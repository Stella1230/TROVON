static void wm8958_micd_set_rate(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint best, i, sysclk, val;\r\nbool idle;\r\nconst struct wm8958_micd_rate *rates;\r\nint num_rates;\r\nidle = !wm8994->jack_mic;\r\nsysclk = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (sysclk & WM8994_SYSCLK_SRC)\r\nsysclk = wm8994->aifclk[1];\r\nelse\r\nsysclk = wm8994->aifclk[0];\r\nif (control->pdata.micd_rates) {\r\nrates = control->pdata.micd_rates;\r\nnum_rates = control->pdata.num_micd_rates;\r\n} else if (wm8994->jackdet) {\r\nrates = jackdet_rates;\r\nnum_rates = ARRAY_SIZE(jackdet_rates);\r\n} else {\r\nrates = micdet_rates;\r\nnum_rates = ARRAY_SIZE(micdet_rates);\r\n}\r\nbest = 0;\r\nfor (i = 0; i < num_rates; i++) {\r\nif (rates[i].idle != idle)\r\ncontinue;\r\nif (abs(rates[i].sysclk - sysclk) <\r\nabs(rates[best].sysclk - sysclk))\r\nbest = i;\r\nelse if (rates[best].idle != idle)\r\nbest = i;\r\n}\r\nval = rates[best].start << WM8958_MICD_BIAS_STARTTIME_SHIFT\r\n| rates[best].rate << WM8958_MICD_RATE_SHIFT;\r\ndev_dbg(codec->dev, "MICD rate %d,%d for %dHz %s\n",\r\nrates[best].start, rates[best].rate, sysclk,\r\nidle ? "idle" : "active");\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_1,\r\nWM8958_MICD_BIAS_STARTTIME_MASK |\r\nWM8958_MICD_RATE_MASK, val);\r\n}\r\nstatic int configure_aif_clock(struct snd_soc_codec *codec, int aif)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint rate;\r\nint reg1 = 0;\r\nint offset;\r\nif (aif)\r\noffset = 4;\r\nelse\r\noffset = 0;\r\nswitch (wm8994->sysclk[aif]) {\r\ncase WM8994_SYSCLK_MCLK1:\r\nrate = wm8994->mclk[0];\r\nbreak;\r\ncase WM8994_SYSCLK_MCLK2:\r\nreg1 |= 0x8;\r\nrate = wm8994->mclk[1];\r\nbreak;\r\ncase WM8994_SYSCLK_FLL1:\r\nreg1 |= 0x10;\r\nrate = wm8994->fll[0].out;\r\nbreak;\r\ncase WM8994_SYSCLK_FLL2:\r\nreg1 |= 0x18;\r\nrate = wm8994->fll[1].out;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (rate >= 13500000) {\r\nrate /= 2;\r\nreg1 |= WM8994_AIF1CLK_DIV;\r\ndev_dbg(codec->dev, "Dividing AIF%d clock to %dHz\n",\r\naif + 1, rate);\r\n}\r\nwm8994->aifclk[aif] = rate;\r\nsnd_soc_update_bits(codec, WM8994_AIF1_CLOCKING_1 + offset,\r\nWM8994_AIF1CLK_SRC_MASK | WM8994_AIF1CLK_DIV,\r\nreg1);\r\nreturn 0;\r\n}\r\nstatic int configure_clock(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint change, new;\r\nconfigure_aif_clock(codec, 0);\r\nconfigure_aif_clock(codec, 1);\r\nif (wm8994->aifclk[0] == wm8994->aifclk[1]) {\r\nwm8958_micd_set_rate(codec);\r\nreturn 0;\r\n}\r\nif (wm8994->aifclk[0] < wm8994->aifclk[1])\r\nnew = WM8994_SYSCLK_SRC;\r\nelse\r\nnew = 0;\r\nchange = snd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8994_SYSCLK_SRC, new);\r\nif (change)\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nwm8958_micd_set_rate(codec);\r\nreturn 0;\r\n}\r\nstatic int check_clk_sys(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nint reg = snd_soc_read(source->codec, WM8994_CLOCKING_1);\r\nconst char *clk;\r\nif (reg & WM8994_SYSCLK_SRC)\r\nclk = "AIF2CLK";\r\nelse\r\nclk = "AIF1CLK";\r\nreturn strcmp(source->name, clk) == 0;\r\n}\r\nstatic int wm8994_put_drc_sw(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint mask, ret;\r\nif (mc->shift == WM8994_AIF1DAC1_DRC_ENA_SHIFT)\r\nmask = WM8994_AIF1ADC1L_DRC_ENA_MASK |\r\nWM8994_AIF1ADC1R_DRC_ENA_MASK;\r\nelse\r\nmask = WM8994_AIF1DAC1_DRC_ENA_MASK;\r\nret = snd_soc_read(codec, mc->reg);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret & mask)\r\nreturn -EINVAL;\r\nreturn snd_soc_put_volsw(kcontrol, ucontrol);\r\n}\r\nstatic void wm8994_set_drc(struct snd_soc_codec *codec, int drc)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint base = wm8994_drc_base[drc];\r\nint cfg = wm8994->drc_cfg[drc];\r\nint save, i;\r\nsave = snd_soc_read(codec, base);\r\nsave &= WM8994_AIF1DAC1_DRC_ENA | WM8994_AIF1ADC1L_DRC_ENA |\r\nWM8994_AIF1ADC1R_DRC_ENA;\r\nfor (i = 0; i < WM8994_DRC_REGS; i++)\r\nsnd_soc_update_bits(codec, base + i, 0xffff,\r\npdata->drc_cfgs[cfg].regs[i]);\r\nsnd_soc_update_bits(codec, base, WM8994_AIF1DAC1_DRC_ENA |\r\nWM8994_AIF1ADC1L_DRC_ENA |\r\nWM8994_AIF1ADC1R_DRC_ENA, save);\r\n}\r\nstatic int wm8994_get_drc(const char *name)\r\n{\r\nif (strcmp(name, "AIF1DRC1 Mode") == 0)\r\nreturn 0;\r\nif (strcmp(name, "AIF1DRC2 Mode") == 0)\r\nreturn 1;\r\nif (strcmp(name, "AIF2DRC Mode") == 0)\r\nreturn 2;\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8994_put_drc_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint drc = wm8994_get_drc(kcontrol->id.name);\r\nint value = ucontrol->value.integer.value[0];\r\nif (drc < 0)\r\nreturn drc;\r\nif (value >= pdata->num_drc_cfgs)\r\nreturn -EINVAL;\r\nwm8994->drc_cfg[drc] = value;\r\nwm8994_set_drc(codec, drc);\r\nreturn 0;\r\n}\r\nstatic int wm8994_get_drc_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint drc = wm8994_get_drc(kcontrol->id.name);\r\nif (drc < 0)\r\nreturn drc;\r\nucontrol->value.enumerated.item[0] = wm8994->drc_cfg[drc];\r\nreturn 0;\r\n}\r\nstatic void wm8994_set_retune_mobile(struct snd_soc_codec *codec, int block)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint base = wm8994_retune_mobile_base[block];\r\nint iface, best, best_val, save, i, cfg;\r\nif (!pdata || !wm8994->num_retune_mobile_texts)\r\nreturn;\r\nswitch (block) {\r\ncase 0:\r\ncase 1:\r\niface = 0;\r\nbreak;\r\ncase 2:\r\niface = 1;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\ncfg = wm8994->retune_mobile_cfg[block];\r\nbest = 0;\r\nbest_val = INT_MAX;\r\nfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\r\nif (strcmp(pdata->retune_mobile_cfgs[i].name,\r\nwm8994->retune_mobile_texts[cfg]) == 0 &&\r\nabs(pdata->retune_mobile_cfgs[i].rate\r\n- wm8994->dac_rates[iface]) < best_val) {\r\nbest = i;\r\nbest_val = abs(pdata->retune_mobile_cfgs[i].rate\r\n- wm8994->dac_rates[iface]);\r\n}\r\n}\r\ndev_dbg(codec->dev, "ReTune Mobile %d %s/%dHz for %dHz sample rate\n",\r\nblock,\r\npdata->retune_mobile_cfgs[best].name,\r\npdata->retune_mobile_cfgs[best].rate,\r\nwm8994->dac_rates[iface]);\r\nsave = snd_soc_read(codec, base);\r\nsave &= WM8994_AIF1DAC1_EQ_ENA;\r\nfor (i = 0; i < WM8994_EQ_REGS; i++)\r\nsnd_soc_update_bits(codec, base + i, 0xffff,\r\npdata->retune_mobile_cfgs[best].regs[i]);\r\nsnd_soc_update_bits(codec, base, WM8994_AIF1DAC1_EQ_ENA, save);\r\n}\r\nstatic int wm8994_get_retune_mobile_block(const char *name)\r\n{\r\nif (strcmp(name, "AIF1.1 EQ Mode") == 0)\r\nreturn 0;\r\nif (strcmp(name, "AIF1.2 EQ Mode") == 0)\r\nreturn 1;\r\nif (strcmp(name, "AIF2 EQ Mode") == 0)\r\nreturn 2;\r\nreturn -EINVAL;\r\n}\r\nstatic int wm8994_put_retune_mobile_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint block = wm8994_get_retune_mobile_block(kcontrol->id.name);\r\nint value = ucontrol->value.integer.value[0];\r\nif (block < 0)\r\nreturn block;\r\nif (value >= pdata->num_retune_mobile_cfgs)\r\nreturn -EINVAL;\r\nwm8994->retune_mobile_cfg[block] = value;\r\nwm8994_set_retune_mobile(codec, block);\r\nreturn 0;\r\n}\r\nstatic int wm8994_get_retune_mobile_enum(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint block = wm8994_get_retune_mobile_block(kcontrol->id.name);\r\nif (block < 0)\r\nreturn block;\r\nucontrol->value.enumerated.item[0] = wm8994->retune_mobile_cfg[block];\r\nreturn 0;\r\n}\r\nstatic void wm1811_jackdet_set_mode(struct snd_soc_codec *codec, u16 mode)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (!wm8994->jackdet || !wm8994->micdet[0].jack)\r\nreturn;\r\nif (wm8994->active_refcount)\r\nmode = WM1811_JACKDET_MODE_AUDIO;\r\nif (mode == wm8994->jackdet_mode)\r\nreturn;\r\nwm8994->jackdet_mode = mode;\r\nif (mode != WM1811_JACKDET_MODE_NONE)\r\nmode = WM1811_JACKDET_MODE_AUDIO;\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM1811_JACKDET_MODE_MASK, mode);\r\n}\r\nstatic void active_reference(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nmutex_lock(&wm8994->accdet_lock);\r\nwm8994->active_refcount++;\r\ndev_dbg(codec->dev, "Active refcount incremented, now %d\n",\r\nwm8994->active_refcount);\r\nwm1811_jackdet_set_mode(codec, WM1811_JACKDET_MODE_AUDIO);\r\nmutex_unlock(&wm8994->accdet_lock);\r\n}\r\nstatic void active_dereference(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nu16 mode;\r\nmutex_lock(&wm8994->accdet_lock);\r\nwm8994->active_refcount--;\r\ndev_dbg(codec->dev, "Active refcount decremented, now %d\n",\r\nwm8994->active_refcount);\r\nif (wm8994->active_refcount == 0) {\r\nif (wm8994->jack_mic || wm8994->mic_detecting)\r\nmode = WM1811_JACKDET_MODE_MIC;\r\nelse\r\nmode = WM1811_JACKDET_MODE_JACK;\r\nwm1811_jackdet_set_mode(codec, mode);\r\n}\r\nmutex_unlock(&wm8994->accdet_lock);\r\n}\r\nstatic int clk_sys_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nreturn configure_clock(codec);\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (wm8994->jackdet && !wm8994->clk_has_run) {\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&wm8994->jackdet_bootstrap,\r\nmsecs_to_jiffies(1000));\r\nwm8994->clk_has_run = true;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nconfigure_clock(codec);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vmid_reference(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\npm_runtime_get_sync(codec->dev);\r\nwm8994->vmid_refcount++;\r\ndev_dbg(codec->dev, "Referencing VMID, refcount is now %d\n",\r\nwm8994->vmid_refcount);\r\nif (wm8994->vmid_refcount == 1) {\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_1,\r\nWM8994_LINEOUT1_DISCH |\r\nWM8994_LINEOUT2_DISCH, 0);\r\nwm_hubs_vmid_ena(codec);\r\nswitch (wm8994->vmid_mode) {\r\ndefault:\r\nWARN_ON(NULL == "Invalid VMID mode");\r\ncase WM8994_VMID_NORMAL:\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM8994_BIAS_SRC |\r\nWM8994_VMID_DISCH |\r\nWM8994_STARTUP_BIAS_ENA |\r\nWM8994_VMID_BUF_ENA |\r\nWM8994_VMID_RAMP_MASK,\r\nWM8994_BIAS_SRC |\r\nWM8994_STARTUP_BIAS_ENA |\r\nWM8994_VMID_BUF_ENA |\r\n(0x2 << WM8994_VMID_RAMP_SHIFT));\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,\r\nWM8994_BIAS_ENA |\r\nWM8994_VMID_SEL_MASK,\r\nWM8994_BIAS_ENA | 0x2);\r\nmsleep(300);\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM8994_VMID_RAMP_MASK |\r\nWM8994_BIAS_SRC,\r\n0);\r\nbreak;\r\ncase WM8994_VMID_FORCE:\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM8994_BIAS_SRC |\r\nWM8994_VMID_DISCH |\r\nWM8994_STARTUP_BIAS_ENA |\r\nWM8994_VMID_BUF_ENA |\r\nWM8994_VMID_RAMP_MASK,\r\nWM8994_BIAS_SRC |\r\nWM8994_STARTUP_BIAS_ENA |\r\nWM8994_VMID_BUF_ENA |\r\n(0x2 << WM8994_VMID_RAMP_SHIFT));\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,\r\nWM8994_BIAS_ENA |\r\nWM8994_VMID_SEL_MASK,\r\nWM8994_BIAS_ENA | 0x2);\r\nmsleep(400);\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM8994_VMID_RAMP_MASK |\r\nWM8994_BIAS_SRC,\r\n0);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void vmid_dereference(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nwm8994->vmid_refcount--;\r\ndev_dbg(codec->dev, "Dereferencing VMID, refcount is now %d\n",\r\nwm8994->vmid_refcount);\r\nif (wm8994->vmid_refcount == 0) {\r\nif (wm8994->hubs.lineout1_se)\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,\r\nWM8994_LINEOUT1N_ENA |\r\nWM8994_LINEOUT1P_ENA,\r\nWM8994_LINEOUT1N_ENA |\r\nWM8994_LINEOUT1P_ENA);\r\nif (wm8994->hubs.lineout2_se)\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,\r\nWM8994_LINEOUT2N_ENA |\r\nWM8994_LINEOUT2P_ENA,\r\nWM8994_LINEOUT2N_ENA |\r\nWM8994_LINEOUT2P_ENA);\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM8994_BIAS_SRC |\r\nWM8994_VMID_DISCH,\r\nWM8994_BIAS_SRC |\r\nWM8994_VMID_DISCH);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,\r\nWM8994_VMID_SEL_MASK, 0);\r\nmsleep(400);\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_1,\r\nWM8994_LINEOUT1_DISCH |\r\nWM8994_LINEOUT2_DISCH,\r\nWM8994_LINEOUT1_DISCH |\r\nWM8994_LINEOUT2_DISCH);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,\r\nWM8994_LINEOUT1N_ENA |\r\nWM8994_LINEOUT1P_ENA |\r\nWM8994_LINEOUT2N_ENA |\r\nWM8994_LINEOUT2P_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_2,\r\nWM8994_BIAS_SRC |\r\nWM8994_STARTUP_BIAS_ENA |\r\nWM8994_VMID_BUF_ENA |\r\nWM8994_VMID_RAMP_MASK, 0);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,\r\nWM8994_VMID_SEL_MASK, 0);\r\n}\r\npm_runtime_put(codec->dev);\r\n}\r\nstatic int vmid_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nvmid_reference(codec);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nvmid_dereference(codec);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool wm8994_check_class_w_digital(struct snd_soc_codec *codec)\r\n{\r\nint source = 0;\r\nint reg, reg_r;\r\nreg = snd_soc_read(codec, WM8994_DAC1_LEFT_MIXER_ROUTING);\r\nswitch (reg) {\r\ncase WM8994_AIF2DACL_TO_DAC1L:\r\ndev_vdbg(codec->dev, "Class W source AIF2DAC\n");\r\nsource = 2 << WM8994_CP_DYN_SRC_SEL_SHIFT;\r\nbreak;\r\ncase WM8994_AIF1DAC2L_TO_DAC1L:\r\ndev_vdbg(codec->dev, "Class W source AIF1DAC2\n");\r\nsource = 1 << WM8994_CP_DYN_SRC_SEL_SHIFT;\r\nbreak;\r\ncase WM8994_AIF1DAC1L_TO_DAC1L:\r\ndev_vdbg(codec->dev, "Class W source AIF1DAC1\n");\r\nsource = 0 << WM8994_CP_DYN_SRC_SEL_SHIFT;\r\nbreak;\r\ndefault:\r\ndev_vdbg(codec->dev, "DAC mixer setting: %x\n", reg);\r\nreturn false;\r\n}\r\nreg_r = snd_soc_read(codec, WM8994_DAC1_RIGHT_MIXER_ROUTING);\r\nif (reg_r != reg) {\r\ndev_vdbg(codec->dev, "Left and right DAC mixers different\n");\r\nreturn false;\r\n}\r\nsnd_soc_update_bits(codec, WM8994_CLASS_W_1,\r\nWM8994_CP_DYN_SRC_SEL_MASK, source);\r\nreturn true;\r\n}\r\nstatic int aif1clk_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint mask = WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC1R_ENA;\r\nint i;\r\nint dac;\r\nint adc;\r\nint val;\r\nswitch (control->type) {\r\ncase WM8994:\r\ncase WM8958:\r\nmask |= WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (wm8994->channels[0] <= 2)\r\nmask &= ~(WM8994_AIF1DAC2L_ENA | WM8994_AIF1DAC2R_ENA);\r\nval = snd_soc_read(codec, WM8994_AIF1_CONTROL_1);\r\nif ((val & WM8994_AIF1ADCL_SRC) &&\r\n(val & WM8994_AIF1ADCR_SRC))\r\nadc = WM8994_AIF1ADC1R_ENA | WM8994_AIF1ADC2R_ENA;\r\nelse if (!(val & WM8994_AIF1ADCL_SRC) &&\r\n!(val & WM8994_AIF1ADCR_SRC))\r\nadc = WM8994_AIF1ADC1L_ENA | WM8994_AIF1ADC2L_ENA;\r\nelse\r\nadc = WM8994_AIF1ADC1R_ENA | WM8994_AIF1ADC2R_ENA |\r\nWM8994_AIF1ADC1L_ENA | WM8994_AIF1ADC2L_ENA;\r\nval = snd_soc_read(codec, WM8994_AIF1_CONTROL_2);\r\nif ((val & WM8994_AIF1DACL_SRC) &&\r\n(val & WM8994_AIF1DACR_SRC))\r\ndac = WM8994_AIF1DAC1R_ENA | WM8994_AIF1DAC2R_ENA;\r\nelse if (!(val & WM8994_AIF1DACL_SRC) &&\r\n!(val & WM8994_AIF1DACR_SRC))\r\ndac = WM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC2L_ENA;\r\nelse\r\ndac = WM8994_AIF1DAC1R_ENA | WM8994_AIF1DAC2R_ENA |\r\nWM8994_AIF1DAC1L_ENA | WM8994_AIF1DAC2L_ENA;\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,\r\nmask, adc);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,\r\nmask, dac);\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8994_AIF1DSPCLK_ENA |\r\nWM8994_SYSDSPCLK_ENA,\r\nWM8994_AIF1DSPCLK_ENA |\r\nWM8994_SYSDSPCLK_ENA);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4, mask,\r\nWM8994_AIF1ADC1R_ENA |\r\nWM8994_AIF1ADC1L_ENA |\r\nWM8994_AIF1ADC2R_ENA |\r\nWM8994_AIF1ADC2L_ENA);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5, mask,\r\nWM8994_AIF1DAC1R_ENA |\r\nWM8994_AIF1DAC1L_ENA |\r\nWM8994_AIF1DAC2R_ENA |\r\nWM8994_AIF1DAC2L_ENA);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nfor (i = 0; i < ARRAY_SIZE(wm8994_vu_bits); i++)\r\nsnd_soc_write(codec, wm8994_vu_bits[i].reg,\r\nsnd_soc_read(codec,\r\nwm8994_vu_bits[i].reg));\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,\r\nmask, 0);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,\r\nmask, 0);\r\nval = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (val & WM8994_AIF2DSPCLK_ENA)\r\nval = WM8994_SYSDSPCLK_ENA;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8994_SYSDSPCLK_ENA |\r\nWM8994_AIF1DSPCLK_ENA, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aif2clk_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nint i;\r\nint dac;\r\nint adc;\r\nint val;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nval = snd_soc_read(codec, WM8994_AIF2_CONTROL_1);\r\nif ((val & WM8994_AIF2ADCL_SRC) &&\r\n(val & WM8994_AIF2ADCR_SRC))\r\nadc = WM8994_AIF2ADCR_ENA;\r\nelse if (!(val & WM8994_AIF2ADCL_SRC) &&\r\n!(val & WM8994_AIF2ADCR_SRC))\r\nadc = WM8994_AIF2ADCL_ENA;\r\nelse\r\nadc = WM8994_AIF2ADCL_ENA | WM8994_AIF2ADCR_ENA;\r\nval = snd_soc_read(codec, WM8994_AIF2_CONTROL_2);\r\nif ((val & WM8994_AIF2DACL_SRC) &&\r\n(val & WM8994_AIF2DACR_SRC))\r\ndac = WM8994_AIF2DACR_ENA;\r\nelse if (!(val & WM8994_AIF2DACL_SRC) &&\r\n!(val & WM8994_AIF2DACR_SRC))\r\ndac = WM8994_AIF2DACL_ENA;\r\nelse\r\ndac = WM8994_AIF2DACL_ENA | WM8994_AIF2DACR_ENA;\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,\r\nWM8994_AIF2ADCL_ENA |\r\nWM8994_AIF2ADCR_ENA, adc);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,\r\nWM8994_AIF2DACL_ENA |\r\nWM8994_AIF2DACR_ENA, dac);\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8994_AIF2DSPCLK_ENA |\r\nWM8994_SYSDSPCLK_ENA,\r\nWM8994_AIF2DSPCLK_ENA |\r\nWM8994_SYSDSPCLK_ENA);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,\r\nWM8994_AIF2ADCL_ENA |\r\nWM8994_AIF2ADCR_ENA,\r\nWM8994_AIF2ADCL_ENA |\r\nWM8994_AIF2ADCR_ENA);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,\r\nWM8994_AIF2DACL_ENA |\r\nWM8994_AIF2DACR_ENA,\r\nWM8994_AIF2DACL_ENA |\r\nWM8994_AIF2DACR_ENA);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nfor (i = 0; i < ARRAY_SIZE(wm8994_vu_bits); i++)\r\nsnd_soc_write(codec, wm8994_vu_bits[i].reg,\r\nsnd_soc_read(codec,\r\nwm8994_vu_bits[i].reg));\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,\r\nWM8994_AIF2DACL_ENA |\r\nWM8994_AIF2DACR_ENA, 0);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,\r\nWM8994_AIF2ADCL_ENA |\r\nWM8994_AIF2ADCR_ENA, 0);\r\nval = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (val & WM8994_AIF1DSPCLK_ENA)\r\nval = WM8994_SYSDSPCLK_ENA;\r\nelse\r\nval = 0;\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_1,\r\nWM8994_SYSDSPCLK_ENA |\r\nWM8994_AIF2DSPCLK_ENA, val);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aif1clk_late_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nwm8994->aif1clk_enable = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nwm8994->aif1clk_disable = 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aif2clk_late_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nwm8994->aif2clk_enable = 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nwm8994->aif2clk_disable = 1;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int late_enable_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (wm8994->aif1clk_enable) {\r\naif1clk_ev(w, kcontrol, SND_SOC_DAPM_PRE_PMU);\r\nsnd_soc_update_bits(codec, WM8994_AIF1_CLOCKING_1,\r\nWM8994_AIF1CLK_ENA_MASK,\r\nWM8994_AIF1CLK_ENA);\r\naif1clk_ev(w, kcontrol, SND_SOC_DAPM_POST_PMU);\r\nwm8994->aif1clk_enable = 0;\r\n}\r\nif (wm8994->aif2clk_enable) {\r\naif2clk_ev(w, kcontrol, SND_SOC_DAPM_PRE_PMU);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_CLOCKING_1,\r\nWM8994_AIF2CLK_ENA_MASK,\r\nWM8994_AIF2CLK_ENA);\r\naif2clk_ev(w, kcontrol, SND_SOC_DAPM_POST_PMU);\r\nwm8994->aif2clk_enable = 0;\r\n}\r\nbreak;\r\n}\r\nwm8958_aif_ev(w, kcontrol, event);\r\nreturn 0;\r\n}\r\nstatic int late_disable_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMD:\r\nif (wm8994->aif1clk_disable) {\r\naif1clk_ev(w, kcontrol, SND_SOC_DAPM_PRE_PMD);\r\nsnd_soc_update_bits(codec, WM8994_AIF1_CLOCKING_1,\r\nWM8994_AIF1CLK_ENA_MASK, 0);\r\naif1clk_ev(w, kcontrol, SND_SOC_DAPM_POST_PMD);\r\nwm8994->aif1clk_disable = 0;\r\n}\r\nif (wm8994->aif2clk_disable) {\r\naif2clk_ev(w, kcontrol, SND_SOC_DAPM_PRE_PMD);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_CLOCKING_1,\r\nWM8994_AIF2CLK_ENA_MASK, 0);\r\naif2clk_ev(w, kcontrol, SND_SOC_DAPM_POST_PMD);\r\nwm8994->aif2clk_disable = 0;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adc_mux_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nlate_enable_ev(w, kcontrol, event);\r\nreturn 0;\r\n}\r\nstatic int micbias_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nlate_enable_ev(w, kcontrol, event);\r\nreturn 0;\r\n}\r\nstatic int dac_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nunsigned int mask = 1 << w->shift;\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,\r\nmask, mask);\r\nreturn 0;\r\n}\r\nstatic int post_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\ndev_dbg(codec->dev, "SRC status: %x\n",\r\nsnd_soc_read(codec,\r\nWM8994_RATE_STATUS));\r\nreturn 0;\r\n}\r\nstatic int wm8994_put_class_w(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nint ret;\r\nret = snd_soc_dapm_put_volsw(kcontrol, ucontrol);\r\nwm_hubs_update_class_w(codec);\r\nreturn ret;\r\n}\r\nstatic int wm8994_get_fll_config(struct wm8994 *control, struct fll_div *fll,\r\nint freq_in, int freq_out)\r\n{\r\nu64 Kpart;\r\nunsigned int K, Ndiv, Nmod, gcd_fll;\r\npr_debug("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);\r\nfll->clk_ref_div = 0;\r\nwhile (freq_in > 13500000) {\r\nfll->clk_ref_div++;\r\nfreq_in /= 2;\r\nif (fll->clk_ref_div > 3)\r\nreturn -EINVAL;\r\n}\r\npr_debug("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);\r\nfll->outdiv = 3;\r\nwhile (freq_out * (fll->outdiv + 1) < 90000000) {\r\nfll->outdiv++;\r\nif (fll->outdiv > 63)\r\nreturn -EINVAL;\r\n}\r\nfreq_out *= fll->outdiv + 1;\r\npr_debug("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);\r\nif (freq_in > 1000000) {\r\nfll->fll_fratio = 0;\r\n} else if (freq_in > 256000) {\r\nfll->fll_fratio = 1;\r\nfreq_in *= 2;\r\n} else if (freq_in > 128000) {\r\nfll->fll_fratio = 2;\r\nfreq_in *= 4;\r\n} else if (freq_in > 64000) {\r\nfll->fll_fratio = 3;\r\nfreq_in *= 8;\r\n} else {\r\nfll->fll_fratio = 4;\r\nfreq_in *= 16;\r\n}\r\npr_debug("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);\r\nNdiv = freq_out / freq_in;\r\nfll->n = Ndiv;\r\nNmod = freq_out % freq_in;\r\npr_debug("Nmod=%d\n", Nmod);\r\nswitch (control->type) {\r\ncase WM8994:\r\nKpart = FIXED_FLL_SIZE * (long long)Nmod;\r\ndo_div(Kpart, freq_in);\r\nK = Kpart & 0xFFFFFFFF;\r\nif ((K % 10) >= 5)\r\nK += 5;\r\nfll->k = K / 10;\r\nfll->lambda = 0;\r\npr_debug("N=%x K=%x\n", fll->n, fll->k);\r\nbreak;\r\ndefault:\r\ngcd_fll = gcd(freq_out, freq_in);\r\nfll->k = (freq_out - (freq_in * fll->n)) / gcd_fll;\r\nfll->lambda = freq_in / gcd_fll;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _wm8994_set_fll(struct snd_soc_codec *codec, int id, int src,\r\nunsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint reg_offset, ret;\r\nstruct fll_div fll;\r\nu16 reg, clk1, aif_reg, aif_src;\r\nunsigned long timeout;\r\nbool was_enabled;\r\nswitch (id) {\r\ncase WM8994_FLL1:\r\nreg_offset = 0;\r\nid = 0;\r\naif_src = 0x10;\r\nbreak;\r\ncase WM8994_FLL2:\r\nreg_offset = 0x20;\r\nid = 1;\r\naif_src = 0x18;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg = snd_soc_read(codec, WM8994_FLL1_CONTROL_1 + reg_offset);\r\nwas_enabled = reg & WM8994_FLL1_ENA;\r\nswitch (src) {\r\ncase 0:\r\nif (freq_out)\r\nreturn -EINVAL;\r\nsrc = wm8994->fll[id].src;\r\nbreak;\r\ncase WM8994_FLL_SRC_MCLK1:\r\ncase WM8994_FLL_SRC_MCLK2:\r\ncase WM8994_FLL_SRC_LRCLK:\r\ncase WM8994_FLL_SRC_BCLK:\r\nbreak;\r\ncase WM8994_FLL_SRC_INTERNAL:\r\nfreq_in = 12000000;\r\nfreq_out = 12000000;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (wm8994->fll[id].src == src &&\r\nwm8994->fll[id].in == freq_in && wm8994->fll[id].out == freq_out)\r\nreturn 0;\r\nif (freq_out)\r\nret = wm8994_get_fll_config(control, &fll, freq_in, freq_out);\r\nelse\r\nret = wm8994_get_fll_config(control, &fll, wm8994->fll[id].in,\r\nwm8994->fll[id].out);\r\nif (ret < 0)\r\nreturn ret;\r\nclk1 = snd_soc_read(codec, WM8994_CLOCKING_1);\r\nif (clk1 & WM8994_SYSCLK_SRC)\r\naif_reg = WM8994_AIF2_CLOCKING_1;\r\nelse\r\naif_reg = WM8994_AIF1_CLOCKING_1;\r\nreg = snd_soc_read(codec, aif_reg);\r\nif ((reg & WM8994_AIF1CLK_ENA) &&\r\n(reg & WM8994_AIF1CLK_SRC_MASK) == aif_src) {\r\ndev_err(codec->dev, "FLL%d is currently providing SYSCLK\n",\r\nid + 1);\r\nreturn -EBUSY;\r\n}\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_1 + reg_offset,\r\nWM8994_FLL1_ENA, 0);\r\nif (wm8994->fll_byp && src == WM8994_FLL_SRC_BCLK &&\r\nfreq_in == freq_out && freq_out) {\r\ndev_dbg(codec->dev, "Bypassing FLL%d\n", id + 1);\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_5 + reg_offset,\r\nWM8958_FLL1_BYP, WM8958_FLL1_BYP);\r\ngoto out;\r\n}\r\nreg = (fll.outdiv << WM8994_FLL1_OUTDIV_SHIFT) |\r\n(fll.fll_fratio << WM8994_FLL1_FRATIO_SHIFT);\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_2 + reg_offset,\r\nWM8994_FLL1_OUTDIV_MASK |\r\nWM8994_FLL1_FRATIO_MASK, reg);\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_3 + reg_offset,\r\nWM8994_FLL1_K_MASK, fll.k);\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_4 + reg_offset,\r\nWM8994_FLL1_N_MASK,\r\nfll.n << WM8994_FLL1_N_SHIFT);\r\nif (fll.lambda) {\r\nsnd_soc_update_bits(codec, WM8958_FLL1_EFS_1 + reg_offset,\r\nWM8958_FLL1_LAMBDA_MASK,\r\nfll.lambda);\r\nsnd_soc_update_bits(codec, WM8958_FLL1_EFS_2 + reg_offset,\r\nWM8958_FLL1_EFS_ENA, WM8958_FLL1_EFS_ENA);\r\n} else {\r\nsnd_soc_update_bits(codec, WM8958_FLL1_EFS_2 + reg_offset,\r\nWM8958_FLL1_EFS_ENA, 0);\r\n}\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_5 + reg_offset,\r\nWM8994_FLL1_FRC_NCO | WM8958_FLL1_BYP |\r\nWM8994_FLL1_REFCLK_DIV_MASK |\r\nWM8994_FLL1_REFCLK_SRC_MASK,\r\n((src == WM8994_FLL_SRC_INTERNAL)\r\n<< WM8994_FLL1_FRC_NCO_SHIFT) |\r\n(fll.clk_ref_div << WM8994_FLL1_REFCLK_DIV_SHIFT) |\r\n(src - 1));\r\ntry_wait_for_completion(&wm8994->fll_locked[id]);\r\nif (freq_out) {\r\nif (!was_enabled) {\r\nactive_reference(codec);\r\nswitch (control->type) {\r\ncase WM8994:\r\nvmid_reference(codec);\r\nbreak;\r\ncase WM8958:\r\nif (control->revision < 1)\r\nvmid_reference(codec);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreg = WM8994_FLL1_ENA;\r\nif (fll.k)\r\nreg |= WM8994_FLL1_FRAC;\r\nif (src == WM8994_FLL_SRC_INTERNAL)\r\nreg |= WM8994_FLL1_OSC_ENA;\r\nsnd_soc_update_bits(codec, WM8994_FLL1_CONTROL_1 + reg_offset,\r\nWM8994_FLL1_ENA | WM8994_FLL1_OSC_ENA |\r\nWM8994_FLL1_FRAC, reg);\r\nif (wm8994->fll_locked_irq) {\r\ntimeout = wait_for_completion_timeout(&wm8994->fll_locked[id],\r\nmsecs_to_jiffies(10));\r\nif (timeout == 0)\r\ndev_warn(codec->dev,\r\n"Timed out waiting for FLL lock\n");\r\n} else {\r\nmsleep(5);\r\n}\r\n} else {\r\nif (was_enabled) {\r\nswitch (control->type) {\r\ncase WM8994:\r\nvmid_dereference(codec);\r\nbreak;\r\ncase WM8958:\r\nif (control->revision < 1)\r\nvmid_dereference(codec);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nactive_dereference(codec);\r\n}\r\n}\r\nout:\r\nwm8994->fll[id].in = freq_in;\r\nwm8994->fll[id].out = freq_out;\r\nwm8994->fll[id].src = src;\r\nconfigure_clock(codec);\r\nif (max(wm8994->aifclk[0], wm8994->aifclk[1]) < 50000) {\r\ndev_dbg(codec->dev, "Configuring AIFs for 128fs\n");\r\nwm8994->aifdiv[0] = snd_soc_read(codec, WM8994_AIF1_RATE)\r\n& WM8994_AIF1CLK_RATE_MASK;\r\nwm8994->aifdiv[1] = snd_soc_read(codec, WM8994_AIF2_RATE)\r\n& WM8994_AIF1CLK_RATE_MASK;\r\nsnd_soc_update_bits(codec, WM8994_AIF1_RATE,\r\nWM8994_AIF1CLK_RATE_MASK, 0x1);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_RATE,\r\nWM8994_AIF2CLK_RATE_MASK, 0x1);\r\n} else if (wm8994->aifdiv[0]) {\r\nsnd_soc_update_bits(codec, WM8994_AIF1_RATE,\r\nWM8994_AIF1CLK_RATE_MASK,\r\nwm8994->aifdiv[0]);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_RATE,\r\nWM8994_AIF2CLK_RATE_MASK,\r\nwm8994->aifdiv[1]);\r\nwm8994->aifdiv[0] = 0;\r\nwm8994->aifdiv[1] = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t wm8994_fll_locked_irq(int irq, void *data)\r\n{\r\nstruct completion *completion = data;\r\ncomplete(completion);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8994_set_fll(struct snd_soc_dai *dai, int id, int src,\r\nunsigned int freq_in, unsigned int freq_out)\r\n{\r\nreturn _wm8994_set_fll(dai->codec, id, src, freq_in, freq_out);\r\n}\r\nstatic int wm8994_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nswitch (dai->id) {\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (clk_id) {\r\ncase WM8994_SYSCLK_MCLK1:\r\nwm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK1;\r\nwm8994->mclk[0] = freq;\r\ndev_dbg(dai->dev, "AIF%d using MCLK1 at %uHz\n",\r\ndai->id, freq);\r\nbreak;\r\ncase WM8994_SYSCLK_MCLK2:\r\nwm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_MCLK2;\r\nwm8994->mclk[1] = freq;\r\ndev_dbg(dai->dev, "AIF%d using MCLK2 at %uHz\n",\r\ndai->id, freq);\r\nbreak;\r\ncase WM8994_SYSCLK_FLL1:\r\nwm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_FLL1;\r\ndev_dbg(dai->dev, "AIF%d using FLL1\n", dai->id);\r\nbreak;\r\ncase WM8994_SYSCLK_FLL2:\r\nwm8994->sysclk[dai->id - 1] = WM8994_SYSCLK_FLL2;\r\ndev_dbg(dai->dev, "AIF%d using FLL2\n", dai->id);\r\nbreak;\r\ncase WM8994_SYSCLK_OPCLK:\r\nif (freq) {\r\nfor (i = 0; i < ARRAY_SIZE(opclk_divs); i++)\r\nif (opclk_divs[i] == freq)\r\nbreak;\r\nif (i == ARRAY_SIZE(opclk_divs))\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, WM8994_CLOCKING_2,\r\nWM8994_OPCLK_DIV_MASK, i);\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2,\r\nWM8994_OPCLK_ENA, WM8994_OPCLK_ENA);\r\n} else {\r\nsnd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2,\r\nWM8994_OPCLK_ENA, 0);\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nconfigure_clock(codec);\r\nif (max(wm8994->aifclk[0], wm8994->aifclk[1]) < 50000) {\r\ndev_dbg(codec->dev, "Configuring AIFs for 128fs\n");\r\nwm8994->aifdiv[0] = snd_soc_read(codec, WM8994_AIF1_RATE)\r\n& WM8994_AIF1CLK_RATE_MASK;\r\nwm8994->aifdiv[1] = snd_soc_read(codec, WM8994_AIF2_RATE)\r\n& WM8994_AIF1CLK_RATE_MASK;\r\nsnd_soc_update_bits(codec, WM8994_AIF1_RATE,\r\nWM8994_AIF1CLK_RATE_MASK, 0x1);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_RATE,\r\nWM8994_AIF2CLK_RATE_MASK, 0x1);\r\n} else if (wm8994->aifdiv[0]) {\r\nsnd_soc_update_bits(codec, WM8994_AIF1_RATE,\r\nWM8994_AIF1CLK_RATE_MASK,\r\nwm8994->aifdiv[0]);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_RATE,\r\nWM8994_AIF2CLK_RATE_MASK,\r\nwm8994->aifdiv[1]);\r\nwm8994->aifdiv[0] = 0;\r\nwm8994->aifdiv[1] = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8994_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nwm_hubs_set_bias_level(codec, level);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nswitch (control->type) {\r\ncase WM8958:\r\ncase WM1811:\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS1,\r\nWM8958_MICB1_MODE, 0);\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS2,\r\nWM8958_MICB2_MODE, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY)\r\nactive_reference(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nswitch (control->type) {\r\ncase WM8958:\r\nif (control->revision == 0) {\r\nsnd_soc_update_bits(codec,\r\nWM8958_CHARGE_PUMP_2,\r\nWM8958_CP_DISCH,\r\nWM8958_CP_DISCH);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, WM8994_ANTIPOP_1,\r\nWM8994_LINEOUT1_DISCH |\r\nWM8994_LINEOUT2_DISCH,\r\nWM8994_LINEOUT1_DISCH |\r\nWM8994_LINEOUT2_DISCH);\r\n}\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_PREPARE)\r\nactive_dereference(codec);\r\nswitch (control->type) {\r\ncase WM8958:\r\ncase WM1811:\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS1,\r\nWM8958_MICB1_MODE,\r\nWM8958_MICB1_MODE);\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS2,\r\nWM8958_MICB2_MODE,\r\nWM8958_MICB2_MODE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_STANDBY)\r\nwm8994->cur_fw = NULL;\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nint wm8994_vmid_mode(struct snd_soc_codec *codec, enum wm8994_vmid_mode mode)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nswitch (mode) {\r\ncase WM8994_VMID_NORMAL:\r\nif (wm8994->hubs.lineout1_se) {\r\nsnd_soc_dapm_disable_pin(&codec->dapm,\r\n"LINEOUT1N Driver");\r\nsnd_soc_dapm_disable_pin(&codec->dapm,\r\n"LINEOUT1P Driver");\r\n}\r\nif (wm8994->hubs.lineout2_se) {\r\nsnd_soc_dapm_disable_pin(&codec->dapm,\r\n"LINEOUT2N Driver");\r\nsnd_soc_dapm_disable_pin(&codec->dapm,\r\n"LINEOUT2P Driver");\r\n}\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nwm8994->vmid_mode = mode;\r\nbreak;\r\ncase WM8994_VMID_FORCE:\r\nif (wm8994->hubs.lineout1_se) {\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"LINEOUT1N Driver");\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"LINEOUT1P Driver");\r\n}\r\nif (wm8994->hubs.lineout2_se) {\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"LINEOUT2N Driver");\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"LINEOUT2P Driver");\r\n}\r\nwm8994->vmid_mode = mode;\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8994_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint ms_reg;\r\nint aif1_reg;\r\nint dac_reg;\r\nint adc_reg;\r\nint ms = 0;\r\nint aif1 = 0;\r\nint lrclk = 0;\r\nswitch (dai->id) {\r\ncase 1:\r\nms_reg = WM8994_AIF1_MASTER_SLAVE;\r\naif1_reg = WM8994_AIF1_CONTROL_1;\r\ndac_reg = WM8994_AIF1DAC_LRCLK;\r\nadc_reg = WM8994_AIF1ADC_LRCLK;\r\nbreak;\r\ncase 2:\r\nms_reg = WM8994_AIF2_MASTER_SLAVE;\r\naif1_reg = WM8994_AIF2_CONTROL_1;\r\ndac_reg = WM8994_AIF1DAC_LRCLK;\r\nadc_reg = WM8994_AIF1ADC_LRCLK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nms = WM8994_AIF1_MSTR;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif1 |= WM8994_AIF1_LRCLK_INV;\r\nlrclk |= WM8958_AIF1_LRCLK_INV;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\naif1 |= 0x18;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\naif1 |= 0x10;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif1 |= 0x8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8994_AIF1_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif1 |= WM8994_AIF1_BCLK_INV | WM8994_AIF1_LRCLK_INV;\r\nlrclk |= WM8958_AIF1_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif1 |= WM8994_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif1 |= WM8994_AIF1_LRCLK_INV;\r\nlrclk |= WM8958_AIF1_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (control->type) {\r\ncase WM1811:\r\ncase WM8958:\r\nif (dai->id == 2)\r\nsnd_soc_update_bits(codec, WM8958_AIF3_CONTROL_1,\r\nWM8994_AIF1_LRCLK_INV |\r\nWM8958_AIF3_FMT_MASK, aif1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, aif1_reg,\r\nWM8994_AIF1_BCLK_INV | WM8994_AIF1_LRCLK_INV |\r\nWM8994_AIF1_FMT_MASK,\r\naif1);\r\nsnd_soc_update_bits(codec, ms_reg, WM8994_AIF1_MSTR,\r\nms);\r\nsnd_soc_update_bits(codec, dac_reg,\r\nWM8958_AIF1_LRCLK_INV, lrclk);\r\nsnd_soc_update_bits(codec, adc_reg,\r\nWM8958_AIF1_LRCLK_INV, lrclk);\r\nreturn 0;\r\n}\r\nstatic int wm8994_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint aif1_reg;\r\nint aif2_reg;\r\nint bclk_reg;\r\nint lrclk_reg;\r\nint rate_reg;\r\nint aif1 = 0;\r\nint aif2 = 0;\r\nint bclk = 0;\r\nint lrclk = 0;\r\nint rate_val = 0;\r\nint id = dai->id - 1;\r\nint i, cur_val, best_val, bclk_rate, best;\r\nswitch (dai->id) {\r\ncase 1:\r\naif1_reg = WM8994_AIF1_CONTROL_1;\r\naif2_reg = WM8994_AIF1_CONTROL_2;\r\nbclk_reg = WM8994_AIF1_BCLK;\r\nrate_reg = WM8994_AIF1_RATE;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\r\nwm8994->lrclk_shared[0]) {\r\nlrclk_reg = WM8994_AIF1DAC_LRCLK;\r\n} else {\r\nlrclk_reg = WM8994_AIF1ADC_LRCLK;\r\ndev_dbg(codec->dev, "AIF1 using split LRCLK\n");\r\n}\r\nbreak;\r\ncase 2:\r\naif1_reg = WM8994_AIF2_CONTROL_1;\r\naif2_reg = WM8994_AIF2_CONTROL_2;\r\nbclk_reg = WM8994_AIF2_BCLK;\r\nrate_reg = WM8994_AIF2_RATE;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK ||\r\nwm8994->lrclk_shared[1]) {\r\nlrclk_reg = WM8994_AIF2DAC_LRCLK;\r\n} else {\r\nlrclk_reg = WM8994_AIF2ADC_LRCLK;\r\ndev_dbg(codec->dev, "AIF2 using split LRCLK\n");\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbclk_rate = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbclk_rate *= 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\nbclk_rate *= 20;\r\naif1 |= 0x20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbclk_rate *= 24;\r\naif1 |= 0x40;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nbclk_rate *= 32;\r\naif1 |= 0x60;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nwm8994->channels[id] = params_channels(params);\r\nif (pdata->max_channels_clocked[id] &&\r\nwm8994->channels[id] > pdata->max_channels_clocked[id]) {\r\ndev_dbg(dai->dev, "Constraining channels to %d from %d\n",\r\npdata->max_channels_clocked[id], wm8994->channels[id]);\r\nwm8994->channels[id] = pdata->max_channels_clocked[id];\r\n}\r\nswitch (wm8994->channels[id]) {\r\ncase 1:\r\ncase 2:\r\nbclk_rate *= 2;\r\nbreak;\r\ndefault:\r\nbclk_rate *= 4;\r\nbreak;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(srs); i++)\r\nif (srs[i].rate == params_rate(params))\r\nbreak;\r\nif (i == ARRAY_SIZE(srs))\r\nreturn -EINVAL;\r\nrate_val |= srs[i].val << WM8994_AIF1_SR_SHIFT;\r\ndev_dbg(dai->dev, "Sample rate is %dHz\n", srs[i].rate);\r\ndev_dbg(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",\r\ndai->id, wm8994->aifclk[id], bclk_rate);\r\nif (wm8994->channels[id] == 1 &&\r\n(snd_soc_read(codec, aif1_reg) & 0x18) == 0x18)\r\naif2 |= WM8994_AIF1_MONO;\r\nif (wm8994->aifclk[id] == 0) {\r\ndev_err(dai->dev, "AIF%dCLK not configured\n", dai->id);\r\nreturn -EINVAL;\r\n}\r\nbest = 0;\r\nbest_val = abs((fs_ratios[0] * params_rate(params))\r\n- wm8994->aifclk[id]);\r\nfor (i = 1; i < ARRAY_SIZE(fs_ratios); i++) {\r\ncur_val = abs((fs_ratios[i] * params_rate(params))\r\n- wm8994->aifclk[id]);\r\nif (cur_val >= best_val)\r\ncontinue;\r\nbest = i;\r\nbest_val = cur_val;\r\n}\r\ndev_dbg(dai->dev, "Selected AIF%dCLK/fs = %d\n",\r\ndai->id, fs_ratios[best]);\r\nrate_val |= best;\r\nbest = 0;\r\nfor (i = 0; i < ARRAY_SIZE(bclk_divs); i++) {\r\ncur_val = (wm8994->aifclk[id] * 10 / bclk_divs[i]) - bclk_rate;\r\nif (cur_val < 0)\r\nbreak;\r\nbest = i;\r\n}\r\nbclk_rate = wm8994->aifclk[id] * 10 / bclk_divs[best];\r\ndev_dbg(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",\r\nbclk_divs[best], bclk_rate);\r\nbclk |= best << WM8994_AIF1_BCLK_DIV_SHIFT;\r\nlrclk = bclk_rate / params_rate(params);\r\nif (!lrclk) {\r\ndev_err(dai->dev, "Unable to generate LRCLK from %dHz BCLK\n",\r\nbclk_rate);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",\r\nlrclk, bclk_rate / lrclk);\r\nsnd_soc_update_bits(codec, aif1_reg, WM8994_AIF1_WL_MASK, aif1);\r\nsnd_soc_update_bits(codec, aif2_reg, WM8994_AIF1_MONO, aif2);\r\nsnd_soc_update_bits(codec, bclk_reg, WM8994_AIF1_BCLK_DIV_MASK, bclk);\r\nsnd_soc_update_bits(codec, lrclk_reg, WM8994_AIF1DAC_RATE_MASK,\r\nlrclk);\r\nsnd_soc_update_bits(codec, rate_reg, WM8994_AIF1_SR_MASK |\r\nWM8994_AIF1CLK_RATE_MASK, rate_val);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nswitch (dai->id) {\r\ncase 1:\r\nwm8994->dac_rates[0] = params_rate(params);\r\nwm8994_set_retune_mobile(codec, 0);\r\nwm8994_set_retune_mobile(codec, 1);\r\nbreak;\r\ncase 2:\r\nwm8994->dac_rates[1] = params_rate(params);\r\nwm8994_set_retune_mobile(codec, 2);\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int wm8994_aif3_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint aif1_reg;\r\nint aif1 = 0;\r\nswitch (dai->id) {\r\ncase 3:\r\nswitch (control->type) {\r\ncase WM1811:\r\ncase WM8958:\r\naif1_reg = WM8958_AIF3_CONTROL_1;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\naif1 |= 0x20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\naif1 |= 0x40;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\naif1 |= 0x60;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_update_bits(codec, aif1_reg, WM8994_AIF1_WL_MASK, aif1);\r\n}\r\nstatic int wm8994_aif_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint mute_reg;\r\nint reg;\r\nswitch (codec_dai->id) {\r\ncase 1:\r\nmute_reg = WM8994_AIF1_DAC1_FILTERS_1;\r\nbreak;\r\ncase 2:\r\nmute_reg = WM8994_AIF2_DAC_FILTERS_1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (mute)\r\nreg = WM8994_AIF1DAC1_MUTE;\r\nelse\r\nreg = 0;\r\nsnd_soc_update_bits(codec, mute_reg, WM8994_AIF1DAC1_MUTE, reg);\r\nreturn 0;\r\n}\r\nstatic int wm8994_set_tristate(struct snd_soc_dai *codec_dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint reg, val, mask;\r\nswitch (codec_dai->id) {\r\ncase 1:\r\nreg = WM8994_AIF1_MASTER_SLAVE;\r\nmask = WM8994_AIF1_TRI;\r\nbreak;\r\ncase 2:\r\nreg = WM8994_AIF2_MASTER_SLAVE;\r\nmask = WM8994_AIF2_TRI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (tristate)\r\nval = mask;\r\nelse\r\nval = 0;\r\nreturn snd_soc_update_bits(codec, reg, mask, val);\r\n}\r\nstatic int wm8994_aif2_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nsnd_soc_update_bits(codec, WM8994_GPIO_3,\r\nWM8994_GPN_PU | WM8994_GPN_PD, 0);\r\nsnd_soc_update_bits(codec, WM8994_GPIO_4,\r\nWM8994_GPN_PU | WM8994_GPN_PD, 0);\r\nsnd_soc_update_bits(codec, WM8994_GPIO_5,\r\nWM8994_GPN_PU | WM8994_GPN_PD, 0);\r\nreturn 0;\r\n}\r\nstatic int wm8994_codec_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->fll); i++) {\r\nmemcpy(&wm8994->fll_suspend[i], &wm8994->fll[i],\r\nsizeof(struct wm8994_fll_config));\r\nret = _wm8994_set_fll(codec, i + 1, 0, 0, 0);\r\nif (ret < 0)\r\ndev_warn(codec->dev, "Failed to stop FLL%d: %d\n",\r\ni + 1, ret);\r\n}\r\nwm8994_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int wm8994_codec_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint i, ret;\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->fll); i++) {\r\nif (!wm8994->fll_suspend[i].out)\r\ncontinue;\r\nret = _wm8994_set_fll(codec, i + 1,\r\nwm8994->fll_suspend[i].src,\r\nwm8994->fll_suspend[i].in,\r\nwm8994->fll_suspend[i].out);\r\nif (ret < 0)\r\ndev_warn(codec->dev, "Failed to restore FLL%d: %d\n",\r\ni + 1, ret);\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm8994_handle_retune_mobile_pdata(struct wm8994_priv *wm8994)\r\n{\r\nstruct snd_soc_codec *codec = wm8994->hubs.codec;\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nstruct snd_kcontrol_new controls[] = {\r\nSOC_ENUM_EXT("AIF1.1 EQ Mode",\r\nwm8994->retune_mobile_enum,\r\nwm8994_get_retune_mobile_enum,\r\nwm8994_put_retune_mobile_enum),\r\nSOC_ENUM_EXT("AIF1.2 EQ Mode",\r\nwm8994->retune_mobile_enum,\r\nwm8994_get_retune_mobile_enum,\r\nwm8994_put_retune_mobile_enum),\r\nSOC_ENUM_EXT("AIF2 EQ Mode",\r\nwm8994->retune_mobile_enum,\r\nwm8994_get_retune_mobile_enum,\r\nwm8994_put_retune_mobile_enum),\r\n};\r\nint ret, i, j;\r\nconst char **t;\r\nwm8994->num_retune_mobile_texts = 0;\r\nwm8994->retune_mobile_texts = NULL;\r\nfor (i = 0; i < pdata->num_retune_mobile_cfgs; i++) {\r\nfor (j = 0; j < wm8994->num_retune_mobile_texts; j++) {\r\nif (strcmp(pdata->retune_mobile_cfgs[i].name,\r\nwm8994->retune_mobile_texts[j]) == 0)\r\nbreak;\r\n}\r\nif (j != wm8994->num_retune_mobile_texts)\r\ncontinue;\r\nt = krealloc(wm8994->retune_mobile_texts,\r\nsizeof(char *) *\r\n(wm8994->num_retune_mobile_texts + 1),\r\nGFP_KERNEL);\r\nif (t == NULL)\r\ncontinue;\r\nt[wm8994->num_retune_mobile_texts] =\r\npdata->retune_mobile_cfgs[i].name;\r\nwm8994->num_retune_mobile_texts++;\r\nwm8994->retune_mobile_texts = t;\r\n}\r\ndev_dbg(codec->dev, "Allocated %d unique ReTune Mobile names\n",\r\nwm8994->num_retune_mobile_texts);\r\nwm8994->retune_mobile_enum.max = wm8994->num_retune_mobile_texts;\r\nwm8994->retune_mobile_enum.texts = wm8994->retune_mobile_texts;\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec, controls,\r\nARRAY_SIZE(controls));\r\nif (ret != 0)\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to add ReTune Mobile controls: %d\n", ret);\r\n}\r\nstatic void wm8994_handle_pdata(struct wm8994_priv *wm8994)\r\n{\r\nstruct snd_soc_codec *codec = wm8994->hubs.codec;\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct wm8994_pdata *pdata = &control->pdata;\r\nint ret, i;\r\nif (!pdata)\r\nreturn;\r\nwm_hubs_handle_analogue_pdata(codec, pdata->lineout1_diff,\r\npdata->lineout2_diff,\r\npdata->lineout1fb,\r\npdata->lineout2fb,\r\npdata->jd_scthr,\r\npdata->jd_thr,\r\npdata->micb1_delay,\r\npdata->micb2_delay,\r\npdata->micbias1_lvl,\r\npdata->micbias2_lvl);\r\ndev_dbg(codec->dev, "%d DRC configurations\n", pdata->num_drc_cfgs);\r\nif (pdata->num_drc_cfgs) {\r\nstruct snd_kcontrol_new controls[] = {\r\nSOC_ENUM_EXT("AIF1DRC1 Mode", wm8994->drc_enum,\r\nwm8994_get_drc_enum, wm8994_put_drc_enum),\r\nSOC_ENUM_EXT("AIF1DRC2 Mode", wm8994->drc_enum,\r\nwm8994_get_drc_enum, wm8994_put_drc_enum),\r\nSOC_ENUM_EXT("AIF2DRC Mode", wm8994->drc_enum,\r\nwm8994_get_drc_enum, wm8994_put_drc_enum),\r\n};\r\nwm8994->drc_texts = devm_kzalloc(wm8994->hubs.codec->dev,\r\nsizeof(char *) * pdata->num_drc_cfgs, GFP_KERNEL);\r\nif (!wm8994->drc_texts) {\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to allocate %d DRC config texts\n",\r\npdata->num_drc_cfgs);\r\nreturn;\r\n}\r\nfor (i = 0; i < pdata->num_drc_cfgs; i++)\r\nwm8994->drc_texts[i] = pdata->drc_cfgs[i].name;\r\nwm8994->drc_enum.max = pdata->num_drc_cfgs;\r\nwm8994->drc_enum.texts = wm8994->drc_texts;\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec, controls,\r\nARRAY_SIZE(controls));\r\nfor (i = 0; i < WM8994_NUM_DRC; i++)\r\nwm8994_set_drc(codec, i);\r\n} else {\r\nret = snd_soc_add_codec_controls(wm8994->hubs.codec,\r\nwm8994_drc_controls,\r\nARRAY_SIZE(wm8994_drc_controls));\r\n}\r\nif (ret != 0)\r\ndev_err(wm8994->hubs.codec->dev,\r\n"Failed to add DRC mode controls: %d\n", ret);\r\ndev_dbg(codec->dev, "%d ReTune Mobile configurations\n",\r\npdata->num_retune_mobile_cfgs);\r\nif (pdata->num_retune_mobile_cfgs)\r\nwm8994_handle_retune_mobile_pdata(wm8994);\r\nelse\r\nsnd_soc_add_codec_controls(wm8994->hubs.codec, wm8994_eq_controls,\r\nARRAY_SIZE(wm8994_eq_controls));\r\nfor (i = 0; i < ARRAY_SIZE(pdata->micbias); i++) {\r\nif (pdata->micbias[i]) {\r\nsnd_soc_write(codec, WM8958_MICBIAS1 + i,\r\npdata->micbias[i] & 0xffff);\r\n}\r\n}\r\n}\r\nint wm8994_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,\r\nint micbias)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994_micdet *micdet;\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint reg, ret;\r\nif (control->type != WM8994) {\r\ndev_warn(codec->dev, "Not a WM8994\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (micbias) {\r\ncase 1:\r\nmicdet = &wm8994->micdet[0];\r\nif (jack)\r\nret = snd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"MICBIAS1");\r\nelse\r\nret = snd_soc_dapm_disable_pin(&codec->dapm,\r\n"MICBIAS1");\r\nbreak;\r\ncase 2:\r\nmicdet = &wm8994->micdet[1];\r\nif (jack)\r\nret = snd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"MICBIAS1");\r\nelse\r\nret = snd_soc_dapm_disable_pin(&codec->dapm,\r\n"MICBIAS1");\r\nbreak;\r\ndefault:\r\ndev_warn(codec->dev, "Invalid MICBIAS %d\n", micbias);\r\nreturn -EINVAL;\r\n}\r\nif (ret != 0)\r\ndev_warn(codec->dev, "Failed to configure MICBIAS%d: %d\n",\r\nmicbias, ret);\r\ndev_dbg(codec->dev, "Configuring microphone detection on %d %p\n",\r\nmicbias, jack);\r\nmicdet->jack = jack;\r\nmicdet->detecting = true;\r\nif (wm8994->micdet[0].jack || wm8994->micdet[1].jack)\r\nreg = WM8994_MICD_ENA;\r\nelse\r\nreg = 0;\r\nsnd_soc_update_bits(codec, WM8994_MICBIAS, WM8994_MICD_ENA, reg);\r\nsnd_soc_update_bits(codec, WM8994_IRQ_DEBOUNCE,\r\nWM8994_MIC1_DET_DB_MASK | WM8994_MIC1_SHRT_DB_MASK |\r\nWM8994_MIC2_DET_DB_MASK | WM8994_MIC2_SHRT_DB_MASK,\r\nWM8994_MIC1_DET_DB | WM8994_MIC1_SHRT_DB);\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nreturn 0;\r\n}\r\nstatic void wm8994_mic_work(struct work_struct *work)\r\n{\r\nstruct wm8994_priv *priv = container_of(work,\r\nstruct wm8994_priv,\r\nmic_work.work);\r\nstruct regmap *regmap = priv->wm8994->regmap;\r\nstruct device *dev = priv->wm8994->dev;\r\nunsigned int reg;\r\nint ret;\r\nint report;\r\npm_runtime_get_sync(dev);\r\nret = regmap_read(regmap, WM8994_INTERRUPT_RAW_STATUS_2, &reg);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read microphone status: %d\n",\r\nret);\r\npm_runtime_put(dev);\r\nreturn;\r\n}\r\ndev_dbg(dev, "Microphone status: %x\n", reg);\r\nreport = 0;\r\nif (reg & WM8994_MIC1_DET_STS) {\r\nif (priv->micdet[0].detecting)\r\nreport = SND_JACK_HEADSET;\r\n}\r\nif (reg & WM8994_MIC1_SHRT_STS) {\r\nif (priv->micdet[0].detecting)\r\nreport = SND_JACK_HEADPHONE;\r\nelse\r\nreport |= SND_JACK_BTN_0;\r\n}\r\nif (report)\r\npriv->micdet[0].detecting = false;\r\nelse\r\npriv->micdet[0].detecting = true;\r\nsnd_soc_jack_report(priv->micdet[0].jack, report,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\nreport = 0;\r\nif (reg & WM8994_MIC2_DET_STS) {\r\nif (priv->micdet[1].detecting)\r\nreport = SND_JACK_HEADSET;\r\n}\r\nif (reg & WM8994_MIC2_SHRT_STS) {\r\nif (priv->micdet[1].detecting)\r\nreport = SND_JACK_HEADPHONE;\r\nelse\r\nreport |= SND_JACK_BTN_0;\r\n}\r\nif (report)\r\npriv->micdet[1].detecting = false;\r\nelse\r\npriv->micdet[1].detecting = true;\r\nsnd_soc_jack_report(priv->micdet[1].jack, report,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\npm_runtime_put(dev);\r\n}\r\nstatic irqreturn_t wm8994_mic_irq(int irq, void *data)\r\n{\r\nstruct wm8994_priv *priv = data;\r\nstruct snd_soc_codec *codec = priv->hubs.codec;\r\n#ifndef CONFIG_SND_SOC_WM8994_MODULE\r\ntrace_snd_soc_jack_irq(dev_name(codec->dev));\r\n#endif\r\npm_wakeup_event(codec->dev, 300);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&priv->mic_work, msecs_to_jiffies(250));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wm1811_micd_stop(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (!wm8994->jackdet)\r\nreturn;\r\nmutex_lock(&wm8994->accdet_lock);\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_1, WM8958_MICD_ENA, 0);\r\nwm1811_jackdet_set_mode(codec, WM1811_JACKDET_MODE_JACK);\r\nmutex_unlock(&wm8994->accdet_lock);\r\nif (wm8994->wm8994->pdata.jd_ext_cap)\r\nsnd_soc_dapm_disable_pin(&codec->dapm,\r\n"MICBIAS2");\r\n}\r\nstatic void wm8958_button_det(struct snd_soc_codec *codec, u16 status)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nint report;\r\nreport = 0;\r\nif (status & 0x4)\r\nreport |= SND_JACK_BTN_0;\r\nif (status & 0x8)\r\nreport |= SND_JACK_BTN_1;\r\nif (status & 0x10)\r\nreport |= SND_JACK_BTN_2;\r\nif (status & 0x20)\r\nreport |= SND_JACK_BTN_3;\r\nif (status & 0x40)\r\nreport |= SND_JACK_BTN_4;\r\nif (status & 0x80)\r\nreport |= SND_JACK_BTN_5;\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, report,\r\nwm8994->btn_mask);\r\n}\r\nstatic void wm8958_open_circuit_work(struct work_struct *work)\r\n{\r\nstruct wm8994_priv *wm8994 = container_of(work,\r\nstruct wm8994_priv,\r\nopen_circuit_work.work);\r\nstruct device *dev = wm8994->wm8994->dev;\r\nwm1811_micd_stop(wm8994->hubs.codec);\r\nmutex_lock(&wm8994->accdet_lock);\r\ndev_dbg(dev, "Reporting open circuit\n");\r\nwm8994->jack_mic = false;\r\nwm8994->mic_detecting = true;\r\nwm8958_micd_set_rate(wm8994->hubs.codec);\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, 0,\r\nwm8994->btn_mask |\r\nSND_JACK_HEADSET);\r\nmutex_unlock(&wm8994->accdet_lock);\r\n}\r\nstatic void wm8958_mic_id(void *data, u16 status)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nif (!(status & WM8958_MICD_STS)) {\r\ndev_dbg(codec->dev, "Detected open circuit\n");\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&wm8994->open_circuit_work,\r\nmsecs_to_jiffies(2500));\r\nreturn;\r\n}\r\nif (status & 0x600) {\r\ndev_dbg(codec->dev, "Detected microphone\n");\r\nwm8994->mic_detecting = false;\r\nwm8994->jack_mic = true;\r\nwm8958_micd_set_rate(codec);\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADSET,\r\nSND_JACK_HEADSET);\r\n}\r\nif (status & 0xfc) {\r\ndev_dbg(codec->dev, "Detected headphone\n");\r\nwm8994->mic_detecting = false;\r\nwm8958_micd_set_rate(codec);\r\nwm1811_micd_stop(codec);\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, SND_JACK_HEADPHONE,\r\nSND_JACK_HEADSET);\r\n}\r\n}\r\nstatic void wm1811_mic_work(struct work_struct *work)\r\n{\r\nstruct wm8994_priv *wm8994 = container_of(work, struct wm8994_priv,\r\nmic_work.work);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct snd_soc_codec *codec = wm8994->hubs.codec;\r\npm_runtime_get_sync(codec->dev);\r\nif (control->pdata.jd_ext_cap) {\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm,\r\n"MICBIAS2");\r\nsnd_soc_dapm_sync(&codec->dapm);\r\n}\r\nmutex_lock(&wm8994->accdet_lock);\r\ndev_dbg(codec->dev, "Starting mic detection\n");\r\nif (wm8994->micd_cb) {\r\nwm8994->micd_cb(wm8994->micd_cb_data);\r\n} else {\r\nwm8994->mic_detecting = true;\r\nwm1811_jackdet_set_mode(codec, WM1811_JACKDET_MODE_MIC);\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_1,\r\nWM8958_MICD_ENA, WM8958_MICD_ENA);\r\n}\r\nmutex_unlock(&wm8994->accdet_lock);\r\npm_runtime_put(codec->dev);\r\n}\r\nstatic irqreturn_t wm1811_jackdet_irq(int irq, void *data)\r\n{\r\nstruct wm8994_priv *wm8994 = data;\r\nstruct wm8994 *control = wm8994->wm8994;\r\nstruct snd_soc_codec *codec = wm8994->hubs.codec;\r\nint reg, delay;\r\nbool present;\r\npm_runtime_get_sync(codec->dev);\r\ncancel_delayed_work_sync(&wm8994->mic_complete_work);\r\nmutex_lock(&wm8994->accdet_lock);\r\nreg = snd_soc_read(codec, WM1811_JACKDET_CTRL);\r\nif (reg < 0) {\r\ndev_err(codec->dev, "Failed to read jack status: %d\n", reg);\r\nmutex_unlock(&wm8994->accdet_lock);\r\npm_runtime_put(codec->dev);\r\nreturn IRQ_NONE;\r\n}\r\ndev_dbg(codec->dev, "JACKDET %x\n", reg);\r\npresent = reg & WM1811_JACKDET_LVL;\r\nif (present) {\r\ndev_dbg(codec->dev, "Jack detected\n");\r\nwm8958_micd_set_rate(codec);\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS2,\r\nWM8958_MICB2_DISCH, 0);\r\nsnd_soc_update_bits(codec, WM1811_JACKDET_CTRL,\r\nWM1811_JACKDET_DB, 0);\r\ndelay = control->pdata.micdet_delay;\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&wm8994->mic_work,\r\nmsecs_to_jiffies(delay));\r\n} else {\r\ndev_dbg(codec->dev, "Jack not detected\n");\r\ncancel_delayed_work_sync(&wm8994->mic_work);\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS2,\r\nWM8958_MICB2_DISCH, WM8958_MICB2_DISCH);\r\nsnd_soc_update_bits(codec, WM1811_JACKDET_CTRL,\r\nWM1811_JACKDET_DB, WM1811_JACKDET_DB);\r\nwm8994->mic_detecting = false;\r\nwm8994->jack_mic = false;\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_1,\r\nWM8958_MICD_ENA, 0);\r\nwm1811_jackdet_set_mode(codec, WM1811_JACKDET_MODE_JACK);\r\n}\r\nmutex_unlock(&wm8994->accdet_lock);\r\nif (control->pdata.jd_ext_cap && !present)\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "MICBIAS2");\r\nif (present)\r\nsnd_soc_jack_report(wm8994->micdet[0].jack,\r\nSND_JACK_MECHANICAL, SND_JACK_MECHANICAL);\r\nelse\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, 0,\r\nSND_JACK_MECHANICAL | SND_JACK_HEADSET |\r\nwm8994->btn_mask);\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, 0, 0);\r\npm_runtime_put(codec->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void wm1811_jackdet_bootstrap(struct work_struct *work)\r\n{\r\nstruct wm8994_priv *wm8994 = container_of(work,\r\nstruct wm8994_priv,\r\njackdet_bootstrap.work);\r\nwm1811_jackdet_irq(0, wm8994);\r\n}\r\nint wm8958_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack,\r\nwm1811_micdet_cb det_cb, void *det_cb_data,\r\nwm1811_mic_id_cb id_cb, void *id_cb_data)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nu16 micd_lvl_sel;\r\nswitch (control->type) {\r\ncase WM1811:\r\ncase WM8958:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (jack) {\r\nsnd_soc_dapm_force_enable_pin(&codec->dapm, "CLK_SYS");\r\nsnd_soc_dapm_sync(&codec->dapm);\r\nwm8994->micdet[0].jack = jack;\r\nif (det_cb) {\r\nwm8994->micd_cb = det_cb;\r\nwm8994->micd_cb_data = det_cb_data;\r\n} else {\r\nwm8994->mic_detecting = true;\r\nwm8994->jack_mic = false;\r\n}\r\nif (id_cb) {\r\nwm8994->mic_id_cb = id_cb;\r\nwm8994->mic_id_cb_data = id_cb_data;\r\n} else {\r\nwm8994->mic_id_cb = wm8958_mic_id;\r\nwm8994->mic_id_cb_data = codec;\r\n}\r\nwm8958_micd_set_rate(codec);\r\nif (control->pdata.micd_lvl_sel)\r\nmicd_lvl_sel = control->pdata.micd_lvl_sel;\r\nelse\r\nmicd_lvl_sel = 0x41;\r\nwm8994->btn_mask = SND_JACK_BTN_0 | SND_JACK_BTN_1 |\r\nSND_JACK_BTN_2 | SND_JACK_BTN_3 |\r\nSND_JACK_BTN_4 | SND_JACK_BTN_5;\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_2,\r\nWM8958_MICD_LVL_SEL_MASK, micd_lvl_sel);\r\nWARN_ON(codec->dapm.bias_level > SND_SOC_BIAS_STANDBY);\r\nif (wm8994->jackdet) {\r\nsnd_soc_update_bits(codec, WM1811_JACKDET_CTRL,\r\nWM1811_JACKDET_DB, 0);\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS2,\r\nWM8958_MICB2_DISCH,\r\nWM8958_MICB2_DISCH);\r\nsnd_soc_update_bits(codec, WM8994_LDO_1,\r\nWM8994_LDO1_DISCH, 0);\r\nwm1811_jackdet_set_mode(codec,\r\nWM1811_JACKDET_MODE_JACK);\r\n} else {\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_1,\r\nWM8958_MICD_ENA, WM8958_MICD_ENA);\r\n}\r\n} else {\r\nsnd_soc_update_bits(codec, WM8958_MIC_DETECT_1,\r\nWM8958_MICD_ENA, 0);\r\nwm1811_jackdet_set_mode(codec, WM1811_JACKDET_MODE_NONE);\r\nsnd_soc_dapm_disable_pin(&codec->dapm, "CLK_SYS");\r\nsnd_soc_dapm_sync(&codec->dapm);\r\n}\r\nreturn 0;\r\n}\r\nstatic void wm8958_mic_work(struct work_struct *work)\r\n{\r\nstruct wm8994_priv *wm8994 = container_of(work,\r\nstruct wm8994_priv,\r\nmic_complete_work.work);\r\nstruct snd_soc_codec *codec = wm8994->hubs.codec;\r\npm_runtime_get_sync(codec->dev);\r\nmutex_lock(&wm8994->accdet_lock);\r\nwm8994->mic_id_cb(wm8994->mic_id_cb_data, wm8994->mic_status);\r\nmutex_unlock(&wm8994->accdet_lock);\r\npm_runtime_put(codec->dev);\r\n}\r\nstatic irqreturn_t wm8958_mic_irq(int irq, void *data)\r\n{\r\nstruct wm8994_priv *wm8994 = data;\r\nstruct snd_soc_codec *codec = wm8994->hubs.codec;\r\nint reg, count, ret, id_delay;\r\nif (!(snd_soc_read(codec, WM8958_MIC_DETECT_1) & WM8958_MICD_ENA))\r\nreturn IRQ_HANDLED;\r\ncancel_delayed_work_sync(&wm8994->mic_complete_work);\r\ncancel_delayed_work_sync(&wm8994->open_circuit_work);\r\npm_runtime_get_sync(codec->dev);\r\ncount = 10;\r\ndo {\r\nreg = snd_soc_read(codec, WM8958_MIC_DETECT_3);\r\nif (reg < 0) {\r\ndev_err(codec->dev,\r\n"Failed to read mic detect status: %d\n",\r\nreg);\r\npm_runtime_put(codec->dev);\r\nreturn IRQ_NONE;\r\n}\r\nif (!(reg & WM8958_MICD_VALID)) {\r\ndev_dbg(codec->dev, "Mic detect data not valid\n");\r\ngoto out;\r\n}\r\nif (!(reg & WM8958_MICD_STS) || (reg & WM8958_MICD_LVL_MASK))\r\nbreak;\r\nmsleep(1);\r\n} while (count--);\r\nif (count == 0)\r\ndev_warn(codec->dev, "No impedance range reported for jack\n");\r\n#ifndef CONFIG_SND_SOC_WM8994_MODULE\r\ntrace_snd_soc_jack_irq(dev_name(codec->dev));\r\n#endif\r\nif (wm8994->jackdet) {\r\nret = snd_soc_read(codec, WM1811_JACKDET_CTRL);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read jack status: %d\n",\r\nret);\r\n} else if (!(ret & WM1811_JACKDET_LVL)) {\r\ndev_dbg(codec->dev, "Ignoring removed jack\n");\r\ngoto out;\r\n}\r\n} else if (!(reg & WM8958_MICD_STS)) {\r\nsnd_soc_jack_report(wm8994->micdet[0].jack, 0,\r\nSND_JACK_MECHANICAL | SND_JACK_HEADSET |\r\nwm8994->btn_mask);\r\nwm8994->mic_detecting = true;\r\ngoto out;\r\n}\r\nwm8994->mic_status = reg;\r\nid_delay = wm8994->wm8994->pdata.mic_id_delay;\r\nif (wm8994->mic_detecting)\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&wm8994->mic_complete_work,\r\nmsecs_to_jiffies(id_delay));\r\nelse\r\nwm8958_button_det(codec, reg);\r\nout:\r\npm_runtime_put(codec->dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm8994_fifo_error(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\ndev_err(codec->dev, "FIFO error\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm8994_temp_warn(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\ndev_err(codec->dev, "Thermal warning\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wm8994_temp_shut(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\ndev_crit(codec->dev, "Thermal shutdown\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wm8994_codec_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994 *control = dev_get_drvdata(codec->dev->parent);\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nunsigned int reg;\r\nint ret, i;\r\nwm8994->hubs.codec = codec;\r\ncodec->control_data = control->regmap;\r\nsnd_soc_codec_set_cache_io(codec, 16, 16, SND_SOC_REGMAP);\r\nmutex_init(&wm8994->accdet_lock);\r\nINIT_DELAYED_WORK(&wm8994->jackdet_bootstrap,\r\nwm1811_jackdet_bootstrap);\r\nINIT_DELAYED_WORK(&wm8994->open_circuit_work,\r\nwm8958_open_circuit_work);\r\nswitch (control->type) {\r\ncase WM8994:\r\nINIT_DELAYED_WORK(&wm8994->mic_work, wm8994_mic_work);\r\nbreak;\r\ncase WM1811:\r\nINIT_DELAYED_WORK(&wm8994->mic_work, wm1811_mic_work);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nINIT_DELAYED_WORK(&wm8994->mic_complete_work, wm8958_mic_work);\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++)\r\ninit_completion(&wm8994->fll_locked[i]);\r\nwm8994->micdet_irq = control->pdata.micdet_irq;\r\ncodec->dapm.idle_bias_off = 1;\r\nswitch (control->type) {\r\ncase WM8994:\r\nif (!control->pdata.lineout1_diff ||\r\n!control->pdata.lineout2_diff)\r\ncodec->dapm.idle_bias_off = 0;\r\nswitch (control->revision) {\r\ncase 2:\r\ncase 3:\r\nwm8994->hubs.dcs_codes_l = -5;\r\nwm8994->hubs.dcs_codes_r = -5;\r\nwm8994->hubs.hp_startup_mode = 1;\r\nwm8994->hubs.dcs_readback_mode = 1;\r\nwm8994->hubs.series_startup = 1;\r\nbreak;\r\ndefault:\r\nwm8994->hubs.dcs_readback_mode = 2;\r\nbreak;\r\n}\r\nbreak;\r\ncase WM8958:\r\nwm8994->hubs.dcs_readback_mode = 1;\r\nwm8994->hubs.hp_startup_mode = 1;\r\nswitch (control->revision) {\r\ncase 0:\r\nbreak;\r\ndefault:\r\nwm8994->fll_byp = true;\r\nbreak;\r\n}\r\nbreak;\r\ncase WM1811:\r\nwm8994->hubs.dcs_readback_mode = 2;\r\nwm8994->hubs.no_series_update = 1;\r\nwm8994->hubs.hp_startup_mode = 1;\r\nwm8994->hubs.no_cache_dac_hp_direct = true;\r\nwm8994->fll_byp = true;\r\nwm8994->hubs.dcs_codes_l = -9;\r\nwm8994->hubs.dcs_codes_r = -7;\r\nsnd_soc_update_bits(codec, WM8994_ANALOGUE_HP_1,\r\nWM1811_HPOUT1_ATTN, WM1811_HPOUT1_ATTN);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwm8994_request_irq(wm8994->wm8994, WM8994_IRQ_FIFOS_ERR,\r\nwm8994_fifo_error, "FIFO error", codec);\r\nwm8994_request_irq(wm8994->wm8994, WM8994_IRQ_TEMP_WARN,\r\nwm8994_temp_warn, "Thermal warning", codec);\r\nwm8994_request_irq(wm8994->wm8994, WM8994_IRQ_TEMP_SHUT,\r\nwm8994_temp_shut, "Thermal shutdown", codec);\r\nret = wm8994_request_irq(wm8994->wm8994, WM8994_IRQ_DCS_DONE,\r\nwm_hubs_dcs_done, "DC servo done",\r\n&wm8994->hubs);\r\nif (ret == 0)\r\nwm8994->hubs.dcs_done_irq = true;\r\nswitch (control->type) {\r\ncase WM8994:\r\nif (wm8994->micdet_irq) {\r\nret = request_threaded_irq(wm8994->micdet_irq, NULL,\r\nwm8994_mic_irq,\r\nIRQF_TRIGGER_RISING,\r\n"Mic1 detect",\r\nwm8994);\r\nif (ret != 0)\r\ndev_warn(codec->dev,\r\n"Failed to request Mic1 detect IRQ: %d\n",\r\nret);\r\n}\r\nret = wm8994_request_irq(wm8994->wm8994,\r\nWM8994_IRQ_MIC1_SHRT,\r\nwm8994_mic_irq, "Mic 1 short",\r\nwm8994);\r\nif (ret != 0)\r\ndev_warn(codec->dev,\r\n"Failed to request Mic1 short IRQ: %d\n",\r\nret);\r\nret = wm8994_request_irq(wm8994->wm8994,\r\nWM8994_IRQ_MIC2_DET,\r\nwm8994_mic_irq, "Mic 2 detect",\r\nwm8994);\r\nif (ret != 0)\r\ndev_warn(codec->dev,\r\n"Failed to request Mic2 detect IRQ: %d\n",\r\nret);\r\nret = wm8994_request_irq(wm8994->wm8994,\r\nWM8994_IRQ_MIC2_SHRT,\r\nwm8994_mic_irq, "Mic 2 short",\r\nwm8994);\r\nif (ret != 0)\r\ndev_warn(codec->dev,\r\n"Failed to request Mic2 short IRQ: %d\n",\r\nret);\r\nbreak;\r\ncase WM8958:\r\ncase WM1811:\r\nif (wm8994->micdet_irq) {\r\nret = request_threaded_irq(wm8994->micdet_irq, NULL,\r\nwm8958_mic_irq,\r\nIRQF_TRIGGER_RISING,\r\n"Mic detect",\r\nwm8994);\r\nif (ret != 0)\r\ndev_warn(codec->dev,\r\n"Failed to request Mic detect IRQ: %d\n",\r\nret);\r\n} else {\r\nwm8994_request_irq(wm8994->wm8994, WM8994_IRQ_MIC1_DET,\r\nwm8958_mic_irq, "Mic detect",\r\nwm8994);\r\n}\r\n}\r\nswitch (control->type) {\r\ncase WM1811:\r\nif (control->cust_id > 1 || control->revision > 1) {\r\nret = wm8994_request_irq(wm8994->wm8994,\r\nWM8994_IRQ_GPIO(6),\r\nwm1811_jackdet_irq, "JACKDET",\r\nwm8994);\r\nif (ret == 0)\r\nwm8994->jackdet = true;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwm8994->fll_locked_irq = true;\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++) {\r\nret = wm8994_request_irq(wm8994->wm8994,\r\nWM8994_IRQ_FLL1_LOCK + i,\r\nwm8994_fll_locked_irq, "FLL lock",\r\n&wm8994->fll_locked[i]);\r\nif (ret != 0)\r\nwm8994->fll_locked_irq = false;\r\n}\r\npm_runtime_get_sync(codec->dev);\r\nret = regmap_read(control->regmap, WM8994_GPIO_1, &reg);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read GPIO1 state: %d\n", ret);\r\ngoto err_irq;\r\n}\r\nif ((reg & WM8994_GPN_FN_MASK) != WM8994_GP_FN_PIN_SPECIFIC) {\r\nwm8994->lrclk_shared[0] = 1;\r\nwm8994_dai[0].symmetric_rates = 1;\r\n} else {\r\nwm8994->lrclk_shared[0] = 0;\r\n}\r\nret = regmap_read(control->regmap, WM8994_GPIO_6, &reg);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read GPIO6 state: %d\n", ret);\r\ngoto err_irq;\r\n}\r\nif ((reg & WM8994_GPN_FN_MASK) != WM8994_GP_FN_PIN_SPECIFIC) {\r\nwm8994->lrclk_shared[1] = 1;\r\nwm8994_dai[1].symmetric_rates = 1;\r\n} else {\r\nwm8994->lrclk_shared[1] = 0;\r\n}\r\npm_runtime_put(codec->dev);\r\nfor (i = 0; i < ARRAY_SIZE(wm8994_vu_bits); i++)\r\nsnd_soc_update_bits(codec, wm8994_vu_bits[i].reg,\r\nwm8994_vu_bits[i].mask,\r\nwm8994_vu_bits[i].mask);\r\nsnd_soc_update_bits(codec, WM8994_AIF1_DAC1_FILTERS_2,\r\n1 << WM8994_AIF1DAC1_3D_GAIN_SHIFT,\r\n1 << WM8994_AIF1DAC1_3D_GAIN_SHIFT);\r\nsnd_soc_update_bits(codec, WM8994_AIF1_DAC2_FILTERS_2,\r\n1 << WM8994_AIF1DAC2_3D_GAIN_SHIFT,\r\n1 << WM8994_AIF1DAC2_3D_GAIN_SHIFT);\r\nsnd_soc_update_bits(codec, WM8994_AIF2_DAC_FILTERS_2,\r\n1 << WM8994_AIF2DAC_3D_GAIN_SHIFT,\r\n1 << WM8994_AIF2DAC_3D_GAIN_SHIFT);\r\nswitch (control->type) {\r\ncase WM8994:\r\ncase WM8958:\r\nsnd_soc_update_bits(codec, WM8994_AIF1_CONTROL_1,\r\nWM8994_AIF1ADC_TDM, WM8994_AIF1ADC_TDM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (control->type) {\r\ncase WM8958:\r\ncase WM1811:\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS1,\r\nWM8958_MICB1_MODE, WM8958_MICB1_MODE);\r\nsnd_soc_update_bits(codec, WM8958_MICBIAS2,\r\nWM8958_MICB2_MODE, WM8958_MICB2_MODE);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwm8994->hubs.check_class_w_digital = wm8994_check_class_w_digital;\r\nwm_hubs_update_class_w(codec);\r\nwm8994_handle_pdata(wm8994);\r\nwm_hubs_add_analogue_controls(codec);\r\nsnd_soc_add_codec_controls(codec, wm8994_snd_controls,\r\nARRAY_SIZE(wm8994_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_dapm_widgets,\r\nARRAY_SIZE(wm8994_dapm_widgets));\r\nswitch (control->type) {\r\ncase WM8994:\r\nsnd_soc_dapm_new_controls(dapm, wm8994_specific_dapm_widgets,\r\nARRAY_SIZE(wm8994_specific_dapm_widgets));\r\nif (control->revision < 4) {\r\nsnd_soc_dapm_new_controls(dapm, wm8994_lateclk_revd_widgets,\r\nARRAY_SIZE(wm8994_lateclk_revd_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_adc_revd_widgets,\r\nARRAY_SIZE(wm8994_adc_revd_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_dac_revd_widgets,\r\nARRAY_SIZE(wm8994_dac_revd_widgets));\r\n} else {\r\nsnd_soc_dapm_new_controls(dapm, wm8994_lateclk_widgets,\r\nARRAY_SIZE(wm8994_lateclk_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_adc_widgets,\r\nARRAY_SIZE(wm8994_adc_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_dac_widgets,\r\nARRAY_SIZE(wm8994_dac_widgets));\r\n}\r\nbreak;\r\ncase WM8958:\r\nsnd_soc_add_codec_controls(codec, wm8958_snd_controls,\r\nARRAY_SIZE(wm8958_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8958_dapm_widgets,\r\nARRAY_SIZE(wm8958_dapm_widgets));\r\nif (control->revision < 1) {\r\nsnd_soc_dapm_new_controls(dapm, wm8994_lateclk_revd_widgets,\r\nARRAY_SIZE(wm8994_lateclk_revd_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_adc_revd_widgets,\r\nARRAY_SIZE(wm8994_adc_revd_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_dac_revd_widgets,\r\nARRAY_SIZE(wm8994_dac_revd_widgets));\r\n} else {\r\nsnd_soc_dapm_new_controls(dapm, wm8994_lateclk_widgets,\r\nARRAY_SIZE(wm8994_lateclk_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_adc_widgets,\r\nARRAY_SIZE(wm8994_adc_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_dac_widgets,\r\nARRAY_SIZE(wm8994_dac_widgets));\r\n}\r\nbreak;\r\ncase WM1811:\r\nsnd_soc_add_codec_controls(codec, wm8958_snd_controls,\r\nARRAY_SIZE(wm8958_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, wm8958_dapm_widgets,\r\nARRAY_SIZE(wm8958_dapm_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_lateclk_widgets,\r\nARRAY_SIZE(wm8994_lateclk_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_adc_widgets,\r\nARRAY_SIZE(wm8994_adc_widgets));\r\nsnd_soc_dapm_new_controls(dapm, wm8994_dac_widgets,\r\nARRAY_SIZE(wm8994_dac_widgets));\r\nbreak;\r\n}\r\nwm_hubs_add_analogue_routes(codec, 0, 0);\r\nsnd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));\r\nswitch (control->type) {\r\ncase WM8994:\r\nsnd_soc_dapm_add_routes(dapm, wm8994_intercon,\r\nARRAY_SIZE(wm8994_intercon));\r\nif (control->revision < 4) {\r\nsnd_soc_dapm_add_routes(dapm, wm8994_revd_intercon,\r\nARRAY_SIZE(wm8994_revd_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8994_lateclk_revd_intercon,\r\nARRAY_SIZE(wm8994_lateclk_revd_intercon));\r\n} else {\r\nsnd_soc_dapm_add_routes(dapm, wm8994_lateclk_intercon,\r\nARRAY_SIZE(wm8994_lateclk_intercon));\r\n}\r\nbreak;\r\ncase WM8958:\r\nif (control->revision < 1) {\r\nsnd_soc_dapm_add_routes(dapm, wm8994_intercon,\r\nARRAY_SIZE(wm8994_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8994_revd_intercon,\r\nARRAY_SIZE(wm8994_revd_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8994_lateclk_revd_intercon,\r\nARRAY_SIZE(wm8994_lateclk_revd_intercon));\r\n} else {\r\nsnd_soc_dapm_add_routes(dapm, wm8994_lateclk_intercon,\r\nARRAY_SIZE(wm8994_lateclk_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8958_intercon,\r\nARRAY_SIZE(wm8958_intercon));\r\n}\r\nwm8958_dsp2_init(codec);\r\nbreak;\r\ncase WM1811:\r\nsnd_soc_dapm_add_routes(dapm, wm8994_lateclk_intercon,\r\nARRAY_SIZE(wm8994_lateclk_intercon));\r\nsnd_soc_dapm_add_routes(dapm, wm8958_intercon,\r\nARRAY_SIZE(wm8958_intercon));\r\nbreak;\r\n}\r\nreturn 0;\r\nerr_irq:\r\nif (wm8994->jackdet)\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_GPIO(6), wm8994);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_MIC2_SHRT, wm8994);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_MIC2_DET, wm8994);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_MIC1_SHRT, wm8994);\r\nif (wm8994->micdet_irq)\r\nfree_irq(wm8994->micdet_irq, wm8994);\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++)\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_FLL1_LOCK + i,\r\n&wm8994->fll_locked[i]);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_DCS_DONE,\r\n&wm8994->hubs);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_FIFOS_ERR, codec);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_TEMP_SHUT, codec);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_TEMP_WARN, codec);\r\nreturn ret;\r\n}\r\nstatic int wm8994_codec_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);\r\nstruct wm8994 *control = wm8994->wm8994;\r\nint i;\r\nwm8994_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nfor (i = 0; i < ARRAY_SIZE(wm8994->fll_locked); i++)\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_FLL1_LOCK + i,\r\n&wm8994->fll_locked[i]);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_DCS_DONE,\r\n&wm8994->hubs);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_FIFOS_ERR, codec);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_TEMP_SHUT, codec);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_TEMP_WARN, codec);\r\nif (wm8994->jackdet)\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_GPIO(6), wm8994);\r\nswitch (control->type) {\r\ncase WM8994:\r\nif (wm8994->micdet_irq)\r\nfree_irq(wm8994->micdet_irq, wm8994);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_MIC2_DET,\r\nwm8994);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_MIC1_SHRT,\r\nwm8994);\r\nwm8994_free_irq(wm8994->wm8994, WM8994_IRQ_MIC1_DET,\r\nwm8994);\r\nbreak;\r\ncase WM1811:\r\ncase WM8958:\r\nif (wm8994->micdet_irq)\r\nfree_irq(wm8994->micdet_irq, wm8994);\r\nbreak;\r\n}\r\nrelease_firmware(wm8994->mbc);\r\nrelease_firmware(wm8994->mbc_vss);\r\nrelease_firmware(wm8994->enh_eq);\r\nkfree(wm8994->retune_mobile_texts);\r\nreturn 0;\r\n}\r\nstatic int wm8994_probe(struct platform_device *pdev)\r\n{\r\nstruct wm8994_priv *wm8994;\r\nwm8994 = devm_kzalloc(&pdev->dev, sizeof(struct wm8994_priv),\r\nGFP_KERNEL);\r\nif (wm8994 == NULL)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, wm8994);\r\nwm8994->wm8994 = dev_get_drvdata(pdev->dev.parent);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_idle(&pdev->dev);\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wm8994,\r\nwm8994_dai, ARRAY_SIZE(wm8994_dai));\r\n}\r\nstatic int wm8994_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int wm8994_suspend(struct device *dev)\r\n{\r\nstruct wm8994_priv *wm8994 = dev_get_drvdata(dev);\r\nif (wm8994->jackdet && !wm8994->active_refcount)\r\nregmap_update_bits(wm8994->wm8994->regmap, WM8994_ANTIPOP_2,\r\nWM1811_JACKDET_MODE_MASK,\r\nwm8994->jackdet_mode);\r\nreturn 0;\r\n}\r\nstatic int wm8994_resume(struct device *dev)\r\n{\r\nstruct wm8994_priv *wm8994 = dev_get_drvdata(dev);\r\nif (wm8994->jackdet && wm8994->jackdet_mode)\r\nregmap_update_bits(wm8994->wm8994->regmap, WM8994_ANTIPOP_2,\r\nWM1811_JACKDET_MODE_MASK,\r\nWM1811_JACKDET_MODE_AUDIO);\r\nreturn 0;\r\n}
