static u_int\r\nahd_calc_syncsrate(u_int period_factor)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(scsi_syncrates); i++) {\r\nif (period_factor == scsi_syncrates[i].period_factor) {\r\nreturn (100000000 / scsi_syncrates[i].period);\r\n}\r\n}\r\nreturn (10000000 / (period_factor * 4 * 10));\r\n}\r\nstatic void\r\nahd_format_transinfo(struct seq_file *m, struct ahd_transinfo *tinfo)\r\n{\r\nu_int speed;\r\nu_int freq;\r\nu_int mb;\r\nif (tinfo->period == AHD_PERIOD_UNKNOWN) {\r\nseq_printf(m, "Renegotiation Pending\n");\r\nreturn;\r\n}\r\nspeed = 3300;\r\nfreq = 0;\r\nif (tinfo->offset != 0) {\r\nfreq = ahd_calc_syncsrate(tinfo->period);\r\nspeed = freq;\r\n}\r\nspeed *= (0x01 << tinfo->width);\r\nmb = speed / 1000;\r\nif (mb > 0)\r\nseq_printf(m, "%d.%03dMB/s transfers", mb, speed % 1000);\r\nelse\r\nseq_printf(m, "%dKB/s transfers", speed);\r\nif (freq != 0) {\r\nint printed_options;\r\nprinted_options = 0;\r\nseq_printf(m, " (%d.%03dMHz", freq / 1000, freq % 1000);\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_RD_STRM) != 0) {\r\nseq_printf(m, " RDSTRM");\r\nprinted_options++;\r\n}\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_DT_REQ) != 0) {\r\nseq_printf(m, "%s", printed_options ? "|DT" : " DT");\r\nprinted_options++;\r\n}\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_IU_REQ) != 0) {\r\nseq_printf(m, "%s", printed_options ? "|IU" : " IU");\r\nprinted_options++;\r\n}\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_RTI) != 0) {\r\nseq_printf(m, "%s",\r\nprinted_options ? "|RTI" : " RTI");\r\nprinted_options++;\r\n}\r\nif ((tinfo->ppr_options & MSG_EXT_PPR_QAS_REQ) != 0) {\r\nseq_printf(m, "%s",\r\nprinted_options ? "|QAS" : " QAS");\r\nprinted_options++;\r\n}\r\n}\r\nif (tinfo->width > 0) {\r\nif (freq != 0) {\r\nseq_printf(m, ", ");\r\n} else {\r\nseq_printf(m, " (");\r\n}\r\nseq_printf(m, "%dbit)", 8 * (0x01 << tinfo->width));\r\n} else if (freq != 0) {\r\nseq_printf(m, ")");\r\n}\r\nseq_printf(m, "\n");\r\n}\r\nstatic void\r\nahd_dump_target_state(struct ahd_softc *ahd, struct seq_file *m,\r\nu_int our_id, char channel, u_int target_id)\r\n{\r\nstruct scsi_target *starget;\r\nstruct ahd_initiator_tinfo *tinfo;\r\nstruct ahd_tmode_tstate *tstate;\r\nint lun;\r\ntinfo = ahd_fetch_transinfo(ahd, channel, our_id,\r\ntarget_id, &tstate);\r\nseq_printf(m, "Target %d Negotiation Settings\n", target_id);\r\nseq_printf(m, "\tUser: ");\r\nahd_format_transinfo(m, &tinfo->user);\r\nstarget = ahd->platform_data->starget[target_id];\r\nif (starget == NULL)\r\nreturn;\r\nseq_printf(m, "\tGoal: ");\r\nahd_format_transinfo(m, &tinfo->goal);\r\nseq_printf(m, "\tCurr: ");\r\nahd_format_transinfo(m, &tinfo->curr);\r\nfor (lun = 0; lun < AHD_NUM_LUNS; lun++) {\r\nstruct scsi_device *dev;\r\ndev = scsi_device_lookup_by_target(starget, lun);\r\nif (dev == NULL)\r\ncontinue;\r\nahd_dump_device_state(m, dev);\r\n}\r\n}\r\nstatic void\r\nahd_dump_device_state(struct seq_file *m, struct scsi_device *sdev)\r\n{\r\nstruct ahd_linux_device *dev = scsi_transport_device_data(sdev);\r\nseq_printf(m, "\tChannel %c Target %d Lun %d Settings\n",\r\nsdev->sdev_target->channel + 'A',\r\nsdev->sdev_target->id, sdev->lun);\r\nseq_printf(m, "\t\tCommands Queued %ld\n", dev->commands_issued);\r\nseq_printf(m, "\t\tCommands Active %d\n", dev->active);\r\nseq_printf(m, "\t\tCommand Openings %d\n", dev->openings);\r\nseq_printf(m, "\t\tMax Tagged Openings %d\n", dev->maxtags);\r\nseq_printf(m, "\t\tDevice Queue Frozen Count %d\n", dev->qfrozen);\r\n}\r\nint\r\nahd_proc_write_seeprom(struct Scsi_Host *shost, char *buffer, int length)\r\n{\r\nstruct ahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;\r\nahd_mode_state saved_modes;\r\nint have_seeprom;\r\nu_long s;\r\nint paused;\r\nint written;\r\nwritten = -EINVAL;\r\nahd_lock(ahd, &s);\r\npaused = ahd_is_paused(ahd);\r\nif (!paused)\r\nahd_pause(ahd);\r\nsaved_modes = ahd_save_modes(ahd);\r\nahd_set_modes(ahd, AHD_MODE_SCSI, AHD_MODE_SCSI);\r\nif (length != sizeof(struct seeprom_config)) {\r\nprintk("ahd_proc_write_seeprom: incorrect buffer size\n");\r\ngoto done;\r\n}\r\nhave_seeprom = ahd_verify_cksum((struct seeprom_config*)buffer);\r\nif (have_seeprom == 0) {\r\nprintk("ahd_proc_write_seeprom: cksum verification failed\n");\r\ngoto done;\r\n}\r\nhave_seeprom = ahd_acquire_seeprom(ahd);\r\nif (!have_seeprom) {\r\nprintk("ahd_proc_write_seeprom: No Serial EEPROM\n");\r\ngoto done;\r\n} else {\r\nu_int start_addr;\r\nif (ahd->seep_config == NULL) {\r\nahd->seep_config = kmalloc(sizeof(*ahd->seep_config), GFP_ATOMIC);\r\nif (ahd->seep_config == NULL) {\r\nprintk("aic79xx: Unable to allocate serial "\r\n"eeprom buffer. Write failing\n");\r\ngoto done;\r\n}\r\n}\r\nprintk("aic79xx: Writing Serial EEPROM\n");\r\nstart_addr = 32 * (ahd->channel - 'A');\r\nahd_write_seeprom(ahd, (u_int16_t *)buffer, start_addr,\r\nsizeof(struct seeprom_config)/2);\r\nahd_read_seeprom(ahd, (uint16_t *)ahd->seep_config,\r\nstart_addr, sizeof(struct seeprom_config)/2,\r\nFALSE);\r\nahd_release_seeprom(ahd);\r\nwritten = length;\r\n}\r\ndone:\r\nahd_restore_modes(ahd, saved_modes);\r\nif (!paused)\r\nahd_unpause(ahd);\r\nahd_unlock(ahd, &s);\r\nreturn (written);\r\n}\r\nint\r\nahd_linux_show_info(struct seq_file *m, struct Scsi_Host *shost)\r\n{\r\nstruct ahd_softc *ahd = *(struct ahd_softc **)shost->hostdata;\r\nchar ahd_info[256];\r\nu_int max_targ;\r\nu_int i;\r\nseq_printf(m, "Adaptec AIC79xx driver version: %s\n",\r\nAIC79XX_DRIVER_VERSION);\r\nseq_printf(m, "%s\n", ahd->description);\r\nahd_controller_info(ahd, ahd_info);\r\nseq_printf(m, "%s\n", ahd_info);\r\nseq_printf(m, "Allocated SCBs: %d, SG List Length: %d\n\n",\r\nahd->scb_data.numscbs, AHD_NSEG);\r\nmax_targ = 16;\r\nif (ahd->seep_config == NULL)\r\nseq_printf(m, "No Serial EEPROM\n");\r\nelse {\r\nseq_printf(m, "Serial EEPROM:\n");\r\nfor (i = 0; i < sizeof(*ahd->seep_config)/2; i++) {\r\nif (((i % 8) == 0) && (i != 0)) {\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, "0x%.4x ",\r\n((uint16_t*)ahd->seep_config)[i]);\r\n}\r\nseq_printf(m, "\n");\r\n}\r\nseq_printf(m, "\n");\r\nif ((ahd->features & AHD_WIDE) == 0)\r\nmax_targ = 8;\r\nfor (i = 0; i < max_targ; i++) {\r\nahd_dump_target_state(ahd, m, ahd->our_id, 'A',\r\ni);\r\n}\r\nreturn 0;\r\n}
