static inline int is_PKCS11_padded(unsigned char *buffer, int length)\r\n{\r\nint i;\r\nif ((buffer[0] != 0x00) || (buffer[1] != 0x01))\r\nreturn 0;\r\nfor (i = 2; i < length; i++)\r\nif (buffer[i] != 0xFF)\r\nbreak;\r\nif (i < 10 || i == length)\r\nreturn 0;\r\nif (buffer[i] != 0x00)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic inline int is_PKCS12_padded(unsigned char *buffer, int length)\r\n{\r\nint i;\r\nif ((buffer[0] != 0x00) || (buffer[1] != 0x02))\r\nreturn 0;\r\nfor (i = 2; i < length; i++)\r\nif (buffer[i] == 0x00)\r\nbreak;\r\nif ((i < 10) || (i == length))\r\nreturn 0;\r\nif (buffer[i] != 0x00)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int ICAMEX_msg_to_type6MEX_msg(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstatic struct type6_hdr static_type6_hdr = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {0x01,0x00,0x43,0x43,0x41,0x2D,0x41,0x50,\r\n0x50,0x4C,0x20,0x20,0x20,0x01,0x01,0x01},\r\n.function_code = {'P','K'},\r\n};\r\nstatic struct function_and_rules_block static_pke_function_and_rules ={\r\n.function_code = {'P','K'},\r\n.ulen = __constant_cpu_to_le16(10),\r\n.only_rule = {'P','K','C','S','-','1','.','2'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRB cprb;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __attribute__((packed)) *msg = ap_msg->message;\r\nint vud_len, pad_len, size;\r\nif (copy_from_user(msg->text, mex->inputdata, mex->inputdatalength))\r\nreturn -EFAULT;\r\nif (is_PKCS11_padded(msg->text, mex->inputdatalength))\r\nreturn -EINVAL;\r\nmsg->hdr = static_type6_hdr;\r\nmsg->fr = static_pke_function_and_rules;\r\nif (is_PKCS12_padded(msg->text, mex->inputdatalength)) {\r\npad_len = strnlen(msg->text + 2, mex->inputdatalength - 2) + 3;\r\nif (pad_len <= 9 || pad_len >= mex->inputdatalength)\r\nreturn -ENODEV;\r\nvud_len = mex->inputdatalength - pad_len;\r\nmemmove(msg->text, msg->text + pad_len, vud_len);\r\nmsg->length = cpu_to_le16(vud_len + 2);\r\nsize = zcrypt_type6_mex_key_en(mex, msg->text + vud_len, 0);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + vud_len;\r\n} else {\r\nvud_len = mex->inputdatalength;\r\nmsg->length = cpu_to_le16(2 + vud_len);\r\nmsg->hdr.function_code[1] = 'D';\r\nmsg->fr.function_code[1] = 'D';\r\nsize = zcrypt_type6_mex_key_de(mex, msg->text + vud_len, 0);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + vud_len;\r\n}\r\nmsg->hdr.ToCardLen1 = (size - sizeof(msg->hdr) + 3) & -4;\r\nmsg->hdr.FromCardLen1 = PCICC_MAX_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprb = static_cprb;\r\nmsg->cprb.usage_domain[0]= AP_QID_QUEUE(zdev->ap_dev->qid);\r\nmsg->cprb.req_parml = cpu_to_le16(size - sizeof(msg->hdr) -\r\nsizeof(msg->cprb));\r\nmsg->cprb.rpl_parml = cpu_to_le16(msg->hdr.FromCardLen1);\r\nap_msg->length = (size + 3) & -4;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type6CRT_msg(struct zcrypt_device *zdev,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstatic struct type6_hdr static_type6_hdr = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {0x01,0x00,0x43,0x43,0x41,0x2D,0x41,0x50,\r\n0x50,0x4C,0x20,0x20,0x20,0x01,0x01,0x01},\r\n.function_code = {'P','D'},\r\n};\r\nstatic struct function_and_rules_block static_pkd_function_and_rules ={\r\n.function_code = {'P','D'},\r\n.ulen = __constant_cpu_to_le16(10),\r\n.only_rule = {'P','K','C','S','-','1','.','2'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRB cprb;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __attribute__((packed)) *msg = ap_msg->message;\r\nint size;\r\nmsg->length = cpu_to_le16(2 + crt->inputdatalength);\r\nif (copy_from_user(msg->text, crt->inputdata, crt->inputdatalength))\r\nreturn -EFAULT;\r\nif (is_PKCS11_padded(msg->text, crt->inputdatalength))\r\nreturn -EINVAL;\r\nsize = zcrypt_type6_crt_key(crt, msg->text + crt->inputdatalength, 0);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + crt->inputdatalength;\r\nmsg->hdr = static_type6_hdr;\r\nmsg->hdr.ToCardLen1 = (size - sizeof(msg->hdr) + 3) & -4;\r\nmsg->hdr.FromCardLen1 = PCICC_MAX_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprb = static_cprb;\r\nmsg->cprb.usage_domain[0] = AP_QID_QUEUE(zdev->ap_dev->qid);\r\nmsg->cprb.req_parml = msg->cprb.rpl_parml =\r\ncpu_to_le16(size - sizeof(msg->hdr) - sizeof(msg->cprb));\r\nmsg->fr = static_pkd_function_and_rules;\r\nap_msg->length = (size + 3) & -4;\r\nreturn 0;\r\n}\r\nstatic int convert_type86(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstatic unsigned char static_pad[] = {\r\n0x00,0x02,\r\n0x1B,0x7B,0x5D,0xB5,0x75,0x01,0x3D,0xFD,\r\n0x8D,0xD1,0xC7,0x03,0x2D,0x09,0x23,0x57,\r\n0x89,0x49,0xB9,0x3F,0xBB,0x99,0x41,0x5B,\r\n0x75,0x21,0x7B,0x9D,0x3B,0x6B,0x51,0x39,\r\n0xBB,0x0D,0x35,0xB9,0x89,0x0F,0x93,0xA5,\r\n0x0B,0x47,0xF1,0xD3,0xBB,0xCB,0xF1,0x9D,\r\n0x23,0x73,0x71,0xFF,0xF3,0xF5,0x45,0xFB,\r\n0x61,0x29,0x23,0xFD,0xF1,0x29,0x3F,0x7F,\r\n0x17,0xB7,0x1B,0xA9,0x19,0xBD,0x57,0xA9,\r\n0xD7,0x95,0xA3,0xCB,0xED,0x1D,0xDB,0x45,\r\n0x7D,0x11,0xD1,0x51,0x1B,0xED,0x71,0xE9,\r\n0xB1,0xD1,0xAB,0xAB,0x21,0x2B,0x1B,0x9F,\r\n0x3B,0x9F,0xF7,0xF7,0xBD,0x63,0xEB,0xAD,\r\n0xDF,0xB3,0x6F,0x5B,0xDB,0x8D,0xA9,0x5D,\r\n0xE3,0x7D,0x77,0x49,0x47,0xF5,0xA7,0xFD,\r\n0xAB,0x2F,0x27,0x35,0x77,0xD3,0x49,0xC9,\r\n0x09,0xEB,0xB1,0xF9,0xBF,0x4B,0xCB,0x2B,\r\n0xEB,0xEB,0x05,0xFF,0x7D,0xC7,0x91,0x8B,\r\n0x09,0x83,0xB9,0xB9,0x69,0x33,0x39,0x6B,\r\n0x79,0x75,0x19,0xBF,0xBB,0x07,0x1D,0xBD,\r\n0x29,0xBF,0x39,0x95,0x93,0x1D,0x35,0xC7,\r\n0xC9,0x4D,0xE5,0x97,0x0B,0x43,0x9B,0xF1,\r\n0x16,0x93,0x03,0x1F,0xA5,0xFB,0xDB,0xF3,\r\n0x27,0x4F,0x27,0x61,0x05,0x1F,0xB9,0x23,\r\n0x2F,0xC3,0x81,0xA9,0x23,0x71,0x55,0x55,\r\n0xEB,0xED,0x41,0xE5,0xF3,0x11,0xF1,0x43,\r\n0x69,0x03,0xBD,0x0B,0x37,0x0F,0x51,0x8F,\r\n0x0B,0xB5,0x89,0x5B,0x67,0xA9,0xD9,0x4F,\r\n0x01,0xF9,0x21,0x77,0x37,0x73,0x79,0xC5,\r\n0x7F,0x51,0xC1,0xCF,0x97,0xA1,0x75,0xAD,\r\n0x35,0x9D,0xD3,0xD3,0xA7,0x9D,0x5D,0x41,\r\n0x6F,0x65,0x1B,0xCF,0xA9,0x87,0x91,0x09\r\n};\r\nstruct type86_reply *msg = reply->message;\r\nunsigned short service_rc, service_rs;\r\nunsigned int reply_len, pad_len;\r\nchar *data;\r\nservice_rc = le16_to_cpu(msg->cprb.ccp_rtcode);\r\nif (unlikely(service_rc != 0)) {\r\nservice_rs = le16_to_cpu(msg->cprb.ccp_rscode);\r\nif (service_rc == 8 && service_rs == 66)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 65)\r\nreturn -EINVAL;\r\nif (service_rc == 8 && service_rs == 770) {\r\nzdev->max_mod_size = PCICC_MAX_MOD_SIZE_OLD;\r\nreturn -EAGAIN;\r\n}\r\nif (service_rc == 8 && service_rs == 783) {\r\nzdev->max_mod_size = PCICC_MAX_MOD_SIZE_OLD;\r\nreturn -EAGAIN;\r\n}\r\nif (service_rc == 8 && service_rs == 72)\r\nreturn -EINVAL;\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\ndata = msg->text;\r\nreply_len = le16_to_cpu(msg->length) - 2;\r\nif (reply_len > outputdatalength)\r\nreturn -EINVAL;\r\npad_len = outputdatalength - reply_len;\r\nif (pad_len > 0) {\r\nif (pad_len < 10)\r\nreturn -EINVAL;\r\nif (copy_to_user(outputdata, static_pad, pad_len - 1))\r\nreturn -EFAULT;\r\nif (put_user(0, outputdata + pad_len - 1))\r\nreturn -EFAULT;\r\n}\r\nif (copy_to_user(outputdata + pad_len, data, reply_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_response(struct zcrypt_device *zdev,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type86_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zdev, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code)\r\nreturn convert_error(zdev, reply);\r\nif (msg->cprb.cprb_ver_id == 0x01)\r\nreturn convert_type86(zdev, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzdev->online = 0;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_pcicc_receive(struct ap_device *ap_dev,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct type86_reply *t86r;\r\nint length;\r\nif (IS_ERR(reply)) {\r\nmemcpy(msg->message, &error_reply, sizeof(error_reply));\r\ngoto out;\r\n}\r\nt86r = reply->message;\r\nif (t86r->hdr.type == TYPE86_RSP_CODE &&\r\nt86r->cprb.cprb_ver_id == 0x01) {\r\nlength = sizeof(struct type86_reply) + t86r->length - 2;\r\nlength = min(PCICC_MAX_RESPONSE_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof error_reply);\r\nout:\r\ncomplete((struct completion *) msg->private);\r\n}\r\nstatic long zcrypt_pcicc_modexpo(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_pcicc_receive;\r\nap_msg.length = PAGE_SIZE;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICAMEX_msg_to_type6MEX_msg(zdev, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0)\r\nrc = convert_response(zdev, &ap_msg, mex->outputdata,\r\nmex->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_pcicc_modexpo_crt(struct zcrypt_device *zdev,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_pcicc_receive;\r\nap_msg.length = PAGE_SIZE;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICACRT_msg_to_type6CRT_msg(zdev, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zdev->ap_dev, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0)\r\nrc = convert_response(zdev, &ap_msg, crt->outputdata,\r\ncrt->outputdatalength);\r\nelse\r\nap_cancel_message(zdev->ap_dev, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic int zcrypt_pcicc_probe(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev;\r\nint rc;\r\nzdev = zcrypt_device_alloc(PCICC_MAX_RESPONSE_SIZE);\r\nif (!zdev)\r\nreturn -ENOMEM;\r\nzdev->ap_dev = ap_dev;\r\nzdev->ops = &zcrypt_pcicc_ops;\r\nzdev->online = 1;\r\nzdev->user_space_type = ZCRYPT_PCICC;\r\nzdev->type_string = "PCICC";\r\nzdev->min_mod_size = PCICC_MIN_MOD_SIZE;\r\nzdev->max_mod_size = PCICC_MAX_MOD_SIZE;\r\nzdev->speed_rating = PCICC_SPEED_RATING;\r\nzdev->max_exp_bit_length = PCICC_MAX_MOD_SIZE;\r\nap_dev->reply = &zdev->reply;\r\nap_dev->private = zdev;\r\nrc = zcrypt_device_register(zdev);\r\nif (rc)\r\ngoto out_free;\r\nreturn 0;\r\nout_free:\r\nap_dev->private = NULL;\r\nzcrypt_device_free(zdev);\r\nreturn rc;\r\n}\r\nstatic void zcrypt_pcicc_remove(struct ap_device *ap_dev)\r\n{\r\nstruct zcrypt_device *zdev = ap_dev->private;\r\nzcrypt_device_unregister(zdev);\r\n}\r\nint __init zcrypt_pcicc_init(void)\r\n{\r\nreturn ap_driver_register(&zcrypt_pcicc_driver, THIS_MODULE, "pcicc");\r\n}\r\nvoid zcrypt_pcicc_exit(void)\r\n{\r\nap_driver_unregister(&zcrypt_pcicc_driver);\r\n}
