static struct platform_device *dpi_get_dsidev(enum omap_channel channel)\r\n{\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\nreturn NULL;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn dsi_get_dsidev_from_id(0);\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn dsi_get_dsidev_from_id(1);\r\ndefault:\r\nreturn NULL;\r\n}\r\ncase OMAPDSS_VER_OMAP5:\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn dsi_get_dsidev_from_id(0);\r\ncase OMAP_DSS_CHANNEL_LCD3:\r\nreturn dsi_get_dsidev_from_id(1);\r\ndefault:\r\nreturn NULL;\r\n}\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic enum omap_dss_clk_source dpi_get_alt_clk_src(enum omap_channel channel)\r\n{\r\nswitch (channel) {\r\ncase OMAP_DSS_CHANNEL_LCD:\r\nreturn OMAP_DSS_CLK_SRC_DSI_PLL_HSDIV_DISPC;\r\ncase OMAP_DSS_CHANNEL_LCD2:\r\nreturn OMAP_DSS_CLK_SRC_DSI2_PLL_HSDIV_DISPC;\r\ndefault:\r\nWARN_ON(1);\r\nreturn OMAP_DSS_CLK_SRC_FCK;\r\n}\r\n}\r\nstatic bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\r\nunsigned long pck, void *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nif (ctx->pck_min >= 100000000) {\r\nif (lckd > 1 && lckd % 2 != 0)\r\nreturn false;\r\nif (pckd > 1 && pckd % 2 != 0)\r\nreturn false;\r\n}\r\nctx->dispc_cinfo.lck_div = lckd;\r\nctx->dispc_cinfo.pck_div = pckd;\r\nctx->dispc_cinfo.lck = lck;\r\nctx->dispc_cinfo.pck = pck;\r\nreturn true;\r\n}\r\nstatic bool dpi_calc_hsdiv_cb(int regm_dispc, unsigned long dispc,\r\nvoid *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nif (regm_dispc > 1 && regm_dispc % 2 != 0 && ctx->pck_min >= 100000000)\r\nreturn false;\r\nctx->dsi_cinfo.regm_dispc = regm_dispc;\r\nctx->dsi_cinfo.dsi_pll_hsdiv_dispc_clk = dispc;\r\nreturn dispc_div_calc(dispc, ctx->pck_min, ctx->pck_max,\r\ndpi_calc_dispc_cb, ctx);\r\n}\r\nstatic bool dpi_calc_pll_cb(int regn, int regm, unsigned long fint,\r\nunsigned long pll,\r\nvoid *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nctx->dsi_cinfo.regn = regn;\r\nctx->dsi_cinfo.regm = regm;\r\nctx->dsi_cinfo.fint = fint;\r\nctx->dsi_cinfo.clkin4ddr = pll;\r\nreturn dsi_hsdiv_calc(ctx->dsidev, pll, ctx->pck_min,\r\ndpi_calc_hsdiv_cb, ctx);\r\n}\r\nstatic bool dpi_calc_dss_cb(int fckd, unsigned long fck, void *data)\r\n{\r\nstruct dpi_clk_calc_ctx *ctx = data;\r\nctx->dss_cinfo.fck = fck;\r\nctx->dss_cinfo.fck_div = fckd;\r\nreturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\r\ndpi_calc_dispc_cb, ctx);\r\n}\r\nstatic bool dpi_dsi_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)\r\n{\r\nunsigned long clkin;\r\nunsigned long pll_min, pll_max;\r\nclkin = dsi_get_pll_clkin(dpi.dsidev);\r\nmemset(ctx, 0, sizeof(*ctx));\r\nctx->dsidev = dpi.dsidev;\r\nctx->pck_min = pck - 1000;\r\nctx->pck_max = pck + 1000;\r\nctx->dsi_cinfo.clkin = clkin;\r\npll_min = 0;\r\npll_max = 0;\r\nreturn dsi_pll_calc(dpi.dsidev, clkin,\r\npll_min, pll_max,\r\ndpi_calc_pll_cb, ctx);\r\n}\r\nstatic bool dpi_dss_clk_calc(unsigned long pck, struct dpi_clk_calc_ctx *ctx)\r\n{\r\nint i;\r\nfor (i = 0; i < 25; ++i) {\r\nbool ok;\r\nmemset(ctx, 0, sizeof(*ctx));\r\nif (pck > 1000 * i * i * i)\r\nctx->pck_min = max(pck - 1000 * i * i * i, 0lu);\r\nelse\r\nctx->pck_min = 0;\r\nctx->pck_max = pck + 1000 * i * i * i;\r\nok = dss_div_calc(ctx->pck_min, dpi_calc_dss_cb, ctx);\r\nif (ok)\r\nreturn ok;\r\n}\r\nreturn false;\r\n}\r\nstatic int dpi_set_dsi_clk(enum omap_channel channel,\r\nunsigned long pck_req, unsigned long *fck, int *lck_div,\r\nint *pck_div)\r\n{\r\nstruct dpi_clk_calc_ctx ctx;\r\nint r;\r\nbool ok;\r\nok = dpi_dsi_clk_calc(pck_req, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nr = dsi_pll_set_clock_div(dpi.dsidev, &ctx.dsi_cinfo);\r\nif (r)\r\nreturn r;\r\ndss_select_lcd_clk_source(channel,\r\ndpi_get_alt_clk_src(channel));\r\ndpi.mgr_config.clock_info = ctx.dispc_cinfo;\r\n*fck = ctx.dsi_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n*lck_div = ctx.dispc_cinfo.lck_div;\r\n*pck_div = ctx.dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_dispc_clk(unsigned long pck_req, unsigned long *fck,\r\nint *lck_div, int *pck_div)\r\n{\r\nstruct dpi_clk_calc_ctx ctx;\r\nint r;\r\nbool ok;\r\nok = dpi_dss_clk_calc(pck_req, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nr = dss_set_clock_div(&ctx.dss_cinfo);\r\nif (r)\r\nreturn r;\r\ndpi.mgr_config.clock_info = ctx.dispc_cinfo;\r\n*fck = ctx.dss_cinfo.fck;\r\n*lck_div = ctx.dispc_cinfo.lck_div;\r\n*pck_div = ctx.dispc_cinfo.pck_div;\r\nreturn 0;\r\n}\r\nstatic int dpi_set_mode(struct omap_overlay_manager *mgr)\r\n{\r\nstruct omap_video_timings *t = &dpi.timings;\r\nint lck_div = 0, pck_div = 0;\r\nunsigned long fck = 0;\r\nunsigned long pck;\r\nint r = 0;\r\nif (dpi.dsidev)\r\nr = dpi_set_dsi_clk(mgr->id, t->pixel_clock * 1000, &fck,\r\n&lck_div, &pck_div);\r\nelse\r\nr = dpi_set_dispc_clk(t->pixel_clock * 1000, &fck,\r\n&lck_div, &pck_div);\r\nif (r)\r\nreturn r;\r\npck = fck / lck_div / pck_div / 1000;\r\nif (pck != t->pixel_clock) {\r\nDSSWARN("Could not find exact pixel clock. "\r\n"Requested %d kHz, got %lu kHz\n",\r\nt->pixel_clock, pck);\r\nt->pixel_clock = pck;\r\n}\r\ndss_mgr_set_timings(mgr, t);\r\nreturn 0;\r\n}\r\nstatic void dpi_config_lcd_manager(struct omap_overlay_manager *mgr)\r\n{\r\ndpi.mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\ndpi.mgr_config.stallmode = false;\r\ndpi.mgr_config.fifohandcheck = false;\r\ndpi.mgr_config.video_port_width = dpi.data_lines;\r\ndpi.mgr_config.lcden_sig_polarity = 0;\r\ndss_mgr_set_lcd_config(mgr, &dpi.mgr_config);\r\n}\r\nstatic int dpi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out = &dpi.output;\r\nint r;\r\nmutex_lock(&dpi.lock);\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI) && !dpi.vdds_dsi_reg) {\r\nDSSERR("no VDSS_DSI regulator\n");\r\nr = -ENODEV;\r\ngoto err_no_reg;\r\n}\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nr = -ENODEV;\r\ngoto err_no_out_mgr;\r\n}\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI)) {\r\nr = regulator_enable(dpi.vdds_dsi_reg);\r\nif (r)\r\ngoto err_reg_enable;\r\n}\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_get_dispc;\r\nr = dss_dpi_select_source(out->manager->id);\r\nif (r)\r\ngoto err_src_sel;\r\nif (dpi.dsidev) {\r\nr = dsi_runtime_get(dpi.dsidev);\r\nif (r)\r\ngoto err_get_dsi;\r\nr = dsi_pll_init(dpi.dsidev, 0, 1);\r\nif (r)\r\ngoto err_dsi_pll_init;\r\n}\r\nr = dpi_set_mode(out->manager);\r\nif (r)\r\ngoto err_set_mode;\r\ndpi_config_lcd_manager(out->manager);\r\nmdelay(2);\r\nr = dss_mgr_enable(out->manager);\r\nif (r)\r\ngoto err_mgr_enable;\r\nmutex_unlock(&dpi.lock);\r\nreturn 0;\r\nerr_mgr_enable:\r\nerr_set_mode:\r\nif (dpi.dsidev)\r\ndsi_pll_uninit(dpi.dsidev, true);\r\nerr_dsi_pll_init:\r\nif (dpi.dsidev)\r\ndsi_runtime_put(dpi.dsidev);\r\nerr_get_dsi:\r\nerr_src_sel:\r\ndispc_runtime_put();\r\nerr_get_dispc:\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nregulator_disable(dpi.vdds_dsi_reg);\r\nerr_reg_enable:\r\nerr_no_out_mgr:\r\nerr_no_reg:\r\nmutex_unlock(&dpi.lock);\r\nreturn r;\r\n}\r\nstatic void dpi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = dpi.output.manager;\r\nmutex_lock(&dpi.lock);\r\ndss_mgr_disable(mgr);\r\nif (dpi.dsidev) {\r\ndss_select_lcd_clk_source(mgr->id, OMAP_DSS_CLK_SRC_FCK);\r\ndsi_pll_uninit(dpi.dsidev, true);\r\ndsi_runtime_put(dpi.dsidev);\r\n}\r\ndispc_runtime_put();\r\nif (dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nregulator_disable(dpi.vdds_dsi_reg);\r\nmutex_unlock(&dpi.lock);\r\n}\r\nstatic void dpi_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nDSSDBG("dpi_set_timings\n");\r\nmutex_lock(&dpi.lock);\r\ndpi.timings = *timings;\r\nmutex_unlock(&dpi.lock);\r\n}\r\nstatic void dpi_get_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nmutex_lock(&dpi.lock);\r\n*timings = dpi.timings;\r\nmutex_unlock(&dpi.lock);\r\n}\r\nstatic int dpi_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct omap_overlay_manager *mgr = dpi.output.manager;\r\nint lck_div, pck_div;\r\nunsigned long fck;\r\nunsigned long pck;\r\nstruct dpi_clk_calc_ctx ctx;\r\nbool ok;\r\nif (mgr && !dispc_mgr_timings_ok(mgr->id, timings))\r\nreturn -EINVAL;\r\nif (timings->pixel_clock == 0)\r\nreturn -EINVAL;\r\nif (dpi.dsidev) {\r\nok = dpi_dsi_clk_calc(timings->pixel_clock * 1000, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nfck = ctx.dsi_cinfo.dsi_pll_hsdiv_dispc_clk;\r\n} else {\r\nok = dpi_dss_clk_calc(timings->pixel_clock * 1000, &ctx);\r\nif (!ok)\r\nreturn -EINVAL;\r\nfck = ctx.dss_cinfo.fck;\r\n}\r\nlck_div = ctx.dispc_cinfo.lck_div;\r\npck_div = ctx.dispc_cinfo.pck_div;\r\npck = fck / lck_div / pck_div / 1000;\r\ntimings->pixel_clock = pck;\r\nreturn 0;\r\n}\r\nstatic void dpi_set_data_lines(struct omap_dss_device *dssdev, int data_lines)\r\n{\r\nmutex_lock(&dpi.lock);\r\ndpi.data_lines = data_lines;\r\nmutex_unlock(&dpi.lock);\r\n}\r\nstatic int dpi_verify_dsi_pll(struct platform_device *dsidev)\r\n{\r\nint r;\r\nr = dsi_runtime_get(dsidev);\r\nif (r)\r\nreturn r;\r\nr = dsi_pll_init(dsidev, 0, 1);\r\nif (r) {\r\ndsi_runtime_put(dsidev);\r\nreturn r;\r\n}\r\ndsi_pll_uninit(dsidev, true);\r\ndsi_runtime_put(dsidev);\r\nreturn 0;\r\n}\r\nstatic int dpi_init_regulator(void)\r\n{\r\nstruct regulator *vdds_dsi;\r\nif (!dss_has_feature(FEAT_DPI_USES_VDDS_DSI))\r\nreturn 0;\r\nif (dpi.vdds_dsi_reg)\r\nreturn 0;\r\nvdds_dsi = devm_regulator_get(&dpi.pdev->dev, "vdds_dsi");\r\nif (IS_ERR(vdds_dsi)) {\r\nDSSERR("can't get VDDS_DSI regulator\n");\r\nreturn PTR_ERR(vdds_dsi);\r\n}\r\ndpi.vdds_dsi_reg = vdds_dsi;\r\nreturn 0;\r\n}\r\nstatic void dpi_init_pll(void)\r\n{\r\nstruct platform_device *dsidev;\r\nif (dpi.dsidev)\r\nreturn;\r\ndsidev = dpi_get_dsidev(dpi.output.dispc_channel);\r\nif (!dsidev)\r\nreturn;\r\nif (dpi_verify_dsi_pll(dsidev)) {\r\nDSSWARN("DSI PLL not operational\n");\r\nreturn;\r\n}\r\ndpi.dsidev = dsidev;\r\n}\r\nstatic enum omap_channel dpi_get_channel(void)\r\n{\r\nswitch (omapdss_get_version()) {\r\ncase OMAPDSS_VER_OMAP24xx:\r\ncase OMAPDSS_VER_OMAP34xx_ES1:\r\ncase OMAPDSS_VER_OMAP34xx_ES3:\r\ncase OMAPDSS_VER_OMAP3630:\r\ncase OMAPDSS_VER_AM35xx:\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\ncase OMAPDSS_VER_OMAP4430_ES1:\r\ncase OMAPDSS_VER_OMAP4430_ES2:\r\ncase OMAPDSS_VER_OMAP4:\r\nreturn OMAP_DSS_CHANNEL_LCD2;\r\ncase OMAPDSS_VER_OMAP5:\r\nreturn OMAP_DSS_CHANNEL_LCD3;\r\ndefault:\r\nDSSWARN("unsupported DSS version\n");\r\nreturn OMAP_DSS_CHANNEL_LCD;\r\n}\r\n}\r\nstatic int dpi_connect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nstruct omap_overlay_manager *mgr;\r\nint r;\r\nr = dpi_init_regulator();\r\nif (r)\r\nreturn r;\r\ndpi_init_pll();\r\nmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\r\nif (!mgr)\r\nreturn -ENODEV;\r\nr = dss_mgr_connect(mgr, dssdev);\r\nif (r)\r\nreturn r;\r\nr = omapdss_output_set_device(dssdev, dst);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndst->name);\r\ndss_mgr_disconnect(mgr, dssdev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dpi_disconnect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nWARN_ON(dst != dssdev->dst);\r\nif (dst != dssdev->dst)\r\nreturn;\r\nomapdss_output_unset_device(dssdev);\r\nif (dssdev->manager)\r\ndss_mgr_disconnect(dssdev->manager, dssdev);\r\n}\r\nstatic void dpi_init_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &dpi.output;\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_DPI;\r\nout->output_type = OMAP_DISPLAY_TYPE_DPI;\r\nout->name = "dpi.0";\r\nout->dispc_channel = dpi_get_channel();\r\nout->ops.dpi = &dpi_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void __exit dpi_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &dpi.output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic int omap_dpi_probe(struct platform_device *pdev)\r\n{\r\ndpi.pdev = pdev;\r\nmutex_init(&dpi.lock);\r\ndpi_init_output(pdev);\r\nreturn 0;\r\n}\r\nstatic int __exit omap_dpi_remove(struct platform_device *pdev)\r\n{\r\ndpi_uninit_output(pdev);\r\nreturn 0;\r\n}\r\nint __init dpi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_dpi_driver);\r\n}\r\nvoid __exit dpi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_dpi_driver);\r\n}
