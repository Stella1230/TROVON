int Check_D_DataBlank(BYTE *redundant)\r\n{\r\nchar i;\r\nfor (i = 0; i < REDTSIZE; i++)\r\nif (*redundant++ != 0xFF)\r\nreturn ERROR;\r\nreturn SMSUCCESS;\r\n}\r\nint Check_D_FailBlock(BYTE *redundant)\r\n{\r\nredundant += REDT_BLOCK;\r\nif (*redundant == 0xFF)\r\nreturn SMSUCCESS;\r\nif (!*redundant)\r\nreturn ERROR;\r\nif (hweight8(*redundant) < 7)\r\nreturn ERROR;\r\nreturn SMSUCCESS;\r\n}\r\nint Check_D_DataStatus(BYTE *redundant)\r\n{\r\nredundant += REDT_DATA;\r\nif (*redundant == 0xFF)\r\nreturn SMSUCCESS;\r\nif (!*redundant) {\r\nErrXDCode = ERR_DataStatus;\r\nreturn ERROR;\r\n} else\r\nErrXDCode = NO_ERROR;\r\nif (hweight8(*redundant) < 5)\r\nreturn ERROR;\r\nreturn SMSUCCESS;\r\n}\r\nint Load_D_LogBlockAddr(BYTE *redundant)\r\n{\r\nWORD addr1, addr2;\r\naddr1 = (WORD)*(redundant + REDT_ADDR1H)*0x0100 +\r\n(WORD)*(redundant + REDT_ADDR1L);\r\naddr2 = (WORD)*(redundant + REDT_ADDR2H)*0x0100 +\r\n(WORD)*(redundant + REDT_ADDR2L);\r\nif (addr1 == addr2)\r\nif ((addr1 & 0xF000) == 0x1000) {\r\nMedia.LogBlock = (addr1 & 0x0FFF) / 2;\r\nreturn SMSUCCESS;\r\n}\r\nif (hweight16((WORD)(addr1^addr2)) != 0x01)\r\nreturn ERROR;\r\nif ((addr1 & 0xF000) == 0x1000)\r\nif (!(hweight16(addr1) & 0x01)) {\r\nMedia.LogBlock = (addr1 & 0x0FFF) / 2;\r\nreturn SMSUCCESS;\r\n}\r\nif ((addr2 & 0xF000) == 0x1000)\r\nif (!(hweight16(addr2) & 0x01)) {\r\nMedia.LogBlock = (addr2 & 0x0FFF) / 2;\r\nreturn SMSUCCESS;\r\n}\r\nreturn ERROR;\r\n}\r\nvoid Clr_D_RedundantData(BYTE *redundant)\r\n{\r\nchar i;\r\nfor (i = 0; i < REDTSIZE; i++)\r\n*(redundant + i) = 0xFF;\r\n}\r\nvoid Set_D_LogBlockAddr(BYTE *redundant)\r\n{\r\nWORD addr;\r\n*(redundant + REDT_BLOCK) = 0xFF;\r\n*(redundant + REDT_DATA) = 0xFF;\r\naddr = Media.LogBlock*2 + 0x1000;\r\nif ((hweight16(addr) % 2))\r\naddr++;\r\n*(redundant + REDT_ADDR1H) = *(redundant + REDT_ADDR2H) =\r\n(BYTE)(addr / 0x0100);\r\n*(redundant + REDT_ADDR1L) = *(redundant + REDT_ADDR2L) = (BYTE)addr;\r\n}\r\nvoid Set_D_FailBlock(BYTE *redundant)\r\n{\r\nchar i;\r\nfor (i = 0; i < REDTSIZE; i++)\r\n*redundant++ = (BYTE)((i == REDT_BLOCK) ? 0xF0 : 0xFF);\r\n}\r\nvoid Set_D_DataStaus(BYTE *redundant)\r\n{\r\nredundant += REDT_DATA;\r\n*redundant = 0x00;\r\n}\r\nvoid Ssfdc_D_Reset(struct us_data *us)\r\n{\r\nreturn;\r\n}\r\nint Ssfdc_D_ReadCisSect(struct us_data *us, BYTE *buf, BYTE *redundant)\r\n{\r\nBYTE zone, sector;\r\nWORD block;\r\nzone = Media.Zone; block = Media.PhyBlock; sector = Media.Sector;\r\nMedia.Zone = 0;\r\nMedia.PhyBlock = CisArea.PhyBlock;\r\nMedia.Sector = CisArea.Sector;\r\nif (Ssfdc_D_ReadSect(us, buf, redundant)) {\r\nMedia.Zone = zone;\r\nMedia.PhyBlock = block;\r\nMedia.Sector = sector;\r\nreturn ERROR;\r\n}\r\nMedia.Zone = zone; Media.PhyBlock = block; Media.Sector = sector;\r\nreturn SMSUCCESS;\r\n}\r\nint Ssfdc_D_ReadSect(struct us_data *us, BYTE *buf, BYTE *redundant)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD addr;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\naddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + Media.PhyBlock;\r\naddr = addr*(WORD)Ssfdc.MaxSectors + Media.Sector;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x02;\r\nbcb->CDB[4] = (BYTE)addr;\r\nbcb->CDB[3] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[2] = Media.Zone / 2;\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, buf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x10;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x03;\r\nbcb->CDB[4] = (BYTE)addr;\r\nbcb->CDB[3] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[2] = Media.Zone / 2;\r\nbcb->CDB[8] = 0;\r\nbcb->CDB[9] = 1;\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, redundant, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_ReadBlock(struct us_data *us, WORD count, BYTE *buf,\r\nBYTE *redundant)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD addr;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\naddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + Media.PhyBlock;\r\naddr = addr*(WORD)Ssfdc.MaxSectors + Media.Sector;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200*count;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x02;\r\nbcb->CDB[4] = (BYTE)addr;\r\nbcb->CDB[3] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[2] = Media.Zone / 2;\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, buf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x10;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x03;\r\nbcb->CDB[4] = (BYTE)addr;\r\nbcb->CDB[3] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[2] = Media.Zone / 2;\r\nbcb->CDB[8] = 0;\r\nbcb->CDB[9] = 1;\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, redundant, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_CopyBlock(struct us_data *us, WORD count, BYTE *buf,\r\nBYTE *redundant)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD ReadAddr, WriteAddr;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\nReadAddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + ReadBlock;\r\nReadAddr = ReadAddr*(WORD)Ssfdc.MaxSectors;\r\nWriteAddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + WriteBlock;\r\nWriteAddr = WriteAddr*(WORD)Ssfdc.MaxSectors;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200*count;\r\nbcb->Flags = 0x00;\r\nbcb->CDB[0] = 0xF0;\r\nbcb->CDB[1] = 0x08;\r\nbcb->CDB[7] = (BYTE)WriteAddr;\r\nbcb->CDB[6] = (BYTE)(WriteAddr / 0x0100);\r\nbcb->CDB[5] = Media.Zone / 2;\r\nbcb->CDB[8] = *(redundant + REDT_ADDR1H);\r\nbcb->CDB[9] = *(redundant + REDT_ADDR1L);\r\nbcb->CDB[10] = Media.Sector;\r\nif (ReadBlock != NO_ASSIGN) {\r\nbcb->CDB[4] = (BYTE)ReadAddr;\r\nbcb->CDB[3] = (BYTE)(ReadAddr / 0x0100);\r\nbcb->CDB[2] = Media.Zone / 2;\r\n} else\r\nbcb->CDB[11] = 1;\r\nresult = ENE_SendScsiCmd(us, FDIR_WRITE, buf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_WriteSectForCopy(struct us_data *us, BYTE *buf, BYTE *redundant)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD addr;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\naddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + Media.PhyBlock;\r\naddr = addr*(WORD)Ssfdc.MaxSectors + Media.Sector;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = 0x00;\r\nbcb->CDB[0] = 0xF0;\r\nbcb->CDB[1] = 0x04;\r\nbcb->CDB[7] = (BYTE)addr;\r\nbcb->CDB[6] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[5] = Media.Zone / 2;\r\nbcb->CDB[8] = *(redundant + REDT_ADDR1H);\r\nbcb->CDB[9] = *(redundant + REDT_ADDR1L);\r\nresult = ENE_SendScsiCmd(us, FDIR_WRITE, buf, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_EraseBlock(struct us_data *us)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD addr;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\naddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + Media.PhyBlock;\r\naddr = addr*(WORD)Ssfdc.MaxSectors;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x200;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF2;\r\nbcb->CDB[1] = 0x06;\r\nbcb->CDB[7] = (BYTE)addr;\r\nbcb->CDB[6] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[5] = Media.Zone / 2;\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, NULL, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_ReadRedtData(struct us_data *us, BYTE *redundant)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD addr;\r\nBYTE *buf;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\naddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + Media.PhyBlock;\r\naddr = addr*(WORD)Ssfdc.MaxSectors + Media.Sector;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x10;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF1;\r\nbcb->CDB[1] = 0x03;\r\nbcb->CDB[4] = (BYTE)addr;\r\nbcb->CDB[3] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[2] = Media.Zone / 2;\r\nbcb->CDB[8] = 0;\r\nbcb->CDB[9] = 1;\r\nbuf = kmalloc(0x10, GFP_KERNEL);\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, buf, 0);\r\nmemcpy(redundant, buf, 0x10);\r\nkfree(buf);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_WriteRedtData(struct us_data *us, BYTE *redundant)\r\n{\r\nstruct bulk_cb_wrap *bcb = (struct bulk_cb_wrap *) us->iobuf;\r\nint result;\r\nWORD addr;\r\nresult = ENE_LoadBinCode(us, SM_RW_PATTERN);\r\nif (result != USB_STOR_XFER_GOOD) {\r\ndev_err(&us->pusb_dev->dev,\r\n"Failed to load SmartMedia read/write code\n");\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\n}\r\naddr = (WORD)Media.Zone*Ssfdc.MaxBlocks + Media.PhyBlock;\r\naddr = addr*(WORD)Ssfdc.MaxSectors + Media.Sector;\r\nmemset(bcb, 0, sizeof(struct bulk_cb_wrap));\r\nbcb->Signature = cpu_to_le32(US_BULK_CB_SIGN);\r\nbcb->DataTransferLength = 0x10;\r\nbcb->Flags = 0x80;\r\nbcb->CDB[0] = 0xF2;\r\nbcb->CDB[1] = 0x05;\r\nbcb->CDB[7] = (BYTE)addr;\r\nbcb->CDB[6] = (BYTE)(addr / 0x0100);\r\nbcb->CDB[5] = Media.Zone / 2;\r\nbcb->CDB[8] = *(redundant + REDT_ADDR1H);\r\nbcb->CDB[9] = *(redundant + REDT_ADDR1L);\r\nresult = ENE_SendScsiCmd(us, FDIR_READ, NULL, 0);\r\nif (result != USB_STOR_XFER_GOOD)\r\nreturn USB_STOR_TRANSPORT_ERROR;\r\nreturn USB_STOR_TRANSPORT_GOOD;\r\n}\r\nint Ssfdc_D_CheckStatus(void)\r\n{\r\nreturn SMSUCCESS;\r\n}\r\nint Set_D_SsfdcModel(BYTE dcode)\r\n{\r\nswitch (_Check_D_DevCode(dcode)) {\r\ncase SSFDC1MB:\r\nSsfdc.Model = SSFDC1MB;\r\nSsfdc.Attribute = FLASH | AD3CYC | BS16 | PS256;\r\nSsfdc.MaxZones = 1;\r\nSsfdc.MaxBlocks = 256;\r\nSsfdc.MaxLogBlocks = 250;\r\nSsfdc.MaxSectors = 8;\r\nbreak;\r\ncase SSFDC2MB:\r\nSsfdc.Model = SSFDC2MB;\r\nSsfdc.Attribute = FLASH | AD3CYC | BS16 | PS256;\r\nSsfdc.MaxZones = 1;\r\nSsfdc.MaxBlocks = 512;\r\nSsfdc.MaxLogBlocks = 500;\r\nSsfdc.MaxSectors = 8;\r\nbreak;\r\ncase SSFDC4MB:\r\nSsfdc.Model = SSFDC4MB;\r\nSsfdc.Attribute = FLASH | AD3CYC | BS16 | PS512;\r\nSsfdc.MaxZones = 1;\r\nSsfdc.MaxBlocks = 512;\r\nSsfdc.MaxLogBlocks = 500;\r\nSsfdc.MaxSectors = 16;\r\nbreak;\r\ncase SSFDC8MB:\r\nSsfdc.Model = SSFDC8MB;\r\nSsfdc.Attribute = FLASH | AD3CYC | BS16 | PS512;\r\nSsfdc.MaxZones = 1;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 16;\r\nbreak;\r\ncase SSFDC16MB:\r\nSsfdc.Model = SSFDC16MB;\r\nSsfdc.Attribute = FLASH | AD3CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 1;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC32MB:\r\nSsfdc.Model = SSFDC32MB;\r\nSsfdc.Attribute = FLASH | AD3CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 2;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC64MB:\r\nSsfdc.Model = SSFDC64MB;\r\nSsfdc.Attribute = FLASH | AD4CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 4;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC128MB:\r\nSsfdc.Model = SSFDC128MB;\r\nSsfdc.Attribute = FLASH | AD4CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 8;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC256MB:\r\nSsfdc.Model = SSFDC256MB;\r\nSsfdc.Attribute = FLASH | AD4CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 16;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC512MB:\r\nSsfdc.Model = SSFDC512MB;\r\nSsfdc.Attribute = FLASH | AD4CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 32;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC1GB:\r\nSsfdc.Model = SSFDC1GB;\r\nSsfdc.Attribute = FLASH | AD4CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 64;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ncase SSFDC2GB:\r\nSsfdc.Model = SSFDC2GB;\r\nSsfdc.Attribute = FLASH | AD4CYC | BS32 | PS512;\r\nSsfdc.MaxZones = 128;\r\nSsfdc.MaxBlocks = 1024;\r\nSsfdc.MaxLogBlocks = 1000;\r\nSsfdc.MaxSectors = 32;\r\nbreak;\r\ndefault:\r\nSsfdc.Model = NOSSFDC;\r\nreturn ERROR;\r\n}\r\nreturn SMSUCCESS;\r\n}\r\nBYTE _Check_D_DevCode(BYTE dcode)\r\n{\r\nswitch (dcode) {\r\ncase 0x6E:\r\ncase 0xE8:\r\ncase 0xEC: return SSFDC1MB;\r\ncase 0x64:\r\ncase 0xEA: return SSFDC2MB;\r\ncase 0x6B:\r\ncase 0xE3:\r\ncase 0xE5: return SSFDC4MB;\r\ncase 0xE6: return SSFDC8MB;\r\ncase 0x73: return SSFDC16MB;\r\ncase 0x75: return SSFDC32MB;\r\ncase 0x76: return SSFDC64MB;\r\ncase 0x79: return SSFDC128MB;\r\ncase 0x71: return SSFDC256MB;\r\ncase 0xDC: return SSFDC512MB;\r\ncase 0xD3: return SSFDC1GB;\r\ncase 0xD5: return SSFDC2GB;\r\ndefault: return NOSSFDC;\r\n}\r\n}\r\nint Check_D_ReadError(BYTE *redundant)\r\n{\r\nreturn SMSUCCESS;\r\n}\r\nint Check_D_Correct(BYTE *buf, BYTE *redundant)\r\n{\r\nreturn SMSUCCESS;\r\n}\r\nint Check_D_CISdata(BYTE *buf, BYTE *redundant)\r\n{\r\nBYTE cis[] = {0x01, 0x03, 0xD9, 0x01, 0xFF, 0x18, 0x02,\r\n0xDF, 0x01, 0x20};\r\nint cis_len = sizeof(cis);\r\nif (!IsSSFDCCompliance && !IsXDCompliance)\r\nreturn SMSUCCESS;\r\nif (!memcmp(redundant + 0x0D, EccBuf, 3))\r\nreturn memcmp(buf, cis, cis_len);\r\nif (!_Correct_D_SwECC(buf, redundant + 0x0D, EccBuf))\r\nreturn memcmp(buf, cis, cis_len);\r\nbuf += 0x100;\r\nif (!memcmp(redundant + 0x08, EccBuf + 0x03, 3))\r\nreturn memcmp(buf, cis, cis_len);\r\nif (!_Correct_D_SwECC(buf, redundant + 0x08, EccBuf + 0x03))\r\nreturn memcmp(buf, cis, cis_len);\r\nreturn ERROR;\r\n}\r\nvoid Set_D_RightECC(BYTE *redundant)\r\n{\r\nreturn;\r\n}
