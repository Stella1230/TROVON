static void synusb_report_buttons(struct synusb *synusb)\r\n{\r\nstruct input_dev *input_dev = synusb->input;\r\ninput_report_key(input_dev, BTN_LEFT, synusb->data[1] & 0x04);\r\ninput_report_key(input_dev, BTN_RIGHT, synusb->data[1] & 0x01);\r\ninput_report_key(input_dev, BTN_MIDDLE, synusb->data[1] & 0x02);\r\n}\r\nstatic void synusb_report_stick(struct synusb *synusb)\r\n{\r\nstruct input_dev *input_dev = synusb->input;\r\nint x, y;\r\nunsigned int pressure;\r\npressure = synusb->data[6];\r\nx = (s16)(be16_to_cpup((__be16 *)&synusb->data[2]) << 3) >> 7;\r\ny = (s16)(be16_to_cpup((__be16 *)&synusb->data[4]) << 3) >> 7;\r\nif (pressure > 0) {\r\ninput_report_rel(input_dev, REL_X, x);\r\ninput_report_rel(input_dev, REL_Y, -y);\r\n}\r\ninput_report_abs(input_dev, ABS_PRESSURE, pressure);\r\nsynusb_report_buttons(synusb);\r\ninput_sync(input_dev);\r\n}\r\nstatic void synusb_report_touchpad(struct synusb *synusb)\r\n{\r\nstruct input_dev *input_dev = synusb->input;\r\nunsigned int num_fingers, tool_width;\r\nunsigned int x, y;\r\nunsigned int pressure, w;\r\npressure = synusb->data[6];\r\nx = be16_to_cpup((__be16 *)&synusb->data[2]);\r\ny = be16_to_cpup((__be16 *)&synusb->data[4]);\r\nw = synusb->data[0] & 0x0f;\r\nif (pressure > 0) {\r\nnum_fingers = 1;\r\ntool_width = 5;\r\nswitch (w) {\r\ncase 0 ... 1:\r\nnum_fingers = 2 + w;\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 4 ... 15:\r\ntool_width = w;\r\nbreak;\r\n}\r\n} else {\r\nnum_fingers = 0;\r\ntool_width = 0;\r\n}\r\nif (pressure > 30)\r\ninput_report_key(input_dev, BTN_TOUCH, 1);\r\nif (pressure < 25)\r\ninput_report_key(input_dev, BTN_TOUCH, 0);\r\nif (num_fingers > 0) {\r\ninput_report_abs(input_dev, ABS_X, x);\r\ninput_report_abs(input_dev, ABS_Y,\r\nYMAX_NOMINAL + YMIN_NOMINAL - y);\r\n}\r\ninput_report_abs(input_dev, ABS_PRESSURE, pressure);\r\ninput_report_abs(input_dev, ABS_TOOL_WIDTH, tool_width);\r\ninput_report_key(input_dev, BTN_TOOL_FINGER, num_fingers == 1);\r\ninput_report_key(input_dev, BTN_TOOL_DOUBLETAP, num_fingers == 2);\r\ninput_report_key(input_dev, BTN_TOOL_TRIPLETAP, num_fingers == 3);\r\nsynusb_report_buttons(synusb);\r\nif (synusb->flags & SYNUSB_AUXDISPLAY)\r\ninput_report_key(input_dev, BTN_MIDDLE, synusb->data[1] & 0x08);\r\ninput_sync(input_dev);\r\n}\r\nstatic void synusb_irq(struct urb *urb)\r\n{\r\nstruct synusb *synusb = urb->context;\r\nint error;\r\nswitch (urb->status) {\r\ncase 0:\r\nusb_mark_last_busy(synusb->udev);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ngoto resubmit;\r\nbreak;\r\n}\r\nif (synusb->flags & SYNUSB_STICK)\r\nsynusb_report_stick(synusb);\r\nelse\r\nsynusb_report_touchpad(synusb);\r\nresubmit:\r\nerror = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (error && error != -EPERM)\r\ndev_err(&synusb->intf->dev,\r\n"%s - usb_submit_urb failed with result: %d",\r\n__func__, error);\r\n}\r\nstatic struct usb_endpoint_descriptor *\r\nsynusb_get_in_endpoint(struct usb_host_interface *iface)\r\n{\r\nstruct usb_endpoint_descriptor *endpoint;\r\nint i;\r\nfor (i = 0; i < iface->desc.bNumEndpoints; ++i) {\r\nendpoint = &iface->endpoint[i].desc;\r\nif (usb_endpoint_is_int_in(endpoint)) {\r\nreturn endpoint;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic int synusb_open(struct input_dev *dev)\r\n{\r\nstruct synusb *synusb = input_get_drvdata(dev);\r\nint retval;\r\nretval = usb_autopm_get_interface(synusb->intf);\r\nif (retval) {\r\ndev_err(&synusb->intf->dev,\r\n"%s - usb_autopm_get_interface failed, error: %d\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\nretval = usb_submit_urb(synusb->urb, GFP_KERNEL);\r\nif (retval) {\r\ndev_err(&synusb->intf->dev,\r\n"%s - usb_submit_urb failed, error: %d\n",\r\n__func__, retval);\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nsynusb->intf->needs_remote_wakeup = 1;\r\nout:\r\nusb_autopm_put_interface(synusb->intf);\r\nreturn retval;\r\n}\r\nstatic void synusb_close(struct input_dev *dev)\r\n{\r\nstruct synusb *synusb = input_get_drvdata(dev);\r\nint autopm_error;\r\nautopm_error = usb_autopm_get_interface(synusb->intf);\r\nusb_kill_urb(synusb->urb);\r\nsynusb->intf->needs_remote_wakeup = 0;\r\nif (!autopm_error)\r\nusb_autopm_put_interface(synusb->intf);\r\n}\r\nstatic int synusb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct usb_endpoint_descriptor *ep;\r\nstruct synusb *synusb;\r\nstruct input_dev *input_dev;\r\nunsigned int intf_num = intf->cur_altsetting->desc.bInterfaceNumber;\r\nunsigned int altsetting = min(intf->num_altsetting, 1U);\r\nint error;\r\nerror = usb_set_interface(udev, intf_num, altsetting);\r\nif (error) {\r\ndev_err(&udev->dev,\r\n"Can not set alternate setting to %i, error: %i",\r\naltsetting, error);\r\nreturn error;\r\n}\r\nep = synusb_get_in_endpoint(intf->cur_altsetting);\r\nif (!ep)\r\nreturn -ENODEV;\r\nsynusb = kzalloc(sizeof(*synusb), GFP_KERNEL);\r\ninput_dev = input_allocate_device();\r\nif (!synusb || !input_dev) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nsynusb->udev = udev;\r\nsynusb->intf = intf;\r\nsynusb->input = input_dev;\r\nsynusb->flags = id->driver_info;\r\nif (synusb->flags & SYNUSB_COMBO) {\r\nsynusb->flags |= intf_num == 1 ?\r\nSYNUSB_STICK : SYNUSB_TOUCHPAD;\r\n}\r\nsynusb->urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!synusb->urb) {\r\nerror = -ENOMEM;\r\ngoto err_free_mem;\r\n}\r\nsynusb->data = usb_alloc_coherent(udev, SYNUSB_RECV_SIZE, GFP_KERNEL,\r\n&synusb->urb->transfer_dma);\r\nif (!synusb->data) {\r\nerror = -ENOMEM;\r\ngoto err_free_urb;\r\n}\r\nusb_fill_int_urb(synusb->urb, udev,\r\nusb_rcvintpipe(udev, ep->bEndpointAddress),\r\nsynusb->data, SYNUSB_RECV_SIZE,\r\nsynusb_irq, synusb,\r\nep->bInterval);\r\nsynusb->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nif (udev->manufacturer)\r\nstrlcpy(synusb->name, udev->manufacturer,\r\nsizeof(synusb->name));\r\nif (udev->product) {\r\nif (udev->manufacturer)\r\nstrlcat(synusb->name, " ", sizeof(synusb->name));\r\nstrlcat(synusb->name, udev->product, sizeof(synusb->name));\r\n}\r\nif (!strlen(synusb->name))\r\nsnprintf(synusb->name, sizeof(synusb->name),\r\n"USB Synaptics Device %04x:%04x",\r\nle16_to_cpu(udev->descriptor.idVendor),\r\nle16_to_cpu(udev->descriptor.idProduct));\r\nif (synusb->flags & SYNUSB_STICK)\r\nstrlcat(synusb->name, " (Stick)", sizeof(synusb->name));\r\nusb_make_path(udev, synusb->phys, sizeof(synusb->phys));\r\nstrlcat(synusb->phys, "/input0", sizeof(synusb->phys));\r\ninput_dev->name = synusb->name;\r\ninput_dev->phys = synusb->phys;\r\nusb_to_input_id(udev, &input_dev->id);\r\ninput_dev->dev.parent = &synusb->intf->dev;\r\nif (!(synusb->flags & SYNUSB_IO_ALWAYS)) {\r\ninput_dev->open = synusb_open;\r\ninput_dev->close = synusb_close;\r\n}\r\ninput_set_drvdata(input_dev, synusb);\r\n__set_bit(EV_ABS, input_dev->evbit);\r\n__set_bit(EV_KEY, input_dev->evbit);\r\nif (synusb->flags & SYNUSB_STICK) {\r\n__set_bit(EV_REL, input_dev->evbit);\r\n__set_bit(REL_X, input_dev->relbit);\r\n__set_bit(REL_Y, input_dev->relbit);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, 127, 0, 0);\r\n} else {\r\ninput_set_abs_params(input_dev, ABS_X,\r\nXMIN_NOMINAL, XMAX_NOMINAL, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_Y,\r\nYMIN_NOMINAL, YMAX_NOMINAL, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_PRESSURE, 0, 255, 0, 0);\r\ninput_set_abs_params(input_dev, ABS_TOOL_WIDTH, 0, 15, 0, 0);\r\n__set_bit(BTN_TOUCH, input_dev->keybit);\r\n__set_bit(BTN_TOOL_FINGER, input_dev->keybit);\r\n__set_bit(BTN_TOOL_DOUBLETAP, input_dev->keybit);\r\n__set_bit(BTN_TOOL_TRIPLETAP, input_dev->keybit);\r\n}\r\n__set_bit(BTN_LEFT, input_dev->keybit);\r\n__set_bit(BTN_RIGHT, input_dev->keybit);\r\n__set_bit(BTN_MIDDLE, input_dev->keybit);\r\nusb_set_intfdata(intf, synusb);\r\nif (synusb->flags & SYNUSB_IO_ALWAYS) {\r\nerror = synusb_open(input_dev);\r\nif (error)\r\ngoto err_free_dma;\r\n}\r\nerror = input_register_device(input_dev);\r\nif (error) {\r\ndev_err(&udev->dev,\r\n"Failed to register input device, error %d\n",\r\nerror);\r\ngoto err_stop_io;\r\n}\r\nreturn 0;\r\nerr_stop_io:\r\nif (synusb->flags & SYNUSB_IO_ALWAYS)\r\nsynusb_close(synusb->input);\r\nerr_free_dma:\r\nusb_free_coherent(udev, SYNUSB_RECV_SIZE, synusb->data,\r\nsynusb->urb->transfer_dma);\r\nerr_free_urb:\r\nusb_free_urb(synusb->urb);\r\nerr_free_mem:\r\ninput_free_device(input_dev);\r\nkfree(synusb);\r\nusb_set_intfdata(intf, NULL);\r\nreturn error;\r\n}\r\nstatic void synusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct synusb *synusb = usb_get_intfdata(intf);\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nif (synusb->flags & SYNUSB_IO_ALWAYS)\r\nsynusb_close(synusb->input);\r\ninput_unregister_device(synusb->input);\r\nusb_free_coherent(udev, SYNUSB_RECV_SIZE, synusb->data,\r\nsynusb->urb->transfer_dma);\r\nusb_free_urb(synusb->urb);\r\nkfree(synusb);\r\nusb_set_intfdata(intf, NULL);\r\n}\r\nstatic int synusb_suspend(struct usb_interface *intf, pm_message_t message)\r\n{\r\nstruct synusb *synusb = usb_get_intfdata(intf);\r\nstruct input_dev *input_dev = synusb->input;\r\nmutex_lock(&input_dev->mutex);\r\nusb_kill_urb(synusb->urb);\r\nmutex_unlock(&input_dev->mutex);\r\nreturn 0;\r\n}\r\nstatic int synusb_resume(struct usb_interface *intf)\r\n{\r\nstruct synusb *synusb = usb_get_intfdata(intf);\r\nstruct input_dev *input_dev = synusb->input;\r\nint retval = 0;\r\nmutex_lock(&input_dev->mutex);\r\nif ((input_dev->users || (synusb->flags & SYNUSB_IO_ALWAYS)) &&\r\nusb_submit_urb(synusb->urb, GFP_NOIO) < 0) {\r\nretval = -EIO;\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\nreturn retval;\r\n}\r\nstatic int synusb_pre_reset(struct usb_interface *intf)\r\n{\r\nstruct synusb *synusb = usb_get_intfdata(intf);\r\nstruct input_dev *input_dev = synusb->input;\r\nmutex_lock(&input_dev->mutex);\r\nusb_kill_urb(synusb->urb);\r\nreturn 0;\r\n}\r\nstatic int synusb_post_reset(struct usb_interface *intf)\r\n{\r\nstruct synusb *synusb = usb_get_intfdata(intf);\r\nstruct input_dev *input_dev = synusb->input;\r\nint retval = 0;\r\nif ((input_dev->users || (synusb->flags & SYNUSB_IO_ALWAYS)) &&\r\nusb_submit_urb(synusb->urb, GFP_NOIO) < 0) {\r\nretval = -EIO;\r\n}\r\nmutex_unlock(&input_dev->mutex);\r\nreturn retval;\r\n}\r\nstatic int synusb_reset_resume(struct usb_interface *intf)\r\n{\r\nreturn synusb_resume(intf);\r\n}
