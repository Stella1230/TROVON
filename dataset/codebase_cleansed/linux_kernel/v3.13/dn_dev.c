static void dn_dev_sysctl_register(struct net_device *dev, struct dn_dev_parms *parms)\r\n{\r\nstruct dn_dev_sysctl_table *t;\r\nint i;\r\nchar path[sizeof("net/decnet/conf/") + IFNAMSIZ];\r\nt = kmemdup(&dn_dev_sysctl, sizeof(*t), GFP_KERNEL);\r\nif (t == NULL)\r\nreturn;\r\nfor(i = 0; i < ARRAY_SIZE(t->dn_dev_vars) - 1; i++) {\r\nlong offset = (long)t->dn_dev_vars[i].data;\r\nt->dn_dev_vars[i].data = ((char *)parms) + offset;\r\n}\r\nsnprintf(path, sizeof(path), "net/decnet/conf/%s",\r\ndev? dev->name : parms->name);\r\nt->dn_dev_vars[0].extra1 = (void *)dev;\r\nt->sysctl_header = register_net_sysctl(&init_net, path, t->dn_dev_vars);\r\nif (t->sysctl_header == NULL)\r\nkfree(t);\r\nelse\r\nparms->sysctl = t;\r\n}\r\nstatic void dn_dev_sysctl_unregister(struct dn_dev_parms *parms)\r\n{\r\nif (parms->sysctl) {\r\nstruct dn_dev_sysctl_table *t = parms->sysctl;\r\nparms->sysctl = NULL;\r\nunregister_net_sysctl_table(t->sysctl_header);\r\nkfree(t);\r\n}\r\n}\r\nstatic int dn_forwarding_proc(struct ctl_table *table, int write,\r\nvoid __user *buffer,\r\nsize_t *lenp, loff_t *ppos)\r\n{\r\n#ifdef CONFIG_DECNET_ROUTER\r\nstruct net_device *dev = table->extra1;\r\nstruct dn_dev *dn_db;\r\nint err;\r\nint tmp, old;\r\nif (table->extra1 == NULL)\r\nreturn -EINVAL;\r\ndn_db = rcu_dereference_raw(dev->dn_ptr);\r\nold = dn_db->parms.forwarding;\r\nerr = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif ((err >= 0) && write) {\r\nif (dn_db->parms.forwarding < 0)\r\ndn_db->parms.forwarding = 0;\r\nif (dn_db->parms.forwarding > 2)\r\ndn_db->parms.forwarding = 2;\r\ntmp = dn_db->parms.forwarding;\r\ndn_db->parms.forwarding = old;\r\nif (dn_db->parms.down)\r\ndn_db->parms.down(dev);\r\ndn_db->parms.forwarding = tmp;\r\nif (dn_db->parms.up)\r\ndn_db->parms.up(dev);\r\n}\r\nreturn err;\r\n#else\r\nreturn -EINVAL;\r\n#endif\r\n}\r\nstatic void dn_dev_sysctl_unregister(struct dn_dev_parms *parms)\r\n{\r\n}\r\nstatic void dn_dev_sysctl_register(struct net_device *dev, struct dn_dev_parms *parms)\r\n{\r\n}\r\nstatic inline __u16 mtu2blksize(struct net_device *dev)\r\n{\r\nu32 blksize = dev->mtu;\r\nif (blksize > 0xffff)\r\nblksize = 0xffff;\r\nif (dev->type == ARPHRD_ETHER ||\r\ndev->type == ARPHRD_PPP ||\r\ndev->type == ARPHRD_IPGRE ||\r\ndev->type == ARPHRD_LOOPBACK)\r\nblksize -= 2;\r\nreturn (__u16)blksize;\r\n}\r\nstatic struct dn_ifaddr *dn_dev_alloc_ifa(void)\r\n{\r\nstruct dn_ifaddr *ifa;\r\nifa = kzalloc(sizeof(*ifa), GFP_KERNEL);\r\nreturn ifa;\r\n}\r\nstatic void dn_dev_free_ifa(struct dn_ifaddr *ifa)\r\n{\r\nkfree_rcu(ifa, rcu);\r\n}\r\nstatic void dn_dev_del_ifa(struct dn_dev *dn_db, struct dn_ifaddr __rcu **ifap, int destroy)\r\n{\r\nstruct dn_ifaddr *ifa1 = rtnl_dereference(*ifap);\r\nunsigned char mac_addr[6];\r\nstruct net_device *dev = dn_db->dev;\r\nASSERT_RTNL();\r\n*ifap = ifa1->ifa_next;\r\nif (dn_db->dev->type == ARPHRD_ETHER) {\r\nif (ifa1->ifa_local != dn_eth2dn(dev->dev_addr)) {\r\ndn_dn2eth(mac_addr, ifa1->ifa_local);\r\ndev_mc_del(dev, mac_addr);\r\n}\r\n}\r\ndn_ifaddr_notify(RTM_DELADDR, ifa1);\r\nblocking_notifier_call_chain(&dnaddr_chain, NETDEV_DOWN, ifa1);\r\nif (destroy) {\r\ndn_dev_free_ifa(ifa1);\r\nif (dn_db->ifa_list == NULL)\r\ndn_dev_delete(dn_db->dev);\r\n}\r\n}\r\nstatic int dn_dev_insert_ifa(struct dn_dev *dn_db, struct dn_ifaddr *ifa)\r\n{\r\nstruct net_device *dev = dn_db->dev;\r\nstruct dn_ifaddr *ifa1;\r\nunsigned char mac_addr[6];\r\nASSERT_RTNL();\r\nfor (ifa1 = rtnl_dereference(dn_db->ifa_list);\r\nifa1 != NULL;\r\nifa1 = rtnl_dereference(ifa1->ifa_next)) {\r\nif (ifa1->ifa_local == ifa->ifa_local)\r\nreturn -EEXIST;\r\n}\r\nif (dev->type == ARPHRD_ETHER) {\r\nif (ifa->ifa_local != dn_eth2dn(dev->dev_addr)) {\r\ndn_dn2eth(mac_addr, ifa->ifa_local);\r\ndev_mc_add(dev, mac_addr);\r\n}\r\n}\r\nifa->ifa_next = dn_db->ifa_list;\r\nrcu_assign_pointer(dn_db->ifa_list, ifa);\r\ndn_ifaddr_notify(RTM_NEWADDR, ifa);\r\nblocking_notifier_call_chain(&dnaddr_chain, NETDEV_UP, ifa);\r\nreturn 0;\r\n}\r\nstatic int dn_dev_set_ifa(struct net_device *dev, struct dn_ifaddr *ifa)\r\n{\r\nstruct dn_dev *dn_db = rtnl_dereference(dev->dn_ptr);\r\nint rv;\r\nif (dn_db == NULL) {\r\nint err;\r\ndn_db = dn_dev_create(dev, &err);\r\nif (dn_db == NULL)\r\nreturn err;\r\n}\r\nifa->ifa_dev = dn_db;\r\nif (dev->flags & IFF_LOOPBACK)\r\nifa->ifa_scope = RT_SCOPE_HOST;\r\nrv = dn_dev_insert_ifa(dn_db, ifa);\r\nif (rv)\r\ndn_dev_free_ifa(ifa);\r\nreturn rv;\r\n}\r\nint dn_dev_ioctl(unsigned int cmd, void __user *arg)\r\n{\r\nchar buffer[DN_IFREQ_SIZE];\r\nstruct ifreq *ifr = (struct ifreq *)buffer;\r\nstruct sockaddr_dn *sdn = (struct sockaddr_dn *)&ifr->ifr_addr;\r\nstruct dn_dev *dn_db;\r\nstruct net_device *dev;\r\nstruct dn_ifaddr *ifa = NULL;\r\nstruct dn_ifaddr __rcu **ifap = NULL;\r\nint ret = 0;\r\nif (copy_from_user(ifr, arg, DN_IFREQ_SIZE))\r\nreturn -EFAULT;\r\nifr->ifr_name[IFNAMSIZ-1] = 0;\r\ndev_load(&init_net, ifr->ifr_name);\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\nbreak;\r\ncase SIOCSIFADDR:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EACCES;\r\nif (sdn->sdn_family != AF_DECnet)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nrtnl_lock();\r\nif ((dev = __dev_get_by_name(&init_net, ifr->ifr_name)) == NULL) {\r\nret = -ENODEV;\r\ngoto done;\r\n}\r\nif ((dn_db = rtnl_dereference(dev->dn_ptr)) != NULL) {\r\nfor (ifap = &dn_db->ifa_list;\r\n(ifa = rtnl_dereference(*ifap)) != NULL;\r\nifap = &ifa->ifa_next)\r\nif (strcmp(ifr->ifr_name, ifa->ifa_label) == 0)\r\nbreak;\r\n}\r\nif (ifa == NULL && cmd != SIOCSIFADDR) {\r\nret = -EADDRNOTAVAIL;\r\ngoto done;\r\n}\r\nswitch (cmd) {\r\ncase SIOCGIFADDR:\r\n*((__le16 *)sdn->sdn_nodeaddr) = ifa->ifa_local;\r\ngoto rarok;\r\ncase SIOCSIFADDR:\r\nif (!ifa) {\r\nif ((ifa = dn_dev_alloc_ifa()) == NULL) {\r\nret = -ENOBUFS;\r\nbreak;\r\n}\r\nmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\r\n} else {\r\nif (ifa->ifa_local == dn_saddr2dn(sdn))\r\nbreak;\r\ndn_dev_del_ifa(dn_db, ifap, 0);\r\n}\r\nifa->ifa_local = ifa->ifa_address = dn_saddr2dn(sdn);\r\nret = dn_dev_set_ifa(dev, ifa);\r\n}\r\ndone:\r\nrtnl_unlock();\r\nreturn ret;\r\nrarok:\r\nif (copy_to_user(arg, ifr, DN_IFREQ_SIZE))\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nstruct net_device *dn_dev_get_default(void)\r\n{\r\nstruct net_device *dev;\r\nspin_lock(&dndev_lock);\r\ndev = decnet_default_device;\r\nif (dev) {\r\nif (dev->dn_ptr)\r\ndev_hold(dev);\r\nelse\r\ndev = NULL;\r\n}\r\nspin_unlock(&dndev_lock);\r\nreturn dev;\r\n}\r\nint dn_dev_set_default(struct net_device *dev, int force)\r\n{\r\nstruct net_device *old = NULL;\r\nint rv = -EBUSY;\r\nif (!dev->dn_ptr)\r\nreturn -ENODEV;\r\nspin_lock(&dndev_lock);\r\nif (force || decnet_default_device == NULL) {\r\nold = decnet_default_device;\r\ndecnet_default_device = dev;\r\nrv = 0;\r\n}\r\nspin_unlock(&dndev_lock);\r\nif (old)\r\ndev_put(old);\r\nreturn rv;\r\n}\r\nstatic void dn_dev_check_default(struct net_device *dev)\r\n{\r\nspin_lock(&dndev_lock);\r\nif (dev == decnet_default_device) {\r\ndecnet_default_device = NULL;\r\n} else {\r\ndev = NULL;\r\n}\r\nspin_unlock(&dndev_lock);\r\nif (dev)\r\ndev_put(dev);\r\n}\r\nstatic struct dn_dev *dn_dev_by_index(int ifindex)\r\n{\r\nstruct net_device *dev;\r\nstruct dn_dev *dn_dev = NULL;\r\ndev = __dev_get_by_index(&init_net, ifindex);\r\nif (dev)\r\ndn_dev = rtnl_dereference(dev->dn_ptr);\r\nreturn dn_dev;\r\n}\r\nstatic int dn_nl_deladdr(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct dn_dev *dn_db;\r\nstruct ifaddrmsg *ifm;\r\nstruct dn_ifaddr *ifa;\r\nstruct dn_ifaddr __rcu **ifap;\r\nint err = -EINVAL;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!net_eq(net, &init_net))\r\ngoto errout;\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, dn_ifa_policy);\r\nif (err < 0)\r\ngoto errout;\r\nerr = -ENODEV;\r\nifm = nlmsg_data(nlh);\r\nif ((dn_db = dn_dev_by_index(ifm->ifa_index)) == NULL)\r\ngoto errout;\r\nerr = -EADDRNOTAVAIL;\r\nfor (ifap = &dn_db->ifa_list;\r\n(ifa = rtnl_dereference(*ifap)) != NULL;\r\nifap = &ifa->ifa_next) {\r\nif (tb[IFA_LOCAL] &&\r\nnla_memcmp(tb[IFA_LOCAL], &ifa->ifa_local, 2))\r\ncontinue;\r\nif (tb[IFA_LABEL] && nla_strcmp(tb[IFA_LABEL], ifa->ifa_label))\r\ncontinue;\r\ndn_dev_del_ifa(dn_db, ifap, 1);\r\nreturn 0;\r\n}\r\nerrout:\r\nreturn err;\r\n}\r\nstatic int dn_nl_newaddr(struct sk_buff *skb, struct nlmsghdr *nlh)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nstruct nlattr *tb[IFA_MAX+1];\r\nstruct net_device *dev;\r\nstruct dn_dev *dn_db;\r\nstruct ifaddrmsg *ifm;\r\nstruct dn_ifaddr *ifa;\r\nint err;\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (!net_eq(net, &init_net))\r\nreturn -EINVAL;\r\nerr = nlmsg_parse(nlh, sizeof(*ifm), tb, IFA_MAX, dn_ifa_policy);\r\nif (err < 0)\r\nreturn err;\r\nif (tb[IFA_LOCAL] == NULL)\r\nreturn -EINVAL;\r\nifm = nlmsg_data(nlh);\r\nif ((dev = __dev_get_by_index(&init_net, ifm->ifa_index)) == NULL)\r\nreturn -ENODEV;\r\nif ((dn_db = rtnl_dereference(dev->dn_ptr)) == NULL) {\r\ndn_db = dn_dev_create(dev, &err);\r\nif (!dn_db)\r\nreturn err;\r\n}\r\nif ((ifa = dn_dev_alloc_ifa()) == NULL)\r\nreturn -ENOBUFS;\r\nif (tb[IFA_ADDRESS] == NULL)\r\ntb[IFA_ADDRESS] = tb[IFA_LOCAL];\r\nifa->ifa_local = nla_get_le16(tb[IFA_LOCAL]);\r\nifa->ifa_address = nla_get_le16(tb[IFA_ADDRESS]);\r\nifa->ifa_flags = ifm->ifa_flags;\r\nifa->ifa_scope = ifm->ifa_scope;\r\nifa->ifa_dev = dn_db;\r\nif (tb[IFA_LABEL])\r\nnla_strlcpy(ifa->ifa_label, tb[IFA_LABEL], IFNAMSIZ);\r\nelse\r\nmemcpy(ifa->ifa_label, dev->name, IFNAMSIZ);\r\nerr = dn_dev_insert_ifa(dn_db, ifa);\r\nif (err)\r\ndn_dev_free_ifa(ifa);\r\nreturn err;\r\n}\r\nstatic inline size_t dn_ifaddr_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifaddrmsg))\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(2)\r\n+ nla_total_size(2);\r\n}\r\nstatic int dn_nl_fill_ifaddr(struct sk_buff *skb, struct dn_ifaddr *ifa,\r\nu32 portid, u32 seq, int event, unsigned int flags)\r\n{\r\nstruct ifaddrmsg *ifm;\r\nstruct nlmsghdr *nlh;\r\nnlh = nlmsg_put(skb, portid, seq, event, sizeof(*ifm), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nifm = nlmsg_data(nlh);\r\nifm->ifa_family = AF_DECnet;\r\nifm->ifa_prefixlen = 16;\r\nifm->ifa_flags = ifa->ifa_flags | IFA_F_PERMANENT;\r\nifm->ifa_scope = ifa->ifa_scope;\r\nifm->ifa_index = ifa->ifa_dev->dev->ifindex;\r\nif ((ifa->ifa_address &&\r\nnla_put_le16(skb, IFA_ADDRESS, ifa->ifa_address)) ||\r\n(ifa->ifa_local &&\r\nnla_put_le16(skb, IFA_LOCAL, ifa->ifa_local)) ||\r\n(ifa->ifa_label[0] &&\r\nnla_put_string(skb, IFA_LABEL, ifa->ifa_label)))\r\ngoto nla_put_failure;\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic void dn_ifaddr_notify(int event, struct dn_ifaddr *ifa)\r\n{\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nskb = alloc_skb(dn_ifaddr_nlmsg_size(), GFP_KERNEL);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = dn_nl_fill_ifaddr(skb, ifa, 0, 0, event, 0);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, &init_net, 0, RTNLGRP_DECnet_IFADDR, NULL, GFP_KERNEL);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(&init_net, RTNLGRP_DECnet_IFADDR, err);\r\n}\r\nstatic int dn_nl_dump_ifaddr(struct sk_buff *skb, struct netlink_callback *cb)\r\n{\r\nstruct net *net = sock_net(skb->sk);\r\nint idx, dn_idx = 0, skip_ndevs, skip_naddr;\r\nstruct net_device *dev;\r\nstruct dn_dev *dn_db;\r\nstruct dn_ifaddr *ifa;\r\nif (!net_eq(net, &init_net))\r\nreturn 0;\r\nskip_ndevs = cb->args[0];\r\nskip_naddr = cb->args[1];\r\nidx = 0;\r\nrcu_read_lock();\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif (idx < skip_ndevs)\r\ngoto cont;\r\nelse if (idx > skip_ndevs) {\r\nskip_naddr = 0;\r\n}\r\nif ((dn_db = rcu_dereference(dev->dn_ptr)) == NULL)\r\ngoto cont;\r\nfor (ifa = rcu_dereference(dn_db->ifa_list), dn_idx = 0; ifa;\r\nifa = rcu_dereference(ifa->ifa_next), dn_idx++) {\r\nif (dn_idx < skip_naddr)\r\ncontinue;\r\nif (dn_nl_fill_ifaddr(skb, ifa, NETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, RTM_NEWADDR,\r\nNLM_F_MULTI) < 0)\r\ngoto done;\r\n}\r\ncont:\r\nidx++;\r\n}\r\ndone:\r\nrcu_read_unlock();\r\ncb->args[0] = idx;\r\ncb->args[1] = dn_idx;\r\nreturn skb->len;\r\n}\r\nstatic int dn_dev_get_first(struct net_device *dev, __le16 *addr)\r\n{\r\nstruct dn_dev *dn_db;\r\nstruct dn_ifaddr *ifa;\r\nint rv = -ENODEV;\r\nrcu_read_lock();\r\ndn_db = rcu_dereference(dev->dn_ptr);\r\nif (dn_db == NULL)\r\ngoto out;\r\nifa = rcu_dereference(dn_db->ifa_list);\r\nif (ifa != NULL) {\r\n*addr = ifa->ifa_local;\r\nrv = 0;\r\n}\r\nout:\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nint dn_dev_bind_default(__le16 *addr)\r\n{\r\nstruct net_device *dev;\r\nint rv;\r\ndev = dn_dev_get_default();\r\nlast_chance:\r\nif (dev) {\r\nrv = dn_dev_get_first(dev, addr);\r\ndev_put(dev);\r\nif (rv == 0 || dev == init_net.loopback_dev)\r\nreturn rv;\r\n}\r\ndev = init_net.loopback_dev;\r\ndev_hold(dev);\r\ngoto last_chance;\r\n}\r\nstatic void dn_send_endnode_hello(struct net_device *dev, struct dn_ifaddr *ifa)\r\n{\r\nstruct endnode_hello_message *msg;\r\nstruct sk_buff *skb = NULL;\r\n__le16 *pktlen;\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nif ((skb = dn_alloc_skb(NULL, sizeof(*msg), GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb->dev = dev;\r\nmsg = (struct endnode_hello_message *)skb_put(skb,sizeof(*msg));\r\nmsg->msgflg = 0x0D;\r\nmemcpy(msg->tiver, dn_eco_version, 3);\r\ndn_dn2eth(msg->id, ifa->ifa_local);\r\nmsg->iinfo = DN_RT_INFO_ENDN;\r\nmsg->blksize = cpu_to_le16(mtu2blksize(dev));\r\nmsg->area = 0x00;\r\nmemset(msg->seed, 0, 8);\r\nmemcpy(msg->neighbor, dn_hiord, ETH_ALEN);\r\nif (dn_db->router) {\r\nstruct dn_neigh *dn = (struct dn_neigh *)dn_db->router;\r\ndn_dn2eth(msg->neighbor, dn->addr);\r\n}\r\nmsg->timer = cpu_to_le16((unsigned short)dn_db->parms.t3);\r\nmsg->mpd = 0x00;\r\nmsg->datalen = 0x02;\r\nmemset(msg->data, 0xAA, 2);\r\npktlen = (__le16 *)skb_push(skb,2);\r\n*pktlen = cpu_to_le16(skb->len - 2);\r\nskb_reset_network_header(skb);\r\ndn_rt_finish_output(skb, dn_rt_all_rt_mcast, msg->id);\r\n}\r\nstatic int dn_am_i_a_router(struct dn_neigh *dn, struct dn_dev *dn_db, struct dn_ifaddr *ifa)\r\n{\r\nif ((jiffies - dn_db->uptime) < DRDELAY)\r\nreturn 0;\r\nif (!dn_db->router)\r\nreturn 1;\r\nif (dn->priority < dn_db->parms.priority)\r\nreturn 1;\r\nif (dn->priority != dn_db->parms.priority)\r\nreturn 0;\r\nif (le16_to_cpu(dn->addr) < le16_to_cpu(ifa->ifa_local))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void dn_send_router_hello(struct net_device *dev, struct dn_ifaddr *ifa)\r\n{\r\nint n;\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nstruct dn_neigh *dn = (struct dn_neigh *)dn_db->router;\r\nstruct sk_buff *skb;\r\nsize_t size;\r\nunsigned char *ptr;\r\nunsigned char *i1, *i2;\r\n__le16 *pktlen;\r\nchar *src;\r\nif (mtu2blksize(dev) < (26 + 7))\r\nreturn;\r\nn = mtu2blksize(dev) - 26;\r\nn /= 7;\r\nif (n > 32)\r\nn = 32;\r\nsize = 2 + 26 + 7 * n;\r\nif ((skb = dn_alloc_skb(NULL, size, GFP_ATOMIC)) == NULL)\r\nreturn;\r\nskb->dev = dev;\r\nptr = skb_put(skb, size);\r\n*ptr++ = DN_RT_PKT_CNTL | DN_RT_PKT_ERTH;\r\n*ptr++ = 2;\r\n*ptr++ = 0;\r\n*ptr++ = 0;\r\ndn_dn2eth(ptr, ifa->ifa_local);\r\nsrc = ptr;\r\nptr += ETH_ALEN;\r\n*ptr++ = dn_db->parms.forwarding == 1 ?\r\nDN_RT_INFO_L1RT : DN_RT_INFO_L2RT;\r\n*((__le16 *)ptr) = cpu_to_le16(mtu2blksize(dev));\r\nptr += 2;\r\n*ptr++ = dn_db->parms.priority;\r\n*ptr++ = 0;\r\n*((__le16 *)ptr) = cpu_to_le16((unsigned short)dn_db->parms.t3);\r\nptr += 2;\r\n*ptr++ = 0;\r\ni1 = ptr++;\r\nmemset(ptr, 0, 7);\r\nptr += 7;\r\ni2 = ptr++;\r\nn = dn_neigh_elist(dev, ptr, n);\r\n*i2 = 7 * n;\r\n*i1 = 8 + *i2;\r\nskb_trim(skb, (27 + *i2));\r\npktlen = (__le16 *)skb_push(skb, 2);\r\n*pktlen = cpu_to_le16(skb->len - 2);\r\nskb_reset_network_header(skb);\r\nif (dn_am_i_a_router(dn, dn_db, ifa)) {\r\nstruct sk_buff *skb2 = skb_copy(skb, GFP_ATOMIC);\r\nif (skb2) {\r\ndn_rt_finish_output(skb2, dn_rt_all_end_mcast, src);\r\n}\r\n}\r\ndn_rt_finish_output(skb, dn_rt_all_rt_mcast, src);\r\n}\r\nstatic void dn_send_brd_hello(struct net_device *dev, struct dn_ifaddr *ifa)\r\n{\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nif (dn_db->parms.forwarding == 0)\r\ndn_send_endnode_hello(dev, ifa);\r\nelse\r\ndn_send_router_hello(dev, ifa);\r\n}\r\nstatic void dn_send_ptp_hello(struct net_device *dev, struct dn_ifaddr *ifa)\r\n{\r\nint tdlen = 16;\r\nint size = dev->hard_header_len + 2 + 4 + tdlen;\r\nstruct sk_buff *skb = dn_alloc_skb(NULL, size, GFP_ATOMIC);\r\nint i;\r\nunsigned char *ptr;\r\nchar src[ETH_ALEN];\r\nif (skb == NULL)\r\nreturn ;\r\nskb->dev = dev;\r\nskb_push(skb, dev->hard_header_len);\r\nptr = skb_put(skb, 2 + 4 + tdlen);\r\n*ptr++ = DN_RT_PKT_HELO;\r\n*((__le16 *)ptr) = ifa->ifa_local;\r\nptr += 2;\r\n*ptr++ = tdlen;\r\nfor(i = 0; i < tdlen; i++)\r\n*ptr++ = 0252;\r\ndn_dn2eth(src, ifa->ifa_local);\r\ndn_rt_finish_output(skb, dn_rt_all_rt_mcast, src);\r\n}\r\nstatic int dn_eth_up(struct net_device *dev)\r\n{\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nif (dn_db->parms.forwarding == 0)\r\ndev_mc_add(dev, dn_rt_all_end_mcast);\r\nelse\r\ndev_mc_add(dev, dn_rt_all_rt_mcast);\r\ndn_db->use_long = 1;\r\nreturn 0;\r\n}\r\nstatic void dn_eth_down(struct net_device *dev)\r\n{\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nif (dn_db->parms.forwarding == 0)\r\ndev_mc_del(dev, dn_rt_all_end_mcast);\r\nelse\r\ndev_mc_del(dev, dn_rt_all_rt_mcast);\r\n}\r\nstatic void dn_dev_timer_func(unsigned long arg)\r\n{\r\nstruct net_device *dev = (struct net_device *)arg;\r\nstruct dn_dev *dn_db;\r\nstruct dn_ifaddr *ifa;\r\nrcu_read_lock();\r\ndn_db = rcu_dereference(dev->dn_ptr);\r\nif (dn_db->t3 <= dn_db->parms.t2) {\r\nif (dn_db->parms.timer3) {\r\nfor (ifa = rcu_dereference(dn_db->ifa_list);\r\nifa;\r\nifa = rcu_dereference(ifa->ifa_next)) {\r\nif (!(ifa->ifa_flags & IFA_F_SECONDARY))\r\ndn_db->parms.timer3(dev, ifa);\r\n}\r\n}\r\ndn_db->t3 = dn_db->parms.t3;\r\n} else {\r\ndn_db->t3 -= dn_db->parms.t2;\r\n}\r\nrcu_read_unlock();\r\ndn_dev_set_timer(dev);\r\n}\r\nstatic void dn_dev_set_timer(struct net_device *dev)\r\n{\r\nstruct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);\r\nif (dn_db->parms.t2 > dn_db->parms.t3)\r\ndn_db->parms.t2 = dn_db->parms.t3;\r\ndn_db->timer.data = (unsigned long)dev;\r\ndn_db->timer.function = dn_dev_timer_func;\r\ndn_db->timer.expires = jiffies + (dn_db->parms.t2 * HZ);\r\nadd_timer(&dn_db->timer);\r\n}\r\nstatic struct dn_dev *dn_dev_create(struct net_device *dev, int *err)\r\n{\r\nint i;\r\nstruct dn_dev_parms *p = dn_dev_list;\r\nstruct dn_dev *dn_db;\r\nfor(i = 0; i < DN_DEV_LIST_SIZE; i++, p++) {\r\nif (p->type == dev->type)\r\nbreak;\r\n}\r\n*err = -ENODEV;\r\nif (i == DN_DEV_LIST_SIZE)\r\nreturn NULL;\r\n*err = -ENOBUFS;\r\nif ((dn_db = kzalloc(sizeof(struct dn_dev), GFP_ATOMIC)) == NULL)\r\nreturn NULL;\r\nmemcpy(&dn_db->parms, p, sizeof(struct dn_dev_parms));\r\nrcu_assign_pointer(dev->dn_ptr, dn_db);\r\ndn_db->dev = dev;\r\ninit_timer(&dn_db->timer);\r\ndn_db->uptime = jiffies;\r\ndn_db->neigh_parms = neigh_parms_alloc(dev, &dn_neigh_table);\r\nif (!dn_db->neigh_parms) {\r\nRCU_INIT_POINTER(dev->dn_ptr, NULL);\r\nkfree(dn_db);\r\nreturn NULL;\r\n}\r\nif (dn_db->parms.up) {\r\nif (dn_db->parms.up(dev) < 0) {\r\nneigh_parms_release(&dn_neigh_table, dn_db->neigh_parms);\r\ndev->dn_ptr = NULL;\r\nkfree(dn_db);\r\nreturn NULL;\r\n}\r\n}\r\ndn_dev_sysctl_register(dev, &dn_db->parms);\r\ndn_dev_set_timer(dev);\r\n*err = 0;\r\nreturn dn_db;\r\n}\r\nvoid dn_dev_up(struct net_device *dev)\r\n{\r\nstruct dn_ifaddr *ifa;\r\n__le16 addr = decnet_address;\r\nint maybe_default = 0;\r\nstruct dn_dev *dn_db = rtnl_dereference(dev->dn_ptr);\r\nif ((dev->type != ARPHRD_ETHER) && (dev->type != ARPHRD_LOOPBACK))\r\nreturn;\r\nif (dn_db == NULL) {\r\nint err;\r\ndn_db = dn_dev_create(dev, &err);\r\nif (dn_db == NULL)\r\nreturn;\r\n}\r\nif (dev->type == ARPHRD_ETHER) {\r\nif (memcmp(dev->dev_addr, dn_hiord, 4) != 0)\r\nreturn;\r\naddr = dn_eth2dn(dev->dev_addr);\r\nmaybe_default = 1;\r\n}\r\nif (addr == 0)\r\nreturn;\r\nif ((ifa = dn_dev_alloc_ifa()) == NULL)\r\nreturn;\r\nifa->ifa_local = ifa->ifa_address = addr;\r\nifa->ifa_flags = 0;\r\nifa->ifa_scope = RT_SCOPE_UNIVERSE;\r\nstrcpy(ifa->ifa_label, dev->name);\r\ndn_dev_set_ifa(dev, ifa);\r\nif (maybe_default) {\r\ndev_hold(dev);\r\nif (dn_dev_set_default(dev, 0))\r\ndev_put(dev);\r\n}\r\n}\r\nstatic void dn_dev_delete(struct net_device *dev)\r\n{\r\nstruct dn_dev *dn_db = rtnl_dereference(dev->dn_ptr);\r\nif (dn_db == NULL)\r\nreturn;\r\ndel_timer_sync(&dn_db->timer);\r\ndn_dev_sysctl_unregister(&dn_db->parms);\r\ndn_dev_check_default(dev);\r\nneigh_ifdown(&dn_neigh_table, dev);\r\nif (dn_db->parms.down)\r\ndn_db->parms.down(dev);\r\ndev->dn_ptr = NULL;\r\nneigh_parms_release(&dn_neigh_table, dn_db->neigh_parms);\r\nneigh_ifdown(&dn_neigh_table, dev);\r\nif (dn_db->router)\r\nneigh_release(dn_db->router);\r\nif (dn_db->peer)\r\nneigh_release(dn_db->peer);\r\nkfree(dn_db);\r\n}\r\nvoid dn_dev_down(struct net_device *dev)\r\n{\r\nstruct dn_dev *dn_db = rtnl_dereference(dev->dn_ptr);\r\nstruct dn_ifaddr *ifa;\r\nif (dn_db == NULL)\r\nreturn;\r\nwhile ((ifa = rtnl_dereference(dn_db->ifa_list)) != NULL) {\r\ndn_dev_del_ifa(dn_db, &dn_db->ifa_list, 0);\r\ndn_dev_free_ifa(ifa);\r\n}\r\ndn_dev_delete(dev);\r\n}\r\nvoid dn_dev_init_pkt(struct sk_buff *skb)\r\n{\r\n}\r\nvoid dn_dev_veri_pkt(struct sk_buff *skb)\r\n{\r\n}\r\nvoid dn_dev_hello(struct sk_buff *skb)\r\n{\r\n}\r\nvoid dn_dev_devices_off(void)\r\n{\r\nstruct net_device *dev;\r\nrtnl_lock();\r\nfor_each_netdev(&init_net, dev)\r\ndn_dev_down(dev);\r\nrtnl_unlock();\r\n}\r\nvoid dn_dev_devices_on(void)\r\n{\r\nstruct net_device *dev;\r\nrtnl_lock();\r\nfor_each_netdev(&init_net, dev) {\r\nif (dev->flags & IFF_UP)\r\ndn_dev_up(dev);\r\n}\r\nrtnl_unlock();\r\n}\r\nint register_dnaddr_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_register(&dnaddr_chain, nb);\r\n}\r\nint unregister_dnaddr_notifier(struct notifier_block *nb)\r\n{\r\nreturn blocking_notifier_chain_unregister(&dnaddr_chain, nb);\r\n}\r\nstatic inline int is_dn_dev(struct net_device *dev)\r\n{\r\nreturn dev->dn_ptr != NULL;\r\n}\r\nstatic void *dn_dev_seq_start(struct seq_file *seq, loff_t *pos)\r\n__acquires(RCU)\r\n{\r\nint i;\r\nstruct net_device *dev;\r\nrcu_read_lock();\r\nif (*pos == 0)\r\nreturn SEQ_START_TOKEN;\r\ni = 1;\r\nfor_each_netdev_rcu(&init_net, dev) {\r\nif (!is_dn_dev(dev))\r\ncontinue;\r\nif (i++ == *pos)\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *dn_dev_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\nstruct net_device *dev;\r\n++*pos;\r\ndev = v;\r\nif (v == SEQ_START_TOKEN)\r\ndev = net_device_entry(&init_net.dev_base_head);\r\nfor_each_netdev_continue_rcu(&init_net, dev) {\r\nif (!is_dn_dev(dev))\r\ncontinue;\r\nreturn dev;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void dn_dev_seq_stop(struct seq_file *seq, void *v)\r\n__releases(RCU)\r\n{\r\nrcu_read_unlock();\r\n}\r\nstatic char *dn_type2asc(char type)\r\n{\r\nswitch (type) {\r\ncase DN_DEV_BCAST:\r\nreturn "B";\r\ncase DN_DEV_UCAST:\r\nreturn "U";\r\ncase DN_DEV_MPOINT:\r\nreturn "M";\r\n}\r\nreturn "?";\r\n}\r\nstatic int dn_dev_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "Name Flags T1 Timer1 T3 Timer3 BlkSize Pri State DevType Router Peer\n");\r\nelse {\r\nstruct net_device *dev = v;\r\nchar peer_buf[DN_ASCBUF_LEN];\r\nchar router_buf[DN_ASCBUF_LEN];\r\nstruct dn_dev *dn_db = rcu_dereference(dev->dn_ptr);\r\nseq_printf(seq, "%-8s %1s %04u %04u %04lu %04lu"\r\n" %04hu %03d %02x %-10s %-7s %-7s\n",\r\ndev->name ? dev->name : "???",\r\ndn_type2asc(dn_db->parms.mode),\r\n0, 0,\r\ndn_db->t3, dn_db->parms.t3,\r\nmtu2blksize(dev),\r\ndn_db->parms.priority,\r\ndn_db->parms.state, dn_db->parms.name,\r\ndn_db->router ? dn_addr2asc(le16_to_cpu(*(__le16 *)dn_db->router->primary_key), router_buf) : "",\r\ndn_db->peer ? dn_addr2asc(le16_to_cpu(*(__le16 *)dn_db->peer->primary_key), peer_buf) : "");\r\n}\r\nreturn 0;\r\n}\r\nstatic int dn_dev_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &dn_dev_seq_ops);\r\n}\r\nvoid __init dn_dev_init(void)\r\n{\r\nif (addr[0] > 63 || addr[0] < 0) {\r\nprintk(KERN_ERR "DECnet: Area must be between 0 and 63");\r\nreturn;\r\n}\r\nif (addr[1] > 1023 || addr[1] < 0) {\r\nprintk(KERN_ERR "DECnet: Node must be between 0 and 1023");\r\nreturn;\r\n}\r\ndecnet_address = cpu_to_le16((addr[0] << 10) | addr[1]);\r\ndn_dev_devices_on();\r\nrtnl_register(PF_DECnet, RTM_NEWADDR, dn_nl_newaddr, NULL, NULL);\r\nrtnl_register(PF_DECnet, RTM_DELADDR, dn_nl_deladdr, NULL, NULL);\r\nrtnl_register(PF_DECnet, RTM_GETADDR, NULL, dn_nl_dump_ifaddr, NULL);\r\nproc_create("decnet_dev", S_IRUGO, init_net.proc_net, &dn_dev_seq_fops);\r\n#ifdef CONFIG_SYSCTL\r\n{\r\nint i;\r\nfor(i = 0; i < DN_DEV_LIST_SIZE; i++)\r\ndn_dev_sysctl_register(NULL, &dn_dev_list[i]);\r\n}\r\n#endif\r\n}\r\nvoid __exit dn_dev_cleanup(void)\r\n{\r\n#ifdef CONFIG_SYSCTL\r\n{\r\nint i;\r\nfor(i = 0; i < DN_DEV_LIST_SIZE; i++)\r\ndn_dev_sysctl_unregister(&dn_dev_list[i]);\r\n}\r\n#endif\r\nremove_proc_entry("decnet_dev", init_net.proc_net);\r\ndn_dev_devices_off();\r\n}
