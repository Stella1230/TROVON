static int dt2815_wait_for_status(struct comedi_device *dev, int status)\r\n{\r\nint i;\r\nfor (i = 0; i < 100; i++) {\r\nif (inb(dev->iobase + DT2815_STATUS) == status)\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic int dt2815_ao_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt2815_private *devpriv = dev->private;\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nfor (i = 0; i < insn->n; i++)\r\ndata[i] = devpriv->ao_readback[chan];\r\nreturn i;\r\n}\r\nstatic int dt2815_ao_insn(struct comedi_device *dev, struct comedi_subdevice *s,\r\nstruct comedi_insn *insn, unsigned int *data)\r\n{\r\nstruct dt2815_private *devpriv = dev->private;\r\nint i;\r\nint chan = CR_CHAN(insn->chanspec);\r\nunsigned int status;\r\nunsigned int lo, hi;\r\nfor (i = 0; i < insn->n; i++) {\r\nlo = ((data[i] & 0x0f) << 4) | (chan << 1) | 0x01;\r\nhi = (data[i] & 0xff0) >> 4;\r\nstatus = dt2815_wait_for_status(dev, 0x00);\r\nif (status != 0) {\r\nprintk(KERN_WARNING "dt2815: failed to write low byte "\r\n"on %d reason %x\n", chan, status);\r\nreturn -EBUSY;\r\n}\r\noutb(lo, dev->iobase + DT2815_DATA);\r\nstatus = dt2815_wait_for_status(dev, 0x10);\r\nif (status != 0x10) {\r\nprintk(KERN_WARNING "dt2815: failed to write high byte "\r\n"on %d reason %x\n", chan, status);\r\nreturn -EBUSY;\r\n}\r\ndevpriv->ao_readback[chan] = data[i];\r\n}\r\nreturn i;\r\n}\r\nstatic int dt2815_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nstruct dt2815_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint i;\r\nconst struct comedi_lrange *current_range_type, *voltage_range_type;\r\nint ret;\r\nret = comedi_request_region(dev, it->options[0], DT2815_SIZE);\r\nif (ret)\r\nreturn ret;\r\nret = comedi_alloc_subdevices(dev, 1);\r\nif (ret)\r\nreturn ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->maxdata = 0xfff;\r\ns->n_chan = 8;\r\ns->insn_write = dt2815_ao_insn;\r\ns->insn_read = dt2815_ao_insn_read;\r\ns->range_table_list = devpriv->range_type_list;\r\ncurrent_range_type = (it->options[3])\r\n? &range_4_20mA : &range_0_32mA;\r\nvoltage_range_type = (it->options[2])\r\n? &range_bipolar5 : &range_unipolar5;\r\nfor (i = 0; i < 8; i++) {\r\ndevpriv->range_type_list[i] = (it->options[5 + i])\r\n? current_range_type : voltage_range_type;\r\n}\r\noutb(0x00, dev->iobase + DT2815_STATUS);\r\nfor (i = 0; i < 100; i++) {\r\nunsigned int status;\r\nudelay(1000);\r\nstatus = inb(dev->iobase + DT2815_STATUS);\r\nif (status == 4) {\r\nunsigned int program;\r\nprogram = (it->options[4] & 0x3) << 3 | 0x7;\r\noutb(program, dev->iobase + DT2815_DATA);\r\nprintk(KERN_INFO ", program: 0x%x (@t=%d)\n",\r\nprogram, i);\r\nbreak;\r\n} else if (status != 0x00) {\r\nprintk(KERN_WARNING "dt2815: unexpected status 0x%x "\r\n"(@t=%d)\n", status, i);\r\nif (status & 0x60)\r\noutb(0x00, dev->iobase + DT2815_STATUS);\r\n}\r\n}\r\nreturn 0;\r\n}
