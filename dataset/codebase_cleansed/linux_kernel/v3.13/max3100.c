static int max3100_do_parity(struct max3100_port *s, u16 c)\r\n{\r\nint parity;\r\nif (s->parity & MAX3100_PARITY_ODD)\r\nparity = 1;\r\nelse\r\nparity = 0;\r\nif (s->parity & MAX3100_7BIT)\r\nc &= 0x7f;\r\nelse\r\nc &= 0xff;\r\nparity = parity ^ (hweight8(c) & 1);\r\nreturn parity;\r\n}\r\nstatic int max3100_check_parity(struct max3100_port *s, u16 c)\r\n{\r\nreturn max3100_do_parity(s, c) == ((c >> 8) & 1);\r\n}\r\nstatic void max3100_calc_parity(struct max3100_port *s, u16 *c)\r\n{\r\nif (s->parity & MAX3100_7BIT)\r\n*c &= 0x7f;\r\nelse\r\n*c &= 0xff;\r\nif (s->parity & MAX3100_PARITY_ON)\r\n*c |= max3100_do_parity(s, *c) << 8;\r\n}\r\nstatic void max3100_dowork(struct max3100_port *s)\r\n{\r\nif (!s->force_end_work && !freezing(current) && !s->suspending)\r\nqueue_work(s->workqueue, &s->work);\r\n}\r\nstatic void max3100_timeout(unsigned long data)\r\n{\r\nstruct max3100_port *s = (struct max3100_port *)data;\r\nif (s->port.state) {\r\nmax3100_dowork(s);\r\nmod_timer(&s->timer, jiffies + s->poll_time);\r\n}\r\n}\r\nstatic int max3100_sr(struct max3100_port *s, u16 tx, u16 *rx)\r\n{\r\nstruct spi_message message;\r\nu16 etx, erx;\r\nint status;\r\nstruct spi_transfer tran = {\r\n.tx_buf = &etx,\r\n.rx_buf = &erx,\r\n.len = 2,\r\n};\r\netx = cpu_to_be16(tx);\r\nspi_message_init(&message);\r\nspi_message_add_tail(&tran, &message);\r\nstatus = spi_sync(s->spi, &message);\r\nif (status) {\r\ndev_warn(&s->spi->dev, "error while calling spi_sync\n");\r\nreturn -EIO;\r\n}\r\n*rx = be16_to_cpu(erx);\r\ns->tx_empty = (*rx & MAX3100_T) > 0;\r\ndev_dbg(&s->spi->dev, "%04x - %04x\n", tx, *rx);\r\nreturn 0;\r\n}\r\nstatic int max3100_handlerx(struct max3100_port *s, u16 rx)\r\n{\r\nunsigned int ch, flg, status = 0;\r\nint ret = 0, cts;\r\nif (rx & MAX3100_R && s->rx_enabled) {\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nch = rx & (s->parity & MAX3100_7BIT ? 0x7f : 0xff);\r\nif (rx & MAX3100_RAFE) {\r\ns->port.icount.frame++;\r\nflg = TTY_FRAME;\r\nstatus |= MAX3100_STATUS_FE;\r\n} else {\r\nif (s->parity & MAX3100_PARITY_ON) {\r\nif (max3100_check_parity(s, rx)) {\r\ns->port.icount.rx++;\r\nflg = TTY_NORMAL;\r\n} else {\r\ns->port.icount.parity++;\r\nflg = TTY_PARITY;\r\nstatus |= MAX3100_STATUS_PE;\r\n}\r\n} else {\r\ns->port.icount.rx++;\r\nflg = TTY_NORMAL;\r\n}\r\n}\r\nuart_insert_char(&s->port, status, MAX3100_STATUS_OE, ch, flg);\r\nret = 1;\r\n}\r\ncts = (rx & MAX3100_CTS) > 0;\r\nif (s->cts != cts) {\r\ns->cts = cts;\r\nuart_handle_cts_change(&s->port, cts ? TIOCM_CTS : 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic void max3100_work(struct work_struct *w)\r\n{\r\nstruct max3100_port *s = container_of(w, struct max3100_port, work);\r\nint rxchars;\r\nu16 tx, rx;\r\nint conf, cconf, rts, crts;\r\nstruct circ_buf *xmit = &s->port.state->xmit;\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nrxchars = 0;\r\ndo {\r\nspin_lock(&s->conf_lock);\r\nconf = s->conf;\r\ncconf = s->conf_commit;\r\ns->conf_commit = 0;\r\nrts = s->rts;\r\ncrts = s->rts_commit;\r\ns->rts_commit = 0;\r\nspin_unlock(&s->conf_lock);\r\nif (cconf)\r\nmax3100_sr(s, MAX3100_WC | conf, &rx);\r\nif (crts) {\r\nmax3100_sr(s, MAX3100_WD | MAX3100_TE |\r\n(s->rts ? MAX3100_RTS : 0), &rx);\r\nrxchars += max3100_handlerx(s, rx);\r\n}\r\nmax3100_sr(s, MAX3100_RD, &rx);\r\nrxchars += max3100_handlerx(s, rx);\r\nif (rx & MAX3100_T) {\r\ntx = 0xffff;\r\nif (s->port.x_char) {\r\ntx = s->port.x_char;\r\ns->port.icount.tx++;\r\ns->port.x_char = 0;\r\n} else if (!uart_circ_empty(xmit) &&\r\n!uart_tx_stopped(&s->port)) {\r\ntx = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) &\r\n(UART_XMIT_SIZE - 1);\r\ns->port.icount.tx++;\r\n}\r\nif (tx != 0xffff) {\r\nmax3100_calc_parity(s, &tx);\r\ntx |= MAX3100_WD | (s->rts ? MAX3100_RTS : 0);\r\nmax3100_sr(s, tx, &rx);\r\nrxchars += max3100_handlerx(s, rx);\r\n}\r\n}\r\nif (rxchars > 16) {\r\ntty_flip_buffer_push(&s->port.state->port);\r\nrxchars = 0;\r\n}\r\nif (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)\r\nuart_write_wakeup(&s->port);\r\n} while (!s->force_end_work &&\r\n!freezing(current) &&\r\n((rx & MAX3100_R) ||\r\n(!uart_circ_empty(xmit) &&\r\n!uart_tx_stopped(&s->port))));\r\nif (rxchars > 0)\r\ntty_flip_buffer_push(&s->port.state->port);\r\n}\r\nstatic irqreturn_t max3100_irq(int irqno, void *dev_id)\r\n{\r\nstruct max3100_port *s = dev_id;\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nmax3100_dowork(s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void max3100_enable_ms(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\nif (s->poll_time > 0)\r\nmod_timer(&s->timer, jiffies);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\n}\r\nstatic void max3100_start_tx(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nmax3100_dowork(s);\r\n}\r\nstatic void max3100_stop_rx(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\ns->rx_enabled = 0;\r\nspin_lock(&s->conf_lock);\r\ns->conf &= ~MAX3100_RM;\r\ns->conf_commit = 1;\r\nspin_unlock(&s->conf_lock);\r\nmax3100_dowork(s);\r\n}\r\nstatic unsigned int max3100_tx_empty(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nmax3100_dowork(s);\r\nreturn s->tx_empty;\r\n}\r\nstatic unsigned int max3100_get_mctrl(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nmax3100_dowork(s);\r\nreturn (s->cts ? TIOCM_CTS : 0) | TIOCM_DSR | TIOCM_CAR;\r\n}\r\nstatic void max3100_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\nint rts;\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nrts = (mctrl & TIOCM_RTS) > 0;\r\nspin_lock(&s->conf_lock);\r\nif (s->rts != rts) {\r\ns->rts = rts;\r\ns->rts_commit = 1;\r\nmax3100_dowork(s);\r\n}\r\nspin_unlock(&s->conf_lock);\r\n}\r\nstatic void\r\nmax3100_set_termios(struct uart_port *port, struct ktermios *termios,\r\nstruct ktermios *old)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\nint baud = 0;\r\nunsigned cflag;\r\nu32 param_new, param_mask, parity = 0;\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\ncflag = termios->c_cflag;\r\nparam_new = 0;\r\nparam_mask = 0;\r\nbaud = tty_termios_baud_rate(termios);\r\nparam_new = s->conf & MAX3100_BAUD;\r\nswitch (baud) {\r\ncase 300:\r\nif (s->crystal)\r\nbaud = s->baud;\r\nelse\r\nparam_new = 15;\r\nbreak;\r\ncase 600:\r\nparam_new = 14 + s->crystal;\r\nbreak;\r\ncase 1200:\r\nparam_new = 13 + s->crystal;\r\nbreak;\r\ncase 2400:\r\nparam_new = 12 + s->crystal;\r\nbreak;\r\ncase 4800:\r\nparam_new = 11 + s->crystal;\r\nbreak;\r\ncase 9600:\r\nparam_new = 10 + s->crystal;\r\nbreak;\r\ncase 19200:\r\nparam_new = 9 + s->crystal;\r\nbreak;\r\ncase 38400:\r\nparam_new = 8 + s->crystal;\r\nbreak;\r\ncase 57600:\r\nparam_new = 1 + s->crystal;\r\nbreak;\r\ncase 115200:\r\nparam_new = 0 + s->crystal;\r\nbreak;\r\ncase 230400:\r\nif (s->crystal)\r\nparam_new = 0;\r\nelse\r\nbaud = s->baud;\r\nbreak;\r\ndefault:\r\nbaud = s->baud;\r\n}\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\ns->baud = baud;\r\nparam_mask |= MAX3100_BAUD;\r\nif ((cflag & CSIZE) == CS8) {\r\nparam_new &= ~MAX3100_L;\r\nparity &= ~MAX3100_7BIT;\r\n} else {\r\nparam_new |= MAX3100_L;\r\nparity |= MAX3100_7BIT;\r\ncflag = (cflag & ~CSIZE) | CS7;\r\n}\r\nparam_mask |= MAX3100_L;\r\nif (cflag & CSTOPB)\r\nparam_new |= MAX3100_ST;\r\nelse\r\nparam_new &= ~MAX3100_ST;\r\nparam_mask |= MAX3100_ST;\r\nif (cflag & PARENB) {\r\nparam_new |= MAX3100_PE;\r\nparity |= MAX3100_PARITY_ON;\r\n} else {\r\nparam_new &= ~MAX3100_PE;\r\nparity &= ~MAX3100_PARITY_ON;\r\n}\r\nparam_mask |= MAX3100_PE;\r\nif (cflag & PARODD)\r\nparity |= MAX3100_PARITY_ODD;\r\nelse\r\nparity &= ~MAX3100_PARITY_ODD;\r\ncflag &= ~CMSPAR;\r\ntermios->c_cflag = cflag;\r\ns->port.ignore_status_mask = 0;\r\nif (termios->c_iflag & IGNPAR)\r\ns->port.ignore_status_mask |=\r\nMAX3100_STATUS_PE | MAX3100_STATUS_FE |\r\nMAX3100_STATUS_OE;\r\ns->port.state->port.low_latency = 1;\r\nif (s->poll_time > 0)\r\ndel_timer_sync(&s->timer);\r\nuart_update_timeout(port, termios->c_cflag, baud);\r\nspin_lock(&s->conf_lock);\r\ns->conf = (s->conf & ~param_mask) | (param_new & param_mask);\r\ns->conf_commit = 1;\r\ns->parity = parity;\r\nspin_unlock(&s->conf_lock);\r\nmax3100_dowork(s);\r\nif (UART_ENABLE_MS(&s->port, termios->c_cflag))\r\nmax3100_enable_ms(&s->port);\r\n}\r\nstatic void max3100_shutdown(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nif (s->suspending)\r\nreturn;\r\ns->force_end_work = 1;\r\nif (s->poll_time > 0)\r\ndel_timer_sync(&s->timer);\r\nif (s->workqueue) {\r\nflush_workqueue(s->workqueue);\r\ndestroy_workqueue(s->workqueue);\r\ns->workqueue = NULL;\r\n}\r\nif (s->irq)\r\nfree_irq(s->irq, s);\r\nif (s->max3100_hw_suspend)\r\ns->max3100_hw_suspend(1);\r\nelse {\r\nu16 tx, rx;\r\ntx = MAX3100_WC | MAX3100_SHDN;\r\nmax3100_sr(s, tx, &rx);\r\n}\r\n}\r\nstatic int max3100_startup(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\nchar b[12];\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\ns->conf = MAX3100_RM;\r\ns->baud = s->crystal ? 230400 : 115200;\r\ns->rx_enabled = 1;\r\nif (s->suspending)\r\nreturn 0;\r\ns->force_end_work = 0;\r\ns->parity = 0;\r\ns->rts = 0;\r\nsprintf(b, "max3100-%d", s->minor);\r\ns->workqueue = create_freezable_workqueue(b);\r\nif (!s->workqueue) {\r\ndev_warn(&s->spi->dev, "cannot create workqueue\n");\r\nreturn -EBUSY;\r\n}\r\nINIT_WORK(&s->work, max3100_work);\r\nif (request_irq(s->irq, max3100_irq,\r\nIRQF_TRIGGER_FALLING, "max3100", s) < 0) {\r\ndev_warn(&s->spi->dev, "cannot allocate irq %d\n", s->irq);\r\ns->irq = 0;\r\ndestroy_workqueue(s->workqueue);\r\ns->workqueue = NULL;\r\nreturn -EBUSY;\r\n}\r\nif (s->loopback) {\r\nu16 tx, rx;\r\ntx = 0x4001;\r\nmax3100_sr(s, tx, &rx);\r\n}\r\nif (s->max3100_hw_suspend)\r\ns->max3100_hw_suspend(0);\r\ns->conf_commit = 1;\r\nmax3100_dowork(s);\r\nmsleep(50);\r\nmax3100_enable_ms(&s->port);\r\nreturn 0;\r\n}\r\nstatic const char *max3100_type(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nreturn s->port.type == PORT_MAX3100 ? "MAX3100" : NULL;\r\n}\r\nstatic void max3100_release_port(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\n}\r\nstatic void max3100_config_port(struct uart_port *port, int flags)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nif (flags & UART_CONFIG_TYPE)\r\ns->port.type = PORT_MAX3100;\r\n}\r\nstatic int max3100_verify_port(struct uart_port *port,\r\nstruct serial_struct *ser)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\nint ret = -EINVAL;\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nif (ser->type == PORT_UNKNOWN || ser->type == PORT_MAX3100)\r\nret = 0;\r\nreturn ret;\r\n}\r\nstatic void max3100_stop_tx(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\n}\r\nstatic int max3100_request_port(struct uart_port *port)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nreturn 0;\r\n}\r\nstatic void max3100_break_ctl(struct uart_port *port, int break_state)\r\n{\r\nstruct max3100_port *s = container_of(port,\r\nstruct max3100_port,\r\nport);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\n}\r\nstatic int max3100_probe(struct spi_device *spi)\r\n{\r\nint i, retval;\r\nstruct plat_max3100 *pdata;\r\nu16 tx, rx;\r\nmutex_lock(&max3100s_lock);\r\nif (!uart_driver_registered) {\r\nuart_driver_registered = 1;\r\nretval = uart_register_driver(&max3100_uart_driver);\r\nif (retval) {\r\nprintk(KERN_ERR "Couldn't register max3100 uart driver\n");\r\nmutex_unlock(&max3100s_lock);\r\nreturn retval;\r\n}\r\n}\r\nfor (i = 0; i < MAX_MAX3100; i++)\r\nif (!max3100s[i])\r\nbreak;\r\nif (i == MAX_MAX3100) {\r\ndev_warn(&spi->dev, "too many MAX3100 chips\n");\r\nmutex_unlock(&max3100s_lock);\r\nreturn -ENOMEM;\r\n}\r\nmax3100s[i] = kzalloc(sizeof(struct max3100_port), GFP_KERNEL);\r\nif (!max3100s[i]) {\r\ndev_warn(&spi->dev,\r\n"kmalloc for max3100 structure %d failed!\n", i);\r\nmutex_unlock(&max3100s_lock);\r\nreturn -ENOMEM;\r\n}\r\nmax3100s[i]->spi = spi;\r\nmax3100s[i]->irq = spi->irq;\r\nspin_lock_init(&max3100s[i]->conf_lock);\r\nspi_set_drvdata(spi, max3100s[i]);\r\npdata = dev_get_platdata(&spi->dev);\r\nmax3100s[i]->crystal = pdata->crystal;\r\nmax3100s[i]->loopback = pdata->loopback;\r\nmax3100s[i]->poll_time = pdata->poll_time * HZ / 1000;\r\nif (pdata->poll_time > 0 && max3100s[i]->poll_time == 0)\r\nmax3100s[i]->poll_time = 1;\r\nmax3100s[i]->max3100_hw_suspend = pdata->max3100_hw_suspend;\r\nmax3100s[i]->minor = i;\r\ninit_timer(&max3100s[i]->timer);\r\nmax3100s[i]->timer.function = max3100_timeout;\r\nmax3100s[i]->timer.data = (unsigned long) max3100s[i];\r\ndev_dbg(&spi->dev, "%s: adding port %d\n", __func__, i);\r\nmax3100s[i]->port.irq = max3100s[i]->irq;\r\nmax3100s[i]->port.uartclk = max3100s[i]->crystal ? 3686400 : 1843200;\r\nmax3100s[i]->port.fifosize = 16;\r\nmax3100s[i]->port.ops = &max3100_ops;\r\nmax3100s[i]->port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF;\r\nmax3100s[i]->port.line = i;\r\nmax3100s[i]->port.type = PORT_MAX3100;\r\nmax3100s[i]->port.dev = &spi->dev;\r\nretval = uart_add_one_port(&max3100_uart_driver, &max3100s[i]->port);\r\nif (retval < 0)\r\ndev_warn(&spi->dev,\r\n"uart_add_one_port failed for line %d with error %d\n",\r\ni, retval);\r\nif (max3100s[i]->max3100_hw_suspend)\r\nmax3100s[i]->max3100_hw_suspend(1);\r\nelse {\r\ntx = MAX3100_WC | MAX3100_SHDN;\r\nmax3100_sr(max3100s[i], tx, &rx);\r\n}\r\nmutex_unlock(&max3100s_lock);\r\nreturn 0;\r\n}\r\nstatic int max3100_remove(struct spi_device *spi)\r\n{\r\nstruct max3100_port *s = spi_get_drvdata(spi);\r\nint i;\r\nmutex_lock(&max3100s_lock);\r\nfor (i = 0; i < MAX_MAX3100; i++)\r\nif (max3100s[i] == s) {\r\ndev_dbg(&spi->dev, "%s: removing port %d\n", __func__, i);\r\nuart_remove_one_port(&max3100_uart_driver, &max3100s[i]->port);\r\nkfree(max3100s[i]);\r\nmax3100s[i] = NULL;\r\nbreak;\r\n}\r\nWARN_ON(i == MAX_MAX3100);\r\nfor (i = 0; i < MAX_MAX3100; i++)\r\nif (max3100s[i]) {\r\nmutex_unlock(&max3100s_lock);\r\nreturn 0;\r\n}\r\npr_debug("removing max3100 driver\n");\r\nuart_unregister_driver(&max3100_uart_driver);\r\nmutex_unlock(&max3100s_lock);\r\nreturn 0;\r\n}\r\nstatic int max3100_suspend(struct device *dev)\r\n{\r\nstruct max3100_port *s = dev_get_drvdata(dev);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\ndisable_irq(s->irq);\r\ns->suspending = 1;\r\nuart_suspend_port(&max3100_uart_driver, &s->port);\r\nif (s->max3100_hw_suspend)\r\ns->max3100_hw_suspend(1);\r\nelse {\r\nu16 tx, rx;\r\ntx = MAX3100_WC | MAX3100_SHDN;\r\nmax3100_sr(s, tx, &rx);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max3100_resume(struct device *dev)\r\n{\r\nstruct max3100_port *s = dev_get_drvdata(dev);\r\ndev_dbg(&s->spi->dev, "%s\n", __func__);\r\nif (s->max3100_hw_suspend)\r\ns->max3100_hw_suspend(0);\r\nuart_resume_port(&max3100_uart_driver, &s->port);\r\ns->suspending = 0;\r\nenable_irq(s->irq);\r\ns->conf_commit = 1;\r\nif (s->workqueue)\r\nmax3100_dowork(s);\r\nreturn 0;\r\n}
