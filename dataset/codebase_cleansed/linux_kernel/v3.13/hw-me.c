static inline u32 mei_me_reg_read(const struct mei_me_hw *hw,\r\nunsigned long offset)\r\n{\r\nreturn ioread32(hw->mem_addr + offset);\r\n}\r\nstatic inline void mei_me_reg_write(const struct mei_me_hw *hw,\r\nunsigned long offset, u32 value)\r\n{\r\niowrite32(value, hw->mem_addr + offset);\r\n}\r\nstatic u32 mei_me_mecbrw_read(const struct mei_device *dev)\r\n{\r\nreturn mei_me_reg_read(to_me_hw(dev), ME_CB_RW);\r\n}\r\nstatic inline u32 mei_me_mecsr_read(const struct mei_me_hw *hw)\r\n{\r\nreturn mei_me_reg_read(hw, ME_CSR_HA);\r\n}\r\nstatic inline u32 mei_hcsr_read(const struct mei_me_hw *hw)\r\n{\r\nreturn mei_me_reg_read(hw, H_CSR);\r\n}\r\nstatic inline void mei_hcsr_set(struct mei_me_hw *hw, u32 hcsr)\r\n{\r\nhcsr &= ~H_IS;\r\nmei_me_reg_write(hw, H_CSR, hcsr);\r\n}\r\nstatic void mei_me_hw_config(struct mei_device *dev)\r\n{\r\nu32 hcsr = mei_hcsr_read(to_me_hw(dev));\r\ndev->hbuf_depth = (hcsr & H_CBD) >> 24;\r\n}\r\nstatic void mei_me_intr_clear(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr = mei_hcsr_read(hw);\r\nif ((hcsr & H_IS) == H_IS)\r\nmei_me_reg_write(hw, H_CSR, hcsr);\r\n}\r\nstatic void mei_me_intr_enable(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr = mei_hcsr_read(hw);\r\nhcsr |= H_IE;\r\nmei_hcsr_set(hw, hcsr);\r\n}\r\nstatic void mei_me_intr_disable(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr = mei_hcsr_read(hw);\r\nhcsr &= ~H_IE;\r\nmei_hcsr_set(hw, hcsr);\r\n}\r\nstatic void mei_me_hw_reset_release(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr = mei_hcsr_read(hw);\r\nhcsr |= H_IG;\r\nhcsr &= ~H_RST;\r\nmei_hcsr_set(hw, hcsr);\r\n}\r\nstatic int mei_me_hw_reset(struct mei_device *dev, bool intr_enable)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 hcsr = mei_hcsr_read(hw);\r\nhcsr |= H_RST | H_IG | H_IS;\r\nif (intr_enable)\r\nhcsr |= H_IE;\r\nelse\r\nhcsr &= ~H_IE;\r\nmei_me_reg_write(hw, H_CSR, hcsr);\r\nif (dev->dev_state == MEI_DEV_POWER_DOWN)\r\nmei_me_hw_reset_release(dev);\r\nreturn 0;\r\n}\r\nstatic void mei_me_host_set_ready(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nhw->host_hw_state |= H_IE | H_IG | H_RDY;\r\nmei_hcsr_set(hw, hw->host_hw_state);\r\n}\r\nstatic bool mei_me_host_is_ready(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nhw->host_hw_state = mei_hcsr_read(hw);\r\nreturn (hw->host_hw_state & H_RDY) == H_RDY;\r\n}\r\nstatic bool mei_me_hw_is_ready(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nhw->me_hw_state = mei_me_mecsr_read(hw);\r\nreturn (hw->me_hw_state & ME_RDY_HRA) == ME_RDY_HRA;\r\n}\r\nstatic int mei_me_hw_ready_wait(struct mei_device *dev)\r\n{\r\nint err;\r\nif (mei_me_hw_is_ready(dev))\r\nreturn 0;\r\ndev->recvd_hw_ready = false;\r\nmutex_unlock(&dev->device_lock);\r\nerr = wait_event_interruptible_timeout(dev->wait_hw_ready,\r\ndev->recvd_hw_ready,\r\nmei_secs_to_jiffies(MEI_INTEROP_TIMEOUT));\r\nmutex_lock(&dev->device_lock);\r\nif (!err && !dev->recvd_hw_ready) {\r\nif (!err)\r\nerr = -ETIMEDOUT;\r\ndev_err(&dev->pdev->dev,\r\n"wait hw ready failed. status = %d\n", err);\r\nreturn err;\r\n}\r\ndev->recvd_hw_ready = false;\r\nreturn 0;\r\n}\r\nstatic int mei_me_hw_start(struct mei_device *dev)\r\n{\r\nint ret = mei_me_hw_ready_wait(dev);\r\nif (ret)\r\nreturn ret;\r\ndev_dbg(&dev->pdev->dev, "hw is ready\n");\r\nmei_me_host_set_ready(dev);\r\nreturn ret;\r\n}\r\nstatic unsigned char mei_hbuf_filled_slots(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nchar read_ptr, write_ptr;\r\nhw->host_hw_state = mei_hcsr_read(hw);\r\nread_ptr = (char) ((hw->host_hw_state & H_CBRP) >> 8);\r\nwrite_ptr = (char) ((hw->host_hw_state & H_CBWP) >> 16);\r\nreturn (unsigned char) (write_ptr - read_ptr);\r\n}\r\nstatic bool mei_me_hbuf_is_empty(struct mei_device *dev)\r\n{\r\nreturn mei_hbuf_filled_slots(dev) == 0;\r\n}\r\nstatic int mei_me_hbuf_empty_slots(struct mei_device *dev)\r\n{\r\nunsigned char filled_slots, empty_slots;\r\nfilled_slots = mei_hbuf_filled_slots(dev);\r\nempty_slots = dev->hbuf_depth - filled_slots;\r\nif (filled_slots > dev->hbuf_depth)\r\nreturn -EOVERFLOW;\r\nreturn empty_slots;\r\n}\r\nstatic size_t mei_me_hbuf_max_len(const struct mei_device *dev)\r\n{\r\nreturn dev->hbuf_depth * sizeof(u32) - sizeof(struct mei_msg_hdr);\r\n}\r\nstatic int mei_me_write_message(struct mei_device *dev,\r\nstruct mei_msg_hdr *header,\r\nunsigned char *buf)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nunsigned long rem;\r\nunsigned long length = header->length;\r\nu32 *reg_buf = (u32 *)buf;\r\nu32 hcsr;\r\nu32 dw_cnt;\r\nint i;\r\nint empty_slots;\r\ndev_dbg(&dev->pdev->dev, MEI_HDR_FMT, MEI_HDR_PRM(header));\r\nempty_slots = mei_hbuf_empty_slots(dev);\r\ndev_dbg(&dev->pdev->dev, "empty slots = %hu.\n", empty_slots);\r\ndw_cnt = mei_data2slots(length);\r\nif (empty_slots < 0 || dw_cnt > empty_slots)\r\nreturn -EIO;\r\nmei_me_reg_write(hw, H_CB_WW, *((u32 *) header));\r\nfor (i = 0; i < length / 4; i++)\r\nmei_me_reg_write(hw, H_CB_WW, reg_buf[i]);\r\nrem = length & 0x3;\r\nif (rem > 0) {\r\nu32 reg = 0;\r\nmemcpy(&reg, &buf[length - rem], rem);\r\nmei_me_reg_write(hw, H_CB_WW, reg);\r\n}\r\nhcsr = mei_hcsr_read(hw) | H_IG;\r\nmei_hcsr_set(hw, hcsr);\r\nif (!mei_me_hw_is_ready(dev))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mei_me_count_full_read_slots(struct mei_device *dev)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nchar read_ptr, write_ptr;\r\nunsigned char buffer_depth, filled_slots;\r\nhw->me_hw_state = mei_me_mecsr_read(hw);\r\nbuffer_depth = (unsigned char)((hw->me_hw_state & ME_CBD_HRA) >> 24);\r\nread_ptr = (char) ((hw->me_hw_state & ME_CBRP_HRA) >> 8);\r\nwrite_ptr = (char) ((hw->me_hw_state & ME_CBWP_HRA) >> 16);\r\nfilled_slots = (unsigned char) (write_ptr - read_ptr);\r\nif (filled_slots > buffer_depth)\r\nreturn -EOVERFLOW;\r\ndev_dbg(&dev->pdev->dev, "filled_slots =%08x\n", filled_slots);\r\nreturn (int)filled_slots;\r\n}\r\nstatic int mei_me_read_slots(struct mei_device *dev, unsigned char *buffer,\r\nunsigned long buffer_length)\r\n{\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 *reg_buf = (u32 *)buffer;\r\nu32 hcsr;\r\nfor (; buffer_length >= sizeof(u32); buffer_length -= sizeof(u32))\r\n*reg_buf++ = mei_me_mecbrw_read(dev);\r\nif (buffer_length > 0) {\r\nu32 reg = mei_me_mecbrw_read(dev);\r\nmemcpy(reg_buf, &reg, buffer_length);\r\n}\r\nhcsr = mei_hcsr_read(hw) | H_IG;\r\nmei_hcsr_set(hw, hcsr);\r\nreturn 0;\r\n}\r\nirqreturn_t mei_me_irq_quick_handler(int irq, void *dev_id)\r\n{\r\nstruct mei_device *dev = (struct mei_device *) dev_id;\r\nstruct mei_me_hw *hw = to_me_hw(dev);\r\nu32 csr_reg = mei_hcsr_read(hw);\r\nif ((csr_reg & H_IS) != H_IS)\r\nreturn IRQ_NONE;\r\nmei_me_reg_write(hw, H_CSR, csr_reg);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nirqreturn_t mei_me_irq_thread_handler(int irq, void *dev_id)\r\n{\r\nstruct mei_device *dev = (struct mei_device *) dev_id;\r\nstruct mei_cl_cb complete_list;\r\ns32 slots;\r\nint rets;\r\ndev_dbg(&dev->pdev->dev, "function called after ISR to handle the interrupt processing.\n");\r\nmutex_lock(&dev->device_lock);\r\nmei_io_list_init(&complete_list);\r\nif (pci_dev_msi_enabled(dev->pdev))\r\nmei_clear_interrupts(dev);\r\nif (!mei_hw_is_ready(dev) &&\r\ndev->dev_state != MEI_DEV_RESETTING &&\r\ndev->dev_state != MEI_DEV_INITIALIZING &&\r\ndev->dev_state != MEI_DEV_POWER_DOWN &&\r\ndev->dev_state != MEI_DEV_POWER_UP) {\r\ndev_dbg(&dev->pdev->dev, "FW not ready.\n");\r\nmei_reset(dev, 1);\r\nmutex_unlock(&dev->device_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!mei_host_is_ready(dev)) {\r\nif (mei_hw_is_ready(dev)) {\r\ndev_dbg(&dev->pdev->dev, "we need to start the dev.\n");\r\ndev->recvd_hw_ready = true;\r\nwake_up_interruptible(&dev->wait_hw_ready);\r\nmutex_unlock(&dev->device_lock);\r\nreturn IRQ_HANDLED;\r\n} else {\r\ndev_dbg(&dev->pdev->dev, "Reset Completed.\n");\r\nmei_me_hw_reset_release(dev);\r\nmutex_unlock(&dev->device_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nslots = mei_count_full_read_slots(dev);\r\nwhile (slots > 0) {\r\nif (dev->wr_ext_msg.hdr.length)\r\nbreak;\r\ndev_dbg(&dev->pdev->dev, "slots =%08x\n", slots);\r\ndev_dbg(&dev->pdev->dev, "call mei_irq_read_handler.\n");\r\nrets = mei_irq_read_handler(dev, &complete_list, &slots);\r\nif (rets)\r\ngoto end;\r\n}\r\nrets = mei_irq_write_handler(dev, &complete_list);\r\nend:\r\ndev_dbg(&dev->pdev->dev, "end of bottom half function.\n");\r\ndev->hbuf_is_ready = mei_hbuf_is_ready(dev);\r\nmutex_unlock(&dev->device_lock);\r\nmei_irq_compl_handler(dev, &complete_list);\r\nreturn IRQ_HANDLED;\r\n}\r\nstruct mei_device *mei_me_dev_init(struct pci_dev *pdev)\r\n{\r\nstruct mei_device *dev;\r\ndev = kzalloc(sizeof(struct mei_device) +\r\nsizeof(struct mei_me_hw), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nmei_device_init(dev);\r\ndev->ops = &mei_me_hw_ops;\r\ndev->pdev = pdev;\r\nreturn dev;\r\n}
