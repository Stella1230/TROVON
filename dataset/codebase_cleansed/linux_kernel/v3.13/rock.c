static int check_sp(struct rock_ridge *rr, struct inode *inode)\r\n{\r\nif (rr->u.SP.magic[0] != 0xbe)\r\nreturn -1;\r\nif (rr->u.SP.magic[1] != 0xef)\r\nreturn -1;\r\nISOFS_SB(inode->i_sb)->s_rock_offset = rr->u.SP.skip;\r\nreturn 0;\r\n}\r\nstatic void setup_rock_ridge(struct iso_directory_record *de,\r\nstruct inode *inode, struct rock_state *rs)\r\n{\r\nrs->len = sizeof(struct iso_directory_record) + de->name_len[0];\r\nif (rs->len & 1)\r\n(rs->len)++;\r\nrs->chr = (unsigned char *)de + rs->len;\r\nrs->len = *((unsigned char *)de) - rs->len;\r\nif (rs->len < 0)\r\nrs->len = 0;\r\nif (ISOFS_SB(inode->i_sb)->s_rock_offset != -1) {\r\nrs->len -= ISOFS_SB(inode->i_sb)->s_rock_offset;\r\nrs->chr += ISOFS_SB(inode->i_sb)->s_rock_offset;\r\nif (rs->len < 0)\r\nrs->len = 0;\r\n}\r\n}\r\nstatic void init_rock_state(struct rock_state *rs, struct inode *inode)\r\n{\r\nmemset(rs, 0, sizeof(*rs));\r\nrs->inode = inode;\r\n}\r\nstatic int rock_continue(struct rock_state *rs)\r\n{\r\nint ret = 1;\r\nint blocksize = 1 << rs->inode->i_blkbits;\r\nconst int min_de_size = offsetof(struct rock_ridge, u);\r\nkfree(rs->buffer);\r\nrs->buffer = NULL;\r\nif ((unsigned)rs->cont_offset > blocksize - min_de_size ||\r\n(unsigned)rs->cont_size > blocksize ||\r\n(unsigned)(rs->cont_offset + rs->cont_size) > blocksize) {\r\nprintk(KERN_NOTICE "rock: corrupted directory entry. "\r\n"extent=%d, offset=%d, size=%d\n",\r\nrs->cont_extent, rs->cont_offset, rs->cont_size);\r\nret = -EIO;\r\ngoto out;\r\n}\r\nif (rs->cont_extent) {\r\nstruct buffer_head *bh;\r\nrs->buffer = kmalloc(rs->cont_size, GFP_KERNEL);\r\nif (!rs->buffer) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = -EIO;\r\nbh = sb_bread(rs->inode->i_sb, rs->cont_extent);\r\nif (bh) {\r\nmemcpy(rs->buffer, bh->b_data + rs->cont_offset,\r\nrs->cont_size);\r\nput_bh(bh);\r\nrs->chr = rs->buffer;\r\nrs->len = rs->cont_size;\r\nrs->cont_extent = 0;\r\nrs->cont_size = 0;\r\nrs->cont_offset = 0;\r\nreturn 0;\r\n}\r\nprintk("Unable to read rock-ridge attributes\n");\r\n}\r\nout:\r\nkfree(rs->buffer);\r\nrs->buffer = NULL;\r\nreturn ret;\r\n}\r\nstatic int rock_check_overflow(struct rock_state *rs, int sig)\r\n{\r\nint len;\r\nswitch (sig) {\r\ncase SIG('S', 'P'):\r\nlen = sizeof(struct SU_SP_s);\r\nbreak;\r\ncase SIG('C', 'E'):\r\nlen = sizeof(struct SU_CE_s);\r\nbreak;\r\ncase SIG('E', 'R'):\r\nlen = sizeof(struct SU_ER_s);\r\nbreak;\r\ncase SIG('R', 'R'):\r\nlen = sizeof(struct RR_RR_s);\r\nbreak;\r\ncase SIG('P', 'X'):\r\nlen = sizeof(struct RR_PX_s);\r\nbreak;\r\ncase SIG('P', 'N'):\r\nlen = sizeof(struct RR_PN_s);\r\nbreak;\r\ncase SIG('S', 'L'):\r\nlen = sizeof(struct RR_SL_s);\r\nbreak;\r\ncase SIG('N', 'M'):\r\nlen = sizeof(struct RR_NM_s);\r\nbreak;\r\ncase SIG('C', 'L'):\r\nlen = sizeof(struct RR_CL_s);\r\nbreak;\r\ncase SIG('P', 'L'):\r\nlen = sizeof(struct RR_PL_s);\r\nbreak;\r\ncase SIG('T', 'F'):\r\nlen = sizeof(struct RR_TF_s);\r\nbreak;\r\ncase SIG('Z', 'F'):\r\nlen = sizeof(struct RR_ZF_s);\r\nbreak;\r\ndefault:\r\nlen = 0;\r\nbreak;\r\n}\r\nlen += offsetof(struct rock_ridge, u);\r\nif (len > rs->len) {\r\nprintk(KERN_NOTICE "rock: directory entry would overflow "\r\n"storage\n");\r\nprintk(KERN_NOTICE "rock: sig=0x%02x, size=%d, remaining=%d\n",\r\nsig, len, rs->len);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint get_rock_ridge_filename(struct iso_directory_record *de,\r\nchar *retname, struct inode *inode)\r\n{\r\nstruct rock_state rs;\r\nstruct rock_ridge *rr;\r\nint sig;\r\nint retnamlen = 0;\r\nint truncate = 0;\r\nint ret = 0;\r\nif (!ISOFS_SB(inode->i_sb)->s_rock)\r\nreturn 0;\r\n*retname = 0;\r\ninit_rock_state(&rs, inode);\r\nsetup_rock_ridge(de, inode, &rs);\r\nrepeat:\r\nwhile (rs.len > 2) {\r\nrr = (struct rock_ridge *)rs.chr;\r\nif (rr->len < 3)\r\ngoto out;\r\nsig = isonum_721(rs.chr);\r\nif (rock_check_overflow(&rs, sig))\r\ngoto eio;\r\nrs.chr += rr->len;\r\nrs.len -= rr->len;\r\nif (rs.len < 0)\r\ngoto out;\r\nswitch (sig) {\r\ncase SIG('R', 'R'):\r\nif ((rr->u.RR.flags[0] & RR_NM) == 0)\r\ngoto out;\r\nbreak;\r\ncase SIG('S', 'P'):\r\nif (check_sp(rr, inode))\r\ngoto out;\r\nbreak;\r\ncase SIG('C', 'E'):\r\nrs.cont_extent = isonum_733(rr->u.CE.extent);\r\nrs.cont_offset = isonum_733(rr->u.CE.offset);\r\nrs.cont_size = isonum_733(rr->u.CE.size);\r\nbreak;\r\ncase SIG('N', 'M'):\r\nif (truncate)\r\nbreak;\r\nif (rr->len < 5)\r\nbreak;\r\nif (rr->u.NM.flags & 6)\r\nbreak;\r\nif (rr->u.NM.flags & ~1) {\r\nprintk("Unsupported NM flag settings (%d)\n",\r\nrr->u.NM.flags);\r\nbreak;\r\n}\r\nif ((strlen(retname) + rr->len - 5) >= 254) {\r\ntruncate = 1;\r\nbreak;\r\n}\r\nstrncat(retname, rr->u.NM.name, rr->len - 5);\r\nretnamlen += rr->len - 5;\r\nbreak;\r\ncase SIG('R', 'E'):\r\nkfree(rs.buffer);\r\nreturn -1;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nret = rock_continue(&rs);\r\nif (ret == 0)\r\ngoto repeat;\r\nif (ret == 1)\r\nreturn retnamlen;\r\nout:\r\nkfree(rs.buffer);\r\nreturn ret;\r\neio:\r\nret = -EIO;\r\ngoto out;\r\n}\r\nstatic int\r\nparse_rock_ridge_inode_internal(struct iso_directory_record *de,\r\nstruct inode *inode, int regard_xa)\r\n{\r\nint symlink_len = 0;\r\nint cnt, sig;\r\nstruct inode *reloc;\r\nstruct rock_ridge *rr;\r\nint rootflag;\r\nstruct rock_state rs;\r\nint ret = 0;\r\nif (!ISOFS_SB(inode->i_sb)->s_rock)\r\nreturn 0;\r\ninit_rock_state(&rs, inode);\r\nsetup_rock_ridge(de, inode, &rs);\r\nif (regard_xa) {\r\nrs.chr += 14;\r\nrs.len -= 14;\r\nif (rs.len < 0)\r\nrs.len = 0;\r\n}\r\nrepeat:\r\nwhile (rs.len > 2) {\r\nrr = (struct rock_ridge *)rs.chr;\r\nif (rr->len < 3)\r\ngoto out;\r\nsig = isonum_721(rs.chr);\r\nif (rock_check_overflow(&rs, sig))\r\ngoto eio;\r\nrs.chr += rr->len;\r\nrs.len -= rr->len;\r\nif (rs.len < 0)\r\ngoto out;\r\nswitch (sig) {\r\n#ifndef CONFIG_ZISOFS\r\ncase SIG('R', 'R'):\r\nif ((rr->u.RR.flags[0] &\r\n(RR_PX | RR_TF | RR_SL | RR_CL)) == 0)\r\ngoto out;\r\nbreak;\r\n#endif\r\ncase SIG('S', 'P'):\r\nif (check_sp(rr, inode))\r\ngoto out;\r\nbreak;\r\ncase SIG('C', 'E'):\r\nrs.cont_extent = isonum_733(rr->u.CE.extent);\r\nrs.cont_offset = isonum_733(rr->u.CE.offset);\r\nrs.cont_size = isonum_733(rr->u.CE.size);\r\nbreak;\r\ncase SIG('E', 'R'):\r\nISOFS_SB(inode->i_sb)->s_rock = 1;\r\nprintk(KERN_DEBUG "ISO 9660 Extensions: ");\r\n{\r\nint p;\r\nfor (p = 0; p < rr->u.ER.len_id; p++)\r\nprintk("%c", rr->u.ER.data[p]);\r\n}\r\nprintk("\n");\r\nbreak;\r\ncase SIG('P', 'X'):\r\ninode->i_mode = isonum_733(rr->u.PX.mode);\r\nset_nlink(inode, isonum_733(rr->u.PX.n_links));\r\ni_uid_write(inode, isonum_733(rr->u.PX.uid));\r\ni_gid_write(inode, isonum_733(rr->u.PX.gid));\r\nbreak;\r\ncase SIG('P', 'N'):\r\n{\r\nint high, low;\r\nhigh = isonum_733(rr->u.PN.dev_high);\r\nlow = isonum_733(rr->u.PN.dev_low);\r\nif ((low & ~0xff) && high == 0) {\r\ninode->i_rdev =\r\nMKDEV(low >> 8, low & 0xff);\r\n} else {\r\ninode->i_rdev =\r\nMKDEV(high, low);\r\n}\r\n}\r\nbreak;\r\ncase SIG('T', 'F'):\r\ncnt = 0;\r\nif (rr->u.TF.flags & TF_CREATE) {\r\ninode->i_ctime.tv_sec =\r\niso_date(rr->u.TF.times[cnt++].time,\r\n0);\r\ninode->i_ctime.tv_nsec = 0;\r\n}\r\nif (rr->u.TF.flags & TF_MODIFY) {\r\ninode->i_mtime.tv_sec =\r\niso_date(rr->u.TF.times[cnt++].time,\r\n0);\r\ninode->i_mtime.tv_nsec = 0;\r\n}\r\nif (rr->u.TF.flags & TF_ACCESS) {\r\ninode->i_atime.tv_sec =\r\niso_date(rr->u.TF.times[cnt++].time,\r\n0);\r\ninode->i_atime.tv_nsec = 0;\r\n}\r\nif (rr->u.TF.flags & TF_ATTRIBUTES) {\r\ninode->i_ctime.tv_sec =\r\niso_date(rr->u.TF.times[cnt++].time,\r\n0);\r\ninode->i_ctime.tv_nsec = 0;\r\n}\r\nbreak;\r\ncase SIG('S', 'L'):\r\n{\r\nint slen;\r\nstruct SL_component *slp;\r\nstruct SL_component *oldslp;\r\nslen = rr->len - 5;\r\nslp = &rr->u.SL.link;\r\ninode->i_size = symlink_len;\r\nwhile (slen > 1) {\r\nrootflag = 0;\r\nswitch (slp->flags & ~1) {\r\ncase 0:\r\ninode->i_size +=\r\nslp->len;\r\nbreak;\r\ncase 2:\r\ninode->i_size += 1;\r\nbreak;\r\ncase 4:\r\ninode->i_size += 2;\r\nbreak;\r\ncase 8:\r\nrootflag = 1;\r\ninode->i_size += 1;\r\nbreak;\r\ndefault:\r\nprintk("Symlink component flag "\r\n"not implemented\n");\r\n}\r\nslen -= slp->len + 2;\r\noldslp = slp;\r\nslp = (struct SL_component *)\r\n(((char *)slp) + slp->len + 2);\r\nif (slen < 2) {\r\nif (((rr->u.SL.\r\nflags & 1) != 0)\r\n&&\r\n((oldslp->\r\nflags & 1) == 0))\r\ninode->i_size +=\r\n1;\r\nbreak;\r\n}\r\nif (!rootflag\r\n&& (oldslp->flags & 1) == 0)\r\ninode->i_size += 1;\r\n}\r\n}\r\nsymlink_len = inode->i_size;\r\nbreak;\r\ncase SIG('R', 'E'):\r\nprintk(KERN_WARNING "Attempt to read inode for "\r\n"relocated directory\n");\r\ngoto out;\r\ncase SIG('C', 'L'):\r\nISOFS_I(inode)->i_first_extent =\r\nisonum_733(rr->u.CL.location);\r\nreloc =\r\nisofs_iget(inode->i_sb,\r\nISOFS_I(inode)->i_first_extent,\r\n0);\r\nif (IS_ERR(reloc)) {\r\nret = PTR_ERR(reloc);\r\ngoto out;\r\n}\r\ninode->i_mode = reloc->i_mode;\r\nset_nlink(inode, reloc->i_nlink);\r\ninode->i_uid = reloc->i_uid;\r\ninode->i_gid = reloc->i_gid;\r\ninode->i_rdev = reloc->i_rdev;\r\ninode->i_size = reloc->i_size;\r\ninode->i_blocks = reloc->i_blocks;\r\ninode->i_atime = reloc->i_atime;\r\ninode->i_ctime = reloc->i_ctime;\r\ninode->i_mtime = reloc->i_mtime;\r\niput(reloc);\r\nbreak;\r\n#ifdef CONFIG_ZISOFS\r\ncase SIG('Z', 'F'): {\r\nint algo;\r\nif (ISOFS_SB(inode->i_sb)->s_nocompress)\r\nbreak;\r\nalgo = isonum_721(rr->u.ZF.algorithm);\r\nif (algo == SIG('p', 'z')) {\r\nint block_shift =\r\nisonum_711(&rr->u.ZF.parms[1]);\r\nif (block_shift > 17) {\r\nprintk(KERN_WARNING "isofs: "\r\n"Can't handle ZF block "\r\n"size of 2^%d\n",\r\nblock_shift);\r\n} else {\r\nISOFS_I(inode)->i_file_format =\r\nisofs_file_compressed;\r\nISOFS_I(inode)->i_format_parm[0] =\r\nisonum_711(&rr->u.ZF.parms[0]);\r\nISOFS_I(inode)->i_format_parm[1] =\r\nisonum_711(&rr->u.ZF.parms[1]);\r\ninode->i_size =\r\nisonum_733(rr->u.ZF.\r\nreal_size);\r\n}\r\n} else {\r\nprintk(KERN_WARNING\r\n"isofs: Unknown ZF compression "\r\n"algorithm: %c%c\n",\r\nrr->u.ZF.algorithm[0],\r\nrr->u.ZF.algorithm[1]);\r\n}\r\nbreak;\r\n}\r\n#endif\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nret = rock_continue(&rs);\r\nif (ret == 0)\r\ngoto repeat;\r\nif (ret == 1)\r\nret = 0;\r\nout:\r\nkfree(rs.buffer);\r\nreturn ret;\r\neio:\r\nret = -EIO;\r\ngoto out;\r\n}\r\nstatic char *get_symlink_chunk(char *rpnt, struct rock_ridge *rr, char *plimit)\r\n{\r\nint slen;\r\nint rootflag;\r\nstruct SL_component *oldslp;\r\nstruct SL_component *slp;\r\nslen = rr->len - 5;\r\nslp = &rr->u.SL.link;\r\nwhile (slen > 1) {\r\nrootflag = 0;\r\nswitch (slp->flags & ~1) {\r\ncase 0:\r\nif (slp->len > plimit - rpnt)\r\nreturn NULL;\r\nmemcpy(rpnt, slp->text, slp->len);\r\nrpnt += slp->len;\r\nbreak;\r\ncase 2:\r\nif (rpnt >= plimit)\r\nreturn NULL;\r\n*rpnt++ = '.';\r\nbreak;\r\ncase 4:\r\nif (2 > plimit - rpnt)\r\nreturn NULL;\r\n*rpnt++ = '.';\r\n*rpnt++ = '.';\r\nbreak;\r\ncase 8:\r\nif (rpnt >= plimit)\r\nreturn NULL;\r\nrootflag = 1;\r\n*rpnt++ = '/';\r\nbreak;\r\ndefault:\r\nprintk("Symlink component flag not implemented (%d)\n",\r\nslp->flags);\r\n}\r\nslen -= slp->len + 2;\r\noldslp = slp;\r\nslp = (struct SL_component *)((char *)slp + slp->len + 2);\r\nif (slen < 2) {\r\nif ((!rootflag) && (rr->u.SL.flags & 1) &&\r\n!(oldslp->flags & 1)) {\r\nif (rpnt >= plimit)\r\nreturn NULL;\r\n*rpnt++ = '/';\r\n}\r\nbreak;\r\n}\r\nif (!rootflag && !(oldslp->flags & 1)) {\r\nif (rpnt >= plimit)\r\nreturn NULL;\r\n*rpnt++ = '/';\r\n}\r\n}\r\nreturn rpnt;\r\n}\r\nint parse_rock_ridge_inode(struct iso_directory_record *de, struct inode *inode)\r\n{\r\nint result = parse_rock_ridge_inode_internal(de, inode, 0);\r\nif ((ISOFS_SB(inode->i_sb)->s_rock_offset == -1)\r\n&& (ISOFS_SB(inode->i_sb)->s_rock == 2)) {\r\nresult = parse_rock_ridge_inode_internal(de, inode, 14);\r\n}\r\nreturn result;\r\n}\r\nstatic int rock_ridge_symlink_readpage(struct file *file, struct page *page)\r\n{\r\nstruct inode *inode = page->mapping->host;\r\nstruct iso_inode_info *ei = ISOFS_I(inode);\r\nstruct isofs_sb_info *sbi = ISOFS_SB(inode->i_sb);\r\nchar *link = kmap(page);\r\nunsigned long bufsize = ISOFS_BUFFER_SIZE(inode);\r\nstruct buffer_head *bh;\r\nchar *rpnt = link;\r\nunsigned char *pnt;\r\nstruct iso_directory_record *raw_de;\r\nunsigned long block, offset;\r\nint sig;\r\nstruct rock_ridge *rr;\r\nstruct rock_state rs;\r\nint ret;\r\nif (!sbi->s_rock)\r\ngoto error;\r\ninit_rock_state(&rs, inode);\r\nblock = ei->i_iget5_block;\r\nbh = sb_bread(inode->i_sb, block);\r\nif (!bh)\r\ngoto out_noread;\r\noffset = ei->i_iget5_offset;\r\npnt = (unsigned char *)bh->b_data + offset;\r\nraw_de = (struct iso_directory_record *)pnt;\r\nif (offset + *pnt > bufsize)\r\ngoto out_bad_span;\r\nsetup_rock_ridge(raw_de, inode, &rs);\r\nrepeat:\r\nwhile (rs.len > 2) {\r\nrr = (struct rock_ridge *)rs.chr;\r\nif (rr->len < 3)\r\ngoto out;\r\nsig = isonum_721(rs.chr);\r\nif (rock_check_overflow(&rs, sig))\r\ngoto out;\r\nrs.chr += rr->len;\r\nrs.len -= rr->len;\r\nif (rs.len < 0)\r\ngoto out;\r\nswitch (sig) {\r\ncase SIG('R', 'R'):\r\nif ((rr->u.RR.flags[0] & RR_SL) == 0)\r\ngoto out;\r\nbreak;\r\ncase SIG('S', 'P'):\r\nif (check_sp(rr, inode))\r\ngoto out;\r\nbreak;\r\ncase SIG('S', 'L'):\r\nrpnt = get_symlink_chunk(rpnt, rr,\r\nlink + (PAGE_SIZE - 1));\r\nif (rpnt == NULL)\r\ngoto out;\r\nbreak;\r\ncase SIG('C', 'E'):\r\nrs.cont_extent = isonum_733(rr->u.CE.extent);\r\nrs.cont_offset = isonum_733(rr->u.CE.offset);\r\nrs.cont_size = isonum_733(rr->u.CE.size);\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nret = rock_continue(&rs);\r\nif (ret == 0)\r\ngoto repeat;\r\nif (ret < 0)\r\ngoto fail;\r\nif (rpnt == link)\r\ngoto fail;\r\nbrelse(bh);\r\n*rpnt = '\0';\r\nSetPageUptodate(page);\r\nkunmap(page);\r\nunlock_page(page);\r\nreturn 0;\r\nout:\r\nkfree(rs.buffer);\r\ngoto fail;\r\nout_noread:\r\nprintk("unable to read i-node block");\r\ngoto fail;\r\nout_bad_span:\r\nprintk("symlink spans iso9660 blocks\n");\r\nfail:\r\nbrelse(bh);\r\nerror:\r\nSetPageError(page);\r\nkunmap(page);\r\nunlock_page(page);\r\nreturn -EIO;\r\n}
