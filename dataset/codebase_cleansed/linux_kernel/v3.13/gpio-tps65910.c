static inline struct tps65910_gpio *to_tps65910_gpio(struct gpio_chip *chip)\r\n{\r\nreturn container_of(chip, struct tps65910_gpio, gpio_chip);\r\n}\r\nstatic int tps65910_gpio_get(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct tps65910_gpio *tps65910_gpio = to_tps65910_gpio(gc);\r\nstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\r\nunsigned int val;\r\ntps65910_reg_read(tps65910, TPS65910_GPIO0 + offset, &val);\r\nif (val & GPIO_STS_MASK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void tps65910_gpio_set(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct tps65910_gpio *tps65910_gpio = to_tps65910_gpio(gc);\r\nstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\r\nif (value)\r\ntps65910_reg_set_bits(tps65910, TPS65910_GPIO0 + offset,\r\nGPIO_SET_MASK);\r\nelse\r\ntps65910_reg_clear_bits(tps65910, TPS65910_GPIO0 + offset,\r\nGPIO_SET_MASK);\r\n}\r\nstatic int tps65910_gpio_output(struct gpio_chip *gc, unsigned offset,\r\nint value)\r\n{\r\nstruct tps65910_gpio *tps65910_gpio = to_tps65910_gpio(gc);\r\nstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\r\ntps65910_gpio_set(gc, offset, value);\r\nreturn tps65910_reg_set_bits(tps65910, TPS65910_GPIO0 + offset,\r\nGPIO_CFG_MASK);\r\n}\r\nstatic int tps65910_gpio_input(struct gpio_chip *gc, unsigned offset)\r\n{\r\nstruct tps65910_gpio *tps65910_gpio = to_tps65910_gpio(gc);\r\nstruct tps65910 *tps65910 = tps65910_gpio->tps65910;\r\nreturn tps65910_reg_clear_bits(tps65910, TPS65910_GPIO0 + offset,\r\nGPIO_CFG_MASK);\r\n}\r\nstatic struct tps65910_board *tps65910_parse_dt_for_gpio(struct device *dev,\r\nstruct tps65910 *tps65910, int chip_ngpio)\r\n{\r\nstruct tps65910_board *tps65910_board = tps65910->of_plat_data;\r\nunsigned int prop_array[TPS6591X_MAX_NUM_GPIO];\r\nint ngpio = min(chip_ngpio, TPS6591X_MAX_NUM_GPIO);\r\nint ret;\r\nint idx;\r\ntps65910_board->gpio_base = -1;\r\nret = of_property_read_u32_array(tps65910->dev->of_node,\r\n"ti,en-gpio-sleep", prop_array, ngpio);\r\nif (ret < 0) {\r\ndev_dbg(dev, "ti,en-gpio-sleep not specified\n");\r\nreturn tps65910_board;\r\n}\r\nfor (idx = 0; idx < ngpio; idx++)\r\ntps65910_board->en_gpio_sleep[idx] = (prop_array[idx] != 0);\r\nreturn tps65910_board;\r\n}\r\nstatic struct tps65910_board *tps65910_parse_dt_for_gpio(struct device *dev,\r\nstruct tps65910 *tps65910, int chip_ngpio)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int tps65910_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct tps65910 *tps65910 = dev_get_drvdata(pdev->dev.parent);\r\nstruct tps65910_board *pdata = dev_get_platdata(tps65910->dev);\r\nstruct tps65910_gpio *tps65910_gpio;\r\nint ret;\r\nint i;\r\ntps65910_gpio = devm_kzalloc(&pdev->dev,\r\nsizeof(*tps65910_gpio), GFP_KERNEL);\r\nif (!tps65910_gpio) {\r\ndev_err(&pdev->dev, "Could not allocate tps65910_gpio\n");\r\nreturn -ENOMEM;\r\n}\r\ntps65910_gpio->tps65910 = tps65910;\r\ntps65910_gpio->gpio_chip.owner = THIS_MODULE;\r\ntps65910_gpio->gpio_chip.label = tps65910->i2c_client->name;\r\nswitch (tps65910_chip_id(tps65910)) {\r\ncase TPS65910:\r\ntps65910_gpio->gpio_chip.ngpio = TPS65910_NUM_GPIO;\r\nbreak;\r\ncase TPS65911:\r\ntps65910_gpio->gpio_chip.ngpio = TPS65911_NUM_GPIO;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ntps65910_gpio->gpio_chip.can_sleep = 1;\r\ntps65910_gpio->gpio_chip.direction_input = tps65910_gpio_input;\r\ntps65910_gpio->gpio_chip.direction_output = tps65910_gpio_output;\r\ntps65910_gpio->gpio_chip.set = tps65910_gpio_set;\r\ntps65910_gpio->gpio_chip.get = tps65910_gpio_get;\r\ntps65910_gpio->gpio_chip.dev = &pdev->dev;\r\n#ifdef CONFIG_OF_GPIO\r\ntps65910_gpio->gpio_chip.of_node = tps65910->dev->of_node;\r\n#endif\r\nif (pdata && pdata->gpio_base)\r\ntps65910_gpio->gpio_chip.base = pdata->gpio_base;\r\nelse\r\ntps65910_gpio->gpio_chip.base = -1;\r\nif (!pdata && tps65910->dev->of_node)\r\npdata = tps65910_parse_dt_for_gpio(&pdev->dev, tps65910,\r\ntps65910_gpio->gpio_chip.ngpio);\r\nif (!pdata)\r\ngoto skip_init;\r\nfor (i = 0; i < tps65910_gpio->gpio_chip.ngpio; ++i) {\r\nif (!pdata->en_gpio_sleep[i])\r\ncontinue;\r\nret = tps65910_reg_set_bits(tps65910,\r\nTPS65910_GPIO0 + i, GPIO_SLEEP_MASK);\r\nif (ret < 0)\r\ndev_warn(tps65910->dev,\r\n"GPIO Sleep setting failed with err %d\n", ret);\r\n}\r\nskip_init:\r\nret = gpiochip_add(&tps65910_gpio->gpio_chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Could not register gpiochip, %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, tps65910_gpio);\r\nreturn ret;\r\n}\r\nstatic int tps65910_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct tps65910_gpio *tps65910_gpio = platform_get_drvdata(pdev);\r\nreturn gpiochip_remove(&tps65910_gpio->gpio_chip);\r\n}\r\nstatic int __init tps65910_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&tps65910_gpio_driver);\r\n}\r\nstatic void __exit tps65910_gpio_exit(void)\r\n{\r\nplatform_driver_unregister(&tps65910_gpio_driver);\r\n}
