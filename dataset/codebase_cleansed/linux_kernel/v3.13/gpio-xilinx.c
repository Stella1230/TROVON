static int xgpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nvoid __iomem *regs = mm_gc->regs + chip->offset;\r\nreturn !!(xgpio_readreg(regs + XGPIO_DATA_OFFSET) & BIT(gpio));\r\n}\r\nstatic void xgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nvoid __iomem *regs = mm_gc->regs;\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\nif (val)\r\nchip->gpio_state |= BIT(gpio);\r\nelse\r\nchip->gpio_state &= ~BIT(gpio);\r\nxgpio_writereg(regs + chip->offset + XGPIO_DATA_OFFSET,\r\nchip->gpio_state);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\n}\r\nstatic int xgpio_dir_in(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nvoid __iomem *regs = mm_gc->regs;\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\nchip->gpio_dir |= BIT(gpio);\r\nxgpio_writereg(regs + chip->offset + XGPIO_TRI_OFFSET, chip->gpio_dir);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int xgpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)\r\n{\r\nunsigned long flags;\r\nstruct of_mm_gpio_chip *mm_gc = to_of_mm_gpio_chip(gc);\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nvoid __iomem *regs = mm_gc->regs;\r\nspin_lock_irqsave(&chip->gpio_lock, flags);\r\nif (val)\r\nchip->gpio_state |= BIT(gpio);\r\nelse\r\nchip->gpio_state &= ~BIT(gpio);\r\nxgpio_writereg(regs + chip->offset + XGPIO_DATA_OFFSET,\r\nchip->gpio_state);\r\nchip->gpio_dir &= ~BIT(gpio);\r\nxgpio_writereg(regs + chip->offset + XGPIO_TRI_OFFSET, chip->gpio_dir);\r\nspin_unlock_irqrestore(&chip->gpio_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void xgpio_save_regs(struct of_mm_gpio_chip *mm_gc)\r\n{\r\nstruct xgpio_instance *chip =\r\ncontainer_of(mm_gc, struct xgpio_instance, mmchip);\r\nxgpio_writereg(mm_gc->regs + chip->offset + XGPIO_DATA_OFFSET,\r\nchip->gpio_state);\r\nxgpio_writereg(mm_gc->regs + chip->offset + XGPIO_TRI_OFFSET,\r\nchip->gpio_dir);\r\n}\r\nstatic int xgpio_of_probe(struct device_node *np)\r\n{\r\nstruct xgpio_instance *chip;\r\nint status = 0;\r\nconst u32 *tree_info;\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nof_property_read_u32(np, "xlnx,dout-default", &chip->gpio_state);\r\nchip->gpio_dir = 0xFFFFFFFF;\r\nof_property_read_u32(np, "xlnx,tri-default", &chip->gpio_dir);\r\nchip->mmchip.gc.ngpio = 32;\r\nof_property_read_u32(np, "xlnx,gpio-width",\r\n(u32 *)&chip->mmchip.gc.ngpio);\r\nspin_lock_init(&chip->gpio_lock);\r\nchip->mmchip.gc.direction_input = xgpio_dir_in;\r\nchip->mmchip.gc.direction_output = xgpio_dir_out;\r\nchip->mmchip.gc.get = xgpio_get;\r\nchip->mmchip.gc.set = xgpio_set;\r\nchip->mmchip.save_regs = xgpio_save_regs;\r\nstatus = of_mm_gpiochip_add(np, &chip->mmchip);\r\nif (status) {\r\nkfree(chip);\r\npr_err("%s: error in probe function with status %d\n",\r\nnp->full_name, status);\r\nreturn status;\r\n}\r\npr_info("XGpio: %s: registered, base is %d\n", np->full_name,\r\nchip->mmchip.gc.base);\r\ntree_info = of_get_property(np, "xlnx,is-dual", NULL);\r\nif (tree_info && be32_to_cpup(tree_info)) {\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->offset = XGPIO_CHANNEL_OFFSET;\r\nof_property_read_u32(np, "xlnx,dout-default-2",\r\n&chip->gpio_state);\r\nchip->gpio_dir = 0xFFFFFFFF;\r\nof_property_read_u32(np, "xlnx,tri-default-2", &chip->gpio_dir);\r\nchip->mmchip.gc.ngpio = 32;\r\nof_property_read_u32(np, "xlnx,gpio2-width",\r\n(u32 *)&chip->mmchip.gc.ngpio);\r\nspin_lock_init(&chip->gpio_lock);\r\nchip->mmchip.gc.direction_input = xgpio_dir_in;\r\nchip->mmchip.gc.direction_output = xgpio_dir_out;\r\nchip->mmchip.gc.get = xgpio_get;\r\nchip->mmchip.gc.set = xgpio_set;\r\nchip->mmchip.save_regs = xgpio_save_regs;\r\nstatus = of_mm_gpiochip_add(np, &chip->mmchip);\r\nif (status) {\r\nkfree(chip);\r\npr_err("%s: error in probe function with status %d\n",\r\nnp->full_name, status);\r\nreturn status;\r\n}\r\npr_info("XGpio: %s: dual channel registered, base is %d\n",\r\nnp->full_name, chip->mmchip.gc.base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init xgpio_init(void)\r\n{\r\nstruct device_node *np;\r\nfor_each_matching_node(np, xgpio_of_match)\r\nxgpio_of_probe(np);\r\nreturn 0;\r\n}
