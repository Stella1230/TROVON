int omap_install_iommu_arch(const struct iommu_functions *ops)\r\n{\r\nif (arch_iommu)\r\nreturn -EBUSY;\r\narch_iommu = ops;\r\nreturn 0;\r\n}\r\nvoid omap_uninstall_iommu_arch(const struct iommu_functions *ops)\r\n{\r\nif (arch_iommu != ops)\r\npr_err("%s: not your arch\n", __func__);\r\narch_iommu = NULL;\r\n}\r\nvoid omap_iommu_save_ctx(struct device *dev)\r\n{\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\narch_iommu->save_ctx(obj);\r\n}\r\nvoid omap_iommu_restore_ctx(struct device *dev)\r\n{\r\nstruct omap_iommu *obj = dev_to_omap_iommu(dev);\r\narch_iommu->restore_ctx(obj);\r\n}\r\nu32 omap_iommu_arch_version(void)\r\n{\r\nreturn arch_iommu->version;\r\n}\r\nstatic int iommu_enable(struct omap_iommu *obj)\r\n{\r\nint err;\r\nstruct platform_device *pdev = to_platform_device(obj->dev);\r\nstruct iommu_platform_data *pdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nif (!arch_iommu)\r\nreturn -ENODEV;\r\nif (pdata->deassert_reset) {\r\nerr = pdata->deassert_reset(pdev, pdata->reset_name);\r\nif (err) {\r\ndev_err(obj->dev, "deassert_reset failed: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\npm_runtime_get_sync(obj->dev);\r\nerr = arch_iommu->enable(obj);\r\nreturn err;\r\n}\r\nstatic void iommu_disable(struct omap_iommu *obj)\r\n{\r\nstruct platform_device *pdev = to_platform_device(obj->dev);\r\nstruct iommu_platform_data *pdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn;\r\narch_iommu->disable(obj);\r\npm_runtime_put_sync(obj->dev);\r\nif (pdata->assert_reset)\r\npdata->assert_reset(pdev, pdata->reset_name);\r\n}\r\nvoid omap_iotlb_cr_to_e(struct cr_regs *cr, struct iotlb_entry *e)\r\n{\r\nBUG_ON(!cr || !e);\r\narch_iommu->cr_to_e(cr, e);\r\n}\r\nstatic inline int iotlb_cr_valid(struct cr_regs *cr)\r\n{\r\nif (!cr)\r\nreturn -EINVAL;\r\nreturn arch_iommu->cr_valid(cr);\r\n}\r\nstatic inline struct cr_regs *iotlb_alloc_cr(struct omap_iommu *obj,\r\nstruct iotlb_entry *e)\r\n{\r\nif (!e)\r\nreturn NULL;\r\nreturn arch_iommu->alloc_cr(obj, e);\r\n}\r\nstatic u32 iotlb_cr_to_virt(struct cr_regs *cr)\r\n{\r\nreturn arch_iommu->cr_to_virt(cr);\r\n}\r\nstatic u32 get_iopte_attr(struct iotlb_entry *e)\r\n{\r\nreturn arch_iommu->get_pte_attr(e);\r\n}\r\nstatic u32 iommu_report_fault(struct omap_iommu *obj, u32 *da)\r\n{\r\nreturn arch_iommu->fault_isr(obj, da);\r\n}\r\nstatic void iotlb_lock_get(struct omap_iommu *obj, struct iotlb_lock *l)\r\n{\r\nu32 val;\r\nval = iommu_read_reg(obj, MMU_LOCK);\r\nl->base = MMU_LOCK_BASE(val);\r\nl->vict = MMU_LOCK_VICT(val);\r\n}\r\nstatic void iotlb_lock_set(struct omap_iommu *obj, struct iotlb_lock *l)\r\n{\r\nu32 val;\r\nval = (l->base << MMU_LOCK_BASE_SHIFT);\r\nval |= (l->vict << MMU_LOCK_VICT_SHIFT);\r\niommu_write_reg(obj, val, MMU_LOCK);\r\n}\r\nstatic void iotlb_read_cr(struct omap_iommu *obj, struct cr_regs *cr)\r\n{\r\narch_iommu->tlb_read_cr(obj, cr);\r\n}\r\nstatic void iotlb_load_cr(struct omap_iommu *obj, struct cr_regs *cr)\r\n{\r\narch_iommu->tlb_load_cr(obj, cr);\r\niommu_write_reg(obj, 1, MMU_FLUSH_ENTRY);\r\niommu_write_reg(obj, 1, MMU_LD_TLB);\r\n}\r\nstatic inline ssize_t iotlb_dump_cr(struct omap_iommu *obj, struct cr_regs *cr,\r\nchar *buf)\r\n{\r\nBUG_ON(!cr || !buf);\r\nreturn arch_iommu->dump_cr(obj, cr, buf);\r\n}\r\nstatic struct cr_regs __iotlb_read_cr(struct omap_iommu *obj, int n)\r\n{\r\nstruct cr_regs cr;\r\nstruct iotlb_lock l;\r\niotlb_lock_get(obj, &l);\r\nl.vict = n;\r\niotlb_lock_set(obj, &l);\r\niotlb_read_cr(obj, &cr);\r\nreturn cr;\r\n}\r\nstatic int load_iotlb_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nint err = 0;\r\nstruct iotlb_lock l;\r\nstruct cr_regs *cr;\r\nif (!obj || !obj->nr_tlb_entries || !e)\r\nreturn -EINVAL;\r\npm_runtime_get_sync(obj->dev);\r\niotlb_lock_get(obj, &l);\r\nif (l.base == obj->nr_tlb_entries) {\r\ndev_warn(obj->dev, "%s: preserve entries full\n", __func__);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\nif (!e->prsvd) {\r\nint i;\r\nstruct cr_regs tmp;\r\nfor_each_iotlb_cr(obj, obj->nr_tlb_entries, i, tmp)\r\nif (!iotlb_cr_valid(&tmp))\r\nbreak;\r\nif (i == obj->nr_tlb_entries) {\r\ndev_dbg(obj->dev, "%s: full: no entry\n", __func__);\r\nerr = -EBUSY;\r\ngoto out;\r\n}\r\niotlb_lock_get(obj, &l);\r\n} else {\r\nl.vict = l.base;\r\niotlb_lock_set(obj, &l);\r\n}\r\ncr = iotlb_alloc_cr(obj, e);\r\nif (IS_ERR(cr)) {\r\npm_runtime_put_sync(obj->dev);\r\nreturn PTR_ERR(cr);\r\n}\r\niotlb_load_cr(obj, cr);\r\nkfree(cr);\r\nif (e->prsvd)\r\nl.base++;\r\nif (++l.vict == obj->nr_tlb_entries)\r\nl.vict = l.base;\r\niotlb_lock_set(obj, &l);\r\nout:\r\npm_runtime_put_sync(obj->dev);\r\nreturn err;\r\n}\r\nstatic int load_iotlb_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nreturn 0;\r\n}\r\nstatic int prefetch_iotlb_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nreturn load_iotlb_entry(obj, e);\r\n}\r\nstatic void flush_iotlb_page(struct omap_iommu *obj, u32 da)\r\n{\r\nint i;\r\nstruct cr_regs cr;\r\npm_runtime_get_sync(obj->dev);\r\nfor_each_iotlb_cr(obj, obj->nr_tlb_entries, i, cr) {\r\nu32 start;\r\nsize_t bytes;\r\nif (!iotlb_cr_valid(&cr))\r\ncontinue;\r\nstart = iotlb_cr_to_virt(&cr);\r\nbytes = iopgsz_to_bytes(cr.cam & 3);\r\nif ((start <= da) && (da < start + bytes)) {\r\ndev_dbg(obj->dev, "%s: %08x<=%08x(%x)\n",\r\n__func__, start, da, bytes);\r\niotlb_load_cr(obj, &cr);\r\niommu_write_reg(obj, 1, MMU_FLUSH_ENTRY);\r\n}\r\n}\r\npm_runtime_put_sync(obj->dev);\r\nif (i == obj->nr_tlb_entries)\r\ndev_dbg(obj->dev, "%s: no page for %08x\n", __func__, da);\r\n}\r\nstatic void flush_iotlb_all(struct omap_iommu *obj)\r\n{\r\nstruct iotlb_lock l;\r\npm_runtime_get_sync(obj->dev);\r\nl.base = 0;\r\nl.vict = 0;\r\niotlb_lock_set(obj, &l);\r\niommu_write_reg(obj, 1, MMU_GFLUSH);\r\npm_runtime_put_sync(obj->dev);\r\n}\r\nssize_t omap_iommu_dump_ctx(struct omap_iommu *obj, char *buf, ssize_t bytes)\r\n{\r\nif (!obj || !buf)\r\nreturn -EINVAL;\r\npm_runtime_get_sync(obj->dev);\r\nbytes = arch_iommu->dump_ctx(obj, buf, bytes);\r\npm_runtime_put_sync(obj->dev);\r\nreturn bytes;\r\n}\r\nstatic int\r\n__dump_tlb_entries(struct omap_iommu *obj, struct cr_regs *crs, int num)\r\n{\r\nint i;\r\nstruct iotlb_lock saved;\r\nstruct cr_regs tmp;\r\nstruct cr_regs *p = crs;\r\npm_runtime_get_sync(obj->dev);\r\niotlb_lock_get(obj, &saved);\r\nfor_each_iotlb_cr(obj, num, i, tmp) {\r\nif (!iotlb_cr_valid(&tmp))\r\ncontinue;\r\n*p++ = tmp;\r\n}\r\niotlb_lock_set(obj, &saved);\r\npm_runtime_put_sync(obj->dev);\r\nreturn p - crs;\r\n}\r\nsize_t omap_dump_tlb_entries(struct omap_iommu *obj, char *buf, ssize_t bytes)\r\n{\r\nint i, num;\r\nstruct cr_regs *cr;\r\nchar *p = buf;\r\nnum = bytes / sizeof(*cr);\r\nnum = min(obj->nr_tlb_entries, num);\r\ncr = kcalloc(num, sizeof(*cr), GFP_KERNEL);\r\nif (!cr)\r\nreturn 0;\r\nnum = __dump_tlb_entries(obj, cr, num);\r\nfor (i = 0; i < num; i++)\r\np += iotlb_dump_cr(obj, cr + i, p);\r\nkfree(cr);\r\nreturn p - buf;\r\n}\r\nint omap_foreach_iommu_device(void *data, int (*fn)(struct device *, void *))\r\n{\r\nreturn driver_for_each_device(&omap_iommu_driver.driver,\r\nNULL, data, fn);\r\n}\r\nstatic void flush_iopgd_range(u32 *first, u32 *last)\r\n{\r\ndo {\r\nasm("mcr p15, 0, %0, c7, c10, 1 @ flush_pgd"\r\n: : "r" (first));\r\nfirst += L1_CACHE_BYTES / sizeof(*first);\r\n} while (first <= last);\r\n}\r\nstatic void flush_iopte_range(u32 *first, u32 *last)\r\n{\r\ndo {\r\nasm("mcr p15, 0, %0, c7, c10, 1 @ flush_pte"\r\n: : "r" (first));\r\nfirst += L1_CACHE_BYTES / sizeof(*first);\r\n} while (first <= last);\r\n}\r\nstatic void iopte_free(u32 *iopte)\r\n{\r\nkmem_cache_free(iopte_cachep, iopte);\r\n}\r\nstatic u32 *iopte_alloc(struct omap_iommu *obj, u32 *iopgd, u32 da)\r\n{\r\nu32 *iopte;\r\nif (*iopgd)\r\ngoto pte_ready;\r\nspin_unlock(&obj->page_table_lock);\r\niopte = kmem_cache_zalloc(iopte_cachep, GFP_KERNEL);\r\nspin_lock(&obj->page_table_lock);\r\nif (!*iopgd) {\r\nif (!iopte)\r\nreturn ERR_PTR(-ENOMEM);\r\n*iopgd = virt_to_phys(iopte) | IOPGD_TABLE;\r\nflush_iopgd_range(iopgd, iopgd);\r\ndev_vdbg(obj->dev, "%s: a new pte:%p\n", __func__, iopte);\r\n} else {\r\niopte_free(iopte);\r\n}\r\npte_ready:\r\niopte = iopte_offset(iopgd, da);\r\ndev_vdbg(obj->dev,\r\n"%s: da:%08x pgd:%p *pgd:%08x pte:%p *pte:%08x\n",\r\n__func__, da, iopgd, *iopgd, iopte, *iopte);\r\nreturn iopte;\r\n}\r\nstatic int iopgd_alloc_section(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nif ((da | pa) & ~IOSECTION_MASK) {\r\ndev_err(obj->dev, "%s: %08x:%08x should aligned on %08lx\n",\r\n__func__, da, pa, IOSECTION_SIZE);\r\nreturn -EINVAL;\r\n}\r\n*iopgd = (pa & IOSECTION_MASK) | prot | IOPGD_SECTION;\r\nflush_iopgd_range(iopgd, iopgd);\r\nreturn 0;\r\n}\r\nstatic int iopgd_alloc_super(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nint i;\r\nif ((da | pa) & ~IOSUPER_MASK) {\r\ndev_err(obj->dev, "%s: %08x:%08x should aligned on %08lx\n",\r\n__func__, da, pa, IOSUPER_SIZE);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 16; i++)\r\n*(iopgd + i) = (pa & IOSUPER_MASK) | prot | IOPGD_SUPER;\r\nflush_iopgd_range(iopgd, iopgd + 15);\r\nreturn 0;\r\n}\r\nstatic int iopte_alloc_page(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nu32 *iopte = iopte_alloc(obj, iopgd, da);\r\nif (IS_ERR(iopte))\r\nreturn PTR_ERR(iopte);\r\n*iopte = (pa & IOPAGE_MASK) | prot | IOPTE_SMALL;\r\nflush_iopte_range(iopte, iopte);\r\ndev_vdbg(obj->dev, "%s: da:%08x pa:%08x pte:%p *pte:%08x\n",\r\n__func__, da, pa, iopte, *iopte);\r\nreturn 0;\r\n}\r\nstatic int iopte_alloc_large(struct omap_iommu *obj, u32 da, u32 pa, u32 prot)\r\n{\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nu32 *iopte = iopte_alloc(obj, iopgd, da);\r\nint i;\r\nif ((da | pa) & ~IOLARGE_MASK) {\r\ndev_err(obj->dev, "%s: %08x:%08x should aligned on %08lx\n",\r\n__func__, da, pa, IOLARGE_SIZE);\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(iopte))\r\nreturn PTR_ERR(iopte);\r\nfor (i = 0; i < 16; i++)\r\n*(iopte + i) = (pa & IOLARGE_MASK) | prot | IOPTE_LARGE;\r\nflush_iopte_range(iopte, iopte + 15);\r\nreturn 0;\r\n}\r\nstatic int\r\niopgtable_store_entry_core(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nint (*fn)(struct omap_iommu *, u32, u32, u32);\r\nu32 prot;\r\nint err;\r\nif (!obj || !e)\r\nreturn -EINVAL;\r\nswitch (e->pgsz) {\r\ncase MMU_CAM_PGSZ_16M:\r\nfn = iopgd_alloc_super;\r\nbreak;\r\ncase MMU_CAM_PGSZ_1M:\r\nfn = iopgd_alloc_section;\r\nbreak;\r\ncase MMU_CAM_PGSZ_64K:\r\nfn = iopte_alloc_large;\r\nbreak;\r\ncase MMU_CAM_PGSZ_4K:\r\nfn = iopte_alloc_page;\r\nbreak;\r\ndefault:\r\nfn = NULL;\r\nBUG();\r\nbreak;\r\n}\r\nprot = get_iopte_attr(e);\r\nspin_lock(&obj->page_table_lock);\r\nerr = fn(obj, e->da, e->pa, prot);\r\nspin_unlock(&obj->page_table_lock);\r\nreturn err;\r\n}\r\nint omap_iopgtable_store_entry(struct omap_iommu *obj, struct iotlb_entry *e)\r\n{\r\nint err;\r\nflush_iotlb_page(obj, e->da);\r\nerr = iopgtable_store_entry_core(obj, e);\r\nif (!err)\r\nprefetch_iotlb_entry(obj, e);\r\nreturn err;\r\n}\r\nstatic void\r\niopgtable_lookup_entry(struct omap_iommu *obj, u32 da, u32 **ppgd, u32 **ppte)\r\n{\r\nu32 *iopgd, *iopte = NULL;\r\niopgd = iopgd_offset(obj, da);\r\nif (!*iopgd)\r\ngoto out;\r\nif (iopgd_is_table(*iopgd))\r\niopte = iopte_offset(iopgd, da);\r\nout:\r\n*ppgd = iopgd;\r\n*ppte = iopte;\r\n}\r\nstatic size_t iopgtable_clear_entry_core(struct omap_iommu *obj, u32 da)\r\n{\r\nsize_t bytes;\r\nu32 *iopgd = iopgd_offset(obj, da);\r\nint nent = 1;\r\nif (!*iopgd)\r\nreturn 0;\r\nif (iopgd_is_table(*iopgd)) {\r\nint i;\r\nu32 *iopte = iopte_offset(iopgd, da);\r\nbytes = IOPTE_SIZE;\r\nif (*iopte & IOPTE_LARGE) {\r\nnent *= 16;\r\niopte = iopte_offset(iopgd, (da & IOLARGE_MASK));\r\n}\r\nbytes *= nent;\r\nmemset(iopte, 0, nent * sizeof(*iopte));\r\nflush_iopte_range(iopte, iopte + (nent - 1) * sizeof(*iopte));\r\niopte = iopte_offset(iopgd, 0);\r\nfor (i = 0; i < PTRS_PER_IOPTE; i++)\r\nif (iopte[i])\r\ngoto out;\r\niopte_free(iopte);\r\nnent = 1;\r\n} else {\r\nbytes = IOPGD_SIZE;\r\nif ((*iopgd & IOPGD_SUPER) == IOPGD_SUPER) {\r\nnent *= 16;\r\niopgd = iopgd_offset(obj, (da & IOSUPER_MASK));\r\n}\r\nbytes *= nent;\r\n}\r\nmemset(iopgd, 0, nent * sizeof(*iopgd));\r\nflush_iopgd_range(iopgd, iopgd + (nent - 1) * sizeof(*iopgd));\r\nout:\r\nreturn bytes;\r\n}\r\nstatic size_t iopgtable_clear_entry(struct omap_iommu *obj, u32 da)\r\n{\r\nsize_t bytes;\r\nspin_lock(&obj->page_table_lock);\r\nbytes = iopgtable_clear_entry_core(obj, da);\r\nflush_iotlb_page(obj, da);\r\nspin_unlock(&obj->page_table_lock);\r\nreturn bytes;\r\n}\r\nstatic void iopgtable_clear_entry_all(struct omap_iommu *obj)\r\n{\r\nint i;\r\nspin_lock(&obj->page_table_lock);\r\nfor (i = 0; i < PTRS_PER_IOPGD; i++) {\r\nu32 da;\r\nu32 *iopgd;\r\nda = i << IOPGD_SHIFT;\r\niopgd = iopgd_offset(obj, da);\r\nif (!*iopgd)\r\ncontinue;\r\nif (iopgd_is_table(*iopgd))\r\niopte_free(iopte_offset(iopgd, 0));\r\n*iopgd = 0;\r\nflush_iopgd_range(iopgd, iopgd);\r\n}\r\nflush_iotlb_all(obj);\r\nspin_unlock(&obj->page_table_lock);\r\n}\r\nstatic irqreturn_t iommu_fault_handler(int irq, void *data)\r\n{\r\nu32 da, errs;\r\nu32 *iopgd, *iopte;\r\nstruct omap_iommu *obj = data;\r\nstruct iommu_domain *domain = obj->domain;\r\nif (!obj->refcount)\r\nreturn IRQ_NONE;\r\nerrs = iommu_report_fault(obj, &da);\r\nif (errs == 0)\r\nreturn IRQ_HANDLED;\r\nif (!report_iommu_fault(domain, obj->dev, da, 0))\r\nreturn IRQ_HANDLED;\r\niommu_disable(obj);\r\niopgd = iopgd_offset(obj, da);\r\nif (!iopgd_is_table(*iopgd)) {\r\ndev_err(obj->dev, "%s: errs:0x%08x da:0x%08x pgd:0x%p *pgd:px%08x\n",\r\nobj->name, errs, da, iopgd, *iopgd);\r\nreturn IRQ_NONE;\r\n}\r\niopte = iopte_offset(iopgd, da);\r\ndev_err(obj->dev, "%s: errs:0x%08x da:0x%08x pgd:0x%p *pgd:0x%08x pte:0x%p *pte:0x%08x\n",\r\nobj->name, errs, da, iopgd, *iopgd, iopte, *iopte);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int device_match_by_alias(struct device *dev, void *data)\r\n{\r\nstruct omap_iommu *obj = to_iommu(dev);\r\nconst char *name = data;\r\npr_debug("%s: %s %s\n", __func__, obj->name, name);\r\nreturn strcmp(obj->name, name) == 0;\r\n}\r\nstatic struct omap_iommu *omap_iommu_attach(const char *name, u32 *iopgd)\r\n{\r\nint err = -ENOMEM;\r\nstruct device *dev;\r\nstruct omap_iommu *obj;\r\ndev = driver_find_device(&omap_iommu_driver.driver, NULL,\r\n(void *)name,\r\ndevice_match_by_alias);\r\nif (!dev)\r\nreturn NULL;\r\nobj = to_iommu(dev);\r\nspin_lock(&obj->iommu_lock);\r\nif (++obj->refcount > 1) {\r\ndev_err(dev, "%s: already attached!\n", obj->name);\r\nerr = -EBUSY;\r\ngoto err_enable;\r\n}\r\nobj->iopgd = iopgd;\r\nerr = iommu_enable(obj);\r\nif (err)\r\ngoto err_enable;\r\nflush_iotlb_all(obj);\r\nif (!try_module_get(obj->owner))\r\ngoto err_module;\r\nspin_unlock(&obj->iommu_lock);\r\ndev_dbg(obj->dev, "%s: %s\n", __func__, obj->name);\r\nreturn obj;\r\nerr_module:\r\nif (obj->refcount == 1)\r\niommu_disable(obj);\r\nerr_enable:\r\nobj->refcount--;\r\nspin_unlock(&obj->iommu_lock);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void omap_iommu_detach(struct omap_iommu *obj)\r\n{\r\nif (!obj || IS_ERR(obj))\r\nreturn;\r\nspin_lock(&obj->iommu_lock);\r\nif (--obj->refcount == 0)\r\niommu_disable(obj);\r\nmodule_put(obj->owner);\r\nobj->iopgd = NULL;\r\nspin_unlock(&obj->iommu_lock);\r\ndev_dbg(obj->dev, "%s: %s\n", __func__, obj->name);\r\n}\r\nstatic int omap_iommu_probe(struct platform_device *pdev)\r\n{\r\nint err = -ENODEV;\r\nint irq;\r\nstruct omap_iommu *obj;\r\nstruct resource *res;\r\nstruct iommu_platform_data *pdata = pdev->dev.platform_data;\r\nobj = kzalloc(sizeof(*obj) + MMU_REG_SIZE, GFP_KERNEL);\r\nif (!obj)\r\nreturn -ENOMEM;\r\nobj->nr_tlb_entries = pdata->nr_tlb_entries;\r\nobj->name = pdata->name;\r\nobj->dev = &pdev->dev;\r\nobj->ctx = (void *)obj + sizeof(*obj);\r\nobj->da_start = pdata->da_start;\r\nobj->da_end = pdata->da_end;\r\nspin_lock_init(&obj->iommu_lock);\r\nmutex_init(&obj->mmap_lock);\r\nspin_lock_init(&obj->page_table_lock);\r\nINIT_LIST_HEAD(&obj->mmap);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nerr = -ENODEV;\r\ngoto err_mem;\r\n}\r\nres = request_mem_region(res->start, resource_size(res),\r\ndev_name(&pdev->dev));\r\nif (!res) {\r\nerr = -EIO;\r\ngoto err_mem;\r\n}\r\nobj->regbase = ioremap(res->start, resource_size(res));\r\nif (!obj->regbase) {\r\nerr = -ENOMEM;\r\ngoto err_ioremap;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nerr = -ENODEV;\r\ngoto err_irq;\r\n}\r\nerr = request_irq(irq, iommu_fault_handler, IRQF_SHARED,\r\ndev_name(&pdev->dev), obj);\r\nif (err < 0)\r\ngoto err_irq;\r\nplatform_set_drvdata(pdev, obj);\r\npm_runtime_irq_safe(obj->dev);\r\npm_runtime_enable(obj->dev);\r\ndev_info(&pdev->dev, "%s registered\n", obj->name);\r\nreturn 0;\r\nerr_irq:\r\niounmap(obj->regbase);\r\nerr_ioremap:\r\nrelease_mem_region(res->start, resource_size(res));\r\nerr_mem:\r\nkfree(obj);\r\nreturn err;\r\n}\r\nstatic int omap_iommu_remove(struct platform_device *pdev)\r\n{\r\nint irq;\r\nstruct resource *res;\r\nstruct omap_iommu *obj = platform_get_drvdata(pdev);\r\niopgtable_clear_entry_all(obj);\r\nirq = platform_get_irq(pdev, 0);\r\nfree_irq(irq, obj);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\niounmap(obj->regbase);\r\npm_runtime_disable(obj->dev);\r\ndev_info(&pdev->dev, "%s removed\n", obj->name);\r\nkfree(obj);\r\nreturn 0;\r\n}\r\nstatic void iopte_cachep_ctor(void *iopte)\r\n{\r\nclean_dcache_area(iopte, IOPTE_TABLE_SIZE);\r\n}\r\nstatic u32 iotlb_init_entry(struct iotlb_entry *e, u32 da, u32 pa,\r\nu32 flags)\r\n{\r\nmemset(e, 0, sizeof(*e));\r\ne->da = da;\r\ne->pa = pa;\r\ne->valid = 1;\r\ne->pgsz = flags & MMU_CAM_PGSZ_MASK;\r\ne->endian = flags & MMU_RAM_ENDIAN_MASK;\r\ne->elsz = flags & MMU_RAM_ELSZ_MASK;\r\ne->mixed = flags & MMU_RAM_MIXED_MASK;\r\nreturn iopgsz_to_bytes(e->pgsz);\r\n}\r\nstatic int omap_iommu_map(struct iommu_domain *domain, unsigned long da,\r\nphys_addr_t pa, size_t bytes, int prot)\r\n{\r\nstruct omap_iommu_domain *omap_domain = domain->priv;\r\nstruct omap_iommu *oiommu = omap_domain->iommu_dev;\r\nstruct device *dev = oiommu->dev;\r\nstruct iotlb_entry e;\r\nint omap_pgsz;\r\nu32 ret, flags;\r\nomap_pgsz = bytes_to_iopgsz(bytes);\r\nif (omap_pgsz < 0) {\r\ndev_err(dev, "invalid size to map: %d\n", bytes);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "mapping da 0x%lx to pa 0x%x size 0x%x\n", da, pa, bytes);\r\nflags = omap_pgsz | prot;\r\niotlb_init_entry(&e, da, pa, flags);\r\nret = omap_iopgtable_store_entry(oiommu, &e);\r\nif (ret)\r\ndev_err(dev, "omap_iopgtable_store_entry failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic size_t omap_iommu_unmap(struct iommu_domain *domain, unsigned long da,\r\nsize_t size)\r\n{\r\nstruct omap_iommu_domain *omap_domain = domain->priv;\r\nstruct omap_iommu *oiommu = omap_domain->iommu_dev;\r\nstruct device *dev = oiommu->dev;\r\ndev_dbg(dev, "unmapping da 0x%lx size %u\n", da, size);\r\nreturn iopgtable_clear_entry(oiommu, da);\r\n}\r\nstatic int\r\nomap_iommu_attach_dev(struct iommu_domain *domain, struct device *dev)\r\n{\r\nstruct omap_iommu_domain *omap_domain = domain->priv;\r\nstruct omap_iommu *oiommu;\r\nstruct omap_iommu_arch_data *arch_data = dev->archdata.iommu;\r\nint ret = 0;\r\nspin_lock(&omap_domain->lock);\r\nif (omap_domain->iommu_dev) {\r\ndev_err(dev, "iommu domain is already attached\n");\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\noiommu = omap_iommu_attach(arch_data->name, omap_domain->pgtable);\r\nif (IS_ERR(oiommu)) {\r\nret = PTR_ERR(oiommu);\r\ndev_err(dev, "can't get omap iommu: %d\n", ret);\r\ngoto out;\r\n}\r\nomap_domain->iommu_dev = arch_data->iommu_dev = oiommu;\r\nomap_domain->dev = dev;\r\noiommu->domain = domain;\r\nout:\r\nspin_unlock(&omap_domain->lock);\r\nreturn ret;\r\n}\r\nstatic void _omap_iommu_detach_dev(struct omap_iommu_domain *omap_domain,\r\nstruct device *dev)\r\n{\r\nstruct omap_iommu *oiommu = dev_to_omap_iommu(dev);\r\nstruct omap_iommu_arch_data *arch_data = dev->archdata.iommu;\r\nif (omap_domain->iommu_dev != oiommu) {\r\ndev_err(dev, "invalid iommu device\n");\r\nreturn;\r\n}\r\niopgtable_clear_entry_all(oiommu);\r\nomap_iommu_detach(oiommu);\r\nomap_domain->iommu_dev = arch_data->iommu_dev = NULL;\r\nomap_domain->dev = NULL;\r\n}\r\nstatic void omap_iommu_detach_dev(struct iommu_domain *domain,\r\nstruct device *dev)\r\n{\r\nstruct omap_iommu_domain *omap_domain = domain->priv;\r\nspin_lock(&omap_domain->lock);\r\n_omap_iommu_detach_dev(omap_domain, dev);\r\nspin_unlock(&omap_domain->lock);\r\n}\r\nstatic int omap_iommu_domain_init(struct iommu_domain *domain)\r\n{\r\nstruct omap_iommu_domain *omap_domain;\r\nomap_domain = kzalloc(sizeof(*omap_domain), GFP_KERNEL);\r\nif (!omap_domain) {\r\npr_err("kzalloc failed\n");\r\ngoto out;\r\n}\r\nomap_domain->pgtable = kzalloc(IOPGD_TABLE_SIZE, GFP_KERNEL);\r\nif (!omap_domain->pgtable) {\r\npr_err("kzalloc failed\n");\r\ngoto fail_nomem;\r\n}\r\nBUG_ON(!IS_ALIGNED((long)omap_domain->pgtable, IOPGD_TABLE_SIZE));\r\nclean_dcache_area(omap_domain->pgtable, IOPGD_TABLE_SIZE);\r\nspin_lock_init(&omap_domain->lock);\r\ndomain->priv = omap_domain;\r\ndomain->geometry.aperture_start = 0;\r\ndomain->geometry.aperture_end = (1ULL << 32) - 1;\r\ndomain->geometry.force_aperture = true;\r\nreturn 0;\r\nfail_nomem:\r\nkfree(omap_domain);\r\nout:\r\nreturn -ENOMEM;\r\n}\r\nstatic void omap_iommu_domain_destroy(struct iommu_domain *domain)\r\n{\r\nstruct omap_iommu_domain *omap_domain = domain->priv;\r\ndomain->priv = NULL;\r\nif (omap_domain->iommu_dev)\r\n_omap_iommu_detach_dev(omap_domain, omap_domain->dev);\r\nkfree(omap_domain->pgtable);\r\nkfree(omap_domain);\r\n}\r\nstatic phys_addr_t omap_iommu_iova_to_phys(struct iommu_domain *domain,\r\ndma_addr_t da)\r\n{\r\nstruct omap_iommu_domain *omap_domain = domain->priv;\r\nstruct omap_iommu *oiommu = omap_domain->iommu_dev;\r\nstruct device *dev = oiommu->dev;\r\nu32 *pgd, *pte;\r\nphys_addr_t ret = 0;\r\niopgtable_lookup_entry(oiommu, da, &pgd, &pte);\r\nif (pte) {\r\nif (iopte_is_small(*pte))\r\nret = omap_iommu_translate(*pte, da, IOPTE_MASK);\r\nelse if (iopte_is_large(*pte))\r\nret = omap_iommu_translate(*pte, da, IOLARGE_MASK);\r\nelse\r\ndev_err(dev, "bogus pte 0x%x, da 0x%llx", *pte,\r\n(unsigned long long)da);\r\n} else {\r\nif (iopgd_is_section(*pgd))\r\nret = omap_iommu_translate(*pgd, da, IOSECTION_MASK);\r\nelse if (iopgd_is_super(*pgd))\r\nret = omap_iommu_translate(*pgd, da, IOSUPER_MASK);\r\nelse\r\ndev_err(dev, "bogus pgd 0x%x, da 0x%llx", *pgd,\r\n(unsigned long long)da);\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_iommu_domain_has_cap(struct iommu_domain *domain,\r\nunsigned long cap)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __init omap_iommu_init(void)\r\n{\r\nstruct kmem_cache *p;\r\nconst unsigned long flags = SLAB_HWCACHE_ALIGN;\r\nsize_t align = 1 << 10;\r\np = kmem_cache_create("iopte_cache", IOPTE_TABLE_SIZE, align, flags,\r\niopte_cachep_ctor);\r\nif (!p)\r\nreturn -ENOMEM;\r\niopte_cachep = p;\r\nbus_set_iommu(&platform_bus_type, &omap_iommu_ops);\r\nreturn platform_driver_register(&omap_iommu_driver);\r\n}\r\nstatic void __exit omap_iommu_exit(void)\r\n{\r\nkmem_cache_destroy(iopte_cachep);\r\nplatform_driver_unregister(&omap_iommu_driver);\r\n}
