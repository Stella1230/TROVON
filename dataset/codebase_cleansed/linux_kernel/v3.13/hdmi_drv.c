static struct hdmi_device *sd_to_hdmi_dev(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct hdmi_device, sd);\r\n}\r\nstatic inline\r\nvoid hdmi_write(struct hdmi_device *hdev, u32 reg_id, u32 value)\r\n{\r\nwritel(value, hdev->regs + reg_id);\r\n}\r\nstatic inline\r\nvoid hdmi_write_mask(struct hdmi_device *hdev, u32 reg_id, u32 value, u32 mask)\r\n{\r\nu32 old = readl(hdev->regs + reg_id);\r\nvalue = (value & mask) | (old & ~mask);\r\nwritel(value, hdev->regs + reg_id);\r\n}\r\nstatic inline\r\nvoid hdmi_writeb(struct hdmi_device *hdev, u32 reg_id, u8 value)\r\n{\r\nwriteb(value, hdev->regs + reg_id);\r\n}\r\nstatic inline\r\nvoid hdmi_writebn(struct hdmi_device *hdev, u32 reg_id, int n, u32 value)\r\n{\r\nswitch (n) {\r\ndefault:\r\nwriteb(value >> 24, hdev->regs + reg_id + 12);\r\ncase 3:\r\nwriteb(value >> 16, hdev->regs + reg_id + 8);\r\ncase 2:\r\nwriteb(value >> 8, hdev->regs + reg_id + 4);\r\ncase 1:\r\nwriteb(value >> 0, hdev->regs + reg_id + 0);\r\n}\r\n}\r\nstatic inline u32 hdmi_read(struct hdmi_device *hdev, u32 reg_id)\r\n{\r\nreturn readl(hdev->regs + reg_id);\r\n}\r\nstatic irqreturn_t hdmi_irq_handler(int irq, void *dev_data)\r\n{\r\nstruct hdmi_device *hdev = dev_data;\r\nu32 intc_flag;\r\n(void)irq;\r\nintc_flag = hdmi_read(hdev, HDMI_INTC_FLAG);\r\nif (intc_flag & HDMI_INTC_FLAG_HPD_UNPLUG) {\r\npr_info("unplugged\n");\r\nhdmi_write_mask(hdev, HDMI_INTC_FLAG, ~0,\r\nHDMI_INTC_FLAG_HPD_UNPLUG);\r\n}\r\nif (intc_flag & HDMI_INTC_FLAG_HPD_PLUG) {\r\npr_info("plugged\n");\r\nhdmi_write_mask(hdev, HDMI_INTC_FLAG, ~0,\r\nHDMI_INTC_FLAG_HPD_PLUG);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void hdmi_reg_init(struct hdmi_device *hdev)\r\n{\r\nhdmi_write_mask(hdev, HDMI_INTC_CON, ~0, HDMI_INTC_EN_GLOBAL |\r\nHDMI_INTC_EN_HPD_PLUG | HDMI_INTC_EN_HPD_UNPLUG);\r\nhdmi_write_mask(hdev, HDMI_MODE_SEL,\r\nHDMI_MODE_DVI_EN, HDMI_MODE_MASK);\r\nhdmi_write_mask(hdev, HDMI_CON_2, ~0,\r\nHDMI_DVI_PERAMBLE_EN | HDMI_DVI_BAND_EN);\r\nhdmi_write_mask(hdev, HDMI_CON_0, 0, HDMI_BLUE_SCR_EN);\r\nhdmi_writeb(hdev, HDMI_BLUE_SCREEN_0, 0x12);\r\nhdmi_writeb(hdev, HDMI_BLUE_SCREEN_1, 0x34);\r\nhdmi_writeb(hdev, HDMI_BLUE_SCREEN_2, 0x56);\r\n}\r\nstatic void hdmi_timing_apply(struct hdmi_device *hdev,\r\nconst struct hdmi_timings *t)\r\n{\r\nhdmi_writebn(hdev, HDMI_H_BLANK_0, 2, t->hact.beg);\r\nhdmi_writebn(hdev, HDMI_H_SYNC_GEN_0, 3,\r\n(t->hsyn_pol << 20) | (t->hsyn.end << 10) | t->hsyn.beg);\r\nhdmi_writeb(hdev, HDMI_VSYNC_POL, t->vsyn_pol);\r\nhdmi_writebn(hdev, HDMI_V_BLANK_0, 3,\r\n(t->vact[0].beg << 11) | t->vact[0].end);\r\nhdmi_writebn(hdev, HDMI_V_SYNC_GEN_1_0, 3,\r\n(t->vsyn[0].beg << 12) | t->vsyn[0].end);\r\nif (t->interlaced) {\r\nu32 vsyn_trans = t->hsyn.beg + t->vsyn_off;\r\nhdmi_writeb(hdev, HDMI_INT_PRO_MODE, 1);\r\nhdmi_writebn(hdev, HDMI_H_V_LINE_0, 3,\r\n(t->hact.end << 12) | t->vact[1].end);\r\nhdmi_writebn(hdev, HDMI_V_BLANK_F_0, 3,\r\n(t->vact[1].end << 11) | t->vact[1].beg);\r\nhdmi_writebn(hdev, HDMI_V_SYNC_GEN_2_0, 3,\r\n(t->vsyn[1].beg << 12) | t->vsyn[1].end);\r\nhdmi_writebn(hdev, HDMI_V_SYNC_GEN_3_0, 3,\r\n(vsyn_trans << 12) | vsyn_trans);\r\n} else {\r\nhdmi_writeb(hdev, HDMI_INT_PRO_MODE, 0);\r\nhdmi_writebn(hdev, HDMI_H_V_LINE_0, 3,\r\n(t->hact.end << 12) | t->vact[0].end);\r\n}\r\nhdmi_writebn(hdev, HDMI_TG_H_FSZ_L, 2, t->hact.end);\r\nhdmi_writebn(hdev, HDMI_TG_HACT_ST_L, 2, t->hact.beg);\r\nhdmi_writebn(hdev, HDMI_TG_HACT_SZ_L, 2, t->hact.end - t->hact.beg);\r\nhdmi_writebn(hdev, HDMI_TG_VSYNC_L, 2, t->vsyn[0].beg);\r\nhdmi_writebn(hdev, HDMI_TG_VACT_ST_L, 2, t->vact[0].beg);\r\nhdmi_writebn(hdev, HDMI_TG_VACT_SZ_L, 2,\r\nt->vact[0].end - t->vact[0].beg);\r\nhdmi_writebn(hdev, HDMI_TG_VSYNC_TOP_HDMI_L, 2, t->vsyn[0].beg);\r\nhdmi_writebn(hdev, HDMI_TG_FIELD_TOP_HDMI_L, 2, t->vsyn[0].beg);\r\nif (t->interlaced) {\r\nhdmi_write_mask(hdev, HDMI_TG_CMD, ~0, HDMI_TG_FIELD_EN);\r\nhdmi_writebn(hdev, HDMI_TG_V_FSZ_L, 2, t->vact[1].end);\r\nhdmi_writebn(hdev, HDMI_TG_VSYNC2_L, 2, t->vsyn[1].beg);\r\nhdmi_writebn(hdev, HDMI_TG_FIELD_CHG_L, 2, t->vact[0].end);\r\nhdmi_writebn(hdev, HDMI_TG_VACT_ST2_L, 2, t->vact[1].beg);\r\nhdmi_writebn(hdev, HDMI_TG_VSYNC_BOT_HDMI_L, 2, t->vsyn[1].beg);\r\nhdmi_writebn(hdev, HDMI_TG_FIELD_BOT_HDMI_L, 2, t->vsyn[1].beg);\r\n} else {\r\nhdmi_write_mask(hdev, HDMI_TG_CMD, 0, HDMI_TG_FIELD_EN);\r\nhdmi_writebn(hdev, HDMI_TG_V_FSZ_L, 2, t->vact[0].end);\r\n}\r\n}\r\nstatic int hdmi_conf_apply(struct hdmi_device *hdmi_dev)\r\n{\r\nstruct device *dev = hdmi_dev->dev;\r\nconst struct hdmi_timings *conf = hdmi_dev->cur_conf;\r\nint ret;\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (!hdmi_dev->cur_conf_dirty)\r\nreturn 0;\r\nhdmi_write_mask(hdmi_dev, HDMI_PHY_RSTOUT, ~0, HDMI_PHY_SW_RSTOUT);\r\nmdelay(10);\r\nhdmi_write_mask(hdmi_dev, HDMI_PHY_RSTOUT, 0, HDMI_PHY_SW_RSTOUT);\r\nmdelay(10);\r\nret = v4l2_subdev_call(hdmi_dev->phy_sd, video, s_dv_timings,\r\n&hdmi_dev->cur_timings);\r\nif (ret) {\r\ndev_err(dev, "failed to set timings\n");\r\nreturn ret;\r\n}\r\nhdmi_write_mask(hdmi_dev, HDMI_CORE_RSTOUT, 0, HDMI_CORE_SW_RSTOUT);\r\nmdelay(10);\r\nhdmi_write_mask(hdmi_dev, HDMI_CORE_RSTOUT, ~0, HDMI_CORE_SW_RSTOUT);\r\nmdelay(10);\r\nhdmi_reg_init(hdmi_dev);\r\nhdmi_timing_apply(hdmi_dev, conf);\r\nhdmi_dev->cur_conf_dirty = 0;\r\nreturn 0;\r\n}\r\nstatic void hdmi_dumpregs(struct hdmi_device *hdev, char *prefix)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndev_dbg(hdev->dev, "%s:" #reg_id " = %08x\n", prefix, \\r\nreadl(hdev->regs + reg_id))\r\ndev_dbg(hdev->dev, "%s: ---- CONTROL REGISTERS ----\n", prefix);\r\nDUMPREG(HDMI_INTC_FLAG);\r\nDUMPREG(HDMI_INTC_CON);\r\nDUMPREG(HDMI_HPD_STATUS);\r\nDUMPREG(HDMI_PHY_RSTOUT);\r\nDUMPREG(HDMI_PHY_VPLL);\r\nDUMPREG(HDMI_PHY_CMU);\r\nDUMPREG(HDMI_CORE_RSTOUT);\r\ndev_dbg(hdev->dev, "%s: ---- CORE REGISTERS ----\n", prefix);\r\nDUMPREG(HDMI_CON_0);\r\nDUMPREG(HDMI_CON_1);\r\nDUMPREG(HDMI_CON_2);\r\nDUMPREG(HDMI_SYS_STATUS);\r\nDUMPREG(HDMI_PHY_STATUS);\r\nDUMPREG(HDMI_STATUS_EN);\r\nDUMPREG(HDMI_HPD);\r\nDUMPREG(HDMI_MODE_SEL);\r\nDUMPREG(HDMI_HPD_GEN);\r\nDUMPREG(HDMI_DC_CONTROL);\r\nDUMPREG(HDMI_VIDEO_PATTERN_GEN);\r\ndev_dbg(hdev->dev, "%s: ---- CORE SYNC REGISTERS ----\n", prefix);\r\nDUMPREG(HDMI_H_BLANK_0);\r\nDUMPREG(HDMI_H_BLANK_1);\r\nDUMPREG(HDMI_V_BLANK_0);\r\nDUMPREG(HDMI_V_BLANK_1);\r\nDUMPREG(HDMI_V_BLANK_2);\r\nDUMPREG(HDMI_H_V_LINE_0);\r\nDUMPREG(HDMI_H_V_LINE_1);\r\nDUMPREG(HDMI_H_V_LINE_2);\r\nDUMPREG(HDMI_VSYNC_POL);\r\nDUMPREG(HDMI_INT_PRO_MODE);\r\nDUMPREG(HDMI_V_BLANK_F_0);\r\nDUMPREG(HDMI_V_BLANK_F_1);\r\nDUMPREG(HDMI_V_BLANK_F_2);\r\nDUMPREG(HDMI_H_SYNC_GEN_0);\r\nDUMPREG(HDMI_H_SYNC_GEN_1);\r\nDUMPREG(HDMI_H_SYNC_GEN_2);\r\nDUMPREG(HDMI_V_SYNC_GEN_1_0);\r\nDUMPREG(HDMI_V_SYNC_GEN_1_1);\r\nDUMPREG(HDMI_V_SYNC_GEN_1_2);\r\nDUMPREG(HDMI_V_SYNC_GEN_2_0);\r\nDUMPREG(HDMI_V_SYNC_GEN_2_1);\r\nDUMPREG(HDMI_V_SYNC_GEN_2_2);\r\nDUMPREG(HDMI_V_SYNC_GEN_3_0);\r\nDUMPREG(HDMI_V_SYNC_GEN_3_1);\r\nDUMPREG(HDMI_V_SYNC_GEN_3_2);\r\ndev_dbg(hdev->dev, "%s: ---- TG REGISTERS ----\n", prefix);\r\nDUMPREG(HDMI_TG_CMD);\r\nDUMPREG(HDMI_TG_H_FSZ_L);\r\nDUMPREG(HDMI_TG_H_FSZ_H);\r\nDUMPREG(HDMI_TG_HACT_ST_L);\r\nDUMPREG(HDMI_TG_HACT_ST_H);\r\nDUMPREG(HDMI_TG_HACT_SZ_L);\r\nDUMPREG(HDMI_TG_HACT_SZ_H);\r\nDUMPREG(HDMI_TG_V_FSZ_L);\r\nDUMPREG(HDMI_TG_V_FSZ_H);\r\nDUMPREG(HDMI_TG_VSYNC_L);\r\nDUMPREG(HDMI_TG_VSYNC_H);\r\nDUMPREG(HDMI_TG_VSYNC2_L);\r\nDUMPREG(HDMI_TG_VSYNC2_H);\r\nDUMPREG(HDMI_TG_VACT_ST_L);\r\nDUMPREG(HDMI_TG_VACT_ST_H);\r\nDUMPREG(HDMI_TG_VACT_SZ_L);\r\nDUMPREG(HDMI_TG_VACT_SZ_H);\r\nDUMPREG(HDMI_TG_FIELD_CHG_L);\r\nDUMPREG(HDMI_TG_FIELD_CHG_H);\r\nDUMPREG(HDMI_TG_VACT_ST2_L);\r\nDUMPREG(HDMI_TG_VACT_ST2_H);\r\nDUMPREG(HDMI_TG_VSYNC_TOP_HDMI_L);\r\nDUMPREG(HDMI_TG_VSYNC_TOP_HDMI_H);\r\nDUMPREG(HDMI_TG_VSYNC_BOT_HDMI_L);\r\nDUMPREG(HDMI_TG_VSYNC_BOT_HDMI_H);\r\nDUMPREG(HDMI_TG_FIELD_TOP_HDMI_L);\r\nDUMPREG(HDMI_TG_FIELD_TOP_HDMI_H);\r\nDUMPREG(HDMI_TG_FIELD_BOT_HDMI_L);\r\nDUMPREG(HDMI_TG_FIELD_BOT_HDMI_H);\r\n#undef DUMPREG\r\n}\r\nstatic int hdmi_streamon(struct hdmi_device *hdev)\r\n{\r\nstruct device *dev = hdev->dev;\r\nstruct hdmi_resources *res = &hdev->res;\r\nint ret, tries;\r\ndev_dbg(dev, "%s\n", __func__);\r\nret = hdmi_conf_apply(hdev);\r\nif (ret)\r\nreturn ret;\r\nret = v4l2_subdev_call(hdev->phy_sd, video, s_stream, 1);\r\nif (ret)\r\nreturn ret;\r\nfor (tries = 100; tries; --tries) {\r\nu32 val = hdmi_read(hdev, HDMI_PHY_STATUS);\r\nif (val & HDMI_PHY_STATUS_READY)\r\nbreak;\r\nmdelay(1);\r\n}\r\nif (tries == 0) {\r\ndev_err(dev, "hdmiphy's pll could not reach steady state.\n");\r\nv4l2_subdev_call(hdev->phy_sd, video, s_stream, 0);\r\nhdmi_dumpregs(hdev, "hdmiphy - s_stream");\r\nreturn -EIO;\r\n}\r\nret = v4l2_subdev_call(hdev->mhl_sd, video, s_stream, 1);\r\nif (hdev->mhl_sd && ret) {\r\nv4l2_subdev_call(hdev->phy_sd, video, s_stream, 0);\r\nhdmi_dumpregs(hdev, "mhl - s_stream");\r\nreturn -EIO;\r\n}\r\nclk_disable(res->sclk_hdmi);\r\nclk_set_parent(res->sclk_hdmi, res->sclk_hdmiphy);\r\nclk_enable(res->sclk_hdmi);\r\nhdmi_write_mask(hdev, HDMI_CON_0, ~0, HDMI_EN);\r\nhdmi_write_mask(hdev, HDMI_TG_CMD, ~0, HDMI_TG_EN);\r\nhdmi_dumpregs(hdev, "streamon");\r\nreturn 0;\r\n}\r\nstatic int hdmi_streamoff(struct hdmi_device *hdev)\r\n{\r\nstruct device *dev = hdev->dev;\r\nstruct hdmi_resources *res = &hdev->res;\r\ndev_dbg(dev, "%s\n", __func__);\r\nhdmi_write_mask(hdev, HDMI_CON_0, 0, HDMI_EN);\r\nhdmi_write_mask(hdev, HDMI_TG_CMD, 0, HDMI_TG_EN);\r\nclk_disable(res->sclk_hdmi);\r\nclk_set_parent(res->sclk_hdmi, res->sclk_pixel);\r\nclk_enable(res->sclk_hdmi);\r\nv4l2_subdev_call(hdev->mhl_sd, video, s_stream, 0);\r\nv4l2_subdev_call(hdev->phy_sd, video, s_stream, 0);\r\nhdmi_dumpregs(hdev, "streamoff");\r\nreturn 0;\r\n}\r\nstatic int hdmi_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\nstruct device *dev = hdev->dev;\r\ndev_dbg(dev, "%s(%d)\n", __func__, enable);\r\nif (enable)\r\nreturn hdmi_streamon(hdev);\r\nreturn hdmi_streamoff(hdev);\r\n}\r\nstatic int hdmi_resource_poweron(struct hdmi_resources *res)\r\n{\r\nint ret;\r\nret = regulator_bulk_enable(res->regul_count, res->regul_bulk);\r\nif (ret < 0)\r\nreturn ret;\r\nclk_enable(res->hdmiphy);\r\nclk_set_parent(res->sclk_hdmi, res->sclk_pixel);\r\nclk_enable(res->sclk_hdmi);\r\nreturn 0;\r\n}\r\nstatic void hdmi_resource_poweroff(struct hdmi_resources *res)\r\n{\r\nclk_disable(res->sclk_hdmi);\r\nclk_disable(res->hdmiphy);\r\nregulator_bulk_disable(res->regul_count, res->regul_bulk);\r\n}\r\nstatic int hdmi_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\nint ret;\r\nif (on)\r\nret = pm_runtime_get_sync(hdev->dev);\r\nelse\r\nret = pm_runtime_put_sync(hdev->dev);\r\nreturn IS_ERR_VALUE(ret) ? ret : 0;\r\n}\r\nstatic int hdmi_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\nstruct device *dev = hdev->dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(hdmi_timings); i++)\r\nif (v4l2_match_dv_timings(&hdmi_timings[i].dv_timings,\r\ntimings, 0))\r\nbreak;\r\nif (i == ARRAY_SIZE(hdmi_timings)) {\r\ndev_err(dev, "timings not supported\n");\r\nreturn -EINVAL;\r\n}\r\nhdev->cur_conf = hdmi_timings[i].hdmi_timings;\r\nhdev->cur_conf_dirty = 1;\r\nhdev->cur_timings = *timings;\r\nif (!hdmi_timings[i].reduced_fps)\r\nhdev->cur_timings.bt.flags &= ~V4L2_DV_FL_CAN_REDUCE_FPS;\r\nreturn 0;\r\n}\r\nstatic int hdmi_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\n*timings = sd_to_hdmi_dev(sd)->cur_timings;\r\nreturn 0;\r\n}\r\nstatic int hdmi_g_mbus_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\nconst struct hdmi_timings *t = hdev->cur_conf;\r\ndev_dbg(hdev->dev, "%s\n", __func__);\r\nif (!hdev->cur_conf)\r\nreturn -EINVAL;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->width = t->hact.end - t->hact.beg;\r\nfmt->height = t->vact[0].end - t->vact[0].beg;\r\nfmt->code = V4L2_MBUS_FMT_FIXED;\r\nfmt->colorspace = V4L2_COLORSPACE_SRGB;\r\nif (t->interlaced) {\r\nfmt->field = V4L2_FIELD_INTERLACED;\r\nfmt->height *= 2;\r\n} else {\r\nfmt->field = V4L2_FIELD_NONE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdmi_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->index >= ARRAY_SIZE(hdmi_timings))\r\nreturn -EINVAL;\r\ntimings->timings = hdmi_timings[timings->index].dv_timings;\r\nif (!hdmi_timings[timings->index].reduced_fps)\r\ntimings->timings.bt.flags &= ~V4L2_DV_FL_CAN_REDUCE_FPS;\r\nreturn 0;\r\n}\r\nstatic int hdmi_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\nv4l2_subdev_call(hdev->phy_sd, video, dv_timings_cap, cap);\r\ncap->type = V4L2_DV_BT_656_1120;\r\ncap->bt.min_width = 720;\r\ncap->bt.max_width = 1920;\r\ncap->bt.min_height = 480;\r\ncap->bt.max_height = 1080;\r\ncap->bt.standards = V4L2_DV_BT_STD_CEA861;\r\ncap->bt.capabilities = V4L2_DV_BT_CAP_INTERLACED |\r\nV4L2_DV_BT_CAP_PROGRESSIVE;\r\nreturn 0;\r\n}\r\nstatic int hdmi_runtime_suspend(struct device *dev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\ndev_dbg(dev, "%s\n", __func__);\r\nv4l2_subdev_call(hdev->mhl_sd, core, s_power, 0);\r\nhdmi_resource_poweroff(&hdev->res);\r\nhdev->cur_conf_dirty = 1;\r\nreturn 0;\r\n}\r\nstatic int hdmi_runtime_resume(struct device *dev)\r\n{\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct hdmi_device *hdev = sd_to_hdmi_dev(sd);\r\nint ret;\r\ndev_dbg(dev, "%s\n", __func__);\r\nret = hdmi_resource_poweron(&hdev->res);\r\nif (ret < 0)\r\nreturn ret;\r\nret = v4l2_subdev_call(hdev->mhl_sd, core, s_power, 1);\r\nif (hdev->mhl_sd && ret)\r\ngoto fail;\r\ndev_dbg(dev, "poweron succeed\n");\r\nreturn 0;\r\nfail:\r\nhdmi_resource_poweroff(&hdev->res);\r\ndev_err(dev, "poweron failed\n");\r\nreturn ret;\r\n}\r\nstatic void hdmi_resource_clear_clocks(struct hdmi_resources *res)\r\n{\r\nres->hdmi = ERR_PTR(-EINVAL);\r\nres->sclk_hdmi = ERR_PTR(-EINVAL);\r\nres->sclk_pixel = ERR_PTR(-EINVAL);\r\nres->sclk_hdmiphy = ERR_PTR(-EINVAL);\r\nres->hdmiphy = ERR_PTR(-EINVAL);\r\n}\r\nstatic void hdmi_resources_cleanup(struct hdmi_device *hdev)\r\n{\r\nstruct hdmi_resources *res = &hdev->res;\r\ndev_dbg(hdev->dev, "HDMI resource cleanup\n");\r\nif (res->regul_count)\r\nregulator_bulk_free(res->regul_count, res->regul_bulk);\r\nkfree(res->regul_bulk);\r\nif (!IS_ERR(res->hdmiphy))\r\nclk_put(res->hdmiphy);\r\nif (!IS_ERR(res->sclk_hdmiphy))\r\nclk_put(res->sclk_hdmiphy);\r\nif (!IS_ERR(res->sclk_pixel))\r\nclk_put(res->sclk_pixel);\r\nif (!IS_ERR(res->sclk_hdmi))\r\nclk_put(res->sclk_hdmi);\r\nif (!IS_ERR(res->hdmi))\r\nclk_put(res->hdmi);\r\nmemset(res, 0, sizeof(*res));\r\nhdmi_resource_clear_clocks(res);\r\n}\r\nstatic int hdmi_resources_init(struct hdmi_device *hdev)\r\n{\r\nstruct device *dev = hdev->dev;\r\nstruct hdmi_resources *res = &hdev->res;\r\nstatic char *supply[] = {\r\n"hdmi-en",\r\n"vdd",\r\n"vdd_osc",\r\n"vdd_pll",\r\n};\r\nint i, ret;\r\ndev_dbg(dev, "HDMI resource init\n");\r\nmemset(res, 0, sizeof(*res));\r\nhdmi_resource_clear_clocks(res);\r\nres->hdmi = clk_get(dev, "hdmi");\r\nif (IS_ERR(res->hdmi)) {\r\ndev_err(dev, "failed to get clock 'hdmi'\n");\r\ngoto fail;\r\n}\r\nres->sclk_hdmi = clk_get(dev, "sclk_hdmi");\r\nif (IS_ERR(res->sclk_hdmi)) {\r\ndev_err(dev, "failed to get clock 'sclk_hdmi'\n");\r\ngoto fail;\r\n}\r\nres->sclk_pixel = clk_get(dev, "sclk_pixel");\r\nif (IS_ERR(res->sclk_pixel)) {\r\ndev_err(dev, "failed to get clock 'sclk_pixel'\n");\r\ngoto fail;\r\n}\r\nres->sclk_hdmiphy = clk_get(dev, "sclk_hdmiphy");\r\nif (IS_ERR(res->sclk_hdmiphy)) {\r\ndev_err(dev, "failed to get clock 'sclk_hdmiphy'\n");\r\ngoto fail;\r\n}\r\nres->hdmiphy = clk_get(dev, "hdmiphy");\r\nif (IS_ERR(res->hdmiphy)) {\r\ndev_err(dev, "failed to get clock 'hdmiphy'\n");\r\ngoto fail;\r\n}\r\nres->regul_bulk = kcalloc(ARRAY_SIZE(supply),\r\nsizeof(res->regul_bulk[0]), GFP_KERNEL);\r\nif (!res->regul_bulk) {\r\ndev_err(dev, "failed to get memory for regulators\n");\r\ngoto fail;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(supply); ++i) {\r\nres->regul_bulk[i].supply = supply[i];\r\nres->regul_bulk[i].consumer = NULL;\r\n}\r\nret = regulator_bulk_get(dev, ARRAY_SIZE(supply), res->regul_bulk);\r\nif (ret) {\r\ndev_err(dev, "failed to get regulators\n");\r\ngoto fail;\r\n}\r\nres->regul_count = ARRAY_SIZE(supply);\r\nreturn 0;\r\nfail:\r\ndev_err(dev, "HDMI resource init - failed\n");\r\nhdmi_resources_cleanup(hdev);\r\nreturn -ENODEV;\r\n}\r\nstatic int hdmi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct i2c_adapter *adapter;\r\nstruct v4l2_subdev *sd;\r\nstruct hdmi_device *hdmi_dev = NULL;\r\nstruct s5p_hdmi_platform_data *pdata = dev->platform_data;\r\nint ret;\r\ndev_dbg(dev, "probe start\n");\r\nif (!pdata) {\r\ndev_err(dev, "platform data is missing\n");\r\nret = -ENODEV;\r\ngoto fail;\r\n}\r\nhdmi_dev = devm_kzalloc(&pdev->dev, sizeof(*hdmi_dev), GFP_KERNEL);\r\nif (!hdmi_dev) {\r\ndev_err(dev, "out of memory\n");\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nhdmi_dev->dev = dev;\r\nret = hdmi_resources_init(hdmi_dev);\r\nif (ret)\r\ngoto fail;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get memory resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail_init;\r\n}\r\nhdmi_dev->regs = devm_ioremap(&pdev->dev, res->start,\r\nresource_size(res));\r\nif (hdmi_dev->regs == NULL) {\r\ndev_err(dev, "register mapping failed.\n");\r\nret = -ENXIO;\r\ngoto fail_init;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get interrupt resource failed.\n");\r\nret = -ENXIO;\r\ngoto fail_init;\r\n}\r\nret = devm_request_irq(&pdev->dev, res->start, hdmi_irq_handler, 0,\r\n"hdmi", hdmi_dev);\r\nif (ret) {\r\ndev_err(dev, "request interrupt failed.\n");\r\ngoto fail_init;\r\n}\r\nhdmi_dev->irq = res->start;\r\nstrlcpy(hdmi_dev->v4l2_dev.name, dev_name(dev),\r\nsizeof(hdmi_dev->v4l2_dev.name));\r\nret = v4l2_device_register(NULL, &hdmi_dev->v4l2_dev);\r\nif (ret) {\r\ndev_err(dev, "could not register v4l2 device.\n");\r\ngoto fail_init;\r\n}\r\nif (!pdata->hdmiphy_info) {\r\ndev_err(dev, "hdmiphy info is missing in platform data\n");\r\nret = -ENXIO;\r\ngoto fail_vdev;\r\n}\r\nadapter = i2c_get_adapter(pdata->hdmiphy_bus);\r\nif (adapter == NULL) {\r\ndev_err(dev, "hdmiphy adapter request failed\n");\r\nret = -ENXIO;\r\ngoto fail_vdev;\r\n}\r\nhdmi_dev->phy_sd = v4l2_i2c_new_subdev_board(&hdmi_dev->v4l2_dev,\r\nadapter, pdata->hdmiphy_info, NULL);\r\ni2c_put_adapter(adapter);\r\nif (hdmi_dev->phy_sd == NULL) {\r\ndev_err(dev, "missing subdev for hdmiphy\n");\r\nret = -ENODEV;\r\ngoto fail_vdev;\r\n}\r\nif (pdata->mhl_info) {\r\nadapter = i2c_get_adapter(pdata->mhl_bus);\r\nif (adapter == NULL) {\r\ndev_err(dev, "MHL adapter request failed\n");\r\nret = -ENXIO;\r\ngoto fail_vdev;\r\n}\r\nhdmi_dev->mhl_sd = v4l2_i2c_new_subdev_board(\r\n&hdmi_dev->v4l2_dev, adapter,\r\npdata->mhl_info, NULL);\r\ni2c_put_adapter(adapter);\r\nif (hdmi_dev->mhl_sd == NULL) {\r\ndev_err(dev, "missing subdev for MHL\n");\r\nret = -ENODEV;\r\ngoto fail_vdev;\r\n}\r\n}\r\nclk_enable(hdmi_dev->res.hdmi);\r\npm_runtime_enable(dev);\r\nsd = &hdmi_dev->sd;\r\nv4l2_subdev_init(sd, &hdmi_sd_ops);\r\nsd->owner = THIS_MODULE;\r\nstrlcpy(sd->name, "s5p-hdmi", sizeof(sd->name));\r\nhdmi_dev->cur_timings =\r\nhdmi_timings[HDMI_DEFAULT_TIMINGS_IDX].dv_timings;\r\nhdmi_dev->cur_conf =\r\nhdmi_timings[HDMI_DEFAULT_TIMINGS_IDX].hdmi_timings;\r\nhdmi_dev->cur_conf_dirty = 1;\r\ndev_set_drvdata(dev, sd);\r\ndev_info(dev, "probe successful\n");\r\nreturn 0;\r\nfail_vdev:\r\nv4l2_device_unregister(&hdmi_dev->v4l2_dev);\r\nfail_init:\r\nhdmi_resources_cleanup(hdmi_dev);\r\nfail:\r\ndev_err(dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int hdmi_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct v4l2_subdev *sd = dev_get_drvdata(dev);\r\nstruct hdmi_device *hdmi_dev = sd_to_hdmi_dev(sd);\r\npm_runtime_disable(dev);\r\nclk_disable(hdmi_dev->res.hdmi);\r\nv4l2_device_unregister(&hdmi_dev->v4l2_dev);\r\ndisable_irq(hdmi_dev->irq);\r\nhdmi_resources_cleanup(hdmi_dev);\r\ndev_info(dev, "remove successful\n");\r\nreturn 0;\r\n}
