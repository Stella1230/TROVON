static int queue_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usba_ep *ep = inode->i_private;\r\nstruct usba_request *req, *req_copy;\r\nstruct list_head *queue_data;\r\nqueue_data = kmalloc(sizeof(*queue_data), GFP_KERNEL);\r\nif (!queue_data)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(queue_data);\r\nspin_lock_irq(&ep->udc->lock);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nreq_copy = kmemdup(req, sizeof(*req_copy), GFP_ATOMIC);\r\nif (!req_copy)\r\ngoto fail;\r\nlist_add_tail(&req_copy->queue, queue_data);\r\n}\r\nspin_unlock_irq(&ep->udc->lock);\r\nfile->private_data = queue_data;\r\nreturn 0;\r\nfail:\r\nspin_unlock_irq(&ep->udc->lock);\r\nlist_for_each_entry_safe(req, req_copy, queue_data, queue) {\r\nlist_del(&req->queue);\r\nkfree(req);\r\n}\r\nkfree(queue_data);\r\nreturn -ENOMEM;\r\n}\r\nstatic ssize_t queue_dbg_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct list_head *queue = file->private_data;\r\nstruct usba_request *req, *tmp_req;\r\nsize_t len, remaining, actual = 0;\r\nchar tmpbuf[38];\r\nif (!access_ok(VERIFY_WRITE, buf, nbytes))\r\nreturn -EFAULT;\r\nmutex_lock(&file_inode(file)->i_mutex);\r\nlist_for_each_entry_safe(req, tmp_req, queue, queue) {\r\nlen = snprintf(tmpbuf, sizeof(tmpbuf),\r\n"%8p %08x %c%c%c %5d %c%c%c\n",\r\nreq->req.buf, req->req.length,\r\nreq->req.no_interrupt ? 'i' : 'I',\r\nreq->req.zero ? 'Z' : 'z',\r\nreq->req.short_not_ok ? 's' : 'S',\r\nreq->req.status,\r\nreq->submitted ? 'F' : 'f',\r\nreq->using_dma ? 'D' : 'd',\r\nreq->last_transaction ? 'L' : 'l');\r\nlen = min(len, sizeof(tmpbuf));\r\nif (len > nbytes)\r\nbreak;\r\nlist_del(&req->queue);\r\nkfree(req);\r\nremaining = __copy_to_user(buf, tmpbuf, len);\r\nactual += len - remaining;\r\nif (remaining)\r\nbreak;\r\nnbytes -= len;\r\nbuf += len;\r\n}\r\nmutex_unlock(&file_inode(file)->i_mutex);\r\nreturn actual;\r\n}\r\nstatic int queue_dbg_release(struct inode *inode, struct file *file)\r\n{\r\nstruct list_head *queue_data = file->private_data;\r\nstruct usba_request *req, *tmp_req;\r\nlist_for_each_entry_safe(req, tmp_req, queue_data, queue) {\r\nlist_del(&req->queue);\r\nkfree(req);\r\n}\r\nkfree(queue_data);\r\nreturn 0;\r\n}\r\nstatic int regs_dbg_open(struct inode *inode, struct file *file)\r\n{\r\nstruct usba_udc *udc;\r\nunsigned int i;\r\nu32 *data;\r\nint ret = -ENOMEM;\r\nmutex_lock(&inode->i_mutex);\r\nudc = inode->i_private;\r\ndata = kmalloc(inode->i_size, GFP_KERNEL);\r\nif (!data)\r\ngoto out;\r\nspin_lock_irq(&udc->lock);\r\nfor (i = 0; i < inode->i_size / 4; i++)\r\ndata[i] = __raw_readl(udc->regs + i * 4);\r\nspin_unlock_irq(&udc->lock);\r\nfile->private_data = data;\r\nret = 0;\r\nout:\r\nmutex_unlock(&inode->i_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t regs_dbg_read(struct file *file, char __user *buf,\r\nsize_t nbytes, loff_t *ppos)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nint ret;\r\nmutex_lock(&inode->i_mutex);\r\nret = simple_read_from_buffer(buf, nbytes, ppos,\r\nfile->private_data,\r\nfile_inode(file)->i_size);\r\nmutex_unlock(&inode->i_mutex);\r\nreturn ret;\r\n}\r\nstatic int regs_dbg_release(struct inode *inode, struct file *file)\r\n{\r\nkfree(file->private_data);\r\nreturn 0;\r\n}\r\nstatic void usba_ep_init_debugfs(struct usba_udc *udc,\r\nstruct usba_ep *ep)\r\n{\r\nstruct dentry *ep_root;\r\nep_root = debugfs_create_dir(ep->ep.name, udc->debugfs_root);\r\nif (!ep_root)\r\ngoto err_root;\r\nep->debugfs_dir = ep_root;\r\nep->debugfs_queue = debugfs_create_file("queue", 0400, ep_root,\r\nep, &queue_dbg_fops);\r\nif (!ep->debugfs_queue)\r\ngoto err_queue;\r\nif (ep->can_dma) {\r\nep->debugfs_dma_status\r\n= debugfs_create_u32("dma_status", 0400, ep_root,\r\n&ep->last_dma_status);\r\nif (!ep->debugfs_dma_status)\r\ngoto err_dma_status;\r\n}\r\nif (ep_is_control(ep)) {\r\nep->debugfs_state\r\n= debugfs_create_u32("state", 0400, ep_root,\r\n&ep->state);\r\nif (!ep->debugfs_state)\r\ngoto err_state;\r\n}\r\nreturn;\r\nerr_state:\r\nif (ep->can_dma)\r\ndebugfs_remove(ep->debugfs_dma_status);\r\nerr_dma_status:\r\ndebugfs_remove(ep->debugfs_queue);\r\nerr_queue:\r\ndebugfs_remove(ep_root);\r\nerr_root:\r\ndev_err(&ep->udc->pdev->dev,\r\n"failed to create debugfs directory for %s\n", ep->ep.name);\r\n}\r\nstatic void usba_ep_cleanup_debugfs(struct usba_ep *ep)\r\n{\r\ndebugfs_remove(ep->debugfs_queue);\r\ndebugfs_remove(ep->debugfs_dma_status);\r\ndebugfs_remove(ep->debugfs_state);\r\ndebugfs_remove(ep->debugfs_dir);\r\nep->debugfs_dma_status = NULL;\r\nep->debugfs_dir = NULL;\r\n}\r\nstatic void usba_init_debugfs(struct usba_udc *udc)\r\n{\r\nstruct dentry *root, *regs;\r\nstruct resource *regs_resource;\r\nroot = debugfs_create_dir(udc->gadget.name, NULL);\r\nif (IS_ERR(root) || !root)\r\ngoto err_root;\r\nudc->debugfs_root = root;\r\nregs = debugfs_create_file("regs", 0400, root, udc, &regs_dbg_fops);\r\nif (!regs)\r\ngoto err_regs;\r\nregs_resource = platform_get_resource(udc->pdev, IORESOURCE_MEM,\r\nCTRL_IOMEM_ID);\r\nregs->d_inode->i_size = resource_size(regs_resource);\r\nudc->debugfs_regs = regs;\r\nusba_ep_init_debugfs(udc, to_usba_ep(udc->gadget.ep0));\r\nreturn;\r\nerr_regs:\r\ndebugfs_remove(root);\r\nerr_root:\r\nudc->debugfs_root = NULL;\r\ndev_err(&udc->pdev->dev, "debugfs is not available\n");\r\n}\r\nstatic void usba_cleanup_debugfs(struct usba_udc *udc)\r\n{\r\nusba_ep_cleanup_debugfs(to_usba_ep(udc->gadget.ep0));\r\ndebugfs_remove(udc->debugfs_regs);\r\ndebugfs_remove(udc->debugfs_root);\r\nudc->debugfs_regs = NULL;\r\nudc->debugfs_root = NULL;\r\n}\r\nstatic inline void usba_ep_init_debugfs(struct usba_udc *udc,\r\nstruct usba_ep *ep)\r\n{\r\n}\r\nstatic inline void usba_ep_cleanup_debugfs(struct usba_ep *ep)\r\n{\r\n}\r\nstatic inline void usba_init_debugfs(struct usba_udc *udc)\r\n{\r\n}\r\nstatic inline void usba_cleanup_debugfs(struct usba_udc *udc)\r\n{\r\n}\r\nstatic int vbus_is_present(struct usba_udc *udc)\r\n{\r\nif (gpio_is_valid(udc->vbus_pin))\r\nreturn gpio_get_value(udc->vbus_pin) ^ udc->vbus_pin_inverted;\r\nreturn 1;\r\n}\r\nstatic void toggle_bias(int is_on)\r\n{\r\nunsigned int uckr = at91_pmc_read(AT91_CKGR_UCKR);\r\nif (is_on)\r\nat91_pmc_write(AT91_CKGR_UCKR, uckr | AT91_PMC_BIASEN);\r\nelse\r\nat91_pmc_write(AT91_CKGR_UCKR, uckr & ~(AT91_PMC_BIASEN));\r\n}\r\nstatic void toggle_bias(int is_on)\r\n{\r\n}\r\nstatic void next_fifo_transaction(struct usba_ep *ep, struct usba_request *req)\r\n{\r\nunsigned int transaction_len;\r\ntransaction_len = req->req.length - req->req.actual;\r\nreq->last_transaction = 1;\r\nif (transaction_len > ep->ep.maxpacket) {\r\ntransaction_len = ep->ep.maxpacket;\r\nreq->last_transaction = 0;\r\n} else if (transaction_len == ep->ep.maxpacket && req->req.zero)\r\nreq->last_transaction = 0;\r\nDBG(DBG_QUEUE, "%s: submit_transaction, req %p (length %d)%s\n",\r\nep->ep.name, req, transaction_len,\r\nreq->last_transaction ? ", done" : "");\r\nmemcpy_toio(ep->fifo, req->req.buf + req->req.actual, transaction_len);\r\nusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\r\nreq->req.actual += transaction_len;\r\n}\r\nstatic void submit_request(struct usba_ep *ep, struct usba_request *req)\r\n{\r\nDBG(DBG_QUEUE, "%s: submit_request: req %p (length %d)\n",\r\nep->ep.name, req, req->req.length);\r\nreq->req.actual = 0;\r\nreq->submitted = 1;\r\nif (req->using_dma) {\r\nif (req->req.length == 0) {\r\nusba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);\r\nreturn;\r\n}\r\nif (req->req.zero)\r\nusba_ep_writel(ep, CTL_ENB, USBA_SHORT_PACKET);\r\nelse\r\nusba_ep_writel(ep, CTL_DIS, USBA_SHORT_PACKET);\r\nusba_dma_writel(ep, ADDRESS, req->req.dma);\r\nusba_dma_writel(ep, CONTROL, req->ctrl);\r\n} else {\r\nnext_fifo_transaction(ep, req);\r\nif (req->last_transaction) {\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);\r\nusba_ep_writel(ep, CTL_ENB, USBA_TX_COMPLETE);\r\n} else {\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\r\nusba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);\r\n}\r\n}\r\n}\r\nstatic void submit_next_request(struct usba_ep *ep)\r\n{\r\nstruct usba_request *req;\r\nif (list_empty(&ep->queue)) {\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY | USBA_RX_BK_RDY);\r\nreturn;\r\n}\r\nreq = list_entry(ep->queue.next, struct usba_request, queue);\r\nif (!req->submitted)\r\nsubmit_request(ep, req);\r\n}\r\nstatic void send_status(struct usba_udc *udc, struct usba_ep *ep)\r\n{\r\nep->state = STATUS_STAGE_IN;\r\nusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\r\nusba_ep_writel(ep, CTL_ENB, USBA_TX_COMPLETE);\r\n}\r\nstatic void receive_data(struct usba_ep *ep)\r\n{\r\nstruct usba_udc *udc = ep->udc;\r\nstruct usba_request *req;\r\nunsigned long status;\r\nunsigned int bytecount, nr_busy;\r\nint is_complete = 0;\r\nstatus = usba_ep_readl(ep, STA);\r\nnr_busy = USBA_BFEXT(BUSY_BANKS, status);\r\nDBG(DBG_QUEUE, "receive data: nr_busy=%u\n", nr_busy);\r\nwhile (nr_busy > 0) {\r\nif (list_empty(&ep->queue)) {\r\nusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\r\nbreak;\r\n}\r\nreq = list_entry(ep->queue.next,\r\nstruct usba_request, queue);\r\nbytecount = USBA_BFEXT(BYTE_COUNT, status);\r\nif (status & (1 << 31))\r\nis_complete = 1;\r\nif (req->req.actual + bytecount >= req->req.length) {\r\nis_complete = 1;\r\nbytecount = req->req.length - req->req.actual;\r\n}\r\nmemcpy_fromio(req->req.buf + req->req.actual,\r\nep->fifo, bytecount);\r\nreq->req.actual += bytecount;\r\nusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\r\nif (is_complete) {\r\nDBG(DBG_QUEUE, "%s: request done\n", ep->ep.name);\r\nreq->req.status = 0;\r\nlist_del_init(&req->queue);\r\nusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\r\nspin_unlock(&udc->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\n}\r\nstatus = usba_ep_readl(ep, STA);\r\nnr_busy = USBA_BFEXT(BUSY_BANKS, status);\r\nif (is_complete && ep_is_control(ep)) {\r\nsend_status(udc, ep);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void\r\nrequest_complete(struct usba_ep *ep, struct usba_request *req, int status)\r\n{\r\nstruct usba_udc *udc = ep->udc;\r\nWARN_ON(!list_empty(&req->queue));\r\nif (req->req.status == -EINPROGRESS)\r\nreq->req.status = status;\r\nif (req->using_dma)\r\nusb_gadget_unmap_request(&udc->gadget, &req->req, ep->is_in);\r\nDBG(DBG_GADGET | DBG_REQ,\r\n"%s: req %p complete: status %d, actual %u\n",\r\nep->ep.name, req, req->req.status, req->req.actual);\r\nspin_unlock(&udc->lock);\r\nreq->req.complete(&ep->ep, &req->req);\r\nspin_lock(&udc->lock);\r\n}\r\nstatic void\r\nrequest_complete_list(struct usba_ep *ep, struct list_head *list, int status)\r\n{\r\nstruct usba_request *req, *tmp_req;\r\nlist_for_each_entry_safe(req, tmp_req, list, queue) {\r\nlist_del_init(&req->queue);\r\nrequest_complete(ep, req, status);\r\n}\r\n}\r\nstatic int\r\nusba_ep_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nstruct usba_udc *udc = ep->udc;\r\nunsigned long flags, ept_cfg, maxpacket;\r\nunsigned int nr_trans;\r\nDBG(DBG_GADGET, "%s: ep_enable: desc=%p\n", ep->ep.name, desc);\r\nmaxpacket = usb_endpoint_maxp(desc) & 0x7ff;\r\nif (((desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK) != ep->index)\r\n|| ep->index == 0\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT\r\n|| maxpacket == 0\r\n|| maxpacket > ep->fifo_size) {\r\nDBG(DBG_ERR, "ep_enable: Invalid argument");\r\nreturn -EINVAL;\r\n}\r\nep->is_isoc = 0;\r\nep->is_in = 0;\r\nif (maxpacket <= 8)\r\nept_cfg = USBA_BF(EPT_SIZE, USBA_EPT_SIZE_8);\r\nelse\r\nept_cfg = USBA_BF(EPT_SIZE, fls(maxpacket - 1) - 3);\r\nDBG(DBG_HW, "%s: EPT_SIZE = %lu (maxpacket = %lu)\n",\r\nep->ep.name, ept_cfg, maxpacket);\r\nif (usb_endpoint_dir_in(desc)) {\r\nep->is_in = 1;\r\nept_cfg |= USBA_EPT_DIR_IN;\r\n}\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL);\r\nept_cfg |= USBA_BF(BK_NUMBER, USBA_BK_NUMBER_ONE);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nif (!ep->can_isoc) {\r\nDBG(DBG_ERR, "ep_enable: %s is not isoc capable\n",\r\nep->ep.name);\r\nreturn -EINVAL;\r\n}\r\nnr_trans = ((usb_endpoint_maxp(desc) >> 11) & 3) + 1;\r\nif (nr_trans > 3)\r\nreturn -EINVAL;\r\nep->is_isoc = 1;\r\nept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_ISO);\r\nif (nr_trans > 1 && ep->nr_banks == 3)\r\nept_cfg |= USBA_BF(BK_NUMBER, USBA_BK_NUMBER_TRIPLE);\r\nelse\r\nept_cfg |= USBA_BF(BK_NUMBER, USBA_BK_NUMBER_DOUBLE);\r\nept_cfg |= USBA_BF(NB_TRANS, nr_trans);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK);\r\nept_cfg |= USBA_BF(BK_NUMBER, USBA_BK_NUMBER_DOUBLE);\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nept_cfg |= USBA_BF(EPT_TYPE, USBA_EPT_TYPE_INT);\r\nept_cfg |= USBA_BF(BK_NUMBER, USBA_BK_NUMBER_DOUBLE);\r\nbreak;\r\n}\r\nspin_lock_irqsave(&ep->udc->lock, flags);\r\nep->ep.desc = desc;\r\nep->ep.maxpacket = maxpacket;\r\nusba_ep_writel(ep, CFG, ept_cfg);\r\nusba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);\r\nif (ep->can_dma) {\r\nu32 ctrl;\r\nusba_writel(udc, INT_ENB,\r\n(usba_readl(udc, INT_ENB)\r\n| USBA_BF(EPT_INT, 1 << ep->index)\r\n| USBA_BF(DMA_INT, 1 << ep->index)));\r\nctrl = USBA_AUTO_VALID | USBA_INTDIS_DMA;\r\nusba_ep_writel(ep, CTL_ENB, ctrl);\r\n} else {\r\nusba_writel(udc, INT_ENB,\r\n(usba_readl(udc, INT_ENB)\r\n| USBA_BF(EPT_INT, 1 << ep->index)));\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nDBG(DBG_HW, "EPT_CFG%d after init: %#08lx\n", ep->index,\r\n(unsigned long)usba_ep_readl(ep, CFG));\r\nDBG(DBG_HW, "INT_ENB after init: %#08lx\n",\r\n(unsigned long)usba_readl(udc, INT_ENB));\r\nreturn 0;\r\n}\r\nstatic int usba_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nstruct usba_udc *udc = ep->udc;\r\nLIST_HEAD(req_list);\r\nunsigned long flags;\r\nDBG(DBG_GADGET, "ep_disable: %s\n", ep->ep.name);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!ep->ep.desc) {\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN)\r\nDBG(DBG_ERR, "ep_disable: %s not enabled\n",\r\nep->ep.name);\r\nreturn -EINVAL;\r\n}\r\nep->ep.desc = NULL;\r\nlist_splice_init(&ep->queue, &req_list);\r\nif (ep->can_dma) {\r\nusba_dma_writel(ep, CONTROL, 0);\r\nusba_dma_writel(ep, ADDRESS, 0);\r\nusba_dma_readl(ep, STATUS);\r\n}\r\nusba_ep_writel(ep, CTL_DIS, USBA_EPT_ENABLE);\r\nusba_writel(udc, INT_ENB,\r\nusba_readl(udc, INT_ENB)\r\n& ~USBA_BF(EPT_INT, 1 << ep->index));\r\nrequest_complete_list(ep, &req_list, -ESHUTDOWN);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\nusba_ep_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)\r\n{\r\nstruct usba_request *req;\r\nDBG(DBG_GADGET, "ep_alloc_request: %p, 0x%x\n", _ep, gfp_flags);\r\nreq = kzalloc(sizeof(*req), gfp_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void\r\nusba_ep_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct usba_request *req = to_usba_req(_req);\r\nDBG(DBG_GADGET, "ep_free_request: %p, %p\n", _ep, _req);\r\nkfree(req);\r\n}\r\nstatic int queue_dma(struct usba_udc *udc, struct usba_ep *ep,\r\nstruct usba_request *req, gfp_t gfp_flags)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nDBG(DBG_DMA, "%s: req l/%u d/%08x %c%c%c\n",\r\nep->ep.name, req->req.length, req->req.dma,\r\nreq->req.zero ? 'Z' : 'z',\r\nreq->req.short_not_ok ? 'S' : 's',\r\nreq->req.no_interrupt ? 'I' : 'i');\r\nif (req->req.length > 0x10000) {\r\nDBG(DBG_ERR, "invalid request length %u\n", req->req.length);\r\nreturn -EINVAL;\r\n}\r\nret = usb_gadget_map_request(&udc->gadget, &req->req, ep->is_in);\r\nif (ret)\r\nreturn ret;\r\nreq->using_dma = 1;\r\nreq->ctrl = USBA_BF(DMA_BUF_LEN, req->req.length)\r\n| USBA_DMA_CH_EN | USBA_DMA_END_BUF_IE\r\n| USBA_DMA_END_TR_EN | USBA_DMA_END_TR_IE;\r\nif (ep->is_in)\r\nreq->ctrl |= USBA_DMA_END_BUF_EN;\r\nret = -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (ep->ep.desc) {\r\nif (list_empty(&ep->queue))\r\nsubmit_request(ep, req);\r\nlist_add_tail(&req->queue, &ep->queue);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nusba_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)\r\n{\r\nstruct usba_request *req = to_usba_req(_req);\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nstruct usba_udc *udc = ep->udc;\r\nunsigned long flags;\r\nint ret;\r\nDBG(DBG_GADGET | DBG_QUEUE | DBG_REQ, "%s: queue req %p, len %u\n",\r\nep->ep.name, req, _req->length);\r\nif (!udc->driver || udc->gadget.speed == USB_SPEED_UNKNOWN ||\r\n!ep->ep.desc)\r\nreturn -ESHUTDOWN;\r\nreq->submitted = 0;\r\nreq->using_dma = 0;\r\nreq->last_transaction = 0;\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\nif (ep->can_dma)\r\nreturn queue_dma(udc, ep, req, gfp_flags);\r\nret = -ESHUTDOWN;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (ep->ep.desc) {\r\nlist_add_tail(&req->queue, &ep->queue);\r\nif ((!ep_is_control(ep) && ep->is_in) ||\r\n(ep_is_control(ep)\r\n&& (ep->state == DATA_STAGE_IN\r\n|| ep->state == STATUS_STAGE_IN)))\r\nusba_ep_writel(ep, CTL_ENB, USBA_TX_PK_RDY);\r\nelse\r\nusba_ep_writel(ep, CTL_ENB, USBA_RX_BK_RDY);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void\r\nusba_update_req(struct usba_ep *ep, struct usba_request *req, u32 status)\r\n{\r\nreq->req.actual = req->req.length - USBA_BFEXT(DMA_BUF_LEN, status);\r\n}\r\nstatic int stop_dma(struct usba_ep *ep, u32 *pstatus)\r\n{\r\nunsigned int timeout;\r\nu32 status;\r\nusba_dma_writel(ep, CONTROL, 0);\r\nfor (timeout = 40; timeout; --timeout) {\r\nstatus = usba_dma_readl(ep, STATUS);\r\nif (!(status & USBA_DMA_CH_EN))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (pstatus)\r\n*pstatus = status;\r\nif (timeout == 0) {\r\ndev_err(&ep->udc->pdev->dev,\r\n"%s: timed out waiting for DMA FIFO to empty\n",\r\nep->ep.name);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int usba_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nstruct usba_udc *udc = ep->udc;\r\nstruct usba_request *req = to_usba_req(_req);\r\nunsigned long flags;\r\nu32 status;\r\nDBG(DBG_GADGET | DBG_QUEUE, "ep_dequeue: %s, req %p\n",\r\nep->ep.name, req);\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (req->using_dma) {\r\nif (ep->queue.next == &req->queue) {\r\nstatus = usba_dma_readl(ep, STATUS);\r\nif (status & USBA_DMA_CH_EN)\r\nstop_dma(ep, &status);\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\r\nep->last_dma_status = status;\r\n#endif\r\nusba_writel(udc, EPT_RST, 1 << ep->index);\r\nusba_update_req(ep, req, status);\r\n}\r\n}\r\nlist_del_init(&req->queue);\r\nrequest_complete(ep, req, -ECONNRESET);\r\nsubmit_next_request(ep);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int usba_ep_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nstruct usba_udc *udc = ep->udc;\r\nunsigned long flags;\r\nint ret = 0;\r\nDBG(DBG_GADGET, "endpoint %s: %s HALT\n", ep->ep.name,\r\nvalue ? "set" : "clear");\r\nif (!ep->ep.desc) {\r\nDBG(DBG_ERR, "Attempted to halt uninitialized ep %s\n",\r\nep->ep.name);\r\nreturn -ENODEV;\r\n}\r\nif (ep->is_isoc) {\r\nDBG(DBG_ERR, "Attempted to halt isochronous ep %s\n",\r\nep->ep.name);\r\nreturn -ENOTTY;\r\n}\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (!list_empty(&ep->queue)\r\n|| ((value && ep->is_in && (usba_ep_readl(ep, STA)\r\n& USBA_BF(BUSY_BANKS, -1L))))) {\r\nret = -EAGAIN;\r\n} else {\r\nif (value)\r\nusba_ep_writel(ep, SET_STA, USBA_FORCE_STALL);\r\nelse\r\nusba_ep_writel(ep, CLR_STA,\r\nUSBA_FORCE_STALL | USBA_TOGGLE_CLR);\r\nusba_ep_readl(ep, STA);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int usba_ep_fifo_status(struct usb_ep *_ep)\r\n{\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nreturn USBA_BFEXT(BYTE_COUNT, usba_ep_readl(ep, STA));\r\n}\r\nstatic void usba_ep_fifo_flush(struct usb_ep *_ep)\r\n{\r\nstruct usba_ep *ep = to_usba_ep(_ep);\r\nstruct usba_udc *udc = ep->udc;\r\nusba_writel(udc, EPT_RST, 1 << ep->index);\r\n}\r\nstatic int usba_udc_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct usba_udc *udc = to_usba_udc(gadget);\r\nreturn USBA_BFEXT(FRAME_NUMBER, usba_readl(udc, FNUM));\r\n}\r\nstatic int usba_udc_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct usba_udc *udc = to_usba_udc(gadget);\r\nunsigned long flags;\r\nu32 ctrl;\r\nint ret = -EINVAL;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (udc->devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP)) {\r\nctrl = usba_readl(udc, CTRL);\r\nusba_writel(udc, CTRL, ctrl | USBA_REMOTE_WAKE_UP);\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int\r\nusba_udc_set_selfpowered(struct usb_gadget *gadget, int is_selfpowered)\r\n{\r\nstruct usba_udc *udc = to_usba_udc(gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (is_selfpowered)\r\nudc->devstatus |= 1 << USB_DEVICE_SELF_POWERED;\r\nelse\r\nudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void nop_release(struct device *dev)\r\n{\r\n}\r\nstatic void reset_all_endpoints(struct usba_udc *udc)\r\n{\r\nstruct usba_ep *ep;\r\nstruct usba_request *req, *tmp_req;\r\nusba_writel(udc, EPT_RST, ~0UL);\r\nep = to_usba_ep(udc->gadget.ep0);\r\nlist_for_each_entry_safe(req, tmp_req, &ep->queue, queue) {\r\nlist_del_init(&req->queue);\r\nrequest_complete(ep, req, -ECONNRESET);\r\n}\r\nlist_for_each_entry(ep, &udc->gadget.ep_list, ep.ep_list) {\r\nif (ep->ep.desc) {\r\nspin_unlock(&udc->lock);\r\nusba_ep_disable(&ep->ep);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\n}\r\nstatic struct usba_ep *get_ep_by_addr(struct usba_udc *udc, u16 wIndex)\r\n{\r\nstruct usba_ep *ep;\r\nif ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)\r\nreturn to_usba_ep(udc->gadget.ep0);\r\nlist_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {\r\nu8 bEndpointAddress;\r\nif (!ep->ep.desc)\r\ncontinue;\r\nbEndpointAddress = ep->ep.desc->bEndpointAddress;\r\nif ((wIndex ^ bEndpointAddress) & USB_DIR_IN)\r\ncontinue;\r\nif ((bEndpointAddress & USB_ENDPOINT_NUMBER_MASK)\r\n== (wIndex & USB_ENDPOINT_NUMBER_MASK))\r\nreturn ep;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void set_protocol_stall(struct usba_udc *udc, struct usba_ep *ep)\r\n{\r\nusba_ep_writel(ep, SET_STA, USBA_FORCE_STALL);\r\nep->state = WAIT_FOR_SETUP;\r\n}\r\nstatic inline int is_stalled(struct usba_udc *udc, struct usba_ep *ep)\r\n{\r\nif (usba_ep_readl(ep, STA) & USBA_FORCE_STALL)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic inline void set_address(struct usba_udc *udc, unsigned int addr)\r\n{\r\nu32 regval;\r\nDBG(DBG_BUS, "setting address %u...\n", addr);\r\nregval = usba_readl(udc, CTRL);\r\nregval = USBA_BFINS(DEV_ADDR, addr, regval);\r\nusba_writel(udc, CTRL, regval);\r\n}\r\nstatic int do_test_mode(struct usba_udc *udc)\r\n{\r\nstatic const char test_packet_buffer[] = {\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,\r\n0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE,\r\n0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\r\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\r\n0x7F, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD,\r\n0xFC, 0x7E, 0xBF, 0xDF, 0xEF, 0xF7, 0xFB, 0xFD, 0x7E\r\n};\r\nstruct usba_ep *ep;\r\nstruct device *dev = &udc->pdev->dev;\r\nint test_mode;\r\ntest_mode = udc->test_mode;\r\nreset_all_endpoints(udc);\r\nswitch (test_mode) {\r\ncase 0x0100:\r\nusba_writel(udc, TST, USBA_TST_J_MODE);\r\ndev_info(dev, "Entering Test_J mode...\n");\r\nbreak;\r\ncase 0x0200:\r\nusba_writel(udc, TST, USBA_TST_K_MODE);\r\ndev_info(dev, "Entering Test_K mode...\n");\r\nbreak;\r\ncase 0x0300:\r\nep = &udc->usba_ep[0];\r\nusba_writel(udc, TST,\r\nUSBA_BF(SPEED_CFG, USBA_SPEED_CFG_FORCE_HIGH));\r\nusba_ep_writel(ep, CFG,\r\nUSBA_BF(EPT_SIZE, USBA_EPT_SIZE_64)\r\n| USBA_EPT_DIR_IN\r\n| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK)\r\n| USBA_BF(BK_NUMBER, 1));\r\nif (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED)) {\r\nset_protocol_stall(udc, ep);\r\ndev_err(dev, "Test_SE0_NAK: ep0 not mapped\n");\r\n} else {\r\nusba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);\r\ndev_info(dev, "Entering Test_SE0_NAK mode...\n");\r\n}\r\nbreak;\r\ncase 0x0400:\r\nep = &udc->usba_ep[0];\r\nusba_ep_writel(ep, CFG,\r\nUSBA_BF(EPT_SIZE, USBA_EPT_SIZE_64)\r\n| USBA_EPT_DIR_IN\r\n| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_BULK)\r\n| USBA_BF(BK_NUMBER, 1));\r\nif (!(usba_ep_readl(ep, CFG) & USBA_EPT_MAPPED)) {\r\nset_protocol_stall(udc, ep);\r\ndev_err(dev, "Test_Packet: ep0 not mapped\n");\r\n} else {\r\nusba_ep_writel(ep, CTL_ENB, USBA_EPT_ENABLE);\r\nusba_writel(udc, TST, USBA_TST_PKT_MODE);\r\nmemcpy_toio(ep->fifo, test_packet_buffer,\r\nsizeof(test_packet_buffer));\r\nusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\r\ndev_info(dev, "Entering Test_Packet mode...\n");\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Invalid test mode: 0x%04x\n", test_mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool feature_is_dev_remote_wakeup(struct usb_ctrlrequest *crq)\r\n{\r\nif (crq->wValue == cpu_to_le16(USB_DEVICE_REMOTE_WAKEUP))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool feature_is_dev_test_mode(struct usb_ctrlrequest *crq)\r\n{\r\nif (crq->wValue == cpu_to_le16(USB_DEVICE_TEST_MODE))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool feature_is_ep_halt(struct usb_ctrlrequest *crq)\r\n{\r\nif (crq->wValue == cpu_to_le16(USB_ENDPOINT_HALT))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int handle_ep0_setup(struct usba_udc *udc, struct usba_ep *ep,\r\nstruct usb_ctrlrequest *crq)\r\n{\r\nint retval = 0;\r\nswitch (crq->bRequest) {\r\ncase USB_REQ_GET_STATUS: {\r\nu16 status;\r\nif (crq->bRequestType == (USB_DIR_IN | USB_RECIP_DEVICE)) {\r\nstatus = cpu_to_le16(udc->devstatus);\r\n} else if (crq->bRequestType\r\n== (USB_DIR_IN | USB_RECIP_INTERFACE)) {\r\nstatus = cpu_to_le16(0);\r\n} else if (crq->bRequestType\r\n== (USB_DIR_IN | USB_RECIP_ENDPOINT)) {\r\nstruct usba_ep *target;\r\ntarget = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));\r\nif (!target)\r\ngoto stall;\r\nstatus = 0;\r\nif (is_stalled(udc, target))\r\nstatus |= cpu_to_le16(1);\r\n} else\r\ngoto delegate;\r\nif (crq->wLength != cpu_to_le16(sizeof(status)))\r\ngoto stall;\r\nep->state = DATA_STAGE_IN;\r\n__raw_writew(status, ep->fifo);\r\nusba_ep_writel(ep, SET_STA, USBA_TX_PK_RDY);\r\nbreak;\r\n}\r\ncase USB_REQ_CLEAR_FEATURE: {\r\nif (crq->bRequestType == USB_RECIP_DEVICE) {\r\nif (feature_is_dev_remote_wakeup(crq))\r\nudc->devstatus\r\n&= ~(1 << USB_DEVICE_REMOTE_WAKEUP);\r\nelse\r\ngoto stall;\r\n} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {\r\nstruct usba_ep *target;\r\nif (crq->wLength != cpu_to_le16(0)\r\n|| !feature_is_ep_halt(crq))\r\ngoto stall;\r\ntarget = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));\r\nif (!target)\r\ngoto stall;\r\nusba_ep_writel(target, CLR_STA, USBA_FORCE_STALL);\r\nif (target->index != 0)\r\nusba_ep_writel(target, CLR_STA,\r\nUSBA_TOGGLE_CLR);\r\n} else {\r\ngoto delegate;\r\n}\r\nsend_status(udc, ep);\r\nbreak;\r\n}\r\ncase USB_REQ_SET_FEATURE: {\r\nif (crq->bRequestType == USB_RECIP_DEVICE) {\r\nif (feature_is_dev_test_mode(crq)) {\r\nsend_status(udc, ep);\r\nep->state = STATUS_STAGE_TEST;\r\nudc->test_mode = le16_to_cpu(crq->wIndex);\r\nreturn 0;\r\n} else if (feature_is_dev_remote_wakeup(crq)) {\r\nudc->devstatus |= 1 << USB_DEVICE_REMOTE_WAKEUP;\r\n} else {\r\ngoto stall;\r\n}\r\n} else if (crq->bRequestType == USB_RECIP_ENDPOINT) {\r\nstruct usba_ep *target;\r\nif (crq->wLength != cpu_to_le16(0)\r\n|| !feature_is_ep_halt(crq))\r\ngoto stall;\r\ntarget = get_ep_by_addr(udc, le16_to_cpu(crq->wIndex));\r\nif (!target)\r\ngoto stall;\r\nusba_ep_writel(target, SET_STA, USBA_FORCE_STALL);\r\n} else\r\ngoto delegate;\r\nsend_status(udc, ep);\r\nbreak;\r\n}\r\ncase USB_REQ_SET_ADDRESS:\r\nif (crq->bRequestType != (USB_DIR_OUT | USB_RECIP_DEVICE))\r\ngoto delegate;\r\nset_address(udc, le16_to_cpu(crq->wValue));\r\nsend_status(udc, ep);\r\nep->state = STATUS_STAGE_ADDR;\r\nbreak;\r\ndefault:\r\ndelegate:\r\nspin_unlock(&udc->lock);\r\nretval = udc->driver->setup(&udc->gadget, crq);\r\nspin_lock(&udc->lock);\r\n}\r\nreturn retval;\r\nstall:\r\npr_err("udc: %s: Invalid setup request: %02x.%02x v%04x i%04x l%d, "\r\n"halting endpoint...\n",\r\nep->ep.name, crq->bRequestType, crq->bRequest,\r\nle16_to_cpu(crq->wValue), le16_to_cpu(crq->wIndex),\r\nle16_to_cpu(crq->wLength));\r\nset_protocol_stall(udc, ep);\r\nreturn -1;\r\n}\r\nstatic void usba_control_irq(struct usba_udc *udc, struct usba_ep *ep)\r\n{\r\nstruct usba_request *req;\r\nu32 epstatus;\r\nu32 epctrl;\r\nrestart:\r\nepstatus = usba_ep_readl(ep, STA);\r\nepctrl = usba_ep_readl(ep, CTL);\r\nDBG(DBG_INT, "%s [%d]: s/%08x c/%08x\n",\r\nep->ep.name, ep->state, epstatus, epctrl);\r\nreq = NULL;\r\nif (!list_empty(&ep->queue))\r\nreq = list_entry(ep->queue.next,\r\nstruct usba_request, queue);\r\nif ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {\r\nif (req->submitted)\r\nnext_fifo_transaction(ep, req);\r\nelse\r\nsubmit_request(ep, req);\r\nif (req->last_transaction) {\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);\r\nusba_ep_writel(ep, CTL_ENB, USBA_TX_COMPLETE);\r\n}\r\ngoto restart;\r\n}\r\nif ((epstatus & epctrl) & USBA_TX_COMPLETE) {\r\nusba_ep_writel(ep, CLR_STA, USBA_TX_COMPLETE);\r\nswitch (ep->state) {\r\ncase DATA_STAGE_IN:\r\nusba_ep_writel(ep, CTL_ENB, USBA_RX_BK_RDY);\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\r\nep->state = STATUS_STAGE_OUT;\r\nbreak;\r\ncase STATUS_STAGE_ADDR:\r\nusba_writel(udc, CTRL, (usba_readl(udc, CTRL)\r\n| USBA_FADDR_EN));\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\r\nep->state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase STATUS_STAGE_IN:\r\nif (req) {\r\nlist_del_init(&req->queue);\r\nrequest_complete(ep, req, 0);\r\nsubmit_next_request(ep);\r\n}\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\r\nep->state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase STATUS_STAGE_TEST:\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_COMPLETE);\r\nep->state = WAIT_FOR_SETUP;\r\nif (do_test_mode(udc))\r\nset_protocol_stall(udc, ep);\r\nbreak;\r\ndefault:\r\npr_err("udc: %s: TXCOMP: Invalid endpoint state %d, "\r\n"halting endpoint...\n",\r\nep->ep.name, ep->state);\r\nset_protocol_stall(udc, ep);\r\nbreak;\r\n}\r\ngoto restart;\r\n}\r\nif ((epstatus & epctrl) & USBA_RX_BK_RDY) {\r\nswitch (ep->state) {\r\ncase STATUS_STAGE_OUT:\r\nusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\r\nusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\r\nif (req) {\r\nlist_del_init(&req->queue);\r\nrequest_complete(ep, req, 0);\r\n}\r\nep->state = WAIT_FOR_SETUP;\r\nbreak;\r\ncase DATA_STAGE_OUT:\r\nreceive_data(ep);\r\nbreak;\r\ndefault:\r\nusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\r\nusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\r\npr_err("udc: %s: RXRDY: Invalid endpoint state %d, "\r\n"halting endpoint...\n",\r\nep->ep.name, ep->state);\r\nset_protocol_stall(udc, ep);\r\nbreak;\r\n}\r\ngoto restart;\r\n}\r\nif (epstatus & USBA_RX_SETUP) {\r\nunion {\r\nstruct usb_ctrlrequest crq;\r\nunsigned long data[2];\r\n} crq;\r\nunsigned int pkt_len;\r\nint ret;\r\nif (ep->state != WAIT_FOR_SETUP) {\r\nint status = -EPROTO;\r\nif (ep->state == STATUS_STAGE_OUT\r\n|| ep->state == STATUS_STAGE_IN) {\r\nusba_ep_writel(ep, CTL_DIS, USBA_RX_BK_RDY);\r\nstatus = 0;\r\n}\r\nif (req) {\r\nlist_del_init(&req->queue);\r\nrequest_complete(ep, req, status);\r\n}\r\n}\r\npkt_len = USBA_BFEXT(BYTE_COUNT, usba_ep_readl(ep, STA));\r\nDBG(DBG_HW, "Packet length: %u\n", pkt_len);\r\nif (pkt_len != sizeof(crq)) {\r\npr_warning("udc: Invalid packet length %u "\r\n"(expected %zu)\n", pkt_len, sizeof(crq));\r\nset_protocol_stall(udc, ep);\r\nreturn;\r\n}\r\nDBG(DBG_FIFO, "Copying ctrl request from 0x%p:\n", ep->fifo);\r\nmemcpy_fromio(crq.data, ep->fifo, sizeof(crq));\r\nusba_ep_writel(ep, CLR_STA, USBA_RX_SETUP);\r\nif (crq.crq.bRequestType & USB_DIR_IN) {\r\nep->state = DATA_STAGE_IN;\r\n} else {\r\nif (crq.crq.wLength != cpu_to_le16(0))\r\nep->state = DATA_STAGE_OUT;\r\nelse\r\nep->state = STATUS_STAGE_IN;\r\n}\r\nret = -1;\r\nif (ep->index == 0)\r\nret = handle_ep0_setup(udc, ep, &crq.crq);\r\nelse {\r\nspin_unlock(&udc->lock);\r\nret = udc->driver->setup(&udc->gadget, &crq.crq);\r\nspin_lock(&udc->lock);\r\n}\r\nDBG(DBG_BUS, "req %02x.%02x, length %d, state %d, ret %d\n",\r\ncrq.crq.bRequestType, crq.crq.bRequest,\r\nle16_to_cpu(crq.crq.wLength), ep->state, ret);\r\nif (ret < 0) {\r\nset_protocol_stall(udc, ep);\r\n}\r\n}\r\n}\r\nstatic void usba_ep_irq(struct usba_udc *udc, struct usba_ep *ep)\r\n{\r\nstruct usba_request *req;\r\nu32 epstatus;\r\nu32 epctrl;\r\nepstatus = usba_ep_readl(ep, STA);\r\nepctrl = usba_ep_readl(ep, CTL);\r\nDBG(DBG_INT, "%s: interrupt, status: 0x%08x\n", ep->ep.name, epstatus);\r\nwhile ((epctrl & USBA_TX_PK_RDY) && !(epstatus & USBA_TX_PK_RDY)) {\r\nDBG(DBG_BUS, "%s: TX PK ready\n", ep->ep.name);\r\nif (list_empty(&ep->queue)) {\r\ndev_warn(&udc->pdev->dev, "ep_irq: queue empty\n");\r\nusba_ep_writel(ep, CTL_DIS, USBA_TX_PK_RDY);\r\nreturn;\r\n}\r\nreq = list_entry(ep->queue.next, struct usba_request, queue);\r\nif (req->using_dma) {\r\nusba_ep_writel(ep, SET_STA,\r\nUSBA_TX_PK_RDY);\r\nusba_ep_writel(ep, CTL_DIS,\r\nUSBA_TX_PK_RDY);\r\nlist_del_init(&req->queue);\r\nsubmit_next_request(ep);\r\nrequest_complete(ep, req, 0);\r\n} else {\r\nif (req->submitted)\r\nnext_fifo_transaction(ep, req);\r\nelse\r\nsubmit_request(ep, req);\r\nif (req->last_transaction) {\r\nlist_del_init(&req->queue);\r\nsubmit_next_request(ep);\r\nrequest_complete(ep, req, 0);\r\n}\r\n}\r\nepstatus = usba_ep_readl(ep, STA);\r\nepctrl = usba_ep_readl(ep, CTL);\r\n}\r\nif ((epstatus & epctrl) & USBA_RX_BK_RDY) {\r\nDBG(DBG_BUS, "%s: RX data ready\n", ep->ep.name);\r\nreceive_data(ep);\r\nusba_ep_writel(ep, CLR_STA, USBA_RX_BK_RDY);\r\n}\r\n}\r\nstatic void usba_dma_irq(struct usba_udc *udc, struct usba_ep *ep)\r\n{\r\nstruct usba_request *req;\r\nu32 status, control, pending;\r\nstatus = usba_dma_readl(ep, STATUS);\r\ncontrol = usba_dma_readl(ep, CONTROL);\r\n#ifdef CONFIG_USB_GADGET_DEBUG_FS\r\nep->last_dma_status = status;\r\n#endif\r\npending = status & control;\r\nDBG(DBG_INT | DBG_DMA, "dma irq, s/%#08x, c/%#08x\n", status, control);\r\nif (status & USBA_DMA_CH_EN) {\r\ndev_err(&udc->pdev->dev,\r\n"DMA_CH_EN is set after transfer is finished!\n");\r\ndev_err(&udc->pdev->dev,\r\n"status=%#08x, pending=%#08x, control=%#08x\n",\r\nstatus, pending, control);\r\n}\r\nif (list_empty(&ep->queue))\r\nreturn;\r\nif (pending & (USBA_DMA_END_TR_ST | USBA_DMA_END_BUF_ST)) {\r\nreq = list_entry(ep->queue.next, struct usba_request, queue);\r\nusba_update_req(ep, req, status);\r\nlist_del_init(&req->queue);\r\nsubmit_next_request(ep);\r\nrequest_complete(ep, req, 0);\r\n}\r\n}\r\nstatic irqreturn_t usba_udc_irq(int irq, void *devid)\r\n{\r\nstruct usba_udc *udc = devid;\r\nu32 status;\r\nu32 dma_status;\r\nu32 ep_status;\r\nspin_lock(&udc->lock);\r\nstatus = usba_readl(udc, INT_STA);\r\nDBG(DBG_INT, "irq, status=%#08x\n", status);\r\nif (status & USBA_DET_SUSPEND) {\r\ntoggle_bias(0);\r\nusba_writel(udc, INT_CLR, USBA_DET_SUSPEND);\r\nDBG(DBG_BUS, "Suspend detected\n");\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& udc->driver && udc->driver->suspend) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->suspend(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nif (status & USBA_WAKE_UP) {\r\ntoggle_bias(1);\r\nusba_writel(udc, INT_CLR, USBA_WAKE_UP);\r\nDBG(DBG_BUS, "Wake Up CPU detected\n");\r\n}\r\nif (status & USBA_END_OF_RESUME) {\r\nusba_writel(udc, INT_CLR, USBA_END_OF_RESUME);\r\nDBG(DBG_BUS, "Resume detected\n");\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& udc->driver && udc->driver->resume) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->resume(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\ndma_status = USBA_BFEXT(DMA_INT, status);\r\nif (dma_status) {\r\nint i;\r\nfor (i = 1; i < USBA_NR_ENDPOINTS; i++)\r\nif (dma_status & (1 << i))\r\nusba_dma_irq(udc, &udc->usba_ep[i]);\r\n}\r\nep_status = USBA_BFEXT(EPT_INT, status);\r\nif (ep_status) {\r\nint i;\r\nfor (i = 0; i < USBA_NR_ENDPOINTS; i++)\r\nif (ep_status & (1 << i)) {\r\nif (ep_is_control(&udc->usba_ep[i]))\r\nusba_control_irq(udc, &udc->usba_ep[i]);\r\nelse\r\nusba_ep_irq(udc, &udc->usba_ep[i]);\r\n}\r\n}\r\nif (status & USBA_END_OF_RESET) {\r\nstruct usba_ep *ep0;\r\nusba_writel(udc, INT_CLR, USBA_END_OF_RESET);\r\nreset_all_endpoints(udc);\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN\r\n&& udc->driver->disconnect) {\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\nif (status & USBA_HIGH_SPEED)\r\nudc->gadget.speed = USB_SPEED_HIGH;\r\nelse\r\nudc->gadget.speed = USB_SPEED_FULL;\r\nDBG(DBG_BUS, "%s bus reset detected\n",\r\nusb_speed_string(udc->gadget.speed));\r\nep0 = &udc->usba_ep[0];\r\nep0->ep.desc = &usba_ep0_desc;\r\nep0->state = WAIT_FOR_SETUP;\r\nusba_ep_writel(ep0, CFG,\r\n(USBA_BF(EPT_SIZE, EP0_EPT_SIZE)\r\n| USBA_BF(EPT_TYPE, USBA_EPT_TYPE_CONTROL)\r\n| USBA_BF(BK_NUMBER, USBA_BK_NUMBER_ONE)));\r\nusba_ep_writel(ep0, CTL_ENB,\r\nUSBA_EPT_ENABLE | USBA_RX_SETUP);\r\nusba_writel(udc, INT_ENB,\r\n(usba_readl(udc, INT_ENB)\r\n| USBA_BF(EPT_INT, 1)\r\n| USBA_DET_SUSPEND\r\n| USBA_END_OF_RESUME));\r\nif (!(usba_ep_readl(ep0, CFG) & USBA_EPT_MAPPED))\r\ndev_dbg(&udc->pdev->dev,\r\n"ODD: EP0 configuration is invalid!\n");\r\n}\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t usba_vbus_irq(int irq, void *devid)\r\n{\r\nstruct usba_udc *udc = devid;\r\nint vbus;\r\nudelay(10);\r\nspin_lock(&udc->lock);\r\nif (!udc->driver)\r\ngoto out;\r\nvbus = vbus_is_present(udc);\r\nif (vbus != udc->vbus_prev) {\r\nif (vbus) {\r\ntoggle_bias(1);\r\nusba_writel(udc, CTRL, USBA_ENABLE_MASK);\r\nusba_writel(udc, INT_ENB, USBA_END_OF_RESET);\r\n} else {\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nreset_all_endpoints(udc);\r\ntoggle_bias(0);\r\nusba_writel(udc, CTRL, USBA_DISABLE_MASK);\r\nif (udc->driver->disconnect) {\r\nspin_unlock(&udc->lock);\r\nudc->driver->disconnect(&udc->gadget);\r\nspin_lock(&udc->lock);\r\n}\r\n}\r\nudc->vbus_prev = vbus;\r\n}\r\nout:\r\nspin_unlock(&udc->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int atmel_usba_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nint ret;\r\nstruct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);\r\nunsigned long flags;\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->devstatus = 1 << USB_DEVICE_SELF_POWERED;\r\nudc->driver = driver;\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nret = clk_prepare_enable(udc->pclk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(udc->hclk);\r\nif (ret) {\r\nclk_disable_unprepare(udc->pclk);\r\nreturn ret;\r\n}\r\nDBG(DBG_GADGET, "registered driver `%s'\n", driver->driver.name);\r\nudc->vbus_prev = 0;\r\nif (gpio_is_valid(udc->vbus_pin))\r\nenable_irq(gpio_to_irq(udc->vbus_pin));\r\nspin_lock_irqsave(&udc->lock, flags);\r\nif (vbus_is_present(udc) && udc->vbus_prev == 0) {\r\ntoggle_bias(1);\r\nusba_writel(udc, CTRL, USBA_ENABLE_MASK);\r\nusba_writel(udc, INT_ENB, USBA_END_OF_RESET);\r\n}\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int atmel_usba_stop(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct usba_udc *udc = container_of(gadget, struct usba_udc, gadget);\r\nunsigned long flags;\r\nif (gpio_is_valid(udc->vbus_pin))\r\ndisable_irq(gpio_to_irq(udc->vbus_pin));\r\nspin_lock_irqsave(&udc->lock, flags);\r\nudc->gadget.speed = USB_SPEED_UNKNOWN;\r\nreset_all_endpoints(udc);\r\nspin_unlock_irqrestore(&udc->lock, flags);\r\ntoggle_bias(0);\r\nusba_writel(udc, CTRL, USBA_DISABLE_MASK);\r\nudc->driver = NULL;\r\nclk_disable_unprepare(udc->hclk);\r\nclk_disable_unprepare(udc->pclk);\r\nDBG(DBG_GADGET, "unregistered driver `%s'\n", driver->driver.name);\r\nreturn 0;\r\n}\r\nstatic struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,\r\nstruct usba_udc *udc)\r\n{\r\nu32 val;\r\nconst char *name;\r\nenum of_gpio_flags flags;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *pp;\r\nint i, ret;\r\nstruct usba_ep *eps, *ep;\r\nudc->num_ep = 0;\r\nudc->vbus_pin = of_get_named_gpio_flags(np, "atmel,vbus-gpio", 0,\r\n&flags);\r\nudc->vbus_pin_inverted = (flags & OF_GPIO_ACTIVE_LOW) ? 1 : 0;\r\npp = NULL;\r\nwhile ((pp = of_get_next_child(np, pp)))\r\nudc->num_ep++;\r\neps = devm_kzalloc(&pdev->dev, sizeof(struct usba_ep) * udc->num_ep,\r\nGFP_KERNEL);\r\nif (!eps)\r\nreturn ERR_PTR(-ENOMEM);\r\nudc->gadget.ep0 = &eps[0].ep;\r\nINIT_LIST_HEAD(&eps[0].ep.ep_list);\r\npp = NULL;\r\ni = 0;\r\nwhile ((pp = of_get_next_child(np, pp))) {\r\nep = &eps[i];\r\nret = of_property_read_u32(pp, "reg", &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "of_probe: reg error(%d)\n", ret);\r\ngoto err;\r\n}\r\nep->index = val;\r\nret = of_property_read_u32(pp, "atmel,fifo-size", &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "of_probe: fifo-size error(%d)\n", ret);\r\ngoto err;\r\n}\r\nep->fifo_size = val;\r\nret = of_property_read_u32(pp, "atmel,nb-banks", &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "of_probe: nb-banks error(%d)\n", ret);\r\ngoto err;\r\n}\r\nep->nr_banks = val;\r\nep->can_dma = of_property_read_bool(pp, "atmel,can-dma");\r\nep->can_isoc = of_property_read_bool(pp, "atmel,can-isoc");\r\nret = of_property_read_string(pp, "name", &name);\r\nep->ep.name = name;\r\nep->ep_regs = udc->regs + USBA_EPT_BASE(i);\r\nep->dma_regs = udc->regs + USBA_DMA_BASE(i);\r\nep->fifo = udc->fifo + USBA_FIFO_BASE(i);\r\nep->ep.ops = &usba_ep_ops;\r\nep->ep.maxpacket = ep->fifo_size;\r\nep->udc = udc;\r\nINIT_LIST_HEAD(&ep->queue);\r\nif (i)\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\ni++;\r\n}\r\nreturn eps;\r\nerr:\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,\r\nstruct usba_udc *udc)\r\n{\r\nreturn ERR_PTR(-ENOSYS);\r\n}\r\nstatic struct usba_ep * usba_udc_pdata(struct platform_device *pdev,\r\nstruct usba_udc *udc)\r\n{\r\nstruct usba_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct usba_ep *eps;\r\nint i;\r\nif (!pdata)\r\nreturn ERR_PTR(-ENXIO);\r\neps = devm_kzalloc(&pdev->dev, sizeof(struct usba_ep) * pdata->num_ep,\r\nGFP_KERNEL);\r\nif (!eps)\r\nreturn ERR_PTR(-ENOMEM);\r\nudc->gadget.ep0 = &eps[0].ep;\r\nudc->vbus_pin = pdata->vbus_pin;\r\nudc->vbus_pin_inverted = pdata->vbus_pin_inverted;\r\nudc->num_ep = pdata->num_ep;\r\nINIT_LIST_HEAD(&eps[0].ep.ep_list);\r\nfor (i = 0; i < pdata->num_ep; i++) {\r\nstruct usba_ep *ep = &eps[i];\r\nep->ep_regs = udc->regs + USBA_EPT_BASE(i);\r\nep->dma_regs = udc->regs + USBA_DMA_BASE(i);\r\nep->fifo = udc->fifo + USBA_FIFO_BASE(i);\r\nep->ep.ops = &usba_ep_ops;\r\nep->ep.name = pdata->ep[i].name;\r\nep->fifo_size = ep->ep.maxpacket = pdata->ep[i].fifo_size;\r\nep->udc = udc;\r\nINIT_LIST_HEAD(&ep->queue);\r\nep->nr_banks = pdata->ep[i].nr_banks;\r\nep->index = pdata->ep[i].index;\r\nep->can_dma = pdata->ep[i].can_dma;\r\nep->can_isoc = pdata->ep[i].can_isoc;\r\nif (i)\r\nlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\r\n}\r\nreturn eps;\r\n}\r\nstatic int __init usba_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *regs, *fifo;\r\nstruct clk *pclk, *hclk;\r\nstruct usba_udc *udc;\r\nint irq, ret, i;\r\nudc = devm_kzalloc(&pdev->dev, sizeof(*udc), GFP_KERNEL);\r\nif (!udc)\r\nreturn -ENOMEM;\r\nudc->gadget = usba_gadget_template;\r\nINIT_LIST_HEAD(&udc->gadget.ep_list);\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, CTRL_IOMEM_ID);\r\nfifo = platform_get_resource(pdev, IORESOURCE_MEM, FIFO_IOMEM_ID);\r\nif (!regs || !fifo)\r\nreturn -ENXIO;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\npclk = clk_get(&pdev->dev, "pclk");\r\nif (IS_ERR(pclk))\r\nreturn PTR_ERR(pclk);\r\nhclk = clk_get(&pdev->dev, "hclk");\r\nif (IS_ERR(hclk)) {\r\nret = PTR_ERR(hclk);\r\ngoto err_get_hclk;\r\n}\r\nspin_lock_init(&udc->lock);\r\nudc->pdev = pdev;\r\nudc->pclk = pclk;\r\nudc->hclk = hclk;\r\nudc->vbus_pin = -ENODEV;\r\nret = -ENOMEM;\r\nudc->regs = ioremap(regs->start, resource_size(regs));\r\nif (!udc->regs) {\r\ndev_err(&pdev->dev, "Unable to map I/O memory, aborting.\n");\r\ngoto err_map_regs;\r\n}\r\ndev_info(&pdev->dev, "MMIO registers at 0x%08lx mapped at %p\n",\r\n(unsigned long)regs->start, udc->regs);\r\nudc->fifo = ioremap(fifo->start, resource_size(fifo));\r\nif (!udc->fifo) {\r\ndev_err(&pdev->dev, "Unable to map FIFO, aborting.\n");\r\ngoto err_map_fifo;\r\n}\r\ndev_info(&pdev->dev, "FIFO at 0x%08lx mapped at %p\n",\r\n(unsigned long)fifo->start, udc->fifo);\r\nplatform_set_drvdata(pdev, udc);\r\nret = clk_prepare_enable(pclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to enable pclk, aborting.\n");\r\ngoto err_clk_enable;\r\n}\r\ntoggle_bias(0);\r\nusba_writel(udc, CTRL, USBA_DISABLE_MASK);\r\nclk_disable_unprepare(pclk);\r\nif (pdev->dev.of_node)\r\nudc->usba_ep = atmel_udc_of_init(pdev, udc);\r\nelse\r\nudc->usba_ep = usba_udc_pdata(pdev, udc);\r\nif (IS_ERR(udc->usba_ep)) {\r\nret = PTR_ERR(udc->usba_ep);\r\ngoto err_alloc_ep;\r\n}\r\nret = request_irq(irq, usba_udc_irq, 0, "atmel_usba_udc", udc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot request irq %d (error %d)\n",\r\nirq, ret);\r\ngoto err_request_irq;\r\n}\r\nudc->irq = irq;\r\nif (gpio_is_valid(udc->vbus_pin)) {\r\nif (!devm_gpio_request(&pdev->dev, udc->vbus_pin, "atmel_usba_udc")) {\r\nret = request_irq(gpio_to_irq(udc->vbus_pin),\r\nusba_vbus_irq, 0,\r\n"atmel_usba_udc", udc);\r\nif (ret) {\r\nudc->vbus_pin = -ENODEV;\r\ndev_warn(&udc->pdev->dev,\r\n"failed to request vbus irq; "\r\n"assuming always on\n");\r\n} else {\r\ndisable_irq(gpio_to_irq(udc->vbus_pin));\r\n}\r\n} else {\r\nudc->vbus_pin = -EINVAL;\r\n}\r\n}\r\nret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\r\nif (ret)\r\ngoto err_add_udc;\r\nusba_init_debugfs(udc);\r\nfor (i = 1; i < udc->num_ep; i++)\r\nusba_ep_init_debugfs(udc, &udc->usba_ep[i]);\r\nreturn 0;\r\nerr_add_udc:\r\nif (gpio_is_valid(udc->vbus_pin))\r\nfree_irq(gpio_to_irq(udc->vbus_pin), udc);\r\nfree_irq(irq, udc);\r\nerr_request_irq:\r\nerr_alloc_ep:\r\nerr_clk_enable:\r\niounmap(udc->fifo);\r\nerr_map_fifo:\r\niounmap(udc->regs);\r\nerr_map_regs:\r\nclk_put(hclk);\r\nerr_get_hclk:\r\nclk_put(pclk);\r\nreturn ret;\r\n}\r\nstatic int __exit usba_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct usba_udc *udc;\r\nint i;\r\nudc = platform_get_drvdata(pdev);\r\nusb_del_gadget_udc(&udc->gadget);\r\nfor (i = 1; i < udc->num_ep; i++)\r\nusba_ep_cleanup_debugfs(&udc->usba_ep[i]);\r\nusba_cleanup_debugfs(udc);\r\nif (gpio_is_valid(udc->vbus_pin)) {\r\nfree_irq(gpio_to_irq(udc->vbus_pin), udc);\r\n}\r\nfree_irq(udc->irq, udc);\r\niounmap(udc->fifo);\r\niounmap(udc->regs);\r\nclk_put(udc->hclk);\r\nclk_put(udc->pclk);\r\nreturn 0;\r\n}
