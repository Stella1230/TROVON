int exynos_platform_device_hdmi_register(void)\r\n{\r\nstruct platform_device *pdev;\r\nif (exynos_drm_hdmi_pdev)\r\nreturn -EEXIST;\r\npdev = platform_device_register_simple(\r\n"exynos-drm-hdmi", -1, NULL, 0);\r\nif (IS_ERR(pdev))\r\nreturn PTR_ERR(pdev);\r\nexynos_drm_hdmi_pdev = pdev;\r\nreturn 0;\r\n}\r\nvoid exynos_platform_device_hdmi_unregister(void)\r\n{\r\nif (exynos_drm_hdmi_pdev) {\r\nplatform_device_unregister(exynos_drm_hdmi_pdev);\r\nexynos_drm_hdmi_pdev = NULL;\r\n}\r\n}\r\nvoid exynos_hdmi_drv_attach(struct exynos_drm_hdmi_context *ctx)\r\n{\r\nif (ctx)\r\nhdmi_ctx = ctx;\r\n}\r\nvoid exynos_mixer_drv_attach(struct exynos_drm_hdmi_context *ctx)\r\n{\r\nif (ctx)\r\nmixer_ctx = ctx;\r\n}\r\nvoid exynos_hdmi_ops_register(struct exynos_hdmi_ops *ops)\r\n{\r\nif (ops)\r\nhdmi_ops = ops;\r\n}\r\nvoid exynos_mixer_ops_register(struct exynos_mixer_ops *ops)\r\n{\r\nif (ops)\r\nmixer_ops = ops;\r\n}\r\nstatic bool drm_hdmi_is_connected(struct device *dev)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(dev);\r\nif (hdmi_ops && hdmi_ops->is_connected)\r\nreturn hdmi_ops->is_connected(ctx->hdmi_ctx->ctx);\r\nreturn false;\r\n}\r\nstatic struct edid *drm_hdmi_get_edid(struct device *dev,\r\nstruct drm_connector *connector)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(dev);\r\nif (hdmi_ops && hdmi_ops->get_edid)\r\nreturn hdmi_ops->get_edid(ctx->hdmi_ctx->ctx, connector);\r\nreturn NULL;\r\n}\r\nstatic int drm_hdmi_check_mode(struct device *dev,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(dev);\r\nint ret = 0;\r\nif (mixer_ops && mixer_ops->check_mode)\r\nret = mixer_ops->check_mode(ctx->mixer_ctx->ctx, mode);\r\nif (ret)\r\nreturn ret;\r\nif (hdmi_ops && hdmi_ops->check_mode)\r\nreturn hdmi_ops->check_mode(ctx->hdmi_ctx->ctx, mode);\r\nreturn 0;\r\n}\r\nstatic int drm_hdmi_power_on(struct device *dev, int mode)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(dev);\r\nif (hdmi_ops && hdmi_ops->power_on)\r\nreturn hdmi_ops->power_on(ctx->hdmi_ctx->ctx, mode);\r\nreturn 0;\r\n}\r\nstatic int drm_hdmi_enable_vblank(struct device *subdrv_dev)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nstruct exynos_drm_subdrv *subdrv = &ctx->subdrv;\r\nstruct exynos_drm_manager *manager = subdrv->manager;\r\nif (mixer_ops && mixer_ops->enable_vblank)\r\nreturn mixer_ops->enable_vblank(ctx->mixer_ctx->ctx,\r\nmanager->pipe);\r\nreturn 0;\r\n}\r\nstatic void drm_hdmi_disable_vblank(struct device *subdrv_dev)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (mixer_ops && mixer_ops->disable_vblank)\r\nreturn mixer_ops->disable_vblank(ctx->mixer_ctx->ctx);\r\n}\r\nstatic void drm_hdmi_wait_for_vblank(struct device *subdrv_dev)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (mixer_ops && mixer_ops->wait_for_vblank)\r\nmixer_ops->wait_for_vblank(ctx->mixer_ctx->ctx);\r\n}\r\nstatic void drm_hdmi_mode_fixup(struct device *subdrv_dev,\r\nstruct drm_connector *connector,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nstruct drm_display_mode *m;\r\nint mode_ok;\r\ndrm_mode_set_crtcinfo(adjusted_mode, 0);\r\nmode_ok = drm_hdmi_check_mode(subdrv_dev, adjusted_mode);\r\nif (mode_ok == 0)\r\nreturn;\r\nlist_for_each_entry(m, &connector->modes, head) {\r\nmode_ok = drm_hdmi_check_mode(subdrv_dev, m);\r\nif (mode_ok == 0) {\r\nstruct drm_mode_object base;\r\nstruct list_head head;\r\nDRM_INFO("desired mode doesn't exist so\n");\r\nDRM_INFO("use the most suitable mode among modes.\n");\r\nDRM_DEBUG_KMS("Adjusted Mode: [%d]x[%d] [%d]Hz\n",\r\nm->hdisplay, m->vdisplay, m->vrefresh);\r\nhead = adjusted_mode->head;\r\nbase = adjusted_mode->base;\r\nmemcpy(adjusted_mode, m, sizeof(*m));\r\nadjusted_mode->head = head;\r\nadjusted_mode->base = base;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void drm_hdmi_mode_set(struct device *subdrv_dev, void *mode)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (hdmi_ops && hdmi_ops->mode_set)\r\nhdmi_ops->mode_set(ctx->hdmi_ctx->ctx, mode);\r\n}\r\nstatic void drm_hdmi_get_max_resol(struct device *subdrv_dev,\r\nunsigned int *width, unsigned int *height)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (hdmi_ops && hdmi_ops->get_max_resol)\r\nhdmi_ops->get_max_resol(ctx->hdmi_ctx->ctx, width, height);\r\n}\r\nstatic void drm_hdmi_commit(struct device *subdrv_dev)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (hdmi_ops && hdmi_ops->commit)\r\nhdmi_ops->commit(ctx->hdmi_ctx->ctx);\r\n}\r\nstatic void drm_hdmi_dpms(struct device *subdrv_dev, int mode)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (mixer_ops && mixer_ops->dpms)\r\nmixer_ops->dpms(ctx->mixer_ctx->ctx, mode);\r\nif (hdmi_ops && hdmi_ops->dpms)\r\nhdmi_ops->dpms(ctx->hdmi_ctx->ctx, mode);\r\n}\r\nstatic void drm_hdmi_apply(struct device *subdrv_dev)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nint i;\r\nfor (i = 0; i < MIXER_WIN_NR; i++) {\r\nif (!ctx->enabled[i])\r\ncontinue;\r\nif (mixer_ops && mixer_ops->win_commit)\r\nmixer_ops->win_commit(ctx->mixer_ctx->ctx, i);\r\n}\r\nif (hdmi_ops && hdmi_ops->commit)\r\nhdmi_ops->commit(ctx->hdmi_ctx->ctx);\r\n}\r\nstatic void drm_mixer_mode_set(struct device *subdrv_dev,\r\nstruct exynos_drm_overlay *overlay)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nif (mixer_ops && mixer_ops->win_mode_set)\r\nmixer_ops->win_mode_set(ctx->mixer_ctx->ctx, overlay);\r\n}\r\nstatic void drm_mixer_commit(struct device *subdrv_dev, int zpos)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nint win = (zpos == DEFAULT_ZPOS) ? MIXER_DEFAULT_WIN : zpos;\r\nif (win < 0 || win >= MIXER_WIN_NR) {\r\nDRM_ERROR("mixer window[%d] is wrong\n", win);\r\nreturn;\r\n}\r\nif (mixer_ops && mixer_ops->win_commit)\r\nmixer_ops->win_commit(ctx->mixer_ctx->ctx, win);\r\nctx->enabled[win] = true;\r\n}\r\nstatic void drm_mixer_disable(struct device *subdrv_dev, int zpos)\r\n{\r\nstruct drm_hdmi_context *ctx = to_context(subdrv_dev);\r\nint win = (zpos == DEFAULT_ZPOS) ? MIXER_DEFAULT_WIN : zpos;\r\nif (win < 0 || win >= MIXER_WIN_NR) {\r\nDRM_ERROR("mixer window[%d] is wrong\n", win);\r\nreturn;\r\n}\r\nif (mixer_ops && mixer_ops->win_disable)\r\nmixer_ops->win_disable(ctx->mixer_ctx->ctx, win);\r\nctx->enabled[win] = false;\r\n}\r\nstatic int hdmi_subdrv_probe(struct drm_device *drm_dev,\r\nstruct device *dev)\r\n{\r\nstruct exynos_drm_subdrv *subdrv = to_subdrv(dev);\r\nstruct drm_hdmi_context *ctx;\r\nif (!hdmi_ctx) {\r\nDRM_ERROR("hdmi context not initialized.\n");\r\nreturn -EFAULT;\r\n}\r\nif (!mixer_ctx) {\r\nDRM_ERROR("mixer context not initialized.\n");\r\nreturn -EFAULT;\r\n}\r\nctx = get_ctx_from_subdrv(subdrv);\r\nif (!ctx) {\r\nDRM_ERROR("no drm hdmi context.\n");\r\nreturn -EFAULT;\r\n}\r\nctx->hdmi_ctx = hdmi_ctx;\r\nctx->mixer_ctx = mixer_ctx;\r\nctx->hdmi_ctx->drm_dev = drm_dev;\r\nctx->mixer_ctx->drm_dev = drm_dev;\r\nif (mixer_ops->iommu_on)\r\nmixer_ops->iommu_on(ctx->mixer_ctx->ctx, true);\r\nreturn 0;\r\n}\r\nstatic void hdmi_subdrv_remove(struct drm_device *drm_dev, struct device *dev)\r\n{\r\nstruct drm_hdmi_context *ctx;\r\nstruct exynos_drm_subdrv *subdrv = to_subdrv(dev);\r\nctx = get_ctx_from_subdrv(subdrv);\r\nif (mixer_ops->iommu_on)\r\nmixer_ops->iommu_on(ctx->mixer_ctx->ctx, false);\r\n}\r\nstatic int exynos_drm_hdmi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct exynos_drm_subdrv *subdrv;\r\nstruct drm_hdmi_context *ctx;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nsubdrv = &ctx->subdrv;\r\nsubdrv->dev = dev;\r\nsubdrv->manager = &hdmi_manager;\r\nsubdrv->probe = hdmi_subdrv_probe;\r\nsubdrv->remove = hdmi_subdrv_remove;\r\nplatform_set_drvdata(pdev, subdrv);\r\nexynos_drm_subdrv_register(subdrv);\r\nreturn 0;\r\n}\r\nstatic int exynos_drm_hdmi_remove(struct platform_device *pdev)\r\n{\r\nstruct drm_hdmi_context *ctx = platform_get_drvdata(pdev);\r\nexynos_drm_subdrv_unregister(&ctx->subdrv);\r\nreturn 0;\r\n}
