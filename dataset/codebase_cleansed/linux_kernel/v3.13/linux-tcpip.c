int\r\nlibcfs_sock_ioctl(int cmd, unsigned long arg)\r\n{\r\nmm_segment_t oldmm = get_fs();\r\nstruct socket *sock;\r\nint rc;\r\nstruct file *sock_filp;\r\nrc = sock_create (PF_INET, SOCK_STREAM, 0, &sock);\r\nif (rc != 0) {\r\nCERROR ("Can't create socket: %d\n", rc);\r\nreturn rc;\r\n}\r\nsock_filp = sock_alloc_file(sock, 0, NULL);\r\nif (IS_ERR(sock_filp)) {\r\nsock_release(sock);\r\nrc = PTR_ERR(sock_filp);\r\ngoto out;\r\n}\r\nset_fs(KERNEL_DS);\r\nif (sock_filp->f_op->unlocked_ioctl)\r\nrc = sock_filp->f_op->unlocked_ioctl(sock_filp, cmd, arg);\r\nset_fs(oldmm);\r\nfput(sock_filp);\r\nout:\r\nreturn rc;\r\n}\r\nint\r\nlibcfs_ipif_query (char *name, int *up, __u32 *ip, __u32 *mask)\r\n{\r\nstruct ifreq ifr;\r\nint nob;\r\nint rc;\r\n__u32 val;\r\nnob = strnlen(name, IFNAMSIZ);\r\nif (nob == IFNAMSIZ) {\r\nCERROR("Interface name %s too long\n", name);\r\nreturn -EINVAL;\r\n}\r\nCLASSERT (sizeof(ifr.ifr_name) >= IFNAMSIZ);\r\nstrcpy(ifr.ifr_name, name);\r\nrc = libcfs_sock_ioctl(SIOCGIFFLAGS, (unsigned long)&ifr);\r\nif (rc != 0) {\r\nCERROR("Can't get flags for interface %s\n", name);\r\nreturn rc;\r\n}\r\nif ((ifr.ifr_flags & IFF_UP) == 0) {\r\nCDEBUG(D_NET, "Interface %s down\n", name);\r\n*up = 0;\r\n*ip = *mask = 0;\r\nreturn 0;\r\n}\r\n*up = 1;\r\nstrcpy(ifr.ifr_name, name);\r\nifr.ifr_addr.sa_family = AF_INET;\r\nrc = libcfs_sock_ioctl(SIOCGIFADDR, (unsigned long)&ifr);\r\nif (rc != 0) {\r\nCERROR("Can't get IP address for interface %s\n", name);\r\nreturn rc;\r\n}\r\nval = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr.s_addr;\r\n*ip = ntohl(val);\r\nstrcpy(ifr.ifr_name, name);\r\nifr.ifr_addr.sa_family = AF_INET;\r\nrc = libcfs_sock_ioctl(SIOCGIFNETMASK, (unsigned long)&ifr);\r\nif (rc != 0) {\r\nCERROR("Can't get netmask for interface %s\n", name);\r\nreturn rc;\r\n}\r\nval = ((struct sockaddr_in *)&ifr.ifr_netmask)->sin_addr.s_addr;\r\n*mask = ntohl(val);\r\nreturn 0;\r\n}\r\nint\r\nlibcfs_ipif_enumerate (char ***namesp)\r\n{\r\nchar **names;\r\nint toobig;\r\nint nalloc;\r\nint nfound;\r\nstruct ifreq *ifr;\r\nstruct ifconf ifc;\r\nint rc;\r\nint nob;\r\nint i;\r\nnalloc = 16;\r\ntoobig = 0;\r\nfor (;;) {\r\nif (nalloc * sizeof(*ifr) > PAGE_CACHE_SIZE) {\r\ntoobig = 1;\r\nnalloc = PAGE_CACHE_SIZE/sizeof(*ifr);\r\nCWARN("Too many interfaces: only enumerating first %d\n",\r\nnalloc);\r\n}\r\nLIBCFS_ALLOC(ifr, nalloc * sizeof(*ifr));\r\nif (ifr == NULL) {\r\nCERROR ("ENOMEM enumerating up to %d interfaces\n", nalloc);\r\nrc = -ENOMEM;\r\ngoto out0;\r\n}\r\nifc.ifc_buf = (char *)ifr;\r\nifc.ifc_len = nalloc * sizeof(*ifr);\r\nrc = libcfs_sock_ioctl(SIOCGIFCONF, (unsigned long)&ifc);\r\nif (rc < 0) {\r\nCERROR ("Error %d enumerating interfaces\n", rc);\r\ngoto out1;\r\n}\r\nLASSERT (rc == 0);\r\nnfound = ifc.ifc_len/sizeof(*ifr);\r\nLASSERT (nfound <= nalloc);\r\nif (nfound < nalloc || toobig)\r\nbreak;\r\nLIBCFS_FREE(ifr, nalloc * sizeof(*ifr));\r\nnalloc *= 2;\r\n}\r\nif (nfound == 0)\r\ngoto out1;\r\nLIBCFS_ALLOC(names, nfound * sizeof(*names));\r\nif (names == NULL) {\r\nrc = -ENOMEM;\r\ngoto out1;\r\n}\r\nmemset (names, 0, nfound * sizeof(*names));\r\nfor (i = 0; i < nfound; i++) {\r\nnob = strnlen (ifr[i].ifr_name, IFNAMSIZ);\r\nif (nob == IFNAMSIZ) {\r\nCERROR("interface name %.*s too long (%d max)\n",\r\nnob, ifr[i].ifr_name, IFNAMSIZ);\r\nrc = -ENAMETOOLONG;\r\ngoto out2;\r\n}\r\nLIBCFS_ALLOC(names[i], IFNAMSIZ);\r\nif (names[i] == NULL) {\r\nrc = -ENOMEM;\r\ngoto out2;\r\n}\r\nmemcpy(names[i], ifr[i].ifr_name, nob);\r\nnames[i][nob] = 0;\r\n}\r\n*namesp = names;\r\nrc = nfound;\r\nout2:\r\nif (rc < 0)\r\nlibcfs_ipif_free_enumeration(names, nfound);\r\nout1:\r\nLIBCFS_FREE(ifr, nalloc * sizeof(*ifr));\r\nout0:\r\nreturn rc;\r\n}\r\nvoid\r\nlibcfs_ipif_free_enumeration (char **names, int n)\r\n{\r\nint i;\r\nLASSERT (n > 0);\r\nfor (i = 0; i < n && names[i] != NULL; i++)\r\nLIBCFS_FREE(names[i], IFNAMSIZ);\r\nLIBCFS_FREE(names, n * sizeof(*names));\r\n}\r\nint\r\nlibcfs_sock_write (struct socket *sock, void *buffer, int nob, int timeout)\r\n{\r\nint rc;\r\nmm_segment_t oldmm = get_fs();\r\nlong ticks = timeout * HZ;\r\nunsigned long then;\r\nstruct timeval tv;\r\nLASSERT (nob > 0);\r\nfor (;;) {\r\nstruct iovec iov = {\r\n.iov_base = buffer,\r\n.iov_len = nob\r\n};\r\nstruct msghdr msg = {\r\n.msg_name = NULL,\r\n.msg_namelen = 0,\r\n.msg_iov = &iov,\r\n.msg_iovlen = 1,\r\n.msg_control = NULL,\r\n.msg_controllen = 0,\r\n.msg_flags = (timeout == 0) ? MSG_DONTWAIT : 0\r\n};\r\nif (timeout != 0) {\r\ntv = (struct timeval) {\r\n.tv_sec = ticks / HZ,\r\n.tv_usec = ((ticks % HZ) * 1000000) / HZ\r\n};\r\nset_fs(KERNEL_DS);\r\nrc = sock_setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO,\r\n(char *)&tv, sizeof(tv));\r\nset_fs(oldmm);\r\nif (rc != 0) {\r\nCERROR("Can't set socket send timeout "\r\n"%ld.%06d: %d\n",\r\n(long)tv.tv_sec, (int)tv.tv_usec, rc);\r\nreturn rc;\r\n}\r\n}\r\nset_fs (KERNEL_DS);\r\nthen = jiffies;\r\nrc = sock_sendmsg (sock, &msg, iov.iov_len);\r\nticks -= jiffies - then;\r\nset_fs (oldmm);\r\nif (rc == nob)\r\nreturn 0;\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc == 0) {\r\nCERROR ("Unexpected zero rc\n");\r\nreturn (-ECONNABORTED);\r\n}\r\nif (ticks <= 0)\r\nreturn -EAGAIN;\r\nbuffer = ((char *)buffer) + rc;\r\nnob -= rc;\r\n}\r\nreturn (0);\r\n}\r\nint\r\nlibcfs_sock_read (struct socket *sock, void *buffer, int nob, int timeout)\r\n{\r\nint rc;\r\nmm_segment_t oldmm = get_fs();\r\nlong ticks = timeout * HZ;\r\nunsigned long then;\r\nstruct timeval tv;\r\nLASSERT (nob > 0);\r\nLASSERT (ticks > 0);\r\nfor (;;) {\r\nstruct iovec iov = {\r\n.iov_base = buffer,\r\n.iov_len = nob\r\n};\r\nstruct msghdr msg = {\r\n.msg_name = NULL,\r\n.msg_namelen = 0,\r\n.msg_iov = &iov,\r\n.msg_iovlen = 1,\r\n.msg_control = NULL,\r\n.msg_controllen = 0,\r\n.msg_flags = 0\r\n};\r\ntv = (struct timeval) {\r\n.tv_sec = ticks / HZ,\r\n.tv_usec = ((ticks % HZ) * 1000000) / HZ\r\n};\r\nset_fs(KERNEL_DS);\r\nrc = sock_setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO,\r\n(char *)&tv, sizeof(tv));\r\nset_fs(oldmm);\r\nif (rc != 0) {\r\nCERROR("Can't set socket recv timeout %ld.%06d: %d\n",\r\n(long)tv.tv_sec, (int)tv.tv_usec, rc);\r\nreturn rc;\r\n}\r\nset_fs(KERNEL_DS);\r\nthen = jiffies;\r\nrc = sock_recvmsg(sock, &msg, iov.iov_len, 0);\r\nticks -= jiffies - then;\r\nset_fs(oldmm);\r\nif (rc < 0)\r\nreturn rc;\r\nif (rc == 0)\r\nreturn -ECONNRESET;\r\nbuffer = ((char *)buffer) + rc;\r\nnob -= rc;\r\nif (nob == 0)\r\nreturn 0;\r\nif (ticks <= 0)\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nstatic int\r\nlibcfs_sock_create (struct socket **sockp, int *fatal,\r\n__u32 local_ip, int local_port)\r\n{\r\nstruct sockaddr_in locaddr;\r\nstruct socket *sock;\r\nint rc;\r\nint option;\r\nmm_segment_t oldmm = get_fs();\r\n*fatal = 1;\r\nrc = sock_create (PF_INET, SOCK_STREAM, 0, &sock);\r\n*sockp = sock;\r\nif (rc != 0) {\r\nCERROR ("Can't create socket: %d\n", rc);\r\nreturn (rc);\r\n}\r\nset_fs (KERNEL_DS);\r\noption = 1;\r\nrc = sock_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\r\n(char *)&option, sizeof (option));\r\nset_fs (oldmm);\r\nif (rc != 0) {\r\nCERROR("Can't set SO_REUSEADDR for socket: %d\n", rc);\r\ngoto failed;\r\n}\r\nif (local_ip != 0 || local_port != 0) {\r\nmemset(&locaddr, 0, sizeof(locaddr));\r\nlocaddr.sin_family = AF_INET;\r\nlocaddr.sin_port = htons(local_port);\r\nlocaddr.sin_addr.s_addr = (local_ip == 0) ?\r\nINADDR_ANY : htonl(local_ip);\r\nrc = sock->ops->bind(sock, (struct sockaddr *)&locaddr,\r\nsizeof(locaddr));\r\nif (rc == -EADDRINUSE) {\r\nCDEBUG(D_NET, "Port %d already in use\n", local_port);\r\n*fatal = 0;\r\ngoto failed;\r\n}\r\nif (rc != 0) {\r\nCERROR("Error trying to bind to port %d: %d\n",\r\nlocal_port, rc);\r\ngoto failed;\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\nsock_release(sock);\r\nreturn rc;\r\n}\r\nint\r\nlibcfs_sock_setbuf (struct socket *sock, int txbufsize, int rxbufsize)\r\n{\r\nmm_segment_t oldmm = get_fs();\r\nint option;\r\nint rc;\r\nif (txbufsize != 0) {\r\noption = txbufsize;\r\nset_fs (KERNEL_DS);\r\nrc = sock_setsockopt(sock, SOL_SOCKET, SO_SNDBUF,\r\n(char *)&option, sizeof (option));\r\nset_fs (oldmm);\r\nif (rc != 0) {\r\nCERROR ("Can't set send buffer %d: %d\n",\r\noption, rc);\r\nreturn (rc);\r\n}\r\n}\r\nif (rxbufsize != 0) {\r\noption = rxbufsize;\r\nset_fs (KERNEL_DS);\r\nrc = sock_setsockopt (sock, SOL_SOCKET, SO_RCVBUF,\r\n(char *)&option, sizeof (option));\r\nset_fs (oldmm);\r\nif (rc != 0) {\r\nCERROR ("Can't set receive buffer %d: %d\n",\r\noption, rc);\r\nreturn (rc);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlibcfs_sock_getaddr (struct socket *sock, int remote, __u32 *ip, int *port)\r\n{\r\nstruct sockaddr_in sin;\r\nint len = sizeof (sin);\r\nint rc;\r\nrc = sock->ops->getname (sock, (struct sockaddr *)&sin, &len,\r\nremote ? 2 : 0);\r\nif (rc != 0) {\r\nCERROR ("Error %d getting sock %s IP/port\n",\r\nrc, remote ? "peer" : "local");\r\nreturn rc;\r\n}\r\nif (ip != NULL)\r\n*ip = ntohl (sin.sin_addr.s_addr);\r\nif (port != NULL)\r\n*port = ntohs (sin.sin_port);\r\nreturn 0;\r\n}\r\nint\r\nlibcfs_sock_getbuf (struct socket *sock, int *txbufsize, int *rxbufsize)\r\n{\r\nif (txbufsize != NULL) {\r\n*txbufsize = sock->sk->sk_sndbuf;\r\n}\r\nif (rxbufsize != NULL) {\r\n*rxbufsize = sock->sk->sk_rcvbuf;\r\n}\r\nreturn 0;\r\n}\r\nint\r\nlibcfs_sock_listen (struct socket **sockp,\r\n__u32 local_ip, int local_port, int backlog)\r\n{\r\nint fatal;\r\nint rc;\r\nrc = libcfs_sock_create(sockp, &fatal, local_ip, local_port);\r\nif (rc != 0) {\r\nif (!fatal)\r\nCERROR("Can't create socket: port %d already in use\n",\r\nlocal_port);\r\nreturn rc;\r\n}\r\nrc = (*sockp)->ops->listen(*sockp, backlog);\r\nif (rc == 0)\r\nreturn 0;\r\nCERROR("Can't set listen backlog %d: %d\n", backlog, rc);\r\nsock_release(*sockp);\r\nreturn rc;\r\n}\r\nint\r\nlibcfs_sock_accept (struct socket **newsockp, struct socket *sock)\r\n{\r\nwait_queue_t wait;\r\nstruct socket *newsock;\r\nint rc;\r\ninit_waitqueue_entry(&wait, current);\r\nrc = sock_create_lite(PF_PACKET, sock->type, IPPROTO_TCP, &newsock);\r\nif (rc) {\r\nCERROR("Can't allocate socket\n");\r\nreturn rc;\r\n}\r\nnewsock->ops = sock->ops;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(cfs_sk_sleep(sock->sk), &wait);\r\nrc = sock->ops->accept(sock, newsock, O_NONBLOCK);\r\nif (rc == -EAGAIN) {\r\nschedule();\r\nrc = sock->ops->accept(sock, newsock, O_NONBLOCK);\r\n}\r\nremove_wait_queue(cfs_sk_sleep(sock->sk), &wait);\r\nset_current_state(TASK_RUNNING);\r\nif (rc != 0)\r\ngoto failed;\r\n*newsockp = newsock;\r\nreturn 0;\r\nfailed:\r\nsock_release(newsock);\r\nreturn rc;\r\n}\r\nvoid\r\nlibcfs_sock_abort_accept (struct socket *sock)\r\n{\r\nwake_up_all(cfs_sk_sleep(sock->sk));\r\n}\r\nint\r\nlibcfs_sock_connect (struct socket **sockp, int *fatal,\r\n__u32 local_ip, int local_port,\r\n__u32 peer_ip, int peer_port)\r\n{\r\nstruct sockaddr_in srvaddr;\r\nint rc;\r\nrc = libcfs_sock_create(sockp, fatal, local_ip, local_port);\r\nif (rc != 0)\r\nreturn rc;\r\nmemset (&srvaddr, 0, sizeof (srvaddr));\r\nsrvaddr.sin_family = AF_INET;\r\nsrvaddr.sin_port = htons(peer_port);\r\nsrvaddr.sin_addr.s_addr = htonl(peer_ip);\r\nrc = (*sockp)->ops->connect(*sockp,\r\n(struct sockaddr *)&srvaddr, sizeof(srvaddr),\r\n0);\r\nif (rc == 0)\r\nreturn 0;\r\n*fatal = !(rc == -EADDRNOTAVAIL);\r\nCDEBUG_LIMIT(*fatal ? D_NETERROR : D_NET,\r\n"Error %d connecting %pI4h/%d -> %pI4h/%d\n", rc,\r\n&local_ip, local_port, &peer_ip, peer_port);\r\nsock_release(*sockp);\r\nreturn rc;\r\n}\r\nvoid\r\nlibcfs_sock_release (struct socket *sock)\r\n{\r\nsock_release(sock);\r\n}
