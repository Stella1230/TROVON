static u32 __init axp_get_tclk_freq(void __iomem *sar)\r\n{\r\nreturn 250000000;\r\n}\r\nstatic u32 __init axp_get_cpu_freq(void __iomem *sar)\r\n{\r\nu32 cpu_freq;\r\nu8 cpu_freq_select = 0;\r\ncpu_freq_select = ((readl(sar + SARL) >> SARL_AXP_PCLK_FREQ_OPT) &\r\nSARL_AXP_PCLK_FREQ_OPT_MASK);\r\ncpu_freq_select |= (((readl(sar + SARH) >> SARH_AXP_PCLK_FREQ_OPT) &\r\nSARH_AXP_PCLK_FREQ_OPT_MASK) << SARH_AXP_PCLK_FREQ_OPT_SHIFT);\r\nif (cpu_freq_select >= ARRAY_SIZE(axp_cpu_freqs)) {\r\npr_err("CPU freq select unsupported: %d\n", cpu_freq_select);\r\ncpu_freq = 0;\r\n} else\r\ncpu_freq = axp_cpu_freqs[cpu_freq_select];\r\nreturn cpu_freq;\r\n}\r\nstatic void __init axp_get_clk_ratio(\r\nvoid __iomem *sar, int id, int *mult, int *div)\r\n{\r\nu32 opt = ((readl(sar + SARL) >> SARL_AXP_FAB_FREQ_OPT) &\r\nSARL_AXP_FAB_FREQ_OPT_MASK);\r\nopt |= (((readl(sar + SARH) >> SARH_AXP_FAB_FREQ_OPT) &\r\nSARH_AXP_FAB_FREQ_OPT_MASK) << SARH_AXP_FAB_FREQ_OPT_SHIFT);\r\nswitch (id) {\r\ncase AXP_CPU_TO_NBCLK:\r\n*mult = axp_nbclk_ratios[opt][0];\r\n*div = axp_nbclk_ratios[opt][1];\r\nbreak;\r\ncase AXP_CPU_TO_HCLK:\r\n*mult = axp_hclk_ratios[opt][0];\r\n*div = axp_hclk_ratios[opt][1];\r\nbreak;\r\ncase AXP_CPU_TO_DRAMCLK:\r\n*mult = axp_dramclk_ratios[opt][0];\r\n*div = axp_dramclk_ratios[opt][1];\r\nbreak;\r\n}\r\n}\r\nstatic void __init axp_coreclk_init(struct device_node *np)\r\n{\r\nmvebu_coreclk_setup(np, &axp_coreclks);\r\n}\r\nstatic void __init axp_clk_gating_init(struct device_node *np)\r\n{\r\nmvebu_clk_gating_setup(np, axp_gating_desc);\r\n}
