static inline u32 udc_read(u32 reg)\r\n{\r\nreturn readb(base_addr + reg);\r\n}\r\nstatic inline void udc_write(u32 value, u32 reg)\r\n{\r\nwriteb(value, base_addr + reg);\r\n}\r\nstatic inline void udc_writeb(void __iomem *base, u32 value, u32 reg)\r\n{\r\nwriteb(value, base + reg);\r\n}\r\nstatic int dprintk(int level, const char *fmt, ...)\r\n{\r\nstatic char printk_buf[1024];\r\nstatic long prevticks;\r\nstatic int invocation;\r\nva_list args;\r\nint len;\r\nif (level > USB_S3C2410_DEBUG_LEVEL)\r\nreturn 0;\r\nif (s3c2410_ticks != prevticks) {\r\nprevticks = s3c2410_ticks;\r\ninvocation = 0;\r\n}\r\nlen = scnprintf(printk_buf,\r\nsizeof(printk_buf), "%1lu.%02d USB: ",\r\nprevticks, invocation++);\r\nva_start(args, fmt);\r\nlen = vscnprintf(printk_buf+len,\r\nsizeof(printk_buf)-len, fmt, args);\r\nva_end(args);\r\nreturn pr_debug("%s", printk_buf);\r\n}\r\nstatic int dprintk(int level, const char *fmt, ...)\r\n{\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_debugfs_seq_show(struct seq_file *m, void *p)\r\n{\r\nu32 addr_reg, pwr_reg, ep_int_reg, usb_int_reg;\r\nu32 ep_int_en_reg, usb_int_en_reg, ep0_csr;\r\nu32 ep1_i_csr1, ep1_i_csr2, ep1_o_csr1, ep1_o_csr2;\r\nu32 ep2_i_csr1, ep2_i_csr2, ep2_o_csr1, ep2_o_csr2;\r\naddr_reg = udc_read(S3C2410_UDC_FUNC_ADDR_REG);\r\npwr_reg = udc_read(S3C2410_UDC_PWR_REG);\r\nep_int_reg = udc_read(S3C2410_UDC_EP_INT_REG);\r\nusb_int_reg = udc_read(S3C2410_UDC_USB_INT_REG);\r\nep_int_en_reg = udc_read(S3C2410_UDC_EP_INT_EN_REG);\r\nusb_int_en_reg = udc_read(S3C2410_UDC_USB_INT_EN_REG);\r\nudc_write(0, S3C2410_UDC_INDEX_REG);\r\nep0_csr = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nudc_write(1, S3C2410_UDC_INDEX_REG);\r\nep1_i_csr1 = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nep1_i_csr2 = udc_read(S3C2410_UDC_IN_CSR2_REG);\r\nep1_o_csr1 = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nep1_o_csr2 = udc_read(S3C2410_UDC_IN_CSR2_REG);\r\nudc_write(2, S3C2410_UDC_INDEX_REG);\r\nep2_i_csr1 = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nep2_i_csr2 = udc_read(S3C2410_UDC_IN_CSR2_REG);\r\nep2_o_csr1 = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nep2_o_csr2 = udc_read(S3C2410_UDC_IN_CSR2_REG);\r\nseq_printf(m, "FUNC_ADDR_REG : 0x%04X\n"\r\n"PWR_REG : 0x%04X\n"\r\n"EP_INT_REG : 0x%04X\n"\r\n"USB_INT_REG : 0x%04X\n"\r\n"EP_INT_EN_REG : 0x%04X\n"\r\n"USB_INT_EN_REG : 0x%04X\n"\r\n"EP0_CSR : 0x%04X\n"\r\n"EP1_I_CSR1 : 0x%04X\n"\r\n"EP1_I_CSR2 : 0x%04X\n"\r\n"EP1_O_CSR1 : 0x%04X\n"\r\n"EP1_O_CSR2 : 0x%04X\n"\r\n"EP2_I_CSR1 : 0x%04X\n"\r\n"EP2_I_CSR2 : 0x%04X\n"\r\n"EP2_O_CSR1 : 0x%04X\n"\r\n"EP2_O_CSR2 : 0x%04X\n",\r\naddr_reg, pwr_reg, ep_int_reg, usb_int_reg,\r\nep_int_en_reg, usb_int_en_reg, ep0_csr,\r\nep1_i_csr1, ep1_i_csr2, ep1_o_csr1, ep1_o_csr2,\r\nep2_i_csr1, ep2_i_csr2, ep2_o_csr1, ep2_o_csr2\r\n);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_debugfs_fops_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nreturn single_open(file, s3c2410_udc_debugfs_seq_show, NULL);\r\n}\r\nstatic inline void s3c2410_udc_clear_ep0_opr(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, S3C2410_UDC_EP0_CSR_SOPKTRDY,\r\nS3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_clear_ep0_sst(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nwriteb(0x00, base + S3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_clear_ep0_se(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, S3C2410_UDC_EP0_CSR_SSE, S3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_set_ep0_ipr(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, S3C2410_UDC_EP0_CSR_IPKRDY, S3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_set_ep0_de(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, S3C2410_UDC_EP0_CSR_DE, S3C2410_UDC_EP0_CSR_REG);\r\n}\r\ninline void s3c2410_udc_set_ep0_ss(void __iomem *b)\r\n{\r\nudc_writeb(b, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(b, S3C2410_UDC_EP0_CSR_SENDSTL, S3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_set_ep0_de_out(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, (S3C2410_UDC_EP0_CSR_SOPKTRDY\r\n| S3C2410_UDC_EP0_CSR_DE),\r\nS3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_set_ep0_sse_out(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, (S3C2410_UDC_EP0_CSR_SOPKTRDY\r\n| S3C2410_UDC_EP0_CSR_SSE),\r\nS3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic inline void s3c2410_udc_set_ep0_de_in(void __iomem *base)\r\n{\r\nudc_writeb(base, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nudc_writeb(base, (S3C2410_UDC_EP0_CSR_IPKRDY\r\n| S3C2410_UDC_EP0_CSR_DE),\r\nS3C2410_UDC_EP0_CSR_REG);\r\n}\r\nstatic void s3c2410_udc_done(struct s3c2410_ep *ep,\r\nstruct s3c2410_request *req, int status)\r\n{\r\nunsigned halted = ep->halted;\r\nlist_del_init(&req->queue);\r\nif (likely(req->req.status == -EINPROGRESS))\r\nreq->req.status = status;\r\nelse\r\nstatus = req->req.status;\r\nep->halted = 1;\r\nreq->req.complete(&ep->ep, &req->req);\r\nep->halted = halted;\r\n}\r\nstatic void s3c2410_udc_nuke(struct s3c2410_udc *udc,\r\nstruct s3c2410_ep *ep, int status)\r\n{\r\nif (&ep->queue == NULL)\r\nreturn;\r\nwhile (!list_empty(&ep->queue)) {\r\nstruct s3c2410_request *req;\r\nreq = list_entry(ep->queue.next, struct s3c2410_request,\r\nqueue);\r\ns3c2410_udc_done(ep, req, status);\r\n}\r\n}\r\nstatic inline void s3c2410_udc_clear_ep_state(struct s3c2410_udc *dev)\r\n{\r\nunsigned i;\r\nfor (i = 1; i < S3C2410_ENDPOINTS; i++)\r\ns3c2410_udc_nuke(dev, &dev->ep[i], -ECONNABORTED);\r\n}\r\nstatic inline int s3c2410_udc_fifo_count_out(void)\r\n{\r\nint tmp;\r\ntmp = udc_read(S3C2410_UDC_OUT_FIFO_CNT2_REG) << 8;\r\ntmp |= udc_read(S3C2410_UDC_OUT_FIFO_CNT1_REG);\r\nreturn tmp;\r\n}\r\nstatic inline int s3c2410_udc_write_packet(int fifo,\r\nstruct s3c2410_request *req,\r\nunsigned max)\r\n{\r\nunsigned len = min(req->req.length - req->req.actual, max);\r\nu8 *buf = req->req.buf + req->req.actual;\r\nprefetch(buf);\r\ndprintk(DEBUG_VERBOSE, "%s %d %d %d %d\n", __func__,\r\nreq->req.actual, req->req.length, len, req->req.actual + len);\r\nreq->req.actual += len;\r\nudelay(5);\r\nwritesb(base_addr + fifo, buf, len);\r\nreturn len;\r\n}\r\nstatic int s3c2410_udc_write_fifo(struct s3c2410_ep *ep,\r\nstruct s3c2410_request *req)\r\n{\r\nunsigned count;\r\nint is_last;\r\nu32 idx;\r\nint fifo_reg;\r\nu32 ep_csr;\r\nidx = ep->bEndpointAddress & 0x7F;\r\nswitch (idx) {\r\ndefault:\r\nidx = 0;\r\ncase 0:\r\nfifo_reg = S3C2410_UDC_EP0_FIFO_REG;\r\nbreak;\r\ncase 1:\r\nfifo_reg = S3C2410_UDC_EP1_FIFO_REG;\r\nbreak;\r\ncase 2:\r\nfifo_reg = S3C2410_UDC_EP2_FIFO_REG;\r\nbreak;\r\ncase 3:\r\nfifo_reg = S3C2410_UDC_EP3_FIFO_REG;\r\nbreak;\r\ncase 4:\r\nfifo_reg = S3C2410_UDC_EP4_FIFO_REG;\r\nbreak;\r\n}\r\ncount = s3c2410_udc_write_packet(fifo_reg, req, ep->ep.maxpacket);\r\nif (count != ep->ep.maxpacket)\r\nis_last = 1;\r\nelse if (req->req.length != req->req.actual || req->req.zero)\r\nis_last = 0;\r\nelse\r\nis_last = 2;\r\nif (idx == 0)\r\ndprintk(DEBUG_NORMAL,\r\n"Written ep%d %d.%d of %d b [last %d,z %d]\n",\r\nidx, count, req->req.actual, req->req.length,\r\nis_last, req->req.zero);\r\nif (is_last) {\r\nif (idx == 0) {\r\nif (!(udc_read(S3C2410_UDC_USB_INT_REG)\r\n& S3C2410_UDC_USBINT_RESET))\r\ns3c2410_udc_set_ep0_de_in(base_addr);\r\nep->dev->ep0state = EP0_IDLE;\r\n} else {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nudc_write(ep_csr | S3C2410_UDC_ICSR1_PKTRDY,\r\nS3C2410_UDC_IN_CSR1_REG);\r\n}\r\ns3c2410_udc_done(ep, req, 0);\r\nis_last = 1;\r\n} else {\r\nif (idx == 0) {\r\nif (!(udc_read(S3C2410_UDC_USB_INT_REG)\r\n& S3C2410_UDC_USBINT_RESET))\r\ns3c2410_udc_set_ep0_ipr(base_addr);\r\n} else {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nudc_write(ep_csr | S3C2410_UDC_ICSR1_PKTRDY,\r\nS3C2410_UDC_IN_CSR1_REG);\r\n}\r\n}\r\nreturn is_last;\r\n}\r\nstatic inline int s3c2410_udc_read_packet(int fifo, u8 *buf,\r\nstruct s3c2410_request *req, unsigned avail)\r\n{\r\nunsigned len;\r\nlen = min(req->req.length - req->req.actual, avail);\r\nreq->req.actual += len;\r\nreadsb(fifo + base_addr, buf, len);\r\nreturn len;\r\n}\r\nstatic int s3c2410_udc_read_fifo(struct s3c2410_ep *ep,\r\nstruct s3c2410_request *req)\r\n{\r\nu8 *buf;\r\nu32 ep_csr;\r\nunsigned bufferspace;\r\nint is_last = 1;\r\nunsigned avail;\r\nint fifo_count = 0;\r\nu32 idx;\r\nint fifo_reg;\r\nidx = ep->bEndpointAddress & 0x7F;\r\nswitch (idx) {\r\ndefault:\r\nidx = 0;\r\ncase 0:\r\nfifo_reg = S3C2410_UDC_EP0_FIFO_REG;\r\nbreak;\r\ncase 1:\r\nfifo_reg = S3C2410_UDC_EP1_FIFO_REG;\r\nbreak;\r\ncase 2:\r\nfifo_reg = S3C2410_UDC_EP2_FIFO_REG;\r\nbreak;\r\ncase 3:\r\nfifo_reg = S3C2410_UDC_EP3_FIFO_REG;\r\nbreak;\r\ncase 4:\r\nfifo_reg = S3C2410_UDC_EP4_FIFO_REG;\r\nbreak;\r\n}\r\nif (!req->req.length)\r\nreturn 1;\r\nbuf = req->req.buf + req->req.actual;\r\nbufferspace = req->req.length - req->req.actual;\r\nif (!bufferspace) {\r\ndprintk(DEBUG_NORMAL, "%s: buffer full!\n", __func__);\r\nreturn -1;\r\n}\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nfifo_count = s3c2410_udc_fifo_count_out();\r\ndprintk(DEBUG_NORMAL, "%s fifo count : %d\n", __func__, fifo_count);\r\nif (fifo_count > ep->ep.maxpacket)\r\navail = ep->ep.maxpacket;\r\nelse\r\navail = fifo_count;\r\nfifo_count = s3c2410_udc_read_packet(fifo_reg, buf, req, avail);\r\nif (idx != 0 && fifo_count < ep->ep.maxpacket) {\r\nis_last = 1;\r\nif (fifo_count != avail)\r\nreq->req.status = -EOVERFLOW;\r\n} else {\r\nis_last = (req->req.length <= req->req.actual) ? 1 : 0;\r\n}\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nfifo_count = s3c2410_udc_fifo_count_out();\r\nif (idx == 0)\r\ndprintk(DEBUG_VERBOSE, "%s fifo count : %d [last %d]\n",\r\n__func__, fifo_count, is_last);\r\nif (is_last) {\r\nif (idx == 0) {\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\nep->dev->ep0state = EP0_IDLE;\r\n} else {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read(S3C2410_UDC_OUT_CSR1_REG);\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nudc_write(ep_csr & ~S3C2410_UDC_OCSR1_PKTRDY,\r\nS3C2410_UDC_OUT_CSR1_REG);\r\n}\r\ns3c2410_udc_done(ep, req, 0);\r\n} else {\r\nif (idx == 0) {\r\ns3c2410_udc_clear_ep0_opr(base_addr);\r\n} else {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read(S3C2410_UDC_OUT_CSR1_REG);\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nudc_write(ep_csr & ~S3C2410_UDC_OCSR1_PKTRDY,\r\nS3C2410_UDC_OUT_CSR1_REG);\r\n}\r\n}\r\nreturn is_last;\r\n}\r\nstatic int s3c2410_udc_read_fifo_crq(struct usb_ctrlrequest *crq)\r\n{\r\nunsigned char *outbuf = (unsigned char *)crq;\r\nint bytes_read = 0;\r\nudc_write(0, S3C2410_UDC_INDEX_REG);\r\nbytes_read = s3c2410_udc_fifo_count_out();\r\ndprintk(DEBUG_NORMAL, "%s: fifo_count=%d\n", __func__, bytes_read);\r\nif (bytes_read > sizeof(struct usb_ctrlrequest))\r\nbytes_read = sizeof(struct usb_ctrlrequest);\r\nreadsb(S3C2410_UDC_EP0_FIFO_REG + base_addr, outbuf, bytes_read);\r\ndprintk(DEBUG_VERBOSE, "%s: len=%d %02x:%02x {%x,%x,%x}\n", __func__,\r\nbytes_read, crq->bRequest, crq->bRequestType,\r\ncrq->wValue, crq->wIndex, crq->wLength);\r\nreturn bytes_read;\r\n}\r\nstatic int s3c2410_udc_get_status(struct s3c2410_udc *dev,\r\nstruct usb_ctrlrequest *crq)\r\n{\r\nu16 status = 0;\r\nu8 ep_num = crq->wIndex & 0x7F;\r\nu8 is_in = crq->wIndex & USB_DIR_IN;\r\nswitch (crq->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_INTERFACE:\r\nbreak;\r\ncase USB_RECIP_DEVICE:\r\nstatus = dev->devstatus;\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nif (ep_num > 4 || crq->wLength > 2)\r\nreturn 1;\r\nif (ep_num == 0) {\r\nudc_write(0, S3C2410_UDC_INDEX_REG);\r\nstatus = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nstatus = status & S3C2410_UDC_EP0_CSR_SENDSTL;\r\n} else {\r\nudc_write(ep_num, S3C2410_UDC_INDEX_REG);\r\nif (is_in) {\r\nstatus = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nstatus = status & S3C2410_UDC_ICSR1_SENDSTL;\r\n} else {\r\nstatus = udc_read(S3C2410_UDC_OUT_CSR1_REG);\r\nstatus = status & S3C2410_UDC_OCSR1_SENDSTL;\r\n}\r\n}\r\nstatus = status ? 1 : 0;\r\nbreak;\r\ndefault:\r\nreturn 1;\r\n}\r\nudelay(5);\r\nudc_write(status & 0xFF, S3C2410_UDC_EP0_FIFO_REG);\r\nudc_write(status >> 8, S3C2410_UDC_EP0_FIFO_REG);\r\ns3c2410_udc_set_ep0_de_in(base_addr);\r\nreturn 0;\r\n}\r\nstatic void s3c2410_udc_handle_ep0_idle(struct s3c2410_udc *dev,\r\nstruct s3c2410_ep *ep,\r\nstruct usb_ctrlrequest *crq,\r\nu32 ep0csr)\r\n{\r\nint len, ret, tmp;\r\nif (!(ep0csr & S3C2410_UDC_EP0_CSR_OPKRDY))\r\nreturn;\r\ns3c2410_udc_nuke(dev, ep, -EPROTO);\r\nlen = s3c2410_udc_read_fifo_crq(crq);\r\nif (len != sizeof(*crq)) {\r\ndprintk(DEBUG_NORMAL, "setup begin: fifo READ ERROR"\r\n" wanted %d bytes got %d. Stalling out...\n",\r\nsizeof(*crq), len);\r\ns3c2410_udc_set_ep0_ss(base_addr);\r\nreturn;\r\n}\r\ndprintk(DEBUG_NORMAL, "bRequest = %d bRequestType %d wLength = %d\n",\r\ncrq->bRequest, crq->bRequestType, crq->wLength);\r\ndev->req_std = (crq->bRequestType & USB_TYPE_MASK)\r\n== USB_TYPE_STANDARD;\r\ndev->req_config = 0;\r\ndev->req_pending = 1;\r\nswitch (crq->bRequest) {\r\ncase USB_REQ_SET_CONFIGURATION:\r\ndprintk(DEBUG_NORMAL, "USB_REQ_SET_CONFIGURATION ...\n");\r\nif (crq->bRequestType == USB_RECIP_DEVICE) {\r\ndev->req_config = 1;\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\n}\r\nbreak;\r\ncase USB_REQ_SET_INTERFACE:\r\ndprintk(DEBUG_NORMAL, "USB_REQ_SET_INTERFACE ...\n");\r\nif (crq->bRequestType == USB_RECIP_INTERFACE) {\r\ndev->req_config = 1;\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\n}\r\nbreak;\r\ncase USB_REQ_SET_ADDRESS:\r\ndprintk(DEBUG_NORMAL, "USB_REQ_SET_ADDRESS ...\n");\r\nif (crq->bRequestType == USB_RECIP_DEVICE) {\r\ntmp = crq->wValue & 0x7F;\r\ndev->address = tmp;\r\nudc_write((tmp | S3C2410_UDC_FUNCADDR_UPDATE),\r\nS3C2410_UDC_FUNC_ADDR_REG);\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\nreturn;\r\n}\r\nbreak;\r\ncase USB_REQ_GET_STATUS:\r\ndprintk(DEBUG_NORMAL, "USB_REQ_GET_STATUS ...\n");\r\ns3c2410_udc_clear_ep0_opr(base_addr);\r\nif (dev->req_std) {\r\nif (!s3c2410_udc_get_status(dev, crq))\r\nreturn;\r\n}\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ns3c2410_udc_clear_ep0_opr(base_addr);\r\nif (crq->bRequestType != USB_RECIP_ENDPOINT)\r\nbreak;\r\nif (crq->wValue != USB_ENDPOINT_HALT || crq->wLength != 0)\r\nbreak;\r\ns3c2410_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 0);\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\nreturn;\r\ncase USB_REQ_SET_FEATURE:\r\ns3c2410_udc_clear_ep0_opr(base_addr);\r\nif (crq->bRequestType != USB_RECIP_ENDPOINT)\r\nbreak;\r\nif (crq->wValue != USB_ENDPOINT_HALT || crq->wLength != 0)\r\nbreak;\r\ns3c2410_udc_set_halt(&dev->ep[crq->wIndex & 0x7f].ep, 1);\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\nreturn;\r\ndefault:\r\ns3c2410_udc_clear_ep0_opr(base_addr);\r\nbreak;\r\n}\r\nif (crq->bRequestType & USB_DIR_IN)\r\ndev->ep0state = EP0_IN_DATA_PHASE;\r\nelse\r\ndev->ep0state = EP0_OUT_DATA_PHASE;\r\nif (!dev->driver)\r\nreturn;\r\nret = dev->driver->setup(&dev->gadget, crq);\r\nif (ret < 0) {\r\nif (dev->req_config) {\r\ndprintk(DEBUG_NORMAL, "config change %02x fail %d?\n",\r\ncrq->bRequest, ret);\r\nreturn;\r\n}\r\nif (ret == -EOPNOTSUPP)\r\ndprintk(DEBUG_NORMAL, "Operation not supported\n");\r\nelse\r\ndprintk(DEBUG_NORMAL,\r\n"dev->driver->setup failed. (%d)\n", ret);\r\nudelay(5);\r\ns3c2410_udc_set_ep0_ss(base_addr);\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\ndev->ep0state = EP0_IDLE;\r\n} else if (dev->req_pending) {\r\ndprintk(DEBUG_VERBOSE, "dev->req_pending... what now?\n");\r\ndev->req_pending = 0;\r\n}\r\ndprintk(DEBUG_VERBOSE, "ep0state %s\n", ep0states[dev->ep0state]);\r\n}\r\nstatic void s3c2410_udc_handle_ep0(struct s3c2410_udc *dev)\r\n{\r\nu32 ep0csr;\r\nstruct s3c2410_ep *ep = &dev->ep[0];\r\nstruct s3c2410_request *req;\r\nstruct usb_ctrlrequest crq;\r\nif (list_empty(&ep->queue))\r\nreq = NULL;\r\nelse\r\nreq = list_entry(ep->queue.next, struct s3c2410_request, queue);\r\nudc_write(0, S3C2410_UDC_INDEX_REG);\r\nep0csr = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\ndprintk(DEBUG_NORMAL, "ep0csr %x ep0state %s\n",\r\nep0csr, ep0states[dev->ep0state]);\r\nif (ep0csr & S3C2410_UDC_EP0_CSR_SENTSTL) {\r\ns3c2410_udc_nuke(dev, ep, -EPIPE);\r\ndprintk(DEBUG_NORMAL, "... clear SENT_STALL ...\n");\r\ns3c2410_udc_clear_ep0_sst(base_addr);\r\ndev->ep0state = EP0_IDLE;\r\nreturn;\r\n}\r\nif (ep0csr & S3C2410_UDC_EP0_CSR_SE) {\r\ndprintk(DEBUG_NORMAL, "... serviced SETUP_END ...\n");\r\ns3c2410_udc_nuke(dev, ep, 0);\r\ns3c2410_udc_clear_ep0_se(base_addr);\r\ndev->ep0state = EP0_IDLE;\r\n}\r\nswitch (dev->ep0state) {\r\ncase EP0_IDLE:\r\ns3c2410_udc_handle_ep0_idle(dev, ep, &crq, ep0csr);\r\nbreak;\r\ncase EP0_IN_DATA_PHASE:\r\ndprintk(DEBUG_NORMAL, "EP0_IN_DATA_PHASE ... what now?\n");\r\nif (!(ep0csr & S3C2410_UDC_EP0_CSR_IPKRDY) && req)\r\ns3c2410_udc_write_fifo(ep, req);\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\ndprintk(DEBUG_NORMAL, "EP0_OUT_DATA_PHASE ... what now?\n");\r\nif ((ep0csr & S3C2410_UDC_EP0_CSR_OPKRDY) && req)\r\ns3c2410_udc_read_fifo(ep, req);\r\nbreak;\r\ncase EP0_END_XFER:\r\ndprintk(DEBUG_NORMAL, "EP0_END_XFER ... what now?\n");\r\ndev->ep0state = EP0_IDLE;\r\nbreak;\r\ncase EP0_STALL:\r\ndprintk(DEBUG_NORMAL, "EP0_STALL ... what now?\n");\r\ndev->ep0state = EP0_IDLE;\r\nbreak;\r\n}\r\n}\r\nstatic void s3c2410_udc_handle_ep(struct s3c2410_ep *ep)\r\n{\r\nstruct s3c2410_request *req;\r\nint is_in = ep->bEndpointAddress & USB_DIR_IN;\r\nu32 ep_csr1;\r\nu32 idx;\r\nif (likely(!list_empty(&ep->queue)))\r\nreq = list_entry(ep->queue.next,\r\nstruct s3c2410_request, queue);\r\nelse\r\nreq = NULL;\r\nidx = ep->bEndpointAddress & 0x7F;\r\nif (is_in) {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr1 = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\ndprintk(DEBUG_VERBOSE, "ep%01d write csr:%02x %d\n",\r\nidx, ep_csr1, req ? 1 : 0);\r\nif (ep_csr1 & S3C2410_UDC_ICSR1_SENTSTL) {\r\ndprintk(DEBUG_VERBOSE, "st\n");\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nudc_write(ep_csr1 & ~S3C2410_UDC_ICSR1_SENTSTL,\r\nS3C2410_UDC_IN_CSR1_REG);\r\nreturn;\r\n}\r\nif (!(ep_csr1 & S3C2410_UDC_ICSR1_PKTRDY) && req)\r\ns3c2410_udc_write_fifo(ep, req);\r\n} else {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr1 = udc_read(S3C2410_UDC_OUT_CSR1_REG);\r\ndprintk(DEBUG_VERBOSE, "ep%01d rd csr:%02x\n", idx, ep_csr1);\r\nif (ep_csr1 & S3C2410_UDC_OCSR1_SENTSTL) {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nudc_write(ep_csr1 & ~S3C2410_UDC_OCSR1_SENTSTL,\r\nS3C2410_UDC_OUT_CSR1_REG);\r\nreturn;\r\n}\r\nif ((ep_csr1 & S3C2410_UDC_OCSR1_PKTRDY) && req)\r\ns3c2410_udc_read_fifo(ep, req);\r\n}\r\n}\r\nstatic irqreturn_t s3c2410_udc_irq(int dummy, void *_dev)\r\n{\r\nstruct s3c2410_udc *dev = _dev;\r\nint usb_status;\r\nint usbd_status;\r\nint pwr_reg;\r\nint ep0csr;\r\nint i;\r\nu32 idx, idx2;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (!dev->driver) {\r\nudc_write(udc_read(S3C2410_UDC_USB_INT_REG),\r\nS3C2410_UDC_USB_INT_REG);\r\nudc_write(udc_read(S3C2410_UDC_EP_INT_REG),\r\nS3C2410_UDC_EP_INT_REG);\r\n}\r\nidx = udc_read(S3C2410_UDC_INDEX_REG);\r\nusb_status = udc_read(S3C2410_UDC_USB_INT_REG);\r\nusbd_status = udc_read(S3C2410_UDC_EP_INT_REG);\r\npwr_reg = udc_read(S3C2410_UDC_PWR_REG);\r\nudc_writeb(base_addr, S3C2410_UDC_INDEX_EP0, S3C2410_UDC_INDEX_REG);\r\nep0csr = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\ndprintk(DEBUG_NORMAL, "usbs=%02x, usbds=%02x, pwr=%02x ep0csr=%02x\n",\r\nusb_status, usbd_status, pwr_reg, ep0csr);\r\nif (usb_status & S3C2410_UDC_USBINT_RESET) {\r\ndprintk(DEBUG_NORMAL, "USB reset csr %x pwr %x\n",\r\nep0csr, pwr_reg);\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\nudc_write(0x00, S3C2410_UDC_INDEX_REG);\r\nudc_write((dev->ep[0].ep.maxpacket & 0x7ff) >> 3,\r\nS3C2410_UDC_MAXP_REG);\r\ndev->address = 0;\r\ndev->ep0state = EP0_IDLE;\r\ndev->gadget.speed = USB_SPEED_FULL;\r\nudc_write(S3C2410_UDC_USBINT_RESET,\r\nS3C2410_UDC_USB_INT_REG);\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (usb_status & S3C2410_UDC_USBINT_RESUME) {\r\ndprintk(DEBUG_NORMAL, "USB resume\n");\r\nudc_write(S3C2410_UDC_USBINT_RESUME,\r\nS3C2410_UDC_USB_INT_REG);\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN\r\n&& dev->driver\r\n&& dev->driver->resume)\r\ndev->driver->resume(&dev->gadget);\r\n}\r\nif (usb_status & S3C2410_UDC_USBINT_SUSPEND) {\r\ndprintk(DEBUG_NORMAL, "USB suspend\n");\r\nudc_write(S3C2410_UDC_USBINT_SUSPEND,\r\nS3C2410_UDC_USB_INT_REG);\r\nif (dev->gadget.speed != USB_SPEED_UNKNOWN\r\n&& dev->driver\r\n&& dev->driver->suspend)\r\ndev->driver->suspend(&dev->gadget);\r\ndev->ep0state = EP0_IDLE;\r\n}\r\nif (usbd_status & S3C2410_UDC_INT_EP0) {\r\ndprintk(DEBUG_VERBOSE, "USB ep0 irq\n");\r\nudc_write(S3C2410_UDC_INT_EP0, S3C2410_UDC_EP_INT_REG);\r\ns3c2410_udc_handle_ep0(dev);\r\n}\r\nfor (i = 1; i < S3C2410_ENDPOINTS; i++) {\r\nu32 tmp = 1 << i;\r\nif (usbd_status & tmp) {\r\ndprintk(DEBUG_VERBOSE, "USB ep%d irq\n", i);\r\nudc_write(tmp, S3C2410_UDC_EP_INT_REG);\r\ns3c2410_udc_handle_ep(&dev->ep[i]);\r\n}\r\n}\r\nif (!usb_status && !usbd_status && !pwr_reg && !ep0csr) {\r\nfor (i = 1; i < S3C2410_ENDPOINTS; i++) {\r\nidx2 = udc_read(S3C2410_UDC_INDEX_REG);\r\nudc_write(i, S3C2410_UDC_INDEX_REG);\r\nif (udc_read(S3C2410_UDC_OUT_CSR1_REG) & 0x1)\r\ns3c2410_udc_handle_ep(&dev->ep[i]);\r\nudc_write(idx2, S3C2410_UDC_INDEX_REG);\r\n}\r\n}\r\ndprintk(DEBUG_VERBOSE, "irq: %d s3c2410_udc_done.\n", IRQ_USBD);\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline struct s3c2410_ep *to_s3c2410_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct s3c2410_ep, ep);\r\n}\r\nstatic inline struct s3c2410_udc *to_s3c2410_udc(struct usb_gadget *gadget)\r\n{\r\nreturn container_of(gadget, struct s3c2410_udc, gadget);\r\n}\r\nstatic inline struct s3c2410_request *to_s3c2410_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct s3c2410_request, req);\r\n}\r\nstatic int s3c2410_udc_ep_enable(struct usb_ep *_ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct s3c2410_udc *dev;\r\nstruct s3c2410_ep *ep;\r\nu32 max, tmp;\r\nunsigned long flags;\r\nu32 csr1, csr2;\r\nu32 int_en_reg;\r\nep = to_s3c2410_ep(_ep);\r\nif (!_ep || !desc\r\n|| _ep->name == ep0name\r\n|| desc->bDescriptorType != USB_DT_ENDPOINT)\r\nreturn -EINVAL;\r\ndev = ep->dev;\r\nif (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)\r\nreturn -ESHUTDOWN;\r\nmax = usb_endpoint_maxp(desc) & 0x1fff;\r\nlocal_irq_save(flags);\r\n_ep->maxpacket = max & 0x7ff;\r\nep->ep.desc = desc;\r\nep->halted = 0;\r\nep->bEndpointAddress = desc->bEndpointAddress;\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(max >> 3, S3C2410_UDC_MAXP_REG);\r\nif (desc->bEndpointAddress & USB_DIR_IN) {\r\ncsr1 = S3C2410_UDC_ICSR1_FFLUSH|S3C2410_UDC_ICSR1_CLRDT;\r\ncsr2 = S3C2410_UDC_ICSR2_MODEIN|S3C2410_UDC_ICSR2_DMAIEN;\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(csr1, S3C2410_UDC_IN_CSR1_REG);\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(csr2, S3C2410_UDC_IN_CSR2_REG);\r\n} else {\r\ncsr1 = S3C2410_UDC_ICSR1_CLRDT;\r\ncsr2 = S3C2410_UDC_ICSR2_DMAIEN;\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(csr1, S3C2410_UDC_IN_CSR1_REG);\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(csr2, S3C2410_UDC_IN_CSR2_REG);\r\ncsr1 = S3C2410_UDC_OCSR1_FFLUSH | S3C2410_UDC_OCSR1_CLRDT;\r\ncsr2 = S3C2410_UDC_OCSR2_DMAIEN;\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(csr1, S3C2410_UDC_OUT_CSR1_REG);\r\nudc_write(ep->num, S3C2410_UDC_INDEX_REG);\r\nudc_write(csr2, S3C2410_UDC_OUT_CSR2_REG);\r\n}\r\nint_en_reg = udc_read(S3C2410_UDC_EP_INT_EN_REG);\r\nudc_write(int_en_reg | (1 << ep->num), S3C2410_UDC_EP_INT_EN_REG);\r\ntmp = desc->bEndpointAddress;\r\ndprintk(DEBUG_NORMAL, "enable %s(%d) ep%x%s-blk max %02x\n",\r\n_ep->name, ep->num, tmp,\r\ndesc->bEndpointAddress & USB_DIR_IN ? "in" : "out", max);\r\nlocal_irq_restore(flags);\r\ns3c2410_udc_set_halt(_ep, 0);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_ep_disable(struct usb_ep *_ep)\r\n{\r\nstruct s3c2410_ep *ep = to_s3c2410_ep(_ep);\r\nunsigned long flags;\r\nu32 int_en_reg;\r\nif (!_ep || !ep->ep.desc) {\r\ndprintk(DEBUG_NORMAL, "%s not enabled\n",\r\n_ep ? ep->ep.name : NULL);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\ndprintk(DEBUG_NORMAL, "ep_disable: %s\n", _ep->name);\r\nep->ep.desc = NULL;\r\nep->halted = 1;\r\ns3c2410_udc_nuke(ep->dev, ep, -ESHUTDOWN);\r\nint_en_reg = udc_read(S3C2410_UDC_EP_INT_EN_REG);\r\nudc_write(int_en_reg & ~(1<<ep->num), S3C2410_UDC_EP_INT_EN_REG);\r\nlocal_irq_restore(flags);\r\ndprintk(DEBUG_NORMAL, "%s disabled\n", _ep->name);\r\nreturn 0;\r\n}\r\nstatic struct usb_request *\r\ns3c2410_udc_alloc_request(struct usb_ep *_ep, gfp_t mem_flags)\r\n{\r\nstruct s3c2410_request *req;\r\ndprintk(DEBUG_VERBOSE, "%s(%p,%d)\n", __func__, _ep, mem_flags);\r\nif (!_ep)\r\nreturn NULL;\r\nreq = kzalloc(sizeof(struct s3c2410_request), mem_flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic void\r\ns3c2410_udc_free_request(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct s3c2410_ep *ep = to_s3c2410_ep(_ep);\r\nstruct s3c2410_request *req = to_s3c2410_req(_req);\r\ndprintk(DEBUG_VERBOSE, "%s(%p,%p)\n", __func__, _ep, _req);\r\nif (!ep || !_req || (!ep->ep.desc && _ep->name != ep0name))\r\nreturn;\r\nWARN_ON(!list_empty(&req->queue));\r\nkfree(req);\r\n}\r\nstatic int s3c2410_udc_queue(struct usb_ep *_ep, struct usb_request *_req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct s3c2410_request *req = to_s3c2410_req(_req);\r\nstruct s3c2410_ep *ep = to_s3c2410_ep(_ep);\r\nstruct s3c2410_udc *dev;\r\nu32 ep_csr = 0;\r\nint fifo_count = 0;\r\nunsigned long flags;\r\nif (unlikely(!_ep || (!ep->ep.desc && ep->ep.name != ep0name))) {\r\ndprintk(DEBUG_NORMAL, "%s: invalid args\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndev = ep->dev;\r\nif (unlikely(!dev->driver\r\n|| dev->gadget.speed == USB_SPEED_UNKNOWN)) {\r\nreturn -ESHUTDOWN;\r\n}\r\nlocal_irq_save(flags);\r\nif (unlikely(!_req || !_req->complete\r\n|| !_req->buf || !list_empty(&req->queue))) {\r\nif (!_req)\r\ndprintk(DEBUG_NORMAL, "%s: 1 X X X\n", __func__);\r\nelse {\r\ndprintk(DEBUG_NORMAL, "%s: 0 %01d %01d %01d\n",\r\n__func__, !_req->complete, !_req->buf,\r\n!list_empty(&req->queue));\r\n}\r\nlocal_irq_restore(flags);\r\nreturn -EINVAL;\r\n}\r\n_req->status = -EINPROGRESS;\r\n_req->actual = 0;\r\ndprintk(DEBUG_VERBOSE, "%s: ep%x len %d\n",\r\n__func__, ep->bEndpointAddress, _req->length);\r\nif (ep->bEndpointAddress) {\r\nudc_write(ep->bEndpointAddress & 0x7F, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read((ep->bEndpointAddress & USB_DIR_IN)\r\n? S3C2410_UDC_IN_CSR1_REG\r\n: S3C2410_UDC_OUT_CSR1_REG);\r\nfifo_count = s3c2410_udc_fifo_count_out();\r\n} else {\r\nudc_write(0, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read(S3C2410_UDC_IN_CSR1_REG);\r\nfifo_count = s3c2410_udc_fifo_count_out();\r\n}\r\nif (list_empty(&ep->queue) && !ep->halted) {\r\nif (ep->bEndpointAddress == 0 ) {\r\nswitch (dev->ep0state) {\r\ncase EP0_IN_DATA_PHASE:\r\nif (!(ep_csr&S3C2410_UDC_EP0_CSR_IPKRDY)\r\n&& s3c2410_udc_write_fifo(ep,\r\nreq)) {\r\ndev->ep0state = EP0_IDLE;\r\nreq = NULL;\r\n}\r\nbreak;\r\ncase EP0_OUT_DATA_PHASE:\r\nif ((!_req->length)\r\n|| ((ep_csr & S3C2410_UDC_OCSR1_PKTRDY)\r\n&& s3c2410_udc_read_fifo(ep,\r\nreq))) {\r\ndev->ep0state = EP0_IDLE;\r\nreq = NULL;\r\n}\r\nbreak;\r\ndefault:\r\nlocal_irq_restore(flags);\r\nreturn -EL2HLT;\r\n}\r\n} else if ((ep->bEndpointAddress & USB_DIR_IN) != 0\r\n&& (!(ep_csr&S3C2410_UDC_OCSR1_PKTRDY))\r\n&& s3c2410_udc_write_fifo(ep, req)) {\r\nreq = NULL;\r\n} else if ((ep_csr & S3C2410_UDC_OCSR1_PKTRDY)\r\n&& fifo_count\r\n&& s3c2410_udc_read_fifo(ep, req)) {\r\nreq = NULL;\r\n}\r\n}\r\nif (likely(req))\r\nlist_add_tail(&req->queue, &ep->queue);\r\nlocal_irq_restore(flags);\r\ndprintk(DEBUG_VERBOSE, "%s ok\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_dequeue(struct usb_ep *_ep, struct usb_request *_req)\r\n{\r\nstruct s3c2410_ep *ep = to_s3c2410_ep(_ep);\r\nstruct s3c2410_udc *udc;\r\nint retval = -EINVAL;\r\nunsigned long flags;\r\nstruct s3c2410_request *req = NULL;\r\ndprintk(DEBUG_VERBOSE, "%s(%p,%p)\n", __func__, _ep, _req);\r\nif (!the_controller->driver)\r\nreturn -ESHUTDOWN;\r\nif (!_ep || !_req)\r\nreturn retval;\r\nudc = to_s3c2410_udc(ep->gadget);\r\nlocal_irq_save(flags);\r\nlist_for_each_entry(req, &ep->queue, queue) {\r\nif (&req->req == _req) {\r\nlist_del_init(&req->queue);\r\n_req->status = -ECONNRESET;\r\nretval = 0;\r\nbreak;\r\n}\r\n}\r\nif (retval == 0) {\r\ndprintk(DEBUG_VERBOSE,\r\n"dequeued req %p from %s, len %d buf %p\n",\r\nreq, _ep->name, _req->length, _req->buf);\r\ns3c2410_udc_done(ep, req, -ECONNRESET);\r\n}\r\nlocal_irq_restore(flags);\r\nreturn retval;\r\n}\r\nstatic int s3c2410_udc_set_halt(struct usb_ep *_ep, int value)\r\n{\r\nstruct s3c2410_ep *ep = to_s3c2410_ep(_ep);\r\nu32 ep_csr = 0;\r\nunsigned long flags;\r\nu32 idx;\r\nif (unlikely(!_ep || (!ep->ep.desc && ep->ep.name != ep0name))) {\r\ndprintk(DEBUG_NORMAL, "%s: inval 2\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nidx = ep->bEndpointAddress & 0x7F;\r\nif (idx == 0) {\r\ns3c2410_udc_set_ep0_ss(base_addr);\r\ns3c2410_udc_set_ep0_de_out(base_addr);\r\n} else {\r\nudc_write(idx, S3C2410_UDC_INDEX_REG);\r\nep_csr = udc_read((ep->bEndpointAddress & USB_DIR_IN)\r\n? S3C2410_UDC_IN_CSR1_REG\r\n: S3C2410_UDC_OUT_CSR1_REG);\r\nif ((ep->bEndpointAddress & USB_DIR_IN) != 0) {\r\nif (value)\r\nudc_write(ep_csr | S3C2410_UDC_ICSR1_SENDSTL,\r\nS3C2410_UDC_IN_CSR1_REG);\r\nelse {\r\nep_csr &= ~S3C2410_UDC_ICSR1_SENDSTL;\r\nudc_write(ep_csr, S3C2410_UDC_IN_CSR1_REG);\r\nep_csr |= S3C2410_UDC_ICSR1_CLRDT;\r\nudc_write(ep_csr, S3C2410_UDC_IN_CSR1_REG);\r\n}\r\n} else {\r\nif (value)\r\nudc_write(ep_csr | S3C2410_UDC_OCSR1_SENDSTL,\r\nS3C2410_UDC_OUT_CSR1_REG);\r\nelse {\r\nep_csr &= ~S3C2410_UDC_OCSR1_SENDSTL;\r\nudc_write(ep_csr, S3C2410_UDC_OUT_CSR1_REG);\r\nep_csr |= S3C2410_UDC_OCSR1_CLRDT;\r\nudc_write(ep_csr, S3C2410_UDC_OUT_CSR1_REG);\r\n}\r\n}\r\n}\r\nep->halted = value ? 1 : 0;\r\nlocal_irq_restore(flags);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_get_frame(struct usb_gadget *_gadget)\r\n{\r\nint tmp;\r\ndprintk(DEBUG_VERBOSE, "%s()\n", __func__);\r\ntmp = udc_read(S3C2410_UDC_FRAME_NUM2_REG) << 8;\r\ntmp |= udc_read(S3C2410_UDC_FRAME_NUM1_REG);\r\nreturn tmp;\r\n}\r\nstatic int s3c2410_udc_wakeup(struct usb_gadget *_gadget)\r\n{\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_set_selfpowered(struct usb_gadget *gadget, int value)\r\n{\r\nstruct s3c2410_udc *udc = to_s3c2410_udc(gadget);\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nif (value)\r\nudc->devstatus |= (1 << USB_DEVICE_SELF_POWERED);\r\nelse\r\nudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_set_pullup(struct s3c2410_udc *udc, int is_on)\r\n{\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nif (udc_info && (udc_info->udc_command ||\r\ngpio_is_valid(udc_info->pullup_pin))) {\r\nif (is_on)\r\ns3c2410_udc_enable(udc);\r\nelse {\r\nif (udc->gadget.speed != USB_SPEED_UNKNOWN) {\r\nif (udc->driver && udc->driver->disconnect)\r\nudc->driver->disconnect(&udc->gadget);\r\n}\r\ns3c2410_udc_disable(udc);\r\n}\r\n} else {\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct s3c2410_udc *udc = to_s3c2410_udc(gadget);\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nudc->vbus = (is_active != 0);\r\ns3c2410_udc_set_pullup(udc, is_active);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct s3c2410_udc *udc = to_s3c2410_udc(gadget);\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\ns3c2410_udc_set_pullup(udc, is_on ? 0 : 1);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t s3c2410_udc_vbus_irq(int irq, void *_dev)\r\n{\r\nstruct s3c2410_udc *dev = _dev;\r\nunsigned int value;\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nvalue = gpio_get_value(udc_info->vbus_pin) ? 1 : 0;\r\nif (udc_info->vbus_pin_inverted)\r\nvalue = !value;\r\nif (value != dev->vbus)\r\ns3c2410_udc_vbus_session(&dev->gadget, value);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c2410_vbus_draw(struct usb_gadget *_gadget, unsigned ma)\r\n{\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nif (udc_info && udc_info->vbus_draw) {\r\nudc_info->vbus_draw(ma);\r\nreturn 0;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic void s3c2410_udc_command(enum s3c2410_udc_cmd_e cmd)\r\n{\r\nif (!udc_info)\r\nreturn;\r\nif (udc_info->udc_command) {\r\nudc_info->udc_command(cmd);\r\n} else if (gpio_is_valid(udc_info->pullup_pin)) {\r\nint value;\r\nswitch (cmd) {\r\ncase S3C2410_UDC_P_ENABLE:\r\nvalue = 1;\r\nbreak;\r\ncase S3C2410_UDC_P_DISABLE:\r\nvalue = 0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nvalue ^= udc_info->pullup_pin_inverted;\r\ngpio_set_value(udc_info->pullup_pin, value);\r\n}\r\n}\r\nstatic void s3c2410_udc_disable(struct s3c2410_udc *dev)\r\n{\r\ndprintk(DEBUG_NORMAL, "%s()\n", __func__);\r\nudc_write(0x00, S3C2410_UDC_USB_INT_EN_REG);\r\nudc_write(0x00, S3C2410_UDC_EP_INT_EN_REG);\r\nudc_write(S3C2410_UDC_USBINT_RESET\r\n| S3C2410_UDC_USBINT_RESUME\r\n| S3C2410_UDC_USBINT_SUSPEND,\r\nS3C2410_UDC_USB_INT_REG);\r\nudc_write(0x1F, S3C2410_UDC_EP_INT_REG);\r\ns3c2410_udc_command(S3C2410_UDC_P_DISABLE);\r\ndev->gadget.speed = USB_SPEED_UNKNOWN;\r\n}\r\nstatic void s3c2410_udc_reinit(struct s3c2410_udc *dev)\r\n{\r\nu32 i;\r\nINIT_LIST_HEAD(&dev->gadget.ep_list);\r\nINIT_LIST_HEAD(&dev->gadget.ep0->ep_list);\r\ndev->ep0state = EP0_IDLE;\r\nfor (i = 0; i < S3C2410_ENDPOINTS; i++) {\r\nstruct s3c2410_ep *ep = &dev->ep[i];\r\nif (i != 0)\r\nlist_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);\r\nep->dev = dev;\r\nep->ep.desc = NULL;\r\nep->halted = 0;\r\nINIT_LIST_HEAD(&ep->queue);\r\n}\r\n}\r\nstatic void s3c2410_udc_enable(struct s3c2410_udc *dev)\r\n{\r\nint i;\r\ndprintk(DEBUG_NORMAL, "s3c2410_udc_enable called\n");\r\ndev->gadget.speed = USB_SPEED_FULL;\r\nfor (i = 0; i < S3C2410_ENDPOINTS; i++) {\r\nudc_write(i, S3C2410_UDC_INDEX_REG);\r\nudc_write((dev->ep[i].ep.maxpacket & 0x7ff) >> 3,\r\nS3C2410_UDC_MAXP_REG);\r\n}\r\nudc_write(DEFAULT_POWER_STATE, S3C2410_UDC_PWR_REG);\r\nudc_write(S3C2410_UDC_USBINT_RESET | S3C2410_UDC_USBINT_SUSPEND,\r\nS3C2410_UDC_USB_INT_EN_REG);\r\nudc_write(S3C2410_UDC_INT_EP0, S3C2410_UDC_EP_INT_EN_REG);\r\ns3c2410_udc_command(S3C2410_UDC_P_ENABLE);\r\n}\r\nstatic int s3c2410_udc_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct s3c2410_udc *udc = to_s3c2410(g);\r\ndprintk(DEBUG_NORMAL, "%s() '%s'\n", __func__, driver->driver.name);\r\nudc->driver = driver;\r\ns3c2410_udc_enable(udc);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_stop(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct s3c2410_udc *udc = to_s3c2410(g);\r\nudc->driver = NULL;\r\ns3c2410_udc_disable(udc);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c2410_udc *udc = &memory;\r\nstruct device *dev = &pdev->dev;\r\nint retval;\r\nint irq;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nusb_bus_clock = clk_get(NULL, "usb-bus-gadget");\r\nif (IS_ERR(usb_bus_clock)) {\r\ndev_err(dev, "failed to get usb bus clock source\n");\r\nreturn PTR_ERR(usb_bus_clock);\r\n}\r\nclk_enable(usb_bus_clock);\r\nudc_clock = clk_get(NULL, "usb-device");\r\nif (IS_ERR(udc_clock)) {\r\ndev_err(dev, "failed to get udc clock source\n");\r\nreturn PTR_ERR(udc_clock);\r\n}\r\nclk_enable(udc_clock);\r\nmdelay(10);\r\ndev_dbg(dev, "got and enabled clocks\n");\r\nif (strncmp(pdev->name, "s3c2440", 7) == 0) {\r\ndev_info(dev, "S3C2440: increasing FIFO to 128 bytes\n");\r\nmemory.ep[1].fifo_size = S3C2440_EP_FIFO_SIZE;\r\nmemory.ep[2].fifo_size = S3C2440_EP_FIFO_SIZE;\r\nmemory.ep[3].fifo_size = S3C2440_EP_FIFO_SIZE;\r\nmemory.ep[4].fifo_size = S3C2440_EP_FIFO_SIZE;\r\n}\r\nspin_lock_init(&udc->lock);\r\nudc_info = dev_get_platdata(&pdev->dev);\r\nrsrc_start = S3C2410_PA_USBDEV;\r\nrsrc_len = S3C24XX_SZ_USBDEV;\r\nif (!request_mem_region(rsrc_start, rsrc_len, gadget_name))\r\nreturn -EBUSY;\r\nbase_addr = ioremap(rsrc_start, rsrc_len);\r\nif (!base_addr) {\r\nretval = -ENOMEM;\r\ngoto err_mem;\r\n}\r\nthe_controller = udc;\r\nplatform_set_drvdata(pdev, udc);\r\ns3c2410_udc_disable(udc);\r\ns3c2410_udc_reinit(udc);\r\nretval = request_irq(IRQ_USBD, s3c2410_udc_irq,\r\n0, gadget_name, udc);\r\nif (retval != 0) {\r\ndev_err(dev, "cannot get irq %i, err %d\n", IRQ_USBD, retval);\r\nretval = -EBUSY;\r\ngoto err_map;\r\n}\r\ndev_dbg(dev, "got irq %i\n", IRQ_USBD);\r\nif (udc_info && udc_info->vbus_pin > 0) {\r\nretval = gpio_request(udc_info->vbus_pin, "udc vbus");\r\nif (retval < 0) {\r\ndev_err(dev, "cannot claim vbus pin\n");\r\ngoto err_int;\r\n}\r\nirq = gpio_to_irq(udc_info->vbus_pin);\r\nif (irq < 0) {\r\ndev_err(dev, "no irq for gpio vbus pin\n");\r\nretval = irq;\r\ngoto err_gpio_claim;\r\n}\r\nretval = request_irq(irq, s3c2410_udc_vbus_irq,\r\nIRQF_TRIGGER_RISING\r\n| IRQF_TRIGGER_FALLING | IRQF_SHARED,\r\ngadget_name, udc);\r\nif (retval != 0) {\r\ndev_err(dev, "can't get vbus irq %d, err %d\n",\r\nirq, retval);\r\nretval = -EBUSY;\r\ngoto err_gpio_claim;\r\n}\r\ndev_dbg(dev, "got irq %i\n", irq);\r\n} else {\r\nudc->vbus = 1;\r\n}\r\nif (udc_info && !udc_info->udc_command &&\r\ngpio_is_valid(udc_info->pullup_pin)) {\r\nretval = gpio_request_one(udc_info->pullup_pin,\r\nudc_info->vbus_pin_inverted ?\r\nGPIOF_OUT_INIT_HIGH : GPIOF_OUT_INIT_LOW,\r\n"udc pullup");\r\nif (retval)\r\ngoto err_vbus_irq;\r\n}\r\nretval = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\r\nif (retval)\r\ngoto err_add_udc;\r\nif (s3c2410_udc_debugfs_root) {\r\nudc->regs_info = debugfs_create_file("registers", S_IRUGO,\r\ns3c2410_udc_debugfs_root,\r\nudc, &s3c2410_udc_debugfs_fops);\r\nif (!udc->regs_info)\r\ndev_warn(dev, "debugfs file creation failed\n");\r\n}\r\ndev_dbg(dev, "probe ok\n");\r\nreturn 0;\r\nerr_add_udc:\r\nif (udc_info && !udc_info->udc_command &&\r\ngpio_is_valid(udc_info->pullup_pin))\r\ngpio_free(udc_info->pullup_pin);\r\nerr_vbus_irq:\r\nif (udc_info && udc_info->vbus_pin > 0)\r\nfree_irq(gpio_to_irq(udc_info->vbus_pin), udc);\r\nerr_gpio_claim:\r\nif (udc_info && udc_info->vbus_pin > 0)\r\ngpio_free(udc_info->vbus_pin);\r\nerr_int:\r\nfree_irq(IRQ_USBD, udc);\r\nerr_map:\r\niounmap(base_addr);\r\nerr_mem:\r\nrelease_mem_region(rsrc_start, rsrc_len);\r\nreturn retval;\r\n}\r\nstatic int s3c2410_udc_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c2410_udc *udc = platform_get_drvdata(pdev);\r\nunsigned int irq;\r\ndev_dbg(&pdev->dev, "%s()\n", __func__);\r\nif (udc->driver)\r\nreturn -EBUSY;\r\nusb_del_gadget_udc(&udc->gadget);\r\ndebugfs_remove(udc->regs_info);\r\nif (udc_info && !udc_info->udc_command &&\r\ngpio_is_valid(udc_info->pullup_pin))\r\ngpio_free(udc_info->pullup_pin);\r\nif (udc_info && udc_info->vbus_pin > 0) {\r\nirq = gpio_to_irq(udc_info->vbus_pin);\r\nfree_irq(irq, udc);\r\n}\r\nfree_irq(IRQ_USBD, udc);\r\niounmap(base_addr);\r\nrelease_mem_region(rsrc_start, rsrc_len);\r\nif (!IS_ERR(udc_clock) && udc_clock != NULL) {\r\nclk_disable(udc_clock);\r\nclk_put(udc_clock);\r\nudc_clock = NULL;\r\n}\r\nif (!IS_ERR(usb_bus_clock) && usb_bus_clock != NULL) {\r\nclk_disable(usb_bus_clock);\r\nclk_put(usb_bus_clock);\r\nusb_bus_clock = NULL;\r\n}\r\ndev_dbg(&pdev->dev, "%s: remove ok\n", __func__);\r\nreturn 0;\r\n}\r\nstatic int\r\ns3c2410_udc_suspend(struct platform_device *pdev, pm_message_t message)\r\n{\r\ns3c2410_udc_command(S3C2410_UDC_P_DISABLE);\r\nreturn 0;\r\n}\r\nstatic int s3c2410_udc_resume(struct platform_device *pdev)\r\n{\r\ns3c2410_udc_command(S3C2410_UDC_P_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int __init udc_init(void)\r\n{\r\nint retval;\r\ndprintk(DEBUG_NORMAL, "%s: version %s\n", gadget_name, DRIVER_VERSION);\r\ns3c2410_udc_debugfs_root = debugfs_create_dir(gadget_name, NULL);\r\nif (IS_ERR(s3c2410_udc_debugfs_root)) {\r\npr_err("%s: debugfs dir creation failed %ld\n",\r\ngadget_name, PTR_ERR(s3c2410_udc_debugfs_root));\r\ns3c2410_udc_debugfs_root = NULL;\r\n}\r\nretval = platform_driver_register(&udc_driver_24x0);\r\nif (retval)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndebugfs_remove(s3c2410_udc_debugfs_root);\r\nreturn retval;\r\n}\r\nstatic void __exit udc_exit(void)\r\n{\r\nplatform_driver_unregister(&udc_driver_24x0);\r\ndebugfs_remove(s3c2410_udc_debugfs_root);\r\n}
