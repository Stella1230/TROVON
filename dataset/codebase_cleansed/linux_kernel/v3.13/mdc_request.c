int mdc_unpack_capa(struct obd_export *exp, struct ptlrpc_request *req,\r\nconst struct req_msg_field *field, struct obd_capa **oc)\r\n{\r\nstruct lustre_capa *capa;\r\nstruct obd_capa *c;\r\ncapa = req_capsule_server_get(&req->rq_pill, field);\r\nif (capa == NULL)\r\nreturn -EPROTO;\r\nc = alloc_capa(CAPA_SITE_CLIENT);\r\nif (IS_ERR(c)) {\r\nCDEBUG(D_INFO, "alloc capa failed!\n");\r\nreturn PTR_ERR(c);\r\n} else {\r\nc->c_capa = *capa;\r\n*oc = c;\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int mdc_queue_wait(struct ptlrpc_request *req)\r\n{\r\nstruct client_obd *cli = &req->rq_import->imp_obd->u.cli;\r\nint rc;\r\nrc = mdc_enter_request(cli);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_exit_request(cli);\r\nreturn rc;\r\n}\r\nstatic int send_getstatus(struct obd_import *imp, struct lu_fid *rootfid,\r\nstruct obd_capa **pc, int level, int msg_flags)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mdt_body *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_GETSTATUS,\r\nLUSTRE_MDS_VERSION, MDS_GETSTATUS);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_pack_body(req, NULL, NULL, 0, 0, -1, 0);\r\nlustre_msg_add_flags(req->rq_reqmsg, msg_flags);\r\nreq->rq_send_state = level;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nGOTO(out, rc = -EPROTO);\r\nif (body->valid & OBD_MD_FLMDSCAPA) {\r\nrc = mdc_unpack_capa(NULL, req, &RMF_CAPA1, pc);\r\nif (rc)\r\nGOTO(out, rc);\r\n}\r\n*rootfid = body->fid1;\r\nCDEBUG(D_NET,\r\n"root fid="DFID", last_committed="LPU64"\n",\r\nPFID(rootfid),\r\nlustre_msg_get_last_committed(req->rq_repmsg));\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint mdc_getstatus(struct obd_export *exp, struct lu_fid *rootfid,\r\nstruct obd_capa **pc)\r\n{\r\nreturn send_getstatus(class_exp2cliimp(exp), rootfid, pc,\r\nLUSTRE_IMP_FULL, 0);\r\n}\r\nstatic int mdc_getattr_common(struct obd_export *exp,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nstruct mdt_body *body;\r\nvoid *eadata;\r\nint rc;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc != 0)\r\nreturn rc;\r\nbody = req_capsule_server_get(pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nreturn -EPROTO;\r\nCDEBUG(D_NET, "mode: %o\n", body->mode);\r\nif (body->eadatasize != 0) {\r\nmdc_update_max_ea_from_body(exp, body);\r\neadata = req_capsule_server_sized_get(pill, &RMF_MDT_MD,\r\nbody->eadatasize);\r\nif (eadata == NULL)\r\nreturn -EPROTO;\r\n}\r\nif (body->valid & OBD_MD_FLRMTPERM) {\r\nstruct mdt_remote_perm *perm;\r\nLASSERT(client_is_remote(exp));\r\nperm = req_capsule_server_swab_get(pill, &RMF_ACL,\r\nlustre_swab_mdt_remote_perm);\r\nif (perm == NULL)\r\nreturn -EPROTO;\r\n}\r\nif (body->valid & OBD_MD_FLMDSCAPA) {\r\nstruct lustre_capa *capa;\r\ncapa = req_capsule_server_get(pill, &RMF_CAPA1);\r\nif (capa == NULL)\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nint mdc_getattr(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nif (op_data->op_flags & MF_GET_MDT_IDX) {\r\nop_data->op_mds = 0;\r\nreturn 0;\r\n}\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_GETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_capa1,\r\nop_data->op_valid, op_data->op_mode, -1, 0);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nop_data->op_mode);\r\nif (op_data->op_valid & OBD_MD_FLRMTPERM) {\r\nLASSERT(client_is_remote(exp));\r\nreq_capsule_set_size(&req->rq_pill, &RMF_ACL, RCL_SERVER,\r\nsizeof(struct mdt_remote_perm));\r\n}\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_getattr_common(exp, req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nint mdc_getattr_name(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_GETATTR_NAME);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GETATTR_NAME);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_capa1,\r\nop_data->op_valid, op_data->op_mode,\r\nop_data->op_suppgids[0], 0);\r\nif (op_data->op_name) {\r\nchar *name = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLASSERT(strnlen(op_data->op_name, op_data->op_namelen) ==\r\nop_data->op_namelen);\r\nmemcpy(name, op_data->op_name, op_data->op_namelen);\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nop_data->op_mode);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_getattr_common(exp, req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_is_subdir(struct obd_export *exp,\r\nconst struct lu_fid *pfid,\r\nconst struct lu_fid *cfid,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MDS_IS_SUBDIR, LUSTRE_MDS_VERSION,\r\nMDS_IS_SUBDIR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_is_subdir_pack(req, pfid, cfid, 0);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc && rc != -EREMOTE)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_xattr_common(struct obd_export *exp,const struct req_format *fmt,\r\nconst struct lu_fid *fid,\r\nstruct obd_capa *oc, int opcode, obd_valid valid,\r\nconst char *xattr_name, const char *input,\r\nint input_size, int output_size, int flags,\r\n__u32 suppgid, struct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint xattr_namelen = 0;\r\nchar *tmp;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), fmt);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, oc);\r\nif (xattr_name) {\r\nxattr_namelen = strlen(xattr_name) + 1;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nxattr_namelen);\r\n}\r\nif (input_size) {\r\nLASSERT(input);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT,\r\ninput_size);\r\n}\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, opcode);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nif (opcode == MDS_REINT) {\r\nstruct mdt_rec_setxattr *rec;\r\nCLASSERT(sizeof(struct mdt_rec_setxattr) ==\r\nsizeof(struct mdt_rec_reint));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->sx_opcode = REINT_SETXATTR;\r\nrec->sx_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nrec->sx_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nrec->sx_cap = cfs_curproc_cap_pack();\r\nrec->sx_suppgid1 = suppgid;\r\nrec->sx_suppgid2 = -1;\r\nrec->sx_fid = *fid;\r\nrec->sx_valid = valid | OBD_MD_FLCTIME;\r\nrec->sx_time = cfs_time_current_sec();\r\nrec->sx_size = output_size;\r\nrec->sx_flags = flags;\r\nmdc_pack_capa(req, &RMF_CAPA1, oc);\r\n} else {\r\nmdc_pack_body(req, fid, oc, valid, output_size, suppgid, flags);\r\n}\r\nif (xattr_name) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nmemcpy(tmp, xattr_name, xattr_namelen);\r\n}\r\nif (input_size) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nmemcpy(tmp, input, input_size);\r\n}\r\nif (req_capsule_has_field(&req->rq_pill, &RMF_EADATA, RCL_SERVER))\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA,\r\nRCL_SERVER, output_size);\r\nptlrpc_request_set_replen(req);\r\nif (opcode == MDS_REINT)\r\nmdc_get_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nif (opcode == MDS_REINT)\r\nmdc_put_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nint mdc_setxattr(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, obd_valid valid, const char *xattr_name,\r\nconst char *input, int input_size, int output_size,\r\nint flags, __u32 suppgid, struct ptlrpc_request **request)\r\n{\r\nreturn mdc_xattr_common(exp, &RQF_MDS_REINT_SETXATTR,\r\nfid, oc, MDS_REINT, valid, xattr_name,\r\ninput, input_size, output_size, flags,\r\nsuppgid, request);\r\n}\r\nint mdc_getxattr(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, obd_valid valid, const char *xattr_name,\r\nconst char *input, int input_size, int output_size,\r\nint flags, struct ptlrpc_request **request)\r\n{\r\nreturn mdc_xattr_common(exp, &RQF_MDS_GETXATTR,\r\nfid, oc, MDS_GETXATTR, valid, xattr_name,\r\ninput, input_size, output_size, flags,\r\n-1, request);\r\n}\r\nstatic int mdc_unpack_acl(struct ptlrpc_request *req, struct lustre_md *md)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nstruct mdt_body *body = md->body;\r\nstruct posix_acl *acl;\r\nvoid *buf;\r\nint rc;\r\nif (!body->aclsize)\r\nreturn 0;\r\nbuf = req_capsule_server_sized_get(pill, &RMF_ACL, body->aclsize);\r\nif (!buf)\r\nreturn -EPROTO;\r\nacl = posix_acl_from_xattr(&init_user_ns, buf, body->aclsize);\r\nif (IS_ERR(acl)) {\r\nrc = PTR_ERR(acl);\r\nCERROR("convert xattr to acl: %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = posix_acl_valid(acl);\r\nif (rc) {\r\nCERROR("validate acl: %d\n", rc);\r\nposix_acl_release(acl);\r\nreturn rc;\r\n}\r\nmd->posix_acl = acl;\r\nreturn 0;\r\n}\r\nint mdc_get_lustre_md(struct obd_export *exp, struct ptlrpc_request *req,\r\nstruct obd_export *dt_exp, struct obd_export *md_exp,\r\nstruct lustre_md *md)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nint rc;\r\nLASSERT(md);\r\nmemset(md, 0, sizeof(*md));\r\nmd->body = req_capsule_server_get(pill, &RMF_MDT_BODY);\r\nLASSERT(md->body != NULL);\r\nif (md->body->valid & OBD_MD_FLEASIZE) {\r\nint lmmsize;\r\nstruct lov_mds_md *lmm;\r\nif (!S_ISREG(md->body->mode)) {\r\nCDEBUG(D_INFO, "OBD_MD_FLEASIZE set, should be a "\r\n"regular file, but is not\n");\r\nGOTO(out, rc = -EPROTO);\r\n}\r\nif (md->body->eadatasize == 0) {\r\nCDEBUG(D_INFO, "OBD_MD_FLEASIZE set, "\r\n"but eadatasize 0\n");\r\nGOTO(out, rc = -EPROTO);\r\n}\r\nlmmsize = md->body->eadatasize;\r\nlmm = req_capsule_server_sized_get(pill, &RMF_MDT_MD, lmmsize);\r\nif (!lmm)\r\nGOTO(out, rc = -EPROTO);\r\nrc = obd_unpackmd(dt_exp, &md->lsm, lmm, lmmsize);\r\nif (rc < 0)\r\nGOTO(out, rc);\r\nif (rc < sizeof(*md->lsm)) {\r\nCDEBUG(D_INFO, "lsm size too small: "\r\n"rc < sizeof (*md->lsm) (%d < %d)\n",\r\nrc, (int)sizeof(*md->lsm));\r\nGOTO(out, rc = -EPROTO);\r\n}\r\n} else if (md->body->valid & OBD_MD_FLDIREA) {\r\nint lmvsize;\r\nstruct lov_mds_md *lmv;\r\nif(!S_ISDIR(md->body->mode)) {\r\nCDEBUG(D_INFO, "OBD_MD_FLDIREA set, should be a "\r\n"directory, but is not\n");\r\nGOTO(out, rc = -EPROTO);\r\n}\r\nif (md->body->eadatasize == 0) {\r\nCDEBUG(D_INFO, "OBD_MD_FLDIREA is set, "\r\n"but eadatasize 0\n");\r\nreturn -EPROTO;\r\n}\r\nif (md->body->valid & OBD_MD_MEA) {\r\nlmvsize = md->body->eadatasize;\r\nlmv = req_capsule_server_sized_get(pill, &RMF_MDT_MD,\r\nlmvsize);\r\nif (!lmv)\r\nGOTO(out, rc = -EPROTO);\r\nrc = obd_unpackmd(md_exp, (void *)&md->mea, lmv,\r\nlmvsize);\r\nif (rc < 0)\r\nGOTO(out, rc);\r\nif (rc < sizeof(*md->mea)) {\r\nCDEBUG(D_INFO, "size too small: "\r\n"rc < sizeof(*md->mea) (%d < %d)\n",\r\nrc, (int)sizeof(*md->mea));\r\nGOTO(out, rc = -EPROTO);\r\n}\r\n}\r\n}\r\nrc = 0;\r\nif (md->body->valid & OBD_MD_FLRMTPERM) {\r\nLASSERT(client_is_remote(exp));\r\nmd->remote_perm = req_capsule_server_swab_get(pill, &RMF_ACL,\r\nlustre_swab_mdt_remote_perm);\r\nif (!md->remote_perm)\r\nGOTO(out, rc = -EPROTO);\r\n}\r\nelse if (md->body->valid & OBD_MD_FLACL) {\r\nif (md->body->aclsize) {\r\nrc = mdc_unpack_acl(req, md);\r\nif (rc)\r\nGOTO(out, rc);\r\n#ifdef CONFIG_FS_POSIX_ACL\r\n} else {\r\nmd->posix_acl = NULL;\r\n#endif\r\n}\r\n}\r\nif (md->body->valid & OBD_MD_FLMDSCAPA) {\r\nstruct obd_capa *oc = NULL;\r\nrc = mdc_unpack_capa(NULL, req, &RMF_CAPA1, &oc);\r\nif (rc)\r\nGOTO(out, rc);\r\nmd->mds_capa = oc;\r\n}\r\nif (md->body->valid & OBD_MD_FLOSSCAPA) {\r\nstruct obd_capa *oc = NULL;\r\nrc = mdc_unpack_capa(NULL, req, &RMF_CAPA2, &oc);\r\nif (rc)\r\nGOTO(out, rc);\r\nmd->oss_capa = oc;\r\n}\r\nout:\r\nif (rc) {\r\nif (md->oss_capa) {\r\ncapa_put(md->oss_capa);\r\nmd->oss_capa = NULL;\r\n}\r\nif (md->mds_capa) {\r\ncapa_put(md->mds_capa);\r\nmd->mds_capa = NULL;\r\n}\r\n#ifdef CONFIG_FS_POSIX_ACL\r\nposix_acl_release(md->posix_acl);\r\n#endif\r\nif (md->lsm)\r\nobd_free_memmd(dt_exp, &md->lsm);\r\n}\r\nreturn rc;\r\n}\r\nint mdc_free_lustre_md(struct obd_export *exp, struct lustre_md *md)\r\n{\r\nreturn 0;\r\n}\r\nvoid mdc_replay_open(struct ptlrpc_request *req)\r\n{\r\nstruct md_open_data *mod = req->rq_cb_data;\r\nstruct ptlrpc_request *close_req;\r\nstruct obd_client_handle *och;\r\nstruct lustre_handle old;\r\nstruct mdt_body *body;\r\nif (mod == NULL) {\r\nDEBUG_REQ(D_ERROR, req,\r\n"Can't properly replay without open data.");\r\nreturn;\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(body != NULL);\r\noch = mod->mod_och;\r\nif (och != NULL) {\r\nstruct lustre_handle *file_fh;\r\nLASSERT(och->och_magic == OBD_CLIENT_HANDLE_MAGIC);\r\nfile_fh = &och->och_fh;\r\nCDEBUG(D_HA, "updating handle from "LPX64" to "LPX64"\n",\r\nfile_fh->cookie, body->handle.cookie);\r\nold = *file_fh;\r\n*file_fh = body->handle;\r\n}\r\nclose_req = mod->mod_close_req;\r\nif (close_req != NULL) {\r\n__u32 opc = lustre_msg_get_opc(close_req->rq_reqmsg);\r\nstruct mdt_ioepoch *epoch;\r\nLASSERT(opc == MDS_CLOSE || opc == MDS_DONE_WRITING);\r\nepoch = req_capsule_client_get(&close_req->rq_pill,\r\n&RMF_MDT_EPOCH);\r\nLASSERT(epoch);\r\nif (och != NULL)\r\nLASSERT(!memcmp(&old, &epoch->handle, sizeof(old)));\r\nDEBUG_REQ(D_HA, close_req, "updating close body with new fh");\r\nepoch->handle = body->handle;\r\n}\r\n}\r\nvoid mdc_commit_open(struct ptlrpc_request *req)\r\n{\r\nstruct md_open_data *mod = req->rq_cb_data;\r\nif (mod == NULL)\r\nreturn;\r\nptlrpc_request_addref(req);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_committed = 1;\r\nspin_unlock(&req->rq_lock);\r\nreq->rq_cb_data = NULL;\r\nobd_mod_put(mod);\r\n}\r\nint mdc_set_open_replay_data(struct obd_export *exp,\r\nstruct obd_client_handle *och,\r\nstruct ptlrpc_request *open_req)\r\n{\r\nstruct md_open_data *mod;\r\nstruct mdt_rec_create *rec;\r\nstruct mdt_body *body;\r\nstruct obd_import *imp = open_req->rq_import;\r\nif (!open_req->rq_replay)\r\nreturn 0;\r\nrec = req_capsule_client_get(&open_req->rq_pill, &RMF_REC_REINT);\r\nbody = req_capsule_server_get(&open_req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(rec != NULL);\r\nLASSERT(body != NULL);\r\nif (och && imp->imp_replayable) {\r\nmod = obd_mod_alloc();\r\nif (mod == NULL) {\r\nDEBUG_REQ(D_ERROR, open_req,\r\n"Can't allocate md_open_data");\r\nreturn 0;\r\n}\r\nobd_mod_get(mod);\r\nobd_mod_get(mod);\r\nspin_lock(&open_req->rq_lock);\r\noch->och_mod = mod;\r\nmod->mod_och = och;\r\nmod->mod_open_req = open_req;\r\nopen_req->rq_cb_data = mod;\r\nopen_req->rq_commit_cb = mdc_commit_open;\r\nspin_unlock(&open_req->rq_lock);\r\n}\r\nrec->cr_fid2 = body->fid1;\r\nrec->cr_ioepoch = body->ioepoch;\r\nrec->cr_old_handle.cookie = body->handle.cookie;\r\nopen_req->rq_replay_cb = mdc_replay_open;\r\nif (!fid_is_sane(&body->fid1)) {\r\nDEBUG_REQ(D_ERROR, open_req, "Saving replay request with "\r\n"insane fid");\r\nLBUG();\r\n}\r\nDEBUG_REQ(D_RPCTRACE, open_req, "Set up open replay data");\r\nreturn 0;\r\n}\r\nint mdc_clear_open_replay_data(struct obd_export *exp,\r\nstruct obd_client_handle *och)\r\n{\r\nstruct md_open_data *mod = och->och_mod;\r\nif (mod == NULL)\r\nreturn 0;\r\nLASSERT(mod != LP_POISON);\r\nmod->mod_och = NULL;\r\noch->och_mod = NULL;\r\nobd_mod_put(mod);\r\nreturn 0;\r\n}\r\nstatic void mdc_close_handle_reply(struct ptlrpc_request *req,\r\nstruct md_op_data *op_data, int rc) {\r\nstruct mdt_body *repbody;\r\nstruct mdt_ioepoch *epoch;\r\nif (req && rc == -EAGAIN) {\r\nrepbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nepoch = req_capsule_client_get(&req->rq_pill, &RMF_MDT_EPOCH);\r\nepoch->flags |= MF_SOM_AU;\r\nif (repbody->valid & OBD_MD_FLGETATTRLOCK)\r\nop_data->op_flags |= MF_GETATTR_LOCK;\r\n}\r\n}\r\nint mdc_close(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct md_open_data *mod, struct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_CLOSE);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_CLOSE);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq->rq_request_portal = MDS_READPAGE_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\nif (likely(mod != NULL)) {\r\nLASSERTF(mod->mod_open_req != NULL &&\r\nmod->mod_open_req->rq_type != LI_POISON,\r\n"POISONED open %p!\n", mod->mod_open_req);\r\nmod->mod_close_req = req;\r\nDEBUG_REQ(D_HA, mod->mod_open_req, "matched open");\r\nspin_lock(&mod->mod_open_req->rq_lock);\r\nmod->mod_open_req->rq_replay = 0;\r\nspin_unlock(&mod->mod_open_req->rq_lock);\r\n} else {\r\nCDEBUG(D_HA, "couldn't find open req; expecting close error\n");\r\n}\r\nmdc_close_pack(req, op_data);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobd->u.cli.cl_max_mds_easize);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_LOGCOOKIES, RCL_SERVER,\r\nobd->u.cli.cl_max_mds_cookiesize);\r\nptlrpc_request_set_replen(req);\r\nmdc_get_rpc_lock(obd->u.cli.cl_close_lock, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_rpc_lock(obd->u.cli.cl_close_lock, NULL);\r\nif (req->rq_repmsg == NULL) {\r\nCDEBUG(D_RPCTRACE, "request failed to send: %p, %d\n", req,\r\nreq->rq_status);\r\nif (rc == 0)\r\nrc = req->rq_status ?: -EIO;\r\n} else if (rc == 0 || rc == -EAGAIN) {\r\nstruct mdt_body *body;\r\nrc = lustre_msg_get_status(req->rq_repmsg);\r\nif (lustre_msg_get_type(req->rq_repmsg) == PTL_RPC_MSG_ERR) {\r\nDEBUG_REQ(D_ERROR, req, "type == PTL_RPC_MSG_ERR, err "\r\n"= %d", rc);\r\nif (rc > 0)\r\nrc = -rc;\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nrc = -EPROTO;\r\n} else if (rc == -ESTALE) {\r\nif (mod) {\r\nDEBUG_REQ(D_HA, req, "Reset ESTALE = %d", rc);\r\nLASSERT(mod->mod_open_req != NULL);\r\nif (mod->mod_open_req->rq_committed)\r\nrc = 0;\r\n}\r\n}\r\nif (mod) {\r\nif (rc != 0)\r\nmod->mod_close_req = NULL;\r\nobd_mod_put(mod);\r\n}\r\n*request = req;\r\nmdc_close_handle_reply(req, op_data, rc);\r\nreturn rc;\r\n}\r\nint mdc_done_writing(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct md_open_data *mod)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_DONE_WRITING);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_DONE_WRITING);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nif (mod != NULL) {\r\nLASSERTF(mod->mod_open_req != NULL &&\r\nmod->mod_open_req->rq_type != LI_POISON,\r\n"POISONED setattr %p!\n", mod->mod_open_req);\r\nmod->mod_close_req = req;\r\nDEBUG_REQ(D_HA, mod->mod_open_req, "matched setattr");\r\nspin_lock(&mod->mod_open_req->rq_lock);\r\nmod->mod_open_req->rq_replay = 0;\r\nspin_unlock(&mod->mod_open_req->rq_lock);\r\n}\r\nmdc_close_pack(req, op_data);\r\nptlrpc_request_set_replen(req);\r\nmdc_get_rpc_lock(obd->u.cli.cl_close_lock, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_rpc_lock(obd->u.cli.cl_close_lock, NULL);\r\nif (rc == -ESTALE) {\r\nif (mod) {\r\nLASSERT(mod->mod_open_req != NULL);\r\nif (mod->mod_open_req->rq_committed)\r\nrc = 0;\r\n}\r\n}\r\nif (mod) {\r\nif (rc != 0)\r\nmod->mod_close_req = NULL;\r\nobd_mod_put(mod);\r\n}\r\nmdc_close_handle_reply(req, op_data, rc);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint mdc_readpage(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct page **pages, struct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct ptlrpc_bulk_desc *desc;\r\nint i;\r\nwait_queue_head_t waitq;\r\nint resends = 0;\r\nstruct l_wait_info lwi;\r\nint rc;\r\n*request = NULL;\r\ninit_waitqueue_head(&waitq);\r\nrestart_bulk:\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_READPAGE);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_READPAGE);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nreq->rq_request_portal = MDS_READPAGE_PORTAL;\r\nptlrpc_at_set_req_timeout(req);\r\ndesc = ptlrpc_prep_bulk_imp(req, op_data->op_npages, 1, BULK_PUT_SINK,\r\nMDS_BULK_PORTAL);\r\nif (desc == NULL) {\r\nptlrpc_request_free(req);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < op_data->op_npages; i++)\r\nptlrpc_prep_bulk_page_pin(desc, pages[i], 0, PAGE_CACHE_SIZE);\r\nmdc_readdir_pack(req, op_data->op_offset,\r\nPAGE_CACHE_SIZE * op_data->op_npages,\r\n&op_data->op_fid1, op_data->op_capa1);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc) {\r\nptlrpc_req_finished(req);\r\nif (rc != -ETIMEDOUT)\r\nreturn rc;\r\nresends++;\r\nif (!client_should_resend(resends, &exp->exp_obd->u.cli)) {\r\nCERROR("too many resend retries, returning error\n");\r\nreturn -EIO;\r\n}\r\nlwi = LWI_TIMEOUT_INTR(cfs_time_seconds(resends), NULL, NULL, NULL);\r\nl_wait_event(waitq, 0, &lwi);\r\ngoto restart_bulk;\r\n}\r\nrc = sptlrpc_cli_unwrap_bulk_read(req, req->rq_bulk,\r\nreq->rq_bulk->bd_nob_transferred);\r\nif (rc < 0) {\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nif (req->rq_bulk->bd_nob_transferred & ~LU_PAGE_MASK) {\r\nCERROR("Unexpected # bytes transferred: %d (%ld expected)\n",\r\nreq->rq_bulk->bd_nob_transferred,\r\nPAGE_CACHE_SIZE * op_data->op_npages);\r\nptlrpc_req_finished(req);\r\nreturn -EPROTO;\r\n}\r\n*request = req;\r\nreturn 0;\r\n}\r\nstatic int mdc_statfs(const struct lu_env *env,\r\nstruct obd_export *exp, struct obd_statfs *osfs,\r\n__u64 max_age, __u32 flags)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req;\r\nstruct obd_statfs *msfs;\r\nstruct obd_import *imp = NULL;\r\nint rc;\r\ndown_read(&obd->u.cli.cl_sem);\r\nif (obd->u.cli.cl_import)\r\nimp = class_import_get(obd->u.cli.cl_import);\r\nup_read(&obd->u.cli.cl_sem);\r\nif (!imp)\r\nreturn -ENODEV;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_STATFS,\r\nLUSTRE_MDS_VERSION, MDS_STATFS);\r\nif (req == NULL)\r\nGOTO(output, rc = -ENOMEM);\r\nptlrpc_request_set_replen(req);\r\nif (flags & OBD_STATFS_NODELAY) {\r\nreq->rq_no_resend = 1;\r\nreq->rq_no_delay = 1;\r\n}\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc) {\r\nif (imp->imp_connect_error)\r\nrc = imp->imp_connect_error;\r\nGOTO(out, rc);\r\n}\r\nmsfs = req_capsule_server_get(&req->rq_pill, &RMF_OBD_STATFS);\r\nif (msfs == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*osfs = *msfs;\r\nout:\r\nptlrpc_req_finished(req);\r\noutput:\r\nclass_import_put(imp);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_fid2path(struct obd_export *exp, struct getinfo_fid2path *gf)\r\n{\r\n__u32 keylen, vallen;\r\nvoid *key;\r\nint rc;\r\nif (gf->gf_pathlen > PATH_MAX)\r\nreturn -ENAMETOOLONG;\r\nif (gf->gf_pathlen < 2)\r\nreturn -EOVERFLOW;\r\nkeylen = cfs_size_round(sizeof(KEY_FID2PATH)) + sizeof(*gf);\r\nOBD_ALLOC(key, keylen);\r\nif (key == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(key, KEY_FID2PATH, sizeof(KEY_FID2PATH));\r\nmemcpy(key + cfs_size_round(sizeof(KEY_FID2PATH)), gf, sizeof(*gf));\r\nCDEBUG(D_IOCTL, "path get "DFID" from "LPU64" #%d\n",\r\nPFID(&gf->gf_fid), gf->gf_recno, gf->gf_linkno);\r\nif (!fid_is_sane(&gf->gf_fid))\r\nGOTO(out, rc = -EINVAL);\r\nvallen = sizeof(*gf) + gf->gf_pathlen;\r\nrc = obd_get_info(NULL, exp, keylen, key, &vallen, gf, NULL);\r\nif (rc != 0 && rc != -EREMOTE)\r\nGOTO(out, rc);\r\nif (vallen <= sizeof(*gf))\r\nGOTO(out, rc = -EPROTO);\r\nelse if (vallen > sizeof(*gf) + gf->gf_pathlen)\r\nGOTO(out, rc = -EOVERFLOW);\r\nCDEBUG(D_IOCTL, "path get "DFID" from "LPU64" #%d\n%s\n",\r\nPFID(&gf->gf_fid), gf->gf_recno, gf->gf_linkno, gf->gf_path);\r\nout:\r\nOBD_FREE(key, keylen);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_progress(struct obd_export *exp,\r\nstruct hsm_progress_kernel *hpk)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct hsm_progress_kernel *req_hpk;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_HSM_PROGRESS,\r\nLUSTRE_MDS_VERSION, MDS_HSM_PROGRESS);\r\nif (req == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nmdc_pack_body(req, NULL, NULL, OBD_MD_FLRMTPERM, 0, 0, 0);\r\nreq_hpk = req_capsule_client_get(&req->rq_pill, &RMF_MDS_HSM_PROGRESS);\r\nif (req_hpk == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*req_hpk = *hpk;\r\nreq_hpk->hpk_errval = lustre_errno_hton(hpk->hpk_errval);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nGOTO(out, rc);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_ct_register(struct obd_import *imp, __u32 archives)\r\n{\r\n__u32 *archive_mask;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_HSM_CT_REGISTER,\r\nLUSTRE_MDS_VERSION,\r\nMDS_HSM_CT_REGISTER);\r\nif (req == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nmdc_pack_body(req, NULL, NULL, OBD_MD_FLRMTPERM, 0, 0, 0);\r\narchive_mask = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDS_HSM_ARCHIVE);\r\nif (archive_mask == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*archive_mask = archives;\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nGOTO(out, rc);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_current_action(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct hsm_current_action *hca = op_data->op_data;\r\nstruct hsm_current_action *req_hca;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_HSM_ACTION);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_ACTION);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_capa1,\r\nOBD_MD_FLRMTPERM, 0, op_data->op_suppgids[0], 0);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nreq_hca = req_capsule_server_get(&req->rq_pill,\r\n&RMF_MDS_HSM_CURRENT_ACTION);\r\nif (req_hca == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*hca = *req_hca;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_ct_unregister(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(imp, &RQF_MDS_HSM_CT_UNREGISTER,\r\nLUSTRE_MDS_VERSION,\r\nMDS_HSM_CT_UNREGISTER);\r\nif (req == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nmdc_pack_body(req, NULL, NULL, OBD_MD_FLRMTPERM, 0, 0, 0);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nGOTO(out, rc);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_state_get(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct hsm_user_state *hus = op_data->op_data;\r\nstruct hsm_user_state *req_hus;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_HSM_STATE_GET);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_STATE_GET);\r\nif (rc != 0) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_capa1,\r\nOBD_MD_FLRMTPERM, 0, op_data->op_suppgids[0], 0);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nreq_hus = req_capsule_server_get(&req->rq_pill, &RMF_HSM_USER_STATE);\r\nif (req_hus == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*hus = *req_hus;\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_state_set(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct hsm_state_set *hss = op_data->op_data;\r\nstruct hsm_state_set *req_hss;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_HSM_STATE_SET);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_STATE_SET);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, &op_data->op_fid1, op_data->op_capa1,\r\nOBD_MD_FLRMTPERM, 0, op_data->op_suppgids[0], 0);\r\nreq_hss = req_capsule_client_get(&req->rq_pill, &RMF_HSM_STATE_SET);\r\nif (req_hss == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*req_hss = *hss;\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nGOTO(out, rc);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_hsm_request(struct obd_export *exp,\r\nstruct hsm_user_request *hur)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct ptlrpc_request *req;\r\nstruct hsm_request *req_hr;\r\nstruct hsm_user_item *req_hui;\r\nchar *req_opaque;\r\nint rc;\r\nreq = ptlrpc_request_alloc(imp, &RQF_MDS_HSM_REQUEST);\r\nif (req == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDS_HSM_USER_ITEM, RCL_CLIENT,\r\nhur->hur_request.hr_itemcount\r\n* sizeof(struct hsm_user_item));\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GENERIC_DATA, RCL_CLIENT,\r\nhur->hur_request.hr_data_len);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_HSM_REQUEST);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, NULL, NULL, OBD_MD_FLRMTPERM, 0, 0, 0);\r\nreq_hr = req_capsule_client_get(&req->rq_pill, &RMF_MDS_HSM_REQUEST);\r\nif (req_hr == NULL)\r\nGOTO(out, rc = -EPROTO);\r\n*req_hr = hur->hur_request;\r\nreq_hui = req_capsule_client_get(&req->rq_pill, &RMF_MDS_HSM_USER_ITEM);\r\nif (req_hui == NULL)\r\nGOTO(out, rc = -EPROTO);\r\nmemcpy(req_hui, hur->hur_user_item,\r\nhur->hur_request.hr_itemcount * sizeof(struct hsm_user_item));\r\nreq_opaque = req_capsule_client_get(&req->rq_pill, &RMF_GENERIC_DATA);\r\nif (req_opaque == NULL)\r\nGOTO(out, rc = -EPROTO);\r\nmemcpy(req_opaque, hur_data(hur), hur->hur_request.hr_data_len);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_queue_wait(req);\r\nGOTO(out, rc);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic struct kuc_hdr *changelog_kuc_hdr(char *buf, int len, int flags)\r\n{\r\nstruct kuc_hdr *lh = (struct kuc_hdr *)buf;\r\nLASSERT(len <= CR_MAXSIZE);\r\nlh->kuc_magic = KUC_MAGIC;\r\nlh->kuc_transport = KUC_TRANSPORT_CHANGELOG;\r\nlh->kuc_flags = flags;\r\nlh->kuc_msgtype = CL_RECORD;\r\nlh->kuc_msglen = len;\r\nreturn lh;\r\n}\r\nstatic int changelog_kkuc_cb(const struct lu_env *env, struct llog_handle *llh,\r\nstruct llog_rec_hdr *hdr, void *data)\r\n{\r\nstruct changelog_show *cs = data;\r\nstruct llog_changelog_rec *rec = (struct llog_changelog_rec *)hdr;\r\nstruct kuc_hdr *lh;\r\nint len, rc;\r\nif (rec->cr_hdr.lrh_type != CHANGELOG_REC) {\r\nrc = -EINVAL;\r\nCERROR("%s: not a changelog rec %x/%d: rc = %d\n",\r\ncs->cs_obd->obd_name, rec->cr_hdr.lrh_type,\r\nrec->cr.cr_type, rc);\r\nreturn rc;\r\n}\r\nif (rec->cr.cr_index < cs->cs_startrec) {\r\nCDEBUG(D_CHANGELOG, "rec="LPU64" start="LPU64"\n",\r\nrec->cr.cr_index, cs->cs_startrec);\r\nreturn 0;\r\n}\r\nCDEBUG(D_CHANGELOG, LPU64" %02d%-5s "LPU64" 0x%x t="DFID" p="DFID\r\n" %.*s\n", rec->cr.cr_index, rec->cr.cr_type,\r\nchangelog_type2str(rec->cr.cr_type), rec->cr.cr_time,\r\nrec->cr.cr_flags & CLF_FLAGMASK,\r\nPFID(&rec->cr.cr_tfid), PFID(&rec->cr.cr_pfid),\r\nrec->cr.cr_namelen, changelog_rec_name(&rec->cr));\r\nlen = sizeof(*lh) + changelog_rec_size(&rec->cr) + rec->cr.cr_namelen;\r\nlh = changelog_kuc_hdr(cs->cs_buf, len, cs->cs_flags);\r\nmemcpy(lh + 1, &rec->cr, len - sizeof(*lh));\r\nrc = libcfs_kkuc_msg_put(cs->cs_fp, lh);\r\nCDEBUG(D_CHANGELOG, "kucmsg fp %p len %d rc %d\n", cs->cs_fp, len,rc);\r\nreturn rc;\r\n}\r\nstatic int mdc_changelog_send_thread(void *csdata)\r\n{\r\nstruct changelog_show *cs = csdata;\r\nstruct llog_ctxt *ctxt = NULL;\r\nstruct llog_handle *llh = NULL;\r\nstruct kuc_hdr *kuch;\r\nint rc;\r\nCDEBUG(D_CHANGELOG, "changelog to fp=%p start "LPU64"\n",\r\ncs->cs_fp, cs->cs_startrec);\r\nOBD_ALLOC(cs->cs_buf, CR_MAXSIZE);\r\nif (cs->cs_buf == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nctxt = llog_get_context(cs->cs_obd, LLOG_CHANGELOG_REPL_CTXT);\r\nif (ctxt == NULL)\r\nGOTO(out, rc = -ENOENT);\r\nrc = llog_open(NULL, ctxt, &llh, NULL, CHANGELOG_CATALOG,\r\nLLOG_OPEN_EXISTS);\r\nif (rc) {\r\nCERROR("%s: fail to open changelog catalog: rc = %d\n",\r\ncs->cs_obd->obd_name, rc);\r\nGOTO(out, rc);\r\n}\r\nrc = llog_init_handle(NULL, llh, LLOG_F_IS_CAT, NULL);\r\nif (rc) {\r\nCERROR("llog_init_handle failed %d\n", rc);\r\nGOTO(out, rc);\r\n}\r\nrc = llog_cat_process(NULL, llh, changelog_kkuc_cb, cs, 0, 0);\r\nif ((kuch = changelog_kuc_hdr(cs->cs_buf, sizeof(*kuch),\r\ncs->cs_flags))) {\r\nkuch->kuc_msgtype = CL_EOF;\r\nlibcfs_kkuc_msg_put(cs->cs_fp, kuch);\r\n}\r\nout:\r\nfput(cs->cs_fp);\r\nif (llh)\r\nllog_cat_close(NULL, llh);\r\nif (ctxt)\r\nllog_ctxt_put(ctxt);\r\nif (cs->cs_buf)\r\nOBD_FREE(cs->cs_buf, CR_MAXSIZE);\r\nOBD_FREE_PTR(cs);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_changelog_send(struct obd_device *obd,\r\nstruct ioc_changelog *icc)\r\n{\r\nstruct changelog_show *cs;\r\nint rc;\r\nOBD_ALLOC_PTR(cs);\r\nif (!cs)\r\nreturn -ENOMEM;\r\ncs->cs_obd = obd;\r\ncs->cs_startrec = icc->icc_recno;\r\ncs->cs_fp = fget(icc->icc_id);\r\ncs->cs_flags = icc->icc_flags;\r\nrc = PTR_ERR(kthread_run(mdc_changelog_send_thread, cs,\r\n"mdc_clg_send_thread"));\r\nif (!IS_ERR_VALUE(rc)) {\r\nCDEBUG(D_CHANGELOG, "start changelog thread\n");\r\nreturn 0;\r\n}\r\nCERROR("Failed to start changelog thread: %d\n", rc);\r\nOBD_FREE_PTR(cs);\r\nreturn rc;\r\n}\r\nstatic int mdc_quotacheck(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct ptlrpc_request *req;\r\nstruct obd_quotactl *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MDS_QUOTACHECK, LUSTRE_MDS_VERSION,\r\nMDS_QUOTACHECK);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\n*body = *oqctl;\r\nptlrpc_request_set_replen(req);\r\ncli->cl_qchk_stat = -ENODATA;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ncli->cl_qchk_stat = rc;\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_quota_poll_check(struct obd_export *exp,\r\nstruct if_quotacheck *qchk)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nint rc;\r\nqchk->obd_uuid = cli->cl_target_uuid;\r\nmemcpy(qchk->obd_type, LUSTRE_MDS_NAME, strlen(LUSTRE_MDS_NAME));\r\nrc = cli->cl_qchk_stat;\r\nif (rc == CL_NOT_QUOTACHECKED)\r\nrc = -EINTR;\r\nreturn rc;\r\n}\r\nstatic int mdc_quotactl(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct obd_quotactl *oqc;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MDS_QUOTACTL, LUSTRE_MDS_VERSION,\r\nMDS_QUOTACTL);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\noqc = req_capsule_client_get(&req->rq_pill, &RMF_OBD_QUOTACTL);\r\n*oqc = *oqctl;\r\nptlrpc_request_set_replen(req);\r\nptlrpc_at_set_req_timeout(req);\r\nreq->rq_no_resend = 1;\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nCERROR("ptlrpc_queue_wait failed, rc: %d\n", rc);\r\nif (req->rq_repmsg &&\r\n(oqc = req_capsule_server_get(&req->rq_pill, &RMF_OBD_QUOTACTL))) {\r\n*oqctl = *oqc;\r\n} else if (!rc) {\r\nCERROR ("Can't unpack obd_quotactl\n");\r\nrc = -EPROTO;\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_ioc_swap_layouts(struct obd_export *exp,\r\nstruct md_op_data *op_data)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct ptlrpc_request *req;\r\nint rc, count;\r\nstruct mdc_swap_layouts *msl, *payload;\r\nmsl = op_data->op_data;\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1, &cancels,\r\nLCK_CR, MDS_INODELOCK_LAYOUT);\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid2, &cancels,\r\nLCK_CR, MDS_INODELOCK_LAYOUT);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_SWAP_LAYOUTS);\r\nif (req == NULL) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nmdc_set_capa_size(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_set_capa_size(req, &RMF_CAPA2, op_data->op_capa2);\r\nrc = mdc_prep_elc_req(exp, req, MDS_SWAP_LAYOUTS, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_swap_layouts_pack(req, op_data);\r\npayload = req_capsule_client_get(&req->rq_pill, &RMF_SWAP_LAYOUTS);\r\nLASSERT(payload);\r\n*payload = *msl;\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nout:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_iocontrol(unsigned int cmd, struct obd_export *exp, int len,\r\nvoid *karg, void *uarg)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct obd_ioctl_data *data = karg;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nif (!try_module_get(THIS_MODULE)) {\r\nCERROR("Can't get module. Is it alive?");\r\nreturn -EINVAL;\r\n}\r\nswitch (cmd) {\r\ncase OBD_IOC_CHANGELOG_SEND:\r\nrc = mdc_ioc_changelog_send(obd, karg);\r\nGOTO(out, rc);\r\ncase OBD_IOC_CHANGELOG_CLEAR: {\r\nstruct ioc_changelog *icc = karg;\r\nstruct changelog_setinfo cs =\r\n{.cs_recno = icc->icc_recno, .cs_id = icc->icc_id};\r\nrc = obd_set_info_async(NULL, exp, strlen(KEY_CHANGELOG_CLEAR),\r\nKEY_CHANGELOG_CLEAR, sizeof(cs), &cs,\r\nNULL);\r\nGOTO(out, rc);\r\n}\r\ncase OBD_IOC_FID2PATH:\r\nrc = mdc_ioc_fid2path(exp, karg);\r\nGOTO(out, rc);\r\ncase LL_IOC_HSM_CT_START:\r\nrc = mdc_ioc_hsm_ct_start(exp, karg);\r\nif (rc == -EEXIST)\r\nrc = 0;\r\nGOTO(out, rc);\r\ncase LL_IOC_HSM_PROGRESS:\r\nrc = mdc_ioc_hsm_progress(exp, karg);\r\nGOTO(out, rc);\r\ncase LL_IOC_HSM_STATE_GET:\r\nrc = mdc_ioc_hsm_state_get(exp, karg);\r\nGOTO(out, rc);\r\ncase LL_IOC_HSM_STATE_SET:\r\nrc = mdc_ioc_hsm_state_set(exp, karg);\r\ncase LL_IOC_HSM_ACTION:\r\nrc = mdc_ioc_hsm_current_action(exp, karg);\r\nGOTO(out, rc);\r\ncase LL_IOC_HSM_REQUEST:\r\nrc = mdc_ioc_hsm_request(exp, karg);\r\nGOTO(out, rc);\r\ncase OBD_IOC_CLIENT_RECOVER:\r\nrc = ptlrpc_recover_import(imp, data->ioc_inlbuf1, 0);\r\nif (rc < 0)\r\nGOTO(out, rc);\r\nGOTO(out, rc = 0);\r\ncase IOC_OSC_SET_ACTIVE:\r\nrc = ptlrpc_set_import_active(imp, data->ioc_offset);\r\nGOTO(out, rc);\r\ncase OBD_IOC_PARSE: {\r\nctxt = llog_get_context(exp->exp_obd, LLOG_CONFIG_REPL_CTXT);\r\nrc = class_config_parse_llog(NULL, ctxt, data->ioc_inlbuf1,\r\nNULL);\r\nllog_ctxt_put(ctxt);\r\nGOTO(out, rc);\r\n}\r\ncase OBD_IOC_LLOG_INFO:\r\ncase OBD_IOC_LLOG_PRINT: {\r\nctxt = llog_get_context(obd, LLOG_CONFIG_REPL_CTXT);\r\nrc = llog_ioctl(NULL, ctxt, cmd, data);\r\nllog_ctxt_put(ctxt);\r\nGOTO(out, rc);\r\n}\r\ncase OBD_IOC_POLL_QUOTACHECK:\r\nrc = mdc_quota_poll_check(exp, (struct if_quotacheck *)karg);\r\nGOTO(out, rc);\r\ncase OBD_IOC_PING_TARGET:\r\nrc = ptlrpc_obd_ping(obd);\r\nGOTO(out, rc);\r\ncase IOC_OBD_STATFS: {\r\nstruct obd_statfs stat_buf = {0};\r\nif (*((__u32 *) data->ioc_inlbuf2) != 0)\r\nGOTO(out, rc = -ENODEV);\r\nif (copy_to_user(data->ioc_pbuf2, obd2cli_tgt(obd),\r\nmin((int) data->ioc_plen2,\r\n(int) sizeof(struct obd_uuid))))\r\nGOTO(out, rc = -EFAULT);\r\nrc = mdc_statfs(NULL, obd->obd_self_export, &stat_buf,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\n0);\r\nif (rc != 0)\r\nGOTO(out, rc);\r\nif (copy_to_user(data->ioc_pbuf1, &stat_buf,\r\nmin((int) data->ioc_plen1,\r\n(int) sizeof(stat_buf))))\r\nGOTO(out, rc = -EFAULT);\r\nGOTO(out, rc = 0);\r\n}\r\ncase OBD_IOC_QUOTACTL: {\r\nstruct if_quotactl *qctl = karg;\r\nstruct obd_quotactl *oqctl;\r\nOBD_ALLOC_PTR(oqctl);\r\nif (!oqctl)\r\nreturn -ENOMEM;\r\nQCTL_COPY(oqctl, qctl);\r\nrc = obd_quotactl(exp, oqctl);\r\nif (rc == 0) {\r\nQCTL_COPY(qctl, oqctl);\r\nqctl->qc_valid = QC_MDTIDX;\r\nqctl->obd_uuid = obd->u.cli.cl_target_uuid;\r\n}\r\nOBD_FREE_PTR(oqctl);\r\nbreak;\r\n}\r\ncase LL_IOC_GET_CONNECT_FLAGS: {\r\nif (copy_to_user(uarg,\r\nexp_connect_flags_ptr(exp),\r\nsizeof(__u64)))\r\nGOTO(out, rc = -EFAULT);\r\nelse\r\nGOTO(out, rc = 0);\r\n}\r\ncase LL_IOC_LOV_SWAP_LAYOUTS: {\r\nrc = mdc_ioc_swap_layouts(exp, karg);\r\nbreak;\r\n}\r\ndefault:\r\nCERROR("mdc_ioctl(): unrecognised ioctl %#x\n", cmd);\r\nGOTO(out, rc = -ENOTTY);\r\n}\r\nout:\r\nmodule_put(THIS_MODULE);\r\nreturn rc;\r\n}\r\nint mdc_get_info_rpc(struct obd_export *exp,\r\nobd_count keylen, void *key,\r\nint vallen, void *val)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct ptlrpc_request *req;\r\nchar *tmp;\r\nint rc = -EINVAL;\r\nreq = ptlrpc_request_alloc(imp, &RQF_MDS_GET_INFO);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GETINFO_KEY,\r\nRCL_CLIENT, keylen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GETINFO_VALLEN,\r\nRCL_CLIENT, sizeof(__u32));\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GET_INFO);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_GETINFO_KEY);\r\nmemcpy(tmp, key, keylen);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_GETINFO_VALLEN);\r\nmemcpy(tmp, &vallen, sizeof(__u32));\r\nreq_capsule_set_size(&req->rq_pill, &RMF_GETINFO_VAL,\r\nRCL_SERVER, vallen);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc == 0 || rc == -EREMOTE) {\r\ntmp = req_capsule_server_get(&req->rq_pill, &RMF_GETINFO_VAL);\r\nmemcpy(val, tmp, vallen);\r\nif (ptlrpc_rep_need_swab(req)) {\r\nif (KEY_IS(KEY_FID2PATH))\r\nlustre_swab_fid2path(val);\r\n}\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic void lustre_swab_hai(struct hsm_action_item *h)\r\n{\r\n__swab32s(&h->hai_len);\r\n__swab32s(&h->hai_action);\r\nlustre_swab_lu_fid(&h->hai_fid);\r\nlustre_swab_lu_fid(&h->hai_dfid);\r\n__swab64s(&h->hai_cookie);\r\n__swab64s(&h->hai_extent.offset);\r\n__swab64s(&h->hai_extent.length);\r\n__swab64s(&h->hai_gid);\r\n}\r\nstatic void lustre_swab_hal(struct hsm_action_list *h)\r\n{\r\nstruct hsm_action_item *hai;\r\nint i;\r\n__swab32s(&h->hal_version);\r\n__swab32s(&h->hal_count);\r\n__swab32s(&h->hal_archive_id);\r\n__swab64s(&h->hal_flags);\r\nhai = hai_zero(h);\r\nfor (i = 0; i < h->hal_count; i++) {\r\nlustre_swab_hai(hai);\r\nhai = hai_next(hai);\r\n}\r\n}\r\nstatic void lustre_swab_kuch(struct kuc_hdr *l)\r\n{\r\n__swab16s(&l->kuc_magic);\r\n__swab16s(&l->kuc_msgtype);\r\n__swab16s(&l->kuc_msglen);\r\n}\r\nstatic int mdc_ioc_hsm_ct_start(struct obd_export *exp,\r\nstruct lustre_kernelcomm *lk)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\n__u32 archive = lk->lk_data;\r\nint rc = 0;\r\nif (lk->lk_group != KUC_GRP_HSM) {\r\nCERROR("Bad copytool group %d\n", lk->lk_group);\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_HSM, "CT start r%d w%d u%d g%d f%#x\n", lk->lk_rfd, lk->lk_wfd,\r\nlk->lk_uid, lk->lk_group, lk->lk_flags);\r\nif (lk->lk_flags & LK_FLG_STOP) {\r\nrc = mdc_ioc_hsm_ct_unregister(imp);\r\n} else {\r\nrc = mdc_ioc_hsm_ct_register(imp, archive);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mdc_hsm_copytool_send(int len, void *val)\r\n{\r\nstruct kuc_hdr *lh = (struct kuc_hdr *)val;\r\nstruct hsm_action_list *hal = (struct hsm_action_list *)(lh + 1);\r\nint rc;\r\nif (len < sizeof(*lh) + sizeof(*hal)) {\r\nCERROR("Short HSM message %d < %d\n", len,\r\n(int) (sizeof(*lh) + sizeof(*hal)));\r\nreturn -EPROTO;\r\n}\r\nif (lh->kuc_magic == __swab16(KUC_MAGIC)) {\r\nlustre_swab_kuch(lh);\r\nlustre_swab_hal(hal);\r\n} else if (lh->kuc_magic != KUC_MAGIC) {\r\nCERROR("Bad magic %x!=%x\n", lh->kuc_magic, KUC_MAGIC);\r\nreturn -EPROTO;\r\n}\r\nCDEBUG(D_HSM, " Received message mg=%x t=%d m=%d l=%d actions=%d "\r\n"on %s\n",\r\nlh->kuc_magic, lh->kuc_transport, lh->kuc_msgtype,\r\nlh->kuc_msglen, hal->hal_count, hal->hal_fsname);\r\nrc = libcfs_kkuc_group_put(KUC_GRP_HSM, lh);\r\nreturn rc;\r\n}\r\nstatic int mdc_hsm_ct_reregister(__u32 data, void *cb_arg)\r\n{\r\nstruct obd_import *imp = (struct obd_import *)cb_arg;\r\n__u32 archive = data;\r\nint rc;\r\nCDEBUG(D_HA, "recover copytool registration to MDT (archive=%#x)\n",\r\narchive);\r\nrc = mdc_ioc_hsm_ct_register(imp, archive);\r\nreturn ((rc != 0) && (rc != -EEXIST)) ? rc : 0;\r\n}\r\nstatic int mdc_kuc_reregister(struct obd_import *imp)\r\n{\r\nreturn libcfs_kkuc_group_foreach(KUC_GRP_HSM, mdc_hsm_ct_reregister,\r\n(void *)imp);\r\n}\r\nint mdc_set_info_async(const struct lu_env *env,\r\nstruct obd_export *exp,\r\nobd_count keylen, void *key,\r\nobd_count vallen, void *val,\r\nstruct ptlrpc_request_set *set)\r\n{\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nint rc;\r\nif (KEY_IS(KEY_READ_ONLY)) {\r\nif (vallen != sizeof(int))\r\nreturn -EINVAL;\r\nspin_lock(&imp->imp_lock);\r\nif (*((int *)val)) {\r\nimp->imp_connect_flags_orig |= OBD_CONNECT_RDONLY;\r\nimp->imp_connect_data.ocd_connect_flags |=\r\nOBD_CONNECT_RDONLY;\r\n} else {\r\nimp->imp_connect_flags_orig &= ~OBD_CONNECT_RDONLY;\r\nimp->imp_connect_data.ocd_connect_flags &=\r\n~OBD_CONNECT_RDONLY;\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nrc = do_set_info_async(imp, MDS_SET_INFO, LUSTRE_MDS_VERSION,\r\nkeylen, key, vallen, val, set);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_SPTLRPC_CONF)) {\r\nsptlrpc_conf_client_adapt(exp->exp_obd);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_FLUSH_CTX)) {\r\nsptlrpc_import_flush_my_ctx(imp);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_MDS_CONN)) {\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_server_timeout = 1;\r\nspin_unlock(&imp->imp_lock);\r\nimp->imp_client->cli_request_portal = MDS_MDS_PORTAL;\r\nCDEBUG(D_OTHER, "%s: timeout / 2\n", exp->exp_obd->obd_name);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_CHANGELOG_CLEAR)) {\r\nrc = do_set_info_async(imp, MDS_SET_INFO, LUSTRE_MDS_VERSION,\r\nkeylen, key, vallen, val, set);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_HSM_COPYTOOL_SEND)) {\r\nrc = mdc_hsm_copytool_send(vallen, val);\r\nreturn rc;\r\n}\r\nCERROR("Unknown key %s\n", (char *)key);\r\nreturn -EINVAL;\r\n}\r\nint mdc_get_info(const struct lu_env *env, struct obd_export *exp,\r\n__u32 keylen, void *key, __u32 *vallen, void *val,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nint rc = -EINVAL;\r\nif (KEY_IS(KEY_MAX_EASIZE)) {\r\nint mdsize, *max_easize;\r\nif (*vallen != sizeof(int))\r\nreturn -EINVAL;\r\nmdsize = *(int*)val;\r\nif (mdsize > exp->exp_obd->u.cli.cl_max_mds_easize)\r\nexp->exp_obd->u.cli.cl_max_mds_easize = mdsize;\r\nmax_easize = val;\r\n*max_easize = exp->exp_obd->u.cli.cl_max_mds_easize;\r\nreturn 0;\r\n} else if (KEY_IS(KEY_CONN_DATA)) {\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct obd_connect_data *data = val;\r\nif (*vallen != sizeof(*data))\r\nreturn -EINVAL;\r\n*data = imp->imp_connect_data;\r\nreturn 0;\r\n} else if (KEY_IS(KEY_TGT_COUNT)) {\r\n*((int *)val) = 1;\r\nreturn 0;\r\n}\r\nrc = mdc_get_info_rpc(exp, keylen, key, *vallen, val);\r\nreturn rc;\r\n}\r\nstatic int mdc_pin(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, struct obd_client_handle *handle,\r\nint flags)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mdt_body *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_PIN);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, oc);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_PIN);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, fid, oc, 0, 0, -1, flags);\r\nptlrpc_request_set_replen(req);\r\nmdc_get_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nif (rc) {\r\nCERROR("Pin failed: %d\n", rc);\r\nGOTO(err_out, rc);\r\n}\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nGOTO(err_out, rc = -EPROTO);\r\nhandle->och_fh = body->handle;\r\nhandle->och_magic = OBD_CLIENT_HANDLE_MAGIC;\r\nhandle->och_mod = obd_mod_alloc();\r\nif (handle->och_mod == NULL) {\r\nDEBUG_REQ(D_ERROR, req, "can't allocate md_open_data");\r\nGOTO(err_out, rc = -ENOMEM);\r\n}\r\nhandle->och_mod->mod_open_req = req;\r\nreturn 0;\r\nerr_out:\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mdc_unpin(struct obd_export *exp, struct obd_client_handle *handle,\r\nint flag)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mdt_body *body;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp), &RQF_MDS_UNPIN,\r\nLUSTRE_MDS_VERSION, MDS_UNPIN);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_MDT_BODY);\r\nbody->handle = handle->och_fh;\r\nbody->flags = flag;\r\nptlrpc_request_set_replen(req);\r\nmdc_get_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nrc = ptlrpc_queue_wait(req);\r\nmdc_put_rpc_lock(exp->exp_obd->u.cli.cl_rpc_lock, NULL);\r\nif (rc != 0)\r\nCERROR("Unpin failed: %d\n", rc);\r\nptlrpc_req_finished(req);\r\nptlrpc_req_finished(handle->och_mod->mod_open_req);\r\nobd_mod_put(handle->och_mod);\r\nreturn rc;\r\n}\r\nint mdc_sync(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, struct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_SYNC);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, oc);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_SYNC);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, fid, oc, 0, 0, -1, 0);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_import_event(struct obd_device *obd, struct obd_import *imp,\r\nenum obd_import_event event)\r\n{\r\nint rc = 0;\r\nLASSERT(imp->imp_obd == obd);\r\nswitch (event) {\r\ncase IMP_EVENT_DISCON: {\r\n#if 0\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_DISCON, NULL);\r\n#endif\r\nbreak;\r\n}\r\ncase IMP_EVENT_INACTIVE: {\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (cli->cl_seq != NULL)\r\nseq_client_flush(cli->cl_seq);\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_INACTIVE, NULL);\r\nbreak;\r\n}\r\ncase IMP_EVENT_INVALIDATE: {\r\nstruct ldlm_namespace *ns = obd->obd_namespace;\r\nldlm_namespace_cleanup(ns, LDLM_FL_LOCAL_ONLY);\r\nbreak;\r\n}\r\ncase IMP_EVENT_ACTIVE:\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_ACTIVE, NULL);\r\nif (rc == 0)\r\nrc = mdc_kuc_reregister(imp);\r\nbreak;\r\ncase IMP_EVENT_OCD:\r\nrc = obd_notify_observer(obd, obd, OBD_NOTIFY_OCD, NULL);\r\nbreak;\r\ncase IMP_EVENT_DEACTIVATE:\r\ncase IMP_EVENT_ACTIVATE:\r\nbreak;\r\ndefault:\r\nCERROR("Unknown import event %x\n", event);\r\nLBUG();\r\n}\r\nreturn rc;\r\n}\r\nint mdc_fid_alloc(struct obd_export *exp, struct lu_fid *fid,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct lu_client_seq *seq = cli->cl_seq;\r\nreturn seq_client_alloc_fid(NULL, seq, fid);\r\n}\r\nstruct obd_uuid *mdc_get_uuid(struct obd_export *exp) {\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nreturn &cli->cl_target_uuid;\r\n}\r\nstatic int mdc_cancel_for_recovery(struct ldlm_lock *lock)\r\n{\r\nif (lock->l_resource->lr_type != LDLM_IBITS)\r\nreturn 0;\r\nif (lock->l_policy_data.l_inodebits.bits & MDS_INODELOCK_OPEN)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int mdc_resource_inode_free(struct ldlm_resource *res)\r\n{\r\nif (res->lr_lvb_inode)\r\nres->lr_lvb_inode = NULL;\r\nreturn 0;\r\n}\r\nstatic int mdc_setup(struct obd_device *obd, struct lustre_cfg *cfg)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nstruct lprocfs_static_vars lvars = { 0 };\r\nint rc;\r\nOBD_ALLOC(cli->cl_rpc_lock, sizeof (*cli->cl_rpc_lock));\r\nif (!cli->cl_rpc_lock)\r\nreturn -ENOMEM;\r\nmdc_init_rpc_lock(cli->cl_rpc_lock);\r\nptlrpcd_addref();\r\nOBD_ALLOC(cli->cl_close_lock, sizeof (*cli->cl_close_lock));\r\nif (!cli->cl_close_lock)\r\nGOTO(err_rpc_lock, rc = -ENOMEM);\r\nmdc_init_rpc_lock(cli->cl_close_lock);\r\nrc = client_obd_setup(obd, cfg);\r\nif (rc)\r\nGOTO(err_close_lock, rc);\r\nlprocfs_mdc_init_vars(&lvars);\r\nlprocfs_obd_setup(obd, lvars.obd_vars);\r\nsptlrpc_lprocfs_cliobd_attach(obd);\r\nptlrpc_lprocfs_register_obd(obd);\r\nns_register_cancel(obd->obd_namespace, mdc_cancel_for_recovery);\r\nobd->obd_namespace->ns_lvbo = &inode_lvbo;\r\nrc = obd_llog_init(obd, &obd->obd_olg, obd, NULL);\r\nif (rc) {\r\nmdc_cleanup(obd);\r\nCERROR("failed to setup llogging subsystems\n");\r\n}\r\nreturn rc;\r\nerr_close_lock:\r\nOBD_FREE(cli->cl_close_lock, sizeof (*cli->cl_close_lock));\r\nerr_rpc_lock:\r\nOBD_FREE(cli->cl_rpc_lock, sizeof (*cli->cl_rpc_lock));\r\nptlrpcd_decref();\r\nreturn rc;\r\n}\r\nstatic int mdc_init_ea_size(struct obd_export *exp, int easize,\r\nint def_easize, int cookiesize)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct client_obd *cli = &obd->u.cli;\r\nif (cli->cl_max_mds_easize < easize)\r\ncli->cl_max_mds_easize = easize;\r\nif (cli->cl_default_mds_easize < def_easize)\r\ncli->cl_default_mds_easize = def_easize;\r\nif (cli->cl_max_mds_cookiesize < cookiesize)\r\ncli->cl_max_mds_cookiesize = cookiesize;\r\nreturn 0;\r\n}\r\nstatic int mdc_precleanup(struct obd_device *obd, enum obd_cleanup_stage stage)\r\n{\r\nint rc = 0;\r\nswitch (stage) {\r\ncase OBD_CLEANUP_EARLY:\r\nbreak;\r\ncase OBD_CLEANUP_EXPORTS:\r\nif (obd->obd_type->typ_refcnt <= 1)\r\nlibcfs_kkuc_group_rem(0, KUC_GRP_HSM);\r\nobd_cleanup_client_import(obd);\r\nptlrpc_lprocfs_unregister_obd(obd);\r\nlprocfs_obd_cleanup(obd);\r\nrc = obd_llog_finish(obd, 0);\r\nif (rc != 0)\r\nCERROR("failed to cleanup llogging subsystems\n");\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mdc_cleanup(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nOBD_FREE(cli->cl_rpc_lock, sizeof (*cli->cl_rpc_lock));\r\nOBD_FREE(cli->cl_close_lock, sizeof (*cli->cl_close_lock));\r\nptlrpcd_decref();\r\nreturn client_obd_cleanup(obd);\r\n}\r\nstatic int mdc_llog_init(struct obd_device *obd, struct obd_llog_group *olg,\r\nstruct obd_device *tgt, int *index)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nLASSERT(olg == &obd->obd_olg);\r\nrc = llog_setup(NULL, obd, olg, LLOG_CHANGELOG_REPL_CTXT, tgt,\r\n&llog_client_ops);\r\nif (rc)\r\nreturn rc;\r\nctxt = llog_group_get_ctxt(olg, LLOG_CHANGELOG_REPL_CTXT);\r\nllog_initiator_connect(ctxt);\r\nllog_ctxt_put(ctxt);\r\nreturn 0;\r\n}\r\nstatic int mdc_llog_finish(struct obd_device *obd, int count)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nctxt = llog_get_context(obd, LLOG_CHANGELOG_REPL_CTXT);\r\nif (ctxt)\r\nllog_cleanup(NULL, ctxt);\r\nreturn 0;\r\n}\r\nstatic int mdc_process_config(struct obd_device *obd, obd_count len, void *buf)\r\n{\r\nstruct lustre_cfg *lcfg = buf;\r\nstruct lprocfs_static_vars lvars = { 0 };\r\nint rc = 0;\r\nlprocfs_mdc_init_vars(&lvars);\r\nswitch (lcfg->lcfg_command) {\r\ndefault:\r\nrc = class_process_proc_param(PARAM_MDC, lvars.obd_vars,\r\nlcfg, obd);\r\nif (rc > 0)\r\nrc = 0;\r\nbreak;\r\n}\r\nreturn(rc);\r\n}\r\nint mdc_get_remote_perm(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, __u32 suppgid,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nLASSERT(client_is_remote(exp));\r\n*request = NULL;\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_GETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_set_capa_size(req, &RMF_CAPA1, oc);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MDS_VERSION, MDS_GETATTR);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_pack_body(req, fid, oc, OBD_MD_FLRMTPERM, 0, suppgid, 0);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_ACL, RCL_SERVER,\r\nsizeof(struct mdt_remote_perm));\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nptlrpc_req_finished(req);\r\nelse\r\n*request = req;\r\nreturn rc;\r\n}\r\nstatic int mdc_interpret_renew_capa(const struct lu_env *env,\r\nstruct ptlrpc_request *req, void *args,\r\nint status)\r\n{\r\nstruct mdc_renew_capa_args *ra = args;\r\nstruct mdt_body *body = NULL;\r\nstruct lustre_capa *capa;\r\nif (status)\r\nGOTO(out, capa = ERR_PTR(status));\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nGOTO(out, capa = ERR_PTR(-EFAULT));\r\nif ((body->valid & OBD_MD_FLOSSCAPA) == 0)\r\nGOTO(out, capa = ERR_PTR(-ENOENT));\r\ncapa = req_capsule_server_get(&req->rq_pill, &RMF_CAPA2);\r\nif (!capa)\r\nGOTO(out, capa = ERR_PTR(-EFAULT));\r\nout:\r\nra->ra_cb(ra->ra_oc, capa);\r\nreturn 0;\r\n}\r\nstatic int mdc_renew_capa(struct obd_export *exp, struct obd_capa *oc,\r\nrenew_capa_cb_t cb)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mdc_renew_capa_args *ra;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp), &RQF_MDS_GETATTR,\r\nLUSTRE_MDS_VERSION, MDS_GETATTR);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nmdc_pack_body(req, &oc->c_capa.lc_fid, oc, OBD_MD_FLOSSCAPA, 0, -1, 0);\r\nptlrpc_request_set_replen(req);\r\nCLASSERT(sizeof(*ra) <= sizeof(req->rq_async_args));\r\nra = ptlrpc_req_async_args(req);\r\nra->ra_oc = oc;\r\nra->ra_cb = cb;\r\nreq->rq_interpret_reply = mdc_interpret_renew_capa;\r\nptlrpcd_add_req(req, PDL_POLICY_LOCAL, -1);\r\nreturn 0;\r\n}\r\nstatic int mdc_connect(const struct lu_env *env,\r\nstruct obd_export **exp,\r\nstruct obd_device *obd, struct obd_uuid *cluuid,\r\nstruct obd_connect_data *data,\r\nvoid *localdata)\r\n{\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nif (data && (data->ocd_connect_flags & OBD_CONNECT_MDS_MDS)) {\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_server_timeout = 1;\r\nspin_unlock(&imp->imp_lock);\r\nimp->imp_client->cli_request_portal = MDS_MDS_PORTAL;\r\nCDEBUG(D_OTHER, "%s: Set 'mds' portal and timeout\n",\r\nobd->obd_name);\r\n}\r\nreturn client_connect_import(env, exp, obd, cluuid, data, NULL);\r\n}\r\nint __init mdc_init(void)\r\n{\r\nint rc;\r\nstruct lprocfs_static_vars lvars = { 0 };\r\nlprocfs_mdc_init_vars(&lvars);\r\nrc = class_register_type(&mdc_obd_ops, &mdc_md_ops, lvars.module_vars,\r\nLUSTRE_MDC_NAME, NULL);\r\nreturn rc;\r\n}\r\nstatic void mdc_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_MDC_NAME);\r\n}
