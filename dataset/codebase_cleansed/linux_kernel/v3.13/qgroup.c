static struct btrfs_qgroup *find_qgroup_rb(struct btrfs_fs_info *fs_info,\r\nu64 qgroupid)\r\n{\r\nstruct rb_node *n = fs_info->qgroup_tree.rb_node;\r\nstruct btrfs_qgroup *qgroup;\r\nwhile (n) {\r\nqgroup = rb_entry(n, struct btrfs_qgroup, node);\r\nif (qgroup->qgroupid < qgroupid)\r\nn = n->rb_left;\r\nelse if (qgroup->qgroupid > qgroupid)\r\nn = n->rb_right;\r\nelse\r\nreturn qgroup;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct btrfs_qgroup *add_qgroup_rb(struct btrfs_fs_info *fs_info,\r\nu64 qgroupid)\r\n{\r\nstruct rb_node **p = &fs_info->qgroup_tree.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct btrfs_qgroup *qgroup;\r\nwhile (*p) {\r\nparent = *p;\r\nqgroup = rb_entry(parent, struct btrfs_qgroup, node);\r\nif (qgroup->qgroupid < qgroupid)\r\np = &(*p)->rb_left;\r\nelse if (qgroup->qgroupid > qgroupid)\r\np = &(*p)->rb_right;\r\nelse\r\nreturn qgroup;\r\n}\r\nqgroup = kzalloc(sizeof(*qgroup), GFP_ATOMIC);\r\nif (!qgroup)\r\nreturn ERR_PTR(-ENOMEM);\r\nqgroup->qgroupid = qgroupid;\r\nINIT_LIST_HEAD(&qgroup->groups);\r\nINIT_LIST_HEAD(&qgroup->members);\r\nINIT_LIST_HEAD(&qgroup->dirty);\r\nrb_link_node(&qgroup->node, parent, p);\r\nrb_insert_color(&qgroup->node, &fs_info->qgroup_tree);\r\nreturn qgroup;\r\n}\r\nstatic void __del_qgroup_rb(struct btrfs_qgroup *qgroup)\r\n{\r\nstruct btrfs_qgroup_list *list;\r\nlist_del(&qgroup->dirty);\r\nwhile (!list_empty(&qgroup->groups)) {\r\nlist = list_first_entry(&qgroup->groups,\r\nstruct btrfs_qgroup_list, next_group);\r\nlist_del(&list->next_group);\r\nlist_del(&list->next_member);\r\nkfree(list);\r\n}\r\nwhile (!list_empty(&qgroup->members)) {\r\nlist = list_first_entry(&qgroup->members,\r\nstruct btrfs_qgroup_list, next_member);\r\nlist_del(&list->next_group);\r\nlist_del(&list->next_member);\r\nkfree(list);\r\n}\r\nkfree(qgroup);\r\n}\r\nstatic int del_qgroup_rb(struct btrfs_fs_info *fs_info, u64 qgroupid)\r\n{\r\nstruct btrfs_qgroup *qgroup = find_qgroup_rb(fs_info, qgroupid);\r\nif (!qgroup)\r\nreturn -ENOENT;\r\nrb_erase(&qgroup->node, &fs_info->qgroup_tree);\r\n__del_qgroup_rb(qgroup);\r\nreturn 0;\r\n}\r\nstatic int add_relation_rb(struct btrfs_fs_info *fs_info,\r\nu64 memberid, u64 parentid)\r\n{\r\nstruct btrfs_qgroup *member;\r\nstruct btrfs_qgroup *parent;\r\nstruct btrfs_qgroup_list *list;\r\nmember = find_qgroup_rb(fs_info, memberid);\r\nparent = find_qgroup_rb(fs_info, parentid);\r\nif (!member || !parent)\r\nreturn -ENOENT;\r\nlist = kzalloc(sizeof(*list), GFP_ATOMIC);\r\nif (!list)\r\nreturn -ENOMEM;\r\nlist->group = parent;\r\nlist->member = member;\r\nlist_add_tail(&list->next_group, &member->groups);\r\nlist_add_tail(&list->next_member, &parent->members);\r\nreturn 0;\r\n}\r\nstatic int del_relation_rb(struct btrfs_fs_info *fs_info,\r\nu64 memberid, u64 parentid)\r\n{\r\nstruct btrfs_qgroup *member;\r\nstruct btrfs_qgroup *parent;\r\nstruct btrfs_qgroup_list *list;\r\nmember = find_qgroup_rb(fs_info, memberid);\r\nparent = find_qgroup_rb(fs_info, parentid);\r\nif (!member || !parent)\r\nreturn -ENOENT;\r\nlist_for_each_entry(list, &member->groups, next_group) {\r\nif (list->group == parent) {\r\nlist_del(&list->next_group);\r\nlist_del(&list->next_member);\r\nkfree(list);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint btrfs_read_qgroup_config(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_key key;\r\nstruct btrfs_key found_key;\r\nstruct btrfs_root *quota_root = fs_info->quota_root;\r\nstruct btrfs_path *path = NULL;\r\nstruct extent_buffer *l;\r\nint slot;\r\nint ret = 0;\r\nu64 flags = 0;\r\nu64 rescan_progress = 0;\r\nif (!fs_info->quota_enabled)\r\nreturn 0;\r\nfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\r\nif (!fs_info->qgroup_ulist) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfs_info->qgroup_flags = 0;\r\nkey.objectid = 0;\r\nkey.type = 0;\r\nkey.offset = 0;\r\nret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 1);\r\nif (ret)\r\ngoto out;\r\nwhile (1) {\r\nstruct btrfs_qgroup *qgroup;\r\nslot = path->slots[0];\r\nl = path->nodes[0];\r\nbtrfs_item_key_to_cpu(l, &found_key, slot);\r\nif (found_key.type == BTRFS_QGROUP_STATUS_KEY) {\r\nstruct btrfs_qgroup_status_item *ptr;\r\nptr = btrfs_item_ptr(l, slot,\r\nstruct btrfs_qgroup_status_item);\r\nif (btrfs_qgroup_status_version(l, ptr) !=\r\nBTRFS_QGROUP_STATUS_VERSION) {\r\nprintk(KERN_ERR\r\n"btrfs: old qgroup version, quota disabled\n");\r\ngoto out;\r\n}\r\nif (btrfs_qgroup_status_generation(l, ptr) !=\r\nfs_info->generation) {\r\nflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\nprintk(KERN_ERR\r\n"btrfs: qgroup generation mismatch, "\r\n"marked as inconsistent\n");\r\n}\r\nfs_info->qgroup_flags = btrfs_qgroup_status_flags(l,\r\nptr);\r\nrescan_progress = btrfs_qgroup_status_rescan(l, ptr);\r\ngoto next1;\r\n}\r\nif (found_key.type != BTRFS_QGROUP_INFO_KEY &&\r\nfound_key.type != BTRFS_QGROUP_LIMIT_KEY)\r\ngoto next1;\r\nqgroup = find_qgroup_rb(fs_info, found_key.offset);\r\nif ((qgroup && found_key.type == BTRFS_QGROUP_INFO_KEY) ||\r\n(!qgroup && found_key.type == BTRFS_QGROUP_LIMIT_KEY)) {\r\nprintk(KERN_ERR "btrfs: inconsitent qgroup config\n");\r\nflags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\n}\r\nif (!qgroup) {\r\nqgroup = add_qgroup_rb(fs_info, found_key.offset);\r\nif (IS_ERR(qgroup)) {\r\nret = PTR_ERR(qgroup);\r\ngoto out;\r\n}\r\n}\r\nswitch (found_key.type) {\r\ncase BTRFS_QGROUP_INFO_KEY: {\r\nstruct btrfs_qgroup_info_item *ptr;\r\nptr = btrfs_item_ptr(l, slot,\r\nstruct btrfs_qgroup_info_item);\r\nqgroup->rfer = btrfs_qgroup_info_rfer(l, ptr);\r\nqgroup->rfer_cmpr = btrfs_qgroup_info_rfer_cmpr(l, ptr);\r\nqgroup->excl = btrfs_qgroup_info_excl(l, ptr);\r\nqgroup->excl_cmpr = btrfs_qgroup_info_excl_cmpr(l, ptr);\r\nbreak;\r\n}\r\ncase BTRFS_QGROUP_LIMIT_KEY: {\r\nstruct btrfs_qgroup_limit_item *ptr;\r\nptr = btrfs_item_ptr(l, slot,\r\nstruct btrfs_qgroup_limit_item);\r\nqgroup->lim_flags = btrfs_qgroup_limit_flags(l, ptr);\r\nqgroup->max_rfer = btrfs_qgroup_limit_max_rfer(l, ptr);\r\nqgroup->max_excl = btrfs_qgroup_limit_max_excl(l, ptr);\r\nqgroup->rsv_rfer = btrfs_qgroup_limit_rsv_rfer(l, ptr);\r\nqgroup->rsv_excl = btrfs_qgroup_limit_rsv_excl(l, ptr);\r\nbreak;\r\n}\r\n}\r\nnext1:\r\nret = btrfs_next_item(quota_root, path);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret)\r\nbreak;\r\n}\r\nbtrfs_release_path(path);\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_RELATION_KEY;\r\nkey.offset = 0;\r\nret = btrfs_search_slot_for_read(quota_root, &key, path, 1, 0);\r\nif (ret)\r\ngoto out;\r\nwhile (1) {\r\nslot = path->slots[0];\r\nl = path->nodes[0];\r\nbtrfs_item_key_to_cpu(l, &found_key, slot);\r\nif (found_key.type != BTRFS_QGROUP_RELATION_KEY)\r\ngoto next2;\r\nif (found_key.objectid > found_key.offset) {\r\ngoto next2;\r\n}\r\nret = add_relation_rb(fs_info, found_key.objectid,\r\nfound_key.offset);\r\nif (ret == -ENOENT) {\r\nprintk(KERN_WARNING\r\n"btrfs: orphan qgroup relation 0x%llx->0x%llx\n",\r\nfound_key.objectid, found_key.offset);\r\nret = 0;\r\n}\r\nif (ret)\r\ngoto out;\r\nnext2:\r\nret = btrfs_next_item(quota_root, path);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret)\r\nbreak;\r\n}\r\nout:\r\nfs_info->qgroup_flags |= flags;\r\nif (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON)) {\r\nfs_info->quota_enabled = 0;\r\nfs_info->pending_quota_state = 0;\r\n} else if (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN &&\r\nret >= 0) {\r\nret = qgroup_rescan_init(fs_info, rescan_progress, 0);\r\n}\r\nbtrfs_free_path(path);\r\nif (ret < 0) {\r\nulist_free(fs_info->qgroup_ulist);\r\nfs_info->qgroup_ulist = NULL;\r\nfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\r\n}\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nvoid btrfs_free_qgroup_config(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct rb_node *n;\r\nstruct btrfs_qgroup *qgroup;\r\nwhile ((n = rb_first(&fs_info->qgroup_tree))) {\r\nqgroup = rb_entry(n, struct btrfs_qgroup, node);\r\nrb_erase(n, &fs_info->qgroup_tree);\r\n__del_qgroup_rb(qgroup);\r\n}\r\nulist_free(fs_info->qgroup_ulist);\r\nfs_info->qgroup_ulist = NULL;\r\n}\r\nstatic int add_qgroup_relation_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *quota_root,\r\nu64 src, u64 dst)\r\n{\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = src;\r\nkey.type = BTRFS_QGROUP_RELATION_KEY;\r\nkey.offset = dst;\r\nret = btrfs_insert_empty_item(trans, quota_root, path, &key, 0);\r\nbtrfs_mark_buffer_dirty(path->nodes[0]);\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int del_qgroup_relation_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *quota_root,\r\nu64 src, u64 dst)\r\n{\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = src;\r\nkey.type = BTRFS_QGROUP_RELATION_KEY;\r\nkey.offset = dst;\r\nret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > 0) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nret = btrfs_del_item(trans, quota_root, path);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int add_qgroup_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *quota_root, u64 qgroupid)\r\n{\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_qgroup_info_item *qgroup_info;\r\nstruct btrfs_qgroup_limit_item *qgroup_limit;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key key;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_INFO_KEY;\r\nkey.offset = qgroupid;\r\nret = btrfs_insert_empty_item(trans, quota_root, path, &key,\r\nsizeof(*qgroup_info));\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nqgroup_info = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_qgroup_info_item);\r\nbtrfs_set_qgroup_info_generation(leaf, qgroup_info, trans->transid);\r\nbtrfs_set_qgroup_info_rfer(leaf, qgroup_info, 0);\r\nbtrfs_set_qgroup_info_rfer_cmpr(leaf, qgroup_info, 0);\r\nbtrfs_set_qgroup_info_excl(leaf, qgroup_info, 0);\r\nbtrfs_set_qgroup_info_excl_cmpr(leaf, qgroup_info, 0);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nbtrfs_release_path(path);\r\nkey.type = BTRFS_QGROUP_LIMIT_KEY;\r\nret = btrfs_insert_empty_item(trans, quota_root, path, &key,\r\nsizeof(*qgroup_limit));\r\nif (ret)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nqgroup_limit = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_qgroup_limit_item);\r\nbtrfs_set_qgroup_limit_flags(leaf, qgroup_limit, 0);\r\nbtrfs_set_qgroup_limit_max_rfer(leaf, qgroup_limit, 0);\r\nbtrfs_set_qgroup_limit_max_excl(leaf, qgroup_limit, 0);\r\nbtrfs_set_qgroup_limit_rsv_rfer(leaf, qgroup_limit, 0);\r\nbtrfs_set_qgroup_limit_rsv_excl(leaf, qgroup_limit, 0);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nret = 0;\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int del_qgroup_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *quota_root, u64 qgroupid)\r\n{\r\nint ret;\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_INFO_KEY;\r\nkey.offset = qgroupid;\r\nret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > 0) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nret = btrfs_del_item(trans, quota_root, path);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\nkey.type = BTRFS_QGROUP_LIMIT_KEY;\r\nret = btrfs_search_slot(trans, quota_root, &key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nif (ret > 0) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nret = btrfs_del_item(trans, quota_root, path);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int update_qgroup_limit_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root, u64 qgroupid,\r\nu64 flags, u64 max_rfer, u64 max_excl,\r\nu64 rsv_rfer, u64 rsv_excl)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *l;\r\nstruct btrfs_qgroup_limit_item *qgroup_limit;\r\nint ret;\r\nint slot;\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_LIMIT_KEY;\r\nkey.offset = qgroupid;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, &key, path, 0, 1);\r\nif (ret > 0)\r\nret = -ENOENT;\r\nif (ret)\r\ngoto out;\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nqgroup_limit = btrfs_item_ptr(l, path->slots[0],\r\nstruct btrfs_qgroup_limit_item);\r\nbtrfs_set_qgroup_limit_flags(l, qgroup_limit, flags);\r\nbtrfs_set_qgroup_limit_max_rfer(l, qgroup_limit, max_rfer);\r\nbtrfs_set_qgroup_limit_max_excl(l, qgroup_limit, max_excl);\r\nbtrfs_set_qgroup_limit_rsv_rfer(l, qgroup_limit, rsv_rfer);\r\nbtrfs_set_qgroup_limit_rsv_excl(l, qgroup_limit, rsv_excl);\r\nbtrfs_mark_buffer_dirty(l);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int update_qgroup_info_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root,\r\nstruct btrfs_qgroup *qgroup)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *l;\r\nstruct btrfs_qgroup_info_item *qgroup_info;\r\nint ret;\r\nint slot;\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_INFO_KEY;\r\nkey.offset = qgroup->qgroupid;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, &key, path, 0, 1);\r\nif (ret > 0)\r\nret = -ENOENT;\r\nif (ret)\r\ngoto out;\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nqgroup_info = btrfs_item_ptr(l, path->slots[0],\r\nstruct btrfs_qgroup_info_item);\r\nbtrfs_set_qgroup_info_generation(l, qgroup_info, trans->transid);\r\nbtrfs_set_qgroup_info_rfer(l, qgroup_info, qgroup->rfer);\r\nbtrfs_set_qgroup_info_rfer_cmpr(l, qgroup_info, qgroup->rfer_cmpr);\r\nbtrfs_set_qgroup_info_excl(l, qgroup_info, qgroup->excl);\r\nbtrfs_set_qgroup_info_excl_cmpr(l, qgroup_info, qgroup->excl_cmpr);\r\nbtrfs_mark_buffer_dirty(l);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int update_qgroup_status_item(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *l;\r\nstruct btrfs_qgroup_status_item *ptr;\r\nint ret;\r\nint slot;\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_STATUS_KEY;\r\nkey.offset = 0;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\nret = btrfs_search_slot(trans, root, &key, path, 0, 1);\r\nif (ret > 0)\r\nret = -ENOENT;\r\nif (ret)\r\ngoto out;\r\nl = path->nodes[0];\r\nslot = path->slots[0];\r\nptr = btrfs_item_ptr(l, slot, struct btrfs_qgroup_status_item);\r\nbtrfs_set_qgroup_status_flags(l, ptr, fs_info->qgroup_flags);\r\nbtrfs_set_qgroup_status_generation(l, ptr, trans->transid);\r\nbtrfs_set_qgroup_status_rescan(l, ptr,\r\nfs_info->qgroup_rescan_progress.objectid);\r\nbtrfs_mark_buffer_dirty(l);\r\nout:\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nstatic int btrfs_clean_quota_tree(struct btrfs_trans_handle *trans,\r\nstruct btrfs_root *root)\r\n{\r\nstruct btrfs_path *path;\r\nstruct btrfs_key key;\r\nstruct extent_buffer *leaf = NULL;\r\nint ret;\r\nint nr = 0;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\nreturn -ENOMEM;\r\npath->leave_spinning = 1;\r\nkey.objectid = 0;\r\nkey.offset = 0;\r\nkey.type = 0;\r\nwhile (1) {\r\nret = btrfs_search_slot(trans, root, &key, path, -1, 1);\r\nif (ret < 0)\r\ngoto out;\r\nleaf = path->nodes[0];\r\nnr = btrfs_header_nritems(leaf);\r\nif (!nr)\r\nbreak;\r\npath->slots[0] = 0;\r\nret = btrfs_del_items(trans, root, path, 0, nr);\r\nif (ret)\r\ngoto out;\r\nbtrfs_release_path(path);\r\n}\r\nret = 0;\r\nout:\r\nroot->fs_info->pending_quota_state = 0;\r\nbtrfs_free_path(path);\r\nreturn ret;\r\n}\r\nint btrfs_quota_enable(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_root *tree_root = fs_info->tree_root;\r\nstruct btrfs_path *path = NULL;\r\nstruct btrfs_qgroup_status_item *ptr;\r\nstruct extent_buffer *leaf;\r\nstruct btrfs_key key;\r\nstruct btrfs_key found_key;\r\nstruct btrfs_qgroup *qgroup = NULL;\r\nint ret = 0;\r\nint slot;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nif (fs_info->quota_root) {\r\nfs_info->pending_quota_state = 1;\r\ngoto out;\r\n}\r\nfs_info->qgroup_ulist = ulist_alloc(GFP_NOFS);\r\nif (!fs_info->qgroup_ulist) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nquota_root = btrfs_create_tree(trans, fs_info,\r\nBTRFS_QUOTA_TREE_OBJECTID);\r\nif (IS_ERR(quota_root)) {\r\nret = PTR_ERR(quota_root);\r\ngoto out;\r\n}\r\npath = btrfs_alloc_path();\r\nif (!path) {\r\nret = -ENOMEM;\r\ngoto out_free_root;\r\n}\r\nkey.objectid = 0;\r\nkey.type = BTRFS_QGROUP_STATUS_KEY;\r\nkey.offset = 0;\r\nret = btrfs_insert_empty_item(trans, quota_root, path, &key,\r\nsizeof(*ptr));\r\nif (ret)\r\ngoto out_free_path;\r\nleaf = path->nodes[0];\r\nptr = btrfs_item_ptr(leaf, path->slots[0],\r\nstruct btrfs_qgroup_status_item);\r\nbtrfs_set_qgroup_status_generation(leaf, ptr, trans->transid);\r\nbtrfs_set_qgroup_status_version(leaf, ptr, BTRFS_QGROUP_STATUS_VERSION);\r\nfs_info->qgroup_flags = BTRFS_QGROUP_STATUS_FLAG_ON |\r\nBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\nbtrfs_set_qgroup_status_flags(leaf, ptr, fs_info->qgroup_flags);\r\nbtrfs_set_qgroup_status_rescan(leaf, ptr, 0);\r\nbtrfs_mark_buffer_dirty(leaf);\r\nkey.objectid = 0;\r\nkey.type = BTRFS_ROOT_REF_KEY;\r\nkey.offset = 0;\r\nbtrfs_release_path(path);\r\nret = btrfs_search_slot_for_read(tree_root, &key, path, 1, 0);\r\nif (ret > 0)\r\ngoto out_add_root;\r\nif (ret < 0)\r\ngoto out_free_path;\r\nwhile (1) {\r\nslot = path->slots[0];\r\nleaf = path->nodes[0];\r\nbtrfs_item_key_to_cpu(leaf, &found_key, slot);\r\nif (found_key.type == BTRFS_ROOT_REF_KEY) {\r\nret = add_qgroup_item(trans, quota_root,\r\nfound_key.offset);\r\nif (ret)\r\ngoto out_free_path;\r\nqgroup = add_qgroup_rb(fs_info, found_key.offset);\r\nif (IS_ERR(qgroup)) {\r\nret = PTR_ERR(qgroup);\r\ngoto out_free_path;\r\n}\r\n}\r\nret = btrfs_next_item(tree_root, path);\r\nif (ret < 0)\r\ngoto out_free_path;\r\nif (ret)\r\nbreak;\r\n}\r\nout_add_root:\r\nbtrfs_release_path(path);\r\nret = add_qgroup_item(trans, quota_root, BTRFS_FS_TREE_OBJECTID);\r\nif (ret)\r\ngoto out_free_path;\r\nqgroup = add_qgroup_rb(fs_info, BTRFS_FS_TREE_OBJECTID);\r\nif (IS_ERR(qgroup)) {\r\nret = PTR_ERR(qgroup);\r\ngoto out_free_path;\r\n}\r\nspin_lock(&fs_info->qgroup_lock);\r\nfs_info->quota_root = quota_root;\r\nfs_info->pending_quota_state = 1;\r\nspin_unlock(&fs_info->qgroup_lock);\r\nout_free_path:\r\nbtrfs_free_path(path);\r\nout_free_root:\r\nif (ret) {\r\nfree_extent_buffer(quota_root->node);\r\nfree_extent_buffer(quota_root->commit_root);\r\nkfree(quota_root);\r\n}\r\nout:\r\nif (ret) {\r\nulist_free(fs_info->qgroup_ulist);\r\nfs_info->qgroup_ulist = NULL;\r\n}\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_quota_disable(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_root *tree_root = fs_info->tree_root;\r\nstruct btrfs_root *quota_root;\r\nint ret = 0;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nif (!fs_info->quota_root)\r\ngoto out;\r\nspin_lock(&fs_info->qgroup_lock);\r\nfs_info->quota_enabled = 0;\r\nfs_info->pending_quota_state = 0;\r\nquota_root = fs_info->quota_root;\r\nfs_info->quota_root = NULL;\r\nspin_unlock(&fs_info->qgroup_lock);\r\nbtrfs_free_qgroup_config(fs_info);\r\nret = btrfs_clean_quota_tree(trans, quota_root);\r\nif (ret)\r\ngoto out;\r\nret = btrfs_del_root(trans, tree_root, &quota_root->root_key);\r\nif (ret)\r\ngoto out;\r\nlist_del(&quota_root->dirty_list);\r\nbtrfs_tree_lock(quota_root->node);\r\nclean_tree_block(trans, tree_root, quota_root->node);\r\nbtrfs_tree_unlock(quota_root->node);\r\nbtrfs_free_tree_block(trans, quota_root, quota_root->node, 0, 1);\r\nfree_extent_buffer(quota_root->node);\r\nfree_extent_buffer(quota_root->commit_root);\r\nkfree(quota_root);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nstatic void qgroup_dirty(struct btrfs_fs_info *fs_info,\r\nstruct btrfs_qgroup *qgroup)\r\n{\r\nif (list_empty(&qgroup->dirty))\r\nlist_add(&qgroup->dirty, &fs_info->dirty_qgroups);\r\n}\r\nint btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info, u64 src, u64 dst)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *parent;\r\nstruct btrfs_qgroup *member;\r\nstruct btrfs_qgroup_list *list;\r\nint ret = 0;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmember = find_qgroup_rb(fs_info, src);\r\nparent = find_qgroup_rb(fs_info, dst);\r\nif (!member || !parent) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(list, &member->groups, next_group) {\r\nif (list->group == parent) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\n}\r\nret = add_qgroup_relation_item(trans, quota_root, src, dst);\r\nif (ret)\r\ngoto out;\r\nret = add_qgroup_relation_item(trans, quota_root, dst, src);\r\nif (ret) {\r\ndel_qgroup_relation_item(trans, quota_root, src, dst);\r\ngoto out;\r\n}\r\nspin_lock(&fs_info->qgroup_lock);\r\nret = add_relation_rb(quota_root->fs_info, src, dst);\r\nspin_unlock(&fs_info->qgroup_lock);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info, u64 src, u64 dst)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *parent;\r\nstruct btrfs_qgroup *member;\r\nstruct btrfs_qgroup_list *list;\r\nint ret = 0;\r\nint err;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmember = find_qgroup_rb(fs_info, src);\r\nparent = find_qgroup_rb(fs_info, dst);\r\nif (!member || !parent) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlist_for_each_entry(list, &member->groups, next_group) {\r\nif (list->group == parent)\r\ngoto exist;\r\n}\r\nret = -ENOENT;\r\ngoto out;\r\nexist:\r\nret = del_qgroup_relation_item(trans, quota_root, src, dst);\r\nerr = del_qgroup_relation_item(trans, quota_root, dst, src);\r\nif (err && !ret)\r\nret = err;\r\nspin_lock(&fs_info->qgroup_lock);\r\ndel_relation_rb(fs_info, src, dst);\r\nspin_unlock(&fs_info->qgroup_lock);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_create_qgroup(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info, u64 qgroupid, char *name)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *qgroup;\r\nint ret = 0;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nqgroup = find_qgroup_rb(fs_info, qgroupid);\r\nif (qgroup) {\r\nret = -EEXIST;\r\ngoto out;\r\n}\r\nret = add_qgroup_item(trans, quota_root, qgroupid);\r\nif (ret)\r\ngoto out;\r\nspin_lock(&fs_info->qgroup_lock);\r\nqgroup = add_qgroup_rb(fs_info, qgroupid);\r\nspin_unlock(&fs_info->qgroup_lock);\r\nif (IS_ERR(qgroup))\r\nret = PTR_ERR(qgroup);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_remove_qgroup(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info, u64 qgroupid)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *qgroup;\r\nint ret = 0;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nqgroup = find_qgroup_rb(fs_info, qgroupid);\r\nif (!qgroup) {\r\nret = -ENOENT;\r\ngoto out;\r\n} else {\r\nif (!list_empty(&qgroup->groups) ||\r\n!list_empty(&qgroup->members)) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\n}\r\nret = del_qgroup_item(trans, quota_root, qgroupid);\r\nspin_lock(&fs_info->qgroup_lock);\r\ndel_qgroup_rb(quota_root->fs_info, qgroupid);\r\nspin_unlock(&fs_info->qgroup_lock);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_limit_qgroup(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info, u64 qgroupid,\r\nstruct btrfs_qgroup_limit *limit)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *qgroup;\r\nint ret = 0;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nqgroup = find_qgroup_rb(fs_info, qgroupid);\r\nif (!qgroup) {\r\nret = -ENOENT;\r\ngoto out;\r\n}\r\nret = update_qgroup_limit_item(trans, quota_root, qgroupid,\r\nlimit->flags, limit->max_rfer,\r\nlimit->max_excl, limit->rsv_rfer,\r\nlimit->rsv_excl);\r\nif (ret) {\r\nfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\nprintk(KERN_INFO "unable to update quota limit for %llu\n",\r\nqgroupid);\r\n}\r\nspin_lock(&fs_info->qgroup_lock);\r\nqgroup->lim_flags = limit->flags;\r\nqgroup->max_rfer = limit->max_rfer;\r\nqgroup->max_excl = limit->max_excl;\r\nqgroup->rsv_rfer = limit->rsv_rfer;\r\nqgroup->rsv_excl = limit->rsv_excl;\r\nspin_unlock(&fs_info->qgroup_lock);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_qgroup_record_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_delayed_ref_node *node,\r\nstruct btrfs_delayed_extent_op *extent_op)\r\n{\r\nstruct qgroup_update *u;\r\nBUG_ON(!trans->delayed_ref_elem.seq);\r\nu = kmalloc(sizeof(*u), GFP_NOFS);\r\nif (!u)\r\nreturn -ENOMEM;\r\nu->node = node;\r\nu->extent_op = extent_op;\r\nlist_add_tail(&u->list, &trans->qgroup_ref_list);\r\nreturn 0;\r\n}\r\nstatic int qgroup_account_ref_step1(struct btrfs_fs_info *fs_info,\r\nstruct ulist *roots, struct ulist *tmp,\r\nu64 seq)\r\n{\r\nstruct ulist_node *unode;\r\nstruct ulist_iterator uiter;\r\nstruct ulist_node *tmp_unode;\r\nstruct ulist_iterator tmp_uiter;\r\nstruct btrfs_qgroup *qg;\r\nint ret;\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(roots, &uiter))) {\r\nqg = find_qgroup_rb(fs_info, unode->val);\r\nif (!qg)\r\ncontinue;\r\nulist_reinit(tmp);\r\nret = ulist_add(tmp, qg->qgroupid,\r\n(u64)(uintptr_t)qg, GFP_ATOMIC);\r\nif (ret < 0)\r\nreturn ret;\r\nULIST_ITER_INIT(&tmp_uiter);\r\nwhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\r\nstruct btrfs_qgroup_list *glist;\r\nqg = (struct btrfs_qgroup *)(uintptr_t)tmp_unode->aux;\r\nif (qg->refcnt < seq)\r\nqg->refcnt = seq + 1;\r\nelse\r\n++qg->refcnt;\r\nlist_for_each_entry(glist, &qg->groups, next_group) {\r\nret = ulist_add(tmp, glist->group->qgroupid,\r\n(u64)(uintptr_t)glist->group,\r\nGFP_ATOMIC);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qgroup_account_ref_step2(struct btrfs_fs_info *fs_info,\r\nstruct ulist *roots, struct ulist *tmp,\r\nu64 seq, int sgn, u64 num_bytes,\r\nstruct btrfs_qgroup *qgroup)\r\n{\r\nstruct ulist_node *unode;\r\nstruct ulist_iterator uiter;\r\nstruct btrfs_qgroup *qg;\r\nstruct btrfs_qgroup_list *glist;\r\nint ret;\r\nulist_reinit(tmp);\r\nret = ulist_add(tmp, qgroup->qgroupid, (uintptr_t)qgroup, GFP_ATOMIC);\r\nif (ret < 0)\r\nreturn ret;\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(tmp, &uiter))) {\r\nqg = (struct btrfs_qgroup *)(uintptr_t)unode->aux;\r\nif (qg->refcnt < seq) {\r\nqg->rfer += sgn * num_bytes;\r\nqg->rfer_cmpr += sgn * num_bytes;\r\nif (roots->nnodes == 0) {\r\nqg->excl += sgn * num_bytes;\r\nqg->excl_cmpr += sgn * num_bytes;\r\n}\r\nqgroup_dirty(fs_info, qg);\r\n}\r\nWARN_ON(qg->tag >= seq);\r\nqg->tag = seq;\r\nlist_for_each_entry(glist, &qg->groups, next_group) {\r\nret = ulist_add(tmp, glist->group->qgroupid,\r\n(uintptr_t)glist->group, GFP_ATOMIC);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int qgroup_account_ref_step3(struct btrfs_fs_info *fs_info,\r\nstruct ulist *roots, struct ulist *tmp,\r\nu64 seq, int sgn, u64 num_bytes)\r\n{\r\nstruct ulist_node *unode;\r\nstruct ulist_iterator uiter;\r\nstruct btrfs_qgroup *qg;\r\nstruct ulist_node *tmp_unode;\r\nstruct ulist_iterator tmp_uiter;\r\nint ret;\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(roots, &uiter))) {\r\nqg = find_qgroup_rb(fs_info, unode->val);\r\nif (!qg)\r\ncontinue;\r\nulist_reinit(tmp);\r\nret = ulist_add(tmp, qg->qgroupid, (uintptr_t)qg, GFP_ATOMIC);\r\nif (ret < 0)\r\nreturn ret;\r\nULIST_ITER_INIT(&tmp_uiter);\r\nwhile ((tmp_unode = ulist_next(tmp, &tmp_uiter))) {\r\nstruct btrfs_qgroup_list *glist;\r\nqg = (struct btrfs_qgroup *)(uintptr_t)tmp_unode->aux;\r\nif (qg->tag == seq)\r\ncontinue;\r\nif (qg->refcnt - seq == roots->nnodes) {\r\nqg->excl -= sgn * num_bytes;\r\nqg->excl_cmpr -= sgn * num_bytes;\r\nqgroup_dirty(fs_info, qg);\r\n}\r\nlist_for_each_entry(glist, &qg->groups, next_group) {\r\nret = ulist_add(tmp, glist->group->qgroupid,\r\n(uintptr_t)glist->group,\r\nGFP_ATOMIC);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint btrfs_qgroup_account_ref(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info,\r\nstruct btrfs_delayed_ref_node *node,\r\nstruct btrfs_delayed_extent_op *extent_op)\r\n{\r\nstruct btrfs_key ins;\r\nstruct btrfs_root *quota_root;\r\nu64 ref_root;\r\nstruct btrfs_qgroup *qgroup;\r\nstruct ulist *roots = NULL;\r\nu64 seq;\r\nint ret = 0;\r\nint sgn;\r\nif (!fs_info->quota_enabled)\r\nreturn 0;\r\nBUG_ON(!fs_info->quota_root);\r\nins.objectid = node->bytenr;\r\nins.offset = node->num_bytes;\r\nins.type = BTRFS_EXTENT_ITEM_KEY;\r\nif (node->type == BTRFS_TREE_BLOCK_REF_KEY ||\r\nnode->type == BTRFS_SHARED_BLOCK_REF_KEY) {\r\nstruct btrfs_delayed_tree_ref *ref;\r\nref = btrfs_delayed_node_to_tree_ref(node);\r\nref_root = ref->root;\r\n} else if (node->type == BTRFS_EXTENT_DATA_REF_KEY ||\r\nnode->type == BTRFS_SHARED_DATA_REF_KEY) {\r\nstruct btrfs_delayed_data_ref *ref;\r\nref = btrfs_delayed_node_to_data_ref(node);\r\nref_root = ref->root;\r\n} else {\r\nBUG();\r\n}\r\nif (!is_fstree(ref_root)) {\r\nreturn 0;\r\n}\r\nswitch (node->action) {\r\ncase BTRFS_ADD_DELAYED_REF:\r\ncase BTRFS_ADD_DELAYED_EXTENT:\r\nsgn = 1;\r\nseq = btrfs_tree_mod_seq_prev(node->seq);\r\nbreak;\r\ncase BTRFS_DROP_DELAYED_REF:\r\nsgn = -1;\r\nseq = node->seq;\r\nbreak;\r\ncase BTRFS_UPDATE_DELAYED_HEAD:\r\nreturn 0;\r\ndefault:\r\nBUG();\r\n}\r\nmutex_lock(&fs_info->qgroup_rescan_lock);\r\nif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) {\r\nif (fs_info->qgroup_rescan_progress.objectid <= node->bytenr) {\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\nreturn 0;\r\n}\r\n}\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\nret = btrfs_find_all_roots(trans, fs_info, node->bytenr, seq, &roots);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock(&fs_info->qgroup_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root)\r\ngoto unlock;\r\nqgroup = find_qgroup_rb(fs_info, ref_root);\r\nif (!qgroup)\r\ngoto unlock;\r\nulist_reinit(fs_info->qgroup_ulist);\r\nseq = fs_info->qgroup_seq;\r\nfs_info->qgroup_seq += roots->nnodes + 1;\r\nret = qgroup_account_ref_step1(fs_info, roots, fs_info->qgroup_ulist,\r\nseq);\r\nif (ret)\r\ngoto unlock;\r\nret = qgroup_account_ref_step2(fs_info, roots, fs_info->qgroup_ulist,\r\nseq, sgn, node->num_bytes, qgroup);\r\nif (ret)\r\ngoto unlock;\r\nret = qgroup_account_ref_step3(fs_info, roots, fs_info->qgroup_ulist,\r\nseq, sgn, node->num_bytes);\r\nif (ret)\r\ngoto unlock;\r\nunlock:\r\nspin_unlock(&fs_info->qgroup_lock);\r\nulist_free(roots);\r\nreturn ret;\r\n}\r\nint btrfs_run_qgroups(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info)\r\n{\r\nstruct btrfs_root *quota_root = fs_info->quota_root;\r\nint ret = 0;\r\nint start_rescan_worker = 0;\r\nif (!quota_root)\r\ngoto out;\r\nif (!fs_info->quota_enabled && fs_info->pending_quota_state)\r\nstart_rescan_worker = 1;\r\nfs_info->quota_enabled = fs_info->pending_quota_state;\r\nspin_lock(&fs_info->qgroup_lock);\r\nwhile (!list_empty(&fs_info->dirty_qgroups)) {\r\nstruct btrfs_qgroup *qgroup;\r\nqgroup = list_first_entry(&fs_info->dirty_qgroups,\r\nstruct btrfs_qgroup, dirty);\r\nlist_del_init(&qgroup->dirty);\r\nspin_unlock(&fs_info->qgroup_lock);\r\nret = update_qgroup_info_item(trans, quota_root, qgroup);\r\nif (ret)\r\nfs_info->qgroup_flags |=\r\nBTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\nspin_lock(&fs_info->qgroup_lock);\r\n}\r\nif (fs_info->quota_enabled)\r\nfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_ON;\r\nelse\r\nfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_ON;\r\nspin_unlock(&fs_info->qgroup_lock);\r\nret = update_qgroup_status_item(trans, fs_info, quota_root);\r\nif (ret)\r\nfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\nif (!ret && start_rescan_worker) {\r\nret = qgroup_rescan_init(fs_info, 0, 1);\r\nif (!ret) {\r\nqgroup_rescan_zero_tracking(fs_info);\r\nbtrfs_queue_worker(&fs_info->qgroup_rescan_workers,\r\n&fs_info->qgroup_rescan_work);\r\n}\r\nret = 0;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nint btrfs_qgroup_inherit(struct btrfs_trans_handle *trans,\r\nstruct btrfs_fs_info *fs_info, u64 srcid, u64 objectid,\r\nstruct btrfs_qgroup_inherit *inherit)\r\n{\r\nint ret = 0;\r\nint i;\r\nu64 *i_qgroups;\r\nstruct btrfs_root *quota_root = fs_info->quota_root;\r\nstruct btrfs_qgroup *srcgroup;\r\nstruct btrfs_qgroup *dstgroup;\r\nu32 level_size = 0;\r\nu64 nums;\r\nmutex_lock(&fs_info->qgroup_ioctl_lock);\r\nif (!fs_info->quota_enabled)\r\ngoto out;\r\nif (!quota_root) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (inherit) {\r\ni_qgroups = (u64 *)(inherit + 1);\r\nnums = inherit->num_qgroups + 2 * inherit->num_ref_copies +\r\n2 * inherit->num_excl_copies;\r\nfor (i = 0; i < nums; ++i) {\r\nsrcgroup = find_qgroup_rb(fs_info, *i_qgroups);\r\nif (!srcgroup) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n++i_qgroups;\r\n}\r\n}\r\nret = add_qgroup_item(trans, quota_root, objectid);\r\nif (ret)\r\ngoto out;\r\nif (inherit && inherit->flags & BTRFS_QGROUP_INHERIT_SET_LIMITS) {\r\nret = update_qgroup_limit_item(trans, quota_root, objectid,\r\ninherit->lim.flags,\r\ninherit->lim.max_rfer,\r\ninherit->lim.max_excl,\r\ninherit->lim.rsv_rfer,\r\ninherit->lim.rsv_excl);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (srcid) {\r\nstruct btrfs_root *srcroot;\r\nstruct btrfs_key srckey;\r\nint srcroot_level;\r\nsrckey.objectid = srcid;\r\nsrckey.type = BTRFS_ROOT_ITEM_KEY;\r\nsrckey.offset = (u64)-1;\r\nsrcroot = btrfs_read_fs_root_no_name(fs_info, &srckey);\r\nif (IS_ERR(srcroot)) {\r\nret = PTR_ERR(srcroot);\r\ngoto out;\r\n}\r\nrcu_read_lock();\r\nsrcroot_level = btrfs_header_level(srcroot->node);\r\nlevel_size = btrfs_level_size(srcroot, srcroot_level);\r\nrcu_read_unlock();\r\n}\r\nif (inherit) {\r\ni_qgroups = (u64 *)(inherit + 1);\r\nfor (i = 0; i < inherit->num_qgroups; ++i) {\r\nret = add_qgroup_relation_item(trans, quota_root,\r\nobjectid, *i_qgroups);\r\nif (ret)\r\ngoto out;\r\nret = add_qgroup_relation_item(trans, quota_root,\r\n*i_qgroups, objectid);\r\nif (ret)\r\ngoto out;\r\n++i_qgroups;\r\n}\r\n}\r\nspin_lock(&fs_info->qgroup_lock);\r\ndstgroup = add_qgroup_rb(fs_info, objectid);\r\nif (IS_ERR(dstgroup)) {\r\nret = PTR_ERR(dstgroup);\r\ngoto unlock;\r\n}\r\nif (srcid) {\r\nsrcgroup = find_qgroup_rb(fs_info, srcid);\r\nif (!srcgroup)\r\ngoto unlock;\r\ndstgroup->rfer = srcgroup->rfer - level_size;\r\ndstgroup->rfer_cmpr = srcgroup->rfer_cmpr - level_size;\r\nsrcgroup->excl = level_size;\r\nsrcgroup->excl_cmpr = level_size;\r\nqgroup_dirty(fs_info, dstgroup);\r\nqgroup_dirty(fs_info, srcgroup);\r\n}\r\nif (!inherit)\r\ngoto unlock;\r\ni_qgroups = (u64 *)(inherit + 1);\r\nfor (i = 0; i < inherit->num_qgroups; ++i) {\r\nret = add_relation_rb(quota_root->fs_info, objectid,\r\n*i_qgroups);\r\nif (ret)\r\ngoto unlock;\r\n++i_qgroups;\r\n}\r\nfor (i = 0; i < inherit->num_ref_copies; ++i) {\r\nstruct btrfs_qgroup *src;\r\nstruct btrfs_qgroup *dst;\r\nsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\r\ndst = find_qgroup_rb(fs_info, i_qgroups[1]);\r\nif (!src || !dst) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ndst->rfer = src->rfer - level_size;\r\ndst->rfer_cmpr = src->rfer_cmpr - level_size;\r\ni_qgroups += 2;\r\n}\r\nfor (i = 0; i < inherit->num_excl_copies; ++i) {\r\nstruct btrfs_qgroup *src;\r\nstruct btrfs_qgroup *dst;\r\nsrc = find_qgroup_rb(fs_info, i_qgroups[0]);\r\ndst = find_qgroup_rb(fs_info, i_qgroups[1]);\r\nif (!src || !dst) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ndst->excl = src->excl + level_size;\r\ndst->excl_cmpr = src->excl_cmpr + level_size;\r\ni_qgroups += 2;\r\n}\r\nunlock:\r\nspin_unlock(&fs_info->qgroup_lock);\r\nout:\r\nmutex_unlock(&fs_info->qgroup_ioctl_lock);\r\nreturn ret;\r\n}\r\nint btrfs_qgroup_reserve(struct btrfs_root *root, u64 num_bytes)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *qgroup;\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nu64 ref_root = root->root_key.objectid;\r\nint ret = 0;\r\nstruct ulist_node *unode;\r\nstruct ulist_iterator uiter;\r\nif (!is_fstree(ref_root))\r\nreturn 0;\r\nif (num_bytes == 0)\r\nreturn 0;\r\nspin_lock(&fs_info->qgroup_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root)\r\ngoto out;\r\nqgroup = find_qgroup_rb(fs_info, ref_root);\r\nif (!qgroup)\r\ngoto out;\r\nulist_reinit(fs_info->qgroup_ulist);\r\nret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\r\n(uintptr_t)qgroup, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\r\nstruct btrfs_qgroup *qg;\r\nstruct btrfs_qgroup_list *glist;\r\nqg = (struct btrfs_qgroup *)(uintptr_t)unode->aux;\r\nif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_RFER) &&\r\nqg->reserved + (s64)qg->rfer + num_bytes >\r\nqg->max_rfer) {\r\nret = -EDQUOT;\r\ngoto out;\r\n}\r\nif ((qg->lim_flags & BTRFS_QGROUP_LIMIT_MAX_EXCL) &&\r\nqg->reserved + (s64)qg->excl + num_bytes >\r\nqg->max_excl) {\r\nret = -EDQUOT;\r\ngoto out;\r\n}\r\nlist_for_each_entry(glist, &qg->groups, next_group) {\r\nret = ulist_add(fs_info->qgroup_ulist,\r\nglist->group->qgroupid,\r\n(uintptr_t)glist->group, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n}\r\nret = 0;\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\r\nstruct btrfs_qgroup *qg;\r\nqg = (struct btrfs_qgroup *)(uintptr_t)unode->aux;\r\nqg->reserved += num_bytes;\r\n}\r\nout:\r\nspin_unlock(&fs_info->qgroup_lock);\r\nreturn ret;\r\n}\r\nvoid btrfs_qgroup_free(struct btrfs_root *root, u64 num_bytes)\r\n{\r\nstruct btrfs_root *quota_root;\r\nstruct btrfs_qgroup *qgroup;\r\nstruct btrfs_fs_info *fs_info = root->fs_info;\r\nstruct ulist_node *unode;\r\nstruct ulist_iterator uiter;\r\nu64 ref_root = root->root_key.objectid;\r\nint ret = 0;\r\nif (!is_fstree(ref_root))\r\nreturn;\r\nif (num_bytes == 0)\r\nreturn;\r\nspin_lock(&fs_info->qgroup_lock);\r\nquota_root = fs_info->quota_root;\r\nif (!quota_root)\r\ngoto out;\r\nqgroup = find_qgroup_rb(fs_info, ref_root);\r\nif (!qgroup)\r\ngoto out;\r\nulist_reinit(fs_info->qgroup_ulist);\r\nret = ulist_add(fs_info->qgroup_ulist, qgroup->qgroupid,\r\n(uintptr_t)qgroup, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(fs_info->qgroup_ulist, &uiter))) {\r\nstruct btrfs_qgroup *qg;\r\nstruct btrfs_qgroup_list *glist;\r\nqg = (struct btrfs_qgroup *)(uintptr_t)unode->aux;\r\nqg->reserved -= num_bytes;\r\nlist_for_each_entry(glist, &qg->groups, next_group) {\r\nret = ulist_add(fs_info->qgroup_ulist,\r\nglist->group->qgroupid,\r\n(uintptr_t)glist->group, GFP_ATOMIC);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nspin_unlock(&fs_info->qgroup_lock);\r\n}\r\nvoid assert_qgroups_uptodate(struct btrfs_trans_handle *trans)\r\n{\r\nif (list_empty(&trans->qgroup_ref_list) && !trans->delayed_ref_elem.seq)\r\nreturn;\r\npr_err("btrfs: qgroups not uptodate in trans handle %p: list is%s empty, seq is %#x.%x\n",\r\ntrans, list_empty(&trans->qgroup_ref_list) ? "" : " not",\r\n(u32)(trans->delayed_ref_elem.seq >> 32),\r\n(u32)trans->delayed_ref_elem.seq);\r\nBUG();\r\n}\r\nstatic int\r\nqgroup_rescan_leaf(struct btrfs_fs_info *fs_info, struct btrfs_path *path,\r\nstruct btrfs_trans_handle *trans, struct ulist *tmp,\r\nstruct extent_buffer *scratch_leaf)\r\n{\r\nstruct btrfs_key found;\r\nstruct ulist *roots = NULL;\r\nstruct ulist_node *unode;\r\nstruct ulist_iterator uiter;\r\nstruct seq_list tree_mod_seq_elem = {};\r\nu64 seq;\r\nint slot;\r\nint ret;\r\npath->leave_spinning = 1;\r\nmutex_lock(&fs_info->qgroup_rescan_lock);\r\nret = btrfs_search_slot_for_read(fs_info->extent_root,\r\n&fs_info->qgroup_rescan_progress,\r\npath, 1, 0);\r\npr_debug("current progress key (%llu %u %llu), search_slot ret %d\n",\r\nfs_info->qgroup_rescan_progress.objectid,\r\nfs_info->qgroup_rescan_progress.type,\r\nfs_info->qgroup_rescan_progress.offset, ret);\r\nif (ret) {\r\nfs_info->qgroup_rescan_progress.objectid = (u64)-1;\r\nbtrfs_release_path(path);\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\nreturn ret;\r\n}\r\nbtrfs_item_key_to_cpu(path->nodes[0], &found,\r\nbtrfs_header_nritems(path->nodes[0]) - 1);\r\nfs_info->qgroup_rescan_progress.objectid = found.objectid + 1;\r\nbtrfs_get_tree_mod_seq(fs_info, &tree_mod_seq_elem);\r\nmemcpy(scratch_leaf, path->nodes[0], sizeof(*scratch_leaf));\r\nslot = path->slots[0];\r\nbtrfs_release_path(path);\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\nfor (; slot < btrfs_header_nritems(scratch_leaf); ++slot) {\r\nbtrfs_item_key_to_cpu(scratch_leaf, &found, slot);\r\nif (found.type != BTRFS_EXTENT_ITEM_KEY)\r\ncontinue;\r\nret = btrfs_find_all_roots(trans, fs_info, found.objectid,\r\ntree_mod_seq_elem.seq, &roots);\r\nif (ret < 0)\r\ngoto out;\r\nspin_lock(&fs_info->qgroup_lock);\r\nseq = fs_info->qgroup_seq;\r\nfs_info->qgroup_seq += roots->nnodes + 1;\r\nret = qgroup_account_ref_step1(fs_info, roots, tmp, seq);\r\nif (ret) {\r\nspin_unlock(&fs_info->qgroup_lock);\r\nulist_free(roots);\r\ngoto out;\r\n}\r\nulist_reinit(tmp);\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(roots, &uiter))) {\r\nstruct btrfs_qgroup *qg;\r\nqg = find_qgroup_rb(fs_info, unode->val);\r\nif (!qg)\r\ncontinue;\r\nret = ulist_add(tmp, qg->qgroupid, (uintptr_t)qg,\r\nGFP_ATOMIC);\r\nif (ret < 0) {\r\nspin_unlock(&fs_info->qgroup_lock);\r\nulist_free(roots);\r\ngoto out;\r\n}\r\n}\r\nULIST_ITER_INIT(&uiter);\r\nwhile ((unode = ulist_next(tmp, &uiter))) {\r\nstruct btrfs_qgroup *qg;\r\nstruct btrfs_qgroup_list *glist;\r\nqg = (struct btrfs_qgroup *)(uintptr_t) unode->aux;\r\nqg->rfer += found.offset;\r\nqg->rfer_cmpr += found.offset;\r\nWARN_ON(qg->tag >= seq);\r\nif (qg->refcnt - seq == roots->nnodes) {\r\nqg->excl += found.offset;\r\nqg->excl_cmpr += found.offset;\r\n}\r\nqgroup_dirty(fs_info, qg);\r\nlist_for_each_entry(glist, &qg->groups, next_group) {\r\nret = ulist_add(tmp, glist->group->qgroupid,\r\n(uintptr_t)glist->group,\r\nGFP_ATOMIC);\r\nif (ret < 0) {\r\nspin_unlock(&fs_info->qgroup_lock);\r\nulist_free(roots);\r\ngoto out;\r\n}\r\n}\r\n}\r\nspin_unlock(&fs_info->qgroup_lock);\r\nulist_free(roots);\r\nret = 0;\r\n}\r\nout:\r\nbtrfs_put_tree_mod_seq(fs_info, &tree_mod_seq_elem);\r\nreturn ret;\r\n}\r\nstatic void btrfs_qgroup_rescan_worker(struct btrfs_work *work)\r\n{\r\nstruct btrfs_fs_info *fs_info = container_of(work, struct btrfs_fs_info,\r\nqgroup_rescan_work);\r\nstruct btrfs_path *path;\r\nstruct btrfs_trans_handle *trans = NULL;\r\nstruct ulist *tmp = NULL;\r\nstruct extent_buffer *scratch_leaf = NULL;\r\nint err = -ENOMEM;\r\npath = btrfs_alloc_path();\r\nif (!path)\r\ngoto out;\r\ntmp = ulist_alloc(GFP_NOFS);\r\nif (!tmp)\r\ngoto out;\r\nscratch_leaf = kmalloc(sizeof(*scratch_leaf), GFP_NOFS);\r\nif (!scratch_leaf)\r\ngoto out;\r\nerr = 0;\r\nwhile (!err) {\r\ntrans = btrfs_start_transaction(fs_info->fs_root, 0);\r\nif (IS_ERR(trans)) {\r\nerr = PTR_ERR(trans);\r\nbreak;\r\n}\r\nif (!fs_info->quota_enabled) {\r\nerr = -EINTR;\r\n} else {\r\nerr = qgroup_rescan_leaf(fs_info, path, trans,\r\ntmp, scratch_leaf);\r\n}\r\nif (err > 0)\r\nbtrfs_commit_transaction(trans, fs_info->fs_root);\r\nelse\r\nbtrfs_end_transaction(trans, fs_info->fs_root);\r\n}\r\nout:\r\nkfree(scratch_leaf);\r\nulist_free(tmp);\r\nbtrfs_free_path(path);\r\nmutex_lock(&fs_info->qgroup_rescan_lock);\r\nfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\r\nif (err == 2 &&\r\nfs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT) {\r\nfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\n} else if (err < 0) {\r\nfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT;\r\n}\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\nif (err >= 0) {\r\npr_info("btrfs: qgroup scan completed%s\n",\r\nerr == 2 ? " (inconsistency flag cleared)" : "");\r\n} else {\r\npr_err("btrfs: qgroup scan failed with %d\n", err);\r\n}\r\ncomplete_all(&fs_info->qgroup_rescan_completion);\r\n}\r\nstatic int\r\nqgroup_rescan_init(struct btrfs_fs_info *fs_info, u64 progress_objectid,\r\nint init_flags)\r\n{\r\nint ret = 0;\r\nif (!init_flags &&\r\n(!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN) ||\r\n!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nmutex_lock(&fs_info->qgroup_rescan_lock);\r\nspin_lock(&fs_info->qgroup_lock);\r\nif (init_flags) {\r\nif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\r\nret = -EINPROGRESS;\r\nelse if (!(fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_ON))\r\nret = -EINVAL;\r\nif (ret) {\r\nspin_unlock(&fs_info->qgroup_lock);\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\ngoto err;\r\n}\r\nfs_info->qgroup_flags |= BTRFS_QGROUP_STATUS_FLAG_RESCAN;\r\n}\r\nmemset(&fs_info->qgroup_rescan_progress, 0,\r\nsizeof(fs_info->qgroup_rescan_progress));\r\nfs_info->qgroup_rescan_progress.objectid = progress_objectid;\r\nspin_unlock(&fs_info->qgroup_lock);\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\ninit_completion(&fs_info->qgroup_rescan_completion);\r\nmemset(&fs_info->qgroup_rescan_work, 0,\r\nsizeof(fs_info->qgroup_rescan_work));\r\nfs_info->qgroup_rescan_work.func = btrfs_qgroup_rescan_worker;\r\nif (ret) {\r\nerr:\r\npr_info("btrfs: qgroup_rescan_init failed with %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nqgroup_rescan_zero_tracking(struct btrfs_fs_info *fs_info)\r\n{\r\nstruct rb_node *n;\r\nstruct btrfs_qgroup *qgroup;\r\nspin_lock(&fs_info->qgroup_lock);\r\nfor (n = rb_first(&fs_info->qgroup_tree); n; n = rb_next(n)) {\r\nqgroup = rb_entry(n, struct btrfs_qgroup, node);\r\nqgroup->rfer = 0;\r\nqgroup->rfer_cmpr = 0;\r\nqgroup->excl = 0;\r\nqgroup->excl_cmpr = 0;\r\n}\r\nspin_unlock(&fs_info->qgroup_lock);\r\n}\r\nint\r\nbtrfs_qgroup_rescan(struct btrfs_fs_info *fs_info)\r\n{\r\nint ret = 0;\r\nstruct btrfs_trans_handle *trans;\r\nret = qgroup_rescan_init(fs_info, 0, 1);\r\nif (ret)\r\nreturn ret;\r\ntrans = btrfs_join_transaction(fs_info->fs_root);\r\nif (IS_ERR(trans)) {\r\nfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\r\nreturn PTR_ERR(trans);\r\n}\r\nret = btrfs_commit_transaction(trans, fs_info->fs_root);\r\nif (ret) {\r\nfs_info->qgroup_flags &= ~BTRFS_QGROUP_STATUS_FLAG_RESCAN;\r\nreturn ret;\r\n}\r\nqgroup_rescan_zero_tracking(fs_info);\r\nbtrfs_queue_worker(&fs_info->qgroup_rescan_workers,\r\n&fs_info->qgroup_rescan_work);\r\nreturn 0;\r\n}\r\nint btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)\r\n{\r\nint running;\r\nint ret = 0;\r\nmutex_lock(&fs_info->qgroup_rescan_lock);\r\nspin_lock(&fs_info->qgroup_lock);\r\nrunning = fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN;\r\nspin_unlock(&fs_info->qgroup_lock);\r\nmutex_unlock(&fs_info->qgroup_rescan_lock);\r\nif (running)\r\nret = wait_for_completion_interruptible(\r\n&fs_info->qgroup_rescan_completion);\r\nreturn ret;\r\n}\r\nvoid\r\nbtrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info)\r\n{\r\nif (fs_info->qgroup_flags & BTRFS_QGROUP_STATUS_FLAG_RESCAN)\r\nbtrfs_queue_worker(&fs_info->qgroup_rescan_workers,\r\n&fs_info->qgroup_rescan_work);\r\n}
