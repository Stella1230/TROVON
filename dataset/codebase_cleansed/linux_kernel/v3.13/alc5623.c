static void alc5623_fill_cache(struct snd_soc_codec *codec)\r\n{\r\nint i, step = codec->driver->reg_cache_step;\r\nu16 *cache = codec->reg_cache;\r\ncodec->cache_bypass = 1;\r\nfor (i = 0 ; i < codec->driver->reg_cache_size ; i += step)\r\ncache[i] = snd_soc_read(codec, i);\r\ncodec->cache_bypass = 0;\r\n}\r\nstatic inline int alc5623_reset(struct snd_soc_codec *codec)\r\n{\r\nreturn snd_soc_write(codec, ALC5623_RESET, 0);\r\n}\r\nstatic int amp_mixer_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nsnd_soc_write(w->codec, ALC5623_HID_CTRL_INDEX, 0x46);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_write(w->codec, ALC5623_HID_CTRL_DATA, 0xFFFF);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_write(w->codec, ALC5623_HID_CTRL_DATA, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alc5623_set_dai_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nint i;\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint gbl_clk = 0, pll_div = 0;\r\nu16 reg;\r\nif (pll_id < ALC5623_PLL_FR_MCLK || pll_id > ALC5623_PLL_FR_BCK)\r\nreturn -ENODEV;\r\nsnd_soc_update_bits(codec, ALC5623_PWR_MANAG_ADD2,\r\nALC5623_PWR_ADD2_PLL,\r\n0);\r\nreg = snd_soc_read(codec, ALC5623_DAI_CONTROL);\r\nif (reg & ALC5623_DAI_SDP_SLAVE_MODE)\r\nreturn 0;\r\nif (!freq_in || !freq_out)\r\nreturn 0;\r\nswitch (pll_id) {\r\ncase ALC5623_PLL_FR_MCLK:\r\nfor (i = 0; i < ARRAY_SIZE(codec_master_pll_div); i++) {\r\nif (codec_master_pll_div[i].pll_in == freq_in\r\n&& codec_master_pll_div[i].pll_out == freq_out) {\r\npll_div = codec_master_pll_div[i].regvalue;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase ALC5623_PLL_FR_BCK:\r\nfor (i = 0; i < ARRAY_SIZE(codec_slave_pll_div); i++) {\r\nif (codec_slave_pll_div[i].pll_in == freq_in\r\n&& codec_slave_pll_div[i].pll_out == freq_out) {\r\ngbl_clk = ALC5623_GBL_CLK_PLL_SOUR_SEL_BITCLK;\r\npll_div = codec_slave_pll_div[i].regvalue;\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (!pll_div)\r\nreturn -EINVAL;\r\nsnd_soc_write(codec, ALC5623_GLOBAL_CLK_CTRL_REG, gbl_clk);\r\nsnd_soc_write(codec, ALC5623_PLL_CTRL, pll_div);\r\nsnd_soc_update_bits(codec, ALC5623_PWR_MANAG_ADD2,\r\nALC5623_PWR_ADD2_PLL,\r\nALC5623_PWR_ADD2_PLL);\r\ngbl_clk |= ALC5623_GBL_CLK_SYS_SOUR_SEL_PLL;\r\nsnd_soc_write(codec, ALC5623_GLOBAL_CLK_CTRL_REG, gbl_clk);\r\nreturn 0;\r\n}\r\nstatic int get_coeff(struct snd_soc_codec *codec, int rate)\r\n{\r\nstruct alc5623_priv *alc5623 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(coeff_div); i++) {\r\nif (coeff_div[i].fs * rate == alc5623->sysclk)\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int alc5623_set_dai_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct alc5623_priv *alc5623 = snd_soc_codec_get_drvdata(codec);\r\nswitch (freq) {\r\ncase 8192000:\r\ncase 11289600:\r\ncase 12288000:\r\ncase 16384000:\r\ncase 16934400:\r\ncase 18432000:\r\ncase 22579200:\r\ncase 24576000:\r\nalc5623->sysclk = freq;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int alc5623_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nu16 iface = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\niface = ALC5623_DAI_SDP_MASTER_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\niface = ALC5623_DAI_SDP_SLAVE_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\niface |= ALC5623_DAI_I2S_DF_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\niface |= ALC5623_DAI_I2S_DF_RIGHT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\niface |= ALC5623_DAI_I2S_DF_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\niface |= ALC5623_DAI_I2S_DF_PCM;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\niface |= ALC5623_DAI_I2S_DF_PCM | ALC5623_DAI_I2S_PCM_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\niface |= ALC5623_DAI_MAIN_I2S_BCLK_POL_CTRL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\niface |= ALC5623_DAI_MAIN_I2S_BCLK_POL_CTRL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_write(codec, ALC5623_DAI_CONTROL, iface);\r\n}\r\nstatic int alc5623_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct alc5623_priv *alc5623 = snd_soc_codec_get_drvdata(codec);\r\nint coeff, rate;\r\nu16 iface;\r\niface = snd_soc_read(codec, ALC5623_DAI_CONTROL);\r\niface &= ~ALC5623_DAI_I2S_DL_MASK;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\niface |= ALC5623_DAI_I2S_DL_16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S20_3LE:\r\niface |= ALC5623_DAI_I2S_DL_20;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\niface |= ALC5623_DAI_I2S_DL_24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\niface |= ALC5623_DAI_I2S_DL_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, ALC5623_DAI_CONTROL, iface);\r\nrate = params_rate(params);\r\ncoeff = get_coeff(codec, rate);\r\nif (coeff < 0)\r\nreturn -EINVAL;\r\ncoeff = coeff_div[coeff].regvalue;\r\ndev_dbg(codec->dev, "%s: sysclk=%d,rate=%d,coeff=0x%04x\n",\r\n__func__, alc5623->sysclk, rate, coeff);\r\nsnd_soc_write(codec, ALC5623_STEREO_AD_DA_CLK_CTRL, coeff);\r\nreturn 0;\r\n}\r\nstatic int alc5623_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu16 hp_mute = ALC5623_MISC_M_DAC_L_INPUT | ALC5623_MISC_M_DAC_R_INPUT;\r\nu16 mute_reg = snd_soc_read(codec, ALC5623_MISC_CTRL) & ~hp_mute;\r\nif (mute)\r\nmute_reg |= hp_mute;\r\nreturn snd_soc_write(codec, ALC5623_MISC_CTRL, mute_reg);\r\n}\r\nstatic void enable_power_depop(struct snd_soc_codec *codec)\r\n{\r\nstruct alc5623_priv *alc5623 = snd_soc_codec_get_drvdata(codec);\r\nsnd_soc_update_bits(codec, ALC5623_PWR_MANAG_ADD1,\r\nALC5623_PWR_ADD1_SOFTGEN_EN,\r\nALC5623_PWR_ADD1_SOFTGEN_EN);\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD3, ALC5623_ADD3_POWER_EN);\r\nsnd_soc_update_bits(codec, ALC5623_MISC_CTRL,\r\nALC5623_MISC_HP_DEPOP_MODE2_EN,\r\nALC5623_MISC_HP_DEPOP_MODE2_EN);\r\nmsleep(500);\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD2, ALC5623_ADD2_POWER_EN);\r\nif (alc5623->id == 0x22)\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD1,\r\nALC5623_ADD1_POWER_EN_5622);\r\nelse\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD1,\r\nALC5623_ADD1_POWER_EN);\r\nsnd_soc_update_bits(codec, ALC5623_MISC_CTRL,\r\nALC5623_MISC_HP_DEPOP_MODE2_EN,\r\n0);\r\n}\r\nstatic int alc5623_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nenable_power_depop(codec);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD2,\r\nALC5623_PWR_ADD2_VREF);\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD3,\r\nALC5623_PWR_ADD3_MAIN_BIAS);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD2, 0);\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD3, 0);\r\nsnd_soc_write(codec, ALC5623_PWR_MANAG_ADD1, 0);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int alc5623_suspend(struct snd_soc_codec *codec)\r\n{\r\nalc5623_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int alc5623_resume(struct snd_soc_codec *codec)\r\n{\r\nint i, step = codec->driver->reg_cache_step;\r\nu16 *cache = codec->reg_cache;\r\nfor (i = 2 ; i < codec->driver->reg_cache_size ; i += step)\r\nsnd_soc_write(codec, i, cache[i]);\r\nalc5623_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (codec->dapm.suspend_bias_level == SND_SOC_BIAS_ON) {\r\nalc5623_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\ncodec->dapm.bias_level = SND_SOC_BIAS_ON;\r\nalc5623_set_bias_level(codec, codec->dapm.bias_level);\r\n}\r\nreturn 0;\r\n}\r\nstatic int alc5623_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct alc5623_priv *alc5623 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint ret;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 16, alc5623->control_type);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nalc5623_reset(codec);\r\nalc5623_fill_cache(codec);\r\nalc5623_set_bias_level(codec, SND_SOC_BIAS_STANDBY);\r\nif (alc5623->add_ctrl) {\r\nsnd_soc_write(codec, ALC5623_ADD_CTRL_REG,\r\nalc5623->add_ctrl);\r\n}\r\nif (alc5623->jack_det_ctrl) {\r\nsnd_soc_write(codec, ALC5623_JACK_DET_CTRL,\r\nalc5623->jack_det_ctrl);\r\n}\r\nswitch (alc5623->id) {\r\ncase 0x21:\r\nsnd_soc_add_codec_controls(codec, alc5621_vol_snd_controls,\r\nARRAY_SIZE(alc5621_vol_snd_controls));\r\nbreak;\r\ncase 0x22:\r\nsnd_soc_add_codec_controls(codec, alc5622_vol_snd_controls,\r\nARRAY_SIZE(alc5622_vol_snd_controls));\r\nbreak;\r\ncase 0x23:\r\nsnd_soc_add_codec_controls(codec, alc5623_vol_snd_controls,\r\nARRAY_SIZE(alc5623_vol_snd_controls));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_add_codec_controls(codec, alc5623_snd_controls,\r\nARRAY_SIZE(alc5623_snd_controls));\r\nsnd_soc_dapm_new_controls(dapm, alc5623_dapm_widgets,\r\nARRAY_SIZE(alc5623_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));\r\nswitch (alc5623->id) {\r\ncase 0x21:\r\ncase 0x22:\r\nsnd_soc_dapm_new_controls(dapm, alc5623_dapm_amp_widgets,\r\nARRAY_SIZE(alc5623_dapm_amp_widgets));\r\nsnd_soc_dapm_add_routes(dapm, intercon_amp_spk,\r\nARRAY_SIZE(intercon_amp_spk));\r\nbreak;\r\ncase 0x23:\r\nsnd_soc_dapm_add_routes(dapm, intercon_spk,\r\nARRAY_SIZE(intercon_spk));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int alc5623_remove(struct snd_soc_codec *codec)\r\n{\r\nalc5623_set_bias_level(codec, SND_SOC_BIAS_OFF);\r\nreturn 0;\r\n}\r\nstatic int alc5623_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct alc5623_platform_data *pdata;\r\nstruct alc5623_priv *alc5623;\r\nint ret, vid1, vid2;\r\nvid1 = i2c_smbus_read_word_data(client, ALC5623_VENDOR_ID1);\r\nif (vid1 < 0) {\r\ndev_err(&client->dev, "failed to read I2C\n");\r\nreturn -EIO;\r\n}\r\nvid1 = ((vid1 & 0xff) << 8) | (vid1 >> 8);\r\nvid2 = i2c_smbus_read_byte_data(client, ALC5623_VENDOR_ID2);\r\nif (vid2 < 0) {\r\ndev_err(&client->dev, "failed to read I2C\n");\r\nreturn -EIO;\r\n}\r\nif ((vid1 != 0x10ec) || (vid2 != id->driver_data)) {\r\ndev_err(&client->dev, "unknown or wrong codec\n");\r\ndev_err(&client->dev, "Expected %x:%lx, got %x:%x\n",\r\n0x10ec, id->driver_data,\r\nvid1, vid2);\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(&client->dev, "Found codec id : alc56%02x\n", vid2);\r\nalc5623 = devm_kzalloc(&client->dev, sizeof(struct alc5623_priv),\r\nGFP_KERNEL);\r\nif (alc5623 == NULL)\r\nreturn -ENOMEM;\r\npdata = client->dev.platform_data;\r\nif (pdata) {\r\nalc5623->add_ctrl = pdata->add_ctrl;\r\nalc5623->jack_det_ctrl = pdata->jack_det_ctrl;\r\n}\r\nalc5623->id = vid2;\r\nswitch (alc5623->id) {\r\ncase 0x21:\r\nalc5623_dai.name = "alc5621-hifi";\r\nbreak;\r\ncase 0x22:\r\nalc5623_dai.name = "alc5622-hifi";\r\nbreak;\r\ncase 0x23:\r\nalc5623_dai.name = "alc5623-hifi";\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni2c_set_clientdata(client, alc5623);\r\nalc5623->control_type = SND_SOC_I2C;\r\nret = snd_soc_register_codec(&client->dev,\r\n&soc_codec_device_alc5623, &alc5623_dai, 1);\r\nif (ret != 0)\r\ndev_err(&client->dev, "Failed to register codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int alc5623_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
