static inline int kbd_defleds(void)\r\n{\r\nreturn 0;\r\n}\r\nint register_keyboard_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_register(&keyboard_notifier_list, nb);\r\n}\r\nint unregister_keyboard_notifier(struct notifier_block *nb)\r\n{\r\nreturn atomic_notifier_chain_unregister(&keyboard_notifier_list, nb);\r\n}\r\nstatic int getkeycode_helper(struct input_handle *handle, void *data)\r\n{\r\nstruct getset_keycode_data *d = data;\r\nd->error = input_get_keycode(handle->dev, &d->ke);\r\nreturn d->error == 0;\r\n}\r\nstatic int getkeycode(unsigned int scancode)\r\n{\r\nstruct getset_keycode_data d = {\r\n.ke = {\r\n.flags = 0,\r\n.len = sizeof(scancode),\r\n.keycode = 0,\r\n},\r\n.error = -ENODEV,\r\n};\r\nmemcpy(d.ke.scancode, &scancode, sizeof(scancode));\r\ninput_handler_for_each_handle(&kbd_handler, &d, getkeycode_helper);\r\nreturn d.error ?: d.ke.keycode;\r\n}\r\nstatic int setkeycode_helper(struct input_handle *handle, void *data)\r\n{\r\nstruct getset_keycode_data *d = data;\r\nd->error = input_set_keycode(handle->dev, &d->ke);\r\nreturn d->error == 0;\r\n}\r\nstatic int setkeycode(unsigned int scancode, unsigned int keycode)\r\n{\r\nstruct getset_keycode_data d = {\r\n.ke = {\r\n.flags = 0,\r\n.len = sizeof(scancode),\r\n.keycode = keycode,\r\n},\r\n.error = -ENODEV,\r\n};\r\nmemcpy(d.ke.scancode, &scancode, sizeof(scancode));\r\ninput_handler_for_each_handle(&kbd_handler, &d, setkeycode_helper);\r\nreturn d.error;\r\n}\r\nstatic int kd_sound_helper(struct input_handle *handle, void *data)\r\n{\r\nunsigned int *hz = data;\r\nstruct input_dev *dev = handle->dev;\r\nif (test_bit(EV_SND, dev->evbit)) {\r\nif (test_bit(SND_TONE, dev->sndbit)) {\r\ninput_inject_event(handle, EV_SND, SND_TONE, *hz);\r\nif (*hz)\r\nreturn 0;\r\n}\r\nif (test_bit(SND_BELL, dev->sndbit))\r\ninput_inject_event(handle, EV_SND, SND_BELL, *hz ? 1 : 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void kd_nosound(unsigned long ignored)\r\n{\r\nstatic unsigned int zero;\r\ninput_handler_for_each_handle(&kbd_handler, &zero, kd_sound_helper);\r\n}\r\nvoid kd_mksound(unsigned int hz, unsigned int ticks)\r\n{\r\ndel_timer_sync(&kd_mksound_timer);\r\ninput_handler_for_each_handle(&kbd_handler, &hz, kd_sound_helper);\r\nif (hz && ticks)\r\nmod_timer(&kd_mksound_timer, jiffies + ticks);\r\n}\r\nstatic int kbd_rate_helper(struct input_handle *handle, void *data)\r\n{\r\nstruct input_dev *dev = handle->dev;\r\nstruct kbd_repeat *rep = data;\r\nif (test_bit(EV_REP, dev->evbit)) {\r\nif (rep[0].delay > 0)\r\ninput_inject_event(handle,\r\nEV_REP, REP_DELAY, rep[0].delay);\r\nif (rep[0].period > 0)\r\ninput_inject_event(handle,\r\nEV_REP, REP_PERIOD, rep[0].period);\r\nrep[1].delay = dev->rep[REP_DELAY];\r\nrep[1].period = dev->rep[REP_PERIOD];\r\n}\r\nreturn 0;\r\n}\r\nint kbd_rate(struct kbd_repeat *rep)\r\n{\r\nstruct kbd_repeat data[2] = { *rep };\r\ninput_handler_for_each_handle(&kbd_handler, data, kbd_rate_helper);\r\n*rep = data[1];\r\nreturn 0;\r\n}\r\nstatic void put_queue(struct vc_data *vc, int ch)\r\n{\r\ntty_insert_flip_char(&vc->port, ch, 0);\r\ntty_schedule_flip(&vc->port);\r\n}\r\nstatic void puts_queue(struct vc_data *vc, char *cp)\r\n{\r\nwhile (*cp) {\r\ntty_insert_flip_char(&vc->port, *cp, 0);\r\ncp++;\r\n}\r\ntty_schedule_flip(&vc->port);\r\n}\r\nstatic void applkey(struct vc_data *vc, int key, char mode)\r\n{\r\nstatic char buf[] = { 0x1b, 'O', 0x00, 0x00 };\r\nbuf[1] = (mode ? 'O' : '[');\r\nbuf[2] = key;\r\nputs_queue(vc, buf);\r\n}\r\nstatic void to_utf8(struct vc_data *vc, uint c)\r\n{\r\nif (c < 0x80)\r\nput_queue(vc, c);\r\nelse if (c < 0x800) {\r\nput_queue(vc, 0xc0 | (c >> 6));\r\nput_queue(vc, 0x80 | (c & 0x3f));\r\n} else if (c < 0x10000) {\r\nif (c >= 0xD800 && c < 0xE000)\r\nreturn;\r\nif (c == 0xFFFF)\r\nreturn;\r\nput_queue(vc, 0xe0 | (c >> 12));\r\nput_queue(vc, 0x80 | ((c >> 6) & 0x3f));\r\nput_queue(vc, 0x80 | (c & 0x3f));\r\n} else if (c < 0x110000) {\r\nput_queue(vc, 0xf0 | (c >> 18));\r\nput_queue(vc, 0x80 | ((c >> 12) & 0x3f));\r\nput_queue(vc, 0x80 | ((c >> 6) & 0x3f));\r\nput_queue(vc, 0x80 | (c & 0x3f));\r\n}\r\n}\r\nstatic void do_compute_shiftstate(void)\r\n{\r\nunsigned int i, j, k, sym, val;\r\nshift_state = 0;\r\nmemset(shift_down, 0, sizeof(shift_down));\r\nfor (i = 0; i < ARRAY_SIZE(key_down); i++) {\r\nif (!key_down[i])\r\ncontinue;\r\nk = i * BITS_PER_LONG;\r\nfor (j = 0; j < BITS_PER_LONG; j++, k++) {\r\nif (!test_bit(k, key_down))\r\ncontinue;\r\nsym = U(key_maps[0][k]);\r\nif (KTYP(sym) != KT_SHIFT && KTYP(sym) != KT_SLOCK)\r\ncontinue;\r\nval = KVAL(sym);\r\nif (val == KVAL(K_CAPSSHIFT))\r\nval = KVAL(K_SHIFT);\r\nshift_down[val]++;\r\nshift_state |= (1 << val);\r\n}\r\n}\r\n}\r\nvoid compute_shiftstate(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\ndo_compute_shiftstate();\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\n}\r\nstatic unsigned int handle_diacr(struct vc_data *vc, unsigned int ch)\r\n{\r\nunsigned int d = diacr;\r\nunsigned int i;\r\ndiacr = 0;\r\nif ((d & ~0xff) == BRL_UC_ROW) {\r\nif ((ch & ~0xff) == BRL_UC_ROW)\r\nreturn d | ch;\r\n} else {\r\nfor (i = 0; i < accent_table_size; i++)\r\nif (accent_table[i].diacr == d && accent_table[i].base == ch)\r\nreturn accent_table[i].result;\r\n}\r\nif (ch == ' ' || ch == (BRL_UC_ROW|0) || ch == d)\r\nreturn d;\r\nif (kbd->kbdmode == VC_UNICODE)\r\nto_utf8(vc, d);\r\nelse {\r\nint c = conv_uni_to_8bit(d);\r\nif (c != -1)\r\nput_queue(vc, c);\r\n}\r\nreturn ch;\r\n}\r\nstatic void fn_enter(struct vc_data *vc)\r\n{\r\nif (diacr) {\r\nif (kbd->kbdmode == VC_UNICODE)\r\nto_utf8(vc, diacr);\r\nelse {\r\nint c = conv_uni_to_8bit(diacr);\r\nif (c != -1)\r\nput_queue(vc, c);\r\n}\r\ndiacr = 0;\r\n}\r\nput_queue(vc, 13);\r\nif (vc_kbd_mode(kbd, VC_CRLF))\r\nput_queue(vc, 10);\r\n}\r\nstatic void fn_caps_toggle(struct vc_data *vc)\r\n{\r\nif (rep)\r\nreturn;\r\nchg_vc_kbd_led(kbd, VC_CAPSLOCK);\r\n}\r\nstatic void fn_caps_on(struct vc_data *vc)\r\n{\r\nif (rep)\r\nreturn;\r\nset_vc_kbd_led(kbd, VC_CAPSLOCK);\r\n}\r\nstatic void fn_show_ptregs(struct vc_data *vc)\r\n{\r\nstruct pt_regs *regs = get_irq_regs();\r\nif (regs)\r\nshow_regs(regs);\r\n}\r\nstatic void fn_hold(struct vc_data *vc)\r\n{\r\nstruct tty_struct *tty = vc->port.tty;\r\nif (rep || !tty)\r\nreturn;\r\nif (tty->stopped)\r\nstart_tty(tty);\r\nelse\r\nstop_tty(tty);\r\n}\r\nstatic void fn_num(struct vc_data *vc)\r\n{\r\nif (vc_kbd_mode(kbd, VC_APPLIC))\r\napplkey(vc, 'P', 1);\r\nelse\r\nfn_bare_num(vc);\r\n}\r\nstatic void fn_bare_num(struct vc_data *vc)\r\n{\r\nif (!rep)\r\nchg_vc_kbd_led(kbd, VC_NUMLOCK);\r\n}\r\nstatic void fn_lastcons(struct vc_data *vc)\r\n{\r\nset_console(last_console);\r\n}\r\nstatic void fn_dec_console(struct vc_data *vc)\r\n{\r\nint i, cur = fg_console;\r\nif (want_console != -1)\r\ncur = want_console;\r\nfor (i = cur - 1; i != cur; i--) {\r\nif (i == -1)\r\ni = MAX_NR_CONSOLES - 1;\r\nif (vc_cons_allocated(i))\r\nbreak;\r\n}\r\nset_console(i);\r\n}\r\nstatic void fn_inc_console(struct vc_data *vc)\r\n{\r\nint i, cur = fg_console;\r\nif (want_console != -1)\r\ncur = want_console;\r\nfor (i = cur+1; i != cur; i++) {\r\nif (i == MAX_NR_CONSOLES)\r\ni = 0;\r\nif (vc_cons_allocated(i))\r\nbreak;\r\n}\r\nset_console(i);\r\n}\r\nstatic void fn_send_intr(struct vc_data *vc)\r\n{\r\ntty_insert_flip_char(&vc->port, 0, TTY_BREAK);\r\ntty_schedule_flip(&vc->port);\r\n}\r\nstatic void fn_scroll_forw(struct vc_data *vc)\r\n{\r\nscrollfront(vc, 0);\r\n}\r\nstatic void fn_scroll_back(struct vc_data *vc)\r\n{\r\nscrollback(vc, 0);\r\n}\r\nstatic void fn_show_mem(struct vc_data *vc)\r\n{\r\nshow_mem(0);\r\n}\r\nstatic void fn_show_state(struct vc_data *vc)\r\n{\r\nshow_state();\r\n}\r\nstatic void fn_boot_it(struct vc_data *vc)\r\n{\r\nctrl_alt_del();\r\n}\r\nstatic void fn_compose(struct vc_data *vc)\r\n{\r\ndead_key_next = true;\r\n}\r\nstatic void fn_spawn_con(struct vc_data *vc)\r\n{\r\nspin_lock(&vt_spawn_con.lock);\r\nif (vt_spawn_con.pid)\r\nif (kill_pid(vt_spawn_con.pid, vt_spawn_con.sig, 1)) {\r\nput_pid(vt_spawn_con.pid);\r\nvt_spawn_con.pid = NULL;\r\n}\r\nspin_unlock(&vt_spawn_con.lock);\r\n}\r\nstatic void fn_SAK(struct vc_data *vc)\r\n{\r\nstruct work_struct *SAK_work = &vc_cons[fg_console].SAK_work;\r\nschedule_work(SAK_work);\r\n}\r\nstatic void fn_null(struct vc_data *vc)\r\n{\r\ndo_compute_shiftstate();\r\n}\r\nstatic void k_ignore(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\n}\r\nstatic void k_spec(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nif (up_flag)\r\nreturn;\r\nif (value >= ARRAY_SIZE(fn_handler))\r\nreturn;\r\nif ((kbd->kbdmode == VC_RAW ||\r\nkbd->kbdmode == VC_MEDIUMRAW ||\r\nkbd->kbdmode == VC_OFF) &&\r\nvalue != KVAL(K_SAK))\r\nreturn;\r\nfn_handler[value](vc);\r\n}\r\nstatic void k_lowercase(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\npr_err("k_lowercase was called - impossible\n");\r\n}\r\nstatic void k_unicode(struct vc_data *vc, unsigned int value, char up_flag)\r\n{\r\nif (up_flag)\r\nreturn;\r\nif (diacr)\r\nvalue = handle_diacr(vc, value);\r\nif (dead_key_next) {\r\ndead_key_next = false;\r\ndiacr = value;\r\nreturn;\r\n}\r\nif (kbd->kbdmode == VC_UNICODE)\r\nto_utf8(vc, value);\r\nelse {\r\nint c = conv_uni_to_8bit(value);\r\nif (c != -1)\r\nput_queue(vc, c);\r\n}\r\n}\r\nstatic void k_deadunicode(struct vc_data *vc, unsigned int value, char up_flag)\r\n{\r\nif (up_flag)\r\nreturn;\r\ndiacr = (diacr ? handle_diacr(vc, value) : value);\r\n}\r\nstatic void k_self(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nk_unicode(vc, conv_8bit_to_uni(value), up_flag);\r\n}\r\nstatic void k_dead2(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nk_deadunicode(vc, value, up_flag);\r\n}\r\nstatic void k_dead(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nstatic const unsigned char ret_diacr[NR_DEAD] = {'`', '\'', '^', '~', '"', ',' };\r\nk_deadunicode(vc, ret_diacr[value], up_flag);\r\n}\r\nstatic void k_cons(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nif (up_flag)\r\nreturn;\r\nset_console(value);\r\n}\r\nstatic void k_fn(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nif (up_flag)\r\nreturn;\r\nif ((unsigned)value < ARRAY_SIZE(func_table)) {\r\nif (func_table[value])\r\nputs_queue(vc, func_table[value]);\r\n} else\r\npr_err("k_fn called with value=%d\n", value);\r\n}\r\nstatic void k_cur(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nstatic const char cur_chars[] = "BDCA";\r\nif (up_flag)\r\nreturn;\r\napplkey(vc, cur_chars[value], vc_kbd_mode(kbd, VC_CKMODE));\r\n}\r\nstatic void k_pad(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nstatic const char pad_chars[] = "0123456789+-*/\015,.?()#";\r\nstatic const char app_map[] = "pqrstuvwxylSRQMnnmPQS";\r\nif (up_flag)\r\nreturn;\r\nif (vc_kbd_mode(kbd, VC_APPLIC) && !shift_down[KG_SHIFT]) {\r\napplkey(vc, app_map[value], 1);\r\nreturn;\r\n}\r\nif (!vc_kbd_led(kbd, VC_NUMLOCK)) {\r\nswitch (value) {\r\ncase KVAL(K_PCOMMA):\r\ncase KVAL(K_PDOT):\r\nk_fn(vc, KVAL(K_REMOVE), 0);\r\nreturn;\r\ncase KVAL(K_P0):\r\nk_fn(vc, KVAL(K_INSERT), 0);\r\nreturn;\r\ncase KVAL(K_P1):\r\nk_fn(vc, KVAL(K_SELECT), 0);\r\nreturn;\r\ncase KVAL(K_P2):\r\nk_cur(vc, KVAL(K_DOWN), 0);\r\nreturn;\r\ncase KVAL(K_P3):\r\nk_fn(vc, KVAL(K_PGDN), 0);\r\nreturn;\r\ncase KVAL(K_P4):\r\nk_cur(vc, KVAL(K_LEFT), 0);\r\nreturn;\r\ncase KVAL(K_P6):\r\nk_cur(vc, KVAL(K_RIGHT), 0);\r\nreturn;\r\ncase KVAL(K_P7):\r\nk_fn(vc, KVAL(K_FIND), 0);\r\nreturn;\r\ncase KVAL(K_P8):\r\nk_cur(vc, KVAL(K_UP), 0);\r\nreturn;\r\ncase KVAL(K_P9):\r\nk_fn(vc, KVAL(K_PGUP), 0);\r\nreturn;\r\ncase KVAL(K_P5):\r\napplkey(vc, 'G', vc_kbd_mode(kbd, VC_APPLIC));\r\nreturn;\r\n}\r\n}\r\nput_queue(vc, pad_chars[value]);\r\nif (value == KVAL(K_PENTER) && vc_kbd_mode(kbd, VC_CRLF))\r\nput_queue(vc, 10);\r\n}\r\nstatic void k_shift(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nint old_state = shift_state;\r\nif (rep)\r\nreturn;\r\nif (value == KVAL(K_CAPSSHIFT)) {\r\nvalue = KVAL(K_SHIFT);\r\nif (!up_flag)\r\nclr_vc_kbd_led(kbd, VC_CAPSLOCK);\r\n}\r\nif (up_flag) {\r\nif (shift_down[value])\r\nshift_down[value]--;\r\n} else\r\nshift_down[value]++;\r\nif (shift_down[value])\r\nshift_state |= (1 << value);\r\nelse\r\nshift_state &= ~(1 << value);\r\nif (up_flag && shift_state != old_state && npadch != -1) {\r\nif (kbd->kbdmode == VC_UNICODE)\r\nto_utf8(vc, npadch);\r\nelse\r\nput_queue(vc, npadch & 0xff);\r\nnpadch = -1;\r\n}\r\n}\r\nstatic void k_meta(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nif (up_flag)\r\nreturn;\r\nif (vc_kbd_mode(kbd, VC_META)) {\r\nput_queue(vc, '\033');\r\nput_queue(vc, value);\r\n} else\r\nput_queue(vc, value | 0x80);\r\n}\r\nstatic void k_ascii(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nint base;\r\nif (up_flag)\r\nreturn;\r\nif (value < 10) {\r\nbase = 10;\r\n} else {\r\nvalue -= 10;\r\nbase = 16;\r\n}\r\nif (npadch == -1)\r\nnpadch = value;\r\nelse\r\nnpadch = npadch * base + value;\r\n}\r\nstatic void k_lock(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nif (up_flag || rep)\r\nreturn;\r\nchg_vc_kbd_lock(kbd, value);\r\n}\r\nstatic void k_slock(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nk_shift(vc, value, up_flag);\r\nif (up_flag || rep)\r\nreturn;\r\nchg_vc_kbd_slock(kbd, value);\r\nif (!key_maps[kbd->lockstate ^ kbd->slockstate]) {\r\nkbd->slockstate = 0;\r\nchg_vc_kbd_slock(kbd, value);\r\n}\r\n}\r\nstatic void k_brlcommit(struct vc_data *vc, unsigned int pattern, char up_flag)\r\n{\r\nstatic unsigned long chords;\r\nstatic unsigned committed;\r\nif (!brl_nbchords)\r\nk_deadunicode(vc, BRL_UC_ROW | pattern, up_flag);\r\nelse {\r\ncommitted |= pattern;\r\nchords++;\r\nif (chords == brl_nbchords) {\r\nk_unicode(vc, BRL_UC_ROW | committed, up_flag);\r\nchords = 0;\r\ncommitted = 0;\r\n}\r\n}\r\n}\r\nstatic void k_brl(struct vc_data *vc, unsigned char value, char up_flag)\r\n{\r\nstatic unsigned pressed, committing;\r\nstatic unsigned long releasestart;\r\nif (kbd->kbdmode != VC_UNICODE) {\r\nif (!up_flag)\r\npr_warning("keyboard mode must be unicode for braille patterns\n");\r\nreturn;\r\n}\r\nif (!value) {\r\nk_unicode(vc, BRL_UC_ROW, up_flag);\r\nreturn;\r\n}\r\nif (value > 8)\r\nreturn;\r\nif (!up_flag) {\r\npressed |= 1 << (value - 1);\r\nif (!brl_timeout)\r\ncommitting = pressed;\r\n} else if (brl_timeout) {\r\nif (!committing ||\r\ntime_after(jiffies,\r\nreleasestart + msecs_to_jiffies(brl_timeout))) {\r\ncommitting = pressed;\r\nreleasestart = jiffies;\r\n}\r\npressed &= ~(1 << (value - 1));\r\nif (!pressed && committing) {\r\nk_brlcommit(vc, committing, 0);\r\ncommitting = 0;\r\n}\r\n} else {\r\nif (committing) {\r\nk_brlcommit(vc, committing, 0);\r\ncommitting = 0;\r\n}\r\npressed &= ~(1 << (value - 1));\r\n}\r\n}\r\nstatic unsigned char getledstate(void)\r\n{\r\nreturn ledstate;\r\n}\r\nvoid setledstate(struct kbd_struct *kbd, unsigned int led)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_lock, flags);\r\nif (!(led & ~7)) {\r\nledioctl = led;\r\nkbd->ledmode = LED_SHOW_IOCTL;\r\n} else\r\nkbd->ledmode = LED_SHOW_FLAGS;\r\nset_leds();\r\nspin_unlock_irqrestore(&led_lock, flags);\r\n}\r\nstatic inline unsigned char getleds(void)\r\n{\r\nstruct kbd_struct *kbd = kbd_table + fg_console;\r\nif (kbd->ledmode == LED_SHOW_IOCTL)\r\nreturn ledioctl;\r\nreturn kbd->ledflagstate;\r\n}\r\nstatic int kbd_update_leds_helper(struct input_handle *handle, void *data)\r\n{\r\nunsigned char leds = *(unsigned char *)data;\r\nif (test_bit(EV_LED, handle->dev->evbit)) {\r\ninput_inject_event(handle, EV_LED, LED_SCROLLL, !!(leds & 0x01));\r\ninput_inject_event(handle, EV_LED, LED_NUML, !!(leds & 0x02));\r\ninput_inject_event(handle, EV_LED, LED_CAPSL, !!(leds & 0x04));\r\ninput_inject_event(handle, EV_SYN, SYN_REPORT, 0);\r\n}\r\nreturn 0;\r\n}\r\nint vt_get_leds(int console, int flag)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_lock, flags);\r\nret = vc_kbd_led(kbd, flag);\r\nspin_unlock_irqrestore(&led_lock, flags);\r\nreturn ret;\r\n}\r\nvoid vt_set_led_state(int console, int leds)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nsetledstate(kbd, leds);\r\n}\r\nvoid vt_kbd_con_start(int console)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_lock, flags);\r\nclr_vc_kbd_led(kbd, VC_SCROLLOCK);\r\nset_leds();\r\nspin_unlock_irqrestore(&led_lock, flags);\r\n}\r\nvoid vt_kbd_con_stop(int console)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_lock, flags);\r\nset_vc_kbd_led(kbd, VC_SCROLLOCK);\r\nset_leds();\r\nspin_unlock_irqrestore(&led_lock, flags);\r\n}\r\nstatic void kbd_bh(unsigned long dummy)\r\n{\r\nunsigned char leds;\r\nunsigned long flags;\r\nspin_lock_irqsave(&led_lock, flags);\r\nleds = getleds();\r\nspin_unlock_irqrestore(&led_lock, flags);\r\nif (leds != ledstate) {\r\ninput_handler_for_each_handle(&kbd_handler, &leds,\r\nkbd_update_leds_helper);\r\nledstate = leds;\r\n}\r\n}\r\nstatic int emulate_raw(struct vc_data *vc, unsigned int keycode,\r\nunsigned char up_flag)\r\n{\r\nint code;\r\nswitch (keycode) {\r\ncase KEY_PAUSE:\r\nput_queue(vc, 0xe1);\r\nput_queue(vc, 0x1d | up_flag);\r\nput_queue(vc, 0x45 | up_flag);\r\nbreak;\r\ncase KEY_HANGEUL:\r\nif (!up_flag)\r\nput_queue(vc, 0xf2);\r\nbreak;\r\ncase KEY_HANJA:\r\nif (!up_flag)\r\nput_queue(vc, 0xf1);\r\nbreak;\r\ncase KEY_SYSRQ:\r\nif (test_bit(KEY_LEFTALT, key_down) ||\r\ntest_bit(KEY_RIGHTALT, key_down)) {\r\nput_queue(vc, 0x54 | up_flag);\r\n} else {\r\nput_queue(vc, 0xe0);\r\nput_queue(vc, 0x2a | up_flag);\r\nput_queue(vc, 0xe0);\r\nput_queue(vc, 0x37 | up_flag);\r\n}\r\nbreak;\r\ndefault:\r\nif (keycode > 255)\r\nreturn -1;\r\ncode = x86_keycodes[keycode];\r\nif (!code)\r\nreturn -1;\r\nif (code & 0x100)\r\nput_queue(vc, 0xe0);\r\nput_queue(vc, (code & 0x7f) | up_flag);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int emulate_raw(struct vc_data *vc, unsigned int keycode, unsigned char up_flag)\r\n{\r\nif (keycode > 127)\r\nreturn -1;\r\nput_queue(vc, keycode | up_flag);\r\nreturn 0;\r\n}\r\nstatic void kbd_rawcode(unsigned char data)\r\n{\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nkbd = kbd_table + vc->vc_num;\r\nif (kbd->kbdmode == VC_RAW)\r\nput_queue(vc, data);\r\n}\r\nstatic void kbd_keycode(unsigned int keycode, int down, int hw_raw)\r\n{\r\nstruct vc_data *vc = vc_cons[fg_console].d;\r\nunsigned short keysym, *key_map;\r\nunsigned char type;\r\nbool raw_mode;\r\nstruct tty_struct *tty;\r\nint shift_final;\r\nstruct keyboard_notifier_param param = { .vc = vc, .value = keycode, .down = down };\r\nint rc;\r\ntty = vc->port.tty;\r\nif (tty && (!tty->driver_data)) {\r\ntty->driver_data = vc;\r\n}\r\nkbd = kbd_table + vc->vc_num;\r\n#ifdef CONFIG_SPARC\r\nif (keycode == KEY_STOP)\r\nsparc_l1_a_state = down;\r\n#endif\r\nrep = (down == 2);\r\nraw_mode = (kbd->kbdmode == VC_RAW);\r\nif (raw_mode && !hw_raw)\r\nif (emulate_raw(vc, keycode, !down << 7))\r\nif (keycode < BTN_MISC && printk_ratelimit())\r\npr_warning("can't emulate rawmode for keycode %d\n",\r\nkeycode);\r\n#ifdef CONFIG_SPARC\r\nif (keycode == KEY_A && sparc_l1_a_state) {\r\nsparc_l1_a_state = false;\r\nsun_do_break();\r\n}\r\n#endif\r\nif (kbd->kbdmode == VC_MEDIUMRAW) {\r\nif (keycode < 128) {\r\nput_queue(vc, keycode | (!down << 7));\r\n} else {\r\nput_queue(vc, !down << 7);\r\nput_queue(vc, (keycode >> 7) | 0x80);\r\nput_queue(vc, keycode | 0x80);\r\n}\r\nraw_mode = true;\r\n}\r\nif (down)\r\nset_bit(keycode, key_down);\r\nelse\r\nclear_bit(keycode, key_down);\r\nif (rep &&\r\n(!vc_kbd_mode(kbd, VC_REPEAT) ||\r\n(tty && !L_ECHO(tty) && tty_chars_in_buffer(tty)))) {\r\nreturn;\r\n}\r\nparam.shift = shift_final = (shift_state | kbd->slockstate) ^ kbd->lockstate;\r\nparam.ledstate = kbd->ledflagstate;\r\nkey_map = key_maps[shift_final];\r\nrc = atomic_notifier_call_chain(&keyboard_notifier_list,\r\nKBD_KEYCODE, &param);\r\nif (rc == NOTIFY_STOP || !key_map) {\r\natomic_notifier_call_chain(&keyboard_notifier_list,\r\nKBD_UNBOUND_KEYCODE, &param);\r\ndo_compute_shiftstate();\r\nkbd->slockstate = 0;\r\nreturn;\r\n}\r\nif (keycode < NR_KEYS)\r\nkeysym = key_map[keycode];\r\nelse if (keycode >= KEY_BRL_DOT1 && keycode <= KEY_BRL_DOT8)\r\nkeysym = U(K(KT_BRL, keycode - KEY_BRL_DOT1 + 1));\r\nelse\r\nreturn;\r\ntype = KTYP(keysym);\r\nif (type < 0xf0) {\r\nparam.value = keysym;\r\nrc = atomic_notifier_call_chain(&keyboard_notifier_list,\r\nKBD_UNICODE, &param);\r\nif (rc != NOTIFY_STOP)\r\nif (down && !raw_mode)\r\nto_utf8(vc, keysym);\r\nreturn;\r\n}\r\ntype -= 0xf0;\r\nif (type == KT_LETTER) {\r\ntype = KT_LATIN;\r\nif (vc_kbd_led(kbd, VC_CAPSLOCK)) {\r\nkey_map = key_maps[shift_final ^ (1 << KG_SHIFT)];\r\nif (key_map)\r\nkeysym = key_map[keycode];\r\n}\r\n}\r\nparam.value = keysym;\r\nrc = atomic_notifier_call_chain(&keyboard_notifier_list,\r\nKBD_KEYSYM, &param);\r\nif (rc == NOTIFY_STOP)\r\nreturn;\r\nif ((raw_mode || kbd->kbdmode == VC_OFF) && type != KT_SPEC && type != KT_SHIFT)\r\nreturn;\r\n(*k_handler[type])(vc, keysym & 0xff, !down);\r\nparam.ledstate = kbd->ledflagstate;\r\natomic_notifier_call_chain(&keyboard_notifier_list, KBD_POST_KEYSYM, &param);\r\nif (type != KT_SLOCK)\r\nkbd->slockstate = 0;\r\n}\r\nstatic void kbd_event(struct input_handle *handle, unsigned int event_type,\r\nunsigned int event_code, int value)\r\n{\r\nspin_lock(&kbd_event_lock);\r\nif (event_type == EV_MSC && event_code == MSC_RAW && HW_RAW(handle->dev))\r\nkbd_rawcode(value);\r\nif (event_type == EV_KEY)\r\nkbd_keycode(event_code, value, HW_RAW(handle->dev));\r\nspin_unlock(&kbd_event_lock);\r\ntasklet_schedule(&keyboard_tasklet);\r\ndo_poke_blanked_console = 1;\r\nschedule_console_callback();\r\n}\r\nstatic bool kbd_match(struct input_handler *handler, struct input_dev *dev)\r\n{\r\nint i;\r\nif (test_bit(EV_SND, dev->evbit))\r\nreturn true;\r\nif (test_bit(EV_KEY, dev->evbit)) {\r\nfor (i = KEY_RESERVED; i < BTN_MISC; i++)\r\nif (test_bit(i, dev->keybit))\r\nreturn true;\r\nfor (i = KEY_BRL_DOT1; i <= KEY_BRL_DOT10; i++)\r\nif (test_bit(i, dev->keybit))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int kbd_connect(struct input_handler *handler, struct input_dev *dev,\r\nconst struct input_device_id *id)\r\n{\r\nstruct input_handle *handle;\r\nint error;\r\nhandle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);\r\nif (!handle)\r\nreturn -ENOMEM;\r\nhandle->dev = dev;\r\nhandle->handler = handler;\r\nhandle->name = "kbd";\r\nerror = input_register_handle(handle);\r\nif (error)\r\ngoto err_free_handle;\r\nerror = input_open_device(handle);\r\nif (error)\r\ngoto err_unregister_handle;\r\nreturn 0;\r\nerr_unregister_handle:\r\ninput_unregister_handle(handle);\r\nerr_free_handle:\r\nkfree(handle);\r\nreturn error;\r\n}\r\nstatic void kbd_disconnect(struct input_handle *handle)\r\n{\r\ninput_close_device(handle);\r\ninput_unregister_handle(handle);\r\nkfree(handle);\r\n}\r\nstatic void kbd_start(struct input_handle *handle)\r\n{\r\ntasklet_disable(&keyboard_tasklet);\r\nif (ledstate != 0xff)\r\nkbd_update_leds_helper(handle, &ledstate);\r\ntasklet_enable(&keyboard_tasklet);\r\n}\r\nint __init kbd_init(void)\r\n{\r\nint i;\r\nint error;\r\nfor (i = 0; i < MAX_NR_CONSOLES; i++) {\r\nkbd_table[i].ledflagstate = kbd_defleds();\r\nkbd_table[i].default_ledflagstate = kbd_defleds();\r\nkbd_table[i].ledmode = LED_SHOW_FLAGS;\r\nkbd_table[i].lockstate = KBD_DEFLOCK;\r\nkbd_table[i].slockstate = 0;\r\nkbd_table[i].modeflags = KBD_DEFMODE;\r\nkbd_table[i].kbdmode = default_utf8 ? VC_UNICODE : VC_XLATE;\r\n}\r\nerror = input_register_handler(&kbd_handler);\r\nif (error)\r\nreturn error;\r\ntasklet_enable(&keyboard_tasklet);\r\ntasklet_schedule(&keyboard_tasklet);\r\nreturn 0;\r\n}\r\nint vt_do_diacrit(unsigned int cmd, void __user *up, int perm)\r\n{\r\nstruct kbdiacrs __user *a = up;\r\nunsigned long flags;\r\nint asize;\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase KDGKBDIACR:\r\n{\r\nstruct kbdiacr *diacr;\r\nint i;\r\ndiacr = kmalloc(MAX_DIACR * sizeof(struct kbdiacr),\r\nGFP_KERNEL);\r\nif (diacr == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nasize = accent_table_size;\r\nfor (i = 0; i < asize; i++) {\r\ndiacr[i].diacr = conv_uni_to_8bit(\r\naccent_table[i].diacr);\r\ndiacr[i].base = conv_uni_to_8bit(\r\naccent_table[i].base);\r\ndiacr[i].result = conv_uni_to_8bit(\r\naccent_table[i].result);\r\n}\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nif (put_user(asize, &a->kb_cnt))\r\nret = -EFAULT;\r\nelse if (copy_to_user(a->kbdiacr, diacr,\r\nasize * sizeof(struct kbdiacr)))\r\nret = -EFAULT;\r\nkfree(diacr);\r\nreturn ret;\r\n}\r\ncase KDGKBDIACRUC:\r\n{\r\nstruct kbdiacrsuc __user *a = up;\r\nvoid *buf;\r\nbuf = kmalloc(MAX_DIACR * sizeof(struct kbdiacruc),\r\nGFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nasize = accent_table_size;\r\nmemcpy(buf, accent_table, asize * sizeof(struct kbdiacruc));\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nif (put_user(asize, &a->kb_cnt))\r\nret = -EFAULT;\r\nelse if (copy_to_user(a->kbdiacruc, buf,\r\nasize*sizeof(struct kbdiacruc)))\r\nret = -EFAULT;\r\nkfree(buf);\r\nreturn ret;\r\n}\r\ncase KDSKBDIACR:\r\n{\r\nstruct kbdiacrs __user *a = up;\r\nstruct kbdiacr *diacr = NULL;\r\nunsigned int ct;\r\nint i;\r\nif (!perm)\r\nreturn -EPERM;\r\nif (get_user(ct, &a->kb_cnt))\r\nreturn -EFAULT;\r\nif (ct >= MAX_DIACR)\r\nreturn -EINVAL;\r\nif (ct) {\r\ndiacr = kmalloc(sizeof(struct kbdiacr) * ct,\r\nGFP_KERNEL);\r\nif (diacr == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(diacr, a->kbdiacr,\r\nsizeof(struct kbdiacr) * ct)) {\r\nkfree(diacr);\r\nreturn -EFAULT;\r\n}\r\n}\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\naccent_table_size = ct;\r\nfor (i = 0; i < ct; i++) {\r\naccent_table[i].diacr =\r\nconv_8bit_to_uni(diacr[i].diacr);\r\naccent_table[i].base =\r\nconv_8bit_to_uni(diacr[i].base);\r\naccent_table[i].result =\r\nconv_8bit_to_uni(diacr[i].result);\r\n}\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nkfree(diacr);\r\nreturn 0;\r\n}\r\ncase KDSKBDIACRUC:\r\n{\r\nstruct kbdiacrsuc __user *a = up;\r\nunsigned int ct;\r\nvoid *buf = NULL;\r\nif (!perm)\r\nreturn -EPERM;\r\nif (get_user(ct, &a->kb_cnt))\r\nreturn -EFAULT;\r\nif (ct >= MAX_DIACR)\r\nreturn -EINVAL;\r\nif (ct) {\r\nbuf = kmalloc(ct * sizeof(struct kbdiacruc),\r\nGFP_KERNEL);\r\nif (buf == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(buf, a->kbdiacruc,\r\nct * sizeof(struct kbdiacruc))) {\r\nkfree(buf);\r\nreturn -EFAULT;\r\n}\r\n}\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nif (ct)\r\nmemcpy(accent_table, buf,\r\nct * sizeof(struct kbdiacruc));\r\naccent_table_size = ct;\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nkfree(buf);\r\nreturn 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint vt_do_kdskbmode(int console, unsigned int arg)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nswitch(arg) {\r\ncase K_RAW:\r\nkbd->kbdmode = VC_RAW;\r\nbreak;\r\ncase K_MEDIUMRAW:\r\nkbd->kbdmode = VC_MEDIUMRAW;\r\nbreak;\r\ncase K_XLATE:\r\nkbd->kbdmode = VC_XLATE;\r\ndo_compute_shiftstate();\r\nbreak;\r\ncase K_UNICODE:\r\nkbd->kbdmode = VC_UNICODE;\r\ndo_compute_shiftstate();\r\nbreak;\r\ncase K_OFF:\r\nkbd->kbdmode = VC_OFF;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nreturn ret;\r\n}\r\nint vt_do_kdskbmeta(int console, unsigned int arg)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nint ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nswitch(arg) {\r\ncase K_METABIT:\r\nclr_vc_kbd_mode(kbd, VC_META);\r\nbreak;\r\ncase K_ESCPREFIX:\r\nset_vc_kbd_mode(kbd, VC_META);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nreturn ret;\r\n}\r\nint vt_do_kbkeycode_ioctl(int cmd, struct kbkeycode __user *user_kbkc,\r\nint perm)\r\n{\r\nstruct kbkeycode tmp;\r\nint kc = 0;\r\nif (copy_from_user(&tmp, user_kbkc, sizeof(struct kbkeycode)))\r\nreturn -EFAULT;\r\nswitch (cmd) {\r\ncase KDGETKEYCODE:\r\nkc = getkeycode(tmp.scancode);\r\nif (kc >= 0)\r\nkc = put_user(kc, &user_kbkc->keycode);\r\nbreak;\r\ncase KDSETKEYCODE:\r\nif (!perm)\r\nreturn -EPERM;\r\nkc = setkeycode(tmp.scancode, tmp.keycode);\r\nbreak;\r\n}\r\nreturn kc;\r\n}\r\nint vt_do_kdsk_ioctl(int cmd, struct kbentry __user *user_kbe, int perm,\r\nint console)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nstruct kbentry tmp;\r\nushort *key_map, *new_map, val, ov;\r\nunsigned long flags;\r\nif (copy_from_user(&tmp, user_kbe, sizeof(struct kbentry)))\r\nreturn -EFAULT;\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\nperm = 0;\r\nswitch (cmd) {\r\ncase KDGKBENT:\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nkey_map = key_maps[s];\r\nif (key_map) {\r\nval = U(key_map[i]);\r\nif (kbd->kbdmode != VC_UNICODE && KTYP(val) >= NR_TYPES)\r\nval = K_HOLE;\r\n} else\r\nval = (i ? K_HOLE : K_NOSUCHMAP);\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nreturn put_user(val, &user_kbe->kb_value);\r\ncase KDSKBENT:\r\nif (!perm)\r\nreturn -EPERM;\r\nif (!i && v == K_NOSUCHMAP) {\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nkey_map = key_maps[s];\r\nif (s && key_map) {\r\nkey_maps[s] = NULL;\r\nif (key_map[0] == U(K_ALLOCATED)) {\r\nkfree(key_map);\r\nkeymap_count--;\r\n}\r\n}\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nbreak;\r\n}\r\nif (KTYP(v) < NR_TYPES) {\r\nif (KVAL(v) > max_vals[KTYP(v)])\r\nreturn -EINVAL;\r\n} else\r\nif (kbd->kbdmode != VC_UNICODE)\r\nreturn -EINVAL;\r\n#if !defined(__mc68000__) && !defined(__powerpc__)\r\nif (!i)\r\nbreak;\r\n#endif\r\nnew_map = kmalloc(sizeof(plain_map), GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nkey_map = key_maps[s];\r\nif (key_map == NULL) {\r\nint j;\r\nif (keymap_count >= MAX_NR_OF_USER_KEYMAPS &&\r\n!capable(CAP_SYS_RESOURCE)) {\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nkfree(new_map);\r\nreturn -EPERM;\r\n}\r\nkey_maps[s] = new_map;\r\nkey_map = new_map;\r\nkey_map[0] = U(K_ALLOCATED);\r\nfor (j = 1; j < NR_KEYS; j++)\r\nkey_map[j] = U(K_HOLE);\r\nkeymap_count++;\r\n} else\r\nkfree(new_map);\r\nov = U(key_map[i]);\r\nif (v == ov)\r\ngoto out;\r\nif (((ov == K_SAK) || (v == K_SAK)) && !capable(CAP_SYS_ADMIN)) {\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nreturn -EPERM;\r\n}\r\nkey_map[i] = U(v);\r\nif (!s && (KTYP(ov) == KT_SHIFT || KTYP(v) == KT_SHIFT))\r\ndo_compute_shiftstate();\r\nout:\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint vt_do_kdgkb_ioctl(int cmd, struct kbsentry __user *user_kdgkb, int perm)\r\n{\r\nstruct kbsentry *kbs;\r\nchar *p;\r\nu_char *q;\r\nu_char __user *up;\r\nint sz;\r\nint delta;\r\nchar *first_free, *fj, *fnw;\r\nint i, j, k;\r\nint ret;\r\nif (!capable(CAP_SYS_TTY_CONFIG))\r\nperm = 0;\r\nkbs = kmalloc(sizeof(*kbs), GFP_KERNEL);\r\nif (!kbs) {\r\nret = -ENOMEM;\r\ngoto reterr;\r\n}\r\nif (copy_from_user(kbs, user_kdgkb, sizeof(struct kbsentry))) {\r\nret = -EFAULT;\r\ngoto reterr;\r\n}\r\nkbs->kb_string[sizeof(kbs->kb_string)-1] = '\0';\r\ni = kbs->kb_func;\r\nswitch (cmd) {\r\ncase KDGKBSENT:\r\nsz = sizeof(kbs->kb_string) - 1;\r\nup = user_kdgkb->kb_string;\r\np = func_table[i];\r\nif(p)\r\nfor ( ; *p && sz; p++, sz--)\r\nif (put_user(*p, up++)) {\r\nret = -EFAULT;\r\ngoto reterr;\r\n}\r\nif (put_user('\0', up)) {\r\nret = -EFAULT;\r\ngoto reterr;\r\n}\r\nkfree(kbs);\r\nreturn ((p && *p) ? -EOVERFLOW : 0);\r\ncase KDSKBSENT:\r\nif (!perm) {\r\nret = -EPERM;\r\ngoto reterr;\r\n}\r\nq = func_table[i];\r\nfirst_free = funcbufptr + (funcbufsize - funcbufleft);\r\nfor (j = i+1; j < MAX_NR_FUNC && !func_table[j]; j++)\r\n;\r\nif (j < MAX_NR_FUNC)\r\nfj = func_table[j];\r\nelse\r\nfj = first_free;\r\ndelta = (q ? -strlen(q) : 1) + strlen(kbs->kb_string);\r\nif (delta <= funcbufleft) {\r\nif (j < MAX_NR_FUNC) {\r\nmemmove(fj + delta, fj, first_free - fj);\r\nfor (k = j; k < MAX_NR_FUNC; k++)\r\nif (func_table[k])\r\nfunc_table[k] += delta;\r\n}\r\nif (!q)\r\nfunc_table[i] = fj;\r\nfuncbufleft -= delta;\r\n} else {\r\nsz = 256;\r\nwhile (sz < funcbufsize - funcbufleft + delta)\r\nsz <<= 1;\r\nfnw = kmalloc(sz, GFP_KERNEL);\r\nif(!fnw) {\r\nret = -ENOMEM;\r\ngoto reterr;\r\n}\r\nif (!q)\r\nfunc_table[i] = fj;\r\nif (fj > funcbufptr)\r\nmemmove(fnw, funcbufptr, fj - funcbufptr);\r\nfor (k = 0; k < j; k++)\r\nif (func_table[k])\r\nfunc_table[k] = fnw + (func_table[k] - funcbufptr);\r\nif (first_free > fj) {\r\nmemmove(fnw + (fj - funcbufptr) + delta, fj, first_free - fj);\r\nfor (k = j; k < MAX_NR_FUNC; k++)\r\nif (func_table[k])\r\nfunc_table[k] = fnw + (func_table[k] - funcbufptr) + delta;\r\n}\r\nif (funcbufptr != func_buf)\r\nkfree(funcbufptr);\r\nfuncbufptr = fnw;\r\nfuncbufleft = funcbufleft - delta + sz - funcbufsize;\r\nfuncbufsize = sz;\r\n}\r\nstrcpy(func_table[i], kbs->kb_string);\r\nbreak;\r\n}\r\nret = 0;\r\nreterr:\r\nkfree(kbs);\r\nreturn ret;\r\n}\r\nint vt_do_kdskled(int console, int cmd, unsigned long arg, int perm)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nunsigned long flags;\r\nunsigned char ucval;\r\nswitch(cmd) {\r\ncase KDGKBLED:\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nucval = kbd->ledflagstate | (kbd->default_ledflagstate << 4);\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\nreturn put_user(ucval, (char __user *)arg);\r\ncase KDSKBLED:\r\nif (!perm)\r\nreturn -EPERM;\r\nif (arg & ~0x77)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&led_lock, flags);\r\nkbd->ledflagstate = (arg & 7);\r\nkbd->default_ledflagstate = ((arg >> 4) & 7);\r\nset_leds();\r\nspin_unlock_irqrestore(&led_lock, flags);\r\nreturn 0;\r\ncase KDGETLED:\r\nucval = getledstate();\r\nreturn put_user(ucval, (char __user *)arg);\r\ncase KDSETLED:\r\nif (!perm)\r\nreturn -EPERM;\r\nsetledstate(kbd, arg);\r\nreturn 0;\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint vt_do_kdgkbmode(int console)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nswitch (kbd->kbdmode) {\r\ncase VC_RAW:\r\nreturn K_RAW;\r\ncase VC_MEDIUMRAW:\r\nreturn K_MEDIUMRAW;\r\ncase VC_UNICODE:\r\nreturn K_UNICODE;\r\ncase VC_OFF:\r\nreturn K_OFF;\r\ndefault:\r\nreturn K_XLATE;\r\n}\r\n}\r\nint vt_do_kdgkbmeta(int console)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nreturn vc_kbd_mode(kbd, VC_META) ? K_ESCPREFIX : K_METABIT;\r\n}\r\nvoid vt_reset_unicode(int console)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nkbd_table[console].kbdmode = default_utf8 ? VC_UNICODE : VC_XLATE;\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\n}\r\nint vt_get_shift_state(void)\r\n{\r\nreturn shift_state;\r\n}\r\nvoid vt_reset_keyboard(int console)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nset_vc_kbd_mode(kbd, VC_REPEAT);\r\nclr_vc_kbd_mode(kbd, VC_CKMODE);\r\nclr_vc_kbd_mode(kbd, VC_APPLIC);\r\nclr_vc_kbd_mode(kbd, VC_CRLF);\r\nkbd->lockstate = 0;\r\nkbd->slockstate = 0;\r\nspin_lock(&led_lock);\r\nkbd->ledmode = LED_SHOW_FLAGS;\r\nkbd->ledflagstate = kbd->default_ledflagstate;\r\nspin_unlock(&led_lock);\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\n}\r\nint vt_get_kbd_mode_bit(int console, int bit)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nreturn vc_kbd_mode(kbd, bit);\r\n}\r\nvoid vt_set_kbd_mode_bit(int console, int bit)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nset_vc_kbd_mode(kbd, bit);\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\n}\r\nvoid vt_clr_kbd_mode_bit(int console, int bit)\r\n{\r\nstruct kbd_struct * kbd = kbd_table + console;\r\nunsigned long flags;\r\nspin_lock_irqsave(&kbd_event_lock, flags);\r\nclr_vc_kbd_mode(kbd, bit);\r\nspin_unlock_irqrestore(&kbd_event_lock, flags);\r\n}
