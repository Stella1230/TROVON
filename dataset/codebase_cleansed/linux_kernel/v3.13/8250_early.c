unsigned int __weak __init serial8250_early_in(struct uart_port *port, int offset)\r\n{\r\nswitch (port->iotype) {\r\ncase UPIO_MEM:\r\nreturn readb(port->membase + offset);\r\ncase UPIO_MEM32:\r\nreturn readl(port->membase + (offset << 2));\r\ncase UPIO_PORT:\r\nreturn inb(port->iobase + offset);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid __weak __init serial8250_early_out(struct uart_port *port, int offset, int value)\r\n{\r\nswitch (port->iotype) {\r\ncase UPIO_MEM:\r\nwriteb(value, port->membase + offset);\r\nbreak;\r\ncase UPIO_MEM32:\r\nwritel(value, port->membase + (offset << 2));\r\nbreak;\r\ncase UPIO_PORT:\r\noutb(value, port->iobase + offset);\r\nbreak;\r\n}\r\n}\r\nstatic void __init wait_for_xmitr(struct uart_port *port)\r\n{\r\nunsigned int status;\r\nfor (;;) {\r\nstatus = serial8250_early_in(port, UART_LSR);\r\nif ((status & BOTH_EMPTY) == BOTH_EMPTY)\r\nreturn;\r\ncpu_relax();\r\n}\r\n}\r\nstatic void __init serial_putc(struct uart_port *port, int c)\r\n{\r\nwait_for_xmitr(port);\r\nserial8250_early_out(port, UART_TX, c);\r\n}\r\nstatic void __init early_serial8250_write(struct console *console,\r\nconst char *s, unsigned int count)\r\n{\r\nstruct uart_port *port = &early_device.port;\r\nunsigned int ier;\r\nier = serial8250_early_in(port, UART_IER);\r\nserial8250_early_out(port, UART_IER, 0);\r\nuart_console_write(port, s, count, serial_putc);\r\nwait_for_xmitr(port);\r\nserial8250_early_out(port, UART_IER, ier);\r\n}\r\nstatic unsigned int __init probe_baud(struct uart_port *port)\r\n{\r\nunsigned char lcr, dll, dlm;\r\nunsigned int quot;\r\nlcr = serial8250_early_in(port, UART_LCR);\r\nserial8250_early_out(port, UART_LCR, lcr | UART_LCR_DLAB);\r\ndll = serial8250_early_in(port, UART_DLL);\r\ndlm = serial8250_early_in(port, UART_DLM);\r\nserial8250_early_out(port, UART_LCR, lcr);\r\nquot = (dlm << 8) | dll;\r\nreturn (port->uartclk / 16) / quot;\r\n}\r\nstatic void __init init_port(struct early_serial8250_device *device)\r\n{\r\nstruct uart_port *port = &device->port;\r\nunsigned int divisor;\r\nunsigned char c;\r\nserial8250_early_out(port, UART_LCR, 0x3);\r\nserial8250_early_out(port, UART_IER, 0);\r\nserial8250_early_out(port, UART_FCR, 0);\r\nserial8250_early_out(port, UART_MCR, 0x3);\r\ndivisor = DIV_ROUND_CLOSEST(port->uartclk, 16 * device->baud);\r\nc = serial8250_early_in(port, UART_LCR);\r\nserial8250_early_out(port, UART_LCR, c | UART_LCR_DLAB);\r\nserial8250_early_out(port, UART_DLL, divisor & 0xff);\r\nserial8250_early_out(port, UART_DLM, (divisor >> 8) & 0xff);\r\nserial8250_early_out(port, UART_LCR, c & ~UART_LCR_DLAB);\r\n}\r\nstatic int __init parse_options(struct early_serial8250_device *device,\r\nchar *options)\r\n{\r\nstruct uart_port *port = &device->port;\r\nint mmio, mmio32, length;\r\nif (!options)\r\nreturn -ENODEV;\r\nport->uartclk = BASE_BAUD * 16;\r\nmmio = !strncmp(options, "mmio,", 5);\r\nmmio32 = !strncmp(options, "mmio32,", 7);\r\nif (mmio || mmio32) {\r\nport->iotype = (mmio ? UPIO_MEM : UPIO_MEM32);\r\nport->mapbase = simple_strtoul(options + (mmio ? 5 : 7),\r\n&options, 0);\r\nif (mmio32)\r\nport->regshift = 2;\r\n#ifdef CONFIG_FIX_EARLYCON_MEM\r\nset_fixmap_nocache(FIX_EARLYCON_MEM_BASE,\r\nport->mapbase & PAGE_MASK);\r\nport->membase =\r\n(void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);\r\nport->membase += port->mapbase & ~PAGE_MASK;\r\n#else\r\nport->membase = ioremap_nocache(port->mapbase, 64);\r\nif (!port->membase) {\r\nprintk(KERN_ERR "%s: Couldn't ioremap 0x%llx\n",\r\n__func__,\r\n(unsigned long long) port->mapbase);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\n} else if (!strncmp(options, "io,", 3)) {\r\nport->iotype = UPIO_PORT;\r\nport->iobase = simple_strtoul(options + 3, &options, 0);\r\nmmio = 0;\r\n} else\r\nreturn -EINVAL;\r\noptions = strchr(options, ',');\r\nif (options) {\r\noptions++;\r\ndevice->baud = simple_strtoul(options, NULL, 0);\r\nlength = min(strcspn(options, " ") + 1,\r\n(size_t)(sizeof(device->options)));\r\nstrlcpy(device->options, options, length);\r\n} else {\r\ndevice->baud = probe_baud(port);\r\nsnprintf(device->options, sizeof(device->options), "%u",\r\ndevice->baud);\r\n}\r\nif (mmio || mmio32)\r\nprintk(KERN_INFO\r\n"Early serial console at MMIO%s 0x%llx (options '%s')\n",\r\nmmio32 ? "32" : "",\r\n(unsigned long long)port->mapbase,\r\ndevice->options);\r\nelse\r\nprintk(KERN_INFO\r\n"Early serial console at I/O port 0x%lx (options '%s')\n",\r\nport->iobase,\r\ndevice->options);\r\nreturn 0;\r\n}\r\nstatic int __init early_serial8250_setup(char *options)\r\n{\r\nstruct early_serial8250_device *device = &early_device;\r\nint err;\r\nif (device->port.membase || device->port.iobase)\r\nreturn 0;\r\nerr = parse_options(device, options);\r\nif (err < 0)\r\nreturn err;\r\ninit_port(device);\r\nreturn 0;\r\n}\r\nint __init setup_early_serial8250_console(char *cmdline)\r\n{\r\nchar *options;\r\nint err;\r\noptions = strstr(cmdline, "uart8250,");\r\nif (!options) {\r\noptions = strstr(cmdline, "uart,");\r\nif (!options)\r\nreturn 0;\r\n}\r\noptions = strchr(cmdline, ',') + 1;\r\nerr = early_serial8250_setup(options);\r\nif (err < 0)\r\nreturn err;\r\nregister_console(&early_serial8250_console);\r\nreturn 0;\r\n}\r\nint serial8250_find_port_for_earlycon(void)\r\n{\r\nstruct early_serial8250_device *device = &early_device;\r\nstruct uart_port *port = &device->port;\r\nint line;\r\nint ret;\r\nif (!device->port.membase && !device->port.iobase)\r\nreturn -ENODEV;\r\nline = serial8250_find_port(port);\r\nif (line < 0)\r\nreturn -ENODEV;\r\nret = update_console_cmdline("uart", 8250,\r\n"ttyS", line, device->options);\r\nif (ret < 0)\r\nret = update_console_cmdline("uart", 0,\r\n"ttyS", line, device->options);\r\nreturn ret;\r\n}
