static void jffs2_erase_block(struct jffs2_sb_info *c,\r\nstruct jffs2_eraseblock *jeb)\r\n{\r\nint ret;\r\nuint32_t bad_offset;\r\n#ifdef __ECOS\r\nret = jffs2_flash_erase(c, jeb);\r\nif (!ret) {\r\njffs2_erase_succeeded(c, jeb);\r\nreturn;\r\n}\r\nbad_offset = jeb->offset;\r\n#else\r\nstruct erase_info *instr;\r\njffs2_dbg(1, "%s(): erase block %#08x (range %#08x-%#08x)\n",\r\n__func__,\r\njeb->offset, jeb->offset, jeb->offset + c->sector_size);\r\ninstr = kmalloc(sizeof(struct erase_info) + sizeof(struct erase_priv_struct), GFP_KERNEL);\r\nif (!instr) {\r\npr_warn("kmalloc for struct erase_info in jffs2_erase_block failed. Refiling block for later\n");\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nlist_move(&jeb->list, &c->erase_pending_list);\r\nc->erasing_size -= c->sector_size;\r\nc->dirty_size += c->sector_size;\r\njeb->dirty_size = c->sector_size;\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nreturn;\r\n}\r\nmemset(instr, 0, sizeof(*instr));\r\ninstr->mtd = c->mtd;\r\ninstr->addr = jeb->offset;\r\ninstr->len = c->sector_size;\r\ninstr->callback = jffs2_erase_callback;\r\ninstr->priv = (unsigned long)(&instr[1]);\r\n((struct erase_priv_struct *)instr->priv)->jeb = jeb;\r\n((struct erase_priv_struct *)instr->priv)->c = c;\r\nret = mtd_erase(c->mtd, instr);\r\nif (!ret)\r\nreturn;\r\nbad_offset = instr->fail_addr;\r\nkfree(instr);\r\n#endif\r\nif (ret == -ENOMEM || ret == -EAGAIN) {\r\njffs2_dbg(1, "Erase at 0x%08x failed: %d. Refiling on erase_pending_list\n",\r\njeb->offset, ret);\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nlist_move(&jeb->list, &c->erase_pending_list);\r\nc->erasing_size -= c->sector_size;\r\nc->dirty_size += c->sector_size;\r\njeb->dirty_size = c->sector_size;\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nreturn;\r\n}\r\nif (ret == -EROFS)\r\npr_warn("Erase at 0x%08x failed immediately: -EROFS. Is the sector locked?\n",\r\njeb->offset);\r\nelse\r\npr_warn("Erase at 0x%08x failed immediately: errno %d\n",\r\njeb->offset, ret);\r\njffs2_erase_failed(c, jeb, bad_offset);\r\n}\r\nint jffs2_erase_pending_blocks(struct jffs2_sb_info *c, int count)\r\n{\r\nstruct jffs2_eraseblock *jeb;\r\nint work_done = 0;\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nwhile (!list_empty(&c->erase_complete_list) ||\r\n!list_empty(&c->erase_pending_list)) {\r\nif (!list_empty(&c->erase_complete_list)) {\r\njeb = list_entry(c->erase_complete_list.next, struct jffs2_eraseblock, list);\r\nlist_move(&jeb->list, &c->erase_checking_list);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\njffs2_mark_erased_block(c, jeb);\r\nwork_done++;\r\nif (!--count) {\r\njffs2_dbg(1, "Count reached. jffs2_erase_pending_blocks leaving\n");\r\ngoto done;\r\n}\r\n} else if (!list_empty(&c->erase_pending_list)) {\r\njeb = list_entry(c->erase_pending_list.next, struct jffs2_eraseblock, list);\r\njffs2_dbg(1, "Starting erase of pending block 0x%08x\n",\r\njeb->offset);\r\nlist_del(&jeb->list);\r\nc->erasing_size += c->sector_size;\r\nc->wasted_size -= jeb->wasted_size;\r\nc->free_size -= jeb->free_size;\r\nc->used_size -= jeb->used_size;\r\nc->dirty_size -= jeb->dirty_size;\r\njeb->wasted_size = jeb->used_size = jeb->dirty_size = jeb->free_size = 0;\r\njffs2_free_jeb_node_refs(c, jeb);\r\nlist_add(&jeb->list, &c->erasing_list);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\njffs2_erase_block(c, jeb);\r\n} else {\r\nBUG();\r\n}\r\ncond_resched();\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\ndone:\r\njffs2_dbg(1, "jffs2_erase_pending_blocks completed\n");\r\nreturn work_done;\r\n}\r\nstatic void jffs2_erase_succeeded(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\r\n{\r\njffs2_dbg(1, "Erase completed successfully at 0x%08x\n", jeb->offset);\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nlist_move_tail(&jeb->list, &c->erase_complete_list);\r\njffs2_garbage_collect_trigger(c);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nwake_up(&c->erase_wait);\r\n}\r\nstatic void jffs2_erase_failed(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t bad_offset)\r\n{\r\nif (jffs2_cleanmarker_oob(c) && (bad_offset != (uint32_t)MTD_FAIL_ADDR_UNKNOWN)) {\r\nif (!jffs2_write_nand_badblock(c, jeb, bad_offset)) {\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nlist_move(&jeb->list, &c->erase_pending_list);\r\nc->erasing_size -= c->sector_size;\r\nc->dirty_size += c->sector_size;\r\njeb->dirty_size = c->sector_size;\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nreturn;\r\n}\r\n}\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nc->erasing_size -= c->sector_size;\r\nc->bad_size += c->sector_size;\r\nlist_move(&jeb->list, &c->bad_list);\r\nc->nr_erasing_blocks--;\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nwake_up(&c->erase_wait);\r\n}\r\nstatic void jffs2_erase_callback(struct erase_info *instr)\r\n{\r\nstruct erase_priv_struct *priv = (void *)instr->priv;\r\nif(instr->state != MTD_ERASE_DONE) {\r\npr_warn("Erase at 0x%08llx finished, but state != MTD_ERASE_DONE. State is 0x%x instead.\n",\r\n(unsigned long long)instr->addr, instr->state);\r\njffs2_erase_failed(priv->c, priv->jeb, instr->fail_addr);\r\n} else {\r\njffs2_erase_succeeded(priv->c, priv->jeb);\r\n}\r\nkfree(instr);\r\n}\r\nstatic inline void jffs2_remove_node_refs_from_ino_list(struct jffs2_sb_info *c,\r\nstruct jffs2_raw_node_ref *ref, struct jffs2_eraseblock *jeb)\r\n{\r\nstruct jffs2_inode_cache *ic = NULL;\r\nstruct jffs2_raw_node_ref **prev;\r\nprev = &ref->next_in_ino;\r\nwhile (1) {\r\nif (!(*prev)->next_in_ino) {\r\nic = (struct jffs2_inode_cache *)(*prev);\r\nprev = &ic->nodes;\r\ncontinue;\r\n}\r\nif (SECTOR_ADDR((*prev)->flash_offset) == jeb->offset) {\r\nstruct jffs2_raw_node_ref *this;\r\nthis = *prev;\r\n*prev = this->next_in_ino;\r\nthis->next_in_ino = NULL;\r\nif (this == ref)\r\nbreak;\r\ncontinue;\r\n}\r\nprev = &((*prev)->next_in_ino);\r\n}\r\nif (!ic) {\r\nJFFS2_WARNING("inode_cache/xattr_datum/xattr_ref"\r\n" not found in remove_node_refs()!!\n");\r\nreturn;\r\n}\r\njffs2_dbg(1, "Removed nodes in range 0x%08x-0x%08x from ino #%u\n",\r\njeb->offset, jeb->offset + c->sector_size, ic->ino);\r\nD2({\r\nint i=0;\r\nstruct jffs2_raw_node_ref *this;\r\nprintk(KERN_DEBUG "After remove_node_refs_from_ino_list: \n");\r\nthis = ic->nodes;\r\nprintk(KERN_DEBUG);\r\nwhile(this) {\r\npr_cont("0x%08x(%d)->",\r\nref_offset(this), ref_flags(this));\r\nif (++i == 5) {\r\nprintk(KERN_DEBUG);\r\ni=0;\r\n}\r\nthis = this->next_in_ino;\r\n}\r\npr_cont("\n");\r\n});\r\nswitch (ic->class) {\r\n#ifdef CONFIG_JFFS2_FS_XATTR\r\ncase RAWNODE_CLASS_XATTR_DATUM:\r\njffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\r\nbreak;\r\ncase RAWNODE_CLASS_XATTR_REF:\r\njffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\r\nbreak;\r\n#endif\r\ndefault:\r\nif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\r\njffs2_del_ino_cache(c, ic);\r\n}\r\n}\r\nvoid jffs2_free_jeb_node_refs(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\r\n{\r\nstruct jffs2_raw_node_ref *block, *ref;\r\njffs2_dbg(1, "Freeing all node refs for eraseblock offset 0x%08x\n",\r\njeb->offset);\r\nblock = ref = jeb->first_node;\r\nwhile (ref) {\r\nif (ref->flash_offset == REF_LINK_NODE) {\r\nref = ref->next_in_ino;\r\njffs2_free_refblock(block);\r\nblock = ref;\r\ncontinue;\r\n}\r\nif (ref->flash_offset != REF_EMPTY_NODE && ref->next_in_ino)\r\njffs2_remove_node_refs_from_ino_list(c, ref, jeb);\r\nref++;\r\n}\r\njeb->first_node = jeb->last_node = NULL;\r\n}\r\nstatic int jffs2_block_check_erase(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb, uint32_t *bad_offset)\r\n{\r\nvoid *ebuf;\r\nuint32_t ofs;\r\nsize_t retlen;\r\nint ret;\r\nunsigned long *wordebuf;\r\nret = mtd_point(c->mtd, jeb->offset, c->sector_size, &retlen,\r\n&ebuf, NULL);\r\nif (ret != -EOPNOTSUPP) {\r\nif (ret) {\r\njffs2_dbg(1, "MTD point failed %d\n", ret);\r\ngoto do_flash_read;\r\n}\r\nif (retlen < c->sector_size) {\r\njffs2_dbg(1, "MTD point returned len too short: 0x%zx\n",\r\nretlen);\r\nmtd_unpoint(c->mtd, jeb->offset, retlen);\r\ngoto do_flash_read;\r\n}\r\nwordebuf = ebuf-sizeof(*wordebuf);\r\nretlen /= sizeof(*wordebuf);\r\ndo {\r\nif (*++wordebuf != ~0)\r\nbreak;\r\n} while(--retlen);\r\nmtd_unpoint(c->mtd, jeb->offset, c->sector_size);\r\nif (retlen) {\r\npr_warn("Newly-erased block contained word 0x%lx at offset 0x%08tx\n",\r\n*wordebuf,\r\njeb->offset +\r\nc->sector_size-retlen * sizeof(*wordebuf));\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\ndo_flash_read:\r\nebuf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!ebuf) {\r\npr_warn("Failed to allocate page buffer for verifying erase at 0x%08x. Refiling\n",\r\njeb->offset);\r\nreturn -EAGAIN;\r\n}\r\njffs2_dbg(1, "Verifying erase at 0x%08x\n", jeb->offset);\r\nfor (ofs = jeb->offset; ofs < jeb->offset + c->sector_size; ) {\r\nuint32_t readlen = min((uint32_t)PAGE_SIZE, jeb->offset + c->sector_size - ofs);\r\nint i;\r\n*bad_offset = ofs;\r\nret = mtd_read(c->mtd, ofs, readlen, &retlen, ebuf);\r\nif (ret) {\r\npr_warn("Read of newly-erased block at 0x%08x failed: %d. Putting on bad_list\n",\r\nofs, ret);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nif (retlen != readlen) {\r\npr_warn("Short read from newly-erased block at 0x%08x. Wanted %d, got %zd\n",\r\nofs, readlen, retlen);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\nfor (i=0; i<readlen; i += sizeof(unsigned long)) {\r\nunsigned long *datum = ebuf + i;\r\nif (*datum + 1) {\r\n*bad_offset += i;\r\npr_warn("Newly-erased block contained word 0x%lx at offset 0x%08x\n",\r\n*datum, *bad_offset);\r\nret = -EIO;\r\ngoto fail;\r\n}\r\n}\r\nofs += readlen;\r\ncond_resched();\r\n}\r\nret = 0;\r\nfail:\r\nkfree(ebuf);\r\nreturn ret;\r\n}\r\nstatic void jffs2_mark_erased_block(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\r\n{\r\nsize_t retlen;\r\nint ret;\r\nuint32_t uninitialized_var(bad_offset);\r\nswitch (jffs2_block_check_erase(c, jeb, &bad_offset)) {\r\ncase -EAGAIN: goto refile;\r\ncase -EIO: goto filebad;\r\n}\r\njffs2_dbg(1, "Writing erased marker to block at 0x%08x\n", jeb->offset);\r\nbad_offset = jeb->offset;\r\nif (jffs2_cleanmarker_oob(c) || c->cleanmarker_size == 0) {\r\nif (jffs2_cleanmarker_oob(c)) {\r\nif (jffs2_write_nand_cleanmarker(c, jeb))\r\ngoto filebad;\r\n}\r\n} else {\r\nstruct kvec vecs[1];\r\nstruct jffs2_unknown_node marker = {\r\n.magic = cpu_to_je16(JFFS2_MAGIC_BITMASK),\r\n.nodetype = cpu_to_je16(JFFS2_NODETYPE_CLEANMARKER),\r\n.totlen = cpu_to_je32(c->cleanmarker_size)\r\n};\r\njffs2_prealloc_raw_node_refs(c, jeb, 1);\r\nmarker.hdr_crc = cpu_to_je32(crc32(0, &marker, sizeof(struct jffs2_unknown_node)-4));\r\nvecs[0].iov_base = (unsigned char *) &marker;\r\nvecs[0].iov_len = sizeof(marker);\r\nret = jffs2_flash_direct_writev(c, vecs, 1, jeb->offset, &retlen);\r\nif (ret || retlen != sizeof(marker)) {\r\nif (ret)\r\npr_warn("Write clean marker to block at 0x%08x failed: %d\n",\r\njeb->offset, ret);\r\nelse\r\npr_warn("Short write to newly-erased block at 0x%08x: Wanted %zd, got %zd\n",\r\njeb->offset, sizeof(marker), retlen);\r\ngoto filebad;\r\n}\r\n}\r\njeb->free_size = c->sector_size;\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\nc->erasing_size -= c->sector_size;\r\nc->free_size += c->sector_size;\r\nif (c->cleanmarker_size && !jffs2_cleanmarker_oob(c))\r\njffs2_link_node_ref(c, jeb, jeb->offset | REF_NORMAL, c->cleanmarker_size, NULL);\r\nlist_move_tail(&jeb->list, &c->free_list);\r\nc->nr_erasing_blocks--;\r\nc->nr_free_blocks++;\r\njffs2_dbg_acct_sanity_check_nolock(c, jeb);\r\njffs2_dbg_acct_paranoia_check_nolock(c, jeb);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nwake_up(&c->erase_wait);\r\nreturn;\r\nfilebad:\r\njffs2_erase_failed(c, jeb, bad_offset);\r\nreturn;\r\nrefile:\r\nmutex_lock(&c->erase_free_sem);\r\nspin_lock(&c->erase_completion_lock);\r\njffs2_garbage_collect_trigger(c);\r\nlist_move(&jeb->list, &c->erase_complete_list);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->erase_free_sem);\r\nreturn;\r\n}
