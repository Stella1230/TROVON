static void __fsi_reg_write(u32 __iomem *reg, u32 data)\r\n{\r\ndata &= 0x00ffffff;\r\n__raw_writel(data, reg);\r\n}\r\nstatic u32 __fsi_reg_read(u32 __iomem *reg)\r\n{\r\nreturn __raw_readl(reg);\r\n}\r\nstatic void __fsi_reg_mask_set(u32 __iomem *reg, u32 mask, u32 data)\r\n{\r\nu32 val = __fsi_reg_read(reg);\r\nval &= ~mask;\r\nval |= data & mask;\r\n__fsi_reg_write(reg, val);\r\n}\r\nstatic u32 _fsi_master_read(struct fsi_master *master, u32 reg)\r\n{\r\nu32 ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&master->lock, flags);\r\nret = __fsi_reg_read(master->base + reg);\r\nspin_unlock_irqrestore(&master->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void _fsi_master_mask_set(struct fsi_master *master,\r\nu32 reg, u32 mask, u32 data)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&master->lock, flags);\r\n__fsi_reg_mask_set(master->base + reg, mask, data);\r\nspin_unlock_irqrestore(&master->lock, flags);\r\n}\r\nstatic int fsi_version(struct fsi_master *master)\r\n{\r\nreturn master->core->ver;\r\n}\r\nstatic struct fsi_master *fsi_get_master(struct fsi_priv *fsi)\r\n{\r\nreturn fsi->master;\r\n}\r\nstatic int fsi_is_clk_master(struct fsi_priv *fsi)\r\n{\r\nreturn fsi->clk_master;\r\n}\r\nstatic int fsi_is_port_a(struct fsi_priv *fsi)\r\n{\r\nreturn fsi->master->base == fsi->base;\r\n}\r\nstatic int fsi_is_spdif(struct fsi_priv *fsi)\r\n{\r\nreturn fsi->spdif;\r\n}\r\nstatic int fsi_is_enable_stream(struct fsi_priv *fsi)\r\n{\r\nreturn fsi->enable_stream;\r\n}\r\nstatic int fsi_is_play(struct snd_pcm_substream *substream)\r\n{\r\nreturn substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\n}\r\nstatic struct snd_soc_dai *fsi_get_dai(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nreturn rtd->cpu_dai;\r\n}\r\nstatic struct fsi_priv *fsi_get_priv_frm_dai(struct snd_soc_dai *dai)\r\n{\r\nstruct fsi_master *master = snd_soc_dai_get_drvdata(dai);\r\nif (dai->id == 0)\r\nreturn &master->fsia;\r\nelse\r\nreturn &master->fsib;\r\n}\r\nstatic struct fsi_priv *fsi_get_priv(struct snd_pcm_substream *substream)\r\n{\r\nreturn fsi_get_priv_frm_dai(fsi_get_dai(substream));\r\n}\r\nstatic u32 fsi_get_port_shift(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nint is_play = fsi_stream_is_play(fsi, io);\r\nint is_porta = fsi_is_port_a(fsi);\r\nu32 shift;\r\nif (is_porta)\r\nshift = is_play ? AO_SHIFT : AI_SHIFT;\r\nelse\r\nshift = is_play ? BO_SHIFT : BI_SHIFT;\r\nreturn shift;\r\n}\r\nstatic int fsi_frame2sample(struct fsi_priv *fsi, int frames)\r\n{\r\nreturn frames * fsi->chan_num;\r\n}\r\nstatic int fsi_sample2frame(struct fsi_priv *fsi, int samples)\r\n{\r\nreturn samples / fsi->chan_num;\r\n}\r\nstatic int fsi_get_current_fifo_samples(struct fsi_priv *fsi,\r\nstruct fsi_stream *io)\r\n{\r\nint is_play = fsi_stream_is_play(fsi, io);\r\nu32 status;\r\nint frames;\r\nstatus = is_play ?\r\nfsi_reg_read(fsi, DOFF_ST) :\r\nfsi_reg_read(fsi, DIFF_ST);\r\nframes = 0x1ff & (status >> 8);\r\nreturn fsi_frame2sample(fsi, frames);\r\n}\r\nstatic void fsi_count_fifo_err(struct fsi_priv *fsi)\r\n{\r\nu32 ostatus = fsi_reg_read(fsi, DOFF_ST);\r\nu32 istatus = fsi_reg_read(fsi, DIFF_ST);\r\nif (ostatus & ERR_OVER)\r\nfsi->playback.oerr_num++;\r\nif (ostatus & ERR_UNDER)\r\nfsi->playback.uerr_num++;\r\nif (istatus & ERR_OVER)\r\nfsi->capture.oerr_num++;\r\nif (istatus & ERR_UNDER)\r\nfsi->capture.uerr_num++;\r\nfsi_reg_write(fsi, DOFF_ST, 0);\r\nfsi_reg_write(fsi, DIFF_ST, 0);\r\n}\r\nstatic inline int fsi_stream_is_play(struct fsi_priv *fsi,\r\nstruct fsi_stream *io)\r\n{\r\nreturn &fsi->playback == io;\r\n}\r\nstatic inline struct fsi_stream *fsi_stream_get(struct fsi_priv *fsi,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nreturn fsi_is_play(substream) ? &fsi->playback : &fsi->capture;\r\n}\r\nstatic int fsi_stream_is_working(struct fsi_priv *fsi,\r\nstruct fsi_stream *io)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&master->lock, flags);\r\nret = !!(io->substream && io->substream->runtime);\r\nspin_unlock_irqrestore(&master->lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct fsi_priv *fsi_stream_to_priv(struct fsi_stream *io)\r\n{\r\nreturn io->priv;\r\n}\r\nstatic void fsi_stream_init(struct fsi_priv *fsi,\r\nstruct fsi_stream *io,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nunsigned long flags;\r\nspin_lock_irqsave(&master->lock, flags);\r\nio->substream = substream;\r\nio->buff_sample_capa = fsi_frame2sample(fsi, runtime->buffer_size);\r\nio->buff_sample_pos = 0;\r\nio->period_samples = fsi_frame2sample(fsi, runtime->period_size);\r\nio->period_pos = 0;\r\nio->sample_width = samples_to_bytes(runtime, 1);\r\nio->bus_option = 0;\r\nio->oerr_num = -1;\r\nio->uerr_num = -1;\r\nfsi_stream_handler_call(io, init, fsi, io);\r\nspin_unlock_irqrestore(&master->lock, flags);\r\n}\r\nstatic void fsi_stream_quit(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nstruct snd_soc_dai *dai = fsi_get_dai(io->substream);\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nunsigned long flags;\r\nspin_lock_irqsave(&master->lock, flags);\r\nif (io->oerr_num > 0)\r\ndev_err(dai->dev, "over_run = %d\n", io->oerr_num);\r\nif (io->uerr_num > 0)\r\ndev_err(dai->dev, "under_run = %d\n", io->uerr_num);\r\nfsi_stream_handler_call(io, quit, fsi, io);\r\nio->substream = NULL;\r\nio->buff_sample_capa = 0;\r\nio->buff_sample_pos = 0;\r\nio->period_samples = 0;\r\nio->period_pos = 0;\r\nio->sample_width = 0;\r\nio->bus_option = 0;\r\nio->oerr_num = 0;\r\nio->uerr_num = 0;\r\nspin_unlock_irqrestore(&master->lock, flags);\r\n}\r\nstatic int fsi_stream_transfer(struct fsi_stream *io)\r\n{\r\nstruct fsi_priv *fsi = fsi_stream_to_priv(io);\r\nif (!fsi)\r\nreturn -EIO;\r\nreturn fsi_stream_handler_call(io, transfer, fsi, io);\r\n}\r\nstatic int fsi_stream_probe(struct fsi_priv *fsi, struct device *dev)\r\n{\r\nstruct fsi_stream *io;\r\nint ret1, ret2;\r\nio = &fsi->playback;\r\nret1 = fsi_stream_handler_call(io, probe, fsi, io, dev);\r\nio = &fsi->capture;\r\nret2 = fsi_stream_handler_call(io, probe, fsi, io, dev);\r\nif (ret1 < 0)\r\nreturn ret1;\r\nif (ret2 < 0)\r\nreturn ret2;\r\nreturn 0;\r\n}\r\nstatic int fsi_stream_remove(struct fsi_priv *fsi)\r\n{\r\nstruct fsi_stream *io;\r\nint ret1, ret2;\r\nio = &fsi->playback;\r\nret1 = fsi_stream_handler_call(io, remove, fsi, io);\r\nio = &fsi->capture;\r\nret2 = fsi_stream_handler_call(io, remove, fsi, io);\r\nif (ret1 < 0)\r\nreturn ret1;\r\nif (ret2 < 0)\r\nreturn ret2;\r\nreturn 0;\r\n}\r\nstatic void fsi_format_bus_setup(struct fsi_priv *fsi, struct fsi_stream *io,\r\nu32 bus, struct device *dev)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nint is_play = fsi_stream_is_play(fsi, io);\r\nu32 fmt = fsi->fmt;\r\nif (fsi_version(master) >= 2) {\r\nu32 dma = 0;\r\nswitch (bus) {\r\ncase PACKAGE_24BITBUS_FRONT:\r\nfmt |= CR_BWS_24;\r\ndma |= VDMD_FRONT;\r\ndev_dbg(dev, "24bit bus / package in front\n");\r\nbreak;\r\ncase PACKAGE_16BITBUS_STREAM:\r\nfmt |= CR_BWS_16;\r\ndma |= VDMD_STREAM;\r\ndev_dbg(dev, "16bit bus / stream mode\n");\r\nbreak;\r\ncase PACKAGE_24BITBUS_BACK:\r\ndefault:\r\nfmt |= CR_BWS_24;\r\ndma |= VDMD_BACK;\r\ndev_dbg(dev, "24bit bus / package in back\n");\r\nbreak;\r\n}\r\nif (is_play)\r\nfsi_reg_write(fsi, OUT_DMAC, dma);\r\nelse\r\nfsi_reg_write(fsi, IN_DMAC, dma);\r\n}\r\nif (is_play)\r\nfsi_reg_write(fsi, DO_FMT, fmt);\r\nelse\r\nfsi_reg_write(fsi, DI_FMT, fmt);\r\n}\r\nstatic void fsi_irq_enable(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nu32 data = AB_IO(1, fsi_get_port_shift(fsi, io));\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nfsi_core_mask_set(master, imsk, data, data);\r\nfsi_core_mask_set(master, iemsk, data, data);\r\n}\r\nstatic void fsi_irq_disable(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nu32 data = AB_IO(1, fsi_get_port_shift(fsi, io));\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nfsi_core_mask_set(master, imsk, data, 0);\r\nfsi_core_mask_set(master, iemsk, data, 0);\r\n}\r\nstatic u32 fsi_irq_get_status(struct fsi_master *master)\r\n{\r\nreturn fsi_core_read(master, int_st);\r\n}\r\nstatic void fsi_irq_clear_status(struct fsi_priv *fsi)\r\n{\r\nu32 data = 0;\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\ndata |= AB_IO(1, fsi_get_port_shift(fsi, &fsi->playback));\r\ndata |= AB_IO(1, fsi_get_port_shift(fsi, &fsi->capture));\r\nfsi_core_mask_set(master, int_st, data, 0);\r\n}\r\nstatic void fsi_spdif_clk_ctrl(struct fsi_priv *fsi, int enable)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nu32 mask, val;\r\nmask = BP | SE;\r\nval = enable ? mask : 0;\r\nfsi_is_port_a(fsi) ?\r\nfsi_core_mask_set(master, a_mclk, mask, val) :\r\nfsi_core_mask_set(master, b_mclk, mask, val);\r\n}\r\nstatic int fsi_clk_init(struct device *dev,\r\nstruct fsi_priv *fsi,\r\nint xck,\r\nint ick,\r\nint div,\r\nint (*set_rate)(struct device *dev,\r\nstruct fsi_priv *fsi))\r\n{\r\nstruct fsi_clk *clock = &fsi->clock;\r\nint is_porta = fsi_is_port_a(fsi);\r\nclock->xck = NULL;\r\nclock->ick = NULL;\r\nclock->div = NULL;\r\nclock->rate = 0;\r\nclock->count = 0;\r\nclock->set_rate = set_rate;\r\nclock->own = devm_clk_get(dev, NULL);\r\nif (IS_ERR(clock->own))\r\nreturn -EINVAL;\r\nif (xck) {\r\nclock->xck = devm_clk_get(dev, is_porta ? "xcka" : "xckb");\r\nif (IS_ERR(clock->xck)) {\r\ndev_err(dev, "can't get xck clock\n");\r\nreturn -EINVAL;\r\n}\r\nif (clock->xck == clock->own) {\r\ndev_err(dev, "cpu doesn't support xck clock\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (ick) {\r\nclock->ick = devm_clk_get(dev, is_porta ? "icka" : "ickb");\r\nif (IS_ERR(clock->ick)) {\r\ndev_err(dev, "can't get ick clock\n");\r\nreturn -EINVAL;\r\n}\r\nif (clock->ick == clock->own) {\r\ndev_err(dev, "cpu doesn't support ick clock\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (div) {\r\nclock->div = devm_clk_get(dev, is_porta ? "diva" : "divb");\r\nif (IS_ERR(clock->div)) {\r\ndev_err(dev, "can't get div clock\n");\r\nreturn -EINVAL;\r\n}\r\nif (clock->div == clock->own) {\r\ndev_err(dev, "cpu doens't support div clock\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void fsi_clk_valid(struct fsi_priv *fsi, unsigned long rate)\r\n{\r\nfsi->clock.rate = rate;\r\n}\r\nstatic int fsi_clk_is_valid(struct fsi_priv *fsi)\r\n{\r\nreturn fsi->clock.set_rate &&\r\nfsi->clock.rate;\r\n}\r\nstatic int fsi_clk_enable(struct device *dev,\r\nstruct fsi_priv *fsi)\r\n{\r\nstruct fsi_clk *clock = &fsi->clock;\r\nint ret = -EINVAL;\r\nif (!fsi_clk_is_valid(fsi))\r\nreturn ret;\r\nif (0 == clock->count) {\r\nret = clock->set_rate(dev, fsi);\r\nif (ret < 0) {\r\nfsi_clk_invalid(fsi);\r\nreturn ret;\r\n}\r\nif (clock->xck)\r\nclk_enable(clock->xck);\r\nif (clock->ick)\r\nclk_enable(clock->ick);\r\nif (clock->div)\r\nclk_enable(clock->div);\r\nclock->count++;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fsi_clk_disable(struct device *dev,\r\nstruct fsi_priv *fsi)\r\n{\r\nstruct fsi_clk *clock = &fsi->clock;\r\nif (!fsi_clk_is_valid(fsi))\r\nreturn -EINVAL;\r\nif (1 == clock->count--) {\r\nif (clock->xck)\r\nclk_disable(clock->xck);\r\nif (clock->ick)\r\nclk_disable(clock->ick);\r\nif (clock->div)\r\nclk_disable(clock->div);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsi_clk_set_ackbpf(struct device *dev,\r\nstruct fsi_priv *fsi,\r\nint ackmd, int bpfmd)\r\n{\r\nu32 data = 0;\r\nif (bpfmd > ackmd) {\r\ndev_err(dev, "unsupported rate (%d/%d)\n", ackmd, bpfmd);\r\nreturn -EINVAL;\r\n}\r\nswitch (ackmd) {\r\ncase 512:\r\ndata |= (0x0 << 12);\r\nbreak;\r\ncase 256:\r\ndata |= (0x1 << 12);\r\nbreak;\r\ncase 128:\r\ndata |= (0x2 << 12);\r\nbreak;\r\ncase 64:\r\ndata |= (0x3 << 12);\r\nbreak;\r\ncase 32:\r\ndata |= (0x4 << 12);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported ackmd (%d)\n", ackmd);\r\nreturn -EINVAL;\r\n}\r\nswitch (bpfmd) {\r\ncase 32:\r\ndata |= (0x0 << 8);\r\nbreak;\r\ncase 64:\r\ndata |= (0x1 << 8);\r\nbreak;\r\ncase 128:\r\ndata |= (0x2 << 8);\r\nbreak;\r\ncase 256:\r\ndata |= (0x3 << 8);\r\nbreak;\r\ncase 512:\r\ndata |= (0x4 << 8);\r\nbreak;\r\ncase 16:\r\ndata |= (0x7 << 8);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported bpfmd (%d)\n", bpfmd);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "ACKMD/BPFMD = %d/%d\n", ackmd, bpfmd);\r\nfsi_reg_mask_set(fsi, CKG1, (ACKMD_MASK | BPFMD_MASK) , data);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int fsi_clk_set_rate_external(struct device *dev,\r\nstruct fsi_priv *fsi)\r\n{\r\nstruct clk *xck = fsi->clock.xck;\r\nstruct clk *ick = fsi->clock.ick;\r\nunsigned long rate = fsi->clock.rate;\r\nunsigned long xrate;\r\nint ackmd, bpfmd;\r\nint ret = 0;\r\nxrate = clk_get_rate(xck);\r\nif (xrate % rate) {\r\ndev_err(dev, "unsupported clock rate\n");\r\nreturn -EINVAL;\r\n}\r\nclk_set_parent(ick, xck);\r\nclk_set_rate(ick, xrate);\r\nbpfmd = fsi->chan_num * 32;\r\nackmd = xrate / rate;\r\ndev_dbg(dev, "external/rate = %ld/%ld\n", xrate, rate);\r\nret = fsi_clk_set_ackbpf(dev, fsi, ackmd, bpfmd);\r\nif (ret < 0)\r\ndev_err(dev, "%s failed", __func__);\r\nreturn ret;\r\n}\r\nstatic int fsi_clk_set_rate_cpg(struct device *dev,\r\nstruct fsi_priv *fsi)\r\n{\r\nstruct clk *ick = fsi->clock.ick;\r\nstruct clk *div = fsi->clock.div;\r\nunsigned long rate = fsi->clock.rate;\r\nunsigned long target = 0;\r\nunsigned long actual, cout;\r\nunsigned long diff, min;\r\nunsigned long best_cout, best_act;\r\nint adj;\r\nint ackmd, bpfmd;\r\nint ret = -EINVAL;\r\nif (!(12288000 % rate))\r\ntarget = 12288000;\r\nif (!(11289600 % rate))\r\ntarget = 11289600;\r\nif (!target) {\r\ndev_err(dev, "unsupported rate\n");\r\nreturn ret;\r\n}\r\nbpfmd = fsi->chan_num * 32;\r\nackmd = target / rate;\r\nret = fsi_clk_set_ackbpf(dev, fsi, ackmd, bpfmd);\r\nif (ret < 0) {\r\ndev_err(dev, "%s failed", __func__);\r\nreturn ret;\r\n}\r\nmin = ~0;\r\nbest_cout = 0;\r\nbest_act = 0;\r\nfor (adj = 1; adj < 0xffff; adj++) {\r\ncout = target * adj;\r\nif (cout > 100000000)\r\nbreak;\r\ncout = clk_round_rate(ick, cout);\r\nactual = cout / adj;\r\ndiff = abs(actual - target);\r\nif (diff < min) {\r\nmin = diff;\r\nbest_cout = cout;\r\nbest_act = actual;\r\n}\r\n}\r\nret = clk_set_rate(ick, best_cout);\r\nif (ret < 0) {\r\ndev_err(dev, "ick clock failed\n");\r\nreturn -EIO;\r\n}\r\nret = clk_set_rate(div, clk_round_rate(div, best_act));\r\nif (ret < 0) {\r\ndev_err(dev, "div clock failed\n");\r\nreturn -EIO;\r\n}\r\ndev_dbg(dev, "ick/div = %ld/%ld\n",\r\nclk_get_rate(ick), clk_get_rate(div));\r\nreturn ret;\r\n}\r\nstatic void fsi_pio_push16(struct fsi_priv *fsi, u8 *_buf, int samples)\r\n{\r\nint i;\r\nif (fsi_is_enable_stream(fsi)) {\r\nu32 *buf = (u32 *)_buf;\r\nfor (i = 0; i < samples / 2; i++)\r\nfsi_reg_write(fsi, DODT, buf[i]);\r\n} else {\r\nu16 *buf = (u16 *)_buf;\r\nfor (i = 0; i < samples; i++)\r\nfsi_reg_write(fsi, DODT, ((u32)*(buf + i) << 8));\r\n}\r\n}\r\nstatic void fsi_pio_pop16(struct fsi_priv *fsi, u8 *_buf, int samples)\r\n{\r\nu16 *buf = (u16 *)_buf;\r\nint i;\r\nfor (i = 0; i < samples; i++)\r\n*(buf + i) = (u16)(fsi_reg_read(fsi, DIDT) >> 8);\r\n}\r\nstatic void fsi_pio_push32(struct fsi_priv *fsi, u8 *_buf, int samples)\r\n{\r\nu32 *buf = (u32 *)_buf;\r\nint i;\r\nfor (i = 0; i < samples; i++)\r\nfsi_reg_write(fsi, DODT, *(buf + i));\r\n}\r\nstatic void fsi_pio_pop32(struct fsi_priv *fsi, u8 *_buf, int samples)\r\n{\r\nu32 *buf = (u32 *)_buf;\r\nint i;\r\nfor (i = 0; i < samples; i++)\r\n*(buf + i) = fsi_reg_read(fsi, DIDT);\r\n}\r\nstatic u8 *fsi_pio_get_area(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nstruct snd_pcm_runtime *runtime = io->substream->runtime;\r\nreturn runtime->dma_area +\r\nsamples_to_bytes(runtime, io->buff_sample_pos);\r\n}\r\nstatic int fsi_pio_transfer(struct fsi_priv *fsi, struct fsi_stream *io,\r\nvoid (*run16)(struct fsi_priv *fsi, u8 *buf, int samples),\r\nvoid (*run32)(struct fsi_priv *fsi, u8 *buf, int samples),\r\nint samples)\r\n{\r\nstruct snd_pcm_runtime *runtime;\r\nstruct snd_pcm_substream *substream;\r\nu8 *buf;\r\nint over_period;\r\nif (!fsi_stream_is_working(fsi, io))\r\nreturn -EINVAL;\r\nover_period = 0;\r\nsubstream = io->substream;\r\nruntime = substream->runtime;\r\nif (io->buff_sample_pos >=\r\nio->period_samples * (io->period_pos + 1)) {\r\nover_period = 1;\r\nio->period_pos = (io->period_pos + 1) % runtime->periods;\r\nif (0 == io->period_pos)\r\nio->buff_sample_pos = 0;\r\n}\r\nbuf = fsi_pio_get_area(fsi, io);\r\nswitch (io->sample_width) {\r\ncase 2:\r\nrun16(fsi, buf, samples);\r\nbreak;\r\ncase 4:\r\nrun32(fsi, buf, samples);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nio->buff_sample_pos += samples;\r\nif (over_period)\r\nsnd_pcm_period_elapsed(substream);\r\nreturn 0;\r\n}\r\nstatic int fsi_pio_pop(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nint sample_residues;\r\nint sample_space;\r\nint samples;\r\nsample_residues = fsi_get_current_fifo_samples(fsi, io);\r\nsample_space = io->buff_sample_capa - io->buff_sample_pos;\r\nsamples = min(sample_residues, sample_space);\r\nreturn fsi_pio_transfer(fsi, io,\r\nfsi_pio_pop16,\r\nfsi_pio_pop32,\r\nsamples);\r\n}\r\nstatic int fsi_pio_push(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nint sample_residues;\r\nint sample_space;\r\nint samples;\r\nsample_residues = io->buff_sample_capa - io->buff_sample_pos;\r\nsample_space = io->fifo_sample_capa -\r\nfsi_get_current_fifo_samples(fsi, io);\r\nsamples = min(sample_residues, sample_space);\r\nreturn fsi_pio_transfer(fsi, io,\r\nfsi_pio_push16,\r\nfsi_pio_push32,\r\nsamples);\r\n}\r\nstatic int fsi_pio_start_stop(struct fsi_priv *fsi, struct fsi_stream *io,\r\nint enable)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nu32 clk = fsi_is_port_a(fsi) ? CRA : CRB;\r\nif (enable)\r\nfsi_irq_enable(fsi, io);\r\nelse\r\nfsi_irq_disable(fsi, io);\r\nif (fsi_is_clk_master(fsi))\r\nfsi_master_mask_set(master, CLK_RST, clk, (enable) ? clk : 0);\r\nreturn 0;\r\n}\r\nstatic int fsi_pio_push_init(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nif (fsi_is_enable_stream(fsi))\r\nio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\r\nBUSOP_SET(16, PACKAGE_16BITBUS_STREAM);\r\nelse\r\nio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\r\nBUSOP_SET(16, PACKAGE_24BITBUS_BACK);\r\nreturn 0;\r\n}\r\nstatic int fsi_pio_pop_init(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\r\nBUSOP_SET(16, PACKAGE_24BITBUS_BACK);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t fsi_interrupt(int irq, void *data)\r\n{\r\nstruct fsi_master *master = data;\r\nu32 int_st = fsi_irq_get_status(master);\r\nfsi_master_mask_set(master, SOFT_RST, IR, 0);\r\nfsi_master_mask_set(master, SOFT_RST, IR, IR);\r\nif (int_st & AB_IO(1, AO_SHIFT))\r\nfsi_stream_transfer(&master->fsia.playback);\r\nif (int_st & AB_IO(1, BO_SHIFT))\r\nfsi_stream_transfer(&master->fsib.playback);\r\nif (int_st & AB_IO(1, AI_SHIFT))\r\nfsi_stream_transfer(&master->fsia.capture);\r\nif (int_st & AB_IO(1, BI_SHIFT))\r\nfsi_stream_transfer(&master->fsib.capture);\r\nfsi_count_fifo_err(&master->fsia);\r\nfsi_count_fifo_err(&master->fsib);\r\nfsi_irq_clear_status(&master->fsia);\r\nfsi_irq_clear_status(&master->fsib);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsi_dma_init(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nstruct snd_pcm_runtime *runtime = io->substream->runtime;\r\nstruct snd_soc_dai *dai = fsi_get_dai(io->substream);\r\nenum dma_data_direction dir = fsi_stream_is_play(fsi, io) ?\r\nDMA_TO_DEVICE : DMA_FROM_DEVICE;\r\nio->bus_option = BUSOP_SET(24, PACKAGE_24BITBUS_BACK) |\r\nBUSOP_SET(16, PACKAGE_16BITBUS_STREAM);\r\nio->loop_cnt = 2;\r\nio->additional_pos = 0;\r\nio->dma = dma_map_single(dai->dev, runtime->dma_area,\r\nsnd_pcm_lib_buffer_bytes(io->substream), dir);\r\nreturn 0;\r\n}\r\nstatic int fsi_dma_quit(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nstruct snd_soc_dai *dai = fsi_get_dai(io->substream);\r\nenum dma_data_direction dir = fsi_stream_is_play(fsi, io) ?\r\nDMA_TO_DEVICE : DMA_FROM_DEVICE;\r\ndma_unmap_single(dai->dev, io->dma,\r\nsnd_pcm_lib_buffer_bytes(io->substream), dir);\r\nreturn 0;\r\n}\r\nstatic dma_addr_t fsi_dma_get_area(struct fsi_stream *io, int additional)\r\n{\r\nstruct snd_pcm_runtime *runtime = io->substream->runtime;\r\nint period = io->period_pos + additional;\r\nif (period >= runtime->periods)\r\nperiod = 0;\r\nreturn io->dma + samples_to_bytes(runtime, period * io->period_samples);\r\n}\r\nstatic void fsi_dma_complete(void *data)\r\n{\r\nstruct fsi_stream *io = (struct fsi_stream *)data;\r\nstruct fsi_priv *fsi = fsi_stream_to_priv(io);\r\nstruct snd_pcm_runtime *runtime = io->substream->runtime;\r\nstruct snd_soc_dai *dai = fsi_get_dai(io->substream);\r\nenum dma_data_direction dir = fsi_stream_is_play(fsi, io) ?\r\nDMA_TO_DEVICE : DMA_FROM_DEVICE;\r\ndma_sync_single_for_cpu(dai->dev, fsi_dma_get_area(io, 0),\r\nsamples_to_bytes(runtime, io->period_samples), dir);\r\nio->buff_sample_pos += io->period_samples;\r\nio->period_pos++;\r\nif (io->period_pos >= runtime->periods) {\r\nio->period_pos = 0;\r\nio->buff_sample_pos = 0;\r\n}\r\nfsi_count_fifo_err(fsi);\r\nfsi_stream_transfer(io);\r\nsnd_pcm_period_elapsed(io->substream);\r\n}\r\nstatic void fsi_dma_do_work(struct work_struct *work)\r\n{\r\nstruct fsi_stream *io = container_of(work, struct fsi_stream, work);\r\nstruct fsi_priv *fsi = fsi_stream_to_priv(io);\r\nstruct snd_soc_dai *dai;\r\nstruct dma_async_tx_descriptor *desc;\r\nstruct snd_pcm_runtime *runtime;\r\nenum dma_data_direction dir;\r\nint is_play = fsi_stream_is_play(fsi, io);\r\nint len, i;\r\ndma_addr_t buf;\r\nif (!fsi_stream_is_working(fsi, io))\r\nreturn;\r\ndai = fsi_get_dai(io->substream);\r\nruntime = io->substream->runtime;\r\ndir = is_play ? DMA_TO_DEVICE : DMA_FROM_DEVICE;\r\nlen = samples_to_bytes(runtime, io->period_samples);\r\nfor (i = 0; i < io->loop_cnt; i++) {\r\nbuf = fsi_dma_get_area(io, io->additional_pos);\r\ndma_sync_single_for_device(dai->dev, buf, len, dir);\r\ndesc = dmaengine_prep_slave_single(io->chan, buf, len, dir,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc) {\r\ndev_err(dai->dev, "dmaengine_prep_slave_sg() fail\n");\r\nreturn;\r\n}\r\ndesc->callback = fsi_dma_complete;\r\ndesc->callback_param = io;\r\nif (dmaengine_submit(desc) < 0) {\r\ndev_err(dai->dev, "tx_submit() fail\n");\r\nreturn;\r\n}\r\ndma_async_issue_pending(io->chan);\r\nio->additional_pos = 1;\r\n}\r\nio->loop_cnt = 1;\r\nif (!is_play) {\r\nif (ERR_OVER & fsi_reg_read(fsi, DIFF_ST)) {\r\nfsi_reg_mask_set(fsi, DIFF_CTL, FIFO_CLR, FIFO_CLR);\r\nfsi_reg_write(fsi, DIFF_ST, 0);\r\n}\r\n}\r\n}\r\nstatic bool fsi_dma_filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct sh_dmae_slave *slave = param;\r\nchan->private = slave;\r\nreturn true;\r\n}\r\nstatic int fsi_dma_transfer(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\nschedule_work(&io->work);\r\nreturn 0;\r\n}\r\nstatic int fsi_dma_push_start_stop(struct fsi_priv *fsi, struct fsi_stream *io,\r\nint start)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nu32 clk = fsi_is_port_a(fsi) ? CRA : CRB;\r\nu32 enable = start ? DMA_ON : 0;\r\nfsi_reg_mask_set(fsi, OUT_DMAC, DMA_ON, enable);\r\ndmaengine_terminate_all(io->chan);\r\nif (fsi_is_clk_master(fsi))\r\nfsi_master_mask_set(master, CLK_RST, clk, (enable) ? clk : 0);\r\nreturn 0;\r\n}\r\nstatic int fsi_dma_probe(struct fsi_priv *fsi, struct fsi_stream *io, struct device *dev)\r\n{\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nio->chan = dma_request_channel(mask, fsi_dma_filter, &io->slave);\r\nif (!io->chan) {\r\nif (fsi_stream_is_play(fsi, io))\r\nfsi->playback.handler = &fsi_pio_push_handler;\r\nelse\r\nfsi->capture.handler = &fsi_pio_pop_handler;\r\ndev_info(dev, "switch handler (dma => pio)\n");\r\nreturn fsi_stream_probe(fsi, dev);\r\n}\r\nINIT_WORK(&io->work, fsi_dma_do_work);\r\nreturn 0;\r\n}\r\nstatic int fsi_dma_remove(struct fsi_priv *fsi, struct fsi_stream *io)\r\n{\r\ncancel_work_sync(&io->work);\r\nfsi_stream_stop(fsi, io);\r\nif (io->chan)\r\ndma_release_channel(io->chan);\r\nio->chan = NULL;\r\nreturn 0;\r\n}\r\nstatic void fsi_fifo_init(struct fsi_priv *fsi,\r\nstruct fsi_stream *io,\r\nstruct device *dev)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nint is_play = fsi_stream_is_play(fsi, io);\r\nu32 shift, i;\r\nint frame_capa;\r\nshift = fsi_master_read(master, FIFO_SZ);\r\nshift >>= fsi_get_port_shift(fsi, io);\r\nshift &= FIFO_SZ_MASK;\r\nframe_capa = 256 << shift;\r\ndev_dbg(dev, "fifo = %d words\n", frame_capa);\r\nfor (i = 1; i < fsi->chan_num; i <<= 1)\r\nframe_capa >>= 1;\r\ndev_dbg(dev, "%d channel %d store\n",\r\nfsi->chan_num, frame_capa);\r\nio->fifo_sample_capa = fsi_frame2sample(fsi, frame_capa);\r\nif (is_play) {\r\nfsi_reg_write(fsi, DOFF_CTL, IRQ_HALF);\r\nfsi_reg_mask_set(fsi, DOFF_CTL, FIFO_CLR, FIFO_CLR);\r\n} else {\r\nfsi_reg_write(fsi, DIFF_CTL, IRQ_HALF);\r\nfsi_reg_mask_set(fsi, DIFF_CTL, FIFO_CLR, FIFO_CLR);\r\n}\r\n}\r\nstatic int fsi_hw_startup(struct fsi_priv *fsi,\r\nstruct fsi_stream *io,\r\nstruct device *dev)\r\n{\r\nu32 data = 0;\r\nif (fsi_is_clk_master(fsi))\r\ndata = DIMD | DOMD;\r\nfsi_reg_mask_set(fsi, CKG1, (DIMD | DOMD), data);\r\ndata = 0;\r\nif (fsi->bit_clk_inv)\r\ndata |= (1 << 0);\r\nif (fsi->lr_clk_inv)\r\ndata |= (1 << 4);\r\nif (fsi_is_clk_master(fsi))\r\ndata <<= 8;\r\nfsi_reg_write(fsi, CKG2, data);\r\nif (fsi_is_spdif(fsi)) {\r\nfsi_spdif_clk_ctrl(fsi, 1);\r\nfsi_reg_mask_set(fsi, OUT_SEL, DMMD, DMMD);\r\n}\r\ndata = 0;\r\nswitch (io->sample_width) {\r\ncase 2:\r\ndata = BUSOP_GET(16, io->bus_option);\r\nbreak;\r\ncase 4:\r\ndata = BUSOP_GET(24, io->bus_option);\r\nbreak;\r\n}\r\nfsi_format_bus_setup(fsi, io, data, dev);\r\nfsi_irq_disable(fsi, io);\r\nfsi_irq_clear_status(fsi);\r\nfsi_fifo_init(fsi, io, dev);\r\nif (fsi_is_clk_master(fsi))\r\nreturn fsi_clk_enable(dev, fsi);\r\nreturn 0;\r\n}\r\nstatic int fsi_hw_shutdown(struct fsi_priv *fsi,\r\nstruct device *dev)\r\n{\r\nif (fsi_is_clk_master(fsi))\r\nreturn fsi_clk_disable(dev, fsi);\r\nreturn 0;\r\n}\r\nstatic int fsi_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsi_priv *fsi = fsi_get_priv(substream);\r\nfsi_clk_invalid(fsi);\r\nreturn 0;\r\n}\r\nstatic void fsi_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsi_priv *fsi = fsi_get_priv(substream);\r\nfsi_clk_invalid(fsi);\r\n}\r\nstatic int fsi_dai_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsi_priv *fsi = fsi_get_priv(substream);\r\nstruct fsi_stream *io = fsi_stream_get(fsi, substream);\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\nfsi_stream_init(fsi, io, substream);\r\nif (!ret)\r\nret = fsi_hw_startup(fsi, io, dai->dev);\r\nif (!ret)\r\nret = fsi_stream_transfer(io);\r\nif (!ret)\r\nfsi_stream_start(fsi, io);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\nif (!ret)\r\nret = fsi_hw_shutdown(fsi, dai->dev);\r\nfsi_stream_stop(fsi, io);\r\nfsi_stream_quit(fsi, io);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fsi_set_fmt_dai(struct fsi_priv *fsi, unsigned int fmt)\r\n{\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nfsi->fmt = CR_I2S;\r\nfsi->chan_num = 2;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nfsi->fmt = CR_PCM;\r\nfsi->chan_num = 2;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsi_set_fmt_spdif(struct fsi_priv *fsi)\r\n{\r\nstruct fsi_master *master = fsi_get_master(fsi);\r\nif (fsi_version(master) < 2)\r\nreturn -EINVAL;\r\nfsi->fmt = CR_DTMD_SPDIF_PCM | CR_PCM;\r\nfsi->chan_num = 2;\r\nreturn 0;\r\n}\r\nstatic int fsi_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct fsi_priv *fsi = fsi_get_priv_frm_dai(dai);\r\nint ret;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nfsi->clk_master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nfsi->bit_clk_inv = 0;\r\nfsi->lr_clk_inv = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nfsi->bit_clk_inv = 1;\r\nfsi->lr_clk_inv = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nfsi->bit_clk_inv = 1;\r\nfsi->lr_clk_inv = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_NF:\r\ndefault:\r\nfsi->bit_clk_inv = 0;\r\nfsi->lr_clk_inv = 0;\r\nbreak;\r\n}\r\nif (fsi_is_clk_master(fsi)) {\r\nif (fsi->clk_cpg)\r\nfsi_clk_init(dai->dev, fsi, 0, 1, 1,\r\nfsi_clk_set_rate_cpg);\r\nelse\r\nfsi_clk_init(dai->dev, fsi, 1, 1, 0,\r\nfsi_clk_set_rate_external);\r\n}\r\nif (fsi_is_spdif(fsi))\r\nret = fsi_set_fmt_spdif(fsi);\r\nelse\r\nret = fsi_set_fmt_dai(fsi, fmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn ret;\r\n}\r\nstatic int fsi_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct fsi_priv *fsi = fsi_get_priv(substream);\r\nif (fsi_is_clk_master(fsi))\r\nfsi_clk_valid(fsi, params_rate(params));\r\nreturn 0;\r\n}\r\nstatic int fsi_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint ret = 0;\r\nsnd_soc_set_runtime_hwparams(substream, &fsi_pcm_hardware);\r\nret = snd_pcm_hw_constraint_integer(runtime,\r\nSNDRV_PCM_HW_PARAM_PERIODS);\r\nreturn ret;\r\n}\r\nstatic int fsi_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int fsi_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic snd_pcm_uframes_t fsi_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct fsi_priv *fsi = fsi_get_priv(substream);\r\nstruct fsi_stream *io = fsi_stream_get(fsi, substream);\r\nreturn fsi_sample2frame(fsi, io->buff_sample_pos);\r\n}\r\nstatic void fsi_pcm_free(struct snd_pcm *pcm)\r\n{\r\nsnd_pcm_lib_preallocate_free_for_all(pcm);\r\n}\r\nstatic int fsi_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nreturn snd_pcm_lib_preallocate_pages_for_all(\r\npcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\nPREALLOC_BUFFER, PREALLOC_BUFFER_MAX);\r\n}\r\nstatic void fsi_of_parse(char *name,\r\nstruct device_node *np,\r\nstruct sh_fsi_port_info *info,\r\nstruct device *dev)\r\n{\r\nint i;\r\nchar prop[128];\r\nunsigned long flags = 0;\r\nstruct {\r\nchar *name;\r\nunsigned int val;\r\n} of_parse_property[] = {\r\n{ "spdif-connection", SH_FSI_FMT_SPDIF },\r\n{ "stream-mode-support", SH_FSI_ENABLE_STREAM_MODE },\r\n{ "use-internal-clock", SH_FSI_CLK_CPG },\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(of_parse_property); i++) {\r\nsprintf(prop, "%s,%s", name, of_parse_property[i].name);\r\nif (of_get_property(np, prop, NULL))\r\nflags |= of_parse_property[i].val;\r\n}\r\ninfo->flags = flags;\r\ndev_dbg(dev, "%s flags : %lx\n", name, info->flags);\r\n}\r\nstatic void fsi_port_info_init(struct fsi_priv *fsi,\r\nstruct sh_fsi_port_info *info)\r\n{\r\nif (info->flags & SH_FSI_FMT_SPDIF)\r\nfsi->spdif = 1;\r\nif (info->flags & SH_FSI_CLK_CPG)\r\nfsi->clk_cpg = 1;\r\nif (info->flags & SH_FSI_ENABLE_STREAM_MODE)\r\nfsi->enable_stream = 1;\r\n}\r\nstatic void fsi_handler_init(struct fsi_priv *fsi,\r\nstruct sh_fsi_port_info *info)\r\n{\r\nfsi->playback.handler = &fsi_pio_push_handler;\r\nfsi->playback.priv = fsi;\r\nfsi->capture.handler = &fsi_pio_pop_handler;\r\nfsi->capture.priv = fsi;\r\nif (info->tx_id) {\r\nfsi->playback.slave.shdma_slave.slave_id = info->tx_id;\r\nfsi->playback.handler = &fsi_dma_push_handler;\r\n}\r\n}\r\nstatic int fsi_probe(struct platform_device *pdev)\r\n{\r\nstruct fsi_master *master;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct sh_fsi_platform_info info;\r\nconst struct fsi_core *core;\r\nstruct fsi_priv *fsi;\r\nstruct resource *res;\r\nunsigned int irq;\r\nint ret;\r\nmemset(&info, 0, sizeof(info));\r\ncore = NULL;\r\nif (np) {\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(fsi_of_match, &pdev->dev);\r\nif (of_id) {\r\ncore = of_id->data;\r\nfsi_of_parse("fsia", np, &info.port_a, &pdev->dev);\r\nfsi_of_parse("fsib", np, &info.port_b, &pdev->dev);\r\n}\r\n} else {\r\nconst struct platform_device_id *id_entry = pdev->id_entry;\r\nif (id_entry)\r\ncore = (struct fsi_core *)id_entry->driver_data;\r\nif (pdev->dev.platform_data)\r\nmemcpy(&info, pdev->dev.platform_data, sizeof(info));\r\n}\r\nif (!core) {\r\ndev_err(&pdev->dev, "unknown fsi device\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (!res || (int)irq <= 0) {\r\ndev_err(&pdev->dev, "Not enough FSI platform resources.\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = devm_kzalloc(&pdev->dev, sizeof(*master), GFP_KERNEL);\r\nif (!master) {\r\ndev_err(&pdev->dev, "Could not allocate master\n");\r\nreturn -ENOMEM;\r\n}\r\nmaster->base = devm_ioremap_nocache(&pdev->dev,\r\nres->start, resource_size(res));\r\nif (!master->base) {\r\ndev_err(&pdev->dev, "Unable to ioremap FSI registers.\n");\r\nreturn -ENXIO;\r\n}\r\nmaster->core = core;\r\nspin_lock_init(&master->lock);\r\nfsi = &master->fsia;\r\nfsi->base = master->base;\r\nfsi->master = master;\r\nfsi_port_info_init(fsi, &info.port_a);\r\nfsi_handler_init(fsi, &info.port_a);\r\nret = fsi_stream_probe(fsi, &pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "FSIA stream probe failed\n");\r\nreturn ret;\r\n}\r\nfsi = &master->fsib;\r\nfsi->base = master->base + 0x40;\r\nfsi->master = master;\r\nfsi_port_info_init(fsi, &info.port_b);\r\nfsi_handler_init(fsi, &info.port_b);\r\nret = fsi_stream_probe(fsi, &pdev->dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "FSIB stream probe failed\n");\r\ngoto exit_fsia;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\ndev_set_drvdata(&pdev->dev, master);\r\nret = devm_request_irq(&pdev->dev, irq, &fsi_interrupt, 0,\r\ndev_name(&pdev->dev), master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "irq request err\n");\r\ngoto exit_fsib;\r\n}\r\nret = snd_soc_register_platform(&pdev->dev, &fsi_soc_platform);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot snd soc register\n");\r\ngoto exit_fsib;\r\n}\r\nret = snd_soc_register_component(&pdev->dev, &fsi_soc_component,\r\nfsi_soc_dai, ARRAY_SIZE(fsi_soc_dai));\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "cannot snd component register\n");\r\ngoto exit_snd_soc;\r\n}\r\nreturn ret;\r\nexit_snd_soc:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nexit_fsib:\r\npm_runtime_disable(&pdev->dev);\r\nfsi_stream_remove(&master->fsib);\r\nexit_fsia:\r\nfsi_stream_remove(&master->fsia);\r\nreturn ret;\r\n}\r\nstatic int fsi_remove(struct platform_device *pdev)\r\n{\r\nstruct fsi_master *master;\r\nmaster = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nfsi_stream_remove(&master->fsia);\r\nfsi_stream_remove(&master->fsib);\r\nreturn 0;\r\n}\r\nstatic void __fsi_suspend(struct fsi_priv *fsi,\r\nstruct fsi_stream *io,\r\nstruct device *dev)\r\n{\r\nif (!fsi_stream_is_working(fsi, io))\r\nreturn;\r\nfsi_stream_stop(fsi, io);\r\nfsi_hw_shutdown(fsi, dev);\r\n}\r\nstatic void __fsi_resume(struct fsi_priv *fsi,\r\nstruct fsi_stream *io,\r\nstruct device *dev)\r\n{\r\nif (!fsi_stream_is_working(fsi, io))\r\nreturn;\r\nfsi_hw_startup(fsi, io, dev);\r\nfsi_stream_start(fsi, io);\r\n}\r\nstatic int fsi_suspend(struct device *dev)\r\n{\r\nstruct fsi_master *master = dev_get_drvdata(dev);\r\nstruct fsi_priv *fsia = &master->fsia;\r\nstruct fsi_priv *fsib = &master->fsib;\r\n__fsi_suspend(fsia, &fsia->playback, dev);\r\n__fsi_suspend(fsia, &fsia->capture, dev);\r\n__fsi_suspend(fsib, &fsib->playback, dev);\r\n__fsi_suspend(fsib, &fsib->capture, dev);\r\nreturn 0;\r\n}\r\nstatic int fsi_resume(struct device *dev)\r\n{\r\nstruct fsi_master *master = dev_get_drvdata(dev);\r\nstruct fsi_priv *fsia = &master->fsia;\r\nstruct fsi_priv *fsib = &master->fsib;\r\n__fsi_resume(fsia, &fsia->playback, dev);\r\n__fsi_resume(fsia, &fsia->capture, dev);\r\n__fsi_resume(fsib, &fsib->playback, dev);\r\n__fsi_resume(fsib, &fsib->capture, dev);\r\nreturn 0;\r\n}
