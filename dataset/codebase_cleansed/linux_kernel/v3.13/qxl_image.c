static int\r\nqxl_allocate_chunk(struct qxl_device *qdev,\r\nstruct qxl_release *release,\r\nstruct qxl_drm_image *image,\r\nunsigned int chunk_size)\r\n{\r\nstruct qxl_drm_chunk *chunk;\r\nint ret;\r\nchunk = kmalloc(sizeof(struct qxl_drm_chunk), GFP_KERNEL);\r\nif (!chunk)\r\nreturn -ENOMEM;\r\nret = qxl_alloc_bo_reserved(qdev, release, chunk_size, &chunk->bo);\r\nif (ret) {\r\nkfree(chunk);\r\nreturn ret;\r\n}\r\nlist_add_tail(&chunk->head, &image->chunk_list);\r\nreturn 0;\r\n}\r\nint\r\nqxl_image_alloc_objects(struct qxl_device *qdev,\r\nstruct qxl_release *release,\r\nstruct qxl_drm_image **image_ptr,\r\nint height, int stride)\r\n{\r\nstruct qxl_drm_image *image;\r\nint ret;\r\nimage = kmalloc(sizeof(struct qxl_drm_image), GFP_KERNEL);\r\nif (!image)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&image->chunk_list);\r\nret = qxl_alloc_bo_reserved(qdev, release, sizeof(struct qxl_image), &image->bo);\r\nif (ret) {\r\nkfree(image);\r\nreturn ret;\r\n}\r\nret = qxl_allocate_chunk(qdev, release, image, sizeof(struct qxl_data_chunk) + stride * height);\r\nif (ret) {\r\nqxl_bo_unref(&image->bo);\r\nkfree(image);\r\nreturn ret;\r\n}\r\n*image_ptr = image;\r\nreturn 0;\r\n}\r\nvoid qxl_image_free_objects(struct qxl_device *qdev, struct qxl_drm_image *dimage)\r\n{\r\nstruct qxl_drm_chunk *chunk, *tmp;\r\nlist_for_each_entry_safe(chunk, tmp, &dimage->chunk_list, head) {\r\nqxl_bo_unref(&chunk->bo);\r\nkfree(chunk);\r\n}\r\nqxl_bo_unref(&dimage->bo);\r\nkfree(dimage);\r\n}\r\nstatic int\r\nqxl_image_init_helper(struct qxl_device *qdev,\r\nstruct qxl_release *release,\r\nstruct qxl_drm_image *dimage,\r\nconst uint8_t *data,\r\nint width, int height,\r\nint depth, unsigned int hash,\r\nint stride)\r\n{\r\nstruct qxl_drm_chunk *drv_chunk;\r\nstruct qxl_image *image;\r\nstruct qxl_data_chunk *chunk;\r\nint i;\r\nint chunk_stride;\r\nint linesize = width * depth / 8;\r\nstruct qxl_bo *chunk_bo, *image_bo;\r\nvoid *ptr;\r\ndrv_chunk = list_first_entry(&dimage->chunk_list, struct qxl_drm_chunk, head);\r\nchunk_bo = drv_chunk->bo;\r\nchunk_stride = stride;\r\nptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, 0);\r\nchunk = ptr;\r\nchunk->data_size = height * chunk_stride;\r\nchunk->prev_chunk = 0;\r\nchunk->next_chunk = 0;\r\nqxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);\r\n{\r\nvoid *k_data, *i_data;\r\nint remain;\r\nint page;\r\nint size;\r\nif (stride == linesize && chunk_stride == stride) {\r\nremain = linesize * height;\r\npage = 0;\r\ni_data = (void *)data;\r\nwhile (remain > 0) {\r\nptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, page << PAGE_SHIFT);\r\nif (page == 0) {\r\nchunk = ptr;\r\nk_data = chunk->data;\r\nsize = PAGE_SIZE - offsetof(struct qxl_data_chunk, data);\r\n} else {\r\nk_data = ptr;\r\nsize = PAGE_SIZE;\r\n}\r\nsize = min(size, remain);\r\nmemcpy(k_data, i_data, size);\r\nqxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);\r\ni_data += size;\r\nremain -= size;\r\npage++;\r\n}\r\n} else {\r\nunsigned page_base, page_offset, out_offset;\r\nfor (i = 0 ; i < height ; ++i) {\r\ni_data = (void *)data + i * stride;\r\nremain = linesize;\r\nout_offset = offsetof(struct qxl_data_chunk, data) + i * chunk_stride;\r\nwhile (remain > 0) {\r\npage_base = out_offset & PAGE_MASK;\r\npage_offset = offset_in_page(out_offset);\r\nsize = min((int)(PAGE_SIZE - page_offset), remain);\r\nptr = qxl_bo_kmap_atomic_page(qdev, chunk_bo, page_base);\r\nk_data = ptr + page_offset;\r\nmemcpy(k_data, i_data, size);\r\nqxl_bo_kunmap_atomic_page(qdev, chunk_bo, ptr);\r\nremain -= size;\r\ni_data += size;\r\nout_offset += size;\r\n}\r\n}\r\n}\r\n}\r\nqxl_bo_kunmap(chunk_bo);\r\nimage_bo = dimage->bo;\r\nptr = qxl_bo_kmap_atomic_page(qdev, image_bo, 0);\r\nimage = ptr;\r\nimage->descriptor.id = 0;\r\nimage->descriptor.type = SPICE_IMAGE_TYPE_BITMAP;\r\nimage->descriptor.flags = 0;\r\nimage->descriptor.width = width;\r\nimage->descriptor.height = height;\r\nswitch (depth) {\r\ncase 1:\r\nimage->u.bitmap.format = SPICE_BITMAP_FMT_1BIT_BE;\r\nbreak;\r\ncase 24:\r\nimage->u.bitmap.format = SPICE_BITMAP_FMT_24BIT;\r\nbreak;\r\ncase 32:\r\nimage->u.bitmap.format = SPICE_BITMAP_FMT_32BIT;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported image bit depth\n");\r\nreturn -EINVAL;\r\n}\r\nimage->u.bitmap.flags = QXL_BITMAP_TOP_DOWN;\r\nimage->u.bitmap.x = width;\r\nimage->u.bitmap.y = height;\r\nimage->u.bitmap.stride = chunk_stride;\r\nimage->u.bitmap.palette = 0;\r\nimage->u.bitmap.data = qxl_bo_physical_address(qdev, chunk_bo, 0);\r\nqxl_bo_kunmap_atomic_page(qdev, image_bo, ptr);\r\nreturn 0;\r\n}\r\nint qxl_image_init(struct qxl_device *qdev,\r\nstruct qxl_release *release,\r\nstruct qxl_drm_image *dimage,\r\nconst uint8_t *data,\r\nint x, int y, int width, int height,\r\nint depth, int stride)\r\n{\r\ndata += y * stride + x * (depth / 8);\r\nreturn qxl_image_init_helper(qdev, release, dimage, data,\r\nwidth, height, depth, 0, stride);\r\n}
