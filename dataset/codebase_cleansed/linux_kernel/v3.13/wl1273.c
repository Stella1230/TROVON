static int snd_wl1273_fm_set_i2s_mode(struct wl1273_core *core,\r\nint rate, int width)\r\n{\r\nstruct device *dev = &core->client->dev;\r\nint r = 0;\r\nu16 mode;\r\ndev_dbg(dev, "rate: %d\n", rate);\r\ndev_dbg(dev, "width: %d\n", width);\r\nmutex_lock(&core->lock);\r\nmode = core->i2s_mode & ~WL1273_IS2_WIDTH & ~WL1273_IS2_RATE;\r\nswitch (rate) {\r\ncase 48000:\r\nmode |= WL1273_IS2_RATE_48K;\r\nbreak;\r\ncase 44100:\r\nmode |= WL1273_IS2_RATE_44_1K;\r\nbreak;\r\ncase 32000:\r\nmode |= WL1273_IS2_RATE_32K;\r\nbreak;\r\ncase 22050:\r\nmode |= WL1273_IS2_RATE_22_05K;\r\nbreak;\r\ncase 16000:\r\nmode |= WL1273_IS2_RATE_16K;\r\nbreak;\r\ncase 12000:\r\nmode |= WL1273_IS2_RATE_12K;\r\nbreak;\r\ncase 11025:\r\nmode |= WL1273_IS2_RATE_11_025;\r\nbreak;\r\ncase 8000:\r\nmode |= WL1273_IS2_RATE_8K;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Sampling rate: %d not supported\n", rate);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\nswitch (width) {\r\ncase 16:\r\nmode |= WL1273_IS2_WIDTH_32;\r\nbreak;\r\ncase 20:\r\nmode |= WL1273_IS2_WIDTH_40;\r\nbreak;\r\ncase 24:\r\nmode |= WL1273_IS2_WIDTH_48;\r\nbreak;\r\ncase 25:\r\nmode |= WL1273_IS2_WIDTH_50;\r\nbreak;\r\ncase 30:\r\nmode |= WL1273_IS2_WIDTH_60;\r\nbreak;\r\ncase 32:\r\nmode |= WL1273_IS2_WIDTH_64;\r\nbreak;\r\ncase 40:\r\nmode |= WL1273_IS2_WIDTH_80;\r\nbreak;\r\ncase 48:\r\nmode |= WL1273_IS2_WIDTH_96;\r\nbreak;\r\ncase 64:\r\nmode |= WL1273_IS2_WIDTH_128;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Data width: %d not supported\n", width);\r\nr = -EINVAL;\r\ngoto out;\r\n}\r\ndev_dbg(dev, "WL1273_I2S_DEF_MODE: 0x%04x\n", WL1273_I2S_DEF_MODE);\r\ndev_dbg(dev, "core->i2s_mode: 0x%04x\n", core->i2s_mode);\r\ndev_dbg(dev, "mode: 0x%04x\n", mode);\r\nif (core->i2s_mode != mode) {\r\nr = core->write(core, WL1273_I2S_MODE_CONFIG_SET, mode);\r\nif (r)\r\ngoto out;\r\ncore->i2s_mode = mode;\r\nr = core->write(core, WL1273_AUDIO_ENABLE,\r\nWL1273_AUDIO_ENABLE_I2S);\r\nif (r)\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&core->lock);\r\nreturn r;\r\n}\r\nstatic int snd_wl1273_fm_set_channel_number(struct wl1273_core *core,\r\nint channel_number)\r\n{\r\nstruct device *dev = &core->client->dev;\r\nint r = 0;\r\ndev_dbg(dev, "%s\n", __func__);\r\nmutex_lock(&core->lock);\r\nif (core->channel_number == channel_number)\r\ngoto out;\r\nif (channel_number == 1 && core->mode == WL1273_MODE_RX)\r\nr = core->write(core, WL1273_MOST_MODE_SET, WL1273_RX_MONO);\r\nelse if (channel_number == 1 && core->mode == WL1273_MODE_TX)\r\nr = core->write(core, WL1273_MONO_SET, WL1273_TX_MONO);\r\nelse if (channel_number == 2 && core->mode == WL1273_MODE_RX)\r\nr = core->write(core, WL1273_MOST_MODE_SET, WL1273_RX_STEREO);\r\nelse if (channel_number == 2 && core->mode == WL1273_MODE_TX)\r\nr = core->write(core, WL1273_MONO_SET, WL1273_TX_STEREO);\r\nelse\r\nr = -EINVAL;\r\nout:\r\nmutex_unlock(&core->lock);\r\nreturn r;\r\n}\r\nstatic int snd_wl1273_get_audio_route(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\nucontrol->value.integer.value[0] = wl1273->mode;\r\nreturn 0;\r\n}\r\nstatic int snd_wl1273_set_audio_route(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\nif (wl1273->mode == ucontrol->value.integer.value[0])\r\nreturn 0;\r\nif (codec->active)\r\nreturn -EPERM;\r\nif (ucontrol->value.integer.value[0] < 0 ||\r\nucontrol->value.integer.value[0] >= ARRAY_SIZE(wl1273_audio_route))\r\nreturn -EINVAL;\r\nwl1273->mode = ucontrol->value.integer.value[0];\r\nreturn 1;\r\n}\r\nstatic int snd_wl1273_fm_audio_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "%s: enter.\n", __func__);\r\nucontrol->value.integer.value[0] = wl1273->core->audio_mode;\r\nreturn 0;\r\n}\r\nstatic int snd_wl1273_fm_audio_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\nint val, r = 0;\r\ndev_dbg(codec->dev, "%s: enter.\n", __func__);\r\nval = ucontrol->value.integer.value[0];\r\nif (wl1273->core->audio_mode == val)\r\nreturn 0;\r\nr = wl1273->core->set_audio(wl1273->core, val);\r\nif (r < 0)\r\nreturn r;\r\nreturn 1;\r\n}\r\nstatic int snd_wl1273_fm_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "%s: enter.\n", __func__);\r\nucontrol->value.integer.value[0] = wl1273->core->volume;\r\nreturn 0;\r\n}\r\nstatic int snd_wl1273_fm_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\nint r;\r\ndev_dbg(codec->dev, "%s: enter.\n", __func__);\r\nr = wl1273->core->set_volume(wl1273->core,\r\nucontrol->value.integer.value[0]);\r\nif (r)\r\nreturn r;\r\nreturn 1;\r\n}\r\nstatic int wl1273_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\nswitch (wl1273->mode) {\r\ncase WL1273_MODE_BT:\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n8000, 8000);\r\nsnd_pcm_hw_constraint_minmax(substream->runtime,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, 1, 1);\r\nbreak;\r\ncase WL1273_MODE_FM_RX:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\npr_err("Cannot play in RX mode.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase WL1273_MODE_FM_TX:\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\npr_err("Cannot capture in TX mode.\n");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wl1273_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(dai->codec);\r\nstruct wl1273_core *core = wl1273->core;\r\nunsigned int rate, width, r;\r\nif (params_format(params) != SNDRV_PCM_FORMAT_S16_LE) {\r\npr_err("Only SNDRV_PCM_FORMAT_S16_LE supported.\n");\r\nreturn -EINVAL;\r\n}\r\nrate = params_rate(params);\r\nwidth = hw_param_interval(params, SNDRV_PCM_HW_PARAM_SAMPLE_BITS)->min;\r\nif (wl1273->mode == WL1273_MODE_BT) {\r\nif (rate != 8000) {\r\npr_err("Rate %d not supported.\n", params_rate(params));\r\nreturn -EINVAL;\r\n}\r\nif (params_channels(params) != 1) {\r\npr_err("Only mono supported.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (wl1273->mode == WL1273_MODE_FM_TX &&\r\nsubstream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\npr_err("Only playback supported with TX.\n");\r\nreturn -EINVAL;\r\n}\r\nif (wl1273->mode == WL1273_MODE_FM_RX &&\r\nsubstream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\npr_err("Only capture supported with RX.\n");\r\nreturn -EINVAL;\r\n}\r\nif (wl1273->mode != WL1273_MODE_FM_RX &&\r\nwl1273->mode != WL1273_MODE_FM_TX) {\r\npr_err("Unexpected mode: %d.\n", wl1273->mode);\r\nreturn -EINVAL;\r\n}\r\nr = snd_wl1273_fm_set_i2s_mode(core, rate, width);\r\nif (r)\r\nreturn r;\r\nwl1273->channels = params_channels(params);\r\nr = snd_wl1273_fm_set_channel_number(core, wl1273->channels);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nint wl1273_get_format(struct snd_soc_codec *codec, unsigned int *fmt)\r\n{\r\nstruct wl1273_priv *wl1273;\r\nif (codec == NULL || fmt == NULL)\r\nreturn -EINVAL;\r\nwl1273 = snd_soc_codec_get_drvdata(codec);\r\nswitch (wl1273->mode) {\r\ncase WL1273_MODE_FM_RX:\r\ncase WL1273_MODE_FM_TX:\r\n*fmt = SND_SOC_DAIFMT_I2S |\r\nSND_SOC_DAIFMT_NB_NF |\r\nSND_SOC_DAIFMT_CBM_CFM;\r\nbreak;\r\ncase WL1273_MODE_BT:\r\n*fmt = SND_SOC_DAIFMT_DSP_A |\r\nSND_SOC_DAIFMT_IB_NF |\r\nSND_SOC_DAIFMT_CBM_CFM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wl1273_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct wl1273_core **core = codec->dev->platform_data;\r\nstruct wl1273_priv *wl1273;\r\nint r;\r\ndev_dbg(codec->dev, "%s.\n", __func__);\r\nif (!core) {\r\ndev_err(codec->dev, "Platform data is missing.\n");\r\nreturn -EINVAL;\r\n}\r\nwl1273 = kzalloc(sizeof(struct wl1273_priv), GFP_KERNEL);\r\nif (wl1273 == NULL) {\r\ndev_err(codec->dev, "Cannot allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\nwl1273->mode = WL1273_MODE_BT;\r\nwl1273->core = *core;\r\nsnd_soc_codec_set_drvdata(codec, wl1273);\r\nr = snd_soc_add_codec_controls(codec, wl1273_controls,\r\nARRAY_SIZE(wl1273_controls));\r\nif (r)\r\nkfree(wl1273);\r\nreturn r;\r\n}\r\nstatic int wl1273_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct wl1273_priv *wl1273 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "%s\n", __func__);\r\nkfree(wl1273);\r\nreturn 0;\r\n}\r\nstatic int wl1273_platform_probe(struct platform_device *pdev)\r\n{\r\nreturn snd_soc_register_codec(&pdev->dev, &soc_codec_dev_wl1273,\r\n&wl1273_dai, 1);\r\n}\r\nstatic int wl1273_platform_remove(struct platform_device *pdev)\r\n{\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nreturn 0;\r\n}
