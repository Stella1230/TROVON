static int emu10k1_playback_constraints(struct snd_pcm_runtime *runtime)\r\n{\r\nint err;\r\nerr = snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_constraint_minmax(runtime, SNDRV_PCM_HW_PARAM_BUFFER_BYTES, 256, UINT_MAX);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic void dummy_systimer_rearm(struct dummy_systimer_pcm *dpcm)\r\n{\r\ndpcm->timer.expires = jiffies +\r\n(dpcm->frac_period_rest + dpcm->rate - 1) / dpcm->rate;\r\nadd_timer(&dpcm->timer);\r\n}\r\nstatic void dummy_systimer_update(struct dummy_systimer_pcm *dpcm)\r\n{\r\nunsigned long delta;\r\ndelta = jiffies - dpcm->base_time;\r\nif (!delta)\r\nreturn;\r\ndpcm->base_time += delta;\r\ndelta *= dpcm->rate;\r\ndpcm->frac_pos += delta;\r\nwhile (dpcm->frac_pos >= dpcm->frac_buffer_size)\r\ndpcm->frac_pos -= dpcm->frac_buffer_size;\r\nwhile (dpcm->frac_period_rest <= delta) {\r\ndpcm->elapsed++;\r\ndpcm->frac_period_rest += dpcm->frac_period_size;\r\n}\r\ndpcm->frac_period_rest -= delta;\r\n}\r\nstatic int dummy_systimer_start(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_systimer_pcm *dpcm = substream->runtime->private_data;\r\nspin_lock(&dpcm->lock);\r\ndpcm->base_time = jiffies;\r\ndummy_systimer_rearm(dpcm);\r\nspin_unlock(&dpcm->lock);\r\nreturn 0;\r\n}\r\nstatic int dummy_systimer_stop(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_systimer_pcm *dpcm = substream->runtime->private_data;\r\nspin_lock(&dpcm->lock);\r\ndel_timer(&dpcm->timer);\r\nspin_unlock(&dpcm->lock);\r\nreturn 0;\r\n}\r\nstatic int dummy_systimer_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dummy_systimer_pcm *dpcm = runtime->private_data;\r\ndpcm->frac_pos = 0;\r\ndpcm->rate = runtime->rate;\r\ndpcm->frac_buffer_size = runtime->buffer_size * HZ;\r\ndpcm->frac_period_size = runtime->period_size * HZ;\r\ndpcm->frac_period_rest = dpcm->frac_period_size;\r\ndpcm->elapsed = 0;\r\nreturn 0;\r\n}\r\nstatic void dummy_systimer_callback(unsigned long data)\r\n{\r\nstruct dummy_systimer_pcm *dpcm = (struct dummy_systimer_pcm *)data;\r\nunsigned long flags;\r\nint elapsed = 0;\r\nspin_lock_irqsave(&dpcm->lock, flags);\r\ndummy_systimer_update(dpcm);\r\ndummy_systimer_rearm(dpcm);\r\nelapsed = dpcm->elapsed;\r\ndpcm->elapsed = 0;\r\nspin_unlock_irqrestore(&dpcm->lock, flags);\r\nif (elapsed)\r\nsnd_pcm_period_elapsed(dpcm->substream);\r\n}\r\nstatic snd_pcm_uframes_t\r\ndummy_systimer_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_systimer_pcm *dpcm = substream->runtime->private_data;\r\nsnd_pcm_uframes_t pos;\r\nspin_lock(&dpcm->lock);\r\ndummy_systimer_update(dpcm);\r\npos = dpcm->frac_pos / HZ;\r\nspin_unlock(&dpcm->lock);\r\nreturn pos;\r\n}\r\nstatic int dummy_systimer_create(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_systimer_pcm *dpcm;\r\ndpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\r\nif (!dpcm)\r\nreturn -ENOMEM;\r\nsubstream->runtime->private_data = dpcm;\r\ninit_timer(&dpcm->timer);\r\ndpcm->timer.data = (unsigned long) dpcm;\r\ndpcm->timer.function = dummy_systimer_callback;\r\nspin_lock_init(&dpcm->lock);\r\ndpcm->substream = substream;\r\nreturn 0;\r\n}\r\nstatic void dummy_systimer_free(struct snd_pcm_substream *substream)\r\n{\r\nkfree(substream->runtime->private_data);\r\n}\r\nstatic void dummy_hrtimer_pcm_elapsed(unsigned long priv)\r\n{\r\nstruct dummy_hrtimer_pcm *dpcm = (struct dummy_hrtimer_pcm *)priv;\r\nif (atomic_read(&dpcm->running))\r\nsnd_pcm_period_elapsed(dpcm->substream);\r\n}\r\nstatic enum hrtimer_restart dummy_hrtimer_callback(struct hrtimer *timer)\r\n{\r\nstruct dummy_hrtimer_pcm *dpcm;\r\ndpcm = container_of(timer, struct dummy_hrtimer_pcm, timer);\r\nif (!atomic_read(&dpcm->running))\r\nreturn HRTIMER_NORESTART;\r\ntasklet_schedule(&dpcm->tasklet);\r\nhrtimer_forward_now(timer, dpcm->period_time);\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic int dummy_hrtimer_start(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;\r\ndpcm->base_time = hrtimer_cb_get_time(&dpcm->timer);\r\nhrtimer_start(&dpcm->timer, dpcm->period_time, HRTIMER_MODE_REL);\r\natomic_set(&dpcm->running, 1);\r\nreturn 0;\r\n}\r\nstatic int dummy_hrtimer_stop(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;\r\natomic_set(&dpcm->running, 0);\r\nhrtimer_cancel(&dpcm->timer);\r\nreturn 0;\r\n}\r\nstatic inline void dummy_hrtimer_sync(struct dummy_hrtimer_pcm *dpcm)\r\n{\r\ntasklet_kill(&dpcm->tasklet);\r\n}\r\nstatic snd_pcm_uframes_t\r\ndummy_hrtimer_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dummy_hrtimer_pcm *dpcm = runtime->private_data;\r\nu64 delta;\r\nu32 pos;\r\ndelta = ktime_us_delta(hrtimer_cb_get_time(&dpcm->timer),\r\ndpcm->base_time);\r\ndelta = div_u64(delta * runtime->rate + 999999, 1000000);\r\ndiv_u64_rem(delta, runtime->buffer_size, &pos);\r\nreturn pos;\r\n}\r\nstatic int dummy_hrtimer_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct dummy_hrtimer_pcm *dpcm = runtime->private_data;\r\nunsigned int period, rate;\r\nlong sec;\r\nunsigned long nsecs;\r\ndummy_hrtimer_sync(dpcm);\r\nperiod = runtime->period_size;\r\nrate = runtime->rate;\r\nsec = period / rate;\r\nperiod %= rate;\r\nnsecs = div_u64((u64)period * 1000000000UL + rate - 1, rate);\r\ndpcm->period_time = ktime_set(sec, nsecs);\r\nreturn 0;\r\n}\r\nstatic int dummy_hrtimer_create(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_hrtimer_pcm *dpcm;\r\ndpcm = kzalloc(sizeof(*dpcm), GFP_KERNEL);\r\nif (!dpcm)\r\nreturn -ENOMEM;\r\nsubstream->runtime->private_data = dpcm;\r\nhrtimer_init(&dpcm->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\ndpcm->timer.function = dummy_hrtimer_callback;\r\ndpcm->substream = substream;\r\natomic_set(&dpcm->running, 0);\r\ntasklet_init(&dpcm->tasklet, dummy_hrtimer_pcm_elapsed,\r\n(unsigned long)dpcm);\r\nreturn 0;\r\n}\r\nstatic void dummy_hrtimer_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct dummy_hrtimer_pcm *dpcm = substream->runtime->private_data;\r\ndummy_hrtimer_sync(dpcm);\r\nkfree(dpcm);\r\n}\r\nstatic int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dummy *dummy = snd_pcm_substream_chip(substream);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nreturn dummy->timer_ops->start(substream);\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nreturn dummy->timer_ops->stop(substream);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int dummy_pcm_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dummy *dummy = snd_pcm_substream_chip(substream);\r\nreturn dummy->timer_ops->prepare(substream);\r\n}\r\nstatic snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dummy *dummy = snd_pcm_substream_chip(substream);\r\nreturn dummy->timer_ops->pointer(substream);\r\n}\r\nstatic int dummy_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nif (fake_buffer) {\r\nsubstream->runtime->dma_bytes = params_buffer_bytes(hw_params);\r\nreturn 0;\r\n}\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int dummy_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nif (fake_buffer)\r\nreturn 0;\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int dummy_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dummy *dummy = snd_pcm_substream_chip(substream);\r\nstruct dummy_model *model = dummy->model;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\ndummy->timer_ops = &dummy_systimer_ops;\r\n#ifdef CONFIG_HIGH_RES_TIMERS\r\nif (hrtimer)\r\ndummy->timer_ops = &dummy_hrtimer_ops;\r\n#endif\r\nerr = dummy->timer_ops->create(substream);\r\nif (err < 0)\r\nreturn err;\r\nruntime->hw = dummy->pcm_hw;\r\nif (substream->pcm->device & 1) {\r\nruntime->hw.info &= ~SNDRV_PCM_INFO_INTERLEAVED;\r\nruntime->hw.info |= SNDRV_PCM_INFO_NONINTERLEAVED;\r\n}\r\nif (substream->pcm->device & 2)\r\nruntime->hw.info &= ~(SNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID);\r\nif (model == NULL)\r\nreturn 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (model->playback_constraints)\r\nerr = model->playback_constraints(substream->runtime);\r\n} else {\r\nif (model->capture_constraints)\r\nerr = model->capture_constraints(substream->runtime);\r\n}\r\nif (err < 0) {\r\ndummy->timer_ops->free(substream);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dummy_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dummy *dummy = snd_pcm_substream_chip(substream);\r\ndummy->timer_ops->free(substream);\r\nreturn 0;\r\n}\r\nstatic void free_fake_buffer(void)\r\n{\r\nif (fake_buffer) {\r\nint i;\r\nfor (i = 0; i < 2; i++)\r\nif (dummy_page[i]) {\r\nfree_page((unsigned long)dummy_page[i]);\r\ndummy_page[i] = NULL;\r\n}\r\n}\r\n}\r\nstatic int alloc_fake_buffer(void)\r\n{\r\nint i;\r\nif (!fake_buffer)\r\nreturn 0;\r\nfor (i = 0; i < 2; i++) {\r\ndummy_page[i] = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!dummy_page[i]) {\r\nfree_fake_buffer();\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dummy_pcm_copy(struct snd_pcm_substream *substream,\r\nint channel, snd_pcm_uframes_t pos,\r\nvoid __user *dst, snd_pcm_uframes_t count)\r\n{\r\nreturn 0;\r\n}\r\nstatic int dummy_pcm_silence(struct snd_pcm_substream *substream,\r\nint channel, snd_pcm_uframes_t pos,\r\nsnd_pcm_uframes_t count)\r\n{\r\nreturn 0;\r\n}\r\nstatic struct page *dummy_pcm_page(struct snd_pcm_substream *substream,\r\nunsigned long offset)\r\n{\r\nreturn virt_to_page(dummy_page[substream->stream]);\r\n}\r\nstatic int snd_card_dummy_pcm(struct snd_dummy *dummy, int device,\r\nint substreams)\r\n{\r\nstruct snd_pcm *pcm;\r\nstruct snd_pcm_ops *ops;\r\nint err;\r\nerr = snd_pcm_new(dummy->card, "Dummy PCM", device,\r\nsubstreams, substreams, &pcm);\r\nif (err < 0)\r\nreturn err;\r\ndummy->pcm = pcm;\r\nif (fake_buffer)\r\nops = &dummy_pcm_ops_no_buf;\r\nelse\r\nops = &dummy_pcm_ops;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, ops);\r\npcm->private_data = dummy;\r\npcm->info_flags = 0;\r\nstrcpy(pcm->name, "Dummy PCM");\r\nif (!fake_buffer) {\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL),\r\n0, 64*1024);\r\n}\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_volume_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = -50;\r\nuinfo->value.integer.max = 100;\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\r\nint addr = kcontrol->private_value;\r\nspin_lock_irq(&dummy->mixer_lock);\r\nucontrol->value.integer.value[0] = dummy->mixer_volume[addr][0];\r\nucontrol->value.integer.value[1] = dummy->mixer_volume[addr][1];\r\nspin_unlock_irq(&dummy->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\r\nint change, addr = kcontrol->private_value;\r\nint left, right;\r\nleft = ucontrol->value.integer.value[0];\r\nif (left < -50)\r\nleft = -50;\r\nif (left > 100)\r\nleft = 100;\r\nright = ucontrol->value.integer.value[1];\r\nif (right < -50)\r\nright = -50;\r\nif (right > 100)\r\nright = 100;\r\nspin_lock_irq(&dummy->mixer_lock);\r\nchange = dummy->mixer_volume[addr][0] != left ||\r\ndummy->mixer_volume[addr][1] != right;\r\ndummy->mixer_volume[addr][0] = left;\r\ndummy->mixer_volume[addr][1] = right;\r\nspin_unlock_irq(&dummy->mixer_lock);\r\nreturn change;\r\n}\r\nstatic int snd_dummy_capsrc_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\r\nint addr = kcontrol->private_value;\r\nspin_lock_irq(&dummy->mixer_lock);\r\nucontrol->value.integer.value[0] = dummy->capture_source[addr][0];\r\nucontrol->value.integer.value[1] = dummy->capture_source[addr][1];\r\nspin_unlock_irq(&dummy->mixer_lock);\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_capsrc_put(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\r\nint change, addr = kcontrol->private_value;\r\nint left, right;\r\nleft = ucontrol->value.integer.value[0] & 1;\r\nright = ucontrol->value.integer.value[1] & 1;\r\nspin_lock_irq(&dummy->mixer_lock);\r\nchange = dummy->capture_source[addr][0] != left &&\r\ndummy->capture_source[addr][1] != right;\r\ndummy->capture_source[addr][0] = left;\r\ndummy->capture_source[addr][1] = right;\r\nspin_unlock_irq(&dummy->mixer_lock);\r\nreturn change;\r\n}\r\nstatic int snd_dummy_iobox_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nconst char *const names[] = { "None", "CD Player" };\r\nreturn snd_ctl_enum_info(info, 1, 2, names);\r\n}\r\nstatic int snd_dummy_iobox_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\r\nvalue->value.enumerated.item[0] = dummy->iobox;\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_iobox_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_dummy *dummy = snd_kcontrol_chip(kcontrol);\r\nint changed;\r\nif (value->value.enumerated.item[0] > 1)\r\nreturn -EINVAL;\r\nchanged = value->value.enumerated.item[0] != dummy->iobox;\r\nif (changed) {\r\ndummy->iobox = value->value.enumerated.item[0];\r\nif (dummy->iobox) {\r\ndummy->cd_volume_ctl->vd[0].access &=\r\n~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\ndummy->cd_switch_ctl->vd[0].access &=\r\n~SNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\n} else {\r\ndummy->cd_volume_ctl->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\ndummy->cd_switch_ctl->vd[0].access |=\r\nSNDRV_CTL_ELEM_ACCESS_INACTIVE;\r\n}\r\nsnd_ctl_notify(dummy->card, SNDRV_CTL_EVENT_MASK_INFO,\r\n&dummy->cd_volume_ctl->id);\r\nsnd_ctl_notify(dummy->card, SNDRV_CTL_EVENT_MASK_INFO,\r\n&dummy->cd_switch_ctl->id);\r\n}\r\nreturn changed;\r\n}\r\nstatic int snd_card_dummy_new_mixer(struct snd_dummy *dummy)\r\n{\r\nstruct snd_card *card = dummy->card;\r\nstruct snd_kcontrol *kcontrol;\r\nunsigned int idx;\r\nint err;\r\nspin_lock_init(&dummy->mixer_lock);\r\nstrcpy(card->mixername, "Dummy Mixer");\r\ndummy->iobox = 1;\r\nfor (idx = 0; idx < ARRAY_SIZE(snd_dummy_controls); idx++) {\r\nkcontrol = snd_ctl_new1(&snd_dummy_controls[idx], dummy);\r\nerr = snd_ctl_add(card, kcontrol);\r\nif (err < 0)\r\nreturn err;\r\nif (!strcmp(kcontrol->id.name, "CD Volume"))\r\ndummy->cd_volume_ctl = kcontrol;\r\nelse if (!strcmp(kcontrol->id.name, "CD Capture Switch"))\r\ndummy->cd_switch_ctl = kcontrol;\r\n}\r\nreturn 0;\r\n}\r\nstatic void print_formats(struct snd_dummy *dummy,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nint i;\r\nfor (i = 0; i < SNDRV_PCM_FORMAT_LAST; i++) {\r\nif (dummy->pcm_hw.formats & (1ULL << i))\r\nsnd_iprintf(buffer, " %s", snd_pcm_format_name(i));\r\n}\r\n}\r\nstatic void print_rates(struct snd_dummy *dummy,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstatic int rates[] = {\r\n5512, 8000, 11025, 16000, 22050, 32000, 44100, 48000,\r\n64000, 88200, 96000, 176400, 192000,\r\n};\r\nint i;\r\nif (dummy->pcm_hw.rates & SNDRV_PCM_RATE_CONTINUOUS)\r\nsnd_iprintf(buffer, " continuous");\r\nif (dummy->pcm_hw.rates & SNDRV_PCM_RATE_KNOT)\r\nsnd_iprintf(buffer, " knot");\r\nfor (i = 0; i < ARRAY_SIZE(rates); i++)\r\nif (dummy->pcm_hw.rates & (1 << i))\r\nsnd_iprintf(buffer, " %d", rates[i]);\r\n}\r\nstatic void dummy_proc_read(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_dummy *dummy = entry->private_data;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fields); i++) {\r\nsnd_iprintf(buffer, "%s ", fields[i].name);\r\nif (fields[i].size == sizeof(int))\r\nsnd_iprintf(buffer, fields[i].format,\r\n*get_dummy_int_ptr(dummy, fields[i].offset));\r\nelse\r\nsnd_iprintf(buffer, fields[i].format,\r\n*get_dummy_ll_ptr(dummy, fields[i].offset));\r\nif (!strcmp(fields[i].name, "formats"))\r\nprint_formats(dummy, buffer);\r\nelse if (!strcmp(fields[i].name, "rates"))\r\nprint_rates(dummy, buffer);\r\nsnd_iprintf(buffer, "\n");\r\n}\r\n}\r\nstatic void dummy_proc_write(struct snd_info_entry *entry,\r\nstruct snd_info_buffer *buffer)\r\n{\r\nstruct snd_dummy *dummy = entry->private_data;\r\nchar line[64];\r\nwhile (!snd_info_get_line(buffer, line, sizeof(line))) {\r\nchar item[20];\r\nconst char *ptr;\r\nunsigned long long val;\r\nint i;\r\nptr = snd_info_get_str(item, line, sizeof(item));\r\nfor (i = 0; i < ARRAY_SIZE(fields); i++) {\r\nif (!strcmp(item, fields[i].name))\r\nbreak;\r\n}\r\nif (i >= ARRAY_SIZE(fields))\r\ncontinue;\r\nsnd_info_get_str(item, ptr, sizeof(item));\r\nif (kstrtoull(item, 0, &val))\r\ncontinue;\r\nif (fields[i].size == sizeof(int))\r\n*get_dummy_int_ptr(dummy, fields[i].offset) = val;\r\nelse\r\n*get_dummy_ll_ptr(dummy, fields[i].offset) = val;\r\n}\r\n}\r\nstatic void dummy_proc_init(struct snd_dummy *chip)\r\n{\r\nstruct snd_info_entry *entry;\r\nif (!snd_card_proc_new(chip->card, "dummy_pcm", &entry)) {\r\nsnd_info_set_text_ops(entry, chip, dummy_proc_read);\r\nentry->c.text.write = dummy_proc_write;\r\nentry->mode |= S_IWUSR;\r\nentry->private_data = chip;\r\n}\r\n}\r\nstatic int snd_dummy_probe(struct platform_device *devptr)\r\n{\r\nstruct snd_card *card;\r\nstruct snd_dummy *dummy;\r\nstruct dummy_model *m = NULL, **mdl;\r\nint idx, err;\r\nint dev = devptr->id;\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE,\r\nsizeof(struct snd_dummy), &card);\r\nif (err < 0)\r\nreturn err;\r\ndummy = card->private_data;\r\ndummy->card = card;\r\nfor (mdl = dummy_models; *mdl && model[dev]; mdl++) {\r\nif (strcmp(model[dev], (*mdl)->name) == 0) {\r\nprintk(KERN_INFO\r\n"snd-dummy: Using model '%s' for card %i\n",\r\n(*mdl)->name, card->number);\r\nm = dummy->model = *mdl;\r\nbreak;\r\n}\r\n}\r\nfor (idx = 0; idx < MAX_PCM_DEVICES && idx < pcm_devs[dev]; idx++) {\r\nif (pcm_substreams[dev] < 1)\r\npcm_substreams[dev] = 1;\r\nif (pcm_substreams[dev] > MAX_PCM_SUBSTREAMS)\r\npcm_substreams[dev] = MAX_PCM_SUBSTREAMS;\r\nerr = snd_card_dummy_pcm(dummy, idx, pcm_substreams[dev]);\r\nif (err < 0)\r\ngoto __nodev;\r\n}\r\ndummy->pcm_hw = dummy_pcm_hardware;\r\nif (m) {\r\nif (m->formats)\r\ndummy->pcm_hw.formats = m->formats;\r\nif (m->buffer_bytes_max)\r\ndummy->pcm_hw.buffer_bytes_max = m->buffer_bytes_max;\r\nif (m->period_bytes_min)\r\ndummy->pcm_hw.period_bytes_min = m->period_bytes_min;\r\nif (m->period_bytes_max)\r\ndummy->pcm_hw.period_bytes_max = m->period_bytes_max;\r\nif (m->periods_min)\r\ndummy->pcm_hw.periods_min = m->periods_min;\r\nif (m->periods_max)\r\ndummy->pcm_hw.periods_max = m->periods_max;\r\nif (m->rates)\r\ndummy->pcm_hw.rates = m->rates;\r\nif (m->rate_min)\r\ndummy->pcm_hw.rate_min = m->rate_min;\r\nif (m->rate_max)\r\ndummy->pcm_hw.rate_max = m->rate_max;\r\nif (m->channels_min)\r\ndummy->pcm_hw.channels_min = m->channels_min;\r\nif (m->channels_max)\r\ndummy->pcm_hw.channels_max = m->channels_max;\r\n}\r\nerr = snd_card_dummy_new_mixer(dummy);\r\nif (err < 0)\r\ngoto __nodev;\r\nstrcpy(card->driver, "Dummy");\r\nstrcpy(card->shortname, "Dummy");\r\nsprintf(card->longname, "Dummy %i", dev + 1);\r\ndummy_proc_init(dummy);\r\nsnd_card_set_dev(card, &devptr->dev);\r\nerr = snd_card_register(card);\r\nif (err == 0) {\r\nplatform_set_drvdata(devptr, card);\r\nreturn 0;\r\n}\r\n__nodev:\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\nstatic int snd_dummy_remove(struct platform_device *devptr)\r\n{\r\nsnd_card_free(platform_get_drvdata(devptr));\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_suspend(struct device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nstruct snd_dummy *dummy = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(dummy->pcm);\r\nreturn 0;\r\n}\r\nstatic int snd_dummy_resume(struct device *pdev)\r\n{\r\nstruct snd_card *card = dev_get_drvdata(pdev);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic void snd_dummy_unregister_all(void)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(devices); ++i)\r\nplatform_device_unregister(devices[i]);\r\nplatform_driver_unregister(&snd_dummy_driver);\r\nfree_fake_buffer();\r\n}\r\nstatic int __init alsa_card_dummy_init(void)\r\n{\r\nint i, cards, err;\r\nerr = platform_driver_register(&snd_dummy_driver);\r\nif (err < 0)\r\nreturn err;\r\nerr = alloc_fake_buffer();\r\nif (err < 0) {\r\nplatform_driver_unregister(&snd_dummy_driver);\r\nreturn err;\r\n}\r\ncards = 0;\r\nfor (i = 0; i < SNDRV_CARDS; i++) {\r\nstruct platform_device *device;\r\nif (! enable[i])\r\ncontinue;\r\ndevice = platform_device_register_simple(SND_DUMMY_DRIVER,\r\ni, NULL, 0);\r\nif (IS_ERR(device))\r\ncontinue;\r\nif (!platform_get_drvdata(device)) {\r\nplatform_device_unregister(device);\r\ncontinue;\r\n}\r\ndevices[i] = device;\r\ncards++;\r\n}\r\nif (!cards) {\r\n#ifdef MODULE\r\nprintk(KERN_ERR "Dummy soundcard not found or device busy\n");\r\n#endif\r\nsnd_dummy_unregister_all();\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit alsa_card_dummy_exit(void)\r\n{\r\nsnd_dummy_unregister_all();\r\n}
