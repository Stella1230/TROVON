static inline u32 snd_als300_gcr_read(unsigned long port, unsigned short reg)\r\n{\r\noutb(reg, port+GCR_INDEX);\r\nreturn inl(port+GCR_DATA);\r\n}\r\nstatic inline void snd_als300_gcr_write(unsigned long port,\r\nunsigned short reg, u32 val)\r\n{\r\noutb(reg, port+GCR_INDEX);\r\noutl(val, port+GCR_DATA);\r\n}\r\nstatic void snd_als300_set_irq_flag(struct snd_als300 *chip, int cmd)\r\n{\r\nu32 tmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);\r\nsnd_als300_dbgcallenter();\r\nif (((chip->revision > 5 || chip->chip_type == DEVICE_ALS300_PLUS) ^\r\n(cmd == IRQ_ENABLE)) == 0)\r\ntmp |= IRQ_SET_BIT;\r\nelse\r\ntmp &= ~IRQ_SET_BIT;\r\nsnd_als300_gcr_write(chip->port, MISC_CONTROL, tmp);\r\nsnd_als300_dbgcallleave();\r\n}\r\nstatic int snd_als300_free(struct snd_als300 *chip)\r\n{\r\nsnd_als300_dbgcallenter();\r\nsnd_als300_set_irq_flag(chip, IRQ_DISABLE);\r\nif (chip->irq >= 0)\r\nfree_irq(chip->irq, chip);\r\npci_release_regions(chip->pci);\r\npci_disable_device(chip->pci);\r\nkfree(chip);\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_dev_free(struct snd_device *device)\r\n{\r\nstruct snd_als300 *chip = device->device_data;\r\nreturn snd_als300_free(chip);\r\n}\r\nstatic irqreturn_t snd_als300_interrupt(int irq, void *dev_id)\r\n{\r\nu8 status;\r\nstruct snd_als300 *chip = dev_id;\r\nstruct snd_als300_substream_data *data;\r\nstatus = inb(chip->port+ALS300_IRQ_STATUS);\r\nif (!status)\r\nreturn IRQ_NONE;\r\noutb(status, chip->port+ALS300_IRQ_STATUS);\r\nif (status & IRQ_PLAYBACK) {\r\nif (chip->pcm && chip->playback_substream) {\r\ndata = chip->playback_substream->runtime->private_data;\r\ndata->period_flipflop ^= 1;\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nsnd_als300_dbgplay("IRQ_PLAYBACK\n");\r\n}\r\n}\r\nif (status & IRQ_CAPTURE) {\r\nif (chip->pcm && chip->capture_substream) {\r\ndata = chip->capture_substream->runtime->private_data;\r\ndata->period_flipflop ^= 1;\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nsnd_als300_dbgplay("IRQ_CAPTURE\n");\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t snd_als300plus_interrupt(int irq, void *dev_id)\r\n{\r\nu8 general, mpu, dram;\r\nstruct snd_als300 *chip = dev_id;\r\nstruct snd_als300_substream_data *data;\r\ngeneral = inb(chip->port+ALS300P_IRQ_STATUS);\r\nmpu = inb(chip->port+MPU_IRQ_STATUS);\r\ndram = inb(chip->port+ALS300P_DRAM_IRQ_STATUS);\r\nif ((general == 0) && ((mpu & 0x80) == 0) && ((dram & 0x01) == 0))\r\nreturn IRQ_NONE;\r\nif (general & IRQ_PLAYBACK) {\r\nif (chip->pcm && chip->playback_substream) {\r\noutb(IRQ_PLAYBACK, chip->port+ALS300P_IRQ_STATUS);\r\ndata = chip->playback_substream->runtime->private_data;\r\ndata->period_flipflop ^= 1;\r\nsnd_pcm_period_elapsed(chip->playback_substream);\r\nsnd_als300_dbgplay("IRQ_PLAYBACK\n");\r\n}\r\n}\r\nif (general & IRQ_CAPTURE) {\r\nif (chip->pcm && chip->capture_substream) {\r\noutb(IRQ_CAPTURE, chip->port+ALS300P_IRQ_STATUS);\r\ndata = chip->capture_substream->runtime->private_data;\r\ndata->period_flipflop ^= 1;\r\nsnd_pcm_period_elapsed(chip->capture_substream);\r\nsnd_als300_dbgplay("IRQ_CAPTURE\n");\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void snd_als300_remove(struct pci_dev *pci)\r\n{\r\nsnd_als300_dbgcallenter();\r\nsnd_card_free(pci_get_drvdata(pci));\r\nsnd_als300_dbgcallleave();\r\n}\r\nstatic unsigned short snd_als300_ac97_read(struct snd_ac97 *ac97,\r\nunsigned short reg)\r\n{\r\nint i;\r\nstruct snd_als300 *chip = ac97->private_data;\r\nfor (i = 0; i < 1000; i++) {\r\nif ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\noutl((reg << 24) | (1 << 31), chip->port+AC97_ACCESS);\r\nfor (i = 0; i < 1000; i++) {\r\nif ((inb(chip->port+AC97_STATUS) & (AC97_DATA_AVAIL)) != 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nreturn inw(chip->port+AC97_READ);\r\n}\r\nstatic void snd_als300_ac97_write(struct snd_ac97 *ac97,\r\nunsigned short reg, unsigned short val)\r\n{\r\nint i;\r\nstruct snd_als300 *chip = ac97->private_data;\r\nfor (i = 0; i < 1000; i++) {\r\nif ((inb(chip->port+AC97_STATUS) & (AC97_BUSY)) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\noutl((reg << 24) | val, chip->port+AC97_ACCESS);\r\n}\r\nstatic int snd_als300_ac97(struct snd_als300 *chip)\r\n{\r\nstruct snd_ac97_bus *bus;\r\nstruct snd_ac97_template ac97;\r\nint err;\r\nstatic struct snd_ac97_bus_ops ops = {\r\n.write = snd_als300_ac97_write,\r\n.read = snd_als300_ac97_read,\r\n};\r\nsnd_als300_dbgcallenter();\r\nif ((err = snd_ac97_bus(chip->card, 0, &ops, NULL, &bus)) < 0)\r\nreturn err;\r\nmemset(&ac97, 0, sizeof(ac97));\r\nac97.private_data = chip;\r\nsnd_als300_dbgcallleave();\r\nreturn snd_ac97_mixer(bus, &ac97, &chip->ac97);\r\n}\r\nstatic int snd_als300_playback_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_als300_substream_data *data = kzalloc(sizeof(*data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nsnd_als300_dbgcallenter();\r\nchip->playback_substream = substream;\r\nruntime->hw = snd_als300_playback_hw;\r\nruntime->private_data = data;\r\ndata->control_register = PLAYBACK_CONTROL;\r\ndata->block_counter_register = PLAYBACK_BLOCK_COUNTER;\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_playback_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_als300_substream_data *data;\r\ndata = substream->runtime->private_data;\r\nsnd_als300_dbgcallenter();\r\nkfree(data);\r\nchip->playback_substream = NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_capture_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_als300_substream_data *data = kzalloc(sizeof(*data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nsnd_als300_dbgcallenter();\r\nchip->capture_substream = substream;\r\nruntime->hw = snd_als300_capture_hw;\r\nruntime->private_data = data;\r\ndata->control_register = RECORD_CONTROL;\r\ndata->block_counter_register = RECORD_BLOCK_COUNTER;\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_capture_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_als300_substream_data *data;\r\ndata = substream->runtime->private_data;\r\nsnd_als300_dbgcallenter();\r\nkfree(data);\r\nchip->capture_substream = NULL;\r\nsnd_pcm_lib_free_pages(substream);\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nreturn snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\n}\r\nstatic int snd_als300_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int snd_als300_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nu32 tmp;\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned short period_bytes = snd_pcm_lib_period_bytes(substream);\r\nunsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\r\nsnd_als300_dbgcallenter();\r\nspin_lock_irq(&chip->reg_lock);\r\ntmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);\r\ntmp &= ~TRANSFER_START;\r\nsnd_als300_dbgplay("Period bytes: %d Buffer bytes %d\n",\r\nperiod_bytes, buffer_bytes);\r\ntmp &= 0xffff0000;\r\ntmp |= period_bytes - 1;\r\nsnd_als300_gcr_write(chip->port, PLAYBACK_CONTROL, tmp);\r\nsnd_als300_gcr_write(chip->port, PLAYBACK_START,\r\nruntime->dma_addr);\r\nsnd_als300_gcr_write(chip->port, PLAYBACK_END,\r\nruntime->dma_addr + buffer_bytes - 1);\r\nspin_unlock_irq(&chip->reg_lock);\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nu32 tmp;\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nunsigned short period_bytes = snd_pcm_lib_period_bytes(substream);\r\nunsigned short buffer_bytes = snd_pcm_lib_buffer_bytes(substream);\r\nsnd_als300_dbgcallenter();\r\nspin_lock_irq(&chip->reg_lock);\r\ntmp = snd_als300_gcr_read(chip->port, RECORD_CONTROL);\r\ntmp &= ~TRANSFER_START;\r\nsnd_als300_dbgplay("Period bytes: %d Buffer bytes %d\n", period_bytes,\r\nbuffer_bytes);\r\ntmp &= 0xffff0000;\r\ntmp |= period_bytes - 1;\r\nsnd_als300_gcr_write(chip->port, RECORD_CONTROL, tmp);\r\nsnd_als300_gcr_write(chip->port, RECORD_START,\r\nruntime->dma_addr);\r\nsnd_als300_gcr_write(chip->port, RECORD_END,\r\nruntime->dma_addr + buffer_bytes - 1);\r\nspin_unlock_irq(&chip->reg_lock);\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nu32 tmp;\r\nstruct snd_als300_substream_data *data;\r\nunsigned short reg;\r\nint ret = 0;\r\ndata = substream->runtime->private_data;\r\nreg = data->control_register;\r\nsnd_als300_dbgcallenter();\r\nspin_lock(&chip->reg_lock);\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ntmp = snd_als300_gcr_read(chip->port, reg);\r\ndata->period_flipflop = 1;\r\nsnd_als300_gcr_write(chip->port, reg, tmp | TRANSFER_START);\r\nsnd_als300_dbgplay("TRIGGER START\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ntmp = snd_als300_gcr_read(chip->port, reg);\r\nsnd_als300_gcr_write(chip->port, reg, tmp & ~TRANSFER_START);\r\nsnd_als300_dbgplay("TRIGGER STOP\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\ntmp = snd_als300_gcr_read(chip->port, reg);\r\nsnd_als300_gcr_write(chip->port, reg, tmp | FIFO_PAUSE);\r\nsnd_als300_dbgplay("TRIGGER PAUSE\n");\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\ntmp = snd_als300_gcr_read(chip->port, reg);\r\nsnd_als300_gcr_write(chip->port, reg, tmp & ~FIFO_PAUSE);\r\nsnd_als300_dbgplay("TRIGGER RELEASE\n");\r\nbreak;\r\ndefault:\r\nsnd_als300_dbgplay("TRIGGER INVALID\n");\r\nret = -EINVAL;\r\n}\r\nspin_unlock(&chip->reg_lock);\r\nsnd_als300_dbgcallleave();\r\nreturn ret;\r\n}\r\nstatic snd_pcm_uframes_t snd_als300_pointer(struct snd_pcm_substream *substream)\r\n{\r\nu16 current_ptr;\r\nstruct snd_als300 *chip = snd_pcm_substream_chip(substream);\r\nstruct snd_als300_substream_data *data;\r\nunsigned short period_bytes;\r\ndata = substream->runtime->private_data;\r\nperiod_bytes = snd_pcm_lib_period_bytes(substream);\r\nsnd_als300_dbgcallenter();\r\nspin_lock(&chip->reg_lock);\r\ncurrent_ptr = (u16) snd_als300_gcr_read(chip->port,\r\ndata->block_counter_register) + 4;\r\nspin_unlock(&chip->reg_lock);\r\nif (current_ptr > period_bytes)\r\ncurrent_ptr = 0;\r\nelse\r\ncurrent_ptr = period_bytes - current_ptr;\r\nif (data->period_flipflop == 0)\r\ncurrent_ptr += period_bytes;\r\nsnd_als300_dbgplay("Pointer (bytes): %d\n", current_ptr);\r\nsnd_als300_dbgcallleave();\r\nreturn bytes_to_frames(substream->runtime, current_ptr);\r\n}\r\nstatic int snd_als300_new_pcm(struct snd_als300 *chip)\r\n{\r\nstruct snd_pcm *pcm;\r\nint err;\r\nsnd_als300_dbgcallenter();\r\nerr = snd_pcm_new(chip->card, "ALS300", 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = chip;\r\nstrcpy(pcm->name, "ALS300");\r\nchip->pcm = pcm;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\n&snd_als300_playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,\r\n&snd_als300_capture_ops);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_DEV,\r\nsnd_dma_pci_data(chip->pci), 64*1024, 64*1024);\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic void snd_als300_init(struct snd_als300 *chip)\r\n{\r\nunsigned long flags;\r\nu32 tmp;\r\nsnd_als300_dbgcallenter();\r\nspin_lock_irqsave(&chip->reg_lock, flags);\r\nchip->revision = (snd_als300_gcr_read(chip->port, MISC_CONTROL) >> 16)\r\n& 0x0000000F;\r\ntmp = snd_als300_gcr_read(chip->port, DRAM_WRITE_CONTROL);\r\nsnd_als300_gcr_write(chip->port, DRAM_WRITE_CONTROL,\r\n(tmp | DRAM_MODE_2)\r\n& ~WRITE_TRANS_START);\r\nsnd_als300_set_irq_flag(chip, IRQ_ENABLE);\r\ntmp = snd_als300_gcr_read(chip->port, MISC_CONTROL);\r\nsnd_als300_gcr_write(chip->port, MISC_CONTROL,\r\ntmp | VMUTE_NORMAL | MMUTE_NORMAL);\r\nsnd_als300_gcr_write(chip->port, MUS_VOC_VOL, 0);\r\ntmp = snd_als300_gcr_read(chip->port, PLAYBACK_CONTROL);\r\nsnd_als300_gcr_write(chip->port, PLAYBACK_CONTROL,\r\ntmp & ~TRANSFER_START);\r\nspin_unlock_irqrestore(&chip->reg_lock, flags);\r\nsnd_als300_dbgcallleave();\r\n}\r\nstatic int snd_als300_create(struct snd_card *card,\r\nstruct pci_dev *pci, int chip_type,\r\nstruct snd_als300 **rchip)\r\n{\r\nstruct snd_als300 *chip;\r\nvoid *irq_handler;\r\nint err;\r\nstatic struct snd_device_ops ops = {\r\n.dev_free = snd_als300_dev_free,\r\n};\r\n*rchip = NULL;\r\nsnd_als300_dbgcallenter();\r\nif ((err = pci_enable_device(pci)) < 0)\r\nreturn err;\r\nif (pci_set_dma_mask(pci, DMA_BIT_MASK(28)) < 0 ||\r\npci_set_consistent_dma_mask(pci, DMA_BIT_MASK(28)) < 0) {\r\nprintk(KERN_ERR "error setting 28bit DMA mask\n");\r\npci_disable_device(pci);\r\nreturn -ENXIO;\r\n}\r\npci_set_master(pci);\r\nchip = kzalloc(sizeof(*chip), GFP_KERNEL);\r\nif (chip == NULL) {\r\npci_disable_device(pci);\r\nreturn -ENOMEM;\r\n}\r\nchip->card = card;\r\nchip->pci = pci;\r\nchip->irq = -1;\r\nchip->chip_type = chip_type;\r\nspin_lock_init(&chip->reg_lock);\r\nif ((err = pci_request_regions(pci, "ALS300")) < 0) {\r\nkfree(chip);\r\npci_disable_device(pci);\r\nreturn err;\r\n}\r\nchip->port = pci_resource_start(pci, 0);\r\nif (chip->chip_type == DEVICE_ALS300_PLUS)\r\nirq_handler = snd_als300plus_interrupt;\r\nelse\r\nirq_handler = snd_als300_interrupt;\r\nif (request_irq(pci->irq, irq_handler, IRQF_SHARED,\r\nKBUILD_MODNAME, chip)) {\r\nsnd_printk(KERN_ERR "unable to grab IRQ %d\n", pci->irq);\r\nsnd_als300_free(chip);\r\nreturn -EBUSY;\r\n}\r\nchip->irq = pci->irq;\r\nsnd_als300_init(chip);\r\nerr = snd_als300_ac97(chip);\r\nif (err < 0) {\r\nsnd_printk(KERN_WARNING "Could not create ac97\n");\r\nsnd_als300_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_als300_new_pcm(chip)) < 0) {\r\nsnd_printk(KERN_WARNING "Could not create PCM\n");\r\nsnd_als300_free(chip);\r\nreturn err;\r\n}\r\nif ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL,\r\nchip, &ops)) < 0) {\r\nsnd_als300_free(chip);\r\nreturn err;\r\n}\r\nsnd_card_set_dev(card, &pci->dev);\r\n*rchip = chip;\r\nsnd_als300_dbgcallleave();\r\nreturn 0;\r\n}\r\nstatic int snd_als300_suspend(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_als300 *chip = card->private_data;\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D3hot);\r\nsnd_pcm_suspend_all(chip->pcm);\r\nsnd_ac97_suspend(chip->ac97);\r\npci_disable_device(pci);\r\npci_save_state(pci);\r\npci_set_power_state(pci, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int snd_als300_resume(struct device *dev)\r\n{\r\nstruct pci_dev *pci = to_pci_dev(dev);\r\nstruct snd_card *card = dev_get_drvdata(dev);\r\nstruct snd_als300 *chip = card->private_data;\r\npci_set_power_state(pci, PCI_D0);\r\npci_restore_state(pci);\r\nif (pci_enable_device(pci) < 0) {\r\nprintk(KERN_ERR "als300: pci_enable_device failed, "\r\n"disabling device\n");\r\nsnd_card_disconnect(card);\r\nreturn -EIO;\r\n}\r\npci_set_master(pci);\r\nsnd_als300_init(chip);\r\nsnd_ac97_resume(chip->ac97);\r\nsnd_power_change_state(card, SNDRV_CTL_POWER_D0);\r\nreturn 0;\r\n}\r\nstatic int snd_als300_probe(struct pci_dev *pci,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstatic int dev;\r\nstruct snd_card *card;\r\nstruct snd_als300 *chip;\r\nint err, chip_type;\r\nif (dev >= SNDRV_CARDS)\r\nreturn -ENODEV;\r\nif (!enable[dev]) {\r\ndev++;\r\nreturn -ENOENT;\r\n}\r\nerr = snd_card_create(index[dev], id[dev], THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nchip_type = pci_id->driver_data;\r\nif ((err = snd_als300_create(card, pci, chip_type, &chip)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\ncard->private_data = chip;\r\nstrcpy(card->driver, "ALS300");\r\nif (chip->chip_type == DEVICE_ALS300_PLUS)\r\nsprintf(card->shortname, "ALS300+ (Rev. %d)", chip->revision);\r\nelse\r\nsprintf(card->shortname, "ALS300 (Rev. %c)", 'A' +\r\nchip->revision - 1);\r\nsprintf(card->longname, "%s at 0x%lx irq %i",\r\ncard->shortname, chip->port, chip->irq);\r\nif ((err = snd_card_register(card)) < 0) {\r\nsnd_card_free(card);\r\nreturn err;\r\n}\r\npci_set_drvdata(pci, card);\r\ndev++;\r\nreturn 0;\r\n}
