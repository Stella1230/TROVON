static int sh_mobile_sdhi_clk_enable(struct platform_device *pdev, unsigned int *f)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);\r\nint ret = clk_enable(priv->clk);\r\nif (ret < 0)\r\nreturn ret;\r\n*f = clk_get_rate(priv->clk);\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_sdhi_clk_disable(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi *priv = container_of(host->pdata, struct sh_mobile_sdhi, mmc_data);\r\nclk_disable(priv->clk);\r\n}\r\nstatic int sh_mobile_sdhi_wait_idle(struct tmio_mmc_host *host)\r\n{\r\nint timeout = 1000;\r\nwhile (--timeout && !(sd_ctrl_read16(host, CTL_STATUS2) & (1 << 13)))\r\nudelay(1);\r\nif (!timeout) {\r\ndev_warn(host->pdata->dev, "timeout waiting for SD bus idle\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sh_mobile_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)\r\n{\r\nswitch (addr)\r\n{\r\ncase CTL_SD_CMD:\r\ncase CTL_STOP_INTERNAL_ACTION:\r\ncase CTL_XFER_BLK_COUNT:\r\ncase CTL_SD_CARD_CLK_CTL:\r\ncase CTL_SD_XFER_LEN:\r\ncase CTL_SD_MEM_CARD_OPT:\r\ncase CTL_TRANSACTION_CTL:\r\ncase CTL_DMA_ENABLE:\r\nreturn sh_mobile_sdhi_wait_idle(host);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sh_mobile_sdhi_cd_wakeup(const struct platform_device *pdev)\r\n{\r\nmmc_detect_change(platform_get_drvdata(pdev), msecs_to_jiffies(100));\r\n}\r\nstatic int sh_mobile_sdhi_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(sh_mobile_sdhi_of_match, &pdev->dev);\r\nstruct sh_mobile_sdhi *priv;\r\nstruct tmio_mmc_data *mmc_data;\r\nstruct sh_mobile_sdhi_info *p = pdev->dev.platform_data;\r\nstruct tmio_mmc_host *host;\r\nint irq, ret, i = 0;\r\nbool multiplexed_isr = true;\r\nstruct tmio_mmc_dma *dma_priv;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(struct sh_mobile_sdhi), GFP_KERNEL);\r\nif (priv == NULL) {\r\ndev_err(&pdev->dev, "kzalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmmc_data = &priv->mmc_data;\r\ndma_priv = &priv->dma_priv;\r\nif (p) {\r\nif (p->init) {\r\nret = p->init(pdev, &sdhi_ops);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\nret = PTR_ERR(priv->clk);\r\ndev_err(&pdev->dev, "cannot get clock: %d\n", ret);\r\ngoto eclkget;\r\n}\r\nmmc_data->clk_enable = sh_mobile_sdhi_clk_enable;\r\nmmc_data->clk_disable = sh_mobile_sdhi_clk_disable;\r\nmmc_data->capabilities = MMC_CAP_MMC_HIGHSPEED;\r\nmmc_data->write16_hook = sh_mobile_sdhi_write16_hook;\r\nif (p) {\r\nmmc_data->flags = p->tmio_flags;\r\nmmc_data->ocr_mask = p->tmio_ocr_mask;\r\nmmc_data->capabilities |= p->tmio_caps;\r\nmmc_data->capabilities2 |= p->tmio_caps2;\r\nmmc_data->cd_gpio = p->cd_gpio;\r\nif (p->dma_slave_tx > 0 && p->dma_slave_rx > 0) {\r\ndma_priv->chan_priv_tx = (void *)p->dma_slave_tx;\r\ndma_priv->chan_priv_rx = (void *)p->dma_slave_rx;\r\ndma_priv->slave_id_tx = p->dma_slave_tx;\r\ndma_priv->slave_id_rx = p->dma_slave_rx;\r\n}\r\n}\r\ndma_priv->alignment_shift = 1;\r\ndma_priv->filter = shdma_chan_filter;\r\nmmc_data->dma = dma_priv;\r\nmmc_data->flags |= TMIO_MMC_BLKSZ_2BYTES;\r\nmmc_data->flags |= TMIO_MMC_SDIO_IRQ;\r\nif (of_id && of_id->data) {\r\nconst struct sh_mobile_sdhi_of_data *of_data = of_id->data;\r\nmmc_data->flags |= of_data->tmio_flags;\r\n}\r\nret = tmio_mmc_host_probe(&host, pdev, mmc_data);\r\nif (ret < 0)\r\ngoto eprobe;\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_CARD_DETECT);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_card_detect_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDIO);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_sdio_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nirq = platform_get_irq_byname(pdev, SH_MOBILE_SDHI_IRQ_SDCARD);\r\nif (irq >= 0) {\r\nmultiplexed_isr = false;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_sdcard_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n} else if (!multiplexed_isr) {\r\ndev_err(&pdev->dev,\r\n"Principal SD-card IRQ is missing among named interrupts\n");\r\nret = irq;\r\ngoto eirq;\r\n}\r\nif (multiplexed_isr) {\r\nwhile (1) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0)\r\nbreak;\r\ni++;\r\nret = devm_request_irq(&pdev->dev, irq, tmio_mmc_irq, 0,\r\ndev_name(&pdev->dev), host);\r\nif (ret)\r\ngoto eirq;\r\n}\r\nif (!i) {\r\nret = irq;\r\ngoto eirq;\r\n}\r\n}\r\ndev_info(&pdev->dev, "%s base at 0x%08lx clock rate %u MHz\n",\r\nmmc_hostname(host->mmc), (unsigned long)\r\n(platform_get_resource(pdev, IORESOURCE_MEM, 0)->start),\r\nhost->mmc->f_max / 1000000);\r\nreturn ret;\r\neirq:\r\ntmio_mmc_host_remove(host);\r\neprobe:\r\neclkget:\r\nif (p && p->cleanup)\r\np->cleanup(pdev);\r\nreturn ret;\r\n}\r\nstatic int sh_mobile_sdhi_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_host *mmc = platform_get_drvdata(pdev);\r\nstruct tmio_mmc_host *host = mmc_priv(mmc);\r\nstruct sh_mobile_sdhi_info *p = pdev->dev.platform_data;\r\ntmio_mmc_host_remove(host);\r\nif (p && p->cleanup)\r\np->cleanup(pdev);\r\nreturn 0;\r\n}
