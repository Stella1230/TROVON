static void hp_sdc_mlc_isr (int irq, void *dev_id,\r\nuint8_t status, uint8_t data)\r\n{\r\nint idx;\r\nhil_mlc *mlc = &hp_sdc_mlc;\r\nwrite_lock(&mlc->lock);\r\nif (mlc->icount < 0) {\r\nprintk(KERN_WARNING PREFIX "HIL Overflow!\n");\r\nup(&mlc->isem);\r\ngoto out;\r\n}\r\nidx = 15 - mlc->icount;\r\nif ((status & HP_SDC_STATUS_IRQMASK) == HP_SDC_STATUS_HILDATA) {\r\nmlc->ipacket[idx] |= data | HIL_ERR_INT;\r\nmlc->icount--;\r\nif (hp_sdc_mlc_priv.got5x || !idx)\r\ngoto check;\r\nif ((mlc->ipacket[idx - 1] & HIL_PKT_ADDR_MASK) !=\r\n(mlc->ipacket[idx] & HIL_PKT_ADDR_MASK)) {\r\nmlc->ipacket[idx] &= ~HIL_PKT_ADDR_MASK;\r\nmlc->ipacket[idx] |= (mlc->ipacket[idx - 1]\r\n& HIL_PKT_ADDR_MASK);\r\n}\r\ngoto check;\r\n}\r\nif (data & HP_SDC_HIL_ISERR)\r\ngoto err;\r\nmlc->ipacket[idx] =\r\n(data & HP_SDC_HIL_R1MASK) << HIL_PKT_ADDR_SHIFT;\r\nhp_sdc_mlc_priv.got5x = 1;\r\ngoto out;\r\ncheck:\r\nhp_sdc_mlc_priv.got5x = 0;\r\nif (mlc->imatch == 0)\r\ngoto done;\r\nif ((mlc->imatch == (HIL_ERR_INT | HIL_PKT_CMD | HIL_CMD_POL))\r\n&& (mlc->ipacket[idx] == (mlc->imatch | idx)))\r\ngoto done;\r\nif (mlc->ipacket[idx] == mlc->imatch)\r\ngoto done;\r\ngoto out;\r\nerr:\r\nprintk(KERN_DEBUG PREFIX "err code %x\n", data);\r\nswitch (data) {\r\ncase HP_SDC_HIL_RC_DONE:\r\nprintk(KERN_WARNING PREFIX "Bastard SDC reconfigured loop!\n");\r\nbreak;\r\ncase HP_SDC_HIL_ERR:\r\nmlc->ipacket[idx] |= HIL_ERR_INT | HIL_ERR_PERR |\r\nHIL_ERR_FERR | HIL_ERR_FOF;\r\nbreak;\r\ncase HP_SDC_HIL_TO:\r\nmlc->ipacket[idx] |= HIL_ERR_INT | HIL_ERR_LERR;\r\nbreak;\r\ncase HP_SDC_HIL_RC:\r\nprintk(KERN_WARNING PREFIX "Bastard SDC decided to reconfigure loop!\n");\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING PREFIX "Unknown HIL Error status (%x)!\n", data);\r\nbreak;\r\n}\r\ndone:\r\ntasklet_schedule(mlc->tasklet);\r\nup(&mlc->isem);\r\nout:\r\nwrite_unlock(&mlc->lock);\r\n}\r\nstatic int hp_sdc_mlc_in(hil_mlc *mlc, suseconds_t timeout)\r\n{\r\nstruct hp_sdc_mlc_priv_s *priv;\r\nint rc = 2;\r\npriv = mlc->priv;\r\nif (down_trylock(&mlc->isem)) {\r\nstruct timeval tv;\r\nif (priv->emtestmode) {\r\nmlc->ipacket[0] =\r\nHIL_ERR_INT | (mlc->opacket &\r\n(HIL_PKT_CMD |\r\nHIL_PKT_ADDR_MASK |\r\nHIL_PKT_DATA_MASK));\r\nmlc->icount = 14;\r\ngoto wasup;\r\n}\r\ndo_gettimeofday(&tv);\r\ntv.tv_usec += USEC_PER_SEC * (tv.tv_sec - mlc->instart.tv_sec);\r\nif (tv.tv_usec - mlc->instart.tv_usec > mlc->intimeout) {\r\nrc = 1;\r\nup(&mlc->isem);\r\n}\r\ngoto done;\r\n}\r\nwasup:\r\nup(&mlc->isem);\r\nrc = 0;\r\ndone:\r\nreturn rc;\r\n}\r\nstatic int hp_sdc_mlc_cts(hil_mlc *mlc)\r\n{\r\nstruct hp_sdc_mlc_priv_s *priv;\r\npriv = mlc->priv;\r\nBUG_ON(down_trylock(&mlc->isem));\r\nBUG_ON(down_trylock(&mlc->osem));\r\nup(&mlc->isem);\r\nup(&mlc->osem);\r\nif (down_trylock(&mlc->csem)) {\r\nif (priv->trans.act.semaphore != &mlc->csem)\r\ngoto poll;\r\nelse\r\ngoto busy;\r\n}\r\nif (!(priv->tseq[4] & HP_SDC_USE_LOOP))\r\ngoto done;\r\npoll:\r\npriv->trans.act.semaphore = &mlc->csem;\r\npriv->trans.actidx = 0;\r\npriv->trans.idx = 1;\r\npriv->trans.endidx = 5;\r\npriv->tseq[0] =\r\nHP_SDC_ACT_POSTCMD | HP_SDC_ACT_DATAIN | HP_SDC_ACT_SEMAPHORE;\r\npriv->tseq[1] = HP_SDC_CMD_READ_USE;\r\npriv->tseq[2] = 1;\r\npriv->tseq[3] = 0;\r\npriv->tseq[4] = 0;\r\n__hp_sdc_enqueue_transaction(&priv->trans);\r\nbusy:\r\nreturn 1;\r\ndone:\r\npriv->trans.act.semaphore = &mlc->osem;\r\nup(&mlc->csem);\r\nreturn 0;\r\n}\r\nstatic void hp_sdc_mlc_out(hil_mlc *mlc)\r\n{\r\nstruct hp_sdc_mlc_priv_s *priv;\r\npriv = mlc->priv;\r\nBUG_ON(down_trylock(&mlc->osem));\r\nif (mlc->opacket & HIL_DO_ALTER_CTRL)\r\ngoto do_control;\r\ndo_data:\r\nif (priv->emtestmode) {\r\nup(&mlc->osem);\r\nreturn;\r\n}\r\nBUG_ON(down_trylock(&mlc->csem));\r\nup(&mlc->csem);\r\npriv->trans.actidx = 0;\r\npriv->trans.idx = 1;\r\npriv->trans.act.semaphore = &mlc->osem;\r\npriv->trans.endidx = 6;\r\npriv->tseq[0] =\r\nHP_SDC_ACT_DATAREG | HP_SDC_ACT_POSTCMD | HP_SDC_ACT_SEMAPHORE;\r\npriv->tseq[1] = 0x7;\r\npriv->tseq[2] =\r\n(mlc->opacket &\r\n(HIL_PKT_ADDR_MASK | HIL_PKT_CMD))\r\n>> HIL_PKT_ADDR_SHIFT;\r\npriv->tseq[3] =\r\n(mlc->opacket & HIL_PKT_DATA_MASK)\r\n>> HIL_PKT_DATA_SHIFT;\r\npriv->tseq[4] = 0;\r\nif (priv->tseq[3] == HIL_CMD_DHR)\r\npriv->tseq[4] = 1;\r\npriv->tseq[5] = HP_SDC_CMD_DO_HIL;\r\ngoto enqueue;\r\ndo_control:\r\npriv->emtestmode = mlc->opacket & HIL_CTRL_TEST;\r\nBUG_ON((mlc->opacket & (HIL_CTRL_APE | HIL_CTRL_IPF)) == HIL_CTRL_APE);\r\nif ((mlc->opacket & HIL_CTRL_ONLY) == HIL_CTRL_ONLY)\r\ngoto control_only;\r\nBUG_ON(mlc->opacket & HIL_CTRL_APE);\r\ngoto do_data;\r\ncontrol_only:\r\npriv->trans.actidx = 0;\r\npriv->trans.idx = 1;\r\npriv->trans.act.semaphore = &mlc->osem;\r\npriv->trans.endidx = 4;\r\npriv->tseq[0] =\r\nHP_SDC_ACT_PRECMD | HP_SDC_ACT_DATAOUT | HP_SDC_ACT_SEMAPHORE;\r\npriv->tseq[1] = HP_SDC_CMD_SET_LPC;\r\npriv->tseq[2] = 1;\r\npriv->tseq[3] = 0;\r\nif (mlc->opacket & HIL_CTRL_APE) {\r\npriv->tseq[3] |= HP_SDC_LPC_APE_IPF;\r\nBUG_ON(down_trylock(&mlc->csem));\r\n}\r\nenqueue:\r\nhp_sdc_enqueue_transaction(&priv->trans);\r\n}\r\nstatic int __init hp_sdc_mlc_init(void)\r\n{\r\nhil_mlc *mlc = &hp_sdc_mlc;\r\nint err;\r\n#ifdef __mc68000__\r\nif (!MACH_IS_HP300)\r\nreturn -ENODEV;\r\n#endif\r\nprintk(KERN_INFO PREFIX "Registering the System Domain Controller's HIL MLC.\n");\r\nhp_sdc_mlc_priv.emtestmode = 0;\r\nhp_sdc_mlc_priv.trans.seq = hp_sdc_mlc_priv.tseq;\r\nhp_sdc_mlc_priv.trans.act.semaphore = &mlc->osem;\r\nhp_sdc_mlc_priv.got5x = 0;\r\nmlc->cts = &hp_sdc_mlc_cts;\r\nmlc->in = &hp_sdc_mlc_in;\r\nmlc->out = &hp_sdc_mlc_out;\r\nmlc->priv = &hp_sdc_mlc_priv;\r\nerr = hil_mlc_register(mlc);\r\nif (err) {\r\nprintk(KERN_WARNING PREFIX "Failed to register MLC structure with hil_mlc\n");\r\nreturn err;\r\n}\r\nif (hp_sdc_request_hil_irq(&hp_sdc_mlc_isr)) {\r\nprintk(KERN_WARNING PREFIX "Request for raw HIL ISR hook denied\n");\r\nif (hil_mlc_unregister(mlc))\r\nprintk(KERN_ERR PREFIX "Failed to unregister MLC structure with hil_mlc.\n"\r\n"This is bad. Could cause an oops.\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __exit hp_sdc_mlc_exit(void)\r\n{\r\nhil_mlc *mlc = &hp_sdc_mlc;\r\nif (hp_sdc_release_hil_irq(&hp_sdc_mlc_isr))\r\nprintk(KERN_ERR PREFIX "Failed to release the raw HIL ISR hook.\n"\r\n"This is bad. Could cause an oops.\n");\r\nif (hil_mlc_unregister(mlc))\r\nprintk(KERN_ERR PREFIX "Failed to unregister MLC structure with hil_mlc.\n"\r\n"This is bad. Could cause an oops.\n");\r\n}
