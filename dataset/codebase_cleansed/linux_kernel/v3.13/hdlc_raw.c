static __be16 raw_type_trans(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nreturn cpu_to_be16(ETH_P_IP);\r\n}\r\nstatic int raw_ioctl(struct net_device *dev, struct ifreq *ifr)\r\n{\r\nraw_hdlc_proto __user *raw_s = ifr->ifr_settings.ifs_ifsu.raw_hdlc;\r\nconst size_t size = sizeof(raw_hdlc_proto);\r\nraw_hdlc_proto new_settings;\r\nhdlc_device *hdlc = dev_to_hdlc(dev);\r\nint result;\r\nswitch (ifr->ifr_settings.type) {\r\ncase IF_GET_PROTO:\r\nif (dev_to_hdlc(dev)->proto != &proto)\r\nreturn -EINVAL;\r\nifr->ifr_settings.type = IF_PROTO_HDLC;\r\nif (ifr->ifr_settings.size < size) {\r\nifr->ifr_settings.size = size;\r\nreturn -ENOBUFS;\r\n}\r\nif (copy_to_user(raw_s, hdlc->state, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase IF_PROTO_HDLC:\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (dev->flags & IFF_UP)\r\nreturn -EBUSY;\r\nif (copy_from_user(&new_settings, raw_s, size))\r\nreturn -EFAULT;\r\nif (new_settings.encoding == ENCODING_DEFAULT)\r\nnew_settings.encoding = ENCODING_NRZ;\r\nif (new_settings.parity == PARITY_DEFAULT)\r\nnew_settings.parity = PARITY_CRC16_PR1_CCITT;\r\nresult = hdlc->attach(dev, new_settings.encoding,\r\nnew_settings.parity);\r\nif (result)\r\nreturn result;\r\nresult = attach_hdlc_protocol(dev, &proto,\r\nsizeof(raw_hdlc_proto));\r\nif (result)\r\nreturn result;\r\nmemcpy(hdlc->state, &new_settings, size);\r\ndev->type = ARPHRD_RAWHDLC;\r\nnetif_dormant_off(dev);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init mod_init(void)\r\n{\r\nregister_hdlc_protocol(&proto);\r\nreturn 0;\r\n}\r\nstatic void __exit mod_exit(void)\r\n{\r\nunregister_hdlc_protocol(&proto);\r\n}
