const char *sptlrpc_part2name(enum lustre_sec_part part)\r\n{\r\nswitch (part) {\r\ncase LUSTRE_SP_CLI:\r\nreturn "cli";\r\ncase LUSTRE_SP_MDT:\r\nreturn "mdt";\r\ncase LUSTRE_SP_OST:\r\nreturn "ost";\r\ncase LUSTRE_SP_MGC:\r\nreturn "mgc";\r\ncase LUSTRE_SP_MGS:\r\nreturn "mgs";\r\ncase LUSTRE_SP_ANY:\r\nreturn "any";\r\ndefault:\r\nreturn "err";\r\n}\r\n}\r\nenum lustre_sec_part sptlrpc_target_sec_part(struct obd_device *obd)\r\n{\r\nconst char *type = obd->obd_type->typ_name;\r\nif (!strcmp(type, LUSTRE_MDT_NAME))\r\nreturn LUSTRE_SP_MDT;\r\nif (!strcmp(type, LUSTRE_OST_NAME))\r\nreturn LUSTRE_SP_OST;\r\nif (!strcmp(type, LUSTRE_MGS_NAME))\r\nreturn LUSTRE_SP_MGS;\r\nCERROR("unknown target %p(%s)\n", obd, type);\r\nreturn LUSTRE_SP_ANY;\r\n}\r\nint sptlrpc_parse_flavor(const char *str, struct sptlrpc_flavor *flvr)\r\n{\r\nchar buf[32];\r\nchar *bulk, *alg;\r\nmemset(flvr, 0, sizeof(*flvr));\r\nif (str == NULL || str[0] == '\0') {\r\nflvr->sf_rpc = SPTLRPC_FLVR_INVALID;\r\nreturn 0;\r\n}\r\nstrncpy(buf, str, sizeof(buf));\r\nbuf[sizeof(buf) - 1] = '\0';\r\nbulk = strchr(buf, '-');\r\nif (bulk)\r\n*bulk++ = '\0';\r\nflvr->sf_rpc = sptlrpc_name2flavor_base(buf);\r\nif (flvr->sf_rpc == SPTLRPC_FLVR_INVALID)\r\ngoto err_out;\r\nif (flvr->sf_rpc == SPTLRPC_FLVR_PLAIN) {\r\nflvr->u_bulk.hash.hash_alg = BULK_HASH_ALG_ADLER32;\r\nif (bulk) {\r\nalg = strchr(bulk, ':');\r\nif (alg == NULL)\r\ngoto err_out;\r\n*alg++ = '\0';\r\nif (strcmp(bulk, "hash"))\r\ngoto err_out;\r\nflvr->u_bulk.hash.hash_alg = sptlrpc_get_hash_alg(alg);\r\nif (flvr->u_bulk.hash.hash_alg >= BULK_HASH_ALG_MAX)\r\ngoto err_out;\r\n}\r\nif (flvr->u_bulk.hash.hash_alg == BULK_HASH_ALG_NULL)\r\nflvr_set_bulk_svc(&flvr->sf_rpc, SPTLRPC_BULK_SVC_NULL);\r\nelse\r\nflvr_set_bulk_svc(&flvr->sf_rpc, SPTLRPC_BULK_SVC_INTG);\r\n} else {\r\nif (bulk)\r\ngoto err_out;\r\n}\r\nflvr->sf_flags = 0;\r\nreturn 0;\r\nerr_out:\r\nCERROR("invalid flavor string: %s\n", str);\r\nreturn -EINVAL;\r\n}\r\nstatic void get_default_flavor(struct sptlrpc_flavor *sf)\r\n{\r\nmemset(sf, 0, sizeof(*sf));\r\nsf->sf_rpc = SPTLRPC_FLVR_NULL;\r\nsf->sf_flags = 0;\r\n}\r\nstatic void sptlrpc_rule_init(struct sptlrpc_rule *rule)\r\n{\r\nrule->sr_netid = LNET_NIDNET(LNET_NID_ANY);\r\nrule->sr_from = LUSTRE_SP_ANY;\r\nrule->sr_to = LUSTRE_SP_ANY;\r\nrule->sr_padding = 0;\r\nget_default_flavor(&rule->sr_flvr);\r\n}\r\nint sptlrpc_parse_rule(char *param, struct sptlrpc_rule *rule)\r\n{\r\nchar *flavor, *dir;\r\nint rc;\r\nsptlrpc_rule_init(rule);\r\nflavor = strchr(param, '=');\r\nif (flavor == NULL) {\r\nCERROR("invalid param, no '='\n");\r\nreturn -EINVAL;\r\n}\r\n*flavor++ = '\0';\r\ndir = strchr(param, '.');\r\nif (dir)\r\n*dir++ = '\0';\r\nif (strcmp(param, "default")) {\r\nrule->sr_netid = libcfs_str2net(param);\r\nif (rule->sr_netid == LNET_NIDNET(LNET_NID_ANY)) {\r\nCERROR("invalid network name: %s\n", param);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (dir) {\r\nif (!strcmp(dir, "mdt2ost")) {\r\nrule->sr_from = LUSTRE_SP_MDT;\r\nrule->sr_to = LUSTRE_SP_OST;\r\n} else if (!strcmp(dir, "mdt2mdt")) {\r\nrule->sr_from = LUSTRE_SP_MDT;\r\nrule->sr_to = LUSTRE_SP_MDT;\r\n} else if (!strcmp(dir, "cli2ost")) {\r\nrule->sr_from = LUSTRE_SP_CLI;\r\nrule->sr_to = LUSTRE_SP_OST;\r\n} else if (!strcmp(dir, "cli2mdt")) {\r\nrule->sr_from = LUSTRE_SP_CLI;\r\nrule->sr_to = LUSTRE_SP_MDT;\r\n} else {\r\nCERROR("invalid rule dir segment: %s\n", dir);\r\nreturn -EINVAL;\r\n}\r\n}\r\nrc = sptlrpc_parse_flavor(flavor, &rule->sr_flvr);\r\nif (rc)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nvoid sptlrpc_rule_set_free(struct sptlrpc_rule_set *rset)\r\n{\r\nLASSERT(rset->srs_nslot ||\r\n(rset->srs_nrule == 0 && rset->srs_rules == NULL));\r\nif (rset->srs_nslot) {\r\nOBD_FREE(rset->srs_rules,\r\nrset->srs_nslot * sizeof(*rset->srs_rules));\r\nsptlrpc_rule_set_init(rset);\r\n}\r\n}\r\nint sptlrpc_rule_set_expand(struct sptlrpc_rule_set *rset)\r\n{\r\nstruct sptlrpc_rule *rules;\r\nint nslot;\r\nmight_sleep();\r\nif (rset->srs_nrule < rset->srs_nslot)\r\nreturn 0;\r\nnslot = rset->srs_nslot + 8;\r\nOBD_ALLOC(rules, nslot * sizeof(*rset->srs_rules));\r\nif (rules == NULL)\r\nreturn -ENOMEM;\r\nif (rset->srs_nrule) {\r\nLASSERT(rset->srs_nslot && rset->srs_rules);\r\nmemcpy(rules, rset->srs_rules,\r\nrset->srs_nrule * sizeof(*rset->srs_rules));\r\nOBD_FREE(rset->srs_rules,\r\nrset->srs_nslot * sizeof(*rset->srs_rules));\r\n}\r\nrset->srs_rules = rules;\r\nrset->srs_nslot = nslot;\r\nreturn 0;\r\n}\r\nstatic inline int rule_spec_dir(struct sptlrpc_rule *rule)\r\n{\r\nreturn (rule->sr_from != LUSTRE_SP_ANY ||\r\nrule->sr_to != LUSTRE_SP_ANY);\r\n}\r\nstatic inline int rule_spec_net(struct sptlrpc_rule *rule)\r\n{\r\nreturn (rule->sr_netid != LNET_NIDNET(LNET_NID_ANY));\r\n}\r\nstatic inline int rule_match_dir(struct sptlrpc_rule *r1,\r\nstruct sptlrpc_rule *r2)\r\n{\r\nreturn (r1->sr_from == r2->sr_from && r1->sr_to == r2->sr_to);\r\n}\r\nstatic inline int rule_match_net(struct sptlrpc_rule *r1,\r\nstruct sptlrpc_rule *r2)\r\n{\r\nreturn (r1->sr_netid == r2->sr_netid);\r\n}\r\nint sptlrpc_rule_set_merge(struct sptlrpc_rule_set *rset,\r\nstruct sptlrpc_rule *rule)\r\n{\r\nstruct sptlrpc_rule *p = rset->srs_rules;\r\nint spec_dir, spec_net;\r\nint rc, n, match = 0;\r\nmight_sleep();\r\nspec_net = rule_spec_net(rule);\r\nspec_dir = rule_spec_dir(rule);\r\nfor (n = 0; n < rset->srs_nrule; n++) {\r\np = &rset->srs_rules[n];\r\nif (!rule_match_net(p, rule)) {\r\nif (spec_net) {\r\nif (rule_spec_net(p))\r\ncontinue;\r\nelse\r\nbreak;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nif (!rule_match_dir(p, rule)) {\r\nif (spec_dir) {\r\nif (rule_spec_dir(p))\r\ncontinue;\r\nelse\r\nbreak;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nmatch = 1;\r\nbreak;\r\n}\r\nif (match) {\r\nLASSERT(n >= 0 && n < rset->srs_nrule);\r\nif (rule->sr_flvr.sf_rpc == SPTLRPC_FLVR_INVALID) {\r\nif (n < rset->srs_nrule - 1)\r\nmemmove(&rset->srs_rules[n],\r\n&rset->srs_rules[n + 1],\r\n(rset->srs_nrule - n - 1) *\r\nsizeof(*rule));\r\nrset->srs_nrule--;\r\n} else {\r\nmemcpy(&rset->srs_rules[n], rule, sizeof(*rule));\r\n}\r\n} else {\r\nLASSERT(n >= 0 && n <= rset->srs_nrule);\r\nif (rule->sr_flvr.sf_rpc != SPTLRPC_FLVR_INVALID) {\r\nrc = sptlrpc_rule_set_expand(rset);\r\nif (rc)\r\nreturn rc;\r\nif (n < rset->srs_nrule)\r\nmemmove(&rset->srs_rules[n + 1],\r\n&rset->srs_rules[n],\r\n(rset->srs_nrule - n) * sizeof(*rule));\r\nmemcpy(&rset->srs_rules[n], rule, sizeof(*rule));\r\nrset->srs_nrule++;\r\n} else {\r\nCDEBUG(D_CONFIG, "ignore the unmatched deletion\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_rule_set_choose(struct sptlrpc_rule_set *rset,\r\nenum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nlnet_nid_t nid,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct sptlrpc_rule *r;\r\nint n;\r\nfor (n = 0; n < rset->srs_nrule; n++) {\r\nr = &rset->srs_rules[n];\r\nif (LNET_NIDNET(nid) != LNET_NIDNET(LNET_NID_ANY) &&\r\nr->sr_netid != LNET_NIDNET(LNET_NID_ANY) &&\r\nLNET_NIDNET(nid) != r->sr_netid)\r\ncontinue;\r\nif (from != LUSTRE_SP_ANY && r->sr_from != LUSTRE_SP_ANY &&\r\nfrom != r->sr_from)\r\ncontinue;\r\nif (to != LUSTRE_SP_ANY && r->sr_to != LUSTRE_SP_ANY &&\r\nto != r->sr_to)\r\ncontinue;\r\n*sf = r->sr_flvr;\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid sptlrpc_rule_set_dump(struct sptlrpc_rule_set *rset)\r\n{\r\nstruct sptlrpc_rule *r;\r\nint n;\r\nfor (n = 0; n < rset->srs_nrule; n++) {\r\nr = &rset->srs_rules[n];\r\nCDEBUG(D_SEC, "<%02d> from %x to %x, net %x, rpc %x\n", n,\r\nr->sr_from, r->sr_to, r->sr_netid, r->sr_flvr.sf_rpc);\r\n}\r\n}\r\nstatic int sptlrpc_rule_set_extract(struct sptlrpc_rule_set *gen,\r\nstruct sptlrpc_rule_set *tgt,\r\nenum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nstruct sptlrpc_rule_set *rset)\r\n{\r\nstruct sptlrpc_rule_set *src[2] = { gen, tgt };\r\nstruct sptlrpc_rule *rule;\r\nint i, n, rc;\r\nmight_sleep();\r\nfor (i = 0; i < 2; i++) {\r\nif (src[i] == NULL)\r\ncontinue;\r\nfor (n = 0; n < src[i]->srs_nrule; n++) {\r\nrule = &src[i]->srs_rules[n];\r\nif (from != LUSTRE_SP_ANY &&\r\nrule->sr_from != LUSTRE_SP_ANY &&\r\nrule->sr_from != from)\r\ncontinue;\r\nif (to != LUSTRE_SP_ANY &&\r\nrule->sr_to != LUSTRE_SP_ANY &&\r\nrule->sr_to != to)\r\ncontinue;\r\nrc = sptlrpc_rule_set_merge(rset, rule);\r\nif (rc) {\r\nCERROR("can't merge: %d\n", rc);\r\nreturn rc;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int is_hex(char c)\r\n{\r\nreturn ((c >= '0' && c <= '9') ||\r\n(c >= 'a' && c <= 'f'));\r\n}\r\nstatic void target2fsname(const char *tgt, char *fsname, int buflen)\r\n{\r\nconst char *ptr;\r\nint len;\r\nptr = strrchr(tgt, '-');\r\nif (ptr) {\r\nif ((strncmp(ptr, "-MDT", 4) != 0 &&\r\nstrncmp(ptr, "-OST", 4) != 0) ||\r\n!is_hex(ptr[4]) || !is_hex(ptr[5]) ||\r\n!is_hex(ptr[6]) || !is_hex(ptr[7]))\r\nptr = NULL;\r\n}\r\nif (ptr == NULL)\r\nlen = strlen(tgt);\r\nelse\r\nlen = ptr - tgt;\r\nlen = min(len, buflen - 1);\r\nmemcpy(fsname, tgt, len);\r\nfsname[len] = '\0';\r\n}\r\nstatic void sptlrpc_conf_free_rsets(struct sptlrpc_conf *conf)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt, *conf_tgt_next;\r\nsptlrpc_rule_set_free(&conf->sc_rset);\r\nlist_for_each_entry_safe(conf_tgt, conf_tgt_next,\r\n&conf->sc_tgts, sct_list) {\r\nsptlrpc_rule_set_free(&conf_tgt->sct_rset);\r\nlist_del(&conf_tgt->sct_list);\r\nOBD_FREE_PTR(conf_tgt);\r\n}\r\nLASSERT(list_empty(&conf->sc_tgts));\r\nconf->sc_updated = 0;\r\nconf->sc_local = 0;\r\n}\r\nstatic void sptlrpc_conf_free(struct sptlrpc_conf *conf)\r\n{\r\nCDEBUG(D_SEC, "free sptlrpc conf %s\n", conf->sc_fsname);\r\nsptlrpc_conf_free_rsets(conf);\r\nlist_del(&conf->sc_list);\r\nOBD_FREE_PTR(conf);\r\n}\r\nstatic\r\nstruct sptlrpc_conf_tgt *sptlrpc_conf_get_tgt(struct sptlrpc_conf *conf,\r\nconst char *name,\r\nint create)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nlist_for_each_entry(conf_tgt, &conf->sc_tgts, sct_list) {\r\nif (strcmp(conf_tgt->sct_name, name) == 0)\r\nreturn conf_tgt;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nOBD_ALLOC_PTR(conf_tgt);\r\nif (conf_tgt) {\r\nstrlcpy(conf_tgt->sct_name, name, sizeof(conf_tgt->sct_name));\r\nsptlrpc_rule_set_init(&conf_tgt->sct_rset);\r\nlist_add(&conf_tgt->sct_list, &conf->sc_tgts);\r\n}\r\nreturn conf_tgt;\r\n}\r\nstatic\r\nstruct sptlrpc_conf *sptlrpc_conf_get(const char *fsname,\r\nint create)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nlist_for_each_entry(conf, &sptlrpc_confs, sc_list) {\r\nif (strcmp(conf->sc_fsname, fsname) == 0)\r\nreturn conf;\r\n}\r\nif (!create)\r\nreturn NULL;\r\nOBD_ALLOC_PTR(conf);\r\nif (conf == NULL)\r\nreturn NULL;\r\nstrcpy(conf->sc_fsname, fsname);\r\nsptlrpc_rule_set_init(&conf->sc_rset);\r\nINIT_LIST_HEAD(&conf->sc_tgts);\r\nlist_add(&conf->sc_list, &sptlrpc_confs);\r\nCDEBUG(D_SEC, "create sptlrpc conf %s\n", conf->sc_fsname);\r\nreturn conf;\r\n}\r\nstatic int sptlrpc_conf_merge_rule(struct sptlrpc_conf *conf,\r\nconst char *target,\r\nstruct sptlrpc_rule *rule)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nstruct sptlrpc_rule_set *rule_set;\r\nif (strcmp(conf->sc_fsname, target) == 0) {\r\nrule_set = &conf->sc_rset;\r\n} else {\r\nconf_tgt = sptlrpc_conf_get_tgt(conf, target, 1);\r\nif (conf_tgt) {\r\nrule_set = &conf_tgt->sct_rset;\r\n} else {\r\nCERROR("out of memory, can't merge rule!\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn sptlrpc_rule_set_merge(rule_set, rule);\r\n}\r\nstatic int __sptlrpc_process_config(struct lustre_cfg *lcfg,\r\nstruct sptlrpc_conf *conf)\r\n{\r\nchar *target, *param;\r\nchar fsname[MTI_NAME_MAXLEN];\r\nstruct sptlrpc_rule rule;\r\nint rc;\r\ntarget = lustre_cfg_string(lcfg, 1);\r\nif (target == NULL) {\r\nCERROR("missing target name\n");\r\nreturn -EINVAL;\r\n}\r\nparam = lustre_cfg_string(lcfg, 2);\r\nif (param == NULL) {\r\nCERROR("missing parameter\n");\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_SEC, "processing rule: %s.%s\n", target, param);\r\nif (strncmp(param, PARAM_SRPC_FLVR, sizeof(PARAM_SRPC_FLVR) - 1) != 0) {\r\nCERROR("Invalid sptlrpc parameter: %s\n", param);\r\nreturn -EINVAL;\r\n}\r\nparam += sizeof(PARAM_SRPC_FLVR) - 1;\r\nrc = sptlrpc_parse_rule(param, &rule);\r\nif (rc)\r\nreturn -EINVAL;\r\nif (conf == NULL) {\r\ntarget2fsname(target, fsname, sizeof(fsname));\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf == NULL) {\r\nCERROR("can't find conf\n");\r\nrc = -ENOMEM;\r\n} else {\r\nrc = sptlrpc_conf_merge_rule(conf, target, &rule);\r\n}\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n} else {\r\nLASSERT(mutex_is_locked(&sptlrpc_conf_lock));\r\nrc = sptlrpc_conf_merge_rule(conf, target, &rule);\r\n}\r\nif (rc == 0)\r\nconf->sc_modified++;\r\nreturn rc;\r\n}\r\nint sptlrpc_process_config(struct lustre_cfg *lcfg)\r\n{\r\nreturn __sptlrpc_process_config(lcfg, NULL);\r\n}\r\nstatic int logname2fsname(const char *logname, char *buf, int buflen)\r\n{\r\nchar *ptr;\r\nint len;\r\nptr = strrchr(logname, '-');\r\nif (ptr == NULL || strcmp(ptr, "-sptlrpc")) {\r\nCERROR("%s is not a sptlrpc config log\n", logname);\r\nreturn -EINVAL;\r\n}\r\nlen = min((int) (ptr - logname), buflen - 1);\r\nmemcpy(buf, logname, len);\r\nbuf[len] = '\0';\r\nreturn 0;\r\n}\r\nvoid sptlrpc_conf_log_update_begin(const char *logname)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf && conf->sc_local) {\r\nLASSERT(conf->sc_updated == 0);\r\nsptlrpc_conf_free_rsets(conf);\r\n}\r\nconf->sc_modified = 0;\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nvoid sptlrpc_conf_log_update_end(const char *logname)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf) {\r\nif (conf->sc_updated == 0)\r\nconf->sc_modified++;\r\nconf->sc_updated = 1;\r\n}\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nvoid sptlrpc_conf_log_start(const char *logname)\r\n{\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nsptlrpc_conf_get(fsname, 1);\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nvoid sptlrpc_conf_log_stop(const char *logname)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nchar fsname[16];\r\nif (logname2fsname(logname, fsname, sizeof(fsname)))\r\nreturn;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf)\r\nsptlrpc_conf_free(conf);\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}\r\nstatic void inline flavor_set_flags(struct sptlrpc_flavor *sf,\r\nenum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nunsigned int fl_udesc)\r\n{\r\nif (sf->sf_rpc == SPTLRPC_FLVR_NULL)\r\nreturn;\r\nif (from == LUSTRE_SP_MDT) {\r\nsf->sf_flags |= PTLRPC_SEC_FL_ROOTONLY;\r\n} else if (from == LUSTRE_SP_CLI && to == LUSTRE_SP_OST) {\r\nsf->sf_flags |= PTLRPC_SEC_FL_ROOTONLY | PTLRPC_SEC_FL_BULK;\r\n} else if (from == LUSTRE_SP_CLI && to == LUSTRE_SP_MDT) {\r\nif (fl_udesc && sf->sf_rpc != SPTLRPC_FLVR_NULL)\r\nsf->sf_flags |= PTLRPC_SEC_FL_UDESC;\r\n}\r\n}\r\nvoid sptlrpc_conf_choose_flavor(enum lustre_sec_part from,\r\nenum lustre_sec_part to,\r\nstruct obd_uuid *target,\r\nlnet_nid_t nid,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nchar name[MTI_NAME_MAXLEN];\r\nint len, rc = 0;\r\ntarget2fsname(target->uuid, name, sizeof(name));\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(name, 0);\r\nif (conf == NULL)\r\ngoto out;\r\nlen = strlen(target->uuid);\r\nLASSERT(len > 5);\r\nmemcpy(name, target->uuid, len - 5);\r\nname[len - 5] = '\0';\r\nconf_tgt = sptlrpc_conf_get_tgt(conf, name, 0);\r\nif (conf_tgt) {\r\nrc = sptlrpc_rule_set_choose(&conf_tgt->sct_rset,\r\nfrom, to, nid, sf);\r\nif (rc)\r\ngoto out;\r\n}\r\nrc = sptlrpc_rule_set_choose(&conf->sc_rset, from, to, nid, sf);\r\nout:\r\nmutex_unlock(&sptlrpc_conf_lock);\r\nif (rc == 0)\r\nget_default_flavor(sf);\r\nflavor_set_flags(sf, from, to, 1);\r\n}\r\nvoid sptlrpc_target_choose_flavor(struct sptlrpc_rule_set *rset,\r\nenum lustre_sec_part from,\r\nlnet_nid_t nid,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nif (sptlrpc_rule_set_choose(rset, from, LUSTRE_SP_ANY, nid, sf) == 0)\r\nget_default_flavor(sf);\r\n}\r\nvoid sptlrpc_conf_client_adapt(struct obd_device *obd)\r\n{\r\nstruct obd_import *imp;\r\nLASSERT(strcmp(obd->obd_type->typ_name, LUSTRE_MDC_NAME) == 0 ||\r\nstrcmp(obd->obd_type->typ_name, LUSTRE_OSC_NAME) ==0);\r\nCDEBUG(D_SEC, "obd %s\n", obd->u.cli.cl_target_uuid.uuid);\r\ndown_read(&obd->u.cli.cl_sem);\r\nimp = obd->u.cli.cl_import;\r\nif (imp) {\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_sec)\r\nimp->imp_sec_expire = cfs_time_current_sec() +\r\nSEC_ADAPT_DELAY;\r\nspin_unlock(&imp->imp_lock);\r\n}\r\nup_read(&obd->u.cli.cl_sem);\r\n}\r\nstatic void rule2string(struct sptlrpc_rule *r, char *buf, int buflen)\r\n{\r\nchar dirbuf[8];\r\nchar *net;\r\nchar *ptr = buf;\r\nif (r->sr_netid == LNET_NIDNET(LNET_NID_ANY))\r\nnet = "default";\r\nelse\r\nnet = libcfs_net2str(r->sr_netid);\r\nif (r->sr_from == LUSTRE_SP_ANY && r->sr_to == LUSTRE_SP_ANY)\r\ndirbuf[0] = '\0';\r\nelse\r\nsnprintf(dirbuf, sizeof(dirbuf), ".%s2%s",\r\nsptlrpc_part2name(r->sr_from),\r\nsptlrpc_part2name(r->sr_to));\r\nptr += snprintf(buf, buflen, "srpc.flavor.%s%s=", net, dirbuf);\r\nsptlrpc_flavor2name(&r->sr_flvr, ptr, buflen - (ptr - buf));\r\nbuf[buflen - 1] = '\0';\r\n}\r\nstatic int sptlrpc_record_rule_set(struct llog_handle *llh,\r\nchar *target,\r\nstruct sptlrpc_rule_set *rset)\r\n{\r\nstruct lustre_cfg_bufs bufs;\r\nstruct lustre_cfg *lcfg;\r\nstruct llog_rec_hdr rec;\r\nint buflen;\r\nchar param[48];\r\nint i, rc;\r\nfor (i = 0; i < rset->srs_nrule; i++) {\r\nrule2string(&rset->srs_rules[i], param, sizeof(param));\r\nlustre_cfg_bufs_reset(&bufs, NULL);\r\nlustre_cfg_bufs_set_string(&bufs, 1, target);\r\nlustre_cfg_bufs_set_string(&bufs, 2, param);\r\nlcfg = lustre_cfg_new(LCFG_SPTLRPC_CONF, &bufs);\r\nLASSERT(lcfg);\r\nbuflen = lustre_cfg_len(lcfg->lcfg_bufcount,\r\nlcfg->lcfg_buflens);\r\nrec.lrh_len = llog_data_len(buflen);\r\nrec.lrh_type = OBD_CFG_REC;\r\nrc = llog_write(NULL, llh, &rec, NULL, 0, (void *)lcfg, -1);\r\nif (rc)\r\nCERROR("failed to write a rec: rc = %d\n", rc);\r\nlustre_cfg_free(lcfg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sptlrpc_record_rules(struct llog_handle *llh,\r\nstruct sptlrpc_conf *conf)\r\n{\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nsptlrpc_record_rule_set(llh, conf->sc_fsname, &conf->sc_rset);\r\nlist_for_each_entry(conf_tgt, &conf->sc_tgts, sct_list) {\r\nsptlrpc_record_rule_set(llh, conf_tgt->sct_name,\r\n&conf_tgt->sct_rset);\r\n}\r\nreturn 0;\r\n}\r\nstatic\r\nint sptlrpc_target_local_copy_conf(struct obd_device *obd,\r\nstruct sptlrpc_conf *conf)\r\n{\r\nstruct llog_handle *llh = NULL;\r\nstruct llog_ctxt *ctxt;\r\nstruct lvfs_run_ctxt saved;\r\nstruct dentry *dentry;\r\nint rc;\r\nctxt = llog_get_context(obd, LLOG_CONFIG_ORIG_CTXT);\r\nif (ctxt == NULL)\r\nreturn -EINVAL;\r\npush_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\ndentry = ll_lookup_one_len(MOUNT_CONFIGS_DIR, cfs_fs_pwd(current->fs),\r\nstrlen(MOUNT_CONFIGS_DIR));\r\nif (IS_ERR(dentry)) {\r\nrc = PTR_ERR(dentry);\r\nCERROR("cannot lookup %s directory: rc = %d\n",\r\nMOUNT_CONFIGS_DIR, rc);\r\nGOTO(out_ctx, rc);\r\n}\r\nrc = llog_erase(NULL, ctxt, NULL, LOG_SPTLRPC_TMP);\r\nif (rc < 0 && rc != -ENOENT) {\r\nCERROR("%s: cannot erase temporary sptlrpc log: rc = %d\n",\r\nobd->obd_name, rc);\r\nGOTO(out_dput, rc);\r\n}\r\nrc = llog_open_create(NULL, ctxt, &llh, NULL, LOG_SPTLRPC_TMP);\r\nif (rc)\r\nGOTO(out_dput, rc);\r\nrc = llog_init_handle(NULL, llh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nrc = sptlrpc_record_rules(llh, conf);\r\nout_close:\r\nllog_close(NULL, llh);\r\nif (rc == 0)\r\nrc = lustre_rename(dentry, obd->obd_lvfs_ctxt.pwdmnt,\r\nLOG_SPTLRPC_TMP, LOG_SPTLRPC);\r\nout_dput:\r\nl_dput(dentry);\r\nout_ctx:\r\npop_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nCDEBUG(D_SEC, "target %s: write local sptlrpc conf: rc = %d\n",\r\nobd->obd_name, rc);\r\nreturn rc;\r\n}\r\nstatic int local_read_handler(const struct lu_env *env,\r\nstruct llog_handle *llh,\r\nstruct llog_rec_hdr *rec, void *data)\r\n{\r\nstruct sptlrpc_conf *conf = (struct sptlrpc_conf *) data;\r\nstruct lustre_cfg *lcfg = (struct lustre_cfg *)(rec + 1);\r\nint cfg_len, rc;\r\nif (rec->lrh_type != OBD_CFG_REC) {\r\nCERROR("unhandled lrh_type: %#x\n", rec->lrh_type);\r\nreturn -EINVAL;\r\n}\r\ncfg_len = rec->lrh_len - sizeof(struct llog_rec_hdr) -\r\nsizeof(struct llog_rec_tail);\r\nrc = lustre_cfg_sanity_check(lcfg, cfg_len);\r\nif (rc) {\r\nCERROR("Insane cfg\n");\r\nreturn rc;\r\n}\r\nif (lcfg->lcfg_command != LCFG_SPTLRPC_CONF) {\r\nCERROR("invalid command (%x)\n", lcfg->lcfg_command);\r\nreturn -EINVAL;\r\n}\r\nreturn __sptlrpc_process_config(lcfg, conf);\r\n}\r\nstatic\r\nint sptlrpc_target_local_read_conf(struct obd_device *obd,\r\nstruct sptlrpc_conf *conf)\r\n{\r\nstruct llog_handle *llh = NULL;\r\nstruct llog_ctxt *ctxt;\r\nstruct lvfs_run_ctxt saved;\r\nint rc;\r\nLASSERT(conf->sc_updated == 0 && conf->sc_local == 0);\r\nctxt = llog_get_context(obd, LLOG_CONFIG_ORIG_CTXT);\r\nif (ctxt == NULL) {\r\nCERROR("missing llog context\n");\r\nreturn -EINVAL;\r\n}\r\npush_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nrc = llog_open(NULL, ctxt, &llh, NULL, LOG_SPTLRPC, LLOG_OPEN_EXISTS);\r\nif (rc < 0) {\r\nif (rc == -ENOENT)\r\nrc = 0;\r\nGOTO(out_pop, rc);\r\n}\r\nrc = llog_init_handle(NULL, llh, LLOG_F_IS_PLAIN, NULL);\r\nif (rc)\r\nGOTO(out_close, rc);\r\nif (llog_get_size(llh) <= 1) {\r\nCDEBUG(D_SEC, "no local sptlrpc copy found\n");\r\nGOTO(out_close, rc = 0);\r\n}\r\nrc = llog_process(NULL, llh, local_read_handler, (void *)conf, NULL);\r\nif (rc == 0) {\r\nconf->sc_local = 1;\r\n} else {\r\nsptlrpc_conf_free_rsets(conf);\r\n}\r\nout_close:\r\nllog_close(NULL, llh);\r\nout_pop:\r\npop_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nllog_ctxt_put(ctxt);\r\nCDEBUG(D_SEC, "target %s: read local sptlrpc conf: rc = %d\n",\r\nobd->obd_name, rc);\r\nreturn rc;\r\n}\r\nint sptlrpc_conf_target_get_rules(struct obd_device *obd,\r\nstruct sptlrpc_rule_set *rset,\r\nint initial)\r\n{\r\nstruct sptlrpc_conf *conf;\r\nstruct sptlrpc_conf_tgt *conf_tgt;\r\nenum lustre_sec_part sp_dst;\r\nchar fsname[MTI_NAME_MAXLEN];\r\nint rc = 0;\r\nif (strcmp(obd->obd_type->typ_name, LUSTRE_MDT_NAME) == 0) {\r\nsp_dst = LUSTRE_SP_MDT;\r\n} else if (strcmp(obd->obd_type->typ_name, LUSTRE_OST_NAME) == 0) {\r\nsp_dst = LUSTRE_SP_OST;\r\n} else {\r\nCERROR("unexpected obd type %s\n", obd->obd_type->typ_name);\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_SEC, "get rules for target %s\n", obd->obd_uuid.uuid);\r\ntarget2fsname(obd->obd_uuid.uuid, fsname, sizeof(fsname));\r\nmutex_lock(&sptlrpc_conf_lock);\r\nconf = sptlrpc_conf_get(fsname, 0);\r\nif (conf == NULL) {\r\nCERROR("missing sptlrpc config log\n");\r\nGOTO(out, rc);\r\n}\r\nif (conf->sc_updated == 0) {\r\nif (conf->sc_local)\r\nsptlrpc_conf_free_rsets(conf);\r\nsptlrpc_target_local_read_conf(obd, conf);\r\n} else {\r\nLASSERT(conf->sc_local == 0);\r\nif (initial || conf->sc_modified)\r\nsptlrpc_target_local_copy_conf(obd, conf);\r\nelse\r\nCDEBUG(D_SEC, "unchanged, skip updating local copy\n");\r\n}\r\nconf_tgt = sptlrpc_conf_get_tgt(conf, obd->obd_name, 0);\r\nrc = sptlrpc_rule_set_extract(&conf->sc_rset,\r\nconf_tgt ? &conf_tgt->sct_rset: NULL,\r\nLUSTRE_SP_ANY, sp_dst, rset);\r\nout:\r\nmutex_unlock(&sptlrpc_conf_lock);\r\nreturn rc;\r\n}\r\nint sptlrpc_conf_init(void)\r\n{\r\nmutex_init(&sptlrpc_conf_lock);\r\nreturn 0;\r\n}\r\nvoid sptlrpc_conf_fini(void)\r\n{\r\nstruct sptlrpc_conf *conf, *conf_next;\r\nmutex_lock(&sptlrpc_conf_lock);\r\nlist_for_each_entry_safe(conf, conf_next, &sptlrpc_confs, sc_list) {\r\nsptlrpc_conf_free(conf);\r\n}\r\nLASSERT(list_empty(&sptlrpc_confs));\r\nmutex_unlock(&sptlrpc_conf_lock);\r\n}
