static int led_init(struct cphy *cphy)\r\n{\r\ncphy_mdio_write(cphy, MDIO_MMD_PCS, 0x8304, 0xdddd);\r\nreturn 0;\r\n}\r\nstatic int led_link(struct cphy *cphy, u32 do_enable)\r\n{\r\nu32 led = 0;\r\n#define LINK_ENABLE_BIT 0x1\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_CTRL2, &led);\r\nif (do_enable & LINK_ENABLE_BIT) {\r\nled |= LINK_ENABLE_BIT;\r\ncphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_CTRL2, led);\r\n} else {\r\nled &= ~LINK_ENABLE_BIT;\r\ncphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_CTRL2, led);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88x201x_reset(struct cphy *cphy, int wait)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mv88x201x_interrupt_enable(struct cphy *cphy)\r\n{\r\ncphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL,\r\nMDIO_PMA_LASI_LSALARM);\r\nif (t1_is_asic(cphy->adapter)) {\r\nu32 elmer;\r\nt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\r\nelmer |= ELMER0_GP_BIT6;\r\nt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88x201x_interrupt_disable(struct cphy *cphy)\r\n{\r\ncphy_mdio_write(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_CTRL, 0x0);\r\nif (t1_is_asic(cphy->adapter)) {\r\nu32 elmer;\r\nt1_tpi_read(cphy->adapter, A_ELMER0_INT_ENABLE, &elmer);\r\nelmer &= ~ELMER0_GP_BIT6;\r\nt1_tpi_write(cphy->adapter, A_ELMER0_INT_ENABLE, elmer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88x201x_interrupt_clear(struct cphy *cphy)\r\n{\r\nu32 elmer;\r\nu32 val;\r\n#ifdef MV88x2010_LINK_STATUS_BUGS\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_RXSTAT, &val);\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_TXSTAT, &val);\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT, &val);\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\r\n#endif\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_STAT, &val);\r\n#ifdef MV88x2010_LINK_STATUS_BUGS\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_RXSTAT, &val);\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_PMA_LASI_TXSTAT, &val);\r\n#endif\r\nif (t1_is_asic(cphy->adapter)) {\r\nt1_tpi_read(cphy->adapter, A_ELMER0_INT_CAUSE, &elmer);\r\nelmer |= ELMER0_GP_BIT6;\r\nt1_tpi_write(cphy->adapter, A_ELMER0_INT_CAUSE, elmer);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mv88x201x_interrupt_handler(struct cphy *cphy)\r\n{\r\nmv88x201x_interrupt_clear(cphy);\r\nreturn cphy_cause_link_change;\r\n}\r\nstatic int mv88x201x_set_loopback(struct cphy *cphy, int on)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mv88x201x_get_link_status(struct cphy *cphy, int *link_ok,\r\nint *speed, int *duplex, int *fc)\r\n{\r\nu32 val = 0;\r\nif (link_ok) {\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT1, &val);\r\nval &= MDIO_STAT1_LSTATUS;\r\n*link_ok = (val == MDIO_STAT1_LSTATUS);\r\nled_link(cphy, *link_ok);\r\n}\r\nif (speed)\r\n*speed = SPEED_10000;\r\nif (duplex)\r\n*duplex = DUPLEX_FULL;\r\nif (fc)\r\n*fc = PAUSE_RX | PAUSE_TX;\r\nreturn 0;\r\n}\r\nstatic void mv88x201x_destroy(struct cphy *cphy)\r\n{\r\nkfree(cphy);\r\n}\r\nstatic struct cphy *mv88x201x_phy_create(struct net_device *dev, int phy_addr,\r\nconst struct mdio_ops *mdio_ops)\r\n{\r\nu32 val;\r\nstruct cphy *cphy = kzalloc(sizeof(*cphy), GFP_KERNEL);\r\nif (!cphy)\r\nreturn NULL;\r\ncphy_init(cphy, dev, phy_addr, &mv88x201x_ops, mdio_ops);\r\ncphy_mdio_read(cphy, MDIO_MMD_PCS, 0x8300, &val);\r\ncphy_mdio_write(cphy, MDIO_MMD_PCS, 0x8300, val | 1);\r\ncphy_mdio_read(cphy, MDIO_MMD_PMAPMD, MDIO_STAT2, &val);\r\ncphy_mdio_read(cphy, MDIO_MMD_PCS, MDIO_STAT2, &val);\r\nled_init(cphy);\r\nreturn cphy;\r\n}\r\nstatic int mv88x201x_phy_reset(adapter_t *adapter)\r\n{\r\nu32 val;\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval &= ~4;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nmsleep(100);\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val | 4);\r\nmsleep(1000);\r\nt1_tpi_read(adapter, A_ELMER0_GPO, &val);\r\nval |= 0x8000;\r\nt1_tpi_write(adapter, A_ELMER0_GPO, val);\r\nudelay(100);\r\nreturn 0;\r\n}
