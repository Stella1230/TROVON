static void sh73a0_vccq_mc0_endisable(struct regulator_dev *reg, bool enable)\r\n{\r\nstruct sh_pfc *pfc = reg->reg_data;\r\nvoid __iomem *addr = pfc->window[1].virt + 4;\r\nunsigned long flags;\r\nu32 value;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nvalue = ioread32(addr);\r\nif (enable)\r\nvalue |= BIT(28);\r\nelse\r\nvalue &= ~BIT(28);\r\niowrite32(value, addr);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\n}\r\nstatic int sh73a0_vccq_mc0_enable(struct regulator_dev *reg)\r\n{\r\nsh73a0_vccq_mc0_endisable(reg, true);\r\nreturn 0;\r\n}\r\nstatic int sh73a0_vccq_mc0_disable(struct regulator_dev *reg)\r\n{\r\nsh73a0_vccq_mc0_endisable(reg, false);\r\nreturn 0;\r\n}\r\nstatic int sh73a0_vccq_mc0_is_enabled(struct regulator_dev *reg)\r\n{\r\nstruct sh_pfc *pfc = reg->reg_data;\r\nvoid __iomem *addr = pfc->window[1].virt + 4;\r\nunsigned long flags;\r\nu32 value;\r\nspin_lock_irqsave(&pfc->lock, flags);\r\nvalue = ioread32(addr);\r\nspin_unlock_irqrestore(&pfc->lock, flags);\r\nreturn !!(value & BIT(28));\r\n}\r\nstatic int sh73a0_vccq_mc0_get_voltage(struct regulator_dev *reg)\r\n{\r\nreturn 3300000;\r\n}\r\nstatic unsigned int sh73a0_pinmux_get_bias(struct sh_pfc *pfc, unsigned int pin)\r\n{\r\nvoid __iomem *addr = pfc->window->virt\r\n+ sh73a0_portcr_offsets[pin >> 5] + pin;\r\nu32 value = ioread8(addr) & PORTnCR_PULMD_MASK;\r\nswitch (value) {\r\ncase PORTnCR_PULMD_UP:\r\nreturn PIN_CONFIG_BIAS_PULL_UP;\r\ncase PORTnCR_PULMD_DOWN:\r\nreturn PIN_CONFIG_BIAS_PULL_DOWN;\r\ncase PORTnCR_PULMD_OFF:\r\ndefault:\r\nreturn PIN_CONFIG_BIAS_DISABLE;\r\n}\r\n}\r\nstatic void sh73a0_pinmux_set_bias(struct sh_pfc *pfc, unsigned int pin,\r\nunsigned int bias)\r\n{\r\nvoid __iomem *addr = pfc->window->virt\r\n+ sh73a0_portcr_offsets[pin >> 5] + pin;\r\nu32 value = ioread8(addr) & ~PORTnCR_PULMD_MASK;\r\nswitch (bias) {\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nvalue |= PORTnCR_PULMD_UP;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nvalue |= PORTnCR_PULMD_DOWN;\r\nbreak;\r\n}\r\niowrite8(value, addr);\r\n}\r\nstatic int sh73a0_pinmux_soc_init(struct sh_pfc *pfc)\r\n{\r\nstruct sh73a0_pinmux_data *data;\r\nstruct regulator_config cfg = { };\r\nint ret;\r\ndata = devm_kzalloc(pfc->dev, sizeof(*data), GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\ncfg.dev = pfc->dev;\r\ncfg.init_data = &sh73a0_vccq_mc0_init_data;\r\ncfg.driver_data = pfc;\r\ndata->vccq_mc0 = regulator_register(&sh73a0_vccq_mc0_desc, &cfg);\r\nif (IS_ERR(data->vccq_mc0)) {\r\nret = PTR_ERR(data->vccq_mc0);\r\ndev_err(pfc->dev, "Failed to register VCCQ MC0 regulator: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\npfc->soc_data = data;\r\nreturn 0;\r\n}\r\nstatic void sh73a0_pinmux_soc_exit(struct sh_pfc *pfc)\r\n{\r\nstruct sh73a0_pinmux_data *data = pfc->soc_data;\r\nregulator_unregister(data->vccq_mc0);\r\n}
