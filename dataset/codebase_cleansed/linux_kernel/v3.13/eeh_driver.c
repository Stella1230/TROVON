static inline const char *eeh_pcid_name(struct pci_dev *pdev)\r\n{\r\nif (pdev && pdev->dev.driver)\r\nreturn pdev->dev.driver->name;\r\nreturn "";\r\n}\r\nstatic inline struct pci_driver *eeh_pcid_get(struct pci_dev *pdev)\r\n{\r\nif (!pdev || !pdev->driver)\r\nreturn NULL;\r\nif (!try_module_get(pdev->driver->driver.owner))\r\nreturn NULL;\r\nreturn pdev->driver;\r\n}\r\nstatic inline void eeh_pcid_put(struct pci_dev *pdev)\r\n{\r\nif (!pdev || !pdev->driver)\r\nreturn;\r\nmodule_put(pdev->driver->driver.owner);\r\n}\r\nstatic void eeh_disable_irq(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nif (dev->msi_enabled || dev->msix_enabled)\r\nreturn;\r\nif (!irq_has_action(dev->irq))\r\nreturn;\r\nedev->mode |= EEH_DEV_IRQ_DISABLED;\r\ndisable_irq_nosync(dev->irq);\r\n}\r\nstatic void eeh_enable_irq(struct pci_dev *dev)\r\n{\r\nstruct eeh_dev *edev = pci_dev_to_eeh_dev(dev);\r\nstruct irq_desc *desc;\r\nif ((edev->mode) & EEH_DEV_IRQ_DISABLED) {\r\nedev->mode &= ~EEH_DEV_IRQ_DISABLED;\r\ndesc = irq_to_desc(dev->irq);\r\nif (desc && desc->depth > 0)\r\nenable_irq(dev->irq);\r\n}\r\n}\r\nstatic void *eeh_report_error(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_frozen;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->error_detected(dev, pci_channel_io_frozen);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_mmio_enabled(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\nif (!driver->err_handler ||\r\n!driver->err_handler->mmio_enabled) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->mmio_enabled(dev);\r\nif (rc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\nif (*res == PCI_ERS_RESULT_NONE) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_reset(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nenum pci_ers_result rc, *res = userdata;\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_normal;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->slot_reset) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nrc = driver->err_handler->slot_reset(dev);\r\nif ((*res == PCI_ERS_RESULT_NONE) ||\r\n(*res == PCI_ERS_RESULT_RECOVERED)) *res = rc;\r\nif (*res == PCI_ERS_RESULT_DISCONNECT &&\r\nrc == PCI_ERS_RESULT_NEED_RESET) *res = rc;\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_resume(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_normal;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_enable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->resume) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\ndriver->err_handler->resume(dev);\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_report_failure(void *data, void *userdata)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nstruct pci_driver *driver;\r\nif (!dev) return NULL;\r\ndev->error_state = pci_channel_io_perm_failure;\r\ndriver = eeh_pcid_get(dev);\r\nif (!driver) return NULL;\r\neeh_disable_irq(dev);\r\nif (!driver->err_handler ||\r\n!driver->err_handler->error_detected) {\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\ndriver->err_handler->error_detected(dev, pci_channel_io_perm_failure);\r\neeh_pcid_put(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_rmv_device(void *data, void *userdata)\r\n{\r\nstruct pci_driver *driver;\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dev *dev = eeh_dev_to_pci_dev(edev);\r\nint *removed = (int *)userdata;\r\nif (!dev || (dev->hdr_type & PCI_HEADER_TYPE_BRIDGE))\r\nreturn NULL;\r\ndriver = eeh_pcid_get(dev);\r\nif (driver && driver->err_handler)\r\nreturn NULL;\r\npr_debug("EEH: Removing %s without EEH sensitive driver\n",\r\npci_name(dev));\r\nedev->bus = dev->bus;\r\nedev->mode |= EEH_DEV_DISCONNECTED;\r\n(*removed)++;\r\npci_stop_and_remove_bus_device(dev);\r\nreturn NULL;\r\n}\r\nstatic void *eeh_pe_detach_dev(void *data, void *userdata)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nstruct eeh_dev *edev, *tmp;\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\nif (!(edev->mode & EEH_DEV_DISCONNECTED))\r\ncontinue;\r\nedev->mode &= ~(EEH_DEV_DISCONNECTED | EEH_DEV_IRQ_DISABLED);\r\neeh_rmv_from_parent_pe(edev);\r\n}\r\nreturn NULL;\r\n}\r\nstatic int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)\r\n{\r\nstruct pci_bus *frozen_bus = eeh_pe_bus_get(pe);\r\nstruct timeval tstamp;\r\nint cnt, rc, removed = 0;\r\ncnt = pe->freeze_count;\r\ntstamp = pe->tstamp;\r\neeh_pe_state_mark(pe, EEH_PE_KEEP);\r\nif (bus)\r\npcibios_remove_pci_devices(bus);\r\nelse if (frozen_bus)\r\neeh_pe_dev_traverse(pe, eeh_rmv_device, &removed);\r\nrc = eeh_reset_pe(pe);\r\nif (rc)\r\nreturn rc;\r\neeh_ops->configure_bridge(pe);\r\neeh_pe_restore_bars(pe);\r\nif (bus) {\r\npr_info("EEH: Sleep 5s ahead of complete hotplug\n");\r\nssleep(5);\r\neeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\r\npcibios_add_pci_devices(bus);\r\n} else if (frozen_bus && removed) {\r\npr_info("EEH: Sleep 5s ahead of partial hotplug\n");\r\nssleep(5);\r\neeh_pe_traverse(pe, eeh_pe_detach_dev, NULL);\r\npcibios_add_pci_devices(frozen_bus);\r\n}\r\neeh_pe_state_clear(pe, EEH_PE_KEEP);\r\npe->tstamp = tstamp;\r\npe->freeze_count = cnt;\r\nreturn 0;\r\n}\r\nstatic void eeh_handle_normal_event(struct eeh_pe *pe)\r\n{\r\nstruct pci_bus *frozen_bus;\r\nint rc = 0;\r\nenum pci_ers_result result = PCI_ERS_RESULT_NONE;\r\nfrozen_bus = eeh_pe_bus_get(pe);\r\nif (!frozen_bus) {\r\npr_err("%s: Cannot find PCI bus for PHB#%d-PE#%x\n",\r\n__func__, pe->phb->global_number, pe->addr);\r\nreturn;\r\n}\r\neeh_pe_update_time_stamp(pe);\r\npe->freeze_count++;\r\nif (pe->freeze_count > EEH_MAX_ALLOWED_FREEZES)\r\ngoto excess_failures;\r\npr_warning("EEH: This PCI device has failed %d times in the last hour\n",\r\npe->freeze_count);\r\npr_info("EEH: Notify device drivers to shutdown\n");\r\neeh_pe_dev_traverse(pe, eeh_report_error, &result);\r\nrc = eeh_ops->wait_state(pe, MAX_WAIT_FOR_RECOVERY*1000);\r\nif (rc < 0 || rc == EEH_STATE_NOT_SUPPORT) {\r\npr_warning("EEH: Permanent failure\n");\r\ngoto hard_fail;\r\n}\r\npr_info("EEH: Collect temporary log\n");\r\neeh_slot_error_detail(pe, EEH_LOG_TEMP);\r\nif (result == PCI_ERS_RESULT_NONE) {\r\npr_info("EEH: Reset with hotplug activity\n");\r\nrc = eeh_reset_device(pe, frozen_bus);\r\nif (rc) {\r\npr_warning("%s: Unable to reset, err=%d\n",\r\n__func__, rc);\r\ngoto hard_fail;\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\npr_info("EEH: Enable I/O for affected devices\n");\r\nrc = eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc) {\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\n} else {\r\npr_info("EEH: Notify device drivers to resume I/O\n");\r\nresult = PCI_ERS_RESULT_NONE;\r\neeh_pe_dev_traverse(pe, eeh_report_mmio_enabled, &result);\r\n}\r\n}\r\nif (result == PCI_ERS_RESULT_CAN_RECOVER) {\r\npr_info("EEH: Enabled DMA for affected devices\n");\r\nrc = eeh_pci_enable(pe, EEH_OPT_THAW_DMA);\r\nif (rc < 0)\r\ngoto hard_fail;\r\nif (rc)\r\nresult = PCI_ERS_RESULT_NEED_RESET;\r\nelse\r\nresult = PCI_ERS_RESULT_RECOVERED;\r\n}\r\nif (result == PCI_ERS_RESULT_DISCONNECT) {\r\npr_warning("EEH: Device driver gave up\n");\r\ngoto hard_fail;\r\n}\r\nif (result == PCI_ERS_RESULT_NEED_RESET) {\r\npr_info("EEH: Reset without hotplug activity\n");\r\nrc = eeh_reset_device(pe, NULL);\r\nif (rc) {\r\npr_warning("%s: Cannot reset, err=%d\n",\r\n__func__, rc);\r\ngoto hard_fail;\r\n}\r\npr_info("EEH: Notify device drivers "\r\n"the completion of reset\n");\r\nresult = PCI_ERS_RESULT_NONE;\r\neeh_pe_dev_traverse(pe, eeh_report_reset, &result);\r\n}\r\nif ((result != PCI_ERS_RESULT_RECOVERED) &&\r\n(result != PCI_ERS_RESULT_NONE)) {\r\npr_warning("EEH: Not recovered\n");\r\ngoto hard_fail;\r\n}\r\npr_info("EEH: Notify device driver to resume\n");\r\neeh_pe_dev_traverse(pe, eeh_report_resume, NULL);\r\nreturn;\r\nexcess_failures:\r\npr_err("EEH: PHB#%d-PE#%x has failed %d times in the\n"\r\n"last hour and has been permanently disabled.\n"\r\n"Please try reseating or replacing it.\n",\r\npe->phb->global_number, pe->addr,\r\npe->freeze_count);\r\ngoto perm_error;\r\nhard_fail:\r\npr_err("EEH: Unable to recover from failure from PHB#%d-PE#%x.\n"\r\n"Please try reseating or replacing it\n",\r\npe->phb->global_number, pe->addr);\r\nperm_error:\r\neeh_slot_error_detail(pe, EEH_LOG_PERM);\r\neeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\r\nif (frozen_bus)\r\npcibios_remove_pci_devices(frozen_bus);\r\n}\r\nstatic void eeh_handle_special_event(void)\r\n{\r\nstruct eeh_pe *pe, *phb_pe;\r\nstruct pci_bus *bus;\r\nstruct pci_controller *hose, *tmp;\r\nunsigned long flags;\r\nint rc = 0;\r\nrc = eeh_ops->next_error(&pe);\r\nif (rc <= 0)\r\nreturn;\r\nswitch (rc) {\r\ncase 4:\r\neeh_serialize_lock(&flags);\r\nlist_for_each_entry_safe(hose, tmp,\r\n&hose_list, list_node) {\r\nphb_pe = eeh_phb_pe_get(hose);\r\nif (!phb_pe) continue;\r\neeh_pe_state_mark(phb_pe,\r\nEEH_PE_ISOLATED | EEH_PE_PHB_DEAD);\r\n}\r\neeh_serialize_unlock(flags);\r\neeh_remove_event(NULL);\r\nbreak;\r\ncase 3:\r\ncase 2:\r\ncase 1:\r\neeh_serialize_lock(&flags);\r\nif (rc == 3)\r\neeh_pe_state_mark(pe,\r\nEEH_PE_ISOLATED | EEH_PE_PHB_DEAD);\r\nelse\r\neeh_pe_state_mark(pe,\r\nEEH_PE_ISOLATED | EEH_PE_RECOVERING);\r\neeh_serialize_unlock(flags);\r\neeh_remove_event(pe);\r\nbreak;\r\ndefault:\r\npr_err("%s: Invalid value %d from next_error()\n",\r\n__func__, rc);\r\nreturn;\r\n}\r\nif (rc == 2 || rc == 1)\r\neeh_handle_normal_event(pe);\r\nelse {\r\nlist_for_each_entry_safe(hose, tmp,\r\n&hose_list, list_node) {\r\nphb_pe = eeh_phb_pe_get(hose);\r\nif (!phb_pe || !(phb_pe->state & EEH_PE_PHB_DEAD))\r\ncontinue;\r\nbus = eeh_pe_bus_get(phb_pe);\r\neeh_pe_dev_traverse(pe, eeh_report_failure, NULL);\r\npcibios_remove_pci_devices(bus);\r\n}\r\n}\r\n}\r\nvoid eeh_handle_event(struct eeh_pe *pe)\r\n{\r\nif (pe)\r\neeh_handle_normal_event(pe);\r\nelse\r\neeh_handle_special_event();\r\n}
