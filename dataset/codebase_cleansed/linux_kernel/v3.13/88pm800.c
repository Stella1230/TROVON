static int device_gpadc_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nstruct pm80x_subchip *subchip = chip->subchip;\r\nstruct regmap *map = subchip->regmap_gpadc;\r\nint data = 0, mask = 0, ret = 0;\r\nif (!map) {\r\ndev_warn(chip->dev,\r\n"Warning: gpadc regmap is not available!\n");\r\nreturn -EINVAL;\r\n}\r\nret = regmap_update_bits(map,\r\nPM800_GPADC_MISC_CONFIG2,\r\nPM800_GPADC_MISC_GPFSM_EN,\r\nPM800_GPADC_MISC_GPFSM_EN);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(map, PM800_GPADC_MEAS_EN1,\r\nPM800_MEAS_EN1_VBAT, PM800_MEAS_EN1_VBAT);\r\nif (ret < 0)\r\ngoto out;\r\nret = regmap_update_bits(map, PM800_GPADC_MEAS_EN2,\r\n(PM800_MEAS_EN2_RFTMP | PM800_MEAS_GP0_EN),\r\n(PM800_MEAS_EN2_RFTMP | PM800_MEAS_GP0_EN));\r\nif (ret < 0)\r\ngoto out;\r\nmask = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN1 |\r\nPM800_GPADC_GP_BIAS_EN2 | PM800_GPADC_GP_BIAS_EN3);\r\nif (pdata && (pdata->batt_det == 0))\r\ndata = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN1 |\r\nPM800_GPADC_GP_BIAS_EN2 | PM800_GPADC_GP_BIAS_EN3);\r\nelse\r\ndata = (PM800_GPADC_GP_BIAS_EN0 | PM800_GPADC_GP_BIAS_EN2 |\r\nPM800_GPADC_GP_BIAS_EN3);\r\nret = regmap_update_bits(map, PM800_GP_BIAS_ENA1, mask, data);\r\nif (ret < 0)\r\ngoto out;\r\ndev_info(chip->dev, "pm800 device_gpadc_init: Done\n");\r\nreturn 0;\r\nout:\r\ndev_info(chip->dev, "pm800 device_gpadc_init: Failed!\n");\r\nreturn ret;\r\n}\r\nstatic int device_onkey_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nint ret;\r\nret = mfd_add_devices(chip->dev, 0, &onkey_devs[0],\r\nARRAY_SIZE(onkey_devs), &onkey_resources[0], 0,\r\nNULL);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to add onkey subdev\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_rtc_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nint ret;\r\nif (pdata) {\r\nrtc_devs[0].platform_data = pdata->rtc;\r\nrtc_devs[0].pdata_size =\r\npdata->rtc ? sizeof(struct pm80x_rtc_pdata) : 0;\r\n}\r\nret = mfd_add_devices(chip->dev, 0, &rtc_devs[0],\r\nARRAY_SIZE(rtc_devs), NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to add rtc subdev\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_regulator_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nint ret;\r\nret = mfd_add_devices(chip->dev, 0, &regulator_devs[0],\r\nARRAY_SIZE(regulator_devs), NULL, 0, NULL);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to add regulator subdev\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int device_irq_init_800(struct pm80x_chip *chip)\r\n{\r\nstruct regmap *map = chip->regmap;\r\nunsigned long flags = IRQF_ONESHOT;\r\nint data, mask, ret = -EINVAL;\r\nif (!map || !chip->irq) {\r\ndev_err(chip->dev, "incorrect parameters\n");\r\nreturn -EINVAL;\r\n}\r\nmask =\r\nPM800_WAKEUP2_INV_INT | PM800_WAKEUP2_INT_CLEAR |\r\nPM800_WAKEUP2_INT_MASK;\r\ndata = PM800_WAKEUP2_INT_CLEAR;\r\nret = regmap_update_bits(map, PM800_WAKEUP2, mask, data);\r\nif (ret < 0)\r\ngoto out;\r\nret =\r\nregmap_add_irq_chip(chip->regmap, chip->irq, flags, -1,\r\nchip->regmap_irq_chip, &chip->irq_data);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void device_irq_exit_800(struct pm80x_chip *chip)\r\n{\r\nregmap_del_irq_chip(chip->irq, chip->irq_data);\r\n}\r\nstatic int pm800_pages_init(struct pm80x_chip *chip)\r\n{\r\nstruct pm80x_subchip *subchip;\r\nstruct i2c_client *client = chip->client;\r\nint ret = 0;\r\nsubchip = chip->subchip;\r\nif (!subchip || !subchip->power_page_addr || !subchip->gpadc_page_addr)\r\nreturn -ENODEV;\r\nsubchip->power_page = i2c_new_dummy(client->adapter,\r\nsubchip->power_page_addr);\r\nif (subchip->power_page == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsubchip->regmap_power = devm_regmap_init_i2c(subchip->power_page,\r\n&pm80x_regmap_config);\r\nif (IS_ERR(subchip->regmap_power)) {\r\nret = PTR_ERR(subchip->regmap_power);\r\ndev_err(chip->dev,\r\n"Failed to allocate regmap_power: %d\n", ret);\r\ngoto out;\r\n}\r\ni2c_set_clientdata(subchip->power_page, chip);\r\nsubchip->gpadc_page = i2c_new_dummy(client->adapter,\r\nsubchip->gpadc_page_addr);\r\nif (subchip->gpadc_page == NULL) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nsubchip->regmap_gpadc = devm_regmap_init_i2c(subchip->gpadc_page,\r\n&pm80x_regmap_config);\r\nif (IS_ERR(subchip->regmap_gpadc)) {\r\nret = PTR_ERR(subchip->regmap_gpadc);\r\ndev_err(chip->dev,\r\n"Failed to allocate regmap_gpadc: %d\n", ret);\r\ngoto out;\r\n}\r\ni2c_set_clientdata(subchip->gpadc_page, chip);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void pm800_pages_exit(struct pm80x_chip *chip)\r\n{\r\nstruct pm80x_subchip *subchip;\r\nsubchip = chip->subchip;\r\nif (subchip && subchip->power_page)\r\ni2c_unregister_device(subchip->power_page);\r\nif (subchip && subchip->gpadc_page)\r\ni2c_unregister_device(subchip->gpadc_page);\r\n}\r\nstatic int device_800_init(struct pm80x_chip *chip,\r\nstruct pm80x_platform_data *pdata)\r\n{\r\nint ret;\r\nunsigned int val;\r\nret = regmap_read(chip->regmap, PM800_RTC_CONTROL, &val);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "Failed to read RTC register: %d\n", ret);\r\ngoto out;\r\n}\r\nif (val & PM800_ALARM_WAKEUP) {\r\nif (pdata && pdata->rtc)\r\npdata->rtc->rtc_wakeup = 1;\r\n}\r\nret = device_gpadc_init(chip, pdata);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "[%s]Failed to init gpadc\n", __func__);\r\ngoto out;\r\n}\r\nchip->regmap_irq_chip = &pm800_irq_chip;\r\nret = device_irq_init_800(chip);\r\nif (ret < 0) {\r\ndev_err(chip->dev, "[%s]Failed to init pm800 irq\n", __func__);\r\ngoto out;\r\n}\r\nret = device_onkey_init(chip, pdata);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to add onkey subdev\n");\r\ngoto out_dev;\r\n}\r\nret = device_rtc_init(chip, pdata);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to add rtc subdev\n");\r\ngoto out;\r\n}\r\nret = device_regulator_init(chip, pdata);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to add regulators subdev\n");\r\ngoto out;\r\n}\r\nreturn 0;\r\nout_dev:\r\nmfd_remove_devices(chip->dev);\r\ndevice_irq_exit_800(chip);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pm800_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret = 0;\r\nstruct pm80x_chip *chip;\r\nstruct pm80x_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct pm80x_subchip *subchip;\r\nret = pm80x_init(client);\r\nif (ret) {\r\ndev_err(&client->dev, "pm800_init fail\n");\r\ngoto out_init;\r\n}\r\nchip = i2c_get_clientdata(client);\r\nsubchip =\r\ndevm_kzalloc(&client->dev, sizeof(struct pm80x_subchip),\r\nGFP_KERNEL);\r\nif (!subchip) {\r\nret = -ENOMEM;\r\ngoto err_subchip_alloc;\r\n}\r\nsubchip->power_page_addr = client->addr + 1;\r\nsubchip->gpadc_page_addr = client->addr + 2;\r\nchip->subchip = subchip;\r\nret = pm800_pages_init(chip);\r\nif (ret) {\r\ndev_err(&client->dev, "pm800_pages_init failed!\n");\r\ngoto err_page_init;\r\n}\r\nret = device_800_init(chip, pdata);\r\nif (ret) {\r\ndev_err(chip->dev, "Failed to initialize 88pm800 devices\n");\r\ngoto err_device_init;\r\n}\r\nif (pdata && pdata->plat_config)\r\npdata->plat_config(chip, pdata);\r\nreturn 0;\r\nerr_device_init:\r\npm800_pages_exit(chip);\r\nerr_page_init:\r\nerr_subchip_alloc:\r\npm80x_deinit();\r\nout_init:\r\nreturn ret;\r\n}\r\nstatic int pm800_remove(struct i2c_client *client)\r\n{\r\nstruct pm80x_chip *chip = i2c_get_clientdata(client);\r\nmfd_remove_devices(chip->dev);\r\ndevice_irq_exit_800(chip);\r\npm800_pages_exit(chip);\r\npm80x_deinit();\r\nreturn 0;\r\n}\r\nstatic int __init pm800_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&pm800_driver);\r\n}\r\nstatic void __exit pm800_i2c_exit(void)\r\n{\r\ni2c_del_driver(&pm800_driver);\r\n}
