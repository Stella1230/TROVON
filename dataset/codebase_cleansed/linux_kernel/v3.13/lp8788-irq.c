static inline u8 _irq_to_addr(enum lp8788_int_id id)\r\n{\r\nreturn id / SIZE_REG;\r\n}\r\nstatic inline u8 _irq_to_enable_addr(enum lp8788_int_id id)\r\n{\r\nreturn _irq_to_addr(id) + BASE_INTEN_ADDR;\r\n}\r\nstatic inline u8 _irq_to_mask(enum lp8788_int_id id)\r\n{\r\nreturn 1 << (id % SIZE_REG);\r\n}\r\nstatic inline u8 _irq_to_val(enum lp8788_int_id id, int enable)\r\n{\r\nreturn enable << (id % SIZE_REG);\r\n}\r\nstatic void lp8788_irq_enable(struct irq_data *data)\r\n{\r\nstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\r\nirqd->enabled[data->hwirq] = 1;\r\n}\r\nstatic void lp8788_irq_disable(struct irq_data *data)\r\n{\r\nstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\r\nirqd->enabled[data->hwirq] = 0;\r\n}\r\nstatic void lp8788_irq_bus_lock(struct irq_data *data)\r\n{\r\nstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&irqd->irq_lock);\r\n}\r\nstatic void lp8788_irq_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct lp8788_irq_data *irqd = irq_data_get_irq_chip_data(data);\r\nenum lp8788_int_id irq = data->hwirq;\r\nu8 addr, mask, val;\r\naddr = _irq_to_enable_addr(irq);\r\nmask = _irq_to_mask(irq);\r\nval = _irq_to_val(irq, irqd->enabled[irq]);\r\nlp8788_update_bits(irqd->lp, addr, mask, val);\r\nmutex_unlock(&irqd->irq_lock);\r\n}\r\nstatic irqreturn_t lp8788_irq_handler(int irq, void *ptr)\r\n{\r\nstruct lp8788_irq_data *irqd = ptr;\r\nstruct lp8788 *lp = irqd->lp;\r\nu8 status[NUM_REGS], addr, mask;\r\nbool handled;\r\nint i;\r\nif (lp8788_read_multi_bytes(lp, LP8788_INT_1, status, NUM_REGS))\r\nreturn IRQ_NONE;\r\nfor (i = 0 ; i < LP8788_INT_MAX ; i++) {\r\naddr = _irq_to_addr(i);\r\nmask = _irq_to_mask(i);\r\nif (status[addr] & mask) {\r\nhandle_nested_irq(irq_find_mapping(irqd->domain, i));\r\nhandled = true;\r\n}\r\n}\r\nreturn handled ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nstatic int lp8788_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct lp8788_irq_data *irqd = d->host_data;\r\nstruct irq_chip *chip = &lp8788_irq_chip;\r\nirq_set_chip_data(virq, irqd);\r\nirq_set_chip_and_handler(virq, chip, handle_edge_irq);\r\nirq_set_nested_thread(virq, 1);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(virq);\r\n#endif\r\nreturn 0;\r\n}\r\nint lp8788_irq_init(struct lp8788 *lp, int irq)\r\n{\r\nstruct lp8788_irq_data *irqd;\r\nint ret;\r\nif (irq <= 0) {\r\ndev_warn(lp->dev, "invalid irq number: %d\n", irq);\r\nreturn 0;\r\n}\r\nirqd = devm_kzalloc(lp->dev, sizeof(*irqd), GFP_KERNEL);\r\nif (!irqd)\r\nreturn -ENOMEM;\r\nirqd->lp = lp;\r\nirqd->domain = irq_domain_add_linear(lp->dev->of_node, LP8788_INT_MAX,\r\n&lp8788_domain_ops, irqd);\r\nif (!irqd->domain) {\r\ndev_err(lp->dev, "failed to add irq domain err\n");\r\nreturn -EINVAL;\r\n}\r\nlp->irqdm = irqd->domain;\r\nmutex_init(&irqd->irq_lock);\r\nret = request_threaded_irq(irq, NULL, lp8788_irq_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"lp8788-irq", irqd);\r\nif (ret) {\r\ndev_err(lp->dev, "failed to create a thread for IRQ_N\n");\r\nreturn ret;\r\n}\r\nlp->irq = irq;\r\nreturn 0;\r\n}\r\nvoid lp8788_irq_exit(struct lp8788 *lp)\r\n{\r\nif (lp->irq)\r\nfree_irq(lp->irq, lp->irqdm);\r\n}
