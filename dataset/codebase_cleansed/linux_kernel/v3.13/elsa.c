static inline u_char\r\nreadreg(unsigned int ale, unsigned int adr, u_char off)\r\n{\r\nregister u_char ret;\r\nbyteout(ale, off);\r\nret = bytein(adr);\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nreadfifo(unsigned int ale, unsigned int adr, u_char off, u_char *data, int size)\r\n{\r\nbyteout(ale, off);\r\ninsb(adr, data, size);\r\n}\r\nstatic inline void\r\nwritereg(unsigned int ale, unsigned int adr, u_char off, u_char data)\r\n{\r\nbyteout(ale, off);\r\nbyteout(adr, data);\r\n}\r\nstatic inline void\r\nwritefifo(unsigned int ale, unsigned int adr, u_char off, u_char *data, int size)\r\n{\r\nbyteout(ale, off);\r\noutsb(adr, data, size);\r\n}\r\nstatic u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset));\r\n}\r\nstatic void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset, value);\r\n}\r\nstatic void\r\nReadISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nreadfifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwritefifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0, data, size);\r\n}\r\nstatic u_char\r\nReadISAC_IPAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset + 0x80));\r\n}\r\nstatic void\r\nWriteISAC_IPAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, offset | 0x80, value);\r\n}\r\nstatic void\r\nReadISACfifo_IPAC(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nreadfifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0x80, data, size);\r\n}\r\nstatic void\r\nWriteISACfifo_IPAC(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nwritefifo(cs->hw.elsa.ale, cs->hw.elsa.isac, 0x80, data, size);\r\n}\r\nstatic u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nreturn (readreg(cs->hw.elsa.ale,\r\ncs->hw.elsa.hscx, offset + (hscx ? 0x40 : 0)));\r\n}\r\nstatic void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\nwritereg(cs->hw.elsa.ale,\r\ncs->hw.elsa.hscx, offset + (hscx ? 0x40 : 0), value);\r\n}\r\nstatic inline u_char\r\nreaditac(struct IsdnCardState *cs, u_char off)\r\n{\r\nregister u_char ret;\r\nbyteout(cs->hw.elsa.ale, off);\r\nret = bytein(cs->hw.elsa.itac);\r\nreturn (ret);\r\n}\r\nstatic inline void\r\nwriteitac(struct IsdnCardState *cs, u_char off, u_char data)\r\n{\r\nbyteout(cs->hw.elsa.ale, off);\r\nbyteout(cs->hw.elsa.itac, data);\r\n}\r\nstatic inline int\r\nTimerRun(struct IsdnCardState *cs)\r\n{\r\nregister u_char v;\r\nv = bytein(cs->hw.elsa.cfg);\r\nif ((cs->subtyp == ELSA_QS1000) || (cs->subtyp == ELSA_QS3000))\r\nreturn (0 == (v & ELIRQF_TIMER_RUN));\r\nelse if (cs->subtyp == ELSA_PCC8)\r\nreturn (v & ELIRQF_TIMER_RUN_PCC8);\r\nreturn (v & ELIRQF_TIMER_RUN);\r\n}\r\nstatic irqreturn_t\r\nelsa_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_long flags;\r\nu_char val;\r\nint icnt = 5;\r\nif ((cs->typ == ISDN_CTYPE_ELSA_PCMCIA) && (*cs->busy_flag == 1)) {\r\nprintk(KERN_WARNING "Elsa: card not available!\n");\r\nreturn IRQ_NONE;\r\n}\r\nspin_lock_irqsave(&cs->lock, flags);\r\n#if ARCOFI_USE\r\nif (cs->hw.elsa.MFlag) {\r\nval = serial_inp(cs, UART_IIR);\r\nif (!(val & UART_IIR_NO_INT)) {\r\ndebugl1(cs, "IIR %02x", val);\r\nrs_interrupt_elsa(cs);\r\n}\r\n}\r\n#endif\r\nval = readreg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_ISTA + 0x40);\r\nStart_HSCX:\r\nif (val) {\r\nhscx_int_main(cs, val);\r\n}\r\nval = readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, ISAC_ISTA);\r\nStart_ISAC:\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\nval = readreg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_ISTA + 0x40);\r\nif (val && icnt) {\r\nif (cs->debug & L1_DEB_HSCX)\r\ndebugl1(cs, "HSCX IntStat after IntRoutine");\r\nicnt--;\r\ngoto Start_HSCX;\r\n}\r\nval = readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, ISAC_ISTA);\r\nif (val && icnt) {\r\nif (cs->debug & L1_DEB_ISAC)\r\ndebugl1(cs, "ISAC IntStat after IntRoutine");\r\nicnt--;\r\ngoto Start_ISAC;\r\n}\r\nif (!icnt)\r\nprintk(KERN_WARNING"ELSA IRQ LOOP\n");\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_MASK, 0xFF);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_MASK + 0x40, 0xFF);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, ISAC_MASK, 0xFF);\r\nif (cs->hw.elsa.status & ELIRQF_TIMER_AKTIV) {\r\nif (!TimerRun(cs)) {\r\nbyteout(cs->hw.elsa.timer, 0);\r\ncs->hw.elsa.counter++;\r\n}\r\n}\r\n#if ARCOFI_USE\r\nif (cs->hw.elsa.MFlag) {\r\nval = serial_inp(cs, UART_MCR);\r\nval ^= 0x8;\r\nserial_outp(cs, UART_MCR, val);\r\nval = serial_inp(cs, UART_MCR);\r\nval ^= 0x8;\r\nserial_outp(cs, UART_MCR, val);\r\n}\r\n#endif\r\nif (cs->hw.elsa.trig)\r\nbyteout(cs->hw.elsa.trig, 0x00);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_MASK, 0x0);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_MASK + 0x40, 0x0);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, ISAC_MASK, 0x0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t\r\nelsa_interrupt_ipac(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_long flags;\r\nu_char ista, val;\r\nint icnt = 5;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nif (cs->subtyp == ELSA_QS1000PCI || cs->subtyp == ELSA_QS3000PCI) {\r\nval = bytein(cs->hw.elsa.cfg + 0x4c);\r\nif (!(val & ELSA_PCI_IRQ_MASK)) {\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_NONE;\r\n}\r\n}\r\n#if ARCOFI_USE\r\nif (cs->hw.elsa.MFlag) {\r\nval = serial_inp(cs, UART_IIR);\r\nif (!(val & UART_IIR_NO_INT)) {\r\ndebugl1(cs, "IIR %02x", val);\r\nrs_interrupt_elsa(cs);\r\n}\r\n}\r\n#endif\r\nista = readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ISTA);\r\nStart_IPAC:\r\nif (cs->debug & L1_DEB_IPAC)\r\ndebugl1(cs, "IPAC ISTA %02X", ista);\r\nif (ista & 0x0f) {\r\nval = readreg(cs->hw.elsa.ale, cs->hw.elsa.hscx, HSCX_ISTA + 0x40);\r\nif (ista & 0x01)\r\nval |= 0x01;\r\nif (ista & 0x04)\r\nval |= 0x02;\r\nif (ista & 0x08)\r\nval |= 0x04;\r\nif (val)\r\nhscx_int_main(cs, val);\r\n}\r\nif (ista & 0x20) {\r\nval = 0xfe & readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, ISAC_ISTA + 0x80);\r\nif (val) {\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nif (ista & 0x10) {\r\nval = 0x01;\r\nisac_interrupt(cs, val);\r\n}\r\nista = readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ISTA);\r\nif ((ista & 0x3f) && icnt) {\r\nicnt--;\r\ngoto Start_IPAC;\r\n}\r\nif (!icnt)\r\nprintk(KERN_WARNING "ELSA IRQ LOOP\n");\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_MASK, 0xFF);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_MASK, 0xC0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\nrelease_io_elsa(struct IsdnCardState *cs)\r\n{\r\nint bytecnt = 8;\r\ndel_timer(&cs->hw.elsa.tl);\r\n#if ARCOFI_USE\r\nclear_arcofi(cs);\r\n#endif\r\nif (cs->hw.elsa.ctrl)\r\nbyteout(cs->hw.elsa.ctrl, 0);\r\nif (cs->subtyp == ELSA_QS1000PCI) {\r\nbyteout(cs->hw.elsa.cfg + 0x4c, 0x01);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ATX, 0xff);\r\nbytecnt = 2;\r\nrelease_region(cs->hw.elsa.cfg, 0x80);\r\n}\r\nif (cs->subtyp == ELSA_QS3000PCI) {\r\nbyteout(cs->hw.elsa.cfg + 0x4c, 0x03);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ATX, 0xff);\r\nrelease_region(cs->hw.elsa.cfg, 0x80);\r\n}\r\nif (cs->subtyp == ELSA_PCMCIA_IPAC) {\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ATX, 0xff);\r\n}\r\nif ((cs->subtyp == ELSA_PCFPRO) ||\r\n(cs->subtyp == ELSA_QS3000) ||\r\n(cs->subtyp == ELSA_PCF) ||\r\n(cs->subtyp == ELSA_QS3000PCI)) {\r\nbytecnt = 16;\r\n#if ARCOFI_USE\r\nrelease_modem(cs);\r\n#endif\r\n}\r\nif (cs->hw.elsa.base)\r\nrelease_region(cs->hw.elsa.base, bytecnt);\r\n}\r\nstatic void\r\nreset_elsa(struct IsdnCardState *cs)\r\n{\r\nif (cs->hw.elsa.timer) {\r\nbyteout(cs->hw.elsa.timer, 0);\r\nwhile (TimerRun(cs));\r\ncs->hw.elsa.ctrl_reg |= 0x50;\r\ncs->hw.elsa.ctrl_reg &= ~ELSA_ISDN_RESET;\r\nbyteout(cs->hw.elsa.ctrl, cs->hw.elsa.ctrl_reg);\r\nbyteout(cs->hw.elsa.timer, 0);\r\nwhile (TimerRun(cs));\r\ncs->hw.elsa.ctrl_reg |= ELSA_ISDN_RESET;\r\nbyteout(cs->hw.elsa.ctrl, cs->hw.elsa.ctrl_reg);\r\nbyteout(cs->hw.elsa.timer, 0);\r\nwhile (TimerRun(cs));\r\nif (cs->hw.elsa.trig)\r\nbyteout(cs->hw.elsa.trig, 0xff);\r\n}\r\nif ((cs->subtyp == ELSA_QS1000PCI) || (cs->subtyp == ELSA_QS3000PCI) || (cs->subtyp == ELSA_PCMCIA_IPAC)) {\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_POTA2, 0x20);\r\nmdelay(10);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_POTA2, 0x00);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_MASK, 0xc0);\r\nmdelay(10);\r\nif (cs->subtyp != ELSA_PCMCIA_IPAC) {\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ACFG, 0x0);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_AOE, 0x3c);\r\n} else {\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_PCFG, 0x10);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ACFG, 0x4);\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_AOE, 0xf8);\r\n}\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ATX, 0xff);\r\nif (cs->subtyp == ELSA_QS1000PCI)\r\nbyteout(cs->hw.elsa.cfg + 0x4c, 0x41);\r\nelse if (cs->subtyp == ELSA_QS3000PCI)\r\nbyteout(cs->hw.elsa.cfg + 0x4c, 0x43);\r\n}\r\n}\r\nstatic void\r\nset_arcofi(struct IsdnCardState *cs, int bc) {\r\ncs->dc.isac.arcofi_bc = bc;\r\narcofi_fsm(cs, ARCOFI_START, &ARCOFI_COP_5);\r\ninterruptible_sleep_on(&cs->dc.isac.arcofi_wait);\r\n}\r\nstatic int\r\ncheck_arcofi(struct IsdnCardState *cs)\r\n{\r\nint arcofi_present = 0;\r\nchar tmp[40];\r\nchar *t;\r\nu_char *p;\r\nif (!cs->dc.isac.mon_tx)\r\nif (!(cs->dc.isac.mon_tx = kmalloc(MAX_MON_FRAME, GFP_ATOMIC))) {\r\nif (cs->debug & L1_DEB_WARN)\r\ndebugl1(cs, "ISAC MON TX out of buffers!");\r\nreturn (0);\r\n}\r\ncs->dc.isac.arcofi_bc = 0;\r\narcofi_fsm(cs, ARCOFI_START, &ARCOFI_VERSION);\r\ninterruptible_sleep_on(&cs->dc.isac.arcofi_wait);\r\nif (!test_and_clear_bit(FLG_ARCOFI_ERROR, &cs->HW_Flags)) {\r\ndebugl1(cs, "Arcofi response received %d bytes", cs->dc.isac.mon_rxp);\r\np = cs->dc.isac.mon_rx;\r\nt = tmp;\r\nt += sprintf(tmp, "Arcofi data");\r\nQuickHex(t, p, cs->dc.isac.mon_rxp);\r\ndebugl1(cs, "%s", tmp);\r\nif ((cs->dc.isac.mon_rxp == 2) && (cs->dc.isac.mon_rx[0] == 0xa0)) {\r\nswitch (cs->dc.isac.mon_rx[1]) {\r\ncase 0x80:\r\ndebugl1(cs, "Arcofi 2160 detected");\r\narcofi_present = 1;\r\nbreak;\r\ncase 0x82:\r\ndebugl1(cs, "Arcofi 2165 detected");\r\narcofi_present = 2;\r\nbreak;\r\ncase 0x84:\r\ndebugl1(cs, "Arcofi 2163 detected");\r\narcofi_present = 3;\r\nbreak;\r\ndefault:\r\ndebugl1(cs, "unknown Arcofi response");\r\nbreak;\r\n}\r\n} else\r\ndebugl1(cs, "undefined Monitor response");\r\ncs->dc.isac.mon_rxp = 0;\r\n} else if (cs->dc.isac.mon_tx) {\r\ndebugl1(cs, "Arcofi not detected");\r\n}\r\nif (arcofi_present) {\r\nif (cs->subtyp == ELSA_QS1000) {\r\ncs->subtyp = ELSA_QS3000;\r\nprintk(KERN_INFO\r\n"Elsa: %s detected modem at 0x%lx\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base + 8);\r\nrelease_region(cs->hw.elsa.base, 8);\r\nif (!request_region(cs->hw.elsa.base, 16, "elsa isdn modem")) {\r\nprintk(KERN_WARNING\r\n"HiSax: %s config port %lx-%lx already in use\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base + 8,\r\ncs->hw.elsa.base + 16);\r\n}\r\n} else if (cs->subtyp == ELSA_PCC16) {\r\ncs->subtyp = ELSA_PCF;\r\nprintk(KERN_INFO\r\n"Elsa: %s detected modem at 0x%lx\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base + 8);\r\nrelease_region(cs->hw.elsa.base, 8);\r\nif (!request_region(cs->hw.elsa.base, 16, "elsa isdn modem")) {\r\nprintk(KERN_WARNING\r\n"HiSax: %s config port %lx-%lx already in use\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base + 8,\r\ncs->hw.elsa.base + 16);\r\n}\r\n} else\r\nprintk(KERN_INFO\r\n"Elsa: %s detected modem at 0x%lx\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base + 8);\r\narcofi_fsm(cs, ARCOFI_START, &ARCOFI_XOP_0);\r\ninterruptible_sleep_on(&cs->dc.isac.arcofi_wait);\r\nreturn (1);\r\n}\r\nreturn (0);\r\n}\r\nstatic void\r\nelsa_led_handler(struct IsdnCardState *cs)\r\n{\r\nint blink = 0;\r\nif (cs->subtyp == ELSA_PCMCIA || cs->subtyp == ELSA_PCMCIA_IPAC)\r\nreturn;\r\ndel_timer(&cs->hw.elsa.tl);\r\nif (cs->hw.elsa.status & ELSA_ASSIGN)\r\ncs->hw.elsa.ctrl_reg |= ELSA_STAT_LED;\r\nelse if (cs->hw.elsa.status & ELSA_BAD_PWR)\r\ncs->hw.elsa.ctrl_reg &= ~ELSA_STAT_LED;\r\nelse {\r\ncs->hw.elsa.ctrl_reg ^= ELSA_STAT_LED;\r\nblink = 250;\r\n}\r\nif (cs->hw.elsa.status & 0xf000)\r\ncs->hw.elsa.ctrl_reg |= ELSA_LINE_LED;\r\nelse if (cs->hw.elsa.status & 0x0f00) {\r\ncs->hw.elsa.ctrl_reg ^= ELSA_LINE_LED;\r\nblink = 500;\r\n} else\r\ncs->hw.elsa.ctrl_reg &= ~ELSA_LINE_LED;\r\nif ((cs->subtyp == ELSA_QS1000PCI) ||\r\n(cs->subtyp == ELSA_QS3000PCI)) {\r\nu_char led = 0xff;\r\nif (cs->hw.elsa.ctrl_reg & ELSA_LINE_LED)\r\nled ^= ELSA_IPAC_LINE_LED;\r\nif (cs->hw.elsa.ctrl_reg & ELSA_STAT_LED)\r\nled ^= ELSA_IPAC_STAT_LED;\r\nwritereg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ATX, led);\r\n} else\r\nbyteout(cs->hw.elsa.ctrl, cs->hw.elsa.ctrl_reg);\r\nif (blink) {\r\ninit_timer(&cs->hw.elsa.tl);\r\ncs->hw.elsa.tl.expires = jiffies + ((blink * HZ) / 1000);\r\nadd_timer(&cs->hw.elsa.tl);\r\n}\r\n}\r\nstatic int\r\nElsa_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nint ret = 0;\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nreset_elsa(cs);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_RELEASE:\r\nrelease_io_elsa(cs);\r\nreturn (0);\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->debug |= L1_DEB_IPAC;\r\nreset_elsa(cs);\r\ninithscxisac(cs, 1);\r\nif ((cs->subtyp == ELSA_QS1000) ||\r\n(cs->subtyp == ELSA_QS3000))\r\n{\r\nbyteout(cs->hw.elsa.timer, 0);\r\n}\r\nif (cs->hw.elsa.trig)\r\nbyteout(cs->hw.elsa.trig, 0xff);\r\ninithscxisac(cs, 2);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn (0);\r\ncase CARD_TEST:\r\nif ((cs->subtyp == ELSA_PCMCIA) ||\r\n(cs->subtyp == ELSA_PCMCIA_IPAC) ||\r\n(cs->subtyp == ELSA_QS1000PCI)) {\r\nreturn (0);\r\n} else if (cs->subtyp == ELSA_QS3000PCI) {\r\nret = 0;\r\n} else {\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.elsa.counter = 0;\r\ncs->hw.elsa.ctrl_reg |= ELSA_ENA_TIMER_INT;\r\ncs->hw.elsa.status |= ELIRQF_TIMER_AKTIV;\r\nbyteout(cs->hw.elsa.ctrl, cs->hw.elsa.ctrl_reg);\r\nbyteout(cs->hw.elsa.timer, 0);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nmsleep(110);\r\nspin_lock_irqsave(&cs->lock, flags);\r\ncs->hw.elsa.ctrl_reg &= ~ELSA_ENA_TIMER_INT;\r\nbyteout(cs->hw.elsa.ctrl, cs->hw.elsa.ctrl_reg);\r\ncs->hw.elsa.status &= ~ELIRQF_TIMER_AKTIV;\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nprintk(KERN_INFO "Elsa: %d timer tics in 110 msek\n",\r\ncs->hw.elsa.counter);\r\nif ((cs->hw.elsa.counter > 10) &&\r\n(cs->hw.elsa.counter < 16)) {\r\nprintk(KERN_INFO "Elsa: timer and irq OK\n");\r\nret = 0;\r\n} else {\r\nprintk(KERN_WARNING\r\n"Elsa: timer tic problem (%d/12) maybe an IRQ(%d) conflict\n",\r\ncs->hw.elsa.counter, cs->irq);\r\nret = 1;\r\n}\r\n}\r\n#if ARCOFI_USE\r\nif (check_arcofi(cs)) {\r\ninit_modem(cs);\r\n}\r\n#endif\r\nelsa_led_handler(cs);\r\nreturn (ret);\r\ncase (MDL_REMOVE | REQUEST):\r\ncs->hw.elsa.status &= 0;\r\nbreak;\r\ncase (MDL_ASSIGN | REQUEST):\r\ncs->hw.elsa.status |= ELSA_ASSIGN;\r\nbreak;\r\ncase MDL_INFO_SETUP:\r\nif ((long) arg)\r\ncs->hw.elsa.status |= 0x0200;\r\nelse\r\ncs->hw.elsa.status |= 0x0100;\r\nbreak;\r\ncase MDL_INFO_CONN:\r\nif ((long) arg)\r\ncs->hw.elsa.status |= 0x2000;\r\nelse\r\ncs->hw.elsa.status |= 0x1000;\r\nbreak;\r\ncase MDL_INFO_REL:\r\nif ((long) arg) {\r\ncs->hw.elsa.status &= ~0x2000;\r\ncs->hw.elsa.status &= ~0x0200;\r\n} else {\r\ncs->hw.elsa.status &= ~0x1000;\r\ncs->hw.elsa.status &= ~0x0100;\r\n}\r\nbreak;\r\n#if ARCOFI_USE\r\ncase CARD_AUX_IND:\r\nif (cs->hw.elsa.MFlag) {\r\nint len;\r\nu_char *msg;\r\nif (!arg)\r\nreturn (0);\r\nmsg = arg;\r\nlen = *msg;\r\nmsg++;\r\nmodem_write_cmd(cs, msg, len);\r\n}\r\nbreak;\r\n#endif\r\n}\r\nif (cs->typ == ISDN_CTYPE_ELSA) {\r\nint pwr = bytein(cs->hw.elsa.ale);\r\nif (pwr & 0x08)\r\ncs->hw.elsa.status |= ELSA_BAD_PWR;\r\nelse\r\ncs->hw.elsa.status &= ~ELSA_BAD_PWR;\r\n}\r\nelsa_led_handler(cs);\r\nreturn (ret);\r\n}\r\nstatic unsigned char\r\nprobe_elsa_adr(unsigned int adr, int typ)\r\n{\r\nint i, in1, in2, p16_1 = 0, p16_2 = 0, p8_1 = 0, p8_2 = 0, pc_1 = 0,\r\npc_2 = 0, pfp_1 = 0, pfp_2 = 0;\r\nif (typ != ISDN_CTYPE_ELSA_PCMCIA) {\r\nif (request_region(adr, 8, "elsa card")) {\r\nrelease_region(adr, 8);\r\n} else {\r\nprintk(KERN_WARNING\r\n"Elsa: Probing Port 0x%x: already in use\n", adr);\r\nreturn (0);\r\n}\r\n}\r\nfor (i = 0; i < 16; i++) {\r\nin1 = inb(adr + ELSA_CONFIG);\r\nin2 = inb(adr + ELSA_CONFIG);\r\np16_1 += 0x04 & in1;\r\np16_2 += 0x04 & in2;\r\np8_1 += 0x02 & in1;\r\np8_2 += 0x02 & in2;\r\npc_1 += 0x01 & in1;\r\npc_2 += 0x01 & in2;\r\npfp_1 += 0x40 & in1;\r\npfp_2 += 0x40 & in2;\r\n}\r\nprintk(KERN_INFO "Elsa: Probing IO 0x%x", adr);\r\nif (65 == ++p16_1 * ++p16_2) {\r\nprintk(" PCC-16/PCF found\n");\r\nreturn (ELSA_PCC16);\r\n} else if (1025 == ++pfp_1 * ++pfp_2) {\r\nprintk(" PCF-Pro found\n");\r\nreturn (ELSA_PCFPRO);\r\n} else if (33 == ++p8_1 * ++p8_2) {\r\nprintk(" PCC8 found\n");\r\nreturn (ELSA_PCC8);\r\n} else if (17 == ++pc_1 * ++pc_2) {\r\nprintk(" PC found\n");\r\nreturn (ELSA_PC);\r\n} else {\r\nprintk(" failed\n");\r\nreturn (0);\r\n}\r\n}\r\nstatic unsigned int\r\nprobe_elsa(struct IsdnCardState *cs)\r\n{\r\nint i;\r\nunsigned int CARD_portlist[] =\r\n{0x160, 0x170, 0x260, 0x360, 0};\r\nfor (i = 0; CARD_portlist[i]; i++) {\r\nif ((cs->subtyp = probe_elsa_adr(CARD_portlist[i], cs->typ)))\r\nbreak;\r\n}\r\nreturn (CARD_portlist[i]);\r\n}\r\nstatic int setup_elsa_isa(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nu_char val;\r\ncs->hw.elsa.base = card->para[0];\r\nprintk(KERN_INFO "Elsa: Microlink IO probing\n");\r\nif (cs->hw.elsa.base) {\r\nif (!(cs->subtyp = probe_elsa_adr(cs->hw.elsa.base,\r\ncs->typ))) {\r\nprintk(KERN_WARNING\r\n"Elsa: no Elsa Microlink at %#lx\n",\r\ncs->hw.elsa.base);\r\nreturn (0);\r\n}\r\n} else\r\ncs->hw.elsa.base = probe_elsa(cs);\r\nif (!cs->hw.elsa.base) {\r\nprintk(KERN_WARNING\r\n"No Elsa Microlink found\n");\r\nreturn (0);\r\n}\r\ncs->hw.elsa.cfg = cs->hw.elsa.base + ELSA_CONFIG;\r\ncs->hw.elsa.ctrl = cs->hw.elsa.base + ELSA_CONTROL;\r\ncs->hw.elsa.ale = cs->hw.elsa.base + ELSA_ALE;\r\ncs->hw.elsa.isac = cs->hw.elsa.base + ELSA_ISAC;\r\ncs->hw.elsa.itac = cs->hw.elsa.base + ELSA_ITAC;\r\ncs->hw.elsa.hscx = cs->hw.elsa.base + ELSA_HSCX;\r\ncs->hw.elsa.trig = cs->hw.elsa.base + ELSA_TRIG_IRQ;\r\ncs->hw.elsa.timer = cs->hw.elsa.base + ELSA_START_TIMER;\r\nval = bytein(cs->hw.elsa.cfg);\r\nif (cs->subtyp == ELSA_PC) {\r\nconst u_char CARD_IrqTab[8] =\r\n{7, 3, 5, 9, 0, 0, 0, 0};\r\ncs->irq = CARD_IrqTab[(val & ELSA_IRQ_IDX_PC) >> 2];\r\n} else if (cs->subtyp == ELSA_PCC8) {\r\nconst u_char CARD_IrqTab[8] =\r\n{7, 3, 5, 9, 0, 0, 0, 0};\r\ncs->irq = CARD_IrqTab[(val & ELSA_IRQ_IDX_PCC8) >> 4];\r\n} else {\r\nconst u_char CARD_IrqTab[8] =\r\n{15, 10, 15, 3, 11, 5, 11, 9};\r\ncs->irq = CARD_IrqTab[(val & ELSA_IRQ_IDX) >> 3];\r\n}\r\nval = bytein(cs->hw.elsa.ale) & ELSA_HW_RELEASE;\r\nif (val < 3)\r\nval |= 8;\r\nval += 'A' - 3;\r\nif (val == 'B' || val == 'C')\r\nval ^= 1;\r\nif ((cs->subtyp == ELSA_PCFPRO) && (val == 'G'))\r\nval = 'C';\r\nprintk(KERN_INFO\r\n"Elsa: %s found at %#lx Rev.:%c IRQ %d\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base,\r\nval, cs->irq);\r\nval = bytein(cs->hw.elsa.ale) & ELSA_S0_POWER_BAD;\r\nif (val) {\r\nprintk(KERN_WARNING\r\n"Elsa: Microlink S0 bus power bad\n");\r\ncs->hw.elsa.status |= ELSA_BAD_PWR;\r\n}\r\nreturn (1);\r\n}\r\nstatic int setup_elsa_isapnp(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\n#ifdef __ISAPNP__\r\nif (!card->para[1] && isapnp_present()) {\r\nstruct pnp_dev *pnp_d;\r\nwhile (ipid->card_vendor) {\r\nif ((pnp_c = pnp_find_card(ipid->card_vendor,\r\nipid->card_device, pnp_c))) {\r\npnp_d = NULL;\r\nif ((pnp_d = pnp_find_dev(pnp_c,\r\nipid->vendor, ipid->function, pnp_d))) {\r\nint err;\r\nprintk(KERN_INFO "HiSax: %s detected\n",\r\n(char *)ipid->driver_data);\r\npnp_disable_dev(pnp_d);\r\nerr = pnp_activate_dev(pnp_d);\r\nif (err < 0) {\r\nprintk(KERN_WARNING "%s: pnp_activate_dev ret(%d)\n",\r\n__func__, err);\r\nreturn (0);\r\n}\r\ncard->para[1] = pnp_port_start(pnp_d, 0);\r\ncard->para[0] = pnp_irq(pnp_d, 0);\r\nif (!card->para[0] || !card->para[1]) {\r\nprintk(KERN_ERR "Elsa PnP:some resources are missing %ld/%lx\n",\r\ncard->para[0], card->para[1]);\r\npnp_disable_dev(pnp_d);\r\nreturn (0);\r\n}\r\nif (ipid->function == ISAPNP_FUNCTION(0x133))\r\ncs->subtyp = ELSA_QS1000;\r\nelse\r\ncs->subtyp = ELSA_QS3000;\r\nbreak;\r\n} else {\r\nprintk(KERN_ERR "Elsa PnP: PnP error card found, no device\n");\r\nreturn (0);\r\n}\r\n}\r\nipid++;\r\npnp_c = NULL;\r\n}\r\nif (!ipid->card_vendor) {\r\nprintk(KERN_INFO "Elsa PnP: no ISAPnP card found\n");\r\nreturn (0);\r\n}\r\n}\r\n#endif\r\nif (card->para[1] && card->para[0]) {\r\ncs->hw.elsa.base = card->para[1];\r\ncs->irq = card->para[0];\r\nif (!cs->subtyp)\r\ncs->subtyp = ELSA_QS1000;\r\n} else {\r\nprintk(KERN_ERR "Elsa PnP: no parameter\n");\r\n}\r\ncs->hw.elsa.cfg = cs->hw.elsa.base + ELSA_CONFIG;\r\ncs->hw.elsa.ale = cs->hw.elsa.base + ELSA_ALE;\r\ncs->hw.elsa.isac = cs->hw.elsa.base + ELSA_ISAC;\r\ncs->hw.elsa.hscx = cs->hw.elsa.base + ELSA_HSCX;\r\ncs->hw.elsa.trig = cs->hw.elsa.base + ELSA_TRIG_IRQ;\r\ncs->hw.elsa.timer = cs->hw.elsa.base + ELSA_START_TIMER;\r\ncs->hw.elsa.ctrl = cs->hw.elsa.base + ELSA_CONTROL;\r\nprintk(KERN_INFO\r\n"Elsa: %s defined at %#lx IRQ %d\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base,\r\ncs->irq);\r\nreturn (1);\r\n}\r\nstatic void setup_elsa_pcmcia(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nu_char val;\r\ncs->hw.elsa.base = card->para[1];\r\ncs->irq = card->para[0];\r\nval = readreg(cs->hw.elsa.base + 0, cs->hw.elsa.base + 2, IPAC_ID);\r\nif ((val == 1) || (val == 2)) {\r\ncs->subtyp = ELSA_PCMCIA_IPAC;\r\ncs->hw.elsa.ale = cs->hw.elsa.base + 0;\r\ncs->hw.elsa.isac = cs->hw.elsa.base + 2;\r\ncs->hw.elsa.hscx = cs->hw.elsa.base + 2;\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\n} else {\r\ncs->subtyp = ELSA_PCMCIA;\r\ncs->hw.elsa.ale = cs->hw.elsa.base + ELSA_ALE_PCM;\r\ncs->hw.elsa.isac = cs->hw.elsa.base + ELSA_ISAC_PCM;\r\ncs->hw.elsa.hscx = cs->hw.elsa.base + ELSA_HSCX;\r\n}\r\ncs->hw.elsa.timer = 0;\r\ncs->hw.elsa.trig = 0;\r\ncs->hw.elsa.ctrl = 0;\r\ncs->irq_flags |= IRQF_SHARED;\r\nprintk(KERN_INFO\r\n"Elsa: %s defined at %#lx IRQ %d\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base,\r\ncs->irq);\r\n}\r\nstatic int setup_elsa_pci(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\ncs->subtyp = 0;\r\nif ((dev_qs1000 = hisax_find_pci_device(PCI_VENDOR_ID_ELSA,\r\nPCI_DEVICE_ID_ELSA_MICROLINK, dev_qs1000))) {\r\nif (pci_enable_device(dev_qs1000))\r\nreturn (0);\r\ncs->subtyp = ELSA_QS1000PCI;\r\ncs->irq = dev_qs1000->irq;\r\ncs->hw.elsa.cfg = pci_resource_start(dev_qs1000, 1);\r\ncs->hw.elsa.base = pci_resource_start(dev_qs1000, 3);\r\n} else if ((dev_qs3000 = hisax_find_pci_device(PCI_VENDOR_ID_ELSA,\r\nPCI_DEVICE_ID_ELSA_QS3000, dev_qs3000))) {\r\nif (pci_enable_device(dev_qs3000))\r\nreturn (0);\r\ncs->subtyp = ELSA_QS3000PCI;\r\ncs->irq = dev_qs3000->irq;\r\ncs->hw.elsa.cfg = pci_resource_start(dev_qs3000, 1);\r\ncs->hw.elsa.base = pci_resource_start(dev_qs3000, 3);\r\n} else {\r\nprintk(KERN_WARNING "Elsa: No PCI card found\n");\r\nreturn (0);\r\n}\r\nif (!cs->irq) {\r\nprintk(KERN_WARNING "Elsa: No IRQ for PCI card found\n");\r\nreturn (0);\r\n}\r\nif (!(cs->hw.elsa.base && cs->hw.elsa.cfg)) {\r\nprintk(KERN_WARNING "Elsa: No IO-Adr for PCI card found\n");\r\nreturn (0);\r\n}\r\nif ((cs->hw.elsa.cfg & 0xff) || (cs->hw.elsa.base & 0xf)) {\r\nprintk(KERN_WARNING "Elsa: You may have a wrong PCI bios\n");\r\nprintk(KERN_WARNING "Elsa: If your system hangs now, read\n");\r\nprintk(KERN_WARNING "Elsa: Documentation/isdn/README.HiSax\n");\r\n}\r\ncs->hw.elsa.ale = cs->hw.elsa.base;\r\ncs->hw.elsa.isac = cs->hw.elsa.base + 1;\r\ncs->hw.elsa.hscx = cs->hw.elsa.base + 1;\r\ntest_and_set_bit(HW_IPAC, &cs->HW_Flags);\r\ncs->hw.elsa.timer = 0;\r\ncs->hw.elsa.trig = 0;\r\ncs->irq_flags |= IRQF_SHARED;\r\nprintk(KERN_INFO\r\n"Elsa: %s defined at %#lx/0x%x IRQ %d\n",\r\nElsa_Types[cs->subtyp],\r\ncs->hw.elsa.base,\r\ncs->hw.elsa.cfg,\r\ncs->irq);\r\nreturn (1);\r\n}\r\nstatic int setup_elsa_pci(struct IsdnCard *card)\r\n{\r\nreturn (1);\r\n}\r\nstatic int setup_elsa_common(struct IsdnCard *card)\r\n{\r\nstruct IsdnCardState *cs = card->cs;\r\nu_char val;\r\nint bytecnt;\r\nswitch (cs->subtyp) {\r\ncase ELSA_PC:\r\ncase ELSA_PCC8:\r\ncase ELSA_PCC16:\r\ncase ELSA_QS1000:\r\ncase ELSA_PCMCIA:\r\ncase ELSA_PCMCIA_IPAC:\r\nbytecnt = 8;\r\nbreak;\r\ncase ELSA_PCFPRO:\r\ncase ELSA_PCF:\r\ncase ELSA_QS3000:\r\ncase ELSA_QS3000PCI:\r\nbytecnt = 16;\r\nbreak;\r\ncase ELSA_QS1000PCI:\r\nbytecnt = 2;\r\nbreak;\r\ndefault:\r\nprintk(KERN_WARNING\r\n"Unknown ELSA subtype %d\n", cs->subtyp);\r\nreturn (0);\r\n}\r\nif (cs->typ != ISDN_CTYPE_ELSA_PCMCIA && !request_region(cs->hw.elsa.base, bytecnt, "elsa isdn")) {\r\nprintk(KERN_WARNING\r\n"HiSax: ELSA config port %#lx-%#lx already in use\n",\r\ncs->hw.elsa.base,\r\ncs->hw.elsa.base + bytecnt);\r\nreturn (0);\r\n}\r\nif ((cs->subtyp == ELSA_QS1000PCI) || (cs->subtyp == ELSA_QS3000PCI)) {\r\nif (!request_region(cs->hw.elsa.cfg, 0x80, "elsa isdn pci")) {\r\nprintk(KERN_WARNING\r\n"HiSax: ELSA pci port %x-%x already in use\n",\r\ncs->hw.elsa.cfg,\r\ncs->hw.elsa.cfg + 0x80);\r\nrelease_region(cs->hw.elsa.base, bytecnt);\r\nreturn (0);\r\n}\r\n}\r\n#if ARCOFI_USE\r\ninit_arcofi(cs);\r\n#endif\r\nsetup_isac(cs);\r\ncs->hw.elsa.tl.function = (void *) elsa_led_handler;\r\ncs->hw.elsa.tl.data = (long) cs;\r\ninit_timer(&cs->hw.elsa.tl);\r\nif (cs->hw.elsa.timer) {\r\nbyteout(cs->hw.elsa.trig, 0xff);\r\nbyteout(cs->hw.elsa.timer, 0);\r\nif (!TimerRun(cs)) {\r\nbyteout(cs->hw.elsa.timer, 0);\r\nif (!TimerRun(cs)) {\r\nprintk(KERN_WARNING\r\n"Elsa: timer do not start\n");\r\nrelease_io_elsa(cs);\r\nreturn (0);\r\n}\r\n}\r\nHZDELAY((HZ / 100) + 1);\r\nif (TimerRun(cs)) {\r\nprintk(KERN_WARNING "Elsa: timer do not run down\n");\r\nrelease_io_elsa(cs);\r\nreturn (0);\r\n}\r\nprintk(KERN_INFO "Elsa: timer OK; resetting card\n");\r\n}\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &Elsa_card_msg;\r\nif ((cs->subtyp == ELSA_QS1000PCI) || (cs->subtyp == ELSA_QS3000PCI) || (cs->subtyp == ELSA_PCMCIA_IPAC)) {\r\ncs->readisac = &ReadISAC_IPAC;\r\ncs->writeisac = &WriteISAC_IPAC;\r\ncs->readisacfifo = &ReadISACfifo_IPAC;\r\ncs->writeisacfifo = &WriteISACfifo_IPAC;\r\ncs->irq_func = &elsa_interrupt_ipac;\r\nval = readreg(cs->hw.elsa.ale, cs->hw.elsa.isac, IPAC_ID);\r\nprintk(KERN_INFO "Elsa: IPAC version %x\n", val);\r\n} else {\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->irq_func = &elsa_interrupt;\r\nISACVersion(cs, "Elsa:");\r\nif (HscxVersion(cs, "Elsa:")) {\r\nprintk(KERN_WARNING\r\n"Elsa: wrong HSCX versions check IO address\n");\r\nrelease_io_elsa(cs);\r\nreturn (0);\r\n}\r\n}\r\nif (cs->subtyp == ELSA_PC) {\r\nval = readitac(cs, ITAC_SYS);\r\nprintk(KERN_INFO "Elsa: ITAC version %s\n", ITACVer[val & 7]);\r\nwriteitac(cs, ITAC_ISEN, 0);\r\nwriteitac(cs, ITAC_RFIE, 0);\r\nwriteitac(cs, ITAC_XFIE, 0);\r\nwriteitac(cs, ITAC_SCIE, 0);\r\nwriteitac(cs, ITAC_STIE, 0);\r\n}\r\nreturn (1);\r\n}\r\nint setup_elsa(struct IsdnCard *card)\r\n{\r\nint rc;\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, Elsa_revision);\r\nprintk(KERN_INFO "HiSax: Elsa driver Rev. %s\n", HiSax_getrev(tmp));\r\ncs->hw.elsa.ctrl_reg = 0;\r\ncs->hw.elsa.status = 0;\r\ncs->hw.elsa.MFlag = 0;\r\ncs->subtyp = 0;\r\nif (cs->typ == ISDN_CTYPE_ELSA) {\r\nrc = setup_elsa_isa(card);\r\nif (!rc)\r\nreturn (0);\r\n} else if (cs->typ == ISDN_CTYPE_ELSA_PNP) {\r\nrc = setup_elsa_isapnp(card);\r\nif (!rc)\r\nreturn (0);\r\n} else if (cs->typ == ISDN_CTYPE_ELSA_PCMCIA)\r\nsetup_elsa_pcmcia(card);\r\nelse if (cs->typ == ISDN_CTYPE_ELSA_PCI) {\r\nrc = setup_elsa_pci(card);\r\nif (!rc)\r\nreturn (0);\r\n} else\r\nreturn (0);\r\nreturn setup_elsa_common(card);\r\n}
