static int twl6030_irq_pm_notifier(struct notifier_block *notifier,\r\nunsigned long pm_event, void *unused)\r\n{\r\nint chained_wakeups;\r\nstruct twl6030_irq *pdata = container_of(notifier, struct twl6030_irq,\r\npm_nb);\r\nswitch (pm_event) {\r\ncase PM_SUSPEND_PREPARE:\r\nchained_wakeups = atomic_read(&pdata->wakeirqs);\r\nif (chained_wakeups && !pdata->irq_wake_enabled) {\r\nif (enable_irq_wake(pdata->twl_irq))\r\npr_err("twl6030 IRQ wake enable failed\n");\r\nelse\r\npdata->irq_wake_enabled = true;\r\n} else if (!chained_wakeups && pdata->irq_wake_enabled) {\r\ndisable_irq_wake(pdata->twl_irq);\r\npdata->irq_wake_enabled = false;\r\n}\r\ndisable_irq(pdata->twl_irq);\r\nbreak;\r\ncase PM_POST_SUSPEND:\r\nenable_irq(pdata->twl_irq);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic irqreturn_t twl6030_irq_thread(int irq, void *data)\r\n{\r\nint i, ret;\r\nunion {\r\nu8 bytes[4];\r\nu32 int_sts;\r\n} sts;\r\nstruct twl6030_irq *pdata = data;\r\nret = twl_i2c_read(TWL_MODULE_PIH, sts.bytes, REG_INT_STS_A, 3);\r\nif (ret) {\r\npr_warn("twl6030_irq: I2C error %d reading PIH ISR\n", ret);\r\nreturn IRQ_HANDLED;\r\n}\r\nsts.bytes[3] = 0;\r\nif (sts.bytes[2] & 0x10)\r\nsts.bytes[2] |= 0x08;\r\nfor (i = 0; sts.int_sts; sts.int_sts >>= 1, i++)\r\nif (sts.int_sts & 0x1) {\r\nint module_irq =\r\nirq_find_mapping(pdata->irq_domain,\r\npdata->irq_mapping_tbl[i]);\r\nif (module_irq)\r\nhandle_nested_irq(module_irq);\r\nelse\r\npr_err("twl6030_irq: Unmapped PIH ISR %u detected\n",\r\ni);\r\npr_debug("twl6030_irq: PIH ISR %u, virq%u\n",\r\ni, module_irq);\r\n}\r\nret = twl_i2c_write_u8(TWL_MODULE_PIH, 0x00, REG_INT_STS_A);\r\nif (ret)\r\npr_warn("twl6030_irq: I2C error in clearing PIH ISR\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl6030_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct twl6030_irq *pdata = irq_get_chip_data(d->irq);\r\nif (on)\r\natomic_inc(&pdata->wakeirqs);\r\nelse\r\natomic_dec(&pdata->wakeirqs);\r\nreturn 0;\r\n}\r\nint twl6030_interrupt_unmask(u8 bit_mask, u8 offset)\r\n{\r\nint ret;\r\nu8 unmask_value;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &unmask_value,\r\nREG_INT_STS_A + offset);\r\nunmask_value &= (~(bit_mask));\r\nret |= twl_i2c_write_u8(TWL_MODULE_PIH, unmask_value,\r\nREG_INT_STS_A + offset);\r\nreturn ret;\r\n}\r\nint twl6030_interrupt_mask(u8 bit_mask, u8 offset)\r\n{\r\nint ret;\r\nu8 mask_value;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &mask_value,\r\nREG_INT_STS_A + offset);\r\nmask_value |= (bit_mask);\r\nret |= twl_i2c_write_u8(TWL_MODULE_PIH, mask_value,\r\nREG_INT_STS_A + offset);\r\nreturn ret;\r\n}\r\nint twl6030_mmc_card_detect_config(void)\r\n{\r\nint ret;\r\nu8 reg_val = 0;\r\ntwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\r\nREG_INT_MSK_LINE_B);\r\ntwl6030_interrupt_unmask(TWL6030_MMCDETECT_INT_MASK,\r\nREG_INT_MSK_STS_B);\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val, TWL6030_MMCCTRL);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to read MMCCTRL, error %d\n", ret);\r\nreturn ret;\r\n}\r\nreg_val &= ~VMMC_AUTO_OFF;\r\nreg_val |= SW_FC;\r\nret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val, TWL6030_MMCCTRL);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to write MMCCTRL, error %d\n", ret);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &reg_val,\r\nTWL6030_CFG_INPUT_PUPD3);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to read CFG_INPUT_PUPD3, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreg_val &= ~(MMC_PU | MMC_PD);\r\nret = twl_i2c_write_u8(TWL6030_MODULE_ID0, reg_val,\r\nTWL6030_CFG_INPUT_PUPD3);\r\nif (ret < 0) {\r\npr_err("twl6030: Failed to write CFG_INPUT_PUPD3, error %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn irq_find_mapping(twl6030_irq->irq_domain,\r\nMMCDETECT_INTR_OFFSET);\r\n}\r\nint twl6030_mmc_card_detect(struct device *dev, int slot)\r\n{\r\nint ret = -EIO;\r\nu8 read_reg = 0;\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nif (pdev->id) {\r\npr_err("Unknown MMC controller %d in %s\n", pdev->id, __func__);\r\nreturn ret;\r\n}\r\nret = twl_i2c_read_u8(TWL6030_MODULE_ID0, &read_reg,\r\nTWL6030_MMCCTRL);\r\nif (ret >= 0)\r\nret = read_reg & STS_MMC;\r\nreturn ret;\r\n}\r\nstatic int twl6030_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct twl6030_irq *pdata = d->host_data;\r\nirq_set_chip_data(virq, pdata);\r\nirq_set_chip_and_handler(virq, &pdata->irq_chip, handle_simple_irq);\r\nirq_set_nested_thread(virq, true);\r\nirq_set_parent(virq, pdata->twl_irq);\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(virq);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void twl6030_irq_unmap(struct irq_domain *d, unsigned int virq)\r\n{\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(virq, 0);\r\n#endif\r\nirq_set_chip_and_handler(virq, NULL, NULL);\r\nirq_set_chip_data(virq, NULL);\r\n}\r\nint twl6030_init_irq(struct device *dev, int irq_num)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nint nr_irqs;\r\nint status;\r\nu8 mask[3];\r\nconst struct of_device_id *of_id;\r\nof_id = of_match_device(twl6030_of_match, dev);\r\nif (!of_id || !of_id->data) {\r\ndev_err(dev, "Unknown TWL device model\n");\r\nreturn -EINVAL;\r\n}\r\nnr_irqs = TWL6030_NR_IRQS;\r\ntwl6030_irq = devm_kzalloc(dev, sizeof(*twl6030_irq), GFP_KERNEL);\r\nif (!twl6030_irq) {\r\ndev_err(dev, "twl6030_irq: Memory allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nmask[0] = 0xFF;\r\nmask[1] = 0xFF;\r\nmask[2] = 0xFF;\r\nstatus = twl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_MSK_LINE_A, 3);\r\nstatus |= twl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_MSK_STS_A, 3);\r\nstatus |= twl_i2c_write(TWL_MODULE_PIH, &mask[0], REG_INT_STS_A, 3);\r\nif (status < 0) {\r\ndev_err(dev, "I2C err writing TWL_MODULE_PIH: %d\n", status);\r\nreturn status;\r\n}\r\ntwl6030_irq->irq_chip = dummy_irq_chip;\r\ntwl6030_irq->irq_chip.name = "twl6030";\r\ntwl6030_irq->irq_chip.irq_set_type = NULL;\r\ntwl6030_irq->irq_chip.irq_set_wake = twl6030_irq_set_wake;\r\ntwl6030_irq->pm_nb.notifier_call = twl6030_irq_pm_notifier;\r\natomic_set(&twl6030_irq->wakeirqs, 0);\r\ntwl6030_irq->irq_mapping_tbl = of_id->data;\r\ntwl6030_irq->irq_domain =\r\nirq_domain_add_linear(node, nr_irqs,\r\n&twl6030_irq_domain_ops, twl6030_irq);\r\nif (!twl6030_irq->irq_domain) {\r\ndev_err(dev, "Can't add irq_domain\n");\r\nreturn -ENOMEM;\r\n}\r\ndev_info(dev, "PIH (irq %d) nested IRQs\n", irq_num);\r\nstatus = request_threaded_irq(irq_num, NULL, twl6030_irq_thread,\r\nIRQF_ONESHOT, "TWL6030-PIH", twl6030_irq);\r\nif (status < 0) {\r\ndev_err(dev, "could not claim irq %d: %d\n", irq_num, status);\r\ngoto fail_irq;\r\n}\r\ntwl6030_irq->twl_irq = irq_num;\r\nregister_pm_notifier(&twl6030_irq->pm_nb);\r\nreturn 0;\r\nfail_irq:\r\nirq_domain_remove(twl6030_irq->irq_domain);\r\nreturn status;\r\n}\r\nint twl6030_exit_irq(void)\r\n{\r\nif (twl6030_irq && twl6030_irq->twl_irq) {\r\nunregister_pm_notifier(&twl6030_irq->pm_nb);\r\nfree_irq(twl6030_irq->twl_irq, NULL);\r\n}\r\nreturn 0;\r\n}
