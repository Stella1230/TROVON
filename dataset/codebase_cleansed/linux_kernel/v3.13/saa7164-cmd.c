static int saa7164_cmd_alloc_seqno(struct saa7164_dev *dev)\r\n{\r\nint i, ret = -1;\r\nmutex_lock(&dev->lock);\r\nfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\r\nif (dev->cmds[i].inuse == 0) {\r\ndev->cmds[i].inuse = 1;\r\ndev->cmds[i].signalled = 0;\r\ndev->cmds[i].timeout = 0;\r\nret = dev->cmds[i].seqno;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic void saa7164_cmd_free_seqno(struct saa7164_dev *dev, u8 seqno)\r\n{\r\nmutex_lock(&dev->lock);\r\nif ((dev->cmds[seqno].inuse == 1) &&\r\n(dev->cmds[seqno].seqno == seqno)) {\r\ndev->cmds[seqno].inuse = 0;\r\ndev->cmds[seqno].signalled = 0;\r\ndev->cmds[seqno].timeout = 0;\r\n}\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic void saa7164_cmd_timeout_seqno(struct saa7164_dev *dev, u8 seqno)\r\n{\r\nmutex_lock(&dev->lock);\r\nif ((dev->cmds[seqno].inuse == 1) &&\r\n(dev->cmds[seqno].seqno == seqno)) {\r\ndev->cmds[seqno].timeout = 1;\r\n}\r\nmutex_unlock(&dev->lock);\r\n}\r\nstatic u32 saa7164_cmd_timeout_get(struct saa7164_dev *dev, u8 seqno)\r\n{\r\nint ret = 0;\r\nmutex_lock(&dev->lock);\r\nif ((dev->cmds[seqno].inuse == 1) &&\r\n(dev->cmds[seqno].seqno == seqno)) {\r\nret = dev->cmds[seqno].timeout;\r\n}\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nint saa7164_irq_dequeue(struct saa7164_dev *dev)\r\n{\r\nint ret = SAA_OK, i = 0;\r\nu32 timeout;\r\nwait_queue_head_t *q = NULL;\r\nu8 tmp[512];\r\ndprintk(DBGLVL_CMD, "%s()\n", __func__);\r\ndo {\r\nstruct tmComResInfo tRsp = { 0, 0, 0, 0, 0, 0 };\r\nret = saa7164_bus_get(dev, &tRsp, NULL, 1);\r\nif (ret != SAA_OK)\r\nbreak;\r\nq = &dev->cmds[tRsp.seqno].wait;\r\ntimeout = saa7164_cmd_timeout_get(dev, tRsp.seqno);\r\ndprintk(DBGLVL_CMD, "%s() timeout = %d\n", __func__, timeout);\r\nif (!timeout) {\r\ndprintk(DBGLVL_CMD,\r\n"%s() signalled seqno(%d) (for dequeue)\n",\r\n__func__, tRsp.seqno);\r\ndev->cmds[tRsp.seqno].signalled = 1;\r\nwake_up(q);\r\n} else {\r\nprintk(KERN_ERR\r\n"%s() found timed out command on the bus\n",\r\n__func__);\r\nret = saa7164_bus_get(dev, &tRsp, &tmp, 0);\r\nprintk(KERN_ERR "%s() ret = %x\n", __func__, ret);\r\nif (ret == SAA_ERR_EMPTY)\r\nreturn SAA_OK;\r\nif (ret != SAA_OK)\r\nreturn ret;\r\n}\r\n} while (i++ < 32);\r\nreturn ret;\r\n}\r\nstatic int saa7164_cmd_dequeue(struct saa7164_dev *dev)\r\n{\r\nint loop = 1;\r\nint ret;\r\nu32 timeout;\r\nwait_queue_head_t *q = NULL;\r\nu8 tmp[512];\r\ndprintk(DBGLVL_CMD, "%s()\n", __func__);\r\nwhile (loop) {\r\nstruct tmComResInfo tRsp = { 0, 0, 0, 0, 0, 0 };\r\nret = saa7164_bus_get(dev, &tRsp, NULL, 1);\r\nif (ret == SAA_ERR_EMPTY)\r\nreturn SAA_OK;\r\nif (ret != SAA_OK)\r\nreturn ret;\r\nq = &dev->cmds[tRsp.seqno].wait;\r\ntimeout = saa7164_cmd_timeout_get(dev, tRsp.seqno);\r\ndprintk(DBGLVL_CMD, "%s() timeout = %d\n", __func__, timeout);\r\nif (timeout) {\r\nprintk(KERN_ERR "found timed out command on the bus\n");\r\nret = saa7164_bus_get(dev, &tRsp, &tmp, 0);\r\nprintk(KERN_ERR "ret = %x\n", ret);\r\nif (ret == SAA_ERR_EMPTY)\r\nreturn SAA_OK;\r\nif (ret != SAA_OK)\r\nreturn ret;\r\nif (tRsp.flags & PVC_CMDFLAG_CONTINUE)\r\nprintk(KERN_ERR "split response\n");\r\nelse\r\nsaa7164_cmd_free_seqno(dev, tRsp.seqno);\r\nprintk(KERN_ERR " timeout continue\n");\r\ncontinue;\r\n}\r\ndprintk(DBGLVL_CMD, "%s() signalled seqno(%d) (for dequeue)\n",\r\n__func__, tRsp.seqno);\r\ndev->cmds[tRsp.seqno].signalled = 1;\r\nwake_up(q);\r\nreturn SAA_OK;\r\n}\r\nreturn SAA_OK;\r\n}\r\nstatic int saa7164_cmd_set(struct saa7164_dev *dev, struct tmComResInfo *msg,\r\nvoid *buf)\r\n{\r\nstruct tmComResBusInfo *bus = &dev->bus;\r\nu8 cmd_sent;\r\nu16 size, idx;\r\nu32 cmds;\r\nvoid *tmp;\r\nint ret = -1;\r\nif (!msg) {\r\nprintk(KERN_ERR "%s() !msg\n", __func__);\r\nreturn SAA_ERR_BAD_PARAMETER;\r\n}\r\nmutex_lock(&dev->cmds[msg->id].lock);\r\nsize = msg->size;\r\nidx = 0;\r\ncmds = size / bus->m_wMaxReqSize;\r\nif (size % bus->m_wMaxReqSize == 0)\r\ncmds -= 1;\r\ncmd_sent = 0;\r\nfor (idx = 0; idx < cmds; idx++) {\r\nmsg->flags |= SAA_CMDFLAG_CONTINUE;\r\nmsg->size = bus->m_wMaxReqSize;\r\ntmp = buf + idx * bus->m_wMaxReqSize;\r\nret = saa7164_bus_set(dev, msg, tmp);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() set failed %d\n", __func__, ret);\r\nif (cmd_sent) {\r\nret = SAA_ERR_BUSY;\r\ngoto out;\r\n}\r\nret = SAA_ERR_OVERFLOW;\r\ngoto out;\r\n}\r\ncmd_sent = 1;\r\n}\r\nif (idx != 0)\r\nmsg->flags &= ~SAA_CMDFLAG_CONTINUE;\r\nmsg->size = size - idx * bus->m_wMaxReqSize;\r\nret = saa7164_bus_set(dev, msg, buf + idx * bus->m_wMaxReqSize);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() set last failed %d\n", __func__, ret);\r\nif (cmd_sent) {\r\nret = SAA_ERR_BUSY;\r\ngoto out;\r\n}\r\nret = SAA_ERR_OVERFLOW;\r\ngoto out;\r\n}\r\nret = SAA_OK;\r\nout:\r\nmutex_unlock(&dev->cmds[msg->id].lock);\r\nreturn ret;\r\n}\r\nstatic int saa7164_cmd_wait(struct saa7164_dev *dev, u8 seqno)\r\n{\r\nwait_queue_head_t *q = NULL;\r\nint ret = SAA_BUS_TIMEOUT;\r\nunsigned long stamp;\r\nint r;\r\nif (saa_debug >= 4)\r\nsaa7164_bus_dump(dev);\r\ndprintk(DBGLVL_CMD, "%s(seqno=%d)\n", __func__, seqno);\r\nmutex_lock(&dev->lock);\r\nif ((dev->cmds[seqno].inuse == 1) &&\r\n(dev->cmds[seqno].seqno == seqno)) {\r\nq = &dev->cmds[seqno].wait;\r\n}\r\nmutex_unlock(&dev->lock);\r\nif (q) {\r\nif (dev->cmds[seqno].signalled == 0) {\r\nstamp = jiffies;\r\ndprintk(DBGLVL_CMD,\r\n"%s(seqno=%d) Waiting (signalled=%d)\n",\r\n__func__, seqno, dev->cmds[seqno].signalled);\r\nwait_event_timeout(*q, dev->cmds[seqno].signalled,\r\n(HZ * waitsecs));\r\nr = time_before(jiffies, stamp + (HZ * waitsecs));\r\nif (r)\r\nret = SAA_OK;\r\nelse\r\nsaa7164_cmd_timeout_seqno(dev, seqno);\r\ndprintk(DBGLVL_CMD, "%s(seqno=%d) Waiting res = %d "\r\n"(signalled=%d)\n", __func__, seqno, r,\r\ndev->cmds[seqno].signalled);\r\n} else\r\nret = SAA_OK;\r\n} else\r\nprintk(KERN_ERR "%s(seqno=%d) seqno is invalid\n",\r\n__func__, seqno);\r\nreturn ret;\r\n}\r\nvoid saa7164_cmd_signal(struct saa7164_dev *dev, u8 seqno)\r\n{\r\nint i;\r\ndprintk(DBGLVL_CMD, "%s()\n", __func__);\r\nmutex_lock(&dev->lock);\r\nfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\r\nif (dev->cmds[i].inuse == 1) {\r\ndprintk(DBGLVL_CMD,\r\n"seqno %d inuse, sig = %d, t/out = %d\n",\r\ndev->cmds[i].seqno,\r\ndev->cmds[i].signalled,\r\ndev->cmds[i].timeout);\r\n}\r\n}\r\nfor (i = 0; i < SAA_CMD_MAX_MSG_UNITS; i++) {\r\nif ((dev->cmds[i].inuse == 1) && ((i == 0) ||\r\n(dev->cmds[i].signalled) || (dev->cmds[i].timeout))) {\r\ndprintk(DBGLVL_CMD, "%s(seqno=%d) calling wake_up\n",\r\n__func__, i);\r\ndev->cmds[i].signalled = 1;\r\nwake_up(&dev->cmds[i].wait);\r\n}\r\n}\r\nmutex_unlock(&dev->lock);\r\n}\r\nint saa7164_cmd_send(struct saa7164_dev *dev, u8 id, enum tmComResCmd command,\r\nu16 controlselector, u16 size, void *buf)\r\n{\r\nstruct tmComResInfo command_t, *pcommand_t;\r\nstruct tmComResInfo response_t, *presponse_t;\r\nu8 errdata[256];\r\nu16 resp_dsize;\r\nu16 data_recd;\r\nu32 loop;\r\nint ret;\r\nint safety = 0;\r\ndprintk(DBGLVL_CMD, "%s(unitid = %s (%d) , command = 0x%x, "\r\n"sel = 0x%x)\n", __func__, saa7164_unitid_name(dev, id), id,\r\ncommand, controlselector);\r\nif ((size == 0) || (buf == NULL)) {\r\nprintk(KERN_ERR "%s() Invalid param\n", __func__);\r\nreturn SAA_ERR_BAD_PARAMETER;\r\n}\r\nmemset(&command_t, 0, sizeof(command_t));\r\nmemset(&response_t, 0, sizeof(response_t));\r\npcommand_t = &command_t;\r\npresponse_t = &response_t;\r\ncommand_t.id = id;\r\ncommand_t.command = command;\r\ncommand_t.controlselector = controlselector;\r\ncommand_t.size = size;\r\nret = saa7164_cmd_alloc_seqno(dev);\r\nif (ret < 0) {\r\nprintk(KERN_ERR "%s() No free sequences\n", __func__);\r\nret = SAA_ERR_NO_RESOURCES;\r\ngoto out;\r\n}\r\ncommand_t.seqno = (u8)ret;\r\nresp_dsize = size;\r\npcommand_t->size = size;\r\ndprintk(DBGLVL_CMD, "%s() pcommand_t.seqno = %d\n",\r\n__func__, pcommand_t->seqno);\r\ndprintk(DBGLVL_CMD, "%s() pcommand_t.size = %d\n",\r\n__func__, pcommand_t->size);\r\nret = saa7164_cmd_set(dev, pcommand_t, buf);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "%s() set command failed %d\n", __func__, ret);\r\nif (ret != SAA_ERR_BUSY)\r\nsaa7164_cmd_free_seqno(dev, pcommand_t->seqno);\r\nelse\r\nsaa7164_cmd_timeout_seqno(dev, pcommand_t->seqno);\r\ngoto out;\r\n}\r\ndata_recd = 0;\r\nloop = 1;\r\nwhile (loop) {\r\ndprintk(DBGLVL_CMD, "%s() loop\n", __func__);\r\nret = saa7164_cmd_wait(dev, pcommand_t->seqno);\r\ndprintk(DBGLVL_CMD, "%s() loop ret = %d\n", __func__, ret);\r\nif (ret == SAA_BUS_TIMEOUT) {\r\nprintk(KERN_ERR "Event timed out\n");\r\nsaa7164_cmd_timeout_seqno(dev, pcommand_t->seqno);\r\nreturn ret;\r\n}\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "spurious error\n");\r\nreturn ret;\r\n}\r\nret = saa7164_bus_get(dev, presponse_t, NULL, 1);\r\nif (ret == SAA_ERR_EMPTY) {\r\ndprintk(4, "%s() SAA_ERR_EMPTY\n", __func__);\r\ncontinue;\r\n}\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "peek failed\n");\r\nreturn ret;\r\n}\r\ndprintk(DBGLVL_CMD, "%s() presponse_t->seqno = %d\n",\r\n__func__, presponse_t->seqno);\r\ndprintk(DBGLVL_CMD, "%s() presponse_t->flags = 0x%x\n",\r\n__func__, presponse_t->flags);\r\ndprintk(DBGLVL_CMD, "%s() presponse_t->size = %d\n",\r\n__func__, presponse_t->size);\r\nif (presponse_t->seqno != pcommand_t->seqno) {\r\ndprintk(DBGLVL_CMD,\r\n"wrong event: seqno = %d, "\r\n"expected seqno = %d, "\r\n"will dequeue regardless\n",\r\npresponse_t->seqno, pcommand_t->seqno);\r\nret = saa7164_cmd_dequeue(dev);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "dequeue failed, ret = %d\n",\r\nret);\r\nif (safety++ > 16) {\r\nprintk(KERN_ERR\r\n"dequeue exceeded, safety exit\n");\r\nreturn SAA_ERR_BUSY;\r\n}\r\n}\r\ncontinue;\r\n}\r\nif ((presponse_t->flags & PVC_RESPONSEFLAG_ERROR) != 0) {\r\nmemset(&errdata[0], 0, sizeof(errdata));\r\nret = saa7164_bus_get(dev, presponse_t, &errdata[0], 0);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "get error(2)\n");\r\nreturn ret;\r\n}\r\nsaa7164_cmd_free_seqno(dev, pcommand_t->seqno);\r\ndprintk(DBGLVL_CMD, "%s() errdata %02x%02x%02x%02x\n",\r\n__func__, errdata[0], errdata[1], errdata[2],\r\nerrdata[3]);\r\ndprintk(DBGLVL_CMD, "%s() cmd, error code = 0x%x\n",\r\n__func__, errdata[0]);\r\nswitch (errdata[0]) {\r\ncase PVC_ERRORCODE_INVALID_COMMAND:\r\ndprintk(DBGLVL_CMD, "%s() INVALID_COMMAND\n",\r\n__func__);\r\nret = SAA_ERR_INVALID_COMMAND;\r\nbreak;\r\ncase PVC_ERRORCODE_INVALID_DATA:\r\ndprintk(DBGLVL_CMD, "%s() INVALID_DATA\n",\r\n__func__);\r\nret = SAA_ERR_BAD_PARAMETER;\r\nbreak;\r\ncase PVC_ERRORCODE_TIMEOUT:\r\ndprintk(DBGLVL_CMD, "%s() TIMEOUT\n", __func__);\r\nret = SAA_ERR_TIMEOUT;\r\nbreak;\r\ncase PVC_ERRORCODE_NAK:\r\ndprintk(DBGLVL_CMD, "%s() NAK\n", __func__);\r\nret = SAA_ERR_NULL_PACKET;\r\nbreak;\r\ncase PVC_ERRORCODE_UNKNOWN:\r\ncase PVC_ERRORCODE_INVALID_CONTROL:\r\ndprintk(DBGLVL_CMD,\r\n"%s() UNKNOWN OR INVALID CONTROL\n",\r\n__func__);\r\ndefault:\r\ndprintk(DBGLVL_CMD, "%s() UNKNOWN\n", __func__);\r\nret = SAA_ERR_NOT_SUPPORTED;\r\n}\r\nif (saa7164_cmd_dequeue(dev) != SAA_OK)\r\nprintk(KERN_ERR "dequeue(2) failed\n");\r\nreturn ret;\r\n}\r\nif ((presponse_t->id != pcommand_t->id) ||\r\n(presponse_t->command != pcommand_t->command) ||\r\n(presponse_t->controlselector !=\r\npcommand_t->controlselector) ||\r\n(((resp_dsize - data_recd) != presponse_t->size) &&\r\n!(presponse_t->flags & PVC_CMDFLAG_CONTINUE)) ||\r\n((resp_dsize - data_recd) < presponse_t->size)) {\r\ndprintk(DBGLVL_CMD, "%s() Invalid\n", __func__);\r\nret = saa7164_bus_get(dev, presponse_t, NULL, 0);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "get failed\n");\r\nreturn ret;\r\n}\r\nif (saa7164_cmd_dequeue(dev) != SAA_OK)\r\nprintk(KERN_ERR "dequeue(3) failed\n");\r\ncontinue;\r\n}\r\nret = saa7164_bus_get(dev, presponse_t, buf + data_recd, 0);\r\nif (ret != SAA_OK) {\r\nprintk(KERN_ERR "get failed\n");\r\nreturn ret;\r\n}\r\ndata_recd = presponse_t->size + data_recd;\r\nif (resp_dsize == data_recd) {\r\ndprintk(DBGLVL_CMD, "%s() Resp recd\n", __func__);\r\nbreak;\r\n}\r\nif (saa7164_cmd_dequeue(dev) != SAA_OK)\r\nprintk(KERN_ERR "dequeue(3) failed\n");\r\ncontinue;\r\n}\r\nsaa7164_cmd_free_seqno(dev, pcommand_t->seqno);\r\ndprintk(DBGLVL_CMD, "%s() Calling dequeue then exit\n", __func__);\r\nif (saa7164_cmd_dequeue(dev) != SAA_OK)\r\nprintk(KERN_ERR "dequeue(4) failed\n");\r\nret = SAA_OK;\r\nout:\r\nreturn ret;\r\n}
