static inline\r\nunsigned int ll_crypto_tfm_alg_min_keysize(struct crypto_blkcipher *tfm)\r\n{\r\nreturn crypto_blkcipher_tfm(tfm)->__crt_alg->cra_blkcipher.min_keysize;\r\n}\r\nstruct hlist_head *init_capa_hash(void)\r\n{\r\nstruct hlist_head *hash;\r\nint nr_hash, i;\r\nOBD_ALLOC(hash, PAGE_CACHE_SIZE);\r\nif (!hash)\r\nreturn NULL;\r\nnr_hash = PAGE_CACHE_SIZE / sizeof(struct hlist_head);\r\nLASSERT(nr_hash > NR_CAPAHASH);\r\nfor (i = 0; i < NR_CAPAHASH; i++)\r\nINIT_HLIST_HEAD(hash + i);\r\nreturn hash;\r\n}\r\nstatic inline int capa_on_server(struct obd_capa *ocapa)\r\n{\r\nreturn ocapa->c_site == CAPA_SITE_SERVER;\r\n}\r\nstatic inline void capa_delete(struct obd_capa *ocapa)\r\n{\r\nLASSERT(capa_on_server(ocapa));\r\nhlist_del_init(&ocapa->u.tgt.c_hash);\r\nlist_del_init(&ocapa->c_list);\r\ncapa_count[ocapa->c_site]--;\r\ncapa_put(ocapa);\r\n}\r\nvoid cleanup_capa_hash(struct hlist_head *hash)\r\n{\r\nint i;\r\nstruct hlist_node *next;\r\nstruct obd_capa *oc;\r\nspin_lock(&capa_lock);\r\nfor (i = 0; i < NR_CAPAHASH; i++) {\r\nhlist_for_each_entry_safe(oc, next, hash + i,\r\nu.tgt.c_hash)\r\ncapa_delete(oc);\r\n}\r\nspin_unlock(&capa_lock);\r\nOBD_FREE(hash, PAGE_CACHE_SIZE);\r\n}\r\nstatic inline int capa_hashfn(struct lu_fid *fid)\r\n{\r\nreturn (fid_oid(fid) ^ fid_ver(fid)) *\r\n(unsigned long)(fid_seq(fid) + 1) % NR_CAPAHASH;\r\n}\r\nstatic inline int capa_is_to_expire(struct obd_capa *oc)\r\n{\r\nreturn cfs_time_before(cfs_time_sub(oc->c_expiry,\r\ncfs_time_seconds(oc->c_capa.lc_timeout)*2/3),\r\ncfs_time_current());\r\n}\r\nstatic struct obd_capa *find_capa(struct lustre_capa *capa,\r\nstruct hlist_head *head, int alive)\r\n{\r\nstruct obd_capa *ocapa;\r\nint len = alive ? offsetof(struct lustre_capa, lc_keyid):sizeof(*capa);\r\nhlist_for_each_entry(ocapa, head, u.tgt.c_hash) {\r\nif (memcmp(&ocapa->c_capa, capa, len))\r\ncontinue;\r\nif (alive && capa_is_to_expire(ocapa))\r\ncontinue;\r\nLASSERT(capa_on_server(ocapa));\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "found");\r\nreturn ocapa;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void capa_delete_lru(struct list_head *head)\r\n{\r\nstruct obd_capa *ocapa;\r\nstruct list_head *node = head->next;\r\nint count = 0;\r\nwhile (count++ < LRU_CAPA_DELETE_COUNT) {\r\nocapa = list_entry(node, struct obd_capa, c_list);\r\nnode = node->next;\r\nif (atomic_read(&ocapa->c_refc))\r\ncontinue;\r\nDEBUG_CAPA(D_SEC, &ocapa->c_capa, "free lru");\r\ncapa_delete(ocapa);\r\n}\r\n}\r\nstruct obd_capa *capa_add(struct hlist_head *hash, struct lustre_capa *capa)\r\n{\r\nstruct hlist_head *head = hash + capa_hashfn(&capa->lc_fid);\r\nstruct obd_capa *ocapa, *old = NULL;\r\nstruct list_head *list = &capa_list[CAPA_SITE_SERVER];\r\nocapa = alloc_capa(CAPA_SITE_SERVER);\r\nif (IS_ERR(ocapa))\r\nreturn NULL;\r\nspin_lock(&capa_lock);\r\nold = find_capa(capa, head, 0);\r\nif (!old) {\r\nocapa->c_capa = *capa;\r\nset_capa_expiry(ocapa);\r\nhlist_add_head(&ocapa->u.tgt.c_hash, head);\r\nlist_add_tail(&ocapa->c_list, list);\r\ncapa_get(ocapa);\r\ncapa_count[CAPA_SITE_SERVER]++;\r\nif (capa_count[CAPA_SITE_SERVER] > CAPA_HASH_SIZE)\r\ncapa_delete_lru(list);\r\nspin_unlock(&capa_lock);\r\nreturn ocapa;\r\n} else {\r\ncapa_get(old);\r\nspin_unlock(&capa_lock);\r\ncapa_put(ocapa);\r\nreturn old;\r\n}\r\n}\r\nstruct obd_capa *capa_lookup(struct hlist_head *hash, struct lustre_capa *capa,\r\nint alive)\r\n{\r\nstruct obd_capa *ocapa;\r\nspin_lock(&capa_lock);\r\nocapa = find_capa(capa, hash + capa_hashfn(&capa->lc_fid), alive);\r\nif (ocapa) {\r\nlist_move_tail(&ocapa->c_list,\r\n&capa_list[CAPA_SITE_SERVER]);\r\ncapa_get(ocapa);\r\n}\r\nspin_unlock(&capa_lock);\r\nreturn ocapa;\r\n}\r\nstatic inline int ll_crypto_hmac(struct crypto_hash *tfm,\r\nu8 *key, unsigned int *keylen,\r\nstruct scatterlist *sg,\r\nunsigned int size, u8 *result)\r\n{\r\nstruct hash_desc desc;\r\nint rv;\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nrv = crypto_hash_setkey(desc.tfm, key, *keylen);\r\nif (rv) {\r\nCERROR("failed to hash setkey: %d\n", rv);\r\nreturn rv;\r\n}\r\nreturn crypto_hash_digest(&desc, sg, size, result);\r\n}\r\nint capa_hmac(__u8 *hmac, struct lustre_capa *capa, __u8 *key)\r\n{\r\nstruct crypto_hash *tfm;\r\nstruct capa_hmac_alg *alg;\r\nint keylen;\r\nstruct scatterlist sl;\r\nif (capa_alg(capa) != CAPA_HMAC_ALG_SHA1) {\r\nCERROR("unknown capability hmac algorithm!\n");\r\nreturn -EFAULT;\r\n}\r\nalg = &capa_hmac_algs[capa_alg(capa)];\r\ntfm = crypto_alloc_hash(alg->ha_name, 0, 0);\r\nif (!tfm) {\r\nCERROR("crypto_alloc_tfm failed, check whether your kernel"\r\n"has crypto support!\n");\r\nreturn -ENOMEM;\r\n}\r\nkeylen = alg->ha_keylen;\r\nsg_set_page(&sl, virt_to_page(capa),\r\noffsetof(struct lustre_capa, lc_hmac),\r\n(unsigned long)(capa) % PAGE_CACHE_SIZE);\r\nll_crypto_hmac(tfm, key, &keylen, &sl, sl.length, hmac);\r\ncrypto_free_hash(tfm);\r\nreturn 0;\r\n}\r\nint capa_encrypt_id(__u32 *d, __u32 *s, __u8 *key, int keylen)\r\n{\r\nstruct crypto_blkcipher *tfm;\r\nstruct scatterlist sd;\r\nstruct scatterlist ss;\r\nstruct blkcipher_desc desc;\r\nunsigned int min;\r\nint rc;\r\nchar alg[CRYPTO_MAX_ALG_NAME+1] = "aes";\r\ntfm = crypto_alloc_blkcipher(alg, 0, 0 );\r\nif (IS_ERR(tfm)) {\r\nCERROR("failed to load transform for aes\n");\r\nreturn PTR_ERR(tfm);\r\n}\r\nmin = ll_crypto_tfm_alg_min_keysize(tfm);\r\nif (keylen < min) {\r\nCERROR("keylen at least %d bits for aes\n", min * 8);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nrc = crypto_blkcipher_setkey(tfm, key, min);\r\nif (rc) {\r\nCERROR("failed to setting key for aes\n");\r\nGOTO(out, rc);\r\n}\r\nsg_set_page(&sd, virt_to_page(d), 16,\r\n(unsigned long)(d) % PAGE_CACHE_SIZE);\r\nsg_set_page(&ss, virt_to_page(s), 16,\r\n(unsigned long)(s) % PAGE_CACHE_SIZE);\r\ndesc.tfm = tfm;\r\ndesc.info = NULL;\r\ndesc.flags = 0;\r\nrc = crypto_blkcipher_encrypt(&desc, &sd, &ss, 16);\r\nif (rc) {\r\nCERROR("failed to encrypt for aes\n");\r\nGOTO(out, rc);\r\n}\r\nout:\r\ncrypto_free_blkcipher(tfm);\r\nreturn rc;\r\n}\r\nint capa_decrypt_id(__u32 *d, __u32 *s, __u8 *key, int keylen)\r\n{\r\nstruct crypto_blkcipher *tfm;\r\nstruct scatterlist sd;\r\nstruct scatterlist ss;\r\nstruct blkcipher_desc desc;\r\nunsigned int min;\r\nint rc;\r\nchar alg[CRYPTO_MAX_ALG_NAME+1] = "aes";\r\ntfm = crypto_alloc_blkcipher(alg, 0, 0 );\r\nif (IS_ERR(tfm)) {\r\nCERROR("failed to load transform for aes\n");\r\nreturn PTR_ERR(tfm);\r\n}\r\nmin = ll_crypto_tfm_alg_min_keysize(tfm);\r\nif (keylen < min) {\r\nCERROR("keylen at least %d bits for aes\n", min * 8);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nrc = crypto_blkcipher_setkey(tfm, key, min);\r\nif (rc) {\r\nCERROR("failed to setting key for aes\n");\r\nGOTO(out, rc);\r\n}\r\nsg_set_page(&sd, virt_to_page(d), 16,\r\n(unsigned long)(d) % PAGE_CACHE_SIZE);\r\nsg_set_page(&ss, virt_to_page(s), 16,\r\n(unsigned long)(s) % PAGE_CACHE_SIZE);\r\ndesc.tfm = tfm;\r\ndesc.info = NULL;\r\ndesc.flags = 0;\r\nrc = crypto_blkcipher_decrypt(&desc, &sd, &ss, 16);\r\nif (rc) {\r\nCERROR("failed to decrypt for aes\n");\r\nGOTO(out, rc);\r\n}\r\nout:\r\ncrypto_free_blkcipher(tfm);\r\nreturn rc;\r\n}\r\nvoid capa_cpy(void *capa, struct obd_capa *ocapa)\r\n{\r\nspin_lock(&ocapa->c_lock);\r\n*(struct lustre_capa *)capa = ocapa->c_capa;\r\nspin_unlock(&ocapa->c_lock);\r\n}\r\nvoid _debug_capa(struct lustre_capa *c,\r\nstruct libcfs_debug_msg_data *msgdata,\r\nconst char *fmt, ... )\r\n{\r\nva_list args;\r\nva_start(args, fmt);\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" capability@%p fid "DFID" opc "LPX64" uid "LPU64\r\n" gid "LPU64" flags %u alg %d keyid %u timeout %u "\r\n"expiry %u\n", c, PFID(capa_fid(c)), capa_opc(c),\r\ncapa_uid(c), capa_gid(c), capa_flags(c),\r\ncapa_alg(c), capa_keyid(c), capa_timeout(c),\r\ncapa_expiry(c));\r\nva_end(args);\r\n}
