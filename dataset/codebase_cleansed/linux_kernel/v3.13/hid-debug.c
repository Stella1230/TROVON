static char *resolv_usage_page(unsigned page, struct seq_file *f) {\r\nconst struct hid_usage_entry *p;\r\nchar *buf = NULL;\r\nif (!f) {\r\nbuf = kzalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_ATOMIC);\r\nif (!buf)\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nfor (p = hid_usage_table; p->description; p++)\r\nif (p->page == page) {\r\nif (!f) {\r\nsnprintf(buf, HID_DEBUG_BUFSIZE, "%s",\r\np->description);\r\nreturn buf;\r\n}\r\nelse {\r\nseq_printf(f, "%s", p->description);\r\nreturn NULL;\r\n}\r\n}\r\nif (!f)\r\nsnprintf(buf, HID_DEBUG_BUFSIZE, "%04x", page);\r\nelse\r\nseq_printf(f, "%04x", page);\r\nreturn buf;\r\n}\r\nchar *hid_resolv_usage(unsigned usage, struct seq_file *f) {\r\nconst struct hid_usage_entry *p;\r\nchar *buf = NULL;\r\nint len = 0;\r\nbuf = resolv_usage_page(usage >> 16, f);\r\nif (IS_ERR(buf)) {\r\npr_err("error allocating HID debug buffer\n");\r\nreturn NULL;\r\n}\r\nif (!f) {\r\nlen = strlen(buf);\r\nsnprintf(buf+len, max(0, HID_DEBUG_BUFSIZE - len), ".");\r\nlen++;\r\n}\r\nelse {\r\nseq_printf(f, ".");\r\n}\r\nfor (p = hid_usage_table; p->description; p++)\r\nif (p->page == (usage >> 16)) {\r\nfor(++p; p->description && p->usage != 0; p++)\r\nif (p->usage == (usage & 0xffff)) {\r\nif (!f)\r\nsnprintf(buf + len,\r\nmax(0,HID_DEBUG_BUFSIZE - len - 1),\r\n"%s", p->description);\r\nelse\r\nseq_printf(f,\r\n"%s",\r\np->description);\r\nreturn buf;\r\n}\r\nbreak;\r\n}\r\nif (!f)\r\nsnprintf(buf + len, max(0, HID_DEBUG_BUFSIZE - len - 1),\r\n"%04x", usage & 0xffff);\r\nelse\r\nseq_printf(f, "%04x", usage & 0xffff);\r\nreturn buf;\r\n}\r\nstatic void tab(int n, struct seq_file *f) {\r\nseq_printf(f, "%*s", n, "");\r\n}\r\nvoid hid_dump_field(struct hid_field *field, int n, struct seq_file *f) {\r\nint j;\r\nif (field->physical) {\r\ntab(n, f);\r\nseq_printf(f, "Physical(");\r\nhid_resolv_usage(field->physical, f); seq_printf(f, ")\n");\r\n}\r\nif (field->logical) {\r\ntab(n, f);\r\nseq_printf(f, "Logical(");\r\nhid_resolv_usage(field->logical, f); seq_printf(f, ")\n");\r\n}\r\nif (field->application) {\r\ntab(n, f);\r\nseq_printf(f, "Application(");\r\nhid_resolv_usage(field->application, f); seq_printf(f, ")\n");\r\n}\r\ntab(n, f); seq_printf(f, "Usage(%d)\n", field->maxusage);\r\nfor (j = 0; j < field->maxusage; j++) {\r\ntab(n+2, f); hid_resolv_usage(field->usage[j].hid, f); seq_printf(f, "\n");\r\n}\r\nif (field->logical_minimum != field->logical_maximum) {\r\ntab(n, f); seq_printf(f, "Logical Minimum(%d)\n", field->logical_minimum);\r\ntab(n, f); seq_printf(f, "Logical Maximum(%d)\n", field->logical_maximum);\r\n}\r\nif (field->physical_minimum != field->physical_maximum) {\r\ntab(n, f); seq_printf(f, "Physical Minimum(%d)\n", field->physical_minimum);\r\ntab(n, f); seq_printf(f, "Physical Maximum(%d)\n", field->physical_maximum);\r\n}\r\nif (field->unit_exponent) {\r\ntab(n, f); seq_printf(f, "Unit Exponent(%d)\n", field->unit_exponent);\r\n}\r\nif (field->unit) {\r\nstatic const char *systems[5] = { "None", "SI Linear", "SI Rotation", "English Linear", "English Rotation" };\r\nstatic const char *units[5][8] = {\r\n{ "None", "None", "None", "None", "None", "None", "None", "None" },\r\n{ "None", "Centimeter", "Gram", "Seconds", "Kelvin", "Ampere", "Candela", "None" },\r\n{ "None", "Radians", "Gram", "Seconds", "Kelvin", "Ampere", "Candela", "None" },\r\n{ "None", "Inch", "Slug", "Seconds", "Fahrenheit", "Ampere", "Candela", "None" },\r\n{ "None", "Degrees", "Slug", "Seconds", "Fahrenheit", "Ampere", "Candela", "None" }\r\n};\r\nint i;\r\nint sys;\r\n__u32 data = field->unit;\r\nsys = data & 0xf;\r\ndata >>= 4;\r\nif(sys > 4) {\r\ntab(n, f); seq_printf(f, "Unit(Invalid)\n");\r\n}\r\nelse {\r\nint earlier_unit = 0;\r\ntab(n, f); seq_printf(f, "Unit(%s : ", systems[sys]);\r\nfor (i=1 ; i<sizeof(__u32)*2 ; i++) {\r\nchar nibble = data & 0xf;\r\ndata >>= 4;\r\nif (nibble != 0) {\r\nif(earlier_unit++ > 0)\r\nseq_printf(f, "*");\r\nseq_printf(f, "%s", units[sys][i]);\r\nif(nibble != 1) {\r\nint val = nibble & 0x7;\r\nif(nibble & 0x08)\r\nval = -((0x7 & ~val) +1);\r\nseq_printf(f, "^%d", val);\r\n}\r\n}\r\n}\r\nseq_printf(f, ")\n");\r\n}\r\n}\r\ntab(n, f); seq_printf(f, "Report Size(%u)\n", field->report_size);\r\ntab(n, f); seq_printf(f, "Report Count(%u)\n", field->report_count);\r\ntab(n, f); seq_printf(f, "Report Offset(%u)\n", field->report_offset);\r\ntab(n, f); seq_printf(f, "Flags( ");\r\nj = field->flags;\r\nseq_printf(f, "%s", HID_MAIN_ITEM_CONSTANT & j ? "Constant " : "");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_VARIABLE & j ? "Variable " : "Array ");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_RELATIVE & j ? "Relative " : "Absolute ");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_WRAP & j ? "Wrap " : "");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_NONLINEAR & j ? "NonLinear " : "");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_NO_PREFERRED & j ? "NoPreferredState " : "");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_NULL_STATE & j ? "NullState " : "");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_VOLATILE & j ? "Volatile " : "");\r\nseq_printf(f, "%s", HID_MAIN_ITEM_BUFFERED_BYTE & j ? "BufferedByte " : "");\r\nseq_printf(f, ")\n");\r\n}\r\nvoid hid_dump_device(struct hid_device *device, struct seq_file *f)\r\n{\r\nstruct hid_report_enum *report_enum;\r\nstruct hid_report *report;\r\nstruct list_head *list;\r\nunsigned i,k;\r\nstatic const char *table[] = {"INPUT", "OUTPUT", "FEATURE"};\r\nfor (i = 0; i < HID_REPORT_TYPES; i++) {\r\nreport_enum = device->report_enum + i;\r\nlist = report_enum->report_list.next;\r\nwhile (list != &report_enum->report_list) {\r\nreport = (struct hid_report *) list;\r\ntab(2, f);\r\nseq_printf(f, "%s", table[i]);\r\nif (report->id)\r\nseq_printf(f, "(%d)", report->id);\r\nseq_printf(f, "[%s]", table[report->type]);\r\nseq_printf(f, "\n");\r\nfor (k = 0; k < report->maxfield; k++) {\r\ntab(4, f);\r\nseq_printf(f, "Field(%d)\n", k);\r\nhid_dump_field(report->field[k], 6, f);\r\n}\r\nlist = list->next;\r\n}\r\n}\r\n}\r\nvoid hid_debug_event(struct hid_device *hdev, char *buf)\r\n{\r\nint i;\r\nstruct hid_debug_list *list;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hdev->debug_list_lock, flags);\r\nlist_for_each_entry(list, &hdev->debug_list, node) {\r\nfor (i = 0; i < strlen(buf); i++)\r\nlist->hid_debug_buf[(list->tail + i) % HID_DEBUG_BUFSIZE] =\r\nbuf[i];\r\nlist->tail = (list->tail + i) % HID_DEBUG_BUFSIZE;\r\n}\r\nspin_unlock_irqrestore(&hdev->debug_list_lock, flags);\r\nwake_up_interruptible(&hdev->debug_wait);\r\n}\r\nvoid hid_dump_report(struct hid_device *hid, int type, u8 *data,\r\nint size)\r\n{\r\nstruct hid_report_enum *report_enum;\r\nchar *buf;\r\nunsigned int i;\r\nbuf = kmalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_ATOMIC);\r\nif (!buf)\r\nreturn;\r\nreport_enum = hid->report_enum + type;\r\nsnprintf(buf, HID_DEBUG_BUFSIZE - 1,\r\n"\nreport (size %u) (%snumbered) = ", size,\r\nreport_enum->numbered ? "" : "un");\r\nhid_debug_event(hid, buf);\r\nfor (i = 0; i < size; i++) {\r\nsnprintf(buf, HID_DEBUG_BUFSIZE - 1,\r\n" %02x", data[i]);\r\nhid_debug_event(hid, buf);\r\n}\r\nhid_debug_event(hid, "\n");\r\nkfree(buf);\r\n}\r\nvoid hid_dump_input(struct hid_device *hdev, struct hid_usage *usage, __s32 value)\r\n{\r\nchar *buf;\r\nint len;\r\nbuf = hid_resolv_usage(usage->hid, NULL);\r\nif (!buf)\r\nreturn;\r\nlen = strlen(buf);\r\nsnprintf(buf + len, HID_DEBUG_BUFSIZE - len - 1, " = %d\n", value);\r\nhid_debug_event(hdev, buf);\r\nkfree(buf);\r\nwake_up_interruptible(&hdev->debug_wait);\r\n}\r\nstatic void hid_resolv_event(__u8 type, __u16 code, struct seq_file *f)\r\n{\r\nseq_printf(f, "%s.%s", events[type] ? events[type] : "?",\r\nnames[type] ? (names[type][code] ? names[type][code] : "?") : "?");\r\n}\r\nstatic void hid_dump_input_mapping(struct hid_device *hid, struct seq_file *f)\r\n{\r\nint i, j, k;\r\nstruct hid_report *report;\r\nstruct hid_usage *usage;\r\nfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\r\nlist_for_each_entry(report, &hid->report_enum[k].report_list, list) {\r\nfor (i = 0; i < report->maxfield; i++) {\r\nfor ( j = 0; j < report->field[i]->maxusage; j++) {\r\nusage = report->field[i]->usage + j;\r\nhid_resolv_usage(usage->hid, f);\r\nseq_printf(f, " ---> ");\r\nhid_resolv_event(usage->type, usage->code, f);\r\nseq_printf(f, "\n");\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic int hid_debug_rdesc_show(struct seq_file *f, void *p)\r\n{\r\nstruct hid_device *hdev = f->private;\r\nconst __u8 *rdesc = hdev->rdesc;\r\nunsigned rsize = hdev->rsize;\r\nint i;\r\nif (!rdesc) {\r\nrdesc = hdev->dev_rdesc;\r\nrsize = hdev->dev_rsize;\r\n}\r\nfor (i = 0; i < rsize; i++)\r\nseq_printf(f, "%02x ", rdesc[i]);\r\nseq_printf(f, "\n\n");\r\nhid_dump_device(hdev, f);\r\nseq_printf(f, "\n");\r\nhid_dump_input_mapping(hdev, f);\r\nreturn 0;\r\n}\r\nstatic int hid_debug_rdesc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, hid_debug_rdesc_show, inode->i_private);\r\n}\r\nstatic int hid_debug_events_open(struct inode *inode, struct file *file)\r\n{\r\nint err = 0;\r\nstruct hid_debug_list *list;\r\nunsigned long flags;\r\nif (!(list = kzalloc(sizeof(struct hid_debug_list), GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!(list->hid_debug_buf = kzalloc(sizeof(char) * HID_DEBUG_BUFSIZE, GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\nkfree(list);\r\ngoto out;\r\n}\r\nlist->hdev = (struct hid_device *) inode->i_private;\r\nfile->private_data = list;\r\nmutex_init(&list->read_mutex);\r\nspin_lock_irqsave(&list->hdev->debug_list_lock, flags);\r\nlist_add_tail(&list->node, &list->hdev->debug_list);\r\nspin_unlock_irqrestore(&list->hdev->debug_list_lock, flags);\r\nout:\r\nreturn err;\r\n}\r\nstatic ssize_t hid_debug_events_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct hid_debug_list *list = file->private_data;\r\nint ret = 0, len;\r\nDECLARE_WAITQUEUE(wait, current);\r\nmutex_lock(&list->read_mutex);\r\nwhile (ret == 0) {\r\nif (list->head == list->tail) {\r\nadd_wait_queue(&list->hdev->debug_wait, &wait);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (list->head == list->tail) {\r\nif (file->f_flags & O_NONBLOCK) {\r\nret = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nret = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (!list->hdev || !list->hdev->debug) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nmutex_unlock(&list->read_mutex);\r\nschedule();\r\nmutex_lock(&list->read_mutex);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nset_current_state(TASK_RUNNING);\r\nremove_wait_queue(&list->hdev->debug_wait, &wait);\r\n}\r\nif (ret)\r\ngoto out;\r\ncopy_rest:\r\nif (list->tail == list->head)\r\ngoto out;\r\nif (list->tail > list->head) {\r\nlen = list->tail - list->head;\r\nif (copy_to_user(buffer + ret, &list->hid_debug_buf[list->head], len)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret += len;\r\nlist->head += len;\r\n} else {\r\nlen = HID_DEBUG_BUFSIZE - list->head;\r\nif (copy_to_user(buffer, &list->hid_debug_buf[list->head], len)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nlist->head = 0;\r\nret += len;\r\ngoto copy_rest;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&list->read_mutex);\r\nreturn ret;\r\n}\r\nstatic unsigned int hid_debug_events_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct hid_debug_list *list = file->private_data;\r\npoll_wait(file, &list->hdev->debug_wait, wait);\r\nif (list->head != list->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nif (!list->hdev->debug)\r\nreturn POLLERR | POLLHUP;\r\nreturn 0;\r\n}\r\nstatic int hid_debug_events_release(struct inode *inode, struct file *file)\r\n{\r\nstruct hid_debug_list *list = file->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&list->hdev->debug_list_lock, flags);\r\nlist_del(&list->node);\r\nspin_unlock_irqrestore(&list->hdev->debug_list_lock, flags);\r\nkfree(list->hid_debug_buf);\r\nkfree(list);\r\nreturn 0;\r\n}\r\nvoid hid_debug_register(struct hid_device *hdev, const char *name)\r\n{\r\nhdev->debug_dir = debugfs_create_dir(name, hid_debug_root);\r\nhdev->debug_rdesc = debugfs_create_file("rdesc", 0400,\r\nhdev->debug_dir, hdev, &hid_debug_rdesc_fops);\r\nhdev->debug_events = debugfs_create_file("events", 0400,\r\nhdev->debug_dir, hdev, &hid_debug_events_fops);\r\nhdev->debug = 1;\r\n}\r\nvoid hid_debug_unregister(struct hid_device *hdev)\r\n{\r\nhdev->debug = 0;\r\nwake_up_interruptible(&hdev->debug_wait);\r\ndebugfs_remove(hdev->debug_rdesc);\r\ndebugfs_remove(hdev->debug_events);\r\ndebugfs_remove(hdev->debug_dir);\r\n}\r\nvoid hid_debug_init(void)\r\n{\r\nhid_debug_root = debugfs_create_dir("hid", NULL);\r\n}\r\nvoid hid_debug_exit(void)\r\n{\r\ndebugfs_remove_recursive(hid_debug_root);\r\n}
