static int is_empty(void *buf, int len)\r\n{\r\nuint8_t *p = buf;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (*p++ != 0xff)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int first_non_ff(void *buf, int len)\r\n{\r\nuint8_t *p = buf;\r\nint i;\r\nfor (i = 0; i < len; i++)\r\nif (*p++ != 0xff)\r\nreturn i;\r\nreturn -1;\r\n}\r\nstatic int get_master_node(const struct ubifs_info *c, int lnum, void **pbuf,\r\nstruct ubifs_mst_node **mst, void **cor)\r\n{\r\nconst int sz = c->mst_node_alsz;\r\nint err, offs, len;\r\nvoid *sbuf, *buf;\r\nsbuf = vmalloc(c->leb_size);\r\nif (!sbuf)\r\nreturn -ENOMEM;\r\nerr = ubifs_leb_read(c, lnum, sbuf, 0, c->leb_size, 0);\r\nif (err && err != -EBADMSG)\r\ngoto out_free;\r\noffs = 0;\r\nbuf = sbuf;\r\nlen = c->leb_size;\r\nwhile (offs + UBIFS_MST_NODE_SZ <= c->leb_size) {\r\nstruct ubifs_ch *ch = buf;\r\nif (le32_to_cpu(ch->magic) != UBIFS_NODE_MAGIC)\r\nbreak;\r\noffs += sz;\r\nbuf += sz;\r\nlen -= sz;\r\n}\r\nif (offs) {\r\nint ret;\r\noffs -= sz;\r\nbuf -= sz;\r\nlen += sz;\r\nret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\r\nif (ret != SCANNED_A_NODE && offs) {\r\noffs -= sz;\r\nbuf -= sz;\r\nlen += sz;\r\nret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\r\nif (ret != SCANNED_A_NODE)\r\ngoto out_err;\r\n}\r\nif (ret == SCANNED_A_NODE) {\r\nstruct ubifs_ch *ch = buf;\r\nif (ch->node_type != UBIFS_MST_NODE)\r\ngoto out_err;\r\ndbg_rcvry("found a master node at %d:%d", lnum, offs);\r\n*mst = buf;\r\noffs += sz;\r\nbuf += sz;\r\nlen -= sz;\r\n}\r\n}\r\nif (offs < c->leb_size) {\r\nif (!is_empty(buf, min_t(int, len, sz))) {\r\n*cor = buf;\r\ndbg_rcvry("found corruption at %d:%d", lnum, offs);\r\n}\r\noffs += sz;\r\nbuf += sz;\r\nlen -= sz;\r\n}\r\nif (offs < c->leb_size)\r\nif (!is_empty(buf, len))\r\ngoto out_err;\r\n*pbuf = sbuf;\r\nreturn 0;\r\nout_err:\r\nerr = -EINVAL;\r\nout_free:\r\nvfree(sbuf);\r\n*mst = NULL;\r\n*cor = NULL;\r\nreturn err;\r\n}\r\nstatic int write_rcvrd_mst_node(struct ubifs_info *c,\r\nstruct ubifs_mst_node *mst)\r\n{\r\nint err = 0, lnum = UBIFS_MST_LNUM, sz = c->mst_node_alsz;\r\n__le32 save_flags;\r\ndbg_rcvry("recovery");\r\nsave_flags = mst->flags;\r\nmst->flags |= cpu_to_le32(UBIFS_MST_RCVRY);\r\nubifs_prepare_node(c, mst, UBIFS_MST_NODE_SZ, 1);\r\nerr = ubifs_leb_change(c, lnum, mst, sz);\r\nif (err)\r\ngoto out;\r\nerr = ubifs_leb_change(c, lnum + 1, mst, sz);\r\nif (err)\r\ngoto out;\r\nout:\r\nmst->flags = save_flags;\r\nreturn err;\r\n}\r\nint ubifs_recover_master_node(struct ubifs_info *c)\r\n{\r\nvoid *buf1 = NULL, *buf2 = NULL, *cor1 = NULL, *cor2 = NULL;\r\nstruct ubifs_mst_node *mst1 = NULL, *mst2 = NULL, *mst;\r\nconst int sz = c->mst_node_alsz;\r\nint err, offs1, offs2;\r\ndbg_rcvry("recovery");\r\nerr = get_master_node(c, UBIFS_MST_LNUM, &buf1, &mst1, &cor1);\r\nif (err)\r\ngoto out_free;\r\nerr = get_master_node(c, UBIFS_MST_LNUM + 1, &buf2, &mst2, &cor2);\r\nif (err)\r\ngoto out_free;\r\nif (mst1) {\r\noffs1 = (void *)mst1 - buf1;\r\nif ((le32_to_cpu(mst1->flags) & UBIFS_MST_RCVRY) &&\r\n(offs1 == 0 && !cor1)) {\r\ndbg_rcvry("recovery recovery");\r\nmst = mst1;\r\n} else if (mst2) {\r\noffs2 = (void *)mst2 - buf2;\r\nif (offs1 == offs2) {\r\nif (memcmp((void *)mst1 + UBIFS_CH_SZ,\r\n(void *)mst2 + UBIFS_CH_SZ,\r\nUBIFS_MST_NODE_SZ - UBIFS_CH_SZ))\r\ngoto out_err;\r\nmst = mst1;\r\n} else if (offs2 + sz == offs1) {\r\nif (cor1)\r\ngoto out_err;\r\nmst = mst1;\r\n} else if (offs1 == 0 &&\r\nc->leb_size - offs2 - sz < sz) {\r\nif (cor1)\r\ngoto out_err;\r\nmst = mst1;\r\n} else\r\ngoto out_err;\r\n} else {\r\nif (offs1 != 0 || cor1)\r\ngoto out_err;\r\nmst = mst1;\r\n}\r\n} else {\r\nif (!mst2)\r\ngoto out_err;\r\noffs2 = (void *)mst2 - buf2;\r\nif (offs2 + sz + sz <= c->leb_size)\r\ngoto out_err;\r\nmst = mst2;\r\n}\r\nubifs_msg("recovered master node from LEB %d",\r\n(mst == mst1 ? UBIFS_MST_LNUM : UBIFS_MST_LNUM + 1));\r\nmemcpy(c->mst_node, mst, UBIFS_MST_NODE_SZ);\r\nif (c->ro_mount) {\r\nc->rcvrd_mst_node = kmalloc(sz, GFP_KERNEL);\r\nif (!c->rcvrd_mst_node) {\r\nerr = -ENOMEM;\r\ngoto out_free;\r\n}\r\nmemcpy(c->rcvrd_mst_node, c->mst_node, UBIFS_MST_NODE_SZ);\r\nc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\r\n} else {\r\nc->max_sqnum = le64_to_cpu(mst->ch.sqnum) - 1;\r\nerr = write_rcvrd_mst_node(c, c->mst_node);\r\nif (err)\r\ngoto out_free;\r\n}\r\nvfree(buf2);\r\nvfree(buf1);\r\nreturn 0;\r\nout_err:\r\nerr = -EINVAL;\r\nout_free:\r\nubifs_err("failed to recover master node");\r\nif (mst1) {\r\nubifs_err("dumping first master node");\r\nubifs_dump_node(c, mst1);\r\n}\r\nif (mst2) {\r\nubifs_err("dumping second master node");\r\nubifs_dump_node(c, mst2);\r\n}\r\nvfree(buf2);\r\nvfree(buf1);\r\nreturn err;\r\n}\r\nint ubifs_write_rcvrd_mst_node(struct ubifs_info *c)\r\n{\r\nint err;\r\nif (!c->rcvrd_mst_node)\r\nreturn 0;\r\nc->rcvrd_mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\r\nc->mst_node->flags |= cpu_to_le32(UBIFS_MST_DIRTY);\r\nerr = write_rcvrd_mst_node(c, c->rcvrd_mst_node);\r\nif (err)\r\nreturn err;\r\nkfree(c->rcvrd_mst_node);\r\nc->rcvrd_mst_node = NULL;\r\nreturn 0;\r\n}\r\nstatic int is_last_write(const struct ubifs_info *c, void *buf, int offs)\r\n{\r\nint empty_offs, check_len;\r\nuint8_t *p;\r\nempty_offs = ALIGN(offs + 1, c->max_write_size);\r\ncheck_len = c->leb_size - empty_offs;\r\np = buf + empty_offs - offs;\r\nreturn is_empty(p, check_len);\r\n}\r\nstatic void clean_buf(const struct ubifs_info *c, void **buf, int lnum,\r\nint *offs, int *len)\r\n{\r\nint empty_offs, pad_len;\r\nlnum = lnum;\r\ndbg_rcvry("cleaning corruption at %d:%d", lnum, *offs);\r\nubifs_assert(!(*offs & 7));\r\nempty_offs = ALIGN(*offs, c->min_io_size);\r\npad_len = empty_offs - *offs;\r\nubifs_pad(c, *buf, pad_len);\r\n*offs += pad_len;\r\n*buf += pad_len;\r\n*len -= pad_len;\r\nmemset(*buf, 0xff, c->leb_size - empty_offs);\r\n}\r\nstatic int no_more_nodes(const struct ubifs_info *c, void *buf, int len,\r\nint lnum, int offs)\r\n{\r\nstruct ubifs_ch *ch = buf;\r\nint skip, dlen = le32_to_cpu(ch->len);\r\nskip = ALIGN(offs + UBIFS_CH_SZ, c->max_write_size) - offs;\r\nif (is_empty(buf + skip, len - skip))\r\nreturn 1;\r\nif (ubifs_check_node(c, buf, lnum, offs, 1, 0) != -EUCLEAN) {\r\ndbg_rcvry("unexpected bad common header at %d:%d", lnum, offs);\r\nreturn 0;\r\n}\r\nskip = ALIGN(offs + dlen, c->max_write_size) - offs;\r\nif (is_empty(buf + skip, len - skip))\r\nreturn 1;\r\ndbg_rcvry("unexpected data at %d:%d", lnum, offs + skip);\r\nreturn 0;\r\n}\r\nstatic int fix_unclean_leb(struct ubifs_info *c, struct ubifs_scan_leb *sleb,\r\nint start)\r\n{\r\nint lnum = sleb->lnum, endpt = start;\r\nif (!list_empty(&sleb->nodes)) {\r\nstruct ubifs_scan_node *snod;\r\nsnod = list_entry(sleb->nodes.prev,\r\nstruct ubifs_scan_node, list);\r\nendpt = snod->offs + snod->len;\r\n}\r\nif (c->ro_mount && !c->remounting_rw) {\r\nstruct ubifs_unclean_leb *ucleb;\r\ndbg_rcvry("need to fix LEB %d start %d endpt %d",\r\nlnum, start, sleb->endpt);\r\nucleb = kzalloc(sizeof(struct ubifs_unclean_leb), GFP_NOFS);\r\nif (!ucleb)\r\nreturn -ENOMEM;\r\nucleb->lnum = lnum;\r\nucleb->endpt = endpt;\r\nlist_add_tail(&ucleb->list, &c->unclean_leb_list);\r\n} else {\r\nint err;\r\ndbg_rcvry("fixing LEB %d start %d endpt %d",\r\nlnum, start, sleb->endpt);\r\nif (endpt == 0) {\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\n} else {\r\nint len = ALIGN(endpt, c->min_io_size);\r\nif (start) {\r\nerr = ubifs_leb_read(c, lnum, sleb->buf, 0,\r\nstart, 1);\r\nif (err)\r\nreturn err;\r\n}\r\nif (len > endpt) {\r\nint pad_len = len - ALIGN(endpt, 8);\r\nif (pad_len > 0) {\r\nvoid *buf = sleb->buf + len - pad_len;\r\nubifs_pad(c, buf, pad_len);\r\n}\r\n}\r\nerr = ubifs_leb_change(c, lnum, sleb->buf, len);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void drop_last_group(struct ubifs_scan_leb *sleb, int *offs)\r\n{\r\nwhile (!list_empty(&sleb->nodes)) {\r\nstruct ubifs_scan_node *snod;\r\nstruct ubifs_ch *ch;\r\nsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\r\nlist);\r\nch = snod->node;\r\nif (ch->group_type != UBIFS_IN_NODE_GROUP)\r\nbreak;\r\ndbg_rcvry("dropping grouped node at %d:%d",\r\nsleb->lnum, snod->offs);\r\n*offs = snod->offs;\r\nlist_del(&snod->list);\r\nkfree(snod);\r\nsleb->nodes_cnt -= 1;\r\n}\r\n}\r\nstatic void drop_last_node(struct ubifs_scan_leb *sleb, int *offs)\r\n{\r\nstruct ubifs_scan_node *snod;\r\nif (!list_empty(&sleb->nodes)) {\r\nsnod = list_entry(sleb->nodes.prev, struct ubifs_scan_node,\r\nlist);\r\ndbg_rcvry("dropping last node at %d:%d",\r\nsleb->lnum, snod->offs);\r\n*offs = snod->offs;\r\nlist_del(&snod->list);\r\nkfree(snod);\r\nsleb->nodes_cnt -= 1;\r\n}\r\n}\r\nstruct ubifs_scan_leb *ubifs_recover_leb(struct ubifs_info *c, int lnum,\r\nint offs, void *sbuf, int jhead)\r\n{\r\nint ret = 0, err, len = c->leb_size - offs, start = offs, min_io_unit;\r\nint grouped = jhead == -1 ? 0 : c->jheads[jhead].grouped;\r\nstruct ubifs_scan_leb *sleb;\r\nvoid *buf = sbuf + offs;\r\ndbg_rcvry("%d:%d, jhead %d, grouped %d", lnum, offs, jhead, grouped);\r\nsleb = ubifs_start_scan(c, lnum, offs, sbuf);\r\nif (IS_ERR(sleb))\r\nreturn sleb;\r\nubifs_assert(len >= 8);\r\nwhile (len >= 8) {\r\ndbg_scan("look at LEB %d:%d (%d bytes left)",\r\nlnum, offs, len);\r\ncond_resched();\r\nret = ubifs_scan_a_node(c, buf, len, lnum, offs, 1);\r\nif (ret == SCANNED_A_NODE) {\r\nstruct ubifs_ch *ch = buf;\r\nint node_len;\r\nerr = ubifs_add_snod(c, sleb, buf, offs);\r\nif (err)\r\ngoto error;\r\nnode_len = ALIGN(le32_to_cpu(ch->len), 8);\r\noffs += node_len;\r\nbuf += node_len;\r\nlen -= node_len;\r\n} else if (ret > 0) {\r\noffs += ret;\r\nbuf += ret;\r\nlen -= ret;\r\n} else if (ret == SCANNED_EMPTY_SPACE ||\r\nret == SCANNED_GARBAGE ||\r\nret == SCANNED_A_BAD_PAD_NODE ||\r\nret == SCANNED_A_CORRUPT_NODE) {\r\ndbg_rcvry("found corruption (%d) at %d:%d",\r\nret, lnum, offs);\r\nbreak;\r\n} else {\r\nubifs_err("unexpected return value %d", ret);\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\n}\r\nif (ret == SCANNED_GARBAGE || ret == SCANNED_A_BAD_PAD_NODE) {\r\nif (!is_last_write(c, buf, offs))\r\ngoto corrupted_rescan;\r\n} else if (ret == SCANNED_A_CORRUPT_NODE) {\r\nif (!no_more_nodes(c, buf, len, lnum, offs))\r\ngoto corrupted_rescan;\r\n} else if (!is_empty(buf, len)) {\r\nif (!is_last_write(c, buf, offs)) {\r\nint corruption = first_non_ff(buf, len);\r\nubifs_err("corrupt empty space LEB %d:%d, corruption starts at %d",\r\nlnum, offs, corruption);\r\noffs += corruption;\r\nbuf += corruption;\r\ngoto corrupted;\r\n}\r\n}\r\nmin_io_unit = round_down(offs, c->min_io_size);\r\nif (grouped)\r\ndrop_last_group(sleb, &offs);\r\nif (jhead == GCHD) {\r\nwhile (offs > min_io_unit)\r\ndrop_last_node(sleb, &offs);\r\n}\r\nbuf = sbuf + offs;\r\nlen = c->leb_size - offs;\r\nclean_buf(c, &buf, lnum, &offs, &len);\r\nubifs_end_scan(c, sleb, lnum, offs);\r\nerr = fix_unclean_leb(c, sleb, start);\r\nif (err)\r\ngoto error;\r\nreturn sleb;\r\ncorrupted_rescan:\r\nubifs_err("corruption %d", ret);\r\nubifs_scan_a_node(c, buf, len, lnum, offs, 1);\r\ncorrupted:\r\nubifs_scanned_corruption(c, lnum, offs, buf);\r\nerr = -EUCLEAN;\r\nerror:\r\nubifs_err("LEB %d scanning failed", lnum);\r\nubifs_scan_destroy(sleb);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int get_cs_sqnum(struct ubifs_info *c, int lnum, int offs,\r\nunsigned long long *cs_sqnum)\r\n{\r\nstruct ubifs_cs_node *cs_node = NULL;\r\nint err, ret;\r\ndbg_rcvry("at %d:%d", lnum, offs);\r\ncs_node = kmalloc(UBIFS_CS_NODE_SZ, GFP_KERNEL);\r\nif (!cs_node)\r\nreturn -ENOMEM;\r\nif (c->leb_size - offs < UBIFS_CS_NODE_SZ)\r\ngoto out_err;\r\nerr = ubifs_leb_read(c, lnum, (void *)cs_node, offs,\r\nUBIFS_CS_NODE_SZ, 0);\r\nif (err && err != -EBADMSG)\r\ngoto out_free;\r\nret = ubifs_scan_a_node(c, cs_node, UBIFS_CS_NODE_SZ, lnum, offs, 0);\r\nif (ret != SCANNED_A_NODE) {\r\nubifs_err("Not a valid node");\r\ngoto out_err;\r\n}\r\nif (cs_node->ch.node_type != UBIFS_CS_NODE) {\r\nubifs_err("Node a CS node, type is %d", cs_node->ch.node_type);\r\ngoto out_err;\r\n}\r\nif (le64_to_cpu(cs_node->cmt_no) != c->cmt_no) {\r\nubifs_err("CS node cmt_no %llu != current cmt_no %llu",\r\n(unsigned long long)le64_to_cpu(cs_node->cmt_no),\r\nc->cmt_no);\r\ngoto out_err;\r\n}\r\n*cs_sqnum = le64_to_cpu(cs_node->ch.sqnum);\r\ndbg_rcvry("commit start sqnum %llu", *cs_sqnum);\r\nkfree(cs_node);\r\nreturn 0;\r\nout_err:\r\nerr = -EINVAL;\r\nout_free:\r\nubifs_err("failed to get CS sqnum");\r\nkfree(cs_node);\r\nreturn err;\r\n}\r\nstruct ubifs_scan_leb *ubifs_recover_log_leb(struct ubifs_info *c, int lnum,\r\nint offs, void *sbuf)\r\n{\r\nstruct ubifs_scan_leb *sleb;\r\nint next_lnum;\r\ndbg_rcvry("LEB %d", lnum);\r\nnext_lnum = lnum + 1;\r\nif (next_lnum >= UBIFS_LOG_LNUM + c->log_lebs)\r\nnext_lnum = UBIFS_LOG_LNUM;\r\nif (next_lnum != c->ltail_lnum) {\r\nsleb = ubifs_scan(c, next_lnum, 0, sbuf, 0);\r\nif (IS_ERR(sleb))\r\nreturn sleb;\r\nif (sleb->nodes_cnt) {\r\nstruct ubifs_scan_node *snod;\r\nunsigned long long cs_sqnum = c->cs_sqnum;\r\nsnod = list_entry(sleb->nodes.next,\r\nstruct ubifs_scan_node, list);\r\nif (cs_sqnum == 0) {\r\nint err;\r\nerr = get_cs_sqnum(c, lnum, offs, &cs_sqnum);\r\nif (err) {\r\nubifs_scan_destroy(sleb);\r\nreturn ERR_PTR(err);\r\n}\r\n}\r\nif (snod->sqnum > cs_sqnum) {\r\nubifs_err("unrecoverable log corruption in LEB %d",\r\nlnum);\r\nubifs_scan_destroy(sleb);\r\nreturn ERR_PTR(-EUCLEAN);\r\n}\r\n}\r\nubifs_scan_destroy(sleb);\r\n}\r\nreturn ubifs_recover_leb(c, lnum, offs, sbuf, -1);\r\n}\r\nstatic int recover_head(struct ubifs_info *c, int lnum, int offs, void *sbuf)\r\n{\r\nint len = c->max_write_size, err;\r\nif (offs + len > c->leb_size)\r\nlen = c->leb_size - offs;\r\nif (!len)\r\nreturn 0;\r\nerr = ubifs_leb_read(c, lnum, sbuf, offs, len, 1);\r\nif (err || !is_empty(sbuf, len)) {\r\ndbg_rcvry("cleaning head at %d:%d", lnum, offs);\r\nif (offs == 0)\r\nreturn ubifs_leb_unmap(c, lnum);\r\nerr = ubifs_leb_read(c, lnum, sbuf, 0, offs, 1);\r\nif (err)\r\nreturn err;\r\nreturn ubifs_leb_change(c, lnum, sbuf, offs);\r\n}\r\nreturn 0;\r\n}\r\nint ubifs_recover_inl_heads(struct ubifs_info *c, void *sbuf)\r\n{\r\nint err;\r\nubifs_assert(!c->ro_mount || c->remounting_rw);\r\ndbg_rcvry("checking index head at %d:%d", c->ihead_lnum, c->ihead_offs);\r\nerr = recover_head(c, c->ihead_lnum, c->ihead_offs, sbuf);\r\nif (err)\r\nreturn err;\r\ndbg_rcvry("checking LPT head at %d:%d", c->nhead_lnum, c->nhead_offs);\r\nerr = recover_head(c, c->nhead_lnum, c->nhead_offs, sbuf);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int clean_an_unclean_leb(struct ubifs_info *c,\r\nstruct ubifs_unclean_leb *ucleb, void *sbuf)\r\n{\r\nint err, lnum = ucleb->lnum, offs = 0, len = ucleb->endpt, quiet = 1;\r\nvoid *buf = sbuf;\r\ndbg_rcvry("LEB %d len %d", lnum, len);\r\nif (len == 0) {\r\nerr = ubifs_leb_unmap(c, lnum);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nerr = ubifs_leb_read(c, lnum, buf, offs, len, 0);\r\nif (err && err != -EBADMSG)\r\nreturn err;\r\nwhile (len >= 8) {\r\nint ret;\r\ncond_resched();\r\nret = ubifs_scan_a_node(c, buf, len, lnum, offs, quiet);\r\nif (ret == SCANNED_A_NODE) {\r\nstruct ubifs_ch *ch = buf;\r\nint node_len;\r\nnode_len = ALIGN(le32_to_cpu(ch->len), 8);\r\noffs += node_len;\r\nbuf += node_len;\r\nlen -= node_len;\r\ncontinue;\r\n}\r\nif (ret > 0) {\r\noffs += ret;\r\nbuf += ret;\r\nlen -= ret;\r\ncontinue;\r\n}\r\nif (ret == SCANNED_EMPTY_SPACE) {\r\nubifs_err("unexpected empty space at %d:%d",\r\nlnum, offs);\r\nreturn -EUCLEAN;\r\n}\r\nif (quiet) {\r\nquiet = 0;\r\ncontinue;\r\n}\r\nubifs_scanned_corruption(c, lnum, offs, buf);\r\nreturn -EUCLEAN;\r\n}\r\nlen = ALIGN(ucleb->endpt, c->min_io_size);\r\nif (len > ucleb->endpt) {\r\nint pad_len = len - ALIGN(ucleb->endpt, 8);\r\nif (pad_len > 0) {\r\nbuf = c->sbuf + len - pad_len;\r\nubifs_pad(c, buf, pad_len);\r\n}\r\n}\r\nerr = ubifs_leb_change(c, lnum, sbuf, len);\r\nif (err)\r\nreturn err;\r\ndbg_rcvry("cleaned LEB %d", lnum);\r\nreturn 0;\r\n}\r\nint ubifs_clean_lebs(struct ubifs_info *c, void *sbuf)\r\n{\r\ndbg_rcvry("recovery");\r\nwhile (!list_empty(&c->unclean_leb_list)) {\r\nstruct ubifs_unclean_leb *ucleb;\r\nint err;\r\nucleb = list_entry(c->unclean_leb_list.next,\r\nstruct ubifs_unclean_leb, list);\r\nerr = clean_an_unclean_leb(c, ucleb, sbuf);\r\nif (err)\r\nreturn err;\r\nlist_del(&ucleb->list);\r\nkfree(ucleb);\r\n}\r\nreturn 0;\r\n}\r\nstatic int grab_empty_leb(struct ubifs_info *c)\r\n{\r\nint lnum, err;\r\nlnum = ubifs_find_free_leb_for_idx(c);\r\nif (lnum < 0) {\r\nubifs_err("could not find an empty LEB");\r\nubifs_dump_lprops(c);\r\nubifs_dump_budg(c, &c->bi);\r\nreturn lnum;\r\n}\r\nerr = ubifs_change_one_lp(c, lnum, LPROPS_NC, LPROPS_NC, 0,\r\nLPROPS_INDEX, 0);\r\nif (err)\r\nreturn err;\r\nc->gc_lnum = lnum;\r\ndbg_rcvry("found empty LEB %d, run commit", lnum);\r\nreturn ubifs_run_commit(c);\r\n}\r\nint ubifs_rcvry_gc_commit(struct ubifs_info *c)\r\n{\r\nstruct ubifs_wbuf *wbuf = &c->jheads[GCHD].wbuf;\r\nstruct ubifs_lprops lp;\r\nint err;\r\ndbg_rcvry("GC head LEB %d, offs %d", wbuf->lnum, wbuf->offs);\r\nc->gc_lnum = -1;\r\nif (wbuf->lnum == -1 || wbuf->offs == c->leb_size)\r\nreturn grab_empty_leb(c);\r\nerr = ubifs_find_dirty_leb(c, &lp, wbuf->offs, 2);\r\nif (err) {\r\nif (err != -ENOSPC)\r\nreturn err;\r\ndbg_rcvry("could not find a dirty LEB");\r\nreturn grab_empty_leb(c);\r\n}\r\nubifs_assert(!(lp.flags & LPROPS_INDEX));\r\nubifs_assert(lp.free + lp.dirty >= wbuf->offs);\r\ndbg_rcvry("committing");\r\nerr = ubifs_run_commit(c);\r\nif (err)\r\nreturn err;\r\ndbg_rcvry("GC'ing LEB %d", lp.lnum);\r\nmutex_lock_nested(&wbuf->io_mutex, wbuf->jhead);\r\nerr = ubifs_garbage_collect_leb(c, &lp);\r\nif (err >= 0) {\r\nint err2 = ubifs_wbuf_sync_nolock(wbuf);\r\nif (err2)\r\nerr = err2;\r\n}\r\nmutex_unlock(&wbuf->io_mutex);\r\nif (err < 0) {\r\nubifs_err("GC failed, error %d", err);\r\nif (err == -EAGAIN)\r\nerr = -EINVAL;\r\nreturn err;\r\n}\r\nubifs_assert(err == LEB_RETAINED);\r\nif (err != LEB_RETAINED)\r\nreturn -EINVAL;\r\nerr = ubifs_leb_unmap(c, c->gc_lnum);\r\nif (err)\r\nreturn err;\r\ndbg_rcvry("allocated LEB %d for GC", lp.lnum);\r\nreturn 0;\r\n}\r\nstatic int add_ino(struct ubifs_info *c, ino_t inum, loff_t i_size,\r\nloff_t d_size, int exists)\r\n{\r\nstruct rb_node **p = &c->size_tree.rb_node, *parent = NULL;\r\nstruct size_entry *e;\r\nwhile (*p) {\r\nparent = *p;\r\ne = rb_entry(parent, struct size_entry, rb);\r\nif (inum < e->inum)\r\np = &(*p)->rb_left;\r\nelse\r\np = &(*p)->rb_right;\r\n}\r\ne = kzalloc(sizeof(struct size_entry), GFP_KERNEL);\r\nif (!e)\r\nreturn -ENOMEM;\r\ne->inum = inum;\r\ne->i_size = i_size;\r\ne->d_size = d_size;\r\ne->exists = exists;\r\nrb_link_node(&e->rb, parent, p);\r\nrb_insert_color(&e->rb, &c->size_tree);\r\nreturn 0;\r\n}\r\nstatic struct size_entry *find_ino(struct ubifs_info *c, ino_t inum)\r\n{\r\nstruct rb_node *p = c->size_tree.rb_node;\r\nstruct size_entry *e;\r\nwhile (p) {\r\ne = rb_entry(p, struct size_entry, rb);\r\nif (inum < e->inum)\r\np = p->rb_left;\r\nelse if (inum > e->inum)\r\np = p->rb_right;\r\nelse\r\nreturn e;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void remove_ino(struct ubifs_info *c, ino_t inum)\r\n{\r\nstruct size_entry *e = find_ino(c, inum);\r\nif (!e)\r\nreturn;\r\nrb_erase(&e->rb, &c->size_tree);\r\nkfree(e);\r\n}\r\nvoid ubifs_destroy_size_tree(struct ubifs_info *c)\r\n{\r\nstruct rb_node *this = c->size_tree.rb_node;\r\nstruct size_entry *e;\r\nwhile (this) {\r\nif (this->rb_left) {\r\nthis = this->rb_left;\r\ncontinue;\r\n} else if (this->rb_right) {\r\nthis = this->rb_right;\r\ncontinue;\r\n}\r\ne = rb_entry(this, struct size_entry, rb);\r\nif (e->inode)\r\niput(e->inode);\r\nthis = rb_parent(this);\r\nif (this) {\r\nif (this->rb_left == &e->rb)\r\nthis->rb_left = NULL;\r\nelse\r\nthis->rb_right = NULL;\r\n}\r\nkfree(e);\r\n}\r\nc->size_tree = RB_ROOT;\r\n}\r\nint ubifs_recover_size_accum(struct ubifs_info *c, union ubifs_key *key,\r\nint deletion, loff_t new_size)\r\n{\r\nino_t inum = key_inum(c, key);\r\nstruct size_entry *e;\r\nint err;\r\nswitch (key_type(c, key)) {\r\ncase UBIFS_INO_KEY:\r\nif (deletion)\r\nremove_ino(c, inum);\r\nelse {\r\ne = find_ino(c, inum);\r\nif (e) {\r\ne->i_size = new_size;\r\ne->exists = 1;\r\n} else {\r\nerr = add_ino(c, inum, new_size, 0, 1);\r\nif (err)\r\nreturn err;\r\n}\r\n}\r\nbreak;\r\ncase UBIFS_DATA_KEY:\r\ne = find_ino(c, inum);\r\nif (e) {\r\nif (new_size > e->d_size)\r\ne->d_size = new_size;\r\n} else {\r\nerr = add_ino(c, inum, 0, new_size, 0);\r\nif (err)\r\nreturn err;\r\n}\r\nbreak;\r\ncase UBIFS_TRUN_KEY:\r\ne = find_ino(c, inum);\r\nif (e)\r\ne->d_size = new_size;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fix_size_in_place(struct ubifs_info *c, struct size_entry *e)\r\n{\r\nstruct ubifs_ino_node *ino = c->sbuf;\r\nunsigned char *p;\r\nunion ubifs_key key;\r\nint err, lnum, offs, len;\r\nloff_t i_size;\r\nuint32_t crc;\r\nino_key_init(c, &key, e->inum);\r\nerr = ubifs_tnc_locate(c, &key, ino, &lnum, &offs);\r\nif (err)\r\ngoto out;\r\ni_size = le64_to_cpu(ino->size);\r\nif (i_size >= e->d_size)\r\nreturn 0;\r\nerr = ubifs_leb_read(c, lnum, c->sbuf, 0, c->leb_size, 1);\r\nif (err)\r\ngoto out;\r\nino = c->sbuf + offs;\r\nino->size = cpu_to_le64(e->d_size);\r\nlen = le32_to_cpu(ino->ch.len);\r\ncrc = crc32(UBIFS_CRC32_INIT, (void *)ino + 8, len - 8);\r\nino->ch.crc = cpu_to_le32(crc);\r\np = c->sbuf;\r\nlen = c->leb_size - 1;\r\nwhile (p[len] == 0xff)\r\nlen -= 1;\r\nlen = ALIGN(len + 1, c->min_io_size);\r\nerr = ubifs_leb_change(c, lnum, c->sbuf, len);\r\nif (err)\r\ngoto out;\r\ndbg_rcvry("inode %lu at %d:%d size %lld -> %lld",\r\n(unsigned long)e->inum, lnum, offs, i_size, e->d_size);\r\nreturn 0;\r\nout:\r\nubifs_warn("inode %lu failed to fix size %lld -> %lld error %d",\r\n(unsigned long)e->inum, e->i_size, e->d_size, err);\r\nreturn err;\r\n}\r\nint ubifs_recover_size(struct ubifs_info *c)\r\n{\r\nstruct rb_node *this = rb_first(&c->size_tree);\r\nwhile (this) {\r\nstruct size_entry *e;\r\nint err;\r\ne = rb_entry(this, struct size_entry, rb);\r\nif (!e->exists) {\r\nunion ubifs_key key;\r\nino_key_init(c, &key, e->inum);\r\nerr = ubifs_tnc_lookup(c, &key, c->sbuf);\r\nif (err && err != -ENOENT)\r\nreturn err;\r\nif (err == -ENOENT) {\r\ndbg_rcvry("removing ino %lu",\r\n(unsigned long)e->inum);\r\nerr = ubifs_tnc_remove_ino(c, e->inum);\r\nif (err)\r\nreturn err;\r\n} else {\r\nstruct ubifs_ino_node *ino = c->sbuf;\r\ne->exists = 1;\r\ne->i_size = le64_to_cpu(ino->size);\r\n}\r\n}\r\nif (e->exists && e->i_size < e->d_size) {\r\nif (c->ro_mount) {\r\nstruct inode *inode;\r\nstruct ubifs_inode *ui;\r\nubifs_assert(!e->inode);\r\ninode = ubifs_iget(c->vfs_sb, e->inum);\r\nif (IS_ERR(inode))\r\nreturn PTR_ERR(inode);\r\nui = ubifs_inode(inode);\r\nif (inode->i_size < e->d_size) {\r\ndbg_rcvry("ino %lu size %lld -> %lld",\r\n(unsigned long)e->inum,\r\ninode->i_size, e->d_size);\r\ninode->i_size = e->d_size;\r\nui->ui_size = e->d_size;\r\nui->synced_i_size = e->d_size;\r\ne->inode = inode;\r\nthis = rb_next(this);\r\ncontinue;\r\n}\r\niput(inode);\r\n} else {\r\nerr = fix_size_in_place(c, e);\r\nif (err)\r\nreturn err;\r\nif (e->inode)\r\niput(e->inode);\r\n}\r\n}\r\nthis = rb_next(this);\r\nrb_erase(&e->rb, &c->size_tree);\r\nkfree(e);\r\n}\r\nreturn 0;\r\n}
