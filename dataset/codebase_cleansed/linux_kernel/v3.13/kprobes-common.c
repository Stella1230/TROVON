void __init find_str_pc_offset(void)\r\n{\r\nint addr, scratch, ret;\r\n__asm__ (\r\n"sub %[ret], pc, #4 \n\t"\r\n"str pc, %[addr] \n\t"\r\n"ldr %[scr], %[addr] \n\t"\r\n"sub %[ret], %[scr], %[ret] \n\t"\r\n: [ret] "=r" (ret), [scr] "=r" (scratch), [addr] "+m" (addr));\r\nstr_pc_offset = ret;\r\n}\r\nvoid __init test_load_write_pc_interworking(void)\r\n{\r\nint arch = cpu_architecture();\r\nBUG_ON(arch == CPU_ARCH_UNKNOWN);\r\nload_write_pc_interworks = arch >= CPU_ARCH_ARMv5T;\r\n}\r\nvoid __init test_alu_write_pc_interworking(void)\r\n{\r\nint arch = cpu_architecture();\r\nBUG_ON(arch == CPU_ARCH_UNKNOWN);\r\nalu_write_pc_interworks = arch >= CPU_ARCH_ARMv7;\r\n}\r\nvoid __init arm_kprobe_decode_init(void)\r\n{\r\nfind_str_pc_offset();\r\ntest_load_write_pc_interworking();\r\ntest_alu_write_pc_interworking();\r\n}\r\nstatic unsigned long __kprobes __check_eq(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_Z_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_ne(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_Z_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_cs(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_cc(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_mi(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_pl(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_vs(unsigned long cpsr)\r\n{\r\nreturn cpsr & PSR_V_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_vc(unsigned long cpsr)\r\n{\r\nreturn (~cpsr) & PSR_V_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_hi(unsigned long cpsr)\r\n{\r\ncpsr &= ~(cpsr >> 1);\r\nreturn cpsr & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_ls(unsigned long cpsr)\r\n{\r\ncpsr &= ~(cpsr >> 1);\r\nreturn (~cpsr) & PSR_C_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_ge(unsigned long cpsr)\r\n{\r\ncpsr ^= (cpsr << 3);\r\nreturn (~cpsr) & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_lt(unsigned long cpsr)\r\n{\r\ncpsr ^= (cpsr << 3);\r\nreturn cpsr & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_gt(unsigned long cpsr)\r\n{\r\nunsigned long temp = cpsr ^ (cpsr << 3);\r\ntemp |= (cpsr << 1);\r\nreturn (~temp) & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_le(unsigned long cpsr)\r\n{\r\nunsigned long temp = cpsr ^ (cpsr << 3);\r\ntemp |= (cpsr << 1);\r\nreturn temp & PSR_N_BIT;\r\n}\r\nstatic unsigned long __kprobes __check_al(unsigned long cpsr)\r\n{\r\nreturn true;\r\n}\r\nvoid __kprobes kprobe_simulate_nop(struct kprobe *p, struct pt_regs *regs)\r\n{\r\n}\r\nvoid __kprobes kprobe_emulate_none(struct kprobe *p, struct pt_regs *regs)\r\n{\r\np->ainsn.insn_fn();\r\n}\r\nstatic void __kprobes simulate_ldm1stm1(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nkprobe_opcode_t insn = p->opcode;\r\nint rn = (insn >> 16) & 0xf;\r\nint lbit = insn & (1 << 20);\r\nint wbit = insn & (1 << 21);\r\nint ubit = insn & (1 << 23);\r\nint pbit = insn & (1 << 24);\r\nlong *addr = (long *)regs->uregs[rn];\r\nint reg_bit_vector;\r\nint reg_count;\r\nreg_count = 0;\r\nreg_bit_vector = insn & 0xffff;\r\nwhile (reg_bit_vector) {\r\nreg_bit_vector &= (reg_bit_vector - 1);\r\n++reg_count;\r\n}\r\nif (!ubit)\r\naddr -= reg_count;\r\naddr += (!pbit == !ubit);\r\nreg_bit_vector = insn & 0xffff;\r\nwhile (reg_bit_vector) {\r\nint reg = __ffs(reg_bit_vector);\r\nreg_bit_vector &= (reg_bit_vector - 1);\r\nif (lbit)\r\nregs->uregs[reg] = *addr++;\r\nelse\r\n*addr++ = regs->uregs[reg];\r\n}\r\nif (wbit) {\r\nif (!ubit)\r\naddr -= reg_count;\r\naddr -= (!pbit == !ubit);\r\nregs->uregs[rn] = (long)addr;\r\n}\r\n}\r\nstatic void __kprobes simulate_stm1_pc(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nregs->ARM_pc = (long)p->addr + str_pc_offset;\r\nsimulate_ldm1stm1(p, regs);\r\nregs->ARM_pc = (long)p->addr + 4;\r\n}\r\nstatic void __kprobes simulate_ldm1_pc(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nsimulate_ldm1stm1(p, regs);\r\nload_write_pc(regs->ARM_pc, regs);\r\n}\r\nstatic void __kprobes\r\nemulate_generic_r0_12_noflags(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nregister void *rregs asm("r1") = regs;\r\nregister void *rfn asm("lr") = p->ainsn.insn_fn;\r\n__asm__ __volatile__ (\r\n"stmdb sp!, {%[regs], r11} \n\t"\r\n"ldmia %[regs], {r0-r12} \n\t"\r\n#if __LINUX_ARM_ARCH__ >= 6\r\n"blx %[fn] \n\t"\r\n#else\r\n"str %[fn], [sp, #-4]! \n\t"\r\n"adr lr, 1f \n\t"\r\n"ldr pc, [sp], #4 \n\t"\r\n"1: \n\t"\r\n#endif\r\n"ldr lr, [sp], #4 \n\t"\r\n"stmia lr, {r0-r12} \n\t"\r\n"ldr r11, [sp], #4 \n\t"\r\n: [regs] "=r" (rregs), [fn] "=r" (rfn)\r\n: "0" (rregs), "1" (rfn)\r\n: "r0", "r2", "r3", "r4", "r5", "r6", "r7",\r\n"r8", "r9", "r10", "r12", "memory", "cc"\r\n);\r\n}\r\nstatic void __kprobes\r\nemulate_generic_r2_14_noflags(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nemulate_generic_r0_12_noflags(p, (struct pt_regs *)(regs->uregs+2));\r\n}\r\nstatic void __kprobes\r\nemulate_ldm_r3_15(struct kprobe *p, struct pt_regs *regs)\r\n{\r\nemulate_generic_r0_12_noflags(p, (struct pt_regs *)(regs->uregs+3));\r\nload_write_pc(regs->ARM_pc, regs);\r\n}\r\nenum kprobe_insn __kprobes\r\nkprobe_decode_ldmstm(kprobe_opcode_t insn, struct arch_specific_insn *asi)\r\n{\r\nkprobe_insn_handler_t *handler = 0;\r\nunsigned reglist = insn & 0xffff;\r\nint is_ldm = insn & 0x100000;\r\nint rn = (insn >> 16) & 0xf;\r\nif (rn <= 12 && (reglist & 0xe000) == 0) {\r\nhandler = emulate_generic_r0_12_noflags;\r\n} else if (rn >= 2 && (reglist & 0x8003) == 0) {\r\nrn -= 2;\r\nreglist >>= 2;\r\nhandler = emulate_generic_r2_14_noflags;\r\n} else if (rn >= 3 && (reglist & 0x0007) == 0) {\r\nif (is_ldm && (reglist & 0x8000)) {\r\nrn -= 3;\r\nreglist >>= 3;\r\nhandler = emulate_ldm_r3_15;\r\n}\r\n}\r\nif (handler) {\r\nasi->insn[0] = (insn & 0xfff00000) | (rn << 16) | reglist;\r\nasi->insn_handler = handler;\r\nreturn INSN_GOOD;\r\n}\r\nif (reglist & 0x8000)\r\nhandler = is_ldm ? simulate_ldm1_pc : simulate_stm1_pc;\r\nelse\r\nhandler = simulate_ldm1stm1;\r\nasi->insn_handler = handler;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\nstatic kprobe_opcode_t __kprobes\r\nprepare_emulated_insn(kprobe_opcode_t insn, struct arch_specific_insn *asi,\r\nbool thumb)\r\n{\r\n#ifdef CONFIG_THUMB2_KERNEL\r\nif (thumb) {\r\nu16 *thumb_insn = (u16 *)asi->insn;\r\nthumb_insn[1] = 0x4770;\r\nthumb_insn[2] = 0x4770;\r\nreturn insn;\r\n}\r\nasi->insn[1] = 0xe12fff1e;\r\n#else\r\nasi->insn[1] = 0xe1a0f00e;\r\n#endif\r\nif (insn < 0xe0000000)\r\ninsn = (insn | 0xe0000000) & ~0x10000000;\r\nreturn insn;\r\n}\r\nstatic void __kprobes\r\nset_emulated_insn(kprobe_opcode_t insn, struct arch_specific_insn *asi,\r\nbool thumb)\r\n{\r\n#ifdef CONFIG_THUMB2_KERNEL\r\nif (thumb) {\r\nu16 *ip = (u16 *)asi->insn;\r\nif (is_wide_instruction(insn))\r\n*ip++ = insn >> 16;\r\n*ip++ = insn;\r\nreturn;\r\n}\r\n#endif\r\nasi->insn[0] = insn;\r\n}\r\nstatic bool __kprobes decode_regs(kprobe_opcode_t* pinsn, u32 regs)\r\n{\r\nkprobe_opcode_t insn = *pinsn;\r\nkprobe_opcode_t mask = 0xf;\r\nfor (; regs != 0; regs >>= 4, mask <<= 4) {\r\nkprobe_opcode_t new_bits = INSN_NEW_BITS;\r\nswitch (regs & 0xf) {\r\ncase REG_TYPE_NONE:\r\ncontinue;\r\ncase REG_TYPE_ANY:\r\nbreak;\r\ncase REG_TYPE_SAMEAS16:\r\nnew_bits = INSN_SAMEAS16_BITS;\r\nbreak;\r\ncase REG_TYPE_SP:\r\nif ((insn ^ 0xdddddddd) & mask)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_PC:\r\nif ((insn ^ 0xffffffff) & mask)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_NOSP:\r\nif (((insn ^ 0xdddddddd) & mask) == 0)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_NOSPPC:\r\ncase REG_TYPE_NOSPPCX:\r\nif (((insn ^ 0xdddddddd) & 0xdddddddd & mask) == 0)\r\ngoto reject;\r\nbreak;\r\ncase REG_TYPE_NOPCWB:\r\nif (!is_writeback(insn))\r\nbreak;\r\ncase REG_TYPE_NOPC:\r\ncase REG_TYPE_NOPCX:\r\nif (((insn ^ 0xffffffff) & mask) == 0)\r\ngoto reject;\r\nbreak;\r\n}\r\ninsn &= ~mask;\r\ninsn |= new_bits & mask;\r\n}\r\n*pinsn = insn;\r\nreturn true;\r\nreject:\r\nreturn false;\r\n}\r\nint __kprobes\r\nkprobe_decode_insn(kprobe_opcode_t insn, struct arch_specific_insn *asi,\r\nconst union decode_item *table, bool thumb)\r\n{\r\nconst struct decode_header *h = (struct decode_header *)table;\r\nconst struct decode_header *next;\r\nbool matched = false;\r\ninsn = prepare_emulated_insn(insn, asi, thumb);\r\nfor (;; h = next) {\r\nenum decode_type type = h->type_regs.bits & DECODE_TYPE_MASK;\r\nu32 regs = h->type_regs.bits >> DECODE_TYPE_BITS;\r\nif (type == DECODE_TYPE_END)\r\nreturn INSN_REJECTED;\r\nnext = (struct decode_header *)\r\n((uintptr_t)h + decode_struct_sizes[type]);\r\nif (!matched && (insn & h->mask.bits) != h->value.bits)\r\ncontinue;\r\nif (!decode_regs(&insn, regs))\r\nreturn INSN_REJECTED;\r\nswitch (type) {\r\ncase DECODE_TYPE_TABLE: {\r\nstruct decode_table *d = (struct decode_table *)h;\r\nnext = (struct decode_header *)d->table.table;\r\nbreak;\r\n}\r\ncase DECODE_TYPE_CUSTOM: {\r\nstruct decode_custom *d = (struct decode_custom *)h;\r\nreturn (*d->decoder.decoder)(insn, asi);\r\n}\r\ncase DECODE_TYPE_SIMULATE: {\r\nstruct decode_simulate *d = (struct decode_simulate *)h;\r\nasi->insn_handler = d->handler.handler;\r\nreturn INSN_GOOD_NO_SLOT;\r\n}\r\ncase DECODE_TYPE_EMULATE: {\r\nstruct decode_emulate *d = (struct decode_emulate *)h;\r\nasi->insn_handler = d->handler.handler;\r\nset_emulated_insn(insn, asi, thumb);\r\nreturn INSN_GOOD;\r\n}\r\ncase DECODE_TYPE_OR:\r\nmatched = true;\r\nbreak;\r\ncase DECODE_TYPE_REJECT:\r\ndefault:\r\nreturn INSN_REJECTED;\r\n}\r\n}\r\n}
