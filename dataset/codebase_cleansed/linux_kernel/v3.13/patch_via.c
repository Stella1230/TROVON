static struct via_spec *via_new_spec(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nspec = kzalloc(sizeof(*spec), GFP_KERNEL);\r\nif (spec == NULL)\r\nreturn NULL;\r\ncodec->spec = spec;\r\nsnd_hda_gen_spec_init(&spec->gen);\r\nspec->codec_type = get_codec_type(codec);\r\nif (spec->codec_type == VT1708BCE)\r\nspec->codec_type = VT1708S;\r\nspec->no_pin_power_ctl = 1;\r\nspec->gen.indep_hp = 1;\r\nspec->gen.keep_eapd_on = 1;\r\nspec->gen.pcm_playback_hook = via_playback_pcm_hook;\r\nreturn spec;\r\n}\r\nstatic enum VIA_HDA_CODEC get_codec_type(struct hda_codec *codec)\r\n{\r\nu32 vendor_id = codec->vendor_id;\r\nu16 ven_id = vendor_id >> 16;\r\nu16 dev_id = vendor_id & 0xffff;\r\nenum VIA_HDA_CODEC codec_type;\r\nif (ven_id != 0x1106)\r\ncodec_type = UNKNOWN;\r\nelse if (dev_id >= 0x1708 && dev_id <= 0x170b)\r\ncodec_type = VT1708;\r\nelse if (dev_id >= 0xe710 && dev_id <= 0xe713)\r\ncodec_type = VT1709_10CH;\r\nelse if (dev_id >= 0xe714 && dev_id <= 0xe717)\r\ncodec_type = VT1709_6CH;\r\nelse if (dev_id >= 0xe720 && dev_id <= 0xe723) {\r\ncodec_type = VT1708B_8CH;\r\nif (snd_hda_param_read(codec, 0x16, AC_PAR_CONNLIST_LEN) == 0x7)\r\ncodec_type = VT1708BCE;\r\n} else if (dev_id >= 0xe724 && dev_id <= 0xe727)\r\ncodec_type = VT1708B_4CH;\r\nelse if ((dev_id & 0xfff) == 0x397\r\n&& (dev_id >> 12) < 8)\r\ncodec_type = VT1708S;\r\nelse if ((dev_id & 0xfff) == 0x398\r\n&& (dev_id >> 12) < 8)\r\ncodec_type = VT1702;\r\nelse if ((dev_id & 0xfff) == 0x428\r\n&& (dev_id >> 12) < 8)\r\ncodec_type = VT1718S;\r\nelse if (dev_id == 0x0433 || dev_id == 0xa721)\r\ncodec_type = VT1716S;\r\nelse if (dev_id == 0x0441 || dev_id == 0x4441)\r\ncodec_type = VT1718S;\r\nelse if (dev_id == 0x0438 || dev_id == 0x4438)\r\ncodec_type = VT2002P;\r\nelse if (dev_id == 0x0448)\r\ncodec_type = VT1812;\r\nelse if (dev_id == 0x0440)\r\ncodec_type = VT1708S;\r\nelse if ((dev_id & 0xfff) == 0x446)\r\ncodec_type = VT1802;\r\nelse if (dev_id == 0x4760)\r\ncodec_type = VT1705CF;\r\nelse if (dev_id == 0x4761 || dev_id == 0x4762)\r\ncodec_type = VT1808;\r\nelse\r\ncodec_type = UNKNOWN;\r\nreturn codec_type;\r\n}\r\nstatic void vt1708_stop_hp_work(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nif (spec->codec_type != VT1708 || !spec->gen.autocfg.hp_outs)\r\nreturn;\r\nif (spec->hp_work_active) {\r\nsnd_hda_codec_write(codec, 0x1, 0, 0xf81, 1);\r\ncodec->jackpoll_interval = 0;\r\ncancel_delayed_work_sync(&codec->jackpoll_work);\r\nspec->hp_work_active = false;\r\n}\r\n}\r\nstatic void vt1708_update_hp_work(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nif (spec->codec_type != VT1708 || !spec->gen.autocfg.hp_outs)\r\nreturn;\r\nif (spec->vt1708_jack_detect) {\r\nif (!spec->hp_work_active) {\r\ncodec->jackpoll_interval = msecs_to_jiffies(100);\r\nsnd_hda_codec_write(codec, 0x1, 0, 0xf81, 0);\r\nqueue_delayed_work(codec->bus->workq,\r\n&codec->jackpoll_work, 0);\r\nspec->hp_work_active = true;\r\n}\r\n} else if (!hp_detect_with_aa(codec))\r\nvt1708_stop_hp_work(codec);\r\n}\r\nstatic void set_widgets_power_state(struct hda_codec *codec)\r\n{\r\n#if 0\r\nstruct via_spec *spec = codec->spec;\r\nif (spec->set_widgets_power_state)\r\nspec->set_widgets_power_state(codec);\r\n#endif\r\n}\r\nstatic void update_power_state(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int parm)\r\n{\r\nif (snd_hda_check_power_state(codec, nid, parm))\r\nreturn;\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE, parm);\r\n}\r\nstatic void update_conv_power_state(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int parm, unsigned int index)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nunsigned int format;\r\nif (snd_hda_check_power_state(codec, nid, parm))\r\nreturn;\r\nformat = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\r\nif (format && (spec->dac_stream_tag[index] != format))\r\nspec->dac_stream_tag[index] = format;\r\nsnd_hda_codec_write(codec, nid, 0, AC_VERB_SET_POWER_STATE, parm);\r\nif (parm == AC_PWRST_D0) {\r\nformat = snd_hda_codec_read(codec, nid, 0, AC_VERB_GET_CONV, 0);\r\nif (!format && (spec->dac_stream_tag[index] != format))\r\nsnd_hda_codec_write(codec, nid, 0,\r\nAC_VERB_SET_CHANNEL_STREAMID,\r\nspec->dac_stream_tag[index]);\r\n}\r\n}\r\nstatic bool smart51_enabled(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nreturn spec->gen.ext_channel_count > 2;\r\n}\r\nstatic bool is_smart51_pins(struct hda_codec *codec, hda_nid_t pin)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->gen.multi_ios; i++)\r\nif (spec->gen.multi_io[i].pin == pin)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void set_pin_power_state(struct hda_codec *codec, hda_nid_t nid,\r\nunsigned int *affected_parm)\r\n{\r\nunsigned parm;\r\nunsigned def_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nunsigned no_presence = (def_conf & AC_DEFCFG_MISC)\r\n>> AC_DEFCFG_MISC_SHIFT\r\n& AC_DEFCFG_MISC_NO_PRESENCE;\r\nstruct via_spec *spec = codec->spec;\r\nunsigned present = 0;\r\nno_presence |= spec->no_pin_power_ctl;\r\nif (!no_presence)\r\npresent = snd_hda_jack_detect(codec, nid);\r\nif ((smart51_enabled(codec) && is_smart51_pins(codec, nid))\r\n|| ((no_presence || present)\r\n&& get_defcfg_connect(def_conf) != AC_JACK_PORT_NONE)) {\r\n*affected_parm = AC_PWRST_D0;\r\nparm = AC_PWRST_D0;\r\n} else\r\nparm = AC_PWRST_D3;\r\nupdate_power_state(codec, nid, parm);\r\n}\r\nstatic int via_pin_power_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nreturn snd_hda_enum_bool_helper_info(kcontrol, uinfo);\r\n}\r\nstatic int via_pin_power_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct via_spec *spec = codec->spec;\r\nucontrol->value.enumerated.item[0] = !spec->no_pin_power_ctl;\r\nreturn 0;\r\n}\r\nstatic int via_pin_power_ctl_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct via_spec *spec = codec->spec;\r\nunsigned int val = !ucontrol->value.enumerated.item[0];\r\nif (val == spec->no_pin_power_ctl)\r\nreturn 0;\r\nspec->no_pin_power_ctl = val;\r\nset_widgets_power_state(codec);\r\nanalog_low_current_mode(codec);\r\nreturn 1;\r\n}\r\nstatic bool is_aa_path_mute(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nconst struct hda_amp_list *p;\r\nint ch, v;\r\np = spec->gen.loopback.amplist;\r\nif (!p)\r\nreturn true;\r\nfor (; p->nid; p++) {\r\nfor (ch = 0; ch < 2; ch++) {\r\nv = snd_hda_codec_amp_read(codec, p->nid, ch, p->dir,\r\np->idx);\r\nif (!(v & HDA_AMP_MUTE) && v > 0)\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void __analog_low_current_mode(struct hda_codec *codec, bool force)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nbool enable;\r\nunsigned int verb, parm;\r\nif (spec->no_pin_power_ctl)\r\nenable = false;\r\nelse\r\nenable = is_aa_path_mute(codec) && !spec->gen.active_streams;\r\nif (enable == spec->alc_mode && !force)\r\nreturn;\r\nspec->alc_mode = enable;\r\nswitch (spec->codec_type) {\r\ncase VT1708B_8CH:\r\ncase VT1708B_4CH:\r\nverb = 0xf70;\r\nparm = enable ? 0x02 : 0x00;\r\nbreak;\r\ncase VT1708S:\r\ncase VT1718S:\r\ncase VT1716S:\r\nverb = 0xf73;\r\nparm = enable ? 0x51 : 0xe1;\r\nbreak;\r\ncase VT1702:\r\nverb = 0xf73;\r\nparm = enable ? 0x01 : 0x1d;\r\nbreak;\r\ncase VT2002P:\r\ncase VT1812:\r\ncase VT1802:\r\nverb = 0xf93;\r\nparm = enable ? 0x00 : 0xe0;\r\nbreak;\r\ncase VT1705CF:\r\ncase VT1808:\r\nverb = 0xf82;\r\nparm = enable ? 0x00 : 0xe0;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nsnd_hda_codec_write(codec, codec->afg, 0, verb, parm);\r\n}\r\nstatic void analog_low_current_mode(struct hda_codec *codec)\r\n{\r\nreturn __analog_low_current_mode(codec, false);\r\n}\r\nstatic int via_build_controls(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint err, i;\r\nerr = snd_hda_gen_build_controls(codec);\r\nif (err < 0)\r\nreturn err;\r\nif (spec->set_widgets_power_state)\r\nspec->mixers[spec->num_mixers++] = via_pin_power_ctl_enum;\r\nfor (i = 0; i < spec->num_mixers; i++) {\r\nerr = snd_hda_add_new_ctls(codec, spec->mixers[i]);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void via_playback_pcm_hook(struct hda_pcm_stream *hinfo,\r\nstruct hda_codec *codec,\r\nstruct snd_pcm_substream *substream,\r\nint action)\r\n{\r\nanalog_low_current_mode(codec);\r\nvt1708_update_hp_work(codec);\r\n}\r\nstatic void via_free(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nif (!spec)\r\nreturn;\r\nvt1708_stop_hp_work(codec);\r\nsnd_hda_gen_spec_free(&spec->gen);\r\nkfree(spec);\r\n}\r\nstatic int via_suspend(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nvt1708_stop_hp_work(codec);\r\nif (spec->codec_type == VT1802)\r\nsnd_hda_shutup_pins(codec);\r\nreturn 0;\r\n}\r\nstatic int via_check_power_status(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nset_widgets_power_state(codec);\r\nanalog_low_current_mode(codec);\r\nvt1708_update_hp_work(codec);\r\nreturn snd_hda_check_amp_list_power(codec, &spec->gen.loopback, nid);\r\n}\r\nstatic void vt1708_set_pinconfig_connect(struct hda_codec *codec, hda_nid_t nid)\r\n{\r\nunsigned int def_conf;\r\nunsigned char seqassoc;\r\ndef_conf = snd_hda_codec_get_pincfg(codec, nid);\r\nseqassoc = (unsigned char) get_defcfg_association(def_conf);\r\nseqassoc = (seqassoc << 4) | get_defcfg_sequence(def_conf);\r\nif (get_defcfg_connect(def_conf) == AC_JACK_PORT_NONE\r\n&& (seqassoc == 0xf0 || seqassoc == 0xff)) {\r\ndef_conf = def_conf & (~(AC_JACK_PORT_BOTH << 30));\r\nsnd_hda_codec_set_pincfg(codec, nid, def_conf);\r\n}\r\nreturn;\r\n}\r\nstatic int vt1708_jack_detect_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct via_spec *spec = codec->spec;\r\nif (spec->codec_type != VT1708)\r\nreturn 0;\r\nucontrol->value.integer.value[0] = spec->vt1708_jack_detect;\r\nreturn 0;\r\n}\r\nstatic int vt1708_jack_detect_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct via_spec *spec = codec->spec;\r\nint val;\r\nif (spec->codec_type != VT1708)\r\nreturn 0;\r\nval = !!ucontrol->value.integer.value[0];\r\nif (spec->vt1708_jack_detect == val)\r\nreturn 0;\r\nspec->vt1708_jack_detect = val;\r\nvt1708_update_hp_work(codec);\r\nreturn 1;\r\n}\r\nstatic void via_hp_automute(struct hda_codec *codec, struct hda_jack_tbl *tbl)\r\n{\r\nset_widgets_power_state(codec);\r\nsnd_hda_gen_hp_automute(codec, tbl);\r\n}\r\nstatic void via_line_automute(struct hda_codec *codec, struct hda_jack_tbl *tbl)\r\n{\r\nset_widgets_power_state(codec);\r\nsnd_hda_gen_line_automute(codec, tbl);\r\n}\r\nstatic void via_jack_powerstate_event(struct hda_codec *codec, struct hda_jack_tbl *tbl)\r\n{\r\nset_widgets_power_state(codec);\r\n}\r\nstatic void via_set_jack_unsol_events(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nstruct auto_pin_cfg *cfg = &spec->gen.autocfg;\r\nhda_nid_t pin;\r\nint i;\r\nspec->gen.hp_automute_hook = via_hp_automute;\r\nif (cfg->speaker_pins[0])\r\nspec->gen.line_automute_hook = via_line_automute;\r\nfor (i = 0; i < cfg->line_outs; i++) {\r\npin = cfg->line_out_pins[i];\r\nif (pin && !snd_hda_jack_tbl_get(codec, pin) &&\r\nis_jack_detectable(codec, pin))\r\nsnd_hda_jack_detect_enable_callback(codec, pin,\r\nVIA_JACK_EVENT,\r\nvia_jack_powerstate_event);\r\n}\r\nfor (i = 0; i < cfg->num_inputs; i++) {\r\npin = cfg->line_out_pins[i];\r\nif (pin && !snd_hda_jack_tbl_get(codec, pin) &&\r\nis_jack_detectable(codec, pin))\r\nsnd_hda_jack_detect_enable_callback(codec, pin,\r\nVIA_JACK_EVENT,\r\nvia_jack_powerstate_event);\r\n}\r\n}\r\nstatic int via_parse_auto_config(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint err;\r\nspec->gen.main_out_badness = &via_main_out_badness;\r\nspec->gen.extra_out_badness = &via_extra_out_badness;\r\nerr = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, NULL, 0);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);\r\nif (err < 0)\r\nreturn err;\r\nvia_set_jack_unsol_events(codec);\r\nreturn 0;\r\n}\r\nstatic int via_init(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint i;\r\nfor (i = 0; i < spec->num_iverbs; i++)\r\nsnd_hda_sequence_write(codec, spec->init_verbs[i]);\r\nset_widgets_power_state(codec);\r\n__analog_low_current_mode(codec, true);\r\nsnd_hda_gen_init(codec);\r\nvt1708_update_hp_work(codec);\r\nreturn 0;\r\n}\r\nstatic int vt1708_build_controls(struct hda_codec *codec)\r\n{\r\nint err;\r\nint old_interval = codec->jackpoll_interval;\r\ncodec->jackpoll_interval = msecs_to_jiffies(100);\r\nerr = via_build_controls(codec);\r\ncodec->jackpoll_interval = old_interval;\r\nreturn err;\r\n}\r\nstatic int vt1708_build_pcms(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint i, err;\r\nerr = snd_hda_gen_build_pcms(codec);\r\nif (err < 0 || codec->vendor_id != 0x11061708)\r\nreturn err;\r\nfor (i = 0; i < codec->num_pcms; i++) {\r\nstruct hda_pcm *info = &spec->gen.pcm_rec[i];\r\nif (!info->stream[SNDRV_PCM_STREAM_PLAYBACK].substreams ||\r\ninfo->pcm_type != HDA_PCM_TYPE_AUDIO)\r\ncontinue;\r\ninfo->stream[SNDRV_PCM_STREAM_PLAYBACK].formats =\r\nSNDRV_PCM_FMTBIT_S16_LE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_vt1708(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x17;\r\ncodec->jackpoll_interval = msecs_to_jiffies(100);\r\nspec->vt1708_jack_detect = 1;\r\nspec->gen.suppress_auto_mic = 1;\r\nspec->gen.auto_mute_via_amp = 1;\r\nvt1708_set_pinconfig_connect(codec, VT1708_HP_PIN_NID);\r\nvt1708_set_pinconfig_connect(codec, VT1708_CD_PIN_NID);\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->mixers[spec->num_mixers++] = vt1708_jack_detect_ctl;\r\nspec->init_verbs[spec->num_iverbs++] = vt1708_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\ncodec->patch_ops.build_controls = vt1708_build_controls;\r\ncodec->patch_ops.build_pcms = vt1708_build_pcms;\r\ncodec->jackpoll_interval = 0;\r\nreturn 0;\r\n}\r\nstatic int patch_vt1709(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x18;\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\ncodec->patch_ops = via_patch_ops;\r\nreturn 0;\r\n}\r\nstatic void set_widgets_power_state_vt1708B(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint imux_is_smixer;\r\nunsigned int parm;\r\nint is_8ch = 0;\r\nif ((spec->codec_type != VT1708B_4CH) &&\r\n(codec->vendor_id != 0x11064397))\r\nis_8ch = 1;\r\nimux_is_smixer =\r\n(snd_hda_codec_read(codec, 0x17, 0, AC_VERB_GET_CONNECT_SEL, 0x00)\r\n== ((spec->codec_type == VT1708S) ? 5 : 0));\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x1a, &parm);\r\nset_pin_power_state(codec, 0x1b, &parm);\r\nset_pin_power_state(codec, 0x1e, &parm);\r\nif (imux_is_smixer)\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x17, parm);\r\nupdate_power_state(codec, 0x13, parm);\r\nupdate_power_state(codec, 0x14, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x19, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x1b, &parm);\r\nupdate_power_state(codec, 0x18, parm);\r\nupdate_power_state(codec, 0x11, parm);\r\nif (is_8ch) {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x22, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x1a, &parm);\r\nupdate_power_state(codec, 0x26, parm);\r\nupdate_power_state(codec, 0x24, parm);\r\n} else if (codec->vendor_id == 0x11064397) {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x23, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x1a, &parm);\r\nupdate_power_state(codec, 0x27, parm);\r\nupdate_power_state(codec, 0x25, parm);\r\n}\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x1c, &parm);\r\nset_pin_power_state(codec, 0x1d, &parm);\r\nif (is_8ch)\r\nset_pin_power_state(codec, 0x23, &parm);\r\nupdate_power_state(codec, 0x16, imux_is_smixer ? AC_PWRST_D0 : parm);\r\nupdate_power_state(codec, 0x10, parm);\r\nif (is_8ch) {\r\nupdate_power_state(codec, 0x25, parm);\r\nupdate_power_state(codec, 0x27, parm);\r\n} else if (codec->vendor_id == 0x11064397 && spec->gen.indep_hp_enabled)\r\nupdate_power_state(codec, 0x25, parm);\r\n}\r\nstatic int patch_vt1708B(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nif (get_codec_type(codec) == VT1708BCE)\r\nreturn patch_vt1708S(codec);\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x16;\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt1708B;\r\nreturn 0;\r\n}\r\nstatic void override_mic_boost(struct hda_codec *codec, hda_nid_t pin,\r\nint offset, int num_steps, int step_size)\r\n{\r\nsnd_hda_override_wcaps(codec, pin,\r\nget_wcaps(codec, pin) | AC_WCAP_IN_AMP);\r\nsnd_hda_override_amp_caps(codec, pin, HDA_INPUT,\r\n(offset << AC_AMPCAP_OFFSET_SHIFT) |\r\n(num_steps << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(step_size << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(0 << AC_AMPCAP_MUTE_SHIFT));\r\n}\r\nstatic int patch_vt1708S(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x16;\r\noverride_mic_boost(codec, 0x1a, 0, 3, 40);\r\noverride_mic_boost(codec, 0x1e, 0, 3, 40);\r\nif (get_codec_type(codec) == VT1708BCE) {\r\nkfree(codec->chip_name);\r\ncodec->chip_name = kstrdup("VT1708BCE", GFP_KERNEL);\r\nsnprintf(codec->bus->card->mixername,\r\nsizeof(codec->bus->card->mixername),\r\n"%s %s", codec->vendor_name, codec->chip_name);\r\n}\r\nif (codec->vendor_id == 0x11064397) {\r\nkfree(codec->chip_name);\r\ncodec->chip_name = kstrdup("VT1705", GFP_KERNEL);\r\nsnprintf(codec->bus->card->mixername,\r\nsizeof(codec->bus->card->mixername),\r\n"%s %s", codec->vendor_name, codec->chip_name);\r\n}\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->init_verbs[spec->num_iverbs++] = vt1708S_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt1708B;\r\nreturn 0;\r\n}\r\nstatic void set_widgets_power_state_vt1702(struct hda_codec *codec)\r\n{\r\nint imux_is_smixer =\r\nsnd_hda_codec_read(codec, 0x13, 0, AC_VERB_GET_CONNECT_SEL, 0x00) == 3;\r\nunsigned int parm;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x14, &parm);\r\nset_pin_power_state(codec, 0x15, &parm);\r\nset_pin_power_state(codec, 0x18, &parm);\r\nif (imux_is_smixer)\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x13, parm);\r\nupdate_power_state(codec, 0x12, parm);\r\nupdate_power_state(codec, 0x1f, parm);\r\nupdate_power_state(codec, 0x20, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x17, &parm);\r\nset_pin_power_state(codec, 0x16, &parm);\r\nupdate_power_state(codec, 0x1a, imux_is_smixer ? AC_PWRST_D0 : parm);\r\nupdate_power_state(codec, 0x10, parm);\r\nupdate_power_state(codec, 0x1d, parm);\r\n}\r\nstatic int patch_vt1702(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x1a;\r\nsnd_hda_override_amp_caps(codec, 0x1A, HDA_INPUT,\r\n(0x17 << AC_AMPCAP_OFFSET_SHIFT) |\r\n(0x17 << AC_AMPCAP_NUM_STEPS_SHIFT) |\r\n(0x5 << AC_AMPCAP_STEP_SIZE_SHIFT) |\r\n(1 << AC_AMPCAP_MUTE_SHIFT));\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->init_verbs[spec->num_iverbs++] = vt1702_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt1702;\r\nreturn 0;\r\n}\r\nstatic void set_widgets_power_state_vt1718S(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint imux_is_smixer;\r\nunsigned int parm, parm2;\r\nimux_is_smixer =\r\nsnd_hda_codec_read(codec, 0x1e, 0, AC_VERB_GET_CONNECT_SEL, 0x00) == 5;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x29, &parm);\r\nset_pin_power_state(codec, 0x2a, &parm);\r\nset_pin_power_state(codec, 0x2b, &parm);\r\nif (imux_is_smixer)\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x1e, parm);\r\nupdate_power_state(codec, 0x1f, parm);\r\nupdate_power_state(codec, 0x10, parm);\r\nupdate_power_state(codec, 0x11, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x27, &parm);\r\nupdate_power_state(codec, 0x1a, parm);\r\nparm2 = parm;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x26, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x2b, &parm);\r\nupdate_power_state(codec, 0xa, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x24, &parm);\r\nif (!spec->gen.indep_hp_enabled)\r\nset_pin_power_state(codec, 0x28, &parm);\r\nupdate_power_state(codec, 0x8, parm);\r\nif (!spec->gen.indep_hp_enabled && parm2 != AC_PWRST_D3)\r\nparm = parm2;\r\nupdate_power_state(codec, 0xb, parm);\r\nupdate_power_state(codec, 0x21, imux_is_smixer ? AC_PWRST_D0 : parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x25, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x2a, &parm);\r\nupdate_power_state(codec, 0x9, parm);\r\nif (spec->gen.indep_hp_enabled) {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x28, &parm);\r\nupdate_power_state(codec, 0x1b, parm);\r\nupdate_power_state(codec, 0x34, parm);\r\nupdate_power_state(codec, 0xc, parm);\r\n}\r\n}\r\nstatic int add_secret_dac_path(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint i, nums;\r\nhda_nid_t conn[8];\r\nhda_nid_t nid;\r\nif (!spec->gen.mixer_nid)\r\nreturn 0;\r\nnums = snd_hda_get_connections(codec, spec->gen.mixer_nid, conn,\r\nARRAY_SIZE(conn) - 1);\r\nfor (i = 0; i < nums; i++) {\r\nif (get_wcaps_type(get_wcaps(codec, conn[i])) == AC_WID_AUD_OUT)\r\nreturn 0;\r\n}\r\nnid = codec->start_nid;\r\nfor (i = 0; i < codec->num_nodes; i++, nid++) {\r\nunsigned int caps = get_wcaps(codec, nid);\r\nif (get_wcaps_type(caps) == AC_WID_AUD_OUT &&\r\n!(caps & AC_WCAP_DIGITAL)) {\r\nconn[nums++] = nid;\r\nreturn snd_hda_override_conn_list(codec,\r\nspec->gen.mixer_nid,\r\nnums, conn);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int patch_vt1718S(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x21;\r\noverride_mic_boost(codec, 0x2b, 0, 3, 40);\r\noverride_mic_boost(codec, 0x29, 0, 3, 40);\r\nadd_secret_dac_path(codec);\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->init_verbs[spec->num_iverbs++] = vt1718S_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt1718S;\r\nreturn 0;\r\n}\r\nstatic int vt1716s_dmic_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 0;\r\nuinfo->value.integer.max = 1;\r\nreturn 0;\r\n}\r\nstatic int vt1716s_dmic_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nint index = 0;\r\nindex = snd_hda_codec_read(codec, 0x26, 0,\r\nAC_VERB_GET_CONNECT_SEL, 0);\r\nif (index != -1)\r\n*ucontrol->value.integer.value = index;\r\nreturn 0;\r\n}\r\nstatic int vt1716s_dmic_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct hda_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct via_spec *spec = codec->spec;\r\nint index = *ucontrol->value.integer.value;\r\nsnd_hda_codec_write(codec, 0x26, 0,\r\nAC_VERB_SET_CONNECT_SEL, index);\r\nspec->dmic_enabled = index;\r\nset_widgets_power_state(codec);\r\nreturn 1;\r\n}\r\nstatic void set_widgets_power_state_vt1716S(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint imux_is_smixer;\r\nunsigned int parm;\r\nunsigned int mono_out, present;\r\nimux_is_smixer =\r\n(snd_hda_codec_read(codec, 0x17, 0,\r\nAC_VERB_GET_CONNECT_SEL, 0x00) == 5);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x1a, &parm);\r\nset_pin_power_state(codec, 0x1b, &parm);\r\nset_pin_power_state(codec, 0x1e, &parm);\r\nif (imux_is_smixer)\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x17, parm);\r\nupdate_power_state(codec, 0x13, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x1e, &parm);\r\nif (spec->dmic_enabled)\r\nset_pin_power_state(codec, 0x22, &parm);\r\nelse\r\nupdate_power_state(codec, 0x22, AC_PWRST_D3);\r\nupdate_power_state(codec, 0x26, parm);\r\nupdate_power_state(codec, 0x14, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x19, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x1b, &parm);\r\nupdate_power_state(codec, 0x18, parm);\r\nupdate_power_state(codec, 0x11, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x23, &parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x1a, &parm);\r\nupdate_power_state(codec, 0x27, parm);\r\nif (smart51_enabled(codec))\r\nset_pin_power_state(codec, 0x1e, &parm);\r\nupdate_power_state(codec, 0x25, parm);\r\npresent = snd_hda_jack_detect(codec, 0x1c);\r\nif (present)\r\nmono_out = 0;\r\nelse {\r\npresent = snd_hda_jack_detect(codec, 0x1d);\r\nif (!spec->gen.indep_hp_enabled && present)\r\nmono_out = 0;\r\nelse\r\nmono_out = 1;\r\n}\r\nparm = mono_out ? AC_PWRST_D0 : AC_PWRST_D3;\r\nupdate_power_state(codec, 0x28, parm);\r\nupdate_power_state(codec, 0x29, parm);\r\nupdate_power_state(codec, 0x2a, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x1c, &parm);\r\nset_pin_power_state(codec, 0x1d, &parm);\r\nif (spec->gen.indep_hp_enabled)\r\nupdate_power_state(codec, 0x25, parm);\r\nupdate_power_state(codec, 0x16, imux_is_smixer ? AC_PWRST_D0 : parm);\r\nupdate_power_state(codec, 0x10, mono_out ? AC_PWRST_D0 : parm);\r\n}\r\nstatic int patch_vt1716S(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x16;\r\noverride_mic_boost(codec, 0x1a, 0, 3, 40);\r\noverride_mic_boost(codec, 0x1e, 0, 3, 40);\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->init_verbs[spec->num_iverbs++] = vt1716S_init_verbs;\r\nspec->mixers[spec->num_mixers++] = vt1716s_dmic_mixer;\r\nspec->mixers[spec->num_mixers++] = vt1716S_mono_out_mixer;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt1716S;\r\nreturn 0;\r\n}\r\nstatic void set_widgets_power_state_vt2002P(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint imux_is_smixer;\r\nunsigned int parm;\r\nunsigned int present;\r\nimux_is_smixer =\r\nsnd_hda_codec_read(codec, 0x1e, 0, AC_VERB_GET_CONNECT_SEL, 0x00) == 3;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x29, &parm);\r\nset_pin_power_state(codec, 0x2a, &parm);\r\nset_pin_power_state(codec, 0x2b, &parm);\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x1e, parm);\r\nupdate_power_state(codec, 0x1f, parm);\r\nupdate_power_state(codec, 0x10, parm);\r\nupdate_power_state(codec, 0x11, parm);\r\nupdate_power_state(codec, 0x8, parm);\r\nif (spec->codec_type == VT1802) {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x28, &parm);\r\nupdate_power_state(codec, 0x18, parm);\r\nupdate_power_state(codec, 0x38, parm);\r\n} else {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x26, &parm);\r\nupdate_power_state(codec, 0x1c, parm);\r\nupdate_power_state(codec, 0x37, parm);\r\n}\r\nif (spec->codec_type == VT1802) {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x25, &parm);\r\nupdate_power_state(codec, 0x15, parm);\r\nupdate_power_state(codec, 0x35, parm);\r\n} else {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x25, &parm);\r\nupdate_power_state(codec, 0x19, parm);\r\nupdate_power_state(codec, 0x35, parm);\r\n}\r\nif (spec->gen.indep_hp_enabled)\r\nupdate_power_state(codec, 0x9, AC_PWRST_D0);\r\npresent = snd_hda_jack_detect(codec, 0x25);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x24, &parm);\r\nparm = present ? AC_PWRST_D3 : AC_PWRST_D0;\r\nif (spec->codec_type == VT1802)\r\nupdate_power_state(codec, 0x14, parm);\r\nelse\r\nupdate_power_state(codec, 0x18, parm);\r\nupdate_power_state(codec, 0x34, parm);\r\npresent = snd_hda_jack_detect(codec, 0x26);\r\nparm = present ? AC_PWRST_D3 : AC_PWRST_D0;\r\nif (spec->codec_type == VT1802) {\r\nupdate_power_state(codec, 0x33, parm);\r\nupdate_power_state(codec, 0x1c, parm);\r\nupdate_power_state(codec, 0x3c, parm);\r\n} else {\r\nupdate_power_state(codec, 0x31, parm);\r\nupdate_power_state(codec, 0x17, parm);\r\nupdate_power_state(codec, 0x3b, parm);\r\n}\r\nif (imux_is_smixer || !is_aa_path_mute(codec))\r\nupdate_power_state(codec, 0x21, AC_PWRST_D0);\r\nelse\r\nupdate_power_state(codec, 0x21, AC_PWRST_D3);\r\n}\r\nstatic void via_fixup_intmic_boost(struct hda_codec *codec,\r\nconst struct hda_fixup *fix, int action)\r\n{\r\nif (action == HDA_FIXUP_ACT_PRE_PROBE)\r\noverride_mic_boost(codec, 0x30, 0, 2, 40);\r\n}\r\nstatic void fix_vt1802_connections(struct hda_codec *codec)\r\n{\r\nstatic hda_nid_t conn_24[] = { 0x14, 0x1c };\r\nstatic hda_nid_t conn_33[] = { 0x1c };\r\nsnd_hda_override_conn_list(codec, 0x24, ARRAY_SIZE(conn_24), conn_24);\r\nsnd_hda_override_conn_list(codec, 0x33, ARRAY_SIZE(conn_33), conn_33);\r\n}\r\nstatic int patch_vt2002P(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x21;\r\noverride_mic_boost(codec, 0x2b, 0, 3, 40);\r\noverride_mic_boost(codec, 0x29, 0, 3, 40);\r\nif (spec->codec_type == VT1802)\r\nfix_vt1802_connections(codec);\r\nadd_secret_dac_path(codec);\r\nsnd_hda_pick_fixup(codec, NULL, vt2002p_fixups, via_fixups);\r\nsnd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nif (spec->codec_type == VT1802)\r\nspec->init_verbs[spec->num_iverbs++] = vt1802_init_verbs;\r\nelse\r\nspec->init_verbs[spec->num_iverbs++] = vt2002P_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt2002P;\r\nreturn 0;\r\n}\r\nstatic void set_widgets_power_state_vt1812(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nunsigned int parm;\r\nunsigned int present;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x29, &parm);\r\nset_pin_power_state(codec, 0x2a, &parm);\r\nset_pin_power_state(codec, 0x2b, &parm);\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x1e, parm);\r\nupdate_power_state(codec, 0x1f, parm);\r\nupdate_power_state(codec, 0x10, parm);\r\nupdate_power_state(codec, 0x11, parm);\r\nupdate_power_state(codec, 0x8, AC_PWRST_D0);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x28, &parm);\r\nupdate_power_state(codec, 0x18, parm);\r\nupdate_power_state(codec, 0x38, parm);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x25, &parm);\r\nupdate_power_state(codec, 0x15, parm);\r\nupdate_power_state(codec, 0x35, parm);\r\nif (spec->gen.indep_hp_enabled)\r\nupdate_power_state(codec, 0x9, AC_PWRST_D0);\r\npresent = snd_hda_jack_detect(codec, 0x25);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x24, &parm);\r\nif (present) {\r\nupdate_power_state(codec, 0x14, AC_PWRST_D3);\r\nupdate_power_state(codec, 0x34, AC_PWRST_D3);\r\n} else {\r\nupdate_power_state(codec, 0x14, AC_PWRST_D0);\r\nupdate_power_state(codec, 0x34, AC_PWRST_D0);\r\n}\r\npresent = snd_hda_jack_detect(codec, 0x28);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x31, &parm);\r\nif (present) {\r\nupdate_power_state(codec, 0x1c, AC_PWRST_D3);\r\nupdate_power_state(codec, 0x3c, AC_PWRST_D3);\r\nupdate_power_state(codec, 0x3e, AC_PWRST_D3);\r\n} else {\r\nupdate_power_state(codec, 0x1c, AC_PWRST_D0);\r\nupdate_power_state(codec, 0x3c, AC_PWRST_D0);\r\nupdate_power_state(codec, 0x3e, AC_PWRST_D0);\r\n}\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x33, &parm);\r\nupdate_power_state(codec, 0x1d, parm);\r\nupdate_power_state(codec, 0x3d, parm);\r\n}\r\nstatic int patch_vt1812(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x21;\r\noverride_mic_boost(codec, 0x2b, 0, 3, 40);\r\noverride_mic_boost(codec, 0x29, 0, 3, 40);\r\nadd_secret_dac_path(codec);\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->init_verbs[spec->num_iverbs++] = vt1812_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt1812;\r\nreturn 0;\r\n}\r\nstatic void set_widgets_power_state_vt3476(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec = codec->spec;\r\nint imux_is_smixer;\r\nunsigned int parm, parm2;\r\nimux_is_smixer =\r\nsnd_hda_codec_read(codec, 0x1e, 0, AC_VERB_GET_CONNECT_SEL, 0x00) == 4;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x29, &parm);\r\nset_pin_power_state(codec, 0x2a, &parm);\r\nset_pin_power_state(codec, 0x2b, &parm);\r\nif (imux_is_smixer)\r\nparm = AC_PWRST_D0;\r\nupdate_power_state(codec, 0x1e, parm);\r\nupdate_power_state(codec, 0x1f, parm);\r\nupdate_power_state(codec, 0x10, parm);\r\nupdate_power_state(codec, 0x11, parm);\r\nif (spec->codec_type == VT1705CF) {\r\nparm = AC_PWRST_D3;\r\nupdate_power_state(codec, 0x27, parm);\r\nupdate_power_state(codec, 0x37, parm);\r\n} else {\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x27, &parm);\r\nupdate_power_state(codec, 0x37, parm);\r\n}\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x26, &parm);\r\nupdate_power_state(codec, 0x36, parm);\r\nif (smart51_enabled(codec)) {\r\nset_pin_power_state(codec, 0x2b, &parm);\r\nupdate_power_state(codec, 0x3b, parm);\r\nupdate_power_state(codec, 0x1b, parm);\r\n}\r\nupdate_conv_power_state(codec, 0xa, parm, 2);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x25, &parm);\r\nupdate_power_state(codec, 0x35, parm);\r\nif (smart51_enabled(codec)) {\r\nset_pin_power_state(codec, 0x2a, &parm);\r\nupdate_power_state(codec, 0x3a, parm);\r\nupdate_power_state(codec, 0x1a, parm);\r\n}\r\nupdate_conv_power_state(codec, 0x9, parm, 1);\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x28, &parm);\r\nupdate_power_state(codec, 0x38, parm);\r\nupdate_power_state(codec, 0x18, parm);\r\nif (spec->gen.indep_hp_enabled)\r\nupdate_conv_power_state(codec, 0xb, parm, 3);\r\nparm2 = parm;\r\nparm = AC_PWRST_D3;\r\nset_pin_power_state(codec, 0x24, &parm);\r\nupdate_power_state(codec, 0x34, parm);\r\nif (!spec->gen.indep_hp_enabled && parm2 != AC_PWRST_D3)\r\nparm = parm2;\r\nupdate_conv_power_state(codec, 0x8, parm, 0);\r\nupdate_power_state(codec, 0x3f, imux_is_smixer ? AC_PWRST_D0 : parm);\r\n}\r\nstatic int patch_vt3476(struct hda_codec *codec)\r\n{\r\nstruct via_spec *spec;\r\nint err;\r\nspec = via_new_spec(codec);\r\nif (spec == NULL)\r\nreturn -ENOMEM;\r\nspec->gen.mixer_nid = 0x3f;\r\nadd_secret_dac_path(codec);\r\nerr = via_parse_auto_config(codec);\r\nif (err < 0) {\r\nvia_free(codec);\r\nreturn err;\r\n}\r\nspec->init_verbs[spec->num_iverbs++] = vt3476_init_verbs;\r\ncodec->patch_ops = via_patch_ops;\r\nspec->set_widgets_power_state = set_widgets_power_state_vt3476;\r\nreturn 0;\r\n}\r\nstatic int __init patch_via_init(void)\r\n{\r\nreturn snd_hda_add_codec_preset(&via_list);\r\n}\r\nstatic void __exit patch_via_exit(void)\r\n{\r\nsnd_hda_delete_codec_preset(&via_list);\r\n}
