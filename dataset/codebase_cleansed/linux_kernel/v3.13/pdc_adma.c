static int adma_check_atapi_dma(struct ata_queued_cmd *qc)\r\n{\r\nreturn 1;\r\n}\r\nstatic void adma_reset_engine(struct ata_port *ap)\r\n{\r\nvoid __iomem *chan = ADMA_PORT_REGS(ap);\r\nwritew(aPIOMD4 | aNIEN | aRSTADM, chan + ADMA_CONTROL);\r\nudelay(2);\r\nwritew(aPIOMD4, chan + ADMA_CONTROL);\r\nudelay(2);\r\n}\r\nstatic void adma_reinit_engine(struct ata_port *ap)\r\n{\r\nstruct adma_port_priv *pp = ap->private_data;\r\nvoid __iomem *chan = ADMA_PORT_REGS(ap);\r\nwriteb(ATA_NIEN, ap->ioaddr.ctl_addr);\r\nata_sff_check_status(ap);\r\nadma_reset_engine(ap);\r\nwritew(0x100, chan + ADMA_FIFO_IN);\r\nwritel((u32)pp->pkt_dma, chan + ADMA_CPB_NEXT);\r\nwritew(0x100, chan + ADMA_FIFO_OUT);\r\nwritew(1, chan + ADMA_CPB_COUNT);\r\nreadb(chan + ADMA_STATUS);\r\n}\r\nstatic inline void adma_enter_reg_mode(struct ata_port *ap)\r\n{\r\nvoid __iomem *chan = ADMA_PORT_REGS(ap);\r\nwritew(aPIOMD4, chan + ADMA_CONTROL);\r\nreadb(chan + ADMA_STATUS);\r\n}\r\nstatic void adma_freeze(struct ata_port *ap)\r\n{\r\nvoid __iomem *chan = ADMA_PORT_REGS(ap);\r\nwriteb(ATA_NIEN, ap->ioaddr.ctl_addr);\r\nata_sff_check_status(ap);\r\nwritew(aPIOMD4 | aNIEN | aRSTADM, chan + ADMA_CONTROL);\r\nudelay(2);\r\nwritew(aPIOMD4 | aNIEN, chan + ADMA_CONTROL);\r\nudelay(2);\r\n}\r\nstatic void adma_thaw(struct ata_port *ap)\r\n{\r\nadma_reinit_engine(ap);\r\n}\r\nstatic int adma_prereset(struct ata_link *link, unsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct adma_port_priv *pp = ap->private_data;\r\nif (pp->state != adma_state_idle)\r\npp->state = adma_state_mmio;\r\nadma_reinit_engine(ap);\r\nreturn ata_sff_prereset(link, deadline);\r\n}\r\nstatic int adma_fill_sg(struct ata_queued_cmd *qc)\r\n{\r\nstruct scatterlist *sg;\r\nstruct ata_port *ap = qc->ap;\r\nstruct adma_port_priv *pp = ap->private_data;\r\nu8 *buf = pp->pkt, *last_buf = NULL;\r\nint i = (2 + buf[3]) * 8;\r\nu8 pFLAGS = pORD | ((qc->tf.flags & ATA_TFLAG_WRITE) ? pDIRO : 0);\r\nunsigned int si;\r\nfor_each_sg(qc->sg, sg, qc->n_elem, si) {\r\nu32 addr;\r\nu32 len;\r\naddr = (u32)sg_dma_address(sg);\r\n*(__le32 *)(buf + i) = cpu_to_le32(addr);\r\ni += 4;\r\nlen = sg_dma_len(sg) >> 3;\r\n*(__le32 *)(buf + i) = cpu_to_le32(len);\r\ni += 4;\r\nlast_buf = &buf[i];\r\nbuf[i++] = pFLAGS;\r\nbuf[i++] = qc->dev->dma_mode & 0xf;\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\n*(__le32 *)(buf + i) =\r\n(pFLAGS & pEND) ? 0 : cpu_to_le32(pp->pkt_dma + i + 4);\r\ni += 4;\r\nVPRINTK("PRD[%u] = (0x%lX, 0x%X)\n", i/4,\r\n(unsigned long)addr, len);\r\n}\r\nif (likely(last_buf))\r\n*last_buf |= pEND;\r\nreturn i;\r\n}\r\nstatic void adma_qc_prep(struct ata_queued_cmd *qc)\r\n{\r\nstruct adma_port_priv *pp = qc->ap->private_data;\r\nu8 *buf = pp->pkt;\r\nu32 pkt_dma = (u32)pp->pkt_dma;\r\nint i = 0;\r\nVPRINTK("ENTER\n");\r\nadma_enter_reg_mode(qc->ap);\r\nif (qc->tf.protocol != ATA_PROT_DMA)\r\nreturn;\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nbuf[i++] = cVLD | cDAT | cIEN;\r\ni++;\r\n*(__le32 *)(buf+i) = cpu_to_le32(pkt_dma);\r\ni += 4;\r\ni += 4;\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nbuf[i++] = 0;\r\nbuf[i++] = qc->tf.device;\r\nbuf[i++] = ADMA_REGS_DEVICE;\r\nif ((qc->tf.flags & ATA_TFLAG_LBA48)) {\r\nbuf[i++] = qc->tf.hob_nsect;\r\nbuf[i++] = ADMA_REGS_SECTOR_COUNT;\r\nbuf[i++] = qc->tf.hob_lbal;\r\nbuf[i++] = ADMA_REGS_LBA_LOW;\r\nbuf[i++] = qc->tf.hob_lbam;\r\nbuf[i++] = ADMA_REGS_LBA_MID;\r\nbuf[i++] = qc->tf.hob_lbah;\r\nbuf[i++] = ADMA_REGS_LBA_HIGH;\r\n}\r\nbuf[i++] = qc->tf.nsect;\r\nbuf[i++] = ADMA_REGS_SECTOR_COUNT;\r\nbuf[i++] = qc->tf.lbal;\r\nbuf[i++] = ADMA_REGS_LBA_LOW;\r\nbuf[i++] = qc->tf.lbam;\r\nbuf[i++] = ADMA_REGS_LBA_MID;\r\nbuf[i++] = qc->tf.lbah;\r\nbuf[i++] = ADMA_REGS_LBA_HIGH;\r\nbuf[i++] = 0;\r\nbuf[i++] = ADMA_REGS_CONTROL;\r\nbuf[i++] = rIGN;\r\nbuf[i++] = 0;\r\nbuf[i++] = qc->tf.command;\r\nbuf[i++] = ADMA_REGS_COMMAND | rEND;\r\nbuf[3] = (i >> 3) - 2;\r\n*(__le32 *)(buf+8) = cpu_to_le32(pkt_dma + i);\r\ni = adma_fill_sg(qc);\r\nwmb();\r\n#if 0\r\n{\r\nint j, len = 0;\r\nstatic char obuf[2048];\r\nfor (j = 0; j < i; ++j) {\r\nlen += sprintf(obuf+len, "%02x ", buf[j]);\r\nif ((j & 7) == 7) {\r\nprintk("%s\n", obuf);\r\nlen = 0;\r\n}\r\n}\r\nif (len)\r\nprintk("%s\n", obuf);\r\n}\r\n#endif\r\n}\r\nstatic inline void adma_packet_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nvoid __iomem *chan = ADMA_PORT_REGS(ap);\r\nVPRINTK("ENTER, ap %p\n", ap);\r\nwritew(aPIOMD4 | aGO, chan + ADMA_CONTROL);\r\n}\r\nstatic unsigned int adma_qc_issue(struct ata_queued_cmd *qc)\r\n{\r\nstruct adma_port_priv *pp = qc->ap->private_data;\r\nswitch (qc->tf.protocol) {\r\ncase ATA_PROT_DMA:\r\npp->state = adma_state_pkt;\r\nadma_packet_start(qc);\r\nreturn 0;\r\ncase ATAPI_PROT_DMA:\r\nBUG();\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npp->state = adma_state_mmio;\r\nreturn ata_sff_qc_issue(qc);\r\n}\r\nstatic inline unsigned int adma_intr_pkt(struct ata_host *host)\r\n{\r\nunsigned int handled = 0, port_no;\r\nfor (port_no = 0; port_no < host->n_ports; ++port_no) {\r\nstruct ata_port *ap = host->ports[port_no];\r\nstruct adma_port_priv *pp;\r\nstruct ata_queued_cmd *qc;\r\nvoid __iomem *chan = ADMA_PORT_REGS(ap);\r\nu8 status = readb(chan + ADMA_STATUS);\r\nif (status == 0)\r\ncontinue;\r\nhandled = 1;\r\nadma_enter_reg_mode(ap);\r\npp = ap->private_data;\r\nif (!pp || pp->state != adma_state_pkt)\r\ncontinue;\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING))) {\r\nif (status & aPERR)\r\nqc->err_mask |= AC_ERR_HOST_BUS;\r\nelse if ((status & (aPSD | aUIRQ)))\r\nqc->err_mask |= AC_ERR_OTHER;\r\nif (pp->pkt[0] & cATERR)\r\nqc->err_mask |= AC_ERR_DEV;\r\nelse if (pp->pkt[0] != cDONE)\r\nqc->err_mask |= AC_ERR_OTHER;\r\nif (!qc->err_mask)\r\nata_qc_complete(qc);\r\nelse {\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nata_ehi_clear_desc(ehi);\r\nata_ehi_push_desc(ehi,\r\n"ADMA-status 0x%02X", status);\r\nata_ehi_push_desc(ehi,\r\n"pkt[0] 0x%02X", pp->pkt[0]);\r\nif (qc->err_mask == AC_ERR_DEV)\r\nata_port_abort(ap);\r\nelse\r\nata_port_freeze(ap);\r\n}\r\n}\r\n}\r\nreturn handled;\r\n}\r\nstatic inline unsigned int adma_intr_mmio(struct ata_host *host)\r\n{\r\nunsigned int handled = 0, port_no;\r\nfor (port_no = 0; port_no < host->n_ports; ++port_no) {\r\nstruct ata_port *ap = host->ports[port_no];\r\nstruct adma_port_priv *pp = ap->private_data;\r\nstruct ata_queued_cmd *qc;\r\nif (!pp || pp->state != adma_state_mmio)\r\ncontinue;\r\nqc = ata_qc_from_tag(ap, ap->link.active_tag);\r\nif (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING))) {\r\nu8 status = ata_sff_check_status(ap);\r\nif ((status & ATA_BUSY))\r\ncontinue;\r\nDPRINTK("ata%u: protocol %d (dev_stat 0x%X)\n",\r\nap->print_id, qc->tf.protocol, status);\r\npp->state = adma_state_idle;\r\nqc->err_mask |= ac_err_mask(status);\r\nif (!qc->err_mask)\r\nata_qc_complete(qc);\r\nelse {\r\nstruct ata_eh_info *ehi = &ap->link.eh_info;\r\nata_ehi_clear_desc(ehi);\r\nata_ehi_push_desc(ehi, "status 0x%02X", status);\r\nif (qc->err_mask == AC_ERR_DEV)\r\nata_port_abort(ap);\r\nelse\r\nata_port_freeze(ap);\r\n}\r\nhandled = 1;\r\n}\r\n}\r\nreturn handled;\r\n}\r\nstatic irqreturn_t adma_intr(int irq, void *dev_instance)\r\n{\r\nstruct ata_host *host = dev_instance;\r\nunsigned int handled = 0;\r\nVPRINTK("ENTER\n");\r\nspin_lock(&host->lock);\r\nhandled = adma_intr_pkt(host) | adma_intr_mmio(host);\r\nspin_unlock(&host->lock);\r\nVPRINTK("EXIT\n");\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void adma_ata_setup_port(struct ata_ioports *port, void __iomem *base)\r\n{\r\nport->cmd_addr =\r\nport->data_addr = base + 0x000;\r\nport->error_addr =\r\nport->feature_addr = base + 0x004;\r\nport->nsect_addr = base + 0x008;\r\nport->lbal_addr = base + 0x00c;\r\nport->lbam_addr = base + 0x010;\r\nport->lbah_addr = base + 0x014;\r\nport->device_addr = base + 0x018;\r\nport->status_addr =\r\nport->command_addr = base + 0x01c;\r\nport->altstatus_addr =\r\nport->ctl_addr = base + 0x038;\r\n}\r\nstatic int adma_port_start(struct ata_port *ap)\r\n{\r\nstruct device *dev = ap->host->dev;\r\nstruct adma_port_priv *pp;\r\nadma_enter_reg_mode(ap);\r\npp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\npp->pkt = dmam_alloc_coherent(dev, ADMA_PKT_BYTES, &pp->pkt_dma,\r\nGFP_KERNEL);\r\nif (!pp->pkt)\r\nreturn -ENOMEM;\r\nif ((pp->pkt_dma & 7) != 0) {\r\nprintk(KERN_ERR "bad alignment for pp->pkt_dma: %08x\n",\r\n(u32)pp->pkt_dma);\r\nreturn -ENOMEM;\r\n}\r\nmemset(pp->pkt, 0, ADMA_PKT_BYTES);\r\nap->private_data = pp;\r\nadma_reinit_engine(ap);\r\nreturn 0;\r\n}\r\nstatic void adma_port_stop(struct ata_port *ap)\r\n{\r\nadma_reset_engine(ap);\r\n}\r\nstatic void adma_host_init(struct ata_host *host, unsigned int chip_id)\r\n{\r\nunsigned int port_no;\r\nwriteb(7, host->iomap[ADMA_MMIO_BAR] + ADMA_MODE_LOCK);\r\nfor (port_no = 0; port_no < ADMA_PORTS; ++port_no)\r\nadma_reset_engine(host->ports[port_no]);\r\n}\r\nstatic int adma_set_dma_masks(struct pci_dev *pdev, void __iomem *mmio_base)\r\n{\r\nint rc;\r\nrc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev, "32-bit DMA enable failed\n");\r\nreturn rc;\r\n}\r\nrc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (rc) {\r\ndev_err(&pdev->dev, "32-bit consistent DMA enable failed\n");\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adma_ata_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nunsigned int board_idx = (unsigned int) ent->driver_data;\r\nconst struct ata_port_info *ppi[] = { &adma_port_info[board_idx], NULL };\r\nstruct ata_host *host;\r\nvoid __iomem *mmio_base;\r\nint rc, port_no;\r\nata_print_version_once(&pdev->dev, DRV_VERSION);\r\nhost = ata_host_alloc_pinfo(&pdev->dev, ppi, ADMA_PORTS);\r\nif (!host)\r\nreturn -ENOMEM;\r\nrc = pcim_enable_device(pdev);\r\nif (rc)\r\nreturn rc;\r\nif ((pci_resource_flags(pdev, 4) & IORESOURCE_MEM) == 0)\r\nreturn -ENODEV;\r\nrc = pcim_iomap_regions(pdev, 1 << ADMA_MMIO_BAR, DRV_NAME);\r\nif (rc)\r\nreturn rc;\r\nhost->iomap = pcim_iomap_table(pdev);\r\nmmio_base = host->iomap[ADMA_MMIO_BAR];\r\nrc = adma_set_dma_masks(pdev, mmio_base);\r\nif (rc)\r\nreturn rc;\r\nfor (port_no = 0; port_no < ADMA_PORTS; ++port_no) {\r\nstruct ata_port *ap = host->ports[port_no];\r\nvoid __iomem *port_base = ADMA_ATA_REGS(mmio_base, port_no);\r\nunsigned int offset = port_base - mmio_base;\r\nadma_ata_setup_port(&ap->ioaddr, port_base);\r\nata_port_pbar_desc(ap, ADMA_MMIO_BAR, -1, "mmio");\r\nata_port_pbar_desc(ap, ADMA_MMIO_BAR, offset, "port");\r\n}\r\nadma_host_init(host, board_idx);\r\npci_set_master(pdev);\r\nreturn ata_host_activate(host, pdev->irq, adma_intr, IRQF_SHARED,\r\n&adma_ata_sht);\r\n}
