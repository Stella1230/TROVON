int lc_try_lock(struct lru_cache *lc)\r\n{\r\nunsigned long val;\r\ndo {\r\nval = cmpxchg(&lc->flags, 0, LC_LOCKED);\r\n} while (unlikely (val == LC_PARANOIA));\r\nreturn 0 == val;\r\n#if 0\r\nunsigned long old, new, val;\r\ndo {\r\nold = lc->flags & LC_PARANOIA;\r\nnew = old | LC_LOCKED;\r\nval = cmpxchg(&lc->flags, old, new);\r\n} while (unlikely (val == (old ^ LC_PARANOIA)));\r\nreturn old == val;\r\n#endif\r\n}\r\nstruct lru_cache *lc_create(const char *name, struct kmem_cache *cache,\r\nunsigned max_pending_changes,\r\nunsigned e_count, size_t e_size, size_t e_off)\r\n{\r\nstruct hlist_head *slot = NULL;\r\nstruct lc_element **element = NULL;\r\nstruct lru_cache *lc;\r\nstruct lc_element *e;\r\nunsigned cache_obj_size = kmem_cache_size(cache);\r\nunsigned i;\r\nWARN_ON(cache_obj_size < e_size);\r\nif (cache_obj_size < e_size)\r\nreturn NULL;\r\nif (e_count > LC_MAX_ACTIVE)\r\nreturn NULL;\r\nslot = kcalloc(e_count, sizeof(struct hlist_head), GFP_KERNEL);\r\nif (!slot)\r\ngoto out_fail;\r\nelement = kzalloc(e_count * sizeof(struct lc_element *), GFP_KERNEL);\r\nif (!element)\r\ngoto out_fail;\r\nlc = kzalloc(sizeof(*lc), GFP_KERNEL);\r\nif (!lc)\r\ngoto out_fail;\r\nINIT_LIST_HEAD(&lc->in_use);\r\nINIT_LIST_HEAD(&lc->lru);\r\nINIT_LIST_HEAD(&lc->free);\r\nINIT_LIST_HEAD(&lc->to_be_changed);\r\nlc->name = name;\r\nlc->element_size = e_size;\r\nlc->element_off = e_off;\r\nlc->nr_elements = e_count;\r\nlc->max_pending_changes = max_pending_changes;\r\nlc->lc_cache = cache;\r\nlc->lc_element = element;\r\nlc->lc_slot = slot;\r\nfor (i = 0; i < e_count; i++) {\r\nvoid *p = kmem_cache_alloc(cache, GFP_KERNEL);\r\nif (!p)\r\nbreak;\r\nmemset(p, 0, lc->element_size);\r\ne = p + e_off;\r\ne->lc_index = i;\r\ne->lc_number = LC_FREE;\r\ne->lc_new_number = LC_FREE;\r\nlist_add(&e->list, &lc->free);\r\nelement[i] = e;\r\n}\r\nif (i == e_count)\r\nreturn lc;\r\nfor (i--; i; i--) {\r\nvoid *p = element[i];\r\nkmem_cache_free(cache, p - e_off);\r\n}\r\nkfree(lc);\r\nout_fail:\r\nkfree(element);\r\nkfree(slot);\r\nreturn NULL;\r\n}\r\nvoid lc_free_by_index(struct lru_cache *lc, unsigned i)\r\n{\r\nvoid *p = lc->lc_element[i];\r\nWARN_ON(!p);\r\nif (p) {\r\np -= lc->element_off;\r\nkmem_cache_free(lc->lc_cache, p);\r\n}\r\n}\r\nvoid lc_destroy(struct lru_cache *lc)\r\n{\r\nunsigned i;\r\nif (!lc)\r\nreturn;\r\nfor (i = 0; i < lc->nr_elements; i++)\r\nlc_free_by_index(lc, i);\r\nkfree(lc->lc_element);\r\nkfree(lc->lc_slot);\r\nkfree(lc);\r\n}\r\nvoid lc_reset(struct lru_cache *lc)\r\n{\r\nunsigned i;\r\nINIT_LIST_HEAD(&lc->in_use);\r\nINIT_LIST_HEAD(&lc->lru);\r\nINIT_LIST_HEAD(&lc->free);\r\nINIT_LIST_HEAD(&lc->to_be_changed);\r\nlc->used = 0;\r\nlc->hits = 0;\r\nlc->misses = 0;\r\nlc->starving = 0;\r\nlc->locked = 0;\r\nlc->changed = 0;\r\nlc->pending_changes = 0;\r\nlc->flags = 0;\r\nmemset(lc->lc_slot, 0, sizeof(struct hlist_head) * lc->nr_elements);\r\nfor (i = 0; i < lc->nr_elements; i++) {\r\nstruct lc_element *e = lc->lc_element[i];\r\nvoid *p = e;\r\np -= lc->element_off;\r\nmemset(p, 0, lc->element_size);\r\ne->lc_index = i;\r\ne->lc_number = LC_FREE;\r\ne->lc_new_number = LC_FREE;\r\nlist_add(&e->list, &lc->free);\r\n}\r\n}\r\nsize_t lc_seq_printf_stats(struct seq_file *seq, struct lru_cache *lc)\r\n{\r\nreturn seq_printf(seq, "\t%s: used:%u/%u "\r\n"hits:%lu misses:%lu starving:%lu locked:%lu changed:%lu\n",\r\nlc->name, lc->used, lc->nr_elements,\r\nlc->hits, lc->misses, lc->starving, lc->locked, lc->changed);\r\n}\r\nstatic struct hlist_head *lc_hash_slot(struct lru_cache *lc, unsigned int enr)\r\n{\r\nreturn lc->lc_slot + (enr % lc->nr_elements);\r\n}\r\nstatic struct lc_element *__lc_find(struct lru_cache *lc, unsigned int enr,\r\nbool include_changing)\r\n{\r\nstruct lc_element *e;\r\nBUG_ON(!lc);\r\nBUG_ON(!lc->nr_elements);\r\nhlist_for_each_entry(e, lc_hash_slot(lc, enr), colision) {\r\nif (e->lc_new_number != enr)\r\ncontinue;\r\nif (e->lc_new_number == e->lc_number || include_changing)\r\nreturn e;\r\nbreak;\r\n}\r\nreturn NULL;\r\n}\r\nstruct lc_element *lc_find(struct lru_cache *lc, unsigned int enr)\r\n{\r\nreturn __lc_find(lc, enr, 0);\r\n}\r\nbool lc_is_used(struct lru_cache *lc, unsigned int enr)\r\n{\r\nstruct lc_element *e = __lc_find(lc, enr, 1);\r\nreturn e && e->refcnt;\r\n}\r\nvoid lc_del(struct lru_cache *lc, struct lc_element *e)\r\n{\r\nPARANOIA_ENTRY();\r\nPARANOIA_LC_ELEMENT(lc, e);\r\nBUG_ON(e->refcnt);\r\ne->lc_number = e->lc_new_number = LC_FREE;\r\nhlist_del_init(&e->colision);\r\nlist_move(&e->list, &lc->free);\r\nRETURN();\r\n}\r\nstatic struct lc_element *lc_prepare_for_change(struct lru_cache *lc, unsigned new_number)\r\n{\r\nstruct list_head *n;\r\nstruct lc_element *e;\r\nif (!list_empty(&lc->free))\r\nn = lc->free.next;\r\nelse if (!list_empty(&lc->lru))\r\nn = lc->lru.prev;\r\nelse\r\nreturn NULL;\r\ne = list_entry(n, struct lc_element, list);\r\nPARANOIA_LC_ELEMENT(lc, e);\r\ne->lc_new_number = new_number;\r\nif (!hlist_unhashed(&e->colision))\r\n__hlist_del(&e->colision);\r\nhlist_add_head(&e->colision, lc_hash_slot(lc, new_number));\r\nlist_move(&e->list, &lc->to_be_changed);\r\nreturn e;\r\n}\r\nstatic int lc_unused_element_available(struct lru_cache *lc)\r\n{\r\nif (!list_empty(&lc->free))\r\nreturn 1;\r\nif (!list_empty(&lc->lru))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic struct lc_element *__lc_get(struct lru_cache *lc, unsigned int enr, unsigned int flags)\r\n{\r\nstruct lc_element *e;\r\nPARANOIA_ENTRY();\r\nif (lc->flags & LC_STARVING) {\r\n++lc->starving;\r\nRETURN(NULL);\r\n}\r\ne = __lc_find(lc, enr, 1);\r\nif (e) {\r\nif (e->lc_new_number != e->lc_number) {\r\nif (!(flags & LC_GET_MAY_USE_UNCOMMITTED))\r\nRETURN(NULL);\r\n++e->refcnt;\r\n++lc->hits;\r\nRETURN(e);\r\n}\r\n++lc->hits;\r\nif (e->refcnt++ == 0)\r\nlc->used++;\r\nlist_move(&e->list, &lc->in_use);\r\nRETURN(e);\r\n}\r\n++lc->misses;\r\nif (!(flags & LC_GET_MAY_CHANGE))\r\nRETURN(NULL);\r\ntest_and_set_bit(__LC_DIRTY, &lc->flags);\r\nif (test_bit(__LC_LOCKED, &lc->flags)) {\r\n++lc->locked;\r\nRETURN(NULL);\r\n}\r\nif (!lc_unused_element_available(lc)) {\r\n__set_bit(__LC_STARVING, &lc->flags);\r\nRETURN(NULL);\r\n}\r\nif (lc->pending_changes >= lc->max_pending_changes)\r\nRETURN(NULL);\r\ne = lc_prepare_for_change(lc, enr);\r\nBUG_ON(!e);\r\nclear_bit(__LC_STARVING, &lc->flags);\r\nBUG_ON(++e->refcnt != 1);\r\nlc->used++;\r\nlc->pending_changes++;\r\nRETURN(e);\r\n}\r\nstruct lc_element *lc_get(struct lru_cache *lc, unsigned int enr)\r\n{\r\nreturn __lc_get(lc, enr, LC_GET_MAY_CHANGE);\r\n}\r\nstruct lc_element *lc_get_cumulative(struct lru_cache *lc, unsigned int enr)\r\n{\r\nreturn __lc_get(lc, enr, LC_GET_MAY_CHANGE|LC_GET_MAY_USE_UNCOMMITTED);\r\n}\r\nstruct lc_element *lc_try_get(struct lru_cache *lc, unsigned int enr)\r\n{\r\nreturn __lc_get(lc, enr, 0);\r\n}\r\nvoid lc_committed(struct lru_cache *lc)\r\n{\r\nstruct lc_element *e, *tmp;\r\nPARANOIA_ENTRY();\r\nlist_for_each_entry_safe(e, tmp, &lc->to_be_changed, list) {\r\n++lc->changed;\r\ne->lc_number = e->lc_new_number;\r\nlist_move(&e->list, &lc->in_use);\r\n}\r\nlc->pending_changes = 0;\r\nRETURN();\r\n}\r\nunsigned int lc_put(struct lru_cache *lc, struct lc_element *e)\r\n{\r\nPARANOIA_ENTRY();\r\nPARANOIA_LC_ELEMENT(lc, e);\r\nBUG_ON(e->refcnt == 0);\r\nBUG_ON(e->lc_number != e->lc_new_number);\r\nif (--e->refcnt == 0) {\r\nlist_move(&e->list, &lc->lru);\r\nlc->used--;\r\nclear_bit_unlock(__LC_STARVING, &lc->flags);\r\n}\r\nRETURN(e->refcnt);\r\n}\r\nstruct lc_element *lc_element_by_index(struct lru_cache *lc, unsigned i)\r\n{\r\nBUG_ON(i >= lc->nr_elements);\r\nBUG_ON(lc->lc_element[i] == NULL);\r\nBUG_ON(lc->lc_element[i]->lc_index != i);\r\nreturn lc->lc_element[i];\r\n}\r\nunsigned int lc_index_of(struct lru_cache *lc, struct lc_element *e)\r\n{\r\nPARANOIA_LC_ELEMENT(lc, e);\r\nreturn e->lc_index;\r\n}\r\nvoid lc_set(struct lru_cache *lc, unsigned int enr, int index)\r\n{\r\nstruct lc_element *e;\r\nstruct list_head *lh;\r\nif (index < 0 || index >= lc->nr_elements)\r\nreturn;\r\ne = lc_element_by_index(lc, index);\r\nBUG_ON(e->lc_number != e->lc_new_number);\r\nBUG_ON(e->refcnt != 0);\r\ne->lc_number = e->lc_new_number = enr;\r\nhlist_del_init(&e->colision);\r\nif (enr == LC_FREE)\r\nlh = &lc->free;\r\nelse {\r\nhlist_add_head(&e->colision, lc_hash_slot(lc, enr));\r\nlh = &lc->lru;\r\n}\r\nlist_move(&e->list, lh);\r\n}\r\nvoid lc_seq_dump_details(struct seq_file *seq, struct lru_cache *lc, char *utext,\r\nvoid (*detail) (struct seq_file *, struct lc_element *))\r\n{\r\nunsigned int nr_elements = lc->nr_elements;\r\nstruct lc_element *e;\r\nint i;\r\nseq_printf(seq, "\tnn: lc_number refcnt %s\n ", utext);\r\nfor (i = 0; i < nr_elements; i++) {\r\ne = lc_element_by_index(lc, i);\r\nif (e->lc_number == LC_FREE) {\r\nseq_printf(seq, "\t%2d: FREE\n", i);\r\n} else {\r\nseq_printf(seq, "\t%2d: %4u %4u ", i,\r\ne->lc_number, e->refcnt);\r\ndetail(seq, e);\r\n}\r\n}\r\n}
