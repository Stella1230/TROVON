static ssize_t connect_type_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nchar *result;\r\nswitch (port_dev->connect_type) {\r\ncase USB_PORT_CONNECT_TYPE_HOT_PLUG:\r\nresult = "hotplug";\r\nbreak;\r\ncase USB_PORT_CONNECT_TYPE_HARD_WIRED:\r\nresult = "hardwired";\r\nbreak;\r\ncase USB_PORT_NOT_USED:\r\nresult = "not used";\r\nbreak;\r\ndefault:\r\nresult = "unknown";\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%s\n", result);\r\n}\r\nstatic void usb_port_device_release(struct device *dev)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nkfree(port_dev);\r\n}\r\nstatic int usb_port_runtime_resume(struct device *dev)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nstruct usb_device *hdev = to_usb_device(dev->parent->parent);\r\nstruct usb_interface *intf = to_usb_interface(dev->parent);\r\nstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\r\nint port1 = port_dev->portnum;\r\nint retval;\r\nif (!hub)\r\nreturn -EINVAL;\r\nusb_autopm_get_interface(intf);\r\nset_bit(port1, hub->busy_bits);\r\nretval = usb_hub_set_port_power(hdev, hub, port1, true);\r\nif (port_dev->child && !retval) {\r\nretval = hub_port_debounce_be_connected(hub, port1);\r\nif (retval < 0)\r\ndev_dbg(&port_dev->dev, "can't get reconnection after setting port power on, status %d\n",\r\nretval);\r\nusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\r\nretval = 0;\r\n}\r\nclear_bit(port1, hub->busy_bits);\r\nusb_autopm_put_interface(intf);\r\nreturn retval;\r\n}\r\nstatic int usb_port_runtime_suspend(struct device *dev)\r\n{\r\nstruct usb_port *port_dev = to_usb_port(dev);\r\nstruct usb_device *hdev = to_usb_device(dev->parent->parent);\r\nstruct usb_interface *intf = to_usb_interface(dev->parent);\r\nstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\r\nint port1 = port_dev->portnum;\r\nint retval;\r\nif (!hub)\r\nreturn -EINVAL;\r\nif (dev_pm_qos_flags(&port_dev->dev, PM_QOS_FLAG_NO_POWER_OFF)\r\n== PM_QOS_FLAGS_ALL)\r\nreturn -EAGAIN;\r\nusb_autopm_get_interface(intf);\r\nset_bit(port1, hub->busy_bits);\r\nretval = usb_hub_set_port_power(hdev, hub, port1, false);\r\nusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\r\nusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\r\nclear_bit(port1, hub->busy_bits);\r\nusb_autopm_put_interface(intf);\r\nreturn retval;\r\n}\r\nint usb_hub_create_port_device(struct usb_hub *hub, int port1)\r\n{\r\nstruct usb_port *port_dev = NULL;\r\nint retval;\r\nport_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);\r\nif (!port_dev) {\r\nretval = -ENOMEM;\r\ngoto exit;\r\n}\r\nhub->ports[port1 - 1] = port_dev;\r\nport_dev->portnum = port1;\r\nport_dev->power_is_on = true;\r\nport_dev->dev.parent = hub->intfdev;\r\nport_dev->dev.groups = port_dev_group;\r\nport_dev->dev.type = &usb_port_device_type;\r\ndev_set_name(&port_dev->dev, "port%d", port1);\r\nretval = device_register(&port_dev->dev);\r\nif (retval)\r\ngoto error_register;\r\npm_runtime_set_active(&port_dev->dev);\r\nif (!dev_pm_qos_expose_flags(&port_dev->dev,\r\nPM_QOS_FLAG_NO_POWER_OFF))\r\npm_runtime_enable(&port_dev->dev);\r\ndevice_enable_async_suspend(&port_dev->dev);\r\nreturn 0;\r\nerror_register:\r\nput_device(&port_dev->dev);\r\nexit:\r\nreturn retval;\r\n}\r\nvoid usb_hub_remove_port_device(struct usb_hub *hub,\r\nint port1)\r\n{\r\ndevice_unregister(&hub->ports[port1 - 1]->dev);\r\n}
