void drbd_md_io_complete(struct bio *bio, int error)\r\n{\r\nstruct drbd_md_io *md_io;\r\nstruct drbd_conf *mdev;\r\nmd_io = (struct drbd_md_io *)bio->bi_private;\r\nmdev = container_of(md_io, struct drbd_conf, md_io);\r\nmd_io->error = error;\r\ndrbd_md_put_buffer(mdev);\r\nmd_io->done = 1;\r\nwake_up(&mdev->misc_wait);\r\nbio_put(bio);\r\nif (mdev->ldev)\r\nput_ldev(mdev);\r\n}\r\nvoid drbd_endio_read_sec_final(struct drbd_peer_request *peer_req) __releases(local)\r\n{\r\nunsigned long flags = 0;\r\nstruct drbd_conf *mdev = peer_req->w.mdev;\r\nspin_lock_irqsave(&mdev->tconn->req_lock, flags);\r\nmdev->read_cnt += peer_req->i.size >> 9;\r\nlist_del(&peer_req->w.list);\r\nif (list_empty(&mdev->read_ee))\r\nwake_up(&mdev->ee_wait);\r\nif (test_bit(__EE_WAS_ERROR, &peer_req->flags))\r\n__drbd_chk_io_error(mdev, DRBD_READ_ERROR);\r\nspin_unlock_irqrestore(&mdev->tconn->req_lock, flags);\r\ndrbd_queue_work(&mdev->tconn->sender_work, &peer_req->w);\r\nput_ldev(mdev);\r\n}\r\nstatic void drbd_endio_write_sec_final(struct drbd_peer_request *peer_req) __releases(local)\r\n{\r\nunsigned long flags = 0;\r\nstruct drbd_conf *mdev = peer_req->w.mdev;\r\nstruct drbd_interval i;\r\nint do_wake;\r\nu64 block_id;\r\nint do_al_complete_io;\r\ni = peer_req->i;\r\ndo_al_complete_io = peer_req->flags & EE_CALL_AL_COMPLETE_IO;\r\nblock_id = peer_req->block_id;\r\nspin_lock_irqsave(&mdev->tconn->req_lock, flags);\r\nmdev->writ_cnt += peer_req->i.size >> 9;\r\nlist_move_tail(&peer_req->w.list, &mdev->done_ee);\r\ndo_wake = list_empty(block_id == ID_SYNCER ? &mdev->sync_ee : &mdev->active_ee);\r\nif (test_bit(__EE_WAS_ERROR, &peer_req->flags))\r\n__drbd_chk_io_error(mdev, DRBD_WRITE_ERROR);\r\nspin_unlock_irqrestore(&mdev->tconn->req_lock, flags);\r\nif (block_id == ID_SYNCER)\r\ndrbd_rs_complete_io(mdev, i.sector);\r\nif (do_wake)\r\nwake_up(&mdev->ee_wait);\r\nif (do_al_complete_io)\r\ndrbd_al_complete_io(mdev, &i);\r\nwake_asender(mdev->tconn);\r\nput_ldev(mdev);\r\n}\r\nvoid drbd_peer_request_endio(struct bio *bio, int error)\r\n{\r\nstruct drbd_peer_request *peer_req = bio->bi_private;\r\nstruct drbd_conf *mdev = peer_req->w.mdev;\r\nint uptodate = bio_flagged(bio, BIO_UPTODATE);\r\nint is_write = bio_data_dir(bio) == WRITE;\r\nif (error && __ratelimit(&drbd_ratelimit_state))\r\ndev_warn(DEV, "%s: error=%d s=%llus\n",\r\nis_write ? "write" : "read", error,\r\n(unsigned long long)peer_req->i.sector);\r\nif (!error && !uptodate) {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_warn(DEV, "%s: setting error to -EIO s=%llus\n",\r\nis_write ? "write" : "read",\r\n(unsigned long long)peer_req->i.sector);\r\nerror = -EIO;\r\n}\r\nif (error)\r\nset_bit(__EE_WAS_ERROR, &peer_req->flags);\r\nbio_put(bio);\r\nif (atomic_dec_and_test(&peer_req->pending_bios)) {\r\nif (is_write)\r\ndrbd_endio_write_sec_final(peer_req);\r\nelse\r\ndrbd_endio_read_sec_final(peer_req);\r\n}\r\n}\r\nvoid drbd_request_endio(struct bio *bio, int error)\r\n{\r\nunsigned long flags;\r\nstruct drbd_request *req = bio->bi_private;\r\nstruct drbd_conf *mdev = req->w.mdev;\r\nstruct bio_and_error m;\r\nenum drbd_req_event what;\r\nint uptodate = bio_flagged(bio, BIO_UPTODATE);\r\nif (!error && !uptodate) {\r\ndev_warn(DEV, "p %s: setting error to -EIO\n",\r\nbio_data_dir(bio) == WRITE ? "write" : "read");\r\nerror = -EIO;\r\n}\r\nif (unlikely(req->rq_state & RQ_LOCAL_ABORTED)) {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_emerg(DEV, "delayed completion of aborted local request; disk-timeout may be too aggressive\n");\r\nif (!error)\r\npanic("possible random memory corruption caused by delayed completion of aborted local request\n");\r\n}\r\nif (unlikely(error)) {\r\nwhat = (bio_data_dir(bio) == WRITE)\r\n? WRITE_COMPLETED_WITH_ERROR\r\n: (bio_rw(bio) == READ)\r\n? READ_COMPLETED_WITH_ERROR\r\n: READ_AHEAD_COMPLETED_WITH_ERROR;\r\n} else\r\nwhat = COMPLETED_OK;\r\nbio_put(req->private_bio);\r\nreq->private_bio = ERR_PTR(error);\r\nspin_lock_irqsave(&mdev->tconn->req_lock, flags);\r\n__req_mod(req, what, &m);\r\nspin_unlock_irqrestore(&mdev->tconn->req_lock, flags);\r\nput_ldev(mdev);\r\nif (m.bio)\r\ncomplete_master_bio(mdev, &m);\r\n}\r\nvoid drbd_csum_ee(struct drbd_conf *mdev, struct crypto_hash *tfm,\r\nstruct drbd_peer_request *peer_req, void *digest)\r\n{\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nstruct page *page = peer_req->pages;\r\nstruct page *tmp;\r\nunsigned len;\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nsg_init_table(&sg, 1);\r\ncrypto_hash_init(&desc);\r\nwhile ((tmp = page_chain_next(page))) {\r\nsg_set_page(&sg, page, PAGE_SIZE, 0);\r\ncrypto_hash_update(&desc, &sg, sg.length);\r\npage = tmp;\r\n}\r\nlen = peer_req->i.size & (PAGE_SIZE - 1);\r\nsg_set_page(&sg, page, len ?: PAGE_SIZE, 0);\r\ncrypto_hash_update(&desc, &sg, sg.length);\r\ncrypto_hash_final(&desc, digest);\r\n}\r\nvoid drbd_csum_bio(struct drbd_conf *mdev, struct crypto_hash *tfm, struct bio *bio, void *digest)\r\n{\r\nstruct hash_desc desc;\r\nstruct scatterlist sg;\r\nstruct bio_vec *bvec;\r\nint i;\r\ndesc.tfm = tfm;\r\ndesc.flags = 0;\r\nsg_init_table(&sg, 1);\r\ncrypto_hash_init(&desc);\r\nbio_for_each_segment(bvec, bio, i) {\r\nsg_set_page(&sg, bvec->bv_page, bvec->bv_len, bvec->bv_offset);\r\ncrypto_hash_update(&desc, &sg, sg.length);\r\n}\r\ncrypto_hash_final(&desc, digest);\r\n}\r\nstatic int w_e_send_csum(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nint digest_size;\r\nvoid *digest;\r\nint err = 0;\r\nif (unlikely(cancel))\r\ngoto out;\r\nif (unlikely((peer_req->flags & EE_WAS_ERROR) != 0))\r\ngoto out;\r\ndigest_size = crypto_hash_digestsize(mdev->tconn->csums_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (digest) {\r\nsector_t sector = peer_req->i.sector;\r\nunsigned int size = peer_req->i.size;\r\ndrbd_csum_ee(mdev, mdev->tconn->csums_tfm, peer_req, digest);\r\ndrbd_free_peer_req(mdev, peer_req);\r\npeer_req = NULL;\r\ninc_rs_pending(mdev);\r\nerr = drbd_send_drequest_csum(mdev, sector, size,\r\ndigest, digest_size,\r\nP_CSUM_RS_REQUEST);\r\nkfree(digest);\r\n} else {\r\ndev_err(DEV, "kmalloc() of digest failed.\n");\r\nerr = -ENOMEM;\r\n}\r\nout:\r\nif (peer_req)\r\ndrbd_free_peer_req(mdev, peer_req);\r\nif (unlikely(err))\r\ndev_err(DEV, "drbd_send_drequest(..., csum) failed\n");\r\nreturn err;\r\n}\r\nstatic int read_for_csum(struct drbd_conf *mdev, sector_t sector, int size)\r\n{\r\nstruct drbd_peer_request *peer_req;\r\nif (!get_ldev(mdev))\r\nreturn -EIO;\r\nif (drbd_rs_should_slow_down(mdev, sector))\r\ngoto defer;\r\npeer_req = drbd_alloc_peer_req(mdev, ID_SYNCER , sector,\r\nsize, GFP_TRY);\r\nif (!peer_req)\r\ngoto defer;\r\npeer_req->w.cb = w_e_send_csum;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_add(&peer_req->w.list, &mdev->read_ee);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\natomic_add(size >> 9, &mdev->rs_sect_ev);\r\nif (drbd_submit_peer_request(mdev, peer_req, READ, DRBD_FAULT_RS_RD) == 0)\r\nreturn 0;\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_del(&peer_req->w.list);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\ndrbd_free_peer_req(mdev, peer_req);\r\ndefer:\r\nput_ldev(mdev);\r\nreturn -EAGAIN;\r\n}\r\nint w_resync_timer(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nswitch (mdev->state.conn) {\r\ncase C_VERIFY_S:\r\nw_make_ov_request(w, cancel);\r\nbreak;\r\ncase C_SYNC_TARGET:\r\nw_make_resync_request(w, cancel);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid resync_timer_fn(unsigned long data)\r\n{\r\nstruct drbd_conf *mdev = (struct drbd_conf *) data;\r\nif (list_empty(&mdev->resync_work.list))\r\ndrbd_queue_work(&mdev->tconn->sender_work, &mdev->resync_work);\r\n}\r\nstatic void fifo_set(struct fifo_buffer *fb, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < fb->size; i++)\r\nfb->values[i] = value;\r\n}\r\nstatic int fifo_push(struct fifo_buffer *fb, int value)\r\n{\r\nint ov;\r\nov = fb->values[fb->head_index];\r\nfb->values[fb->head_index++] = value;\r\nif (fb->head_index >= fb->size)\r\nfb->head_index = 0;\r\nreturn ov;\r\n}\r\nstatic void fifo_add_val(struct fifo_buffer *fb, int value)\r\n{\r\nint i;\r\nfor (i = 0; i < fb->size; i++)\r\nfb->values[i] += value;\r\n}\r\nstruct fifo_buffer *fifo_alloc(int fifo_size)\r\n{\r\nstruct fifo_buffer *fb;\r\nfb = kzalloc(sizeof(struct fifo_buffer) + sizeof(int) * fifo_size, GFP_NOIO);\r\nif (!fb)\r\nreturn NULL;\r\nfb->head_index = 0;\r\nfb->size = fifo_size;\r\nfb->total = 0;\r\nreturn fb;\r\n}\r\nstatic int drbd_rs_controller(struct drbd_conf *mdev)\r\n{\r\nstruct disk_conf *dc;\r\nunsigned int sect_in;\r\nunsigned int want;\r\nint req_sect;\r\nint correction;\r\nint cps;\r\nint steps;\r\nint curr_corr;\r\nint max_sect;\r\nstruct fifo_buffer *plan;\r\nsect_in = atomic_xchg(&mdev->rs_sect_in, 0);\r\nmdev->rs_in_flight -= sect_in;\r\ndc = rcu_dereference(mdev->ldev->disk_conf);\r\nplan = rcu_dereference(mdev->rs_plan_s);\r\nsteps = plan->size;\r\nif (mdev->rs_in_flight + sect_in == 0) {\r\nwant = ((dc->resync_rate * 2 * SLEEP_TIME) / HZ) * steps;\r\n} else {\r\nwant = dc->c_fill_target ? dc->c_fill_target :\r\nsect_in * dc->c_delay_target * HZ / (SLEEP_TIME * 10);\r\n}\r\ncorrection = want - mdev->rs_in_flight - plan->total;\r\ncps = correction / steps;\r\nfifo_add_val(plan, cps);\r\nplan->total += cps * steps;\r\ncurr_corr = fifo_push(plan, 0);\r\nplan->total -= curr_corr;\r\nreq_sect = sect_in + curr_corr;\r\nif (req_sect < 0)\r\nreq_sect = 0;\r\nmax_sect = (dc->c_max_rate * 2 * SLEEP_TIME) / HZ;\r\nif (req_sect > max_sect)\r\nreq_sect = max_sect;\r\nreturn req_sect;\r\n}\r\nstatic int drbd_rs_number_requests(struct drbd_conf *mdev)\r\n{\r\nint number;\r\nrcu_read_lock();\r\nif (rcu_dereference(mdev->rs_plan_s)->size) {\r\nnumber = drbd_rs_controller(mdev) >> (BM_BLOCK_SHIFT - 9);\r\nmdev->c_sync_rate = number * HZ * (BM_BLOCK_SIZE / 1024) / SLEEP_TIME;\r\n} else {\r\nmdev->c_sync_rate = rcu_dereference(mdev->ldev->disk_conf)->resync_rate;\r\nnumber = SLEEP_TIME * mdev->c_sync_rate / ((BM_BLOCK_SIZE / 1024) * HZ);\r\n}\r\nrcu_read_unlock();\r\nreturn number;\r\n}\r\nint w_make_resync_request(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nunsigned long bit;\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nint max_bio_size;\r\nint number, rollback_i, size;\r\nint align, queued, sndbuf;\r\nint i = 0;\r\nif (unlikely(cancel))\r\nreturn 0;\r\nif (mdev->rs_total == 0) {\r\ndrbd_resync_finished(mdev);\r\nreturn 0;\r\n}\r\nif (!get_ldev(mdev)) {\r\ndev_err(DEV, "Disk broke down during resync!\n");\r\nreturn 0;\r\n}\r\nmax_bio_size = queue_max_hw_sectors(mdev->rq_queue) << 9;\r\nnumber = drbd_rs_number_requests(mdev);\r\nif (number == 0)\r\ngoto requeue;\r\nfor (i = 0; i < number; i++) {\r\nmutex_lock(&mdev->tconn->data.mutex);\r\nif (mdev->tconn->data.socket) {\r\nqueued = mdev->tconn->data.socket->sk->sk_wmem_queued;\r\nsndbuf = mdev->tconn->data.socket->sk->sk_sndbuf;\r\n} else {\r\nqueued = 1;\r\nsndbuf = 0;\r\n}\r\nmutex_unlock(&mdev->tconn->data.mutex);\r\nif (queued > sndbuf / 2)\r\ngoto requeue;\r\nnext_sector:\r\nsize = BM_BLOCK_SIZE;\r\nbit = drbd_bm_find_next(mdev, mdev->bm_resync_fo);\r\nif (bit == DRBD_END_OF_BITMAP) {\r\nmdev->bm_resync_fo = drbd_bm_bits(mdev);\r\nput_ldev(mdev);\r\nreturn 0;\r\n}\r\nsector = BM_BIT_TO_SECT(bit);\r\nif (drbd_rs_should_slow_down(mdev, sector) ||\r\ndrbd_try_rs_begin_io(mdev, sector)) {\r\nmdev->bm_resync_fo = bit;\r\ngoto requeue;\r\n}\r\nmdev->bm_resync_fo = bit + 1;\r\nif (unlikely(drbd_bm_test_bit(mdev, bit) == 0)) {\r\ndrbd_rs_complete_io(mdev, sector);\r\ngoto next_sector;\r\n}\r\n#if DRBD_MAX_BIO_SIZE > BM_BLOCK_SIZE\r\nalign = 1;\r\nrollback_i = i;\r\nfor (;;) {\r\nif (size + BM_BLOCK_SIZE > max_bio_size)\r\nbreak;\r\nif (sector & ((1<<(align+3))-1))\r\nbreak;\r\nif (((bit+1) & BM_BLOCKS_PER_BM_EXT_MASK) == 0)\r\nbreak;\r\nif (drbd_bm_test_bit(mdev, bit+1) != 1)\r\nbreak;\r\nbit++;\r\nsize += BM_BLOCK_SIZE;\r\nif ((BM_BLOCK_SIZE << align) <= size)\r\nalign++;\r\ni++;\r\n}\r\nif (size > BM_BLOCK_SIZE)\r\nmdev->bm_resync_fo = bit + 1;\r\n#endif\r\nif (sector + (size>>9) > capacity)\r\nsize = (capacity-sector)<<9;\r\nif (mdev->tconn->agreed_pro_version >= 89 && mdev->tconn->csums_tfm) {\r\nswitch (read_for_csum(mdev, sector, size)) {\r\ncase -EIO:\r\nput_ldev(mdev);\r\nreturn -EIO;\r\ncase -EAGAIN:\r\ndrbd_rs_complete_io(mdev, sector);\r\nmdev->bm_resync_fo = BM_SECT_TO_BIT(sector);\r\ni = rollback_i;\r\ngoto requeue;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n} else {\r\nint err;\r\ninc_rs_pending(mdev);\r\nerr = drbd_send_drequest(mdev, P_RS_DATA_REQUEST,\r\nsector, size, ID_SYNCER);\r\nif (err) {\r\ndev_err(DEV, "drbd_send_drequest() failed, aborting...\n");\r\ndec_rs_pending(mdev);\r\nput_ldev(mdev);\r\nreturn err;\r\n}\r\n}\r\n}\r\nif (mdev->bm_resync_fo >= drbd_bm_bits(mdev)) {\r\nput_ldev(mdev);\r\nreturn 0;\r\n}\r\nrequeue:\r\nmdev->rs_in_flight += (i << (BM_BLOCK_SHIFT - 9));\r\nmod_timer(&mdev->resync_timer, jiffies + SLEEP_TIME);\r\nput_ldev(mdev);\r\nreturn 0;\r\n}\r\nstatic int w_make_ov_request(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nint number, i, size;\r\nsector_t sector;\r\nconst sector_t capacity = drbd_get_capacity(mdev->this_bdev);\r\nbool stop_sector_reached = false;\r\nif (unlikely(cancel))\r\nreturn 1;\r\nnumber = drbd_rs_number_requests(mdev);\r\nsector = mdev->ov_position;\r\nfor (i = 0; i < number; i++) {\r\nif (sector >= capacity)\r\nreturn 1;\r\nstop_sector_reached = i > 0\r\n&& verify_can_do_stop_sector(mdev)\r\n&& sector >= mdev->ov_stop_sector;\r\nif (stop_sector_reached)\r\nbreak;\r\nsize = BM_BLOCK_SIZE;\r\nif (drbd_rs_should_slow_down(mdev, sector) ||\r\ndrbd_try_rs_begin_io(mdev, sector)) {\r\nmdev->ov_position = sector;\r\ngoto requeue;\r\n}\r\nif (sector + (size>>9) > capacity)\r\nsize = (capacity-sector)<<9;\r\ninc_rs_pending(mdev);\r\nif (drbd_send_ov_request(mdev, sector, size)) {\r\ndec_rs_pending(mdev);\r\nreturn 0;\r\n}\r\nsector += BM_SECT_PER_BIT;\r\n}\r\nmdev->ov_position = sector;\r\nrequeue:\r\nmdev->rs_in_flight += (i << (BM_BLOCK_SHIFT - 9));\r\nif (i == 0 || !stop_sector_reached)\r\nmod_timer(&mdev->resync_timer, jiffies + SLEEP_TIME);\r\nreturn 1;\r\n}\r\nint w_ov_finished(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nkfree(w);\r\nov_out_of_sync_print(mdev);\r\ndrbd_resync_finished(mdev);\r\nreturn 0;\r\n}\r\nstatic int w_resync_finished(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nkfree(w);\r\ndrbd_resync_finished(mdev);\r\nreturn 0;\r\n}\r\nstatic void ping_peer(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nclear_bit(GOT_PING_ACK, &tconn->flags);\r\nrequest_ping(tconn);\r\nwait_event(tconn->ping_wait,\r\ntest_bit(GOT_PING_ACK, &tconn->flags) || mdev->state.conn < C_CONNECTED);\r\n}\r\nint drbd_resync_finished(struct drbd_conf *mdev)\r\n{\r\nunsigned long db, dt, dbdt;\r\nunsigned long n_oos;\r\nunion drbd_state os, ns;\r\nstruct drbd_work *w;\r\nchar *khelper_cmd = NULL;\r\nint verify_done = 0;\r\nif (drbd_rs_del_all(mdev)) {\r\nschedule_timeout_interruptible(HZ / 10);\r\nw = kmalloc(sizeof(struct drbd_work), GFP_ATOMIC);\r\nif (w) {\r\nw->cb = w_resync_finished;\r\nw->mdev = mdev;\r\ndrbd_queue_work(&mdev->tconn->sender_work, w);\r\nreturn 1;\r\n}\r\ndev_err(DEV, "Warn failed to drbd_rs_del_all() and to kmalloc(w).\n");\r\n}\r\ndt = (jiffies - mdev->rs_start - mdev->rs_paused) / HZ;\r\nif (dt <= 0)\r\ndt = 1;\r\ndb = mdev->rs_total;\r\nif (mdev->state.conn == C_VERIFY_S || mdev->state.conn == C_VERIFY_T)\r\ndb -= mdev->ov_left;\r\ndbdt = Bit2KB(db/dt);\r\nmdev->rs_paused /= HZ;\r\nif (!get_ldev(mdev))\r\ngoto out;\r\nping_peer(mdev);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nos = drbd_read_state(mdev);\r\nverify_done = (os.conn == C_VERIFY_S || os.conn == C_VERIFY_T);\r\nif (os.conn <= C_CONNECTED)\r\ngoto out_unlock;\r\nns = os;\r\nns.conn = C_CONNECTED;\r\ndev_info(DEV, "%s done (total %lu sec; paused %lu sec; %lu K/sec)\n",\r\nverify_done ? "Online verify" : "Resync",\r\ndt + mdev->rs_paused, mdev->rs_paused, dbdt);\r\nn_oos = drbd_bm_total_weight(mdev);\r\nif (os.conn == C_VERIFY_S || os.conn == C_VERIFY_T) {\r\nif (n_oos) {\r\ndev_alert(DEV, "Online verify found %lu %dk block out of sync!\n",\r\nn_oos, Bit2KB(1));\r\nkhelper_cmd = "out-of-sync";\r\n}\r\n} else {\r\nD_ASSERT((n_oos - mdev->rs_failed) == 0);\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T)\r\nkhelper_cmd = "after-resync-target";\r\nif (mdev->tconn->csums_tfm && mdev->rs_total) {\r\nconst unsigned long s = mdev->rs_same_csum;\r\nconst unsigned long t = mdev->rs_total;\r\nconst int ratio =\r\n(t == 0) ? 0 :\r\n(t < 100000) ? ((s*100)/t) : (s/(t/100));\r\ndev_info(DEV, "%u %% had equal checksums, eliminated: %luK; "\r\n"transferred %luK total %luK\n",\r\nratio,\r\nBit2KB(mdev->rs_same_csum),\r\nBit2KB(mdev->rs_total - mdev->rs_same_csum),\r\nBit2KB(mdev->rs_total));\r\n}\r\n}\r\nif (mdev->rs_failed) {\r\ndev_info(DEV, " %lu failed blocks\n", mdev->rs_failed);\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T) {\r\nns.disk = D_INCONSISTENT;\r\nns.pdsk = D_UP_TO_DATE;\r\n} else {\r\nns.disk = D_UP_TO_DATE;\r\nns.pdsk = D_INCONSISTENT;\r\n}\r\n} else {\r\nns.disk = D_UP_TO_DATE;\r\nns.pdsk = D_UP_TO_DATE;\r\nif (os.conn == C_SYNC_TARGET || os.conn == C_PAUSED_SYNC_T) {\r\nif (mdev->p_uuid) {\r\nint i;\r\nfor (i = UI_BITMAP ; i <= UI_HISTORY_END ; i++)\r\n_drbd_uuid_set(mdev, i, mdev->p_uuid[i]);\r\ndrbd_uuid_set(mdev, UI_BITMAP, mdev->ldev->md.uuid[UI_CURRENT]);\r\n_drbd_uuid_set(mdev, UI_CURRENT, mdev->p_uuid[UI_CURRENT]);\r\n} else {\r\ndev_err(DEV, "mdev->p_uuid is NULL! BUG\n");\r\n}\r\n}\r\nif (!(os.conn == C_VERIFY_S || os.conn == C_VERIFY_T)) {\r\ndrbd_uuid_set_bm(mdev, 0UL);\r\ndrbd_print_uuids(mdev, "updated UUIDs");\r\nif (mdev->p_uuid) {\r\nint i;\r\nfor (i = UI_CURRENT ; i <= UI_HISTORY_END ; i++)\r\nmdev->p_uuid[i] = mdev->ldev->md.uuid[i];\r\n}\r\n}\r\n}\r\n_drbd_set_state(mdev, ns, CS_VERBOSE, NULL);\r\nout_unlock:\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nput_ldev(mdev);\r\nout:\r\nmdev->rs_total = 0;\r\nmdev->rs_failed = 0;\r\nmdev->rs_paused = 0;\r\nif (verify_done && mdev->ov_left == 0)\r\nmdev->ov_start_sector = 0;\r\ndrbd_md_sync(mdev);\r\nif (khelper_cmd)\r\ndrbd_khelper(mdev, khelper_cmd);\r\nreturn 1;\r\n}\r\nstatic void move_to_net_ee_or_free(struct drbd_conf *mdev, struct drbd_peer_request *peer_req)\r\n{\r\nif (drbd_peer_req_has_active_page(peer_req)) {\r\nint i = (peer_req->i.size + PAGE_SIZE -1) >> PAGE_SHIFT;\r\natomic_add(i, &mdev->pp_in_use_by_net);\r\natomic_sub(i, &mdev->pp_in_use);\r\nspin_lock_irq(&mdev->tconn->req_lock);\r\nlist_add_tail(&peer_req->w.list, &mdev->net_ee);\r\nspin_unlock_irq(&mdev->tconn->req_lock);\r\nwake_up(&drbd_pp_wait);\r\n} else\r\ndrbd_free_peer_req(mdev, peer_req);\r\n}\r\nint w_e_end_data_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nint err;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(mdev, peer_req);\r\ndec_unacked(mdev);\r\nreturn 0;\r\n}\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\nerr = drbd_send_block(mdev, P_DATA_REPLY, peer_req);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Sending NegDReply. sector=%llus.\n",\r\n(unsigned long long)peer_req->i.sector);\r\nerr = drbd_send_ack(mdev, P_NEG_DREPLY, peer_req);\r\n}\r\ndec_unacked(mdev);\r\nmove_to_net_ee_or_free(mdev, peer_req);\r\nif (unlikely(err))\r\ndev_err(DEV, "drbd_send_block() failed\n");\r\nreturn err;\r\n}\r\nint w_e_end_rsdata_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nint err;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(mdev, peer_req);\r\ndec_unacked(mdev);\r\nreturn 0;\r\n}\r\nif (get_ldev_if_state(mdev, D_FAILED)) {\r\ndrbd_rs_complete_io(mdev, peer_req->i.sector);\r\nput_ldev(mdev);\r\n}\r\nif (mdev->state.conn == C_AHEAD) {\r\nerr = drbd_send_ack(mdev, P_RS_CANCEL, peer_req);\r\n} else if (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\nif (likely(mdev->state.pdsk >= D_INCONSISTENT)) {\r\ninc_rs_pending(mdev);\r\nerr = drbd_send_block(mdev, P_RS_DATA_REPLY, peer_req);\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Not sending RSDataReply, "\r\n"partner DISKLESS!\n");\r\nerr = 0;\r\n}\r\n} else {\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Sending NegRSDReply. sector %llus.\n",\r\n(unsigned long long)peer_req->i.sector);\r\nerr = drbd_send_ack(mdev, P_NEG_RS_DREPLY, peer_req);\r\ndrbd_rs_failed_io(mdev, peer_req->i.sector, peer_req->i.size);\r\n}\r\ndec_unacked(mdev);\r\nmove_to_net_ee_or_free(mdev, peer_req);\r\nif (unlikely(err))\r\ndev_err(DEV, "drbd_send_block() failed\n");\r\nreturn err;\r\n}\r\nint w_e_end_csum_rs_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct digest_info *di;\r\nint digest_size;\r\nvoid *digest = NULL;\r\nint err, eq = 0;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(mdev, peer_req);\r\ndec_unacked(mdev);\r\nreturn 0;\r\n}\r\nif (get_ldev(mdev)) {\r\ndrbd_rs_complete_io(mdev, peer_req->i.sector);\r\nput_ldev(mdev);\r\n}\r\ndi = peer_req->digest;\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\nif (mdev->tconn->csums_tfm) {\r\ndigest_size = crypto_hash_digestsize(mdev->tconn->csums_tfm);\r\nD_ASSERT(digest_size == di->digest_size);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\n}\r\nif (digest) {\r\ndrbd_csum_ee(mdev, mdev->tconn->csums_tfm, peer_req, digest);\r\neq = !memcmp(digest, di->digest, digest_size);\r\nkfree(digest);\r\n}\r\nif (eq) {\r\ndrbd_set_in_sync(mdev, peer_req->i.sector, peer_req->i.size);\r\nmdev->rs_same_csum += peer_req->i.size >> BM_BLOCK_SHIFT;\r\nerr = drbd_send_ack(mdev, P_RS_IS_IN_SYNC, peer_req);\r\n} else {\r\ninc_rs_pending(mdev);\r\npeer_req->block_id = ID_SYNCER;\r\npeer_req->flags &= ~EE_HAS_DIGEST;\r\nkfree(di);\r\nerr = drbd_send_block(mdev, P_RS_DATA_REPLY, peer_req);\r\n}\r\n} else {\r\nerr = drbd_send_ack(mdev, P_NEG_RS_DREPLY, peer_req);\r\nif (__ratelimit(&drbd_ratelimit_state))\r\ndev_err(DEV, "Sending NegDReply. I guess it gets messy.\n");\r\n}\r\ndec_unacked(mdev);\r\nmove_to_net_ee_or_free(mdev, peer_req);\r\nif (unlikely(err))\r\ndev_err(DEV, "drbd_send_block/ack() failed\n");\r\nreturn err;\r\n}\r\nint w_e_end_ov_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nsector_t sector = peer_req->i.sector;\r\nunsigned int size = peer_req->i.size;\r\nint digest_size;\r\nvoid *digest;\r\nint err = 0;\r\nif (unlikely(cancel))\r\ngoto out;\r\ndigest_size = crypto_hash_digestsize(mdev->tconn->verify_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (!digest) {\r\nerr = 1;\r\ngoto out;\r\n}\r\nif (likely(!(peer_req->flags & EE_WAS_ERROR)))\r\ndrbd_csum_ee(mdev, mdev->tconn->verify_tfm, peer_req, digest);\r\nelse\r\nmemset(digest, 0, digest_size);\r\ndrbd_free_peer_req(mdev, peer_req);\r\npeer_req = NULL;\r\ninc_rs_pending(mdev);\r\nerr = drbd_send_drequest_csum(mdev, sector, size, digest, digest_size, P_OV_REPLY);\r\nif (err)\r\ndec_rs_pending(mdev);\r\nkfree(digest);\r\nout:\r\nif (peer_req)\r\ndrbd_free_peer_req(mdev, peer_req);\r\ndec_unacked(mdev);\r\nreturn err;\r\n}\r\nvoid drbd_ov_out_of_sync_found(struct drbd_conf *mdev, sector_t sector, int size)\r\n{\r\nif (mdev->ov_last_oos_start + mdev->ov_last_oos_size == sector) {\r\nmdev->ov_last_oos_size += size>>9;\r\n} else {\r\nmdev->ov_last_oos_start = sector;\r\nmdev->ov_last_oos_size = size>>9;\r\n}\r\ndrbd_set_out_of_sync(mdev, sector, size);\r\n}\r\nint w_e_end_ov_reply(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_peer_request *peer_req = container_of(w, struct drbd_peer_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct digest_info *di;\r\nvoid *digest;\r\nsector_t sector = peer_req->i.sector;\r\nunsigned int size = peer_req->i.size;\r\nint digest_size;\r\nint err, eq = 0;\r\nbool stop_sector_reached = false;\r\nif (unlikely(cancel)) {\r\ndrbd_free_peer_req(mdev, peer_req);\r\ndec_unacked(mdev);\r\nreturn 0;\r\n}\r\nif (get_ldev(mdev)) {\r\ndrbd_rs_complete_io(mdev, peer_req->i.sector);\r\nput_ldev(mdev);\r\n}\r\ndi = peer_req->digest;\r\nif (likely((peer_req->flags & EE_WAS_ERROR) == 0)) {\r\ndigest_size = crypto_hash_digestsize(mdev->tconn->verify_tfm);\r\ndigest = kmalloc(digest_size, GFP_NOIO);\r\nif (digest) {\r\ndrbd_csum_ee(mdev, mdev->tconn->verify_tfm, peer_req, digest);\r\nD_ASSERT(digest_size == di->digest_size);\r\neq = !memcmp(digest, di->digest, digest_size);\r\nkfree(digest);\r\n}\r\n}\r\ndrbd_free_peer_req(mdev, peer_req);\r\nif (!eq)\r\ndrbd_ov_out_of_sync_found(mdev, sector, size);\r\nelse\r\nov_out_of_sync_print(mdev);\r\nerr = drbd_send_ack_ex(mdev, P_OV_RESULT, sector, size,\r\neq ? ID_IN_SYNC : ID_OUT_OF_SYNC);\r\ndec_unacked(mdev);\r\n--mdev->ov_left;\r\nif ((mdev->ov_left & 0x200) == 0x200)\r\ndrbd_advance_rs_marks(mdev, mdev->ov_left);\r\nstop_sector_reached = verify_can_do_stop_sector(mdev) &&\r\n(sector + (size>>9)) >= mdev->ov_stop_sector;\r\nif (mdev->ov_left == 0 || stop_sector_reached) {\r\nov_out_of_sync_print(mdev);\r\ndrbd_resync_finished(mdev);\r\n}\r\nreturn err;\r\n}\r\nint w_prev_work_done(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_wq_barrier *b = container_of(w, struct drbd_wq_barrier, w);\r\ncomplete(&b->done);\r\nreturn 0;\r\n}\r\nint drbd_send_barrier(struct drbd_tconn *tconn)\r\n{\r\nstruct p_barrier *p;\r\nstruct drbd_socket *sock;\r\nsock = &tconn->data;\r\np = conn_prepare_command(tconn, sock);\r\nif (!p)\r\nreturn -EIO;\r\np->barrier = tconn->send.current_epoch_nr;\r\np->pad = 0;\r\ntconn->send.current_epoch_writes = 0;\r\nreturn conn_send_command(tconn, sock, P_BARRIER, sizeof(*p), NULL, 0);\r\n}\r\nint w_send_write_hint(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct drbd_socket *sock;\r\nif (cancel)\r\nreturn 0;\r\nsock = &mdev->tconn->data;\r\nif (!drbd_prepare_command(mdev, sock))\r\nreturn -EIO;\r\nreturn drbd_send_command(mdev, sock, P_UNPLUG_REMOTE, 0, NULL, 0);\r\n}\r\nstatic void re_init_if_first_write(struct drbd_tconn *tconn, unsigned int epoch)\r\n{\r\nif (!tconn->send.seen_any_write_yet) {\r\ntconn->send.seen_any_write_yet = true;\r\ntconn->send.current_epoch_nr = epoch;\r\ntconn->send.current_epoch_writes = 0;\r\n}\r\n}\r\nstatic void maybe_send_barrier(struct drbd_tconn *tconn, unsigned int epoch)\r\n{\r\nif (!tconn->send.seen_any_write_yet)\r\nreturn;\r\nif (tconn->send.current_epoch_nr != epoch) {\r\nif (tconn->send.current_epoch_writes)\r\ndrbd_send_barrier(tconn);\r\ntconn->send.current_epoch_nr = epoch;\r\n}\r\n}\r\nint w_send_out_of_sync(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nint err;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, SEND_CANCELED);\r\nreturn 0;\r\n}\r\nmaybe_send_barrier(tconn, req->epoch);\r\nerr = drbd_send_out_of_sync(mdev, req);\r\nreq_mod(req, OOS_HANDED_TO_NETWORK);\r\nreturn err;\r\n}\r\nint w_send_dblock(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nint err;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, SEND_CANCELED);\r\nreturn 0;\r\n}\r\nre_init_if_first_write(tconn, req->epoch);\r\nmaybe_send_barrier(tconn, req->epoch);\r\ntconn->send.current_epoch_writes++;\r\nerr = drbd_send_dblock(mdev, req);\r\nreq_mod(req, err ? SEND_FAILED : HANDED_OVER_TO_NETWORK);\r\nreturn err;\r\n}\r\nint w_send_read_req(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nstruct drbd_tconn *tconn = mdev->tconn;\r\nint err;\r\nif (unlikely(cancel)) {\r\nreq_mod(req, SEND_CANCELED);\r\nreturn 0;\r\n}\r\nmaybe_send_barrier(tconn, req->epoch);\r\nerr = drbd_send_drequest(mdev, P_DATA_REQUEST, req->i.sector, req->i.size,\r\n(unsigned long)req);\r\nreq_mod(req, err ? SEND_FAILED : HANDED_OVER_TO_NETWORK);\r\nreturn err;\r\n}\r\nint w_restart_disk_io(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_request *req = container_of(w, struct drbd_request, w);\r\nstruct drbd_conf *mdev = w->mdev;\r\nif (bio_data_dir(req->master_bio) == WRITE && req->rq_state & RQ_IN_ACT_LOG)\r\ndrbd_al_begin_io(mdev, &req->i, false);\r\ndrbd_req_make_private_bio(req, req->master_bio);\r\nreq->private_bio->bi_bdev = mdev->ldev->backing_bdev;\r\ngeneric_make_request(req->private_bio);\r\nreturn 0;\r\n}\r\nstatic int _drbd_may_sync_now(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_conf *odev = mdev;\r\nint resync_after;\r\nwhile (1) {\r\nif (!odev->ldev || odev->state.disk == D_DISKLESS)\r\nreturn 1;\r\nrcu_read_lock();\r\nresync_after = rcu_dereference(odev->ldev->disk_conf)->resync_after;\r\nrcu_read_unlock();\r\nif (resync_after == -1)\r\nreturn 1;\r\nodev = minor_to_mdev(resync_after);\r\nif (!odev)\r\nreturn 1;\r\nif ((odev->state.conn >= C_SYNC_SOURCE &&\r\nodev->state.conn <= C_PAUSED_SYNC_T) ||\r\nodev->state.aftr_isp || odev->state.peer_isp ||\r\nodev->state.user_isp)\r\nreturn 0;\r\n}\r\n}\r\nstatic int _drbd_pause_after(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_conf *odev;\r\nint i, rv = 0;\r\nrcu_read_lock();\r\nidr_for_each_entry(&minors, odev, i) {\r\nif (odev->state.conn == C_STANDALONE && odev->state.disk == D_DISKLESS)\r\ncontinue;\r\nif (!_drbd_may_sync_now(odev))\r\nrv |= (__drbd_set_state(_NS(odev, aftr_isp, 1), CS_HARD, NULL)\r\n!= SS_NOTHING_TO_DO);\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nstatic int _drbd_resume_next(struct drbd_conf *mdev)\r\n{\r\nstruct drbd_conf *odev;\r\nint i, rv = 0;\r\nrcu_read_lock();\r\nidr_for_each_entry(&minors, odev, i) {\r\nif (odev->state.conn == C_STANDALONE && odev->state.disk == D_DISKLESS)\r\ncontinue;\r\nif (odev->state.aftr_isp) {\r\nif (_drbd_may_sync_now(odev))\r\nrv |= (__drbd_set_state(_NS(odev, aftr_isp, 0),\r\nCS_HARD, NULL)\r\n!= SS_NOTHING_TO_DO) ;\r\n}\r\n}\r\nrcu_read_unlock();\r\nreturn rv;\r\n}\r\nvoid resume_next_sg(struct drbd_conf *mdev)\r\n{\r\nwrite_lock_irq(&global_state_lock);\r\n_drbd_resume_next(mdev);\r\nwrite_unlock_irq(&global_state_lock);\r\n}\r\nvoid suspend_other_sg(struct drbd_conf *mdev)\r\n{\r\nwrite_lock_irq(&global_state_lock);\r\n_drbd_pause_after(mdev);\r\nwrite_unlock_irq(&global_state_lock);\r\n}\r\nenum drbd_ret_code drbd_resync_after_valid(struct drbd_conf *mdev, int o_minor)\r\n{\r\nstruct drbd_conf *odev;\r\nint resync_after;\r\nif (o_minor == -1)\r\nreturn NO_ERROR;\r\nif (o_minor < -1 || o_minor > MINORMASK)\r\nreturn ERR_RESYNC_AFTER;\r\nodev = minor_to_mdev(o_minor);\r\nwhile (1) {\r\nif (odev == mdev)\r\nreturn ERR_RESYNC_AFTER_CYCLE;\r\nif (!odev || !odev->ldev || odev->state.disk == D_DISKLESS)\r\nreturn NO_ERROR;\r\nrcu_read_lock();\r\nresync_after = rcu_dereference(odev->ldev->disk_conf)->resync_after;\r\nrcu_read_unlock();\r\nif (resync_after == -1)\r\nreturn NO_ERROR;\r\nodev = minor_to_mdev(resync_after);\r\n}\r\n}\r\nvoid drbd_resync_after_changed(struct drbd_conf *mdev)\r\n{\r\nint changes;\r\ndo {\r\nchanges = _drbd_pause_after(mdev);\r\nchanges |= _drbd_resume_next(mdev);\r\n} while (changes);\r\n}\r\nvoid drbd_rs_controller_reset(struct drbd_conf *mdev)\r\n{\r\nstruct fifo_buffer *plan;\r\natomic_set(&mdev->rs_sect_in, 0);\r\natomic_set(&mdev->rs_sect_ev, 0);\r\nmdev->rs_in_flight = 0;\r\nrcu_read_lock();\r\nplan = rcu_dereference(mdev->rs_plan_s);\r\nplan->total = 0;\r\nfifo_set(plan, 0);\r\nrcu_read_unlock();\r\n}\r\nvoid start_resync_timer_fn(unsigned long data)\r\n{\r\nstruct drbd_conf *mdev = (struct drbd_conf *) data;\r\ndrbd_queue_work(&mdev->tconn->sender_work, &mdev->start_resync_work);\r\n}\r\nint w_start_resync(struct drbd_work *w, int cancel)\r\n{\r\nstruct drbd_conf *mdev = w->mdev;\r\nif (atomic_read(&mdev->unacked_cnt) || atomic_read(&mdev->rs_pending_cnt)) {\r\ndev_warn(DEV, "w_start_resync later...\n");\r\nmdev->start_resync_timer.expires = jiffies + HZ/10;\r\nadd_timer(&mdev->start_resync_timer);\r\nreturn 0;\r\n}\r\ndrbd_start_resync(mdev, C_SYNC_SOURCE);\r\nclear_bit(AHEAD_TO_SYNC_SOURCE, &mdev->flags);\r\nreturn 0;\r\n}\r\nvoid drbd_start_resync(struct drbd_conf *mdev, enum drbd_conns side)\r\n{\r\nunion drbd_state ns;\r\nint r;\r\nif (mdev->state.conn >= C_SYNC_SOURCE && mdev->state.conn < C_AHEAD) {\r\ndev_err(DEV, "Resync already running!\n");\r\nreturn;\r\n}\r\nif (!test_bit(B_RS_H_DONE, &mdev->flags)) {\r\nif (side == C_SYNC_TARGET) {\r\nr = drbd_khelper(mdev, "before-resync-target");\r\nr = (r >> 8) & 0xff;\r\nif (r > 0) {\r\ndev_info(DEV, "before-resync-target handler returned %d, "\r\n"dropping connection.\n", r);\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn;\r\n}\r\n} else {\r\nr = drbd_khelper(mdev, "before-resync-source");\r\nr = (r >> 8) & 0xff;\r\nif (r > 0) {\r\nif (r == 3) {\r\ndev_info(DEV, "before-resync-source handler returned %d, "\r\n"ignoring. Old userland tools?", r);\r\n} else {\r\ndev_info(DEV, "before-resync-source handler returned %d, "\r\n"dropping connection.\n", r);\r\nconn_request_state(mdev->tconn, NS(conn, C_DISCONNECTING), CS_HARD);\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nif (current == mdev->tconn->worker.task) {\r\nif (!mutex_trylock(mdev->state_mutex)) {\r\nset_bit(B_RS_H_DONE, &mdev->flags);\r\nmdev->start_resync_timer.expires = jiffies + HZ/5;\r\nadd_timer(&mdev->start_resync_timer);\r\nreturn;\r\n}\r\n} else {\r\nmutex_lock(mdev->state_mutex);\r\n}\r\nclear_bit(B_RS_H_DONE, &mdev->flags);\r\nwrite_lock_irq(&global_state_lock);\r\nif (mdev->state.conn < C_CONNECTED\r\n|| !get_ldev_if_state(mdev, D_NEGOTIATING)) {\r\nwrite_unlock_irq(&global_state_lock);\r\nmutex_unlock(mdev->state_mutex);\r\nreturn;\r\n}\r\nns = drbd_read_state(mdev);\r\nns.aftr_isp = !_drbd_may_sync_now(mdev);\r\nns.conn = side;\r\nif (side == C_SYNC_TARGET)\r\nns.disk = D_INCONSISTENT;\r\nelse\r\nns.pdsk = D_INCONSISTENT;\r\nr = __drbd_set_state(mdev, ns, CS_VERBOSE, NULL);\r\nns = drbd_read_state(mdev);\r\nif (ns.conn < C_CONNECTED)\r\nr = SS_UNKNOWN_ERROR;\r\nif (r == SS_SUCCESS) {\r\nunsigned long tw = drbd_bm_total_weight(mdev);\r\nunsigned long now = jiffies;\r\nint i;\r\nmdev->rs_failed = 0;\r\nmdev->rs_paused = 0;\r\nmdev->rs_same_csum = 0;\r\nmdev->rs_last_events = 0;\r\nmdev->rs_last_sect_ev = 0;\r\nmdev->rs_total = tw;\r\nmdev->rs_start = now;\r\nfor (i = 0; i < DRBD_SYNC_MARKS; i++) {\r\nmdev->rs_mark_left[i] = tw;\r\nmdev->rs_mark_time[i] = now;\r\n}\r\n_drbd_pause_after(mdev);\r\n}\r\nwrite_unlock_irq(&global_state_lock);\r\nif (r == SS_SUCCESS) {\r\nmdev->rs_last_bcast = jiffies - HZ;\r\ndev_info(DEV, "Began resync as %s (will sync %lu KB [%lu bits set]).\n",\r\ndrbd_conn_str(ns.conn),\r\n(unsigned long) mdev->rs_total << (BM_BLOCK_SHIFT-10),\r\n(unsigned long) mdev->rs_total);\r\nif (side == C_SYNC_TARGET)\r\nmdev->bm_resync_fo = 0;\r\nif (side == C_SYNC_SOURCE && mdev->tconn->agreed_pro_version < 96)\r\ndrbd_gen_and_send_sync_uuid(mdev);\r\nif (mdev->tconn->agreed_pro_version < 95 && mdev->rs_total == 0) {\r\nif (side == C_SYNC_SOURCE) {\r\nstruct net_conf *nc;\r\nint timeo;\r\nrcu_read_lock();\r\nnc = rcu_dereference(mdev->tconn->net_conf);\r\ntimeo = nc->ping_int * HZ + nc->ping_timeo * HZ / 9;\r\nrcu_read_unlock();\r\nschedule_timeout_interruptible(timeo);\r\n}\r\ndrbd_resync_finished(mdev);\r\n}\r\ndrbd_rs_controller_reset(mdev);\r\nif (ns.conn == C_SYNC_TARGET)\r\nmod_timer(&mdev->resync_timer, jiffies);\r\ndrbd_md_sync(mdev);\r\n}\r\nput_ldev(mdev);\r\nmutex_unlock(mdev->state_mutex);\r\n}\r\nbool need_to_send_barrier(struct drbd_tconn *connection)\r\n{\r\nif (!connection->send.seen_any_write_yet)\r\nreturn false;\r\nif (!connection->send.current_epoch_writes)\r\nreturn false;\r\nif (atomic_read(&connection->current_tle_nr) !=\r\nconnection->send.current_epoch_nr + 1)\r\nreturn false;\r\nreturn true;\r\n}\r\nbool dequeue_work_batch(struct drbd_work_queue *queue, struct list_head *work_list)\r\n{\r\nspin_lock_irq(&queue->q_lock);\r\nlist_splice_init(&queue->q, work_list);\r\nspin_unlock_irq(&queue->q_lock);\r\nreturn !list_empty(work_list);\r\n}\r\nbool dequeue_work_item(struct drbd_work_queue *queue, struct list_head *work_list)\r\n{\r\nspin_lock_irq(&queue->q_lock);\r\nif (!list_empty(&queue->q))\r\nlist_move(queue->q.next, work_list);\r\nspin_unlock_irq(&queue->q_lock);\r\nreturn !list_empty(work_list);\r\n}\r\nvoid wait_for_work(struct drbd_tconn *connection, struct list_head *work_list)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct net_conf *nc;\r\nint uncork, cork;\r\ndequeue_work_item(&connection->sender_work, work_list);\r\nif (!list_empty(work_list))\r\nreturn;\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\nuncork = nc ? nc->tcp_cork : 0;\r\nrcu_read_unlock();\r\nif (uncork) {\r\nmutex_lock(&connection->data.mutex);\r\nif (connection->data.socket)\r\ndrbd_tcp_uncork(connection->data.socket);\r\nmutex_unlock(&connection->data.mutex);\r\n}\r\nfor (;;) {\r\nint send_barrier;\r\nprepare_to_wait(&connection->sender_work.q_wait, &wait, TASK_INTERRUPTIBLE);\r\nspin_lock_irq(&connection->req_lock);\r\nspin_lock(&connection->sender_work.q_lock);\r\nif (!list_empty(&connection->sender_work.q))\r\nlist_move(connection->sender_work.q.next, work_list);\r\nspin_unlock(&connection->sender_work.q_lock);\r\nif (!list_empty(work_list) || signal_pending(current)) {\r\nspin_unlock_irq(&connection->req_lock);\r\nbreak;\r\n}\r\nsend_barrier = need_to_send_barrier(connection);\r\nspin_unlock_irq(&connection->req_lock);\r\nif (send_barrier) {\r\ndrbd_send_barrier(connection);\r\nconnection->send.current_epoch_nr++;\r\n}\r\nschedule();\r\n}\r\nfinish_wait(&connection->sender_work.q_wait, &wait);\r\nrcu_read_lock();\r\nnc = rcu_dereference(connection->net_conf);\r\ncork = nc ? nc->tcp_cork : 0;\r\nrcu_read_unlock();\r\nmutex_lock(&connection->data.mutex);\r\nif (connection->data.socket) {\r\nif (cork)\r\ndrbd_tcp_cork(connection->data.socket);\r\nelse if (!uncork)\r\ndrbd_tcp_uncork(connection->data.socket);\r\n}\r\nmutex_unlock(&connection->data.mutex);\r\n}\r\nint drbd_worker(struct drbd_thread *thi)\r\n{\r\nstruct drbd_tconn *tconn = thi->tconn;\r\nstruct drbd_work *w = NULL;\r\nstruct drbd_conf *mdev;\r\nLIST_HEAD(work_list);\r\nint vnr;\r\nwhile (get_t_state(thi) == RUNNING) {\r\ndrbd_thread_current_set_cpu(thi);\r\nif (list_empty(&work_list))\r\nwait_for_work(tconn, &work_list);\r\nif (signal_pending(current)) {\r\nflush_signals(current);\r\nif (get_t_state(thi) == RUNNING) {\r\nconn_warn(tconn, "Worker got an unexpected signal\n");\r\ncontinue;\r\n}\r\nbreak;\r\n}\r\nif (get_t_state(thi) != RUNNING)\r\nbreak;\r\nwhile (!list_empty(&work_list)) {\r\nw = list_first_entry(&work_list, struct drbd_work, list);\r\nlist_del_init(&w->list);\r\nif (w->cb(w, tconn->cstate < C_WF_REPORT_PARAMS) == 0)\r\ncontinue;\r\nif (tconn->cstate >= C_WF_REPORT_PARAMS)\r\nconn_request_state(tconn, NS(conn, C_NETWORK_FAILURE), CS_HARD);\r\n}\r\n}\r\ndo {\r\nwhile (!list_empty(&work_list)) {\r\nw = list_first_entry(&work_list, struct drbd_work, list);\r\nlist_del_init(&w->list);\r\nw->cb(w, 1);\r\n}\r\ndequeue_work_batch(&tconn->sender_work, &work_list);\r\n} while (!list_empty(&work_list));\r\nrcu_read_lock();\r\nidr_for_each_entry(&tconn->volumes, mdev, vnr) {\r\nD_ASSERT(mdev->state.disk == D_DISKLESS && mdev->state.conn == C_STANDALONE);\r\nkref_get(&mdev->kref);\r\nrcu_read_unlock();\r\ndrbd_mdev_cleanup(mdev);\r\nkref_put(&mdev->kref, &drbd_minor_destroy);\r\nrcu_read_lock();\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}
