static int clk_apmu_enable(struct clk_hw *hw)\r\n{\r\nstruct clk_apmu *apmu = to_clk_apmu(hw);\r\nunsigned long data;\r\nunsigned long flags = 0;\r\nif (apmu->lock)\r\nspin_lock_irqsave(apmu->lock, flags);\r\ndata = readl_relaxed(apmu->base) | apmu->enable_mask;\r\nwritel_relaxed(data, apmu->base);\r\nif (apmu->lock)\r\nspin_unlock_irqrestore(apmu->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void clk_apmu_disable(struct clk_hw *hw)\r\n{\r\nstruct clk_apmu *apmu = to_clk_apmu(hw);\r\nunsigned long data;\r\nunsigned long flags = 0;\r\nif (apmu->lock)\r\nspin_lock_irqsave(apmu->lock, flags);\r\ndata = readl_relaxed(apmu->base) & ~apmu->enable_mask;\r\nwritel_relaxed(data, apmu->base);\r\nif (apmu->lock)\r\nspin_unlock_irqrestore(apmu->lock, flags);\r\n}\r\nstruct clk *mmp_clk_register_apmu(const char *name, const char *parent_name,\r\nvoid __iomem *base, u32 enable_mask, spinlock_t *lock)\r\n{\r\nstruct clk_apmu *apmu;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\napmu = kzalloc(sizeof(*apmu), GFP_KERNEL);\r\nif (!apmu)\r\nreturn NULL;\r\ninit.name = name;\r\ninit.ops = &clk_apmu_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ninit.parent_names = (parent_name ? &parent_name : NULL);\r\ninit.num_parents = (parent_name ? 1 : 0);\r\napmu->base = base;\r\napmu->enable_mask = enable_mask;\r\napmu->lock = lock;\r\napmu->hw.init = &init;\r\nclk = clk_register(NULL, &apmu->hw);\r\nif (IS_ERR(clk))\r\nkfree(apmu);\r\nreturn clk;\r\n}
