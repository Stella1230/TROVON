static struct nf_logger *__find_logger(int pf, const char *str_logger)\r\n{\r\nstruct nf_logger *t;\r\nlist_for_each_entry(t, &nf_loggers_l[pf], list[pf]) {\r\nif (!strnicmp(str_logger, t->name, strlen(t->name)))\r\nreturn t;\r\n}\r\nreturn NULL;\r\n}\r\nvoid nf_log_set(struct net *net, u_int8_t pf, const struct nf_logger *logger)\r\n{\r\nconst struct nf_logger *log;\r\nif (pf == NFPROTO_UNSPEC)\r\nreturn;\r\nmutex_lock(&nf_log_mutex);\r\nlog = rcu_dereference_protected(net->nf.nf_loggers[pf],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (log == NULL)\r\nrcu_assign_pointer(net->nf.nf_loggers[pf], logger);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nvoid nf_log_unset(struct net *net, const struct nf_logger *logger)\r\n{\r\nint i;\r\nconst struct nf_logger *log;\r\nmutex_lock(&nf_log_mutex);\r\nfor (i = 0; i < NFPROTO_NUMPROTO; i++) {\r\nlog = rcu_dereference_protected(net->nf.nf_loggers[i],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (log == logger)\r\nRCU_INIT_POINTER(net->nf.nf_loggers[i], NULL);\r\n}\r\nmutex_unlock(&nf_log_mutex);\r\nsynchronize_rcu();\r\n}\r\nint nf_log_register(u_int8_t pf, struct nf_logger *logger)\r\n{\r\nint i;\r\nif (pf >= ARRAY_SIZE(init_net.nf.nf_loggers))\r\nreturn -EINVAL;\r\nfor (i = 0; i < ARRAY_SIZE(logger->list); i++)\r\nINIT_LIST_HEAD(&logger->list[i]);\r\nmutex_lock(&nf_log_mutex);\r\nif (pf == NFPROTO_UNSPEC) {\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\r\nlist_add_tail(&(logger->list[i]), &(nf_loggers_l[i]));\r\n} else {\r\nlist_add_tail(&logger->list[pf], &nf_loggers_l[pf]);\r\n}\r\nmutex_unlock(&nf_log_mutex);\r\nreturn 0;\r\n}\r\nvoid nf_log_unregister(struct nf_logger *logger)\r\n{\r\nint i;\r\nmutex_lock(&nf_log_mutex);\r\nfor (i = 0; i < NFPROTO_NUMPROTO; i++)\r\nlist_del(&logger->list[i]);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nint nf_log_bind_pf(struct net *net, u_int8_t pf,\r\nconst struct nf_logger *logger)\r\n{\r\nif (pf >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn -EINVAL;\r\nmutex_lock(&nf_log_mutex);\r\nif (__find_logger(pf, logger->name) == NULL) {\r\nmutex_unlock(&nf_log_mutex);\r\nreturn -ENOENT;\r\n}\r\nrcu_assign_pointer(net->nf.nf_loggers[pf], logger);\r\nmutex_unlock(&nf_log_mutex);\r\nreturn 0;\r\n}\r\nvoid nf_log_unbind_pf(struct net *net, u_int8_t pf)\r\n{\r\nif (pf >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn;\r\nmutex_lock(&nf_log_mutex);\r\nRCU_INIT_POINTER(net->nf.nf_loggers[pf], NULL);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nvoid nf_log_packet(struct net *net,\r\nu_int8_t pf,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *fmt, ...)\r\n{\r\nva_list args;\r\nchar prefix[NF_LOG_PREFIXLEN];\r\nconst struct nf_logger *logger;\r\nrcu_read_lock();\r\nlogger = rcu_dereference(net->nf.nf_loggers[pf]);\r\nif (logger) {\r\nva_start(args, fmt);\r\nvsnprintf(prefix, sizeof(prefix), fmt, args);\r\nva_end(args);\r\nlogger->logfn(net, pf, hooknum, skb, in, out, loginfo, prefix);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void *seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(seq);\r\nmutex_lock(&nf_log_mutex);\r\nif (*pos >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void *seq_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct net *net = seq_file_net(s);\r\n(*pos)++;\r\nif (*pos >= ARRAY_SIZE(net->nf.nf_loggers))\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void seq_stop(struct seq_file *s, void *v)\r\n{\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nstatic int seq_show(struct seq_file *s, void *v)\r\n{\r\nloff_t *pos = v;\r\nconst struct nf_logger *logger;\r\nstruct nf_logger *t;\r\nint ret;\r\nstruct net *net = seq_file_net(s);\r\nlogger = rcu_dereference_protected(net->nf.nf_loggers[*pos],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (!logger)\r\nret = seq_printf(s, "%2lld NONE (", *pos);\r\nelse\r\nret = seq_printf(s, "%2lld %s (", *pos, logger->name);\r\nif (ret < 0)\r\nreturn ret;\r\nlist_for_each_entry(t, &nf_loggers_l[*pos], list[*pos]) {\r\nret = seq_printf(s, "%s", t->name);\r\nif (ret < 0)\r\nreturn ret;\r\nif (&t->list[*pos] != nf_loggers_l[*pos].prev) {\r\nret = seq_printf(s, ",");\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\n}\r\nreturn seq_printf(s, ")\n");\r\n}\r\nstatic int nflog_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &nflog_seq_ops,\r\nsizeof(struct seq_net_private));\r\n}\r\nstatic int nf_log_proc_dostring(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nconst struct nf_logger *logger;\r\nchar buf[NFLOGGER_NAME_LEN];\r\nsize_t size = *lenp;\r\nint r = 0;\r\nint tindex = (unsigned long)table->extra1;\r\nstruct net *net = current->nsproxy->net_ns;\r\nif (write) {\r\nif (size > sizeof(buf))\r\nsize = sizeof(buf);\r\nif (copy_from_user(buf, buffer, size))\r\nreturn -EFAULT;\r\nif (!strcmp(buf, "NONE")) {\r\nnf_log_unbind_pf(net, tindex);\r\nreturn 0;\r\n}\r\nmutex_lock(&nf_log_mutex);\r\nlogger = __find_logger(tindex, buf);\r\nif (logger == NULL) {\r\nmutex_unlock(&nf_log_mutex);\r\nreturn -ENOENT;\r\n}\r\nrcu_assign_pointer(net->nf.nf_loggers[tindex], logger);\r\nmutex_unlock(&nf_log_mutex);\r\n} else {\r\nmutex_lock(&nf_log_mutex);\r\nlogger = rcu_dereference_protected(net->nf.nf_loggers[tindex],\r\nlockdep_is_held(&nf_log_mutex));\r\nif (!logger)\r\ntable->data = "NONE";\r\nelse\r\ntable->data = logger->name;\r\nr = proc_dostring(table, write, buffer, lenp, ppos);\r\nmutex_unlock(&nf_log_mutex);\r\n}\r\nreturn r;\r\n}\r\nstatic int netfilter_log_sysctl_init(struct net *net)\r\n{\r\nint i;\r\nstruct ctl_table *table;\r\ntable = nf_log_sysctl_table;\r\nif (!net_eq(net, &init_net)) {\r\ntable = kmemdup(nf_log_sysctl_table,\r\nsizeof(nf_log_sysctl_table),\r\nGFP_KERNEL);\r\nif (!table)\r\ngoto err_alloc;\r\n} else {\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++) {\r\nsnprintf(nf_log_sysctl_fnames[i],\r\n3, "%d", i);\r\nnf_log_sysctl_table[i].procname =\r\nnf_log_sysctl_fnames[i];\r\nnf_log_sysctl_table[i].data = NULL;\r\nnf_log_sysctl_table[i].maxlen =\r\nNFLOGGER_NAME_LEN * sizeof(char);\r\nnf_log_sysctl_table[i].mode = 0644;\r\nnf_log_sysctl_table[i].proc_handler =\r\nnf_log_proc_dostring;\r\nnf_log_sysctl_table[i].extra1 =\r\n(void *)(unsigned long) i;\r\n}\r\n}\r\nnet->nf.nf_log_dir_header = register_net_sysctl(net,\r\n"net/netfilter/nf_log",\r\ntable);\r\nif (!net->nf.nf_log_dir_header)\r\ngoto err_reg;\r\nreturn 0;\r\nerr_reg:\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\nerr_alloc:\r\nreturn -ENOMEM;\r\n}\r\nstatic void netfilter_log_sysctl_exit(struct net *net)\r\n{\r\nstruct ctl_table *table;\r\ntable = net->nf.nf_log_dir_header->ctl_table_arg;\r\nunregister_net_sysctl_table(net->nf.nf_log_dir_header);\r\nif (!net_eq(net, &init_net))\r\nkfree(table);\r\n}\r\nstatic int netfilter_log_sysctl_init(struct net *net)\r\n{\r\nreturn 0;\r\n}\r\nstatic void netfilter_log_sysctl_exit(struct net *net)\r\n{\r\n}\r\nstatic int __net_init nf_log_net_init(struct net *net)\r\n{\r\nint ret = -ENOMEM;\r\n#ifdef CONFIG_PROC_FS\r\nif (!proc_create("nf_log", S_IRUGO,\r\nnet->nf.proc_netfilter, &nflog_file_ops))\r\nreturn ret;\r\n#endif\r\nret = netfilter_log_sysctl_init(net);\r\nif (ret < 0)\r\ngoto out_sysctl;\r\nreturn 0;\r\nout_sysctl:\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nf_log", net->nf.proc_netfilter);\r\n#endif\r\nreturn ret;\r\n}\r\nstatic void __net_exit nf_log_net_exit(struct net *net)\r\n{\r\nnetfilter_log_sysctl_exit(net);\r\n#ifdef CONFIG_PROC_FS\r\nremove_proc_entry("nf_log", net->nf.proc_netfilter);\r\n#endif\r\n}\r\nint __init netfilter_log_init(void)\r\n{\r\nint i, ret;\r\nret = register_pernet_subsys(&nf_log_net_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = NFPROTO_UNSPEC; i < NFPROTO_NUMPROTO; i++)\r\nINIT_LIST_HEAD(&(nf_loggers_l[i]));\r\nreturn 0;\r\n}
