static irqreturn_t handle_twl4030_pih(int irq, void *devid)\r\n{\r\nirqreturn_t ret;\r\nu8 pih_isr;\r\nret = twl_i2c_read_u8(TWL_MODULE_PIH, &pih_isr,\r\nREG_PIH_ISR_P1);\r\nif (ret) {\r\npr_warning("twl4030: I2C error %d reading PIH ISR\n", ret);\r\nreturn IRQ_NONE;\r\n}\r\nwhile (pih_isr) {\r\nunsigned long pending = __ffs(pih_isr);\r\nunsigned int irq;\r\npih_isr &= ~BIT(pending);\r\nirq = pending + twl4030_irq_base;\r\nhandle_nested_irq(irq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int twl4030_init_sih_modules(unsigned line)\r\n{\r\nconst struct sih *sih;\r\nu8 buf[4];\r\nint i;\r\nint status;\r\nif (line > 1)\r\nreturn -EINVAL;\r\nirq_line = line;\r\nmemset(buf, 0xff, sizeof buf);\r\nsih = sih_modules;\r\nfor (i = 0; i < nr_sih_modules; i++, sih++) {\r\nif (!sih->bytes_ixr)\r\ncontinue;\r\nif (sih->irq_lines <= line)\r\ncontinue;\r\nstatus = twl_i2c_write(sih->module, buf,\r\nsih->mask[line].imr_offset, sih->bytes_ixr);\r\nif (status < 0)\r\npr_err("twl4030: err %d initializing %s %s\n",\r\nstatus, sih->name, "IMR");\r\nif (sih->set_cor) {\r\nstatus = twl_i2c_write_u8(sih->module,\r\nTWL4030_SIH_CTRL_COR_MASK,\r\nsih->control_offset);\r\nif (status < 0)\r\npr_err("twl4030: err %d initializing %s %s\n",\r\nstatus, sih->name, "SIH_CTRL");\r\n}\r\n}\r\nsih = sih_modules;\r\nfor (i = 0; i < nr_sih_modules; i++, sih++) {\r\nu8 rxbuf[4];\r\nint j;\r\nif (!sih->bytes_ixr)\r\ncontinue;\r\nif (sih->irq_lines <= line)\r\ncontinue;\r\nfor (j = 0; j < 2; j++) {\r\nstatus = twl_i2c_read(sih->module, rxbuf,\r\nsih->mask[line].isr_offset, sih->bytes_ixr);\r\nif (status < 0)\r\npr_err("twl4030: err %d initializing %s %s\n",\r\nstatus, sih->name, "ISR");\r\nif (!sih->set_cor)\r\nstatus = twl_i2c_write(sih->module, buf,\r\nsih->mask[line].isr_offset,\r\nsih->bytes_ixr);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void activate_irq(int irq)\r\n{\r\n#ifdef CONFIG_ARM\r\nset_irq_flags(irq, IRQF_VALID);\r\n#else\r\nirq_set_noprobe(irq);\r\n#endif\r\n}\r\nstatic void twl4030_sih_mask(struct irq_data *data)\r\n{\r\nstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\r\nagent->imr |= BIT(data->irq - agent->irq_base);\r\nagent->imr_change_pending = true;\r\n}\r\nstatic void twl4030_sih_unmask(struct irq_data *data)\r\n{\r\nstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\r\nagent->imr &= ~BIT(data->irq - agent->irq_base);\r\nagent->imr_change_pending = true;\r\n}\r\nstatic int twl4030_sih_set_type(struct irq_data *data, unsigned trigger)\r\n{\r\nstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\r\nif (trigger & ~(IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nreturn -EINVAL;\r\nif (irqd_get_trigger_type(data) != trigger)\r\nagent->edge_change |= BIT(data->irq - agent->irq_base);\r\nreturn 0;\r\n}\r\nstatic void twl4030_sih_bus_lock(struct irq_data *data)\r\n{\r\nstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\r\nmutex_lock(&agent->irq_lock);\r\n}\r\nstatic void twl4030_sih_bus_sync_unlock(struct irq_data *data)\r\n{\r\nstruct sih_agent *agent = irq_data_get_irq_chip_data(data);\r\nconst struct sih *sih = agent->sih;\r\nint status;\r\nif (agent->imr_change_pending) {\r\nunion {\r\nu32 word;\r\nu8 bytes[4];\r\n} imr;\r\nimr.word = cpu_to_le32(agent->imr);\r\nagent->imr_change_pending = false;\r\nstatus = twl_i2c_write(sih->module, imr.bytes,\r\nsih->mask[irq_line].imr_offset,\r\nsih->bytes_ixr);\r\nif (status)\r\npr_err("twl4030: %s, %s --> %d\n", __func__,\r\n"write", status);\r\n}\r\nif (agent->edge_change) {\r\nu32 edge_change;\r\nu8 bytes[6];\r\nedge_change = agent->edge_change;\r\nagent->edge_change = 0;\r\nstatus = twl_i2c_read(sih->module, bytes,\r\nsih->edr_offset, sih->bytes_edr);\r\nif (status) {\r\npr_err("twl4030: %s, %s --> %d\n", __func__,\r\n"read", status);\r\nreturn;\r\n}\r\nwhile (edge_change) {\r\nint i = fls(edge_change) - 1;\r\nint byte = i >> 2;\r\nint off = (i & 0x3) * 2;\r\nunsigned int type;\r\nbytes[byte] &= ~(0x03 << off);\r\ntype = irq_get_trigger_type(i + agent->irq_base);\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nbytes[byte] |= BIT(off + 1);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nbytes[byte] |= BIT(off + 0);\r\nedge_change &= ~BIT(i);\r\n}\r\nstatus = twl_i2c_write(sih->module, bytes,\r\nsih->edr_offset, sih->bytes_edr);\r\nif (status)\r\npr_err("twl4030: %s, %s --> %d\n", __func__,\r\n"write", status);\r\n}\r\nmutex_unlock(&agent->irq_lock);\r\n}\r\nstatic inline int sih_read_isr(const struct sih *sih)\r\n{\r\nint status;\r\nunion {\r\nu8 bytes[4];\r\nu32 word;\r\n} isr;\r\nisr.word = 0;\r\nstatus = twl_i2c_read(sih->module, isr.bytes,\r\nsih->mask[irq_line].isr_offset, sih->bytes_ixr);\r\nreturn (status < 0) ? status : le32_to_cpu(isr.word);\r\n}\r\nstatic irqreturn_t handle_twl4030_sih(int irq, void *data)\r\n{\r\nstruct sih_agent *agent = irq_get_handler_data(irq);\r\nconst struct sih *sih = agent->sih;\r\nint isr;\r\nisr = sih_read_isr(sih);\r\nif (isr < 0) {\r\npr_err("twl4030: %s SIH, read ISR error %d\n",\r\nsih->name, isr);\r\nreturn IRQ_HANDLED;\r\n}\r\nwhile (isr) {\r\nirq = fls(isr);\r\nirq--;\r\nisr &= ~BIT(irq);\r\nif (irq < sih->bits)\r\nhandle_nested_irq(agent->irq_base + irq);\r\nelse\r\npr_err("twl4030: %s SIH, invalid ISR bit %d\n",\r\nsih->name, irq);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint twl4030_sih_setup(struct device *dev, int module, int irq_base)\r\n{\r\nint sih_mod;\r\nconst struct sih *sih = NULL;\r\nstruct sih_agent *agent;\r\nint i, irq;\r\nint status = -EINVAL;\r\nfor (sih_mod = 0, sih = sih_modules; sih_mod < nr_sih_modules;\r\nsih_mod++, sih++) {\r\nif (sih->module == module && sih->set_cor) {\r\nstatus = 0;\r\nbreak;\r\n}\r\n}\r\nif (status < 0)\r\nreturn status;\r\nagent = kzalloc(sizeof *agent, GFP_KERNEL);\r\nif (!agent)\r\nreturn -ENOMEM;\r\nagent->irq_base = irq_base;\r\nagent->sih = sih;\r\nagent->imr = ~0;\r\nmutex_init(&agent->irq_lock);\r\nfor (i = 0; i < sih->bits; i++) {\r\nirq = irq_base + i;\r\nirq_set_chip_data(irq, agent);\r\nirq_set_chip_and_handler(irq, &twl4030_sih_irq_chip,\r\nhandle_edge_irq);\r\nirq_set_nested_thread(irq, 1);\r\nactivate_irq(irq);\r\n}\r\nirq = sih_mod + twl4030_irq_base;\r\nirq_set_handler_data(irq, agent);\r\nagent->irq_name = kasprintf(GFP_KERNEL, "twl4030_%s", sih->name);\r\nstatus = request_threaded_irq(irq, NULL, handle_twl4030_sih,\r\nIRQF_EARLY_RESUME,\r\nagent->irq_name ?: sih->name, NULL);\r\ndev_info(dev, "%s (irq %d) chaining IRQs %d..%d\n", sih->name,\r\nirq, irq_base, irq_base + i - 1);\r\nreturn status < 0 ? status : irq_base;\r\n}\r\nint twl4030_init_irq(struct device *dev, int irq_num)\r\n{\r\nstatic struct irq_chip twl4030_irq_chip;\r\nint status, i;\r\nint irq_base, irq_end, nr_irqs;\r\nstruct device_node *node = dev->of_node;\r\nnr_irqs = TWL4030_PWR_NR_IRQS + TWL4030_CORE_NR_IRQS;\r\nirq_base = irq_alloc_descs(-1, 0, nr_irqs, 0);\r\nif (IS_ERR_VALUE(irq_base)) {\r\ndev_err(dev, "Fail to allocate IRQ descs\n");\r\nreturn irq_base;\r\n}\r\nirq_domain_add_legacy(node, nr_irqs, irq_base, 0,\r\n&irq_domain_simple_ops, NULL);\r\nirq_end = irq_base + TWL4030_CORE_NR_IRQS;\r\nstatus = twl4030_init_sih_modules(twl_irq_line);\r\nif (status < 0)\r\nreturn status;\r\ntwl4030_irq_base = irq_base;\r\ntwl4030_irq_chip = dummy_irq_chip;\r\ntwl4030_irq_chip.name = "twl4030";\r\ntwl4030_sih_irq_chip.irq_ack = dummy_irq_chip.irq_ack;\r\nfor (i = irq_base; i < irq_end; i++) {\r\nirq_set_chip_and_handler(i, &twl4030_irq_chip,\r\nhandle_simple_irq);\r\nirq_set_nested_thread(i, 1);\r\nactivate_irq(i);\r\n}\r\ndev_info(dev, "%s (irq %d) chaining IRQs %d..%d\n", "PIH",\r\nirq_num, irq_base, irq_end);\r\nstatus = twl4030_sih_setup(dev, TWL4030_MODULE_INT, irq_end);\r\nif (status < 0) {\r\ndev_err(dev, "sih_setup PWR INT --> %d\n", status);\r\ngoto fail;\r\n}\r\nstatus = request_threaded_irq(irq_num, NULL, handle_twl4030_pih,\r\nIRQF_ONESHOT,\r\n"TWL4030-PIH", NULL);\r\nif (status < 0) {\r\ndev_err(dev, "could not claim irq%d: %d\n", irq_num, status);\r\ngoto fail_rqirq;\r\n}\r\nenable_irq_wake(irq_num);\r\nreturn irq_base;\r\nfail_rqirq:\r\nfail:\r\nfor (i = irq_base; i < irq_end; i++) {\r\nirq_set_nested_thread(i, 0);\r\nirq_set_chip_and_handler(i, NULL, NULL);\r\n}\r\nreturn status;\r\n}\r\nint twl4030_exit_irq(void)\r\n{\r\nif (twl4030_irq_base) {\r\npr_err("twl4030: can't yet clean up IRQs?\n");\r\nreturn -ENOSYS;\r\n}\r\nreturn 0;\r\n}\r\nint twl4030_init_chip_irq(const char *chip)\r\n{\r\nif (!strcmp(chip, "twl5031")) {\r\nsih_modules = sih_modules_twl5031;\r\nnr_sih_modules = ARRAY_SIZE(sih_modules_twl5031);\r\n} else {\r\nsih_modules = sih_modules_twl4030;\r\nnr_sih_modules = ARRAY_SIZE(sih_modules_twl4030);\r\n}\r\nreturn 0;\r\n}
