static void mga_hide_cursor(struct mga_device *mdev)\r\n{\r\nWREG8(MGA_CURPOSXL, 0);\r\nWREG8(MGA_CURPOSXH, 0);\r\nmgag200_bo_unpin(mdev->cursor.pixels_1);\r\nmgag200_bo_unpin(mdev->cursor.pixels_2);\r\n}\r\nint mga_crtc_cursor_set(struct drm_crtc *crtc,\r\nstruct drm_file *file_priv,\r\nuint32_t handle,\r\nuint32_t width,\r\nuint32_t height)\r\n{\r\nstruct drm_device *dev = (struct drm_device *)file_priv->minor->dev;\r\nstruct mga_device *mdev = (struct mga_device *)dev->dev_private;\r\nstruct mgag200_bo *pixels_1 = mdev->cursor.pixels_1;\r\nstruct mgag200_bo *pixels_2 = mdev->cursor.pixels_2;\r\nstruct mgag200_bo *pixels_current = mdev->cursor.pixels_current;\r\nstruct mgag200_bo *pixels_prev = mdev->cursor.pixels_prev;\r\nstruct drm_gem_object *obj;\r\nstruct mgag200_bo *bo = NULL;\r\nint ret = 0;\r\nunsigned int i, row, col;\r\nuint32_t colour_set[16];\r\nuint32_t *next_space = &colour_set[0];\r\nuint32_t *palette_iter;\r\nuint32_t this_colour;\r\nbool found = false;\r\nint colour_count = 0;\r\nu64 gpu_addr;\r\nu8 reg_index;\r\nu8 this_row[48];\r\nif (!pixels_1 || !pixels_2) {\r\nWREG8(MGA_CURPOSXL, 0);\r\nWREG8(MGA_CURPOSXH, 0);\r\nreturn -ENOTSUPP;\r\n}\r\nif ((width != 64 || height != 64) && handle) {\r\nWREG8(MGA_CURPOSXL, 0);\r\nWREG8(MGA_CURPOSXH, 0);\r\nreturn -EINVAL;\r\n}\r\nBUG_ON(pixels_1 != pixels_current && pixels_1 != pixels_prev);\r\nBUG_ON(pixels_2 != pixels_current && pixels_2 != pixels_prev);\r\nBUG_ON(pixels_current == pixels_prev);\r\nret = mgag200_bo_reserve(pixels_1, true);\r\nif (ret) {\r\nWREG8(MGA_CURPOSXL, 0);\r\nWREG8(MGA_CURPOSXH, 0);\r\nreturn ret;\r\n}\r\nret = mgag200_bo_reserve(pixels_2, true);\r\nif (ret) {\r\nWREG8(MGA_CURPOSXL, 0);\r\nWREG8(MGA_CURPOSXH, 0);\r\nmgag200_bo_unreserve(pixels_1);\r\nreturn ret;\r\n}\r\nif (!handle) {\r\nmga_hide_cursor(mdev);\r\nret = 0;\r\ngoto out1;\r\n}\r\nif (!pixels_1->pin_count) {\r\nret = mgag200_bo_pin(pixels_1, TTM_PL_FLAG_VRAM,\r\n&mdev->cursor.pixels_1_gpu_addr);\r\nif (ret)\r\ngoto out1;\r\n}\r\nif (!pixels_2->pin_count) {\r\nret = mgag200_bo_pin(pixels_2, TTM_PL_FLAG_VRAM,\r\n&mdev->cursor.pixels_2_gpu_addr);\r\nif (ret) {\r\nmgag200_bo_unpin(pixels_1);\r\ngoto out1;\r\n}\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(dev, file_priv, handle);\r\nif (!obj) {\r\nmutex_unlock(&dev->struct_mutex);\r\nret = -ENOENT;\r\ngoto out1;\r\n}\r\ndrm_gem_object_unreference(obj);\r\nmutex_unlock(&dev->struct_mutex);\r\nbo = gem_to_mga_bo(obj);\r\nret = mgag200_bo_reserve(bo, true);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "failed to reserve user bo\n");\r\ngoto out1;\r\n}\r\nif (!bo->kmap.virtual) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "failed to kmap user buffer updates\n");\r\ngoto out2;\r\n}\r\n}\r\nmemset(&colour_set[0], 0, sizeof(uint32_t)*16);\r\nfor (i = 0; i < 16384; i += 4) {\r\nthis_colour = ioread32(bo->kmap.virtual + i);\r\nif (this_colour>>24 != 0xff &&\r\nthis_colour>>24 != 0x0) {\r\nif (warn_transparent) {\r\ndev_info(&dev->pdev->dev, "Video card doesn't support cursors with partial transparency.\n");\r\ndev_info(&dev->pdev->dev, "Not enabling hardware cursor.\n");\r\nwarn_transparent = false;\r\n}\r\nret = -EINVAL;\r\ngoto out3;\r\n}\r\nif (this_colour>>24 == 0x0)\r\ncontinue;\r\nfound = false;\r\nfor (palette_iter = &colour_set[0]; palette_iter != next_space; palette_iter++) {\r\nif (*palette_iter == this_colour) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (found)\r\ncontinue;\r\nif (colour_count >= 16) {\r\nif (warn_palette) {\r\ndev_info(&dev->pdev->dev, "Video card only supports cursors with up to 16 colours.\n");\r\ndev_info(&dev->pdev->dev, "Not enabling hardware cursor.\n");\r\nwarn_palette = false;\r\n}\r\nret = -EINVAL;\r\ngoto out3;\r\n}\r\n*next_space = this_colour;\r\nnext_space++;\r\ncolour_count++;\r\n}\r\nfor (i = 0; i < colour_count; i++) {\r\nif (i <= 2)\r\nreg_index = 0x8 + i*0x4;\r\nelse\r\nreg_index = 0x60 + i*0x3;\r\nWREG_DAC(reg_index, colour_set[i] & 0xff);\r\nWREG_DAC(reg_index+1, colour_set[i]>>8 & 0xff);\r\nWREG_DAC(reg_index+2, colour_set[i]>>16 & 0xff);\r\nBUG_ON((colour_set[i]>>24 & 0xff) != 0xff);\r\n}\r\nif (!pixels_prev->kmap.virtual) {\r\nret = ttm_bo_kmap(&pixels_prev->bo, 0,\r\npixels_prev->bo.num_pages,\r\n&pixels_prev->kmap);\r\nif (ret) {\r\ndev_err(&dev->pdev->dev, "failed to kmap cursor updates\n");\r\ngoto out3;\r\n}\r\n}\r\nfor (row = 0; row < 64; row++) {\r\nmemset(&this_row[0], 0, 48);\r\nfor (col = 0; col < 64; col++) {\r\nthis_colour = ioread32(bo->kmap.virtual + 4*(col + 64*row));\r\nif (this_colour>>24 == 0x0) {\r\nthis_row[47 - col/8] |= 0x80>>(col%8);\r\ncontinue;\r\n}\r\nfor (i = 0; i < colour_count; i++) {\r\nif (colour_set[i] == this_colour) {\r\nif (col % 2)\r\nthis_row[col/2] |= i<<4;\r\nelse\r\nthis_row[col/2] |= i;\r\nbreak;\r\n}\r\n}\r\n}\r\nmemcpy_toio(pixels_prev->kmap.virtual + row*48, &this_row[0], 48);\r\n}\r\nif (pixels_prev == pixels_1)\r\ngpu_addr = mdev->cursor.pixels_1_gpu_addr;\r\nelse\r\ngpu_addr = mdev->cursor.pixels_2_gpu_addr;\r\nWREG_DAC(MGA1064_CURSOR_BASE_ADR_LOW, (u8)((gpu_addr>>10) & 0xff));\r\nWREG_DAC(MGA1064_CURSOR_BASE_ADR_HI, (u8)((gpu_addr>>18) & 0x3f));\r\nWREG_DAC(MGA1064_CURSOR_CTL, 4);\r\nif (mdev->cursor.pixels_1 == mdev->cursor.pixels_prev) {\r\nmdev->cursor.pixels_prev = mdev->cursor.pixels_2;\r\nmdev->cursor.pixels_current = mdev->cursor.pixels_1;\r\n} else if (mdev->cursor.pixels_1 == mdev->cursor.pixels_current) {\r\nmdev->cursor.pixels_prev = mdev->cursor.pixels_1;\r\nmdev->cursor.pixels_current = mdev->cursor.pixels_2;\r\n} else {\r\nBUG();\r\n}\r\nret = 0;\r\nttm_bo_kunmap(&pixels_prev->kmap);\r\nout3:\r\nttm_bo_kunmap(&bo->kmap);\r\nout2:\r\nmgag200_bo_unreserve(bo);\r\nout1:\r\nif (ret)\r\nmga_hide_cursor(mdev);\r\nmgag200_bo_unreserve(pixels_1);\r\nmgag200_bo_unreserve(pixels_2);\r\nreturn ret;\r\n}\r\nint mga_crtc_cursor_move(struct drm_crtc *crtc, int x, int y)\r\n{\r\nstruct mga_device *mdev = (struct mga_device *)crtc->dev->dev_private;\r\nx += 64;\r\ny += 64;\r\nBUG_ON(x <= 0);\r\nBUG_ON(y <= 0);\r\nBUG_ON(x & ~0xffff);\r\nBUG_ON(y & ~0xffff);\r\nWREG8(MGA_CURPOSXL, x & 0xff);\r\nWREG8(MGA_CURPOSXH, (x>>8) & 0xff);\r\nWREG8(MGA_CURPOSYL, y & 0xff);\r\nWREG8(MGA_CURPOSYH, (y>>8) & 0xff);\r\nreturn 0;\r\n}
