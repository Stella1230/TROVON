static int alias_lookup_cb(const char *k, const char *v,\r\nvoid *cb __maybe_unused)\r\n{\r\nif (!prefixcmp(k, "alias.") && !strcmp(k+6, alias_key)) {\r\nif (!v)\r\nreturn config_error_nonbool(k);\r\nalias_val = strdup(v);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nchar *alias_lookup(const char *alias)\r\n{\r\nalias_key = alias;\r\nalias_val = NULL;\r\nperf_config(alias_lookup_cb, NULL);\r\nreturn alias_val;\r\n}\r\nint split_cmdline(char *cmdline, const char ***argv)\r\n{\r\nint src, dst, count = 0, size = 16;\r\nchar quoted = 0;\r\n*argv = malloc(sizeof(char*) * size);\r\n(*argv)[count++] = cmdline;\r\nfor (src = dst = 0; cmdline[src];) {\r\nchar c = cmdline[src];\r\nif (!quoted && isspace(c)) {\r\ncmdline[dst++] = 0;\r\nwhile (cmdline[++src]\r\n&& isspace(cmdline[src]))\r\n;\r\nif (count >= size) {\r\nsize += 16;\r\n*argv = realloc(*argv, sizeof(char*) * size);\r\n}\r\n(*argv)[count++] = cmdline + dst;\r\n} else if (!quoted && (c == '\'' || c == '"')) {\r\nquoted = c;\r\nsrc++;\r\n} else if (c == quoted) {\r\nquoted = 0;\r\nsrc++;\r\n} else {\r\nif (c == '\\' && quoted != '\'') {\r\nsrc++;\r\nc = cmdline[src];\r\nif (!c) {\r\nfree(*argv);\r\n*argv = NULL;\r\nreturn error("cmdline ends with \\");\r\n}\r\n}\r\ncmdline[dst++] = c;\r\nsrc++;\r\n}\r\n}\r\ncmdline[dst] = 0;\r\nif (quoted) {\r\nfree(*argv);\r\n*argv = NULL;\r\nreturn error("unclosed quote");\r\n}\r\nreturn count;\r\n}
