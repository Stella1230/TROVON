uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,\r\nuint32_t max_formats, enum omap_color_mode supported_modes)\r\n{\r\nuint32_t nformats = 0;\r\nint i = 0;\r\nfor (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++)\r\nif (formats[i].dss_format & supported_modes)\r\npixel_formats[nformats++] = formats[i].pixel_format;\r\nreturn nformats;\r\n}\r\nstatic int omap_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nreturn drm_gem_handle_create(file_priv,\r\nomap_fb->planes[0].bo, handle);\r\n}\r\nstatic void omap_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = drm_format_num_planes(fb->pixel_format);\r\nDBG("destroy: FB ID: %d (%p)", fb->base.id, fb);\r\ndrm_framebuffer_cleanup(fb);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nif (plane->bo)\r\ndrm_gem_object_unreference_unlocked(plane->bo);\r\n}\r\nkfree(omap_fb);\r\n}\r\nstatic int omap_framebuffer_dirty(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv, unsigned flags, unsigned color,\r\nstruct drm_clip_rect *clips, unsigned num_clips)\r\n{\r\nint i;\r\nfor (i = 0; i < num_clips; i++) {\r\nomap_framebuffer_flush(fb, clips[i].x1, clips[i].y1,\r\nclips[i].x2 - clips[i].x1,\r\nclips[i].y2 - clips[i].y1);\r\n}\r\nreturn 0;\r\n}\r\nstatic uint32_t get_linear_addr(struct plane *plane,\r\nconst struct format *format, int n, int x, int y)\r\n{\r\nuint32_t offset;\r\noffset = plane->offset +\r\n(x * format->planes[n].stride_bpp) +\r\n(y * plane->pitch / format->planes[n].sub_y);\r\nreturn plane->paddr + offset;\r\n}\r\nvoid omap_framebuffer_update_scanout(struct drm_framebuffer *fb,\r\nstruct omap_drm_window *win, struct omap_overlay_info *info)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nconst struct format *format = omap_fb->format;\r\nstruct plane *plane = &omap_fb->planes[0];\r\nuint32_t x, y, orient = 0;\r\ninfo->color_mode = format->dss_format;\r\ninfo->pos_x = win->crtc_x;\r\ninfo->pos_y = win->crtc_y;\r\ninfo->out_width = win->crtc_w;\r\ninfo->out_height = win->crtc_h;\r\ninfo->width = win->src_w;\r\ninfo->height = win->src_h;\r\nx = win->src_x;\r\ny = win->src_y;\r\nif (omap_gem_flags(plane->bo) & OMAP_BO_TILED) {\r\nuint32_t w = win->src_w;\r\nuint32_t h = win->src_h;\r\nswitch (win->rotation & 0xf) {\r\ndefault:\r\ndev_err(fb->dev->dev, "invalid rotation: %02x",\r\n(uint32_t)win->rotation);\r\ncase 0:\r\ncase BIT(DRM_ROTATE_0):\r\norient = 0;\r\nbreak;\r\ncase BIT(DRM_ROTATE_90):\r\norient = MASK_XY_FLIP | MASK_X_INVERT;\r\nbreak;\r\ncase BIT(DRM_ROTATE_180):\r\norient = MASK_X_INVERT | MASK_Y_INVERT;\r\nbreak;\r\ncase BIT(DRM_ROTATE_270):\r\norient = MASK_XY_FLIP | MASK_Y_INVERT;\r\nbreak;\r\n}\r\nif (win->rotation & BIT(DRM_REFLECT_X))\r\norient ^= MASK_X_INVERT;\r\nif (win->rotation & BIT(DRM_REFLECT_Y))\r\norient ^= MASK_Y_INVERT;\r\nif (orient & MASK_XY_FLIP)\r\nswap(w, h);\r\nif (orient & MASK_Y_INVERT)\r\ny += h - 1;\r\nif (orient & MASK_X_INVERT)\r\nx += w - 1;\r\nomap_gem_rotated_paddr(plane->bo, orient, x, y, &info->paddr);\r\ninfo->rotation_type = OMAP_DSS_ROT_TILER;\r\ninfo->screen_width = omap_gem_tiled_stride(plane->bo, orient);\r\n} else {\r\ninfo->paddr = get_linear_addr(plane, format, 0, x, y);\r\ninfo->rotation_type = OMAP_DSS_ROT_DMA;\r\ninfo->screen_width = plane->pitch;\r\n}\r\ninfo->screen_width /= format->planes[0].stride_bpp;\r\nif (format->dss_format == OMAP_DSS_COLOR_NV12) {\r\nplane = &omap_fb->planes[1];\r\nif (info->rotation_type == OMAP_DSS_ROT_TILER) {\r\nWARN_ON(!(omap_gem_flags(plane->bo) & OMAP_BO_TILED));\r\nomap_gem_rotated_paddr(plane->bo, orient,\r\nx/2, y/2, &info->p_uv_addr);\r\n} else {\r\ninfo->p_uv_addr = get_linear_addr(plane, format, 1, x, y);\r\n}\r\n} else {\r\ninfo->p_uv_addr = 0;\r\n}\r\n}\r\nint omap_framebuffer_pin(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint ret, i, n = drm_format_num_planes(fb->pixel_format);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nret = omap_gem_get_paddr(plane->bo, &plane->paddr, true);\r\nif (ret)\r\ngoto fail;\r\nomap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);\r\n}\r\nreturn 0;\r\nfail:\r\nfor (i--; i >= 0; i--) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nomap_gem_put_paddr(plane->bo);\r\nplane->paddr = 0;\r\n}\r\nreturn ret;\r\n}\r\nint omap_framebuffer_unpin(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint ret, i, n = drm_format_num_planes(fb->pixel_format);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nret = omap_gem_put_paddr(plane->bo);\r\nif (ret)\r\ngoto fail;\r\nplane->paddr = 0;\r\n}\r\nreturn 0;\r\nfail:\r\nreturn ret;\r\n}\r\nstruct drm_gem_object *omap_framebuffer_bo(struct drm_framebuffer *fb, int p)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nif (p >= drm_format_num_planes(fb->pixel_format))\r\nreturn NULL;\r\nreturn omap_fb->planes[p].bo;\r\n}\r\nstruct drm_connector *omap_framebuffer_get_next_connector(\r\nstruct drm_framebuffer *fb, struct drm_connector *from)\r\n{\r\nstruct drm_device *dev = fb->dev;\r\nstruct list_head *connector_list = &dev->mode_config.connector_list;\r\nstruct drm_connector *connector = from;\r\nif (!from)\r\nreturn list_first_entry(connector_list, typeof(*from), head);\r\nlist_for_each_entry_from(connector, connector_list, head) {\r\nif (connector != from) {\r\nstruct drm_encoder *encoder = connector->encoder;\r\nstruct drm_crtc *crtc = encoder ? encoder->crtc : NULL;\r\nif (crtc && crtc->fb == fb)\r\nreturn connector;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid omap_framebuffer_flush(struct drm_framebuffer *fb,\r\nint x, int y, int w, int h)\r\n{\r\nstruct drm_connector *connector = NULL;\r\nVERB("flush: %d,%d %dx%d, fb=%p", x, y, w, h, fb);\r\nwhile ((connector = omap_framebuffer_get_next_connector(fb, connector))) {\r\nif (connector->encoder && connector->encoder->crtc) {\r\nstruct drm_crtc *crtc = connector->encoder->crtc;\r\nint cx = max(0, x - crtc->x);\r\nint cy = max(0, y - crtc->y);\r\nint cw = w + (x - crtc->x) - cx;\r\nint ch = h + (y - crtc->y) - cy;\r\nomap_connector_flush(connector, cx, cy, cw, ch);\r\n}\r\n}\r\n}\r\nvoid omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = drm_format_num_planes(fb->pixel_format);\r\nseq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,\r\n(char *)&fb->pixel_format);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nseq_printf(m, " %d: offset=%d pitch=%d, obj: ",\r\ni, plane->offset, plane->pitch);\r\nomap_gem_describe(plane->bo, m);\r\n}\r\n}\r\nstruct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file, struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *bos[4];\r\nstruct drm_framebuffer *fb;\r\nint ret;\r\nret = objects_lookup(dev, file, mode_cmd->pixel_format,\r\nbos, mode_cmd->handles);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nfb = omap_framebuffer_init(dev, mode_cmd, bos);\r\nif (IS_ERR(fb)) {\r\nint i, n = drm_format_num_planes(mode_cmd->pixel_format);\r\nfor (i = 0; i < n; i++)\r\ndrm_gem_object_unreference_unlocked(bos[i]);\r\nreturn fb;\r\n}\r\nreturn fb;\r\n}\r\nstruct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,\r\nstruct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)\r\n{\r\nstruct omap_framebuffer *omap_fb;\r\nstruct drm_framebuffer *fb = NULL;\r\nconst struct format *format = NULL;\r\nint ret, i, n = drm_format_num_planes(mode_cmd->pixel_format);\r\nDBG("create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)",\r\ndev, mode_cmd, mode_cmd->width, mode_cmd->height,\r\n(char *)&mode_cmd->pixel_format);\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (formats[i].pixel_format == mode_cmd->pixel_format) {\r\nformat = &formats[i];\r\nbreak;\r\n}\r\n}\r\nif (!format) {\r\ndev_err(dev->dev, "unsupported pixel format: %4.4s\n",\r\n(char *)&mode_cmd->pixel_format);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nomap_fb = kzalloc(sizeof(*omap_fb), GFP_KERNEL);\r\nif (!omap_fb) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfb = &omap_fb->base;\r\nomap_fb->format = format;\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nint size, pitch = mode_cmd->pitches[i];\r\nif (pitch < (mode_cmd->width * format->planes[i].stride_bpp)) {\r\ndev_err(dev->dev, "provided buffer pitch is too small! %d < %d\n",\r\npitch, mode_cmd->width * format->planes[i].stride_bpp);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nsize = pitch * mode_cmd->height / format->planes[i].sub_y;\r\nif (size > (omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i])) {\r\ndev_err(dev->dev, "provided buffer object is too small! %d < %d\n",\r\nbos[i]->size - mode_cmd->offsets[i], size);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nplane->bo = bos[i];\r\nplane->offset = mode_cmd->offsets[i];\r\nplane->pitch = pitch;\r\nplane->paddr = 0;\r\n}\r\ndrm_helper_mode_fill_fb_struct(fb, mode_cmd);\r\nret = drm_framebuffer_init(dev, fb, &omap_framebuffer_funcs);\r\nif (ret) {\r\ndev_err(dev->dev, "framebuffer init failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nDBG("create: FB ID: %d (%p)", fb->base.id, fb);\r\nreturn fb;\r\nfail:\r\nif (fb)\r\nomap_framebuffer_destroy(fb);\r\nreturn ERR_PTR(ret);\r\n}
