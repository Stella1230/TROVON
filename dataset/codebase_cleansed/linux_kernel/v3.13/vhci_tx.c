static void setup_cmd_submit_pdu(struct usbip_header *pdup, struct urb *urb)\r\n{\r\nstruct vhci_priv *priv = ((struct vhci_priv *)urb->hcpriv);\r\nstruct vhci_device *vdev = priv->vdev;\r\nusbip_dbg_vhci_tx("URB, local devnum %u, remote devid %u\n",\r\nusb_pipedevice(urb->pipe), vdev->devid);\r\npdup->base.command = USBIP_CMD_SUBMIT;\r\npdup->base.seqnum = priv->seqnum;\r\npdup->base.devid = vdev->devid;\r\npdup->base.direction = usb_pipein(urb->pipe) ?\r\nUSBIP_DIR_IN : USBIP_DIR_OUT;\r\npdup->base.ep = usb_pipeendpoint(urb->pipe);\r\nusbip_pack_pdu(pdup, urb, USBIP_CMD_SUBMIT, 1);\r\nif (urb->setup_packet)\r\nmemcpy(pdup->u.cmd_submit.setup, urb->setup_packet, 8);\r\n}\r\nstatic struct vhci_priv *dequeue_from_priv_tx(struct vhci_device *vdev)\r\n{\r\nstruct vhci_priv *priv, *tmp;\r\nspin_lock(&vdev->priv_lock);\r\nlist_for_each_entry_safe(priv, tmp, &vdev->priv_tx, list) {\r\nlist_move_tail(&priv->list, &vdev->priv_rx);\r\nspin_unlock(&vdev->priv_lock);\r\nreturn priv;\r\n}\r\nspin_unlock(&vdev->priv_lock);\r\nreturn NULL;\r\n}\r\nstatic int vhci_send_cmd_submit(struct vhci_device *vdev)\r\n{\r\nstruct vhci_priv *priv = NULL;\r\nstruct msghdr msg;\r\nstruct kvec iov[3];\r\nsize_t txsize;\r\nsize_t total_size = 0;\r\nwhile ((priv = dequeue_from_priv_tx(vdev)) != NULL) {\r\nint ret;\r\nstruct urb *urb = priv->urb;\r\nstruct usbip_header pdu_header;\r\nstruct usbip_iso_packet_descriptor *iso_buffer = NULL;\r\ntxsize = 0;\r\nmemset(&pdu_header, 0, sizeof(pdu_header));\r\nmemset(&msg, 0, sizeof(msg));\r\nmemset(&iov, 0, sizeof(iov));\r\nusbip_dbg_vhci_tx("setup txdata urb %p\n", urb);\r\nsetup_cmd_submit_pdu(&pdu_header, urb);\r\nusbip_header_correct_endian(&pdu_header, 1);\r\niov[0].iov_base = &pdu_header;\r\niov[0].iov_len = sizeof(pdu_header);\r\ntxsize += sizeof(pdu_header);\r\nif (!usb_pipein(urb->pipe) && urb->transfer_buffer_length > 0) {\r\niov[1].iov_base = urb->transfer_buffer;\r\niov[1].iov_len = urb->transfer_buffer_length;\r\ntxsize += urb->transfer_buffer_length;\r\n}\r\nif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\r\nssize_t len = 0;\r\niso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\r\nif (!iso_buffer) {\r\nusbip_event_add(&vdev->ud,\r\nSDEV_EVENT_ERROR_MALLOC);\r\nreturn -1;\r\n}\r\niov[2].iov_base = iso_buffer;\r\niov[2].iov_len = len;\r\ntxsize += len;\r\n}\r\nret = kernel_sendmsg(vdev->ud.tcp_socket, &msg, iov, 3, txsize);\r\nif (ret != txsize) {\r\npr_err("sendmsg failed!, ret=%d for %zd\n", ret,\r\ntxsize);\r\nkfree(iso_buffer);\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_TCP);\r\nreturn -1;\r\n}\r\nkfree(iso_buffer);\r\nusbip_dbg_vhci_tx("send txdata\n");\r\ntotal_size += txsize;\r\n}\r\nreturn total_size;\r\n}\r\nstatic struct vhci_unlink *dequeue_from_unlink_tx(struct vhci_device *vdev)\r\n{\r\nstruct vhci_unlink *unlink, *tmp;\r\nspin_lock(&vdev->priv_lock);\r\nlist_for_each_entry_safe(unlink, tmp, &vdev->unlink_tx, list) {\r\nlist_move_tail(&unlink->list, &vdev->unlink_rx);\r\nspin_unlock(&vdev->priv_lock);\r\nreturn unlink;\r\n}\r\nspin_unlock(&vdev->priv_lock);\r\nreturn NULL;\r\n}\r\nstatic int vhci_send_cmd_unlink(struct vhci_device *vdev)\r\n{\r\nstruct vhci_unlink *unlink = NULL;\r\nstruct msghdr msg;\r\nstruct kvec iov[3];\r\nsize_t txsize;\r\nsize_t total_size = 0;\r\nwhile ((unlink = dequeue_from_unlink_tx(vdev)) != NULL) {\r\nint ret;\r\nstruct usbip_header pdu_header;\r\ntxsize = 0;\r\nmemset(&pdu_header, 0, sizeof(pdu_header));\r\nmemset(&msg, 0, sizeof(msg));\r\nmemset(&iov, 0, sizeof(iov));\r\nusbip_dbg_vhci_tx("setup cmd unlink, %lu\n", unlink->seqnum);\r\npdu_header.base.command = USBIP_CMD_UNLINK;\r\npdu_header.base.seqnum = unlink->seqnum;\r\npdu_header.base.devid = vdev->devid;\r\npdu_header.base.ep = 0;\r\npdu_header.u.cmd_unlink.seqnum = unlink->unlink_seqnum;\r\nusbip_header_correct_endian(&pdu_header, 1);\r\niov[0].iov_base = &pdu_header;\r\niov[0].iov_len = sizeof(pdu_header);\r\ntxsize += sizeof(pdu_header);\r\nret = kernel_sendmsg(vdev->ud.tcp_socket, &msg, iov, 1, txsize);\r\nif (ret != txsize) {\r\npr_err("sendmsg failed!, ret=%d for %zd\n", ret,\r\ntxsize);\r\nusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_TCP);\r\nreturn -1;\r\n}\r\nusbip_dbg_vhci_tx("send txdata\n");\r\ntotal_size += txsize;\r\n}\r\nreturn total_size;\r\n}\r\nint vhci_tx_loop(void *data)\r\n{\r\nstruct usbip_device *ud = data;\r\nstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\r\nwhile (!kthread_should_stop()) {\r\nif (vhci_send_cmd_submit(vdev) < 0)\r\nbreak;\r\nif (vhci_send_cmd_unlink(vdev) < 0)\r\nbreak;\r\nwait_event_interruptible(vdev->waitq_tx,\r\n(!list_empty(&vdev->priv_tx) ||\r\n!list_empty(&vdev->unlink_tx) ||\r\nkthread_should_stop()));\r\nusbip_dbg_vhci_tx("pending urbs ?, now wake up\n");\r\n}\r\nreturn 0;\r\n}
