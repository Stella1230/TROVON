static void ux500_dma_callback(void *private_data)\r\n{\r\nstruct dma_channel *channel = private_data;\r\nstruct ux500_dma_channel *ux500_channel = channel->private_data;\r\nstruct musb_hw_ep *hw_ep = ux500_channel->hw_ep;\r\nstruct musb *musb = hw_ep->musb;\r\nunsigned long flags;\r\ndev_dbg(musb->controller, "DMA rx transfer done on hw_ep=%d\n",\r\nhw_ep->epnum);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nux500_channel->channel.actual_len = ux500_channel->cur_len;\r\nux500_channel->channel.status = MUSB_DMA_STATUS_FREE;\r\nmusb_dma_completion(musb, hw_ep->epnum, ux500_channel->is_tx);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic bool ux500_configure_channel(struct dma_channel *channel,\r\nu16 packet_sz, u8 mode,\r\ndma_addr_t dma_addr, u32 len)\r\n{\r\nstruct ux500_dma_channel *ux500_channel = channel->private_data;\r\nstruct musb_hw_ep *hw_ep = ux500_channel->hw_ep;\r\nstruct dma_chan *dma_chan = ux500_channel->dma_chan;\r\nstruct dma_async_tx_descriptor *dma_desc;\r\nenum dma_transfer_direction direction;\r\nstruct scatterlist sg;\r\nstruct dma_slave_config slave_conf;\r\nenum dma_slave_buswidth addr_width;\r\ndma_addr_t usb_fifo_addr = (MUSB_FIFO_OFFSET(hw_ep->epnum) +\r\nux500_channel->controller->phy_base);\r\nstruct musb *musb = ux500_channel->controller->private_data;\r\ndev_dbg(musb->controller,\r\n"packet_sz=%d, mode=%d, dma_addr=0x%llu, len=%d is_tx=%d\n",\r\npacket_sz, mode, (unsigned long long) dma_addr,\r\nlen, ux500_channel->is_tx);\r\nux500_channel->cur_len = len;\r\nsg_init_table(&sg, 1);\r\nsg_set_page(&sg, pfn_to_page(PFN_DOWN(dma_addr)), len,\r\noffset_in_page(dma_addr));\r\nsg_dma_address(&sg) = dma_addr;\r\nsg_dma_len(&sg) = len;\r\ndirection = ux500_channel->is_tx ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM;\r\naddr_width = (len & 0x3) ? DMA_SLAVE_BUSWIDTH_1_BYTE :\r\nDMA_SLAVE_BUSWIDTH_4_BYTES;\r\nslave_conf.direction = direction;\r\nslave_conf.src_addr = usb_fifo_addr;\r\nslave_conf.src_addr_width = addr_width;\r\nslave_conf.src_maxburst = 16;\r\nslave_conf.dst_addr = usb_fifo_addr;\r\nslave_conf.dst_addr_width = addr_width;\r\nslave_conf.dst_maxburst = 16;\r\nslave_conf.device_fc = false;\r\ndma_chan->device->device_control(dma_chan, DMA_SLAVE_CONFIG,\r\n(unsigned long) &slave_conf);\r\ndma_desc = dmaengine_prep_slave_sg(dma_chan, &sg, 1, direction,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!dma_desc)\r\nreturn false;\r\ndma_desc->callback = ux500_dma_callback;\r\ndma_desc->callback_param = channel;\r\nux500_channel->cookie = dma_desc->tx_submit(dma_desc);\r\ndma_async_issue_pending(dma_chan);\r\nreturn true;\r\n}\r\nstatic struct dma_channel *ux500_dma_channel_allocate(struct dma_controller *c,\r\nstruct musb_hw_ep *hw_ep, u8 is_tx)\r\n{\r\nstruct ux500_dma_controller *controller = container_of(c,\r\nstruct ux500_dma_controller, controller);\r\nstruct ux500_dma_channel *ux500_channel = NULL;\r\nstruct musb *musb = controller->private_data;\r\nu8 ch_num = hw_ep->epnum - 1;\r\nif (ch_num > 7)\r\nch_num -= 8;\r\nif (ch_num >= UX500_MUSB_DMA_NUM_RX_TX_CHANNELS)\r\nreturn NULL;\r\nux500_channel = is_tx ? &(controller->tx_channel[ch_num]) :\r\n&(controller->rx_channel[ch_num]) ;\r\nif (ux500_channel->is_allocated)\r\nreturn NULL;\r\nux500_channel->hw_ep = hw_ep;\r\nux500_channel->is_allocated = 1;\r\ndev_dbg(musb->controller, "hw_ep=%d, is_tx=0x%x, channel=%d\n",\r\nhw_ep->epnum, is_tx, ch_num);\r\nreturn &(ux500_channel->channel);\r\n}\r\nstatic void ux500_dma_channel_release(struct dma_channel *channel)\r\n{\r\nstruct ux500_dma_channel *ux500_channel = channel->private_data;\r\nstruct musb *musb = ux500_channel->controller->private_data;\r\ndev_dbg(musb->controller, "channel=%d\n", ux500_channel->ch_num);\r\nif (ux500_channel->is_allocated) {\r\nux500_channel->is_allocated = 0;\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nchannel->actual_len = 0;\r\n}\r\n}\r\nstatic int ux500_dma_is_compatible(struct dma_channel *channel,\r\nu16 maxpacket, void *buf, u32 length)\r\n{\r\nif ((maxpacket & 0x3) ||\r\n((unsigned long int) buf & 0x3) ||\r\n(length < 512) ||\r\n(length & 0x3))\r\nreturn false;\r\nelse\r\nreturn true;\r\n}\r\nstatic int ux500_dma_channel_program(struct dma_channel *channel,\r\nu16 packet_sz, u8 mode,\r\ndma_addr_t dma_addr, u32 len)\r\n{\r\nint ret;\r\nBUG_ON(channel->status == MUSB_DMA_STATUS_UNKNOWN ||\r\nchannel->status == MUSB_DMA_STATUS_BUSY);\r\nif (!ux500_dma_is_compatible(channel, packet_sz, (void *)dma_addr, len))\r\nreturn false;\r\nchannel->status = MUSB_DMA_STATUS_BUSY;\r\nchannel->actual_len = 0;\r\nret = ux500_configure_channel(channel, packet_sz, mode, dma_addr, len);\r\nif (!ret)\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\nreturn ret;\r\n}\r\nstatic int ux500_dma_channel_abort(struct dma_channel *channel)\r\n{\r\nstruct ux500_dma_channel *ux500_channel = channel->private_data;\r\nstruct ux500_dma_controller *controller = ux500_channel->controller;\r\nstruct musb *musb = controller->private_data;\r\nvoid __iomem *epio = musb->endpoints[ux500_channel->hw_ep->epnum].regs;\r\nu16 csr;\r\ndev_dbg(musb->controller, "channel=%d, is_tx=%d\n",\r\nux500_channel->ch_num, ux500_channel->is_tx);\r\nif (channel->status == MUSB_DMA_STATUS_BUSY) {\r\nif (ux500_channel->is_tx) {\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\ncsr &= ~(MUSB_TXCSR_AUTOSET |\r\nMUSB_TXCSR_DMAENAB |\r\nMUSB_TXCSR_DMAMODE);\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n} else {\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ncsr &= ~(MUSB_RXCSR_AUTOCLEAR |\r\nMUSB_RXCSR_DMAENAB |\r\nMUSB_RXCSR_DMAMODE);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\nux500_channel->dma_chan->device->\r\ndevice_control(ux500_channel->dma_chan,\r\nDMA_TERMINATE_ALL, 0);\r\nchannel->status = MUSB_DMA_STATUS_FREE;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ux500_dma_controller_stop(struct ux500_dma_controller *controller)\r\n{\r\nstruct ux500_dma_channel *ux500_channel;\r\nstruct dma_channel *channel;\r\nu8 ch_num;\r\nfor (ch_num = 0; ch_num < UX500_MUSB_DMA_NUM_RX_TX_CHANNELS; ch_num++) {\r\nchannel = &controller->rx_channel[ch_num].channel;\r\nux500_channel = channel->private_data;\r\nux500_dma_channel_release(channel);\r\nif (ux500_channel->dma_chan)\r\ndma_release_channel(ux500_channel->dma_chan);\r\n}\r\nfor (ch_num = 0; ch_num < UX500_MUSB_DMA_NUM_RX_TX_CHANNELS; ch_num++) {\r\nchannel = &controller->tx_channel[ch_num].channel;\r\nux500_channel = channel->private_data;\r\nux500_dma_channel_release(channel);\r\nif (ux500_channel->dma_chan)\r\ndma_release_channel(ux500_channel->dma_chan);\r\n}\r\n}\r\nstatic int ux500_dma_controller_start(struct ux500_dma_controller *controller)\r\n{\r\nstruct ux500_dma_channel *ux500_channel = NULL;\r\nstruct musb *musb = controller->private_data;\r\nstruct device *dev = musb->controller;\r\nstruct musb_hdrc_platform_data *plat = dev_get_platdata(dev);\r\nstruct ux500_musb_board_data *data;\r\nstruct dma_channel *dma_channel = NULL;\r\nchar **chan_names;\r\nu32 ch_num;\r\nu8 dir;\r\nu8 is_tx = 0;\r\nvoid **param_array;\r\nstruct ux500_dma_channel *channel_array;\r\ndma_cap_mask_t mask;\r\nif (!plat) {\r\ndev_err(musb->controller, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\ndata = plat->board_data;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nchannel_array = controller->rx_channel;\r\nparam_array = data ? data->dma_rx_param_array : NULL;\r\nchan_names = (char **)iep_chan_names;\r\nfor (dir = 0; dir < 2; dir++) {\r\nfor (ch_num = 0;\r\nch_num < UX500_MUSB_DMA_NUM_RX_TX_CHANNELS;\r\nch_num++) {\r\nux500_channel = &channel_array[ch_num];\r\nux500_channel->controller = controller;\r\nux500_channel->ch_num = ch_num;\r\nux500_channel->is_tx = is_tx;\r\ndma_channel = &(ux500_channel->channel);\r\ndma_channel->private_data = ux500_channel;\r\ndma_channel->status = MUSB_DMA_STATUS_FREE;\r\ndma_channel->max_len = SZ_16M;\r\nux500_channel->dma_chan =\r\ndma_request_slave_channel(dev, chan_names[ch_num]);\r\nif (!ux500_channel->dma_chan)\r\nux500_channel->dma_chan =\r\ndma_request_channel(mask,\r\ndata ?\r\ndata->dma_filter :\r\nNULL,\r\nparam_array[ch_num]);\r\nif (!ux500_channel->dma_chan) {\r\nERR("Dma pipe allocation error dir=%d ch=%d\n",\r\ndir, ch_num);\r\nux500_dma_controller_stop(controller);\r\nreturn -EBUSY;\r\n}\r\n}\r\nchannel_array = controller->tx_channel;\r\nparam_array = data ? data->dma_tx_param_array : NULL;\r\nchan_names = (char **)oep_chan_names;\r\nis_tx = 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid dma_controller_destroy(struct dma_controller *c)\r\n{\r\nstruct ux500_dma_controller *controller = container_of(c,\r\nstruct ux500_dma_controller, controller);\r\nux500_dma_controller_stop(controller);\r\nkfree(controller);\r\n}\r\nstruct dma_controller *dma_controller_create(struct musb *musb,\r\nvoid __iomem *base)\r\n{\r\nstruct ux500_dma_controller *controller;\r\nstruct platform_device *pdev = to_platform_device(musb->controller);\r\nstruct resource *iomem;\r\nint ret;\r\ncontroller = kzalloc(sizeof(*controller), GFP_KERNEL);\r\nif (!controller)\r\ngoto kzalloc_fail;\r\ncontroller->private_data = musb;\r\niomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!iomem) {\r\ndev_err(musb->controller, "no memory resource defined\n");\r\ngoto plat_get_fail;\r\n}\r\ncontroller->phy_base = (dma_addr_t) iomem->start;\r\ncontroller->controller.channel_alloc = ux500_dma_channel_allocate;\r\ncontroller->controller.channel_release = ux500_dma_channel_release;\r\ncontroller->controller.channel_program = ux500_dma_channel_program;\r\ncontroller->controller.channel_abort = ux500_dma_channel_abort;\r\ncontroller->controller.is_compatible = ux500_dma_is_compatible;\r\nret = ux500_dma_controller_start(controller);\r\nif (ret)\r\ngoto plat_get_fail;\r\nreturn &controller->controller;\r\nplat_get_fail:\r\nkfree(controller);\r\nkzalloc_fail:\r\nreturn NULL;\r\n}
