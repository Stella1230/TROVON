static void rt2500pci_bbp_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, const u8 value)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field32(&reg, BBPCSR_VALUE, value);\r\nrt2x00_set_field32(&reg, BBPCSR_REGNUM, word);\r\nrt2x00_set_field32(&reg, BBPCSR_BUSY, 1);\r\nrt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 1);\r\nrt2x00mmio_register_write(rt2x00dev, BBPCSR, reg);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt2500pci_bbp_read(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, u8 *value)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_BBP(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field32(&reg, BBPCSR_REGNUM, word);\r\nrt2x00_set_field32(&reg, BBPCSR_BUSY, 1);\r\nrt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 0);\r\nrt2x00mmio_register_write(rt2x00dev, BBPCSR, reg);\r\nWAIT_FOR_BBP(rt2x00dev, &reg);\r\n}\r\n*value = rt2x00_get_field32(reg, BBPCSR_VALUE);\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt2500pci_rf_write(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int word, const u32 value)\r\n{\r\nu32 reg;\r\nmutex_lock(&rt2x00dev->csr_mutex);\r\nif (WAIT_FOR_RF(rt2x00dev, &reg)) {\r\nreg = 0;\r\nrt2x00_set_field32(&reg, RFCSR_VALUE, value);\r\nrt2x00_set_field32(&reg, RFCSR_NUMBER_OF_BITS, 20);\r\nrt2x00_set_field32(&reg, RFCSR_IF_SELECT, 0);\r\nrt2x00_set_field32(&reg, RFCSR_BUSY, 1);\r\nrt2x00mmio_register_write(rt2x00dev, RFCSR, reg);\r\nrt2x00_rf_write(rt2x00dev, word, value);\r\n}\r\nmutex_unlock(&rt2x00dev->csr_mutex);\r\n}\r\nstatic void rt2500pci_eepromregister_read(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = eeprom->data;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, CSR21, &reg);\r\neeprom->reg_data_in = !!rt2x00_get_field32(reg, CSR21_EEPROM_DATA_IN);\r\neeprom->reg_data_out = !!rt2x00_get_field32(reg, CSR21_EEPROM_DATA_OUT);\r\neeprom->reg_data_clock =\r\n!!rt2x00_get_field32(reg, CSR21_EEPROM_DATA_CLOCK);\r\neeprom->reg_chip_select =\r\n!!rt2x00_get_field32(reg, CSR21_EEPROM_CHIP_SELECT);\r\n}\r\nstatic void rt2500pci_eepromregister_write(struct eeprom_93cx6 *eeprom)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = eeprom->data;\r\nu32 reg = 0;\r\nrt2x00_set_field32(&reg, CSR21_EEPROM_DATA_IN, !!eeprom->reg_data_in);\r\nrt2x00_set_field32(&reg, CSR21_EEPROM_DATA_OUT, !!eeprom->reg_data_out);\r\nrt2x00_set_field32(&reg, CSR21_EEPROM_DATA_CLOCK,\r\n!!eeprom->reg_data_clock);\r\nrt2x00_set_field32(&reg, CSR21_EEPROM_CHIP_SELECT,\r\n!!eeprom->reg_chip_select);\r\nrt2x00mmio_register_write(rt2x00dev, CSR21, reg);\r\n}\r\nstatic int rt2500pci_rfkill_poll(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, GPIOCSR, &reg);\r\nreturn rt2x00_get_field32(reg, GPIOCSR_VAL0);\r\n}\r\nstatic void rt2500pci_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct rt2x00_led *led =\r\ncontainer_of(led_cdev, struct rt2x00_led, led_dev);\r\nunsigned int enabled = brightness != LED_OFF;\r\nu32 reg;\r\nrt2x00mmio_register_read(led->rt2x00dev, LEDCSR, &reg);\r\nif (led->type == LED_TYPE_RADIO || led->type == LED_TYPE_ASSOC)\r\nrt2x00_set_field32(&reg, LEDCSR_LINK, enabled);\r\nelse if (led->type == LED_TYPE_ACTIVITY)\r\nrt2x00_set_field32(&reg, LEDCSR_ACTIVITY, enabled);\r\nrt2x00mmio_register_write(led->rt2x00dev, LEDCSR, reg);\r\n}\r\nstatic int rt2500pci_blink_set(struct led_classdev *led_cdev,\r\nunsigned long *delay_on,\r\nunsigned long *delay_off)\r\n{\r\nstruct rt2x00_led *led =\r\ncontainer_of(led_cdev, struct rt2x00_led, led_dev);\r\nu32 reg;\r\nrt2x00mmio_register_read(led->rt2x00dev, LEDCSR, &reg);\r\nrt2x00_set_field32(&reg, LEDCSR_ON_PERIOD, *delay_on);\r\nrt2x00_set_field32(&reg, LEDCSR_OFF_PERIOD, *delay_off);\r\nrt2x00mmio_register_write(led->rt2x00dev, LEDCSR, reg);\r\nreturn 0;\r\n}\r\nstatic void rt2500pci_init_led(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_led *led,\r\nenum led_type type)\r\n{\r\nled->rt2x00dev = rt2x00dev;\r\nled->type = type;\r\nled->led_dev.brightness_set = rt2500pci_brightness_set;\r\nled->led_dev.blink_set = rt2500pci_blink_set;\r\nled->flags = LED_INITIALIZED;\r\n}\r\nstatic void rt2500pci_config_filter(struct rt2x00_dev *rt2x00dev,\r\nconst unsigned int filter_flags)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, RXCSR0, &reg);\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_CRC,\r\n!(filter_flags & FIF_FCSFAIL));\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_PHYSICAL,\r\n!(filter_flags & FIF_PLCPFAIL));\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_CONTROL,\r\n!(filter_flags & FIF_CONTROL));\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME,\r\n!(filter_flags & FIF_PROMISC_IN_BSS));\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_TODS,\r\n!(filter_flags & FIF_PROMISC_IN_BSS) &&\r\n!rt2x00dev->intf_ap_count);\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_VERSION_ERROR, 1);\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_MCAST,\r\n!(filter_flags & FIF_ALLMULTI));\r\nrt2x00_set_field32(&reg, RXCSR0_DROP_BCAST, 0);\r\nrt2x00mmio_register_write(rt2x00dev, RXCSR0, reg);\r\n}\r\nstatic void rt2500pci_config_intf(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_intf *intf,\r\nstruct rt2x00intf_conf *conf,\r\nconst unsigned int flags)\r\n{\r\nstruct data_queue *queue = rt2x00dev->bcn;\r\nunsigned int bcn_preload;\r\nu32 reg;\r\nif (flags & CONFIG_UPDATE_TYPE) {\r\nbcn_preload = PREAMBLE + GET_DURATION(IEEE80211_HEADER, 20);\r\nrt2x00mmio_register_read(rt2x00dev, BCNCSR1, &reg);\r\nrt2x00_set_field32(&reg, BCNCSR1_PRELOAD, bcn_preload);\r\nrt2x00_set_field32(&reg, BCNCSR1_BEACON_CWMIN, queue->cw_min);\r\nrt2x00mmio_register_write(rt2x00dev, BCNCSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR14, &reg);\r\nrt2x00_set_field32(&reg, CSR14_TSF_SYNC, conf->sync);\r\nrt2x00mmio_register_write(rt2x00dev, CSR14, reg);\r\n}\r\nif (flags & CONFIG_UPDATE_MAC)\r\nrt2x00mmio_register_multiwrite(rt2x00dev, CSR3,\r\nconf->mac, sizeof(conf->mac));\r\nif (flags & CONFIG_UPDATE_BSSID)\r\nrt2x00mmio_register_multiwrite(rt2x00dev, CSR5,\r\nconf->bssid, sizeof(conf->bssid));\r\n}\r\nstatic void rt2500pci_config_erp(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_erp *erp,\r\nu32 changed)\r\n{\r\nint preamble_mask;\r\nu32 reg;\r\nif (changed & BSS_CHANGED_ERP_PREAMBLE) {\r\npreamble_mask = erp->short_preamble << 3;\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR1, &reg);\r\nrt2x00_set_field32(&reg, TXCSR1_ACK_TIMEOUT, 0x162);\r\nrt2x00_set_field32(&reg, TXCSR1_ACK_CONSUME_TIME, 0xa2);\r\nrt2x00_set_field32(&reg, TXCSR1_TSF_OFFSET, IEEE80211_HEADER);\r\nrt2x00_set_field32(&reg, TXCSR1_AUTORESPONDER, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARCSR2, &reg);\r\nrt2x00_set_field32(&reg, ARCSR2_SIGNAL, 0x00);\r\nrt2x00_set_field32(&reg, ARCSR2_SERVICE, 0x04);\r\nrt2x00_set_field32(&reg, ARCSR2_LENGTH,\r\nGET_DURATION(ACK_SIZE, 10));\r\nrt2x00mmio_register_write(rt2x00dev, ARCSR2, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARCSR3, &reg);\r\nrt2x00_set_field32(&reg, ARCSR3_SIGNAL, 0x01 | preamble_mask);\r\nrt2x00_set_field32(&reg, ARCSR3_SERVICE, 0x04);\r\nrt2x00_set_field32(&reg, ARCSR2_LENGTH,\r\nGET_DURATION(ACK_SIZE, 20));\r\nrt2x00mmio_register_write(rt2x00dev, ARCSR3, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARCSR4, &reg);\r\nrt2x00_set_field32(&reg, ARCSR4_SIGNAL, 0x02 | preamble_mask);\r\nrt2x00_set_field32(&reg, ARCSR4_SERVICE, 0x04);\r\nrt2x00_set_field32(&reg, ARCSR2_LENGTH,\r\nGET_DURATION(ACK_SIZE, 55));\r\nrt2x00mmio_register_write(rt2x00dev, ARCSR4, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARCSR5, &reg);\r\nrt2x00_set_field32(&reg, ARCSR5_SIGNAL, 0x03 | preamble_mask);\r\nrt2x00_set_field32(&reg, ARCSR5_SERVICE, 0x84);\r\nrt2x00_set_field32(&reg, ARCSR2_LENGTH,\r\nGET_DURATION(ACK_SIZE, 110));\r\nrt2x00mmio_register_write(rt2x00dev, ARCSR5, reg);\r\n}\r\nif (changed & BSS_CHANGED_BASIC_RATES)\r\nrt2x00mmio_register_write(rt2x00dev, ARCSR1, erp->basic_rates);\r\nif (changed & BSS_CHANGED_ERP_SLOT) {\r\nrt2x00mmio_register_read(rt2x00dev, CSR11, &reg);\r\nrt2x00_set_field32(&reg, CSR11_SLOT_TIME, erp->slot_time);\r\nrt2x00mmio_register_write(rt2x00dev, CSR11, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR18, &reg);\r\nrt2x00_set_field32(&reg, CSR18_SIFS, erp->sifs);\r\nrt2x00_set_field32(&reg, CSR18_PIFS, erp->pifs);\r\nrt2x00mmio_register_write(rt2x00dev, CSR18, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR19, &reg);\r\nrt2x00_set_field32(&reg, CSR19_DIFS, erp->difs);\r\nrt2x00_set_field32(&reg, CSR19_EIFS, erp->eifs);\r\nrt2x00mmio_register_write(rt2x00dev, CSR19, reg);\r\n}\r\nif (changed & BSS_CHANGED_BEACON_INT) {\r\nrt2x00mmio_register_read(rt2x00dev, CSR12, &reg);\r\nrt2x00_set_field32(&reg, CSR12_BEACON_INTERVAL,\r\nerp->beacon_int * 16);\r\nrt2x00_set_field32(&reg, CSR12_CFP_MAX_DURATION,\r\nerp->beacon_int * 16);\r\nrt2x00mmio_register_write(rt2x00dev, CSR12, reg);\r\n}\r\n}\r\nstatic void rt2500pci_config_ant(struct rt2x00_dev *rt2x00dev,\r\nstruct antenna_setup *ant)\r\n{\r\nu32 reg;\r\nu8 r14;\r\nu8 r2;\r\nBUG_ON(ant->rx == ANTENNA_SW_DIVERSITY ||\r\nant->tx == ANTENNA_SW_DIVERSITY);\r\nrt2x00mmio_register_read(rt2x00dev, BBPCSR1, &reg);\r\nrt2500pci_bbp_read(rt2x00dev, 14, &r14);\r\nrt2500pci_bbp_read(rt2x00dev, 2, &r2);\r\nswitch (ant->tx) {\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 0);\r\nrt2x00_set_field32(&reg, BBPCSR1_CCK, 0);\r\nrt2x00_set_field32(&reg, BBPCSR1_OFDM, 0);\r\nbreak;\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 2);\r\nrt2x00_set_field32(&reg, BBPCSR1_CCK, 2);\r\nrt2x00_set_field32(&reg, BBPCSR1_OFDM, 2);\r\nbreak;\r\n}\r\nswitch (ant->rx) {\r\ncase ANTENNA_A:\r\nrt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 0);\r\nbreak;\r\ncase ANTENNA_B:\r\ndefault:\r\nrt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 2);\r\nbreak;\r\n}\r\nif (rt2x00_rf(rt2x00dev, RF2525E) || rt2x00_rf(rt2x00dev, RF5222)) {\r\nrt2x00_set_field8(&r2, BBP_R2_TX_IQ_FLIP, 1);\r\nrt2x00_set_field32(&reg, BBPCSR1_CCK_FLIP, 1);\r\nrt2x00_set_field32(&reg, BBPCSR1_OFDM_FLIP, 1);\r\nif (rt2x00_rf(rt2x00dev, RF2525E))\r\nrt2x00_set_field8(&r14, BBP_R14_RX_IQ_FLIP, 0);\r\n} else {\r\nrt2x00_set_field32(&reg, BBPCSR1_CCK_FLIP, 0);\r\nrt2x00_set_field32(&reg, BBPCSR1_OFDM_FLIP, 0);\r\n}\r\nrt2x00mmio_register_write(rt2x00dev, BBPCSR1, reg);\r\nrt2500pci_bbp_write(rt2x00dev, 14, r14);\r\nrt2500pci_bbp_write(rt2x00dev, 2, r2);\r\n}\r\nstatic void rt2500pci_config_channel(struct rt2x00_dev *rt2x00dev,\r\nstruct rf_channel *rf, const int txpower)\r\n{\r\nu8 r70;\r\nrt2x00_set_field32(&rf->rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\r\nif (!rt2x00_rf(rt2x00dev, RF2523))\r\nrt2x00_set_field32(&rf->rf1, RF1_TUNER, 1);\r\nrt2x00_set_field32(&rf->rf3, RF3_TUNER, 1);\r\nif (rt2x00_rf(rt2x00dev, RF2525)) {\r\nstatic const u32 vals[] = {\r\n0x00080cbe, 0x00080d02, 0x00080d06, 0x00080d0a,\r\n0x00080d0e, 0x00080d12, 0x00080d16, 0x00080d1a,\r\n0x00080d1e, 0x00080d22, 0x00080d26, 0x00080d2a,\r\n0x00080d2e, 0x00080d3a\r\n};\r\nrt2500pci_rf_write(rt2x00dev, 1, rf->rf1);\r\nrt2500pci_rf_write(rt2x00dev, 2, vals[rf->channel - 1]);\r\nrt2500pci_rf_write(rt2x00dev, 3, rf->rf3);\r\nif (rf->rf4)\r\nrt2500pci_rf_write(rt2x00dev, 4, rf->rf4);\r\n}\r\nrt2500pci_rf_write(rt2x00dev, 1, rf->rf1);\r\nrt2500pci_rf_write(rt2x00dev, 2, rf->rf2);\r\nrt2500pci_rf_write(rt2x00dev, 3, rf->rf3);\r\nif (rf->rf4)\r\nrt2500pci_rf_write(rt2x00dev, 4, rf->rf4);\r\nr70 = 0x46;\r\nrt2x00_set_field8(&r70, BBP_R70_JAPAN_FILTER, rf->channel == 14);\r\nrt2500pci_bbp_write(rt2x00dev, 70, r70);\r\nmsleep(1);\r\nif (!rt2x00_rf(rt2x00dev, RF2523)) {\r\nrt2x00_set_field32(&rf->rf1, RF1_TUNER, 0);\r\nrt2500pci_rf_write(rt2x00dev, 1, rf->rf1);\r\n}\r\nrt2x00_set_field32(&rf->rf3, RF3_TUNER, 0);\r\nrt2500pci_rf_write(rt2x00dev, 3, rf->rf3);\r\nrt2x00mmio_register_read(rt2x00dev, CNT0, &rf->rf1);\r\n}\r\nstatic void rt2500pci_config_txpower(struct rt2x00_dev *rt2x00dev,\r\nconst int txpower)\r\n{\r\nu32 rf3;\r\nrt2x00_rf_read(rt2x00dev, 3, &rf3);\r\nrt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));\r\nrt2500pci_rf_write(rt2x00dev, 3, rf3);\r\n}\r\nstatic void rt2500pci_config_retry_limit(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, CSR11, &reg);\r\nrt2x00_set_field32(&reg, CSR11_LONG_RETRY,\r\nlibconf->conf->long_frame_max_tx_count);\r\nrt2x00_set_field32(&reg, CSR11_SHORT_RETRY,\r\nlibconf->conf->short_frame_max_tx_count);\r\nrt2x00mmio_register_write(rt2x00dev, CSR11, reg);\r\n}\r\nstatic void rt2500pci_config_ps(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf)\r\n{\r\nenum dev_state state =\r\n(libconf->conf->flags & IEEE80211_CONF_PS) ?\r\nSTATE_SLEEP : STATE_AWAKE;\r\nu32 reg;\r\nif (state == STATE_SLEEP) {\r\nrt2x00mmio_register_read(rt2x00dev, CSR20, &reg);\r\nrt2x00_set_field32(&reg, CSR20_DELAY_AFTER_TBCN,\r\n(rt2x00dev->beacon_int - 20) * 16);\r\nrt2x00_set_field32(&reg, CSR20_TBCN_BEFORE_WAKEUP,\r\nlibconf->conf->listen_interval - 1);\r\nrt2x00_set_field32(&reg, CSR20_AUTOWAKE, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR20, reg);\r\nrt2x00_set_field32(&reg, CSR20_AUTOWAKE, 1);\r\nrt2x00mmio_register_write(rt2x00dev, CSR20, reg);\r\n} else {\r\nrt2x00mmio_register_read(rt2x00dev, CSR20, &reg);\r\nrt2x00_set_field32(&reg, CSR20_AUTOWAKE, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR20, reg);\r\n}\r\nrt2x00dev->ops->lib->set_device_state(rt2x00dev, state);\r\n}\r\nstatic void rt2500pci_config(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00lib_conf *libconf,\r\nconst unsigned int flags)\r\n{\r\nif (flags & IEEE80211_CONF_CHANGE_CHANNEL)\r\nrt2500pci_config_channel(rt2x00dev, &libconf->rf,\r\nlibconf->conf->power_level);\r\nif ((flags & IEEE80211_CONF_CHANGE_POWER) &&\r\n!(flags & IEEE80211_CONF_CHANGE_CHANNEL))\r\nrt2500pci_config_txpower(rt2x00dev,\r\nlibconf->conf->power_level);\r\nif (flags & IEEE80211_CONF_CHANGE_RETRY_LIMITS)\r\nrt2500pci_config_retry_limit(rt2x00dev, libconf);\r\nif (flags & IEEE80211_CONF_CHANGE_PS)\r\nrt2500pci_config_ps(rt2x00dev, libconf);\r\n}\r\nstatic void rt2500pci_link_stats(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, CNT0, &reg);\r\nqual->rx_failed = rt2x00_get_field32(reg, CNT0_FCS_ERROR);\r\nrt2x00mmio_register_read(rt2x00dev, CNT3, &reg);\r\nqual->false_cca = rt2x00_get_field32(reg, CNT3_FALSE_CCA);\r\n}\r\nstatic inline void rt2500pci_set_vgc(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual, u8 vgc_level)\r\n{\r\nif (qual->vgc_level_reg != vgc_level) {\r\nrt2500pci_bbp_write(rt2x00dev, 17, vgc_level);\r\nqual->vgc_level = vgc_level;\r\nqual->vgc_level_reg = vgc_level;\r\n}\r\n}\r\nstatic void rt2500pci_reset_tuner(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual)\r\n{\r\nrt2500pci_set_vgc(rt2x00dev, qual, 0x48);\r\n}\r\nstatic void rt2500pci_link_tuner(struct rt2x00_dev *rt2x00dev,\r\nstruct link_qual *qual, const u32 count)\r\n{\r\nif (rt2x00_rev(rt2x00dev) < RT2560_VERSION_D &&\r\nrt2x00dev->intf_associated && count > 20)\r\nreturn;\r\nif (rt2x00_rev(rt2x00dev) < RT2560_VERSION_D ||\r\n!rt2x00dev->intf_associated)\r\ngoto dynamic_cca_tune;\r\nif (qual->rssi < -80 && count > 20) {\r\nif (qual->vgc_level_reg >= 0x41)\r\nrt2500pci_set_vgc(rt2x00dev, qual, qual->vgc_level);\r\nreturn;\r\n}\r\nif (qual->rssi >= -58) {\r\nrt2500pci_set_vgc(rt2x00dev, qual, 0x50);\r\nreturn;\r\n}\r\nif (qual->rssi >= -74) {\r\nrt2500pci_set_vgc(rt2x00dev, qual, 0x41);\r\nreturn;\r\n}\r\nif (qual->vgc_level_reg >= 0x41) {\r\nrt2500pci_set_vgc(rt2x00dev, qual, qual->vgc_level);\r\nreturn;\r\n}\r\ndynamic_cca_tune:\r\nif (qual->false_cca > 512 && qual->vgc_level_reg < 0x40)\r\nrt2500pci_set_vgc(rt2x00dev, qual, ++qual->vgc_level_reg);\r\nelse if (qual->false_cca < 100 && qual->vgc_level_reg > 0x32)\r\nrt2500pci_set_vgc(rt2x00dev, qual, --qual->vgc_level_reg);\r\n}\r\nstatic void rt2500pci_start_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nrt2x00mmio_register_read(rt2x00dev, RXCSR0, &reg);\r\nrt2x00_set_field32(&reg, RXCSR0_DISABLE_RX, 0);\r\nrt2x00mmio_register_write(rt2x00dev, RXCSR0, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00mmio_register_read(rt2x00dev, CSR14, &reg);\r\nrt2x00_set_field32(&reg, CSR14_TSF_COUNT, 1);\r\nrt2x00_set_field32(&reg, CSR14_TBCN, 1);\r\nrt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);\r\nrt2x00mmio_register_write(rt2x00dev, CSR14, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void rt2500pci_kick_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR0, &reg);\r\nrt2x00_set_field32(&reg, TXCSR0_KICK_PRIO, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\r\nbreak;\r\ncase QID_AC_VI:\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR0, &reg);\r\nrt2x00_set_field32(&reg, TXCSR0_KICK_TX, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\r\nbreak;\r\ncase QID_ATIM:\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR0, &reg);\r\nrt2x00_set_field32(&reg, TXCSR0_KICK_ATIM, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void rt2500pci_stop_queue(struct data_queue *queue)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = queue->rt2x00dev;\r\nu32 reg;\r\nswitch (queue->qid) {\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_ATIM:\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR0, &reg);\r\nrt2x00_set_field32(&reg, TXCSR0_ABORT, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR0, reg);\r\nbreak;\r\ncase QID_RX:\r\nrt2x00mmio_register_read(rt2x00dev, RXCSR0, &reg);\r\nrt2x00_set_field32(&reg, RXCSR0_DISABLE_RX, 1);\r\nrt2x00mmio_register_write(rt2x00dev, RXCSR0, reg);\r\nbreak;\r\ncase QID_BEACON:\r\nrt2x00mmio_register_read(rt2x00dev, CSR14, &reg);\r\nrt2x00_set_field32(&reg, CSR14_TSF_COUNT, 0);\r\nrt2x00_set_field32(&reg, CSR14_TBCN, 0);\r\nrt2x00_set_field32(&reg, CSR14_BEACON_GEN, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR14, reg);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic bool rt2500pci_get_entry_state(struct queue_entry *entry)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nu32 word;\r\nif (entry->queue->qid == QID_RX) {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nreturn rt2x00_get_field32(word, RXD_W0_OWNER_NIC);\r\n} else {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nreturn (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\r\nrt2x00_get_field32(word, TXD_W0_VALID));\r\n}\r\n}\r\nstatic void rt2500pci_clear_entry(struct queue_entry *entry)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nu32 word;\r\nif (entry->queue->qid == QID_RX) {\r\nrt2x00_desc_read(entry_priv->desc, 1, &word);\r\nrt2x00_set_field32(&word, RXD_W1_BUFFER_ADDRESS, skbdesc->skb_dma);\r\nrt2x00_desc_write(entry_priv->desc, 1, word);\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nrt2x00_set_field32(&word, RXD_W0_OWNER_NIC, 1);\r\nrt2x00_desc_write(entry_priv->desc, 0, word);\r\n} else {\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nrt2x00_set_field32(&word, TXD_W0_VALID, 0);\r\nrt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 0);\r\nrt2x00_desc_write(entry_priv->desc, 0, word);\r\n}\r\n}\r\nstatic int rt2500pci_init_queues(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR2, &reg);\r\nrt2x00_set_field32(&reg, TXCSR2_TXD_SIZE, rt2x00dev->tx[0].desc_size);\r\nrt2x00_set_field32(&reg, TXCSR2_NUM_TXD, rt2x00dev->tx[1].limit);\r\nrt2x00_set_field32(&reg, TXCSR2_NUM_ATIM, rt2x00dev->atim->limit);\r\nrt2x00_set_field32(&reg, TXCSR2_NUM_PRIO, rt2x00dev->tx[0].limit);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR2, reg);\r\nentry_priv = rt2x00dev->tx[1].entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR3, &reg);\r\nrt2x00_set_field32(&reg, TXCSR3_TX_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR3, reg);\r\nentry_priv = rt2x00dev->tx[0].entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR5, &reg);\r\nrt2x00_set_field32(&reg, TXCSR5_PRIO_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR5, reg);\r\nentry_priv = rt2x00dev->atim->entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR4, &reg);\r\nrt2x00_set_field32(&reg, TXCSR4_ATIM_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR4, reg);\r\nentry_priv = rt2x00dev->bcn->entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR6, &reg);\r\nrt2x00_set_field32(&reg, TXCSR6_BEACON_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR6, reg);\r\nrt2x00mmio_register_read(rt2x00dev, RXCSR1, &reg);\r\nrt2x00_set_field32(&reg, RXCSR1_RXD_SIZE, rt2x00dev->rx->desc_size);\r\nrt2x00_set_field32(&reg, RXCSR1_NUM_RXD, rt2x00dev->rx->limit);\r\nrt2x00mmio_register_write(rt2x00dev, RXCSR1, reg);\r\nentry_priv = rt2x00dev->rx->entries[0].priv_data;\r\nrt2x00mmio_register_read(rt2x00dev, RXCSR2, &reg);\r\nrt2x00_set_field32(&reg, RXCSR2_RX_RING_REGISTER,\r\nentry_priv->desc_dma);\r\nrt2x00mmio_register_write(rt2x00dev, RXCSR2, reg);\r\nreturn 0;\r\n}\r\nstatic int rt2500pci_init_registers(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nrt2x00mmio_register_write(rt2x00dev, PSCSR0, 0x00020002);\r\nrt2x00mmio_register_write(rt2x00dev, PSCSR1, 0x00000002);\r\nrt2x00mmio_register_write(rt2x00dev, PSCSR2, 0x00020002);\r\nrt2x00mmio_register_write(rt2x00dev, PSCSR3, 0x00000002);\r\nrt2x00mmio_register_read(rt2x00dev, TIMECSR, &reg);\r\nrt2x00_set_field32(&reg, TIMECSR_US_COUNT, 33);\r\nrt2x00_set_field32(&reg, TIMECSR_US_64_COUNT, 63);\r\nrt2x00_set_field32(&reg, TIMECSR_BEACON_EXPECT, 0);\r\nrt2x00mmio_register_write(rt2x00dev, TIMECSR, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR9, &reg);\r\nrt2x00_set_field32(&reg, CSR9_MAX_FRAME_UNIT,\r\nrt2x00dev->rx->data_size / 128);\r\nrt2x00mmio_register_write(rt2x00dev, CSR9, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR11, &reg);\r\nrt2x00_set_field32(&reg, CSR11_CW_SELECT, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR11, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR14, &reg);\r\nrt2x00_set_field32(&reg, CSR14_TSF_COUNT, 0);\r\nrt2x00_set_field32(&reg, CSR14_TSF_SYNC, 0);\r\nrt2x00_set_field32(&reg, CSR14_TBCN, 0);\r\nrt2x00_set_field32(&reg, CSR14_TCFP, 0);\r\nrt2x00_set_field32(&reg, CSR14_TATIMW, 0);\r\nrt2x00_set_field32(&reg, CSR14_BEACON_GEN, 0);\r\nrt2x00_set_field32(&reg, CSR14_CFP_COUNT_PRELOAD, 0);\r\nrt2x00_set_field32(&reg, CSR14_TBCM_PRELOAD, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR14, reg);\r\nrt2x00mmio_register_write(rt2x00dev, CNT3, 0);\r\nrt2x00mmio_register_read(rt2x00dev, TXCSR8, &reg);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID0, 10);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID0_VALID, 1);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID1, 11);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID1_VALID, 1);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID2, 13);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID2_VALID, 1);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID3, 12);\r\nrt2x00_set_field32(&reg, TXCSR8_BBP_ID3_VALID, 1);\r\nrt2x00mmio_register_write(rt2x00dev, TXCSR8, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARTCSR0, &reg);\r\nrt2x00_set_field32(&reg, ARTCSR0_ACK_CTS_1MBS, 112);\r\nrt2x00_set_field32(&reg, ARTCSR0_ACK_CTS_2MBS, 56);\r\nrt2x00_set_field32(&reg, ARTCSR0_ACK_CTS_5_5MBS, 20);\r\nrt2x00_set_field32(&reg, ARTCSR0_ACK_CTS_11MBS, 10);\r\nrt2x00mmio_register_write(rt2x00dev, ARTCSR0, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARTCSR1, &reg);\r\nrt2x00_set_field32(&reg, ARTCSR1_ACK_CTS_6MBS, 45);\r\nrt2x00_set_field32(&reg, ARTCSR1_ACK_CTS_9MBS, 37);\r\nrt2x00_set_field32(&reg, ARTCSR1_ACK_CTS_12MBS, 33);\r\nrt2x00_set_field32(&reg, ARTCSR1_ACK_CTS_18MBS, 29);\r\nrt2x00mmio_register_write(rt2x00dev, ARTCSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, ARTCSR2, &reg);\r\nrt2x00_set_field32(&reg, ARTCSR2_ACK_CTS_24MBS, 29);\r\nrt2x00_set_field32(&reg, ARTCSR2_ACK_CTS_36MBS, 25);\r\nrt2x00_set_field32(&reg, ARTCSR2_ACK_CTS_48MBS, 25);\r\nrt2x00_set_field32(&reg, ARTCSR2_ACK_CTS_54MBS, 25);\r\nrt2x00mmio_register_write(rt2x00dev, ARTCSR2, reg);\r\nrt2x00mmio_register_read(rt2x00dev, RXCSR3, &reg);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID0, 47);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID0_VALID, 1);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID1, 51);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID1_VALID, 1);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID2, 42);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID2_VALID, 1);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID3, 51);\r\nrt2x00_set_field32(&reg, RXCSR3_BBP_ID3_VALID, 1);\r\nrt2x00mmio_register_write(rt2x00dev, RXCSR3, reg);\r\nrt2x00mmio_register_read(rt2x00dev, PCICSR, &reg);\r\nrt2x00_set_field32(&reg, PCICSR_BIG_ENDIAN, 0);\r\nrt2x00_set_field32(&reg, PCICSR_RX_TRESHOLD, 0);\r\nrt2x00_set_field32(&reg, PCICSR_TX_TRESHOLD, 3);\r\nrt2x00_set_field32(&reg, PCICSR_BURST_LENTH, 1);\r\nrt2x00_set_field32(&reg, PCICSR_ENABLE_CLK, 1);\r\nrt2x00_set_field32(&reg, PCICSR_READ_MULTIPLE, 1);\r\nrt2x00_set_field32(&reg, PCICSR_WRITE_INVALID, 1);\r\nrt2x00mmio_register_write(rt2x00dev, PCICSR, reg);\r\nrt2x00mmio_register_write(rt2x00dev, PWRCSR0, 0x3f3b3100);\r\nrt2x00mmio_register_write(rt2x00dev, GPIOCSR, 0x0000ff00);\r\nrt2x00mmio_register_write(rt2x00dev, TESTCSR, 0x000000f0);\r\nif (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))\r\nreturn -EBUSY;\r\nrt2x00mmio_register_write(rt2x00dev, MACCSR0, 0x00213223);\r\nrt2x00mmio_register_write(rt2x00dev, MACCSR1, 0x00235518);\r\nrt2x00mmio_register_read(rt2x00dev, MACCSR2, &reg);\r\nrt2x00_set_field32(&reg, MACCSR2_DELAY, 64);\r\nrt2x00mmio_register_write(rt2x00dev, MACCSR2, reg);\r\nrt2x00mmio_register_read(rt2x00dev, RALINKCSR, &reg);\r\nrt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA0, 17);\r\nrt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID0, 26);\r\nrt2x00_set_field32(&reg, RALINKCSR_AR_BBP_VALID0, 1);\r\nrt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA1, 0);\r\nrt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID1, 26);\r\nrt2x00_set_field32(&reg, RALINKCSR_AR_BBP_VALID1, 1);\r\nrt2x00mmio_register_write(rt2x00dev, RALINKCSR, reg);\r\nrt2x00mmio_register_write(rt2x00dev, BBPCSR1, 0x82188200);\r\nrt2x00mmio_register_write(rt2x00dev, TXACKCSR0, 0x00000020);\r\nrt2x00mmio_register_read(rt2x00dev, CSR1, &reg);\r\nrt2x00_set_field32(&reg, CSR1_SOFT_RESET, 1);\r\nrt2x00_set_field32(&reg, CSR1_BBP_RESET, 0);\r\nrt2x00_set_field32(&reg, CSR1_HOST_READY, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CSR1, &reg);\r\nrt2x00_set_field32(&reg, CSR1_SOFT_RESET, 0);\r\nrt2x00_set_field32(&reg, CSR1_HOST_READY, 1);\r\nrt2x00mmio_register_write(rt2x00dev, CSR1, reg);\r\nrt2x00mmio_register_read(rt2x00dev, CNT0, &reg);\r\nrt2x00mmio_register_read(rt2x00dev, CNT4, &reg);\r\nreturn 0;\r\n}\r\nstatic int rt2500pci_wait_bbp_ready(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu8 value;\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2500pci_bbp_read(rt2x00dev, 0, &value);\r\nif ((value != 0xff) && (value != 0x00))\r\nreturn 0;\r\nudelay(REGISTER_BUSY_DELAY);\r\n}\r\nrt2x00_err(rt2x00dev, "BBP register access failed, aborting\n");\r\nreturn -EACCES;\r\n}\r\nstatic int rt2500pci_init_bbp(struct rt2x00_dev *rt2x00dev)\r\n{\r\nunsigned int i;\r\nu16 eeprom;\r\nu8 reg_id;\r\nu8 value;\r\nif (unlikely(rt2500pci_wait_bbp_ready(rt2x00dev)))\r\nreturn -EACCES;\r\nrt2500pci_bbp_write(rt2x00dev, 3, 0x02);\r\nrt2500pci_bbp_write(rt2x00dev, 4, 0x19);\r\nrt2500pci_bbp_write(rt2x00dev, 14, 0x1c);\r\nrt2500pci_bbp_write(rt2x00dev, 15, 0x30);\r\nrt2500pci_bbp_write(rt2x00dev, 16, 0xac);\r\nrt2500pci_bbp_write(rt2x00dev, 18, 0x18);\r\nrt2500pci_bbp_write(rt2x00dev, 19, 0xff);\r\nrt2500pci_bbp_write(rt2x00dev, 20, 0x1e);\r\nrt2500pci_bbp_write(rt2x00dev, 21, 0x08);\r\nrt2500pci_bbp_write(rt2x00dev, 22, 0x08);\r\nrt2500pci_bbp_write(rt2x00dev, 23, 0x08);\r\nrt2500pci_bbp_write(rt2x00dev, 24, 0x70);\r\nrt2500pci_bbp_write(rt2x00dev, 25, 0x40);\r\nrt2500pci_bbp_write(rt2x00dev, 26, 0x08);\r\nrt2500pci_bbp_write(rt2x00dev, 27, 0x23);\r\nrt2500pci_bbp_write(rt2x00dev, 30, 0x10);\r\nrt2500pci_bbp_write(rt2x00dev, 31, 0x2b);\r\nrt2500pci_bbp_write(rt2x00dev, 32, 0xb9);\r\nrt2500pci_bbp_write(rt2x00dev, 34, 0x12);\r\nrt2500pci_bbp_write(rt2x00dev, 35, 0x50);\r\nrt2500pci_bbp_write(rt2x00dev, 39, 0xc4);\r\nrt2500pci_bbp_write(rt2x00dev, 40, 0x02);\r\nrt2500pci_bbp_write(rt2x00dev, 41, 0x60);\r\nrt2500pci_bbp_write(rt2x00dev, 53, 0x10);\r\nrt2500pci_bbp_write(rt2x00dev, 54, 0x18);\r\nrt2500pci_bbp_write(rt2x00dev, 56, 0x08);\r\nrt2500pci_bbp_write(rt2x00dev, 57, 0x10);\r\nrt2500pci_bbp_write(rt2x00dev, 58, 0x08);\r\nrt2500pci_bbp_write(rt2x00dev, 61, 0x6d);\r\nrt2500pci_bbp_write(rt2x00dev, 62, 0x10);\r\nfor (i = 0; i < EEPROM_BBP_SIZE; i++) {\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_BBP_START + i, &eeprom);\r\nif (eeprom != 0xffff && eeprom != 0x0000) {\r\nreg_id = rt2x00_get_field16(eeprom, EEPROM_BBP_REG_ID);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);\r\nrt2500pci_bbp_write(rt2x00dev, reg_id, value);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void rt2500pci_toggle_irq(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nint mask = (state == STATE_RADIO_IRQ_OFF);\r\nu32 reg;\r\nunsigned long flags;\r\nif (state == STATE_RADIO_IRQ_ON) {\r\nrt2x00mmio_register_read(rt2x00dev, CSR7, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, CSR7, reg);\r\n}\r\nspin_lock_irqsave(&rt2x00dev->irqmask_lock, flags);\r\nrt2x00mmio_register_read(rt2x00dev, CSR8, &reg);\r\nrt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, mask);\r\nrt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, mask);\r\nrt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, mask);\r\nrt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, mask);\r\nrt2x00_set_field32(&reg, CSR8_RXDONE, mask);\r\nrt2x00mmio_register_write(rt2x00dev, CSR8, reg);\r\nspin_unlock_irqrestore(&rt2x00dev->irqmask_lock, flags);\r\nif (state == STATE_RADIO_IRQ_OFF) {\r\ntasklet_kill(&rt2x00dev->txstatus_tasklet);\r\ntasklet_kill(&rt2x00dev->rxdone_tasklet);\r\ntasklet_kill(&rt2x00dev->tbtt_tasklet);\r\n}\r\n}\r\nstatic int rt2500pci_enable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nif (unlikely(rt2500pci_init_queues(rt2x00dev) ||\r\nrt2500pci_init_registers(rt2x00dev) ||\r\nrt2500pci_init_bbp(rt2x00dev)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic void rt2500pci_disable_radio(struct rt2x00_dev *rt2x00dev)\r\n{\r\nrt2x00mmio_register_write(rt2x00dev, PWRCSR0, 0);\r\n}\r\nstatic int rt2500pci_set_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nu32 reg, reg2;\r\nunsigned int i;\r\nchar put_to_sleep;\r\nchar bbp_state;\r\nchar rf_state;\r\nput_to_sleep = (state != STATE_AWAKE);\r\nrt2x00mmio_register_read(rt2x00dev, PWRCSR1, &reg);\r\nrt2x00_set_field32(&reg, PWRCSR1_SET_STATE, 1);\r\nrt2x00_set_field32(&reg, PWRCSR1_BBP_DESIRE_STATE, state);\r\nrt2x00_set_field32(&reg, PWRCSR1_RF_DESIRE_STATE, state);\r\nrt2x00_set_field32(&reg, PWRCSR1_PUT_TO_SLEEP, put_to_sleep);\r\nrt2x00mmio_register_write(rt2x00dev, PWRCSR1, reg);\r\nfor (i = 0; i < REGISTER_BUSY_COUNT; i++) {\r\nrt2x00mmio_register_read(rt2x00dev, PWRCSR1, &reg2);\r\nbbp_state = rt2x00_get_field32(reg2, PWRCSR1_BBP_CURR_STATE);\r\nrf_state = rt2x00_get_field32(reg2, PWRCSR1_RF_CURR_STATE);\r\nif (bbp_state == state && rf_state == state)\r\nreturn 0;\r\nrt2x00mmio_register_write(rt2x00dev, PWRCSR1, reg);\r\nmsleep(10);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int rt2500pci_set_device_state(struct rt2x00_dev *rt2x00dev,\r\nenum dev_state state)\r\n{\r\nint retval = 0;\r\nswitch (state) {\r\ncase STATE_RADIO_ON:\r\nretval = rt2500pci_enable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_OFF:\r\nrt2500pci_disable_radio(rt2x00dev);\r\nbreak;\r\ncase STATE_RADIO_IRQ_ON:\r\ncase STATE_RADIO_IRQ_OFF:\r\nrt2500pci_toggle_irq(rt2x00dev, state);\r\nbreak;\r\ncase STATE_DEEP_SLEEP:\r\ncase STATE_SLEEP:\r\ncase STATE_STANDBY:\r\ncase STATE_AWAKE:\r\nretval = rt2500pci_set_state(rt2x00dev, state);\r\nbreak;\r\ndefault:\r\nretval = -ENOTSUPP;\r\nbreak;\r\n}\r\nif (unlikely(retval))\r\nrt2x00_err(rt2x00dev, "Device failed to enter state %d (%d)\n",\r\nstate, retval);\r\nreturn retval;\r\n}\r\nstatic void rt2500pci_write_tx_desc(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct skb_frame_desc *skbdesc = get_skb_frame_desc(entry->skb);\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\n__le32 *txd = entry_priv->desc;\r\nu32 word;\r\nrt2x00_desc_read(txd, 1, &word);\r\nrt2x00_set_field32(&word, TXD_W1_BUFFER_ADDRESS, skbdesc->skb_dma);\r\nrt2x00_desc_write(txd, 1, word);\r\nrt2x00_desc_read(txd, 2, &word);\r\nrt2x00_set_field32(&word, TXD_W2_IV_OFFSET, IEEE80211_HEADER);\r\nrt2x00_set_field32(&word, TXD_W2_AIFS, entry->queue->aifs);\r\nrt2x00_set_field32(&word, TXD_W2_CWMIN, entry->queue->cw_min);\r\nrt2x00_set_field32(&word, TXD_W2_CWMAX, entry->queue->cw_max);\r\nrt2x00_desc_write(txd, 2, word);\r\nrt2x00_desc_read(txd, 3, &word);\r\nrt2x00_set_field32(&word, TXD_W3_PLCP_SIGNAL, txdesc->u.plcp.signal);\r\nrt2x00_set_field32(&word, TXD_W3_PLCP_SERVICE, txdesc->u.plcp.service);\r\nrt2x00_set_field32(&word, TXD_W3_PLCP_LENGTH_LOW,\r\ntxdesc->u.plcp.length_low);\r\nrt2x00_set_field32(&word, TXD_W3_PLCP_LENGTH_HIGH,\r\ntxdesc->u.plcp.length_high);\r\nrt2x00_desc_write(txd, 3, word);\r\nrt2x00_desc_read(txd, 10, &word);\r\nrt2x00_set_field32(&word, TXD_W10_RTS,\r\ntest_bit(ENTRY_TXD_RTS_FRAME, &txdesc->flags));\r\nrt2x00_desc_write(txd, 10, word);\r\nrt2x00_desc_read(txd, 0, &word);\r\nrt2x00_set_field32(&word, TXD_W0_OWNER_NIC, 1);\r\nrt2x00_set_field32(&word, TXD_W0_VALID, 1);\r\nrt2x00_set_field32(&word, TXD_W0_MORE_FRAG,\r\ntest_bit(ENTRY_TXD_MORE_FRAG, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_ACK,\r\ntest_bit(ENTRY_TXD_ACK, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_TIMESTAMP,\r\ntest_bit(ENTRY_TXD_REQ_TIMESTAMP, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_OFDM,\r\n(txdesc->rate_mode == RATE_MODE_OFDM));\r\nrt2x00_set_field32(&word, TXD_W0_CIPHER_OWNER, 1);\r\nrt2x00_set_field32(&word, TXD_W0_IFS, txdesc->u.plcp.ifs);\r\nrt2x00_set_field32(&word, TXD_W0_RETRY_MODE,\r\ntest_bit(ENTRY_TXD_RETRY_MODE, &txdesc->flags));\r\nrt2x00_set_field32(&word, TXD_W0_DATABYTE_COUNT, txdesc->length);\r\nrt2x00_set_field32(&word, TXD_W0_CIPHER_ALG, CIPHER_NONE);\r\nrt2x00_desc_write(txd, 0, word);\r\nskbdesc->desc = txd;\r\nskbdesc->desc_len = TXD_DESC_SIZE;\r\n}\r\nstatic void rt2500pci_write_beacon(struct queue_entry *entry,\r\nstruct txentry_desc *txdesc)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = entry->queue->rt2x00dev;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, CSR14, &reg);\r\nrt2x00_set_field32(&reg, CSR14_BEACON_GEN, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR14, reg);\r\nif (rt2x00queue_map_txskb(entry)) {\r\nrt2x00_err(rt2x00dev, "Fail to map beacon, aborting\n");\r\ngoto out;\r\n}\r\nrt2500pci_write_tx_desc(entry, txdesc);\r\nrt2x00debug_dump_frame(rt2x00dev, DUMP_FRAME_BEACON, entry->skb);\r\nout:\r\nrt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);\r\nrt2x00mmio_register_write(rt2x00dev, CSR14, reg);\r\n}\r\nstatic void rt2500pci_fill_rxdone(struct queue_entry *entry,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct queue_entry_priv_mmio *entry_priv = entry->priv_data;\r\nu32 word0;\r\nu32 word2;\r\nrt2x00_desc_read(entry_priv->desc, 0, &word0);\r\nrt2x00_desc_read(entry_priv->desc, 2, &word2);\r\nif (rt2x00_get_field32(word0, RXD_W0_CRC_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_FCS_CRC;\r\nif (rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))\r\nrxdesc->flags |= RX_FLAG_FAILED_PLCP_CRC;\r\nrxdesc->signal = rt2x00_get_field32(word2, RXD_W2_SIGNAL);\r\nrxdesc->rssi = rt2x00_get_field32(word2, RXD_W2_RSSI) -\r\nentry->queue->rt2x00dev->rssi_offset;\r\nrxdesc->size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);\r\nif (rt2x00_get_field32(word0, RXD_W0_OFDM))\r\nrxdesc->dev_flags |= RXDONE_SIGNAL_PLCP;\r\nelse\r\nrxdesc->dev_flags |= RXDONE_SIGNAL_BITRATE;\r\nif (rt2x00_get_field32(word0, RXD_W0_MY_BSS))\r\nrxdesc->dev_flags |= RXDONE_MY_BSS;\r\n}\r\nstatic void rt2500pci_txdone(struct rt2x00_dev *rt2x00dev,\r\nconst enum data_queue_qid queue_idx)\r\n{\r\nstruct data_queue *queue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);\r\nstruct queue_entry_priv_mmio *entry_priv;\r\nstruct queue_entry *entry;\r\nstruct txdone_entry_desc txdesc;\r\nu32 word;\r\nwhile (!rt2x00queue_empty(queue)) {\r\nentry = rt2x00queue_get_entry(queue, Q_INDEX_DONE);\r\nentry_priv = entry->priv_data;\r\nrt2x00_desc_read(entry_priv->desc, 0, &word);\r\nif (rt2x00_get_field32(word, TXD_W0_OWNER_NIC) ||\r\n!rt2x00_get_field32(word, TXD_W0_VALID))\r\nbreak;\r\ntxdesc.flags = 0;\r\nswitch (rt2x00_get_field32(word, TXD_W0_RESULT)) {\r\ncase 0:\r\ncase 1:\r\n__set_bit(TXDONE_SUCCESS, &txdesc.flags);\r\nbreak;\r\ncase 2:\r\n__set_bit(TXDONE_EXCESSIVE_RETRY, &txdesc.flags);\r\ndefault:\r\n__set_bit(TXDONE_FAILURE, &txdesc.flags);\r\n}\r\ntxdesc.retry = rt2x00_get_field32(word, TXD_W0_RETRY_COUNT);\r\nrt2x00lib_txdone(entry, &txdesc);\r\n}\r\n}\r\nstatic inline void rt2500pci_enable_interrupt(struct rt2x00_dev *rt2x00dev,\r\nstruct rt2x00_field32 irq_field)\r\n{\r\nu32 reg;\r\nspin_lock_irq(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, CSR8, &reg);\r\nrt2x00_set_field32(&reg, irq_field, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR8, reg);\r\nspin_unlock_irq(&rt2x00dev->irqmask_lock);\r\n}\r\nstatic void rt2500pci_txstatus_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nu32 reg;\r\nrt2500pci_txdone(rt2x00dev, QID_ATIM);\r\nrt2500pci_txdone(rt2x00dev, QID_AC_VO);\r\nrt2500pci_txdone(rt2x00dev, QID_AC_VI);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags)) {\r\nspin_lock_irq(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, CSR8, &reg);\r\nrt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, 0);\r\nrt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, 0);\r\nrt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, 0);\r\nrt2x00mmio_register_write(rt2x00dev, CSR8, reg);\r\nspin_unlock_irq(&rt2x00dev->irqmask_lock);\r\n}\r\n}\r\nstatic void rt2500pci_tbtt_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nrt2x00lib_beacondone(rt2x00dev);\r\nif (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2500pci_enable_interrupt(rt2x00dev, CSR8_TBCN_EXPIRE);\r\n}\r\nstatic void rt2500pci_rxdone_tasklet(unsigned long data)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = (struct rt2x00_dev *)data;\r\nif (rt2x00mmio_rxdone(rt2x00dev))\r\ntasklet_schedule(&rt2x00dev->rxdone_tasklet);\r\nelse if (test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nrt2500pci_enable_interrupt(rt2x00dev, CSR8_RXDONE);\r\n}\r\nstatic irqreturn_t rt2500pci_interrupt(int irq, void *dev_instance)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = dev_instance;\r\nu32 reg, mask;\r\nrt2x00mmio_register_read(rt2x00dev, CSR7, &reg);\r\nrt2x00mmio_register_write(rt2x00dev, CSR7, reg);\r\nif (!reg)\r\nreturn IRQ_NONE;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn IRQ_HANDLED;\r\nmask = reg;\r\nif (rt2x00_get_field32(reg, CSR7_TBCN_EXPIRE))\r\ntasklet_hi_schedule(&rt2x00dev->tbtt_tasklet);\r\nif (rt2x00_get_field32(reg, CSR7_RXDONE))\r\ntasklet_schedule(&rt2x00dev->rxdone_tasklet);\r\nif (rt2x00_get_field32(reg, CSR7_TXDONE_ATIMRING) ||\r\nrt2x00_get_field32(reg, CSR7_TXDONE_PRIORING) ||\r\nrt2x00_get_field32(reg, CSR7_TXDONE_TXRING)) {\r\ntasklet_schedule(&rt2x00dev->txstatus_tasklet);\r\nrt2x00_set_field32(&mask, CSR8_TXDONE_TXRING, 1);\r\nrt2x00_set_field32(&mask, CSR8_TXDONE_ATIMRING, 1);\r\nrt2x00_set_field32(&mask, CSR8_TXDONE_PRIORING, 1);\r\n}\r\nspin_lock(&rt2x00dev->irqmask_lock);\r\nrt2x00mmio_register_read(rt2x00dev, CSR8, &reg);\r\nreg |= mask;\r\nrt2x00mmio_register_write(rt2x00dev, CSR8, reg);\r\nspin_unlock(&rt2x00dev->irqmask_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rt2500pci_validate_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct eeprom_93cx6 eeprom;\r\nu32 reg;\r\nu16 word;\r\nu8 *mac;\r\nrt2x00mmio_register_read(rt2x00dev, CSR21, &reg);\r\neeprom.data = rt2x00dev;\r\neeprom.register_read = rt2500pci_eepromregister_read;\r\neeprom.register_write = rt2500pci_eepromregister_write;\r\neeprom.width = rt2x00_get_field32(reg, CSR21_TYPE_93C46) ?\r\nPCI_EEPROM_WIDTH_93C46 : PCI_EEPROM_WIDTH_93C66;\r\neeprom.reg_data_in = 0;\r\neeprom.reg_data_out = 0;\r\neeprom.reg_data_clock = 0;\r\neeprom.reg_chip_select = 0;\r\neeprom_93cx6_multiread(&eeprom, EEPROM_BASE, rt2x00dev->eeprom,\r\nEEPROM_SIZE / sizeof(u16));\r\nmac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);\r\nif (!is_valid_ether_addr(mac)) {\r\neth_random_addr(mac);\r\nrt2x00_eeprom_dbg(rt2x00dev, "MAC: %pM\n", mac);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_TX_DEFAULT,\r\nANTENNA_SW_DIVERSITY);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_RX_DEFAULT,\r\nANTENNA_SW_DIVERSITY);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_LED_MODE,\r\nLED_MODE_DEFAULT);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_DYN_TXAGC, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_HARDWARE_RADIO, 0);\r\nrt2x00_set_field16(&word, EEPROM_ANTENNA_RF_TYPE, RF2522);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_ANTENNA, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "Antenna: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_NIC, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_NIC_CARDBUS_ACCEL, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_DYN_BBP_TUNE, 0);\r\nrt2x00_set_field16(&word, EEPROM_NIC_CCK_TX_POWER, 0);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_NIC, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "NIC: 0x%04x\n", word);\r\n}\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &word);\r\nif (word == 0xffff) {\r\nrt2x00_set_field16(&word, EEPROM_CALIBRATE_OFFSET_RSSI,\r\nDEFAULT_RSSI_OFFSET);\r\nrt2x00_eeprom_write(rt2x00dev, EEPROM_CALIBRATE_OFFSET, word);\r\nrt2x00_eeprom_dbg(rt2x00dev, "Calibrate offset: 0x%04x\n",\r\nword);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2500pci_init_eeprom(struct rt2x00_dev *rt2x00dev)\r\n{\r\nu32 reg;\r\nu16 value;\r\nu16 eeprom;\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &eeprom);\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);\r\nrt2x00mmio_register_read(rt2x00dev, CSR0, &reg);\r\nrt2x00_set_chip(rt2x00dev, RT2560, value,\r\nrt2x00_get_field32(reg, CSR0_REVISION));\r\nif (!rt2x00_rf(rt2x00dev, RF2522) &&\r\n!rt2x00_rf(rt2x00dev, RF2523) &&\r\n!rt2x00_rf(rt2x00dev, RF2524) &&\r\n!rt2x00_rf(rt2x00dev, RF2525) &&\r\n!rt2x00_rf(rt2x00dev, RF2525E) &&\r\n!rt2x00_rf(rt2x00dev, RF5222)) {\r\nrt2x00_err(rt2x00dev, "Invalid RF chipset detected\n");\r\nreturn -ENODEV;\r\n}\r\nrt2x00dev->default_ant.tx =\r\nrt2x00_get_field16(eeprom, EEPROM_ANTENNA_TX_DEFAULT);\r\nrt2x00dev->default_ant.rx =\r\nrt2x00_get_field16(eeprom, EEPROM_ANTENNA_RX_DEFAULT);\r\n#ifdef CONFIG_RT2X00_LIB_LEDS\r\nvalue = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_LED_MODE);\r\nrt2500pci_init_led(rt2x00dev, &rt2x00dev->led_radio, LED_TYPE_RADIO);\r\nif (value == LED_MODE_TXRX_ACTIVITY ||\r\nvalue == LED_MODE_DEFAULT ||\r\nvalue == LED_MODE_ASUS)\r\nrt2500pci_init_led(rt2x00dev, &rt2x00dev->led_qual,\r\nLED_TYPE_ACTIVITY);\r\n#endif\r\nif (rt2x00_get_field16(eeprom, EEPROM_ANTENNA_HARDWARE_RADIO))\r\n__set_bit(CAPABILITY_HW_BUTTON, &rt2x00dev->cap_flags);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_NIC, &eeprom);\r\nif (!rt2x00_get_field16(eeprom, EEPROM_NIC_DYN_BBP_TUNE))\r\n__set_bit(CAPABILITY_LINK_TUNING, &rt2x00dev->cap_flags);\r\nrt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &eeprom);\r\nrt2x00dev->rssi_offset =\r\nrt2x00_get_field16(eeprom, EEPROM_CALIBRATE_OFFSET_RSSI);\r\nreturn 0;\r\n}\r\nstatic int rt2500pci_probe_hw_mode(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct hw_mode_spec *spec = &rt2x00dev->spec;\r\nstruct channel_info *info;\r\nchar *tx_power;\r\nunsigned int i;\r\nrt2x00dev->hw->flags = IEEE80211_HW_HOST_BROADCAST_PS_BUFFERING |\r\nIEEE80211_HW_SIGNAL_DBM |\r\nIEEE80211_HW_SUPPORTS_PS |\r\nIEEE80211_HW_PS_NULLFUNC_STACK;\r\nSET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->dev);\r\nSET_IEEE80211_PERM_ADDR(rt2x00dev->hw,\r\nrt2x00_eeprom_addr(rt2x00dev,\r\nEEPROM_MAC_ADDR_0));\r\nspec->supported_bands = SUPPORT_BAND_2GHZ;\r\nspec->supported_rates = SUPPORT_RATE_CCK | SUPPORT_RATE_OFDM;\r\nif (rt2x00_rf(rt2x00dev, RF2522)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2522);\r\nspec->channels = rf_vals_bg_2522;\r\n} else if (rt2x00_rf(rt2x00dev, RF2523)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2523);\r\nspec->channels = rf_vals_bg_2523;\r\n} else if (rt2x00_rf(rt2x00dev, RF2524)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2524);\r\nspec->channels = rf_vals_bg_2524;\r\n} else if (rt2x00_rf(rt2x00dev, RF2525)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2525);\r\nspec->channels = rf_vals_bg_2525;\r\n} else if (rt2x00_rf(rt2x00dev, RF2525E)) {\r\nspec->num_channels = ARRAY_SIZE(rf_vals_bg_2525e);\r\nspec->channels = rf_vals_bg_2525e;\r\n} else if (rt2x00_rf(rt2x00dev, RF5222)) {\r\nspec->supported_bands |= SUPPORT_BAND_5GHZ;\r\nspec->num_channels = ARRAY_SIZE(rf_vals_5222);\r\nspec->channels = rf_vals_5222;\r\n}\r\ninfo = kcalloc(spec->num_channels, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\nspec->channels_info = info;\r\ntx_power = rt2x00_eeprom_addr(rt2x00dev, EEPROM_TXPOWER_START);\r\nfor (i = 0; i < 14; i++) {\r\ninfo[i].max_power = MAX_TXPOWER;\r\ninfo[i].default_power1 = TXPOWER_FROM_DEV(tx_power[i]);\r\n}\r\nif (spec->num_channels > 14) {\r\nfor (i = 14; i < spec->num_channels; i++) {\r\ninfo[i].max_power = MAX_TXPOWER;\r\ninfo[i].default_power1 = DEFAULT_TXPOWER;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt2500pci_probe_hw(struct rt2x00_dev *rt2x00dev)\r\n{\r\nint retval;\r\nu32 reg;\r\nretval = rt2500pci_validate_eeprom(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nretval = rt2500pci_init_eeprom(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\nrt2x00mmio_register_read(rt2x00dev, GPIOCSR, &reg);\r\nrt2x00_set_field32(&reg, GPIOCSR_DIR0, 1);\r\nrt2x00mmio_register_write(rt2x00dev, GPIOCSR, reg);\r\nretval = rt2500pci_probe_hw_mode(rt2x00dev);\r\nif (retval)\r\nreturn retval;\r\n__set_bit(REQUIRE_ATIM_QUEUE, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_DMA, &rt2x00dev->cap_flags);\r\n__set_bit(REQUIRE_SW_SEQNO, &rt2x00dev->cap_flags);\r\nrt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;\r\nreturn 0;\r\n}\r\nstatic u64 rt2500pci_get_tsf(struct ieee80211_hw *hw,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nu64 tsf;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, CSR17, &reg);\r\ntsf = (u64) rt2x00_get_field32(reg, CSR17_HIGH_TSFTIMER) << 32;\r\nrt2x00mmio_register_read(rt2x00dev, CSR16, &reg);\r\ntsf |= rt2x00_get_field32(reg, CSR16_LOW_TSFTIMER);\r\nreturn tsf;\r\n}\r\nstatic int rt2500pci_tx_last_beacon(struct ieee80211_hw *hw)\r\n{\r\nstruct rt2x00_dev *rt2x00dev = hw->priv;\r\nu32 reg;\r\nrt2x00mmio_register_read(rt2x00dev, CSR15, &reg);\r\nreturn rt2x00_get_field32(reg, CSR15_BEACON_SENT);\r\n}\r\nstatic void rt2500pci_queue_init(struct data_queue *queue)\r\n{\r\nswitch (queue->qid) {\r\ncase QID_RX:\r\nqueue->limit = 32;\r\nqueue->data_size = DATA_FRAME_SIZE;\r\nqueue->desc_size = RXD_DESC_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_AC_VO:\r\ncase QID_AC_VI:\r\ncase QID_AC_BE:\r\ncase QID_AC_BK:\r\nqueue->limit = 32;\r\nqueue->data_size = DATA_FRAME_SIZE;\r\nqueue->desc_size = TXD_DESC_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_BEACON:\r\nqueue->limit = 1;\r\nqueue->data_size = MGMT_FRAME_SIZE;\r\nqueue->desc_size = TXD_DESC_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ncase QID_ATIM:\r\nqueue->limit = 8;\r\nqueue->data_size = DATA_FRAME_SIZE;\r\nqueue->desc_size = TXD_DESC_SIZE;\r\nqueue->priv_size = sizeof(struct queue_entry_priv_mmio);\r\nbreak;\r\ndefault:\r\nBUG();\r\nbreak;\r\n}\r\n}\r\nstatic int rt2500pci_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn rt2x00pci_probe(pci_dev, &rt2500pci_ops);\r\n}
