static inline char *ext_flags(struct osc_extent *ext, char *flags)\r\n{\r\nchar *buf = flags;\r\n*buf++ = ext->oe_rw ? 'r' : 'w';\r\nif (ext->oe_intree)\r\n*buf++ = 'i';\r\nif (ext->oe_srvlock)\r\n*buf++ = 's';\r\nif (ext->oe_hp)\r\n*buf++ = 'h';\r\nif (ext->oe_urgent)\r\n*buf++ = 'u';\r\nif (ext->oe_memalloc)\r\n*buf++ = 'm';\r\nif (ext->oe_trunc_pending)\r\n*buf++ = 't';\r\nif (ext->oe_fsync_wait)\r\n*buf++ = 'Y';\r\n*buf = 0;\r\nreturn flags;\r\n}\r\nstatic inline char list_empty_marker(struct list_head *list)\r\n{\r\nreturn list_empty(list) ? '-' : '+';\r\n}\r\nstatic inline struct osc_extent *rb_extent(struct rb_node *n)\r\n{\r\nif (n == NULL)\r\nreturn NULL;\r\nreturn container_of(n, struct osc_extent, oe_node);\r\n}\r\nstatic inline struct osc_extent *next_extent(struct osc_extent *ext)\r\n{\r\nif (ext == NULL)\r\nreturn NULL;\r\nLASSERT(ext->oe_intree);\r\nreturn rb_extent(rb_next(&ext->oe_node));\r\n}\r\nstatic inline struct osc_extent *prev_extent(struct osc_extent *ext)\r\n{\r\nif (ext == NULL)\r\nreturn NULL;\r\nLASSERT(ext->oe_intree);\r\nreturn rb_extent(rb_prev(&ext->oe_node));\r\n}\r\nstatic inline struct osc_extent *first_extent(struct osc_object *obj)\r\n{\r\nreturn rb_extent(rb_first(&obj->oo_root));\r\n}\r\nstatic int osc_extent_sanity_check0(struct osc_extent *ext,\r\nconst char *func, const int line)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nstruct osc_async_page *oap;\r\nint page_count;\r\nint rc = 0;\r\nif (!osc_object_is_locked(obj))\r\nGOTO(out, rc = 9);\r\nif (ext->oe_state >= OES_STATE_MAX)\r\nGOTO(out, rc = 10);\r\nif (atomic_read(&ext->oe_refc) <= 0)\r\nGOTO(out, rc = 20);\r\nif (atomic_read(&ext->oe_refc) < atomic_read(&ext->oe_users))\r\nGOTO(out, rc = 30);\r\nswitch (ext->oe_state) {\r\ncase OES_INV:\r\nif (ext->oe_nr_pages > 0 || !list_empty(&ext->oe_pages))\r\nGOTO(out, rc = 35);\r\nGOTO(out, rc = 0);\r\nbreak;\r\ncase OES_ACTIVE:\r\nif (atomic_read(&ext->oe_users) == 0)\r\nGOTO(out, rc = 40);\r\nif (ext->oe_hp)\r\nGOTO(out, rc = 50);\r\nif (ext->oe_fsync_wait && !ext->oe_urgent)\r\nGOTO(out, rc = 55);\r\nbreak;\r\ncase OES_CACHE:\r\nif (ext->oe_grants == 0)\r\nGOTO(out, rc = 60);\r\nif (ext->oe_fsync_wait && !ext->oe_urgent && !ext->oe_hp)\r\nGOTO(out, rc = 65);\r\ndefault:\r\nif (atomic_read(&ext->oe_users) > 0)\r\nGOTO(out, rc = 70);\r\n}\r\nif (ext->oe_max_end < ext->oe_end || ext->oe_end < ext->oe_start)\r\nGOTO(out, rc = 80);\r\nif (ext->oe_osclock == NULL && ext->oe_grants > 0)\r\nGOTO(out, rc = 90);\r\nif (ext->oe_osclock) {\r\nstruct cl_lock_descr *descr;\r\ndescr = &ext->oe_osclock->cll_descr;\r\nif (!(descr->cld_start <= ext->oe_start &&\r\ndescr->cld_end >= ext->oe_max_end))\r\nGOTO(out, rc = 100);\r\n}\r\nif (ext->oe_nr_pages > ext->oe_mppr)\r\nGOTO(out, rc = 105);\r\nif (ext->oe_state > OES_CACHE)\r\nGOTO(out, rc = 0);\r\nif (!extent_debug)\r\nGOTO(out, rc = 0);\r\npage_count = 0;\r\nlist_for_each_entry(oap, &ext->oe_pages, oap_pending_item) {\r\npgoff_t index = oap2cl_page(oap)->cp_index;\r\n++page_count;\r\nif (index > ext->oe_end || index < ext->oe_start)\r\nGOTO(out, rc = 110);\r\n}\r\nif (page_count != ext->oe_nr_pages)\r\nGOTO(out, rc = 120);\r\nout:\r\nif (rc != 0)\r\nOSC_EXTENT_DUMP(D_ERROR, ext,\r\n"%s:%d sanity check %p failed with rc = %d\n",\r\nfunc, line, ext, rc);\r\nreturn rc;\r\n}\r\nstatic int osc_extent_is_overlapped(struct osc_object *obj,\r\nstruct osc_extent *ext)\r\n{\r\nstruct osc_extent *tmp;\r\nLASSERT(osc_object_is_locked(obj));\r\nif (!extent_debug)\r\nreturn 0;\r\nfor (tmp = first_extent(obj); tmp != NULL; tmp = next_extent(tmp)) {\r\nif (tmp == ext)\r\ncontinue;\r\nif (tmp->oe_end >= ext->oe_start &&\r\ntmp->oe_start <= ext->oe_end)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void osc_extent_state_set(struct osc_extent *ext, int state)\r\n{\r\nLASSERT(osc_object_is_locked(ext->oe_obj));\r\nLASSERT(state >= OES_INV && state < OES_STATE_MAX);\r\next->oe_state = state;\r\nwake_up_all(&ext->oe_waitq);\r\n}\r\nstatic struct osc_extent *osc_extent_alloc(struct osc_object *obj)\r\n{\r\nstruct osc_extent *ext;\r\nOBD_SLAB_ALLOC_PTR_GFP(ext, osc_extent_kmem, GFP_IOFS);\r\nif (ext == NULL)\r\nreturn NULL;\r\nRB_CLEAR_NODE(&ext->oe_node);\r\next->oe_obj = obj;\r\natomic_set(&ext->oe_refc, 1);\r\natomic_set(&ext->oe_users, 0);\r\nINIT_LIST_HEAD(&ext->oe_link);\r\next->oe_state = OES_INV;\r\nINIT_LIST_HEAD(&ext->oe_pages);\r\ninit_waitqueue_head(&ext->oe_waitq);\r\next->oe_osclock = NULL;\r\nreturn ext;\r\n}\r\nstatic void osc_extent_free(struct osc_extent *ext)\r\n{\r\nOBD_SLAB_FREE_PTR(ext, osc_extent_kmem);\r\n}\r\nstatic struct osc_extent *osc_extent_get(struct osc_extent *ext)\r\n{\r\nLASSERT(atomic_read(&ext->oe_refc) >= 0);\r\natomic_inc(&ext->oe_refc);\r\nreturn ext;\r\n}\r\nstatic void osc_extent_put(const struct lu_env *env, struct osc_extent *ext)\r\n{\r\nLASSERT(atomic_read(&ext->oe_refc) > 0);\r\nif (atomic_dec_and_test(&ext->oe_refc)) {\r\nLASSERT(list_empty(&ext->oe_link));\r\nLASSERT(atomic_read(&ext->oe_users) == 0);\r\nLASSERT(ext->oe_state == OES_INV);\r\nLASSERT(!ext->oe_intree);\r\nif (ext->oe_osclock) {\r\ncl_lock_put(env, ext->oe_osclock);\r\next->oe_osclock = NULL;\r\n}\r\nosc_extent_free(ext);\r\n}\r\n}\r\nstatic void osc_extent_put_trust(struct osc_extent *ext)\r\n{\r\nLASSERT(atomic_read(&ext->oe_refc) > 1);\r\nLASSERT(osc_object_is_locked(ext->oe_obj));\r\natomic_dec(&ext->oe_refc);\r\n}\r\nstatic struct osc_extent *osc_extent_search(struct osc_object *obj,\r\npgoff_t index)\r\n{\r\nstruct rb_node *n = obj->oo_root.rb_node;\r\nstruct osc_extent *tmp, *p = NULL;\r\nLASSERT(osc_object_is_locked(obj));\r\nwhile (n != NULL) {\r\ntmp = rb_extent(n);\r\nif (index < tmp->oe_start) {\r\nn = n->rb_left;\r\n} else if (index > tmp->oe_end) {\r\np = rb_extent(n);\r\nn = n->rb_right;\r\n} else {\r\nreturn tmp;\r\n}\r\n}\r\nreturn p;\r\n}\r\nstatic struct osc_extent *osc_extent_lookup(struct osc_object *obj,\r\npgoff_t index)\r\n{\r\nstruct osc_extent *ext;\r\next = osc_extent_search(obj, index);\r\nif (ext != NULL && ext->oe_start <= index && index <= ext->oe_end)\r\nreturn osc_extent_get(ext);\r\nreturn NULL;\r\n}\r\nstatic void osc_extent_insert(struct osc_object *obj, struct osc_extent *ext)\r\n{\r\nstruct rb_node **n = &obj->oo_root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct osc_extent *tmp;\r\nLASSERT(ext->oe_intree == 0);\r\nLASSERT(ext->oe_obj == obj);\r\nLASSERT(osc_object_is_locked(obj));\r\nwhile (*n != NULL) {\r\ntmp = rb_extent(*n);\r\nparent = *n;\r\nif (ext->oe_end < tmp->oe_start)\r\nn = &(*n)->rb_left;\r\nelse if (ext->oe_start > tmp->oe_end)\r\nn = &(*n)->rb_right;\r\nelse\r\nEASSERTF(0, tmp, EXTSTR, EXTPARA(ext));\r\n}\r\nrb_link_node(&ext->oe_node, parent, n);\r\nrb_insert_color(&ext->oe_node, &obj->oo_root);\r\nosc_extent_get(ext);\r\next->oe_intree = 1;\r\n}\r\nstatic void osc_extent_erase(struct osc_extent *ext)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nLASSERT(osc_object_is_locked(obj));\r\nif (ext->oe_intree) {\r\nrb_erase(&ext->oe_node, &obj->oo_root);\r\next->oe_intree = 0;\r\nosc_extent_put_trust(ext);\r\n}\r\n}\r\nstatic struct osc_extent *osc_extent_hold(struct osc_extent *ext)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nLASSERT(osc_object_is_locked(obj));\r\nLASSERT(ext->oe_state == OES_ACTIVE || ext->oe_state == OES_CACHE);\r\nif (ext->oe_state == OES_CACHE) {\r\nosc_extent_state_set(ext, OES_ACTIVE);\r\nosc_update_pending(obj, OBD_BRW_WRITE, -ext->oe_nr_pages);\r\n}\r\natomic_inc(&ext->oe_users);\r\nlist_del_init(&ext->oe_link);\r\nreturn osc_extent_get(ext);\r\n}\r\nstatic void __osc_extent_remove(struct osc_extent *ext)\r\n{\r\nLASSERT(osc_object_is_locked(ext->oe_obj));\r\nLASSERT(list_empty(&ext->oe_pages));\r\nosc_extent_erase(ext);\r\nlist_del_init(&ext->oe_link);\r\nosc_extent_state_set(ext, OES_INV);\r\nOSC_EXTENT_DUMP(D_CACHE, ext, "destroyed.\n");\r\n}\r\nstatic void osc_extent_remove(struct osc_extent *ext)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nosc_object_lock(obj);\r\n__osc_extent_remove(ext);\r\nosc_object_unlock(obj);\r\n}\r\nstatic int osc_extent_merge(const struct lu_env *env, struct osc_extent *cur,\r\nstruct osc_extent *victim)\r\n{\r\nstruct osc_object *obj = cur->oe_obj;\r\npgoff_t chunk_start;\r\npgoff_t chunk_end;\r\nint ppc_bits;\r\nLASSERT(cur->oe_state == OES_CACHE);\r\nLASSERT(osc_object_is_locked(obj));\r\nif (victim == NULL)\r\nreturn -EINVAL;\r\nif (victim->oe_state != OES_CACHE || victim->oe_fsync_wait)\r\nreturn -EBUSY;\r\nif (cur->oe_max_end != victim->oe_max_end)\r\nreturn -ERANGE;\r\nLASSERT(cur->oe_osclock == victim->oe_osclock);\r\nppc_bits = osc_cli(obj)->cl_chunkbits - PAGE_CACHE_SHIFT;\r\nchunk_start = cur->oe_start >> ppc_bits;\r\nchunk_end = cur->oe_end >> ppc_bits;\r\nif (chunk_start != (victim->oe_end >> ppc_bits) + 1 &&\r\nchunk_end + 1 != victim->oe_start >> ppc_bits)\r\nreturn -ERANGE;\r\nOSC_EXTENT_DUMP(D_CACHE, victim, "will be merged by %p.\n", cur);\r\ncur->oe_start = min(cur->oe_start, victim->oe_start);\r\ncur->oe_end = max(cur->oe_end, victim->oe_end);\r\ncur->oe_grants += victim->oe_grants;\r\ncur->oe_nr_pages += victim->oe_nr_pages;\r\ncur->oe_urgent |= victim->oe_urgent;\r\ncur->oe_memalloc |= victim->oe_memalloc;\r\nlist_splice_init(&victim->oe_pages, &cur->oe_pages);\r\nlist_del_init(&victim->oe_link);\r\nvictim->oe_nr_pages = 0;\r\nosc_extent_get(victim);\r\n__osc_extent_remove(victim);\r\nosc_extent_put(env, victim);\r\nOSC_EXTENT_DUMP(D_CACHE, cur, "after merging %p.\n", victim);\r\nreturn 0;\r\n}\r\nint osc_extent_release(const struct lu_env *env, struct osc_extent *ext)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nint rc = 0;\r\nLASSERT(atomic_read(&ext->oe_users) > 0);\r\nLASSERT(sanity_check(ext) == 0);\r\nLASSERT(ext->oe_grants > 0);\r\nif (atomic_dec_and_lock(&ext->oe_users, &obj->oo_lock)) {\r\nLASSERT(ext->oe_state == OES_ACTIVE);\r\nif (ext->oe_trunc_pending) {\r\nosc_extent_state_set(ext, OES_TRUNC);\r\next->oe_trunc_pending = 0;\r\n} else {\r\nosc_extent_state_set(ext, OES_CACHE);\r\nosc_update_pending(obj, OBD_BRW_WRITE,\r\next->oe_nr_pages);\r\nosc_extent_merge(env, ext, prev_extent(ext));\r\nosc_extent_merge(env, ext, next_extent(ext));\r\nif (ext->oe_urgent)\r\nlist_move_tail(&ext->oe_link,\r\n&obj->oo_urgent_exts);\r\n}\r\nosc_object_unlock(obj);\r\nosc_io_unplug_async(env, osc_cli(obj), obj);\r\n}\r\nosc_extent_put(env, ext);\r\nreturn rc;\r\n}\r\nstatic inline int overlapped(struct osc_extent *ex1, struct osc_extent *ex2)\r\n{\r\nreturn !(ex1->oe_end < ex2->oe_start || ex2->oe_end < ex1->oe_start);\r\n}\r\nstruct osc_extent *osc_extent_find(const struct lu_env *env,\r\nstruct osc_object *obj, pgoff_t index,\r\nint *grants)\r\n{\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct cl_lock *lock;\r\nstruct osc_extent *cur;\r\nstruct osc_extent *ext;\r\nstruct osc_extent *conflict = NULL;\r\nstruct osc_extent *found = NULL;\r\npgoff_t chunk;\r\npgoff_t max_end;\r\nint max_pages;\r\nint chunksize;\r\nint ppc_bits;\r\nint chunk_mask;\r\nint rc;\r\ncur = osc_extent_alloc(obj);\r\nif (cur == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nlock = cl_lock_at_pgoff(env, osc2cl(obj), index, NULL, 1, 0);\r\nLASSERT(lock != NULL);\r\nLASSERT(lock->cll_descr.cld_mode >= CLM_WRITE);\r\nLASSERT(cli->cl_chunkbits >= PAGE_CACHE_SHIFT);\r\nppc_bits = cli->cl_chunkbits - PAGE_CACHE_SHIFT;\r\nchunk_mask = ~((1 << ppc_bits) - 1);\r\nchunksize = 1 << cli->cl_chunkbits;\r\nchunk = index >> ppc_bits;\r\nmax_pages = cli->cl_max_pages_per_rpc;\r\nLASSERT((max_pages & ~chunk_mask) == 0);\r\nmax_end = index - (index % max_pages) + max_pages - 1;\r\nmax_end = min_t(pgoff_t, max_end, lock->cll_descr.cld_end);\r\ncur->oe_max_end = max_end;\r\ncur->oe_start = index & chunk_mask;\r\ncur->oe_end = ((index + ~chunk_mask + 1) & chunk_mask) - 1;\r\nif (cur->oe_start < lock->cll_descr.cld_start)\r\ncur->oe_start = lock->cll_descr.cld_start;\r\nif (cur->oe_end > max_end)\r\ncur->oe_end = max_end;\r\ncur->oe_osclock = lock;\r\ncur->oe_grants = 0;\r\ncur->oe_mppr = max_pages;\r\nLASSERTF(*grants >= chunksize + cli->cl_extent_tax,\r\n"%u/%u/%u.\n", *grants, chunksize, cli->cl_extent_tax);\r\nLASSERTF((max_end - cur->oe_start) < max_pages, EXTSTR, EXTPARA(cur));\r\nrestart:\r\nosc_object_lock(obj);\r\next = osc_extent_search(obj, cur->oe_start);\r\nif (ext == NULL)\r\next = first_extent(obj);\r\nwhile (ext != NULL) {\r\nloff_t ext_chk_start = ext->oe_start >> ppc_bits;\r\nloff_t ext_chk_end = ext->oe_end >> ppc_bits;\r\nLASSERT(sanity_check_nolock(ext) == 0);\r\nif (chunk > ext_chk_end + 1)\r\nbreak;\r\nif (lock != ext->oe_osclock) {\r\nEASSERTF(!overlapped(ext, cur), ext,\r\nEXTSTR, EXTPARA(cur));\r\next = next_extent(ext);\r\ncontinue;\r\n}\r\nif (chunk + 1 < ext_chk_start) {\r\next = next_extent(ext);\r\ncontinue;\r\n}\r\nif (overlapped(ext, cur)) {\r\nEASSERTF((ext->oe_start <= cur->oe_start &&\r\next->oe_end >= cur->oe_end),\r\next, EXTSTR, EXTPARA(cur));\r\nif (ext->oe_state > OES_CACHE || ext->oe_fsync_wait) {\r\nconflict = osc_extent_get(ext);\r\nbreak;\r\n}\r\nfound = osc_extent_hold(ext);\r\nbreak;\r\n}\r\nif (ext->oe_state != OES_CACHE || ext->oe_fsync_wait) {\r\next = next_extent(ext);\r\ncontinue;\r\n}\r\nif (ext->oe_max_end != max_end) {\r\next = next_extent(ext);\r\ncontinue;\r\n}\r\nif (chunk + 1 == ext_chk_start) {\r\nEASSERT((ext->oe_start & ~chunk_mask) == 0, ext);\r\next->oe_start = cur->oe_start;\r\next->oe_grants += chunksize;\r\n*grants -= chunksize;\r\nfound = osc_extent_hold(ext);\r\n} else if (chunk == ext_chk_end + 1) {\r\next->oe_end = cur->oe_end;\r\next->oe_grants += chunksize;\r\n*grants -= chunksize;\r\nif (osc_extent_merge(env, ext, next_extent(ext)) == 0)\r\n*grants += cli->cl_extent_tax;\r\nfound = osc_extent_hold(ext);\r\n}\r\nif (found != NULL)\r\nbreak;\r\next = next_extent(ext);\r\n}\r\nosc_extent_tree_dump(D_CACHE, obj);\r\nif (found != NULL) {\r\nLASSERT(conflict == NULL);\r\nif (!IS_ERR(found)) {\r\nLASSERT(found->oe_osclock == cur->oe_osclock);\r\nOSC_EXTENT_DUMP(D_CACHE, found,\r\n"found caching ext for %lu.\n", index);\r\n}\r\n} else if (conflict == NULL) {\r\nEASSERT(osc_extent_is_overlapped(obj, cur) == 0, cur);\r\ncur->oe_grants = chunksize + cli->cl_extent_tax;\r\n*grants -= cur->oe_grants;\r\nLASSERT(*grants >= 0);\r\ncur->oe_state = OES_CACHE;\r\nfound = osc_extent_hold(cur);\r\nosc_extent_insert(obj, cur);\r\nOSC_EXTENT_DUMP(D_CACHE, cur, "add into tree %lu/%lu.\n",\r\nindex, lock->cll_descr.cld_end);\r\n}\r\nosc_object_unlock(obj);\r\nif (conflict != NULL) {\r\nLASSERT(found == NULL);\r\nrc = osc_extent_wait(env, conflict, OES_INV);\r\nosc_extent_put(env, conflict);\r\nconflict = NULL;\r\nif (rc < 0)\r\nGOTO(out, found = ERR_PTR(rc));\r\ngoto restart;\r\n}\r\nout:\r\nosc_extent_put(env, cur);\r\nLASSERT(*grants >= 0);\r\nreturn found;\r\n}\r\nint osc_extent_finish(const struct lu_env *env, struct osc_extent *ext,\r\nint sent, int rc)\r\n{\r\nstruct client_obd *cli = osc_cli(ext->oe_obj);\r\nstruct osc_async_page *oap;\r\nstruct osc_async_page *tmp;\r\nint nr_pages = ext->oe_nr_pages;\r\nint lost_grant = 0;\r\nint blocksize = cli->cl_import->imp_obd->obd_osfs.os_bsize ? : 4096;\r\n__u64 last_off = 0;\r\nint last_count = -1;\r\nOSC_EXTENT_DUMP(D_CACHE, ext, "extent finished.\n");\r\next->oe_rc = rc ?: ext->oe_nr_pages;\r\nEASSERT(ergo(rc == 0, ext->oe_state == OES_RPC), ext);\r\nlist_for_each_entry_safe(oap, tmp, &ext->oe_pages,\r\noap_pending_item) {\r\nlist_del_init(&oap->oap_rpc_item);\r\nlist_del_init(&oap->oap_pending_item);\r\nif (last_off <= oap->oap_obj_off) {\r\nlast_off = oap->oap_obj_off;\r\nlast_count = oap->oap_count;\r\n}\r\n--ext->oe_nr_pages;\r\nosc_ap_completion(env, cli, oap, sent, rc);\r\n}\r\nEASSERT(ext->oe_nr_pages == 0, ext);\r\nif (!sent) {\r\nlost_grant = ext->oe_grants;\r\n} else if (blocksize < PAGE_CACHE_SIZE &&\r\nlast_count != PAGE_CACHE_SIZE) {\r\nint offset = oap->oap_page_off & ~CFS_PAGE_MASK;\r\nint count = oap->oap_count + (offset & (blocksize - 1));\r\nint end = (offset + oap->oap_count) & (blocksize - 1);\r\nif (end)\r\ncount += blocksize - end;\r\nlost_grant = PAGE_CACHE_SIZE - count;\r\n}\r\nif (ext->oe_grants > 0)\r\nosc_free_grant(cli, nr_pages, lost_grant);\r\nosc_extent_remove(ext);\r\nosc_extent_put(env, ext);\r\nreturn 0;\r\n}\r\nstatic int extent_wait_cb(struct osc_extent *ext, int state)\r\n{\r\nint ret;\r\nosc_object_lock(ext->oe_obj);\r\nret = ext->oe_state == state;\r\nosc_object_unlock(ext->oe_obj);\r\nreturn ret;\r\n}\r\nstatic int osc_extent_wait(const struct lu_env *env, struct osc_extent *ext,\r\nint state)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nstruct l_wait_info lwi = LWI_TIMEOUT_INTR(cfs_time_seconds(600), NULL,\r\nLWI_ON_SIGNAL_NOOP, NULL);\r\nint rc = 0;\r\nosc_object_lock(obj);\r\nLASSERT(sanity_check_nolock(ext) == 0);\r\nif (state == OES_INV && !ext->oe_urgent && !ext->oe_hp) {\r\nif (ext->oe_state == OES_ACTIVE) {\r\next->oe_urgent = 1;\r\n} else if (ext->oe_state == OES_CACHE) {\r\next->oe_urgent = 1;\r\nosc_extent_hold(ext);\r\nrc = 1;\r\n}\r\n}\r\nosc_object_unlock(obj);\r\nif (rc == 1)\r\nosc_extent_release(env, ext);\r\nrc = l_wait_event(ext->oe_waitq, extent_wait_cb(ext, state), &lwi);\r\nif (rc == -ETIMEDOUT) {\r\nOSC_EXTENT_DUMP(D_ERROR, ext,\r\n"%s: wait ext to %d timedout, recovery in progress?\n",\r\nosc_export(obj)->exp_obd->obd_name, state);\r\nlwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);\r\nrc = l_wait_event(ext->oe_waitq, extent_wait_cb(ext, state),\r\n&lwi);\r\n}\r\nif (rc == 0 && ext->oe_rc < 0)\r\nrc = ext->oe_rc;\r\nreturn rc;\r\n}\r\nstatic int osc_extent_truncate(struct osc_extent *ext, pgoff_t trunc_index,\r\nbool partial)\r\n{\r\nstruct cl_env_nest nest;\r\nstruct lu_env *env;\r\nstruct cl_io *io;\r\nstruct osc_object *obj = ext->oe_obj;\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct osc_async_page *oap;\r\nstruct osc_async_page *tmp;\r\nint pages_in_chunk = 0;\r\nint ppc_bits = cli->cl_chunkbits - PAGE_CACHE_SHIFT;\r\n__u64 trunc_chunk = trunc_index >> ppc_bits;\r\nint grants = 0;\r\nint nr_pages = 0;\r\nint rc = 0;\r\nLASSERT(sanity_check(ext) == 0);\r\nLASSERT(ext->oe_state == OES_TRUNC);\r\nLASSERT(!ext->oe_urgent);\r\nenv = cl_env_nested_get(&nest);\r\nio = &osc_env_info(env)->oti_io;\r\nio->ci_obj = cl_object_top(osc2cl(obj));\r\nrc = cl_io_init(env, io, CIT_MISC, io->ci_obj);\r\nif (rc < 0)\r\nGOTO(out, rc);\r\nlist_for_each_entry_safe(oap, tmp, &ext->oe_pages,\r\noap_pending_item) {\r\nstruct cl_page *sub = oap2cl_page(oap);\r\nstruct cl_page *page = cl_page_top(sub);\r\nLASSERT(list_empty(&oap->oap_rpc_item));\r\nif (sub->cp_index < trunc_index ||\r\n(sub->cp_index == trunc_index && partial)) {\r\nif (sub->cp_index >> ppc_bits == trunc_chunk)\r\n++pages_in_chunk;\r\ncontinue;\r\n}\r\nlist_del_init(&oap->oap_pending_item);\r\ncl_page_get(page);\r\nlu_ref_add(&page->cp_reference, "truncate", current);\r\nif (cl_page_own(env, io, page) == 0) {\r\ncl_page_unmap(env, io, page);\r\ncl_page_discard(env, io, page);\r\ncl_page_disown(env, io, page);\r\n} else {\r\nLASSERT(page->cp_state == CPS_FREEING);\r\nLASSERT(0);\r\n}\r\nlu_ref_del(&page->cp_reference, "truncate", current);\r\ncl_page_put(env, page);\r\n--ext->oe_nr_pages;\r\n++nr_pages;\r\n}\r\nEASSERTF(ergo(ext->oe_start >= trunc_index + !!partial,\r\next->oe_nr_pages == 0),\r\next, "trunc_index %lu, partial %d\n", trunc_index, partial);\r\nosc_object_lock(obj);\r\nif (ext->oe_nr_pages == 0) {\r\nLASSERT(pages_in_chunk == 0);\r\ngrants = ext->oe_grants;\r\next->oe_grants = 0;\r\n} else {\r\nint chunks = (ext->oe_end >> ppc_bits) - trunc_chunk;\r\npgoff_t last_index;\r\nif (pages_in_chunk == 0) {\r\nLASSERT(trunc_chunk > 0);\r\n--trunc_chunk;\r\n++chunks;\r\n}\r\ngrants = chunks << cli->cl_chunkbits;\r\next->oe_grants -= grants;\r\nlast_index = ((trunc_chunk + 1) << ppc_bits) - 1;\r\next->oe_end = min(last_index, ext->oe_max_end);\r\nLASSERT(ext->oe_end >= ext->oe_start);\r\nLASSERT(ext->oe_grants > 0);\r\n}\r\nosc_object_unlock(obj);\r\nif (grants > 0 || nr_pages > 0)\r\nosc_free_grant(cli, nr_pages, grants);\r\nout:\r\ncl_io_fini(env, io);\r\ncl_env_nested_put(&nest, env);\r\nreturn rc;\r\n}\r\nstatic int osc_extent_make_ready(const struct lu_env *env,\r\nstruct osc_extent *ext)\r\n{\r\nstruct osc_async_page *oap;\r\nstruct osc_async_page *last = NULL;\r\nstruct osc_object *obj = ext->oe_obj;\r\nint page_count = 0;\r\nint rc;\r\nLASSERT(sanity_check(ext) == 0);\r\nEASSERT(ext->oe_state == OES_LOCKING, ext);\r\nEASSERT(ext->oe_owner != NULL, ext);\r\nOSC_EXTENT_DUMP(D_CACHE, ext, "make ready\n");\r\nlist_for_each_entry(oap, &ext->oe_pages, oap_pending_item) {\r\n++page_count;\r\nif (last == NULL || last->oap_obj_off < oap->oap_obj_off)\r\nlast = oap;\r\nif ((oap->oap_async_flags & ASYNC_READY) != 0)\r\ncontinue;\r\nrc = osc_make_ready(env, oap, OBD_BRW_WRITE);\r\nswitch (rc) {\r\ncase 0:\r\nspin_lock(&oap->oap_lock);\r\noap->oap_async_flags |= ASYNC_READY;\r\nspin_unlock(&oap->oap_lock);\r\nbreak;\r\ncase -EALREADY:\r\nLASSERT((oap->oap_async_flags & ASYNC_READY) != 0);\r\nbreak;\r\ndefault:\r\nLASSERTF(0, "unknown return code: %d\n", rc);\r\n}\r\n}\r\nLASSERT(page_count == ext->oe_nr_pages);\r\nLASSERT(last != NULL);\r\nif (!(last->oap_async_flags & ASYNC_COUNT_STABLE)) {\r\nlast->oap_count = osc_refresh_count(env, last, OBD_BRW_WRITE);\r\nLASSERT(last->oap_count > 0);\r\nLASSERT(last->oap_page_off + last->oap_count <= PAGE_CACHE_SIZE);\r\nlast->oap_async_flags |= ASYNC_COUNT_STABLE;\r\n}\r\nlist_for_each_entry(oap, &ext->oe_pages, oap_pending_item) {\r\nif (!(oap->oap_async_flags & ASYNC_COUNT_STABLE)) {\r\noap->oap_count = PAGE_CACHE_SIZE - oap->oap_page_off;\r\noap->oap_async_flags |= ASYNC_COUNT_STABLE;\r\n}\r\n}\r\nosc_object_lock(obj);\r\nosc_extent_state_set(ext, OES_RPC);\r\nosc_object_unlock(obj);\r\nosc_extent_get(ext);\r\nreturn 0;\r\n}\r\nstatic int osc_extent_expand(struct osc_extent *ext, pgoff_t index, int *grants)\r\n{\r\nstruct osc_object *obj = ext->oe_obj;\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct osc_extent *next;\r\nint ppc_bits = cli->cl_chunkbits - PAGE_CACHE_SHIFT;\r\npgoff_t chunk = index >> ppc_bits;\r\npgoff_t end_chunk;\r\npgoff_t end_index;\r\nint chunksize = 1 << cli->cl_chunkbits;\r\nint rc = 0;\r\nLASSERT(ext->oe_max_end >= index && ext->oe_start <= index);\r\nosc_object_lock(obj);\r\nLASSERT(sanity_check_nolock(ext) == 0);\r\nend_chunk = ext->oe_end >> ppc_bits;\r\nif (chunk > end_chunk + 1)\r\nGOTO(out, rc = -ERANGE);\r\nif (end_chunk >= chunk)\r\nGOTO(out, rc = 0);\r\nLASSERT(end_chunk + 1 == chunk);\r\nend_index = min(ext->oe_max_end, ((chunk + 1) << ppc_bits) - 1);\r\nnext = next_extent(ext);\r\nif (next != NULL && next->oe_start <= end_index)\r\nGOTO(out, rc = -EAGAIN);\r\next->oe_end = end_index;\r\next->oe_grants += chunksize;\r\n*grants -= chunksize;\r\nLASSERT(*grants >= 0);\r\nEASSERTF(osc_extent_is_overlapped(obj, ext) == 0, ext,\r\n"overlapped after expanding for %lu.\n", index);\r\nout:\r\nosc_object_unlock(obj);\r\nreturn rc;\r\n}\r\nstatic void osc_extent_tree_dump0(int level, struct osc_object *obj,\r\nconst char *func, int line)\r\n{\r\nstruct osc_extent *ext;\r\nint cnt;\r\nCDEBUG(level, "Dump object %p extents at %s:%d, mppr: %u.\n",\r\nobj, func, line, osc_cli(obj)->cl_max_pages_per_rpc);\r\ncnt = 1;\r\nfor (ext = first_extent(obj); ext != NULL; ext = next_extent(ext))\r\nOSC_EXTENT_DUMP(level, ext, "in tree %d.\n", cnt++);\r\ncnt = 1;\r\nlist_for_each_entry(ext, &obj->oo_hp_exts, oe_link)\r\nOSC_EXTENT_DUMP(level, ext, "hp %d.\n", cnt++);\r\ncnt = 1;\r\nlist_for_each_entry(ext, &obj->oo_urgent_exts, oe_link)\r\nOSC_EXTENT_DUMP(level, ext, "urgent %d.\n", cnt++);\r\ncnt = 1;\r\nlist_for_each_entry(ext, &obj->oo_reading_exts, oe_link)\r\nOSC_EXTENT_DUMP(level, ext, "reading %d.\n", cnt++);\r\n}\r\nstatic inline int osc_is_ready(struct osc_object *osc)\r\n{\r\nreturn !list_empty(&osc->oo_ready_item) ||\r\n!list_empty(&osc->oo_hp_ready_item);\r\n}\r\nstatic int osc_make_ready(const struct lu_env *env, struct osc_async_page *oap,\r\nint cmd)\r\n{\r\nstruct osc_page *opg = oap2osc_page(oap);\r\nstruct cl_page *page = cl_page_top(oap2cl_page(oap));\r\nint result;\r\nLASSERT(cmd == OBD_BRW_WRITE);\r\nresult = cl_page_make_ready(env, page, CRT_WRITE);\r\nif (result == 0)\r\nopg->ops_submit_time = cfs_time_current();\r\nreturn result;\r\n}\r\nstatic int osc_refresh_count(const struct lu_env *env,\r\nstruct osc_async_page *oap, int cmd)\r\n{\r\nstruct osc_page *opg = oap2osc_page(oap);\r\nstruct cl_page *page = oap2cl_page(oap);\r\nstruct cl_object *obj;\r\nstruct cl_attr *attr = &osc_env_info(env)->oti_attr;\r\nint result;\r\nloff_t kms;\r\nLASSERT(!(cmd & OBD_BRW_READ));\r\nLASSERT(opg != NULL);\r\nobj = opg->ops_cl.cpl_obj;\r\ncl_object_attr_lock(obj);\r\nresult = cl_object_attr_get(env, obj, attr);\r\ncl_object_attr_unlock(obj);\r\nif (result < 0)\r\nreturn result;\r\nkms = attr->cat_kms;\r\nif (cl_offset(obj, page->cp_index) >= kms)\r\nreturn 0;\r\nelse if (cl_offset(obj, page->cp_index + 1) > kms)\r\nreturn kms % PAGE_CACHE_SIZE;\r\nelse\r\nreturn PAGE_CACHE_SIZE;\r\n}\r\nstatic int osc_completion(const struct lu_env *env, struct osc_async_page *oap,\r\nint cmd, int rc)\r\n{\r\nstruct osc_page *opg = oap2osc_page(oap);\r\nstruct cl_page *page = cl_page_top(oap2cl_page(oap));\r\nstruct osc_object *obj = cl2osc(opg->ops_cl.cpl_obj);\r\nenum cl_req_type crt;\r\nint srvlock;\r\ncmd &= ~OBD_BRW_NOQUOTA;\r\nLASSERT(equi(page->cp_state == CPS_PAGEIN, cmd == OBD_BRW_READ));\r\nLASSERT(equi(page->cp_state == CPS_PAGEOUT, cmd == OBD_BRW_WRITE));\r\nLASSERT(opg->ops_transfer_pinned);\r\nif (page->cp_req != NULL)\r\ncl_req_page_done(env, page);\r\nLASSERT(page->cp_req == NULL);\r\ncrt = cmd == OBD_BRW_READ ? CRT_READ : CRT_WRITE;\r\nopg->ops_transfer_pinned = 0;\r\nspin_lock(&obj->oo_seatbelt);\r\nLASSERT(opg->ops_submitter != NULL);\r\nLASSERT(!list_empty(&opg->ops_inflight));\r\nlist_del_init(&opg->ops_inflight);\r\nopg->ops_submitter = NULL;\r\nspin_unlock(&obj->oo_seatbelt);\r\nopg->ops_submit_time = 0;\r\nsrvlock = oap->oap_brw_flags & OBD_BRW_SRVLOCK;\r\nif (rc == 0 && srvlock) {\r\nstruct lu_device *ld = opg->ops_cl.cpl_obj->co_lu.lo_dev;\r\nstruct osc_stats *stats = &lu2osc_dev(ld)->od_stats;\r\nint bytes = oap->oap_count;\r\nif (crt == CRT_READ)\r\nstats->os_lockless_reads += bytes;\r\nelse\r\nstats->os_lockless_writes += bytes;\r\n}\r\nlu_ref_del(&page->cp_reference, "transfer", page);\r\ncl_page_completion(env, page, crt, rc);\r\nreturn 0;\r\n}\r\nstatic void osc_consume_write_grant(struct client_obd *cli,\r\nstruct brw_page *pga)\r\n{\r\nLASSERT(spin_is_locked(&cli->cl_loi_list_lock.lock));\r\nLASSERT(!(pga->flag & OBD_BRW_FROM_GRANT));\r\natomic_inc(&obd_dirty_pages);\r\ncli->cl_dirty += PAGE_CACHE_SIZE;\r\npga->flag |= OBD_BRW_FROM_GRANT;\r\nCDEBUG(D_CACHE, "using %lu grant credits for brw %p page %p\n",\r\nPAGE_CACHE_SIZE, pga, pga->pg);\r\nosc_update_next_shrink(cli);\r\n}\r\nstatic void osc_release_write_grant(struct client_obd *cli,\r\nstruct brw_page *pga)\r\n{\r\nLASSERT(spin_is_locked(&cli->cl_loi_list_lock.lock));\r\nif (!(pga->flag & OBD_BRW_FROM_GRANT)) {\r\nreturn;\r\n}\r\npga->flag &= ~OBD_BRW_FROM_GRANT;\r\natomic_dec(&obd_dirty_pages);\r\ncli->cl_dirty -= PAGE_CACHE_SIZE;\r\nif (pga->flag & OBD_BRW_NOCACHE) {\r\npga->flag &= ~OBD_BRW_NOCACHE;\r\natomic_dec(&obd_dirty_transit_pages);\r\ncli->cl_dirty_transit -= PAGE_CACHE_SIZE;\r\n}\r\n}\r\nstatic int osc_reserve_grant(struct client_obd *cli, unsigned int bytes)\r\n{\r\nint rc = -EDQUOT;\r\nif (cli->cl_avail_grant >= bytes) {\r\ncli->cl_avail_grant -= bytes;\r\ncli->cl_reserved_grant += bytes;\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic void __osc_unreserve_grant(struct client_obd *cli,\r\nunsigned int reserved, unsigned int unused)\r\n{\r\ncli->cl_reserved_grant -= reserved;\r\nif (unused > reserved) {\r\ncli->cl_avail_grant += reserved;\r\ncli->cl_lost_grant += unused - reserved;\r\n} else {\r\ncli->cl_avail_grant += unused;\r\n}\r\n}\r\nvoid osc_unreserve_grant(struct client_obd *cli,\r\nunsigned int reserved, unsigned int unused)\r\n{\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\n__osc_unreserve_grant(cli, reserved, unused);\r\nif (unused > 0)\r\nosc_wake_cache_waiters(cli);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\nstatic void osc_free_grant(struct client_obd *cli, unsigned int nr_pages,\r\nunsigned int lost_grant)\r\n{\r\nint grant = (1 << cli->cl_chunkbits) + cli->cl_extent_tax;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\natomic_sub(nr_pages, &obd_dirty_pages);\r\ncli->cl_dirty -= nr_pages << PAGE_CACHE_SHIFT;\r\ncli->cl_lost_grant += lost_grant;\r\nif (cli->cl_avail_grant < grant && cli->cl_lost_grant >= grant) {\r\ncli->cl_lost_grant -= grant;\r\ncli->cl_avail_grant += grant;\r\n}\r\nosc_wake_cache_waiters(cli);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nCDEBUG(D_CACHE, "lost %u grant: %lu avail: %lu dirty: %lu\n",\r\nlost_grant, cli->cl_lost_grant,\r\ncli->cl_avail_grant, cli->cl_dirty);\r\n}\r\nstatic void osc_exit_cache(struct client_obd *cli, struct osc_async_page *oap)\r\n{\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nosc_release_write_grant(cli, &oap->oap_brw_page);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\nstatic int osc_enter_cache_try(struct client_obd *cli,\r\nstruct osc_async_page *oap,\r\nint bytes, int transient)\r\n{\r\nint rc;\r\nOSC_DUMP_GRANT(cli, "need:%d.\n", bytes);\r\nrc = osc_reserve_grant(cli, bytes);\r\nif (rc < 0)\r\nreturn 0;\r\nif (cli->cl_dirty + PAGE_CACHE_SIZE <= cli->cl_dirty_max &&\r\natomic_read(&obd_dirty_pages) + 1 <= obd_max_dirty_pages) {\r\nosc_consume_write_grant(cli, &oap->oap_brw_page);\r\nif (transient) {\r\ncli->cl_dirty_transit += PAGE_CACHE_SIZE;\r\natomic_inc(&obd_dirty_transit_pages);\r\noap->oap_brw_flags |= OBD_BRW_NOCACHE;\r\n}\r\nrc = 1;\r\n} else {\r\n__osc_unreserve_grant(cli, bytes, bytes);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int ocw_granted(struct client_obd *cli, struct osc_cache_waiter *ocw)\r\n{\r\nint rc;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nrc = list_empty(&ocw->ocw_entry);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn rc;\r\n}\r\nstatic int osc_enter_cache(const struct lu_env *env, struct client_obd *cli,\r\nstruct osc_async_page *oap, int bytes)\r\n{\r\nstruct osc_object *osc = oap->oap_obj;\r\nstruct lov_oinfo *loi = osc->oo_oinfo;\r\nstruct osc_cache_waiter ocw;\r\nstruct l_wait_info lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);\r\nint rc = -EDQUOT;\r\nOSC_DUMP_GRANT(cli, "need:%d.\n", bytes);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (OBD_FAIL_CHECK(OBD_FAIL_OSC_NO_GRANT) ||\r\ncli->cl_dirty_max < PAGE_CACHE_SIZE ||\r\ncli->cl_ar.ar_force_sync || loi->loi_ar.ar_force_sync)\r\nGOTO(out, rc = -EDQUOT);\r\nif (osc_enter_cache_try(cli, oap, bytes, 0))\r\nGOTO(out, rc = 0);\r\ninit_waitqueue_head(&ocw.ocw_waitq);\r\nocw.ocw_oap = oap;\r\nocw.ocw_grant = bytes;\r\nwhile (cli->cl_dirty > 0 || cli->cl_w_in_flight > 0) {\r\nlist_add_tail(&ocw.ocw_entry, &cli->cl_cache_waiters);\r\nocw.ocw_rc = 0;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nosc_io_unplug_async(env, cli, NULL);\r\nCDEBUG(D_CACHE, "%s: sleeping for cache space @ %p for %p\n",\r\ncli->cl_import->imp_obd->obd_name, &ocw, oap);\r\nrc = l_wait_event(ocw.ocw_waitq, ocw_granted(cli, &ocw), &lwi);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (rc < 0) {\r\nlist_del_init(&ocw.ocw_entry);\r\nGOTO(out, rc);\r\n}\r\nLASSERT(list_empty(&ocw.ocw_entry));\r\nrc = ocw.ocw_rc;\r\nif (rc != -EDQUOT)\r\nGOTO(out, rc);\r\nif (osc_enter_cache_try(cli, oap, bytes, 0))\r\nGOTO(out, rc = 0);\r\n}\r\nout:\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nOSC_DUMP_GRANT(cli, "returned %d.\n", rc);\r\nreturn rc;\r\n}\r\nvoid osc_wake_cache_waiters(struct client_obd *cli)\r\n{\r\nstruct list_head *l, *tmp;\r\nstruct osc_cache_waiter *ocw;\r\nlist_for_each_safe(l, tmp, &cli->cl_cache_waiters) {\r\nocw = list_entry(l, struct osc_cache_waiter, ocw_entry);\r\nlist_del_init(&ocw->ocw_entry);\r\nocw->ocw_rc = -EDQUOT;\r\nif ((cli->cl_dirty + PAGE_CACHE_SIZE > cli->cl_dirty_max) ||\r\n(atomic_read(&obd_dirty_pages) + 1 >\r\nobd_max_dirty_pages)) {\r\nCDEBUG(D_CACHE, "no dirty room: dirty: %ld "\r\n"osc max %ld, sys max %d\n", cli->cl_dirty,\r\ncli->cl_dirty_max, obd_max_dirty_pages);\r\ngoto wakeup;\r\n}\r\nocw->ocw_rc = 0;\r\nif (!osc_enter_cache_try(cli, ocw->ocw_oap, ocw->ocw_grant, 0))\r\nocw->ocw_rc = -EDQUOT;\r\nwakeup:\r\nCDEBUG(D_CACHE, "wake up %p for oap %p, avail grant %ld, %d\n",\r\nocw, ocw->ocw_oap, cli->cl_avail_grant, ocw->ocw_rc);\r\nwake_up(&ocw->ocw_waitq);\r\n}\r\n}\r\nstatic int osc_max_rpc_in_flight(struct client_obd *cli, struct osc_object *osc)\r\n{\r\nint hprpc = !!list_empty(&osc->oo_hp_exts);\r\nreturn rpcs_in_flight(cli) >= cli->cl_max_rpcs_in_flight + hprpc;\r\n}\r\nstatic int osc_makes_rpc(struct client_obd *cli, struct osc_object *osc,\r\nint cmd)\r\n{\r\nint invalid_import = 0;\r\nif ((cli->cl_import == NULL || cli->cl_import->imp_invalid))\r\ninvalid_import = 1;\r\nif (cmd & OBD_BRW_WRITE) {\r\nif (atomic_read(&osc->oo_nr_writes) == 0)\r\nreturn 0;\r\nif (invalid_import) {\r\nCDEBUG(D_CACHE, "invalid import forcing RPC\n");\r\nreturn 1;\r\n}\r\nif (!list_empty(&osc->oo_hp_exts)) {\r\nCDEBUG(D_CACHE, "high prio request forcing RPC\n");\r\nreturn 1;\r\n}\r\nif (!list_empty(&osc->oo_urgent_exts)) {\r\nCDEBUG(D_CACHE, "urgent request forcing RPC\n");\r\nreturn 1;\r\n}\r\nif (!list_empty(&cli->cl_cache_waiters)) {\r\nCDEBUG(D_CACHE, "cache waiters forcing RPC\n");\r\nreturn 1;\r\n}\r\nif (atomic_read(&osc->oo_nr_writes) >=\r\ncli->cl_max_pages_per_rpc)\r\nreturn 1;\r\n} else {\r\nif (atomic_read(&osc->oo_nr_reads) == 0)\r\nreturn 0;\r\nif (invalid_import) {\r\nCDEBUG(D_CACHE, "invalid import forcing RPC\n");\r\nreturn 1;\r\n}\r\nif (!list_empty(&osc->oo_reading_exts))\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void osc_update_pending(struct osc_object *obj, int cmd, int delta)\r\n{\r\nstruct client_obd *cli = osc_cli(obj);\r\nif (cmd & OBD_BRW_WRITE) {\r\natomic_add(delta, &obj->oo_nr_writes);\r\natomic_add(delta, &cli->cl_pending_w_pages);\r\nLASSERT(atomic_read(&obj->oo_nr_writes) >= 0);\r\n} else {\r\natomic_add(delta, &obj->oo_nr_reads);\r\natomic_add(delta, &cli->cl_pending_r_pages);\r\nLASSERT(atomic_read(&obj->oo_nr_reads) >= 0);\r\n}\r\nOSC_IO_DEBUG(obj, "update pending cmd %d delta %d.\n", cmd, delta);\r\n}\r\nstatic int osc_makes_hprpc(struct osc_object *obj)\r\n{\r\nreturn !list_empty(&obj->oo_hp_exts);\r\n}\r\nstatic void on_list(struct list_head *item, struct list_head *list, int should_be_on)\r\n{\r\nif (list_empty(item) && should_be_on)\r\nlist_add_tail(item, list);\r\nelse if (!list_empty(item) && !should_be_on)\r\nlist_del_init(item);\r\n}\r\nstatic int __osc_list_maint(struct client_obd *cli, struct osc_object *osc)\r\n{\r\nif (osc_makes_hprpc(osc)) {\r\non_list(&osc->oo_ready_item, &cli->cl_loi_ready_list, 0);\r\non_list(&osc->oo_hp_ready_item, &cli->cl_loi_hp_ready_list, 1);\r\n} else {\r\non_list(&osc->oo_hp_ready_item, &cli->cl_loi_hp_ready_list, 0);\r\non_list(&osc->oo_ready_item, &cli->cl_loi_ready_list,\r\nosc_makes_rpc(cli, osc, OBD_BRW_WRITE) ||\r\nosc_makes_rpc(cli, osc, OBD_BRW_READ));\r\n}\r\non_list(&osc->oo_write_item, &cli->cl_loi_write_list,\r\natomic_read(&osc->oo_nr_writes) > 0);\r\non_list(&osc->oo_read_item, &cli->cl_loi_read_list,\r\natomic_read(&osc->oo_nr_reads) > 0);\r\nreturn osc_is_ready(osc);\r\n}\r\nstatic int osc_list_maint(struct client_obd *cli, struct osc_object *osc)\r\n{\r\nint is_ready;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nis_ready = __osc_list_maint(cli, osc);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn is_ready;\r\n}\r\nstatic void osc_process_ar(struct osc_async_rc *ar, __u64 xid,\r\nint rc)\r\n{\r\nif (rc) {\r\nif (!ar->ar_rc)\r\nar->ar_rc = rc;\r\nar->ar_force_sync = 1;\r\nar->ar_min_xid = ptlrpc_sample_next_xid();\r\nreturn;\r\n}\r\nif (ar->ar_force_sync && (xid >= ar->ar_min_xid))\r\nar->ar_force_sync = 0;\r\n}\r\nstatic void osc_ap_completion(const struct lu_env *env, struct client_obd *cli,\r\nstruct osc_async_page *oap, int sent, int rc)\r\n{\r\nstruct osc_object *osc = oap->oap_obj;\r\nstruct lov_oinfo *loi = osc->oo_oinfo;\r\n__u64 xid = 0;\r\nif (oap->oap_request != NULL) {\r\nxid = ptlrpc_req_xid(oap->oap_request);\r\nptlrpc_req_finished(oap->oap_request);\r\noap->oap_request = NULL;\r\n}\r\nspin_lock(&oap->oap_lock);\r\noap->oap_async_flags = 0;\r\nspin_unlock(&oap->oap_lock);\r\noap->oap_interrupted = 0;\r\nif (oap->oap_cmd & OBD_BRW_WRITE && xid > 0) {\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nosc_process_ar(&cli->cl_ar, xid, rc);\r\nosc_process_ar(&loi->loi_ar, xid, rc);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\nrc = osc_completion(env, oap, oap->oap_cmd, rc);\r\nif (rc)\r\nCERROR("completion on oap %p obj %p returns %d.\n",\r\noap, osc, rc);\r\n}\r\nstatic int try_to_add_extent_for_io(struct client_obd *cli,\r\nstruct osc_extent *ext, struct list_head *rpclist,\r\nint *pc, unsigned int *max_pages)\r\n{\r\nstruct osc_extent *tmp;\r\nEASSERT((ext->oe_state == OES_CACHE || ext->oe_state == OES_LOCK_DONE),\r\next);\r\n*max_pages = max(ext->oe_mppr, *max_pages);\r\nif (*pc + ext->oe_nr_pages > *max_pages)\r\nreturn 0;\r\nlist_for_each_entry(tmp, rpclist, oe_link) {\r\nEASSERT(tmp->oe_owner == current, tmp);\r\n#if 0\r\nif (overlapped(tmp, ext)) {\r\nOSC_EXTENT_DUMP(D_ERROR, tmp, "overlapped %p.\n", ext);\r\nEASSERT(0, ext);\r\n}\r\n#endif\r\nif (tmp->oe_srvlock != ext->oe_srvlock ||\r\n!tmp->oe_grants != !ext->oe_grants)\r\nreturn 0;\r\nbreak;\r\n}\r\n*pc += ext->oe_nr_pages;\r\nlist_move_tail(&ext->oe_link, rpclist);\r\next->oe_owner = current;\r\nreturn 1;\r\n}\r\nstatic int get_write_extents(struct osc_object *obj, struct list_head *rpclist)\r\n{\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct osc_extent *ext;\r\nint page_count = 0;\r\nunsigned int max_pages = cli->cl_max_pages_per_rpc;\r\nLASSERT(osc_object_is_locked(obj));\r\nwhile (!list_empty(&obj->oo_hp_exts)) {\r\next = list_entry(obj->oo_hp_exts.next, struct osc_extent,\r\noe_link);\r\nLASSERT(ext->oe_state == OES_CACHE);\r\nif (!try_to_add_extent_for_io(cli, ext, rpclist, &page_count,\r\n&max_pages))\r\nreturn page_count;\r\nEASSERT(ext->oe_nr_pages <= max_pages, ext);\r\n}\r\nif (page_count == max_pages)\r\nreturn page_count;\r\nwhile (!list_empty(&obj->oo_urgent_exts)) {\r\next = list_entry(obj->oo_urgent_exts.next,\r\nstruct osc_extent, oe_link);\r\nif (!try_to_add_extent_for_io(cli, ext, rpclist, &page_count,\r\n&max_pages))\r\nreturn page_count;\r\nif (!ext->oe_intree)\r\ncontinue;\r\nwhile ((ext = next_extent(ext)) != NULL) {\r\nif ((ext->oe_state != OES_CACHE) ||\r\n(!list_empty(&ext->oe_link) &&\r\next->oe_owner != NULL))\r\ncontinue;\r\nif (!try_to_add_extent_for_io(cli, ext, rpclist,\r\n&page_count, &max_pages))\r\nreturn page_count;\r\n}\r\n}\r\nif (page_count == max_pages)\r\nreturn page_count;\r\next = first_extent(obj);\r\nwhile (ext != NULL) {\r\nif ((ext->oe_state != OES_CACHE) ||\r\n(!list_empty(&ext->oe_link) && ext->oe_owner != NULL)) {\r\next = next_extent(ext);\r\ncontinue;\r\n}\r\nif (!try_to_add_extent_for_io(cli, ext, rpclist, &page_count,\r\n&max_pages))\r\nreturn page_count;\r\next = next_extent(ext);\r\n}\r\nreturn page_count;\r\n}\r\nstatic int\r\nosc_send_write_rpc(const struct lu_env *env, struct client_obd *cli,\r\nstruct osc_object *osc, pdl_policy_t pol)\r\n{\r\nLIST_HEAD(rpclist);\r\nstruct osc_extent *ext;\r\nstruct osc_extent *tmp;\r\nstruct osc_extent *first = NULL;\r\nobd_count page_count = 0;\r\nint srvlock = 0;\r\nint rc = 0;\r\nLASSERT(osc_object_is_locked(osc));\r\npage_count = get_write_extents(osc, &rpclist);\r\nLASSERT(equi(page_count == 0, list_empty(&rpclist)));\r\nif (list_empty(&rpclist))\r\nreturn 0;\r\nosc_update_pending(osc, OBD_BRW_WRITE, -page_count);\r\nlist_for_each_entry(ext, &rpclist, oe_link) {\r\nLASSERT(ext->oe_state == OES_CACHE ||\r\next->oe_state == OES_LOCK_DONE);\r\nif (ext->oe_state == OES_CACHE)\r\nosc_extent_state_set(ext, OES_LOCKING);\r\nelse\r\nosc_extent_state_set(ext, OES_RPC);\r\n}\r\nosc_object_unlock(osc);\r\nlist_for_each_entry_safe(ext, tmp, &rpclist, oe_link) {\r\nif (ext->oe_state == OES_LOCKING) {\r\nrc = osc_extent_make_ready(env, ext);\r\nif (unlikely(rc < 0)) {\r\nlist_del_init(&ext->oe_link);\r\nosc_extent_finish(env, ext, 0, rc);\r\ncontinue;\r\n}\r\n}\r\nif (first == NULL) {\r\nfirst = ext;\r\nsrvlock = ext->oe_srvlock;\r\n} else {\r\nLASSERT(srvlock == ext->oe_srvlock);\r\n}\r\n}\r\nif (!list_empty(&rpclist)) {\r\nLASSERT(page_count > 0);\r\nrc = osc_build_rpc(env, cli, &rpclist, OBD_BRW_WRITE, pol);\r\nLASSERT(list_empty(&rpclist));\r\n}\r\nosc_object_lock(osc);\r\nreturn rc;\r\n}\r\nstatic int\r\nosc_send_read_rpc(const struct lu_env *env, struct client_obd *cli,\r\nstruct osc_object *osc, pdl_policy_t pol)\r\n{\r\nstruct osc_extent *ext;\r\nstruct osc_extent *next;\r\nLIST_HEAD(rpclist);\r\nint page_count = 0;\r\nunsigned int max_pages = cli->cl_max_pages_per_rpc;\r\nint rc = 0;\r\nLASSERT(osc_object_is_locked(osc));\r\nlist_for_each_entry_safe(ext, next,\r\n&osc->oo_reading_exts, oe_link) {\r\nEASSERT(ext->oe_state == OES_LOCK_DONE, ext);\r\nif (!try_to_add_extent_for_io(cli, ext, &rpclist, &page_count,\r\n&max_pages))\r\nbreak;\r\nosc_extent_state_set(ext, OES_RPC);\r\nEASSERT(ext->oe_nr_pages <= max_pages, ext);\r\n}\r\nLASSERT(page_count <= max_pages);\r\nosc_update_pending(osc, OBD_BRW_READ, -page_count);\r\nif (!list_empty(&rpclist)) {\r\nosc_object_unlock(osc);\r\nLASSERT(page_count > 0);\r\nrc = osc_build_rpc(env, cli, &rpclist, OBD_BRW_READ, pol);\r\nLASSERT(list_empty(&rpclist));\r\nosc_object_lock(osc);\r\n}\r\nreturn rc;\r\n}\r\nstatic struct osc_object *osc_next_obj(struct client_obd *cli)\r\n{\r\nif (!list_empty(&cli->cl_loi_hp_ready_list))\r\nreturn list_to_obj(&cli->cl_loi_hp_ready_list, hp_ready_item);\r\nif (!list_empty(&cli->cl_loi_ready_list))\r\nreturn list_to_obj(&cli->cl_loi_ready_list, ready_item);\r\nif (!list_empty(&cli->cl_cache_waiters) &&\r\n!list_empty(&cli->cl_loi_write_list))\r\nreturn list_to_obj(&cli->cl_loi_write_list, write_item);\r\nif (cli->cl_import == NULL || cli->cl_import->imp_invalid) {\r\nif (!list_empty(&cli->cl_loi_write_list))\r\nreturn list_to_obj(&cli->cl_loi_write_list, write_item);\r\nif (!list_empty(&cli->cl_loi_read_list))\r\nreturn list_to_obj(&cli->cl_loi_read_list, read_item);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void osc_check_rpcs(const struct lu_env *env, struct client_obd *cli,\r\npdl_policy_t pol)\r\n{\r\nstruct osc_object *osc;\r\nint rc = 0;\r\nwhile ((osc = osc_next_obj(cli)) != NULL) {\r\nstruct cl_object *obj = osc2cl(osc);\r\nstruct lu_ref_link link;\r\nOSC_IO_DEBUG(osc, "%lu in flight\n", rpcs_in_flight(cli));\r\nif (osc_max_rpc_in_flight(cli, osc)) {\r\n__osc_list_maint(cli, osc);\r\nbreak;\r\n}\r\ncl_object_get(obj);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nlu_object_ref_add_at(&obj->co_lu, &link, "check",\r\ncurrent);\r\nosc_object_lock(osc);\r\nif (osc_makes_rpc(cli, osc, OBD_BRW_WRITE)) {\r\nrc = osc_send_write_rpc(env, cli, osc, pol);\r\nif (rc < 0) {\r\nCERROR("Write request failed with %d\n", rc);\r\n}\r\n}\r\nif (osc_makes_rpc(cli, osc, OBD_BRW_READ)) {\r\nrc = osc_send_read_rpc(env, cli, osc, pol);\r\nif (rc < 0)\r\nCERROR("Read request failed with %d\n", rc);\r\n}\r\nosc_object_unlock(osc);\r\nosc_list_maint(cli, osc);\r\nlu_object_ref_del_at(&obj->co_lu, &link, "check",\r\ncurrent);\r\ncl_object_put(env, obj);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\n}\r\n}\r\nstatic int osc_io_unplug0(const struct lu_env *env, struct client_obd *cli,\r\nstruct osc_object *osc, pdl_policy_t pol, int async)\r\n{\r\nint rc = 0;\r\nif (osc != NULL && osc_list_maint(cli, osc) == 0)\r\nreturn 0;\r\nif (!async) {\r\natomic_inc(&cli->cl_lru_shrinkers);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nosc_check_rpcs(env, cli, pol);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\natomic_dec(&cli->cl_lru_shrinkers);\r\n} else {\r\nCDEBUG(D_CACHE, "Queue writeback work for client %p.\n", cli);\r\nLASSERT(cli->cl_writeback_work != NULL);\r\nrc = ptlrpcd_queue_work(cli->cl_writeback_work);\r\n}\r\nreturn rc;\r\n}\r\nstatic int osc_io_unplug_async(const struct lu_env *env,\r\nstruct client_obd *cli, struct osc_object *osc)\r\n{\r\nreturn osc_io_unplug0(env, cli, osc, PDL_POLICY_ROUND, 1);\r\n}\r\nvoid osc_io_unplug(const struct lu_env *env, struct client_obd *cli,\r\nstruct osc_object *osc, pdl_policy_t pol)\r\n{\r\n(void)osc_io_unplug0(env, cli, osc, pol, 0);\r\n}\r\nint osc_prep_async_page(struct osc_object *osc, struct osc_page *ops,\r\nstruct page *page, loff_t offset)\r\n{\r\nstruct obd_export *exp = osc_export(osc);\r\nstruct osc_async_page *oap = &ops->ops_oap;\r\nif (!page)\r\nreturn cfs_size_round(sizeof(*oap));\r\noap->oap_magic = OAP_MAGIC;\r\noap->oap_cli = &exp->exp_obd->u.cli;\r\noap->oap_obj = osc;\r\noap->oap_page = page;\r\noap->oap_obj_off = offset;\r\nLASSERT(!(offset & ~CFS_PAGE_MASK));\r\nif (!client_is_remote(exp) && cfs_capable(CFS_CAP_SYS_RESOURCE))\r\noap->oap_brw_flags = OBD_BRW_NOQUOTA;\r\nINIT_LIST_HEAD(&oap->oap_pending_item);\r\nINIT_LIST_HEAD(&oap->oap_rpc_item);\r\nspin_lock_init(&oap->oap_lock);\r\nCDEBUG(D_INFO, "oap %p page %p obj off "LPU64"\n",\r\noap, page, oap->oap_obj_off);\r\nreturn 0;\r\n}\r\nint osc_queue_async_io(const struct lu_env *env, struct cl_io *io,\r\nstruct osc_page *ops)\r\n{\r\nstruct osc_io *oio = osc_env_io(env);\r\nstruct osc_extent *ext = NULL;\r\nstruct osc_async_page *oap = &ops->ops_oap;\r\nstruct client_obd *cli = oap->oap_cli;\r\nstruct osc_object *osc = oap->oap_obj;\r\npgoff_t index;\r\nint grants = 0;\r\nint brw_flags = OBD_BRW_ASYNC;\r\nint cmd = OBD_BRW_WRITE;\r\nint need_release = 0;\r\nint rc = 0;\r\nif (oap->oap_magic != OAP_MAGIC)\r\nreturn -EINVAL;\r\nif (cli->cl_import == NULL || cli->cl_import->imp_invalid)\r\nreturn -EIO;\r\nif (!list_empty(&oap->oap_pending_item) ||\r\n!list_empty(&oap->oap_rpc_item))\r\nreturn -EBUSY;\r\nbrw_flags |= ops->ops_srvlock ? OBD_BRW_SRVLOCK : 0;\r\nif (!client_is_remote(osc_export(osc)) &&\r\ncfs_capable(CFS_CAP_SYS_RESOURCE)) {\r\nbrw_flags |= OBD_BRW_NOQUOTA;\r\ncmd |= OBD_BRW_NOQUOTA;\r\n}\r\nif (!(cmd & OBD_BRW_NOQUOTA)) {\r\nstruct cl_object *obj;\r\nstruct cl_attr *attr;\r\nunsigned int qid[MAXQUOTAS];\r\nobj = cl_object_top(&osc->oo_cl);\r\nattr = &osc_env_info(env)->oti_attr;\r\ncl_object_attr_lock(obj);\r\nrc = cl_object_attr_get(env, obj, attr);\r\ncl_object_attr_unlock(obj);\r\nqid[USRQUOTA] = attr->cat_uid;\r\nqid[GRPQUOTA] = attr->cat_gid;\r\nif (rc == 0 && osc_quota_chkdq(cli, qid) == NO_QUOTA)\r\nrc = -EDQUOT;\r\nif (rc)\r\nreturn rc;\r\n}\r\noap->oap_cmd = cmd;\r\noap->oap_page_off = ops->ops_from;\r\noap->oap_count = ops->ops_to - ops->ops_from;\r\noap->oap_async_flags = 0;\r\noap->oap_brw_flags = brw_flags;\r\nOSC_IO_DEBUG(osc, "oap %p page %p added for cmd %d\n",\r\noap, oap->oap_page, oap->oap_cmd & OBD_BRW_RWMASK);\r\nindex = oap2cl_page(oap)->cp_index;\r\next = oio->oi_active;\r\nif (ext != NULL && ext->oe_start <= index && ext->oe_max_end >= index) {\r\ngrants = (1 << cli->cl_chunkbits) + cli->cl_extent_tax;\r\nif (ext->oe_end >= index)\r\ngrants = 0;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nrc = osc_enter_cache_try(cli, oap, grants, 0);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nif (rc == 0) {\r\ngrants = 0;\r\nneed_release = 1;\r\n} else if (ext->oe_end < index) {\r\nint tmp = grants;\r\nrc = osc_extent_expand(ext, index, &tmp);\r\nif (rc < 0) {\r\nneed_release = 1;\r\n} else {\r\nOSC_EXTENT_DUMP(D_CACHE, ext,\r\n"expanded for %lu.\n", index);\r\nosc_unreserve_grant(cli, grants, tmp);\r\ngrants = 0;\r\n}\r\n}\r\nrc = 0;\r\n} else if (ext != NULL) {\r\nneed_release = 1;\r\n}\r\nif (need_release) {\r\nosc_extent_release(env, ext);\r\noio->oi_active = NULL;\r\next = NULL;\r\n}\r\nif (ext == NULL) {\r\nint tmp = (1 << cli->cl_chunkbits) + cli->cl_extent_tax;\r\nLASSERT(oio->oi_active == NULL);\r\nLASSERT(ergo(grants > 0, grants >= tmp));\r\nrc = 0;\r\nif (grants == 0) {\r\nrc = osc_enter_cache(env, cli, oap, tmp);\r\nif (rc == 0)\r\ngrants = tmp;\r\n}\r\ntmp = grants;\r\nif (rc == 0) {\r\next = osc_extent_find(env, osc, index, &tmp);\r\nif (IS_ERR(ext)) {\r\nLASSERT(tmp == grants);\r\nosc_exit_cache(cli, oap);\r\nrc = PTR_ERR(ext);\r\next = NULL;\r\n} else {\r\noio->oi_active = ext;\r\n}\r\n}\r\nif (grants > 0)\r\nosc_unreserve_grant(cli, grants, tmp);\r\n}\r\nLASSERT(ergo(rc == 0, ext != NULL));\r\nif (ext != NULL) {\r\nEASSERTF(ext->oe_end >= index && ext->oe_start <= index,\r\next, "index = %lu.\n", index);\r\nLASSERT((oap->oap_brw_flags & OBD_BRW_FROM_GRANT) != 0);\r\nosc_object_lock(osc);\r\nif (ext->oe_nr_pages == 0)\r\next->oe_srvlock = ops->ops_srvlock;\r\nelse\r\nLASSERT(ext->oe_srvlock == ops->ops_srvlock);\r\n++ext->oe_nr_pages;\r\nlist_add_tail(&oap->oap_pending_item, &ext->oe_pages);\r\nosc_object_unlock(osc);\r\n}\r\nreturn rc;\r\n}\r\nint osc_teardown_async_page(const struct lu_env *env,\r\nstruct osc_object *obj, struct osc_page *ops)\r\n{\r\nstruct osc_async_page *oap = &ops->ops_oap;\r\nstruct osc_extent *ext = NULL;\r\nint rc = 0;\r\nLASSERT(oap->oap_magic == OAP_MAGIC);\r\nCDEBUG(D_INFO, "teardown oap %p page %p at index %lu.\n",\r\noap, ops, oap2cl_page(oap)->cp_index);\r\nosc_object_lock(obj);\r\nif (!list_empty(&oap->oap_rpc_item)) {\r\nCDEBUG(D_CACHE, "oap %p is not in cache.\n", oap);\r\nrc = -EBUSY;\r\n} else if (!list_empty(&oap->oap_pending_item)) {\r\next = osc_extent_lookup(obj, oap2cl_page(oap)->cp_index);\r\nif (ext != NULL && ext->oe_state != OES_TRUNC) {\r\nOSC_EXTENT_DUMP(D_ERROR, ext, "trunc at %lu.\n",\r\noap2cl_page(oap)->cp_index);\r\nrc = -EBUSY;\r\n}\r\n}\r\nosc_object_unlock(obj);\r\nif (ext != NULL)\r\nosc_extent_put(env, ext);\r\nreturn rc;\r\n}\r\nint osc_flush_async_page(const struct lu_env *env, struct cl_io *io,\r\nstruct osc_page *ops)\r\n{\r\nstruct osc_extent *ext = NULL;\r\nstruct osc_object *obj = cl2osc(ops->ops_cl.cpl_obj);\r\nstruct cl_page *cp = ops->ops_cl.cpl_page;\r\npgoff_t index = cp->cp_index;\r\nstruct osc_async_page *oap = &ops->ops_oap;\r\nbool unplug = false;\r\nint rc = 0;\r\nosc_object_lock(obj);\r\next = osc_extent_lookup(obj, index);\r\nif (ext == NULL) {\r\nosc_extent_tree_dump(D_ERROR, obj);\r\nLASSERTF(0, "page index %lu is NOT covered.\n", index);\r\n}\r\nswitch (ext->oe_state) {\r\ncase OES_RPC:\r\ncase OES_LOCK_DONE:\r\nCL_PAGE_DEBUG(D_ERROR, env, cl_page_top(cp),\r\n"flush an in-rpc page?\n");\r\nLASSERT(0);\r\nbreak;\r\ncase OES_LOCKING:\r\ncase OES_TRUNC:\r\nGOTO(out, rc = -EAGAIN);\r\ndefault:\r\nbreak;\r\n}\r\nrc = cl_page_prep(env, io, cl_page_top(cp), CRT_WRITE);\r\nif (rc)\r\nGOTO(out, rc);\r\nspin_lock(&oap->oap_lock);\r\noap->oap_async_flags |= ASYNC_READY|ASYNC_URGENT;\r\nspin_unlock(&oap->oap_lock);\r\nif (memory_pressure_get())\r\next->oe_memalloc = 1;\r\next->oe_urgent = 1;\r\nif (ext->oe_state == OES_CACHE) {\r\nOSC_EXTENT_DUMP(D_CACHE, ext,\r\n"flush page %p make it urgent.\n", oap);\r\nif (list_empty(&ext->oe_link))\r\nlist_add_tail(&ext->oe_link, &obj->oo_urgent_exts);\r\nunplug = true;\r\n}\r\nrc = 0;\r\nout:\r\nosc_object_unlock(obj);\r\nosc_extent_put(env, ext);\r\nif (unplug)\r\nosc_io_unplug_async(env, osc_cli(obj), obj);\r\nreturn rc;\r\n}\r\nint osc_cancel_async_page(const struct lu_env *env, struct osc_page *ops)\r\n{\r\nstruct osc_async_page *oap = &ops->ops_oap;\r\nstruct osc_object *obj = oap->oap_obj;\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct osc_extent *ext;\r\nstruct osc_extent *found = NULL;\r\nstruct list_head *plist;\r\npgoff_t index = oap2cl_page(oap)->cp_index;\r\nint rc = -EBUSY;\r\nint cmd;\r\nLASSERT(!oap->oap_interrupted);\r\noap->oap_interrupted = 1;\r\nosc_object_lock(obj);\r\nif (oap->oap_cmd & OBD_BRW_WRITE) {\r\nplist = &obj->oo_urgent_exts;\r\ncmd = OBD_BRW_WRITE;\r\n} else {\r\nplist = &obj->oo_reading_exts;\r\ncmd = OBD_BRW_READ;\r\n}\r\nlist_for_each_entry(ext, plist, oe_link) {\r\nif (ext->oe_start <= index && ext->oe_end >= index) {\r\nLASSERT(ext->oe_state == OES_LOCK_DONE);\r\nfound = osc_extent_get(ext);\r\nbreak;\r\n}\r\n}\r\nif (found != NULL) {\r\nlist_del_init(&found->oe_link);\r\nosc_update_pending(obj, cmd, -found->oe_nr_pages);\r\nosc_object_unlock(obj);\r\nosc_extent_finish(env, found, 0, -EINTR);\r\nosc_extent_put(env, found);\r\nrc = 0;\r\n} else {\r\nosc_object_unlock(obj);\r\nif (oap->oap_request != NULL) {\r\nptlrpc_mark_interrupted(oap->oap_request);\r\nptlrpcd_wake(oap->oap_request);\r\nptlrpc_req_finished(oap->oap_request);\r\noap->oap_request = NULL;\r\n}\r\n}\r\nosc_list_maint(cli, obj);\r\nreturn rc;\r\n}\r\nint osc_queue_sync_pages(const struct lu_env *env, struct osc_object *obj,\r\nstruct list_head *list, int cmd, int brw_flags)\r\n{\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct osc_extent *ext;\r\nstruct osc_async_page *oap, *tmp;\r\nint page_count = 0;\r\nint mppr = cli->cl_max_pages_per_rpc;\r\npgoff_t start = CL_PAGE_EOF;\r\npgoff_t end = 0;\r\nlist_for_each_entry(oap, list, oap_pending_item) {\r\nstruct cl_page *cp = oap2cl_page(oap);\r\nif (cp->cp_index > end)\r\nend = cp->cp_index;\r\nif (cp->cp_index < start)\r\nstart = cp->cp_index;\r\n++page_count;\r\nmppr <<= (page_count > mppr);\r\n}\r\next = osc_extent_alloc(obj);\r\nif (ext == NULL) {\r\nlist_for_each_entry_safe(oap, tmp, list, oap_pending_item) {\r\nlist_del_init(&oap->oap_pending_item);\r\nosc_ap_completion(env, cli, oap, 0, -ENOMEM);\r\n}\r\nreturn -ENOMEM;\r\n}\r\next->oe_rw = !!(cmd & OBD_BRW_READ);\r\next->oe_urgent = 1;\r\next->oe_start = start;\r\next->oe_end = ext->oe_max_end = end;\r\next->oe_obj = obj;\r\next->oe_srvlock = !!(brw_flags & OBD_BRW_SRVLOCK);\r\next->oe_nr_pages = page_count;\r\next->oe_mppr = mppr;\r\nlist_splice_init(list, &ext->oe_pages);\r\nosc_object_lock(obj);\r\nosc_extent_state_set(ext, OES_LOCK_DONE);\r\nif (cmd & OBD_BRW_WRITE) {\r\nlist_add_tail(&ext->oe_link, &obj->oo_urgent_exts);\r\nosc_update_pending(obj, OBD_BRW_WRITE, page_count);\r\n} else {\r\nlist_add_tail(&ext->oe_link, &obj->oo_reading_exts);\r\nosc_update_pending(obj, OBD_BRW_READ, page_count);\r\n}\r\nosc_object_unlock(obj);\r\nosc_io_unplug(env, cli, obj, PDL_POLICY_ROUND);\r\nreturn 0;\r\n}\r\nint osc_cache_truncate_start(const struct lu_env *env, struct osc_io *oio,\r\nstruct osc_object *obj, __u64 size)\r\n{\r\nstruct client_obd *cli = osc_cli(obj);\r\nstruct osc_extent *ext;\r\nstruct osc_extent *waiting = NULL;\r\npgoff_t index;\r\nLIST_HEAD(list);\r\nint result = 0;\r\nbool partial;\r\nindex = cl_index(osc2cl(obj), size);\r\npartial = size > cl_offset(osc2cl(obj), index);\r\nagain:\r\nosc_object_lock(obj);\r\next = osc_extent_search(obj, index);\r\nif (ext == NULL)\r\next = first_extent(obj);\r\nelse if (ext->oe_end < index)\r\next = next_extent(ext);\r\nwhile (ext != NULL) {\r\nEASSERT(ext->oe_state != OES_TRUNC, ext);\r\nif (ext->oe_state > OES_CACHE || ext->oe_urgent) {\r\nLASSERT(!ext->oe_hp);\r\nOSC_EXTENT_DUMP(D_CACHE, ext,\r\n"waiting for busy extent\n");\r\nwaiting = osc_extent_get(ext);\r\nbreak;\r\n}\r\nOSC_EXTENT_DUMP(D_CACHE, ext, "try to trunc:"LPU64".\n", size);\r\nosc_extent_get(ext);\r\nif (ext->oe_state == OES_ACTIVE) {\r\nLASSERT(!ext->oe_trunc_pending);\r\next->oe_trunc_pending = 1;\r\n} else {\r\nEASSERT(ext->oe_state == OES_CACHE, ext);\r\nosc_extent_state_set(ext, OES_TRUNC);\r\nosc_update_pending(obj, OBD_BRW_WRITE,\r\n-ext->oe_nr_pages);\r\n}\r\nEASSERT(list_empty(&ext->oe_link), ext);\r\nlist_add_tail(&ext->oe_link, &list);\r\next = next_extent(ext);\r\n}\r\nosc_object_unlock(obj);\r\nosc_list_maint(cli, obj);\r\nwhile (!list_empty(&list)) {\r\nint rc;\r\next = list_entry(list.next, struct osc_extent, oe_link);\r\nlist_del_init(&ext->oe_link);\r\nif (ext->oe_state != OES_TRUNC)\r\nosc_extent_wait(env, ext, OES_TRUNC);\r\nrc = osc_extent_truncate(ext, index, partial);\r\nif (rc < 0) {\r\nif (result == 0)\r\nresult = rc;\r\nOSC_EXTENT_DUMP(D_ERROR, ext,\r\n"truncate error %d\n", rc);\r\n} else if (ext->oe_nr_pages == 0) {\r\nosc_extent_remove(ext);\r\n} else {\r\nEASSERTF(ext->oe_start <= index, ext,\r\n"trunc index = %lu/%d.\n", index, partial);\r\nindex = ext->oe_end + 1;\r\npartial = false;\r\nLASSERT(oio->oi_trunc == NULL);\r\noio->oi_trunc = osc_extent_get(ext);\r\nOSC_EXTENT_DUMP(D_CACHE, ext,\r\n"trunc at "LPU64"\n", size);\r\n}\r\nosc_extent_put(env, ext);\r\n}\r\nif (waiting != NULL) {\r\nint rc;\r\nrc = osc_extent_wait(env, waiting, OES_INV);\r\nif (rc < 0)\r\nOSC_EXTENT_DUMP(D_CACHE, waiting, "error: %d.\n", rc);\r\nosc_extent_put(env, waiting);\r\nwaiting = NULL;\r\ngoto again;\r\n}\r\nreturn result;\r\n}\r\nvoid osc_cache_truncate_end(const struct lu_env *env, struct osc_io *oio,\r\nstruct osc_object *obj)\r\n{\r\nstruct osc_extent *ext = oio->oi_trunc;\r\noio->oi_trunc = NULL;\r\nif (ext != NULL) {\r\nbool unplug = false;\r\nEASSERT(ext->oe_nr_pages > 0, ext);\r\nEASSERT(ext->oe_state == OES_TRUNC, ext);\r\nEASSERT(!ext->oe_urgent, ext);\r\nOSC_EXTENT_DUMP(D_CACHE, ext, "trunc -> cache.\n");\r\nosc_object_lock(obj);\r\nosc_extent_state_set(ext, OES_CACHE);\r\nif (ext->oe_fsync_wait && !ext->oe_urgent) {\r\next->oe_urgent = 1;\r\nlist_move_tail(&ext->oe_link, &obj->oo_urgent_exts);\r\nunplug = true;\r\n}\r\nosc_update_pending(obj, OBD_BRW_WRITE, ext->oe_nr_pages);\r\nosc_object_unlock(obj);\r\nosc_extent_put(env, ext);\r\nif (unplug)\r\nosc_io_unplug_async(env, osc_cli(obj), obj);\r\n}\r\n}\r\nint osc_cache_wait_range(const struct lu_env *env, struct osc_object *obj,\r\npgoff_t start, pgoff_t end)\r\n{\r\nstruct osc_extent *ext;\r\npgoff_t index = start;\r\nint result = 0;\r\nagain:\r\nosc_object_lock(obj);\r\next = osc_extent_search(obj, index);\r\nif (ext == NULL)\r\next = first_extent(obj);\r\nelse if (ext->oe_end < index)\r\next = next_extent(ext);\r\nwhile (ext != NULL) {\r\nint rc;\r\nif (ext->oe_start > end)\r\nbreak;\r\nif (!ext->oe_fsync_wait) {\r\next = next_extent(ext);\r\ncontinue;\r\n}\r\nEASSERT(ergo(ext->oe_state == OES_CACHE,\r\next->oe_hp || ext->oe_urgent), ext);\r\nEASSERT(ergo(ext->oe_state == OES_ACTIVE,\r\n!ext->oe_hp && ext->oe_urgent), ext);\r\nindex = ext->oe_end + 1;\r\nosc_extent_get(ext);\r\nosc_object_unlock(obj);\r\nrc = osc_extent_wait(env, ext, OES_INV);\r\nif (result == 0)\r\nresult = rc;\r\nosc_extent_put(env, ext);\r\ngoto again;\r\n}\r\nosc_object_unlock(obj);\r\nOSC_IO_DEBUG(obj, "sync file range.\n");\r\nreturn result;\r\n}\r\nint osc_cache_writeback_range(const struct lu_env *env, struct osc_object *obj,\r\npgoff_t start, pgoff_t end, int hp, int discard)\r\n{\r\nstruct osc_extent *ext;\r\nLIST_HEAD(discard_list);\r\nbool unplug = false;\r\nint result = 0;\r\nosc_object_lock(obj);\r\next = osc_extent_search(obj, start);\r\nif (ext == NULL)\r\next = first_extent(obj);\r\nelse if (ext->oe_end < start)\r\next = next_extent(ext);\r\nwhile (ext != NULL) {\r\nif (ext->oe_start > end)\r\nbreak;\r\next->oe_fsync_wait = 1;\r\nswitch (ext->oe_state) {\r\ncase OES_CACHE:\r\nresult += ext->oe_nr_pages;\r\nif (!discard) {\r\nstruct list_head *list = NULL;\r\nif (hp) {\r\nEASSERT(!ext->oe_hp, ext);\r\next->oe_hp = 1;\r\nlist = &obj->oo_hp_exts;\r\n} else if (!ext->oe_urgent) {\r\next->oe_urgent = 1;\r\nlist = &obj->oo_urgent_exts;\r\n}\r\nif (list != NULL)\r\nlist_move_tail(&ext->oe_link, list);\r\nunplug = true;\r\n} else {\r\nEASSERT(ext->oe_start >= start &&\r\next->oe_max_end <= end, ext);\r\nosc_extent_state_set(ext, OES_LOCKING);\r\next->oe_owner = current;\r\nlist_move_tail(&ext->oe_link,\r\n&discard_list);\r\nosc_update_pending(obj, OBD_BRW_WRITE,\r\n-ext->oe_nr_pages);\r\n}\r\nbreak;\r\ncase OES_ACTIVE:\r\nLASSERT(hp == 0 && discard == 0);\r\next->oe_urgent = 1;\r\nbreak;\r\ncase OES_TRUNC:\r\ndefault:\r\nbreak;\r\n}\r\next = next_extent(ext);\r\n}\r\nosc_object_unlock(obj);\r\nLASSERT(ergo(!discard, list_empty(&discard_list)));\r\nif (!list_empty(&discard_list)) {\r\nstruct osc_extent *tmp;\r\nint rc;\r\nosc_list_maint(osc_cli(obj), obj);\r\nlist_for_each_entry_safe(ext, tmp, &discard_list, oe_link) {\r\nlist_del_init(&ext->oe_link);\r\nEASSERT(ext->oe_state == OES_LOCKING, ext);\r\nrc = osc_extent_make_ready(env, ext);\r\nif (unlikely(rc < 0)) {\r\nOSC_EXTENT_DUMP(D_ERROR, ext,\r\n"make_ready returned %d\n", rc);\r\nif (result >= 0)\r\nresult = rc;\r\n}\r\nosc_extent_finish(env, ext, 0, 0);\r\n}\r\n}\r\nif (unplug)\r\nosc_io_unplug(env, osc_cli(obj), obj, PDL_POLICY_ROUND);\r\nif (hp || discard) {\r\nint rc;\r\nrc = osc_cache_wait_range(env, obj, start, end);\r\nif (result >= 0 && rc < 0)\r\nresult = rc;\r\n}\r\nOSC_IO_DEBUG(obj, "cache page out.\n");\r\nreturn result;\r\n}
