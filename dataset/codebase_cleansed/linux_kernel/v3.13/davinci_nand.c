static inline unsigned int davinci_nand_readl(struct davinci_nand_info *info,\r\nint offset)\r\n{\r\nreturn __raw_readl(info->base + offset);\r\n}\r\nstatic inline void davinci_nand_writel(struct davinci_nand_info *info,\r\nint offset, unsigned long value)\r\n{\r\n__raw_writel(value, info->base + offset);\r\n}\r\nstatic void nand_davinci_hwcontrol(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nuint32_t addr = info->current_cs;\r\nstruct nand_chip *nand = mtd->priv;\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nif ((ctrl & NAND_CTRL_CLE) == NAND_CTRL_CLE)\r\naddr |= info->mask_cle;\r\nelse if ((ctrl & NAND_CTRL_ALE) == NAND_CTRL_ALE)\r\naddr |= info->mask_ale;\r\nnand->IO_ADDR_W = (void __iomem __force *)addr;\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\niowrite8(cmd, nand->IO_ADDR_W);\r\n}\r\nstatic void nand_davinci_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nuint32_t addr = info->ioaddr;\r\nif (chip > 0)\r\naddr |= info->mask_chipsel;\r\ninfo->current_cs = addr;\r\ninfo->chip.IO_ADDR_W = (void __iomem __force *)addr;\r\ninfo->chip.IO_ADDR_R = info->chip.IO_ADDR_W;\r\n}\r\nstatic inline uint32_t nand_davinci_readecc_1bit(struct mtd_info *mtd)\r\n{\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nreturn davinci_nand_readl(info, NANDF1ECC_OFFSET\r\n+ 4 * info->core_chipsel);\r\n}\r\nstatic void nand_davinci_hwctl_1bit(struct mtd_info *mtd, int mode)\r\n{\r\nstruct davinci_nand_info *info;\r\nuint32_t nandcfr;\r\nunsigned long flags;\r\ninfo = to_davinci_nand(mtd);\r\nnand_davinci_readecc_1bit(mtd);\r\nspin_lock_irqsave(&davinci_nand_lock, flags);\r\nnandcfr = davinci_nand_readl(info, NANDFCR_OFFSET);\r\nnandcfr |= BIT(8 + info->core_chipsel);\r\ndavinci_nand_writel(info, NANDFCR_OFFSET, nandcfr);\r\nspin_unlock_irqrestore(&davinci_nand_lock, flags);\r\n}\r\nstatic int nand_davinci_calculate_1bit(struct mtd_info *mtd,\r\nconst u_char *dat, u_char *ecc_code)\r\n{\r\nunsigned int ecc_val = nand_davinci_readecc_1bit(mtd);\r\nunsigned int ecc24 = (ecc_val & 0x0fff) | ((ecc_val & 0x0fff0000) >> 4);\r\necc24 = ~ecc24;\r\necc_code[0] = (u_char)(ecc24);\r\necc_code[1] = (u_char)(ecc24 >> 8);\r\necc_code[2] = (u_char)(ecc24 >> 16);\r\nreturn 0;\r\n}\r\nstatic int nand_davinci_correct_1bit(struct mtd_info *mtd, u_char *dat,\r\nu_char *read_ecc, u_char *calc_ecc)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nuint32_t eccNand = read_ecc[0] | (read_ecc[1] << 8) |\r\n(read_ecc[2] << 16);\r\nuint32_t eccCalc = calc_ecc[0] | (calc_ecc[1] << 8) |\r\n(calc_ecc[2] << 16);\r\nuint32_t diff = eccCalc ^ eccNand;\r\nif (diff) {\r\nif ((((diff >> 12) ^ diff) & 0xfff) == 0xfff) {\r\nif ((diff >> (12 + 3)) < chip->ecc.size) {\r\ndat[diff >> (12 + 3)] ^= BIT((diff >> 12) & 7);\r\nreturn 1;\r\n} else {\r\nreturn -1;\r\n}\r\n} else if (!(diff & (diff - 1))) {\r\nreturn 1;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)\r\n{\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&davinci_nand_lock, flags);\r\nval = davinci_nand_readl(info, NANDFCR_OFFSET);\r\nval &= ~(0x03 << 4);\r\nval |= (info->core_chipsel << 4) | BIT(12);\r\ndavinci_nand_writel(info, NANDFCR_OFFSET, val);\r\ninfo->is_readmode = (mode == NAND_ECC_READ);\r\nspin_unlock_irqrestore(&davinci_nand_lock, flags);\r\n}\r\nstatic void\r\nnand_davinci_readecc_4bit(struct davinci_nand_info *info, u32 code[4])\r\n{\r\nconst u32 mask = 0x03ff03ff;\r\ncode[0] = davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET) & mask;\r\ncode[1] = davinci_nand_readl(info, NAND_4BIT_ECC2_OFFSET) & mask;\r\ncode[2] = davinci_nand_readl(info, NAND_4BIT_ECC3_OFFSET) & mask;\r\ncode[3] = davinci_nand_readl(info, NAND_4BIT_ECC4_OFFSET) & mask;\r\n}\r\nstatic int nand_davinci_calculate_4bit(struct mtd_info *mtd,\r\nconst u_char *dat, u_char *ecc_code)\r\n{\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nu32 raw_ecc[4], *p;\r\nunsigned i;\r\nif (info->is_readmode) {\r\ndavinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);\r\nreturn 0;\r\n}\r\nnand_davinci_readecc_4bit(info, raw_ecc);\r\nfor (i = 0, p = raw_ecc; i < 2; i++, p += 2) {\r\n*ecc_code++ = p[0] & 0xff;\r\n*ecc_code++ = ((p[0] >> 8) & 0x03) | ((p[0] >> 14) & 0xfc);\r\n*ecc_code++ = ((p[0] >> 22) & 0x0f) | ((p[1] << 4) & 0xf0);\r\n*ecc_code++ = ((p[1] >> 4) & 0x3f) | ((p[1] >> 10) & 0xc0);\r\n*ecc_code++ = (p[1] >> 18) & 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nand_davinci_correct_4bit(struct mtd_info *mtd,\r\nu_char *data, u_char *ecc_code, u_char *null)\r\n{\r\nint i;\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nunsigned short ecc10[8];\r\nunsigned short *ecc16;\r\nu32 syndrome[4];\r\nu32 ecc_state;\r\nunsigned num_errors, corrected;\r\nunsigned long timeo;\r\nfor (i = 0; i < 10; i++) {\r\nif (ecc_code[i] != 0xff)\r\ngoto compare;\r\n}\r\nreturn 0;\r\ncompare:\r\nif (WARN_ON(0x01 & (unsigned) ecc_code))\r\nreturn -EINVAL;\r\necc16 = (unsigned short *)ecc_code;\r\necc10[0] = (ecc16[0] >> 0) & 0x3ff;\r\necc10[1] = ((ecc16[0] >> 10) & 0x3f) | ((ecc16[1] << 6) & 0x3c0);\r\necc10[2] = (ecc16[1] >> 4) & 0x3ff;\r\necc10[3] = ((ecc16[1] >> 14) & 0x3) | ((ecc16[2] << 2) & 0x3fc);\r\necc10[4] = (ecc16[2] >> 8) | ((ecc16[3] << 8) & 0x300);\r\necc10[5] = (ecc16[3] >> 2) & 0x3ff;\r\necc10[6] = ((ecc16[3] >> 12) & 0xf) | ((ecc16[4] << 4) & 0x3f0);\r\necc10[7] = (ecc16[4] >> 6) & 0x3ff;\r\nfor (i = 7; i >= 0; i--)\r\ndavinci_nand_writel(info, NAND_4BIT_ECC_LOAD_OFFSET, ecc10[i]);\r\ndavinci_nand_readl(info, NANDFSR_OFFSET);\r\nnand_davinci_readecc_4bit(info, syndrome);\r\nif (!(syndrome[0] | syndrome[1] | syndrome[2] | syndrome[3]))\r\nreturn 0;\r\ndavinci_nand_readl(info, NAND_ERR_ADD1_OFFSET);\r\ndavinci_nand_writel(info, NANDFCR_OFFSET,\r\ndavinci_nand_readl(info, NANDFCR_OFFSET) | BIT(13));\r\ntimeo = jiffies + usecs_to_jiffies(100);\r\ndo {\r\necc_state = (davinci_nand_readl(info,\r\nNANDFSR_OFFSET) >> 8) & 0x0f;\r\ncpu_relax();\r\n} while ((ecc_state < 4) && time_before(jiffies, timeo));\r\nfor (;;) {\r\nu32 fsr = davinci_nand_readl(info, NANDFSR_OFFSET);\r\nswitch ((fsr >> 8) & 0x0f) {\r\ncase 0:\r\ndavinci_nand_readl(info, NAND_ERR_ERRVAL1_OFFSET);\r\nreturn 0;\r\ncase 1:\r\ndavinci_nand_readl(info, NAND_ERR_ERRVAL1_OFFSET);\r\nreturn -EIO;\r\ncase 2:\r\ncase 3:\r\nnum_errors = 1 + ((fsr >> 16) & 0x03);\r\ngoto correct;\r\ndefault:\r\ncpu_relax();\r\ncontinue;\r\n}\r\n}\r\ncorrect:\r\nfor (i = 0, corrected = 0; i < num_errors; i++) {\r\nint error_address, error_value;\r\nif (i > 1) {\r\nerror_address = davinci_nand_readl(info,\r\nNAND_ERR_ADD2_OFFSET);\r\nerror_value = davinci_nand_readl(info,\r\nNAND_ERR_ERRVAL2_OFFSET);\r\n} else {\r\nerror_address = davinci_nand_readl(info,\r\nNAND_ERR_ADD1_OFFSET);\r\nerror_value = davinci_nand_readl(info,\r\nNAND_ERR_ERRVAL1_OFFSET);\r\n}\r\nif (i & 1) {\r\nerror_address >>= 16;\r\nerror_value >>= 16;\r\n}\r\nerror_address &= 0x3ff;\r\nerror_address = (512 + 7) - error_address;\r\nif (error_address < 512) {\r\ndata[error_address] ^= error_value;\r\ncorrected++;\r\n}\r\n}\r\nreturn corrected;\r\n}\r\nstatic void nand_davinci_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif ((0x03 & ((unsigned)buf)) == 0 && (0x03 & len) == 0)\r\nioread32_rep(chip->IO_ADDR_R, buf, len >> 2);\r\nelse if ((0x01 & ((unsigned)buf)) == 0 && (0x01 & len) == 0)\r\nioread16_rep(chip->IO_ADDR_R, buf, len >> 1);\r\nelse\r\nioread8_rep(chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic void nand_davinci_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd->priv;\r\nif ((0x03 & ((unsigned)buf)) == 0 && (0x03 & len) == 0)\r\niowrite32_rep(chip->IO_ADDR_R, buf, len >> 2);\r\nelse if ((0x01 & ((unsigned)buf)) == 0 && (0x01 & len) == 0)\r\niowrite16_rep(chip->IO_ADDR_R, buf, len >> 1);\r\nelse\r\niowrite8_rep(chip->IO_ADDR_R, buf, len);\r\n}\r\nstatic int nand_davinci_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct davinci_nand_info *info = to_davinci_nand(mtd);\r\nreturn davinci_nand_readl(info, NANDFSR_OFFSET) & BIT(0);\r\n}\r\nstatic struct davinci_nand_pdata\r\n*nand_davinci_get_pdata(struct platform_device *pdev)\r\n{\r\nif (!dev_get_platdata(&pdev->dev) && pdev->dev.of_node) {\r\nstruct davinci_nand_pdata *pdata;\r\nconst char *mode;\r\nu32 prop;\r\nint len;\r\npdata = devm_kzalloc(&pdev->dev,\r\nsizeof(struct davinci_nand_pdata),\r\nGFP_KERNEL);\r\npdev->dev.platform_data = pdata;\r\nif (!pdata)\r\nreturn NULL;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"ti,davinci-chipselect", &prop))\r\npdev->id = prop;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"ti,davinci-mask-ale", &prop))\r\npdata->mask_ale = prop;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"ti,davinci-mask-cle", &prop))\r\npdata->mask_cle = prop;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"ti,davinci-mask-chipsel", &prop))\r\npdata->mask_chipsel = prop;\r\nif (!of_property_read_string(pdev->dev.of_node,\r\n"ti,davinci-ecc-mode", &mode)) {\r\nif (!strncmp("none", mode, 4))\r\npdata->ecc_mode = NAND_ECC_NONE;\r\nif (!strncmp("soft", mode, 4))\r\npdata->ecc_mode = NAND_ECC_SOFT;\r\nif (!strncmp("hw", mode, 2))\r\npdata->ecc_mode = NAND_ECC_HW;\r\n}\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"ti,davinci-ecc-bits", &prop))\r\npdata->ecc_bits = prop;\r\nif (!of_property_read_u32(pdev->dev.of_node,\r\n"ti,davinci-nand-buswidth", &prop))\r\nif (prop == 16)\r\npdata->options |= NAND_BUSWIDTH_16;\r\nif (of_find_property(pdev->dev.of_node,\r\n"ti,davinci-nand-use-bbt", &len))\r\npdata->bbt_options = NAND_BBT_USE_FLASH;\r\n}\r\nreturn dev_get_platdata(&pdev->dev);\r\n}\r\nstatic struct davinci_nand_pdata\r\n*nand_davinci_get_pdata(struct platform_device *pdev)\r\n{\r\nreturn dev_get_platdata(&pdev->dev);\r\n}\r\nstatic int __init nand_davinci_probe(struct platform_device *pdev)\r\n{\r\nstruct davinci_nand_pdata *pdata;\r\nstruct davinci_nand_info *info;\r\nstruct resource *res1;\r\nstruct resource *res2;\r\nvoid __iomem *vaddr;\r\nvoid __iomem *base;\r\nint ret;\r\nuint32_t val;\r\nnand_ecc_modes_t ecc_mode;\r\npdata = nand_davinci_get_pdata(pdev);\r\nif (!pdata)\r\nreturn -ENODEV;\r\nif (pdev->id < 0 || pdev->id > 3)\r\nreturn -ENODEV;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info) {\r\ndev_err(&pdev->dev, "unable to allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_nomem;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nres1 = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nres2 = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res1 || !res2) {\r\ndev_err(&pdev->dev, "resource missing\n");\r\nret = -EINVAL;\r\ngoto err_nomem;\r\n}\r\nvaddr = devm_ioremap_resource(&pdev->dev, res1);\r\nif (IS_ERR(vaddr)) {\r\nret = PTR_ERR(vaddr);\r\ngoto err_ioremap;\r\n}\r\nbase = devm_ioremap_resource(&pdev->dev, res2);\r\nif (IS_ERR(base)) {\r\nret = PTR_ERR(base);\r\ngoto err_ioremap;\r\n}\r\ninfo->dev = &pdev->dev;\r\ninfo->base = base;\r\ninfo->vaddr = vaddr;\r\ninfo->mtd.priv = &info->chip;\r\ninfo->mtd.name = dev_name(&pdev->dev);\r\ninfo->mtd.owner = THIS_MODULE;\r\ninfo->mtd.dev.parent = &pdev->dev;\r\ninfo->chip.IO_ADDR_R = vaddr;\r\ninfo->chip.IO_ADDR_W = vaddr;\r\ninfo->chip.chip_delay = 0;\r\ninfo->chip.select_chip = nand_davinci_select_chip;\r\ninfo->chip.bbt_options = pdata->bbt_options;\r\ninfo->chip.options = pdata->options;\r\ninfo->chip.bbt_td = pdata->bbt_td;\r\ninfo->chip.bbt_md = pdata->bbt_md;\r\ninfo->timing = pdata->timing;\r\ninfo->ioaddr = (uint32_t __force) vaddr;\r\ninfo->current_cs = info->ioaddr;\r\ninfo->core_chipsel = pdev->id;\r\ninfo->mask_chipsel = pdata->mask_chipsel;\r\ninfo->mask_ale = pdata->mask_ale ? : MASK_ALE;\r\ninfo->mask_cle = pdata->mask_cle ? : MASK_CLE;\r\ninfo->chip.cmd_ctrl = nand_davinci_hwcontrol;\r\ninfo->chip.dev_ready = nand_davinci_dev_ready;\r\ninfo->chip.read_buf = nand_davinci_read_buf;\r\ninfo->chip.write_buf = nand_davinci_write_buf;\r\necc_mode = pdata->ecc_mode;\r\nret = -EINVAL;\r\nswitch (ecc_mode) {\r\ncase NAND_ECC_NONE:\r\ncase NAND_ECC_SOFT:\r\npdata->ecc_bits = 0;\r\nbreak;\r\ncase NAND_ECC_HW:\r\nif (pdata->ecc_bits == 4) {\r\nspin_lock_irq(&davinci_nand_lock);\r\nif (ecc4_busy)\r\nret = -EBUSY;\r\nelse\r\necc4_busy = true;\r\nspin_unlock_irq(&davinci_nand_lock);\r\nif (ret == -EBUSY)\r\ngoto err_ecc;\r\ninfo->chip.ecc.calculate = nand_davinci_calculate_4bit;\r\ninfo->chip.ecc.correct = nand_davinci_correct_4bit;\r\ninfo->chip.ecc.hwctl = nand_davinci_hwctl_4bit;\r\ninfo->chip.ecc.bytes = 10;\r\n} else {\r\ninfo->chip.ecc.calculate = nand_davinci_calculate_1bit;\r\ninfo->chip.ecc.correct = nand_davinci_correct_1bit;\r\ninfo->chip.ecc.hwctl = nand_davinci_hwctl_1bit;\r\ninfo->chip.ecc.bytes = 3;\r\n}\r\ninfo->chip.ecc.size = 512;\r\ninfo->chip.ecc.strength = pdata->ecc_bits;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err_ecc;\r\n}\r\ninfo->chip.ecc.mode = ecc_mode;\r\ninfo->clk = devm_clk_get(&pdev->dev, "aemif");\r\nif (IS_ERR(info->clk)) {\r\nret = PTR_ERR(info->clk);\r\ndev_dbg(&pdev->dev, "unable to get AEMIF clock, err %d\n", ret);\r\ngoto err_clk;\r\n}\r\nret = clk_prepare_enable(info->clk);\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "unable to enable AEMIF clock, err %d\n",\r\nret);\r\ngoto err_clk_enable;\r\n}\r\nval = davinci_nand_readl(info, A1CR_OFFSET + info->core_chipsel * 4);\r\nval &= ~(ACR_ASIZE_MASK | ACR_EW_MASK | ACR_SS_MASK);\r\nif (info->chip.options & NAND_BUSWIDTH_16)\r\nval |= 0x1;\r\ndavinci_nand_writel(info, A1CR_OFFSET + info->core_chipsel * 4, val);\r\nret = 0;\r\nif (info->timing)\r\nret = davinci_aemif_setup_timing(info->timing, info->base,\r\ninfo->core_chipsel);\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "NAND timing values setup fail\n");\r\ngoto err_timing;\r\n}\r\nspin_lock_irq(&davinci_nand_lock);\r\nval = davinci_nand_readl(info, NANDFCR_OFFSET);\r\nval |= BIT(info->core_chipsel);\r\ndavinci_nand_writel(info, NANDFCR_OFFSET, val);\r\nspin_unlock_irq(&davinci_nand_lock);\r\nret = nand_scan_ident(&info->mtd, pdata->mask_chipsel ? 2 : 1, NULL);\r\nif (ret < 0) {\r\ndev_dbg(&pdev->dev, "no NAND chip(s) found\n");\r\ngoto err_scan;\r\n}\r\nif (pdata->ecc_bits == 4) {\r\nint chunks = info->mtd.writesize / 512;\r\nif (!chunks || info->mtd.oobsize < 16) {\r\ndev_dbg(&pdev->dev, "too small\n");\r\nret = -EINVAL;\r\ngoto err_scan;\r\n}\r\nif (chunks == 1) {\r\ninfo->ecclayout = hwecc4_small;\r\ninfo->ecclayout.oobfree[1].length =\r\ninfo->mtd.oobsize - 16;\r\ngoto syndrome_done;\r\n}\r\nif (chunks == 4) {\r\ninfo->ecclayout = hwecc4_2048;\r\ninfo->chip.ecc.mode = NAND_ECC_HW_OOB_FIRST;\r\ngoto syndrome_done;\r\n}\r\ndev_warn(&pdev->dev, "no 4-bit ECC support yet "\r\n"for 4KiB-page NAND\n");\r\nret = -EIO;\r\ngoto err_scan;\r\nsyndrome_done:\r\ninfo->chip.ecc.layout = &info->ecclayout;\r\n}\r\nret = nand_scan_tail(&info->mtd);\r\nif (ret < 0)\r\ngoto err_scan;\r\nif (pdata->parts)\r\nret = mtd_device_parse_register(&info->mtd, NULL, NULL,\r\npdata->parts, pdata->nr_parts);\r\nelse {\r\nstruct mtd_part_parser_data ppdata;\r\nppdata.of_node = pdev->dev.of_node;\r\nret = mtd_device_parse_register(&info->mtd, NULL, &ppdata,\r\nNULL, 0);\r\n}\r\nif (ret < 0)\r\ngoto err_scan;\r\nval = davinci_nand_readl(info, NRCSR_OFFSET);\r\ndev_info(&pdev->dev, "controller rev. %d.%d\n",\r\n(val >> 8) & 0xff, val & 0xff);\r\nreturn 0;\r\nerr_scan:\r\nerr_timing:\r\nclk_disable_unprepare(info->clk);\r\nerr_clk_enable:\r\nspin_lock_irq(&davinci_nand_lock);\r\nif (ecc_mode == NAND_ECC_HW_SYNDROME)\r\necc4_busy = false;\r\nspin_unlock_irq(&davinci_nand_lock);\r\nerr_ecc:\r\nerr_clk:\r\nerr_ioremap:\r\nerr_nomem:\r\nreturn ret;\r\n}\r\nstatic int __exit nand_davinci_remove(struct platform_device *pdev)\r\n{\r\nstruct davinci_nand_info *info = platform_get_drvdata(pdev);\r\nspin_lock_irq(&davinci_nand_lock);\r\nif (info->chip.ecc.mode == NAND_ECC_HW_SYNDROME)\r\necc4_busy = false;\r\nspin_unlock_irq(&davinci_nand_lock);\r\nnand_release(&info->mtd);\r\nclk_disable_unprepare(info->clk);\r\nreturn 0;\r\n}
