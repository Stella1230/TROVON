enum fw_retval\r\ncsio_mb_fw_retval(struct csio_mb *mbp)\r\n{\r\nstruct fw_cmd_hdr *hdr;\r\nhdr = (struct fw_cmd_hdr *)(mbp->mb);\r\nreturn FW_CMD_RETVAL_GET(ntohl(hdr->lo));\r\n}\r\nvoid\r\ncsio_mb_hello(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nuint32_t m_mbox, uint32_t a_mbox, enum csio_dev_master master,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_hello_cmd *cmdp = (struct fw_hello_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\r\ncmdp->op_to_write = htonl(FW_CMD_OP(FW_HELLO_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE);\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->err_to_clearinit = htonl(\r\nFW_HELLO_CMD_MASTERDIS(master == CSIO_MASTER_CANT) |\r\nFW_HELLO_CMD_MASTERFORCE(master == CSIO_MASTER_MUST) |\r\nFW_HELLO_CMD_MBMASTER(master == CSIO_MASTER_MUST ?\r\nm_mbox : FW_HELLO_CMD_MBMASTER_MASK) |\r\nFW_HELLO_CMD_MBASYNCNOT(a_mbox) |\r\nFW_HELLO_CMD_STAGE(fw_hello_cmd_stage_os) |\r\nFW_HELLO_CMD_CLEARINIT);\r\n}\r\nvoid\r\ncsio_mb_process_hello_rsp(struct csio_hw *hw, struct csio_mb *mbp,\r\nenum fw_retval *retval, enum csio_dev_state *state,\r\nuint8_t *mpfn)\r\n{\r\nstruct fw_hello_cmd *rsp = (struct fw_hello_cmd *)(mbp->mb);\r\nuint32_t value;\r\n*retval = FW_CMD_RETVAL_GET(ntohl(rsp->retval_len16));\r\nif (*retval == FW_SUCCESS) {\r\nhw->fwrev = ntohl(rsp->fwrev);\r\nvalue = ntohl(rsp->err_to_clearinit);\r\n*mpfn = FW_HELLO_CMD_MBMASTER_GET(value);\r\nif (value & FW_HELLO_CMD_INIT)\r\n*state = CSIO_DEV_STATE_INIT;\r\nelse if (value & FW_HELLO_CMD_ERR)\r\n*state = CSIO_DEV_STATE_ERR;\r\nelse\r\n*state = CSIO_DEV_STATE_UNINIT;\r\n}\r\n}\r\nvoid\r\ncsio_mb_bye(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_bye_cmd *cmdp = (struct fw_bye_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\r\ncmdp->op_to_write = htonl(FW_CMD_OP(FW_BYE_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE);\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\n}\r\nvoid\r\ncsio_mb_reset(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nint reset, int halt,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_reset_cmd *cmdp = (struct fw_reset_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\r\ncmdp->op_to_write = htonl(FW_CMD_OP(FW_RESET_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE);\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->val = htonl(reset);\r\ncmdp->halt_pkd = htonl(halt);\r\n}\r\nvoid\r\ncsio_mb_params(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nunsigned int pf, unsigned int vf, unsigned int nparams,\r\nconst u32 *params, u32 *val, bool wr,\r\nvoid (*cbfn)(struct csio_hw *, struct csio_mb *))\r\n{\r\nuint32_t i;\r\nuint32_t temp_params = 0, temp_val = 0;\r\nstruct fw_params_cmd *cmdp = (struct fw_params_cmd *)(mbp->mb);\r\n__be32 *p = &cmdp->param[0].mnem;\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\r\ncmdp->op_to_vfn = htonl(FW_CMD_OP(FW_PARAMS_CMD) |\r\nFW_CMD_REQUEST |\r\n(wr ? FW_CMD_WRITE : FW_CMD_READ) |\r\nFW_PARAMS_CMD_PFN(pf) |\r\nFW_PARAMS_CMD_VFN(vf));\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\nif (wr) {\r\nwhile (nparams--) {\r\ntemp_params = *params++;\r\ntemp_val = *val++;\r\n*p++ = htonl(temp_params);\r\n*p++ = htonl(temp_val);\r\n}\r\n} else {\r\nfor (i = 0; i < nparams; i++, p += 2) {\r\ntemp_params = *params++;\r\n*p = htonl(temp_params);\r\n}\r\n}\r\n}\r\nvoid\r\ncsio_mb_process_read_params_rsp(struct csio_hw *hw, struct csio_mb *mbp,\r\nenum fw_retval *retval, unsigned int nparams,\r\nu32 *val)\r\n{\r\nstruct fw_params_cmd *rsp = (struct fw_params_cmd *)(mbp->mb);\r\nuint32_t i;\r\n__be32 *p = &rsp->param[0].val;\r\n*retval = FW_CMD_RETVAL_GET(ntohl(rsp->retval_len16));\r\nif (*retval == FW_SUCCESS)\r\nfor (i = 0; i < nparams; i++, p += 2)\r\n*val++ = ntohl(*p);\r\n}\r\nvoid\r\ncsio_mb_ldst(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo, int reg)\r\n{\r\nstruct fw_ldst_cmd *ldst_cmd = (struct fw_ldst_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, ldst_cmd, tmo, hw, NULL, 1);\r\nldst_cmd->op_to_addrspace =\r\nhtonl(FW_CMD_OP(FW_LDST_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ |\r\nFW_LDST_CMD_ADDRSPACE(FW_LDST_ADDRSPC_FUNC_PCIE));\r\nldst_cmd->cycles_to_len16 = htonl(FW_LEN16(struct fw_ldst_cmd));\r\nldst_cmd->u.pcie.select_naccess = FW_LDST_CMD_NACCESS(1);\r\nldst_cmd->u.pcie.ctrl_to_fn =\r\n(FW_LDST_CMD_LC | FW_LDST_CMD_FN(hw->pfn));\r\nldst_cmd->u.pcie.r = (uint8_t)reg;\r\n}\r\nvoid\r\ncsio_mb_caps_config(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nbool wr, bool init, bool tgt, bool cofld,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_caps_config_cmd *cmdp =\r\n(struct fw_caps_config_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, wr ? 0 : 1);\r\ncmdp->op_to_write = htonl(FW_CMD_OP(FW_CAPS_CONFIG_CMD) |\r\nFW_CMD_REQUEST |\r\n(wr ? FW_CMD_WRITE : FW_CMD_READ));\r\ncmdp->cfvalid_to_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\nif (!wr)\r\nreturn;\r\ncmdp->fcoecaps = 0;\r\nif (cofld)\r\ncmdp->fcoecaps |= htons(FW_CAPS_CONFIG_FCOE_CTRL_OFLD);\r\nif (init)\r\ncmdp->fcoecaps |= htons(FW_CAPS_CONFIG_FCOE_INITIATOR);\r\nif (tgt)\r\ncmdp->fcoecaps |= htons(FW_CAPS_CONFIG_FCOE_TARGET);\r\n}\r\nvoid\r\ncsio_mb_port(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nuint8_t portid, bool wr, uint32_t fc, uint16_t caps,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_port_cmd *cmdp = (struct fw_port_cmd *)(mbp->mb);\r\nunsigned int lfc = 0, mdi = FW_PORT_MDI(FW_PORT_MDI_AUTO);\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\r\ncmdp->op_to_portid = htonl(FW_CMD_OP(FW_PORT_CMD) |\r\nFW_CMD_REQUEST |\r\n(wr ? FW_CMD_EXEC : FW_CMD_READ) |\r\nFW_PORT_CMD_PORTID(portid));\r\nif (!wr) {\r\ncmdp->action_to_len16 = htonl(\r\nFW_PORT_CMD_ACTION(FW_PORT_ACTION_GET_PORT_INFO) |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\nreturn;\r\n}\r\ncmdp->action_to_len16 = htonl(\r\nFW_PORT_CMD_ACTION(FW_PORT_ACTION_L1_CFG) |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\nif (fc & PAUSE_RX)\r\nlfc |= FW_PORT_CAP_FC_RX;\r\nif (fc & PAUSE_TX)\r\nlfc |= FW_PORT_CAP_FC_TX;\r\nif (!(caps & FW_PORT_CAP_ANEG))\r\ncmdp->u.l1cfg.rcap = htonl((caps & CSIO_ADVERT_MASK) | lfc);\r\nelse\r\ncmdp->u.l1cfg.rcap = htonl((caps & CSIO_ADVERT_MASK) |\r\nlfc | mdi);\r\n}\r\nvoid\r\ncsio_mb_process_read_port_rsp(struct csio_hw *hw, struct csio_mb *mbp,\r\nenum fw_retval *retval, uint16_t *caps)\r\n{\r\nstruct fw_port_cmd *rsp = (struct fw_port_cmd *)(mbp->mb);\r\n*retval = FW_CMD_RETVAL_GET(ntohl(rsp->action_to_len16));\r\nif (*retval == FW_SUCCESS)\r\n*caps = ntohs(rsp->u.info.pcap);\r\n}\r\nvoid\r\ncsio_mb_initialize(struct csio_hw *hw, struct csio_mb *mbp, uint32_t tmo,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_initialize_cmd *cmdp = (struct fw_initialize_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, tmo, hw, cbfn, 1);\r\ncmdp->op_to_write = htonl(FW_CMD_OP(FW_INITIALIZE_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE);\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\n}\r\nstatic void\r\ncsio_mb_iq_alloc(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, struct csio_iq_params *iq_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_iq_cmd *cmdp = (struct fw_iq_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\r\ncmdp->op_to_vfn = htonl(FW_CMD_OP(FW_IQ_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_EXEC |\r\nFW_IQ_CMD_PFN(iq_params->pfn) |\r\nFW_IQ_CMD_VFN(iq_params->vfn));\r\ncmdp->alloc_to_len16 = htonl(FW_IQ_CMD_ALLOC |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->type_to_iqandstindex = htonl(\r\nFW_IQ_CMD_VIID(iq_params->viid) |\r\nFW_IQ_CMD_TYPE(iq_params->type) |\r\nFW_IQ_CMD_IQASYNCH(iq_params->iqasynch));\r\ncmdp->fl0size = htons(iq_params->fl0size);\r\ncmdp->fl0size = htons(iq_params->fl1size);\r\n}\r\nstatic void\r\ncsio_mb_iq_write(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, bool cascaded_req,\r\nstruct csio_iq_params *iq_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_iq_cmd *cmdp = (struct fw_iq_cmd *)(mbp->mb);\r\nuint32_t iq_start_stop = (iq_params->iq_start) ?\r\nFW_IQ_CMD_IQSTART(1) :\r\nFW_IQ_CMD_IQSTOP(1);\r\nif (!cascaded_req)\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\r\ncmdp->op_to_vfn |= htonl(FW_CMD_OP(FW_IQ_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE |\r\nFW_IQ_CMD_PFN(iq_params->pfn) |\r\nFW_IQ_CMD_VFN(iq_params->vfn));\r\ncmdp->alloc_to_len16 |= htonl(iq_start_stop |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->iqid |= htons(iq_params->iqid);\r\ncmdp->fl0id |= htons(iq_params->fl0id);\r\ncmdp->fl1id |= htons(iq_params->fl1id);\r\ncmdp->type_to_iqandstindex |= htonl(\r\nFW_IQ_CMD_IQANDST(iq_params->iqandst) |\r\nFW_IQ_CMD_IQANUS(iq_params->iqanus) |\r\nFW_IQ_CMD_IQANUD(iq_params->iqanud) |\r\nFW_IQ_CMD_IQANDSTINDEX(iq_params->iqandstindex));\r\ncmdp->iqdroprss_to_iqesize |= htons(\r\nFW_IQ_CMD_IQPCIECH(iq_params->iqpciech) |\r\nFW_IQ_CMD_IQDCAEN(iq_params->iqdcaen) |\r\nFW_IQ_CMD_IQDCACPU(iq_params->iqdcacpu) |\r\nFW_IQ_CMD_IQINTCNTTHRESH(iq_params->iqintcntthresh) |\r\nFW_IQ_CMD_IQCPRIO(iq_params->iqcprio) |\r\nFW_IQ_CMD_IQESIZE(iq_params->iqesize));\r\ncmdp->iqsize |= htons(iq_params->iqsize);\r\ncmdp->iqaddr |= cpu_to_be64(iq_params->iqaddr);\r\nif (iq_params->type == 0) {\r\ncmdp->iqns_to_fl0congen |= htonl(\r\nFW_IQ_CMD_IQFLINTIQHSEN(iq_params->iqflintiqhsen)|\r\nFW_IQ_CMD_IQFLINTCONGEN(iq_params->iqflintcongen));\r\n}\r\nif (iq_params->fl0size && iq_params->fl0addr &&\r\n(iq_params->fl0id != 0xFFFF)) {\r\ncmdp->iqns_to_fl0congen |= htonl(\r\nFW_IQ_CMD_FL0HOSTFCMODE(iq_params->fl0hostfcmode)|\r\nFW_IQ_CMD_FL0CPRIO(iq_params->fl0cprio) |\r\nFW_IQ_CMD_FL0PADEN(iq_params->fl0paden) |\r\nFW_IQ_CMD_FL0PACKEN(iq_params->fl0packen));\r\ncmdp->fl0dcaen_to_fl0cidxfthresh |= htons(\r\nFW_IQ_CMD_FL0DCAEN(iq_params->fl0dcaen) |\r\nFW_IQ_CMD_FL0DCACPU(iq_params->fl0dcacpu) |\r\nFW_IQ_CMD_FL0FBMIN(iq_params->fl0fbmin) |\r\nFW_IQ_CMD_FL0FBMAX(iq_params->fl0fbmax) |\r\nFW_IQ_CMD_FL0CIDXFTHRESH(iq_params->fl0cidxfthresh));\r\ncmdp->fl0size |= htons(iq_params->fl0size);\r\ncmdp->fl0addr |= cpu_to_be64(iq_params->fl0addr);\r\n}\r\n}\r\nvoid\r\ncsio_mb_iq_alloc_write(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, struct csio_iq_params *iq_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\ncsio_mb_iq_alloc(hw, mbp, priv, mb_tmo, iq_params, cbfn);\r\ncsio_mb_iq_write(hw, mbp, priv, mb_tmo, true, iq_params, cbfn);\r\n}\r\nvoid\r\ncsio_mb_iq_alloc_write_rsp(struct csio_hw *hw, struct csio_mb *mbp,\r\nenum fw_retval *ret_val,\r\nstruct csio_iq_params *iq_params)\r\n{\r\nstruct fw_iq_cmd *rsp = (struct fw_iq_cmd *)(mbp->mb);\r\n*ret_val = FW_CMD_RETVAL_GET(ntohl(rsp->alloc_to_len16));\r\nif (*ret_val == FW_SUCCESS) {\r\niq_params->physiqid = ntohs(rsp->physiqid);\r\niq_params->iqid = ntohs(rsp->iqid);\r\niq_params->fl0id = ntohs(rsp->fl0id);\r\niq_params->fl1id = ntohs(rsp->fl1id);\r\n} else {\r\niq_params->physiqid = iq_params->iqid =\r\niq_params->fl0id = iq_params->fl1id = 0;\r\n}\r\n}\r\nvoid\r\ncsio_mb_iq_free(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, struct csio_iq_params *iq_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_iq_cmd *cmdp = (struct fw_iq_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\r\ncmdp->op_to_vfn = htonl(FW_CMD_OP(FW_IQ_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_EXEC |\r\nFW_IQ_CMD_PFN(iq_params->pfn) |\r\nFW_IQ_CMD_VFN(iq_params->vfn));\r\ncmdp->alloc_to_len16 = htonl(FW_IQ_CMD_FREE |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->type_to_iqandstindex = htonl(FW_IQ_CMD_TYPE(iq_params->type));\r\ncmdp->iqid = htons(iq_params->iqid);\r\ncmdp->fl0id = htons(iq_params->fl0id);\r\ncmdp->fl1id = htons(iq_params->fl1id);\r\n}\r\nstatic void\r\ncsio_mb_eq_ofld_alloc(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, struct csio_eq_params *eq_ofld_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_eq_ofld_cmd *cmdp = (struct fw_eq_ofld_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\r\ncmdp->op_to_vfn = htonl(FW_CMD_OP(FW_EQ_OFLD_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_EXEC |\r\nFW_EQ_OFLD_CMD_PFN(eq_ofld_params->pfn) |\r\nFW_EQ_OFLD_CMD_VFN(eq_ofld_params->vfn));\r\ncmdp->alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_ALLOC |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\n}\r\nstatic void\r\ncsio_mb_eq_ofld_write(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, bool cascaded_req,\r\nstruct csio_eq_params *eq_ofld_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_eq_ofld_cmd *cmdp = (struct fw_eq_ofld_cmd *)(mbp->mb);\r\nuint32_t eq_start_stop = (eq_ofld_params->eqstart) ?\r\nFW_EQ_OFLD_CMD_EQSTART : FW_EQ_OFLD_CMD_EQSTOP;\r\nif (!cascaded_req)\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\r\ncmdp->op_to_vfn |= htonl(FW_CMD_OP(FW_EQ_OFLD_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_WRITE |\r\nFW_EQ_OFLD_CMD_PFN(eq_ofld_params->pfn) |\r\nFW_EQ_OFLD_CMD_VFN(eq_ofld_params->vfn));\r\ncmdp->alloc_to_len16 |= htonl(eq_start_stop |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->eqid_pkd |= htonl(FW_EQ_OFLD_CMD_EQID(eq_ofld_params->eqid));\r\ncmdp->fetchszm_to_iqid |= htonl(\r\nFW_EQ_OFLD_CMD_HOSTFCMODE(eq_ofld_params->hostfcmode) |\r\nFW_EQ_OFLD_CMD_CPRIO(eq_ofld_params->cprio) |\r\nFW_EQ_OFLD_CMD_PCIECHN(eq_ofld_params->pciechn) |\r\nFW_EQ_OFLD_CMD_IQID(eq_ofld_params->iqid));\r\ncmdp->dcaen_to_eqsize |= htonl(\r\nFW_EQ_OFLD_CMD_DCAEN(eq_ofld_params->dcaen) |\r\nFW_EQ_OFLD_CMD_DCACPU(eq_ofld_params->dcacpu) |\r\nFW_EQ_OFLD_CMD_FBMIN(eq_ofld_params->fbmin) |\r\nFW_EQ_OFLD_CMD_FBMAX(eq_ofld_params->fbmax) |\r\nFW_EQ_OFLD_CMD_CIDXFTHRESHO(eq_ofld_params->cidxfthresho) |\r\nFW_EQ_OFLD_CMD_CIDXFTHRESH(eq_ofld_params->cidxfthresh) |\r\nFW_EQ_OFLD_CMD_EQSIZE(eq_ofld_params->eqsize));\r\ncmdp->eqaddr |= cpu_to_be64(eq_ofld_params->eqaddr);\r\n}\r\nvoid\r\ncsio_mb_eq_ofld_alloc_write(struct csio_hw *hw, struct csio_mb *mbp,\r\nvoid *priv, uint32_t mb_tmo,\r\nstruct csio_eq_params *eq_ofld_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\ncsio_mb_eq_ofld_alloc(hw, mbp, priv, mb_tmo, eq_ofld_params, cbfn);\r\ncsio_mb_eq_ofld_write(hw, mbp, priv, mb_tmo, true,\r\neq_ofld_params, cbfn);\r\n}\r\nvoid\r\ncsio_mb_eq_ofld_alloc_write_rsp(struct csio_hw *hw,\r\nstruct csio_mb *mbp, enum fw_retval *ret_val,\r\nstruct csio_eq_params *eq_ofld_params)\r\n{\r\nstruct fw_eq_ofld_cmd *rsp = (struct fw_eq_ofld_cmd *)(mbp->mb);\r\n*ret_val = FW_CMD_RETVAL_GET(ntohl(rsp->alloc_to_len16));\r\nif (*ret_val == FW_SUCCESS) {\r\neq_ofld_params->eqid = FW_EQ_OFLD_CMD_EQID_GET(\r\nntohl(rsp->eqid_pkd));\r\neq_ofld_params->physeqid = FW_EQ_OFLD_CMD_PHYSEQID_GET(\r\nntohl(rsp->physeqid_pkd));\r\n} else\r\neq_ofld_params->eqid = 0;\r\n}\r\nvoid\r\ncsio_mb_eq_ofld_free(struct csio_hw *hw, struct csio_mb *mbp, void *priv,\r\nuint32_t mb_tmo, struct csio_eq_params *eq_ofld_params,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_eq_ofld_cmd *cmdp = (struct fw_eq_ofld_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, priv, cbfn, 1);\r\ncmdp->op_to_vfn = htonl(FW_CMD_OP(FW_EQ_OFLD_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_EXEC |\r\nFW_EQ_OFLD_CMD_PFN(eq_ofld_params->pfn) |\r\nFW_EQ_OFLD_CMD_VFN(eq_ofld_params->vfn));\r\ncmdp->alloc_to_len16 = htonl(FW_EQ_OFLD_CMD_FREE |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->eqid_pkd = htonl(FW_EQ_OFLD_CMD_EQID(eq_ofld_params->eqid));\r\n}\r\nvoid\r\ncsio_write_fcoe_link_cond_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\r\nuint32_t mb_tmo, uint8_t port_id, uint32_t sub_opcode,\r\nuint8_t cos, bool link_status, uint32_t fcfi,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_fcoe_link_cmd *cmdp =\r\n(struct fw_fcoe_link_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\r\ncmdp->op_to_portid = htonl((\r\nFW_CMD_OP(FW_FCOE_LINK_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_WRITE |\r\nFW_FCOE_LINK_CMD_PORTID(port_id)));\r\ncmdp->sub_opcode_fcfi = htonl(\r\nFW_FCOE_LINK_CMD_SUB_OPCODE(sub_opcode) |\r\nFW_FCOE_LINK_CMD_FCFI(fcfi));\r\ncmdp->lstatus = link_status;\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\n}\r\nvoid\r\ncsio_fcoe_read_res_info_init_mb(struct csio_hw *hw, struct csio_mb *mbp,\r\nuint32_t mb_tmo,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_fcoe_res_info_cmd *cmdp =\r\n(struct fw_fcoe_res_info_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, hw, cbfn, 1);\r\ncmdp->op_to_read = htonl((FW_CMD_OP(FW_FCOE_RES_INFO_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ));\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\n}\r\nvoid\r\ncsio_fcoe_vnp_alloc_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\r\nuint32_t mb_tmo, uint32_t fcfi, uint32_t vnpi, uint16_t iqid,\r\nuint8_t vnport_wwnn[8], uint8_t vnport_wwpn[8],\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_fcoe_vnp_cmd *cmdp =\r\n(struct fw_fcoe_vnp_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\r\ncmdp->op_to_fcfi = htonl((FW_CMD_OP(FW_FCOE_VNP_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC |\r\nFW_FCOE_VNP_CMD_FCFI(fcfi)));\r\ncmdp->alloc_to_len16 = htonl(FW_FCOE_VNP_CMD_ALLOC |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->gen_wwn_to_vnpi = htonl(FW_FCOE_VNP_CMD_VNPI(vnpi));\r\ncmdp->iqid = htons(iqid);\r\nif (!wwn_to_u64(vnport_wwnn) && !wwn_to_u64(vnport_wwpn))\r\ncmdp->gen_wwn_to_vnpi |= htonl(FW_FCOE_VNP_CMD_GEN_WWN);\r\nif (vnport_wwnn)\r\nmemcpy(cmdp->vnport_wwnn, vnport_wwnn, 8);\r\nif (vnport_wwpn)\r\nmemcpy(cmdp->vnport_wwpn, vnport_wwpn, 8);\r\n}\r\nvoid\r\ncsio_fcoe_vnp_read_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\r\nuint32_t mb_tmo, uint32_t fcfi, uint32_t vnpi,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_fcoe_vnp_cmd *cmdp =\r\n(struct fw_fcoe_vnp_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\r\ncmdp->op_to_fcfi = htonl(FW_CMD_OP(FW_FCOE_VNP_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ |\r\nFW_FCOE_VNP_CMD_FCFI(fcfi));\r\ncmdp->alloc_to_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->gen_wwn_to_vnpi = htonl(FW_FCOE_VNP_CMD_VNPI(vnpi));\r\n}\r\nvoid\r\ncsio_fcoe_vnp_free_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\r\nuint32_t mb_tmo, uint32_t fcfi, uint32_t vnpi,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_fcoe_vnp_cmd *cmdp =\r\n(struct fw_fcoe_vnp_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\r\ncmdp->op_to_fcfi = htonl(FW_CMD_OP(FW_FCOE_VNP_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_EXEC |\r\nFW_FCOE_VNP_CMD_FCFI(fcfi));\r\ncmdp->alloc_to_len16 = htonl(FW_FCOE_VNP_CMD_FREE |\r\nFW_CMD_LEN16(sizeof(*cmdp) / 16));\r\ncmdp->gen_wwn_to_vnpi = htonl(FW_FCOE_VNP_CMD_VNPI(vnpi));\r\n}\r\nvoid\r\ncsio_fcoe_read_fcf_init_mb(struct csio_lnode *ln, struct csio_mb *mbp,\r\nuint32_t mb_tmo, uint32_t portid, uint32_t fcfi,\r\nvoid (*cbfn) (struct csio_hw *, struct csio_mb *))\r\n{\r\nstruct fw_fcoe_fcf_cmd *cmdp =\r\n(struct fw_fcoe_fcf_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, ln, cbfn, 1);\r\ncmdp->op_to_fcfi = htonl(FW_CMD_OP(FW_FCOE_FCF_CMD) |\r\nFW_CMD_REQUEST |\r\nFW_CMD_READ |\r\nFW_FCOE_FCF_CMD_FCFI(fcfi));\r\ncmdp->retval_len16 = htonl(FW_CMD_LEN16(sizeof(*cmdp) / 16));\r\n}\r\nvoid\r\ncsio_fcoe_read_portparams_init_mb(struct csio_hw *hw, struct csio_mb *mbp,\r\nuint32_t mb_tmo,\r\nstruct fw_fcoe_port_cmd_params *portparams,\r\nvoid (*cbfn)(struct csio_hw *,\r\nstruct csio_mb *))\r\n{\r\nstruct fw_fcoe_stats_cmd *cmdp = (struct fw_fcoe_stats_cmd *)(mbp->mb);\r\nCSIO_INIT_MBP(mbp, cmdp, mb_tmo, hw, cbfn, 1);\r\nmbp->mb_size = 64;\r\ncmdp->op_to_flowid = htonl(FW_CMD_OP(FW_FCOE_STATS_CMD) |\r\nFW_CMD_REQUEST | FW_CMD_READ);\r\ncmdp->free_to_len16 = htonl(FW_CMD_LEN16(CSIO_MAX_MB_SIZE/16));\r\ncmdp->u.ctl.nstats_port = FW_FCOE_STATS_CMD_NSTATS(portparams->nstats) |\r\nFW_FCOE_STATS_CMD_PORT(portparams->portid);\r\ncmdp->u.ctl.port_valid_ix = FW_FCOE_STATS_CMD_IX(portparams->idx) |\r\nFW_FCOE_STATS_CMD_PORT_VALID;\r\n}\r\nvoid\r\ncsio_mb_process_portparams_rsp(struct csio_hw *hw,\r\nstruct csio_mb *mbp,\r\nenum fw_retval *retval,\r\nstruct fw_fcoe_port_cmd_params *portparams,\r\nstruct fw_fcoe_port_stats *portstats)\r\n{\r\nstruct fw_fcoe_stats_cmd *rsp = (struct fw_fcoe_stats_cmd *)(mbp->mb);\r\nstruct fw_fcoe_port_stats stats;\r\nuint8_t *src;\r\nuint8_t *dst;\r\n*retval = FW_CMD_RETVAL_GET(ntohl(rsp->free_to_len16));\r\nmemset(&stats, 0, sizeof(struct fw_fcoe_port_stats));\r\nif (*retval == FW_SUCCESS) {\r\ndst = (uint8_t *)(&stats) + ((portparams->idx - 1) * 8);\r\nsrc = (uint8_t *)rsp + (CSIO_STATS_OFFSET * 8);\r\nmemcpy(dst, src, (portparams->nstats * 8));\r\nif (portparams->idx == 1) {\r\nportstats->tx_bcast_bytes = stats.tx_bcast_bytes;\r\nportstats->tx_bcast_frames = stats.tx_bcast_frames;\r\nportstats->tx_mcast_bytes = stats.tx_mcast_bytes;\r\nportstats->tx_mcast_frames = stats.tx_mcast_frames;\r\nportstats->tx_ucast_bytes = stats.tx_ucast_bytes;\r\nportstats->tx_ucast_frames = stats.tx_ucast_frames;\r\n}\r\nif (portparams->idx == 7) {\r\nportstats->tx_drop_frames = stats.tx_drop_frames;\r\nportstats->tx_offload_bytes = stats.tx_offload_bytes;\r\nportstats->tx_offload_frames = stats.tx_offload_frames;\r\n#if 0\r\nportstats->rx_pf_bytes = stats.rx_pf_bytes;\r\nportstats->rx_pf_frames = stats.rx_pf_frames;\r\n#endif\r\nportstats->rx_bcast_bytes = stats.rx_bcast_bytes;\r\nportstats->rx_bcast_frames = stats.rx_bcast_frames;\r\nportstats->rx_mcast_bytes = stats.rx_mcast_bytes;\r\n}\r\nif (portparams->idx == 13) {\r\nportstats->rx_mcast_frames = stats.rx_mcast_frames;\r\nportstats->rx_ucast_bytes = stats.rx_ucast_bytes;\r\nportstats->rx_ucast_frames = stats.rx_ucast_frames;\r\nportstats->rx_err_frames = stats.rx_err_frames;\r\n}\r\n}\r\n}\r\nvoid\r\ncsio_mb_intr_enable(struct csio_hw *hw)\r\n{\r\ncsio_wr_reg32(hw, MBMSGRDYINTEN(1), MYPF_REG(CIM_PF_HOST_INT_ENABLE));\r\ncsio_rd_reg32(hw, MYPF_REG(CIM_PF_HOST_INT_ENABLE));\r\n}\r\nvoid\r\ncsio_mb_intr_disable(struct csio_hw *hw)\r\n{\r\ncsio_wr_reg32(hw, MBMSGRDYINTEN(0), MYPF_REG(CIM_PF_HOST_INT_ENABLE));\r\ncsio_rd_reg32(hw, MYPF_REG(CIM_PF_HOST_INT_ENABLE));\r\n}\r\nstatic void\r\ncsio_mb_dump_fw_dbg(struct csio_hw *hw, __be64 *cmd)\r\n{\r\nstruct fw_debug_cmd *dbg = (struct fw_debug_cmd *)cmd;\r\nif ((FW_DEBUG_CMD_TYPE_GET(ntohl(dbg->op_type))) == 1) {\r\ncsio_info(hw, "FW print message:\n");\r\ncsio_info(hw, "\tdebug->dprtstridx = %d\n",\r\nntohs(dbg->u.prt.dprtstridx));\r\ncsio_info(hw, "\tdebug->dprtstrparam0 = 0x%x\n",\r\nntohl(dbg->u.prt.dprtstrparam0));\r\ncsio_info(hw, "\tdebug->dprtstrparam1 = 0x%x\n",\r\nntohl(dbg->u.prt.dprtstrparam1));\r\ncsio_info(hw, "\tdebug->dprtstrparam2 = 0x%x\n",\r\nntohl(dbg->u.prt.dprtstrparam2));\r\ncsio_info(hw, "\tdebug->dprtstrparam3 = 0x%x\n",\r\nntohl(dbg->u.prt.dprtstrparam3));\r\n} else {\r\ncsio_fatal(hw, "FW assertion at %.16s:%u, val0 %#x, val1 %#x\n",\r\ndbg->u.assert.filename_0_7,\r\nntohl(dbg->u.assert.line),\r\nntohl(dbg->u.assert.x),\r\nntohl(dbg->u.assert.y));\r\n}\r\n}\r\nstatic void\r\ncsio_mb_debug_cmd_handler(struct csio_hw *hw)\r\n{\r\nint i;\r\n__be64 cmd[CSIO_MB_MAX_REGS];\r\nuint32_t ctl_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_CTRL);\r\nuint32_t data_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_DATA);\r\nint size = sizeof(struct fw_debug_cmd);\r\nfor (i = 0; i < size; i += 8)\r\ncmd[i / 8] = cpu_to_be64(csio_rd_reg64(hw, data_reg + i));\r\ncsio_mb_dump_fw_dbg(hw, cmd);\r\ncsio_wr_reg32(hw, MBMSGVALID | MBINTREQ | MBOWNER(CSIO_MBOWNER_FW),\r\nctl_reg);\r\ncsio_rd_reg32(hw, ctl_reg);\r\nwmb();\r\n}\r\nint\r\ncsio_mb_issue(struct csio_hw *hw, struct csio_mb *mbp)\r\n{\r\nuint32_t owner, ctl;\r\nint i;\r\nuint32_t ii;\r\n__be64 *cmd = mbp->mb;\r\n__be64 hdr;\r\nstruct csio_mbm *mbm = &hw->mbm;\r\nuint32_t ctl_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_CTRL);\r\nuint32_t data_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_DATA);\r\nint size = mbp->mb_size;\r\nint rv = -EINVAL;\r\nstruct fw_cmd_hdr *fw_hdr;\r\nif (mbp->mb_cbfn == NULL) {\r\nif (mbp->tmo < CSIO_MB_POLL_FREQ) {\r\ncsio_err(hw, "Invalid tmo: 0x%x\n", mbp->tmo);\r\ngoto error_out;\r\n}\r\n} else if (!csio_is_host_intr_enabled(hw) ||\r\n!csio_is_hw_intr_enabled(hw)) {\r\ncsio_err(hw, "Cannot issue mailbox in interrupt mode 0x%x\n",\r\n*((uint8_t *)mbp->mb));\r\ngoto error_out;\r\n}\r\nif (mbm->mcurrent != NULL) {\r\nif (mbp->mb_cbfn == NULL) {\r\nrv = -EBUSY;\r\ncsio_dbg(hw, "Couldnt own Mailbox %x op:0x%x\n",\r\nhw->pfn, *((uint8_t *)mbp->mb));\r\ngoto error_out;\r\n} else {\r\nlist_add_tail(&mbp->list, &mbm->req_q);\r\nCSIO_INC_STATS(mbm, n_activeq);\r\nreturn 0;\r\n}\r\n}\r\nowner = MBOWNER_GET(csio_rd_reg32(hw, ctl_reg));\r\nif (!csio_mb_is_host_owner(owner)) {\r\nfor (i = 0; (owner == CSIO_MBOWNER_NONE) && (i < 3); i++)\r\nowner = MBOWNER_GET(csio_rd_reg32(hw, ctl_reg));\r\nif (!csio_mb_is_host_owner(owner)) {\r\nif (mbp->mb_cbfn == NULL) {\r\nrv = owner ? -EBUSY : -ETIMEDOUT;\r\ncsio_dbg(hw,\r\n"Couldnt own Mailbox %x op:0x%x "\r\n"owner:%x\n",\r\nhw->pfn, *((uint8_t *)mbp->mb), owner);\r\ngoto error_out;\r\n} else {\r\nif (mbm->mcurrent == NULL) {\r\ncsio_err(hw,\r\n"Couldnt own Mailbox %x "\r\n"op:0x%x owner:%x\n",\r\nhw->pfn, *((uint8_t *)mbp->mb),\r\nowner);\r\ncsio_err(hw,\r\n"No outstanding driver"\r\n" mailbox as well\n");\r\ngoto error_out;\r\n}\r\n}\r\n}\r\n}\r\nfor (i = 0; i < size; i += 8) {\r\ncsio_wr_reg64(hw, be64_to_cpu(*cmd), data_reg + i);\r\ncmd++;\r\n}\r\nCSIO_DUMP_MB(hw, hw->pfn, data_reg);\r\nif (mbp->mb_cbfn != NULL) {\r\nmbm->mcurrent = mbp;\r\nmod_timer(&mbm->timer, jiffies + msecs_to_jiffies(mbp->tmo));\r\ncsio_wr_reg32(hw, MBMSGVALID | MBINTREQ |\r\nMBOWNER(CSIO_MBOWNER_FW), ctl_reg);\r\n} else\r\ncsio_wr_reg32(hw, MBMSGVALID | MBOWNER(CSIO_MBOWNER_FW),\r\nctl_reg);\r\ncsio_rd_reg32(hw, ctl_reg);\r\nwmb();\r\nCSIO_INC_STATS(mbm, n_req);\r\nif (mbp->mb_cbfn)\r\nreturn 0;\r\ncmd = mbp->mb;\r\nfor (ii = 0; ii < mbp->tmo; ii += CSIO_MB_POLL_FREQ) {\r\nmdelay(CSIO_MB_POLL_FREQ);\r\nctl = csio_rd_reg32(hw, ctl_reg);\r\nif (csio_mb_is_host_owner(MBOWNER_GET(ctl))) {\r\nif (!(ctl & MBMSGVALID)) {\r\ncsio_wr_reg32(hw, 0, ctl_reg);\r\ncontinue;\r\n}\r\nCSIO_DUMP_MB(hw, hw->pfn, data_reg);\r\nhdr = cpu_to_be64(csio_rd_reg64(hw, data_reg));\r\nfw_hdr = (struct fw_cmd_hdr *)&hdr;\r\nswitch (FW_CMD_OP_GET(ntohl(fw_hdr->hi))) {\r\ncase FW_DEBUG_CMD:\r\ncsio_mb_debug_cmd_handler(hw);\r\ncontinue;\r\n}\r\nfor (i = 0; i < size; i += 8)\r\n*cmd++ = cpu_to_be64(csio_rd_reg64\r\n(hw, data_reg + i));\r\ncsio_wr_reg32(hw, 0, ctl_reg);\r\nif (csio_mb_fw_retval(mbp) != FW_SUCCESS)\r\nCSIO_INC_STATS(mbm, n_err);\r\nCSIO_INC_STATS(mbm, n_rsp);\r\nreturn 0;\r\n}\r\n}\r\nCSIO_INC_STATS(mbm, n_tmo);\r\ncsio_err(hw, "Mailbox %x op:0x%x timed out!\n",\r\nhw->pfn, *((uint8_t *)cmd));\r\nreturn -ETIMEDOUT;\r\nerror_out:\r\nCSIO_INC_STATS(mbm, n_err);\r\nreturn rv;\r\n}\r\nvoid\r\ncsio_mb_completions(struct csio_hw *hw, struct list_head *cbfn_q)\r\n{\r\nstruct csio_mb *mbp;\r\nstruct csio_mbm *mbm = &hw->mbm;\r\nenum fw_retval rv;\r\nwhile (!list_empty(cbfn_q)) {\r\nmbp = list_first_entry(cbfn_q, struct csio_mb, list);\r\nlist_del_init(&mbp->list);\r\nrv = csio_mb_fw_retval(mbp);\r\nif ((rv != FW_SUCCESS) && (rv != FW_HOSTERROR))\r\nCSIO_INC_STATS(mbm, n_err);\r\nelse if (rv != FW_HOSTERROR)\r\nCSIO_INC_STATS(mbm, n_rsp);\r\nif (mbp->mb_cbfn)\r\nmbp->mb_cbfn(hw, mbp);\r\n}\r\n}\r\nstatic void\r\ncsio_mb_portmod_changed(struct csio_hw *hw, uint8_t port_id)\r\n{\r\nstatic char *mod_str[] = {\r\nNULL, "LR", "SR", "ER", "TWINAX", "active TWINAX", "LRM"\r\n};\r\nstruct csio_pport *port = &hw->pport[port_id];\r\nif (port->mod_type == FW_PORT_MOD_TYPE_NONE)\r\ncsio_info(hw, "Port:%d - port module unplugged\n", port_id);\r\nelse if (port->mod_type < ARRAY_SIZE(mod_str))\r\ncsio_info(hw, "Port:%d - %s port module inserted\n", port_id,\r\nmod_str[port->mod_type]);\r\nelse if (port->mod_type == FW_PORT_MOD_TYPE_NOTSUPPORTED)\r\ncsio_info(hw,\r\n"Port:%d - unsupported optical port module "\r\n"inserted\n", port_id);\r\nelse if (port->mod_type == FW_PORT_MOD_TYPE_UNKNOWN)\r\ncsio_info(hw,\r\n"Port:%d - unknown port module inserted, forcing "\r\n"TWINAX\n", port_id);\r\nelse if (port->mod_type == FW_PORT_MOD_TYPE_ERROR)\r\ncsio_info(hw, "Port:%d - transceiver module error\n", port_id);\r\nelse\r\ncsio_info(hw, "Port:%d - unknown module type %d inserted\n",\r\nport_id, port->mod_type);\r\n}\r\nint\r\ncsio_mb_fwevt_handler(struct csio_hw *hw, __be64 *cmd)\r\n{\r\nuint8_t opcode = *(uint8_t *)cmd;\r\nstruct fw_port_cmd *pcmd;\r\nuint8_t port_id;\r\nuint32_t link_status;\r\nuint16_t action;\r\nuint8_t mod_type;\r\nif (opcode == FW_PORT_CMD) {\r\npcmd = (struct fw_port_cmd *)cmd;\r\nport_id = FW_PORT_CMD_PORTID_GET(\r\nntohl(pcmd->op_to_portid));\r\naction = FW_PORT_CMD_ACTION_GET(\r\nntohl(pcmd->action_to_len16));\r\nif (action != FW_PORT_ACTION_GET_PORT_INFO) {\r\ncsio_err(hw, "Unhandled FW_PORT_CMD action: %u\n",\r\naction);\r\nreturn -EINVAL;\r\n}\r\nlink_status = ntohl(pcmd->u.info.lstatus_to_modtype);\r\nmod_type = FW_PORT_CMD_MODTYPE_GET(link_status);\r\nhw->pport[port_id].link_status =\r\nFW_PORT_CMD_LSTATUS_GET(link_status);\r\nhw->pport[port_id].link_speed =\r\nFW_PORT_CMD_LSPEED_GET(link_status);\r\ncsio_info(hw, "Port:%x - LINK %s\n", port_id,\r\nFW_PORT_CMD_LSTATUS_GET(link_status) ? "UP" : "DOWN");\r\nif (mod_type != hw->pport[port_id].mod_type) {\r\nhw->pport[port_id].mod_type = mod_type;\r\ncsio_mb_portmod_changed(hw, port_id);\r\n}\r\n} else if (opcode == FW_DEBUG_CMD) {\r\ncsio_mb_dump_fw_dbg(hw, cmd);\r\n} else {\r\ncsio_dbg(hw, "Gen MB can't handle op:0x%x on evtq.\n", opcode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint\r\ncsio_mb_isr_handler(struct csio_hw *hw)\r\n{\r\nstruct csio_mbm *mbm = &hw->mbm;\r\nstruct csio_mb *mbp = mbm->mcurrent;\r\n__be64 *cmd;\r\nuint32_t ctl, cim_cause, pl_cause;\r\nint i;\r\nuint32_t ctl_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_CTRL);\r\nuint32_t data_reg = PF_REG(hw->pfn, CIM_PF_MAILBOX_DATA);\r\nint size;\r\n__be64 hdr;\r\nstruct fw_cmd_hdr *fw_hdr;\r\npl_cause = csio_rd_reg32(hw, MYPF_REG(PL_PF_INT_CAUSE));\r\ncim_cause = csio_rd_reg32(hw, MYPF_REG(CIM_PF_HOST_INT_CAUSE));\r\nif (!(pl_cause & PFCIM) || !(cim_cause & MBMSGRDYINT)) {\r\nCSIO_INC_STATS(hw, n_mbint_unexp);\r\nreturn -EINVAL;\r\n}\r\ncsio_wr_reg32(hw, MBMSGRDYINT, MYPF_REG(CIM_PF_HOST_INT_CAUSE));\r\ncsio_wr_reg32(hw, PFCIM, MYPF_REG(PL_PF_INT_CAUSE));\r\nctl = csio_rd_reg32(hw, ctl_reg);\r\nif (csio_mb_is_host_owner(MBOWNER_GET(ctl))) {\r\nCSIO_DUMP_MB(hw, hw->pfn, data_reg);\r\nif (!(ctl & MBMSGVALID)) {\r\ncsio_warn(hw,\r\n"Stray mailbox interrupt recvd,"\r\n" mailbox data not valid\n");\r\ncsio_wr_reg32(hw, 0, ctl_reg);\r\ncsio_rd_reg32(hw, ctl_reg);\r\nreturn -EINVAL;\r\n}\r\nhdr = cpu_to_be64(csio_rd_reg64(hw, data_reg));\r\nfw_hdr = (struct fw_cmd_hdr *)&hdr;\r\nswitch (FW_CMD_OP_GET(ntohl(fw_hdr->hi))) {\r\ncase FW_DEBUG_CMD:\r\ncsio_mb_debug_cmd_handler(hw);\r\nreturn -EINVAL;\r\n#if 0\r\ncase FW_ERROR_CMD:\r\ncase FW_INITIALIZE_CMD:\r\n#endif\r\n}\r\nCSIO_ASSERT(mbp != NULL);\r\ncmd = mbp->mb;\r\nsize = mbp->mb_size;\r\nfor (i = 0; i < size; i += 8)\r\n*cmd++ = cpu_to_be64(csio_rd_reg64\r\n(hw, data_reg + i));\r\ncsio_wr_reg32(hw, 0, ctl_reg);\r\ncsio_rd_reg32(hw, ctl_reg);\r\nmbm->mcurrent = NULL;\r\nlist_add_tail(&mbp->list, &mbm->cbfn_q);\r\nCSIO_INC_STATS(mbm, n_cbfnq);\r\nif (csio_enqueue_evt(hw, CSIO_EVT_MBX, mbp, sizeof(mbp)))\r\nCSIO_INC_STATS(hw, n_evt_drop);\r\nreturn 0;\r\n} else {\r\ncsio_dbg(hw, "Host not owner, no mailbox interrupt\n");\r\nCSIO_INC_STATS(hw, n_int_stray);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstruct csio_mb *\r\ncsio_mb_tmo_handler(struct csio_hw *hw)\r\n{\r\nstruct csio_mbm *mbm = &hw->mbm;\r\nstruct csio_mb *mbp = mbm->mcurrent;\r\nstruct fw_cmd_hdr *fw_hdr;\r\nif (mbp == NULL) {\r\nCSIO_DB_ASSERT(0);\r\nreturn NULL;\r\n}\r\nfw_hdr = (struct fw_cmd_hdr *)(mbp->mb);\r\ncsio_dbg(hw, "Mailbox num:%x op:0x%x timed out\n", hw->pfn,\r\nFW_CMD_OP_GET(ntohl(fw_hdr->hi)));\r\nmbm->mcurrent = NULL;\r\nCSIO_INC_STATS(mbm, n_tmo);\r\nfw_hdr->lo = htonl(FW_CMD_RETVAL(FW_ETIMEDOUT));\r\nreturn mbp;\r\n}\r\nvoid\r\ncsio_mb_cancel_all(struct csio_hw *hw, struct list_head *cbfn_q)\r\n{\r\nstruct csio_mb *mbp;\r\nstruct csio_mbm *mbm = &hw->mbm;\r\nstruct fw_cmd_hdr *hdr;\r\nstruct list_head *tmp;\r\nif (mbm->mcurrent) {\r\nmbp = mbm->mcurrent;\r\ndel_timer_sync(&mbm->timer);\r\nlist_add_tail(&mbp->list, cbfn_q);\r\nmbm->mcurrent = NULL;\r\n}\r\nif (!list_empty(&mbm->req_q)) {\r\nlist_splice_tail_init(&mbm->req_q, cbfn_q);\r\nmbm->stats.n_activeq = 0;\r\n}\r\nif (!list_empty(&mbm->cbfn_q)) {\r\nlist_splice_tail_init(&mbm->cbfn_q, cbfn_q);\r\nmbm->stats.n_cbfnq = 0;\r\n}\r\nif (list_empty(cbfn_q))\r\nreturn;\r\nlist_for_each(tmp, cbfn_q) {\r\nmbp = (struct csio_mb *)tmp;\r\nhdr = (struct fw_cmd_hdr *)(mbp->mb);\r\ncsio_dbg(hw, "Cancelling pending mailbox num %x op:%x\n",\r\nhw->pfn, FW_CMD_OP_GET(ntohl(hdr->hi)));\r\nCSIO_INC_STATS(mbm, n_cancel);\r\nhdr->lo = htonl(FW_CMD_RETVAL(FW_HOSTERROR));\r\n}\r\n}\r\nint\r\ncsio_mbm_init(struct csio_mbm *mbm, struct csio_hw *hw,\r\nvoid (*timer_fn)(uintptr_t))\r\n{\r\nstruct timer_list *timer = &mbm->timer;\r\ninit_timer(timer);\r\ntimer->function = timer_fn;\r\ntimer->data = (unsigned long)hw;\r\nINIT_LIST_HEAD(&mbm->req_q);\r\nINIT_LIST_HEAD(&mbm->cbfn_q);\r\ncsio_set_mb_intr_idx(mbm, -1);\r\nreturn 0;\r\n}\r\nvoid\r\ncsio_mbm_exit(struct csio_mbm *mbm)\r\n{\r\ndel_timer_sync(&mbm->timer);\r\nCSIO_DB_ASSERT(mbm->mcurrent == NULL);\r\nCSIO_DB_ASSERT(list_empty(&mbm->req_q));\r\nCSIO_DB_ASSERT(list_empty(&mbm->cbfn_q));\r\n}
