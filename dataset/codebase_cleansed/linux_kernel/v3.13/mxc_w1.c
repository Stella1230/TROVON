static u8 mxc_w1_ds2_reset_bus(void *data)\r\n{\r\nu8 reg_val;\r\nunsigned int timeout_cnt = 0;\r\nstruct mxc_w1_device *dev = data;\r\n__raw_writeb(0x80, (dev->regs + MXC_W1_CONTROL));\r\nwhile (1) {\r\nreg_val = __raw_readb(dev->regs + MXC_W1_CONTROL);\r\nif (((reg_val >> 7) & 0x1) == 0 ||\r\ntimeout_cnt > MXC_W1_RESET_TIMEOUT)\r\nbreak;\r\nelse\r\ntimeout_cnt++;\r\nudelay(100);\r\n}\r\nreturn (reg_val >> 7) & 0x1;\r\n}\r\nstatic u8 mxc_w1_ds2_touch_bit(void *data, u8 bit)\r\n{\r\nstruct mxc_w1_device *mdev = data;\r\nvoid __iomem *ctrl_addr = mdev->regs + MXC_W1_CONTROL;\r\nunsigned int timeout_cnt = 400;\r\n__raw_writeb((1 << (5 - bit)), ctrl_addr);\r\nwhile (timeout_cnt--) {\r\nif (!((__raw_readb(ctrl_addr) >> (5 - bit)) & 0x1))\r\nbreak;\r\nudelay(1);\r\n}\r\nreturn ((__raw_readb(ctrl_addr)) >> 3) & 0x1;\r\n}\r\nstatic int mxc_w1_probe(struct platform_device *pdev)\r\n{\r\nstruct mxc_w1_device *mdev;\r\nstruct resource *res;\r\nint err = 0;\r\nmdev = devm_kzalloc(&pdev->dev, sizeof(struct mxc_w1_device),\r\nGFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nmdev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(mdev->clk))\r\nreturn PTR_ERR(mdev->clk);\r\nmdev->clkdiv = (clk_get_rate(mdev->clk) / 1000000) - 1;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmdev->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mdev->regs))\r\nreturn PTR_ERR(mdev->regs);\r\nclk_prepare_enable(mdev->clk);\r\n__raw_writeb(mdev->clkdiv, mdev->regs + MXC_W1_TIME_DIVIDER);\r\nmdev->bus_master.data = mdev;\r\nmdev->bus_master.reset_bus = mxc_w1_ds2_reset_bus;\r\nmdev->bus_master.touch_bit = mxc_w1_ds2_touch_bit;\r\nerr = w1_add_master_device(&mdev->bus_master);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, mdev);\r\nreturn 0;\r\n}\r\nstatic int mxc_w1_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_w1_device *mdev = platform_get_drvdata(pdev);\r\nw1_remove_master_device(&mdev->bus_master);\r\nclk_disable_unprepare(mdev->clk);\r\nreturn 0;\r\n}
