static inline void print_err_status(struct stk1160 *dev,\r\nint packet, int status)\r\n{\r\nchar *errmsg = "Unknown";\r\nswitch (status) {\r\ncase -ENOENT:\r\nerrmsg = "unlinked synchronuously";\r\nbreak;\r\ncase -ECONNRESET:\r\nerrmsg = "unlinked asynchronuously";\r\nbreak;\r\ncase -ENOSR:\r\nerrmsg = "Buffer error (overrun)";\r\nbreak;\r\ncase -EPIPE:\r\nerrmsg = "Stalled (device not responding)";\r\nbreak;\r\ncase -EOVERFLOW:\r\nerrmsg = "Babble (bad cable?)";\r\nbreak;\r\ncase -EPROTO:\r\nerrmsg = "Bit-stuff error (bad cable?)";\r\nbreak;\r\ncase -EILSEQ:\r\nerrmsg = "CRC/Timeout (could be anything)";\r\nbreak;\r\ncase -ETIME:\r\nerrmsg = "Device does not respond";\r\nbreak;\r\n}\r\nif (packet < 0)\r\nprintk_ratelimited(KERN_WARNING "URB status %d [%s].\n",\r\nstatus, errmsg);\r\nelse\r\nprintk_ratelimited(KERN_INFO "URB packet %d, status %d [%s].\n",\r\npacket, status, errmsg);\r\n}\r\nstatic inline\r\nstruct stk1160_buffer *stk1160_next_buffer(struct stk1160 *dev)\r\n{\r\nstruct stk1160_buffer *buf = NULL;\r\nunsigned long flags = 0;\r\nWARN_ON(dev->isoc_ctl.buf);\r\nspin_lock_irqsave(&dev->buf_lock, flags);\r\nif (!list_empty(&dev->avail_bufs)) {\r\nbuf = list_first_entry(&dev->avail_bufs,\r\nstruct stk1160_buffer, list);\r\nlist_del(&buf->list);\r\n}\r\nspin_unlock_irqrestore(&dev->buf_lock, flags);\r\nreturn buf;\r\n}\r\nstatic inline\r\nvoid stk1160_buffer_done(struct stk1160 *dev)\r\n{\r\nstruct stk1160_buffer *buf = dev->isoc_ctl.buf;\r\ndev->field_count++;\r\nbuf->vb.v4l2_buf.sequence = dev->field_count >> 1;\r\nbuf->vb.v4l2_buf.field = V4L2_FIELD_INTERLACED;\r\nbuf->vb.v4l2_buf.bytesused = buf->bytesused;\r\nv4l2_get_timestamp(&buf->vb.v4l2_buf.timestamp);\r\nvb2_set_plane_payload(&buf->vb, 0, buf->bytesused);\r\nvb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);\r\ndev->isoc_ctl.buf = NULL;\r\n}\r\nstatic inline\r\nvoid stk1160_copy_video(struct stk1160 *dev, u8 *src, int len)\r\n{\r\nint linesdone, lineoff, lencopy;\r\nint bytesperline = dev->width * 2;\r\nstruct stk1160_buffer *buf = dev->isoc_ctl.buf;\r\nu8 *dst = buf->mem;\r\nint remain;\r\nlen -= 4;\r\nsrc += 4;\r\nremain = len;\r\nlinesdone = buf->pos / bytesperline;\r\nlineoff = buf->pos % bytesperline;\r\nif (!buf->odd)\r\ndst += bytesperline;\r\ndst += linesdone * bytesperline * 2 + lineoff;\r\nif (remain < (bytesperline - lineoff))\r\nlencopy = remain;\r\nelse\r\nlencopy = bytesperline - lineoff;\r\nif (lencopy > buf->bytesused - buf->length) {\r\nlencopy = buf->bytesused - buf->length;\r\nremain = lencopy;\r\n}\r\nif (lencopy == 0 || remain == 0)\r\nreturn;\r\nif (lencopy < 0) {\r\nstk1160_dbg("copy skipped: negative lencopy\n");\r\nreturn;\r\n}\r\nif ((unsigned long)dst + lencopy >\r\n(unsigned long)buf->mem + buf->length) {\r\nprintk_ratelimited(KERN_WARNING "stk1160: buffer overflow detected\n");\r\nreturn;\r\n}\r\nmemcpy(dst, src, lencopy);\r\nbuf->bytesused += lencopy;\r\nbuf->pos += lencopy;\r\nremain -= lencopy;\r\nwhile (remain > 0) {\r\ndst += lencopy + bytesperline;\r\nsrc += lencopy;\r\nif (remain < bytesperline)\r\nlencopy = remain;\r\nelse\r\nlencopy = bytesperline;\r\nif (lencopy > buf->bytesused - buf->length) {\r\nlencopy = buf->bytesused - buf->length;\r\nremain = lencopy;\r\n}\r\nif (lencopy == 0 || remain == 0)\r\nreturn;\r\nif (lencopy < 0) {\r\nprintk_ratelimited(KERN_WARNING "stk1160: negative lencopy detected\n");\r\nreturn;\r\n}\r\nif ((unsigned long)dst + lencopy >\r\n(unsigned long)buf->mem + buf->length) {\r\nprintk_ratelimited(KERN_WARNING "stk1160: buffer overflow detected\n");\r\nreturn;\r\n}\r\nmemcpy(dst, src, lencopy);\r\nremain -= lencopy;\r\nbuf->bytesused += lencopy;\r\nbuf->pos += lencopy;\r\n}\r\n}\r\nstatic void stk1160_process_isoc(struct stk1160 *dev, struct urb *urb)\r\n{\r\nint i, len, status;\r\nu8 *p;\r\nif (!dev) {\r\nstk1160_warn("%s called with null device\n", __func__);\r\nreturn;\r\n}\r\nif (urb->status < 0) {\r\nprint_err_status(dev, -1, urb->status);\r\nreturn;\r\n}\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nstatus = urb->iso_frame_desc[i].status;\r\nif (status < 0) {\r\nprint_err_status(dev, i, status);\r\ncontinue;\r\n}\r\np = urb->transfer_buffer + urb->iso_frame_desc[i].offset;\r\nlen = urb->iso_frame_desc[i].actual_length;\r\nif (len <= 4)\r\ncontinue;\r\nif (p[0] == 0xc0) {\r\nif (dev->isoc_ctl.buf != NULL)\r\nstk1160_buffer_done(dev);\r\ndev->isoc_ctl.buf = stk1160_next_buffer(dev);\r\nif (dev->isoc_ctl.buf == NULL)\r\nreturn;\r\n}\r\nif (dev->isoc_ctl.buf == NULL)\r\ncontinue;\r\nif (p[0] == 0xc0 || p[0] == 0x80) {\r\ndev->isoc_ctl.buf->odd = *p & 0x40;\r\ndev->isoc_ctl.buf->pos = 0;\r\ncontinue;\r\n}\r\nstk1160_copy_video(dev, p, len);\r\n}\r\n}\r\nstatic void stk1160_isoc_irq(struct urb *urb)\r\n{\r\nint i, rc;\r\nstruct stk1160 *dev = urb->context;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nstk1160_err("urb error! status %d\n", urb->status);\r\nreturn;\r\n}\r\nstk1160_process_isoc(dev, urb);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nrc = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (rc)\r\nstk1160_err("urb re-submit failed (%d)\n", rc);\r\n}\r\nvoid stk1160_cancel_isoc(struct stk1160 *dev)\r\n{\r\nint i, num_bufs = dev->isoc_ctl.num_bufs;\r\nif (!num_bufs)\r\nreturn;\r\nstk1160_dbg("killing %d urbs...\n", num_bufs);\r\nfor (i = 0; i < num_bufs; i++) {\r\nusb_kill_urb(dev->isoc_ctl.urb[i]);\r\n}\r\nstk1160_dbg("all urbs killed\n");\r\n}\r\nvoid stk1160_free_isoc(struct stk1160 *dev)\r\n{\r\nstruct urb *urb;\r\nint i, num_bufs = dev->isoc_ctl.num_bufs;\r\nstk1160_dbg("freeing %d urb buffers...\n", num_bufs);\r\nfor (i = 0; i < num_bufs; i++) {\r\nurb = dev->isoc_ctl.urb[i];\r\nif (urb) {\r\nif (dev->isoc_ctl.transfer_buffer[i]) {\r\n#ifndef CONFIG_DMA_NONCOHERENT\r\nusb_free_coherent(dev->udev,\r\nurb->transfer_buffer_length,\r\ndev->isoc_ctl.transfer_buffer[i],\r\nurb->transfer_dma);\r\n#else\r\nkfree(dev->isoc_ctl.transfer_buffer[i]);\r\n#endif\r\n}\r\nusb_free_urb(urb);\r\ndev->isoc_ctl.urb[i] = NULL;\r\n}\r\ndev->isoc_ctl.transfer_buffer[i] = NULL;\r\n}\r\nkfree(dev->isoc_ctl.urb);\r\nkfree(dev->isoc_ctl.transfer_buffer);\r\ndev->isoc_ctl.urb = NULL;\r\ndev->isoc_ctl.transfer_buffer = NULL;\r\ndev->isoc_ctl.num_bufs = 0;\r\nstk1160_dbg("all urb buffers freed\n");\r\n}\r\nvoid stk1160_uninit_isoc(struct stk1160 *dev)\r\n{\r\nstk1160_cancel_isoc(dev);\r\nstk1160_free_isoc(dev);\r\n}\r\nint stk1160_alloc_isoc(struct stk1160 *dev)\r\n{\r\nstruct urb *urb;\r\nint i, j, k, sb_size, max_packets, num_bufs;\r\nif (dev->isoc_ctl.num_bufs)\r\nstk1160_uninit_isoc(dev);\r\nstk1160_dbg("allocating urbs...\n");\r\nnum_bufs = STK1160_NUM_BUFS;\r\nmax_packets = STK1160_NUM_PACKETS;\r\nsb_size = max_packets * dev->max_pkt_size;\r\ndev->isoc_ctl.buf = NULL;\r\ndev->isoc_ctl.max_pkt_size = dev->max_pkt_size;\r\ndev->isoc_ctl.urb = kzalloc(sizeof(void *)*num_bufs, GFP_KERNEL);\r\nif (!dev->isoc_ctl.urb) {\r\nstk1160_err("out of memory for urb array\n");\r\nreturn -ENOMEM;\r\n}\r\ndev->isoc_ctl.transfer_buffer = kzalloc(sizeof(void *)*num_bufs,\r\nGFP_KERNEL);\r\nif (!dev->isoc_ctl.transfer_buffer) {\r\nstk1160_err("out of memory for usb transfers\n");\r\nkfree(dev->isoc_ctl.urb);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < num_bufs; i++) {\r\nurb = usb_alloc_urb(max_packets, GFP_KERNEL);\r\nif (!urb) {\r\nstk1160_err("cannot alloc urb[%d]\n", i);\r\ngoto free_i_bufs;\r\n}\r\ndev->isoc_ctl.urb[i] = urb;\r\n#ifndef CONFIG_DMA_NONCOHERENT\r\ndev->isoc_ctl.transfer_buffer[i] = usb_alloc_coherent(dev->udev,\r\nsb_size, GFP_KERNEL, &urb->transfer_dma);\r\n#else\r\ndev->isoc_ctl.transfer_buffer[i] = kmalloc(sb_size, GFP_KERNEL);\r\n#endif\r\nif (!dev->isoc_ctl.transfer_buffer[i]) {\r\nstk1160_err("cannot alloc %d bytes for tx[%d] buffer\n",\r\nsb_size, i);\r\nif (i < STK1160_MIN_BUFS)\r\ngoto free_i_bufs;\r\ngoto nomore_tx_bufs;\r\n}\r\nmemset(dev->isoc_ctl.transfer_buffer[i], 0, sb_size);\r\nurb->dev = dev->udev;\r\nurb->pipe = usb_rcvisocpipe(dev->udev, STK1160_EP_VIDEO);\r\nurb->transfer_buffer = dev->isoc_ctl.transfer_buffer[i];\r\nurb->transfer_buffer_length = sb_size;\r\nurb->complete = stk1160_isoc_irq;\r\nurb->context = dev;\r\nurb->interval = 1;\r\nurb->start_frame = 0;\r\nurb->number_of_packets = max_packets;\r\n#ifndef CONFIG_DMA_NONCOHERENT\r\nurb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\r\n#else\r\nurb->transfer_flags = URB_ISO_ASAP;\r\n#endif\r\nk = 0;\r\nfor (j = 0; j < max_packets; j++) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\ndev->isoc_ctl.max_pkt_size;\r\nk += dev->isoc_ctl.max_pkt_size;\r\n}\r\n}\r\nstk1160_dbg("%d urbs allocated\n", num_bufs);\r\ndev->isoc_ctl.num_bufs = num_bufs;\r\nreturn 0;\r\nnomore_tx_bufs:\r\nusb_free_urb(dev->isoc_ctl.urb[i]);\r\ndev->isoc_ctl.urb[i] = NULL;\r\nstk1160_warn("%d urbs allocated. Trying to continue...\n", i - 1);\r\ndev->isoc_ctl.num_bufs = i - 1;\r\nreturn 0;\r\nfree_i_bufs:\r\ndev->isoc_ctl.num_bufs = i+1;\r\nstk1160_free_isoc(dev);\r\nreturn -ENOMEM;\r\n}
