static struct rndis_device *get_rndis_device(void)\r\n{\r\nstruct rndis_device *device;\r\ndevice = kzalloc(sizeof(struct rndis_device), GFP_KERNEL);\r\nif (!device)\r\nreturn NULL;\r\nspin_lock_init(&device->request_lock);\r\nINIT_LIST_HEAD(&device->req_list);\r\ndevice->state = RNDIS_DEV_UNINITIALIZED;\r\nreturn device;\r\n}\r\nstatic struct rndis_request *get_rndis_request(struct rndis_device *dev,\r\nu32 msg_type,\r\nu32 msg_len)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_message *rndis_msg;\r\nstruct rndis_set_request *set;\r\nunsigned long flags;\r\nrequest = kzalloc(sizeof(struct rndis_request), GFP_KERNEL);\r\nif (!request)\r\nreturn NULL;\r\ninit_completion(&request->wait_event);\r\nrndis_msg = &request->request_msg;\r\nrndis_msg->ndis_msg_type = msg_type;\r\nrndis_msg->msg_len = msg_len;\r\nset = &rndis_msg->msg.set_req;\r\nset->req_id = atomic_inc_return(&dev->new_req_id);\r\nspin_lock_irqsave(&dev->request_lock, flags);\r\nlist_add_tail(&request->list_ent, &dev->req_list);\r\nspin_unlock_irqrestore(&dev->request_lock, flags);\r\nreturn request;\r\n}\r\nstatic void put_rndis_request(struct rndis_device *dev,\r\nstruct rndis_request *req)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->request_lock, flags);\r\nlist_del(&req->list_ent);\r\nspin_unlock_irqrestore(&dev->request_lock, flags);\r\nkfree(req);\r\n}\r\nstatic void dump_rndis_message(struct hv_device *hv_dev,\r\nstruct rndis_message *rndis_msg)\r\n{\r\nstruct net_device *netdev;\r\nstruct netvsc_device *net_device;\r\nnet_device = hv_get_drvdata(hv_dev);\r\nnetdev = net_device->ndev;\r\nswitch (rndis_msg->ndis_msg_type) {\r\ncase RNDIS_MSG_PACKET:\r\nnetdev_dbg(netdev, "RNDIS_MSG_PACKET (len %u, "\r\n"data offset %u data len %u, # oob %u, "\r\n"oob offset %u, oob len %u, pkt offset %u, "\r\n"pkt len %u\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.pkt.data_offset,\r\nrndis_msg->msg.pkt.data_len,\r\nrndis_msg->msg.pkt.num_oob_data_elements,\r\nrndis_msg->msg.pkt.oob_data_offset,\r\nrndis_msg->msg.pkt.oob_data_len,\r\nrndis_msg->msg.pkt.per_pkt_info_offset,\r\nrndis_msg->msg.pkt.per_pkt_info_len);\r\nbreak;\r\ncase RNDIS_MSG_INIT_C:\r\nnetdev_dbg(netdev, "RNDIS_MSG_INIT_C "\r\n"(len %u, id 0x%x, status 0x%x, major %d, minor %d, "\r\n"device flags %d, max xfer size 0x%x, max pkts %u, "\r\n"pkt aligned %u)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.init_complete.req_id,\r\nrndis_msg->msg.init_complete.status,\r\nrndis_msg->msg.init_complete.major_ver,\r\nrndis_msg->msg.init_complete.minor_ver,\r\nrndis_msg->msg.init_complete.dev_flags,\r\nrndis_msg->msg.init_complete.max_xfer_size,\r\nrndis_msg->msg.init_complete.\r\nmax_pkt_per_msg,\r\nrndis_msg->msg.init_complete.\r\npkt_alignment_factor);\r\nbreak;\r\ncase RNDIS_MSG_QUERY_C:\r\nnetdev_dbg(netdev, "RNDIS_MSG_QUERY_C "\r\n"(len %u, id 0x%x, status 0x%x, buf len %u, "\r\n"buf offset %u)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.query_complete.req_id,\r\nrndis_msg->msg.query_complete.status,\r\nrndis_msg->msg.query_complete.\r\ninfo_buflen,\r\nrndis_msg->msg.query_complete.\r\ninfo_buf_offset);\r\nbreak;\r\ncase RNDIS_MSG_SET_C:\r\nnetdev_dbg(netdev,\r\n"RNDIS_MSG_SET_C (len %u, id 0x%x, status 0x%x)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.set_complete.req_id,\r\nrndis_msg->msg.set_complete.status);\r\nbreak;\r\ncase RNDIS_MSG_INDICATE:\r\nnetdev_dbg(netdev, "RNDIS_MSG_INDICATE "\r\n"(len %u, status 0x%x, buf len %u, buf offset %u)\n",\r\nrndis_msg->msg_len,\r\nrndis_msg->msg.indicate_status.status,\r\nrndis_msg->msg.indicate_status.status_buflen,\r\nrndis_msg->msg.indicate_status.status_buf_offset);\r\nbreak;\r\ndefault:\r\nnetdev_dbg(netdev, "0x%x (len %u)\n",\r\nrndis_msg->ndis_msg_type,\r\nrndis_msg->msg_len);\r\nbreak;\r\n}\r\n}\r\nstatic int rndis_filter_send_request(struct rndis_device *dev,\r\nstruct rndis_request *req)\r\n{\r\nint ret;\r\nstruct hv_netvsc_packet *packet;\r\npacket = &req->pkt;\r\npacket->is_data_pkt = false;\r\npacket->total_data_buflen = req->request_msg.msg_len;\r\npacket->page_buf_cnt = 1;\r\npacket->page_buf[0].pfn = virt_to_phys(&req->request_msg) >>\r\nPAGE_SHIFT;\r\npacket->page_buf[0].len = req->request_msg.msg_len;\r\npacket->page_buf[0].offset =\r\n(unsigned long)&req->request_msg & (PAGE_SIZE - 1);\r\nif (packet->page_buf[0].offset + packet->page_buf[0].len > PAGE_SIZE) {\r\npacket->page_buf_cnt++;\r\npacket->page_buf[0].len = PAGE_SIZE -\r\npacket->page_buf[0].offset;\r\npacket->page_buf[1].pfn = virt_to_phys((void *)&req->request_msg\r\n+ packet->page_buf[0].len) >> PAGE_SHIFT;\r\npacket->page_buf[1].offset = 0;\r\npacket->page_buf[1].len = req->request_msg.msg_len -\r\npacket->page_buf[0].len;\r\n}\r\npacket->completion.send.send_completion = NULL;\r\nret = netvsc_send(dev->net_dev->dev, packet);\r\nreturn ret;\r\n}\r\nstatic void rndis_filter_receive_response(struct rndis_device *dev,\r\nstruct rndis_message *resp)\r\n{\r\nstruct rndis_request *request = NULL;\r\nbool found = false;\r\nunsigned long flags;\r\nstruct net_device *ndev;\r\nndev = dev->net_dev->ndev;\r\nspin_lock_irqsave(&dev->request_lock, flags);\r\nlist_for_each_entry(request, &dev->req_list, list_ent) {\r\nif (request->request_msg.msg.init_req.req_id\r\n== resp->msg.init_complete.req_id) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->request_lock, flags);\r\nif (found) {\r\nif (resp->msg_len <=\r\nsizeof(struct rndis_message) + RNDIS_EXT_LEN) {\r\nmemcpy(&request->response_msg, resp,\r\nresp->msg_len);\r\n} else {\r\nnetdev_err(ndev,\r\n"rndis response buffer overflow "\r\n"detected (size %u max %zu)\n",\r\nresp->msg_len,\r\nsizeof(struct rndis_filter_packet));\r\nif (resp->ndis_msg_type ==\r\nRNDIS_MSG_RESET_C) {\r\nrequest->response_msg.msg.reset_complete.\r\nstatus = RNDIS_STATUS_BUFFER_OVERFLOW;\r\n} else {\r\nrequest->response_msg.msg.\r\ninit_complete.status =\r\nRNDIS_STATUS_BUFFER_OVERFLOW;\r\n}\r\n}\r\ncomplete(&request->wait_event);\r\n} else {\r\nnetdev_err(ndev,\r\n"no rndis request found for this response "\r\n"(id 0x%x res type 0x%x)\n",\r\nresp->msg.init_complete.req_id,\r\nresp->ndis_msg_type);\r\n}\r\n}\r\nstatic void rndis_filter_receive_indicate_status(struct rndis_device *dev,\r\nstruct rndis_message *resp)\r\n{\r\nstruct rndis_indicate_status *indicate =\r\n&resp->msg.indicate_status;\r\nif (indicate->status == RNDIS_STATUS_MEDIA_CONNECT) {\r\nnetvsc_linkstatus_callback(\r\ndev->net_dev->dev, 1);\r\n} else if (indicate->status == RNDIS_STATUS_MEDIA_DISCONNECT) {\r\nnetvsc_linkstatus_callback(\r\ndev->net_dev->dev, 0);\r\n} else {\r\n}\r\n}\r\nstatic inline void *rndis_get_ppi(struct rndis_packet *rpkt, u32 type)\r\n{\r\nstruct rndis_per_packet_info *ppi;\r\nint len;\r\nif (rpkt->per_pkt_info_offset == 0)\r\nreturn NULL;\r\nppi = (struct rndis_per_packet_info *)((ulong)rpkt +\r\nrpkt->per_pkt_info_offset);\r\nlen = rpkt->per_pkt_info_len;\r\nwhile (len > 0) {\r\nif (ppi->type == type)\r\nreturn (void *)((ulong)ppi + ppi->ppi_offset);\r\nlen -= ppi->size;\r\nppi = (struct rndis_per_packet_info *)((ulong)ppi + ppi->size);\r\n}\r\nreturn NULL;\r\n}\r\nstatic void rndis_filter_receive_data(struct rndis_device *dev,\r\nstruct rndis_message *msg,\r\nstruct hv_netvsc_packet *pkt)\r\n{\r\nstruct rndis_packet *rndis_pkt;\r\nu32 data_offset;\r\nstruct ndis_pkt_8021q_info *vlan;\r\nrndis_pkt = &msg->msg.pkt;\r\ndata_offset = RNDIS_HEADER_SIZE + rndis_pkt->data_offset;\r\npkt->total_data_buflen -= data_offset;\r\nif (pkt->total_data_buflen < rndis_pkt->data_len) {\r\nnetdev_err(dev->net_dev->ndev, "rndis message buffer "\r\n"overflow detected (got %u, min %u)"\r\n"...dropping this message!\n",\r\npkt->total_data_buflen, rndis_pkt->data_len);\r\nreturn;\r\n}\r\npkt->total_data_buflen = rndis_pkt->data_len;\r\npkt->data = (void *)((unsigned long)pkt->data + data_offset);\r\npkt->is_data_pkt = true;\r\nvlan = rndis_get_ppi(rndis_pkt, IEEE_8021Q_INFO);\r\nif (vlan) {\r\npkt->vlan_tci = VLAN_TAG_PRESENT | vlan->vlanid |\r\n(vlan->pri << VLAN_PRIO_SHIFT);\r\n} else {\r\npkt->vlan_tci = 0;\r\n}\r\nnetvsc_recv_callback(dev->net_dev->dev, pkt);\r\n}\r\nint rndis_filter_receive(struct hv_device *dev,\r\nstruct hv_netvsc_packet *pkt)\r\n{\r\nstruct netvsc_device *net_dev = hv_get_drvdata(dev);\r\nstruct rndis_device *rndis_dev;\r\nstruct rndis_message *rndis_msg;\r\nstruct net_device *ndev;\r\nint ret = 0;\r\nif (!net_dev) {\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nndev = net_dev->ndev;\r\nif (!net_dev->extension) {\r\nnetdev_err(ndev, "got rndis message but no rndis device - "\r\n"dropping this message!\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nrndis_dev = (struct rndis_device *)net_dev->extension;\r\nif (rndis_dev->state == RNDIS_DEV_UNINITIALIZED) {\r\nnetdev_err(ndev, "got rndis message but rndis device "\r\n"uninitialized...dropping this message!\n");\r\nret = -ENODEV;\r\ngoto exit;\r\n}\r\nrndis_msg = pkt->data;\r\ndump_rndis_message(dev, rndis_msg);\r\nswitch (rndis_msg->ndis_msg_type) {\r\ncase RNDIS_MSG_PACKET:\r\nrndis_filter_receive_data(rndis_dev, rndis_msg, pkt);\r\nbreak;\r\ncase RNDIS_MSG_INIT_C:\r\ncase RNDIS_MSG_QUERY_C:\r\ncase RNDIS_MSG_SET_C:\r\nrndis_filter_receive_response(rndis_dev, rndis_msg);\r\nbreak;\r\ncase RNDIS_MSG_INDICATE:\r\nrndis_filter_receive_indicate_status(rndis_dev, rndis_msg);\r\nbreak;\r\ndefault:\r\nnetdev_err(ndev,\r\n"unhandled rndis message (type %u len %u)\n",\r\nrndis_msg->ndis_msg_type,\r\nrndis_msg->msg_len);\r\nbreak;\r\n}\r\nexit:\r\nif (ret != 0)\r\npkt->status = NVSP_STAT_FAIL;\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_query_device(struct rndis_device *dev, u32 oid,\r\nvoid *result, u32 *result_size)\r\n{\r\nstruct rndis_request *request;\r\nu32 inresult_size = *result_size;\r\nstruct rndis_query_request *query;\r\nstruct rndis_query_complete *query_complete;\r\nint ret = 0;\r\nint t;\r\nif (!result)\r\nreturn -EINVAL;\r\n*result_size = 0;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_QUERY,\r\nRNDIS_MESSAGE_SIZE(struct rndis_query_request));\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nquery = &request->request_msg.msg.query_req;\r\nquery->oid = oid;\r\nquery->info_buf_offset = sizeof(struct rndis_query_request);\r\nquery->info_buflen = 0;\r\nquery->dev_vc_handle = 0;\r\nret = rndis_filter_send_request(dev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\nquery_complete = &request->response_msg.msg.query_complete;\r\nif (query_complete->info_buflen > inresult_size) {\r\nret = -1;\r\ngoto cleanup;\r\n}\r\nmemcpy(result,\r\n(void *)((unsigned long)query_complete +\r\nquery_complete->info_buf_offset),\r\nquery_complete->info_buflen);\r\n*result_size = query_complete->info_buflen;\r\ncleanup:\r\nif (request)\r\nput_rndis_request(dev, request);\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_query_device_mac(struct rndis_device *dev)\r\n{\r\nu32 size = ETH_ALEN;\r\nreturn rndis_filter_query_device(dev,\r\nRNDIS_OID_802_3_PERMANENT_ADDRESS,\r\ndev->hw_mac_adr, &size);\r\n}\r\nint rndis_filter_set_device_mac(struct hv_device *hdev, char *mac)\r\n{\r\nstruct netvsc_device *nvdev = hv_get_drvdata(hdev);\r\nstruct rndis_device *rdev = nvdev->extension;\r\nstruct net_device *ndev = nvdev->ndev;\r\nstruct rndis_request *request;\r\nstruct rndis_set_request *set;\r\nstruct rndis_config_parameter_info *cpi;\r\nwchar_t *cfg_nwadr, *cfg_mac;\r\nstruct rndis_set_complete *set_complete;\r\nchar macstr[2*ETH_ALEN+1];\r\nu32 extlen = sizeof(struct rndis_config_parameter_info) +\r\n2*NWADR_STRLEN + 4*ETH_ALEN;\r\nint ret, t;\r\nrequest = get_rndis_request(rdev, RNDIS_MSG_SET,\r\nRNDIS_MESSAGE_SIZE(struct rndis_set_request) + extlen);\r\nif (!request)\r\nreturn -ENOMEM;\r\nset = &request->request_msg.msg.set_req;\r\nset->oid = RNDIS_OID_GEN_RNDIS_CONFIG_PARAMETER;\r\nset->info_buflen = extlen;\r\nset->info_buf_offset = sizeof(struct rndis_set_request);\r\nset->dev_vc_handle = 0;\r\ncpi = (struct rndis_config_parameter_info *)((ulong)set +\r\nset->info_buf_offset);\r\ncpi->parameter_name_offset =\r\nsizeof(struct rndis_config_parameter_info);\r\ncpi->parameter_name_length = 2*NWADR_STRLEN;\r\ncpi->parameter_type = RNDIS_CONFIG_PARAM_TYPE_STRING;\r\ncpi->parameter_value_offset =\r\ncpi->parameter_name_offset + cpi->parameter_name_length;\r\ncpi->parameter_value_length = 4*ETH_ALEN;\r\ncfg_nwadr = (wchar_t *)((ulong)cpi + cpi->parameter_name_offset);\r\ncfg_mac = (wchar_t *)((ulong)cpi + cpi->parameter_value_offset);\r\nret = utf8s_to_utf16s(NWADR_STR, NWADR_STRLEN, UTF16_HOST_ENDIAN,\r\ncfg_nwadr, NWADR_STRLEN);\r\nif (ret < 0)\r\ngoto cleanup;\r\nsnprintf(macstr, 2*ETH_ALEN+1, "%pm", mac);\r\nret = utf8s_to_utf16s(macstr, 2*ETH_ALEN, UTF16_HOST_ENDIAN,\r\ncfg_mac, 2*ETH_ALEN);\r\nif (ret < 0)\r\ngoto cleanup;\r\nret = rndis_filter_send_request(rdev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nnetdev_err(ndev, "timeout before we got a set response...\n");\r\nreturn -EBUSY;\r\n} else {\r\nset_complete = &request->response_msg.msg.set_complete;\r\nif (set_complete->status != RNDIS_STATUS_SUCCESS) {\r\nnetdev_err(ndev, "Fail to set MAC on host side:0x%x\n",\r\nset_complete->status);\r\nret = -EINVAL;\r\n}\r\n}\r\ncleanup:\r\nput_rndis_request(rdev, request);\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_query_device_link_status(struct rndis_device *dev)\r\n{\r\nu32 size = sizeof(u32);\r\nu32 link_status;\r\nint ret;\r\nret = rndis_filter_query_device(dev,\r\nRNDIS_OID_GEN_MEDIA_CONNECT_STATUS,\r\n&link_status, &size);\r\ndev->link_state = (link_status != 0) ? true : false;\r\nreturn ret;\r\n}\r\nint rndis_filter_set_packet_filter(struct rndis_device *dev, u32 new_filter)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_set_request *set;\r\nstruct rndis_set_complete *set_complete;\r\nu32 status;\r\nint ret, t;\r\nstruct net_device *ndev;\r\nndev = dev->net_dev->ndev;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_SET,\r\nRNDIS_MESSAGE_SIZE(struct rndis_set_request) +\r\nsizeof(u32));\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\nset = &request->request_msg.msg.set_req;\r\nset->oid = RNDIS_OID_GEN_CURRENT_PACKET_FILTER;\r\nset->info_buflen = sizeof(u32);\r\nset->info_buf_offset = sizeof(struct rndis_set_request);\r\nmemcpy((void *)(unsigned long)set + sizeof(struct rndis_set_request),\r\n&new_filter, sizeof(u32));\r\nret = rndis_filter_send_request(dev, request);\r\nif (ret != 0)\r\ngoto cleanup;\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nnetdev_err(ndev,\r\n"timeout before we got a set response...\n");\r\nret = -ETIMEDOUT;\r\ngoto exit;\r\n} else {\r\nset_complete = &request->response_msg.msg.set_complete;\r\nstatus = set_complete->status;\r\n}\r\ncleanup:\r\nif (request)\r\nput_rndis_request(dev, request);\r\nexit:\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_init_device(struct rndis_device *dev)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_initialize_request *init;\r\nstruct rndis_initialize_complete *init_complete;\r\nu32 status;\r\nint ret, t;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_INIT,\r\nRNDIS_MESSAGE_SIZE(struct rndis_initialize_request));\r\nif (!request) {\r\nret = -ENOMEM;\r\ngoto cleanup;\r\n}\r\ninit = &request->request_msg.msg.init_req;\r\ninit->major_ver = RNDIS_MAJOR_VERSION;\r\ninit->minor_ver = RNDIS_MINOR_VERSION;\r\ninit->max_xfer_size = 0x4000;\r\ndev->state = RNDIS_DEV_INITIALIZING;\r\nret = rndis_filter_send_request(dev, request);\r\nif (ret != 0) {\r\ndev->state = RNDIS_DEV_UNINITIALIZED;\r\ngoto cleanup;\r\n}\r\nt = wait_for_completion_timeout(&request->wait_event, 5*HZ);\r\nif (t == 0) {\r\nret = -ETIMEDOUT;\r\ngoto cleanup;\r\n}\r\ninit_complete = &request->response_msg.msg.init_complete;\r\nstatus = init_complete->status;\r\nif (status == RNDIS_STATUS_SUCCESS) {\r\ndev->state = RNDIS_DEV_INITIALIZED;\r\nret = 0;\r\n} else {\r\ndev->state = RNDIS_DEV_UNINITIALIZED;\r\nret = -EINVAL;\r\n}\r\ncleanup:\r\nif (request)\r\nput_rndis_request(dev, request);\r\nreturn ret;\r\n}\r\nstatic void rndis_filter_halt_device(struct rndis_device *dev)\r\n{\r\nstruct rndis_request *request;\r\nstruct rndis_halt_request *halt;\r\nstruct netvsc_device *nvdev = dev->net_dev;\r\nstruct hv_device *hdev = nvdev->dev;\r\nulong flags;\r\nrequest = get_rndis_request(dev, RNDIS_MSG_HALT,\r\nRNDIS_MESSAGE_SIZE(struct rndis_halt_request));\r\nif (!request)\r\ngoto cleanup;\r\nhalt = &request->request_msg.msg.halt_req;\r\nhalt->req_id = atomic_inc_return(&dev->new_req_id);\r\nrndis_filter_send_request(dev, request);\r\ndev->state = RNDIS_DEV_UNINITIALIZED;\r\ncleanup:\r\nspin_lock_irqsave(&hdev->channel->inbound_lock, flags);\r\nnvdev->destroy = true;\r\nspin_unlock_irqrestore(&hdev->channel->inbound_lock, flags);\r\nwait_event(nvdev->wait_drain,\r\natomic_read(&nvdev->num_outstanding_sends) == 0);\r\nif (request)\r\nput_rndis_request(dev, request);\r\nreturn;\r\n}\r\nstatic int rndis_filter_open_device(struct rndis_device *dev)\r\n{\r\nint ret;\r\nif (dev->state != RNDIS_DEV_INITIALIZED)\r\nreturn 0;\r\nret = rndis_filter_set_packet_filter(dev,\r\nNDIS_PACKET_TYPE_BROADCAST |\r\nNDIS_PACKET_TYPE_ALL_MULTICAST |\r\nNDIS_PACKET_TYPE_DIRECTED);\r\nif (ret == 0)\r\ndev->state = RNDIS_DEV_DATAINITIALIZED;\r\nreturn ret;\r\n}\r\nstatic int rndis_filter_close_device(struct rndis_device *dev)\r\n{\r\nint ret;\r\nif (dev->state != RNDIS_DEV_DATAINITIALIZED)\r\nreturn 0;\r\nret = rndis_filter_set_packet_filter(dev, 0);\r\nif (ret == 0)\r\ndev->state = RNDIS_DEV_INITIALIZED;\r\nreturn ret;\r\n}\r\nint rndis_filter_device_add(struct hv_device *dev,\r\nvoid *additional_info)\r\n{\r\nint ret;\r\nstruct netvsc_device *net_device;\r\nstruct rndis_device *rndis_device;\r\nstruct netvsc_device_info *device_info = additional_info;\r\nrndis_device = get_rndis_device();\r\nif (!rndis_device)\r\nreturn -ENODEV;\r\nret = netvsc_device_add(dev, additional_info);\r\nif (ret != 0) {\r\nkfree(rndis_device);\r\nreturn ret;\r\n}\r\nnet_device = hv_get_drvdata(dev);\r\nnet_device->extension = rndis_device;\r\nrndis_device->net_dev = net_device;\r\nret = rndis_filter_init_device(rndis_device);\r\nif (ret != 0) {\r\nrndis_filter_device_remove(dev);\r\nreturn ret;\r\n}\r\nret = rndis_filter_query_device_mac(rndis_device);\r\nif (ret != 0) {\r\nrndis_filter_device_remove(dev);\r\nreturn ret;\r\n}\r\nmemcpy(device_info->mac_adr, rndis_device->hw_mac_adr, ETH_ALEN);\r\nrndis_filter_query_device_link_status(rndis_device);\r\ndevice_info->link_state = rndis_device->link_state;\r\ndev_info(&dev->device, "Device MAC %pM link state %s\n",\r\nrndis_device->hw_mac_adr,\r\ndevice_info->link_state ? "down" : "up");\r\nreturn ret;\r\n}\r\nvoid rndis_filter_device_remove(struct hv_device *dev)\r\n{\r\nstruct netvsc_device *net_dev = hv_get_drvdata(dev);\r\nstruct rndis_device *rndis_dev = net_dev->extension;\r\nrndis_filter_halt_device(rndis_dev);\r\nkfree(rndis_dev);\r\nnet_dev->extension = NULL;\r\nnetvsc_device_remove(dev);\r\n}\r\nint rndis_filter_open(struct hv_device *dev)\r\n{\r\nstruct netvsc_device *net_device = hv_get_drvdata(dev);\r\nif (!net_device)\r\nreturn -EINVAL;\r\nreturn rndis_filter_open_device(net_device->extension);\r\n}\r\nint rndis_filter_close(struct hv_device *dev)\r\n{\r\nstruct netvsc_device *nvdev = hv_get_drvdata(dev);\r\nif (!nvdev)\r\nreturn -EINVAL;\r\nreturn rndis_filter_close_device(nvdev->extension);\r\n}\r\nint rndis_filter_send(struct hv_device *dev,\r\nstruct hv_netvsc_packet *pkt)\r\n{\r\nint ret;\r\nstruct rndis_filter_packet *filter_pkt;\r\nstruct rndis_message *rndis_msg;\r\nstruct rndis_packet *rndis_pkt;\r\nu32 rndis_msg_size;\r\nbool isvlan = pkt->vlan_tci & VLAN_TAG_PRESENT;\r\nfilter_pkt = (struct rndis_filter_packet *)pkt->extension;\r\nrndis_msg = &filter_pkt->msg;\r\nrndis_msg_size = RNDIS_MESSAGE_SIZE(struct rndis_packet);\r\nif (isvlan)\r\nrndis_msg_size += NDIS_VLAN_PPI_SIZE;\r\nrndis_msg->ndis_msg_type = RNDIS_MSG_PACKET;\r\nrndis_msg->msg_len = pkt->total_data_buflen +\r\nrndis_msg_size;\r\nrndis_pkt = &rndis_msg->msg.pkt;\r\nrndis_pkt->data_offset = sizeof(struct rndis_packet);\r\nif (isvlan)\r\nrndis_pkt->data_offset += NDIS_VLAN_PPI_SIZE;\r\nrndis_pkt->data_len = pkt->total_data_buflen;\r\nif (isvlan) {\r\nstruct rndis_per_packet_info *ppi;\r\nstruct ndis_pkt_8021q_info *vlan;\r\nrndis_pkt->per_pkt_info_offset = sizeof(struct rndis_packet);\r\nrndis_pkt->per_pkt_info_len = NDIS_VLAN_PPI_SIZE;\r\nppi = (struct rndis_per_packet_info *)((ulong)rndis_pkt +\r\nrndis_pkt->per_pkt_info_offset);\r\nppi->size = NDIS_VLAN_PPI_SIZE;\r\nppi->type = IEEE_8021Q_INFO;\r\nppi->ppi_offset = sizeof(struct rndis_per_packet_info);\r\nvlan = (struct ndis_pkt_8021q_info *)((ulong)ppi +\r\nppi->ppi_offset);\r\nvlan->vlanid = pkt->vlan_tci & VLAN_VID_MASK;\r\nvlan->pri = (pkt->vlan_tci & VLAN_PRIO_MASK) >> VLAN_PRIO_SHIFT;\r\n}\r\npkt->is_data_pkt = true;\r\npkt->page_buf[0].pfn = virt_to_phys(rndis_msg) >> PAGE_SHIFT;\r\npkt->page_buf[0].offset =\r\n(unsigned long)rndis_msg & (PAGE_SIZE-1);\r\npkt->page_buf[0].len = rndis_msg_size;\r\nif (pkt->page_buf[0].offset + rndis_msg_size > PAGE_SIZE) {\r\nint i;\r\nfor (i = pkt->page_buf_cnt; i > 1; i--)\r\npkt->page_buf[i] = pkt->page_buf[i-1];\r\npkt->page_buf_cnt++;\r\npkt->page_buf[0].len = PAGE_SIZE - pkt->page_buf[0].offset;\r\npkt->page_buf[1].pfn = virt_to_phys((void *)((ulong)\r\nrndis_msg + pkt->page_buf[0].len)) >> PAGE_SHIFT;\r\npkt->page_buf[1].offset = 0;\r\npkt->page_buf[1].len = rndis_msg_size - pkt->page_buf[0].len;\r\n}\r\nfilter_pkt->completion = pkt->completion.send.send_completion;\r\nfilter_pkt->completion_ctx =\r\npkt->completion.send.send_completion_ctx;\r\npkt->completion.send.send_completion = rndis_filter_send_completion;\r\npkt->completion.send.send_completion_ctx = filter_pkt;\r\nret = netvsc_send(dev, pkt);\r\nif (ret != 0) {\r\npkt->completion.send.send_completion =\r\nfilter_pkt->completion;\r\npkt->completion.send.send_completion_ctx =\r\nfilter_pkt->completion_ctx;\r\n}\r\nreturn ret;\r\n}\r\nstatic void rndis_filter_send_completion(void *ctx)\r\n{\r\nstruct rndis_filter_packet *filter_pkt = ctx;\r\nfilter_pkt->completion(filter_pkt->completion_ctx);\r\n}
