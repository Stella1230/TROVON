static u32 _rcar_thermal_common_read(struct rcar_thermal_common *common,\r\nu32 reg)\r\n{\r\nreturn ioread32(common->base + reg);\r\n}\r\nstatic void _rcar_thermal_common_write(struct rcar_thermal_common *common,\r\nu32 reg, u32 data)\r\n{\r\niowrite32(data, common->base + reg);\r\n}\r\nstatic void _rcar_thermal_common_bset(struct rcar_thermal_common *common,\r\nu32 reg, u32 mask, u32 data)\r\n{\r\nu32 val;\r\nval = ioread32(common->base + reg);\r\nval &= ~mask;\r\nval |= (data & mask);\r\niowrite32(val, common->base + reg);\r\n}\r\nstatic u32 _rcar_thermal_read(struct rcar_thermal_priv *priv, u32 reg)\r\n{\r\nreturn ioread32(priv->base + reg);\r\n}\r\nstatic void _rcar_thermal_write(struct rcar_thermal_priv *priv,\r\nu32 reg, u32 data)\r\n{\r\niowrite32(data, priv->base + reg);\r\n}\r\nstatic void _rcar_thermal_bset(struct rcar_thermal_priv *priv, u32 reg,\r\nu32 mask, u32 data)\r\n{\r\nu32 val;\r\nval = ioread32(priv->base + reg);\r\nval &= ~mask;\r\nval |= (data & mask);\r\niowrite32(val, priv->base + reg);\r\n}\r\nstatic int rcar_thermal_update_temp(struct rcar_thermal_priv *priv)\r\n{\r\nstruct device *dev = rcar_priv_to_dev(priv);\r\nint i;\r\nint ctemp, old, new;\r\nint ret = -EINVAL;\r\nmutex_lock(&priv->lock);\r\nrcar_thermal_bset(priv, THSCR, CPCTL, CPCTL);\r\nctemp = 0;\r\nold = ~0;\r\nfor (i = 0; i < 128; i++) {\r\nudelay(300);\r\nnew = rcar_thermal_read(priv, THSSR) & CTEMP;\r\nif (new == old) {\r\nctemp = new;\r\nbreak;\r\n}\r\nold = new;\r\n}\r\nif (!ctemp) {\r\ndev_err(dev, "thermal sensor was broken\n");\r\ngoto err_out_unlock;\r\n}\r\nif (rcar_has_irq_support(priv)) {\r\nrcar_thermal_write(priv, FILONOFF, 0);\r\nrcar_thermal_write(priv, POSNEG, 0x1);\r\nrcar_thermal_write(priv, INTCTRL, (((ctemp - 0) << 8) |\r\n((ctemp - 1) << 0)));\r\n}\r\ndev_dbg(dev, "thermal%d %d -> %d\n", priv->id, priv->ctemp, ctemp);\r\npriv->ctemp = ctemp;\r\nret = 0;\r\nerr_out_unlock:\r\nmutex_unlock(&priv->lock);\r\nreturn ret;\r\n}\r\nstatic int rcar_thermal_get_temp(struct thermal_zone_device *zone,\r\nunsigned long *temp)\r\n{\r\nstruct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);\r\nif (!rcar_has_irq_support(priv) || rcar_force_update_temp(priv))\r\nrcar_thermal_update_temp(priv);\r\nmutex_lock(&priv->lock);\r\n*temp = MCELSIUS((priv->ctemp * 5) - 65);\r\nmutex_unlock(&priv->lock);\r\nreturn 0;\r\n}\r\nstatic int rcar_thermal_get_trip_type(struct thermal_zone_device *zone,\r\nint trip, enum thermal_trip_type *type)\r\n{\r\nstruct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);\r\nstruct device *dev = rcar_priv_to_dev(priv);\r\nswitch (trip) {\r\ncase 0:\r\n*type = THERMAL_TRIP_CRITICAL;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "rcar driver trip error\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rcar_thermal_get_trip_temp(struct thermal_zone_device *zone,\r\nint trip, unsigned long *temp)\r\n{\r\nstruct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);\r\nstruct device *dev = rcar_priv_to_dev(priv);\r\nswitch (trip) {\r\ncase 0:\r\n*temp = MCELSIUS(90);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "rcar driver trip error\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rcar_thermal_notify(struct thermal_zone_device *zone,\r\nint trip, enum thermal_trip_type type)\r\n{\r\nstruct rcar_thermal_priv *priv = rcar_zone_to_priv(zone);\r\nstruct device *dev = rcar_priv_to_dev(priv);\r\nswitch (type) {\r\ncase THERMAL_TRIP_CRITICAL:\r\ndev_warn(dev, "Thermal reached to critical temperature\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void _rcar_thermal_irq_ctrl(struct rcar_thermal_priv *priv, int enable)\r\n{\r\nstruct rcar_thermal_common *common = priv->common;\r\nunsigned long flags;\r\nu32 mask = 0x3 << rcar_id_to_shift(priv);\r\nspin_lock_irqsave(&common->lock, flags);\r\nrcar_thermal_common_bset(common, INTMSK, mask, enable ? 0 : mask);\r\nspin_unlock_irqrestore(&common->lock, flags);\r\n}\r\nstatic void rcar_thermal_work(struct work_struct *work)\r\n{\r\nstruct rcar_thermal_priv *priv;\r\npriv = container_of(work, struct rcar_thermal_priv, work.work);\r\nrcar_thermal_update_temp(priv);\r\nrcar_thermal_irq_enable(priv);\r\nthermal_zone_device_update(priv->zone);\r\n}\r\nstatic u32 rcar_thermal_had_changed(struct rcar_thermal_priv *priv, u32 status)\r\n{\r\nstruct device *dev = rcar_priv_to_dev(priv);\r\nstatus = (status >> rcar_id_to_shift(priv)) & 0x3;\r\nif (status & 0x3) {\r\ndev_dbg(dev, "thermal%d %s%s\n",\r\npriv->id,\r\n(status & 0x2) ? "Rising " : "",\r\n(status & 0x1) ? "Falling" : "");\r\n}\r\nreturn status;\r\n}\r\nstatic irqreturn_t rcar_thermal_irq(int irq, void *data)\r\n{\r\nstruct rcar_thermal_common *common = data;\r\nstruct rcar_thermal_priv *priv;\r\nunsigned long flags;\r\nu32 status, mask;\r\nspin_lock_irqsave(&common->lock, flags);\r\nmask = rcar_thermal_common_read(common, INTMSK);\r\nstatus = rcar_thermal_common_read(common, STR);\r\nrcar_thermal_common_write(common, STR, 0x000F0F0F & mask);\r\nspin_unlock_irqrestore(&common->lock, flags);\r\nstatus = status & ~mask;\r\nrcar_thermal_for_each_priv(priv, common) {\r\nif (rcar_thermal_had_changed(priv, status)) {\r\nrcar_thermal_irq_disable(priv);\r\nschedule_delayed_work(&priv->work,\r\nmsecs_to_jiffies(300));\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rcar_thermal_probe(struct platform_device *pdev)\r\n{\r\nstruct rcar_thermal_common *common;\r\nstruct rcar_thermal_priv *priv;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res, *irq;\r\nint mres = 0;\r\nint i;\r\nint ret = -ENODEV;\r\nint idle = IDLE_INTERVAL;\r\ncommon = devm_kzalloc(dev, sizeof(*common), GFP_KERNEL);\r\nif (!common) {\r\ndev_err(dev, "Could not allocate common\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_LIST_HEAD(&common->head);\r\nspin_lock_init(&common->lock);\r\ncommon->dev = dev;\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (irq) {\r\nint ret;\r\nret = devm_request_irq(dev, irq->start, rcar_thermal_irq, 0,\r\ndev_name(dev), common);\r\nif (ret) {\r\ndev_err(dev, "irq request failed\n ");\r\nreturn ret;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, mres++);\r\ncommon->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(common->base))\r\nreturn PTR_ERR(common->base);\r\nrcar_thermal_common_write(common, ENR, 0x00030303);\r\nidle = 0;\r\n}\r\nfor (i = 0;; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, mres++);\r\nif (!res)\r\nbreak;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\ndev_err(dev, "Could not allocate priv\n");\r\nret = -ENOMEM;\r\ngoto error_unregister;\r\n}\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base)) {\r\nret = PTR_ERR(priv->base);\r\ngoto error_unregister;\r\n}\r\npriv->common = common;\r\npriv->id = i;\r\nmutex_init(&priv->lock);\r\nINIT_LIST_HEAD(&priv->list);\r\nINIT_DELAYED_WORK(&priv->work, rcar_thermal_work);\r\nrcar_thermal_update_temp(priv);\r\npriv->zone = thermal_zone_device_register("rcar_thermal",\r\n1, 0, priv,\r\n&rcar_thermal_zone_ops, NULL, 0,\r\nidle);\r\nif (IS_ERR(priv->zone)) {\r\ndev_err(dev, "can't register thermal zone\n");\r\nret = PTR_ERR(priv->zone);\r\ngoto error_unregister;\r\n}\r\nif (rcar_has_irq_support(priv))\r\nrcar_thermal_irq_enable(priv);\r\nlist_move_tail(&priv->list, &common->head);\r\n}\r\nplatform_set_drvdata(pdev, common);\r\ndev_info(dev, "%d sensor probed\n", i);\r\nreturn 0;\r\nerror_unregister:\r\nrcar_thermal_for_each_priv(priv, common) {\r\nthermal_zone_device_unregister(priv->zone);\r\nif (rcar_has_irq_support(priv))\r\nrcar_thermal_irq_disable(priv);\r\n}\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int rcar_thermal_remove(struct platform_device *pdev)\r\n{\r\nstruct rcar_thermal_common *common = platform_get_drvdata(pdev);\r\nstruct device *dev = &pdev->dev;\r\nstruct rcar_thermal_priv *priv;\r\nrcar_thermal_for_each_priv(priv, common) {\r\nthermal_zone_device_unregister(priv->zone);\r\nif (rcar_has_irq_support(priv))\r\nrcar_thermal_irq_disable(priv);\r\n}\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nreturn 0;\r\n}
