static void update_irq(struct mdp4_kms *mdp4_kms)\r\n{\r\nstruct mdp4_irq *irq;\r\nuint32_t irqmask = mdp4_kms->vblank_mask;\r\nBUG_ON(!spin_is_locked(&list_lock));\r\nlist_for_each_entry(irq, &mdp4_kms->irq_list, node)\r\nirqmask |= irq->irqmask;\r\nmdp4_write(mdp4_kms, REG_MDP4_INTR_ENABLE, irqmask);\r\n}\r\nstatic void update_irq_unlocked(struct mdp4_kms *mdp4_kms)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nupdate_irq(mdp4_kms);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\n}\r\nstatic void mdp4_irq_error_handler(struct mdp4_irq *irq, uint32_t irqstatus)\r\n{\r\nDRM_ERROR("errors: %08x\n", irqstatus);\r\n}\r\nvoid mdp4_irq_preinstall(struct msm_kms *kms)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(kms);\r\nmdp4_write(mdp4_kms, REG_MDP4_INTR_CLEAR, 0xffffffff);\r\n}\r\nint mdp4_irq_postinstall(struct msm_kms *kms)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(kms);\r\nstruct mdp4_irq *error_handler = &mdp4_kms->error_handler;\r\nINIT_LIST_HEAD(&mdp4_kms->irq_list);\r\nerror_handler->irq = mdp4_irq_error_handler;\r\nerror_handler->irqmask = MDP4_IRQ_PRIMARY_INTF_UDERRUN |\r\nMDP4_IRQ_EXTERNAL_INTF_UDERRUN;\r\nmdp4_irq_register(mdp4_kms, error_handler);\r\nreturn 0;\r\n}\r\nvoid mdp4_irq_uninstall(struct msm_kms *kms)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(kms);\r\nmdp4_write(mdp4_kms, REG_MDP4_INTR_ENABLE, 0x00000000);\r\n}\r\nirqreturn_t mdp4_irq(struct msm_kms *kms)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(kms);\r\nstruct drm_device *dev = mdp4_kms->dev;\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct mdp4_irq *handler, *n;\r\nunsigned long flags;\r\nunsigned int id;\r\nuint32_t status;\r\nstatus = mdp4_read(mdp4_kms, REG_MDP4_INTR_STATUS);\r\nmdp4_write(mdp4_kms, REG_MDP4_INTR_CLEAR, status);\r\nVERB("status=%08x", status);\r\nfor (id = 0; id < priv->num_crtcs; id++)\r\nif (status & mdp4_crtc_vblank(priv->crtcs[id]))\r\ndrm_handle_vblank(dev, id);\r\nspin_lock_irqsave(&list_lock, flags);\r\nmdp4_kms->in_irq = true;\r\nlist_for_each_entry_safe(handler, n, &mdp4_kms->irq_list, node) {\r\nif (handler->irqmask & status) {\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nhandler->irq(handler, handler->irqmask & status);\r\nspin_lock_irqsave(&list_lock, flags);\r\n}\r\n}\r\nmdp4_kms->in_irq = false;\r\nupdate_irq(mdp4_kms);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mdp4_enable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(kms);\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nmdp4_kms->vblank_mask |= mdp4_crtc_vblank(crtc);\r\nupdate_irq(mdp4_kms);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nreturn 0;\r\n}\r\nvoid mdp4_disable_vblank(struct msm_kms *kms, struct drm_crtc *crtc)\r\n{\r\nstruct mdp4_kms *mdp4_kms = to_mdp4_kms(kms);\r\nunsigned long flags;\r\nspin_lock_irqsave(&list_lock, flags);\r\nmdp4_kms->vblank_mask &= ~mdp4_crtc_vblank(crtc);\r\nupdate_irq(mdp4_kms);\r\nspin_unlock_irqrestore(&list_lock, flags);\r\n}\r\nstatic void wait_irq(struct mdp4_irq *irq, uint32_t irqstatus)\r\n{\r\nstruct mdp4_irq_wait *wait =\r\ncontainer_of(irq, struct mdp4_irq_wait, irq);\r\nwait->count--;\r\nwake_up_all(&wait_event);\r\n}\r\nvoid mdp4_irq_wait(struct mdp4_kms *mdp4_kms, uint32_t irqmask)\r\n{\r\nstruct mdp4_irq_wait wait = {\r\n.irq = {\r\n.irq = wait_irq,\r\n.irqmask = irqmask,\r\n},\r\n.count = 1,\r\n};\r\nmdp4_irq_register(mdp4_kms, &wait.irq);\r\nwait_event(wait_event, (wait.count <= 0));\r\nmdp4_irq_unregister(mdp4_kms, &wait.irq);\r\n}\r\nvoid mdp4_irq_register(struct mdp4_kms *mdp4_kms, struct mdp4_irq *irq)\r\n{\r\nunsigned long flags;\r\nbool needs_update = false;\r\nspin_lock_irqsave(&list_lock, flags);\r\nif (!irq->registered) {\r\nirq->registered = true;\r\nlist_add(&irq->node, &mdp4_kms->irq_list);\r\nneeds_update = !mdp4_kms->in_irq;\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nif (needs_update)\r\nupdate_irq_unlocked(mdp4_kms);\r\n}\r\nvoid mdp4_irq_unregister(struct mdp4_kms *mdp4_kms, struct mdp4_irq *irq)\r\n{\r\nunsigned long flags;\r\nbool needs_update = false;\r\nspin_lock_irqsave(&list_lock, flags);\r\nif (irq->registered) {\r\nirq->registered = false;\r\nlist_del(&irq->node);\r\nneeds_update = !mdp4_kms->in_irq;\r\n}\r\nspin_unlock_irqrestore(&list_lock, flags);\r\nif (needs_update)\r\nupdate_irq_unlocked(mdp4_kms);\r\n}
