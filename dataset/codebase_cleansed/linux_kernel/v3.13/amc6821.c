static ssize_t get_temp(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nint ix = to_sensor_dev_attr(devattr)->index;\r\nreturn sprintf(buf, "%d\n", data->temp[ix] * 1000);\r\n}\r\nstatic ssize_t set_temp(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nint ix = to_sensor_dev_attr(attr)->index;\r\nlong val;\r\nint ret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = clamp_val(val / 1000, -128, 127);\r\nmutex_lock(&data->update_lock);\r\ndata->temp[ix] = val;\r\nif (i2c_smbus_write_byte_data(client, temp_reg[ix], data->temp[ix])) {\r\ndev_err(&client->dev, "Register write error, aborting.\n");\r\ncount = -EIO;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_temp_alarm(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nint ix = to_sensor_dev_attr(devattr)->index;\r\nu8 flag;\r\nswitch (ix) {\r\ncase IDX_TEMP1_MIN:\r\nflag = data->stat1 & AMC6821_STAT1_LTL;\r\nbreak;\r\ncase IDX_TEMP1_MAX:\r\nflag = data->stat1 & AMC6821_STAT1_LTH;\r\nbreak;\r\ncase IDX_TEMP1_CRIT:\r\nflag = data->stat2 & AMC6821_STAT2_LTC;\r\nbreak;\r\ncase IDX_TEMP2_MIN:\r\nflag = data->stat1 & AMC6821_STAT1_RTL;\r\nbreak;\r\ncase IDX_TEMP2_MAX:\r\nflag = data->stat1 & AMC6821_STAT1_RTH;\r\nbreak;\r\ncase IDX_TEMP2_CRIT:\r\nflag = data->stat2 & AMC6821_STAT2_RTC;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr->index (%d).\n", ix);\r\nreturn -EINVAL;\r\n}\r\nif (flag)\r\nreturn sprintf(buf, "1");\r\nelse\r\nreturn sprintf(buf, "0");\r\n}\r\nstatic ssize_t get_temp2_fault(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nif (data->stat1 & AMC6821_STAT1_RTF)\r\nreturn sprintf(buf, "1");\r\nelse\r\nreturn sprintf(buf, "0");\r\n}\r\nstatic ssize_t get_pwm1(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1);\r\n}\r\nstatic ssize_t set_pwm1(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint ret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm1 = clamp_val(val , 0, 255);\r\ni2c_smbus_write_byte_data(client, AMC6821_REG_DCY, data->pwm1);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm1_enable(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1_enable);\r\n}\r\nstatic ssize_t set_pwm1_enable(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint config = kstrtol(buf, 10, &val);\r\nif (config)\r\nreturn config;\r\nconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF1);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Error reading configuration register, aborting.\n");\r\nreturn config;\r\n}\r\nswitch (val) {\r\ncase 1:\r\nconfig &= ~AMC6821_CONF1_FDRC0;\r\nconfig &= ~AMC6821_CONF1_FDRC1;\r\nbreak;\r\ncase 2:\r\nconfig &= ~AMC6821_CONF1_FDRC0;\r\nconfig |= AMC6821_CONF1_FDRC1;\r\nbreak;\r\ncase 3:\r\nconfig |= AMC6821_CONF1_FDRC0;\r\nconfig |= AMC6821_CONF1_FDRC1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&data->update_lock);\r\nif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF1, config)) {\r\ndev_err(&client->dev,\r\n"Configuration register write error, aborting.\n");\r\ncount = -EIO;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_pwm1_auto_channels_temp(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1_auto_channels_temp);\r\n}\r\nstatic ssize_t get_temp_auto_point_temp(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint ix = to_sensor_dev_attr_2(devattr)->index;\r\nint nr = to_sensor_dev_attr_2(devattr)->nr;\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nswitch (nr) {\r\ncase 1:\r\nreturn sprintf(buf, "%d\n",\r\ndata->temp1_auto_point_temp[ix] * 1000);\r\ncase 2:\r\nreturn sprintf(buf, "%d\n",\r\ndata->temp2_auto_point_temp[ix] * 1000);\r\ndefault:\r\ndev_dbg(dev, "Unknown attr->nr (%d).\n", nr);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic ssize_t get_pwm1_auto_point_pwm(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nint ix = to_sensor_dev_attr(devattr)->index;\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm1_auto_point_pwm[ix]);\r\n}\r\nstatic inline ssize_t set_slope_register(struct i2c_client *client,\r\nu8 reg,\r\nu8 dpwm,\r\nu8 *ptemp)\r\n{\r\nint dt;\r\nu8 tmp;\r\ndt = ptemp[2]-ptemp[1];\r\nfor (tmp = 4; tmp > 0; tmp--) {\r\nif (dt * (0x20 >> tmp) >= dpwm)\r\nbreak;\r\n}\r\ntmp |= (ptemp[1] & 0x7C) << 1;\r\nif (i2c_smbus_write_byte_data(client,\r\nreg, tmp)) {\r\ndev_err(&client->dev, "Register write error, aborting.\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t set_temp_auto_point_temp(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nint ix = to_sensor_dev_attr_2(attr)->index;\r\nint nr = to_sensor_dev_attr_2(attr)->nr;\r\nu8 *ptemp;\r\nu8 reg;\r\nint dpwm;\r\nlong val;\r\nint ret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nswitch (nr) {\r\ncase 1:\r\nptemp = data->temp1_auto_point_temp;\r\nreg = AMC6821_REG_LTEMP_FAN_CTRL;\r\nbreak;\r\ncase 2:\r\nptemp = data->temp2_auto_point_temp;\r\nreg = AMC6821_REG_RTEMP_FAN_CTRL;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr->nr (%d).\n", nr);\r\nreturn -EINVAL;\r\n}\r\ndata->valid = 0;\r\nmutex_lock(&data->update_lock);\r\nswitch (ix) {\r\ncase 0:\r\nptemp[0] = clamp_val(val / 1000, 0,\r\ndata->temp1_auto_point_temp[1]);\r\nptemp[0] = clamp_val(ptemp[0], 0,\r\ndata->temp2_auto_point_temp[1]);\r\nptemp[0] = clamp_val(ptemp[0], 0, 63);\r\nif (i2c_smbus_write_byte_data(\r\nclient,\r\nAMC6821_REG_PSV_TEMP,\r\nptemp[0])) {\r\ndev_err(&client->dev,\r\n"Register write error, aborting.\n");\r\ncount = -EIO;\r\n}\r\ngoto EXIT;\r\ncase 1:\r\nptemp[1] = clamp_val(val / 1000, (ptemp[0] & 0x7C) + 4, 124);\r\nptemp[1] &= 0x7C;\r\nptemp[2] = clamp_val(ptemp[2], ptemp[1] + 1, 255);\r\nbreak;\r\ncase 2:\r\nptemp[2] = clamp_val(val / 1000, ptemp[1]+1, 255);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "Unknown attr->index (%d).\n", ix);\r\ncount = -EINVAL;\r\ngoto EXIT;\r\n}\r\ndpwm = data->pwm1_auto_point_pwm[2] - data->pwm1_auto_point_pwm[1];\r\nif (set_slope_register(client, reg, dpwm, ptemp))\r\ncount = -EIO;\r\nEXIT:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm1_auto_point_pwm(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nint dpwm;\r\nlong val;\r\nint ret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm1_auto_point_pwm[1] = clamp_val(val, 0, 254);\r\nif (i2c_smbus_write_byte_data(client, AMC6821_REG_DCY_LOW_TEMP,\r\ndata->pwm1_auto_point_pwm[1])) {\r\ndev_err(&client->dev, "Register write error, aborting.\n");\r\ncount = -EIO;\r\ngoto EXIT;\r\n}\r\ndpwm = data->pwm1_auto_point_pwm[2] - data->pwm1_auto_point_pwm[1];\r\nif (set_slope_register(client, AMC6821_REG_LTEMP_FAN_CTRL, dpwm,\r\ndata->temp1_auto_point_temp)) {\r\ncount = -EIO;\r\ngoto EXIT;\r\n}\r\nif (set_slope_register(client, AMC6821_REG_RTEMP_FAN_CTRL, dpwm,\r\ndata->temp2_auto_point_temp)) {\r\ncount = -EIO;\r\ngoto EXIT;\r\n}\r\nEXIT:\r\ndata->valid = 0;\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nint ix = to_sensor_dev_attr(devattr)->index;\r\nif (0 == data->fan[ix])\r\nreturn sprintf(buf, "0");\r\nreturn sprintf(buf, "%d\n", (int)(6000000 / data->fan[ix]));\r\n}\r\nstatic ssize_t get_fan1_fault(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nif (data->stat1 & AMC6821_STAT1_FANS)\r\nreturn sprintf(buf, "1");\r\nelse\r\nreturn sprintf(buf, "0");\r\n}\r\nstatic ssize_t set_fan(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint ix = to_sensor_dev_attr(attr)->index;\r\nint ret = kstrtol(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nval = 1 > val ? 0xFFFF : 6000000/val;\r\nmutex_lock(&data->update_lock);\r\ndata->fan[ix] = (u16) clamp_val(val, 1, 0xFFFF);\r\nif (i2c_smbus_write_byte_data(client, fan_reg_low[ix],\r\ndata->fan[ix] & 0xFF)) {\r\ndev_err(&client->dev, "Register write error, aborting.\n");\r\ncount = -EIO;\r\ngoto EXIT;\r\n}\r\nif (i2c_smbus_write_byte_data(client,\r\nfan_reg_hi[ix], data->fan[ix] >> 8)) {\r\ndev_err(&client->dev, "Register write error, aborting.\n");\r\ncount = -EIO;\r\n}\r\nEXIT:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t get_fan1_div(\r\nstruct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct amc6821_data *data = amc6821_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->fan1_div);\r\n}\r\nstatic ssize_t set_fan1_div(\r\nstruct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nlong val;\r\nint config = kstrtol(buf, 10, &val);\r\nif (config)\r\nreturn config;\r\nconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF4);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Error reading configuration register, aborting.\n");\r\nreturn config;\r\n}\r\nmutex_lock(&data->update_lock);\r\nswitch (val) {\r\ncase 2:\r\nconfig &= ~AMC6821_CONF4_PSPR;\r\ndata->fan1_div = 2;\r\nbreak;\r\ncase 4:\r\nconfig |= AMC6821_CONF4_PSPR;\r\ndata->fan1_div = 4;\r\nbreak;\r\ndefault:\r\ncount = -EINVAL;\r\ngoto EXIT;\r\n}\r\nif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF4, config)) {\r\ndev_err(&client->dev,\r\n"Configuration register write error, aborting.\n");\r\ncount = -EIO;\r\n}\r\nEXIT:\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic int amc6821_detect(\r\nstruct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint address = client->addr;\r\nint dev_id, comp_id;\r\ndev_dbg(&adapter->dev, "amc6821_detect called.\n");\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_dbg(&adapter->dev,\r\n"amc6821: I2C bus doesn't support byte mode, "\r\n"skipping.\n");\r\nreturn -ENODEV;\r\n}\r\ndev_id = i2c_smbus_read_byte_data(client, AMC6821_REG_DEV_ID);\r\ncomp_id = i2c_smbus_read_byte_data(client, AMC6821_REG_COMP_ID);\r\nif (dev_id != 0x21 || comp_id != 0x49) {\r\ndev_dbg(&adapter->dev,\r\n"amc6821: detection failed at 0x%02x.\n",\r\naddress);\r\nreturn -ENODEV;\r\n}\r\ndev_id = i2c_smbus_read_byte_data(client, 0x80 | AMC6821_REG_DEV_ID);\r\ncomp_id = i2c_smbus_read_byte_data(client, 0x80 | AMC6821_REG_COMP_ID);\r\nif (dev_id != 0x21 || comp_id != 0x49) {\r\ndev_dbg(&adapter->dev,\r\n"amc6821: detection failed at 0x%02x.\n",\r\naddress);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&adapter->dev, "amc6821: chip found at 0x%02x.\n", address);\r\nstrlcpy(info->type, "amc6821", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int amc6821_probe(\r\nstruct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct amc6821_data *data;\r\nint err;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct amc6821_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nerr = amc6821_init_client(client);\r\nif (err)\r\nreturn err;\r\nerr = sysfs_create_group(&client->dev.kobj, &amc6821_attr_grp);\r\nif (err)\r\nreturn err;\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (!IS_ERR(data->hwmon_dev))\r\nreturn 0;\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(&client->dev, "error registering hwmon device.\n");\r\nsysfs_remove_group(&client->dev.kobj, &amc6821_attr_grp);\r\nreturn err;\r\n}\r\nstatic int amc6821_remove(struct i2c_client *client)\r\n{\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&client->dev.kobj, &amc6821_attr_grp);\r\nreturn 0;\r\n}\r\nstatic int amc6821_init_client(struct i2c_client *client)\r\n{\r\nint config;\r\nint err = -EIO;\r\nif (init) {\r\nconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF4);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Error reading configuration register, aborting.\n");\r\nreturn err;\r\n}\r\nconfig |= AMC6821_CONF4_MODE;\r\nif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF4,\r\nconfig)) {\r\ndev_err(&client->dev,\r\n"Configuration register write error, aborting.\n");\r\nreturn err;\r\n}\r\nconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF3);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Error reading configuration register, aborting.\n");\r\nreturn err;\r\n}\r\ndev_info(&client->dev, "Revision %d\n", config & 0x0f);\r\nconfig &= ~AMC6821_CONF3_THERM_FAN_EN;\r\nif (i2c_smbus_write_byte_data(client, AMC6821_REG_CONF3,\r\nconfig)) {\r\ndev_err(&client->dev,\r\n"Configuration register write error, aborting.\n");\r\nreturn err;\r\n}\r\nconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF2);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Error reading configuration register, aborting.\n");\r\nreturn err;\r\n}\r\nconfig &= ~AMC6821_CONF2_RTFIE;\r\nconfig &= ~AMC6821_CONF2_LTOIE;\r\nconfig &= ~AMC6821_CONF2_RTOIE;\r\nif (i2c_smbus_write_byte_data(client,\r\nAMC6821_REG_CONF2, config)) {\r\ndev_err(&client->dev,\r\n"Configuration register write error, aborting.\n");\r\nreturn err;\r\n}\r\nconfig = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF1);\r\nif (config < 0) {\r\ndev_err(&client->dev,\r\n"Error reading configuration register, aborting.\n");\r\nreturn err;\r\n}\r\nconfig &= ~AMC6821_CONF1_THERMOVIE;\r\nconfig &= ~AMC6821_CONF1_FANIE;\r\nconfig |= AMC6821_CONF1_START;\r\nif (pwminv)\r\nconfig |= AMC6821_CONF1_PWMINV;\r\nelse\r\nconfig &= ~AMC6821_CONF1_PWMINV;\r\nif (i2c_smbus_write_byte_data(\r\nclient, AMC6821_REG_CONF1, config)) {\r\ndev_err(&client->dev,\r\n"Configuration register write error, aborting.\n");\r\nreturn err;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct amc6821_data *amc6821_update_device(struct device *dev)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct amc6821_data *data = i2c_get_clientdata(client);\r\nint timeout = HZ;\r\nu8 reg;\r\nint i;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + timeout) ||\r\n!data->valid) {\r\nfor (i = 0; i < TEMP_IDX_LEN; i++)\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\ntemp_reg[i]);\r\ndata->stat1 = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_STAT1);\r\ndata->stat2 = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_STAT2);\r\ndata->pwm1 = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_DCY);\r\nfor (i = 0; i < FAN1_IDX_LEN; i++) {\r\ndata->fan[i] = i2c_smbus_read_byte_data(\r\nclient,\r\nfan_reg_low[i]);\r\ndata->fan[i] += i2c_smbus_read_byte_data(\r\nclient,\r\nfan_reg_hi[i]) << 8;\r\n}\r\ndata->fan1_div = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_CONF4);\r\ndata->fan1_div = data->fan1_div & AMC6821_CONF4_PSPR ? 4 : 2;\r\ndata->pwm1_auto_point_pwm[0] = 0;\r\ndata->pwm1_auto_point_pwm[2] = 255;\r\ndata->pwm1_auto_point_pwm[1] = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_DCY_LOW_TEMP);\r\ndata->temp1_auto_point_temp[0] =\r\ni2c_smbus_read_byte_data(client,\r\nAMC6821_REG_PSV_TEMP);\r\ndata->temp2_auto_point_temp[0] =\r\ndata->temp1_auto_point_temp[0];\r\nreg = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_LTEMP_FAN_CTRL);\r\ndata->temp1_auto_point_temp[1] = (reg & 0xF8) >> 1;\r\nreg &= 0x07;\r\nreg = 0x20 >> reg;\r\nif (reg > 0)\r\ndata->temp1_auto_point_temp[2] =\r\ndata->temp1_auto_point_temp[1] +\r\n(data->pwm1_auto_point_pwm[2] -\r\ndata->pwm1_auto_point_pwm[1]) / reg;\r\nelse\r\ndata->temp1_auto_point_temp[2] = 255;\r\nreg = i2c_smbus_read_byte_data(client,\r\nAMC6821_REG_RTEMP_FAN_CTRL);\r\ndata->temp2_auto_point_temp[1] = (reg & 0xF8) >> 1;\r\nreg &= 0x07;\r\nreg = 0x20 >> reg;\r\nif (reg > 0)\r\ndata->temp2_auto_point_temp[2] =\r\ndata->temp2_auto_point_temp[1] +\r\n(data->pwm1_auto_point_pwm[2] -\r\ndata->pwm1_auto_point_pwm[1]) / reg;\r\nelse\r\ndata->temp2_auto_point_temp[2] = 255;\r\nreg = i2c_smbus_read_byte_data(client, AMC6821_REG_CONF1);\r\nreg = (reg >> 5) & 0x3;\r\nswitch (reg) {\r\ncase 0:\r\ndata->pwm1_auto_channels_temp = 0;\r\ndata->pwm1_enable = 1;\r\nbreak;\r\ncase 2:\r\ndata->pwm1_auto_channels_temp = 2;\r\ndata->pwm1_enable = 2;\r\nbreak;\r\ncase 3:\r\ndata->pwm1_auto_channels_temp = 3;\r\ndata->pwm1_enable = 3;\r\nbreak;\r\ncase 1:\r\ndata->pwm1_auto_channels_temp = 0;\r\ndata->pwm1_enable = 0;\r\nbreak;\r\n}\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}
