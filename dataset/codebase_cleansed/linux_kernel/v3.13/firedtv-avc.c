static inline void clear_operands(struct avc_command_frame *c, int from, int to)\r\n{\r\nmemset(&c->operand[from], 0, to - from + 1);\r\n}\r\nstatic void pad_operands(struct avc_command_frame *c, int from)\r\n{\r\nint to = ALIGN(from, 4);\r\nif (from <= to && to <= LAST_OPERAND)\r\nclear_operands(c, from, to);\r\n}\r\nstatic const char *debug_fcp_ctype(unsigned int ctype)\r\n{\r\nstatic const char *ctypes[] = {\r\n[0x0] = "CONTROL", [0x1] = "STATUS",\r\n[0x2] = "SPECIFIC INQUIRY", [0x3] = "NOTIFY",\r\n[0x4] = "GENERAL INQUIRY", [0x8] = "NOT IMPLEMENTED",\r\n[0x9] = "ACCEPTED", [0xa] = "REJECTED",\r\n[0xb] = "IN TRANSITION", [0xc] = "IMPLEMENTED/STABLE",\r\n[0xd] = "CHANGED", [0xf] = "INTERIM",\r\n};\r\nconst char *ret = ctype < ARRAY_SIZE(ctypes) ? ctypes[ctype] : NULL;\r\nreturn ret ? ret : "?";\r\n}\r\nstatic const char *debug_fcp_opcode(unsigned int opcode,\r\nconst u8 *data, int length)\r\n{\r\nswitch (opcode) {\r\ncase AVC_OPCODE_VENDOR:\r\nbreak;\r\ncase AVC_OPCODE_READ_DESCRIPTOR:\r\nreturn avc_debug & AVC_DEBUG_READ_DESCRIPTOR ?\r\n"ReadDescriptor" : NULL;\r\ncase AVC_OPCODE_DSIT:\r\nreturn avc_debug & AVC_DEBUG_DSIT ?\r\n"DirectSelectInfo.Type" : NULL;\r\ncase AVC_OPCODE_DSD:\r\nreturn avc_debug & AVC_DEBUG_DSD ? "DirectSelectData" : NULL;\r\ndefault:\r\nreturn "Unknown";\r\n}\r\nif (length < 7 ||\r\ndata[3] != SFE_VENDOR_DE_COMPANYID_0 ||\r\ndata[4] != SFE_VENDOR_DE_COMPANYID_1 ||\r\ndata[5] != SFE_VENDOR_DE_COMPANYID_2)\r\nreturn "Vendor/Unknown";\r\nswitch (data[6]) {\r\ncase SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL:\r\nreturn avc_debug & AVC_DEBUG_REGISTER_REMOTE_CONTROL ?\r\n"RegisterRC" : NULL;\r\ncase SFE_VENDOR_OPCODE_LNB_CONTROL:\r\nreturn avc_debug & AVC_DEBUG_LNB_CONTROL ? "LNBControl" : NULL;\r\ncase SFE_VENDOR_OPCODE_TUNE_QPSK:\r\nreturn avc_debug & AVC_DEBUG_TUNE_QPSK ? "TuneQPSK" : NULL;\r\ncase SFE_VENDOR_OPCODE_TUNE_QPSK2:\r\nreturn avc_debug & AVC_DEBUG_TUNE_QPSK2 ? "TuneQPSK2" : NULL;\r\ncase SFE_VENDOR_OPCODE_HOST2CA:\r\nreturn avc_debug & AVC_DEBUG_HOST2CA ? "Host2CA" : NULL;\r\ncase SFE_VENDOR_OPCODE_CA2HOST:\r\nreturn avc_debug & AVC_DEBUG_CA2HOST ? "CA2Host" : NULL;\r\n}\r\nreturn "Vendor/Unknown";\r\n}\r\nstatic void debug_fcp(const u8 *data, int length)\r\n{\r\nunsigned int subunit_type, subunit_id, opcode;\r\nconst char *op, *prefix;\r\nprefix = data[0] > 7 ? "FCP <- " : "FCP -> ";\r\nsubunit_type = data[1] >> 3;\r\nsubunit_id = data[1] & 7;\r\nopcode = subunit_type == 0x1e || subunit_id == 5 ? ~0 : data[2];\r\nop = debug_fcp_opcode(opcode, data, length);\r\nif (op) {\r\nprintk(KERN_INFO "%ssu=%x.%x l=%d: %-8s - %s\n",\r\nprefix, subunit_type, subunit_id, length,\r\ndebug_fcp_ctype(data[0]), op);\r\nif (avc_debug & AVC_DEBUG_FCP_PAYLOADS)\r\nprint_hex_dump(KERN_INFO, prefix, DUMP_PREFIX_NONE,\r\n16, 1, data, length, false);\r\n}\r\n}\r\nstatic void debug_pmt(char *msg, int length)\r\n{\r\nprintk(KERN_INFO "APP PMT -> l=%d\n", length);\r\nprint_hex_dump(KERN_INFO, "APP PMT -> ", DUMP_PREFIX_NONE,\r\n16, 1, msg, length, false);\r\n}\r\nstatic int avc_write(struct firedtv *fdtv)\r\n{\r\nint err, retry;\r\nfdtv->avc_reply_received = false;\r\nfor (retry = 0; retry < 6; retry++) {\r\nif (unlikely(avc_debug))\r\ndebug_fcp(fdtv->avc_data, fdtv->avc_data_length);\r\nerr = fdtv_write(fdtv, FCP_COMMAND_REGISTER,\r\nfdtv->avc_data, fdtv->avc_data_length);\r\nif (err) {\r\ndev_err(fdtv->device, "FCP command write failed\n");\r\nreturn err;\r\n}\r\nif (wait_event_timeout(fdtv->avc_wait,\r\nfdtv->avc_reply_received,\r\nmsecs_to_jiffies(200)) != 0)\r\nreturn 0;\r\n}\r\ndev_err(fdtv->device, "FCP response timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic bool is_register_rc(struct avc_response_frame *r)\r\n{\r\nreturn r->opcode == AVC_OPCODE_VENDOR &&\r\nr->operand[0] == SFE_VENDOR_DE_COMPANYID_0 &&\r\nr->operand[1] == SFE_VENDOR_DE_COMPANYID_1 &&\r\nr->operand[2] == SFE_VENDOR_DE_COMPANYID_2 &&\r\nr->operand[3] == SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL;\r\n}\r\nint avc_recv(struct firedtv *fdtv, void *data, size_t length)\r\n{\r\nstruct avc_response_frame *r = data;\r\nif (unlikely(avc_debug))\r\ndebug_fcp(data, length);\r\nif (length >= 8 && is_register_rc(r)) {\r\nswitch (r->response) {\r\ncase AVC_RESPONSE_CHANGED:\r\nfdtv_handle_rc(fdtv, r->operand[4] << 8 | r->operand[5]);\r\nschedule_work(&fdtv->remote_ctrl_work);\r\nbreak;\r\ncase AVC_RESPONSE_INTERIM:\r\nif (is_register_rc((void *)fdtv->avc_data))\r\ngoto wake;\r\nbreak;\r\ndefault:\r\ndev_info(fdtv->device,\r\n"remote control result = %d\n", r->response);\r\n}\r\nreturn 0;\r\n}\r\nif (fdtv->avc_reply_received) {\r\ndev_err(fdtv->device, "out-of-order AVC response, ignored\n");\r\nreturn -EIO;\r\n}\r\nmemcpy(fdtv->avc_data, data, length);\r\nfdtv->avc_data_length = length;\r\nwake:\r\nfdtv->avc_reply_received = true;\r\nwake_up(&fdtv->avc_wait);\r\nreturn 0;\r\n}\r\nstatic int add_pid_filter(struct firedtv *fdtv, u8 *operand)\r\n{\r\nint i, n, pos = 1;\r\nfor (i = 0, n = 0; i < 16; i++) {\r\nif (test_bit(i, &fdtv->channel_active)) {\r\noperand[pos++] = 0x13;\r\noperand[pos++] = 0x80;\r\noperand[pos++] = (fdtv->channel_pid[i] >> 8) & 0x1f;\r\noperand[pos++] = fdtv->channel_pid[i] & 0xff;\r\noperand[pos++] = 0x00;\r\noperand[pos++] = 0x00;\r\nn++;\r\n}\r\n}\r\noperand[0] = n;\r\nreturn pos;\r\n}\r\nstatic int avc_tuner_tuneqpsk(struct firedtv *fdtv,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nif (fdtv->type == FIREDTV_DVB_S2)\r\nc->operand[3] = SFE_VENDOR_OPCODE_TUNE_QPSK2;\r\nelse\r\nc->operand[3] = SFE_VENDOR_OPCODE_TUNE_QPSK;\r\nc->operand[4] = (p->frequency >> 24) & 0xff;\r\nc->operand[5] = (p->frequency >> 16) & 0xff;\r\nc->operand[6] = (p->frequency >> 8) & 0xff;\r\nc->operand[7] = p->frequency & 0xff;\r\nc->operand[8] = ((p->symbol_rate / 1000) >> 8) & 0xff;\r\nc->operand[9] = (p->symbol_rate / 1000) & 0xff;\r\nswitch (p->fec_inner) {\r\ncase FEC_1_2: c->operand[10] = 0x1; break;\r\ncase FEC_2_3: c->operand[10] = 0x2; break;\r\ncase FEC_3_4: c->operand[10] = 0x3; break;\r\ncase FEC_5_6: c->operand[10] = 0x4; break;\r\ncase FEC_7_8: c->operand[10] = 0x5; break;\r\ncase FEC_4_5:\r\ncase FEC_8_9:\r\ncase FEC_AUTO:\r\ndefault: c->operand[10] = 0x0;\r\n}\r\nif (fdtv->voltage == 0xff)\r\nc->operand[11] = 0xff;\r\nelse if (fdtv->voltage == SEC_VOLTAGE_18)\r\nc->operand[11] = 0;\r\nelse\r\nc->operand[11] = 1;\r\nif (fdtv->tone == 0xff)\r\nc->operand[12] = 0xff;\r\nelse if (fdtv->tone == SEC_TONE_ON)\r\nc->operand[12] = 1;\r\nelse\r\nc->operand[12] = 0;\r\nif (fdtv->type == FIREDTV_DVB_S2) {\r\nif (fdtv->fe.dtv_property_cache.delivery_system == SYS_DVBS2) {\r\nswitch (fdtv->fe.dtv_property_cache.modulation) {\r\ncase QAM_16: c->operand[13] = 0x1; break;\r\ncase QPSK: c->operand[13] = 0x2; break;\r\ncase PSK_8: c->operand[13] = 0x3; break;\r\ndefault: c->operand[13] = 0x2; break;\r\n}\r\nswitch (fdtv->fe.dtv_property_cache.rolloff) {\r\ncase ROLLOFF_35: c->operand[14] = 0x2; break;\r\ncase ROLLOFF_20: c->operand[14] = 0x0; break;\r\ncase ROLLOFF_25: c->operand[14] = 0x1; break;\r\ncase ROLLOFF_AUTO:\r\ndefault: c->operand[14] = 0x2; break;\r\n}\r\nswitch (fdtv->fe.dtv_property_cache.pilot) {\r\ncase PILOT_AUTO: c->operand[15] = 0x0; break;\r\ncase PILOT_OFF: c->operand[15] = 0x0; break;\r\ncase PILOT_ON: c->operand[15] = 0x1; break;\r\n}\r\n} else {\r\nc->operand[13] = 0x1;\r\nc->operand[14] = 0xff;\r\nc->operand[15] = 0xff;\r\n}\r\nreturn 16;\r\n} else {\r\nreturn 13;\r\n}\r\n}\r\nstatic int avc_tuner_dsd_dvb_c(struct firedtv *fdtv,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nc->opcode = AVC_OPCODE_DSD;\r\nc->operand[0] = 0;\r\nc->operand[1] = 0xd2;\r\nc->operand[2] = 0x20;\r\nc->operand[3] = 0x00;\r\nc->operand[4] = 0x11;\r\nc->operand[5] = 0 << 7\r\n| 0 << 6\r\n| 0 << 5\r\n| 1 << 4\r\n| 1 << 3\r\n| 0 << 2\r\n| (p->fec_inner != FEC_AUTO ? 1 << 1 : 0)\r\n| (p->modulation != QAM_AUTO ? 1 << 0 : 0);\r\nc->operand[6] = 0 << 7\r\n| 0 << 0 ;\r\nc->operand[7] = 0x00;\r\nc->operand[8] = 0x00;\r\nc->operand[9] = 0x00;\r\nc->operand[10] = 0x00;\r\nc->operand[11] = (((p->frequency / 4000) >> 16) & 0xff) | (2 << 6);\r\nc->operand[12] = ((p->frequency / 4000) >> 8) & 0xff;\r\nc->operand[13] = (p->frequency / 4000) & 0xff;\r\nc->operand[14] = ((p->symbol_rate / 1000) >> 12) & 0xff;\r\nc->operand[15] = ((p->symbol_rate / 1000) >> 4) & 0xff;\r\nc->operand[16] = ((p->symbol_rate / 1000) << 4) & 0xf0;\r\nc->operand[17] = 0x00;\r\nswitch (p->fec_inner) {\r\ncase FEC_1_2: c->operand[18] = 0x1; break;\r\ncase FEC_2_3: c->operand[18] = 0x2; break;\r\ncase FEC_3_4: c->operand[18] = 0x3; break;\r\ncase FEC_5_6: c->operand[18] = 0x4; break;\r\ncase FEC_7_8: c->operand[18] = 0x5; break;\r\ncase FEC_8_9: c->operand[18] = 0x6; break;\r\ncase FEC_4_5: c->operand[18] = 0x8; break;\r\ncase FEC_AUTO:\r\ndefault: c->operand[18] = 0x0;\r\n}\r\nswitch (p->modulation) {\r\ncase QAM_16: c->operand[19] = 0x08; break;\r\ncase QAM_32: c->operand[19] = 0x10; break;\r\ncase QAM_64: c->operand[19] = 0x18; break;\r\ncase QAM_128: c->operand[19] = 0x20; break;\r\ncase QAM_256: c->operand[19] = 0x28; break;\r\ncase QAM_AUTO:\r\ndefault: c->operand[19] = 0x00;\r\n}\r\nc->operand[20] = 0x00;\r\nc->operand[21] = 0x00;\r\nreturn 22 + add_pid_filter(fdtv, &c->operand[22]);\r\n}\r\nstatic int avc_tuner_dsd_dvb_t(struct firedtv *fdtv,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nc->opcode = AVC_OPCODE_DSD;\r\nc->operand[0] = 0;\r\nc->operand[1] = 0xd2;\r\nc->operand[2] = 0x20;\r\nc->operand[3] = 0x00;\r\nc->operand[4] = 0x0c;\r\nc->operand[5] =\r\n0 << 7\r\n| 1 << 6\r\n| (p->bandwidth_hz != 0 ? 1 << 5 : 0)\r\n| (p->modulation != QAM_AUTO ? 1 << 4 : 0)\r\n| (p->hierarchy != HIERARCHY_AUTO ? 1 << 3 : 0)\r\n| (p->code_rate_HP != FEC_AUTO ? 1 << 2 : 0)\r\n| (p->code_rate_LP != FEC_AUTO ? 1 << 1 : 0)\r\n| (p->guard_interval != GUARD_INTERVAL_AUTO ? 1 << 0 : 0);\r\nc->operand[6] =\r\n0 << 7\r\n| (p->transmission_mode != TRANSMISSION_MODE_AUTO ? 1 << 6 : 0)\r\n| 0 << 5\r\n| 0 << 0 ;\r\nc->operand[7] = 0x0;\r\nc->operand[8] = (p->frequency / 10) >> 24;\r\nc->operand[9] = ((p->frequency / 10) >> 16) & 0xff;\r\nc->operand[10] = ((p->frequency / 10) >> 8) & 0xff;\r\nc->operand[11] = (p->frequency / 10) & 0xff;\r\nswitch (p->bandwidth_hz) {\r\ncase 7000000: c->operand[12] = 0x20; break;\r\ncase 8000000:\r\ncase 6000000:\r\ncase 0:\r\ndefault: c->operand[12] = 0x00;\r\n}\r\nswitch (p->modulation) {\r\ncase QAM_16: c->operand[13] = 1 << 6; break;\r\ncase QAM_64: c->operand[13] = 2 << 6; break;\r\ncase QPSK:\r\ndefault: c->operand[13] = 0x00;\r\n}\r\nswitch (p->hierarchy) {\r\ncase HIERARCHY_1: c->operand[13] |= 1 << 3; break;\r\ncase HIERARCHY_2: c->operand[13] |= 2 << 3; break;\r\ncase HIERARCHY_4: c->operand[13] |= 3 << 3; break;\r\ncase HIERARCHY_AUTO:\r\ncase HIERARCHY_NONE:\r\ndefault: break;\r\n}\r\nswitch (p->code_rate_HP) {\r\ncase FEC_2_3: c->operand[13] |= 1; break;\r\ncase FEC_3_4: c->operand[13] |= 2; break;\r\ncase FEC_5_6: c->operand[13] |= 3; break;\r\ncase FEC_7_8: c->operand[13] |= 4; break;\r\ncase FEC_1_2:\r\ndefault: break;\r\n}\r\nswitch (p->code_rate_LP) {\r\ncase FEC_2_3: c->operand[14] = 1 << 5; break;\r\ncase FEC_3_4: c->operand[14] = 2 << 5; break;\r\ncase FEC_5_6: c->operand[14] = 3 << 5; break;\r\ncase FEC_7_8: c->operand[14] = 4 << 5; break;\r\ncase FEC_1_2:\r\ndefault: c->operand[14] = 0x00; break;\r\n}\r\nswitch (p->guard_interval) {\r\ncase GUARD_INTERVAL_1_16: c->operand[14] |= 1 << 3; break;\r\ncase GUARD_INTERVAL_1_8: c->operand[14] |= 2 << 3; break;\r\ncase GUARD_INTERVAL_1_4: c->operand[14] |= 3 << 3; break;\r\ncase GUARD_INTERVAL_1_32:\r\ncase GUARD_INTERVAL_AUTO:\r\ndefault: break;\r\n}\r\nswitch (p->transmission_mode) {\r\ncase TRANSMISSION_MODE_8K: c->operand[14] |= 1 << 1; break;\r\ncase TRANSMISSION_MODE_2K:\r\ncase TRANSMISSION_MODE_AUTO:\r\ndefault: break;\r\n}\r\nc->operand[15] = 0x00;\r\nc->operand[16] = 0x00;\r\nreturn 17 + add_pid_filter(fdtv, &c->operand[17]);\r\n}\r\nint avc_tuner_dsd(struct firedtv *fdtv,\r\nstruct dtv_frontend_properties *p)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nint pos, ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nswitch (fdtv->type) {\r\ncase FIREDTV_DVB_S:\r\ncase FIREDTV_DVB_S2: pos = avc_tuner_tuneqpsk(fdtv, p); break;\r\ncase FIREDTV_DVB_C: pos = avc_tuner_dsd_dvb_c(fdtv, p); break;\r\ncase FIREDTV_DVB_T: pos = avc_tuner_dsd_dvb_t(fdtv, p); break;\r\ndefault:\r\nBUG();\r\n}\r\npad_operands(c, pos);\r\nfdtv->avc_data_length = ALIGN(3 + pos, 4);\r\nret = avc_write(fdtv);\r\n#if 0\r\nif (status)\r\n*status = r->operand[2];\r\n#endif\r\nmutex_unlock(&fdtv->avc_mutex);\r\nif (ret == 0)\r\nmsleep(500);\r\nreturn ret;\r\n}\r\nint avc_tuner_set_pids(struct firedtv *fdtv, unsigned char pidc, u16 pid[])\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nint ret, pos, k;\r\nif (pidc > 16 && pidc != 0xff)\r\nreturn -EINVAL;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_DSD;\r\nc->operand[0] = 0;\r\nc->operand[1] = 0xd2;\r\nc->operand[2] = 0x20;\r\nc->operand[3] = 0x00;\r\nc->operand[4] = 0x00;\r\nc->operand[5] = pidc;\r\npos = 6;\r\nif (pidc != 0xff)\r\nfor (k = 0; k < pidc; k++) {\r\nc->operand[pos++] = 0x13;\r\nc->operand[pos++] = 0x80;\r\nc->operand[pos++] = (pid[k] >> 8) & 0x1f;\r\nc->operand[pos++] = pid[k] & 0xff;\r\nc->operand[pos++] = 0x00;\r\nc->operand[pos++] = 0x00;\r\n}\r\npad_operands(c, pos);\r\nfdtv->avc_data_length = ALIGN(3 + pos, 4);\r\nret = avc_write(fdtv);\r\nmutex_unlock(&fdtv->avc_mutex);\r\nif (ret == 0)\r\nmsleep(50);\r\nreturn ret;\r\n}\r\nint avc_tuner_get_ts(struct firedtv *fdtv)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nint ret, sl;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_DSIT;\r\nsl = fdtv->type == FIREDTV_DVB_T ? 0x0c : 0x11;\r\nc->operand[0] = 0;\r\nc->operand[1] = 0xd2;\r\nc->operand[2] = 0xff;\r\nc->operand[3] = 0x20;\r\nc->operand[4] = 0x00;\r\nc->operand[5] = 0x0;\r\nc->operand[6] = sl;\r\nclear_operands(c, 7, 24);\r\nfdtv->avc_data_length = fdtv->type == FIREDTV_DVB_T ? 24 : 28;\r\nret = avc_write(fdtv);\r\nmutex_unlock(&fdtv->avc_mutex);\r\nif (ret == 0)\r\nmsleep(250);\r\nreturn ret;\r\n}\r\nint avc_identify_subunit(struct firedtv *fdtv)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_READ_DESCRIPTOR;\r\nc->operand[0] = DESCRIPTOR_SUBUNIT_IDENTIFIER;\r\nc->operand[1] = 0xff;\r\nc->operand[2] = 0x00;\r\nc->operand[3] = 0x00;\r\nc->operand[4] = 0x08;\r\nc->operand[5] = 0x00;\r\nc->operand[6] = 0x0d;\r\nclear_operands(c, 7, 8);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\nif ((r->response != AVC_RESPONSE_STABLE &&\r\nr->response != AVC_RESPONSE_ACCEPTED) ||\r\n(r->operand[3] << 8) + r->operand[4] != 8) {\r\ndev_err(fdtv->device, "cannot read subunit identifier\n");\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_tuner_status(struct firedtv *fdtv, struct firedtv_tuner_status *stat)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint length, ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_READ_DESCRIPTOR;\r\nc->operand[0] = DESCRIPTOR_TUNER_STATUS;\r\nc->operand[1] = 0xff;\r\nclear_operands(c, 2, 31);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\nif (r->response != AVC_RESPONSE_STABLE &&\r\nr->response != AVC_RESPONSE_ACCEPTED) {\r\ndev_err(fdtv->device, "cannot read tuner status\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nlength = r->operand[9];\r\nif (r->operand[1] != 0x10 || length != SIZEOF_ANTENNA_INPUT_INFO) {\r\ndev_err(fdtv->device, "got invalid tuner status\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nstat->active_system = r->operand[10];\r\nstat->searching = r->operand[11] >> 7 & 1;\r\nstat->moving = r->operand[11] >> 6 & 1;\r\nstat->no_rf = r->operand[11] >> 5 & 1;\r\nstat->input = r->operand[12] >> 7 & 1;\r\nstat->selected_antenna = r->operand[12] & 0x7f;\r\nstat->ber = r->operand[13] << 24 |\r\nr->operand[14] << 16 |\r\nr->operand[15] << 8 |\r\nr->operand[16];\r\nstat->signal_strength = r->operand[17];\r\nstat->raster_frequency = r->operand[18] >> 6 & 2;\r\nstat->rf_frequency = (r->operand[18] & 0x3f) << 16 |\r\nr->operand[19] << 8 |\r\nr->operand[20];\r\nstat->man_dep_info_length = r->operand[21];\r\nstat->front_end_error = r->operand[22] >> 4 & 1;\r\nstat->antenna_error = r->operand[22] >> 3 & 1;\r\nstat->front_end_power_status = r->operand[22] >> 1 & 1;\r\nstat->power_supply = r->operand[22] & 1;\r\nstat->carrier_noise_ratio = r->operand[23] << 8 |\r\nr->operand[24];\r\nstat->power_supply_voltage = r->operand[27];\r\nstat->antenna_voltage = r->operand[28];\r\nstat->firewire_bus_voltage = r->operand[29];\r\nstat->ca_mmi = r->operand[30] & 1;\r\nstat->ca_pmt_reply = r->operand[31] >> 7 & 1;\r\nstat->ca_date_time_request = r->operand[31] >> 6 & 1;\r\nstat->ca_application_info = r->operand[31] >> 5 & 1;\r\nstat->ca_module_present_status = r->operand[31] >> 4 & 1;\r\nstat->ca_dvb_flag = r->operand[31] >> 3 & 1;\r\nstat->ca_error_flag = r->operand[31] >> 2 & 1;\r\nstat->ca_initialization_status = r->operand[31] >> 1 & 1;\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_lnb_control(struct firedtv *fdtv, char voltage, char burst,\r\nchar conttone, char nrdiseq,\r\nstruct dvb_diseqc_master_cmd *diseqcmd)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint pos, j, k, ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_LNB_CONTROL;\r\nc->operand[4] = voltage;\r\nc->operand[5] = nrdiseq;\r\npos = 6;\r\nfor (j = 0; j < nrdiseq; j++) {\r\nc->operand[pos++] = diseqcmd[j].msg_len;\r\nfor (k = 0; k < diseqcmd[j].msg_len; k++)\r\nc->operand[pos++] = diseqcmd[j].msg[k];\r\n}\r\nc->operand[pos++] = burst;\r\nc->operand[pos++] = conttone;\r\npad_operands(c, pos);\r\nfdtv->avc_data_length = ALIGN(3 + pos, 4);\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\nif (r->response != AVC_RESPONSE_ACCEPTED) {\r\ndev_err(fdtv->device, "LNB control failed\n");\r\nret = -EINVAL;\r\n}\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_register_remote_control(struct firedtv *fdtv)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nint ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_NOTIFY;\r\nc->subunit = AVC_SUBUNIT_TYPE_UNIT | 7;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_REGISTER_REMOTE_CONTROL;\r\nc->operand[4] = 0;\r\nfdtv->avc_data_length = 8;\r\nret = avc_write(fdtv);\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nvoid avc_remote_ctrl_work(struct work_struct *work)\r\n{\r\nstruct firedtv *fdtv =\r\ncontainer_of(work, struct firedtv, remote_ctrl_work);\r\navc_register_remote_control(fdtv);\r\n}\r\nstatic int get_ca_object_pos(struct avc_response_frame *r)\r\n{\r\nint length = 1;\r\nif (r->operand[7] & 0x80)\r\nlength = (r->operand[7] & 0x7f) + 1;\r\nreturn length + 7;\r\n}\r\nstatic int get_ca_object_length(struct avc_response_frame *r)\r\n{\r\n#if 0\r\nint size = 0;\r\nint i;\r\nif (r->operand[7] & 0x80)\r\nfor (i = 0; i < (r->operand[7] & 0x7f); i++) {\r\nsize <<= 8;\r\nsize += r->operand[8 + i];\r\n}\r\n#endif\r\nreturn r->operand[7];\r\n}\r\nint avc_ca_app_info(struct firedtv *fdtv, char *app_info, unsigned int *len)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint pos, ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_STATUS;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_APPLICATION_INFO;\r\nclear_operands(c, 6, LAST_OPERAND);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\npos = get_ca_object_pos(r);\r\napp_info[0] = (EN50221_TAG_APP_INFO >> 16) & 0xff;\r\napp_info[1] = (EN50221_TAG_APP_INFO >> 8) & 0xff;\r\napp_info[2] = (EN50221_TAG_APP_INFO >> 0) & 0xff;\r\napp_info[3] = 6 + r->operand[pos + 4];\r\napp_info[4] = 0x01;\r\nmemcpy(&app_info[5], &r->operand[pos], 5 + r->operand[pos + 4]);\r\n*len = app_info[3] + 4;\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_ca_info(struct firedtv *fdtv, char *app_info, unsigned int *len)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint i, pos, ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_STATUS;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_APPLICATION_INFO;\r\nclear_operands(c, 6, LAST_OPERAND);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\npos = get_ca_object_pos(r);\r\napp_info[0] = (EN50221_TAG_CA_INFO >> 16) & 0xff;\r\napp_info[1] = (EN50221_TAG_CA_INFO >> 8) & 0xff;\r\napp_info[2] = (EN50221_TAG_CA_INFO >> 0) & 0xff;\r\nif (num_fake_ca_system_ids == 0) {\r\napp_info[3] = 2;\r\napp_info[4] = r->operand[pos + 0];\r\napp_info[5] = r->operand[pos + 1];\r\n} else {\r\napp_info[3] = num_fake_ca_system_ids * 2;\r\nfor (i = 0; i < num_fake_ca_system_ids; i++) {\r\napp_info[4 + i * 2] =\r\n(fake_ca_system_ids[i] >> 8) & 0xff;\r\napp_info[5 + i * 2] = fake_ca_system_ids[i] & 0xff;\r\n}\r\n}\r\n*len = app_info[3] + 4;\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_ca_reset(struct firedtv *fdtv)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nint ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_RESET;\r\nc->operand[6] = 0;\r\nc->operand[7] = 1;\r\nc->operand[8] = 0;\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_ca_pmt(struct firedtv *fdtv, char *msg, int length)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint list_management;\r\nint program_info_length;\r\nint pmt_cmd_id;\r\nint read_pos;\r\nint write_pos;\r\nint es_info_length;\r\nint crc32_csum;\r\nint ret;\r\nif (unlikely(avc_debug & AVC_DEBUG_APPLICATION_PMT))\r\ndebug_pmt(msg, length);\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_CONTROL;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nif (msg[0] != EN50221_LIST_MANAGEMENT_ONLY) {\r\ndev_info(fdtv->device, "forcing list_management to ONLY\n");\r\nmsg[0] = EN50221_LIST_MANAGEMENT_ONLY;\r\n}\r\nlist_management = msg[0];\r\nprogram_info_length = ((msg[4] & 0x0f) << 8) + msg[5];\r\nif (program_info_length > 0)\r\nprogram_info_length--;\r\npmt_cmd_id = msg[6];\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_PMT;\r\nc->operand[6] = 0;\r\nc->operand[10] = list_management;\r\nc->operand[11] = 0x01;\r\nc->operand[12] = 0x02;\r\nc->operand[13] = 0x80;\r\nc->operand[15] = msg[1];\r\nc->operand[16] = msg[2];\r\nc->operand[17] = msg[3];\r\nc->operand[18] = 0x00;\r\nc->operand[19] = 0x00;\r\nc->operand[20] = 0x1f;\r\nc->operand[21] = 0xff;\r\nc->operand[22] = (program_info_length >> 8);\r\nc->operand[23] = (program_info_length & 0xff);\r\nread_pos = 6;\r\nwrite_pos = 24;\r\nif (program_info_length > 0) {\r\npmt_cmd_id = msg[read_pos++];\r\nif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\r\ndev_err(fdtv->device,\r\n"invalid pmt_cmd_id %d\n", pmt_cmd_id);\r\nmemcpy(&c->operand[write_pos], &msg[read_pos],\r\nprogram_info_length);\r\nread_pos += program_info_length;\r\nwrite_pos += program_info_length;\r\n}\r\nwhile (read_pos < length) {\r\nc->operand[write_pos++] = msg[read_pos++];\r\nc->operand[write_pos++] = msg[read_pos++];\r\nc->operand[write_pos++] = msg[read_pos++];\r\nes_info_length =\r\n((msg[read_pos] & 0x0f) << 8) + msg[read_pos + 1];\r\nread_pos += 2;\r\nif (es_info_length > 0)\r\nes_info_length--;\r\nc->operand[write_pos++] = es_info_length >> 8;\r\nc->operand[write_pos++] = es_info_length & 0xff;\r\nif (es_info_length > 0) {\r\npmt_cmd_id = msg[read_pos++];\r\nif (pmt_cmd_id != 1 && pmt_cmd_id != 4)\r\ndev_err(fdtv->device, "invalid pmt_cmd_id %d "\r\n"at stream level\n", pmt_cmd_id);\r\nmemcpy(&c->operand[write_pos], &msg[read_pos],\r\nes_info_length);\r\nread_pos += es_info_length;\r\nwrite_pos += es_info_length;\r\n}\r\n}\r\nwrite_pos += 4;\r\nc->operand[7] = 0x82;\r\nc->operand[8] = (write_pos - 10) >> 8;\r\nc->operand[9] = (write_pos - 10) & 0xff;\r\nc->operand[14] = write_pos - 15;\r\ncrc32_csum = crc32_be(0, &c->operand[10], c->operand[12] - 1);\r\nc->operand[write_pos - 4] = (crc32_csum >> 24) & 0xff;\r\nc->operand[write_pos - 3] = (crc32_csum >> 16) & 0xff;\r\nc->operand[write_pos - 2] = (crc32_csum >> 8) & 0xff;\r\nc->operand[write_pos - 1] = (crc32_csum >> 0) & 0xff;\r\npad_operands(c, write_pos);\r\nfdtv->avc_data_length = ALIGN(3 + write_pos, 4);\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\nif (r->response != AVC_RESPONSE_ACCEPTED) {\r\ndev_err(fdtv->device,\r\n"CA PMT failed with response 0x%x\n", r->response);\r\nret = -EACCES;\r\n}\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_ca_get_time_date(struct firedtv *fdtv, int *interval)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_STATUS;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_DATE_TIME;\r\nclear_operands(c, 6, LAST_OPERAND);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\n*interval = r->operand[get_ca_object_pos(r)];\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_ca_enter_menu(struct firedtv *fdtv)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nint ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_STATUS;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_HOST2CA;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_ENTER_MENU;\r\nclear_operands(c, 6, 8);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nint avc_ca_get_mmi(struct firedtv *fdtv, char *mmi_object, unsigned int *len)\r\n{\r\nstruct avc_command_frame *c = (void *)fdtv->avc_data;\r\nstruct avc_response_frame *r = (void *)fdtv->avc_data;\r\nint ret;\r\nmutex_lock(&fdtv->avc_mutex);\r\nc->ctype = AVC_CTYPE_STATUS;\r\nc->subunit = AVC_SUBUNIT_TYPE_TUNER | fdtv->subunit;\r\nc->opcode = AVC_OPCODE_VENDOR;\r\nc->operand[0] = SFE_VENDOR_DE_COMPANYID_0;\r\nc->operand[1] = SFE_VENDOR_DE_COMPANYID_1;\r\nc->operand[2] = SFE_VENDOR_DE_COMPANYID_2;\r\nc->operand[3] = SFE_VENDOR_OPCODE_CA2HOST;\r\nc->operand[4] = 0;\r\nc->operand[5] = SFE_VENDOR_TAG_CA_MMI;\r\nclear_operands(c, 6, LAST_OPERAND);\r\nfdtv->avc_data_length = 12;\r\nret = avc_write(fdtv);\r\nif (ret < 0)\r\ngoto out;\r\n*len = get_ca_object_length(r);\r\nmemcpy(mmi_object, &r->operand[get_ca_object_pos(r)], *len);\r\nout:\r\nmutex_unlock(&fdtv->avc_mutex);\r\nreturn ret;\r\n}\r\nstatic int cmp_read(struct firedtv *fdtv, u64 addr, __be32 *data)\r\n{\r\nint ret;\r\nret = fdtv_read(fdtv, addr, data);\r\nif (ret < 0)\r\ndev_err(fdtv->device, "CMP: read I/O error\n");\r\nreturn ret;\r\n}\r\nstatic int cmp_lock(struct firedtv *fdtv, u64 addr, __be32 data[])\r\n{\r\nint ret;\r\nret = fdtv_lock(fdtv, addr, data);\r\nif (ret < 0)\r\ndev_err(fdtv->device, "CMP: lock I/O error\n");\r\nreturn ret;\r\n}\r\nstatic inline u32 get_opcr(__be32 opcr, u32 mask, u32 shift)\r\n{\r\nreturn (be32_to_cpu(opcr) >> shift) & mask;\r\n}\r\nstatic inline void set_opcr(__be32 *opcr, u32 value, u32 mask, u32 shift)\r\n{\r\n*opcr &= ~cpu_to_be32(mask << shift);\r\n*opcr |= cpu_to_be32((value & mask) << shift);\r\n}\r\nint cmp_establish_pp_connection(struct firedtv *fdtv, int plug, int channel)\r\n{\r\n__be32 old_opcr, opcr[2];\r\nu64 opcr_address = CMP_OUTPUT_PLUG_CONTROL_REG_0 + (plug << 2);\r\nint attempts = 0;\r\nint ret;\r\nret = cmp_read(fdtv, opcr_address, opcr);\r\nif (ret < 0)\r\nreturn ret;\r\nrepeat:\r\nif (!get_opcr_online(*opcr)) {\r\ndev_err(fdtv->device, "CMP: output offline\n");\r\nreturn -EBUSY;\r\n}\r\nold_opcr = *opcr;\r\nif (get_opcr_p2p_connections(*opcr)) {\r\nif (get_opcr_channel(*opcr) != channel) {\r\ndev_err(fdtv->device, "CMP: cannot change channel\n");\r\nreturn -EBUSY;\r\n}\r\ndev_info(fdtv->device, "CMP: overlaying connection\n");\r\n} else {\r\nset_opcr_channel(opcr, channel);\r\nset_opcr_data_rate(opcr, 2);\r\nset_opcr_overhead_id(opcr, 0);\r\n}\r\nset_opcr_p2p_connections(opcr, get_opcr_p2p_connections(*opcr) + 1);\r\nopcr[1] = *opcr;\r\nopcr[0] = old_opcr;\r\nret = cmp_lock(fdtv, opcr_address, opcr);\r\nif (ret < 0)\r\nreturn ret;\r\nif (old_opcr != *opcr) {\r\nif (++attempts < 6)\r\ngoto repeat;\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nvoid cmp_break_pp_connection(struct firedtv *fdtv, int plug, int channel)\r\n{\r\n__be32 old_opcr, opcr[2];\r\nu64 opcr_address = CMP_OUTPUT_PLUG_CONTROL_REG_0 + (plug << 2);\r\nint attempts = 0;\r\nif (cmp_read(fdtv, opcr_address, opcr) < 0)\r\nreturn;\r\nrepeat:\r\nif (!get_opcr_online(*opcr) || !get_opcr_p2p_connections(*opcr) ||\r\nget_opcr_channel(*opcr) != channel) {\r\ndev_err(fdtv->device, "CMP: no connection to break\n");\r\nreturn;\r\n}\r\nold_opcr = *opcr;\r\nset_opcr_p2p_connections(opcr, get_opcr_p2p_connections(*opcr) - 1);\r\nopcr[1] = *opcr;\r\nopcr[0] = old_opcr;\r\nif (cmp_lock(fdtv, opcr_address, opcr) < 0)\r\nreturn;\r\nif (old_opcr != *opcr) {\r\nif (++attempts < 6)\r\ngoto repeat;\r\n}\r\n}
