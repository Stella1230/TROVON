static void sym_printl_hex(u_char *p, int n)\r\n{\r\nwhile (n-- > 0)\r\nprintf (" %x", *p++);\r\nprintf (".\n");\r\n}\r\nstatic void sym_print_msg(struct sym_ccb *cp, char *label, u_char *msg)\r\n{\r\nsym_print_addr(cp->cmd, "%s: ", label);\r\nspi_print_msg(msg);\r\nprintf("\n");\r\n}\r\nstatic void sym_print_nego_msg(struct sym_hcb *np, int target, char *label, u_char *msg)\r\n{\r\nstruct sym_tcb *tp = &np->target[target];\r\ndev_info(&tp->starget->dev, "%s: ", label);\r\nspi_print_msg(msg);\r\nprintf("\n");\r\n}\r\nvoid sym_print_xerr(struct scsi_cmnd *cmd, int x_status)\r\n{\r\nif (x_status & XE_PARITY_ERR) {\r\nsym_print_addr(cmd, "unrecovered SCSI parity error.\n");\r\n}\r\nif (x_status & XE_EXTRA_DATA) {\r\nsym_print_addr(cmd, "extraneous data discarded.\n");\r\n}\r\nif (x_status & XE_BAD_PHASE) {\r\nsym_print_addr(cmd, "illegal scsi phase (4/5).\n");\r\n}\r\nif (x_status & XE_SODL_UNRUN) {\r\nsym_print_addr(cmd, "ODD transfer in DATA OUT phase.\n");\r\n}\r\nif (x_status & XE_SWIDE_OVRUN) {\r\nsym_print_addr(cmd, "ODD transfer in DATA IN phase.\n");\r\n}\r\n}\r\nstatic char *sym_scsi_bus_mode(int mode)\r\n{\r\nswitch(mode) {\r\ncase SMODE_HVD: return "HVD";\r\ncase SMODE_SE: return "SE";\r\ncase SMODE_LVD: return "LVD";\r\n}\r\nreturn "??";\r\n}\r\nstatic void sym_chip_reset (struct sym_hcb *np)\r\n{\r\nOUTB(np, nc_istat, SRST);\r\nINB(np, nc_mbox1);\r\nudelay(10);\r\nOUTB(np, nc_istat, 0);\r\nINB(np, nc_mbox1);\r\nudelay(2000);\r\n}\r\nstatic void sym_soft_reset (struct sym_hcb *np)\r\n{\r\nu_char istat = 0;\r\nint i;\r\nif (!(np->features & FE_ISTAT1) || !(INB(np, nc_istat1) & SCRUN))\r\ngoto do_chip_reset;\r\nOUTB(np, nc_istat, CABRT);\r\nfor (i = 100000 ; i ; --i) {\r\nistat = INB(np, nc_istat);\r\nif (istat & SIP) {\r\nINW(np, nc_sist);\r\n}\r\nelse if (istat & DIP) {\r\nif (INB(np, nc_dstat) & ABRT)\r\nbreak;\r\n}\r\nudelay(5);\r\n}\r\nOUTB(np, nc_istat, 0);\r\nif (!i)\r\nprintf("%s: unable to abort current chip operation, "\r\n"ISTAT=0x%02x.\n", sym_name(np), istat);\r\ndo_chip_reset:\r\nsym_chip_reset(np);\r\n}\r\nstatic void sym_start_reset(struct sym_hcb *np)\r\n{\r\nsym_reset_scsi_bus(np, 1);\r\n}\r\nint sym_reset_scsi_bus(struct sym_hcb *np, int enab_int)\r\n{\r\nu32 term;\r\nint retv = 0;\r\nsym_soft_reset(np);\r\nif (enab_int)\r\nOUTW(np, nc_sien, RST);\r\nOUTB(np, nc_stest3, TE);\r\nOUTB(np, nc_dcntl, (np->rv_dcntl & IRQM));\r\nOUTB(np, nc_scntl1, CRST);\r\nINB(np, nc_mbox1);\r\nudelay(200);\r\nif (!SYM_SETUP_SCSI_BUS_CHECK)\r\ngoto out;\r\nterm = INB(np, nc_sstat0);\r\nterm = ((term & 2) << 7) + ((term & 1) << 17);\r\nterm |= ((INB(np, nc_sstat2) & 0x01) << 26) |\r\n((INW(np, nc_sbdl) & 0xff) << 9) |\r\n((INW(np, nc_sbdl) & 0xff00) << 10) |\r\nINB(np, nc_sbcl);\r\nif (!np->maxwide)\r\nterm &= 0x3ffff;\r\nif (term != (2<<7)) {\r\nprintf("%s: suspicious SCSI data while resetting the BUS.\n",\r\nsym_name(np));\r\nprintf("%s: %sdp0,d7-0,rst,req,ack,bsy,sel,atn,msg,c/d,i/o = "\r\n"0x%lx, expecting 0x%lx\n",\r\nsym_name(np),\r\n(np->features & FE_WIDE) ? "dp1,d15-8," : "",\r\n(u_long)term, (u_long)(2<<7));\r\nif (SYM_SETUP_SCSI_BUS_CHECK == 1)\r\nretv = 1;\r\n}\r\nout:\r\nOUTB(np, nc_scntl1, 0);\r\nreturn retv;\r\n}\r\nstatic void sym_selectclock(struct sym_hcb *np, u_char scntl3)\r\n{\r\nif (np->multiplier <= 1) {\r\nOUTB(np, nc_scntl3, scntl3);\r\nreturn;\r\n}\r\nif (sym_verbose >= 2)\r\nprintf ("%s: enabling clock multiplier\n", sym_name(np));\r\nOUTB(np, nc_stest1, DBLEN);\r\nif (np->features & FE_LCKFRQ) {\r\nint i = 20;\r\nwhile (!(INB(np, nc_stest4) & LCKFRQ) && --i > 0)\r\nudelay(20);\r\nif (!i)\r\nprintf("%s: the chip cannot lock the frequency\n",\r\nsym_name(np));\r\n} else {\r\nINB(np, nc_mbox1);\r\nudelay(50+10);\r\n}\r\nOUTB(np, nc_stest3, HSC);\r\nOUTB(np, nc_scntl3, scntl3);\r\nOUTB(np, nc_stest1, (DBLEN|DBLSEL));\r\nOUTB(np, nc_stest3, 0x00);\r\n}\r\nstatic unsigned getfreq (struct sym_hcb *np, int gen)\r\n{\r\nunsigned int ms = 0;\r\nunsigned int f;\r\nOUTW(np, nc_sien, 0);\r\nINW(np, nc_sist);\r\nOUTB(np, nc_dien, 0);\r\nINW(np, nc_sist);\r\nif (np->features & FE_C10) {\r\nOUTW(np, nc_sien, GEN);\r\nOUTB(np, nc_istat1, SIRQD);\r\n}\r\nOUTB(np, nc_scntl3, 4);\r\nOUTB(np, nc_stime1, 0);\r\nOUTB(np, nc_stime1, gen);\r\nwhile (!(INW(np, nc_sist) & GEN) && ms++ < 100000)\r\nudelay(1000/4);\r\nOUTB(np, nc_stime1, 0);\r\nif (np->features & FE_C10) {\r\nOUTW(np, nc_sien, 0);\r\nOUTB(np, nc_istat1, 0);\r\n}\r\nOUTB(np, nc_scntl3, 0);\r\nf = ms ? ((1 << gen) * (4340*4)) / ms : 0;\r\nif (np->features & FE_C10)\r\nf = (f * 2) / 3;\r\nif (sym_verbose >= 2)\r\nprintf ("%s: Delay (GEN=%d): %u msec, %u KHz\n",\r\nsym_name(np), gen, ms/4, f);\r\nreturn f;\r\n}\r\nstatic unsigned sym_getfreq (struct sym_hcb *np)\r\n{\r\nu_int f1, f2;\r\nint gen = 8;\r\ngetfreq (np, gen);\r\nf1 = getfreq (np, gen);\r\nf2 = getfreq (np, gen);\r\nif (f1 > f2) f1 = f2;\r\nreturn f1;\r\n}\r\nstatic void sym_getclock (struct sym_hcb *np, int mult)\r\n{\r\nunsigned char scntl3 = np->sv_scntl3;\r\nunsigned char stest1 = np->sv_stest1;\r\nunsigned f1;\r\nnp->multiplier = 1;\r\nf1 = 40000;\r\nif (mult > 1 && (stest1 & (DBLEN+DBLSEL)) == DBLEN+DBLSEL) {\r\nif (sym_verbose >= 2)\r\nprintf ("%s: clock multiplier found\n", sym_name(np));\r\nnp->multiplier = mult;\r\n}\r\nif (np->multiplier != mult || (scntl3 & 7) < 3 || !(scntl3 & 1)) {\r\nOUTB(np, nc_stest1, 0);\r\nf1 = sym_getfreq (np);\r\nif (sym_verbose)\r\nprintf ("%s: chip clock is %uKHz\n", sym_name(np), f1);\r\nif (f1 < 45000) f1 = 40000;\r\nelse if (f1 < 55000) f1 = 50000;\r\nelse f1 = 80000;\r\nif (f1 < 80000 && mult > 1) {\r\nif (sym_verbose >= 2)\r\nprintf ("%s: clock multiplier assumed\n",\r\nsym_name(np));\r\nnp->multiplier = mult;\r\n}\r\n} else {\r\nif ((scntl3 & 7) == 3) f1 = 40000;\r\nelse if ((scntl3 & 7) == 5) f1 = 80000;\r\nelse f1 = 160000;\r\nf1 /= np->multiplier;\r\n}\r\nf1 *= np->multiplier;\r\nnp->clock_khz = f1;\r\n}\r\nstatic int\r\nsym_getsync(struct sym_hcb *np, u_char dt, u_char sfac, u_char *divp, u_char *fakp)\r\n{\r\nu32 clk = np->clock_khz;\r\nint div = np->clock_divn;\r\nu32 fak;\r\nu32 per;\r\nu32 kpc;\r\nint ret;\r\nif (dt && sfac <= 9) per = 125;\r\nelse if (sfac <= 10) per = 250;\r\nelse if (sfac == 11) per = 303;\r\nelse if (sfac == 12) per = 500;\r\nelse per = 40 * sfac;\r\nret = per;\r\nkpc = per * clk;\r\nif (dt)\r\nkpc <<= 1;\r\n#if 1\r\nif ((np->features & (FE_C10|FE_U3EN)) == FE_C10) {\r\nwhile (div > 0) {\r\n--div;\r\nif (kpc > (div_10M[div] << 2)) {\r\n++div;\r\nbreak;\r\n}\r\n}\r\nfak = 0;\r\nif (div == np->clock_divn) {\r\nret = -1;\r\n}\r\n*divp = div;\r\n*fakp = fak;\r\nreturn ret;\r\n}\r\n#endif\r\nwhile (div-- > 0)\r\nif (kpc >= (div_10M[div] << 2)) break;\r\nif (dt) {\r\nfak = (kpc - 1) / (div_10M[div] << 1) + 1 - 2;\r\n} else {\r\nfak = (kpc - 1) / div_10M[div] + 1 - 4;\r\n}\r\nif (fak > 2) {\r\nfak = 2;\r\nret = -1;\r\n}\r\n*divp = div;\r\n*fakp = fak;\r\nreturn ret;\r\n}\r\nstatic inline void sym_init_burst(struct sym_hcb *np, u_char bc)\r\n{\r\nnp->rv_ctest4 &= ~0x80;\r\nnp->rv_dmode &= ~(0x3 << 6);\r\nnp->rv_ctest5 &= ~0x4;\r\nif (!bc) {\r\nnp->rv_ctest4 |= 0x80;\r\n}\r\nelse {\r\n--bc;\r\nnp->rv_dmode |= ((bc & 0x3) << 6);\r\nnp->rv_ctest5 |= (bc & 0x4);\r\n}\r\n}\r\nstatic void sym_save_initial_setting (struct sym_hcb *np)\r\n{\r\nnp->sv_scntl0 = INB(np, nc_scntl0) & 0x0a;\r\nnp->sv_scntl3 = INB(np, nc_scntl3) & 0x07;\r\nnp->sv_dmode = INB(np, nc_dmode) & 0xce;\r\nnp->sv_dcntl = INB(np, nc_dcntl) & 0xa8;\r\nnp->sv_ctest3 = INB(np, nc_ctest3) & 0x01;\r\nnp->sv_ctest4 = INB(np, nc_ctest4) & 0x80;\r\nnp->sv_gpcntl = INB(np, nc_gpcntl);\r\nnp->sv_stest1 = INB(np, nc_stest1);\r\nnp->sv_stest2 = INB(np, nc_stest2) & 0x20;\r\nnp->sv_stest4 = INB(np, nc_stest4);\r\nif (np->features & FE_C10) {\r\nnp->sv_scntl4 = INB(np, nc_scntl4);\r\nnp->sv_ctest5 = INB(np, nc_ctest5) & 0x04;\r\n}\r\nelse\r\nnp->sv_ctest5 = INB(np, nc_ctest5) & 0x24;\r\n}\r\nstatic void sym_set_bus_mode(struct sym_hcb *np, struct sym_nvram *nvram)\r\n{\r\nif (np->scsi_mode)\r\nreturn;\r\nnp->scsi_mode = SMODE_SE;\r\nif (np->features & (FE_ULTRA2|FE_ULTRA3))\r\nnp->scsi_mode = (np->sv_stest4 & SMODE);\r\nelse if (np->features & FE_DIFF) {\r\nif (SYM_SETUP_SCSI_DIFF == 1) {\r\nif (np->sv_scntl3) {\r\nif (np->sv_stest2 & 0x20)\r\nnp->scsi_mode = SMODE_HVD;\r\n} else if (nvram->type == SYM_SYMBIOS_NVRAM) {\r\nif (!(INB(np, nc_gpreg) & 0x08))\r\nnp->scsi_mode = SMODE_HVD;\r\n}\r\n} else if (SYM_SETUP_SCSI_DIFF == 2)\r\nnp->scsi_mode = SMODE_HVD;\r\n}\r\nif (np->scsi_mode == SMODE_HVD)\r\nnp->rv_stest2 |= 0x20;\r\n}\r\nstatic int sym_prepare_setting(struct Scsi_Host *shost, struct sym_hcb *np, struct sym_nvram *nvram)\r\n{\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nu_char burst_max;\r\nu32 period;\r\nint i;\r\nnp->maxwide = (np->features & FE_WIDE) ? 1 : 0;\r\nif (np->features & (FE_ULTRA3 | FE_ULTRA2))\r\nnp->clock_khz = 160000;\r\nelse if (np->features & FE_ULTRA)\r\nnp->clock_khz = 80000;\r\nelse\r\nnp->clock_khz = 40000;\r\nif (np->features & FE_QUAD)\r\nnp->multiplier = 4;\r\nelse if (np->features & FE_DBLR)\r\nnp->multiplier = 2;\r\nelse\r\nnp->multiplier = 1;\r\nif (np->features & FE_VARCLK)\r\nsym_getclock(np, np->multiplier);\r\ni = np->clock_divn - 1;\r\nwhile (--i >= 0) {\r\nif (10ul * SYM_CONF_MIN_ASYNC * np->clock_khz > div_10M[i]) {\r\n++i;\r\nbreak;\r\n}\r\n}\r\nnp->rv_scntl3 = i+1;\r\nif (np->features & FE_C10)\r\nnp->rv_scntl3 = 0;\r\nperiod = (4 * div_10M[0] + np->clock_khz - 1) / np->clock_khz;\r\nif (period <= 250) np->minsync = 10;\r\nelse if (period <= 303) np->minsync = 11;\r\nelse if (period <= 500) np->minsync = 12;\r\nelse np->minsync = (period + 40 - 1) / 40;\r\nif (np->minsync < 25 &&\r\n!(np->features & (FE_ULTRA|FE_ULTRA2|FE_ULTRA3)))\r\nnp->minsync = 25;\r\nelse if (np->minsync < 12 &&\r\n!(np->features & (FE_ULTRA2|FE_ULTRA3)))\r\nnp->minsync = 12;\r\nperiod = (11 * div_10M[np->clock_divn - 1]) / (4 * np->clock_khz);\r\nnp->maxsync = period > 2540 ? 254 : period / 10;\r\nif ((np->features & (FE_C10|FE_ULTRA3)) == (FE_C10|FE_ULTRA3)) {\r\nif (np->clock_khz == 160000) {\r\nnp->minsync_dt = 9;\r\nnp->maxsync_dt = 50;\r\nnp->maxoffs_dt = nvram->type ? 62 : 31;\r\n}\r\n}\r\nif (np->features & FE_DAC) {\r\nif (!use_dac(np))\r\nnp->rv_ccntl1 |= (DDAC);\r\nelse if (SYM_CONF_DMA_ADDRESSING_MODE == 1)\r\nnp->rv_ccntl1 |= (XTIMOD | EXTIBMV);\r\nelse if (SYM_CONF_DMA_ADDRESSING_MODE == 2)\r\nnp->rv_ccntl1 |= (0 | EXTIBMV);\r\n}\r\nif (np->features & FE_NOPM)\r\nnp->rv_ccntl0 |= (ENPMJ);\r\nif (pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 &&\r\npdev->revision < 0x1)\r\nnp->rv_ccntl0 |= DILS;\r\nburst_max = SYM_SETUP_BURST_ORDER;\r\nif (burst_max == 255)\r\nburst_max = burst_code(np->sv_dmode, np->sv_ctest4,\r\nnp->sv_ctest5);\r\nif (burst_max > 7)\r\nburst_max = 7;\r\nif (burst_max > np->maxburst)\r\nburst_max = np->maxburst;\r\nif ((pdev->device == PCI_DEVICE_ID_NCR_53C810 &&\r\npdev->revision >= 0x10 && pdev->revision <= 0x11) ||\r\n(pdev->device == PCI_DEVICE_ID_NCR_53C860 &&\r\npdev->revision <= 0x1))\r\nnp->features &= ~(FE_WRIE|FE_ERL|FE_ERMP);\r\nif (np->features & FE_ERL)\r\nnp->rv_dmode |= ERL;\r\nif (np->features & FE_BOF)\r\nnp->rv_dmode |= BOF;\r\nif (np->features & FE_ERMP)\r\nnp->rv_dmode |= ERMP;\r\n#if 1\r\nif ((np->features & FE_PFEN) && !np->ram_ba)\r\n#else\r\nif (np->features & FE_PFEN)\r\n#endif\r\nnp->rv_dcntl |= PFEN;\r\nif (np->features & FE_CLSE)\r\nnp->rv_dcntl |= CLSE;\r\nif (np->features & FE_WRIE)\r\nnp->rv_ctest3 |= WRIE;\r\nif (np->features & FE_DFS)\r\nnp->rv_ctest5 |= DFS;\r\nnp->rv_ctest4 |= MPEE;\r\nnp->rv_scntl0 |= 0x0a;\r\nnp->myaddr = 255;\r\nnp->scsi_mode = 0;\r\nsym_nvram_setup_host(shost, np, nvram);\r\nif (np->myaddr == 255) {\r\nnp->myaddr = INB(np, nc_scid) & 0x07;\r\nif (!np->myaddr)\r\nnp->myaddr = SYM_SETUP_HOST_ID;\r\n}\r\nsym_init_burst(np, burst_max);\r\nsym_set_bus_mode(np, nvram);\r\nif ((SYM_SETUP_SCSI_LED ||\r\n(nvram->type == SYM_SYMBIOS_NVRAM ||\r\n(nvram->type == SYM_TEKRAM_NVRAM &&\r\npdev->device == PCI_DEVICE_ID_NCR_53C895))) &&\r\n!(np->features & FE_LEDC) && !(np->sv_gpcntl & 0x01))\r\nnp->features |= FE_LED0;\r\nswitch(SYM_SETUP_IRQ_MODE & 3) {\r\ncase 2:\r\nnp->rv_dcntl |= IRQM;\r\nbreak;\r\ncase 1:\r\nnp->rv_dcntl |= (np->sv_dcntl & IRQM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nfor (i = 0 ; i < SYM_CONF_MAX_TARGET ; i++) {\r\nstruct sym_tcb *tp = &np->target[i];\r\ntp->usrflags |= (SYM_DISC_ENABLED | SYM_TAGS_ENABLED);\r\ntp->usrtags = SYM_SETUP_MAX_TAG;\r\ntp->usr_width = np->maxwide;\r\ntp->usr_period = 9;\r\nsym_nvram_setup_target(tp, i, nvram);\r\nif (!tp->usrtags)\r\ntp->usrflags &= ~SYM_TAGS_ENABLED;\r\n}\r\nprintf("%s: %s, ID %d, Fast-%d, %s, %s\n", sym_name(np),\r\nsym_nvram_type(nvram), np->myaddr,\r\n(np->features & FE_ULTRA3) ? 80 :\r\n(np->features & FE_ULTRA2) ? 40 :\r\n(np->features & FE_ULTRA) ? 20 : 10,\r\nsym_scsi_bus_mode(np->scsi_mode),\r\n(np->rv_scntl0 & 0xa) ? "parity checking" : "NO parity");\r\nif (sym_verbose) {\r\nprintf("%s: %s IRQ line driver%s\n",\r\nsym_name(np),\r\nnp->rv_dcntl & IRQM ? "totem pole" : "open drain",\r\nnp->ram_ba ? ", using on-chip SRAM" : "");\r\nprintf("%s: using %s firmware.\n", sym_name(np), np->fw_name);\r\nif (np->features & FE_NOPM)\r\nprintf("%s: handling phase mismatch from SCRIPTS.\n",\r\nsym_name(np));\r\n}\r\nif (sym_verbose >= 2) {\r\nprintf ("%s: initial SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "\r\n"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n",\r\nsym_name(np), np->sv_scntl3, np->sv_dmode, np->sv_dcntl,\r\nnp->sv_ctest3, np->sv_ctest4, np->sv_ctest5);\r\nprintf ("%s: final SCNTL3/DMODE/DCNTL/CTEST3/4/5 = "\r\n"(hex) %02x/%02x/%02x/%02x/%02x/%02x\n",\r\nsym_name(np), np->rv_scntl3, np->rv_dmode, np->rv_dcntl,\r\nnp->rv_ctest3, np->rv_ctest4, np->rv_ctest5);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int sym_regtest(struct sym_hcb *np)\r\n{\r\nreturn 0;\r\n}\r\nstatic int sym_snooptest(struct sym_hcb *np)\r\n{\r\nu32 sym_rd, sym_wr, sym_bk, host_rd, host_wr, pc, dstat;\r\nint i, err;\r\nerr = sym_regtest(np);\r\nif (err)\r\nreturn err;\r\nrestart_test:\r\nOUTB(np, nc_ctest4, (np->rv_ctest4 & MPEE));\r\npc = SCRIPTZ_BA(np, snooptest);\r\nhost_wr = 1;\r\nsym_wr = 2;\r\nnp->scratch = cpu_to_scr(host_wr);\r\nOUTL(np, nc_temp, sym_wr);\r\nOUTL(np, nc_dsa, np->hcb_ba);\r\nOUTL_DSP(np, pc);\r\nfor (i=0; i<SYM_SNOOP_TIMEOUT; i++)\r\nif (INB(np, nc_istat) & (INTF|SIP|DIP))\r\nbreak;\r\nif (i>=SYM_SNOOP_TIMEOUT) {\r\nprintf ("CACHE TEST FAILED: timeout.\n");\r\nreturn (0x20);\r\n}\r\ndstat = INB(np, nc_dstat);\r\n#if 1\r\nif ((dstat & MDPE) && (np->rv_ctest4 & MPEE)) {\r\nprintf ("%s: PCI DATA PARITY ERROR DETECTED - "\r\n"DISABLING MASTER DATA PARITY CHECKING.\n",\r\nsym_name(np));\r\nnp->rv_ctest4 &= ~MPEE;\r\ngoto restart_test;\r\n}\r\n#endif\r\nif (dstat & (MDPE|BF|IID)) {\r\nprintf ("CACHE TEST FAILED: DMA error (dstat=0x%02x).", dstat);\r\nreturn (0x80);\r\n}\r\npc = INL(np, nc_dsp);\r\nhost_rd = scr_to_cpu(np->scratch);\r\nsym_rd = INL(np, nc_scratcha);\r\nsym_bk = INL(np, nc_temp);\r\nif (pc != SCRIPTZ_BA(np, snoopend)+8) {\r\nprintf ("CACHE TEST FAILED: script execution failed.\n");\r\nprintf ("start=%08lx, pc=%08lx, end=%08lx\n",\r\n(u_long) SCRIPTZ_BA(np, snooptest), (u_long) pc,\r\n(u_long) SCRIPTZ_BA(np, snoopend) +8);\r\nreturn (0x40);\r\n}\r\nif (host_wr != sym_rd) {\r\nprintf ("CACHE TEST FAILED: host wrote %d, chip read %d.\n",\r\n(int) host_wr, (int) sym_rd);\r\nerr |= 1;\r\n}\r\nif (host_rd != sym_wr) {\r\nprintf ("CACHE TEST FAILED: chip wrote %d, host read %d.\n",\r\n(int) sym_wr, (int) host_rd);\r\nerr |= 2;\r\n}\r\nif (sym_bk != sym_wr) {\r\nprintf ("CACHE TEST FAILED: chip wrote %d, read back %d.\n",\r\n(int) sym_wr, (int) sym_bk);\r\nerr |= 4;\r\n}\r\nreturn err;\r\n}\r\nstatic void sym_log_hard_error(struct Scsi_Host *shost, u_short sist, u_char dstat)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nu32 dsp;\r\nint script_ofs;\r\nint script_size;\r\nchar *script_name;\r\nu_char *script_base;\r\nint i;\r\ndsp = INL(np, nc_dsp);\r\nif (dsp > np->scripta_ba &&\r\ndsp <= np->scripta_ba + np->scripta_sz) {\r\nscript_ofs = dsp - np->scripta_ba;\r\nscript_size = np->scripta_sz;\r\nscript_base = (u_char *) np->scripta0;\r\nscript_name = "scripta";\r\n}\r\nelse if (np->scriptb_ba < dsp &&\r\ndsp <= np->scriptb_ba + np->scriptb_sz) {\r\nscript_ofs = dsp - np->scriptb_ba;\r\nscript_size = np->scriptb_sz;\r\nscript_base = (u_char *) np->scriptb0;\r\nscript_name = "scriptb";\r\n} else {\r\nscript_ofs = dsp;\r\nscript_size = 0;\r\nscript_base = NULL;\r\nscript_name = "mem";\r\n}\r\nprintf ("%s:%d: ERROR (%x:%x) (%x-%x-%x) (%x/%x/%x) @ (%s %x:%08x).\n",\r\nsym_name(np), (unsigned)INB(np, nc_sdid)&0x0f, dstat, sist,\r\n(unsigned)INB(np, nc_socl), (unsigned)INB(np, nc_sbcl),\r\n(unsigned)INB(np, nc_sbdl), (unsigned)INB(np, nc_sxfer),\r\n(unsigned)INB(np, nc_scntl3),\r\n(np->features & FE_C10) ? (unsigned)INB(np, nc_scntl4) : 0,\r\nscript_name, script_ofs, (unsigned)INL(np, nc_dbc));\r\nif (((script_ofs & 3) == 0) &&\r\n(unsigned)script_ofs < script_size) {\r\nprintf ("%s: script cmd = %08x\n", sym_name(np),\r\nscr_to_cpu((int) *(u32 *)(script_base + script_ofs)));\r\n}\r\nprintf("%s: regdump:", sym_name(np));\r\nfor (i = 0; i < 24; i++)\r\nprintf(" %02x", (unsigned)INB_OFF(np, i));\r\nprintf(".\n");\r\nif (dstat & (MDPE|BF))\r\nsym_log_bus_error(shost);\r\n}\r\nvoid sym_dump_registers(struct Scsi_Host *shost)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nu_short sist;\r\nu_char dstat;\r\nsist = INW(np, nc_sist);\r\ndstat = INB(np, nc_dstat);\r\nsym_log_hard_error(shost, sist, dstat);\r\n}\r\nstruct sym_chip *\r\nsym_lookup_chip_table (u_short device_id, u_char revision)\r\n{\r\nstruct sym_chip *chip;\r\nint i;\r\nfor (i = 0; i < sym_num_devs; i++) {\r\nchip = &sym_dev_table[i];\r\nif (device_id != chip->device_id)\r\ncontinue;\r\nif (revision > chip->revision_id)\r\ncontinue;\r\nreturn chip;\r\n}\r\nreturn NULL;\r\n}\r\nint sym_lookup_dmap(struct sym_hcb *np, u32 h, int s)\r\n{\r\nint i;\r\nif (!use_dac(np))\r\ngoto weird;\r\nfor (i = SYM_DMAP_SIZE-1; i > 0; i--) {\r\nif (h == np->dmap_bah[i])\r\nreturn i;\r\n}\r\nif (!np->dmap_bah[s])\r\ngoto new;\r\nfor (s = SYM_DMAP_SIZE-1; s > 0; s--) {\r\nif (!np->dmap_bah[s])\r\ngoto new;\r\n}\r\nweird:\r\npanic("sym: ran out of 64 bit DMA segment registers");\r\nreturn -1;\r\nnew:\r\nnp->dmap_bah[s] = h;\r\nnp->dmap_dirty = 1;\r\nreturn s;\r\n}\r\nstatic void sym_update_dmap_regs(struct sym_hcb *np)\r\n{\r\nint o, i;\r\nif (!np->dmap_dirty)\r\nreturn;\r\no = offsetof(struct sym_reg, nc_scrx[0]);\r\nfor (i = 0; i < SYM_DMAP_SIZE; i++) {\r\nOUTL_OFF(np, o, np->dmap_bah[i]);\r\no += 4;\r\n}\r\nnp->dmap_dirty = 0;\r\n}\r\nstatic void sym_check_goals(struct sym_hcb *np, struct scsi_target *starget,\r\nstruct sym_trans *goal)\r\n{\r\nif (!spi_support_wide(starget))\r\ngoal->width = 0;\r\nif (!spi_support_sync(starget)) {\r\ngoal->iu = 0;\r\ngoal->dt = 0;\r\ngoal->qas = 0;\r\ngoal->offset = 0;\r\nreturn;\r\n}\r\nif (spi_support_dt(starget)) {\r\nif (spi_support_dt_only(starget))\r\ngoal->dt = 1;\r\nif (goal->offset == 0)\r\ngoal->dt = 0;\r\n} else {\r\ngoal->dt = 0;\r\n}\r\nif ((np->scsi_mode != SMODE_LVD) || !(np->features & FE_U3EN))\r\ngoal->dt = 0;\r\nif (goal->dt) {\r\ngoal->width = 1;\r\nif (goal->offset > np->maxoffs_dt)\r\ngoal->offset = np->maxoffs_dt;\r\nif (goal->period < np->minsync_dt)\r\ngoal->period = np->minsync_dt;\r\nif (goal->period > np->maxsync_dt)\r\ngoal->period = np->maxsync_dt;\r\n} else {\r\ngoal->iu = goal->qas = 0;\r\nif (goal->offset > np->maxoffs)\r\ngoal->offset = np->maxoffs;\r\nif (goal->period < np->minsync)\r\ngoal->period = np->minsync;\r\nif (goal->period > np->maxsync)\r\ngoal->period = np->maxsync;\r\n}\r\n}\r\nstatic int sym_prepare_nego(struct sym_hcb *np, struct sym_ccb *cp, u_char *msgptr)\r\n{\r\nstruct sym_tcb *tp = &np->target[cp->target];\r\nstruct scsi_target *starget = tp->starget;\r\nstruct sym_trans *goal = &tp->tgoal;\r\nint msglen = 0;\r\nint nego;\r\nsym_check_goals(np, starget, goal);\r\nif (goal->renego == NS_PPR || (goal->offset &&\r\n(goal->iu || goal->dt || goal->qas || (goal->period < 0xa)))) {\r\nnego = NS_PPR;\r\n} else if (goal->renego == NS_WIDE || goal->width) {\r\nnego = NS_WIDE;\r\n} else if (goal->renego == NS_SYNC || goal->offset) {\r\nnego = NS_SYNC;\r\n} else {\r\ngoal->check_nego = 0;\r\nnego = 0;\r\n}\r\nswitch (nego) {\r\ncase NS_SYNC:\r\nmsglen += spi_populate_sync_msg(msgptr + msglen, goal->period,\r\ngoal->offset);\r\nbreak;\r\ncase NS_WIDE:\r\nmsglen += spi_populate_width_msg(msgptr + msglen, goal->width);\r\nbreak;\r\ncase NS_PPR:\r\nmsglen += spi_populate_ppr_msg(msgptr + msglen, goal->period,\r\ngoal->offset, goal->width,\r\n(goal->iu ? PPR_OPT_IU : 0) |\r\n(goal->dt ? PPR_OPT_DT : 0) |\r\n(goal->qas ? PPR_OPT_QAS : 0));\r\nbreak;\r\n}\r\ncp->nego_status = nego;\r\nif (nego) {\r\ntp->nego_cp = cp;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, cp->target,\r\nnego == NS_SYNC ? "sync msgout" :\r\nnego == NS_WIDE ? "wide msgout" :\r\n"ppr msgout", msgptr);\r\n}\r\n}\r\nreturn msglen;\r\n}\r\nvoid sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp)\r\n{\r\nu_short qidx;\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\nif (np->last_cp && np->iarb_count < np->iarb_max) {\r\nnp->last_cp->host_flags |= HF_HINT_IARB;\r\n++np->iarb_count;\r\n}\r\nelse\r\nnp->iarb_count = 0;\r\nnp->last_cp = cp;\r\n#endif\r\n#if SYM_CONF_DMA_ADDRESSING_MODE == 2\r\nif (np->dmap_dirty)\r\ncp->host_xflags |= HX_DMAP_DIRTY;\r\n#endif\r\nqidx = np->squeueput + 2;\r\nif (qidx >= MAX_QUEUE*2) qidx = 0;\r\nnp->squeue [qidx] = cpu_to_scr(np->idletask_ba);\r\nMEMORY_WRITE_BARRIER();\r\nnp->squeue [np->squeueput] = cpu_to_scr(cp->ccb_ba);\r\nnp->squeueput = qidx;\r\nif (DEBUG_FLAGS & DEBUG_QUEUE)\r\nscmd_printk(KERN_DEBUG, cp->cmd, "queuepos=%d\n",\r\nnp->squeueput);\r\nMEMORY_WRITE_BARRIER();\r\nOUTB(np, nc_istat, SIGP|np->istat_sem);\r\n}\r\nvoid sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn)\r\n{\r\nSYM_QUEHEAD *qp;\r\nstruct sym_ccb *cp;\r\nassert(!lp->started_tags || !lp->started_no_tag);\r\nwhile (maxn--) {\r\nqp = sym_remque_head(&lp->waiting_ccbq);\r\nif (!qp)\r\nbreak;\r\ncp = sym_que_entry(qp, struct sym_ccb, link2_ccbq);\r\nif (cp->tag != NO_TAG) {\r\nif (lp->started_no_tag ||\r\nlp->started_tags >= lp->started_max) {\r\nsym_insque_head(qp, &lp->waiting_ccbq);\r\nbreak;\r\n}\r\nlp->itlq_tbl[cp->tag] = cpu_to_scr(cp->ccb_ba);\r\nlp->head.resel_sa =\r\ncpu_to_scr(SCRIPTA_BA(np, resel_tag));\r\n++lp->started_tags;\r\n} else {\r\nif (lp->started_no_tag || lp->started_tags) {\r\nsym_insque_head(qp, &lp->waiting_ccbq);\r\nbreak;\r\n}\r\nlp->head.itl_task_sa = cpu_to_scr(cp->ccb_ba);\r\nlp->head.resel_sa =\r\ncpu_to_scr(SCRIPTA_BA(np, resel_no_tag));\r\n++lp->started_no_tag;\r\n}\r\ncp->started = 1;\r\nsym_insque_tail(qp, &lp->started_ccbq);\r\nsym_put_start_queue(np, cp);\r\n}\r\n}\r\nstatic int sym_wakeup_done (struct sym_hcb *np)\r\n{\r\nstruct sym_ccb *cp;\r\nint i, n;\r\nu32 dsa;\r\nn = 0;\r\ni = np->dqueueget;\r\nwhile (1) {\r\ndsa = scr_to_cpu(np->dqueue[i]);\r\nif (!dsa)\r\nbreak;\r\nnp->dqueue[i] = 0;\r\nif ((i = i+2) >= MAX_QUEUE*2)\r\ni = 0;\r\ncp = sym_ccb_from_dsa(np, dsa);\r\nif (cp) {\r\nMEMORY_READ_BARRIER();\r\nsym_complete_ok (np, cp);\r\n++n;\r\n}\r\nelse\r\nprintf ("%s: bad DSA (%x) in done queue.\n",\r\nsym_name(np), (u_int) dsa);\r\n}\r\nnp->dqueueget = i;\r\nreturn n;\r\n}\r\nstatic void sym_flush_comp_queue(struct sym_hcb *np, int cam_status)\r\n{\r\nSYM_QUEHEAD *qp;\r\nstruct sym_ccb *cp;\r\nwhile ((qp = sym_remque_head(&np->comp_ccbq)) != NULL) {\r\nstruct scsi_cmnd *cmd;\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nsym_insque_tail(&cp->link_ccbq, &np->busy_ccbq);\r\nif (cp->host_status == HS_WAIT)\r\ncontinue;\r\ncmd = cp->cmd;\r\nif (cam_status)\r\nsym_set_cam_status(cmd, cam_status);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (sym_get_cam_status(cmd) == DID_SOFT_ERROR) {\r\nstruct sym_tcb *tp = &np->target[cp->target];\r\nstruct sym_lcb *lp = sym_lp(tp, cp->lun);\r\nif (lp) {\r\nsym_remque(&cp->link2_ccbq);\r\nsym_insque_tail(&cp->link2_ccbq,\r\n&lp->waiting_ccbq);\r\nif (cp->started) {\r\nif (cp->tag != NO_TAG)\r\n--lp->started_tags;\r\nelse\r\n--lp->started_no_tag;\r\n}\r\n}\r\ncp->started = 0;\r\ncontinue;\r\n}\r\n#endif\r\nsym_free_ccb(np, cp);\r\nsym_xpt_done(np, cmd);\r\n}\r\n}\r\nstatic void sym_flush_busy_queue (struct sym_hcb *np, int cam_status)\r\n{\r\nsym_que_splice(&np->busy_ccbq, &np->comp_ccbq);\r\nsym_que_init(&np->busy_ccbq);\r\nsym_flush_comp_queue(np, cam_status);\r\n}\r\nvoid sym_start_up(struct Scsi_Host *shost, int reason)\r\n{\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nstruct sym_hcb *np = sym_data->ncb;\r\nint i;\r\nu32 phys;\r\nif (reason == 1)\r\nsym_soft_reset(np);\r\nelse {\r\nOUTB(np, nc_stest3, TE|CSF);\r\nOUTONB(np, nc_ctest3, CLF);\r\n}\r\nphys = np->squeue_ba;\r\nfor (i = 0; i < MAX_QUEUE*2; i += 2) {\r\nnp->squeue[i] = cpu_to_scr(np->idletask_ba);\r\nnp->squeue[i+1] = cpu_to_scr(phys + (i+2)*4);\r\n}\r\nnp->squeue[MAX_QUEUE*2-1] = cpu_to_scr(phys);\r\nnp->squeueput = 0;\r\nphys = np->dqueue_ba;\r\nfor (i = 0; i < MAX_QUEUE*2; i += 2) {\r\nnp->dqueue[i] = 0;\r\nnp->dqueue[i+1] = cpu_to_scr(phys + (i+2)*4);\r\n}\r\nnp->dqueue[MAX_QUEUE*2-1] = cpu_to_scr(phys);\r\nnp->dqueueget = 0;\r\nnp->fw_patch(shost);\r\nsym_flush_busy_queue(np, DID_RESET);\r\nOUTB(np, nc_istat, 0x00);\r\nINB(np, nc_mbox1);\r\nudelay(2000);\r\nOUTB(np, nc_scntl0, np->rv_scntl0 | 0xc0);\r\nOUTB(np, nc_scntl1, 0x00);\r\nsym_selectclock(np, np->rv_scntl3);\r\nOUTB(np, nc_scid , RRE|np->myaddr);\r\nOUTW(np, nc_respid, 1ul<<np->myaddr);\r\nOUTB(np, nc_istat , SIGP );\r\nOUTB(np, nc_dmode , np->rv_dmode);\r\nOUTB(np, nc_ctest5, np->rv_ctest5);\r\nOUTB(np, nc_dcntl , NOCOM|np->rv_dcntl);\r\nOUTB(np, nc_ctest3, np->rv_ctest3);\r\nOUTB(np, nc_ctest4, np->rv_ctest4);\r\nif (np->features & FE_C10)\r\nOUTB(np, nc_stest2, np->rv_stest2);\r\nelse\r\nOUTB(np, nc_stest2, EXT|np->rv_stest2);\r\nOUTB(np, nc_stest3, TE);\r\nOUTB(np, nc_stime0, 0x0c);\r\nif (pdev->device == PCI_DEVICE_ID_LSI_53C1010_66)\r\nOUTB(np, nc_aipcntl1, DISAIP);\r\nif (pdev->device == PCI_DEVICE_ID_LSI_53C1010_33 &&\r\npdev->revision < 1)\r\nOUTB(np, nc_stest1, INB(np, nc_stest1) | 0x30);\r\nif (pdev->device == PCI_DEVICE_ID_NCR_53C875)\r\nOUTB(np, nc_ctest0, (1<<5));\r\nelse if (pdev->device == PCI_DEVICE_ID_NCR_53C896)\r\nnp->rv_ccntl0 |= DPR;\r\nif (np->features & (FE_DAC|FE_NOPM)) {\r\nOUTB(np, nc_ccntl0, np->rv_ccntl0);\r\nOUTB(np, nc_ccntl1, np->rv_ccntl1);\r\n}\r\n#if SYM_CONF_DMA_ADDRESSING_MODE == 2\r\nif (use_dac(np)) {\r\nnp->dmap_bah[0] = 0;\r\nOUTL(np, nc_scrx[0], np->dmap_bah[0]);\r\nOUTL(np, nc_drs, np->dmap_bah[0]);\r\n}\r\n#endif\r\nif (np->features & FE_NOPM) {\r\nOUTL(np, nc_pmjad1, SCRIPTB_BA(np, pm_handle));\r\nOUTL(np, nc_pmjad2, SCRIPTB_BA(np, pm_handle));\r\n}\r\nif (np->features & FE_LED0)\r\nOUTB(np, nc_gpcntl, INB(np, nc_gpcntl) & ~0x01);\r\nelse if (np->features & FE_LEDC)\r\nOUTB(np, nc_gpcntl, (INB(np, nc_gpcntl) & ~0x41) | 0x20);\r\nOUTW(np, nc_sien , STO|HTH|MA|SGE|UDC|RST|PAR);\r\nOUTB(np, nc_dien , MDPE|BF|SSI|SIR|IID);\r\nif (np->features & (FE_ULTRA2|FE_ULTRA3)) {\r\nOUTONW(np, nc_sien, SBMC);\r\nif (reason == 0) {\r\nINB(np, nc_mbox1);\r\nmdelay(100);\r\nINW(np, nc_sist);\r\n}\r\nnp->scsi_mode = INB(np, nc_stest4) & SMODE;\r\n}\r\nfor (i=0;i<SYM_CONF_MAX_TARGET;i++) {\r\nstruct sym_tcb *tp = &np->target[i];\r\ntp->to_reset = 0;\r\ntp->head.sval = 0;\r\ntp->head.wval = np->rv_scntl3;\r\ntp->head.uval = 0;\r\nif (tp->lun0p)\r\ntp->lun0p->to_clear = 0;\r\nif (tp->lunmp) {\r\nint ln;\r\nfor (ln = 1; ln < SYM_CONF_MAX_LUN; ln++)\r\nif (tp->lunmp[ln])\r\ntp->lunmp[ln]->to_clear = 0;\r\n}\r\n}\r\nphys = SCRIPTA_BA(np, init);\r\nif (np->ram_ba) {\r\nif (sym_verbose >= 2)\r\nprintf("%s: Downloading SCSI SCRIPTS.\n", sym_name(np));\r\nmemcpy_toio(np->s.ramaddr, np->scripta0, np->scripta_sz);\r\nif (np->features & FE_RAM8K) {\r\nmemcpy_toio(np->s.ramaddr + 4096, np->scriptb0, np->scriptb_sz);\r\nphys = scr_to_cpu(np->scr_ram_seg);\r\nOUTL(np, nc_mmws, phys);\r\nOUTL(np, nc_mmrs, phys);\r\nOUTL(np, nc_sfs, phys);\r\nphys = SCRIPTB_BA(np, start64);\r\n}\r\n}\r\nnp->istat_sem = 0;\r\nOUTL(np, nc_dsa, np->hcb_ba);\r\nOUTL_DSP(np, phys);\r\nif (reason != 0)\r\nsym_xpt_async_bus_reset(np);\r\n}\r\nstatic void sym_settrans(struct sym_hcb *np, int target, u_char opts, u_char ofs,\r\nu_char per, u_char wide, u_char div, u_char fak)\r\n{\r\nSYM_QUEHEAD *qp;\r\nu_char sval, wval, uval;\r\nstruct sym_tcb *tp = &np->target[target];\r\nassert(target == (INB(np, nc_sdid) & 0x0f));\r\nsval = tp->head.sval;\r\nwval = tp->head.wval;\r\nuval = tp->head.uval;\r\n#if 0\r\nprintf("XXXX sval=%x wval=%x uval=%x (%x)\n",\r\nsval, wval, uval, np->rv_scntl3);\r\n#endif\r\nif (!(np->features & FE_C10))\r\nsval = (sval & ~0x1f) | ofs;\r\nelse\r\nsval = (sval & ~0x3f) | ofs;\r\nif (ofs != 0) {\r\nwval = (wval & ~0x70) | ((div+1) << 4);\r\nif (!(np->features & FE_C10))\r\nsval = (sval & ~0xe0) | (fak << 5);\r\nelse {\r\nuval = uval & ~(XCLKH_ST|XCLKH_DT|XCLKS_ST|XCLKS_DT);\r\nif (fak >= 1) uval |= (XCLKH_ST|XCLKH_DT);\r\nif (fak >= 2) uval |= (XCLKS_ST|XCLKS_DT);\r\n}\r\n}\r\nwval = wval & ~EWS;\r\nif (wide != 0)\r\nwval |= EWS;\r\nif (np->features & FE_C10) {\r\nuval = uval & ~(U3EN|AIPCKEN);\r\nif (opts) {\r\nassert(np->features & FE_U3EN);\r\nuval |= U3EN;\r\n}\r\n} else {\r\nwval = wval & ~ULTRA;\r\nif (per <= 12) wval |= ULTRA;\r\n}\r\nif (tp->head.sval == sval &&\r\ntp->head.wval == wval &&\r\ntp->head.uval == uval)\r\nreturn;\r\ntp->head.sval = sval;\r\ntp->head.wval = wval;\r\ntp->head.uval = uval;\r\nif (per < 50 && !(np->features & FE_C10))\r\nOUTOFFB(np, nc_stest2, EXT);\r\nOUTB(np, nc_sxfer, tp->head.sval);\r\nOUTB(np, nc_scntl3, tp->head.wval);\r\nif (np->features & FE_C10) {\r\nOUTB(np, nc_scntl4, tp->head.uval);\r\n}\r\nFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\r\nstruct sym_ccb *cp;\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nif (cp->target != target)\r\ncontinue;\r\ncp->phys.select.sel_scntl3 = tp->head.wval;\r\ncp->phys.select.sel_sxfer = tp->head.sval;\r\nif (np->features & FE_C10) {\r\ncp->phys.select.sel_scntl4 = tp->head.uval;\r\n}\r\n}\r\n}\r\nstatic void sym_announce_transfer_rate(struct sym_tcb *tp)\r\n{\r\nstruct scsi_target *starget = tp->starget;\r\nif (tp->tprint.period != spi_period(starget) ||\r\ntp->tprint.offset != spi_offset(starget) ||\r\ntp->tprint.width != spi_width(starget) ||\r\ntp->tprint.iu != spi_iu(starget) ||\r\ntp->tprint.dt != spi_dt(starget) ||\r\ntp->tprint.qas != spi_qas(starget) ||\r\n!tp->tprint.check_nego) {\r\ntp->tprint.period = spi_period(starget);\r\ntp->tprint.offset = spi_offset(starget);\r\ntp->tprint.width = spi_width(starget);\r\ntp->tprint.iu = spi_iu(starget);\r\ntp->tprint.dt = spi_dt(starget);\r\ntp->tprint.qas = spi_qas(starget);\r\ntp->tprint.check_nego = 1;\r\nspi_display_xfer_agreement(starget);\r\n}\r\n}\r\nstatic void sym_setwide(struct sym_hcb *np, int target, u_char wide)\r\n{\r\nstruct sym_tcb *tp = &np->target[target];\r\nstruct scsi_target *starget = tp->starget;\r\nsym_settrans(np, target, 0, 0, 0, wide, 0, 0);\r\nif (wide)\r\ntp->tgoal.renego = NS_WIDE;\r\nelse\r\ntp->tgoal.renego = 0;\r\ntp->tgoal.check_nego = 0;\r\ntp->tgoal.width = wide;\r\nspi_offset(starget) = 0;\r\nspi_period(starget) = 0;\r\nspi_width(starget) = wide;\r\nspi_iu(starget) = 0;\r\nspi_dt(starget) = 0;\r\nspi_qas(starget) = 0;\r\nif (sym_verbose >= 3)\r\nsym_announce_transfer_rate(tp);\r\n}\r\nstatic void\r\nsym_setsync(struct sym_hcb *np, int target,\r\nu_char ofs, u_char per, u_char div, u_char fak)\r\n{\r\nstruct sym_tcb *tp = &np->target[target];\r\nstruct scsi_target *starget = tp->starget;\r\nu_char wide = (tp->head.wval & EWS) ? BUS_16_BIT : BUS_8_BIT;\r\nsym_settrans(np, target, 0, ofs, per, wide, div, fak);\r\nif (wide)\r\ntp->tgoal.renego = NS_WIDE;\r\nelse if (ofs)\r\ntp->tgoal.renego = NS_SYNC;\r\nelse\r\ntp->tgoal.renego = 0;\r\nspi_period(starget) = per;\r\nspi_offset(starget) = ofs;\r\nspi_iu(starget) = spi_dt(starget) = spi_qas(starget) = 0;\r\nif (!tp->tgoal.dt && !tp->tgoal.iu && !tp->tgoal.qas) {\r\ntp->tgoal.period = per;\r\ntp->tgoal.offset = ofs;\r\ntp->tgoal.check_nego = 0;\r\n}\r\nsym_announce_transfer_rate(tp);\r\n}\r\nstatic void\r\nsym_setpprot(struct sym_hcb *np, int target, u_char opts, u_char ofs,\r\nu_char per, u_char wide, u_char div, u_char fak)\r\n{\r\nstruct sym_tcb *tp = &np->target[target];\r\nstruct scsi_target *starget = tp->starget;\r\nsym_settrans(np, target, opts, ofs, per, wide, div, fak);\r\nif (wide || ofs)\r\ntp->tgoal.renego = NS_PPR;\r\nelse\r\ntp->tgoal.renego = 0;\r\nspi_width(starget) = tp->tgoal.width = wide;\r\nspi_period(starget) = tp->tgoal.period = per;\r\nspi_offset(starget) = tp->tgoal.offset = ofs;\r\nspi_iu(starget) = tp->tgoal.iu = !!(opts & PPR_OPT_IU);\r\nspi_dt(starget) = tp->tgoal.dt = !!(opts & PPR_OPT_DT);\r\nspi_qas(starget) = tp->tgoal.qas = !!(opts & PPR_OPT_QAS);\r\ntp->tgoal.check_nego = 0;\r\nsym_announce_transfer_rate(tp);\r\n}\r\nstatic void sym_recover_scsi_int (struct sym_hcb *np, u_char hsts)\r\n{\r\nu32 dsp = INL(np, nc_dsp);\r\nu32 dsa = INL(np, nc_dsa);\r\nstruct sym_ccb *cp = sym_ccb_from_dsa(np, dsa);\r\nif ((!(dsp > SCRIPTA_BA(np, getjob_begin) &&\r\ndsp < SCRIPTA_BA(np, getjob_end) + 1)) &&\r\n(!(dsp > SCRIPTA_BA(np, ungetjob) &&\r\ndsp < SCRIPTA_BA(np, reselect) + 1)) &&\r\n(!(dsp > SCRIPTB_BA(np, sel_for_abort) &&\r\ndsp < SCRIPTB_BA(np, sel_for_abort_1) + 1)) &&\r\n(!(dsp > SCRIPTA_BA(np, done) &&\r\ndsp < SCRIPTA_BA(np, done_end) + 1))) {\r\nOUTB(np, nc_ctest3, np->rv_ctest3 | CLF);\r\nOUTB(np, nc_stest3, TE|CSF);\r\nif (cp) {\r\ncp->host_status = hsts;\r\nOUTL_DSP(np, SCRIPTA_BA(np, complete_error));\r\n}\r\nelse {\r\nOUTL(np, nc_dsa, 0xffffff);\r\nOUTL_DSP(np, SCRIPTA_BA(np, start));\r\n}\r\n}\r\nelse\r\ngoto reset_all;\r\nreturn;\r\nreset_all:\r\nsym_start_reset(np);\r\n}\r\nstatic void sym_int_sto (struct sym_hcb *np)\r\n{\r\nu32 dsp = INL(np, nc_dsp);\r\nif (DEBUG_FLAGS & DEBUG_TINY) printf ("T");\r\nif (dsp == SCRIPTA_BA(np, wf_sel_done) + 8)\r\nsym_recover_scsi_int(np, HS_SEL_TIMEOUT);\r\nelse\r\nsym_start_reset(np);\r\n}\r\nstatic void sym_int_udc (struct sym_hcb *np)\r\n{\r\nprintf ("%s: unexpected disconnect\n", sym_name(np));\r\nsym_recover_scsi_int(np, HS_UNEXPECTED);\r\n}\r\nstatic void sym_int_sbmc(struct Scsi_Host *shost)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nu_char scsi_mode = INB(np, nc_stest4) & SMODE;\r\nprintf("%s: SCSI BUS mode change from %s to %s.\n", sym_name(np),\r\nsym_scsi_bus_mode(np->scsi_mode), sym_scsi_bus_mode(scsi_mode));\r\nsym_start_up(shost, 2);\r\n}\r\nstatic void sym_int_par (struct sym_hcb *np, u_short sist)\r\n{\r\nu_char hsts = INB(np, HS_PRT);\r\nu32 dsp = INL(np, nc_dsp);\r\nu32 dbc = INL(np, nc_dbc);\r\nu32 dsa = INL(np, nc_dsa);\r\nu_char sbcl = INB(np, nc_sbcl);\r\nu_char cmd = dbc >> 24;\r\nint phase = cmd & 7;\r\nstruct sym_ccb *cp = sym_ccb_from_dsa(np, dsa);\r\nif (printk_ratelimit())\r\nprintf("%s: SCSI parity error detected: SCR1=%d DBC=%x SBCL=%x\n",\r\nsym_name(np), hsts, dbc, sbcl);\r\nif (!(INB(np, nc_scntl1) & ISCON)) {\r\nsym_recover_scsi_int(np, HS_UNEXPECTED);\r\nreturn;\r\n}\r\nif (!cp)\r\ngoto reset_all;\r\nif ((cmd & 0xc0) || !(phase & 1) || !(sbcl & 0x8))\r\ngoto reset_all;\r\nOUTONB(np, HF_PRT, HF_EXT_ERR);\r\ncp->xerr_status |= XE_PARITY_ERR;\r\nnp->msgout[0] = (phase == 7) ? M_PARITY : M_ID_ERROR;\r\nif (phase == 1 || phase == 5) {\r\nif (dsp == SCRIPTB_BA(np, pm_handle))\r\nOUTL_DSP(np, dsp);\r\nelse if (sist & MA)\r\nsym_int_ma (np);\r\nelse {\r\nsym_set_script_dp (np, cp, dsp);\r\nOUTL_DSP(np, SCRIPTA_BA(np, dispatch));\r\n}\r\n}\r\nelse if (phase == 7)\r\n#if 1\r\ngoto reset_all;\r\n#else\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\n#endif\r\nelse\r\nOUTL_DSP(np, SCRIPTA_BA(np, dispatch));\r\nreturn;\r\nreset_all:\r\nsym_start_reset(np);\r\nreturn;\r\n}\r\nstatic void sym_int_ma (struct sym_hcb *np)\r\n{\r\nu32 dbc;\r\nu32 rest;\r\nu32 dsp;\r\nu32 dsa;\r\nu32 nxtdsp;\r\nu32 *vdsp;\r\nu32 oadr, olen;\r\nu32 *tblp;\r\nu32 newcmd;\r\nu_int delta;\r\nu_char cmd;\r\nu_char hflags, hflags0;\r\nstruct sym_pmc *pm;\r\nstruct sym_ccb *cp;\r\ndsp = INL(np, nc_dsp);\r\ndbc = INL(np, nc_dbc);\r\ndsa = INL(np, nc_dsa);\r\ncmd = dbc >> 24;\r\nrest = dbc & 0xffffff;\r\ndelta = 0;\r\ncp = sym_ccb_from_dsa(np, dsa);\r\nif ((cmd & 7) != 1 && (cmd & 7) != 5) {\r\nu_char ss0, ss2;\r\nif (np->features & FE_DFBC)\r\ndelta = INW(np, nc_dfbc);\r\nelse {\r\nu32 dfifo;\r\ndfifo = INL(np, nc_dfifo);\r\nif (dfifo & (DFS << 16))\r\ndelta = ((((dfifo >> 8) & 0x300) |\r\n(dfifo & 0xff)) - rest) & 0x3ff;\r\nelse\r\ndelta = ((dfifo & 0xff) - rest) & 0x7f;\r\n}\r\nrest += delta;\r\nss0 = INB(np, nc_sstat0);\r\nif (ss0 & OLF) rest++;\r\nif (!(np->features & FE_C10))\r\nif (ss0 & ORF) rest++;\r\nif (cp && (cp->phys.select.sel_scntl3 & EWS)) {\r\nss2 = INB(np, nc_sstat2);\r\nif (ss2 & OLF1) rest++;\r\nif (!(np->features & FE_C10))\r\nif (ss2 & ORF1) rest++;\r\n}\r\nOUTB(np, nc_ctest3, np->rv_ctest3 | CLF);\r\nOUTB(np, nc_stest3, TE|CSF);\r\n}\r\nif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_PHASE))\r\nprintf ("P%x%x RL=%d D=%d ", cmd&7, INB(np, nc_sbcl)&7,\r\n(unsigned) rest, (unsigned) delta);\r\nvdsp = NULL;\r\nnxtdsp = 0;\r\nif (dsp > np->scripta_ba &&\r\ndsp <= np->scripta_ba + np->scripta_sz) {\r\nvdsp = (u32 *)((char*)np->scripta0 + (dsp-np->scripta_ba-8));\r\nnxtdsp = dsp;\r\n}\r\nelse if (dsp > np->scriptb_ba &&\r\ndsp <= np->scriptb_ba + np->scriptb_sz) {\r\nvdsp = (u32 *)((char*)np->scriptb0 + (dsp-np->scriptb_ba-8));\r\nnxtdsp = dsp;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_PHASE) {\r\nprintf ("\nCP=%p DSP=%x NXT=%x VDSP=%p CMD=%x ",\r\ncp, (unsigned)dsp, (unsigned)nxtdsp, vdsp, cmd);\r\n}\r\nif (!vdsp) {\r\nprintf ("%s: interrupted SCRIPT address not found.\n",\r\nsym_name (np));\r\ngoto reset_all;\r\n}\r\nif (!cp) {\r\nprintf ("%s: SCSI phase error fixup: CCB already dequeued.\n",\r\nsym_name (np));\r\ngoto reset_all;\r\n}\r\noadr = scr_to_cpu(vdsp[1]);\r\nif (cmd & 0x10) {\r\ntblp = (u32 *) ((char*) &cp->phys + oadr);\r\nolen = scr_to_cpu(tblp[0]);\r\noadr = scr_to_cpu(tblp[1]);\r\n} else {\r\ntblp = (u32 *) 0;\r\nolen = scr_to_cpu(vdsp[0]) & 0xffffff;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_PHASE) {\r\nprintf ("OCMD=%x\nTBLP=%p OLEN=%x OADR=%x\n",\r\n(unsigned) (scr_to_cpu(vdsp[0]) >> 24),\r\ntblp,\r\n(unsigned) olen,\r\n(unsigned) oadr);\r\n}\r\nif (((cmd & 2) ? cmd : (cmd & ~4)) != (scr_to_cpu(vdsp[0]) >> 24)) {\r\nsym_print_addr(cp->cmd,\r\n"internal error: cmd=%02x != %02x=(vdsp[0] >> 24)\n",\r\ncmd, scr_to_cpu(vdsp[0]) >> 24);\r\ngoto reset_all;\r\n}\r\nif (cmd & 2) {\r\nsym_print_addr(cp->cmd,\r\n"phase change %x-%x %d@%08x resid=%d.\n",\r\ncmd&7, INB(np, nc_sbcl)&7, (unsigned)olen,\r\n(unsigned)oadr, (unsigned)rest);\r\ngoto unexpected_phase;\r\n}\r\nhflags0 = INB(np, HF_PRT);\r\nhflags = hflags0;\r\nif (hflags & (HF_IN_PM0 | HF_IN_PM1 | HF_DP_SAVED)) {\r\nif (hflags & HF_IN_PM0)\r\nnxtdsp = scr_to_cpu(cp->phys.pm0.ret);\r\nelse if (hflags & HF_IN_PM1)\r\nnxtdsp = scr_to_cpu(cp->phys.pm1.ret);\r\nif (hflags & HF_DP_SAVED)\r\nhflags ^= HF_ACT_PM;\r\n}\r\nif (!(hflags & HF_ACT_PM)) {\r\npm = &cp->phys.pm0;\r\nnewcmd = SCRIPTA_BA(np, pm0_data);\r\n}\r\nelse {\r\npm = &cp->phys.pm1;\r\nnewcmd = SCRIPTA_BA(np, pm1_data);\r\n}\r\nhflags &= ~(HF_IN_PM0 | HF_IN_PM1 | HF_DP_SAVED);\r\nif (hflags != hflags0)\r\nOUTB(np, HF_PRT, hflags);\r\npm->sg.addr = cpu_to_scr(oadr + olen - rest);\r\npm->sg.size = cpu_to_scr(rest);\r\npm->ret = cpu_to_scr(nxtdsp);\r\nnxtdsp = SCRIPTA_BA(np, dispatch);\r\nif ((cmd & 7) == 1 && cp && (cp->phys.select.sel_scntl3 & EWS) &&\r\n(INB(np, nc_scntl2) & WSR)) {\r\nu32 tmp;\r\ntmp = scr_to_cpu(pm->sg.addr);\r\ncp->phys.wresid.addr = cpu_to_scr(tmp);\r\npm->sg.addr = cpu_to_scr(tmp + 1);\r\ntmp = scr_to_cpu(pm->sg.size);\r\ncp->phys.wresid.size = cpu_to_scr((tmp&0xff000000) | 1);\r\npm->sg.size = cpu_to_scr(tmp - 1);\r\nif ((tmp&0xffffff) == 1)\r\nnewcmd = pm->ret;\r\nnxtdsp = SCRIPTB_BA(np, wsr_ma_helper);\r\n}\r\nif (DEBUG_FLAGS & DEBUG_PHASE) {\r\nsym_print_addr(cp->cmd, "PM %x %x %x / %x %x %x.\n",\r\nhflags0, hflags, newcmd,\r\n(unsigned)scr_to_cpu(pm->sg.addr),\r\n(unsigned)scr_to_cpu(pm->sg.size),\r\n(unsigned)scr_to_cpu(pm->ret));\r\n}\r\nsym_set_script_dp (np, cp, newcmd);\r\nOUTL_DSP(np, nxtdsp);\r\nreturn;\r\nunexpected_phase:\r\ndsp -= 8;\r\nnxtdsp = 0;\r\nswitch (cmd & 7) {\r\ncase 2:\r\nnxtdsp = SCRIPTA_BA(np, dispatch);\r\nbreak;\r\n#if 0\r\ncase 3:\r\nnxtdsp = SCRIPTA_BA(np, dispatch);\r\nbreak;\r\n#endif\r\ncase 6:\r\nif (dsp == SCRIPTA_BA(np, send_ident)) {\r\nif (cp->tag != NO_TAG && olen - rest <= 3) {\r\ncp->host_status = HS_BUSY;\r\nnp->msgout[0] = IDENTIFY(0, cp->lun);\r\nnxtdsp = SCRIPTB_BA(np, ident_break_atn);\r\n}\r\nelse\r\nnxtdsp = SCRIPTB_BA(np, ident_break);\r\n}\r\nelse if (dsp == SCRIPTB_BA(np, send_wdtr) ||\r\ndsp == SCRIPTB_BA(np, send_sdtr) ||\r\ndsp == SCRIPTB_BA(np, send_ppr)) {\r\nnxtdsp = SCRIPTB_BA(np, nego_bad_phase);\r\nif (dsp == SCRIPTB_BA(np, send_ppr)) {\r\nstruct scsi_device *dev = cp->cmd->device;\r\ndev->ppr = 0;\r\n}\r\n}\r\nbreak;\r\n#if 0\r\ncase 7:\r\nnxtdsp = SCRIPTA_BA(np, clrack);\r\nbreak;\r\n#endif\r\n}\r\nif (nxtdsp) {\r\nOUTL_DSP(np, nxtdsp);\r\nreturn;\r\n}\r\nreset_all:\r\nsym_start_reset(np);\r\n}\r\nirqreturn_t sym_interrupt(struct Scsi_Host *shost)\r\n{\r\nstruct sym_data *sym_data = shost_priv(shost);\r\nstruct sym_hcb *np = sym_data->ncb;\r\nstruct pci_dev *pdev = sym_data->pdev;\r\nu_char istat, istatc;\r\nu_char dstat;\r\nu_short sist;\r\nistat = INB(np, nc_istat);\r\nif (istat & INTF) {\r\nOUTB(np, nc_istat, (istat & SIGP) | INTF | np->istat_sem);\r\nistat |= INB(np, nc_istat);\r\nif (DEBUG_FLAGS & DEBUG_TINY) printf ("F ");\r\nsym_wakeup_done(np);\r\n}\r\nif (!(istat & (SIP|DIP)))\r\nreturn (istat & INTF) ? IRQ_HANDLED : IRQ_NONE;\r\n#if 0\r\nif (istat & CABRT)\r\nOUTB(np, nc_istat, CABRT);\r\n#endif\r\nsist = 0;\r\ndstat = 0;\r\nistatc = istat;\r\ndo {\r\nif (istatc & SIP)\r\nsist |= INW(np, nc_sist);\r\nif (istatc & DIP)\r\ndstat |= INB(np, nc_dstat);\r\nistatc = INB(np, nc_istat);\r\nistat |= istatc;\r\nif (unlikely(sist == 0xffff && dstat == 0xff)) {\r\nif (pci_channel_offline(pdev))\r\nreturn IRQ_NONE;\r\n}\r\n} while (istatc & (SIP|DIP));\r\nif (DEBUG_FLAGS & DEBUG_TINY)\r\nprintf ("<%d|%x:%x|%x:%x>",\r\n(int)INB(np, nc_scr0),\r\ndstat,sist,\r\n(unsigned)INL(np, nc_dsp),\r\n(unsigned)INL(np, nc_dbc));\r\nMEMORY_READ_BARRIER();\r\nif (!(sist & (STO|GEN|HTH|SGE|UDC|SBMC|RST)) &&\r\n!(dstat & (MDPE|BF|ABRT|IID))) {\r\nif (sist & PAR) sym_int_par (np, sist);\r\nelse if (sist & MA) sym_int_ma (np);\r\nelse if (dstat & SIR) sym_int_sir(np);\r\nelse if (dstat & SSI) OUTONB_STD();\r\nelse goto unknown_int;\r\nreturn IRQ_HANDLED;\r\n}\r\nif (sist & RST) {\r\nprintf("%s: SCSI BUS reset detected.\n", sym_name(np));\r\nsym_start_up(shost, 1);\r\nreturn IRQ_HANDLED;\r\n}\r\nOUTB(np, nc_ctest3, np->rv_ctest3 | CLF);\r\nOUTB(np, nc_stest3, TE|CSF);\r\nif (!(sist & (GEN|HTH|SGE)) &&\r\n!(dstat & (MDPE|BF|ABRT|IID))) {\r\nif (sist & SBMC) sym_int_sbmc(shost);\r\nelse if (sist & STO) sym_int_sto (np);\r\nelse if (sist & UDC) sym_int_udc (np);\r\nelse goto unknown_int;\r\nreturn IRQ_HANDLED;\r\n}\r\nsym_log_hard_error(shost, sist, dstat);\r\nif ((sist & (GEN|HTH|SGE)) ||\r\n(dstat & (MDPE|BF|ABRT|IID))) {\r\nsym_start_reset(np);\r\nreturn IRQ_HANDLED;\r\n}\r\nunknown_int:\r\nprintf( "%s: unknown interrupt(s) ignored, "\r\n"ISTAT=0x%x DSTAT=0x%x SIST=0x%x\n",\r\nsym_name(np), istat, dstat, sist);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int\r\nsym_dequeue_from_squeue(struct sym_hcb *np, int i, int target, int lun, int task)\r\n{\r\nint j;\r\nstruct sym_ccb *cp;\r\nassert((i >= 0) && (i < 2*MAX_QUEUE));\r\nj = i;\r\nwhile (i != np->squeueput) {\r\ncp = sym_ccb_from_dsa(np, scr_to_cpu(np->squeue[i]));\r\nassert(cp);\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\ncp->host_flags &= ~HF_HINT_IARB;\r\n#endif\r\nif ((target == -1 || cp->target == target) &&\r\n(lun == -1 || cp->lun == lun) &&\r\n(task == -1 || cp->tag == task)) {\r\nsym_set_cam_status(cp->cmd, DID_SOFT_ERROR);\r\nsym_remque(&cp->link_ccbq);\r\nsym_insque_tail(&cp->link_ccbq, &np->comp_ccbq);\r\n}\r\nelse {\r\nif (i != j)\r\nnp->squeue[j] = np->squeue[i];\r\nif ((j += 2) >= MAX_QUEUE*2) j = 0;\r\n}\r\nif ((i += 2) >= MAX_QUEUE*2) i = 0;\r\n}\r\nif (i != j)\r\nnp->squeue[j] = np->squeue[i];\r\nnp->squeueput = j;\r\nreturn (i - j) / 2;\r\n}\r\nstatic void sym_sir_bad_scsi_status(struct sym_hcb *np, int num, struct sym_ccb *cp)\r\n{\r\nu32 startp;\r\nu_char s_status = cp->ssss_status;\r\nu_char h_flags = cp->host_flags;\r\nint msglen;\r\nint i;\r\ni = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\nif (np->last_cp)\r\nnp->last_cp = 0;\r\n#endif\r\nswitch(s_status) {\r\ncase S_BUSY:\r\ncase S_QUEUE_FULL:\r\nif (sym_verbose >= 2) {\r\nsym_print_addr(cp->cmd, "%s\n",\r\ns_status == S_BUSY ? "BUSY" : "QUEUE FULL\n");\r\n}\r\ndefault:\r\nsym_complete_error (np, cp);\r\nbreak;\r\ncase S_TERMINATED:\r\ncase S_CHECK_COND:\r\nif (h_flags & HF_SENSE) {\r\nsym_complete_error (np, cp);\r\nbreak;\r\n}\r\nsym_dequeue_from_squeue(np, i, cp->target, cp->lun, -1);\r\nOUTL_DSP(np, SCRIPTA_BA(np, start));\r\ncp->sv_scsi_status = cp->ssss_status;\r\ncp->sv_xerr_status = cp->xerr_status;\r\ncp->sv_resid = sym_compute_residual(np, cp);\r\ncp->scsi_smsg2[0] = IDENTIFY(0, cp->lun);\r\nmsglen = 1;\r\ncp->nego_status = 0;\r\nmsglen += sym_prepare_nego(np, cp, &cp->scsi_smsg2[msglen]);\r\ncp->phys.smsg.addr = CCB_BA(cp, scsi_smsg2);\r\ncp->phys.smsg.size = cpu_to_scr(msglen);\r\ncp->phys.cmd.addr = CCB_BA(cp, sensecmd);\r\ncp->phys.cmd.size = cpu_to_scr(6);\r\ncp->sensecmd[0] = REQUEST_SENSE;\r\ncp->sensecmd[1] = 0;\r\nif (cp->cmd->device->scsi_level <= SCSI_2 && cp->lun <= 7)\r\ncp->sensecmd[1] = cp->lun << 5;\r\ncp->sensecmd[4] = SYM_SNS_BBUF_LEN;\r\ncp->data_len = SYM_SNS_BBUF_LEN;\r\nmemset(cp->sns_bbuf, 0, SYM_SNS_BBUF_LEN);\r\ncp->phys.sense.addr = CCB_BA(cp, sns_bbuf);\r\ncp->phys.sense.size = cpu_to_scr(SYM_SNS_BBUF_LEN);\r\nstartp = SCRIPTB_BA(np, sdata_in);\r\ncp->phys.head.savep = cpu_to_scr(startp);\r\ncp->phys.head.lastp = cpu_to_scr(startp);\r\ncp->startp = cpu_to_scr(startp);\r\ncp->goalp = cpu_to_scr(startp + 16);\r\ncp->host_xflags = 0;\r\ncp->host_status = cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\r\ncp->ssss_status = S_ILLEGAL;\r\ncp->host_flags = (HF_SENSE|HF_DATA_IN);\r\ncp->xerr_status = 0;\r\ncp->extra_bytes = 0;\r\ncp->phys.head.go.start = cpu_to_scr(SCRIPTA_BA(np, select));\r\nsym_put_start_queue(np, cp);\r\nsym_flush_comp_queue(np, 0);\r\nbreak;\r\n}\r\n}\r\nint sym_clear_tasks(struct sym_hcb *np, int cam_status, int target, int lun, int task)\r\n{\r\nSYM_QUEHEAD qtmp, *qp;\r\nint i = 0;\r\nstruct sym_ccb *cp;\r\nsym_que_init(&qtmp);\r\nsym_que_splice(&np->busy_ccbq, &qtmp);\r\nsym_que_init(&np->busy_ccbq);\r\nwhile ((qp = sym_remque_head(&qtmp)) != NULL) {\r\nstruct scsi_cmnd *cmd;\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\ncmd = cp->cmd;\r\nif (cp->host_status != HS_DISCONNECT ||\r\ncp->target != target ||\r\n(lun != -1 && cp->lun != lun) ||\r\n(task != -1 &&\r\n(cp->tag != NO_TAG && cp->scsi_smsg[2] != task))) {\r\nsym_insque_tail(&cp->link_ccbq, &np->busy_ccbq);\r\ncontinue;\r\n}\r\nsym_insque_tail(&cp->link_ccbq, &np->comp_ccbq);\r\nif (sym_get_cam_status(cmd) != DID_TIME_OUT)\r\nsym_set_cam_status(cmd, cam_status);\r\n++i;\r\n#if 0\r\nprintf("XXXX TASK @%p CLEARED\n", cp);\r\n#endif\r\n}\r\nreturn i;\r\n}\r\nstatic void sym_sir_task_recovery(struct sym_hcb *np, int num)\r\n{\r\nSYM_QUEHEAD *qp;\r\nstruct sym_ccb *cp;\r\nstruct sym_tcb *tp = NULL;\r\nstruct scsi_target *starget;\r\nint target=-1, lun=-1, task;\r\nint i, k;\r\nswitch(num) {\r\ncase SIR_SCRIPT_STOPPED:\r\nfor (i = 0 ; i < SYM_CONF_MAX_TARGET ; i++) {\r\ntp = &np->target[i];\r\nif (tp->to_reset ||\r\n(tp->lun0p && tp->lun0p->to_clear)) {\r\ntarget = i;\r\nbreak;\r\n}\r\nif (!tp->lunmp)\r\ncontinue;\r\nfor (k = 1 ; k < SYM_CONF_MAX_LUN ; k++) {\r\nif (tp->lunmp[k] && tp->lunmp[k]->to_clear) {\r\ntarget = i;\r\nbreak;\r\n}\r\n}\r\nif (target != -1)\r\nbreak;\r\n}\r\nif (target == -1) {\r\nFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\r\ncp = sym_que_entry(qp,struct sym_ccb,link_ccbq);\r\nif (cp->host_status != HS_DISCONNECT)\r\ncontinue;\r\nif (cp->to_abort) {\r\ntarget = cp->target;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (target != -1) {\r\ntp = &np->target[target];\r\nnp->abrt_sel.sel_id = target;\r\nnp->abrt_sel.sel_scntl3 = tp->head.wval;\r\nnp->abrt_sel.sel_sxfer = tp->head.sval;\r\nOUTL(np, nc_dsa, np->hcb_ba);\r\nOUTL_DSP(np, SCRIPTB_BA(np, sel_for_abort));\r\nreturn;\r\n}\r\ni = 0;\r\ncp = NULL;\r\nFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nif (cp->host_status != HS_BUSY &&\r\ncp->host_status != HS_NEGOTIATE)\r\ncontinue;\r\nif (!cp->to_abort)\r\ncontinue;\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\nif (cp == np->last_cp) {\r\ncp->to_abort = 0;\r\ncontinue;\r\n}\r\n#endif\r\ni = 1;\r\nbreak;\r\n}\r\nif (!i) {\r\nnp->istat_sem = 0;\r\nOUTB(np, nc_istat, SIGP);\r\nbreak;\r\n}\r\ni = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\r\ni = sym_dequeue_from_squeue(np, i, cp->target, cp->lun, -1);\r\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nassert(i && sym_get_cam_status(cp->cmd) == DID_SOFT_ERROR);\r\n#else\r\nsym_remque(&cp->link_ccbq);\r\nsym_insque_tail(&cp->link_ccbq, &np->comp_ccbq);\r\n#endif\r\nif (cp->to_abort == 2)\r\nsym_set_cam_status(cp->cmd, DID_TIME_OUT);\r\nelse\r\nsym_set_cam_status(cp->cmd, DID_ABORT);\r\nsym_flush_comp_queue(np, 0);\r\nbreak;\r\ncase SIR_TARGET_SELECTED:\r\ntarget = INB(np, nc_sdid) & 0xf;\r\ntp = &np->target[target];\r\nnp->abrt_tbl.addr = cpu_to_scr(vtobus(np->abrt_msg));\r\nif (tp->to_reset) {\r\nnp->abrt_msg[0] = M_RESET;\r\nnp->abrt_tbl.size = 1;\r\ntp->to_reset = 0;\r\nbreak;\r\n}\r\nif (tp->lun0p && tp->lun0p->to_clear)\r\nlun = 0;\r\nelse if (tp->lunmp) {\r\nfor (k = 1 ; k < SYM_CONF_MAX_LUN ; k++) {\r\nif (tp->lunmp[k] && tp->lunmp[k]->to_clear) {\r\nlun = k;\r\nbreak;\r\n}\r\n}\r\n}\r\nif (lun != -1) {\r\nstruct sym_lcb *lp = sym_lp(tp, lun);\r\nlp->to_clear = 0;\r\nnp->abrt_msg[0] = IDENTIFY(0, lun);\r\nnp->abrt_msg[1] = M_ABORT;\r\nnp->abrt_tbl.size = 2;\r\nbreak;\r\n}\r\ni = 0;\r\ncp = NULL;\r\nFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nif (cp->host_status != HS_DISCONNECT)\r\ncontinue;\r\nif (cp->target != target)\r\ncontinue;\r\nif (!cp->to_abort)\r\ncontinue;\r\ni = 1;\r\nbreak;\r\n}\r\nif (!i) {\r\nnp->abrt_msg[0] = M_ABORT;\r\nnp->abrt_tbl.size = 1;\r\nbreak;\r\n}\r\nnp->abrt_msg[0] = IDENTIFY(0, cp->lun);\r\nif (cp->tag == NO_TAG) {\r\nnp->abrt_msg[1] = M_ABORT;\r\nnp->abrt_tbl.size = 2;\r\n} else {\r\nnp->abrt_msg[1] = cp->scsi_smsg[1];\r\nnp->abrt_msg[2] = cp->scsi_smsg[2];\r\nnp->abrt_msg[3] = M_ABORT_TAG;\r\nnp->abrt_tbl.size = 4;\r\n}\r\nif (cp->to_abort == 2)\r\nsym_set_cam_status(cp->cmd, DID_TIME_OUT);\r\ncp->to_abort = 0;\r\nbreak;\r\ncase SIR_ABORT_SENT:\r\ntarget = INB(np, nc_sdid) & 0xf;\r\ntp = &np->target[target];\r\nstarget = tp->starget;\r\nif (np->abrt_msg[0] == M_ABORT)\r\nbreak;\r\nlun = -1;\r\ntask = -1;\r\nif (np->abrt_msg[0] == M_RESET) {\r\ntp->head.sval = 0;\r\ntp->head.wval = np->rv_scntl3;\r\ntp->head.uval = 0;\r\nspi_period(starget) = 0;\r\nspi_offset(starget) = 0;\r\nspi_width(starget) = 0;\r\nspi_iu(starget) = 0;\r\nspi_dt(starget) = 0;\r\nspi_qas(starget) = 0;\r\ntp->tgoal.check_nego = 1;\r\ntp->tgoal.renego = 0;\r\n}\r\nelse {\r\nlun = np->abrt_msg[0] & 0x3f;\r\nif (np->abrt_msg[1] == M_ABORT_TAG)\r\ntask = np->abrt_msg[2];\r\n}\r\ni = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\r\nsym_dequeue_from_squeue(np, i, target, lun, -1);\r\nsym_clear_tasks(np, DID_ABORT, target, lun, task);\r\nsym_flush_comp_queue(np, 0);\r\nif (np->abrt_msg[0] == M_RESET)\r\nstarget_printk(KERN_NOTICE, starget,\r\n"has been reset\n");\r\nbreak;\r\n}\r\nif (num == SIR_TARGET_SELECTED) {\r\ndev_info(&tp->starget->dev, "control msgout:");\r\nsym_printl_hex(np->abrt_msg, np->abrt_tbl.size);\r\nnp->abrt_tbl.size = cpu_to_scr(np->abrt_tbl.size);\r\n}\r\nOUTONB_STD();\r\n}\r\nstatic int sym_evaluate_dp(struct sym_hcb *np, struct sym_ccb *cp, u32 scr, int *ofs)\r\n{\r\nu32 dp_scr;\r\nint dp_ofs, dp_sg, dp_sgmin;\r\nint tmp;\r\nstruct sym_pmc *pm;\r\ndp_scr = scr;\r\ndp_ofs = *ofs;\r\nif (dp_scr == SCRIPTA_BA(np, pm0_data))\r\npm = &cp->phys.pm0;\r\nelse if (dp_scr == SCRIPTA_BA(np, pm1_data))\r\npm = &cp->phys.pm1;\r\nelse\r\npm = NULL;\r\nif (pm) {\r\ndp_scr = scr_to_cpu(pm->ret);\r\ndp_ofs -= scr_to_cpu(pm->sg.size) & 0x00ffffff;\r\n}\r\nif (cp->host_flags & HF_SENSE) {\r\n*ofs = dp_ofs;\r\nreturn 0;\r\n}\r\ntmp = scr_to_cpu(cp->goalp);\r\ndp_sg = SYM_CONF_MAX_SG;\r\nif (dp_scr != tmp)\r\ndp_sg -= (tmp - 8 - (int)dp_scr) / (2*4);\r\ndp_sgmin = SYM_CONF_MAX_SG - cp->segments;\r\nif (dp_ofs < 0) {\r\nint n;\r\nwhile (dp_sg > dp_sgmin) {\r\n--dp_sg;\r\ntmp = scr_to_cpu(cp->phys.data[dp_sg].size);\r\nn = dp_ofs + (tmp & 0xffffff);\r\nif (n > 0) {\r\n++dp_sg;\r\nbreak;\r\n}\r\ndp_ofs = n;\r\n}\r\n}\r\nelse if (dp_ofs > 0) {\r\nwhile (dp_sg < SYM_CONF_MAX_SG) {\r\ntmp = scr_to_cpu(cp->phys.data[dp_sg].size);\r\ndp_ofs -= (tmp & 0xffffff);\r\n++dp_sg;\r\nif (dp_ofs <= 0)\r\nbreak;\r\n}\r\n}\r\nif (dp_sg < dp_sgmin || (dp_sg == dp_sgmin && dp_ofs < 0))\r\ngoto out_err;\r\nelse if (dp_sg > SYM_CONF_MAX_SG ||\r\n(dp_sg == SYM_CONF_MAX_SG && dp_ofs > 0))\r\ngoto out_err;\r\nif (dp_sg > cp->ext_sg ||\r\n(dp_sg == cp->ext_sg && dp_ofs > cp->ext_ofs)) {\r\ncp->ext_sg = dp_sg;\r\ncp->ext_ofs = dp_ofs;\r\n}\r\n*ofs = dp_ofs;\r\nreturn dp_sg;\r\nout_err:\r\nreturn -1;\r\n}\r\nstatic void sym_modify_dp(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp, int ofs)\r\n{\r\nint dp_ofs = ofs;\r\nu32 dp_scr = sym_get_script_dp (np, cp);\r\nu32 dp_ret;\r\nu32 tmp;\r\nu_char hflags;\r\nint dp_sg;\r\nstruct sym_pmc *pm;\r\nif (cp->host_flags & HF_SENSE)\r\ngoto out_reject;\r\ndp_sg = sym_evaluate_dp(np, cp, dp_scr, &dp_ofs);\r\nif (dp_sg < 0)\r\ngoto out_reject;\r\ndp_ret = cpu_to_scr(cp->goalp);\r\ndp_ret = dp_ret - 8 - (SYM_CONF_MAX_SG - dp_sg) * (2*4);\r\nif (dp_ofs == 0) {\r\ndp_scr = dp_ret;\r\ngoto out_ok;\r\n}\r\nhflags = INB(np, HF_PRT);\r\nif (hflags & HF_DP_SAVED)\r\nhflags ^= HF_ACT_PM;\r\nif (!(hflags & HF_ACT_PM)) {\r\npm = &cp->phys.pm0;\r\ndp_scr = SCRIPTA_BA(np, pm0_data);\r\n}\r\nelse {\r\npm = &cp->phys.pm1;\r\ndp_scr = SCRIPTA_BA(np, pm1_data);\r\n}\r\nhflags &= ~(HF_DP_SAVED);\r\nOUTB(np, HF_PRT, hflags);\r\npm->ret = cpu_to_scr(dp_ret);\r\ntmp = scr_to_cpu(cp->phys.data[dp_sg-1].addr);\r\ntmp += scr_to_cpu(cp->phys.data[dp_sg-1].size) + dp_ofs;\r\npm->sg.addr = cpu_to_scr(tmp);\r\npm->sg.size = cpu_to_scr(-dp_ofs);\r\nout_ok:\r\nsym_set_script_dp (np, cp, dp_scr);\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\nreturn;\r\nout_reject:\r\nOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\r\n}\r\nint sym_compute_residual(struct sym_hcb *np, struct sym_ccb *cp)\r\n{\r\nint dp_sg, dp_sgmin, resid = 0;\r\nint dp_ofs = 0;\r\nif (cp->xerr_status & (XE_EXTRA_DATA|XE_SODL_UNRUN|XE_SWIDE_OVRUN)) {\r\nif (cp->xerr_status & XE_EXTRA_DATA)\r\nresid -= cp->extra_bytes;\r\nif (cp->xerr_status & XE_SODL_UNRUN)\r\n++resid;\r\nif (cp->xerr_status & XE_SWIDE_OVRUN)\r\n--resid;\r\n}\r\nif (cp->phys.head.lastp == cp->goalp)\r\nreturn resid;\r\nif (cp->startp == cp->phys.head.lastp ||\r\nsym_evaluate_dp(np, cp, scr_to_cpu(cp->phys.head.lastp),\r\n&dp_ofs) < 0) {\r\nreturn cp->data_len - cp->odd_byte_adjustment;\r\n}\r\nif (cp->host_flags & HF_SENSE) {\r\nreturn -dp_ofs;\r\n}\r\ndp_sgmin = SYM_CONF_MAX_SG - cp->segments;\r\nresid = -cp->ext_ofs;\r\nfor (dp_sg = cp->ext_sg; dp_sg < SYM_CONF_MAX_SG; ++dp_sg) {\r\nu_int tmp = scr_to_cpu(cp->phys.data[dp_sg].size);\r\nresid += (tmp & 0xffffff);\r\n}\r\nresid -= cp->odd_byte_adjustment;\r\nreturn resid;\r\n}\r\nstatic int\r\nsym_sync_nego_check(struct sym_hcb *np, int req, struct sym_ccb *cp)\r\n{\r\nint target = cp->target;\r\nu_char chg, ofs, per, fak, div;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, target, "sync msgin", np->msgin);\r\n}\r\nchg = 0;\r\nper = np->msgin[3];\r\nofs = np->msgin[4];\r\nif (ofs) {\r\nif (ofs > np->maxoffs)\r\n{chg = 1; ofs = np->maxoffs;}\r\n}\r\nif (ofs) {\r\nif (per < np->minsync)\r\n{chg = 1; per = np->minsync;}\r\n}\r\ndiv = fak = 0;\r\nif (ofs && sym_getsync(np, 0, per, &div, &fak) < 0)\r\ngoto reject_it;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_addr(cp->cmd,\r\n"sdtr: ofs=%d per=%d div=%d fak=%d chg=%d.\n",\r\nofs, per, div, fak, chg);\r\n}\r\nif (!req && chg)\r\ngoto reject_it;\r\nsym_setsync (np, target, ofs, per, div, fak);\r\nif (!req)\r\nreturn 0;\r\nspi_populate_sync_msg(np->msgout, per, ofs);\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, target, "sync msgout", np->msgout);\r\n}\r\nnp->msgin [0] = M_NOOP;\r\nreturn 0;\r\nreject_it:\r\nsym_setsync (np, target, 0, 0, 0, 0);\r\nreturn -1;\r\n}\r\nstatic void sym_sync_nego(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\r\n{\r\nint req = 1;\r\nint result;\r\nif (INB(np, HS_PRT) == HS_NEGOTIATE) {\r\nOUTB(np, HS_PRT, HS_BUSY);\r\nif (cp->nego_status && cp->nego_status != NS_SYNC)\r\ngoto reject_it;\r\nreq = 0;\r\n}\r\nresult = sym_sync_nego_check(np, req, cp);\r\nif (result)\r\ngoto reject_it;\r\nif (req) {\r\ncp->nego_status = NS_SYNC;\r\nOUTL_DSP(np, SCRIPTB_BA(np, sdtr_resp));\r\n}\r\nelse\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\nreturn;\r\nreject_it:\r\nOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\r\n}\r\nstatic int\r\nsym_ppr_nego_check(struct sym_hcb *np, int req, int target)\r\n{\r\nstruct sym_tcb *tp = &np->target[target];\r\nunsigned char fak, div;\r\nint dt, chg = 0;\r\nunsigned char per = np->msgin[3];\r\nunsigned char ofs = np->msgin[5];\r\nunsigned char wide = np->msgin[6];\r\nunsigned char opts = np->msgin[7] & PPR_OPT_MASK;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, target, "ppr msgin", np->msgin);\r\n}\r\nif (wide > np->maxwide) {\r\nchg = 1;\r\nwide = np->maxwide;\r\n}\r\nif (!wide || !(np->features & FE_U3EN))\r\nopts = 0;\r\nif (opts != (np->msgin[7] & PPR_OPT_MASK))\r\nchg = 1;\r\ndt = opts & PPR_OPT_DT;\r\nif (ofs) {\r\nunsigned char maxoffs = dt ? np->maxoffs_dt : np->maxoffs;\r\nif (ofs > maxoffs) {\r\nchg = 1;\r\nofs = maxoffs;\r\n}\r\n}\r\nif (ofs) {\r\nunsigned char minsync = dt ? np->minsync_dt : np->minsync;\r\nif (per < minsync) {\r\nchg = 1;\r\nper = minsync;\r\n}\r\n}\r\ndiv = fak = 0;\r\nif (ofs && sym_getsync(np, dt, per, &div, &fak) < 0)\r\ngoto reject_it;\r\nif (!req && chg)\r\ngoto reject_it;\r\nsym_setpprot(np, target, opts, ofs, per, wide, div, fak);\r\nif (!req)\r\nreturn 0;\r\nspi_populate_ppr_msg(np->msgout, per, ofs, wide, opts);\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, target, "ppr msgout", np->msgout);\r\n}\r\nnp->msgin [0] = M_NOOP;\r\nreturn 0;\r\nreject_it:\r\nsym_setpprot (np, target, 0, 0, 0, 0, 0, 0);\r\nif (!req && !opts) {\r\ntp->tgoal.period = per;\r\ntp->tgoal.offset = ofs;\r\ntp->tgoal.width = wide;\r\ntp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\r\ntp->tgoal.check_nego = 1;\r\n}\r\nreturn -1;\r\n}\r\nstatic void sym_ppr_nego(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\r\n{\r\nint req = 1;\r\nint result;\r\nif (INB(np, HS_PRT) == HS_NEGOTIATE) {\r\nOUTB(np, HS_PRT, HS_BUSY);\r\nif (cp->nego_status && cp->nego_status != NS_PPR)\r\ngoto reject_it;\r\nreq = 0;\r\n}\r\nresult = sym_ppr_nego_check(np, req, cp->target);\r\nif (result)\r\ngoto reject_it;\r\nif (req) {\r\ncp->nego_status = NS_PPR;\r\nOUTL_DSP(np, SCRIPTB_BA(np, ppr_resp));\r\n}\r\nelse\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\nreturn;\r\nreject_it:\r\nOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\r\n}\r\nstatic int\r\nsym_wide_nego_check(struct sym_hcb *np, int req, struct sym_ccb *cp)\r\n{\r\nint target = cp->target;\r\nu_char chg, wide;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, target, "wide msgin", np->msgin);\r\n}\r\nchg = 0;\r\nwide = np->msgin[3];\r\nif (wide > np->maxwide) {\r\nchg = 1;\r\nwide = np->maxwide;\r\n}\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_addr(cp->cmd, "wdtr: wide=%d chg=%d.\n",\r\nwide, chg);\r\n}\r\nif (!req && chg)\r\ngoto reject_it;\r\nsym_setwide (np, target, wide);\r\nif (!req)\r\nreturn 0;\r\nspi_populate_width_msg(np->msgout, wide);\r\nnp->msgin [0] = M_NOOP;\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, target, "wide msgout", np->msgout);\r\n}\r\nreturn 0;\r\nreject_it:\r\nreturn -1;\r\n}\r\nstatic void sym_wide_nego(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\r\n{\r\nint req = 1;\r\nint result;\r\nif (INB(np, HS_PRT) == HS_NEGOTIATE) {\r\nOUTB(np, HS_PRT, HS_BUSY);\r\nif (cp->nego_status && cp->nego_status != NS_WIDE)\r\ngoto reject_it;\r\nreq = 0;\r\n}\r\nresult = sym_wide_nego_check(np, req, cp);\r\nif (result)\r\ngoto reject_it;\r\nif (req) {\r\ncp->nego_status = NS_WIDE;\r\nOUTL_DSP(np, SCRIPTB_BA(np, wdtr_resp));\r\n} else {\r\nif (tp->tgoal.offset) {\r\nspi_populate_sync_msg(np->msgout, tp->tgoal.period,\r\ntp->tgoal.offset);\r\nif (DEBUG_FLAGS & DEBUG_NEGO) {\r\nsym_print_nego_msg(np, cp->target,\r\n"sync msgout", np->msgout);\r\n}\r\ncp->nego_status = NS_SYNC;\r\nOUTB(np, HS_PRT, HS_NEGOTIATE);\r\nOUTL_DSP(np, SCRIPTB_BA(np, sdtr_resp));\r\nreturn;\r\n} else\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\n}\r\nreturn;\r\nreject_it:\r\nOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\r\n}\r\nstatic void sym_nego_default(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\r\n{\r\nswitch (cp->nego_status) {\r\ncase NS_PPR:\r\n#if 0\r\nsym_setpprot (np, cp->target, 0, 0, 0, 0, 0, 0);\r\n#else\r\nif (tp->tgoal.period < np->minsync)\r\ntp->tgoal.period = np->minsync;\r\nif (tp->tgoal.offset > np->maxoffs)\r\ntp->tgoal.offset = np->maxoffs;\r\ntp->tgoal.iu = tp->tgoal.dt = tp->tgoal.qas = 0;\r\ntp->tgoal.check_nego = 1;\r\n#endif\r\nbreak;\r\ncase NS_SYNC:\r\nsym_setsync (np, cp->target, 0, 0, 0, 0);\r\nbreak;\r\ncase NS_WIDE:\r\nsym_setwide (np, cp->target, 0);\r\nbreak;\r\n}\r\nnp->msgin [0] = M_NOOP;\r\nnp->msgout[0] = M_NOOP;\r\ncp->nego_status = 0;\r\n}\r\nstatic void sym_nego_rejected(struct sym_hcb *np, struct sym_tcb *tp, struct sym_ccb *cp)\r\n{\r\nsym_nego_default(np, tp, cp);\r\nOUTB(np, HS_PRT, HS_BUSY);\r\n}\r\nstatic void sym_int_sir(struct sym_hcb *np)\r\n{\r\nu_char num = INB(np, nc_dsps);\r\nu32 dsa = INL(np, nc_dsa);\r\nstruct sym_ccb *cp = sym_ccb_from_dsa(np, dsa);\r\nu_char target = INB(np, nc_sdid) & 0x0f;\r\nstruct sym_tcb *tp = &np->target[target];\r\nint tmp;\r\nif (DEBUG_FLAGS & DEBUG_TINY) printf ("I#%d", num);\r\nswitch (num) {\r\n#if SYM_CONF_DMA_ADDRESSING_MODE == 2\r\ncase SIR_DMAP_DIRTY:\r\nsym_update_dmap_regs(np);\r\ngoto out;\r\n#endif\r\ncase SIR_COMPLETE_ERROR:\r\nsym_complete_error(np, cp);\r\nreturn;\r\ncase SIR_SCRIPT_STOPPED:\r\ncase SIR_TARGET_SELECTED:\r\ncase SIR_ABORT_SENT:\r\nsym_sir_task_recovery(np, num);\r\nreturn;\r\ncase SIR_SEL_ATN_NO_MSG_OUT:\r\nscmd_printk(KERN_WARNING, cp->cmd,\r\n"No MSG OUT phase after selection with ATN\n");\r\ngoto out_stuck;\r\ncase SIR_RESEL_NO_MSG_IN:\r\nscmd_printk(KERN_WARNING, cp->cmd,\r\n"No MSG IN phase after reselection\n");\r\ngoto out_stuck;\r\ncase SIR_RESEL_NO_IDENTIFY:\r\nscmd_printk(KERN_WARNING, cp->cmd,\r\n"No IDENTIFY after reselection\n");\r\ngoto out_stuck;\r\ncase SIR_RESEL_BAD_LUN:\r\nnp->msgout[0] = M_RESET;\r\ngoto out;\r\ncase SIR_RESEL_BAD_I_T_L:\r\nnp->msgout[0] = M_ABORT;\r\ngoto out;\r\ncase SIR_RESEL_BAD_I_T_L_Q:\r\nnp->msgout[0] = M_ABORT_TAG;\r\ngoto out;\r\ncase SIR_RESEL_ABORTED:\r\nnp->lastmsg = np->msgout[0];\r\nnp->msgout[0] = M_NOOP;\r\nscmd_printk(KERN_WARNING, cp->cmd,\r\n"message %x sent on bad reselection\n", np->lastmsg);\r\ngoto out;\r\ncase SIR_MSG_OUT_DONE:\r\nnp->lastmsg = np->msgout[0];\r\nnp->msgout[0] = M_NOOP;\r\nif (np->lastmsg == M_PARITY || np->lastmsg == M_ID_ERROR) {\r\nif (cp) {\r\ncp->xerr_status &= ~XE_PARITY_ERR;\r\nif (!cp->xerr_status)\r\nOUTOFFB(np, HF_PRT, HF_EXT_ERR);\r\n}\r\n}\r\ngoto out;\r\ncase SIR_BAD_SCSI_STATUS:\r\nif (!cp)\r\ngoto out;\r\nsym_sir_bad_scsi_status(np, num, cp);\r\nreturn;\r\ncase SIR_REJECT_TO_SEND:\r\nsym_print_msg(cp, "M_REJECT to send for ", np->msgin);\r\nnp->msgout[0] = M_REJECT;\r\ngoto out;\r\ncase SIR_SWIDE_OVERRUN:\r\nif (cp) {\r\nOUTONB(np, HF_PRT, HF_EXT_ERR);\r\ncp->xerr_status |= XE_SWIDE_OVRUN;\r\n}\r\ngoto out;\r\ncase SIR_SODL_UNDERRUN:\r\nif (cp) {\r\nOUTONB(np, HF_PRT, HF_EXT_ERR);\r\ncp->xerr_status |= XE_SODL_UNRUN;\r\n}\r\ngoto out;\r\ncase SIR_DATA_OVERRUN:\r\nif (cp) {\r\nOUTONB(np, HF_PRT, HF_EXT_ERR);\r\ncp->xerr_status |= XE_EXTRA_DATA;\r\ncp->extra_bytes += INL(np, nc_scratcha);\r\n}\r\ngoto out;\r\ncase SIR_BAD_PHASE:\r\nif (cp) {\r\nOUTONB(np, HF_PRT, HF_EXT_ERR);\r\ncp->xerr_status |= XE_BAD_PHASE;\r\n}\r\ngoto out;\r\ncase SIR_MSG_RECEIVED:\r\nif (!cp)\r\ngoto out_stuck;\r\nswitch (np->msgin [0]) {\r\ncase M_EXTENDED:\r\nswitch (np->msgin [2]) {\r\ncase M_X_MODIFY_DP:\r\nif (DEBUG_FLAGS & DEBUG_POINTER)\r\nsym_print_msg(cp, "extended msg ",\r\nnp->msgin);\r\ntmp = (np->msgin[3]<<24) + (np->msgin[4]<<16) +\r\n(np->msgin[5]<<8) + (np->msgin[6]);\r\nsym_modify_dp(np, tp, cp, tmp);\r\nreturn;\r\ncase M_X_SYNC_REQ:\r\nsym_sync_nego(np, tp, cp);\r\nreturn;\r\ncase M_X_PPR_REQ:\r\nsym_ppr_nego(np, tp, cp);\r\nreturn;\r\ncase M_X_WIDE_REQ:\r\nsym_wide_nego(np, tp, cp);\r\nreturn;\r\ndefault:\r\ngoto out_reject;\r\n}\r\nbreak;\r\ncase M_IGN_RESIDUE:\r\nif (DEBUG_FLAGS & DEBUG_POINTER)\r\nsym_print_msg(cp, "1 or 2 byte ", np->msgin);\r\nif (cp->host_flags & HF_SENSE)\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\nelse\r\nsym_modify_dp(np, tp, cp, -1);\r\nreturn;\r\ncase M_REJECT:\r\nif (INB(np, HS_PRT) == HS_NEGOTIATE)\r\nsym_nego_rejected(np, tp, cp);\r\nelse {\r\nsym_print_addr(cp->cmd,\r\n"M_REJECT received (%x:%x).\n",\r\nscr_to_cpu(np->lastmsg), np->msgout[0]);\r\n}\r\ngoto out_clrack;\r\nbreak;\r\ndefault:\r\ngoto out_reject;\r\n}\r\nbreak;\r\ncase SIR_MSG_WEIRD:\r\nsym_print_msg(cp, "WEIRD message received", np->msgin);\r\nOUTL_DSP(np, SCRIPTB_BA(np, msg_weird));\r\nreturn;\r\ncase SIR_NEGO_FAILED:\r\nOUTB(np, HS_PRT, HS_BUSY);\r\ncase SIR_NEGO_PROTO:\r\nsym_nego_default(np, tp, cp);\r\ngoto out;\r\n}\r\nout:\r\nOUTONB_STD();\r\nreturn;\r\nout_reject:\r\nOUTL_DSP(np, SCRIPTB_BA(np, msg_bad));\r\nreturn;\r\nout_clrack:\r\nOUTL_DSP(np, SCRIPTA_BA(np, clrack));\r\nreturn;\r\nout_stuck:\r\nreturn;\r\n}\r\nstruct sym_ccb *sym_get_ccb (struct sym_hcb *np, struct scsi_cmnd *cmd, u_char tag_order)\r\n{\r\nu_char tn = cmd->device->id;\r\nu_char ln = cmd->device->lun;\r\nstruct sym_tcb *tp = &np->target[tn];\r\nstruct sym_lcb *lp = sym_lp(tp, ln);\r\nu_short tag = NO_TAG;\r\nSYM_QUEHEAD *qp;\r\nstruct sym_ccb *cp = NULL;\r\nif (sym_que_empty(&np->free_ccbq))\r\nsym_alloc_ccb(np);\r\nqp = sym_remque_head(&np->free_ccbq);\r\nif (!qp)\r\ngoto out;\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\n{\r\nif (tag_order) {\r\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (lp->busy_itl != 0)\r\ngoto out_free;\r\n#endif\r\nif (!lp->cb_tags) {\r\nsym_alloc_lcb_tags(np, tn, ln);\r\nif (!lp->cb_tags)\r\ngoto out_free;\r\n}\r\nif (lp->busy_itlq < SYM_CONF_MAX_TASK) {\r\ntag = lp->cb_tags[lp->ia_tag];\r\nif (++lp->ia_tag == SYM_CONF_MAX_TASK)\r\nlp->ia_tag = 0;\r\n++lp->busy_itlq;\r\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nlp->itlq_tbl[tag] = cpu_to_scr(cp->ccb_ba);\r\nlp->head.resel_sa =\r\ncpu_to_scr(SCRIPTA_BA(np, resel_tag));\r\n#endif\r\n#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING\r\ncp->tags_si = lp->tags_si;\r\n++lp->tags_sum[cp->tags_si];\r\n++lp->tags_since;\r\n#endif\r\n}\r\nelse\r\ngoto out_free;\r\n}\r\nelse {\r\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (lp->busy_itl != 0 || lp->busy_itlq != 0)\r\ngoto out_free;\r\n#endif\r\n++lp->busy_itl;\r\n#ifndef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (lp->busy_itl == 1) {\r\nlp->head.itl_task_sa = cpu_to_scr(cp->ccb_ba);\r\nlp->head.resel_sa =\r\ncpu_to_scr(SCRIPTA_BA(np, resel_no_tag));\r\n}\r\nelse\r\ngoto out_free;\r\n#endif\r\n}\r\n}\r\nsym_insque_tail(&cp->link_ccbq, &np->busy_ccbq);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (lp) {\r\nsym_remque(&cp->link2_ccbq);\r\nsym_insque_tail(&cp->link2_ccbq, &lp->waiting_ccbq);\r\n}\r\n#endif\r\ncp->to_abort = 0;\r\ncp->odd_byte_adjustment = 0;\r\ncp->tag = tag;\r\ncp->order = tag_order;\r\ncp->target = tn;\r\ncp->lun = ln;\r\nif (DEBUG_FLAGS & DEBUG_TAGS) {\r\nsym_print_addr(cmd, "ccb @%p using tag %d.\n", cp, tag);\r\n}\r\nout:\r\nreturn cp;\r\nout_free:\r\nsym_insque_head(&cp->link_ccbq, &np->free_ccbq);\r\nreturn NULL;\r\n}\r\nvoid sym_free_ccb (struct sym_hcb *np, struct sym_ccb *cp)\r\n{\r\nstruct sym_tcb *tp = &np->target[cp->target];\r\nstruct sym_lcb *lp = sym_lp(tp, cp->lun);\r\nif (DEBUG_FLAGS & DEBUG_TAGS) {\r\nsym_print_addr(cp->cmd, "ccb @%p freeing tag %d.\n",\r\ncp, cp->tag);\r\n}\r\nif (lp) {\r\nif (cp->tag != NO_TAG) {\r\n#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING\r\n--lp->tags_sum[cp->tags_si];\r\n#endif\r\nlp->cb_tags[lp->if_tag] = cp->tag;\r\nif (++lp->if_tag == SYM_CONF_MAX_TASK)\r\nlp->if_tag = 0;\r\nlp->itlq_tbl[cp->tag] = cpu_to_scr(np->bad_itlq_ba);\r\n--lp->busy_itlq;\r\n} else {\r\nlp->head.itl_task_sa = cpu_to_scr(np->bad_itl_ba);\r\n--lp->busy_itl;\r\n}\r\nif (lp->busy_itlq == 0 && lp->busy_itl == 0)\r\nlp->head.resel_sa =\r\ncpu_to_scr(SCRIPTB_BA(np, resel_bad_lun));\r\n}\r\nif (cp == tp->nego_cp)\r\ntp->nego_cp = NULL;\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\nif (cp == np->last_cp)\r\nnp->last_cp = 0;\r\n#endif\r\ncp->cmd = NULL;\r\ncp->host_status = HS_IDLE;\r\nsym_remque(&cp->link_ccbq);\r\nsym_insque_head(&cp->link_ccbq, &np->free_ccbq);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (lp) {\r\nsym_remque(&cp->link2_ccbq);\r\nsym_insque_tail(&cp->link2_ccbq, &np->dummy_ccbq);\r\nif (cp->started) {\r\nif (cp->tag != NO_TAG)\r\n--lp->started_tags;\r\nelse\r\n--lp->started_no_tag;\r\n}\r\n}\r\ncp->started = 0;\r\n#endif\r\n}\r\nstatic struct sym_ccb *sym_alloc_ccb(struct sym_hcb *np)\r\n{\r\nstruct sym_ccb *cp = NULL;\r\nint hcode;\r\nif (np->actccbs >= SYM_CONF_MAX_START)\r\nreturn NULL;\r\ncp = sym_calloc_dma(sizeof(struct sym_ccb), "CCB");\r\nif (!cp)\r\ngoto out_free;\r\nnp->actccbs++;\r\ncp->ccb_ba = vtobus(cp);\r\nhcode = CCB_HASH_CODE(cp->ccb_ba);\r\ncp->link_ccbh = np->ccbh[hcode];\r\nnp->ccbh[hcode] = cp;\r\ncp->phys.head.go.start = cpu_to_scr(SCRIPTA_BA(np, idle));\r\ncp->phys.head.go.restart = cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\r\ncp->phys.smsg_ext.addr = cpu_to_scr(HCB_BA(np, msgin[2]));\r\nsym_insque_head(&cp->link_ccbq, &np->free_ccbq);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nsym_insque_head(&cp->link2_ccbq, &np->dummy_ccbq);\r\n#endif\r\nreturn cp;\r\nout_free:\r\nif (cp)\r\nsym_mfree_dma(cp, sizeof(*cp), "CCB");\r\nreturn NULL;\r\n}\r\nstatic struct sym_ccb *sym_ccb_from_dsa(struct sym_hcb *np, u32 dsa)\r\n{\r\nint hcode;\r\nstruct sym_ccb *cp;\r\nhcode = CCB_HASH_CODE(dsa);\r\ncp = np->ccbh[hcode];\r\nwhile (cp) {\r\nif (cp->ccb_ba == dsa)\r\nbreak;\r\ncp = cp->link_ccbh;\r\n}\r\nreturn cp;\r\n}\r\nstatic void sym_init_tcb (struct sym_hcb *np, u_char tn)\r\n{\r\n#if 0\r\nassert (((offsetof(struct sym_reg, nc_sxfer) ^\r\noffsetof(struct sym_tcb, head.sval)) &3) == 0);\r\nassert (((offsetof(struct sym_reg, nc_scntl3) ^\r\noffsetof(struct sym_tcb, head.wval)) &3) == 0);\r\n#endif\r\n}\r\nstruct sym_lcb *sym_alloc_lcb (struct sym_hcb *np, u_char tn, u_char ln)\r\n{\r\nstruct sym_tcb *tp = &np->target[tn];\r\nstruct sym_lcb *lp = NULL;\r\nsym_init_tcb (np, tn);\r\nif (ln && !tp->luntbl) {\r\nint i;\r\ntp->luntbl = sym_calloc_dma(256, "LUNTBL");\r\nif (!tp->luntbl)\r\ngoto fail;\r\nfor (i = 0 ; i < 64 ; i++)\r\ntp->luntbl[i] = cpu_to_scr(vtobus(&np->badlun_sa));\r\ntp->head.luntbl_sa = cpu_to_scr(vtobus(tp->luntbl));\r\n}\r\nif (ln && !tp->lunmp) {\r\ntp->lunmp = kcalloc(SYM_CONF_MAX_LUN, sizeof(struct sym_lcb *),\r\nGFP_ATOMIC);\r\nif (!tp->lunmp)\r\ngoto fail;\r\n}\r\nlp = sym_calloc_dma(sizeof(struct sym_lcb), "LCB");\r\nif (!lp)\r\ngoto fail;\r\nif (ln) {\r\ntp->lunmp[ln] = lp;\r\ntp->luntbl[ln] = cpu_to_scr(vtobus(lp));\r\n}\r\nelse {\r\ntp->lun0p = lp;\r\ntp->head.lun0_sa = cpu_to_scr(vtobus(lp));\r\n}\r\ntp->nlcb++;\r\nlp->head.itl_task_sa = cpu_to_scr(np->bad_itl_ba);\r\nlp->head.resel_sa = cpu_to_scr(SCRIPTB_BA(np, resel_bad_lun));\r\nlp->user_flags = tp->usrflags & (SYM_DISC_ENABLED | SYM_TAGS_ENABLED);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nsym_que_init(&lp->waiting_ccbq);\r\nsym_que_init(&lp->started_ccbq);\r\nlp->started_max = SYM_CONF_MAX_TASK;\r\nlp->started_limit = SYM_CONF_MAX_TASK;\r\n#endif\r\nfail:\r\nreturn lp;\r\n}\r\nstatic void sym_alloc_lcb_tags (struct sym_hcb *np, u_char tn, u_char ln)\r\n{\r\nstruct sym_tcb *tp = &np->target[tn];\r\nstruct sym_lcb *lp = sym_lp(tp, ln);\r\nint i;\r\nlp->itlq_tbl = sym_calloc_dma(SYM_CONF_MAX_TASK*4, "ITLQ_TBL");\r\nif (!lp->itlq_tbl)\r\ngoto fail;\r\nlp->cb_tags = kcalloc(SYM_CONF_MAX_TASK, 1, GFP_ATOMIC);\r\nif (!lp->cb_tags) {\r\nsym_mfree_dma(lp->itlq_tbl, SYM_CONF_MAX_TASK*4, "ITLQ_TBL");\r\nlp->itlq_tbl = NULL;\r\ngoto fail;\r\n}\r\nfor (i = 0 ; i < SYM_CONF_MAX_TASK ; i++)\r\nlp->itlq_tbl[i] = cpu_to_scr(np->notask_ba);\r\nfor (i = 0 ; i < SYM_CONF_MAX_TASK ; i++)\r\nlp->cb_tags[i] = i;\r\nlp->head.itlq_tbl_sa = cpu_to_scr(vtobus(lp->itlq_tbl));\r\nreturn;\r\nfail:\r\nreturn;\r\n}\r\nint sym_free_lcb(struct sym_hcb *np, u_char tn, u_char ln)\r\n{\r\nstruct sym_tcb *tp = &np->target[tn];\r\nstruct sym_lcb *lp = sym_lp(tp, ln);\r\ntp->nlcb--;\r\nif (ln) {\r\nif (!tp->nlcb) {\r\nkfree(tp->lunmp);\r\nsym_mfree_dma(tp->luntbl, 256, "LUNTBL");\r\ntp->lunmp = NULL;\r\ntp->luntbl = NULL;\r\ntp->head.luntbl_sa = cpu_to_scr(vtobus(np->badluntbl));\r\n} else {\r\ntp->luntbl[ln] = cpu_to_scr(vtobus(&np->badlun_sa));\r\ntp->lunmp[ln] = NULL;\r\n}\r\n} else {\r\ntp->lun0p = NULL;\r\ntp->head.lun0_sa = cpu_to_scr(vtobus(&np->badlun_sa));\r\n}\r\nif (lp->itlq_tbl) {\r\nsym_mfree_dma(lp->itlq_tbl, SYM_CONF_MAX_TASK*4, "ITLQ_TBL");\r\nkfree(lp->cb_tags);\r\n}\r\nsym_mfree_dma(lp, sizeof(*lp), "LCB");\r\nreturn tp->nlcb;\r\n}\r\nint sym_queue_scsiio(struct sym_hcb *np, struct scsi_cmnd *cmd, struct sym_ccb *cp)\r\n{\r\nstruct scsi_device *sdev = cmd->device;\r\nstruct sym_tcb *tp;\r\nstruct sym_lcb *lp;\r\nu_char *msgptr;\r\nu_int msglen;\r\nint can_disconnect;\r\ncp->cmd = cmd;\r\ntp = &np->target[cp->target];\r\nlp = sym_lp(tp, sdev->lun);\r\ncan_disconnect = (cp->tag != NO_TAG) ||\r\n(lp && (lp->curr_flags & SYM_DISC_ENABLED));\r\nmsgptr = cp->scsi_smsg;\r\nmsglen = 0;\r\nmsgptr[msglen++] = IDENTIFY(can_disconnect, sdev->lun);\r\nif (cp->tag != NO_TAG) {\r\nu_char order = cp->order;\r\nswitch(order) {\r\ncase M_ORDERED_TAG:\r\nbreak;\r\ncase M_HEAD_TAG:\r\nbreak;\r\ndefault:\r\norder = M_SIMPLE_TAG;\r\n}\r\n#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING\r\nif (lp && lp->tags_since > 3*SYM_CONF_MAX_TAG) {\r\nlp->tags_si = !(lp->tags_si);\r\nif (lp->tags_sum[lp->tags_si]) {\r\norder = M_ORDERED_TAG;\r\nif ((DEBUG_FLAGS & DEBUG_TAGS)||sym_verbose>1) {\r\nsym_print_addr(cmd,\r\n"ordered tag forced.\n");\r\n}\r\n}\r\nlp->tags_since = 0;\r\n}\r\n#endif\r\nmsgptr[msglen++] = order;\r\n#if SYM_CONF_MAX_TASK > (512/4)\r\nmsgptr[msglen++] = cp->tag;\r\n#else\r\nmsgptr[msglen++] = (cp->tag << 1) + 1;\r\n#endif\r\n}\r\ncp->nego_status = 0;\r\nif ((tp->tgoal.check_nego ||\r\ncmd->cmnd[0] == INQUIRY || cmd->cmnd[0] == REQUEST_SENSE) &&\r\n!tp->nego_cp && lp) {\r\nmsglen += sym_prepare_nego(np, cp, msgptr + msglen);\r\n}\r\ncp->phys.head.go.start = cpu_to_scr(SCRIPTA_BA(np, select));\r\ncp->phys.head.go.restart = cpu_to_scr(SCRIPTA_BA(np, resel_dsa));\r\ncp->phys.select.sel_id = cp->target;\r\ncp->phys.select.sel_scntl3 = tp->head.wval;\r\ncp->phys.select.sel_sxfer = tp->head.sval;\r\ncp->phys.select.sel_scntl4 = tp->head.uval;\r\ncp->phys.smsg.addr = CCB_BA(cp, scsi_smsg);\r\ncp->phys.smsg.size = cpu_to_scr(msglen);\r\ncp->host_xflags = 0;\r\ncp->host_status = cp->nego_status ? HS_NEGOTIATE : HS_BUSY;\r\ncp->ssss_status = S_ILLEGAL;\r\ncp->xerr_status = 0;\r\ncp->host_flags = 0;\r\ncp->extra_bytes = 0;\r\ncp->ext_sg = -1;\r\ncp->ext_ofs = 0;\r\nreturn sym_setup_data_and_start(np, cmd, cp);\r\n}\r\nint sym_reset_scsi_target(struct sym_hcb *np, int target)\r\n{\r\nstruct sym_tcb *tp;\r\nif (target == np->myaddr || (u_int)target >= SYM_CONF_MAX_TARGET)\r\nreturn -1;\r\ntp = &np->target[target];\r\ntp->to_reset = 1;\r\nnp->istat_sem = SEM;\r\nOUTB(np, nc_istat, SIGP|SEM);\r\nreturn 0;\r\n}\r\nstatic int sym_abort_ccb(struct sym_hcb *np, struct sym_ccb *cp, int timed_out)\r\n{\r\nif (!cp || !cp->host_status || cp->host_status == HS_WAIT)\r\nreturn -1;\r\nif (cp->to_abort) {\r\nsym_reset_scsi_bus(np, 1);\r\nreturn 0;\r\n}\r\ncp->to_abort = timed_out ? 2 : 1;\r\nnp->istat_sem = SEM;\r\nOUTB(np, nc_istat, SIGP|SEM);\r\nreturn 0;\r\n}\r\nint sym_abort_scsiio(struct sym_hcb *np, struct scsi_cmnd *cmd, int timed_out)\r\n{\r\nstruct sym_ccb *cp;\r\nSYM_QUEHEAD *qp;\r\ncp = NULL;\r\nFOR_EACH_QUEUED_ELEMENT(&np->busy_ccbq, qp) {\r\nstruct sym_ccb *cp2 = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nif (cp2->cmd == cmd) {\r\ncp = cp2;\r\nbreak;\r\n}\r\n}\r\nreturn sym_abort_ccb(np, cp, timed_out);\r\n}\r\nvoid sym_complete_error(struct sym_hcb *np, struct sym_ccb *cp)\r\n{\r\nstruct scsi_device *sdev;\r\nstruct scsi_cmnd *cmd;\r\nstruct sym_tcb *tp;\r\nstruct sym_lcb *lp;\r\nint resid;\r\nint i;\r\nif (!cp || !cp->cmd)\r\nreturn;\r\ncmd = cp->cmd;\r\nsdev = cmd->device;\r\nif (DEBUG_FLAGS & (DEBUG_TINY|DEBUG_RESULT)) {\r\ndev_info(&sdev->sdev_gendev, "CCB=%p STAT=%x/%x/%x\n", cp,\r\ncp->host_status, cp->ssss_status, cp->host_flags);\r\n}\r\ntp = &np->target[cp->target];\r\nlp = sym_lp(tp, sdev->lun);\r\nif (cp->xerr_status) {\r\nif (sym_verbose)\r\nsym_print_xerr(cmd, cp->xerr_status);\r\nif (cp->host_status == HS_COMPLETE)\r\ncp->host_status = HS_COMP_ERR;\r\n}\r\nresid = sym_compute_residual(np, cp);\r\nif (!SYM_SETUP_RESIDUAL_SUPPORT) {\r\nresid = 0;\r\ncp->sv_resid = 0;\r\n}\r\n#ifdef DEBUG_2_0_X\r\nif (resid)\r\nprintf("XXXX RESID= %d - 0x%x\n", resid, resid);\r\n#endif\r\ni = (INL(np, nc_scratcha) - np->squeue_ba) / 4;\r\ni = sym_dequeue_from_squeue(np, i, cp->target, sdev->lun, -1);\r\nOUTL_DSP(np, SCRIPTA_BA(np, start));\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (cp->host_status == HS_COMPLETE &&\r\ncp->ssss_status == S_QUEUE_FULL) {\r\nif (!lp || lp->started_tags - i < 2)\r\ngoto weirdness;\r\nlp->started_max = lp->started_tags - i - 1;\r\nlp->num_sgood = 0;\r\nif (sym_verbose >= 2) {\r\nsym_print_addr(cmd, " queue depth is now %d\n",\r\nlp->started_max);\r\n}\r\ncp->host_status = HS_BUSY;\r\ncp->ssss_status = S_ILLEGAL;\r\nsym_set_cam_status(cmd, DID_SOFT_ERROR);\r\ngoto finish;\r\n}\r\nweirdness:\r\n#endif\r\nsym_set_cam_result_error(np, cp, resid);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nfinish:\r\n#endif\r\nsym_remque(&cp->link_ccbq);\r\nsym_insque_head(&cp->link_ccbq, &np->comp_ccbq);\r\nsym_flush_comp_queue(np, 0);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nsym_start_next_ccbs(np, lp, 1);\r\n#endif\r\n}\r\nvoid sym_complete_ok (struct sym_hcb *np, struct sym_ccb *cp)\r\n{\r\nstruct sym_tcb *tp;\r\nstruct sym_lcb *lp;\r\nstruct scsi_cmnd *cmd;\r\nint resid;\r\nif (!cp || !cp->cmd)\r\nreturn;\r\nassert (cp->host_status == HS_COMPLETE);\r\ncmd = cp->cmd;\r\ntp = &np->target[cp->target];\r\nlp = sym_lp(tp, cp->lun);\r\nresid = 0;\r\nif (cp->phys.head.lastp != cp->goalp)\r\nresid = sym_compute_residual(np, cp);\r\nif (!SYM_SETUP_RESIDUAL_SUPPORT)\r\nresid = 0;\r\n#ifdef DEBUG_2_0_X\r\nif (resid)\r\nprintf("XXXX RESID= %d - 0x%x\n", resid, resid);\r\n#endif\r\nsym_set_cam_result_ok(cp, cmd, resid);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (lp && lp->started_max < lp->started_limit) {\r\n++lp->num_sgood;\r\nif (lp->num_sgood >= 200) {\r\nlp->num_sgood = 0;\r\n++lp->started_max;\r\nif (sym_verbose >= 2) {\r\nsym_print_addr(cmd, " queue depth is now %d\n",\r\nlp->started_max);\r\n}\r\n}\r\n}\r\n#endif\r\nsym_free_ccb (np, cp);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nif (!sym_que_empty(&lp->waiting_ccbq))\r\nsym_start_next_ccbs(np, lp, 2);\r\n#endif\r\nsym_xpt_done(np, cmd);\r\n}\r\nint sym_hcb_attach(struct Scsi_Host *shost, struct sym_fw *fw, struct sym_nvram *nvram)\r\n{\r\nstruct sym_hcb *np = sym_get_hcb(shost);\r\nint i;\r\nnp->scripta_sz = fw->a_size;\r\nnp->scriptb_sz = fw->b_size;\r\nnp->scriptz_sz = fw->z_size;\r\nnp->fw_setup = fw->setup;\r\nnp->fw_patch = fw->patch;\r\nnp->fw_name = fw->name;\r\nsym_save_initial_setting (np);\r\nsym_chip_reset(np);\r\nsym_prepare_setting(shost, np, nvram);\r\ni = sym_getpciclock(np);\r\nif (i > 37000 && !(np->features & FE_66MHZ))\r\nprintf("%s: PCI BUS clock seems too high: %u KHz.\n",\r\nsym_name(np), i);\r\nnp->squeue = sym_calloc_dma(sizeof(u32)*(MAX_QUEUE*2),"SQUEUE");\r\nif (!np->squeue)\r\ngoto attach_failed;\r\nnp->squeue_ba = vtobus(np->squeue);\r\nnp->dqueue = sym_calloc_dma(sizeof(u32)*(MAX_QUEUE*2),"DQUEUE");\r\nif (!np->dqueue)\r\ngoto attach_failed;\r\nnp->dqueue_ba = vtobus(np->dqueue);\r\nnp->targtbl = sym_calloc_dma(256, "TARGTBL");\r\nif (!np->targtbl)\r\ngoto attach_failed;\r\nnp->targtbl_ba = vtobus(np->targtbl);\r\nnp->scripta0 = sym_calloc_dma(np->scripta_sz, "SCRIPTA0");\r\nnp->scriptb0 = sym_calloc_dma(np->scriptb_sz, "SCRIPTB0");\r\nnp->scriptz0 = sym_calloc_dma(np->scriptz_sz, "SCRIPTZ0");\r\nif (!np->scripta0 || !np->scriptb0 || !np->scriptz0)\r\ngoto attach_failed;\r\nnp->ccbh = kcalloc(CCB_HASH_SIZE, sizeof(struct sym_ccb **), GFP_KERNEL);\r\nif (!np->ccbh)\r\ngoto attach_failed;\r\nsym_que_init(&np->free_ccbq);\r\nsym_que_init(&np->busy_ccbq);\r\nsym_que_init(&np->comp_ccbq);\r\n#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING\r\nsym_que_init(&np->dummy_ccbq);\r\n#endif\r\nif (!sym_alloc_ccb(np))\r\ngoto attach_failed;\r\nnp->scripta_ba = vtobus(np->scripta0);\r\nnp->scriptb_ba = vtobus(np->scriptb0);\r\nnp->scriptz_ba = vtobus(np->scriptz0);\r\nif (np->ram_ba) {\r\nnp->scripta_ba = np->ram_ba;\r\nif (np->features & FE_RAM8K) {\r\nnp->scriptb_ba = np->scripta_ba + 4096;\r\n#if 0\r\nnp->scr_ram_seg = cpu_to_scr(np->scripta_ba >> 32);\r\n#endif\r\n}\r\n}\r\nmemcpy(np->scripta0, fw->a_base, np->scripta_sz);\r\nmemcpy(np->scriptb0, fw->b_base, np->scriptb_sz);\r\nmemcpy(np->scriptz0, fw->z_base, np->scriptz_sz);\r\nnp->fw_setup(np, fw);\r\nsym_fw_bind_script(np, (u32 *) np->scripta0, np->scripta_sz);\r\nsym_fw_bind_script(np, (u32 *) np->scriptb0, np->scriptb_sz);\r\nsym_fw_bind_script(np, (u32 *) np->scriptz0, np->scriptz_sz);\r\n#ifdef SYM_CONF_IARB_SUPPORT\r\n#ifdef SYM_SETUP_IARB_MAX\r\nnp->iarb_max = SYM_SETUP_IARB_MAX;\r\n#else\r\nnp->iarb_max = 4;\r\n#endif\r\n#endif\r\nnp->idletask.start = cpu_to_scr(SCRIPTA_BA(np, idle));\r\nnp->idletask.restart = cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\r\nnp->idletask_ba = vtobus(&np->idletask);\r\nnp->notask.start = cpu_to_scr(SCRIPTA_BA(np, idle));\r\nnp->notask.restart = cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\r\nnp->notask_ba = vtobus(&np->notask);\r\nnp->bad_itl.start = cpu_to_scr(SCRIPTA_BA(np, idle));\r\nnp->bad_itl.restart = cpu_to_scr(SCRIPTB_BA(np, bad_i_t_l));\r\nnp->bad_itl_ba = vtobus(&np->bad_itl);\r\nnp->bad_itlq.start = cpu_to_scr(SCRIPTA_BA(np, idle));\r\nnp->bad_itlq.restart = cpu_to_scr(SCRIPTB_BA(np,bad_i_t_l_q));\r\nnp->bad_itlq_ba = vtobus(&np->bad_itlq);\r\nnp->badluntbl = sym_calloc_dma(256, "BADLUNTBL");\r\nif (!np->badluntbl)\r\ngoto attach_failed;\r\nnp->badlun_sa = cpu_to_scr(SCRIPTB_BA(np, resel_bad_lun));\r\nfor (i = 0 ; i < 64 ; i++)\r\nnp->badluntbl[i] = cpu_to_scr(vtobus(&np->badlun_sa));\r\nfor (i = 0 ; i < SYM_CONF_MAX_TARGET ; i++) {\r\nnp->targtbl[i] = cpu_to_scr(vtobus(&np->target[i]));\r\nnp->target[i].head.luntbl_sa =\r\ncpu_to_scr(vtobus(np->badluntbl));\r\nnp->target[i].head.lun0_sa =\r\ncpu_to_scr(vtobus(&np->badlun_sa));\r\n}\r\nif (sym_snooptest (np)) {\r\nprintf("%s: CACHE INCORRECTLY CONFIGURED.\n", sym_name(np));\r\ngoto attach_failed;\r\n}\r\nreturn 0;\r\nattach_failed:\r\nreturn -ENXIO;\r\n}\r\nvoid sym_hcb_free(struct sym_hcb *np)\r\n{\r\nSYM_QUEHEAD *qp;\r\nstruct sym_ccb *cp;\r\nstruct sym_tcb *tp;\r\nint target;\r\nif (np->scriptz0)\r\nsym_mfree_dma(np->scriptz0, np->scriptz_sz, "SCRIPTZ0");\r\nif (np->scriptb0)\r\nsym_mfree_dma(np->scriptb0, np->scriptb_sz, "SCRIPTB0");\r\nif (np->scripta0)\r\nsym_mfree_dma(np->scripta0, np->scripta_sz, "SCRIPTA0");\r\nif (np->squeue)\r\nsym_mfree_dma(np->squeue, sizeof(u32)*(MAX_QUEUE*2), "SQUEUE");\r\nif (np->dqueue)\r\nsym_mfree_dma(np->dqueue, sizeof(u32)*(MAX_QUEUE*2), "DQUEUE");\r\nif (np->actccbs) {\r\nwhile ((qp = sym_remque_head(&np->free_ccbq)) != NULL) {\r\ncp = sym_que_entry(qp, struct sym_ccb, link_ccbq);\r\nsym_mfree_dma(cp, sizeof(*cp), "CCB");\r\n}\r\n}\r\nkfree(np->ccbh);\r\nif (np->badluntbl)\r\nsym_mfree_dma(np->badluntbl, 256,"BADLUNTBL");\r\nfor (target = 0; target < SYM_CONF_MAX_TARGET ; target++) {\r\ntp = &np->target[target];\r\nif (tp->luntbl)\r\nsym_mfree_dma(tp->luntbl, 256, "LUNTBL");\r\n#if SYM_CONF_MAX_LUN > 1\r\nkfree(tp->lunmp);\r\n#endif\r\n}\r\nif (np->targtbl)\r\nsym_mfree_dma(np->targtbl, 256, "TARGTBL");\r\n}
