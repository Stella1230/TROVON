static inline u8 ds2482_calculate_config(u8 conf)\r\n{\r\nreturn conf | ((~conf & 0x0f) << 4);\r\n}\r\nstatic inline int ds2482_select_register(struct ds2482_data *pdev, u8 read_ptr)\r\n{\r\nif (pdev->read_prt != read_ptr) {\r\nif (i2c_smbus_write_byte_data(pdev->client,\r\nDS2482_CMD_SET_READ_PTR,\r\nread_ptr) < 0)\r\nreturn -1;\r\npdev->read_prt = read_ptr;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int ds2482_send_cmd(struct ds2482_data *pdev, u8 cmd)\r\n{\r\nif (i2c_smbus_write_byte(pdev->client, cmd) < 0)\r\nreturn -1;\r\npdev->read_prt = DS2482_PTR_CODE_STATUS;\r\nreturn 0;\r\n}\r\nstatic inline int ds2482_send_cmd_data(struct ds2482_data *pdev,\r\nu8 cmd, u8 byte)\r\n{\r\nif (i2c_smbus_write_byte_data(pdev->client, cmd, byte) < 0)\r\nreturn -1;\r\npdev->read_prt = (cmd != DS2482_CMD_WRITE_CONFIG) ?\r\nDS2482_PTR_CODE_STATUS : DS2482_PTR_CODE_CONFIG;\r\nreturn 0;\r\n}\r\nstatic int ds2482_wait_1wire_idle(struct ds2482_data *pdev)\r\n{\r\nint temp = -1;\r\nint retries = 0;\r\nif (!ds2482_select_register(pdev, DS2482_PTR_CODE_STATUS)) {\r\ndo {\r\ntemp = i2c_smbus_read_byte(pdev->client);\r\n} while ((temp >= 0) && (temp & DS2482_REG_STS_1WB) &&\r\n(++retries < DS2482_WAIT_IDLE_TIMEOUT));\r\n}\r\nif (retries >= DS2482_WAIT_IDLE_TIMEOUT)\r\nprintk(KERN_ERR "%s: timeout on channel %d\n",\r\n__func__, pdev->channel);\r\nreturn temp;\r\n}\r\nstatic int ds2482_set_channel(struct ds2482_data *pdev, u8 channel)\r\n{\r\nif (i2c_smbus_write_byte_data(pdev->client, DS2482_CMD_CHANNEL_SELECT,\r\nds2482_chan_wr[channel]) < 0)\r\nreturn -1;\r\npdev->read_prt = DS2482_PTR_CODE_CHANNEL;\r\npdev->channel = -1;\r\nif (i2c_smbus_read_byte(pdev->client) == ds2482_chan_rd[channel]) {\r\npdev->channel = channel;\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic u8 ds2482_w1_touch_bit(void *data, u8 bit)\r\n{\r\nstruct ds2482_w1_chan *pchan = data;\r\nstruct ds2482_data *pdev = pchan->pdev;\r\nint status = -1;\r\nmutex_lock(&pdev->access_lock);\r\nds2482_wait_1wire_idle(pdev);\r\nif (pdev->w1_count > 1)\r\nds2482_set_channel(pdev, pchan->channel);\r\nif (!ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_SINGLE_BIT,\r\nbit ? 0xFF : 0))\r\nstatus = ds2482_wait_1wire_idle(pdev);\r\nmutex_unlock(&pdev->access_lock);\r\nreturn (status & DS2482_REG_STS_SBR) ? 1 : 0;\r\n}\r\nstatic u8 ds2482_w1_triplet(void *data, u8 dbit)\r\n{\r\nstruct ds2482_w1_chan *pchan = data;\r\nstruct ds2482_data *pdev = pchan->pdev;\r\nint status = (3 << 5);\r\nmutex_lock(&pdev->access_lock);\r\nds2482_wait_1wire_idle(pdev);\r\nif (pdev->w1_count > 1)\r\nds2482_set_channel(pdev, pchan->channel);\r\nif (!ds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_TRIPLET,\r\ndbit ? 0xFF : 0))\r\nstatus = ds2482_wait_1wire_idle(pdev);\r\nmutex_unlock(&pdev->access_lock);\r\nreturn (status >> 5);\r\n}\r\nstatic void ds2482_w1_write_byte(void *data, u8 byte)\r\n{\r\nstruct ds2482_w1_chan *pchan = data;\r\nstruct ds2482_data *pdev = pchan->pdev;\r\nmutex_lock(&pdev->access_lock);\r\nds2482_wait_1wire_idle(pdev);\r\nif (pdev->w1_count > 1)\r\nds2482_set_channel(pdev, pchan->channel);\r\nds2482_send_cmd_data(pdev, DS2482_CMD_1WIRE_WRITE_BYTE, byte);\r\nmutex_unlock(&pdev->access_lock);\r\n}\r\nstatic u8 ds2482_w1_read_byte(void *data)\r\n{\r\nstruct ds2482_w1_chan *pchan = data;\r\nstruct ds2482_data *pdev = pchan->pdev;\r\nint result;\r\nmutex_lock(&pdev->access_lock);\r\nds2482_wait_1wire_idle(pdev);\r\nif (pdev->w1_count > 1)\r\nds2482_set_channel(pdev, pchan->channel);\r\nds2482_send_cmd(pdev, DS2482_CMD_1WIRE_READ_BYTE);\r\nds2482_wait_1wire_idle(pdev);\r\nds2482_select_register(pdev, DS2482_PTR_CODE_DATA);\r\nresult = i2c_smbus_read_byte(pdev->client);\r\nmutex_unlock(&pdev->access_lock);\r\nreturn result;\r\n}\r\nstatic u8 ds2482_w1_reset_bus(void *data)\r\n{\r\nstruct ds2482_w1_chan *pchan = data;\r\nstruct ds2482_data *pdev = pchan->pdev;\r\nint err;\r\nu8 retval = 1;\r\nmutex_lock(&pdev->access_lock);\r\nds2482_wait_1wire_idle(pdev);\r\nif (pdev->w1_count > 1)\r\nds2482_set_channel(pdev, pchan->channel);\r\nerr = ds2482_send_cmd(pdev, DS2482_CMD_1WIRE_RESET);\r\nif (err >= 0) {\r\nerr = ds2482_wait_1wire_idle(pdev);\r\nretval = !(err & DS2482_REG_STS_PPD);\r\nif (err & DS2482_REG_STS_RST)\r\nds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,\r\nds2482_calculate_config(0x00));\r\n}\r\nmutex_unlock(&pdev->access_lock);\r\nreturn retval;\r\n}\r\nstatic u8 ds2482_w1_set_pullup(void *data, int delay)\r\n{\r\nstruct ds2482_w1_chan *pchan = data;\r\nstruct ds2482_data *pdev = pchan->pdev;\r\nu8 retval = 1;\r\nif (delay) {\r\nds2482_wait_1wire_idle(pdev);\r\nretval = ds2482_send_cmd_data(pdev, DS2482_CMD_WRITE_CONFIG,\r\nds2482_calculate_config(DS2482_REG_CFG_SPU |\r\nDS2482_REG_CFG_APU));\r\nds2482_wait_1wire_idle(pdev);\r\n}\r\nreturn retval;\r\n}\r\nstatic int ds2482_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ds2482_data *data;\r\nint err = -ENODEV;\r\nint temp1;\r\nint idx;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WRITE_BYTE_DATA |\r\nI2C_FUNC_SMBUS_BYTE))\r\nreturn -ENODEV;\r\nif (!(data = kzalloc(sizeof(struct ds2482_data), GFP_KERNEL))) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->client = client;\r\ni2c_set_clientdata(client, data);\r\nif (ds2482_send_cmd(data, DS2482_CMD_RESET) < 0) {\r\ndev_warn(&client->dev, "DS2482 reset failed.\n");\r\ngoto exit_free;\r\n}\r\nndelay(525);\r\ntemp1 = i2c_smbus_read_byte(client);\r\nif (temp1 != (DS2482_REG_STS_LL | DS2482_REG_STS_RST)) {\r\ndev_warn(&client->dev, "DS2482 reset status "\r\n"0x%02X - not a DS2482\n", temp1);\r\ngoto exit_free;\r\n}\r\ndata->w1_count = 1;\r\nif (ds2482_set_channel(data, 7) == 0)\r\ndata->w1_count = 8;\r\nds2482_send_cmd_data(data, DS2482_CMD_WRITE_CONFIG,\r\nds2482_calculate_config(0x00));\r\nmutex_init(&data->access_lock);\r\nfor (idx = 0; idx < data->w1_count; idx++) {\r\ndata->w1_ch[idx].pdev = data;\r\ndata->w1_ch[idx].channel = idx;\r\ndata->w1_ch[idx].w1_bm.data = &data->w1_ch[idx];\r\ndata->w1_ch[idx].w1_bm.read_byte = ds2482_w1_read_byte;\r\ndata->w1_ch[idx].w1_bm.write_byte = ds2482_w1_write_byte;\r\ndata->w1_ch[idx].w1_bm.touch_bit = ds2482_w1_touch_bit;\r\ndata->w1_ch[idx].w1_bm.triplet = ds2482_w1_triplet;\r\ndata->w1_ch[idx].w1_bm.reset_bus = ds2482_w1_reset_bus;\r\ndata->w1_ch[idx].w1_bm.set_pullup = ds2482_w1_set_pullup;\r\nerr = w1_add_master_device(&data->w1_ch[idx].w1_bm);\r\nif (err) {\r\ndata->w1_ch[idx].pdev = NULL;\r\ngoto exit_w1_remove;\r\n}\r\n}\r\nreturn 0;\r\nexit_w1_remove:\r\nfor (idx = 0; idx < data->w1_count; idx++) {\r\nif (data->w1_ch[idx].pdev != NULL)\r\nw1_remove_master_device(&data->w1_ch[idx].w1_bm);\r\n}\r\nexit_free:\r\nkfree(data);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int ds2482_remove(struct i2c_client *client)\r\n{\r\nstruct ds2482_data *data = i2c_get_clientdata(client);\r\nint idx;\r\nfor (idx = 0; idx < data->w1_count; idx++) {\r\nif (data->w1_ch[idx].pdev != NULL)\r\nw1_remove_master_device(&data->w1_ch[idx].w1_bm);\r\n}\r\nkfree(data);\r\nreturn 0;\r\n}
