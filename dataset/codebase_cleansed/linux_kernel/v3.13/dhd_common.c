bool brcmf_c_prec_enq(struct device *dev, struct pktq *q,\r\nstruct sk_buff *pkt, int prec)\r\n{\r\nstruct sk_buff *p;\r\nint eprec = -1;\r\nbool discard_oldest;\r\nstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\r\nstruct brcmf_pub *drvr = bus_if->drvr;\r\nif (!pktq_pfull(q, prec) && !pktq_full(q)) {\r\nbrcmu_pktq_penq(q, prec, pkt);\r\nreturn true;\r\n}\r\nif (pktq_pfull(q, prec))\r\neprec = prec;\r\nelse if (pktq_full(q)) {\r\np = brcmu_pktq_peek_tail(q, &eprec);\r\nif (eprec > prec)\r\nreturn false;\r\n}\r\nif (eprec >= 0) {\r\ndiscard_oldest = ac_bitmap_tst(drvr->wme_dp, eprec);\r\nif (eprec == prec && !discard_oldest)\r\nreturn false;\r\np = discard_oldest ? brcmu_pktq_pdeq(q, eprec) :\r\nbrcmu_pktq_pdeq_tail(q, eprec);\r\nif (p == NULL)\r\nbrcmf_err("brcmu_pktq_penq() failed, oldest %d\n",\r\ndiscard_oldest);\r\nbrcmu_pkt_buf_free_skb(p);\r\n}\r\np = brcmu_pktq_penq(q, prec, pkt);\r\nif (p == NULL)\r\nbrcmf_err("brcmu_pktq_penq() failed\n");\r\nreturn p != NULL;\r\n}\r\nstatic int brcmf_c_pattern_atoh(char *src, char *dst)\r\n{\r\nint i;\r\nif (strncmp(src, "0x", 2) != 0 && strncmp(src, "0X", 2) != 0) {\r\nbrcmf_err("Mask invalid format. Needs to start with 0x\n");\r\nreturn -EINVAL;\r\n}\r\nsrc = src + 2;\r\nif (strlen(src) % 2 != 0) {\r\nbrcmf_err("Mask invalid format. Length must be even.\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; *src != '\0'; i++) {\r\nunsigned long res;\r\nchar num[3];\r\nstrncpy(num, src, 2);\r\nnum[2] = '\0';\r\nif (kstrtoul(num, 16, &res))\r\nreturn -EINVAL;\r\ndst[i] = (u8)res;\r\nsrc += 2;\r\n}\r\nreturn i;\r\n}\r\nstatic void\r\nbrcmf_c_pktfilter_offload_enable(struct brcmf_if *ifp, char *arg, int enable,\r\nint master_mode)\r\n{\r\nunsigned long res;\r\nchar *argv;\r\nchar *arg_save = NULL, *arg_org = NULL;\r\ns32 err;\r\nstruct brcmf_pkt_filter_enable_le enable_parm;\r\narg_save = kstrdup(arg, GFP_ATOMIC);\r\nif (!arg_save)\r\ngoto fail;\r\narg_org = arg_save;\r\nargv = strsep(&arg_save, " ");\r\nif (argv == NULL) {\r\nbrcmf_err("No args provided\n");\r\ngoto fail;\r\n}\r\nenable_parm.id = 0;\r\nif (!kstrtoul(argv, 0, &res))\r\nenable_parm.id = cpu_to_le32((u32)res);\r\nenable_parm.enable = cpu_to_le32(enable);\r\nerr = brcmf_fil_iovar_data_set(ifp, "pkt_filter_enable", &enable_parm,\r\nsizeof(enable_parm));\r\nif (err)\r\nbrcmf_err("Set pkt_filter_enable error (%d)\n", err);\r\nerr = brcmf_fil_iovar_int_set(ifp, "pkt_filter_mode", master_mode);\r\nif (err)\r\nbrcmf_err("Set pkt_filter_mode error (%d)\n", err);\r\nfail:\r\nkfree(arg_org);\r\n}\r\nstatic void brcmf_c_pktfilter_offload_set(struct brcmf_if *ifp, char *arg)\r\n{\r\nstruct brcmf_pkt_filter_le *pkt_filter;\r\nunsigned long res;\r\nint buf_len;\r\ns32 err;\r\nu32 mask_size;\r\nu32 pattern_size;\r\nchar *argv[8], *buf = NULL;\r\nint i = 0;\r\nchar *arg_save = NULL, *arg_org = NULL;\r\narg_save = kstrdup(arg, GFP_ATOMIC);\r\nif (!arg_save)\r\ngoto fail;\r\narg_org = arg_save;\r\nbuf = kmalloc(PKTFILTER_BUF_SIZE, GFP_ATOMIC);\r\nif (!buf)\r\ngoto fail;\r\nargv[i] = strsep(&arg_save, " ");\r\nwhile (argv[i]) {\r\ni++;\r\nif (i >= 8) {\r\nbrcmf_err("Too many parameters\n");\r\ngoto fail;\r\n}\r\nargv[i] = strsep(&arg_save, " ");\r\n}\r\nif (i != 6) {\r\nbrcmf_err("Not enough args provided %d\n", i);\r\ngoto fail;\r\n}\r\npkt_filter = (struct brcmf_pkt_filter_le *)buf;\r\npkt_filter->id = 0;\r\nif (!kstrtoul(argv[0], 0, &res))\r\npkt_filter->id = cpu_to_le32((u32)res);\r\npkt_filter->negate_match = 0;\r\nif (!kstrtoul(argv[1], 0, &res))\r\npkt_filter->negate_match = cpu_to_le32((u32)res);\r\npkt_filter->type = 0;\r\nif (!kstrtoul(argv[2], 0, &res))\r\npkt_filter->type = cpu_to_le32((u32)res);\r\npkt_filter->u.pattern.offset = 0;\r\nif (!kstrtoul(argv[3], 0, &res))\r\npkt_filter->u.pattern.offset = cpu_to_le32((u32)res);\r\nmask_size = brcmf_c_pattern_atoh(argv[4],\r\n(char *)pkt_filter->u.pattern.mask_and_pattern);\r\npattern_size = brcmf_c_pattern_atoh(argv[5],\r\n(char *)&pkt_filter->u.pattern.mask_and_pattern[mask_size]);\r\nif (mask_size != pattern_size) {\r\nbrcmf_err("Mask and pattern not the same size\n");\r\ngoto fail;\r\n}\r\npkt_filter->u.pattern.size_bytes = cpu_to_le32(mask_size);\r\nbuf_len = offsetof(struct brcmf_pkt_filter_le,\r\nu.pattern.mask_and_pattern);\r\nbuf_len += mask_size + pattern_size;\r\nerr = brcmf_fil_iovar_data_set(ifp, "pkt_filter_add", pkt_filter,\r\nbuf_len);\r\nif (err)\r\nbrcmf_err("Set pkt_filter_add error (%d)\n", err);\r\nfail:\r\nkfree(arg_org);\r\nkfree(buf);\r\n}\r\nint brcmf_c_preinit_dcmds(struct brcmf_if *ifp)\r\n{\r\ns8 eventmask[BRCMF_EVENTING_MASK_LEN];\r\nu8 buf[BRCMF_DCMD_SMLEN];\r\nchar *ptr;\r\ns32 err;\r\nstruct brcmf_bus_dcmd *cmdlst;\r\nstruct list_head *cur, *q;\r\nerr = brcmf_fil_iovar_data_get(ifp, "cur_etheraddr", ifp->mac_addr,\r\nsizeof(ifp->mac_addr));\r\nif (err < 0) {\r\nbrcmf_err("Retreiving cur_etheraddr failed, %d\n",\r\nerr);\r\ngoto done;\r\n}\r\nmemcpy(ifp->drvr->mac, ifp->mac_addr, sizeof(ifp->drvr->mac));\r\nmemset(buf, 0, sizeof(buf));\r\nstrcpy(buf, "ver");\r\nerr = brcmf_fil_iovar_data_get(ifp, "ver", buf, sizeof(buf));\r\nif (err < 0) {\r\nbrcmf_err("Retreiving version information failed, %d\n",\r\nerr);\r\ngoto done;\r\n}\r\nptr = (char *)buf;\r\nstrsep(&ptr, "\n");\r\nbrcmf_err("Firmware version = %s\n", buf);\r\nerr = brcmf_fil_iovar_int_set(ifp, "bcn_timeout",\r\nBRCMF_DEFAULT_BCN_TIMEOUT);\r\nif (err) {\r\nbrcmf_err("bcn_timeout error (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_fil_iovar_int_set(ifp, "roam_off", 1);\r\nif (err) {\r\nbrcmf_err("roam_off error (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_fil_iovar_data_get(ifp, "event_msgs", eventmask,\r\nBRCMF_EVENTING_MASK_LEN);\r\nif (err) {\r\nbrcmf_err("Get event_msgs error (%d)\n", err);\r\ngoto done;\r\n}\r\nsetbit(eventmask, BRCMF_E_IF);\r\nerr = brcmf_fil_iovar_data_set(ifp, "event_msgs", eventmask,\r\nBRCMF_EVENTING_MASK_LEN);\r\nif (err) {\r\nbrcmf_err("Set event_msgs error (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\r\nBRCMF_DEFAULT_SCAN_CHANNEL_TIME);\r\nif (err) {\r\nbrcmf_err("BRCMF_C_SET_SCAN_CHANNEL_TIME error (%d)\n",\r\nerr);\r\ngoto done;\r\n}\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\r\nBRCMF_DEFAULT_SCAN_UNASSOC_TIME);\r\nif (err) {\r\nbrcmf_err("BRCMF_C_SET_SCAN_UNASSOC_TIME error (%d)\n",\r\nerr);\r\ngoto done;\r\n}\r\nbrcmf_c_pktfilter_offload_set(ifp, BRCMF_DEFAULT_PACKET_FILTER);\r\nbrcmf_c_pktfilter_offload_enable(ifp, BRCMF_DEFAULT_PACKET_FILTER,\r\n0, true);\r\nlist_for_each_safe(cur, q, &ifp->drvr->bus_if->dcmd_list) {\r\ncmdlst = list_entry(cur, struct brcmf_bus_dcmd, list);\r\nif (cmdlst->name && cmdlst->param && cmdlst->param_len) {\r\nbrcmf_fil_iovar_data_set(ifp, cmdlst->name,\r\ncmdlst->param,\r\ncmdlst->param_len);\r\n}\r\nlist_del(cur);\r\nkfree(cmdlst);\r\n}\r\ndone:\r\nreturn err;\r\n}\r\nvoid __brcmf_err(const char *func, const char *fmt, ...)\r\n{\r\nstruct va_format vaf = {\r\n.fmt = fmt,\r\n};\r\nva_list args;\r\nva_start(args, fmt);\r\nvaf.va = &args;\r\npr_err("%s: %pV", func, &vaf);\r\ntrace_brcmf_err(func, &vaf);\r\nva_end(args);\r\n}\r\nvoid __brcmf_dbg(u32 level, const char *func, const char *fmt, ...)\r\n{\r\nstruct va_format vaf = {\r\n.fmt = fmt,\r\n};\r\nva_list args;\r\nva_start(args, fmt);\r\nvaf.va = &args;\r\nif (brcmf_msg_level & level)\r\npr_debug("%s %pV", func, &vaf);\r\ntrace_brcmf_dbg(level, func, &vaf);\r\nva_end(args);\r\n}
