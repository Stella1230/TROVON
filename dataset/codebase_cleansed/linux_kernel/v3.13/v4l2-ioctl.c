const char *v4l2_norm_to_name(v4l2_std_id id)\r\n{\r\nu32 myid = id;\r\nint i;\r\nBUG_ON(myid != id);\r\nfor (i = 0; standards[i].std; i++)\r\nif (myid == standards[i].std)\r\nbreak;\r\nreturn standards[i].descr;\r\n}\r\nvoid v4l2_video_std_frame_period(int id, struct v4l2_fract *frameperiod)\r\n{\r\nif (id & V4L2_STD_525_60) {\r\nframeperiod->numerator = 1001;\r\nframeperiod->denominator = 30000;\r\n} else {\r\nframeperiod->numerator = 1;\r\nframeperiod->denominator = 25;\r\n}\r\n}\r\nint v4l2_video_std_construct(struct v4l2_standard *vs,\r\nint id, const char *name)\r\n{\r\nvs->id = id;\r\nv4l2_video_std_frame_period(id, &vs->frameperiod);\r\nvs->framelines = (id & V4L2_STD_525_60) ? 525 : 625;\r\nstrlcpy(vs->name, name, sizeof(vs->name));\r\nreturn 0;\r\n}\r\nstatic void v4l_print_querycap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_capability *p = arg;\r\npr_cont("driver=%.*s, card=%.*s, bus=%.*s, version=0x%08x, "\r\n"capabilities=0x%08x, device_caps=0x%08x\n",\r\n(int)sizeof(p->driver), p->driver,\r\n(int)sizeof(p->card), p->card,\r\n(int)sizeof(p->bus_info), p->bus_info,\r\np->version, p->capabilities, p->device_caps);\r\n}\r\nstatic void v4l_print_enuminput(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_input *p = arg;\r\npr_cont("index=%u, name=%.*s, type=%u, audioset=0x%x, tuner=%u, "\r\n"std=0x%08Lx, status=0x%x, capabilities=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name, p->type, p->audioset,\r\np->tuner, (unsigned long long)p->std, p->status,\r\np->capabilities);\r\n}\r\nstatic void v4l_print_enumoutput(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_output *p = arg;\r\npr_cont("index=%u, name=%.*s, type=%u, audioset=0x%x, "\r\n"modulator=%u, std=0x%08Lx, capabilities=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name, p->type, p->audioset,\r\np->modulator, (unsigned long long)p->std, p->capabilities);\r\n}\r\nstatic void v4l_print_audio(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_audio *p = arg;\r\nif (write_only)\r\npr_cont("index=%u, mode=0x%x\n", p->index, p->mode);\r\nelse\r\npr_cont("index=%u, name=%.*s, capability=0x%x, mode=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name,\r\np->capability, p->mode);\r\n}\r\nstatic void v4l_print_audioout(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_audioout *p = arg;\r\nif (write_only)\r\npr_cont("index=%u\n", p->index);\r\nelse\r\npr_cont("index=%u, name=%.*s, capability=0x%x, mode=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name,\r\np->capability, p->mode);\r\n}\r\nstatic void v4l_print_fmtdesc(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_fmtdesc *p = arg;\r\npr_cont("index=%u, type=%s, flags=0x%x, pixelformat=%c%c%c%c, description='%.*s'\n",\r\np->index, prt_names(p->type, v4l2_type_names),\r\np->flags, (p->pixelformat & 0xff),\r\n(p->pixelformat >> 8) & 0xff,\r\n(p->pixelformat >> 16) & 0xff,\r\n(p->pixelformat >> 24) & 0xff,\r\n(int)sizeof(p->description), p->description);\r\n}\r\nstatic void v4l_print_format(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_format *p = arg;\r\nconst struct v4l2_pix_format *pix;\r\nconst struct v4l2_pix_format_mplane *mp;\r\nconst struct v4l2_vbi_format *vbi;\r\nconst struct v4l2_sliced_vbi_format *sliced;\r\nconst struct v4l2_window *win;\r\nunsigned i;\r\npr_cont("type=%s", prt_names(p->type, v4l2_type_names));\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\npix = &p->fmt.pix;\r\npr_cont(", width=%u, height=%u, "\r\n"pixelformat=%c%c%c%c, field=%s, "\r\n"bytesperline=%u, sizeimage=%u, colorspace=%d\n",\r\npix->width, pix->height,\r\n(pix->pixelformat & 0xff),\r\n(pix->pixelformat >> 8) & 0xff,\r\n(pix->pixelformat >> 16) & 0xff,\r\n(pix->pixelformat >> 24) & 0xff,\r\nprt_names(pix->field, v4l2_field_names),\r\npix->bytesperline, pix->sizeimage,\r\npix->colorspace);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nmp = &p->fmt.pix_mp;\r\npr_cont(", width=%u, height=%u, "\r\n"format=%c%c%c%c, field=%s, "\r\n"colorspace=%d, num_planes=%u\n",\r\nmp->width, mp->height,\r\n(mp->pixelformat & 0xff),\r\n(mp->pixelformat >> 8) & 0xff,\r\n(mp->pixelformat >> 16) & 0xff,\r\n(mp->pixelformat >> 24) & 0xff,\r\nprt_names(mp->field, v4l2_field_names),\r\nmp->colorspace, mp->num_planes);\r\nfor (i = 0; i < mp->num_planes; i++)\r\nprintk(KERN_DEBUG "plane %u: bytesperline=%u sizeimage=%u\n", i,\r\nmp->plane_fmt[i].bytesperline,\r\nmp->plane_fmt[i].sizeimage);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nwin = &p->fmt.win;\r\npr_cont(", wxh=%dx%d, x,y=%d,%d, field=%s, chromakey=0x%08x, clipcount=%u, clips=%p, bitmap=%p, global_alpha=0x%02x\n",\r\nwin->w.width, win->w.height, win->w.left, win->w.top,\r\nprt_names(win->field, v4l2_field_names),\r\nwin->chromakey, win->clipcount, win->clips,\r\nwin->bitmap, win->global_alpha);\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nvbi = &p->fmt.vbi;\r\npr_cont(", sampling_rate=%u, offset=%u, samples_per_line=%u, "\r\n"sample_format=%c%c%c%c, start=%u,%u, count=%u,%u\n",\r\nvbi->sampling_rate, vbi->offset,\r\nvbi->samples_per_line,\r\n(vbi->sample_format & 0xff),\r\n(vbi->sample_format >> 8) & 0xff,\r\n(vbi->sample_format >> 16) & 0xff,\r\n(vbi->sample_format >> 24) & 0xff,\r\nvbi->start[0], vbi->start[1],\r\nvbi->count[0], vbi->count[1]);\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nsliced = &p->fmt.sliced;\r\npr_cont(", service_set=0x%08x, io_size=%d\n",\r\nsliced->service_set, sliced->io_size);\r\nfor (i = 0; i < 24; i++)\r\nprintk(KERN_DEBUG "line[%02u]=0x%04x, 0x%04x\n", i,\r\nsliced->service_lines[0][i],\r\nsliced->service_lines[1][i]);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_framebuffer(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_framebuffer *p = arg;\r\npr_cont("capability=0x%x, flags=0x%x, base=0x%p, width=%u, "\r\n"height=%u, pixelformat=%c%c%c%c, "\r\n"bytesperline=%u, sizeimage=%u, colorspace=%d\n",\r\np->capability, p->flags, p->base,\r\np->fmt.width, p->fmt.height,\r\n(p->fmt.pixelformat & 0xff),\r\n(p->fmt.pixelformat >> 8) & 0xff,\r\n(p->fmt.pixelformat >> 16) & 0xff,\r\n(p->fmt.pixelformat >> 24) & 0xff,\r\np->fmt.bytesperline, p->fmt.sizeimage,\r\np->fmt.colorspace);\r\n}\r\nstatic void v4l_print_buftype(const void *arg, bool write_only)\r\n{\r\npr_cont("type=%s\n", prt_names(*(u32 *)arg, v4l2_type_names));\r\n}\r\nstatic void v4l_print_modulator(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_modulator *p = arg;\r\nif (write_only)\r\npr_cont("index=%u, txsubchans=0x%x\n", p->index, p->txsubchans);\r\nelse\r\npr_cont("index=%u, name=%.*s, capability=0x%x, "\r\n"rangelow=%u, rangehigh=%u, txsubchans=0x%x\n",\r\np->index, (int)sizeof(p->name), p->name, p->capability,\r\np->rangelow, p->rangehigh, p->txsubchans);\r\n}\r\nstatic void v4l_print_tuner(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_tuner *p = arg;\r\nif (write_only)\r\npr_cont("index=%u, audmode=%u\n", p->index, p->audmode);\r\nelse\r\npr_cont("index=%u, name=%.*s, type=%u, capability=0x%x, "\r\n"rangelow=%u, rangehigh=%u, signal=%u, afc=%d, "\r\n"rxsubchans=0x%x, audmode=%u\n",\r\np->index, (int)sizeof(p->name), p->name, p->type,\r\np->capability, p->rangelow,\r\np->rangehigh, p->signal, p->afc,\r\np->rxsubchans, p->audmode);\r\n}\r\nstatic void v4l_print_frequency(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frequency *p = arg;\r\npr_cont("tuner=%u, type=%u, frequency=%u\n",\r\np->tuner, p->type, p->frequency);\r\n}\r\nstatic void v4l_print_standard(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_standard *p = arg;\r\npr_cont("index=%u, id=0x%Lx, name=%.*s, fps=%u/%u, "\r\n"framelines=%u\n", p->index,\r\n(unsigned long long)p->id, (int)sizeof(p->name), p->name,\r\np->frameperiod.numerator,\r\np->frameperiod.denominator,\r\np->framelines);\r\n}\r\nstatic void v4l_print_std(const void *arg, bool write_only)\r\n{\r\npr_cont("std=0x%08Lx\n", *(const long long unsigned *)arg);\r\n}\r\nstatic void v4l_print_hw_freq_seek(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_hw_freq_seek *p = arg;\r\npr_cont("tuner=%u, type=%u, seek_upward=%u, wrap_around=%u, spacing=%u, "\r\n"rangelow=%u, rangehigh=%u\n",\r\np->tuner, p->type, p->seek_upward, p->wrap_around, p->spacing,\r\np->rangelow, p->rangehigh);\r\n}\r\nstatic void v4l_print_requestbuffers(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_requestbuffers *p = arg;\r\npr_cont("count=%d, type=%s, memory=%s\n",\r\np->count,\r\nprt_names(p->type, v4l2_type_names),\r\nprt_names(p->memory, v4l2_memory_names));\r\n}\r\nstatic void v4l_print_buffer(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_buffer *p = arg;\r\nconst struct v4l2_timecode *tc = &p->timecode;\r\nconst struct v4l2_plane *plane;\r\nint i;\r\npr_cont("%02ld:%02d:%02d.%08ld index=%d, type=%s, "\r\n"flags=0x%08x, field=%s, sequence=%d, memory=%s",\r\np->timestamp.tv_sec / 3600,\r\n(int)(p->timestamp.tv_sec / 60) % 60,\r\n(int)(p->timestamp.tv_sec % 60),\r\n(long)p->timestamp.tv_usec,\r\np->index,\r\nprt_names(p->type, v4l2_type_names),\r\np->flags, prt_names(p->field, v4l2_field_names),\r\np->sequence, prt_names(p->memory, v4l2_memory_names));\r\nif (V4L2_TYPE_IS_MULTIPLANAR(p->type) && p->m.planes) {\r\npr_cont("\n");\r\nfor (i = 0; i < p->length; ++i) {\r\nplane = &p->m.planes[i];\r\nprintk(KERN_DEBUG\r\n"plane %d: bytesused=%d, data_offset=0x%08x, "\r\n"offset/userptr=0x%lx, length=%d\n",\r\ni, plane->bytesused, plane->data_offset,\r\nplane->m.userptr, plane->length);\r\n}\r\n} else {\r\npr_cont(", bytesused=%d, offset/userptr=0x%lx, length=%d\n",\r\np->bytesused, p->m.userptr, p->length);\r\n}\r\nprintk(KERN_DEBUG "timecode=%02d:%02d:%02d type=%d, "\r\n"flags=0x%08x, frames=%d, userbits=0x%08x\n",\r\ntc->hours, tc->minutes, tc->seconds,\r\ntc->type, tc->flags, tc->frames, *(__u32 *)tc->userbits);\r\n}\r\nstatic void v4l_print_exportbuffer(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_exportbuffer *p = arg;\r\npr_cont("fd=%d, type=%s, index=%u, plane=%u, flags=0x%08x\n",\r\np->fd, prt_names(p->type, v4l2_type_names),\r\np->index, p->plane, p->flags);\r\n}\r\nstatic void v4l_print_create_buffers(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_create_buffers *p = arg;\r\npr_cont("index=%d, count=%d, memory=%s, ",\r\np->index, p->count,\r\nprt_names(p->memory, v4l2_memory_names));\r\nv4l_print_format(&p->format, write_only);\r\n}\r\nstatic void v4l_print_streamparm(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_streamparm *p = arg;\r\npr_cont("type=%s", prt_names(p->type, v4l2_type_names));\r\nif (p->type == V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\np->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {\r\nconst struct v4l2_captureparm *c = &p->parm.capture;\r\npr_cont(", capability=0x%x, capturemode=0x%x, timeperframe=%d/%d, "\r\n"extendedmode=%d, readbuffers=%d\n",\r\nc->capability, c->capturemode,\r\nc->timeperframe.numerator, c->timeperframe.denominator,\r\nc->extendedmode, c->readbuffers);\r\n} else if (p->type == V4L2_BUF_TYPE_VIDEO_OUTPUT ||\r\np->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {\r\nconst struct v4l2_outputparm *c = &p->parm.output;\r\npr_cont(", capability=0x%x, outputmode=0x%x, timeperframe=%d/%d, "\r\n"extendedmode=%d, writebuffers=%d\n",\r\nc->capability, c->outputmode,\r\nc->timeperframe.numerator, c->timeperframe.denominator,\r\nc->extendedmode, c->writebuffers);\r\n} else {\r\npr_cont("\n");\r\n}\r\n}\r\nstatic void v4l_print_queryctrl(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_queryctrl *p = arg;\r\npr_cont("id=0x%x, type=%d, name=%.*s, min/max=%d/%d, "\r\n"step=%d, default=%d, flags=0x%08x\n",\r\np->id, p->type, (int)sizeof(p->name), p->name,\r\np->minimum, p->maximum,\r\np->step, p->default_value, p->flags);\r\n}\r\nstatic void v4l_print_querymenu(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_querymenu *p = arg;\r\npr_cont("id=0x%x, index=%d\n", p->id, p->index);\r\n}\r\nstatic void v4l_print_control(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_control *p = arg;\r\npr_cont("id=0x%x, value=%d\n", p->id, p->value);\r\n}\r\nstatic void v4l_print_ext_controls(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_ext_controls *p = arg;\r\nint i;\r\npr_cont("class=0x%x, count=%d, error_idx=%d",\r\np->ctrl_class, p->count, p->error_idx);\r\nfor (i = 0; i < p->count; i++) {\r\nif (p->controls[i].size)\r\npr_cont(", id/val=0x%x/0x%x",\r\np->controls[i].id, p->controls[i].value);\r\nelse\r\npr_cont(", id/size=0x%x/%u",\r\np->controls[i].id, p->controls[i].size);\r\n}\r\npr_cont("\n");\r\n}\r\nstatic void v4l_print_cropcap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_cropcap *p = arg;\r\npr_cont("type=%s, bounds wxh=%dx%d, x,y=%d,%d, "\r\n"defrect wxh=%dx%d, x,y=%d,%d\n, "\r\n"pixelaspect %d/%d\n",\r\nprt_names(p->type, v4l2_type_names),\r\np->bounds.width, p->bounds.height,\r\np->bounds.left, p->bounds.top,\r\np->defrect.width, p->defrect.height,\r\np->defrect.left, p->defrect.top,\r\np->pixelaspect.numerator, p->pixelaspect.denominator);\r\n}\r\nstatic void v4l_print_crop(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_crop *p = arg;\r\npr_cont("type=%s, wxh=%dx%d, x,y=%d,%d\n",\r\nprt_names(p->type, v4l2_type_names),\r\np->c.width, p->c.height,\r\np->c.left, p->c.top);\r\n}\r\nstatic void v4l_print_selection(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_selection *p = arg;\r\npr_cont("type=%s, target=%d, flags=0x%x, wxh=%dx%d, x,y=%d,%d\n",\r\nprt_names(p->type, v4l2_type_names),\r\np->target, p->flags,\r\np->r.width, p->r.height, p->r.left, p->r.top);\r\n}\r\nstatic void v4l_print_jpegcompression(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_jpegcompression *p = arg;\r\npr_cont("quality=%d, APPn=%d, APP_len=%d, "\r\n"COM_len=%d, jpeg_markers=0x%x\n",\r\np->quality, p->APPn, p->APP_len,\r\np->COM_len, p->jpeg_markers);\r\n}\r\nstatic void v4l_print_enc_idx(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_enc_idx *p = arg;\r\npr_cont("entries=%d, entries_cap=%d\n",\r\np->entries, p->entries_cap);\r\n}\r\nstatic void v4l_print_encoder_cmd(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_encoder_cmd *p = arg;\r\npr_cont("cmd=%d, flags=0x%x\n",\r\np->cmd, p->flags);\r\n}\r\nstatic void v4l_print_decoder_cmd(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_decoder_cmd *p = arg;\r\npr_cont("cmd=%d, flags=0x%x\n", p->cmd, p->flags);\r\nif (p->cmd == V4L2_DEC_CMD_START)\r\npr_info("speed=%d, format=%u\n",\r\np->start.speed, p->start.format);\r\nelse if (p->cmd == V4L2_DEC_CMD_STOP)\r\npr_info("pts=%llu\n", p->stop.pts);\r\n}\r\nstatic void v4l_print_dbg_chip_info(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dbg_chip_info *p = arg;\r\npr_cont("type=%u, ", p->match.type);\r\nif (p->match.type == V4L2_CHIP_MATCH_I2C_DRIVER)\r\npr_cont("name=%.*s, ",\r\n(int)sizeof(p->match.name), p->match.name);\r\nelse\r\npr_cont("addr=%u, ", p->match.addr);\r\npr_cont("name=%.*s\n", (int)sizeof(p->name), p->name);\r\n}\r\nstatic void v4l_print_dbg_register(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dbg_register *p = arg;\r\npr_cont("type=%u, ", p->match.type);\r\nif (p->match.type == V4L2_CHIP_MATCH_I2C_DRIVER)\r\npr_cont("name=%.*s, ",\r\n(int)sizeof(p->match.name), p->match.name);\r\nelse\r\npr_cont("addr=%u, ", p->match.addr);\r\npr_cont("reg=0x%llx, val=0x%llx\n",\r\np->reg, p->val);\r\n}\r\nstatic void v4l_print_dv_timings(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dv_timings *p = arg;\r\nswitch (p->type) {\r\ncase V4L2_DV_BT_656_1120:\r\npr_cont("type=bt-656/1120, interlaced=%u, "\r\n"pixelclock=%llu, "\r\n"width=%u, height=%u, polarities=0x%x, "\r\n"hfrontporch=%u, hsync=%u, "\r\n"hbackporch=%u, vfrontporch=%u, "\r\n"vsync=%u, vbackporch=%u, "\r\n"il_vfrontporch=%u, il_vsync=%u, "\r\n"il_vbackporch=%u, standards=0x%x, flags=0x%x\n",\r\np->bt.interlaced, p->bt.pixelclock,\r\np->bt.width, p->bt.height,\r\np->bt.polarities, p->bt.hfrontporch,\r\np->bt.hsync, p->bt.hbackporch,\r\np->bt.vfrontporch, p->bt.vsync,\r\np->bt.vbackporch, p->bt.il_vfrontporch,\r\np->bt.il_vsync, p->bt.il_vbackporch,\r\np->bt.standards, p->bt.flags);\r\nbreak;\r\ndefault:\r\npr_cont("type=%d\n", p->type);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_enum_dv_timings(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_enum_dv_timings *p = arg;\r\npr_cont("index=%u, ", p->index);\r\nv4l_print_dv_timings(&p->timings, write_only);\r\n}\r\nstatic void v4l_print_dv_timings_cap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_dv_timings_cap *p = arg;\r\nswitch (p->type) {\r\ncase V4L2_DV_BT_656_1120:\r\npr_cont("type=bt-656/1120, width=%u-%u, height=%u-%u, "\r\n"pixelclock=%llu-%llu, standards=0x%x, capabilities=0x%x\n",\r\np->bt.min_width, p->bt.max_width,\r\np->bt.min_height, p->bt.max_height,\r\np->bt.min_pixelclock, p->bt.max_pixelclock,\r\np->bt.standards, p->bt.capabilities);\r\nbreak;\r\ndefault:\r\npr_cont("type=%u\n", p->type);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_frmsizeenum(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frmsizeenum *p = arg;\r\npr_cont("index=%u, pixelformat=%c%c%c%c, type=%u",\r\np->index,\r\n(p->pixel_format & 0xff),\r\n(p->pixel_format >> 8) & 0xff,\r\n(p->pixel_format >> 16) & 0xff,\r\n(p->pixel_format >> 24) & 0xff,\r\np->type);\r\nswitch (p->type) {\r\ncase V4L2_FRMSIZE_TYPE_DISCRETE:\r\npr_cont(", wxh=%ux%u\n",\r\np->discrete.width, p->discrete.height);\r\nbreak;\r\ncase V4L2_FRMSIZE_TYPE_STEPWISE:\r\npr_cont(", min=%ux%u, max=%ux%u, step=%ux%u\n",\r\np->stepwise.min_width, p->stepwise.min_height,\r\np->stepwise.step_width, p->stepwise.step_height,\r\np->stepwise.max_width, p->stepwise.max_height);\r\nbreak;\r\ncase V4L2_FRMSIZE_TYPE_CONTINUOUS:\r\ndefault:\r\npr_cont("\n");\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_frmivalenum(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frmivalenum *p = arg;\r\npr_cont("index=%u, pixelformat=%c%c%c%c, wxh=%ux%u, type=%u",\r\np->index,\r\n(p->pixel_format & 0xff),\r\n(p->pixel_format >> 8) & 0xff,\r\n(p->pixel_format >> 16) & 0xff,\r\n(p->pixel_format >> 24) & 0xff,\r\np->width, p->height, p->type);\r\nswitch (p->type) {\r\ncase V4L2_FRMIVAL_TYPE_DISCRETE:\r\npr_cont(", fps=%d/%d\n",\r\np->discrete.numerator,\r\np->discrete.denominator);\r\nbreak;\r\ncase V4L2_FRMIVAL_TYPE_STEPWISE:\r\npr_cont(", min=%d/%d, max=%d/%d, step=%d/%d\n",\r\np->stepwise.min.numerator,\r\np->stepwise.min.denominator,\r\np->stepwise.max.numerator,\r\np->stepwise.max.denominator,\r\np->stepwise.step.numerator,\r\np->stepwise.step.denominator);\r\nbreak;\r\ncase V4L2_FRMIVAL_TYPE_CONTINUOUS:\r\ndefault:\r\npr_cont("\n");\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_event(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_event *p = arg;\r\nconst struct v4l2_event_ctrl *c;\r\npr_cont("type=0x%x, pending=%u, sequence=%u, id=%u, "\r\n"timestamp=%lu.%9.9lu\n",\r\np->type, p->pending, p->sequence, p->id,\r\np->timestamp.tv_sec, p->timestamp.tv_nsec);\r\nswitch (p->type) {\r\ncase V4L2_EVENT_VSYNC:\r\nprintk(KERN_DEBUG "field=%s\n",\r\nprt_names(p->u.vsync.field, v4l2_field_names));\r\nbreak;\r\ncase V4L2_EVENT_CTRL:\r\nc = &p->u.ctrl;\r\nprintk(KERN_DEBUG "changes=0x%x, type=%u, ",\r\nc->changes, c->type);\r\nif (c->type == V4L2_CTRL_TYPE_INTEGER64)\r\npr_cont("value64=%lld, ", c->value64);\r\nelse\r\npr_cont("value=%d, ", c->value);\r\npr_cont("flags=0x%x, minimum=%d, maximum=%d, step=%d, "\r\n"default_value=%d\n",\r\nc->flags, c->minimum, c->maximum,\r\nc->step, c->default_value);\r\nbreak;\r\ncase V4L2_EVENT_FRAME_SYNC:\r\npr_cont("frame_sequence=%u\n",\r\np->u.frame_sync.frame_sequence);\r\nbreak;\r\n}\r\n}\r\nstatic void v4l_print_event_subscription(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_event_subscription *p = arg;\r\npr_cont("type=0x%x, id=0x%x, flags=0x%x\n",\r\np->type, p->id, p->flags);\r\n}\r\nstatic void v4l_print_sliced_vbi_cap(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_sliced_vbi_cap *p = arg;\r\nint i;\r\npr_cont("type=%s, service_set=0x%08x\n",\r\nprt_names(p->type, v4l2_type_names), p->service_set);\r\nfor (i = 0; i < 24; i++)\r\nprintk(KERN_DEBUG "line[%02u]=0x%04x, 0x%04x\n", i,\r\np->service_lines[0][i],\r\np->service_lines[1][i]);\r\n}\r\nstatic void v4l_print_freq_band(const void *arg, bool write_only)\r\n{\r\nconst struct v4l2_frequency_band *p = arg;\r\npr_cont("tuner=%u, type=%u, index=%u, capability=0x%x, "\r\n"rangelow=%u, rangehigh=%u, modulation=0x%x\n",\r\np->tuner, p->type, p->index,\r\np->capability, p->rangelow,\r\np->rangehigh, p->modulation);\r\n}\r\nstatic void v4l_print_u32(const void *arg, bool write_only)\r\n{\r\npr_cont("value=%u\n", *(const u32 *)arg);\r\n}\r\nstatic void v4l_print_newline(const void *arg, bool write_only)\r\n{\r\npr_cont("\n");\r\n}\r\nstatic void v4l_print_default(const void *arg, bool write_only)\r\n{\r\npr_cont("driver-specific ioctl\n");\r\n}\r\nstatic int check_ext_ctrls(struct v4l2_ext_controls *c, int allow_priv)\r\n{\r\n__u32 i;\r\nc->reserved[0] = c->reserved[1] = 0;\r\nfor (i = 0; i < c->count; i++)\r\nc->controls[i].reserved2[0] = 0;\r\nif (!allow_priv && c->ctrl_class == V4L2_CID_PRIVATE_BASE)\r\nreturn 0;\r\nfor (i = 0; i < c->count; i++) {\r\nif (V4L2_CTRL_ID2CLASS(c->controls[i].id) != c->ctrl_class) {\r\nc->error_idx = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nstatic int check_fmt(struct file *file, enum v4l2_buf_type type)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_vbi = vfd->vfl_type == VFL_TYPE_VBI;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nif (ops == NULL)\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (is_vid && is_rx &&\r\n(ops->vidioc_g_fmt_vid_cap || ops->vidioc_g_fmt_vid_cap_mplane))\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (is_vid && is_rx && ops->vidioc_g_fmt_vid_cap_mplane)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (is_vid && is_rx && ops->vidioc_g_fmt_vid_overlay)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (is_vid && is_tx &&\r\n(ops->vidioc_g_fmt_vid_out || ops->vidioc_g_fmt_vid_out_mplane))\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (is_vid && is_tx && ops->vidioc_g_fmt_vid_out_mplane)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (is_vid && is_tx && ops->vidioc_g_fmt_vid_out_overlay)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (is_vbi && is_rx && ops->vidioc_g_fmt_vbi_cap)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (is_vbi && is_tx && ops->vidioc_g_fmt_vbi_out)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (is_vbi && is_rx && ops->vidioc_g_fmt_sliced_vbi_cap)\r\nreturn 0;\r\nbreak;\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (is_vbi && is_tx && ops->vidioc_g_fmt_sliced_vbi_out)\r\nreturn 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_querycap(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_capability *cap = (struct v4l2_capability *)arg;\r\ncap->version = LINUX_VERSION_CODE;\r\nreturn ops->vidioc_querycap(file, fh, cap);\r\n}\r\nstatic int v4l_s_input(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_s_input(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_s_output(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_s_output(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_g_priority(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd;\r\nu32 *p = arg;\r\nif (ops->vidioc_g_priority)\r\nreturn ops->vidioc_g_priority(file, fh, arg);\r\nvfd = video_devdata(file);\r\n*p = v4l2_prio_max(&vfd->v4l2_dev->prio);\r\nreturn 0;\r\n}\r\nstatic int v4l_s_priority(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd;\r\nstruct v4l2_fh *vfh;\r\nu32 *p = arg;\r\nif (ops->vidioc_s_priority)\r\nreturn ops->vidioc_s_priority(file, fh, *p);\r\nvfd = video_devdata(file);\r\nvfh = file->private_data;\r\nreturn v4l2_prio_change(&vfd->v4l2_dev->prio, &vfh->prio, *p);\r\n}\r\nstatic int v4l_enuminput(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_input *p = arg;\r\nif (is_valid_ioctl(vfd, VIDIOC_S_STD))\r\np->capabilities |= V4L2_IN_CAP_STD;\r\nreturn ops->vidioc_enum_input(file, fh, p);\r\n}\r\nstatic int v4l_enumoutput(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_output *p = arg;\r\nif (is_valid_ioctl(vfd, VIDIOC_S_STD))\r\np->capabilities |= V4L2_OUT_CAP_STD;\r\nreturn ops->vidioc_enum_output(file, fh, p);\r\n}\r\nstatic int v4l_enum_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_fmtdesc *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || !ops->vidioc_enum_fmt_vid_cap))\r\nbreak;\r\nreturn ops->vidioc_enum_fmt_vid_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !ops->vidioc_enum_fmt_vid_cap_mplane))\r\nbreak;\r\nreturn ops->vidioc_enum_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !ops->vidioc_enum_fmt_vid_overlay))\r\nbreak;\r\nreturn ops->vidioc_enum_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !ops->vidioc_enum_fmt_vid_out))\r\nbreak;\r\nreturn ops->vidioc_enum_fmt_vid_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !ops->vidioc_enum_fmt_vid_out_mplane))\r\nbreak;\r\nreturn ops->vidioc_enum_fmt_vid_out_mplane(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_format *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_g_fmt_vid_cap))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_g_fmt_vid_cap_mplane))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_g_fmt_vid_overlay))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_g_fmt_vbi_cap))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_g_fmt_sliced_vbi_cap))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_sliced_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_g_fmt_vid_out))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_g_fmt_vid_out_mplane))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_out_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_g_fmt_vid_out_overlay))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vid_out_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_g_fmt_vbi_out))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_g_fmt_sliced_vbi_out))\r\nbreak;\r\nreturn ops->vidioc_g_fmt_sliced_vbi_out(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_format *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nreturn ops->vidioc_s_fmt_vid_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_cap_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp);\r\nreturn ops->vidioc_s_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_s_fmt_vid_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_s_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_s_fmt_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nreturn ops->vidioc_s_fmt_vid_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp);\r\nreturn ops->vidioc_s_fmt_vid_out_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_s_fmt_vid_out_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_s_fmt_vid_out_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_s_fmt_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_s_fmt_sliced_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_s_fmt_sliced_vbi_out(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_format *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\r\nbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\r\nbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\r\nswitch (p->type) {\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_try_fmt_vid_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nreturn ops->vidioc_try_fmt_vid_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_try_fmt_vid_cap_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp);\r\nreturn ops->vidioc_try_fmt_vid_cap_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OVERLAY:\r\nif (unlikely(!is_rx || !is_vid || !ops->vidioc_try_fmt_vid_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_try_fmt_vid_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_try_fmt_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_try_fmt_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:\r\nif (unlikely(!is_rx || is_vid || !ops->vidioc_try_fmt_sliced_vbi_cap))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_try_fmt_sliced_vbi_cap(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_try_fmt_vid_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix);\r\nreturn ops->vidioc_try_fmt_vid_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_try_fmt_vid_out_mplane))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.pix_mp);\r\nreturn ops->vidioc_try_fmt_vid_out_mplane(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:\r\nif (unlikely(!is_tx || !is_vid || !ops->vidioc_try_fmt_vid_out_overlay))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.win);\r\nreturn ops->vidioc_try_fmt_vid_out_overlay(file, fh, arg);\r\ncase V4L2_BUF_TYPE_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_try_fmt_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.vbi);\r\nreturn ops->vidioc_try_fmt_vbi_out(file, fh, arg);\r\ncase V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:\r\nif (unlikely(!is_tx || is_vid || !ops->vidioc_try_fmt_sliced_vbi_out))\r\nbreak;\r\nCLEAR_AFTER_FIELD(p, fmt.sliced);\r\nreturn ops->vidioc_try_fmt_sliced_vbi_out(file, fh, arg);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_streamon(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_streamon(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_streamoff(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_streamoff(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_g_tuner(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_tuner *p = arg;\r\nint err;\r\np->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nerr = ops->vidioc_g_tuner(file, fh, p);\r\nif (!err)\r\np->capability |= V4L2_TUNER_CAP_FREQ_BANDS;\r\nreturn err;\r\n}\r\nstatic int v4l_s_tuner(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_tuner *p = arg;\r\np->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nreturn ops->vidioc_s_tuner(file, fh, p);\r\n}\r\nstatic int v4l_g_modulator(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_modulator *p = arg;\r\nint err;\r\nerr = ops->vidioc_g_modulator(file, fh, p);\r\nif (!err)\r\np->capability |= V4L2_TUNER_CAP_FREQ_BANDS;\r\nreturn err;\r\n}\r\nstatic int v4l_g_frequency(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_frequency *p = arg;\r\np->type = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nreturn ops->vidioc_g_frequency(file, fh, p);\r\n}\r\nstatic int v4l_s_frequency(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nconst struct v4l2_frequency *p = arg;\r\nenum v4l2_tuner_type type;\r\ntype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nif (p->type != type)\r\nreturn -EINVAL;\r\nreturn ops->vidioc_s_frequency(file, fh, p);\r\n}\r\nstatic int v4l_enumstd(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_standard *p = arg;\r\nv4l2_std_id id = vfd->tvnorms, curr_id = 0;\r\nunsigned int index = p->index, i, j = 0;\r\nconst char *descr = "";\r\nif (id == 0)\r\nreturn -ENODATA;\r\nfor (i = 0; i <= index && id; i++) {\r\nwhile ((id & standards[j].std) != standards[j].std)\r\nj++;\r\ncurr_id = standards[j].std;\r\ndescr = standards[j].descr;\r\nj++;\r\nif (curr_id == 0)\r\nbreak;\r\nif (curr_id != V4L2_STD_PAL &&\r\ncurr_id != V4L2_STD_SECAM &&\r\ncurr_id != V4L2_STD_NTSC)\r\nid &= ~curr_id;\r\n}\r\nif (i <= index)\r\nreturn -EINVAL;\r\nv4l2_video_std_construct(p, curr_id, descr);\r\nreturn 0;\r\n}\r\nstatic int v4l_s_std(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nv4l2_std_id id = *(v4l2_std_id *)arg, norm;\r\nnorm = id & vfd->tvnorms;\r\nif (vfd->tvnorms && !norm)\r\nreturn -EINVAL;\r\nreturn ops->vidioc_s_std(file, fh, norm);\r\n}\r\nstatic int v4l_querystd(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nv4l2_std_id *p = arg;\r\n*p = vfd->tvnorms;\r\nreturn ops->vidioc_querystd(file, fh, arg);\r\n}\r\nstatic int v4l_s_hw_freq_seek(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_hw_freq_seek *p = arg;\r\nenum v4l2_tuner_type type;\r\ntype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nif (p->type != type)\r\nreturn -EINVAL;\r\nreturn ops->vidioc_s_hw_freq_seek(file, fh, p);\r\n}\r\nstatic int v4l_overlay(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_overlay(file, fh, *(unsigned int *)arg);\r\n}\r\nstatic int v4l_reqbufs(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_requestbuffers *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nif (ret)\r\nreturn ret;\r\nCLEAR_AFTER_FIELD(p, memory);\r\nreturn ops->vidioc_reqbufs(file, fh, p);\r\n}\r\nstatic int v4l_querybuf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_querybuf(file, fh, p);\r\n}\r\nstatic int v4l_qbuf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_qbuf(file, fh, p);\r\n}\r\nstatic int v4l_dqbuf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_dqbuf(file, fh, p);\r\n}\r\nstatic int v4l_create_bufs(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_create_buffers *create = arg;\r\nint ret = check_fmt(file, create->format.type);\r\nreturn ret ? ret : ops->vidioc_create_bufs(file, fh, create);\r\n}\r\nstatic int v4l_prepare_buf(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_buffer *b = arg;\r\nint ret = check_fmt(file, b->type);\r\nreturn ret ? ret : ops->vidioc_prepare_buf(file, fh, b);\r\n}\r\nstatic int v4l_g_parm(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_streamparm *p = arg;\r\nv4l2_std_id std;\r\nint ret = check_fmt(file, p->type);\r\nif (ret)\r\nreturn ret;\r\nif (ops->vidioc_g_parm)\r\nreturn ops->vidioc_g_parm(file, fh, p);\r\nif (p->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&\r\np->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)\r\nreturn -EINVAL;\r\np->parm.capture.readbuffers = 2;\r\nret = ops->vidioc_g_std(file, fh, &std);\r\nif (ret == 0)\r\nv4l2_video_std_frame_period(std, &p->parm.capture.timeperframe);\r\nreturn ret;\r\n}\r\nstatic int v4l_s_parm(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_streamparm *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nreturn ret ? ret : ops->vidioc_s_parm(file, fh, p);\r\n}\r\nstatic int v4l_queryctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_queryctrl *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_queryctrl(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_queryctrl(vfd->ctrl_handler, p);\r\nif (ops->vidioc_queryctrl)\r\nreturn ops->vidioc_queryctrl(file, fh, p);\r\nreturn -ENOTTY;\r\n}\r\nstatic int v4l_querymenu(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_querymenu *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_querymenu(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_querymenu(vfd->ctrl_handler, p);\r\nif (ops->vidioc_querymenu)\r\nreturn ops->vidioc_querymenu(file, fh, p);\r\nreturn -ENOTTY;\r\n}\r\nstatic int v4l_g_ctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_control *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nstruct v4l2_ext_controls ctrls;\r\nstruct v4l2_ext_control ctrl;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_g_ctrl(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_g_ctrl(vfd->ctrl_handler, p);\r\nif (ops->vidioc_g_ctrl)\r\nreturn ops->vidioc_g_ctrl(file, fh, p);\r\nif (ops->vidioc_g_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);\r\nctrls.count = 1;\r\nctrls.controls = &ctrl;\r\nctrl.id = p->id;\r\nctrl.value = p->value;\r\nif (check_ext_ctrls(&ctrls, 1)) {\r\nint ret = ops->vidioc_g_ext_ctrls(file, fh, &ctrls);\r\nif (ret == 0)\r\np->value = ctrl.value;\r\nreturn ret;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_s_ctrl(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_control *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\nstruct v4l2_ext_controls ctrls;\r\nstruct v4l2_ext_control ctrl;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_s_ctrl(vfh, vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_s_ctrl(NULL, vfd->ctrl_handler, p);\r\nif (ops->vidioc_s_ctrl)\r\nreturn ops->vidioc_s_ctrl(file, fh, p);\r\nif (ops->vidioc_s_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nctrls.ctrl_class = V4L2_CTRL_ID2CLASS(p->id);\r\nctrls.count = 1;\r\nctrls.controls = &ctrl;\r\nctrl.id = p->id;\r\nctrl.value = p->value;\r\nif (check_ext_ctrls(&ctrls, 1))\r\nreturn ops->vidioc_s_ext_ctrls(file, fh, &ctrls);\r\nreturn -EINVAL;\r\n}\r\nstatic int v4l_g_ext_ctrls(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_ext_controls *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\np->error_idx = p->count;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_g_ext_ctrls(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_g_ext_ctrls(vfd->ctrl_handler, p);\r\nif (ops->vidioc_g_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nreturn check_ext_ctrls(p, 0) ? ops->vidioc_g_ext_ctrls(file, fh, p) :\r\n-EINVAL;\r\n}\r\nstatic int v4l_s_ext_ctrls(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_ext_controls *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\np->error_idx = p->count;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_s_ext_ctrls(vfh, vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_s_ext_ctrls(NULL, vfd->ctrl_handler, p);\r\nif (ops->vidioc_s_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nreturn check_ext_ctrls(p, 0) ? ops->vidioc_s_ext_ctrls(file, fh, p) :\r\n-EINVAL;\r\n}\r\nstatic int v4l_try_ext_ctrls(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_ext_controls *p = arg;\r\nstruct v4l2_fh *vfh =\r\ntest_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags) ? fh : NULL;\r\np->error_idx = p->count;\r\nif (vfh && vfh->ctrl_handler)\r\nreturn v4l2_try_ext_ctrls(vfh->ctrl_handler, p);\r\nif (vfd->ctrl_handler)\r\nreturn v4l2_try_ext_ctrls(vfd->ctrl_handler, p);\r\nif (ops->vidioc_try_ext_ctrls == NULL)\r\nreturn -ENOTTY;\r\nreturn check_ext_ctrls(p, 0) ? ops->vidioc_try_ext_ctrls(file, fh, p) :\r\n-EINVAL;\r\n}\r\nstatic int v4l_g_crop(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_crop *p = arg;\r\nstruct v4l2_selection s = {\r\n.type = p->type,\r\n};\r\nint ret;\r\nif (ops->vidioc_g_crop)\r\nreturn ops->vidioc_g_crop(file, fh, p);\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_ACTIVE;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_ACTIVE;\r\nret = ops->vidioc_g_selection(file, fh, &s);\r\nif (!ret)\r\np->c = s.r;\r\nreturn ret;\r\n}\r\nstatic int v4l_s_crop(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_crop *p = arg;\r\nstruct v4l2_selection s = {\r\n.type = p->type,\r\n.r = p->c,\r\n};\r\nif (ops->vidioc_s_crop)\r\nreturn ops->vidioc_s_crop(file, fh, p);\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_ACTIVE;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_ACTIVE;\r\nreturn ops->vidioc_s_selection(file, fh, &s);\r\n}\r\nstatic int v4l_cropcap(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_cropcap *p = arg;\r\nstruct v4l2_selection s = { .type = p->type };\r\nint ret;\r\nif (ops->vidioc_cropcap)\r\nreturn ops->vidioc_cropcap(file, fh, p);\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_BOUNDS;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_BOUNDS;\r\nret = ops->vidioc_g_selection(file, fh, &s);\r\nif (ret)\r\nreturn ret;\r\np->bounds = s.r;\r\nif (V4L2_TYPE_IS_OUTPUT(p->type))\r\ns.target = V4L2_SEL_TGT_COMPOSE_DEFAULT;\r\nelse\r\ns.target = V4L2_SEL_TGT_CROP_DEFAULT;\r\nret = ops->vidioc_g_selection(file, fh, &s);\r\nif (ret)\r\nreturn ret;\r\np->defrect = s.r;\r\np->pixelaspect.numerator = 1;\r\np->pixelaspect.denominator = 1;\r\nreturn 0;\r\n}\r\nstatic int v4l_log_status(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nint ret;\r\nif (vfd->v4l2_dev)\r\npr_info("%s: ================= START STATUS =================\n",\r\nvfd->v4l2_dev->name);\r\nret = ops->vidioc_log_status(file, fh);\r\nif (vfd->v4l2_dev)\r\npr_info("%s: ================== END STATUS ==================\n",\r\nvfd->v4l2_dev->name);\r\nreturn ret;\r\n}\r\nstatic int v4l_dbg_g_register(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nstruct v4l2_dbg_register *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_subdev *sd;\r\nint idx = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (p->match.type == V4L2_CHIP_MATCH_SUBDEV) {\r\nif (vfd->v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nv4l2_device_for_each_subdev(sd, vfd->v4l2_dev)\r\nif (p->match.addr == idx++)\r\nreturn v4l2_subdev_call(sd, core, g_register, p);\r\nreturn -EINVAL;\r\n}\r\nif (ops->vidioc_g_register && p->match.type == V4L2_CHIP_MATCH_BRIDGE &&\r\n(ops->vidioc_g_chip_info || p->match.addr == 0))\r\nreturn ops->vidioc_g_register(file, fh, p);\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nstatic int v4l_dbg_s_register(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nconst struct v4l2_dbg_register *p = arg;\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_subdev *sd;\r\nint idx = 0;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (p->match.type == V4L2_CHIP_MATCH_SUBDEV) {\r\nif (vfd->v4l2_dev == NULL)\r\nreturn -EINVAL;\r\nv4l2_device_for_each_subdev(sd, vfd->v4l2_dev)\r\nif (p->match.addr == idx++)\r\nreturn v4l2_subdev_call(sd, core, s_register, p);\r\nreturn -EINVAL;\r\n}\r\nif (ops->vidioc_s_register && p->match.type == V4L2_CHIP_MATCH_BRIDGE &&\r\n(ops->vidioc_g_chip_info || p->match.addr == 0))\r\nreturn ops->vidioc_s_register(file, fh, p);\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nstatic int v4l_dbg_g_chip_info(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\n#ifdef CONFIG_VIDEO_ADV_DEBUG\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_dbg_chip_info *p = arg;\r\nstruct v4l2_subdev *sd;\r\nint idx = 0;\r\nswitch (p->match.type) {\r\ncase V4L2_CHIP_MATCH_BRIDGE:\r\nif (ops->vidioc_s_register)\r\np->flags |= V4L2_CHIP_FL_WRITABLE;\r\nif (ops->vidioc_g_register)\r\np->flags |= V4L2_CHIP_FL_READABLE;\r\nstrlcpy(p->name, vfd->v4l2_dev->name, sizeof(p->name));\r\nif (ops->vidioc_g_chip_info)\r\nreturn ops->vidioc_g_chip_info(file, fh, arg);\r\nif (p->match.addr)\r\nreturn -EINVAL;\r\nreturn 0;\r\ncase V4L2_CHIP_MATCH_SUBDEV:\r\nif (vfd->v4l2_dev == NULL)\r\nbreak;\r\nv4l2_device_for_each_subdev(sd, vfd->v4l2_dev) {\r\nif (p->match.addr != idx++)\r\ncontinue;\r\nif (sd->ops->core && sd->ops->core->s_register)\r\np->flags |= V4L2_CHIP_FL_WRITABLE;\r\nif (sd->ops->core && sd->ops->core->g_register)\r\np->flags |= V4L2_CHIP_FL_READABLE;\r\nstrlcpy(p->name, sd->name, sizeof(p->name));\r\nreturn 0;\r\n}\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n#else\r\nreturn -ENOTTY;\r\n#endif\r\n}\r\nstatic int v4l_dqevent(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn v4l2_event_dequeue(fh, arg, file->f_flags & O_NONBLOCK);\r\n}\r\nstatic int v4l_subscribe_event(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_subscribe_event(fh, arg);\r\n}\r\nstatic int v4l_unsubscribe_event(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nreturn ops->vidioc_unsubscribe_event(fh, arg);\r\n}\r\nstatic int v4l_g_sliced_vbi_cap(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct v4l2_sliced_vbi_cap *p = arg;\r\nint ret = check_fmt(file, p->type);\r\nif (ret)\r\nreturn ret;\r\nmemset(p, 0, offsetof(struct v4l2_sliced_vbi_cap, type));\r\nreturn ops->vidioc_g_sliced_vbi_cap(file, fh, p);\r\n}\r\nstatic int v4l_enum_freq_bands(const struct v4l2_ioctl_ops *ops,\r\nstruct file *file, void *fh, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct v4l2_frequency_band *p = arg;\r\nenum v4l2_tuner_type type;\r\nint err;\r\ntype = (vfd->vfl_type == VFL_TYPE_RADIO) ?\r\nV4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;\r\nif (type != p->type)\r\nreturn -EINVAL;\r\nif (ops->vidioc_enum_freq_bands)\r\nreturn ops->vidioc_enum_freq_bands(file, fh, p);\r\nif (is_valid_ioctl(vfd, VIDIOC_G_TUNER)) {\r\nstruct v4l2_tuner t = {\r\n.index = p->tuner,\r\n.type = type,\r\n};\r\nif (p->index)\r\nreturn -EINVAL;\r\nerr = ops->vidioc_g_tuner(file, fh, &t);\r\nif (err)\r\nreturn err;\r\np->capability = t.capability | V4L2_TUNER_CAP_FREQ_BANDS;\r\np->rangelow = t.rangelow;\r\np->rangehigh = t.rangehigh;\r\np->modulation = (type == V4L2_TUNER_RADIO) ?\r\nV4L2_BAND_MODULATION_FM : V4L2_BAND_MODULATION_VSB;\r\nreturn 0;\r\n}\r\nif (is_valid_ioctl(vfd, VIDIOC_G_MODULATOR)) {\r\nstruct v4l2_modulator m = {\r\n.index = p->tuner,\r\n};\r\nif (type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nif (p->index)\r\nreturn -EINVAL;\r\nerr = ops->vidioc_g_modulator(file, fh, &m);\r\nif (err)\r\nreturn err;\r\np->capability = m.capability | V4L2_TUNER_CAP_FREQ_BANDS;\r\np->rangelow = m.rangelow;\r\np->rangehigh = m.rangehigh;\r\np->modulation = (type == V4L2_TUNER_RADIO) ?\r\nV4L2_BAND_MODULATION_FM : V4L2_BAND_MODULATION_VSB;\r\nreturn 0;\r\n}\r\nreturn -ENOTTY;\r\n}\r\nbool v4l2_is_known_ioctl(unsigned int cmd)\r\n{\r\nif (_IOC_NR(cmd) >= V4L2_IOCTLS)\r\nreturn false;\r\nreturn v4l2_ioctls[_IOC_NR(cmd)].ioctl == cmd;\r\n}\r\nstruct mutex *v4l2_ioctl_get_lock(struct video_device *vdev, unsigned cmd)\r\n{\r\nif (_IOC_NR(cmd) >= V4L2_IOCTLS)\r\nreturn vdev->lock;\r\nif (test_bit(_IOC_NR(cmd), vdev->disable_locking))\r\nreturn NULL;\r\nif (vdev->queue && vdev->queue->lock &&\r\n(v4l2_ioctls[_IOC_NR(cmd)].flags & INFO_FL_QUEUE))\r\nreturn vdev->queue->lock;\r\nreturn vdev->lock;\r\n}\r\nvoid v4l_printk_ioctl(const char *prefix, unsigned int cmd)\r\n{\r\nconst char *dir, *type;\r\nif (prefix)\r\nprintk(KERN_DEBUG "%s: ", prefix);\r\nswitch (_IOC_TYPE(cmd)) {\r\ncase 'd':\r\ntype = "v4l2_int";\r\nbreak;\r\ncase 'V':\r\nif (_IOC_NR(cmd) >= V4L2_IOCTLS) {\r\ntype = "v4l2";\r\nbreak;\r\n}\r\npr_cont("%s", v4l2_ioctls[_IOC_NR(cmd)].name);\r\nreturn;\r\ndefault:\r\ntype = "unknown";\r\nbreak;\r\n}\r\nswitch (_IOC_DIR(cmd)) {\r\ncase _IOC_NONE: dir = "--"; break;\r\ncase _IOC_READ: dir = "r-"; break;\r\ncase _IOC_WRITE: dir = "-w"; break;\r\ncase _IOC_READ | _IOC_WRITE: dir = "rw"; break;\r\ndefault: dir = "*ERR*"; break;\r\n}\r\npr_cont("%s ioctl '%c', dir=%s, #%d (0x%08x)",\r\ntype, _IOC_TYPE(cmd), dir, _IOC_NR(cmd), cmd);\r\n}\r\nstatic long __video_do_ioctl(struct file *file,\r\nunsigned int cmd, void *arg)\r\n{\r\nstruct video_device *vfd = video_devdata(file);\r\nconst struct v4l2_ioctl_ops *ops = vfd->ioctl_ops;\r\nbool write_only = false;\r\nstruct v4l2_ioctl_info default_info;\r\nconst struct v4l2_ioctl_info *info;\r\nvoid *fh = file->private_data;\r\nstruct v4l2_fh *vfh = NULL;\r\nint use_fh_prio = 0;\r\nint debug = vfd->debug;\r\nlong ret = -ENOTTY;\r\nif (ops == NULL) {\r\npr_warn("%s: has no ioctl_ops.\n",\r\nvideo_device_node_name(vfd));\r\nreturn ret;\r\n}\r\nif (test_bit(V4L2_FL_USES_V4L2_FH, &vfd->flags)) {\r\nvfh = file->private_data;\r\nuse_fh_prio = test_bit(V4L2_FL_USE_FH_PRIO, &vfd->flags);\r\n}\r\nif (v4l2_is_known_ioctl(cmd)) {\r\ninfo = &v4l2_ioctls[_IOC_NR(cmd)];\r\nif (!test_bit(_IOC_NR(cmd), vfd->valid_ioctls) &&\r\n!((info->flags & INFO_FL_CTRL) && vfh && vfh->ctrl_handler))\r\ngoto done;\r\nif (use_fh_prio && (info->flags & INFO_FL_PRIO)) {\r\nret = v4l2_prio_check(vfd->prio, vfh->prio);\r\nif (ret)\r\ngoto done;\r\n}\r\n} else {\r\ndefault_info.ioctl = cmd;\r\ndefault_info.flags = 0;\r\ndefault_info.debug = v4l_print_default;\r\ninfo = &default_info;\r\n}\r\nwrite_only = _IOC_DIR(cmd) == _IOC_WRITE;\r\nif (info->flags & INFO_FL_STD) {\r\ntypedef int (*vidioc_op)(struct file *file, void *fh, void *p);\r\nconst void *p = vfd->ioctl_ops;\r\nconst vidioc_op *vidioc = p + info->u.offset;\r\nret = (*vidioc)(file, fh, arg);\r\n} else if (info->flags & INFO_FL_FUNC) {\r\nret = info->u.func(ops, file, fh, arg);\r\n} else if (!ops->vidioc_default) {\r\nret = -ENOTTY;\r\n} else {\r\nret = ops->vidioc_default(file, fh,\r\nuse_fh_prio ? v4l2_prio_check(vfd->prio, vfh->prio) >= 0 : 0,\r\ncmd, arg);\r\n}\r\ndone:\r\nif (debug) {\r\nv4l_printk_ioctl(video_device_node_name(vfd), cmd);\r\nif (ret < 0)\r\npr_cont(": error %ld", ret);\r\nif (debug == V4L2_DEBUG_IOCTL)\r\npr_cont("\n");\r\nelse if (_IOC_DIR(cmd) == _IOC_NONE)\r\ninfo->debug(arg, write_only);\r\nelse {\r\npr_cont(": ");\r\ninfo->debug(arg, write_only);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int check_array_args(unsigned int cmd, void *parg, size_t *array_size,\r\nvoid * __user *user_ptr, void ***kernel_ptr)\r\n{\r\nint ret = 0;\r\nswitch (cmd) {\r\ncase VIDIOC_PREPARE_BUF:\r\ncase VIDIOC_QUERYBUF:\r\ncase VIDIOC_QBUF:\r\ncase VIDIOC_DQBUF: {\r\nstruct v4l2_buffer *buf = parg;\r\nif (V4L2_TYPE_IS_MULTIPLANAR(buf->type) && buf->length > 0) {\r\nif (buf->length > VIDEO_MAX_PLANES) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n*user_ptr = (void __user *)buf->m.planes;\r\n*kernel_ptr = (void *)&buf->m.planes;\r\n*array_size = sizeof(struct v4l2_plane) * buf->length;\r\nret = 1;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_SUBDEV_G_EDID:\r\ncase VIDIOC_SUBDEV_S_EDID: {\r\nstruct v4l2_subdev_edid *edid = parg;\r\nif (edid->blocks) {\r\nif (edid->blocks > 256) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n*user_ptr = (void __user *)edid->edid;\r\n*kernel_ptr = (void *)&edid->edid;\r\n*array_size = edid->blocks * 128;\r\nret = 1;\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_S_EXT_CTRLS:\r\ncase VIDIOC_G_EXT_CTRLS:\r\ncase VIDIOC_TRY_EXT_CTRLS: {\r\nstruct v4l2_ext_controls *ctrls = parg;\r\nif (ctrls->count != 0) {\r\nif (ctrls->count > V4L2_CID_MAX_CTRLS) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\n*user_ptr = (void __user *)ctrls->controls;\r\n*kernel_ptr = (void *)&ctrls->controls;\r\n*array_size = sizeof(struct v4l2_ext_control)\r\n* ctrls->count;\r\nret = 1;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nlong\r\nvideo_usercopy(struct file *file, unsigned int cmd, unsigned long arg,\r\nv4l2_kioctl func)\r\n{\r\nchar sbuf[128];\r\nvoid *mbuf = NULL;\r\nvoid *parg = (void *)arg;\r\nlong err = -EINVAL;\r\nbool has_array_args;\r\nsize_t array_size = 0;\r\nvoid __user *user_ptr = NULL;\r\nvoid **kernel_ptr = NULL;\r\nif (_IOC_DIR(cmd) != _IOC_NONE) {\r\nif (_IOC_SIZE(cmd) <= sizeof(sbuf)) {\r\nparg = sbuf;\r\n} else {\r\nmbuf = kmalloc(_IOC_SIZE(cmd), GFP_KERNEL);\r\nif (NULL == mbuf)\r\nreturn -ENOMEM;\r\nparg = mbuf;\r\n}\r\nerr = -EFAULT;\r\nif (_IOC_DIR(cmd) & _IOC_WRITE) {\r\nunsigned int n = _IOC_SIZE(cmd);\r\nif (v4l2_is_known_ioctl(cmd)) {\r\nu32 flags = v4l2_ioctls[_IOC_NR(cmd)].flags;\r\nif (flags & INFO_FL_CLEAR_MASK)\r\nn = (flags & INFO_FL_CLEAR_MASK) >> 16;\r\n}\r\nif (copy_from_user(parg, (void __user *)arg, n))\r\ngoto out;\r\nif (n < _IOC_SIZE(cmd))\r\nmemset((u8 *)parg + n, 0, _IOC_SIZE(cmd) - n);\r\n} else {\r\nmemset(parg, 0, _IOC_SIZE(cmd));\r\n}\r\n}\r\nerr = check_array_args(cmd, parg, &array_size, &user_ptr, &kernel_ptr);\r\nif (err < 0)\r\ngoto out;\r\nhas_array_args = err;\r\nif (has_array_args) {\r\nmbuf = kmalloc(array_size, GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (NULL == mbuf)\r\ngoto out_array_args;\r\nerr = -EFAULT;\r\nif (copy_from_user(mbuf, user_ptr, array_size))\r\ngoto out_array_args;\r\n*kernel_ptr = mbuf;\r\n}\r\nerr = func(file, cmd, parg);\r\nif (err == -ENOIOCTLCMD)\r\nerr = -ENOTTY;\r\nif (has_array_args) {\r\n*kernel_ptr = user_ptr;\r\nif (copy_to_user(user_ptr, mbuf, array_size))\r\nerr = -EFAULT;\r\ngoto out_array_args;\r\n}\r\nif (err < 0 && cmd != VIDIOC_QUERY_DV_TIMINGS)\r\ngoto out;\r\nout_array_args:\r\nswitch (_IOC_DIR(cmd)) {\r\ncase _IOC_READ:\r\ncase (_IOC_WRITE | _IOC_READ):\r\nif (copy_to_user((void __user *)arg, parg, _IOC_SIZE(cmd)))\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nout:\r\nkfree(mbuf);\r\nreturn err;\r\n}\r\nlong video_ioctl2(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nreturn video_usercopy(file, cmd, arg, __video_do_ioctl);\r\n}
