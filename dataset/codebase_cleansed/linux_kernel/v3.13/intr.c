static void waiter_release(struct kref *kref)\r\n{\r\nkfree(container_of(kref, struct host1x_waitlist, refcount));\r\n}\r\nstatic bool add_waiter_to_queue(struct host1x_waitlist *waiter,\r\nstruct list_head *queue)\r\n{\r\nstruct host1x_waitlist *pos;\r\nu32 thresh = waiter->thresh;\r\nlist_for_each_entry_reverse(pos, queue, list)\r\nif ((s32)(pos->thresh - thresh) <= 0) {\r\nlist_add(&waiter->list, &pos->list);\r\nreturn false;\r\n}\r\nlist_add(&waiter->list, queue);\r\nreturn true;\r\n}\r\nstatic void remove_completed_waiters(struct list_head *head, u32 sync,\r\nstruct list_head completed[HOST1X_INTR_ACTION_COUNT])\r\n{\r\nstruct list_head *dest;\r\nstruct host1x_waitlist *waiter, *next, *prev;\r\nlist_for_each_entry_safe(waiter, next, head, list) {\r\nif ((s32)(waiter->thresh - sync) > 0)\r\nbreak;\r\ndest = completed + waiter->action;\r\nif (waiter->action == HOST1X_INTR_ACTION_SUBMIT_COMPLETE &&\r\n!list_empty(dest)) {\r\nprev = list_entry(dest->prev,\r\nstruct host1x_waitlist, list);\r\nif (prev->data == waiter->data) {\r\nprev->count++;\r\ndest = NULL;\r\n}\r\n}\r\nif (atomic_inc_return(&waiter->state) == WLS_HANDLED || !dest) {\r\nlist_del(&waiter->list);\r\nkref_put(&waiter->refcount, waiter_release);\r\n} else\r\nlist_move_tail(&waiter->list, dest);\r\n}\r\n}\r\nstatic void reset_threshold_interrupt(struct host1x *host,\r\nstruct list_head *head,\r\nunsigned int id)\r\n{\r\nu32 thresh =\r\nlist_first_entry(head, struct host1x_waitlist, list)->thresh;\r\nhost1x_hw_intr_set_syncpt_threshold(host, id, thresh);\r\nhost1x_hw_intr_enable_syncpt_intr(host, id);\r\n}\r\nstatic void action_submit_complete(struct host1x_waitlist *waiter)\r\n{\r\nstruct host1x_channel *channel = waiter->data;\r\nhost1x_cdma_update(&channel->cdma);\r\ntrace_host1x_channel_submit_complete(dev_name(channel->dev),\r\nwaiter->count, waiter->thresh);\r\n}\r\nstatic void action_wakeup(struct host1x_waitlist *waiter)\r\n{\r\nwait_queue_head_t *wq = waiter->data;\r\nwake_up(wq);\r\n}\r\nstatic void action_wakeup_interruptible(struct host1x_waitlist *waiter)\r\n{\r\nwait_queue_head_t *wq = waiter->data;\r\nwake_up_interruptible(wq);\r\n}\r\nstatic void run_handlers(struct list_head completed[HOST1X_INTR_ACTION_COUNT])\r\n{\r\nstruct list_head *head = completed;\r\nint i;\r\nfor (i = 0; i < HOST1X_INTR_ACTION_COUNT; ++i, ++head) {\r\naction_handler handler = action_handlers[i];\r\nstruct host1x_waitlist *waiter, *next;\r\nlist_for_each_entry_safe(waiter, next, head, list) {\r\nlist_del(&waiter->list);\r\nhandler(waiter);\r\nWARN_ON(atomic_xchg(&waiter->state, WLS_HANDLED) !=\r\nWLS_REMOVED);\r\nkref_put(&waiter->refcount, waiter_release);\r\n}\r\n}\r\n}\r\nstatic int process_wait_list(struct host1x *host,\r\nstruct host1x_syncpt *syncpt,\r\nu32 threshold)\r\n{\r\nstruct list_head completed[HOST1X_INTR_ACTION_COUNT];\r\nunsigned int i;\r\nint empty;\r\nfor (i = 0; i < HOST1X_INTR_ACTION_COUNT; ++i)\r\nINIT_LIST_HEAD(completed + i);\r\nspin_lock(&syncpt->intr.lock);\r\nremove_completed_waiters(&syncpt->intr.wait_head, threshold,\r\ncompleted);\r\nempty = list_empty(&syncpt->intr.wait_head);\r\nif (empty)\r\nhost1x_hw_intr_disable_syncpt_intr(host, syncpt->id);\r\nelse\r\nreset_threshold_interrupt(host, &syncpt->intr.wait_head,\r\nsyncpt->id);\r\nspin_unlock(&syncpt->intr.lock);\r\nrun_handlers(completed);\r\nreturn empty;\r\n}\r\nstatic void syncpt_thresh_work(struct work_struct *work)\r\n{\r\nstruct host1x_syncpt_intr *syncpt_intr =\r\ncontainer_of(work, struct host1x_syncpt_intr, work);\r\nstruct host1x_syncpt *syncpt =\r\ncontainer_of(syncpt_intr, struct host1x_syncpt, intr);\r\nunsigned int id = syncpt->id;\r\nstruct host1x *host = syncpt->host;\r\n(void)process_wait_list(host, syncpt,\r\nhost1x_syncpt_load(host->syncpt + id));\r\n}\r\nint host1x_intr_add_action(struct host1x *host, u32 id, u32 thresh,\r\nenum host1x_intr_action action, void *data,\r\nstruct host1x_waitlist *waiter, void **ref)\r\n{\r\nstruct host1x_syncpt *syncpt;\r\nint queue_was_empty;\r\nif (waiter == NULL) {\r\npr_warn("%s: NULL waiter\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&waiter->list);\r\nkref_init(&waiter->refcount);\r\nif (ref)\r\nkref_get(&waiter->refcount);\r\nwaiter->thresh = thresh;\r\nwaiter->action = action;\r\natomic_set(&waiter->state, WLS_PENDING);\r\nwaiter->data = data;\r\nwaiter->count = 1;\r\nsyncpt = host->syncpt + id;\r\nspin_lock(&syncpt->intr.lock);\r\nqueue_was_empty = list_empty(&syncpt->intr.wait_head);\r\nif (add_waiter_to_queue(waiter, &syncpt->intr.wait_head)) {\r\nhost1x_hw_intr_set_syncpt_threshold(host, id, thresh);\r\nif (queue_was_empty)\r\nhost1x_hw_intr_enable_syncpt_intr(host, id);\r\n}\r\nspin_unlock(&syncpt->intr.lock);\r\nif (ref)\r\n*ref = waiter;\r\nreturn 0;\r\n}\r\nvoid host1x_intr_put_ref(struct host1x *host, u32 id, void *ref)\r\n{\r\nstruct host1x_waitlist *waiter = ref;\r\nstruct host1x_syncpt *syncpt;\r\nwhile (atomic_cmpxchg(&waiter->state, WLS_PENDING, WLS_CANCELLED) ==\r\nWLS_REMOVED)\r\nschedule();\r\nsyncpt = host->syncpt + id;\r\n(void)process_wait_list(host, syncpt,\r\nhost1x_syncpt_load(host->syncpt + id));\r\nkref_put(&waiter->refcount, waiter_release);\r\n}\r\nint host1x_intr_init(struct host1x *host, unsigned int irq_sync)\r\n{\r\nunsigned int id;\r\nu32 nb_pts = host1x_syncpt_nb_pts(host);\r\nmutex_init(&host->intr_mutex);\r\nhost->intr_syncpt_irq = irq_sync;\r\nhost->intr_wq = create_workqueue("host_syncpt");\r\nif (!host->intr_wq)\r\nreturn -ENOMEM;\r\nfor (id = 0; id < nb_pts; ++id) {\r\nstruct host1x_syncpt *syncpt = host->syncpt + id;\r\nspin_lock_init(&syncpt->intr.lock);\r\nINIT_LIST_HEAD(&syncpt->intr.wait_head);\r\nsnprintf(syncpt->intr.thresh_irq_name,\r\nsizeof(syncpt->intr.thresh_irq_name),\r\n"host1x_sp_%02d", id);\r\n}\r\nhost1x_intr_start(host);\r\nreturn 0;\r\n}\r\nvoid host1x_intr_deinit(struct host1x *host)\r\n{\r\nhost1x_intr_stop(host);\r\ndestroy_workqueue(host->intr_wq);\r\n}\r\nvoid host1x_intr_start(struct host1x *host)\r\n{\r\nu32 hz = clk_get_rate(host->clk);\r\nint err;\r\nmutex_lock(&host->intr_mutex);\r\nerr = host1x_hw_intr_init_host_sync(host, DIV_ROUND_UP(hz, 1000000),\r\nsyncpt_thresh_work);\r\nif (err) {\r\nmutex_unlock(&host->intr_mutex);\r\nreturn;\r\n}\r\nmutex_unlock(&host->intr_mutex);\r\n}\r\nvoid host1x_intr_stop(struct host1x *host)\r\n{\r\nunsigned int id;\r\nstruct host1x_syncpt *syncpt = host->syncpt;\r\nu32 nb_pts = host1x_syncpt_nb_pts(host);\r\nmutex_lock(&host->intr_mutex);\r\nhost1x_hw_intr_disable_all_syncpt_intrs(host);\r\nfor (id = 0; id < nb_pts; ++id) {\r\nstruct host1x_waitlist *waiter, *next;\r\nlist_for_each_entry_safe(waiter, next,\r\n&syncpt[id].intr.wait_head, list) {\r\nif (atomic_cmpxchg(&waiter->state,\r\nWLS_CANCELLED, WLS_HANDLED) == WLS_CANCELLED) {\r\nlist_del(&waiter->list);\r\nkref_put(&waiter->refcount, waiter_release);\r\n}\r\n}\r\nif (!list_empty(&syncpt[id].intr.wait_head)) {\r\nmutex_unlock(&host->intr_mutex);\r\npr_warn("%s cannot stop syncpt intr id=%d\n",\r\n__func__, id);\r\nreturn;\r\n}\r\n}\r\nhost1x_hw_intr_free_syncpt_irq(host);\r\nmutex_unlock(&host->intr_mutex);\r\n}
