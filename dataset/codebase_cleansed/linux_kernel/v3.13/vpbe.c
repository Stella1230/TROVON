static struct encoder_config_info*\r\nvpbe_current_encoder_info(struct vpbe_device *vpbe_dev)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nint index = vpbe_dev->current_sd_index;\r\nreturn ((index == 0) ? &cfg->venc :\r\n&cfg->ext_encoders[index-1]);\r\n}\r\nstatic int vpbe_find_encoder_sd_index(struct vpbe_config *cfg,\r\nint index)\r\n{\r\nchar *encoder_name = cfg->outputs[index].subdev_name;\r\nint i;\r\nif (!strcmp(encoder_name, cfg->venc.module_name))\r\nreturn 0;\r\nfor (i = 0; i < cfg->num_ext_encoders; i++) {\r\nif (!strcmp(encoder_name,\r\ncfg->ext_encoders[i].module_name))\r\nreturn i+1;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_g_cropcap(struct vpbe_device *vpbe_dev,\r\nstruct v4l2_cropcap *cropcap)\r\n{\r\nif (NULL == cropcap)\r\nreturn -EINVAL;\r\ncropcap->bounds.left = 0;\r\ncropcap->bounds.top = 0;\r\ncropcap->bounds.width = vpbe_dev->current_timings.xres;\r\ncropcap->bounds.height = vpbe_dev->current_timings.yres;\r\ncropcap->defrect = cropcap->bounds;\r\nreturn 0;\r\n}\r\nstatic int vpbe_enum_outputs(struct vpbe_device *vpbe_dev,\r\nstruct v4l2_output *output)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nint temp_index = output->index;\r\nif (temp_index >= cfg->num_outputs)\r\nreturn -EINVAL;\r\n*output = cfg->outputs[temp_index].output;\r\noutput->index = temp_index;\r\nreturn 0;\r\n}\r\nstatic int vpbe_get_mode_info(struct vpbe_device *vpbe_dev, char *mode,\r\nint output_index)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nstruct vpbe_enc_mode_info var;\r\nint curr_output = output_index;\r\nint i;\r\nif (NULL == mode)\r\nreturn -EINVAL;\r\nfor (i = 0; i < cfg->outputs[curr_output].num_modes; i++) {\r\nvar = cfg->outputs[curr_output].modes[i];\r\nif (!strcmp(mode, var.name)) {\r\nvpbe_dev->current_timings = var;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_get_current_mode_info(struct vpbe_device *vpbe_dev,\r\nstruct vpbe_enc_mode_info *mode_info)\r\n{\r\nif (NULL == mode_info)\r\nreturn -EINVAL;\r\n*mode_info = vpbe_dev->current_timings;\r\nreturn 0;\r\n}\r\nstatic int vpbe_get_std_info(struct vpbe_device *vpbe_dev,\r\nv4l2_std_id std_id)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nstruct vpbe_enc_mode_info var;\r\nint curr_output = vpbe_dev->current_out_index;\r\nint i;\r\nfor (i = 0; i < vpbe_dev->cfg->outputs[curr_output].num_modes; i++) {\r\nvar = cfg->outputs[curr_output].modes[i];\r\nif ((var.timings_type & VPBE_ENC_STD) &&\r\n(var.std_id & std_id)) {\r\nvpbe_dev->current_timings = var;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_get_std_info_by_name(struct vpbe_device *vpbe_dev,\r\nchar *std_name)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nstruct vpbe_enc_mode_info var;\r\nint curr_output = vpbe_dev->current_out_index;\r\nint i;\r\nfor (i = 0; i < vpbe_dev->cfg->outputs[curr_output].num_modes; i++) {\r\nvar = cfg->outputs[curr_output].modes[i];\r\nif (!strcmp(var.name, std_name)) {\r\nvpbe_dev->current_timings = var;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_set_output(struct vpbe_device *vpbe_dev, int index)\r\n{\r\nstruct encoder_config_info *curr_enc_info =\r\nvpbe_current_encoder_info(vpbe_dev);\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nstruct venc_platform_data *venc_device = vpbe_dev->venc_device;\r\nenum v4l2_mbus_pixelcode if_params;\r\nint enc_out_index;\r\nint sd_index;\r\nint ret = 0;\r\nif (index >= cfg->num_outputs)\r\nreturn -EINVAL;\r\nmutex_lock(&vpbe_dev->lock);\r\nsd_index = vpbe_dev->current_sd_index;\r\nenc_out_index = cfg->outputs[index].output.index;\r\nif (strcmp(curr_enc_info->module_name,\r\ncfg->outputs[index].subdev_name)) {\r\nsd_index = vpbe_find_encoder_sd_index(cfg, index);\r\nif (sd_index < 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif_params = cfg->outputs[index].if_params;\r\nvenc_device->setup_if_config(if_params);\r\nif (ret)\r\ngoto out;\r\n}\r\nret = v4l2_subdev_call(vpbe_dev->encoders[sd_index], video,\r\ns_routing, 0, enc_out_index, 0);\r\nif (ret)\r\ngoto out;\r\nret = vpbe_get_mode_info(vpbe_dev,\r\ncfg->outputs[index].default_mode, index);\r\nif (!ret) {\r\nstruct osd_state *osd_device = vpbe_dev->osd_device;\r\nosd_device->ops.set_left_margin(osd_device,\r\nvpbe_dev->current_timings.left_margin);\r\nosd_device->ops.set_top_margin(osd_device,\r\nvpbe_dev->current_timings.upper_margin);\r\nvpbe_dev->current_sd_index = sd_index;\r\nvpbe_dev->current_out_index = index;\r\n}\r\nout:\r\nmutex_unlock(&vpbe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpbe_set_default_output(struct vpbe_device *vpbe_dev)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < cfg->num_outputs; i++) {\r\nif (!strcmp(def_output,\r\ncfg->outputs[i].output.name)) {\r\nret = vpbe_set_output(vpbe_dev, i);\r\nif (!ret)\r\nvpbe_dev->current_out_index = i;\r\nreturn ret;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int vpbe_get_output(struct vpbe_device *vpbe_dev)\r\n{\r\nreturn vpbe_dev->current_out_index;\r\n}\r\nstatic int vpbe_s_dv_timings(struct vpbe_device *vpbe_dev,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nint out_index = vpbe_dev->current_out_index;\r\nstruct vpbe_output *output = &cfg->outputs[out_index];\r\nint sd_index = vpbe_dev->current_sd_index;\r\nint ret, i;\r\nif (!(cfg->outputs[out_index].output.capabilities &\r\nV4L2_OUT_CAP_DV_TIMINGS))\r\nreturn -EINVAL;\r\nfor (i = 0; i < output->num_modes; i++) {\r\nif (output->modes[i].timings_type == VPBE_ENC_DV_TIMINGS &&\r\n!memcmp(&output->modes[i].dv_timings,\r\ndv_timings, sizeof(*dv_timings)))\r\nbreak;\r\n}\r\nif (i >= output->num_modes)\r\nreturn -EINVAL;\r\nvpbe_dev->current_timings = output->modes[i];\r\nmutex_lock(&vpbe_dev->lock);\r\nret = v4l2_subdev_call(vpbe_dev->encoders[sd_index], video,\r\ns_dv_timings, dv_timings);\r\nif (!ret && (vpbe_dev->amp != NULL)) {\r\nret = v4l2_subdev_call(vpbe_dev->amp, video,\r\ns_dv_timings, dv_timings);\r\n}\r\nif (!ret) {\r\nstruct osd_state *osd_device = vpbe_dev->osd_device;\r\nosd_device->ops.set_left_margin(osd_device,\r\nvpbe_dev->current_timings.left_margin);\r\nosd_device->ops.set_top_margin(osd_device,\r\nvpbe_dev->current_timings.upper_margin);\r\n}\r\nmutex_unlock(&vpbe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpbe_g_dv_timings(struct vpbe_device *vpbe_dev,\r\nstruct v4l2_dv_timings *dv_timings)\r\n{\r\nif (vpbe_dev->current_timings.timings_type &\r\nVPBE_ENC_DV_TIMINGS) {\r\n*dv_timings = vpbe_dev->current_timings.dv_timings;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_enum_dv_timings(struct vpbe_device *vpbe_dev,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nint out_index = vpbe_dev->current_out_index;\r\nstruct vpbe_output *output = &cfg->outputs[out_index];\r\nint j = 0;\r\nint i;\r\nif (!(output->output.capabilities & V4L2_OUT_CAP_DV_TIMINGS))\r\nreturn -EINVAL;\r\nfor (i = 0; i < output->num_modes; i++) {\r\nif (output->modes[i].timings_type == VPBE_ENC_DV_TIMINGS) {\r\nif (j == timings->index)\r\nbreak;\r\nj++;\r\n}\r\n}\r\nif (i == output->num_modes)\r\nreturn -EINVAL;\r\ntimings->timings = output->modes[i].dv_timings;\r\nreturn 0;\r\n}\r\nstatic int vpbe_s_std(struct vpbe_device *vpbe_dev, v4l2_std_id std_id)\r\n{\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nint out_index = vpbe_dev->current_out_index;\r\nint sd_index = vpbe_dev->current_sd_index;\r\nint ret;\r\nif (!(cfg->outputs[out_index].output.capabilities &\r\nV4L2_OUT_CAP_STD))\r\nreturn -EINVAL;\r\nret = vpbe_get_std_info(vpbe_dev, std_id);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&vpbe_dev->lock);\r\nret = v4l2_subdev_call(vpbe_dev->encoders[sd_index], video,\r\ns_std_output, std_id);\r\nif (!ret) {\r\nstruct osd_state *osd_device = vpbe_dev->osd_device;\r\nosd_device->ops.set_left_margin(osd_device,\r\nvpbe_dev->current_timings.left_margin);\r\nosd_device->ops.set_top_margin(osd_device,\r\nvpbe_dev->current_timings.upper_margin);\r\n}\r\nmutex_unlock(&vpbe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpbe_g_std(struct vpbe_device *vpbe_dev, v4l2_std_id *std_id)\r\n{\r\nstruct vpbe_enc_mode_info *cur_timings = &vpbe_dev->current_timings;\r\nif (cur_timings->timings_type & VPBE_ENC_STD) {\r\n*std_id = cur_timings->std_id;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vpbe_set_mode(struct vpbe_device *vpbe_dev,\r\nstruct vpbe_enc_mode_info *mode_info)\r\n{\r\nstruct vpbe_enc_mode_info *preset_mode = NULL;\r\nstruct vpbe_config *cfg = vpbe_dev->cfg;\r\nstruct v4l2_dv_timings dv_timings;\r\nstruct osd_state *osd_device;\r\nint out_index = vpbe_dev->current_out_index;\r\nint ret = 0;\r\nint i;\r\nif ((NULL == mode_info) || (NULL == mode_info->name))\r\nreturn -EINVAL;\r\nfor (i = 0; i < cfg->outputs[out_index].num_modes; i++) {\r\nif (!strcmp(mode_info->name,\r\ncfg->outputs[out_index].modes[i].name)) {\r\npreset_mode = &cfg->outputs[out_index].modes[i];\r\nif (preset_mode->timings_type & VPBE_ENC_STD)\r\nreturn vpbe_s_std(vpbe_dev,\r\npreset_mode->std_id);\r\nif (preset_mode->timings_type &\r\nVPBE_ENC_DV_TIMINGS) {\r\ndv_timings =\r\npreset_mode->dv_timings;\r\nreturn vpbe_s_dv_timings(vpbe_dev, &dv_timings);\r\n}\r\n}\r\n}\r\nif (preset_mode == NULL)\r\nreturn -EINVAL;\r\nmutex_lock(&vpbe_dev->lock);\r\nosd_device = vpbe_dev->osd_device;\r\nvpbe_dev->current_timings = *preset_mode;\r\nosd_device->ops.set_left_margin(osd_device,\r\nvpbe_dev->current_timings.left_margin);\r\nosd_device->ops.set_top_margin(osd_device,\r\nvpbe_dev->current_timings.upper_margin);\r\nmutex_unlock(&vpbe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic int vpbe_set_default_mode(struct vpbe_device *vpbe_dev)\r\n{\r\nint ret;\r\nret = vpbe_get_std_info_by_name(vpbe_dev, def_mode);\r\nif (ret)\r\nreturn ret;\r\nreturn vpbe_set_mode(vpbe_dev, &vpbe_dev->current_timings);\r\n}\r\nstatic int platform_device_get(struct device *dev, void *data)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct vpbe_device *vpbe_dev = data;\r\nif (strstr(pdev->name, "vpbe-osd") != NULL)\r\nvpbe_dev->osd_device = platform_get_drvdata(pdev);\r\nif (strstr(pdev->name, "vpbe-venc") != NULL)\r\nvpbe_dev->venc_device = dev_get_platdata(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int vpbe_initialize(struct device *dev, struct vpbe_device *vpbe_dev)\r\n{\r\nstruct encoder_config_info *enc_info;\r\nstruct amp_config_info *amp_info;\r\nstruct v4l2_subdev **enc_subdev;\r\nstruct osd_state *osd_device;\r\nstruct i2c_adapter *i2c_adap;\r\nint num_encoders;\r\nint ret = 0;\r\nint err;\r\nint i;\r\nif (NULL == vpbe_dev || NULL == dev) {\r\nprintk(KERN_ERR "Null device pointers.\n");\r\nreturn -ENODEV;\r\n}\r\nif (vpbe_dev->initialized)\r\nreturn 0;\r\nmutex_lock(&vpbe_dev->lock);\r\nif (strcmp(vpbe_dev->cfg->module_name, "dm644x-vpbe-display") != 0) {\r\nvpbe_dev->dac_clk = clk_get(vpbe_dev->pdev, "vpss_dac");\r\nif (IS_ERR(vpbe_dev->dac_clk)) {\r\nret = PTR_ERR(vpbe_dev->dac_clk);\r\ngoto fail_mutex_unlock;\r\n}\r\nif (clk_prepare_enable(vpbe_dev->dac_clk)) {\r\nret = -ENODEV;\r\ngoto fail_mutex_unlock;\r\n}\r\n}\r\nvpss_enable_clock(VPSS_VPBE_CLOCK, 1);\r\nret = v4l2_device_register(dev, &vpbe_dev->v4l2_dev);\r\nif (ret) {\r\nv4l2_err(dev->driver,\r\n"Unable to register v4l2 device.\n");\r\ngoto fail_clk_put;\r\n}\r\nv4l2_info(&vpbe_dev->v4l2_dev, "vpbe v4l2 device registered\n");\r\nerr = bus_for_each_dev(&platform_bus_type, NULL, vpbe_dev,\r\nplatform_device_get);\r\nif (err < 0) {\r\nret = err;\r\ngoto fail_dev_unregister;\r\n}\r\nvpbe_dev->venc = venc_sub_dev_init(&vpbe_dev->v4l2_dev,\r\nvpbe_dev->cfg->venc.module_name);\r\nif (vpbe_dev->venc == NULL) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"vpbe unable to init venc sub device\n");\r\nret = -ENODEV;\r\ngoto fail_dev_unregister;\r\n}\r\nosd_device = vpbe_dev->osd_device;\r\nif (NULL != osd_device->ops.initialize) {\r\nerr = osd_device->ops.initialize(osd_device);\r\nif (err) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"unable to initialize the OSD device");\r\nerr = -ENOMEM;\r\ngoto fail_dev_unregister;\r\n}\r\n}\r\nnum_encoders = vpbe_dev->cfg->num_ext_encoders + 1;\r\nvpbe_dev->encoders = kmalloc(\r\nsizeof(struct v4l2_subdev *)*num_encoders,\r\nGFP_KERNEL);\r\nif (NULL == vpbe_dev->encoders) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"unable to allocate memory for encoders sub devices");\r\nret = -ENOMEM;\r\ngoto fail_dev_unregister;\r\n}\r\ni2c_adap = i2c_get_adapter(vpbe_dev->cfg->i2c_adapter_id);\r\nfor (i = 0; i < (vpbe_dev->cfg->num_ext_encoders + 1); i++) {\r\nif (i == 0) {\r\nenc_subdev = &vpbe_dev->encoders[i];\r\n*enc_subdev = vpbe_dev->venc;\r\ncontinue;\r\n}\r\nenc_info = &vpbe_dev->cfg->ext_encoders[i];\r\nif (enc_info->is_i2c) {\r\nenc_subdev = &vpbe_dev->encoders[i];\r\n*enc_subdev = v4l2_i2c_new_subdev_board(\r\n&vpbe_dev->v4l2_dev, i2c_adap,\r\n&enc_info->board_info, NULL);\r\nif (*enc_subdev)\r\nv4l2_info(&vpbe_dev->v4l2_dev,\r\n"v4l2 sub device %s registered\n",\r\nenc_info->module_name);\r\nelse {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "encoder %s"\r\n" failed to register",\r\nenc_info->module_name);\r\nret = -ENODEV;\r\ngoto fail_kfree_encoders;\r\n}\r\n} else\r\nv4l2_warn(&vpbe_dev->v4l2_dev, "non-i2c encoders"\r\n" currently not supported");\r\n}\r\nif ((strcmp(vpbe_dev->cfg->module_name, "dm365-vpbe-display") == 0) &&\r\nvpbe_dev->cfg->amp != NULL) {\r\namp_info = vpbe_dev->cfg->amp;\r\nif (amp_info->is_i2c) {\r\nvpbe_dev->amp = v4l2_i2c_new_subdev_board(\r\n&vpbe_dev->v4l2_dev, i2c_adap,\r\n&amp_info->board_info, NULL);\r\nif (!vpbe_dev->amp) {\r\nv4l2_err(&vpbe_dev->v4l2_dev,\r\n"amplifier %s failed to register",\r\namp_info->module_name);\r\nret = -ENODEV;\r\ngoto fail_kfree_encoders;\r\n}\r\nv4l2_info(&vpbe_dev->v4l2_dev,\r\n"v4l2 sub device %s registered\n",\r\namp_info->module_name);\r\n} else {\r\nvpbe_dev->amp = NULL;\r\nv4l2_warn(&vpbe_dev->v4l2_dev, "non-i2c amplifiers"\r\n" currently not supported");\r\n}\r\n} else {\r\nvpbe_dev->amp = NULL;\r\n}\r\nvpbe_dev->current_sd_index = 0;\r\nvpbe_dev->current_out_index = 0;\r\nmutex_unlock(&vpbe_dev->lock);\r\nprintk(KERN_NOTICE "Setting default output to %s\n", def_output);\r\nret = vpbe_set_default_output(vpbe_dev);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Failed to set default output %s",\r\ndef_output);\r\nreturn ret;\r\n}\r\nprintk(KERN_NOTICE "Setting default mode to %s\n", def_mode);\r\nret = vpbe_set_default_mode(vpbe_dev);\r\nif (ret) {\r\nv4l2_err(&vpbe_dev->v4l2_dev, "Failed to set default mode %s",\r\ndef_mode);\r\nreturn ret;\r\n}\r\nvpbe_dev->initialized = 1;\r\nreturn 0;\r\nfail_kfree_encoders:\r\nkfree(vpbe_dev->encoders);\r\nfail_dev_unregister:\r\nv4l2_device_unregister(&vpbe_dev->v4l2_dev);\r\nfail_clk_put:\r\nif (strcmp(vpbe_dev->cfg->module_name, "dm644x-vpbe-display") != 0) {\r\nclk_disable_unprepare(vpbe_dev->dac_clk);\r\nclk_put(vpbe_dev->dac_clk);\r\n}\r\nfail_mutex_unlock:\r\nmutex_unlock(&vpbe_dev->lock);\r\nreturn ret;\r\n}\r\nstatic void vpbe_deinitialize(struct device *dev, struct vpbe_device *vpbe_dev)\r\n{\r\nv4l2_device_unregister(&vpbe_dev->v4l2_dev);\r\nif (strcmp(vpbe_dev->cfg->module_name, "dm644x-vpbe-display") != 0) {\r\nclk_disable_unprepare(vpbe_dev->dac_clk);\r\nclk_put(vpbe_dev->dac_clk);\r\n}\r\nkfree(vpbe_dev->amp);\r\nkfree(vpbe_dev->encoders);\r\nvpbe_dev->initialized = 0;\r\nvpss_enable_clock(VPSS_VPBE_CLOCK, 0);\r\n}\r\nstatic int vpbe_probe(struct platform_device *pdev)\r\n{\r\nstruct vpbe_device *vpbe_dev;\r\nstruct vpbe_config *cfg;\r\nint ret = -EINVAL;\r\nif (pdev->dev.platform_data == NULL) {\r\nv4l2_err(pdev->dev.driver, "No platform data\n");\r\nreturn -ENODEV;\r\n}\r\ncfg = pdev->dev.platform_data;\r\nif (!cfg->module_name[0] ||\r\n!cfg->osd.module_name[0] ||\r\n!cfg->venc.module_name[0]) {\r\nv4l2_err(pdev->dev.driver, "vpbe display module names not"\r\n" defined\n");\r\nreturn ret;\r\n}\r\nvpbe_dev = kzalloc(sizeof(*vpbe_dev), GFP_KERNEL);\r\nif (vpbe_dev == NULL) {\r\nv4l2_err(pdev->dev.driver, "Unable to allocate memory"\r\n" for vpbe_device\n");\r\nreturn -ENOMEM;\r\n}\r\nvpbe_dev->cfg = cfg;\r\nvpbe_dev->ops = vpbe_dev_ops;\r\nvpbe_dev->pdev = &pdev->dev;\r\nif (cfg->outputs->num_modes > 0)\r\nvpbe_dev->current_timings = vpbe_dev->cfg->outputs[0].modes[0];\r\nelse {\r\nkfree(vpbe_dev);\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, vpbe_dev);\r\nmutex_init(&vpbe_dev->lock);\r\nreturn 0;\r\n}\r\nstatic int vpbe_remove(struct platform_device *device)\r\n{\r\nstruct vpbe_device *vpbe_dev = platform_get_drvdata(device);\r\nkfree(vpbe_dev);\r\nreturn 0;\r\n}
