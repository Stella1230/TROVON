static int ehci_mxc_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct mxc_usbh_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct usb_hcd *hcd;\r\nstruct resource *res;\r\nint irq, ret;\r\nstruct ehci_mxc_priv *priv;\r\nstruct device *dev = &pdev->dev;\r\nstruct ehci_hcd *ehci;\r\nif (!pdata) {\r\ndev_err(dev, "No platform data given, bailing out.\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nhcd = usb_create_hcd(&ehci_mxc_hc_driver, dev, dev_name(dev));\r\nif (!hcd)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "Found HC with no register addr. Check setup!\n");\r\nret = -ENODEV;\r\ngoto err_alloc;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nhcd->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nret = PTR_ERR(hcd->regs);\r\ngoto err_alloc;\r\n}\r\nhcd->has_tt = 1;\r\nehci = hcd_to_ehci(hcd);\r\npriv = (struct ehci_mxc_priv *) ehci->priv;\r\npriv->usbclk = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(priv->usbclk)) {\r\nret = PTR_ERR(priv->usbclk);\r\ngoto err_alloc;\r\n}\r\nclk_prepare_enable(priv->usbclk);\r\npriv->ahbclk = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(priv->ahbclk)) {\r\nret = PTR_ERR(priv->ahbclk);\r\ngoto err_clk_ahb;\r\n}\r\nclk_prepare_enable(priv->ahbclk);\r\npriv->phyclk = devm_clk_get(&pdev->dev, "phy");\r\nif (IS_ERR(priv->phyclk))\r\npriv->phyclk = NULL;\r\nif (priv->phyclk)\r\nclk_prepare_enable(priv->phyclk);\r\nif (pdata->init) {\r\nret = pdata->init(pdev);\r\nif (ret) {\r\ndev_err(dev, "platform init failed\n");\r\ngoto err_init;\r\n}\r\nmdelay(10);\r\n}\r\nehci->caps = hcd->regs + 0x100;\r\nehci->regs = hcd->regs + 0x100 +\r\nHC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\r\nehci_writel(ehci, pdata->portsc, &ehci->regs->port_status[0]);\r\nmsleep(10);\r\nif (pdata->otg) {\r\npdata->otg->io_priv = hcd->regs + ULPI_VIEWPORT_OFFSET;\r\nret = usb_phy_init(pdata->otg);\r\nif (ret) {\r\ndev_err(dev, "unable to init transceiver, probably missing\n");\r\nret = -ENODEV;\r\ngoto err_add;\r\n}\r\nret = otg_set_vbus(pdata->otg->otg, 1);\r\nif (ret) {\r\ndev_err(dev, "unable to enable vbus on transceiver\n");\r\ngoto err_add;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, hcd);\r\nret = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (ret)\r\ngoto err_add;\r\nreturn 0;\r\nerr_add:\r\nif (pdata && pdata->exit)\r\npdata->exit(pdev);\r\nerr_init:\r\nif (priv->phyclk)\r\nclk_disable_unprepare(priv->phyclk);\r\nclk_disable_unprepare(priv->ahbclk);\r\nerr_clk_ahb:\r\nclk_disable_unprepare(priv->usbclk);\r\nerr_alloc:\r\nusb_put_hcd(hcd);\r\nreturn ret;\r\n}\r\nstatic int ehci_mxc_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct mxc_usbh_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\r\nstruct ehci_mxc_priv *priv = (struct ehci_mxc_priv *) ehci->priv;\r\nusb_remove_hcd(hcd);\r\nif (pdata && pdata->exit)\r\npdata->exit(pdev);\r\nif (pdata && pdata->otg)\r\nusb_phy_shutdown(pdata->otg);\r\nclk_disable_unprepare(priv->usbclk);\r\nclk_disable_unprepare(priv->ahbclk);\r\nif (priv->phyclk)\r\nclk_disable_unprepare(priv->phyclk);\r\nusb_put_hcd(hcd);\r\nreturn 0;\r\n}\r\nstatic int __init ehci_mxc_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nehci_init_driver(&ehci_mxc_hc_driver, &ehci_mxc_overrides);\r\nreturn platform_driver_register(&ehci_mxc_driver);\r\n}\r\nstatic void __exit ehci_mxc_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ehci_mxc_driver);\r\n}
