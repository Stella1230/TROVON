static inline uint32_t jz4740_rtc_reg_read(struct jz4740_rtc *rtc, size_t reg)\r\n{\r\nreturn readl(rtc->base + reg);\r\n}\r\nstatic int jz4740_rtc_wait_write_ready(struct jz4740_rtc *rtc)\r\n{\r\nuint32_t ctrl;\r\nint timeout = 1000;\r\ndo {\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\n} while (!(ctrl & JZ_RTC_CTRL_WRDY) && --timeout);\r\nreturn timeout ? 0 : -EIO;\r\n}\r\nstatic inline int jz4740_rtc_reg_write(struct jz4740_rtc *rtc, size_t reg,\r\nuint32_t val)\r\n{\r\nint ret;\r\nret = jz4740_rtc_wait_write_ready(rtc);\r\nif (ret == 0)\r\nwritel(val, rtc->base + reg);\r\nreturn ret;\r\n}\r\nstatic int jz4740_rtc_ctrl_set_bits(struct jz4740_rtc *rtc, uint32_t mask,\r\nbool set)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nuint32_t ctrl;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\nctrl |= JZ_RTC_CTRL_1HZ | JZ_RTC_CTRL_AF;\r\nif (set)\r\nctrl |= mask;\r\nelse\r\nctrl &= ~mask;\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_CTRL, ctrl);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int jz4740_rtc_read_time(struct device *dev, struct rtc_time *time)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nuint32_t secs, secs2;\r\nint timeout = 5;\r\nsecs = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\r\nsecs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\r\nwhile (secs != secs2 && --timeout) {\r\nsecs = secs2;\r\nsecs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\r\n}\r\nif (timeout == 0)\r\nreturn -EIO;\r\nrtc_time_to_tm(secs, time);\r\nreturn rtc_valid_tm(time);\r\n}\r\nstatic int jz4740_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nreturn jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC, secs);\r\n}\r\nstatic int jz4740_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nuint32_t secs;\r\nuint32_t ctrl;\r\nsecs = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC_ALARM);\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\nalrm->enabled = !!(ctrl & JZ_RTC_CTRL_AE);\r\nalrm->pending = !!(ctrl & JZ_RTC_CTRL_AF);\r\nrtc_time_to_tm(secs, &alrm->time);\r\nreturn rtc_valid_tm(&alrm->time);\r\n}\r\nstatic int jz4740_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nint ret;\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long secs;\r\nrtc_tm_to_time(&alrm->time, &secs);\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC_ALARM, secs);\r\nif (!ret)\r\nret = jz4740_rtc_ctrl_set_bits(rtc,\r\nJZ_RTC_CTRL_AE | JZ_RTC_CTRL_AF_IRQ, alrm->enabled);\r\nreturn ret;\r\n}\r\nstatic int jz4740_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nreturn jz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_AF_IRQ, enable);\r\n}\r\nstatic irqreturn_t jz4740_rtc_irq(int irq, void *data)\r\n{\r\nstruct jz4740_rtc *rtc = data;\r\nuint32_t ctrl;\r\nunsigned long events = 0;\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\nif (ctrl & JZ_RTC_CTRL_1HZ)\r\nevents |= (RTC_UF | RTC_IRQF);\r\nif (ctrl & JZ_RTC_CTRL_AF)\r\nevents |= (RTC_AF | RTC_IRQF);\r\nrtc_update_irq(rtc->rtc, 1, events);\r\njz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_1HZ | JZ_RTC_CTRL_AF, false);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid jz4740_rtc_poweroff(struct device *dev)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\njz4740_rtc_reg_write(rtc, JZ_REG_RTC_HIBERNATE, 1);\r\n}\r\nstatic int jz4740_rtc_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct jz4740_rtc *rtc;\r\nuint32_t scratchpad;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->irq = platform_get_irq(pdev, 0);\r\nif (rtc->irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get platform irq\n");\r\nreturn -ENOENT;\r\n}\r\nrtc->mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!rtc->mem) {\r\ndev_err(&pdev->dev, "Failed to get platform mmio memory\n");\r\nreturn -ENOENT;\r\n}\r\nrtc->mem = devm_request_mem_region(&pdev->dev, rtc->mem->start,\r\nresource_size(rtc->mem), pdev->name);\r\nif (!rtc->mem) {\r\ndev_err(&pdev->dev, "Failed to request mmio memory region\n");\r\nreturn -EBUSY;\r\n}\r\nrtc->base = devm_ioremap_nocache(&pdev->dev, rtc->mem->start,\r\nresource_size(rtc->mem));\r\nif (!rtc->base) {\r\ndev_err(&pdev->dev, "Failed to ioremap mmio memory\n");\r\nreturn -EBUSY;\r\n}\r\nspin_lock_init(&rtc->lock);\r\nplatform_set_drvdata(pdev, rtc);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&jz4740_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\nret = PTR_ERR(rtc->rtc);\r\ndev_err(&pdev->dev, "Failed to register rtc device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, rtc->irq, jz4740_rtc_irq, 0,\r\npdev->name, rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request rtc irq: %d\n", ret);\r\nreturn ret;\r\n}\r\nscratchpad = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SCRATCHPAD);\r\nif (scratchpad != 0x12345678) {\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SCRATCHPAD, 0x12345678);\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not write write to RTC registers\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int jz4740_rtc_suspend(struct device *dev)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(rtc->irq);\r\nreturn 0;\r\n}\r\nstatic int jz4740_rtc_resume(struct device *dev)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(rtc->irq);\r\nreturn 0;\r\n}
