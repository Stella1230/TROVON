int cl_is_normalio(const struct lu_env *env, const struct cl_io *io)\r\n{\r\nstruct vvp_io *vio = vvp_env_io(env);\r\nLASSERT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE);\r\nreturn vio->cui_io_subtype == IO_NORMAL;\r\n}\r\nstatic bool can_populate_pages(const struct lu_env *env, struct cl_io *io,\r\nstruct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct ccc_io *cio = ccc_env_io(env);\r\nbool rc = true;\r\nswitch (io->ci_type) {\r\ncase CIT_READ:\r\ncase CIT_WRITE:\r\nif (lli->lli_layout_gen != cio->cui_layout_gen) {\r\nio->ci_need_restart = 1;\r\nio->ci_continue = 0;\r\nrc = false;\r\n}\r\ncase CIT_FAULT:\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int vvp_io_fault_iter_init(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct vvp_io *vio = cl2vvp_io(env, ios);\r\nstruct inode *inode = ccc_object_inode(ios->cis_obj);\r\nLASSERT(inode ==\r\ncl2ccc_io(env, ios)->cui_fd->fd_file->f_dentry->d_inode);\r\nvio->u.fault.ft_mtime = LTIME_S(inode->i_mtime);\r\nreturn 0;\r\n}\r\nstatic void vvp_io_fini(const struct lu_env *env, const struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_object *obj = io->ci_obj;\r\nstruct ccc_io *cio = cl2ccc_io(env, ios);\r\nCLOBINVRNT(env, obj, ccc_object_invariant(obj));\r\nCDEBUG(D_VFSTRACE, "ignore/verify layout %d/%d, layout version %d.\n",\r\nio->ci_ignore_layout, io->ci_verify_layout, cio->cui_layout_gen);\r\nif (!io->ci_ignore_layout && io->ci_verify_layout) {\r\n__u32 gen = 0;\r\nll_layout_refresh(ccc_object_inode(obj), &gen);\r\nio->ci_need_restart = cio->cui_layout_gen != gen;\r\nif (io->ci_need_restart)\r\nCDEBUG(D_VFSTRACE, "layout changed from %d to %d.\n",\r\ncio->cui_layout_gen, gen);\r\n}\r\n}\r\nstatic void vvp_io_fault_fini(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_page *page = io->u.ci_fault.ft_page;\r\nCLOBINVRNT(env, io->ci_obj, ccc_object_invariant(io->ci_obj));\r\nif (page != NULL) {\r\nlu_ref_del(&page->cp_reference, "fault", io);\r\ncl_page_put(env, page);\r\nio->u.ci_fault.ft_page = NULL;\r\n}\r\nvvp_io_fini(env, ios);\r\n}\r\nenum cl_lock_mode vvp_mode_from_vma(struct vm_area_struct *vma)\r\n{\r\nif ((vma->vm_flags & VM_SHARED) && (vma->vm_flags & VM_WRITE))\r\nreturn CLM_WRITE;\r\nreturn CLM_READ;\r\n}\r\nstatic int vvp_mmap_locks(const struct lu_env *env,\r\nstruct ccc_io *vio, struct cl_io *io)\r\n{\r\nstruct ccc_thread_info *cti = ccc_env_info(env);\r\nstruct mm_struct *mm = current->mm;\r\nstruct vm_area_struct *vma;\r\nstruct cl_lock_descr *descr = &cti->cti_descr;\r\nldlm_policy_data_t policy;\r\nunsigned long addr;\r\nunsigned long seg;\r\nssize_t count;\r\nint result;\r\nLASSERT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE);\r\nif (!cl_is_normalio(env, io))\r\nreturn 0;\r\nif (vio->cui_iov == NULL)\r\nreturn 0;\r\nif (mm == NULL)\r\nreturn 0;\r\nfor (seg = 0; seg < vio->cui_nrsegs; seg++) {\r\nconst struct iovec *iv = &vio->cui_iov[seg];\r\naddr = (unsigned long)iv->iov_base;\r\ncount = iv->iov_len;\r\nif (count == 0)\r\ncontinue;\r\ncount += addr & (~CFS_PAGE_MASK);\r\naddr &= CFS_PAGE_MASK;\r\ndown_read(&mm->mmap_sem);\r\nwhile((vma = our_vma(mm, addr, count)) != NULL) {\r\nstruct inode *inode = vma->vm_file->f_dentry->d_inode;\r\nint flags = CEF_MUST;\r\nif (ll_file_nolock(vma->vm_file)) {\r\nflags = CEF_NEVER;\r\n}\r\npolicy_from_vma(&policy, vma, addr, count);\r\ndescr->cld_mode = vvp_mode_from_vma(vma);\r\ndescr->cld_obj = ll_i2info(inode)->lli_clob;\r\ndescr->cld_start = cl_index(descr->cld_obj,\r\npolicy.l_extent.start);\r\ndescr->cld_end = cl_index(descr->cld_obj,\r\npolicy.l_extent.end);\r\ndescr->cld_enq_flags = flags;\r\nresult = cl_io_lock_alloc_add(env, io, descr);\r\nCDEBUG(D_VFSTRACE, "lock: %d: [%lu, %lu]\n",\r\ndescr->cld_mode, descr->cld_start,\r\ndescr->cld_end);\r\nif (result < 0)\r\nreturn result;\r\nif (vma->vm_end - addr >= count)\r\nbreak;\r\ncount -= vma->vm_end - addr;\r\naddr = vma->vm_end;\r\n}\r\nup_read(&mm->mmap_sem);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vvp_io_rw_lock(const struct lu_env *env, struct cl_io *io,\r\nenum cl_lock_mode mode, loff_t start, loff_t end)\r\n{\r\nstruct ccc_io *cio = ccc_env_io(env);\r\nint result;\r\nint ast_flags = 0;\r\nLASSERT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE);\r\nccc_io_update_iov(env, cio, io);\r\nif (io->u.ci_rw.crw_nonblock)\r\nast_flags |= CEF_NONBLOCK;\r\nresult = vvp_mmap_locks(env, cio, io);\r\nif (result == 0)\r\nresult = ccc_io_one_lock(env, io, ast_flags, mode, start, end);\r\nreturn result;\r\n}\r\nstatic int vvp_io_read_lock(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct ll_inode_info *lli = ll_i2info(ccc_object_inode(io->ci_obj));\r\nint result;\r\nif (lli->lli_has_smd)\r\nresult = vvp_io_rw_lock(env, io, CLM_READ,\r\nio->u.ci_rd.rd.crw_pos,\r\nio->u.ci_rd.rd.crw_pos +\r\nio->u.ci_rd.rd.crw_count - 1);\r\nelse\r\nresult = 0;\r\nreturn result;\r\n}\r\nstatic int vvp_io_fault_lock(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct vvp_io *vio = cl2vvp_io(env, ios);\r\nreturn ccc_io_one_lock_index\r\n(env, io, 0, vvp_mode_from_vma(vio->u.fault.ft_vma),\r\nio->u.ci_fault.ft_index, io->u.ci_fault.ft_index);\r\n}\r\nstatic int vvp_io_write_lock(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nloff_t start;\r\nloff_t end;\r\nif (io->u.ci_wr.wr_append) {\r\nstart = 0;\r\nend = OBD_OBJECT_EOF;\r\n} else {\r\nstart = io->u.ci_wr.wr.crw_pos;\r\nend = start + io->u.ci_wr.wr.crw_count - 1;\r\n}\r\nreturn vvp_io_rw_lock(env, io, CLM_WRITE, start, end);\r\n}\r\nstatic int vvp_io_setattr_iter_init(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vvp_io_setattr_lock(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct ccc_io *cio = ccc_env_io(env);\r\nstruct cl_io *io = ios->cis_io;\r\n__u64 new_size;\r\n__u32 enqflags = 0;\r\nif (cl_io_is_trunc(io)) {\r\nnew_size = io->u.ci_setattr.sa_attr.lvb_size;\r\nif (new_size == 0)\r\nenqflags = CEF_DISCARD_DATA;\r\n} else {\r\nif ((io->u.ci_setattr.sa_attr.lvb_mtime >=\r\nio->u.ci_setattr.sa_attr.lvb_ctime) ||\r\n(io->u.ci_setattr.sa_attr.lvb_atime >=\r\nio->u.ci_setattr.sa_attr.lvb_ctime))\r\nreturn 0;\r\nnew_size = 0;\r\n}\r\ncio->u.setattr.cui_local_lock = SETATTR_EXTENT_LOCK;\r\nreturn ccc_io_one_lock(env, io, enqflags, CLM_WRITE,\r\nnew_size, OBD_OBJECT_EOF);\r\n}\r\nstatic int vvp_do_vmtruncate(struct inode *inode, size_t size)\r\n{\r\nint result;\r\nll_inode_size_lock(inode);\r\nresult = inode_newsize_ok(inode, size);\r\nif (result < 0) {\r\nll_inode_size_unlock(inode);\r\nreturn result;\r\n}\r\ntruncate_setsize(inode, size);\r\nll_inode_size_unlock(inode);\r\nreturn result;\r\n}\r\nstatic int vvp_io_setattr_trunc(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nstruct inode *inode, loff_t size)\r\n{\r\ninode_dio_wait(inode);\r\nreturn 0;\r\n}\r\nstatic int vvp_io_setattr_time(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_object *obj = io->ci_obj;\r\nstruct cl_attr *attr = ccc_env_thread_attr(env);\r\nint result;\r\nunsigned valid = CAT_CTIME;\r\ncl_object_attr_lock(obj);\r\nattr->cat_ctime = io->u.ci_setattr.sa_attr.lvb_ctime;\r\nif (io->u.ci_setattr.sa_valid & ATTR_ATIME_SET) {\r\nattr->cat_atime = io->u.ci_setattr.sa_attr.lvb_atime;\r\nvalid |= CAT_ATIME;\r\n}\r\nif (io->u.ci_setattr.sa_valid & ATTR_MTIME_SET) {\r\nattr->cat_mtime = io->u.ci_setattr.sa_attr.lvb_mtime;\r\nvalid |= CAT_MTIME;\r\n}\r\nresult = cl_object_attr_set(env, obj, attr, valid);\r\ncl_object_attr_unlock(obj);\r\nreturn result;\r\n}\r\nstatic int vvp_io_setattr_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct inode *inode = ccc_object_inode(io->ci_obj);\r\nint result = 0;\r\nmutex_lock(&inode->i_mutex);\r\nif (cl_io_is_trunc(io))\r\nresult = vvp_io_setattr_trunc(env, ios, inode,\r\nio->u.ci_setattr.sa_attr.lvb_size);\r\nif (result == 0)\r\nresult = vvp_io_setattr_time(env, ios);\r\nreturn result;\r\n}\r\nstatic void vvp_io_setattr_end(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct inode *inode = ccc_object_inode(io->ci_obj);\r\nif (cl_io_is_trunc(io)) {\r\nvvp_do_vmtruncate(inode, io->u.ci_setattr.sa_attr.lvb_size);\r\ninode_dio_write_done(inode);\r\n}\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nstatic void vvp_io_setattr_fini(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nvvp_io_fini(env, ios);\r\n}\r\nstatic ssize_t lustre_generic_file_read(struct file *file,\r\nstruct ccc_io *vio, loff_t *ppos)\r\n{\r\nreturn generic_file_aio_read(vio->cui_iocb, vio->cui_iov,\r\nvio->cui_nrsegs, *ppos);\r\n}\r\nstatic ssize_t lustre_generic_file_write(struct file *file,\r\nstruct ccc_io *vio, loff_t *ppos)\r\n{\r\nreturn generic_file_aio_write(vio->cui_iocb, vio->cui_iov,\r\nvio->cui_nrsegs, *ppos);\r\n}\r\nstatic int vvp_io_read_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct vvp_io *vio = cl2vvp_io(env, ios);\r\nstruct ccc_io *cio = cl2ccc_io(env, ios);\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_object *obj = io->ci_obj;\r\nstruct inode *inode = ccc_object_inode(obj);\r\nstruct ll_ra_read *bead = &vio->cui_bead;\r\nstruct file *file = cio->cui_fd->fd_file;\r\nint result;\r\nloff_t pos = io->u.ci_rd.rd.crw_pos;\r\nlong cnt = io->u.ci_rd.rd.crw_count;\r\nlong tot = cio->cui_tot_count;\r\nint exceed = 0;\r\nCLOBINVRNT(env, obj, ccc_object_invariant(obj));\r\nCDEBUG(D_VFSTRACE, "read: -> [%lli, %lli)\n", pos, pos + cnt);\r\nif (!can_populate_pages(env, io, inode))\r\nreturn 0;\r\nresult = ccc_prep_size(env, obj, io, pos, tot, &exceed);\r\nif (result != 0)\r\nreturn result;\r\nelse if (exceed != 0)\r\ngoto out;\r\nLU_OBJECT_HEADER(D_INODE, env, &obj->co_lu,\r\n"Read ino %lu, %lu bytes, offset %lld, size %llu\n",\r\ninode->i_ino, cnt, pos, i_size_read(inode));\r\ncio->cui_fd->fd_file->f_ra.ra_pages = 0;\r\nif (!vio->cui_ra_window_set) {\r\nvio->cui_ra_window_set = 1;\r\nbead->lrr_start = cl_index(obj, pos);\r\nbead->lrr_count = cl_index(obj, tot + PAGE_CACHE_SIZE - 1);\r\nll_ra_read_in(file, bead);\r\n}\r\nfile_accessed(file);\r\nswitch (vio->cui_io_subtype) {\r\ncase IO_NORMAL:\r\nresult = lustre_generic_file_read(file, cio, &pos);\r\nbreak;\r\ncase IO_SPLICE:\r\nresult = generic_file_splice_read(file, &pos,\r\nvio->u.splice.cui_pipe, cnt,\r\nvio->u.splice.cui_flags);\r\nio->ci_continue = 0;\r\nbreak;\r\ndefault:\r\nCERROR("Wrong IO type %u\n", vio->cui_io_subtype);\r\nLBUG();\r\n}\r\nout:\r\nif (result >= 0) {\r\nif (result < cnt)\r\nio->ci_continue = 0;\r\nio->ci_nob += result;\r\nll_rw_stats_tally(ll_i2sbi(inode), current->pid,\r\ncio->cui_fd, pos, result, READ);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic void vvp_io_read_fini(const struct lu_env *env, const struct cl_io_slice *ios)\r\n{\r\nstruct vvp_io *vio = cl2vvp_io(env, ios);\r\nstruct ccc_io *cio = cl2ccc_io(env, ios);\r\nif (vio->cui_ra_window_set)\r\nll_ra_read_ex(cio->cui_fd->fd_file, &vio->cui_bead);\r\nvvp_io_fini(env, ios);\r\n}\r\nstatic int vvp_io_write_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct ccc_io *cio = cl2ccc_io(env, ios);\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_object *obj = io->ci_obj;\r\nstruct inode *inode = ccc_object_inode(obj);\r\nstruct file *file = cio->cui_fd->fd_file;\r\nssize_t result = 0;\r\nloff_t pos = io->u.ci_wr.wr.crw_pos;\r\nsize_t cnt = io->u.ci_wr.wr.crw_count;\r\nif (!can_populate_pages(env, io, inode))\r\nreturn 0;\r\nif (cl_io_is_append(io)) {\r\npos = io->u.ci_wr.wr.crw_pos = i_size_read(inode);\r\ncio->cui_iocb->ki_pos = pos;\r\n}\r\nCDEBUG(D_VFSTRACE, "write: [%lli, %lli)\n", pos, pos + (long long)cnt);\r\nif (cio->cui_iov == NULL)\r\nresult = 0;\r\nelse\r\nresult = lustre_generic_file_write(file, cio, &pos);\r\nif (result > 0) {\r\nif (result < cnt)\r\nio->ci_continue = 0;\r\nio->ci_nob += result;\r\nll_rw_stats_tally(ll_i2sbi(inode), current->pid,\r\ncio->cui_fd, pos, result, WRITE);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic int vvp_io_kernel_fault(struct vvp_fault_io *cfio)\r\n{\r\nstruct vm_fault *vmf = cfio->fault.ft_vmf;\r\ncfio->fault.ft_flags = filemap_fault(cfio->ft_vma, vmf);\r\nif (vmf->page) {\r\nLL_CDEBUG_PAGE(D_PAGE, vmf->page, "got addr %p type NOPAGE\n",\r\nvmf->virtual_address);\r\nif (unlikely(!(cfio->fault.ft_flags & VM_FAULT_LOCKED))) {\r\nlock_page(vmf->page);\r\ncfio->fault.ft_flags &= VM_FAULT_LOCKED;\r\n}\r\ncfio->ft_vmpage = vmf->page;\r\nreturn 0;\r\n}\r\nif (cfio->fault.ft_flags & VM_FAULT_SIGBUS) {\r\nCDEBUG(D_PAGE, "got addr %p - SIGBUS\n", vmf->virtual_address);\r\nreturn -EFAULT;\r\n}\r\nif (cfio->fault.ft_flags & VM_FAULT_OOM) {\r\nCDEBUG(D_PAGE, "got addr %p - OOM\n", vmf->virtual_address);\r\nreturn -ENOMEM;\r\n}\r\nif (cfio->fault.ft_flags & VM_FAULT_RETRY)\r\nreturn -EAGAIN;\r\nCERROR("unknow error in page fault %d!\n", cfio->fault.ft_flags);\r\nreturn -EINVAL;\r\n}\r\nstatic int vvp_io_fault_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nstruct vvp_io *vio = cl2vvp_io(env, ios);\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_object *obj = io->ci_obj;\r\nstruct inode *inode = ccc_object_inode(obj);\r\nstruct cl_fault_io *fio = &io->u.ci_fault;\r\nstruct vvp_fault_io *cfio = &vio->u.fault;\r\nloff_t offset;\r\nint result = 0;\r\nstruct page *vmpage = NULL;\r\nstruct cl_page *page;\r\nloff_t size;\r\npgoff_t last;\r\nif (fio->ft_executable &&\r\nLTIME_S(inode->i_mtime) != vio->u.fault.ft_mtime)\r\nCWARN("binary "DFID\r\n" changed while waiting for the page fault lock\n",\r\nPFID(lu_object_fid(&obj->co_lu)));\r\noffset = cl_offset(obj, fio->ft_index + 1) - 1;\r\nLASSERT(cl_index(obj, offset) == fio->ft_index);\r\nresult = ccc_prep_size(env, obj, io, 0, offset + 1, NULL);\r\nif (result != 0)\r\nreturn result;\r\nif (fio->ft_mkwrite) {\r\nLASSERT(cfio->ft_vmpage != NULL);\r\nlock_page(cfio->ft_vmpage);\r\n} else {\r\nresult = vvp_io_kernel_fault(cfio);\r\nif (result != 0)\r\nreturn result;\r\n}\r\nvmpage = cfio->ft_vmpage;\r\nLASSERT(PageLocked(vmpage));\r\nif (OBD_FAIL_CHECK(OBD_FAIL_LLITE_FAULT_TRUNC_RACE))\r\nll_invalidate_page(vmpage);\r\nsize = i_size_read(inode);\r\nif (unlikely((vmpage->mapping != inode->i_mapping) ||\r\n(page_offset(vmpage) > size))) {\r\nCDEBUG(D_PAGE, "llite: fault and truncate race happened!\n");\r\nGOTO(out, result = +1);\r\n}\r\nif (fio->ft_mkwrite ) {\r\npgoff_t last_index;\r\nlast_index = cl_index(obj, size - 1);\r\nif (last_index < fio->ft_index) {\r\nCDEBUG(D_PAGE,\r\n"llite: mkwrite and truncate race happened: "\r\n"%p: 0x%lx 0x%lx\n",\r\nvmpage->mapping,fio->ft_index,last_index);\r\nGOTO(out, result = -ENODATA);\r\n}\r\n}\r\npage = cl_page_find(env, obj, fio->ft_index, vmpage, CPT_CACHEABLE);\r\nif (IS_ERR(page))\r\nGOTO(out, result = PTR_ERR(page));\r\nif (fio->ft_mkwrite) {\r\nwait_on_page_writeback(vmpage);\r\nif (set_page_dirty(vmpage)) {\r\nstruct ccc_page *cp;\r\ncl_page_assume(env, io, page);\r\ncp = cl2ccc_page(cl_page_at(page, &vvp_device_type));\r\nvvp_write_pending(cl2ccc(obj), cp);\r\nresult = cl_page_cache_add(env, io, page, CRT_WRITE);\r\nLASSERT(cl_page_is_owned(page, io));\r\nvmpage = NULL;\r\nif (result < 0) {\r\ncl_page_unmap(env, io, page);\r\ncl_page_discard(env, io, page);\r\ncl_page_disown(env, io, page);\r\ncl_page_put(env, page);\r\nif (result == -EDQUOT)\r\nresult = -ENOSPC;\r\nGOTO(out, result);\r\n} else\r\ncl_page_disown(env, io, page);\r\n}\r\n}\r\nlast = cl_index(obj, size - 1);\r\nLASSERT(!fio->ft_mkwrite || fio->ft_index <= last);\r\nif (fio->ft_index == last)\r\nfio->ft_nob = size - cl_offset(obj, fio->ft_index);\r\nelse\r\nfio->ft_nob = cl_page_size(obj);\r\nlu_ref_add(&page->cp_reference, "fault", io);\r\nfio->ft_page = page;\r\nout:\r\nif (vmpage != NULL)\r\nunlock_page(vmpage);\r\ncfio->fault.ft_flags &= ~VM_FAULT_LOCKED;\r\nreturn result;\r\n}\r\nstatic int vvp_io_fsync_start(const struct lu_env *env,\r\nconst struct cl_io_slice *ios)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vvp_io_read_page(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct cl_io *io = ios->cis_io;\r\nstruct cl_object *obj = slice->cpl_obj;\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct cl_page *page = slice->cpl_page;\r\nstruct inode *inode = ccc_object_inode(obj);\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct ll_file_data *fd = cl2ccc_io(env, ios)->cui_fd;\r\nstruct ll_readahead_state *ras = &fd->fd_ras;\r\nstruct page *vmpage = cp->cpg_page;\r\nstruct cl_2queue *queue = &io->ci_queue;\r\nint rc;\r\nCLOBINVRNT(env, obj, ccc_object_invariant(obj));\r\nLASSERT(slice->cpl_obj == obj);\r\nif (sbi->ll_ra_info.ra_max_pages_per_file &&\r\nsbi->ll_ra_info.ra_max_pages)\r\nras_update(sbi, inode, ras, page->cp_index,\r\ncp->cpg_defer_uptodate);\r\nrc = cl_page_is_under_lock(env, io, page);\r\nif (rc != -EBUSY) {\r\nCL_PAGE_HEADER(D_WARNING, env, page, "%s: %d\n",\r\nrc == -ENODATA ? "without a lock" :\r\n"match failed", rc);\r\nif (rc != -ENODATA)\r\nreturn rc;\r\n}\r\nif (cp->cpg_defer_uptodate) {\r\ncp->cpg_ra_used = 1;\r\ncl_page_export(env, page, 1);\r\n}\r\ncl_2queue_add(queue, page);\r\nif (sbi->ll_ra_info.ra_max_pages_per_file &&\r\nsbi->ll_ra_info.ra_max_pages)\r\nll_readahead(env, io, ras,\r\nvmpage->mapping, &queue->c2_qin, fd->fd_flags);\r\nreturn 0;\r\n}\r\nstatic int vvp_page_sync_io(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page *page, struct ccc_page *cp,\r\nenum cl_req_type crt)\r\n{\r\nstruct cl_2queue *queue;\r\nint result;\r\nLASSERT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE);\r\nqueue = &io->ci_queue;\r\ncl_2queue_init_page(queue, page);\r\nresult = cl_io_submit_sync(env, io, crt, queue, 0);\r\nLASSERT(cl_page_is_owned(page, io));\r\nif (crt == CRT_READ)\r\ncl_page_list_disown(env, io, &queue->c2_qin);\r\ncl_2queue_fini(env, queue);\r\nreturn result;\r\n}\r\nstatic int vvp_io_prepare_partial(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_object *obj, struct cl_page *pg,\r\nstruct ccc_page *cp,\r\nunsigned from, unsigned to)\r\n{\r\nstruct cl_attr *attr = ccc_env_thread_attr(env);\r\nloff_t offset = cl_offset(obj, pg->cp_index);\r\nint result;\r\ncl_object_attr_lock(obj);\r\nresult = cl_object_attr_get(env, obj, attr);\r\ncl_object_attr_unlock(obj);\r\nif (result == 0) {\r\nif (attr->cat_kms <= offset) {\r\nchar *kaddr = kmap_atomic(cp->cpg_page);\r\nmemset(kaddr, 0, cl_page_size(obj));\r\nkunmap_atomic(kaddr);\r\n} else if (cp->cpg_defer_uptodate)\r\ncp->cpg_ra_used = 1;\r\nelse\r\nresult = vvp_page_sync_io(env, io, pg, cp, CRT_READ);\r\nif (result == 0)\r\ncl_page_export(env, pg, 1);\r\n}\r\nreturn result;\r\n}\r\nstatic int vvp_io_prepare_write(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice,\r\nunsigned from, unsigned to)\r\n{\r\nstruct cl_object *obj = slice->cpl_obj;\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nstruct page *vmpage = cp->cpg_page;\r\nint result;\r\nLINVRNT(cl_page_is_vmlocked(env, pg));\r\nLASSERT(vmpage->mapping->host == ccc_object_inode(obj));\r\nresult = 0;\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "preparing: [%d, %d]\n", from, to);\r\nif (!PageUptodate(vmpage)) {\r\nif (from == 0 && to == PAGE_CACHE_SIZE) {\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "full page write\n");\r\nPOISON_PAGE(page, 0x11);\r\n} else\r\nresult = vvp_io_prepare_partial(env, ios->cis_io, obj,\r\npg, cp, from, to);\r\n} else\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "uptodate\n");\r\nreturn result;\r\n}\r\nstatic int vvp_io_commit_write(const struct lu_env *env,\r\nconst struct cl_io_slice *ios,\r\nconst struct cl_page_slice *slice,\r\nunsigned from, unsigned to)\r\n{\r\nstruct cl_object *obj = slice->cpl_obj;\r\nstruct cl_io *io = ios->cis_io;\r\nstruct ccc_page *cp = cl2ccc_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nstruct inode *inode = ccc_object_inode(obj);\r\nstruct ll_sb_info *sbi = ll_i2sbi(inode);\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct page *vmpage = cp->cpg_page;\r\nint result;\r\nint tallyop;\r\nloff_t size;\r\nLINVRNT(cl_page_is_vmlocked(env, pg));\r\nLASSERT(vmpage->mapping->host == inode);\r\nLU_OBJECT_HEADER(D_INODE, env, &obj->co_lu, "committing page write\n");\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "committing: [%d, %d]\n", from, to);\r\nif (!PageDirty(vmpage)) {\r\ntallyop = LPROC_LL_DIRTY_MISSES;\r\nresult = cl_page_cache_add(env, io, pg, CRT_WRITE);\r\nif (result == 0) {\r\nset_page_dirty(vmpage);\r\nvvp_write_pending(cl2ccc(obj), cp);\r\n} else if (result == -EDQUOT) {\r\npgoff_t last_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;\r\nbool need_clip = true;\r\nif (last_index > pg->cp_index) {\r\nto = PAGE_CACHE_SIZE;\r\nneed_clip = false;\r\n} else if (last_index == pg->cp_index) {\r\nint size_to = i_size_read(inode) & ~CFS_PAGE_MASK;\r\nif (to < size_to)\r\nto = size_to;\r\n}\r\nif (need_clip)\r\ncl_page_clip(env, pg, 0, to);\r\nresult = vvp_page_sync_io(env, io, pg, cp, CRT_WRITE);\r\nif (result)\r\nCERROR("Write page %lu of inode %p failed %d\n",\r\npg->cp_index, inode, result);\r\n}\r\n} else {\r\ntallyop = LPROC_LL_DIRTY_HITS;\r\nresult = 0;\r\n}\r\nll_stats_ops_tally(sbi, tallyop, 1);\r\nif (result == 0) {\r\nspin_lock(&lli->lli_lock);\r\nlli->lli_flags |= LLIF_DATA_MODIFIED;\r\nspin_unlock(&lli->lli_lock);\r\n}\r\nsize = cl_offset(obj, pg->cp_index) + to;\r\nll_inode_size_lock(inode);\r\nif (result == 0) {\r\nif (size > i_size_read(inode)) {\r\ncl_isize_write_nolock(inode, size);\r\nCDEBUG(D_VFSTRACE, DFID" updating i_size %lu\n",\r\nPFID(lu_object_fid(&obj->co_lu)),\r\n(unsigned long)size);\r\n}\r\ncl_page_export(env, pg, 1);\r\n} else {\r\nif (size > i_size_read(inode))\r\ncl_page_discard(env, io, pg);\r\n}\r\nll_inode_size_unlock(inode);\r\nreturn result;\r\n}\r\nint vvp_io_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_io *io)\r\n{\r\nstruct vvp_io *vio = vvp_env_io(env);\r\nstruct ccc_io *cio = ccc_env_io(env);\r\nstruct inode *inode = ccc_object_inode(obj);\r\nint result;\r\nCLOBINVRNT(env, obj, ccc_object_invariant(obj));\r\nCL_IO_SLICE_CLEAN(cio, cui_cl);\r\ncl_io_slice_add(io, &cio->cui_cl, obj, &vvp_io_ops);\r\nvio->cui_ra_window_set = 0;\r\nresult = 0;\r\nif (io->ci_type == CIT_READ || io->ci_type == CIT_WRITE) {\r\nsize_t count;\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\ncount = io->u.ci_rw.crw_count;\r\nif (count == 0)\r\nresult = 1;\r\nelse {\r\ncio->cui_tot_count = count;\r\ncio->cui_tot_nrsegs = 0;\r\n}\r\nlustre_get_jobid(lli->lli_jobid);\r\n} else if (io->ci_type == CIT_SETATTR) {\r\nif (!cl_io_is_trunc(io))\r\nio->ci_lockreq = CILR_MANDATORY;\r\n}\r\nif (io->ci_type == CIT_MISC && !io->ci_verify_layout)\r\nio->ci_ignore_layout = 1;\r\nif (result == 0 && !io->ci_ignore_layout) {\r\nresult = ll_layout_refresh(inode, &cio->cui_layout_gen);\r\nif (result == -ENOENT)\r\nresult = 0;\r\nif (result < 0)\r\nCERROR("%s: refresh file layout " DFID " error %d.\n",\r\nll_get_fsname(inode->i_sb, NULL, 0),\r\nPFID(lu_object_fid(&obj->co_lu)), result);\r\n}\r\nreturn result;\r\n}\r\nstatic struct vvp_io *cl2vvp_io(const struct lu_env *env,\r\nconst struct cl_io_slice *slice)\r\n{\r\ncl2ccc_io(env, slice);\r\nreturn vvp_env_io(env);\r\n}
