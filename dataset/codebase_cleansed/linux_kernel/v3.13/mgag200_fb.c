static void mga_dirty_update(struct mga_fbdev *mfbdev,\r\nint x, int y, int width, int height)\r\n{\r\nint i;\r\nstruct drm_gem_object *obj;\r\nstruct mgag200_bo *bo;\r\nint src_offset, dst_offset;\r\nint bpp = (mfbdev->mfb.base.bits_per_pixel + 7)/8;\r\nint ret = -EBUSY;\r\nbool unmap = false;\r\nbool store_for_later = false;\r\nint x2, y2;\r\nunsigned long flags;\r\nobj = mfbdev->mfb.obj;\r\nbo = gem_to_mga_bo(obj);\r\nif (!in_interrupt())\r\nret = mgag200_bo_reserve(bo, true);\r\nif (ret) {\r\nif (ret != -EBUSY)\r\nreturn;\r\nstore_for_later = true;\r\n}\r\nx2 = x + width - 1;\r\ny2 = y + height - 1;\r\nspin_lock_irqsave(&mfbdev->dirty_lock, flags);\r\nif (mfbdev->y1 < y)\r\ny = mfbdev->y1;\r\nif (mfbdev->y2 > y2)\r\ny2 = mfbdev->y2;\r\nif (mfbdev->x1 < x)\r\nx = mfbdev->x1;\r\nif (mfbdev->x2 > x2)\r\nx2 = mfbdev->x2;\r\nif (store_for_later) {\r\nmfbdev->x1 = x;\r\nmfbdev->x2 = x2;\r\nmfbdev->y1 = y;\r\nmfbdev->y2 = y2;\r\nspin_unlock_irqrestore(&mfbdev->dirty_lock, flags);\r\nreturn;\r\n}\r\nmfbdev->x1 = mfbdev->y1 = INT_MAX;\r\nmfbdev->x2 = mfbdev->y2 = 0;\r\nspin_unlock_irqrestore(&mfbdev->dirty_lock, flags);\r\nif (!bo->kmap.virtual) {\r\nret = ttm_bo_kmap(&bo->bo, 0, bo->bo.num_pages, &bo->kmap);\r\nif (ret) {\r\nDRM_ERROR("failed to kmap fb updates\n");\r\nmgag200_bo_unreserve(bo);\r\nreturn;\r\n}\r\nunmap = true;\r\n}\r\nfor (i = y; i <= y2; i++) {\r\nsrc_offset = dst_offset = i * mfbdev->mfb.base.pitches[0] + (x * bpp);\r\nmemcpy_toio(bo->kmap.virtual + src_offset, mfbdev->sysram + src_offset, (x2 - x + 1) * bpp);\r\n}\r\nif (unmap)\r\nttm_bo_kunmap(&bo->kmap);\r\nmgag200_bo_unreserve(bo);\r\n}\r\nstatic void mga_fillrect(struct fb_info *info,\r\nconst struct fb_fillrect *rect)\r\n{\r\nstruct mga_fbdev *mfbdev = info->par;\r\nsys_fillrect(info, rect);\r\nmga_dirty_update(mfbdev, rect->dx, rect->dy, rect->width,\r\nrect->height);\r\n}\r\nstatic void mga_copyarea(struct fb_info *info,\r\nconst struct fb_copyarea *area)\r\n{\r\nstruct mga_fbdev *mfbdev = info->par;\r\nsys_copyarea(info, area);\r\nmga_dirty_update(mfbdev, area->dx, area->dy, area->width,\r\narea->height);\r\n}\r\nstatic void mga_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct mga_fbdev *mfbdev = info->par;\r\nsys_imageblit(info, image);\r\nmga_dirty_update(mfbdev, image->dx, image->dy, image->width,\r\nimage->height);\r\n}\r\nstatic int mgag200fb_create_object(struct mga_fbdev *afbdev,\r\nstruct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object **gobj_p)\r\n{\r\nstruct drm_device *dev = afbdev->helper.dev;\r\nu32 size;\r\nstruct drm_gem_object *gobj;\r\nint ret = 0;\r\nsize = mode_cmd->pitches[0] * mode_cmd->height;\r\nret = mgag200_gem_create(dev, size, true, &gobj);\r\nif (ret)\r\nreturn ret;\r\n*gobj_p = gobj;\r\nreturn ret;\r\n}\r\nstatic int mgag200fb_create(struct drm_fb_helper *helper,\r\nstruct drm_fb_helper_surface_size *sizes)\r\n{\r\nstruct mga_fbdev *mfbdev = (struct mga_fbdev *)helper;\r\nstruct drm_device *dev = mfbdev->helper.dev;\r\nstruct drm_mode_fb_cmd2 mode_cmd;\r\nstruct mga_device *mdev = dev->dev_private;\r\nstruct fb_info *info;\r\nstruct drm_framebuffer *fb;\r\nstruct drm_gem_object *gobj = NULL;\r\nstruct device *device = &dev->pdev->dev;\r\nstruct mgag200_bo *bo;\r\nint ret;\r\nvoid *sysram;\r\nint size;\r\nmode_cmd.width = sizes->surface_width;\r\nmode_cmd.height = sizes->surface_height;\r\nmode_cmd.pitches[0] = mode_cmd.width * ((sizes->surface_bpp + 7) / 8);\r\nmode_cmd.pixel_format = drm_mode_legacy_fb_format(sizes->surface_bpp,\r\nsizes->surface_depth);\r\nsize = mode_cmd.pitches[0] * mode_cmd.height;\r\nret = mgag200fb_create_object(mfbdev, &mode_cmd, &gobj);\r\nif (ret) {\r\nDRM_ERROR("failed to create fbcon backing object %d\n", ret);\r\nreturn ret;\r\n}\r\nbo = gem_to_mga_bo(gobj);\r\nsysram = vmalloc(size);\r\nif (!sysram)\r\nreturn -ENOMEM;\r\ninfo = framebuffer_alloc(0, device);\r\nif (info == NULL)\r\nreturn -ENOMEM;\r\ninfo->par = mfbdev;\r\nret = mgag200_framebuffer_init(dev, &mfbdev->mfb, &mode_cmd, gobj);\r\nif (ret)\r\nreturn ret;\r\nmfbdev->sysram = sysram;\r\nmfbdev->size = size;\r\nfb = &mfbdev->mfb.base;\r\nmfbdev->helper.fb = fb;\r\nmfbdev->helper.fbdev = info;\r\nret = fb_alloc_cmap(&info->cmap, 256, 0);\r\nif (ret) {\r\nDRM_ERROR("%s: can't allocate color map\n", info->fix.id);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nstrcpy(info->fix.id, "mgadrmfb");\r\ninfo->flags = FBINFO_DEFAULT | FBINFO_CAN_FORCE_OUTPUT;\r\ninfo->fbops = &mgag200fb_ops;\r\ninfo->apertures = alloc_apertures(1);\r\nif (!info->apertures) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ninfo->apertures->ranges[0].base = mdev->dev->mode_config.fb_base;\r\ninfo->apertures->ranges[0].size = mdev->mc.vram_size;\r\ndrm_fb_helper_fill_fix(info, fb->pitches[0], fb->depth);\r\ndrm_fb_helper_fill_var(info, &mfbdev->helper, sizes->fb_width,\r\nsizes->fb_height);\r\ninfo->screen_base = sysram;\r\ninfo->screen_size = size;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\nDRM_DEBUG_KMS("allocated %dx%d\n",\r\nfb->width, fb->height);\r\nreturn 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int mga_fbdev_destroy(struct drm_device *dev,\r\nstruct mga_fbdev *mfbdev)\r\n{\r\nstruct fb_info *info;\r\nstruct mga_framebuffer *mfb = &mfbdev->mfb;\r\nif (mfbdev->helper.fbdev) {\r\ninfo = mfbdev->helper.fbdev;\r\nunregister_framebuffer(info);\r\nif (info->cmap.len)\r\nfb_dealloc_cmap(&info->cmap);\r\nframebuffer_release(info);\r\n}\r\nif (mfb->obj) {\r\ndrm_gem_object_unreference_unlocked(mfb->obj);\r\nmfb->obj = NULL;\r\n}\r\ndrm_fb_helper_fini(&mfbdev->helper);\r\nvfree(mfbdev->sysram);\r\ndrm_framebuffer_unregister_private(&mfb->base);\r\ndrm_framebuffer_cleanup(&mfb->base);\r\nreturn 0;\r\n}\r\nint mgag200_fbdev_init(struct mga_device *mdev)\r\n{\r\nstruct mga_fbdev *mfbdev;\r\nint ret;\r\nmfbdev = devm_kzalloc(mdev->dev->dev, sizeof(struct mga_fbdev), GFP_KERNEL);\r\nif (!mfbdev)\r\nreturn -ENOMEM;\r\nmdev->mfbdev = mfbdev;\r\nmfbdev->helper.funcs = &mga_fb_helper_funcs;\r\nspin_lock_init(&mfbdev->dirty_lock);\r\nret = drm_fb_helper_init(mdev->dev, &mfbdev->helper,\r\nmdev->num_crtc, MGAG200FB_CONN_LIMIT);\r\nif (ret)\r\nreturn ret;\r\ndrm_fb_helper_single_add_all_connectors(&mfbdev->helper);\r\ndrm_helper_disable_unused_functions(mdev->dev);\r\ndrm_fb_helper_initial_config(&mfbdev->helper, 32);\r\nreturn 0;\r\n}\r\nvoid mgag200_fbdev_fini(struct mga_device *mdev)\r\n{\r\nif (!mdev->mfbdev)\r\nreturn;\r\nmga_fbdev_destroy(mdev->dev, mdev->mfbdev);\r\n}
