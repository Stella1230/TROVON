static int size_to_chunks(int size)\r\n{\r\nreturn (size + CHUNK_SIZE - 1) >> CHUNK_SHIFT;\r\n}\r\nstatic struct zbud_header *init_zbud_page(struct page *page)\r\n{\r\nstruct zbud_header *zhdr = page_address(page);\r\nzhdr->first_chunks = 0;\r\nzhdr->last_chunks = 0;\r\nINIT_LIST_HEAD(&zhdr->buddy);\r\nINIT_LIST_HEAD(&zhdr->lru);\r\nzhdr->under_reclaim = 0;\r\nreturn zhdr;\r\n}\r\nstatic void free_zbud_page(struct zbud_header *zhdr)\r\n{\r\n__free_page(virt_to_page(zhdr));\r\n}\r\nstatic unsigned long encode_handle(struct zbud_header *zhdr, enum buddy bud)\r\n{\r\nunsigned long handle;\r\nhandle = (unsigned long)zhdr;\r\nif (bud == FIRST)\r\nhandle += ZHDR_SIZE_ALIGNED;\r\nelse\r\nhandle += PAGE_SIZE - (zhdr->last_chunks << CHUNK_SHIFT);\r\nreturn handle;\r\n}\r\nstatic struct zbud_header *handle_to_zbud_header(unsigned long handle)\r\n{\r\nreturn (struct zbud_header *)(handle & PAGE_MASK);\r\n}\r\nstatic int num_free_chunks(struct zbud_header *zhdr)\r\n{\r\nreturn NCHUNKS - zhdr->first_chunks - zhdr->last_chunks - 1;\r\n}\r\nstruct zbud_pool *zbud_create_pool(gfp_t gfp, struct zbud_ops *ops)\r\n{\r\nstruct zbud_pool *pool;\r\nint i;\r\npool = kmalloc(sizeof(struct zbud_pool), gfp);\r\nif (!pool)\r\nreturn NULL;\r\nspin_lock_init(&pool->lock);\r\nfor_each_unbuddied_list(i, 0)\r\nINIT_LIST_HEAD(&pool->unbuddied[i]);\r\nINIT_LIST_HEAD(&pool->buddied);\r\nINIT_LIST_HEAD(&pool->lru);\r\npool->pages_nr = 0;\r\npool->ops = ops;\r\nreturn pool;\r\n}\r\nvoid zbud_destroy_pool(struct zbud_pool *pool)\r\n{\r\nkfree(pool);\r\n}\r\nint zbud_alloc(struct zbud_pool *pool, int size, gfp_t gfp,\r\nunsigned long *handle)\r\n{\r\nint chunks, i, freechunks;\r\nstruct zbud_header *zhdr = NULL;\r\nenum buddy bud;\r\nstruct page *page;\r\nif (size <= 0 || gfp & __GFP_HIGHMEM)\r\nreturn -EINVAL;\r\nif (size > PAGE_SIZE - ZHDR_SIZE_ALIGNED - CHUNK_SIZE)\r\nreturn -ENOSPC;\r\nchunks = size_to_chunks(size);\r\nspin_lock(&pool->lock);\r\nzhdr = NULL;\r\nfor_each_unbuddied_list(i, chunks) {\r\nif (!list_empty(&pool->unbuddied[i])) {\r\nzhdr = list_first_entry(&pool->unbuddied[i],\r\nstruct zbud_header, buddy);\r\nlist_del(&zhdr->buddy);\r\nif (zhdr->first_chunks == 0)\r\nbud = FIRST;\r\nelse\r\nbud = LAST;\r\ngoto found;\r\n}\r\n}\r\nspin_unlock(&pool->lock);\r\npage = alloc_page(gfp);\r\nif (!page)\r\nreturn -ENOMEM;\r\nspin_lock(&pool->lock);\r\npool->pages_nr++;\r\nzhdr = init_zbud_page(page);\r\nbud = FIRST;\r\nfound:\r\nif (bud == FIRST)\r\nzhdr->first_chunks = chunks;\r\nelse\r\nzhdr->last_chunks = chunks;\r\nif (zhdr->first_chunks == 0 || zhdr->last_chunks == 0) {\r\nfreechunks = num_free_chunks(zhdr);\r\nlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\r\n} else {\r\nlist_add(&zhdr->buddy, &pool->buddied);\r\n}\r\nif (!list_empty(&zhdr->lru))\r\nlist_del(&zhdr->lru);\r\nlist_add(&zhdr->lru, &pool->lru);\r\n*handle = encode_handle(zhdr, bud);\r\nspin_unlock(&pool->lock);\r\nreturn 0;\r\n}\r\nvoid zbud_free(struct zbud_pool *pool, unsigned long handle)\r\n{\r\nstruct zbud_header *zhdr;\r\nint freechunks;\r\nspin_lock(&pool->lock);\r\nzhdr = handle_to_zbud_header(handle);\r\nif ((handle - ZHDR_SIZE_ALIGNED) & ~PAGE_MASK)\r\nzhdr->last_chunks = 0;\r\nelse\r\nzhdr->first_chunks = 0;\r\nif (zhdr->under_reclaim) {\r\nspin_unlock(&pool->lock);\r\nreturn;\r\n}\r\nlist_del(&zhdr->buddy);\r\nif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\r\nlist_del(&zhdr->lru);\r\nfree_zbud_page(zhdr);\r\npool->pages_nr--;\r\n} else {\r\nfreechunks = num_free_chunks(zhdr);\r\nlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\r\n}\r\nspin_unlock(&pool->lock);\r\n}\r\nint zbud_reclaim_page(struct zbud_pool *pool, unsigned int retries)\r\n{\r\nint i, ret, freechunks;\r\nstruct zbud_header *zhdr;\r\nunsigned long first_handle = 0, last_handle = 0;\r\nspin_lock(&pool->lock);\r\nif (!pool->ops || !pool->ops->evict || list_empty(&pool->lru) ||\r\nretries == 0) {\r\nspin_unlock(&pool->lock);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < retries; i++) {\r\nzhdr = list_tail_entry(&pool->lru, struct zbud_header, lru);\r\nlist_del(&zhdr->lru);\r\nlist_del(&zhdr->buddy);\r\nzhdr->under_reclaim = true;\r\nfirst_handle = 0;\r\nlast_handle = 0;\r\nif (zhdr->first_chunks)\r\nfirst_handle = encode_handle(zhdr, FIRST);\r\nif (zhdr->last_chunks)\r\nlast_handle = encode_handle(zhdr, LAST);\r\nspin_unlock(&pool->lock);\r\nif (first_handle) {\r\nret = pool->ops->evict(pool, first_handle);\r\nif (ret)\r\ngoto next;\r\n}\r\nif (last_handle) {\r\nret = pool->ops->evict(pool, last_handle);\r\nif (ret)\r\ngoto next;\r\n}\r\nnext:\r\nspin_lock(&pool->lock);\r\nzhdr->under_reclaim = false;\r\nif (zhdr->first_chunks == 0 && zhdr->last_chunks == 0) {\r\nfree_zbud_page(zhdr);\r\npool->pages_nr--;\r\nspin_unlock(&pool->lock);\r\nreturn 0;\r\n} else if (zhdr->first_chunks == 0 ||\r\nzhdr->last_chunks == 0) {\r\nfreechunks = num_free_chunks(zhdr);\r\nlist_add(&zhdr->buddy, &pool->unbuddied[freechunks]);\r\n} else {\r\nlist_add(&zhdr->buddy, &pool->buddied);\r\n}\r\nlist_add(&zhdr->lru, &pool->lru);\r\n}\r\nspin_unlock(&pool->lock);\r\nreturn -EAGAIN;\r\n}\r\nvoid *zbud_map(struct zbud_pool *pool, unsigned long handle)\r\n{\r\nreturn (void *)(handle);\r\n}\r\nvoid zbud_unmap(struct zbud_pool *pool, unsigned long handle)\r\n{\r\n}\r\nu64 zbud_get_pool_size(struct zbud_pool *pool)\r\n{\r\nreturn pool->pages_nr;\r\n}\r\nstatic int __init init_zbud(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct zbud_header) > ZHDR_SIZE_ALIGNED);\r\npr_info("loaded\n");\r\nreturn 0;\r\n}\r\nstatic void __exit exit_zbud(void)\r\n{\r\npr_info("unloaded\n");\r\n}
