const char *ll_opcode2str(__u32 opcode)\r\n{\r\n__u32 offset = opcode_offset(opcode);\r\nLASSERTF(offset < LUSTRE_MAX_OPCODES,\r\n"offset %u >= LUSTRE_MAX_OPCODES %u\n",\r\noffset, LUSTRE_MAX_OPCODES);\r\nLASSERTF(ll_rpc_opcode_table[offset].opcode == opcode,\r\n"ll_rpc_opcode_table[%u].opcode %u != opcode %u\n",\r\noffset, ll_rpc_opcode_table[offset].opcode, opcode);\r\nreturn ll_rpc_opcode_table[offset].opname;\r\n}\r\nconst char* ll_eopcode2str(__u32 opcode)\r\n{\r\nLASSERT(ll_eopcode_table[opcode].opcode == opcode);\r\nreturn ll_eopcode_table[opcode].opname;\r\n}\r\nvoid ptlrpc_lprocfs_register(struct proc_dir_entry *root, char *dir,\r\nchar *name, struct proc_dir_entry **procroot_ret,\r\nstruct lprocfs_stats **stats_ret)\r\n{\r\nstruct proc_dir_entry *svc_procroot;\r\nstruct lprocfs_stats *svc_stats;\r\nint i, rc;\r\nunsigned int svc_counter_config = LPROCFS_CNTR_AVGMINMAX |\r\nLPROCFS_CNTR_STDDEV;\r\nLASSERT(*procroot_ret == NULL);\r\nLASSERT(*stats_ret == NULL);\r\nsvc_stats = lprocfs_alloc_stats(EXTRA_MAX_OPCODES+LUSTRE_MAX_OPCODES,0);\r\nif (svc_stats == NULL)\r\nreturn;\r\nif (dir) {\r\nsvc_procroot = lprocfs_register(dir, root, NULL, NULL);\r\nif (IS_ERR(svc_procroot)) {\r\nlprocfs_free_stats(&svc_stats);\r\nreturn;\r\n}\r\n} else {\r\nsvc_procroot = root;\r\n}\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQWAIT_CNTR,\r\nsvc_counter_config, "req_waittime", "usec");\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQQDEPTH_CNTR,\r\nsvc_counter_config, "req_qdepth", "reqs");\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQACTIVE_CNTR,\r\nsvc_counter_config, "req_active", "reqs");\r\nlprocfs_counter_init(svc_stats, PTLRPC_TIMEOUT,\r\nsvc_counter_config, "req_timeout", "sec");\r\nlprocfs_counter_init(svc_stats, PTLRPC_REQBUF_AVAIL_CNTR,\r\nsvc_counter_config, "reqbuf_avail", "bufs");\r\nfor (i = 0; i < EXTRA_LAST_OPC; i++) {\r\nchar *units;\r\nswitch(i) {\r\ncase BRW_WRITE_BYTES:\r\ncase BRW_READ_BYTES:\r\nunits = "bytes";\r\nbreak;\r\ndefault:\r\nunits = "reqs";\r\nbreak;\r\n}\r\nlprocfs_counter_init(svc_stats, PTLRPC_LAST_CNTR + i,\r\nsvc_counter_config,\r\nll_eopcode2str(i), units);\r\n}\r\nfor (i = 0; i < LUSTRE_MAX_OPCODES; i++) {\r\n__u32 opcode = ll_rpc_opcode_table[i].opcode;\r\nlprocfs_counter_init(svc_stats,\r\nEXTRA_MAX_OPCODES + i, svc_counter_config,\r\nll_opcode2str(opcode), "usec");\r\n}\r\nrc = lprocfs_register_stats(svc_procroot, name, svc_stats);\r\nif (rc < 0) {\r\nif (dir)\r\nlprocfs_remove(&svc_procroot);\r\nlprocfs_free_stats(&svc_stats);\r\n} else {\r\nif (dir)\r\n*procroot_ret = svc_procroot;\r\n*stats_ret = svc_stats;\r\n}\r\n}\r\nstatic int\r\nptlrpc_lprocfs_req_history_len_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nint total = 0;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\ntotal += svcpt->scp_hist_nrqbds;\r\nreturn seq_printf(m, "%d\n", total);\r\n}\r\nstatic int\r\nptlrpc_lprocfs_req_history_max_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nint total = 0;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\ntotal += svc->srv_hist_nrqbds_cpt_max;\r\nreturn seq_printf(m, "%d\n", total);\r\n}\r\nstatic ssize_t\r\nptlrpc_lprocfs_req_history_max_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nint bufpages;\r\nint val;\r\nint rc;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val < 0)\r\nreturn -ERANGE;\r\nbufpages = (svc->srv_buf_size + PAGE_CACHE_SIZE - 1) >> PAGE_CACHE_SHIFT;\r\nif (val > totalram_pages / (2 * bufpages))\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nif (val == 0)\r\nsvc->srv_hist_nrqbds_cpt_max = 0;\r\nelse\r\nsvc->srv_hist_nrqbds_cpt_max = max(1, (val / svc->srv_ncpts));\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic int\r\nptlrpc_lprocfs_threads_min_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nreturn seq_printf(m, "%d\n",\r\nsvc->srv_nthrs_cpt_init * svc->srv_ncpts);\r\n}\r\nstatic ssize_t\r\nptlrpc_lprocfs_threads_min_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nint val;\r\nint rc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val / svc->srv_ncpts < PTLRPC_NTHRS_INIT)\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nif (val > svc->srv_nthrs_cpt_limit * svc->srv_ncpts) {\r\nspin_unlock(&svc->srv_lock);\r\nreturn -ERANGE;\r\n}\r\nsvc->srv_nthrs_cpt_init = val / svc->srv_ncpts;\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic int\r\nptlrpc_lprocfs_threads_started_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nint total = 0;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\ntotal += svcpt->scp_nthrs_running;\r\nreturn seq_printf(m, "%d\n", total);\r\n}\r\nstatic int\r\nptlrpc_lprocfs_threads_max_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nreturn seq_printf(m, "%d\n",\r\nsvc->srv_nthrs_cpt_limit * svc->srv_ncpts);\r\n}\r\nstatic ssize_t\r\nptlrpc_lprocfs_threads_max_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nint val;\r\nint rc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val / svc->srv_ncpts < PTLRPC_NTHRS_INIT)\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nif (val < svc->srv_nthrs_cpt_init * svc->srv_ncpts) {\r\nspin_unlock(&svc->srv_lock);\r\nreturn -ERANGE;\r\n}\r\nsvc->srv_nthrs_cpt_limit = val / svc->srv_ncpts;\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nstatic const char *nrs_state2str(enum ptlrpc_nrs_pol_state state)\r\n{\r\nswitch (state) {\r\ndefault:\r\nLBUG();\r\ncase NRS_POL_STATE_INVALID:\r\nreturn "invalid";\r\ncase NRS_POL_STATE_STOPPED:\r\nreturn "stopped";\r\ncase NRS_POL_STATE_STOPPING:\r\nreturn "stopping";\r\ncase NRS_POL_STATE_STARTING:\r\nreturn "starting";\r\ncase NRS_POL_STATE_STARTED:\r\nreturn "started";\r\n}\r\n}\r\nvoid nrs_policy_get_info_locked(struct ptlrpc_nrs_policy *policy,\r\nstruct ptlrpc_nrs_pol_info *info)\r\n{\r\nLASSERT(policy != NULL);\r\nLASSERT(info != NULL);\r\nLASSERT(spin_is_locked(&policy->pol_nrs->nrs_lock));\r\nmemcpy(info->pi_name, policy->pol_desc->pd_name, NRS_POL_NAME_MAX);\r\ninfo->pi_fallback = !!(policy->pol_flags & PTLRPC_NRS_FL_FALLBACK);\r\ninfo->pi_state = policy->pol_state;\r\ninfo->pi_req_queued = policy->pol_req_queued;\r\ninfo->pi_req_started = policy->pol_req_started;\r\n}\r\nstatic int ptlrpc_lprocfs_nrs_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_nrs *nrs;\r\nstruct ptlrpc_nrs_policy *policy;\r\nstruct ptlrpc_nrs_pol_info *infos;\r\nstruct ptlrpc_nrs_pol_info tmp;\r\nunsigned num_pols;\r\nunsigned pol_idx = 0;\r\nbool hp = false;\r\nint i;\r\nint rc = 0;\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nnrs = nrs_svcpt2nrs(svc->srv_parts[0], false);\r\nspin_lock(&nrs->nrs_lock);\r\nnum_pols = svc->srv_parts[0]->scp_nrs_reg.nrs_num_pols;\r\nspin_unlock(&nrs->nrs_lock);\r\nOBD_ALLOC(infos, num_pols * sizeof(*infos));\r\nif (infos == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nagain:\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nnrs = nrs_svcpt2nrs(svcpt, hp);\r\nspin_lock(&nrs->nrs_lock);\r\npol_idx = 0;\r\nlist_for_each_entry(policy, &nrs->nrs_policy_list,\r\npol_list) {\r\nLASSERT(pol_idx < num_pols);\r\nnrs_policy_get_info_locked(policy, &tmp);\r\nif (i == 0) {\r\nmemcpy(infos[pol_idx].pi_name, tmp.pi_name,\r\nNRS_POL_NAME_MAX);\r\nmemcpy(&infos[pol_idx].pi_state, &tmp.pi_state,\r\nsizeof(tmp.pi_state));\r\ninfos[pol_idx].pi_fallback = tmp.pi_fallback;\r\n} else {\r\nLASSERT(strncmp(infos[pol_idx].pi_name,\r\ntmp.pi_name,\r\nNRS_POL_NAME_MAX) == 0);\r\nLASSERT(infos[pol_idx].pi_fallback ==\r\ntmp.pi_fallback);\r\n}\r\ninfos[pol_idx].pi_req_queued += tmp.pi_req_queued;\r\ninfos[pol_idx].pi_req_started += tmp.pi_req_started;\r\npol_idx++;\r\n}\r\nspin_unlock(&nrs->nrs_lock);\r\n}\r\nseq_printf(m, "%s\n",\r\n!hp ? "\nregular_requests:" : "high_priority_requests:");\r\nfor (pol_idx = 0; pol_idx < num_pols; pol_idx++) {\r\nseq_printf(m, " - name: %s\n"\r\n" state: %s\n"\r\n" fallback: %s\n"\r\n" queued: %-20d\n"\r\n" active: %-20d\n\n",\r\ninfos[pol_idx].pi_name,\r\nnrs_state2str(infos[pol_idx].pi_state),\r\ninfos[pol_idx].pi_fallback ? "yes" : "no",\r\n(int)infos[pol_idx].pi_req_queued,\r\n(int)infos[pol_idx].pi_req_started);\r\n}\r\nif (!hp && nrs_svc_has_hp(svc)) {\r\nmemset(infos, 0, num_pols * sizeof(*infos));\r\nhp = true;\r\ngoto again;\r\n}\r\nout:\r\nif (infos)\r\nOBD_FREE(infos, num_pols * sizeof(*infos));\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\nreturn rc;\r\n}\r\nstatic ssize_t ptlrpc_lprocfs_nrs_seq_write(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nenum ptlrpc_nrs_queue_type queue = PTLRPC_NRS_QUEUE_BOTH;\r\nchar *cmd;\r\nchar *cmd_copy = NULL;\r\nchar *token;\r\nint rc = 0;\r\nif (count >= LPROCFS_NRS_WR_MAX_CMD)\r\nGOTO(out, rc = -EINVAL);\r\nOBD_ALLOC(cmd, LPROCFS_NRS_WR_MAX_CMD);\r\nif (cmd == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\ncmd_copy = cmd;\r\nif (copy_from_user(cmd, buffer, count))\r\nGOTO(out, rc = -EFAULT);\r\ncmd[count] = '\0';\r\ntoken = strsep(&cmd, " ");\r\nif (strlen(token) > NRS_POL_NAME_MAX - 1)\r\nGOTO(out, rc = -EINVAL);\r\nif (cmd == NULL)\r\ngoto default_queue;\r\nif (strcmp(cmd, "reg") == 0)\r\nqueue = PTLRPC_NRS_QUEUE_REG;\r\nelse if (strcmp(cmd, "hp") == 0)\r\nqueue = PTLRPC_NRS_QUEUE_HP;\r\nelse\r\nGOTO(out, rc = -EINVAL);\r\ndefault_queue:\r\nif (queue == PTLRPC_NRS_QUEUE_HP && !nrs_svc_has_hp(svc))\r\nGOTO(out, rc = -ENODEV);\r\nelse if (queue == PTLRPC_NRS_QUEUE_BOTH && !nrs_svc_has_hp(svc))\r\nqueue = PTLRPC_NRS_QUEUE_REG;\r\nmutex_lock(&nrs_core.nrs_mutex);\r\nrc = ptlrpc_nrs_policy_control(svc, queue, token, PTLRPC_NRS_CTL_START,\r\nfalse, NULL);\r\nmutex_unlock(&nrs_core.nrs_mutex);\r\nout:\r\nif (cmd_copy)\r\nOBD_FREE(cmd_copy, LPROCFS_NRS_WR_MAX_CMD);\r\nreturn rc < 0 ? rc : count;\r\n}\r\nint\r\nptlrpc_lprocfs_svc_req_history_seek(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_srh_iterator *srhi,\r\n__u64 seq)\r\n{\r\nstruct list_head *e;\r\nstruct ptlrpc_request *req;\r\nif (srhi->srhi_req != NULL &&\r\nsrhi->srhi_seq > svcpt->scp_hist_seq_culled &&\r\nsrhi->srhi_seq <= seq) {\r\nLASSERTF(srhi->srhi_seq == srhi->srhi_req->rq_history_seq,\r\n"%s:%d: seek seq "LPU64", request seq "LPU64"\n",\r\nsvcpt->scp_service->srv_name, svcpt->scp_cpt,\r\nsrhi->srhi_seq, srhi->srhi_req->rq_history_seq);\r\nLASSERTF(!list_empty(&svcpt->scp_hist_reqs),\r\n"%s:%d: seek offset "LPU64", request seq "LPU64", "\r\n"last culled "LPU64"\n",\r\nsvcpt->scp_service->srv_name, svcpt->scp_cpt,\r\nseq, srhi->srhi_seq, svcpt->scp_hist_seq_culled);\r\ne = &srhi->srhi_req->rq_history_list;\r\n} else {\r\ne = svcpt->scp_hist_reqs.next;\r\n}\r\nwhile (e != &svcpt->scp_hist_reqs) {\r\nreq = list_entry(e, struct ptlrpc_request, rq_history_list);\r\nif (req->rq_history_seq >= seq) {\r\nsrhi->srhi_seq = req->rq_history_seq;\r\nsrhi->srhi_req = req;\r\nreturn 0;\r\n}\r\ne = e->next;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic void *\r\nptlrpc_lprocfs_svc_req_history_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct ptlrpc_service *svc = s->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_srh_iterator *srhi;\r\nunsigned int cpt;\r\nint rc;\r\nint i;\r\nif (sizeof(loff_t) != sizeof(__u64)) {\r\nCWARN("Failed to read request history because size of loff_t "\r\n"%d can't match size of u64\n", (int)sizeof(loff_t));\r\nreturn NULL;\r\n}\r\nOBD_ALLOC(srhi, sizeof(*srhi));\r\nif (srhi == NULL)\r\nreturn NULL;\r\nsrhi->srhi_seq = 0;\r\nsrhi->srhi_req = NULL;\r\ncpt = PTLRPC_REQ_POS2CPT(svc, *pos);\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (i < cpt)\r\ncontinue;\r\nif (i > cpt)\r\n*pos = PTLRPC_REQ_CPT2POS(svc, i);\r\nspin_lock(&svcpt->scp_lock);\r\nrc = ptlrpc_lprocfs_svc_req_history_seek(svcpt, srhi,\r\nPTLRPC_REQ_POS2SEQ(svc, *pos));\r\nspin_unlock(&svcpt->scp_lock);\r\nif (rc == 0) {\r\n*pos = PTLRPC_REQ_SEQ2POS(svc, srhi->srhi_seq);\r\nsrhi->srhi_idx = i;\r\nreturn srhi;\r\n}\r\n}\r\nOBD_FREE(srhi, sizeof(*srhi));\r\nreturn NULL;\r\n}\r\nstatic void\r\nptlrpc_lprocfs_svc_req_history_stop(struct seq_file *s, void *iter)\r\n{\r\nstruct ptlrpc_srh_iterator *srhi = iter;\r\nif (srhi != NULL)\r\nOBD_FREE(srhi, sizeof(*srhi));\r\n}\r\nstatic void *\r\nptlrpc_lprocfs_svc_req_history_next(struct seq_file *s,\r\nvoid *iter, loff_t *pos)\r\n{\r\nstruct ptlrpc_service *svc = s->private;\r\nstruct ptlrpc_srh_iterator *srhi = iter;\r\nstruct ptlrpc_service_part *svcpt;\r\n__u64 seq;\r\nint rc;\r\nint i;\r\nfor (i = srhi->srhi_idx; i < svc->srv_ncpts; i++) {\r\nsvcpt = svc->srv_parts[i];\r\nif (i > srhi->srhi_idx) {\r\nsrhi->srhi_req = NULL;\r\nseq = srhi->srhi_seq = 0;\r\n} else {\r\nseq = srhi->srhi_seq + (1 << svc->srv_cpt_bits);\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nrc = ptlrpc_lprocfs_svc_req_history_seek(svcpt, srhi, seq);\r\nspin_unlock(&svcpt->scp_lock);\r\nif (rc == 0) {\r\n*pos = PTLRPC_REQ_SEQ2POS(svc, srhi->srhi_seq);\r\nsrhi->srhi_idx = i;\r\nreturn srhi;\r\n}\r\n}\r\nOBD_FREE(srhi, sizeof(*srhi));\r\nreturn NULL;\r\n}\r\nvoid target_print_req(void *seq_file, struct ptlrpc_request *req)\r\n{\r\nstruct seq_file *sf = seq_file;\r\nswitch (req->rq_phase) {\r\ncase RQ_PHASE_NEW:\r\nseq_printf(sf, "<not swabbed>\n");\r\nbreak;\r\ncase RQ_PHASE_INTERPRET:\r\ncase RQ_PHASE_COMPLETE:\r\nseq_printf(sf, "opc %d\n", lustre_msg_get_opc(req->rq_reqmsg));\r\nbreak;\r\ndefault:\r\nDEBUG_REQ(D_ERROR, req, "bad phase %d", req->rq_phase);\r\n}\r\n}\r\nstatic int ptlrpc_lprocfs_svc_req_history_show(struct seq_file *s, void *iter)\r\n{\r\nstruct ptlrpc_service *svc = s->private;\r\nstruct ptlrpc_srh_iterator *srhi = iter;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nLASSERT(srhi->srhi_idx < svc->srv_ncpts);\r\nsvcpt = svc->srv_parts[srhi->srhi_idx];\r\nspin_lock(&svcpt->scp_lock);\r\nrc = ptlrpc_lprocfs_svc_req_history_seek(svcpt, srhi, srhi->srhi_seq);\r\nif (rc == 0) {\r\nreq = srhi->srhi_req;\r\nseq_printf(s, LPD64":%s:%s:x"LPU64":%d:%s:%ld:%lds(%+lds) ",\r\nreq->rq_history_seq, libcfs_nid2str(req->rq_self),\r\nlibcfs_id2str(req->rq_peer), req->rq_xid,\r\nreq->rq_reqlen, ptlrpc_rqphase2str(req),\r\nreq->rq_arrival_time.tv_sec,\r\nreq->rq_sent - req->rq_arrival_time.tv_sec,\r\nreq->rq_sent - req->rq_deadline);\r\nif (svc->srv_ops.so_req_printer == NULL)\r\nseq_printf(s, "\n");\r\nelse\r\nsvc->srv_ops.so_req_printer(s, srhi->srhi_req);\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn rc;\r\n}\r\nstatic int\r\nptlrpc_lprocfs_svc_req_history_open(struct inode *inode, struct file *file)\r\n{\r\nstatic struct seq_operations sops = {\r\n.start = ptlrpc_lprocfs_svc_req_history_start,\r\n.stop = ptlrpc_lprocfs_svc_req_history_stop,\r\n.next = ptlrpc_lprocfs_svc_req_history_next,\r\n.show = ptlrpc_lprocfs_svc_req_history_show,\r\n};\r\nstruct seq_file *seqf;\r\nint rc;\r\nrc = seq_open(file, &sops);\r\nif (rc)\r\nreturn rc;\r\nseqf = file->private_data;\r\nseqf->private = PDE_DATA(inode);\r\nreturn 0;\r\n}\r\nstatic int ptlrpc_lprocfs_timeouts_seq_show(struct seq_file *m, void *n)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct dhms ts;\r\ntime_t worstt;\r\nunsigned int cur;\r\nunsigned int worst;\r\nint i;\r\nif (AT_OFF) {\r\nseq_printf(m, "adaptive timeouts off, using obd_timeout %u\n",\r\nobd_timeout);\r\nreturn 0;\r\n}\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\ncur = at_get(&svcpt->scp_at_estimate);\r\nworst = svcpt->scp_at_estimate.at_worst_ever;\r\nworstt = svcpt->scp_at_estimate.at_worst_time;\r\ns2dhms(&ts, cfs_time_current_sec() - worstt);\r\nseq_printf(m, "%10s : cur %3u worst %3u (at %ld, "\r\nDHMS_FMT" ago) ", "service",\r\ncur, worst, worstt, DHMS_VARS(&ts));\r\nlprocfs_at_hist_helper(m, &svcpt->scp_at_estimate);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ptlrpc_lprocfs_hp_ratio_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct ptlrpc_service *svc = m->private;\r\nreturn seq_printf(m, "%d", svc->srv_hpreq_ratio);\r\n}\r\nstatic ssize_t ptlrpc_lprocfs_hp_ratio_seq_write(struct file *file,\r\nconst char *buffer,\r\nsize_t count,\r\nloff_t *off)\r\n{\r\nstruct ptlrpc_service *svc = ((struct seq_file *)file->private_data)->private;\r\nint rc;\r\nint val;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val < 0)\r\nreturn -ERANGE;\r\nspin_lock(&svc->srv_lock);\r\nsvc->srv_hpreq_ratio = val;\r\nspin_unlock(&svc->srv_lock);\r\nreturn count;\r\n}\r\nvoid ptlrpc_lprocfs_register_service(struct proc_dir_entry *entry,\r\nstruct ptlrpc_service *svc)\r\n{\r\nstruct lprocfs_vars lproc_vars[] = {\r\n{.name = "high_priority_ratio",\r\n.fops = &ptlrpc_lprocfs_hp_ratio_fops,\r\n.data = svc},\r\n{.name = "req_buffer_history_len",\r\n.fops = &ptlrpc_lprocfs_req_history_len_fops,\r\n.data = svc},\r\n{.name = "req_buffer_history_max",\r\n.fops = &ptlrpc_lprocfs_req_history_max_fops,\r\n.data = svc},\r\n{.name = "threads_min",\r\n.fops = &ptlrpc_lprocfs_threads_min_fops,\r\n.data = svc},\r\n{.name = "threads_max",\r\n.fops = &ptlrpc_lprocfs_threads_max_fops,\r\n.data = svc},\r\n{.name = "threads_started",\r\n.fops = &ptlrpc_lprocfs_threads_started_fops,\r\n.data = svc},\r\n{.name = "timeouts",\r\n.fops = &ptlrpc_lprocfs_timeouts_fops,\r\n.data = svc},\r\n{.name = "nrs_policies",\r\n.fops = &ptlrpc_lprocfs_nrs_fops,\r\n.data = svc},\r\n{NULL}\r\n};\r\nstatic struct file_operations req_history_fops = {\r\n.owner = THIS_MODULE,\r\n.open = ptlrpc_lprocfs_svc_req_history_open,\r\n.read = seq_read,\r\n.llseek = seq_lseek,\r\n.release = lprocfs_seq_release,\r\n};\r\nint rc;\r\nptlrpc_lprocfs_register(entry, svc->srv_name,\r\n"stats", &svc->srv_procroot,\r\n&svc->srv_stats);\r\nif (svc->srv_procroot == NULL)\r\nreturn;\r\nlprocfs_add_vars(svc->srv_procroot, lproc_vars, NULL);\r\nrc = lprocfs_seq_create(svc->srv_procroot, "req_history",\r\n0400, &req_history_fops, svc);\r\nif (rc)\r\nCWARN("Error adding the req_history file\n");\r\n}\r\nvoid ptlrpc_lprocfs_register_obd(struct obd_device *obddev)\r\n{\r\nptlrpc_lprocfs_register(obddev->obd_proc_entry, NULL, "stats",\r\n&obddev->obd_svc_procroot,\r\n&obddev->obd_svc_stats);\r\n}\r\nvoid ptlrpc_lprocfs_rpc_sent(struct ptlrpc_request *req, long amount)\r\n{\r\nstruct lprocfs_stats *svc_stats;\r\n__u32 op = lustre_msg_get_opc(req->rq_reqmsg);\r\nint opc = opcode_offset(op);\r\nsvc_stats = req->rq_import->imp_obd->obd_svc_stats;\r\nif (svc_stats == NULL || opc <= 0)\r\nreturn;\r\nLASSERT(opc < LUSTRE_MAX_OPCODES);\r\nif (!(op == LDLM_ENQUEUE || op == MDS_REINT))\r\nlprocfs_counter_add(svc_stats, opc + EXTRA_MAX_OPCODES, amount);\r\n}\r\nvoid ptlrpc_lprocfs_brw(struct ptlrpc_request *req, int bytes)\r\n{\r\nstruct lprocfs_stats *svc_stats;\r\nint idx;\r\nif (!req->rq_import)\r\nreturn;\r\nsvc_stats = req->rq_import->imp_obd->obd_svc_stats;\r\nif (!svc_stats)\r\nreturn;\r\nidx = lustre_msg_get_opc(req->rq_reqmsg);\r\nswitch (idx) {\r\ncase OST_READ:\r\nidx = BRW_READ_BYTES + PTLRPC_LAST_CNTR;\r\nbreak;\r\ncase OST_WRITE:\r\nidx = BRW_WRITE_BYTES + PTLRPC_LAST_CNTR;\r\nbreak;\r\ndefault:\r\nLASSERTF(0, "unsupported opcode %u\n", idx);\r\nbreak;\r\n}\r\nlprocfs_counter_add(svc_stats, idx, bytes);\r\n}\r\nvoid ptlrpc_lprocfs_unregister_service(struct ptlrpc_service *svc)\r\n{\r\nif (svc->srv_procroot != NULL)\r\nlprocfs_remove(&svc->srv_procroot);\r\nif (svc->srv_stats)\r\nlprocfs_free_stats(&svc->srv_stats);\r\n}\r\nvoid ptlrpc_lprocfs_unregister_obd(struct obd_device *obd)\r\n{\r\nif (obd->obd_svc_procroot)\r\nlprocfs_remove(&obd->obd_svc_procroot);\r\nif (obd->obd_svc_stats)\r\nlprocfs_free_stats(&obd->obd_svc_stats);\r\n}\r\nint lprocfs_wr_evict_client(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nchar *kbuf;\r\nchar *tmpbuf;\r\nOBD_ALLOC(kbuf, BUFLEN);\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kbuf, buffer,\r\nmin_t(unsigned long, BUFLEN - 1, count))) {\r\ncount = -EFAULT;\r\ngoto out;\r\n}\r\ntmpbuf = cfs_firststr(kbuf, min_t(unsigned long, BUFLEN - 1, count));\r\nclass_incref(obd, __FUNCTION__, current);\r\nif (strncmp(tmpbuf, "nid:", 4) == 0)\r\nobd_export_evict_by_nid(obd, tmpbuf + 4);\r\nelse if (strncmp(tmpbuf, "uuid:", 5) == 0)\r\nobd_export_evict_by_uuid(obd, tmpbuf + 5);\r\nelse\r\nobd_export_evict_by_uuid(obd, tmpbuf);\r\nclass_decref(obd, __FUNCTION__, current);\r\nout:\r\nOBD_FREE(kbuf, BUFLEN);\r\nreturn count;\r\n}\r\nint lprocfs_wr_ping(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nstruct ptlrpc_request *req;\r\nint rc;\r\nLPROCFS_CLIMP_CHECK(obd);\r\nreq = ptlrpc_prep_ping(obd->u.cli.cl_import);\r\nLPROCFS_CLIMP_EXIT(obd);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq->rq_send_state = LUSTRE_IMP_FULL;\r\nrc = ptlrpc_queue_wait(req);\r\nptlrpc_req_finished(req);\r\nif (rc >= 0)\r\nreturn count;\r\nreturn rc;\r\n}\r\nint lprocfs_wr_import(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nchar *kbuf = NULL;\r\nchar *uuid;\r\nchar *ptr;\r\nint do_reconn = 1;\r\nconst char prefix[] = "connection=";\r\nconst int prefix_len = sizeof(prefix) - 1;\r\nif (count > PAGE_CACHE_SIZE - 1 || count <= prefix_len)\r\nreturn -EINVAL;\r\nOBD_ALLOC(kbuf, count + 1);\r\nif (kbuf == NULL)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kbuf, buffer, count))\r\nGOTO(out, count = -EFAULT);\r\nkbuf[count] = 0;\r\nif (strncmp(prefix, kbuf, prefix_len) != 0)\r\nGOTO(out, count = -EINVAL);\r\nuuid = kbuf + prefix_len;\r\nptr = strstr(uuid, "::");\r\nif (ptr) {\r\n__u32 inst;\r\nchar *endptr;\r\n*ptr = 0;\r\ndo_reconn = 0;\r\nptr += strlen("::");\r\ninst = simple_strtol(ptr, &endptr, 10);\r\nif (*endptr) {\r\nCERROR("config: wrong instance # %s\n", ptr);\r\n} else if (inst != imp->imp_connect_data.ocd_instance) {\r\nCDEBUG(D_INFO, "IR: %s is connecting to an obsoleted "\r\n"target(%u/%u), reconnecting...\n",\r\nimp->imp_obd->obd_name,\r\nimp->imp_connect_data.ocd_instance, inst);\r\ndo_reconn = 1;\r\n} else {\r\nCDEBUG(D_INFO, "IR: %s has already been connecting to "\r\n"new target(%u)\n",\r\nimp->imp_obd->obd_name, inst);\r\n}\r\n}\r\nif (do_reconn)\r\nptlrpc_recover_import(imp, uuid, 1);\r\nout:\r\nOBD_FREE(kbuf, count + 1);\r\nreturn count;\r\n}\r\nint lprocfs_rd_pinger_recov(struct seq_file *m, void *n)\r\n{\r\nstruct obd_device *obd = m->private;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nint rc;\r\nLPROCFS_CLIMP_CHECK(obd);\r\nrc = seq_printf(m, "%d\n", !imp->imp_no_pinger_recover);\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn rc;\r\n}\r\nint lprocfs_wr_pinger_recov(struct file *file, const char *buffer,\r\nsize_t count, loff_t *off)\r\n{\r\nstruct obd_device *obd = ((struct seq_file *)file->private_data)->private;\r\nstruct client_obd *cli = &obd->u.cli;\r\nstruct obd_import *imp = cli->cl_import;\r\nint rc, val;\r\nrc = lprocfs_write_helper(buffer, count, &val);\r\nif (rc < 0)\r\nreturn rc;\r\nif (val != 0 && val != 1)\r\nreturn -ERANGE;\r\nLPROCFS_CLIMP_CHECK(obd);\r\nspin_lock(&imp->imp_lock);\r\nimp->imp_no_pinger_recover = !val;\r\nspin_unlock(&imp->imp_lock);\r\nLPROCFS_CLIMP_EXIT(obd);\r\nreturn count;\r\n}
