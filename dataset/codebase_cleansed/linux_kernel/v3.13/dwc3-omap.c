static inline u32 dwc3_omap_readl(void __iomem *base, u32 offset)\r\n{\r\nreturn readl(base + offset);\r\n}\r\nstatic inline void dwc3_omap_writel(void __iomem *base, u32 offset, u32 value)\r\n{\r\nwritel(value, base + offset);\r\n}\r\nstatic u32 dwc3_omap_read_utmi_status(struct dwc3_omap *omap)\r\n{\r\nreturn dwc3_omap_readl(omap->base, USBOTGSS_UTMI_OTG_STATUS +\r\nomap->utmi_otg_offset);\r\n}\r\nstatic void dwc3_omap_write_utmi_status(struct dwc3_omap *omap, u32 value)\r\n{\r\ndwc3_omap_writel(omap->base, USBOTGSS_UTMI_OTG_STATUS +\r\nomap->utmi_otg_offset, value);\r\n}\r\nstatic u32 dwc3_omap_read_irq0_status(struct dwc3_omap *omap)\r\n{\r\nreturn dwc3_omap_readl(omap->base, USBOTGSS_IRQSTATUS_0 -\r\nomap->irq0_offset);\r\n}\r\nstatic void dwc3_omap_write_irq0_status(struct dwc3_omap *omap, u32 value)\r\n{\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQSTATUS_0 -\r\nomap->irq0_offset, value);\r\n}\r\nstatic u32 dwc3_omap_read_irqmisc_status(struct dwc3_omap *omap)\r\n{\r\nreturn dwc3_omap_readl(omap->base, USBOTGSS_IRQSTATUS_MISC +\r\nomap->irqmisc_offset);\r\n}\r\nstatic void dwc3_omap_write_irqmisc_status(struct dwc3_omap *omap, u32 value)\r\n{\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQSTATUS_MISC +\r\nomap->irqmisc_offset, value);\r\n}\r\nstatic void dwc3_omap_write_irqmisc_set(struct dwc3_omap *omap, u32 value)\r\n{\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_SET_MISC +\r\nomap->irqmisc_offset, value);\r\n}\r\nstatic void dwc3_omap_write_irq0_set(struct dwc3_omap *omap, u32 value)\r\n{\r\ndwc3_omap_writel(omap->base, USBOTGSS_IRQENABLE_SET_0 -\r\nomap->irq0_offset, value);\r\n}\r\nstatic void dwc3_omap_set_mailbox(struct dwc3_omap *omap,\r\nenum omap_dwc3_vbus_id_status status)\r\n{\r\nint ret;\r\nu32 val;\r\nswitch (status) {\r\ncase OMAP_DWC3_ID_GROUND:\r\ndev_dbg(omap->dev, "ID GND\n");\r\nif (omap->vbus_reg) {\r\nret = regulator_enable(omap->vbus_reg);\r\nif (ret) {\r\ndev_dbg(omap->dev, "regulator enable failed\n");\r\nreturn;\r\n}\r\n}\r\nval = dwc3_omap_read_utmi_status(omap);\r\nval &= ~(USBOTGSS_UTMI_OTG_STATUS_IDDIG\r\n| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID\r\n| USBOTGSS_UTMI_OTG_STATUS_SESSEND);\r\nval |= USBOTGSS_UTMI_OTG_STATUS_SESSVALID\r\n| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT;\r\ndwc3_omap_write_utmi_status(omap, val);\r\nbreak;\r\ncase OMAP_DWC3_VBUS_VALID:\r\ndev_dbg(omap->dev, "VBUS Connect\n");\r\nval = dwc3_omap_read_utmi_status(omap);\r\nval &= ~USBOTGSS_UTMI_OTG_STATUS_SESSEND;\r\nval |= USBOTGSS_UTMI_OTG_STATUS_IDDIG\r\n| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID\r\n| USBOTGSS_UTMI_OTG_STATUS_SESSVALID\r\n| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT;\r\ndwc3_omap_write_utmi_status(omap, val);\r\nbreak;\r\ncase OMAP_DWC3_ID_FLOAT:\r\nif (omap->vbus_reg)\r\nregulator_disable(omap->vbus_reg);\r\ncase OMAP_DWC3_VBUS_OFF:\r\ndev_dbg(omap->dev, "VBUS Disconnect\n");\r\nval = dwc3_omap_read_utmi_status(omap);\r\nval &= ~(USBOTGSS_UTMI_OTG_STATUS_SESSVALID\r\n| USBOTGSS_UTMI_OTG_STATUS_VBUSVALID\r\n| USBOTGSS_UTMI_OTG_STATUS_POWERPRESENT);\r\nval |= USBOTGSS_UTMI_OTG_STATUS_SESSEND\r\n| USBOTGSS_UTMI_OTG_STATUS_IDDIG;\r\ndwc3_omap_write_utmi_status(omap, val);\r\nbreak;\r\ndefault:\r\ndev_dbg(omap->dev, "invalid state\n");\r\n}\r\n}\r\nstatic irqreturn_t dwc3_omap_interrupt(int irq, void *_omap)\r\n{\r\nstruct dwc3_omap *omap = _omap;\r\nu32 reg;\r\nspin_lock(&omap->lock);\r\nreg = dwc3_omap_read_irqmisc_status(omap);\r\nif (reg & USBOTGSS_IRQMISC_DMADISABLECLR) {\r\ndev_dbg(omap->dev, "DMA Disable was Cleared\n");\r\nomap->dma_status = false;\r\n}\r\nif (reg & USBOTGSS_IRQMISC_OEVT)\r\ndev_dbg(omap->dev, "OTG Event\n");\r\nif (reg & USBOTGSS_IRQMISC_DRVVBUS_RISE)\r\ndev_dbg(omap->dev, "DRVVBUS Rise\n");\r\nif (reg & USBOTGSS_IRQMISC_CHRGVBUS_RISE)\r\ndev_dbg(omap->dev, "CHRGVBUS Rise\n");\r\nif (reg & USBOTGSS_IRQMISC_DISCHRGVBUS_RISE)\r\ndev_dbg(omap->dev, "DISCHRGVBUS Rise\n");\r\nif (reg & USBOTGSS_IRQMISC_IDPULLUP_RISE)\r\ndev_dbg(omap->dev, "IDPULLUP Rise\n");\r\nif (reg & USBOTGSS_IRQMISC_DRVVBUS_FALL)\r\ndev_dbg(omap->dev, "DRVVBUS Fall\n");\r\nif (reg & USBOTGSS_IRQMISC_CHRGVBUS_FALL)\r\ndev_dbg(omap->dev, "CHRGVBUS Fall\n");\r\nif (reg & USBOTGSS_IRQMISC_DISCHRGVBUS_FALL)\r\ndev_dbg(omap->dev, "DISCHRGVBUS Fall\n");\r\nif (reg & USBOTGSS_IRQMISC_IDPULLUP_FALL)\r\ndev_dbg(omap->dev, "IDPULLUP Fall\n");\r\ndwc3_omap_write_irqmisc_status(omap, reg);\r\nreg = dwc3_omap_read_irq0_status(omap);\r\ndwc3_omap_write_irq0_status(omap, reg);\r\nspin_unlock(&omap->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dwc3_omap_remove_core(struct device *dev, void *c)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nplatform_device_unregister(pdev);\r\nreturn 0;\r\n}\r\nstatic void dwc3_omap_enable_irqs(struct dwc3_omap *omap)\r\n{\r\nu32 reg;\r\nreg = USBOTGSS_IRQO_COREIRQ_ST;\r\ndwc3_omap_write_irq0_set(omap, reg);\r\nreg = (USBOTGSS_IRQMISC_OEVT |\r\nUSBOTGSS_IRQMISC_DRVVBUS_RISE |\r\nUSBOTGSS_IRQMISC_CHRGVBUS_RISE |\r\nUSBOTGSS_IRQMISC_DISCHRGVBUS_RISE |\r\nUSBOTGSS_IRQMISC_IDPULLUP_RISE |\r\nUSBOTGSS_IRQMISC_DRVVBUS_FALL |\r\nUSBOTGSS_IRQMISC_CHRGVBUS_FALL |\r\nUSBOTGSS_IRQMISC_DISCHRGVBUS_FALL |\r\nUSBOTGSS_IRQMISC_IDPULLUP_FALL);\r\ndwc3_omap_write_irqmisc_set(omap, reg);\r\n}\r\nstatic void dwc3_omap_disable_irqs(struct dwc3_omap *omap)\r\n{\r\ndwc3_omap_write_irqmisc_set(omap, 0x00);\r\ndwc3_omap_write_irq0_set(omap, 0x00);\r\n}\r\nstatic int dwc3_omap_id_notifier(struct notifier_block *nb,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct dwc3_omap *omap = container_of(nb, struct dwc3_omap, id_nb);\r\nif (event)\r\ndwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_GROUND);\r\nelse\r\ndwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_FLOAT);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int dwc3_omap_vbus_notifier(struct notifier_block *nb,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct dwc3_omap *omap = container_of(nb, struct dwc3_omap, vbus_nb);\r\nif (event)\r\ndwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_VALID);\r\nelse\r\ndwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_OFF);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int dwc3_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct dwc3_omap *omap;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct extcon_dev *edev;\r\nstruct regulator *vbus_reg = NULL;\r\nint ret = -ENOMEM;\r\nint irq;\r\nint utmi_mode = 0;\r\nint x_major;\r\nu32 reg;\r\nvoid __iomem *base;\r\nif (!node) {\r\ndev_err(dev, "device node not found\n");\r\nreturn -EINVAL;\r\n}\r\nomap = devm_kzalloc(dev, sizeof(*omap), GFP_KERNEL);\r\nif (!omap) {\r\ndev_err(dev, "not enough memory\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, omap);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "missing IRQ resource\n");\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "missing memory base resource\n");\r\nreturn -EINVAL;\r\n}\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nif (of_property_read_bool(node, "vbus-supply")) {\r\nvbus_reg = devm_regulator_get(dev, "vbus");\r\nif (IS_ERR(vbus_reg)) {\r\ndev_err(dev, "vbus init failed\n");\r\nreturn PTR_ERR(vbus_reg);\r\n}\r\n}\r\nspin_lock_init(&omap->lock);\r\nomap->dev = dev;\r\nomap->irq = irq;\r\nomap->base = base;\r\nomap->vbus_reg = vbus_reg;\r\ndev->dma_mask = &dwc3_omap_dma_mask;\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "get_sync failed with err %d\n", ret);\r\ngoto err0;\r\n}\r\nreg = dwc3_omap_readl(omap->base, USBOTGSS_REVISION);\r\nomap->revision = reg;\r\nx_major = USBOTGSS_REVISION_XMAJOR(reg);\r\nswitch (x_major) {\r\ncase USBOTGSS_REVISION_XMAJOR1:\r\ncase USBOTGSS_REVISION_XMAJOR2:\r\nomap->irq_eoi_offset = 0;\r\nomap->irq0_offset = 0;\r\nomap->irqmisc_offset = 0;\r\nomap->utmi_otg_offset = 0;\r\nomap->debug_offset = 0;\r\nbreak;\r\ndefault:\r\nomap->irq_eoi_offset = USBOTGSS_EOI_OFFSET;\r\nomap->irq0_offset = USBOTGSS_IRQ0_OFFSET;\r\nomap->irqmisc_offset = USBOTGSS_IRQMISC_OFFSET;\r\nomap->utmi_otg_offset = USBOTGSS_UTMI_OTG_OFFSET;\r\nomap->debug_offset = USBOTGSS_DEBUG_OFFSET;\r\nbreak;\r\n}\r\nif (of_device_is_compatible(node, "ti,am437x-dwc3")) {\r\nomap->irq_eoi_offset = USBOTGSS_EOI_OFFSET;\r\nomap->irq0_offset = USBOTGSS_IRQ0_OFFSET;\r\nomap->irqmisc_offset = USBOTGSS_IRQMISC_OFFSET;\r\nomap->utmi_otg_offset = USBOTGSS_UTMI_OTG_OFFSET;\r\nomap->debug_offset = USBOTGSS_DEBUG_OFFSET;\r\n}\r\nreg = dwc3_omap_read_utmi_status(omap);\r\nof_property_read_u32(node, "utmi-mode", &utmi_mode);\r\nswitch (utmi_mode) {\r\ncase DWC3_OMAP_UTMI_MODE_SW:\r\nreg |= USBOTGSS_UTMI_OTG_STATUS_SW_MODE;\r\nbreak;\r\ncase DWC3_OMAP_UTMI_MODE_HW:\r\nreg &= ~USBOTGSS_UTMI_OTG_STATUS_SW_MODE;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "UNKNOWN utmi mode %d\n", utmi_mode);\r\n}\r\ndwc3_omap_write_utmi_status(omap, reg);\r\nreg = dwc3_omap_readl(omap->base, USBOTGSS_SYSCONFIG);\r\nomap->dma_status = !!(reg & USBOTGSS_SYSCONFIG_DMADISABLE);\r\nret = devm_request_irq(dev, omap->irq, dwc3_omap_interrupt, 0,\r\n"dwc3-omap", omap);\r\nif (ret) {\r\ndev_err(dev, "failed to request IRQ #%d --> %d\n",\r\nomap->irq, ret);\r\ngoto err1;\r\n}\r\ndwc3_omap_enable_irqs(omap);\r\nif (of_property_read_bool(node, "extcon")) {\r\nedev = of_extcon_get_extcon_dev(dev, 0);\r\nif (IS_ERR(edev)) {\r\ndev_vdbg(dev, "couldn't get extcon device\n");\r\nret = PTR_ERR(edev);\r\ngoto err2;\r\n}\r\nomap->vbus_nb.notifier_call = dwc3_omap_vbus_notifier;\r\nret = extcon_register_interest(&omap->extcon_vbus_dev,\r\nedev->name, "USB", &omap->vbus_nb);\r\nif (ret < 0)\r\ndev_vdbg(dev, "failed to register notifier for USB\n");\r\nomap->id_nb.notifier_call = dwc3_omap_id_notifier;\r\nret = extcon_register_interest(&omap->extcon_id_dev, edev->name,\r\n"USB-HOST", &omap->id_nb);\r\nif (ret < 0)\r\ndev_vdbg(dev,\r\n"failed to register notifier for USB-HOST\n");\r\nif (extcon_get_cable_state(edev, "USB") == true)\r\ndwc3_omap_set_mailbox(omap, OMAP_DWC3_VBUS_VALID);\r\nif (extcon_get_cable_state(edev, "USB-HOST") == true)\r\ndwc3_omap_set_mailbox(omap, OMAP_DWC3_ID_GROUND);\r\n}\r\nret = of_platform_populate(node, NULL, NULL, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to create dwc3 core\n");\r\ngoto err3;\r\n}\r\nreturn 0;\r\nerr3:\r\nif (omap->extcon_vbus_dev.edev)\r\nextcon_unregister_interest(&omap->extcon_vbus_dev);\r\nif (omap->extcon_id_dev.edev)\r\nextcon_unregister_interest(&omap->extcon_id_dev);\r\nerr2:\r\ndwc3_omap_disable_irqs(omap);\r\nerr1:\r\npm_runtime_put_sync(dev);\r\nerr0:\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int dwc3_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct dwc3_omap *omap = platform_get_drvdata(pdev);\r\nif (omap->extcon_vbus_dev.edev)\r\nextcon_unregister_interest(&omap->extcon_vbus_dev);\r\nif (omap->extcon_id_dev.edev)\r\nextcon_unregister_interest(&omap->extcon_id_dev);\r\ndwc3_omap_disable_irqs(omap);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\ndevice_for_each_child(&pdev->dev, NULL, dwc3_omap_remove_core);\r\nreturn 0;\r\n}\r\nstatic int dwc3_omap_prepare(struct device *dev)\r\n{\r\nstruct dwc3_omap *omap = dev_get_drvdata(dev);\r\ndwc3_omap_disable_irqs(omap);\r\nreturn 0;\r\n}\r\nstatic void dwc3_omap_complete(struct device *dev)\r\n{\r\nstruct dwc3_omap *omap = dev_get_drvdata(dev);\r\ndwc3_omap_enable_irqs(omap);\r\n}\r\nstatic int dwc3_omap_suspend(struct device *dev)\r\n{\r\nstruct dwc3_omap *omap = dev_get_drvdata(dev);\r\nomap->utmi_otg_status = dwc3_omap_read_utmi_status(omap);\r\nreturn 0;\r\n}\r\nstatic int dwc3_omap_resume(struct device *dev)\r\n{\r\nstruct dwc3_omap *omap = dev_get_drvdata(dev);\r\ndwc3_omap_write_utmi_status(omap, omap->utmi_otg_status);\r\npm_runtime_disable(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}
