static inline void __user *to_user_ptr(u64 address)\r\n{\r\nreturn (void __user *)(uintptr_t)address;\r\n}\r\nstatic struct msm_gem_submit *submit_create(struct drm_device *dev,\r\nstruct msm_gpu *gpu, int nr)\r\n{\r\nstruct msm_gem_submit *submit;\r\nint sz = sizeof(*submit) + (nr * sizeof(submit->bos[0]));\r\nsubmit = kmalloc(sz, GFP_TEMPORARY | __GFP_NOWARN | __GFP_NORETRY);\r\nif (submit) {\r\nsubmit->dev = dev;\r\nsubmit->gpu = gpu;\r\nsubmit->nr_bos = 0;\r\nsubmit->nr_cmds = 0;\r\nINIT_LIST_HEAD(&submit->bo_list);\r\nww_acquire_init(&submit->ticket, &reservation_ww_class);\r\n}\r\nreturn submit;\r\n}\r\nstatic int submit_lookup_objects(struct msm_gem_submit *submit,\r\nstruct drm_msm_gem_submit *args, struct drm_file *file)\r\n{\r\nunsigned i;\r\nint ret = 0;\r\nspin_lock(&file->table_lock);\r\nfor (i = 0; i < args->nr_bos; i++) {\r\nstruct drm_msm_gem_submit_bo submit_bo;\r\nstruct drm_gem_object *obj;\r\nstruct msm_gem_object *msm_obj;\r\nvoid __user *userptr =\r\nto_user_ptr(args->bos + (i * sizeof(submit_bo)));\r\nret = copy_from_user(&submit_bo, userptr, sizeof(submit_bo));\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nif (submit_bo.flags & BO_INVALID_FLAGS) {\r\nDRM_ERROR("invalid flags: %x\n", submit_bo.flags);\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nsubmit->bos[i].flags = submit_bo.flags;\r\nsubmit->bos[i].iova = submit_bo.presumed;\r\nobj = idr_find(&file->object_idr, submit_bo.handle);\r\nif (!obj) {\r\nDRM_ERROR("invalid handle %u at index %u\n", submit_bo.handle, i);\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nmsm_obj = to_msm_bo(obj);\r\nif (!list_empty(&msm_obj->submit_entry)) {\r\nDRM_ERROR("handle %u at index %u already on submit list\n",\r\nsubmit_bo.handle, i);\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\ndrm_gem_object_reference(obj);\r\nsubmit->bos[i].obj = msm_obj;\r\nlist_add_tail(&msm_obj->submit_entry, &submit->bo_list);\r\n}\r\nout_unlock:\r\nsubmit->nr_bos = i;\r\nspin_unlock(&file->table_lock);\r\nreturn ret;\r\n}\r\nstatic void submit_unlock_unpin_bo(struct msm_gem_submit *submit, int i)\r\n{\r\nstruct msm_gem_object *msm_obj = submit->bos[i].obj;\r\nif (submit->bos[i].flags & BO_PINNED)\r\nmsm_gem_put_iova(&msm_obj->base, submit->gpu->id);\r\nif (submit->bos[i].flags & BO_LOCKED)\r\nww_mutex_unlock(&msm_obj->resv->lock);\r\nif (!(submit->bos[i].flags & BO_VALID))\r\nsubmit->bos[i].iova = 0;\r\nsubmit->bos[i].flags &= ~(BO_LOCKED | BO_PINNED);\r\n}\r\nstatic int submit_validate_objects(struct msm_gem_submit *submit)\r\n{\r\nint contended, slow_locked = -1, i, ret = 0;\r\nretry:\r\nsubmit->valid = true;\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nstruct msm_gem_object *msm_obj = submit->bos[i].obj;\r\nuint32_t iova;\r\nif (slow_locked == i)\r\nslow_locked = -1;\r\ncontended = i;\r\nif (!(submit->bos[i].flags & BO_LOCKED)) {\r\nret = ww_mutex_lock_interruptible(&msm_obj->resv->lock,\r\n&submit->ticket);\r\nif (ret)\r\ngoto fail;\r\nsubmit->bos[i].flags |= BO_LOCKED;\r\n}\r\nret = msm_gem_get_iova(&msm_obj->base,\r\nsubmit->gpu->id, &iova);\r\nWARN_ON(ret == -EDEADLK);\r\nif (ret)\r\ngoto fail;\r\nsubmit->bos[i].flags |= BO_PINNED;\r\nif (iova == submit->bos[i].iova) {\r\nsubmit->bos[i].flags |= BO_VALID;\r\n} else {\r\nsubmit->bos[i].iova = iova;\r\nsubmit->bos[i].flags &= ~BO_VALID;\r\nsubmit->valid = false;\r\n}\r\n}\r\nww_acquire_done(&submit->ticket);\r\nreturn 0;\r\nfail:\r\nfor (; i >= 0; i--)\r\nsubmit_unlock_unpin_bo(submit, i);\r\nif (slow_locked > 0)\r\nsubmit_unlock_unpin_bo(submit, slow_locked);\r\nif (ret == -EDEADLK) {\r\nstruct msm_gem_object *msm_obj = submit->bos[contended].obj;\r\nret = ww_mutex_lock_slow_interruptible(&msm_obj->resv->lock,\r\n&submit->ticket);\r\nif (!ret) {\r\nsubmit->bos[contended].flags |= BO_LOCKED;\r\nslow_locked = contended;\r\ngoto retry;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int submit_bo(struct msm_gem_submit *submit, uint32_t idx,\r\nstruct msm_gem_object **obj, uint32_t *iova, bool *valid)\r\n{\r\nif (idx >= submit->nr_bos) {\r\nDRM_ERROR("invalid buffer index: %u (out of %u)\n",\r\nidx, submit->nr_bos);\r\nreturn -EINVAL;\r\n}\r\nif (obj)\r\n*obj = submit->bos[idx].obj;\r\nif (iova)\r\n*iova = submit->bos[idx].iova;\r\nif (valid)\r\n*valid = !!(submit->bos[idx].flags & BO_VALID);\r\nreturn 0;\r\n}\r\nstatic int submit_reloc(struct msm_gem_submit *submit, struct msm_gem_object *obj,\r\nuint32_t offset, uint32_t nr_relocs, uint64_t relocs)\r\n{\r\nuint32_t i, last_offset = 0;\r\nuint32_t *ptr;\r\nint ret;\r\nif (offset % 4) {\r\nDRM_ERROR("non-aligned cmdstream buffer: %u\n", offset);\r\nreturn -EINVAL;\r\n}\r\nptr = msm_gem_vaddr(&obj->base);\r\nif (IS_ERR(ptr)) {\r\nret = PTR_ERR(ptr);\r\nDBG("failed to map: %d", ret);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < nr_relocs; i++) {\r\nstruct drm_msm_gem_submit_reloc submit_reloc;\r\nvoid __user *userptr =\r\nto_user_ptr(relocs + (i * sizeof(submit_reloc)));\r\nuint32_t iova, off;\r\nbool valid;\r\nret = copy_from_user(&submit_reloc, userptr, sizeof(submit_reloc));\r\nif (ret)\r\nreturn -EFAULT;\r\nif (submit_reloc.submit_offset % 4) {\r\nDRM_ERROR("non-aligned reloc offset: %u\n",\r\nsubmit_reloc.submit_offset);\r\nreturn -EINVAL;\r\n}\r\noff = submit_reloc.submit_offset / 4;\r\nif ((off >= (obj->base.size / 4)) ||\r\n(off < last_offset)) {\r\nDRM_ERROR("invalid offset %u at reloc %u\n", off, i);\r\nreturn -EINVAL;\r\n}\r\nret = submit_bo(submit, submit_reloc.reloc_idx, NULL, &iova, &valid);\r\nif (ret)\r\nreturn ret;\r\nif (valid)\r\ncontinue;\r\niova += submit_reloc.reloc_offset;\r\nif (submit_reloc.shift < 0)\r\niova >>= -submit_reloc.shift;\r\nelse\r\niova <<= submit_reloc.shift;\r\nptr[off] = iova | submit_reloc.or;\r\nlast_offset = off;\r\n}\r\nreturn 0;\r\n}\r\nstatic void submit_cleanup(struct msm_gem_submit *submit, bool fail)\r\n{\r\nunsigned i;\r\nmutex_lock(&submit->dev->struct_mutex);\r\nfor (i = 0; i < submit->nr_bos; i++) {\r\nstruct msm_gem_object *msm_obj = submit->bos[i].obj;\r\nsubmit_unlock_unpin_bo(submit, i);\r\nlist_del_init(&msm_obj->submit_entry);\r\ndrm_gem_object_unreference(&msm_obj->base);\r\n}\r\nmutex_unlock(&submit->dev->struct_mutex);\r\nww_acquire_fini(&submit->ticket);\r\nkfree(submit);\r\n}\r\nint msm_ioctl_gem_submit(struct drm_device *dev, void *data,\r\nstruct drm_file *file)\r\n{\r\nstruct msm_drm_private *priv = dev->dev_private;\r\nstruct drm_msm_gem_submit *args = data;\r\nstruct msm_file_private *ctx = file->driver_priv;\r\nstruct msm_gem_submit *submit;\r\nstruct msm_gpu *gpu;\r\nunsigned i;\r\nint ret;\r\nif (args->pipe != MSM_PIPE_3D0)\r\nreturn -EINVAL;\r\ngpu = priv->gpu;\r\nif (args->nr_cmds > MAX_CMDS)\r\nreturn -EINVAL;\r\nsubmit = submit_create(dev, gpu, args->nr_bos);\r\nif (!submit) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = submit_lookup_objects(submit, args, file);\r\nif (ret)\r\ngoto out;\r\nret = submit_validate_objects(submit);\r\nif (ret)\r\ngoto out;\r\nfor (i = 0; i < args->nr_cmds; i++) {\r\nstruct drm_msm_gem_submit_cmd submit_cmd;\r\nvoid __user *userptr =\r\nto_user_ptr(args->cmds + (i * sizeof(submit_cmd)));\r\nstruct msm_gem_object *msm_obj;\r\nuint32_t iova;\r\nret = copy_from_user(&submit_cmd, userptr, sizeof(submit_cmd));\r\nif (ret) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = submit_bo(submit, submit_cmd.submit_idx,\r\n&msm_obj, &iova, NULL);\r\nif (ret)\r\ngoto out;\r\nif (submit_cmd.size % 4) {\r\nDRM_ERROR("non-aligned cmdstream buffer size: %u\n",\r\nsubmit_cmd.size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif ((submit_cmd.size + submit_cmd.submit_offset) >=\r\nmsm_obj->base.size) {\r\nDRM_ERROR("invalid cmdstream size: %u\n", submit_cmd.size);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsubmit->cmd[i].type = submit_cmd.type;\r\nsubmit->cmd[i].size = submit_cmd.size / 4;\r\nsubmit->cmd[i].iova = iova + submit_cmd.submit_offset;\r\nif (submit->valid)\r\ncontinue;\r\nret = submit_reloc(submit, msm_obj, submit_cmd.submit_offset,\r\nsubmit_cmd.nr_relocs, submit_cmd.relocs);\r\nif (ret)\r\ngoto out;\r\n}\r\nsubmit->nr_cmds = i;\r\nret = msm_gpu_submit(gpu, submit, ctx);\r\nargs->fence = submit->fence;\r\nout:\r\nif (submit)\r\nsubmit_cleanup(submit, !!ret);\r\nreturn ret;\r\n}
