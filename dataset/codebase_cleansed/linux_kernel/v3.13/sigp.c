static int __sigp_sense(struct kvm_vcpu *vcpu, u16 cpu_addr,\r\nu64 *reg)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nint rc;\r\nif (cpu_addr >= KVM_MAX_VCPUS)\r\nreturn SIGP_CC_NOT_OPERATIONAL;\r\nspin_lock(&fi->lock);\r\nif (fi->local_int[cpu_addr] == NULL)\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\nelse if (!(atomic_read(fi->local_int[cpu_addr]->cpuflags)\r\n& (CPUSTAT_ECALL_PEND | CPUSTAT_STOPPED)))\r\nrc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\nelse {\r\n*reg &= 0xffffffff00000000UL;\r\nif (atomic_read(fi->local_int[cpu_addr]->cpuflags)\r\n& CPUSTAT_ECALL_PEND)\r\n*reg |= SIGP_STATUS_EXT_CALL_PENDING;\r\nif (atomic_read(fi->local_int[cpu_addr]->cpuflags)\r\n& CPUSTAT_STOPPED)\r\n*reg |= SIGP_STATUS_STOPPED;\r\nrc = SIGP_CC_STATUS_STORED;\r\n}\r\nspin_unlock(&fi->lock);\r\nVCPU_EVENT(vcpu, 4, "sensed status of cpu %x rc %x", cpu_addr, rc);\r\nreturn rc;\r\n}\r\nstatic int __sigp_emergency(struct kvm_vcpu *vcpu, u16 cpu_addr)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nstruct kvm_s390_local_interrupt *li;\r\nstruct kvm_s390_interrupt_info *inti;\r\nint rc;\r\nif (cpu_addr >= KVM_MAX_VCPUS)\r\nreturn SIGP_CC_NOT_OPERATIONAL;\r\ninti = kzalloc(sizeof(*inti), GFP_KERNEL);\r\nif (!inti)\r\nreturn -ENOMEM;\r\ninti->type = KVM_S390_INT_EMERGENCY;\r\ninti->emerg.code = vcpu->vcpu_id;\r\nspin_lock(&fi->lock);\r\nli = fi->local_int[cpu_addr];\r\nif (li == NULL) {\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\nkfree(inti);\r\ngoto unlock;\r\n}\r\nspin_lock_bh(&li->lock);\r\nlist_add_tail(&inti->list, &li->list);\r\natomic_set(&li->active, 1);\r\natomic_set_mask(CPUSTAT_EXT_INT, li->cpuflags);\r\nif (waitqueue_active(li->wq))\r\nwake_up_interruptible(li->wq);\r\nspin_unlock_bh(&li->lock);\r\nrc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\nVCPU_EVENT(vcpu, 4, "sent sigp emerg to cpu %x", cpu_addr);\r\nunlock:\r\nspin_unlock(&fi->lock);\r\nreturn rc;\r\n}\r\nstatic int __sigp_external_call(struct kvm_vcpu *vcpu, u16 cpu_addr)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nstruct kvm_s390_local_interrupt *li;\r\nstruct kvm_s390_interrupt_info *inti;\r\nint rc;\r\nif (cpu_addr >= KVM_MAX_VCPUS)\r\nreturn SIGP_CC_NOT_OPERATIONAL;\r\ninti = kzalloc(sizeof(*inti), GFP_KERNEL);\r\nif (!inti)\r\nreturn -ENOMEM;\r\ninti->type = KVM_S390_INT_EXTERNAL_CALL;\r\ninti->extcall.code = vcpu->vcpu_id;\r\nspin_lock(&fi->lock);\r\nli = fi->local_int[cpu_addr];\r\nif (li == NULL) {\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\nkfree(inti);\r\ngoto unlock;\r\n}\r\nspin_lock_bh(&li->lock);\r\nlist_add_tail(&inti->list, &li->list);\r\natomic_set(&li->active, 1);\r\natomic_set_mask(CPUSTAT_EXT_INT, li->cpuflags);\r\nif (waitqueue_active(li->wq))\r\nwake_up_interruptible(li->wq);\r\nspin_unlock_bh(&li->lock);\r\nrc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\nVCPU_EVENT(vcpu, 4, "sent sigp ext call to cpu %x", cpu_addr);\r\nunlock:\r\nspin_unlock(&fi->lock);\r\nreturn rc;\r\n}\r\nstatic int __inject_sigp_stop(struct kvm_s390_local_interrupt *li, int action)\r\n{\r\nstruct kvm_s390_interrupt_info *inti;\r\ninti = kzalloc(sizeof(*inti), GFP_ATOMIC);\r\nif (!inti)\r\nreturn -ENOMEM;\r\ninti->type = KVM_S390_SIGP_STOP;\r\nspin_lock_bh(&li->lock);\r\nif ((atomic_read(li->cpuflags) & CPUSTAT_STOPPED)) {\r\nkfree(inti);\r\ngoto out;\r\n}\r\nlist_add_tail(&inti->list, &li->list);\r\natomic_set(&li->active, 1);\r\natomic_set_mask(CPUSTAT_STOP_INT, li->cpuflags);\r\nli->action_bits |= action;\r\nif (waitqueue_active(li->wq))\r\nwake_up_interruptible(li->wq);\r\nout:\r\nspin_unlock_bh(&li->lock);\r\nreturn SIGP_CC_ORDER_CODE_ACCEPTED;\r\n}\r\nstatic int __sigp_stop(struct kvm_vcpu *vcpu, u16 cpu_addr, int action)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nstruct kvm_s390_local_interrupt *li;\r\nint rc;\r\nif (cpu_addr >= KVM_MAX_VCPUS)\r\nreturn SIGP_CC_NOT_OPERATIONAL;\r\nspin_lock(&fi->lock);\r\nli = fi->local_int[cpu_addr];\r\nif (li == NULL) {\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\ngoto unlock;\r\n}\r\nrc = __inject_sigp_stop(li, action);\r\nunlock:\r\nspin_unlock(&fi->lock);\r\nVCPU_EVENT(vcpu, 4, "sent sigp stop to cpu %x", cpu_addr);\r\nreturn rc;\r\n}\r\nint kvm_s390_inject_sigp_stop(struct kvm_vcpu *vcpu, int action)\r\n{\r\nstruct kvm_s390_local_interrupt *li = &vcpu->arch.local_int;\r\nreturn __inject_sigp_stop(li, action);\r\n}\r\nstatic int __sigp_set_arch(struct kvm_vcpu *vcpu, u32 parameter)\r\n{\r\nint rc;\r\nswitch (parameter & 0xff) {\r\ncase 0:\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nrc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\nbreak;\r\ndefault:\r\nrc = -EOPNOTSUPP;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __sigp_set_prefix(struct kvm_vcpu *vcpu, u16 cpu_addr, u32 address,\r\nu64 *reg)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nstruct kvm_s390_local_interrupt *li = NULL;\r\nstruct kvm_s390_interrupt_info *inti;\r\nint rc;\r\nu8 tmp;\r\naddress = address & 0x7fffe000u;\r\nif (copy_from_guest_absolute(vcpu, &tmp, address, 1) ||\r\ncopy_from_guest_absolute(vcpu, &tmp, address + PAGE_SIZE, 1)) {\r\n*reg &= 0xffffffff00000000UL;\r\n*reg |= SIGP_STATUS_INVALID_PARAMETER;\r\nreturn SIGP_CC_STATUS_STORED;\r\n}\r\ninti = kzalloc(sizeof(*inti), GFP_KERNEL);\r\nif (!inti)\r\nreturn SIGP_CC_BUSY;\r\nspin_lock(&fi->lock);\r\nif (cpu_addr < KVM_MAX_VCPUS)\r\nli = fi->local_int[cpu_addr];\r\nif (li == NULL) {\r\n*reg &= 0xffffffff00000000UL;\r\n*reg |= SIGP_STATUS_INCORRECT_STATE;\r\nrc = SIGP_CC_STATUS_STORED;\r\nkfree(inti);\r\ngoto out_fi;\r\n}\r\nspin_lock_bh(&li->lock);\r\nif (!(atomic_read(li->cpuflags) & CPUSTAT_STOPPED)) {\r\n*reg &= 0xffffffff00000000UL;\r\n*reg |= SIGP_STATUS_INCORRECT_STATE;\r\nrc = SIGP_CC_STATUS_STORED;\r\nkfree(inti);\r\ngoto out_li;\r\n}\r\ninti->type = KVM_S390_SIGP_SET_PREFIX;\r\ninti->prefix.address = address;\r\nlist_add_tail(&inti->list, &li->list);\r\natomic_set(&li->active, 1);\r\nif (waitqueue_active(li->wq))\r\nwake_up_interruptible(li->wq);\r\nrc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\nVCPU_EVENT(vcpu, 4, "set prefix of cpu %02x to %x", cpu_addr, address);\r\nout_li:\r\nspin_unlock_bh(&li->lock);\r\nout_fi:\r\nspin_unlock(&fi->lock);\r\nreturn rc;\r\n}\r\nstatic int __sigp_sense_running(struct kvm_vcpu *vcpu, u16 cpu_addr,\r\nu64 *reg)\r\n{\r\nint rc;\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nif (cpu_addr >= KVM_MAX_VCPUS)\r\nreturn SIGP_CC_NOT_OPERATIONAL;\r\nspin_lock(&fi->lock);\r\nif (fi->local_int[cpu_addr] == NULL)\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\nelse {\r\nif (atomic_read(fi->local_int[cpu_addr]->cpuflags)\r\n& CPUSTAT_RUNNING) {\r\nrc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\n} else {\r\n*reg &= 0xffffffff00000000UL;\r\n*reg |= SIGP_STATUS_NOT_RUNNING;\r\nrc = SIGP_CC_STATUS_STORED;\r\n}\r\n}\r\nspin_unlock(&fi->lock);\r\nVCPU_EVENT(vcpu, 4, "sensed running status of cpu %x rc %x", cpu_addr,\r\nrc);\r\nreturn rc;\r\n}\r\nstatic int __sigp_restart(struct kvm_vcpu *vcpu, u16 cpu_addr)\r\n{\r\nstruct kvm_s390_float_interrupt *fi = &vcpu->kvm->arch.float_int;\r\nstruct kvm_s390_local_interrupt *li;\r\nint rc = SIGP_CC_ORDER_CODE_ACCEPTED;\r\nif (cpu_addr >= KVM_MAX_VCPUS)\r\nreturn SIGP_CC_NOT_OPERATIONAL;\r\nspin_lock(&fi->lock);\r\nli = fi->local_int[cpu_addr];\r\nif (li == NULL) {\r\nrc = SIGP_CC_NOT_OPERATIONAL;\r\ngoto out;\r\n}\r\nspin_lock_bh(&li->lock);\r\nif (li->action_bits & ACTION_STOP_ON_STOP)\r\nrc = SIGP_CC_BUSY;\r\nelse\r\nVCPU_EVENT(vcpu, 4, "sigp restart %x to handle userspace",\r\ncpu_addr);\r\nspin_unlock_bh(&li->lock);\r\nout:\r\nspin_unlock(&fi->lock);\r\nreturn rc;\r\n}\r\nint kvm_s390_handle_sigp(struct kvm_vcpu *vcpu)\r\n{\r\nint r1 = (vcpu->arch.sie_block->ipa & 0x00f0) >> 4;\r\nint r3 = vcpu->arch.sie_block->ipa & 0x000f;\r\nu32 parameter;\r\nu16 cpu_addr = vcpu->run->s.regs.gprs[r3];\r\nu8 order_code;\r\nint rc;\r\nif (vcpu->arch.sie_block->gpsw.mask & PSW_MASK_PSTATE)\r\nreturn kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);\r\norder_code = kvm_s390_get_base_disp_rs(vcpu);\r\nif (r1 % 2)\r\nparameter = vcpu->run->s.regs.gprs[r1];\r\nelse\r\nparameter = vcpu->run->s.regs.gprs[r1 + 1];\r\ntrace_kvm_s390_handle_sigp(vcpu, order_code, cpu_addr, parameter);\r\nswitch (order_code) {\r\ncase SIGP_SENSE:\r\nvcpu->stat.instruction_sigp_sense++;\r\nrc = __sigp_sense(vcpu, cpu_addr,\r\n&vcpu->run->s.regs.gprs[r1]);\r\nbreak;\r\ncase SIGP_EXTERNAL_CALL:\r\nvcpu->stat.instruction_sigp_external_call++;\r\nrc = __sigp_external_call(vcpu, cpu_addr);\r\nbreak;\r\ncase SIGP_EMERGENCY_SIGNAL:\r\nvcpu->stat.instruction_sigp_emergency++;\r\nrc = __sigp_emergency(vcpu, cpu_addr);\r\nbreak;\r\ncase SIGP_STOP:\r\nvcpu->stat.instruction_sigp_stop++;\r\nrc = __sigp_stop(vcpu, cpu_addr, ACTION_STOP_ON_STOP);\r\nbreak;\r\ncase SIGP_STOP_AND_STORE_STATUS:\r\nvcpu->stat.instruction_sigp_stop++;\r\nrc = __sigp_stop(vcpu, cpu_addr, ACTION_STORE_ON_STOP |\r\nACTION_STOP_ON_STOP);\r\nbreak;\r\ncase SIGP_SET_ARCHITECTURE:\r\nvcpu->stat.instruction_sigp_arch++;\r\nrc = __sigp_set_arch(vcpu, parameter);\r\nbreak;\r\ncase SIGP_SET_PREFIX:\r\nvcpu->stat.instruction_sigp_prefix++;\r\nrc = __sigp_set_prefix(vcpu, cpu_addr, parameter,\r\n&vcpu->run->s.regs.gprs[r1]);\r\nbreak;\r\ncase SIGP_SENSE_RUNNING:\r\nvcpu->stat.instruction_sigp_sense_running++;\r\nrc = __sigp_sense_running(vcpu, cpu_addr,\r\n&vcpu->run->s.regs.gprs[r1]);\r\nbreak;\r\ncase SIGP_RESTART:\r\nvcpu->stat.instruction_sigp_restart++;\r\nrc = __sigp_restart(vcpu, cpu_addr);\r\nif (rc == SIGP_CC_BUSY)\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (rc < 0)\r\nreturn rc;\r\nvcpu->arch.sie_block->gpsw.mask &= ~(3ul << 44);\r\nvcpu->arch.sie_block->gpsw.mask |= (rc & 3ul) << 44;\r\nreturn 0;\r\n}
