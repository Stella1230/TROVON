static int rx8025_read_reg(struct i2c_client *client, int number, u8 *value)\r\n{\r\nint ret = i2c_smbus_read_byte_data(client, (number << 4) | 0x08);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "Unable to read register #%d\n", number);\r\nreturn ret;\r\n}\r\n*value = ret;\r\nreturn 0;\r\n}\r\nstatic int rx8025_read_regs(struct i2c_client *client,\r\nint number, u8 length, u8 *values)\r\n{\r\nint ret = i2c_smbus_read_i2c_block_data(client, (number << 4) | 0x08,\r\nlength, values);\r\nif (ret != length) {\r\ndev_err(&client->dev, "Unable to read registers #%d..#%d\n",\r\nnumber, number + length - 1);\r\nreturn ret < 0 ? ret : -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8025_write_reg(struct i2c_client *client, int number, u8 value)\r\n{\r\nint ret = i2c_smbus_write_byte_data(client, number << 4, value);\r\nif (ret)\r\ndev_err(&client->dev, "Unable to write register #%d\n",\r\nnumber);\r\nreturn ret;\r\n}\r\nstatic int rx8025_write_regs(struct i2c_client *client,\r\nint number, u8 length, u8 *values)\r\n{\r\nint ret = i2c_smbus_write_i2c_block_data(client, (number << 4) | 0x08,\r\nlength, values);\r\nif (ret)\r\ndev_err(&client->dev, "Unable to write registers #%d..#%d\n",\r\nnumber, number + length - 1);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t rx8025_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\r\ndisable_irq_nosync(irq);\r\nschedule_work(&rx8025->work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void rx8025_work(struct work_struct *work)\r\n{\r\nstruct rx8025_data *rx8025 = container_of(work, struct rx8025_data,\r\nwork);\r\nstruct i2c_client *client = rx8025->client;\r\nstruct mutex *lock = &rx8025->rtc->ops_lock;\r\nu8 status;\r\nmutex_lock(lock);\r\nif (rx8025_read_reg(client, RX8025_REG_CTRL2, &status))\r\ngoto out;\r\nif (!(status & RX8025_BIT_CTRL2_XST))\r\ndev_warn(&client->dev, "Oscillation stop was detected,"\r\n"you may have to readjust the clock\n");\r\nif (status & RX8025_BIT_CTRL2_CTFG) {\r\nstatus &= ~RX8025_BIT_CTRL2_CTFG;\r\nlocal_irq_disable();\r\nrtc_update_irq(rx8025->rtc, 1, RTC_PF | RTC_IRQF);\r\nlocal_irq_enable();\r\n}\r\nif (status & RX8025_BIT_CTRL2_DAFG) {\r\nstatus &= RX8025_BIT_CTRL2_DAFG;\r\nif (rx8025_write_reg(client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1 & ~RX8025_BIT_CTRL1_DALE))\r\ngoto out;\r\nlocal_irq_disable();\r\nrtc_update_irq(rx8025->rtc, 1, RTC_AF | RTC_IRQF);\r\nlocal_irq_enable();\r\n}\r\nrx8025_write_reg(client, RX8025_REG_CTRL2,\r\nstatus | RX8025_BIT_CTRL2_XST);\r\nout:\r\nif (!rx8025->exiting)\r\nenable_irq(client->irq);\r\nmutex_unlock(lock);\r\n}\r\nstatic int rx8025_get_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 date[7];\r\nint err;\r\nerr = rx8025_read_regs(rx8025->client, RX8025_REG_SEC, 7, date);\r\nif (err)\r\nreturn err;\r\ndev_dbg(dev, "%s: read 0x%02x 0x%02x "\r\n"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n", __func__,\r\ndate[0], date[1], date[2], date[3], date[4],\r\ndate[5], date[6]);\r\ndt->tm_sec = bcd2bin(date[RX8025_REG_SEC] & 0x7f);\r\ndt->tm_min = bcd2bin(date[RX8025_REG_MIN] & 0x7f);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\ndt->tm_hour = bcd2bin(date[RX8025_REG_HOUR] & 0x3f);\r\nelse\r\ndt->tm_hour = bcd2bin(date[RX8025_REG_HOUR] & 0x1f) % 12\r\n+ (date[RX8025_REG_HOUR] & 0x20 ? 12 : 0);\r\ndt->tm_mday = bcd2bin(date[RX8025_REG_MDAY] & 0x3f);\r\ndt->tm_mon = bcd2bin(date[RX8025_REG_MONTH] & 0x1f) - 1;\r\ndt->tm_year = bcd2bin(date[RX8025_REG_YEAR]);\r\nif (dt->tm_year < 70)\r\ndt->tm_year += 100;\r\ndev_dbg(dev, "%s: date %ds %dm %dh %dmd %dm %dy\n", __func__,\r\ndt->tm_sec, dt->tm_min, dt->tm_hour,\r\ndt->tm_mday, dt->tm_mon, dt->tm_year);\r\nreturn rtc_valid_tm(dt);\r\n}\r\nstatic int rx8025_set_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 date[7];\r\ndate[RX8025_REG_SEC] = bin2bcd(dt->tm_sec);\r\ndate[RX8025_REG_MIN] = bin2bcd(dt->tm_min);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\ndate[RX8025_REG_HOUR] = bin2bcd(dt->tm_hour);\r\nelse\r\ndate[RX8025_REG_HOUR] = (dt->tm_hour >= 12 ? 0x20 : 0)\r\n| bin2bcd((dt->tm_hour + 11) % 12 + 1);\r\ndate[RX8025_REG_WDAY] = bin2bcd(dt->tm_wday);\r\ndate[RX8025_REG_MDAY] = bin2bcd(dt->tm_mday);\r\ndate[RX8025_REG_MONTH] = bin2bcd(dt->tm_mon + 1);\r\ndate[RX8025_REG_YEAR] = bin2bcd(dt->tm_year % 100);\r\ndev_dbg(dev,\r\n"%s: write 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\n__func__,\r\ndate[0], date[1], date[2], date[3], date[4], date[5], date[6]);\r\nreturn rx8025_write_regs(rx8025->client, RX8025_REG_SEC, 7, date);\r\n}\r\nstatic int rx8025_init_client(struct i2c_client *client, int *need_reset)\r\n{\r\nstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\r\nu8 ctrl[2], ctrl2;\r\nint need_clear = 0;\r\nint err;\r\nerr = rx8025_read_regs(rx8025->client, RX8025_REG_CTRL1, 2, ctrl);\r\nif (err)\r\ngoto out;\r\nrx8025->ctrl1 = ctrl[0] & ~RX8025_BIT_CTRL1_TEST;\r\nif (ctrl[1] & RX8025_BIT_CTRL2_PON) {\r\ndev_warn(&client->dev, "power-on reset was detected, "\r\n"you may have to readjust the clock\n");\r\n*need_reset = 1;\r\n}\r\nif (ctrl[1] & RX8025_BIT_CTRL2_VDET) {\r\ndev_warn(&client->dev, "a power voltage drop was detected, "\r\n"you may have to readjust the clock\n");\r\n*need_reset = 1;\r\n}\r\nif (!(ctrl[1] & RX8025_BIT_CTRL2_XST)) {\r\ndev_warn(&client->dev, "Oscillation stop was detected,"\r\n"you may have to readjust the clock\n");\r\n*need_reset = 1;\r\n}\r\nif (ctrl[1] & (RX8025_BIT_CTRL2_DAFG | RX8025_BIT_CTRL2_WAFG)) {\r\ndev_warn(&client->dev, "Alarm was detected\n");\r\nneed_clear = 1;\r\n}\r\nif (!(ctrl[1] & RX8025_BIT_CTRL2_CTFG))\r\nneed_clear = 1;\r\nif (*need_reset || need_clear) {\r\nctrl2 = ctrl[0];\r\nctrl2 &= ~(RX8025_BIT_CTRL2_PON | RX8025_BIT_CTRL2_VDET |\r\nRX8025_BIT_CTRL2_CTFG | RX8025_BIT_CTRL2_WAFG |\r\nRX8025_BIT_CTRL2_DAFG);\r\nctrl2 |= RX8025_BIT_CTRL2_XST;\r\nerr = rx8025_write_reg(client, RX8025_REG_CTRL2, ctrl2);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int rx8025_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = rx8025->client;\r\nu8 ctrl2, ald[2];\r\nint err;\r\nif (client->irq <= 0)\r\nreturn -EINVAL;\r\nerr = rx8025_read_regs(client, RX8025_REG_ALDMIN, 2, ald);\r\nif (err)\r\nreturn err;\r\nerr = rx8025_read_reg(client, RX8025_REG_CTRL2, &ctrl2);\r\nif (err)\r\nreturn err;\r\ndev_dbg(dev, "%s: read alarm 0x%02x 0x%02x ctrl2 %02x\n",\r\n__func__, ald[0], ald[1], ctrl2);\r\nt->time.tm_sec = 0;\r\nt->time.tm_min = bcd2bin(ald[0] & 0x7f);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\nt->time.tm_hour = bcd2bin(ald[1] & 0x3f);\r\nelse\r\nt->time.tm_hour = bcd2bin(ald[1] & 0x1f) % 12\r\n+ (ald[1] & 0x20 ? 12 : 0);\r\nt->time.tm_wday = -1;\r\nt->time.tm_mday = -1;\r\nt->time.tm_mon = -1;\r\nt->time.tm_year = -1;\r\ndev_dbg(dev, "%s: date: %ds %dm %dh %dmd %dm %dy\n",\r\n__func__,\r\nt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\r\nt->time.tm_mday, t->time.tm_mon, t->time.tm_year);\r\nt->enabled = !!(rx8025->ctrl1 & RX8025_BIT_CTRL1_DALE);\r\nt->pending = (ctrl2 & RX8025_BIT_CTRL2_DAFG) && t->enabled;\r\nreturn err;\r\n}\r\nstatic int rx8025_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 ald[2];\r\nint err;\r\nif (client->irq <= 0)\r\nreturn -EINVAL;\r\nald[0] = bin2bcd(t->time.tm_min);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\nald[1] = bin2bcd(t->time.tm_hour);\r\nelse\r\nald[1] = (t->time.tm_hour >= 12 ? 0x20 : 0)\r\n| bin2bcd((t->time.tm_hour + 11) % 12 + 1);\r\ndev_dbg(dev, "%s: write 0x%02x 0x%02x\n", __func__, ald[0], ald[1]);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_DALE) {\r\nrx8025->ctrl1 &= ~RX8025_BIT_CTRL1_DALE;\r\nerr = rx8025_write_reg(rx8025->client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = rx8025_write_regs(rx8025->client, RX8025_REG_ALDMIN, 2, ald);\r\nif (err)\r\nreturn err;\r\nif (t->enabled) {\r\nrx8025->ctrl1 |= RX8025_BIT_CTRL1_DALE;\r\nerr = rx8025_write_reg(rx8025->client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8025_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 ctrl1;\r\nint err;\r\nctrl1 = rx8025->ctrl1;\r\nif (enabled)\r\nctrl1 |= RX8025_BIT_CTRL1_DALE;\r\nelse\r\nctrl1 &= ~RX8025_BIT_CTRL1_DALE;\r\nif (ctrl1 != rx8025->ctrl1) {\r\nrx8025->ctrl1 = ctrl1;\r\nerr = rx8025_write_reg(rx8025->client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8025_get_clock_adjust(struct device *dev, int *adj)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 digoff;\r\nint err;\r\nerr = rx8025_read_reg(client, RX8025_REG_DIGOFF, &digoff);\r\nif (err)\r\nreturn err;\r\n*adj = digoff >= 64 ? digoff - 128 : digoff;\r\nif (*adj > 0)\r\n(*adj)--;\r\n*adj *= -RX8025_ADJ_RESOLUTION;\r\nreturn 0;\r\n}\r\nstatic int rx8025_set_clock_adjust(struct device *dev, int adj)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 digoff;\r\nint err;\r\nadj /= -RX8025_ADJ_RESOLUTION;\r\nif (adj > RX8025_ADJ_DATA_MAX)\r\nadj = RX8025_ADJ_DATA_MAX;\r\nelse if (adj < RX8025_ADJ_DATA_MIN)\r\nadj = RX8025_ADJ_DATA_MIN;\r\nelse if (adj > 0)\r\nadj++;\r\nelse if (adj < 0)\r\nadj += 128;\r\ndigoff = adj;\r\nerr = rx8025_write_reg(client, RX8025_REG_DIGOFF, digoff);\r\nif (err)\r\nreturn err;\r\ndev_dbg(dev, "%s: write 0x%02x\n", __func__, digoff);\r\nreturn 0;\r\n}\r\nstatic ssize_t rx8025_sysfs_show_clock_adjust(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint err, adj;\r\nerr = rx8025_get_clock_adjust(dev, &adj);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", adj);\r\n}\r\nstatic ssize_t rx8025_sysfs_store_clock_adjust(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint adj, err;\r\nif (sscanf(buf, "%i", &adj) != 1)\r\nreturn -EINVAL;\r\nerr = rx8025_set_clock_adjust(dev, adj);\r\nreturn err ? err : count;\r\n}\r\nstatic int rx8025_sysfs_register(struct device *dev)\r\n{\r\nreturn device_create_file(dev, &dev_attr_clock_adjust_ppb);\r\n}\r\nstatic void rx8025_sysfs_unregister(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_clock_adjust_ppb);\r\n}\r\nstatic int rx8025_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct rx8025_data *rx8025;\r\nint err, need_reset = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ndev_err(&adapter->dev,\r\n"doesn't support required functionality\n");\r\nerr = -EIO;\r\ngoto errout;\r\n}\r\nrx8025 = devm_kzalloc(&client->dev, sizeof(*rx8025), GFP_KERNEL);\r\nif (!rx8025) {\r\ndev_err(&adapter->dev, "failed to alloc memory\n");\r\nerr = -ENOMEM;\r\ngoto errout;\r\n}\r\nrx8025->client = client;\r\ni2c_set_clientdata(client, rx8025);\r\nINIT_WORK(&rx8025->work, rx8025_work);\r\nerr = rx8025_init_client(client, &need_reset);\r\nif (err)\r\ngoto errout;\r\nif (need_reset) {\r\nstruct rtc_time tm;\r\ndev_info(&client->dev,\r\n"bad conditions detected, resetting date\n");\r\nrtc_time_to_tm(0, &tm);\r\nrx8025_set_time(&client->dev, &tm);\r\n}\r\nrx8025->rtc = devm_rtc_device_register(&client->dev, client->name,\r\n&rx8025_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rx8025->rtc)) {\r\nerr = PTR_ERR(rx8025->rtc);\r\ndev_err(&client->dev, "unable to register the class device\n");\r\ngoto errout;\r\n}\r\nif (client->irq > 0) {\r\ndev_info(&client->dev, "IRQ %d supplied\n", client->irq);\r\nerr = request_irq(client->irq, rx8025_irq,\r\n0, "rx8025", client);\r\nif (err) {\r\ndev_err(&client->dev, "unable to request IRQ\n");\r\ngoto errout;\r\n}\r\n}\r\nrx8025->rtc->irq_freq = 1;\r\nrx8025->rtc->max_user_freq = 1;\r\nerr = rx8025_sysfs_register(&client->dev);\r\nif (err)\r\ngoto errout_irq;\r\nreturn 0;\r\nerrout_irq:\r\nif (client->irq > 0)\r\nfree_irq(client->irq, client);\r\nerrout:\r\ndev_err(&adapter->dev, "probing for rx8025 failed\n");\r\nreturn err;\r\n}\r\nstatic int rx8025_remove(struct i2c_client *client)\r\n{\r\nstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\r\nstruct mutex *lock = &rx8025->rtc->ops_lock;\r\nif (client->irq > 0) {\r\nmutex_lock(lock);\r\nrx8025->exiting = 1;\r\nmutex_unlock(lock);\r\nfree_irq(client->irq, client);\r\ncancel_work_sync(&rx8025->work);\r\n}\r\nrx8025_sysfs_unregister(&client->dev);\r\nreturn 0;\r\n}
