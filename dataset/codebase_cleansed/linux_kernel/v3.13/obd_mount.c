int lustre_process_log(struct super_block *sb, char *logname,\r\nstruct config_llog_instance *cfg)\r\n{\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs *bufs;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *mgc = lsi->lsi_mgc;\r\nint rc;\r\nLASSERT(mgc);\r\nLASSERT(cfg);\r\nOBD_ALLOC_PTR(bufs);\r\nif (bufs == NULL)\r\nreturn -ENOMEM;\r\nlustre_cfg_bufs_reset(bufs, mgc->obd_name);\r\nlustre_cfg_bufs_set_string(bufs, 1, logname);\r\nlustre_cfg_bufs_set(bufs, 2, cfg, sizeof(*cfg));\r\nlustre_cfg_bufs_set(bufs, 3, &sb, sizeof(sb));\r\nlcfg = lustre_cfg_new(LCFG_LOG_START, bufs);\r\nrc = obd_process_config(mgc, sizeof(*lcfg), lcfg);\r\nlustre_cfg_free(lcfg);\r\nOBD_FREE_PTR(bufs);\r\nif (rc == -EINVAL)\r\nLCONSOLE_ERROR_MSG(0x15b, "%s: The configuration from log '%s'"\r\n"failed from the MGS (%d). Make sure this "\r\n"client and the MGS are running compatible "\r\n"versions of Lustre.\n",\r\nmgc->obd_name, logname, rc);\r\nif (rc)\r\nLCONSOLE_ERROR_MSG(0x15c, "%s: The configuration from log '%s' "\r\n"failed (%d). This may be the result of "\r\n"communication errors between this node and "\r\n"the MGS, a bad configuration, or other "\r\n"errors. See the syslog for more "\r\n"information.\n", mgc->obd_name, logname,\r\nrc);\r\nreturn rc;\r\n}\r\nint lustre_end_log(struct super_block *sb, char *logname,\r\nstruct config_llog_instance *cfg)\r\n{\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs bufs;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *mgc = lsi->lsi_mgc;\r\nint rc;\r\nif (!mgc)\r\nreturn -ENOENT;\r\nlustre_cfg_bufs_reset(&bufs, mgc->obd_name);\r\nlustre_cfg_bufs_set_string(&bufs, 1, logname);\r\nif (cfg)\r\nlustre_cfg_bufs_set(&bufs, 2, cfg, sizeof(*cfg));\r\nlcfg = lustre_cfg_new(LCFG_LOG_END, &bufs);\r\nrc = obd_process_config(mgc, sizeof(*lcfg), lcfg);\r\nlustre_cfg_free(lcfg);\r\nreturn rc;\r\n}\r\nint do_lcfg(char *cfgname, lnet_nid_t nid, int cmd,\r\nchar *s1, char *s2, char *s3, char *s4)\r\n{\r\nstruct lustre_cfg_bufs bufs;\r\nstruct lustre_cfg * lcfg = NULL;\r\nint rc;\r\nCDEBUG(D_TRACE, "lcfg %s %#x %s %s %s %s\n", cfgname,\r\ncmd, s1, s2, s3, s4);\r\nlustre_cfg_bufs_reset(&bufs, cfgname);\r\nif (s1)\r\nlustre_cfg_bufs_set_string(&bufs, 1, s1);\r\nif (s2)\r\nlustre_cfg_bufs_set_string(&bufs, 2, s2);\r\nif (s3)\r\nlustre_cfg_bufs_set_string(&bufs, 3, s3);\r\nif (s4)\r\nlustre_cfg_bufs_set_string(&bufs, 4, s4);\r\nlcfg = lustre_cfg_new(cmd, &bufs);\r\nlcfg->lcfg_nid = nid;\r\nrc = class_process_config(lcfg);\r\nlustre_cfg_free(lcfg);\r\nreturn(rc);\r\n}\r\nint lustre_start_simple(char *obdname, char *type, char *uuid,\r\nchar *s1, char *s2, char *s3, char *s4)\r\n{\r\nint rc;\r\nCDEBUG(D_MOUNT, "Starting obd %s (typ=%s)\n", obdname, type);\r\nrc = do_lcfg(obdname, 0, LCFG_ATTACH, type, uuid, 0, 0);\r\nif (rc) {\r\nCERROR("%s attach error %d\n", obdname, rc);\r\nreturn rc;\r\n}\r\nrc = do_lcfg(obdname, 0, LCFG_SETUP, s1, s2, s3, s4);\r\nif (rc) {\r\nCERROR("%s setup error %d\n", obdname, rc);\r\ndo_lcfg(obdname, 0, LCFG_DETACH, 0, 0, 0, 0);\r\n}\r\nreturn rc;\r\n}\r\nint lustre_start_mgc(struct super_block *sb)\r\n{\r\nstruct obd_connect_data *data = NULL;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *obd;\r\nstruct obd_export *exp;\r\nstruct obd_uuid *uuid;\r\nclass_uuid_t uuidc;\r\nlnet_nid_t nid;\r\nchar *mgcname = NULL, *niduuid = NULL, *mgssec = NULL;\r\nchar *ptr;\r\nint recov_bk;\r\nint rc = 0, i = 0, j, len;\r\nLASSERT(lsi->lsi_lmd);\r\nif (IS_SERVER(lsi)) {\r\nptr = lsi->lsi_lmd->lmd_mgs;\r\nif (lsi->lsi_lmd->lmd_mgs &&\r\n(class_parse_nid(lsi->lsi_lmd->lmd_mgs, &nid, &ptr) == 0)) {\r\ni++;\r\n} else if (IS_MGS(lsi)) {\r\nlnet_process_id_t id;\r\nwhile ((rc = LNetGetId(i++, &id)) != -ENOENT) {\r\nif (LNET_NETTYP(LNET_NIDNET(id.nid)) == LOLND)\r\ncontinue;\r\nnid = id.nid;\r\ni++;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nptr = lsi->lsi_lmd->lmd_dev;\r\nif (class_parse_nid(ptr, &nid, &ptr) == 0)\r\ni++;\r\n}\r\nif (i == 0) {\r\nCERROR("No valid MGS nids found.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&mgc_start_lock);\r\nlen = strlen(LUSTRE_MGC_OBDNAME) + strlen(libcfs_nid2str(nid)) + 1;\r\nOBD_ALLOC(mgcname, len);\r\nOBD_ALLOC(niduuid, len + 2);\r\nif (!mgcname || !niduuid)\r\nGOTO(out_free, rc = -ENOMEM);\r\nsprintf(mgcname, "%s%s", LUSTRE_MGC_OBDNAME, libcfs_nid2str(nid));\r\nmgssec = lsi->lsi_lmd->lmd_mgssec ? lsi->lsi_lmd->lmd_mgssec : "";\r\nOBD_ALLOC_PTR(data);\r\nif (data == NULL)\r\nGOTO(out_free, rc = -ENOMEM);\r\nobd = class_name2obd(mgcname);\r\nif (obd && !obd->obd_stopping) {\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nstrlen(KEY_MGSSEC), KEY_MGSSEC,\r\nstrlen(mgssec), mgssec, NULL);\r\nif (rc)\r\nGOTO(out_free, rc);\r\natomic_inc(&obd->u.cli.cl_mgc_refcount);\r\nif (lmd_is_client(lsi->lsi_lmd)) {\r\nint has_ir;\r\nint vallen = sizeof(*data);\r\n__u32 *flags = &lsi->lsi_lmd->lmd_flags;\r\nrc = obd_get_info(NULL, obd->obd_self_export,\r\nstrlen(KEY_CONN_DATA), KEY_CONN_DATA,\r\n&vallen, data, NULL);\r\nLASSERT(rc == 0);\r\nhas_ir = OCD_HAS_FLAG(data, IMP_RECOV);\r\nif (has_ir ^ !(*flags & LMD_FLG_NOIR)) {\r\nLCONSOLE_WARN(\r\n"Trying to mount a client with IR setting "\r\n"not compatible with current mgc. "\r\n"Force to use current mgc setting that is "\r\n"IR %s.\n",\r\nhas_ir ? "enabled" : "disabled");\r\nif (has_ir)\r\n*flags &= ~LMD_FLG_NOIR;\r\nelse\r\n*flags |= LMD_FLG_NOIR;\r\n}\r\n}\r\nrecov_bk = 0;\r\nif (IS_MGS(lsi)) {\r\nCDEBUG(D_MOUNT, "New MGS with live MGC\n");\r\nrecov_bk = 1;\r\n}\r\nrecov_bk++;\r\nCDEBUG(D_MOUNT, "%s: Set MGC reconnect %d\n", mgcname,recov_bk);\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nsizeof(KEY_INIT_RECOV_BACKUP),\r\nKEY_INIT_RECOV_BACKUP,\r\nsizeof(recov_bk), &recov_bk, NULL);\r\nGOTO(out, rc = 0);\r\n}\r\nCDEBUG(D_MOUNT, "Start MGC '%s'\n", mgcname);\r\ni = 0;\r\nsprintf(niduuid, "%s_%x", mgcname, i);\r\nif (IS_SERVER(lsi)) {\r\nptr = lsi->lsi_lmd->lmd_mgs;\r\nif (IS_MGS(lsi)) {\r\nlnet_process_id_t id;\r\nwhile ((rc = LNetGetId(i++, &id)) != -ENOENT) {\r\nrc = do_lcfg(mgcname, id.nid,\r\nLCFG_ADD_UUID, niduuid, 0,0,0);\r\n}\r\n} else {\r\nif (lsi->lsi_lmd->lmd_mgs) {\r\nptr = lsi->lsi_lmd->lmd_mgs;\r\n} else if (class_find_param(ptr, PARAM_MGSNODE,\r\n&ptr) != 0) {\r\nCERROR("No MGS nids given.\n");\r\nGOTO(out_free, rc = -EINVAL);\r\n}\r\nwhile (class_parse_nid(ptr, &nid, &ptr) == 0) {\r\nrc = do_lcfg(mgcname, nid,\r\nLCFG_ADD_UUID, niduuid, 0,0,0);\r\ni++;\r\n}\r\n}\r\n} else {\r\nptr = lsi->lsi_lmd->lmd_dev;\r\nwhile (class_parse_nid(ptr, &nid, &ptr) == 0) {\r\nrc = do_lcfg(mgcname, nid,\r\nLCFG_ADD_UUID, niduuid, 0,0,0);\r\ni++;\r\nif (*ptr == ':')\r\nbreak;\r\n}\r\n}\r\nif (i == 0) {\r\nCERROR("No valid MGS nids found.\n");\r\nGOTO(out_free, rc = -EINVAL);\r\n}\r\nlsi->lsi_lmd->lmd_mgs_failnodes = 1;\r\nOBD_ALLOC_PTR(uuid);\r\nll_generate_random_uuid(uuidc);\r\nclass_uuid_unparse(uuidc, uuid);\r\nrc = lustre_start_simple(mgcname, LUSTRE_MGC_NAME,\r\n(char *)uuid->uuid, LUSTRE_MGS_OBDNAME,\r\nniduuid, 0, 0);\r\nOBD_FREE_PTR(uuid);\r\nif (rc)\r\nGOTO(out_free, rc);\r\ni = 1;\r\nwhile (ptr && ((*ptr == ':' ||\r\nclass_find_param(ptr, PARAM_MGSNODE, &ptr) == 0))) {\r\nsprintf(niduuid, "%s_%x", mgcname, i);\r\nj = 0;\r\nwhile (class_parse_nid_quiet(ptr, &nid, &ptr) == 0) {\r\nj++;\r\nrc = do_lcfg(mgcname, nid,\r\nLCFG_ADD_UUID, niduuid, 0,0,0);\r\nif (*ptr == ':')\r\nbreak;\r\n}\r\nif (j > 0) {\r\nrc = do_lcfg(mgcname, 0, LCFG_ADD_CONN,\r\nniduuid, 0, 0, 0);\r\ni++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nlsi->lsi_lmd->lmd_mgs_failnodes = i;\r\nobd = class_name2obd(mgcname);\r\nif (!obd) {\r\nCERROR("Can't find mgcobd %s\n", mgcname);\r\nGOTO(out_free, rc = -ENOTCONN);\r\n}\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nstrlen(KEY_MGSSEC), KEY_MGSSEC,\r\nstrlen(mgssec), mgssec, NULL);\r\nif (rc)\r\nGOTO(out_free, rc);\r\natomic_set(&obd->u.cli.cl_mgc_refcount, 1);\r\nrecov_bk = 1;\r\nrc = obd_set_info_async(NULL, obd->obd_self_export,\r\nsizeof(KEY_INIT_RECOV_BACKUP),\r\nKEY_INIT_RECOV_BACKUP,\r\nsizeof(recov_bk), &recov_bk, NULL);\r\nif (rc)\r\nCWARN("can't set %s %d\n", KEY_INIT_RECOV_BACKUP, rc);\r\ndata->ocd_connect_flags = OBD_CONNECT_VERSION | OBD_CONNECT_AT |\r\nOBD_CONNECT_FULL20 | OBD_CONNECT_IMP_RECOV |\r\nOBD_CONNECT_LVB_TYPE;\r\n#if LUSTRE_VERSION_CODE < OBD_OCD_VERSION(3, 2, 50, 0)\r\ndata->ocd_connect_flags |= OBD_CONNECT_MNE_SWAB;\r\n#else\r\n#warning "LU-1644: Remove old OBD_CONNECT_MNE_SWAB fixup and imp_need_mne_swab"\r\n#endif\r\nif (lmd_is_client(lsi->lsi_lmd) &&\r\nlsi->lsi_lmd->lmd_flags & LMD_FLG_NOIR)\r\ndata->ocd_connect_flags &= ~OBD_CONNECT_IMP_RECOV;\r\ndata->ocd_version = LUSTRE_VERSION_CODE;\r\nrc = obd_connect(NULL, &exp, obd, &(obd->obd_uuid), data, NULL);\r\nif (rc) {\r\nCERROR("connect failed %d\n", rc);\r\nGOTO(out, rc);\r\n}\r\nobd->u.cli.cl_mgc_mgsexp = exp;\r\nout:\r\nlsi->lsi_mgc = obd;\r\nout_free:\r\nmutex_unlock(&mgc_start_lock);\r\nif (data)\r\nOBD_FREE_PTR(data);\r\nif (mgcname)\r\nOBD_FREE(mgcname, len);\r\nif (niduuid)\r\nOBD_FREE(niduuid, len + 2);\r\nreturn rc;\r\n}\r\nstatic int lustre_stop_mgc(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct obd_device *obd;\r\nchar *niduuid = 0, *ptr = 0;\r\nint i, rc = 0, len = 0;\r\nif (!lsi)\r\nreturn -ENOENT;\r\nobd = lsi->lsi_mgc;\r\nif (!obd)\r\nreturn -ENOENT;\r\nlsi->lsi_mgc = NULL;\r\nmutex_lock(&mgc_start_lock);\r\nLASSERT(atomic_read(&obd->u.cli.cl_mgc_refcount) > 0);\r\nif (!atomic_dec_and_test(&obd->u.cli.cl_mgc_refcount)) {\r\nCDEBUG(D_MOUNT, "mgc still has %d references.\n",\r\natomic_read(&obd->u.cli.cl_mgc_refcount));\r\nGOTO(out, rc = -EBUSY);\r\n}\r\nobd->obd_no_recov = 1;\r\nif (obd->u.cli.cl_mgc_mgsexp) {\r\nrc = obd_disconnect(obd->u.cli.cl_mgc_mgsexp);\r\nif (rc)\r\nCDEBUG(D_MOUNT, "disconnect failed %d\n", rc);\r\n}\r\nlen = strlen(obd->obd_name) + 6;\r\nOBD_ALLOC(niduuid, len);\r\nif (niduuid) {\r\nstrcpy(niduuid, obd->obd_name);\r\nptr = niduuid + strlen(niduuid);\r\n}\r\nrc = class_manual_cleanup(obd);\r\nif (rc)\r\nGOTO(out, rc);\r\nif (!niduuid)\r\nGOTO(out, rc = -ENOMEM);\r\nfor (i = 0; i < lsi->lsi_lmd->lmd_mgs_failnodes; i++) {\r\nsprintf(ptr, "_%x", i);\r\nrc = do_lcfg(LUSTRE_MGC_OBDNAME, 0, LCFG_DEL_UUID,\r\nniduuid, 0, 0, 0);\r\nif (rc)\r\nCERROR("del MDC UUID %s failed: rc = %d\n",\r\nniduuid, rc);\r\n}\r\nout:\r\nif (niduuid)\r\nOBD_FREE(niduuid, len);\r\nmutex_unlock(&mgc_start_lock);\r\nreturn rc;\r\n}\r\nstruct lustre_sb_info *lustre_init_lsi(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi;\r\nOBD_ALLOC_PTR(lsi);\r\nif (!lsi)\r\nreturn NULL;\r\nOBD_ALLOC_PTR(lsi->lsi_lmd);\r\nif (!lsi->lsi_lmd) {\r\nOBD_FREE_PTR(lsi);\r\nreturn NULL;\r\n}\r\nlsi->lsi_lmd->lmd_exclude_count = 0;\r\nlsi->lsi_lmd->lmd_recovery_time_soft = 0;\r\nlsi->lsi_lmd->lmd_recovery_time_hard = 0;\r\ns2lsi_nocast(sb) = lsi;\r\natomic_set(&lsi->lsi_mounts, 1);\r\nlsi->lsi_flags = LSI_UMOUNT_FAILOVER;\r\nreturn lsi;\r\n}\r\nstatic int lustre_free_lsi(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nLASSERT(lsi != NULL);\r\nCDEBUG(D_MOUNT, "Freeing lsi %p\n", lsi);\r\nLASSERT(atomic_read(&lsi->lsi_mounts) == 0);\r\nif (lsi->lsi_lmd != NULL) {\r\nif (lsi->lsi_lmd->lmd_dev != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_dev,\r\nstrlen(lsi->lsi_lmd->lmd_dev) + 1);\r\nif (lsi->lsi_lmd->lmd_profile != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_profile,\r\nstrlen(lsi->lsi_lmd->lmd_profile) + 1);\r\nif (lsi->lsi_lmd->lmd_mgssec != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_mgssec,\r\nstrlen(lsi->lsi_lmd->lmd_mgssec) + 1);\r\nif (lsi->lsi_lmd->lmd_opts != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_opts,\r\nstrlen(lsi->lsi_lmd->lmd_opts) + 1);\r\nif (lsi->lsi_lmd->lmd_exclude_count)\r\nOBD_FREE(lsi->lsi_lmd->lmd_exclude,\r\nsizeof(lsi->lsi_lmd->lmd_exclude[0]) *\r\nlsi->lsi_lmd->lmd_exclude_count);\r\nif (lsi->lsi_lmd->lmd_mgs != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_mgs,\r\nstrlen(lsi->lsi_lmd->lmd_mgs) + 1);\r\nif (lsi->lsi_lmd->lmd_osd_type != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_osd_type,\r\nstrlen(lsi->lsi_lmd->lmd_osd_type) + 1);\r\nif (lsi->lsi_lmd->lmd_params != NULL)\r\nOBD_FREE(lsi->lsi_lmd->lmd_params, 4096);\r\nOBD_FREE(lsi->lsi_lmd, sizeof(*lsi->lsi_lmd));\r\n}\r\nLASSERT(lsi->lsi_llsbi == NULL);\r\nOBD_FREE(lsi, sizeof(*lsi));\r\ns2lsi_nocast(sb) = NULL;\r\nreturn 0;\r\n}\r\nint lustre_put_lsi(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nLASSERT(lsi != NULL);\r\nCDEBUG(D_MOUNT, "put %p %d\n", sb, atomic_read(&lsi->lsi_mounts));\r\nif (atomic_dec_and_test(&lsi->lsi_mounts)) {\r\nif (IS_SERVER(lsi) && lsi->lsi_osd_exp) {\r\nobd_disconnect(lsi->lsi_osd_exp);\r\nobd_zombie_barrier();\r\n}\r\nlustre_free_lsi(sb);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint server_name2fsname(const char *svname, char *fsname, const char **endptr)\r\n{\r\nconst char *dash;\r\ndash = svname + strnlen(svname, 8);\r\nfor (; dash > svname && *dash != '-' && *dash != ':'; dash--)\r\n;\r\nif (dash == svname)\r\nreturn -EINVAL;\r\nif (fsname != NULL) {\r\nstrncpy(fsname, svname, dash - svname);\r\nfsname[dash - svname] = '\0';\r\n}\r\nif (endptr != NULL)\r\n*endptr = dash;\r\nreturn 0;\r\n}\r\nint server_name2svname(const char *label, char *svname, const char **endptr,\r\nsize_t svsize)\r\n{\r\nint rc;\r\nconst char *dash;\r\nrc = server_name2fsname(label, NULL, &dash);\r\nif (rc != 0)\r\nreturn rc;\r\nif (endptr != NULL)\r\n*endptr = dash;\r\nif (strlcpy(svname, dash + 1, svsize) >= svsize)\r\nreturn -E2BIG;\r\nreturn 0;\r\n}\r\nint server_name2index(const char *svname, __u32 *idx, const char **endptr)\r\n{\r\nunsigned long index;\r\nint rc;\r\nconst char *dash;\r\nrc = server_name2fsname(svname, NULL, &dash);\r\nif (rc != 0)\r\nreturn rc;\r\ndash++;\r\nif (strncmp(dash, "MDT", 3) == 0)\r\nrc = LDD_F_SV_TYPE_MDT;\r\nelse if (strncmp(dash, "OST", 3) == 0)\r\nrc = LDD_F_SV_TYPE_OST;\r\nelse\r\nreturn -EINVAL;\r\ndash += 3;\r\nif (strncmp(dash, "all", 3) == 0) {\r\nif (endptr != NULL)\r\n*endptr = dash + 3;\r\nreturn rc | LDD_F_SV_ALL;\r\n}\r\nindex = simple_strtoul(dash, (char **)endptr, 16);\r\nif (idx != NULL)\r\n*idx = index;\r\nif (endptr != NULL && strncmp(LUSTRE_MDC_NAME, *endptr + 1,\r\nsizeof(LUSTRE_MDC_NAME)-1) == 0)\r\n*endptr += sizeof(LUSTRE_MDC_NAME);\r\nreturn rc;\r\n}\r\nint lustre_common_put_super(struct super_block *sb)\r\n{\r\nint rc;\r\nCDEBUG(D_MOUNT, "dropping sb %p\n", sb);\r\nrc = lustre_stop_mgc(sb);\r\nif (rc && (rc != -ENOENT)) {\r\nif (rc != -EBUSY) {\r\nCERROR("Can't stop MGC: %d\n", rc);\r\nreturn rc;\r\n}\r\nCDEBUG(D_MOUNT, "MGC still in use\n");\r\n}\r\nlustre_put_lsi(sb);\r\nlu_types_stop();\r\nreturn rc;\r\n}\r\nstatic void lmd_print(struct lustre_mount_data *lmd)\r\n{\r\nint i;\r\nPRINT_CMD(D_MOUNT, " mount data:\n");\r\nif (lmd_is_client(lmd))\r\nPRINT_CMD(D_MOUNT, "profile: %s\n", lmd->lmd_profile);\r\nPRINT_CMD(D_MOUNT, "device: %s\n", lmd->lmd_dev);\r\nPRINT_CMD(D_MOUNT, "flags: %x\n", lmd->lmd_flags);\r\nif (lmd->lmd_opts)\r\nPRINT_CMD(D_MOUNT, "options: %s\n", lmd->lmd_opts);\r\nif (lmd->lmd_recovery_time_soft)\r\nPRINT_CMD(D_MOUNT, "recovery time soft: %d\n",\r\nlmd->lmd_recovery_time_soft);\r\nif (lmd->lmd_recovery_time_hard)\r\nPRINT_CMD(D_MOUNT, "recovery time hard: %d\n",\r\nlmd->lmd_recovery_time_hard);\r\nfor (i = 0; i < lmd->lmd_exclude_count; i++) {\r\nPRINT_CMD(D_MOUNT, "exclude %d: OST%04x\n", i,\r\nlmd->lmd_exclude[i]);\r\n}\r\n}\r\nint lustre_check_exclusion(struct super_block *sb, char *svname)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct lustre_mount_data *lmd = lsi->lsi_lmd;\r\n__u32 index;\r\nint i, rc;\r\nrc = server_name2index(svname, &index, NULL);\r\nif (rc != LDD_F_SV_TYPE_OST)\r\nreturn 0;\r\nCDEBUG(D_MOUNT, "Check exclusion %s (%d) in %d of %s\n", svname,\r\nindex, lmd->lmd_exclude_count, lmd->lmd_dev);\r\nfor(i = 0; i < lmd->lmd_exclude_count; i++) {\r\nif (index == lmd->lmd_exclude[i]) {\r\nCWARN("Excluding %s (on exclusion list)\n", svname);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int lmd_make_exclusion(struct lustre_mount_data *lmd, const char *ptr)\r\n{\r\nconst char *s1 = ptr, *s2;\r\n__u32 index, *exclude_list;\r\nint rc = 0, devmax;\r\ndevmax = strlen(ptr) / 8 + 1;\r\nOBD_ALLOC(exclude_list, sizeof(index) * devmax);\r\nif (!exclude_list)\r\nreturn -ENOMEM;\r\nwhile (*s1 && *s1 != ' ' && *s1 != ',') {\r\ns1++;\r\nrc = server_name2index(s1, &index, &s2);\r\nif (rc < 0) {\r\nCERROR("Can't parse server name '%s': rc = %d\n",\r\ns1, rc);\r\nbreak;\r\n}\r\nif (rc == LDD_F_SV_TYPE_OST)\r\nexclude_list[lmd->lmd_exclude_count++] = index;\r\nelse\r\nCDEBUG(D_MOUNT, "ignoring exclude %.*s: type = %#x\n",\r\n(uint)(s2-s1), s1, rc);\r\ns1 = s2;\r\nif (lmd->lmd_exclude_count >= devmax)\r\nbreak;\r\n}\r\nif (rc >= 0)\r\nrc = 0;\r\nif (lmd->lmd_exclude_count) {\r\nOBD_ALLOC(lmd->lmd_exclude, sizeof(index) *\r\nlmd->lmd_exclude_count);\r\nif (lmd->lmd_exclude) {\r\nmemcpy(lmd->lmd_exclude, exclude_list,\r\nsizeof(index) * lmd->lmd_exclude_count);\r\n} else {\r\nrc = -ENOMEM;\r\nlmd->lmd_exclude_count = 0;\r\n}\r\n}\r\nOBD_FREE(exclude_list, sizeof(index) * devmax);\r\nreturn rc;\r\n}\r\nstatic int lmd_parse_mgssec(struct lustre_mount_data *lmd, char *ptr)\r\n{\r\nchar *tail;\r\nint length;\r\nif (lmd->lmd_mgssec != NULL) {\r\nOBD_FREE(lmd->lmd_mgssec, strlen(lmd->lmd_mgssec) + 1);\r\nlmd->lmd_mgssec = NULL;\r\n}\r\ntail = strchr(ptr, ',');\r\nif (tail == NULL)\r\nlength = strlen(ptr);\r\nelse\r\nlength = tail - ptr;\r\nOBD_ALLOC(lmd->lmd_mgssec, length + 1);\r\nif (lmd->lmd_mgssec == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(lmd->lmd_mgssec, ptr, length);\r\nlmd->lmd_mgssec[length] = '\0';\r\nreturn 0;\r\n}\r\nstatic int lmd_parse_string(char **handle, char *ptr)\r\n{\r\nchar *tail;\r\nint length;\r\nif ((handle == NULL) || (ptr == NULL))\r\nreturn -EINVAL;\r\nif (*handle != NULL) {\r\nOBD_FREE(*handle, strlen(*handle) + 1);\r\n*handle = NULL;\r\n}\r\ntail = strchr(ptr, ',');\r\nif (tail == NULL)\r\nlength = strlen(ptr);\r\nelse\r\nlength = tail - ptr;\r\nOBD_ALLOC(*handle, length + 1);\r\nif (*handle == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(*handle, ptr, length);\r\n(*handle)[length] = '\0';\r\nreturn 0;\r\n}\r\nstatic int lmd_parse_mgs(struct lustre_mount_data *lmd, char **ptr)\r\n{\r\nlnet_nid_t nid;\r\nchar *tail = *ptr;\r\nchar *mgsnid;\r\nint length;\r\nint oldlen = 0;\r\nwhile (class_parse_nid_quiet(tail, &nid, &tail) == 0) {}\r\nlength = tail - *ptr;\r\nif (length == 0) {\r\nLCONSOLE_ERROR_MSG(0x159, "Can't parse NID '%s'\n", *ptr);\r\nreturn -EINVAL;\r\n}\r\nif (lmd->lmd_mgs != NULL)\r\noldlen = strlen(lmd->lmd_mgs) + 1;\r\nOBD_ALLOC(mgsnid, oldlen + length + 1);\r\nif (mgsnid == NULL)\r\nreturn -ENOMEM;\r\nif (lmd->lmd_mgs != NULL) {\r\nmemcpy(mgsnid, lmd->lmd_mgs, oldlen);\r\nmgsnid[oldlen - 1] = ':';\r\nOBD_FREE(lmd->lmd_mgs, oldlen);\r\n}\r\nmemcpy(mgsnid + oldlen, *ptr, length);\r\nmgsnid[oldlen + length] = '\0';\r\nlmd->lmd_mgs = mgsnid;\r\n*ptr = tail;\r\nreturn 0;\r\n}\r\nstatic int lmd_parse(char *options, struct lustre_mount_data *lmd)\r\n{\r\nchar *s1, *s2, *devname = NULL;\r\nstruct lustre_mount_data *raw = (struct lustre_mount_data *)options;\r\nint rc = 0;\r\nLASSERT(lmd);\r\nif (!options) {\r\nLCONSOLE_ERROR_MSG(0x162, "Missing mount data: check that "\r\n"/sbin/mount.lustre is installed.\n");\r\nreturn -EINVAL;\r\n}\r\nif ((raw->lmd_magic & 0xffffff00) == (LMD_MAGIC & 0xffffff00)) {\r\nLCONSOLE_ERROR_MSG(0x163, "You're using an old version of "\r\n"/sbin/mount.lustre. Please install "\r\n"version %s\n", LUSTRE_VERSION_STRING);\r\nreturn -EINVAL;\r\n}\r\nlmd->lmd_magic = LMD_MAGIC;\r\nOBD_ALLOC(lmd->lmd_params, 4096);\r\nif (lmd->lmd_params == NULL)\r\nreturn -ENOMEM;\r\nlmd->lmd_params[0] = '\0';\r\ns1 = options;\r\nwhile (*s1) {\r\nint clear = 0;\r\nint time_min = OBD_RECOVERY_TIME_MIN;\r\nwhile (*s1 == ' ' || *s1 == ',')\r\ns1++;\r\nif (strncmp(s1, "abort_recov", 11) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_ABORT_RECOV;\r\nclear++;\r\n} else if (strncmp(s1, "recovery_time_soft=", 19) == 0) {\r\nlmd->lmd_recovery_time_soft = max_t(int,\r\nsimple_strtoul(s1 + 19, NULL, 10), time_min);\r\nclear++;\r\n} else if (strncmp(s1, "recovery_time_hard=", 19) == 0) {\r\nlmd->lmd_recovery_time_hard = max_t(int,\r\nsimple_strtoul(s1 + 19, NULL, 10), time_min);\r\nclear++;\r\n} else if (strncmp(s1, "noir", 4) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOIR;\r\nclear++;\r\n} else if (strncmp(s1, "nosvc", 5) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOSVC;\r\nclear++;\r\n} else if (strncmp(s1, "nomgs", 5) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOMGS;\r\nclear++;\r\n} else if (strncmp(s1, "noscrub", 7) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NOSCRUB;\r\nclear++;\r\n} else if (strncmp(s1, PARAM_MGSNODE,\r\nsizeof(PARAM_MGSNODE) - 1) == 0) {\r\ns2 = s1 + sizeof(PARAM_MGSNODE) - 1;\r\nrc = lmd_parse_mgs(lmd, &s2);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "writeconf", 9) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_WRITECONF;\r\nclear++;\r\n} else if (strncmp(s1, "update", 6) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_UPDATE;\r\nclear++;\r\n} else if (strncmp(s1, "virgin", 6) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_VIRGIN;\r\nclear++;\r\n} else if (strncmp(s1, "noprimnode", 10) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_NO_PRIMNODE;\r\nclear++;\r\n} else if (strncmp(s1, "mgssec=", 7) == 0) {\r\nrc = lmd_parse_mgssec(lmd, s1 + 7);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "exclude=", 8) == 0) {\r\nrc = lmd_make_exclusion(lmd, s1 + 7);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "mgs", 3) == 0) {\r\nlmd->lmd_flags |= LMD_FLG_MGS;\r\nclear++;\r\n} else if (strncmp(s1, "svname=", 7) == 0) {\r\nrc = lmd_parse_string(&lmd->lmd_profile, s1 + 7);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n} else if (strncmp(s1, "param=", 6) == 0) {\r\nint length;\r\nchar *tail = strchr(s1 + 6, ',');\r\nif (tail == NULL)\r\nlength = strlen(s1);\r\nelse\r\nlength = tail - s1;\r\nlength -= 6;\r\nstrncat(lmd->lmd_params, s1 + 6, length);\r\nstrcat(lmd->lmd_params, " ");\r\nclear++;\r\n} else if (strncmp(s1, "osd=", 4) == 0) {\r\nrc = lmd_parse_string(&lmd->lmd_osd_type, s1 + 4);\r\nif (rc)\r\ngoto invalid;\r\nclear++;\r\n}\r\nelse if (strncmp(s1, "device=", 7) == 0) {\r\ndevname = s1 + 7;\r\n*s1 = '\0';\r\nbreak;\r\n}\r\ns2 = strchr(s1, ',');\r\nif (s2 == NULL) {\r\nif (clear)\r\n*s1 = '\0';\r\nbreak;\r\n}\r\ns2++;\r\nif (clear)\r\nmemmove(s1, s2, strlen(s2) + 1);\r\nelse\r\ns1 = s2;\r\n}\r\nif (!devname) {\r\nLCONSOLE_ERROR_MSG(0x164, "Can't find the device name "\r\n"(need mount option 'device=...')\n");\r\ngoto invalid;\r\n}\r\ns1 = strstr(devname, ":/");\r\nif (s1) {\r\n++s1;\r\nlmd->lmd_flags |= LMD_FLG_CLIENT;\r\nwhile (*++s1 == '/') ;\r\nOBD_ALLOC(lmd->lmd_profile, strlen(s1) + 8);\r\nif (!lmd->lmd_profile)\r\nreturn -ENOMEM;\r\nsprintf(lmd->lmd_profile, "%s-client", s1);\r\n}\r\nOBD_ALLOC(lmd->lmd_dev, strlen(devname) + 1);\r\nif (!lmd->lmd_dev)\r\nreturn -ENOMEM;\r\nstrcpy(lmd->lmd_dev, devname);\r\ns1 = options + strlen(options) - 1;\r\nwhile (s1 >= options && (*s1 == ',' || *s1 == ' '))\r\n*s1-- = 0;\r\nif (*options != 0) {\r\nOBD_ALLOC(lmd->lmd_opts, strlen(options) + 1);\r\nif (!lmd->lmd_opts)\r\nreturn -ENOMEM;\r\nstrcpy(lmd->lmd_opts, options);\r\n}\r\nlmd_print(lmd);\r\nlmd->lmd_magic = LMD_MAGIC;\r\nreturn rc;\r\ninvalid:\r\nCERROR("Bad mount options %s\n", options);\r\nreturn -EINVAL;\r\n}\r\nint lustre_fill_super(struct super_block *sb, void *data, int silent)\r\n{\r\nstruct lustre_mount_data *lmd;\r\nstruct lustre_mount_data2 *lmd2 = data;\r\nstruct lustre_sb_info *lsi;\r\nint rc;\r\nCDEBUG(D_MOUNT|D_VFSTRACE, "VFS Op: sb %p\n", sb);\r\nlsi = lustre_init_lsi(sb);\r\nif (!lsi)\r\nreturn -ENOMEM;\r\nlmd = lsi->lsi_lmd;\r\nlockdep_off();\r\nobd_zombie_barrier();\r\nif (lmd_parse((char *)(lmd2->lmd2_data), lmd)) {\r\nlustre_put_lsi(sb);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nif (lmd_is_client(lmd)) {\r\nCDEBUG(D_MOUNT, "Mounting client %s\n", lmd->lmd_profile);\r\nif (!client_fill_super) {\r\nLCONSOLE_ERROR_MSG(0x165, "Nothing registered for "\r\n"client mount! Is the 'lustre' "\r\n"module loaded?\n");\r\nlustre_put_lsi(sb);\r\nrc = -ENODEV;\r\n} else {\r\nrc = lustre_start_mgc(sb);\r\nif (rc) {\r\nlustre_put_lsi(sb);\r\nGOTO(out, rc);\r\n}\r\nrc = (*client_fill_super)(sb, lmd2->lmd2_mnt);\r\n}\r\n} else {\r\nCERROR("This is client-side-only module, "\r\n"cannot handle server mount.\n");\r\nrc = -EINVAL;\r\n}\r\nGOTO(out, rc);\r\nout:\r\nif (rc) {\r\nCERROR("Unable to mount %s (%d)\n",\r\ns2lsi(sb) ? lmd->lmd_dev : "", rc);\r\n} else {\r\nCDEBUG(D_SUPER, "Mount %s complete\n",\r\nlmd->lmd_dev);\r\n}\r\nlockdep_on();\r\nreturn rc;\r\n}\r\nvoid lustre_register_client_fill_super(int (*cfs)(struct super_block *sb,\r\nstruct vfsmount *mnt))\r\n{\r\nclient_fill_super = cfs;\r\n}\r\nvoid lustre_register_kill_super_cb(void (*cfs)(struct super_block *sb))\r\n{\r\nkill_super_cb = cfs;\r\n}\r\nstruct dentry *lustre_mount(struct file_system_type *fs_type, int flags,\r\nconst char *devname, void *data)\r\n{\r\nstruct lustre_mount_data2 lmd2 = { data, NULL };\r\nreturn mount_nodev(fs_type, flags, &lmd2, lustre_fill_super);\r\n}\r\nvoid lustre_kill_super(struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nif (kill_super_cb && lsi && !IS_SERVER(lsi))\r\n(*kill_super_cb)(sb);\r\nkill_anon_super(sb);\r\n}\r\nint lustre_register_fs(void)\r\n{\r\nreturn register_filesystem(&lustre_fs_type);\r\n}\r\nint lustre_unregister_fs(void)\r\n{\r\nreturn unregister_filesystem(&lustre_fs_type);\r\n}
