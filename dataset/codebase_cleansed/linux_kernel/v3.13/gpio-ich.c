static int ichx_write_bit(int reg, unsigned nr, int val, int verify)\r\n{\r\nunsigned long flags;\r\nu32 data, tmp;\r\nint reg_nr = nr / 32;\r\nint bit = nr & 0x1f;\r\nint ret = 0;\r\nspin_lock_irqsave(&ichx_priv.lock, flags);\r\ndata = ICHX_READ(ichx_regs[reg][reg_nr], ichx_priv.gpio_base);\r\nif (val)\r\ndata |= 1 << bit;\r\nelse\r\ndata &= ~(1 << bit);\r\nICHX_WRITE(data, ichx_regs[reg][reg_nr], ichx_priv.gpio_base);\r\ntmp = ICHX_READ(ichx_regs[reg][reg_nr], ichx_priv.gpio_base);\r\nif (verify && data != tmp)\r\nret = -EPERM;\r\nspin_unlock_irqrestore(&ichx_priv.lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ichx_read_bit(int reg, unsigned nr)\r\n{\r\nunsigned long flags;\r\nu32 data;\r\nint reg_nr = nr / 32;\r\nint bit = nr & 0x1f;\r\nspin_lock_irqsave(&ichx_priv.lock, flags);\r\ndata = ICHX_READ(ichx_regs[reg][reg_nr], ichx_priv.gpio_base);\r\nspin_unlock_irqrestore(&ichx_priv.lock, flags);\r\nreturn data & (1 << bit) ? 1 : 0;\r\n}\r\nstatic bool ichx_gpio_check_available(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nreturn !!(ichx_priv.use_gpio & (1 << (nr / 32)));\r\n}\r\nstatic int ichx_gpio_direction_input(struct gpio_chip *gpio, unsigned nr)\r\n{\r\nif (ichx_write_bit(GPIO_IO_SEL, nr, 1, 1))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ichx_gpio_direction_output(struct gpio_chip *gpio, unsigned nr,\r\nint val)\r\n{\r\nif (nr < 32)\r\nichx_write_bit(GPO_BLINK, nr, 0, 0);\r\nichx_write_bit(GPIO_LVL, nr, val, 0);\r\nif (ichx_write_bit(GPIO_IO_SEL, nr, 0, 1))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ichx_gpio_get(struct gpio_chip *chip, unsigned nr)\r\n{\r\nreturn ichx_read_bit(GPIO_LVL, nr);\r\n}\r\nstatic int ich6_gpio_get(struct gpio_chip *chip, unsigned nr)\r\n{\r\nunsigned long flags;\r\nu32 data;\r\nif (nr < 16) {\r\nif (!ichx_priv.pm_base)\r\nreturn -ENXIO;\r\nspin_lock_irqsave(&ichx_priv.lock, flags);\r\nICHX_WRITE(1 << (16 + nr), 0, ichx_priv.pm_base);\r\ndata = ICHX_READ(0, ichx_priv.pm_base);\r\nspin_unlock_irqrestore(&ichx_priv.lock, flags);\r\nreturn (data >> 16) & (1 << nr) ? 1 : 0;\r\n} else {\r\nreturn ichx_gpio_get(chip, nr);\r\n}\r\n}\r\nstatic int ichx_gpio_request(struct gpio_chip *chip, unsigned nr)\r\n{\r\nif (!ichx_gpio_check_available(chip, nr))\r\nreturn -ENXIO;\r\nif (ichx_priv.desc->use_sel_ignore[nr / 32] & (1 << (nr & 0x1f)))\r\nreturn 0;\r\nreturn ichx_read_bit(GPIO_USE_SEL, nr) ? 0 : -ENODEV;\r\n}\r\nstatic int ich6_gpio_request(struct gpio_chip *chip, unsigned nr)\r\n{\r\nif (nr == 16 || nr == 17)\r\nnr -= 16;\r\nreturn ichx_gpio_request(chip, nr);\r\n}\r\nstatic void ichx_gpio_set(struct gpio_chip *chip, unsigned nr, int val)\r\n{\r\nichx_write_bit(GPIO_LVL, nr, val, 0);\r\n}\r\nstatic void ichx_gpiolib_setup(struct gpio_chip *chip)\r\n{\r\nchip->owner = THIS_MODULE;\r\nchip->label = DRV_NAME;\r\nchip->dev = &ichx_priv.dev->dev;\r\nchip->request = ichx_priv.desc->request ?\r\nichx_priv.desc->request : ichx_gpio_request;\r\nchip->get = ichx_priv.desc->get ?\r\nichx_priv.desc->get : ichx_gpio_get;\r\nchip->set = ichx_gpio_set;\r\nchip->direction_input = ichx_gpio_direction_input;\r\nchip->direction_output = ichx_gpio_direction_output;\r\nchip->base = modparam_gpiobase;\r\nchip->ngpio = ichx_priv.desc->ngpio;\r\nchip->can_sleep = 0;\r\nchip->dbg_show = NULL;\r\n}\r\nstatic int ichx_gpio_request_regions(struct resource *res_base,\r\nconst char *name, u8 use_gpio)\r\n{\r\nint i;\r\nif (!res_base || !res_base->start || !res_base->end)\r\nreturn -ENODEV;\r\nfor (i = 0; i < ARRAY_SIZE(ichx_regs[0]); i++) {\r\nif (!(use_gpio & (1 << i)))\r\ncontinue;\r\nif (!request_region(res_base->start + ichx_regs[0][i],\r\nichx_reglen[i], name))\r\ngoto request_err;\r\n}\r\nreturn 0;\r\nrequest_err:\r\nfor (i--; i >= 0; i--) {\r\nif (!(use_gpio & (1 << i)))\r\ncontinue;\r\nrelease_region(res_base->start + ichx_regs[0][i],\r\nichx_reglen[i]);\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic void ichx_gpio_release_regions(struct resource *res_base, u8 use_gpio)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ichx_regs[0]); i++) {\r\nif (!(use_gpio & (1 << i)))\r\ncontinue;\r\nrelease_region(res_base->start + ichx_regs[0][i],\r\nichx_reglen[i]);\r\n}\r\n}\r\nstatic int ichx_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res_base, *res_pm;\r\nint err;\r\nstruct lpc_ich_info *ich_info = dev_get_platdata(&pdev->dev);\r\nif (!ich_info)\r\nreturn -ENODEV;\r\nichx_priv.dev = pdev;\r\nswitch (ich_info->gpio_version) {\r\ncase ICH_I3100_GPIO:\r\nichx_priv.desc = &i3100_desc;\r\nbreak;\r\ncase ICH_V5_GPIO:\r\nichx_priv.desc = &intel5_desc;\r\nbreak;\r\ncase ICH_V6_GPIO:\r\nichx_priv.desc = &ich6_desc;\r\nbreak;\r\ncase ICH_V7_GPIO:\r\nichx_priv.desc = &ich7_desc;\r\nbreak;\r\ncase ICH_V9_GPIO:\r\nichx_priv.desc = &ich9_desc;\r\nbreak;\r\ncase ICH_V10CORP_GPIO:\r\nichx_priv.desc = &ich10_corp_desc;\r\nbreak;\r\ncase ICH_V10CONS_GPIO:\r\nichx_priv.desc = &ich10_cons_desc;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nspin_lock_init(&ichx_priv.lock);\r\nres_base = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_GPIO);\r\nichx_priv.use_gpio = ich_info->use_gpio;\r\nerr = ichx_gpio_request_regions(res_base, pdev->name,\r\nichx_priv.use_gpio);\r\nif (err)\r\nreturn err;\r\nichx_priv.gpio_base = res_base;\r\nif (!ichx_priv.desc->uses_gpe0)\r\ngoto init;\r\nres_pm = platform_get_resource(pdev, IORESOURCE_IO, ICH_RES_GPE0);\r\nif (!res_pm) {\r\npr_warn("ACPI BAR is unavailable, GPI 0 - 15 unavailable\n");\r\ngoto init;\r\n}\r\nif (!request_region(res_pm->start, resource_size(res_pm),\r\npdev->name)) {\r\npr_warn("ACPI BAR is busy, GPI 0 - 15 unavailable\n");\r\ngoto init;\r\n}\r\nichx_priv.pm_base = res_pm;\r\ninit:\r\nichx_gpiolib_setup(&ichx_priv.chip);\r\nerr = gpiochip_add(&ichx_priv.chip);\r\nif (err) {\r\npr_err("Failed to register GPIOs\n");\r\ngoto add_err;\r\n}\r\npr_info("GPIO from %d to %d on %s\n", ichx_priv.chip.base,\r\nichx_priv.chip.base + ichx_priv.chip.ngpio - 1, DRV_NAME);\r\nreturn 0;\r\nadd_err:\r\nichx_gpio_release_regions(ichx_priv.gpio_base, ichx_priv.use_gpio);\r\nif (ichx_priv.pm_base)\r\nrelease_region(ichx_priv.pm_base->start,\r\nresource_size(ichx_priv.pm_base));\r\nreturn err;\r\n}\r\nstatic int ichx_gpio_remove(struct platform_device *pdev)\r\n{\r\nint err;\r\nerr = gpiochip_remove(&ichx_priv.chip);\r\nif (err) {\r\ndev_err(&pdev->dev, "%s failed, %d\n",\r\n"gpiochip_remove()", err);\r\nreturn err;\r\n}\r\nichx_gpio_release_regions(ichx_priv.gpio_base, ichx_priv.use_gpio);\r\nif (ichx_priv.pm_base)\r\nrelease_region(ichx_priv.pm_base->start,\r\nresource_size(ichx_priv.pm_base));\r\nreturn 0;\r\n}
