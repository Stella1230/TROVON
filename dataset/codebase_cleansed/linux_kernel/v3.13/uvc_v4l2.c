static int uvc_ioctl_ctrl_map(struct uvc_video_chain *chain,\r\nstruct uvc_xu_control_mapping *xmap)\r\n{\r\nstruct uvc_control_mapping *map;\r\nunsigned int size;\r\nint ret;\r\nmap = kzalloc(sizeof *map, GFP_KERNEL);\r\nif (map == NULL)\r\nreturn -ENOMEM;\r\nmap->id = xmap->id;\r\nmemcpy(map->name, xmap->name, sizeof map->name);\r\nmemcpy(map->entity, xmap->entity, sizeof map->entity);\r\nmap->selector = xmap->selector;\r\nmap->size = xmap->size;\r\nmap->offset = xmap->offset;\r\nmap->v4l2_type = xmap->v4l2_type;\r\nmap->data_type = xmap->data_type;\r\nswitch (xmap->v4l2_type) {\r\ncase V4L2_CTRL_TYPE_INTEGER:\r\ncase V4L2_CTRL_TYPE_BOOLEAN:\r\ncase V4L2_CTRL_TYPE_BUTTON:\r\nbreak;\r\ncase V4L2_CTRL_TYPE_MENU:\r\nif (xmap->menu_count == 0 ||\r\nxmap->menu_count > UVC_MAX_CONTROL_MENU_ENTRIES) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nsize = xmap->menu_count * sizeof(*map->menu_info);\r\nmap->menu_info = kmalloc(size, GFP_KERNEL);\r\nif (map->menu_info == NULL) {\r\nret = -ENOMEM;\r\ngoto done;\r\n}\r\nif (copy_from_user(map->menu_info, xmap->menu_info, size)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nmap->menu_count = xmap->menu_count;\r\nbreak;\r\ndefault:\r\nuvc_trace(UVC_TRACE_CONTROL, "Unsupported V4L2 control type "\r\n"%u.\n", xmap->v4l2_type);\r\nret = -ENOTTY;\r\ngoto done;\r\n}\r\nret = uvc_ctrl_add_mapping(chain, map);\r\ndone:\r\nkfree(map->menu_info);\r\nkfree(map);\r\nreturn ret;\r\n}\r\nstatic __u32 uvc_try_frame_interval(struct uvc_frame *frame, __u32 interval)\r\n{\r\nunsigned int i;\r\nif (frame->bFrameIntervalType) {\r\n__u32 best = -1, dist;\r\nfor (i = 0; i < frame->bFrameIntervalType; ++i) {\r\ndist = interval > frame->dwFrameInterval[i]\r\n? interval - frame->dwFrameInterval[i]\r\n: frame->dwFrameInterval[i] - interval;\r\nif (dist > best)\r\nbreak;\r\nbest = dist;\r\n}\r\ninterval = frame->dwFrameInterval[i-1];\r\n} else {\r\nconst __u32 min = frame->dwFrameInterval[0];\r\nconst __u32 max = frame->dwFrameInterval[1];\r\nconst __u32 step = frame->dwFrameInterval[2];\r\ninterval = min + (interval - min + step/2) / step * step;\r\nif (interval > max)\r\ninterval = max;\r\n}\r\nreturn interval;\r\n}\r\nstatic int uvc_v4l2_try_format(struct uvc_streaming *stream,\r\nstruct v4l2_format *fmt, struct uvc_streaming_control *probe,\r\nstruct uvc_format **uvc_format, struct uvc_frame **uvc_frame)\r\n{\r\nstruct uvc_format *format = NULL;\r\nstruct uvc_frame *frame = NULL;\r\n__u16 rw, rh;\r\nunsigned int d, maxd;\r\nunsigned int i;\r\n__u32 interval;\r\nint ret = 0;\r\n__u8 *fcc;\r\nif (fmt->type != stream->type)\r\nreturn -EINVAL;\r\nfcc = (__u8 *)&fmt->fmt.pix.pixelformat;\r\nuvc_trace(UVC_TRACE_FORMAT, "Trying format 0x%08x (%c%c%c%c): %ux%u.\n",\r\nfmt->fmt.pix.pixelformat,\r\nfcc[0], fcc[1], fcc[2], fcc[3],\r\nfmt->fmt.pix.width, fmt->fmt.pix.height);\r\nfor (i = 0; i < stream->nformats; ++i) {\r\nformat = &stream->format[i];\r\nif (format->fcc == fmt->fmt.pix.pixelformat)\r\nbreak;\r\n}\r\nif (i == stream->nformats) {\r\nformat = stream->def_format;\r\nfmt->fmt.pix.pixelformat = format->fcc;\r\n}\r\nrw = fmt->fmt.pix.width;\r\nrh = fmt->fmt.pix.height;\r\nmaxd = (unsigned int)-1;\r\nfor (i = 0; i < format->nframes; ++i) {\r\n__u16 w = format->frame[i].wWidth;\r\n__u16 h = format->frame[i].wHeight;\r\nd = min(w, rw) * min(h, rh);\r\nd = w*h + rw*rh - 2*d;\r\nif (d < maxd) {\r\nmaxd = d;\r\nframe = &format->frame[i];\r\n}\r\nif (maxd == 0)\r\nbreak;\r\n}\r\nif (frame == NULL) {\r\nuvc_trace(UVC_TRACE_FORMAT, "Unsupported size %ux%u.\n",\r\nfmt->fmt.pix.width, fmt->fmt.pix.height);\r\nreturn -EINVAL;\r\n}\r\ninterval = frame->dwDefaultFrameInterval;\r\nuvc_trace(UVC_TRACE_FORMAT, "Using default frame interval %u.%u us "\r\n"(%u.%u fps).\n", interval/10, interval%10, 10000000/interval,\r\n(100000000/interval)%10);\r\nmemset(probe, 0, sizeof *probe);\r\nprobe->bmHint = 1;\r\nprobe->bFormatIndex = format->index;\r\nprobe->bFrameIndex = frame->bFrameIndex;\r\nprobe->dwFrameInterval = uvc_try_frame_interval(frame, interval);\r\nmutex_lock(&stream->mutex);\r\nif (stream->dev->quirks & UVC_QUIRK_PROBE_EXTRAFIELDS)\r\nprobe->dwMaxVideoFrameSize =\r\nstream->ctrl.dwMaxVideoFrameSize;\r\nret = uvc_probe_video(stream, probe);\r\nmutex_unlock(&stream->mutex);\r\nif (ret < 0)\r\ngoto done;\r\nfmt->fmt.pix.width = frame->wWidth;\r\nfmt->fmt.pix.height = frame->wHeight;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;\r\nfmt->fmt.pix.sizeimage = probe->dwMaxVideoFrameSize;\r\nfmt->fmt.pix.colorspace = format->colorspace;\r\nfmt->fmt.pix.priv = 0;\r\nif (uvc_format != NULL)\r\n*uvc_format = format;\r\nif (uvc_frame != NULL)\r\n*uvc_frame = frame;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int uvc_v4l2_get_format(struct uvc_streaming *stream,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_format *format;\r\nstruct uvc_frame *frame;\r\nint ret = 0;\r\nif (fmt->type != stream->type)\r\nreturn -EINVAL;\r\nmutex_lock(&stream->mutex);\r\nformat = stream->cur_format;\r\nframe = stream->cur_frame;\r\nif (format == NULL || frame == NULL) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nfmt->fmt.pix.pixelformat = format->fcc;\r\nfmt->fmt.pix.width = frame->wWidth;\r\nfmt->fmt.pix.height = frame->wHeight;\r\nfmt->fmt.pix.field = V4L2_FIELD_NONE;\r\nfmt->fmt.pix.bytesperline = format->bpp * frame->wWidth / 8;\r\nfmt->fmt.pix.sizeimage = stream->ctrl.dwMaxVideoFrameSize;\r\nfmt->fmt.pix.colorspace = format->colorspace;\r\nfmt->fmt.pix.priv = 0;\r\ndone:\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstatic int uvc_v4l2_set_format(struct uvc_streaming *stream,\r\nstruct v4l2_format *fmt)\r\n{\r\nstruct uvc_streaming_control probe;\r\nstruct uvc_format *format;\r\nstruct uvc_frame *frame;\r\nint ret;\r\nif (fmt->type != stream->type)\r\nreturn -EINVAL;\r\nret = uvc_v4l2_try_format(stream, fmt, &probe, &format, &frame);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_lock(&stream->mutex);\r\nif (uvc_queue_allocated(&stream->queue)) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nstream->ctrl = probe;\r\nstream->cur_format = format;\r\nstream->cur_frame = frame;\r\ndone:\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstatic int uvc_v4l2_get_streamparm(struct uvc_streaming *stream,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nuint32_t numerator, denominator;\r\nif (parm->type != stream->type)\r\nreturn -EINVAL;\r\nmutex_lock(&stream->mutex);\r\nnumerator = stream->ctrl.dwFrameInterval;\r\nmutex_unlock(&stream->mutex);\r\ndenominator = 10000000;\r\nuvc_simplify_fraction(&numerator, &denominator, 8, 333);\r\nmemset(parm, 0, sizeof *parm);\r\nparm->type = stream->type;\r\nif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nparm->parm.capture.capability = V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.capture.capturemode = 0;\r\nparm->parm.capture.timeperframe.numerator = numerator;\r\nparm->parm.capture.timeperframe.denominator = denominator;\r\nparm->parm.capture.extendedmode = 0;\r\nparm->parm.capture.readbuffers = 0;\r\n} else {\r\nparm->parm.output.capability = V4L2_CAP_TIMEPERFRAME;\r\nparm->parm.output.outputmode = 0;\r\nparm->parm.output.timeperframe.numerator = numerator;\r\nparm->parm.output.timeperframe.denominator = denominator;\r\n}\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_set_streamparm(struct uvc_streaming *stream,\r\nstruct v4l2_streamparm *parm)\r\n{\r\nstruct uvc_streaming_control probe;\r\nstruct v4l2_fract timeperframe;\r\nuint32_t interval;\r\nint ret;\r\nif (parm->type != stream->type)\r\nreturn -EINVAL;\r\nif (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ntimeperframe = parm->parm.capture.timeperframe;\r\nelse\r\ntimeperframe = parm->parm.output.timeperframe;\r\ninterval = uvc_fraction_to_interval(timeperframe.numerator,\r\ntimeperframe.denominator);\r\nuvc_trace(UVC_TRACE_FORMAT, "Setting frame interval to %u/%u (%u).\n",\r\ntimeperframe.numerator, timeperframe.denominator, interval);\r\nmutex_lock(&stream->mutex);\r\nif (uvc_queue_streaming(&stream->queue)) {\r\nmutex_unlock(&stream->mutex);\r\nreturn -EBUSY;\r\n}\r\nprobe = stream->ctrl;\r\nprobe.dwFrameInterval =\r\nuvc_try_frame_interval(stream->cur_frame, interval);\r\nret = uvc_probe_video(stream, &probe);\r\nif (ret < 0) {\r\nmutex_unlock(&stream->mutex);\r\nreturn ret;\r\n}\r\nstream->ctrl = probe;\r\nmutex_unlock(&stream->mutex);\r\ntimeperframe.numerator = probe.dwFrameInterval;\r\ntimeperframe.denominator = 10000000;\r\nuvc_simplify_fraction(&timeperframe.numerator,\r\n&timeperframe.denominator, 8, 333);\r\nif (parm->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nparm->parm.capture.timeperframe = timeperframe;\r\nelse\r\nparm->parm.output.timeperframe = timeperframe;\r\nreturn 0;\r\n}\r\nstatic int uvc_acquire_privileges(struct uvc_fh *handle)\r\n{\r\nif (handle->state == UVC_HANDLE_ACTIVE)\r\nreturn 0;\r\nif (atomic_inc_return(&handle->stream->active) != 1) {\r\natomic_dec(&handle->stream->active);\r\nreturn -EBUSY;\r\n}\r\nhandle->state = UVC_HANDLE_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic void uvc_dismiss_privileges(struct uvc_fh *handle)\r\n{\r\nif (handle->state == UVC_HANDLE_ACTIVE)\r\natomic_dec(&handle->stream->active);\r\nhandle->state = UVC_HANDLE_PASSIVE;\r\n}\r\nstatic int uvc_has_privileges(struct uvc_fh *handle)\r\n{\r\nreturn handle->state == UVC_HANDLE_ACTIVE;\r\n}\r\nstatic int uvc_v4l2_open(struct file *file)\r\n{\r\nstruct uvc_streaming *stream;\r\nstruct uvc_fh *handle;\r\nint ret = 0;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_open\n");\r\nstream = video_drvdata(file);\r\nif (stream->dev->state & UVC_DEV_DISCONNECTED)\r\nreturn -ENODEV;\r\nret = usb_autopm_get_interface(stream->dev->intf);\r\nif (ret < 0)\r\nreturn ret;\r\nhandle = kzalloc(sizeof *handle, GFP_KERNEL);\r\nif (handle == NULL) {\r\nusb_autopm_put_interface(stream->dev->intf);\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&stream->dev->lock);\r\nif (stream->dev->users == 0) {\r\nret = uvc_status_start(stream->dev, GFP_KERNEL);\r\nif (ret < 0) {\r\nmutex_unlock(&stream->dev->lock);\r\nusb_autopm_put_interface(stream->dev->intf);\r\nkfree(handle);\r\nreturn ret;\r\n}\r\n}\r\nstream->dev->users++;\r\nmutex_unlock(&stream->dev->lock);\r\nv4l2_fh_init(&handle->vfh, stream->vdev);\r\nv4l2_fh_add(&handle->vfh);\r\nhandle->chain = stream->chain;\r\nhandle->stream = stream;\r\nhandle->state = UVC_HANDLE_PASSIVE;\r\nfile->private_data = handle;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_release(struct file *file)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_release\n");\r\nif (uvc_has_privileges(handle)) {\r\nuvc_video_enable(stream, 0);\r\nuvc_free_buffers(&stream->queue);\r\n}\r\nuvc_dismiss_privileges(handle);\r\nv4l2_fh_del(&handle->vfh);\r\nv4l2_fh_exit(&handle->vfh);\r\nkfree(handle);\r\nfile->private_data = NULL;\r\nmutex_lock(&stream->dev->lock);\r\nif (--stream->dev->users == 0)\r\nuvc_status_stop(stream->dev);\r\nmutex_unlock(&stream->dev->lock);\r\nusb_autopm_put_interface(stream->dev->intf);\r\nreturn 0;\r\n}\r\nstatic long uvc_v4l2_do_ioctl(struct file *file, unsigned int cmd, void *arg)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_video_chain *chain = handle->chain;\r\nstruct uvc_streaming *stream = handle->stream;\r\nlong ret = 0;\r\nswitch (cmd) {\r\ncase VIDIOC_QUERYCAP:\r\n{\r\nstruct v4l2_capability *cap = arg;\r\nmemset(cap, 0, sizeof *cap);\r\nstrlcpy(cap->driver, "uvcvideo", sizeof cap->driver);\r\nstrlcpy(cap->card, vdev->name, sizeof cap->card);\r\nusb_make_path(stream->dev->udev,\r\ncap->bus_info, sizeof(cap->bus_info));\r\ncap->version = LINUX_VERSION_CODE;\r\ncap->capabilities = V4L2_CAP_DEVICE_CAPS | V4L2_CAP_STREAMING\r\n| chain->caps;\r\nif (stream->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE\r\n| V4L2_CAP_STREAMING;\r\nelse\r\ncap->device_caps = V4L2_CAP_VIDEO_OUTPUT\r\n| V4L2_CAP_STREAMING;\r\nbreak;\r\n}\r\ncase VIDIOC_G_PRIORITY:\r\n*(u32 *)arg = v4l2_prio_max(vdev->prio);\r\nbreak;\r\ncase VIDIOC_S_PRIORITY:\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn v4l2_prio_change(vdev->prio, &handle->vfh.prio,\r\n*(u32 *)arg);\r\ncase VIDIOC_QUERYCTRL:\r\nreturn uvc_query_v4l2_ctrl(chain, arg);\r\ncase VIDIOC_G_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nstruct v4l2_ext_control xctrl;\r\nmemset(&xctrl, 0, sizeof xctrl);\r\nxctrl.id = ctrl->id;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uvc_ctrl_get(chain, &xctrl);\r\nuvc_ctrl_rollback(handle);\r\nif (ret >= 0)\r\nctrl->value = xctrl.value;\r\nbreak;\r\n}\r\ncase VIDIOC_S_CTRL:\r\n{\r\nstruct v4l2_control *ctrl = arg;\r\nstruct v4l2_ext_control xctrl;\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nmemset(&xctrl, 0, sizeof xctrl);\r\nxctrl.id = ctrl->id;\r\nxctrl.value = ctrl->value;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nret = uvc_ctrl_set(chain, &xctrl);\r\nif (ret < 0) {\r\nuvc_ctrl_rollback(handle);\r\nreturn ret;\r\n}\r\nret = uvc_ctrl_commit(handle, &xctrl, 1);\r\nif (ret == 0)\r\nctrl->value = xctrl.value;\r\nbreak;\r\n}\r\ncase VIDIOC_QUERYMENU:\r\nreturn uvc_query_v4l2_menu(chain, arg);\r\ncase VIDIOC_G_EXT_CTRLS:\r\n{\r\nstruct v4l2_ext_controls *ctrls = arg;\r\nstruct v4l2_ext_control *ctrl = ctrls->controls;\r\nunsigned int i;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\r\nret = uvc_ctrl_get(chain, ctrl);\r\nif (ret < 0) {\r\nuvc_ctrl_rollback(handle);\r\nctrls->error_idx = i;\r\nreturn ret;\r\n}\r\n}\r\nctrls->error_idx = 0;\r\nret = uvc_ctrl_rollback(handle);\r\nbreak;\r\n}\r\ncase VIDIOC_S_EXT_CTRLS:\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\ncase VIDIOC_TRY_EXT_CTRLS:\r\n{\r\nstruct v4l2_ext_controls *ctrls = arg;\r\nstruct v4l2_ext_control *ctrl = ctrls->controls;\r\nunsigned int i;\r\nret = uvc_ctrl_begin(chain);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (i = 0; i < ctrls->count; ++ctrl, ++i) {\r\nret = uvc_ctrl_set(chain, ctrl);\r\nif (ret < 0) {\r\nuvc_ctrl_rollback(handle);\r\nctrls->error_idx = cmd == VIDIOC_S_EXT_CTRLS\r\n? ctrls->count : i;\r\nreturn ret;\r\n}\r\n}\r\nctrls->error_idx = 0;\r\nif (cmd == VIDIOC_S_EXT_CTRLS)\r\nret = uvc_ctrl_commit(handle,\r\nctrls->controls, ctrls->count);\r\nelse\r\nret = uvc_ctrl_rollback(handle);\r\nbreak;\r\n}\r\ncase VIDIOC_ENUMINPUT:\r\n{\r\nconst struct uvc_entity *selector = chain->selector;\r\nstruct v4l2_input *input = arg;\r\nstruct uvc_entity *iterm = NULL;\r\nu32 index = input->index;\r\nint pin = 0;\r\nif (selector == NULL ||\r\n(chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\r\nif (index != 0)\r\nreturn -EINVAL;\r\nlist_for_each_entry(iterm, &chain->entities, chain) {\r\nif (UVC_ENTITY_IS_ITERM(iterm))\r\nbreak;\r\n}\r\npin = iterm->id;\r\n} else if (index < selector->bNrInPins) {\r\npin = selector->baSourceID[index];\r\nlist_for_each_entry(iterm, &chain->entities, chain) {\r\nif (!UVC_ENTITY_IS_ITERM(iterm))\r\ncontinue;\r\nif (iterm->id == pin)\r\nbreak;\r\n}\r\n}\r\nif (iterm == NULL || iterm->id != pin)\r\nreturn -EINVAL;\r\nmemset(input, 0, sizeof *input);\r\ninput->index = index;\r\nstrlcpy(input->name, iterm->name, sizeof input->name);\r\nif (UVC_ENTITY_TYPE(iterm) == UVC_ITT_CAMERA)\r\ninput->type = V4L2_INPUT_TYPE_CAMERA;\r\nbreak;\r\n}\r\ncase VIDIOC_G_INPUT:\r\n{\r\nu8 input;\r\nif (chain->selector == NULL ||\r\n(chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\r\n*(int *)arg = 0;\r\nbreak;\r\n}\r\nret = uvc_query_ctrl(chain->dev, UVC_GET_CUR,\r\nchain->selector->id, chain->dev->intfnum,\r\nUVC_SU_INPUT_SELECT_CONTROL, &input, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n*(int *)arg = input - 1;\r\nbreak;\r\n}\r\ncase VIDIOC_S_INPUT:\r\n{\r\nu32 input = *(u32 *)arg + 1;\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret = uvc_acquire_privileges(handle)) < 0)\r\nreturn ret;\r\nif (chain->selector == NULL ||\r\n(chain->dev->quirks & UVC_QUIRK_IGNORE_SELECTOR_UNIT)) {\r\nif (input != 1)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nif (input == 0 || input > chain->selector->bNrInPins)\r\nreturn -EINVAL;\r\nreturn uvc_query_ctrl(chain->dev, UVC_SET_CUR,\r\nchain->selector->id, chain->dev->intfnum,\r\nUVC_SU_INPUT_SELECT_CONTROL, &input, 1);\r\n}\r\ncase VIDIOC_ENUM_FMT:\r\n{\r\nstruct v4l2_fmtdesc *fmt = arg;\r\nstruct uvc_format *format;\r\nenum v4l2_buf_type type = fmt->type;\r\n__u32 index = fmt->index;\r\nif (fmt->type != stream->type ||\r\nfmt->index >= stream->nformats)\r\nreturn -EINVAL;\r\nmemset(fmt, 0, sizeof(*fmt));\r\nfmt->index = index;\r\nfmt->type = type;\r\nformat = &stream->format[fmt->index];\r\nfmt->flags = 0;\r\nif (format->flags & UVC_FMT_FLAG_COMPRESSED)\r\nfmt->flags |= V4L2_FMT_FLAG_COMPRESSED;\r\nstrlcpy(fmt->description, format->name,\r\nsizeof fmt->description);\r\nfmt->description[sizeof fmt->description - 1] = 0;\r\nfmt->pixelformat = format->fcc;\r\nbreak;\r\n}\r\ncase VIDIOC_TRY_FMT:\r\n{\r\nstruct uvc_streaming_control probe;\r\nreturn uvc_v4l2_try_format(stream, arg, &probe, NULL, NULL);\r\n}\r\ncase VIDIOC_S_FMT:\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret = uvc_acquire_privileges(handle)) < 0)\r\nreturn ret;\r\nreturn uvc_v4l2_set_format(stream, arg);\r\ncase VIDIOC_G_FMT:\r\nreturn uvc_v4l2_get_format(stream, arg);\r\ncase VIDIOC_ENUM_FRAMESIZES:\r\n{\r\nstruct v4l2_frmsizeenum *fsize = arg;\r\nstruct uvc_format *format = NULL;\r\nstruct uvc_frame *frame;\r\nint i;\r\nfor (i = 0; i < stream->nformats; i++) {\r\nif (stream->format[i].fcc ==\r\nfsize->pixel_format) {\r\nformat = &stream->format[i];\r\nbreak;\r\n}\r\n}\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nif (fsize->index >= format->nframes)\r\nreturn -EINVAL;\r\nframe = &format->frame[fsize->index];\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = frame->wWidth;\r\nfsize->discrete.height = frame->wHeight;\r\nbreak;\r\n}\r\ncase VIDIOC_ENUM_FRAMEINTERVALS:\r\n{\r\nstruct v4l2_frmivalenum *fival = arg;\r\nstruct uvc_format *format = NULL;\r\nstruct uvc_frame *frame = NULL;\r\nint i;\r\nfor (i = 0; i < stream->nformats; i++) {\r\nif (stream->format[i].fcc ==\r\nfival->pixel_format) {\r\nformat = &stream->format[i];\r\nbreak;\r\n}\r\n}\r\nif (format == NULL)\r\nreturn -EINVAL;\r\nfor (i = 0; i < format->nframes; i++) {\r\nif (format->frame[i].wWidth == fival->width &&\r\nformat->frame[i].wHeight == fival->height) {\r\nframe = &format->frame[i];\r\nbreak;\r\n}\r\n}\r\nif (frame == NULL)\r\nreturn -EINVAL;\r\nif (frame->bFrameIntervalType) {\r\nif (fival->index >= frame->bFrameIntervalType)\r\nreturn -EINVAL;\r\nfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfival->discrete.numerator =\r\nframe->dwFrameInterval[fival->index];\r\nfival->discrete.denominator = 10000000;\r\nuvc_simplify_fraction(&fival->discrete.numerator,\r\n&fival->discrete.denominator, 8, 333);\r\n} else {\r\nfival->type = V4L2_FRMIVAL_TYPE_STEPWISE;\r\nfival->stepwise.min.numerator =\r\nframe->dwFrameInterval[0];\r\nfival->stepwise.min.denominator = 10000000;\r\nfival->stepwise.max.numerator =\r\nframe->dwFrameInterval[1];\r\nfival->stepwise.max.denominator = 10000000;\r\nfival->stepwise.step.numerator =\r\nframe->dwFrameInterval[2];\r\nfival->stepwise.step.denominator = 10000000;\r\nuvc_simplify_fraction(&fival->stepwise.min.numerator,\r\n&fival->stepwise.min.denominator, 8, 333);\r\nuvc_simplify_fraction(&fival->stepwise.max.numerator,\r\n&fival->stepwise.max.denominator, 8, 333);\r\nuvc_simplify_fraction(&fival->stepwise.step.numerator,\r\n&fival->stepwise.step.denominator, 8, 333);\r\n}\r\nbreak;\r\n}\r\ncase VIDIOC_G_PARM:\r\nreturn uvc_v4l2_get_streamparm(stream, arg);\r\ncase VIDIOC_S_PARM:\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret = uvc_acquire_privileges(handle)) < 0)\r\nreturn ret;\r\nreturn uvc_v4l2_set_streamparm(stream, arg);\r\ncase VIDIOC_CROPCAP:\r\n{\r\nstruct v4l2_cropcap *ccap = arg;\r\nif (ccap->type != stream->type)\r\nreturn -EINVAL;\r\nccap->bounds.left = 0;\r\nccap->bounds.top = 0;\r\nmutex_lock(&stream->mutex);\r\nccap->bounds.width = stream->cur_frame->wWidth;\r\nccap->bounds.height = stream->cur_frame->wHeight;\r\nmutex_unlock(&stream->mutex);\r\nccap->defrect = ccap->bounds;\r\nccap->pixelaspect.numerator = 1;\r\nccap->pixelaspect.denominator = 1;\r\nbreak;\r\n}\r\ncase VIDIOC_G_CROP:\r\ncase VIDIOC_S_CROP:\r\nreturn -ENOTTY;\r\ncase VIDIOC_REQBUFS:\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nif ((ret = uvc_acquire_privileges(handle)) < 0)\r\nreturn ret;\r\nmutex_lock(&stream->mutex);\r\nret = uvc_alloc_buffers(&stream->queue, arg);\r\nmutex_unlock(&stream->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret == 0)\r\nuvc_dismiss_privileges(handle);\r\nret = 0;\r\nbreak;\r\ncase VIDIOC_QUERYBUF:\r\n{\r\nstruct v4l2_buffer *buf = arg;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_query_buffer(&stream->queue, buf);\r\n}\r\ncase VIDIOC_QBUF:\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_queue_buffer(&stream->queue, arg);\r\ncase VIDIOC_DQBUF:\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_dequeue_buffer(&stream->queue, arg,\r\nfile->f_flags & O_NONBLOCK);\r\ncase VIDIOC_STREAMON:\r\n{\r\nint *type = arg;\r\nif (*type != stream->type)\r\nreturn -EINVAL;\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nmutex_lock(&stream->mutex);\r\nret = uvc_video_enable(stream, 1);\r\nmutex_unlock(&stream->mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\ncase VIDIOC_STREAMOFF:\r\n{\r\nint *type = arg;\r\nif (*type != stream->type)\r\nreturn -EINVAL;\r\nret = v4l2_prio_check(vdev->prio, handle->vfh.prio);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!uvc_has_privileges(handle))\r\nreturn -EBUSY;\r\nreturn uvc_video_enable(stream, 0);\r\n}\r\ncase VIDIOC_SUBSCRIBE_EVENT:\r\n{\r\nstruct v4l2_event_subscription *sub = arg;\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_CTRL:\r\nreturn v4l2_event_subscribe(&handle->vfh, sub, 0,\r\n&uvc_ctrl_sub_ev_ops);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\ncase VIDIOC_UNSUBSCRIBE_EVENT:\r\nreturn v4l2_event_unsubscribe(&handle->vfh, arg);\r\ncase VIDIOC_DQEVENT:\r\nreturn v4l2_event_dequeue(&handle->vfh, arg,\r\nfile->f_flags & O_NONBLOCK);\r\ncase VIDIOC_ENUMSTD:\r\ncase VIDIOC_QUERYSTD:\r\ncase VIDIOC_G_STD:\r\ncase VIDIOC_S_STD:\r\ncase VIDIOC_OVERLAY:\r\ncase VIDIOC_ENUMAUDIO:\r\ncase VIDIOC_ENUMAUDOUT:\r\ncase VIDIOC_ENUMOUTPUT:\r\nuvc_trace(UVC_TRACE_IOCTL, "Unsupported ioctl 0x%08x\n", cmd);\r\nreturn -ENOTTY;\r\ncase UVCIOC_CTRL_MAP:\r\nreturn uvc_ioctl_ctrl_map(chain, arg);\r\ncase UVCIOC_CTRL_QUERY:\r\nreturn uvc_xu_ctrl_query(chain, arg);\r\ndefault:\r\nuvc_trace(UVC_TRACE_IOCTL, "Unknown ioctl 0x%08x\n", cmd);\r\nreturn -ENOTTY;\r\n}\r\nreturn ret;\r\n}\r\nstatic long uvc_v4l2_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nif (uvc_trace_param & UVC_TRACE_IOCTL) {\r\nuvc_printk(KERN_DEBUG, "uvc_v4l2_ioctl(");\r\nv4l_printk_ioctl(NULL, cmd);\r\nprintk(")\n");\r\n}\r\nreturn video_usercopy(file, cmd, arg, uvc_v4l2_do_ioctl);\r\n}\r\nstatic int uvc_v4l2_get_xu_mapping(struct uvc_xu_control_mapping *kp,\r\nconst struct uvc_xu_control_mapping32 __user *up)\r\n{\r\nstruct uvc_menu_info __user *umenus;\r\nstruct uvc_menu_info __user *kmenus;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_READ, up, sizeof(*up)) ||\r\n__copy_from_user(kp, up, offsetof(typeof(*up), menu_info)) ||\r\n__get_user(kp->menu_count, &up->menu_count))\r\nreturn -EFAULT;\r\nmemset(kp->reserved, 0, sizeof(kp->reserved));\r\nif (kp->menu_count == 0) {\r\nkp->menu_info = NULL;\r\nreturn 0;\r\n}\r\nif (__get_user(p, &up->menu_info))\r\nreturn -EFAULT;\r\numenus = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, umenus, kp->menu_count * sizeof(*umenus)))\r\nreturn -EFAULT;\r\nkmenus = compat_alloc_user_space(kp->menu_count * sizeof(*kmenus));\r\nif (kmenus == NULL)\r\nreturn -EFAULT;\r\nkp->menu_info = kmenus;\r\nif (copy_in_user(kmenus, umenus, kp->menu_count * sizeof(*umenus)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_put_xu_mapping(const struct uvc_xu_control_mapping *kp,\r\nstruct uvc_xu_control_mapping32 __user *up)\r\n{\r\nstruct uvc_menu_info __user *umenus;\r\nstruct uvc_menu_info __user *kmenus = kp->menu_info;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||\r\n__copy_to_user(up, kp, offsetof(typeof(*up), menu_info)) ||\r\n__put_user(kp->menu_count, &up->menu_count))\r\nreturn -EFAULT;\r\nif (__clear_user(up->reserved, sizeof(up->reserved)))\r\nreturn -EFAULT;\r\nif (kp->menu_count == 0)\r\nreturn 0;\r\nif (get_user(p, &up->menu_info))\r\nreturn -EFAULT;\r\numenus = compat_ptr(p);\r\nif (copy_in_user(umenus, kmenus, kp->menu_count * sizeof(*umenus)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_get_xu_query(struct uvc_xu_control_query *kp,\r\nconst struct uvc_xu_control_query32 __user *up)\r\n{\r\nu8 __user *udata;\r\nu8 __user *kdata;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_READ, up, sizeof(*up)) ||\r\n__copy_from_user(kp, up, offsetof(typeof(*up), data)))\r\nreturn -EFAULT;\r\nif (kp->size == 0) {\r\nkp->data = NULL;\r\nreturn 0;\r\n}\r\nif (__get_user(p, &up->data))\r\nreturn -EFAULT;\r\nudata = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, udata, kp->size))\r\nreturn -EFAULT;\r\nkdata = compat_alloc_user_space(kp->size);\r\nif (kdata == NULL)\r\nreturn -EFAULT;\r\nkp->data = kdata;\r\nif (copy_in_user(kdata, udata, kp->size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int uvc_v4l2_put_xu_query(const struct uvc_xu_control_query *kp,\r\nstruct uvc_xu_control_query32 __user *up)\r\n{\r\nu8 __user *udata;\r\nu8 __user *kdata = kp->data;\r\ncompat_caddr_t p;\r\nif (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||\r\n__copy_to_user(up, kp, offsetof(typeof(*up), data)))\r\nreturn -EFAULT;\r\nif (kp->size == 0)\r\nreturn 0;\r\nif (get_user(p, &up->data))\r\nreturn -EFAULT;\r\nudata = compat_ptr(p);\r\nif (!access_ok(VERIFY_READ, udata, kp->size))\r\nreturn -EFAULT;\r\nif (copy_in_user(udata, kdata, kp->size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long uvc_v4l2_compat_ioctl32(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nunion {\r\nstruct uvc_xu_control_mapping xmap;\r\nstruct uvc_xu_control_query xqry;\r\n} karg;\r\nvoid __user *up = compat_ptr(arg);\r\nmm_segment_t old_fs;\r\nlong ret;\r\nswitch (cmd) {\r\ncase UVCIOC_CTRL_MAP32:\r\ncmd = UVCIOC_CTRL_MAP;\r\nret = uvc_v4l2_get_xu_mapping(&karg.xmap, up);\r\nbreak;\r\ncase UVCIOC_CTRL_QUERY32:\r\ncmd = UVCIOC_CTRL_QUERY;\r\nret = uvc_v4l2_get_xu_query(&karg.xqry, up);\r\nbreak;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\nold_fs = get_fs();\r\nset_fs(KERNEL_DS);\r\nret = uvc_v4l2_ioctl(file, cmd, (unsigned long)&karg);\r\nset_fs(old_fs);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (cmd) {\r\ncase UVCIOC_CTRL_MAP:\r\nret = uvc_v4l2_put_xu_mapping(&karg.xmap, up);\r\nbreak;\r\ncase UVCIOC_CTRL_QUERY:\r\nret = uvc_v4l2_put_xu_query(&karg.xqry, up);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t uvc_v4l2_read(struct file *file, char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_read: not implemented.\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int uvc_v4l2_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_mmap\n");\r\nreturn uvc_queue_mmap(&stream->queue, vma);\r\n}\r\nstatic unsigned int uvc_v4l2_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_poll\n");\r\nreturn uvc_queue_poll(&stream->queue, file, wait);\r\n}\r\nstatic unsigned long uvc_v4l2_get_unmapped_area(struct file *file,\r\nunsigned long addr, unsigned long len, unsigned long pgoff,\r\nunsigned long flags)\r\n{\r\nstruct uvc_fh *handle = file->private_data;\r\nstruct uvc_streaming *stream = handle->stream;\r\nuvc_trace(UVC_TRACE_CALLS, "uvc_v4l2_get_unmapped_area\n");\r\nreturn uvc_queue_get_unmapped_area(&stream->queue, pgoff);\r\n}
