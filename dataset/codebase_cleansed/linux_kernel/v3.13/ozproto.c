static u8 oz_get_new_session_id(u8 exclude)\r\n{\r\nif (++g_session_id == 0)\r\ng_session_id = 1;\r\nif (g_session_id == exclude) {\r\nif (++g_session_id == 0)\r\ng_session_id = 1;\r\n}\r\nreturn g_session_id;\r\n}\r\nstatic void oz_send_conn_rsp(struct oz_pd *pd, u8 status)\r\n{\r\nstruct sk_buff *skb;\r\nstruct net_device *dev = pd->net_dev;\r\nstruct oz_hdr *oz_hdr;\r\nstruct oz_elt *elt;\r\nstruct oz_elt_connect_rsp *body;\r\nint sz = sizeof(struct oz_hdr) + sizeof(struct oz_elt) +\r\nsizeof(struct oz_elt_connect_rsp);\r\nskb = alloc_skb(sz + OZ_ALLOCATED_SPACE(dev), GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn;\r\nskb_reserve(skb, LL_RESERVED_SPACE(dev));\r\nskb_reset_network_header(skb);\r\noz_hdr = (struct oz_hdr *)skb_put(skb, sz);\r\nelt = (struct oz_elt *)(oz_hdr+1);\r\nbody = (struct oz_elt_connect_rsp *)(elt+1);\r\nskb->dev = dev;\r\nskb->protocol = htons(OZ_ETHERTYPE);\r\nif (dev_hard_header(skb, dev, OZ_ETHERTYPE, pd->mac_addr,\r\ndev->dev_addr, skb->len) < 0) {\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\noz_hdr->control = (OZ_PROTOCOL_VERSION<<OZ_VERSION_SHIFT);\r\noz_hdr->last_pkt_num = 0;\r\nput_unaligned(0, &oz_hdr->pkt_num);\r\nelt->type = OZ_ELT_CONNECT_RSP;\r\nelt->length = sizeof(struct oz_elt_connect_rsp);\r\nmemset(body, 0, sizeof(struct oz_elt_connect_rsp));\r\nbody->status = status;\r\nif (status == 0) {\r\nbody->mode = pd->mode;\r\nbody->session_id = pd->session_id;\r\nput_unaligned(cpu_to_le16(pd->total_apps), &body->apps);\r\n}\r\noz_dbg(ON, "TX: OZ_ELT_CONNECT_RSP %d", status);\r\ndev_queue_xmit(skb);\r\nreturn;\r\n}\r\nstatic void pd_set_keepalive(struct oz_pd *pd, u8 kalive)\r\n{\r\nunsigned long keep_alive = kalive & OZ_KALIVE_VALUE_MASK;\r\nswitch (kalive & OZ_KALIVE_TYPE_MASK) {\r\ncase OZ_KALIVE_SPECIAL:\r\npd->keep_alive = keep_alive * 1000*60*60*24*20;\r\nbreak;\r\ncase OZ_KALIVE_SECS:\r\npd->keep_alive = keep_alive*1000;\r\nbreak;\r\ncase OZ_KALIVE_MINS:\r\npd->keep_alive = keep_alive*1000*60;\r\nbreak;\r\ncase OZ_KALIVE_HOURS:\r\npd->keep_alive = keep_alive*1000*60*60;\r\nbreak;\r\ndefault:\r\npd->keep_alive = 0;\r\n}\r\noz_dbg(ON, "Keepalive = %lu mSec\n", pd->keep_alive);\r\n}\r\nstatic void pd_set_presleep(struct oz_pd *pd, u8 presleep, u8 start_timer)\r\n{\r\nif (presleep)\r\npd->presleep = presleep*100;\r\nelse\r\npd->presleep = OZ_PRESLEEP_TOUT;\r\nif (start_timer) {\r\nspin_unlock(&g_polling_lock);\r\noz_timer_add(pd, OZ_TIMER_TOUT, pd->presleep);\r\nspin_lock(&g_polling_lock);\r\n}\r\noz_dbg(ON, "Presleep time = %lu mSec\n", pd->presleep);\r\n}\r\nstatic struct oz_pd *oz_connect_req(struct oz_pd *cur_pd, struct oz_elt *elt,\r\nconst u8 *pd_addr, struct net_device *net_dev)\r\n{\r\nstruct oz_pd *pd;\r\nstruct oz_elt_connect_req *body =\r\n(struct oz_elt_connect_req *)(elt+1);\r\nu8 rsp_status = OZ_STATUS_SUCCESS;\r\nu8 stop_needed = 0;\r\nu16 new_apps = g_apps;\r\nstruct net_device *old_net_dev = NULL;\r\nstruct oz_pd *free_pd = NULL;\r\nif (cur_pd) {\r\npd = cur_pd;\r\nspin_lock_bh(&g_polling_lock);\r\n} else {\r\nstruct oz_pd *pd2 = NULL;\r\nstruct list_head *e;\r\npd = oz_pd_alloc(pd_addr);\r\nif (pd == NULL)\r\nreturn NULL;\r\ngetnstimeofday(&pd->last_rx_timestamp);\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each(e, &g_pd_list) {\r\npd2 = container_of(e, struct oz_pd, link);\r\nif (memcmp(pd2->mac_addr, pd_addr, ETH_ALEN) == 0) {\r\nfree_pd = pd;\r\npd = pd2;\r\nbreak;\r\n}\r\n}\r\nif (pd != pd2)\r\nlist_add_tail(&pd->link, &g_pd_list);\r\n}\r\nif (pd == NULL) {\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn NULL;\r\n}\r\nif (pd->net_dev != net_dev) {\r\nold_net_dev = pd->net_dev;\r\ndev_hold(net_dev);\r\npd->net_dev = net_dev;\r\n}\r\noz_dbg(ON, "Host vendor: %d\n", body->host_vendor);\r\npd->max_tx_size = OZ_MAX_TX_SIZE;\r\npd->mode = body->mode;\r\npd->pd_info = body->pd_info;\r\nif (pd->mode & OZ_F_ISOC_NO_ELTS) {\r\npd->ms_per_isoc = body->ms_per_isoc;\r\nif (!pd->ms_per_isoc)\r\npd->ms_per_isoc = 4;\r\nswitch (body->ms_isoc_latency & OZ_LATENCY_MASK) {\r\ncase OZ_ONE_MS_LATENCY:\r\npd->isoc_latency = (body->ms_isoc_latency &\r\n~OZ_LATENCY_MASK) / pd->ms_per_isoc;\r\nbreak;\r\ncase OZ_TEN_MS_LATENCY:\r\npd->isoc_latency = ((body->ms_isoc_latency &\r\n~OZ_LATENCY_MASK) * 10) / pd->ms_per_isoc;\r\nbreak;\r\ndefault:\r\npd->isoc_latency = OZ_MAX_TX_QUEUE_ISOC;\r\n}\r\n}\r\nif (body->max_len_div16)\r\npd->max_tx_size = ((u16)body->max_len_div16)<<4;\r\noz_dbg(ON, "Max frame:%u Ms per isoc:%u\n",\r\npd->max_tx_size, pd->ms_per_isoc);\r\npd->max_stream_buffering = 3*1024;\r\npd->pulse_period = OZ_QUANTUM;\r\npd_set_presleep(pd, body->presleep, 0);\r\npd_set_keepalive(pd, body->keep_alive);\r\nnew_apps &= le16_to_cpu(get_unaligned(&body->apps));\r\nif ((new_apps & 0x1) && (body->session_id)) {\r\nif (pd->session_id) {\r\nif (pd->session_id != body->session_id) {\r\nrsp_status = OZ_STATUS_SESSION_MISMATCH;\r\ngoto done;\r\n}\r\n} else {\r\nnew_apps &= ~0x1;\r\npd->session_id =\r\noz_get_new_session_id(body->session_id);\r\n}\r\n} else {\r\nif (pd->session_id && !body->session_id) {\r\nrsp_status = OZ_STATUS_SESSION_TEARDOWN;\r\nstop_needed = 1;\r\n} else {\r\nnew_apps &= ~0x1;\r\npd->session_id =\r\noz_get_new_session_id(body->session_id);\r\n}\r\n}\r\ndone:\r\nif (rsp_status == OZ_STATUS_SUCCESS) {\r\nu16 start_apps = new_apps & ~pd->total_apps & ~0x1;\r\nu16 stop_apps = pd->total_apps & ~new_apps & ~0x1;\r\nu16 resume_apps = new_apps & pd->paused_apps & ~0x1;\r\nspin_unlock_bh(&g_polling_lock);\r\noz_pd_set_state(pd, OZ_PD_S_CONNECTED);\r\noz_dbg(ON, "new_apps=0x%x total_apps=0x%x paused_apps=0x%x\n",\r\nnew_apps, pd->total_apps, pd->paused_apps);\r\nif (start_apps) {\r\nif (oz_services_start(pd, start_apps, 0))\r\nrsp_status = OZ_STATUS_TOO_MANY_PDS;\r\n}\r\nif (resume_apps)\r\nif (oz_services_start(pd, resume_apps, 1))\r\nrsp_status = OZ_STATUS_TOO_MANY_PDS;\r\nif (stop_apps)\r\noz_services_stop(pd, stop_apps, 0);\r\noz_pd_request_heartbeat(pd);\r\n} else {\r\nspin_unlock_bh(&g_polling_lock);\r\n}\r\noz_send_conn_rsp(pd, rsp_status);\r\nif (rsp_status != OZ_STATUS_SUCCESS) {\r\nif (stop_needed)\r\noz_pd_stop(pd);\r\noz_pd_put(pd);\r\npd = NULL;\r\n}\r\nif (old_net_dev)\r\ndev_put(old_net_dev);\r\nif (free_pd)\r\noz_pd_destroy(free_pd);\r\nreturn pd;\r\n}\r\nstatic void oz_add_farewell(struct oz_pd *pd, u8 ep_num, u8 index,\r\nconst u8 *report, u8 len)\r\n{\r\nstruct oz_farewell *f;\r\nstruct oz_farewell *f2;\r\nint found = 0;\r\nf = kmalloc(sizeof(struct oz_farewell) + len, GFP_ATOMIC);\r\nif (!f)\r\nreturn;\r\nf->ep_num = ep_num;\r\nf->index = index;\r\nf->len = len;\r\nmemcpy(f->report, report, len);\r\noz_dbg(ON, "RX: Adding farewell report\n");\r\nspin_lock(&g_polling_lock);\r\nlist_for_each_entry(f2, &pd->farewell_list, link) {\r\nif ((f2->ep_num == ep_num) && (f2->index == index)) {\r\nfound = 1;\r\nlist_del(&f2->link);\r\nbreak;\r\n}\r\n}\r\nlist_add_tail(&f->link, &pd->farewell_list);\r\nspin_unlock(&g_polling_lock);\r\nif (found)\r\nkfree(f2);\r\n}\r\nstatic void oz_rx_frame(struct sk_buff *skb)\r\n{\r\nu8 *mac_hdr;\r\nu8 *src_addr;\r\nstruct oz_elt *elt;\r\nint length;\r\nstruct oz_pd *pd = NULL;\r\nstruct oz_hdr *oz_hdr = (struct oz_hdr *)skb_network_header(skb);\r\nstruct timespec current_time;\r\nint dup = 0;\r\nu32 pkt_num;\r\noz_dbg(RX_FRAMES, "RX frame PN=0x%x LPN=0x%x control=0x%x\n",\r\noz_hdr->pkt_num, oz_hdr->last_pkt_num, oz_hdr->control);\r\nmac_hdr = skb_mac_header(skb);\r\nsrc_addr = &mac_hdr[ETH_ALEN] ;\r\nlength = skb->len;\r\nif (oz_get_prot_ver(oz_hdr->control) != OZ_PROTOCOL_VERSION) {\r\noz_dbg(ON, "Incorrect protocol version: %d\n",\r\noz_get_prot_ver(oz_hdr->control));\r\ngoto done;\r\n}\r\npkt_num = le32_to_cpu(get_unaligned(&oz_hdr->pkt_num));\r\npd = oz_pd_find(src_addr);\r\nif (pd) {\r\nif (!(pd->state & OZ_PD_S_CONNECTED))\r\noz_pd_set_state(pd, OZ_PD_S_CONNECTED);\r\ngetnstimeofday(&current_time);\r\nif ((current_time.tv_sec != pd->last_rx_timestamp.tv_sec) ||\r\n(pd->presleep < MSEC_PER_SEC)) {\r\noz_timer_add(pd, OZ_TIMER_TOUT, pd->presleep);\r\npd->last_rx_timestamp = current_time;\r\n}\r\nif (pkt_num != pd->last_rx_pkt_num) {\r\npd->last_rx_pkt_num = pkt_num;\r\n} else {\r\ndup = 1;\r\noz_dbg(ON, "Duplicate frame\n");\r\n}\r\n}\r\nif (pd && !dup && ((pd->mode & OZ_MODE_MASK) == OZ_MODE_TRIGGERED)) {\r\noz_dbg(RX_FRAMES, "Received TRIGGER Frame\n");\r\npd->last_sent_frame = &pd->tx_queue;\r\nif (oz_hdr->control & OZ_F_ACK) {\r\noz_retire_tx_frames(pd, oz_hdr->last_pkt_num);\r\n}\r\nif ((oz_hdr->control & OZ_F_ACK_REQUESTED) &&\r\n(pd->state == OZ_PD_S_CONNECTED)) {\r\nint backlog = pd->nb_queued_frames;\r\npd->trigger_pkt_num = pkt_num;\r\noz_send_queued_frames(pd, backlog);\r\n}\r\n}\r\nlength -= sizeof(struct oz_hdr);\r\nelt = (struct oz_elt *)((u8 *)oz_hdr + sizeof(struct oz_hdr));\r\nwhile (length >= sizeof(struct oz_elt)) {\r\nlength -= sizeof(struct oz_elt) + elt->length;\r\nif (length < 0)\r\nbreak;\r\nswitch (elt->type) {\r\ncase OZ_ELT_CONNECT_REQ:\r\noz_dbg(ON, "RX: OZ_ELT_CONNECT_REQ\n");\r\npd = oz_connect_req(pd, elt, src_addr, skb->dev);\r\nbreak;\r\ncase OZ_ELT_DISCONNECT:\r\noz_dbg(ON, "RX: OZ_ELT_DISCONNECT\n");\r\nif (pd)\r\noz_pd_sleep(pd);\r\nbreak;\r\ncase OZ_ELT_UPDATE_PARAM_REQ: {\r\nstruct oz_elt_update_param *body =\r\n(struct oz_elt_update_param *)(elt + 1);\r\noz_dbg(ON, "RX: OZ_ELT_UPDATE_PARAM_REQ\n");\r\nif (pd && (pd->state & OZ_PD_S_CONNECTED)) {\r\nspin_lock(&g_polling_lock);\r\npd_set_keepalive(pd, body->keepalive);\r\npd_set_presleep(pd, body->presleep, 1);\r\nspin_unlock(&g_polling_lock);\r\n}\r\n}\r\nbreak;\r\ncase OZ_ELT_FAREWELL_REQ: {\r\nstruct oz_elt_farewell *body =\r\n(struct oz_elt_farewell *)(elt + 1);\r\noz_dbg(ON, "RX: OZ_ELT_FAREWELL_REQ\n");\r\noz_add_farewell(pd, body->ep_num,\r\nbody->index, body->report,\r\nelt->length + 1 - sizeof(*body));\r\n}\r\nbreak;\r\ncase OZ_ELT_APP_DATA:\r\nif (pd && (pd->state & OZ_PD_S_CONNECTED)) {\r\nstruct oz_app_hdr *app_hdr =\r\n(struct oz_app_hdr *)(elt+1);\r\nif (dup)\r\nbreak;\r\noz_handle_app_elt(pd, app_hdr->app_id, elt);\r\n}\r\nbreak;\r\ndefault:\r\noz_dbg(ON, "RX: Unknown elt %02x\n", elt->type);\r\n}\r\nelt = oz_next_elt(elt);\r\n}\r\ndone:\r\nif (pd)\r\noz_pd_put(pd);\r\nconsume_skb(skb);\r\n}\r\nvoid oz_protocol_term(void)\r\n{\r\nstruct oz_binding *b, *t;\r\nspin_lock_bh(&g_binding_lock);\r\nlist_for_each_entry_safe(b, t, &g_binding, link) {\r\nlist_del(&b->link);\r\nspin_unlock_bh(&g_binding_lock);\r\ndev_remove_pack(&b->ptype);\r\nif (b->ptype.dev)\r\ndev_put(b->ptype.dev);\r\nkfree(b);\r\nspin_lock_bh(&g_binding_lock);\r\n}\r\nspin_unlock_bh(&g_binding_lock);\r\nspin_lock_bh(&g_polling_lock);\r\nwhile (!list_empty(&g_pd_list)) {\r\nstruct oz_pd *pd =\r\nlist_first_entry(&g_pd_list, struct oz_pd, link);\r\noz_pd_get(pd);\r\nspin_unlock_bh(&g_polling_lock);\r\noz_pd_stop(pd);\r\noz_pd_put(pd);\r\nspin_lock_bh(&g_polling_lock);\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\noz_dbg(ON, "Protocol stopped\n");\r\n}\r\nvoid oz_pd_heartbeat_handler(unsigned long data)\r\n{\r\nstruct oz_pd *pd = (struct oz_pd *)data;\r\nu16 apps = 0;\r\nspin_lock_bh(&g_polling_lock);\r\nif (pd->state & OZ_PD_S_CONNECTED)\r\napps = pd->total_apps;\r\nspin_unlock_bh(&g_polling_lock);\r\nif (apps)\r\noz_pd_heartbeat(pd, apps);\r\noz_pd_put(pd);\r\n}\r\nvoid oz_pd_timeout_handler(unsigned long data)\r\n{\r\nint type;\r\nstruct oz_pd *pd = (struct oz_pd *)data;\r\nspin_lock_bh(&g_polling_lock);\r\ntype = pd->timeout_type;\r\nspin_unlock_bh(&g_polling_lock);\r\nswitch (type) {\r\ncase OZ_TIMER_TOUT:\r\noz_pd_sleep(pd);\r\nbreak;\r\ncase OZ_TIMER_STOP:\r\noz_pd_stop(pd);\r\nbreak;\r\n}\r\noz_pd_put(pd);\r\n}\r\nenum hrtimer_restart oz_pd_heartbeat_event(struct hrtimer *timer)\r\n{\r\nstruct oz_pd *pd;\r\npd = container_of(timer, struct oz_pd, heartbeat);\r\nhrtimer_forward_now(timer, ktime_set(pd->pulse_period /\r\nMSEC_PER_SEC, (pd->pulse_period % MSEC_PER_SEC) * NSEC_PER_MSEC));\r\noz_pd_get(pd);\r\ntasklet_schedule(&pd->heartbeat_tasklet);\r\nreturn HRTIMER_RESTART;\r\n}\r\nenum hrtimer_restart oz_pd_timeout_event(struct hrtimer *timer)\r\n{\r\nstruct oz_pd *pd;\r\npd = container_of(timer, struct oz_pd, timeout);\r\noz_pd_get(pd);\r\ntasklet_schedule(&pd->timeout_tasklet);\r\nreturn HRTIMER_NORESTART;\r\n}\r\nvoid oz_timer_add(struct oz_pd *pd, int type, unsigned long due_time)\r\n{\r\nspin_lock_bh(&g_polling_lock);\r\nswitch (type) {\r\ncase OZ_TIMER_TOUT:\r\ncase OZ_TIMER_STOP:\r\nif (hrtimer_active(&pd->timeout)) {\r\nhrtimer_set_expires(&pd->timeout, ktime_set(due_time /\r\nMSEC_PER_SEC, (due_time % MSEC_PER_SEC) *\r\nNSEC_PER_MSEC));\r\nhrtimer_start_expires(&pd->timeout, HRTIMER_MODE_REL);\r\n} else {\r\nhrtimer_start(&pd->timeout, ktime_set(due_time /\r\nMSEC_PER_SEC, (due_time % MSEC_PER_SEC) *\r\nNSEC_PER_MSEC), HRTIMER_MODE_REL);\r\n}\r\npd->timeout_type = type;\r\nbreak;\r\ncase OZ_TIMER_HEARTBEAT:\r\nif (!hrtimer_active(&pd->heartbeat))\r\nhrtimer_start(&pd->heartbeat, ktime_set(due_time /\r\nMSEC_PER_SEC, (due_time % MSEC_PER_SEC) *\r\nNSEC_PER_MSEC), HRTIMER_MODE_REL);\r\nbreak;\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\n}\r\nvoid oz_pd_request_heartbeat(struct oz_pd *pd)\r\n{\r\noz_timer_add(pd, OZ_TIMER_HEARTBEAT, pd->pulse_period > 0 ?\r\npd->pulse_period : OZ_QUANTUM);\r\n}\r\nstruct oz_pd *oz_pd_find(const u8 *mac_addr)\r\n{\r\nstruct oz_pd *pd;\r\nstruct list_head *e;\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each(e, &g_pd_list) {\r\npd = container_of(e, struct oz_pd, link);\r\nif (memcmp(pd->mac_addr, mac_addr, ETH_ALEN) == 0) {\r\natomic_inc(&pd->ref_count);\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn pd;\r\n}\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn NULL;\r\n}\r\nvoid oz_app_enable(int app_id, int enable)\r\n{\r\nif (app_id <= OZ_APPID_MAX) {\r\nspin_lock_bh(&g_polling_lock);\r\nif (enable)\r\ng_apps |= (1<<app_id);\r\nelse\r\ng_apps &= ~(1<<app_id);\r\nspin_unlock_bh(&g_polling_lock);\r\n}\r\n}\r\nstatic int oz_pkt_recv(struct sk_buff *skb, struct net_device *dev,\r\nstruct packet_type *pt, struct net_device *orig_dev)\r\n{\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (skb == NULL)\r\nreturn 0;\r\nspin_lock_bh(&g_rx_queue.lock);\r\nif (g_processing_rx) {\r\n__skb_queue_head(&g_rx_queue, skb);\r\nspin_unlock_bh(&g_rx_queue.lock);\r\n} else {\r\ng_processing_rx = 1;\r\ndo {\r\nspin_unlock_bh(&g_rx_queue.lock);\r\noz_rx_frame(skb);\r\nspin_lock_bh(&g_rx_queue.lock);\r\nif (skb_queue_empty(&g_rx_queue)) {\r\ng_processing_rx = 0;\r\nspin_unlock_bh(&g_rx_queue.lock);\r\nbreak;\r\n}\r\nskb = __skb_dequeue(&g_rx_queue);\r\n} while (1);\r\n}\r\nreturn 0;\r\n}\r\nvoid oz_binding_add(const char *net_dev)\r\n{\r\nstruct oz_binding *binding;\r\nbinding = kmalloc(sizeof(struct oz_binding), GFP_KERNEL);\r\nif (binding) {\r\nbinding->ptype.type = __constant_htons(OZ_ETHERTYPE);\r\nbinding->ptype.func = oz_pkt_recv;\r\nmemcpy(binding->name, net_dev, OZ_MAX_BINDING_LEN);\r\nif (net_dev && *net_dev) {\r\noz_dbg(ON, "Adding binding: %s\n", net_dev);\r\nbinding->ptype.dev =\r\ndev_get_by_name(&init_net, net_dev);\r\nif (binding->ptype.dev == NULL) {\r\noz_dbg(ON, "Netdev %s not found\n", net_dev);\r\nkfree(binding);\r\nbinding = NULL;\r\n}\r\n} else {\r\noz_dbg(ON, "Binding to all netcards\n");\r\nbinding->ptype.dev = NULL;\r\n}\r\nif (binding) {\r\ndev_add_pack(&binding->ptype);\r\nspin_lock_bh(&g_binding_lock);\r\nlist_add_tail(&binding->link, &g_binding);\r\nspin_unlock_bh(&g_binding_lock);\r\n}\r\n}\r\n}\r\nstatic void pd_stop_all_for_device(struct net_device *net_dev)\r\n{\r\nstruct list_head h;\r\nstruct oz_pd *pd;\r\nstruct oz_pd *n;\r\nINIT_LIST_HEAD(&h);\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each_entry_safe(pd, n, &g_pd_list, link) {\r\nif (pd->net_dev == net_dev) {\r\nlist_move(&pd->link, &h);\r\noz_pd_get(pd);\r\n}\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\nwhile (!list_empty(&h)) {\r\npd = list_first_entry(&h, struct oz_pd, link);\r\noz_pd_stop(pd);\r\noz_pd_put(pd);\r\n}\r\n}\r\nvoid oz_binding_remove(const char *net_dev)\r\n{\r\nstruct oz_binding *binding;\r\nint found = 0;\r\noz_dbg(ON, "Removing binding: %s\n", net_dev);\r\nspin_lock_bh(&g_binding_lock);\r\nlist_for_each_entry(binding, &g_binding, link) {\r\nif (strncmp(binding->name, net_dev, OZ_MAX_BINDING_LEN) == 0) {\r\noz_dbg(ON, "Binding '%s' found\n", net_dev);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&g_binding_lock);\r\nif (found) {\r\ndev_remove_pack(&binding->ptype);\r\nif (binding->ptype.dev) {\r\ndev_put(binding->ptype.dev);\r\npd_stop_all_for_device(binding->ptype.dev);\r\n}\r\nlist_del(&binding->link);\r\nkfree(binding);\r\n}\r\n}\r\nstatic char *oz_get_next_device_name(char *s, char *dname, int max_size)\r\n{\r\nwhile (*s == ',')\r\ns++;\r\nwhile (*s && (*s != ',') && max_size > 1) {\r\n*dname++ = *s++;\r\nmax_size--;\r\n}\r\n*dname = 0;\r\nreturn s;\r\n}\r\nint oz_protocol_init(char *devs)\r\n{\r\nskb_queue_head_init(&g_rx_queue);\r\nif (devs && (devs[0] == '*')) {\r\noz_binding_add(NULL);\r\n} else {\r\nchar d[32];\r\nwhile (*devs) {\r\ndevs = oz_get_next_device_name(devs, d, sizeof(d));\r\nif (d[0])\r\noz_binding_add(d);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint oz_get_pd_list(struct oz_mac_addr *addr, int max_count)\r\n{\r\nstruct oz_pd *pd;\r\nstruct list_head *e;\r\nint count = 0;\r\nspin_lock_bh(&g_polling_lock);\r\nlist_for_each(e, &g_pd_list) {\r\nif (count >= max_count)\r\nbreak;\r\npd = container_of(e, struct oz_pd, link);\r\nmemcpy(&addr[count++], pd->mac_addr, ETH_ALEN);\r\n}\r\nspin_unlock_bh(&g_polling_lock);\r\nreturn count;\r\n}\r\nvoid oz_polling_lock_bh(void)\r\n{\r\nspin_lock_bh(&g_polling_lock);\r\n}\r\nvoid oz_polling_unlock_bh(void)\r\n{\r\nspin_unlock_bh(&g_polling_lock);\r\n}
