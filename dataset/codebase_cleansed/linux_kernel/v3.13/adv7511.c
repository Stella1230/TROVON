static inline struct adv7511_state *get_adv7511_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct adv7511_state, sd);\r\n}\r\nstatic inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn &container_of(ctrl->handler, struct adv7511_state, hdl)->sd;\r\n}\r\nstatic s32 adv_smbus_read_byte_data_check(struct i2c_client *client,\r\nu8 command, bool check)\r\n{\r\nunion i2c_smbus_data data;\r\nif (!i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_BYTE_DATA, &data))\r\nreturn data.byte;\r\nif (check)\r\nv4l_err(client, "error reading %02x, %02x\n",\r\nclient->addr, command);\r\nreturn -1;\r\n}\r\nstatic s32 adv_smbus_read_byte_data(struct i2c_client *client, u8 command)\r\n{\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nint ret = adv_smbus_read_byte_data_check(client, command, true);\r\nif (ret >= 0) {\r\nif (i)\r\nv4l_err(client, "read ok after %d retries\n", i);\r\nreturn ret;\r\n}\r\n}\r\nv4l_err(client, "read failed\n");\r\nreturn -1;\r\n}\r\nstatic int adv7511_rd(struct v4l2_subdev *sd, u8 reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn adv_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int adv7511_wr(struct v4l2_subdev *sd, u8 reg, u8 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nint ret;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nif (ret == 0)\r\nreturn 0;\r\n}\r\nv4l2_err(sd, "%s: i2c write error\n", __func__);\r\nreturn ret;\r\n}\r\nstatic inline void adv7511_wr_and_or(struct v4l2_subdev *sd, u8 reg, uint8_t clr_mask, uint8_t val_mask)\r\n{\r\nadv7511_wr(sd, reg, (adv7511_rd(sd, reg) & clr_mask) | val_mask);\r\n}\r\nstatic int adv_smbus_read_i2c_block_data(struct i2c_client *client,\r\nu8 command, unsigned length, u8 *values)\r\n{\r\nunion i2c_smbus_data data;\r\nint ret;\r\nif (length > I2C_SMBUS_BLOCK_MAX)\r\nlength = I2C_SMBUS_BLOCK_MAX;\r\ndata.block[0] = length;\r\nret = i2c_smbus_xfer(client->adapter, client->addr, client->flags,\r\nI2C_SMBUS_READ, command,\r\nI2C_SMBUS_I2C_BLOCK_DATA, &data);\r\nmemcpy(values, data.block + 1, length);\r\nreturn ret;\r\n}\r\nstatic inline void adv7511_edid_rd(struct v4l2_subdev *sd, uint16_t len, uint8_t *buf)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nint i;\r\nint err = 0;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nfor (i = 0; !err && i < len; i += I2C_SMBUS_BLOCK_MAX)\r\nerr = adv_smbus_read_i2c_block_data(state->i2c_edid, i,\r\nI2C_SMBUS_BLOCK_MAX, buf + i);\r\nif (err)\r\nv4l2_err(sd, "%s: i2c read error\n", __func__);\r\n}\r\nstatic inline bool adv7511_have_hotplug(struct v4l2_subdev *sd)\r\n{\r\nreturn adv7511_rd(sd, 0x42) & MASK_ADV7511_HPD_DETECT;\r\n}\r\nstatic inline bool adv7511_have_rx_sense(struct v4l2_subdev *sd)\r\n{\r\nreturn adv7511_rd(sd, 0x42) & MASK_ADV7511_MSEN_DETECT;\r\n}\r\nstatic void adv7511_csc_conversion_mode(struct v4l2_subdev *sd, uint8_t mode)\r\n{\r\nadv7511_wr_and_or(sd, 0x18, 0x9f, (mode & 0x3)<<5);\r\n}\r\nstatic void adv7511_csc_coeff(struct v4l2_subdev *sd,\r\nu16 A1, u16 A2, u16 A3, u16 A4,\r\nu16 B1, u16 B2, u16 B3, u16 B4,\r\nu16 C1, u16 C2, u16 C3, u16 C4)\r\n{\r\nadv7511_wr_and_or(sd, 0x18, 0xe0, A1>>8);\r\nadv7511_wr(sd, 0x19, A1);\r\nadv7511_wr_and_or(sd, 0x1A, 0xe0, A2>>8);\r\nadv7511_wr(sd, 0x1B, A2);\r\nadv7511_wr_and_or(sd, 0x1c, 0xe0, A3>>8);\r\nadv7511_wr(sd, 0x1d, A3);\r\nadv7511_wr_and_or(sd, 0x1e, 0xe0, A4>>8);\r\nadv7511_wr(sd, 0x1f, A4);\r\nadv7511_wr_and_or(sd, 0x20, 0xe0, B1>>8);\r\nadv7511_wr(sd, 0x21, B1);\r\nadv7511_wr_and_or(sd, 0x22, 0xe0, B2>>8);\r\nadv7511_wr(sd, 0x23, B2);\r\nadv7511_wr_and_or(sd, 0x24, 0xe0, B3>>8);\r\nadv7511_wr(sd, 0x25, B3);\r\nadv7511_wr_and_or(sd, 0x26, 0xe0, B4>>8);\r\nadv7511_wr(sd, 0x27, B4);\r\nadv7511_wr_and_or(sd, 0x28, 0xe0, C1>>8);\r\nadv7511_wr(sd, 0x29, C1);\r\nadv7511_wr_and_or(sd, 0x2A, 0xe0, C2>>8);\r\nadv7511_wr(sd, 0x2B, C2);\r\nadv7511_wr_and_or(sd, 0x2C, 0xe0, C3>>8);\r\nadv7511_wr(sd, 0x2D, C3);\r\nadv7511_wr_and_or(sd, 0x2E, 0xe0, C4>>8);\r\nadv7511_wr(sd, 0x2F, C4);\r\n}\r\nstatic void adv7511_csc_rgb_full2limit(struct v4l2_subdev *sd, bool enable)\r\n{\r\nif (enable) {\r\nuint8_t csc_mode = 0;\r\nadv7511_csc_conversion_mode(sd, csc_mode);\r\nadv7511_csc_coeff(sd,\r\n4096-564, 0, 0, 256,\r\n0, 4096-564, 0, 256,\r\n0, 0, 4096-564, 256);\r\nadv7511_wr_and_or(sd, 0x18, 0x7f, 0x80);\r\nadv7511_wr_and_or(sd, 0x57, 0xf3, 0x04);\r\n} else {\r\nadv7511_wr_and_or(sd, 0x18, 0x7f, 0x0);\r\nadv7511_wr_and_or(sd, 0x57, 0xf3, 0x08);\r\n}\r\n}\r\nstatic void adv7511_set_IT_content_AVI_InfoFrame(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nif (state->dv_timings.bt.standards & V4L2_DV_BT_STD_CEA861) {\r\nadv7511_wr_and_or(sd, 0x57, 0x7f, 0x00);\r\n} else {\r\nadv7511_wr_and_or(sd, 0x57, 0x7f, 0x80);\r\n}\r\n}\r\nstatic int adv7511_set_rgb_quantization_mode(struct v4l2_subdev *sd, struct v4l2_ctrl *ctrl)\r\n{\r\nswitch (ctrl->val) {\r\ndefault:\r\nreturn -EINVAL;\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_AUTO: {\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nif (state->dv_timings.bt.standards & V4L2_DV_BT_STD_CEA861) {\r\nadv7511_csc_rgb_full2limit(sd, true);\r\n} else {\r\nadv7511_csc_rgb_full2limit(sd, false);\r\n}\r\n}\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_LIMITED:\r\nadv7511_csc_rgb_full2limit(sd, true);\r\nbreak;\r\ncase V4L2_DV_RGB_RANGE_FULL:\r\nadv7511_csc_rgb_full2limit(sd, false);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct v4l2_subdev *sd = to_sd(ctrl);\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s: ctrl id: %d, ctrl->val %d\n", __func__, ctrl->id, ctrl->val);\r\nif (state->hdmi_mode_ctrl == ctrl) {\r\nadv7511_wr_and_or(sd, 0xaf, 0xfd, ctrl->val == V4L2_DV_TX_MODE_HDMI ? 0x02 : 0x00);\r\nreturn 0;\r\n}\r\nif (state->rgb_quantization_range_ctrl == ctrl)\r\nreturn adv7511_set_rgb_quantization_mode(sd, ctrl);\r\nreturn -EINVAL;\r\n}\r\nstatic void adv7511_inv_register(struct v4l2_subdev *sd)\r\n{\r\nv4l2_info(sd, "0x000-0x0ff: Main Map\n");\r\n}\r\nstatic int adv7511_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)\r\n{\r\nreg->size = 1;\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nreg->val = adv7511_rd(sd, reg->reg & 0xff);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7511_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)\r\n{\r\nswitch (reg->reg >> 8) {\r\ncase 0:\r\nadv7511_wr(sd, reg->reg & 0xff, reg->val & 0xff);\r\nbreak;\r\ndefault:\r\nv4l2_info(sd, "Register %03llx not supported\n", reg->reg);\r\nadv7511_inv_register(sd);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct adv7511_state_edid *edid = &state->edid;\r\nstatic const char * const states[] = {\r\n"in reset",\r\n"reading EDID",\r\n"idle",\r\n"initializing HDCP",\r\n"HDCP enabled",\r\n"initializing HDCP repeater",\r\n"6", "7", "8", "9", "A", "B", "C", "D", "E", "F"\r\n};\r\nstatic const char * const errors[] = {\r\n"no error",\r\n"bad receiver BKSV",\r\n"Ri mismatch",\r\n"Pj mismatch",\r\n"i2c error",\r\n"timed out",\r\n"max repeater cascade exceeded",\r\n"hash check failed",\r\n"too many devices",\r\n"9", "A", "B", "C", "D", "E", "F"\r\n};\r\nv4l2_info(sd, "power %s\n", state->power_on ? "on" : "off");\r\nv4l2_info(sd, "%s hotplug, %s Rx Sense, %s EDID (%d block(s))\n",\r\n(adv7511_rd(sd, 0x42) & MASK_ADV7511_HPD_DETECT) ? "detected" : "no",\r\n(adv7511_rd(sd, 0x42) & MASK_ADV7511_MSEN_DETECT) ? "detected" : "no",\r\nedid->segments ? "found" : "no",\r\nedid->blocks);\r\nv4l2_info(sd, "%s output %s\n",\r\n(adv7511_rd(sd, 0xaf) & 0x02) ?\r\n"HDMI" : "DVI-D",\r\n(adv7511_rd(sd, 0xa1) & 0x3c) ?\r\n"disabled" : "enabled");\r\nv4l2_info(sd, "state: %s, error: %s, detect count: %u, msk/irq: %02x/%02x\n",\r\nstates[adv7511_rd(sd, 0xc8) & 0xf],\r\nerrors[adv7511_rd(sd, 0xc8) >> 4], state->edid_detect_counter,\r\nadv7511_rd(sd, 0x94), adv7511_rd(sd, 0x96));\r\nv4l2_info(sd, "RGB quantization: %s range\n", adv7511_rd(sd, 0x18) & 0x80 ? "limited" : "full");\r\nif (state->dv_timings.type == V4L2_DV_BT_656_1120)\r\nv4l2_print_dv_timings(sd->name, "timings: ",\r\n&state->dv_timings, false);\r\nelse\r\nv4l2_info(sd, "no timings set\n");\r\nv4l2_info(sd, "i2c edid addr: 0x%x\n", state->i2c_edid_addr);\r\nv4l2_info(sd, "i2c cec addr: 0x%x\n", state->i2c_cec_addr);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_power(struct v4l2_subdev *sd, int on)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nconst int retries = 20;\r\nint i;\r\nv4l2_dbg(1, debug, sd, "%s: power %s\n", __func__, on ? "on" : "off");\r\nstate->power_on = on;\r\nif (!on) {\r\nadv7511_wr_and_or(sd, 0x41, 0xbf, 0x40);\r\nreturn true;\r\n}\r\nfor (i = 0; i < retries; i++) {\r\nadv7511_wr_and_or(sd, 0x41, 0xbf, 0x0);\r\nif ((adv7511_rd(sd, 0x41) & 0x40) == 0)\r\nbreak;\r\nadv7511_wr_and_or(sd, 0x41, 0xbf, 0x40);\r\nmsleep(10);\r\n}\r\nif (i == retries) {\r\nv4l2_dbg(1, debug, sd, "%s: failed to powerup the adv7511!\n", __func__);\r\nadv7511_s_power(sd, 0);\r\nreturn false;\r\n}\r\nif (i > 1)\r\nv4l2_dbg(1, debug, sd, "%s: needed %d retries to powerup the adv7511\n", __func__, i);\r\nadv7511_wr(sd, 0x98, 0x03);\r\nadv7511_wr_and_or(sd, 0x9a, 0xfe, 0x70);\r\nadv7511_wr(sd, 0x9c, 0x30);\r\nadv7511_wr_and_or(sd, 0x9d, 0xfc, 0x01);\r\nadv7511_wr(sd, 0xa2, 0xa4);\r\nadv7511_wr(sd, 0xa3, 0xa4);\r\nadv7511_wr(sd, 0xe0, 0xd0);\r\nadv7511_wr(sd, 0xf9, 0x00);\r\nadv7511_wr(sd, 0x43, state->i2c_edid_addr);\r\nadv7511_wr(sd, 0xc9, 0xf);\r\nreturn true;\r\n}\r\nstatic void adv7511_set_isr(struct v4l2_subdev *sd, bool enable)\r\n{\r\nuint8_t irqs = MASK_ADV7511_HPD_INT | MASK_ADV7511_MSEN_INT;\r\nuint8_t irqs_rd;\r\nint retries = 100;\r\nv4l2_dbg(2, debug, sd, "%s: %s\n", __func__, enable ? "enable" : "disable");\r\nif (!enable)\r\nirqs = 0;\r\nelse if (adv7511_have_hotplug(sd))\r\nirqs |= MASK_ADV7511_EDID_RDY_INT;\r\ndo {\r\nadv7511_wr(sd, 0x94, irqs);\r\nirqs_rd = adv7511_rd(sd, 0x94);\r\n} while (retries-- && irqs_rd != irqs);\r\nif (irqs_rd == irqs)\r\nreturn;\r\nv4l2_err(sd, "Could not set interrupts: hw failure?\n");\r\n}\r\nstatic int adv7511_isr(struct v4l2_subdev *sd, u32 status, bool *handled)\r\n{\r\nuint8_t irq_status;\r\nadv7511_set_isr(sd, false);\r\nirq_status = adv7511_rd(sd, 0x96);\r\nadv7511_wr(sd, 0x96, irq_status);\r\nv4l2_dbg(1, debug, sd, "%s: irq 0x%x\n", __func__, irq_status);\r\nif (irq_status & (MASK_ADV7511_HPD_INT | MASK_ADV7511_MSEN_INT))\r\nadv7511_check_monitor_present_status(sd);\r\nif (irq_status & MASK_ADV7511_EDID_RDY_INT)\r\nadv7511_check_edid_status(sd);\r\nadv7511_set_isr(sd, true);\r\nif (handled)\r\n*handled = true;\r\nreturn 0;\r\n}\r\nstatic int adv7511_get_edid(struct v4l2_subdev *sd, struct v4l2_subdev_edid *edid)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nif (edid->pad != 0)\r\nreturn -EINVAL;\r\nif ((edid->blocks == 0) || (edid->blocks > 256))\r\nreturn -EINVAL;\r\nif (!edid->edid)\r\nreturn -EINVAL;\r\nif (!state->edid.segments) {\r\nv4l2_dbg(1, debug, sd, "EDID segment 0 not found\n");\r\nreturn -ENODATA;\r\n}\r\nif (edid->start_block >= state->edid.segments * 2)\r\nreturn -E2BIG;\r\nif ((edid->blocks + edid->start_block) >= state->edid.segments * 2)\r\nedid->blocks = state->edid.segments * 2 - edid->start_block;\r\nmemcpy(edid->edid, &state->edid.data[edid->start_block * 128],\r\n128 * edid->blocks);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n", __func__, (enable ? "en" : "dis"));\r\nadv7511_wr_and_or(sd, 0xa1, ~0x3c, (enable ? 0 : 0x3c));\r\nif (enable) {\r\nadv7511_check_monitor_present_status(sd);\r\n} else {\r\nadv7511_s_power(sd, 0);\r\nstate->have_monitor = false;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!v4l2_valid_dv_timings(timings, &adv7511_timings_cap, NULL, NULL))\r\nreturn -EINVAL;\r\nv4l2_find_dv_timings_cap(timings, &adv7511_timings_cap, 0, NULL, NULL);\r\ntimings->bt.flags &= ~V4L2_DV_FL_REDUCED_FPS;\r\nstate->dv_timings = *timings;\r\nadv7511_set_rgb_quantization_mode(sd, state->rgb_quantization_range_ctrl);\r\nadv7511_set_IT_content_AVI_InfoFrame(sd);\r\nreturn 0;\r\n}\r\nstatic int adv7511_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (!timings)\r\nreturn -EINVAL;\r\n*timings = state->dv_timings;\r\nreturn 0;\r\n}\r\nstatic int adv7511_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nreturn v4l2_enum_dv_timings_cap(timings, &adv7511_timings_cap, NULL, NULL);\r\n}\r\nstatic int adv7511_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\n*cap = adv7511_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_audio_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s: %sable\n", __func__, (enable ? "en" : "dis"));\r\nif (enable)\r\nadv7511_wr_and_or(sd, 0x4b, 0x3f, 0x80);\r\nelse\r\nadv7511_wr_and_or(sd, 0x4b, 0x3f, 0x40);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nu32 N;\r\nswitch (freq) {\r\ncase 32000: N = 4096; break;\r\ncase 44100: N = 6272; break;\r\ncase 48000: N = 6144; break;\r\ncase 88200: N = 12544; break;\r\ncase 96000: N = 12288; break;\r\ncase 176400: N = 25088; break;\r\ncase 192000: N = 24576; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadv7511_wr(sd, 0x01, (N >> 16) & 0xf);\r\nadv7511_wr(sd, 0x02, (N >> 8) & 0xff);\r\nadv7511_wr(sd, 0x03, N & 0xff);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_i2s_clock_freq(struct v4l2_subdev *sd, u32 freq)\r\n{\r\nu32 i2s_sf;\r\nswitch (freq) {\r\ncase 32000: i2s_sf = 0x30; break;\r\ncase 44100: i2s_sf = 0x00; break;\r\ncase 48000: i2s_sf = 0x20; break;\r\ncase 88200: i2s_sf = 0x80; break;\r\ncase 96000: i2s_sf = 0xa0; break;\r\ncase 176400: i2s_sf = 0xc0; break;\r\ncase 192000: i2s_sf = 0xe0; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadv7511_wr_and_or(sd, 0x15, 0xf, i2s_sf);\r\nreturn 0;\r\n}\r\nstatic int adv7511_s_routing(struct v4l2_subdev *sd, u32 input, u32 output, u32 config)\r\n{\r\nadv7511_wr_and_or(sd, 0x73, 0xf8, 0x1);\r\nadv7511_wr(sd, 0x76, 0x00);\r\nadv7511_wr_and_or(sd, 0x14, 0xf0, 0x02);\r\nreturn 0;\r\n}\r\nstatic void adv7511_dbg_dump_edid(int lvl, int debug, struct v4l2_subdev *sd, int segment, uint8_t *buf)\r\n{\r\nif (debug >= lvl) {\r\nint i, j;\r\nv4l2_dbg(lvl, debug, sd, "edid segment %d\n", segment);\r\nfor (i = 0; i < 256; i += 16) {\r\nu8 b[128];\r\nu8 *bp = b;\r\nif (i == 128)\r\nv4l2_dbg(lvl, debug, sd, "\n");\r\nfor (j = i; j < i + 16; j++) {\r\nsprintf(bp, "0x%02x, ", buf[j]);\r\nbp += 6;\r\n}\r\nbp[0] = '\0';\r\nv4l2_dbg(lvl, debug, sd, "%s\n", b);\r\n}\r\n}\r\n}\r\nstatic void adv7511_edid_handler(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct adv7511_state *state = container_of(dwork, struct adv7511_state, edid_handler);\r\nstruct v4l2_subdev *sd = &state->sd;\r\nstruct adv7511_edid_detect ed;\r\nv4l2_dbg(1, debug, sd, "%s:\n", __func__);\r\nif (adv7511_check_edid_status(sd)) {\r\nreturn;\r\n}\r\nif (adv7511_have_hotplug(sd)) {\r\nif (state->edid.read_retries) {\r\nstate->edid.read_retries--;\r\nv4l2_dbg(1, debug, sd, "%s: edid read failed\n", __func__);\r\nstate->have_monitor = false;\r\nadv7511_s_power(sd, false);\r\nadv7511_s_power(sd, true);\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\nreturn;\r\n}\r\n}\r\ned.present = false;\r\ned.segment = adv7511_rd(sd, 0xc4);\r\nv4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&ed);\r\nv4l2_dbg(1, debug, sd, "%s: no edid found\n", __func__);\r\n}\r\nstatic void adv7511_audio_setup(struct v4l2_subdev *sd)\r\n{\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nadv7511_s_i2s_clock_freq(sd, 48000);\r\nadv7511_s_clock_freq(sd, 48000);\r\nadv7511_s_routing(sd, 0, 0, 0);\r\n}\r\nstatic void adv7511_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nadv7511_wr_and_or(sd, 0x15, 0xf0, 0x0);\r\nadv7511_wr_and_or(sd, 0x16, 0x7f, 0x0);\r\nadv7511_wr_and_or(sd, 0x17, 0xf9, 0x06);\r\nadv7511_wr_and_or(sd, 0x3b, 0x9f, 0x0);\r\nadv7511_wr_and_or(sd, 0x18, 0x7f, 0x0);\r\nadv7511_wr_and_or(sd, 0x55, 0x9c, 0x12);\r\nadv7511_wr_and_or(sd, 0x44, 0xe7, 0x10);\r\nadv7511_wr(sd, 0x56, 0xa8);\r\nadv7511_wr_and_or(sd, 0xaf, 0xed, 0x0);\r\nadv7511_wr_and_or(sd, 0xba, 0x1f, 0x60);\r\nadv7511_audio_setup(sd);\r\nv4l2_ctrl_handler_setup(&state->hdl);\r\n}\r\nstatic void adv7511_notify_monitor_detect(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_monitor_detect mdt;\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nmdt.present = state->have_monitor;\r\nv4l2_subdev_notify(sd, ADV7511_MONITOR_DETECT, (void *)&mdt);\r\n}\r\nstatic void adv7511_check_monitor_present_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nuint8_t status = adv7511_rd(sd, 0x42);\r\nv4l2_dbg(1, debug, sd, "%s: status: 0x%x%s%s\n",\r\n__func__,\r\nstatus,\r\nstatus & MASK_ADV7511_HPD_DETECT ? ", hotplug" : "",\r\nstatus & MASK_ADV7511_MSEN_DETECT ? ", rx-sense" : "");\r\nv4l2_ctrl_s_ctrl(state->hotplug_ctrl, adv7511_have_hotplug(sd) ? 0x1 : 0x0);\r\nv4l2_ctrl_s_ctrl(state->rx_sense_ctrl, adv7511_have_rx_sense(sd) ? 0x1 : 0x0);\r\nv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, state->edid.segments ? 0x1 : 0x0);\r\nif ((status & MASK_ADV7511_HPD_DETECT) && ((status & MASK_ADV7511_MSEN_DETECT) || state->edid.segments)) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug and (rx-sense or edid)\n", __func__);\r\nif (!state->have_monitor) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor detected\n", __func__);\r\nstate->have_monitor = true;\r\nadv7511_set_isr(sd, true);\r\nif (!adv7511_s_power(sd, true)) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor detected, powerup failed\n", __func__);\r\nreturn;\r\n}\r\nadv7511_setup(sd);\r\nadv7511_notify_monitor_detect(sd);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\n}\r\n} else if (status & MASK_ADV7511_HPD_DETECT) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug detected\n", __func__);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\n} else if (!(status & MASK_ADV7511_HPD_DETECT)) {\r\nv4l2_dbg(1, debug, sd, "%s: hotplug not detected\n", __func__);\r\nif (state->have_monitor) {\r\nv4l2_dbg(1, debug, sd, "%s: monitor not detected\n", __func__);\r\nstate->have_monitor = false;\r\nadv7511_notify_monitor_detect(sd);\r\n}\r\nadv7511_s_power(sd, false);\r\nmemset(&state->edid, 0, sizeof(struct adv7511_state_edid));\r\n}\r\n}\r\nstatic bool edid_block_verify_crc(uint8_t *edid_block)\r\n{\r\nint i;\r\nuint8_t sum = 0;\r\nfor (i = 0; i < 128; i++)\r\nsum += *(edid_block + i);\r\nreturn (sum == 0);\r\n}\r\nstatic bool edid_segment_verify_crc(struct v4l2_subdev *sd, u32 segment)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nu32 blocks = state->edid.blocks;\r\nuint8_t *data = state->edid.data;\r\nif (edid_block_verify_crc(&data[segment * 256])) {\r\nif ((segment + 1) * 2 <= blocks)\r\nreturn edid_block_verify_crc(&data[segment * 256 + 128]);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool adv7511_check_edid_status(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nuint8_t edidRdy = adv7511_rd(sd, 0xc5);\r\nv4l2_dbg(1, debug, sd, "%s: edid ready (retries: %d)\n",\r\n__func__, EDID_MAX_RETRIES - state->edid.read_retries);\r\nif (state->edid.complete)\r\nreturn true;\r\nif (edidRdy & MASK_ADV7511_EDID_RDY) {\r\nint segment = adv7511_rd(sd, 0xc4);\r\nstruct adv7511_edid_detect ed;\r\nif (segment >= EDID_MAX_SEGM) {\r\nv4l2_err(sd, "edid segment number too big\n");\r\nreturn false;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: got segment %d\n", __func__, segment);\r\nadv7511_edid_rd(sd, 256, &state->edid.data[segment * 256]);\r\nadv7511_dbg_dump_edid(2, debug, sd, segment, &state->edid.data[segment * 256]);\r\nif (segment == 0) {\r\nstate->edid.blocks = state->edid.data[0x7e] + 1;\r\nv4l2_dbg(1, debug, sd, "%s: %d blocks in total\n", __func__, state->edid.blocks);\r\n}\r\nif (!edid_segment_verify_crc(sd, segment)) {\r\nv4l2_dbg(1, debug, sd, "%s: edid crc error\n", __func__);\r\nstate->have_monitor = false;\r\nadv7511_s_power(sd, false);\r\nadv7511_s_power(sd, true);\r\nreturn false;\r\n}\r\nstate->edid.segments = segment + 1;\r\nif (((state->edid.data[0x7e] >> 1) + 1) > state->edid.segments) {\r\nv4l2_dbg(1, debug, sd, "%s: request segment %d\n", __func__, state->edid.segments);\r\nadv7511_wr(sd, 0xc9, 0xf);\r\nadv7511_wr(sd, 0xc4, state->edid.segments);\r\nstate->edid.read_retries = EDID_MAX_RETRIES;\r\nqueue_delayed_work(state->work_queue, &state->edid_handler, EDID_DELAY);\r\nreturn false;\r\n}\r\nv4l2_dbg(1, debug, sd, "%s: edid complete with %d segment(s)\n", __func__, state->edid.segments);\r\nstate->edid.complete = true;\r\ned.present = true;\r\ned.segment = 0;\r\nstate->edid_detect_counter++;\r\nv4l2_ctrl_s_ctrl(state->have_edid0_ctrl, state->edid.segments ? 0x1 : 0x0);\r\nv4l2_subdev_notify(sd, ADV7511_EDID_DETECT, (void *)&ed);\r\nreturn ed.present;\r\n}\r\nreturn false;\r\n}\r\nstatic void adv7511_init_setup(struct v4l2_subdev *sd)\r\n{\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstruct adv7511_state_edid *edid = &state->edid;\r\nv4l2_dbg(1, debug, sd, "%s\n", __func__);\r\nadv7511_wr(sd, 0x96, 0xff);\r\nmemset(edid, 0, sizeof(struct adv7511_state_edid));\r\nstate->have_monitor = false;\r\nadv7511_set_isr(sd, false);\r\nadv7511_s_stream(sd, false);\r\nadv7511_s_audio_stream(sd, false);\r\n}\r\nstatic int adv7511_probe(struct i2c_client *client, const struct i2c_device_id *id)\r\n{\r\nstruct adv7511_state *state;\r\nstruct adv7511_platform_data *pdata = client->dev.platform_data;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct v4l2_subdev *sd;\r\nu8 chip_id[2];\r\nint err = -EIO;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nstate = devm_kzalloc(&client->dev, sizeof(struct adv7511_state), GFP_KERNEL);\r\nif (!state)\r\nreturn -ENOMEM;\r\nif (!pdata) {\r\nv4l_err(client, "No platform data!\n");\r\nreturn -ENODEV;\r\n}\r\nmemcpy(&state->pdata, pdata, sizeof(state->pdata));\r\nsd = &state->sd;\r\nv4l2_dbg(1, debug, sd, "detecting adv7511 client on address 0x%x\n",\r\nclient->addr << 1);\r\nv4l2_i2c_subdev_init(sd, client, &adv7511_ops);\r\nhdl = &state->hdl;\r\nv4l2_ctrl_handler_init(hdl, 10);\r\nstate->hdmi_mode_ctrl = v4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\r\nV4L2_CID_DV_TX_MODE, V4L2_DV_TX_MODE_HDMI,\r\n0, V4L2_DV_TX_MODE_DVI_D);\r\nstate->hotplug_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_HOTPLUG, 0, 1, 0, 0);\r\nstate->rx_sense_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_RXSENSE, 0, 1, 0, 0);\r\nstate->have_edid0_ctrl = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_DV_TX_EDID_PRESENT, 0, 1, 0, 0);\r\nstate->rgb_quantization_range_ctrl =\r\nv4l2_ctrl_new_std_menu(hdl, &adv7511_ctrl_ops,\r\nV4L2_CID_DV_TX_RGB_RANGE, V4L2_DV_RGB_RANGE_FULL,\r\n0, V4L2_DV_RGB_RANGE_AUTO);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nerr = hdl->error;\r\ngoto err_hdl;\r\n}\r\nstate->hdmi_mode_ctrl->is_private = true;\r\nstate->hotplug_ctrl->is_private = true;\r\nstate->rx_sense_ctrl->is_private = true;\r\nstate->have_edid0_ctrl->is_private = true;\r\nstate->rgb_quantization_range_ctrl->is_private = true;\r\nstate->pad.flags = MEDIA_PAD_FL_SINK;\r\nerr = media_entity_init(&sd->entity, 1, &state->pad, 0);\r\nif (err)\r\ngoto err_hdl;\r\nstate->i2c_edid_addr = state->pdata.i2c_edid << 1;\r\nstate->i2c_cec_addr = state->pdata.i2c_cec << 1;\r\nstate->chip_revision = adv7511_rd(sd, 0x0);\r\nchip_id[0] = adv7511_rd(sd, 0xf5);\r\nchip_id[1] = adv7511_rd(sd, 0xf6);\r\nif (chip_id[0] != 0x75 || chip_id[1] != 0x11) {\r\nv4l2_err(sd, "chip_id != 0x7511, read 0x%02x%02x\n", chip_id[0], chip_id[1]);\r\nerr = -EIO;\r\ngoto err_entity;\r\n}\r\nstate->i2c_edid = i2c_new_dummy(client->adapter, state->i2c_edid_addr >> 1);\r\nif (state->i2c_edid == NULL) {\r\nv4l2_err(sd, "failed to register edid i2c client\n");\r\nerr = -ENOMEM;\r\ngoto err_entity;\r\n}\r\nadv7511_wr(sd, 0xe2, 0x01);\r\nstate->work_queue = create_singlethread_workqueue(sd->name);\r\nif (state->work_queue == NULL) {\r\nv4l2_err(sd, "could not create workqueue\n");\r\nerr = -ENOMEM;\r\ngoto err_unreg_cec;\r\n}\r\nINIT_DELAYED_WORK(&state->edid_handler, adv7511_edid_handler);\r\nadv7511_init_setup(sd);\r\nadv7511_set_isr(sd, true);\r\nadv7511_check_monitor_present_status(sd);\r\nv4l2_info(sd, "%s found @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nreturn 0;\r\nerr_unreg_cec:\r\ni2c_unregister_device(state->i2c_edid);\r\nerr_entity:\r\nmedia_entity_cleanup(&sd->entity);\r\nerr_hdl:\r\nv4l2_ctrl_handler_free(&state->hdl);\r\nreturn err;\r\n}\r\nstatic int adv7511_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nstruct adv7511_state *state = get_adv7511_state(sd);\r\nstate->chip_revision = -1;\r\nv4l2_dbg(1, debug, sd, "%s removed @ 0x%x (%s)\n", client->name,\r\nclient->addr << 1, client->adapter->name);\r\nadv7511_init_setup(sd);\r\ncancel_delayed_work(&state->edid_handler);\r\ni2c_unregister_device(state->i2c_edid);\r\ndestroy_workqueue(state->work_queue);\r\nv4l2_device_unregister_subdev(sd);\r\nmedia_entity_cleanup(&sd->entity);\r\nv4l2_ctrl_handler_free(sd->ctrl_handler);\r\nreturn 0;\r\n}
