static void lmv_activate_target(struct lmv_obd *lmv,\r\nstruct lmv_tgt_desc *tgt,\r\nint activate)\r\n{\r\nif (tgt->ltd_active == activate)\r\nreturn;\r\ntgt->ltd_active = activate;\r\nlmv->desc.ld_active_tgt_count += (activate ? 1 : -1);\r\n}\r\nstatic int lmv_set_mdc_active(struct lmv_obd *lmv, struct obd_uuid *uuid,\r\nint activate)\r\n{\r\nstruct lmv_tgt_desc *uninitialized_var(tgt);\r\nstruct obd_device *obd;\r\nint i;\r\nint rc = 0;\r\nCDEBUG(D_INFO, "Searching in lmv %p for uuid %s (activate=%d)\n",\r\nlmv, uuid->uuid, activate);\r\nspin_lock(&lmv->lmv_lock);\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL || tgt->ltd_exp == NULL)\r\ncontinue;\r\nCDEBUG(D_INFO, "Target idx %d is %s conn "LPX64"\n", i,\r\ntgt->ltd_uuid.uuid, tgt->ltd_exp->exp_handle.h_cookie);\r\nif (obd_uuid_equals(uuid, &tgt->ltd_uuid))\r\nbreak;\r\n}\r\nif (i == lmv->desc.ld_tgt_count)\r\nGOTO(out_lmv_lock, rc = -EINVAL);\r\nobd = class_exp2obd(tgt->ltd_exp);\r\nif (obd == NULL)\r\nGOTO(out_lmv_lock, rc = -ENOTCONN);\r\nCDEBUG(D_INFO, "Found OBD %s=%s device %d (%p) type %s at LMV idx %d\n",\r\nobd->obd_name, obd->obd_uuid.uuid, obd->obd_minor, obd,\r\nobd->obd_type->typ_name, i);\r\nLASSERT(strcmp(obd->obd_type->typ_name, LUSTRE_MDC_NAME) == 0);\r\nif (tgt->ltd_active == activate) {\r\nCDEBUG(D_INFO, "OBD %p already %sactive!\n", obd,\r\nactivate ? "" : "in");\r\nGOTO(out_lmv_lock, rc);\r\n}\r\nCDEBUG(D_INFO, "Marking OBD %p %sactive\n", obd,\r\nactivate ? "" : "in");\r\nlmv_activate_target(lmv, tgt, activate);\r\nout_lmv_lock:\r\nspin_unlock(&lmv->lmv_lock);\r\nreturn rc;\r\n}\r\nstruct obd_uuid *lmv_get_uuid(struct obd_export *exp)\r\n{\r\nstruct lmv_obd *lmv = &exp->exp_obd->u.lmv;\r\nreturn obd_get_uuid(lmv->tgts[0]->ltd_exp);\r\n}\r\nstatic int lmv_notify(struct obd_device *obd, struct obd_device *watched,\r\nenum obd_notify_event ev, void *data)\r\n{\r\nstruct obd_connect_data *conn_data;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct obd_uuid *uuid;\r\nint rc = 0;\r\nif (strcmp(watched->obd_type->typ_name, LUSTRE_MDC_NAME)) {\r\nCERROR("unexpected notification of %s %s!\n",\r\nwatched->obd_type->typ_name,\r\nwatched->obd_name);\r\nreturn -EINVAL;\r\n}\r\nuuid = &watched->u.cli.cl_target_uuid;\r\nif (ev == OBD_NOTIFY_ACTIVE || ev == OBD_NOTIFY_INACTIVE) {\r\nrc = lmv_set_mdc_active(lmv, uuid,\r\nev == OBD_NOTIFY_ACTIVE);\r\nif (rc) {\r\nCERROR("%sactivation of %s failed: %d\n",\r\nev == OBD_NOTIFY_ACTIVE ? "" : "de",\r\nuuid->uuid, rc);\r\nreturn rc;\r\n}\r\n} else if (ev == OBD_NOTIFY_OCD) {\r\nconn_data = &watched->u.cli.cl_import->imp_connect_data;\r\nobd->obd_self_export->exp_connect_data = *conn_data;\r\n}\r\n#if 0\r\nelse if (ev == OBD_NOTIFY_DISCON) {\r\nfld_client_flush(&lmv->lmv_fld);\r\n}\r\n#endif\r\nif (obd->obd_observer)\r\nrc = obd_notify(obd->obd_observer, watched, ev, data);\r\nreturn rc;\r\n}\r\nstatic int lmv_connect(const struct lu_env *env,\r\nstruct obd_export **exp, struct obd_device *obd,\r\nstruct obd_uuid *cluuid, struct obd_connect_data *data,\r\nvoid *localdata)\r\n{\r\nstruct proc_dir_entry *lmv_proc_dir;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lustre_handle conn = { 0 };\r\nint rc = 0;\r\nlmv->refcount++;\r\nif (lmv->refcount > 1) {\r\n*exp = NULL;\r\nreturn 0;\r\n}\r\nrc = class_connect(&conn, obd, cluuid);\r\nif (rc) {\r\nCERROR("class_connection() returned %d\n", rc);\r\nreturn rc;\r\n}\r\n*exp = class_conn2export(&conn);\r\nclass_export_get(*exp);\r\nlmv->exp = *exp;\r\nlmv->connected = 0;\r\nlmv->cluuid = *cluuid;\r\nif (data)\r\nlmv->conn_data = *data;\r\nif (obd->obd_proc_private != NULL) {\r\nlmv_proc_dir = obd->obd_proc_private;\r\n} else {\r\nlmv_proc_dir = lprocfs_register("target_obds", obd->obd_proc_entry,\r\nNULL, NULL);\r\nif (IS_ERR(lmv_proc_dir)) {\r\nCERROR("could not register /proc/fs/lustre/%s/%s/target_obds.",\r\nobd->obd_type->typ_name, obd->obd_name);\r\nlmv_proc_dir = NULL;\r\n}\r\nobd->obd_proc_private = lmv_proc_dir;\r\n}\r\nif (data->ocd_connect_flags & OBD_CONNECT_REAL)\r\nrc = lmv_check_connect(obd);\r\nif (rc && lmv_proc_dir) {\r\nlprocfs_remove(&lmv_proc_dir);\r\nobd->obd_proc_private = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic void lmv_set_timeouts(struct obd_device *obd)\r\n{\r\nstruct lmv_tgt_desc *tgt;\r\nstruct lmv_obd *lmv;\r\nint i;\r\nlmv = &obd->u.lmv;\r\nif (lmv->server_timeout == 0)\r\nreturn;\r\nif (lmv->connected == 0)\r\nreturn;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL || tgt->ltd_exp == NULL || tgt->ltd_active == 0)\r\ncontinue;\r\nobd_set_info_async(NULL, tgt->ltd_exp, sizeof(KEY_INTERMDS),\r\nKEY_INTERMDS, 0, NULL, NULL);\r\n}\r\n}\r\nstatic int lmv_init_ea_size(struct obd_export *exp, int easize,\r\nint def_easize, int cookiesize)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint i;\r\nint rc = 0;\r\nint change = 0;\r\nif (lmv->max_easize < easize) {\r\nlmv->max_easize = easize;\r\nchange = 1;\r\n}\r\nif (lmv->max_def_easize < def_easize) {\r\nlmv->max_def_easize = def_easize;\r\nchange = 1;\r\n}\r\nif (lmv->max_cookiesize < cookiesize) {\r\nlmv->max_cookiesize = cookiesize;\r\nchange = 1;\r\n}\r\nif (change == 0)\r\nreturn 0;\r\nif (lmv->connected == 0)\r\nreturn 0;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL ||\r\nlmv->tgts[i]->ltd_exp == NULL ||\r\nlmv->tgts[i]->ltd_active == 0) {\r\nCWARN("%s: NULL export for %d\n", obd->obd_name, i);\r\ncontinue;\r\n}\r\nrc = md_init_ea_size(lmv->tgts[i]->ltd_exp, easize, def_easize,\r\ncookiesize);\r\nif (rc) {\r\nCERROR("%s: obd_init_ea_size() failed on MDT target %d:"\r\n" rc = %d.\n", obd->obd_name, i, rc);\r\nbreak;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint lmv_connect_mdc(struct obd_device *obd, struct lmv_tgt_desc *tgt)\r\n{\r\nstruct proc_dir_entry *lmv_proc_dir;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct obd_uuid *cluuid = &lmv->cluuid;\r\nstruct obd_uuid lmv_mdc_uuid = { "LMV_MDC_UUID" };\r\nstruct obd_device *mdc_obd;\r\nstruct obd_export *mdc_exp;\r\nstruct lu_fld_target target;\r\nint rc;\r\nmdc_obd = class_find_client_obd(&tgt->ltd_uuid, LUSTRE_MDC_NAME,\r\n&obd->obd_uuid);\r\nif (!mdc_obd) {\r\nCERROR("target %s not attached\n", tgt->ltd_uuid.uuid);\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_CONFIG, "connect to %s(%s) - %s, %s FOR %s\n",\r\nmdc_obd->obd_name, mdc_obd->obd_uuid.uuid,\r\ntgt->ltd_uuid.uuid, obd->obd_uuid.uuid,\r\ncluuid->uuid);\r\nif (!mdc_obd->obd_set_up) {\r\nCERROR("target %s is not set up\n", tgt->ltd_uuid.uuid);\r\nreturn -EINVAL;\r\n}\r\nrc = obd_connect(NULL, &mdc_exp, mdc_obd, &lmv_mdc_uuid,\r\n&lmv->conn_data, NULL);\r\nif (rc) {\r\nCERROR("target %s connect error %d\n", tgt->ltd_uuid.uuid, rc);\r\nreturn rc;\r\n}\r\nrc = obd_fid_init(mdc_obd, mdc_exp, LUSTRE_SEQ_METADATA);\r\nif (rc)\r\nreturn rc;\r\ntarget.ft_srv = NULL;\r\ntarget.ft_exp = mdc_exp;\r\ntarget.ft_idx = tgt->ltd_idx;\r\nfld_client_add_target(&lmv->lmv_fld, &target);\r\nrc = obd_register_observer(mdc_obd, obd);\r\nif (rc) {\r\nobd_disconnect(mdc_exp);\r\nCERROR("target %s register_observer error %d\n",\r\ntgt->ltd_uuid.uuid, rc);\r\nreturn rc;\r\n}\r\nif (obd->obd_observer) {\r\nrc = obd_notify(obd->obd_observer, mdc_exp->exp_obd,\r\nOBD_NOTIFY_ACTIVE,\r\n(void *)(tgt - lmv->tgts[0]));\r\nif (rc) {\r\nobd_disconnect(mdc_exp);\r\nreturn rc;\r\n}\r\n}\r\ntgt->ltd_active = 1;\r\ntgt->ltd_exp = mdc_exp;\r\nlmv->desc.ld_active_tgt_count++;\r\nmd_init_ea_size(tgt->ltd_exp, lmv->max_easize,\r\nlmv->max_def_easize, lmv->max_cookiesize);\r\nCDEBUG(D_CONFIG, "Connected to %s(%s) successfully (%d)\n",\r\nmdc_obd->obd_name, mdc_obd->obd_uuid.uuid,\r\natomic_read(&obd->obd_refcount));\r\nlmv_proc_dir = obd->obd_proc_private;\r\nif (lmv_proc_dir) {\r\nstruct proc_dir_entry *mdc_symlink;\r\nLASSERT(mdc_obd->obd_type != NULL);\r\nLASSERT(mdc_obd->obd_type->typ_name != NULL);\r\nmdc_symlink = lprocfs_add_symlink(mdc_obd->obd_name,\r\nlmv_proc_dir,\r\n"../../../%s/%s",\r\nmdc_obd->obd_type->typ_name,\r\nmdc_obd->obd_name);\r\nif (mdc_symlink == NULL) {\r\nCERROR("Could not register LMV target "\r\n"/proc/fs/lustre/%s/%s/target_obds/%s.",\r\nobd->obd_type->typ_name, obd->obd_name,\r\nmdc_obd->obd_name);\r\nlprocfs_remove(&lmv_proc_dir);\r\nobd->obd_proc_private = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void lmv_del_target(struct lmv_obd *lmv, int index)\r\n{\r\nif (lmv->tgts[index] == NULL)\r\nreturn;\r\nOBD_FREE_PTR(lmv->tgts[index]);\r\nlmv->tgts[index] = NULL;\r\nreturn;\r\n}\r\nstatic int lmv_add_target(struct obd_device *obd, struct obd_uuid *uuidp,\r\n__u32 index, int gen)\r\n{\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc = 0;\r\nCDEBUG(D_CONFIG, "Target uuid: %s. index %d\n", uuidp->uuid, index);\r\nlmv_init_lock(lmv);\r\nif (lmv->desc.ld_tgt_count == 0) {\r\nstruct obd_device *mdc_obd;\r\nmdc_obd = class_find_client_obd(uuidp, LUSTRE_MDC_NAME,\r\n&obd->obd_uuid);\r\nif (!mdc_obd) {\r\nlmv_init_unlock(lmv);\r\nCERROR("%s: Target %s not attached: rc = %d\n",\r\nobd->obd_name, uuidp->uuid, -EINVAL);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif ((index < lmv->tgts_size) && (lmv->tgts[index] != NULL)) {\r\ntgt = lmv->tgts[index];\r\nCERROR("%s: UUID %s already assigned at LOV target index %d:"\r\n" rc = %d\n", obd->obd_name,\r\nobd_uuid2str(&tgt->ltd_uuid), index, -EEXIST);\r\nlmv_init_unlock(lmv);\r\nreturn -EEXIST;\r\n}\r\nif (index >= lmv->tgts_size) {\r\nstruct lmv_tgt_desc **newtgts, **old = NULL;\r\n__u32 newsize = 1;\r\n__u32 oldsize = 0;\r\nwhile (newsize < index + 1)\r\nnewsize = newsize << 1;\r\nOBD_ALLOC(newtgts, sizeof(*newtgts) * newsize);\r\nif (newtgts == NULL) {\r\nlmv_init_unlock(lmv);\r\nreturn -ENOMEM;\r\n}\r\nif (lmv->tgts_size) {\r\nmemcpy(newtgts, lmv->tgts,\r\nsizeof(*newtgts) * lmv->tgts_size);\r\nold = lmv->tgts;\r\noldsize = lmv->tgts_size;\r\n}\r\nlmv->tgts = newtgts;\r\nlmv->tgts_size = newsize;\r\nsmp_rmb();\r\nif (old)\r\nOBD_FREE(old, sizeof(*old) * oldsize);\r\nCDEBUG(D_CONFIG, "tgts: %p size: %d\n", lmv->tgts,\r\nlmv->tgts_size);\r\n}\r\nOBD_ALLOC_PTR(tgt);\r\nif (!tgt) {\r\nlmv_init_unlock(lmv);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&tgt->ltd_fid_mutex);\r\ntgt->ltd_idx = index;\r\ntgt->ltd_uuid = *uuidp;\r\ntgt->ltd_active = 0;\r\nlmv->tgts[index] = tgt;\r\nif (index >= lmv->desc.ld_tgt_count)\r\nlmv->desc.ld_tgt_count = index + 1;\r\nif (lmv->connected) {\r\nrc = lmv_connect_mdc(obd, tgt);\r\nif (rc) {\r\nspin_lock(&lmv->lmv_lock);\r\nlmv->desc.ld_tgt_count--;\r\nmemset(tgt, 0, sizeof(*tgt));\r\nspin_unlock(&lmv->lmv_lock);\r\n} else {\r\nint easize = sizeof(struct lmv_stripe_md) +\r\nlmv->desc.ld_tgt_count *\r\nsizeof(struct lu_fid);\r\nlmv_init_ea_size(obd->obd_self_export, easize, 0, 0);\r\n}\r\n}\r\nlmv_init_unlock(lmv);\r\nreturn rc;\r\n}\r\nint lmv_check_connect(struct obd_device *obd)\r\n{\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint i;\r\nint rc;\r\nint easize;\r\nif (lmv->connected)\r\nreturn 0;\r\nlmv_init_lock(lmv);\r\nif (lmv->connected) {\r\nlmv_init_unlock(lmv);\r\nreturn 0;\r\n}\r\nif (lmv->desc.ld_tgt_count == 0) {\r\nlmv_init_unlock(lmv);\r\nCERROR("%s: no targets configured.\n", obd->obd_name);\r\nreturn -EINVAL;\r\n}\r\nCDEBUG(D_CONFIG, "Time to connect %s to %s\n",\r\nlmv->cluuid.uuid, obd->obd_name);\r\nLASSERT(lmv->tgts != NULL);\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL)\r\ncontinue;\r\nrc = lmv_connect_mdc(obd, tgt);\r\nif (rc)\r\nGOTO(out_disc, rc);\r\n}\r\nlmv_set_timeouts(obd);\r\nclass_export_put(lmv->exp);\r\nlmv->connected = 1;\r\neasize = lmv_get_easize(lmv);\r\nlmv_init_ea_size(obd->obd_self_export, easize, 0, 0);\r\nlmv_init_unlock(lmv);\r\nreturn 0;\r\nout_disc:\r\nwhile (i-- > 0) {\r\nint rc2;\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL)\r\ncontinue;\r\ntgt->ltd_active = 0;\r\nif (tgt->ltd_exp) {\r\n--lmv->desc.ld_active_tgt_count;\r\nrc2 = obd_disconnect(tgt->ltd_exp);\r\nif (rc2) {\r\nCERROR("LMV target %s disconnect on "\r\n"MDC idx %d: error %d\n",\r\ntgt->ltd_uuid.uuid, i, rc2);\r\n}\r\n}\r\n}\r\nclass_disconnect(lmv->exp);\r\nlmv_init_unlock(lmv);\r\nreturn rc;\r\n}\r\nstatic int lmv_disconnect_mdc(struct obd_device *obd, struct lmv_tgt_desc *tgt)\r\n{\r\nstruct proc_dir_entry *lmv_proc_dir;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct obd_device *mdc_obd;\r\nint rc;\r\nLASSERT(tgt != NULL);\r\nLASSERT(obd != NULL);\r\nmdc_obd = class_exp2obd(tgt->ltd_exp);\r\nif (mdc_obd) {\r\nmdc_obd->obd_force = obd->obd_force;\r\nmdc_obd->obd_fail = obd->obd_fail;\r\nmdc_obd->obd_no_recov = obd->obd_no_recov;\r\n}\r\nlmv_proc_dir = obd->obd_proc_private;\r\nif (lmv_proc_dir)\r\nlprocfs_remove_proc_entry(mdc_obd->obd_name, lmv_proc_dir);\r\nrc = obd_fid_fini(tgt->ltd_exp->exp_obd);\r\nif (rc)\r\nCERROR("Can't finanize fids factory\n");\r\nCDEBUG(D_INFO, "Disconnected from %s(%s) successfully\n",\r\ntgt->ltd_exp->exp_obd->obd_name,\r\ntgt->ltd_exp->exp_obd->obd_uuid.uuid);\r\nobd_register_observer(tgt->ltd_exp->exp_obd, NULL);\r\nrc = obd_disconnect(tgt->ltd_exp);\r\nif (rc) {\r\nif (tgt->ltd_active) {\r\nCERROR("Target %s disconnect error %d\n",\r\ntgt->ltd_uuid.uuid, rc);\r\n}\r\n}\r\nlmv_activate_target(lmv, tgt, 0);\r\ntgt->ltd_exp = NULL;\r\nreturn 0;\r\n}\r\nstatic int lmv_disconnect(struct obd_export *exp)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint rc;\r\nint i;\r\nif (!lmv->tgts)\r\ngoto out_local;\r\nlmv->refcount--;\r\nif (lmv->refcount != 0)\r\ngoto out_local;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL || lmv->tgts[i]->ltd_exp == NULL)\r\ncontinue;\r\nlmv_disconnect_mdc(obd, lmv->tgts[i]);\r\n}\r\nif (obd->obd_proc_private)\r\nlprocfs_remove((struct proc_dir_entry **)&obd->obd_proc_private);\r\nelse\r\nCERROR("/proc/fs/lustre/%s/%s/target_obds missing\n",\r\nobd->obd_type->typ_name, obd->obd_name);\r\nout_local:\r\nif (!lmv->connected)\r\nclass_export_put(exp);\r\nrc = class_disconnect(exp);\r\nif (lmv->refcount == 0)\r\nlmv->connected = 0;\r\nreturn rc;\r\n}\r\nstatic int lmv_fid2path(struct obd_export *exp, int len, void *karg, void *uarg)\r\n{\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obddev->u.lmv;\r\nstruct getinfo_fid2path *gf;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct getinfo_fid2path *remote_gf = NULL;\r\nint remote_gf_size = 0;\r\nint rc;\r\ngf = (struct getinfo_fid2path *)karg;\r\ntgt = lmv_find_target(lmv, &gf->gf_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrepeat_fid2path:\r\nrc = obd_iocontrol(OBD_IOC_FID2PATH, tgt->ltd_exp, len, gf, uarg);\r\nif (rc != 0 && rc != -EREMOTE)\r\nGOTO(out_fid2path, rc);\r\nif (remote_gf != NULL) {\r\nstruct getinfo_fid2path *ori_gf;\r\nchar *ptr;\r\nori_gf = (struct getinfo_fid2path *)karg;\r\nif (strlen(ori_gf->gf_path) +\r\nstrlen(gf->gf_path) > ori_gf->gf_pathlen)\r\nGOTO(out_fid2path, rc = -EOVERFLOW);\r\nptr = ori_gf->gf_path;\r\nmemmove(ptr + strlen(gf->gf_path) + 1, ptr,\r\nstrlen(ori_gf->gf_path));\r\nstrncpy(ptr, gf->gf_path, strlen(gf->gf_path));\r\nptr += strlen(gf->gf_path);\r\n*ptr = '/';\r\n}\r\nCDEBUG(D_INFO, "%s: get path %s "DFID" rec: "LPU64" ln: %u\n",\r\ntgt->ltd_exp->exp_obd->obd_name,\r\ngf->gf_path, PFID(&gf->gf_fid), gf->gf_recno,\r\ngf->gf_linkno);\r\nif (rc == 0)\r\nGOTO(out_fid2path, rc);\r\nif (remote_gf == NULL) {\r\nremote_gf_size = sizeof(*remote_gf) + PATH_MAX;\r\nOBD_ALLOC(remote_gf, remote_gf_size);\r\nif (remote_gf == NULL)\r\nGOTO(out_fid2path, rc = -ENOMEM);\r\nremote_gf->gf_pathlen = PATH_MAX;\r\n}\r\nif (!fid_is_sane(&gf->gf_fid)) {\r\nCERROR("%s: invalid FID "DFID": rc = %d\n",\r\ntgt->ltd_exp->exp_obd->obd_name,\r\nPFID(&gf->gf_fid), -EINVAL);\r\nGOTO(out_fid2path, rc = -EINVAL);\r\n}\r\ntgt = lmv_find_target(lmv, &gf->gf_fid);\r\nif (IS_ERR(tgt))\r\nGOTO(out_fid2path, rc = -EINVAL);\r\nremote_gf->gf_fid = gf->gf_fid;\r\nremote_gf->gf_recno = -1;\r\nremote_gf->gf_linkno = -1;\r\nmemset(remote_gf->gf_path, 0, remote_gf->gf_pathlen);\r\ngf = remote_gf;\r\ngoto repeat_fid2path;\r\nout_fid2path:\r\nif (remote_gf != NULL)\r\nOBD_FREE(remote_gf, remote_gf_size);\r\nreturn rc;\r\n}\r\nstatic int lmv_hsm_req_count(struct lmv_obd *lmv,\r\nconst struct hsm_user_request *hur,\r\nconst struct lmv_tgt_desc *tgt_mds)\r\n{\r\nint i, nr = 0;\r\nstruct lmv_tgt_desc *curr_tgt;\r\nfor (i = 0; i < hur->hur_request.hr_itemcount; i++) {\r\ncurr_tgt = lmv_find_target(lmv, &hur->hur_user_item[i].hui_fid);\r\nif (obd_uuid_equals(&curr_tgt->ltd_uuid, &tgt_mds->ltd_uuid))\r\nnr++;\r\n}\r\nreturn nr;\r\n}\r\nstatic void lmv_hsm_req_build(struct lmv_obd *lmv,\r\nstruct hsm_user_request *hur_in,\r\nconst struct lmv_tgt_desc *tgt_mds,\r\nstruct hsm_user_request *hur_out)\r\n{\r\nint i, nr_out;\r\nstruct lmv_tgt_desc *curr_tgt;\r\nhur_out->hur_request = hur_in->hur_request;\r\nnr_out = 0;\r\nfor (i = 0; i < hur_in->hur_request.hr_itemcount; i++) {\r\ncurr_tgt = lmv_find_target(lmv,\r\n&hur_in->hur_user_item[i].hui_fid);\r\nif (obd_uuid_equals(&curr_tgt->ltd_uuid, &tgt_mds->ltd_uuid)) {\r\nhur_out->hur_user_item[nr_out] =\r\nhur_in->hur_user_item[i];\r\nnr_out++;\r\n}\r\n}\r\nhur_out->hur_request.hr_itemcount = nr_out;\r\nmemcpy(hur_data(hur_out), hur_data(hur_in),\r\nhur_in->hur_request.hr_data_len);\r\n}\r\nstatic int lmv_hsm_ct_unregister(struct lmv_obd *lmv, unsigned int cmd, int len,\r\nstruct lustre_kernelcomm *lk, void *uarg)\r\n{\r\nint i, rc = 0;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nobd_iocontrol(cmd, lmv->tgts[i]->ltd_exp, len, lk, uarg);\r\n}\r\nrc = libcfs_kkuc_group_rem(lk->lk_uid, lk->lk_group);\r\nreturn rc;\r\n}\r\nstatic int lmv_hsm_ct_register(struct lmv_obd *lmv, unsigned int cmd, int len,\r\nstruct lustre_kernelcomm *lk, void *uarg)\r\n{\r\nstruct file *filp;\r\nint i, j, err;\r\nint rc = 0;\r\nbool any_set = false;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nerr = obd_iocontrol(cmd, lmv->tgts[i]->ltd_exp,\r\nlen, lk, uarg);\r\nif (err) {\r\nif (lmv->tgts[i]->ltd_active) {\r\nCERROR("error: iocontrol MDC %s on MDT"\r\n"idx %d cmd %x: err = %d\n",\r\nlmv->tgts[i]->ltd_uuid.uuid,\r\ni, cmd, err);\r\nrc = err;\r\nlk->lk_flags |= LK_FLG_STOP;\r\nfor (j = 0; j < i; j++)\r\nobd_iocontrol(cmd,\r\nlmv->tgts[j]->ltd_exp,\r\nlen, lk, uarg);\r\nreturn rc;\r\n}\r\n} else {\r\nany_set = true;\r\n}\r\n}\r\nif (!any_set)\r\nreturn -ENOTCONN;\r\nfilp = fget(lk->lk_wfd);\r\nif (filp == NULL) {\r\nreturn -EBADF;\r\n}\r\nrc = libcfs_kkuc_group_add(filp, lk->lk_uid, lk->lk_group, lk->lk_data);\r\nif (rc != 0 && filp != NULL)\r\nfput(filp);\r\nreturn rc;\r\n}\r\nstatic int lmv_iocontrol(unsigned int cmd, struct obd_export *exp,\r\nint len, void *karg, void *uarg)\r\n{\r\nstruct obd_device *obddev = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obddev->u.lmv;\r\nint i = 0;\r\nint rc = 0;\r\nint set = 0;\r\nint count = lmv->desc.ld_tgt_count;\r\nif (count == 0)\r\nreturn -ENOTTY;\r\nswitch (cmd) {\r\ncase IOC_OBD_STATFS: {\r\nstruct obd_ioctl_data *data = karg;\r\nstruct obd_device *mdc_obd;\r\nstruct obd_statfs stat_buf = {0};\r\n__u32 index;\r\nmemcpy(&index, data->ioc_inlbuf2, sizeof(__u32));\r\nif ((index >= count))\r\nreturn -ENODEV;\r\nif (lmv->tgts[index] == NULL ||\r\nlmv->tgts[index]->ltd_active == 0)\r\nreturn -ENODATA;\r\nmdc_obd = class_exp2obd(lmv->tgts[index]->ltd_exp);\r\nif (!mdc_obd)\r\nreturn -EINVAL;\r\nif (copy_to_user(data->ioc_pbuf2, obd2cli_tgt(mdc_obd),\r\nmin((int) data->ioc_plen2,\r\n(int) sizeof(struct obd_uuid))))\r\nreturn -EFAULT;\r\nrc = obd_statfs(NULL, lmv->tgts[index]->ltd_exp, &stat_buf,\r\ncfs_time_shift_64(-OBD_STATFS_CACHE_SECONDS),\r\n0);\r\nif (rc)\r\nreturn rc;\r\nif (copy_to_user(data->ioc_pbuf1, &stat_buf,\r\nmin((int) data->ioc_plen1,\r\n(int) sizeof(stat_buf))))\r\nreturn -EFAULT;\r\nbreak;\r\n}\r\ncase OBD_IOC_QUOTACTL: {\r\nstruct if_quotactl *qctl = karg;\r\nstruct lmv_tgt_desc *tgt = NULL;\r\nstruct obd_quotactl *oqctl;\r\nif (qctl->qc_valid == QC_MDTIDX) {\r\nif (qctl->qc_idx < 0 || count <= qctl->qc_idx)\r\nreturn -EINVAL;\r\ntgt = lmv->tgts[qctl->qc_idx];\r\nif (tgt == NULL || tgt->ltd_exp == NULL)\r\nreturn -EINVAL;\r\n} else if (qctl->qc_valid == QC_UUID) {\r\nfor (i = 0; i < count; i++) {\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL)\r\ncontinue;\r\nif (!obd_uuid_equals(&tgt->ltd_uuid,\r\n&qctl->obd_uuid))\r\ncontinue;\r\nif (tgt->ltd_exp == NULL)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nif (i >= count)\r\nreturn -EAGAIN;\r\nLASSERT(tgt && tgt->ltd_exp);\r\nOBD_ALLOC_PTR(oqctl);\r\nif (!oqctl)\r\nreturn -ENOMEM;\r\nQCTL_COPY(oqctl, qctl);\r\nrc = obd_quotactl(tgt->ltd_exp, oqctl);\r\nif (rc == 0) {\r\nQCTL_COPY(qctl, oqctl);\r\nqctl->qc_valid = QC_MDTIDX;\r\nqctl->obd_uuid = tgt->ltd_uuid;\r\n}\r\nOBD_FREE_PTR(oqctl);\r\nbreak;\r\n}\r\ncase OBD_IOC_CHANGELOG_SEND:\r\ncase OBD_IOC_CHANGELOG_CLEAR: {\r\nstruct ioc_changelog *icc = karg;\r\nif (icc->icc_mdtindex >= count)\r\nreturn -ENODEV;\r\nif (lmv->tgts[icc->icc_mdtindex] == NULL ||\r\nlmv->tgts[icc->icc_mdtindex]->ltd_exp == NULL ||\r\nlmv->tgts[icc->icc_mdtindex]->ltd_active == 0)\r\nreturn -ENODEV;\r\nrc = obd_iocontrol(cmd, lmv->tgts[icc->icc_mdtindex]->ltd_exp,\r\nsizeof(*icc), icc, NULL);\r\nbreak;\r\n}\r\ncase LL_IOC_GET_CONNECT_FLAGS: {\r\nif (lmv->tgts[0] == NULL)\r\nreturn -ENODATA;\r\nrc = obd_iocontrol(cmd, lmv->tgts[0]->ltd_exp, len, karg, uarg);\r\nbreak;\r\n}\r\ncase OBD_IOC_FID2PATH: {\r\nrc = lmv_fid2path(exp, len, karg, uarg);\r\nbreak;\r\n}\r\ncase LL_IOC_HSM_STATE_GET:\r\ncase LL_IOC_HSM_STATE_SET:\r\ncase LL_IOC_HSM_ACTION: {\r\nstruct md_op_data *op_data = karg;\r\nstruct lmv_tgt_desc *tgt;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nif (tgt->ltd_exp == NULL)\r\nreturn -EINVAL;\r\nrc = obd_iocontrol(cmd, tgt->ltd_exp, len, karg, uarg);\r\nbreak;\r\n}\r\ncase LL_IOC_HSM_PROGRESS: {\r\nconst struct hsm_progress_kernel *hpk = karg;\r\nstruct lmv_tgt_desc *tgt;\r\ntgt = lmv_find_target(lmv, &hpk->hpk_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = obd_iocontrol(cmd, tgt->ltd_exp, len, karg, uarg);\r\nbreak;\r\n}\r\ncase LL_IOC_HSM_REQUEST: {\r\nstruct hsm_user_request *hur = karg;\r\nstruct lmv_tgt_desc *tgt;\r\nunsigned int reqcount = hur->hur_request.hr_itemcount;\r\nif (reqcount == 0)\r\nreturn 0;\r\nif (reqcount == 1 || count == 1) {\r\ntgt = lmv_find_target(lmv,\r\n&hur->hur_user_item[0].hui_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = obd_iocontrol(cmd, tgt->ltd_exp, len, karg, uarg);\r\n} else {\r\nfor (i = 0; i < count; i++) {\r\nunsigned int nr, reqlen;\r\nint rc1;\r\nstruct hsm_user_request *req;\r\nnr = lmv_hsm_req_count(lmv, hur, lmv->tgts[i]);\r\nif (nr == 0)\r\ncontinue;\r\nreqlen = offsetof(typeof(*hur),\r\nhur_user_item[nr])\r\n+ hur->hur_request.hr_data_len;\r\nOBD_ALLOC_LARGE(req, reqlen);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nlmv_hsm_req_build(lmv, hur, lmv->tgts[i], req);\r\nrc1 = obd_iocontrol(cmd, lmv->tgts[i]->ltd_exp,\r\nreqlen, req, uarg);\r\nif (rc1 != 0 && rc == 0)\r\nrc = rc1;\r\nOBD_FREE_LARGE(req, reqlen);\r\n}\r\n}\r\nbreak;\r\n}\r\ncase LL_IOC_LOV_SWAP_LAYOUTS: {\r\nstruct md_op_data *op_data = karg;\r\nstruct lmv_tgt_desc *tgt1, *tgt2;\r\ntgt1 = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt1))\r\nreturn PTR_ERR(tgt1);\r\ntgt2 = lmv_find_target(lmv, &op_data->op_fid2);\r\nif (IS_ERR(tgt2))\r\nreturn PTR_ERR(tgt2);\r\nif ((tgt1->ltd_exp == NULL) || (tgt2->ltd_exp == NULL))\r\nreturn -EINVAL;\r\nif (tgt1->ltd_idx != tgt2->ltd_idx)\r\nreturn -EPERM;\r\nrc = obd_iocontrol(cmd, tgt1->ltd_exp, len, karg, uarg);\r\nbreak;\r\n}\r\ncase LL_IOC_HSM_CT_START: {\r\nstruct lustre_kernelcomm *lk = karg;\r\nif (lk->lk_flags & LK_FLG_STOP)\r\nrc = lmv_hsm_ct_unregister(lmv, cmd, len, lk, uarg);\r\nelse\r\nrc = lmv_hsm_ct_register(lmv, cmd, len, lk, uarg);\r\nbreak;\r\n}\r\ndefault:\r\nfor (i = 0; i < count; i++) {\r\nstruct obd_device *mdc_obd;\r\nint err;\r\nif (lmv->tgts[i] == NULL ||\r\nlmv->tgts[i]->ltd_exp == NULL)\r\ncontinue;\r\nmdc_obd = class_exp2obd(lmv->tgts[i]->ltd_exp);\r\nmdc_obd->obd_force = obddev->obd_force;\r\nerr = obd_iocontrol(cmd, lmv->tgts[i]->ltd_exp, len,\r\nkarg, uarg);\r\nif (err == -ENODATA && cmd == OBD_IOC_POLL_QUOTACHECK) {\r\nreturn err;\r\n} else if (err) {\r\nif (lmv->tgts[i]->ltd_active) {\r\nCERROR("error: iocontrol MDC %s on MDT"\r\n"idx %d cmd %x: err = %d\n",\r\nlmv->tgts[i]->ltd_uuid.uuid,\r\ni, cmd, err);\r\nif (!rc)\r\nrc = err;\r\n}\r\n} else\r\nset = 1;\r\n}\r\nif (!set && !rc)\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_placement_policy(struct obd_device *obd,\r\nstruct md_op_data *op_data,\r\nmdsno_t *mds)\r\n{\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nLASSERT(mds != NULL);\r\nif (lmv->desc.ld_tgt_count == 1) {\r\n*mds = 0;\r\nreturn 0;\r\n}\r\nif (op_data->op_cli_flags & CLI_SET_MEA) {\r\nstruct lmv_user_md *lum;\r\nlum = (struct lmv_user_md *)op_data->op_data;\r\nif (lum->lum_type == LMV_STRIPE_TYPE &&\r\nlum->lum_stripe_offset != -1) {\r\nif (lum->lum_stripe_offset >= lmv->desc.ld_tgt_count) {\r\nCERROR("%s: Stripe_offset %d > MDT count %d:"\r\n" rc = %d\n", obd->obd_name,\r\nlum->lum_stripe_offset,\r\nlmv->desc.ld_tgt_count, -ERANGE);\r\nreturn -ERANGE;\r\n}\r\n*mds = lum->lum_stripe_offset;\r\nreturn 0;\r\n}\r\n}\r\n*mds = op_data->op_mds;\r\nreturn 0;\r\n}\r\nint __lmv_fid_alloc(struct lmv_obd *lmv, struct lu_fid *fid,\r\nmdsno_t mds)\r\n{\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\ntgt = lmv_get_target(lmv, mds);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nmutex_lock(&tgt->ltd_fid_mutex);\r\nif (tgt->ltd_active == 0 || tgt->ltd_exp == NULL)\r\nGOTO(out, rc = -ENODEV);\r\nrc = obd_fid_alloc(tgt->ltd_exp, fid, NULL);\r\nif (rc > 0) {\r\nLASSERT(fid_is_sane(fid));\r\nrc = 0;\r\n}\r\nout:\r\nmutex_unlock(&tgt->ltd_fid_mutex);\r\nreturn rc;\r\n}\r\nint lmv_fid_alloc(struct obd_export *exp, struct lu_fid *fid,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nmdsno_t mds = 0;\r\nint rc;\r\nLASSERT(op_data != NULL);\r\nLASSERT(fid != NULL);\r\nrc = lmv_placement_policy(obd, op_data, &mds);\r\nif (rc) {\r\nCERROR("Can't get target for allocating fid, "\r\n"rc %d\n", rc);\r\nreturn rc;\r\n}\r\nrc = __lmv_fid_alloc(lmv, fid, mds);\r\nif (rc) {\r\nCERROR("Can't alloc new fid, rc %d\n", rc);\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lprocfs_static_vars lvars;\r\nstruct lmv_desc *desc;\r\nint rc;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) < 1) {\r\nCERROR("LMV setup requires a descriptor\n");\r\nreturn -EINVAL;\r\n}\r\ndesc = (struct lmv_desc *)lustre_cfg_buf(lcfg, 1);\r\nif (sizeof(*desc) > LUSTRE_CFG_BUFLEN(lcfg, 1)) {\r\nCERROR("Lmv descriptor size wrong: %d > %d\n",\r\n(int)sizeof(*desc), LUSTRE_CFG_BUFLEN(lcfg, 1));\r\nreturn -EINVAL;\r\n}\r\nOBD_ALLOC(lmv->tgts, sizeof(*lmv->tgts) * 32);\r\nif (lmv->tgts == NULL)\r\nreturn -ENOMEM;\r\nlmv->tgts_size = 32;\r\nobd_str2uuid(&lmv->desc.ld_uuid, desc->ld_uuid.uuid);\r\nlmv->desc.ld_tgt_count = 0;\r\nlmv->desc.ld_active_tgt_count = 0;\r\nlmv->max_cookiesize = 0;\r\nlmv->max_def_easize = 0;\r\nlmv->max_easize = 0;\r\nlmv->lmv_placement = PLACEMENT_CHAR_POLICY;\r\nspin_lock_init(&lmv->lmv_lock);\r\nmutex_init(&lmv->init_mutex);\r\nlprocfs_lmv_init_vars(&lvars);\r\nlprocfs_obd_setup(obd, lvars.obd_vars);\r\n#ifdef LPROCFS\r\n{\r\nrc = lprocfs_seq_create(obd->obd_proc_entry, "target_obd",\r\n0444, &lmv_proc_target_fops, obd);\r\nif (rc)\r\nCWARN("%s: error adding LMV target_obd file: rc = %d\n",\r\nobd->obd_name, rc);\r\n}\r\n#endif\r\nrc = fld_client_init(&lmv->lmv_fld, obd->obd_name,\r\nLUSTRE_CLI_FLD_HASH_DHT);\r\nif (rc) {\r\nCERROR("Can't init FLD, err %d\n", rc);\r\nGOTO(out, rc);\r\n}\r\nreturn 0;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int lmv_cleanup(struct obd_device *obd)\r\n{\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nfld_client_fini(&lmv->lmv_fld);\r\nif (lmv->tgts != NULL) {\r\nint i;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL)\r\ncontinue;\r\nlmv_del_target(lmv, i);\r\n}\r\nOBD_FREE(lmv->tgts, sizeof(*lmv->tgts) * lmv->tgts_size);\r\nlmv->tgts_size = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lmv_process_config(struct obd_device *obd, obd_count len, void *buf)\r\n{\r\nstruct lustre_cfg *lcfg = buf;\r\nstruct obd_uuid obd_uuid;\r\nint gen;\r\n__u32 index;\r\nint rc;\r\nswitch (lcfg->lcfg_command) {\r\ncase LCFG_ADD_MDC:\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) > sizeof(obd_uuid.uuid))\r\nGOTO(out, rc = -EINVAL);\r\nobd_str2uuid(&obd_uuid, lustre_cfg_buf(lcfg, 1));\r\nif (sscanf(lustre_cfg_buf(lcfg, 2), "%d", &index) != 1)\r\nGOTO(out, rc = -EINVAL);\r\nif (sscanf(lustre_cfg_buf(lcfg, 3), "%d", &gen) != 1)\r\nGOTO(out, rc = -EINVAL);\r\nrc = lmv_add_target(obd, &obd_uuid, index, gen);\r\nGOTO(out, rc);\r\ndefault:\r\nCERROR("Unknown command: %d\n", lcfg->lcfg_command);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int lmv_statfs(const struct lu_env *env, struct obd_export *exp,\r\nstruct obd_statfs *osfs, __u64 max_age, __u32 flags)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct obd_statfs *temp;\r\nint rc = 0;\r\nint i;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nOBD_ALLOC(temp, sizeof(*temp));\r\nif (temp == NULL)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL || lmv->tgts[i]->ltd_exp == NULL)\r\ncontinue;\r\nrc = obd_statfs(env, lmv->tgts[i]->ltd_exp, temp,\r\nmax_age, flags);\r\nif (rc) {\r\nCERROR("can't stat MDS #%d (%s), error %d\n", i,\r\nlmv->tgts[i]->ltd_exp->exp_obd->obd_name,\r\nrc);\r\nGOTO(out_free_temp, rc);\r\n}\r\nif (i == 0) {\r\n*osfs = *temp;\r\nif (flags & OBD_STATFS_FOR_MDT0)\r\nGOTO(out_free_temp, rc);\r\n} else {\r\nosfs->os_bavail += temp->os_bavail;\r\nosfs->os_blocks += temp->os_blocks;\r\nosfs->os_ffree += temp->os_ffree;\r\nosfs->os_files += temp->os_files;\r\n}\r\n}\r\nout_free_temp:\r\nOBD_FREE(temp, sizeof(*temp));\r\nreturn rc;\r\n}\r\nstatic int lmv_getstatus(struct obd_export *exp,\r\nstruct lu_fid *fid,\r\nstruct obd_capa **pc)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nrc = md_getstatus(lmv->tgts[0]->ltd_exp, fid, pc);\r\nreturn rc;\r\n}\r\nstatic int lmv_getxattr(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, obd_valid valid, const char *name,\r\nconst char *input, int input_size, int output_size,\r\nint flags, struct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_getxattr(tgt->ltd_exp, fid, oc, valid, name, input,\r\ninput_size, output_size, flags, request);\r\nreturn rc;\r\n}\r\nstatic int lmv_setxattr(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, obd_valid valid, const char *name,\r\nconst char *input, int input_size, int output_size,\r\nint flags, __u32 suppgid,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_setxattr(tgt->ltd_exp, fid, oc, valid, name, input,\r\ninput_size, output_size, flags, suppgid,\r\nrequest);\r\nreturn rc;\r\n}\r\nstatic int lmv_getattr(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nif (op_data->op_flags & MF_GET_MDT_IDX) {\r\nop_data->op_mds = tgt->ltd_idx;\r\nreturn 0;\r\n}\r\nrc = md_getattr(tgt->ltd_exp, op_data, request);\r\nreturn rc;\r\n}\r\nstatic int lmv_null_inode(struct obd_export *exp, const struct lu_fid *fid)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint i;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INODE, "CBDATA for "DFID"\n", PFID(fid));\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL || lmv->tgts[i]->ltd_exp == NULL)\r\ncontinue;\r\nmd_null_inode(lmv->tgts[i]->ltd_exp, fid);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lmv_find_cbdata(struct obd_export *exp, const struct lu_fid *fid,\r\nldlm_iterator_t it, void *data)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint i;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INODE, "CBDATA for "DFID"\n", PFID(fid));\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL || lmv->tgts[i]->ltd_exp == NULL)\r\ncontinue;\r\nrc = md_find_cbdata(lmv->tgts[i]->ltd_exp, fid, it, data);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_close(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct md_open_data *mod, struct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nCDEBUG(D_INODE, "CLOSE "DFID"\n", PFID(&op_data->op_fid1));\r\nrc = md_close(tgt->ltd_exp, op_data, mod, request);\r\nreturn rc;\r\n}\r\nstruct lmv_tgt_desc\r\n*lmv_locate_mds(struct lmv_obd *lmv, struct md_op_data *op_data,\r\nstruct lu_fid *fid)\r\n{\r\nstruct lmv_tgt_desc *tgt;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn tgt;\r\nop_data->op_mds = tgt->ltd_idx;\r\nreturn tgt;\r\n}\r\nint lmv_create(struct obd_export *exp, struct md_op_data *op_data,\r\nconst void *data, int datalen, int mode, __u32 uid,\r\n__u32 gid, cfs_cap_t cap_effective, __u64 rdev,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nif (!lmv->desc.ld_active_tgt_count)\r\nreturn -EIO;\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = lmv_fid_alloc(exp, &op_data->op_fid2, op_data);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INODE, "CREATE '%*s' on "DFID" -> mds #%x\n",\r\nop_data->op_namelen, op_data->op_name, PFID(&op_data->op_fid1),\r\nop_data->op_mds);\r\nop_data->op_flags |= MF_MDC_CANCEL_FID1;\r\nrc = md_create(tgt->ltd_exp, op_data, data, datalen, mode, uid, gid,\r\ncap_effective, rdev, request);\r\nif (rc == 0) {\r\nif (*request == NULL)\r\nreturn rc;\r\nCDEBUG(D_INODE, "Created - "DFID"\n", PFID(&op_data->op_fid2));\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_done_writing(struct obd_export *exp,\r\nstruct md_op_data *op_data,\r\nstruct md_open_data *mod)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_done_writing(tgt->ltd_exp, op_data, mod);\r\nreturn rc;\r\n}\r\nstatic int\r\nlmv_enqueue_remote(struct obd_export *exp, struct ldlm_enqueue_info *einfo,\r\nstruct lookup_intent *it, struct md_op_data *op_data,\r\nstruct lustre_handle *lockh, void *lmm, int lmmsize,\r\nint extra_lock_flags)\r\n{\r\nstruct ptlrpc_request *req = it->d.lustre.it_data;\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lustre_handle plock;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct md_op_data *rdata;\r\nstruct lu_fid fid1;\r\nstruct mdt_body *body;\r\nint rc = 0;\r\nint pmode;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nLASSERT(body != NULL);\r\nif (!(body->valid & OBD_MD_MDS))\r\nreturn 0;\r\nCDEBUG(D_INODE, "REMOTE_ENQUEUE '%s' on "DFID" -> "DFID"\n",\r\nLL_IT2STR(it), PFID(&op_data->op_fid1), PFID(&body->fid1));\r\npmode = it->d.lustre.it_lock_mode;\r\nLASSERT(pmode != 0);\r\nmemcpy(&plock, lockh, sizeof(plock));\r\nit->d.lustre.it_lock_mode = 0;\r\nit->d.lustre.it_data = NULL;\r\nfid1 = body->fid1;\r\nit->d.lustre.it_disposition &= ~DISP_ENQ_COMPLETE;\r\nptlrpc_req_finished(req);\r\ntgt = lmv_find_target(lmv, &fid1);\r\nif (IS_ERR(tgt))\r\nGOTO(out, rc = PTR_ERR(tgt));\r\nOBD_ALLOC_PTR(rdata);\r\nif (rdata == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nrdata->op_fid1 = fid1;\r\nrdata->op_bias = MDS_CROSS_REF;\r\nrc = md_enqueue(tgt->ltd_exp, einfo, it, rdata, lockh,\r\nlmm, lmmsize, NULL, extra_lock_flags);\r\nOBD_FREE_PTR(rdata);\r\nout:\r\nldlm_lock_decref(&plock, pmode);\r\nreturn rc;\r\n}\r\nstatic int\r\nlmv_enqueue(struct obd_export *exp, struct ldlm_enqueue_info *einfo,\r\nstruct lookup_intent *it, struct md_op_data *op_data,\r\nstruct lustre_handle *lockh, void *lmm, int lmmsize,\r\nstruct ptlrpc_request **req, __u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INODE, "ENQUEUE '%s' on "DFID"\n",\r\nLL_IT2STR(it), PFID(&op_data->op_fid1));\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nCDEBUG(D_INODE, "ENQUEUE '%s' on "DFID" -> mds #%d\n",\r\nLL_IT2STR(it), PFID(&op_data->op_fid1), tgt->ltd_idx);\r\nrc = md_enqueue(tgt->ltd_exp, einfo, it, op_data, lockh,\r\nlmm, lmmsize, req, extra_lock_flags);\r\nif (rc == 0 && it && it->it_op == IT_OPEN) {\r\nrc = lmv_enqueue_remote(exp, einfo, it, op_data, lockh,\r\nlmm, lmmsize, extra_lock_flags);\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlmv_getattr_name(struct obd_export *exp,struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct mdt_body *body;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nCDEBUG(D_INODE, "GETATTR_NAME for %*s on "DFID" -> mds #%d\n",\r\nop_data->op_namelen, op_data->op_name, PFID(&op_data->op_fid1),\r\ntgt->ltd_idx);\r\nrc = md_getattr_name(tgt->ltd_exp, op_data, request);\r\nif (rc != 0)\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*request)->rq_pill,\r\n&RMF_MDT_BODY);\r\nLASSERT(body != NULL);\r\nif (body->valid & OBD_MD_MDS) {\r\nstruct lu_fid rid = body->fid1;\r\nCDEBUG(D_INODE, "Request attrs for "DFID"\n",\r\nPFID(&rid));\r\ntgt = lmv_find_target(lmv, &rid);\r\nif (IS_ERR(tgt)) {\r\nptlrpc_req_finished(*request);\r\nreturn PTR_ERR(tgt);\r\n}\r\nop_data->op_fid1 = rid;\r\nop_data->op_valid |= OBD_MD_FLCROSSREF;\r\nop_data->op_namelen = 0;\r\nop_data->op_name = NULL;\r\nrc = md_getattr_name(tgt->ltd_exp, op_data, &req);\r\nptlrpc_req_finished(*request);\r\n*request = req;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_early_cancel(struct obd_export *exp, struct md_op_data *op_data,\r\nint op_tgt, ldlm_mode_t mode, int bits, int flag)\r\n{\r\nstruct lu_fid *fid = md_op_data_fid(op_data, flag);\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nldlm_policy_data_t policy = {{0}};\r\nint rc = 0;\r\nif (!fid_is_sane(fid))\r\nreturn 0;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nif (tgt->ltd_idx != op_tgt) {\r\nCDEBUG(D_INODE, "EARLY_CANCEL on "DFID"\n", PFID(fid));\r\npolicy.l_inodebits.bits = bits;\r\nrc = md_cancel_unused(tgt->ltd_exp, fid, &policy,\r\nmode, LCF_ASYNC, NULL);\r\n} else {\r\nCDEBUG(D_INODE,\r\n"EARLY_CANCEL skip operation target %d on "DFID"\n",\r\nop_tgt, PFID(fid));\r\nop_data->op_flags |= flag;\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_link(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nLASSERT(op_data->op_namelen != 0);\r\nCDEBUG(D_INODE, "LINK "DFID":%*s to "DFID"\n",\r\nPFID(&op_data->op_fid2), op_data->op_namelen,\r\nop_data->op_name, PFID(&op_data->op_fid1));\r\nop_data->op_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nop_data->op_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nop_data->op_cap = cfs_curproc_cap_pack();\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid2);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nop_data->op_flags |= MF_MDC_CANCEL_FID2;\r\nrc = lmv_early_cancel(exp, op_data, tgt->ltd_idx, LCK_EX,\r\nMDS_INODELOCK_UPDATE, MF_MDC_CANCEL_FID1);\r\nif (rc != 0)\r\nreturn rc;\r\nrc = md_link(tgt->ltd_exp, op_data, request);\r\nreturn rc;\r\n}\r\nstatic int lmv_rename(struct obd_export *exp, struct md_op_data *op_data,\r\nconst char *old, int oldlen, const char *new, int newlen,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *src_tgt;\r\nstruct lmv_tgt_desc *tgt_tgt;\r\nint rc;\r\nLASSERT(oldlen != 0);\r\nCDEBUG(D_INODE, "RENAME %*s in "DFID" to %*s in "DFID"\n",\r\noldlen, old, PFID(&op_data->op_fid1),\r\nnewlen, new, PFID(&op_data->op_fid2));\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nop_data->op_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nop_data->op_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nop_data->op_cap = cfs_curproc_cap_pack();\r\nsrc_tgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(src_tgt))\r\nreturn PTR_ERR(src_tgt);\r\ntgt_tgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid2);\r\nif (IS_ERR(tgt_tgt))\r\nreturn PTR_ERR(tgt_tgt);\r\nop_data->op_flags |= MF_MDC_CANCEL_FID1 | MF_MDC_CANCEL_FID3;\r\nrc = lmv_early_cancel(exp, op_data, src_tgt->ltd_idx,\r\nLCK_EX, MDS_INODELOCK_UPDATE,\r\nMF_MDC_CANCEL_FID2);\r\nif (rc == 0) {\r\nrc = lmv_early_cancel(exp, op_data, src_tgt->ltd_idx,\r\nLCK_EX, MDS_INODELOCK_LOOKUP,\r\nMF_MDC_CANCEL_FID4);\r\n}\r\nif (rc == 0)\r\nrc = lmv_early_cancel(exp, op_data, src_tgt->ltd_idx,\r\nLCK_EX, MDS_INODELOCK_FULL,\r\nMF_MDC_CANCEL_FID4);\r\nif (rc == 0)\r\nrc = md_rename(src_tgt->ltd_exp, op_data, old, oldlen,\r\nnew, newlen, request);\r\nreturn rc;\r\n}\r\nstatic int lmv_setattr(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *ea, int ealen, void *ea2, int ea2len,\r\nstruct ptlrpc_request **request,\r\nstruct md_open_data **mod)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc = 0;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INODE, "SETATTR for "DFID", valid 0x%x\n",\r\nPFID(&op_data->op_fid1), op_data->op_attr.ia_valid);\r\nop_data->op_flags |= MF_MDC_CANCEL_FID1;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_setattr(tgt->ltd_exp, op_data, ea, ealen, ea2,\r\nea2len, request, mod);\r\nreturn rc;\r\n}\r\nstatic int lmv_sync(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct obd_capa *oc, struct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_sync(tgt->ltd_exp, fid, oc, request);\r\nreturn rc;\r\n}\r\nstatic void lmv_adjust_dirpages(struct page **pages, int ncfspgs, int nlupgs)\r\n{\r\nint i;\r\nfor (i = 0; i < ncfspgs; i++) {\r\nstruct lu_dirpage *dp = kmap(pages[i]);\r\nstruct lu_dirpage *first = dp;\r\nstruct lu_dirent *end_dirent = NULL;\r\nstruct lu_dirent *ent;\r\n__u64 hash_end = dp->ldp_hash_end;\r\n__u32 flags = dp->ldp_flags;\r\nwhile (--nlupgs > 0) {\r\nent = lu_dirent_start(dp);\r\nfor (end_dirent = ent; ent != NULL;\r\nend_dirent = ent, ent = lu_dirent_next(ent));\r\ndp = (struct lu_dirpage *)((char *)dp + LU_PAGE_SIZE);\r\nif (!((unsigned long)dp & ~CFS_PAGE_MASK))\r\nbreak;\r\nhash_end = dp->ldp_hash_end;\r\nflags = dp->ldp_flags;\r\nif (!end_dirent)\r\nbreak;\r\nLASSERT(le16_to_cpu(end_dirent->lde_reclen) == 0);\r\nend_dirent->lde_reclen =\r\ncpu_to_le16((char *)(dp->ldp_entries) -\r\n(char *)end_dirent);\r\n}\r\nfirst->ldp_hash_end = hash_end;\r\nfirst->ldp_flags &= ~cpu_to_le32(LDF_COLLIDE);\r\nfirst->ldp_flags |= flags & cpu_to_le32(LDF_COLLIDE);\r\nkunmap(pages[i]);\r\n}\r\nLASSERTF(nlupgs == 0, "left = %d", nlupgs);\r\n}\r\nstatic int lmv_readpage(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct page **pages, struct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\n__u64 offset = op_data->op_offset;\r\nint rc;\r\nint ncfspgs;\r\nint nlupgs;\r\nstruct lmv_tgt_desc *tgt;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_INODE, "READPAGE at "LPX64" from "DFID"\n",\r\noffset, PFID(&op_data->op_fid1));\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_readpage(tgt->ltd_exp, op_data, pages, request);\r\nif (rc != 0)\r\nreturn rc;\r\nncfspgs = ((*request)->rq_bulk->bd_nob_transferred + PAGE_CACHE_SIZE - 1)\r\n>> PAGE_CACHE_SHIFT;\r\nnlupgs = (*request)->rq_bulk->bd_nob_transferred >> LU_PAGE_SHIFT;\r\nLASSERT(!((*request)->rq_bulk->bd_nob_transferred & ~LU_PAGE_MASK));\r\nLASSERT(ncfspgs > 0 && ncfspgs <= op_data->op_npages);\r\nCDEBUG(D_INODE, "read %d(%d)/%d pages\n", ncfspgs, nlupgs,\r\nop_data->op_npages);\r\nlmv_adjust_dirpages(pages, ncfspgs, nlupgs);\r\nreturn rc;\r\n}\r\nstatic int lmv_unlink(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt = NULL;\r\nstruct mdt_body *body;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nretry:\r\nif (likely(!fid_is_zero(&op_data->op_fid2)))\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid2);\r\nelse\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nop_data->op_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nop_data->op_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nop_data->op_cap = cfs_curproc_cap_pack();\r\nop_data->op_flags |= MF_MDC_CANCEL_FID1 | MF_MDC_CANCEL_FID3;\r\nrc = lmv_early_cancel(exp, op_data, tgt->ltd_idx, LCK_EX,\r\nMDS_INODELOCK_FULL, MF_MDC_CANCEL_FID3);\r\nif (rc != 0)\r\nreturn rc;\r\nCDEBUG(D_INODE, "unlink with fid="DFID"/"DFID" -> mds #%d\n",\r\nPFID(&op_data->op_fid1), PFID(&op_data->op_fid2), tgt->ltd_idx);\r\nrc = md_unlink(tgt->ltd_exp, op_data, request);\r\nif (rc != 0 && rc != -EREMOTE)\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*request)->rq_pill, &RMF_MDT_BODY);\r\nif (body == NULL)\r\nreturn -EPROTO;\r\nif (likely(!(body->valid & OBD_MD_MDS)))\r\nreturn 0;\r\nCDEBUG(D_INODE, "%s: try unlink to another MDT for "DFID"\n",\r\nexp->exp_obd->obd_name, PFID(&body->fid1));\r\nop_data->op_fid2 = body->fid1;\r\nptlrpc_req_finished(*request);\r\n*request = NULL;\r\ngoto retry;\r\n}\r\nstatic int lmv_precleanup(struct obd_device *obd, enum obd_cleanup_stage stage)\r\n{\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint rc = 0;\r\nswitch (stage) {\r\ncase OBD_CLEANUP_EARLY:\r\nbreak;\r\ncase OBD_CLEANUP_EXPORTS:\r\nfld_client_proc_fini(&lmv->lmv_fld);\r\nlprocfs_obd_cleanup(obd);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_get_info(const struct lu_env *env, struct obd_export *exp,\r\n__u32 keylen, void *key, __u32 *vallen, void *val,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nstruct obd_device *obd;\r\nstruct lmv_obd *lmv;\r\nint rc = 0;\r\nobd = class_exp2obd(exp);\r\nif (obd == NULL) {\r\nCDEBUG(D_IOCTL, "Invalid client cookie "LPX64"\n",\r\nexp->exp_handle.h_cookie);\r\nreturn -EINVAL;\r\n}\r\nlmv = &obd->u.lmv;\r\nif (keylen >= strlen("remote_flag") && !strcmp(key, "remote_flag")) {\r\nstruct lmv_tgt_desc *tgt;\r\nint i;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nLASSERT(*vallen == sizeof(__u32));\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL || tgt->ltd_exp == NULL)\r\ncontinue;\r\nif (!obd_get_info(env, tgt->ltd_exp, keylen, key,\r\nvallen, val, NULL))\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n} else if (KEY_IS(KEY_MAX_EASIZE) || KEY_IS(KEY_CONN_DATA)) {\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nrc = obd_get_info(env, lmv->tgts[0]->ltd_exp, keylen, key,\r\nvallen, val, NULL);\r\nif (!rc && KEY_IS(KEY_CONN_DATA))\r\nexp->exp_connect_data = *(struct obd_connect_data *)val;\r\nreturn rc;\r\n} else if (KEY_IS(KEY_TGT_COUNT)) {\r\n*((int *)val) = lmv->desc.ld_tgt_count;\r\nreturn 0;\r\n}\r\nCDEBUG(D_IOCTL, "Invalid key\n");\r\nreturn -EINVAL;\r\n}\r\nint lmv_set_info_async(const struct lu_env *env, struct obd_export *exp,\r\nobd_count keylen, void *key, obd_count vallen,\r\nvoid *val, struct ptlrpc_request_set *set)\r\n{\r\nstruct lmv_tgt_desc *tgt;\r\nstruct obd_device *obd;\r\nstruct lmv_obd *lmv;\r\nint rc = 0;\r\nobd = class_exp2obd(exp);\r\nif (obd == NULL) {\r\nCDEBUG(D_IOCTL, "Invalid client cookie "LPX64"\n",\r\nexp->exp_handle.h_cookie);\r\nreturn -EINVAL;\r\n}\r\nlmv = &obd->u.lmv;\r\nif (KEY_IS(KEY_READ_ONLY) || KEY_IS(KEY_FLUSH_CTX)) {\r\nint i, err = 0;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL || tgt->ltd_exp == NULL)\r\ncontinue;\r\nerr = obd_set_info_async(env, tgt->ltd_exp,\r\nkeylen, key, vallen, val, set);\r\nif (err && rc == 0)\r\nrc = err;\r\n}\r\nreturn rc;\r\n}\r\nreturn -EINVAL;\r\n}\r\nint lmv_packmd(struct obd_export *exp, struct lov_mds_md **lmmp,\r\nstruct lov_stripe_md *lsm)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_stripe_md *meap;\r\nstruct lmv_stripe_md *lsmp;\r\nint mea_size;\r\nint i;\r\nmea_size = lmv_get_easize(lmv);\r\nif (!lmmp)\r\nreturn mea_size;\r\nif (*lmmp && !lsm) {\r\nOBD_FREE_LARGE(*lmmp, mea_size);\r\n*lmmp = NULL;\r\nreturn 0;\r\n}\r\nif (*lmmp == NULL) {\r\nOBD_ALLOC_LARGE(*lmmp, mea_size);\r\nif (*lmmp == NULL)\r\nreturn -ENOMEM;\r\n}\r\nif (!lsm)\r\nreturn mea_size;\r\nlsmp = (struct lmv_stripe_md *)lsm;\r\nmeap = (struct lmv_stripe_md *)*lmmp;\r\nif (lsmp->mea_magic != MEA_MAGIC_LAST_CHAR &&\r\nlsmp->mea_magic != MEA_MAGIC_ALL_CHARS)\r\nreturn -EINVAL;\r\nmeap->mea_magic = cpu_to_le32(lsmp->mea_magic);\r\nmeap->mea_count = cpu_to_le32(lsmp->mea_count);\r\nmeap->mea_master = cpu_to_le32(lsmp->mea_master);\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nmeap->mea_ids[i] = lsmp->mea_ids[i];\r\nfid_cpu_to_le(&meap->mea_ids[i], &lsmp->mea_ids[i]);\r\n}\r\nreturn mea_size;\r\n}\r\nint lmv_unpackmd(struct obd_export *exp, struct lov_stripe_md **lsmp,\r\nstruct lov_mds_md *lmm, int lmm_size)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_stripe_md **tmea = (struct lmv_stripe_md **)lsmp;\r\nstruct lmv_stripe_md *mea = (struct lmv_stripe_md *)lmm;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint mea_size;\r\nint i;\r\n__u32 magic;\r\nmea_size = lmv_get_easize(lmv);\r\nif (lsmp == NULL)\r\nreturn mea_size;\r\nif (*lsmp != NULL && lmm == NULL) {\r\nOBD_FREE_LARGE(*tmea, mea_size);\r\n*lsmp = NULL;\r\nreturn 0;\r\n}\r\nLASSERT(mea_size == lmm_size);\r\nOBD_ALLOC_LARGE(*tmea, mea_size);\r\nif (*tmea == NULL)\r\nreturn -ENOMEM;\r\nif (!lmm)\r\nreturn mea_size;\r\nif (mea->mea_magic == MEA_MAGIC_LAST_CHAR ||\r\nmea->mea_magic == MEA_MAGIC_ALL_CHARS ||\r\nmea->mea_magic == MEA_MAGIC_HASH_SEGMENT)\r\n{\r\nmagic = le32_to_cpu(mea->mea_magic);\r\n} else {\r\nCERROR("Old not supportable EA is found\n");\r\nLBUG();\r\n}\r\n(*tmea)->mea_magic = magic;\r\n(*tmea)->mea_count = le32_to_cpu(mea->mea_count);\r\n(*tmea)->mea_master = le32_to_cpu(mea->mea_master);\r\nfor (i = 0; i < (*tmea)->mea_count; i++) {\r\n(*tmea)->mea_ids[i] = mea->mea_ids[i];\r\nfid_le_to_cpu(&(*tmea)->mea_ids[i], &(*tmea)->mea_ids[i]);\r\n}\r\nreturn mea_size;\r\n}\r\nstatic int lmv_cancel_unused(struct obd_export *exp, const struct lu_fid *fid,\r\nldlm_policy_data_t *policy, ldlm_mode_t mode,\r\nldlm_cancel_flags_t flags, void *opaque)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nint rc = 0;\r\nint err;\r\nint i;\r\nLASSERT(fid != NULL);\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL || lmv->tgts[i]->ltd_exp == NULL ||\r\nlmv->tgts[i]->ltd_active == 0)\r\ncontinue;\r\nerr = md_cancel_unused(lmv->tgts[i]->ltd_exp, fid,\r\npolicy, mode, flags, opaque);\r\nif (!rc)\r\nrc = err;\r\n}\r\nreturn rc;\r\n}\r\nint lmv_set_lock_data(struct obd_export *exp, __u64 *lockh, void *data,\r\n__u64 *bits)\r\n{\r\nstruct lmv_obd *lmv = &exp->exp_obd->u.lmv;\r\nint rc;\r\nrc = md_set_lock_data(lmv->tgts[0]->ltd_exp, lockh, data, bits);\r\nreturn rc;\r\n}\r\nldlm_mode_t lmv_lock_match(struct obd_export *exp, __u64 flags,\r\nconst struct lu_fid *fid, ldlm_type_t type,\r\nldlm_policy_data_t *policy, ldlm_mode_t mode,\r\nstruct lustre_handle *lockh)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nldlm_mode_t rc;\r\nint i;\r\nCDEBUG(D_INODE, "Lock match for "DFID"\n", PFID(fid));\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nif (lmv->tgts[i] == NULL ||\r\nlmv->tgts[i]->ltd_exp == NULL ||\r\nlmv->tgts[i]->ltd_active == 0)\r\ncontinue;\r\nrc = md_lock_match(lmv->tgts[i]->ltd_exp, flags, fid,\r\ntype, policy, mode, lockh);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nint lmv_get_lustre_md(struct obd_export *exp, struct ptlrpc_request *req,\r\nstruct obd_export *dt_exp, struct obd_export *md_exp,\r\nstruct lustre_md *md)\r\n{\r\nstruct lmv_obd *lmv = &exp->exp_obd->u.lmv;\r\nreturn md_get_lustre_md(lmv->tgts[0]->ltd_exp, req, dt_exp, md_exp, md);\r\n}\r\nint lmv_free_lustre_md(struct obd_export *exp, struct lustre_md *md)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nif (md->mea)\r\nobd_free_memmd(exp, (void *)&md->mea);\r\nreturn md_free_lustre_md(lmv->tgts[0]->ltd_exp, md);\r\n}\r\nint lmv_set_open_replay_data(struct obd_export *exp,\r\nstruct obd_client_handle *och,\r\nstruct ptlrpc_request *open_req)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\ntgt = lmv_find_target(lmv, &och->och_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nreturn md_set_open_replay_data(tgt->ltd_exp, och, open_req);\r\n}\r\nint lmv_clear_open_replay_data(struct obd_export *exp,\r\nstruct obd_client_handle *och)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\ntgt = lmv_find_target(lmv, &och->och_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nreturn md_clear_open_replay_data(tgt->ltd_exp, och);\r\n}\r\nstatic int lmv_get_remote_perm(struct obd_export *exp,\r\nconst struct lu_fid *fid,\r\nstruct obd_capa *oc, __u32 suppgid,\r\nstruct ptlrpc_request **request)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_get_remote_perm(tgt->ltd_exp, fid, oc, suppgid, request);\r\nreturn rc;\r\n}\r\nstatic int lmv_renew_capa(struct obd_export *exp, struct obd_capa *oc,\r\nrenew_capa_cb_t cb)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, &oc->c_capa.lc_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_renew_capa(tgt->ltd_exp, oc, cb);\r\nreturn rc;\r\n}\r\nint lmv_unpack_capa(struct obd_export *exp, struct ptlrpc_request *req,\r\nconst struct req_msg_field *field, struct obd_capa **oc)\r\n{\r\nstruct lmv_obd *lmv = &exp->exp_obd->u.lmv;\r\nreturn md_unpack_capa(lmv->tgts[0]->ltd_exp, req, field, oc);\r\n}\r\nint lmv_intent_getattr_async(struct obd_export *exp,\r\nstruct md_enqueue_info *minfo,\r\nstruct ldlm_enqueue_info *einfo)\r\n{\r\nstruct md_op_data *op_data = &minfo->mi_data;\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt = NULL;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_intent_getattr_async(tgt->ltd_exp, minfo, einfo);\r\nreturn rc;\r\n}\r\nint lmv_revalidate_lock(struct obd_export *exp, struct lookup_intent *it,\r\nstruct lu_fid *fid, __u64 *bits)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint rc;\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\ntgt = lmv_find_target(lmv, fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nrc = md_revalidate_lock(tgt->ltd_exp, it, fid, bits);\r\nreturn rc;\r\n}\r\nint lmv_quotactl(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt = lmv->tgts[0];\r\nint rc = 0, i;\r\n__u64 curspace, curinodes;\r\nif (!lmv->desc.ld_tgt_count || !tgt->ltd_active) {\r\nCERROR("master lmv inactive\n");\r\nreturn -EIO;\r\n}\r\nif (oqctl->qc_cmd != Q_GETOQUOTA) {\r\nrc = obd_quotactl(tgt->ltd_exp, oqctl);\r\nreturn rc;\r\n}\r\ncurspace = curinodes = 0;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nint err;\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL || tgt->ltd_exp == NULL || tgt->ltd_active == 0)\r\ncontinue;\r\nif (!tgt->ltd_active) {\r\nCDEBUG(D_HA, "mdt %d is inactive.\n", i);\r\ncontinue;\r\n}\r\nerr = obd_quotactl(tgt->ltd_exp, oqctl);\r\nif (err) {\r\nCERROR("getquota on mdt %d failed. %d\n", i, err);\r\nif (!rc)\r\nrc = err;\r\n} else {\r\ncurspace += oqctl->qc_dqblk.dqb_curspace;\r\ncurinodes += oqctl->qc_dqblk.dqb_curinodes;\r\n}\r\n}\r\noqctl->qc_dqblk.dqb_curspace = curspace;\r\noqctl->qc_dqblk.dqb_curinodes = curinodes;\r\nreturn rc;\r\n}\r\nint lmv_quotacheck(struct obd_device *unused, struct obd_export *exp,\r\nstruct obd_quotactl *oqctl)\r\n{\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nint i, rc = 0;\r\nfor (i = 0; i < lmv->desc.ld_tgt_count; i++) {\r\nint err;\r\ntgt = lmv->tgts[i];\r\nif (tgt == NULL || tgt->ltd_exp == NULL || !tgt->ltd_active) {\r\nCERROR("lmv idx %d inactive\n", i);\r\nreturn -EIO;\r\n}\r\nerr = obd_quotacheck(tgt->ltd_exp, oqctl);\r\nif (err && !rc)\r\nrc = err;\r\n}\r\nreturn rc;\r\n}\r\nint __init lmv_init(void)\r\n{\r\nstruct lprocfs_static_vars lvars;\r\nint rc;\r\nlprocfs_lmv_init_vars(&lvars);\r\nrc = class_register_type(&lmv_obd_ops, &lmv_md_ops,\r\nlvars.module_vars, LUSTRE_LMV_NAME, NULL);\r\nreturn rc;\r\n}\r\nstatic void lmv_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_LMV_NAME);\r\n}
