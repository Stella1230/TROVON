static int mgc_name2resid(char *name, int len, struct ldlm_res_id *res_id,\r\nint type)\r\n{\r\n__u64 resname = 0;\r\nif (len > 8) {\r\nCERROR("name too long: %s\n", name);\r\nreturn -EINVAL;\r\n}\r\nif (len <= 0) {\r\nCERROR("missing name: %s\n", name);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&resname, name, len);\r\nmemset(res_id, 0, sizeof(*res_id));\r\nres_id->name[0] = cpu_to_le64(resname);\r\nswitch(type) {\r\ncase CONFIG_T_CONFIG:\r\ncase CONFIG_T_SPTLRPC:\r\nresname = 0;\r\nbreak;\r\ncase CONFIG_T_RECOVER:\r\nresname = type;\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nres_id->name[1] = cpu_to_le64(resname);\r\nCDEBUG(D_MGC, "log %s to resid "LPX64"/"LPX64" (%.8s)\n", name,\r\nres_id->name[0], res_id->name[1], (char *)&res_id->name[0]);\r\nreturn 0;\r\n}\r\nint mgc_fsname2resid(char *fsname, struct ldlm_res_id *res_id, int type)\r\n{\r\nreturn mgc_name2resid(fsname, strlen(fsname), res_id, type);\r\n}\r\nint mgc_logname2resid(char *logname, struct ldlm_res_id *res_id, int type)\r\n{\r\nchar *name_end;\r\nint len;\r\nname_end = strrchr(logname, '-');\r\nLASSERT(name_end);\r\nlen = name_end - logname;\r\nreturn mgc_name2resid(logname, len, res_id, type);\r\n}\r\nstatic int config_log_get(struct config_llog_data *cld)\r\n{\r\natomic_inc(&cld->cld_refcount);\r\nCDEBUG(D_INFO, "log %s refs %d\n", cld->cld_logname,\r\natomic_read(&cld->cld_refcount));\r\nreturn 0;\r\n}\r\nstatic void config_log_put(struct config_llog_data *cld)\r\n{\r\nCDEBUG(D_INFO, "log %s refs %d\n", cld->cld_logname,\r\natomic_read(&cld->cld_refcount));\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nif (atomic_dec_and_lock(&cld->cld_refcount, &config_list_lock)) {\r\nlist_del(&cld->cld_list_chain);\r\nspin_unlock(&config_list_lock);\r\nCDEBUG(D_MGC, "dropping config log %s\n", cld->cld_logname);\r\nif (cld->cld_recover)\r\nconfig_log_put(cld->cld_recover);\r\nif (cld->cld_sptlrpc)\r\nconfig_log_put(cld->cld_sptlrpc);\r\nif (cld_is_sptlrpc(cld))\r\nsptlrpc_conf_log_stop(cld->cld_logname);\r\nclass_export_put(cld->cld_mgcexp);\r\nOBD_FREE(cld, sizeof(*cld) + strlen(cld->cld_logname) + 1);\r\n}\r\n}\r\nstatic\r\nstruct config_llog_data *config_log_find(char *logname,\r\nstruct config_llog_instance *cfg)\r\n{\r\nstruct config_llog_data *cld;\r\nstruct config_llog_data *found = NULL;\r\nvoid * instance;\r\nLASSERT(logname != NULL);\r\ninstance = cfg ? cfg->cfg_instance : NULL;\r\nspin_lock(&config_list_lock);\r\nlist_for_each_entry(cld, &config_llog_list, cld_list_chain) {\r\nif (instance != cld->cld_cfg.cfg_instance)\r\ncontinue;\r\nif (strcmp(logname, cld->cld_logname) == 0) {\r\nfound = cld;\r\nbreak;\r\n}\r\n}\r\nif (found) {\r\natomic_inc(&found->cld_refcount);\r\nLASSERT(found->cld_stopping == 0 || cld_is_sptlrpc(found) == 0);\r\n}\r\nspin_unlock(&config_list_lock);\r\nreturn found;\r\n}\r\nstatic\r\nstruct config_llog_data *do_config_log_add(struct obd_device *obd,\r\nchar *logname,\r\nint type,\r\nstruct config_llog_instance *cfg,\r\nstruct super_block *sb)\r\n{\r\nstruct config_llog_data *cld;\r\nint rc;\r\nCDEBUG(D_MGC, "do adding config log %s:%p\n", logname,\r\ncfg ? cfg->cfg_instance : 0);\r\nOBD_ALLOC(cld, sizeof(*cld) + strlen(logname) + 1);\r\nif (!cld)\r\nreturn ERR_PTR(-ENOMEM);\r\nstrcpy(cld->cld_logname, logname);\r\nif (cfg)\r\ncld->cld_cfg = *cfg;\r\nelse\r\ncld->cld_cfg.cfg_callback = class_config_llog_handler;\r\nmutex_init(&cld->cld_lock);\r\ncld->cld_cfg.cfg_last_idx = 0;\r\ncld->cld_cfg.cfg_flags = 0;\r\ncld->cld_cfg.cfg_sb = sb;\r\ncld->cld_type = type;\r\natomic_set(&cld->cld_refcount, 1);\r\ncld->cld_mgcexp = class_export_get(obd->obd_self_export);\r\nif (cld_is_sptlrpc(cld)) {\r\nsptlrpc_conf_log_start(logname);\r\ncld->cld_cfg.cfg_obdname = obd->obd_name;\r\n}\r\nrc = mgc_logname2resid(logname, &cld->cld_resid, type);\r\nspin_lock(&config_list_lock);\r\nlist_add(&cld->cld_list_chain, &config_llog_list);\r\nspin_unlock(&config_list_lock);\r\nif (rc) {\r\nconfig_log_put(cld);\r\nreturn ERR_PTR(rc);\r\n}\r\nif (cld_is_sptlrpc(cld)) {\r\nrc = mgc_process_log(obd, cld);\r\nif (rc && rc != -ENOENT)\r\nCERROR("failed processing sptlrpc log: %d\n", rc);\r\n}\r\nreturn cld;\r\n}\r\nstatic struct config_llog_data *config_recover_log_add(struct obd_device *obd,\r\nchar *fsname,\r\nstruct config_llog_instance *cfg,\r\nstruct super_block *sb)\r\n{\r\nstruct config_llog_instance lcfg = *cfg;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct config_llog_data *cld;\r\nchar logname[32];\r\nif (IS_OST(lsi))\r\nreturn NULL;\r\nif (IS_MDT(lsi) && lcfg.cfg_instance)\r\nreturn NULL;\r\nLASSERT(strlen(fsname) < sizeof(logname) / 2);\r\nstrcpy(logname, fsname);\r\nif (IS_SERVER(lsi)) {\r\nLASSERT(lcfg.cfg_instance == NULL);\r\nlcfg.cfg_instance = sb;\r\nstrcat(logname, "-mdtir");\r\n} else {\r\nLASSERT(lcfg.cfg_instance != NULL);\r\nstrcat(logname, "-cliir");\r\n}\r\ncld = do_config_log_add(obd, logname, CONFIG_T_RECOVER, &lcfg, sb);\r\nreturn cld;\r\n}\r\nstatic int config_log_add(struct obd_device *obd, char *logname,\r\nstruct config_llog_instance *cfg,\r\nstruct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct config_llog_data *cld;\r\nstruct config_llog_data *sptlrpc_cld;\r\nchar seclogname[32];\r\nchar *ptr;\r\nCDEBUG(D_MGC, "adding config log %s:%p\n", logname, cfg->cfg_instance);\r\nptr = strrchr(logname, '-');\r\nif (ptr == NULL || ptr - logname > 8) {\r\nCERROR("logname %s is too long\n", logname);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(seclogname, logname, ptr - logname);\r\nstrcpy(seclogname + (ptr - logname), "-sptlrpc");\r\nsptlrpc_cld = config_log_find(seclogname, NULL);\r\nif (sptlrpc_cld == NULL) {\r\nsptlrpc_cld = do_config_log_add(obd, seclogname,\r\nCONFIG_T_SPTLRPC, NULL, NULL);\r\nif (IS_ERR(sptlrpc_cld)) {\r\nCERROR("can't create sptlrpc log: %s\n", seclogname);\r\nreturn PTR_ERR(sptlrpc_cld);\r\n}\r\n}\r\ncld = do_config_log_add(obd, logname, CONFIG_T_CONFIG, cfg, sb);\r\nif (IS_ERR(cld)) {\r\nCERROR("can't create log: %s\n", logname);\r\nconfig_log_put(sptlrpc_cld);\r\nreturn PTR_ERR(cld);\r\n}\r\ncld->cld_sptlrpc = sptlrpc_cld;\r\nLASSERT(lsi->lsi_lmd);\r\nif (!(lsi->lsi_lmd->lmd_flags & LMD_FLG_NOIR)) {\r\nstruct config_llog_data *recover_cld;\r\n*strrchr(seclogname, '-') = 0;\r\nrecover_cld = config_recover_log_add(obd, seclogname, cfg, sb);\r\nif (IS_ERR(recover_cld)) {\r\nconfig_log_put(cld);\r\nreturn PTR_ERR(recover_cld);\r\n}\r\ncld->cld_recover = recover_cld;\r\n}\r\nreturn 0;\r\n}\r\nstatic int config_log_end(char *logname, struct config_llog_instance *cfg)\r\n{\r\nstruct config_llog_data *cld;\r\nstruct config_llog_data *cld_sptlrpc = NULL;\r\nstruct config_llog_data *cld_recover = NULL;\r\nint rc = 0;\r\ncld = config_log_find(logname, cfg);\r\nif (cld == NULL)\r\nreturn -ENOENT;\r\nmutex_lock(&cld->cld_lock);\r\nif (unlikely(cld->cld_stopping)) {\r\nmutex_unlock(&cld->cld_lock);\r\nconfig_log_put(cld);\r\nreturn rc;\r\n}\r\ncld->cld_stopping = 1;\r\ncld_recover = cld->cld_recover;\r\ncld->cld_recover = NULL;\r\nmutex_unlock(&cld->cld_lock);\r\nif (cld_recover) {\r\nmutex_lock(&cld_recover->cld_lock);\r\ncld_recover->cld_stopping = 1;\r\nmutex_unlock(&cld_recover->cld_lock);\r\nconfig_log_put(cld_recover);\r\n}\r\nspin_lock(&config_list_lock);\r\ncld_sptlrpc = cld->cld_sptlrpc;\r\ncld->cld_sptlrpc = NULL;\r\nspin_unlock(&config_list_lock);\r\nif (cld_sptlrpc)\r\nconfig_log_put(cld_sptlrpc);\r\nconfig_log_put(cld);\r\nconfig_log_put(cld);\r\nCDEBUG(D_MGC, "end config log %s (%d)\n", logname ? logname : "client",\r\nrc);\r\nreturn rc;\r\n}\r\nint lprocfs_mgc_rd_ir_state(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp = obd->u.cli.cl_import;\r\nstruct obd_connect_data *ocd = &imp->imp_connect_data;\r\nstruct config_llog_data *cld;\r\nseq_printf(m, "imperative_recovery: %s\n",\r\nOCD_HAS_FLAG(ocd, IMP_RECOV) ? "ENABLED" : "DISABLED");\r\nseq_printf(m, "client_state:\n");\r\nspin_lock(&config_list_lock);\r\nlist_for_each_entry(cld, &config_llog_list, cld_list_chain) {\r\nif (cld->cld_recover == NULL)\r\ncontinue;\r\nseq_printf(m, " - { client: %s, nidtbl_version: %u }\n",\r\ncld->cld_logname,\r\ncld->cld_recover->cld_cfg.cfg_last_idx);\r\n}\r\nspin_unlock(&config_list_lock);\r\nreturn 0;\r\n}\r\nstatic void do_requeue(struct config_llog_data *cld)\r\n{\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\ndown_read(&cld->cld_mgcexp->exp_obd->u.cli.cl_sem);\r\nif (cld->cld_mgcexp->exp_obd->u.cli.cl_conn_count != 0) {\r\nCDEBUG(D_MGC, "updating log %s\n", cld->cld_logname);\r\nmgc_process_log(cld->cld_mgcexp->exp_obd, cld);\r\n} else {\r\nCDEBUG(D_MGC, "disconnecting, won't update log %s\n",\r\ncld->cld_logname);\r\n}\r\nup_read(&cld->cld_mgcexp->exp_obd->u.cli.cl_sem);\r\n}\r\nstatic int mgc_requeue_thread(void *data)\r\n{\r\nint rc = 0;\r\nCDEBUG(D_MGC, "Starting requeue thread\n");\r\nspin_lock(&config_list_lock);\r\nrq_state |= RQ_RUNNING;\r\nwhile (1) {\r\nstruct l_wait_info lwi;\r\nstruct config_llog_data *cld, *cld_prev;\r\nint rand = cfs_rand() & MGC_TIMEOUT_RAND_CENTISEC;\r\nint stopped = !!(rq_state & RQ_STOP);\r\nint to;\r\nrq_state &= ~(RQ_NOW | RQ_LATER);\r\nspin_unlock(&config_list_lock);\r\nto = MGC_TIMEOUT_MIN_SECONDS * HZ;\r\nto += rand * HZ / 100;\r\nlwi = LWI_TIMEOUT(to, NULL, NULL);\r\nl_wait_event(rq_waitq, rq_state & RQ_STOP, &lwi);\r\ncld_prev = NULL;\r\nspin_lock(&config_list_lock);\r\nlist_for_each_entry(cld, &config_llog_list,\r\ncld_list_chain) {\r\nif (!cld->cld_lostlock)\r\ncontinue;\r\nspin_unlock(&config_list_lock);\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nif (cld_prev)\r\nconfig_log_put(cld_prev);\r\ncld_prev = cld;\r\ncld->cld_lostlock = 0;\r\nif (likely(!stopped))\r\ndo_requeue(cld);\r\nspin_lock(&config_list_lock);\r\n}\r\nspin_unlock(&config_list_lock);\r\nif (cld_prev)\r\nconfig_log_put(cld_prev);\r\nif (unlikely(stopped)) {\r\nspin_lock(&config_list_lock);\r\nbreak;\r\n}\r\nlwi = (struct l_wait_info) { 0 };\r\nl_wait_event(rq_waitq, rq_state & (RQ_NOW | RQ_STOP),\r\n&lwi);\r\nspin_lock(&config_list_lock);\r\n}\r\nrq_state &= ~RQ_RUNNING;\r\nspin_unlock(&config_list_lock);\r\ncomplete(&rq_exit);\r\nCDEBUG(D_MGC, "Ending requeue thread\n");\r\nreturn rc;\r\n}\r\nstatic void mgc_requeue_add(struct config_llog_data *cld)\r\n{\r\nCDEBUG(D_INFO, "log %s: requeue (r=%d sp=%d st=%x)\n",\r\ncld->cld_logname, atomic_read(&cld->cld_refcount),\r\ncld->cld_stopping, rq_state);\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nmutex_lock(&cld->cld_lock);\r\nif (cld->cld_stopping || cld->cld_lostlock) {\r\nmutex_unlock(&cld->cld_lock);\r\nreturn;\r\n}\r\nconfig_log_get(cld);\r\ncld->cld_lostlock = 1;\r\nmutex_unlock(&cld->cld_lock);\r\nspin_lock(&config_list_lock);\r\nif (rq_state & RQ_STOP) {\r\nspin_unlock(&config_list_lock);\r\ncld->cld_lostlock = 0;\r\nconfig_log_put(cld);\r\n} else {\r\nrq_state |= RQ_NOW;\r\nspin_unlock(&config_list_lock);\r\nwake_up(&rq_waitq);\r\n}\r\n}\r\nstatic int mgc_fs_setup(struct obd_device *obd, struct super_block *sb,\r\nstruct vfsmount *mnt)\r\n{\r\nstruct lvfs_run_ctxt saved;\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct client_obd *cli = &obd->u.cli;\r\nstruct dentry *dentry;\r\nchar *label;\r\nint err = 0;\r\nLASSERT(lsi);\r\nLASSERT(lsi->lsi_srv_mnt == mnt);\r\ndown(&cli->cl_mgc_sem);\r\ncfs_cleanup_group_info();\r\nobd->obd_fsops = fsfilt_get_ops(lsi->lsi_fstype);\r\nif (IS_ERR(obd->obd_fsops)) {\r\nup(&cli->cl_mgc_sem);\r\nCERROR("%s: No fstype %s: rc = %ld\n", lsi->lsi_fstype,\r\nobd->obd_name, PTR_ERR(obd->obd_fsops));\r\nreturn PTR_ERR(obd->obd_fsops);\r\n}\r\ncli->cl_mgc_vfsmnt = mnt;\r\nerr = fsfilt_setup(obd, mnt->mnt_sb);\r\nif (err)\r\nGOTO(err_ops, err);\r\nOBD_SET_CTXT_MAGIC(&obd->obd_lvfs_ctxt);\r\nobd->obd_lvfs_ctxt.pwdmnt = mnt;\r\nobd->obd_lvfs_ctxt.pwd = mnt->mnt_root;\r\nobd->obd_lvfs_ctxt.fs = get_ds();\r\npush_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\ndentry = ll_lookup_one_len(MOUNT_CONFIGS_DIR, cfs_fs_pwd(current->fs),\r\nstrlen(MOUNT_CONFIGS_DIR));\r\npop_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nif (IS_ERR(dentry)) {\r\nerr = PTR_ERR(dentry);\r\nCERROR("cannot lookup %s directory: rc = %d\n",\r\nMOUNT_CONFIGS_DIR, err);\r\nGOTO(err_ops, err);\r\n}\r\ncli->cl_mgc_configs_dir = dentry;\r\nclass_incref(obd, "mgc_fs", obd);\r\nlabel = fsfilt_get_label(obd, mnt->mnt_sb);\r\nif (label)\r\nCDEBUG(D_MGC, "MGC using disk labelled=%s\n", label);\r\nreturn 0;\r\nerr_ops:\r\nfsfilt_put_ops(obd->obd_fsops);\r\nobd->obd_fsops = NULL;\r\ncli->cl_mgc_vfsmnt = NULL;\r\nup(&cli->cl_mgc_sem);\r\nreturn err;\r\n}\r\nstatic int mgc_fs_cleanup(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nint rc = 0;\r\nLASSERT(cli->cl_mgc_vfsmnt != NULL);\r\nif (cli->cl_mgc_configs_dir != NULL) {\r\nstruct lvfs_run_ctxt saved;\r\npush_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nl_dput(cli->cl_mgc_configs_dir);\r\ncli->cl_mgc_configs_dir = NULL;\r\npop_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nclass_decref(obd, "mgc_fs", obd);\r\n}\r\ncli->cl_mgc_vfsmnt = NULL;\r\nif (obd->obd_fsops)\r\nfsfilt_put_ops(obd->obd_fsops);\r\nup(&cli->cl_mgc_sem);\r\nreturn rc;\r\n}\r\nstatic int mgc_precleanup(struct obd_device *obd, enum obd_cleanup_stage stage)\r\n{\r\nint rc = 0;\r\nswitch (stage) {\r\ncase OBD_CLEANUP_EARLY:\r\nbreak;\r\ncase OBD_CLEANUP_EXPORTS:\r\nif (atomic_dec_and_test(&mgc_count)) {\r\nint running;\r\nspin_lock(&config_list_lock);\r\nrunning = rq_state & RQ_RUNNING;\r\nif (running)\r\nrq_state |= RQ_STOP;\r\nspin_unlock(&config_list_lock);\r\nif (running) {\r\nwake_up(&rq_waitq);\r\nwait_for_completion(&rq_exit);\r\n}\r\n}\r\nobd_cleanup_client_import(obd);\r\nrc = obd_llog_finish(obd, 0);\r\nif (rc != 0)\r\nCERROR("failed to cleanup llogging subsystems\n");\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_cleanup(struct obd_device *obd)\r\n{\r\nstruct client_obd *cli = &obd->u.cli;\r\nint rc;\r\nLASSERT(cli->cl_mgc_vfsmnt == NULL);\r\nif (obd->obd_type->typ_refcnt <= 1)\r\nclass_del_profiles();\r\nlprocfs_obd_cleanup(obd);\r\nptlrpcd_decref();\r\nrc = client_obd_cleanup(obd);\r\nreturn rc;\r\n}\r\nstatic int mgc_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lprocfs_static_vars lvars;\r\nint rc;\r\nptlrpcd_addref();\r\nrc = client_obd_setup(obd, lcfg);\r\nif (rc)\r\nGOTO(err_decref, rc);\r\nrc = obd_llog_init(obd, &obd->obd_olg, obd, NULL);\r\nif (rc) {\r\nCERROR("failed to setup llogging subsystems\n");\r\nGOTO(err_cleanup, rc);\r\n}\r\nlprocfs_mgc_init_vars(&lvars);\r\nlprocfs_obd_setup(obd, lvars.obd_vars);\r\nsptlrpc_lprocfs_cliobd_attach(obd);\r\nif (atomic_inc_return(&mgc_count) == 1) {\r\nrq_state = 0;\r\ninit_waitqueue_head(&rq_waitq);\r\nrc = PTR_ERR(kthread_run(mgc_requeue_thread, NULL,\r\n"ll_cfg_requeue"));\r\nif (IS_ERR_VALUE(rc)) {\r\nCERROR("%s: Cannot start requeue thread (%d),"\r\n"no more log updates!\n",\r\nobd->obd_name, rc);\r\nGOTO(err_cleanup, rc);\r\n}\r\nrc = 0;\r\n}\r\nreturn rc;\r\nerr_cleanup:\r\nclient_obd_cleanup(obd);\r\nerr_decref:\r\nptlrpcd_decref();\r\nreturn rc;\r\n}\r\nstatic int mgc_blocking_ast(struct ldlm_lock *lock, struct ldlm_lock_desc *desc,\r\nvoid *data, int flag)\r\n{\r\nstruct lustre_handle lockh;\r\nstruct config_llog_data *cld = (struct config_llog_data *)data;\r\nint rc = 0;\r\nswitch (flag) {\r\ncase LDLM_CB_BLOCKING:\r\nLDLM_DEBUG(lock, "MGC blocking CB");\r\nldlm_lock2handle(lock, &lockh);\r\nrc = ldlm_cli_cancel(&lockh, LCF_ASYNC);\r\nbreak;\r\ncase LDLM_CB_CANCELING:\r\nLDLM_DEBUG(lock, "MGC cancel CB");\r\nCDEBUG(D_MGC, "Lock res "LPX64" (%.8s)\n",\r\nlock->l_resource->lr_name.name[0],\r\n(char *)&lock->l_resource->lr_name.name[0]);\r\nif (!cld) {\r\nCDEBUG(D_INFO, "missing data, won't requeue\n");\r\nbreak;\r\n}\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nif (cld->cld_stopping) {\r\nCDEBUG(D_MGC, "log %s: stopping, won't requeue\n",\r\ncld->cld_logname);\r\nconfig_log_put(cld);\r\nbreak;\r\n}\r\nif (!lock->l_conn_export ||\r\n!lock->l_conn_export->exp_obd->u.cli.cl_conn_count) {\r\nCDEBUG(D_MGC, "log %.8s: disconnecting, won't requeue\n",\r\ncld->cld_logname);\r\nconfig_log_put(cld);\r\nbreak;\r\n}\r\nmgc_requeue_add(cld);\r\nconfig_log_put(cld);\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_set_mgs_param(struct obd_export *exp,\r\nstruct mgs_send_param *msp)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mgs_send_param *req_msp, *rep_msp;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MGS_SET_INFO, LUSTRE_MGS_VERSION,\r\nMGS_SET_INFO);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_msp = req_capsule_client_get(&req->rq_pill, &RMF_MGS_SEND_PARAM);\r\nif (!req_msp) {\r\nptlrpc_req_finished(req);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(req_msp, msp, sizeof(*req_msp));\r\nptlrpc_request_set_replen(req);\r\nreq->rq_delay_limit = MGC_SEND_PARAM_LIMIT;\r\nrc = ptlrpc_queue_wait(req);\r\nif (!rc) {\r\nrep_msp = req_capsule_server_get(&req->rq_pill, &RMF_MGS_SEND_PARAM);\r\nmemcpy(msp, rep_msp, sizeof(*rep_msp));\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mgc_enqueue(struct obd_export *exp, struct lov_stripe_md *lsm,\r\n__u32 type, ldlm_policy_data_t *policy, __u32 mode,\r\n__u64 *flags, void *bl_cb, void *cp_cb, void *gl_cb,\r\nvoid *data, __u32 lvb_len, void *lvb_swabber,\r\nstruct lustre_handle *lockh)\r\n{\r\nstruct config_llog_data *cld = (struct config_llog_data *)data;\r\nstruct ldlm_enqueue_info einfo = {\r\n.ei_type = type,\r\n.ei_mode = mode,\r\n.ei_cb_bl = mgc_blocking_ast,\r\n.ei_cb_cp = ldlm_completion_ast,\r\n};\r\nstruct ptlrpc_request *req;\r\nint short_limit = cld_is_sptlrpc(cld);\r\nint rc;\r\nCDEBUG(D_MGC, "Enqueue for %s (res "LPX64")\n", cld->cld_logname,\r\ncld->cld_resid.name[0]);\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_LDLM_ENQUEUE, LUSTRE_DLM_VERSION,\r\nLDLM_ENQUEUE);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_DLM_LVB, RCL_SERVER, 0);\r\nptlrpc_request_set_replen(req);\r\nif (cld->cld_cfg.cfg_sb) {\r\nstruct lustre_sb_info *lsi = s2lsi(cld->cld_cfg.cfg_sb);\r\nif (lsi && IS_SERVER(lsi))\r\nshort_limit = 1;\r\n}\r\nreq->rq_delay_limit = short_limit ? 5 : MGC_ENQUEUE_LIMIT;\r\nrc = ldlm_cli_enqueue(exp, &req, &einfo, &cld->cld_resid, NULL, flags,\r\nNULL, 0, LVB_T_NONE, lockh, 0);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mgc_cancel(struct obd_export *exp, struct lov_stripe_md *md,\r\n__u32 mode, struct lustre_handle *lockh)\r\n{\r\nldlm_lock_decref(lockh, mode);\r\nreturn 0;\r\n}\r\nstatic void mgc_notify_active(struct obd_device *unused)\r\n{\r\nspin_lock(&config_list_lock);\r\nrq_state |= RQ_NOW;\r\nspin_unlock(&config_list_lock);\r\nwake_up(&rq_waitq);\r\n}\r\nstatic int mgc_target_register(struct obd_export *exp,\r\nstruct mgs_target_info *mti)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mgs_target_info *req_mti, *rep_mti;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MGS_TARGET_REG, LUSTRE_MGS_VERSION,\r\nMGS_TARGET_REG);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nreq_mti = req_capsule_client_get(&req->rq_pill, &RMF_MGS_TARGET_INFO);\r\nif (!req_mti) {\r\nptlrpc_req_finished(req);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(req_mti, mti, sizeof(*req_mti));\r\nptlrpc_request_set_replen(req);\r\nCDEBUG(D_MGC, "register %s\n", mti->mti_svname);\r\nreq->rq_delay_limit = MGC_TARGET_REG_LIMIT;\r\nrc = ptlrpc_queue_wait(req);\r\nif (!rc) {\r\nrep_mti = req_capsule_server_get(&req->rq_pill,\r\n&RMF_MGS_TARGET_INFO);\r\nmemcpy(mti, rep_mti, sizeof(*rep_mti));\r\nCDEBUG(D_MGC, "register %s got index = %d\n",\r\nmti->mti_svname, mti->mti_stripe_index);\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nint mgc_set_info_async(const struct lu_env *env, struct obd_export *exp,\r\nobd_count keylen, void *key, obd_count vallen,\r\nvoid *val, struct ptlrpc_request_set *set)\r\n{\r\nint rc = -EINVAL;\r\nif (KEY_IS(KEY_INIT_RECOV_BACKUP)) {\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nint value;\r\nif (vallen != sizeof(int))\r\nreturn -EINVAL;\r\nvalue = *(int *)val;\r\nCDEBUG(D_MGC, "InitRecov %s %d/d%d:i%d:r%d:or%d:%s\n",\r\nimp->imp_obd->obd_name, value,\r\nimp->imp_deactive, imp->imp_invalid,\r\nimp->imp_replayable, imp->imp_obd->obd_replayable,\r\nptlrpc_import_state_name(imp->imp_state));\r\nif ((imp->imp_state != LUSTRE_IMP_FULL &&\r\nimp->imp_state != LUSTRE_IMP_NEW) || value > 1)\r\nptlrpc_reconnect_import(imp);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_REGISTER_TARGET)) {\r\nstruct mgs_target_info *mti;\r\nif (vallen != sizeof(struct mgs_target_info))\r\nreturn -EINVAL;\r\nmti = (struct mgs_target_info *)val;\r\nCDEBUG(D_MGC, "register_target %s %#x\n",\r\nmti->mti_svname, mti->mti_flags);\r\nrc = mgc_target_register(exp, mti);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_SET_FS)) {\r\nstruct super_block *sb = (struct super_block *)val;\r\nstruct lustre_sb_info *lsi;\r\nif (vallen != sizeof(struct super_block))\r\nreturn -EINVAL;\r\nlsi = s2lsi(sb);\r\nrc = mgc_fs_setup(exp->exp_obd, sb, lsi->lsi_srv_mnt);\r\nif (rc) {\r\nCERROR("set_fs got %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_CLEAR_FS)) {\r\nif (vallen != 0)\r\nreturn -EINVAL;\r\nrc = mgc_fs_cleanup(exp->exp_obd);\r\nif (rc) {\r\nCERROR("clear_fs got %d\n", rc);\r\n}\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_SET_INFO)) {\r\nstruct mgs_send_param *msp;\r\nmsp = (struct mgs_send_param *)val;\r\nrc = mgc_set_mgs_param(exp, msp);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_MGSSEC)) {\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct sptlrpc_flavor flvr;\r\nif (vallen == 0) {\r\nif (cli->cl_flvr_mgc.sf_rpc != SPTLRPC_FLVR_INVALID)\r\nreturn 0;\r\nval = "null";\r\nvallen = 4;\r\n}\r\nrc = sptlrpc_parse_flavor(val, &flvr);\r\nif (rc) {\r\nCERROR("invalid sptlrpc flavor %s to MGS\n",\r\n(char *) val);\r\nreturn rc;\r\n}\r\nif (cli->cl_flvr_mgc.sf_rpc == SPTLRPC_FLVR_INVALID) {\r\ncli->cl_flvr_mgc = flvr;\r\n} else if (memcmp(&cli->cl_flvr_mgc, &flvr,\r\nsizeof(flvr)) != 0) {\r\nchar str[20];\r\nsptlrpc_flavor2name(&cli->cl_flvr_mgc,\r\nstr, sizeof(str));\r\nLCONSOLE_ERROR("asking sptlrpc flavor %s to MGS but "\r\n"currently %s is in use\n",\r\n(char *) val, str);\r\nrc = -EPERM;\r\n}\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_get_info(const struct lu_env *env, struct obd_export *exp,\r\n__u32 keylen, void *key, __u32 *vallen, void *val,\r\nstruct lov_stripe_md *unused)\r\n{\r\nint rc = -EINVAL;\r\nif (KEY_IS(KEY_CONN_DATA)) {\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct obd_connect_data *data = val;\r\nif (*vallen == sizeof(*data)) {\r\n*data = imp->imp_connect_data;\r\nrc = 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_import_event(struct obd_device *obd,\r\nstruct obd_import *imp,\r\nenum obd_import_event event)\r\n{\r\nint rc = 0;\r\nLASSERT(imp->imp_obd == obd);\r\nCDEBUG(D_MGC, "import event %#x\n", event);\r\nswitch (event) {\r\ncase IMP_EVENT_DISCON:\r\nif (OCD_HAS_FLAG(&imp->imp_connect_data, IMP_RECOV))\r\nptlrpc_pinger_ir_down();\r\nbreak;\r\ncase IMP_EVENT_INACTIVE:\r\nbreak;\r\ncase IMP_EVENT_INVALIDATE: {\r\nstruct ldlm_namespace *ns = obd->obd_namespace;\r\nldlm_namespace_cleanup(ns, LDLM_FL_LOCAL_ONLY);\r\nbreak;\r\n}\r\ncase IMP_EVENT_ACTIVE:\r\nCDEBUG(D_INFO, "%s: Reactivating import\n", obd->obd_name);\r\nobd->obd_no_recov = 0;\r\nmgc_notify_active(obd);\r\nif (OCD_HAS_FLAG(&imp->imp_connect_data, IMP_RECOV))\r\nptlrpc_pinger_ir_up();\r\nbreak;\r\ncase IMP_EVENT_OCD:\r\nbreak;\r\ncase IMP_EVENT_DEACTIVATE:\r\ncase IMP_EVENT_ACTIVATE:\r\nbreak;\r\ndefault:\r\nCERROR("Unknown import event %#x\n", event);\r\nLBUG();\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_llog_init(struct obd_device *obd, struct obd_llog_group *olg,\r\nstruct obd_device *tgt, int *index)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nLASSERT(olg == &obd->obd_olg);\r\nrc = llog_setup(NULL, obd, olg, LLOG_CONFIG_REPL_CTXT, tgt,\r\n&llog_client_ops);\r\nif (rc)\r\nGOTO(out, rc);\r\nctxt = llog_group_get_ctxt(olg, LLOG_CONFIG_REPL_CTXT);\r\nif (!ctxt)\r\nGOTO(out, rc = -ENODEV);\r\nllog_initiator_connect(ctxt);\r\nllog_ctxt_put(ctxt);\r\nreturn 0;\r\nout:\r\nctxt = llog_get_context(obd, LLOG_CONFIG_ORIG_CTXT);\r\nif (ctxt)\r\nllog_cleanup(NULL, ctxt);\r\nreturn rc;\r\n}\r\nstatic int mgc_llog_finish(struct obd_device *obd, int count)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nctxt = llog_get_context(obd, LLOG_CONFIG_REPL_CTXT);\r\nif (ctxt)\r\nllog_cleanup(NULL, ctxt);\r\nctxt = llog_get_context(obd, LLOG_CONFIG_ORIG_CTXT);\r\nif (ctxt)\r\nllog_cleanup(NULL, ctxt);\r\nreturn 0;\r\n}\r\nstatic int mgc_apply_recover_logs(struct obd_device *mgc,\r\nstruct config_llog_data *cld,\r\n__u64 max_version,\r\nvoid *data, int datalen, bool mne_swab)\r\n{\r\nstruct config_llog_instance *cfg = &cld->cld_cfg;\r\nstruct lustre_sb_info *lsi = s2lsi(cfg->cfg_sb);\r\nstruct mgs_nidtbl_entry *entry;\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs bufs;\r\nu64 prev_version = 0;\r\nchar *inst;\r\nchar *buf;\r\nint bufsz;\r\nint pos;\r\nint rc = 0;\r\nint off = 0;\r\nLASSERT(cfg->cfg_instance != NULL);\r\nLASSERT(cfg->cfg_sb == cfg->cfg_instance);\r\nOBD_ALLOC(inst, PAGE_CACHE_SIZE);\r\nif (inst == NULL)\r\nreturn -ENOMEM;\r\nif (!IS_SERVER(lsi)) {\r\npos = snprintf(inst, PAGE_CACHE_SIZE, "%p", cfg->cfg_instance);\r\nif (pos >= PAGE_CACHE_SIZE) {\r\nOBD_FREE(inst, PAGE_CACHE_SIZE);\r\nreturn -E2BIG;\r\n}\r\n} else {\r\nLASSERT(IS_MDT(lsi));\r\nrc = server_name2svname(lsi->lsi_svname, inst, NULL,\r\nPAGE_CACHE_SIZE);\r\nif (rc) {\r\nOBD_FREE(inst, PAGE_CACHE_SIZE);\r\nreturn -EINVAL;\r\n}\r\npos = strlen(inst);\r\n}\r\n++pos;\r\nbuf = inst + pos;\r\nbufsz = PAGE_CACHE_SIZE - pos;\r\nwhile (datalen > 0) {\r\nint entry_len = sizeof(*entry);\r\nint is_ost;\r\nstruct obd_device *obd;\r\nchar *obdname;\r\nchar *cname;\r\nchar *params;\r\nchar *uuid;\r\nrc = -EINVAL;\r\nif (datalen < sizeof(*entry))\r\nbreak;\r\nentry = (typeof(entry))(data + off);\r\nif (entry->mne_nid_type != 0)\r\nbreak;\r\nif (entry->mne_nid_count == 0)\r\nbreak;\r\nif (entry->mne_nid_size != sizeof(lnet_nid_t))\r\nbreak;\r\nentry_len += entry->mne_nid_count * entry->mne_nid_size;\r\nif (datalen < entry_len)\r\nbreak;\r\nif (mne_swab)\r\nlustre_swab_mgs_nidtbl_entry(entry);\r\nif (entry->mne_length > PAGE_CACHE_SIZE) {\r\nCERROR("MNE too large (%u)\n", entry->mne_length);\r\nbreak;\r\n}\r\nif (entry->mne_length < entry_len)\r\nbreak;\r\noff += entry->mne_length;\r\ndatalen -= entry->mne_length;\r\nif (datalen < 0)\r\nbreak;\r\nif (entry->mne_version > max_version) {\r\nCERROR("entry index(%lld) is over max_index(%lld)\n",\r\nentry->mne_version, max_version);\r\nbreak;\r\n}\r\nif (prev_version >= entry->mne_version) {\r\nCERROR("index unsorted, prev %lld, now %lld\n",\r\nprev_version, entry->mne_version);\r\nbreak;\r\n}\r\nprev_version = entry->mne_version;\r\nis_ost = entry->mne_type == LDD_F_SV_TYPE_OST;\r\nmemset(buf, 0, bufsz);\r\nobdname = buf;\r\npos = 0;\r\nstrcpy(obdname, cld->cld_logname);\r\ncname = strrchr(obdname, '-');\r\nif (cname == NULL) {\r\nCERROR("mgc %s: invalid logname %s\n",\r\nmgc->obd_name, obdname);\r\nbreak;\r\n}\r\npos = cname - obdname;\r\nobdname[pos] = 0;\r\npos += sprintf(obdname + pos, "-%s%04x",\r\nis_ost ? "OST" : "MDT", entry->mne_index);\r\ncname = is_ost ? "osc" : "mdc",\r\npos += sprintf(obdname + pos, "-%s-%s", cname, inst);\r\nlustre_cfg_bufs_reset(&bufs, obdname);\r\nobd = class_name2obd(obdname);\r\nif (obd == NULL) {\r\nCDEBUG(D_INFO, "mgc %s: cannot find obdname %s\n",\r\nmgc->obd_name, obdname);\r\nrc = 0;\r\ncontinue;\r\n}\r\n++pos;\r\nparams = buf + pos;\r\npos += sprintf(params, "%s.import=%s", cname, "connection=");\r\nuuid = buf + pos;\r\ndown_read(&obd->u.cli.cl_sem);\r\nif (obd->u.cli.cl_import == NULL) {\r\nup_read(&obd->u.cli.cl_sem);\r\nrc = 0;\r\ncontinue;\r\n}\r\nrc = client_import_find_conn(obd->u.cli.cl_import,\r\nentry->u.nids[0],\r\n(struct obd_uuid *)uuid);\r\nup_read(&obd->u.cli.cl_sem);\r\nif (rc < 0) {\r\nCERROR("mgc: cannot find uuid by nid %s\n",\r\nlibcfs_nid2str(entry->u.nids[0]));\r\nbreak;\r\n}\r\nCDEBUG(D_INFO, "Find uuid %s by nid %s\n",\r\nuuid, libcfs_nid2str(entry->u.nids[0]));\r\npos += strlen(uuid);\r\npos += sprintf(buf + pos, "::%u", entry->mne_instance);\r\nLASSERT(pos < bufsz);\r\nlustre_cfg_bufs_set_string(&bufs, 1, params);\r\nrc = -ENOMEM;\r\nlcfg = lustre_cfg_new(LCFG_PARAM, &bufs);\r\nif (lcfg == NULL) {\r\nCERROR("mgc: cannot allocate memory\n");\r\nbreak;\r\n}\r\nCDEBUG(D_INFO, "ir apply logs "LPD64"/"LPD64" for %s -> %s\n",\r\nprev_version, max_version, obdname, params);\r\nrc = class_process_config(lcfg);\r\nlustre_cfg_free(lcfg);\r\nif (rc)\r\nCDEBUG(D_INFO, "process config for %s error %d\n",\r\nobdname, rc);\r\n}\r\nOBD_FREE(inst, PAGE_CACHE_SIZE);\r\nreturn rc;\r\n}\r\nstatic int mgc_process_recover_log(struct obd_device *obd,\r\nstruct config_llog_data *cld)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nstruct config_llog_instance *cfg = &cld->cld_cfg;\r\nstruct mgs_config_body *body;\r\nstruct mgs_config_res *res;\r\nstruct ptlrpc_bulk_desc *desc;\r\nstruct page **pages;\r\nint nrpages;\r\nbool eof = true;\r\nbool mne_swab = false;\r\nint i;\r\nint ealen;\r\nint rc;\r\nnrpages = CONFIG_READ_NRPAGES;\r\nif (cfg->cfg_last_idx == 0)\r\nnrpages = CONFIG_READ_NRPAGES_INIT;\r\nOBD_ALLOC(pages, sizeof(*pages) * nrpages);\r\nif (pages == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nfor (i = 0; i < nrpages; i++) {\r\npages[i] = alloc_page(GFP_IOFS);\r\nif (pages[i] == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\n}\r\nagain:\r\nLASSERT(cld_is_recover(cld));\r\nLASSERT(mutex_is_locked(&cld->cld_lock));\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(cld->cld_mgcexp),\r\n&RQF_MGS_CONFIG_READ);\r\nif (req == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nrc = ptlrpc_request_pack(req, LUSTRE_MGS_VERSION, MGS_CONFIG_READ);\r\nif (rc)\r\nGOTO(out, rc);\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_MGS_CONFIG_BODY);\r\nLASSERT(body != NULL);\r\nLASSERT(sizeof(body->mcb_name) > strlen(cld->cld_logname));\r\nif (strlcpy(body->mcb_name, cld->cld_logname, sizeof(body->mcb_name))\r\n>= sizeof(body->mcb_name))\r\nGOTO(out, rc = -E2BIG);\r\nbody->mcb_offset = cfg->cfg_last_idx + 1;\r\nbody->mcb_type = cld->cld_type;\r\nbody->mcb_bits = PAGE_CACHE_SHIFT;\r\nbody->mcb_units = nrpages;\r\ndesc = ptlrpc_prep_bulk_imp(req, nrpages, 1, BULK_PUT_SINK,\r\nMGS_BULK_PORTAL);\r\nif (desc == NULL)\r\nGOTO(out, rc = -ENOMEM);\r\nfor (i = 0; i < nrpages; i++)\r\nptlrpc_prep_bulk_page_pin(desc, pages[i], 0, PAGE_CACHE_SIZE);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\nGOTO(out, rc);\r\nres = req_capsule_server_get(&req->rq_pill, &RMF_MGS_CONFIG_RES);\r\nif (res->mcr_size < res->mcr_offset)\r\nGOTO(out, rc = -EINVAL);\r\ncfg->cfg_last_idx = res->mcr_offset;\r\neof = res->mcr_offset == res->mcr_size;\r\nCDEBUG(D_INFO, "Latest version "LPD64", more %d.\n",\r\nres->mcr_offset, eof == false);\r\nealen = sptlrpc_cli_unwrap_bulk_read(req, req->rq_bulk, 0);\r\nif (ealen < 0)\r\nGOTO(out, rc = ealen);\r\nif (ealen > nrpages << PAGE_CACHE_SHIFT)\r\nGOTO(out, rc = -EINVAL);\r\nif (ealen == 0) {\r\nif (!eof)\r\nrc = -EINVAL;\r\nGOTO(out, rc);\r\n}\r\nmne_swab = !!ptlrpc_rep_need_swab(req);\r\n#if LUSTRE_VERSION_CODE < OBD_OCD_VERSION(3, 2, 50, 0)\r\nif (unlikely(req->rq_import->imp_need_mne_swab))\r\nmne_swab = !mne_swab;\r\n#else\r\n#warning "LU-1644: Remove old OBD_CONNECT_MNE_SWAB fixup and imp_need_mne_swab"\r\n#endif\r\nfor (i = 0; i < nrpages && ealen > 0; i++) {\r\nint rc2;\r\nvoid *ptr;\r\nptr = kmap(pages[i]);\r\nrc2 = mgc_apply_recover_logs(obd, cld, res->mcr_offset, ptr,\r\nmin_t(int, ealen, PAGE_CACHE_SIZE),\r\nmne_swab);\r\nkunmap(pages[i]);\r\nif (rc2 < 0) {\r\nCWARN("Process recover log %s error %d\n",\r\ncld->cld_logname, rc2);\r\nbreak;\r\n}\r\nealen -= PAGE_CACHE_SIZE;\r\n}\r\nout:\r\nif (req)\r\nptlrpc_req_finished(req);\r\nif (rc == 0 && !eof)\r\ngoto again;\r\nif (pages) {\r\nfor (i = 0; i < nrpages; i++) {\r\nif (pages[i] == NULL)\r\nbreak;\r\n__free_page(pages[i]);\r\n}\r\nOBD_FREE(pages, sizeof(*pages) * nrpages);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_process_cfg_log(struct obd_device *mgc,\r\nstruct config_llog_data *cld,\r\nint local_only)\r\n{\r\nstruct llog_ctxt *ctxt, *lctxt = NULL;\r\nstruct lvfs_run_ctxt *saved_ctxt;\r\nstruct lustre_sb_info *lsi = NULL;\r\nint rc = 0, must_pop = 0;\r\nbool sptlrpc_started = false;\r\nLASSERT(cld);\r\nLASSERT(mutex_is_locked(&cld->cld_lock));\r\nif (cld_is_sptlrpc(cld) && local_only)\r\nreturn 0;\r\nif (cld->cld_cfg.cfg_sb)\r\nlsi = s2lsi(cld->cld_cfg.cfg_sb);\r\nctxt = llog_get_context(mgc, LLOG_CONFIG_REPL_CTXT);\r\nif (!ctxt) {\r\nCERROR("missing llog context\n");\r\nreturn -EINVAL;\r\n}\r\nOBD_ALLOC_PTR(saved_ctxt);\r\nif (saved_ctxt == NULL)\r\nreturn -ENOMEM;\r\nlctxt = llog_get_context(mgc, LLOG_CONFIG_ORIG_CTXT);\r\nif (local_only) {\r\nGOTO(out_pop, rc = -EIO);\r\n}\r\nif (cld_is_sptlrpc(cld)) {\r\nsptlrpc_conf_log_update_begin(cld->cld_logname);\r\nsptlrpc_started = true;\r\n}\r\nrc = class_config_parse_llog(NULL, ctxt, cld->cld_logname,\r\n&cld->cld_cfg);\r\nout_pop:\r\nllog_ctxt_put(ctxt);\r\nif (lctxt)\r\nllog_ctxt_put(lctxt);\r\nif (must_pop)\r\npop_ctxt(saved_ctxt, &mgc->obd_lvfs_ctxt, NULL);\r\nOBD_FREE_PTR(saved_ctxt);\r\nif (sptlrpc_started) {\r\nLASSERT(cld_is_sptlrpc(cld));\r\nsptlrpc_conf_log_update_end(cld->cld_logname);\r\nclass_notify_sptlrpc_conf(cld->cld_logname,\r\nstrlen(cld->cld_logname) -\r\nstrlen("-sptlrpc"));\r\n}\r\nreturn rc;\r\n}\r\nint mgc_process_log(struct obd_device *mgc, struct config_llog_data *cld)\r\n{\r\nstruct lustre_handle lockh = { 0 };\r\n__u64 flags = LDLM_FL_NO_LRU;\r\nint rc = 0, rcl;\r\nLASSERT(cld);\r\nmutex_lock(&cld->cld_lock);\r\nif (cld->cld_stopping) {\r\nmutex_unlock(&cld->cld_lock);\r\nreturn 0;\r\n}\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_MGC_PAUSE_PROCESS_LOG, 20);\r\nCDEBUG(D_MGC, "Process log %s:%p from %d\n", cld->cld_logname,\r\ncld->cld_cfg.cfg_instance, cld->cld_cfg.cfg_last_idx + 1);\r\nrcl = mgc_enqueue(mgc->u.cli.cl_mgc_mgsexp, NULL, LDLM_PLAIN, NULL,\r\nLCK_CR, &flags, NULL, NULL, NULL,\r\ncld, 0, NULL, &lockh);\r\nif (rcl == 0) {\r\nconfig_log_get(cld);\r\nrc = ldlm_lock_set_data(&lockh, (void *)cld);\r\nLASSERT(rc == 0);\r\n} else {\r\nCDEBUG(D_MGC, "Can't get cfg lock: %d\n", rcl);\r\ncld->cld_lostlock = 1;\r\nconfig_log_get(cld);\r\n}\r\nif (cld_is_recover(cld)) {\r\nrc = 0;\r\nif (rcl == 0)\r\nrc = mgc_process_recover_log(mgc, cld);\r\n} else {\r\nrc = mgc_process_cfg_log(mgc, cld, rcl != 0);\r\n}\r\nCDEBUG(D_MGC, "%s: configuration from log '%s' %sed (%d).\n",\r\nmgc->obd_name, cld->cld_logname, rc ? "fail" : "succeed", rc);\r\nmutex_unlock(&cld->cld_lock);\r\nif (!rcl) {\r\nrcl = mgc_cancel(mgc->u.cli.cl_mgc_mgsexp, NULL,\r\nLCK_CR, &lockh);\r\nif (rcl)\r\nCERROR("Can't drop cfg lock: %d\n", rcl);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_process_config(struct obd_device *obd, obd_count len, void *buf)\r\n{\r\nstruct lustre_cfg *lcfg = buf;\r\nstruct config_llog_instance *cfg = NULL;\r\nchar *logname;\r\nint rc = 0;\r\nswitch(lcfg->lcfg_command) {\r\ncase LCFG_LOV_ADD_OBD: {\r\nstruct mgs_target_info *mti;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) !=\r\nsizeof(struct mgs_target_info))\r\nGOTO(out, rc = -EINVAL);\r\nmti = (struct mgs_target_info *)lustre_cfg_buf(lcfg, 1);\r\nCDEBUG(D_MGC, "add_target %s %#x\n",\r\nmti->mti_svname, mti->mti_flags);\r\nrc = mgc_target_register(obd->u.cli.cl_mgc_mgsexp, mti);\r\nbreak;\r\n}\r\ncase LCFG_LOV_DEL_OBD:\r\nCERROR("lov_del_obd unimplemented\n");\r\nrc = -ENOSYS;\r\nbreak;\r\ncase LCFG_SPTLRPC_CONF: {\r\nrc = sptlrpc_process_config(lcfg);\r\nbreak;\r\n}\r\ncase LCFG_LOG_START: {\r\nstruct config_llog_data *cld;\r\nstruct super_block *sb;\r\nlogname = lustre_cfg_string(lcfg, 1);\r\ncfg = (struct config_llog_instance *)lustre_cfg_buf(lcfg, 2);\r\nsb = *(struct super_block **)lustre_cfg_buf(lcfg, 3);\r\nCDEBUG(D_MGC, "parse_log %s from %d\n", logname,\r\ncfg->cfg_last_idx);\r\nrc = config_log_add(obd, logname, cfg, sb);\r\nif (rc)\r\nbreak;\r\ncld = config_log_find(logname, cfg);\r\nif (cld == NULL) {\r\nrc = -ENOENT;\r\nbreak;\r\n}\r\ncld->cld_cfg.cfg_flags |= CFG_F_COMPAT146;\r\nrc = mgc_process_log(obd, cld);\r\nif (rc == 0 && cld->cld_recover != NULL) {\r\nif (OCD_HAS_FLAG(&obd->u.cli.cl_import->\r\nimp_connect_data, IMP_RECOV)) {\r\nrc = mgc_process_log(obd, cld->cld_recover);\r\n} else {\r\nstruct config_llog_data *cir = cld->cld_recover;\r\ncld->cld_recover = NULL;\r\nconfig_log_put(cir);\r\n}\r\nif (rc)\r\nCERROR("Cannot process recover llog %d\n", rc);\r\n}\r\nconfig_log_put(cld);\r\nbreak;\r\n}\r\ncase LCFG_LOG_END: {\r\nlogname = lustre_cfg_string(lcfg, 1);\r\nif (lcfg->lcfg_bufcount >= 2)\r\ncfg = (struct config_llog_instance *)lustre_cfg_buf(\r\nlcfg, 2);\r\nrc = config_log_end(logname, cfg);\r\nbreak;\r\n}\r\ndefault: {\r\nCERROR("Unknown command: %d\n", lcfg->lcfg_command);\r\nGOTO(out, rc = -EINVAL);\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint __init mgc_init(void)\r\n{\r\nreturn class_register_type(&mgc_obd_ops, NULL, NULL,\r\nLUSTRE_MGC_NAME, NULL);\r\n}\r\nstatic void mgc_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_MGC_NAME);\r\n}
