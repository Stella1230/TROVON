int m5602_read_bridge(struct sd *sd, const u8 address, u8 *i2c_data)\r\n{\r\nint err;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nerr = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\r\n0x04, 0xc0, 0x14,\r\n0x8100 + address, buf,\r\n1, M5602_URB_MSG_TIMEOUT);\r\n*i2c_data = buf[0];\r\nPDEBUG(D_CONF, "Reading bridge register 0x%x containing 0x%x",\r\naddress, *i2c_data);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nint m5602_write_bridge(struct sd *sd, const u8 address, const u8 i2c_data)\r\n{\r\nint err;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nPDEBUG(D_CONF, "Writing bridge register 0x%x with 0x%x",\r\naddress, i2c_data);\r\nmemcpy(buf, bridge_urb_skeleton,\r\nsizeof(bridge_urb_skeleton));\r\nbuf[1] = address;\r\nbuf[3] = i2c_data;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, 0x19,\r\n0x0000, buf,\r\n4, M5602_URB_MSG_TIMEOUT);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic int m5602_wait_for_i2c(struct sd *sd)\r\n{\r\nint err;\r\nu8 data;\r\ndo {\r\nerr = m5602_read_bridge(sd, M5602_XB_I2C_STATUS, &data);\r\n} while ((data & I2C_BUSY) && !err);\r\nreturn err;\r\n}\r\nint m5602_read_sensor(struct sd *sd, const u8 address,\r\nu8 *i2c_data, const u8 len)\r\n{\r\nint err, i;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\r\nif (!len || len > sd->sensor->i2c_regW)\r\nreturn -EINVAL;\r\nerr = m5602_wait_for_i2c(sd);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_I2C_DEV_ADDR,\r\nsd->sensor->i2c_slave_id);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_I2C_REG_ADDR, address);\r\nif (err < 0)\r\nreturn err;\r\nif (sd->sensor->i2c_regW == 1) {\r\nerr = m5602_write_bridge(sd, M5602_XB_I2C_CTRL, 1);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_write_bridge(sd, M5602_XB_I2C_CTRL, 0x08);\r\n} else {\r\nerr = m5602_write_bridge(sd, M5602_XB_I2C_CTRL, 0x18 + len);\r\n}\r\nfor (i = 0; (i < len) && !err; i++) {\r\nerr = m5602_wait_for_i2c(sd);\r\nif (err < 0)\r\nreturn err;\r\nerr = m5602_read_bridge(sd, M5602_XB_I2C_DATA, &(i2c_data[i]));\r\nPDEBUG(D_CONF, "Reading sensor register "\r\n"0x%x containing 0x%x ", address, *i2c_data);\r\n}\r\nreturn err;\r\n}\r\nint m5602_write_sensor(struct sd *sd, const u8 address,\r\nu8 *i2c_data, const u8 len)\r\n{\r\nint err, i;\r\nu8 *p;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *) sd;\r\nstruct usb_device *udev = sd->gspca_dev.dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nif (len > sd->sensor->i2c_regW || !len)\r\nreturn -EINVAL;\r\nmemcpy(buf, sensor_urb_skeleton,\r\nsizeof(sensor_urb_skeleton));\r\nbuf[11] = sd->sensor->i2c_slave_id;\r\nbuf[15] = address;\r\np = buf + 16;\r\nfor (i = 0; i < len; i++) {\r\nmemcpy(p, sensor_urb_skeleton + 16, 4);\r\np[3] = i2c_data[i];\r\np += 4;\r\nPDEBUG(D_CONF, "Writing sensor register 0x%x with 0x%x",\r\naddress, i2c_data[i]);\r\n}\r\nmemcpy(p, sensor_urb_skeleton + 20, 4);\r\np[3] = 0x10 + len;\r\nerr = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\r\n0x04, 0x40, 0x19,\r\n0x0000, buf,\r\n20 + len * 4, M5602_URB_MSG_TIMEOUT);\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic void m5602_dump_bridge(struct sd *sd)\r\n{\r\nint i;\r\nfor (i = 0; i < 0x80; i++) {\r\nunsigned char val = 0;\r\nm5602_read_bridge(sd, i, &val);\r\npr_info("ALi m5602 address 0x%x contains 0x%x\n", i, val);\r\n}\r\npr_info("Warning: The ALi m5602 webcam probably won't work until it's power cycled\n");\r\n}\r\nstatic int m5602_probe_sensor(struct sd *sd)\r\n{\r\nsd->sensor = &po1030;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &mt9m111;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &s5k4aa;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &ov9650;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &ov7660;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\nsd->sensor = &s5k83a;\r\nif (!sd->sensor->probe(sd))\r\nreturn 0;\r\npr_info("Failed to find a sensor\n");\r\nsd->sensor = NULL;\r\nreturn -ENODEV;\r\n}\r\nstatic int m5602_init(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint err;\r\nPDEBUG(D_CONF, "Initializing ALi m5602 webcam");\r\nerr = sd->sensor->init(sd);\r\nreturn err;\r\n}\r\nstatic int m5602_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (!sd->sensor->init_controls)\r\nreturn 0;\r\nreturn sd->sensor->init_controls(sd);\r\n}\r\nstatic int m5602_start_transfer(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\n__u8 *buf = sd->gspca_dev.usb_buf;\r\nint err;\r\nconst u8 buffer[4] = {0x13, 0xf9, 0x0f, 0x01};\r\nif (sd->sensor->start)\r\nsd->sensor->start(sd);\r\nmemcpy(buf, buffer, sizeof(buffer));\r\nerr = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\n0x04, 0x40, 0x19, 0x0000, buf,\r\nsizeof(buffer), M5602_URB_MSG_TIMEOUT);\r\nPDEBUG(D_STREAM, "Transfer started");\r\nreturn (err < 0) ? err : 0;\r\n}\r\nstatic void m5602_urb_complete(struct gspca_dev *gspca_dev,\r\nu8 *data, int len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (len < 6) {\r\nPDEBUG(D_PACK, "Packet is less than 6 bytes");\r\nreturn;\r\n}\r\nif (data[0] == 0xff && data[4] == 0xff && data[5] == 0xff &&\r\ndata[2] != sd->frame_id) {\r\nPDEBUG(D_FRAM, "Frame delimiter detected");\r\nsd->frame_id = data[2];\r\ndata += 6;\r\nlen -= 6;\r\ngspca_frame_add(gspca_dev, LAST_PACKET,\r\nNULL, 0);\r\nsd->frame_count++;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET, data, len);\r\nPDEBUG(D_FRAM, "Starting new frame %d",\r\nsd->frame_count);\r\n} else {\r\nint cur_frame_len;\r\ncur_frame_len = gspca_dev->image_len;\r\ndata += 4;\r\nlen -= 4;\r\nif (cur_frame_len + len <= gspca_dev->frsz) {\r\nPDEBUG(D_FRAM, "Continuing frame %d copying %d bytes",\r\nsd->frame_count, len);\r\ngspca_frame_add(gspca_dev, INTER_PACKET,\r\ndata, len);\r\n} else {\r\ngspca_frame_add(gspca_dev, INTER_PACKET, data,\r\ngspca_dev->frsz - cur_frame_len);\r\n}\r\n}\r\n}\r\nstatic void m5602_stop_transfer(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor->stop)\r\nsd->sensor->stop(sd);\r\n}\r\nstatic int m5602_configure(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct cam *cam;\r\nint err;\r\ncam = &gspca_dev->cam;\r\nif (dump_bridge)\r\nm5602_dump_bridge(sd);\r\nerr = m5602_probe_sensor(sd);\r\nif (err)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nPERR("ALi m5602 webcam failed");\r\ncam->cam_mode = NULL;\r\ncam->nmodes = 0;\r\nreturn err;\r\n}\r\nstatic int m5602_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}\r\nstatic void m5602_disconnect(struct usb_interface *intf)\r\n{\r\nstruct gspca_dev *gspca_dev = usb_get_intfdata(intf);\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->sensor->disconnect)\r\nsd->sensor->disconnect(sd);\r\ngspca_disconnect(intf);\r\n}
