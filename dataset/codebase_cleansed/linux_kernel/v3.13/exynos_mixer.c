static inline u32 vp_reg_read(struct mixer_resources *res, u32 reg_id)\r\n{\r\nreturn readl(res->vp_regs + reg_id);\r\n}\r\nstatic inline void vp_reg_write(struct mixer_resources *res, u32 reg_id,\r\nu32 val)\r\n{\r\nwritel(val, res->vp_regs + reg_id);\r\n}\r\nstatic inline void vp_reg_writemask(struct mixer_resources *res, u32 reg_id,\r\nu32 val, u32 mask)\r\n{\r\nu32 old = vp_reg_read(res, reg_id);\r\nval = (val & mask) | (old & ~mask);\r\nwritel(val, res->vp_regs + reg_id);\r\n}\r\nstatic inline u32 mixer_reg_read(struct mixer_resources *res, u32 reg_id)\r\n{\r\nreturn readl(res->mixer_regs + reg_id);\r\n}\r\nstatic inline void mixer_reg_write(struct mixer_resources *res, u32 reg_id,\r\nu32 val)\r\n{\r\nwritel(val, res->mixer_regs + reg_id);\r\n}\r\nstatic inline void mixer_reg_writemask(struct mixer_resources *res,\r\nu32 reg_id, u32 val, u32 mask)\r\n{\r\nu32 old = mixer_reg_read(res, reg_id);\r\nval = (val & mask) | (old & ~mask);\r\nwritel(val, res->mixer_regs + reg_id);\r\n}\r\nstatic void mixer_regs_dump(struct mixer_context *ctx)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndo { \\r\nDRM_DEBUG_KMS(#reg_id " = %08x\n", \\r\n(u32)readl(ctx->mixer_res.mixer_regs + reg_id)); \\r\n} while (0)\r\nDUMPREG(MXR_STATUS);\r\nDUMPREG(MXR_CFG);\r\nDUMPREG(MXR_INT_EN);\r\nDUMPREG(MXR_INT_STATUS);\r\nDUMPREG(MXR_LAYER_CFG);\r\nDUMPREG(MXR_VIDEO_CFG);\r\nDUMPREG(MXR_GRAPHIC0_CFG);\r\nDUMPREG(MXR_GRAPHIC0_BASE);\r\nDUMPREG(MXR_GRAPHIC0_SPAN);\r\nDUMPREG(MXR_GRAPHIC0_WH);\r\nDUMPREG(MXR_GRAPHIC0_SXY);\r\nDUMPREG(MXR_GRAPHIC0_DXY);\r\nDUMPREG(MXR_GRAPHIC1_CFG);\r\nDUMPREG(MXR_GRAPHIC1_BASE);\r\nDUMPREG(MXR_GRAPHIC1_SPAN);\r\nDUMPREG(MXR_GRAPHIC1_WH);\r\nDUMPREG(MXR_GRAPHIC1_SXY);\r\nDUMPREG(MXR_GRAPHIC1_DXY);\r\n#undef DUMPREG\r\n}\r\nstatic void vp_regs_dump(struct mixer_context *ctx)\r\n{\r\n#define DUMPREG(reg_id) \\r\ndo { \\r\nDRM_DEBUG_KMS(#reg_id " = %08x\n", \\r\n(u32) readl(ctx->mixer_res.vp_regs + reg_id)); \\r\n} while (0)\r\nDUMPREG(VP_ENABLE);\r\nDUMPREG(VP_SRESET);\r\nDUMPREG(VP_SHADOW_UPDATE);\r\nDUMPREG(VP_FIELD_ID);\r\nDUMPREG(VP_MODE);\r\nDUMPREG(VP_IMG_SIZE_Y);\r\nDUMPREG(VP_IMG_SIZE_C);\r\nDUMPREG(VP_PER_RATE_CTRL);\r\nDUMPREG(VP_TOP_Y_PTR);\r\nDUMPREG(VP_BOT_Y_PTR);\r\nDUMPREG(VP_TOP_C_PTR);\r\nDUMPREG(VP_BOT_C_PTR);\r\nDUMPREG(VP_ENDIAN_MODE);\r\nDUMPREG(VP_SRC_H_POSITION);\r\nDUMPREG(VP_SRC_V_POSITION);\r\nDUMPREG(VP_SRC_WIDTH);\r\nDUMPREG(VP_SRC_HEIGHT);\r\nDUMPREG(VP_DST_H_POSITION);\r\nDUMPREG(VP_DST_V_POSITION);\r\nDUMPREG(VP_DST_WIDTH);\r\nDUMPREG(VP_DST_HEIGHT);\r\nDUMPREG(VP_H_RATIO);\r\nDUMPREG(VP_V_RATIO);\r\n#undef DUMPREG\r\n}\r\nstatic inline void vp_filter_set(struct mixer_resources *res,\r\nint reg_id, const u8 *data, unsigned int size)\r\n{\r\nBUG_ON(size & 3);\r\nfor (; size; size -= 4, reg_id += 4, data += 4) {\r\nu32 val = (data[0] << 24) | (data[1] << 16) |\r\n(data[2] << 8) | data[3];\r\nvp_reg_write(res, reg_id, val);\r\n}\r\n}\r\nstatic void vp_default_filter(struct mixer_resources *res)\r\n{\r\nvp_filter_set(res, VP_POLY8_Y0_LL,\r\nfilter_y_horiz_tap8, sizeof(filter_y_horiz_tap8));\r\nvp_filter_set(res, VP_POLY4_Y0_LL,\r\nfilter_y_vert_tap4, sizeof(filter_y_vert_tap4));\r\nvp_filter_set(res, VP_POLY4_C0_LL,\r\nfilter_cr_horiz_tap4, sizeof(filter_cr_horiz_tap4));\r\n}\r\nstatic void mixer_vsync_set_update(struct mixer_context *ctx, bool enable)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmixer_reg_writemask(res, MXR_STATUS, enable ?\r\nMXR_STATUS_SYNC_ENABLE : 0, MXR_STATUS_SYNC_ENABLE);\r\nif (ctx->vp_enabled)\r\nvp_reg_write(res, VP_SHADOW_UPDATE, enable ?\r\nVP_SHADOW_UPDATE_ENABLE : 0);\r\n}\r\nstatic void mixer_cfg_scan(struct mixer_context *ctx, unsigned int height)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nval = (ctx->interlace ? MXR_CFG_SCAN_INTERLACE :\r\nMXR_CFG_SCAN_PROGRASSIVE);\r\nif (ctx->mxr_ver != MXR_VER_128_0_0_184) {\r\nif (height <= 480)\r\nval |= MXR_CFG_SCAN_NTSC | MXR_CFG_SCAN_SD;\r\nelse if (height <= 576)\r\nval |= MXR_CFG_SCAN_PAL | MXR_CFG_SCAN_SD;\r\nelse if (height <= 720)\r\nval |= MXR_CFG_SCAN_HD_720 | MXR_CFG_SCAN_HD;\r\nelse if (height <= 1080)\r\nval |= MXR_CFG_SCAN_HD_1080 | MXR_CFG_SCAN_HD;\r\nelse\r\nval |= MXR_CFG_SCAN_HD_720 | MXR_CFG_SCAN_HD;\r\n}\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_SCAN_MASK);\r\n}\r\nstatic void mixer_cfg_rgb_fmt(struct mixer_context *ctx, unsigned int height)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nif (height == 480) {\r\nval = MXR_CFG_RGB601_0_255;\r\n} else if (height == 576) {\r\nval = MXR_CFG_RGB601_0_255;\r\n} else if (height == 720) {\r\nval = MXR_CFG_RGB709_16_235;\r\nmixer_reg_write(res, MXR_CM_COEFF_Y,\r\n(1 << 30) | (94 << 20) | (314 << 10) |\r\n(32 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CB,\r\n(972 << 20) | (851 << 10) | (225 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CR,\r\n(225 << 20) | (820 << 10) | (1004 << 0));\r\n} else if (height == 1080) {\r\nval = MXR_CFG_RGB709_16_235;\r\nmixer_reg_write(res, MXR_CM_COEFF_Y,\r\n(1 << 30) | (94 << 20) | (314 << 10) |\r\n(32 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CB,\r\n(972 << 20) | (851 << 10) | (225 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CR,\r\n(225 << 20) | (820 << 10) | (1004 << 0));\r\n} else {\r\nval = MXR_CFG_RGB709_16_235;\r\nmixer_reg_write(res, MXR_CM_COEFF_Y,\r\n(1 << 30) | (94 << 20) | (314 << 10) |\r\n(32 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CB,\r\n(972 << 20) | (851 << 10) | (225 << 0));\r\nmixer_reg_write(res, MXR_CM_COEFF_CR,\r\n(225 << 20) | (820 << 10) | (1004 << 0));\r\n}\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_RGB_FMT_MASK);\r\n}\r\nstatic void mixer_cfg_layer(struct mixer_context *ctx, int win, bool enable)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val = enable ? ~0 : 0;\r\nswitch (win) {\r\ncase 0:\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_GRP0_ENABLE);\r\nbreak;\r\ncase 1:\r\nmixer_reg_writemask(res, MXR_CFG, val, MXR_CFG_GRP1_ENABLE);\r\nbreak;\r\ncase 2:\r\nif (ctx->vp_enabled) {\r\nvp_reg_writemask(res, VP_ENABLE, val, VP_ENABLE_ON);\r\nmixer_reg_writemask(res, MXR_CFG, val,\r\nMXR_CFG_VP_ENABLE);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void mixer_run(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmixer_reg_writemask(res, MXR_STATUS, ~0, MXR_STATUS_REG_RUN);\r\nmixer_regs_dump(ctx);\r\n}\r\nstatic void vp_video_buffer(struct mixer_context *ctx, int win)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nunsigned long flags;\r\nstruct hdmi_win_data *win_data;\r\nunsigned int x_ratio, y_ratio;\r\nunsigned int buf_num = 1;\r\ndma_addr_t luma_addr[2], chroma_addr[2];\r\nbool tiled_mode = false;\r\nbool crcb_mode = false;\r\nu32 val;\r\nwin_data = &ctx->win_data[win];\r\nswitch (win_data->pixel_format) {\r\ncase DRM_FORMAT_NV12MT:\r\ntiled_mode = true;\r\ncase DRM_FORMAT_NV12:\r\ncrcb_mode = false;\r\nbuf_num = 2;\r\nbreak;\r\ndefault:\r\nif (!win_data->dma_addr)\r\nbreak;\r\nDRM_ERROR("pixel format for vp is wrong [%d].\n",\r\nwin_data->pixel_format);\r\nreturn;\r\n}\r\nx_ratio = (win_data->src_width << 16) / win_data->crtc_width;\r\ny_ratio = (win_data->src_height << 16) / win_data->crtc_height;\r\nif (buf_num == 2) {\r\nluma_addr[0] = win_data->dma_addr;\r\nchroma_addr[0] = win_data->chroma_dma_addr;\r\n} else {\r\nluma_addr[0] = win_data->dma_addr;\r\nchroma_addr[0] = win_data->dma_addr\r\n+ (win_data->fb_width * win_data->fb_height);\r\n}\r\nif (win_data->scan_flags & DRM_MODE_FLAG_INTERLACE) {\r\nctx->interlace = true;\r\nif (tiled_mode) {\r\nluma_addr[1] = luma_addr[0] + 0x40;\r\nchroma_addr[1] = chroma_addr[0] + 0x40;\r\n} else {\r\nluma_addr[1] = luma_addr[0] + win_data->fb_width;\r\nchroma_addr[1] = chroma_addr[0] + win_data->fb_width;\r\n}\r\n} else {\r\nctx->interlace = false;\r\nluma_addr[1] = 0;\r\nchroma_addr[1] = 0;\r\n}\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_vsync_set_update(ctx, false);\r\nval = (ctx->interlace ? ~0 : 0);\r\nvp_reg_writemask(res, VP_MODE, val, VP_MODE_LINE_SKIP);\r\nval = (crcb_mode ? VP_MODE_NV21 : VP_MODE_NV12);\r\nval |= (tiled_mode ? VP_MODE_MEM_TILED : VP_MODE_MEM_LINEAR);\r\nvp_reg_writemask(res, VP_MODE, val, VP_MODE_FMT_MASK);\r\nvp_reg_write(res, VP_IMG_SIZE_Y, VP_IMG_HSIZE(win_data->fb_width) |\r\nVP_IMG_VSIZE(win_data->fb_height));\r\nvp_reg_write(res, VP_IMG_SIZE_C, VP_IMG_HSIZE(win_data->fb_width) |\r\nVP_IMG_VSIZE(win_data->fb_height / 2));\r\nvp_reg_write(res, VP_SRC_WIDTH, win_data->src_width);\r\nvp_reg_write(res, VP_SRC_HEIGHT, win_data->src_height);\r\nvp_reg_write(res, VP_SRC_H_POSITION,\r\nVP_SRC_H_POSITION_VAL(win_data->fb_x));\r\nvp_reg_write(res, VP_SRC_V_POSITION, win_data->fb_y);\r\nvp_reg_write(res, VP_DST_WIDTH, win_data->crtc_width);\r\nvp_reg_write(res, VP_DST_H_POSITION, win_data->crtc_x);\r\nif (ctx->interlace) {\r\nvp_reg_write(res, VP_DST_HEIGHT, win_data->crtc_height / 2);\r\nvp_reg_write(res, VP_DST_V_POSITION, win_data->crtc_y / 2);\r\n} else {\r\nvp_reg_write(res, VP_DST_HEIGHT, win_data->crtc_height);\r\nvp_reg_write(res, VP_DST_V_POSITION, win_data->crtc_y);\r\n}\r\nvp_reg_write(res, VP_H_RATIO, x_ratio);\r\nvp_reg_write(res, VP_V_RATIO, y_ratio);\r\nvp_reg_write(res, VP_ENDIAN_MODE, VP_ENDIAN_MODE_LITTLE);\r\nvp_reg_write(res, VP_TOP_Y_PTR, luma_addr[0]);\r\nvp_reg_write(res, VP_BOT_Y_PTR, luma_addr[1]);\r\nvp_reg_write(res, VP_TOP_C_PTR, chroma_addr[0]);\r\nvp_reg_write(res, VP_BOT_C_PTR, chroma_addr[1]);\r\nmixer_cfg_scan(ctx, win_data->mode_height);\r\nmixer_cfg_rgb_fmt(ctx, win_data->mode_height);\r\nmixer_cfg_layer(ctx, win, true);\r\nmixer_run(ctx);\r\nmixer_vsync_set_update(ctx, true);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\nvp_regs_dump(ctx);\r\n}\r\nstatic void mixer_layer_update(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val;\r\nval = mixer_reg_read(res, MXR_CFG);\r\nif (!(val & MXR_CFG_LAYER_UPDATE_COUNT_MASK))\r\nmixer_reg_writemask(res, MXR_CFG, ~0, MXR_CFG_LAYER_UPDATE);\r\n}\r\nstatic void mixer_graph_buffer(struct mixer_context *ctx, int win)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nunsigned long flags;\r\nstruct hdmi_win_data *win_data;\r\nunsigned int x_ratio, y_ratio;\r\nunsigned int src_x_offset, src_y_offset, dst_x_offset, dst_y_offset;\r\ndma_addr_t dma_addr;\r\nunsigned int fmt;\r\nu32 val;\r\nwin_data = &ctx->win_data[win];\r\n#define RGB565 4\r\n#define ARGB1555 5\r\n#define ARGB4444 6\r\n#define ARGB8888 7\r\nswitch (win_data->bpp) {\r\ncase 16:\r\nfmt = ARGB4444;\r\nbreak;\r\ncase 32:\r\nfmt = ARGB8888;\r\nbreak;\r\ndefault:\r\nfmt = ARGB8888;\r\n}\r\nx_ratio = 0;\r\ny_ratio = 0;\r\ndst_x_offset = win_data->crtc_x;\r\ndst_y_offset = win_data->crtc_y;\r\ndma_addr = win_data->dma_addr\r\n+ (win_data->fb_x * win_data->bpp >> 3)\r\n+ (win_data->fb_y * win_data->fb_width * win_data->bpp >> 3);\r\nsrc_x_offset = 0;\r\nsrc_y_offset = 0;\r\nif (win_data->scan_flags & DRM_MODE_FLAG_INTERLACE)\r\nctx->interlace = true;\r\nelse\r\nctx->interlace = false;\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_vsync_set_update(ctx, false);\r\nmixer_reg_writemask(res, MXR_GRAPHIC_CFG(win),\r\nMXR_GRP_CFG_FORMAT_VAL(fmt), MXR_GRP_CFG_FORMAT_MASK);\r\nmixer_reg_write(res, MXR_GRAPHIC_SPAN(win), win_data->fb_width);\r\nif (ctx->mxr_ver == MXR_VER_128_0_0_184 &&\r\nwin == MIXER_DEFAULT_WIN) {\r\nval = MXR_MXR_RES_HEIGHT(win_data->fb_height);\r\nval |= MXR_MXR_RES_WIDTH(win_data->fb_width);\r\nmixer_reg_write(res, MXR_RESOLUTION, val);\r\n}\r\nval = MXR_GRP_WH_WIDTH(win_data->crtc_width);\r\nval |= MXR_GRP_WH_HEIGHT(win_data->crtc_height);\r\nval |= MXR_GRP_WH_H_SCALE(x_ratio);\r\nval |= MXR_GRP_WH_V_SCALE(y_ratio);\r\nmixer_reg_write(res, MXR_GRAPHIC_WH(win), val);\r\nval = MXR_GRP_SXY_SX(src_x_offset);\r\nval |= MXR_GRP_SXY_SY(src_y_offset);\r\nmixer_reg_write(res, MXR_GRAPHIC_SXY(win), val);\r\nval = MXR_GRP_DXY_DX(dst_x_offset);\r\nval |= MXR_GRP_DXY_DY(dst_y_offset);\r\nmixer_reg_write(res, MXR_GRAPHIC_DXY(win), val);\r\nmixer_reg_write(res, MXR_GRAPHIC_BASE(win), dma_addr);\r\nmixer_cfg_scan(ctx, win_data->mode_height);\r\nmixer_cfg_rgb_fmt(ctx, win_data->mode_height);\r\nmixer_cfg_layer(ctx, win, true);\r\nif (ctx->mxr_ver == MXR_VER_16_0_33_0 ||\r\nctx->mxr_ver == MXR_VER_128_0_0_184)\r\nmixer_layer_update(ctx);\r\nmixer_run(ctx);\r\nmixer_vsync_set_update(ctx, true);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\n}\r\nstatic void vp_win_reset(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nint tries = 100;\r\nvp_reg_write(res, VP_SRESET, VP_SRESET_PROCESSING);\r\nfor (tries = 100; tries; --tries) {\r\nif (~vp_reg_read(res, VP_SRESET) & VP_SRESET_PROCESSING)\r\nbreak;\r\nusleep_range(10000, 12000);\r\n}\r\nWARN(tries == 0, "failed to reset Video Processor\n");\r\n}\r\nstatic void mixer_win_reset(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nunsigned long flags;\r\nu32 val;\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_vsync_set_update(ctx, false);\r\nmixer_reg_writemask(res, MXR_CFG, MXR_CFG_DST_HDMI, MXR_CFG_DST_MASK);\r\nmixer_reg_writemask(res, MXR_CFG, MXR_CFG_OUT_RGB888, MXR_CFG_OUT_MASK);\r\nmixer_reg_writemask(res, MXR_STATUS, MXR_STATUS_16_BURST,\r\nMXR_STATUS_BURST_MASK);\r\nval = MXR_LAYER_CFG_GRP1_VAL(3);\r\nval |= MXR_LAYER_CFG_GRP0_VAL(2);\r\nif (ctx->vp_enabled)\r\nval |= MXR_LAYER_CFG_VP_VAL(1);\r\nmixer_reg_write(res, MXR_LAYER_CFG, val);\r\nmixer_reg_write(res, MXR_BG_COLOR0, 0x008080);\r\nmixer_reg_write(res, MXR_BG_COLOR1, 0x008080);\r\nmixer_reg_write(res, MXR_BG_COLOR2, 0x008080);\r\nval = MXR_GRP_CFG_COLOR_KEY_DISABLE;\r\nval |= MXR_GRP_CFG_WIN_BLEND_EN;\r\nval |= MXR_GRP_CFG_ALPHA_VAL(0xff);\r\nmixer_reg_write(res, MXR_GRAPHIC_CFG(0), val);\r\nval |= MXR_GRP_CFG_BLEND_PRE_MUL;\r\nval |= MXR_GRP_CFG_PIXEL_BLEND_EN;\r\nmixer_reg_write(res, MXR_GRAPHIC_CFG(1), val);\r\nval = MXR_GRP_CFG_ALPHA_VAL(0);\r\nmixer_reg_write(res, MXR_VIDEO_CFG, val);\r\nif (ctx->vp_enabled) {\r\nvp_win_reset(ctx);\r\nvp_default_filter(res);\r\n}\r\nmixer_reg_writemask(res, MXR_CFG, 0, MXR_CFG_GRP0_ENABLE);\r\nmixer_reg_writemask(res, MXR_CFG, 0, MXR_CFG_GRP1_ENABLE);\r\nif (ctx->vp_enabled)\r\nmixer_reg_writemask(res, MXR_CFG, 0, MXR_CFG_VP_ENABLE);\r\nmixer_vsync_set_update(ctx, true);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\n}\r\nstatic int mixer_iommu_on(void *ctx, bool enable)\r\n{\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx;\r\nstruct mixer_context *mdata = ctx;\r\nstruct drm_device *drm_dev;\r\ndrm_hdmi_ctx = mdata->parent_ctx;\r\ndrm_dev = drm_hdmi_ctx->drm_dev;\r\nif (is_drm_iommu_supported(drm_dev)) {\r\nif (enable)\r\nreturn drm_iommu_attach_device(drm_dev, mdata->dev);\r\ndrm_iommu_detach_device(drm_dev, mdata->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_enable_vblank(void *ctx, int pipe)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nstruct mixer_resources *res = &mixer_ctx->mixer_res;\r\nmixer_ctx->pipe = pipe;\r\nmixer_reg_writemask(res, MXR_INT_EN, MXR_INT_EN_VSYNC,\r\nMXR_INT_EN_VSYNC);\r\nreturn 0;\r\n}\r\nstatic void mixer_disable_vblank(void *ctx)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nstruct mixer_resources *res = &mixer_ctx->mixer_res;\r\nmixer_reg_writemask(res, MXR_INT_EN, 0, MXR_INT_EN_VSYNC);\r\n}\r\nstatic void mixer_win_mode_set(void *ctx,\r\nstruct exynos_drm_overlay *overlay)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nstruct hdmi_win_data *win_data;\r\nint win;\r\nif (!overlay) {\r\nDRM_ERROR("overlay is NULL\n");\r\nreturn;\r\n}\r\nDRM_DEBUG_KMS("set [%d]x[%d] at (%d,%d) to [%d]x[%d] at (%d,%d)\n",\r\noverlay->fb_width, overlay->fb_height,\r\noverlay->fb_x, overlay->fb_y,\r\noverlay->crtc_width, overlay->crtc_height,\r\noverlay->crtc_x, overlay->crtc_y);\r\nwin = overlay->zpos;\r\nif (win == DEFAULT_ZPOS)\r\nwin = MIXER_DEFAULT_WIN;\r\nif (win < 0 || win >= MIXER_WIN_NR) {\r\nDRM_ERROR("mixer window[%d] is wrong\n", win);\r\nreturn;\r\n}\r\nwin_data = &mixer_ctx->win_data[win];\r\nwin_data->dma_addr = overlay->dma_addr[0];\r\nwin_data->chroma_dma_addr = overlay->dma_addr[1];\r\nwin_data->pixel_format = overlay->pixel_format;\r\nwin_data->bpp = overlay->bpp;\r\nwin_data->crtc_x = overlay->crtc_x;\r\nwin_data->crtc_y = overlay->crtc_y;\r\nwin_data->crtc_width = overlay->crtc_width;\r\nwin_data->crtc_height = overlay->crtc_height;\r\nwin_data->fb_x = overlay->fb_x;\r\nwin_data->fb_y = overlay->fb_y;\r\nwin_data->fb_width = overlay->fb_width;\r\nwin_data->fb_height = overlay->fb_height;\r\nwin_data->src_width = overlay->src_width;\r\nwin_data->src_height = overlay->src_height;\r\nwin_data->mode_width = overlay->mode_width;\r\nwin_data->mode_height = overlay->mode_height;\r\nwin_data->scan_flags = overlay->scan_flag;\r\n}\r\nstatic void mixer_win_commit(void *ctx, int win)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nDRM_DEBUG_KMS("win: %d\n", win);\r\nmutex_lock(&mixer_ctx->mixer_mutex);\r\nif (!mixer_ctx->powered) {\r\nmutex_unlock(&mixer_ctx->mixer_mutex);\r\nreturn;\r\n}\r\nmutex_unlock(&mixer_ctx->mixer_mutex);\r\nif (win > 1 && mixer_ctx->vp_enabled)\r\nvp_video_buffer(mixer_ctx, win);\r\nelse\r\nmixer_graph_buffer(mixer_ctx, win);\r\nmixer_ctx->win_data[win].enabled = true;\r\n}\r\nstatic void mixer_win_disable(void *ctx, int win)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nstruct mixer_resources *res = &mixer_ctx->mixer_res;\r\nunsigned long flags;\r\nDRM_DEBUG_KMS("win: %d\n", win);\r\nmutex_lock(&mixer_ctx->mixer_mutex);\r\nif (!mixer_ctx->powered) {\r\nmutex_unlock(&mixer_ctx->mixer_mutex);\r\nmixer_ctx->win_data[win].resume = false;\r\nreturn;\r\n}\r\nmutex_unlock(&mixer_ctx->mixer_mutex);\r\nspin_lock_irqsave(&res->reg_slock, flags);\r\nmixer_vsync_set_update(mixer_ctx, false);\r\nmixer_cfg_layer(mixer_ctx, win, false);\r\nmixer_vsync_set_update(mixer_ctx, true);\r\nspin_unlock_irqrestore(&res->reg_slock, flags);\r\nmixer_ctx->win_data[win].enabled = false;\r\n}\r\nstatic int mixer_check_mode(void *ctx, struct drm_display_mode *mode)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nu32 w, h;\r\nw = mode->hdisplay;\r\nh = mode->vdisplay;\r\nDRM_DEBUG_KMS("xres=%d, yres=%d, refresh=%d, intl=%d\n",\r\nmode->hdisplay, mode->vdisplay, mode->vrefresh,\r\n(mode->flags & DRM_MODE_FLAG_INTERLACE) ? 1 : 0);\r\nif (mixer_ctx->mxr_ver == MXR_VER_0_0_0_16 ||\r\nmixer_ctx->mxr_ver == MXR_VER_128_0_0_184)\r\nreturn 0;\r\nif ((w >= 464 && w <= 720 && h >= 261 && h <= 576) ||\r\n(w >= 1024 && w <= 1280 && h >= 576 && h <= 720) ||\r\n(w >= 1664 && w <= 1920 && h >= 936 && h <= 1080))\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nstatic void mixer_wait_for_vblank(void *ctx)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nmutex_lock(&mixer_ctx->mixer_mutex);\r\nif (!mixer_ctx->powered) {\r\nmutex_unlock(&mixer_ctx->mixer_mutex);\r\nreturn;\r\n}\r\nmutex_unlock(&mixer_ctx->mixer_mutex);\r\natomic_set(&mixer_ctx->wait_vsync_event, 1);\r\nif (!wait_event_timeout(mixer_ctx->wait_vsync_queue,\r\n!atomic_read(&mixer_ctx->wait_vsync_event),\r\nDRM_HZ/20))\r\nDRM_DEBUG_KMS("vblank wait timed out.\n");\r\n}\r\nstatic void mixer_window_suspend(struct mixer_context *ctx)\r\n{\r\nstruct hdmi_win_data *win_data;\r\nint i;\r\nfor (i = 0; i < MIXER_WIN_NR; i++) {\r\nwin_data = &ctx->win_data[i];\r\nwin_data->resume = win_data->enabled;\r\nmixer_win_disable(ctx, i);\r\n}\r\nmixer_wait_for_vblank(ctx);\r\n}\r\nstatic void mixer_window_resume(struct mixer_context *ctx)\r\n{\r\nstruct hdmi_win_data *win_data;\r\nint i;\r\nfor (i = 0; i < MIXER_WIN_NR; i++) {\r\nwin_data = &ctx->win_data[i];\r\nwin_data->enabled = win_data->resume;\r\nwin_data->resume = false;\r\n}\r\n}\r\nstatic void mixer_poweron(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmutex_lock(&ctx->mixer_mutex);\r\nif (ctx->powered) {\r\nmutex_unlock(&ctx->mixer_mutex);\r\nreturn;\r\n}\r\nctx->powered = true;\r\nmutex_unlock(&ctx->mixer_mutex);\r\nclk_prepare_enable(res->mixer);\r\nif (ctx->vp_enabled) {\r\nclk_prepare_enable(res->vp);\r\nclk_prepare_enable(res->sclk_mixer);\r\n}\r\nmixer_reg_write(res, MXR_INT_EN, ctx->int_en);\r\nmixer_win_reset(ctx);\r\nmixer_window_resume(ctx);\r\n}\r\nstatic void mixer_poweroff(struct mixer_context *ctx)\r\n{\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nmutex_lock(&ctx->mixer_mutex);\r\nif (!ctx->powered)\r\ngoto out;\r\nmutex_unlock(&ctx->mixer_mutex);\r\nmixer_window_suspend(ctx);\r\nctx->int_en = mixer_reg_read(res, MXR_INT_EN);\r\nclk_disable_unprepare(res->mixer);\r\nif (ctx->vp_enabled) {\r\nclk_disable_unprepare(res->vp);\r\nclk_disable_unprepare(res->sclk_mixer);\r\n}\r\nmutex_lock(&ctx->mixer_mutex);\r\nctx->powered = false;\r\nout:\r\nmutex_unlock(&ctx->mixer_mutex);\r\n}\r\nstatic void mixer_dpms(void *ctx, int mode)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx;\r\nswitch (mode) {\r\ncase DRM_MODE_DPMS_ON:\r\nif (pm_runtime_suspended(mixer_ctx->dev))\r\npm_runtime_get_sync(mixer_ctx->dev);\r\nbreak;\r\ncase DRM_MODE_DPMS_STANDBY:\r\ncase DRM_MODE_DPMS_SUSPEND:\r\ncase DRM_MODE_DPMS_OFF:\r\nif (!pm_runtime_suspended(mixer_ctx->dev))\r\npm_runtime_put_sync(mixer_ctx->dev);\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("unknown dpms mode: %d\n", mode);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t mixer_irq_handler(int irq, void *arg)\r\n{\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx = arg;\r\nstruct mixer_context *ctx = drm_hdmi_ctx->ctx;\r\nstruct mixer_resources *res = &ctx->mixer_res;\r\nu32 val, base, shadow;\r\nspin_lock(&res->reg_slock);\r\nval = mixer_reg_read(res, MXR_INT_STATUS);\r\nif (val & MXR_INT_STATUS_VSYNC) {\r\nif (ctx->interlace) {\r\nbase = mixer_reg_read(res, MXR_GRAPHIC_BASE(0));\r\nshadow = mixer_reg_read(res, MXR_GRAPHIC_BASE_S(0));\r\nif (base != shadow)\r\ngoto out;\r\nbase = mixer_reg_read(res, MXR_GRAPHIC_BASE(1));\r\nshadow = mixer_reg_read(res, MXR_GRAPHIC_BASE_S(1));\r\nif (base != shadow)\r\ngoto out;\r\n}\r\ndrm_handle_vblank(drm_hdmi_ctx->drm_dev, ctx->pipe);\r\nexynos_drm_crtc_finish_pageflip(drm_hdmi_ctx->drm_dev,\r\nctx->pipe);\r\nif (atomic_read(&ctx->wait_vsync_event)) {\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nDRM_WAKEUP(&ctx->wait_vsync_queue);\r\n}\r\n}\r\nout:\r\nif (~val & MXR_INT_EN_VSYNC) {\r\nval &= ~MXR_INT_EN_VSYNC;\r\nval |= MXR_INT_CLEAR_VSYNC;\r\n}\r\nmixer_reg_write(res, MXR_INT_STATUS, val);\r\nspin_unlock(&res->reg_slock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int mixer_resources_init(struct exynos_drm_hdmi_context *ctx,\r\nstruct platform_device *pdev)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx->ctx;\r\nstruct device *dev = &pdev->dev;\r\nstruct mixer_resources *mixer_res = &mixer_ctx->mixer_res;\r\nstruct resource *res;\r\nint ret;\r\nspin_lock_init(&mixer_res->reg_slock);\r\nmixer_res->mixer = devm_clk_get(dev, "mixer");\r\nif (IS_ERR(mixer_res->mixer)) {\r\ndev_err(dev, "failed to get clock 'mixer'\n");\r\nreturn -ENODEV;\r\n}\r\nmixer_res->sclk_hdmi = devm_clk_get(dev, "sclk_hdmi");\r\nif (IS_ERR(mixer_res->sclk_hdmi)) {\r\ndev_err(dev, "failed to get clock 'sclk_hdmi'\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get memory resource failed.\n");\r\nreturn -ENXIO;\r\n}\r\nmixer_res->mixer_regs = devm_ioremap(dev, res->start,\r\nresource_size(res));\r\nif (mixer_res->mixer_regs == NULL) {\r\ndev_err(dev, "register mapping failed.\n");\r\nreturn -ENXIO;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(dev, "get interrupt resource failed.\n");\r\nreturn -ENXIO;\r\n}\r\nret = devm_request_irq(dev, res->start, mixer_irq_handler,\r\n0, "drm_mixer", ctx);\r\nif (ret) {\r\ndev_err(dev, "request interrupt failed.\n");\r\nreturn ret;\r\n}\r\nmixer_res->irq = res->start;\r\nreturn 0;\r\n}\r\nstatic int vp_resources_init(struct exynos_drm_hdmi_context *ctx,\r\nstruct platform_device *pdev)\r\n{\r\nstruct mixer_context *mixer_ctx = ctx->ctx;\r\nstruct device *dev = &pdev->dev;\r\nstruct mixer_resources *mixer_res = &mixer_ctx->mixer_res;\r\nstruct resource *res;\r\nmixer_res->vp = devm_clk_get(dev, "vp");\r\nif (IS_ERR(mixer_res->vp)) {\r\ndev_err(dev, "failed to get clock 'vp'\n");\r\nreturn -ENODEV;\r\n}\r\nmixer_res->sclk_mixer = devm_clk_get(dev, "sclk_mixer");\r\nif (IS_ERR(mixer_res->sclk_mixer)) {\r\ndev_err(dev, "failed to get clock 'sclk_mixer'\n");\r\nreturn -ENODEV;\r\n}\r\nmixer_res->sclk_dac = devm_clk_get(dev, "sclk_dac");\r\nif (IS_ERR(mixer_res->sclk_dac)) {\r\ndev_err(dev, "failed to get clock 'sclk_dac'\n");\r\nreturn -ENODEV;\r\n}\r\nif (mixer_res->sclk_hdmi)\r\nclk_set_parent(mixer_res->sclk_mixer, mixer_res->sclk_hdmi);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (res == NULL) {\r\ndev_err(dev, "get memory resource failed.\n");\r\nreturn -ENXIO;\r\n}\r\nmixer_res->vp_regs = devm_ioremap(dev, res->start,\r\nresource_size(res));\r\nif (mixer_res->vp_regs == NULL) {\r\ndev_err(dev, "register mapping failed.\n");\r\nreturn -ENXIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mixer_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx;\r\nstruct mixer_context *ctx;\r\nstruct mixer_drv_data *drv;\r\nint ret;\r\ndev_info(dev, "probe start\n");\r\ndrm_hdmi_ctx = devm_kzalloc(dev, sizeof(*drm_hdmi_ctx),\r\nGFP_KERNEL);\r\nif (!drm_hdmi_ctx)\r\nreturn -ENOMEM;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nmutex_init(&ctx->mixer_mutex);\r\nif (dev->of_node) {\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(mixer_match_types, dev->of_node);\r\ndrv = (struct mixer_drv_data *)match->data;\r\n} else {\r\ndrv = (struct mixer_drv_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n}\r\nctx->dev = dev;\r\nctx->parent_ctx = (void *)drm_hdmi_ctx;\r\ndrm_hdmi_ctx->ctx = (void *)ctx;\r\nctx->vp_enabled = drv->is_vp_enabled;\r\nctx->mxr_ver = drv->version;\r\nDRM_INIT_WAITQUEUE(&ctx->wait_vsync_queue);\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nplatform_set_drvdata(pdev, drm_hdmi_ctx);\r\nret = mixer_resources_init(drm_hdmi_ctx, pdev);\r\nif (ret) {\r\nDRM_ERROR("mixer_resources_init failed\n");\r\ngoto fail;\r\n}\r\nif (ctx->vp_enabled) {\r\nret = vp_resources_init(drm_hdmi_ctx, pdev);\r\nif (ret) {\r\nDRM_ERROR("vp_resources_init failed\n");\r\ngoto fail;\r\n}\r\n}\r\nexynos_mixer_drv_attach(drm_hdmi_ctx);\r\nexynos_mixer_ops_register(&mixer_ops);\r\npm_runtime_enable(dev);\r\nreturn 0;\r\nfail:\r\ndev_info(dev, "probe failed\n");\r\nreturn ret;\r\n}\r\nstatic int mixer_remove(struct platform_device *pdev)\r\n{\r\ndev_info(&pdev->dev, "remove successful\n");\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int mixer_suspend(struct device *dev)\r\n{\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx = get_mixer_context(dev);\r\nstruct mixer_context *ctx = drm_hdmi_ctx->ctx;\r\nif (pm_runtime_suspended(dev)) {\r\nDRM_DEBUG_KMS("Already suspended\n");\r\nreturn 0;\r\n}\r\nmixer_poweroff(ctx);\r\nreturn 0;\r\n}\r\nstatic int mixer_resume(struct device *dev)\r\n{\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx = get_mixer_context(dev);\r\nstruct mixer_context *ctx = drm_hdmi_ctx->ctx;\r\nif (!pm_runtime_suspended(dev)) {\r\nDRM_DEBUG_KMS("Already resumed\n");\r\nreturn 0;\r\n}\r\nmixer_poweron(ctx);\r\nreturn 0;\r\n}\r\nstatic int mixer_runtime_suspend(struct device *dev)\r\n{\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx = get_mixer_context(dev);\r\nstruct mixer_context *ctx = drm_hdmi_ctx->ctx;\r\nmixer_poweroff(ctx);\r\nreturn 0;\r\n}\r\nstatic int mixer_runtime_resume(struct device *dev)\r\n{\r\nstruct exynos_drm_hdmi_context *drm_hdmi_ctx = get_mixer_context(dev);\r\nstruct mixer_context *ctx = drm_hdmi_ctx->ctx;\r\nmixer_poweron(ctx);\r\nreturn 0;\r\n}
