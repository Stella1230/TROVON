int lzo1x_decompress_safe(const unsigned char *in, size_t in_len,\r\nunsigned char *out, size_t *out_len)\r\n{\r\nunsigned char *op;\r\nconst unsigned char *ip;\r\nsize_t t, next;\r\nsize_t state = 0;\r\nconst unsigned char *m_pos;\r\nconst unsigned char * const ip_end = in + in_len;\r\nunsigned char * const op_end = out + *out_len;\r\nop = out;\r\nip = in;\r\nif (unlikely(in_len < 3))\r\ngoto input_overrun;\r\nif (*ip > 17) {\r\nt = *ip++ - 17;\r\nif (t < 4) {\r\nnext = t;\r\ngoto match_next;\r\n}\r\ngoto copy_literal_run;\r\n}\r\nfor (;;) {\r\nt = *ip++;\r\nif (t < 16) {\r\nif (likely(state == 0)) {\r\nif (unlikely(t == 0)) {\r\nwhile (unlikely(*ip == 0)) {\r\nt += 255;\r\nip++;\r\nNEED_IP(1);\r\n}\r\nt += 15 + *ip++;\r\n}\r\nt += 3;\r\ncopy_literal_run:\r\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\r\nif (likely(HAVE_IP(t + 15) && HAVE_OP(t + 15))) {\r\nconst unsigned char *ie = ip + t;\r\nunsigned char *oe = op + t;\r\ndo {\r\nCOPY8(op, ip);\r\nop += 8;\r\nip += 8;\r\nCOPY8(op, ip);\r\nop += 8;\r\nip += 8;\r\n} while (ip < ie);\r\nip = ie;\r\nop = oe;\r\n} else\r\n#endif\r\n{\r\nNEED_OP(t);\r\nNEED_IP(t + 3);\r\ndo {\r\n*op++ = *ip++;\r\n} while (--t > 0);\r\n}\r\nstate = 4;\r\ncontinue;\r\n} else if (state != 4) {\r\nnext = t & 3;\r\nm_pos = op - 1;\r\nm_pos -= t >> 2;\r\nm_pos -= *ip++ << 2;\r\nTEST_LB(m_pos);\r\nNEED_OP(2);\r\nop[0] = m_pos[0];\r\nop[1] = m_pos[1];\r\nop += 2;\r\ngoto match_next;\r\n} else {\r\nnext = t & 3;\r\nm_pos = op - (1 + M2_MAX_OFFSET);\r\nm_pos -= t >> 2;\r\nm_pos -= *ip++ << 2;\r\nt = 3;\r\n}\r\n} else if (t >= 64) {\r\nnext = t & 3;\r\nm_pos = op - 1;\r\nm_pos -= (t >> 2) & 7;\r\nm_pos -= *ip++ << 3;\r\nt = (t >> 5) - 1 + (3 - 1);\r\n} else if (t >= 32) {\r\nt = (t & 31) + (3 - 1);\r\nif (unlikely(t == 2)) {\r\nwhile (unlikely(*ip == 0)) {\r\nt += 255;\r\nip++;\r\nNEED_IP(1);\r\n}\r\nt += 31 + *ip++;\r\nNEED_IP(2);\r\n}\r\nm_pos = op - 1;\r\nnext = get_unaligned_le16(ip);\r\nip += 2;\r\nm_pos -= next >> 2;\r\nnext &= 3;\r\n} else {\r\nm_pos = op;\r\nm_pos -= (t & 8) << 11;\r\nt = (t & 7) + (3 - 1);\r\nif (unlikely(t == 2)) {\r\nwhile (unlikely(*ip == 0)) {\r\nt += 255;\r\nip++;\r\nNEED_IP(1);\r\n}\r\nt += 7 + *ip++;\r\nNEED_IP(2);\r\n}\r\nnext = get_unaligned_le16(ip);\r\nip += 2;\r\nm_pos -= next >> 2;\r\nnext &= 3;\r\nif (m_pos == op)\r\ngoto eof_found;\r\nm_pos -= 0x4000;\r\n}\r\nTEST_LB(m_pos);\r\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\r\nif (op - m_pos >= 8) {\r\nunsigned char *oe = op + t;\r\nif (likely(HAVE_OP(t + 15))) {\r\ndo {\r\nCOPY8(op, m_pos);\r\nop += 8;\r\nm_pos += 8;\r\nCOPY8(op, m_pos);\r\nop += 8;\r\nm_pos += 8;\r\n} while (op < oe);\r\nop = oe;\r\nif (HAVE_IP(6)) {\r\nstate = next;\r\nCOPY4(op, ip);\r\nop += next;\r\nip += next;\r\ncontinue;\r\n}\r\n} else {\r\nNEED_OP(t);\r\ndo {\r\n*op++ = *m_pos++;\r\n} while (op < oe);\r\n}\r\n} else\r\n#endif\r\n{\r\nunsigned char *oe = op + t;\r\nNEED_OP(t);\r\nop[0] = m_pos[0];\r\nop[1] = m_pos[1];\r\nop += 2;\r\nm_pos += 2;\r\ndo {\r\n*op++ = *m_pos++;\r\n} while (op < oe);\r\n}\r\nmatch_next:\r\nstate = next;\r\nt = next;\r\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\r\nif (likely(HAVE_IP(6) && HAVE_OP(4))) {\r\nCOPY4(op, ip);\r\nop += t;\r\nip += t;\r\n} else\r\n#endif\r\n{\r\nNEED_IP(t + 3);\r\nNEED_OP(t);\r\nwhile (t > 0) {\r\n*op++ = *ip++;\r\nt--;\r\n}\r\n}\r\n}\r\neof_found:\r\n*out_len = op - out;\r\nreturn (t != 3 ? LZO_E_ERROR :\r\nip == ip_end ? LZO_E_OK :\r\nip < ip_end ? LZO_E_INPUT_NOT_CONSUMED : LZO_E_INPUT_OVERRUN);\r\ninput_overrun:\r\n*out_len = op - out;\r\nreturn LZO_E_INPUT_OVERRUN;\r\noutput_overrun:\r\n*out_len = op - out;\r\nreturn LZO_E_OUTPUT_OVERRUN;\r\nlookbehind_overrun:\r\n*out_len = op - out;\r\nreturn LZO_E_LOOKBEHIND_OVERRUN;\r\n}
