static void ts_reset_encoder(struct saa7134_dev* dev)\r\n{\r\nif (!dev->empress_started)\r\nreturn;\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x00);\r\nmsleep(10);\r\nsaa_writeb(SAA7134_SPECIAL_MODE, 0x01);\r\nmsleep(100);\r\ndev->empress_started = 0;\r\n}\r\nstatic int ts_init_encoder(struct saa7134_dev* dev)\r\n{\r\nu32 leading_null_bytes = 0;\r\nswitch (dev->board) {\r\ncase SAA7134_BOARD_BEHOLD_M6:\r\ncase SAA7134_BOARD_BEHOLD_M63:\r\ncase SAA7134_BOARD_BEHOLD_M6_EXTRA:\r\nleading_null_bytes = 1;\r\nbreak;\r\n}\r\nts_reset_encoder(dev);\r\nsaa_call_all(dev, core, init, leading_null_bytes);\r\ndev->empress_started = 1;\r\nreturn 0;\r\n}\r\nstatic int ts_open(struct file *file)\r\n{\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct saa7134_dev *dev = video_drvdata(file);\r\nint err;\r\ndprintk("open dev=%s\n", video_device_node_name(vdev));\r\nerr = -EBUSY;\r\nif (!mutex_trylock(&dev->empress_tsq.vb_lock))\r\nreturn err;\r\nif (atomic_read(&dev->empress_users))\r\ngoto done;\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\r\nsaa_readb(SAA7134_AUDIO_MUTE_CTRL) & ~(1 << 6));\r\natomic_inc(&dev->empress_users);\r\nfile->private_data = dev;\r\nerr = 0;\r\ndone:\r\nmutex_unlock(&dev->empress_tsq.vb_lock);\r\nreturn err;\r\n}\r\nstatic int ts_release(struct file *file)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nvideobuf_stop(&dev->empress_tsq);\r\nvideobuf_mmap_free(&dev->empress_tsq);\r\nts_reset_encoder(dev);\r\nsaa_writeb(SAA7134_AUDIO_MUTE_CTRL,\r\nsaa_readb(SAA7134_AUDIO_MUTE_CTRL) | (1 << 6));\r\natomic_dec(&dev->empress_users);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nts_read(struct file *file, char __user *data, size_t count, loff_t *ppos)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nif (!dev->empress_started)\r\nts_init_encoder(dev);\r\nreturn videobuf_read_stream(&dev->empress_tsq,\r\ndata, count, ppos, 0,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic unsigned int\r\nts_poll(struct file *file, struct poll_table_struct *wait)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_poll_stream(file, &dev->empress_tsq, wait);\r\n}\r\nstatic int\r\nts_mmap(struct file *file, struct vm_area_struct * vma)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_mmap_mapper(&dev->empress_tsq, vma);\r\n}\r\nstatic int empress_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nstrcpy(cap->driver, "saa7134");\r\nstrlcpy(cap->card, saa7134_boards[dev->board].name,\r\nsizeof(cap->card));\r\nsprintf(cap->bus_info, "PCI:%s", pci_name(dev->pci));\r\ncap->capabilities =\r\nV4L2_CAP_VIDEO_CAPTURE |\r\nV4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nreturn 0;\r\n}\r\nstatic int empress_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index != 0)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nstrcpy(i->name, "CCIR656");\r\nreturn 0;\r\n}\r\nstatic int empress_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\n*i = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nif (i != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int empress_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, "MPEG TS", sizeof(f->description));\r\nf->pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->flags = V4L2_FMT_FLAG_COMPRESSED;\r\nreturn 0;\r\n}\r\nstatic int empress_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nsaa_call_all(dev, video, g_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\nsaa_call_all(dev, video, s_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, V4L2_MBUS_FMT_FIXED);\r\nsaa_call_all(dev, video, try_mbus_fmt, &mbus_fmt);\r\nv4l2_fill_pix_format(&f->fmt.pix, &mbus_fmt);\r\nf->fmt.pix.pixelformat = V4L2_PIX_FMT_MPEG;\r\nf->fmt.pix.sizeimage = TS_PACKET_SIZE * dev->ts.nr_packets;\r\nf->fmt.pix.bytesperline = 0;\r\nf->fmt.pix.priv = 0;\r\nreturn 0;\r\n}\r\nstatic int empress_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *p)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_reqbufs(&dev->empress_tsq, p);\r\n}\r\nstatic int empress_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *b)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_querybuf(&dev->empress_tsq, b);\r\n}\r\nstatic int empress_qbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_qbuf(&dev->empress_tsq, b);\r\n}\r\nstatic int empress_dqbuf(struct file *file, void *priv, struct v4l2_buffer *b)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_dqbuf(&dev->empress_tsq, b,\r\nfile->f_flags & O_NONBLOCK);\r\n}\r\nstatic int empress_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_streamon(&dev->empress_tsq);\r\n}\r\nstatic int empress_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn videobuf_streamoff(&dev->empress_tsq);\r\n}\r\nstatic int empress_s_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nint err;\r\nif (ctrls->count == 0)\r\nreturn 0;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\nerr = saa_call_empress(dev, core, s_ext_ctrls, ctrls);\r\nts_init_encoder(dev);\r\nreturn err;\r\n}\r\nstatic int empress_g_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctrls)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nif (ctrls->ctrl_class != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\nreturn saa_call_empress(dev, core, g_ext_ctrls, ctrls);\r\n}\r\nstatic int empress_g_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *c)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn saa7134_g_ctrl_internal(dev, NULL, c);\r\n}\r\nstatic int empress_s_ctrl(struct file *file, void *priv,\r\nstruct v4l2_control *c)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn saa7134_s_ctrl_internal(dev, NULL, c);\r\n}\r\nstatic int empress_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *c)\r\n{\r\nstatic const u32 user_ctrls[] = {\r\nV4L2_CID_USER_CLASS,\r\nV4L2_CID_BRIGHTNESS,\r\nV4L2_CID_CONTRAST,\r\nV4L2_CID_SATURATION,\r\nV4L2_CID_HUE,\r\nV4L2_CID_AUDIO_VOLUME,\r\nV4L2_CID_AUDIO_MUTE,\r\nV4L2_CID_HFLIP,\r\n0\r\n};\r\nstatic const u32 mpeg_ctrls[] = {\r\nV4L2_CID_MPEG_CLASS,\r\nV4L2_CID_MPEG_STREAM_TYPE,\r\nV4L2_CID_MPEG_STREAM_PID_PMT,\r\nV4L2_CID_MPEG_STREAM_PID_AUDIO,\r\nV4L2_CID_MPEG_STREAM_PID_VIDEO,\r\nV4L2_CID_MPEG_STREAM_PID_PCR,\r\nV4L2_CID_MPEG_AUDIO_SAMPLING_FREQ,\r\nV4L2_CID_MPEG_AUDIO_ENCODING,\r\nV4L2_CID_MPEG_AUDIO_L2_BITRATE,\r\nV4L2_CID_MPEG_VIDEO_ENCODING,\r\nV4L2_CID_MPEG_VIDEO_ASPECT,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_MODE,\r\nV4L2_CID_MPEG_VIDEO_BITRATE,\r\nV4L2_CID_MPEG_VIDEO_BITRATE_PEAK,\r\n0\r\n};\r\nstatic const u32 *ctrl_classes[] = {\r\nuser_ctrls,\r\nmpeg_ctrls,\r\nNULL\r\n};\r\nstruct saa7134_dev *dev = file->private_data;\r\nc->id = v4l2_ctrl_next(ctrl_classes, c->id);\r\nif (c->id == 0)\r\nreturn -EINVAL;\r\nif (c->id == V4L2_CID_USER_CLASS || c->id == V4L2_CID_MPEG_CLASS)\r\nreturn v4l2_ctrl_query_fill(c, 0, 0, 0, 0);\r\nif (V4L2_CTRL_ID2CLASS(c->id) != V4L2_CTRL_CLASS_MPEG)\r\nreturn saa7134_queryctrl(file, priv, c);\r\nreturn saa_call_empress(dev, core, queryctrl, c);\r\n}\r\nstatic int empress_querymenu(struct file *file, void *priv,\r\nstruct v4l2_querymenu *c)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nif (V4L2_CTRL_ID2CLASS(c->id) != V4L2_CTRL_CLASS_MPEG)\r\nreturn -EINVAL;\r\nreturn saa_call_empress(dev, core, querymenu, c);\r\n}\r\nstatic int empress_s_std(struct file *file, void *priv, v4l2_std_id id)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\nreturn saa7134_s_std_internal(dev, NULL, id);\r\n}\r\nstatic int empress_g_std(struct file *file, void *priv, v4l2_std_id *id)\r\n{\r\nstruct saa7134_dev *dev = file->private_data;\r\n*id = dev->tvnorm->id;\r\nreturn 0;\r\n}\r\nstatic void empress_signal_update(struct work_struct *work)\r\n{\r\nstruct saa7134_dev* dev =\r\ncontainer_of(work, struct saa7134_dev, empress_workqueue);\r\nif (dev->nosignal) {\r\ndprintk("no video signal\n");\r\n} else {\r\ndprintk("video signal acquired\n");\r\n}\r\n}\r\nstatic void empress_signal_change(struct saa7134_dev *dev)\r\n{\r\nschedule_work(&dev->empress_workqueue);\r\n}\r\nstatic int empress_init(struct saa7134_dev *dev)\r\n{\r\nint err;\r\ndprintk("%s: %s\n",dev->name,__func__);\r\ndev->empress_dev = video_device_alloc();\r\nif (NULL == dev->empress_dev)\r\nreturn -ENOMEM;\r\n*(dev->empress_dev) = saa7134_empress_template;\r\ndev->empress_dev->v4l2_dev = &dev->v4l2_dev;\r\ndev->empress_dev->release = video_device_release;\r\nsnprintf(dev->empress_dev->name, sizeof(dev->empress_dev->name),\r\n"%s empress (%s)", dev->name,\r\nsaa7134_boards[dev->board].name);\r\nINIT_WORK(&dev->empress_workqueue, empress_signal_update);\r\nvideo_set_drvdata(dev->empress_dev, dev);\r\nerr = video_register_device(dev->empress_dev,VFL_TYPE_GRABBER,\r\nempress_nr[dev->nr]);\r\nif (err < 0) {\r\nprintk(KERN_INFO "%s: can't register video device\n",\r\ndev->name);\r\nvideo_device_release(dev->empress_dev);\r\ndev->empress_dev = NULL;\r\nreturn err;\r\n}\r\nprintk(KERN_INFO "%s: registered device %s [mpeg]\n",\r\ndev->name, video_device_node_name(dev->empress_dev));\r\nvideobuf_queue_sg_init(&dev->empress_tsq, &saa7134_ts_qops,\r\n&dev->pci->dev, &dev->slock,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE,\r\nV4L2_FIELD_ALTERNATE,\r\nsizeof(struct saa7134_buf),\r\ndev, NULL);\r\nempress_signal_update(&dev->empress_workqueue);\r\nreturn 0;\r\n}\r\nstatic int empress_fini(struct saa7134_dev *dev)\r\n{\r\ndprintk("%s: %s\n",dev->name,__func__);\r\nif (NULL == dev->empress_dev)\r\nreturn 0;\r\nflush_work(&dev->empress_workqueue);\r\nvideo_unregister_device(dev->empress_dev);\r\ndev->empress_dev = NULL;\r\nreturn 0;\r\n}\r\nstatic int __init empress_register(void)\r\n{\r\nreturn saa7134_ts_register(&empress_ops);\r\n}\r\nstatic void __exit empress_unregister(void)\r\n{\r\nsaa7134_ts_unregister(&empress_ops);\r\n}
