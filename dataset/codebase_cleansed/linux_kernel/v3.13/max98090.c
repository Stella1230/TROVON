static bool max98090_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase M98090_REG_DEVICE_STATUS:\r\ncase M98090_REG_JACK_STATUS:\r\ncase M98090_REG_REVISION_ID:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool max98090_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase M98090_REG_DEVICE_STATUS:\r\ncase M98090_REG_JACK_STATUS:\r\ncase M98090_REG_INTERRUPT_S:\r\ncase M98090_REG_RESERVED:\r\ncase M98090_REG_LINE_INPUT_CONFIG:\r\ncase M98090_REG_LINE_INPUT_LEVEL:\r\ncase M98090_REG_INPUT_MODE:\r\ncase M98090_REG_MIC1_INPUT_LEVEL:\r\ncase M98090_REG_MIC2_INPUT_LEVEL:\r\ncase M98090_REG_MIC_BIAS_VOLTAGE:\r\ncase M98090_REG_DIGITAL_MIC_ENABLE:\r\ncase M98090_REG_DIGITAL_MIC_CONFIG:\r\ncase M98090_REG_LEFT_ADC_MIXER:\r\ncase M98090_REG_RIGHT_ADC_MIXER:\r\ncase M98090_REG_LEFT_ADC_LEVEL:\r\ncase M98090_REG_RIGHT_ADC_LEVEL:\r\ncase M98090_REG_ADC_BIQUAD_LEVEL:\r\ncase M98090_REG_ADC_SIDETONE:\r\ncase M98090_REG_SYSTEM_CLOCK:\r\ncase M98090_REG_CLOCK_MODE:\r\ncase M98090_REG_CLOCK_RATIO_NI_MSB:\r\ncase M98090_REG_CLOCK_RATIO_NI_LSB:\r\ncase M98090_REG_CLOCK_RATIO_MI_MSB:\r\ncase M98090_REG_CLOCK_RATIO_MI_LSB:\r\ncase M98090_REG_MASTER_MODE:\r\ncase M98090_REG_INTERFACE_FORMAT:\r\ncase M98090_REG_TDM_CONTROL:\r\ncase M98090_REG_TDM_FORMAT:\r\ncase M98090_REG_IO_CONFIGURATION:\r\ncase M98090_REG_FILTER_CONFIG:\r\ncase M98090_REG_DAI_PLAYBACK_LEVEL:\r\ncase M98090_REG_DAI_PLAYBACK_LEVEL_EQ:\r\ncase M98090_REG_LEFT_HP_MIXER:\r\ncase M98090_REG_RIGHT_HP_MIXER:\r\ncase M98090_REG_HP_CONTROL:\r\ncase M98090_REG_LEFT_HP_VOLUME:\r\ncase M98090_REG_RIGHT_HP_VOLUME:\r\ncase M98090_REG_LEFT_SPK_MIXER:\r\ncase M98090_REG_RIGHT_SPK_MIXER:\r\ncase M98090_REG_SPK_CONTROL:\r\ncase M98090_REG_LEFT_SPK_VOLUME:\r\ncase M98090_REG_RIGHT_SPK_VOLUME:\r\ncase M98090_REG_DRC_TIMING:\r\ncase M98090_REG_DRC_COMPRESSOR:\r\ncase M98090_REG_DRC_EXPANDER:\r\ncase M98090_REG_DRC_GAIN:\r\ncase M98090_REG_RCV_LOUTL_MIXER:\r\ncase M98090_REG_RCV_LOUTL_CONTROL:\r\ncase M98090_REG_RCV_LOUTL_VOLUME:\r\ncase M98090_REG_LOUTR_MIXER:\r\ncase M98090_REG_LOUTR_CONTROL:\r\ncase M98090_REG_LOUTR_VOLUME:\r\ncase M98090_REG_JACK_DETECT:\r\ncase M98090_REG_INPUT_ENABLE:\r\ncase M98090_REG_OUTPUT_ENABLE:\r\ncase M98090_REG_LEVEL_CONTROL:\r\ncase M98090_REG_DSP_FILTER_ENABLE:\r\ncase M98090_REG_BIAS_CONTROL:\r\ncase M98090_REG_DAC_CONTROL:\r\ncase M98090_REG_ADC_CONTROL:\r\ncase M98090_REG_DEVICE_SHUTDOWN:\r\ncase M98090_REG_EQUALIZER_BASE ... M98090_REG_EQUALIZER_BASE + 0x68:\r\ncase M98090_REG_RECORD_BIQUAD_BASE ... M98090_REG_RECORD_BIQUAD_BASE + 0x0E:\r\ncase M98090_REG_DMIC3_VOLUME:\r\ncase M98090_REG_DMIC4_VOLUME:\r\ncase M98090_REG_DMIC34_BQ_PREATTEN:\r\ncase M98090_REG_RECORD_TDM_SLOT:\r\ncase M98090_REG_SAMPLE_RATE:\r\ncase M98090_REG_DMIC34_BIQUAD_BASE ... M98090_REG_DMIC34_BIQUAD_BASE + 0x0E:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int max98090_reset(struct max98090_priv *max98090)\r\n{\r\nint ret;\r\nret = regmap_write(max98090->regmap, M98090_REG_SOFTWARE_RESET,\r\nM98090_SWRESET_MASK);\r\nif (ret < 0) {\r\ndev_err(max98090->codec->dev,\r\n"Failed to reset codec: %d\n", ret);\r\nreturn ret;\r\n}\r\nmsleep(20);\r\nreturn ret;\r\n}\r\nstatic int max98090_get_enab_tlv(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int mask = (1 << fls(mc->max)) - 1;\r\nunsigned int val = snd_soc_read(codec, mc->reg);\r\nunsigned int *select;\r\nswitch (mc->reg) {\r\ncase M98090_REG_MIC1_INPUT_LEVEL:\r\nselect = &(max98090->pa1en);\r\nbreak;\r\ncase M98090_REG_MIC2_INPUT_LEVEL:\r\nselect = &(max98090->pa2en);\r\nbreak;\r\ncase M98090_REG_ADC_SIDETONE:\r\nselect = &(max98090->sidetone);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = (val >> mc->shift) & mask;\r\nif (val >= 1) {\r\nval = val - 1;\r\n*select = val;\r\n} else {\r\nval = *select;\r\n}\r\nucontrol->value.integer.value[0] = val;\r\nreturn 0;\r\n}\r\nstatic int max98090_put_enab_tlv(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nunsigned int mask = (1 << fls(mc->max)) - 1;\r\nunsigned int sel = ucontrol->value.integer.value[0];\r\nunsigned int val = snd_soc_read(codec, mc->reg);\r\nunsigned int *select;\r\nswitch (mc->reg) {\r\ncase M98090_REG_MIC1_INPUT_LEVEL:\r\nselect = &(max98090->pa1en);\r\nbreak;\r\ncase M98090_REG_MIC2_INPUT_LEVEL:\r\nselect = &(max98090->pa2en);\r\nbreak;\r\ncase M98090_REG_ADC_SIDETONE:\r\nselect = &(max98090->sidetone);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nval = (val >> mc->shift) & mask;\r\n*select = sel;\r\nif (val >= 1) {\r\nsel = sel + 1;\r\n} else {\r\nsel = val;\r\n}\r\nsnd_soc_update_bits(codec, mc->reg,\r\nmask << mc->shift,\r\nsel << mc->shift);\r\nreturn 0;\r\n}\r\nstatic int max98090_micinput_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = w->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = snd_soc_read(codec, w->reg);\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\r\nval = (val & M98090_MIC_PA1EN_MASK) >> M98090_MIC_PA1EN_SHIFT;\r\nelse\r\nval = (val & M98090_MIC_PA2EN_MASK) >> M98090_MIC_PA2EN_SHIFT;\r\nif (val >= 1) {\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL) {\r\nmax98090->pa1en = val - 1;\r\n} else {\r\nmax98090->pa2en = val - 1;\r\n}\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\r\nval = max98090->pa1en + 1;\r\nelse\r\nval = max98090->pa2en + 1;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nval = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (w->reg == M98090_REG_MIC1_INPUT_LEVEL)\r\nsnd_soc_update_bits(codec, w->reg, M98090_MIC_PA1EN_MASK,\r\nval << M98090_MIC_PA1EN_SHIFT);\r\nelse\r\nsnd_soc_update_bits(codec, w->reg, M98090_MIC_PA2EN_MASK,\r\nval << M98090_MIC_PA2EN_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98090_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nsnd_soc_add_codec_controls(codec, max98090_snd_controls,\r\nARRAY_SIZE(max98090_snd_controls));\r\nif (max98090->devtype == MAX98091) {\r\nsnd_soc_add_codec_controls(codec, max98091_snd_controls,\r\nARRAY_SIZE(max98091_snd_controls));\r\n}\r\nsnd_soc_dapm_new_controls(dapm, max98090_dapm_widgets,\r\nARRAY_SIZE(max98090_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, max98090_dapm_routes,\r\nARRAY_SIZE(max98090_dapm_routes));\r\nif (max98090->devtype == MAX98091) {\r\nsnd_soc_dapm_new_controls(dapm, max98091_dapm_widgets,\r\nARRAY_SIZE(max98091_dapm_widgets));\r\nsnd_soc_dapm_add_routes(dapm, max98091_dapm_routes,\r\nARRAY_SIZE(max98091_dapm_routes));\r\n}\r\nreturn 0;\r\n}\r\nstatic void max98090_configure_bclk(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nunsigned long long ni;\r\nint i;\r\nif (!max98090->sysclk) {\r\ndev_err(codec->dev, "No SYSCLK configured\n");\r\nreturn;\r\n}\r\nif (!max98090->bclk || !max98090->lrclk) {\r\ndev_err(codec->dev, "No audio clocks configured\n");\r\nreturn;\r\n}\r\nif (!(snd_soc_read(codec, M98090_REG_MASTER_MODE) &\r\nM98090_MAS_MASK)) {\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(pclk_rates); i++) {\r\nif ((pclk_rates[i] == max98090->sysclk) &&\r\n(lrclk_rates[i] == max98090->lrclk)) {\r\ndev_dbg(codec->dev,\r\n"Found supported PCLK to LRCLK rates 0x%x\n",\r\ni + 0x8);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_FREQ_MASK,\r\n(i + 0x8) << M98090_FREQ_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK, 0);\r\nreturn;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(user_pclk_rates); i++) {\r\nif ((user_pclk_rates[i] == max98090->sysclk) &&\r\n(user_lrclk_rates[i] == max98090->lrclk)) {\r\ndev_dbg(codec->dev,\r\n"Found user supported PCLK to LRCLK rates\n");\r\ndev_dbg(codec->dev, "i %d ni %lld mi %lld\n",\r\ni, ni_value[i], mi_value[i]);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_FREQ_MASK, 0);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK,\r\n1 << M98090_USE_M1_SHIFT);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,\r\n(ni_value[i] >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB,\r\nni_value[i] & 0xFF);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_MSB,\r\n(mi_value[i] >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_MI_LSB,\r\nmi_value[i] & 0xFF);\r\nreturn;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_FREQ_MASK, 0);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK, 0);\r\nni = 65536ULL * (max98090->lrclk < 50000 ? 96ULL : 48ULL)\r\n* (unsigned long long int)max98090->lrclk;\r\ndo_div(ni, (unsigned long long int)max98090->sysclk);\r\ndev_info(codec->dev, "No better method found\n");\r\ndev_info(codec->dev, "Calculating ni %lld with mi 65536\n", ni);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_MSB,\r\n(ni >> 8) & 0x7F);\r\nsnd_soc_write(codec, M98090_REG_CLOCK_RATIO_NI_LSB, ni & 0xFF);\r\n}\r\nstatic int max98090_dai_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\nu8 regval;\r\nmax98090->dai_fmt = fmt;\r\ncdata = &max98090->dai[0];\r\nif (fmt != cdata->fmt) {\r\ncdata->fmt = fmt;\r\nregval = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_write(codec,\r\nM98090_REG_CLOCK_RATIO_NI_MSB, 0x00);\r\nsnd_soc_write(codec,\r\nM98090_REG_CLOCK_RATIO_NI_LSB, 0x00);\r\nsnd_soc_update_bits(codec, M98090_REG_CLOCK_MODE,\r\nM98090_USE_M1_MASK, 0);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nif (max98090->tdm_slots == 4) {\r\nregval |= M98090_MAS_MASK |\r\nM98090_BSEL_64;\r\n} else if (max98090->tdm_slots == 3) {\r\nregval |= M98090_MAS_MASK |\r\nM98090_BSEL_48;\r\n} else {\r\nregval |= M98090_MAS_MASK |\r\nM98090_BSEL_32;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ndefault:\r\ndev_err(codec->dev, "DAI clock mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, M98090_REG_MASTER_MODE, regval);\r\nregval = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nregval |= M98090_DLY_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nregval |= M98090_RJ_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ndefault:\r\ndev_err(codec->dev, "DAI format unsupported");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nregval |= M98090_WCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nregval |= M98090_BCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nregval |= M98090_BCI_MASK|M98090_WCI_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI invert mode unsupported");\r\nreturn -EINVAL;\r\n}\r\nif (max98090->tdm_slots > 1)\r\nregval ^= M98090_BCI_MASK;\r\nsnd_soc_write(codec,\r\nM98090_REG_INTERFACE_FORMAT, regval);\r\n}\r\nreturn 0;\r\n}\r\nstatic int max98090_set_tdm_slot(struct snd_soc_dai *codec_dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\ncdata = &max98090->dai[0];\r\nif (slots < 0 || slots > 4)\r\nreturn -EINVAL;\r\nmax98090->tdm_slots = slots;\r\nmax98090->tdm_width = slot_width;\r\nif (max98090->tdm_slots > 1) {\r\nsnd_soc_write(codec, M98090_REG_TDM_FORMAT,\r\n0 << M98090_TDM_SLOTL_SHIFT |\r\n1 << M98090_TDM_SLOTR_SHIFT |\r\n0 << M98090_TDM_SLOTDLY_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_TDM_CONTROL,\r\nM98090_TDM_MASK,\r\nM98090_TDM_MASK);\r\n}\r\ncdata->fmt = 0;\r\nmax98090_dai_set_fmt(codec_dai, max98090->dai_fmt);\r\nreturn 0;\r\n}\r\nstatic int max98090_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nif (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {\r\nret = regcache_sync(max98090->regmap);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nif (max98090->jack_state == M98090_JACK_STATE_HEADSET) {\r\nsnd_soc_update_bits(codec, M98090_REG_MIC_BIAS_VOLTAGE,\r\nM98090_MBVSEL_MASK, M98090_MBVSEL_2V8);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDWK_MASK, M98090_JDWK_MASK);\r\nregcache_mark_dirty(max98090->regmap);\r\nbreak;\r\n}\r\ncodec->dapm.bias_level = level;\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\nint i, j;\r\ncdata = &max98090->dai[0];\r\nmax98090->bclk = snd_soc_params_to_bclk(params);\r\nif (params_channels(params) == 1)\r\nmax98090->bclk *= 2;\r\nmax98090->lrclk = params_rate(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nsnd_soc_update_bits(codec, M98090_REG_INTERFACE_FORMAT,\r\nM98090_WS_MASK, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nmax98090_configure_bclk(codec);\r\ncdata->rate = max98090->lrclk;\r\nif (max98090->lrclk < 24000)\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_MODE_MASK, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_MODE_MASK, M98090_MODE_MASK);\r\nif (max98090->lrclk < 50000)\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_DHF_MASK, 0);\r\nelse\r\nsnd_soc_update_bits(codec, M98090_REG_FILTER_CONFIG,\r\nM98090_DHF_MASK, M98090_DHF_MASK);\r\nfor (j = 0; j < ARRAY_SIZE(comp_pclk_rates); j++) {\r\nif (comp_pclk_rates[j] == max98090->sysclk) {\r\nbreak;\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(comp_lrclk_rates) - 1; i++) {\r\nif (max98090->lrclk <= (comp_lrclk_rates[i] +\r\ncomp_lrclk_rates[i + 1]) / 2) {\r\nbreak;\r\n}\r\n}\r\nsnd_soc_update_bits(codec, M98090_REG_DIGITAL_MIC_ENABLE,\r\nM98090_MICCLK_MASK,\r\ndmic_micclk[j] << M98090_MICCLK_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_DIGITAL_MIC_CONFIG,\r\nM98090_DMIC_COMP_MASK,\r\ndmic_comp[j][i] << M98090_DMIC_COMP_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nif (freq == max98090->sysclk)\r\nreturn 0;\r\nif ((freq >= 10000000) && (freq < 20000000)) {\r\nsnd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,\r\nM98090_PSCLK_DIV1);\r\n} else if ((freq >= 20000000) && (freq < 40000000)) {\r\nsnd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,\r\nM98090_PSCLK_DIV2);\r\n} else if ((freq >= 40000000) && (freq < 60000000)) {\r\nsnd_soc_write(codec, M98090_REG_SYSTEM_CLOCK,\r\nM98090_PSCLK_DIV4);\r\n} else {\r\ndev_err(codec->dev, "Invalid master clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\nmax98090->sysclk = freq;\r\nmax98090_configure_bclk(codec);\r\nreturn 0;\r\n}\r\nstatic int max98090_dai_digital_mute(struct snd_soc_dai *codec_dai, int mute)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nint regval;\r\nregval = mute ? M98090_DVM_MASK : 0;\r\nsnd_soc_update_bits(codec, M98090_REG_DAI_PLAYBACK_LEVEL,\r\nM98090_DVM_MASK, regval);\r\nreturn 0;\r\n}\r\nstatic void max98090_jack_work(struct work_struct *work)\r\n{\r\nstruct max98090_priv *max98090 = container_of(work,\r\nstruct max98090_priv,\r\njack_work.work);\r\nstruct snd_soc_codec *codec = max98090->codec;\r\nstruct snd_soc_dapm_context *dapm = &codec->dapm;\r\nint status = 0;\r\nint reg;\r\nif (max98090->jack_state == M98090_JACK_STATE_NO_HEADSET) {\r\nsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDWK_MASK, 0);\r\nmsleep(50);\r\nreg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\r\nsnd_soc_update_bits(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDWK_MASK, M98090_JDWK_MASK);\r\n} else {\r\nreg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\r\n}\r\nreg = snd_soc_read(codec, M98090_REG_JACK_STATUS);\r\nswitch (reg & (M98090_LSNS_MASK | M98090_JKSNS_MASK)) {\r\ncase M98090_LSNS_MASK | M98090_JKSNS_MASK:\r\ndev_dbg(codec->dev, "No Headset Detected\n");\r\nmax98090->jack_state = M98090_JACK_STATE_NO_HEADSET;\r\nstatus |= 0;\r\nbreak;\r\ncase 0:\r\nif (max98090->jack_state ==\r\nM98090_JACK_STATE_HEADSET) {\r\ndev_dbg(codec->dev,\r\n"Headset Button Down Detected\n");\r\nstatus |= SND_JACK_HEADSET;\r\nstatus |= SND_JACK_BTN_0;\r\nbreak;\r\n}\r\ndev_dbg(codec->dev, "Headphone Detected\n");\r\nmax98090->jack_state = M98090_JACK_STATE_HEADPHONE;\r\nstatus |= SND_JACK_HEADPHONE;\r\nbreak;\r\ncase M98090_JKSNS_MASK:\r\ndev_dbg(codec->dev, "Headset Detected\n");\r\nmax98090->jack_state = M98090_JACK_STATE_HEADSET;\r\nstatus |= SND_JACK_HEADSET;\r\nbreak;\r\ndefault:\r\ndev_dbg(codec->dev, "Unrecognized Jack Status\n");\r\nbreak;\r\n}\r\nsnd_soc_jack_report(max98090->jack, status,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\nsnd_soc_dapm_sync(dapm);\r\n}\r\nstatic irqreturn_t max98090_interrupt(int irq, void *data)\r\n{\r\nstruct snd_soc_codec *codec = data;\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nunsigned int mask;\r\nunsigned int active;\r\ndev_dbg(codec->dev, "***** max98090_interrupt *****\n");\r\nret = regmap_read(max98090->regmap, M98090_REG_INTERRUPT_S, &mask);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"failed to read M98090_REG_INTERRUPT_S: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\nret = regmap_read(max98090->regmap, M98090_REG_DEVICE_STATUS, &active);\r\nif (ret != 0) {\r\ndev_err(codec->dev,\r\n"failed to read M98090_REG_DEVICE_STATUS: %d\n",\r\nret);\r\nreturn IRQ_NONE;\r\n}\r\ndev_dbg(codec->dev, "active=0x%02x mask=0x%02x -> active=0x%02x\n",\r\nactive, mask, active & mask);\r\nactive &= mask;\r\nif (!active)\r\nreturn IRQ_NONE;\r\nif (active & M98090_CLD_MASK)\r\ndev_err(codec->dev, "M98090_CLD_MASK\n");\r\nif (active & M98090_SLD_MASK)\r\ndev_dbg(codec->dev, "M98090_SLD_MASK\n");\r\nif (active & M98090_ULK_MASK)\r\ndev_err(codec->dev, "M98090_ULK_MASK\n");\r\nif (active & M98090_JDET_MASK) {\r\ndev_dbg(codec->dev, "M98090_JDET_MASK\n");\r\npm_wakeup_event(codec->dev, 100);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&max98090->jack_work,\r\nmsecs_to_jiffies(100));\r\n}\r\nif (active & M98090_DRCACT_MASK)\r\ndev_dbg(codec->dev, "M98090_DRCACT_MASK\n");\r\nif (active & M98090_DRCCLP_MASK)\r\ndev_err(codec->dev, "M98090_DRCCLP_MASK\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nint max98090_mic_detect(struct snd_soc_codec *codec,\r\nstruct snd_soc_jack *jack)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "max98090_mic_detect\n");\r\nmax98090->jack = jack;\r\nif (jack) {\r\nsnd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,\r\nM98090_IJDET_MASK,\r\n1 << M98090_IJDET_SHIFT);\r\n} else {\r\nsnd_soc_update_bits(codec, M98090_REG_INTERRUPT_S,\r\nM98090_IJDET_MASK,\r\n0);\r\n}\r\nsnd_soc_jack_report(max98090->jack, 0,\r\nSND_JACK_HEADSET | SND_JACK_BTN_0);\r\nqueue_delayed_work(system_power_efficient_wq,\r\n&max98090->jack_work,\r\nmsecs_to_jiffies(100));\r\nreturn 0;\r\n}\r\nstatic void max98090_handle_pdata(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_pdata *pdata = max98090->pdata;\r\nif (!pdata) {\r\ndev_err(codec->dev, "No platform data\n");\r\nreturn;\r\n}\r\n}\r\nstatic int max98090_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\nstruct max98090_cdata *cdata;\r\nint ret = 0;\r\ndev_dbg(codec->dev, "max98090_probe\n");\r\nmax98090->codec = codec;\r\ncodec->control_data = max98090->regmap;\r\nret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_REGMAP);\r\nif (ret != 0) {\r\ndev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);\r\nreturn ret;\r\n}\r\nmax98090_reset(max98090);\r\nmax98090->sysclk = (unsigned)-1;\r\ncdata = &max98090->dai[0];\r\ncdata->rate = (unsigned)-1;\r\ncdata->fmt = (unsigned)-1;\r\nmax98090->lin_state = 0;\r\nmax98090->pa1en = 0;\r\nmax98090->pa2en = 0;\r\nmax98090->extmic_mux = 0;\r\nret = snd_soc_read(codec, M98090_REG_REVISION_ID);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "Failed to read device revision: %d\n",\r\nret);\r\ngoto err_access;\r\n}\r\nif ((ret >= M98090_REVA) && (ret <= M98090_REVA + 0x0f)) {\r\nmax98090->devtype = MAX98090;\r\ndev_info(codec->dev, "MAX98090 REVID=0x%02x\n", ret);\r\n} else if ((ret >= M98091_REVA) && (ret <= M98091_REVA + 0x0f)) {\r\nmax98090->devtype = MAX98091;\r\ndev_info(codec->dev, "MAX98091 REVID=0x%02x\n", ret);\r\n} else {\r\nmax98090->devtype = MAX98090;\r\ndev_err(codec->dev, "Unrecognized revision 0x%02x\n", ret);\r\n}\r\nmax98090->jack_state = M98090_JACK_STATE_NO_HEADSET;\r\nINIT_DELAYED_WORK(&max98090->jack_work, max98090_jack_work);\r\nsnd_soc_write(codec, M98090_REG_JACK_DETECT,\r\nM98090_JDETEN_MASK | M98090_JDEB_25MS);\r\ndev_dbg(codec->dev, "irq = %d\n", max98090->irq);\r\nret = request_threaded_irq(max98090->irq, NULL,\r\nmax98090_interrupt, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"max98090_interrupt", codec);\r\nif (ret < 0) {\r\ndev_err(codec->dev, "request_irq failed: %d\n",\r\nret);\r\n}\r\nsnd_soc_read(codec, M98090_REG_DEVICE_STATUS);\r\nsnd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,\r\nM98090_DACHP_MASK,\r\n1 << M98090_DACHP_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_DAC_CONTROL,\r\nM98090_PERFMODE_MASK,\r\n0 << M98090_PERFMODE_SHIFT);\r\nsnd_soc_update_bits(codec, M98090_REG_ADC_CONTROL,\r\nM98090_ADCHP_MASK,\r\n1 << M98090_ADCHP_SHIFT);\r\nsnd_soc_write(codec, M98090_REG_BIAS_CONTROL,\r\nM98090_VCM_MODE_MASK);\r\nmax98090_handle_pdata(codec);\r\nmax98090_add_widgets(codec);\r\nerr_access:\r\nreturn ret;\r\n}\r\nstatic int max98090_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct max98090_priv *max98090 = snd_soc_codec_get_drvdata(codec);\r\ncancel_delayed_work_sync(&max98090->jack_work);\r\nreturn 0;\r\n}\r\nstatic int max98090_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct max98090_priv *max98090;\r\nint ret;\r\npr_debug("max98090_i2c_probe\n");\r\nmax98090 = devm_kzalloc(&i2c->dev, sizeof(struct max98090_priv),\r\nGFP_KERNEL);\r\nif (max98090 == NULL)\r\nreturn -ENOMEM;\r\nmax98090->devtype = id->driver_data;\r\ni2c_set_clientdata(i2c, max98090);\r\nmax98090->control_data = i2c;\r\nmax98090->pdata = i2c->dev.platform_data;\r\nmax98090->irq = i2c->irq;\r\nmax98090->regmap = devm_regmap_init_i2c(i2c, &max98090_regmap);\r\nif (IS_ERR(max98090->regmap)) {\r\nret = PTR_ERR(max98090->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);\r\ngoto err_enable;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev,\r\n&soc_codec_dev_max98090, max98090_dai,\r\nARRAY_SIZE(max98090_dai));\r\nerr_enable:\r\nreturn ret;\r\n}\r\nstatic int max98090_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}\r\nstatic int max98090_runtime_resume(struct device *dev)\r\n{\r\nstruct max98090_priv *max98090 = dev_get_drvdata(dev);\r\nregcache_cache_only(max98090->regmap, false);\r\nregcache_sync(max98090->regmap);\r\nreturn 0;\r\n}\r\nstatic int max98090_runtime_suspend(struct device *dev)\r\n{\r\nstruct max98090_priv *max98090 = dev_get_drvdata(dev);\r\nregcache_cache_only(max98090->regmap, true);\r\nreturn 0;\r\n}
