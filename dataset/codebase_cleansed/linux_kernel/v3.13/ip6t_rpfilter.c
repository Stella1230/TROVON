static bool rpfilter_addr_unicast(const struct in6_addr *addr)\r\n{\r\nint addr_type = ipv6_addr_type(addr);\r\nreturn addr_type & IPV6_ADDR_UNICAST;\r\n}\r\nstatic bool rpfilter_lookup_reverse6(const struct sk_buff *skb,\r\nconst struct net_device *dev, u8 flags)\r\n{\r\nstruct rt6_info *rt;\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nbool ret = false;\r\nstruct flowi6 fl6 = {\r\n.flowlabel = (* (__be32 *) iph) & IPV6_FLOWINFO_MASK,\r\n.flowi6_proto = iph->nexthdr,\r\n.daddr = iph->saddr,\r\n};\r\nint lookup_flags;\r\nif (rpfilter_addr_unicast(&iph->daddr)) {\r\nmemcpy(&fl6.saddr, &iph->daddr, sizeof(struct in6_addr));\r\nlookup_flags = RT6_LOOKUP_F_HAS_SADDR;\r\n} else {\r\nlookup_flags = 0;\r\n}\r\nfl6.flowi6_mark = flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;\r\nif ((flags & XT_RPFILTER_LOOSE) == 0) {\r\nfl6.flowi6_oif = dev->ifindex;\r\nlookup_flags |= RT6_LOOKUP_F_IFACE;\r\n}\r\nrt = (void *) ip6_route_lookup(dev_net(dev), &fl6, lookup_flags);\r\nif (rt->dst.error)\r\ngoto out;\r\nif (rt->rt6i_flags & (RTF_REJECT|RTF_ANYCAST))\r\ngoto out;\r\nif (rt->rt6i_flags & RTF_LOCAL) {\r\nret = flags & XT_RPFILTER_ACCEPT_LOCAL;\r\ngoto out;\r\n}\r\nif (rt->rt6i_idev->dev == dev || (flags & XT_RPFILTER_LOOSE))\r\nret = true;\r\nout:\r\nip6_rt_put(rt);\r\nreturn ret;\r\n}\r\nstatic bool rpfilter_is_local(const struct sk_buff *skb)\r\n{\r\nconst struct rt6_info *rt = (const void *) skb_dst(skb);\r\nreturn rt && (rt->rt6i_flags & RTF_LOCAL);\r\n}\r\nstatic bool rpfilter_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct xt_rpfilter_info *info = par->matchinfo;\r\nint saddrtype;\r\nstruct ipv6hdr *iph;\r\nbool invert = info->flags & XT_RPFILTER_INVERT;\r\nif (rpfilter_is_local(skb))\r\nreturn true ^ invert;\r\niph = ipv6_hdr(skb);\r\nsaddrtype = ipv6_addr_type(&iph->saddr);\r\nif (unlikely(saddrtype == IPV6_ADDR_ANY))\r\nreturn true ^ invert;\r\nreturn rpfilter_lookup_reverse6(skb, par->in, info->flags) ^ invert;\r\n}\r\nstatic int rpfilter_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct xt_rpfilter_info *info = par->matchinfo;\r\nunsigned int options = ~XT_RPFILTER_OPTION_MASK;\r\nif (info->flags & options) {\r\npr_info("unknown options encountered");\r\nreturn -EINVAL;\r\n}\r\nif (strcmp(par->table, "mangle") != 0 &&\r\nstrcmp(par->table, "raw") != 0) {\r\npr_info("match only valid in the \'raw\' "\r\n"or \'mangle\' tables, not \'%s\'.\n", par->table);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init rpfilter_mt_init(void)\r\n{\r\nreturn xt_register_match(&rpfilter_mt_reg);\r\n}\r\nstatic void __exit rpfilter_mt_exit(void)\r\n{\r\nxt_unregister_match(&rpfilter_mt_reg);\r\n}
