static inline unsigned long sun4d_swap(volatile unsigned long *ptr, unsigned long val)\r\n{\r\n__asm__ __volatile__("swap [%1], %0\n\t" :\r\n"=&r" (val), "=&r" (ptr) :\r\n"0" (val), "1" (ptr));\r\nreturn val;\r\n}\r\nstatic inline void show_leds(int cpuid)\r\n{\r\ncpuid &= 0x1e;\r\n__asm__ __volatile__ ("stba %0, [%1] %2" : :\r\n"r" ((cpu_leds[cpuid] << 4) | cpu_leds[cpuid+1]),\r\n"r" (ECSR_BASE(cpuid) | BB_LEDS),\r\n"i" (ASI_M_CTL));\r\n}\r\nvoid sun4d_cpu_pre_starting(void *arg)\r\n{\r\nint cpuid = hard_smp_processor_id();\r\ncpu_leds[cpuid] = 0x6;\r\nshow_leds(cpuid);\r\ncc_set_imsk((cc_get_imsk() & ~0x8000) | 0x4000);\r\n}\r\nvoid sun4d_cpu_pre_online(void *arg)\r\n{\r\nunsigned long flags;\r\nint cpuid;\r\ncpuid = hard_smp_processor_id();\r\nsun4d_swap((unsigned long *)&cpu_callin_map[cpuid], 1);\r\nlocal_ops->cache_all();\r\nlocal_ops->tlb_all();\r\nwhile ((unsigned long)current_set[cpuid] < PAGE_OFFSET)\r\nbarrier();\r\nwhile (current_set[cpuid]->cpu != cpuid)\r\nbarrier();\r\n__asm__ __volatile__("ld [%0], %%g6\n\t"\r\n: : "r" (&current_set[cpuid])\r\n: "memory" );\r\ncpu_leds[cpuid] = 0x9;\r\nshow_leds(cpuid);\r\natomic_inc(&init_mm.mm_count);\r\ncurrent->active_mm = &init_mm;\r\nlocal_ops->cache_all();\r\nlocal_ops->tlb_all();\r\nwhile (!cpumask_test_cpu(cpuid, &smp_commenced_mask))\r\nbarrier();\r\nspin_lock_irqsave(&sun4d_imsk_lock, flags);\r\ncc_set_imsk(cc_get_imsk() & ~0x4000);\r\nspin_unlock_irqrestore(&sun4d_imsk_lock, flags);\r\n}\r\nvoid __init smp4d_boot_cpus(void)\r\n{\r\nsmp4d_ipi_init();\r\nif (boot_cpu_id)\r\ncurrent_set[0] = NULL;\r\nlocal_ops->cache_all();\r\n}\r\nint smp4d_boot_one_cpu(int i, struct task_struct *idle)\r\n{\r\nunsigned long *entry = &sun4d_cpu_startup;\r\nint timeout;\r\nint cpu_node;\r\ncpu_find_by_instance(i, &cpu_node, NULL);\r\ncurrent_set[i] = task_thread_info(idle);\r\nsmp_penguin_ctable.which_io = 0;\r\nsmp_penguin_ctable.phys_addr = (unsigned int) srmmu_ctx_table_phys;\r\nsmp_penguin_ctable.reg_size = 0;\r\nprintk(KERN_INFO "Starting CPU %d at %p\n", i, entry);\r\nlocal_ops->cache_all();\r\nprom_startcpu(cpu_node,\r\n&smp_penguin_ctable, 0, (char *)entry);\r\nprintk(KERN_INFO "prom_startcpu returned :)\n");\r\nfor (timeout = 0; timeout < 10000; timeout++) {\r\nif (cpu_callin_map[i])\r\nbreak;\r\nudelay(200);\r\n}\r\nif (!(cpu_callin_map[i])) {\r\nprintk(KERN_ERR "Processor %d is stuck.\n", i);\r\nreturn -ENODEV;\r\n}\r\nlocal_ops->cache_all();\r\nreturn 0;\r\n}\r\nvoid __init smp4d_smp_done(void)\r\n{\r\nint i, first;\r\nint *prev;\r\nfirst = 0;\r\nprev = &first;\r\nfor_each_online_cpu(i) {\r\n*prev = i;\r\nprev = &cpu_data(i).next;\r\n}\r\n*prev = first;\r\nlocal_ops->cache_all();\r\nsmp_processors_ready = 1;\r\nsun4d_distribute_irqs();\r\n}\r\nstatic void __init smp4d_ipi_init(void)\r\n{\r\nint cpu;\r\nstruct sun4d_ipi_work *work;\r\nprintk(KERN_INFO "smp4d: setup IPI at IRQ %d\n", SUN4D_IPI_IRQ);\r\nfor_each_possible_cpu(cpu) {\r\nwork = &per_cpu(sun4d_ipi_work, cpu);\r\nwork->single = work->msk = work->resched = 0;\r\n}\r\n}\r\nvoid sun4d_ipi_interrupt(void)\r\n{\r\nstruct sun4d_ipi_work *work = &__get_cpu_var(sun4d_ipi_work);\r\nif (work->single) {\r\nwork->single = 0;\r\nsmp_call_function_single_interrupt();\r\n}\r\nif (work->msk) {\r\nwork->msk = 0;\r\nsmp_call_function_interrupt();\r\n}\r\nif (work->resched) {\r\nwork->resched = 0;\r\nsmp_resched_interrupt();\r\n}\r\n}\r\nstatic void sun4d_send_ipi(int cpu, int level)\r\n{\r\ncc_set_igen(IGEN_MESSAGE(0, cpu << 3, 6 + ((level >> 1) & 7), 1 << (level - 1)));\r\n}\r\nstatic void sun4d_ipi_single(int cpu)\r\n{\r\nstruct sun4d_ipi_work *work = &per_cpu(sun4d_ipi_work, cpu);\r\nwork->single = 1;\r\nsun4d_send_ipi(cpu, SUN4D_IPI_IRQ);\r\n}\r\nstatic void sun4d_ipi_mask_one(int cpu)\r\n{\r\nstruct sun4d_ipi_work *work = &per_cpu(sun4d_ipi_work, cpu);\r\nwork->msk = 1;\r\nsun4d_send_ipi(cpu, SUN4D_IPI_IRQ);\r\n}\r\nstatic void sun4d_ipi_resched(int cpu)\r\n{\r\nstruct sun4d_ipi_work *work = &per_cpu(sun4d_ipi_work, cpu);\r\nwork->resched = 1;\r\nsun4d_send_ipi(cpu, SUN4D_IPI_IRQ);\r\n}\r\nstatic void sun4d_cross_call(smpfunc_t func, cpumask_t mask, unsigned long arg1,\r\nunsigned long arg2, unsigned long arg3,\r\nunsigned long arg4)\r\n{\r\nif (smp_processors_ready) {\r\nregister int high = smp_highest_cpu;\r\nunsigned long flags;\r\nspin_lock_irqsave(&cross_call_lock, flags);\r\n{\r\nregister smpfunc_t f asm("i0") = func;\r\nregister unsigned long a1 asm("i1") = arg1;\r\nregister unsigned long a2 asm("i2") = arg2;\r\nregister unsigned long a3 asm("i3") = arg3;\r\nregister unsigned long a4 asm("i4") = arg4;\r\nregister unsigned long a5 asm("i5") = 0;\r\n__asm__ __volatile__(\r\n"std %0, [%6]\n\t"\r\n"std %2, [%6 + 8]\n\t"\r\n"std %4, [%6 + 16]\n\t" : :\r\n"r"(f), "r"(a1), "r"(a2), "r"(a3), "r"(a4), "r"(a5),\r\n"r" (&ccall_info.func));\r\n}\r\n{\r\nregister int i;\r\ncpumask_clear_cpu(smp_processor_id(), &mask);\r\ncpumask_and(&mask, cpu_online_mask, &mask);\r\nfor (i = 0; i <= high; i++) {\r\nif (cpumask_test_cpu(i, &mask)) {\r\nccall_info.processors_in[i] = 0;\r\nccall_info.processors_out[i] = 0;\r\nsun4d_send_ipi(i, IRQ_CROSS_CALL);\r\n}\r\n}\r\n}\r\n{\r\nregister int i;\r\ni = 0;\r\ndo {\r\nif (!cpumask_test_cpu(i, &mask))\r\ncontinue;\r\nwhile (!ccall_info.processors_in[i])\r\nbarrier();\r\n} while (++i <= high);\r\ni = 0;\r\ndo {\r\nif (!cpumask_test_cpu(i, &mask))\r\ncontinue;\r\nwhile (!ccall_info.processors_out[i])\r\nbarrier();\r\n} while (++i <= high);\r\n}\r\nspin_unlock_irqrestore(&cross_call_lock, flags);\r\n}\r\n}\r\nvoid smp4d_cross_call_irq(void)\r\n{\r\nint i = hard_smp_processor_id();\r\nccall_info.processors_in[i] = 1;\r\nccall_info.func(ccall_info.arg1, ccall_info.arg2, ccall_info.arg3,\r\nccall_info.arg4, ccall_info.arg5);\r\nccall_info.processors_out[i] = 1;\r\n}\r\nvoid smp4d_percpu_timer_interrupt(struct pt_regs *regs)\r\n{\r\nstruct pt_regs *old_regs;\r\nint cpu = hard_smp_processor_id();\r\nstruct clock_event_device *ce;\r\nstatic int cpu_tick[NR_CPUS];\r\nstatic char led_mask[] = { 0xe, 0xd, 0xb, 0x7, 0xb, 0xd };\r\nold_regs = set_irq_regs(regs);\r\nbw_get_prof_limit(cpu);\r\nbw_clear_intr_mask(0, 1);\r\ncpu_tick[cpu]++;\r\nif (!(cpu_tick[cpu] & 15)) {\r\nif (cpu_tick[cpu] == 0x60)\r\ncpu_tick[cpu] = 0;\r\ncpu_leds[cpu] = led_mask[cpu_tick[cpu] >> 4];\r\nshow_leds(cpu);\r\n}\r\nce = &per_cpu(sparc32_clockevent, cpu);\r\nirq_enter();\r\nce->event_handler(ce);\r\nirq_exit();\r\nset_irq_regs(old_regs);\r\n}\r\nvoid __init sun4d_init_smp(void)\r\n{\r\nint i;\r\nt_nmi[1] = t_nmi[1] + (linux_trap_ipi15_sun4d - linux_trap_ipi15_sun4m);\r\nsparc32_ipi_ops = &sun4d_ipi_ops;\r\nfor (i = 0; i < NR_CPUS; i++) {\r\nccall_info.processors_in[i] = 1;\r\nccall_info.processors_out[i] = 1;\r\n}\r\n}
