int cl_init_ea_size(struct obd_export *md_exp, struct obd_export *dt_exp)\r\n{\r\nstruct lov_stripe_md lsm = { .lsm_magic = LOV_MAGIC_V3 };\r\n__u32 valsize = sizeof(struct lov_desc);\r\nint rc, easize, def_easize, cookiesize;\r\nstruct lov_desc desc;\r\n__u16 stripes;\r\nrc = obd_get_info(NULL, dt_exp, sizeof(KEY_LOVDESC), KEY_LOVDESC,\r\n&valsize, &desc, NULL);\r\nif (rc)\r\nreturn rc;\r\nstripes = min(desc.ld_tgt_count, (__u32)LOV_MAX_STRIPE_COUNT);\r\nlsm.lsm_stripe_count = stripes;\r\neasize = obd_size_diskmd(dt_exp, &lsm);\r\nlsm.lsm_stripe_count = desc.ld_default_stripe_count;\r\ndef_easize = obd_size_diskmd(dt_exp, &lsm);\r\ncookiesize = stripes * sizeof(struct llog_cookie);\r\nCDEBUG(D_HA, "updating max_mdsize/max_cookiesize: %d/%d\n",\r\neasize, cookiesize);\r\nrc = md_init_ea_size(md_exp, easize, def_easize, cookiesize);\r\nreturn rc;\r\n}\r\nint cl_ocd_update(struct obd_device *host,\r\nstruct obd_device *watched,\r\nenum obd_notify_event ev, void *owner, void *data)\r\n{\r\nstruct lustre_client_ocd *lco;\r\nstruct client_obd *cli;\r\n__u64 flags;\r\nint result;\r\nif (!strcmp(watched->obd_type->typ_name, LUSTRE_OSC_NAME)) {\r\ncli = &watched->u.cli;\r\nlco = owner;\r\nflags = cli->cl_import->imp_connect_data.ocd_connect_flags;\r\nCDEBUG(D_SUPER, "Changing connect_flags: "LPX64" -> "LPX64"\n",\r\nlco->lco_flags, flags);\r\nmutex_lock(&lco->lco_lock);\r\nlco->lco_flags &= flags;\r\nif (lco->lco_dt_exp)\r\ncl_init_ea_size(lco->lco_md_exp, lco->lco_dt_exp);\r\nmutex_unlock(&lco->lco_lock);\r\nresult = 0;\r\n} else {\r\nCERROR("unexpected notification from %s %s!\n",\r\nwatched->obd_type->typ_name,\r\nwatched->obd_name);\r\nresult = -EINVAL;\r\n}\r\nreturn result;\r\n}\r\nint cl_get_grouplock(struct cl_object *obj, unsigned long gid, int nonblock,\r\nstruct ccc_grouplock *cg)\r\n{\r\nstruct lu_env *env;\r\nstruct cl_io *io;\r\nstruct cl_lock *lock;\r\nstruct cl_lock_descr *descr;\r\n__u32 enqflags;\r\nint refcheck;\r\nint rc;\r\nenv = cl_env_get(&refcheck);\r\nif (IS_ERR(env))\r\nreturn PTR_ERR(env);\r\nio = ccc_env_thread_io(env);\r\nio->ci_obj = obj;\r\nio->ci_ignore_layout = 1;\r\nrc = cl_io_init(env, io, CIT_MISC, io->ci_obj);\r\nif (rc) {\r\nLASSERT(rc < 0);\r\ncl_env_put(env, &refcheck);\r\nreturn rc;\r\n}\r\ndescr = &ccc_env_info(env)->cti_descr;\r\ndescr->cld_obj = obj;\r\ndescr->cld_start = 0;\r\ndescr->cld_end = CL_PAGE_EOF;\r\ndescr->cld_gid = gid;\r\ndescr->cld_mode = CLM_GROUP;\r\nenqflags = CEF_MUST | (nonblock ? CEF_NONBLOCK : 0);\r\ndescr->cld_enq_flags = enqflags;\r\nlock = cl_lock_request(env, io, descr, GROUPLOCK_SCOPE, current);\r\nif (IS_ERR(lock)) {\r\ncl_io_fini(env, io);\r\ncl_env_put(env, &refcheck);\r\nreturn PTR_ERR(lock);\r\n}\r\ncg->cg_env = cl_env_get(&refcheck);\r\ncg->cg_io = io;\r\ncg->cg_lock = lock;\r\ncg->cg_gid = gid;\r\nLASSERT(cg->cg_env == env);\r\ncl_env_unplant(env, &refcheck);\r\nreturn 0;\r\n}\r\nvoid cl_put_grouplock(struct ccc_grouplock *cg)\r\n{\r\nstruct lu_env *env = cg->cg_env;\r\nstruct cl_io *io = cg->cg_io;\r\nstruct cl_lock *lock = cg->cg_lock;\r\nint refcheck;\r\nLASSERT(cg->cg_env);\r\nLASSERT(cg->cg_gid);\r\ncl_env_implant(env, &refcheck);\r\ncl_env_put(env, &refcheck);\r\ncl_unuse(env, lock);\r\ncl_lock_release(env, lock, GROUPLOCK_SCOPE, current);\r\ncl_io_fini(env, io);\r\ncl_env_put(env, NULL);\r\n}
