int libcfs_ukuc_start(lustre_kernelcomm *link, int group)\r\n{\r\nint pfd[2];\r\nif (pipe(pfd) < 0)\r\nreturn -errno;\r\nmemset(link, 0, sizeof(*link));\r\nlink->lk_rfd = pfd[0];\r\nlink->lk_wfd = pfd[1];\r\nlink->lk_group = group;\r\nlink->lk_uid = getpid();\r\nreturn 0;\r\n}\r\nint libcfs_ukuc_stop(lustre_kernelcomm *link)\r\n{\r\nif (link->lk_wfd > 0)\r\nclose(link->lk_wfd);\r\nreturn close(link->lk_rfd);\r\n}\r\nint libcfs_ukuc_msg_get(lustre_kernelcomm *link, char *buf, int maxsize,\r\nint transport)\r\n{\r\nstruct kuc_hdr *kuch;\r\nint rc = 0;\r\nmemset(buf, 0, maxsize);\r\nCDEBUG(D_KUC, "Waiting for message from kernel on fd %d\n",\r\nlink->lk_rfd);\r\nwhile (1) {\r\nrc = read(link->lk_rfd, buf, lhsz);\r\nif (rc <= 0) {\r\nrc = -errno;\r\nbreak;\r\n}\r\nkuch = (struct kuc_hdr *)buf;\r\nCDEBUG(D_KUC, "Received message mg=%x t=%d m=%d l=%d\n",\r\nkuch->kuc_magic, kuch->kuc_transport, kuch->kuc_msgtype,\r\nkuch->kuc_msglen);\r\nif (kuch->kuc_magic != KUC_MAGIC) {\r\nCERROR("bad message magic %x != %x\n",\r\nkuch->kuc_magic, KUC_MAGIC);\r\nrc = -EPROTO;\r\nbreak;\r\n}\r\nif (kuch->kuc_msglen > maxsize) {\r\nrc = -EMSGSIZE;\r\nbreak;\r\n}\r\nrc = read(link->lk_rfd, buf + lhsz, kuch->kuc_msglen - lhsz);\r\nif (rc < 0) {\r\nrc = -errno;\r\nbreak;\r\n}\r\nif (rc < (kuch->kuc_msglen - lhsz)) {\r\nCERROR("short read: got %d of %d bytes\n",\r\nrc, kuch->kuc_msglen);\r\nrc = -EPROTO;\r\nbreak;\r\n}\r\nif (kuch->kuc_transport == transport ||\r\nkuch->kuc_transport == KUC_TRANSPORT_GENERIC) {\r\nreturn 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint libcfs_kkuc_msg_put(struct file *filp, void *payload)\r\n{\r\nstruct kuc_hdr *kuch = (struct kuc_hdr *)payload;\r\nssize_t count = kuch->kuc_msglen;\r\nloff_t offset = 0;\r\nmm_segment_t fs;\r\nint rc = -ENOSYS;\r\nif (filp == NULL || IS_ERR(filp))\r\nreturn -EBADF;\r\nif (kuch->kuc_magic != KUC_MAGIC) {\r\nCERROR("KernelComm: bad magic %x\n", kuch->kuc_magic);\r\nreturn -ENOSYS;\r\n}\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nwhile (count > 0) {\r\nrc = vfs_write(filp, (void __force __user *)payload,\r\ncount, &offset);\r\nif (rc < 0)\r\nbreak;\r\ncount -= rc;\r\npayload += rc;\r\nrc = 0;\r\n}\r\nset_fs(fs);\r\nif (rc < 0)\r\nCWARN("message send failed (%d)\n", rc);\r\nelse\r\nCDEBUG(D_KUC, "Sent message rc=%d, fp=%p\n", rc, filp);\r\nreturn rc;\r\n}\r\nint libcfs_kkuc_group_add(struct file *filp, int uid, int group, __u32 data)\r\n{\r\nstruct kkuc_reg *reg;\r\nif (group > KUC_GRP_MAX) {\r\nCDEBUG(D_WARNING, "Kernelcomm: bad group %d\n", group);\r\nreturn -EINVAL;\r\n}\r\nif (filp == NULL)\r\nreturn -EBADF;\r\nreg = kmalloc(sizeof(*reg), 0);\r\nif (reg == NULL)\r\nreturn -ENOMEM;\r\nreg->kr_fp = filp;\r\nreg->kr_uid = uid;\r\nreg->kr_data = data;\r\ndown_write(&kg_sem);\r\nif (kkuc_groups[group].next == NULL)\r\nINIT_LIST_HEAD(&kkuc_groups[group]);\r\nlist_add(&reg->kr_chain, &kkuc_groups[group]);\r\nup_write(&kg_sem);\r\nCDEBUG(D_KUC, "Added uid=%d fp=%p to group %d\n", uid, filp, group);\r\nreturn 0;\r\n}\r\nint libcfs_kkuc_group_rem(int uid, int group)\r\n{\r\nstruct kkuc_reg *reg, *next;\r\nif (kkuc_groups[group].next == NULL)\r\nreturn 0;\r\nif (uid == 0) {\r\nstruct kuc_hdr lh;\r\nlh.kuc_magic = KUC_MAGIC;\r\nlh.kuc_transport = KUC_TRANSPORT_GENERIC;\r\nlh.kuc_msgtype = KUC_MSG_SHUTDOWN;\r\nlh.kuc_msglen = sizeof(lh);\r\nlibcfs_kkuc_group_put(group, &lh);\r\n}\r\ndown_write(&kg_sem);\r\nlist_for_each_entry_safe(reg, next, &kkuc_groups[group], kr_chain) {\r\nif ((uid == 0) || (uid == reg->kr_uid)) {\r\nlist_del(&reg->kr_chain);\r\nCDEBUG(D_KUC, "Removed uid=%d fp=%p from group %d\n",\r\nreg->kr_uid, reg->kr_fp, group);\r\nif (reg->kr_fp != NULL)\r\nfput(reg->kr_fp);\r\nkfree(reg);\r\n}\r\n}\r\nup_write(&kg_sem);\r\nreturn 0;\r\n}\r\nint libcfs_kkuc_group_put(int group, void *payload)\r\n{\r\nstruct kkuc_reg *reg;\r\nint rc = 0;\r\nint one_success = 0;\r\ndown_read(&kg_sem);\r\nlist_for_each_entry(reg, &kkuc_groups[group], kr_chain) {\r\nif (reg->kr_fp != NULL) {\r\nrc = libcfs_kkuc_msg_put(reg->kr_fp, payload);\r\nif (rc == 0)\r\none_success = 1;\r\nelse if (rc == -EPIPE) {\r\nfput(reg->kr_fp);\r\nreg->kr_fp = NULL;\r\n}\r\n}\r\n}\r\nup_read(&kg_sem);\r\nif (one_success)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint libcfs_kkuc_group_foreach(int group, libcfs_kkuc_cb_t cb_func,\r\nvoid *cb_arg)\r\n{\r\nstruct kkuc_reg *reg;\r\nint rc = 0;\r\nif (group > KUC_GRP_MAX) {\r\nCDEBUG(D_WARNING, "Kernelcomm: bad group %d\n", group);\r\nreturn -EINVAL;\r\n}\r\nif (kkuc_groups[group].next == NULL)\r\nreturn 0;\r\ndown_read(&kg_sem);\r\nlist_for_each_entry(reg, &kkuc_groups[group], kr_chain) {\r\nif (reg->kr_fp != NULL) {\r\nrc = cb_func(reg->kr_data, cb_arg);\r\n}\r\n}\r\nup_read(&kg_sem);\r\nreturn rc;\r\n}
