void\r\nsnd_emux_init_seq_oss(struct snd_emux *emu)\r\n{\r\nstruct snd_seq_oss_reg *arg;\r\nstruct snd_seq_device *dev;\r\nif (snd_seq_device_new(emu->card, 0, SNDRV_SEQ_DEV_ID_OSS,\r\nsizeof(struct snd_seq_oss_reg), &dev) < 0)\r\nreturn;\r\nemu->oss_synth = dev;\r\nstrcpy(dev->name, emu->name);\r\narg = SNDRV_SEQ_DEVICE_ARGPTR(dev);\r\narg->type = SYNTH_TYPE_SAMPLE;\r\narg->subtype = SAMPLE_TYPE_AWE32;\r\narg->nvoices = emu->max_voices;\r\narg->oper = oss_callback;\r\narg->private_data = emu;\r\nsnd_device_register(emu->card, dev);\r\n}\r\nvoid\r\nsnd_emux_detach_seq_oss(struct snd_emux *emu)\r\n{\r\nif (emu->oss_synth) {\r\nsnd_device_free(emu->card, emu->oss_synth);\r\nemu->oss_synth = NULL;\r\n}\r\n}\r\nstatic int\r\nsnd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_port *p;\r\nstruct snd_seq_port_callback callback;\r\nchar tmpname[64];\r\nemu = closure;\r\nif (snd_BUG_ON(!arg || !emu))\r\nreturn -ENXIO;\r\nmutex_lock(&emu->register_mutex);\r\nif (!snd_emux_inc_count(emu)) {\r\nmutex_unlock(&emu->register_mutex);\r\nreturn -EFAULT;\r\n}\r\nmemset(&callback, 0, sizeof(callback));\r\ncallback.owner = THIS_MODULE;\r\ncallback.event_input = snd_emux_event_oss_input;\r\nsprintf(tmpname, "%s OSS Port", emu->name);\r\np = snd_emux_create_port(emu, tmpname, 32,\r\n1, &callback);\r\nif (p == NULL) {\r\nsnd_printk(KERN_ERR "can't create port\n");\r\nsnd_emux_dec_count(emu);\r\nmutex_unlock(&emu->register_mutex);\r\nreturn -ENOMEM;\r\n}\r\narg->private_data = p;\r\narg->addr.client = p->chset.client;\r\narg->addr.port = p->chset.port;\r\np->oss_arg = arg;\r\nreset_port_mode(p, arg->seq_mode);\r\nsnd_emux_reset_port(p);\r\nmutex_unlock(&emu->register_mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\nreset_port_mode(struct snd_emux_port *port, int midi_mode)\r\n{\r\nif (midi_mode) {\r\nport->port_mode = SNDRV_EMUX_PORT_MODE_OSS_MIDI;\r\nport->drum_flags = DEFAULT_DRUM_FLAGS;\r\nport->volume_atten = 0;\r\nport->oss_arg->event_passing = SNDRV_SEQ_OSS_PROCESS_KEYPRESS;\r\n} else {\r\nport->port_mode = SNDRV_EMUX_PORT_MODE_OSS_SYNTH;\r\nport->drum_flags = 0;\r\nport->volume_atten = 32;\r\nport->oss_arg->event_passing = SNDRV_SEQ_OSS_PROCESS_EVENTS;\r\n}\r\n}\r\nstatic int\r\nsnd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_port *p;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\np = arg->private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -ENXIO;\r\nemu = p->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nmutex_lock(&emu->register_mutex);\r\nsnd_emux_sounds_off_all(p);\r\nsnd_soundfont_close_check(emu->sflist, SF_CLIENT_NO(p->chset.port));\r\nsnd_seq_event_port_detach(p->chset.client, p->chset.port);\r\nsnd_emux_dec_count(emu);\r\nmutex_unlock(&emu->register_mutex);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_emux_load_patch_seq_oss(struct snd_seq_oss_arg *arg, int format,\r\nconst char __user *buf, int offs, int count)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_port *p;\r\nint rc;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\np = arg->private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -ENXIO;\r\nemu = p->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nif (format == GUS_PATCH)\r\nrc = snd_soundfont_load_guspatch(emu->sflist, buf, count,\r\nSF_CLIENT_NO(p->chset.port));\r\nelse if (format == SNDRV_OSS_SOUNDFONT_PATCH) {\r\nstruct soundfont_patch_info patch;\r\nif (count < (int)sizeof(patch))\r\nrc = -EINVAL;\r\nif (copy_from_user(&patch, buf, sizeof(patch)))\r\nrc = -EFAULT;\r\nif (patch.type >= SNDRV_SFNT_LOAD_INFO &&\r\npatch.type <= SNDRV_SFNT_PROBE_DATA)\r\nrc = snd_soundfont_load(emu->sflist, buf, count, SF_CLIENT_NO(p->chset.port));\r\nelse {\r\nif (emu->ops.load_fx)\r\nrc = emu->ops.load_fx(emu, patch.type, patch.optarg, buf, count);\r\nelse\r\nrc = -EINVAL;\r\n}\r\n} else\r\nrc = 0;\r\nreturn rc;\r\n}\r\nstatic int\r\nsnd_emux_ioctl_seq_oss(struct snd_seq_oss_arg *arg, unsigned int cmd, unsigned long ioarg)\r\n{\r\nstruct snd_emux_port *p;\r\nstruct snd_emux *emu;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\np = arg->private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -ENXIO;\r\nemu = p->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -ENXIO;\r\nswitch (cmd) {\r\ncase SNDCTL_SEQ_RESETSAMPLES:\r\nsnd_soundfont_remove_samples(emu->sflist);\r\nreturn 0;\r\ncase SNDCTL_SYNTH_MEMAVL:\r\nif (emu->memhdr)\r\nreturn snd_util_mem_avail(emu->memhdr);\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_emux_reset_seq_oss(struct snd_seq_oss_arg *arg)\r\n{\r\nstruct snd_emux_port *p;\r\nif (snd_BUG_ON(!arg))\r\nreturn -ENXIO;\r\np = arg->private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -ENXIO;\r\nsnd_emux_reset_port(p);\r\nreturn 0;\r\n}\r\nstatic int\r\nsnd_emux_event_oss_input(struct snd_seq_event *ev, int direct, void *private_data,\r\nint atomic, int hop)\r\n{\r\nstruct snd_emux *emu;\r\nstruct snd_emux_port *p;\r\nunsigned char cmd, *data;\r\np = private_data;\r\nif (snd_BUG_ON(!p))\r\nreturn -EINVAL;\r\nemu = p->emu;\r\nif (snd_BUG_ON(!emu))\r\nreturn -EINVAL;\r\nif (ev->type != SNDRV_SEQ_EVENT_OSS)\r\nreturn snd_emux_event_input(ev, direct, private_data, atomic, hop);\r\ndata = ev->data.raw8.d;\r\nif (data[0] != 0xfe)\r\nreturn 0;\r\ncmd = data[2] & _EMUX_OSS_MODE_VALUE_MASK;\r\nif (data[2] & _EMUX_OSS_MODE_FLAG)\r\nemuspec_control(emu, p, cmd, data, atomic, hop);\r\nelse\r\ngusspec_control(emu, p, cmd, data, atomic, hop);\r\nreturn 0;\r\n}\r\nstatic void\r\nemuspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,\r\nunsigned char *event, int atomic, int hop)\r\n{\r\nint voice;\r\nunsigned short p1;\r\nshort p2;\r\nint i;\r\nstruct snd_midi_channel *chan;\r\nvoice = event[3];\r\nif (voice < 0 || voice >= port->chset.max_channels)\r\nchan = NULL;\r\nelse\r\nchan = &port->chset.channels[voice];\r\np1 = *(unsigned short *) &event[4];\r\np2 = *(short *) &event[6];\r\nswitch (cmd) {\r\n#if 0\r\ncase _EMUX_OSS_REMOVE_LAST_SAMPLES:\r\nsnd_soundfont_remove_unlocked(emu->sflist);\r\nbreak;\r\n#endif\r\ncase _EMUX_OSS_SEND_EFFECT:\r\nif (chan)\r\nsnd_emux_send_effect_oss(port, chan, p1, p2);\r\nbreak;\r\ncase _EMUX_OSS_TERMINATE_ALL:\r\nsnd_emux_terminate_all(emu);\r\nbreak;\r\ncase _EMUX_OSS_TERMINATE_CHANNEL:\r\nbreak;\r\ncase _EMUX_OSS_RESET_CHANNEL:\r\nbreak;\r\ncase _EMUX_OSS_RELEASE_ALL:\r\nfake_event(emu, port, voice, MIDI_CTL_ALL_NOTES_OFF, 0, atomic, hop);\r\nbreak;\r\ncase _EMUX_OSS_NOTEOFF_ALL:\r\nfake_event(emu, port, voice, MIDI_CTL_ALL_SOUNDS_OFF, 0, atomic, hop);\r\nbreak;\r\ncase _EMUX_OSS_INITIAL_VOLUME:\r\nif (p2) {\r\nport->volume_atten = (short)p1;\r\nsnd_emux_update_port(port, SNDRV_EMUX_UPDATE_VOLUME);\r\n}\r\nbreak;\r\ncase _EMUX_OSS_CHN_PRESSURE:\r\nif (chan) {\r\nchan->midi_pressure = p1;\r\nsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_FMMOD|SNDRV_EMUX_UPDATE_FM2FRQ2);\r\n}\r\nbreak;\r\ncase _EMUX_OSS_CHANNEL_MODE:\r\nreset_port_mode(port, p1);\r\nsnd_emux_reset_port(port);\r\nbreak;\r\ncase _EMUX_OSS_DRUM_CHANNELS:\r\nport->drum_flags = *(unsigned int*)&event[4];\r\nfor (i = 0; i < port->chset.max_channels; i++) {\r\nchan = &port->chset.channels[i];\r\nchan->drum_channel = ((port->drum_flags >> i) & 1) ? 1 : 0;\r\n}\r\nbreak;\r\ncase _EMUX_OSS_MISC_MODE:\r\nif (p1 < EMUX_MD_END)\r\nport->ctrls[p1] = p2;\r\nbreak;\r\ncase _EMUX_OSS_DEBUG_MODE:\r\nbreak;\r\ndefault:\r\nif (emu->ops.oss_ioctl)\r\nemu->ops.oss_ioctl(emu, cmd, p1, p2);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\ngusspec_control(struct snd_emux *emu, struct snd_emux_port *port, int cmd,\r\nunsigned char *event, int atomic, int hop)\r\n{\r\nint voice;\r\nunsigned short p1;\r\nshort p2;\r\nint plong;\r\nstruct snd_midi_channel *chan;\r\nif (port->port_mode != SNDRV_EMUX_PORT_MODE_OSS_SYNTH)\r\nreturn;\r\nif (cmd == _GUS_NUMVOICES)\r\nreturn;\r\nvoice = event[3];\r\nif (voice < 0 || voice >= port->chset.max_channels)\r\nreturn;\r\nchan = &port->chset.channels[voice];\r\np1 = *(unsigned short *) &event[4];\r\np2 = *(short *) &event[6];\r\nplong = *(int*) &event[4];\r\nswitch (cmd) {\r\ncase _GUS_VOICESAMPLE:\r\nchan->midi_program = p1;\r\nreturn;\r\ncase _GUS_VOICEBALA:\r\nchan->control[MIDI_CTL_MSB_PAN] = (int)p1 << 3;\r\nsnd_emux_update_channel(port, chan, SNDRV_EMUX_UPDATE_PAN);\r\nreturn;\r\ncase _GUS_VOICEVOL:\r\ncase _GUS_VOICEVOL2:\r\nreturn;\r\ncase _GUS_RAMPRANGE:\r\ncase _GUS_RAMPRATE:\r\ncase _GUS_RAMPMODE:\r\ncase _GUS_RAMPON:\r\ncase _GUS_RAMPOFF:\r\nreturn;\r\ncase _GUS_VOLUME_SCALE:\r\nreturn;\r\ncase _GUS_VOICE_POS:\r\n#ifdef SNDRV_EMUX_USE_RAW_EFFECT\r\nsnd_emux_send_effect(port, chan, EMUX_FX_SAMPLE_START,\r\n(short)(plong & 0x7fff),\r\nEMUX_FX_FLAG_SET);\r\nsnd_emux_send_effect(port, chan, EMUX_FX_COARSE_SAMPLE_START,\r\n(plong >> 15) & 0xffff,\r\nEMUX_FX_FLAG_SET);\r\n#endif\r\nreturn;\r\n}\r\n}\r\nstatic void\r\nfake_event(struct snd_emux *emu, struct snd_emux_port *port, int ch, int param, int val, int atomic, int hop)\r\n{\r\nstruct snd_seq_event ev;\r\nmemset(&ev, 0, sizeof(ev));\r\nev.type = SNDRV_SEQ_EVENT_CONTROLLER;\r\nev.data.control.channel = ch;\r\nev.data.control.param = param;\r\nev.data.control.value = val;\r\nsnd_emux_event_input(&ev, 0, port, atomic, hop);\r\n}
