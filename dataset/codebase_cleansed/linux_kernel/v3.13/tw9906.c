static inline struct tw9906 *to_state(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct tw9906, sd);\r\n}\r\nstatic int write_reg(struct v4l2_subdev *sd, u8 reg, u8 value)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nreturn i2c_smbus_write_byte_data(client, reg, value);\r\n}\r\nstatic int write_regs(struct v4l2_subdev *sd, const u8 *regs)\r\n{\r\nint i;\r\nfor (i = 0; regs[i] != 0x00; i += 2)\r\nif (write_reg(sd, regs[i], regs[i + 1]) < 0)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int tw9906_s_video_routing(struct v4l2_subdev *sd, u32 input,\r\nu32 output, u32 config)\r\n{\r\nwrite_reg(sd, 0x02, 0x40 | (input << 1));\r\nreturn 0;\r\n}\r\nstatic int tw9906_s_std(struct v4l2_subdev *sd, v4l2_std_id norm)\r\n{\r\nstruct tw9906 *dec = to_state(sd);\r\nbool is_60hz = norm & V4L2_STD_525_60;\r\nstatic const u8 config_60hz[] = {\r\n0x05, 0x81,\r\n0x07, 0x02,\r\n0x08, 0x14,\r\n0x09, 0xf0,\r\n0, 0,\r\n};\r\nstatic const u8 config_50hz[] = {\r\n0x05, 0x01,\r\n0x07, 0x12,\r\n0x08, 0x18,\r\n0x09, 0x20,\r\n0, 0,\r\n};\r\nwrite_regs(sd, is_60hz ? config_60hz : config_50hz);\r\ndec->norm = norm;\r\nreturn 0;\r\n}\r\nstatic int tw9906_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct tw9906 *dec = container_of(ctrl->handler, struct tw9906, hdl);\r\nstruct v4l2_subdev *sd = &dec->sd;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nwrite_reg(sd, 0x10, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nwrite_reg(sd, 0x11, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nwrite_reg(sd, 0x15, ctrl->val);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw9906_log_status(struct v4l2_subdev *sd)\r\n{\r\nstruct tw9906 *dec = to_state(sd);\r\nbool is_60hz = dec->norm & V4L2_STD_525_60;\r\nv4l2_info(sd, "Standard: %d Hz\n", is_60hz ? 60 : 50);\r\nv4l2_ctrl_subdev_log_status(sd);\r\nreturn 0;\r\n}\r\nstatic int tw9906_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tw9906 *dec;\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_ctrl_handler *hdl;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -EIO;\r\nv4l_info(client, "chip found @ 0x%02x (%s)\n",\r\nclient->addr << 1, client->adapter->name);\r\ndec = devm_kzalloc(&client->dev, sizeof(*dec), GFP_KERNEL);\r\nif (dec == NULL)\r\nreturn -ENOMEM;\r\nsd = &dec->sd;\r\nv4l2_i2c_subdev_init(sd, client, &tw9906_ops);\r\nhdl = &dec->hdl;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &tw9906_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, -128, 127, 1, 0);\r\nv4l2_ctrl_new_std(hdl, &tw9906_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 0x60);\r\nv4l2_ctrl_new_std(hdl, &tw9906_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nsd->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nint err = hdl->error;\r\nv4l2_ctrl_handler_free(hdl);\r\nreturn err;\r\n}\r\ndec->norm = V4L2_STD_NTSC;\r\nif (write_regs(sd, initial_registers) < 0) {\r\nv4l2_err(client, "error initializing TW9906\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tw9906_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *sd = i2c_get_clientdata(client);\r\nv4l2_device_unregister_subdev(sd);\r\nv4l2_ctrl_handler_free(&to_state(sd)->hdl);\r\nreturn 0;\r\n}
