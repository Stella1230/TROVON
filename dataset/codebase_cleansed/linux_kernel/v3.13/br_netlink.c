static inline size_t br_port_info_size(void)\r\n{\r\nreturn nla_total_size(1)\r\n+ nla_total_size(2)\r\n+ nla_total_size(4)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ nla_total_size(1)\r\n+ 0;\r\n}\r\nstatic inline size_t br_nlmsg_size(void)\r\n{\r\nreturn NLMSG_ALIGN(sizeof(struct ifinfomsg))\r\n+ nla_total_size(IFNAMSIZ)\r\n+ nla_total_size(MAX_ADDR_LEN)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(4)\r\n+ nla_total_size(1)\r\n+ nla_total_size(br_port_info_size());\r\n}\r\nstatic int br_port_fill_attrs(struct sk_buff *skb,\r\nconst struct net_bridge_port *p)\r\n{\r\nu8 mode = !!(p->flags & BR_HAIRPIN_MODE);\r\nif (nla_put_u8(skb, IFLA_BRPORT_STATE, p->state) ||\r\nnla_put_u16(skb, IFLA_BRPORT_PRIORITY, p->priority) ||\r\nnla_put_u32(skb, IFLA_BRPORT_COST, p->path_cost) ||\r\nnla_put_u8(skb, IFLA_BRPORT_MODE, mode) ||\r\nnla_put_u8(skb, IFLA_BRPORT_GUARD, !!(p->flags & BR_BPDU_GUARD)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_PROTECT, !!(p->flags & BR_ROOT_BLOCK)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_FAST_LEAVE, !!(p->flags & BR_MULTICAST_FAST_LEAVE)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_LEARNING, !!(p->flags & BR_LEARNING)) ||\r\nnla_put_u8(skb, IFLA_BRPORT_UNICAST_FLOOD, !!(p->flags & BR_FLOOD)))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic int br_fill_ifinfo(struct sk_buff *skb,\r\nconst struct net_bridge_port *port,\r\nu32 pid, u32 seq, int event, unsigned int flags,\r\nu32 filter_mask, const struct net_device *dev)\r\n{\r\nconst struct net_bridge *br;\r\nstruct ifinfomsg *hdr;\r\nstruct nlmsghdr *nlh;\r\nu8 operstate = netif_running(dev) ? dev->operstate : IF_OPER_DOWN;\r\nif (port)\r\nbr = port->br;\r\nelse\r\nbr = netdev_priv(dev);\r\nbr_debug(br, "br_fill_info event %d port %s master %s\n",\r\nevent, dev->name, br->dev->name);\r\nnlh = nlmsg_put(skb, pid, seq, event, sizeof(*hdr), flags);\r\nif (nlh == NULL)\r\nreturn -EMSGSIZE;\r\nhdr = nlmsg_data(nlh);\r\nhdr->ifi_family = AF_BRIDGE;\r\nhdr->__ifi_pad = 0;\r\nhdr->ifi_type = dev->type;\r\nhdr->ifi_index = dev->ifindex;\r\nhdr->ifi_flags = dev_get_flags(dev);\r\nhdr->ifi_change = 0;\r\nif (nla_put_string(skb, IFLA_IFNAME, dev->name) ||\r\nnla_put_u32(skb, IFLA_MASTER, br->dev->ifindex) ||\r\nnla_put_u32(skb, IFLA_MTU, dev->mtu) ||\r\nnla_put_u8(skb, IFLA_OPERSTATE, operstate) ||\r\n(dev->addr_len &&\r\nnla_put(skb, IFLA_ADDRESS, dev->addr_len, dev->dev_addr)) ||\r\n(dev->ifindex != dev->iflink &&\r\nnla_put_u32(skb, IFLA_LINK, dev->iflink)))\r\ngoto nla_put_failure;\r\nif (event == RTM_NEWLINK && port) {\r\nstruct nlattr *nest\r\n= nla_nest_start(skb, IFLA_PROTINFO | NLA_F_NESTED);\r\nif (nest == NULL || br_port_fill_attrs(skb, port) < 0)\r\ngoto nla_put_failure;\r\nnla_nest_end(skb, nest);\r\n}\r\nif (filter_mask & RTEXT_FILTER_BRVLAN) {\r\nstruct nlattr *af;\r\nconst struct net_port_vlans *pv;\r\nstruct bridge_vlan_info vinfo;\r\nu16 vid;\r\nu16 pvid;\r\nif (port)\r\npv = nbp_get_vlan_info(port);\r\nelse\r\npv = br_get_vlan_info(br);\r\nif (!pv || bitmap_empty(pv->vlan_bitmap, VLAN_N_VID))\r\ngoto done;\r\naf = nla_nest_start(skb, IFLA_AF_SPEC);\r\nif (!af)\r\ngoto nla_put_failure;\r\npvid = br_get_pvid(pv);\r\nfor_each_set_bit(vid, pv->vlan_bitmap, VLAN_N_VID) {\r\nvinfo.vid = vid;\r\nvinfo.flags = 0;\r\nif (vid == pvid)\r\nvinfo.flags |= BRIDGE_VLAN_INFO_PVID;\r\nif (test_bit(vid, pv->untagged_bitmap))\r\nvinfo.flags |= BRIDGE_VLAN_INFO_UNTAGGED;\r\nif (nla_put(skb, IFLA_BRIDGE_VLAN_INFO,\r\nsizeof(vinfo), &vinfo))\r\ngoto nla_put_failure;\r\n}\r\nnla_nest_end(skb, af);\r\n}\r\ndone:\r\nreturn nlmsg_end(skb, nlh);\r\nnla_put_failure:\r\nnlmsg_cancel(skb, nlh);\r\nreturn -EMSGSIZE;\r\n}\r\nvoid br_ifinfo_notify(int event, struct net_bridge_port *port)\r\n{\r\nstruct net *net;\r\nstruct sk_buff *skb;\r\nint err = -ENOBUFS;\r\nif (!port)\r\nreturn;\r\nnet = dev_net(port->dev);\r\nbr_debug(port->br, "port %u(%s) event %d\n",\r\n(unsigned int)port->port_no, port->dev->name, event);\r\nskb = nlmsg_new(br_nlmsg_size(), GFP_ATOMIC);\r\nif (skb == NULL)\r\ngoto errout;\r\nerr = br_fill_ifinfo(skb, port, 0, 0, event, 0, 0, port->dev);\r\nif (err < 0) {\r\nWARN_ON(err == -EMSGSIZE);\r\nkfree_skb(skb);\r\ngoto errout;\r\n}\r\nrtnl_notify(skb, net, 0, RTNLGRP_LINK, NULL, GFP_ATOMIC);\r\nreturn;\r\nerrout:\r\nif (err < 0)\r\nrtnl_set_sk_err(net, RTNLGRP_LINK, err);\r\n}\r\nint br_getlink(struct sk_buff *skb, u32 pid, u32 seq,\r\nstruct net_device *dev, u32 filter_mask)\r\n{\r\nint err = 0;\r\nstruct net_bridge_port *port = br_port_get_rtnl(dev);\r\nif (!port && !(filter_mask & RTEXT_FILTER_BRVLAN))\r\ngoto out;\r\nerr = br_fill_ifinfo(skb, port, pid, seq, RTM_NEWLINK, NLM_F_MULTI,\r\nfilter_mask, dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic int br_afspec(struct net_bridge *br,\r\nstruct net_bridge_port *p,\r\nstruct nlattr *af_spec,\r\nint cmd)\r\n{\r\nstruct nlattr *tb[IFLA_BRIDGE_MAX+1];\r\nint err = 0;\r\nerr = nla_parse_nested(tb, IFLA_BRIDGE_MAX, af_spec, ifla_br_policy);\r\nif (err)\r\nreturn err;\r\nif (tb[IFLA_BRIDGE_VLAN_INFO]) {\r\nstruct bridge_vlan_info *vinfo;\r\nvinfo = nla_data(tb[IFLA_BRIDGE_VLAN_INFO]);\r\nif (!vinfo->vid || vinfo->vid >= VLAN_VID_MASK)\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase RTM_SETLINK:\r\nif (p) {\r\nerr = nbp_vlan_add(p, vinfo->vid, vinfo->flags);\r\nif (err)\r\nbreak;\r\nif (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)\r\nerr = br_vlan_add(p->br, vinfo->vid,\r\nvinfo->flags);\r\n} else\r\nerr = br_vlan_add(br, vinfo->vid, vinfo->flags);\r\nif (err)\r\nbreak;\r\nbreak;\r\ncase RTM_DELLINK:\r\nif (p) {\r\nnbp_vlan_delete(p, vinfo->vid);\r\nif (vinfo->flags & BRIDGE_VLAN_INFO_MASTER)\r\nbr_vlan_delete(p->br, vinfo->vid);\r\n} else\r\nbr_vlan_delete(br, vinfo->vid);\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int br_set_port_state(struct net_bridge_port *p, u8 state)\r\n{\r\nif (state > BR_STATE_BLOCKING)\r\nreturn -EINVAL;\r\nif (p->br->stp_enabled == BR_KERNEL_STP)\r\nreturn -EBUSY;\r\nif (!netif_running(p->dev) ||\r\n(!netif_oper_up(p->dev) && state != BR_STATE_DISABLED))\r\nreturn -ENETDOWN;\r\np->state = state;\r\nbr_log_state(p);\r\nbr_port_state_selection(p->br);\r\nreturn 0;\r\n}\r\nstatic void br_set_port_flag(struct net_bridge_port *p, struct nlattr *tb[],\r\nint attrtype, unsigned long mask)\r\n{\r\nif (tb[attrtype]) {\r\nu8 flag = nla_get_u8(tb[attrtype]);\r\nif (flag)\r\np->flags |= mask;\r\nelse\r\np->flags &= ~mask;\r\n}\r\n}\r\nstatic int br_setport(struct net_bridge_port *p, struct nlattr *tb[])\r\n{\r\nint err;\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_MODE, BR_HAIRPIN_MODE);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_GUARD, BR_BPDU_GUARD);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_FAST_LEAVE, BR_MULTICAST_FAST_LEAVE);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_PROTECT, BR_ROOT_BLOCK);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_LEARNING, BR_LEARNING);\r\nbr_set_port_flag(p, tb, IFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD);\r\nif (tb[IFLA_BRPORT_COST]) {\r\nerr = br_stp_set_path_cost(p, nla_get_u32(tb[IFLA_BRPORT_COST]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (tb[IFLA_BRPORT_PRIORITY]) {\r\nerr = br_stp_set_port_priority(p, nla_get_u16(tb[IFLA_BRPORT_PRIORITY]));\r\nif (err)\r\nreturn err;\r\n}\r\nif (tb[IFLA_BRPORT_STATE]) {\r\nerr = br_set_port_state(p, nla_get_u8(tb[IFLA_BRPORT_STATE]));\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nint br_setlink(struct net_device *dev, struct nlmsghdr *nlh)\r\n{\r\nstruct nlattr *protinfo;\r\nstruct nlattr *afspec;\r\nstruct net_bridge_port *p;\r\nstruct nlattr *tb[IFLA_BRPORT_MAX + 1];\r\nint err = 0;\r\nprotinfo = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_PROTINFO);\r\nafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\r\nif (!protinfo && !afspec)\r\nreturn 0;\r\np = br_port_get_rtnl(dev);\r\nif (!p && !afspec)\r\nreturn -EINVAL;\r\nif (p && protinfo) {\r\nif (protinfo->nla_type & NLA_F_NESTED) {\r\nerr = nla_parse_nested(tb, IFLA_BRPORT_MAX,\r\nprotinfo, ifla_brport_policy);\r\nif (err)\r\nreturn err;\r\nspin_lock_bh(&p->br->lock);\r\nerr = br_setport(p, tb);\r\nspin_unlock_bh(&p->br->lock);\r\n} else {\r\nif (nla_len(protinfo) < sizeof(u8))\r\nreturn -EINVAL;\r\nspin_lock_bh(&p->br->lock);\r\nerr = br_set_port_state(p, nla_get_u8(protinfo));\r\nspin_unlock_bh(&p->br->lock);\r\n}\r\nif (err)\r\ngoto out;\r\n}\r\nif (afspec) {\r\nerr = br_afspec((struct net_bridge *)netdev_priv(dev), p,\r\nafspec, RTM_SETLINK);\r\n}\r\nif (err == 0)\r\nbr_ifinfo_notify(RTM_NEWLINK, p);\r\nout:\r\nreturn err;\r\n}\r\nint br_dellink(struct net_device *dev, struct nlmsghdr *nlh)\r\n{\r\nstruct nlattr *afspec;\r\nstruct net_bridge_port *p;\r\nint err;\r\nafspec = nlmsg_find_attr(nlh, sizeof(struct ifinfomsg), IFLA_AF_SPEC);\r\nif (!afspec)\r\nreturn 0;\r\np = br_port_get_rtnl(dev);\r\nif (!p && !(dev->priv_flags & IFF_EBRIDGE))\r\nreturn -EINVAL;\r\nerr = br_afspec((struct net_bridge *)netdev_priv(dev), p,\r\nafspec, RTM_DELLINK);\r\nreturn err;\r\n}\r\nstatic int br_validate(struct nlattr *tb[], struct nlattr *data[])\r\n{\r\nif (tb[IFLA_ADDRESS]) {\r\nif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\r\nreturn -EINVAL;\r\nif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nreturn 0;\r\n}\r\nstatic size_t br_get_link_af_size(const struct net_device *dev)\r\n{\r\nstruct net_port_vlans *pv;\r\nif (br_port_exists(dev))\r\npv = nbp_get_vlan_info(br_port_get_rtnl(dev));\r\nelse if (dev->priv_flags & IFF_EBRIDGE)\r\npv = br_get_vlan_info((struct net_bridge *)netdev_priv(dev));\r\nelse\r\nreturn 0;\r\nif (!pv)\r\nreturn 0;\r\nreturn pv->num_vlans * nla_total_size(sizeof(struct bridge_vlan_info));\r\n}\r\nint __init br_netlink_init(void)\r\n{\r\nint err;\r\nbr_mdb_init();\r\nerr = rtnl_af_register(&br_af_ops);\r\nif (err)\r\ngoto out;\r\nerr = rtnl_link_register(&br_link_ops);\r\nif (err)\r\ngoto out_af;\r\nreturn 0;\r\nout_af:\r\nrtnl_af_unregister(&br_af_ops);\r\nout:\r\nbr_mdb_uninit();\r\nreturn err;\r\n}\r\nvoid __exit br_netlink_fini(void)\r\n{\r\nbr_mdb_uninit();\r\nrtnl_af_unregister(&br_af_ops);\r\nrtnl_link_unregister(&br_link_ops);\r\n}
