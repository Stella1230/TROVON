static inline int\r\nnlm_cmp_owner(struct nlm_share *share, struct xdr_netobj *oh)\r\n{\r\nreturn share->s_owner.len == oh->len\r\n&& !memcmp(share->s_owner.data, oh->data, oh->len);\r\n}\r\n__be32\r\nnlmsvc_share_file(struct nlm_host *host, struct nlm_file *file,\r\nstruct nlm_args *argp)\r\n{\r\nstruct nlm_share *share;\r\nstruct xdr_netobj *oh = &argp->lock.oh;\r\nu8 *ohdata;\r\nfor (share = file->f_shares; share; share = share->s_next) {\r\nif (share->s_host == host && nlm_cmp_owner(share, oh))\r\ngoto update;\r\nif ((argp->fsm_access & share->s_mode)\r\n|| (argp->fsm_mode & share->s_access ))\r\nreturn nlm_lck_denied;\r\n}\r\nshare = kmalloc(sizeof(*share) + oh->len,\r\nGFP_KERNEL);\r\nif (share == NULL)\r\nreturn nlm_lck_denied_nolocks;\r\nohdata = (u8 *) (share + 1);\r\nmemcpy(ohdata, oh->data, oh->len);\r\nshare->s_file = file;\r\nshare->s_host = host;\r\nshare->s_owner.data = ohdata;\r\nshare->s_owner.len = oh->len;\r\nshare->s_next = file->f_shares;\r\nfile->f_shares = share;\r\nupdate:\r\nshare->s_access = argp->fsm_access;\r\nshare->s_mode = argp->fsm_mode;\r\nreturn nlm_granted;\r\n}\r\n__be32\r\nnlmsvc_unshare_file(struct nlm_host *host, struct nlm_file *file,\r\nstruct nlm_args *argp)\r\n{\r\nstruct nlm_share *share, **shpp;\r\nstruct xdr_netobj *oh = &argp->lock.oh;\r\nfor (shpp = &file->f_shares; (share = *shpp) != NULL;\r\nshpp = &share->s_next) {\r\nif (share->s_host == host && nlm_cmp_owner(share, oh)) {\r\n*shpp = share->s_next;\r\nkfree(share);\r\nreturn nlm_granted;\r\n}\r\n}\r\nreturn nlm_granted;\r\n}\r\nvoid nlmsvc_traverse_shares(struct nlm_host *host, struct nlm_file *file,\r\nnlm_host_match_fn_t match)\r\n{\r\nstruct nlm_share *share, **shpp;\r\nshpp = &file->f_shares;\r\nwhile ((share = *shpp) != NULL) {\r\nif (match(share->s_host, host)) {\r\n*shpp = share->s_next;\r\nkfree(share);\r\ncontinue;\r\n}\r\nshpp = &share->s_next;\r\n}\r\n}
