static void iser_cq_event_callback(struct ib_event *cause, void *context)\r\n{\r\niser_err("got cq event %d \n", cause->event);\r\n}\r\nstatic void iser_qp_event_callback(struct ib_event *cause, void *context)\r\n{\r\niser_err("got qp event %d\n",cause->event);\r\n}\r\nstatic void iser_event_handler(struct ib_event_handler *handler,\r\nstruct ib_event *event)\r\n{\r\niser_err("async event %d on device %s port %d\n", event->event,\r\nevent->device->name, event->element.port_num);\r\n}\r\nstatic int iser_create_device_ib_res(struct iser_device *device)\r\n{\r\nint i, j;\r\nstruct iser_cq_desc *cq_desc;\r\nstruct ib_device_attr *dev_attr;\r\ndev_attr = kmalloc(sizeof(*dev_attr), GFP_KERNEL);\r\nif (!dev_attr)\r\nreturn -ENOMEM;\r\nif (ib_query_device(device->ib_device, dev_attr)) {\r\npr_warn("Query device failed for %s\n", device->ib_device->name);\r\ngoto dev_attr_err;\r\n}\r\nif (device->ib_device->alloc_fmr && device->ib_device->dealloc_fmr &&\r\ndevice->ib_device->map_phys_fmr && device->ib_device->unmap_fmr) {\r\niser_info("FMR supported, using FMR for registration\n");\r\ndevice->iser_alloc_rdma_reg_res = iser_create_fmr_pool;\r\ndevice->iser_free_rdma_reg_res = iser_free_fmr_pool;\r\ndevice->iser_reg_rdma_mem = iser_reg_rdma_mem_fmr;\r\ndevice->iser_unreg_rdma_mem = iser_unreg_mem_fmr;\r\n} else\r\nif (dev_attr->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS) {\r\niser_info("FRWR supported, using FRWR for registration\n");\r\ndevice->iser_alloc_rdma_reg_res = iser_create_frwr_pool;\r\ndevice->iser_free_rdma_reg_res = iser_free_frwr_pool;\r\ndevice->iser_reg_rdma_mem = iser_reg_rdma_mem_frwr;\r\ndevice->iser_unreg_rdma_mem = iser_unreg_mem_frwr;\r\n} else {\r\niser_err("IB device does not support FMRs nor FRWRs, can't register memory\n");\r\ngoto dev_attr_err;\r\n}\r\ndevice->cqs_used = min(ISER_MAX_CQ, device->ib_device->num_comp_vectors);\r\niser_info("using %d CQs, device %s supports %d vectors\n",\r\ndevice->cqs_used, device->ib_device->name,\r\ndevice->ib_device->num_comp_vectors);\r\ndevice->cq_desc = kmalloc(sizeof(struct iser_cq_desc) * device->cqs_used,\r\nGFP_KERNEL);\r\nif (device->cq_desc == NULL)\r\ngoto cq_desc_err;\r\ncq_desc = device->cq_desc;\r\ndevice->pd = ib_alloc_pd(device->ib_device);\r\nif (IS_ERR(device->pd))\r\ngoto pd_err;\r\nfor (i = 0; i < device->cqs_used; i++) {\r\ncq_desc[i].device = device;\r\ncq_desc[i].cq_index = i;\r\ndevice->rx_cq[i] = ib_create_cq(device->ib_device,\r\niser_cq_callback,\r\niser_cq_event_callback,\r\n(void *)&cq_desc[i],\r\nISER_MAX_RX_CQ_LEN, i);\r\nif (IS_ERR(device->rx_cq[i]))\r\ngoto cq_err;\r\ndevice->tx_cq[i] = ib_create_cq(device->ib_device,\r\nNULL, iser_cq_event_callback,\r\n(void *)&cq_desc[i],\r\nISER_MAX_TX_CQ_LEN, i);\r\nif (IS_ERR(device->tx_cq[i]))\r\ngoto cq_err;\r\nif (ib_req_notify_cq(device->rx_cq[i], IB_CQ_NEXT_COMP))\r\ngoto cq_err;\r\ntasklet_init(&device->cq_tasklet[i],\r\niser_cq_tasklet_fn,\r\n(unsigned long)&cq_desc[i]);\r\n}\r\ndevice->mr = ib_get_dma_mr(device->pd, IB_ACCESS_LOCAL_WRITE |\r\nIB_ACCESS_REMOTE_WRITE |\r\nIB_ACCESS_REMOTE_READ);\r\nif (IS_ERR(device->mr))\r\ngoto dma_mr_err;\r\nINIT_IB_EVENT_HANDLER(&device->event_handler, device->ib_device,\r\niser_event_handler);\r\nif (ib_register_event_handler(&device->event_handler))\r\ngoto handler_err;\r\nkfree(dev_attr);\r\nreturn 0;\r\nhandler_err:\r\nib_dereg_mr(device->mr);\r\ndma_mr_err:\r\nfor (j = 0; j < device->cqs_used; j++)\r\ntasklet_kill(&device->cq_tasklet[j]);\r\ncq_err:\r\nfor (j = 0; j < i; j++) {\r\nif (device->tx_cq[j])\r\nib_destroy_cq(device->tx_cq[j]);\r\nif (device->rx_cq[j])\r\nib_destroy_cq(device->rx_cq[j]);\r\n}\r\nib_dealloc_pd(device->pd);\r\npd_err:\r\nkfree(device->cq_desc);\r\ncq_desc_err:\r\niser_err("failed to allocate an IB resource\n");\r\ndev_attr_err:\r\nkfree(dev_attr);\r\nreturn -1;\r\n}\r\nstatic void iser_free_device_ib_res(struct iser_device *device)\r\n{\r\nint i;\r\nBUG_ON(device->mr == NULL);\r\nfor (i = 0; i < device->cqs_used; i++) {\r\ntasklet_kill(&device->cq_tasklet[i]);\r\n(void)ib_destroy_cq(device->tx_cq[i]);\r\n(void)ib_destroy_cq(device->rx_cq[i]);\r\ndevice->tx_cq[i] = NULL;\r\ndevice->rx_cq[i] = NULL;\r\n}\r\n(void)ib_unregister_event_handler(&device->event_handler);\r\n(void)ib_dereg_mr(device->mr);\r\n(void)ib_dealloc_pd(device->pd);\r\nkfree(device->cq_desc);\r\ndevice->mr = NULL;\r\ndevice->pd = NULL;\r\n}\r\nint iser_create_fmr_pool(struct iser_conn *ib_conn, unsigned cmds_max)\r\n{\r\nstruct iser_device *device = ib_conn->device;\r\nstruct ib_fmr_pool_param params;\r\nint ret = -ENOMEM;\r\nib_conn->fastreg.fmr.page_vec = kmalloc(sizeof(struct iser_page_vec) +\r\n(sizeof(u64)*(ISCSI_ISER_SG_TABLESIZE + 1)),\r\nGFP_KERNEL);\r\nif (!ib_conn->fastreg.fmr.page_vec)\r\nreturn ret;\r\nib_conn->fastreg.fmr.page_vec->pages = (u64 *)(ib_conn->fastreg.fmr.page_vec + 1);\r\nparams.page_shift = SHIFT_4K;\r\nparams.max_pages_per_fmr = ISCSI_ISER_SG_TABLESIZE + 1;\r\nparams.pool_size = cmds_max * 2;\r\nparams.dirty_watermark = cmds_max;\r\nparams.cache = 0;\r\nparams.flush_function = NULL;\r\nparams.access = (IB_ACCESS_LOCAL_WRITE |\r\nIB_ACCESS_REMOTE_WRITE |\r\nIB_ACCESS_REMOTE_READ);\r\nib_conn->fastreg.fmr.pool = ib_create_fmr_pool(device->pd, &params);\r\nif (!IS_ERR(ib_conn->fastreg.fmr.pool))\r\nreturn 0;\r\nkfree(ib_conn->fastreg.fmr.page_vec);\r\nib_conn->fastreg.fmr.page_vec = NULL;\r\nret = PTR_ERR(ib_conn->fastreg.fmr.pool);\r\nib_conn->fastreg.fmr.pool = NULL;\r\nif (ret != -ENOSYS) {\r\niser_err("FMR allocation failed, err %d\n", ret);\r\nreturn ret;\r\n} else {\r\niser_warn("FMRs are not supported, using unaligned mode\n");\r\nreturn 0;\r\n}\r\n}\r\nvoid iser_free_fmr_pool(struct iser_conn *ib_conn)\r\n{\r\niser_info("freeing conn %p fmr pool %p\n",\r\nib_conn, ib_conn->fastreg.fmr.pool);\r\nif (ib_conn->fastreg.fmr.pool != NULL)\r\nib_destroy_fmr_pool(ib_conn->fastreg.fmr.pool);\r\nib_conn->fastreg.fmr.pool = NULL;\r\nkfree(ib_conn->fastreg.fmr.page_vec);\r\nib_conn->fastreg.fmr.page_vec = NULL;\r\n}\r\nint iser_create_frwr_pool(struct iser_conn *ib_conn, unsigned cmds_max)\r\n{\r\nstruct iser_device *device = ib_conn->device;\r\nstruct fast_reg_descriptor *desc;\r\nint i, ret;\r\nINIT_LIST_HEAD(&ib_conn->fastreg.frwr.pool);\r\nib_conn->fastreg.frwr.pool_size = 0;\r\nfor (i = 0; i < cmds_max; i++) {\r\ndesc = kmalloc(sizeof(*desc), GFP_KERNEL);\r\nif (!desc) {\r\niser_err("Failed to allocate a new fast_reg descriptor\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndesc->data_frpl = ib_alloc_fast_reg_page_list(device->ib_device,\r\nISCSI_ISER_SG_TABLESIZE + 1);\r\nif (IS_ERR(desc->data_frpl)) {\r\nret = PTR_ERR(desc->data_frpl);\r\niser_err("Failed to allocate ib_fast_reg_page_list err=%d\n", ret);\r\ngoto fast_reg_page_failure;\r\n}\r\ndesc->data_mr = ib_alloc_fast_reg_mr(device->pd,\r\nISCSI_ISER_SG_TABLESIZE + 1);\r\nif (IS_ERR(desc->data_mr)) {\r\nret = PTR_ERR(desc->data_mr);\r\niser_err("Failed to allocate ib_fast_reg_mr err=%d\n", ret);\r\ngoto fast_reg_mr_failure;\r\n}\r\ndesc->valid = true;\r\nlist_add_tail(&desc->list, &ib_conn->fastreg.frwr.pool);\r\nib_conn->fastreg.frwr.pool_size++;\r\n}\r\nreturn 0;\r\nfast_reg_mr_failure:\r\nib_free_fast_reg_page_list(desc->data_frpl);\r\nfast_reg_page_failure:\r\nkfree(desc);\r\nerr:\r\niser_free_frwr_pool(ib_conn);\r\nreturn ret;\r\n}\r\nvoid iser_free_frwr_pool(struct iser_conn *ib_conn)\r\n{\r\nstruct fast_reg_descriptor *desc, *tmp;\r\nint i = 0;\r\nif (list_empty(&ib_conn->fastreg.frwr.pool))\r\nreturn;\r\niser_info("freeing conn %p frwr pool\n", ib_conn);\r\nlist_for_each_entry_safe(desc, tmp, &ib_conn->fastreg.frwr.pool, list) {\r\nlist_del(&desc->list);\r\nib_free_fast_reg_page_list(desc->data_frpl);\r\nib_dereg_mr(desc->data_mr);\r\nkfree(desc);\r\n++i;\r\n}\r\nif (i < ib_conn->fastreg.frwr.pool_size)\r\niser_warn("pool still has %d regions registered\n",\r\nib_conn->fastreg.frwr.pool_size - i);\r\n}\r\nstatic int iser_create_ib_conn_res(struct iser_conn *ib_conn)\r\n{\r\nstruct iser_device *device;\r\nstruct ib_qp_init_attr init_attr;\r\nint ret = -ENOMEM;\r\nint index, min_index = 0;\r\nBUG_ON(ib_conn->device == NULL);\r\ndevice = ib_conn->device;\r\nmemset(&init_attr, 0, sizeof init_attr);\r\nmutex_lock(&ig.connlist_mutex);\r\nfor (index = 0; index < device->cqs_used; index++)\r\nif (device->cq_active_qps[index] <\r\ndevice->cq_active_qps[min_index])\r\nmin_index = index;\r\ndevice->cq_active_qps[min_index]++;\r\nmutex_unlock(&ig.connlist_mutex);\r\niser_info("cq index %d used for ib_conn %p\n", min_index, ib_conn);\r\ninit_attr.event_handler = iser_qp_event_callback;\r\ninit_attr.qp_context = (void *)ib_conn;\r\ninit_attr.send_cq = device->tx_cq[min_index];\r\ninit_attr.recv_cq = device->rx_cq[min_index];\r\ninit_attr.cap.max_send_wr = ISER_QP_MAX_REQ_DTOS;\r\ninit_attr.cap.max_recv_wr = ISER_QP_MAX_RECV_DTOS;\r\ninit_attr.cap.max_send_sge = 2;\r\ninit_attr.cap.max_recv_sge = 1;\r\ninit_attr.sq_sig_type = IB_SIGNAL_REQ_WR;\r\ninit_attr.qp_type = IB_QPT_RC;\r\nret = rdma_create_qp(ib_conn->cma_id, device->pd, &init_attr);\r\nif (ret)\r\ngoto out_err;\r\nib_conn->qp = ib_conn->cma_id->qp;\r\niser_info("setting conn %p cma_id %p qp %p\n",\r\nib_conn, ib_conn->cma_id,\r\nib_conn->cma_id->qp);\r\nreturn ret;\r\nout_err:\r\niser_err("unable to alloc mem or create resource, err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int iser_free_ib_conn_res(struct iser_conn *ib_conn)\r\n{\r\nint cq_index;\r\nBUG_ON(ib_conn == NULL);\r\niser_info("freeing conn %p cma_id %p qp %p\n",\r\nib_conn, ib_conn->cma_id,\r\nib_conn->qp);\r\nif (ib_conn->qp != NULL) {\r\ncq_index = ((struct iser_cq_desc *)ib_conn->qp->recv_cq->cq_context)->cq_index;\r\nib_conn->device->cq_active_qps[cq_index]--;\r\nrdma_destroy_qp(ib_conn->cma_id);\r\n}\r\nib_conn->qp = NULL;\r\nreturn 0;\r\n}\r\nstatic\r\nstruct iser_device *iser_device_find_by_ib_device(struct rdma_cm_id *cma_id)\r\n{\r\nstruct iser_device *device;\r\nmutex_lock(&ig.device_list_mutex);\r\nlist_for_each_entry(device, &ig.device_list, ig_list)\r\nif (device->ib_device->node_guid == cma_id->device->node_guid)\r\ngoto inc_refcnt;\r\ndevice = kzalloc(sizeof *device, GFP_KERNEL);\r\nif (device == NULL)\r\ngoto out;\r\ndevice->ib_device = cma_id->device;\r\nif (iser_create_device_ib_res(device)) {\r\nkfree(device);\r\ndevice = NULL;\r\ngoto out;\r\n}\r\nlist_add(&device->ig_list, &ig.device_list);\r\ninc_refcnt:\r\ndevice->refcount++;\r\nout:\r\nmutex_unlock(&ig.device_list_mutex);\r\nreturn device;\r\n}\r\nstatic void iser_device_try_release(struct iser_device *device)\r\n{\r\nmutex_lock(&ig.device_list_mutex);\r\ndevice->refcount--;\r\niser_info("device %p refcount %d\n", device, device->refcount);\r\nif (!device->refcount) {\r\niser_free_device_ib_res(device);\r\nlist_del(&device->ig_list);\r\nkfree(device);\r\n}\r\nmutex_unlock(&ig.device_list_mutex);\r\n}\r\nstatic int iser_conn_state_comp_exch(struct iser_conn *ib_conn,\r\nenum iser_ib_conn_state comp,\r\nenum iser_ib_conn_state exch)\r\n{\r\nint ret;\r\nspin_lock_bh(&ib_conn->lock);\r\nif ((ret = (ib_conn->state == comp)))\r\nib_conn->state = exch;\r\nspin_unlock_bh(&ib_conn->lock);\r\nreturn ret;\r\n}\r\nstatic void iser_conn_release(struct iser_conn *ib_conn, int can_destroy_id)\r\n{\r\nstruct iser_device *device = ib_conn->device;\r\nBUG_ON(ib_conn->state != ISER_CONN_DOWN);\r\nmutex_lock(&ig.connlist_mutex);\r\nlist_del(&ib_conn->conn_list);\r\nmutex_unlock(&ig.connlist_mutex);\r\niser_free_rx_descriptors(ib_conn);\r\niser_free_ib_conn_res(ib_conn);\r\nib_conn->device = NULL;\r\nif (device != NULL)\r\niser_device_try_release(device);\r\nif (ib_conn->cma_id != NULL && can_destroy_id) {\r\nrdma_destroy_id(ib_conn->cma_id);\r\nib_conn->cma_id = NULL;\r\n}\r\niscsi_destroy_endpoint(ib_conn->ep);\r\n}\r\nvoid iser_conn_get(struct iser_conn *ib_conn)\r\n{\r\natomic_inc(&ib_conn->refcount);\r\n}\r\nint iser_conn_put(struct iser_conn *ib_conn, int can_destroy_id)\r\n{\r\nif (atomic_dec_and_test(&ib_conn->refcount)) {\r\niser_conn_release(ib_conn, can_destroy_id);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nvoid iser_conn_terminate(struct iser_conn *ib_conn)\r\n{\r\nint err = 0;\r\niser_conn_state_comp_exch(ib_conn, ISER_CONN_UP, ISER_CONN_TERMINATING);\r\nerr = rdma_disconnect(ib_conn->cma_id);\r\nif (err)\r\niser_err("Failed to disconnect, conn: 0x%p err %d\n",\r\nib_conn,err);\r\nwait_event_interruptible(ib_conn->wait,\r\nib_conn->state == ISER_CONN_DOWN);\r\niser_conn_put(ib_conn, 1);\r\n}\r\nstatic int iser_connect_error(struct rdma_cm_id *cma_id)\r\n{\r\nstruct iser_conn *ib_conn;\r\nib_conn = (struct iser_conn *)cma_id->context;\r\nib_conn->state = ISER_CONN_DOWN;\r\nwake_up_interruptible(&ib_conn->wait);\r\nreturn iser_conn_put(ib_conn, 0);\r\n}\r\nstatic int iser_addr_handler(struct rdma_cm_id *cma_id)\r\n{\r\nstruct iser_device *device;\r\nstruct iser_conn *ib_conn;\r\nint ret;\r\ndevice = iser_device_find_by_ib_device(cma_id);\r\nif (!device) {\r\niser_err("device lookup/creation failed\n");\r\nreturn iser_connect_error(cma_id);\r\n}\r\nib_conn = (struct iser_conn *)cma_id->context;\r\nib_conn->device = device;\r\nret = rdma_resolve_route(cma_id, 1000);\r\nif (ret) {\r\niser_err("resolve route failed: %d\n", ret);\r\nreturn iser_connect_error(cma_id);\r\n}\r\nreturn 0;\r\n}\r\nstatic int iser_route_handler(struct rdma_cm_id *cma_id)\r\n{\r\nstruct rdma_conn_param conn_param;\r\nint ret;\r\nstruct iser_cm_hdr req_hdr;\r\nret = iser_create_ib_conn_res((struct iser_conn *)cma_id->context);\r\nif (ret)\r\ngoto failure;\r\nmemset(&conn_param, 0, sizeof conn_param);\r\nconn_param.responder_resources = 4;\r\nconn_param.initiator_depth = 1;\r\nconn_param.retry_count = 7;\r\nconn_param.rnr_retry_count = 6;\r\nmemset(&req_hdr, 0, sizeof(req_hdr));\r\nreq_hdr.flags = (ISER_ZBVA_NOT_SUPPORTED |\r\nISER_SEND_W_INV_NOT_SUPPORTED);\r\nconn_param.private_data = (void *)&req_hdr;\r\nconn_param.private_data_len = sizeof(struct iser_cm_hdr);\r\nret = rdma_connect(cma_id, &conn_param);\r\nif (ret) {\r\niser_err("failure connecting: %d\n", ret);\r\ngoto failure;\r\n}\r\nreturn 0;\r\nfailure:\r\nreturn iser_connect_error(cma_id);\r\n}\r\nstatic void iser_connected_handler(struct rdma_cm_id *cma_id)\r\n{\r\nstruct iser_conn *ib_conn;\r\nib_conn = (struct iser_conn *)cma_id->context;\r\nib_conn->state = ISER_CONN_UP;\r\nwake_up_interruptible(&ib_conn->wait);\r\n}\r\nstatic int iser_disconnected_handler(struct rdma_cm_id *cma_id)\r\n{\r\nstruct iser_conn *ib_conn;\r\nint ret;\r\nib_conn = (struct iser_conn *)cma_id->context;\r\nif (iser_conn_state_comp_exch(ib_conn, ISER_CONN_UP,\r\nISER_CONN_TERMINATING))\r\niscsi_conn_failure(ib_conn->iser_conn->iscsi_conn,\r\nISCSI_ERR_CONN_FAILED);\r\nif (ib_conn->post_recv_buf_count == 0 &&\r\n(atomic_read(&ib_conn->post_send_buf_count) == 0)) {\r\nib_conn->state = ISER_CONN_DOWN;\r\nwake_up_interruptible(&ib_conn->wait);\r\n}\r\nret = iser_conn_put(ib_conn, 0);\r\nreturn ret;\r\n}\r\nstatic int iser_cma_handler(struct rdma_cm_id *cma_id, struct rdma_cm_event *event)\r\n{\r\nint ret = 0;\r\niser_info("event %d status %d conn %p id %p\n",\r\nevent->event, event->status, cma_id->context, cma_id);\r\nswitch (event->event) {\r\ncase RDMA_CM_EVENT_ADDR_RESOLVED:\r\nret = iser_addr_handler(cma_id);\r\nbreak;\r\ncase RDMA_CM_EVENT_ROUTE_RESOLVED:\r\nret = iser_route_handler(cma_id);\r\nbreak;\r\ncase RDMA_CM_EVENT_ESTABLISHED:\r\niser_connected_handler(cma_id);\r\nbreak;\r\ncase RDMA_CM_EVENT_ADDR_ERROR:\r\ncase RDMA_CM_EVENT_ROUTE_ERROR:\r\ncase RDMA_CM_EVENT_CONNECT_ERROR:\r\ncase RDMA_CM_EVENT_UNREACHABLE:\r\ncase RDMA_CM_EVENT_REJECTED:\r\nret = iser_connect_error(cma_id);\r\nbreak;\r\ncase RDMA_CM_EVENT_DISCONNECTED:\r\ncase RDMA_CM_EVENT_DEVICE_REMOVAL:\r\ncase RDMA_CM_EVENT_ADDR_CHANGE:\r\nret = iser_disconnected_handler(cma_id);\r\nbreak;\r\ndefault:\r\niser_err("Unexpected RDMA CM event (%d)\n", event->event);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nvoid iser_conn_init(struct iser_conn *ib_conn)\r\n{\r\nib_conn->state = ISER_CONN_INIT;\r\ninit_waitqueue_head(&ib_conn->wait);\r\nib_conn->post_recv_buf_count = 0;\r\natomic_set(&ib_conn->post_send_buf_count, 0);\r\natomic_set(&ib_conn->refcount, 1);\r\nINIT_LIST_HEAD(&ib_conn->conn_list);\r\nspin_lock_init(&ib_conn->lock);\r\n}\r\nint iser_connect(struct iser_conn *ib_conn,\r\nstruct sockaddr_in *src_addr,\r\nstruct sockaddr_in *dst_addr,\r\nint non_blocking)\r\n{\r\nstruct sockaddr *src, *dst;\r\nint err = 0;\r\nsprintf(ib_conn->name, "%pI4:%d",\r\n&dst_addr->sin_addr.s_addr, dst_addr->sin_port);\r\nib_conn->device = NULL;\r\niser_info("connecting to: %pI4, port 0x%x\n",\r\n&dst_addr->sin_addr, dst_addr->sin_port);\r\nib_conn->state = ISER_CONN_PENDING;\r\niser_conn_get(ib_conn);\r\nib_conn->cma_id = rdma_create_id(iser_cma_handler,\r\n(void *)ib_conn,\r\nRDMA_PS_TCP, IB_QPT_RC);\r\nif (IS_ERR(ib_conn->cma_id)) {\r\nerr = PTR_ERR(ib_conn->cma_id);\r\niser_err("rdma_create_id failed: %d\n", err);\r\ngoto id_failure;\r\n}\r\nsrc = (struct sockaddr *)src_addr;\r\ndst = (struct sockaddr *)dst_addr;\r\nerr = rdma_resolve_addr(ib_conn->cma_id, src, dst, 1000);\r\nif (err) {\r\niser_err("rdma_resolve_addr failed: %d\n", err);\r\ngoto addr_failure;\r\n}\r\nif (!non_blocking) {\r\nwait_event_interruptible(ib_conn->wait,\r\n(ib_conn->state != ISER_CONN_PENDING));\r\nif (ib_conn->state != ISER_CONN_UP) {\r\nerr = -EIO;\r\ngoto connect_failure;\r\n}\r\n}\r\nmutex_lock(&ig.connlist_mutex);\r\nlist_add(&ib_conn->conn_list, &ig.connlist);\r\nmutex_unlock(&ig.connlist_mutex);\r\nreturn 0;\r\nid_failure:\r\nib_conn->cma_id = NULL;\r\naddr_failure:\r\nib_conn->state = ISER_CONN_DOWN;\r\niser_conn_put(ib_conn, 1);\r\nconnect_failure:\r\niser_conn_put(ib_conn, 1);\r\nreturn err;\r\n}\r\nint iser_reg_page_vec(struct iser_conn *ib_conn,\r\nstruct iser_page_vec *page_vec,\r\nstruct iser_mem_reg *mem_reg)\r\n{\r\nstruct ib_pool_fmr *mem;\r\nu64 io_addr;\r\nu64 *page_list;\r\nint status;\r\npage_list = page_vec->pages;\r\nio_addr = page_list[0];\r\nmem = ib_fmr_pool_map_phys(ib_conn->fastreg.fmr.pool,\r\npage_list,\r\npage_vec->length,\r\nio_addr);\r\nif (IS_ERR(mem)) {\r\nstatus = (int)PTR_ERR(mem);\r\niser_err("ib_fmr_pool_map_phys failed: %d\n", status);\r\nreturn status;\r\n}\r\nmem_reg->lkey = mem->fmr->lkey;\r\nmem_reg->rkey = mem->fmr->rkey;\r\nmem_reg->len = page_vec->length * SIZE_4K;\r\nmem_reg->va = io_addr;\r\nmem_reg->is_mr = 1;\r\nmem_reg->mem_h = (void *)mem;\r\nmem_reg->va += page_vec->offset;\r\nmem_reg->len = page_vec->data_size;\r\niser_dbg("PHYSICAL Mem.register, [PHYS p_array: 0x%p, sz: %d, "\r\n"entry[0]: (0x%08lx,%ld)] -> "\r\n"[lkey: 0x%08X mem_h: 0x%p va: 0x%08lX sz: %ld]\n",\r\npage_vec, page_vec->length,\r\n(unsigned long)page_vec->pages[0],\r\n(unsigned long)page_vec->data_size,\r\n(unsigned int)mem_reg->lkey, mem_reg->mem_h,\r\n(unsigned long)mem_reg->va, (unsigned long)mem_reg->len);\r\nreturn 0;\r\n}\r\nvoid iser_unreg_mem_fmr(struct iscsi_iser_task *iser_task,\r\nenum iser_data_dir cmd_dir)\r\n{\r\nstruct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;\r\nint ret;\r\nif (!reg->is_mr)\r\nreturn;\r\niser_dbg("PHYSICAL Mem.Unregister mem_h %p\n",reg->mem_h);\r\nret = ib_fmr_pool_unmap((struct ib_pool_fmr *)reg->mem_h);\r\nif (ret)\r\niser_err("ib_fmr_pool_unmap failed %d\n", ret);\r\nreg->mem_h = NULL;\r\n}\r\nvoid iser_unreg_mem_frwr(struct iscsi_iser_task *iser_task,\r\nenum iser_data_dir cmd_dir)\r\n{\r\nstruct iser_mem_reg *reg = &iser_task->rdma_regd[cmd_dir].reg;\r\nstruct iser_conn *ib_conn = iser_task->iser_conn->ib_conn;\r\nstruct fast_reg_descriptor *desc = reg->mem_h;\r\nif (!reg->is_mr)\r\nreturn;\r\nreg->mem_h = NULL;\r\nreg->is_mr = 0;\r\nspin_lock_bh(&ib_conn->lock);\r\nlist_add_tail(&desc->list, &ib_conn->fastreg.frwr.pool);\r\nspin_unlock_bh(&ib_conn->lock);\r\n}\r\nint iser_post_recvl(struct iser_conn *ib_conn)\r\n{\r\nstruct ib_recv_wr rx_wr, *rx_wr_failed;\r\nstruct ib_sge sge;\r\nint ib_ret;\r\nsge.addr = ib_conn->login_resp_dma;\r\nsge.length = ISER_RX_LOGIN_SIZE;\r\nsge.lkey = ib_conn->device->mr->lkey;\r\nrx_wr.wr_id = (unsigned long)ib_conn->login_resp_buf;\r\nrx_wr.sg_list = &sge;\r\nrx_wr.num_sge = 1;\r\nrx_wr.next = NULL;\r\nib_conn->post_recv_buf_count++;\r\nib_ret = ib_post_recv(ib_conn->qp, &rx_wr, &rx_wr_failed);\r\nif (ib_ret) {\r\niser_err("ib_post_recv failed ret=%d\n", ib_ret);\r\nib_conn->post_recv_buf_count--;\r\n}\r\nreturn ib_ret;\r\n}\r\nint iser_post_recvm(struct iser_conn *ib_conn, int count)\r\n{\r\nstruct ib_recv_wr *rx_wr, *rx_wr_failed;\r\nint i, ib_ret;\r\nunsigned int my_rx_head = ib_conn->rx_desc_head;\r\nstruct iser_rx_desc *rx_desc;\r\nfor (rx_wr = ib_conn->rx_wr, i = 0; i < count; i++, rx_wr++) {\r\nrx_desc = &ib_conn->rx_descs[my_rx_head];\r\nrx_wr->wr_id = (unsigned long)rx_desc;\r\nrx_wr->sg_list = &rx_desc->rx_sg;\r\nrx_wr->num_sge = 1;\r\nrx_wr->next = rx_wr + 1;\r\nmy_rx_head = (my_rx_head + 1) & ib_conn->qp_max_recv_dtos_mask;\r\n}\r\nrx_wr--;\r\nrx_wr->next = NULL;\r\nib_conn->post_recv_buf_count += count;\r\nib_ret = ib_post_recv(ib_conn->qp, ib_conn->rx_wr, &rx_wr_failed);\r\nif (ib_ret) {\r\niser_err("ib_post_recv failed ret=%d\n", ib_ret);\r\nib_conn->post_recv_buf_count -= count;\r\n} else\r\nib_conn->rx_desc_head = my_rx_head;\r\nreturn ib_ret;\r\n}\r\nint iser_post_send(struct iser_conn *ib_conn, struct iser_tx_desc *tx_desc)\r\n{\r\nint ib_ret;\r\nstruct ib_send_wr send_wr, *send_wr_failed;\r\nib_dma_sync_single_for_device(ib_conn->device->ib_device,\r\ntx_desc->dma_addr, ISER_HEADERS_LEN, DMA_TO_DEVICE);\r\nsend_wr.next = NULL;\r\nsend_wr.wr_id = (unsigned long)tx_desc;\r\nsend_wr.sg_list = tx_desc->tx_sg;\r\nsend_wr.num_sge = tx_desc->num_sge;\r\nsend_wr.opcode = IB_WR_SEND;\r\nsend_wr.send_flags = IB_SEND_SIGNALED;\r\natomic_inc(&ib_conn->post_send_buf_count);\r\nib_ret = ib_post_send(ib_conn->qp, &send_wr, &send_wr_failed);\r\nif (ib_ret) {\r\niser_err("ib_post_send failed, ret:%d\n", ib_ret);\r\natomic_dec(&ib_conn->post_send_buf_count);\r\n}\r\nreturn ib_ret;\r\n}\r\nstatic void iser_handle_comp_error(struct iser_tx_desc *desc,\r\nstruct iser_conn *ib_conn)\r\n{\r\nif (desc && desc->type == ISCSI_TX_DATAOUT)\r\nkmem_cache_free(ig.desc_cache, desc);\r\nif (ib_conn->post_recv_buf_count == 0 &&\r\natomic_read(&ib_conn->post_send_buf_count) == 0) {\r\nif (iser_conn_state_comp_exch(ib_conn, ISER_CONN_UP,\r\nISER_CONN_TERMINATING))\r\niscsi_conn_failure(ib_conn->iser_conn->iscsi_conn,\r\nISCSI_ERR_CONN_FAILED);\r\nib_conn->state = ISER_CONN_DOWN;\r\nwake_up_interruptible(&ib_conn->wait);\r\n}\r\n}\r\nstatic int iser_drain_tx_cq(struct iser_device *device, int cq_index)\r\n{\r\nstruct ib_cq *cq = device->tx_cq[cq_index];\r\nstruct ib_wc wc;\r\nstruct iser_tx_desc *tx_desc;\r\nstruct iser_conn *ib_conn;\r\nint completed_tx = 0;\r\nwhile (ib_poll_cq(cq, 1, &wc) == 1) {\r\ntx_desc = (struct iser_tx_desc *) (unsigned long) wc.wr_id;\r\nib_conn = wc.qp->qp_context;\r\nif (wc.status == IB_WC_SUCCESS) {\r\nif (wc.opcode == IB_WC_SEND)\r\niser_snd_completion(tx_desc, ib_conn);\r\nelse if (wc.opcode == IB_WC_LOCAL_INV ||\r\nwc.opcode == IB_WC_FAST_REG_MR) {\r\natomic_dec(&ib_conn->post_send_buf_count);\r\ncontinue;\r\n} else\r\niser_err("expected opcode %d got %d\n",\r\nIB_WC_SEND, wc.opcode);\r\n} else {\r\niser_err("tx id %llx status %d vend_err %x\n",\r\nwc.wr_id, wc.status, wc.vendor_err);\r\natomic_dec(&ib_conn->post_send_buf_count);\r\niser_handle_comp_error(tx_desc, ib_conn);\r\n}\r\ncompleted_tx++;\r\n}\r\nreturn completed_tx;\r\n}\r\nstatic void iser_cq_tasklet_fn(unsigned long data)\r\n{\r\nstruct iser_cq_desc *cq_desc = (struct iser_cq_desc *)data;\r\nstruct iser_device *device = cq_desc->device;\r\nint cq_index = cq_desc->cq_index;\r\nstruct ib_cq *cq = device->rx_cq[cq_index];\r\nstruct ib_wc wc;\r\nstruct iser_rx_desc *desc;\r\nunsigned long xfer_len;\r\nstruct iser_conn *ib_conn;\r\nint completed_tx, completed_rx;\r\ncompleted_tx = completed_rx = 0;\r\nwhile (ib_poll_cq(cq, 1, &wc) == 1) {\r\ndesc = (struct iser_rx_desc *) (unsigned long) wc.wr_id;\r\nBUG_ON(desc == NULL);\r\nib_conn = wc.qp->qp_context;\r\nif (wc.status == IB_WC_SUCCESS) {\r\nif (wc.opcode == IB_WC_RECV) {\r\nxfer_len = (unsigned long)wc.byte_len;\r\niser_rcv_completion(desc, xfer_len, ib_conn);\r\n} else\r\niser_err("expected opcode %d got %d\n",\r\nIB_WC_RECV, wc.opcode);\r\n} else {\r\nif (wc.status != IB_WC_WR_FLUSH_ERR)\r\niser_err("rx id %llx status %d vend_err %x\n",\r\nwc.wr_id, wc.status, wc.vendor_err);\r\nib_conn->post_recv_buf_count--;\r\niser_handle_comp_error(NULL, ib_conn);\r\n}\r\ncompleted_rx++;\r\nif (!(completed_rx & 63))\r\ncompleted_tx += iser_drain_tx_cq(device, cq_index);\r\n}\r\nib_req_notify_cq(cq, IB_CQ_NEXT_COMP);\r\ncompleted_tx += iser_drain_tx_cq(device, cq_index);\r\niser_dbg("got %d rx %d tx completions\n", completed_rx, completed_tx);\r\n}\r\nstatic void iser_cq_callback(struct ib_cq *cq, void *cq_context)\r\n{\r\nstruct iser_cq_desc *cq_desc = (struct iser_cq_desc *)cq_context;\r\nstruct iser_device *device = cq_desc->device;\r\nint cq_index = cq_desc->cq_index;\r\ntasklet_schedule(&device->cq_tasklet[cq_index]);\r\n}
