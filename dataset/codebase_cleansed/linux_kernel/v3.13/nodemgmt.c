static int jffs2_rp_can_write(struct jffs2_sb_info *c)\r\n{\r\nuint32_t avail;\r\nstruct jffs2_mount_opts *opts = &c->mount_opts;\r\navail = c->dirty_size + c->free_size + c->unchecked_size +\r\nc->erasing_size - c->resv_blocks_write * c->sector_size\r\n- c->nospc_dirty_size;\r\nif (avail < 2 * opts->rp_size)\r\njffs2_dbg(1, "rpsize %u, dirty_size %u, free_size %u, "\r\n"erasing_size %u, unchecked_size %u, "\r\n"nr_erasing_blocks %u, avail %u, resrv %u\n",\r\nopts->rp_size, c->dirty_size, c->free_size,\r\nc->erasing_size, c->unchecked_size,\r\nc->nr_erasing_blocks, avail, c->nospc_dirty_size);\r\nif (avail > opts->rp_size)\r\nreturn 1;\r\nif (capable(CAP_SYS_RESOURCE))\r\nreturn 1;\r\njffs2_dbg(1, "forbid writing\n");\r\nreturn 0;\r\n}\r\nint jffs2_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\r\nuint32_t *len, int prio, uint32_t sumsize)\r\n{\r\nint ret = -EAGAIN;\r\nint blocksneeded = c->resv_blocks_write;\r\nminsize = PAD(minsize);\r\njffs2_dbg(1, "%s(): Requested 0x%x bytes\n", __func__, minsize);\r\nmutex_lock(&c->alloc_sem);\r\njffs2_dbg(1, "%s(): alloc sem got\n", __func__);\r\nspin_lock(&c->erase_completion_lock);\r\nif (prio != ALLOC_DELETION && !jffs2_rp_can_write(c)) {\r\nret = -ENOSPC;\r\ngoto out;\r\n}\r\nwhile(ret == -EAGAIN) {\r\nwhile(c->nr_free_blocks + c->nr_erasing_blocks < blocksneeded) {\r\nuint32_t dirty, avail;\r\ndirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size + c->unchecked_size;\r\nif (dirty < c->nospc_dirty_size) {\r\nif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\r\njffs2_dbg(1, "%s(): Low on dirty space to GC, but it's a deletion. Allowing...\n",\r\n__func__);\r\nbreak;\r\n}\r\njffs2_dbg(1, "dirty size 0x%08x + unchecked_size 0x%08x < nospc_dirty_size 0x%08x, returning -ENOSPC\n",\r\ndirty, c->unchecked_size,\r\nc->sector_size);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn -ENOSPC;\r\n}\r\navail = c->free_size + c->dirty_size + c->erasing_size + c->unchecked_size;\r\nif ( (avail / c->sector_size) <= blocksneeded) {\r\nif (prio == ALLOC_DELETION && c->nr_free_blocks + c->nr_erasing_blocks >= c->resv_blocks_deletion) {\r\njffs2_dbg(1, "%s(): Low on possibly available space, but it's a deletion. Allowing...\n",\r\n__func__);\r\nbreak;\r\n}\r\njffs2_dbg(1, "max. available size 0x%08x < blocksneeded * sector_size 0x%08x, returning -ENOSPC\n",\r\navail, blocksneeded * c->sector_size);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\nreturn -ENOSPC;\r\n}\r\nmutex_unlock(&c->alloc_sem);\r\njffs2_dbg(1, "Triggering GC pass. nr_free_blocks %d, nr_erasing_blocks %d, free_size 0x%08x, dirty_size 0x%08x, wasted_size 0x%08x, used_size 0x%08x, erasing_size 0x%08x, bad_size 0x%08x (total 0x%08x of 0x%08x)\n",\r\nc->nr_free_blocks, c->nr_erasing_blocks,\r\nc->free_size, c->dirty_size, c->wasted_size,\r\nc->used_size, c->erasing_size, c->bad_size,\r\nc->free_size + c->dirty_size +\r\nc->wasted_size + c->used_size +\r\nc->erasing_size + c->bad_size,\r\nc->flash_size);\r\nspin_unlock(&c->erase_completion_lock);\r\nret = jffs2_garbage_collect_pass(c);\r\nif (ret == -EAGAIN) {\r\nspin_lock(&c->erase_completion_lock);\r\nif (c->nr_erasing_blocks &&\r\nlist_empty(&c->erase_pending_list) &&\r\nlist_empty(&c->erase_complete_list)) {\r\nDECLARE_WAITQUEUE(wait, current);\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nadd_wait_queue(&c->erase_wait, &wait);\r\njffs2_dbg(1, "%s waiting for erase to complete\n",\r\n__func__);\r\nspin_unlock(&c->erase_completion_lock);\r\nschedule();\r\n} else\r\nspin_unlock(&c->erase_completion_lock);\r\n} else if (ret)\r\nreturn ret;\r\ncond_resched();\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nmutex_lock(&c->alloc_sem);\r\nspin_lock(&c->erase_completion_lock);\r\n}\r\nret = jffs2_do_reserve_space(c, minsize, len, sumsize);\r\nif (ret) {\r\njffs2_dbg(1, "%s(): ret is %d\n", __func__, ret);\r\n}\r\n}\r\nout:\r\nspin_unlock(&c->erase_completion_lock);\r\nif (!ret)\r\nret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\r\nif (ret)\r\nmutex_unlock(&c->alloc_sem);\r\nreturn ret;\r\n}\r\nint jffs2_reserve_space_gc(struct jffs2_sb_info *c, uint32_t minsize,\r\nuint32_t *len, uint32_t sumsize)\r\n{\r\nint ret = -EAGAIN;\r\nminsize = PAD(minsize);\r\njffs2_dbg(1, "%s(): Requested 0x%x bytes\n", __func__, minsize);\r\nspin_lock(&c->erase_completion_lock);\r\nwhile(ret == -EAGAIN) {\r\nret = jffs2_do_reserve_space(c, minsize, len, sumsize);\r\nif (ret) {\r\njffs2_dbg(1, "%s(): looping, ret is %d\n",\r\n__func__, ret);\r\n}\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nif (!ret)\r\nret = jffs2_prealloc_raw_node_refs(c, c->nextblock, 1);\r\nreturn ret;\r\n}\r\nstatic void jffs2_close_nextblock(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb)\r\n{\r\nif (c->nextblock == NULL) {\r\njffs2_dbg(1, "%s(): Erase block at 0x%08x has already been placed in a list\n",\r\n__func__, jeb->offset);\r\nreturn;\r\n}\r\nif (ISDIRTY (jeb->wasted_size + jeb->dirty_size)) {\r\nc->dirty_size += jeb->wasted_size;\r\nc->wasted_size -= jeb->wasted_size;\r\njeb->dirty_size += jeb->wasted_size;\r\njeb->wasted_size = 0;\r\nif (VERYDIRTY(c, jeb->dirty_size)) {\r\njffs2_dbg(1, "Adding full erase block at 0x%08x to very_dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",\r\njeb->offset, jeb->free_size, jeb->dirty_size,\r\njeb->used_size);\r\nlist_add_tail(&jeb->list, &c->very_dirty_list);\r\n} else {\r\njffs2_dbg(1, "Adding full erase block at 0x%08x to dirty_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",\r\njeb->offset, jeb->free_size, jeb->dirty_size,\r\njeb->used_size);\r\nlist_add_tail(&jeb->list, &c->dirty_list);\r\n}\r\n} else {\r\njffs2_dbg(1, "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",\r\njeb->offset, jeb->free_size, jeb->dirty_size,\r\njeb->used_size);\r\nlist_add_tail(&jeb->list, &c->clean_list);\r\n}\r\nc->nextblock = NULL;\r\n}\r\nstatic int jffs2_find_nextblock(struct jffs2_sb_info *c)\r\n{\r\nstruct list_head *next;\r\nif (list_empty(&c->free_list)) {\r\nif (!c->nr_erasing_blocks &&\r\n!list_empty(&c->erasable_list)) {\r\nstruct jffs2_eraseblock *ejeb;\r\nejeb = list_entry(c->erasable_list.next, struct jffs2_eraseblock, list);\r\nlist_move_tail(&ejeb->list, &c->erase_pending_list);\r\nc->nr_erasing_blocks++;\r\njffs2_garbage_collect_trigger(c);\r\njffs2_dbg(1, "%s(): Triggering erase of erasable block at 0x%08x\n",\r\n__func__, ejeb->offset);\r\n}\r\nif (!c->nr_erasing_blocks &&\r\n!list_empty(&c->erasable_pending_wbuf_list)) {\r\njffs2_dbg(1, "%s(): Flushing write buffer\n",\r\n__func__);\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_flush_wbuf_pad(c);\r\nspin_lock(&c->erase_completion_lock);\r\nreturn -EAGAIN;\r\n}\r\nif (!c->nr_erasing_blocks) {\r\npr_crit("Argh. No free space left for GC. nr_erasing_blocks is %d. nr_free_blocks is %d. (erasableempty: %s, erasingempty: %s, erasependingempty: %s)\n",\r\nc->nr_erasing_blocks, c->nr_free_blocks,\r\nlist_empty(&c->erasable_list) ? "yes" : "no",\r\nlist_empty(&c->erasing_list) ? "yes" : "no",\r\nlist_empty(&c->erase_pending_list) ? "yes" : "no");\r\nreturn -ENOSPC;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_erase_pending_blocks(c, 1);\r\nspin_lock(&c->erase_completion_lock);\r\nreturn -EAGAIN;\r\n}\r\nnext = c->free_list.next;\r\nlist_del(next);\r\nc->nextblock = list_entry(next, struct jffs2_eraseblock, list);\r\nc->nr_free_blocks--;\r\njffs2_sum_reset_collected(c->summary);\r\n#ifdef CONFIG_JFFS2_FS_WRITEBUFFER\r\nif (!(c->wbuf_ofs % c->sector_size) && !c->wbuf_len)\r\nc->wbuf_ofs = 0xffffffff;\r\n#endif\r\njffs2_dbg(1, "%s(): new nextblock = 0x%08x\n",\r\n__func__, c->nextblock->offset);\r\nreturn 0;\r\n}\r\nstatic int jffs2_do_reserve_space(struct jffs2_sb_info *c, uint32_t minsize,\r\nuint32_t *len, uint32_t sumsize)\r\n{\r\nstruct jffs2_eraseblock *jeb = c->nextblock;\r\nuint32_t reserved_size;\r\nint ret;\r\nrestart:\r\nreserved_size = 0;\r\nif (jffs2_sum_active() && (sumsize != JFFS2_SUMMARY_NOSUM_SIZE)) {\r\nif (jeb) {\r\nreserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\r\ndbg_summary("minsize=%d , jeb->free=%d ,"\r\n"summary->size=%d , sumsize=%d\n",\r\nminsize, jeb->free_size,\r\nc->summary->sum_size, sumsize);\r\n}\r\nif (jeb && (PAD(minsize) + PAD(c->summary->sum_size + sumsize +\r\nJFFS2_SUMMARY_FRAME_SIZE) > jeb->free_size)) {\r\nif (jffs2_sum_is_disabled(c->summary)) {\r\nsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\r\ngoto restart;\r\n}\r\ndbg_summary("generating summary for 0x%08x.\n", jeb->offset);\r\nret = jffs2_sum_write_sumnode(c);\r\nif (ret)\r\nreturn ret;\r\nif (jffs2_sum_is_disabled(c->summary)) {\r\nsumsize = JFFS2_SUMMARY_NOSUM_SIZE;\r\ngoto restart;\r\n}\r\njffs2_close_nextblock(c, jeb);\r\njeb = NULL;\r\nreserved_size = PAD(sumsize + c->summary->sum_size + JFFS2_SUMMARY_FRAME_SIZE);\r\n}\r\n} else {\r\nif (jeb && minsize > jeb->free_size) {\r\nuint32_t waste;\r\nif (jffs2_wbuf_dirty(c)) {\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_dbg(1, "%s(): Flushing write buffer\n",\r\n__func__);\r\njffs2_flush_wbuf_pad(c);\r\nspin_lock(&c->erase_completion_lock);\r\njeb = c->nextblock;\r\ngoto restart;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nret = jffs2_prealloc_raw_node_refs(c, jeb, 1);\r\nspin_lock(&c->erase_completion_lock);\r\nif (ret)\r\nreturn ret;\r\nwaste = jeb->free_size;\r\njffs2_link_node_ref(c, jeb,\r\n(jeb->offset + c->sector_size - waste) | REF_OBSOLETE,\r\nwaste, NULL);\r\njeb->dirty_size -= waste;\r\nc->dirty_size -= waste;\r\njeb->wasted_size += waste;\r\nc->wasted_size += waste;\r\njffs2_close_nextblock(c, jeb);\r\njeb = NULL;\r\n}\r\n}\r\nif (!jeb) {\r\nret = jffs2_find_nextblock(c);\r\nif (ret)\r\nreturn ret;\r\njeb = c->nextblock;\r\nif (jeb->free_size != c->sector_size - c->cleanmarker_size) {\r\npr_warn("Eep. Block 0x%08x taken from free_list had free_size of 0x%08x!!\n",\r\njeb->offset, jeb->free_size);\r\ngoto restart;\r\n}\r\n}\r\n*len = jeb->free_size - reserved_size;\r\nif (c->cleanmarker_size && jeb->used_size == c->cleanmarker_size &&\r\n!jeb->first_node->next_in_ino) {\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_mark_node_obsolete(c, jeb->first_node);\r\nspin_lock(&c->erase_completion_lock);\r\n}\r\njffs2_dbg(1, "%s(): Giving 0x%x bytes at 0x%x\n",\r\n__func__,\r\n*len, jeb->offset + (c->sector_size - jeb->free_size));\r\nreturn 0;\r\n}\r\nstruct jffs2_raw_node_ref *jffs2_add_physical_node_ref(struct jffs2_sb_info *c,\r\nuint32_t ofs, uint32_t len,\r\nstruct jffs2_inode_cache *ic)\r\n{\r\nstruct jffs2_eraseblock *jeb;\r\nstruct jffs2_raw_node_ref *new;\r\njeb = &c->blocks[ofs / c->sector_size];\r\njffs2_dbg(1, "%s(): Node at 0x%x(%d), size 0x%x\n",\r\n__func__, ofs & ~3, ofs & 3, len);\r\n#if 1\r\nif ((c->nextblock || ((ofs & 3) != REF_OBSOLETE))\r\n&& (jeb != c->nextblock || (ofs & ~3) != jeb->offset + (c->sector_size - jeb->free_size))) {\r\npr_warn("argh. node added in wrong place at 0x%08x(%d)\n",\r\nofs & ~3, ofs & 3);\r\nif (c->nextblock)\r\npr_warn("nextblock 0x%08x", c->nextblock->offset);\r\nelse\r\npr_warn("No nextblock");\r\npr_cont(", expected at %08x\n",\r\njeb->offset + (c->sector_size - jeb->free_size));\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n#endif\r\nspin_lock(&c->erase_completion_lock);\r\nnew = jffs2_link_node_ref(c, jeb, ofs, len, ic);\r\nif (!jeb->free_size && !jeb->dirty_size && !ISDIRTY(jeb->wasted_size)) {\r\njffs2_dbg(1, "Adding full erase block at 0x%08x to clean_list (free 0x%08x, dirty 0x%08x, used 0x%08x\n",\r\njeb->offset, jeb->free_size, jeb->dirty_size,\r\njeb->used_size);\r\nif (jffs2_wbuf_dirty(c)) {\r\nspin_unlock(&c->erase_completion_lock);\r\njffs2_flush_wbuf_pad(c);\r\nspin_lock(&c->erase_completion_lock);\r\n}\r\nlist_add_tail(&jeb->list, &c->clean_list);\r\nc->nextblock = NULL;\r\n}\r\njffs2_dbg_acct_sanity_check_nolock(c,jeb);\r\njffs2_dbg_acct_paranoia_check_nolock(c, jeb);\r\nspin_unlock(&c->erase_completion_lock);\r\nreturn new;\r\n}\r\nvoid jffs2_complete_reservation(struct jffs2_sb_info *c)\r\n{\r\njffs2_dbg(1, "jffs2_complete_reservation()\n");\r\nspin_lock(&c->erase_completion_lock);\r\njffs2_garbage_collect_trigger(c);\r\nspin_unlock(&c->erase_completion_lock);\r\nmutex_unlock(&c->alloc_sem);\r\n}\r\nstatic inline int on_list(struct list_head *obj, struct list_head *head)\r\n{\r\nstruct list_head *this;\r\nlist_for_each(this, head) {\r\nif (this == obj) {\r\njffs2_dbg(1, "%p is on list at %p\n", obj, head);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid jffs2_mark_node_obsolete(struct jffs2_sb_info *c, struct jffs2_raw_node_ref *ref)\r\n{\r\nstruct jffs2_eraseblock *jeb;\r\nint blocknr;\r\nstruct jffs2_unknown_node n;\r\nint ret, addedsize;\r\nsize_t retlen;\r\nuint32_t freed_len;\r\nif(unlikely(!ref)) {\r\npr_notice("EEEEEK. jffs2_mark_node_obsolete called with NULL node\n");\r\nreturn;\r\n}\r\nif (ref_obsolete(ref)) {\r\njffs2_dbg(1, "%s(): called with already obsolete node at 0x%08x\n",\r\n__func__, ref_offset(ref));\r\nreturn;\r\n}\r\nblocknr = ref->flash_offset / c->sector_size;\r\nif (blocknr >= c->nr_blocks) {\r\npr_notice("raw node at 0x%08x is off the end of device!\n",\r\nref->flash_offset);\r\nBUG();\r\n}\r\njeb = &c->blocks[blocknr];\r\nif (jffs2_can_mark_obsolete(c) && !jffs2_is_readonly(c) &&\r\n!(c->flags & (JFFS2_SB_FLAG_SCANNING | JFFS2_SB_FLAG_BUILDING))) {\r\nmutex_lock(&c->erase_free_sem);\r\n}\r\nspin_lock(&c->erase_completion_lock);\r\nfreed_len = ref_totlen(c, jeb, ref);\r\nif (ref_flags(ref) == REF_UNCHECKED) {\r\nD1(if (unlikely(jeb->unchecked_size < freed_len)) {\r\npr_notice("raw unchecked node of size 0x%08x freed from erase block %d at 0x%08x, but unchecked_size was already 0x%08x\n",\r\nfreed_len, blocknr,\r\nref->flash_offset, jeb->used_size);\r\nBUG();\r\n})\r\njffs2_dbg(1, "Obsoleting previously unchecked node at 0x%08x of len %x\n",\r\nref_offset(ref), freed_len);\r\njeb->unchecked_size -= freed_len;\r\nc->unchecked_size -= freed_len;\r\n} else {\r\nD1(if (unlikely(jeb->used_size < freed_len)) {\r\npr_notice("raw node of size 0x%08x freed from erase block %d at 0x%08x, but used_size was already 0x%08x\n",\r\nfreed_len, blocknr,\r\nref->flash_offset, jeb->used_size);\r\nBUG();\r\n})\r\njffs2_dbg(1, "Obsoleting node at 0x%08x of len %#x: ",\r\nref_offset(ref), freed_len);\r\njeb->used_size -= freed_len;\r\nc->used_size -= freed_len;\r\n}\r\nif ((jeb->dirty_size || ISDIRTY(jeb->wasted_size + freed_len)) && jeb != c->nextblock) {\r\njffs2_dbg(1, "Dirtying\n");\r\naddedsize = freed_len;\r\njeb->dirty_size += freed_len;\r\nc->dirty_size += freed_len;\r\nif (jeb->wasted_size) {\r\nif (on_list(&jeb->list, &c->bad_used_list)) {\r\njffs2_dbg(1, "Leaving block at %08x on the bad_used_list\n",\r\njeb->offset);\r\naddedsize = 0;\r\n} else {\r\njffs2_dbg(1, "Converting %d bytes of wasted space to dirty in block at %08x\n",\r\njeb->wasted_size, jeb->offset);\r\naddedsize += jeb->wasted_size;\r\njeb->dirty_size += jeb->wasted_size;\r\nc->dirty_size += jeb->wasted_size;\r\nc->wasted_size -= jeb->wasted_size;\r\njeb->wasted_size = 0;\r\n}\r\n}\r\n} else {\r\njffs2_dbg(1, "Wasting\n");\r\naddedsize = 0;\r\njeb->wasted_size += freed_len;\r\nc->wasted_size += freed_len;\r\n}\r\nref->flash_offset = ref_offset(ref) | REF_OBSOLETE;\r\njffs2_dbg_acct_sanity_check_nolock(c, jeb);\r\njffs2_dbg_acct_paranoia_check_nolock(c, jeb);\r\nif (c->flags & JFFS2_SB_FLAG_SCANNING) {\r\nspin_unlock(&c->erase_completion_lock);\r\nreturn;\r\n}\r\nif (jeb == c->nextblock) {\r\njffs2_dbg(2, "Not moving nextblock 0x%08x to dirty/erase_pending list\n",\r\njeb->offset);\r\n} else if (!jeb->used_size && !jeb->unchecked_size) {\r\nif (jeb == c->gcblock) {\r\njffs2_dbg(1, "gcblock at 0x%08x completely dirtied. Clearing gcblock...\n",\r\njeb->offset);\r\nc->gcblock = NULL;\r\n} else {\r\njffs2_dbg(1, "Eraseblock at 0x%08x completely dirtied. Removing from (dirty?) list...\n",\r\njeb->offset);\r\nlist_del(&jeb->list);\r\n}\r\nif (jffs2_wbuf_dirty(c)) {\r\njffs2_dbg(1, "...and adding to erasable_pending_wbuf_list\n");\r\nlist_add_tail(&jeb->list, &c->erasable_pending_wbuf_list);\r\n} else {\r\nif (jiffies & 127) {\r\njffs2_dbg(1, "...and adding to erase_pending_list\n");\r\nlist_add_tail(&jeb->list, &c->erase_pending_list);\r\nc->nr_erasing_blocks++;\r\njffs2_garbage_collect_trigger(c);\r\n} else {\r\njffs2_dbg(1, "...and adding to erasable_list\n");\r\nlist_add_tail(&jeb->list, &c->erasable_list);\r\n}\r\n}\r\njffs2_dbg(1, "Done OK\n");\r\n} else if (jeb == c->gcblock) {\r\njffs2_dbg(2, "Not moving gcblock 0x%08x to dirty_list\n",\r\njeb->offset);\r\n} else if (ISDIRTY(jeb->dirty_size) && !ISDIRTY(jeb->dirty_size - addedsize)) {\r\njffs2_dbg(1, "Eraseblock at 0x%08x is freshly dirtied. Removing from clean list...\n",\r\njeb->offset);\r\nlist_del(&jeb->list);\r\njffs2_dbg(1, "...and adding to dirty_list\n");\r\nlist_add_tail(&jeb->list, &c->dirty_list);\r\n} else if (VERYDIRTY(c, jeb->dirty_size) &&\r\n!VERYDIRTY(c, jeb->dirty_size - addedsize)) {\r\njffs2_dbg(1, "Eraseblock at 0x%08x is now very dirty. Removing from dirty list...\n",\r\njeb->offset);\r\nlist_del(&jeb->list);\r\njffs2_dbg(1, "...and adding to very_dirty_list\n");\r\nlist_add_tail(&jeb->list, &c->very_dirty_list);\r\n} else {\r\njffs2_dbg(1, "Eraseblock at 0x%08x not moved anywhere. (free 0x%08x, dirty 0x%08x, used 0x%08x)\n",\r\njeb->offset, jeb->free_size, jeb->dirty_size,\r\njeb->used_size);\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\nif (!jffs2_can_mark_obsolete(c) || jffs2_is_readonly(c) ||\r\n(c->flags & JFFS2_SB_FLAG_BUILDING)) {\r\nreturn;\r\n}\r\njffs2_dbg(1, "obliterating obsoleted node at 0x%08x\n",\r\nref_offset(ref));\r\nret = jffs2_flash_read(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\r\nif (ret) {\r\npr_warn("Read error reading from obsoleted node at 0x%08x: %d\n",\r\nref_offset(ref), ret);\r\ngoto out_erase_sem;\r\n}\r\nif (retlen != sizeof(n)) {\r\npr_warn("Short read from obsoleted node at 0x%08x: %zd\n",\r\nref_offset(ref), retlen);\r\ngoto out_erase_sem;\r\n}\r\nif (PAD(je32_to_cpu(n.totlen)) != PAD(freed_len)) {\r\npr_warn("Node totlen on flash (0x%08x) != totlen from node ref (0x%08x)\n",\r\nje32_to_cpu(n.totlen), freed_len);\r\ngoto out_erase_sem;\r\n}\r\nif (!(je16_to_cpu(n.nodetype) & JFFS2_NODE_ACCURATE)) {\r\njffs2_dbg(1, "Node at 0x%08x was already marked obsolete (nodetype 0x%04x)\n",\r\nref_offset(ref), je16_to_cpu(n.nodetype));\r\ngoto out_erase_sem;\r\n}\r\nn.nodetype = cpu_to_je16(je16_to_cpu(n.nodetype) & ~JFFS2_NODE_ACCURATE);\r\nret = jffs2_flash_write(c, ref_offset(ref), sizeof(n), &retlen, (char *)&n);\r\nif (ret) {\r\npr_warn("Write error in obliterating obsoleted node at 0x%08x: %d\n",\r\nref_offset(ref), ret);\r\ngoto out_erase_sem;\r\n}\r\nif (retlen != sizeof(n)) {\r\npr_warn("Short write in obliterating obsoleted node at 0x%08x: %zd\n",\r\nref_offset(ref), retlen);\r\ngoto out_erase_sem;\r\n}\r\nif (ref->next_in_ino) {\r\nstruct jffs2_inode_cache *ic;\r\nstruct jffs2_raw_node_ref **p;\r\nspin_lock(&c->erase_completion_lock);\r\nic = jffs2_raw_ref_to_ic(ref);\r\nfor (p = &ic->nodes; (*p) != ref; p = &((*p)->next_in_ino))\r\n;\r\n*p = ref->next_in_ino;\r\nref->next_in_ino = NULL;\r\nswitch (ic->class) {\r\n#ifdef CONFIG_JFFS2_FS_XATTR\r\ncase RAWNODE_CLASS_XATTR_DATUM:\r\njffs2_release_xattr_datum(c, (struct jffs2_xattr_datum *)ic);\r\nbreak;\r\ncase RAWNODE_CLASS_XATTR_REF:\r\njffs2_release_xattr_ref(c, (struct jffs2_xattr_ref *)ic);\r\nbreak;\r\n#endif\r\ndefault:\r\nif (ic->nodes == (void *)ic && ic->pino_nlink == 0)\r\njffs2_del_ino_cache(c, ic);\r\nbreak;\r\n}\r\nspin_unlock(&c->erase_completion_lock);\r\n}\r\nout_erase_sem:\r\nmutex_unlock(&c->erase_free_sem);\r\n}\r\nint jffs2_thread_should_wake(struct jffs2_sb_info *c)\r\n{\r\nint ret = 0;\r\nuint32_t dirty;\r\nint nr_very_dirty = 0;\r\nstruct jffs2_eraseblock *jeb;\r\nif (!list_empty(&c->erase_complete_list) ||\r\n!list_empty(&c->erase_pending_list))\r\nreturn 1;\r\nif (c->unchecked_size) {\r\njffs2_dbg(1, "jffs2_thread_should_wake(): unchecked_size %d, checked_ino #%d\n",\r\nc->unchecked_size, c->checked_ino);\r\nreturn 1;\r\n}\r\ndirty = c->dirty_size + c->erasing_size - c->nr_erasing_blocks * c->sector_size;\r\nif (c->nr_free_blocks + c->nr_erasing_blocks < c->resv_blocks_gctrigger &&\r\n(dirty > c->nospc_dirty_size))\r\nret = 1;\r\nlist_for_each_entry(jeb, &c->very_dirty_list, list) {\r\nnr_very_dirty++;\r\nif (nr_very_dirty == c->vdirty_blocks_gctrigger) {\r\nret = 1;\r\nD1(continue);\r\nbreak;\r\n}\r\n}\r\njffs2_dbg(1, "%s(): nr_free_blocks %d, nr_erasing_blocks %d, dirty_size 0x%x, vdirty_blocks %d: %s\n",\r\n__func__, c->nr_free_blocks, c->nr_erasing_blocks,\r\nc->dirty_size, nr_very_dirty, ret ? "yes" : "no");\r\nreturn ret;\r\n}
