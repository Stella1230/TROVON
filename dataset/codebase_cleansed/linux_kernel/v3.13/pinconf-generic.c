void pinconf_generic_dump_pin(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin)\r\n{\r\nconst struct pinconf_ops *ops = pctldev->desc->confops;\r\nint i;\r\nif (!ops->is_generic)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(conf_items); i++) {\r\nunsigned long config;\r\nint ret;\r\nconfig = pinconf_to_config_packed(conf_items[i].param, 0);\r\nret = pin_config_get_for_pin(pctldev, pin, &config);\r\nif (ret == -EINVAL || ret == -ENOTSUPP)\r\ncontinue;\r\nif (ret) {\r\nseq_printf(s, "ERROR READING CONFIG SETTING %d ", i);\r\ncontinue;\r\n}\r\nseq_puts(s, " ");\r\nseq_puts(s, conf_items[i].display);\r\nif (conf_items[i].format &&\r\npinconf_to_config_argument(config) != 0)\r\nseq_printf(s, " (%u %s)",\r\npinconf_to_config_argument(config),\r\nconf_items[i].format);\r\n}\r\n}\r\nvoid pinconf_generic_dump_group(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, const char *gname)\r\n{\r\nconst struct pinconf_ops *ops = pctldev->desc->confops;\r\nint i;\r\nif (!ops->is_generic)\r\nreturn;\r\nfor (i = 0; i < ARRAY_SIZE(conf_items); i++) {\r\nunsigned long config;\r\nint ret;\r\nconfig = pinconf_to_config_packed(conf_items[i].param, 0);\r\nret = pin_config_group_get(dev_name(pctldev->dev), gname,\r\n&config);\r\nif (ret == -EINVAL || ret == -ENOTSUPP)\r\ncontinue;\r\nif (ret) {\r\nseq_printf(s, "ERROR READING CONFIG SETTING %d ", i);\r\ncontinue;\r\n}\r\nseq_puts(s, " ");\r\nseq_puts(s, conf_items[i].display);\r\nif (conf_items[i].format && config != 0)\r\nseq_printf(s, " (%u %s)",\r\npinconf_to_config_argument(config),\r\nconf_items[i].format);\r\n}\r\n}\r\nvoid pinconf_generic_dump_config(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned long config)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(conf_items); i++) {\r\nif (pinconf_to_config_param(config) != conf_items[i].param)\r\ncontinue;\r\nseq_printf(s, "%s: 0x%x", conf_items[i].display,\r\npinconf_to_config_argument(config));\r\n}\r\n}\r\nint pinconf_generic_parse_dt_config(struct device_node *np,\r\nunsigned long **configs,\r\nunsigned int *nconfigs)\r\n{\r\nunsigned long *cfg;\r\nunsigned int ncfg = 0;\r\nint ret;\r\nint i;\r\nu32 val;\r\nif (!np)\r\nreturn -EINVAL;\r\ncfg = kzalloc(sizeof(*cfg) * ARRAY_SIZE(dt_params), GFP_KERNEL);\r\nif (!cfg)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(dt_params); i++) {\r\nstruct pinconf_generic_dt_params *par = &dt_params[i];\r\nret = of_property_read_u32(np, par->property, &val);\r\nif (ret == -EINVAL)\r\ncontinue;\r\nif (ret)\r\nval = par->default_value;\r\npr_debug("found %s with value %u\n", par->property, val);\r\ncfg[ncfg] = pinconf_to_config_packed(par->param, val);\r\nncfg++;\r\n}\r\nret = 0;\r\nif (ncfg == 0) {\r\n*configs = NULL;\r\n*nconfigs = 0;\r\ngoto out;\r\n}\r\n*configs = kzalloc(ncfg * sizeof(unsigned long), GFP_KERNEL);\r\nif (!*configs) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nmemcpy(*configs, cfg, ncfg * sizeof(unsigned long));\r\n*nconfigs = ncfg;\r\nout:\r\nkfree(cfg);\r\nreturn ret;\r\n}\r\nint pinconf_generic_dt_subnode_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np, struct pinctrl_map **map,\r\nunsigned *reserved_maps, unsigned *num_maps,\r\nenum pinctrl_map_type type)\r\n{\r\nint ret;\r\nconst char *function;\r\nstruct device *dev = pctldev->dev;\r\nunsigned long *configs = NULL;\r\nunsigned num_configs = 0;\r\nunsigned reserve;\r\nstruct property *prop;\r\nconst char *group;\r\nret = of_property_read_string(np, "function", &function);\r\nif (ret < 0) {\r\nif (ret != -EINVAL)\r\ndev_err(dev, "could not parse property function\n");\r\nfunction = NULL;\r\n}\r\nret = pinconf_generic_parse_dt_config(np, &configs, &num_configs);\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse node property\n");\r\nreturn ret;\r\n}\r\nreserve = 0;\r\nif (function != NULL)\r\nreserve++;\r\nif (num_configs)\r\nreserve++;\r\nret = of_property_count_strings(np, "pins");\r\nif (ret < 0) {\r\ndev_err(dev, "could not parse property pins\n");\r\ngoto exit;\r\n}\r\nreserve *= ret;\r\nret = pinctrl_utils_reserve_map(pctldev, map, reserved_maps,\r\nnum_maps, reserve);\r\nif (ret < 0)\r\ngoto exit;\r\nof_property_for_each_string(np, "pins", prop, group) {\r\nif (function) {\r\nret = pinctrl_utils_add_map_mux(pctldev, map,\r\nreserved_maps, num_maps, group,\r\nfunction);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\nif (num_configs) {\r\nret = pinctrl_utils_add_map_configs(pctldev, map,\r\nreserved_maps, num_maps, group, configs,\r\nnum_configs, type);\r\nif (ret < 0)\r\ngoto exit;\r\n}\r\n}\r\nret = 0;\r\nexit:\r\nkfree(configs);\r\nreturn ret;\r\n}\r\nint pinconf_generic_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np_config, struct pinctrl_map **map,\r\nunsigned *num_maps, enum pinctrl_map_type type)\r\n{\r\nunsigned reserved_maps;\r\nstruct device_node *np;\r\nint ret;\r\nreserved_maps = 0;\r\n*map = NULL;\r\n*num_maps = 0;\r\nfor_each_child_of_node(np_config, np) {\r\nret = pinconf_generic_dt_subnode_to_map(pctldev, np, map,\r\n&reserved_maps, num_maps, type);\r\nif (ret < 0) {\r\npinctrl_utils_dt_free_map(pctldev, *map, *num_maps);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
