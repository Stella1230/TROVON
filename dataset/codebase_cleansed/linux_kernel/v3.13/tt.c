static inline u32 DTS_DIODE_GET_VREFS_ID(u32 flags)\r\n{\r\nreturn (flags & DTS_DIODE_REG_FLAGS_VREFS_ID) >>\r\nDTS_DIODE_REG_FLAGS_VREFS_ID_POS;\r\n}\r\nstatic s16 iwl_mvm_dts_get_volt_band_gap(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_nvm_section calib_sec;\r\nconst __le16 *calib;\r\nu16 vbg;\r\ncalib_sec = mvm->nvm_sections[NVM_SECTION_TYPE_CALIBRATION];\r\ncalib = (__le16 *)calib_sec.data;\r\nvbg = le16_to_cpu(calib[OTP_WP_DTS_VBG]);\r\nif (vbg < MEAS_VBG_MIN_VAL || vbg > MEAS_VBG_MAX_VAL)\r\nvbg = MEAS_VBG_DEFAULT_VAL;\r\nreturn vbg;\r\n}\r\nstatic u16 iwl_mvm_dts_get_ptat_deviation_offset(struct iwl_mvm *mvm)\r\n{\r\nconst u8 *calib;\r\nu8 ptat, pa1, pa2, median;\r\ncalib = mvm->nvm_sections[NVM_SECTION_TYPE_CALIBRATION].data;\r\nptat = calib[OTP_DTS_DIODE_DEVIATION];\r\npa1 = calib[OTP_DTS_DIODE_DEVIATION + 1];\r\npa2 = calib[OTP_DTS_DIODE_DEVIATION + 2];\r\nif (ptat > pa1) {\r\nif (ptat > pa2)\r\nmedian = (pa1 > pa2) ? pa1 : pa2;\r\nelse\r\nmedian = ptat;\r\n} else {\r\nif (pa1 > pa2)\r\nmedian = (ptat > pa2) ? ptat : pa2;\r\nelse\r\nmedian = pa1;\r\n}\r\nreturn ptat - median;\r\n}\r\nstatic u8 iwl_mvm_dts_calibrate_ptat_deviation(struct iwl_mvm *mvm, u8 value)\r\n{\r\ns16 new_val = value - iwl_mvm_dts_get_ptat_deviation_offset(mvm);\r\nif (new_val > PTAT_DIGITAL_VALUE_MAX_VALUE)\r\nnew_val = PTAT_DIGITAL_VALUE_MAX_VALUE;\r\nelse if (new_val < PTAT_DIGITAL_VALUE_MIN_VALUE)\r\nnew_val = PTAT_DIGITAL_VALUE_MIN_VALUE;\r\nreturn new_val;\r\n}\r\nstatic bool dts_get_adjacent_vrefs(struct iwl_mvm *mvm,\r\nunion dts_diode_results *avg_ptat)\r\n{\r\nu8 vrefs_results[DTS_VREFS_NUM];\r\nu8 low_vref_index = 0, flags;\r\nu32 reg;\r\nreg = iwl_read_prph(mvm->trans, DTSC_VREF_AVG);\r\nmemcpy(vrefs_results, &reg, sizeof(reg));\r\nreg = iwl_read_prph(mvm->trans, DTSC_VREF5_AVG);\r\nvrefs_results[4] = reg & 0xff;\r\nif (avg_ptat->bits.digital_value < vrefs_results[0] ||\r\navg_ptat->bits.digital_value > vrefs_results[4])\r\nreturn false;\r\nif (avg_ptat->bits.digital_value > vrefs_results[3])\r\nlow_vref_index = 3;\r\nelse if (avg_ptat->bits.digital_value > vrefs_results[2])\r\nlow_vref_index = 2;\r\nelse if (avg_ptat->bits.digital_value > vrefs_results[1])\r\nlow_vref_index = 1;\r\navg_ptat->bits.vref_low = vrefs_results[low_vref_index];\r\navg_ptat->bits.vref_high = vrefs_results[low_vref_index + 1];\r\nflags = avg_ptat->bits.flags;\r\navg_ptat->bits.flags =\r\n(flags & ~DTS_DIODE_REG_FLAGS_VREFS_ID) |\r\n(low_vref_index & DTS_DIODE_REG_FLAGS_VREFS_ID);\r\nreturn true;\r\n}\r\nstatic bool dts_read_ptat_avg_results(struct iwl_mvm *mvm,\r\nunion dts_diode_results *avg_ptat)\r\n{\r\nu32 reg;\r\nu8 tmp;\r\nreg = iwl_read_prph(mvm->trans, DTSC_PTAT_AVG);\r\nreg &= DTS_DIODE_REG_DIG_VAL | DTS_DIODE_REG_PASS_ONCE;\r\navg_ptat->reg_value = reg;\r\ntmp = avg_ptat->bits.digital_value;\r\ntmp = iwl_mvm_dts_calibrate_ptat_deviation(mvm, tmp);\r\navg_ptat->bits.digital_value = tmp;\r\nreturn dts_get_adjacent_vrefs(mvm, avg_ptat) &&\r\nDTS_DIODE_VALID(avg_ptat->bits.flags);\r\n}\r\nstatic s32 calculate_nic_temperature(union dts_diode_results avg_ptat,\r\nu16 volt_band_gap)\r\n{\r\nu32 tmp_result;\r\nu8 vrefs_diff;\r\nstatic const u16 calc_lut[CALC_LUT_SIZE] = {\r\n2168, 2118, 2071, 2026, 1983, 1942, 1902, 1864, 1828,\r\n};\r\nvrefs_diff = avg_ptat.bits.vref_high - avg_ptat.bits.vref_low;\r\nif (vrefs_diff < CALC_VREFS_MIN_DIFF ||\r\nvrefs_diff > CALC_VREFS_MAX_DIFF)\r\nreturn TEMPERATURE_ERROR;\r\ntmp_result =\r\nvrefs_diff * (DTS_DIODE_GET_VREFS_ID(avg_ptat.bits.flags) + 9);\r\ntmp_result += avg_ptat.bits.digital_value;\r\ntmp_result -= avg_ptat.bits.vref_high;\r\ntmp_result *= calc_lut[vrefs_diff - CALC_LUT_INDEX_OFFSET];\r\ntmp_result *= volt_band_gap;\r\ntmp_result = tmp_result >> CALC_TEMPERATURE_RESULT_SHIFT_OFFSET;\r\nreturn (s16)tmp_result - 240;\r\n}\r\nstatic s32 check_nic_temperature(struct iwl_mvm *mvm)\r\n{\r\nu16 volt_band_gap;\r\nunion dts_diode_results avg_ptat;\r\nvolt_band_gap = iwl_mvm_dts_get_volt_band_gap(mvm);\r\niwl_write_prph(mvm->trans, SHR_MISC_WFM_DTS_EN, 0);\r\niwl_write_prph(mvm->trans, SHR_MISC_WFM_DTS_EN, 1);\r\niwl_write_prph(mvm->trans, DTSC_CFG_MODE,\r\nDTSC_CFG_MODE_PERIODIC);\r\nmsleep(100);\r\nif (!dts_read_ptat_avg_results(mvm, &avg_ptat))\r\nreturn TEMPERATURE_ERROR;\r\niwl_write_prph(mvm->trans, SHR_MISC_WFM_DTS_EN, 0);\r\nreturn calculate_nic_temperature(avg_ptat, volt_band_gap);\r\n}\r\nstatic void iwl_mvm_enter_ctkill(struct iwl_mvm *mvm)\r\n{\r\nu32 duration = mvm->thermal_throttle.params->ct_kill_duration;\r\nIWL_ERR(mvm, "Enter CT Kill\n");\r\niwl_mvm_set_hw_ctkill_state(mvm, true);\r\nschedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,\r\nround_jiffies_relative(duration * HZ));\r\n}\r\nstatic void iwl_mvm_exit_ctkill(struct iwl_mvm *mvm)\r\n{\r\nIWL_ERR(mvm, "Exit CT Kill\n");\r\niwl_mvm_set_hw_ctkill_state(mvm, false);\r\n}\r\nstatic void check_exit_ctkill(struct work_struct *work)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt;\r\nstruct iwl_mvm *mvm;\r\nu32 duration;\r\ns32 temp;\r\ntt = container_of(work, struct iwl_mvm_tt_mgmt, ct_kill_exit.work);\r\nmvm = container_of(tt, struct iwl_mvm, thermal_throttle);\r\nduration = tt->params->ct_kill_duration;\r\niwl_trans_start_hw(mvm->trans);\r\ntemp = check_nic_temperature(mvm);\r\niwl_trans_stop_hw(mvm->trans, false);\r\nif (temp < MIN_TEMPERATURE || temp > MAX_TEMPERATURE) {\r\nIWL_DEBUG_TEMP(mvm, "Failed to measure NIC temperature\n");\r\ngoto reschedule;\r\n}\r\nIWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", temp);\r\nif (temp <= tt->params->ct_kill_exit) {\r\niwl_mvm_exit_ctkill(mvm);\r\nreturn;\r\n}\r\nreschedule:\r\nschedule_delayed_work(&mvm->thermal_throttle.ct_kill_exit,\r\nround_jiffies(duration * HZ));\r\n}\r\nstatic void iwl_mvm_tt_smps_iterator(void *_data, u8 *mac,\r\nstruct ieee80211_vif *vif)\r\n{\r\nstruct iwl_mvm *mvm = _data;\r\nenum ieee80211_smps_mode smps_mode;\r\nlockdep_assert_held(&mvm->mutex);\r\nif (mvm->thermal_throttle.dynamic_smps)\r\nsmps_mode = IEEE80211_SMPS_DYNAMIC;\r\nelse\r\nsmps_mode = IEEE80211_SMPS_AUTOMATIC;\r\nif (vif->type != NL80211_IFTYPE_STATION)\r\nreturn;\r\niwl_mvm_update_smps(mvm, vif, IWL_MVM_SMPS_REQ_TT, smps_mode);\r\n}\r\nstatic void iwl_mvm_tt_tx_protection(struct iwl_mvm *mvm, bool enable)\r\n{\r\nstruct ieee80211_sta *sta;\r\nstruct iwl_mvm_sta *mvmsta;\r\nint i, err;\r\nfor (i = 0; i < IWL_MVM_STATION_COUNT; i++) {\r\nsta = rcu_dereference_protected(mvm->fw_id_to_mac_id[i],\r\nlockdep_is_held(&mvm->mutex));\r\nif (IS_ERR_OR_NULL(sta))\r\ncontinue;\r\nmvmsta = (void *)sta->drv_priv;\r\nif (enable == mvmsta->tt_tx_protection)\r\ncontinue;\r\nerr = iwl_mvm_tx_protection(mvm, mvmsta, enable);\r\nif (err) {\r\nIWL_ERR(mvm, "Failed to %s Tx protection\n",\r\nenable ? "enable" : "disable");\r\n} else {\r\nIWL_DEBUG_TEMP(mvm, "%s Tx protection\n",\r\nenable ? "Enable" : "Disable");\r\nmvmsta->tt_tx_protection = enable;\r\n}\r\n}\r\n}\r\nstatic void iwl_mvm_tt_tx_backoff(struct iwl_mvm *mvm, u32 backoff)\r\n{\r\nstruct iwl_host_cmd cmd = {\r\n.id = REPLY_THERMAL_MNG_BACKOFF,\r\n.len = { sizeof(u32), },\r\n.data = { &backoff, },\r\n.flags = CMD_SYNC,\r\n};\r\nif (iwl_mvm_send_cmd(mvm, &cmd) == 0) {\r\nIWL_DEBUG_TEMP(mvm, "Set Thermal Tx backoff to: %u\n",\r\nbackoff);\r\nmvm->thermal_throttle.tx_backoff = backoff;\r\n} else {\r\nIWL_ERR(mvm, "Failed to change Thermal Tx backoff\n");\r\n}\r\n}\r\nvoid iwl_mvm_tt_handler(struct iwl_mvm *mvm)\r\n{\r\nconst struct iwl_tt_params *params = mvm->thermal_throttle.params;\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\ns32 temperature = mvm->temperature;\r\nbool throttle_enable = false;\r\nint i;\r\nu32 tx_backoff;\r\nIWL_DEBUG_TEMP(mvm, "NIC temperature: %d\n", mvm->temperature);\r\nif (params->support_ct_kill && temperature >= params->ct_kill_entry) {\r\niwl_mvm_enter_ctkill(mvm);\r\nreturn;\r\n}\r\nif (params->support_dynamic_smps) {\r\nif (!tt->dynamic_smps &&\r\ntemperature >= params->dynamic_smps_entry) {\r\nIWL_DEBUG_TEMP(mvm, "Enable dynamic SMPS\n");\r\ntt->dynamic_smps = true;\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_tt_smps_iterator, mvm);\r\nthrottle_enable = true;\r\n} else if (tt->dynamic_smps &&\r\ntemperature <= params->dynamic_smps_exit) {\r\nIWL_DEBUG_TEMP(mvm, "Disable dynamic SMPS\n");\r\ntt->dynamic_smps = false;\r\nieee80211_iterate_active_interfaces_atomic(\r\nmvm->hw, IEEE80211_IFACE_ITER_NORMAL,\r\niwl_mvm_tt_smps_iterator, mvm);\r\n}\r\n}\r\nif (params->support_tx_protection) {\r\nif (temperature >= params->tx_protection_entry) {\r\niwl_mvm_tt_tx_protection(mvm, true);\r\nthrottle_enable = true;\r\n} else if (temperature <= params->tx_protection_exit) {\r\niwl_mvm_tt_tx_protection(mvm, false);\r\n}\r\n}\r\nif (params->support_tx_backoff) {\r\ntx_backoff = 0;\r\nfor (i = 0; i < TT_TX_BACKOFF_SIZE; i++) {\r\nif (temperature < params->tx_backoff[i].temperature)\r\nbreak;\r\ntx_backoff = params->tx_backoff[i].backoff;\r\n}\r\nif (tx_backoff != 0)\r\nthrottle_enable = true;\r\nif (tt->tx_backoff != tx_backoff)\r\niwl_mvm_tt_tx_backoff(mvm, tx_backoff);\r\n}\r\nif (!tt->throttle && throttle_enable) {\r\nIWL_WARN(mvm,\r\n"Due to high temperature thermal throttling initiated\n");\r\ntt->throttle = true;\r\n} else if (tt->throttle && !tt->dynamic_smps && tt->tx_backoff == 0 &&\r\ntemperature <= params->tx_protection_exit) {\r\nIWL_WARN(mvm,\r\n"Temperature is back to normal thermal throttling stopped\n");\r\ntt->throttle = false;\r\n}\r\n}\r\nvoid iwl_mvm_tt_initialize(struct iwl_mvm *mvm)\r\n{\r\nstruct iwl_mvm_tt_mgmt *tt = &mvm->thermal_throttle;\r\nIWL_DEBUG_TEMP(mvm, "Initialize Thermal Throttling\n");\r\nif (mvm->cfg->high_temp)\r\ntt->params = &iwl7000_high_temp_tt_params;\r\nelse\r\ntt->params = &iwl7000_tt_params;\r\ntt->throttle = false;\r\nINIT_DELAYED_WORK(&tt->ct_kill_exit, check_exit_ctkill);\r\n}\r\nvoid iwl_mvm_tt_exit(struct iwl_mvm *mvm)\r\n{\r\ncancel_delayed_work_sync(&mvm->thermal_throttle.ct_kill_exit);\r\nIWL_DEBUG_TEMP(mvm, "Exit Thermal Throttling\n");\r\n}
