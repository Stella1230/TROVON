static bool match_scancode(struct hid_usage *usage,\r\nunsigned int cur_idx, unsigned int scancode)\r\n{\r\nreturn (usage->hid & (HID_USAGE_PAGE | HID_USAGE)) == scancode;\r\n}\r\nstatic bool match_keycode(struct hid_usage *usage,\r\nunsigned int cur_idx, unsigned int keycode)\r\n{\r\nreturn (usage->type == EV_KEY && usage->code == keycode);\r\n}\r\nstatic bool match_index(struct hid_usage *usage,\r\nunsigned int cur_idx, unsigned int idx)\r\n{\r\nreturn cur_idx == idx;\r\n}\r\nstatic struct hid_usage *hidinput_find_key(struct hid_device *hid,\r\nhid_usage_cmp_t match,\r\nunsigned int value,\r\nunsigned int *usage_idx)\r\n{\r\nunsigned int i, j, k, cur_idx = 0;\r\nstruct hid_report *report;\r\nstruct hid_usage *usage;\r\nfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\r\nlist_for_each_entry(report, &hid->report_enum[k].report_list, list) {\r\nfor (i = 0; i < report->maxfield; i++) {\r\nfor (j = 0; j < report->field[i]->maxusage; j++) {\r\nusage = report->field[i]->usage + j;\r\nif (usage->type == EV_KEY || usage->type == 0) {\r\nif (match(usage, cur_idx, value)) {\r\nif (usage_idx)\r\n*usage_idx = cur_idx;\r\nreturn usage;\r\n}\r\ncur_idx++;\r\n}\r\n}\r\n}\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct hid_usage *hidinput_locate_usage(struct hid_device *hid,\r\nconst struct input_keymap_entry *ke,\r\nunsigned int *index)\r\n{\r\nstruct hid_usage *usage;\r\nunsigned int scancode;\r\nif (ke->flags & INPUT_KEYMAP_BY_INDEX)\r\nusage = hidinput_find_key(hid, match_index, ke->index, index);\r\nelse if (input_scancode_to_scalar(ke, &scancode) == 0)\r\nusage = hidinput_find_key(hid, match_scancode, scancode, index);\r\nelse\r\nusage = NULL;\r\nreturn usage;\r\n}\r\nstatic int hidinput_getkeycode(struct input_dev *dev,\r\nstruct input_keymap_entry *ke)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct hid_usage *usage;\r\nunsigned int scancode, index;\r\nusage = hidinput_locate_usage(hid, ke, &index);\r\nif (usage) {\r\nke->keycode = usage->type == EV_KEY ?\r\nusage->code : KEY_RESERVED;\r\nke->index = index;\r\nscancode = usage->hid & (HID_USAGE_PAGE | HID_USAGE);\r\nke->len = sizeof(scancode);\r\nmemcpy(ke->scancode, &scancode, sizeof(scancode));\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hidinput_setkeycode(struct input_dev *dev,\r\nconst struct input_keymap_entry *ke,\r\nunsigned int *old_keycode)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct hid_usage *usage;\r\nusage = hidinput_locate_usage(hid, ke, NULL);\r\nif (usage) {\r\n*old_keycode = usage->type == EV_KEY ?\r\nusage->code : KEY_RESERVED;\r\nusage->code = ke->keycode;\r\nclear_bit(*old_keycode, dev->keybit);\r\nset_bit(usage->code, dev->keybit);\r\ndbg_hid("Assigned keycode %d to HID usage code %x\n",\r\nusage->code, usage->hid);\r\nif (hidinput_find_key(hid, match_keycode, *old_keycode, NULL))\r\nset_bit(*old_keycode, dev->keybit);\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\n__s32 hidinput_calc_abs_res(const struct hid_field *field, __u16 code)\r\n{\r\n__s32 unit_exponent = field->unit_exponent;\r\n__s32 logical_extents = field->logical_maximum -\r\nfield->logical_minimum;\r\n__s32 physical_extents = field->physical_maximum -\r\nfield->physical_minimum;\r\n__s32 prev;\r\nif (logical_extents <= 0 || physical_extents <= 0)\r\nreturn 0;\r\nswitch (code) {\r\ncase ABS_X:\r\ncase ABS_Y:\r\ncase ABS_Z:\r\ncase ABS_MT_POSITION_X:\r\ncase ABS_MT_POSITION_Y:\r\ncase ABS_MT_TOOL_X:\r\ncase ABS_MT_TOOL_Y:\r\ncase ABS_MT_TOUCH_MAJOR:\r\ncase ABS_MT_TOUCH_MINOR:\r\nif (field->unit == 0x11) {\r\nunit_exponent += 1;\r\n} else if (field->unit == 0x13) {\r\nprev = physical_extents;\r\nphysical_extents *= 254;\r\nif (physical_extents < prev)\r\nreturn 0;\r\nunit_exponent -= 1;\r\n} else {\r\nreturn 0;\r\n}\r\nbreak;\r\ncase ABS_RX:\r\ncase ABS_RY:\r\ncase ABS_RZ:\r\ncase ABS_TILT_X:\r\ncase ABS_TILT_Y:\r\nif (field->unit == 0x14) {\r\nprev = logical_extents;\r\nlogical_extents *= 573;\r\nif (logical_extents < prev)\r\nreturn 0;\r\nunit_exponent += 1;\r\n} else if (field->unit != 0x12) {\r\nreturn 0;\r\n}\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nfor (; unit_exponent < 0; unit_exponent++) {\r\nprev = logical_extents;\r\nlogical_extents *= 10;\r\nif (logical_extents < prev)\r\nreturn 0;\r\n}\r\nfor (; unit_exponent > 0; unit_exponent--) {\r\nprev = physical_extents;\r\nphysical_extents *= 10;\r\nif (physical_extents < prev)\r\nreturn 0;\r\n}\r\nreturn DIV_ROUND_CLOSEST(logical_extents, physical_extents);\r\n}\r\nstatic unsigned find_battery_quirk(struct hid_device *hdev)\r\n{\r\nunsigned quirks = 0;\r\nconst struct hid_device_id *match;\r\nmatch = hid_match_id(hdev, hid_battery_quirks);\r\nif (match != NULL)\r\nquirks = match->driver_data;\r\nreturn quirks;\r\n}\r\nstatic int hidinput_get_battery_property(struct power_supply *psy,\r\nenum power_supply_property prop,\r\nunion power_supply_propval *val)\r\n{\r\nstruct hid_device *dev = container_of(psy, struct hid_device, battery);\r\nint ret = 0;\r\n__u8 *buf;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = 1;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nbuf = kmalloc(2 * sizeof(__u8), GFP_KERNEL);\r\nif (!buf) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nret = dev->hid_get_raw_report(dev, dev->battery_report_id,\r\nbuf, 2,\r\ndev->battery_report_type);\r\nif (ret != 2) {\r\nret = -ENODATA;\r\nkfree(buf);\r\nbreak;\r\n}\r\nret = 0;\r\nif (dev->battery_min < dev->battery_max &&\r\nbuf[1] >= dev->battery_min &&\r\nbuf[1] <= dev->battery_max)\r\nval->intval = (100 * (buf[1] - dev->battery_min)) /\r\n(dev->battery_max - dev->battery_min);\r\nkfree(buf);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = dev->name;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SCOPE:\r\nval->intval = POWER_SUPPLY_SCOPE_DEVICE;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type, struct hid_field *field)\r\n{\r\nstruct power_supply *battery = &dev->battery;\r\nint ret;\r\nunsigned quirks;\r\ns32 min, max;\r\nif (field->usage->hid != HID_DC_BATTERYSTRENGTH)\r\nreturn false;\r\nif (battery->name != NULL)\r\ngoto out;\r\nbattery->name = kasprintf(GFP_KERNEL, "hid-%s-battery", dev->uniq);\r\nif (battery->name == NULL)\r\ngoto out;\r\nbattery->type = POWER_SUPPLY_TYPE_BATTERY;\r\nbattery->properties = hidinput_battery_props;\r\nbattery->num_properties = ARRAY_SIZE(hidinput_battery_props);\r\nbattery->use_for_apm = 0;\r\nbattery->get_property = hidinput_get_battery_property;\r\nquirks = find_battery_quirk(dev);\r\nhid_dbg(dev, "device %x:%x:%x %d quirks %d\n",\r\ndev->bus, dev->vendor, dev->product, dev->version, quirks);\r\nmin = field->logical_minimum;\r\nmax = field->logical_maximum;\r\nif (quirks & HID_BATTERY_QUIRK_PERCENT) {\r\nmin = 0;\r\nmax = 100;\r\n}\r\nif (quirks & HID_BATTERY_QUIRK_FEATURE)\r\nreport_type = HID_FEATURE_REPORT;\r\ndev->battery_min = min;\r\ndev->battery_max = max;\r\ndev->battery_report_type = report_type;\r\ndev->battery_report_id = field->report->id;\r\nret = power_supply_register(&dev->dev, battery);\r\nif (ret != 0) {\r\nhid_warn(dev, "can't register power supply: %d\n", ret);\r\nkfree(battery->name);\r\nbattery->name = NULL;\r\n}\r\npower_supply_powers(battery, &dev->dev);\r\nout:\r\nreturn true;\r\n}\r\nstatic void hidinput_cleanup_battery(struct hid_device *dev)\r\n{\r\nif (!dev->battery.name)\r\nreturn;\r\npower_supply_unregister(&dev->battery);\r\nkfree(dev->battery.name);\r\ndev->battery.name = NULL;\r\n}\r\nstatic bool hidinput_setup_battery(struct hid_device *dev, unsigned report_type,\r\nstruct hid_field *field)\r\n{\r\nreturn false;\r\n}\r\nstatic void hidinput_cleanup_battery(struct hid_device *dev)\r\n{\r\n}\r\nstatic void hidinput_configure_usage(struct hid_input *hidinput, struct hid_field *field,\r\nstruct hid_usage *usage)\r\n{\r\nstruct input_dev *input = hidinput->input;\r\nstruct hid_device *device = input_get_drvdata(input);\r\nint max = 0, code;\r\nunsigned long *bit = NULL;\r\nfield->hidinput = hidinput;\r\nif (field->flags & HID_MAIN_ITEM_CONSTANT)\r\ngoto ignore;\r\nif (field->report_count < 1)\r\ngoto ignore;\r\nif (field->report_type == HID_OUTPUT_REPORT &&\r\n(usage->hid & HID_USAGE_PAGE) != HID_UP_LED) {\r\ngoto ignore;\r\n}\r\nif (device->driver->input_mapping) {\r\nint ret = device->driver->input_mapping(device, hidinput, field,\r\nusage, &bit, &max);\r\nif (ret > 0)\r\ngoto mapped;\r\nif (ret < 0)\r\ngoto ignore;\r\n}\r\nswitch (usage->hid & HID_USAGE_PAGE) {\r\ncase HID_UP_UNDEFINED:\r\ngoto ignore;\r\ncase HID_UP_KEYBOARD:\r\nset_bit(EV_REP, input->evbit);\r\nif ((usage->hid & HID_USAGE) < 256) {\r\nif (!hid_keyboard[usage->hid & HID_USAGE]) goto ignore;\r\nmap_key_clear(hid_keyboard[usage->hid & HID_USAGE]);\r\n} else\r\nmap_key(KEY_UNKNOWN);\r\nbreak;\r\ncase HID_UP_BUTTON:\r\ncode = ((usage->hid - 1) & HID_USAGE);\r\nswitch (field->application) {\r\ncase HID_GD_MOUSE:\r\ncase HID_GD_POINTER: code += BTN_MOUSE; break;\r\ncase HID_GD_JOYSTICK:\r\nif (code <= 0xf)\r\ncode += BTN_JOYSTICK;\r\nelse\r\ncode += BTN_TRIGGER_HAPPY - 0x10;\r\nbreak;\r\ncase HID_GD_GAMEPAD:\r\nif (code <= 0xf)\r\ncode += BTN_GAMEPAD;\r\nelse\r\ncode += BTN_TRIGGER_HAPPY - 0x10;\r\nbreak;\r\ndefault:\r\nswitch (field->physical) {\r\ncase HID_GD_MOUSE:\r\ncase HID_GD_POINTER: code += BTN_MOUSE; break;\r\ncase HID_GD_JOYSTICK: code += BTN_JOYSTICK; break;\r\ncase HID_GD_GAMEPAD: code += BTN_GAMEPAD; break;\r\ndefault: code += BTN_MISC;\r\n}\r\n}\r\nmap_key(code);\r\nbreak;\r\ncase HID_UP_SIMULATION:\r\nswitch (usage->hid & 0xffff) {\r\ncase 0xba: map_abs(ABS_RUDDER); break;\r\ncase 0xbb: map_abs(ABS_THROTTLE); break;\r\ncase 0xc4: map_abs(ABS_GAS); break;\r\ncase 0xc5: map_abs(ABS_BRAKE); break;\r\ncase 0xc8: map_abs(ABS_WHEEL); break;\r\ndefault: goto ignore;\r\n}\r\nbreak;\r\ncase HID_UP_GENDESK:\r\nif ((usage->hid & 0xf0) == 0x80) {\r\nswitch (usage->hid & 0xf) {\r\ncase 0x1: map_key_clear(KEY_POWER); break;\r\ncase 0x2: map_key_clear(KEY_SLEEP); break;\r\ncase 0x3: map_key_clear(KEY_WAKEUP); break;\r\ncase 0x4: map_key_clear(KEY_CONTEXT_MENU); break;\r\ncase 0x5: map_key_clear(KEY_MENU); break;\r\ncase 0x6: map_key_clear(KEY_PROG1); break;\r\ncase 0x7: map_key_clear(KEY_HELP); break;\r\ncase 0x8: map_key_clear(KEY_EXIT); break;\r\ncase 0x9: map_key_clear(KEY_SELECT); break;\r\ncase 0xa: map_key_clear(KEY_RIGHT); break;\r\ncase 0xb: map_key_clear(KEY_LEFT); break;\r\ncase 0xc: map_key_clear(KEY_UP); break;\r\ncase 0xd: map_key_clear(KEY_DOWN); break;\r\ncase 0xe: map_key_clear(KEY_POWER2); break;\r\ncase 0xf: map_key_clear(KEY_RESTART); break;\r\ndefault: goto unknown;\r\n}\r\nbreak;\r\n}\r\nif ((usage->hid & 0xf0) == 0x90) {\r\nswitch (usage->hid) {\r\ncase HID_GD_UP: usage->hat_dir = 1; break;\r\ncase HID_GD_DOWN: usage->hat_dir = 5; break;\r\ncase HID_GD_RIGHT: usage->hat_dir = 3; break;\r\ncase HID_GD_LEFT: usage->hat_dir = 7; break;\r\ndefault: goto unknown;\r\n}\r\nif (field->dpad) {\r\nmap_abs(field->dpad);\r\ngoto ignore;\r\n}\r\nmap_abs(ABS_HAT0X);\r\nbreak;\r\n}\r\nswitch (usage->hid) {\r\ncase HID_GD_X: case HID_GD_Y: case HID_GD_Z:\r\ncase HID_GD_RX: case HID_GD_RY: case HID_GD_RZ:\r\ncase HID_GD_SLIDER: case HID_GD_DIAL: case HID_GD_WHEEL:\r\nif (field->flags & HID_MAIN_ITEM_RELATIVE)\r\nmap_rel(usage->hid & 0xf);\r\nelse\r\nmap_abs(usage->hid & 0xf);\r\nbreak;\r\ncase HID_GD_HATSWITCH:\r\nusage->hat_min = field->logical_minimum;\r\nusage->hat_max = field->logical_maximum;\r\nmap_abs(ABS_HAT0X);\r\nbreak;\r\ncase HID_GD_START: map_key_clear(BTN_START); break;\r\ncase HID_GD_SELECT: map_key_clear(BTN_SELECT); break;\r\ndefault: goto unknown;\r\n}\r\nbreak;\r\ncase HID_UP_LED:\r\nswitch (usage->hid & 0xffff) {\r\ncase 0x01: map_led (LED_NUML); break;\r\ncase 0x02: map_led (LED_CAPSL); break;\r\ncase 0x03: map_led (LED_SCROLLL); break;\r\ncase 0x04: map_led (LED_COMPOSE); break;\r\ncase 0x05: map_led (LED_KANA); break;\r\ncase 0x27: map_led (LED_SLEEP); break;\r\ncase 0x4c: map_led (LED_SUSPEND); break;\r\ncase 0x09: map_led (LED_MUTE); break;\r\ncase 0x4b: map_led (LED_MISC); break;\r\ncase 0x19: map_led (LED_MAIL); break;\r\ncase 0x4d: map_led (LED_CHARGING); break;\r\ndefault: goto ignore;\r\n}\r\nbreak;\r\ncase HID_UP_DIGITIZER:\r\nswitch (usage->hid & 0xff) {\r\ncase 0x00:\r\ngoto ignore;\r\ncase 0x30:\r\nif (!test_bit(BTN_TOUCH, input->keybit)) {\r\ndevice->quirks |= HID_QUIRK_NOTOUCH;\r\nset_bit(EV_KEY, input->evbit);\r\nset_bit(BTN_TOUCH, input->keybit);\r\n}\r\nmap_abs_clear(ABS_PRESSURE);\r\nbreak;\r\ncase 0x32:\r\nswitch (field->physical & 0xff) {\r\ncase 0x21: map_key(BTN_TOOL_MOUSE); break;\r\ncase 0x22: map_key(BTN_TOOL_FINGER); break;\r\ndefault: map_key(BTN_TOOL_PEN); break;\r\n}\r\nbreak;\r\ncase 0x3c:\r\nmap_key_clear(BTN_TOOL_RUBBER);\r\nbreak;\r\ncase 0x3d:\r\nmap_abs_clear(ABS_TILT_X);\r\nbreak;\r\ncase 0x3e:\r\nmap_abs_clear(ABS_TILT_Y);\r\nbreak;\r\ncase 0x33:\r\ncase 0x42:\r\ncase 0x43:\r\ndevice->quirks &= ~HID_QUIRK_NOTOUCH;\r\nmap_key_clear(BTN_TOUCH);\r\nbreak;\r\ncase 0x44:\r\nmap_key_clear(BTN_STYLUS);\r\nbreak;\r\ncase 0x46:\r\nmap_key_clear(BTN_STYLUS2);\r\nbreak;\r\ndefault: goto unknown;\r\n}\r\nbreak;\r\ncase HID_UP_CONSUMER:\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x000: goto ignore;\r\ncase 0x030: map_key_clear(KEY_POWER); break;\r\ncase 0x031: map_key_clear(KEY_RESTART); break;\r\ncase 0x032: map_key_clear(KEY_SLEEP); break;\r\ncase 0x034: map_key_clear(KEY_SLEEP); break;\r\ncase 0x035: map_key_clear(KEY_KBDILLUMTOGGLE); break;\r\ncase 0x036: map_key_clear(BTN_MISC); break;\r\ncase 0x040: map_key_clear(KEY_MENU); break;\r\ncase 0x041: map_key_clear(KEY_SELECT); break;\r\ncase 0x042: map_key_clear(KEY_UP); break;\r\ncase 0x043: map_key_clear(KEY_DOWN); break;\r\ncase 0x044: map_key_clear(KEY_LEFT); break;\r\ncase 0x045: map_key_clear(KEY_RIGHT); break;\r\ncase 0x046: map_key_clear(KEY_ESC); break;\r\ncase 0x047: map_key_clear(KEY_KPPLUS); break;\r\ncase 0x048: map_key_clear(KEY_KPMINUS); break;\r\ncase 0x060: map_key_clear(KEY_INFO); break;\r\ncase 0x061: map_key_clear(KEY_SUBTITLE); break;\r\ncase 0x063: map_key_clear(KEY_VCR); break;\r\ncase 0x065: map_key_clear(KEY_CAMERA); break;\r\ncase 0x069: map_key_clear(KEY_RED); break;\r\ncase 0x06a: map_key_clear(KEY_GREEN); break;\r\ncase 0x06b: map_key_clear(KEY_BLUE); break;\r\ncase 0x06c: map_key_clear(KEY_YELLOW); break;\r\ncase 0x06d: map_key_clear(KEY_ZOOM); break;\r\ncase 0x082: map_key_clear(KEY_VIDEO_NEXT); break;\r\ncase 0x083: map_key_clear(KEY_LAST); break;\r\ncase 0x084: map_key_clear(KEY_ENTER); break;\r\ncase 0x088: map_key_clear(KEY_PC); break;\r\ncase 0x089: map_key_clear(KEY_TV); break;\r\ncase 0x08a: map_key_clear(KEY_WWW); break;\r\ncase 0x08b: map_key_clear(KEY_DVD); break;\r\ncase 0x08c: map_key_clear(KEY_PHONE); break;\r\ncase 0x08d: map_key_clear(KEY_PROGRAM); break;\r\ncase 0x08e: map_key_clear(KEY_VIDEOPHONE); break;\r\ncase 0x08f: map_key_clear(KEY_GAMES); break;\r\ncase 0x090: map_key_clear(KEY_MEMO); break;\r\ncase 0x091: map_key_clear(KEY_CD); break;\r\ncase 0x092: map_key_clear(KEY_VCR); break;\r\ncase 0x093: map_key_clear(KEY_TUNER); break;\r\ncase 0x094: map_key_clear(KEY_EXIT); break;\r\ncase 0x095: map_key_clear(KEY_HELP); break;\r\ncase 0x096: map_key_clear(KEY_TAPE); break;\r\ncase 0x097: map_key_clear(KEY_TV2); break;\r\ncase 0x098: map_key_clear(KEY_SAT); break;\r\ncase 0x09a: map_key_clear(KEY_PVR); break;\r\ncase 0x09c: map_key_clear(KEY_CHANNELUP); break;\r\ncase 0x09d: map_key_clear(KEY_CHANNELDOWN); break;\r\ncase 0x0a0: map_key_clear(KEY_VCR2); break;\r\ncase 0x0b0: map_key_clear(KEY_PLAY); break;\r\ncase 0x0b1: map_key_clear(KEY_PAUSE); break;\r\ncase 0x0b2: map_key_clear(KEY_RECORD); break;\r\ncase 0x0b3: map_key_clear(KEY_FASTFORWARD); break;\r\ncase 0x0b4: map_key_clear(KEY_REWIND); break;\r\ncase 0x0b5: map_key_clear(KEY_NEXTSONG); break;\r\ncase 0x0b6: map_key_clear(KEY_PREVIOUSSONG); break;\r\ncase 0x0b7: map_key_clear(KEY_STOPCD); break;\r\ncase 0x0b8: map_key_clear(KEY_EJECTCD); break;\r\ncase 0x0bc: map_key_clear(KEY_MEDIA_REPEAT); break;\r\ncase 0x0b9: map_key_clear(KEY_SHUFFLE); break;\r\ncase 0x0bf: map_key_clear(KEY_SLOW); break;\r\ncase 0x0cd: map_key_clear(KEY_PLAYPAUSE); break;\r\ncase 0x0e0: map_abs_clear(ABS_VOLUME); break;\r\ncase 0x0e2: map_key_clear(KEY_MUTE); break;\r\ncase 0x0e5: map_key_clear(KEY_BASSBOOST); break;\r\ncase 0x0e9: map_key_clear(KEY_VOLUMEUP); break;\r\ncase 0x0ea: map_key_clear(KEY_VOLUMEDOWN); break;\r\ncase 0x0f5: map_key_clear(KEY_SLOW); break;\r\ncase 0x182: map_key_clear(KEY_BOOKMARKS); break;\r\ncase 0x183: map_key_clear(KEY_CONFIG); break;\r\ncase 0x184: map_key_clear(KEY_WORDPROCESSOR); break;\r\ncase 0x185: map_key_clear(KEY_EDITOR); break;\r\ncase 0x186: map_key_clear(KEY_SPREADSHEET); break;\r\ncase 0x187: map_key_clear(KEY_GRAPHICSEDITOR); break;\r\ncase 0x188: map_key_clear(KEY_PRESENTATION); break;\r\ncase 0x189: map_key_clear(KEY_DATABASE); break;\r\ncase 0x18a: map_key_clear(KEY_MAIL); break;\r\ncase 0x18b: map_key_clear(KEY_NEWS); break;\r\ncase 0x18c: map_key_clear(KEY_VOICEMAIL); break;\r\ncase 0x18d: map_key_clear(KEY_ADDRESSBOOK); break;\r\ncase 0x18e: map_key_clear(KEY_CALENDAR); break;\r\ncase 0x191: map_key_clear(KEY_FINANCE); break;\r\ncase 0x192: map_key_clear(KEY_CALC); break;\r\ncase 0x193: map_key_clear(KEY_PLAYER); break;\r\ncase 0x194: map_key_clear(KEY_FILE); break;\r\ncase 0x196: map_key_clear(KEY_WWW); break;\r\ncase 0x199: map_key_clear(KEY_CHAT); break;\r\ncase 0x19c: map_key_clear(KEY_LOGOFF); break;\r\ncase 0x19e: map_key_clear(KEY_COFFEE); break;\r\ncase 0x1a6: map_key_clear(KEY_HELP); break;\r\ncase 0x1a7: map_key_clear(KEY_DOCUMENTS); break;\r\ncase 0x1ab: map_key_clear(KEY_SPELLCHECK); break;\r\ncase 0x1ae: map_key_clear(KEY_KEYBOARD); break;\r\ncase 0x1b6: map_key_clear(KEY_IMAGES); break;\r\ncase 0x1b7: map_key_clear(KEY_AUDIO); break;\r\ncase 0x1b8: map_key_clear(KEY_VIDEO); break;\r\ncase 0x1bc: map_key_clear(KEY_MESSENGER); break;\r\ncase 0x1bd: map_key_clear(KEY_INFO); break;\r\ncase 0x201: map_key_clear(KEY_NEW); break;\r\ncase 0x202: map_key_clear(KEY_OPEN); break;\r\ncase 0x203: map_key_clear(KEY_CLOSE); break;\r\ncase 0x204: map_key_clear(KEY_EXIT); break;\r\ncase 0x207: map_key_clear(KEY_SAVE); break;\r\ncase 0x208: map_key_clear(KEY_PRINT); break;\r\ncase 0x209: map_key_clear(KEY_PROPS); break;\r\ncase 0x21a: map_key_clear(KEY_UNDO); break;\r\ncase 0x21b: map_key_clear(KEY_COPY); break;\r\ncase 0x21c: map_key_clear(KEY_CUT); break;\r\ncase 0x21d: map_key_clear(KEY_PASTE); break;\r\ncase 0x21f: map_key_clear(KEY_FIND); break;\r\ncase 0x221: map_key_clear(KEY_SEARCH); break;\r\ncase 0x222: map_key_clear(KEY_GOTO); break;\r\ncase 0x223: map_key_clear(KEY_HOMEPAGE); break;\r\ncase 0x224: map_key_clear(KEY_BACK); break;\r\ncase 0x225: map_key_clear(KEY_FORWARD); break;\r\ncase 0x226: map_key_clear(KEY_STOP); break;\r\ncase 0x227: map_key_clear(KEY_REFRESH); break;\r\ncase 0x22a: map_key_clear(KEY_BOOKMARKS); break;\r\ncase 0x22d: map_key_clear(KEY_ZOOMIN); break;\r\ncase 0x22e: map_key_clear(KEY_ZOOMOUT); break;\r\ncase 0x22f: map_key_clear(KEY_ZOOMRESET); break;\r\ncase 0x233: map_key_clear(KEY_SCROLLUP); break;\r\ncase 0x234: map_key_clear(KEY_SCROLLDOWN); break;\r\ncase 0x238: map_rel(REL_HWHEEL); break;\r\ncase 0x23d: map_key_clear(KEY_EDIT); break;\r\ncase 0x25f: map_key_clear(KEY_CANCEL); break;\r\ncase 0x269: map_key_clear(KEY_INSERT); break;\r\ncase 0x26a: map_key_clear(KEY_DELETE); break;\r\ncase 0x279: map_key_clear(KEY_REDO); break;\r\ncase 0x289: map_key_clear(KEY_REPLY); break;\r\ncase 0x28b: map_key_clear(KEY_FORWARDMAIL); break;\r\ncase 0x28c: map_key_clear(KEY_SEND); break;\r\ndefault: goto ignore;\r\n}\r\nbreak;\r\ncase HID_UP_GENDEVCTRLS:\r\nif (hidinput_setup_battery(device, HID_INPUT_REPORT, field))\r\ngoto ignore;\r\nelse\r\ngoto unknown;\r\nbreak;\r\ncase HID_UP_HPVENDOR:\r\nset_bit(EV_REP, input->evbit);\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x021: map_key_clear(KEY_PRINT); break;\r\ncase 0x070: map_key_clear(KEY_HP); break;\r\ncase 0x071: map_key_clear(KEY_CAMERA); break;\r\ncase 0x072: map_key_clear(KEY_SOUND); break;\r\ncase 0x073: map_key_clear(KEY_QUESTION); break;\r\ncase 0x080: map_key_clear(KEY_EMAIL); break;\r\ncase 0x081: map_key_clear(KEY_CHAT); break;\r\ncase 0x082: map_key_clear(KEY_SEARCH); break;\r\ncase 0x083: map_key_clear(KEY_CONNECT); break;\r\ncase 0x084: map_key_clear(KEY_FINANCE); break;\r\ncase 0x085: map_key_clear(KEY_SPORT); break;\r\ncase 0x086: map_key_clear(KEY_SHOP); break;\r\ndefault: goto ignore;\r\n}\r\nbreak;\r\ncase HID_UP_HPVENDOR2:\r\nset_bit(EV_REP, input->evbit);\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0x003: map_key_clear(KEY_BRIGHTNESSDOWN); break;\r\ncase 0x004: map_key_clear(KEY_BRIGHTNESSUP); break;\r\ndefault: goto ignore;\r\n}\r\nbreak;\r\ncase HID_UP_MSVENDOR:\r\ngoto ignore;\r\ncase HID_UP_CUSTOM:\r\nset_bit(EV_REP, input->evbit);\r\ngoto ignore;\r\ncase HID_UP_LOGIVENDOR:\r\ngoto ignore;\r\ncase HID_UP_PID:\r\nswitch (usage->hid & HID_USAGE) {\r\ncase 0xa4: map_key_clear(BTN_DEAD); break;\r\ndefault: goto ignore;\r\n}\r\nbreak;\r\ndefault:\r\nunknown:\r\nif (field->report_size == 1) {\r\nif (field->report->type == HID_OUTPUT_REPORT) {\r\nmap_led(LED_MISC);\r\nbreak;\r\n}\r\nmap_key(BTN_MISC);\r\nbreak;\r\n}\r\nif (field->flags & HID_MAIN_ITEM_RELATIVE) {\r\nmap_rel(REL_MISC);\r\nbreak;\r\n}\r\nmap_abs(ABS_MISC);\r\nbreak;\r\n}\r\nmapped:\r\nif (device->driver->input_mapped && device->driver->input_mapped(device,\r\nhidinput, field, usage, &bit, &max) < 0)\r\ngoto ignore;\r\nset_bit(usage->type, input->evbit);\r\nwhile (usage->code <= max && test_and_set_bit(usage->code, bit))\r\nusage->code = find_next_zero_bit(bit, max + 1, usage->code);\r\nif (usage->code > max)\r\ngoto ignore;\r\nif (usage->type == EV_ABS) {\r\nint a = field->logical_minimum;\r\nint b = field->logical_maximum;\r\nif ((device->quirks & HID_QUIRK_BADPAD) && (usage->code == ABS_X || usage->code == ABS_Y)) {\r\na = field->logical_minimum = 0;\r\nb = field->logical_maximum = 255;\r\n}\r\nif (field->application == HID_GD_GAMEPAD || field->application == HID_GD_JOYSTICK)\r\ninput_set_abs_params(input, usage->code, a, b, (b - a) >> 8, (b - a) >> 4);\r\nelse input_set_abs_params(input, usage->code, a, b, 0, 0);\r\ninput_abs_set_res(input, usage->code,\r\nhidinput_calc_abs_res(field, usage->code));\r\nif (usage->code == ABS_MT_POSITION_X && input->hint_events_per_packet == 0)\r\ninput_set_events_per_packet(input, 60);\r\n}\r\nif (usage->type == EV_ABS &&\r\n(usage->hat_min < usage->hat_max || usage->hat_dir)) {\r\nint i;\r\nfor (i = usage->code; i < usage->code + 2 && i <= max; i++) {\r\ninput_set_abs_params(input, i, -1, 1, 0, 0);\r\nset_bit(i, input->absbit);\r\n}\r\nif (usage->hat_dir && !field->dpad)\r\nfield->dpad = usage->code;\r\n}\r\nif ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&\r\n(usage->code == ABS_VOLUME)) {\r\nset_bit(KEY_VOLUMEUP, input->keybit);\r\nset_bit(KEY_VOLUMEDOWN, input->keybit);\r\n}\r\nif (usage->type == EV_KEY) {\r\nset_bit(EV_MSC, input->evbit);\r\nset_bit(MSC_SCAN, input->mscbit);\r\n}\r\nignore:\r\nreturn;\r\n}\r\nvoid hidinput_hid_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value)\r\n{\r\nstruct input_dev *input;\r\nunsigned *quirks = &hid->quirks;\r\nif (!field->hidinput)\r\nreturn;\r\ninput = field->hidinput->input;\r\nif (!usage->type)\r\nreturn;\r\nif (usage->hat_min < usage->hat_max || usage->hat_dir) {\r\nint hat_dir = usage->hat_dir;\r\nif (!hat_dir)\r\nhat_dir = (value - usage->hat_min) * 8 / (usage->hat_max - usage->hat_min + 1) + 1;\r\nif (hat_dir < 0 || hat_dir > 8) hat_dir = 0;\r\ninput_event(input, usage->type, usage->code , hid_hat_to_axis[hat_dir].x);\r\ninput_event(input, usage->type, usage->code + 1, hid_hat_to_axis[hat_dir].y);\r\nreturn;\r\n}\r\nif (usage->hid == (HID_UP_DIGITIZER | 0x003c)) {\r\n*quirks = value ? (*quirks | HID_QUIRK_INVERT) : (*quirks & ~HID_QUIRK_INVERT);\r\nreturn;\r\n}\r\nif (usage->hid == (HID_UP_DIGITIZER | 0x0032)) {\r\nif (value) {\r\ninput_event(input, usage->type, (*quirks & HID_QUIRK_INVERT) ? BTN_TOOL_RUBBER : usage->code, 1);\r\nreturn;\r\n}\r\ninput_event(input, usage->type, usage->code, 0);\r\ninput_event(input, usage->type, BTN_TOOL_RUBBER, 0);\r\nreturn;\r\n}\r\nif (usage->hid == (HID_UP_DIGITIZER | 0x0030) && (*quirks & HID_QUIRK_NOTOUCH)) {\r\nint a = field->logical_minimum;\r\nint b = field->logical_maximum;\r\ninput_event(input, EV_KEY, BTN_TOUCH, value > a + ((b - a) >> 3));\r\n}\r\nif (usage->hid == (HID_UP_PID | 0x83UL)) {\r\ndbg_hid("Maximum Effects - %d\n",value);\r\nreturn;\r\n}\r\nif (usage->hid == (HID_UP_PID | 0x7fUL)) {\r\ndbg_hid("PID Pool Report\n");\r\nreturn;\r\n}\r\nif ((usage->type == EV_KEY) && (usage->code == 0))\r\nreturn;\r\nif ((usage->type == EV_ABS) && (field->flags & HID_MAIN_ITEM_RELATIVE) &&\r\n(usage->code == ABS_VOLUME)) {\r\nint count = abs(value);\r\nint direction = value > 0 ? KEY_VOLUMEUP : KEY_VOLUMEDOWN;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\ninput_event(input, EV_KEY, direction, 1);\r\ninput_sync(input);\r\ninput_event(input, EV_KEY, direction, 0);\r\ninput_sync(input);\r\n}\r\nreturn;\r\n}\r\nif ((field->flags & HID_MAIN_ITEM_VARIABLE) &&\r\n(field->logical_minimum < field->logical_maximum) &&\r\n(value < field->logical_minimum ||\r\nvalue > field->logical_maximum)) {\r\ndbg_hid("Ignoring out-of-range value %x\n", value);\r\nreturn;\r\n}\r\nif (usage->type == EV_KEY && !!test_bit(usage->code, input->key) != value)\r\ninput_event(input, EV_MSC, MSC_SCAN, usage->hid);\r\ninput_event(input, usage->type, usage->code, value);\r\nif ((field->flags & HID_MAIN_ITEM_RELATIVE) && (usage->type == EV_KEY))\r\ninput_event(input, usage->type, usage->code, 0);\r\n}\r\nvoid hidinput_report_event(struct hid_device *hid, struct hid_report *report)\r\n{\r\nstruct hid_input *hidinput;\r\nif (hid->quirks & HID_QUIRK_NO_INPUT_SYNC)\r\nreturn;\r\nlist_for_each_entry(hidinput, &hid->inputs, list)\r\ninput_sync(hidinput->input);\r\n}\r\nint hidinput_find_field(struct hid_device *hid, unsigned int type, unsigned int code, struct hid_field **field)\r\n{\r\nstruct hid_report *report;\r\nint i, j;\r\nlist_for_each_entry(report, &hid->report_enum[HID_OUTPUT_REPORT].report_list, list) {\r\nfor (i = 0; i < report->maxfield; i++) {\r\n*field = report->field[i];\r\nfor (j = 0; j < (*field)->maxusage; j++)\r\nif ((*field)->usage[j].type == type && (*field)->usage[j].code == code)\r\nreturn j;\r\n}\r\n}\r\nreturn -1;\r\n}\r\nstruct hid_field *hidinput_get_led_field(struct hid_device *hid)\r\n{\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nint i, j;\r\nlist_for_each_entry(report,\r\n&hid->report_enum[HID_OUTPUT_REPORT].report_list,\r\nlist) {\r\nfor (i = 0; i < report->maxfield; i++) {\r\nfield = report->field[i];\r\nfor (j = 0; j < field->maxusage; j++)\r\nif (field->usage[j].type == EV_LED)\r\nreturn field;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nunsigned int hidinput_count_leds(struct hid_device *hid)\r\n{\r\nstruct hid_report *report;\r\nstruct hid_field *field;\r\nint i, j;\r\nunsigned int count = 0;\r\nlist_for_each_entry(report,\r\n&hid->report_enum[HID_OUTPUT_REPORT].report_list,\r\nlist) {\r\nfor (i = 0; i < report->maxfield; i++) {\r\nfield = report->field[i];\r\nfor (j = 0; j < field->maxusage; j++)\r\nif (field->usage[j].type == EV_LED &&\r\nfield->value[j])\r\ncount += 1;\r\n}\r\n}\r\nreturn count;\r\n}\r\nstatic void hidinput_led_worker(struct work_struct *work)\r\n{\r\nstruct hid_device *hid = container_of(work, struct hid_device,\r\nled_work);\r\nstruct hid_field *field;\r\nstruct hid_report *report;\r\nint len;\r\n__u8 *buf;\r\nfield = hidinput_get_led_field(hid);\r\nif (!field)\r\nreturn;\r\nreport = field->report;\r\nif (hid->ll_driver->request)\r\nreturn hid->ll_driver->request(hid, report, HID_REQ_SET_REPORT);\r\nlen = ((report->size - 1) >> 3) + 1 + (report->id > 0);\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn;\r\nhid_output_report(report, buf);\r\nhid->hid_output_raw_report(hid, buf, len, HID_OUTPUT_REPORT);\r\nkfree(buf);\r\n}\r\nstatic int hidinput_input_event(struct input_dev *dev, unsigned int type,\r\nunsigned int code, int value)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nstruct hid_field *field;\r\nint offset;\r\nif (type == EV_FF)\r\nreturn input_ff_event(dev, type, code, value);\r\nif (type != EV_LED)\r\nreturn -1;\r\nif ((offset = hidinput_find_field(hid, type, code, &field)) == -1) {\r\nhid_warn(dev, "event field not found\n");\r\nreturn -1;\r\n}\r\nhid_set_field(field, offset, value);\r\nschedule_work(&hid->led_work);\r\nreturn 0;\r\n}\r\nstatic int hidinput_open(struct input_dev *dev)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nreturn hid_hw_open(hid);\r\n}\r\nstatic void hidinput_close(struct input_dev *dev)\r\n{\r\nstruct hid_device *hid = input_get_drvdata(dev);\r\nhid_hw_close(hid);\r\n}\r\nstatic void report_features(struct hid_device *hid)\r\n{\r\nstruct hid_driver *drv = hid->driver;\r\nstruct hid_report_enum *rep_enum;\r\nstruct hid_report *rep;\r\nint i, j;\r\nrep_enum = &hid->report_enum[HID_FEATURE_REPORT];\r\nlist_for_each_entry(rep, &rep_enum->report_list, list)\r\nfor (i = 0; i < rep->maxfield; i++) {\r\nif (rep->field[i]->report_count < 1)\r\ncontinue;\r\nfor (j = 0; j < rep->field[i]->maxusage; j++) {\r\nhidinput_setup_battery(hid, HID_FEATURE_REPORT, rep->field[i]);\r\nif (drv->feature_mapping)\r\ndrv->feature_mapping(hid, rep->field[i],\r\nrep->field[i]->usage + j);\r\n}\r\n}\r\n}\r\nstatic struct hid_input *hidinput_allocate(struct hid_device *hid)\r\n{\r\nstruct hid_input *hidinput = kzalloc(sizeof(*hidinput), GFP_KERNEL);\r\nstruct input_dev *input_dev = input_allocate_device();\r\nif (!hidinput || !input_dev) {\r\nkfree(hidinput);\r\ninput_free_device(input_dev);\r\nhid_err(hid, "Out of memory during hid input probe\n");\r\nreturn NULL;\r\n}\r\ninput_set_drvdata(input_dev, hid);\r\nif (hid->ll_driver->hidinput_input_event)\r\ninput_dev->event = hid->ll_driver->hidinput_input_event;\r\nelse if (hid->ll_driver->request || hid->hid_output_raw_report)\r\ninput_dev->event = hidinput_input_event;\r\ninput_dev->open = hidinput_open;\r\ninput_dev->close = hidinput_close;\r\ninput_dev->setkeycode = hidinput_setkeycode;\r\ninput_dev->getkeycode = hidinput_getkeycode;\r\ninput_dev->name = hid->name;\r\ninput_dev->phys = hid->phys;\r\ninput_dev->uniq = hid->uniq;\r\ninput_dev->id.bustype = hid->bus;\r\ninput_dev->id.vendor = hid->vendor;\r\ninput_dev->id.product = hid->product;\r\ninput_dev->id.version = hid->version;\r\ninput_dev->dev.parent = hid->dev.parent;\r\nhidinput->input = input_dev;\r\nlist_add_tail(&hidinput->list, &hid->inputs);\r\nreturn hidinput;\r\n}\r\nstatic bool hidinput_has_been_populated(struct hid_input *hidinput)\r\n{\r\nint i;\r\nunsigned long r = 0;\r\nfor (i = 0; i < BITS_TO_LONGS(EV_CNT); i++)\r\nr |= hidinput->input->evbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(KEY_CNT); i++)\r\nr |= hidinput->input->keybit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(REL_CNT); i++)\r\nr |= hidinput->input->relbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(ABS_CNT); i++)\r\nr |= hidinput->input->absbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(MSC_CNT); i++)\r\nr |= hidinput->input->mscbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(LED_CNT); i++)\r\nr |= hidinput->input->ledbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(SND_CNT); i++)\r\nr |= hidinput->input->sndbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(FF_CNT); i++)\r\nr |= hidinput->input->ffbit[i];\r\nfor (i = 0; i < BITS_TO_LONGS(SW_CNT); i++)\r\nr |= hidinput->input->swbit[i];\r\nreturn !!r;\r\n}\r\nstatic void hidinput_cleanup_hidinput(struct hid_device *hid,\r\nstruct hid_input *hidinput)\r\n{\r\nstruct hid_report *report;\r\nint i, k;\r\nlist_del(&hidinput->list);\r\ninput_free_device(hidinput->input);\r\nfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\r\nif (k == HID_OUTPUT_REPORT &&\r\nhid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)\r\ncontinue;\r\nlist_for_each_entry(report, &hid->report_enum[k].report_list,\r\nlist) {\r\nfor (i = 0; i < report->maxfield; i++)\r\nif (report->field[i]->hidinput == hidinput)\r\nreport->field[i]->hidinput = NULL;\r\n}\r\n}\r\nkfree(hidinput);\r\n}\r\nint hidinput_connect(struct hid_device *hid, unsigned int force)\r\n{\r\nstruct hid_driver *drv = hid->driver;\r\nstruct hid_report *report;\r\nstruct hid_input *hidinput = NULL;\r\nint i, j, k;\r\nINIT_LIST_HEAD(&hid->inputs);\r\nINIT_WORK(&hid->led_work, hidinput_led_worker);\r\nif (!force) {\r\nfor (i = 0; i < hid->maxcollection; i++) {\r\nstruct hid_collection *col = &hid->collection[i];\r\nif (col->type == HID_COLLECTION_APPLICATION ||\r\ncol->type == HID_COLLECTION_PHYSICAL)\r\nif (IS_INPUT_APPLICATION(col->usage))\r\nbreak;\r\n}\r\nif (i == hid->maxcollection)\r\nreturn -1;\r\n}\r\nreport_features(hid);\r\nfor (k = HID_INPUT_REPORT; k <= HID_OUTPUT_REPORT; k++) {\r\nif (k == HID_OUTPUT_REPORT &&\r\nhid->quirks & HID_QUIRK_SKIP_OUTPUT_REPORTS)\r\ncontinue;\r\nlist_for_each_entry(report, &hid->report_enum[k].report_list, list) {\r\nif (!report->maxfield)\r\ncontinue;\r\nif (!hidinput) {\r\nhidinput = hidinput_allocate(hid);\r\nif (!hidinput)\r\ngoto out_unwind;\r\n}\r\nfor (i = 0; i < report->maxfield; i++)\r\nfor (j = 0; j < report->field[i]->maxusage; j++)\r\nhidinput_configure_usage(hidinput, report->field[i],\r\nreport->field[i]->usage + j);\r\nif ((hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&\r\n!hidinput_has_been_populated(hidinput))\r\ncontinue;\r\nif (hid->quirks & HID_QUIRK_MULTI_INPUT) {\r\nhidinput->report = report;\r\nif (drv->input_configured)\r\ndrv->input_configured(hid, hidinput);\r\nif (input_register_device(hidinput->input))\r\ngoto out_cleanup;\r\nhidinput = NULL;\r\n}\r\n}\r\n}\r\nif (hidinput && (hid->quirks & HID_QUIRK_NO_EMPTY_INPUT) &&\r\n!hidinput_has_been_populated(hidinput)) {\r\nhidinput_cleanup_hidinput(hid, hidinput);\r\nhidinput = NULL;\r\n}\r\nif (list_empty(&hid->inputs)) {\r\nhid_err(hid, "No inputs registered, leaving\n");\r\ngoto out_unwind;\r\n}\r\nif (hidinput) {\r\nif (drv->input_configured)\r\ndrv->input_configured(hid, hidinput);\r\nif (input_register_device(hidinput->input))\r\ngoto out_cleanup;\r\n}\r\nreturn 0;\r\nout_cleanup:\r\nlist_del(&hidinput->list);\r\ninput_free_device(hidinput->input);\r\nkfree(hidinput);\r\nout_unwind:\r\nhidinput_disconnect(hid);\r\nreturn -1;\r\n}\r\nvoid hidinput_disconnect(struct hid_device *hid)\r\n{\r\nstruct hid_input *hidinput, *next;\r\nhidinput_cleanup_battery(hid);\r\nlist_for_each_entry_safe(hidinput, next, &hid->inputs, list) {\r\nlist_del(&hidinput->list);\r\ninput_unregister_device(hidinput->input);\r\nkfree(hidinput);\r\n}\r\ncancel_work_sync(&hid->led_work);\r\n}
