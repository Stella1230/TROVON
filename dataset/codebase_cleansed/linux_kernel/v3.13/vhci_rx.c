struct urb *pickup_urb_and_free_priv(struct vhci_device *vdev, __u32 seqnum)\r\n{\r\nstruct vhci_priv *priv, *tmp;\r\nstruct urb *urb = NULL;\r\nint status;\r\nlist_for_each_entry_safe(priv, tmp, &vdev->priv_rx, list) {\r\nif (priv->seqnum != seqnum)\r\ncontinue;\r\nurb = priv->urb;\r\nstatus = urb->status;\r\nusbip_dbg_vhci_rx("find urb %p vurb %p seqnum %u\n",\r\nurb, priv, seqnum);\r\nswitch (status) {\r\ncase -ENOENT:\r\ncase -ECONNRESET:\r\ndev_info(&urb->dev->dev,\r\n"urb %p was unlinked %ssynchronuously.\n", urb,\r\nstatus == -ENOENT ? "" : "a");\r\nbreak;\r\ncase -EINPROGRESS:\r\nbreak;\r\ndefault:\r\ndev_info(&urb->dev->dev,\r\n"urb %p may be in a error, status %d\n", urb,\r\nstatus);\r\n}\r\nlist_del(&priv->list);\r\nkfree(priv);\r\nurb->hcpriv = NULL;\r\nbreak;\r\n}\r\nreturn urb;\r\n}\r\nstatic void vhci_recv_ret_submit(struct vhci_device *vdev,\r\nstruct usbip_header *pdu)\r\n{\r\nstruct usbip_device *ud = &vdev->ud;\r\nstruct urb *urb;\r\nspin_lock(&vdev->priv_lock);\r\nurb = pickup_urb_and_free_priv(vdev, pdu->base.seqnum);\r\nspin_unlock(&vdev->priv_lock);\r\nif (!urb) {\r\npr_err("cannot find a urb of seqnum %u\n", pdu->base.seqnum);\r\npr_info("max seqnum %d\n",\r\natomic_read(&the_controller->seqnum));\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn;\r\n}\r\nusbip_pack_pdu(pdu, urb, USBIP_RET_SUBMIT, 0);\r\nif (usbip_recv_xbuff(ud, urb) < 0)\r\nreturn;\r\nif (usbip_recv_iso(ud, urb) < 0)\r\nreturn;\r\nusbip_pad_iso(ud, urb);\r\nif (usbip_dbg_flag_vhci_rx)\r\nusbip_dump_urb(urb);\r\nusbip_dbg_vhci_rx("now giveback urb %p\n", urb);\r\nspin_lock(&the_controller->lock);\r\nusb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);\r\nspin_unlock(&the_controller->lock);\r\nusb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb, urb->status);\r\nusbip_dbg_vhci_rx("Leave\n");\r\nreturn;\r\n}\r\nstatic struct vhci_unlink *dequeue_pending_unlink(struct vhci_device *vdev,\r\nstruct usbip_header *pdu)\r\n{\r\nstruct vhci_unlink *unlink, *tmp;\r\nspin_lock(&vdev->priv_lock);\r\nlist_for_each_entry_safe(unlink, tmp, &vdev->unlink_rx, list) {\r\npr_info("unlink->seqnum %lu\n", unlink->seqnum);\r\nif (unlink->seqnum == pdu->base.seqnum) {\r\nusbip_dbg_vhci_rx("found pending unlink, %lu\n",\r\nunlink->seqnum);\r\nlist_del(&unlink->list);\r\nspin_unlock(&vdev->priv_lock);\r\nreturn unlink;\r\n}\r\n}\r\nspin_unlock(&vdev->priv_lock);\r\nreturn NULL;\r\n}\r\nstatic void vhci_recv_ret_unlink(struct vhci_device *vdev,\r\nstruct usbip_header *pdu)\r\n{\r\nstruct vhci_unlink *unlink;\r\nstruct urb *urb;\r\nusbip_dump_header(pdu);\r\nunlink = dequeue_pending_unlink(vdev, pdu);\r\nif (!unlink) {\r\npr_info("cannot find the pending unlink %u\n",\r\npdu->base.seqnum);\r\nreturn;\r\n}\r\nspin_lock(&vdev->priv_lock);\r\nurb = pickup_urb_and_free_priv(vdev, unlink->unlink_seqnum);\r\nspin_unlock(&vdev->priv_lock);\r\nif (!urb) {\r\npr_info("the urb (seqnum %d) was already given back\n",\r\npdu->base.seqnum);\r\n} else {\r\nusbip_dbg_vhci_rx("now giveback urb %p\n", urb);\r\nurb->status = pdu->u.ret_unlink.status;\r\npr_info("urb->status %d\n", urb->status);\r\nspin_lock(&the_controller->lock);\r\nusb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);\r\nspin_unlock(&the_controller->lock);\r\nusb_hcd_giveback_urb(vhci_to_hcd(the_controller), urb,\r\nurb->status);\r\n}\r\nkfree(unlink);\r\n}\r\nstatic int vhci_priv_tx_empty(struct vhci_device *vdev)\r\n{\r\nint empty = 0;\r\nspin_lock(&vdev->priv_lock);\r\nempty = list_empty(&vdev->priv_rx);\r\nspin_unlock(&vdev->priv_lock);\r\nreturn empty;\r\n}\r\nstatic void vhci_rx_pdu(struct usbip_device *ud)\r\n{\r\nint ret;\r\nstruct usbip_header pdu;\r\nstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\r\nusbip_dbg_vhci_rx("Enter\n");\r\nmemset(&pdu, 0, sizeof(pdu));\r\nret = usbip_recv(ud->tcp_socket, &pdu, sizeof(pdu));\r\nif (ret < 0) {\r\nif (ret == -ECONNRESET)\r\npr_info("connection reset by peer\n");\r\nelse if (ret == -EAGAIN) {\r\nif (vhci_priv_tx_empty(vdev))\r\nreturn;\r\npr_info("connection timed out with pending urbs\n");\r\n} else if (ret != -ERESTARTSYS)\r\npr_info("xmit failed %d\n", ret);\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn;\r\n}\r\nif (ret == 0) {\r\npr_info("connection closed");\r\nusbip_event_add(ud, VDEV_EVENT_DOWN);\r\nreturn;\r\n}\r\nif (ret != sizeof(pdu)) {\r\npr_err("received pdu size is %d, should be %d\n", ret,\r\n(unsigned int)sizeof(pdu));\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nreturn;\r\n}\r\nusbip_header_correct_endian(&pdu, 0);\r\nif (usbip_dbg_flag_vhci_rx)\r\nusbip_dump_header(&pdu);\r\nswitch (pdu.base.command) {\r\ncase USBIP_RET_SUBMIT:\r\nvhci_recv_ret_submit(vdev, &pdu);\r\nbreak;\r\ncase USBIP_RET_UNLINK:\r\nvhci_recv_ret_unlink(vdev, &pdu);\r\nbreak;\r\ndefault:\r\npr_err("unknown pdu %u\n", pdu.base.command);\r\nusbip_dump_header(&pdu);\r\nusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\r\nbreak;\r\n}\r\n}\r\nint vhci_rx_loop(void *data)\r\n{\r\nstruct usbip_device *ud = data;\r\nwhile (!kthread_should_stop()) {\r\nif (usbip_event_happened(ud))\r\nbreak;\r\nvhci_rx_pdu(ud);\r\n}\r\nreturn 0;\r\n}
