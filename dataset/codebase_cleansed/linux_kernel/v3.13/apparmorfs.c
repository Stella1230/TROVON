static int mangle_name(char *name, char *target)\r\n{\r\nchar *t = target;\r\nwhile (*name == '/' || *name == '.')\r\nname++;\r\nif (target) {\r\nfor (; *name; name++) {\r\nif (*name == '/')\r\n*(t)++ = '.';\r\nelse if (isspace(*name))\r\n*(t)++ = '_';\r\nelse if (isalnum(*name) || strchr("._-", *name))\r\n*(t)++ = *name;\r\n}\r\n*t = 0;\r\n} else {\r\nint len = 0;\r\nfor (; *name; name++) {\r\nif (isalnum(*name) || isspace(*name) ||\r\nstrchr("/._-", *name))\r\nlen++;\r\n}\r\nreturn len;\r\n}\r\nreturn t - target;\r\n}\r\nstatic char *aa_simple_write_to_buffer(int op, const char __user *userbuf,\r\nsize_t alloc_size, size_t copy_size,\r\nloff_t *pos)\r\n{\r\nchar *data;\r\nBUG_ON(copy_size > alloc_size);\r\nif (*pos != 0)\r\nreturn ERR_PTR(-ESPIPE);\r\nif (!aa_may_manage_policy(op))\r\nreturn ERR_PTR(-EACCES);\r\ndata = kvmalloc(alloc_size);\r\nif (data == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (copy_from_user(data, userbuf, copy_size)) {\r\nkvfree(data);\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nreturn data;\r\n}\r\nstatic ssize_t profile_load(struct file *f, const char __user *buf, size_t size,\r\nloff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_LOAD, buf, size, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\nerror = aa_replace_profiles(data, size, PROF_ADD);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic ssize_t profile_replace(struct file *f, const char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_REPL, buf, size, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\nerror = aa_replace_profiles(data, size, PROF_REPLACE);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic ssize_t profile_remove(struct file *f, const char __user *buf,\r\nsize_t size, loff_t *pos)\r\n{\r\nchar *data;\r\nssize_t error;\r\ndata = aa_simple_write_to_buffer(OP_PROF_RM, buf, size + 1, size, pos);\r\nerror = PTR_ERR(data);\r\nif (!IS_ERR(data)) {\r\ndata[size] = 0;\r\nerror = aa_remove_profiles(data, size);\r\nkvfree(data);\r\n}\r\nreturn error;\r\n}\r\nstatic int aa_fs_seq_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aa_fs_entry *fs_file = seq->private;\r\nif (!fs_file)\r\nreturn 0;\r\nswitch (fs_file->v_type) {\r\ncase AA_FS_TYPE_BOOLEAN:\r\nseq_printf(seq, "%s\n", fs_file->v.boolean ? "yes" : "no");\r\nbreak;\r\ncase AA_FS_TYPE_STRING:\r\nseq_printf(seq, "%s\n", fs_file->v.string);\r\nbreak;\r\ncase AA_FS_TYPE_U64:\r\nseq_printf(seq, "%#08lx\n", fs_file->v.u64);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int aa_fs_seq_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, aa_fs_seq_show, inode->i_private);\r\n}\r\nstatic int aa_fs_seq_profile_open(struct inode *inode, struct file *file,\r\nint (*show)(struct seq_file *, void *))\r\n{\r\nstruct aa_replacedby *r = aa_get_replacedby(inode->i_private);\r\nint error = single_open(file, show, r);\r\nif (error) {\r\nfile->private_data = NULL;\r\naa_put_replacedby(r);\r\n}\r\nreturn error;\r\n}\r\nstatic int aa_fs_seq_profile_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = (struct seq_file *) file->private_data;\r\nif (seq)\r\naa_put_replacedby(seq->private);\r\nreturn single_release(inode, file);\r\n}\r\nstatic int aa_fs_seq_profname_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aa_replacedby *r = seq->private;\r\nstruct aa_profile *profile = aa_get_profile_rcu(&r->profile);\r\nseq_printf(seq, "%s\n", profile->base.name);\r\naa_put_profile(profile);\r\nreturn 0;\r\n}\r\nstatic int aa_fs_seq_profname_open(struct inode *inode, struct file *file)\r\n{\r\nreturn aa_fs_seq_profile_open(inode, file, aa_fs_seq_profname_show);\r\n}\r\nstatic int aa_fs_seq_profmode_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aa_replacedby *r = seq->private;\r\nstruct aa_profile *profile = aa_get_profile_rcu(&r->profile);\r\nseq_printf(seq, "%s\n", aa_profile_mode_names[profile->mode]);\r\naa_put_profile(profile);\r\nreturn 0;\r\n}\r\nstatic int aa_fs_seq_profmode_open(struct inode *inode, struct file *file)\r\n{\r\nreturn aa_fs_seq_profile_open(inode, file, aa_fs_seq_profmode_show);\r\n}\r\nstatic int aa_fs_seq_profattach_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aa_replacedby *r = seq->private;\r\nstruct aa_profile *profile = aa_get_profile_rcu(&r->profile);\r\nif (profile->attach)\r\nseq_printf(seq, "%s\n", profile->attach);\r\nelse if (profile->xmatch)\r\nseq_puts(seq, "<unknown>\n");\r\nelse\r\nseq_printf(seq, "%s\n", profile->base.name);\r\naa_put_profile(profile);\r\nreturn 0;\r\n}\r\nstatic int aa_fs_seq_profattach_open(struct inode *inode, struct file *file)\r\n{\r\nreturn aa_fs_seq_profile_open(inode, file, aa_fs_seq_profattach_show);\r\n}\r\nstatic int aa_fs_seq_hash_show(struct seq_file *seq, void *v)\r\n{\r\nstruct aa_replacedby *r = seq->private;\r\nstruct aa_profile *profile = aa_get_profile_rcu(&r->profile);\r\nunsigned int i, size = aa_hash_size();\r\nif (profile->hash) {\r\nfor (i = 0; i < size; i++)\r\nseq_printf(seq, "%.2x", profile->hash[i]);\r\nseq_puts(seq, "\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int aa_fs_seq_hash_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, aa_fs_seq_hash_show, inode->i_private);\r\n}\r\nvoid __aa_fs_profile_rmdir(struct aa_profile *profile)\r\n{\r\nstruct aa_profile *child;\r\nint i;\r\nif (!profile)\r\nreturn;\r\nlist_for_each_entry(child, &profile->base.profiles, base.list)\r\n__aa_fs_profile_rmdir(child);\r\nfor (i = AAFS_PROF_SIZEOF - 1; i >= 0; --i) {\r\nstruct aa_replacedby *r;\r\nif (!profile->dents[i])\r\ncontinue;\r\nr = profile->dents[i]->d_inode->i_private;\r\nsecurityfs_remove(profile->dents[i]);\r\naa_put_replacedby(r);\r\nprofile->dents[i] = NULL;\r\n}\r\n}\r\nvoid __aa_fs_profile_migrate_dents(struct aa_profile *old,\r\nstruct aa_profile *new)\r\n{\r\nint i;\r\nfor (i = 0; i < AAFS_PROF_SIZEOF; i++) {\r\nnew->dents[i] = old->dents[i];\r\nold->dents[i] = NULL;\r\n}\r\n}\r\nstatic struct dentry *create_profile_file(struct dentry *dir, const char *name,\r\nstruct aa_profile *profile,\r\nconst struct file_operations *fops)\r\n{\r\nstruct aa_replacedby *r = aa_get_replacedby(profile->replacedby);\r\nstruct dentry *dent;\r\ndent = securityfs_create_file(name, S_IFREG | 0444, dir, r, fops);\r\nif (IS_ERR(dent))\r\naa_put_replacedby(r);\r\nreturn dent;\r\n}\r\nint __aa_fs_profile_mkdir(struct aa_profile *profile, struct dentry *parent)\r\n{\r\nstruct aa_profile *child;\r\nstruct dentry *dent = NULL, *dir;\r\nint error;\r\nif (!parent) {\r\nstruct aa_profile *p;\r\np = aa_deref_parent(profile);\r\ndent = prof_dir(p);\r\ndent = securityfs_create_dir("profiles", dent);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nprof_child_dir(p) = parent = dent;\r\n}\r\nif (!profile->dirname) {\r\nint len, id_len;\r\nlen = mangle_name(profile->base.name, NULL);\r\nid_len = snprintf(NULL, 0, ".%ld", profile->ns->uniq_id);\r\nprofile->dirname = kmalloc(len + id_len + 1, GFP_KERNEL);\r\nif (!profile->dirname)\r\ngoto fail;\r\nmangle_name(profile->base.name, profile->dirname);\r\nsprintf(profile->dirname + len, ".%ld", profile->ns->uniq_id++);\r\n}\r\ndent = securityfs_create_dir(profile->dirname, parent);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nprof_dir(profile) = dir = dent;\r\ndent = create_profile_file(dir, "name", profile, &aa_fs_profname_fops);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nprofile->dents[AAFS_PROF_NAME] = dent;\r\ndent = create_profile_file(dir, "mode", profile, &aa_fs_profmode_fops);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nprofile->dents[AAFS_PROF_MODE] = dent;\r\ndent = create_profile_file(dir, "attach", profile,\r\n&aa_fs_profattach_fops);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nprofile->dents[AAFS_PROF_ATTACH] = dent;\r\nif (profile->hash) {\r\ndent = create_profile_file(dir, "sha1", profile,\r\n&aa_fs_seq_hash_fops);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nprofile->dents[AAFS_PROF_HASH] = dent;\r\n}\r\nlist_for_each_entry(child, &profile->base.profiles, base.list) {\r\nerror = __aa_fs_profile_mkdir(child, prof_child_dir(profile));\r\nif (error)\r\ngoto fail2;\r\n}\r\nreturn 0;\r\nfail:\r\nerror = PTR_ERR(dent);\r\nfail2:\r\n__aa_fs_profile_rmdir(profile);\r\nreturn error;\r\n}\r\nvoid __aa_fs_namespace_rmdir(struct aa_namespace *ns)\r\n{\r\nstruct aa_namespace *sub;\r\nstruct aa_profile *child;\r\nint i;\r\nif (!ns)\r\nreturn;\r\nlist_for_each_entry(child, &ns->base.profiles, base.list)\r\n__aa_fs_profile_rmdir(child);\r\nlist_for_each_entry(sub, &ns->sub_ns, base.list) {\r\nmutex_lock(&sub->lock);\r\n__aa_fs_namespace_rmdir(sub);\r\nmutex_unlock(&sub->lock);\r\n}\r\nfor (i = AAFS_NS_SIZEOF - 1; i >= 0; --i) {\r\nsecurityfs_remove(ns->dents[i]);\r\nns->dents[i] = NULL;\r\n}\r\n}\r\nint __aa_fs_namespace_mkdir(struct aa_namespace *ns, struct dentry *parent,\r\nconst char *name)\r\n{\r\nstruct aa_namespace *sub;\r\nstruct aa_profile *child;\r\nstruct dentry *dent, *dir;\r\nint error;\r\nif (!name)\r\nname = ns->base.name;\r\ndent = securityfs_create_dir(name, parent);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nns_dir(ns) = dir = dent;\r\ndent = securityfs_create_dir("profiles", dir);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nns_subprofs_dir(ns) = dent;\r\ndent = securityfs_create_dir("namespaces", dir);\r\nif (IS_ERR(dent))\r\ngoto fail;\r\nns_subns_dir(ns) = dent;\r\nlist_for_each_entry(child, &ns->base.profiles, base.list) {\r\nerror = __aa_fs_profile_mkdir(child, ns_subprofs_dir(ns));\r\nif (error)\r\ngoto fail2;\r\n}\r\nlist_for_each_entry(sub, &ns->sub_ns, base.list) {\r\nmutex_lock(&sub->lock);\r\nerror = __aa_fs_namespace_mkdir(sub, ns_subns_dir(ns), NULL);\r\nmutex_unlock(&sub->lock);\r\nif (error)\r\ngoto fail2;\r\n}\r\nreturn 0;\r\nfail:\r\nerror = PTR_ERR(dent);\r\nfail2:\r\n__aa_fs_namespace_rmdir(ns);\r\nreturn error;\r\n}\r\nstatic struct aa_namespace *__next_namespace(struct aa_namespace *root,\r\nstruct aa_namespace *ns)\r\n{\r\nstruct aa_namespace *parent, *next;\r\nif (!list_empty(&ns->sub_ns)) {\r\nnext = list_first_entry(&ns->sub_ns, typeof(*ns), base.list);\r\nmutex_lock(&next->lock);\r\nreturn next;\r\n}\r\nparent = ns->parent;\r\nwhile (ns != root) {\r\nmutex_unlock(&ns->lock);\r\nnext = list_entry_next(ns, base.list);\r\nif (!list_entry_is_head(next, &parent->sub_ns, base.list)) {\r\nmutex_lock(&next->lock);\r\nreturn next;\r\n}\r\nns = parent;\r\nparent = parent->parent;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct aa_profile *__first_profile(struct aa_namespace *root,\r\nstruct aa_namespace *ns)\r\n{\r\nfor (; ns; ns = __next_namespace(root, ns)) {\r\nif (!list_empty(&ns->base.profiles))\r\nreturn list_first_entry(&ns->base.profiles,\r\nstruct aa_profile, base.list);\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct aa_profile *__next_profile(struct aa_profile *p)\r\n{\r\nstruct aa_profile *parent;\r\nstruct aa_namespace *ns = p->ns;\r\nif (!list_empty(&p->base.profiles))\r\nreturn list_first_entry(&p->base.profiles, typeof(*p),\r\nbase.list);\r\nparent = rcu_dereference_protected(p->parent,\r\nmutex_is_locked(&p->ns->lock));\r\nwhile (parent) {\r\np = list_entry_next(p, base.list);\r\nif (!list_entry_is_head(p, &parent->base.profiles, base.list))\r\nreturn p;\r\np = parent;\r\nparent = rcu_dereference_protected(parent->parent,\r\nmutex_is_locked(&parent->ns->lock));\r\n}\r\np = list_entry_next(p, base.list);\r\nif (!list_entry_is_head(p, &ns->base.profiles, base.list))\r\nreturn p;\r\nreturn NULL;\r\n}\r\nstatic struct aa_profile *next_profile(struct aa_namespace *root,\r\nstruct aa_profile *profile)\r\n{\r\nstruct aa_profile *next = __next_profile(profile);\r\nif (next)\r\nreturn next;\r\nreturn __first_profile(root, __next_namespace(root, profile->ns));\r\n}\r\nstatic void *p_start(struct seq_file *f, loff_t *pos)\r\n{\r\nstruct aa_profile *profile = NULL;\r\nstruct aa_namespace *root = aa_current_profile()->ns;\r\nloff_t l = *pos;\r\nf->private = aa_get_namespace(root);\r\nmutex_lock(&root->lock);\r\nprofile = __first_profile(root, root);\r\nfor (; profile && l > 0; l--)\r\nprofile = next_profile(root, profile);\r\nreturn profile;\r\n}\r\nstatic void *p_next(struct seq_file *f, void *p, loff_t *pos)\r\n{\r\nstruct aa_profile *profile = p;\r\nstruct aa_namespace *ns = f->private;\r\n(*pos)++;\r\nreturn next_profile(ns, profile);\r\n}\r\nstatic void p_stop(struct seq_file *f, void *p)\r\n{\r\nstruct aa_profile *profile = p;\r\nstruct aa_namespace *root = f->private, *ns;\r\nif (profile) {\r\nfor (ns = profile->ns; ns && ns != root; ns = ns->parent)\r\nmutex_unlock(&ns->lock);\r\n}\r\nmutex_unlock(&root->lock);\r\naa_put_namespace(root);\r\n}\r\nstatic int seq_show_profile(struct seq_file *f, void *p)\r\n{\r\nstruct aa_profile *profile = (struct aa_profile *)p;\r\nstruct aa_namespace *root = f->private;\r\nif (profile->ns != root)\r\nseq_printf(f, ":%s://", aa_ns_name(root, profile->ns));\r\nseq_printf(f, "%s (%s)\n", profile->base.hname,\r\naa_profile_mode_names[profile->mode]);\r\nreturn 0;\r\n}\r\nstatic int profiles_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &aa_fs_profiles_op);\r\n}\r\nstatic int profiles_release(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_release(inode, file);\r\n}\r\nstatic int __init aafs_create_file(struct aa_fs_entry *fs_file,\r\nstruct dentry *parent)\r\n{\r\nint error = 0;\r\nfs_file->dentry = securityfs_create_file(fs_file->name,\r\nS_IFREG | fs_file->mode,\r\nparent, fs_file,\r\nfs_file->file_ops);\r\nif (IS_ERR(fs_file->dentry)) {\r\nerror = PTR_ERR(fs_file->dentry);\r\nfs_file->dentry = NULL;\r\n}\r\nreturn error;\r\n}\r\nstatic int __init aafs_create_dir(struct aa_fs_entry *fs_dir,\r\nstruct dentry *parent)\r\n{\r\nstruct aa_fs_entry *fs_file;\r\nstruct dentry *dir;\r\nint error;\r\ndir = securityfs_create_dir(fs_dir->name, parent);\r\nif (IS_ERR(dir))\r\nreturn PTR_ERR(dir);\r\nfs_dir->dentry = dir;\r\nfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\r\nif (fs_file->v_type == AA_FS_TYPE_DIR)\r\nerror = aafs_create_dir(fs_file, fs_dir->dentry);\r\nelse\r\nerror = aafs_create_file(fs_file, fs_dir->dentry);\r\nif (error)\r\ngoto failed;\r\n}\r\nreturn 0;\r\nfailed:\r\naafs_remove_dir(fs_dir);\r\nreturn error;\r\n}\r\nstatic void __init aafs_remove_file(struct aa_fs_entry *fs_file)\r\n{\r\nif (!fs_file->dentry)\r\nreturn;\r\nsecurityfs_remove(fs_file->dentry);\r\nfs_file->dentry = NULL;\r\n}\r\nstatic void __init aafs_remove_dir(struct aa_fs_entry *fs_dir)\r\n{\r\nstruct aa_fs_entry *fs_file;\r\nfor (fs_file = fs_dir->v.files; fs_file && fs_file->name; ++fs_file) {\r\nif (fs_file->v_type == AA_FS_TYPE_DIR)\r\naafs_remove_dir(fs_file);\r\nelse\r\naafs_remove_file(fs_file);\r\n}\r\naafs_remove_file(fs_dir);\r\n}\r\nvoid __init aa_destroy_aafs(void)\r\n{\r\naafs_remove_dir(&aa_fs_entry);\r\n}\r\nstatic int __init aa_create_aafs(void)\r\n{\r\nint error;\r\nif (!apparmor_initialized)\r\nreturn 0;\r\nif (aa_fs_entry.dentry) {\r\nAA_ERROR("%s: AppArmor securityfs already exists\n", __func__);\r\nreturn -EEXIST;\r\n}\r\nerror = aafs_create_dir(&aa_fs_entry, NULL);\r\nif (error)\r\ngoto error;\r\nerror = __aa_fs_namespace_mkdir(root_ns, aa_fs_entry.dentry,\r\n"policy");\r\nif (error)\r\ngoto error;\r\naa_info_message("AppArmor Filesystem Enabled");\r\nreturn 0;\r\nerror:\r\naa_destroy_aafs();\r\nAA_ERROR("Error creating AppArmor securityfs\n");\r\nreturn error;\r\n}
