static inline void __enable_block(int block)\r\n{\r\nvoid __iomem *base = (void __iomem *)VSS_ADDR(block);\r\n__raw_writel(3, base + VSS_CLKRST);\r\nwmb();\r\n__raw_writel(0x01fffffe, base + VSS_GATE);\r\nwmb();\r\n__raw_writel(0x01, base + VSS_FTR);\r\nwmb();\r\n__raw_writel(0x03, base + VSS_FTR);\r\nwmb();\r\n__raw_writel(0x07, base + VSS_FTR);\r\nwmb();\r\n__raw_writel(0x0f, base + VSS_FTR);\r\nwmb();\r\n__raw_writel(0x01ffffff, base + VSS_GATE);\r\nwmb();\r\n__raw_writel(2, base + VSS_CLKRST);\r\nwmb();\r\n__raw_writel(0x1f, base + VSS_FTR);\r\nwmb();\r\n}\r\nstatic inline void __disable_block(int block)\r\n{\r\nvoid __iomem *base = (void __iomem *)VSS_ADDR(block);\r\n__raw_writel(0x0f, base + VSS_FTR);\r\nwmb();\r\n__raw_writel(0, base + VSS_GATE);\r\nwmb();\r\n__raw_writel(3, base + VSS_CLKRST);\r\nwmb();\r\n__raw_writel(1, base + VSS_CLKRST);\r\nwmb();\r\n__raw_writel(0, base + VSS_FTR);\r\nwmb();\r\n}\r\nvoid au1300_vss_block_control(int block, int enable)\r\n{\r\nunsigned long flags;\r\nif (alchemy_get_cputype() != ALCHEMY_CPU_AU1300)\r\nreturn;\r\nspin_lock_irqsave(&au1300_vss_lock, flags);\r\nif (enable)\r\n__enable_block(block);\r\nelse\r\n__disable_block(block);\r\nspin_unlock_irqrestore(&au1300_vss_lock, flags);\r\n}
