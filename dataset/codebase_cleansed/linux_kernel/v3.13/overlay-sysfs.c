static ssize_t overlay_name_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", ovl->name);\r\n}\r\nstatic ssize_t overlay_manager_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n",\r\novl->manager ? ovl->manager->name : "<none>");\r\n}\r\nstatic ssize_t overlay_manager_store(struct omap_overlay *ovl, const char *buf,\r\nsize_t size)\r\n{\r\nint i, r;\r\nstruct omap_overlay_manager *mgr = NULL;\r\nstruct omap_overlay_manager *old_mgr;\r\nint len = size;\r\nif (buf[size-1] == '\n')\r\n--len;\r\nif (len > 0) {\r\nfor (i = 0; i < omap_dss_get_num_overlay_managers(); ++i) {\r\nmgr = omap_dss_get_overlay_manager(i);\r\nif (sysfs_streq(buf, mgr->name))\r\nbreak;\r\nmgr = NULL;\r\n}\r\n}\r\nif (len > 0 && mgr == NULL)\r\nreturn -EINVAL;\r\nif (mgr)\r\nDSSDBG("manager %s found\n", mgr->name);\r\nif (mgr == ovl->manager)\r\nreturn size;\r\nold_mgr = ovl->manager;\r\nr = dispc_runtime_get();\r\nif (r)\r\nreturn r;\r\nif (old_mgr) {\r\nr = ovl->unset_manager(ovl);\r\nif (r) {\r\nDSSERR("detach failed\n");\r\ngoto err;\r\n}\r\nr = old_mgr->apply(old_mgr);\r\nif (r)\r\ngoto err;\r\n}\r\nif (mgr) {\r\nr = ovl->set_manager(ovl, mgr);\r\nif (r) {\r\nDSSERR("Failed to attach overlay\n");\r\ngoto err;\r\n}\r\nr = mgr->apply(mgr);\r\nif (r)\r\ngoto err;\r\n}\r\ndispc_runtime_put();\r\nreturn size;\r\nerr:\r\ndispc_runtime_put();\r\nreturn r;\r\n}\r\nstatic ssize_t overlay_input_size_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d,%d\n",\r\ninfo.width, info.height);\r\n}\r\nstatic ssize_t overlay_screen_width_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", info.screen_width);\r\n}\r\nstatic ssize_t overlay_position_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d,%d\n",\r\ninfo.pos_x, info.pos_y);\r\n}\r\nstatic ssize_t overlay_position_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nchar *last;\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.pos_x = simple_strtoul(buf, &last, 10);\r\n++last;\r\nif (last - buf >= size)\r\nreturn -EINVAL;\r\ninfo.pos_y = simple_strtoul(last, &last, 10);\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_output_size_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d,%d\n",\r\ninfo.out_width, info.out_height);\r\n}\r\nstatic ssize_t overlay_output_size_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nchar *last;\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.out_width = simple_strtoul(buf, &last, 10);\r\n++last;\r\nif (last - buf >= size)\r\nreturn -EINVAL;\r\ninfo.out_height = simple_strtoul(last, &last, 10);\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_enabled_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ovl->is_enabled(ovl));\r\n}\r\nstatic ssize_t overlay_enabled_store(struct omap_overlay *ovl, const char *buf,\r\nsize_t size)\r\n{\r\nint r;\r\nbool enable;\r\nr = strtobool(buf, &enable);\r\nif (r)\r\nreturn r;\r\nif (enable)\r\nr = ovl->enable(ovl);\r\nelse\r\nr = ovl->disable(ovl);\r\nif (r)\r\nreturn r;\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_global_alpha_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ninfo.global_alpha);\r\n}\r\nstatic ssize_t overlay_global_alpha_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nu8 alpha;\r\nstruct omap_overlay_info info;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_GLOBAL_ALPHA) == 0)\r\nreturn -ENODEV;\r\nr = kstrtou8(buf, 0, &alpha);\r\nif (r)\r\nreturn r;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.global_alpha = alpha;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_pre_mult_alpha_show(struct omap_overlay *ovl,\r\nchar *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n",\r\ninfo.pre_mult_alpha);\r\n}\r\nstatic ssize_t overlay_pre_mult_alpha_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nu8 alpha;\r\nstruct omap_overlay_info info;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_PRE_MULT_ALPHA) == 0)\r\nreturn -ENODEV;\r\nr = kstrtou8(buf, 0, &alpha);\r\nif (r)\r\nreturn r;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.pre_mult_alpha = alpha;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_zorder_show(struct omap_overlay *ovl, char *buf)\r\n{\r\nstruct omap_overlay_info info;\r\novl->get_overlay_info(ovl, &info);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", info.zorder);\r\n}\r\nstatic ssize_t overlay_zorder_store(struct omap_overlay *ovl,\r\nconst char *buf, size_t size)\r\n{\r\nint r;\r\nu8 zorder;\r\nstruct omap_overlay_info info;\r\nif ((ovl->caps & OMAP_DSS_OVL_CAP_ZORDER) == 0)\r\nreturn -ENODEV;\r\nr = kstrtou8(buf, 0, &zorder);\r\nif (r)\r\nreturn r;\r\novl->get_overlay_info(ovl, &info);\r\ninfo.zorder = zorder;\r\nr = ovl->set_overlay_info(ovl, &info);\r\nif (r)\r\nreturn r;\r\nif (ovl->manager) {\r\nr = ovl->manager->apply(ovl->manager);\r\nif (r)\r\nreturn r;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t overlay_attr_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nstruct omap_overlay *overlay;\r\nstruct overlay_attribute *overlay_attr;\r\noverlay = container_of(kobj, struct omap_overlay, kobj);\r\noverlay_attr = container_of(attr, struct overlay_attribute, attr);\r\nif (!overlay_attr->show)\r\nreturn -ENOENT;\r\nreturn overlay_attr->show(overlay, buf);\r\n}\r\nstatic ssize_t overlay_attr_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct omap_overlay *overlay;\r\nstruct overlay_attribute *overlay_attr;\r\noverlay = container_of(kobj, struct omap_overlay, kobj);\r\noverlay_attr = container_of(attr, struct overlay_attribute, attr);\r\nif (!overlay_attr->store)\r\nreturn -ENOENT;\r\nreturn overlay_attr->store(overlay, buf, size);\r\n}\r\nint dss_overlay_kobj_init(struct omap_overlay *ovl,\r\nstruct platform_device *pdev)\r\n{\r\nreturn kobject_init_and_add(&ovl->kobj, &overlay_ktype,\r\n&pdev->dev.kobj, "overlay%d", ovl->id);\r\n}\r\nvoid dss_overlay_kobj_uninit(struct omap_overlay *ovl)\r\n{\r\nkobject_del(&ovl->kobj);\r\nkobject_put(&ovl->kobj);\r\n}
