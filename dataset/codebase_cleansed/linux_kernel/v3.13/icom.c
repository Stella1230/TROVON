static inline void trace(struct icom_port *icom_port, char *trace_pt,\r\nunsigned long trace_data)\r\n{\r\ndev_info(&icom_port->adapter->pci_dev->dev, ":%d:%s - %lx\n",\r\nicom_port->port, trace_pt, trace_data);\r\n}\r\nstatic inline void trace(struct icom_port *icom_port, char *trace_pt, unsigned long trace_data) {}\r\nstatic void free_port_memory(struct icom_port *icom_port)\r\n{\r\nstruct pci_dev *dev = icom_port->adapter->pci_dev;\r\ntrace(icom_port, "RET_PORT_MEM", 0);\r\nif (icom_port->recv_buf) {\r\npci_free_consistent(dev, 4096, icom_port->recv_buf,\r\nicom_port->recv_buf_pci);\r\nicom_port->recv_buf = NULL;\r\n}\r\nif (icom_port->xmit_buf) {\r\npci_free_consistent(dev, 4096, icom_port->xmit_buf,\r\nicom_port->xmit_buf_pci);\r\nicom_port->xmit_buf = NULL;\r\n}\r\nif (icom_port->statStg) {\r\npci_free_consistent(dev, 4096, icom_port->statStg,\r\nicom_port->statStg_pci);\r\nicom_port->statStg = NULL;\r\n}\r\nif (icom_port->xmitRestart) {\r\npci_free_consistent(dev, 4096, icom_port->xmitRestart,\r\nicom_port->xmitRestart_pci);\r\nicom_port->xmitRestart = NULL;\r\n}\r\n}\r\nstatic int get_port_memory(struct icom_port *icom_port)\r\n{\r\nint index;\r\nunsigned long stgAddr;\r\nunsigned long startStgAddr;\r\nunsigned long offset;\r\nstruct pci_dev *dev = icom_port->adapter->pci_dev;\r\nicom_port->xmit_buf =\r\npci_alloc_consistent(dev, 4096, &icom_port->xmit_buf_pci);\r\nif (!icom_port->xmit_buf) {\r\ndev_err(&dev->dev, "Can not allocate Transmit buffer\n");\r\nreturn -ENOMEM;\r\n}\r\ntrace(icom_port, "GET_PORT_MEM",\r\n(unsigned long) icom_port->xmit_buf);\r\nicom_port->recv_buf =\r\npci_alloc_consistent(dev, 4096, &icom_port->recv_buf_pci);\r\nif (!icom_port->recv_buf) {\r\ndev_err(&dev->dev, "Can not allocate Receive buffer\n");\r\nfree_port_memory(icom_port);\r\nreturn -ENOMEM;\r\n}\r\ntrace(icom_port, "GET_PORT_MEM",\r\n(unsigned long) icom_port->recv_buf);\r\nicom_port->statStg =\r\npci_alloc_consistent(dev, 4096, &icom_port->statStg_pci);\r\nif (!icom_port->statStg) {\r\ndev_err(&dev->dev, "Can not allocate Status buffer\n");\r\nfree_port_memory(icom_port);\r\nreturn -ENOMEM;\r\n}\r\ntrace(icom_port, "GET_PORT_MEM",\r\n(unsigned long) icom_port->statStg);\r\nicom_port->xmitRestart =\r\npci_alloc_consistent(dev, 4096, &icom_port->xmitRestart_pci);\r\nif (!icom_port->xmitRestart) {\r\ndev_err(&dev->dev,\r\n"Can not allocate xmit Restart buffer\n");\r\nfree_port_memory(icom_port);\r\nreturn -ENOMEM;\r\n}\r\nmemset(icom_port->statStg, 0, 4096);\r\nstgAddr = (unsigned long) icom_port->statStg;\r\nfor (index = 0; index < NUM_XBUFFS; index++) {\r\ntrace(icom_port, "FOD_ADDR", stgAddr);\r\nstgAddr = stgAddr + sizeof(icom_port->statStg->xmit[0]);\r\nif (index < (NUM_XBUFFS - 1)) {\r\nmemset(&icom_port->statStg->xmit[index], 0, sizeof(struct xmit_status_area));\r\nicom_port->statStg->xmit[index].leLengthASD =\r\n(unsigned short int) cpu_to_le16(XMIT_BUFF_SZ);\r\ntrace(icom_port, "FOD_ADDR", stgAddr);\r\ntrace(icom_port, "FOD_XBUFF",\r\n(unsigned long) icom_port->xmit_buf);\r\nicom_port->statStg->xmit[index].leBuffer =\r\ncpu_to_le32(icom_port->xmit_buf_pci);\r\n} else if (index == (NUM_XBUFFS - 1)) {\r\nmemset(&icom_port->statStg->xmit[index], 0, sizeof(struct xmit_status_area));\r\nicom_port->statStg->xmit[index].leLengthASD =\r\n(unsigned short int) cpu_to_le16(XMIT_BUFF_SZ);\r\ntrace(icom_port, "FOD_XBUFF",\r\n(unsigned long) icom_port->xmit_buf);\r\nicom_port->statStg->xmit[index].leBuffer =\r\ncpu_to_le32(icom_port->xmit_buf_pci);\r\n} else {\r\nmemset(&icom_port->statStg->xmit[index], 0, sizeof(struct xmit_status_area));\r\n}\r\n}\r\nstartStgAddr = stgAddr;\r\nfor (index = 0; index < NUM_RBUFFS; index++) {\r\ntrace(icom_port, "FID_ADDR", stgAddr);\r\nstgAddr = stgAddr + sizeof(icom_port->statStg->rcv[0]);\r\nicom_port->statStg->rcv[index].leLength = 0;\r\nicom_port->statStg->rcv[index].WorkingLength =\r\n(unsigned short int) cpu_to_le16(RCV_BUFF_SZ);\r\nif (index < (NUM_RBUFFS - 1) ) {\r\noffset = stgAddr - (unsigned long) icom_port->statStg;\r\nicom_port->statStg->rcv[index].leNext =\r\ncpu_to_le32(icom_port-> statStg_pci + offset);\r\ntrace(icom_port, "FID_RBUFF",\r\n(unsigned long) icom_port->recv_buf);\r\nicom_port->statStg->rcv[index].leBuffer =\r\ncpu_to_le32(icom_port->recv_buf_pci);\r\n} else if (index == (NUM_RBUFFS -1) ) {\r\noffset = startStgAddr - (unsigned long) icom_port->statStg;\r\nicom_port->statStg->rcv[index].leNext =\r\ncpu_to_le32(icom_port-> statStg_pci + offset);\r\ntrace(icom_port, "FID_RBUFF",\r\n(unsigned long) icom_port->recv_buf + 2048);\r\nicom_port->statStg->rcv[index].leBuffer =\r\ncpu_to_le32(icom_port->recv_buf_pci + 2048);\r\n} else {\r\nicom_port->statStg->rcv[index].leNext = 0;\r\nicom_port->statStg->rcv[index].leBuffer = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void stop_processor(struct icom_port *icom_port)\r\n{\r\nunsigned long temp;\r\nunsigned long flags;\r\nint port;\r\nspin_lock_irqsave(&icom_lock, flags);\r\nport = icom_port->port;\r\nif (port >= ARRAY_SIZE(stop_proc)) {\r\ndev_err(&icom_port->adapter->pci_dev->dev,\r\n"Invalid port assignment\n");\r\ngoto unlock;\r\n}\r\nif (port == 0 || port == 1)\r\nstop_proc[port].global_control_reg = &icom_port->global_reg->control;\r\nelse\r\nstop_proc[port].global_control_reg = &icom_port->global_reg->control_2;\r\ntemp = readl(stop_proc[port].global_control_reg);\r\ntemp = (temp & ~start_proc[port].processor_id) | stop_proc[port].processor_id;\r\nwritel(temp, stop_proc[port].global_control_reg);\r\nreadl(stop_proc[port].global_control_reg);\r\nunlock:\r\nspin_unlock_irqrestore(&icom_lock, flags);\r\n}\r\nstatic void start_processor(struct icom_port *icom_port)\r\n{\r\nunsigned long temp;\r\nunsigned long flags;\r\nint port;\r\nspin_lock_irqsave(&icom_lock, flags);\r\nport = icom_port->port;\r\nif (port >= ARRAY_SIZE(start_proc)) {\r\ndev_err(&icom_port->adapter->pci_dev->dev,\r\n"Invalid port assignment\n");\r\ngoto unlock;\r\n}\r\nif (port == 0 || port == 1)\r\nstart_proc[port].global_control_reg = &icom_port->global_reg->control;\r\nelse\r\nstart_proc[port].global_control_reg = &icom_port->global_reg->control_2;\r\ntemp = readl(start_proc[port].global_control_reg);\r\ntemp = (temp & ~stop_proc[port].processor_id) | start_proc[port].processor_id;\r\nwritel(temp, start_proc[port].global_control_reg);\r\nreadl(start_proc[port].global_control_reg);\r\nunlock:\r\nspin_unlock_irqrestore(&icom_lock, flags);\r\n}\r\nstatic void load_code(struct icom_port *icom_port)\r\n{\r\nconst struct firmware *fw;\r\nchar __iomem *iram_ptr;\r\nint index;\r\nint status = 0;\r\nvoid __iomem *dram_ptr = icom_port->dram;\r\ndma_addr_t temp_pci;\r\nunsigned char *new_page = NULL;\r\nunsigned char cable_id = NO_CABLE;\r\nstruct pci_dev *dev = icom_port->adapter->pci_dev;\r\nwritew(0x3FFF, icom_port->int_reg);\r\ntrace(icom_port, "CLEAR_INTERRUPTS", 0);\r\nstop_processor(icom_port);\r\nmemset_io(dram_ptr, 0, 512);\r\nif (request_firmware(&fw, "icom_call_setup.bin", &dev->dev) < 0) {\r\ndev_err(&dev->dev,"Unable to load icom_call_setup.bin firmware image\n");\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\nif (fw->size > ICOM_DCE_IRAM_OFFSET) {\r\ndev_err(&dev->dev, "Invalid firmware image for icom_call_setup.bin found.\n");\r\nrelease_firmware(fw);\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\niram_ptr = (char __iomem *)icom_port->dram + ICOM_IRAM_OFFSET;\r\nfor (index = 0; index < fw->size; index++)\r\nwriteb(fw->data[index], &iram_ptr[index]);\r\nrelease_firmware(fw);\r\nif (request_firmware(&fw, "icom_res_dce.bin", &dev->dev) < 0) {\r\ndev_err(&dev->dev,"Unable to load icom_res_dce.bin firmware image\n");\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\nif (fw->size > ICOM_IRAM_SIZE) {\r\ndev_err(&dev->dev, "Invalid firmware image for icom_res_dce.bin found.\n");\r\nrelease_firmware(fw);\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\niram_ptr = (char __iomem *) icom_port->dram + ICOM_IRAM_OFFSET;\r\nfor (index = ICOM_DCE_IRAM_OFFSET; index < fw->size; index++)\r\nwriteb(fw->data[index], &iram_ptr[index]);\r\nrelease_firmware(fw);\r\nif (icom_port->adapter->version == ADAPTER_V2)\r\nwriteb(V2_HARDWARE, &(icom_port->dram->misc_flags));\r\nstart_processor(icom_port);\r\nwriteb((HDLC_PPP_PURE_ASYNC | HDLC_FF_FILL),\r\n&(icom_port->dram->HDLCConfigReg));\r\nwriteb(0x04, &(icom_port->dram->FlagFillIdleTimer));\r\nwriteb(0x00, &(icom_port->dram->CmdReg));\r\nwriteb(0x10, &(icom_port->dram->async_config3));\r\nwriteb((ICOM_ACFG_DRIVE1 | ICOM_ACFG_NO_PARITY | ICOM_ACFG_8BPC |\r\nICOM_ACFG_1STOP_BIT), &(icom_port->dram->async_config2));\r\nnew_page = pci_alloc_consistent(dev, 4096, &temp_pci);\r\nif (!new_page) {\r\ndev_err(&dev->dev, "Can not allocate DMA buffer\n");\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\nif (request_firmware(&fw, "icom_asc.bin", &dev->dev) < 0) {\r\ndev_err(&dev->dev,"Unable to load icom_asc.bin firmware image\n");\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\nif (fw->size > ICOM_DCE_IRAM_OFFSET) {\r\ndev_err(&dev->dev, "Invalid firmware image for icom_asc.bin found.\n");\r\nrelease_firmware(fw);\r\nstatus = -1;\r\ngoto load_code_exit;\r\n}\r\nfor (index = 0; index < fw->size; index++)\r\nnew_page[index] = fw->data[index];\r\nrelease_firmware(fw);\r\nwriteb((char) ((fw->size + 16)/16), &icom_port->dram->mac_length);\r\nwritel(temp_pci, &icom_port->dram->mac_load_addr);\r\nwriteb(START_DOWNLOAD, &icom_port->dram->sync);\r\nfor (index = 0; index < 10; index++) {\r\nmsleep(100);\r\nif (readb(&icom_port->dram->misc_flags) & ICOM_HDW_ACTIVE)\r\nbreak;\r\n}\r\nif (index == 10)\r\nstatus = -1;\r\ncable_id = readb(&icom_port->dram->cable_id);\r\nif (cable_id & ICOM_CABLE_ID_VALID) {\r\ncable_id = (cable_id & ICOM_CABLE_ID_MASK) >> 4;\r\nicom_port->cable_id = cable_id;\r\n} else {\r\ndev_err(&dev->dev,"Invalid or no cable attached\n");\r\nicom_port->cable_id = NO_CABLE;\r\n}\r\nload_code_exit:\r\nif (status != 0) {\r\nwritew(0x3FFF, icom_port->int_reg);\r\nwriteb(ICOM_DISABLE, &(icom_port->dram->disable));\r\nstop_processor(icom_port);\r\ndev_err(&icom_port->adapter->pci_dev->dev,"Port not operational\n");\r\n}\r\nif (new_page != NULL)\r\npci_free_consistent(dev, 4096, new_page, temp_pci);\r\n}\r\nstatic int startup(struct icom_port *icom_port)\r\n{\r\nunsigned long temp;\r\nunsigned char cable_id, raw_cable_id;\r\nunsigned long flags;\r\nint port;\r\ntrace(icom_port, "STARTUP", 0);\r\nif (!icom_port->dram) {\r\ndev_err(&icom_port->adapter->pci_dev->dev,\r\n"Unusable Port, port configuration missing\n");\r\nreturn -ENODEV;\r\n}\r\nraw_cable_id = readb(&icom_port->dram->cable_id);\r\ntrace(icom_port, "CABLE_ID", raw_cable_id);\r\ncable_id = (raw_cable_id & ICOM_CABLE_ID_MASK) >> 4;\r\nif (!(raw_cable_id & ICOM_CABLE_ID_VALID) ||\r\n(cable_id != icom_port->cable_id)) {\r\nload_code(icom_port);\r\nraw_cable_id = readb(&icom_port->dram->cable_id);\r\ncable_id = (raw_cable_id & ICOM_CABLE_ID_MASK) >> 4;\r\nif (!(raw_cable_id & ICOM_CABLE_ID_VALID) ||\r\n(icom_port->cable_id == NO_CABLE))\r\nreturn -EIO;\r\n}\r\nspin_lock_irqsave(&icom_lock, flags);\r\nport = icom_port->port;\r\nif (port >= ARRAY_SIZE(int_mask_tbl)) {\r\ndev_err(&icom_port->adapter->pci_dev->dev,\r\n"Invalid port assignment\n");\r\ngoto unlock;\r\n}\r\nif (port == 0 || port == 1)\r\nint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask;\r\nelse\r\nint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask_2;\r\nif (port == 0 || port == 2)\r\nwritew(0x00FF, icom_port->int_reg);\r\nelse\r\nwritew(0x3F00, icom_port->int_reg);\r\ntemp = readl(int_mask_tbl[port].global_int_mask);\r\nwritel(temp & ~int_mask_tbl[port].processor_id, int_mask_tbl[port].global_int_mask);\r\nreadl(int_mask_tbl[port].global_int_mask);\r\nunlock:\r\nspin_unlock_irqrestore(&icom_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void shutdown(struct icom_port *icom_port)\r\n{\r\nunsigned long temp;\r\nunsigned char cmdReg;\r\nunsigned long flags;\r\nint port;\r\nspin_lock_irqsave(&icom_lock, flags);\r\ntrace(icom_port, "SHUTDOWN", 0);\r\nport = icom_port->port;\r\nif (port >= ARRAY_SIZE(int_mask_tbl)) {\r\ndev_err(&icom_port->adapter->pci_dev->dev,\r\n"Invalid port assignment\n");\r\ngoto unlock;\r\n}\r\nif (port == 0 || port == 1)\r\nint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask;\r\nelse\r\nint_mask_tbl[port].global_int_mask = &icom_port->global_reg->int_mask_2;\r\ntemp = readl(int_mask_tbl[port].global_int_mask);\r\nwritel(temp | int_mask_tbl[port].processor_id, int_mask_tbl[port].global_int_mask);\r\nreadl(int_mask_tbl[port].global_int_mask);\r\nunlock:\r\nspin_unlock_irqrestore(&icom_lock, flags);\r\ncmdReg = readb(&icom_port->dram->CmdReg);\r\nif (cmdReg & CMD_SND_BREAK) {\r\nwriteb(cmdReg & ~CMD_SND_BREAK, &icom_port->dram->CmdReg);\r\n}\r\n}\r\nstatic int icom_write(struct uart_port *port)\r\n{\r\nunsigned long data_count;\r\nunsigned char cmdReg;\r\nunsigned long offset;\r\nint temp_tail = port->state->xmit.tail;\r\ntrace(ICOM_PORT, "WRITE", 0);\r\nif (cpu_to_le16(ICOM_PORT->statStg->xmit[0].flags) &\r\nSA_FLAGS_READY_TO_XMIT) {\r\ntrace(ICOM_PORT, "WRITE_FULL", 0);\r\nreturn 0;\r\n}\r\ndata_count = 0;\r\nwhile ((port->state->xmit.head != temp_tail) &&\r\n(data_count <= XMIT_BUFF_SZ)) {\r\nICOM_PORT->xmit_buf[data_count++] =\r\nport->state->xmit.buf[temp_tail];\r\ntemp_tail++;\r\ntemp_tail &= (UART_XMIT_SIZE - 1);\r\n}\r\nif (data_count) {\r\nICOM_PORT->statStg->xmit[0].flags =\r\ncpu_to_le16(SA_FLAGS_READY_TO_XMIT);\r\nICOM_PORT->statStg->xmit[0].leLength =\r\ncpu_to_le16(data_count);\r\noffset =\r\n(unsigned long) &ICOM_PORT->statStg->xmit[0] -\r\n(unsigned long) ICOM_PORT->statStg;\r\n*ICOM_PORT->xmitRestart =\r\ncpu_to_le32(ICOM_PORT->statStg_pci + offset);\r\ncmdReg = readb(&ICOM_PORT->dram->CmdReg);\r\nwriteb(cmdReg | CMD_XMIT_RCV_ENABLE,\r\n&ICOM_PORT->dram->CmdReg);\r\nwriteb(START_XMIT, &ICOM_PORT->dram->StartXmitCmd);\r\ntrace(ICOM_PORT, "WRITE_START", data_count);\r\nreadb(&ICOM_PORT->dram->StartXmitCmd);\r\n}\r\nreturn data_count;\r\n}\r\nstatic inline void check_modem_status(struct icom_port *icom_port)\r\n{\r\nstatic char old_status = 0;\r\nchar delta_status;\r\nunsigned char status;\r\nspin_lock(&icom_port->uart_port.lock);\r\nstatus = readb(&icom_port->dram->isr);\r\ntrace(icom_port, "CHECK_MODEM", status);\r\ndelta_status = status ^ old_status;\r\nif (delta_status) {\r\nif (delta_status & ICOM_RI)\r\nicom_port->uart_port.icount.rng++;\r\nif (delta_status & ICOM_DSR)\r\nicom_port->uart_port.icount.dsr++;\r\nif (delta_status & ICOM_DCD)\r\nuart_handle_dcd_change(&icom_port->uart_port,\r\ndelta_status & ICOM_DCD);\r\nif (delta_status & ICOM_CTS)\r\nuart_handle_cts_change(&icom_port->uart_port,\r\ndelta_status & ICOM_CTS);\r\nwake_up_interruptible(&icom_port->uart_port.state->\r\nport.delta_msr_wait);\r\nold_status = status;\r\n}\r\nspin_unlock(&icom_port->uart_port.lock);\r\n}\r\nstatic void xmit_interrupt(u16 port_int_reg, struct icom_port *icom_port)\r\n{\r\nunsigned short int count;\r\nint i;\r\nif (port_int_reg & (INT_XMIT_COMPLETED)) {\r\ntrace(icom_port, "XMIT_COMPLETE", 0);\r\nicom_port->statStg->xmit[0].flags &=\r\ncpu_to_le16(~SA_FLAGS_READY_TO_XMIT);\r\ncount = (unsigned short int)\r\ncpu_to_le16(icom_port->statStg->xmit[0].leLength);\r\nicom_port->uart_port.icount.tx += count;\r\nfor (i=0; i<count &&\r\n!uart_circ_empty(&icom_port->uart_port.state->xmit); i++) {\r\nicom_port->uart_port.state->xmit.tail++;\r\nicom_port->uart_port.state->xmit.tail &=\r\n(UART_XMIT_SIZE - 1);\r\n}\r\nif (!icom_write(&icom_port->uart_port))\r\nuart_write_wakeup(&icom_port->uart_port);\r\n} else\r\ntrace(icom_port, "XMIT_DISABLED", 0);\r\n}\r\nstatic void recv_interrupt(u16 port_int_reg, struct icom_port *icom_port)\r\n{\r\nshort int count, rcv_buff;\r\nstruct tty_port *port = &icom_port->uart_port.state->port;\r\nunsigned short int status;\r\nstruct uart_icount *icount;\r\nunsigned long offset;\r\nunsigned char flag;\r\ntrace(icom_port, "RCV_COMPLETE", 0);\r\nrcv_buff = icom_port->next_rcv;\r\nstatus = cpu_to_le16(icom_port->statStg->rcv[rcv_buff].flags);\r\nwhile (status & SA_FL_RCV_DONE) {\r\nint first = -1;\r\ntrace(icom_port, "FID_STATUS", status);\r\ncount = cpu_to_le16(icom_port->statStg->rcv[rcv_buff].leLength);\r\ntrace(icom_port, "RCV_COUNT", count);\r\ntrace(icom_port, "REAL_COUNT", count);\r\noffset =\r\ncpu_to_le32(icom_port->statStg->rcv[rcv_buff].leBuffer) -\r\nicom_port->recv_buf_pci;\r\nif (count > 0) {\r\nfirst = icom_port->recv_buf[offset];\r\ntty_insert_flip_string(port, icom_port->recv_buf + offset, count - 1);\r\n}\r\nicount = &icom_port->uart_port.icount;\r\nicount->rx += count;\r\nif ((status & SA_FLAGS_FRAME_ERROR)\r\n&& first == 0) {\r\nstatus &= ~SA_FLAGS_FRAME_ERROR;\r\nstatus |= SA_FLAGS_BREAK_DET;\r\ntrace(icom_port, "BREAK_DET", 0);\r\n}\r\nflag = TTY_NORMAL;\r\nif (status &\r\n(SA_FLAGS_BREAK_DET | SA_FLAGS_PARITY_ERROR |\r\nSA_FLAGS_FRAME_ERROR | SA_FLAGS_OVERRUN)) {\r\nif (status & SA_FLAGS_BREAK_DET)\r\nicount->brk++;\r\nif (status & SA_FLAGS_PARITY_ERROR)\r\nicount->parity++;\r\nif (status & SA_FLAGS_FRAME_ERROR)\r\nicount->frame++;\r\nif (status & SA_FLAGS_OVERRUN)\r\nicount->overrun++;\r\nif (status & icom_port->ignore_status_mask) {\r\ntrace(icom_port, "IGNORE_CHAR", 0);\r\ngoto ignore_char;\r\n}\r\nstatus &= icom_port->read_status_mask;\r\nif (status & SA_FLAGS_BREAK_DET) {\r\nflag = TTY_BREAK;\r\n} else if (status & SA_FLAGS_PARITY_ERROR) {\r\ntrace(icom_port, "PARITY_ERROR", 0);\r\nflag = TTY_PARITY;\r\n} else if (status & SA_FLAGS_FRAME_ERROR)\r\nflag = TTY_FRAME;\r\n}\r\ntty_insert_flip_char(port, *(icom_port->recv_buf + offset + count - 1), flag);\r\nif (status & SA_FLAGS_OVERRUN)\r\ntty_insert_flip_char(port, 0, TTY_OVERRUN);\r\nignore_char:\r\nicom_port->statStg->rcv[rcv_buff].flags = 0;\r\nicom_port->statStg->rcv[rcv_buff].leLength = 0;\r\nicom_port->statStg->rcv[rcv_buff].WorkingLength =\r\n(unsigned short int) cpu_to_le16(RCV_BUFF_SZ);\r\nrcv_buff++;\r\nif (rcv_buff == NUM_RBUFFS)\r\nrcv_buff = 0;\r\nstatus = cpu_to_le16(icom_port->statStg->rcv[rcv_buff].flags);\r\n}\r\nicom_port->next_rcv = rcv_buff;\r\nspin_unlock(&icom_port->uart_port.lock);\r\ntty_flip_buffer_push(port);\r\nspin_lock(&icom_port->uart_port.lock);\r\n}\r\nstatic void process_interrupt(u16 port_int_reg,\r\nstruct icom_port *icom_port)\r\n{\r\nspin_lock(&icom_port->uart_port.lock);\r\ntrace(icom_port, "INTERRUPT", port_int_reg);\r\nif (port_int_reg & (INT_XMIT_COMPLETED | INT_XMIT_DISABLED))\r\nxmit_interrupt(port_int_reg, icom_port);\r\nif (port_int_reg & INT_RCV_COMPLETED)\r\nrecv_interrupt(port_int_reg, icom_port);\r\nspin_unlock(&icom_port->uart_port.lock);\r\n}\r\nstatic irqreturn_t icom_interrupt(int irq, void *dev_id)\r\n{\r\nvoid __iomem * int_reg;\r\nu32 adapter_interrupts;\r\nu16 port_int_reg;\r\nstruct icom_adapter *icom_adapter;\r\nstruct icom_port *icom_port;\r\nicom_adapter = (struct icom_adapter *) dev_id;\r\nif (icom_adapter->version == ADAPTER_V2) {\r\nint_reg = icom_adapter->base_addr + 0x8024;\r\nadapter_interrupts = readl(int_reg);\r\nif (adapter_interrupts & 0x00003FFF) {\r\nicom_port = &icom_adapter->port_info[2];\r\nport_int_reg = (u16) adapter_interrupts;\r\nprocess_interrupt(port_int_reg, icom_port);\r\ncheck_modem_status(icom_port);\r\n}\r\nif (adapter_interrupts & 0x3FFF0000) {\r\nicom_port = &icom_adapter->port_info[3];\r\nif (icom_port->status == ICOM_PORT_ACTIVE) {\r\nport_int_reg =\r\n(u16) (adapter_interrupts >> 16);\r\nprocess_interrupt(port_int_reg, icom_port);\r\ncheck_modem_status(icom_port);\r\n}\r\n}\r\nwritel(adapter_interrupts, int_reg);\r\nint_reg = icom_adapter->base_addr + 0x8004;\r\n} else {\r\nint_reg = icom_adapter->base_addr + 0x4004;\r\n}\r\nadapter_interrupts = readl(int_reg);\r\nif (adapter_interrupts & 0x00003FFF) {\r\nicom_port = &icom_adapter->port_info[0];\r\nport_int_reg = (u16) adapter_interrupts;\r\nprocess_interrupt(port_int_reg, icom_port);\r\ncheck_modem_status(icom_port);\r\n}\r\nif (adapter_interrupts & 0x3FFF0000) {\r\nicom_port = &icom_adapter->port_info[1];\r\nif (icom_port->status == ICOM_PORT_ACTIVE) {\r\nport_int_reg = (u16) (adapter_interrupts >> 16);\r\nprocess_interrupt(port_int_reg, icom_port);\r\ncheck_modem_status(icom_port);\r\n}\r\n}\r\nwritel(adapter_interrupts, int_reg);\r\nadapter_interrupts = readl(int_reg);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int icom_tx_empty(struct uart_port *port)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (cpu_to_le16(ICOM_PORT->statStg->xmit[0].flags) &\r\nSA_FLAGS_READY_TO_XMIT)\r\nret = TIOCSER_TEMT;\r\nelse\r\nret = 0;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void icom_set_mctrl(struct uart_port *port, unsigned int mctrl)\r\n{\r\nunsigned char local_osr;\r\ntrace(ICOM_PORT, "SET_MODEM", 0);\r\nlocal_osr = readb(&ICOM_PORT->dram->osr);\r\nif (mctrl & TIOCM_RTS) {\r\ntrace(ICOM_PORT, "RAISE_RTS", 0);\r\nlocal_osr |= ICOM_RTS;\r\n} else {\r\ntrace(ICOM_PORT, "LOWER_RTS", 0);\r\nlocal_osr &= ~ICOM_RTS;\r\n}\r\nif (mctrl & TIOCM_DTR) {\r\ntrace(ICOM_PORT, "RAISE_DTR", 0);\r\nlocal_osr |= ICOM_DTR;\r\n} else {\r\ntrace(ICOM_PORT, "LOWER_DTR", 0);\r\nlocal_osr &= ~ICOM_DTR;\r\n}\r\nwriteb(local_osr, &ICOM_PORT->dram->osr);\r\n}\r\nstatic unsigned int icom_get_mctrl(struct uart_port *port)\r\n{\r\nunsigned char status;\r\nunsigned int result;\r\ntrace(ICOM_PORT, "GET_MODEM", 0);\r\nstatus = readb(&ICOM_PORT->dram->isr);\r\nresult = ((status & ICOM_DCD) ? TIOCM_CAR : 0)\r\n| ((status & ICOM_RI) ? TIOCM_RNG : 0)\r\n| ((status & ICOM_DSR) ? TIOCM_DSR : 0)\r\n| ((status & ICOM_CTS) ? TIOCM_CTS : 0);\r\nreturn result;\r\n}\r\nstatic void icom_stop_tx(struct uart_port *port)\r\n{\r\nunsigned char cmdReg;\r\ntrace(ICOM_PORT, "STOP", 0);\r\ncmdReg = readb(&ICOM_PORT->dram->CmdReg);\r\nwriteb(cmdReg | CMD_HOLD_XMIT, &ICOM_PORT->dram->CmdReg);\r\n}\r\nstatic void icom_start_tx(struct uart_port *port)\r\n{\r\nunsigned char cmdReg;\r\ntrace(ICOM_PORT, "START", 0);\r\ncmdReg = readb(&ICOM_PORT->dram->CmdReg);\r\nif ((cmdReg & CMD_HOLD_XMIT) == CMD_HOLD_XMIT)\r\nwriteb(cmdReg & ~CMD_HOLD_XMIT,\r\n&ICOM_PORT->dram->CmdReg);\r\nicom_write(port);\r\n}\r\nstatic void icom_send_xchar(struct uart_port *port, char ch)\r\n{\r\nunsigned char xdata;\r\nint index;\r\nunsigned long flags;\r\ntrace(ICOM_PORT, "SEND_XCHAR", ch);\r\nfor (index = 0; index < 10; index++) {\r\nspin_lock_irqsave(&port->lock, flags);\r\nxdata = readb(&ICOM_PORT->dram->xchar);\r\nif (xdata == 0x00) {\r\ntrace(ICOM_PORT, "QUICK_WRITE", 0);\r\nwriteb(ch, &ICOM_PORT->dram->xchar);\r\nxdata = readb(&ICOM_PORT->dram->xchar);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nmsleep(10);\r\n}\r\n}\r\nstatic void icom_stop_rx(struct uart_port *port)\r\n{\r\nunsigned char cmdReg;\r\ncmdReg = readb(&ICOM_PORT->dram->CmdReg);\r\nwriteb(cmdReg & ~CMD_RCV_ENABLE, &ICOM_PORT->dram->CmdReg);\r\n}\r\nstatic void icom_enable_ms(struct uart_port *port)\r\n{\r\n}\r\nstatic void icom_break(struct uart_port *port, int break_state)\r\n{\r\nunsigned char cmdReg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntrace(ICOM_PORT, "BREAK", 0);\r\ncmdReg = readb(&ICOM_PORT->dram->CmdReg);\r\nif (break_state == -1) {\r\nwriteb(cmdReg | CMD_SND_BREAK, &ICOM_PORT->dram->CmdReg);\r\n} else {\r\nwriteb(cmdReg & ~CMD_SND_BREAK, &ICOM_PORT->dram->CmdReg);\r\n}\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int icom_open(struct uart_port *port)\r\n{\r\nint retval;\r\nkref_get(&ICOM_PORT->adapter->kref);\r\nretval = startup(ICOM_PORT);\r\nif (retval) {\r\nkref_put(&ICOM_PORT->adapter->kref, icom_kref_release);\r\ntrace(ICOM_PORT, "STARTUP_ERROR", 0);\r\nreturn retval;\r\n}\r\nreturn 0;\r\n}\r\nstatic void icom_close(struct uart_port *port)\r\n{\r\nunsigned char cmdReg;\r\ntrace(ICOM_PORT, "CLOSE", 0);\r\ncmdReg = readb(&ICOM_PORT->dram->CmdReg);\r\nwriteb(cmdReg & ~CMD_RCV_ENABLE, &ICOM_PORT->dram->CmdReg);\r\nshutdown(ICOM_PORT);\r\nkref_put(&ICOM_PORT->adapter->kref, icom_kref_release);\r\n}\r\nstatic void icom_set_termios(struct uart_port *port,\r\nstruct ktermios *termios,\r\nstruct ktermios *old_termios)\r\n{\r\nint baud;\r\nunsigned cflag, iflag;\r\nchar new_config2;\r\nchar new_config3 = 0;\r\nchar tmp_byte;\r\nint index;\r\nint rcv_buff, xmit_buff;\r\nunsigned long offset;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\ntrace(ICOM_PORT, "CHANGE_SPEED", 0);\r\ncflag = termios->c_cflag;\r\niflag = termios->c_iflag;\r\nnew_config2 = ICOM_ACFG_DRIVE1;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nnew_config2 |= ICOM_ACFG_5BPC;\r\nbreak;\r\ncase CS6:\r\nnew_config2 |= ICOM_ACFG_6BPC;\r\nbreak;\r\ncase CS7:\r\nnew_config2 |= ICOM_ACFG_7BPC;\r\nbreak;\r\ncase CS8:\r\nnew_config2 |= ICOM_ACFG_8BPC;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (cflag & CSTOPB) {\r\nnew_config2 |= ICOM_ACFG_2STOP_BIT;\r\n}\r\nif (cflag & PARENB) {\r\nnew_config2 |= ICOM_ACFG_PARITY_ENAB;\r\ntrace(ICOM_PORT, "PARENB", 0);\r\n}\r\nif (cflag & PARODD) {\r\nnew_config2 |= ICOM_ACFG_PARITY_ODD;\r\ntrace(ICOM_PORT, "PARODD", 0);\r\n}\r\nbaud = uart_get_baud_rate(port, termios, old_termios,\r\nicom_acfg_baud[0],\r\nicom_acfg_baud[BAUD_TABLE_LIMIT]);\r\nif (!baud)\r\nbaud = 9600;\r\nfor (index = 0; index < BAUD_TABLE_LIMIT; index++) {\r\nif (icom_acfg_baud[index] == baud) {\r\nnew_config3 = index;\r\nbreak;\r\n}\r\n}\r\nuart_update_timeout(port, cflag, baud);\r\ntmp_byte = readb(&(ICOM_PORT->dram->HDLCConfigReg));\r\nif (cflag & CRTSCTS)\r\ntmp_byte |= HDLC_HDW_FLOW;\r\nelse\r\ntmp_byte &= ~HDLC_HDW_FLOW;\r\nwriteb(tmp_byte, &(ICOM_PORT->dram->HDLCConfigReg));\r\nICOM_PORT->read_status_mask = SA_FLAGS_OVERRUN | SA_FL_RCV_DONE;\r\nif (iflag & INPCK)\r\nICOM_PORT->read_status_mask |=\r\nSA_FLAGS_FRAME_ERROR | SA_FLAGS_PARITY_ERROR;\r\nif ((iflag & BRKINT) || (iflag & PARMRK))\r\nICOM_PORT->read_status_mask |= SA_FLAGS_BREAK_DET;\r\nICOM_PORT->ignore_status_mask = 0;\r\nif (iflag & IGNPAR)\r\nICOM_PORT->ignore_status_mask |=\r\nSA_FLAGS_PARITY_ERROR | SA_FLAGS_FRAME_ERROR;\r\nif (iflag & IGNBRK) {\r\nICOM_PORT->ignore_status_mask |= SA_FLAGS_BREAK_DET;\r\nif (iflag & IGNPAR)\r\nICOM_PORT->ignore_status_mask |= SA_FLAGS_OVERRUN;\r\n}\r\nif ((cflag & CREAD) == 0)\r\nICOM_PORT->ignore_status_mask |= SA_FL_RCV_DONE;\r\nwriteb(CMD_RCV_DISABLE, &ICOM_PORT->dram->CmdReg);\r\nfor (index = 0; index < 10; index++) {\r\nif (readb(&ICOM_PORT->dram->PrevCmdReg) == 0x00) {\r\nbreak;\r\n}\r\n}\r\nfor (rcv_buff = 0; rcv_buff < NUM_RBUFFS; rcv_buff++) {\r\nICOM_PORT->statStg->rcv[rcv_buff].flags = 0;\r\nICOM_PORT->statStg->rcv[rcv_buff].leLength = 0;\r\nICOM_PORT->statStg->rcv[rcv_buff].WorkingLength =\r\n(unsigned short int) cpu_to_le16(RCV_BUFF_SZ);\r\n}\r\nfor (xmit_buff = 0; xmit_buff < NUM_XBUFFS; xmit_buff++) {\r\nICOM_PORT->statStg->xmit[xmit_buff].flags = 0;\r\n}\r\nwriteb(new_config3, &(ICOM_PORT->dram->async_config3));\r\nwriteb(new_config2, &(ICOM_PORT->dram->async_config2));\r\ntmp_byte = readb(&(ICOM_PORT->dram->HDLCConfigReg));\r\ntmp_byte |= HDLC_PPP_PURE_ASYNC | HDLC_FF_FILL;\r\nwriteb(tmp_byte, &(ICOM_PORT->dram->HDLCConfigReg));\r\nwriteb(0x04, &(ICOM_PORT->dram->FlagFillIdleTimer));\r\nwriteb(0xFF, &(ICOM_PORT->dram->ier));\r\nwriteb(CMD_RESTART, &ICOM_PORT->dram->CmdReg);\r\nfor (index = 0; index < 10; index++) {\r\nif (readb(&ICOM_PORT->dram->CmdReg) == 0x00) {\r\nbreak;\r\n}\r\n}\r\noffset =\r\n(unsigned long) &ICOM_PORT->statStg->rcv[0] -\r\n(unsigned long) ICOM_PORT->statStg;\r\nwritel(ICOM_PORT->statStg_pci + offset,\r\n&ICOM_PORT->dram->RcvStatusAddr);\r\nICOM_PORT->next_rcv = 0;\r\nICOM_PORT->put_length = 0;\r\n*ICOM_PORT->xmitRestart = 0;\r\nwritel(ICOM_PORT->xmitRestart_pci,\r\n&ICOM_PORT->dram->XmitStatusAddr);\r\ntrace(ICOM_PORT, "XR_ENAB", 0);\r\nwriteb(CMD_XMIT_RCV_ENABLE, &ICOM_PORT->dram->CmdReg);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic const char *icom_type(struct uart_port *port)\r\n{\r\nreturn "icom";\r\n}\r\nstatic void icom_release_port(struct uart_port *port)\r\n{\r\n}\r\nstatic int icom_request_port(struct uart_port *port)\r\n{\r\nreturn 0;\r\n}\r\nstatic void icom_config_port(struct uart_port *port, int flags)\r\n{\r\nport->type = PORT_ICOM;\r\n}\r\nstatic int icom_init_ports(struct icom_adapter *icom_adapter)\r\n{\r\nu32 subsystem_id = icom_adapter->subsystem_id;\r\nint i;\r\nstruct icom_port *icom_port;\r\nif (icom_adapter->version == ADAPTER_V1) {\r\nicom_adapter->numb_ports = 2;\r\nfor (i = 0; i < 2; i++) {\r\nicom_port = &icom_adapter->port_info[i];\r\nicom_port->port = i;\r\nicom_port->status = ICOM_PORT_ACTIVE;\r\nicom_port->imbed_modem = ICOM_UNKNOWN;\r\n}\r\n} else {\r\nif (subsystem_id == PCI_DEVICE_ID_IBM_ICOM_FOUR_PORT_MODEL) {\r\nicom_adapter->numb_ports = 4;\r\nfor (i = 0; i < 4; i++) {\r\nicom_port = &icom_adapter->port_info[i];\r\nicom_port->port = i;\r\nicom_port->status = ICOM_PORT_ACTIVE;\r\nicom_port->imbed_modem = ICOM_IMBED_MODEM;\r\n}\r\n} else {\r\nicom_adapter->numb_ports = 4;\r\nicom_adapter->port_info[0].port = 0;\r\nicom_adapter->port_info[0].status = ICOM_PORT_ACTIVE;\r\nif (subsystem_id ==\r\nPCI_DEVICE_ID_IBM_ICOM_V2_ONE_PORT_RVX_ONE_PORT_MDM) {\r\nicom_adapter->port_info[0].imbed_modem = ICOM_IMBED_MODEM;\r\n} else {\r\nicom_adapter->port_info[0].imbed_modem = ICOM_RVX;\r\n}\r\nicom_adapter->port_info[1].status = ICOM_PORT_OFF;\r\nicom_adapter->port_info[2].port = 2;\r\nicom_adapter->port_info[2].status = ICOM_PORT_ACTIVE;\r\nicom_adapter->port_info[2].imbed_modem = ICOM_RVX;\r\nicom_adapter->port_info[3].status = ICOM_PORT_OFF;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void icom_port_active(struct icom_port *icom_port, struct icom_adapter *icom_adapter, int port_num)\r\n{\r\nif (icom_adapter->version == ADAPTER_V1) {\r\nicom_port->global_reg = icom_adapter->base_addr + 0x4000;\r\nicom_port->int_reg = icom_adapter->base_addr +\r\n0x4004 + 2 - 2 * port_num;\r\n} else {\r\nicom_port->global_reg = icom_adapter->base_addr + 0x8000;\r\nif (icom_port->port < 2)\r\nicom_port->int_reg = icom_adapter->base_addr +\r\n0x8004 + 2 - 2 * icom_port->port;\r\nelse\r\nicom_port->int_reg = icom_adapter->base_addr +\r\n0x8024 + 2 - 2 * (icom_port->port - 2);\r\n}\r\n}\r\nstatic int icom_load_ports(struct icom_adapter *icom_adapter)\r\n{\r\nstruct icom_port *icom_port;\r\nint port_num;\r\nfor (port_num = 0; port_num < icom_adapter->numb_ports; port_num++) {\r\nicom_port = &icom_adapter->port_info[port_num];\r\nif (icom_port->status == ICOM_PORT_ACTIVE) {\r\nicom_port_active(icom_port, icom_adapter, port_num);\r\nicom_port->dram = icom_adapter->base_addr +\r\n0x2000 * icom_port->port;\r\nicom_port->adapter = icom_adapter;\r\nif (get_port_memory(icom_port) != 0) {\r\ndev_err(&icom_port->adapter->pci_dev->dev,\r\n"Memory allocation for port FAILED\n");\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int icom_alloc_adapter(struct icom_adapter\r\n**icom_adapter_ref)\r\n{\r\nint adapter_count = 0;\r\nstruct icom_adapter *icom_adapter;\r\nstruct icom_adapter *cur_adapter_entry;\r\nstruct list_head *tmp;\r\nicom_adapter = kzalloc(sizeof(struct icom_adapter), GFP_KERNEL);\r\nif (!icom_adapter) {\r\nreturn -ENOMEM;\r\n}\r\nlist_for_each(tmp, &icom_adapter_head) {\r\ncur_adapter_entry =\r\nlist_entry(tmp, struct icom_adapter,\r\nicom_adapter_entry);\r\nif (cur_adapter_entry->index != adapter_count) {\r\nbreak;\r\n}\r\nadapter_count++;\r\n}\r\nicom_adapter->index = adapter_count;\r\nlist_add_tail(&icom_adapter->icom_adapter_entry, tmp);\r\n*icom_adapter_ref = icom_adapter;\r\nreturn 0;\r\n}\r\nstatic void icom_free_adapter(struct icom_adapter *icom_adapter)\r\n{\r\nlist_del(&icom_adapter->icom_adapter_entry);\r\nkfree(icom_adapter);\r\n}\r\nstatic void icom_remove_adapter(struct icom_adapter *icom_adapter)\r\n{\r\nstruct icom_port *icom_port;\r\nint index;\r\nfor (index = 0; index < icom_adapter->numb_ports; index++) {\r\nicom_port = &icom_adapter->port_info[index];\r\nif (icom_port->status == ICOM_PORT_ACTIVE) {\r\ndev_info(&icom_adapter->pci_dev->dev,\r\n"Device removed\n");\r\nuart_remove_one_port(&icom_uart_driver,\r\n&icom_port->uart_port);\r\nwriteb(0x00, &icom_port->dram->osr);\r\nmsleep(100);\r\nstop_processor(icom_port);\r\nfree_port_memory(icom_port);\r\n}\r\n}\r\nfree_irq(icom_adapter->pci_dev->irq, (void *) icom_adapter);\r\niounmap(icom_adapter->base_addr);\r\npci_release_regions(icom_adapter->pci_dev);\r\nicom_free_adapter(icom_adapter);\r\n}\r\nstatic void icom_kref_release(struct kref *kref)\r\n{\r\nstruct icom_adapter *icom_adapter;\r\nicom_adapter = to_icom_adapter(kref);\r\nicom_remove_adapter(icom_adapter);\r\n}\r\nstatic int icom_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *ent)\r\n{\r\nint index;\r\nunsigned int command_reg;\r\nint retval;\r\nstruct icom_adapter *icom_adapter;\r\nstruct icom_port *icom_port;\r\nretval = pci_enable_device(dev);\r\nif (retval) {\r\ndev_err(&dev->dev, "Device enable FAILED\n");\r\nreturn retval;\r\n}\r\nif ( (retval = pci_request_regions(dev, "icom"))) {\r\ndev_err(&dev->dev, "pci_request_regions FAILED\n");\r\npci_disable_device(dev);\r\nreturn retval;\r\n}\r\npci_set_master(dev);\r\nif ( (retval = pci_read_config_dword(dev, PCI_COMMAND, &command_reg))) {\r\ndev_err(&dev->dev, "PCI Config read FAILED\n");\r\nreturn retval;\r\n}\r\npci_write_config_dword(dev, PCI_COMMAND,\r\ncommand_reg | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER\r\n| PCI_COMMAND_PARITY | PCI_COMMAND_SERR);\r\nif (ent->driver_data == ADAPTER_V1) {\r\npci_write_config_dword(dev, 0x44, 0x8300830A);\r\n} else {\r\npci_write_config_dword(dev, 0x44, 0x42004200);\r\npci_write_config_dword(dev, 0x48, 0x42004200);\r\n}\r\nretval = icom_alloc_adapter(&icom_adapter);\r\nif (retval) {\r\ndev_err(&dev->dev, "icom_alloc_adapter FAILED\n");\r\nretval = -EIO;\r\ngoto probe_exit0;\r\n}\r\nicom_adapter->base_addr_pci = pci_resource_start(dev, 0);\r\nicom_adapter->pci_dev = dev;\r\nicom_adapter->version = ent->driver_data;\r\nicom_adapter->subsystem_id = ent->subdevice;\r\nretval = icom_init_ports(icom_adapter);\r\nif (retval) {\r\ndev_err(&dev->dev, "Port configuration failed\n");\r\ngoto probe_exit1;\r\n}\r\nicom_adapter->base_addr = pci_ioremap_bar(dev, 0);\r\nif (!icom_adapter->base_addr)\r\ngoto probe_exit1;\r\nif ( (retval = request_irq(dev->irq, icom_interrupt,\r\nIRQF_SHARED, ICOM_DRIVER_NAME,\r\n(void *) icom_adapter))) {\r\ngoto probe_exit2;\r\n}\r\nretval = icom_load_ports(icom_adapter);\r\nfor (index = 0; index < icom_adapter->numb_ports; index++) {\r\nicom_port = &icom_adapter->port_info[index];\r\nif (icom_port->status == ICOM_PORT_ACTIVE) {\r\nicom_port->uart_port.irq = icom_port->adapter->pci_dev->irq;\r\nicom_port->uart_port.type = PORT_ICOM;\r\nicom_port->uart_port.iotype = UPIO_MEM;\r\nicom_port->uart_port.membase =\r\n(unsigned char __iomem *)icom_adapter->base_addr_pci;\r\nicom_port->uart_port.fifosize = 16;\r\nicom_port->uart_port.ops = &icom_ops;\r\nicom_port->uart_port.line =\r\nicom_port->port + icom_adapter->index * 4;\r\nif (uart_add_one_port (&icom_uart_driver, &icom_port->uart_port)) {\r\nicom_port->status = ICOM_PORT_OFF;\r\ndev_err(&dev->dev, "Device add failed\n");\r\n} else\r\ndev_info(&dev->dev, "Device added\n");\r\n}\r\n}\r\nkref_init(&icom_adapter->kref);\r\nreturn 0;\r\nprobe_exit2:\r\niounmap(icom_adapter->base_addr);\r\nprobe_exit1:\r\nicom_free_adapter(icom_adapter);\r\nprobe_exit0:\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\nreturn retval;\r\n}\r\nstatic void icom_remove(struct pci_dev *dev)\r\n{\r\nstruct icom_adapter *icom_adapter;\r\nstruct list_head *tmp;\r\nlist_for_each(tmp, &icom_adapter_head) {\r\nicom_adapter = list_entry(tmp, struct icom_adapter,\r\nicom_adapter_entry);\r\nif (icom_adapter->pci_dev == dev) {\r\nkref_put(&icom_adapter->kref, icom_kref_release);\r\nreturn;\r\n}\r\n}\r\ndev_err(&dev->dev, "Unable to find device to remove\n");\r\n}\r\nstatic int __init icom_init(void)\r\n{\r\nint ret;\r\nspin_lock_init(&icom_lock);\r\nret = uart_register_driver(&icom_uart_driver);\r\nif (ret)\r\nreturn ret;\r\nret = pci_register_driver(&icom_pci_driver);\r\nif (ret < 0)\r\nuart_unregister_driver(&icom_uart_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit icom_exit(void)\r\n{\r\npci_unregister_driver(&icom_pci_driver);\r\nuart_unregister_driver(&icom_uart_driver);\r\n}
