static inline int\r\nsuperio_inb(int base, int reg)\r\n{\r\noutb(reg, base);\r\nreturn inb(base + 1);\r\n}\r\nstatic int\r\nsuperio_inw(int base, int reg)\r\n{\r\nint val;\r\noutb(reg++, base);\r\nval = inb(base + 1) << 8;\r\noutb(reg, base);\r\nval |= inb(base + 1);\r\nreturn val;\r\n}\r\nstatic inline void\r\nsuperio_select(int base, int ld)\r\n{\r\noutb(SIO_REG_LDSEL, base);\r\noutb(ld, base + 1);\r\n}\r\nstatic inline void\r\nsuperio_enter(int base)\r\n{\r\noutb(0x87, base);\r\noutb(0x87, base);\r\n}\r\nstatic inline void\r\nsuperio_exit(int base)\r\n{\r\noutb(0xaa, base);\r\n}\r\nstatic inline long in_from_reg(u8 reg)\r\n{\r\nreturn reg * 8;\r\n}\r\nstatic inline u8 in_to_reg(long val)\r\n{\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 2016)\r\nreturn 0xfc;\r\nreturn ((val + 16) / 32) << 2;\r\n}\r\nstatic inline long in0_from_reg(u8 reg)\r\n{\r\nreturn reg * 16;\r\n}\r\nstatic inline u8 in0_to_reg(long val)\r\n{\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 4032)\r\nreturn 0xfc;\r\nreturn ((val + 32) / 64) << 2;\r\n}\r\nstatic inline long fan_from_reg(u16 reg)\r\n{\r\nreg &= 0xfff;\r\nif (!reg || reg == 0xfff)\r\nreturn 0;\r\nreturn 1500000 / reg;\r\n}\r\nstatic inline u16 fan_to_reg(long rpm)\r\n{\r\nif (rpm < 367)\r\nreturn 0xfff;\r\nreturn 1500000 / rpm;\r\n}\r\nstatic inline unsigned long pwm_freq_from_reg(u8 reg)\r\n{\r\nunsigned long clock = (reg & 0x80) ? 48000000UL : 1000000UL;\r\nreg &= 0x7f;\r\nif (reg == 0)\r\nreg++;\r\nreturn clock / (reg << 8);\r\n}\r\nstatic inline u8 pwm_freq_to_reg(unsigned long val)\r\n{\r\nif (val >= 187500)\r\nreturn 0x80;\r\nif (val >= 1475)\r\nreturn 0x80 | (48000000UL / (val << 8));\r\nif (val < 31)\r\nreturn 0x7f;\r\nelse\r\nreturn 1000000UL / (val << 8);\r\n}\r\nstatic inline int pwm_mode_from_reg(u8 reg)\r\n{\r\nreturn !(reg & FAN_CTRL_DC_MODE);\r\n}\r\nstatic inline long temp_from_reg(u8 reg)\r\n{\r\nreturn reg * 1000;\r\n}\r\nstatic inline u8 temp_to_reg(long val)\r\n{\r\nif (val <= 0)\r\nreturn 0;\r\nif (val >= 1000 * 0xff)\r\nreturn 0xff;\r\nreturn (val + 500) / 1000;\r\n}\r\nstatic u8 f71805f_read8(struct f71805f_data *data, u8 reg)\r\n{\r\noutb(reg, data->addr + ADDR_REG_OFFSET);\r\nreturn inb(data->addr + DATA_REG_OFFSET);\r\n}\r\nstatic void f71805f_write8(struct f71805f_data *data, u8 reg, u8 val)\r\n{\r\noutb(reg, data->addr + ADDR_REG_OFFSET);\r\noutb(val, data->addr + DATA_REG_OFFSET);\r\n}\r\nstatic u16 f71805f_read16(struct f71805f_data *data, u8 reg)\r\n{\r\nu16 val;\r\noutb(reg, data->addr + ADDR_REG_OFFSET);\r\nval = inb(data->addr + DATA_REG_OFFSET) << 8;\r\noutb(++reg, data->addr + ADDR_REG_OFFSET);\r\nval |= inb(data->addr + DATA_REG_OFFSET);\r\nreturn val;\r\n}\r\nstatic void f71805f_write16(struct f71805f_data *data, u8 reg, u16 val)\r\n{\r\noutb(reg, data->addr + ADDR_REG_OFFSET);\r\noutb(val >> 8, data->addr + DATA_REG_OFFSET);\r\noutb(++reg, data->addr + ADDR_REG_OFFSET);\r\noutb(val & 0xff, data->addr + DATA_REG_OFFSET);\r\n}\r\nstatic struct f71805f_data *f71805f_update_device(struct device *dev)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nint nr, apnr;\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + 60 * HZ)\r\n|| !data->valid) {\r\nfor (nr = 0; nr < 11; nr++) {\r\nif (!(data->has_in & (1 << nr)))\r\ncontinue;\r\ndata->in_high[nr] = f71805f_read8(data,\r\nF71805F_REG_IN_HIGH(nr));\r\ndata->in_low[nr] = f71805f_read8(data,\r\nF71805F_REG_IN_LOW(nr));\r\n}\r\nfor (nr = 0; nr < 3; nr++) {\r\ndata->fan_low[nr] = f71805f_read16(data,\r\nF71805F_REG_FAN_LOW(nr));\r\ndata->fan_target[nr] = f71805f_read16(data,\r\nF71805F_REG_FAN_TARGET(nr));\r\ndata->pwm_freq[nr] = f71805f_read8(data,\r\nF71805F_REG_PWM_FREQ(nr));\r\n}\r\nfor (nr = 0; nr < 3; nr++) {\r\ndata->temp_high[nr] = f71805f_read8(data,\r\nF71805F_REG_TEMP_HIGH(nr));\r\ndata->temp_hyst[nr] = f71805f_read8(data,\r\nF71805F_REG_TEMP_HYST(nr));\r\n}\r\ndata->temp_mode = f71805f_read8(data, F71805F_REG_TEMP_MODE);\r\nfor (nr = 0; nr < 3; nr++) {\r\nfor (apnr = 0; apnr < 3; apnr++) {\r\ndata->auto_points[nr].temp[apnr] =\r\nf71805f_read8(data,\r\nF71805F_REG_PWM_AUTO_POINT_TEMP(nr,\r\napnr));\r\ndata->auto_points[nr].fan[apnr] =\r\nf71805f_read16(data,\r\nF71805F_REG_PWM_AUTO_POINT_FAN(nr,\r\napnr));\r\n}\r\n}\r\ndata->last_limits = jiffies;\r\n}\r\nif (time_after(jiffies, data->last_updated + HZ)\r\n|| !data->valid) {\r\nfor (nr = 0; nr < 11; nr++) {\r\nif (!(data->has_in & (1 << nr)))\r\ncontinue;\r\ndata->in[nr] = f71805f_read8(data,\r\nF71805F_REG_IN(nr));\r\n}\r\nfor (nr = 0; nr < 3; nr++) {\r\ndata->fan[nr] = f71805f_read16(data,\r\nF71805F_REG_FAN(nr));\r\ndata->fan_ctrl[nr] = f71805f_read8(data,\r\nF71805F_REG_FAN_CTRL(nr));\r\ndata->pwm[nr] = f71805f_read8(data,\r\nF71805F_REG_PWM_DUTY(nr));\r\n}\r\nfor (nr = 0; nr < 3; nr++) {\r\ndata->temp[nr] = f71805f_read8(data,\r\nF71805F_REG_TEMP(nr));\r\n}\r\ndata->alarms = f71805f_read8(data, F71805F_REG_STATUS(0))\r\n+ (f71805f_read8(data, F71805F_REG_STATUS(1)) << 8)\r\n+ (f71805f_read8(data, F71805F_REG_STATUS(2)) << 16);\r\ndata->last_updated = jiffies;\r\ndata->valid = 1;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t show_in0(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", in0_from_reg(data->in[nr]));\r\n}\r\nstatic ssize_t show_in0_max(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", in0_from_reg(data->in_high[nr]));\r\n}\r\nstatic ssize_t show_in0_min(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", in0_from_reg(data->in_low[nr]));\r\n}\r\nstatic ssize_t set_in0_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_high[nr] = in0_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_IN_HIGH(nr), data->in_high[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_in0_min(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_low[nr] = in0_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_IN_LOW(nr), data->in_low[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", in_from_reg(data->in[nr]));\r\n}\r\nstatic ssize_t show_in_max(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", in_from_reg(data->in_high[nr]));\r\n}\r\nstatic ssize_t show_in_min(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", in_from_reg(data->in_low[nr]));\r\n}\r\nstatic ssize_t set_in_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_high[nr] = in_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_IN_HIGH(nr), data->in_high[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_in_min(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->in_low[nr] = in_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_IN_LOW(nr), data->in_low[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", fan_from_reg(data->fan[nr]));\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", fan_from_reg(data->fan_low[nr]));\r\n}\r\nstatic ssize_t show_fan_target(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", fan_from_reg(data->fan_target[nr]));\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_low[nr] = fan_to_reg(val);\r\nf71805f_write16(data, F71805F_REG_FAN_LOW(nr), data->fan_low[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_target(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->fan_target[nr] = fan_to_reg(val);\r\nf71805f_write16(data, F71805F_REG_FAN_TARGET(nr),\r\ndata->fan_target[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", (int)data->pwm[nr]);\r\n}\r\nstatic ssize_t show_pwm_enable(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nint mode;\r\nswitch (data->fan_ctrl[nr] & FAN_CTRL_MODE_MASK) {\r\ncase FAN_CTRL_MODE_SPEED:\r\nmode = 3;\r\nbreak;\r\ncase FAN_CTRL_MODE_TEMPERATURE:\r\nmode = 2;\r\nbreak;\r\ndefault:\r\nmode = 1;\r\n}\r\nreturn sprintf(buf, "%d\n", mode);\r\n}\r\nstatic ssize_t show_pwm_freq(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%lu\n", pwm_freq_from_reg(data->pwm_freq[nr]));\r\n}\r\nstatic ssize_t show_pwm_mode(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%d\n", pwm_mode_from_reg(data->fan_ctrl[nr]));\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] = val;\r\nf71805f_write8(data, F71805F_REG_PWM_DUTY(nr), data->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm_enable(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nu8 reg;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val < 1 || val > 3)\r\nreturn -EINVAL;\r\nif (val > 1) {\r\nif (sysfs_chmod_file(&dev->kobj, f71805f_attr_pwm[nr],\r\nS_IRUGO))\r\ndev_dbg(dev, "chmod -w pwm%d failed\n", nr + 1);\r\n}\r\nmutex_lock(&data->update_lock);\r\nreg = f71805f_read8(data, F71805F_REG_FAN_CTRL(nr))\r\n& ~FAN_CTRL_MODE_MASK;\r\nswitch (val) {\r\ncase 1:\r\nreg |= FAN_CTRL_MODE_MANUAL;\r\nbreak;\r\ncase 2:\r\nreg |= FAN_CTRL_MODE_TEMPERATURE;\r\nbreak;\r\ncase 3:\r\nreg |= FAN_CTRL_MODE_SPEED;\r\nbreak;\r\n}\r\ndata->fan_ctrl[nr] = reg;\r\nf71805f_write8(data, F71805F_REG_FAN_CTRL(nr), reg);\r\nmutex_unlock(&data->update_lock);\r\nif (val == 1) {\r\nif (sysfs_chmod_file(&dev->kobj, f71805f_attr_pwm[nr],\r\nS_IRUGO | S_IWUSR))\r\ndev_dbg(dev, "chmod +w pwm%d failed\n", nr + 1);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm_freq(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm_freq[nr] = pwm_freq_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_PWM_FREQ(nr), data->pwm_freq[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nint pwmnr = attr->nr;\r\nint apnr = attr->index;\r\nreturn sprintf(buf, "%ld\n",\r\ntemp_from_reg(data->auto_points[pwmnr].temp[apnr]));\r\n}\r\nstatic ssize_t set_pwm_auto_point_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nint pwmnr = attr->nr;\r\nint apnr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->auto_points[pwmnr].temp[apnr] = temp_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_PWM_AUTO_POINT_TEMP(pwmnr, apnr),\r\ndata->auto_points[pwmnr].temp[apnr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_point_fan(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nint pwmnr = attr->nr;\r\nint apnr = attr->index;\r\nreturn sprintf(buf, "%ld\n",\r\nfan_from_reg(data->auto_points[pwmnr].fan[apnr]));\r\n}\r\nstatic ssize_t set_pwm_auto_point_fan(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute_2 *attr = to_sensor_dev_attr_2(devattr);\r\nint pwmnr = attr->nr;\r\nint apnr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->auto_points[pwmnr].fan[apnr] = fan_to_reg(val);\r\nf71805f_write16(data, F71805F_REG_PWM_AUTO_POINT_FAN(pwmnr, apnr),\r\ndata->auto_points[pwmnr].fan[apnr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg(data->temp[nr]));\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg(data->temp_high[nr]));\r\n}\r\nstatic ssize_t show_temp_hyst(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%ld\n", temp_from_reg(data->temp_hyst[nr]));\r\n}\r\nstatic ssize_t show_temp_type(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nreturn sprintf(buf, "%u\n", (data->temp_mode & (1 << nr)) ? 3 : 4);\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_high[nr] = temp_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_TEMP_HIGH(nr), data->temp_high[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_temp_hyst(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\ndata->temp_hyst[nr] = temp_to_reg(val);\r\nf71805f_write8(data, F71805F_REG_TEMP_HYST(nr), data->temp_hyst[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarms_in(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nreturn sprintf(buf, "%lu\n", data->alarms & 0x7ff);\r\n}\r\nstatic ssize_t show_alarms_fan(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nreturn sprintf(buf, "%lu\n", (data->alarms >> 16) & 0x07);\r\n}\r\nstatic ssize_t show_alarms_temp(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nreturn sprintf(buf, "%lu\n", (data->alarms >> 11) & 0x07);\r\n}\r\nstatic ssize_t show_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = f71805f_update_device(dev);\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nint bitnr = attr->index;\r\nreturn sprintf(buf, "%lu\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t show_name(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct f71805f_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic void f71805f_init_device(struct f71805f_data *data)\r\n{\r\nu8 reg;\r\nint i;\r\nreg = f71805f_read8(data, F71805F_REG_START);\r\nif ((reg & 0x41) != 0x01) {\r\npr_debug("Starting monitoring operations\n");\r\nf71805f_write8(data, F71805F_REG_START, (reg | 0x01) & ~0x40);\r\n}\r\nfor (i = 0; i < 3; i++) {\r\ndata->fan_ctrl[i] = f71805f_read8(data,\r\nF71805F_REG_FAN_CTRL(i));\r\nif (data->fan_ctrl[i] & FAN_CTRL_LATCH_FULL) {\r\ndata->fan_ctrl[i] &= ~FAN_CTRL_LATCH_FULL;\r\nf71805f_write8(data, F71805F_REG_FAN_CTRL(i),\r\ndata->fan_ctrl[i]);\r\n}\r\n}\r\n}\r\nstatic int f71805f_probe(struct platform_device *pdev)\r\n{\r\nstruct f71805f_sio_data *sio_data = dev_get_platdata(&pdev->dev);\r\nstruct f71805f_data *data;\r\nstruct resource *res;\r\nint i, err;\r\nstatic const char * const names[] = {\r\n"f71805f",\r\n"f71872f",\r\n};\r\ndata = devm_kzalloc(&pdev->dev, sizeof(struct f71805f_data),\r\nGFP_KERNEL);\r\nif (!data) {\r\npr_err("Out of memory\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nif (!devm_request_region(&pdev->dev, res->start + ADDR_REG_OFFSET, 2,\r\nDRVNAME)) {\r\ndev_err(&pdev->dev, "Failed to request region 0x%lx-0x%lx\n",\r\n(unsigned long)(res->start + ADDR_REG_OFFSET),\r\n(unsigned long)(res->start + ADDR_REG_OFFSET + 1));\r\nreturn -EBUSY;\r\n}\r\ndata->addr = res->start;\r\ndata->name = names[sio_data->kind];\r\nmutex_init(&data->update_lock);\r\nplatform_set_drvdata(pdev, data);\r\nswitch (sio_data->kind) {\r\ncase f71805f:\r\ndata->has_in = 0x1ff;\r\nbreak;\r\ncase f71872f:\r\ndata->has_in = 0x6ef;\r\nif (sio_data->fnsel1 & 0x01)\r\ndata->has_in |= (1 << 4);\r\nif (sio_data->fnsel1 & 0x02)\r\ndata->has_in |= (1 << 8);\r\nbreak;\r\n}\r\nf71805f_init_device(data);\r\nerr = sysfs_create_group(&pdev->dev.kobj, &f71805f_group);\r\nif (err)\r\nreturn err;\r\nif (data->has_in & (1 << 4)) {\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&f71805f_group_optin[0]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nif (data->has_in & (1 << 8)) {\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&f71805f_group_optin[1]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nif (data->has_in & (1 << 9)) {\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&f71805f_group_optin[2]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nif (data->has_in & (1 << 10)) {\r\nerr = sysfs_create_group(&pdev->dev.kobj,\r\n&f71805f_group_optin[3]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nif (!(data->fan_ctrl[i] & FAN_CTRL_DC_MODE)) {\r\nerr = sysfs_create_file(&pdev->dev.kobj,\r\nf71805f_attributes_pwm_freq[i]);\r\nif (err)\r\ngoto exit_remove_files;\r\n}\r\nif (data->fan_ctrl[i] & FAN_CTRL_MODE_MANUAL) {\r\nerr = sysfs_chmod_file(&pdev->dev.kobj,\r\nf71805f_attr_pwm[i],\r\nS_IRUGO | S_IWUSR);\r\nif (err) {\r\ndev_err(&pdev->dev, "chmod +w pwm%d failed\n",\r\ni + 1);\r\ngoto exit_remove_files;\r\n}\r\n}\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&pdev->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ndev_err(&pdev->dev, "Class registration failed (%d)\n", err);\r\ngoto exit_remove_files;\r\n}\r\nreturn 0;\r\nexit_remove_files:\r\nsysfs_remove_group(&pdev->dev.kobj, &f71805f_group);\r\nfor (i = 0; i < 4; i++)\r\nsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_optin[i]);\r\nsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_pwm_freq);\r\nreturn err;\r\n}\r\nstatic int f71805f_remove(struct platform_device *pdev)\r\n{\r\nstruct f71805f_data *data = platform_get_drvdata(pdev);\r\nint i;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsysfs_remove_group(&pdev->dev.kobj, &f71805f_group);\r\nfor (i = 0; i < 4; i++)\r\nsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_optin[i]);\r\nsysfs_remove_group(&pdev->dev.kobj, &f71805f_group_pwm_freq);\r\nreturn 0;\r\n}\r\nstatic int __init f71805f_device_add(unsigned short address,\r\nconst struct f71805f_sio_data *sio_data)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + REGION_LENGTH - 1,\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\npdev = platform_device_alloc(DRVNAME, address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\nres.name = pdev->name;\r\nerr = acpi_check_resource_conflict(&res);\r\nif (err)\r\ngoto exit_device_put;\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add_data(pdev, sio_data,\r\nsizeof(struct f71805f_sio_data));\r\nif (err) {\r\npr_err("Platform data allocation failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __init f71805f_find(int sioaddr, unsigned short *address,\r\nstruct f71805f_sio_data *sio_data)\r\n{\r\nint err = -ENODEV;\r\nu16 devid;\r\nstatic const char * const names[] = {\r\n"F71805F/FG",\r\n"F71872F/FG or F71806F/FG",\r\n};\r\nsuperio_enter(sioaddr);\r\ndevid = superio_inw(sioaddr, SIO_REG_MANID);\r\nif (devid != SIO_FINTEK_ID)\r\ngoto exit;\r\ndevid = force_id ? force_id : superio_inw(sioaddr, SIO_REG_DEVID);\r\nswitch (devid) {\r\ncase SIO_F71805F_ID:\r\nsio_data->kind = f71805f;\r\nbreak;\r\ncase SIO_F71872F_ID:\r\nsio_data->kind = f71872f;\r\nsio_data->fnsel1 = superio_inb(sioaddr, SIO_REG_FNSEL1);\r\nbreak;\r\ndefault:\r\npr_info("Unsupported Fintek device, skipping\n");\r\ngoto exit;\r\n}\r\nsuperio_select(sioaddr, F71805F_LD_HWM);\r\nif (!(superio_inb(sioaddr, SIO_REG_ENABLE) & 0x01)) {\r\npr_warn("Device not activated, skipping\n");\r\ngoto exit;\r\n}\r\n*address = superio_inw(sioaddr, SIO_REG_ADDR);\r\nif (*address == 0) {\r\npr_warn("Base address not set, skipping\n");\r\ngoto exit;\r\n}\r\n*address &= ~(REGION_LENGTH - 1);\r\nerr = 0;\r\npr_info("Found %s chip at %#x, revision %u\n",\r\nnames[sio_data->kind], *address,\r\nsuperio_inb(sioaddr, SIO_REG_DEVREV));\r\nexit:\r\nsuperio_exit(sioaddr);\r\nreturn err;\r\n}\r\nstatic int __init f71805f_init(void)\r\n{\r\nint err;\r\nunsigned short address;\r\nstruct f71805f_sio_data sio_data;\r\nif (f71805f_find(0x2e, &address, &sio_data)\r\n&& f71805f_find(0x4e, &address, &sio_data))\r\nreturn -ENODEV;\r\nerr = platform_driver_register(&f71805f_driver);\r\nif (err)\r\ngoto exit;\r\nerr = f71805f_device_add(address, &sio_data);\r\nif (err)\r\ngoto exit_driver;\r\nreturn 0;\r\nexit_driver:\r\nplatform_driver_unregister(&f71805f_driver);\r\nexit:\r\nreturn err;\r\n}\r\nstatic void __exit f71805f_exit(void)\r\n{\r\nplatform_device_unregister(pdev);\r\nplatform_driver_unregister(&f71805f_driver);\r\n}
