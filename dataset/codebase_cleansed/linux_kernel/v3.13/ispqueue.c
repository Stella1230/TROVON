static void isp_video_buffer_cache_sync(struct isp_video_buffer *buf)\r\n{\r\nif (buf->skip_cache)\r\nreturn;\r\nif (buf->vbuf.m.userptr == 0 || buf->npages == 0 ||\r\nbuf->npages > ISP_CACHE_FLUSH_PAGES_MAX)\r\nflush_cache_all();\r\nelse {\r\ndmac_map_area((void *)buf->vbuf.m.userptr, buf->vbuf.length,\r\nDMA_FROM_DEVICE);\r\nouter_inv_range(buf->vbuf.m.userptr,\r\nbuf->vbuf.m.userptr + buf->vbuf.length);\r\n}\r\n}\r\nstatic int isp_video_buffer_lock_vma(struct isp_video_buffer *buf, int lock)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long start;\r\nunsigned long end;\r\nint ret = 0;\r\nif (buf->vbuf.memory == V4L2_MEMORY_MMAP)\r\nreturn 0;\r\nif (!current || !current->mm)\r\nreturn lock ? -EINVAL : 0;\r\nstart = buf->vbuf.m.userptr;\r\nend = buf->vbuf.m.userptr + buf->vbuf.length - 1;\r\ndown_write(&current->mm->mmap_sem);\r\nspin_lock(&current->mm->page_table_lock);\r\ndo {\r\nvma = find_vma(current->mm, start);\r\nif (vma == NULL) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nif (lock)\r\nvma->vm_flags |= VM_LOCKED;\r\nelse\r\nvma->vm_flags &= ~VM_LOCKED;\r\nstart = vma->vm_end + 1;\r\n} while (vma->vm_end < end);\r\nif (lock)\r\nbuf->vm_flags |= VM_LOCKED;\r\nelse\r\nbuf->vm_flags &= ~VM_LOCKED;\r\nout:\r\nspin_unlock(&current->mm->page_table_lock);\r\nup_write(&current->mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic int isp_video_buffer_sglist_kernel(struct isp_video_buffer *buf)\r\n{\r\nstruct scatterlist *sglist;\r\nunsigned int npages;\r\nunsigned int i;\r\nvoid *addr;\r\naddr = buf->vaddr;\r\nnpages = PAGE_ALIGN(buf->vbuf.length) >> PAGE_SHIFT;\r\nsglist = vmalloc(npages * sizeof(*sglist));\r\nif (sglist == NULL)\r\nreturn -ENOMEM;\r\nsg_init_table(sglist, npages);\r\nfor (i = 0; i < npages; ++i, addr += PAGE_SIZE) {\r\nstruct page *page = vmalloc_to_page(addr);\r\nif (page == NULL || PageHighMem(page)) {\r\nvfree(sglist);\r\nreturn -EINVAL;\r\n}\r\nsg_set_page(&sglist[i], page, PAGE_SIZE, 0);\r\n}\r\nbuf->sglen = npages;\r\nbuf->sglist = sglist;\r\nreturn 0;\r\n}\r\nstatic int isp_video_buffer_sglist_user(struct isp_video_buffer *buf)\r\n{\r\nstruct scatterlist *sglist;\r\nunsigned int offset = buf->offset;\r\nunsigned int i;\r\nsglist = vmalloc(buf->npages * sizeof(*sglist));\r\nif (sglist == NULL)\r\nreturn -ENOMEM;\r\nsg_init_table(sglist, buf->npages);\r\nfor (i = 0; i < buf->npages; ++i) {\r\nif (PageHighMem(buf->pages[i])) {\r\nvfree(sglist);\r\nreturn -EINVAL;\r\n}\r\nsg_set_page(&sglist[i], buf->pages[i], PAGE_SIZE - offset,\r\noffset);\r\noffset = 0;\r\n}\r\nbuf->sglen = buf->npages;\r\nbuf->sglist = sglist;\r\nreturn 0;\r\n}\r\nstatic int isp_video_buffer_sglist_pfnmap(struct isp_video_buffer *buf)\r\n{\r\nstruct scatterlist *sglist;\r\nunsigned int offset = buf->offset;\r\nunsigned long pfn = buf->paddr >> PAGE_SHIFT;\r\nunsigned int i;\r\nsglist = vmalloc(buf->npages * sizeof(*sglist));\r\nif (sglist == NULL)\r\nreturn -ENOMEM;\r\nsg_init_table(sglist, buf->npages);\r\nfor (i = 0; i < buf->npages; ++i, ++pfn) {\r\nsg_set_page(&sglist[i], pfn_to_page(pfn), PAGE_SIZE - offset,\r\noffset);\r\nsg_dma_address(&sglist[i]) = (pfn << PAGE_SHIFT) + offset;\r\noffset = 0;\r\n}\r\nbuf->sglen = buf->npages;\r\nbuf->sglist = sglist;\r\nreturn 0;\r\n}\r\nstatic void isp_video_buffer_cleanup(struct isp_video_buffer *buf)\r\n{\r\nenum dma_data_direction direction;\r\nunsigned int i;\r\nif (buf->queue->ops->buffer_cleanup)\r\nbuf->queue->ops->buffer_cleanup(buf);\r\nif (!(buf->vm_flags & VM_PFNMAP)) {\r\ndirection = buf->vbuf.type == V4L2_BUF_TYPE_VIDEO_CAPTURE\r\n? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\ndma_unmap_sg(buf->queue->dev, buf->sglist, buf->sglen,\r\ndirection);\r\n}\r\nvfree(buf->sglist);\r\nbuf->sglist = NULL;\r\nbuf->sglen = 0;\r\nif (buf->pages != NULL) {\r\nisp_video_buffer_lock_vma(buf, 0);\r\nfor (i = 0; i < buf->npages; ++i)\r\npage_cache_release(buf->pages[i]);\r\nvfree(buf->pages);\r\nbuf->pages = NULL;\r\n}\r\nbuf->npages = 0;\r\nbuf->skip_cache = false;\r\n}\r\nstatic int isp_video_buffer_prepare_user(struct isp_video_buffer *buf)\r\n{\r\nunsigned long data;\r\nunsigned int first;\r\nunsigned int last;\r\nint ret;\r\ndata = buf->vbuf.m.userptr;\r\nfirst = (data & PAGE_MASK) >> PAGE_SHIFT;\r\nlast = ((data + buf->vbuf.length - 1) & PAGE_MASK) >> PAGE_SHIFT;\r\nbuf->offset = data & ~PAGE_MASK;\r\nbuf->npages = last - first + 1;\r\nbuf->pages = vmalloc(buf->npages * sizeof(buf->pages[0]));\r\nif (buf->pages == NULL)\r\nreturn -ENOMEM;\r\ndown_read(&current->mm->mmap_sem);\r\nret = get_user_pages(current, current->mm, data & PAGE_MASK,\r\nbuf->npages,\r\nbuf->vbuf.type == V4L2_BUF_TYPE_VIDEO_CAPTURE, 0,\r\nbuf->pages, NULL);\r\nup_read(&current->mm->mmap_sem);\r\nif (ret != buf->npages) {\r\nbuf->npages = ret < 0 ? 0 : ret;\r\nisp_video_buffer_cleanup(buf);\r\nreturn -EFAULT;\r\n}\r\nret = isp_video_buffer_lock_vma(buf, 1);\r\nif (ret < 0)\r\nisp_video_buffer_cleanup(buf);\r\nreturn ret;\r\n}\r\nstatic int isp_video_buffer_prepare_pfnmap(struct isp_video_buffer *buf)\r\n{\r\nstruct vm_area_struct *vma;\r\nunsigned long prev_pfn;\r\nunsigned long this_pfn;\r\nunsigned long start;\r\nunsigned long end;\r\ndma_addr_t pa = 0;\r\nint ret = -EFAULT;\r\nstart = buf->vbuf.m.userptr;\r\nend = buf->vbuf.m.userptr + buf->vbuf.length - 1;\r\nbuf->offset = start & ~PAGE_MASK;\r\nbuf->npages = (end >> PAGE_SHIFT) - (start >> PAGE_SHIFT) + 1;\r\nbuf->pages = NULL;\r\ndown_read(&current->mm->mmap_sem);\r\nvma = find_vma(current->mm, start);\r\nif (vma == NULL || vma->vm_end < end)\r\ngoto done;\r\nfor (prev_pfn = 0; start <= end; start += PAGE_SIZE) {\r\nret = follow_pfn(vma, start, &this_pfn);\r\nif (ret)\r\ngoto done;\r\nif (prev_pfn == 0)\r\npa = this_pfn << PAGE_SHIFT;\r\nelse if (this_pfn != prev_pfn + 1) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nprev_pfn = this_pfn;\r\n}\r\nbuf->paddr = pa + buf->offset;\r\nret = 0;\r\ndone:\r\nup_read(&current->mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic int isp_video_buffer_prepare_vm_flags(struct isp_video_buffer *buf)\r\n{\r\nstruct vm_area_struct *vma;\r\npgprot_t uninitialized_var(vm_page_prot);\r\nunsigned long start;\r\nunsigned long end;\r\nint ret = -EFAULT;\r\nstart = buf->vbuf.m.userptr;\r\nend = buf->vbuf.m.userptr + buf->vbuf.length - 1;\r\ndown_read(&current->mm->mmap_sem);\r\ndo {\r\nvma = find_vma(current->mm, start);\r\nif (vma == NULL)\r\ngoto done;\r\nif (start == buf->vbuf.m.userptr) {\r\nbuf->vm_flags = vma->vm_flags;\r\nvm_page_prot = vma->vm_page_prot;\r\n}\r\nif ((buf->vm_flags ^ vma->vm_flags) & VM_PFNMAP)\r\ngoto done;\r\nif (vm_page_prot != vma->vm_page_prot)\r\ngoto done;\r\nstart = vma->vm_end + 1;\r\n} while (vma->vm_end < end);\r\nif (vm_page_prot == pgprot_noncached(vm_page_prot) ||\r\nvm_page_prot == pgprot_writecombine(vm_page_prot))\r\nbuf->skip_cache = true;\r\nret = 0;\r\ndone:\r\nup_read(&current->mm->mmap_sem);\r\nreturn ret;\r\n}\r\nstatic int isp_video_buffer_prepare(struct isp_video_buffer *buf)\r\n{\r\nenum dma_data_direction direction;\r\nint ret;\r\nswitch (buf->vbuf.memory) {\r\ncase V4L2_MEMORY_MMAP:\r\nret = isp_video_buffer_sglist_kernel(buf);\r\nbreak;\r\ncase V4L2_MEMORY_USERPTR:\r\nret = isp_video_buffer_prepare_vm_flags(buf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (buf->vm_flags & VM_PFNMAP) {\r\nret = isp_video_buffer_prepare_pfnmap(buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isp_video_buffer_sglist_pfnmap(buf);\r\n} else {\r\nret = isp_video_buffer_prepare_user(buf);\r\nif (ret < 0)\r\nreturn ret;\r\nret = isp_video_buffer_sglist_user(buf);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (ret < 0)\r\ngoto done;\r\nif (!(buf->vm_flags & VM_PFNMAP)) {\r\ndirection = buf->vbuf.type == V4L2_BUF_TYPE_VIDEO_CAPTURE\r\n? DMA_FROM_DEVICE : DMA_TO_DEVICE;\r\nret = dma_map_sg(buf->queue->dev, buf->sglist, buf->sglen,\r\ndirection);\r\nif (ret != buf->sglen) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\n}\r\nif (buf->queue->ops->buffer_prepare)\r\nret = buf->queue->ops->buffer_prepare(buf);\r\ndone:\r\nif (ret < 0) {\r\nisp_video_buffer_cleanup(buf);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic void isp_video_buffer_query(struct isp_video_buffer *buf,\r\nstruct v4l2_buffer *vbuf)\r\n{\r\nmemcpy(vbuf, &buf->vbuf, sizeof(*vbuf));\r\nif (buf->vma_use_count)\r\nvbuf->flags |= V4L2_BUF_FLAG_MAPPED;\r\nswitch (buf->state) {\r\ncase ISP_BUF_STATE_ERROR:\r\nvbuf->flags |= V4L2_BUF_FLAG_ERROR;\r\ncase ISP_BUF_STATE_DONE:\r\nvbuf->flags |= V4L2_BUF_FLAG_DONE;\r\ncase ISP_BUF_STATE_QUEUED:\r\ncase ISP_BUF_STATE_ACTIVE:\r\nvbuf->flags |= V4L2_BUF_FLAG_QUEUED;\r\nbreak;\r\ncase ISP_BUF_STATE_IDLE:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int isp_video_buffer_wait(struct isp_video_buffer *buf, int nonblocking)\r\n{\r\nif (nonblocking) {\r\nreturn (buf->state != ISP_BUF_STATE_QUEUED &&\r\nbuf->state != ISP_BUF_STATE_ACTIVE)\r\n? 0 : -EAGAIN;\r\n}\r\nreturn wait_event_interruptible(buf->wait,\r\nbuf->state != ISP_BUF_STATE_QUEUED &&\r\nbuf->state != ISP_BUF_STATE_ACTIVE);\r\n}\r\nstatic int isp_video_queue_free(struct isp_video_queue *queue)\r\n{\r\nunsigned int i;\r\nif (queue->streaming)\r\nreturn -EBUSY;\r\nfor (i = 0; i < queue->count; ++i) {\r\nif (queue->buffers[i]->vma_use_count != 0)\r\nreturn -EBUSY;\r\n}\r\nfor (i = 0; i < queue->count; ++i) {\r\nstruct isp_video_buffer *buf = queue->buffers[i];\r\nisp_video_buffer_cleanup(buf);\r\nvfree(buf->vaddr);\r\nbuf->vaddr = NULL;\r\nkfree(buf);\r\nqueue->buffers[i] = NULL;\r\n}\r\nINIT_LIST_HEAD(&queue->queue);\r\nqueue->count = 0;\r\nreturn 0;\r\n}\r\nstatic int isp_video_queue_alloc(struct isp_video_queue *queue,\r\nunsigned int nbuffers,\r\nunsigned int size, enum v4l2_memory memory)\r\n{\r\nstruct isp_video_buffer *buf;\r\nunsigned int i;\r\nvoid *mem;\r\nint ret;\r\nret = isp_video_queue_free(queue);\r\nif (ret < 0)\r\nreturn ret;\r\nif (nbuffers == 0)\r\nreturn 0;\r\nfor (i = 0; i < nbuffers; ++i) {\r\nbuf = kzalloc(queue->bufsize, GFP_KERNEL);\r\nif (buf == NULL)\r\nbreak;\r\nif (memory == V4L2_MEMORY_MMAP) {\r\nmem = vmalloc_32_user(PAGE_ALIGN(size));\r\nif (mem == NULL) {\r\nkfree(buf);\r\nbreak;\r\n}\r\nbuf->vbuf.m.offset = i * PAGE_ALIGN(size);\r\nbuf->vaddr = mem;\r\n}\r\nbuf->vbuf.index = i;\r\nbuf->vbuf.length = size;\r\nbuf->vbuf.type = queue->type;\r\nbuf->vbuf.flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nbuf->vbuf.field = V4L2_FIELD_NONE;\r\nbuf->vbuf.memory = memory;\r\nbuf->queue = queue;\r\ninit_waitqueue_head(&buf->wait);\r\nqueue->buffers[i] = buf;\r\n}\r\nif (i == 0)\r\nreturn -ENOMEM;\r\nqueue->count = i;\r\nreturn nbuffers;\r\n}\r\nint omap3isp_video_queue_cleanup(struct isp_video_queue *queue)\r\n{\r\nreturn isp_video_queue_free(queue);\r\n}\r\nint omap3isp_video_queue_init(struct isp_video_queue *queue,\r\nenum v4l2_buf_type type,\r\nconst struct isp_video_queue_operations *ops,\r\nstruct device *dev, unsigned int bufsize)\r\n{\r\nINIT_LIST_HEAD(&queue->queue);\r\nmutex_init(&queue->lock);\r\nspin_lock_init(&queue->irqlock);\r\nqueue->type = type;\r\nqueue->ops = ops;\r\nqueue->dev = dev;\r\nqueue->bufsize = bufsize;\r\nreturn 0;\r\n}\r\nint omap3isp_video_queue_reqbufs(struct isp_video_queue *queue,\r\nstruct v4l2_requestbuffers *rb)\r\n{\r\nunsigned int nbuffers = rb->count;\r\nunsigned int size;\r\nint ret;\r\nif (rb->type != queue->type)\r\nreturn -EINVAL;\r\nqueue->ops->queue_prepare(queue, &nbuffers, &size);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nnbuffers = min_t(unsigned int, nbuffers, ISP_VIDEO_MAX_BUFFERS);\r\nmutex_lock(&queue->lock);\r\nret = isp_video_queue_alloc(queue, nbuffers, size, rb->memory);\r\nif (ret < 0)\r\ngoto done;\r\nrb->count = ret;\r\nret = 0;\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn ret;\r\n}\r\nint omap3isp_video_queue_querybuf(struct isp_video_queue *queue,\r\nstruct v4l2_buffer *vbuf)\r\n{\r\nstruct isp_video_buffer *buf;\r\nint ret = 0;\r\nif (vbuf->type != queue->type)\r\nreturn -EINVAL;\r\nmutex_lock(&queue->lock);\r\nif (vbuf->index >= queue->count) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbuf = queue->buffers[vbuf->index];\r\nisp_video_buffer_query(buf, vbuf);\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn ret;\r\n}\r\nint omap3isp_video_queue_qbuf(struct isp_video_queue *queue,\r\nstruct v4l2_buffer *vbuf)\r\n{\r\nstruct isp_video_buffer *buf;\r\nunsigned long flags;\r\nint ret = -EINVAL;\r\nif (vbuf->type != queue->type)\r\ngoto done;\r\nmutex_lock(&queue->lock);\r\nif (vbuf->index >= queue->count)\r\ngoto done;\r\nbuf = queue->buffers[vbuf->index];\r\nif (vbuf->memory != buf->vbuf.memory)\r\ngoto done;\r\nif (buf->state != ISP_BUF_STATE_IDLE)\r\ngoto done;\r\nif (vbuf->memory == V4L2_MEMORY_USERPTR &&\r\nvbuf->length < buf->vbuf.length)\r\ngoto done;\r\nif (vbuf->memory == V4L2_MEMORY_USERPTR &&\r\nvbuf->m.userptr != buf->vbuf.m.userptr) {\r\nisp_video_buffer_cleanup(buf);\r\nbuf->vbuf.m.userptr = vbuf->m.userptr;\r\nbuf->prepared = 0;\r\n}\r\nif (!buf->prepared) {\r\nret = isp_video_buffer_prepare(buf);\r\nif (ret < 0)\r\ngoto done;\r\nbuf->prepared = 1;\r\n}\r\nisp_video_buffer_cache_sync(buf);\r\nbuf->state = ISP_BUF_STATE_QUEUED;\r\nlist_add_tail(&buf->stream, &queue->queue);\r\nif (queue->streaming) {\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nqueue->ops->buffer_queue(buf);\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\n}\r\nret = 0;\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn ret;\r\n}\r\nint omap3isp_video_queue_dqbuf(struct isp_video_queue *queue,\r\nstruct v4l2_buffer *vbuf, int nonblocking)\r\n{\r\nstruct isp_video_buffer *buf;\r\nint ret;\r\nif (vbuf->type != queue->type)\r\nreturn -EINVAL;\r\nmutex_lock(&queue->lock);\r\nif (list_empty(&queue->queue)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nbuf = list_first_entry(&queue->queue, struct isp_video_buffer, stream);\r\nret = isp_video_buffer_wait(buf, nonblocking);\r\nif (ret < 0)\r\ngoto done;\r\nlist_del(&buf->stream);\r\nisp_video_buffer_query(buf, vbuf);\r\nbuf->state = ISP_BUF_STATE_IDLE;\r\nvbuf->flags &= ~V4L2_BUF_FLAG_QUEUED;\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn ret;\r\n}\r\nint omap3isp_video_queue_streamon(struct isp_video_queue *queue)\r\n{\r\nstruct isp_video_buffer *buf;\r\nunsigned long flags;\r\nmutex_lock(&queue->lock);\r\nif (queue->streaming)\r\ngoto done;\r\nqueue->streaming = 1;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nlist_for_each_entry(buf, &queue->queue, stream)\r\nqueue->ops->buffer_queue(buf);\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn 0;\r\n}\r\nvoid omap3isp_video_queue_streamoff(struct isp_video_queue *queue)\r\n{\r\nstruct isp_video_buffer *buf;\r\nunsigned long flags;\r\nunsigned int i;\r\nmutex_lock(&queue->lock);\r\nif (!queue->streaming)\r\ngoto done;\r\nqueue->streaming = 0;\r\nspin_lock_irqsave(&queue->irqlock, flags);\r\nfor (i = 0; i < queue->count; ++i) {\r\nbuf = queue->buffers[i];\r\nif (buf->state == ISP_BUF_STATE_ACTIVE)\r\nwake_up(&buf->wait);\r\nbuf->state = ISP_BUF_STATE_IDLE;\r\n}\r\nspin_unlock_irqrestore(&queue->irqlock, flags);\r\nINIT_LIST_HEAD(&queue->queue);\r\ndone:\r\nmutex_unlock(&queue->lock);\r\n}\r\nvoid omap3isp_video_queue_discard_done(struct isp_video_queue *queue)\r\n{\r\nstruct isp_video_buffer *buf;\r\nunsigned int i;\r\nmutex_lock(&queue->lock);\r\nif (!queue->streaming)\r\ngoto done;\r\nfor (i = 0; i < queue->count; ++i) {\r\nbuf = queue->buffers[i];\r\nif (buf->state == ISP_BUF_STATE_DONE)\r\nbuf->state = ISP_BUF_STATE_ERROR;\r\n}\r\ndone:\r\nmutex_unlock(&queue->lock);\r\n}\r\nstatic void isp_video_queue_vm_open(struct vm_area_struct *vma)\r\n{\r\nstruct isp_video_buffer *buf = vma->vm_private_data;\r\nbuf->vma_use_count++;\r\n}\r\nstatic void isp_video_queue_vm_close(struct vm_area_struct *vma)\r\n{\r\nstruct isp_video_buffer *buf = vma->vm_private_data;\r\nbuf->vma_use_count--;\r\n}\r\nint omap3isp_video_queue_mmap(struct isp_video_queue *queue,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct isp_video_buffer *uninitialized_var(buf);\r\nunsigned long size;\r\nunsigned int i;\r\nint ret = 0;\r\nmutex_lock(&queue->lock);\r\nfor (i = 0; i < queue->count; ++i) {\r\nbuf = queue->buffers[i];\r\nif ((buf->vbuf.m.offset >> PAGE_SHIFT) == vma->vm_pgoff)\r\nbreak;\r\n}\r\nif (i == queue->count) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nsize = vma->vm_end - vma->vm_start;\r\nif (buf->vbuf.memory != V4L2_MEMORY_MMAP ||\r\nsize != PAGE_ALIGN(buf->vbuf.length)) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = remap_vmalloc_range(vma, buf->vaddr, 0);\r\nif (ret < 0)\r\ngoto done;\r\nvma->vm_ops = &isp_video_queue_vm_ops;\r\nvma->vm_private_data = buf;\r\nisp_video_queue_vm_open(vma);\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn ret;\r\n}\r\nunsigned int omap3isp_video_queue_poll(struct isp_video_queue *queue,\r\nstruct file *file, poll_table *wait)\r\n{\r\nstruct isp_video_buffer *buf;\r\nunsigned int mask = 0;\r\nmutex_lock(&queue->lock);\r\nif (list_empty(&queue->queue)) {\r\nmask |= POLLERR;\r\ngoto done;\r\n}\r\nbuf = list_first_entry(&queue->queue, struct isp_video_buffer, stream);\r\npoll_wait(file, &buf->wait, wait);\r\nif (buf->state == ISP_BUF_STATE_DONE ||\r\nbuf->state == ISP_BUF_STATE_ERROR) {\r\nif (queue->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nmask |= POLLIN | POLLRDNORM;\r\nelse\r\nmask |= POLLOUT | POLLWRNORM;\r\n}\r\ndone:\r\nmutex_unlock(&queue->lock);\r\nreturn mask;\r\n}
