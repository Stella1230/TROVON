static unsigned char nuc900_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nunsigned char ret;\r\nstruct nuc900_nand *nand;\r\nnand = container_of(mtd, struct nuc900_nand, mtd);\r\nret = (unsigned char)read_data_reg(nand);\r\nreturn ret;\r\n}\r\nstatic void nuc900_nand_read_buf(struct mtd_info *mtd,\r\nunsigned char *buf, int len)\r\n{\r\nint i;\r\nstruct nuc900_nand *nand;\r\nnand = container_of(mtd, struct nuc900_nand, mtd);\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = (unsigned char)read_data_reg(nand);\r\n}\r\nstatic void nuc900_nand_write_buf(struct mtd_info *mtd,\r\nconst unsigned char *buf, int len)\r\n{\r\nint i;\r\nstruct nuc900_nand *nand;\r\nnand = container_of(mtd, struct nuc900_nand, mtd);\r\nfor (i = 0; i < len; i++)\r\nwrite_data_reg(nand, buf[i]);\r\n}\r\nstatic int nuc900_check_rb(struct nuc900_nand *nand)\r\n{\r\nunsigned int val;\r\nspin_lock(&nand->lock);\r\nval = __raw_readl(REG_SMISR);\r\nval &= READYBUSY;\r\nspin_unlock(&nand->lock);\r\nreturn val;\r\n}\r\nstatic int nuc900_nand_devready(struct mtd_info *mtd)\r\n{\r\nstruct nuc900_nand *nand;\r\nint ready;\r\nnand = container_of(mtd, struct nuc900_nand, mtd);\r\nready = (nuc900_check_rb(nand)) ? 1 : 0;\r\nreturn ready;\r\n}\r\nstatic void nuc900_nand_command_lp(struct mtd_info *mtd, unsigned int command,\r\nint column, int page_addr)\r\n{\r\nregister struct nand_chip *chip = mtd->priv;\r\nstruct nuc900_nand *nand;\r\nnand = container_of(mtd, struct nuc900_nand, mtd);\r\nif (command == NAND_CMD_READOOB) {\r\ncolumn += mtd->writesize;\r\ncommand = NAND_CMD_READ0;\r\n}\r\nwrite_cmd_reg(nand, command & 0xff);\r\nif (column != -1 || page_addr != -1) {\r\nif (column != -1) {\r\nif (chip->options & NAND_BUSWIDTH_16)\r\ncolumn >>= 1;\r\nwrite_addr_reg(nand, column);\r\nwrite_addr_reg(nand, column >> 8 | ENDADDR);\r\n}\r\nif (page_addr != -1) {\r\nwrite_addr_reg(nand, page_addr);\r\nif (chip->chipsize > (128 << 20)) {\r\nwrite_addr_reg(nand, page_addr >> 8);\r\nwrite_addr_reg(nand, page_addr >> 16 | ENDADDR);\r\n} else {\r\nwrite_addr_reg(nand, page_addr >> 8 | ENDADDR);\r\n}\r\n}\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_CACHEDPROG:\r\ncase NAND_CMD_PAGEPROG:\r\ncase NAND_CMD_ERASE1:\r\ncase NAND_CMD_ERASE2:\r\ncase NAND_CMD_SEQIN:\r\ncase NAND_CMD_RNDIN:\r\ncase NAND_CMD_STATUS:\r\nreturn;\r\ncase NAND_CMD_RESET:\r\nif (chip->dev_ready)\r\nbreak;\r\nudelay(chip->chip_delay);\r\nwrite_cmd_reg(nand, NAND_CMD_STATUS);\r\nwrite_cmd_reg(nand, command);\r\nwhile (!nuc900_check_rb(nand))\r\n;\r\nreturn;\r\ncase NAND_CMD_RNDOUT:\r\nwrite_cmd_reg(nand, NAND_CMD_RNDOUTSTART);\r\nreturn;\r\ncase NAND_CMD_READ0:\r\nwrite_cmd_reg(nand, NAND_CMD_READSTART);\r\ndefault:\r\nif (!chip->dev_ready) {\r\nudelay(chip->chip_delay);\r\nreturn;\r\n}\r\n}\r\nndelay(100);\r\nwhile (!chip->dev_ready(mtd))\r\n;\r\n}\r\nstatic void nuc900_nand_enable(struct nuc900_nand *nand)\r\n{\r\nunsigned int val;\r\nspin_lock(&nand->lock);\r\n__raw_writel(RESET_FMI, (nand->reg + REG_FMICSR));\r\nval = __raw_readl(nand->reg + REG_FMICSR);\r\nif (!(val & NAND_EN))\r\n__raw_writel(val | NAND_EN, REG_FMICSR);\r\nval = __raw_readl(nand->reg + REG_SMCSR);\r\nval &= ~(SWRST|PSIZE|DMARWEN|BUSWID|ECC4EN|NANDCS);\r\nval |= WP;\r\n__raw_writel(val, nand->reg + REG_SMCSR);\r\nspin_unlock(&nand->lock);\r\n}\r\nstatic int nuc900_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct nuc900_nand *nuc900_nand;\r\nstruct nand_chip *chip;\r\nint retval;\r\nstruct resource *res;\r\nretval = 0;\r\nnuc900_nand = kzalloc(sizeof(struct nuc900_nand), GFP_KERNEL);\r\nif (!nuc900_nand)\r\nreturn -ENOMEM;\r\nchip = &(nuc900_nand->chip);\r\nnuc900_nand->mtd.priv = chip;\r\nnuc900_nand->mtd.owner = THIS_MODULE;\r\nspin_lock_init(&nuc900_nand->lock);\r\nnuc900_nand->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(nuc900_nand->clk)) {\r\nretval = -ENOENT;\r\ngoto fail1;\r\n}\r\nclk_enable(nuc900_nand->clk);\r\nchip->cmdfunc = nuc900_nand_command_lp;\r\nchip->dev_ready = nuc900_nand_devready;\r\nchip->read_byte = nuc900_nand_read_byte;\r\nchip->write_buf = nuc900_nand_write_buf;\r\nchip->read_buf = nuc900_nand_read_buf;\r\nchip->chip_delay = 50;\r\nchip->options = 0;\r\nchip->ecc.mode = NAND_ECC_SOFT;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nretval = -ENXIO;\r\ngoto fail1;\r\n}\r\nif (!request_mem_region(res->start, resource_size(res), pdev->name)) {\r\nretval = -EBUSY;\r\ngoto fail1;\r\n}\r\nnuc900_nand->reg = ioremap(res->start, resource_size(res));\r\nif (!nuc900_nand->reg) {\r\nretval = -ENOMEM;\r\ngoto fail2;\r\n}\r\nnuc900_nand_enable(nuc900_nand);\r\nif (nand_scan(&(nuc900_nand->mtd), 1)) {\r\nretval = -ENXIO;\r\ngoto fail3;\r\n}\r\nmtd_device_register(&(nuc900_nand->mtd), partitions,\r\nARRAY_SIZE(partitions));\r\nplatform_set_drvdata(pdev, nuc900_nand);\r\nreturn retval;\r\nfail3: iounmap(nuc900_nand->reg);\r\nfail2: release_mem_region(res->start, resource_size(res));\r\nfail1: kfree(nuc900_nand);\r\nreturn retval;\r\n}\r\nstatic int nuc900_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct nuc900_nand *nuc900_nand = platform_get_drvdata(pdev);\r\nstruct resource *res;\r\nnand_release(&nuc900_nand->mtd);\r\niounmap(nuc900_nand->reg);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrelease_mem_region(res->start, resource_size(res));\r\nclk_disable(nuc900_nand->clk);\r\nclk_put(nuc900_nand->clk);\r\nkfree(nuc900_nand);\r\nreturn 0;\r\n}
