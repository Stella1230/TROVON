int sptlrpc_register_policy(struct ptlrpc_sec_policy *policy)\r\n{\r\n__u16 number = policy->sp_policy;\r\nLASSERT(policy->sp_name);\r\nLASSERT(policy->sp_cops);\r\nLASSERT(policy->sp_sops);\r\nif (number >= SPTLRPC_POLICY_MAX)\r\nreturn -EINVAL;\r\nwrite_lock(&policy_lock);\r\nif (unlikely(policies[number])) {\r\nwrite_unlock(&policy_lock);\r\nreturn -EALREADY;\r\n}\r\npolicies[number] = policy;\r\nwrite_unlock(&policy_lock);\r\nCDEBUG(D_SEC, "%s: registered\n", policy->sp_name);\r\nreturn 0;\r\n}\r\nint sptlrpc_unregister_policy(struct ptlrpc_sec_policy *policy)\r\n{\r\n__u16 number = policy->sp_policy;\r\nLASSERT(number < SPTLRPC_POLICY_MAX);\r\nwrite_lock(&policy_lock);\r\nif (unlikely(policies[number] == NULL)) {\r\nwrite_unlock(&policy_lock);\r\nCERROR("%s: already unregistered\n", policy->sp_name);\r\nreturn -EINVAL;\r\n}\r\nLASSERT(policies[number] == policy);\r\npolicies[number] = NULL;\r\nwrite_unlock(&policy_lock);\r\nCDEBUG(D_SEC, "%s: unregistered\n", policy->sp_name);\r\nreturn 0;\r\n}\r\nstatic\r\nstruct ptlrpc_sec_policy * sptlrpc_wireflavor2policy(__u32 flavor)\r\n{\r\nstatic DEFINE_MUTEX(load_mutex);\r\nstatic atomic_t loaded = ATOMIC_INIT(0);\r\nstruct ptlrpc_sec_policy *policy;\r\n__u16 number = SPTLRPC_FLVR_POLICY(flavor);\r\n__u16 flag = 0;\r\nif (number >= SPTLRPC_POLICY_MAX)\r\nreturn NULL;\r\nwhile (1) {\r\nread_lock(&policy_lock);\r\npolicy = policies[number];\r\nif (policy && !try_module_get(policy->sp_owner))\r\npolicy = NULL;\r\nif (policy == NULL)\r\nflag = atomic_read(&loaded);\r\nread_unlock(&policy_lock);\r\nif (policy != NULL || flag != 0 ||\r\nnumber != SPTLRPC_POLICY_GSS)\r\nbreak;\r\nmutex_lock(&load_mutex);\r\nif (atomic_read(&loaded) == 0) {\r\nif (request_module("ptlrpc_gss") == 0)\r\nCDEBUG(D_SEC,\r\n"module ptlrpc_gss loaded on demand\n");\r\nelse\r\nCERROR("Unable to load module ptlrpc_gss\n");\r\natomic_set(&loaded, 1);\r\n}\r\nmutex_unlock(&load_mutex);\r\n}\r\nreturn policy;\r\n}\r\n__u32 sptlrpc_name2flavor_base(const char *name)\r\n{\r\nif (!strcmp(name, "null"))\r\nreturn SPTLRPC_FLVR_NULL;\r\nif (!strcmp(name, "plain"))\r\nreturn SPTLRPC_FLVR_PLAIN;\r\nif (!strcmp(name, "krb5n"))\r\nreturn SPTLRPC_FLVR_KRB5N;\r\nif (!strcmp(name, "krb5a"))\r\nreturn SPTLRPC_FLVR_KRB5A;\r\nif (!strcmp(name, "krb5i"))\r\nreturn SPTLRPC_FLVR_KRB5I;\r\nif (!strcmp(name, "krb5p"))\r\nreturn SPTLRPC_FLVR_KRB5P;\r\nreturn SPTLRPC_FLVR_INVALID;\r\n}\r\nconst char *sptlrpc_flavor2name_base(__u32 flvr)\r\n{\r\n__u32 base = SPTLRPC_FLVR_BASE(flvr);\r\nif (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_NULL))\r\nreturn "null";\r\nelse if (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_PLAIN))\r\nreturn "plain";\r\nelse if (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5N))\r\nreturn "krb5n";\r\nelse if (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5A))\r\nreturn "krb5a";\r\nelse if (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5I))\r\nreturn "krb5i";\r\nelse if (base == SPTLRPC_FLVR_BASE(SPTLRPC_FLVR_KRB5P))\r\nreturn "krb5p";\r\nCERROR("invalid wire flavor 0x%x\n", flvr);\r\nreturn "invalid";\r\n}\r\nchar *sptlrpc_flavor2name_bulk(struct sptlrpc_flavor *sf,\r\nchar *buf, int bufsize)\r\n{\r\nif (SPTLRPC_FLVR_POLICY(sf->sf_rpc) == SPTLRPC_POLICY_PLAIN)\r\nsnprintf(buf, bufsize, "hash:%s",\r\nsptlrpc_get_hash_name(sf->u_bulk.hash.hash_alg));\r\nelse\r\nsnprintf(buf, bufsize, "%s",\r\nsptlrpc_flavor2name_base(sf->sf_rpc));\r\nbuf[bufsize - 1] = '\0';\r\nreturn buf;\r\n}\r\nchar *sptlrpc_flavor2name(struct sptlrpc_flavor *sf, char *buf, int bufsize)\r\n{\r\nsnprintf(buf, bufsize, "%s", sptlrpc_flavor2name_base(sf->sf_rpc));\r\nif (SPTLRPC_FLVR_POLICY(sf->sf_rpc) == SPTLRPC_POLICY_PLAIN) {\r\nchar bspec[16];\r\nbspec[0] = '-';\r\nsptlrpc_flavor2name_bulk(sf, &bspec[1], sizeof(bspec) - 1);\r\nstrncat(buf, bspec, bufsize);\r\n}\r\nbuf[bufsize - 1] = '\0';\r\nreturn buf;\r\n}\r\nchar *sptlrpc_secflags2str(__u32 flags, char *buf, int bufsize)\r\n{\r\nbuf[0] = '\0';\r\nif (flags & PTLRPC_SEC_FL_REVERSE)\r\nstrlcat(buf, "reverse,", bufsize);\r\nif (flags & PTLRPC_SEC_FL_ROOTONLY)\r\nstrlcat(buf, "rootonly,", bufsize);\r\nif (flags & PTLRPC_SEC_FL_UDESC)\r\nstrlcat(buf, "udesc,", bufsize);\r\nif (flags & PTLRPC_SEC_FL_BULK)\r\nstrlcat(buf, "bulk,", bufsize);\r\nif (buf[0] == '\0')\r\nstrlcat(buf, "-,", bufsize);\r\nreturn buf;\r\n}\r\nstatic\r\nstruct ptlrpc_cli_ctx *get_my_ctx(struct ptlrpc_sec *sec)\r\n{\r\nstruct vfs_cred vcred;\r\nint create = 1, remove_dead = 1;\r\nLASSERT(sec);\r\nLASSERT(sec->ps_policy->sp_cops->lookup_ctx);\r\nif (sec->ps_flvr.sf_flags & (PTLRPC_SEC_FL_REVERSE |\r\nPTLRPC_SEC_FL_ROOTONLY)) {\r\nvcred.vc_uid = 0;\r\nvcred.vc_gid = 0;\r\nif (sec->ps_flvr.sf_flags & PTLRPC_SEC_FL_REVERSE) {\r\ncreate = 0;\r\nremove_dead = 0;\r\n}\r\n} else {\r\nvcred.vc_uid = from_kuid(&init_user_ns, current_uid());\r\nvcred.vc_gid = from_kgid(&init_user_ns, current_gid());\r\n}\r\nreturn sec->ps_policy->sp_cops->lookup_ctx(sec, &vcred,\r\ncreate, remove_dead);\r\n}\r\nstruct ptlrpc_cli_ctx *sptlrpc_cli_ctx_get(struct ptlrpc_cli_ctx *ctx)\r\n{\r\natomic_inc(&ctx->cc_refcount);\r\nreturn ctx;\r\n}\r\nvoid sptlrpc_cli_ctx_put(struct ptlrpc_cli_ctx *ctx, int sync)\r\n{\r\nstruct ptlrpc_sec *sec = ctx->cc_sec;\r\nLASSERT(sec);\r\nLASSERT_ATOMIC_POS(&ctx->cc_refcount);\r\nif (!atomic_dec_and_test(&ctx->cc_refcount))\r\nreturn;\r\nsec->ps_policy->sp_cops->release_ctx(sec, ctx, sync);\r\n}\r\nvoid sptlrpc_cli_ctx_expire(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nLASSERT(ctx->cc_ops->die);\r\nctx->cc_ops->die(ctx, 0);\r\n}\r\nvoid sptlrpc_cli_ctx_wakeup(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct ptlrpc_request *req, *next;\r\nspin_lock(&ctx->cc_lock);\r\nlist_for_each_entry_safe(req, next, &ctx->cc_req_list,\r\nrq_ctx_chain) {\r\nlist_del_init(&req->rq_ctx_chain);\r\nptlrpc_client_wake_req(req);\r\n}\r\nspin_unlock(&ctx->cc_lock);\r\n}\r\nint sptlrpc_cli_ctx_display(struct ptlrpc_cli_ctx *ctx, char *buf, int bufsize)\r\n{\r\nLASSERT(ctx->cc_ops);\r\nif (ctx->cc_ops->display == NULL)\r\nreturn 0;\r\nreturn ctx->cc_ops->display(ctx, buf, bufsize);\r\n}\r\nstatic int import_sec_check_expire(struct obd_import *imp)\r\n{\r\nint adapt = 0;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_sec_expire &&\r\nimp->imp_sec_expire < cfs_time_current_sec()) {\r\nadapt = 1;\r\nimp->imp_sec_expire = 0;\r\n}\r\nspin_unlock(&imp->imp_lock);\r\nif (!adapt)\r\nreturn 0;\r\nCDEBUG(D_SEC, "found delayed sec adapt expired, do it now\n");\r\nreturn sptlrpc_import_sec_adapt(imp, NULL, 0);\r\n}\r\nstatic int import_sec_validate_get(struct obd_import *imp,\r\nstruct ptlrpc_sec **sec)\r\n{\r\nint rc;\r\nif (unlikely(imp->imp_sec_expire)) {\r\nrc = import_sec_check_expire(imp);\r\nif (rc)\r\nreturn rc;\r\n}\r\n*sec = sptlrpc_import_sec_ref(imp);\r\nif (*sec == NULL) {\r\nCERROR("import %p (%s) with no sec\n",\r\nimp, ptlrpc_import_state_name(imp->imp_state));\r\nreturn -EACCES;\r\n}\r\nif (unlikely((*sec)->ps_dying)) {\r\nCERROR("attempt to use dying sec %p\n", sec);\r\nsptlrpc_sec_put(*sec);\r\nreturn -EACCES;\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_req_get_ctx(struct ptlrpc_request *req)\r\n{\r\nstruct obd_import *imp = req->rq_import;\r\nstruct ptlrpc_sec *sec;\r\nint rc;\r\nLASSERT(!req->rq_cli_ctx);\r\nLASSERT(imp);\r\nrc = import_sec_validate_get(imp, &sec);\r\nif (rc)\r\nreturn rc;\r\nreq->rq_cli_ctx = get_my_ctx(sec);\r\nsptlrpc_sec_put(sec);\r\nif (!req->rq_cli_ctx) {\r\nCERROR("req %p: fail to get context\n", req);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid sptlrpc_req_put_ctx(struct ptlrpc_request *req, int sync)\r\n{\r\nLASSERT(req);\r\nLASSERT(req->rq_cli_ctx);\r\nif (!list_empty(&req->rq_ctx_chain)) {\r\nspin_lock(&req->rq_cli_ctx->cc_lock);\r\nlist_del_init(&req->rq_ctx_chain);\r\nspin_unlock(&req->rq_cli_ctx->cc_lock);\r\n}\r\nsptlrpc_cli_ctx_put(req->rq_cli_ctx, sync);\r\nreq->rq_cli_ctx = NULL;\r\n}\r\nstatic\r\nint sptlrpc_req_ctx_switch(struct ptlrpc_request *req,\r\nstruct ptlrpc_cli_ctx *oldctx,\r\nstruct ptlrpc_cli_ctx *newctx)\r\n{\r\nstruct sptlrpc_flavor old_flvr;\r\nchar *reqmsg = NULL;\r\nint reqmsg_size;\r\nint rc = 0;\r\nLASSERT(req->rq_reqmsg);\r\nLASSERT(req->rq_reqlen);\r\nLASSERT(req->rq_replen);\r\nCDEBUG(D_SEC, "req %p: switch ctx %p(%u->%s) -> %p(%u->%s), "\r\n"switch sec %p(%s) -> %p(%s)\n", req,\r\noldctx, oldctx->cc_vcred.vc_uid, sec2target_str(oldctx->cc_sec),\r\nnewctx, newctx->cc_vcred.vc_uid, sec2target_str(newctx->cc_sec),\r\noldctx->cc_sec, oldctx->cc_sec->ps_policy->sp_name,\r\nnewctx->cc_sec, newctx->cc_sec->ps_policy->sp_name);\r\nold_flvr = req->rq_flvr;\r\nreqmsg_size = req->rq_reqlen;\r\nif (reqmsg_size != 0) {\r\nOBD_ALLOC_LARGE(reqmsg, reqmsg_size);\r\nif (reqmsg == NULL)\r\nreturn -ENOMEM;\r\nmemcpy(reqmsg, req->rq_reqmsg, reqmsg_size);\r\n}\r\nreq->rq_cli_ctx = oldctx;\r\nsptlrpc_cli_free_reqbuf(req);\r\nsptlrpc_cli_free_repbuf(req);\r\nreq->rq_cli_ctx = newctx;\r\nsptlrpc_req_set_flavor(req, 0);\r\nif (reqmsg_size != 0) {\r\nrc = sptlrpc_cli_alloc_reqbuf(req, reqmsg_size);\r\nif (!rc) {\r\nLASSERT(req->rq_reqmsg);\r\nmemcpy(req->rq_reqmsg, reqmsg, reqmsg_size);\r\n} else {\r\nCWARN("failed to alloc reqbuf: %d\n", rc);\r\nreq->rq_flvr = old_flvr;\r\n}\r\nOBD_FREE_LARGE(reqmsg, reqmsg_size);\r\n}\r\nreturn rc;\r\n}\r\nint sptlrpc_req_replace_dead_ctx(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_cli_ctx *oldctx = req->rq_cli_ctx;\r\nstruct ptlrpc_cli_ctx *newctx;\r\nint rc;\r\nLASSERT(oldctx);\r\nsptlrpc_cli_ctx_get(oldctx);\r\nsptlrpc_req_put_ctx(req, 0);\r\nrc = sptlrpc_req_get_ctx(req);\r\nif (unlikely(rc)) {\r\nLASSERT(!req->rq_cli_ctx);\r\nreq->rq_cli_ctx = oldctx;\r\nreturn rc;\r\n}\r\nnewctx = req->rq_cli_ctx;\r\nLASSERT(newctx);\r\nif (unlikely(newctx == oldctx &&\r\ntest_bit(PTLRPC_CTX_DEAD_BIT, &oldctx->cc_flags))) {\r\nCDEBUG(D_SEC,\r\n"ctx (%p, fl %lx) doesn't switch, relax a little bit\n",\r\nnewctx, newctx->cc_flags);\r\nschedule_timeout_and_set_state(TASK_INTERRUPTIBLE,\r\nHZ);\r\n} else {\r\nrc = sptlrpc_req_ctx_switch(req, oldctx, newctx);\r\nif (rc) {\r\nsptlrpc_req_put_ctx(req, 0);\r\nreq->rq_cli_ctx = oldctx;\r\nreturn rc;\r\n}\r\nLASSERT(req->rq_cli_ctx == newctx);\r\n}\r\nsptlrpc_cli_ctx_put(oldctx, 1);\r\nreturn 0;\r\n}\r\nstatic\r\nint ctx_check_refresh(struct ptlrpc_cli_ctx *ctx)\r\n{\r\nif (cli_ctx_is_refreshed(ctx))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic\r\nint ctx_refresh_timeout(void *data)\r\n{\r\nstruct ptlrpc_request *req = data;\r\nint rc;\r\nlustre_msg_set_conn_cnt(req->rq_reqmsg, req->rq_import->imp_conn_cnt);\r\nrc = ptlrpc_expire_one_request(req, 1);\r\nif (rc == 0)\r\nreq->rq_cli_ctx->cc_ops->die(req->rq_cli_ctx, 0);\r\nreturn rc;\r\n}\r\nstatic\r\nvoid ctx_refresh_interrupt(void *data)\r\n{\r\nstruct ptlrpc_request *req = data;\r\nspin_lock(&req->rq_lock);\r\nreq->rq_intr = 1;\r\nspin_unlock(&req->rq_lock);\r\n}\r\nstatic\r\nvoid req_off_ctx_list(struct ptlrpc_request *req, struct ptlrpc_cli_ctx *ctx)\r\n{\r\nspin_lock(&ctx->cc_lock);\r\nif (!list_empty(&req->rq_ctx_chain))\r\nlist_del_init(&req->rq_ctx_chain);\r\nspin_unlock(&ctx->cc_lock);\r\n}\r\nint sptlrpc_req_refresh_ctx(struct ptlrpc_request *req, long timeout)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nstruct ptlrpc_sec *sec;\r\nstruct l_wait_info lwi;\r\nint rc;\r\nLASSERT(ctx);\r\nif (req->rq_ctx_init || req->rq_ctx_fini)\r\nreturn 0;\r\nagain:\r\nrc = import_sec_validate_get(req->rq_import, &sec);\r\nif (rc)\r\nreturn rc;\r\nif (sec->ps_flvr.sf_rpc != req->rq_flvr.sf_rpc) {\r\nCDEBUG(D_SEC, "req %p: flavor has changed %x -> %x\n",\r\nreq, req->rq_flvr.sf_rpc, sec->ps_flvr.sf_rpc);\r\nreq_off_ctx_list(req, ctx);\r\nsptlrpc_req_replace_dead_ctx(req);\r\nctx = req->rq_cli_ctx;\r\n}\r\nsptlrpc_sec_put(sec);\r\nif (cli_ctx_is_eternal(ctx))\r\nreturn 0;\r\nif (unlikely(test_bit(PTLRPC_CTX_NEW_BIT, &ctx->cc_flags))) {\r\nLASSERT(ctx->cc_ops->refresh);\r\nctx->cc_ops->refresh(ctx);\r\n}\r\nLASSERT(test_bit(PTLRPC_CTX_NEW_BIT, &ctx->cc_flags) == 0);\r\nLASSERT(ctx->cc_ops->validate);\r\nif (ctx->cc_ops->validate(ctx) == 0) {\r\nreq_off_ctx_list(req, ctx);\r\nreturn 0;\r\n}\r\nif (unlikely(test_bit(PTLRPC_CTX_ERROR_BIT, &ctx->cc_flags))) {\r\nspin_lock(&req->rq_lock);\r\nreq->rq_err = 1;\r\nspin_unlock(&req->rq_lock);\r\nreq_off_ctx_list(req, ctx);\r\nreturn -EPERM;\r\n}\r\nif (test_bit(PTLRPC_CTX_UPTODATE_BIT, &ctx->cc_flags) &&\r\nunlikely(req->rq_reqmsg) &&\r\nlustre_msg_get_flags(req->rq_reqmsg) & MSG_RESENT) {\r\nreq_off_ctx_list(req, ctx);\r\nreturn 0;\r\n}\r\nif (unlikely(test_bit(PTLRPC_CTX_DEAD_BIT, &ctx->cc_flags))) {\r\nreq_off_ctx_list(req, ctx);\r\nif (req->rq_import->imp_deactive) {\r\nspin_lock(&req->rq_lock);\r\nreq->rq_err = 1;\r\nspin_unlock(&req->rq_lock);\r\nreturn -EINTR;\r\n}\r\nrc = sptlrpc_req_replace_dead_ctx(req);\r\nif (rc) {\r\nLASSERT(ctx == req->rq_cli_ctx);\r\nCERROR("req %p: failed to replace dead ctx %p: %d\n",\r\nreq, ctx, rc);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_err = 1;\r\nspin_unlock(&req->rq_lock);\r\nreturn rc;\r\n}\r\nctx = req->rq_cli_ctx;\r\ngoto again;\r\n}\r\nspin_lock(&ctx->cc_lock);\r\nif (list_empty(&req->rq_ctx_chain))\r\nlist_add(&req->rq_ctx_chain, &ctx->cc_req_list);\r\nspin_unlock(&ctx->cc_lock);\r\nif (timeout < 0)\r\nreturn -EWOULDBLOCK;\r\nLASSERT(req->rq_receiving_reply == 0);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_err = 0;\r\nreq->rq_timedout = 0;\r\nreq->rq_resend = 0;\r\nreq->rq_restart = 0;\r\nspin_unlock(&req->rq_lock);\r\nlwi = LWI_TIMEOUT_INTR(timeout * HZ, ctx_refresh_timeout,\r\nctx_refresh_interrupt, req);\r\nrc = l_wait_event(req->rq_reply_waitq, ctx_check_refresh(ctx), &lwi);\r\nif (!cli_ctx_is_refreshed(ctx)) {\r\nreq_off_ctx_list(req, ctx);\r\nLASSERT(rc != 0);\r\nreturn rc;\r\n}\r\ngoto again;\r\n}\r\nvoid sptlrpc_req_set_flavor(struct ptlrpc_request *req, int opcode)\r\n{\r\nstruct ptlrpc_sec *sec;\r\nLASSERT(req->rq_import);\r\nLASSERT(req->rq_cli_ctx);\r\nLASSERT(req->rq_cli_ctx->cc_sec);\r\nLASSERT(req->rq_bulk_read == 0 || req->rq_bulk_write == 0);\r\nswitch (opcode) {\r\ncase OST_READ:\r\ncase MDS_READPAGE:\r\ncase MGS_CONFIG_READ:\r\ncase OBD_IDX_READ:\r\nreq->rq_bulk_read = 1;\r\nbreak;\r\ncase OST_WRITE:\r\ncase MDS_WRITEPAGE:\r\nreq->rq_bulk_write = 1;\r\nbreak;\r\ncase SEC_CTX_INIT:\r\nreq->rq_ctx_init = 1;\r\nbreak;\r\ncase SEC_CTX_FINI:\r\nreq->rq_ctx_fini = 1;\r\nbreak;\r\ncase 0:\r\nLASSERT(req->rq_ctx_init == 0);\r\nLASSERT(req->rq_ctx_fini == 0);\r\nreq->rq_pack_udesc = 0;\r\nreq->rq_pack_bulk = 0;\r\nbreak;\r\n}\r\nsec = req->rq_cli_ctx->cc_sec;\r\nspin_lock(&sec->ps_lock);\r\nreq->rq_flvr = sec->ps_flvr;\r\nspin_unlock(&sec->ps_lock);\r\nif (unlikely(req->rq_ctx_init))\r\nflvr_set_svc(&req->rq_flvr.sf_rpc, SPTLRPC_SVC_NULL);\r\nelse if (unlikely(req->rq_ctx_fini))\r\nflvr_set_svc(&req->rq_flvr.sf_rpc, SPTLRPC_SVC_INTG);\r\nif ((sec->ps_flvr.sf_flags & PTLRPC_SEC_FL_UDESC) &&\r\n(req->rq_flvr.sf_rpc != SPTLRPC_FLVR_NULL))\r\nreq->rq_pack_udesc = 1;\r\nif ((req->rq_bulk_read || req->rq_bulk_write) &&\r\nsptlrpc_flavor_has_bulk(&req->rq_flvr))\r\nreq->rq_pack_bulk = 1;\r\n}\r\nvoid sptlrpc_request_out_callback(struct ptlrpc_request *req)\r\n{\r\nif (SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc) != SPTLRPC_SVC_PRIV)\r\nreturn;\r\nLASSERT(req->rq_clrbuf);\r\nif (req->rq_pool || !req->rq_reqbuf)\r\nreturn;\r\nOBD_FREE(req->rq_reqbuf, req->rq_reqbuf_len);\r\nreq->rq_reqbuf = NULL;\r\nreq->rq_reqbuf_len = 0;\r\n}\r\nint sptlrpc_import_check_ctx(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_sec *sec;\r\nstruct ptlrpc_cli_ctx *ctx;\r\nstruct ptlrpc_request *req = NULL;\r\nint rc;\r\nmight_sleep();\r\nsec = sptlrpc_import_sec_ref(imp);\r\nctx = get_my_ctx(sec);\r\nsptlrpc_sec_put(sec);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (cli_ctx_is_eternal(ctx) ||\r\nctx->cc_ops->validate(ctx) == 0) {\r\nsptlrpc_cli_ctx_put(ctx, 1);\r\nreturn 0;\r\n}\r\nif (cli_ctx_is_error(ctx)) {\r\nsptlrpc_cli_ctx_put(ctx, 1);\r\nreturn -EACCES;\r\n}\r\nOBD_ALLOC_PTR(req);\r\nif (!req)\r\nreturn -ENOMEM;\r\nspin_lock_init(&req->rq_lock);\r\natomic_set(&req->rq_refcount, 10000);\r\nINIT_LIST_HEAD(&req->rq_ctx_chain);\r\ninit_waitqueue_head(&req->rq_reply_waitq);\r\ninit_waitqueue_head(&req->rq_set_waitq);\r\nreq->rq_import = imp;\r\nreq->rq_flvr = sec->ps_flvr;\r\nreq->rq_cli_ctx = ctx;\r\nrc = sptlrpc_req_refresh_ctx(req, 0);\r\nLASSERT(list_empty(&req->rq_ctx_chain));\r\nsptlrpc_cli_ctx_put(req->rq_cli_ctx, 1);\r\nOBD_FREE_PTR(req);\r\nreturn rc;\r\n}\r\nint sptlrpc_cli_wrap_request(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nint rc = 0;\r\nLASSERT(ctx);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(req->rq_reqbuf || req->rq_clrbuf);\r\nif (req->rq_bulk) {\r\nrc = sptlrpc_cli_wrap_bulk(req, req->rq_bulk);\r\nif (rc)\r\nreturn rc;\r\n}\r\nswitch (SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc)) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nLASSERT(ctx->cc_ops->sign);\r\nrc = ctx->cc_ops->sign(ctx, req);\r\nbreak;\r\ncase SPTLRPC_SVC_PRIV:\r\nLASSERT(ctx->cc_ops->seal);\r\nrc = ctx->cc_ops->seal(ctx, req);\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nif (rc == 0) {\r\nLASSERT(req->rq_reqdata_len);\r\nLASSERT(req->rq_reqdata_len % 8 == 0);\r\nLASSERT(req->rq_reqdata_len <= req->rq_reqbuf_len);\r\n}\r\nreturn rc;\r\n}\r\nstatic int do_cli_unwrap_reply(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nint rc;\r\nLASSERT(ctx);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(req->rq_repbuf);\r\nLASSERT(req->rq_repdata);\r\nLASSERT(req->rq_repmsg == NULL);\r\nreq->rq_rep_swab_mask = 0;\r\nrc = __lustre_unpack_msg(req->rq_repdata, req->rq_repdata_len);\r\nswitch (rc) {\r\ncase 1:\r\nlustre_set_rep_swabbed(req, MSG_PTLRPC_HEADER_OFF);\r\ncase 0:\r\nbreak;\r\ndefault:\r\nCERROR("failed unpack reply: x"LPU64"\n", req->rq_xid);\r\nreturn -EPROTO;\r\n}\r\nif (req->rq_repdata_len < sizeof(struct lustre_msg)) {\r\nCERROR("replied data length %d too small\n",\r\nreq->rq_repdata_len);\r\nreturn -EPROTO;\r\n}\r\nif (SPTLRPC_FLVR_POLICY(req->rq_repdata->lm_secflvr) !=\r\nSPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc)) {\r\nCERROR("reply policy %u doesn't match request policy %u\n",\r\nSPTLRPC_FLVR_POLICY(req->rq_repdata->lm_secflvr),\r\nSPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc));\r\nreturn -EPROTO;\r\n}\r\nswitch (SPTLRPC_FLVR_SVC(req->rq_flvr.sf_rpc)) {\r\ncase SPTLRPC_SVC_NULL:\r\ncase SPTLRPC_SVC_AUTH:\r\ncase SPTLRPC_SVC_INTG:\r\nLASSERT(ctx->cc_ops->verify);\r\nrc = ctx->cc_ops->verify(ctx, req);\r\nbreak;\r\ncase SPTLRPC_SVC_PRIV:\r\nLASSERT(ctx->cc_ops->unseal);\r\nrc = ctx->cc_ops->unseal(ctx, req);\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nLASSERT(rc || req->rq_repmsg || req->rq_resend);\r\nif (SPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc) != SPTLRPC_POLICY_NULL &&\r\n!req->rq_ctx_init)\r\nreq->rq_rep_swab_mask = 0;\r\nreturn rc;\r\n}\r\nint sptlrpc_cli_unwrap_reply(struct ptlrpc_request *req)\r\n{\r\nLASSERT(req->rq_repbuf);\r\nLASSERT(req->rq_repdata == NULL);\r\nLASSERT(req->rq_repmsg == NULL);\r\nLASSERT(req->rq_reply_off + req->rq_nob_received <= req->rq_repbuf_len);\r\nif (req->rq_reply_off == 0 &&\r\n(lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT)) {\r\nCERROR("real reply with offset 0\n");\r\nreturn -EPROTO;\r\n}\r\nif (req->rq_reply_off % 8 != 0) {\r\nCERROR("reply at odd offset %u\n", req->rq_reply_off);\r\nreturn -EPROTO;\r\n}\r\nreq->rq_repdata = (struct lustre_msg *)\r\n(req->rq_repbuf + req->rq_reply_off);\r\nreq->rq_repdata_len = req->rq_nob_received;\r\nreturn do_cli_unwrap_reply(req);\r\n}\r\nint sptlrpc_cli_unwrap_early_reply(struct ptlrpc_request *req,\r\nstruct ptlrpc_request **req_ret)\r\n{\r\nstruct ptlrpc_request *early_req;\r\nchar *early_buf;\r\nint early_bufsz, early_size;\r\nint rc;\r\nOBD_ALLOC_PTR(early_req);\r\nif (early_req == NULL)\r\nreturn -ENOMEM;\r\nearly_size = req->rq_nob_received;\r\nearly_bufsz = size_roundup_power2(early_size);\r\nOBD_ALLOC_LARGE(early_buf, early_bufsz);\r\nif (early_buf == NULL)\r\nGOTO(err_req, rc = -ENOMEM);\r\nspin_lock(&req->rq_lock);\r\nif (req->rq_replied) {\r\nspin_unlock(&req->rq_lock);\r\nGOTO(err_buf, rc = -EALREADY);\r\n}\r\nLASSERT(req->rq_repbuf);\r\nLASSERT(req->rq_repdata == NULL);\r\nLASSERT(req->rq_repmsg == NULL);\r\nif (req->rq_reply_off != 0) {\r\nCERROR("early reply with offset %u\n", req->rq_reply_off);\r\nspin_unlock(&req->rq_lock);\r\nGOTO(err_buf, rc = -EPROTO);\r\n}\r\nif (req->rq_nob_received != early_size) {\r\nCERROR("data size has changed from %u to %u\n",\r\nearly_size, req->rq_nob_received);\r\nspin_unlock(&req->rq_lock);\r\nGOTO(err_buf, rc = -EINVAL);\r\n}\r\nif (req->rq_nob_received < sizeof(struct lustre_msg)) {\r\nCERROR("early reply length %d too small\n",\r\nreq->rq_nob_received);\r\nspin_unlock(&req->rq_lock);\r\nGOTO(err_buf, rc = -EALREADY);\r\n}\r\nmemcpy(early_buf, req->rq_repbuf, early_size);\r\nspin_unlock(&req->rq_lock);\r\nspin_lock_init(&early_req->rq_lock);\r\nearly_req->rq_cli_ctx = sptlrpc_cli_ctx_get(req->rq_cli_ctx);\r\nearly_req->rq_flvr = req->rq_flvr;\r\nearly_req->rq_repbuf = early_buf;\r\nearly_req->rq_repbuf_len = early_bufsz;\r\nearly_req->rq_repdata = (struct lustre_msg *) early_buf;\r\nearly_req->rq_repdata_len = early_size;\r\nearly_req->rq_early = 1;\r\nearly_req->rq_reqmsg = req->rq_reqmsg;\r\nrc = do_cli_unwrap_reply(early_req);\r\nif (rc) {\r\nDEBUG_REQ(D_ADAPTTO, early_req,\r\n"error %d unwrap early reply", rc);\r\nGOTO(err_ctx, rc);\r\n}\r\nLASSERT(early_req->rq_repmsg);\r\n*req_ret = early_req;\r\nreturn 0;\r\nerr_ctx:\r\nsptlrpc_cli_ctx_put(early_req->rq_cli_ctx, 1);\r\nerr_buf:\r\nOBD_FREE_LARGE(early_buf, early_bufsz);\r\nerr_req:\r\nOBD_FREE_PTR(early_req);\r\nreturn rc;\r\n}\r\nvoid sptlrpc_cli_finish_early_reply(struct ptlrpc_request *early_req)\r\n{\r\nLASSERT(early_req->rq_repbuf);\r\nLASSERT(early_req->rq_repdata);\r\nLASSERT(early_req->rq_repmsg);\r\nsptlrpc_cli_ctx_put(early_req->rq_cli_ctx, 1);\r\nOBD_FREE_LARGE(early_req->rq_repbuf, early_req->rq_repbuf_len);\r\nOBD_FREE_PTR(early_req);\r\n}\r\nint sptlrpc_get_next_secid(void)\r\n{\r\nreturn atomic_inc_return(&sptlrpc_sec_id);\r\n}\r\nstatic int sec_cop_flush_ctx_cache(struct ptlrpc_sec *sec, uid_t uid,\r\nint grace, int force)\r\n{\r\nstruct ptlrpc_sec_policy *policy = sec->ps_policy;\r\nLASSERT(policy->sp_cops);\r\nLASSERT(policy->sp_cops->flush_ctx_cache);\r\nreturn policy->sp_cops->flush_ctx_cache(sec, uid, grace, force);\r\n}\r\nstatic void sec_cop_destroy_sec(struct ptlrpc_sec *sec)\r\n{\r\nstruct ptlrpc_sec_policy *policy = sec->ps_policy;\r\nLASSERT_ATOMIC_ZERO(&sec->ps_refcount);\r\nLASSERT_ATOMIC_ZERO(&sec->ps_nctx);\r\nLASSERT(policy->sp_cops->destroy_sec);\r\nCDEBUG(D_SEC, "%s@%p: being destroied\n", sec->ps_policy->sp_name, sec);\r\npolicy->sp_cops->destroy_sec(sec);\r\nsptlrpc_policy_put(policy);\r\n}\r\nvoid sptlrpc_sec_destroy(struct ptlrpc_sec *sec)\r\n{\r\nsec_cop_destroy_sec(sec);\r\n}\r\nstatic void sptlrpc_sec_kill(struct ptlrpc_sec *sec)\r\n{\r\nLASSERT_ATOMIC_POS(&sec->ps_refcount);\r\nif (sec->ps_policy->sp_cops->kill_sec) {\r\nsec->ps_policy->sp_cops->kill_sec(sec);\r\nsec_cop_flush_ctx_cache(sec, -1, 1, 1);\r\n}\r\n}\r\nstruct ptlrpc_sec *sptlrpc_sec_get(struct ptlrpc_sec *sec)\r\n{\r\nif (sec)\r\natomic_inc(&sec->ps_refcount);\r\nreturn sec;\r\n}\r\nvoid sptlrpc_sec_put(struct ptlrpc_sec *sec)\r\n{\r\nif (sec) {\r\nLASSERT_ATOMIC_POS(&sec->ps_refcount);\r\nif (atomic_dec_and_test(&sec->ps_refcount)) {\r\nsptlrpc_gc_del_sec(sec);\r\nsec_cop_destroy_sec(sec);\r\n}\r\n}\r\n}\r\nstatic\r\nstruct ptlrpc_sec * sptlrpc_sec_create(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svc_ctx,\r\nstruct sptlrpc_flavor *sf,\r\nenum lustre_sec_part sp)\r\n{\r\nstruct ptlrpc_sec_policy *policy;\r\nstruct ptlrpc_sec *sec;\r\nchar str[32];\r\nif (svc_ctx) {\r\nLASSERT(imp->imp_dlm_fake == 1);\r\nCDEBUG(D_SEC, "%s %s: reverse sec using flavor %s\n",\r\nimp->imp_obd->obd_type->typ_name,\r\nimp->imp_obd->obd_name,\r\nsptlrpc_flavor2name(sf, str, sizeof(str)));\r\npolicy = sptlrpc_policy_get(svc_ctx->sc_policy);\r\nsf->sf_flags |= PTLRPC_SEC_FL_REVERSE | PTLRPC_SEC_FL_ROOTONLY;\r\n} else {\r\nLASSERT(imp->imp_dlm_fake == 0);\r\nCDEBUG(D_SEC, "%s %s: select security flavor %s\n",\r\nimp->imp_obd->obd_type->typ_name,\r\nimp->imp_obd->obd_name,\r\nsptlrpc_flavor2name(sf, str, sizeof(str)));\r\npolicy = sptlrpc_wireflavor2policy(sf->sf_rpc);\r\nif (!policy) {\r\nCERROR("invalid flavor 0x%x\n", sf->sf_rpc);\r\nreturn NULL;\r\n}\r\n}\r\nsec = policy->sp_cops->create_sec(imp, svc_ctx, sf);\r\nif (sec) {\r\natomic_inc(&sec->ps_refcount);\r\nsec->ps_part = sp;\r\nif (sec->ps_gc_interval && policy->sp_cops->gc_ctx)\r\nsptlrpc_gc_add_sec(sec);\r\n} else {\r\nsptlrpc_policy_put(policy);\r\n}\r\nreturn sec;\r\n}\r\nstruct ptlrpc_sec *sptlrpc_import_sec_ref(struct obd_import *imp)\r\n{\r\nstruct ptlrpc_sec *sec;\r\nspin_lock(&imp->imp_lock);\r\nsec = sptlrpc_sec_get(imp->imp_sec);\r\nspin_unlock(&imp->imp_lock);\r\nreturn sec;\r\n}\r\nstatic void sptlrpc_import_sec_install(struct obd_import *imp,\r\nstruct ptlrpc_sec *sec)\r\n{\r\nstruct ptlrpc_sec *old_sec;\r\nLASSERT_ATOMIC_POS(&sec->ps_refcount);\r\nspin_lock(&imp->imp_lock);\r\nold_sec = imp->imp_sec;\r\nimp->imp_sec = sec;\r\nspin_unlock(&imp->imp_lock);\r\nif (old_sec) {\r\nsptlrpc_sec_kill(old_sec);\r\nsptlrpc_sec_put(old_sec);\r\n}\r\n}\r\nstatic inline\r\nint flavor_equal(struct sptlrpc_flavor *sf1, struct sptlrpc_flavor *sf2)\r\n{\r\nreturn (memcmp(sf1, sf2, sizeof(*sf1)) == 0);\r\n}\r\nstatic inline\r\nvoid flavor_copy(struct sptlrpc_flavor *dst, struct sptlrpc_flavor *src)\r\n{\r\n*dst = *src;\r\n}\r\nstatic void sptlrpc_import_sec_adapt_inplace(struct obd_import *imp,\r\nstruct ptlrpc_sec *sec,\r\nstruct sptlrpc_flavor *sf)\r\n{\r\nchar str1[32], str2[32];\r\nif (sec->ps_flvr.sf_flags != sf->sf_flags)\r\nCDEBUG(D_SEC, "changing sec flags: %s -> %s\n",\r\nsptlrpc_secflags2str(sec->ps_flvr.sf_flags,\r\nstr1, sizeof(str1)),\r\nsptlrpc_secflags2str(sf->sf_flags,\r\nstr2, sizeof(str2)));\r\nspin_lock(&sec->ps_lock);\r\nflavor_copy(&sec->ps_flvr, sf);\r\nspin_unlock(&sec->ps_lock);\r\n}\r\nint sptlrpc_import_sec_adapt(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *svc_ctx,\r\nstruct sptlrpc_flavor *flvr)\r\n{\r\nstruct ptlrpc_connection *conn;\r\nstruct sptlrpc_flavor sf;\r\nstruct ptlrpc_sec *sec, *newsec;\r\nenum lustre_sec_part sp;\r\nchar str[24];\r\nint rc = 0;\r\nmight_sleep();\r\nif (imp == NULL)\r\nreturn 0;\r\nconn = imp->imp_connection;\r\nif (svc_ctx == NULL) {\r\nstruct client_obd *cliobd = &imp->imp_obd->u.cli;\r\nif (cliobd->cl_sp_me == LUSTRE_SP_MGC)\r\nsf = cliobd->cl_flvr_mgc;\r\nelse\r\nsptlrpc_conf_choose_flavor(cliobd->cl_sp_me,\r\ncliobd->cl_sp_to,\r\n&cliobd->cl_target_uuid,\r\nconn->c_self, &sf);\r\nsp = imp->imp_obd->u.cli.cl_sp_me;\r\n} else {\r\nsf = *flvr;\r\nif (sf.sf_rpc != SPTLRPC_FLVR_NULL)\r\nsf.sf_flags = PTLRPC_SEC_FL_REVERSE |\r\nPTLRPC_SEC_FL_ROOTONLY;\r\nsp = sptlrpc_target_sec_part(imp->imp_obd);\r\n}\r\nsec = sptlrpc_import_sec_ref(imp);\r\nif (sec) {\r\nchar str2[24];\r\nif (flavor_equal(&sf, &sec->ps_flvr))\r\nGOTO(out, rc);\r\nCDEBUG(D_SEC, "import %s->%s: changing flavor %s -> %s\n",\r\nimp->imp_obd->obd_name,\r\nobd_uuid2str(&conn->c_remote_uuid),\r\nsptlrpc_flavor2name(&sec->ps_flvr, str, sizeof(str)),\r\nsptlrpc_flavor2name(&sf, str2, sizeof(str2)));\r\nif (SPTLRPC_FLVR_POLICY(sf.sf_rpc) ==\r\nSPTLRPC_FLVR_POLICY(sec->ps_flvr.sf_rpc) &&\r\nSPTLRPC_FLVR_MECH(sf.sf_rpc) ==\r\nSPTLRPC_FLVR_MECH(sec->ps_flvr.sf_rpc)) {\r\nsptlrpc_import_sec_adapt_inplace(imp, sec, &sf);\r\nGOTO(out, rc);\r\n}\r\n} else if (SPTLRPC_FLVR_BASE(sf.sf_rpc) !=\r\nSPTLRPC_FLVR_BASE(SPTLRPC_FLVR_NULL)) {\r\nCDEBUG(D_SEC, "import %s->%s netid %x: select flavor %s\n",\r\nimp->imp_obd->obd_name,\r\nobd_uuid2str(&conn->c_remote_uuid),\r\nLNET_NIDNET(conn->c_self),\r\nsptlrpc_flavor2name(&sf, str, sizeof(str)));\r\n}\r\nmutex_lock(&imp->imp_sec_mutex);\r\nnewsec = sptlrpc_sec_create(imp, svc_ctx, &sf, sp);\r\nif (newsec) {\r\nsptlrpc_import_sec_install(imp, newsec);\r\n} else {\r\nCERROR("import %s->%s: failed to create new sec\n",\r\nimp->imp_obd->obd_name,\r\nobd_uuid2str(&conn->c_remote_uuid));\r\nrc = -EPERM;\r\n}\r\nmutex_unlock(&imp->imp_sec_mutex);\r\nout:\r\nsptlrpc_sec_put(sec);\r\nreturn rc;\r\n}\r\nvoid sptlrpc_import_sec_put(struct obd_import *imp)\r\n{\r\nif (imp->imp_sec) {\r\nsptlrpc_sec_kill(imp->imp_sec);\r\nsptlrpc_sec_put(imp->imp_sec);\r\nimp->imp_sec = NULL;\r\n}\r\n}\r\nstatic void import_flush_ctx_common(struct obd_import *imp,\r\nuid_t uid, int grace, int force)\r\n{\r\nstruct ptlrpc_sec *sec;\r\nif (imp == NULL)\r\nreturn;\r\nsec = sptlrpc_import_sec_ref(imp);\r\nif (sec == NULL)\r\nreturn;\r\nsec_cop_flush_ctx_cache(sec, uid, grace, force);\r\nsptlrpc_sec_put(sec);\r\n}\r\nvoid sptlrpc_import_flush_root_ctx(struct obd_import *imp)\r\n{\r\nimport_flush_ctx_common(imp, 0, 1, 1);\r\n}\r\nvoid sptlrpc_import_flush_my_ctx(struct obd_import *imp)\r\n{\r\nimport_flush_ctx_common(imp, from_kuid(&init_user_ns, current_uid()),\r\n1, 1);\r\n}\r\nvoid sptlrpc_import_flush_all_ctx(struct obd_import *imp)\r\n{\r\nimport_flush_ctx_common(imp, -1, 1, 1);\r\n}\r\nint sptlrpc_cli_alloc_reqbuf(struct ptlrpc_request *req, int msgsize)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nstruct ptlrpc_sec_policy *policy;\r\nint rc;\r\nLASSERT(ctx);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(ctx->cc_sec->ps_policy);\r\nLASSERT(req->rq_reqmsg == NULL);\r\nLASSERT_ATOMIC_POS(&ctx->cc_refcount);\r\npolicy = ctx->cc_sec->ps_policy;\r\nrc = policy->sp_cops->alloc_reqbuf(ctx->cc_sec, req, msgsize);\r\nif (!rc) {\r\nLASSERT(req->rq_reqmsg);\r\nLASSERT(req->rq_reqbuf || req->rq_clrbuf);\r\nif (req->rq_pool)\r\nmemset(req->rq_reqmsg, 0, msgsize);\r\n}\r\nreturn rc;\r\n}\r\nvoid sptlrpc_cli_free_reqbuf(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nstruct ptlrpc_sec_policy *policy;\r\nLASSERT(ctx);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(ctx->cc_sec->ps_policy);\r\nLASSERT_ATOMIC_POS(&ctx->cc_refcount);\r\nif (req->rq_reqbuf == NULL && req->rq_clrbuf == NULL)\r\nreturn;\r\npolicy = ctx->cc_sec->ps_policy;\r\npolicy->sp_cops->free_reqbuf(ctx->cc_sec, req);\r\nreq->rq_reqmsg = NULL;\r\n}\r\nvoid _sptlrpc_enlarge_msg_inplace(struct lustre_msg *msg,\r\nint segment, int newsize)\r\n{\r\nvoid *src, *dst;\r\nint oldsize, oldmsg_size, movesize;\r\nLASSERT(segment < msg->lm_bufcount);\r\nLASSERT(msg->lm_buflens[segment] <= newsize);\r\nif (msg->lm_buflens[segment] == newsize)\r\nreturn;\r\nif (segment == msg->lm_bufcount - 1) {\r\nmsg->lm_buflens[segment] = newsize;\r\nreturn;\r\n}\r\noldsize = msg->lm_buflens[segment];\r\nsrc = lustre_msg_buf(msg, segment + 1, 0);\r\nmsg->lm_buflens[segment] = newsize;\r\ndst = lustre_msg_buf(msg, segment + 1, 0);\r\nmsg->lm_buflens[segment] = oldsize;\r\nLASSERT(msg->lm_magic == LUSTRE_MSG_MAGIC_V2);\r\noldmsg_size = lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\nmovesize = oldmsg_size - ((unsigned long) src - (unsigned long) msg);\r\nLASSERT(movesize >= 0);\r\nif (movesize)\r\nmemmove(dst, src, movesize);\r\nmsg->lm_buflens[segment] = newsize;\r\n}\r\nint sptlrpc_cli_enlarge_reqbuf(struct ptlrpc_request *req,\r\nint segment, int newsize)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nstruct ptlrpc_sec_cops *cops;\r\nstruct lustre_msg *msg = req->rq_reqmsg;\r\nLASSERT(ctx);\r\nLASSERT(msg);\r\nLASSERT(msg->lm_bufcount > segment);\r\nLASSERT(msg->lm_buflens[segment] <= newsize);\r\nif (msg->lm_buflens[segment] == newsize)\r\nreturn 0;\r\ncops = ctx->cc_sec->ps_policy->sp_cops;\r\nLASSERT(cops->enlarge_reqbuf);\r\nreturn cops->enlarge_reqbuf(ctx->cc_sec, req, segment, newsize);\r\n}\r\nint sptlrpc_cli_alloc_repbuf(struct ptlrpc_request *req, int msgsize)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nstruct ptlrpc_sec_policy *policy;\r\nLASSERT(ctx);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(ctx->cc_sec->ps_policy);\r\nif (req->rq_repbuf)\r\nreturn 0;\r\npolicy = ctx->cc_sec->ps_policy;\r\nreturn policy->sp_cops->alloc_repbuf(ctx->cc_sec, req, msgsize);\r\n}\r\nvoid sptlrpc_cli_free_repbuf(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx = req->rq_cli_ctx;\r\nstruct ptlrpc_sec_policy *policy;\r\nLASSERT(ctx);\r\nLASSERT(ctx->cc_sec);\r\nLASSERT(ctx->cc_sec->ps_policy);\r\nLASSERT_ATOMIC_POS(&ctx->cc_refcount);\r\nif (req->rq_repbuf == NULL)\r\nreturn;\r\nLASSERT(req->rq_repbuf_len);\r\npolicy = ctx->cc_sec->ps_policy;\r\npolicy->sp_cops->free_repbuf(ctx->cc_sec, req);\r\nreq->rq_repmsg = NULL;\r\n}\r\nint sptlrpc_cli_install_rvs_ctx(struct obd_import *imp,\r\nstruct ptlrpc_cli_ctx *ctx)\r\n{\r\nstruct ptlrpc_sec_policy *policy = ctx->cc_sec->ps_policy;\r\nif (!policy->sp_cops->install_rctx)\r\nreturn 0;\r\nreturn policy->sp_cops->install_rctx(imp, ctx->cc_sec, ctx);\r\n}\r\nint sptlrpc_svc_install_rvs_ctx(struct obd_import *imp,\r\nstruct ptlrpc_svc_ctx *ctx)\r\n{\r\nstruct ptlrpc_sec_policy *policy = ctx->sc_policy;\r\nif (!policy->sp_sops->install_rctx)\r\nreturn 0;\r\nreturn policy->sp_sops->install_rctx(imp, ctx);\r\n}\r\nstatic int flavor_allowed(struct sptlrpc_flavor *exp,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct sptlrpc_flavor *flvr = &req->rq_flvr;\r\nif (exp->sf_rpc == SPTLRPC_FLVR_ANY || exp->sf_rpc == flvr->sf_rpc)\r\nreturn 1;\r\nif ((req->rq_ctx_init || req->rq_ctx_fini) &&\r\nSPTLRPC_FLVR_POLICY(exp->sf_rpc) ==\r\nSPTLRPC_FLVR_POLICY(flvr->sf_rpc) &&\r\nSPTLRPC_FLVR_MECH(exp->sf_rpc) == SPTLRPC_FLVR_MECH(flvr->sf_rpc))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint sptlrpc_target_export_check(struct obd_export *exp,\r\nstruct ptlrpc_request *req)\r\n{\r\nstruct sptlrpc_flavor flavor;\r\nif (exp == NULL)\r\nreturn 0;\r\nif (exp->exp_imp_reverse == NULL)\r\nreturn 0;\r\nif (req->rq_ctx_fini)\r\nreturn 0;\r\nspin_lock(&exp->exp_lock);\r\nif (unlikely(exp->exp_flvr_changed) &&\r\nflavor_allowed(&exp->exp_flvr_old[1], req)) {\r\nCDEBUG(D_SEC, "exp %p: just changed: %x->%x\n", exp,\r\nexp->exp_flvr.sf_rpc, exp->exp_flvr_old[1].sf_rpc);\r\nflavor = exp->exp_flvr_old[1];\r\nexp->exp_flvr_old[1] = exp->exp_flvr_old[0];\r\nexp->exp_flvr_expire[1] = exp->exp_flvr_expire[0];\r\nexp->exp_flvr_old[0] = exp->exp_flvr;\r\nexp->exp_flvr_expire[0] = cfs_time_current_sec() +\r\nEXP_FLVR_UPDATE_EXPIRE;\r\nexp->exp_flvr = flavor;\r\nexp->exp_flvr_changed = 0;\r\nLASSERT(exp->exp_flvr_adapt == 1);\r\nif (req->rq_auth_gss &&\r\n!(req->rq_ctx_init &&\r\n(req->rq_auth_usr_root || req->rq_auth_usr_mdt ||\r\nreq->rq_auth_usr_ost))) {\r\nspin_unlock(&exp->exp_lock);\r\nCDEBUG(D_SEC, "is good but not root(%d:%d:%d:%d:%d)\n",\r\nreq->rq_auth_gss, req->rq_ctx_init,\r\nreq->rq_auth_usr_root, req->rq_auth_usr_mdt,\r\nreq->rq_auth_usr_ost);\r\nreturn 0;\r\n}\r\nexp->exp_flvr_adapt = 0;\r\nspin_unlock(&exp->exp_lock);\r\nreturn sptlrpc_import_sec_adapt(exp->exp_imp_reverse,\r\nreq->rq_svc_ctx, &flavor);\r\n}\r\nif (likely(flavor_allowed(&exp->exp_flvr, req))) {\r\nif (!req->rq_auth_gss || !req->rq_ctx_init ||\r\n(!req->rq_auth_usr_root && !req->rq_auth_usr_mdt &&\r\n!req->rq_auth_usr_ost)) {\r\nspin_unlock(&exp->exp_lock);\r\nreturn 0;\r\n}\r\nif (exp->exp_flvr_changed) {\r\nLASSERT(exp->exp_flvr_adapt);\r\nspin_unlock(&exp->exp_lock);\r\nreturn 0;\r\n}\r\nif (exp->exp_flvr_adapt) {\r\nexp->exp_flvr_adapt = 0;\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): do delayed adapt\n",\r\nexp, exp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc,\r\nexp->exp_flvr_old[1].sf_rpc);\r\nflavor = exp->exp_flvr;\r\nspin_unlock(&exp->exp_lock);\r\nreturn sptlrpc_import_sec_adapt(exp->exp_imp_reverse,\r\nreq->rq_svc_ctx,\r\n&flavor);\r\n} else {\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): is current flavor, "\r\n"install rvs ctx\n", exp, exp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc,\r\nexp->exp_flvr_old[1].sf_rpc);\r\nspin_unlock(&exp->exp_lock);\r\nreturn sptlrpc_svc_install_rvs_ctx(exp->exp_imp_reverse,\r\nreq->rq_svc_ctx);\r\n}\r\n}\r\nif (exp->exp_flvr_expire[0]) {\r\nif (exp->exp_flvr_expire[0] >= cfs_time_current_sec()) {\r\nif (flavor_allowed(&exp->exp_flvr_old[0], req)) {\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): match the "\r\n"middle one ("CFS_DURATION_T")\n", exp,\r\nexp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc,\r\nexp->exp_flvr_old[1].sf_rpc,\r\nexp->exp_flvr_expire[0] -\r\ncfs_time_current_sec());\r\nspin_unlock(&exp->exp_lock);\r\nreturn 0;\r\n}\r\n} else {\r\nCDEBUG(D_SEC, "mark middle expired\n");\r\nexp->exp_flvr_expire[0] = 0;\r\n}\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): %x not match middle\n", exp,\r\nexp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc, exp->exp_flvr_old[1].sf_rpc,\r\nreq->rq_flvr.sf_rpc);\r\n}\r\nif (exp->exp_flvr_changed == 0 && exp->exp_flvr_expire[1]) {\r\nif (exp->exp_flvr_expire[1] >= cfs_time_current_sec()) {\r\nif (flavor_allowed(&exp->exp_flvr_old[1], req)) {\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): match the "\r\n"oldest one ("CFS_DURATION_T")\n", exp,\r\nexp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc,\r\nexp->exp_flvr_old[1].sf_rpc,\r\nexp->exp_flvr_expire[1] -\r\ncfs_time_current_sec());\r\nspin_unlock(&exp->exp_lock);\r\nreturn 0;\r\n}\r\n} else {\r\nCDEBUG(D_SEC, "mark oldest expired\n");\r\nexp->exp_flvr_expire[1] = 0;\r\n}\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): %x not match found\n",\r\nexp, exp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc, exp->exp_flvr_old[1].sf_rpc,\r\nreq->rq_flvr.sf_rpc);\r\n} else {\r\nCDEBUG(D_SEC, "exp %p (%x|%x|%x): skip the last one\n",\r\nexp, exp->exp_flvr.sf_rpc, exp->exp_flvr_old[0].sf_rpc,\r\nexp->exp_flvr_old[1].sf_rpc);\r\n}\r\nspin_unlock(&exp->exp_lock);\r\nCWARN("exp %p(%s): req %p (%u|%u|%u|%u|%u|%u) with "\r\n"unauthorized flavor %x, expect %x|%x(%+ld)|%x(%+ld)\n",\r\nexp, exp->exp_obd->obd_name,\r\nreq, req->rq_auth_gss, req->rq_ctx_init, req->rq_ctx_fini,\r\nreq->rq_auth_usr_root, req->rq_auth_usr_mdt, req->rq_auth_usr_ost,\r\nreq->rq_flvr.sf_rpc,\r\nexp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[0].sf_rpc,\r\nexp->exp_flvr_expire[0] ?\r\n(unsigned long) (exp->exp_flvr_expire[0] -\r\ncfs_time_current_sec()) : 0,\r\nexp->exp_flvr_old[1].sf_rpc,\r\nexp->exp_flvr_expire[1] ?\r\n(unsigned long) (exp->exp_flvr_expire[1] -\r\ncfs_time_current_sec()) : 0);\r\nreturn -EACCES;\r\n}\r\nvoid sptlrpc_target_update_exp_flavor(struct obd_device *obd,\r\nstruct sptlrpc_rule_set *rset)\r\n{\r\nstruct obd_export *exp;\r\nstruct sptlrpc_flavor new_flvr;\r\nLASSERT(obd);\r\nspin_lock(&obd->obd_dev_lock);\r\nlist_for_each_entry(exp, &obd->obd_exports, exp_obd_chain) {\r\nif (exp->exp_connection == NULL)\r\ncontinue;\r\nspin_lock(&exp->exp_lock);\r\nsptlrpc_target_choose_flavor(rset, exp->exp_sp_peer,\r\nexp->exp_connection->c_peer.nid,\r\n&new_flvr);\r\nif (exp->exp_flvr_changed ||\r\n!flavor_equal(&new_flvr, &exp->exp_flvr)) {\r\nexp->exp_flvr_old[1] = new_flvr;\r\nexp->exp_flvr_expire[1] = 0;\r\nexp->exp_flvr_changed = 1;\r\nexp->exp_flvr_adapt = 1;\r\nCDEBUG(D_SEC, "exp %p (%s): updated flavor %x->%x\n",\r\nexp, sptlrpc_part2name(exp->exp_sp_peer),\r\nexp->exp_flvr.sf_rpc,\r\nexp->exp_flvr_old[1].sf_rpc);\r\n}\r\nspin_unlock(&exp->exp_lock);\r\n}\r\nspin_unlock(&obd->obd_dev_lock);\r\n}\r\nstatic int sptlrpc_svc_check_from(struct ptlrpc_request *req, int svc_rc)\r\n{\r\nif (!req->rq_auth_gss || svc_rc == SECSVC_DROP)\r\nreturn svc_rc;\r\nswitch (req->rq_sp_from) {\r\ncase LUSTRE_SP_CLI:\r\nif (req->rq_auth_usr_mdt || req->rq_auth_usr_ost) {\r\nDEBUG_REQ(D_ERROR, req, "faked source CLI");\r\nsvc_rc = SECSVC_DROP;\r\n}\r\nbreak;\r\ncase LUSTRE_SP_MDT:\r\nif (!req->rq_auth_usr_mdt) {\r\nDEBUG_REQ(D_ERROR, req, "faked source MDT");\r\nsvc_rc = SECSVC_DROP;\r\n}\r\nbreak;\r\ncase LUSTRE_SP_OST:\r\nif (!req->rq_auth_usr_ost) {\r\nDEBUG_REQ(D_ERROR, req, "faked source OST");\r\nsvc_rc = SECSVC_DROP;\r\n}\r\nbreak;\r\ncase LUSTRE_SP_MGS:\r\ncase LUSTRE_SP_MGC:\r\nif (!req->rq_auth_usr_root && !req->rq_auth_usr_mdt &&\r\n!req->rq_auth_usr_ost) {\r\nDEBUG_REQ(D_ERROR, req, "faked source MGC/MGS");\r\nsvc_rc = SECSVC_DROP;\r\n}\r\nbreak;\r\ncase LUSTRE_SP_ANY:\r\ndefault:\r\nDEBUG_REQ(D_ERROR, req, "invalid source %u", req->rq_sp_from);\r\nsvc_rc = SECSVC_DROP;\r\n}\r\nreturn svc_rc;\r\n}\r\nint sptlrpc_svc_unwrap_request(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_sec_policy *policy;\r\nstruct lustre_msg *msg = req->rq_reqbuf;\r\nint rc;\r\nLASSERT(msg);\r\nLASSERT(req->rq_reqmsg == NULL);\r\nLASSERT(req->rq_repmsg == NULL);\r\nLASSERT(req->rq_svc_ctx == NULL);\r\nreq->rq_req_swab_mask = 0;\r\nrc = __lustre_unpack_msg(msg, req->rq_reqdata_len);\r\nswitch (rc) {\r\ncase 1:\r\nlustre_set_req_swabbed(req, MSG_PTLRPC_HEADER_OFF);\r\ncase 0:\r\nbreak;\r\ndefault:\r\nCERROR("error unpacking request from %s x"LPU64"\n",\r\nlibcfs_id2str(req->rq_peer), req->rq_xid);\r\nreturn SECSVC_DROP;\r\n}\r\nreq->rq_flvr.sf_rpc = WIRE_FLVR(msg->lm_secflvr);\r\nreq->rq_sp_from = LUSTRE_SP_ANY;\r\nreq->rq_auth_uid = -1;\r\nreq->rq_auth_mapped_uid = -1;\r\npolicy = sptlrpc_wireflavor2policy(req->rq_flvr.sf_rpc);\r\nif (!policy) {\r\nCERROR("unsupported rpc flavor %x\n", req->rq_flvr.sf_rpc);\r\nreturn SECSVC_DROP;\r\n}\r\nLASSERT(policy->sp_sops->accept);\r\nrc = policy->sp_sops->accept(req);\r\nsptlrpc_policy_put(policy);\r\nLASSERT(req->rq_reqmsg || rc != SECSVC_OK);\r\nLASSERT(req->rq_svc_ctx || rc == SECSVC_DROP);\r\nif (SPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc) != SPTLRPC_POLICY_NULL)\r\nreq->rq_req_swab_mask = 0;\r\nrc = sptlrpc_svc_check_from(req, rc);\r\nreturn rc;\r\n}\r\nint sptlrpc_svc_alloc_rs(struct ptlrpc_request *req, int msglen)\r\n{\r\nstruct ptlrpc_sec_policy *policy;\r\nstruct ptlrpc_reply_state *rs;\r\nint rc;\r\nLASSERT(req->rq_svc_ctx);\r\nLASSERT(req->rq_svc_ctx->sc_policy);\r\npolicy = req->rq_svc_ctx->sc_policy;\r\nLASSERT(policy->sp_sops->alloc_rs);\r\nrc = policy->sp_sops->alloc_rs(req, msglen);\r\nif (unlikely(rc == -ENOMEM)) {\r\nrs = lustre_get_emerg_rs(req->rq_rqbd->rqbd_svcpt);\r\nif (rs == NULL)\r\nreturn -ENOMEM;\r\nreq->rq_reply_state = rs;\r\nrc = policy->sp_sops->alloc_rs(req, msglen);\r\nif (rc) {\r\nlustre_put_emerg_rs(rs);\r\nreq->rq_reply_state = NULL;\r\n}\r\n}\r\nLASSERT(rc != 0 ||\r\n(req->rq_reply_state && req->rq_reply_state->rs_msg));\r\nreturn rc;\r\n}\r\nint sptlrpc_svc_wrap_reply(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_sec_policy *policy;\r\nint rc;\r\nLASSERT(req->rq_svc_ctx);\r\nLASSERT(req->rq_svc_ctx->sc_policy);\r\npolicy = req->rq_svc_ctx->sc_policy;\r\nLASSERT(policy->sp_sops->authorize);\r\nrc = policy->sp_sops->authorize(req);\r\nLASSERT(rc || req->rq_reply_state->rs_repdata_len);\r\nreturn rc;\r\n}\r\nvoid sptlrpc_svc_free_rs(struct ptlrpc_reply_state *rs)\r\n{\r\nstruct ptlrpc_sec_policy *policy;\r\nunsigned int prealloc;\r\nLASSERT(rs->rs_svc_ctx);\r\nLASSERT(rs->rs_svc_ctx->sc_policy);\r\npolicy = rs->rs_svc_ctx->sc_policy;\r\nLASSERT(policy->sp_sops->free_rs);\r\nprealloc = rs->rs_prealloc;\r\npolicy->sp_sops->free_rs(rs);\r\nif (prealloc)\r\nlustre_put_emerg_rs(rs);\r\n}\r\nvoid sptlrpc_svc_ctx_addref(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_svc_ctx *ctx = req->rq_svc_ctx;\r\nif (ctx != NULL)\r\natomic_inc(&ctx->sc_refcount);\r\n}\r\nvoid sptlrpc_svc_ctx_decref(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_svc_ctx *ctx = req->rq_svc_ctx;\r\nif (ctx == NULL)\r\nreturn;\r\nLASSERT_ATOMIC_POS(&ctx->sc_refcount);\r\nif (atomic_dec_and_test(&ctx->sc_refcount)) {\r\nif (ctx->sc_policy->sp_sops->free_ctx)\r\nctx->sc_policy->sp_sops->free_ctx(ctx);\r\n}\r\nreq->rq_svc_ctx = NULL;\r\n}\r\nvoid sptlrpc_svc_ctx_invalidate(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_svc_ctx *ctx = req->rq_svc_ctx;\r\nif (ctx == NULL)\r\nreturn;\r\nLASSERT_ATOMIC_POS(&ctx->sc_refcount);\r\nif (ctx->sc_policy->sp_sops->invalidate_ctx)\r\nctx->sc_policy->sp_sops->invalidate_ctx(ctx);\r\n}\r\nint sptlrpc_cli_wrap_bulk(struct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx;\r\nLASSERT(req->rq_bulk_read || req->rq_bulk_write);\r\nif (!req->rq_pack_bulk)\r\nreturn 0;\r\nctx = req->rq_cli_ctx;\r\nif (ctx->cc_ops->wrap_bulk)\r\nreturn ctx->cc_ops->wrap_bulk(ctx, req, desc);\r\nreturn 0;\r\n}\r\nint sptlrpc_cli_unwrap_bulk_read(struct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc,\r\nint nob)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx;\r\nint rc;\r\nLASSERT(req->rq_bulk_read && !req->rq_bulk_write);\r\nif (!req->rq_pack_bulk)\r\nreturn desc->bd_nob_transferred;\r\nctx = req->rq_cli_ctx;\r\nif (ctx->cc_ops->unwrap_bulk) {\r\nrc = ctx->cc_ops->unwrap_bulk(ctx, req, desc);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nreturn desc->bd_nob_transferred;\r\n}\r\nint sptlrpc_cli_unwrap_bulk_write(struct ptlrpc_request *req,\r\nstruct ptlrpc_bulk_desc *desc)\r\n{\r\nstruct ptlrpc_cli_ctx *ctx;\r\nint rc;\r\nLASSERT(!req->rq_bulk_read && req->rq_bulk_write);\r\nif (!req->rq_pack_bulk)\r\nreturn 0;\r\nctx = req->rq_cli_ctx;\r\nif (ctx->cc_ops->unwrap_bulk) {\r\nrc = ctx->cc_ops->unwrap_bulk(ctx, req, desc);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (desc->bd_nob != desc->bd_nob_transferred) {\r\nCERROR("nob %d doesn't match transferred nob %d",\r\ndesc->bd_nob, desc->bd_nob_transferred);\r\nreturn -EPROTO;\r\n}\r\nreturn 0;\r\n}\r\nint sptlrpc_current_user_desc_size(void)\r\n{\r\nint ngroups;\r\nngroups = current_ngroups;\r\nif (ngroups > LUSTRE_MAX_GROUPS)\r\nngroups = LUSTRE_MAX_GROUPS;\r\nreturn sptlrpc_user_desc_size(ngroups);\r\n}\r\nint sptlrpc_pack_user_desc(struct lustre_msg *msg, int offset)\r\n{\r\nstruct ptlrpc_user_desc *pud;\r\npud = lustre_msg_buf(msg, offset, 0);\r\npud->pud_uid = from_kuid(&init_user_ns, current_uid());\r\npud->pud_gid = from_kgid(&init_user_ns, current_gid());\r\npud->pud_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\npud->pud_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\npud->pud_cap = cfs_curproc_cap_pack();\r\npud->pud_ngroups = (msg->lm_buflens[offset] - sizeof(*pud)) / 4;\r\ntask_lock(current);\r\nif (pud->pud_ngroups > current_ngroups)\r\npud->pud_ngroups = current_ngroups;\r\nmemcpy(pud->pud_groups, current_cred()->group_info->blocks[0],\r\npud->pud_ngroups * sizeof(__u32));\r\ntask_unlock(current);\r\nreturn 0;\r\n}\r\nint sptlrpc_unpack_user_desc(struct lustre_msg *msg, int offset, int swabbed)\r\n{\r\nstruct ptlrpc_user_desc *pud;\r\nint i;\r\npud = lustre_msg_buf(msg, offset, sizeof(*pud));\r\nif (!pud)\r\nreturn -EINVAL;\r\nif (swabbed) {\r\n__swab32s(&pud->pud_uid);\r\n__swab32s(&pud->pud_gid);\r\n__swab32s(&pud->pud_fsuid);\r\n__swab32s(&pud->pud_fsgid);\r\n__swab32s(&pud->pud_cap);\r\n__swab32s(&pud->pud_ngroups);\r\n}\r\nif (pud->pud_ngroups > LUSTRE_MAX_GROUPS) {\r\nCERROR("%u groups is too large\n", pud->pud_ngroups);\r\nreturn -EINVAL;\r\n}\r\nif (sizeof(*pud) + pud->pud_ngroups * sizeof(__u32) >\r\nmsg->lm_buflens[offset]) {\r\nCERROR("%u groups are claimed but bufsize only %u\n",\r\npud->pud_ngroups, msg->lm_buflens[offset]);\r\nreturn -EINVAL;\r\n}\r\nif (swabbed) {\r\nfor (i = 0; i < pud->pud_ngroups; i++)\r\n__swab32s(&pud->pud_groups[i]);\r\n}\r\nreturn 0;\r\n}\r\nconst char * sec2target_str(struct ptlrpc_sec *sec)\r\n{\r\nif (!sec || !sec->ps_import || !sec->ps_import->imp_obd)\r\nreturn "*";\r\nif (sec_is_reverse(sec))\r\nreturn "c";\r\nreturn obd_uuid2str(&sec->ps_import->imp_obd->u.cli.cl_target_uuid);\r\n}\r\nint sptlrpc_flavor_has_bulk(struct sptlrpc_flavor *flvr)\r\n{\r\nswitch (SPTLRPC_FLVR_BULK_SVC(flvr->sf_rpc)) {\r\ncase SPTLRPC_BULK_SVC_INTG:\r\ncase SPTLRPC_BULK_SVC_PRIV:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint sptlrpc_init(void)\r\n{\r\nint rc;\r\nrwlock_init(&policy_lock);\r\nrc = sptlrpc_gc_init();\r\nif (rc)\r\ngoto out;\r\nrc = sptlrpc_conf_init();\r\nif (rc)\r\ngoto out_gc;\r\nrc = sptlrpc_enc_pool_init();\r\nif (rc)\r\ngoto out_conf;\r\nrc = sptlrpc_null_init();\r\nif (rc)\r\ngoto out_pool;\r\nrc = sptlrpc_plain_init();\r\nif (rc)\r\ngoto out_null;\r\nrc = sptlrpc_lproc_init();\r\nif (rc)\r\ngoto out_plain;\r\nreturn 0;\r\nout_plain:\r\nsptlrpc_plain_fini();\r\nout_null:\r\nsptlrpc_null_fini();\r\nout_pool:\r\nsptlrpc_enc_pool_fini();\r\nout_conf:\r\nsptlrpc_conf_fini();\r\nout_gc:\r\nsptlrpc_gc_fini();\r\nout:\r\nreturn rc;\r\n}\r\nvoid sptlrpc_fini(void)\r\n{\r\nsptlrpc_lproc_fini();\r\nsptlrpc_plain_fini();\r\nsptlrpc_null_fini();\r\nsptlrpc_enc_pool_fini();\r\nsptlrpc_conf_fini();\r\nsptlrpc_gc_fini();\r\n}
