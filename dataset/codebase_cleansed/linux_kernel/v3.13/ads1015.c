static int ads1015_read_adc(struct i2c_client *client, unsigned int channel)\r\n{\r\nu16 config;\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nunsigned int pga = data->channel_data[channel].pga;\r\nunsigned int data_rate = data->channel_data[channel].data_rate;\r\nunsigned int conversion_time_ms;\r\nconst unsigned int * const rate_table = data->id == ads1115 ?\r\ndata_rate_table_1115 : data_rate_table_1015;\r\nint res;\r\nmutex_lock(&data->update_lock);\r\nres = i2c_smbus_read_word_swapped(client, ADS1015_CONFIG);\r\nif (res < 0)\r\ngoto err_unlock;\r\nconfig = res;\r\nconversion_time_ms = DIV_ROUND_UP(1000, rate_table[data_rate]);\r\nconfig &= 0x001f;\r\nconfig |= (1 << 15) | (1 << 8);\r\nconfig |= (channel & 0x0007) << 12;\r\nconfig |= (pga & 0x0007) << 9;\r\nconfig |= (data_rate & 0x0007) << 5;\r\nres = i2c_smbus_write_word_swapped(client, ADS1015_CONFIG, config);\r\nif (res < 0)\r\ngoto err_unlock;\r\nmsleep(conversion_time_ms);\r\nres = i2c_smbus_read_word_swapped(client, ADS1015_CONFIG);\r\nif (res < 0)\r\ngoto err_unlock;\r\nconfig = res;\r\nif (!(config & (1 << 15))) {\r\nres = -EIO;\r\ngoto err_unlock;\r\n}\r\nres = i2c_smbus_read_word_swapped(client, ADS1015_CONVERSION);\r\nerr_unlock:\r\nmutex_unlock(&data->update_lock);\r\nreturn res;\r\n}\r\nstatic int ads1015_reg_to_mv(struct i2c_client *client, unsigned int channel,\r\ns16 reg)\r\n{\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nunsigned int pga = data->channel_data[channel].pga;\r\nint fullscale = fullscale_table[pga];\r\nconst unsigned mask = data->id == ads1115 ? 0x7fff : 0x7ff0;\r\nreturn DIV_ROUND_CLOSEST(reg * fullscale, mask);\r\n}\r\nstatic ssize_t show_in(struct device *dev, struct device_attribute *da,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(da);\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint res;\r\nint index = attr->index;\r\nres = ads1015_read_adc(client, index);\r\nif (res < 0)\r\nreturn res;\r\nreturn sprintf(buf, "%d\n", ads1015_reg_to_mv(client, index, res));\r\n}\r\nstatic int ads1015_remove(struct i2c_client *client)\r\n{\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nint k;\r\nhwmon_device_unregister(data->hwmon_dev);\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k)\r\ndevice_remove_file(&client->dev, &ads1015_in[k].dev_attr);\r\nreturn 0;\r\n}\r\nstatic int ads1015_get_channels_config_of(struct i2c_client *client)\r\n{\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nstruct device_node *node;\r\nif (!client->dev.of_node\r\n|| !of_get_next_child(client->dev.of_node, NULL))\r\nreturn -EINVAL;\r\nfor_each_child_of_node(client->dev.of_node, node) {\r\nconst __be32 *property;\r\nint len;\r\nunsigned int channel;\r\nunsigned int pga = ADS1015_DEFAULT_PGA;\r\nunsigned int data_rate = ADS1015_DEFAULT_DATA_RATE;\r\nproperty = of_get_property(node, "reg", &len);\r\nif (!property || len != sizeof(int)) {\r\ndev_err(&client->dev, "invalid reg on %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\nchannel = be32_to_cpup(property);\r\nif (channel > ADS1015_CHANNELS) {\r\ndev_err(&client->dev,\r\n"invalid channel index %d on %s\n",\r\nchannel, node->full_name);\r\ncontinue;\r\n}\r\nproperty = of_get_property(node, "ti,gain", &len);\r\nif (property && len == sizeof(int)) {\r\npga = be32_to_cpup(property);\r\nif (pga > 6) {\r\ndev_err(&client->dev,\r\n"invalid gain on %s\n",\r\nnode->full_name);\r\n}\r\n}\r\nproperty = of_get_property(node, "ti,datarate", &len);\r\nif (property && len == sizeof(int)) {\r\ndata_rate = be32_to_cpup(property);\r\nif (data_rate > 7) {\r\ndev_err(&client->dev,\r\n"invalid data_rate on %s\n",\r\nnode->full_name);\r\n}\r\n}\r\ndata->channel_data[channel].enabled = true;\r\ndata->channel_data[channel].pga = pga;\r\ndata->channel_data[channel].data_rate = data_rate;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ads1015_get_channels_config(struct i2c_client *client)\r\n{\r\nunsigned int k;\r\nstruct ads1015_data *data = i2c_get_clientdata(client);\r\nstruct ads1015_platform_data *pdata = dev_get_platdata(&client->dev);\r\nif (pdata) {\r\nmemcpy(data->channel_data, pdata->channel_data,\r\nsizeof(data->channel_data));\r\nreturn;\r\n}\r\n#ifdef CONFIG_OF\r\nif (!ads1015_get_channels_config_of(client))\r\nreturn;\r\n#endif\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k) {\r\ndata->channel_data[k].enabled = true;\r\ndata->channel_data[k].pga = ADS1015_DEFAULT_PGA;\r\ndata->channel_data[k].data_rate = ADS1015_DEFAULT_DATA_RATE;\r\n}\r\n}\r\nstatic int ads1015_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct ads1015_data *data;\r\nint err;\r\nunsigned int k;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct ads1015_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->id = id->driver_data;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nads1015_get_channels_config(client);\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k) {\r\nif (!data->channel_data[k].enabled)\r\ncontinue;\r\nerr = device_create_file(&client->dev, &ads1015_in[k].dev_attr);\r\nif (err)\r\ngoto exit_remove;\r\n}\r\ndata->hwmon_dev = hwmon_device_register(&client->dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto exit_remove;\r\n}\r\nreturn 0;\r\nexit_remove:\r\nfor (k = 0; k < ADS1015_CHANNELS; ++k)\r\ndevice_remove_file(&client->dev, &ads1015_in[k].dev_attr);\r\nreturn err;\r\n}
