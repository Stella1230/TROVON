int hfsplus_ext_cmp_key(const hfsplus_btree_key *k1,\r\nconst hfsplus_btree_key *k2)\r\n{\r\n__be32 k1id, k2id;\r\n__be32 k1s, k2s;\r\nk1id = k1->ext.cnid;\r\nk2id = k2->ext.cnid;\r\nif (k1id != k2id)\r\nreturn be32_to_cpu(k1id) < be32_to_cpu(k2id) ? -1 : 1;\r\nif (k1->ext.fork_type != k2->ext.fork_type)\r\nreturn k1->ext.fork_type < k2->ext.fork_type ? -1 : 1;\r\nk1s = k1->ext.start_block;\r\nk2s = k2->ext.start_block;\r\nif (k1s == k2s)\r\nreturn 0;\r\nreturn be32_to_cpu(k1s) < be32_to_cpu(k2s) ? -1 : 1;\r\n}\r\nstatic void hfsplus_ext_build_key(hfsplus_btree_key *key, u32 cnid,\r\nu32 block, u8 type)\r\n{\r\nkey->key_len = cpu_to_be16(HFSPLUS_EXT_KEYLEN - 2);\r\nkey->ext.cnid = cpu_to_be32(cnid);\r\nkey->ext.start_block = cpu_to_be32(block);\r\nkey->ext.fork_type = type;\r\nkey->ext.pad = 0;\r\n}\r\nstatic u32 hfsplus_ext_find_block(struct hfsplus_extent *ext, u32 off)\r\n{\r\nint i;\r\nu32 count;\r\nfor (i = 0; i < 8; ext++, i++) {\r\ncount = be32_to_cpu(ext->block_count);\r\nif (off < count)\r\nreturn be32_to_cpu(ext->start_block) + off;\r\noff -= count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hfsplus_ext_block_count(struct hfsplus_extent *ext)\r\n{\r\nint i;\r\nu32 count = 0;\r\nfor (i = 0; i < 8; ext++, i++)\r\ncount += be32_to_cpu(ext->block_count);\r\nreturn count;\r\n}\r\nstatic u32 hfsplus_ext_lastblock(struct hfsplus_extent *ext)\r\n{\r\nint i;\r\next += 7;\r\nfor (i = 0; i < 7; ext--, i++)\r\nif (ext->block_count)\r\nbreak;\r\nreturn be32_to_cpu(ext->start_block) + be32_to_cpu(ext->block_count);\r\n}\r\nstatic int __hfsplus_ext_write_extent(struct inode *inode,\r\nstruct hfs_find_data *fd)\r\n{\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nint res;\r\nWARN_ON(!mutex_is_locked(&hip->extents_lock));\r\nhfsplus_ext_build_key(fd->search_key, inode->i_ino, hip->cached_start,\r\nHFSPLUS_IS_RSRC(inode) ?\r\nHFSPLUS_TYPE_RSRC : HFSPLUS_TYPE_DATA);\r\nres = hfs_brec_find(fd, hfs_find_rec_by_key);\r\nif (hip->extent_state & HFSPLUS_EXT_NEW) {\r\nif (res != -ENOENT)\r\nreturn res;\r\nhfs_brec_insert(fd, hip->cached_extents,\r\nsizeof(hfsplus_extent_rec));\r\nhip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\r\n} else {\r\nif (res)\r\nreturn res;\r\nhfs_bnode_write(fd->bnode, hip->cached_extents,\r\nfd->entryoffset, fd->entrylength);\r\nhip->extent_state &= ~HFSPLUS_EXT_DIRTY;\r\n}\r\nset_bit(HFSPLUS_I_EXT_DIRTY, &hip->flags);\r\nreturn 0;\r\n}\r\nstatic int hfsplus_ext_write_extent_locked(struct inode *inode)\r\n{\r\nint res = 0;\r\nif (HFSPLUS_I(inode)->extent_state & HFSPLUS_EXT_DIRTY) {\r\nstruct hfs_find_data fd;\r\nres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\r\nif (res)\r\nreturn res;\r\nres = __hfsplus_ext_write_extent(inode, &fd);\r\nhfs_find_exit(&fd);\r\n}\r\nreturn res;\r\n}\r\nint hfsplus_ext_write_extent(struct inode *inode)\r\n{\r\nint res;\r\nmutex_lock(&HFSPLUS_I(inode)->extents_lock);\r\nres = hfsplus_ext_write_extent_locked(inode);\r\nmutex_unlock(&HFSPLUS_I(inode)->extents_lock);\r\nreturn res;\r\n}\r\nstatic inline int __hfsplus_ext_read_extent(struct hfs_find_data *fd,\r\nstruct hfsplus_extent *extent,\r\nu32 cnid, u32 block, u8 type)\r\n{\r\nint res;\r\nhfsplus_ext_build_key(fd->search_key, cnid, block, type);\r\nfd->key->ext.cnid = 0;\r\nres = hfs_brec_find(fd, hfs_find_rec_by_key);\r\nif (res && res != -ENOENT)\r\nreturn res;\r\nif (fd->key->ext.cnid != fd->search_key->ext.cnid ||\r\nfd->key->ext.fork_type != fd->search_key->ext.fork_type)\r\nreturn -ENOENT;\r\nif (fd->entrylength != sizeof(hfsplus_extent_rec))\r\nreturn -EIO;\r\nhfs_bnode_read(fd->bnode, extent, fd->entryoffset,\r\nsizeof(hfsplus_extent_rec));\r\nreturn 0;\r\n}\r\nstatic inline int __hfsplus_ext_cache_extent(struct hfs_find_data *fd,\r\nstruct inode *inode, u32 block)\r\n{\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nint res;\r\nWARN_ON(!mutex_is_locked(&hip->extents_lock));\r\nif (hip->extent_state & HFSPLUS_EXT_DIRTY) {\r\nres = __hfsplus_ext_write_extent(inode, fd);\r\nif (res)\r\nreturn res;\r\n}\r\nres = __hfsplus_ext_read_extent(fd, hip->cached_extents, inode->i_ino,\r\nblock, HFSPLUS_IS_RSRC(inode) ?\r\nHFSPLUS_TYPE_RSRC :\r\nHFSPLUS_TYPE_DATA);\r\nif (!res) {\r\nhip->cached_start = be32_to_cpu(fd->key->ext.start_block);\r\nhip->cached_blocks =\r\nhfsplus_ext_block_count(hip->cached_extents);\r\n} else {\r\nhip->cached_start = hip->cached_blocks = 0;\r\nhip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\r\n}\r\nreturn res;\r\n}\r\nstatic int hfsplus_ext_read_extent(struct inode *inode, u32 block)\r\n{\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nstruct hfs_find_data fd;\r\nint res;\r\nif (block >= hip->cached_start &&\r\nblock < hip->cached_start + hip->cached_blocks)\r\nreturn 0;\r\nres = hfs_find_init(HFSPLUS_SB(inode->i_sb)->ext_tree, &fd);\r\nif (!res) {\r\nres = __hfsplus_ext_cache_extent(&fd, inode, block);\r\nhfs_find_exit(&fd);\r\n}\r\nreturn res;\r\n}\r\nint hfsplus_get_block(struct inode *inode, sector_t iblock,\r\nstruct buffer_head *bh_result, int create)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nint res = -EIO;\r\nu32 ablock, dblock, mask;\r\nsector_t sector;\r\nint was_dirty = 0;\r\nint shift;\r\nshift = sbi->alloc_blksz_shift - sb->s_blocksize_bits;\r\nablock = iblock >> sbi->fs_shift;\r\nif (iblock >= hip->fs_blocks) {\r\nif (iblock > hip->fs_blocks || !create)\r\nreturn -EIO;\r\nif (ablock >= hip->alloc_blocks) {\r\nres = hfsplus_file_extend(inode);\r\nif (res)\r\nreturn res;\r\n}\r\n} else\r\ncreate = 0;\r\nif (ablock < hip->first_blocks) {\r\ndblock = hfsplus_ext_find_block(hip->first_extents, ablock);\r\ngoto done;\r\n}\r\nif (inode->i_ino == HFSPLUS_EXT_CNID)\r\nreturn -EIO;\r\nmutex_lock(&hip->extents_lock);\r\nwas_dirty = (hip->extent_state & HFSPLUS_EXT_DIRTY);\r\nres = hfsplus_ext_read_extent(inode, ablock);\r\nif (res) {\r\nmutex_unlock(&hip->extents_lock);\r\nreturn -EIO;\r\n}\r\ndblock = hfsplus_ext_find_block(hip->cached_extents,\r\nablock - hip->cached_start);\r\nmutex_unlock(&hip->extents_lock);\r\ndone:\r\nhfs_dbg(EXTENT, "get_block(%lu): %llu - %u\n",\r\ninode->i_ino, (long long)iblock, dblock);\r\nmask = (1 << sbi->fs_shift) - 1;\r\nsector = ((sector_t)dblock << sbi->fs_shift) +\r\nsbi->blockoffset + (iblock & mask);\r\nmap_bh(bh_result, sb, sector);\r\nif (create) {\r\nset_buffer_new(bh_result);\r\nhip->phys_size += sb->s_blocksize;\r\nhip->fs_blocks++;\r\ninode_add_bytes(inode, sb->s_blocksize);\r\n}\r\nif (create || was_dirty)\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic void hfsplus_dump_extent(struct hfsplus_extent *extent)\r\n{\r\nint i;\r\nhfs_dbg(EXTENT, " ");\r\nfor (i = 0; i < 8; i++)\r\nhfs_dbg_cont(EXTENT, " %u:%u",\r\nbe32_to_cpu(extent[i].start_block),\r\nbe32_to_cpu(extent[i].block_count));\r\nhfs_dbg_cont(EXTENT, "\n");\r\n}\r\nstatic int hfsplus_add_extent(struct hfsplus_extent *extent, u32 offset,\r\nu32 alloc_block, u32 block_count)\r\n{\r\nu32 count, start;\r\nint i;\r\nhfsplus_dump_extent(extent);\r\nfor (i = 0; i < 8; extent++, i++) {\r\ncount = be32_to_cpu(extent->block_count);\r\nif (offset == count) {\r\nstart = be32_to_cpu(extent->start_block);\r\nif (alloc_block != start + count) {\r\nif (++i >= 8)\r\nreturn -ENOSPC;\r\nextent++;\r\nextent->start_block = cpu_to_be32(alloc_block);\r\n} else\r\nblock_count += count;\r\nextent->block_count = cpu_to_be32(block_count);\r\nreturn 0;\r\n} else if (offset < count)\r\nbreak;\r\noffset -= count;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int hfsplus_free_extents(struct super_block *sb,\r\nstruct hfsplus_extent *extent,\r\nu32 offset, u32 block_nr)\r\n{\r\nu32 count, start;\r\nint i;\r\nint err = 0;\r\nhfsplus_dump_extent(extent);\r\nfor (i = 0; i < 8; extent++, i++) {\r\ncount = be32_to_cpu(extent->block_count);\r\nif (offset == count)\r\ngoto found;\r\nelse if (offset < count)\r\nbreak;\r\noffset -= count;\r\n}\r\nreturn -EIO;\r\nfound:\r\nfor (;;) {\r\nstart = be32_to_cpu(extent->start_block);\r\nif (count <= block_nr) {\r\nerr = hfsplus_block_free(sb, start, count);\r\nif (err) {\r\npr_err("can't free extent\n");\r\nhfs_dbg(EXTENT, " start: %u count: %u\n",\r\nstart, count);\r\n}\r\nextent->block_count = 0;\r\nextent->start_block = 0;\r\nblock_nr -= count;\r\n} else {\r\ncount -= block_nr;\r\nerr = hfsplus_block_free(sb, start + count, block_nr);\r\nif (err) {\r\npr_err("can't free extent\n");\r\nhfs_dbg(EXTENT, " start: %u count: %u\n",\r\nstart, count);\r\n}\r\nextent->block_count = cpu_to_be32(count);\r\nblock_nr = 0;\r\n}\r\nif (!block_nr || !i) {\r\nreturn err;\r\n}\r\ni--;\r\nextent--;\r\ncount = be32_to_cpu(extent->block_count);\r\n}\r\n}\r\nint hfsplus_free_fork(struct super_block *sb, u32 cnid,\r\nstruct hfsplus_fork_raw *fork, int type)\r\n{\r\nstruct hfs_find_data fd;\r\nhfsplus_extent_rec ext_entry;\r\nu32 total_blocks, blocks, start;\r\nint res, i;\r\ntotal_blocks = be32_to_cpu(fork->total_blocks);\r\nif (!total_blocks)\r\nreturn 0;\r\nblocks = 0;\r\nfor (i = 0; i < 8; i++)\r\nblocks += be32_to_cpu(fork->extents[i].block_count);\r\nres = hfsplus_free_extents(sb, fork->extents, blocks, blocks);\r\nif (res)\r\nreturn res;\r\nif (total_blocks == blocks)\r\nreturn 0;\r\nres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\r\nif (res)\r\nreturn res;\r\ndo {\r\nres = __hfsplus_ext_read_extent(&fd, ext_entry, cnid,\r\ntotal_blocks, type);\r\nif (res)\r\nbreak;\r\nstart = be32_to_cpu(fd.key->ext.start_block);\r\nhfsplus_free_extents(sb, ext_entry,\r\ntotal_blocks - start,\r\ntotal_blocks);\r\nhfs_brec_remove(&fd);\r\ntotal_blocks = start;\r\n} while (total_blocks > blocks);\r\nhfs_find_exit(&fd);\r\nreturn res;\r\n}\r\nint hfsplus_file_extend(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfsplus_sb_info *sbi = HFSPLUS_SB(sb);\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nu32 start, len, goal;\r\nint res;\r\nif (sbi->alloc_file->i_size * 8 <\r\nsbi->total_blocks - sbi->free_blocks + 8) {\r\npr_err("extend alloc file! "\r\n"(%llu,%u,%u)\n",\r\nsbi->alloc_file->i_size * 8,\r\nsbi->total_blocks, sbi->free_blocks);\r\nreturn -ENOSPC;\r\n}\r\nmutex_lock(&hip->extents_lock);\r\nif (hip->alloc_blocks == hip->first_blocks)\r\ngoal = hfsplus_ext_lastblock(hip->first_extents);\r\nelse {\r\nres = hfsplus_ext_read_extent(inode, hip->alloc_blocks);\r\nif (res)\r\ngoto out;\r\ngoal = hfsplus_ext_lastblock(hip->cached_extents);\r\n}\r\nlen = hip->clump_blocks;\r\nstart = hfsplus_block_allocate(sb, sbi->total_blocks, goal, &len);\r\nif (start >= sbi->total_blocks) {\r\nstart = hfsplus_block_allocate(sb, goal, 0, &len);\r\nif (start >= goal) {\r\nres = -ENOSPC;\r\ngoto out;\r\n}\r\n}\r\nhfs_dbg(EXTENT, "extend %lu: %u,%u\n", inode->i_ino, start, len);\r\nif (hip->alloc_blocks <= hip->first_blocks) {\r\nif (!hip->first_blocks) {\r\nhfs_dbg(EXTENT, "first extents\n");\r\nhip->first_extents[0].start_block = cpu_to_be32(start);\r\nhip->first_extents[0].block_count = cpu_to_be32(len);\r\nres = 0;\r\n} else {\r\nres = hfsplus_add_extent(hip->first_extents,\r\nhip->alloc_blocks,\r\nstart, len);\r\nif (res == -ENOSPC)\r\ngoto insert_extent;\r\n}\r\nif (!res) {\r\nhfsplus_dump_extent(hip->first_extents);\r\nhip->first_blocks += len;\r\n}\r\n} else {\r\nres = hfsplus_add_extent(hip->cached_extents,\r\nhip->alloc_blocks - hip->cached_start,\r\nstart, len);\r\nif (!res) {\r\nhfsplus_dump_extent(hip->cached_extents);\r\nhip->extent_state |= HFSPLUS_EXT_DIRTY;\r\nhip->cached_blocks += len;\r\n} else if (res == -ENOSPC)\r\ngoto insert_extent;\r\n}\r\nout:\r\nmutex_unlock(&hip->extents_lock);\r\nif (!res) {\r\nhip->alloc_blocks += len;\r\nhfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\r\n}\r\nreturn res;\r\ninsert_extent:\r\nhfs_dbg(EXTENT, "insert new extent\n");\r\nres = hfsplus_ext_write_extent_locked(inode);\r\nif (res)\r\ngoto out;\r\nmemset(hip->cached_extents, 0, sizeof(hfsplus_extent_rec));\r\nhip->cached_extents[0].start_block = cpu_to_be32(start);\r\nhip->cached_extents[0].block_count = cpu_to_be32(len);\r\nhfsplus_dump_extent(hip->cached_extents);\r\nhip->extent_state |= HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW;\r\nhip->cached_start = hip->alloc_blocks;\r\nhip->cached_blocks = len;\r\nres = 0;\r\ngoto out;\r\n}\r\nvoid hfsplus_file_truncate(struct inode *inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nstruct hfsplus_inode_info *hip = HFSPLUS_I(inode);\r\nstruct hfs_find_data fd;\r\nu32 alloc_cnt, blk_cnt, start;\r\nint res;\r\nhfs_dbg(INODE, "truncate: %lu, %llu -> %llu\n",\r\ninode->i_ino, (long long)hip->phys_size, inode->i_size);\r\nif (inode->i_size > hip->phys_size) {\r\nstruct address_space *mapping = inode->i_mapping;\r\nstruct page *page;\r\nvoid *fsdata;\r\nloff_t size = inode->i_size;\r\nres = pagecache_write_begin(NULL, mapping, size, 0,\r\nAOP_FLAG_UNINTERRUPTIBLE,\r\n&page, &fsdata);\r\nif (res)\r\nreturn;\r\nres = pagecache_write_end(NULL, mapping, size,\r\n0, 0, page, fsdata);\r\nif (res < 0)\r\nreturn;\r\nmark_inode_dirty(inode);\r\nreturn;\r\n} else if (inode->i_size == hip->phys_size)\r\nreturn;\r\nblk_cnt = (inode->i_size + HFSPLUS_SB(sb)->alloc_blksz - 1) >>\r\nHFSPLUS_SB(sb)->alloc_blksz_shift;\r\nalloc_cnt = hip->alloc_blocks;\r\nif (blk_cnt == alloc_cnt)\r\ngoto out;\r\nmutex_lock(&hip->extents_lock);\r\nres = hfs_find_init(HFSPLUS_SB(sb)->ext_tree, &fd);\r\nif (res) {\r\nmutex_unlock(&hip->extents_lock);\r\nreturn;\r\n}\r\nwhile (1) {\r\nif (alloc_cnt == hip->first_blocks) {\r\nhfsplus_free_extents(sb, hip->first_extents,\r\nalloc_cnt, alloc_cnt - blk_cnt);\r\nhfsplus_dump_extent(hip->first_extents);\r\nhip->first_blocks = blk_cnt;\r\nbreak;\r\n}\r\nres = __hfsplus_ext_cache_extent(&fd, inode, alloc_cnt);\r\nif (res)\r\nbreak;\r\nstart = hip->cached_start;\r\nhfsplus_free_extents(sb, hip->cached_extents,\r\nalloc_cnt - start, alloc_cnt - blk_cnt);\r\nhfsplus_dump_extent(hip->cached_extents);\r\nif (blk_cnt > start) {\r\nhip->extent_state |= HFSPLUS_EXT_DIRTY;\r\nbreak;\r\n}\r\nalloc_cnt = start;\r\nhip->cached_start = hip->cached_blocks = 0;\r\nhip->extent_state &= ~(HFSPLUS_EXT_DIRTY | HFSPLUS_EXT_NEW);\r\nhfs_brec_remove(&fd);\r\n}\r\nhfs_find_exit(&fd);\r\nmutex_unlock(&hip->extents_lock);\r\nhip->alloc_blocks = blk_cnt;\r\nout:\r\nhip->phys_size = inode->i_size;\r\nhip->fs_blocks = (inode->i_size + sb->s_blocksize - 1) >>\r\nsb->s_blocksize_bits;\r\ninode_set_bytes(inode, hip->fs_blocks << sb->s_blocksize_bits);\r\nhfsplus_mark_inode_dirty(inode, HFSPLUS_I_ALLOC_DIRTY);\r\n}
