static int omap_vc_config_channel(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nif (vc->flags & OMAP_VC_CHANNEL_DEFAULT)\r\nvc->cfg_channel &= vc_cfg_bits->racen;\r\nvoltdm->rmw(CFG_CHANNEL_MASK << vc->cfg_channel_sa_shift,\r\nvc->cfg_channel << vc->cfg_channel_sa_shift,\r\nvc->cfg_channel_reg);\r\nreturn 0;\r\n}\r\nint omap_vc_pre_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt,\r\nu8 *target_vsel, u8 *current_vsel)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nu32 vc_cmdval;\r\nif (!voltdm->pmic) {\r\npr_err("%s: Insufficient pmic info to scale the vdd_%s\n",\r\n__func__, voltdm->name);\r\nreturn -EINVAL;\r\n}\r\nif (!voltdm->pmic->uv_to_vsel) {\r\npr_err("%s: PMIC function to convert voltage in uV to vsel not registered. Hence unable to scale voltage for vdd_%s\n",\r\n__func__, voltdm->name);\r\nreturn -ENODATA;\r\n}\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn -EINVAL;\r\n}\r\n*target_vsel = voltdm->pmic->uv_to_vsel(target_volt);\r\n*current_vsel = voltdm->pmic->uv_to_vsel(voltdm->nominal_volt);\r\nvc_cmdval = voltdm->read(vc->cmdval_reg);\r\nvc_cmdval &= ~vc->common->cmd_on_mask;\r\nvc_cmdval |= (*target_vsel << vc->common->cmd_on_shift);\r\nvoltdm->write(vc_cmdval, vc->cmdval_reg);\r\nvoltdm->vc_param->on = target_volt;\r\nomap_vp_update_errorgain(voltdm, target_volt);\r\nreturn 0;\r\n}\r\nvoid omap_vc_post_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt,\r\nu8 target_vsel, u8 current_vsel)\r\n{\r\nu32 smps_steps = 0, smps_delay = 0;\r\nsmps_steps = abs(target_vsel - current_vsel);\r\nsmps_delay = ((smps_steps * voltdm->pmic->step_size) /\r\nvoltdm->pmic->slew_rate) + 2;\r\nudelay(smps_delay);\r\n}\r\nint omap_vc_bypass_scale(struct voltagedomain *voltdm,\r\nunsigned long target_volt)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nu32 loop_cnt = 0, retries_cnt = 0;\r\nu32 vc_valid, vc_bypass_val_reg, vc_bypass_value;\r\nu8 target_vsel, current_vsel;\r\nint ret;\r\nret = omap_vc_pre_scale(voltdm, target_volt, &target_vsel, &current_vsel);\r\nif (ret)\r\nreturn ret;\r\nvc_valid = vc->common->valid;\r\nvc_bypass_val_reg = vc->common->bypass_val_reg;\r\nvc_bypass_value = (target_vsel << vc->common->data_shift) |\r\n(vc->volt_reg_addr << vc->common->regaddr_shift) |\r\n(vc->i2c_slave_addr << vc->common->slaveaddr_shift);\r\nvoltdm->write(vc_bypass_value, vc_bypass_val_reg);\r\nvoltdm->write(vc_bypass_value | vc_valid, vc_bypass_val_reg);\r\nvc_bypass_value = voltdm->read(vc_bypass_val_reg);\r\nwhile (!(vc_bypass_value & vc_valid)) {\r\nloop_cnt++;\r\nif (retries_cnt > 10) {\r\npr_warning("%s: Retry count exceeded\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (loop_cnt > 50) {\r\nretries_cnt++;\r\nloop_cnt = 0;\r\nudelay(10);\r\n}\r\nvc_bypass_value = voltdm->read(vc_bypass_val_reg);\r\n}\r\nomap_vc_post_scale(voltdm, target_volt, target_vsel, current_vsel);\r\nreturn 0;\r\n}\r\nstatic inline u32 omap_usec_to_32k(u32 usec)\r\n{\r\nreturn DIV_ROUND_UP_ULL(32768ULL * (u64)usec, 1000000ULL);\r\n}\r\nstatic void omap3_set_clksetup(u32 usec, struct voltagedomain *voltdm)\r\n{\r\nvoltdm->write(omap_usec_to_32k(usec), OMAP3_PRM_CLKSETUP_OFFSET);\r\n}\r\nstatic void omap3_set_i2c_timings(struct voltagedomain *voltdm, bool off_mode)\r\n{\r\nunsigned long voltsetup1;\r\nu32 tgt_volt;\r\nomap3_set_clksetup(1, voltdm);\r\nif (off_mode)\r\ntgt_volt = voltdm->vc_param->off;\r\nelse\r\ntgt_volt = voltdm->vc_param->ret;\r\nvoltsetup1 = (voltdm->vc_param->on - tgt_volt) /\r\nvoltdm->pmic->slew_rate;\r\nvoltsetup1 = voltsetup1 * voltdm->sys_clk.rate / 8 / 1000000 + 1;\r\nvoltdm->rmw(voltdm->vfsm->voltsetup_mask,\r\nvoltsetup1 << __ffs(voltdm->vfsm->voltsetup_mask),\r\nvoltdm->vfsm->voltsetup_reg);\r\nvoltdm->write(0, OMAP3_PRM_VOLTSETUP2_OFFSET);\r\n}\r\nstatic void omap3_set_off_timings(struct voltagedomain *voltdm)\r\n{\r\nunsigned long clksetup;\r\nunsigned long voltsetup2;\r\nunsigned long voltsetup2_old;\r\nu32 val;\r\nu32 tstart, tshut;\r\nval = voltdm->read(OMAP3_PRM_VOLTCTRL_OFFSET);\r\nif (!(val & OMAP3430_SEL_OFF_MASK)) {\r\nomap3_set_i2c_timings(voltdm, true);\r\nreturn;\r\n}\r\nomap_pm_get_oscillator(&tstart, &tshut);\r\nomap3_set_clksetup(tstart, voltdm);\r\nclksetup = voltdm->read(OMAP3_PRM_CLKSETUP_OFFSET);\r\nvoltsetup2 = voltdm->vc_param->on / voltdm->pmic->slew_rate;\r\nvoltsetup2 = DIV_ROUND_UP(voltsetup2 * 32768, 1000000);\r\nvoltsetup2_old = voltdm->read(OMAP3_PRM_VOLTSETUP2_OFFSET);\r\nif (voltsetup2 > voltsetup2_old) {\r\nvoltdm->write(voltsetup2, OMAP3_PRM_VOLTSETUP2_OFFSET);\r\nvoltdm->write(clksetup - voltsetup2,\r\nOMAP3_PRM_VOLTOFFSET_OFFSET);\r\n} else\r\nvoltdm->write(clksetup - voltsetup2_old,\r\nOMAP3_PRM_VOLTOFFSET_OFFSET);\r\nvoltdm->rmw(voltdm->vfsm->voltsetup_mask, 0,\r\nvoltdm->vfsm->voltsetup_reg);\r\nvoltdm->write(clksetup - voltsetup2, OMAP3_PRM_VOLTOFFSET_OFFSET);\r\n}\r\nstatic void __init omap3_vc_init_channel(struct voltagedomain *voltdm)\r\n{\r\nomap3_set_off_timings(voltdm);\r\n}\r\nstatic u32 omap4_calc_volt_ramp(struct voltagedomain *voltdm, u32 voltage_diff)\r\n{\r\nu32 prescaler;\r\nu32 cycles;\r\nu32 time;\r\ntime = voltage_diff / voltdm->pmic->slew_rate;\r\ncycles = voltdm->sys_clk.rate / 1000 * time / 1000;\r\ncycles /= 64;\r\nprescaler = 0;\r\nif (cycles > 63) {\r\ncycles /= 4;\r\nprescaler++;\r\n}\r\nif (cycles > 63) {\r\ncycles /= 2;\r\nprescaler++;\r\n}\r\nif (cycles > 63) {\r\ncycles /= 4;\r\nprescaler++;\r\n}\r\nif (cycles > 63) {\r\npr_warn("%s: invalid setuptime for vdd_%s\n", __func__,\r\nvoltdm->name);\r\nreturn 0;\r\n}\r\ncycles++;\r\nreturn (prescaler << OMAP4430_RAMP_UP_PRESCAL_SHIFT) |\r\n(cycles << OMAP4430_RAMP_UP_COUNT_SHIFT);\r\n}\r\nstatic u32 omap4_usec_to_val_scrm(u32 usec, int shift, u32 mask)\r\n{\r\nu32 val;\r\nval = omap_usec_to_32k(usec) << shift;\r\nif (val > mask)\r\nval = mask;\r\nreturn val;\r\n}\r\nstatic void omap4_set_timings(struct voltagedomain *voltdm, bool off_mode)\r\n{\r\nu32 val;\r\nu32 ramp;\r\nint offset;\r\nu32 tstart, tshut;\r\nif (off_mode) {\r\nramp = omap4_calc_volt_ramp(voltdm,\r\nvoltdm->vc_param->on - voltdm->vc_param->off);\r\noffset = voltdm->vfsm->voltsetup_off_reg;\r\n} else {\r\nramp = omap4_calc_volt_ramp(voltdm,\r\nvoltdm->vc_param->on - voltdm->vc_param->ret);\r\noffset = voltdm->vfsm->voltsetup_reg;\r\n}\r\nif (!ramp)\r\nreturn;\r\nval = voltdm->read(offset);\r\nval |= ramp << OMAP4430_RAMP_DOWN_COUNT_SHIFT;\r\nval |= ramp << OMAP4430_RAMP_UP_COUNT_SHIFT;\r\nvoltdm->write(val, offset);\r\nomap_pm_get_oscillator(&tstart, &tshut);\r\nval = omap4_usec_to_val_scrm(tstart, OMAP4_SETUPTIME_SHIFT,\r\nOMAP4_SETUPTIME_MASK);\r\nval |= omap4_usec_to_val_scrm(tshut, OMAP4_DOWNTIME_SHIFT,\r\nOMAP4_DOWNTIME_MASK);\r\n__raw_writel(val, OMAP4_SCRM_CLKSETUPTIME);\r\n}\r\nstatic void __init omap4_vc_init_channel(struct voltagedomain *voltdm)\r\n{\r\nomap4_set_timings(voltdm, true);\r\nomap4_set_timings(voltdm, false);\r\n}\r\nstatic void __init omap4_vc_i2c_timing_init(struct voltagedomain *voltdm)\r\n{\r\nu32 capacitance;\r\nu32 val;\r\nu16 hsscll;\r\nconst struct i2c_init_data *i2c_data;\r\nif (!voltdm->pmic->i2c_high_speed) {\r\npr_warn("%s: only high speed supported!\n", __func__);\r\nreturn;\r\n}\r\ncapacitance = DIV_ROUND_UP(sr_i2c_pcb_length, 8);\r\ncapacitance += 4;\r\ncapacitance += voltdm->pmic->i2c_pad_load;\r\ni2c_data = omap4_i2c_timing_data;\r\nwhile (i2c_data->load > capacitance)\r\ni2c_data++;\r\nswitch (voltdm->sys_clk.rate) {\r\ncase 38400000:\r\nhsscll = i2c_data->hsscll_38_4;\r\nbreak;\r\ncase 26000000:\r\nhsscll = i2c_data->hsscll_26;\r\nbreak;\r\ncase 19200000:\r\nhsscll = i2c_data->hsscll_19_2;\r\nbreak;\r\ncase 16800000:\r\nhsscll = i2c_data->hsscll_16_8;\r\nbreak;\r\ncase 12000000:\r\nhsscll = i2c_data->hsscll_12;\r\nbreak;\r\ndefault:\r\npr_warn("%s: unsupported sysclk rate: %d!\n", __func__,\r\nvoltdm->sys_clk.rate);\r\nreturn;\r\n}\r\nval = i2c_data->loadbits << 25 | i2c_data->loadbits << 29;\r\n__raw_writel(val, OMAP2_L4_IO_ADDRESS(OMAP4_CTRL_MODULE_PAD_WKUP +\r\nOMAP4_CTRL_MODULE_PAD_WKUP_CONTROL_I2C_2));\r\nval = hsscll << OMAP4430_HSSCLL_SHIFT;\r\nval |= (0x28 << OMAP4430_SCLL_SHIFT | 0x2c << OMAP4430_SCLH_SHIFT);\r\nvoltdm->write(val, OMAP4_PRM_VC_CFG_I2C_CLK_OFFSET);\r\n}\r\nstatic void __init omap_vc_i2c_init(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nstatic bool initialized;\r\nstatic bool i2c_high_speed;\r\nu8 mcode;\r\nif (initialized) {\r\nif (voltdm->pmic->i2c_high_speed != i2c_high_speed)\r\npr_warn("%s: I2C config for vdd_%s does not match other channels (%u).\n",\r\n__func__, voltdm->name, i2c_high_speed);\r\nreturn;\r\n}\r\ni2c_high_speed = voltdm->pmic->i2c_high_speed;\r\nif (i2c_high_speed)\r\nvoltdm->rmw(vc->common->i2c_cfg_hsen_mask,\r\nvc->common->i2c_cfg_hsen_mask,\r\nvc->common->i2c_cfg_reg);\r\nmcode = voltdm->pmic->i2c_mcode;\r\nif (mcode)\r\nvoltdm->rmw(vc->common->i2c_mcode_mask,\r\nmcode << __ffs(vc->common->i2c_mcode_mask),\r\nvc->common->i2c_cfg_reg);\r\nif (cpu_is_omap44xx())\r\nomap4_vc_i2c_timing_init(voltdm);\r\ninitialized = true;\r\n}\r\nstatic u8 omap_vc_calc_vsel(struct voltagedomain *voltdm, u32 uvolt)\r\n{\r\nif (voltdm->pmic->vddmin > uvolt)\r\nuvolt = voltdm->pmic->vddmin;\r\nif (voltdm->pmic->vddmax < uvolt) {\r\nWARN(1, "%s: voltage not supported by pmic: %u vs max %u\n",\r\n__func__, uvolt, voltdm->pmic->vddmax);\r\nuvolt = voltdm->pmic->vddmax;\r\n}\r\nreturn voltdm->pmic->uv_to_vsel(uvolt);\r\n}\r\nvoid __init omap_pm_setup_sr_i2c_pcb_length(u32 mm)\r\n{\r\nsr_i2c_pcb_length = mm;\r\n}\r\nvoid __init omap_vc_init_channel(struct voltagedomain *voltdm)\r\n{\r\nstruct omap_vc_channel *vc = voltdm->vc;\r\nu8 on_vsel, onlp_vsel, ret_vsel, off_vsel;\r\nu32 val;\r\nif (!voltdm->pmic || !voltdm->pmic->uv_to_vsel) {\r\npr_err("%s: No PMIC info for vdd_%s\n", __func__, voltdm->name);\r\nreturn;\r\n}\r\nif (!voltdm->read || !voltdm->write) {\r\npr_err("%s: No read/write API for accessing vdd_%s regs\n",\r\n__func__, voltdm->name);\r\nreturn;\r\n}\r\nvc->cfg_channel = 0;\r\nif (vc->flags & OMAP_VC_CHANNEL_CFG_MUTANT)\r\nvc_cfg_bits = &vc_mutant_channel_cfg;\r\nelse\r\nvc_cfg_bits = &vc_default_channel_cfg;\r\nvc->i2c_slave_addr = voltdm->pmic->i2c_slave_addr;\r\nvc->volt_reg_addr = voltdm->pmic->volt_reg_addr;\r\nvc->cmd_reg_addr = voltdm->pmic->cmd_reg_addr;\r\nvoltdm->rmw(vc->smps_sa_mask,\r\nvc->i2c_slave_addr << __ffs(vc->smps_sa_mask),\r\nvc->smps_sa_reg);\r\nvc->cfg_channel |= vc_cfg_bits->sa;\r\nvoltdm->rmw(vc->smps_volra_mask,\r\nvc->volt_reg_addr << __ffs(vc->smps_volra_mask),\r\nvc->smps_volra_reg);\r\nvc->cfg_channel |= vc_cfg_bits->rav;\r\nif (vc->cmd_reg_addr) {\r\nvoltdm->rmw(vc->smps_cmdra_mask,\r\nvc->cmd_reg_addr << __ffs(vc->smps_cmdra_mask),\r\nvc->smps_cmdra_reg);\r\nvc->cfg_channel |= vc_cfg_bits->rac;\r\n}\r\nif (vc->cmd_reg_addr == vc->volt_reg_addr)\r\nvc->cfg_channel |= vc_cfg_bits->racen;\r\non_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->on);\r\nonlp_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->onlp);\r\nret_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->ret);\r\noff_vsel = omap_vc_calc_vsel(voltdm, voltdm->vc_param->off);\r\nval = ((on_vsel << vc->common->cmd_on_shift) |\r\n(onlp_vsel << vc->common->cmd_onlp_shift) |\r\n(ret_vsel << vc->common->cmd_ret_shift) |\r\n(off_vsel << vc->common->cmd_off_shift));\r\nvoltdm->write(val, vc->cmdval_reg);\r\nvc->cfg_channel |= vc_cfg_bits->cmd;\r\nomap_vc_config_channel(voltdm);\r\nomap_vc_i2c_init(voltdm);\r\nif (cpu_is_omap34xx())\r\nomap3_vc_init_channel(voltdm);\r\nelse if (cpu_is_omap44xx())\r\nomap4_vc_init_channel(voltdm);\r\n}
