static void exynos_drm_crtc_dpms(struct drm_crtc *crtc, int mode)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nDRM_DEBUG_KMS("crtc[%d] mode[%d]\n", crtc->base.id, mode);\r\nif (exynos_crtc->dpms == mode) {\r\nDRM_DEBUG_KMS("desired dpms mode is same as previous one.\n");\r\nreturn;\r\n}\r\nif (mode > DRM_MODE_DPMS_ON) {\r\nwait_event(exynos_crtc->pending_flip_queue,\r\natomic_read(&exynos_crtc->pending_flip) == 0);\r\ndrm_vblank_off(crtc->dev, exynos_crtc->pipe);\r\n}\r\nexynos_drm_fn_encoder(crtc, &mode, exynos_drm_encoder_crtc_dpms);\r\nexynos_crtc->dpms = mode;\r\n}\r\nstatic void exynos_drm_crtc_prepare(struct drm_crtc *crtc)\r\n{\r\n}\r\nstatic void exynos_drm_crtc_commit(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nexynos_drm_crtc_dpms(crtc, DRM_MODE_DPMS_ON);\r\nexynos_plane_commit(exynos_crtc->plane);\r\nexynos_plane_dpms(exynos_crtc->plane, DRM_MODE_DPMS_ON);\r\n}\r\nstatic bool\r\nexynos_drm_crtc_mode_fixup(struct drm_crtc *crtc,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic int\r\nexynos_drm_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct drm_plane *plane = exynos_crtc->plane;\r\nunsigned int crtc_w;\r\nunsigned int crtc_h;\r\nint pipe = exynos_crtc->pipe;\r\nint ret;\r\nmemcpy(&crtc->mode, adjusted_mode, sizeof(*adjusted_mode));\r\ncrtc_w = crtc->fb->width - x;\r\ncrtc_h = crtc->fb->height - y;\r\nret = exynos_plane_mode_set(plane, crtc, crtc->fb, 0, 0, crtc_w, crtc_h,\r\nx, y, crtc_w, crtc_h);\r\nif (ret)\r\nreturn ret;\r\nplane->crtc = crtc;\r\nplane->fb = crtc->fb;\r\nexynos_drm_fn_encoder(crtc, &pipe, exynos_drm_encoder_crtc_pipe);\r\nreturn 0;\r\n}\r\nstatic int exynos_drm_crtc_mode_set_commit(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct drm_plane *plane = exynos_crtc->plane;\r\nunsigned int crtc_w;\r\nunsigned int crtc_h;\r\nint ret;\r\nif (exynos_crtc->dpms > DRM_MODE_DPMS_ON) {\r\nDRM_ERROR("failed framebuffer changing request.\n");\r\nreturn -EPERM;\r\n}\r\ncrtc_w = crtc->fb->width - x;\r\ncrtc_h = crtc->fb->height - y;\r\nret = exynos_plane_mode_set(plane, crtc, crtc->fb, 0, 0, crtc_w, crtc_h,\r\nx, y, crtc_w, crtc_h);\r\nif (ret)\r\nreturn ret;\r\nexynos_drm_crtc_commit(crtc);\r\nreturn 0;\r\n}\r\nstatic int exynos_drm_crtc_mode_set_base(struct drm_crtc *crtc, int x, int y,\r\nstruct drm_framebuffer *old_fb)\r\n{\r\nreturn exynos_drm_crtc_mode_set_commit(crtc, x, y, old_fb);\r\n}\r\nstatic void exynos_drm_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nexynos_plane_dpms(exynos_crtc->plane, DRM_MODE_DPMS_OFF);\r\nexynos_drm_crtc_dpms(crtc, DRM_MODE_DPMS_OFF);\r\n}\r\nstatic int exynos_drm_crtc_page_flip(struct drm_crtc *crtc,\r\nstruct drm_framebuffer *fb,\r\nstruct drm_pending_vblank_event *event,\r\nuint32_t page_flip_flags)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct drm_framebuffer *old_fb = crtc->fb;\r\nint ret = -EINVAL;\r\nif (exynos_crtc->dpms > DRM_MODE_DPMS_ON) {\r\nDRM_ERROR("failed page flip request.\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&dev->struct_mutex);\r\nif (event) {\r\nevent->pipe = exynos_crtc->pipe;\r\nret = drm_vblank_get(dev, exynos_crtc->pipe);\r\nif (ret) {\r\nDRM_DEBUG("failed to acquire vblank counter\n");\r\ngoto out;\r\n}\r\nspin_lock_irq(&dev->event_lock);\r\nlist_add_tail(&event->base.link,\r\n&dev_priv->pageflip_event_list);\r\natomic_set(&exynos_crtc->pending_flip, 1);\r\nspin_unlock_irq(&dev->event_lock);\r\ncrtc->fb = fb;\r\nret = exynos_drm_crtc_mode_set_commit(crtc, crtc->x, crtc->y,\r\nNULL);\r\nif (ret) {\r\ncrtc->fb = old_fb;\r\nspin_lock_irq(&dev->event_lock);\r\ndrm_vblank_put(dev, exynos_crtc->pipe);\r\nlist_del(&event->base.link);\r\nspin_unlock_irq(&dev->event_lock);\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}\r\nstatic void exynos_drm_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nstruct exynos_drm_private *private = crtc->dev->dev_private;\r\nprivate->crtc[exynos_crtc->pipe] = NULL;\r\ndrm_crtc_cleanup(crtc);\r\nkfree(exynos_crtc);\r\n}\r\nstatic int exynos_drm_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(crtc);\r\nif (property == dev_priv->crtc_mode_property) {\r\nenum exynos_crtc_mode mode = val;\r\nif (mode == exynos_crtc->mode)\r\nreturn 0;\r\nexynos_crtc->mode = mode;\r\nswitch (mode) {\r\ncase CRTC_MODE_NORMAL:\r\nexynos_drm_crtc_commit(crtc);\r\nbreak;\r\ncase CRTC_MODE_BLANK:\r\nexynos_plane_dpms(exynos_crtc->plane,\r\nDRM_MODE_DPMS_OFF);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void exynos_drm_crtc_attach_mode_property(struct drm_crtc *crtc)\r\n{\r\nstruct drm_device *dev = crtc->dev;\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct drm_property *prop;\r\nprop = dev_priv->crtc_mode_property;\r\nif (!prop) {\r\nprop = drm_property_create_enum(dev, 0, "mode", mode_names,\r\nARRAY_SIZE(mode_names));\r\nif (!prop)\r\nreturn;\r\ndev_priv->crtc_mode_property = prop;\r\n}\r\ndrm_object_attach_property(&crtc->base, prop, 0);\r\n}\r\nint exynos_drm_crtc_create(struct drm_device *dev, unsigned int nr)\r\n{\r\nstruct exynos_drm_crtc *exynos_crtc;\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct drm_crtc *crtc;\r\nexynos_crtc = kzalloc(sizeof(*exynos_crtc), GFP_KERNEL);\r\nif (!exynos_crtc)\r\nreturn -ENOMEM;\r\nexynos_crtc->pipe = nr;\r\nexynos_crtc->dpms = DRM_MODE_DPMS_OFF;\r\ninit_waitqueue_head(&exynos_crtc->pending_flip_queue);\r\natomic_set(&exynos_crtc->pending_flip, 0);\r\nexynos_crtc->plane = exynos_plane_init(dev, 1 << nr, true);\r\nif (!exynos_crtc->plane) {\r\nkfree(exynos_crtc);\r\nreturn -ENOMEM;\r\n}\r\ncrtc = &exynos_crtc->drm_crtc;\r\nprivate->crtc[nr] = crtc;\r\ndrm_crtc_init(dev, crtc, &exynos_crtc_funcs);\r\ndrm_crtc_helper_add(crtc, &exynos_crtc_helper_funcs);\r\nexynos_drm_crtc_attach_mode_property(crtc);\r\nreturn 0;\r\n}\r\nint exynos_drm_crtc_enable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc =\r\nto_exynos_crtc(private->crtc[crtc]);\r\nif (exynos_crtc->dpms != DRM_MODE_DPMS_ON)\r\nreturn -EPERM;\r\nexynos_drm_fn_encoder(private->crtc[crtc], &crtc,\r\nexynos_drm_enable_vblank);\r\nreturn 0;\r\n}\r\nvoid exynos_drm_crtc_disable_vblank(struct drm_device *dev, int crtc)\r\n{\r\nstruct exynos_drm_private *private = dev->dev_private;\r\nstruct exynos_drm_crtc *exynos_crtc =\r\nto_exynos_crtc(private->crtc[crtc]);\r\nif (exynos_crtc->dpms != DRM_MODE_DPMS_ON)\r\nreturn;\r\nexynos_drm_fn_encoder(private->crtc[crtc], &crtc,\r\nexynos_drm_disable_vblank);\r\n}\r\nvoid exynos_drm_crtc_finish_pageflip(struct drm_device *dev, int crtc)\r\n{\r\nstruct exynos_drm_private *dev_priv = dev->dev_private;\r\nstruct drm_pending_vblank_event *e, *t;\r\nstruct drm_crtc *drm_crtc = dev_priv->crtc[crtc];\r\nstruct exynos_drm_crtc *exynos_crtc = to_exynos_crtc(drm_crtc);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nlist_for_each_entry_safe(e, t, &dev_priv->pageflip_event_list,\r\nbase.link) {\r\nif (crtc != e->pipe)\r\ncontinue;\r\nlist_del(&e->base.link);\r\ndrm_send_vblank_event(dev, -1, e);\r\ndrm_vblank_put(dev, crtc);\r\natomic_set(&exynos_crtc->pending_flip, 0);\r\nwake_up(&exynos_crtc->pending_flip_queue);\r\n}\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}
