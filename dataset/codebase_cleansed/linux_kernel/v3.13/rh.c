static int wusbhc_rh_port_reset(struct wusbhc *wusbhc, u8 port_idx)\r\n{\r\nint result = 0;\r\nstruct wusb_port *port = wusb_port_by_idx(wusbhc, port_idx);\r\nstruct wusb_dev *wusb_dev = port->wusb_dev;\r\nif (wusb_dev == NULL)\r\nreturn -ENOTCONN;\r\nport->status |= USB_PORT_STAT_RESET;\r\nport->change |= USB_PORT_STAT_C_RESET;\r\nif (wusb_dev->addr & WUSB_DEV_ADDR_UNAUTH)\r\nresult = 0;\r\nelse\r\nresult = wusb_dev_update_address(wusbhc, wusb_dev);\r\nport->status &= ~USB_PORT_STAT_RESET;\r\nport->status |= USB_PORT_STAT_ENABLE;\r\nport->change |= USB_PORT_STAT_C_RESET | USB_PORT_STAT_C_ENABLE;\r\nreturn result;\r\n}\r\nint wusbhc_rh_status_data(struct usb_hcd *usb_hcd, char *_buf)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nsize_t cnt, size, bits_set = 0;\r\nsize = DIV_ROUND_UP(wusbhc->ports_max + 1, 8);\r\nmemset(_buf, 0, size);\r\nfor (cnt = 0; cnt < wusbhc->ports_max; cnt++) {\r\nif (wusb_port_by_idx(wusbhc, cnt)->change) {\r\nconst int bitpos = cnt+1;\r\n_buf[bitpos/8] |= (1 << (bitpos % 8));\r\nbits_set++;\r\n}\r\n}\r\nreturn bits_set ? size : 0;\r\n}\r\nstatic int wusbhc_rh_get_hub_descr(struct wusbhc *wusbhc, u16 wValue,\r\nu16 wIndex,\r\nstruct usb_hub_descriptor *descr,\r\nu16 wLength)\r\n{\r\nu16 temp = 1 + (wusbhc->ports_max / 8);\r\nu8 length = 7 + 2 * temp;\r\nif (wLength < length)\r\nreturn -ENOSPC;\r\ndescr->bDescLength = 7 + 2 * temp;\r\ndescr->bDescriptorType = 0x29;\r\ndescr->bNbrPorts = wusbhc->ports_max;\r\ndescr->wHubCharacteristics = cpu_to_le16(\r\n0x00\r\n| 0x00\r\n| 0x10\r\n| 0x00\r\n| 0x00);\r\ndescr->bPwrOn2PwrGood = 0;\r\ndescr->bHubContrCurrent = 0;\r\nmemset(&descr->u.hs.DeviceRemovable[0], 0, temp);\r\nmemset(&descr->u.hs.DeviceRemovable[temp], 0xff, temp);\r\nreturn 0;\r\n}\r\nstatic int wusbhc_rh_clear_hub_feat(struct wusbhc *wusbhc, u16 feature)\r\n{\r\nint result;\r\nswitch (feature) {\r\ncase C_HUB_LOCAL_POWER:\r\ncase C_HUB_OVER_CURRENT:\r\nresult = 0;\r\nbreak;\r\ndefault:\r\nresult = -EPIPE;\r\n}\r\nreturn result;\r\n}\r\nstatic int wusbhc_rh_get_hub_status(struct wusbhc *wusbhc, u32 *buf,\r\nu16 wLength)\r\n{\r\n*buf = 0;\r\nreturn 0;\r\n}\r\nstatic int wusbhc_rh_set_port_feat(struct wusbhc *wusbhc, u16 feature,\r\nu8 selector, u8 port_idx)\r\n{\r\nstruct device *dev = wusbhc->dev;\r\nif (port_idx > wusbhc->ports_max)\r\nreturn -EINVAL;\r\nswitch (feature) {\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_RESET:\r\nreturn 0;\r\ncase USB_PORT_FEAT_POWER:\r\nmutex_lock(&wusbhc->mutex);\r\nwusb_port_by_idx(wusbhc, port_idx)->status |= USB_PORT_STAT_POWER;\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn 0;\r\ncase USB_PORT_FEAT_RESET:\r\nreturn wusbhc_rh_port_reset(wusbhc, port_idx);\r\ncase USB_PORT_FEAT_ENABLE:\r\ncase USB_PORT_FEAT_SUSPEND:\r\ndev_err(dev, "(port_idx %d) set feat %d/%d UNIMPLEMENTED\n",\r\nport_idx, feature, selector);\r\nreturn -ENOSYS;\r\ndefault:\r\ndev_err(dev, "(port_idx %d) set feat %d/%d UNKNOWN\n",\r\nport_idx, feature, selector);\r\nreturn -EPIPE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wusbhc_rh_clear_port_feat(struct wusbhc *wusbhc, u16 feature,\r\nu8 selector, u8 port_idx)\r\n{\r\nint result = 0;\r\nstruct device *dev = wusbhc->dev;\r\nif (port_idx > wusbhc->ports_max)\r\nreturn -EINVAL;\r\nmutex_lock(&wusbhc->mutex);\r\nswitch (feature) {\r\ncase USB_PORT_FEAT_POWER:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\nbreak;\r\ncase USB_PORT_FEAT_C_RESET:\r\nwusb_port_by_idx(wusbhc, port_idx)->change &= ~USB_PORT_STAT_C_RESET;\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\nwusb_port_by_idx(wusbhc, port_idx)->change &= ~USB_PORT_STAT_C_CONNECTION;\r\nbreak;\r\ncase USB_PORT_FEAT_ENABLE:\r\n__wusbhc_dev_disable(wusbhc, port_idx);\r\nbreak;\r\ncase USB_PORT_FEAT_C_ENABLE:\r\nwusb_port_by_idx(wusbhc, port_idx)->change &= ~USB_PORT_STAT_C_ENABLE;\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\ndev_err(dev, "(port_idx %d) Clear feat %d/%d UNIMPLEMENTED\n",\r\nport_idx, feature, selector);\r\nresult = -ENOSYS;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "(port_idx %d) Clear feat %d/%d UNKNOWN\n",\r\nport_idx, feature, selector);\r\nresult = -EPIPE;\r\nbreak;\r\n}\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn result;\r\n}\r\nstatic int wusbhc_rh_get_port_status(struct wusbhc *wusbhc, u16 port_idx,\r\nu32 *_buf, u16 wLength)\r\n{\r\n__le16 *buf = (__le16 *)_buf;\r\nif (port_idx > wusbhc->ports_max)\r\nreturn -EINVAL;\r\nmutex_lock(&wusbhc->mutex);\r\nbuf[0] = cpu_to_le16(wusb_port_by_idx(wusbhc, port_idx)->status);\r\nbuf[1] = cpu_to_le16(wusb_port_by_idx(wusbhc, port_idx)->change);\r\nmutex_unlock(&wusbhc->mutex);\r\nreturn 0;\r\n}\r\nint wusbhc_rh_control(struct usb_hcd *usb_hcd, u16 reqntype, u16 wValue,\r\nu16 wIndex, char *buf, u16 wLength)\r\n{\r\nint result = -ENOSYS;\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\nswitch (reqntype) {\r\ncase GetHubDescriptor:\r\nresult = wusbhc_rh_get_hub_descr(\r\nwusbhc, wValue, wIndex,\r\n(struct usb_hub_descriptor *) buf, wLength);\r\nbreak;\r\ncase ClearHubFeature:\r\nresult = wusbhc_rh_clear_hub_feat(wusbhc, wValue);\r\nbreak;\r\ncase GetHubStatus:\r\nresult = wusbhc_rh_get_hub_status(wusbhc, (u32 *)buf, wLength);\r\nbreak;\r\ncase SetPortFeature:\r\nresult = wusbhc_rh_set_port_feat(wusbhc, wValue, wIndex >> 8,\r\n(wIndex & 0xff) - 1);\r\nbreak;\r\ncase ClearPortFeature:\r\nresult = wusbhc_rh_clear_port_feat(wusbhc, wValue, wIndex >> 8,\r\n(wIndex & 0xff) - 1);\r\nbreak;\r\ncase GetPortStatus:\r\nresult = wusbhc_rh_get_port_status(wusbhc, wIndex - 1,\r\n(u32 *)buf, wLength);\r\nbreak;\r\ncase SetHubFeature:\r\ndefault:\r\ndev_err(wusbhc->dev, "%s (%p [%p], %x, %x, %x, %p, %x) "\r\n"UNIMPLEMENTED\n", __func__, usb_hcd, wusbhc, reqntype,\r\nwValue, wIndex, buf, wLength);\r\nresult = -ENOSYS;\r\n}\r\nreturn result;\r\n}\r\nint wusbhc_rh_start_port_reset(struct usb_hcd *usb_hcd, unsigned port_idx)\r\n{\r\nstruct wusbhc *wusbhc = usb_hcd_to_wusbhc(usb_hcd);\r\ndev_err(wusbhc->dev, "%s (%p [%p], port_idx %u) UNIMPLEMENTED\n",\r\n__func__, usb_hcd, wusbhc, port_idx);\r\nWARN_ON(1);\r\nreturn -ENOSYS;\r\n}\r\nstatic void wusb_port_init(struct wusb_port *port)\r\n{\r\nport->status |= USB_PORT_STAT_HIGH_SPEED;\r\n}\r\nint wusbhc_rh_create(struct wusbhc *wusbhc)\r\n{\r\nint result = -ENOMEM;\r\nsize_t port_size, itr;\r\nport_size = wusbhc->ports_max * sizeof(wusbhc->port[0]);\r\nwusbhc->port = kzalloc(port_size, GFP_KERNEL);\r\nif (wusbhc->port == NULL)\r\ngoto error_port_alloc;\r\nfor (itr = 0; itr < wusbhc->ports_max; itr++)\r\nwusb_port_init(&wusbhc->port[itr]);\r\nresult = 0;\r\nerror_port_alloc:\r\nreturn result;\r\n}\r\nvoid wusbhc_rh_destroy(struct wusbhc *wusbhc)\r\n{\r\nkfree(wusbhc->port);\r\n}
