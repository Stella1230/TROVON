static void __iomem *byt_gpio_reg(struct gpio_chip *chip, unsigned offset,\r\nint reg)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nu32 reg_offset;\r\nif (reg == BYT_INT_STAT_REG)\r\nreg_offset = (offset / 32) * 4;\r\nelse\r\nreg_offset = vg->range->pins[offset] * 16;\r\nreturn vg->reg_base + reg_offset + reg;\r\n}\r\nstatic int byt_gpio_request(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\npm_runtime_get(&vg->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_free(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nvoid __iomem *reg = byt_gpio_reg(&vg->chip, offset, BYT_CONF0_REG);\r\nu32 value;\r\nvalue = readl(reg);\r\nvalue &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);\r\nwritel(value, reg);\r\npm_runtime_put(&vg->pdev->dev);\r\n}\r\nstatic int byt_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct byt_gpio *vg = irq_data_get_irq_chip_data(d);\r\nu32 offset = irqd_to_hwirq(d);\r\nu32 value;\r\nunsigned long flags;\r\nvoid __iomem *reg = byt_gpio_reg(&vg->chip, offset, BYT_CONF0_REG);\r\nif (offset >= vg->chip.ngpio)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg);\r\nvalue &= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nvalue |= BYT_TRIG_LVL;\r\ncase IRQ_TYPE_EDGE_RISING:\r\nvalue |= BYT_TRIG_POS;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nvalue |= BYT_TRIG_LVL;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nvalue |= BYT_TRIG_NEG;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nvalue |= (BYT_TRIG_NEG | BYT_TRIG_POS);\r\nbreak;\r\n}\r\nwritel(value, reg);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);\r\nreturn readl(reg) & BYT_LEVEL;\r\n}\r\nstatic void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 old_val;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nold_val = readl(reg);\r\nif (value)\r\nwritel(old_val | BYT_LEVEL, reg);\r\nelse\r\nwritel(old_val & ~BYT_LEVEL, reg);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nvoid __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 value;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nvalue = readl(reg) | BYT_DIR_MASK;\r\nvalue &= ~BYT_INPUT_EN;\r\nwritel(value, reg);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned gpio, int value)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nvoid __iomem *reg = byt_gpio_reg(chip, gpio, BYT_VAL_REG);\r\nunsigned long flags;\r\nu32 reg_val;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nreg_val = readl(reg) | BYT_DIR_MASK;\r\nreg_val &= ~BYT_OUTPUT_EN;\r\nif (value)\r\nwritel(reg_val | BYT_LEVEL, reg);\r\nelse\r\nwritel(reg_val & ~BYT_LEVEL, reg);\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nint i;\r\nunsigned long flags;\r\nu32 conf0, val, offs;\r\nspin_lock_irqsave(&vg->lock, flags);\r\nfor (i = 0; i < vg->chip.ngpio; i++) {\r\noffs = vg->range->pins[i] * 16;\r\nconf0 = readl(vg->reg_base + offs + BYT_CONF0_REG);\r\nval = readl(vg->reg_base + offs + BYT_VAL_REG);\r\nseq_printf(s,\r\n" gpio-%-3d %s %s %s pad-%-3d offset:0x%03x mux:%d %s%s%s\n",\r\ni,\r\nval & BYT_INPUT_EN ? " " : "in",\r\nval & BYT_OUTPUT_EN ? " " : "out",\r\nval & BYT_LEVEL ? "hi" : "lo",\r\nvg->range->pins[i], offs,\r\nconf0 & 0x7,\r\nconf0 & BYT_TRIG_NEG ? " fall" : "",\r\nconf0 & BYT_TRIG_POS ? " rise" : "",\r\nconf0 & BYT_TRIG_LVL ? " level" : "");\r\n}\r\nspin_unlock_irqrestore(&vg->lock, flags);\r\n}\r\nstatic int byt_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct byt_gpio *vg = to_byt_gpio(chip);\r\nreturn irq_create_mapping(vg->domain, offset);\r\n}\r\nstatic void byt_gpio_irq_handler(unsigned irq, struct irq_desc *desc)\r\n{\r\nstruct irq_data *data = irq_desc_get_irq_data(desc);\r\nstruct byt_gpio *vg = irq_data_get_irq_handler_data(data);\r\nstruct irq_chip *chip = irq_data_get_irq_chip(data);\r\nu32 base, pin, mask;\r\nvoid __iomem *reg;\r\nu32 pending;\r\nunsigned virq;\r\nint looplimit = 0;\r\nfor (base = 0; base < vg->chip.ngpio; base += 32) {\r\nreg = byt_gpio_reg(&vg->chip, base, BYT_INT_STAT_REG);\r\nwhile ((pending = readl(reg))) {\r\npin = __ffs(pending);\r\nmask = BIT(pin);\r\nwritel(mask, reg);\r\nvirq = irq_find_mapping(vg->domain, base + pin);\r\ngeneric_handle_irq(virq);\r\nif (looplimit++ > 32) {\r\ndev_err(&vg->pdev->dev,\r\n"Gpio %d interrupt flood, disabling\n",\r\nbase + pin);\r\nreg = byt_gpio_reg(&vg->chip, base + pin,\r\nBYT_CONF0_REG);\r\nmask = readl(reg);\r\nmask &= ~(BYT_TRIG_NEG | BYT_TRIG_POS |\r\nBYT_TRIG_LVL);\r\nwritel(mask, reg);\r\nmask = readl(reg);\r\nbreak;\r\n}\r\n}\r\n}\r\nchip->irq_eoi(data);\r\n}\r\nstatic void byt_irq_unmask(struct irq_data *d)\r\n{\r\n}\r\nstatic void byt_irq_mask(struct irq_data *d)\r\n{\r\n}\r\nstatic void byt_gpio_irq_init_hw(struct byt_gpio *vg)\r\n{\r\nvoid __iomem *reg;\r\nu32 base, value;\r\nfor (base = 0; base < vg->chip.ngpio; base += 32) {\r\nreg = byt_gpio_reg(&vg->chip, base, BYT_INT_STAT_REG);\r\nwritel(0xffffffff, reg);\r\nvalue = readl(reg);\r\nif (value)\r\ndev_err(&vg->pdev->dev,\r\n"GPIO interrupt error, pins misconfigured\n");\r\n}\r\n}\r\nstatic int byt_gpio_irq_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct byt_gpio *vg = d->host_data;\r\nirq_set_chip_and_handler_name(virq, &byt_irqchip, handle_simple_irq,\r\n"demux");\r\nirq_set_chip_data(virq, vg);\r\nirq_set_irq_type(virq, IRQ_TYPE_NONE);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct byt_gpio *vg;\r\nstruct gpio_chip *gc;\r\nstruct resource *mem_rc, *irq_rc;\r\nstruct device *dev = &pdev->dev;\r\nstruct acpi_device *acpi_dev;\r\nstruct pinctrl_gpio_range *range;\r\nacpi_handle handle = ACPI_HANDLE(dev);\r\nunsigned hwirq;\r\nint ret;\r\nif (acpi_bus_get_device(handle, &acpi_dev))\r\nreturn -ENODEV;\r\nvg = devm_kzalloc(dev, sizeof(struct byt_gpio), GFP_KERNEL);\r\nif (!vg) {\r\ndev_err(&pdev->dev, "can't allocate byt_gpio chip data\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (range = byt_ranges; range->name; range++) {\r\nif (!strcmp(acpi_dev->pnp.unique_id, range->name)) {\r\nvg->chip.ngpio = range->npins;\r\nvg->range = range;\r\nbreak;\r\n}\r\n}\r\nif (!vg->chip.ngpio || !vg->range)\r\nreturn -ENODEV;\r\nvg->pdev = pdev;\r\nplatform_set_drvdata(pdev, vg);\r\nmem_rc = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvg->reg_base = devm_ioremap_resource(dev, mem_rc);\r\nif (IS_ERR(vg->reg_base))\r\nreturn PTR_ERR(vg->reg_base);\r\nspin_lock_init(&vg->lock);\r\ngc = &vg->chip;\r\ngc->label = dev_name(&pdev->dev);\r\ngc->owner = THIS_MODULE;\r\ngc->request = byt_gpio_request;\r\ngc->free = byt_gpio_free;\r\ngc->direction_input = byt_gpio_direction_input;\r\ngc->direction_output = byt_gpio_direction_output;\r\ngc->get = byt_gpio_get;\r\ngc->set = byt_gpio_set;\r\ngc->dbg_show = byt_gpio_dbg_show;\r\ngc->base = -1;\r\ngc->can_sleep = 0;\r\ngc->dev = dev;\r\nret = gpiochip_add(gc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed adding byt-gpio chip\n");\r\nreturn ret;\r\n}\r\nirq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (irq_rc && irq_rc->start) {\r\nhwirq = irq_rc->start;\r\ngc->to_irq = byt_gpio_to_irq;\r\nvg->domain = irq_domain_add_linear(NULL, gc->ngpio,\r\n&byt_gpio_irq_ops, vg);\r\nif (!vg->domain)\r\nreturn -ENXIO;\r\nbyt_gpio_irq_init_hw(vg);\r\nirq_set_handler_data(hwirq, vg);\r\nirq_set_chained_handler(hwirq, byt_gpio_irq_handler);\r\nacpi_gpiochip_request_interrupts(gc);\r\n}\r\npm_runtime_enable(dev);\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_runtime_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_runtime_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int byt_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct byt_gpio *vg = platform_get_drvdata(pdev);\r\nint err;\r\npm_runtime_disable(&pdev->dev);\r\nerr = gpiochip_remove(&vg->chip);\r\nif (err)\r\ndev_warn(&pdev->dev, "failed to remove gpio_chip.\n");\r\nreturn 0;\r\n}\r\nstatic int __init byt_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&byt_gpio_driver);\r\n}
