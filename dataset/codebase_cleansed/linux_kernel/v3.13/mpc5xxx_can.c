static u32 mpc52xx_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nunsigned int pvr;\r\nstruct mpc52xx_cdm __iomem *cdm;\r\nstruct device_node *np_cdm;\r\nunsigned int freq;\r\nu32 val;\r\npvr = mfspr(SPRN_PVR);\r\nif (clock_name && strcmp(clock_name, "ip") == 0)\r\n*mscan_clksrc = MSCAN_CLKSRC_BUS;\r\nelse\r\n*mscan_clksrc = MSCAN_CLKSRC_XTAL;\r\nfreq = mpc5xxx_get_bus_frequency(ofdev->dev.of_node);\r\nif (!freq)\r\nreturn 0;\r\nif (*mscan_clksrc == MSCAN_CLKSRC_BUS || pvr == 0x80822011)\r\nreturn freq;\r\nnp_cdm = of_find_matching_node(NULL, mpc52xx_cdm_ids);\r\nif (!np_cdm) {\r\ndev_err(&ofdev->dev, "can't get clock node!\n");\r\nreturn 0;\r\n}\r\ncdm = of_iomap(np_cdm, 0);\r\nif (in_8(&cdm->ipb_clk_sel) & 0x1)\r\nfreq *= 2;\r\nval = in_be32(&cdm->rstcfg);\r\nfreq *= (val & (1 << 5)) ? 8 : 4;\r\nfreq /= (val & (1 << 6)) ? 12 : 16;\r\nof_node_put(np_cdm);\r\niounmap(cdm);\r\nreturn freq;\r\n}\r\nstatic u32 mpc52xx_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nreturn 0;\r\n}\r\nstatic u32 mpc512x_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nstruct mpc512x_clockctl __iomem *clockctl;\r\nstruct device_node *np_clock;\r\nstruct clk *sys_clk, *ref_clk;\r\nint plen, clockidx, clocksrc = -1;\r\nu32 sys_freq, val, clockdiv = 1, freq = 0;\r\nconst u32 *pval;\r\nnp_clock = of_find_matching_node(NULL, mpc512x_clock_ids);\r\nif (!np_clock) {\r\ndev_err(&ofdev->dev, "couldn't find clock node\n");\r\nreturn 0;\r\n}\r\nclockctl = of_iomap(np_clock, 0);\r\nif (!clockctl) {\r\ndev_err(&ofdev->dev, "couldn't map clock registers\n");\r\ngoto exit_put;\r\n}\r\npval = of_get_property(ofdev->dev.of_node, "reg", &plen);\r\nBUG_ON(!pval || plen < sizeof(*pval));\r\nclockidx = (*pval & 0x80) ? 1 : 0;\r\nif (*pval & 0x2000)\r\nclockidx += 2;\r\nif (clock_name && !strcmp(clock_name, "ip")) {\r\n*mscan_clksrc = MSCAN_CLKSRC_IPS;\r\nfreq = mpc5xxx_get_bus_frequency(ofdev->dev.of_node);\r\n} else {\r\n*mscan_clksrc = MSCAN_CLKSRC_BUS;\r\npval = of_get_property(ofdev->dev.of_node,\r\n"fsl,mscan-clock-divider", &plen);\r\nif (pval && plen == sizeof(*pval))\r\nclockdiv = *pval;\r\nif (!clockdiv)\r\nclockdiv = 1;\r\nif (!clock_name || !strcmp(clock_name, "sys")) {\r\nsys_clk = devm_clk_get(&ofdev->dev, "sys_clk");\r\nif (IS_ERR(sys_clk)) {\r\ndev_err(&ofdev->dev, "couldn't get sys_clk\n");\r\ngoto exit_unmap;\r\n}\r\nsys_freq = 1000000 *\r\n((clk_get_rate(sys_clk) + 499999) / 1000000);\r\nif (!clock_name) {\r\nif ((sys_freq % 16000000) == 0) {\r\nclocksrc = 0;\r\nclockdiv = sys_freq / 16000000;\r\nfreq = sys_freq / clockdiv;\r\n}\r\n} else {\r\nclocksrc = 0;\r\nfreq = sys_freq / clockdiv;\r\n}\r\n}\r\nif (clocksrc < 0) {\r\nref_clk = devm_clk_get(&ofdev->dev, "ref_clk");\r\nif (IS_ERR(ref_clk)) {\r\ndev_err(&ofdev->dev, "couldn't get ref_clk\n");\r\ngoto exit_unmap;\r\n}\r\nclocksrc = 1;\r\nfreq = clk_get_rate(ref_clk) / clockdiv;\r\n}\r\n}\r\nout_be32(&clockctl->mccr[clockidx], 0x0);\r\nif (clocksrc >= 0) {\r\nval = (clocksrc << 14) | ((clockdiv - 1) << 17);\r\nout_be32(&clockctl->mccr[clockidx], val);\r\nout_be32(&clockctl->mccr[clockidx], val | 0x10000);\r\n}\r\nval = in_be32(&clockctl->sccr[1]);\r\nif (!(val & (1 << 25)))\r\nout_be32(&clockctl->sccr[1], val | (1 << 25));\r\ndev_dbg(&ofdev->dev, "using '%s' with frequency divider %d\n",\r\n*mscan_clksrc == MSCAN_CLKSRC_IPS ? "ips_clk" :\r\nclocksrc == 1 ? "ref_clk" : "sys_clk", clockdiv);\r\nexit_unmap:\r\niounmap(clockctl);\r\nexit_put:\r\nof_node_put(np_clock);\r\nreturn freq;\r\n}\r\nstatic u32 mpc512x_can_get_clock(struct platform_device *ofdev,\r\nconst char *clock_name, int *mscan_clksrc)\r\n{\r\nreturn 0;\r\n}\r\nstatic int mpc5xxx_can_probe(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct mpc5xxx_can_data *data;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct net_device *dev;\r\nstruct mscan_priv *priv;\r\nvoid __iomem *base;\r\nconst char *clock_name = NULL;\r\nint irq, mscan_clksrc = 0;\r\nint err = -ENOMEM;\r\nmatch = of_match_device(mpc5xxx_can_table, &ofdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\ndata = match->data;\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\ndev_err(&ofdev->dev, "couldn't ioremap\n");\r\nreturn err;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\ndev_err(&ofdev->dev, "no irq found\n");\r\nerr = -ENODEV;\r\ngoto exit_unmap_mem;\r\n}\r\ndev = alloc_mscandev();\r\nif (!dev)\r\ngoto exit_dispose_irq;\r\nplatform_set_drvdata(ofdev, dev);\r\nSET_NETDEV_DEV(dev, &ofdev->dev);\r\npriv = netdev_priv(dev);\r\npriv->reg_base = base;\r\ndev->irq = irq;\r\nclock_name = of_get_property(np, "fsl,mscan-clock-source", NULL);\r\nBUG_ON(!data);\r\npriv->type = data->type;\r\npriv->can.clock.freq = data->get_clock(ofdev, clock_name,\r\n&mscan_clksrc);\r\nif (!priv->can.clock.freq) {\r\ndev_err(&ofdev->dev, "couldn't get MSCAN clock properties\n");\r\ngoto exit_free_mscan;\r\n}\r\nerr = register_mscandev(dev, mscan_clksrc);\r\nif (err) {\r\ndev_err(&ofdev->dev, "registering %s failed (err=%d)\n",\r\nDRV_NAME, err);\r\ngoto exit_free_mscan;\r\n}\r\ndev_info(&ofdev->dev, "MSCAN at 0x%p, irq %d, clock %d Hz\n",\r\npriv->reg_base, dev->irq, priv->can.clock.freq);\r\nreturn 0;\r\nexit_free_mscan:\r\nfree_candev(dev);\r\nexit_dispose_irq:\r\nirq_dispose_mapping(irq);\r\nexit_unmap_mem:\r\niounmap(base);\r\nreturn err;\r\n}\r\nstatic int mpc5xxx_can_remove(struct platform_device *ofdev)\r\n{\r\nconst struct of_device_id *match;\r\nconst struct mpc5xxx_can_data *data;\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nmatch = of_match_device(mpc5xxx_can_table, &ofdev->dev);\r\ndata = match ? match->data : NULL;\r\nunregister_mscandev(dev);\r\nif (data && data->put_clock)\r\ndata->put_clock(ofdev);\r\niounmap(priv->reg_base);\r\nirq_dispose_mapping(dev->irq);\r\nfree_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int mpc5xxx_can_suspend(struct platform_device *ofdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;\r\n_memcpy_fromio(&saved_regs, regs, sizeof(*regs));\r\nreturn 0;\r\n}\r\nstatic int mpc5xxx_can_resume(struct platform_device *ofdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(ofdev);\r\nstruct mscan_priv *priv = netdev_priv(dev);\r\nstruct mscan_regs *regs = (struct mscan_regs *)priv->reg_base;\r\nregs->canctl0 |= MSCAN_INITRQ;\r\nwhile (!(regs->canctl1 & MSCAN_INITAK))\r\nudelay(10);\r\nregs->canctl1 = saved_regs.canctl1;\r\nregs->canbtr0 = saved_regs.canbtr0;\r\nregs->canbtr1 = saved_regs.canbtr1;\r\nregs->canidac = saved_regs.canidac;\r\n_memcpy_toio(&regs->canidar1_0, (void *)&saved_regs.canidar1_0,\r\nsizeof(*regs) - offsetof(struct mscan_regs, canidar1_0));\r\nregs->canctl0 &= ~MSCAN_INITRQ;\r\nregs->cantbsel = saved_regs.cantbsel;\r\nregs->canrier = saved_regs.canrier;\r\nregs->cantier = saved_regs.cantier;\r\nregs->canctl0 = saved_regs.canctl0;\r\nreturn 0;\r\n}
