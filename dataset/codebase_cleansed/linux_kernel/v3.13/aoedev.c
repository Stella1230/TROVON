static int\r\nminor_get_dyn(ulong *sysminor)\r\n{\r\nulong flags;\r\nulong n;\r\nint error = 0;\r\nspin_lock_irqsave(&used_minors_lock, flags);\r\nn = find_first_zero_bit(used_minors, N_DEVS);\r\nif (n < N_DEVS)\r\nset_bit(n, used_minors);\r\nelse\r\nerror = -1;\r\nspin_unlock_irqrestore(&used_minors_lock, flags);\r\n*sysminor = n * AOE_PARTITIONS;\r\nreturn error;\r\n}\r\nstatic int\r\nminor_get_static(ulong *sysminor, ulong aoemaj, int aoemin)\r\n{\r\nulong flags;\r\nulong n;\r\nint error = 0;\r\nenum {\r\nNPERSHELF = 16,\r\n};\r\nif (aoemin >= NPERSHELF) {\r\npr_err("aoe: %s %d slots per shelf\n",\r\n"static minor device numbers support only",\r\nNPERSHELF);\r\nerror = -1;\r\ngoto out;\r\n}\r\nn = aoemaj * NPERSHELF + aoemin;\r\nif (n >= N_DEVS) {\r\npr_err("aoe: %s with e%ld.%d\n",\r\n"cannot use static minor device numbers",\r\naoemaj, aoemin);\r\nerror = -1;\r\ngoto out;\r\n}\r\nspin_lock_irqsave(&used_minors_lock, flags);\r\nif (test_bit(n, used_minors)) {\r\npr_err("aoe: %s %lu\n",\r\n"existing device already has static minor number",\r\nn);\r\nerror = -1;\r\n} else\r\nset_bit(n, used_minors);\r\nspin_unlock_irqrestore(&used_minors_lock, flags);\r\n*sysminor = n * AOE_PARTITIONS;\r\nout:\r\nreturn error;\r\n}\r\nstatic int\r\nminor_get(ulong *sysminor, ulong aoemaj, int aoemin)\r\n{\r\nif (aoe_dyndevs)\r\nreturn minor_get_dyn(sysminor);\r\nelse\r\nreturn minor_get_static(sysminor, aoemaj, aoemin);\r\n}\r\nstatic void\r\nminor_free(ulong minor)\r\n{\r\nulong flags;\r\nminor /= AOE_PARTITIONS;\r\nBUG_ON(minor >= N_DEVS);\r\nspin_lock_irqsave(&used_minors_lock, flags);\r\nBUG_ON(!test_bit(minor, used_minors));\r\nclear_bit(minor, used_minors);\r\nspin_unlock_irqrestore(&used_minors_lock, flags);\r\n}\r\nvoid\r\naoedev_put(struct aoedev *d)\r\n{\r\nulong flags;\r\nspin_lock_irqsave(&devlist_lock, flags);\r\nd->ref--;\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\n}\r\nstatic void\r\ndummy_timer(ulong vp)\r\n{\r\nstruct aoedev *d;\r\nd = (struct aoedev *)vp;\r\nif (d->flags & DEVFL_TKILL)\r\nreturn;\r\nd->timer.expires = jiffies + HZ;\r\nadd_timer(&d->timer);\r\n}\r\nstatic void\r\naoe_failip(struct aoedev *d)\r\n{\r\nstruct request *rq;\r\nstruct bio *bio;\r\nunsigned long n;\r\naoe_failbuf(d, d->ip.buf);\r\nrq = d->ip.rq;\r\nif (rq == NULL)\r\nreturn;\r\nwhile ((bio = d->ip.nxbio)) {\r\nclear_bit(BIO_UPTODATE, &bio->bi_flags);\r\nd->ip.nxbio = bio->bi_next;\r\nn = (unsigned long) rq->special;\r\nrq->special = (void *) --n;\r\n}\r\nif ((unsigned long) rq->special == 0)\r\naoe_end_request(d, rq, 0);\r\n}\r\nstatic void\r\ndowndev_frame(struct list_head *pos)\r\n{\r\nstruct frame *f;\r\nf = list_entry(pos, struct frame, head);\r\nlist_del(pos);\r\nif (f->buf) {\r\nf->buf->nframesout--;\r\naoe_failbuf(f->t->d, f->buf);\r\n}\r\naoe_freetframe(f);\r\n}\r\nvoid\r\naoedev_downdev(struct aoedev *d)\r\n{\r\nstruct aoetgt *t, **tt, **te;\r\nstruct list_head *head, *pos, *nx;\r\nstruct request *rq;\r\nint i;\r\nd->flags &= ~DEVFL_UP;\r\nfor (i = 0; i < NFACTIVE; i++) {\r\nhead = &d->factive[i];\r\nlist_for_each_safe(pos, nx, head)\r\ndowndev_frame(pos);\r\n}\r\nhead = &d->rexmitq;\r\nlist_for_each_safe(pos, nx, head)\r\ndowndev_frame(pos);\r\ntt = d->targets;\r\nte = tt + d->ntargets;\r\nfor (; tt < te && (t = *tt); tt++) {\r\naoecmd_wreset(t);\r\nt->nout = 0;\r\n}\r\naoe_failip(d);\r\nif (d->blkq) {\r\nwhile ((rq = blk_peek_request(d->blkq))) {\r\nblk_start_request(rq);\r\naoe_end_request(d, rq, 1);\r\n}\r\n}\r\nif (d->gd)\r\nset_capacity(d->gd, 0);\r\n}\r\nstatic int\r\nuser_req(char *s, size_t slen, struct aoedev *d)\r\n{\r\nconst char *p;\r\nsize_t lim;\r\nif (!d->gd)\r\nreturn 0;\r\np = kbasename(d->gd->disk_name);\r\nlim = sizeof(d->gd->disk_name);\r\nlim -= p - d->gd->disk_name;\r\nif (slen < lim)\r\nlim = slen;\r\nreturn !strncmp(s, p, lim);\r\n}\r\nstatic void\r\nfreedev(struct aoedev *d)\r\n{\r\nstruct aoetgt **t, **e;\r\nint freeing = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&d->lock, flags);\r\nif (d->flags & DEVFL_TKILL\r\n&& !(d->flags & DEVFL_FREEING)) {\r\nd->flags |= DEVFL_FREEING;\r\nfreeing = 1;\r\n}\r\nspin_unlock_irqrestore(&d->lock, flags);\r\nif (!freeing)\r\nreturn;\r\ndel_timer_sync(&d->timer);\r\nif (d->gd) {\r\naoedisk_rm_debugfs(d);\r\naoedisk_rm_sysfs(d);\r\ndel_gendisk(d->gd);\r\nput_disk(d->gd);\r\nblk_cleanup_queue(d->blkq);\r\n}\r\nt = d->targets;\r\ne = t + d->ntargets;\r\nfor (; t < e && *t; t++)\r\nfreetgt(d, *t);\r\nif (d->bufpool)\r\nmempool_destroy(d->bufpool);\r\nskbpoolfree(d);\r\nminor_free(d->sysminor);\r\nspin_lock_irqsave(&d->lock, flags);\r\nd->flags |= DEVFL_FREED;\r\nspin_unlock_irqrestore(&d->lock, flags);\r\n}\r\nstatic int\r\nflush(const char __user *str, size_t cnt, int exiting)\r\n{\r\nulong flags;\r\nstruct aoedev *d, **dd;\r\nchar buf[16];\r\nint all = 0;\r\nint specified = 0;\r\nunsigned int skipflags;\r\nskipflags = DEVFL_GDALLOC | DEVFL_NEWSIZE | DEVFL_TKILL;\r\nif (!exiting && cnt >= 3) {\r\nif (cnt > sizeof buf)\r\ncnt = sizeof buf;\r\nif (copy_from_user(buf, str, cnt))\r\nreturn -EFAULT;\r\nall = !strncmp(buf, "all", 3);\r\nif (!all)\r\nspecified = 1;\r\n}\r\nflush_scheduled_work();\r\nspin_lock_irqsave(&devlist_lock, flags);\r\nfor (d = devlist; d; d = d->next) {\r\nspin_lock(&d->lock);\r\nif (exiting) {\r\n} else if (specified) {\r\nif (!user_req(buf, cnt, d))\r\ngoto cont;\r\n} else if ((!all && (d->flags & DEVFL_UP))\r\n|| d->flags & skipflags\r\n|| d->nopen\r\n|| d->ref)\r\ngoto cont;\r\naoedev_downdev(d);\r\nd->flags |= DEVFL_TKILL;\r\ncont:\r\nspin_unlock(&d->lock);\r\n}\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nrestart:\r\nspin_lock_irqsave(&devlist_lock, flags);\r\nfor (d = devlist; d; d = d->next) {\r\nspin_lock(&d->lock);\r\nif (d->flags & DEVFL_TKILL\r\n&& !(d->flags & DEVFL_FREEING)) {\r\nspin_unlock(&d->lock);\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nfreedev(d);\r\ngoto restart;\r\n}\r\nspin_unlock(&d->lock);\r\n}\r\nfor (dd = &devlist, d = *dd; d; d = *dd) {\r\nstruct aoedev *doomed = NULL;\r\nspin_lock(&d->lock);\r\nif (d->flags & DEVFL_FREED) {\r\n*dd = d->next;\r\ndoomed = d;\r\n} else {\r\ndd = &d->next;\r\n}\r\nspin_unlock(&d->lock);\r\nif (doomed)\r\nkfree(doomed->targets);\r\nkfree(doomed);\r\n}\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nreturn 0;\r\n}\r\nint\r\naoedev_flush(const char __user *str, size_t cnt)\r\n{\r\nreturn flush(str, cnt, NOT_EXITING);\r\n}\r\nstatic void\r\nskbfree(struct sk_buff *skb)\r\n{\r\nenum { Sms = 250, Tms = 30 * 1000};\r\nint i = Tms / Sms;\r\nif (skb == NULL)\r\nreturn;\r\nwhile (atomic_read(&skb_shinfo(skb)->dataref) != 1 && i-- > 0)\r\nmsleep(Sms);\r\nif (i < 0) {\r\nprintk(KERN_ERR\r\n"aoe: %s holds ref: %s\n",\r\nskb->dev ? skb->dev->name : "netif",\r\n"cannot free skb -- memory leaked.");\r\nreturn;\r\n}\r\nskb->truesize -= skb->data_len;\r\nskb_shinfo(skb)->nr_frags = skb->data_len = 0;\r\nskb_trim(skb, 0);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void\r\nskbpoolfree(struct aoedev *d)\r\n{\r\nstruct sk_buff *skb, *tmp;\r\nskb_queue_walk_safe(&d->skbpool, skb, tmp)\r\nskbfree(skb);\r\n__skb_queue_head_init(&d->skbpool);\r\n}\r\nstruct aoedev *\r\naoedev_by_aoeaddr(ulong maj, int min, int do_alloc)\r\n{\r\nstruct aoedev *d;\r\nint i;\r\nulong flags;\r\nulong sysminor = 0;\r\nspin_lock_irqsave(&devlist_lock, flags);\r\nfor (d=devlist; d; d=d->next)\r\nif (d->aoemajor == maj && d->aoeminor == min) {\r\nspin_lock(&d->lock);\r\nif (d->flags & DEVFL_TKILL) {\r\nspin_unlock(&d->lock);\r\nd = NULL;\r\ngoto out;\r\n}\r\nd->ref++;\r\nspin_unlock(&d->lock);\r\nbreak;\r\n}\r\nif (d || !do_alloc || minor_get(&sysminor, maj, min) < 0)\r\ngoto out;\r\nd = kcalloc(1, sizeof *d, GFP_ATOMIC);\r\nif (!d)\r\ngoto out;\r\nd->targets = kcalloc(NTARGETS, sizeof(*d->targets), GFP_ATOMIC);\r\nif (!d->targets) {\r\nkfree(d);\r\nd = NULL;\r\ngoto out;\r\n}\r\nd->ntargets = NTARGETS;\r\nINIT_WORK(&d->work, aoecmd_sleepwork);\r\nspin_lock_init(&d->lock);\r\nskb_queue_head_init(&d->skbpool);\r\ninit_timer(&d->timer);\r\nd->timer.data = (ulong) d;\r\nd->timer.function = dummy_timer;\r\nd->timer.expires = jiffies + HZ;\r\nadd_timer(&d->timer);\r\nd->bufpool = NULL;\r\nd->tgt = d->targets;\r\nd->ref = 1;\r\nfor (i = 0; i < NFACTIVE; i++)\r\nINIT_LIST_HEAD(&d->factive[i]);\r\nINIT_LIST_HEAD(&d->rexmitq);\r\nd->sysminor = sysminor;\r\nd->aoemajor = maj;\r\nd->aoeminor = min;\r\nd->rttavg = RTTAVG_INIT;\r\nd->rttdev = RTTDEV_INIT;\r\nd->next = devlist;\r\ndevlist = d;\r\nout:\r\nspin_unlock_irqrestore(&devlist_lock, flags);\r\nreturn d;\r\n}\r\nstatic void\r\nfreetgt(struct aoedev *d, struct aoetgt *t)\r\n{\r\nstruct frame *f;\r\nstruct list_head *pos, *nx, *head;\r\nstruct aoeif *ifp;\r\nfor (ifp = t->ifs; ifp < &t->ifs[NAOEIFS]; ++ifp) {\r\nif (!ifp->nd)\r\nbreak;\r\ndev_put(ifp->nd);\r\n}\r\nhead = &t->ffree;\r\nlist_for_each_safe(pos, nx, head) {\r\nlist_del(pos);\r\nf = list_entry(pos, struct frame, head);\r\nskbfree(f->skb);\r\nkfree(f);\r\n}\r\nkfree(t);\r\n}\r\nvoid\r\naoedev_exit(void)\r\n{\r\nflush_scheduled_work();\r\nflush(NULL, 0, EXITING);\r\n}\r\nint __init\r\naoedev_init(void)\r\n{\r\nreturn 0;\r\n}
