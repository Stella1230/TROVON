static int llog_lvfs_pad(struct obd_device *obd, struct l_file *file,\r\nint len, int index)\r\n{\r\nstruct llog_rec_hdr rec = { 0 };\r\nstruct llog_rec_tail tail;\r\nint rc;\r\nLASSERT(len >= LLOG_MIN_REC_SIZE && (len & 0x7) == 0);\r\ntail.lrt_len = rec.lrh_len = len;\r\ntail.lrt_index = rec.lrh_index = index;\r\nrec.lrh_type = LLOG_PAD_MAGIC;\r\nrc = fsfilt_write_record(obd, file, &rec, sizeof(rec), &file->f_pos, 0);\r\nif (rc) {\r\nCERROR("error writing padding record: rc %d\n", rc);\r\ngoto out;\r\n}\r\nfile->f_pos += len - sizeof(rec) - sizeof(tail);\r\nrc = fsfilt_write_record(obd, file, &tail, sizeof(tail),&file->f_pos,0);\r\nif (rc) {\r\nCERROR("error writing padding record: rc %d\n", rc);\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_write_blob(struct obd_device *obd, struct l_file *file,\r\nstruct llog_rec_hdr *rec, void *buf, loff_t off)\r\n{\r\nint rc;\r\nstruct llog_rec_tail end;\r\nloff_t saved_off = file->f_pos;\r\nint buflen = rec->lrh_len;\r\nfile->f_pos = off;\r\nif (buflen == 0)\r\nCWARN("0-length record\n");\r\nif (!buf) {\r\nrc = fsfilt_write_record(obd, file, rec, buflen,&file->f_pos,0);\r\nif (rc) {\r\nCERROR("error writing log record: rc %d\n", rc);\r\ngoto out;\r\n}\r\nGOTO(out, rc = 0);\r\n}\r\nrec->lrh_len = sizeof(*rec) + buflen + sizeof(end);\r\nrc = fsfilt_write_record(obd, file, rec, sizeof(*rec), &file->f_pos, 0);\r\nif (rc) {\r\nCERROR("error writing log hdr: rc %d\n", rc);\r\ngoto out;\r\n}\r\nrc = fsfilt_write_record(obd, file, buf, buflen, &file->f_pos, 0);\r\nif (rc) {\r\nCERROR("error writing log buffer: rc %d\n", rc);\r\ngoto out;\r\n}\r\nend.lrt_len = rec->lrh_len;\r\nend.lrt_index = rec->lrh_index;\r\nrc = fsfilt_write_record(obd, file, &end, sizeof(end), &file->f_pos, 0);\r\nif (rc) {\r\nCERROR("error writing log tail: rc %d\n", rc);\r\ngoto out;\r\n}\r\nrc = 0;\r\nout:\r\nif (saved_off > file->f_pos)\r\nfile->f_pos = saved_off;\r\nLASSERT(rc <= 0);\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_read_blob(struct obd_device *obd, struct l_file *file,\r\nvoid *buf, int size, loff_t off)\r\n{\r\nloff_t offset = off;\r\nint rc;\r\nrc = fsfilt_read_record(obd, file, buf, size, &offset);\r\nif (rc) {\r\nCERROR("error reading log record: rc %d\n", rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int llog_lvfs_read_header(const struct lu_env *env,\r\nstruct llog_handle *handle)\r\n{\r\nstruct obd_device *obd;\r\nint rc;\r\nLASSERT(sizeof(*handle->lgh_hdr) == LLOG_CHUNK_SIZE);\r\nobd = handle->lgh_ctxt->loc_exp->exp_obd;\r\nif (i_size_read(handle->lgh_file->f_dentry->d_inode) == 0) {\r\nCDEBUG(D_HA, "not reading header from 0-byte log\n");\r\nreturn LLOG_EEMPTY;\r\n}\r\nrc = llog_lvfs_read_blob(obd, handle->lgh_file, handle->lgh_hdr,\r\nLLOG_CHUNK_SIZE, 0);\r\nif (rc) {\r\nCERROR("error reading log header from %.*s\n",\r\nhandle->lgh_file->f_dentry->d_name.len,\r\nhandle->lgh_file->f_dentry->d_name.name);\r\n} else {\r\nstruct llog_rec_hdr *llh_hdr = &handle->lgh_hdr->llh_hdr;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(llh_hdr))\r\nlustre_swab_llog_hdr(handle->lgh_hdr);\r\nif (llh_hdr->lrh_type != LLOG_HDR_MAGIC) {\r\nCERROR("bad log %.*s header magic: %#x (expected %#x)\n",\r\nhandle->lgh_file->f_dentry->d_name.len,\r\nhandle->lgh_file->f_dentry->d_name.name,\r\nllh_hdr->lrh_type, LLOG_HDR_MAGIC);\r\nrc = -EIO;\r\n} else if (llh_hdr->lrh_len != LLOG_CHUNK_SIZE) {\r\nCERROR("incorrectly sized log %.*s header: %#x "\r\n"(expected %#x)\n",\r\nhandle->lgh_file->f_dentry->d_name.len,\r\nhandle->lgh_file->f_dentry->d_name.name,\r\nllh_hdr->lrh_len, LLOG_CHUNK_SIZE);\r\nCERROR("you may need to re-run lconf --write_conf.\n");\r\nrc = -EIO;\r\n}\r\n}\r\nhandle->lgh_last_idx = handle->lgh_hdr->llh_tail.lrt_index;\r\nhandle->lgh_file->f_pos = i_size_read(handle->lgh_file->f_dentry->d_inode);\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_write_rec(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nstruct llog_rec_hdr *rec,\r\nstruct llog_cookie *reccookie, int cookiecount,\r\nvoid *buf, int idx, struct thandle *th)\r\n{\r\nstruct llog_log_hdr *llh;\r\nint reclen = rec->lrh_len, index, rc;\r\nstruct llog_rec_tail *lrt;\r\nstruct obd_device *obd;\r\nstruct file *file;\r\nsize_t left;\r\nllh = loghandle->lgh_hdr;\r\nfile = loghandle->lgh_file;\r\nobd = loghandle->lgh_ctxt->loc_exp->exp_obd;\r\nif (buf)\r\nrc = (reclen > LLOG_CHUNK_SIZE - sizeof(struct llog_rec_hdr) -\r\nsizeof(struct llog_rec_tail)) ? -E2BIG : 0;\r\nelse\r\nrc = (reclen > LLOG_CHUNK_SIZE) ? -E2BIG : 0;\r\nif (rc)\r\nreturn rc;\r\nif (buf)\r\nreclen = sizeof(*rec) + rec->lrh_len +\r\nsizeof(struct llog_rec_tail);\r\nif (idx != -1) {\r\nloff_t saved_offset;\r\nif (idx != 1 && !i_size_read(file->f_dentry->d_inode)) {\r\nCERROR("idx != -1 in empty log\n");\r\nLBUG();\r\n}\r\nif (idx && llh->llh_size && llh->llh_size != rec->lrh_len)\r\nreturn -EINVAL;\r\nif (!ext2_test_bit(idx, llh->llh_bitmap))\r\nCERROR("Modify unset record %u\n", idx);\r\nif (idx != rec->lrh_index)\r\nCERROR("Index mismatch %d %u\n", idx, rec->lrh_index);\r\nrc = llog_lvfs_write_blob(obd, file, &llh->llh_hdr, NULL, 0);\r\nif (rc || idx == 0)\r\nreturn rc;\r\nif (buf) {\r\nsaved_offset = loghandle->lgh_cur_offset;\r\nCDEBUG(D_OTHER,\r\n"modify record "DOSTID": idx:%d/%u/%d, len:%u "\r\n"offset %llu\n",\r\nPOSTID(&loghandle->lgh_id.lgl_oi), idx, rec->lrh_index,\r\nloghandle->lgh_cur_idx, rec->lrh_len,\r\n(long long)(saved_offset - sizeof(*llh)));\r\nif (rec->lrh_index != loghandle->lgh_cur_idx) {\r\nCERROR("modify idx mismatch %u/%d\n",\r\nidx, loghandle->lgh_cur_idx);\r\nreturn -EFAULT;\r\n}\r\n} else {\r\nsaved_offset = sizeof(*llh) + (idx - 1) * reclen;\r\n}\r\nrc = llog_lvfs_write_blob(obd, file, rec, buf, saved_offset);\r\nif (rc == 0 && reccookie) {\r\nreccookie->lgc_lgl = loghandle->lgh_id;\r\nreccookie->lgc_index = idx;\r\nrc = 1;\r\n}\r\nreturn rc;\r\n}\r\nleft = LLOG_CHUNK_SIZE - (file->f_pos & (LLOG_CHUNK_SIZE - 1));\r\nif (left != 0 && left != reclen &&\r\nleft < (reclen + LLOG_MIN_REC_SIZE)) {\r\nindex = loghandle->lgh_last_idx + 1;\r\nrc = llog_lvfs_pad(obd, file, left, index);\r\nif (rc)\r\nreturn rc;\r\nloghandle->lgh_last_idx++;\r\n}\r\nif (loghandle->lgh_last_idx >= LLOG_BITMAP_SIZE(llh) - 1)\r\nreturn -ENOSPC;\r\nloghandle->lgh_last_idx++;\r\nindex = loghandle->lgh_last_idx;\r\nLASSERT(index < LLOG_BITMAP_SIZE(llh));\r\nrec->lrh_index = index;\r\nif (buf == NULL) {\r\nlrt = (struct llog_rec_tail *)\r\n((char *)rec + rec->lrh_len - sizeof(*lrt));\r\nlrt->lrt_len = rec->lrh_len;\r\nlrt->lrt_index = rec->lrh_index;\r\n}\r\nLASSERT(index < LLOG_BITMAP_SIZE(llh));\r\nspin_lock(&loghandle->lgh_hdr_lock);\r\nif (ext2_set_bit(index, llh->llh_bitmap)) {\r\nCERROR("argh, index %u already set in log bitmap?\n", index);\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nLBUG();\r\n}\r\nllh->llh_count++;\r\nspin_unlock(&loghandle->lgh_hdr_lock);\r\nllh->llh_tail.lrt_index = index;\r\nrc = llog_lvfs_write_blob(obd, file, &llh->llh_hdr, NULL, 0);\r\nif (rc)\r\nreturn rc;\r\nrc = llog_lvfs_write_blob(obd, file, rec, buf, file->f_pos);\r\nif (rc)\r\nreturn rc;\r\nCDEBUG(D_RPCTRACE, "added record "DOSTID": idx: %u, %u \n",\r\nPOSTID(&loghandle->lgh_id.lgl_oi), index, rec->lrh_len);\r\nif (rc == 0 && reccookie) {\r\nreccookie->lgc_lgl = loghandle->lgh_id;\r\nreccookie->lgc_index = index;\r\nif ((rec->lrh_type == MDS_UNLINK_REC) ||\r\n(rec->lrh_type == MDS_SETATTR64_REC))\r\nreccookie->lgc_subsys = LLOG_MDS_OST_ORIG_CTXT;\r\nelse if (rec->lrh_type == OST_SZ_REC)\r\nreccookie->lgc_subsys = LLOG_SIZE_ORIG_CTXT;\r\nelse\r\nreccookie->lgc_subsys = -1;\r\nrc = 1;\r\n}\r\nif (rc == 0 && rec->lrh_type == LLOG_GEN_REC)\r\nrc = 1;\r\nreturn rc;\r\n}\r\nstatic void llog_skip_over(__u64 *off, int curr, int goal)\r\n{\r\nif (goal <= curr)\r\nreturn;\r\n*off = (*off + (goal-curr-1) * LLOG_MIN_REC_SIZE) &\r\n~(LLOG_CHUNK_SIZE - 1);\r\n}\r\nstatic int llog_lvfs_next_block(const struct lu_env *env,\r\nstruct llog_handle *loghandle, int *cur_idx,\r\nint next_idx, __u64 *cur_offset, void *buf,\r\nint len)\r\n{\r\nint rc;\r\nif (len == 0 || len & (LLOG_CHUNK_SIZE - 1))\r\nreturn -EINVAL;\r\nCDEBUG(D_OTHER, "looking for log index %u (cur idx %u off "LPU64")\n",\r\nnext_idx, *cur_idx, *cur_offset);\r\nwhile (*cur_offset < i_size_read(loghandle->lgh_file->f_dentry->d_inode)) {\r\nstruct llog_rec_hdr *rec, *last_rec;\r\nstruct llog_rec_tail *tail;\r\nloff_t ppos;\r\nint llen;\r\nllog_skip_over(cur_offset, *cur_idx, next_idx);\r\nppos = *cur_offset;\r\nllen = LLOG_CHUNK_SIZE - (*cur_offset & (LLOG_CHUNK_SIZE - 1));\r\nrc = fsfilt_read_record(loghandle->lgh_ctxt->loc_exp->exp_obd,\r\nloghandle->lgh_file, buf, llen,\r\ncur_offset);\r\nif (rc < 0) {\r\nCERROR("Cant read llog block at log id "DOSTID\r\n"/%u offset "LPU64"\n",\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen,\r\n*cur_offset);\r\nreturn rc;\r\n}\r\nrc = *cur_offset - ppos;\r\nif (rc < len) {\r\nmemset(buf + rc, 0, len - rc);\r\n}\r\nif (rc == 0)\r\nreturn 0;\r\nif (rc < sizeof(*tail)) {\r\nCERROR("Invalid llog block at log id "DOSTID"/%u offset"\r\nLPU64"\n", POSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, *cur_offset);\r\nreturn -EINVAL;\r\n}\r\nrec = buf;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\ntail = (struct llog_rec_tail *)(buf + rc -\r\nsizeof(struct llog_rec_tail));\r\nlast_rec = (struct llog_rec_hdr *)(buf + rc -\r\nle32_to_cpu(tail->lrt_len));\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(last_rec))\r\nlustre_swab_llog_rec(last_rec);\r\nLASSERT(last_rec->lrh_index == tail->lrt_index);\r\n*cur_idx = tail->lrt_index;\r\nif (tail->lrt_index == 0) {\r\nCERROR("Invalid llog tail at log id "DOSTID"/%u offset "\r\nLPU64"\n", POSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, *cur_offset);\r\nreturn -EINVAL;\r\n}\r\nif (tail->lrt_index < next_idx)\r\ncontinue;\r\nif (rec->lrh_index > next_idx) {\r\nCERROR("missed desired record? %u > %u\n",\r\nrec->lrh_index, next_idx);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic int llog_lvfs_prev_block(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nint prev_idx, void *buf, int len)\r\n{\r\n__u64 cur_offset;\r\nint rc;\r\nif (len == 0 || len & (LLOG_CHUNK_SIZE - 1))\r\nreturn -EINVAL;\r\nCDEBUG(D_OTHER, "looking for log index %u\n", prev_idx);\r\ncur_offset = LLOG_CHUNK_SIZE;\r\nllog_skip_over(&cur_offset, 0, prev_idx);\r\nwhile (cur_offset < i_size_read(loghandle->lgh_file->f_dentry->d_inode)) {\r\nstruct llog_rec_hdr *rec, *last_rec;\r\nstruct llog_rec_tail *tail;\r\nloff_t ppos = cur_offset;\r\nrc = fsfilt_read_record(loghandle->lgh_ctxt->loc_exp->exp_obd,\r\nloghandle->lgh_file, buf, len,\r\n&cur_offset);\r\nif (rc < 0) {\r\nCERROR("Cant read llog block at log id "DOSTID\r\n"/%u offset "LPU64"\n",\r\nPOSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen,\r\ncur_offset);\r\nreturn rc;\r\n}\r\nrc = cur_offset - ppos;\r\nif (rc == 0)\r\nreturn 0;\r\nif (rc < sizeof(*tail)) {\r\nCERROR("Invalid llog block at log id "DOSTID"/%u offset"\r\nLPU64"\n", POSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, cur_offset);\r\nreturn -EINVAL;\r\n}\r\nrec = buf;\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(rec))\r\nlustre_swab_llog_rec(rec);\r\ntail = (struct llog_rec_tail *)(buf + rc -\r\nsizeof(struct llog_rec_tail));\r\nlast_rec = (struct llog_rec_hdr *)(buf + rc -\r\nle32_to_cpu(tail->lrt_len));\r\nif (LLOG_REC_HDR_NEEDS_SWABBING(last_rec))\r\nlustre_swab_llog_rec(last_rec);\r\nLASSERT(last_rec->lrh_index == tail->lrt_index);\r\nif (tail->lrt_index == 0) {\r\nCERROR("Invalid llog tail at log id "DOSTID"/%u offset"\r\nLPU64"\n", POSTID(&loghandle->lgh_id.lgl_oi),\r\nloghandle->lgh_id.lgl_ogen, cur_offset);\r\nreturn -EINVAL;\r\n}\r\nif (tail->lrt_index < prev_idx)\r\ncontinue;\r\nif (rec->lrh_index > prev_idx) {\r\nCERROR("missed desired record? %u > %u\n",\r\nrec->lrh_index, prev_idx);\r\nreturn -ENOENT;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nstatic struct file *llog_filp_open(char *dir, char *name, int flags, int mode)\r\n{\r\nchar *logname;\r\nstruct file *filp;\r\nint len;\r\nOBD_ALLOC(logname, PATH_MAX);\r\nif (logname == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nlen = snprintf(logname, PATH_MAX, "%s/%s", dir, name);\r\nif (len >= PATH_MAX - 1) {\r\nfilp = ERR_PTR(-ENAMETOOLONG);\r\n} else {\r\nfilp = l_filp_open(logname, flags, mode);\r\nif (IS_ERR(filp) && PTR_ERR(filp) != -ENOENT)\r\nCERROR("logfile creation %s: %ld\n", logname,\r\nPTR_ERR(filp));\r\n}\r\nOBD_FREE(logname, PATH_MAX);\r\nreturn filp;\r\n}\r\nstatic int llog_lvfs_open(const struct lu_env *env, struct llog_handle *handle,\r\nstruct llog_logid *logid, char *name,\r\nenum llog_open_param open_param)\r\n{\r\nstruct llog_ctxt *ctxt = handle->lgh_ctxt;\r\nstruct l_dentry *dchild = NULL;\r\nstruct obd_device *obd;\r\nint rc = 0;\r\nLASSERT(ctxt);\r\nLASSERT(ctxt->loc_exp);\r\nLASSERT(ctxt->loc_exp->exp_obd);\r\nobd = ctxt->loc_exp->exp_obd;\r\nLASSERT(handle);\r\nif (logid != NULL) {\r\ndchild = obd_lvfs_fid2dentry(ctxt->loc_exp, &logid->lgl_oi,\r\nlogid->lgl_ogen);\r\nif (IS_ERR(dchild)) {\r\nrc = PTR_ERR(dchild);\r\nCERROR("%s: error looking up logfile #"DOSTID "#%08x:"\r\n" rc = %d\n", ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), logid->lgl_ogen, rc);\r\nGOTO(out, rc);\r\n}\r\nif (dchild->d_inode == NULL) {\r\nl_dput(dchild);\r\nrc = -ENOENT;\r\nCERROR("%s: nonexistent llog #"DOSTID"#%08x:"\r\n"rc = %d\n", ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), logid->lgl_ogen, rc);\r\nGOTO(out, rc);\r\n}\r\nhandle->lgh_file = l_dentry_open(&obd->obd_lvfs_ctxt, dchild,\r\nO_RDWR | O_LARGEFILE);\r\nl_dput(dchild);\r\nif (IS_ERR(handle->lgh_file)) {\r\nrc = PTR_ERR(handle->lgh_file);\r\nhandle->lgh_file = NULL;\r\nCERROR("%s: error opening llog #"DOSTID"#%08x:"\r\n"rc = %d\n", ctxt->loc_obd->obd_name,\r\nPOSTID(&logid->lgl_oi), logid->lgl_ogen, rc);\r\nGOTO(out, rc);\r\n}\r\nhandle->lgh_id = *logid;\r\n} else if (name) {\r\nhandle->lgh_file = llog_filp_open(MOUNT_CONFIGS_DIR, name,\r\nO_RDWR | O_LARGEFILE, 0644);\r\nif (IS_ERR(handle->lgh_file)) {\r\nrc = PTR_ERR(handle->lgh_file);\r\nhandle->lgh_file = NULL;\r\nif (rc == -ENOENT && open_param == LLOG_OPEN_NEW) {\r\nOBD_ALLOC(handle->lgh_name, strlen(name) + 1);\r\nif (handle->lgh_name)\r\nstrcpy(handle->lgh_name, name);\r\nelse\r\nGOTO(out, rc = -ENOMEM);\r\nrc = 0;\r\n} else {\r\nGOTO(out, rc);\r\n}\r\n} else {\r\nlustre_build_llog_lvfs_oid(&handle->lgh_id,\r\nhandle->lgh_file->f_dentry->d_inode->i_ino,\r\nhandle->lgh_file->f_dentry->d_inode->i_generation);\r\n}\r\n} else {\r\nLASSERTF(open_param == LLOG_OPEN_NEW, "%#x\n", open_param);\r\nhandle->lgh_file = NULL;\r\n}\r\nif (open_param != LLOG_OPEN_NEW && handle->lgh_file == NULL)\r\nGOTO(out_name, rc = -ENOENT);\r\nreturn 0;\r\nout_name:\r\nif (handle->lgh_name != NULL)\r\nOBD_FREE(handle->lgh_name, strlen(name) + 1);\r\nout:\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_exist(struct llog_handle *handle)\r\n{\r\nreturn (handle->lgh_file != NULL);\r\n}\r\nstatic int llog_lvfs_create(const struct lu_env *env,\r\nstruct llog_handle *handle,\r\nstruct thandle *th)\r\n{\r\nstruct llog_ctxt *ctxt = handle->lgh_ctxt;\r\nstruct obd_device *obd;\r\nstruct l_dentry *dchild = NULL;\r\nstruct file *file;\r\nstruct obdo *oa = NULL;\r\nint rc = 0;\r\nint open_flags = O_RDWR | O_CREAT | O_LARGEFILE;\r\nLASSERT(ctxt);\r\nLASSERT(ctxt->loc_exp);\r\nobd = ctxt->loc_exp->exp_obd;\r\nLASSERT(handle->lgh_file == NULL);\r\nif (handle->lgh_name) {\r\nfile = llog_filp_open(MOUNT_CONFIGS_DIR, handle->lgh_name,\r\nopen_flags, 0644);\r\nif (IS_ERR(file))\r\nreturn PTR_ERR(file);\r\nlustre_build_llog_lvfs_oid(&handle->lgh_id,\r\nfile->f_dentry->d_inode->i_ino,\r\nfile->f_dentry->d_inode->i_generation);\r\nhandle->lgh_file = file;\r\n} else {\r\nOBDO_ALLOC(oa);\r\nif (oa == NULL)\r\nreturn -ENOMEM;\r\nostid_set_seq_llog(&oa->o_oi);\r\noa->o_valid = OBD_MD_FLGENER | OBD_MD_FLGROUP;\r\nrc = obd_create(NULL, ctxt->loc_exp, oa, NULL, NULL);\r\nif (rc)\r\nGOTO(out, rc);\r\n#define o_generation o_parent_oid\r\ndchild = obd_lvfs_fid2dentry(ctxt->loc_exp, &oa->o_oi,\r\noa->o_generation);\r\nif (IS_ERR(dchild))\r\nGOTO(out, rc = PTR_ERR(dchild));\r\nfile = l_dentry_open(&obd->obd_lvfs_ctxt, dchild, open_flags);\r\nl_dput(dchild);\r\nif (IS_ERR(file))\r\nGOTO(out, rc = PTR_ERR(file));\r\nhandle->lgh_id.lgl_oi = oa->o_oi;\r\nhandle->lgh_id.lgl_ogen = oa->o_generation;\r\nhandle->lgh_file = file;\r\nout:\r\nOBDO_FREE(oa);\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_close(const struct lu_env *env,\r\nstruct llog_handle *handle)\r\n{\r\nint rc;\r\nif (handle->lgh_file == NULL)\r\nreturn 0;\r\nrc = filp_close(handle->lgh_file, 0);\r\nif (rc)\r\nCERROR("%s: error closing llog #"DOSTID"#%08x: "\r\n"rc = %d\n", handle->lgh_ctxt->loc_obd->obd_name,\r\nPOSTID(&handle->lgh_id.lgl_oi),\r\nhandle->lgh_id.lgl_ogen, rc);\r\nhandle->lgh_file = NULL;\r\nif (handle->lgh_name) {\r\nOBD_FREE(handle->lgh_name, strlen(handle->lgh_name) + 1);\r\nhandle->lgh_name = NULL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_destroy(const struct lu_env *env,\r\nstruct llog_handle *handle)\r\n{\r\nstruct dentry *fdentry;\r\nstruct obdo *oa;\r\nstruct obd_device *obd = handle->lgh_ctxt->loc_exp->exp_obd;\r\nchar *dir;\r\nvoid *th;\r\nstruct inode *inode;\r\nint rc, rc1;\r\ndir = MOUNT_CONFIGS_DIR;\r\nLASSERT(handle->lgh_file);\r\nfdentry = handle->lgh_file->f_dentry;\r\ninode = fdentry->d_parent->d_inode;\r\nif (strcmp(fdentry->d_parent->d_name.name, dir) == 0) {\r\nstruct lvfs_run_ctxt saved;\r\nstruct vfsmount *mnt = mntget(handle->lgh_file->f_vfsmnt);\r\npush_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\ndget(fdentry);\r\nrc = llog_lvfs_close(env, handle);\r\nif (rc == 0) {\r\nmutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT);\r\nrc = ll_vfs_unlink(inode, fdentry, mnt);\r\nmutex_unlock(&inode->i_mutex);\r\n}\r\nmntput(mnt);\r\ndput(fdentry);\r\npop_ctxt(&saved, &obd->obd_lvfs_ctxt, NULL);\r\nreturn rc;\r\n}\r\nOBDO_ALLOC(oa);\r\nif (oa == NULL)\r\nreturn -ENOMEM;\r\noa->o_oi = handle->lgh_id.lgl_oi;\r\noa->o_generation = handle->lgh_id.lgl_ogen;\r\n#undef o_generation\r\noa->o_valid = OBD_MD_FLID | OBD_MD_FLGROUP | OBD_MD_FLGENER;\r\nrc = llog_lvfs_close(env, handle);\r\nif (rc)\r\nGOTO(out, rc);\r\nth = fsfilt_start_log(obd, inode, FSFILT_OP_UNLINK, NULL, 1);\r\nif (IS_ERR(th)) {\r\nCERROR("fsfilt_start failed: %ld\n", PTR_ERR(th));\r\nGOTO(out, rc = PTR_ERR(th));\r\n}\r\nrc = obd_destroy(NULL, handle->lgh_ctxt->loc_exp, oa,\r\nNULL, NULL, NULL, NULL);\r\nrc1 = fsfilt_commit(obd, inode, th, 0);\r\nif (rc == 0 && rc1 != 0)\r\nrc = rc1;\r\nout:\r\nOBDO_FREE(oa);\r\nreturn rc;\r\n}\r\nstatic int llog_lvfs_declare_create(const struct lu_env *env,\r\nstruct llog_handle *res,\r\nstruct thandle *th)\r\n{\r\nreturn 0;\r\n}\r\nstatic int llog_lvfs_declare_write_rec(const struct lu_env *env,\r\nstruct llog_handle *loghandle,\r\nstruct llog_rec_hdr *rec,\r\nint idx, struct thandle *th)\r\n{\r\nreturn 0;\r\n}
