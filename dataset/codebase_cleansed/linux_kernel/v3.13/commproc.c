void __init m360_cpm_reset()\r\n{\r\npquicc = (struct quicc *)(_quicc_base);\r\npquicc->cp_cr = (SOFTWARE_RESET | CMD_FLAG);\r\nwhile (pquicc->cp_cr & CMD_FLAG);\r\npquicc->sdma_sdcr = 0x0740;\r\ndp_alloc_base = CPM_DATAONLY_BASE;\r\ndp_alloc_top = dp_alloc_base + CPM_DATAONLY_SIZE;\r\n}\r\nvoid\r\ncpm_interrupt_init(void)\r\n{\r\npquicc->intr_cicr =\r\n(CICR_SCD_SCC4 | CICR_SCC_SCC3 | CICR_SCB_SCC2 | CICR_SCA_SCC1) |\r\n(CPM_INTERRUPT << 13) |\r\nCICR_HP_MASK |\r\n(CPM_VECTOR_BASE << 5) |\r\nCICR_SPS;\r\npquicc->intr_cimr = 0;\r\n}\r\nstatic void\r\ncpm_interrupt(int irq, void * dev, struct pt_regs * regs)\r\n{\r\n#if 0\r\n((volatile immap_t *)IMAP_ADDR)->im_cpic.cpic_civr = 1;\r\nvec = ((volatile immap_t *)IMAP_ADDR)->im_cpic.cpic_civr;\r\nvec >>= 11;\r\nif (cpm_vecs[vec].handler != 0)\r\n(*cpm_vecs[vec].handler)(cpm_vecs[vec].dev_id);\r\nelse\r\n((immap_t *)IMAP_ADDR)->im_cpic.cpic_cimr &= ~(1 << vec);\r\n((immap_t *)IMAP_ADDR)->im_cpic.cpic_cisr |= (1 << vec);\r\n#endif\r\n}\r\nstatic void\r\ncpm_error_interrupt(void *dev)\r\n{\r\n}\r\nvoid\r\ncpm_install_handler(int vec, void (*handler)(), void *dev_id)\r\n{\r\nrequest_irq(vec, handler, 0, "timer", dev_id);\r\n}\r\nvoid\r\ncpm_free_handler(int vec)\r\n{\r\ncpm_vecs[vec].handler = NULL;\r\ncpm_vecs[vec].dev_id = NULL;\r\npquicc->intr_cimr &= ~(1 << vec);\r\n}\r\nuint\r\nm360_cpm_dpalloc(uint size)\r\n{\r\nuint retloc;\r\nif ((dp_alloc_base + size) >= dp_alloc_top)\r\nreturn(CPM_DP_NOSPACE);\r\nretloc = dp_alloc_base;\r\ndp_alloc_base += size;\r\nreturn(retloc);\r\n}\r\nvoid\r\nm360_cpm_setbrg(uint brg, uint rate)\r\n{\r\nvolatile uint *bp;\r\nbp = (volatile uint *)(&pquicc->brgc[0].l);\r\nbp += brg;\r\n*bp = ((BRG_UART_CLK / rate - 1) << 1) | CPM_BRG_EN;\r\n}
