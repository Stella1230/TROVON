static int dvb_usbv2_download_firmware(struct dvb_usb_device *d,\r\nconst char *name)\r\n{\r\nint ret;\r\nconst struct firmware *fw;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (!d->props->download_firmware) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = request_firmware(&fw, name, &d->udev->dev);\r\nif (ret < 0) {\r\ndev_err(&d->udev->dev,\r\n"%s: Did not find the firmware file '%s'. Please see linux/Documentation/dvb/ for more details on firmware-problems. Status %d\n",\r\nKBUILD_MODNAME, name, ret);\r\ngoto err;\r\n}\r\ndev_info(&d->udev->dev, "%s: downloading firmware from file '%s'\n",\r\nKBUILD_MODNAME, name);\r\nret = d->props->download_firmware(d, fw);\r\nrelease_firmware(fw);\r\nif (ret < 0)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_i2c_init(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (!d->props->i2c_algo)\r\nreturn 0;\r\nstrlcpy(d->i2c_adap.name, d->name, sizeof(d->i2c_adap.name));\r\nd->i2c_adap.algo = d->props->i2c_algo;\r\nd->i2c_adap.dev.parent = &d->udev->dev;\r\ni2c_set_adapdata(&d->i2c_adap, d);\r\nret = i2c_add_adapter(&d->i2c_adap);\r\nif (ret < 0) {\r\nd->i2c_adap.algo = NULL;\r\ndev_err(&d->udev->dev, "%s: i2c_add_adapter() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_i2c_exit(struct dvb_usb_device *d)\r\n{\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (d->i2c_adap.algo)\r\ni2c_del_adapter(&d->i2c_adap);\r\nreturn 0;\r\n}\r\nstatic void dvb_usb_read_remote_control(struct work_struct *work)\r\n{\r\nstruct dvb_usb_device *d = container_of(work,\r\nstruct dvb_usb_device, rc_query_work.work);\r\nint ret;\r\nif (dvb_usbv2_disable_rc_polling || d->rc.bulk_mode) {\r\nd->rc_polling_active = false;\r\nreturn;\r\n}\r\nret = d->rc.query(d);\r\nif (ret < 0) {\r\ndev_err(&d->udev->dev, "%s: rc.query() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\nd->rc_polling_active = false;\r\nreturn;\r\n}\r\nschedule_delayed_work(&d->rc_query_work,\r\nmsecs_to_jiffies(d->rc.interval));\r\n}\r\nstatic int dvb_usbv2_remote_init(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nstruct rc_dev *dev;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (dvb_usbv2_disable_rc_polling || !d->props->get_rc_config)\r\nreturn 0;\r\nd->rc.map_name = d->rc_map;\r\nret = d->props->get_rc_config(d, &d->rc);\r\nif (ret < 0)\r\ngoto err;\r\nif (!d->rc.map_name)\r\nreturn 0;\r\ndev = rc_allocate_device();\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->dev.parent = &d->udev->dev;\r\ndev->input_name = d->name;\r\nusb_make_path(d->udev, d->rc_phys, sizeof(d->rc_phys));\r\nstrlcat(d->rc_phys, "/ir0", sizeof(d->rc_phys));\r\ndev->input_phys = d->rc_phys;\r\nusb_to_input_id(d->udev, &dev->input_id);\r\ndev->driver_name = (char *) d->props->driver_name;\r\ndev->map_name = d->rc.map_name;\r\ndev->driver_type = d->rc.driver_type;\r\ndev->allowed_protos = d->rc.allowed_protos;\r\ndev->change_protocol = d->rc.change_protocol;\r\ndev->priv = d;\r\nret = rc_register_device(dev);\r\nif (ret < 0) {\r\nrc_free_device(dev);\r\ngoto err;\r\n}\r\nd->rc_dev = dev;\r\nif (d->rc.query && !d->rc.bulk_mode) {\r\nINIT_DELAYED_WORK(&d->rc_query_work,\r\ndvb_usb_read_remote_control);\r\ndev_info(&d->udev->dev,\r\n"%s: schedule remote query interval to %d msecs\n",\r\nKBUILD_MODNAME, d->rc.interval);\r\nschedule_delayed_work(&d->rc_query_work,\r\nmsecs_to_jiffies(d->rc.interval));\r\nd->rc_polling_active = true;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_remote_exit(struct dvb_usb_device *d)\r\n{\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (d->rc_dev) {\r\ncancel_delayed_work_sync(&d->rc_query_work);\r\nrc_unregister_device(d->rc_dev);\r\nd->rc_dev = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dvb_usb_data_complete(struct usb_data_stream *stream, u8 *buf,\r\nsize_t len)\r\n{\r\nstruct dvb_usb_adapter *adap = stream->user_priv;\r\ndvb_dmx_swfilter(&adap->demux, buf, len);\r\n}\r\nstatic void dvb_usb_data_complete_204(struct usb_data_stream *stream, u8 *buf,\r\nsize_t len)\r\n{\r\nstruct dvb_usb_adapter *adap = stream->user_priv;\r\ndvb_dmx_swfilter_204(&adap->demux, buf, len);\r\n}\r\nstatic void dvb_usb_data_complete_raw(struct usb_data_stream *stream, u8 *buf,\r\nsize_t len)\r\n{\r\nstruct dvb_usb_adapter *adap = stream->user_priv;\r\ndvb_dmx_swfilter_raw(&adap->demux, buf, len);\r\n}\r\nstatic int dvb_usbv2_adapter_stream_init(struct dvb_usb_adapter *adap)\r\n{\r\ndev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,\r\nadap->id);\r\nadap->stream.udev = adap_to_d(adap)->udev;\r\nadap->stream.user_priv = adap;\r\nadap->stream.complete = dvb_usb_data_complete;\r\nreturn usb_urb_initv2(&adap->stream, &adap->props->stream);\r\n}\r\nstatic int dvb_usbv2_adapter_stream_exit(struct dvb_usb_adapter *adap)\r\n{\r\ndev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,\r\nadap->id);\r\nreturn usb_urb_exitv2(&adap->stream);\r\n}\r\nstatic int wait_schedule(void *ptr)\r\n{\r\nschedule();\r\nreturn 0;\r\n}\r\nstatic int dvb_usb_start_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\nstruct usb_data_stream_properties stream_props;\r\ndev_dbg(&d->udev->dev,\r\n"%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d\n",\r\n__func__, adap->id, adap->active_fe, dvbdmxfeed->type,\r\nadap->pid_filtering ? "yes" : "no", dvbdmxfeed->pid,\r\ndvbdmxfeed->pid, dvbdmxfeed->index);\r\nwait_on_bit(&adap->state_bits, ADAP_INIT, wait_schedule,\r\nTASK_UNINTERRUPTIBLE);\r\nif (adap->active_fe == -1)\r\nreturn -EINVAL;\r\nif (adap->feed_count++ > 0)\r\ngoto skip_feed_start;\r\nset_bit(ADAP_STREAMING, &adap->state_bits);\r\nif (d->props->get_stream_config) {\r\nmemcpy(&stream_props, &adap->props->stream,\r\nsizeof(struct usb_data_stream_properties));\r\nret = d->props->get_stream_config(adap->fe[adap->active_fe],\r\n&adap->ts_type, &stream_props);\r\nif (ret)\r\ndev_err(&d->udev->dev,\r\n"%s: get_stream_config() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n} else {\r\nstream_props = adap->props->stream;\r\n}\r\nswitch (adap->ts_type) {\r\ncase DVB_USB_FE_TS_TYPE_204:\r\nadap->stream.complete = dvb_usb_data_complete_204;\r\nbreak;\r\ncase DVB_USB_FE_TS_TYPE_RAW:\r\nadap->stream.complete = dvb_usb_data_complete_raw;\r\nbreak;\r\ncase DVB_USB_FE_TS_TYPE_188:\r\ndefault:\r\nadap->stream.complete = dvb_usb_data_complete;\r\nbreak;\r\n}\r\nusb_urb_submitv2(&adap->stream, &stream_props);\r\nif (adap->pid_filtering && adap->props->pid_filter_ctrl) {\r\nret = adap->props->pid_filter_ctrl(adap, 1);\r\nif (ret)\r\ndev_err(&d->udev->dev,\r\n"%s: pid_filter_ctrl() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n}\r\nif (d->props->streaming_ctrl) {\r\nret = d->props->streaming_ctrl(adap->fe[adap->active_fe], 1);\r\nif (ret)\r\ndev_err(&d->udev->dev,\r\n"%s: streaming_ctrl() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n}\r\nskip_feed_start:\r\nif (adap->pid_filtering && adap->props->pid_filter) {\r\nret = adap->props->pid_filter(adap, dvbdmxfeed->index,\r\ndvbdmxfeed->pid, 1);\r\nif (ret)\r\ndev_err(&d->udev->dev, "%s: pid_filter() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n}\r\nif (ret)\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usb_stop_feed(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nstruct dvb_usb_adapter *adap = dvbdmxfeed->demux->priv;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\ndev_dbg(&d->udev->dev,\r\n"%s: adap=%d active_fe=%d feed_type=%d setting pid [%s]: %04x (%04d) at index %d\n",\r\n__func__, adap->id, adap->active_fe, dvbdmxfeed->type,\r\nadap->pid_filtering ? "yes" : "no", dvbdmxfeed->pid,\r\ndvbdmxfeed->pid, dvbdmxfeed->index);\r\nif (adap->active_fe == -1)\r\nreturn -EINVAL;\r\nif (adap->pid_filtering && adap->props->pid_filter) {\r\nret = adap->props->pid_filter(adap, dvbdmxfeed->index,\r\ndvbdmxfeed->pid, 0);\r\nif (ret)\r\ndev_err(&d->udev->dev, "%s: pid_filter() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n}\r\nif (--adap->feed_count > 0)\r\ngoto skip_feed_stop;\r\nif (d->props->streaming_ctrl) {\r\nret = d->props->streaming_ctrl(adap->fe[adap->active_fe], 0);\r\nif (ret)\r\ndev_err(&d->udev->dev,\r\n"%s: streaming_ctrl() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n}\r\nif (adap->pid_filtering && adap->props->pid_filter_ctrl) {\r\nret = adap->props->pid_filter_ctrl(adap, 0);\r\nif (ret)\r\ndev_err(&d->udev->dev,\r\n"%s: pid_filter_ctrl() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\n}\r\nusb_urb_killv2(&adap->stream);\r\nclear_bit(ADAP_STREAMING, &adap->state_bits);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(&adap->state_bits, ADAP_STREAMING);\r\nskip_feed_stop:\r\nif (ret)\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_adapter_dvb_init(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, adap->id);\r\nret = dvb_register_adapter(&adap->dvb_adap, d->name, d->props->owner,\r\n&d->udev->dev, d->props->adapter_nr);\r\nif (ret < 0) {\r\ndev_dbg(&d->udev->dev, "%s: dvb_register_adapter() failed=%d\n",\r\n__func__, ret);\r\ngoto err_dvb_register_adapter;\r\n}\r\nadap->dvb_adap.priv = adap;\r\nif (d->props->read_mac_address) {\r\nret = d->props->read_mac_address(adap,\r\nadap->dvb_adap.proposed_mac);\r\nif (ret < 0)\r\ngoto err_dvb_dmx_init;\r\ndev_info(&d->udev->dev, "%s: MAC address: %pM\n",\r\nKBUILD_MODNAME, adap->dvb_adap.proposed_mac);\r\n}\r\nadap->demux.dmx.capabilities = DMX_TS_FILTERING | DMX_SECTION_FILTERING;\r\nadap->demux.priv = adap;\r\nadap->demux.filternum = 0;\r\nadap->demux.filternum = adap->max_feed_count;\r\nadap->demux.feednum = adap->demux.filternum;\r\nadap->demux.start_feed = dvb_usb_start_feed;\r\nadap->demux.stop_feed = dvb_usb_stop_feed;\r\nadap->demux.write_to_decoder = NULL;\r\nret = dvb_dmx_init(&adap->demux);\r\nif (ret < 0) {\r\ndev_err(&d->udev->dev, "%s: dvb_dmx_init() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto err_dvb_dmx_init;\r\n}\r\nadap->dmxdev.filternum = adap->demux.filternum;\r\nadap->dmxdev.demux = &adap->demux.dmx;\r\nadap->dmxdev.capabilities = 0;\r\nret = dvb_dmxdev_init(&adap->dmxdev, &adap->dvb_adap);\r\nif (ret < 0) {\r\ndev_err(&d->udev->dev, "%s: dvb_dmxdev_init() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto err_dvb_dmxdev_init;\r\n}\r\nret = dvb_net_init(&adap->dvb_adap, &adap->dvb_net, &adap->demux.dmx);\r\nif (ret < 0) {\r\ndev_err(&d->udev->dev, "%s: dvb_net_init() failed=%d\n",\r\nKBUILD_MODNAME, ret);\r\ngoto err_dvb_net_init;\r\n}\r\nreturn 0;\r\nerr_dvb_net_init:\r\ndvb_dmxdev_release(&adap->dmxdev);\r\nerr_dvb_dmxdev_init:\r\ndvb_dmx_release(&adap->demux);\r\nerr_dvb_dmx_init:\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\nerr_dvb_register_adapter:\r\nadap->dvb_adap.priv = NULL;\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_adapter_dvb_exit(struct dvb_usb_adapter *adap)\r\n{\r\ndev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,\r\nadap->id);\r\nif (adap->dvb_adap.priv) {\r\ndvb_net_release(&adap->dvb_net);\r\nadap->demux.dmx.close(&adap->demux.dmx);\r\ndvb_dmxdev_release(&adap->dmxdev);\r\ndvb_dmx_release(&adap->demux);\r\ndvb_unregister_adapter(&adap->dvb_adap);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usbv2_device_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\nif (onoff)\r\nd->powered++;\r\nelse\r\nd->powered--;\r\nif (d->powered == 0 || (onoff && d->powered == 1)) {\r\ndev_dbg(&d->udev->dev, "%s: power=%d\n", __func__, onoff);\r\nif (d->props->power_ctrl) {\r\nret = d->props->power_ctrl(d, onoff);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usb_fe_init(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,\r\nfe->id);\r\nif (!adap->suspend_resume_active) {\r\nadap->active_fe = fe->id;\r\nset_bit(ADAP_INIT, &adap->state_bits);\r\n}\r\nret = dvb_usbv2_device_power_ctrl(d, 1);\r\nif (ret < 0)\r\ngoto err;\r\nif (d->props->frontend_ctrl) {\r\nret = d->props->frontend_ctrl(fe, 1);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (adap->fe_init[fe->id]) {\r\nret = adap->fe_init[fe->id](fe);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nerr:\r\nif (!adap->suspend_resume_active) {\r\nclear_bit(ADAP_INIT, &adap->state_bits);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(&adap->state_bits, ADAP_INIT);\r\n}\r\ndev_dbg(&d->udev->dev, "%s: ret=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usb_fe_sleep(struct dvb_frontend *fe)\r\n{\r\nint ret;\r\nstruct dvb_usb_adapter *adap = fe->dvb->priv;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s: adap=%d fe=%d\n", __func__, adap->id,\r\nfe->id);\r\nif (!adap->suspend_resume_active) {\r\nset_bit(ADAP_SLEEP, &adap->state_bits);\r\nwait_on_bit(&adap->state_bits, ADAP_STREAMING, wait_schedule,\r\nTASK_UNINTERRUPTIBLE);\r\n}\r\nif (adap->fe_sleep[fe->id]) {\r\nret = adap->fe_sleep[fe->id](fe);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (d->props->frontend_ctrl) {\r\nret = d->props->frontend_ctrl(fe, 0);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nret = dvb_usbv2_device_power_ctrl(d, 0);\r\nif (ret < 0)\r\ngoto err;\r\nerr:\r\nif (!adap->suspend_resume_active) {\r\nadap->active_fe = -1;\r\nclear_bit(ADAP_SLEEP, &adap->state_bits);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(&adap->state_bits, ADAP_SLEEP);\r\n}\r\ndev_dbg(&d->udev->dev, "%s: ret=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_adapter_frontend_init(struct dvb_usb_adapter *adap)\r\n{\r\nint ret, i, count_registered = 0;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\ndev_dbg(&d->udev->dev, "%s: adap=%d\n", __func__, adap->id);\r\nmemset(adap->fe, 0, sizeof(adap->fe));\r\nadap->active_fe = -1;\r\nif (d->props->frontend_attach) {\r\nret = d->props->frontend_attach(adap);\r\nif (ret < 0) {\r\ndev_dbg(&d->udev->dev,\r\n"%s: frontend_attach() failed=%d\n",\r\n__func__, ret);\r\ngoto err_dvb_frontend_detach;\r\n}\r\n} else {\r\ndev_dbg(&d->udev->dev, "%s: frontend_attach() do not exists\n",\r\n__func__);\r\nret = 0;\r\ngoto err;\r\n}\r\nfor (i = 0; i < MAX_NO_OF_FE_PER_ADAP && adap->fe[i]; i++) {\r\nadap->fe[i]->id = i;\r\nadap->fe_init[i] = adap->fe[i]->ops.init;\r\nadap->fe[i]->ops.init = dvb_usb_fe_init;\r\nadap->fe_sleep[i] = adap->fe[i]->ops.sleep;\r\nadap->fe[i]->ops.sleep = dvb_usb_fe_sleep;\r\nret = dvb_register_frontend(&adap->dvb_adap, adap->fe[i]);\r\nif (ret < 0) {\r\ndev_err(&d->udev->dev,\r\n"%s: frontend%d registration failed\n",\r\nKBUILD_MODNAME, i);\r\ngoto err_dvb_unregister_frontend;\r\n}\r\ncount_registered++;\r\n}\r\nif (d->props->tuner_attach) {\r\nret = d->props->tuner_attach(adap);\r\nif (ret < 0) {\r\ndev_dbg(&d->udev->dev, "%s: tuner_attach() failed=%d\n",\r\n__func__, ret);\r\ngoto err_dvb_unregister_frontend;\r\n}\r\n}\r\nreturn 0;\r\nerr_dvb_unregister_frontend:\r\nfor (i = count_registered - 1; i >= 0; i--)\r\ndvb_unregister_frontend(adap->fe[i]);\r\nerr_dvb_frontend_detach:\r\nfor (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {\r\nif (adap->fe[i]) {\r\ndvb_frontend_detach(adap->fe[i]);\r\nadap->fe[i] = NULL;\r\n}\r\n}\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_adapter_frontend_exit(struct dvb_usb_adapter *adap)\r\n{\r\nint i;\r\ndev_dbg(&adap_to_d(adap)->udev->dev, "%s: adap=%d\n", __func__,\r\nadap->id);\r\nfor (i = MAX_NO_OF_FE_PER_ADAP - 1; i >= 0; i--) {\r\nif (adap->fe[i]) {\r\ndvb_unregister_frontend(adap->fe[i]);\r\ndvb_frontend_detach(adap->fe[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usbv2_adapter_init(struct dvb_usb_device *d)\r\n{\r\nstruct dvb_usb_adapter *adap;\r\nint ret, i, adapter_count;\r\nadapter_count = d->props->num_adapters;\r\nif (d->props->get_adapter_count) {\r\nret = d->props->get_adapter_count(d);\r\nif (ret < 0)\r\ngoto err;\r\nadapter_count = ret;\r\n}\r\nfor (i = 0; i < adapter_count; i++) {\r\nadap = &d->adapter[i];\r\nadap->id = i;\r\nadap->props = &d->props->adapter[i];\r\nif (d->udev->speed == USB_SPEED_FULL &&\r\n!(adap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER)) {\r\ndev_err(&d->udev->dev,\r\n"%s: this USB2.0 device cannot be run on a USB1.1 port (it lacks a hardware PID filter)\n",\r\nKBUILD_MODNAME);\r\nret = -ENODEV;\r\ngoto err;\r\n} else if ((d->udev->speed == USB_SPEED_FULL &&\r\nadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) ||\r\n(adap->props->caps & DVB_USB_ADAP_NEED_PID_FILTERING)) {\r\ndev_info(&d->udev->dev,\r\n"%s: will use the device's hardware PID filter (table count: %d)\n",\r\nKBUILD_MODNAME,\r\nadap->props->pid_filter_count);\r\nadap->pid_filtering = 1;\r\nadap->max_feed_count = adap->props->pid_filter_count;\r\n} else {\r\ndev_info(&d->udev->dev,\r\n"%s: will pass the complete MPEG2 transport stream to the software demuxer\n",\r\nKBUILD_MODNAME);\r\nadap->pid_filtering = 0;\r\nadap->max_feed_count = 255;\r\n}\r\nif (!adap->pid_filtering && dvb_usb_force_pid_filter_usage &&\r\nadap->props->caps & DVB_USB_ADAP_HAS_PID_FILTER) {\r\ndev_info(&d->udev->dev,\r\n"%s: PID filter enabled by module option\n",\r\nKBUILD_MODNAME);\r\nadap->pid_filtering = 1;\r\nadap->max_feed_count = adap->props->pid_filter_count;\r\n}\r\nret = dvb_usbv2_adapter_stream_init(adap);\r\nif (ret)\r\ngoto err;\r\nret = dvb_usbv2_adapter_dvb_init(adap);\r\nif (ret)\r\ngoto err;\r\nret = dvb_usbv2_adapter_frontend_init(adap);\r\nif (ret)\r\ngoto err;\r\nif (adap->fe[1])\r\nadap->dvb_adap.mfe_shared = 1;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_adapter_exit(struct dvb_usb_device *d)\r\n{\r\nint i;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nfor (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {\r\nif (d->adapter[i].props) {\r\ndvb_usbv2_adapter_frontend_exit(&d->adapter[i]);\r\ndvb_usbv2_adapter_dvb_exit(&d->adapter[i]);\r\ndvb_usbv2_adapter_stream_exit(&d->adapter[i]);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_usbv2_exit(struct dvb_usb_device *d)\r\n{\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\ndvb_usbv2_remote_exit(d);\r\ndvb_usbv2_adapter_exit(d);\r\ndvb_usbv2_i2c_exit(d);\r\nkfree(d->priv);\r\nkfree(d);\r\nreturn 0;\r\n}\r\nstatic int dvb_usbv2_init(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\ndvb_usbv2_device_power_ctrl(d, 1);\r\nif (d->props->read_config) {\r\nret = d->props->read_config(d);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nret = dvb_usbv2_i2c_init(d);\r\nif (ret < 0)\r\ngoto err;\r\nret = dvb_usbv2_adapter_init(d);\r\nif (ret < 0)\r\ngoto err;\r\nif (d->props->init) {\r\nret = d->props->init(d);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nret = dvb_usbv2_remote_init(d);\r\nif (ret < 0)\r\ngoto err;\r\ndvb_usbv2_device_power_ctrl(d, 0);\r\nreturn 0;\r\nerr:\r\ndvb_usbv2_device_power_ctrl(d, 0);\r\ndev_dbg(&d->udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nint dvb_usbv2_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d;\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nstruct dvb_usb_driver_info *driver_info =\r\n(struct dvb_usb_driver_info *) id->driver_info;\r\ndev_dbg(&udev->dev, "%s: bInterfaceNumber=%d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (!id->driver_info) {\r\ndev_err(&udev->dev, "%s: driver_info failed\n", KBUILD_MODNAME);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nd = kzalloc(sizeof(struct dvb_usb_device), GFP_KERNEL);\r\nif (!d) {\r\ndev_err(&udev->dev, "%s: kzalloc() failed\n", KBUILD_MODNAME);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nd->name = driver_info->name;\r\nd->rc_map = driver_info->rc_map;\r\nd->udev = udev;\r\nd->props = driver_info->props;\r\nif (intf->cur_altsetting->desc.bInterfaceNumber !=\r\nd->props->bInterfaceNumber) {\r\nret = -ENODEV;\r\ngoto err_free_all;\r\n}\r\nmutex_init(&d->usb_mutex);\r\nmutex_init(&d->i2c_mutex);\r\nif (d->props->size_of_priv) {\r\nd->priv = kzalloc(d->props->size_of_priv, GFP_KERNEL);\r\nif (!d->priv) {\r\ndev_err(&d->udev->dev, "%s: kzalloc() failed\n",\r\nKBUILD_MODNAME);\r\nret = -ENOMEM;\r\ngoto err_free_all;\r\n}\r\n}\r\nif (d->props->identify_state) {\r\nconst char *name = NULL;\r\nret = d->props->identify_state(d, &name);\r\nif (ret == 0) {\r\n;\r\n} else if (ret == COLD) {\r\ndev_info(&d->udev->dev,\r\n"%s: found a '%s' in cold state\n",\r\nKBUILD_MODNAME, d->name);\r\nif (!name)\r\nname = d->props->firmware;\r\nret = dvb_usbv2_download_firmware(d, name);\r\nif (ret == 0) {\r\n;\r\n} else if (ret == RECONNECTS_USB) {\r\ngoto exit;\r\n} else {\r\ngoto err_free_all;\r\n}\r\n} else {\r\ngoto err_free_all;\r\n}\r\n}\r\ndev_info(&d->udev->dev, "%s: found a '%s' in warm state\n",\r\nKBUILD_MODNAME, d->name);\r\nret = dvb_usbv2_init(d);\r\nif (ret < 0)\r\ngoto err_free_all;\r\ndev_info(&d->udev->dev,\r\n"%s: '%s' successfully initialized and connected\n",\r\nKBUILD_MODNAME, d->name);\r\nexit:\r\nusb_set_intfdata(intf, d);\r\nreturn 0;\r\nerr_free_all:\r\ndvb_usbv2_exit(d);\r\nerr:\r\ndev_dbg(&udev->dev, "%s: failed=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nvoid dvb_usbv2_disconnect(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nconst char *name = d->name;\r\nstruct device dev = d->udev->dev;\r\ndev_dbg(&d->udev->dev, "%s: bInterfaceNumber=%d\n", __func__,\r\nintf->cur_altsetting->desc.bInterfaceNumber);\r\nif (d->props->exit)\r\nd->props->exit(d);\r\ndvb_usbv2_exit(d);\r\ndev_info(&dev, "%s: '%s' successfully deinitialized and disconnected\n",\r\nKBUILD_MODNAME, name);\r\n}\r\nint dvb_usbv2_suspend(struct usb_interface *intf, pm_message_t msg)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nint ret = 0, i, active_fe;\r\nstruct dvb_frontend *fe;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nif (d->rc_polling_active)\r\ncancel_delayed_work_sync(&d->rc_query_work);\r\nfor (i = MAX_NO_OF_ADAPTER_PER_DEVICE - 1; i >= 0; i--) {\r\nactive_fe = d->adapter[i].active_fe;\r\nif (d->adapter[i].dvb_adap.priv && active_fe != -1) {\r\nfe = d->adapter[i].fe[active_fe];\r\nd->adapter[i].suspend_resume_active = true;\r\nif (d->props->streaming_ctrl)\r\nd->props->streaming_ctrl(fe, 0);\r\nusb_urb_killv2(&d->adapter[i].stream);\r\nret = dvb_frontend_suspend(fe);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int dvb_usbv2_resume_common(struct dvb_usb_device *d)\r\n{\r\nint ret = 0, i, active_fe;\r\nstruct dvb_frontend *fe;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nfor (i = 0; i < MAX_NO_OF_ADAPTER_PER_DEVICE; i++) {\r\nactive_fe = d->adapter[i].active_fe;\r\nif (d->adapter[i].dvb_adap.priv && active_fe != -1) {\r\nfe = d->adapter[i].fe[active_fe];\r\nret = dvb_frontend_resume(fe);\r\nusb_urb_submitv2(&d->adapter[i].stream, NULL);\r\nif (d->props->streaming_ctrl)\r\nd->props->streaming_ctrl(fe, 1);\r\nd->adapter[i].suspend_resume_active = false;\r\n}\r\n}\r\nif (d->rc_polling_active)\r\nschedule_delayed_work(&d->rc_query_work,\r\nmsecs_to_jiffies(d->rc.interval));\r\nreturn ret;\r\n}\r\nint dvb_usbv2_resume(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\nreturn dvb_usbv2_resume_common(d);\r\n}\r\nint dvb_usbv2_reset_resume(struct usb_interface *intf)\r\n{\r\nstruct dvb_usb_device *d = usb_get_intfdata(intf);\r\nint ret;\r\ndev_dbg(&d->udev->dev, "%s:\n", __func__);\r\ndvb_usbv2_device_power_ctrl(d, 1);\r\nif (d->props->init)\r\nd->props->init(d);\r\nret = dvb_usbv2_resume_common(d);\r\ndvb_usbv2_device_power_ctrl(d, 0);\r\nreturn ret;\r\n}
