static int mt9m032_read(struct i2c_client *client, u8 reg)\r\n{\r\nreturn i2c_smbus_read_word_swapped(client, reg);\r\n}\r\nstatic int mt9m032_write(struct i2c_client *client, u8 reg, const u16 data)\r\n{\r\nreturn i2c_smbus_write_word_swapped(client, reg, data);\r\n}\r\nstatic u32 mt9m032_row_time(struct mt9m032 *sensor, unsigned int width)\r\n{\r\nunsigned int effective_width;\r\nu32 ns;\r\neffective_width = width + 716;\r\nns = div_u64(1000000000ULL * effective_width, sensor->pix_clock);\r\ndev_dbg(to_dev(sensor), "MT9M032 line time: %u ns\n", ns);\r\nreturn ns;\r\n}\r\nstatic int mt9m032_update_timing(struct mt9m032 *sensor,\r\nstruct v4l2_fract *interval)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nstruct v4l2_rect *crop = &sensor->crop;\r\nunsigned int min_vblank;\r\nunsigned int vblank;\r\nu32 row_time;\r\nif (!interval)\r\ninterval = &sensor->frame_interval;\r\nrow_time = mt9m032_row_time(sensor, crop->width);\r\nvblank = div_u64(1000000000ULL * interval->numerator,\r\n(u64)row_time * interval->denominator)\r\n- crop->height;\r\nif (vblank > MT9M032_VBLANK_MAX) {\r\ninterval->denominator = 1000;\r\ninterval->numerator =\r\ndiv_u64((crop->height + MT9M032_VBLANK_MAX) *\r\n(u64)row_time * interval->denominator,\r\n1000000000ULL);\r\nvblank = div_u64(1000000000ULL * interval->numerator,\r\n(u64)row_time * interval->denominator)\r\n- crop->height;\r\n}\r\nmin_vblank = 1600000 / row_time;\r\nvblank = clamp_t(unsigned int, vblank, min_vblank, MT9M032_VBLANK_MAX);\r\nreturn mt9m032_write(client, MT9M032_VBLANK, vblank);\r\n}\r\nstatic int mt9m032_update_geom_timing(struct mt9m032 *sensor)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nint ret;\r\nret = mt9m032_write(client, MT9M032_COLUMN_SIZE,\r\nsensor->crop.width - 1);\r\nif (!ret)\r\nret = mt9m032_write(client, MT9M032_ROW_SIZE,\r\nsensor->crop.height - 1);\r\nif (!ret)\r\nret = mt9m032_write(client, MT9M032_COLUMN_START,\r\nsensor->crop.left);\r\nif (!ret)\r\nret = mt9m032_write(client, MT9M032_ROW_START,\r\nsensor->crop.top);\r\nif (!ret)\r\nret = mt9m032_update_timing(sensor, NULL);\r\nreturn ret;\r\n}\r\nstatic int update_formatter2(struct mt9m032 *sensor, bool streaming)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nu16 reg_val = MT9M032_FORMATTER2_DOUT_EN\r\n| 0x0070;\r\nif (streaming)\r\nreg_val |= MT9M032_FORMATTER2_PIXCLK_EN;\r\nreturn mt9m032_write(client, MT9M032_FORMATTER2, reg_val);\r\n}\r\nstatic int mt9m032_setup_pll(struct mt9m032 *sensor)\r\n{\r\nstatic const struct aptina_pll_limits limits = {\r\n.ext_clock_min = 8000000,\r\n.ext_clock_max = 16500000,\r\n.int_clock_min = 2000000,\r\n.int_clock_max = 24000000,\r\n.out_clock_min = 322000000,\r\n.out_clock_max = 693000000,\r\n.pix_clock_max = 99000000,\r\n.n_min = 1,\r\n.n_max = 64,\r\n.m_min = 16,\r\n.m_max = 255,\r\n.p1_min = 6,\r\n.p1_max = 7,\r\n};\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nstruct mt9m032_platform_data *pdata = sensor->pdata;\r\nstruct aptina_pll pll;\r\nu16 reg_val;\r\nint ret;\r\npll.ext_clock = pdata->ext_clock;\r\npll.pix_clock = pdata->pix_clock;\r\nret = aptina_pll_calculate(&client->dev, &limits, &pll);\r\nif (ret < 0)\r\nreturn ret;\r\nsensor->pix_clock = pdata->pix_clock;\r\nret = mt9m032_write(client, MT9M032_PLL_CONFIG1,\r\n(pll.m << MT9M032_PLL_CONFIG1_MUL_SHIFT) |\r\n((pll.n - 1) & MT9M032_PLL_CONFIG1_PREDIV_MASK));\r\nif (!ret)\r\nret = mt9m032_write(client, MT9P031_PLL_CONTROL,\r\nMT9P031_PLL_CONTROL_PWRON |\r\nMT9P031_PLL_CONTROL_USEPLL);\r\nif (!ret)\r\nret = mt9m032_write(client, MT9M032_READ_MODE1, 0x8000 |\r\nMT9M032_READ_MODE1_STROBE_START_EXP |\r\nMT9M032_READ_MODE1_STROBE_END_SHUTTER);\r\nif (!ret) {\r\nreg_val = (pll.p1 == 6 ? MT9M032_FORMATTER1_PLL_P1_6 : 0)\r\n| MT9M032_FORMATTER1_PARALLEL | 0x001e;\r\nret = mt9m032_write(client, MT9M032_FORMATTER1, reg_val);\r\n}\r\nreturn ret;\r\n}\r\nstatic int mt9m032_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->index != 0)\r\nreturn -EINVAL;\r\ncode->code = V4L2_MBUS_FMT_Y8_1X8;\r\nreturn 0;\r\n}\r\nstatic int mt9m032_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nif (fse->index != 0 || fse->code != V4L2_MBUS_FMT_Y8_1X8)\r\nreturn -EINVAL;\r\nfse->min_width = MT9M032_COLUMN_SIZE_DEF;\r\nfse->max_width = MT9M032_COLUMN_SIZE_DEF;\r\nfse->min_height = MT9M032_ROW_SIZE_DEF;\r\nfse->max_height = MT9M032_ROW_SIZE_DEF;\r\nreturn 0;\r\n}\r\nstatic struct v4l2_rect *\r\n__mt9m032_get_pad_crop(struct mt9m032 *sensor, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_crop(fh, 0);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &sensor->crop;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic struct v4l2_mbus_framefmt *\r\n__mt9m032_get_pad_format(struct mt9m032 *sensor, struct v4l2_subdev_fh *fh,\r\nenum v4l2_subdev_format_whence which)\r\n{\r\nswitch (which) {\r\ncase V4L2_SUBDEV_FORMAT_TRY:\r\nreturn v4l2_subdev_get_try_format(fh, 0);\r\ncase V4L2_SUBDEV_FORMAT_ACTIVE:\r\nreturn &sensor->format;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int mt9m032_get_pad_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nmutex_lock(&sensor->lock);\r\nfmt->format = *__mt9m032_get_pad_format(sensor, fh, fmt->which);\r\nmutex_unlock(&sensor->lock);\r\nreturn 0;\r\n}\r\nstatic int mt9m032_set_pad_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nint ret;\r\nmutex_lock(&sensor->lock);\r\nif (sensor->streaming && fmt->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nfmt->format = *__mt9m032_get_pad_format(sensor, fh, fmt->which);\r\nret = 0;\r\ndone:\r\nmutex_unlock(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int mt9m032_get_pad_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nmutex_lock(&sensor->lock);\r\ncrop->rect = *__mt9m032_get_pad_crop(sensor, fh, crop->which);\r\nmutex_unlock(&sensor->lock);\r\nreturn 0;\r\n}\r\nstatic int mt9m032_set_pad_crop(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_fh *fh,\r\nstruct v4l2_subdev_crop *crop)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nstruct v4l2_mbus_framefmt *format;\r\nstruct v4l2_rect *__crop;\r\nstruct v4l2_rect rect;\r\nint ret = 0;\r\nmutex_lock(&sensor->lock);\r\nif (sensor->streaming && crop->which == V4L2_SUBDEV_FORMAT_ACTIVE) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nrect.left = clamp(ALIGN(crop->rect.left, 2), MT9M032_COLUMN_START_MIN,\r\nMT9M032_COLUMN_START_MAX);\r\nrect.top = clamp(ALIGN(crop->rect.top, 2), MT9M032_ROW_START_MIN,\r\nMT9M032_ROW_START_MAX);\r\nrect.width = clamp(ALIGN(crop->rect.width, 2), MT9M032_COLUMN_SIZE_MIN,\r\nMT9M032_COLUMN_SIZE_MAX);\r\nrect.height = clamp(ALIGN(crop->rect.height, 2), MT9M032_ROW_SIZE_MIN,\r\nMT9M032_ROW_SIZE_MAX);\r\nrect.width = min(rect.width, MT9M032_PIXEL_ARRAY_WIDTH - rect.left);\r\nrect.height = min(rect.height, MT9M032_PIXEL_ARRAY_HEIGHT - rect.top);\r\n__crop = __mt9m032_get_pad_crop(sensor, fh, crop->which);\r\nif (rect.width != __crop->width || rect.height != __crop->height) {\r\nformat = __mt9m032_get_pad_format(sensor, fh, crop->which);\r\nformat->width = rect.width;\r\nformat->height = rect.height;\r\n}\r\n*__crop = rect;\r\ncrop->rect = rect;\r\nif (crop->which == V4L2_SUBDEV_FORMAT_ACTIVE)\r\nret = mt9m032_update_geom_timing(sensor);\r\ndone:\r\nmutex_unlock(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int mt9m032_get_frame_interval(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nmutex_lock(&sensor->lock);\r\nmemset(fi, 0, sizeof(*fi));\r\nfi->interval = sensor->frame_interval;\r\nmutex_unlock(&sensor->lock);\r\nreturn 0;\r\n}\r\nstatic int mt9m032_set_frame_interval(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_frame_interval *fi)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nint ret;\r\nmutex_lock(&sensor->lock);\r\nif (sensor->streaming) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nif (fi->interval.denominator == 0)\r\nfi->interval.denominator = 1;\r\nret = mt9m032_update_timing(sensor, &fi->interval);\r\nif (!ret)\r\nsensor->frame_interval = fi->interval;\r\ndone:\r\nmutex_unlock(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int mt9m032_s_stream(struct v4l2_subdev *subdev, int streaming)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nint ret;\r\nmutex_lock(&sensor->lock);\r\nret = update_formatter2(sensor, streaming);\r\nif (!ret)\r\nsensor->streaming = streaming;\r\nmutex_unlock(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int mt9m032_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nint val;\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nval = mt9m032_read(client, reg->reg);\r\nif (val < 0)\r\nreturn -EIO;\r\nreg->size = 2;\r\nreg->val = val;\r\nreturn 0;\r\n}\r\nstatic int mt9m032_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct mt9m032 *sensor = to_mt9m032(sd);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nif (reg->reg > 0xff)\r\nreturn -EINVAL;\r\nreturn mt9m032_write(client, reg->reg, reg->val);\r\n}\r\nstatic int update_read_mode2(struct mt9m032 *sensor, bool vflip, bool hflip)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nint reg_val = (vflip << MT9M032_READ_MODE2_VFLIP_SHIFT)\r\n| (hflip << MT9M032_READ_MODE2_HFLIP_SHIFT)\r\n| MT9M032_READ_MODE2_ROW_BLC\r\n| 0x0007;\r\nreturn mt9m032_write(client, MT9M032_READ_MODE2, reg_val);\r\n}\r\nstatic int mt9m032_set_gain(struct mt9m032 *sensor, s32 val)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nint digital_gain_val;\r\nint analog_mul;\r\nint analog_gain_val;\r\nu16 reg_val;\r\ndigital_gain_val = 51;\r\nif (val < 63) {\r\nanalog_mul = 0;\r\nanalog_gain_val = val;\r\n} else {\r\nanalog_mul = 1;\r\nanalog_gain_val = val / 2;\r\n}\r\nreg_val = ((digital_gain_val & MT9M032_GAIN_DIGITAL_MASK)\r\n<< MT9M032_GAIN_DIGITAL_SHIFT)\r\n| ((analog_mul & 1) << MT9M032_GAIN_AMUL_SHIFT)\r\n| (analog_gain_val & MT9M032_GAIN_ANALOG_MASK);\r\nreturn mt9m032_write(client, MT9M032_GAIN_ALL, reg_val);\r\n}\r\nstatic int mt9m032_try_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nif (ctrl->id == V4L2_CID_GAIN && ctrl->val >= 63) {\r\nctrl->val &= ~1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9m032_set_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mt9m032 *sensor =\r\ncontainer_of(ctrl->handler, struct mt9m032, ctrls);\r\nstruct i2c_client *client = v4l2_get_subdevdata(&sensor->subdev);\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_GAIN:\r\nreturn mt9m032_set_gain(sensor, ctrl->val);\r\ncase V4L2_CID_HFLIP:\r\nreturn update_read_mode2(sensor, sensor->vflip->val,\r\nsensor->hflip->val);\r\ncase V4L2_CID_EXPOSURE:\r\nret = mt9m032_write(client, MT9M032_SHUTTER_WIDTH_HIGH,\r\n(ctrl->val >> 16) & 0xffff);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn mt9m032_write(client, MT9M032_SHUTTER_WIDTH_LOW,\r\nctrl->val & 0xffff);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt9m032_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *devid)\r\n{\r\nstruct mt9m032_platform_data *pdata = client->dev.platform_data;\r\nstruct i2c_adapter *adapter = client->adapter;\r\nstruct mt9m032 *sensor;\r\nint chip_version;\r\nint ret;\r\nif (pdata == NULL) {\r\ndev_err(&client->dev, "No platform data\n");\r\nreturn -EINVAL;\r\n}\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_warn(&client->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nif (!client->dev.platform_data)\r\nreturn -ENODEV;\r\nsensor = devm_kzalloc(&client->dev, sizeof(*sensor), GFP_KERNEL);\r\nif (sensor == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&sensor->lock);\r\nsensor->pdata = pdata;\r\nv4l2_i2c_subdev_init(&sensor->subdev, client, &mt9m032_ops);\r\nsensor->subdev.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;\r\nchip_version = mt9m032_read(client, MT9M032_CHIP_VERSION);\r\nif (chip_version != MT9M032_CHIP_VERSION_VALUE) {\r\ndev_err(&client->dev, "MT9M032 not detected, wrong version "\r\n"0x%04x\n", chip_version);\r\nret = -ENODEV;\r\ngoto error_sensor;\r\n}\r\ndev_info(&client->dev, "MT9M032 detected at address 0x%02x\n",\r\nclient->addr);\r\nsensor->frame_interval.numerator = 1;\r\nsensor->frame_interval.denominator = 30;\r\nsensor->crop.left = MT9M032_COLUMN_START_DEF;\r\nsensor->crop.top = MT9M032_ROW_START_DEF;\r\nsensor->crop.width = MT9M032_COLUMN_SIZE_DEF;\r\nsensor->crop.height = MT9M032_ROW_SIZE_DEF;\r\nsensor->format.width = sensor->crop.width;\r\nsensor->format.height = sensor->crop.height;\r\nsensor->format.code = V4L2_MBUS_FMT_Y8_1X8;\r\nsensor->format.field = V4L2_FIELD_NONE;\r\nsensor->format.colorspace = V4L2_COLORSPACE_SRGB;\r\nv4l2_ctrl_handler_init(&sensor->ctrls, 5);\r\nv4l2_ctrl_new_std(&sensor->ctrls, &mt9m032_ctrl_ops,\r\nV4L2_CID_GAIN, 0, 127, 1, 64);\r\nsensor->hflip = v4l2_ctrl_new_std(&sensor->ctrls,\r\n&mt9m032_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsensor->vflip = v4l2_ctrl_new_std(&sensor->ctrls,\r\n&mt9m032_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nv4l2_ctrl_new_std(&sensor->ctrls, &mt9m032_ctrl_ops,\r\nV4L2_CID_EXPOSURE, MT9M032_SHUTTER_WIDTH_MIN,\r\nMT9M032_SHUTTER_WIDTH_MAX, 1,\r\nMT9M032_SHUTTER_WIDTH_DEF);\r\nv4l2_ctrl_new_std(&sensor->ctrls, &mt9m032_ctrl_ops,\r\nV4L2_CID_PIXEL_RATE, pdata->pix_clock,\r\npdata->pix_clock, 1, pdata->pix_clock);\r\nif (sensor->ctrls.error) {\r\nret = sensor->ctrls.error;\r\ndev_err(&client->dev, "control initialization error %d\n", ret);\r\ngoto error_ctrl;\r\n}\r\nv4l2_ctrl_cluster(2, &sensor->hflip);\r\nsensor->subdev.ctrl_handler = &sensor->ctrls;\r\nsensor->pad.flags = MEDIA_PAD_FL_SOURCE;\r\nret = media_entity_init(&sensor->subdev.entity, 1, &sensor->pad, 0);\r\nif (ret < 0)\r\ngoto error_ctrl;\r\nret = mt9m032_write(client, MT9M032_RESET, 1);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_write(client, MT9M032_RESET, 0);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_setup_pll(sensor);\r\nif (ret < 0)\r\ngoto error_entity;\r\nusleep_range(10000, 11000);\r\nret = v4l2_ctrl_handler_setup(&sensor->ctrls);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_update_geom_timing(sensor);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_write(client, 0x41, 0x0000);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_write(client, 0x42, 0x0003);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_write(client, 0x43, 0x0003);\r\nif (ret < 0)\r\ngoto error_entity;\r\nret = mt9m032_write(client, 0x7f, 0x0000);\r\nif (ret < 0)\r\ngoto error_entity;\r\nif (sensor->pdata->invert_pixclock) {\r\nret = mt9m032_write(client, MT9M032_PIX_CLK_CTRL,\r\nMT9M032_PIX_CLK_CTRL_INV_PIXCLK);\r\nif (ret < 0)\r\ngoto error_entity;\r\n}\r\nret = mt9m032_write(client, MT9M032_RESTART, 1);\r\nif (ret < 0)\r\ngoto error_entity;\r\nmsleep(100);\r\nret = mt9m032_write(client, MT9M032_RESTART, 0);\r\nif (ret < 0)\r\ngoto error_entity;\r\nmsleep(100);\r\nret = update_formatter2(sensor, false);\r\nif (ret < 0)\r\ngoto error_entity;\r\nreturn ret;\r\nerror_entity:\r\nmedia_entity_cleanup(&sensor->subdev.entity);\r\nerror_ctrl:\r\nv4l2_ctrl_handler_free(&sensor->ctrls);\r\nerror_sensor:\r\nmutex_destroy(&sensor->lock);\r\nreturn ret;\r\n}\r\nstatic int mt9m032_remove(struct i2c_client *client)\r\n{\r\nstruct v4l2_subdev *subdev = i2c_get_clientdata(client);\r\nstruct mt9m032 *sensor = to_mt9m032(subdev);\r\nv4l2_device_unregister_subdev(subdev);\r\nv4l2_ctrl_handler_free(&sensor->ctrls);\r\nmedia_entity_cleanup(&subdev->entity);\r\nmutex_destroy(&sensor->lock);\r\nreturn 0;\r\n}
