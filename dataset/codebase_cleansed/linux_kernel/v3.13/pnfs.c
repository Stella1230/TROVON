static struct pnfs_layoutdriver_type *\r\nfind_pnfs_driver_locked(u32 id)\r\n{\r\nstruct pnfs_layoutdriver_type *local;\r\nlist_for_each_entry(local, &pnfs_modules_tbl, pnfs_tblid)\r\nif (local->id == id)\r\ngoto out;\r\nlocal = NULL;\r\nout:\r\ndprintk("%s: Searching for id %u, found %p\n", __func__, id, local);\r\nreturn local;\r\n}\r\nstatic struct pnfs_layoutdriver_type *\r\nfind_pnfs_driver(u32 id)\r\n{\r\nstruct pnfs_layoutdriver_type *local;\r\nspin_lock(&pnfs_spinlock);\r\nlocal = find_pnfs_driver_locked(id);\r\nif (local != NULL && !try_module_get(local->owner)) {\r\ndprintk("%s: Could not grab reference on module\n", __func__);\r\nlocal = NULL;\r\n}\r\nspin_unlock(&pnfs_spinlock);\r\nreturn local;\r\n}\r\nvoid\r\nunset_pnfs_layoutdriver(struct nfs_server *nfss)\r\n{\r\nif (nfss->pnfs_curr_ld) {\r\nif (nfss->pnfs_curr_ld->clear_layoutdriver)\r\nnfss->pnfs_curr_ld->clear_layoutdriver(nfss);\r\nif (atomic_dec_and_test(&nfss->nfs_client->cl_mds_count))\r\nnfs4_deviceid_purge_client(nfss->nfs_client);\r\nmodule_put(nfss->pnfs_curr_ld->owner);\r\n}\r\nnfss->pnfs_curr_ld = NULL;\r\n}\r\nvoid\r\nset_pnfs_layoutdriver(struct nfs_server *server, const struct nfs_fh *mntfh,\r\nu32 id)\r\n{\r\nstruct pnfs_layoutdriver_type *ld_type = NULL;\r\nif (id == 0)\r\ngoto out_no_driver;\r\nif (!(server->nfs_client->cl_exchange_flags &\r\n(EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_PNFS_MDS))) {\r\nprintk(KERN_ERR "NFS: %s: id %u cl_exchange_flags 0x%x\n",\r\n__func__, id, server->nfs_client->cl_exchange_flags);\r\ngoto out_no_driver;\r\n}\r\nld_type = find_pnfs_driver(id);\r\nif (!ld_type) {\r\nrequest_module("%s-%u", LAYOUT_NFSV4_1_MODULE_PREFIX, id);\r\nld_type = find_pnfs_driver(id);\r\nif (!ld_type) {\r\ndprintk("%s: No pNFS module found for %u.\n",\r\n__func__, id);\r\ngoto out_no_driver;\r\n}\r\n}\r\nserver->pnfs_curr_ld = ld_type;\r\nif (ld_type->set_layoutdriver\r\n&& ld_type->set_layoutdriver(server, mntfh)) {\r\nprintk(KERN_ERR "NFS: %s: Error initializing pNFS layout "\r\n"driver %u.\n", __func__, id);\r\nmodule_put(ld_type->owner);\r\ngoto out_no_driver;\r\n}\r\natomic_inc(&server->nfs_client->cl_mds_count);\r\ndprintk("%s: pNFS module for %u set\n", __func__, id);\r\nreturn;\r\nout_no_driver:\r\ndprintk("%s: Using NFSv4 I/O\n", __func__);\r\nserver->pnfs_curr_ld = NULL;\r\n}\r\nint\r\npnfs_register_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\r\n{\r\nint status = -EINVAL;\r\nstruct pnfs_layoutdriver_type *tmp;\r\nif (ld_type->id == 0) {\r\nprintk(KERN_ERR "NFS: %s id 0 is reserved\n", __func__);\r\nreturn status;\r\n}\r\nif (!ld_type->alloc_lseg || !ld_type->free_lseg) {\r\nprintk(KERN_ERR "NFS: %s Layout driver must provide "\r\n"alloc_lseg and free_lseg.\n", __func__);\r\nreturn status;\r\n}\r\nspin_lock(&pnfs_spinlock);\r\ntmp = find_pnfs_driver_locked(ld_type->id);\r\nif (!tmp) {\r\nlist_add(&ld_type->pnfs_tblid, &pnfs_modules_tbl);\r\nstatus = 0;\r\ndprintk("%s Registering id:%u name:%s\n", __func__, ld_type->id,\r\nld_type->name);\r\n} else {\r\nprintk(KERN_ERR "NFS: %s Module with id %d already loaded!\n",\r\n__func__, ld_type->id);\r\n}\r\nspin_unlock(&pnfs_spinlock);\r\nreturn status;\r\n}\r\nvoid\r\npnfs_unregister_layoutdriver(struct pnfs_layoutdriver_type *ld_type)\r\n{\r\ndprintk("%s Deregistering id:%u\n", __func__, ld_type->id);\r\nspin_lock(&pnfs_spinlock);\r\nlist_del(&ld_type->pnfs_tblid);\r\nspin_unlock(&pnfs_spinlock);\r\n}\r\nvoid\r\npnfs_get_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\natomic_inc(&lo->plh_refcount);\r\n}\r\nstatic struct pnfs_layout_hdr *\r\npnfs_alloc_layout_hdr(struct inode *ino, gfp_t gfp_flags)\r\n{\r\nstruct pnfs_layoutdriver_type *ld = NFS_SERVER(ino)->pnfs_curr_ld;\r\nreturn ld->alloc_layout_hdr(ino, gfp_flags);\r\n}\r\nstatic void\r\npnfs_free_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(lo->plh_inode);\r\nstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\r\nif (!list_empty(&lo->plh_layouts)) {\r\nstruct nfs_client *clp = server->nfs_client;\r\nspin_lock(&clp->cl_lock);\r\nlist_del_init(&lo->plh_layouts);\r\nspin_unlock(&clp->cl_lock);\r\n}\r\nput_rpccred(lo->plh_lc_cred);\r\nreturn ld->free_layout_hdr(lo);\r\n}\r\nstatic void\r\npnfs_detach_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(lo->plh_inode);\r\ndprintk("%s: freeing layout cache %p\n", __func__, lo);\r\nnfsi->layout = NULL;\r\nnfsi->write_io = 0;\r\nnfsi->read_io = 0;\r\n}\r\nvoid\r\npnfs_put_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nif (atomic_dec_and_lock(&lo->plh_refcount, &inode->i_lock)) {\r\npnfs_detach_layout_hdr(lo);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_layout_hdr(lo);\r\n}\r\n}\r\nstatic int\r\npnfs_iomode_to_fail_bit(u32 iomode)\r\n{\r\nreturn iomode == IOMODE_RW ?\r\nNFS_LAYOUT_RW_FAILED : NFS_LAYOUT_RO_FAILED;\r\n}\r\nstatic void\r\npnfs_layout_set_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\r\n{\r\nlo->plh_retry_timestamp = jiffies;\r\nif (!test_and_set_bit(fail_bit, &lo->plh_flags))\r\natomic_inc(&lo->plh_refcount);\r\n}\r\nstatic void\r\npnfs_layout_clear_fail_bit(struct pnfs_layout_hdr *lo, int fail_bit)\r\n{\r\nif (test_and_clear_bit(fail_bit, &lo->plh_flags))\r\natomic_dec(&lo->plh_refcount);\r\n}\r\nstatic void\r\npnfs_layout_io_set_failed(struct pnfs_layout_hdr *lo, u32 iomode)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nstruct pnfs_layout_range range = {\r\n.iomode = iomode,\r\n.offset = 0,\r\n.length = NFS4_MAX_UINT64,\r\n};\r\nLIST_HEAD(head);\r\nspin_lock(&inode->i_lock);\r\npnfs_layout_set_fail_bit(lo, pnfs_iomode_to_fail_bit(iomode));\r\npnfs_mark_matching_lsegs_invalid(lo, &head, &range);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg_list(&head);\r\ndprintk("%s Setting layout IOMODE_%s fail bit\n", __func__,\r\niomode == IOMODE_RW ? "RW" : "READ");\r\n}\r\nstatic bool\r\npnfs_layout_io_test_failed(struct pnfs_layout_hdr *lo, u32 iomode)\r\n{\r\nunsigned long start, end;\r\nint fail_bit = pnfs_iomode_to_fail_bit(iomode);\r\nif (test_bit(fail_bit, &lo->plh_flags) == 0)\r\nreturn false;\r\nend = jiffies;\r\nstart = end - PNFS_LAYOUTGET_RETRY_TIMEOUT;\r\nif (!time_in_range(lo->plh_retry_timestamp, start, end)) {\r\npnfs_layout_clear_fail_bit(lo, fail_bit);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void\r\ninit_lseg(struct pnfs_layout_hdr *lo, struct pnfs_layout_segment *lseg)\r\n{\r\nINIT_LIST_HEAD(&lseg->pls_list);\r\nINIT_LIST_HEAD(&lseg->pls_lc_list);\r\natomic_set(&lseg->pls_refcount, 1);\r\nsmp_mb();\r\nset_bit(NFS_LSEG_VALID, &lseg->pls_flags);\r\nlseg->pls_layout = lo;\r\n}\r\nstatic void pnfs_free_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct inode *ino = lseg->pls_layout->plh_inode;\r\nNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\r\n}\r\nstatic void\r\npnfs_layout_remove_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct inode *inode = lo->plh_inode;\r\nWARN_ON(test_bit(NFS_LSEG_VALID, &lseg->pls_flags));\r\nlist_del_init(&lseg->pls_list);\r\natomic_dec(&lo->plh_refcount);\r\nif (list_empty(&lo->plh_segs))\r\nclear_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\r\nrpc_wake_up(&NFS_SERVER(inode)->roc_rpcwaitq);\r\n}\r\nvoid\r\npnfs_put_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nstruct inode *inode;\r\nif (!lseg)\r\nreturn;\r\ndprintk("%s: lseg %p ref %d valid %d\n", __func__, lseg,\r\natomic_read(&lseg->pls_refcount),\r\ntest_bit(NFS_LSEG_VALID, &lseg->pls_flags));\r\nlo = lseg->pls_layout;\r\ninode = lo->plh_inode;\r\nif (atomic_dec_and_lock(&lseg->pls_refcount, &inode->i_lock)) {\r\npnfs_get_layout_hdr(lo);\r\npnfs_layout_remove_lseg(lo, lseg);\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg(lseg);\r\npnfs_put_layout_hdr(lo);\r\n}\r\n}\r\nstatic u64\r\nend_offset(u64 start, u64 len)\r\n{\r\nu64 end;\r\nend = start + len;\r\nreturn end >= start ? end : NFS4_MAX_UINT64;\r\n}\r\nstatic bool\r\npnfs_lseg_range_contained(const struct pnfs_layout_range *l1,\r\nconst struct pnfs_layout_range *l2)\r\n{\r\nu64 start1 = l1->offset;\r\nu64 end1 = end_offset(start1, l1->length);\r\nu64 start2 = l2->offset;\r\nu64 end2 = end_offset(start2, l2->length);\r\nreturn (start1 <= start2) && (end1 >= end2);\r\n}\r\nstatic bool\r\npnfs_lseg_range_intersecting(const struct pnfs_layout_range *l1,\r\nconst struct pnfs_layout_range *l2)\r\n{\r\nu64 start1 = l1->offset;\r\nu64 end1 = end_offset(start1, l1->length);\r\nu64 start2 = l2->offset;\r\nu64 end2 = end_offset(start2, l2->length);\r\nreturn (end1 == NFS4_MAX_UINT64 || end1 > start2) &&\r\n(end2 == NFS4_MAX_UINT64 || end2 > start1);\r\n}\r\nstatic bool\r\nshould_free_lseg(const struct pnfs_layout_range *lseg_range,\r\nconst struct pnfs_layout_range *recall_range)\r\n{\r\nreturn (recall_range->iomode == IOMODE_ANY ||\r\nlseg_range->iomode == recall_range->iomode) &&\r\npnfs_lseg_range_intersecting(lseg_range, recall_range);\r\n}\r\nstatic bool pnfs_lseg_dec_and_remove_zero(struct pnfs_layout_segment *lseg,\r\nstruct list_head *tmp_list)\r\n{\r\nif (!atomic_dec_and_test(&lseg->pls_refcount))\r\nreturn false;\r\npnfs_layout_remove_lseg(lseg->pls_layout, lseg);\r\nlist_add(&lseg->pls_list, tmp_list);\r\nreturn true;\r\n}\r\nstatic int mark_lseg_invalid(struct pnfs_layout_segment *lseg,\r\nstruct list_head *tmp_list)\r\n{\r\nint rv = 0;\r\nif (test_and_clear_bit(NFS_LSEG_VALID, &lseg->pls_flags)) {\r\ndprintk("%s: lseg %p ref %d\n", __func__, lseg,\r\natomic_read(&lseg->pls_refcount));\r\nif (pnfs_lseg_dec_and_remove_zero(lseg, tmp_list))\r\nrv = 1;\r\n}\r\nreturn rv;\r\n}\r\nint\r\npnfs_mark_matching_lsegs_invalid(struct pnfs_layout_hdr *lo,\r\nstruct list_head *tmp_list,\r\nstruct pnfs_layout_range *recall_range)\r\n{\r\nstruct pnfs_layout_segment *lseg, *next;\r\nint invalid = 0, removed = 0;\r\ndprintk("%s:Begin lo %p\n", __func__, lo);\r\nif (list_empty(&lo->plh_segs))\r\nreturn 0;\r\nlist_for_each_entry_safe(lseg, next, &lo->plh_segs, pls_list)\r\nif (!recall_range ||\r\nshould_free_lseg(&lseg->pls_range, recall_range)) {\r\ndprintk("%s: freeing lseg %p iomode %d "\r\n"offset %llu length %llu\n", __func__,\r\nlseg, lseg->pls_range.iomode, lseg->pls_range.offset,\r\nlseg->pls_range.length);\r\ninvalid++;\r\nremoved += mark_lseg_invalid(lseg, tmp_list);\r\n}\r\ndprintk("%s:Return %i\n", __func__, invalid - removed);\r\nreturn invalid - removed;\r\n}\r\nvoid\r\npnfs_free_lseg_list(struct list_head *free_me)\r\n{\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nif (list_empty(free_me))\r\nreturn;\r\nlist_for_each_entry_safe(lseg, tmp, free_me, pls_list) {\r\nlist_del(&lseg->pls_list);\r\npnfs_free_lseg(lseg);\r\n}\r\n}\r\nvoid\r\npnfs_destroy_layout(struct nfs_inode *nfsi)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nLIST_HEAD(tmp_list);\r\nspin_lock(&nfsi->vfs_inode.i_lock);\r\nlo = nfsi->layout;\r\nif (lo) {\r\nlo->plh_block_lgets++;\r\npnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\r\npnfs_get_layout_hdr(lo);\r\npnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RO_FAILED);\r\npnfs_layout_clear_fail_bit(lo, NFS_LAYOUT_RW_FAILED);\r\nspin_unlock(&nfsi->vfs_inode.i_lock);\r\npnfs_free_lseg_list(&tmp_list);\r\npnfs_put_layout_hdr(lo);\r\n} else\r\nspin_unlock(&nfsi->vfs_inode.i_lock);\r\n}\r\nstatic bool\r\npnfs_layout_add_bulk_destroy_list(struct inode *inode,\r\nstruct list_head *layout_list)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nbool ret = false;\r\nspin_lock(&inode->i_lock);\r\nlo = NFS_I(inode)->layout;\r\nif (lo != NULL && list_empty(&lo->plh_bulk_destroy)) {\r\npnfs_get_layout_hdr(lo);\r\nlist_add(&lo->plh_bulk_destroy, layout_list);\r\nret = true;\r\n}\r\nspin_unlock(&inode->i_lock);\r\nreturn ret;\r\n}\r\nstatic int\r\npnfs_layout_bulk_destroy_byserver_locked(struct nfs_client *clp,\r\nstruct nfs_server *server,\r\nstruct list_head *layout_list)\r\n{\r\nstruct pnfs_layout_hdr *lo, *next;\r\nstruct inode *inode;\r\nlist_for_each_entry_safe(lo, next, &server->layouts, plh_layouts) {\r\ninode = igrab(lo->plh_inode);\r\nif (inode == NULL)\r\ncontinue;\r\nlist_del_init(&lo->plh_layouts);\r\nif (pnfs_layout_add_bulk_destroy_list(inode, layout_list))\r\ncontinue;\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\niput(inode);\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npnfs_layout_free_bulk_destroy_list(struct list_head *layout_list,\r\nbool is_bulk_recall)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nstruct inode *inode;\r\nstruct pnfs_layout_range range = {\r\n.iomode = IOMODE_ANY,\r\n.offset = 0,\r\n.length = NFS4_MAX_UINT64,\r\n};\r\nLIST_HEAD(lseg_list);\r\nint ret = 0;\r\nwhile (!list_empty(layout_list)) {\r\nlo = list_entry(layout_list->next, struct pnfs_layout_hdr,\r\nplh_bulk_destroy);\r\ndprintk("%s freeing layout for inode %lu\n", __func__,\r\nlo->plh_inode->i_ino);\r\ninode = lo->plh_inode;\r\nspin_lock(&inode->i_lock);\r\nlist_del_init(&lo->plh_bulk_destroy);\r\nlo->plh_block_lgets++;\r\nif (is_bulk_recall)\r\nset_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags);\r\nif (pnfs_mark_matching_lsegs_invalid(lo, &lseg_list, &range))\r\nret = -EAGAIN;\r\nspin_unlock(&inode->i_lock);\r\npnfs_free_lseg_list(&lseg_list);\r\npnfs_put_layout_hdr(lo);\r\niput(inode);\r\n}\r\nreturn ret;\r\n}\r\nint\r\npnfs_destroy_layouts_byfsid(struct nfs_client *clp,\r\nstruct nfs_fsid *fsid,\r\nbool is_recall)\r\n{\r\nstruct nfs_server *server;\r\nLIST_HEAD(layout_list);\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nrestart:\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nif (memcmp(&server->fsid, fsid, sizeof(*fsid)) != 0)\r\ncontinue;\r\nif (pnfs_layout_bulk_destroy_byserver_locked(clp,\r\nserver,\r\n&layout_list) != 0)\r\ngoto restart;\r\n}\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\nif (list_empty(&layout_list))\r\nreturn 0;\r\nreturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\r\n}\r\nint\r\npnfs_destroy_layouts_byclid(struct nfs_client *clp,\r\nbool is_recall)\r\n{\r\nstruct nfs_server *server;\r\nLIST_HEAD(layout_list);\r\nspin_lock(&clp->cl_lock);\r\nrcu_read_lock();\r\nrestart:\r\nlist_for_each_entry_rcu(server, &clp->cl_superblocks, client_link) {\r\nif (pnfs_layout_bulk_destroy_byserver_locked(clp,\r\nserver,\r\n&layout_list) != 0)\r\ngoto restart;\r\n}\r\nrcu_read_unlock();\r\nspin_unlock(&clp->cl_lock);\r\nif (list_empty(&layout_list))\r\nreturn 0;\r\nreturn pnfs_layout_free_bulk_destroy_list(&layout_list, is_recall);\r\n}\r\nvoid\r\npnfs_destroy_all_layouts(struct nfs_client *clp)\r\n{\r\nnfs4_deviceid_mark_client_invalid(clp);\r\nnfs4_deviceid_purge_client(clp);\r\npnfs_destroy_layouts_byclid(clp, false);\r\n}\r\nstatic bool pnfs_seqid_is_newer(u32 s1, u32 s2)\r\n{\r\nreturn (s32)s1 - (s32)s2 > 0;\r\n}\r\nvoid\r\npnfs_set_layout_stateid(struct pnfs_layout_hdr *lo, const nfs4_stateid *new,\r\nbool update_barrier)\r\n{\r\nu32 oldseq, newseq, new_barrier;\r\nint empty = list_empty(&lo->plh_segs);\r\noldseq = be32_to_cpu(lo->plh_stateid.seqid);\r\nnewseq = be32_to_cpu(new->seqid);\r\nif (empty || pnfs_seqid_is_newer(newseq, oldseq)) {\r\nnfs4_stateid_copy(&lo->plh_stateid, new);\r\nif (update_barrier) {\r\nnew_barrier = be32_to_cpu(new->seqid);\r\n} else {\r\nnew_barrier = newseq - atomic_read(&lo->plh_outstanding);\r\n}\r\nif (empty || pnfs_seqid_is_newer(new_barrier, lo->plh_barrier))\r\nlo->plh_barrier = new_barrier;\r\n}\r\n}\r\nstatic bool\r\npnfs_layout_stateid_blocked(const struct pnfs_layout_hdr *lo,\r\nconst nfs4_stateid *stateid)\r\n{\r\nu32 seqid = be32_to_cpu(stateid->seqid);\r\nreturn !pnfs_seqid_is_newer(seqid, lo->plh_barrier);\r\n}\r\nstatic bool\r\npnfs_layoutgets_blocked(const struct pnfs_layout_hdr *lo, int lget)\r\n{\r\nreturn lo->plh_block_lgets ||\r\ntest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags) ||\r\n(list_empty(&lo->plh_segs) &&\r\n(atomic_read(&lo->plh_outstanding) > lget));\r\n}\r\nint\r\npnfs_choose_layoutget_stateid(nfs4_stateid *dst, struct pnfs_layout_hdr *lo,\r\nstruct nfs4_state *open_state)\r\n{\r\nint status = 0;\r\ndprintk("--> %s\n", __func__);\r\nspin_lock(&lo->plh_inode->i_lock);\r\nif (pnfs_layoutgets_blocked(lo, 1)) {\r\nstatus = -EAGAIN;\r\n} else if (!nfs4_valid_open_stateid(open_state)) {\r\nstatus = -EBADF;\r\n} else if (list_empty(&lo->plh_segs)) {\r\nint seq;\r\ndo {\r\nseq = read_seqbegin(&open_state->seqlock);\r\nnfs4_stateid_copy(dst, &open_state->stateid);\r\n} while (read_seqretry(&open_state->seqlock, seq));\r\n} else\r\nnfs4_stateid_copy(dst, &lo->plh_stateid);\r\nspin_unlock(&lo->plh_inode->i_lock);\r\ndprintk("<-- %s\n", __func__);\r\nreturn status;\r\n}\r\nstatic struct pnfs_layout_segment *\r\nsend_layoutget(struct pnfs_layout_hdr *lo,\r\nstruct nfs_open_context *ctx,\r\nstruct pnfs_layout_range *range,\r\ngfp_t gfp_flags)\r\n{\r\nstruct inode *ino = lo->plh_inode;\r\nstruct nfs_server *server = NFS_SERVER(ino);\r\nstruct nfs4_layoutget *lgp;\r\nstruct pnfs_layout_segment *lseg;\r\ndprintk("--> %s\n", __func__);\r\nlgp = kzalloc(sizeof(*lgp), gfp_flags);\r\nif (lgp == NULL)\r\nreturn NULL;\r\nlgp->args.minlength = PAGE_CACHE_SIZE;\r\nif (lgp->args.minlength > range->length)\r\nlgp->args.minlength = range->length;\r\nlgp->args.maxcount = PNFS_LAYOUT_MAXSIZE;\r\nlgp->args.range = *range;\r\nlgp->args.type = server->pnfs_curr_ld->id;\r\nlgp->args.inode = ino;\r\nlgp->args.ctx = get_nfs_open_context(ctx);\r\nlgp->gfp_flags = gfp_flags;\r\nlgp->cred = lo->plh_lc_cred;\r\nlseg = nfs4_proc_layoutget(lgp, gfp_flags);\r\nif (IS_ERR(lseg)) {\r\nswitch (PTR_ERR(lseg)) {\r\ncase -ENOMEM:\r\ncase -ERESTARTSYS:\r\nbreak;\r\ndefault:\r\npnfs_layout_io_set_failed(lo, range->iomode);\r\n}\r\nreturn NULL;\r\n}\r\nreturn lseg;\r\n}\r\nstatic void pnfs_clear_layoutcommit(struct inode *inode,\r\nstruct list_head *head)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\r\nreturn;\r\nlist_for_each_entry_safe(lseg, tmp, &nfsi->layout->plh_segs, pls_list) {\r\nif (!test_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\r\ncontinue;\r\npnfs_lseg_dec_and_remove_zero(lseg, head);\r\n}\r\n}\r\nint\r\n_pnfs_return_layout(struct inode *ino)\r\n{\r\nstruct pnfs_layout_hdr *lo = NULL;\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nLIST_HEAD(tmp_list);\r\nstruct nfs4_layoutreturn *lrp;\r\nnfs4_stateid stateid;\r\nint status = 0, empty;\r\ndprintk("NFS: %s for inode %lu\n", __func__, ino->i_ino);\r\nspin_lock(&ino->i_lock);\r\nlo = nfsi->layout;\r\nif (!lo) {\r\nspin_unlock(&ino->i_lock);\r\ndprintk("NFS: %s no layout to return\n", __func__);\r\ngoto out;\r\n}\r\nstateid = nfsi->layout->plh_stateid;\r\npnfs_get_layout_hdr(lo);\r\nempty = list_empty(&lo->plh_segs);\r\npnfs_clear_layoutcommit(ino, &tmp_list);\r\npnfs_mark_matching_lsegs_invalid(lo, &tmp_list, NULL);\r\nif (empty) {\r\nspin_unlock(&ino->i_lock);\r\npnfs_put_layout_hdr(lo);\r\ndprintk("NFS: %s no layout segments to return\n", __func__);\r\ngoto out;\r\n}\r\nlo->plh_block_lgets++;\r\nspin_unlock(&ino->i_lock);\r\npnfs_free_lseg_list(&tmp_list);\r\nlrp = kzalloc(sizeof(*lrp), GFP_KERNEL);\r\nif (unlikely(lrp == NULL)) {\r\nstatus = -ENOMEM;\r\nspin_lock(&ino->i_lock);\r\nlo->plh_block_lgets--;\r\nspin_unlock(&ino->i_lock);\r\npnfs_put_layout_hdr(lo);\r\ngoto out;\r\n}\r\nlrp->args.stateid = stateid;\r\nlrp->args.layout_type = NFS_SERVER(ino)->pnfs_curr_ld->id;\r\nlrp->args.inode = ino;\r\nlrp->args.layout = lo;\r\nlrp->clp = NFS_SERVER(ino)->nfs_client;\r\nlrp->cred = lo->plh_lc_cred;\r\nstatus = nfs4_proc_layoutreturn(lrp);\r\nout:\r\ndprintk("<-- %s status: %d\n", __func__, status);\r\nreturn status;\r\n}\r\nint\r\npnfs_commit_and_return_layout(struct inode *inode)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nint ret;\r\nspin_lock(&inode->i_lock);\r\nlo = NFS_I(inode)->layout;\r\nif (lo == NULL) {\r\nspin_unlock(&inode->i_lock);\r\nreturn 0;\r\n}\r\npnfs_get_layout_hdr(lo);\r\nlo->plh_block_lgets++;\r\nspin_unlock(&inode->i_lock);\r\nfilemap_fdatawait(inode->i_mapping);\r\nret = pnfs_layoutcommit_inode(inode, true);\r\nif (ret == 0)\r\nret = _pnfs_return_layout(inode);\r\nspin_lock(&inode->i_lock);\r\nlo->plh_block_lgets--;\r\nspin_unlock(&inode->i_lock);\r\npnfs_put_layout_hdr(lo);\r\nreturn ret;\r\n}\r\nbool pnfs_roc(struct inode *ino)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nLIST_HEAD(tmp_list);\r\nbool found = false;\r\nspin_lock(&ino->i_lock);\r\nlo = NFS_I(ino)->layout;\r\nif (!lo || !test_and_clear_bit(NFS_LAYOUT_ROC, &lo->plh_flags) ||\r\ntest_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags))\r\ngoto out_nolayout;\r\nlist_for_each_entry_safe(lseg, tmp, &lo->plh_segs, pls_list)\r\nif (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {\r\nmark_lseg_invalid(lseg, &tmp_list);\r\nfound = true;\r\n}\r\nif (!found)\r\ngoto out_nolayout;\r\nlo->plh_block_lgets++;\r\npnfs_get_layout_hdr(lo);\r\nspin_unlock(&ino->i_lock);\r\npnfs_free_lseg_list(&tmp_list);\r\nreturn true;\r\nout_nolayout:\r\nspin_unlock(&ino->i_lock);\r\nreturn false;\r\n}\r\nvoid pnfs_roc_release(struct inode *ino)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nspin_lock(&ino->i_lock);\r\nlo = NFS_I(ino)->layout;\r\nlo->plh_block_lgets--;\r\nif (atomic_dec_and_test(&lo->plh_refcount)) {\r\npnfs_detach_layout_hdr(lo);\r\nspin_unlock(&ino->i_lock);\r\npnfs_free_layout_hdr(lo);\r\n} else\r\nspin_unlock(&ino->i_lock);\r\n}\r\nvoid pnfs_roc_set_barrier(struct inode *ino, u32 barrier)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nspin_lock(&ino->i_lock);\r\nlo = NFS_I(ino)->layout;\r\nif (pnfs_seqid_is_newer(barrier, lo->plh_barrier))\r\nlo->plh_barrier = barrier;\r\nspin_unlock(&ino->i_lock);\r\n}\r\nbool pnfs_roc_drain(struct inode *ino, u32 *barrier, struct rpc_task *task)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nstruct pnfs_layout_hdr *lo;\r\nstruct pnfs_layout_segment *lseg;\r\nu32 current_seqid;\r\nbool found = false;\r\nspin_lock(&ino->i_lock);\r\nlist_for_each_entry(lseg, &nfsi->layout->plh_segs, pls_list)\r\nif (test_bit(NFS_LSEG_ROC, &lseg->pls_flags)) {\r\nrpc_sleep_on(&NFS_SERVER(ino)->roc_rpcwaitq, task, NULL);\r\nfound = true;\r\ngoto out;\r\n}\r\nlo = nfsi->layout;\r\ncurrent_seqid = be32_to_cpu(lo->plh_stateid.seqid);\r\n*barrier = current_seqid + atomic_read(&lo->plh_outstanding);\r\nout:\r\nspin_unlock(&ino->i_lock);\r\nreturn found;\r\n}\r\nstatic s64\r\npnfs_lseg_range_cmp(const struct pnfs_layout_range *l1,\r\nconst struct pnfs_layout_range *l2)\r\n{\r\ns64 d;\r\nd = l1->offset - l2->offset;\r\nif (d)\r\nreturn d;\r\nd = l2->length - l1->length;\r\nif (d)\r\nreturn d;\r\nreturn (int)(l1->iomode == IOMODE_READ) - (int)(l2->iomode == IOMODE_READ);\r\n}\r\nstatic void\r\npnfs_layout_insert_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct pnfs_layout_segment *lp;\r\ndprintk("%s:Begin\n", __func__);\r\nlist_for_each_entry(lp, &lo->plh_segs, pls_list) {\r\nif (pnfs_lseg_range_cmp(&lseg->pls_range, &lp->pls_range) > 0)\r\ncontinue;\r\nlist_add_tail(&lseg->pls_list, &lp->pls_list);\r\ndprintk("%s: inserted lseg %p "\r\n"iomode %d offset %llu length %llu before "\r\n"lp %p iomode %d offset %llu length %llu\n",\r\n__func__, lseg, lseg->pls_range.iomode,\r\nlseg->pls_range.offset, lseg->pls_range.length,\r\nlp, lp->pls_range.iomode, lp->pls_range.offset,\r\nlp->pls_range.length);\r\ngoto out;\r\n}\r\nlist_add_tail(&lseg->pls_list, &lo->plh_segs);\r\ndprintk("%s: inserted lseg %p "\r\n"iomode %d offset %llu length %llu at tail\n",\r\n__func__, lseg, lseg->pls_range.iomode,\r\nlseg->pls_range.offset, lseg->pls_range.length);\r\nout:\r\npnfs_get_layout_hdr(lo);\r\ndprintk("%s:Return\n", __func__);\r\n}\r\nstatic struct pnfs_layout_hdr *\r\nalloc_init_layout_hdr(struct inode *ino,\r\nstruct nfs_open_context *ctx,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_layout_hdr *lo;\r\nlo = pnfs_alloc_layout_hdr(ino, gfp_flags);\r\nif (!lo)\r\nreturn NULL;\r\natomic_set(&lo->plh_refcount, 1);\r\nINIT_LIST_HEAD(&lo->plh_layouts);\r\nINIT_LIST_HEAD(&lo->plh_segs);\r\nINIT_LIST_HEAD(&lo->plh_bulk_destroy);\r\nlo->plh_inode = ino;\r\nlo->plh_lc_cred = get_rpccred(ctx->cred);\r\nreturn lo;\r\n}\r\nstatic struct pnfs_layout_hdr *\r\npnfs_find_alloc_layout(struct inode *ino,\r\nstruct nfs_open_context *ctx,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nstruct pnfs_layout_hdr *new = NULL;\r\ndprintk("%s Begin ino=%p layout=%p\n", __func__, ino, nfsi->layout);\r\nif (nfsi->layout != NULL)\r\ngoto out_existing;\r\nspin_unlock(&ino->i_lock);\r\nnew = alloc_init_layout_hdr(ino, ctx, gfp_flags);\r\nspin_lock(&ino->i_lock);\r\nif (likely(nfsi->layout == NULL)) {\r\nnfsi->layout = new;\r\nreturn new;\r\n} else if (new != NULL)\r\npnfs_free_layout_hdr(new);\r\nout_existing:\r\npnfs_get_layout_hdr(nfsi->layout);\r\nreturn nfsi->layout;\r\n}\r\nstatic bool\r\npnfs_lseg_range_match(const struct pnfs_layout_range *ls_range,\r\nconst struct pnfs_layout_range *range)\r\n{\r\nstruct pnfs_layout_range range1;\r\nif ((range->iomode == IOMODE_RW &&\r\nls_range->iomode != IOMODE_RW) ||\r\n!pnfs_lseg_range_intersecting(ls_range, range))\r\nreturn 0;\r\nrange1 = *range;\r\nrange1.length = 1;\r\nreturn pnfs_lseg_range_contained(ls_range, &range1);\r\n}\r\nstatic struct pnfs_layout_segment *\r\npnfs_find_lseg(struct pnfs_layout_hdr *lo,\r\nstruct pnfs_layout_range *range)\r\n{\r\nstruct pnfs_layout_segment *lseg, *ret = NULL;\r\ndprintk("%s:Begin\n", __func__);\r\nlist_for_each_entry(lseg, &lo->plh_segs, pls_list) {\r\nif (test_bit(NFS_LSEG_VALID, &lseg->pls_flags) &&\r\npnfs_lseg_range_match(&lseg->pls_range, range)) {\r\nret = pnfs_get_lseg(lseg);\r\nbreak;\r\n}\r\nif (lseg->pls_range.offset > range->offset)\r\nbreak;\r\n}\r\ndprintk("%s:Return lseg %p ref %d\n",\r\n__func__, ret, ret ? atomic_read(&ret->pls_refcount) : 0);\r\nreturn ret;\r\n}\r\nstatic bool pnfs_within_mdsthreshold(struct nfs_open_context *ctx,\r\nstruct inode *ino, int iomode)\r\n{\r\nstruct nfs4_threshold *t = ctx->mdsthreshold;\r\nstruct nfs_inode *nfsi = NFS_I(ino);\r\nloff_t fsize = i_size_read(ino);\r\nbool size = false, size_set = false, io = false, io_set = false, ret = false;\r\nif (t == NULL)\r\nreturn ret;\r\ndprintk("%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu\n",\r\n__func__, t->bm, t->rd_sz, t->wr_sz, t->rd_io_sz, t->wr_io_sz);\r\nswitch (iomode) {\r\ncase IOMODE_READ:\r\nif (t->bm & THRESHOLD_RD) {\r\ndprintk("%s fsize %llu\n", __func__, fsize);\r\nsize_set = true;\r\nif (fsize < t->rd_sz)\r\nsize = true;\r\n}\r\nif (t->bm & THRESHOLD_RD_IO) {\r\ndprintk("%s nfsi->read_io %llu\n", __func__,\r\nnfsi->read_io);\r\nio_set = true;\r\nif (nfsi->read_io < t->rd_io_sz)\r\nio = true;\r\n}\r\nbreak;\r\ncase IOMODE_RW:\r\nif (t->bm & THRESHOLD_WR) {\r\ndprintk("%s fsize %llu\n", __func__, fsize);\r\nsize_set = true;\r\nif (fsize < t->wr_sz)\r\nsize = true;\r\n}\r\nif (t->bm & THRESHOLD_WR_IO) {\r\ndprintk("%s nfsi->write_io %llu\n", __func__,\r\nnfsi->write_io);\r\nio_set = true;\r\nif (nfsi->write_io < t->wr_io_sz)\r\nio = true;\r\n}\r\nbreak;\r\n}\r\nif (size_set && io_set) {\r\nif (size && io)\r\nret = true;\r\n} else if (size || io)\r\nret = true;\r\ndprintk("<-- %s size %d io %d ret %d\n", __func__, size, io, ret);\r\nreturn ret;\r\n}\r\nstruct pnfs_layout_segment *\r\npnfs_update_layout(struct inode *ino,\r\nstruct nfs_open_context *ctx,\r\nloff_t pos,\r\nu64 count,\r\nenum pnfs_iomode iomode,\r\ngfp_t gfp_flags)\r\n{\r\nstruct pnfs_layout_range arg = {\r\n.iomode = iomode,\r\n.offset = pos,\r\n.length = count,\r\n};\r\nunsigned pg_offset;\r\nstruct nfs_server *server = NFS_SERVER(ino);\r\nstruct nfs_client *clp = server->nfs_client;\r\nstruct pnfs_layout_hdr *lo;\r\nstruct pnfs_layout_segment *lseg = NULL;\r\nbool first;\r\nif (!pnfs_enabled_sb(NFS_SERVER(ino)))\r\ngoto out;\r\nif (pnfs_within_mdsthreshold(ctx, ino, iomode))\r\ngoto out;\r\nspin_lock(&ino->i_lock);\r\nlo = pnfs_find_alloc_layout(ino, ctx, gfp_flags);\r\nif (lo == NULL) {\r\nspin_unlock(&ino->i_lock);\r\ngoto out;\r\n}\r\nif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\r\ndprintk("%s matches recall, use MDS\n", __func__);\r\ngoto out_unlock;\r\n}\r\nif (pnfs_layout_io_test_failed(lo, iomode))\r\ngoto out_unlock;\r\nlseg = pnfs_find_lseg(lo, &arg);\r\nif (lseg)\r\ngoto out_unlock;\r\nif (pnfs_layoutgets_blocked(lo, 0))\r\ngoto out_unlock;\r\natomic_inc(&lo->plh_outstanding);\r\nfirst = list_empty(&lo->plh_layouts) ? true : false;\r\nspin_unlock(&ino->i_lock);\r\nif (first) {\r\nspin_lock(&clp->cl_lock);\r\nlist_add_tail(&lo->plh_layouts, &server->layouts);\r\nspin_unlock(&clp->cl_lock);\r\n}\r\npg_offset = arg.offset & ~PAGE_CACHE_MASK;\r\nif (pg_offset) {\r\narg.offset -= pg_offset;\r\narg.length += pg_offset;\r\n}\r\nif (arg.length != NFS4_MAX_UINT64)\r\narg.length = PAGE_CACHE_ALIGN(arg.length);\r\nlseg = send_layoutget(lo, ctx, &arg, gfp_flags);\r\natomic_dec(&lo->plh_outstanding);\r\nout_put_layout_hdr:\r\npnfs_put_layout_hdr(lo);\r\nout:\r\ndprintk("%s: inode %s/%llu pNFS layout segment %s for "\r\n"(%s, offset: %llu, length: %llu)\n",\r\n__func__, ino->i_sb->s_id,\r\n(unsigned long long)NFS_FILEID(ino),\r\nlseg == NULL ? "not found" : "found",\r\niomode==IOMODE_RW ? "read/write" : "read-only",\r\n(unsigned long long)pos,\r\n(unsigned long long)count);\r\nreturn lseg;\r\nout_unlock:\r\nspin_unlock(&ino->i_lock);\r\ngoto out_put_layout_hdr;\r\n}\r\nstruct pnfs_layout_segment *\r\npnfs_layout_process(struct nfs4_layoutget *lgp)\r\n{\r\nstruct pnfs_layout_hdr *lo = NFS_I(lgp->args.inode)->layout;\r\nstruct nfs4_layoutget_res *res = &lgp->res;\r\nstruct pnfs_layout_segment *lseg;\r\nstruct inode *ino = lo->plh_inode;\r\nint status = 0;\r\nlseg = NFS_SERVER(ino)->pnfs_curr_ld->alloc_lseg(lo, res, lgp->gfp_flags);\r\nif (!lseg || IS_ERR(lseg)) {\r\nif (!lseg)\r\nstatus = -ENOMEM;\r\nelse\r\nstatus = PTR_ERR(lseg);\r\ndprintk("%s: Could not allocate layout: error %d\n",\r\n__func__, status);\r\ngoto out;\r\n}\r\nspin_lock(&ino->i_lock);\r\nif (test_bit(NFS_LAYOUT_BULK_RECALL, &lo->plh_flags)) {\r\ndprintk("%s forget reply due to recall\n", __func__);\r\ngoto out_forget_reply;\r\n}\r\nif (pnfs_layoutgets_blocked(lo, 1) ||\r\npnfs_layout_stateid_blocked(lo, &res->stateid)) {\r\ndprintk("%s forget reply due to state\n", __func__);\r\ngoto out_forget_reply;\r\n}\r\npnfs_set_layout_stateid(lo, &res->stateid, false);\r\ninit_lseg(lo, lseg);\r\nlseg->pls_range = res->range;\r\npnfs_get_lseg(lseg);\r\npnfs_layout_insert_lseg(lo, lseg);\r\nif (res->return_on_close) {\r\nset_bit(NFS_LSEG_ROC, &lseg->pls_flags);\r\nset_bit(NFS_LAYOUT_ROC, &lo->plh_flags);\r\n}\r\nspin_unlock(&ino->i_lock);\r\nreturn lseg;\r\nout:\r\nreturn ERR_PTR(status);\r\nout_forget_reply:\r\nspin_unlock(&ino->i_lock);\r\nlseg->pls_layout = lo;\r\nNFS_SERVER(ino)->pnfs_curr_ld->free_lseg(lseg);\r\ngoto out;\r\n}\r\nvoid\r\npnfs_generic_pg_init_read(struct nfs_pageio_descriptor *pgio, struct nfs_page *req)\r\n{\r\nu64 rd_size = req->wb_bytes;\r\nWARN_ON_ONCE(pgio->pg_lseg != NULL);\r\nif (req->wb_offset != req->wb_pgbase) {\r\nnfs_pageio_reset_read_mds(pgio);\r\nreturn;\r\n}\r\nif (pgio->pg_dreq == NULL)\r\nrd_size = i_size_read(pgio->pg_inode) - req_offset(req);\r\nelse\r\nrd_size = nfs_dreq_bytes_left(pgio->pg_dreq);\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\nreq_offset(req),\r\nrd_size,\r\nIOMODE_READ,\r\nGFP_KERNEL);\r\nif (pgio->pg_lseg == NULL)\r\nnfs_pageio_reset_read_mds(pgio);\r\n}\r\nvoid\r\npnfs_generic_pg_init_write(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *req, u64 wb_size)\r\n{\r\nWARN_ON_ONCE(pgio->pg_lseg != NULL);\r\nif (req->wb_offset != req->wb_pgbase) {\r\nnfs_pageio_reset_write_mds(pgio);\r\nreturn;\r\n}\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\nreq_offset(req),\r\nwb_size,\r\nIOMODE_RW,\r\nGFP_NOFS);\r\nif (pgio->pg_lseg == NULL)\r\nnfs_pageio_reset_write_mds(pgio);\r\n}\r\nvoid\r\npnfs_pageio_init_read(struct nfs_pageio_descriptor *pgio, struct inode *inode,\r\nconst struct nfs_pgio_completion_ops *compl_ops)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\r\nif (ld == NULL)\r\nnfs_pageio_init_read(pgio, inode, compl_ops);\r\nelse\r\nnfs_pageio_init(pgio, inode, ld->pg_read_ops, compl_ops, server->rsize, 0);\r\n}\r\nvoid\r\npnfs_pageio_init_write(struct nfs_pageio_descriptor *pgio, struct inode *inode,\r\nint ioflags,\r\nconst struct nfs_pgio_completion_ops *compl_ops)\r\n{\r\nstruct nfs_server *server = NFS_SERVER(inode);\r\nstruct pnfs_layoutdriver_type *ld = server->pnfs_curr_ld;\r\nif (ld == NULL)\r\nnfs_pageio_init_write(pgio, inode, ioflags, compl_ops);\r\nelse\r\nnfs_pageio_init(pgio, inode, ld->pg_write_ops, compl_ops, server->wsize, ioflags);\r\n}\r\nbool\r\npnfs_generic_pg_test(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\r\nstruct nfs_page *req)\r\n{\r\nif (pgio->pg_lseg == NULL)\r\nreturn nfs_generic_pg_test(pgio, prev, req);\r\nreturn req_offset(req) < end_offset(pgio->pg_lseg->pls_range.offset,\r\npgio->pg_lseg->pls_range.length);\r\n}\r\nint pnfs_write_done_resend_to_mds(struct inode *inode,\r\nstruct list_head *head,\r\nconst struct nfs_pgio_completion_ops *compl_ops,\r\nstruct nfs_direct_req *dreq)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nLIST_HEAD(failed);\r\nnfs_pageio_init_write(&pgio, inode, FLUSH_STABLE, compl_ops);\r\npgio.pg_dreq = dreq;\r\nwhile (!list_empty(head)) {\r\nstruct nfs_page *req = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nif (!nfs_pageio_add_request(&pgio, req))\r\nnfs_list_add_request(req, &failed);\r\n}\r\nnfs_pageio_complete(&pgio);\r\nif (!list_empty(&failed)) {\r\nlist_move(&failed, head);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pnfs_ld_handle_write_error(struct nfs_write_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\ndprintk("pnfs write error = %d\n", hdr->pnfs_error);\r\nif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\r\nPNFS_LAYOUTRET_ON_ERROR) {\r\npnfs_return_layout(hdr->inode);\r\n}\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\r\ndata->task.tk_status = pnfs_write_done_resend_to_mds(hdr->inode,\r\n&hdr->pages,\r\nhdr->completion_ops,\r\nhdr->dreq);\r\n}\r\nvoid pnfs_ld_write_done(struct nfs_write_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\ntrace_nfs4_pnfs_write(data, hdr->pnfs_error);\r\nif (!hdr->pnfs_error) {\r\npnfs_set_layoutcommit(data);\r\nhdr->mds_ops->rpc_call_done(&data->task, data);\r\n} else\r\npnfs_ld_handle_write_error(data);\r\nhdr->mds_ops->rpc_release(data);\r\n}\r\nstatic void\r\npnfs_write_through_mds(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_write_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\nlist_splice_tail_init(&hdr->pages, &desc->pg_list);\r\nnfs_pageio_reset_write_mds(desc);\r\ndesc->pg_recoalesce = 1;\r\n}\r\nnfs_writedata_release(data);\r\n}\r\nstatic enum pnfs_try_status\r\npnfs_try_to_write_data(struct nfs_write_data *wdata,\r\nconst struct rpc_call_ops *call_ops,\r\nstruct pnfs_layout_segment *lseg,\r\nint how)\r\n{\r\nstruct nfs_pgio_header *hdr = wdata->header;\r\nstruct inode *inode = hdr->inode;\r\nenum pnfs_try_status trypnfs;\r\nstruct nfs_server *nfss = NFS_SERVER(inode);\r\nhdr->mds_ops = call_ops;\r\ndprintk("%s: Writing ino:%lu %u@%llu (how %d)\n", __func__,\r\ninode->i_ino, wdata->args.count, wdata->args.offset, how);\r\ntrypnfs = nfss->pnfs_curr_ld->write_pagelist(wdata, how);\r\nif (trypnfs != PNFS_NOT_ATTEMPTED)\r\nnfs_inc_stats(inode, NFSIOS_PNFS_WRITE);\r\ndprintk("%s End (trypnfs:%d)\n", __func__, trypnfs);\r\nreturn trypnfs;\r\n}\r\nstatic void\r\npnfs_do_multiple_writes(struct nfs_pageio_descriptor *desc, struct list_head *head, int how)\r\n{\r\nstruct nfs_write_data *data;\r\nconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\r\nstruct pnfs_layout_segment *lseg = desc->pg_lseg;\r\ndesc->pg_lseg = NULL;\r\nwhile (!list_empty(head)) {\r\nenum pnfs_try_status trypnfs;\r\ndata = list_first_entry(head, struct nfs_write_data, list);\r\nlist_del_init(&data->list);\r\ntrypnfs = pnfs_try_to_write_data(data, call_ops, lseg, how);\r\nif (trypnfs == PNFS_NOT_ATTEMPTED)\r\npnfs_write_through_mds(desc, data);\r\n}\r\npnfs_put_lseg(lseg);\r\n}\r\nstatic void pnfs_writehdr_free(struct nfs_pgio_header *hdr)\r\n{\r\npnfs_put_lseg(hdr->lseg);\r\nnfs_writehdr_free(hdr);\r\n}\r\nint\r\npnfs_generic_pg_writepages(struct nfs_pageio_descriptor *desc)\r\n{\r\nstruct nfs_write_header *whdr;\r\nstruct nfs_pgio_header *hdr;\r\nint ret;\r\nwhdr = nfs_writehdr_alloc();\r\nif (!whdr) {\r\ndesc->pg_completion_ops->error_cleanup(&desc->pg_list);\r\npnfs_put_lseg(desc->pg_lseg);\r\ndesc->pg_lseg = NULL;\r\nreturn -ENOMEM;\r\n}\r\nhdr = &whdr->header;\r\nnfs_pgheader_init(desc, hdr, pnfs_writehdr_free);\r\nhdr->lseg = pnfs_get_lseg(desc->pg_lseg);\r\natomic_inc(&hdr->refcnt);\r\nret = nfs_generic_flush(desc, hdr);\r\nif (ret != 0) {\r\npnfs_put_lseg(desc->pg_lseg);\r\ndesc->pg_lseg = NULL;\r\n} else\r\npnfs_do_multiple_writes(desc, &hdr->rpc_list, desc->pg_ioflags);\r\nif (atomic_dec_and_test(&hdr->refcnt))\r\nhdr->completion_ops->completion(hdr);\r\nreturn ret;\r\n}\r\nint pnfs_read_done_resend_to_mds(struct inode *inode,\r\nstruct list_head *head,\r\nconst struct nfs_pgio_completion_ops *compl_ops,\r\nstruct nfs_direct_req *dreq)\r\n{\r\nstruct nfs_pageio_descriptor pgio;\r\nLIST_HEAD(failed);\r\nnfs_pageio_init_read(&pgio, inode, compl_ops);\r\npgio.pg_dreq = dreq;\r\nwhile (!list_empty(head)) {\r\nstruct nfs_page *req = nfs_list_entry(head->next);\r\nnfs_list_remove_request(req);\r\nif (!nfs_pageio_add_request(&pgio, req))\r\nnfs_list_add_request(req, &failed);\r\n}\r\nnfs_pageio_complete(&pgio);\r\nif (!list_empty(&failed)) {\r\nlist_move(&failed, head);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pnfs_ld_handle_read_error(struct nfs_read_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\ndprintk("pnfs read error = %d\n", hdr->pnfs_error);\r\nif (NFS_SERVER(hdr->inode)->pnfs_curr_ld->flags &\r\nPNFS_LAYOUTRET_ON_ERROR) {\r\npnfs_return_layout(hdr->inode);\r\n}\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags))\r\ndata->task.tk_status = pnfs_read_done_resend_to_mds(hdr->inode,\r\n&hdr->pages,\r\nhdr->completion_ops,\r\nhdr->dreq);\r\n}\r\nvoid pnfs_ld_read_done(struct nfs_read_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\ntrace_nfs4_pnfs_read(data, hdr->pnfs_error);\r\nif (likely(!hdr->pnfs_error)) {\r\n__nfs4_read_done_cb(data);\r\nhdr->mds_ops->rpc_call_done(&data->task, data);\r\n} else\r\npnfs_ld_handle_read_error(data);\r\nhdr->mds_ops->rpc_release(data);\r\n}\r\nstatic void\r\npnfs_read_through_mds(struct nfs_pageio_descriptor *desc,\r\nstruct nfs_read_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\nlist_splice_tail_init(&hdr->pages, &desc->pg_list);\r\nnfs_pageio_reset_read_mds(desc);\r\ndesc->pg_recoalesce = 1;\r\n}\r\nnfs_readdata_release(data);\r\n}\r\nstatic enum pnfs_try_status\r\npnfs_try_to_read_data(struct nfs_read_data *rdata,\r\nconst struct rpc_call_ops *call_ops,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct nfs_pgio_header *hdr = rdata->header;\r\nstruct inode *inode = hdr->inode;\r\nstruct nfs_server *nfss = NFS_SERVER(inode);\r\nenum pnfs_try_status trypnfs;\r\nhdr->mds_ops = call_ops;\r\ndprintk("%s: Reading ino:%lu %u@%llu\n",\r\n__func__, inode->i_ino, rdata->args.count, rdata->args.offset);\r\ntrypnfs = nfss->pnfs_curr_ld->read_pagelist(rdata);\r\nif (trypnfs != PNFS_NOT_ATTEMPTED)\r\nnfs_inc_stats(inode, NFSIOS_PNFS_READ);\r\ndprintk("%s End (trypnfs:%d)\n", __func__, trypnfs);\r\nreturn trypnfs;\r\n}\r\nstatic void\r\npnfs_do_multiple_reads(struct nfs_pageio_descriptor *desc, struct list_head *head)\r\n{\r\nstruct nfs_read_data *data;\r\nconst struct rpc_call_ops *call_ops = desc->pg_rpc_callops;\r\nstruct pnfs_layout_segment *lseg = desc->pg_lseg;\r\ndesc->pg_lseg = NULL;\r\nwhile (!list_empty(head)) {\r\nenum pnfs_try_status trypnfs;\r\ndata = list_first_entry(head, struct nfs_read_data, list);\r\nlist_del_init(&data->list);\r\ntrypnfs = pnfs_try_to_read_data(data, call_ops, lseg);\r\nif (trypnfs == PNFS_NOT_ATTEMPTED)\r\npnfs_read_through_mds(desc, data);\r\n}\r\npnfs_put_lseg(lseg);\r\n}\r\nstatic void pnfs_readhdr_free(struct nfs_pgio_header *hdr)\r\n{\r\npnfs_put_lseg(hdr->lseg);\r\nnfs_readhdr_free(hdr);\r\n}\r\nint\r\npnfs_generic_pg_readpages(struct nfs_pageio_descriptor *desc)\r\n{\r\nstruct nfs_read_header *rhdr;\r\nstruct nfs_pgio_header *hdr;\r\nint ret;\r\nrhdr = nfs_readhdr_alloc();\r\nif (!rhdr) {\r\ndesc->pg_completion_ops->error_cleanup(&desc->pg_list);\r\nret = -ENOMEM;\r\npnfs_put_lseg(desc->pg_lseg);\r\ndesc->pg_lseg = NULL;\r\nreturn ret;\r\n}\r\nhdr = &rhdr->header;\r\nnfs_pgheader_init(desc, hdr, pnfs_readhdr_free);\r\nhdr->lseg = pnfs_get_lseg(desc->pg_lseg);\r\natomic_inc(&hdr->refcnt);\r\nret = nfs_generic_pagein(desc, hdr);\r\nif (ret != 0) {\r\npnfs_put_lseg(desc->pg_lseg);\r\ndesc->pg_lseg = NULL;\r\n} else\r\npnfs_do_multiple_reads(desc, &hdr->rpc_list);\r\nif (atomic_dec_and_test(&hdr->refcnt))\r\nhdr->completion_ops->completion(hdr);\r\nreturn ret;\r\n}\r\nstatic void pnfs_list_write_lseg(struct inode *inode, struct list_head *listp)\r\n{\r\nstruct pnfs_layout_segment *lseg;\r\nlist_for_each_entry(lseg, &NFS_I(inode)->layout->plh_segs, pls_list) {\r\nif (lseg->pls_range.iomode == IOMODE_RW &&\r\ntest_and_clear_bit(NFS_LSEG_LAYOUTCOMMIT, &lseg->pls_flags))\r\nlist_add(&lseg->pls_lc_list, listp);\r\n}\r\n}\r\nstatic void pnfs_list_write_lseg_done(struct inode *inode, struct list_head *listp)\r\n{\r\nstruct pnfs_layout_segment *lseg, *tmp;\r\nunsigned long *bitlock = &NFS_I(inode)->flags;\r\nlist_for_each_entry_safe(lseg, tmp, listp, pls_lc_list) {\r\nlist_del_init(&lseg->pls_lc_list);\r\npnfs_put_lseg(lseg);\r\n}\r\nclear_bit_unlock(NFS_INO_LAYOUTCOMMITTING, bitlock);\r\nsmp_mb__after_clear_bit();\r\nwake_up_bit(bitlock, NFS_INO_LAYOUTCOMMITTING);\r\n}\r\nvoid pnfs_set_lo_fail(struct pnfs_layout_segment *lseg)\r\n{\r\npnfs_layout_io_set_failed(lseg->pls_layout, lseg->pls_range.iomode);\r\n}\r\nvoid\r\npnfs_set_layoutcommit(struct nfs_write_data *wdata)\r\n{\r\nstruct nfs_pgio_header *hdr = wdata->header;\r\nstruct inode *inode = hdr->inode;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nloff_t end_pos = wdata->mds_offset + wdata->res.count;\r\nbool mark_as_dirty = false;\r\nspin_lock(&inode->i_lock);\r\nif (!test_and_set_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\r\nmark_as_dirty = true;\r\ndprintk("%s: Set layoutcommit for inode %lu ",\r\n__func__, inode->i_ino);\r\n}\r\nif (!test_and_set_bit(NFS_LSEG_LAYOUTCOMMIT, &hdr->lseg->pls_flags)) {\r\npnfs_get_lseg(hdr->lseg);\r\n}\r\nif (end_pos > nfsi->layout->plh_lwb)\r\nnfsi->layout->plh_lwb = end_pos;\r\nspin_unlock(&inode->i_lock);\r\ndprintk("%s: lseg %p end_pos %llu\n",\r\n__func__, hdr->lseg, nfsi->layout->plh_lwb);\r\nif (mark_as_dirty)\r\nmark_inode_dirty_sync(inode);\r\n}\r\nvoid pnfs_cleanup_layoutcommit(struct nfs4_layoutcommit_data *data)\r\n{\r\nstruct nfs_server *nfss = NFS_SERVER(data->args.inode);\r\nif (nfss->pnfs_curr_ld->cleanup_layoutcommit)\r\nnfss->pnfs_curr_ld->cleanup_layoutcommit(data);\r\npnfs_list_write_lseg_done(data->args.inode, &data->lseg_list);\r\n}\r\nint\r\npnfs_layoutcommit_inode(struct inode *inode, bool sync)\r\n{\r\nstruct nfs4_layoutcommit_data *data;\r\nstruct nfs_inode *nfsi = NFS_I(inode);\r\nloff_t end_pos;\r\nint status = 0;\r\ndprintk("--> %s inode %lu\n", __func__, inode->i_ino);\r\nif (!test_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\r\nreturn 0;\r\ndata = kzalloc(sizeof(*data), GFP_NOFS);\r\nif (!data) {\r\nstatus = -ENOMEM;\r\ngoto out;\r\n}\r\nif (!test_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags))\r\ngoto out_free;\r\nif (test_and_set_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags)) {\r\nif (!sync) {\r\nstatus = -EAGAIN;\r\ngoto out_free;\r\n}\r\nstatus = wait_on_bit_lock(&nfsi->flags, NFS_INO_LAYOUTCOMMITTING,\r\nnfs_wait_bit_killable, TASK_KILLABLE);\r\nif (status)\r\ngoto out_free;\r\n}\r\nINIT_LIST_HEAD(&data->lseg_list);\r\nspin_lock(&inode->i_lock);\r\nif (!test_and_clear_bit(NFS_INO_LAYOUTCOMMIT, &nfsi->flags)) {\r\nclear_bit(NFS_INO_LAYOUTCOMMITTING, &nfsi->flags);\r\nspin_unlock(&inode->i_lock);\r\nwake_up_bit(&nfsi->flags, NFS_INO_LAYOUTCOMMITTING);\r\ngoto out_free;\r\n}\r\npnfs_list_write_lseg(inode, &data->lseg_list);\r\nend_pos = nfsi->layout->plh_lwb;\r\nnfsi->layout->plh_lwb = 0;\r\nnfs4_stateid_copy(&data->args.stateid, &nfsi->layout->plh_stateid);\r\nspin_unlock(&inode->i_lock);\r\ndata->args.inode = inode;\r\ndata->cred = get_rpccred(nfsi->layout->plh_lc_cred);\r\nnfs_fattr_init(&data->fattr);\r\ndata->args.bitmask = NFS_SERVER(inode)->cache_consistency_bitmask;\r\ndata->res.fattr = &data->fattr;\r\ndata->args.lastbytewritten = end_pos - 1;\r\ndata->res.server = NFS_SERVER(inode);\r\nstatus = nfs4_proc_layoutcommit(data, sync);\r\nout:\r\nif (status)\r\nmark_inode_dirty_sync(inode);\r\ndprintk("<-- %s status %d\n", __func__, status);\r\nreturn status;\r\nout_free:\r\nkfree(data);\r\ngoto out;\r\n}\r\nstruct nfs4_threshold *pnfs_mdsthreshold_alloc(void)\r\n{\r\nstruct nfs4_threshold *thp;\r\nthp = kzalloc(sizeof(*thp), GFP_NOFS);\r\nif (!thp) {\r\ndprintk("%s mdsthreshold allocation failed\n", __func__);\r\nreturn NULL;\r\n}\r\nreturn thp;\r\n}
