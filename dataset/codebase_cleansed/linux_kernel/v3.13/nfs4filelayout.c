static loff_t\r\nfilelayout_get_dense_offset(struct nfs4_filelayout_segment *flseg,\r\nloff_t offset)\r\n{\r\nu32 stripe_width = flseg->stripe_unit * flseg->dsaddr->stripe_count;\r\nu64 stripe_no;\r\nu32 rem;\r\noffset -= flseg->pattern_offset;\r\nstripe_no = div_u64(offset, stripe_width);\r\ndiv_u64_rem(offset, flseg->stripe_unit, &rem);\r\nreturn stripe_no * flseg->stripe_unit + rem;\r\n}\r\nstatic loff_t\r\nfilelayout_get_dserver_offset(struct pnfs_layout_segment *lseg, loff_t offset)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nswitch (flseg->stripe_type) {\r\ncase STRIPE_SPARSE:\r\nreturn offset;\r\ncase STRIPE_DENSE:\r\nreturn filelayout_get_dense_offset(flseg, offset);\r\n}\r\nBUG();\r\n}\r\nstatic void filelayout_reset_write(struct nfs_write_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nstruct rpc_task *task = &data->task;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\ndprintk("%s Reset task %5u for i/o through MDS "\r\n"(req %s/%lld, %u bytes @ offset %llu)\n", __func__,\r\ndata->task.tk_pid,\r\nhdr->inode->i_sb->s_id,\r\n(long long)NFS_FILEID(hdr->inode),\r\ndata->args.count,\r\n(unsigned long long)data->args.offset);\r\ntask->tk_status = pnfs_write_done_resend_to_mds(hdr->inode,\r\n&hdr->pages,\r\nhdr->completion_ops,\r\nhdr->dreq);\r\n}\r\n}\r\nstatic void filelayout_reset_read(struct nfs_read_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nstruct rpc_task *task = &data->task;\r\nif (!test_and_set_bit(NFS_IOHDR_REDO, &hdr->flags)) {\r\ndprintk("%s Reset task %5u for i/o through MDS "\r\n"(req %s/%lld, %u bytes @ offset %llu)\n", __func__,\r\ndata->task.tk_pid,\r\nhdr->inode->i_sb->s_id,\r\n(long long)NFS_FILEID(hdr->inode),\r\ndata->args.count,\r\n(unsigned long long)data->args.offset);\r\ntask->tk_status = pnfs_read_done_resend_to_mds(hdr->inode,\r\n&hdr->pages,\r\nhdr->completion_ops,\r\nhdr->dreq);\r\n}\r\n}\r\nstatic void filelayout_fenceme(struct inode *inode, struct pnfs_layout_hdr *lo)\r\n{\r\nif (!test_and_clear_bit(NFS_LAYOUT_RETURN, &lo->plh_flags))\r\nreturn;\r\npnfs_return_layout(inode);\r\n}\r\nstatic int filelayout_async_handle_error(struct rpc_task *task,\r\nstruct nfs4_state *state,\r\nstruct nfs_client *clp,\r\nstruct pnfs_layout_segment *lseg)\r\n{\r\nstruct pnfs_layout_hdr *lo = lseg->pls_layout;\r\nstruct inode *inode = lo->plh_inode;\r\nstruct nfs_server *mds_server = NFS_SERVER(inode);\r\nstruct nfs4_deviceid_node *devid = FILELAYOUT_DEVID_NODE(lseg);\r\nstruct nfs_client *mds_client = mds_server->nfs_client;\r\nstruct nfs4_slot_table *tbl = &clp->cl_session->fc_slot_table;\r\nif (task->tk_status >= 0)\r\nreturn 0;\r\nswitch (task->tk_status) {\r\ncase -NFS4ERR_DELEG_REVOKED:\r\ncase -NFS4ERR_ADMIN_REVOKED:\r\ncase -NFS4ERR_BAD_STATEID:\r\nif (state == NULL)\r\nbreak;\r\nnfs_remove_bad_delegation(state->inode);\r\ncase -NFS4ERR_OPENMODE:\r\nif (state == NULL)\r\nbreak;\r\nif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\r\ngoto out_bad_stateid;\r\ngoto wait_on_recovery;\r\ncase -NFS4ERR_EXPIRED:\r\nif (state != NULL) {\r\nif (nfs4_schedule_stateid_recovery(mds_server, state) < 0)\r\ngoto out_bad_stateid;\r\n}\r\nnfs4_schedule_lease_recovery(mds_client);\r\ngoto wait_on_recovery;\r\ncase -NFS4ERR_BADSESSION:\r\ncase -NFS4ERR_BADSLOT:\r\ncase -NFS4ERR_BAD_HIGH_SLOT:\r\ncase -NFS4ERR_DEADSESSION:\r\ncase -NFS4ERR_CONN_NOT_BOUND_TO_SESSION:\r\ncase -NFS4ERR_SEQ_FALSE_RETRY:\r\ncase -NFS4ERR_SEQ_MISORDERED:\r\ndprintk("%s ERROR %d, Reset session. Exchangeid "\r\n"flags 0x%x\n", __func__, task->tk_status,\r\nclp->cl_exchange_flags);\r\nnfs4_schedule_session_recovery(clp->cl_session, task->tk_status);\r\nbreak;\r\ncase -NFS4ERR_DELAY:\r\ncase -NFS4ERR_GRACE:\r\nrpc_delay(task, FILELAYOUT_POLL_RETRY_MAX);\r\nbreak;\r\ncase -NFS4ERR_RETRY_UNCACHED_REP:\r\nbreak;\r\ncase -NFS4ERR_PNFS_NO_LAYOUT:\r\ncase -ESTALE:\r\ncase -EBADHANDLE:\r\ncase -EISDIR:\r\ncase -NFS4ERR_FHEXPIRED:\r\ncase -NFS4ERR_WRONG_TYPE:\r\ndprintk("%s Invalid layout error %d\n", __func__,\r\ntask->tk_status);\r\npnfs_destroy_layout(NFS_I(inode));\r\nrpc_wake_up(&tbl->slot_tbl_waitq);\r\ngoto reset;\r\ncase -ECONNREFUSED:\r\ncase -EHOSTDOWN:\r\ncase -EHOSTUNREACH:\r\ncase -ENETUNREACH:\r\ncase -EIO:\r\ncase -ETIMEDOUT:\r\ncase -EPIPE:\r\ndprintk("%s DS connection error %d\n", __func__,\r\ntask->tk_status);\r\nnfs4_mark_deviceid_unavailable(devid);\r\nset_bit(NFS_LAYOUT_RETURN, &lo->plh_flags);\r\nrpc_wake_up(&tbl->slot_tbl_waitq);\r\ndefault:\r\nreset:\r\ndprintk("%s Retry through MDS. Error %d\n", __func__,\r\ntask->tk_status);\r\nreturn -NFS4ERR_RESET_TO_MDS;\r\n}\r\nout:\r\ntask->tk_status = 0;\r\nreturn -EAGAIN;\r\nout_bad_stateid:\r\ntask->tk_status = -EIO;\r\nreturn 0;\r\nwait_on_recovery:\r\nrpc_sleep_on(&mds_client->cl_rpcwaitq, task, NULL);\r\nif (test_bit(NFS4CLNT_MANAGER_RUNNING, &mds_client->cl_state) == 0)\r\nrpc_wake_up_queued_task(&mds_client->cl_rpcwaitq, task);\r\ngoto out;\r\n}\r\nstatic int filelayout_read_done_cb(struct rpc_task *task,\r\nstruct nfs_read_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nint err;\r\ntrace_nfs4_pnfs_read(data, task->tk_status);\r\nerr = filelayout_async_handle_error(task, data->args.context->state,\r\ndata->ds_clp, hdr->lseg);\r\nswitch (err) {\r\ncase -NFS4ERR_RESET_TO_MDS:\r\nfilelayout_reset_read(data);\r\nreturn task->tk_status;\r\ncase -EAGAIN:\r\nrpc_restart_call_prepare(task);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nfilelayout_set_layoutcommit(struct nfs_write_data *wdata)\r\n{\r\nstruct nfs_pgio_header *hdr = wdata->header;\r\nif (FILELAYOUT_LSEG(hdr->lseg)->commit_through_mds ||\r\nwdata->res.verf->committed == NFS_FILE_SYNC)\r\nreturn;\r\npnfs_set_layoutcommit(wdata);\r\ndprintk("%s ionde %lu pls_end_pos %lu\n", __func__, hdr->inode->i_ino,\r\n(unsigned long) NFS_I(hdr->inode)->layout->plh_lwb);\r\n}\r\nbool\r\nfilelayout_test_devid_unavailable(struct nfs4_deviceid_node *node)\r\n{\r\nreturn filelayout_test_devid_invalid(node) ||\r\nnfs4_test_deviceid_unavailable(node);\r\n}\r\nstatic bool\r\nfilelayout_reset_to_mds(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct nfs4_deviceid_node *node = FILELAYOUT_DEVID_NODE(lseg);\r\nreturn filelayout_test_devid_unavailable(node);\r\n}\r\nstatic void filelayout_read_prepare(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_read_data *rdata = data;\r\nif (unlikely(test_bit(NFS_CONTEXT_BAD, &rdata->args.context->flags))) {\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (filelayout_reset_to_mds(rdata->header->lseg)) {\r\ndprintk("%s task %u reset io to MDS\n", __func__, task->tk_pid);\r\nfilelayout_reset_read(rdata);\r\nrpc_exit(task, 0);\r\nreturn;\r\n}\r\nrdata->read_done_cb = filelayout_read_done_cb;\r\nif (nfs41_setup_sequence(rdata->ds_clp->cl_session,\r\n&rdata->args.seq_args,\r\n&rdata->res.seq_res,\r\ntask))\r\nreturn;\r\nnfs4_set_rw_stateid(&rdata->args.stateid, rdata->args.context,\r\nrdata->args.lock_context, FMODE_READ);\r\n}\r\nstatic void filelayout_read_call_done(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_read_data *rdata = data;\r\ndprintk("--> %s task->tk_status %d\n", __func__, task->tk_status);\r\nif (test_bit(NFS_IOHDR_REDO, &rdata->header->flags) &&\r\ntask->tk_status == 0)\r\nreturn;\r\nrdata->header->mds_ops->rpc_call_done(task, data);\r\n}\r\nstatic void filelayout_read_count_stats(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_read_data *rdata = data;\r\nrpc_count_iostats(task, NFS_SERVER(rdata->header->inode)->client->cl_metrics);\r\n}\r\nstatic void filelayout_read_release(void *data)\r\n{\r\nstruct nfs_read_data *rdata = data;\r\nstruct pnfs_layout_hdr *lo = rdata->header->lseg->pls_layout;\r\nfilelayout_fenceme(lo->plh_inode, lo);\r\nnfs_put_client(rdata->ds_clp);\r\nrdata->header->mds_ops->rpc_release(data);\r\n}\r\nstatic int filelayout_write_done_cb(struct rpc_task *task,\r\nstruct nfs_write_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nint err;\r\ntrace_nfs4_pnfs_write(data, task->tk_status);\r\nerr = filelayout_async_handle_error(task, data->args.context->state,\r\ndata->ds_clp, hdr->lseg);\r\nswitch (err) {\r\ncase -NFS4ERR_RESET_TO_MDS:\r\nfilelayout_reset_write(data);\r\nreturn task->tk_status;\r\ncase -EAGAIN:\r\nrpc_restart_call_prepare(task);\r\nreturn -EAGAIN;\r\n}\r\nfilelayout_set_layoutcommit(data);\r\nreturn 0;\r\n}\r\nstatic void prepare_to_resend_writes(struct nfs_commit_data *data)\r\n{\r\nstruct nfs_page *first = nfs_list_entry(data->pages.next);\r\ndata->task.tk_status = 0;\r\nmemcpy(&data->verf.verifier, &first->wb_verf,\r\nsizeof(data->verf.verifier));\r\ndata->verf.verifier.data[0]++;\r\n}\r\nstatic int filelayout_commit_done_cb(struct rpc_task *task,\r\nstruct nfs_commit_data *data)\r\n{\r\nint err;\r\ntrace_nfs4_pnfs_commit_ds(data, task->tk_status);\r\nerr = filelayout_async_handle_error(task, NULL, data->ds_clp,\r\ndata->lseg);\r\nswitch (err) {\r\ncase -NFS4ERR_RESET_TO_MDS:\r\nprepare_to_resend_writes(data);\r\nreturn -EAGAIN;\r\ncase -EAGAIN:\r\nrpc_restart_call_prepare(task);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nstatic void filelayout_write_prepare(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_write_data *wdata = data;\r\nif (unlikely(test_bit(NFS_CONTEXT_BAD, &wdata->args.context->flags))) {\r\nrpc_exit(task, -EIO);\r\nreturn;\r\n}\r\nif (filelayout_reset_to_mds(wdata->header->lseg)) {\r\ndprintk("%s task %u reset io to MDS\n", __func__, task->tk_pid);\r\nfilelayout_reset_write(wdata);\r\nrpc_exit(task, 0);\r\nreturn;\r\n}\r\nif (nfs41_setup_sequence(wdata->ds_clp->cl_session,\r\n&wdata->args.seq_args,\r\n&wdata->res.seq_res,\r\ntask))\r\nreturn;\r\nnfs4_set_rw_stateid(&wdata->args.stateid, wdata->args.context,\r\nwdata->args.lock_context, FMODE_WRITE);\r\n}\r\nstatic void filelayout_write_call_done(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_write_data *wdata = data;\r\nif (test_bit(NFS_IOHDR_REDO, &wdata->header->flags) &&\r\ntask->tk_status == 0)\r\nreturn;\r\nwdata->header->mds_ops->rpc_call_done(task, data);\r\n}\r\nstatic void filelayout_write_count_stats(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_write_data *wdata = data;\r\nrpc_count_iostats(task, NFS_SERVER(wdata->header->inode)->client->cl_metrics);\r\n}\r\nstatic void filelayout_write_release(void *data)\r\n{\r\nstruct nfs_write_data *wdata = data;\r\nstruct pnfs_layout_hdr *lo = wdata->header->lseg->pls_layout;\r\nfilelayout_fenceme(lo->plh_inode, lo);\r\nnfs_put_client(wdata->ds_clp);\r\nwdata->header->mds_ops->rpc_release(data);\r\n}\r\nstatic void filelayout_commit_prepare(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_commit_data *wdata = data;\r\nnfs41_setup_sequence(wdata->ds_clp->cl_session,\r\n&wdata->args.seq_args,\r\n&wdata->res.seq_res,\r\ntask);\r\n}\r\nstatic void filelayout_write_commit_done(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_commit_data *wdata = data;\r\nwdata->mds_ops->rpc_call_done(task, data);\r\n}\r\nstatic void filelayout_commit_count_stats(struct rpc_task *task, void *data)\r\n{\r\nstruct nfs_commit_data *cdata = data;\r\nrpc_count_iostats(task, NFS_SERVER(cdata->inode)->client->cl_metrics);\r\n}\r\nstatic void filelayout_commit_release(void *calldata)\r\n{\r\nstruct nfs_commit_data *data = calldata;\r\ndata->completion_ops->completion(data);\r\npnfs_put_lseg(data->lseg);\r\nnfs_put_client(data->ds_clp);\r\nnfs_commitdata_release(data);\r\n}\r\nstatic enum pnfs_try_status\r\nfilelayout_read_pagelist(struct nfs_read_data *data)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nstruct pnfs_layout_segment *lseg = hdr->lseg;\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct rpc_clnt *ds_clnt;\r\nloff_t offset = data->args.offset;\r\nu32 j, idx;\r\nstruct nfs_fh *fh;\r\ndprintk("--> %s ino %lu pgbase %u req %Zu@%llu\n",\r\n__func__, hdr->inode->i_ino,\r\ndata->args.pgbase, (size_t)data->args.count, offset);\r\nj = nfs4_fl_calc_j_index(lseg, offset);\r\nidx = nfs4_fl_calc_ds_index(lseg, j);\r\nds = nfs4_fl_prepare_ds(lseg, idx);\r\nif (!ds)\r\nreturn PNFS_NOT_ATTEMPTED;\r\nds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\r\nif (IS_ERR(ds_clnt))\r\nreturn PNFS_NOT_ATTEMPTED;\r\ndprintk("%s USE DS: %s cl_count %d\n", __func__,\r\nds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\r\natomic_inc(&ds->ds_clp->cl_count);\r\ndata->ds_clp = ds->ds_clp;\r\nfh = nfs4_fl_select_ds_fh(lseg, j);\r\nif (fh)\r\ndata->args.fh = fh;\r\ndata->args.offset = filelayout_get_dserver_offset(lseg, offset);\r\ndata->mds_offset = offset;\r\nnfs_initiate_read(ds_clnt, data,\r\n&filelayout_read_call_ops, RPC_TASK_SOFTCONN);\r\nreturn PNFS_ATTEMPTED;\r\n}\r\nstatic enum pnfs_try_status\r\nfilelayout_write_pagelist(struct nfs_write_data *data, int sync)\r\n{\r\nstruct nfs_pgio_header *hdr = data->header;\r\nstruct pnfs_layout_segment *lseg = hdr->lseg;\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct rpc_clnt *ds_clnt;\r\nloff_t offset = data->args.offset;\r\nu32 j, idx;\r\nstruct nfs_fh *fh;\r\nj = nfs4_fl_calc_j_index(lseg, offset);\r\nidx = nfs4_fl_calc_ds_index(lseg, j);\r\nds = nfs4_fl_prepare_ds(lseg, idx);\r\nif (!ds)\r\nreturn PNFS_NOT_ATTEMPTED;\r\nds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, hdr->inode);\r\nif (IS_ERR(ds_clnt))\r\nreturn PNFS_NOT_ATTEMPTED;\r\ndprintk("%s ino %lu sync %d req %Zu@%llu DS: %s cl_count %d\n",\r\n__func__, hdr->inode->i_ino, sync, (size_t) data->args.count,\r\noffset, ds->ds_remotestr, atomic_read(&ds->ds_clp->cl_count));\r\ndata->write_done_cb = filelayout_write_done_cb;\r\natomic_inc(&ds->ds_clp->cl_count);\r\ndata->ds_clp = ds->ds_clp;\r\nfh = nfs4_fl_select_ds_fh(lseg, j);\r\nif (fh)\r\ndata->args.fh = fh;\r\ndata->args.offset = filelayout_get_dserver_offset(lseg, offset);\r\nnfs_initiate_write(ds_clnt, data,\r\n&filelayout_write_call_ops, sync,\r\nRPC_TASK_SOFTCONN);\r\nreturn PNFS_ATTEMPTED;\r\n}\r\nstatic int\r\nfilelayout_check_layout(struct pnfs_layout_hdr *lo,\r\nstruct nfs4_filelayout_segment *fl,\r\nstruct nfs4_layoutget_res *lgr,\r\nstruct nfs4_deviceid *id,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_deviceid_node *d;\r\nstruct nfs4_file_layout_dsaddr *dsaddr;\r\nint status = -EINVAL;\r\nstruct nfs_server *nfss = NFS_SERVER(lo->plh_inode);\r\ndprintk("--> %s\n", __func__);\r\nif (lgr->range.offset != 0 ||\r\nlgr->range.length != NFS4_MAX_UINT64) {\r\ndprintk("%s Only whole file layouts supported. Use MDS i/o\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (fl->pattern_offset > lgr->range.offset) {\r\ndprintk("%s pattern_offset %lld too large\n",\r\n__func__, fl->pattern_offset);\r\ngoto out;\r\n}\r\nif (!fl->stripe_unit || fl->stripe_unit % PAGE_SIZE) {\r\ndprintk("%s Invalid stripe unit (%u)\n",\r\n__func__, fl->stripe_unit);\r\ngoto out;\r\n}\r\nd = nfs4_find_get_deviceid(NFS_SERVER(lo->plh_inode)->pnfs_curr_ld,\r\nNFS_SERVER(lo->plh_inode)->nfs_client, id);\r\nif (d == NULL) {\r\ndsaddr = filelayout_get_device_info(lo->plh_inode, id,\r\nlo->plh_lc_cred, gfp_flags);\r\nif (dsaddr == NULL)\r\ngoto out;\r\n} else\r\ndsaddr = container_of(d, struct nfs4_file_layout_dsaddr, id_node);\r\nif (filelayout_test_devid_unavailable(&dsaddr->id_node))\r\ngoto out_put;\r\nfl->dsaddr = dsaddr;\r\nif (fl->first_stripe_index >= dsaddr->stripe_count) {\r\ndprintk("%s Bad first_stripe_index %u\n",\r\n__func__, fl->first_stripe_index);\r\ngoto out_put;\r\n}\r\nif ((fl->stripe_type == STRIPE_SPARSE &&\r\nfl->num_fh > 1 && fl->num_fh != dsaddr->ds_num) ||\r\n(fl->stripe_type == STRIPE_DENSE &&\r\nfl->num_fh != dsaddr->stripe_count)) {\r\ndprintk("%s num_fh %u not valid for given packing\n",\r\n__func__, fl->num_fh);\r\ngoto out_put;\r\n}\r\nif (fl->stripe_unit % nfss->rsize || fl->stripe_unit % nfss->wsize) {\r\ndprintk("%s Stripe unit (%u) not aligned with rsize %u "\r\n"wsize %u\n", __func__, fl->stripe_unit, nfss->rsize,\r\nnfss->wsize);\r\n}\r\nstatus = 0;\r\nout:\r\ndprintk("--> %s returns %d\n", __func__, status);\r\nreturn status;\r\nout_put:\r\nnfs4_fl_put_deviceid(dsaddr);\r\ngoto out;\r\n}\r\nstatic void filelayout_free_fh_array(struct nfs4_filelayout_segment *fl)\r\n{\r\nint i;\r\nfor (i = 0; i < fl->num_fh; i++) {\r\nif (!fl->fh_array[i])\r\nbreak;\r\nkfree(fl->fh_array[i]);\r\n}\r\nkfree(fl->fh_array);\r\nfl->fh_array = NULL;\r\n}\r\nstatic void\r\n_filelayout_free_lseg(struct nfs4_filelayout_segment *fl)\r\n{\r\nfilelayout_free_fh_array(fl);\r\nkfree(fl);\r\n}\r\nstatic int\r\nfilelayout_decode_layout(struct pnfs_layout_hdr *flo,\r\nstruct nfs4_filelayout_segment *fl,\r\nstruct nfs4_layoutget_res *lgr,\r\nstruct nfs4_deviceid *id,\r\ngfp_t gfp_flags)\r\n{\r\nstruct xdr_stream stream;\r\nstruct xdr_buf buf;\r\nstruct page *scratch;\r\n__be32 *p;\r\nuint32_t nfl_util;\r\nint i;\r\ndprintk("%s: set_layout_map Begin\n", __func__);\r\nscratch = alloc_page(gfp_flags);\r\nif (!scratch)\r\nreturn -ENOMEM;\r\nxdr_init_decode_pages(&stream, &buf, lgr->layoutp->pages, lgr->layoutp->len);\r\nxdr_set_scratch_buffer(&stream, page_address(scratch), PAGE_SIZE);\r\np = xdr_inline_decode(&stream, NFS4_DEVICEID4_SIZE + 20);\r\nif (unlikely(!p))\r\ngoto out_err;\r\nmemcpy(id, p, sizeof(*id));\r\np += XDR_QUADLEN(NFS4_DEVICEID4_SIZE);\r\nnfs4_print_deviceid(id);\r\nnfl_util = be32_to_cpup(p++);\r\nif (nfl_util & NFL4_UFLG_COMMIT_THRU_MDS)\r\nfl->commit_through_mds = 1;\r\nif (nfl_util & NFL4_UFLG_DENSE)\r\nfl->stripe_type = STRIPE_DENSE;\r\nelse\r\nfl->stripe_type = STRIPE_SPARSE;\r\nfl->stripe_unit = nfl_util & ~NFL4_UFLG_MASK;\r\nfl->first_stripe_index = be32_to_cpup(p++);\r\np = xdr_decode_hyper(p, &fl->pattern_offset);\r\nfl->num_fh = be32_to_cpup(p++);\r\ndprintk("%s: nfl_util 0x%X num_fh %u fsi %u po %llu\n",\r\n__func__, nfl_util, fl->num_fh, fl->first_stripe_index,\r\nfl->pattern_offset);\r\nif (fl->num_fh >\r\nmax(NFS4_PNFS_MAX_STRIPE_CNT, NFS4_PNFS_MAX_MULTI_CNT))\r\ngoto out_err;\r\nif (fl->num_fh > 0) {\r\nfl->fh_array = kcalloc(fl->num_fh, sizeof(fl->fh_array[0]),\r\ngfp_flags);\r\nif (!fl->fh_array)\r\ngoto out_err;\r\n}\r\nfor (i = 0; i < fl->num_fh; i++) {\r\nfl->fh_array[i] = kmalloc(sizeof(struct nfs_fh), gfp_flags);\r\nif (!fl->fh_array[i])\r\ngoto out_err_free;\r\np = xdr_inline_decode(&stream, 4);\r\nif (unlikely(!p))\r\ngoto out_err_free;\r\nfl->fh_array[i]->size = be32_to_cpup(p++);\r\nif (sizeof(struct nfs_fh) < fl->fh_array[i]->size) {\r\nprintk(KERN_ERR "NFS: Too big fh %d received %d\n",\r\ni, fl->fh_array[i]->size);\r\ngoto out_err_free;\r\n}\r\np = xdr_inline_decode(&stream, fl->fh_array[i]->size);\r\nif (unlikely(!p))\r\ngoto out_err_free;\r\nmemcpy(fl->fh_array[i]->data, p, fl->fh_array[i]->size);\r\ndprintk("DEBUG: %s: fh len %d\n", __func__,\r\nfl->fh_array[i]->size);\r\n}\r\n__free_page(scratch);\r\nreturn 0;\r\nout_err_free:\r\nfilelayout_free_fh_array(fl);\r\nout_err:\r\n__free_page(scratch);\r\nreturn -EIO;\r\n}\r\nstatic void\r\nfilelayout_free_lseg(struct pnfs_layout_segment *lseg)\r\n{\r\nstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\r\ndprintk("--> %s\n", __func__);\r\nnfs4_fl_put_deviceid(fl->dsaddr);\r\nif (lseg->pls_range.iomode == IOMODE_RW) {\r\nstruct nfs4_filelayout *flo;\r\nflo = FILELAYOUT_FROM_HDR(lseg->pls_layout);\r\nflo->commit_info.nbuckets = 0;\r\nkfree(flo->commit_info.buckets);\r\nflo->commit_info.buckets = NULL;\r\n}\r\n_filelayout_free_lseg(fl);\r\n}\r\nstatic int\r\nfilelayout_alloc_commit_info(struct pnfs_layout_segment *lseg,\r\nstruct nfs_commit_info *cinfo,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\r\nstruct pnfs_commit_bucket *buckets;\r\nint size;\r\nif (fl->commit_through_mds)\r\nreturn 0;\r\nif (cinfo->ds->nbuckets != 0) {\r\nreturn 0;\r\n}\r\nsize = (fl->stripe_type == STRIPE_SPARSE) ?\r\nfl->dsaddr->ds_num : fl->dsaddr->stripe_count;\r\nbuckets = kcalloc(size, sizeof(struct pnfs_commit_bucket),\r\ngfp_flags);\r\nif (!buckets)\r\nreturn -ENOMEM;\r\nelse {\r\nint i;\r\nspin_lock(cinfo->lock);\r\nif (cinfo->ds->nbuckets != 0)\r\nkfree(buckets);\r\nelse {\r\ncinfo->ds->buckets = buckets;\r\ncinfo->ds->nbuckets = size;\r\nfor (i = 0; i < size; i++) {\r\nINIT_LIST_HEAD(&buckets[i].written);\r\nINIT_LIST_HEAD(&buckets[i].committing);\r\n}\r\n}\r\nspin_unlock(cinfo->lock);\r\nreturn 0;\r\n}\r\n}\r\nstatic struct pnfs_layout_segment *\r\nfilelayout_alloc_lseg(struct pnfs_layout_hdr *layoutid,\r\nstruct nfs4_layoutget_res *lgr,\r\ngfp_t gfp_flags)\r\n{\r\nstruct nfs4_filelayout_segment *fl;\r\nint rc;\r\nstruct nfs4_deviceid id;\r\ndprintk("--> %s\n", __func__);\r\nfl = kzalloc(sizeof(*fl), gfp_flags);\r\nif (!fl)\r\nreturn NULL;\r\nrc = filelayout_decode_layout(layoutid, fl, lgr, &id, gfp_flags);\r\nif (rc != 0 || filelayout_check_layout(layoutid, fl, lgr, &id, gfp_flags)) {\r\n_filelayout_free_lseg(fl);\r\nreturn NULL;\r\n}\r\nreturn &fl->generic_hdr;\r\n}\r\nstatic bool\r\nfilelayout_pg_test(struct nfs_pageio_descriptor *pgio, struct nfs_page *prev,\r\nstruct nfs_page *req)\r\n{\r\nu64 p_stripe, r_stripe;\r\nu32 stripe_unit;\r\nif (!pnfs_generic_pg_test(pgio, prev, req) ||\r\n!nfs_generic_pg_test(pgio, prev, req))\r\nreturn false;\r\np_stripe = (u64)req_offset(prev);\r\nr_stripe = (u64)req_offset(req);\r\nstripe_unit = FILELAYOUT_LSEG(pgio->pg_lseg)->stripe_unit;\r\ndo_div(p_stripe, stripe_unit);\r\ndo_div(r_stripe, stripe_unit);\r\nreturn (p_stripe == r_stripe);\r\n}\r\nstatic void\r\nfilelayout_pg_init_read(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *req)\r\n{\r\nWARN_ON_ONCE(pgio->pg_lseg != NULL);\r\nif (req->wb_offset != req->wb_pgbase) {\r\nnfs_pageio_reset_read_mds(pgio);\r\nreturn;\r\n}\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\n0,\r\nNFS4_MAX_UINT64,\r\nIOMODE_READ,\r\nGFP_KERNEL);\r\nif (pgio->pg_lseg == NULL)\r\nnfs_pageio_reset_read_mds(pgio);\r\n}\r\nstatic void\r\nfilelayout_pg_init_write(struct nfs_pageio_descriptor *pgio,\r\nstruct nfs_page *req)\r\n{\r\nstruct nfs_commit_info cinfo;\r\nint status;\r\nWARN_ON_ONCE(pgio->pg_lseg != NULL);\r\nif (req->wb_offset != req->wb_pgbase)\r\ngoto out_mds;\r\npgio->pg_lseg = pnfs_update_layout(pgio->pg_inode,\r\nreq->wb_context,\r\n0,\r\nNFS4_MAX_UINT64,\r\nIOMODE_RW,\r\nGFP_NOFS);\r\nif (pgio->pg_lseg == NULL)\r\ngoto out_mds;\r\nnfs_init_cinfo(&cinfo, pgio->pg_inode, pgio->pg_dreq);\r\nstatus = filelayout_alloc_commit_info(pgio->pg_lseg, &cinfo, GFP_NOFS);\r\nif (status < 0) {\r\npnfs_put_lseg(pgio->pg_lseg);\r\npgio->pg_lseg = NULL;\r\ngoto out_mds;\r\n}\r\nreturn;\r\nout_mds:\r\nnfs_pageio_reset_write_mds(pgio);\r\n}\r\nstatic u32 select_bucket_index(struct nfs4_filelayout_segment *fl, u32 j)\r\n{\r\nif (fl->stripe_type == STRIPE_SPARSE)\r\nreturn nfs4_fl_calc_ds_index(&fl->generic_hdr, j);\r\nelse\r\nreturn j;\r\n}\r\nstatic void\r\nfilelayout_clear_request_commit(struct nfs_page *req,\r\nstruct nfs_commit_info *cinfo)\r\n{\r\nstruct pnfs_layout_segment *freeme = NULL;\r\nspin_lock(cinfo->lock);\r\nif (!test_and_clear_bit(PG_COMMIT_TO_DS, &req->wb_flags))\r\ngoto out;\r\ncinfo->ds->nwritten--;\r\nif (list_is_singular(&req->wb_list)) {\r\nstruct pnfs_commit_bucket *bucket;\r\nbucket = list_first_entry(&req->wb_list,\r\nstruct pnfs_commit_bucket,\r\nwritten);\r\nfreeme = bucket->wlseg;\r\nbucket->wlseg = NULL;\r\n}\r\nout:\r\nnfs_request_remove_commit_list(req, cinfo);\r\nspin_unlock(cinfo->lock);\r\npnfs_put_lseg(freeme);\r\n}\r\nstatic struct list_head *\r\nfilelayout_choose_commit_list(struct nfs_page *req,\r\nstruct pnfs_layout_segment *lseg,\r\nstruct nfs_commit_info *cinfo)\r\n{\r\nstruct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);\r\nu32 i, j;\r\nstruct list_head *list;\r\nstruct pnfs_commit_bucket *buckets;\r\nif (fl->commit_through_mds)\r\nreturn &cinfo->mds->list;\r\nj = nfs4_fl_calc_j_index(lseg, req_offset(req));\r\ni = select_bucket_index(fl, j);\r\nbuckets = cinfo->ds->buckets;\r\nlist = &buckets[i].written;\r\nif (list_empty(list)) {\r\nbuckets[i].wlseg = pnfs_get_lseg(lseg);\r\n}\r\nset_bit(PG_COMMIT_TO_DS, &req->wb_flags);\r\ncinfo->ds->nwritten++;\r\nreturn list;\r\n}\r\nstatic void\r\nfilelayout_mark_request_commit(struct nfs_page *req,\r\nstruct pnfs_layout_segment *lseg,\r\nstruct nfs_commit_info *cinfo)\r\n{\r\nstruct list_head *list;\r\nlist = filelayout_choose_commit_list(req, lseg, cinfo);\r\nnfs_request_add_commit_list(req, list, cinfo);\r\n}\r\nstatic u32 calc_ds_index_from_commit(struct pnfs_layout_segment *lseg, u32 i)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nif (flseg->stripe_type == STRIPE_SPARSE)\r\nreturn i;\r\nelse\r\nreturn nfs4_fl_calc_ds_index(lseg, i);\r\n}\r\nstatic struct nfs_fh *\r\nselect_ds_fh_from_commit(struct pnfs_layout_segment *lseg, u32 i)\r\n{\r\nstruct nfs4_filelayout_segment *flseg = FILELAYOUT_LSEG(lseg);\r\nif (flseg->stripe_type == STRIPE_SPARSE) {\r\nif (flseg->num_fh == 1)\r\ni = 0;\r\nelse if (flseg->num_fh == 0)\r\nreturn NULL;\r\n}\r\nreturn flseg->fh_array[i];\r\n}\r\nstatic int filelayout_initiate_commit(struct nfs_commit_data *data, int how)\r\n{\r\nstruct pnfs_layout_segment *lseg = data->lseg;\r\nstruct nfs4_pnfs_ds *ds;\r\nstruct rpc_clnt *ds_clnt;\r\nu32 idx;\r\nstruct nfs_fh *fh;\r\nidx = calc_ds_index_from_commit(lseg, data->ds_commit_index);\r\nds = nfs4_fl_prepare_ds(lseg, idx);\r\nif (!ds)\r\ngoto out_err;\r\nds_clnt = nfs4_find_or_create_ds_client(ds->ds_clp, data->inode);\r\nif (IS_ERR(ds_clnt))\r\ngoto out_err;\r\ndprintk("%s ino %lu, how %d cl_count %d\n", __func__,\r\ndata->inode->i_ino, how, atomic_read(&ds->ds_clp->cl_count));\r\ndata->commit_done_cb = filelayout_commit_done_cb;\r\natomic_inc(&ds->ds_clp->cl_count);\r\ndata->ds_clp = ds->ds_clp;\r\nfh = select_ds_fh_from_commit(lseg, data->ds_commit_index);\r\nif (fh)\r\ndata->args.fh = fh;\r\nreturn nfs_initiate_commit(ds_clnt, data,\r\n&filelayout_commit_call_ops, how,\r\nRPC_TASK_SOFTCONN);\r\nout_err:\r\nprepare_to_resend_writes(data);\r\nfilelayout_commit_release(data);\r\nreturn -EAGAIN;\r\n}\r\nstatic int\r\ntransfer_commit_list(struct list_head *src, struct list_head *dst,\r\nstruct nfs_commit_info *cinfo, int max)\r\n{\r\nstruct nfs_page *req, *tmp;\r\nint ret = 0;\r\nlist_for_each_entry_safe(req, tmp, src, wb_list) {\r\nif (!nfs_lock_request(req))\r\ncontinue;\r\nkref_get(&req->wb_kref);\r\nif (cond_resched_lock(cinfo->lock))\r\nlist_safe_reset_next(req, tmp, wb_list);\r\nnfs_request_remove_commit_list(req, cinfo);\r\nclear_bit(PG_COMMIT_TO_DS, &req->wb_flags);\r\nnfs_list_add_request(req, dst);\r\nret++;\r\nif ((ret == max) && !cinfo->dreq)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nfilelayout_scan_ds_commit_list(struct pnfs_commit_bucket *bucket,\r\nstruct nfs_commit_info *cinfo,\r\nint max)\r\n{\r\nstruct list_head *src = &bucket->written;\r\nstruct list_head *dst = &bucket->committing;\r\nint ret;\r\nret = transfer_commit_list(src, dst, cinfo, max);\r\nif (ret) {\r\ncinfo->ds->nwritten -= ret;\r\ncinfo->ds->ncommitting += ret;\r\nbucket->clseg = bucket->wlseg;\r\nif (list_empty(src))\r\nbucket->wlseg = NULL;\r\nelse\r\npnfs_get_lseg(bucket->clseg);\r\n}\r\nreturn ret;\r\n}\r\nstatic int filelayout_scan_commit_lists(struct nfs_commit_info *cinfo,\r\nint max)\r\n{\r\nint i, rv = 0, cnt;\r\nfor (i = 0; i < cinfo->ds->nbuckets && max != 0; i++) {\r\ncnt = filelayout_scan_ds_commit_list(&cinfo->ds->buckets[i],\r\ncinfo, max);\r\nmax -= cnt;\r\nrv += cnt;\r\n}\r\nreturn rv;\r\n}\r\nstatic void filelayout_recover_commit_reqs(struct list_head *dst,\r\nstruct nfs_commit_info *cinfo)\r\n{\r\nstruct pnfs_commit_bucket *b;\r\nint i;\r\nfor (i = 0, b = cinfo->ds->buckets; i < cinfo->ds->nbuckets; i++, b++) {\r\nif (transfer_commit_list(&b->written, dst, cinfo, 0)) {\r\npnfs_put_lseg(b->wlseg);\r\nb->wlseg = NULL;\r\n}\r\n}\r\ncinfo->ds->nwritten = 0;\r\n}\r\nstatic unsigned int\r\nalloc_ds_commits(struct nfs_commit_info *cinfo, struct list_head *list)\r\n{\r\nstruct pnfs_ds_commit_info *fl_cinfo;\r\nstruct pnfs_commit_bucket *bucket;\r\nstruct nfs_commit_data *data;\r\nint i, j;\r\nunsigned int nreq = 0;\r\nfl_cinfo = cinfo->ds;\r\nbucket = fl_cinfo->buckets;\r\nfor (i = 0; i < fl_cinfo->nbuckets; i++, bucket++) {\r\nif (list_empty(&bucket->committing))\r\ncontinue;\r\ndata = nfs_commitdata_alloc();\r\nif (!data)\r\nbreak;\r\ndata->ds_commit_index = i;\r\ndata->lseg = bucket->clseg;\r\nbucket->clseg = NULL;\r\nlist_add(&data->pages, list);\r\nnreq++;\r\n}\r\nfor (j = i; j < fl_cinfo->nbuckets; j++, bucket++) {\r\nif (list_empty(&bucket->committing))\r\ncontinue;\r\nnfs_retry_commit(&bucket->committing, bucket->clseg, cinfo);\r\npnfs_put_lseg(bucket->clseg);\r\nbucket->clseg = NULL;\r\n}\r\nreturn nreq;\r\n}\r\nstatic int\r\nfilelayout_commit_pagelist(struct inode *inode, struct list_head *mds_pages,\r\nint how, struct nfs_commit_info *cinfo)\r\n{\r\nstruct nfs_commit_data *data, *tmp;\r\nLIST_HEAD(list);\r\nunsigned int nreq = 0;\r\nif (!list_empty(mds_pages)) {\r\ndata = nfs_commitdata_alloc();\r\nif (data != NULL) {\r\ndata->lseg = NULL;\r\nlist_add(&data->pages, &list);\r\nnreq++;\r\n} else\r\nnfs_retry_commit(mds_pages, NULL, cinfo);\r\n}\r\nnreq += alloc_ds_commits(cinfo, &list);\r\nif (nreq == 0) {\r\ncinfo->completion_ops->error_cleanup(NFS_I(inode));\r\ngoto out;\r\n}\r\natomic_add(nreq, &cinfo->mds->rpcs_out);\r\nlist_for_each_entry_safe(data, tmp, &list, pages) {\r\nlist_del_init(&data->pages);\r\nif (!data->lseg) {\r\nnfs_init_commit(data, mds_pages, NULL, cinfo);\r\nnfs_initiate_commit(NFS_CLIENT(inode), data,\r\ndata->mds_ops, how, 0);\r\n} else {\r\nstruct pnfs_commit_bucket *buckets;\r\nbuckets = cinfo->ds->buckets;\r\nnfs_init_commit(data, &buckets[data->ds_commit_index].committing, data->lseg, cinfo);\r\nfilelayout_initiate_commit(data, how);\r\n}\r\n}\r\nout:\r\ncinfo->ds->ncommitting = 0;\r\nreturn PNFS_ATTEMPTED;\r\n}\r\nstatic void\r\nfilelayout_free_deveiceid_node(struct nfs4_deviceid_node *d)\r\n{\r\nnfs4_fl_free_deviceid(container_of(d, struct nfs4_file_layout_dsaddr, id_node));\r\n}\r\nstatic struct pnfs_layout_hdr *\r\nfilelayout_alloc_layout_hdr(struct inode *inode, gfp_t gfp_flags)\r\n{\r\nstruct nfs4_filelayout *flo;\r\nflo = kzalloc(sizeof(*flo), gfp_flags);\r\nreturn &flo->generic_hdr;\r\n}\r\nstatic void\r\nfilelayout_free_layout_hdr(struct pnfs_layout_hdr *lo)\r\n{\r\nkfree(FILELAYOUT_FROM_HDR(lo));\r\n}\r\nstatic struct pnfs_ds_commit_info *\r\nfilelayout_get_ds_info(struct inode *inode)\r\n{\r\nstruct pnfs_layout_hdr *layout = NFS_I(inode)->layout;\r\nif (layout == NULL)\r\nreturn NULL;\r\nelse\r\nreturn &FILELAYOUT_FROM_HDR(layout)->commit_info;\r\n}\r\nstatic int __init nfs4filelayout_init(void)\r\n{\r\nprintk(KERN_INFO "%s: NFSv4 File Layout Driver Registering...\n",\r\n__func__);\r\nreturn pnfs_register_layoutdriver(&filelayout_type);\r\n}\r\nstatic void __exit nfs4filelayout_exit(void)\r\n{\r\nprintk(KERN_INFO "%s: NFSv4 File Layout Driver Unregistering...\n",\r\n__func__);\r\npnfs_unregister_layoutdriver(&filelayout_type);\r\n}
