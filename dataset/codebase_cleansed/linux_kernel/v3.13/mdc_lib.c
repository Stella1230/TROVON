static void __mdc_pack_body(struct mdt_body *b, __u32 suppgid)\r\n{\r\nLASSERT (b != NULL);\r\nb->suppgid = suppgid;\r\nb->uid = from_kuid(&init_user_ns, current_uid());\r\nb->gid = from_kgid(&init_user_ns, current_gid());\r\nb->fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nb->fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nb->capability = cfs_curproc_cap_pack();\r\n}\r\nvoid mdc_pack_capa(struct ptlrpc_request *req, const struct req_msg_field *field,\r\nstruct obd_capa *oc)\r\n{\r\nstruct req_capsule *pill = &req->rq_pill;\r\nstruct lustre_capa *c;\r\nif (oc == NULL) {\r\nLASSERT(req_capsule_get_size(pill, field, RCL_CLIENT) == 0);\r\nreturn;\r\n}\r\nc = req_capsule_client_get(pill, field);\r\nLASSERT(c != NULL);\r\ncapa_cpy(c, oc);\r\nDEBUG_CAPA(D_SEC, c, "pack");\r\n}\r\nvoid mdc_is_subdir_pack(struct ptlrpc_request *req, const struct lu_fid *pfid,\r\nconst struct lu_fid *cfid, int flags)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nif (pfid) {\r\nb->fid1 = *pfid;\r\nb->valid = OBD_MD_FLID;\r\n}\r\nif (cfid)\r\nb->fid2 = *cfid;\r\nb->flags = flags;\r\n}\r\nvoid mdc_swap_layouts_pack(struct ptlrpc_request *req,\r\nstruct md_op_data *op_data)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\n__mdc_pack_body(b, op_data->op_suppgids[0]);\r\nb->fid1 = op_data->op_fid1;\r\nb->fid2 = op_data->op_fid2;\r\nb->valid |= OBD_MD_FLID;\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_pack_capa(req, &RMF_CAPA2, op_data->op_capa2);\r\n}\r\nvoid mdc_pack_body(struct ptlrpc_request *req,\r\nconst struct lu_fid *fid, struct obd_capa *oc,\r\n__u64 valid, int ea_size, __u32 suppgid, int flags)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nLASSERT(b != NULL);\r\nb->valid = valid;\r\nb->eadatasize = ea_size;\r\nb->flags = flags;\r\n__mdc_pack_body(b, suppgid);\r\nif (fid) {\r\nb->fid1 = *fid;\r\nb->valid |= OBD_MD_FLID;\r\nmdc_pack_capa(req, &RMF_CAPA1, oc);\r\n}\r\n}\r\nvoid mdc_readdir_pack(struct ptlrpc_request *req, __u64 pgoff,\r\n__u32 size, const struct lu_fid *fid, struct obd_capa *oc)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nb->fid1 = *fid;\r\nb->valid |= OBD_MD_FLID;\r\nb->size = pgoff;\r\nb->nlink = size;\r\n__mdc_pack_body(b, -1);\r\nb->mode = LUDA_FID | LUDA_TYPE;\r\nmdc_pack_capa(req, &RMF_CAPA1, oc);\r\n}\r\nvoid mdc_create_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\nconst void *data, int datalen, __u32 mode,\r\n__u32 uid, __u32 gid, cfs_cap_t cap_effective, __u64 rdev)\r\n{\r\nstruct mdt_rec_create *rec;\r\nchar *tmp;\r\n__u64 flags;\r\nCLASSERT(sizeof(struct mdt_rec_reint) == sizeof(struct mdt_rec_create));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->cr_opcode = REINT_CREATE;\r\nrec->cr_fsuid = uid;\r\nrec->cr_fsgid = gid;\r\nrec->cr_cap = cap_effective;\r\nrec->cr_fid1 = op_data->op_fid1;\r\nrec->cr_fid2 = op_data->op_fid2;\r\nrec->cr_mode = mode;\r\nrec->cr_rdev = rdev;\r\nrec->cr_time = op_data->op_mod_time;\r\nrec->cr_suppgid1 = op_data->op_suppgids[0];\r\nrec->cr_suppgid2 = op_data->op_suppgids[1];\r\nflags = op_data->op_flags & MF_SOM_LOCAL_FLAGS;\r\nif (op_data->op_bias & MDS_CREATE_VOLATILE)\r\nflags |= MDS_OPEN_VOLATILE;\r\nset_mrc_cr_flags(rec, flags);\r\nrec->cr_bias = op_data->op_bias;\r\nrec->cr_umask = current_umask();\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLOGL0(op_data->op_name, op_data->op_namelen, tmp);\r\nif (data) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nmemcpy(tmp, data, datalen);\r\n}\r\n}\r\nstatic __u64 mds_pack_open_flags(__u32 flags, __u32 mode)\r\n{\r\n__u64 cr_flags = (flags & (FMODE_READ | FMODE_WRITE |\r\nMDS_OPEN_HAS_EA | MDS_OPEN_HAS_OBJS |\r\nMDS_OPEN_OWNEROVERRIDE | MDS_OPEN_LOCK |\r\nMDS_OPEN_BY_FID));\r\nif (flags & O_CREAT)\r\ncr_flags |= MDS_OPEN_CREAT;\r\nif (flags & O_EXCL)\r\ncr_flags |= MDS_OPEN_EXCL;\r\nif (flags & O_TRUNC)\r\ncr_flags |= MDS_OPEN_TRUNC;\r\nif (flags & O_APPEND)\r\ncr_flags |= MDS_OPEN_APPEND;\r\nif (flags & O_SYNC)\r\ncr_flags |= MDS_OPEN_SYNC;\r\nif (flags & O_DIRECTORY)\r\ncr_flags |= MDS_OPEN_DIRECTORY;\r\n#ifdef FMODE_EXEC\r\nif (flags & FMODE_EXEC)\r\ncr_flags |= MDS_FMODE_EXEC;\r\n#endif\r\nif (flags & O_LOV_DELAY_CREATE)\r\ncr_flags |= MDS_OPEN_DELAY_CREATE;\r\nif (flags & O_NONBLOCK)\r\ncr_flags |= MDS_OPEN_NORESTORE;\r\nreturn cr_flags;\r\n}\r\nvoid mdc_open_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\n__u32 mode, __u64 rdev, __u32 flags, const void *lmm,\r\nint lmmlen)\r\n{\r\nstruct mdt_rec_create *rec;\r\nchar *tmp;\r\n__u64 cr_flags;\r\nCLASSERT(sizeof(struct mdt_rec_reint) == sizeof(struct mdt_rec_create));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->cr_opcode = REINT_OPEN;\r\nrec->cr_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nrec->cr_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nrec->cr_cap = cfs_curproc_cap_pack();\r\nif (op_data != NULL) {\r\nrec->cr_fid1 = op_data->op_fid1;\r\nrec->cr_fid2 = op_data->op_fid2;\r\n}\r\nrec->cr_mode = mode;\r\ncr_flags = mds_pack_open_flags(flags, mode);\r\nrec->cr_rdev = rdev;\r\nrec->cr_time = op_data->op_mod_time;\r\nrec->cr_suppgid1 = op_data->op_suppgids[0];\r\nrec->cr_suppgid2 = op_data->op_suppgids[1];\r\nrec->cr_bias = op_data->op_bias;\r\nrec->cr_umask = current_umask();\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nif (op_data->op_name) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLOGL0(op_data->op_name, op_data->op_namelen, tmp);\r\nif (op_data->op_bias & MDS_CREATE_VOLATILE)\r\ncr_flags |= MDS_OPEN_VOLATILE;\r\n}\r\nif (lmm) {\r\ncr_flags |= MDS_OPEN_HAS_EA;\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nmemcpy(tmp, lmm, lmmlen);\r\n}\r\nset_mrc_cr_flags(rec, cr_flags);\r\n}\r\nstatic inline __u64 attr_pack(unsigned int ia_valid) {\r\n__u64 sa_valid = 0;\r\nif (ia_valid & ATTR_MODE)\r\nsa_valid |= MDS_ATTR_MODE;\r\nif (ia_valid & ATTR_UID)\r\nsa_valid |= MDS_ATTR_UID;\r\nif (ia_valid & ATTR_GID)\r\nsa_valid |= MDS_ATTR_GID;\r\nif (ia_valid & ATTR_SIZE)\r\nsa_valid |= MDS_ATTR_SIZE;\r\nif (ia_valid & ATTR_ATIME)\r\nsa_valid |= MDS_ATTR_ATIME;\r\nif (ia_valid & ATTR_MTIME)\r\nsa_valid |= MDS_ATTR_MTIME;\r\nif (ia_valid & ATTR_CTIME)\r\nsa_valid |= MDS_ATTR_CTIME;\r\nif (ia_valid & ATTR_ATIME_SET)\r\nsa_valid |= MDS_ATTR_ATIME_SET;\r\nif (ia_valid & ATTR_MTIME_SET)\r\nsa_valid |= MDS_ATTR_MTIME_SET;\r\nif (ia_valid & ATTR_FORCE)\r\nsa_valid |= MDS_ATTR_FORCE;\r\nif (ia_valid & ATTR_ATTR_FLAG)\r\nsa_valid |= MDS_ATTR_ATTR_FLAG;\r\nif (ia_valid & ATTR_KILL_SUID)\r\nsa_valid |= MDS_ATTR_KILL_SUID;\r\nif (ia_valid & ATTR_KILL_SGID)\r\nsa_valid |= MDS_ATTR_KILL_SGID;\r\nif (ia_valid & ATTR_CTIME_SET)\r\nsa_valid |= MDS_ATTR_CTIME_SET;\r\nif (ia_valid & ATTR_FROM_OPEN)\r\nsa_valid |= MDS_ATTR_FROM_OPEN;\r\nif (ia_valid & ATTR_BLOCKS)\r\nsa_valid |= MDS_ATTR_BLOCKS;\r\nif (ia_valid & MDS_OPEN_OWNEROVERRIDE)\r\nsa_valid |= MDS_OPEN_OWNEROVERRIDE;\r\nreturn sa_valid;\r\n}\r\nstatic void mdc_setattr_pack_rec(struct mdt_rec_setattr *rec,\r\nstruct md_op_data *op_data)\r\n{\r\nrec->sa_opcode = REINT_SETATTR;\r\nrec->sa_fsuid = from_kuid(&init_user_ns, current_fsuid());\r\nrec->sa_fsgid = from_kgid(&init_user_ns, current_fsgid());\r\nrec->sa_cap = cfs_curproc_cap_pack();\r\nrec->sa_suppgid = -1;\r\nrec->sa_fid = op_data->op_fid1;\r\nrec->sa_valid = attr_pack(op_data->op_attr.ia_valid);\r\nrec->sa_mode = op_data->op_attr.ia_mode;\r\nrec->sa_uid = from_kuid(&init_user_ns, op_data->op_attr.ia_uid);\r\nrec->sa_gid = from_kgid(&init_user_ns, op_data->op_attr.ia_gid);\r\nrec->sa_size = op_data->op_attr.ia_size;\r\nrec->sa_blocks = op_data->op_attr_blocks;\r\nrec->sa_atime = LTIME_S(op_data->op_attr.ia_atime);\r\nrec->sa_mtime = LTIME_S(op_data->op_attr.ia_mtime);\r\nrec->sa_ctime = LTIME_S(op_data->op_attr.ia_ctime);\r\nrec->sa_attr_flags = ((struct ll_iattr *)&op_data->op_attr)->ia_attr_flags;\r\nif ((op_data->op_attr.ia_valid & ATTR_GID) &&\r\nin_group_p(op_data->op_attr.ia_gid))\r\nrec->sa_suppgid =\r\nfrom_kgid(&init_user_ns, op_data->op_attr.ia_gid);\r\nelse\r\nrec->sa_suppgid = op_data->op_suppgids[0];\r\nrec->sa_bias = op_data->op_bias;\r\n}\r\nstatic void mdc_ioepoch_pack(struct mdt_ioepoch *epoch,\r\nstruct md_op_data *op_data)\r\n{\r\nmemcpy(&epoch->handle, &op_data->op_handle, sizeof(epoch->handle));\r\nepoch->ioepoch = op_data->op_ioepoch;\r\nepoch->flags = op_data->op_flags & MF_SOM_LOCAL_FLAGS;\r\n}\r\nvoid mdc_setattr_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\nvoid *ea, int ealen, void *ea2, int ea2len)\r\n{\r\nstruct mdt_rec_setattr *rec;\r\nstruct mdt_ioepoch *epoch;\r\nstruct lov_user_md *lum = NULL;\r\nCLASSERT(sizeof(struct mdt_rec_reint) ==sizeof(struct mdt_rec_setattr));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nmdc_setattr_pack_rec(rec, op_data);\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nif (op_data->op_flags & (MF_SOM_CHANGE | MF_EPOCH_OPEN)) {\r\nepoch = req_capsule_client_get(&req->rq_pill, &RMF_MDT_EPOCH);\r\nmdc_ioepoch_pack(epoch, op_data);\r\n}\r\nif (ealen == 0)\r\nreturn;\r\nlum = req_capsule_client_get(&req->rq_pill, &RMF_EADATA);\r\nif (ea == NULL) {\r\nlum->lmm_magic = LOV_USER_MAGIC_V1;\r\nlum->lmm_stripe_size = 0;\r\nlum->lmm_stripe_count = 0;\r\nlum->lmm_stripe_offset = (typeof(lum->lmm_stripe_offset))(-1);\r\n} else {\r\nmemcpy(lum, ea, ealen);\r\n}\r\nif (ea2len == 0)\r\nreturn;\r\nmemcpy(req_capsule_client_get(&req->rq_pill, &RMF_LOGCOOKIES), ea2,\r\nea2len);\r\n}\r\nvoid mdc_unlink_pack(struct ptlrpc_request *req, struct md_op_data *op_data)\r\n{\r\nstruct mdt_rec_unlink *rec;\r\nchar *tmp;\r\nCLASSERT(sizeof(struct mdt_rec_reint) == sizeof(struct mdt_rec_unlink));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nLASSERT(rec != NULL);\r\nrec->ul_opcode = op_data->op_cli_flags & CLI_RM_ENTRY ?\r\nREINT_RMENTRY : REINT_UNLINK;\r\nrec->ul_fsuid = op_data->op_fsuid;\r\nrec->ul_fsgid = op_data->op_fsgid;\r\nrec->ul_cap = op_data->op_cap;\r\nrec->ul_mode = op_data->op_mode;\r\nrec->ul_suppgid1= op_data->op_suppgids[0];\r\nrec->ul_suppgid2= -1;\r\nrec->ul_fid1 = op_data->op_fid1;\r\nrec->ul_fid2 = op_data->op_fid2;\r\nrec->ul_time = op_data->op_mod_time;\r\nrec->ul_bias = op_data->op_bias;\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLASSERT(tmp != NULL);\r\nLOGL0(op_data->op_name, op_data->op_namelen, tmp);\r\n}\r\nvoid mdc_link_pack(struct ptlrpc_request *req, struct md_op_data *op_data)\r\n{\r\nstruct mdt_rec_link *rec;\r\nchar *tmp;\r\nCLASSERT(sizeof(struct mdt_rec_reint) == sizeof(struct mdt_rec_link));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nLASSERT (rec != NULL);\r\nrec->lk_opcode = REINT_LINK;\r\nrec->lk_fsuid = op_data->op_fsuid;\r\nrec->lk_fsgid = op_data->op_fsgid;\r\nrec->lk_cap = op_data->op_cap;\r\nrec->lk_suppgid1 = op_data->op_suppgids[0];\r\nrec->lk_suppgid2 = op_data->op_suppgids[1];\r\nrec->lk_fid1 = op_data->op_fid1;\r\nrec->lk_fid2 = op_data->op_fid2;\r\nrec->lk_time = op_data->op_mod_time;\r\nrec->lk_bias = op_data->op_bias;\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_pack_capa(req, &RMF_CAPA2, op_data->op_capa2);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLOGL0(op_data->op_name, op_data->op_namelen, tmp);\r\n}\r\nvoid mdc_rename_pack(struct ptlrpc_request *req, struct md_op_data *op_data,\r\nconst char *old, int oldlen, const char *new, int newlen)\r\n{\r\nstruct mdt_rec_rename *rec;\r\nchar *tmp;\r\nCLASSERT(sizeof(struct mdt_rec_reint) == sizeof(struct mdt_rec_rename));\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nrec->rn_opcode = REINT_RENAME;\r\nrec->rn_fsuid = op_data->op_fsuid;\r\nrec->rn_fsgid = op_data->op_fsgid;\r\nrec->rn_cap = op_data->op_cap;\r\nrec->rn_suppgid1 = op_data->op_suppgids[0];\r\nrec->rn_suppgid2 = op_data->op_suppgids[1];\r\nrec->rn_fid1 = op_data->op_fid1;\r\nrec->rn_fid2 = op_data->op_fid2;\r\nrec->rn_time = op_data->op_mod_time;\r\nrec->rn_mode = op_data->op_mode;\r\nrec->rn_bias = op_data->op_bias;\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_pack_capa(req, &RMF_CAPA2, op_data->op_capa2);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLOGL0(old, oldlen, tmp);\r\nif (new) {\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_SYMTGT);\r\nLOGL0(new, newlen, tmp);\r\n}\r\n}\r\nvoid mdc_getattr_pack(struct ptlrpc_request *req, __u64 valid, int flags,\r\nstruct md_op_data *op_data, int ea_size)\r\n{\r\nstruct mdt_body *b = req_capsule_client_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nb->valid = valid;\r\nif (op_data->op_bias & MDS_CHECK_SPLIT)\r\nb->valid |= OBD_MD_FLCKSPLIT;\r\nif (op_data->op_bias & MDS_CROSS_REF)\r\nb->valid |= OBD_MD_FLCROSSREF;\r\nb->eadatasize = ea_size;\r\nb->flags = flags;\r\n__mdc_pack_body(b, op_data->op_suppgids[0]);\r\nb->fid1 = op_data->op_fid1;\r\nb->fid2 = op_data->op_fid2;\r\nb->valid |= OBD_MD_FLID;\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nif (op_data->op_name) {\r\nchar *tmp = req_capsule_client_get(&req->rq_pill, &RMF_NAME);\r\nLOGL0(op_data->op_name, op_data->op_namelen, tmp);\r\n}\r\n}\r\nvoid mdc_close_pack(struct ptlrpc_request *req, struct md_op_data *op_data)\r\n{\r\nstruct mdt_ioepoch *epoch;\r\nstruct mdt_rec_setattr *rec;\r\nepoch = req_capsule_client_get(&req->rq_pill, &RMF_MDT_EPOCH);\r\nrec = req_capsule_client_get(&req->rq_pill, &RMF_REC_REINT);\r\nmdc_setattr_pack_rec(rec, op_data);\r\nmdc_pack_capa(req, &RMF_CAPA1, op_data->op_capa1);\r\nmdc_ioepoch_pack(epoch, op_data);\r\n}\r\nstatic int mdc_req_avail(struct client_obd *cli, struct mdc_cache_waiter *mcw)\r\n{\r\nint rc;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nrc = list_empty(&mcw->mcw_entry);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nreturn rc;\r\n}\r\nint mdc_enter_request(struct client_obd *cli)\r\n{\r\nint rc = 0;\r\nstruct mdc_cache_waiter mcw;\r\nstruct l_wait_info lwi = LWI_INTR(LWI_ON_SIGNAL_NOOP, NULL);\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (cli->cl_r_in_flight >= cli->cl_max_rpcs_in_flight) {\r\nlist_add_tail(&mcw.mcw_entry, &cli->cl_cache_waiters);\r\ninit_waitqueue_head(&mcw.mcw_waitq);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\nrc = l_wait_event(mcw.mcw_waitq, mdc_req_avail(cli, &mcw), &lwi);\r\nif (rc) {\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\nif (list_empty(&mcw.mcw_entry))\r\ncli->cl_r_in_flight--;\r\nlist_del_init(&mcw.mcw_entry);\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\n} else {\r\ncli->cl_r_in_flight++;\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}\r\nreturn rc;\r\n}\r\nvoid mdc_exit_request(struct client_obd *cli)\r\n{\r\nstruct list_head *l, *tmp;\r\nstruct mdc_cache_waiter *mcw;\r\nclient_obd_list_lock(&cli->cl_loi_list_lock);\r\ncli->cl_r_in_flight--;\r\nlist_for_each_safe(l, tmp, &cli->cl_cache_waiters) {\r\nif (cli->cl_r_in_flight >= cli->cl_max_rpcs_in_flight) {\r\nbreak;\r\n}\r\nmcw = list_entry(l, struct mdc_cache_waiter, mcw_entry);\r\nlist_del_init(&mcw->mcw_entry);\r\ncli->cl_r_in_flight++;\r\nwake_up(&mcw->mcw_waitq);\r\n}\r\nclient_obd_list_unlock(&cli->cl_loi_list_lock);\r\n}
