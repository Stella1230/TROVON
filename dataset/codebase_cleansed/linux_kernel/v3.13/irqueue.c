static __u32 hash( const char* name)\r\n{\r\n__u32 h = 0;\r\n__u32 g;\r\nwhile(*name) {\r\nh = (h<<4) + *name++;\r\nif ((g = (h & 0xf0000000)))\r\nh ^=g>>24;\r\nh &=~g;\r\n}\r\nreturn h;\r\n}\r\nstatic void enqueue_first(irda_queue_t **queue, irda_queue_t* element)\r\n{\r\nIRDA_DEBUG( 4, "%s()\n", __func__);\r\nif ( *queue == NULL ) {\r\nelement->q_next = element->q_prev = *queue = element;\r\n} else {\r\nelement->q_next = (*queue);\r\n(*queue)->q_prev->q_next = element;\r\nelement->q_prev = (*queue)->q_prev;\r\n(*queue)->q_prev = element;\r\n(*queue) = element;\r\n}\r\n}\r\nstatic irda_queue_t *dequeue_first(irda_queue_t **queue)\r\n{\r\nirda_queue_t *ret;\r\nIRDA_DEBUG( 4, "dequeue_first()\n");\r\nret = *queue;\r\nif ( *queue == NULL ) {\r\n} else if ( (*queue)->q_next == *queue ) {\r\n*queue = NULL;\r\n} else {\r\n(*queue)->q_prev->q_next = (*queue)->q_next;\r\n(*queue)->q_next->q_prev = (*queue)->q_prev;\r\n*queue = (*queue)->q_next;\r\n}\r\nreturn ret;\r\n}\r\nstatic irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)\r\n{\r\nirda_queue_t *ret;\r\nIRDA_DEBUG( 4, "dequeue_general()\n");\r\nret = *queue;\r\nif ( *queue == NULL ) {\r\n} else if ( (*queue)->q_next == *queue ) {\r\n*queue = NULL;\r\n} else {\r\nelement->q_prev->q_next = element->q_next;\r\nelement->q_next->q_prev = element->q_prev;\r\nif ( (*queue) == element)\r\n(*queue) = element->q_next;\r\n}\r\nreturn ret;\r\n}\r\nhashbin_t *hashbin_new(int type)\r\n{\r\nhashbin_t* hashbin;\r\nhashbin = kzalloc(sizeof(*hashbin), GFP_ATOMIC);\r\nif (!hashbin)\r\nreturn NULL;\r\nhashbin->hb_type = type;\r\nhashbin->magic = HB_MAGIC;\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_lock_init(&hashbin->hb_spinlock);\r\n}\r\nreturn hashbin;\r\n}\r\nint hashbin_delete( hashbin_t* hashbin, FREE_FUNC free_func)\r\n{\r\nirda_queue_t* queue;\r\nunsigned long flags = 0;\r\nint i;\r\nIRDA_ASSERT(hashbin != NULL, return -1;);\r\nIRDA_ASSERT(hashbin->magic == HB_MAGIC, return -1;);\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_lock_irqsave_nested(&hashbin->hb_spinlock, flags,\r\nhashbin_lock_depth++);\r\n}\r\nfor (i = 0; i < HASHBIN_SIZE; i ++ ) {\r\nqueue = dequeue_first((irda_queue_t**) &hashbin->hb_queue[i]);\r\nwhile (queue ) {\r\nif (free_func)\r\n(*free_func)(queue);\r\nqueue = dequeue_first(\r\n(irda_queue_t**) &hashbin->hb_queue[i]);\r\n}\r\n}\r\nhashbin->hb_current = NULL;\r\nhashbin->magic = ~HB_MAGIC;\r\nif ( hashbin->hb_type & HB_LOCK) {\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\n#ifdef CONFIG_LOCKDEP\r\nhashbin_lock_depth--;\r\n#endif\r\n}\r\nkfree(hashbin);\r\nreturn 0;\r\n}\r\nvoid hashbin_insert(hashbin_t* hashbin, irda_queue_t* entry, long hashv,\r\nconst char* name)\r\n{\r\nunsigned long flags = 0;\r\nint bin;\r\nIRDA_DEBUG( 4, "%s()\n", __func__);\r\nIRDA_ASSERT( hashbin != NULL, return;);\r\nIRDA_ASSERT( hashbin->magic == HB_MAGIC, return;);\r\nif ( name )\r\nhashv = hash( name );\r\nbin = GET_HASHBIN( hashv );\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_lock_irqsave(&hashbin->hb_spinlock, flags);\r\n}\r\nentry->q_hash = hashv;\r\nif ( name )\r\nstrlcpy( entry->q_name, name, sizeof(entry->q_name));\r\nenqueue_first( (irda_queue_t**) &hashbin->hb_queue[ bin ],\r\nentry);\r\nhashbin->hb_size++;\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\n}\r\n}\r\nvoid *hashbin_remove_first( hashbin_t *hashbin)\r\n{\r\nunsigned long flags = 0;\r\nirda_queue_t *entry = NULL;\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_lock_irqsave(&hashbin->hb_spinlock, flags);\r\n}\r\nentry = hashbin_get_first( hashbin);\r\nif ( entry != NULL) {\r\nint bin;\r\nlong hashv;\r\nhashv = entry->q_hash;\r\nbin = GET_HASHBIN( hashv );\r\ndequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\r\nentry);\r\nhashbin->hb_size--;\r\nentry->q_next = NULL;\r\nentry->q_prev = NULL;\r\nif ( entry == hashbin->hb_current)\r\nhashbin->hb_current = NULL;\r\n}\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\n}\r\nreturn entry;\r\n}\r\nvoid* hashbin_remove( hashbin_t* hashbin, long hashv, const char* name)\r\n{\r\nint bin, found = FALSE;\r\nunsigned long flags = 0;\r\nirda_queue_t* entry;\r\nIRDA_DEBUG( 4, "%s()\n", __func__);\r\nIRDA_ASSERT( hashbin != NULL, return NULL;);\r\nIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\r\nif ( name )\r\nhashv = hash( name );\r\nbin = GET_HASHBIN( hashv );\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_lock_irqsave(&hashbin->hb_spinlock, flags);\r\n}\r\nentry = hashbin->hb_queue[ bin ];\r\nif ( entry ) {\r\ndo {\r\nif ( entry->q_hash == hashv ) {\r\nif ( name ) {\r\nif ( strcmp( entry->q_name, name) == 0)\r\n{\r\nfound = TRUE;\r\nbreak;\r\n}\r\n} else {\r\nfound = TRUE;\r\nbreak;\r\n}\r\n}\r\nentry = entry->q_next;\r\n} while ( entry != hashbin->hb_queue[ bin ] );\r\n}\r\nif ( found ) {\r\ndequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\r\nentry);\r\nhashbin->hb_size--;\r\nif ( entry == hashbin->hb_current)\r\nhashbin->hb_current = NULL;\r\n}\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\n}\r\nif ( found )\r\nreturn entry;\r\nelse\r\nreturn NULL;\r\n}\r\nvoid* hashbin_remove_this( hashbin_t* hashbin, irda_queue_t* entry)\r\n{\r\nunsigned long flags = 0;\r\nint bin;\r\nlong hashv;\r\nIRDA_DEBUG( 4, "%s()\n", __func__);\r\nIRDA_ASSERT( hashbin != NULL, return NULL;);\r\nIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\r\nIRDA_ASSERT( entry != NULL, return NULL;);\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_lock_irqsave(&hashbin->hb_spinlock, flags);\r\n}\r\nif((entry->q_next == NULL) || (entry->q_prev == NULL)) {\r\nentry = NULL;\r\ngoto out;\r\n}\r\nhashv = entry->q_hash;\r\nbin = GET_HASHBIN( hashv );\r\ndequeue_general( (irda_queue_t**) &hashbin->hb_queue[ bin ],\r\nentry);\r\nhashbin->hb_size--;\r\nentry->q_next = NULL;\r\nentry->q_prev = NULL;\r\nif ( entry == hashbin->hb_current)\r\nhashbin->hb_current = NULL;\r\nout:\r\nif ( hashbin->hb_type & HB_LOCK ) {\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\n}\r\nreturn entry;\r\n}\r\nvoid* hashbin_find( hashbin_t* hashbin, long hashv, const char* name )\r\n{\r\nint bin;\r\nirda_queue_t* entry;\r\nIRDA_DEBUG( 4, "hashbin_find()\n");\r\nIRDA_ASSERT( hashbin != NULL, return NULL;);\r\nIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\r\nif ( name )\r\nhashv = hash( name );\r\nbin = GET_HASHBIN( hashv );\r\nentry = hashbin->hb_queue[ bin];\r\nif ( entry ) {\r\ndo {\r\nif ( entry->q_hash == hashv ) {\r\nif ( name ) {\r\nif ( strcmp( entry->q_name, name ) == 0 ) {\r\nreturn entry;\r\n}\r\n} else {\r\nreturn entry;\r\n}\r\n}\r\nentry = entry->q_next;\r\n} while ( entry != hashbin->hb_queue[ bin ] );\r\n}\r\nreturn NULL;\r\n}\r\nvoid* hashbin_lock_find( hashbin_t* hashbin, long hashv, const char* name )\r\n{\r\nunsigned long flags = 0;\r\nirda_queue_t* entry;\r\nspin_lock_irqsave(&hashbin->hb_spinlock, flags);\r\nentry = hashbin_find(hashbin, hashv, name);\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\nreturn entry;\r\n}\r\nvoid* hashbin_find_next( hashbin_t* hashbin, long hashv, const char* name,\r\nvoid ** pnext)\r\n{\r\nunsigned long flags = 0;\r\nirda_queue_t* entry;\r\nspin_lock_irqsave(&hashbin->hb_spinlock, flags);\r\nentry = hashbin_find(hashbin, hashv, name);\r\nif(entry) {\r\nhashbin->hb_current = entry;\r\n*pnext = hashbin_get_next( hashbin );\r\n} else\r\n*pnext = NULL;\r\nspin_unlock_irqrestore(&hashbin->hb_spinlock, flags);\r\nreturn entry;\r\n}\r\nirda_queue_t *hashbin_get_first( hashbin_t* hashbin)\r\n{\r\nirda_queue_t *entry;\r\nint i;\r\nIRDA_ASSERT( hashbin != NULL, return NULL;);\r\nIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\r\nif ( hashbin == NULL)\r\nreturn NULL;\r\nfor ( i = 0; i < HASHBIN_SIZE; i ++ ) {\r\nentry = hashbin->hb_queue[ i];\r\nif ( entry) {\r\nhashbin->hb_current = entry;\r\nreturn entry;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nirda_queue_t *hashbin_get_next( hashbin_t *hashbin)\r\n{\r\nirda_queue_t* entry;\r\nint bin;\r\nint i;\r\nIRDA_ASSERT( hashbin != NULL, return NULL;);\r\nIRDA_ASSERT( hashbin->magic == HB_MAGIC, return NULL;);\r\nif ( hashbin->hb_current == NULL) {\r\nIRDA_ASSERT( hashbin->hb_current != NULL, return NULL;);\r\nreturn NULL;\r\n}\r\nentry = hashbin->hb_current->q_next;\r\nbin = GET_HASHBIN( entry->q_hash);\r\nif ( entry != hashbin->hb_queue[ bin ]) {\r\nhashbin->hb_current = entry;\r\nreturn entry;\r\n}\r\nif ( bin >= HASHBIN_SIZE)\r\nreturn NULL;\r\nbin++;\r\nfor ( i = bin; i < HASHBIN_SIZE; i++ ) {\r\nentry = hashbin->hb_queue[ i];\r\nif ( entry) {\r\nhashbin->hb_current = entry;\r\nreturn entry;\r\n}\r\n}\r\nreturn NULL;\r\n}
