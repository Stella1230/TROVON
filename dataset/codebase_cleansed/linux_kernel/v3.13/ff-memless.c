static const struct ff_envelope *get_envelope(const struct ff_effect *effect)\r\n{\r\nstatic const struct ff_envelope empty_envelope;\r\nswitch (effect->type) {\r\ncase FF_PERIODIC:\r\nreturn &effect->u.periodic.envelope;\r\ncase FF_CONSTANT:\r\nreturn &effect->u.constant.envelope;\r\ndefault:\r\nreturn &empty_envelope;\r\n}\r\n}\r\nstatic unsigned long calculate_next_time(struct ml_effect_state *state)\r\n{\r\nconst struct ff_envelope *envelope = get_envelope(state->effect);\r\nunsigned long attack_stop, fade_start, next_fade;\r\nif (envelope->attack_length) {\r\nattack_stop = state->play_at +\r\nmsecs_to_jiffies(envelope->attack_length);\r\nif (time_before(state->adj_at, attack_stop))\r\nreturn state->adj_at +\r\nmsecs_to_jiffies(FF_ENVELOPE_INTERVAL);\r\n}\r\nif (state->effect->replay.length) {\r\nif (envelope->fade_length) {\r\nfade_start = state->stop_at -\r\nmsecs_to_jiffies(envelope->fade_length);\r\nif (time_before(state->adj_at, fade_start))\r\nreturn fade_start;\r\nnext_fade = state->adj_at +\r\nmsecs_to_jiffies(FF_ENVELOPE_INTERVAL);\r\nif (time_before(next_fade, state->stop_at))\r\nreturn next_fade;\r\n}\r\nreturn state->stop_at;\r\n}\r\nreturn state->play_at;\r\n}\r\nstatic void ml_schedule_timer(struct ml_device *ml)\r\n{\r\nstruct ml_effect_state *state;\r\nunsigned long now = jiffies;\r\nunsigned long earliest = 0;\r\nunsigned long next_at;\r\nint events = 0;\r\nint i;\r\npr_debug("calculating next timer\n");\r\nfor (i = 0; i < FF_MEMLESS_EFFECTS; i++) {\r\nstate = &ml->states[i];\r\nif (!test_bit(FF_EFFECT_STARTED, &state->flags))\r\ncontinue;\r\nif (test_bit(FF_EFFECT_PLAYING, &state->flags))\r\nnext_at = calculate_next_time(state);\r\nelse\r\nnext_at = state->play_at;\r\nif (time_before_eq(now, next_at) &&\r\n(++events == 1 || time_before(next_at, earliest)))\r\nearliest = next_at;\r\n}\r\nif (!events) {\r\npr_debug("no actions\n");\r\ndel_timer(&ml->timer);\r\n} else {\r\npr_debug("timer set\n");\r\nmod_timer(&ml->timer, earliest);\r\n}\r\n}\r\nstatic int apply_envelope(struct ml_effect_state *state, int value,\r\nstruct ff_envelope *envelope)\r\n{\r\nstruct ff_effect *effect = state->effect;\r\nunsigned long now = jiffies;\r\nint time_from_level;\r\nint time_of_envelope;\r\nint envelope_level;\r\nint difference;\r\nif (envelope->attack_length &&\r\ntime_before(now,\r\nstate->play_at + msecs_to_jiffies(envelope->attack_length))) {\r\npr_debug("value = 0x%x, attack_level = 0x%x\n",\r\nvalue, envelope->attack_level);\r\ntime_from_level = jiffies_to_msecs(now - state->play_at);\r\ntime_of_envelope = envelope->attack_length;\r\nenvelope_level = min_t(u16, envelope->attack_level, 0x7fff);\r\n} else if (envelope->fade_length && effect->replay.length &&\r\ntime_after(now,\r\nstate->stop_at - msecs_to_jiffies(envelope->fade_length)) &&\r\ntime_before(now, state->stop_at)) {\r\ntime_from_level = jiffies_to_msecs(state->stop_at - now);\r\ntime_of_envelope = envelope->fade_length;\r\nenvelope_level = min_t(u16, envelope->fade_level, 0x7fff);\r\n} else\r\nreturn value;\r\ndifference = abs(value) - envelope_level;\r\npr_debug("difference = %d\n", difference);\r\npr_debug("time_from_level = 0x%x\n", time_from_level);\r\npr_debug("time_of_envelope = 0x%x\n", time_of_envelope);\r\ndifference = difference * time_from_level / time_of_envelope;\r\npr_debug("difference = %d\n", difference);\r\nreturn value < 0 ?\r\n-(difference + envelope_level) : (difference + envelope_level);\r\n}\r\nstatic int get_compatible_type(struct ff_device *ff, int effect_type)\r\n{\r\nif (test_bit(effect_type, ff->ffbit))\r\nreturn effect_type;\r\nif (effect_type == FF_PERIODIC && test_bit(FF_RUMBLE, ff->ffbit))\r\nreturn FF_RUMBLE;\r\npr_err("invalid type in get_compatible_type()\n");\r\nreturn 0;\r\n}\r\nstatic u16 ml_calculate_direction(u16 direction, u16 force,\r\nu16 new_direction, u16 new_force)\r\n{\r\nif (!force)\r\nreturn new_direction;\r\nif (!new_force)\r\nreturn direction;\r\nreturn (((u32)(direction >> 1) * force +\r\n(new_direction >> 1) * new_force) /\r\n(force + new_force)) << 1;\r\n}\r\nstatic void ml_combine_effects(struct ff_effect *effect,\r\nstruct ml_effect_state *state,\r\nint gain)\r\n{\r\nstruct ff_effect *new = state->effect;\r\nunsigned int strong, weak, i;\r\nint x, y;\r\nfixp_t level;\r\nswitch (new->type) {\r\ncase FF_CONSTANT:\r\ni = new->direction * 360 / 0xffff;\r\nlevel = fixp_new16(apply_envelope(state,\r\nnew->u.constant.level,\r\n&new->u.constant.envelope));\r\nx = fixp_mult(fixp_sin(i), level) * gain / 0xffff;\r\ny = fixp_mult(-fixp_cos(i), level) * gain / 0xffff;\r\neffect->u.ramp.start_level =\r\nclamp_val(effect->u.ramp.start_level + x, -0x80, 0x7f);\r\neffect->u.ramp.end_level =\r\nclamp_val(effect->u.ramp.end_level + y, -0x80, 0x7f);\r\nbreak;\r\ncase FF_RUMBLE:\r\nstrong = (u32)new->u.rumble.strong_magnitude * gain / 0xffff;\r\nweak = (u32)new->u.rumble.weak_magnitude * gain / 0xffff;\r\nif (effect->u.rumble.strong_magnitude + strong)\r\neffect->direction = ml_calculate_direction(\r\neffect->direction,\r\neffect->u.rumble.strong_magnitude,\r\nnew->direction, strong);\r\nelse if (effect->u.rumble.weak_magnitude + weak)\r\neffect->direction = ml_calculate_direction(\r\neffect->direction,\r\neffect->u.rumble.weak_magnitude,\r\nnew->direction, weak);\r\nelse\r\neffect->direction = 0;\r\neffect->u.rumble.strong_magnitude =\r\nmin(strong + effect->u.rumble.strong_magnitude,\r\n0xffffU);\r\neffect->u.rumble.weak_magnitude =\r\nmin(weak + effect->u.rumble.weak_magnitude, 0xffffU);\r\nbreak;\r\ncase FF_PERIODIC:\r\ni = apply_envelope(state, abs(new->u.periodic.magnitude),\r\n&new->u.periodic.envelope);\r\ni = i * gain / 0x7fff;\r\nif (effect->u.rumble.strong_magnitude + i)\r\neffect->direction = ml_calculate_direction(\r\neffect->direction,\r\neffect->u.rumble.strong_magnitude,\r\nnew->direction, i);\r\nelse\r\neffect->direction = 0;\r\neffect->u.rumble.strong_magnitude =\r\nmin(i + effect->u.rumble.strong_magnitude, 0xffffU);\r\neffect->u.rumble.weak_magnitude =\r\nmin(i + effect->u.rumble.weak_magnitude, 0xffffU);\r\nbreak;\r\ndefault:\r\npr_err("invalid type in ml_combine_effects()\n");\r\nbreak;\r\n}\r\n}\r\nstatic int ml_get_combo_effect(struct ml_device *ml,\r\nunsigned long *effect_handled,\r\nstruct ff_effect *combo_effect)\r\n{\r\nstruct ff_effect *effect;\r\nstruct ml_effect_state *state;\r\nint effect_type;\r\nint i;\r\nmemset(combo_effect, 0, sizeof(struct ff_effect));\r\nfor (i = 0; i < FF_MEMLESS_EFFECTS; i++) {\r\nif (__test_and_set_bit(i, effect_handled))\r\ncontinue;\r\nstate = &ml->states[i];\r\neffect = state->effect;\r\nif (!test_bit(FF_EFFECT_STARTED, &state->flags))\r\ncontinue;\r\nif (time_before(jiffies, state->play_at))\r\ncontinue;\r\neffect_type = get_compatible_type(ml->dev->ff, effect->type);\r\nif (combo_effect->type != effect_type) {\r\nif (combo_effect->type != 0) {\r\n__clear_bit(i, effect_handled);\r\ncontinue;\r\n}\r\ncombo_effect->type = effect_type;\r\n}\r\nif (__test_and_clear_bit(FF_EFFECT_ABORTING, &state->flags)) {\r\n__clear_bit(FF_EFFECT_PLAYING, &state->flags);\r\n__clear_bit(FF_EFFECT_STARTED, &state->flags);\r\n} else if (effect->replay.length &&\r\ntime_after_eq(jiffies, state->stop_at)) {\r\n__clear_bit(FF_EFFECT_PLAYING, &state->flags);\r\nif (--state->count <= 0) {\r\n__clear_bit(FF_EFFECT_STARTED, &state->flags);\r\n} else {\r\nstate->play_at = jiffies +\r\nmsecs_to_jiffies(effect->replay.delay);\r\nstate->stop_at = state->play_at +\r\nmsecs_to_jiffies(effect->replay.length);\r\n}\r\n} else {\r\n__set_bit(FF_EFFECT_PLAYING, &state->flags);\r\nstate->adj_at = jiffies;\r\nml_combine_effects(combo_effect, state, ml->gain);\r\n}\r\n}\r\nreturn combo_effect->type != 0;\r\n}\r\nstatic void ml_play_effects(struct ml_device *ml)\r\n{\r\nstruct ff_effect effect;\r\nDECLARE_BITMAP(handled_bm, FF_MEMLESS_EFFECTS);\r\nmemset(handled_bm, 0, sizeof(handled_bm));\r\nwhile (ml_get_combo_effect(ml, handled_bm, &effect))\r\nml->play_effect(ml->dev, ml->private, &effect);\r\nml_schedule_timer(ml);\r\n}\r\nstatic void ml_effect_timer(unsigned long timer_data)\r\n{\r\nstruct input_dev *dev = (struct input_dev *)timer_data;\r\nstruct ml_device *ml = dev->ff->private;\r\nunsigned long flags;\r\npr_debug("timer: updating effects\n");\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nml_play_effects(ml);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\n}\r\nstatic void ml_ff_set_gain(struct input_dev *dev, u16 gain)\r\n{\r\nstruct ml_device *ml = dev->ff->private;\r\nint i;\r\nml->gain = gain;\r\nfor (i = 0; i < FF_MEMLESS_EFFECTS; i++)\r\n__clear_bit(FF_EFFECT_PLAYING, &ml->states[i].flags);\r\nml_play_effects(ml);\r\n}\r\nstatic int ml_ff_playback(struct input_dev *dev, int effect_id, int value)\r\n{\r\nstruct ml_device *ml = dev->ff->private;\r\nstruct ml_effect_state *state = &ml->states[effect_id];\r\nif (value > 0) {\r\npr_debug("initiated play\n");\r\n__set_bit(FF_EFFECT_STARTED, &state->flags);\r\nstate->count = value;\r\nstate->play_at = jiffies +\r\nmsecs_to_jiffies(state->effect->replay.delay);\r\nstate->stop_at = state->play_at +\r\nmsecs_to_jiffies(state->effect->replay.length);\r\nstate->adj_at = state->play_at;\r\n} else {\r\npr_debug("initiated stop\n");\r\nif (test_bit(FF_EFFECT_PLAYING, &state->flags))\r\n__set_bit(FF_EFFECT_ABORTING, &state->flags);\r\nelse\r\n__clear_bit(FF_EFFECT_STARTED, &state->flags);\r\n}\r\nml_play_effects(ml);\r\nreturn 0;\r\n}\r\nstatic int ml_ff_upload(struct input_dev *dev,\r\nstruct ff_effect *effect, struct ff_effect *old)\r\n{\r\nstruct ml_device *ml = dev->ff->private;\r\nstruct ml_effect_state *state = &ml->states[effect->id];\r\nspin_lock_irq(&dev->event_lock);\r\nif (test_bit(FF_EFFECT_STARTED, &state->flags)) {\r\n__clear_bit(FF_EFFECT_PLAYING, &state->flags);\r\nstate->play_at = jiffies +\r\nmsecs_to_jiffies(state->effect->replay.delay);\r\nstate->stop_at = state->play_at +\r\nmsecs_to_jiffies(state->effect->replay.length);\r\nstate->adj_at = state->play_at;\r\nml_schedule_timer(ml);\r\n}\r\nspin_unlock_irq(&dev->event_lock);\r\nreturn 0;\r\n}\r\nstatic void ml_ff_destroy(struct ff_device *ff)\r\n{\r\nstruct ml_device *ml = ff->private;\r\nkfree(ml->private);\r\n}\r\nint input_ff_create_memless(struct input_dev *dev, void *data,\r\nint (*play_effect)(struct input_dev *, void *, struct ff_effect *))\r\n{\r\nstruct ml_device *ml;\r\nstruct ff_device *ff;\r\nint error;\r\nint i;\r\nml = kzalloc(sizeof(struct ml_device), GFP_KERNEL);\r\nif (!ml)\r\nreturn -ENOMEM;\r\nml->dev = dev;\r\nml->private = data;\r\nml->play_effect = play_effect;\r\nml->gain = 0xffff;\r\nsetup_timer(&ml->timer, ml_effect_timer, (unsigned long)dev);\r\nset_bit(FF_GAIN, dev->ffbit);\r\nerror = input_ff_create(dev, FF_MEMLESS_EFFECTS);\r\nif (error) {\r\nkfree(ml);\r\nreturn error;\r\n}\r\nff = dev->ff;\r\nff->private = ml;\r\nff->upload = ml_ff_upload;\r\nff->playback = ml_ff_playback;\r\nff->set_gain = ml_ff_set_gain;\r\nff->destroy = ml_ff_destroy;\r\nif (test_bit(FF_RUMBLE, ff->ffbit)) {\r\nset_bit(FF_PERIODIC, dev->ffbit);\r\nset_bit(FF_SINE, dev->ffbit);\r\nset_bit(FF_TRIANGLE, dev->ffbit);\r\nset_bit(FF_SQUARE, dev->ffbit);\r\n}\r\nfor (i = 0; i < FF_MEMLESS_EFFECTS; i++)\r\nml->states[i].effect = &ff->effects[i];\r\nreturn 0;\r\n}
