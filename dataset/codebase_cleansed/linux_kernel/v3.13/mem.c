static void __init find_tempdir(void)\r\n{\r\nconst char *dirs[] = { "TMP", "TEMP", "TMPDIR", NULL };\r\nint i;\r\nchar *dir = NULL;\r\nif (tempdir != NULL)\r\nreturn;\r\nfor (i = 0; dirs[i]; i++) {\r\ndir = getenv(dirs[i]);\r\nif ((dir != NULL) && (*dir != '\0'))\r\nbreak;\r\n}\r\nif ((dir == NULL) || (*dir == '\0'))\r\ndir = default_tmpdir;\r\ntempdir = malloc(strlen(dir) + 2);\r\nif (tempdir == NULL) {\r\nfprintf(stderr, "Failed to malloc tempdir, "\r\n"errno = %d\n", errno);\r\nreturn;\r\n}\r\nstrcpy(tempdir, dir);\r\nstrcat(tempdir, "/");\r\n}\r\nstatic int pop(int fd, char *buf, size_t size, size_t npop)\r\n{\r\nssize_t n;\r\nsize_t len = strlen(&buf[npop]);\r\nmemmove(buf, &buf[npop], len + 1);\r\nn = read(fd, &buf[len], size - len - 1);\r\nif (n < 0)\r\nreturn -errno;\r\nbuf[len + n] = '\0';\r\nreturn 1;\r\n}\r\nstatic int next(int fd, char *buf, size_t size, char c)\r\n{\r\nssize_t n;\r\nchar *ptr;\r\nwhile ((ptr = strchr(buf, c)) == NULL) {\r\nn = read(fd, buf, size - 1);\r\nif (n == 0)\r\nreturn 0;\r\nelse if (n < 0)\r\nreturn -errno;\r\nbuf[n] = '\0';\r\n}\r\nreturn pop(fd, buf, size, ptr - buf + 1);\r\n}\r\nstatic int decode_path(const char *in, char *out, size_t *len)\r\n{\r\nchar *first = out;\r\nint c;\r\nint i;\r\nint ret = -EINVAL;\r\nwhile (1) {\r\nswitch (*in) {\r\ncase '\0':\r\ngoto out;\r\ncase ' ':\r\nret = 0;\r\ngoto out;\r\ncase '\\':\r\nin++;\r\nc = 0;\r\nfor (i = 0; i < 3; i++) {\r\nif (*in < '0' || *in > '7')\r\ngoto out;\r\nc = (c << 3) | (*in++ - '0');\r\n}\r\n*(unsigned char *)out++ = (unsigned char) c;\r\nbreak;\r\ndefault:\r\n*out++ = *in++;\r\nbreak;\r\n}\r\n}\r\nout:\r\n*out = '\0';\r\n*len = out - first;\r\nreturn ret;\r\n}\r\nstatic size_t octal_encoded_length(const char *s, const char *chars)\r\n{\r\nsize_t len = strlen(s);\r\nwhile ((s = strpbrk(s, chars)) != NULL) {\r\nlen += 3;\r\ns++;\r\n}\r\nreturn len;\r\n}\r\nstatic int read_mount(int fd, char *buf, size_t bufsize, const char *path,\r\nint *outcome)\r\n{\r\nint found;\r\nint match;\r\nchar *space;\r\nsize_t len;\r\nenum {\r\nMATCH_NONE,\r\nMATCH_EXACT,\r\nMATCH_PARENT,\r\n};\r\nfound = next(fd, buf, bufsize, ' ');\r\nif (found != 1)\r\nreturn found;\r\nspace = strchr(buf, ' ');\r\nif (space) {\r\nmatch = MATCH_NONE;\r\nif (!decode_path(buf, buf, &len)) {\r\nif (!strcmp(buf, path))\r\nmatch = MATCH_EXACT;\r\nelse if (!strncmp(buf, path, len)\r\n&& (path[len] == '/' || !strcmp(buf, "/")))\r\nmatch = MATCH_PARENT;\r\n}\r\nfound = pop(fd, buf, bufsize, space - buf + 1);\r\nif (found != 1)\r\nreturn found;\r\nswitch (match) {\r\ncase MATCH_EXACT:\r\nif (!strncmp(buf, "tmpfs", strlen("tmpfs")))\r\n*outcome = OUTCOME_TMPFS_MOUNT;\r\nelse\r\n*outcome = OUTCOME_NON_TMPFS_MOUNT;\r\nbreak;\r\ncase MATCH_PARENT:\r\n*outcome = OUTCOME_NOTHING_MOUNTED;\r\nbreak;\r\n}\r\n}\r\nreturn next(fd, buf, bufsize, '\n');\r\n}\r\nstatic void which_tmpdir(void)\r\n{\r\nint fd;\r\nint found;\r\nint outcome;\r\nchar *path;\r\nchar *buf;\r\nsize_t bufsize;\r\nif (checked_tmpdir)\r\nreturn;\r\nchecked_tmpdir = 1;\r\nprintf("Checking for tmpfs mount on /dev/shm...");\r\npath = realpath("/dev/shm", NULL);\r\nif (!path) {\r\nprintf("failed to check real path, errno = %d\n", errno);\r\nreturn;\r\n}\r\nprintf("%s...", path);\r\nbufsize = octal_encoded_length(path, " \t\n\\") + 2;\r\nif (bufsize < 128)\r\nbufsize = 128;\r\nbuf = malloc(bufsize);\r\nif (!buf) {\r\nprintf("malloc failed, errno = %d\n", errno);\r\ngoto out;\r\n}\r\nbuf[0] = '\0';\r\nfd = open("/proc/mounts", O_RDONLY);\r\nif (fd < 0) {\r\nprintf("failed to open /proc/mounts, errno = %d\n", errno);\r\ngoto out1;\r\n}\r\noutcome = OUTCOME_NOTHING_MOUNTED;\r\nwhile (1) {\r\nfound = read_mount(fd, buf, bufsize, path, &outcome);\r\nif (found != 1)\r\nbreak;\r\n}\r\nif (found < 0) {\r\nprintf("read returned errno %d\n", -found);\r\n} else {\r\nswitch (outcome) {\r\ncase OUTCOME_TMPFS_MOUNT:\r\nprintf("OK\n");\r\ndefault_tmpdir = "/dev/shm";\r\nbreak;\r\ncase OUTCOME_NON_TMPFS_MOUNT:\r\nprintf("not tmpfs\n");\r\nbreak;\r\ndefault:\r\nprintf("nothing mounted on /dev/shm\n");\r\nbreak;\r\n}\r\n}\r\nclose(fd);\r\nout1:\r\nfree(buf);\r\nout:\r\nfree(path);\r\n}\r\nstatic int __init make_tempfile(const char *template, char **out_tempname,\r\nint do_unlink)\r\n{\r\nchar *tempname;\r\nint fd;\r\nwhich_tmpdir();\r\ntempname = malloc(MAXPATHLEN);\r\nif (tempname == NULL)\r\nreturn -1;\r\nfind_tempdir();\r\nif ((tempdir == NULL) || (strlen(tempdir) >= MAXPATHLEN))\r\ngoto out;\r\nif (template[0] != '/')\r\nstrcpy(tempname, tempdir);\r\nelse\r\ntempname[0] = '\0';\r\nstrncat(tempname, template, MAXPATHLEN-1-strlen(tempname));\r\nfd = mkstemp(tempname);\r\nif (fd < 0) {\r\nfprintf(stderr, "open - cannot create %s: %s\n", tempname,\r\nstrerror(errno));\r\ngoto out;\r\n}\r\nif (do_unlink && (unlink(tempname) < 0)) {\r\nperror("unlink");\r\ngoto close;\r\n}\r\nif (out_tempname) {\r\n*out_tempname = tempname;\r\n} else\r\nfree(tempname);\r\nreturn fd;\r\nclose:\r\nclose(fd);\r\nout:\r\nfree(tempname);\r\nreturn -1;\r\n}\r\nstatic int __init create_tmp_file(unsigned long long len)\r\n{\r\nint fd, err;\r\nchar zero;\r\nfd = make_tempfile(TEMPNAME_TEMPLATE, NULL, 1);\r\nif (fd < 0)\r\nexit(1);\r\nerr = fchmod(fd, 0777);\r\nif (err < 0) {\r\nperror("fchmod");\r\nexit(1);\r\n}\r\nif (lseek64(fd, len - 1, SEEK_SET) < 0) {\r\nperror("lseek64");\r\nexit(1);\r\n}\r\nzero = 0;\r\nerr = write(fd, &zero, 1);\r\nif (err != 1) {\r\nperror("write");\r\nexit(1);\r\n}\r\nreturn fd;\r\n}\r\nint __init create_mem_file(unsigned long long len)\r\n{\r\nint err, fd;\r\nfd = create_tmp_file(len);\r\nerr = os_set_exec_close(fd);\r\nif (err < 0) {\r\nerrno = -err;\r\nperror("exec_close");\r\n}\r\nreturn fd;\r\n}\r\nvoid __init check_tmpexec(void)\r\n{\r\nvoid *addr;\r\nint err, fd = create_tmp_file(UM_KERN_PAGE_SIZE);\r\naddr = mmap(NULL, UM_KERN_PAGE_SIZE,\r\nPROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE, fd, 0);\r\nprintf("Checking PROT_EXEC mmap in %s...",tempdir);\r\nfflush(stdout);\r\nif (addr == MAP_FAILED) {\r\nerr = errno;\r\nperror("failed");\r\nclose(fd);\r\nif (err == EPERM)\r\nprintf("%s must be not mounted noexec\n",tempdir);\r\nexit(1);\r\n}\r\nprintf("OK\n");\r\nmunmap(addr, UM_KERN_PAGE_SIZE);\r\nclose(fd);\r\n}
