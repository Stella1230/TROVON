static struct max77686_clk *to_max77686_clk(struct clk_hw *hw)\r\n{\r\nreturn container_of(hw, struct max77686_clk, hw);\r\n}\r\nstatic int max77686_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nreturn regmap_update_bits(max77686->iodev->regmap,\r\nMAX77686_REG_32KHZ, max77686->mask,\r\nmax77686->mask);\r\n}\r\nstatic void max77686_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nregmap_update_bits(max77686->iodev->regmap,\r\nMAX77686_REG_32KHZ, max77686->mask, ~max77686->mask);\r\n}\r\nstatic int max77686_clk_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct max77686_clk *max77686 = to_max77686_clk(hw);\r\nint ret;\r\nu32 val;\r\nret = regmap_read(max77686->iodev->regmap,\r\nMAX77686_REG_32KHZ, &val);\r\nif (ret < 0)\r\nreturn -EINVAL;\r\nreturn val & max77686->mask;\r\n}\r\nstatic int max77686_clk_register(struct device *dev,\r\nstruct max77686_clk *max77686)\r\n{\r\nstruct clk *clk;\r\nstruct clk_hw *hw = &max77686->hw;\r\nclk = clk_register(dev, hw);\r\nif (IS_ERR(clk))\r\nreturn -ENOMEM;\r\nmax77686->lookup = kzalloc(sizeof(struct clk_lookup), GFP_KERNEL);\r\nif (!max77686->lookup)\r\nreturn -ENOMEM;\r\nmax77686->lookup->con_id = hw->init->name;\r\nmax77686->lookup->clk = clk;\r\nclkdev_add(max77686->lookup);\r\nreturn 0;\r\n}\r\nstatic int max77686_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct max77686_dev *iodev = dev_get_drvdata(pdev->dev.parent);\r\nstruct max77686_clk **max77686_clks;\r\nint i, ret;\r\nmax77686_clks = devm_kzalloc(&pdev->dev, sizeof(struct max77686_clk *)\r\n* MAX77686_CLKS_NUM, GFP_KERNEL);\r\nif (!max77686_clks)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < MAX77686_CLKS_NUM; i++) {\r\nmax77686_clks[i] = devm_kzalloc(&pdev->dev,\r\nsizeof(struct max77686_clk), GFP_KERNEL);\r\nif (!max77686_clks[i])\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < MAX77686_CLKS_NUM; i++) {\r\nmax77686_clks[i]->iodev = iodev;\r\nmax77686_clks[i]->mask = 1 << i;\r\nmax77686_clks[i]->hw.init = &max77686_clks_init[i];\r\nret = max77686_clk_register(&pdev->dev, max77686_clks[i]);\r\nif (ret) {\r\nswitch (i) {\r\ncase MAX77686_CLK_AP:\r\ndev_err(&pdev->dev, "Fail to register CLK_AP\n");\r\ngoto err_clk_ap;\r\nbreak;\r\ncase MAX77686_CLK_CP:\r\ndev_err(&pdev->dev, "Fail to register CLK_CP\n");\r\ngoto err_clk_cp;\r\nbreak;\r\ncase MAX77686_CLK_PMIC:\r\ndev_err(&pdev->dev, "Fail to register CLK_PMIC\n");\r\ngoto err_clk_pmic;\r\n}\r\n}\r\n}\r\nplatform_set_drvdata(pdev, max77686_clks);\r\ngoto out;\r\nerr_clk_pmic:\r\nclkdev_drop(max77686_clks[MAX77686_CLK_CP]->lookup);\r\nkfree(max77686_clks[MAX77686_CLK_CP]->hw.clk);\r\nerr_clk_cp:\r\nclkdev_drop(max77686_clks[MAX77686_CLK_AP]->lookup);\r\nkfree(max77686_clks[MAX77686_CLK_AP]->hw.clk);\r\nerr_clk_ap:\r\nout:\r\nreturn ret;\r\n}\r\nstatic int max77686_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct max77686_clk **max77686_clks = platform_get_drvdata(pdev);\r\nint i;\r\nfor (i = 0; i < MAX77686_CLKS_NUM; i++) {\r\nclkdev_drop(max77686_clks[i]->lookup);\r\nkfree(max77686_clks[i]->hw.clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init max77686_clk_init(void)\r\n{\r\nreturn platform_driver_register(&max77686_clk_driver);\r\n}\r\nstatic void __init max77686_clk_cleanup(void)\r\n{\r\nplatform_driver_unregister(&max77686_clk_driver);\r\n}
