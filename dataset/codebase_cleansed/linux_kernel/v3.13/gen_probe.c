struct mtd_info *mtd_do_chip_probe(struct map_info *map, struct chip_probe *cp)\r\n{\r\nstruct mtd_info *mtd = NULL;\r\nstruct cfi_private *cfi;\r\ncfi = genprobe_ident_chips(map, cp);\r\nif (!cfi)\r\nreturn NULL;\r\nmap->fldrv_priv = cfi;\r\nmtd = check_cmd_set(map, 1);\r\nif (!mtd)\r\nmtd = check_cmd_set(map, 0);\r\nif (mtd) {\r\nif (mtd->size > map->size) {\r\nprintk(KERN_WARNING "Reducing visibility of %ldKiB chip to %ldKiB\n",\r\n(unsigned long)mtd->size >> 10,\r\n(unsigned long)map->size >> 10);\r\nmtd->size = map->size;\r\n}\r\nreturn mtd;\r\n}\r\nprintk(KERN_WARNING"gen_probe: No supported Vendor Command Set found\n");\r\nkfree(cfi->cfiq);\r\nkfree(cfi);\r\nmap->fldrv_priv = NULL;\r\nreturn NULL;\r\n}\r\nstatic struct cfi_private *genprobe_ident_chips(struct map_info *map, struct chip_probe *cp)\r\n{\r\nstruct cfi_private cfi;\r\nstruct cfi_private *retcfi;\r\nunsigned long *chip_map;\r\nint i, j, mapsize;\r\nint max_chips;\r\nmemset(&cfi, 0, sizeof(cfi));\r\nif (!genprobe_new_chip(map, cp, &cfi)) {\r\npr_debug("%s: Found no %s device at location zero\n",\r\ncp->name, map->name);\r\nreturn NULL;\r\n}\r\n#if 0\r\nif (cfi.cfiq->NumEraseRegions == 0) {\r\nprintk(KERN_WARNING "Number of erase regions is zero\n");\r\nkfree(cfi.cfiq);\r\nreturn NULL;\r\n}\r\n#endif\r\ncfi.chipshift = cfi.cfiq->DevSize;\r\nif (cfi_interleave_is_1(&cfi)) {\r\n;\r\n} else if (cfi_interleave_is_2(&cfi)) {\r\ncfi.chipshift++;\r\n} else if (cfi_interleave_is_4((&cfi))) {\r\ncfi.chipshift += 2;\r\n} else if (cfi_interleave_is_8(&cfi)) {\r\ncfi.chipshift += 3;\r\n} else {\r\nBUG();\r\n}\r\ncfi.numchips = 1;\r\nmax_chips = map->size >> cfi.chipshift;\r\nif (!max_chips) {\r\nprintk(KERN_WARNING "NOR chip too large to fit in mapping. Attempting to cope...\n");\r\nmax_chips = 1;\r\n}\r\nmapsize = sizeof(long) * DIV_ROUND_UP(max_chips, BITS_PER_LONG);\r\nchip_map = kzalloc(mapsize, GFP_KERNEL);\r\nif (!chip_map) {\r\nprintk(KERN_WARNING "%s: kmalloc failed for CFI chip map\n", map->name);\r\nkfree(cfi.cfiq);\r\nreturn NULL;\r\n}\r\nset_bit(0, chip_map);\r\nfor (i = 1; i < max_chips; i++) {\r\ncp->probe_chip(map, i << cfi.chipshift, chip_map, &cfi);\r\n}\r\nretcfi = kmalloc(sizeof(struct cfi_private) + cfi.numchips * sizeof(struct flchip), GFP_KERNEL);\r\nif (!retcfi) {\r\nprintk(KERN_WARNING "%s: kmalloc failed for CFI private structure\n", map->name);\r\nkfree(cfi.cfiq);\r\nkfree(chip_map);\r\nreturn NULL;\r\n}\r\nmemcpy(retcfi, &cfi, sizeof(cfi));\r\nmemset(&retcfi->chips[0], 0, sizeof(struct flchip) * cfi.numchips);\r\nfor (i = 0, j = 0; (j < cfi.numchips) && (i < max_chips); i++) {\r\nif(test_bit(i, chip_map)) {\r\nstruct flchip *pchip = &retcfi->chips[j++];\r\npchip->start = (i << cfi.chipshift);\r\npchip->state = FL_READY;\r\ninit_waitqueue_head(&pchip->wq);\r\nmutex_init(&pchip->mutex);\r\n}\r\n}\r\nkfree(chip_map);\r\nreturn retcfi;\r\n}\r\nstatic int genprobe_new_chip(struct map_info *map, struct chip_probe *cp,\r\nstruct cfi_private *cfi)\r\n{\r\nint min_chips = (map_bankwidth(map)/4?:1);\r\nint max_chips = map_bankwidth(map);\r\nint nr_chips, type;\r\nfor (nr_chips = max_chips; nr_chips >= min_chips; nr_chips >>= 1) {\r\nif (!cfi_interleave_supported(nr_chips))\r\ncontinue;\r\ncfi->interleave = nr_chips;\r\ntype = map_bankwidth(map) / nr_chips;\r\nfor (; type <= CFI_DEVICETYPE_X32; type<<=1) {\r\ncfi->device_type = type;\r\nif (cp->probe_chip(map, 0, NULL, cfi))\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline struct mtd_info *cfi_cmdset_unknown(struct map_info *map,\r\nint primary)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\n__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;\r\n#ifdef CONFIG_MODULES\r\nchar probename[sizeof(VMLINUX_SYMBOL_STR(cfi_cmdset_%4.4X))];\r\ncfi_cmdset_fn_t *probe_function;\r\nsprintf(probename, VMLINUX_SYMBOL_STR(cfi_cmdset_%4.4X), type);\r\nprobe_function = __symbol_get(probename);\r\nif (!probe_function) {\r\nrequest_module("cfi_cmdset_%4.4X", type);\r\nprobe_function = __symbol_get(probename);\r\n}\r\nif (probe_function) {\r\nstruct mtd_info *mtd;\r\nmtd = (*probe_function)(map, primary);\r\nsymbol_put_addr(probe_function);\r\nreturn mtd;\r\n}\r\n#endif\r\nprintk(KERN_NOTICE "Support for command set %04X not present\n", type);\r\nreturn NULL;\r\n}\r\nstatic struct mtd_info *check_cmd_set(struct map_info *map, int primary)\r\n{\r\nstruct cfi_private *cfi = map->fldrv_priv;\r\n__u16 type = primary?cfi->cfiq->P_ID:cfi->cfiq->A_ID;\r\nif (type == P_ID_NONE || type == P_ID_RESERVED)\r\nreturn NULL;\r\nswitch(type){\r\n#ifdef CONFIG_MTD_CFI_INTELEXT\r\ncase P_ID_INTEL_EXT:\r\ncase P_ID_INTEL_STD:\r\ncase P_ID_INTEL_PERFORMANCE:\r\nreturn cfi_cmdset_0001(map, primary);\r\n#endif\r\n#ifdef CONFIG_MTD_CFI_AMDSTD\r\ncase P_ID_AMD_STD:\r\ncase P_ID_SST_OLD:\r\ncase P_ID_WINBOND:\r\nreturn cfi_cmdset_0002(map, primary);\r\n#endif\r\n#ifdef CONFIG_MTD_CFI_STAA\r\ncase P_ID_ST_ADV:\r\nreturn cfi_cmdset_0020(map, primary);\r\n#endif\r\ndefault:\r\nreturn cfi_cmdset_unknown(map, primary);\r\n}\r\n}
