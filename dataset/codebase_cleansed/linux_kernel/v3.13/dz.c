static inline struct dz_port *to_dport(struct uart_port *uport)\r\n{\r\nreturn container_of(uport, struct dz_port, port);\r\n}\r\nstatic u16 dz_in(struct dz_port *dport, unsigned offset)\r\n{\r\nvoid __iomem *addr = dport->port.membase + offset;\r\nreturn readw(addr);\r\n}\r\nstatic void dz_out(struct dz_port *dport, unsigned offset, u16 value)\r\n{\r\nvoid __iomem *addr = dport->port.membase + offset;\r\nwritew(value, addr);\r\n}\r\nstatic void dz_stop_tx(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nu16 tmp, mask = 1 << dport->port.line;\r\ntmp = dz_in(dport, DZ_TCR);\r\ntmp &= ~mask;\r\ndz_out(dport, DZ_TCR, tmp);\r\n}\r\nstatic void dz_start_tx(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nu16 tmp, mask = 1 << dport->port.line;\r\ntmp = dz_in(dport, DZ_TCR);\r\ntmp |= mask;\r\ndz_out(dport, DZ_TCR, tmp);\r\n}\r\nstatic void dz_stop_rx(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\ndport->cflag &= ~DZ_RXENAB;\r\ndz_out(dport, DZ_LPR, dport->cflag);\r\n}\r\nstatic void dz_enable_ms(struct uart_port *uport)\r\n{\r\n}\r\nstatic inline void dz_receive_chars(struct dz_mux *mux)\r\n{\r\nstruct uart_port *uport;\r\nstruct dz_port *dport = &mux->dport[0];\r\nstruct uart_icount *icount;\r\nint lines_rx[DZ_NB_PORT] = { [0 ... DZ_NB_PORT - 1] = 0 };\r\nunsigned char ch, flag;\r\nu16 status;\r\nint i;\r\nwhile ((status = dz_in(dport, DZ_RBUF)) & DZ_DVAL) {\r\ndport = &mux->dport[LINE(status)];\r\nuport = &dport->port;\r\nch = UCHAR(status);\r\nflag = TTY_NORMAL;\r\nicount = &uport->icount;\r\nicount->rx++;\r\nif (unlikely(status & (DZ_OERR | DZ_FERR | DZ_PERR))) {\r\nif (!ch) {\r\nstatus |= (status & DZ_FERR) >>\r\n(ffs(DZ_FERR) - ffs(DZ_BREAK));\r\nstatus &= ~DZ_FERR;\r\n}\r\nif (status & DZ_BREAK) {\r\nicount->brk++;\r\nif (uart_handle_break(uport))\r\ncontinue;\r\n} else if (status & DZ_FERR)\r\nicount->frame++;\r\nelse if (status & DZ_PERR)\r\nicount->parity++;\r\nif (status & DZ_OERR)\r\nicount->overrun++;\r\nstatus &= uport->read_status_mask;\r\nif (status & DZ_BREAK)\r\nflag = TTY_BREAK;\r\nelse if (status & DZ_FERR)\r\nflag = TTY_FRAME;\r\nelse if (status & DZ_PERR)\r\nflag = TTY_PARITY;\r\n}\r\nif (uart_handle_sysrq_char(uport, ch))\r\ncontinue;\r\nuart_insert_char(uport, status, DZ_OERR, ch, flag);\r\nlines_rx[LINE(status)] = 1;\r\n}\r\nfor (i = 0; i < DZ_NB_PORT; i++)\r\nif (lines_rx[i])\r\ntty_flip_buffer_push(&mux->dport[i].port.state->port);\r\n}\r\nstatic inline void dz_transmit_chars(struct dz_mux *mux)\r\n{\r\nstruct dz_port *dport = &mux->dport[0];\r\nstruct circ_buf *xmit;\r\nunsigned char tmp;\r\nu16 status;\r\nstatus = dz_in(dport, DZ_CSR);\r\ndport = &mux->dport[LINE(status)];\r\nxmit = &dport->port.state->xmit;\r\nif (dport->port.x_char) {\r\ndz_out(dport, DZ_TDR, dport->port.x_char);\r\ndport->port.icount.tx++;\r\ndport->port.x_char = 0;\r\nreturn;\r\n}\r\nif (uart_circ_empty(xmit) || uart_tx_stopped(&dport->port)) {\r\nspin_lock(&dport->port.lock);\r\ndz_stop_tx(&dport->port);\r\nspin_unlock(&dport->port.lock);\r\nreturn;\r\n}\r\ntmp = xmit->buf[xmit->tail];\r\nxmit->tail = (xmit->tail + 1) & (DZ_XMIT_SIZE - 1);\r\ndz_out(dport, DZ_TDR, tmp);\r\ndport->port.icount.tx++;\r\nif (uart_circ_chars_pending(xmit) < DZ_WAKEUP_CHARS)\r\nuart_write_wakeup(&dport->port);\r\nif (uart_circ_empty(xmit)) {\r\nspin_lock(&dport->port.lock);\r\ndz_stop_tx(&dport->port);\r\nspin_unlock(&dport->port.lock);\r\n}\r\n}\r\nstatic inline void check_modem_status(struct dz_port *dport)\r\n{\r\nu16 status;\r\nif (dport->port.line != DZ_MODEM)\r\nreturn;\r\nstatus = dz_in(dport, DZ_MSR);\r\nif (status)\r\ndport->port.icount.dsr++;\r\n}\r\nstatic irqreturn_t dz_interrupt(int irq, void *dev_id)\r\n{\r\nstruct dz_mux *mux = dev_id;\r\nstruct dz_port *dport = &mux->dport[0];\r\nu16 status;\r\nstatus = dz_in(dport, DZ_CSR);\r\nif ((status & (DZ_RDONE | DZ_RIE)) == (DZ_RDONE | DZ_RIE))\r\ndz_receive_chars(mux);\r\nif ((status & (DZ_TRDY | DZ_TIE)) == (DZ_TRDY | DZ_TIE))\r\ndz_transmit_chars(mux);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned int dz_get_mctrl(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nunsigned int mctrl = TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;\r\nif (dport->port.line == DZ_MODEM) {\r\nif (dz_in(dport, DZ_MSR) & DZ_MODEM_DSR)\r\nmctrl &= ~TIOCM_DSR;\r\n}\r\nreturn mctrl;\r\n}\r\nstatic void dz_set_mctrl(struct uart_port *uport, unsigned int mctrl)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nu16 tmp;\r\nif (dport->port.line == DZ_MODEM) {\r\ntmp = dz_in(dport, DZ_TCR);\r\nif (mctrl & TIOCM_DTR)\r\ntmp &= ~DZ_MODEM_DTR;\r\nelse\r\ntmp |= DZ_MODEM_DTR;\r\ndz_out(dport, DZ_TCR, tmp);\r\n}\r\n}\r\nstatic int dz_startup(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nstruct dz_mux *mux = dport->mux;\r\nunsigned long flags;\r\nint irq_guard;\r\nint ret;\r\nu16 tmp;\r\nirq_guard = atomic_add_return(1, &mux->irq_guard);\r\nif (irq_guard != 1)\r\nreturn 0;\r\nret = request_irq(dport->port.irq, dz_interrupt,\r\nIRQF_SHARED, "dz", mux);\r\nif (ret) {\r\natomic_add(-1, &mux->irq_guard);\r\nprintk(KERN_ERR "dz: Cannot get IRQ %d!\n", dport->port.irq);\r\nreturn ret;\r\n}\r\nspin_lock_irqsave(&dport->port.lock, flags);\r\ntmp = dz_in(dport, DZ_CSR);\r\ntmp |= DZ_RIE | DZ_TIE;\r\ndz_out(dport, DZ_CSR, tmp);\r\nspin_unlock_irqrestore(&dport->port.lock, flags);\r\nreturn 0;\r\n}\r\nstatic void dz_shutdown(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nstruct dz_mux *mux = dport->mux;\r\nunsigned long flags;\r\nint irq_guard;\r\nu16 tmp;\r\nspin_lock_irqsave(&dport->port.lock, flags);\r\ndz_stop_tx(&dport->port);\r\nspin_unlock_irqrestore(&dport->port.lock, flags);\r\nirq_guard = atomic_add_return(-1, &mux->irq_guard);\r\nif (!irq_guard) {\r\ntmp = dz_in(dport, DZ_CSR);\r\ntmp &= ~(DZ_RIE | DZ_TIE);\r\ndz_out(dport, DZ_CSR, tmp);\r\nfree_irq(dport->port.irq, mux);\r\n}\r\n}\r\nstatic unsigned int dz_tx_empty(struct uart_port *uport)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nunsigned short tmp, mask = 1 << dport->port.line;\r\ntmp = dz_in(dport, DZ_TCR);\r\ntmp &= mask;\r\nreturn tmp ? 0 : TIOCSER_TEMT;\r\n}\r\nstatic void dz_break_ctl(struct uart_port *uport, int break_state)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nunsigned long flags;\r\nunsigned short tmp, mask = 1 << dport->port.line;\r\nspin_lock_irqsave(&uport->lock, flags);\r\ntmp = dz_in(dport, DZ_TCR);\r\nif (break_state)\r\ntmp |= mask;\r\nelse\r\ntmp &= ~mask;\r\ndz_out(dport, DZ_TCR, tmp);\r\nspin_unlock_irqrestore(&uport->lock, flags);\r\n}\r\nstatic int dz_encode_baud_rate(unsigned int baud)\r\n{\r\nswitch (baud) {\r\ncase 50:\r\nreturn DZ_B50;\r\ncase 75:\r\nreturn DZ_B75;\r\ncase 110:\r\nreturn DZ_B110;\r\ncase 134:\r\nreturn DZ_B134;\r\ncase 150:\r\nreturn DZ_B150;\r\ncase 300:\r\nreturn DZ_B300;\r\ncase 600:\r\nreturn DZ_B600;\r\ncase 1200:\r\nreturn DZ_B1200;\r\ncase 1800:\r\nreturn DZ_B1800;\r\ncase 2000:\r\nreturn DZ_B2000;\r\ncase 2400:\r\nreturn DZ_B2400;\r\ncase 3600:\r\nreturn DZ_B3600;\r\ncase 4800:\r\nreturn DZ_B4800;\r\ncase 7200:\r\nreturn DZ_B7200;\r\ncase 9600:\r\nreturn DZ_B9600;\r\ndefault:\r\nreturn -1;\r\n}\r\n}\r\nstatic void dz_reset(struct dz_port *dport)\r\n{\r\nstruct dz_mux *mux = dport->mux;\r\nif (mux->initialised)\r\nreturn;\r\ndz_out(dport, DZ_CSR, DZ_CLR);\r\nwhile (dz_in(dport, DZ_CSR) & DZ_CLR);\r\niob();\r\ndz_out(dport, DZ_CSR, DZ_MSE);\r\nmux->initialised = 1;\r\n}\r\nstatic void dz_set_termios(struct uart_port *uport, struct ktermios *termios,\r\nstruct ktermios *old_termios)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nunsigned long flags;\r\nunsigned int cflag, baud;\r\nint bflag;\r\ncflag = dport->port.line;\r\nswitch (termios->c_cflag & CSIZE) {\r\ncase CS5:\r\ncflag |= DZ_CS5;\r\nbreak;\r\ncase CS6:\r\ncflag |= DZ_CS6;\r\nbreak;\r\ncase CS7:\r\ncflag |= DZ_CS7;\r\nbreak;\r\ncase CS8:\r\ndefault:\r\ncflag |= DZ_CS8;\r\n}\r\nif (termios->c_cflag & CSTOPB)\r\ncflag |= DZ_CSTOPB;\r\nif (termios->c_cflag & PARENB)\r\ncflag |= DZ_PARENB;\r\nif (termios->c_cflag & PARODD)\r\ncflag |= DZ_PARODD;\r\nbaud = uart_get_baud_rate(uport, termios, old_termios, 50, 9600);\r\nbflag = dz_encode_baud_rate(baud);\r\nif (bflag < 0) {\r\nbaud = uart_get_baud_rate(uport, old_termios, NULL, 50, 9600);\r\nbflag = dz_encode_baud_rate(baud);\r\nif (bflag < 0) {\r\nbaud = 9600;\r\nbflag = DZ_B9600;\r\n}\r\ntty_termios_encode_baud_rate(termios, baud, baud);\r\n}\r\ncflag |= bflag;\r\nif (termios->c_cflag & CREAD)\r\ncflag |= DZ_RXENAB;\r\nspin_lock_irqsave(&dport->port.lock, flags);\r\nuart_update_timeout(uport, termios->c_cflag, baud);\r\ndz_out(dport, DZ_LPR, cflag);\r\ndport->cflag = cflag;\r\ndport->port.read_status_mask = DZ_OERR;\r\nif (termios->c_iflag & INPCK)\r\ndport->port.read_status_mask |= DZ_FERR | DZ_PERR;\r\nif (termios->c_iflag & (BRKINT | PARMRK))\r\ndport->port.read_status_mask |= DZ_BREAK;\r\nuport->ignore_status_mask = 0;\r\nif ((termios->c_iflag & (IGNPAR | IGNBRK)) == (IGNPAR | IGNBRK))\r\ndport->port.ignore_status_mask |= DZ_OERR;\r\nif (termios->c_iflag & IGNPAR)\r\ndport->port.ignore_status_mask |= DZ_FERR | DZ_PERR;\r\nif (termios->c_iflag & IGNBRK)\r\ndport->port.ignore_status_mask |= DZ_BREAK;\r\nspin_unlock_irqrestore(&dport->port.lock, flags);\r\n}\r\nstatic void dz_pm(struct uart_port *uport, unsigned int state,\r\nunsigned int oldstate)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nunsigned long flags;\r\nspin_lock_irqsave(&dport->port.lock, flags);\r\nif (state < 3)\r\ndz_start_tx(&dport->port);\r\nelse\r\ndz_stop_tx(&dport->port);\r\nspin_unlock_irqrestore(&dport->port.lock, flags);\r\n}\r\nstatic const char *dz_type(struct uart_port *uport)\r\n{\r\nreturn "DZ";\r\n}\r\nstatic void dz_release_port(struct uart_port *uport)\r\n{\r\nstruct dz_mux *mux = to_dport(uport)->mux;\r\nint map_guard;\r\niounmap(uport->membase);\r\nuport->membase = NULL;\r\nmap_guard = atomic_add_return(-1, &mux->map_guard);\r\nif (!map_guard)\r\nrelease_mem_region(uport->mapbase, dec_kn_slot_size);\r\n}\r\nstatic int dz_map_port(struct uart_port *uport)\r\n{\r\nif (!uport->membase)\r\nuport->membase = ioremap_nocache(uport->mapbase,\r\ndec_kn_slot_size);\r\nif (!uport->membase) {\r\nprintk(KERN_ERR "dz: Cannot map MMIO\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dz_request_port(struct uart_port *uport)\r\n{\r\nstruct dz_mux *mux = to_dport(uport)->mux;\r\nint map_guard;\r\nint ret;\r\nmap_guard = atomic_add_return(1, &mux->map_guard);\r\nif (map_guard == 1) {\r\nif (!request_mem_region(uport->mapbase, dec_kn_slot_size,\r\n"dz")) {\r\natomic_add(-1, &mux->map_guard);\r\nprintk(KERN_ERR\r\n"dz: Unable to reserve MMIO resource\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = dz_map_port(uport);\r\nif (ret) {\r\nmap_guard = atomic_add_return(-1, &mux->map_guard);\r\nif (!map_guard)\r\nrelease_mem_region(uport->mapbase, dec_kn_slot_size);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dz_config_port(struct uart_port *uport, int flags)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nif (flags & UART_CONFIG_TYPE) {\r\nif (dz_request_port(uport))\r\nreturn;\r\nuport->type = PORT_DZ;\r\ndz_reset(dport);\r\n}\r\n}\r\nstatic int dz_verify_port(struct uart_port *uport, struct serial_struct *ser)\r\n{\r\nint ret = 0;\r\nif (ser->type != PORT_UNKNOWN && ser->type != PORT_DZ)\r\nret = -EINVAL;\r\nif (ser->irq != uport->irq)\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic void __init dz_init_ports(void)\r\n{\r\nstatic int first = 1;\r\nunsigned long base;\r\nint line;\r\nif (!first)\r\nreturn;\r\nfirst = 0;\r\nif (mips_machtype == MACH_DS23100 || mips_machtype == MACH_DS5100)\r\nbase = dec_kn_slot_base + KN01_DZ11;\r\nelse\r\nbase = dec_kn_slot_base + KN02_DZ11;\r\nfor (line = 0; line < DZ_NB_PORT; line++) {\r\nstruct dz_port *dport = &dz_mux.dport[line];\r\nstruct uart_port *uport = &dport->port;\r\ndport->mux = &dz_mux;\r\nuport->irq = dec_interrupt[DEC_IRQ_DZ11];\r\nuport->fifosize = 1;\r\nuport->iotype = UPIO_MEM;\r\nuport->flags = UPF_BOOT_AUTOCONF;\r\nuport->ops = &dz_ops;\r\nuport->line = line;\r\nuport->mapbase = base;\r\n}\r\n}\r\nstatic void dz_console_putchar(struct uart_port *uport, int ch)\r\n{\r\nstruct dz_port *dport = to_dport(uport);\r\nunsigned long flags;\r\nunsigned short csr, tcr, trdy, mask;\r\nint loops = 10000;\r\nspin_lock_irqsave(&dport->port.lock, flags);\r\ncsr = dz_in(dport, DZ_CSR);\r\ndz_out(dport, DZ_CSR, csr & ~DZ_TIE);\r\ntcr = dz_in(dport, DZ_TCR);\r\ntcr |= 1 << dport->port.line;\r\nmask = tcr;\r\ndz_out(dport, DZ_TCR, mask);\r\niob();\r\nspin_unlock_irqrestore(&dport->port.lock, flags);\r\ndo {\r\ntrdy = dz_in(dport, DZ_CSR);\r\nif (!(trdy & DZ_TRDY))\r\ncontinue;\r\ntrdy = (trdy & DZ_TLINE) >> 8;\r\nif (trdy == dport->port.line)\r\nbreak;\r\nmask &= ~(1 << trdy);\r\ndz_out(dport, DZ_TCR, mask);\r\niob();\r\nudelay(2);\r\n} while (--loops);\r\nif (loops)\r\ndz_out(dport, DZ_TDR, ch);\r\ndz_out(dport, DZ_TCR, tcr);\r\ndz_out(dport, DZ_CSR, csr);\r\n}\r\nstatic void dz_console_print(struct console *co,\r\nconst char *str,\r\nunsigned int count)\r\n{\r\nstruct dz_port *dport = &dz_mux.dport[co->index];\r\n#ifdef DEBUG_DZ\r\nprom_printf((char *) str);\r\n#endif\r\nuart_console_write(&dport->port, str, count, dz_console_putchar);\r\n}\r\nstatic int __init dz_console_setup(struct console *co, char *options)\r\n{\r\nstruct dz_port *dport = &dz_mux.dport[co->index];\r\nstruct uart_port *uport = &dport->port;\r\nint baud = 9600;\r\nint bits = 8;\r\nint parity = 'n';\r\nint flow = 'n';\r\nint ret;\r\nret = dz_map_port(uport);\r\nif (ret)\r\nreturn ret;\r\nspin_lock_init(&dport->port.lock);\r\ndz_reset(dport);\r\ndz_pm(uport, 0, -1);\r\nif (options)\r\nuart_parse_options(options, &baud, &parity, &bits, &flow);\r\nreturn uart_set_options(&dport->port, co, baud, parity, bits, flow);\r\n}\r\nstatic int __init dz_serial_console_init(void)\r\n{\r\nif (!IOASIC) {\r\ndz_init_ports();\r\nregister_console(&dz_console);\r\nreturn 0;\r\n} else\r\nreturn -ENXIO;\r\n}\r\nstatic int __init dz_init(void)\r\n{\r\nint ret, i;\r\nif (IOASIC)\r\nreturn -ENXIO;\r\nprintk("%s%s\n", dz_name, dz_version);\r\ndz_init_ports();\r\nret = uart_register_driver(&dz_reg);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < DZ_NB_PORT; i++)\r\nuart_add_one_port(&dz_reg, &dz_mux.dport[i].port);\r\nreturn 0;\r\n}
