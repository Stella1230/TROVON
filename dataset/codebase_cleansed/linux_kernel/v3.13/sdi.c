static bool dpi_calc_dispc_cb(int lckd, int pckd, unsigned long lck,\r\nunsigned long pck, void *data)\r\n{\r\nstruct sdi_clk_calc_ctx *ctx = data;\r\nctx->dispc_cinfo.lck_div = lckd;\r\nctx->dispc_cinfo.pck_div = pckd;\r\nctx->dispc_cinfo.lck = lck;\r\nctx->dispc_cinfo.pck = pck;\r\nreturn true;\r\n}\r\nstatic bool dpi_calc_dss_cb(int fckd, unsigned long fck, void *data)\r\n{\r\nstruct sdi_clk_calc_ctx *ctx = data;\r\nctx->dss_cinfo.fck = fck;\r\nctx->dss_cinfo.fck_div = fckd;\r\nreturn dispc_div_calc(fck, ctx->pck_min, ctx->pck_max,\r\ndpi_calc_dispc_cb, ctx);\r\n}\r\nstatic int sdi_calc_clock_div(unsigned long pclk,\r\nstruct dss_clock_info *dss_cinfo,\r\nstruct dispc_clock_info *dispc_cinfo)\r\n{\r\nint i;\r\nstruct sdi_clk_calc_ctx ctx;\r\nfor (i = 0; i < 10; ++i) {\r\nbool ok;\r\nmemset(&ctx, 0, sizeof(ctx));\r\nif (pclk > 1000 * i * i * i)\r\nctx.pck_min = max(pclk - 1000 * i * i * i, 0lu);\r\nelse\r\nctx.pck_min = 0;\r\nctx.pck_max = pclk + 1000 * i * i * i;\r\nok = dss_div_calc(ctx.pck_min, dpi_calc_dss_cb, &ctx);\r\nif (ok) {\r\n*dss_cinfo = ctx.dss_cinfo;\r\n*dispc_cinfo = ctx.dispc_cinfo;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void sdi_config_lcd_manager(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = sdi.output.manager;\r\nsdi.mgr_config.io_pad_mode = DSS_IO_PAD_MODE_BYPASS;\r\nsdi.mgr_config.stallmode = false;\r\nsdi.mgr_config.fifohandcheck = false;\r\nsdi.mgr_config.video_port_width = 24;\r\nsdi.mgr_config.lcden_sig_polarity = 1;\r\ndss_mgr_set_lcd_config(mgr, &sdi.mgr_config);\r\n}\r\nstatic int sdi_display_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_dss_device *out = &sdi.output;\r\nstruct omap_video_timings *t = &sdi.timings;\r\nstruct dss_clock_info dss_cinfo;\r\nstruct dispc_clock_info dispc_cinfo;\r\nunsigned long pck;\r\nint r;\r\nif (out == NULL || out->manager == NULL) {\r\nDSSERR("failed to enable display: no output/manager\n");\r\nreturn -ENODEV;\r\n}\r\nr = regulator_enable(sdi.vdds_sdi_reg);\r\nif (r)\r\ngoto err_reg_enable;\r\nr = dispc_runtime_get();\r\nif (r)\r\ngoto err_get_dispc;\r\nt->data_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\nt->sync_pclk_edge = OMAPDSS_DRIVE_SIG_RISING_EDGE;\r\nr = sdi_calc_clock_div(t->pixel_clock * 1000, &dss_cinfo, &dispc_cinfo);\r\nif (r)\r\ngoto err_calc_clock_div;\r\nsdi.mgr_config.clock_info = dispc_cinfo;\r\npck = dss_cinfo.fck / dispc_cinfo.lck_div / dispc_cinfo.pck_div / 1000;\r\nif (pck != t->pixel_clock) {\r\nDSSWARN("Could not find exact pixel clock. Requested %d kHz, "\r\n"got %lu kHz\n",\r\nt->pixel_clock, pck);\r\nt->pixel_clock = pck;\r\n}\r\ndss_mgr_set_timings(out->manager, t);\r\nr = dss_set_clock_div(&dss_cinfo);\r\nif (r)\r\ngoto err_set_dss_clock_div;\r\nsdi_config_lcd_manager(dssdev);\r\ndispc_mgr_set_clock_div(out->manager->id, &sdi.mgr_config.clock_info);\r\ndss_sdi_init(sdi.datapairs);\r\nr = dss_sdi_enable();\r\nif (r)\r\ngoto err_sdi_enable;\r\nmdelay(2);\r\nr = dss_mgr_enable(out->manager);\r\nif (r)\r\ngoto err_mgr_enable;\r\nreturn 0;\r\nerr_mgr_enable:\r\ndss_sdi_disable();\r\nerr_sdi_enable:\r\nerr_set_dss_clock_div:\r\nerr_calc_clock_div:\r\ndispc_runtime_put();\r\nerr_get_dispc:\r\nregulator_disable(sdi.vdds_sdi_reg);\r\nerr_reg_enable:\r\nreturn r;\r\n}\r\nstatic void sdi_display_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct omap_overlay_manager *mgr = sdi.output.manager;\r\ndss_mgr_disable(mgr);\r\ndss_sdi_disable();\r\ndispc_runtime_put();\r\nregulator_disable(sdi.vdds_sdi_reg);\r\n}\r\nstatic void sdi_set_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nsdi.timings = *timings;\r\n}\r\nstatic void sdi_get_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\n*timings = sdi.timings;\r\n}\r\nstatic int sdi_check_timings(struct omap_dss_device *dssdev,\r\nstruct omap_video_timings *timings)\r\n{\r\nstruct omap_overlay_manager *mgr = sdi.output.manager;\r\nif (mgr && !dispc_mgr_timings_ok(mgr->id, timings))\r\nreturn -EINVAL;\r\nif (timings->pixel_clock == 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void sdi_set_datapairs(struct omap_dss_device *dssdev, int datapairs)\r\n{\r\nsdi.datapairs = datapairs;\r\n}\r\nstatic int sdi_init_regulator(void)\r\n{\r\nstruct regulator *vdds_sdi;\r\nif (sdi.vdds_sdi_reg)\r\nreturn 0;\r\nvdds_sdi = devm_regulator_get(&sdi.pdev->dev, "vdds_sdi");\r\nif (IS_ERR(vdds_sdi)) {\r\nDSSERR("can't get VDDS_SDI regulator\n");\r\nreturn PTR_ERR(vdds_sdi);\r\n}\r\nsdi.vdds_sdi_reg = vdds_sdi;\r\nreturn 0;\r\n}\r\nstatic int sdi_connect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nstruct omap_overlay_manager *mgr;\r\nint r;\r\nr = sdi_init_regulator();\r\nif (r)\r\nreturn r;\r\nmgr = omap_dss_get_overlay_manager(dssdev->dispc_channel);\r\nif (!mgr)\r\nreturn -ENODEV;\r\nr = dss_mgr_connect(mgr, dssdev);\r\nif (r)\r\nreturn r;\r\nr = omapdss_output_set_device(dssdev, dst);\r\nif (r) {\r\nDSSERR("failed to connect output to new device: %s\n",\r\ndst->name);\r\ndss_mgr_disconnect(mgr, dssdev);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void sdi_disconnect(struct omap_dss_device *dssdev,\r\nstruct omap_dss_device *dst)\r\n{\r\nWARN_ON(dst != dssdev->dst);\r\nif (dst != dssdev->dst)\r\nreturn;\r\nomapdss_output_unset_device(dssdev);\r\nif (dssdev->manager)\r\ndss_mgr_disconnect(dssdev->manager, dssdev);\r\n}\r\nstatic void sdi_init_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &sdi.output;\r\nout->dev = &pdev->dev;\r\nout->id = OMAP_DSS_OUTPUT_SDI;\r\nout->output_type = OMAP_DISPLAY_TYPE_SDI;\r\nout->name = "sdi.0";\r\nout->dispc_channel = OMAP_DSS_CHANNEL_LCD;\r\nout->ops.sdi = &sdi_ops;\r\nout->owner = THIS_MODULE;\r\nomapdss_register_output(out);\r\n}\r\nstatic void __exit sdi_uninit_output(struct platform_device *pdev)\r\n{\r\nstruct omap_dss_device *out = &sdi.output;\r\nomapdss_unregister_output(out);\r\n}\r\nstatic int omap_sdi_probe(struct platform_device *pdev)\r\n{\r\nsdi.pdev = pdev;\r\nsdi_init_output(pdev);\r\nreturn 0;\r\n}\r\nstatic int __exit omap_sdi_remove(struct platform_device *pdev)\r\n{\r\nsdi_uninit_output(pdev);\r\nreturn 0;\r\n}\r\nint __init sdi_init_platform_driver(void)\r\n{\r\nreturn platform_driver_register(&omap_sdi_driver);\r\n}\r\nvoid __exit sdi_uninit_platform_driver(void)\r\n{\r\nplatform_driver_unregister(&omap_sdi_driver);\r\n}
