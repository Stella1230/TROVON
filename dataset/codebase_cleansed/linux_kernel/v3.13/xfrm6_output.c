int xfrm6_find_1stfragopt(struct xfrm_state *x, struct sk_buff *skb,\r\nu8 **prevhdr)\r\n{\r\nreturn ip6_find_1stfragopt(skb, prevhdr);\r\n}\r\nstatic int xfrm6_local_dontfrag(struct sk_buff *skb)\r\n{\r\nint proto;\r\nstruct sock *sk = skb->sk;\r\nif (sk) {\r\nif (sk->sk_family != AF_INET6)\r\nreturn 0;\r\nproto = sk->sk_protocol;\r\nif (proto == IPPROTO_UDP || proto == IPPROTO_RAW)\r\nreturn inet6_sk(sk)->dontfrag;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xfrm6_local_rxpmtu(struct sk_buff *skb, u32 mtu)\r\n{\r\nstruct flowi6 fl6;\r\nstruct sock *sk = skb->sk;\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nfl6.daddr = ipv6_hdr(skb)->daddr;\r\nipv6_local_rxpmtu(sk, &fl6, mtu);\r\n}\r\nvoid xfrm6_local_error(struct sk_buff *skb, u32 mtu)\r\n{\r\nstruct flowi6 fl6;\r\nconst struct ipv6hdr *hdr;\r\nstruct sock *sk = skb->sk;\r\nhdr = skb->encapsulation ? inner_ipv6_hdr(skb) : ipv6_hdr(skb);\r\nfl6.fl6_dport = inet_sk(sk)->inet_dport;\r\nfl6.daddr = hdr->daddr;\r\nipv6_local_error(sk, EMSGSIZE, &fl6, mtu);\r\n}\r\nstatic int xfrm6_tunnel_check_size(struct sk_buff *skb)\r\n{\r\nint mtu, ret = 0;\r\nstruct dst_entry *dst = skb_dst(skb);\r\nmtu = dst_mtu(dst);\r\nif (mtu < IPV6_MIN_MTU)\r\nmtu = IPV6_MIN_MTU;\r\nif (!skb->local_df && skb->len > mtu) {\r\nskb->dev = dst->dev;\r\nif (xfrm6_local_dontfrag(skb))\r\nxfrm6_local_rxpmtu(skb, mtu);\r\nelse if (skb->sk)\r\nxfrm_local_error(skb, mtu);\r\nelse\r\nicmpv6_send(skb, ICMPV6_PKT_TOOBIG, 0, mtu);\r\nret = -EMSGSIZE;\r\n}\r\nreturn ret;\r\n}\r\nint xfrm6_extract_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = xfrm6_tunnel_check_size(skb);\r\nif (err)\r\nreturn err;\r\nXFRM_MODE_SKB_CB(skb)->protocol = ipv6_hdr(skb)->nexthdr;\r\nreturn xfrm6_extract_header(skb);\r\n}\r\nint xfrm6_prepare_output(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nint err;\r\nerr = xfrm_inner_extract_output(x, skb);\r\nif (err)\r\nreturn err;\r\nmemset(IP6CB(skb), 0, sizeof(*IP6CB(skb)));\r\n#ifdef CONFIG_NETFILTER\r\nIP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;\r\n#endif\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb->local_df = 1;\r\nreturn x->outer_mode->output2(x, skb);\r\n}\r\nint xfrm6_output_finish(struct sk_buff *skb)\r\n{\r\n#ifdef CONFIG_NETFILTER\r\nIP6CB(skb)->flags |= IP6SKB_XFRM_TRANSFORMED;\r\n#endif\r\nskb->protocol = htons(ETH_P_IPV6);\r\nreturn xfrm_output(skb);\r\n}\r\nstatic int __xfrm6_output(struct sk_buff *skb)\r\n{\r\nstruct dst_entry *dst = skb_dst(skb);\r\nstruct xfrm_state *x = dst->xfrm;\r\nint mtu;\r\nif (skb->protocol == htons(ETH_P_IPV6))\r\nmtu = ip6_skb_dst_mtu(skb);\r\nelse\r\nmtu = dst_mtu(skb_dst(skb));\r\nif (skb->len > mtu && xfrm6_local_dontfrag(skb)) {\r\nxfrm6_local_rxpmtu(skb, mtu);\r\nreturn -EMSGSIZE;\r\n} else if (!skb->local_df && skb->len > mtu && skb->sk) {\r\nxfrm_local_error(skb, mtu);\r\nreturn -EMSGSIZE;\r\n}\r\nif (x->props.mode == XFRM_MODE_TUNNEL &&\r\n((skb->len > mtu && !skb_is_gso(skb)) ||\r\ndst_allfrag(skb_dst(skb)))) {\r\nreturn ip6_fragment(skb, x->outer_mode->afinfo->output_finish);\r\n}\r\nreturn x->outer_mode->afinfo->output_finish(skb);\r\n}\r\nint xfrm6_output(struct sk_buff *skb)\r\n{\r\nreturn NF_HOOK(NFPROTO_IPV6, NF_INET_POST_ROUTING, skb, NULL,\r\nskb_dst(skb)->dev, __xfrm6_output);\r\n}
