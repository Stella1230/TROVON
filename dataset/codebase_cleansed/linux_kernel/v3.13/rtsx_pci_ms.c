static inline struct device *ms_dev(struct realtek_pci_ms *host)\r\n{\r\nreturn &(host->pdev->dev);\r\n}\r\nstatic inline void ms_clear_error(struct realtek_pci_ms *host)\r\n{\r\nrtsx_pci_write_register(host->pcr, CARD_STOP,\r\nMS_STOP | MS_CLR_ERR, MS_STOP | MS_CLR_ERR);\r\n}\r\nstatic void ms_print_debug_regs(struct realtek_pci_ms *host)\r\n{\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nu16 i;\r\nu8 *ptr;\r\nrtsx_pci_init_cmd(pcr);\r\nfor (i = 0xFD40; i <= 0xFD44; i++)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, i, 0, 0);\r\nfor (i = 0xFD52; i <= 0xFD69; i++)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, i, 0, 0);\r\nrtsx_pci_send_cmd(pcr, 100);\r\nptr = rtsx_pci_get_cmd_data(pcr);\r\nfor (i = 0xFD40; i <= 0xFD44; i++)\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", i, *(ptr++));\r\nfor (i = 0xFD52; i <= 0xFD69; i++)\r\ndev_dbg(ms_dev(host), "0x%04X: 0x%02x\n", i, *(ptr++));\r\n}\r\nstatic int ms_power_on(struct realtek_pci_ms *host)\r\n{\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nint err;\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_SELECT, 0x07, MS_MOD_SEL);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_SHARE_MODE,\r\nCARD_SHARE_MASK, CARD_SHARE_48_MS);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN,\r\nMS_CLK_EN, MS_CLK_EN);\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nerr = rtsx_pci_card_pull_ctl_enable(pcr, RTSX_MS_CARD);\r\nif (err < 0)\r\nreturn err;\r\nerr = rtsx_pci_card_power_on(pcr, RTSX_MS_CARD);\r\nif (err < 0)\r\nreturn err;\r\nmsleep(150);\r\nerr = rtsx_pci_write_register(pcr, CARD_OE,\r\nMS_OUTPUT_EN, MS_OUTPUT_EN);\r\nif (err < 0)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int ms_power_off(struct realtek_pci_ms *host)\r\n{\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nint err;\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN, MS_CLK_EN, 0);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_OE, MS_OUTPUT_EN, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 100);\r\nif (err < 0)\r\nreturn err;\r\nerr = rtsx_pci_card_power_off(pcr, RTSX_MS_CARD);\r\nif (err < 0)\r\nreturn err;\r\nreturn rtsx_pci_card_pull_ctl_disable(pcr, RTSX_MS_CARD);\r\n}\r\nstatic int ms_transfer_data(struct realtek_pci_ms *host, unsigned char data_dir,\r\nu8 tpc, u8 cfg, struct scatterlist *sg)\r\n{\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nint err;\r\nunsigned int length = sg->length;\r\nu16 sec_cnt = (u16)(length / 512);\r\nu8 val, trans_mode, dma_dir;\r\ndev_dbg(ms_dev(host), "%s: tpc = 0x%02x, data_dir = %s, length = %d\n",\r\n__func__, tpc, (data_dir == READ) ? "READ" : "WRITE",\r\nlength);\r\nif (data_dir == READ) {\r\ndma_dir = DMA_DIR_FROM_CARD;\r\ntrans_mode = MS_TM_AUTO_READ;\r\n} else {\r\ndma_dir = DMA_DIR_TO_CARD;\r\ntrans_mode = MS_TM_AUTO_WRITE;\r\n}\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_SECTOR_CNT_H,\r\n0xFF, (u8)(sec_cnt >> 8));\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_SECTOR_CNT_L,\r\n0xFF, (u8)sec_cnt);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, IRQSTAT0,\r\nDMA_DONE_INT, DMA_DONE_INT);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC3, 0xFF, (u8)(length >> 24));\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC2, 0xFF, (u8)(length >> 16));\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC1, 0xFF, (u8)(length >> 8));\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC0, 0xFF, (u8)length);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMACTL,\r\n0x03 | DMA_PACK_SIZE_MASK, dma_dir | DMA_EN | DMA_512);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, RING_BUFFER);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANSFER,\r\n0xFF, MS_TRANSFER_START | trans_mode);\r\nrtsx_pci_add_cmd(pcr, CHECK_REG_CMD, MS_TRANSFER,\r\nMS_TRANSFER_END, MS_TRANSFER_END);\r\nrtsx_pci_send_cmd_no_wait(pcr);\r\nerr = rtsx_pci_transfer_data(pcr, sg, 1, data_dir == READ, 10000);\r\nif (err < 0) {\r\nms_clear_error(host);\r\nreturn err;\r\n}\r\nrtsx_pci_read_register(pcr, MS_TRANS_CFG, &val);\r\nif (val & (MS_INT_CMDNK | MS_INT_ERR | MS_CRC16_ERR | MS_RDY_TIMEOUT))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ms_write_bytes(struct realtek_pci_ms *host, u8 tpc,\r\nu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\r\n{\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nint err, i;\r\ndev_dbg(ms_dev(host), "%s: tpc = 0x%02x\n", __func__, tpc);\r\nif (!data)\r\nreturn -EINVAL;\r\nrtsx_pci_init_cmd(pcr);\r\nfor (i = 0; i < cnt; i++)\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\r\nPPBUF_BASE2 + i, 0xFF, data[i]);\r\nif (cnt % 2)\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\r\nPPBUF_BASE2 + i, 0xFF, 0xFF);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, PINGPONG_BUFFER);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANSFER,\r\n0xFF, MS_TRANSFER_START | MS_TM_WRITE_BYTES);\r\nrtsx_pci_add_cmd(pcr, CHECK_REG_CMD, MS_TRANSFER,\r\nMS_TRANSFER_END, MS_TRANSFER_END);\r\nif (int_reg)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 5000);\r\nif (err < 0) {\r\nu8 val;\r\nrtsx_pci_read_register(pcr, MS_TRANS_CFG, &val);\r\ndev_dbg(ms_dev(host), "MS_TRANS_CFG: 0x%02x\n", val);\r\nif (int_reg)\r\n*int_reg = val & 0x0F;\r\nms_print_debug_regs(host);\r\nms_clear_error(host);\r\nif (!(tpc & 0x08)) {\r\nif (val & MS_CRC16_ERR)\r\nreturn -EIO;\r\n} else {\r\nif (!(val & 0x80)) {\r\nif (val & (MS_INT_ERR | MS_INT_CMDNK))\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nif (int_reg) {\r\nu8 *ptr = rtsx_pci_get_cmd_data(pcr) + 1;\r\n*int_reg = *ptr & 0x0F;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ms_read_bytes(struct realtek_pci_ms *host, u8 tpc,\r\nu8 cfg, u8 cnt, u8 *data, u8 *int_reg)\r\n{\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nint err, i;\r\nu8 *ptr;\r\ndev_dbg(ms_dev(host), "%s: tpc = 0x%02x\n", __func__, tpc);\r\nif (!data)\r\nreturn -EINVAL;\r\nrtsx_pci_init_cmd(pcr);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TPC, 0xFF, tpc);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_BYTE_CNT, 0xFF, cnt);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANS_CFG, 0xFF, cfg);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, PINGPONG_BUFFER);\r\nrtsx_pci_add_cmd(pcr, WRITE_REG_CMD, MS_TRANSFER,\r\n0xFF, MS_TRANSFER_START | MS_TM_READ_BYTES);\r\nrtsx_pci_add_cmd(pcr, CHECK_REG_CMD, MS_TRANSFER,\r\nMS_TRANSFER_END, MS_TRANSFER_END);\r\nfor (i = 0; i < cnt - 1; i++)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, PPBUF_BASE2 + i, 0, 0);\r\nif (cnt % 2)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, PPBUF_BASE2 + cnt, 0, 0);\r\nelse\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD,\r\nPPBUF_BASE2 + cnt - 1, 0, 0);\r\nif (int_reg)\r\nrtsx_pci_add_cmd(pcr, READ_REG_CMD, MS_TRANS_CFG, 0, 0);\r\nerr = rtsx_pci_send_cmd(pcr, 5000);\r\nif (err < 0) {\r\nu8 val;\r\nrtsx_pci_read_register(pcr, MS_TRANS_CFG, &val);\r\ndev_dbg(ms_dev(host), "MS_TRANS_CFG: 0x%02x\n", val);\r\nif (int_reg)\r\n*int_reg = val & 0x0F;\r\nms_print_debug_regs(host);\r\nms_clear_error(host);\r\nif (!(tpc & 0x08)) {\r\nif (val & MS_CRC16_ERR)\r\nreturn -EIO;\r\n} else {\r\nif (!(val & 0x80)) {\r\nif (val & (MS_INT_ERR | MS_INT_CMDNK))\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nptr = rtsx_pci_get_cmd_data(pcr) + 1;\r\nfor (i = 0; i < cnt; i++)\r\ndata[i] = *ptr++;\r\nif (int_reg)\r\n*int_reg = *ptr & 0x0F;\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_ms_issue_cmd(struct realtek_pci_ms *host)\r\n{\r\nstruct memstick_request *req = host->req;\r\nint err = 0;\r\nu8 cfg = 0, int_reg;\r\ndev_dbg(ms_dev(host), "%s\n", __func__);\r\nif (req->need_card_int) {\r\nif (host->ifmode != MEMSTICK_SERIAL)\r\ncfg = WAIT_INT;\r\n}\r\nif (req->long_data) {\r\nerr = ms_transfer_data(host, req->data_dir,\r\nreq->tpc, cfg, &(req->sg));\r\n} else {\r\nif (req->data_dir == READ) {\r\nerr = ms_read_bytes(host, req->tpc, cfg,\r\nreq->data_len, req->data, &int_reg);\r\n} else {\r\nerr = ms_write_bytes(host, req->tpc, cfg,\r\nreq->data_len, req->data, &int_reg);\r\n}\r\n}\r\nif (err < 0)\r\nreturn err;\r\nif (req->need_card_int && (host->ifmode == MEMSTICK_SERIAL)) {\r\nerr = ms_read_bytes(host, MS_TPC_GET_INT,\r\nNO_WAIT_INT, 1, &int_reg, NULL);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (req->need_card_int) {\r\ndev_dbg(ms_dev(host), "int_reg: 0x%02x\n", int_reg);\r\nif (int_reg & MS_INT_CMDNK)\r\nreq->int_reg |= MEMSTICK_INT_CMDNAK;\r\nif (int_reg & MS_INT_BREQ)\r\nreq->int_reg |= MEMSTICK_INT_BREQ;\r\nif (int_reg & MS_INT_ERR)\r\nreq->int_reg |= MEMSTICK_INT_ERR;\r\nif (int_reg & MS_INT_CED)\r\nreq->int_reg |= MEMSTICK_INT_CED;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rtsx_pci_ms_handle_req(struct work_struct *work)\r\n{\r\nstruct realtek_pci_ms *host = container_of(work,\r\nstruct realtek_pci_ms, handle_req);\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nstruct memstick_host *msh = host->msh;\r\nint rc;\r\nmutex_lock(&pcr->pcr_mutex);\r\nrtsx_pci_start_run(pcr);\r\nrtsx_pci_switch_clock(host->pcr, host->clock, host->ssc_depth,\r\nfalse, true, false);\r\nrtsx_pci_write_register(pcr, CARD_SELECT, 0x07, MS_MOD_SEL);\r\nrtsx_pci_write_register(pcr, CARD_SHARE_MODE,\r\nCARD_SHARE_MASK, CARD_SHARE_48_MS);\r\nif (!host->req) {\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\ndev_dbg(ms_dev(host), "next req %d\n", rc);\r\nif (!rc)\r\nhost->req->error = rtsx_pci_ms_issue_cmd(host);\r\n} while (!rc);\r\n}\r\nmutex_unlock(&pcr->pcr_mutex);\r\n}\r\nstatic void rtsx_pci_ms_request(struct memstick_host *msh)\r\n{\r\nstruct realtek_pci_ms *host = memstick_priv(msh);\r\ndev_dbg(ms_dev(host), "--> %s\n", __func__);\r\nif (rtsx_pci_card_exclusive_check(host->pcr, RTSX_MS_CARD))\r\nreturn;\r\nschedule_work(&host->handle_req);\r\n}\r\nstatic int rtsx_pci_ms_set_param(struct memstick_host *msh,\r\nenum memstick_param param, int value)\r\n{\r\nstruct realtek_pci_ms *host = memstick_priv(msh);\r\nstruct rtsx_pcr *pcr = host->pcr;\r\nunsigned int clock = 0;\r\nu8 ssc_depth = 0;\r\nint err;\r\ndev_dbg(ms_dev(host), "%s: param = %d, value = %d\n",\r\n__func__, param, value);\r\nerr = rtsx_pci_card_exclusive_check(host->pcr, RTSX_MS_CARD);\r\nif (err)\r\nreturn err;\r\nswitch (param) {\r\ncase MEMSTICK_POWER:\r\nif (value == MEMSTICK_POWER_ON)\r\nerr = ms_power_on(host);\r\nelse if (value == MEMSTICK_POWER_OFF)\r\nerr = ms_power_off(host);\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ncase MEMSTICK_INTERFACE:\r\nif (value == MEMSTICK_SERIAL) {\r\nclock = 19000000;\r\nssc_depth = RTSX_SSC_DEPTH_500K;\r\nerr = rtsx_pci_write_register(pcr, MS_CFG,\r\n0x18, MS_BUS_WIDTH_1);\r\nif (err < 0)\r\nreturn err;\r\n} else if (value == MEMSTICK_PAR4) {\r\nclock = 39000000;\r\nssc_depth = RTSX_SSC_DEPTH_1M;\r\nerr = rtsx_pci_write_register(pcr, MS_CFG,\r\n0x58, MS_BUS_WIDTH_4 | PUSH_TIME_ODD);\r\nif (err < 0)\r\nreturn err;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nerr = rtsx_pci_switch_clock(pcr, clock,\r\nssc_depth, false, true, false);\r\nif (err < 0)\r\nreturn err;\r\nhost->ssc_depth = ssc_depth;\r\nhost->clock = clock;\r\nhost->ifmode = value;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_ms_suspend(struct platform_device *pdev, pm_message_t state)\r\n{\r\nstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\r\nstruct memstick_host *msh = host->msh;\r\ndev_dbg(ms_dev(host), "--> %s\n", __func__);\r\nmemstick_suspend_host(msh);\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_ms_resume(struct platform_device *pdev)\r\n{\r\nstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\r\nstruct memstick_host *msh = host->msh;\r\ndev_dbg(ms_dev(host), "--> %s\n", __func__);\r\nmemstick_resume_host(msh);\r\nreturn 0;\r\n}\r\nstatic void rtsx_pci_ms_card_event(struct platform_device *pdev)\r\n{\r\nstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\r\nmemstick_detect_change(host->msh);\r\n}\r\nstatic int rtsx_pci_ms_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct memstick_host *msh;\r\nstruct realtek_pci_ms *host;\r\nstruct rtsx_pcr *pcr;\r\nstruct pcr_handle *handle = pdev->dev.platform_data;\r\nint rc;\r\nif (!handle)\r\nreturn -ENXIO;\r\npcr = handle->pcr;\r\nif (!pcr)\r\nreturn -ENXIO;\r\ndev_dbg(&(pdev->dev),\r\n": Realtek PCI-E Memstick controller found\n");\r\nmsh = memstick_alloc_host(sizeof(*host), &pdev->dev);\r\nif (!msh)\r\nreturn -ENOMEM;\r\nhost = memstick_priv(msh);\r\nhost->pcr = pcr;\r\nhost->msh = msh;\r\nhost->pdev = pdev;\r\nplatform_set_drvdata(pdev, host);\r\npcr->slots[RTSX_MS_CARD].p_dev = pdev;\r\npcr->slots[RTSX_MS_CARD].card_event = rtsx_pci_ms_card_event;\r\nmutex_init(&host->host_mutex);\r\nINIT_WORK(&host->handle_req, rtsx_pci_ms_handle_req);\r\nmsh->request = rtsx_pci_ms_request;\r\nmsh->set_param = rtsx_pci_ms_set_param;\r\nmsh->caps = MEMSTICK_CAP_PAR4;\r\nrc = memstick_add_host(msh);\r\nif (rc) {\r\nmemstick_free_host(msh);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtsx_pci_ms_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct realtek_pci_ms *host = platform_get_drvdata(pdev);\r\nstruct rtsx_pcr *pcr;\r\nstruct memstick_host *msh;\r\nint rc;\r\nif (!host)\r\nreturn 0;\r\npcr = host->pcr;\r\npcr->slots[RTSX_MS_CARD].p_dev = NULL;\r\npcr->slots[RTSX_MS_CARD].card_event = NULL;\r\nmsh = host->msh;\r\nhost->eject = true;\r\nmutex_lock(&host->host_mutex);\r\nif (host->req) {\r\ndev_dbg(&(pdev->dev),\r\n"%s: Controller removed during transfer\n",\r\ndev_name(&msh->dev));\r\nrtsx_pci_complete_unfinished_transfer(pcr);\r\nhost->req->error = -ENOMEDIUM;\r\ndo {\r\nrc = memstick_next_req(msh, &host->req);\r\nif (!rc)\r\nhost->req->error = -ENOMEDIUM;\r\n} while (!rc);\r\n}\r\nmutex_unlock(&host->host_mutex);\r\nmemstick_remove_host(msh);\r\nmemstick_free_host(msh);\r\ndev_dbg(&(pdev->dev),\r\n": Realtek PCI-E Memstick controller has been removed\n");\r\nreturn 0;\r\n}
