static void tfp410_encoder_destroy(struct drm_encoder *encoder)\r\n{\r\nstruct tfp410_encoder *tfp410_encoder = to_tfp410_encoder(encoder);\r\ndrm_encoder_cleanup(encoder);\r\nkfree(tfp410_encoder);\r\n}\r\nstatic void tfp410_encoder_dpms(struct drm_encoder *encoder, int mode)\r\n{\r\nstruct tfp410_encoder *tfp410_encoder = to_tfp410_encoder(encoder);\r\nif (tfp410_encoder->dpms == mode)\r\nreturn;\r\nif (mode == DRM_MODE_DPMS_ON) {\r\nDBG("Power on");\r\ngpio_direction_output(tfp410_encoder->mod->gpio, 1);\r\n} else {\r\nDBG("Power off");\r\ngpio_direction_output(tfp410_encoder->mod->gpio, 0);\r\n}\r\ntfp410_encoder->dpms = mode;\r\n}\r\nstatic bool tfp410_encoder_mode_fixup(struct drm_encoder *encoder,\r\nconst struct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\nreturn true;\r\n}\r\nstatic void tfp410_encoder_prepare(struct drm_encoder *encoder)\r\n{\r\ntfp410_encoder_dpms(encoder, DRM_MODE_DPMS_OFF);\r\ntilcdc_crtc_set_panel_info(encoder->crtc, &dvi_info);\r\n}\r\nstatic void tfp410_encoder_commit(struct drm_encoder *encoder)\r\n{\r\ntfp410_encoder_dpms(encoder, DRM_MODE_DPMS_ON);\r\n}\r\nstatic void tfp410_encoder_mode_set(struct drm_encoder *encoder,\r\nstruct drm_display_mode *mode,\r\nstruct drm_display_mode *adjusted_mode)\r\n{\r\n}\r\nstatic struct drm_encoder *tfp410_encoder_create(struct drm_device *dev,\r\nstruct tfp410_module *mod)\r\n{\r\nstruct tfp410_encoder *tfp410_encoder;\r\nstruct drm_encoder *encoder;\r\nint ret;\r\ntfp410_encoder = kzalloc(sizeof(*tfp410_encoder), GFP_KERNEL);\r\nif (!tfp410_encoder) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\ntfp410_encoder->dpms = DRM_MODE_DPMS_OFF;\r\ntfp410_encoder->mod = mod;\r\nencoder = &tfp410_encoder->base;\r\nencoder->possible_crtcs = 1;\r\nret = drm_encoder_init(dev, encoder, &tfp410_encoder_funcs,\r\nDRM_MODE_ENCODER_TMDS);\r\nif (ret < 0)\r\ngoto fail;\r\ndrm_encoder_helper_add(encoder, &tfp410_encoder_helper_funcs);\r\nreturn encoder;\r\nfail:\r\ntfp410_encoder_destroy(encoder);\r\nreturn NULL;\r\n}\r\nstatic void tfp410_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct tfp410_connector *tfp410_connector = to_tfp410_connector(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(tfp410_connector);\r\n}\r\nstatic enum drm_connector_status tfp410_connector_detect(\r\nstruct drm_connector *connector,\r\nbool force)\r\n{\r\nstruct tfp410_connector *tfp410_connector = to_tfp410_connector(connector);\r\nif (drm_probe_ddc(tfp410_connector->mod->i2c))\r\nreturn connector_status_connected;\r\nreturn connector_status_unknown;\r\n}\r\nstatic int tfp410_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct tfp410_connector *tfp410_connector = to_tfp410_connector(connector);\r\nstruct edid *edid;\r\nint ret = 0;\r\nedid = drm_get_edid(connector, tfp410_connector->mod->i2c);\r\ndrm_mode_connector_update_edid_property(connector, edid);\r\nif (edid) {\r\nret = drm_add_edid_modes(connector, edid);\r\nkfree(edid);\r\n}\r\nreturn ret;\r\n}\r\nstatic int tfp410_connector_mode_valid(struct drm_connector *connector,\r\nstruct drm_display_mode *mode)\r\n{\r\nstruct tilcdc_drm_private *priv = connector->dev->dev_private;\r\nreturn tilcdc_crtc_mode_valid(priv->crtc, mode);\r\n}\r\nstatic struct drm_encoder *tfp410_connector_best_encoder(\r\nstruct drm_connector *connector)\r\n{\r\nstruct tfp410_connector *tfp410_connector = to_tfp410_connector(connector);\r\nreturn tfp410_connector->encoder;\r\n}\r\nstatic struct drm_connector *tfp410_connector_create(struct drm_device *dev,\r\nstruct tfp410_module *mod, struct drm_encoder *encoder)\r\n{\r\nstruct tfp410_connector *tfp410_connector;\r\nstruct drm_connector *connector;\r\nint ret;\r\ntfp410_connector = kzalloc(sizeof(*tfp410_connector), GFP_KERNEL);\r\nif (!tfp410_connector) {\r\ndev_err(dev->dev, "allocation failed\n");\r\nreturn NULL;\r\n}\r\ntfp410_connector->encoder = encoder;\r\ntfp410_connector->mod = mod;\r\nconnector = &tfp410_connector->base;\r\ndrm_connector_init(dev, connector, &tfp410_connector_funcs,\r\nDRM_MODE_CONNECTOR_DVID);\r\ndrm_connector_helper_add(connector, &tfp410_connector_helper_funcs);\r\nconnector->polled = DRM_CONNECTOR_POLL_CONNECT |\r\nDRM_CONNECTOR_POLL_DISCONNECT;\r\nconnector->interlace_allowed = 0;\r\nconnector->doublescan_allowed = 0;\r\nret = drm_mode_connector_attach_encoder(connector, encoder);\r\nif (ret)\r\ngoto fail;\r\ndrm_sysfs_connector_add(connector);\r\nreturn connector;\r\nfail:\r\ntfp410_connector_destroy(connector);\r\nreturn NULL;\r\n}\r\nstatic int tfp410_modeset_init(struct tilcdc_module *mod, struct drm_device *dev)\r\n{\r\nstruct tfp410_module *tfp410_mod = to_tfp410_module(mod);\r\nstruct tilcdc_drm_private *priv = dev->dev_private;\r\nstruct drm_encoder *encoder;\r\nstruct drm_connector *connector;\r\nencoder = tfp410_encoder_create(dev, tfp410_mod);\r\nif (!encoder)\r\nreturn -ENOMEM;\r\nconnector = tfp410_connector_create(dev, tfp410_mod, encoder);\r\nif (!connector)\r\nreturn -ENOMEM;\r\npriv->encoders[priv->num_encoders++] = encoder;\r\npriv->connectors[priv->num_connectors++] = connector;\r\nreturn 0;\r\n}\r\nstatic void tfp410_destroy(struct tilcdc_module *mod)\r\n{\r\nstruct tfp410_module *tfp410_mod = to_tfp410_module(mod);\r\nif (tfp410_mod->i2c)\r\ni2c_put_adapter(tfp410_mod->i2c);\r\nif (!IS_ERR_VALUE(tfp410_mod->gpio))\r\ngpio_free(tfp410_mod->gpio);\r\ntilcdc_module_cleanup(mod);\r\nkfree(tfp410_mod);\r\n}\r\nstatic int tfp410_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *i2c_node;\r\nstruct tfp410_module *tfp410_mod;\r\nstruct tilcdc_module *mod;\r\nstruct pinctrl *pinctrl;\r\nuint32_t i2c_phandle;\r\nint ret = -EINVAL;\r\nif (!node) {\r\ndev_err(&pdev->dev, "device-tree data is missing\n");\r\nreturn -ENXIO;\r\n}\r\ntfp410_mod = kzalloc(sizeof(*tfp410_mod), GFP_KERNEL);\r\nif (!tfp410_mod)\r\nreturn -ENOMEM;\r\nmod = &tfp410_mod->base;\r\ntilcdc_module_init(mod, "tfp410", &tfp410_module_ops);\r\npinctrl = devm_pinctrl_get_select_default(&pdev->dev);\r\nif (IS_ERR(pinctrl))\r\ndev_warn(&pdev->dev, "pins are not configured\n");\r\nif (of_property_read_u32(node, "i2c", &i2c_phandle)) {\r\ndev_err(&pdev->dev, "could not get i2c bus phandle\n");\r\ngoto fail;\r\n}\r\nmod->preferred_bpp = dvi_info.bpp;\r\ni2c_node = of_find_node_by_phandle(i2c_phandle);\r\nif (!i2c_node) {\r\ndev_err(&pdev->dev, "could not get i2c bus node\n");\r\ngoto fail;\r\n}\r\ntfp410_mod->i2c = of_find_i2c_adapter_by_node(i2c_node);\r\nif (!tfp410_mod->i2c) {\r\ndev_err(&pdev->dev, "could not get i2c\n");\r\ngoto fail;\r\n}\r\nof_node_put(i2c_node);\r\ntfp410_mod->gpio = of_get_named_gpio_flags(node, "powerdn-gpio",\r\n0, NULL);\r\nif (IS_ERR_VALUE(tfp410_mod->gpio)) {\r\ndev_warn(&pdev->dev, "No power down GPIO\n");\r\n} else {\r\nret = gpio_request(tfp410_mod->gpio, "DVI_PDn");\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not get DVI_PDn gpio\n");\r\ngoto fail;\r\n}\r\n}\r\nreturn 0;\r\nfail:\r\ntfp410_destroy(mod);\r\nreturn ret;\r\n}\r\nstatic int tfp410_remove(struct platform_device *pdev)\r\n{\r\nreturn 0;\r\n}\r\nint __init tilcdc_tfp410_init(void)\r\n{\r\nreturn platform_driver_register(&tfp410_driver);\r\n}\r\nvoid __exit tilcdc_tfp410_fini(void)\r\n{\r\nplatform_driver_unregister(&tfp410_driver);\r\n}
