static bool check_vif_up(struct brcmf_cfg80211_vif *vif)\r\n{\r\nif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state)) {\r\nbrcmf_dbg(INFO, "device is not ready : status (%lu)\n",\r\nvif->sme_state);\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic u16 brcmf_qdbm_to_mw(u8 qdbm)\r\n{\r\nuint factor = 1;\r\nint idx = qdbm - QDBM_OFFSET;\r\nif (idx >= QDBM_TABLE_LEN)\r\nreturn 0xFFFF;\r\nwhile (idx < 0) {\r\nidx += 40;\r\nfactor *= 10;\r\n}\r\nreturn (nqdBm_to_mW_map[idx] + factor / 2) / factor;\r\n}\r\nstatic u8 brcmf_mw_to_qdbm(u16 mw)\r\n{\r\nu8 qdbm;\r\nint offset;\r\nuint mw_uint = mw;\r\nuint boundary;\r\nif (mw_uint <= 1)\r\nreturn 0;\r\noffset = QDBM_OFFSET;\r\nwhile (mw_uint < QDBM_TABLE_LOW_BOUND) {\r\nmw_uint *= 10;\r\noffset -= 40;\r\n}\r\nfor (qdbm = 0; qdbm < QDBM_TABLE_LEN - 1; qdbm++) {\r\nboundary = nqdBm_to_mW_map[qdbm] + (nqdBm_to_mW_map[qdbm + 1] -\r\nnqdBm_to_mW_map[qdbm]) / 2;\r\nif (mw_uint < boundary)\r\nbreak;\r\n}\r\nqdbm += (u8) offset;\r\nreturn qdbm;\r\n}\r\nu16 channel_to_chanspec(struct brcmu_d11inf *d11inf,\r\nstruct ieee80211_channel *ch)\r\n{\r\nstruct brcmu_chan ch_inf;\r\nch_inf.chnum = ieee80211_frequency_to_channel(ch->center_freq);\r\nch_inf.bw = BRCMU_CHAN_BW_20;\r\nd11inf->encchspec(&ch_inf);\r\nreturn ch_inf.chspec;\r\n}\r\nstruct brcmf_tlv *brcmf_parse_tlvs(void *buf, int buflen, uint key)\r\n{\r\nstruct brcmf_tlv *elt;\r\nint totlen;\r\nelt = (struct brcmf_tlv *)buf;\r\ntotlen = buflen;\r\nwhile (totlen >= TLV_HDR_LEN) {\r\nint len = elt->len;\r\nif ((elt->id == key) && (totlen >= (len + TLV_HDR_LEN)))\r\nreturn elt;\r\nelt = (struct brcmf_tlv *)((u8 *)elt + (len + TLV_HDR_LEN));\r\ntotlen -= (len + TLV_HDR_LEN);\r\n}\r\nreturn NULL;\r\n}\r\nstatic bool\r\nbrcmf_tlv_has_ie(u8 *ie, u8 **tlvs, u32 *tlvs_len,\r\nu8 *oui, u32 oui_len, u8 type)\r\n{\r\nif (ie[TLV_LEN_OFF] >= oui_len + 1 &&\r\n!memcmp(&ie[TLV_BODY_OFF], oui, oui_len) &&\r\ntype == ie[TLV_BODY_OFF + oui_len]) {\r\nreturn true;\r\n}\r\nif (tlvs == NULL)\r\nreturn false;\r\nie += ie[TLV_LEN_OFF] + TLV_HDR_LEN;\r\n*tlvs_len -= (int)(ie - *tlvs);\r\n*tlvs = ie;\r\nreturn false;\r\n}\r\nstatic struct brcmf_vs_tlv *\r\nbrcmf_find_wpaie(u8 *parse, u32 len)\r\n{\r\nstruct brcmf_tlv *ie;\r\nwhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\r\nif (brcmf_tlv_has_ie((u8 *)ie, &parse, &len,\r\nWPA_OUI, TLV_OUI_LEN, WPA_OUI_TYPE))\r\nreturn (struct brcmf_vs_tlv *)ie;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct brcmf_vs_tlv *\r\nbrcmf_find_wpsie(u8 *parse, u32 len)\r\n{\r\nstruct brcmf_tlv *ie;\r\nwhile ((ie = brcmf_parse_tlvs(parse, len, WLAN_EID_VENDOR_SPECIFIC))) {\r\nif (brcmf_tlv_has_ie((u8 *)ie, &parse, &len,\r\nWPA_OUI, TLV_OUI_LEN, WPS_OUI_TYPE))\r\nreturn (struct brcmf_vs_tlv *)ie;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void convert_key_from_CPU(struct brcmf_wsec_key *key,\r\nstruct brcmf_wsec_key_le *key_le)\r\n{\r\nkey_le->index = cpu_to_le32(key->index);\r\nkey_le->len = cpu_to_le32(key->len);\r\nkey_le->algo = cpu_to_le32(key->algo);\r\nkey_le->flags = cpu_to_le32(key->flags);\r\nkey_le->rxiv.hi = cpu_to_le32(key->rxiv.hi);\r\nkey_le->rxiv.lo = cpu_to_le16(key->rxiv.lo);\r\nkey_le->iv_initialized = cpu_to_le32(key->iv_initialized);\r\nmemcpy(key_le->data, key->data, sizeof(key->data));\r\nmemcpy(key_le->ea, key->ea, sizeof(key->ea));\r\n}\r\nstatic int\r\nsend_key_to_dongle(struct net_device *ndev, struct brcmf_wsec_key *key)\r\n{\r\nint err;\r\nstruct brcmf_wsec_key_le key_le;\r\nconvert_key_from_CPU(key, &key_le);\r\nbrcmf_netdev_wait_pend8021x(ndev);\r\nerr = brcmf_fil_bsscfg_data_set(netdev_priv(ndev), "wsec_key", &key_le,\r\nsizeof(key_le));\r\nif (err)\r\nbrcmf_err("wsec_key error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_configure_arp_offload(struct brcmf_if *ifp, bool enable)\r\n{\r\ns32 err;\r\nu32 mode;\r\nif (enable)\r\nmode = BRCMF_ARP_OL_AGENT | BRCMF_ARP_OL_PEER_AUTO_REPLY;\r\nelse\r\nmode = 0;\r\nerr = brcmf_fil_iovar_int_set(ifp, "arp_ol", mode);\r\nif (err) {\r\nbrcmf_dbg(TRACE, "failed to set ARP offload mode to 0x%x, err = %d\n",\r\nmode, err);\r\nerr = 0;\r\n} else {\r\nerr = brcmf_fil_iovar_int_set(ifp, "arpoe", enable);\r\nif (err) {\r\nbrcmf_dbg(TRACE, "failed to configure (%d) ARP offload err = %d\n",\r\nenable, err);\r\nerr = 0;\r\n} else\r\nbrcmf_dbg(TRACE, "successfully configured (%d) ARP offload to 0x%x\n",\r\nenable, mode);\r\n}\r\nreturn err;\r\n}\r\nstatic struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,\r\nconst char *name,\r\nenum nl80211_iftype type,\r\nu32 *flags,\r\nstruct vif_params *params)\r\n{\r\nbrcmf_dbg(TRACE, "enter: %s type %d\n", name, type);\r\nswitch (type) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nreturn brcmf_p2p_add_vif(wiphy, name, type, flags, params);\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\ndefault:\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nvoid brcmf_set_mpc(struct brcmf_if *ifp, int mpc)\r\n{\r\ns32 err = 0;\r\nif (check_vif_up(ifp->vif)) {\r\nerr = brcmf_fil_iovar_int_set(ifp, "mpc", mpc);\r\nif (err) {\r\nbrcmf_err("fail to set mpc\n");\r\nreturn;\r\n}\r\nbrcmf_dbg(INFO, "MPC : %d\n", mpc);\r\n}\r\n}\r\ns32 brcmf_notify_escan_complete(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_if *ifp, bool aborted,\r\nbool fw_abort)\r\n{\r\nstruct brcmf_scan_params_le params_le;\r\nstruct cfg80211_scan_request *scan_request;\r\ns32 err = 0;\r\nbrcmf_dbg(SCAN, "Enter\n");\r\nscan_request = cfg->scan_request;\r\ncfg->scan_request = NULL;\r\nif (timer_pending(&cfg->escan_timeout))\r\ndel_timer_sync(&cfg->escan_timeout);\r\nif (fw_abort) {\r\nbrcmf_dbg(SCAN, "ABORT scan in firmware\n");\r\nmemset(&params_le, 0, sizeof(params_le));\r\nmemset(params_le.bssid, 0xFF, ETH_ALEN);\r\nparams_le.bss_type = DOT11_BSSTYPE_ANY;\r\nparams_le.scan_type = 0;\r\nparams_le.channel_num = cpu_to_le32(1);\r\nparams_le.nprobes = cpu_to_le32(1);\r\nparams_le.active_time = cpu_to_le32(-1);\r\nparams_le.passive_time = cpu_to_le32(-1);\r\nparams_le.home_time = cpu_to_le32(-1);\r\nparams_le.channel_list[0] = cpu_to_le16(-1);\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,\r\n&params_le, sizeof(params_le));\r\nif (err)\r\nbrcmf_err("Scan abort failed\n");\r\n}\r\nif (cfg->sched_escan) {\r\nbrcmf_dbg(SCAN, "scheduled scan completed\n");\r\ncfg->sched_escan = false;\r\nif (!aborted)\r\ncfg80211_sched_scan_results(cfg_to_wiphy(cfg));\r\nbrcmf_set_mpc(ifp, 1);\r\n} else if (scan_request) {\r\nbrcmf_dbg(SCAN, "ESCAN Completed scan: %s\n",\r\naborted ? "Aborted" : "Done");\r\ncfg80211_scan_done(scan_request, aborted);\r\nbrcmf_set_mpc(ifp, 1);\r\n}\r\nif (!test_and_clear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\r\nbrcmf_dbg(SCAN, "Scan complete, probably P2P scan\n");\r\nreturn err;\r\n}\r\nstatic\r\nint brcmf_cfg80211_del_iface(struct wiphy *wiphy, struct wireless_dev *wdev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\r\nstruct net_device *ndev = wdev->netdev;\r\nif (brcmf_cfg80211_vif_event_armed(cfg))\r\nreturn -EBUSY;\r\nif (ndev) {\r\nif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status) &&\r\ncfg->escan_info.ifp == netdev_priv(ndev))\r\nbrcmf_notify_escan_complete(cfg, netdev_priv(ndev),\r\ntrue, true);\r\nbrcmf_fil_iovar_int_set(netdev_priv(ndev), "mpc", 1);\r\n}\r\nswitch (wdev->iftype) {\r\ncase NL80211_IFTYPE_ADHOC:\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nreturn -EOPNOTSUPP;\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\ncase NL80211_IFTYPE_P2P_GO:\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nreturn brcmf_p2p_del_vif(wiphy, wdev);\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_change_iface(struct wiphy *wiphy, struct net_device *ndev,\r\nenum nl80211_iftype type, u32 *flags,\r\nstruct vif_params *params)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_vif *vif = ifp->vif;\r\ns32 infra = 0;\r\ns32 ap = 0;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter, ndev=%p, type=%d\n", ndev, type);\r\nswitch (type) {\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_WDS:\r\nbrcmf_err("type (%d) : currently we do not support this type\n",\r\ntype);\r\nreturn -EOPNOTSUPP;\r\ncase NL80211_IFTYPE_ADHOC:\r\nvif->mode = WL_MODE_IBSS;\r\ninfra = 0;\r\nbreak;\r\ncase NL80211_IFTYPE_STATION:\r\nif ((vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) ||\r\n(vif->wdev.iftype == NL80211_IFTYPE_P2P_GO)) {\r\nbrcmf_dbg(TRACE, "Ignoring cmd for p2p if\n");\r\nreturn 0;\r\n}\r\nvif->mode = WL_MODE_BSS;\r\ninfra = 1;\r\nbreak;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\nvif->mode = WL_MODE_AP;\r\nap = 1;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nif (ap) {\r\nif (type == NL80211_IFTYPE_P2P_GO) {\r\nbrcmf_dbg(INFO, "IF Type = P2P GO\n");\r\nerr = brcmf_p2p_ifchange(cfg, BRCMF_FIL_P2P_IF_GO);\r\n}\r\nif (!err) {\r\nset_bit(BRCMF_VIF_STATUS_AP_CREATING, &vif->sme_state);\r\nbrcmf_dbg(INFO, "IF Type = AP\n");\r\n}\r\n} else {\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, infra);\r\nif (err) {\r\nbrcmf_err("WLC_SET_INFRA error (%d)\n", err);\r\nerr = -EAGAIN;\r\ngoto done;\r\n}\r\nbrcmf_dbg(INFO, "IF Type = %s\n", (vif->mode == WL_MODE_IBSS) ?\r\n"Adhoc" : "Infra");\r\n}\r\nndev->ieee80211_ptr->iftype = type;\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic void brcmf_escan_prep(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_scan_params_le *params_le,\r\nstruct cfg80211_scan_request *request)\r\n{\r\nu32 n_ssids;\r\nu32 n_channels;\r\ns32 i;\r\ns32 offset;\r\nu16 chanspec;\r\nchar *ptr;\r\nstruct brcmf_ssid_le ssid_le;\r\nmemset(params_le->bssid, 0xFF, ETH_ALEN);\r\nparams_le->bss_type = DOT11_BSSTYPE_ANY;\r\nparams_le->scan_type = 0;\r\nparams_le->channel_num = 0;\r\nparams_le->nprobes = cpu_to_le32(-1);\r\nparams_le->active_time = cpu_to_le32(-1);\r\nparams_le->passive_time = cpu_to_le32(-1);\r\nparams_le->home_time = cpu_to_le32(-1);\r\nmemset(&params_le->ssid_le, 0, sizeof(params_le->ssid_le));\r\nif (!request)\r\nreturn;\r\nn_ssids = request->n_ssids;\r\nn_channels = request->n_channels;\r\nbrcmf_dbg(SCAN, "### List of channelspecs to scan ### %d\n",\r\nn_channels);\r\nif (n_channels > 0) {\r\nfor (i = 0; i < n_channels; i++) {\r\nchanspec = channel_to_chanspec(&cfg->d11inf,\r\nrequest->channels[i]);\r\nbrcmf_dbg(SCAN, "Chan : %d, Channel spec: %x\n",\r\nrequest->channels[i]->hw_value, chanspec);\r\nparams_le->channel_list[i] = cpu_to_le16(chanspec);\r\n}\r\n} else {\r\nbrcmf_dbg(SCAN, "Scanning all channels\n");\r\n}\r\nbrcmf_dbg(SCAN, "### List of SSIDs to scan ### %d\n", n_ssids);\r\nif (n_ssids > 0) {\r\noffset = offsetof(struct brcmf_scan_params_le, channel_list) +\r\nn_channels * sizeof(u16);\r\noffset = roundup(offset, sizeof(u32));\r\nptr = (char *)params_le + offset;\r\nfor (i = 0; i < n_ssids; i++) {\r\nmemset(&ssid_le, 0, sizeof(ssid_le));\r\nssid_le.SSID_len =\r\ncpu_to_le32(request->ssids[i].ssid_len);\r\nmemcpy(ssid_le.SSID, request->ssids[i].ssid,\r\nrequest->ssids[i].ssid_len);\r\nif (!ssid_le.SSID_len)\r\nbrcmf_dbg(SCAN, "%d: Broadcast scan\n", i);\r\nelse\r\nbrcmf_dbg(SCAN, "%d: scan for %s size =%d\n",\r\ni, ssid_le.SSID, ssid_le.SSID_len);\r\nmemcpy(ptr, &ssid_le, sizeof(ssid_le));\r\nptr += sizeof(ssid_le);\r\n}\r\n} else {\r\nbrcmf_dbg(SCAN, "Broadcast scan %p\n", request->ssids);\r\nif ((request->ssids) && request->ssids->ssid_len) {\r\nbrcmf_dbg(SCAN, "SSID %s len=%d\n",\r\nparams_le->ssid_le.SSID,\r\nrequest->ssids->ssid_len);\r\nparams_le->ssid_le.SSID_len =\r\ncpu_to_le32(request->ssids->ssid_len);\r\nmemcpy(&params_le->ssid_le.SSID, request->ssids->ssid,\r\nrequest->ssids->ssid_len);\r\n}\r\n}\r\nparams_le->channel_num =\r\ncpu_to_le32((n_ssids << BRCMF_SCAN_PARAMS_NSSID_SHIFT) |\r\n(n_channels & BRCMF_SCAN_PARAMS_COUNT_MASK));\r\n}\r\nstatic s32\r\nbrcmf_run_escan(struct brcmf_cfg80211_info *cfg, struct brcmf_if *ifp,\r\nstruct cfg80211_scan_request *request, u16 action)\r\n{\r\ns32 params_size = BRCMF_SCAN_PARAMS_FIXED_SIZE +\r\noffsetof(struct brcmf_escan_params_le, params_le);\r\nstruct brcmf_escan_params_le *params;\r\ns32 err = 0;\r\nbrcmf_dbg(SCAN, "E-SCAN START\n");\r\nif (request != NULL) {\r\nparams_size += sizeof(u32) * ((request->n_channels + 1) / 2);\r\nparams_size += sizeof(struct brcmf_ssid) * request->n_ssids;\r\n}\r\nparams = kzalloc(params_size, GFP_KERNEL);\r\nif (!params) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\nBUG_ON(params_size + sizeof("escan") >= BRCMF_DCMD_MEDLEN);\r\nbrcmf_escan_prep(cfg, &params->params_le, request);\r\nparams->version = cpu_to_le32(BRCMF_ESCAN_REQ_VERSION);\r\nparams->action = cpu_to_le16(action);\r\nparams->sync_id = cpu_to_le16(0x1234);\r\nerr = brcmf_fil_iovar_data_set(ifp, "escan", params, params_size);\r\nif (err) {\r\nif (err == -EBUSY)\r\nbrcmf_dbg(INFO, "system busy : escan canceled\n");\r\nelse\r\nbrcmf_err("error (%d)\n", err);\r\n}\r\nkfree(params);\r\nexit:\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_do_escan(struct brcmf_cfg80211_info *cfg, struct wiphy *wiphy,\r\nstruct brcmf_if *ifp, struct cfg80211_scan_request *request)\r\n{\r\ns32 err;\r\nu32 passive_scan;\r\nstruct brcmf_scan_results *results;\r\nstruct escan_info *escan = &cfg->escan_info;\r\nbrcmf_dbg(SCAN, "Enter\n");\r\nescan->ifp = ifp;\r\nescan->wiphy = wiphy;\r\nescan->escan_state = WL_ESCAN_STATE_SCANNING;\r\npassive_scan = cfg->active_scan ? 0 : 1;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\r\npassive_scan);\r\nif (err) {\r\nbrcmf_err("error (%d)\n", err);\r\nreturn err;\r\n}\r\nbrcmf_set_mpc(ifp, 0);\r\nresults = (struct brcmf_scan_results *)cfg->escan_info.escan_buf;\r\nresults->version = 0;\r\nresults->count = 0;\r\nresults->buflen = WL_ESCAN_RESULTS_FIXED_SIZE;\r\nerr = escan->run(cfg, ifp, request, WL_ESCAN_ACTION_START);\r\nif (err)\r\nbrcmf_set_mpc(ifp, 1);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_escan(struct wiphy *wiphy, struct brcmf_cfg80211_vif *vif,\r\nstruct cfg80211_scan_request *request,\r\nstruct cfg80211_ssid *this_ssid)\r\n{\r\nstruct brcmf_if *ifp = vif->ifp;\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct cfg80211_ssid *ssids;\r\nstruct brcmf_cfg80211_scan_req *sr = &cfg->scan_req_int;\r\nu32 passive_scan;\r\nbool escan_req;\r\nbool spec_scan;\r\ns32 err;\r\nu32 SSID_len;\r\nbrcmf_dbg(SCAN, "START ESCAN\n");\r\nif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\r\nbrcmf_err("Scanning already: status (%lu)\n", cfg->scan_status);\r\nreturn -EAGAIN;\r\n}\r\nif (test_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status)) {\r\nbrcmf_err("Scanning being aborted: status (%lu)\n",\r\ncfg->scan_status);\r\nreturn -EAGAIN;\r\n}\r\nif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\r\nbrcmf_err("Scanning suppressed: status (%lu)\n",\r\ncfg->scan_status);\r\nreturn -EAGAIN;\r\n}\r\nif (test_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state)) {\r\nbrcmf_err("Connecting: status (%lu)\n", ifp->vif->sme_state);\r\nreturn -EAGAIN;\r\n}\r\nif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\r\nvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;\r\nmod_timer(&cfg->escan_timeout, jiffies +\r\nWL_ESCAN_TIMER_INTERVAL_MS * HZ / 1000);\r\nescan_req = false;\r\nif (request) {\r\nssids = request->ssids;\r\nescan_req = true;\r\n} else {\r\nssids = this_ssid;\r\n}\r\ncfg->scan_request = request;\r\nset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\r\nif (escan_req) {\r\ncfg->escan_info.run = brcmf_run_escan;\r\nerr = brcmf_p2p_scan_prep(wiphy, request, vif);\r\nif (err)\r\ngoto scan_out;\r\nerr = brcmf_do_escan(cfg, wiphy, vif->ifp, request);\r\nif (err)\r\ngoto scan_out;\r\n} else {\r\nbrcmf_dbg(SCAN, "ssid \"%s\", ssid_len (%d)\n",\r\nssids->ssid, ssids->ssid_len);\r\nmemset(&sr->ssid_le, 0, sizeof(sr->ssid_le));\r\nSSID_len = min_t(u8, sizeof(sr->ssid_le.SSID), ssids->ssid_len);\r\nsr->ssid_le.SSID_len = cpu_to_le32(0);\r\nspec_scan = false;\r\nif (SSID_len) {\r\nmemcpy(sr->ssid_le.SSID, ssids->ssid, SSID_len);\r\nsr->ssid_le.SSID_len = cpu_to_le32(SSID_len);\r\nspec_scan = true;\r\n} else\r\nbrcmf_dbg(SCAN, "Broadcast scan\n");\r\npassive_scan = cfg->active_scan ? 0 : 1;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PASSIVE_SCAN,\r\npassive_scan);\r\nif (err) {\r\nbrcmf_err("WLC_SET_PASSIVE_SCAN error (%d)\n", err);\r\ngoto scan_out;\r\n}\r\nbrcmf_set_mpc(ifp, 0);\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCAN,\r\n&sr->ssid_le, sizeof(sr->ssid_le));\r\nif (err) {\r\nif (err == -EBUSY)\r\nbrcmf_dbg(INFO, "BUSY: scan for \"%s\" canceled\n",\r\nsr->ssid_le.SSID);\r\nelse\r\nbrcmf_err("WLC_SCAN error (%d)\n", err);\r\nbrcmf_set_mpc(ifp, 1);\r\ngoto scan_out;\r\n}\r\n}\r\nreturn 0;\r\nscan_out:\r\nclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\r\nif (timer_pending(&cfg->escan_timeout))\r\ndel_timer_sync(&cfg->escan_timeout);\r\ncfg->scan_request = NULL;\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_scan(struct wiphy *wiphy, struct cfg80211_scan_request *request)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nvif = container_of(request->wdev, struct brcmf_cfg80211_vif, wdev);\r\nif (!check_vif_up(vif))\r\nreturn -EIO;\r\nerr = brcmf_cfg80211_escan(wiphy, vif, request, NULL);\r\nif (err)\r\nbrcmf_err("scan error (%d)\n", err);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_rts(struct net_device *ndev, u32 rts_threshold)\r\n{\r\ns32 err = 0;\r\nerr = brcmf_fil_iovar_int_set(netdev_priv(ndev), "rtsthresh",\r\nrts_threshold);\r\nif (err)\r\nbrcmf_err("Error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_frag(struct net_device *ndev, u32 frag_threshold)\r\n{\r\ns32 err = 0;\r\nerr = brcmf_fil_iovar_int_set(netdev_priv(ndev), "fragthresh",\r\nfrag_threshold);\r\nif (err)\r\nbrcmf_err("Error (%d)\n", err);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_retry(struct net_device *ndev, u32 retry, bool l)\r\n{\r\ns32 err = 0;\r\nu32 cmd = (l ? BRCMF_C_SET_LRL : BRCMF_C_SET_SRL);\r\nerr = brcmf_fil_cmd_int_set(netdev_priv(ndev), cmd, retry);\r\nif (err) {\r\nbrcmf_err("cmd (%d) , error (%d)\n", cmd, err);\r\nreturn err;\r\n}\r\nreturn err;\r\n}\r\nstatic s32 brcmf_cfg80211_set_wiphy_params(struct wiphy *wiphy, u32 changed)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nif (changed & WIPHY_PARAM_RTS_THRESHOLD &&\r\n(cfg->conf->rts_threshold != wiphy->rts_threshold)) {\r\ncfg->conf->rts_threshold = wiphy->rts_threshold;\r\nerr = brcmf_set_rts(ndev, cfg->conf->rts_threshold);\r\nif (!err)\r\ngoto done;\r\n}\r\nif (changed & WIPHY_PARAM_FRAG_THRESHOLD &&\r\n(cfg->conf->frag_threshold != wiphy->frag_threshold)) {\r\ncfg->conf->frag_threshold = wiphy->frag_threshold;\r\nerr = brcmf_set_frag(ndev, cfg->conf->frag_threshold);\r\nif (!err)\r\ngoto done;\r\n}\r\nif (changed & WIPHY_PARAM_RETRY_LONG\r\n&& (cfg->conf->retry_long != wiphy->retry_long)) {\r\ncfg->conf->retry_long = wiphy->retry_long;\r\nerr = brcmf_set_retry(ndev, cfg->conf->retry_long, true);\r\nif (!err)\r\ngoto done;\r\n}\r\nif (changed & WIPHY_PARAM_RETRY_SHORT\r\n&& (cfg->conf->retry_short != wiphy->retry_short)) {\r\ncfg->conf->retry_short = wiphy->retry_short;\r\nerr = brcmf_set_retry(ndev, cfg->conf->retry_short, false);\r\nif (!err)\r\ngoto done;\r\n}\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic void brcmf_init_prof(struct brcmf_cfg80211_profile *prof)\r\n{\r\nmemset(prof, 0, sizeof(*prof));\r\n}\r\nstatic void brcmf_link_down(struct brcmf_cfg80211_vif *vif)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(vif->wdev.wiphy);\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (test_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state)) {\r\nbrcmf_dbg(INFO, "Call WLC_DISASSOC to stop excess roaming\n ");\r\nerr = brcmf_fil_cmd_data_set(vif->ifp,\r\nBRCMF_C_DISASSOC, NULL, 0);\r\nif (err) {\r\nbrcmf_err("WLC_DISASSOC failed (%d)\n", err);\r\ncfg80211_disconnected(vif->wdev.netdev, 0,\r\nNULL, 0, GFP_KERNEL);\r\n}\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTED, &vif->sme_state);\r\n}\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTING, &vif->sme_state);\r\nclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\r\nbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ibss_params *params)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct brcmf_join_params join_params;\r\nsize_t join_params_size = 0;\r\ns32 err = 0;\r\ns32 wsec = 0;\r\ns32 bcnprd;\r\nu16 chanspec;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nif (params->ssid)\r\nbrcmf_dbg(CONN, "SSID: %s\n", params->ssid);\r\nelse {\r\nbrcmf_dbg(CONN, "SSID: NULL, Not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\r\nif (params->bssid)\r\nbrcmf_dbg(CONN, "BSSID: %pM\n", params->bssid);\r\nelse\r\nbrcmf_dbg(CONN, "No BSSID specified\n");\r\nif (params->chandef.chan)\r\nbrcmf_dbg(CONN, "channel: %d\n",\r\nparams->chandef.chan->center_freq);\r\nelse\r\nbrcmf_dbg(CONN, "no channel specified\n");\r\nif (params->channel_fixed)\r\nbrcmf_dbg(CONN, "fixed channel required\n");\r\nelse\r\nbrcmf_dbg(CONN, "no fixed channel required\n");\r\nif (params->ie && params->ie_len)\r\nbrcmf_dbg(CONN, "ie len: %d\n", params->ie_len);\r\nelse\r\nbrcmf_dbg(CONN, "no ie specified\n");\r\nif (params->beacon_interval)\r\nbrcmf_dbg(CONN, "beacon interval: %d\n",\r\nparams->beacon_interval);\r\nelse\r\nbrcmf_dbg(CONN, "no beacon interval specified\n");\r\nif (params->basic_rates)\r\nbrcmf_dbg(CONN, "basic rates: %08X\n", params->basic_rates);\r\nelse\r\nbrcmf_dbg(CONN, "no basic rates specified\n");\r\nif (params->privacy)\r\nbrcmf_dbg(CONN, "privacy required\n");\r\nelse\r\nbrcmf_dbg(CONN, "no privacy required\n");\r\nif (params->privacy)\r\nwsec |= WEP_ENABLED;\r\nerr = brcmf_fil_iovar_int_set(ifp, "wsec", wsec);\r\nif (err) {\r\nbrcmf_err("wsec failed (%d)\n", err);\r\ngoto done;\r\n}\r\nif (params->beacon_interval)\r\nbcnprd = params->beacon_interval;\r\nelse\r\nbcnprd = 100;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, bcnprd);\r\nif (err) {\r\nbrcmf_err("WLC_SET_BCNPRD failed (%d)\n", err);\r\ngoto done;\r\n}\r\nmemset(&join_params, 0, sizeof(struct brcmf_join_params));\r\nprofile->ssid.SSID_len = min_t(u32, params->ssid_len, 32);\r\nmemcpy(profile->ssid.SSID, params->ssid, profile->ssid.SSID_len);\r\nmemcpy(join_params.ssid_le.SSID, params->ssid, profile->ssid.SSID_len);\r\njoin_params.ssid_le.SSID_len = cpu_to_le32(profile->ssid.SSID_len);\r\njoin_params_size = sizeof(join_params.ssid_le);\r\nif (params->bssid) {\r\nmemcpy(join_params.params_le.bssid, params->bssid, ETH_ALEN);\r\njoin_params_size = sizeof(join_params.ssid_le) +\r\nBRCMF_ASSOC_PARAMS_FIXED_SIZE;\r\nmemcpy(profile->bssid, params->bssid, ETH_ALEN);\r\n} else {\r\nmemset(join_params.params_le.bssid, 0xFF, ETH_ALEN);\r\nmemset(profile->bssid, 0, ETH_ALEN);\r\n}\r\nif (params->chandef.chan) {\r\nu32 target_channel;\r\ncfg->channel =\r\nieee80211_frequency_to_channel(\r\nparams->chandef.chan->center_freq);\r\nif (params->channel_fixed) {\r\nchanspec = channel_to_chanspec(&cfg->d11inf,\r\nparams->chandef.chan);\r\njoin_params.params_le.chanspec_list[0] =\r\ncpu_to_le16(chanspec);\r\njoin_params.params_le.chanspec_num = cpu_to_le32(1);\r\njoin_params_size += sizeof(join_params.params_le);\r\n}\r\ntarget_channel = cfg->channel;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_CHANNEL,\r\ntarget_channel);\r\nif (err) {\r\nbrcmf_err("WLC_SET_CHANNEL failed (%d)\n", err);\r\ngoto done;\r\n}\r\n} else\r\ncfg->channel = 0;\r\ncfg->ibss_starter = false;\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\r\n&join_params, join_params_size);\r\nif (err) {\r\nbrcmf_err("WLC_SET_SSID failed (%d)\n", err);\r\ngoto done;\r\n}\r\ndone:\r\nif (err)\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_leave_ibss(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nbrcmf_link_down(ifp->vif);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_wpa_version(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 val = 0;\r\ns32 err = 0;\r\nif (sme->crypto.wpa_versions & NL80211_WPA_VERSION_1)\r\nval = WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED;\r\nelse if (sme->crypto.wpa_versions & NL80211_WPA_VERSION_2)\r\nval = WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED;\r\nelse\r\nval = WPA_AUTH_DISABLED;\r\nbrcmf_dbg(CONN, "setting wpa_auth to 0x%0x\n", val);\r\nerr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "wpa_auth", val);\r\nif (err) {\r\nbrcmf_err("set wpa_auth failed (%d)\n", err);\r\nreturn err;\r\n}\r\nsec = &profile->sec;\r\nsec->wpa_versions = sme->crypto.wpa_versions;\r\nreturn err;\r\n}\r\nstatic s32 brcmf_set_auth_type(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 val = 0;\r\ns32 err = 0;\r\nswitch (sme->auth_type) {\r\ncase NL80211_AUTHTYPE_OPEN_SYSTEM:\r\nval = 0;\r\nbrcmf_dbg(CONN, "open system\n");\r\nbreak;\r\ncase NL80211_AUTHTYPE_SHARED_KEY:\r\nval = 1;\r\nbrcmf_dbg(CONN, "shared key\n");\r\nbreak;\r\ncase NL80211_AUTHTYPE_AUTOMATIC:\r\nval = 2;\r\nbrcmf_dbg(CONN, "automatic\n");\r\nbreak;\r\ncase NL80211_AUTHTYPE_NETWORK_EAP:\r\nbrcmf_dbg(CONN, "network eap\n");\r\ndefault:\r\nval = 2;\r\nbrcmf_err("invalid auth type (%d)\n", sme->auth_type);\r\nbreak;\r\n}\r\nerr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "auth", val);\r\nif (err) {\r\nbrcmf_err("set auth failed (%d)\n", err);\r\nreturn err;\r\n}\r\nsec = &profile->sec;\r\nsec->auth_type = sme->auth_type;\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_set_set_cipher(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 pval = 0;\r\ns32 gval = 0;\r\ns32 err = 0;\r\nif (sme->crypto.n_ciphers_pairwise) {\r\nswitch (sme->crypto.ciphers_pairwise[0]) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\npval = WEP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\npval = TKIP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\npval = AES_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\npval = AES_ENABLED;\r\nbreak;\r\ndefault:\r\nbrcmf_err("invalid cipher pairwise (%d)\n",\r\nsme->crypto.ciphers_pairwise[0]);\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sme->crypto.cipher_group) {\r\nswitch (sme->crypto.cipher_group) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\ngval = WEP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\ngval = TKIP_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\ngval = AES_ENABLED;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\ngval = AES_ENABLED;\r\nbreak;\r\ndefault:\r\nbrcmf_err("invalid cipher group (%d)\n",\r\nsme->crypto.cipher_group);\r\nreturn -EINVAL;\r\n}\r\n}\r\nbrcmf_dbg(CONN, "pval (%d) gval (%d)\n", pval, gval);\r\nif (brcmf_find_wpsie(sme->ie, sme->ie_len) && !pval && !gval &&\r\nsme->privacy)\r\npval = AES_ENABLED;\r\nerr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "wsec", pval | gval);\r\nif (err) {\r\nbrcmf_err("error (%d)\n", err);\r\nreturn err;\r\n}\r\nsec = &profile->sec;\r\nsec->cipher_pairwise = sme->crypto.ciphers_pairwise[0];\r\nsec->cipher_group = sme->crypto.cipher_group;\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_set_key_mgmt(struct net_device *ndev, struct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 val = 0;\r\ns32 err = 0;\r\nif (sme->crypto.n_akm_suites) {\r\nerr = brcmf_fil_bsscfg_int_get(netdev_priv(ndev),\r\n"wpa_auth", &val);\r\nif (err) {\r\nbrcmf_err("could not get wpa_auth (%d)\n", err);\r\nreturn err;\r\n}\r\nif (val & (WPA_AUTH_PSK | WPA_AUTH_UNSPECIFIED)) {\r\nswitch (sme->crypto.akm_suites[0]) {\r\ncase WLAN_AKM_SUITE_8021X:\r\nval = WPA_AUTH_UNSPECIFIED;\r\nbreak;\r\ncase WLAN_AKM_SUITE_PSK:\r\nval = WPA_AUTH_PSK;\r\nbreak;\r\ndefault:\r\nbrcmf_err("invalid cipher group (%d)\n",\r\nsme->crypto.cipher_group);\r\nreturn -EINVAL;\r\n}\r\n} else if (val & (WPA2_AUTH_PSK | WPA2_AUTH_UNSPECIFIED)) {\r\nswitch (sme->crypto.akm_suites[0]) {\r\ncase WLAN_AKM_SUITE_8021X:\r\nval = WPA2_AUTH_UNSPECIFIED;\r\nbreak;\r\ncase WLAN_AKM_SUITE_PSK:\r\nval = WPA2_AUTH_PSK;\r\nbreak;\r\ndefault:\r\nbrcmf_err("invalid cipher group (%d)\n",\r\nsme->crypto.cipher_group);\r\nreturn -EINVAL;\r\n}\r\n}\r\nbrcmf_dbg(CONN, "setting wpa_auth to %d\n", val);\r\nerr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev),\r\n"wpa_auth", val);\r\nif (err) {\r\nbrcmf_err("could not set wpa_auth (%d)\n", err);\r\nreturn err;\r\n}\r\n}\r\nsec = &profile->sec;\r\nsec->wpa_auth = sme->crypto.akm_suites[0];\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_set_sharedkey(struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ndev);\r\nstruct brcmf_cfg80211_security *sec;\r\nstruct brcmf_wsec_key key;\r\ns32 val;\r\ns32 err = 0;\r\nbrcmf_dbg(CONN, "key len (%d)\n", sme->key_len);\r\nif (sme->key_len == 0)\r\nreturn 0;\r\nsec = &profile->sec;\r\nbrcmf_dbg(CONN, "wpa_versions 0x%x cipher_pairwise 0x%x\n",\r\nsec->wpa_versions, sec->cipher_pairwise);\r\nif (sec->wpa_versions & (NL80211_WPA_VERSION_1 | NL80211_WPA_VERSION_2))\r\nreturn 0;\r\nif (!(sec->cipher_pairwise &\r\n(WLAN_CIPHER_SUITE_WEP40 | WLAN_CIPHER_SUITE_WEP104)))\r\nreturn 0;\r\nmemset(&key, 0, sizeof(key));\r\nkey.len = (u32) sme->key_len;\r\nkey.index = (u32) sme->key_idx;\r\nif (key.len > sizeof(key.data)) {\r\nbrcmf_err("Too long key length (%u)\n", key.len);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(key.data, sme->key, key.len);\r\nkey.flags = BRCMF_PRIMARY_KEY;\r\nswitch (sec->cipher_pairwise) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nkey.algo = CRYPTO_ALGO_WEP1;\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey.algo = CRYPTO_ALGO_WEP128;\r\nbreak;\r\ndefault:\r\nbrcmf_err("Invalid algorithm (%d)\n",\r\nsme->crypto.ciphers_pairwise[0]);\r\nreturn -EINVAL;\r\n}\r\nbrcmf_dbg(CONN, "key length (%d) key index (%d) algo (%d)\n",\r\nkey.len, key.index, key.algo);\r\nbrcmf_dbg(CONN, "key \"%s\"\n", key.data);\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\nreturn err;\r\nif (sec->auth_type == NL80211_AUTHTYPE_SHARED_KEY) {\r\nbrcmf_dbg(CONN, "set auth_type to shared key\n");\r\nval = WL_AUTH_SHARED_KEY;\r\nerr = brcmf_fil_bsscfg_int_set(netdev_priv(ndev), "auth", val);\r\nif (err)\r\nbrcmf_err("set auth failed (%d)\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic\r\nenum nl80211_auth_type brcmf_war_auth_type(struct brcmf_if *ifp,\r\nenum nl80211_auth_type type)\r\n{\r\nu32 ci;\r\nif (type == NL80211_AUTHTYPE_AUTOMATIC) {\r\nci = brcmf_get_chip_info(ifp) >> 4;\r\nswitch (ci) {\r\ncase 43236:\r\nbrcmf_dbg(CONN, "43236 WAR: use OPEN instead of AUTO\n");\r\nreturn NL80211_AUTHTYPE_OPEN_SYSTEM;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn type;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_connect_params *sme)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct ieee80211_channel *chan = sme->channel;\r\nstruct brcmf_join_params join_params;\r\nsize_t join_params_size;\r\nstruct brcmf_tlv *rsn_ie;\r\nstruct brcmf_vs_tlv *wpa_ie;\r\nvoid *ie;\r\nu32 ie_len;\r\nstruct brcmf_ext_join_params_le *ext_join_params;\r\nu16 chanspec;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nif (!sme->ssid) {\r\nbrcmf_err("Invalid ssid\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif) {\r\nie = NULL;\r\nie_len = 0;\r\nwpa_ie = brcmf_find_wpaie((u8 *)sme->ie, sme->ie_len);\r\nif (wpa_ie) {\r\nie = wpa_ie;\r\nie_len = wpa_ie->len + TLV_HDR_LEN;\r\n} else {\r\nrsn_ie = brcmf_parse_tlvs((u8 *)sme->ie, sme->ie_len,\r\nWLAN_EID_RSN);\r\nif (rsn_ie) {\r\nie = rsn_ie;\r\nie_len = rsn_ie->len + TLV_HDR_LEN;\r\n}\r\n}\r\nbrcmf_fil_iovar_data_set(ifp, "wpaie", ie, ie_len);\r\n}\r\nerr = brcmf_vif_set_mgmt_ie(ifp->vif, BRCMF_VNDR_IE_ASSOCREQ_FLAG,\r\nsme->ie, sme->ie_len);\r\nif (err)\r\nbrcmf_err("Set Assoc REQ IE Failed\n");\r\nelse\r\nbrcmf_dbg(TRACE, "Applied Vndr IEs for Assoc request\n");\r\nset_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\r\nif (chan) {\r\ncfg->channel =\r\nieee80211_frequency_to_channel(chan->center_freq);\r\nchanspec = channel_to_chanspec(&cfg->d11inf, chan);\r\nbrcmf_dbg(CONN, "channel=%d, center_req=%d, chanspec=0x%04x\n",\r\ncfg->channel, chan->center_freq, chanspec);\r\n} else {\r\ncfg->channel = 0;\r\nchanspec = 0;\r\n}\r\nbrcmf_dbg(INFO, "ie (%p), ie_len (%zd)\n", sme->ie, sme->ie_len);\r\nerr = brcmf_set_wpa_version(ndev, sme);\r\nif (err) {\r\nbrcmf_err("wl_set_wpa_version failed (%d)\n", err);\r\ngoto done;\r\n}\r\nsme->auth_type = brcmf_war_auth_type(ifp, sme->auth_type);\r\nerr = brcmf_set_auth_type(ndev, sme);\r\nif (err) {\r\nbrcmf_err("wl_set_auth_type failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_set_cipher(ndev, sme);\r\nif (err) {\r\nbrcmf_err("wl_set_set_cipher failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_key_mgmt(ndev, sme);\r\nif (err) {\r\nbrcmf_err("wl_set_key_mgmt failed (%d)\n", err);\r\ngoto done;\r\n}\r\nerr = brcmf_set_sharedkey(ndev, sme);\r\nif (err) {\r\nbrcmf_err("brcmf_set_sharedkey failed (%d)\n", err);\r\ngoto done;\r\n}\r\nprofile->ssid.SSID_len = min_t(u32, (u32)sizeof(profile->ssid.SSID),\r\n(u32)sme->ssid_len);\r\nmemcpy(&profile->ssid.SSID, sme->ssid, profile->ssid.SSID_len);\r\nif (profile->ssid.SSID_len < IEEE80211_MAX_SSID_LEN) {\r\nprofile->ssid.SSID[profile->ssid.SSID_len] = 0;\r\nbrcmf_dbg(CONN, "SSID \"%s\", len (%d)\n", profile->ssid.SSID,\r\nprofile->ssid.SSID_len);\r\n}\r\njoin_params_size = offsetof(struct brcmf_ext_join_params_le, assoc_le) +\r\noffsetof(struct brcmf_assoc_params_le, chanspec_list);\r\nif (cfg->channel)\r\njoin_params_size += sizeof(u16);\r\next_join_params = kzalloc(join_params_size, GFP_KERNEL);\r\nif (ext_join_params == NULL) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\next_join_params->ssid_le.SSID_len = cpu_to_le32(profile->ssid.SSID_len);\r\nmemcpy(&ext_join_params->ssid_le.SSID, sme->ssid,\r\nprofile->ssid.SSID_len);\r\next_join_params->scan_le.active_time =\r\ncpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS);\r\next_join_params->scan_le.passive_time =\r\ncpu_to_le32(BRCMF_SCAN_JOIN_PASSIVE_DWELL_TIME_MS);\r\next_join_params->scan_le.scan_type = -1;\r\next_join_params->scan_le.nprobes =\r\ncpu_to_le32(BRCMF_SCAN_JOIN_ACTIVE_DWELL_TIME_MS /\r\nBRCMF_SCAN_JOIN_PROBE_INTERVAL_MS);\r\next_join_params->scan_le.home_time = cpu_to_le32(-1);\r\nif (sme->bssid)\r\nmemcpy(&ext_join_params->assoc_le.bssid, sme->bssid, ETH_ALEN);\r\nelse\r\nmemset(&ext_join_params->assoc_le.bssid, 0xFF, ETH_ALEN);\r\nif (cfg->channel) {\r\next_join_params->assoc_le.chanspec_num = cpu_to_le32(1);\r\next_join_params->assoc_le.chanspec_list[0] =\r\ncpu_to_le16(chanspec);\r\n}\r\nerr = brcmf_fil_bsscfg_data_set(ifp, "join", ext_join_params,\r\njoin_params_size);\r\nkfree(ext_join_params);\r\nif (!err)\r\ngoto done;\r\nmemset(&join_params, 0, sizeof(join_params));\r\njoin_params_size = sizeof(join_params.ssid_le);\r\nmemcpy(&join_params.ssid_le.SSID, sme->ssid, profile->ssid.SSID_len);\r\njoin_params.ssid_le.SSID_len = cpu_to_le32(profile->ssid.SSID_len);\r\nif (sme->bssid)\r\nmemcpy(join_params.params_le.bssid, sme->bssid, ETH_ALEN);\r\nelse\r\nmemset(join_params.params_le.bssid, 0xFF, ETH_ALEN);\r\nif (cfg->channel) {\r\njoin_params.params_le.chanspec_list[0] = cpu_to_le16(chanspec);\r\njoin_params.params_le.chanspec_num = cpu_to_le32(1);\r\njoin_params_size += sizeof(join_params.params_le);\r\n}\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\r\n&join_params, join_params_size);\r\nif (err)\r\nbrcmf_err("BRCMF_C_SET_SSID failed (%d)\n", err);\r\ndone:\r\nif (err)\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTING, &ifp->vif->sme_state);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_disconnect(struct wiphy *wiphy, struct net_device *ndev,\r\nu16 reason_code)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct brcmf_scb_val_le scbval;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter. Reason code = %d\n", reason_code);\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\r\nmemcpy(&scbval.ea, &profile->bssid, ETH_ALEN);\r\nscbval.val = cpu_to_le32(reason_code);\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_DISASSOC,\r\n&scbval, sizeof(scbval));\r\nif (err)\r\nbrcmf_err("error (%d)\n", err);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_tx_power(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nenum nl80211_tx_power_setting type, s32 mbm)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nu16 txpwrmw;\r\ns32 err = 0;\r\ns32 disable = 0;\r\ns32 dbm = MBM_TO_DBM(mbm);\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nswitch (type) {\r\ncase NL80211_TX_POWER_AUTOMATIC:\r\nbreak;\r\ncase NL80211_TX_POWER_LIMITED:\r\ncase NL80211_TX_POWER_FIXED:\r\nif (dbm < 0) {\r\nbrcmf_err("TX_POWER_FIXED - dbm is negative\n");\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nbreak;\r\n}\r\ndisable = WL_RADIO_SW_DISABLE << 16;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_RADIO, disable);\r\nif (err)\r\nbrcmf_err("WLC_SET_RADIO error (%d)\n", err);\r\nif (dbm > 0xffff)\r\ntxpwrmw = 0xffff;\r\nelse\r\ntxpwrmw = (u16) dbm;\r\nerr = brcmf_fil_iovar_int_set(ifp, "qtxpower",\r\n(s32)brcmf_mw_to_qdbm(txpwrmw));\r\nif (err)\r\nbrcmf_err("qtxpower error (%d)\n", err);\r\ncfg->conf->tx_power = dbm;\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_cfg80211_get_tx_power(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\ns32 *dbm)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\r\ns32 txpwrdbm;\r\nu8 result;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nerr = brcmf_fil_iovar_int_get(ifp, "qtxpower", &txpwrdbm);\r\nif (err) {\r\nbrcmf_err("error (%d)\n", err);\r\ngoto done;\r\n}\r\nresult = (u8) (txpwrdbm & ~WL_TXPWR_OVERRIDE);\r\n*dbm = (s32) brcmf_qdbm_to_mw(result);\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_config_default_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool unicast, bool multicast)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nu32 index;\r\nu32 wsec;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_dbg(CONN, "key index (%d)\n", key_idx);\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nerr = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);\r\nif (err) {\r\nbrcmf_err("WLC_GET_WSEC error (%d)\n", err);\r\ngoto done;\r\n}\r\nif (wsec & WEP_ENABLED) {\r\nindex = key_idx;\r\nerr = brcmf_fil_cmd_int_set(ifp,\r\nBRCMF_C_SET_KEY_PRIMARY, index);\r\nif (err)\r\nbrcmf_err("error (%d)\n", err);\r\n}\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_add_keyext(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, const u8 *mac_addr, struct key_params *params)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_wsec_key key;\r\ns32 err = 0;\r\nu8 keybuf[8];\r\nmemset(&key, 0, sizeof(key));\r\nkey.index = (u32) key_idx;\r\nif (!is_multicast_ether_addr(mac_addr))\r\nmemcpy((char *)&key.ea, (void *)mac_addr, ETH_ALEN);\r\nkey.len = (u32) params->key_len;\r\nif (key.len == 0) {\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\nbrcmf_err("key delete error (%d)\n", err);\r\n} else {\r\nif (key.len > sizeof(key.data)) {\r\nbrcmf_err("Invalid key length (%d)\n", key.len);\r\nreturn -EINVAL;\r\n}\r\nbrcmf_dbg(CONN, "Setting the key index %d\n", key.index);\r\nmemcpy(key.data, params->key, key.len);\r\nif ((ifp->vif->mode != WL_MODE_AP) &&\r\n(params->cipher == WLAN_CIPHER_SUITE_TKIP)) {\r\nbrcmf_dbg(CONN, "Swapping RX/TX MIC key\n");\r\nmemcpy(keybuf, &key.data[24], sizeof(keybuf));\r\nmemcpy(&key.data[24], &key.data[16], sizeof(keybuf));\r\nmemcpy(&key.data[16], keybuf, sizeof(keybuf));\r\n}\r\nif (params->seq && params->seq_len == 6) {\r\nu8 *ivptr;\r\nivptr = (u8 *) params->seq;\r\nkey.rxiv.hi = (ivptr[5] << 24) | (ivptr[4] << 16) |\r\n(ivptr[3] << 8) | ivptr[2];\r\nkey.rxiv.lo = (ivptr[1] << 8) | ivptr[0];\r\nkey.iv_initialized = true;\r\n}\r\nswitch (params->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nkey.algo = CRYPTO_ALGO_WEP1;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_WEP40\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey.algo = CRYPTO_ALGO_WEP128;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_WEP104\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nkey.algo = CRYPTO_ALGO_TKIP;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_TKIP\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_AES_CMAC\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_CCMP\n");\r\nbreak;\r\ndefault:\r\nbrcmf_err("Invalid cipher (0x%x)\n", params->cipher);\r\nreturn -EINVAL;\r\n}\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\nbrcmf_err("wsec_key error (%d)\n", err);\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_add_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool pairwise, const u8 *mac_addr,\r\nstruct key_params *params)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_wsec_key key;\r\ns32 val;\r\ns32 wsec;\r\ns32 err = 0;\r\nu8 keybuf[8];\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_dbg(CONN, "key index (%d)\n", key_idx);\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nif (mac_addr) {\r\nbrcmf_dbg(TRACE, "Exit");\r\nreturn brcmf_add_keyext(wiphy, ndev, key_idx, mac_addr, params);\r\n}\r\nmemset(&key, 0, sizeof(key));\r\nkey.len = (u32) params->key_len;\r\nkey.index = (u32) key_idx;\r\nif (key.len > sizeof(key.data)) {\r\nbrcmf_err("Too long key length (%u)\n", key.len);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nmemcpy(key.data, params->key, key.len);\r\nkey.flags = BRCMF_PRIMARY_KEY;\r\nswitch (params->cipher) {\r\ncase WLAN_CIPHER_SUITE_WEP40:\r\nkey.algo = CRYPTO_ALGO_WEP1;\r\nval = WEP_ENABLED;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_WEP40\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_WEP104:\r\nkey.algo = CRYPTO_ALGO_WEP128;\r\nval = WEP_ENABLED;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_WEP104\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_TKIP:\r\nif (ifp->vif->mode != WL_MODE_AP) {\r\nbrcmf_dbg(CONN, "Swapping RX/TX MIC key\n");\r\nmemcpy(keybuf, &key.data[24], sizeof(keybuf));\r\nmemcpy(&key.data[24], &key.data[16], sizeof(keybuf));\r\nmemcpy(&key.data[16], keybuf, sizeof(keybuf));\r\n}\r\nkey.algo = CRYPTO_ALGO_TKIP;\r\nval = TKIP_ENABLED;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_TKIP\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_AES_CMAC:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nval = AES_ENABLED;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_AES_CMAC\n");\r\nbreak;\r\ncase WLAN_CIPHER_SUITE_CCMP:\r\nkey.algo = CRYPTO_ALGO_AES_CCM;\r\nval = AES_ENABLED;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_CCMP\n");\r\nbreak;\r\ndefault:\r\nbrcmf_err("Invalid cipher (0x%x)\n", params->cipher);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\nerr = send_key_to_dongle(ndev, &key);\r\nif (err)\r\ngoto done;\r\nerr = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);\r\nif (err) {\r\nbrcmf_err("get wsec error (%d)\n", err);\r\ngoto done;\r\n}\r\nwsec |= val;\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);\r\nif (err) {\r\nbrcmf_err("set wsec error (%d)\n", err);\r\ngoto done;\r\n}\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_del_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool pairwise, const u8 *mac_addr)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_wsec_key key;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nif (key_idx >= DOT11_MAX_DEFAULT_KEYS) {\r\nbrcmf_err("invalid key index (%d)\n", key_idx);\r\nreturn -EINVAL;\r\n}\r\nmemset(&key, 0, sizeof(key));\r\nkey.index = (u32) key_idx;\r\nkey.flags = BRCMF_PRIMARY_KEY;\r\nkey.algo = CRYPTO_ALGO_OFF;\r\nbrcmf_dbg(CONN, "key index (%d)\n", key_idx);\r\nerr = send_key_to_dongle(ndev, &key);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_get_key(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 key_idx, bool pairwise, const u8 *mac_addr, void *cookie,\r\nvoid (*callback) (void *cookie, struct key_params * params))\r\n{\r\nstruct key_params params;\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct brcmf_cfg80211_security *sec;\r\ns32 wsec;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_dbg(CONN, "key index (%d)\n", key_idx);\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nmemset(&params, 0, sizeof(params));\r\nerr = brcmf_fil_bsscfg_int_get(ifp, "wsec", &wsec);\r\nif (err) {\r\nbrcmf_err("WLC_GET_WSEC error (%d)\n", err);\r\nerr = -EAGAIN;\r\ngoto done;\r\n}\r\nif (wsec & WEP_ENABLED) {\r\nsec = &profile->sec;\r\nif (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP40) {\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP40;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_WEP40\n");\r\n} else if (sec->cipher_pairwise & WLAN_CIPHER_SUITE_WEP104) {\r\nparams.cipher = WLAN_CIPHER_SUITE_WEP104;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_WEP104\n");\r\n}\r\n} else if (wsec & TKIP_ENABLED) {\r\nparams.cipher = WLAN_CIPHER_SUITE_TKIP;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_TKIP\n");\r\n} else if (wsec & AES_ENABLED) {\r\nparams.cipher = WLAN_CIPHER_SUITE_AES_CMAC;\r\nbrcmf_dbg(CONN, "WLAN_CIPHER_SUITE_AES_CMAC\n");\r\n} else {\r\nbrcmf_err("Invalid algo (0x%x)\n", wsec);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\ncallback(cookie, &params);\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_config_default_mgmt_key(struct wiphy *wiphy,\r\nstruct net_device *ndev, u8 key_idx)\r\n{\r\nbrcmf_dbg(INFO, "Not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_get_station(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 *mac, struct station_info *sinfo)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct brcmf_scb_val_le scb_val;\r\nint rssi;\r\ns32 rate;\r\ns32 err = 0;\r\nu8 *bssid = profile->bssid;\r\nstruct brcmf_sta_info_le sta_info_le;\r\nbrcmf_dbg(TRACE, "Enter, MAC %pM\n", mac);\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nif (ifp->vif->mode == WL_MODE_AP) {\r\nmemcpy(&sta_info_le, mac, ETH_ALEN);\r\nerr = brcmf_fil_iovar_data_get(ifp, "sta_info",\r\n&sta_info_le,\r\nsizeof(sta_info_le));\r\nif (err < 0) {\r\nbrcmf_err("GET STA INFO failed, %d\n", err);\r\ngoto done;\r\n}\r\nsinfo->filled = STATION_INFO_INACTIVE_TIME;\r\nsinfo->inactive_time = le32_to_cpu(sta_info_le.idle) * 1000;\r\nif (le32_to_cpu(sta_info_le.flags) & BRCMF_STA_ASSOC) {\r\nsinfo->filled |= STATION_INFO_CONNECTED_TIME;\r\nsinfo->connected_time = le32_to_cpu(sta_info_le.in);\r\n}\r\nbrcmf_dbg(TRACE, "STA idle time : %d ms, connected time :%d sec\n",\r\nsinfo->inactive_time, sinfo->connected_time);\r\n} else if (ifp->vif->mode == WL_MODE_BSS) {\r\nif (memcmp(mac, bssid, ETH_ALEN)) {\r\nbrcmf_err("Wrong Mac address cfg_mac-%pM wl_bssid-%pM\n",\r\nmac, bssid);\r\nerr = -ENOENT;\r\ngoto done;\r\n}\r\nerr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_RATE, &rate);\r\nif (err) {\r\nbrcmf_err("Could not get rate (%d)\n", err);\r\ngoto done;\r\n} else {\r\nsinfo->filled |= STATION_INFO_TX_BITRATE;\r\nsinfo->txrate.legacy = rate * 5;\r\nbrcmf_dbg(CONN, "Rate %d Mbps\n", rate / 2);\r\n}\r\nif (test_bit(BRCMF_VIF_STATUS_CONNECTED,\r\n&ifp->vif->sme_state)) {\r\nmemset(&scb_val, 0, sizeof(scb_val));\r\nerr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_RSSI,\r\n&scb_val, sizeof(scb_val));\r\nif (err) {\r\nbrcmf_err("Could not get rssi (%d)\n", err);\r\ngoto done;\r\n} else {\r\nrssi = le32_to_cpu(scb_val.val);\r\nsinfo->filled |= STATION_INFO_SIGNAL;\r\nsinfo->signal = rssi;\r\nbrcmf_dbg(CONN, "RSSI %d dBm\n", rssi);\r\n}\r\n}\r\n} else\r\nerr = -EPERM;\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,\r\nbool enabled, s32 timeout)\r\n{\r\ns32 pm;\r\ns32 err = 0;\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nbrcmf_dbg(TRACE, "Enter\n");\r\ncfg->pwr_save = enabled;\r\nif (!check_vif_up(ifp->vif)) {\r\nbrcmf_dbg(INFO, "Device is not ready, storing the value in cfg_info struct\n");\r\ngoto done;\r\n}\r\npm = enabled ? PM_FAST : PM_OFF;\r\nif (ifp->vif->wdev.iftype == NL80211_IFTYPE_P2P_CLIENT) {\r\nbrcmf_dbg(INFO, "Do not enable power save for P2P clients\n");\r\npm = PM_OFF;\r\n}\r\nbrcmf_dbg(INFO, "power save %s\n", (pm ? "enabled" : "disabled"));\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, pm);\r\nif (err) {\r\nif (err == -ENODEV)\r\nbrcmf_err("net_device is not ready yet\n");\r\nelse\r\nbrcmf_err("error (%d)\n", err);\r\n}\r\ndone:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32 brcmf_inform_single_bss(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_bss_info_le *bi)\r\n{\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg);\r\nstruct ieee80211_channel *notify_channel;\r\nstruct cfg80211_bss *bss;\r\nstruct ieee80211_supported_band *band;\r\nstruct brcmu_chan ch;\r\ns32 err = 0;\r\nu16 channel;\r\nu32 freq;\r\nu16 notify_capability;\r\nu16 notify_interval;\r\nu8 *notify_ie;\r\nsize_t notify_ielen;\r\ns32 notify_signal;\r\nif (le32_to_cpu(bi->length) > WL_BSS_INFO_MAX) {\r\nbrcmf_err("Bss info is larger than buffer. Discarding\n");\r\nreturn 0;\r\n}\r\nif (!bi->ctl_ch) {\r\nch.chspec = le16_to_cpu(bi->chanspec);\r\ncfg->d11inf.decchspec(&ch);\r\nbi->ctl_ch = ch.chnum;\r\n}\r\nchannel = bi->ctl_ch;\r\nif (channel <= CH_MAX_2G_CHANNEL)\r\nband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfreq = ieee80211_channel_to_frequency(channel, band->band);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nnotify_capability = le16_to_cpu(bi->capability);\r\nnotify_interval = le16_to_cpu(bi->beacon_period);\r\nnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\r\nnotify_ielen = le32_to_cpu(bi->ie_length);\r\nnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\r\nbrcmf_dbg(CONN, "bssid: %pM\n", bi->BSSID);\r\nbrcmf_dbg(CONN, "Channel: %d(%d)\n", channel, freq);\r\nbrcmf_dbg(CONN, "Capability: %X\n", notify_capability);\r\nbrcmf_dbg(CONN, "Beacon interval: %d\n", notify_interval);\r\nbrcmf_dbg(CONN, "Signal: %d\n", notify_signal);\r\nbss = cfg80211_inform_bss(wiphy, notify_channel, (const u8 *)bi->BSSID,\r\n0, notify_capability, notify_interval, notify_ie,\r\nnotify_ielen, notify_signal, GFP_KERNEL);\r\nif (!bss)\r\nreturn -ENOMEM;\r\ncfg80211_put_bss(wiphy, bss);\r\nreturn err;\r\n}\r\nstatic struct brcmf_bss_info_le *\r\nnext_bss_le(struct brcmf_scan_results *list, struct brcmf_bss_info_le *bss)\r\n{\r\nif (bss == NULL)\r\nreturn list->bss_info_le;\r\nreturn (struct brcmf_bss_info_le *)((unsigned long)bss +\r\nle32_to_cpu(bss->length));\r\n}\r\nstatic s32 brcmf_inform_bss(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_scan_results *bss_list;\r\nstruct brcmf_bss_info_le *bi = NULL;\r\ns32 err = 0;\r\nint i;\r\nbss_list = cfg->bss_list;\r\nif (bss_list->count != 0 &&\r\nbss_list->version != BRCMF_BSS_INFO_VERSION) {\r\nbrcmf_err("Version %d != WL_BSS_INFO_VERSION\n",\r\nbss_list->version);\r\nreturn -EOPNOTSUPP;\r\n}\r\nbrcmf_dbg(SCAN, "scanned AP count (%d)\n", bss_list->count);\r\nfor (i = 0; i < bss_list->count; i++) {\r\nbi = next_bss_le(bss_list, bi);\r\nerr = brcmf_inform_single_bss(cfg, bi);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic s32 wl_inform_ibss(struct brcmf_cfg80211_info *cfg,\r\nstruct net_device *ndev, const u8 *bssid)\r\n{\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg);\r\nstruct ieee80211_channel *notify_channel;\r\nstruct brcmf_bss_info_le *bi = NULL;\r\nstruct ieee80211_supported_band *band;\r\nstruct cfg80211_bss *bss;\r\nstruct brcmu_chan ch;\r\nu8 *buf = NULL;\r\ns32 err = 0;\r\nu32 freq;\r\nu16 notify_capability;\r\nu16 notify_interval;\r\nu8 *notify_ie;\r\nsize_t notify_ielen;\r\ns32 notify_signal;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\r\nif (buf == NULL) {\r\nerr = -ENOMEM;\r\ngoto CleanUp;\r\n}\r\n*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\r\nerr = brcmf_fil_cmd_data_get(netdev_priv(ndev), BRCMF_C_GET_BSS_INFO,\r\nbuf, WL_BSS_INFO_MAX);\r\nif (err) {\r\nbrcmf_err("WLC_GET_BSS_INFO failed: %d\n", err);\r\ngoto CleanUp;\r\n}\r\nbi = (struct brcmf_bss_info_le *)(buf + 4);\r\nch.chspec = le16_to_cpu(bi->chanspec);\r\ncfg->d11inf.decchspec(&ch);\r\nif (ch.band == BRCMU_CHAN_BAND_2G)\r\nband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfreq = ieee80211_channel_to_frequency(ch.chnum, band->band);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\nnotify_capability = le16_to_cpu(bi->capability);\r\nnotify_interval = le16_to_cpu(bi->beacon_period);\r\nnotify_ie = (u8 *)bi + le16_to_cpu(bi->ie_offset);\r\nnotify_ielen = le32_to_cpu(bi->ie_length);\r\nnotify_signal = (s16)le16_to_cpu(bi->RSSI) * 100;\r\nbrcmf_dbg(CONN, "channel: %d(%d)\n", ch.chnum, freq);\r\nbrcmf_dbg(CONN, "capability: %X\n", notify_capability);\r\nbrcmf_dbg(CONN, "beacon interval: %d\n", notify_interval);\r\nbrcmf_dbg(CONN, "signal: %d\n", notify_signal);\r\nbss = cfg80211_inform_bss(wiphy, notify_channel, bssid,\r\n0, notify_capability, notify_interval,\r\nnotify_ie, notify_ielen, notify_signal, GFP_KERNEL);\r\nif (!bss) {\r\nerr = -ENOMEM;\r\ngoto CleanUp;\r\n}\r\ncfg80211_put_bss(wiphy, bss);\r\nCleanUp:\r\nkfree(buf);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic bool brcmf_is_ibssmode(struct brcmf_cfg80211_vif *vif)\r\n{\r\nreturn vif->mode == WL_MODE_IBSS;\r\n}\r\nstatic s32 brcmf_update_bss_info(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_if *ifp)\r\n{\r\nstruct brcmf_cfg80211_profile *profile = ndev_to_prof(ifp->ndev);\r\nstruct brcmf_bss_info_le *bi;\r\nstruct brcmf_ssid *ssid;\r\nstruct brcmf_tlv *tim;\r\nu16 beacon_interval;\r\nu8 dtim_period;\r\nsize_t ie_len;\r\nu8 *ie;\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (brcmf_is_ibssmode(ifp->vif))\r\nreturn err;\r\nssid = &profile->ssid;\r\n*(__le32 *)cfg->extra_buf = cpu_to_le32(WL_EXTRA_BUF_MAX);\r\nerr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\r\ncfg->extra_buf, WL_EXTRA_BUF_MAX);\r\nif (err) {\r\nbrcmf_err("Could not get bss info %d\n", err);\r\ngoto update_bss_info_out;\r\n}\r\nbi = (struct brcmf_bss_info_le *)(cfg->extra_buf + 4);\r\nerr = brcmf_inform_single_bss(cfg, bi);\r\nif (err)\r\ngoto update_bss_info_out;\r\nie = ((u8 *)bi) + le16_to_cpu(bi->ie_offset);\r\nie_len = le32_to_cpu(bi->ie_length);\r\nbeacon_interval = le16_to_cpu(bi->beacon_period);\r\ntim = brcmf_parse_tlvs(ie, ie_len, WLAN_EID_TIM);\r\nif (tim)\r\ndtim_period = tim->data[1];\r\nelse {\r\nu32 var;\r\nerr = brcmf_fil_iovar_int_get(ifp, "dtim_assoc", &var);\r\nif (err) {\r\nbrcmf_err("wl dtim_assoc failed (%d)\n", err);\r\ngoto update_bss_info_out;\r\n}\r\ndtim_period = (u8)var;\r\n}\r\nupdate_bss_info_out:\r\nbrcmf_dbg(TRACE, "Exit");\r\nreturn err;\r\n}\r\nvoid brcmf_abort_scanning(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct escan_info *escan = &cfg->escan_info;\r\nset_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\r\nif (cfg->scan_request) {\r\nescan->escan_state = WL_ESCAN_STATE_IDLE;\r\nbrcmf_notify_escan_complete(cfg, escan->ifp, true, true);\r\n}\r\nclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\r\nclear_bit(BRCMF_SCAN_STATUS_ABORT, &cfg->scan_status);\r\n}\r\nstatic void brcmf_cfg80211_escan_timeout_worker(struct work_struct *work)\r\n{\r\nstruct brcmf_cfg80211_info *cfg =\r\ncontainer_of(work, struct brcmf_cfg80211_info,\r\nescan_timeout_work);\r\nbrcmf_notify_escan_complete(cfg, cfg->escan_info.ifp, true, true);\r\n}\r\nstatic void brcmf_escan_timeout(unsigned long data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg =\r\n(struct brcmf_cfg80211_info *)data;\r\nif (cfg->scan_request) {\r\nbrcmf_err("timer expired\n");\r\nschedule_work(&cfg->escan_timeout_work);\r\n}\r\n}\r\nstatic s32\r\nbrcmf_compare_update_same_bss(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_bss_info_le *bss,\r\nstruct brcmf_bss_info_le *bss_info_le)\r\n{\r\nstruct brcmu_chan ch_bss, ch_bss_info_le;\r\nch_bss.chspec = le16_to_cpu(bss->chanspec);\r\ncfg->d11inf.decchspec(&ch_bss);\r\nch_bss_info_le.chspec = le16_to_cpu(bss_info_le->chanspec);\r\ncfg->d11inf.decchspec(&ch_bss_info_le);\r\nif (!memcmp(&bss_info_le->BSSID, &bss->BSSID, ETH_ALEN) &&\r\nch_bss.band == ch_bss_info_le.band &&\r\nbss_info_le->SSID_len == bss->SSID_len &&\r\n!memcmp(bss_info_le->SSID, bss->SSID, bss_info_le->SSID_len)) {\r\nif ((bss->flags & WLC_BSS_RSSI_ON_CHANNEL) ==\r\n(bss_info_le->flags & WLC_BSS_RSSI_ON_CHANNEL)) {\r\ns16 bss_rssi = le16_to_cpu(bss->RSSI);\r\ns16 bss_info_rssi = le16_to_cpu(bss_info_le->RSSI);\r\nif (bss_info_rssi > bss_rssi)\r\nbss->RSSI = bss_info_le->RSSI;\r\n} else if ((bss->flags & WLC_BSS_RSSI_ON_CHANNEL) &&\r\n(bss_info_le->flags & WLC_BSS_RSSI_ON_CHANNEL) == 0) {\r\nbss->RSSI = bss_info_le->RSSI;\r\nbss->flags |= WLC_BSS_RSSI_ON_CHANNEL;\r\n}\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_escan_handler(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\ns32 status;\r\ns32 err = 0;\r\nstruct brcmf_escan_result_le *escan_result_le;\r\nstruct brcmf_bss_info_le *bss_info_le;\r\nstruct brcmf_bss_info_le *bss = NULL;\r\nu32 bi_length;\r\nstruct brcmf_scan_results *list;\r\nu32 i;\r\nbool aborted;\r\nstatus = e->status;\r\nif (!test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\r\nbrcmf_err("scan not ready, bssidx=%d\n", ifp->bssidx);\r\nreturn -EPERM;\r\n}\r\nif (status == BRCMF_E_STATUS_PARTIAL) {\r\nbrcmf_dbg(SCAN, "ESCAN Partial result\n");\r\nescan_result_le = (struct brcmf_escan_result_le *) data;\r\nif (!escan_result_le) {\r\nbrcmf_err("Invalid escan result (NULL pointer)\n");\r\ngoto exit;\r\n}\r\nif (le16_to_cpu(escan_result_le->bss_count) != 1) {\r\nbrcmf_err("Invalid bss_count %d: ignoring\n",\r\nescan_result_le->bss_count);\r\ngoto exit;\r\n}\r\nbss_info_le = &escan_result_le->bss_info_le;\r\nif (brcmf_p2p_scan_finding_common_channel(cfg, bss_info_le))\r\ngoto exit;\r\nif (!cfg->scan_request) {\r\nbrcmf_dbg(SCAN, "result without cfg80211 request\n");\r\ngoto exit;\r\n}\r\nbi_length = le32_to_cpu(bss_info_le->length);\r\nif (bi_length != (le32_to_cpu(escan_result_le->buflen) -\r\nWL_ESCAN_RESULTS_FIXED_SIZE)) {\r\nbrcmf_err("Invalid bss_info length %d: ignoring\n",\r\nbi_length);\r\ngoto exit;\r\n}\r\nif (!(cfg_to_wiphy(cfg)->interface_modes &\r\nBIT(NL80211_IFTYPE_ADHOC))) {\r\nif (le16_to_cpu(bss_info_le->capability) &\r\nWLAN_CAPABILITY_IBSS) {\r\nbrcmf_err("Ignoring IBSS result\n");\r\ngoto exit;\r\n}\r\n}\r\nlist = (struct brcmf_scan_results *)\r\ncfg->escan_info.escan_buf;\r\nif (bi_length > WL_ESCAN_BUF_SIZE - list->buflen) {\r\nbrcmf_err("Buffer is too small: ignoring\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < list->count; i++) {\r\nbss = bss ? (struct brcmf_bss_info_le *)\r\n((unsigned char *)bss +\r\nle32_to_cpu(bss->length)) : list->bss_info_le;\r\nif (brcmf_compare_update_same_bss(cfg, bss,\r\nbss_info_le))\r\ngoto exit;\r\n}\r\nmemcpy(&(cfg->escan_info.escan_buf[list->buflen]),\r\nbss_info_le, bi_length);\r\nlist->version = le32_to_cpu(bss_info_le->version);\r\nlist->buflen += bi_length;\r\nlist->count++;\r\n} else {\r\ncfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\r\nif (brcmf_p2p_scan_finding_common_channel(cfg, NULL))\r\ngoto exit;\r\nif (cfg->scan_request) {\r\ncfg->bss_list = (struct brcmf_scan_results *)\r\ncfg->escan_info.escan_buf;\r\nbrcmf_inform_bss(cfg);\r\naborted = status != BRCMF_E_STATUS_SUCCESS;\r\nbrcmf_notify_escan_complete(cfg, ifp, aborted,\r\nfalse);\r\n} else\r\nbrcmf_dbg(SCAN, "Ignored scan complete result 0x%x\n",\r\nstatus);\r\n}\r\nexit:\r\nreturn err;\r\n}\r\nstatic void brcmf_init_escan(struct brcmf_cfg80211_info *cfg)\r\n{\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_ESCAN_RESULT,\r\nbrcmf_cfg80211_escan_handler);\r\ncfg->escan_info.escan_state = WL_ESCAN_STATE_IDLE;\r\ninit_timer(&cfg->escan_timeout);\r\ncfg->escan_timeout.data = (unsigned long) cfg;\r\ncfg->escan_timeout.function = brcmf_escan_timeout;\r\nINIT_WORK(&cfg->escan_timeout_work,\r\nbrcmf_cfg80211_escan_timeout_worker);\r\n}\r\nstatic __always_inline void brcmf_delay(u32 ms)\r\n{\r\nif (ms < 1000 / HZ) {\r\ncond_resched();\r\nmdelay(ms);\r\n} else {\r\nmsleep(ms);\r\n}\r\n}\r\nstatic s32 brcmf_cfg80211_resume(struct wiphy *wiphy)\r\n{\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nreturn 0;\r\n}\r\nstatic s32 brcmf_cfg80211_suspend(struct wiphy *wiphy,\r\nstruct cfg80211_wowlan *wow)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg);\r\nstruct brcmf_cfg80211_vif *vif;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nvif = ((struct brcmf_if *)netdev_priv(ndev))->vif;\r\nif (!check_vif_up(vif))\r\ngoto exit;\r\nlist_for_each_entry(vif, &cfg->vif_list, list) {\r\nif (!test_bit(BRCMF_VIF_STATUS_READY, &vif->sme_state))\r\ncontinue;\r\nbrcmf_link_down(vif);\r\nbrcmf_delay(500);\r\n}\r\nif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status))\r\nbrcmf_abort_scanning(cfg);\r\nbrcmf_set_mpc(netdev_priv(ndev), 1);\r\nexit:\r\nbrcmf_dbg(TRACE, "Exit\n");\r\ncfg->scan_status = 0;\r\nreturn 0;\r\n}\r\nstatic __used s32\r\nbrcmf_update_pmklist(struct net_device *ndev,\r\nstruct brcmf_cfg80211_pmk_list *pmk_list, s32 err)\r\n{\r\nint i, j;\r\nint pmkid_len;\r\npmkid_len = le32_to_cpu(pmk_list->pmkids.npmkid);\r\nbrcmf_dbg(CONN, "No of elements %d\n", pmkid_len);\r\nfor (i = 0; i < pmkid_len; i++) {\r\nbrcmf_dbg(CONN, "PMKID[%d]: %pM =\n", i,\r\n&pmk_list->pmkids.pmkid[i].BSSID);\r\nfor (j = 0; j < WLAN_PMKID_LEN; j++)\r\nbrcmf_dbg(CONN, "%02x\n",\r\npmk_list->pmkids.pmkid[i].PMKID[j]);\r\n}\r\nif (!err)\r\nbrcmf_fil_iovar_data_set(netdev_priv(ndev), "pmkid_info",\r\n(char *)pmk_list, sizeof(*pmk_list));\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_pmksa(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct pmkid_list *pmkids = &cfg->pmk_list->pmkids;\r\ns32 err = 0;\r\nint i;\r\nint pmkid_len;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\npmkid_len = le32_to_cpu(pmkids->npmkid);\r\nfor (i = 0; i < pmkid_len; i++)\r\nif (!memcmp(pmksa->bssid, pmkids->pmkid[i].BSSID, ETH_ALEN))\r\nbreak;\r\nif (i < WL_NUM_PMKIDS_MAX) {\r\nmemcpy(pmkids->pmkid[i].BSSID, pmksa->bssid, ETH_ALEN);\r\nmemcpy(pmkids->pmkid[i].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);\r\nif (i == pmkid_len) {\r\npmkid_len++;\r\npmkids->npmkid = cpu_to_le32(pmkid_len);\r\n}\r\n} else\r\nerr = -EINVAL;\r\nbrcmf_dbg(CONN, "set_pmksa,IW_PMKSA_ADD - PMKID: %pM =\n",\r\npmkids->pmkid[pmkid_len].BSSID);\r\nfor (i = 0; i < WLAN_PMKID_LEN; i++)\r\nbrcmf_dbg(CONN, "%02x\n", pmkids->pmkid[pmkid_len].PMKID[i]);\r\nerr = brcmf_update_pmklist(ndev, cfg->pmk_list, err);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_del_pmksa(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_pmksa *pmksa)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct pmkid_list pmkid;\r\ns32 err = 0;\r\nint i, pmkid_len;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nmemcpy(&pmkid.pmkid[0].BSSID, pmksa->bssid, ETH_ALEN);\r\nmemcpy(&pmkid.pmkid[0].PMKID, pmksa->pmkid, WLAN_PMKID_LEN);\r\nbrcmf_dbg(CONN, "del_pmksa,IW_PMKSA_REMOVE - PMKID: %pM =\n",\r\n&pmkid.pmkid[0].BSSID);\r\nfor (i = 0; i < WLAN_PMKID_LEN; i++)\r\nbrcmf_dbg(CONN, "%02x\n", pmkid.pmkid[0].PMKID[i]);\r\npmkid_len = le32_to_cpu(cfg->pmk_list->pmkids.npmkid);\r\nfor (i = 0; i < pmkid_len; i++)\r\nif (!memcmp\r\n(pmksa->bssid, &cfg->pmk_list->pmkids.pmkid[i].BSSID,\r\nETH_ALEN))\r\nbreak;\r\nif ((pmkid_len > 0)\r\n&& (i < pmkid_len)) {\r\nmemset(&cfg->pmk_list->pmkids.pmkid[i], 0,\r\nsizeof(struct pmkid));\r\nfor (; i < (pmkid_len - 1); i++) {\r\nmemcpy(&cfg->pmk_list->pmkids.pmkid[i].BSSID,\r\n&cfg->pmk_list->pmkids.pmkid[i + 1].BSSID,\r\nETH_ALEN);\r\nmemcpy(&cfg->pmk_list->pmkids.pmkid[i].PMKID,\r\n&cfg->pmk_list->pmkids.pmkid[i + 1].PMKID,\r\nWLAN_PMKID_LEN);\r\n}\r\ncfg->pmk_list->pmkids.npmkid = cpu_to_le32(pmkid_len - 1);\r\n} else\r\nerr = -EINVAL;\r\nerr = brcmf_update_pmklist(ndev, cfg->pmk_list, err);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_flush_pmksa(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nmemset(cfg->pmk_list, 0, sizeof(*cfg->pmk_list));\r\nerr = brcmf_update_pmklist(ndev, cfg->pmk_list, err);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_sched_scan_results(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct brcmf_pno_net_info_le *netinfo, *netinfo_start;\r\nstruct cfg80211_scan_request *request = NULL;\r\nstruct cfg80211_ssid *ssid = NULL;\r\nstruct ieee80211_channel *channel = NULL;\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg);\r\nint err = 0;\r\nint channel_req = 0;\r\nint band = 0;\r\nstruct brcmf_pno_scanresults_le *pfn_result;\r\nu32 result_count;\r\nu32 status;\r\nbrcmf_dbg(SCAN, "Enter\n");\r\nif (e->event_code == BRCMF_E_PFN_NET_LOST) {\r\nbrcmf_dbg(SCAN, "PFN NET LOST event. Do Nothing\n");\r\nreturn 0;\r\n}\r\npfn_result = (struct brcmf_pno_scanresults_le *)data;\r\nresult_count = le32_to_cpu(pfn_result->count);\r\nstatus = le32_to_cpu(pfn_result->status);\r\nWARN_ON(status != BRCMF_PNO_SCAN_COMPLETE);\r\nbrcmf_dbg(SCAN, "PFN NET FOUND event. count: %d\n", result_count);\r\nif (result_count > 0) {\r\nint i;\r\nrequest = kzalloc(sizeof(*request), GFP_KERNEL);\r\nssid = kcalloc(result_count, sizeof(*ssid), GFP_KERNEL);\r\nchannel = kcalloc(result_count, sizeof(*channel), GFP_KERNEL);\r\nif (!request || !ssid || !channel) {\r\nerr = -ENOMEM;\r\ngoto out_err;\r\n}\r\nrequest->wiphy = wiphy;\r\ndata += sizeof(struct brcmf_pno_scanresults_le);\r\nnetinfo_start = (struct brcmf_pno_net_info_le *)data;\r\nfor (i = 0; i < result_count; i++) {\r\nnetinfo = &netinfo_start[i];\r\nif (!netinfo) {\r\nbrcmf_err("Invalid netinfo ptr. index: %d\n",\r\ni);\r\nerr = -EINVAL;\r\ngoto out_err;\r\n}\r\nbrcmf_dbg(SCAN, "SSID:%s Channel:%d\n",\r\nnetinfo->SSID, netinfo->channel);\r\nmemcpy(ssid[i].ssid, netinfo->SSID, netinfo->SSID_len);\r\nssid[i].ssid_len = netinfo->SSID_len;\r\nrequest->n_ssids++;\r\nchannel_req = netinfo->channel;\r\nif (channel_req <= CH_MAX_2G_CHANNEL)\r\nband = NL80211_BAND_2GHZ;\r\nelse\r\nband = NL80211_BAND_5GHZ;\r\nchannel[i].center_freq =\r\nieee80211_channel_to_frequency(channel_req,\r\nband);\r\nchannel[i].band = band;\r\nchannel[i].flags |= IEEE80211_CHAN_NO_HT40;\r\nrequest->channels[i] = &channel[i];\r\nrequest->n_channels++;\r\n}\r\nif (request->n_ssids)\r\nrequest->ssids = &ssid[0];\r\nif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\r\nbrcmf_abort_scanning(cfg);\r\n}\r\nset_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\r\nerr = brcmf_do_escan(cfg, wiphy, ifp, request);\r\nif (err) {\r\nclear_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status);\r\ngoto out_err;\r\n}\r\ncfg->sched_escan = true;\r\ncfg->scan_request = request;\r\n} else {\r\nbrcmf_err("FALSE PNO Event. (pfn_count == 0)\n");\r\ngoto out_err;\r\n}\r\nkfree(ssid);\r\nkfree(channel);\r\nkfree(request);\r\nreturn 0;\r\nout_err:\r\nkfree(ssid);\r\nkfree(channel);\r\nkfree(request);\r\ncfg80211_sched_scan_stopped(wiphy);\r\nreturn err;\r\n}\r\nstatic int brcmf_dev_pno_clean(struct net_device *ndev)\r\n{\r\nint ret;\r\nret = brcmf_fil_iovar_int_set(netdev_priv(ndev), "pfn", 0);\r\nif (ret == 0) {\r\nret = brcmf_fil_iovar_data_set(netdev_priv(ndev), "pfnclear",\r\nNULL, 0);\r\n}\r\nif (ret < 0)\r\nbrcmf_err("failed code %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int brcmf_dev_pno_config(struct net_device *ndev)\r\n{\r\nstruct brcmf_pno_param_le pfn_param;\r\nmemset(&pfn_param, 0, sizeof(pfn_param));\r\npfn_param.version = cpu_to_le32(BRCMF_PNO_VERSION);\r\npfn_param.flags = cpu_to_le16(1 << BRCMF_PNO_ENABLE_ADAPTSCAN_BIT);\r\npfn_param.repeat = BRCMF_PNO_REPEAT;\r\npfn_param.exp = BRCMF_PNO_FREQ_EXPO_MAX;\r\npfn_param.scan_freq = cpu_to_le32(BRCMF_PNO_TIME);\r\nreturn brcmf_fil_iovar_data_set(netdev_priv(ndev), "pfn_set",\r\n&pfn_param, sizeof(pfn_param));\r\n}\r\nstatic int\r\nbrcmf_cfg80211_sched_scan_start(struct wiphy *wiphy,\r\nstruct net_device *ndev,\r\nstruct cfg80211_sched_scan_request *request)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_info *cfg = wiphy_priv(wiphy);\r\nstruct brcmf_pno_net_param_le pfn;\r\nint i;\r\nint ret = 0;\r\nbrcmf_dbg(SCAN, "Enter n_match_sets:%d n_ssids:%d\n",\r\nrequest->n_match_sets, request->n_ssids);\r\nif (test_bit(BRCMF_SCAN_STATUS_BUSY, &cfg->scan_status)) {\r\nbrcmf_err("Scanning already: status (%lu)\n", cfg->scan_status);\r\nreturn -EAGAIN;\r\n}\r\nif (test_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status)) {\r\nbrcmf_err("Scanning suppressed: status (%lu)\n",\r\ncfg->scan_status);\r\nreturn -EAGAIN;\r\n}\r\nif (!request->n_ssids || !request->n_match_sets) {\r\nbrcmf_err("Invalid sched scan req!! n_ssids:%d\n",\r\nrequest->n_ssids);\r\nreturn -EINVAL;\r\n}\r\nif (request->n_ssids > 0) {\r\nfor (i = 0; i < request->n_ssids; i++) {\r\nbrcmf_dbg(SCAN, ">>> Active scan req for ssid (%s)\n",\r\nrequest->ssids[i].ssid);\r\n}\r\n}\r\nif (request->n_match_sets > 0) {\r\nret = brcmf_dev_pno_clean(ndev);\r\nif (ret < 0) {\r\nbrcmf_err("failed error=%d\n", ret);\r\nreturn ret;\r\n}\r\nret = brcmf_dev_pno_config(ndev);\r\nif (ret < 0) {\r\nbrcmf_err("PNO setup failed!! ret=%d\n", ret);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < request->n_match_sets; i++) {\r\nstruct cfg80211_ssid *ssid;\r\nu32 ssid_len;\r\nssid = &request->match_sets[i].ssid;\r\nssid_len = ssid->ssid_len;\r\nif (!ssid_len) {\r\nbrcmf_err("skip broadcast ssid\n");\r\ncontinue;\r\n}\r\npfn.auth = cpu_to_le32(WLAN_AUTH_OPEN);\r\npfn.wpa_auth = cpu_to_le32(BRCMF_PNO_WPA_AUTH_ANY);\r\npfn.wsec = cpu_to_le32(0);\r\npfn.infra = cpu_to_le32(1);\r\npfn.flags = cpu_to_le32(1 << BRCMF_PNO_HIDDEN_BIT);\r\npfn.ssid.SSID_len = cpu_to_le32(ssid_len);\r\nmemcpy(pfn.ssid.SSID, ssid->ssid, ssid_len);\r\nret = brcmf_fil_iovar_data_set(ifp, "pfn_add", &pfn,\r\nsizeof(pfn));\r\nbrcmf_dbg(SCAN, ">>> PNO filter %s for ssid (%s)\n",\r\nret == 0 ? "set" : "failed", ssid->ssid);\r\n}\r\nif (brcmf_fil_iovar_int_set(ifp, "pfn", 1) < 0) {\r\nbrcmf_err("PNO enable failed!! ret=%d\n", ret);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int brcmf_cfg80211_sched_scan_stop(struct wiphy *wiphy,\r\nstruct net_device *ndev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nbrcmf_dbg(SCAN, "enter\n");\r\nbrcmf_dev_pno_clean(ndev);\r\nif (cfg->sched_escan)\r\nbrcmf_notify_escan_complete(cfg, netdev_priv(ndev), true, true);\r\nreturn 0;\r\n}\r\nstatic int brcmf_cfg80211_testmode(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nvoid *data, int len)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct net_device *ndev = cfg_to_ndev(cfg);\r\nstruct brcmf_dcmd *dcmd = data;\r\nstruct sk_buff *reply;\r\nint ret;\r\nbrcmf_dbg(TRACE, "cmd %x set %d buf %p len %d\n", dcmd->cmd, dcmd->set,\r\ndcmd->buf, dcmd->len);\r\nif (dcmd->set)\r\nret = brcmf_fil_cmd_data_set(netdev_priv(ndev), dcmd->cmd,\r\ndcmd->buf, dcmd->len);\r\nelse\r\nret = brcmf_fil_cmd_data_get(netdev_priv(ndev), dcmd->cmd,\r\ndcmd->buf, dcmd->len);\r\nif (ret == 0) {\r\nreply = cfg80211_testmode_alloc_reply_skb(wiphy, sizeof(*dcmd));\r\nnla_put(reply, NL80211_ATTR_TESTDATA, sizeof(*dcmd), dcmd);\r\nret = cfg80211_testmode_reply(reply);\r\n}\r\nreturn ret;\r\n}\r\nstatic s32 brcmf_configure_opensecurity(struct brcmf_if *ifp)\r\n{\r\ns32 err;\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "auth", 0);\r\nif (err < 0) {\r\nbrcmf_err("auth error %d\n", err);\r\nreturn err;\r\n}\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "wsec", 0);\r\nif (err < 0) {\r\nbrcmf_err("wsec error %d\n", err);\r\nreturn err;\r\n}\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", WPA_AUTH_NONE);\r\nif (err < 0) {\r\nbrcmf_err("wpa_auth error %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool brcmf_valid_wpa_oui(u8 *oui, bool is_rsn_ie)\r\n{\r\nif (is_rsn_ie)\r\nreturn (memcmp(oui, RSN_OUI, TLV_OUI_LEN) == 0);\r\nreturn (memcmp(oui, WPA_OUI, TLV_OUI_LEN) == 0);\r\n}\r\nstatic s32\r\nbrcmf_configure_wpaie(struct net_device *ndev, struct brcmf_vs_tlv *wpa_ie,\r\nbool is_rsn_ie)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nu32 auth = 0;\r\nu16 count;\r\ns32 err = 0;\r\ns32 len = 0;\r\nu32 i;\r\nu32 wsec;\r\nu32 pval = 0;\r\nu32 gval = 0;\r\nu32 wpa_auth = 0;\r\nu32 offset;\r\nu8 *data;\r\nu16 rsn_cap;\r\nu32 wme_bss_disable;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (wpa_ie == NULL)\r\ngoto exit;\r\nlen = wpa_ie->len + TLV_HDR_LEN;\r\ndata = (u8 *)wpa_ie;\r\noffset = TLV_HDR_LEN;\r\nif (!is_rsn_ie)\r\noffset += VS_IE_FIXED_HDR_LEN;\r\nelse\r\noffset += WPA_IE_VERSION_LEN;\r\nif (offset + WPA_IE_MIN_OUI_LEN > len) {\r\nerr = -EINVAL;\r\nbrcmf_err("no multicast cipher suite\n");\r\ngoto exit;\r\n}\r\nif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\r\nerr = -EINVAL;\r\nbrcmf_err("ivalid OUI\n");\r\ngoto exit;\r\n}\r\noffset += TLV_OUI_LEN;\r\nswitch (data[offset]) {\r\ncase WPA_CIPHER_NONE:\r\ngval = 0;\r\nbreak;\r\ncase WPA_CIPHER_WEP_40:\r\ncase WPA_CIPHER_WEP_104:\r\ngval = WEP_ENABLED;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\ngval = TKIP_ENABLED;\r\nbreak;\r\ncase WPA_CIPHER_AES_CCM:\r\ngval = AES_ENABLED;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\nbrcmf_err("Invalid multi cast cipher info\n");\r\ngoto exit;\r\n}\r\noffset++;\r\ncount = data[offset] + (data[offset + 1] << 8);\r\noffset += WPA_IE_SUITE_COUNT_LEN;\r\nif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\r\nerr = -EINVAL;\r\nbrcmf_err("no unicast cipher suite\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\r\nerr = -EINVAL;\r\nbrcmf_err("ivalid OUI\n");\r\ngoto exit;\r\n}\r\noffset += TLV_OUI_LEN;\r\nswitch (data[offset]) {\r\ncase WPA_CIPHER_NONE:\r\nbreak;\r\ncase WPA_CIPHER_WEP_40:\r\ncase WPA_CIPHER_WEP_104:\r\npval |= WEP_ENABLED;\r\nbreak;\r\ncase WPA_CIPHER_TKIP:\r\npval |= TKIP_ENABLED;\r\nbreak;\r\ncase WPA_CIPHER_AES_CCM:\r\npval |= AES_ENABLED;\r\nbreak;\r\ndefault:\r\nbrcmf_err("Ivalid unicast security info\n");\r\n}\r\noffset++;\r\n}\r\ncount = data[offset] + (data[offset + 1] << 8);\r\noffset += WPA_IE_SUITE_COUNT_LEN;\r\nif (offset + (WPA_IE_MIN_OUI_LEN * count) > len) {\r\nerr = -EINVAL;\r\nbrcmf_err("no auth key mgmt suite\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < count; i++) {\r\nif (!brcmf_valid_wpa_oui(&data[offset], is_rsn_ie)) {\r\nerr = -EINVAL;\r\nbrcmf_err("ivalid OUI\n");\r\ngoto exit;\r\n}\r\noffset += TLV_OUI_LEN;\r\nswitch (data[offset]) {\r\ncase RSN_AKM_NONE:\r\nbrcmf_dbg(TRACE, "RSN_AKM_NONE\n");\r\nwpa_auth |= WPA_AUTH_NONE;\r\nbreak;\r\ncase RSN_AKM_UNSPECIFIED:\r\nbrcmf_dbg(TRACE, "RSN_AKM_UNSPECIFIED\n");\r\nis_rsn_ie ? (wpa_auth |= WPA2_AUTH_UNSPECIFIED) :\r\n(wpa_auth |= WPA_AUTH_UNSPECIFIED);\r\nbreak;\r\ncase RSN_AKM_PSK:\r\nbrcmf_dbg(TRACE, "RSN_AKM_PSK\n");\r\nis_rsn_ie ? (wpa_auth |= WPA2_AUTH_PSK) :\r\n(wpa_auth |= WPA_AUTH_PSK);\r\nbreak;\r\ndefault:\r\nbrcmf_err("Ivalid key mgmt info\n");\r\n}\r\noffset++;\r\n}\r\nif (is_rsn_ie) {\r\nwme_bss_disable = 1;\r\nif ((offset + RSN_CAP_LEN) <= len) {\r\nrsn_cap = data[offset] + (data[offset + 1] << 8);\r\nif (rsn_cap & RSN_CAP_PTK_REPLAY_CNTR_MASK)\r\nwme_bss_disable = 0;\r\n}\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "wme_bss_disable",\r\nwme_bss_disable);\r\nif (err < 0) {\r\nbrcmf_err("wme_bss_disable error %d\n", err);\r\ngoto exit;\r\n}\r\n}\r\nwsec = (pval | gval | SES_OW_ENABLED);\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "auth", auth);\r\nif (err < 0) {\r\nbrcmf_err("auth error %d\n", err);\r\ngoto exit;\r\n}\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "wsec", wsec);\r\nif (err < 0) {\r\nbrcmf_err("wsec error %d\n", err);\r\ngoto exit;\r\n}\r\nerr = brcmf_fil_bsscfg_int_set(ifp, "wpa_auth", wpa_auth);\r\nif (err < 0) {\r\nbrcmf_err("wpa_auth error %d\n", err);\r\ngoto exit;\r\n}\r\nexit:\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_parse_vndr_ies(const u8 *vndr_ie_buf, u32 vndr_ie_len,\r\nstruct parsed_vndr_ies *vndr_ies)\r\n{\r\ns32 err = 0;\r\nstruct brcmf_vs_tlv *vndrie;\r\nstruct brcmf_tlv *ie;\r\nstruct parsed_vndr_ie_info *parsed_info;\r\ns32 remaining_len;\r\nremaining_len = (s32)vndr_ie_len;\r\nmemset(vndr_ies, 0, sizeof(*vndr_ies));\r\nie = (struct brcmf_tlv *)vndr_ie_buf;\r\nwhile (ie) {\r\nif (ie->id != WLAN_EID_VENDOR_SPECIFIC)\r\ngoto next;\r\nvndrie = (struct brcmf_vs_tlv *)ie;\r\nif (vndrie->len < (VS_IE_FIXED_HDR_LEN - TLV_HDR_LEN + 1)) {\r\nbrcmf_err("invalid vndr ie. length is too small %d\n",\r\nvndrie->len);\r\ngoto next;\r\n}\r\nif (!memcmp(vndrie->oui, (u8 *)WPA_OUI, TLV_OUI_LEN) &&\r\n((vndrie->oui_type == WPA_OUI_TYPE) ||\r\n(vndrie->oui_type == WME_OUI_TYPE))) {\r\nbrcmf_dbg(TRACE, "Found WPA/WME oui. Do not add it\n");\r\ngoto next;\r\n}\r\nparsed_info = &vndr_ies->ie_info[vndr_ies->count];\r\nparsed_info->ie_ptr = (char *)vndrie;\r\nparsed_info->ie_len = vndrie->len + TLV_HDR_LEN;\r\nmemcpy(&parsed_info->vndrie, vndrie, sizeof(*vndrie));\r\nvndr_ies->count++;\r\nbrcmf_dbg(TRACE, "** OUI %02x %02x %02x, type 0x%02x\n",\r\nparsed_info->vndrie.oui[0],\r\nparsed_info->vndrie.oui[1],\r\nparsed_info->vndrie.oui[2],\r\nparsed_info->vndrie.oui_type);\r\nif (vndr_ies->count >= VNDR_IE_PARSE_LIMIT)\r\nbreak;\r\nnext:\r\nremaining_len -= (ie->len + TLV_HDR_LEN);\r\nif (remaining_len <= TLV_HDR_LEN)\r\nie = NULL;\r\nelse\r\nie = (struct brcmf_tlv *)(((u8 *)ie) + ie->len +\r\nTLV_HDR_LEN);\r\n}\r\nreturn err;\r\n}\r\nstatic u32\r\nbrcmf_vndr_ie(u8 *iebuf, s32 pktflag, u8 *ie_ptr, u32 ie_len, s8 *add_del_cmd)\r\n{\r\n__le32 iecount_le;\r\n__le32 pktflag_le;\r\nstrncpy(iebuf, add_del_cmd, VNDR_IE_CMD_LEN - 1);\r\niebuf[VNDR_IE_CMD_LEN - 1] = '\0';\r\niecount_le = cpu_to_le32(1);\r\nmemcpy(&iebuf[VNDR_IE_COUNT_OFFSET], &iecount_le, sizeof(iecount_le));\r\npktflag_le = cpu_to_le32(pktflag);\r\nmemcpy(&iebuf[VNDR_IE_PKTFLAG_OFFSET], &pktflag_le, sizeof(pktflag_le));\r\nmemcpy(&iebuf[VNDR_IE_VSIE_OFFSET], ie_ptr, ie_len);\r\nreturn ie_len + VNDR_IE_HDR_SIZE;\r\n}\r\ns32 brcmf_vif_set_mgmt_ie(struct brcmf_cfg80211_vif *vif, s32 pktflag,\r\nconst u8 *vndr_ie_buf, u32 vndr_ie_len)\r\n{\r\nstruct brcmf_if *ifp;\r\nstruct vif_saved_ie *saved_ie;\r\ns32 err = 0;\r\nu8 *iovar_ie_buf;\r\nu8 *curr_ie_buf;\r\nu8 *mgmt_ie_buf = NULL;\r\nint mgmt_ie_buf_len;\r\nu32 *mgmt_ie_len;\r\nu32 del_add_ie_buf_len = 0;\r\nu32 total_ie_buf_len = 0;\r\nu32 parsed_ie_buf_len = 0;\r\nstruct parsed_vndr_ies old_vndr_ies;\r\nstruct parsed_vndr_ies new_vndr_ies;\r\nstruct parsed_vndr_ie_info *vndrie_info;\r\ns32 i;\r\nu8 *ptr;\r\nint remained_buf_len;\r\nif (!vif)\r\nreturn -ENODEV;\r\nifp = vif->ifp;\r\nsaved_ie = &vif->saved_ie;\r\nbrcmf_dbg(TRACE, "bssidx %d, pktflag : 0x%02X\n", ifp->bssidx, pktflag);\r\niovar_ie_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\r\nif (!iovar_ie_buf)\r\nreturn -ENOMEM;\r\ncurr_ie_buf = iovar_ie_buf;\r\nswitch (pktflag) {\r\ncase BRCMF_VNDR_IE_PRBREQ_FLAG:\r\nmgmt_ie_buf = saved_ie->probe_req_ie;\r\nmgmt_ie_len = &saved_ie->probe_req_ie_len;\r\nmgmt_ie_buf_len = sizeof(saved_ie->probe_req_ie);\r\nbreak;\r\ncase BRCMF_VNDR_IE_PRBRSP_FLAG:\r\nmgmt_ie_buf = saved_ie->probe_res_ie;\r\nmgmt_ie_len = &saved_ie->probe_res_ie_len;\r\nmgmt_ie_buf_len = sizeof(saved_ie->probe_res_ie);\r\nbreak;\r\ncase BRCMF_VNDR_IE_BEACON_FLAG:\r\nmgmt_ie_buf = saved_ie->beacon_ie;\r\nmgmt_ie_len = &saved_ie->beacon_ie_len;\r\nmgmt_ie_buf_len = sizeof(saved_ie->beacon_ie);\r\nbreak;\r\ncase BRCMF_VNDR_IE_ASSOCREQ_FLAG:\r\nmgmt_ie_buf = saved_ie->assoc_req_ie;\r\nmgmt_ie_len = &saved_ie->assoc_req_ie_len;\r\nmgmt_ie_buf_len = sizeof(saved_ie->assoc_req_ie);\r\nbreak;\r\ndefault:\r\nerr = -EPERM;\r\nbrcmf_err("not suitable type\n");\r\ngoto exit;\r\n}\r\nif (vndr_ie_len > mgmt_ie_buf_len) {\r\nerr = -ENOMEM;\r\nbrcmf_err("extra IE size too big\n");\r\ngoto exit;\r\n}\r\nif (vndr_ie_buf && vndr_ie_len && curr_ie_buf) {\r\nptr = curr_ie_buf;\r\nbrcmf_parse_vndr_ies(vndr_ie_buf, vndr_ie_len, &new_vndr_ies);\r\nfor (i = 0; i < new_vndr_ies.count; i++) {\r\nvndrie_info = &new_vndr_ies.ie_info[i];\r\nmemcpy(ptr + parsed_ie_buf_len, vndrie_info->ie_ptr,\r\nvndrie_info->ie_len);\r\nparsed_ie_buf_len += vndrie_info->ie_len;\r\n}\r\n}\r\nif (mgmt_ie_buf && *mgmt_ie_len) {\r\nif (parsed_ie_buf_len && (parsed_ie_buf_len == *mgmt_ie_len) &&\r\n(memcmp(mgmt_ie_buf, curr_ie_buf,\r\nparsed_ie_buf_len) == 0)) {\r\nbrcmf_dbg(TRACE, "Previous mgmt IE equals to current IE\n");\r\ngoto exit;\r\n}\r\nbrcmf_parse_vndr_ies(mgmt_ie_buf, *mgmt_ie_len, &old_vndr_ies);\r\nfor (i = 0; i < old_vndr_ies.count; i++) {\r\nvndrie_info = &old_vndr_ies.ie_info[i];\r\nbrcmf_dbg(TRACE, "DEL ID : %d, Len: %d , OUI:%02x:%02x:%02x\n",\r\nvndrie_info->vndrie.id,\r\nvndrie_info->vndrie.len,\r\nvndrie_info->vndrie.oui[0],\r\nvndrie_info->vndrie.oui[1],\r\nvndrie_info->vndrie.oui[2]);\r\ndel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\r\nvndrie_info->ie_ptr,\r\nvndrie_info->ie_len,\r\n"del");\r\ncurr_ie_buf += del_add_ie_buf_len;\r\ntotal_ie_buf_len += del_add_ie_buf_len;\r\n}\r\n}\r\n*mgmt_ie_len = 0;\r\nif (mgmt_ie_buf && parsed_ie_buf_len) {\r\nptr = mgmt_ie_buf;\r\nremained_buf_len = mgmt_ie_buf_len;\r\nfor (i = 0; i < new_vndr_ies.count; i++) {\r\nvndrie_info = &new_vndr_ies.ie_info[i];\r\nif (remained_buf_len < (vndrie_info->vndrie.len +\r\nVNDR_IE_VSIE_OFFSET)) {\r\nbrcmf_err("no space in mgmt_ie_buf: len left %d",\r\nremained_buf_len);\r\nbreak;\r\n}\r\nremained_buf_len -= (vndrie_info->ie_len +\r\nVNDR_IE_VSIE_OFFSET);\r\nbrcmf_dbg(TRACE, "ADDED ID : %d, Len: %d, OUI:%02x:%02x:%02x\n",\r\nvndrie_info->vndrie.id,\r\nvndrie_info->vndrie.len,\r\nvndrie_info->vndrie.oui[0],\r\nvndrie_info->vndrie.oui[1],\r\nvndrie_info->vndrie.oui[2]);\r\ndel_add_ie_buf_len = brcmf_vndr_ie(curr_ie_buf, pktflag,\r\nvndrie_info->ie_ptr,\r\nvndrie_info->ie_len,\r\n"add");\r\nmemcpy(ptr + (*mgmt_ie_len), vndrie_info->ie_ptr,\r\nvndrie_info->ie_len);\r\n*mgmt_ie_len += vndrie_info->ie_len;\r\ncurr_ie_buf += del_add_ie_buf_len;\r\ntotal_ie_buf_len += del_add_ie_buf_len;\r\n}\r\n}\r\nif (total_ie_buf_len) {\r\nerr = brcmf_fil_bsscfg_data_set(ifp, "vndr_ie", iovar_ie_buf,\r\ntotal_ie_buf_len);\r\nif (err)\r\nbrcmf_err("vndr ie set error : %d\n", err);\r\n}\r\nexit:\r\nkfree(iovar_ie_buf);\r\nreturn err;\r\n}\r\ns32 brcmf_vif_clear_mgmt_ies(struct brcmf_cfg80211_vif *vif)\r\n{\r\ns32 pktflags[] = {\r\nBRCMF_VNDR_IE_PRBREQ_FLAG,\r\nBRCMF_VNDR_IE_PRBRSP_FLAG,\r\nBRCMF_VNDR_IE_BEACON_FLAG\r\n};\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(pktflags); i++)\r\nbrcmf_vif_set_mgmt_ie(vif, pktflags[i], NULL, 0);\r\nmemset(&vif->saved_ie, 0, sizeof(vif->saved_ie));\r\nreturn 0;\r\n}\r\nstatic s32\r\nbrcmf_config_ap_mgmt_ie(struct brcmf_cfg80211_vif *vif,\r\nstruct cfg80211_beacon_data *beacon)\r\n{\r\ns32 err;\r\nerr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_BEACON_FLAG,\r\nbeacon->tail, beacon->tail_len);\r\nif (err) {\r\nbrcmf_err("Set Beacon IE Failed\n");\r\nreturn err;\r\n}\r\nbrcmf_dbg(TRACE, "Applied Vndr IEs for Beacon\n");\r\nerr = brcmf_vif_set_mgmt_ie(vif, BRCMF_VNDR_IE_PRBRSP_FLAG,\r\nbeacon->proberesp_ies,\r\nbeacon->proberesp_ies_len);\r\nif (err)\r\nbrcmf_err("Set Probe Resp IE Failed\n");\r\nelse\r\nbrcmf_dbg(TRACE, "Applied Vndr IEs for Probe Resp\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_set_channel(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_if *ifp,\r\nstruct ieee80211_channel *channel)\r\n{\r\nu16 chanspec;\r\ns32 err;\r\nbrcmf_dbg(TRACE, "band=%d, center_freq=%d\n", channel->band,\r\nchannel->center_freq);\r\nchanspec = channel_to_chanspec(&cfg->d11inf, channel);\r\nerr = brcmf_fil_iovar_int_set(ifp, "chanspec", chanspec);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_ap_settings *settings)\r\n{\r\ns32 ie_offset;\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_tlv *ssid_ie;\r\nstruct brcmf_ssid_le ssid_le;\r\ns32 err = -EPERM;\r\nstruct brcmf_tlv *rsn_ie;\r\nstruct brcmf_vs_tlv *wpa_ie;\r\nstruct brcmf_join_params join_params;\r\nenum nl80211_iftype dev_role;\r\nstruct brcmf_fil_bss_enable_le bss_enable;\r\nbrcmf_dbg(TRACE, "channel_type=%d, beacon_interval=%d, dtim_period=%d,\n",\r\ncfg80211_get_chandef_type(&settings->chandef),\r\nsettings->beacon_interval,\r\nsettings->dtim_period);\r\nbrcmf_dbg(TRACE, "ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\n",\r\nsettings->ssid, settings->ssid_len, settings->auth_type,\r\nsettings->inactivity_timeout);\r\ndev_role = ifp->vif->wdev.iftype;\r\nmemset(&ssid_le, 0, sizeof(ssid_le));\r\nif (settings->ssid == NULL || settings->ssid_len == 0) {\r\nie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN;\r\nssid_ie = brcmf_parse_tlvs(\r\n(u8 *)&settings->beacon.head[ie_offset],\r\nsettings->beacon.head_len - ie_offset,\r\nWLAN_EID_SSID);\r\nif (!ssid_ie)\r\nreturn -EINVAL;\r\nmemcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len);\r\nssid_le.SSID_len = cpu_to_le32(ssid_ie->len);\r\nbrcmf_dbg(TRACE, "SSID is (%s) in Head\n", ssid_le.SSID);\r\n} else {\r\nmemcpy(ssid_le.SSID, settings->ssid, settings->ssid_len);\r\nssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len);\r\n}\r\nbrcmf_set_mpc(ifp, 0);\r\nbrcmf_configure_arp_offload(ifp, false);\r\nrsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail,\r\nsettings->beacon.tail_len, WLAN_EID_RSN);\r\nwpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail,\r\nsettings->beacon.tail_len);\r\nif ((wpa_ie != NULL || rsn_ie != NULL)) {\r\nbrcmf_dbg(TRACE, "WPA(2) IE is found\n");\r\nif (wpa_ie != NULL) {\r\nerr = brcmf_configure_wpaie(ndev, wpa_ie, false);\r\nif (err < 0)\r\ngoto exit;\r\n} else {\r\nerr = brcmf_configure_wpaie(ndev,\r\n(struct brcmf_vs_tlv *)rsn_ie, true);\r\nif (err < 0)\r\ngoto exit;\r\n}\r\n} else {\r\nbrcmf_dbg(TRACE, "No WPA(2) IEs found\n");\r\nbrcmf_configure_opensecurity(ifp);\r\n}\r\nbrcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon);\r\nerr = brcmf_cfg80211_set_channel(cfg, ifp, settings->chandef.chan);\r\nif (err < 0) {\r\nbrcmf_err("Set Channel failed, %d\n", err);\r\ngoto exit;\r\n}\r\nif (settings->beacon_interval) {\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD,\r\nsettings->beacon_interval);\r\nif (err < 0) {\r\nbrcmf_err("Beacon Interval Set Error, %d\n", err);\r\ngoto exit;\r\n}\r\n}\r\nif (settings->dtim_period) {\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD,\r\nsettings->dtim_period);\r\nif (err < 0) {\r\nbrcmf_err("DTIM Interval Set Error, %d\n", err);\r\ngoto exit;\r\n}\r\n}\r\nif (dev_role == NL80211_IFTYPE_AP) {\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1);\r\nif (err < 0) {\r\nbrcmf_err("BRCMF_C_DOWN error %d\n", err);\r\ngoto exit;\r\n}\r\nbrcmf_fil_iovar_int_set(ifp, "apsta", 0);\r\n}\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1);\r\nif (err < 0) {\r\nbrcmf_err("SET INFRA error %d\n", err);\r\ngoto exit;\r\n}\r\nif (dev_role == NL80211_IFTYPE_AP) {\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1);\r\nif (err < 0) {\r\nbrcmf_err("setting AP mode failed %d\n", err);\r\ngoto exit;\r\n}\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1);\r\nif (err < 0) {\r\nbrcmf_err("BRCMF_C_UP error (%d)\n", err);\r\ngoto exit;\r\n}\r\nmemset(&join_params, 0, sizeof(join_params));\r\nmemcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le));\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\r\n&join_params, sizeof(join_params));\r\nif (err < 0) {\r\nbrcmf_err("SET SSID error (%d)\n", err);\r\ngoto exit;\r\n}\r\nbrcmf_dbg(TRACE, "AP mode configuration complete\n");\r\n} else {\r\nerr = brcmf_fil_bsscfg_data_set(ifp, "ssid", &ssid_le,\r\nsizeof(ssid_le));\r\nif (err < 0) {\r\nbrcmf_err("setting ssid failed %d\n", err);\r\ngoto exit;\r\n}\r\nbss_enable.bsscfg_idx = cpu_to_le32(ifp->bssidx);\r\nbss_enable.enable = cpu_to_le32(1);\r\nerr = brcmf_fil_iovar_data_set(ifp, "bss", &bss_enable,\r\nsizeof(bss_enable));\r\nif (err < 0) {\r\nbrcmf_err("bss_enable config failed %d\n", err);\r\ngoto exit;\r\n}\r\nbrcmf_dbg(TRACE, "GO mode configuration complete\n");\r\n}\r\nclear_bit(BRCMF_VIF_STATUS_AP_CREATING, &ifp->vif->sme_state);\r\nset_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\r\nexit:\r\nif (err) {\r\nbrcmf_set_mpc(ifp, 1);\r\nbrcmf_configure_arp_offload(ifp, true);\r\n}\r\nreturn err;\r\n}\r\nstatic int brcmf_cfg80211_stop_ap(struct wiphy *wiphy, struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\ns32 err;\r\nstruct brcmf_fil_bss_enable_le bss_enable;\r\nstruct brcmf_join_params join_params;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (ifp->vif->wdev.iftype == NL80211_IFTYPE_AP) {\r\nmsleep(400);\r\nmemset(&join_params, 0, sizeof(join_params));\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID,\r\n&join_params, sizeof(join_params));\r\nif (err < 0)\r\nbrcmf_err("SET SSID error (%d)\n", err);\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 0);\r\nif (err < 0)\r\nbrcmf_err("BRCMF_C_UP error %d\n", err);\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 0);\r\nif (err < 0)\r\nbrcmf_err("setting AP mode failed %d\n", err);\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 0);\r\nif (err < 0)\r\nbrcmf_err("setting INFRA mode failed %d\n", err);\r\n} else {\r\nbss_enable.bsscfg_idx = cpu_to_le32(ifp->bssidx);\r\nbss_enable.enable = cpu_to_le32(0);\r\nerr = brcmf_fil_iovar_data_set(ifp, "bss", &bss_enable,\r\nsizeof(bss_enable));\r\nif (err < 0)\r\nbrcmf_err("bss_enable config failed %d\n", err);\r\n}\r\nbrcmf_set_mpc(ifp, 1);\r\nbrcmf_configure_arp_offload(ifp, true);\r\nset_bit(BRCMF_VIF_STATUS_AP_CREATING, &ifp->vif->sme_state);\r\nclear_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_cfg80211_change_beacon(struct wiphy *wiphy, struct net_device *ndev,\r\nstruct cfg80211_beacon_data *info)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\ns32 err;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nerr = brcmf_config_ap_mgmt_ie(ifp->vif, info);\r\nreturn err;\r\n}\r\nstatic int\r\nbrcmf_cfg80211_del_station(struct wiphy *wiphy, struct net_device *ndev,\r\nu8 *mac)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_scb_val_le scbval;\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\ns32 err;\r\nif (!mac)\r\nreturn -EFAULT;\r\nbrcmf_dbg(TRACE, "Enter %pM\n", mac);\r\nif (ifp->vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif)\r\nifp = cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif->ifp;\r\nif (!check_vif_up(ifp->vif))\r\nreturn -EIO;\r\nmemcpy(&scbval.ea, mac, ETH_ALEN);\r\nscbval.val = cpu_to_le32(WLAN_REASON_DEAUTH_LEAVING);\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SCB_DEAUTHENTICATE_FOR_REASON,\r\n&scbval, sizeof(scbval));\r\nif (err)\r\nbrcmf_err("SCB_DEAUTHENTICATE_FOR_REASON failed %d\n", err);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic void\r\nbrcmf_cfg80211_mgmt_frame_register(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nu16 frame_type, bool reg)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nu16 mgmt_type;\r\nbrcmf_dbg(TRACE, "Enter, frame_type %04x, reg=%d\n", frame_type, reg);\r\nmgmt_type = (frame_type & IEEE80211_FCTL_STYPE) >> 4;\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nif (reg)\r\nvif->mgmt_rx_reg |= BIT(mgmt_type);\r\nelse\r\nvif->mgmt_rx_reg &= ~BIT(mgmt_type);\r\n}\r\nstatic int\r\nbrcmf_cfg80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,\r\nstruct ieee80211_channel *chan, bool offchan,\r\nunsigned int wait, const u8 *buf, size_t len,\r\nbool no_cck, bool dont_wait_for_ack, u64 *cookie)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nconst struct ieee80211_mgmt *mgmt;\r\nstruct brcmf_cfg80211_vif *vif;\r\ns32 err = 0;\r\ns32 ie_offset;\r\ns32 ie_len;\r\nstruct brcmf_fil_action_frame_le *action_frame;\r\nstruct brcmf_fil_af_params_le *af_params;\r\nbool ack;\r\ns32 chan_nr;\r\nu32 freq;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\n*cookie = 0;\r\nmgmt = (const struct ieee80211_mgmt *)buf;\r\nif (!ieee80211_is_mgmt(mgmt->frame_control)) {\r\nbrcmf_err("Driver only allows MGMT packet type\n");\r\nreturn -EPERM;\r\n}\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nif (ieee80211_is_probe_resp(mgmt->frame_control)) {\r\nie_offset = DOT11_MGMT_HDR_LEN +\r\nDOT11_BCN_PRB_FIXED_LEN;\r\nie_len = len - ie_offset;\r\nif (vif == cfg->p2p.bss_idx[P2PAPI_BSSCFG_PRIMARY].vif)\r\nvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nerr = brcmf_vif_set_mgmt_ie(vif,\r\nBRCMF_VNDR_IE_PRBRSP_FLAG,\r\n&buf[ie_offset],\r\nie_len);\r\ncfg80211_mgmt_tx_status(wdev, *cookie, buf, len, true,\r\nGFP_KERNEL);\r\n} else if (ieee80211_is_action(mgmt->frame_control)) {\r\naf_params = kzalloc(sizeof(*af_params), GFP_KERNEL);\r\nif (af_params == NULL) {\r\nbrcmf_err("unable to allocate frame\n");\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\naction_frame = &af_params->action_frame;\r\naction_frame->packet_id = cpu_to_le32(*cookie);\r\nmemcpy(&action_frame->da[0], &mgmt->da[0], ETH_ALEN);\r\nmemcpy(&af_params->bssid[0], &mgmt->bssid[0], ETH_ALEN);\r\naction_frame->len = cpu_to_le16(len - DOT11_MGMT_HDR_LEN);\r\nif (chan)\r\nfreq = chan->center_freq;\r\nelse\r\nbrcmf_fil_cmd_int_get(vif->ifp, BRCMF_C_GET_CHANNEL,\r\n&freq);\r\nchan_nr = ieee80211_frequency_to_channel(freq);\r\naf_params->channel = cpu_to_le32(chan_nr);\r\nmemcpy(action_frame->data, &buf[DOT11_MGMT_HDR_LEN],\r\nle16_to_cpu(action_frame->len));\r\nbrcmf_dbg(TRACE, "Action frame, cookie=%lld, len=%d, freq=%d\n",\r\n*cookie, le16_to_cpu(action_frame->len), freq);\r\nack = brcmf_p2p_send_action_frame(cfg, cfg_to_ndev(cfg),\r\naf_params);\r\ncfg80211_mgmt_tx_status(wdev, *cookie, buf, len, ack,\r\nGFP_KERNEL);\r\nkfree(af_params);\r\n} else {\r\nbrcmf_dbg(TRACE, "Unhandled, fc=%04x!!\n", mgmt->frame_control);\r\nbrcmf_dbg_hex_dump(true, buf, len, "payload, len=%Zu\n", len);\r\n}\r\nexit:\r\nreturn err;\r\n}\r\nstatic int\r\nbrcmf_cfg80211_cancel_remain_on_channel(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nu64 cookie)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_cfg80211_vif *vif;\r\nint err = 0;\r\nbrcmf_dbg(TRACE, "Enter p2p listen cancel\n");\r\nvif = cfg->p2p.bss_idx[P2PAPI_BSSCFG_DEVICE].vif;\r\nif (vif == NULL) {\r\nbrcmf_err("No p2p device available for probe response\n");\r\nerr = -ENODEV;\r\ngoto exit;\r\n}\r\nbrcmf_p2p_cancel_remain_on_channel(vif->ifp);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int brcmf_cfg80211_crit_proto_start(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev,\r\nenum nl80211_crit_proto_id proto,\r\nu16 duration)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_cfg80211_vif *vif;\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nif (proto != NL80211_CRIT_PROTO_DHCP)\r\nreturn -EINVAL;\r\nset_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\r\nbrcmf_abort_scanning(cfg);\r\nreturn brcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_DISABLED, duration);\r\n}\r\nstatic void brcmf_cfg80211_crit_proto_stop(struct wiphy *wiphy,\r\nstruct wireless_dev *wdev)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);\r\nstruct brcmf_cfg80211_vif *vif;\r\nvif = container_of(wdev, struct brcmf_cfg80211_vif, wdev);\r\nbrcmf_btcoex_set_mode(vif, BRCMF_BTCOEX_ENABLED, 0);\r\nclear_bit(BRCMF_SCAN_STATUS_SUPPRESS, &cfg->scan_status);\r\n}\r\nstatic int brcmf_convert_nl80211_tdls_oper(enum nl80211_tdls_operation oper)\r\n{\r\nint ret;\r\nswitch (oper) {\r\ncase NL80211_TDLS_DISCOVERY_REQ:\r\nret = BRCMF_TDLS_MANUAL_EP_DISCOVERY;\r\nbreak;\r\ncase NL80211_TDLS_SETUP:\r\nret = BRCMF_TDLS_MANUAL_EP_CREATE;\r\nbreak;\r\ncase NL80211_TDLS_TEARDOWN:\r\nret = BRCMF_TDLS_MANUAL_EP_DELETE;\r\nbreak;\r\ndefault:\r\nbrcmf_err("unsupported operation: %d\n", oper);\r\nret = -EOPNOTSUPP;\r\n}\r\nreturn ret;\r\n}\r\nstatic int brcmf_cfg80211_tdls_oper(struct wiphy *wiphy,\r\nstruct net_device *ndev, u8 *peer,\r\nenum nl80211_tdls_operation oper)\r\n{\r\nstruct brcmf_if *ifp;\r\nstruct brcmf_tdls_iovar_le info;\r\nint ret = 0;\r\nret = brcmf_convert_nl80211_tdls_oper(oper);\r\nif (ret < 0)\r\nreturn ret;\r\nifp = netdev_priv(ndev);\r\nmemset(&info, 0, sizeof(info));\r\ninfo.mode = (u8)ret;\r\nif (peer)\r\nmemcpy(info.ea, peer, ETH_ALEN);\r\nret = brcmf_fil_iovar_data_set(ifp, "tdls_endpoint",\r\n&info, sizeof(info));\r\nif (ret < 0)\r\nbrcmf_err("tdls_endpoint iovar failed: ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic s32 brcmf_nl80211_iftype_to_mode(enum nl80211_iftype type)\r\n{\r\nswitch (type) {\r\ncase NL80211_IFTYPE_AP_VLAN:\r\ncase NL80211_IFTYPE_WDS:\r\ncase NL80211_IFTYPE_MONITOR:\r\ncase NL80211_IFTYPE_MESH_POINT:\r\nreturn -ENOTSUPP;\r\ncase NL80211_IFTYPE_ADHOC:\r\nreturn WL_MODE_IBSS;\r\ncase NL80211_IFTYPE_STATION:\r\ncase NL80211_IFTYPE_P2P_CLIENT:\r\nreturn WL_MODE_BSS;\r\ncase NL80211_IFTYPE_AP:\r\ncase NL80211_IFTYPE_P2P_GO:\r\nreturn WL_MODE_AP;\r\ncase NL80211_IFTYPE_P2P_DEVICE:\r\nreturn WL_MODE_P2P;\r\ncase NL80211_IFTYPE_UNSPECIFIED:\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void brcmf_wiphy_pno_params(struct wiphy *wiphy)\r\n{\r\nwiphy->max_sched_scan_ssids = BRCMF_PNO_MAX_PFN_COUNT;\r\nwiphy->max_match_sets = BRCMF_PNO_MAX_PFN_COUNT;\r\nwiphy->max_sched_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\r\nwiphy->flags |= WIPHY_FLAG_SUPPORTS_SCHED_SCAN;\r\n}\r\nstatic struct wiphy *brcmf_setup_wiphy(struct device *phydev)\r\n{\r\nstruct wiphy *wiphy;\r\ns32 err = 0;\r\nwiphy = wiphy_new(&wl_cfg80211_ops, sizeof(struct brcmf_cfg80211_info));\r\nif (!wiphy) {\r\nbrcmf_err("Could not allocate wiphy device\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nset_wiphy_dev(wiphy, phydev);\r\nwiphy->max_scan_ssids = WL_NUM_SCAN_MAX;\r\nwiphy->max_scan_ie_len = BRCMF_SCAN_IE_LEN_MAX;\r\nwiphy->max_num_pmkids = WL_NUM_PMKIDS_MAX;\r\nwiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |\r\nBIT(NL80211_IFTYPE_ADHOC) |\r\nBIT(NL80211_IFTYPE_AP) |\r\nBIT(NL80211_IFTYPE_P2P_CLIENT) |\r\nBIT(NL80211_IFTYPE_P2P_GO) |\r\nBIT(NL80211_IFTYPE_P2P_DEVICE);\r\nwiphy->iface_combinations = brcmf_iface_combos;\r\nwiphy->n_iface_combinations = ARRAY_SIZE(brcmf_iface_combos);\r\nwiphy->bands[IEEE80211_BAND_2GHZ] = &__wl_band_2ghz;\r\nwiphy->signal_type = CFG80211_SIGNAL_TYPE_MBM;\r\nwiphy->cipher_suites = __wl_cipher_suites;\r\nwiphy->n_cipher_suites = ARRAY_SIZE(__wl_cipher_suites);\r\nwiphy->flags |= WIPHY_FLAG_PS_ON_BY_DEFAULT |\r\nWIPHY_FLAG_OFFCHAN_TX |\r\nWIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |\r\nWIPHY_FLAG_SUPPORTS_TDLS;\r\nwiphy->mgmt_stypes = brcmf_txrx_stypes;\r\nwiphy->max_remain_on_channel_duration = 5000;\r\nbrcmf_wiphy_pno_params(wiphy);\r\nbrcmf_dbg(INFO, "Registering custom regulatory\n");\r\nwiphy->flags |= WIPHY_FLAG_CUSTOM_REGULATORY;\r\nwiphy_apply_custom_regulatory(wiphy, &brcmf_regdom);\r\nerr = wiphy_register(wiphy);\r\nif (err < 0) {\r\nbrcmf_err("Could not register wiphy device (%d)\n", err);\r\nwiphy_free(wiphy);\r\nreturn ERR_PTR(err);\r\n}\r\nreturn wiphy;\r\n}\r\nstruct brcmf_cfg80211_vif *brcmf_alloc_vif(struct brcmf_cfg80211_info *cfg,\r\nenum nl80211_iftype type,\r\nbool pm_block)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nif (cfg->vif_cnt == BRCMF_IFACE_MAX_CNT)\r\nreturn ERR_PTR(-ENOSPC);\r\nbrcmf_dbg(TRACE, "allocating virtual interface (size=%zu)\n",\r\nsizeof(*vif));\r\nvif = kzalloc(sizeof(*vif), GFP_KERNEL);\r\nif (!vif)\r\nreturn ERR_PTR(-ENOMEM);\r\nvif->wdev.wiphy = cfg->wiphy;\r\nvif->wdev.iftype = type;\r\nvif->mode = brcmf_nl80211_iftype_to_mode(type);\r\nvif->pm_block = pm_block;\r\nvif->roam_off = -1;\r\nbrcmf_init_prof(&vif->profile);\r\nlist_add_tail(&vif->list, &cfg->vif_list);\r\ncfg->vif_cnt++;\r\nreturn vif;\r\n}\r\nvoid brcmf_free_vif(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_cfg80211_vif *vif)\r\n{\r\nlist_del(&vif->list);\r\ncfg->vif_cnt--;\r\nkfree(vif);\r\nif (!cfg->vif_cnt) {\r\nwiphy_unregister(cfg->wiphy);\r\nwiphy_free(cfg->wiphy);\r\n}\r\n}\r\nstatic bool brcmf_is_linkup(const struct brcmf_event_msg *e)\r\n{\r\nu32 event = e->event_code;\r\nu32 status = e->status;\r\nif (event == BRCMF_E_SET_SSID && status == BRCMF_E_STATUS_SUCCESS) {\r\nbrcmf_dbg(CONN, "Processing set ssid\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool brcmf_is_linkdown(const struct brcmf_event_msg *e)\r\n{\r\nu32 event = e->event_code;\r\nu16 flags = e->flags;\r\nif (event == BRCMF_E_LINK && (!(flags & BRCMF_EVENT_MSG_LINK))) {\r\nbrcmf_dbg(CONN, "Processing link down\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool brcmf_is_nonetwork(struct brcmf_cfg80211_info *cfg,\r\nconst struct brcmf_event_msg *e)\r\n{\r\nu32 event = e->event_code;\r\nu32 status = e->status;\r\nif (event == BRCMF_E_LINK && status == BRCMF_E_STATUS_NO_NETWORKS) {\r\nbrcmf_dbg(CONN, "Processing Link %s & no network found\n",\r\ne->flags & BRCMF_EVENT_MSG_LINK ? "up" : "down");\r\nreturn true;\r\n}\r\nif (event == BRCMF_E_SET_SSID && status != BRCMF_E_STATUS_SUCCESS) {\r\nbrcmf_dbg(CONN, "Processing connecting & no network found\n");\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic void brcmf_clear_assoc_ies(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\r\nkfree(conn_info->req_ie);\r\nconn_info->req_ie = NULL;\r\nconn_info->req_ie_len = 0;\r\nkfree(conn_info->resp_ie);\r\nconn_info->resp_ie = NULL;\r\nconn_info->resp_ie_len = 0;\r\n}\r\nstatic s32 brcmf_get_assoc_ies(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_if *ifp)\r\n{\r\nstruct brcmf_cfg80211_assoc_ielen_le *assoc_info;\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\r\nu32 req_len;\r\nu32 resp_len;\r\ns32 err = 0;\r\nbrcmf_clear_assoc_ies(cfg);\r\nerr = brcmf_fil_iovar_data_get(ifp, "assoc_info",\r\ncfg->extra_buf, WL_ASSOC_INFO_MAX);\r\nif (err) {\r\nbrcmf_err("could not get assoc info (%d)\n", err);\r\nreturn err;\r\n}\r\nassoc_info =\r\n(struct brcmf_cfg80211_assoc_ielen_le *)cfg->extra_buf;\r\nreq_len = le32_to_cpu(assoc_info->req_len);\r\nresp_len = le32_to_cpu(assoc_info->resp_len);\r\nif (req_len) {\r\nerr = brcmf_fil_iovar_data_get(ifp, "assoc_req_ies",\r\ncfg->extra_buf,\r\nWL_ASSOC_INFO_MAX);\r\nif (err) {\r\nbrcmf_err("could not get assoc req (%d)\n", err);\r\nreturn err;\r\n}\r\nconn_info->req_ie_len = req_len;\r\nconn_info->req_ie =\r\nkmemdup(cfg->extra_buf, conn_info->req_ie_len,\r\nGFP_KERNEL);\r\n} else {\r\nconn_info->req_ie_len = 0;\r\nconn_info->req_ie = NULL;\r\n}\r\nif (resp_len) {\r\nerr = brcmf_fil_iovar_data_get(ifp, "assoc_resp_ies",\r\ncfg->extra_buf,\r\nWL_ASSOC_INFO_MAX);\r\nif (err) {\r\nbrcmf_err("could not get assoc resp (%d)\n", err);\r\nreturn err;\r\n}\r\nconn_info->resp_ie_len = resp_len;\r\nconn_info->resp_ie =\r\nkmemdup(cfg->extra_buf, conn_info->resp_ie_len,\r\nGFP_KERNEL);\r\n} else {\r\nconn_info->resp_ie_len = 0;\r\nconn_info->resp_ie = NULL;\r\n}\r\nbrcmf_dbg(CONN, "req len (%d) resp len (%d)\n",\r\nconn_info->req_ie_len, conn_info->resp_ie_len);\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_bss_roaming_done(struct brcmf_cfg80211_info *cfg,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\r\nstruct wiphy *wiphy = cfg_to_wiphy(cfg);\r\nstruct ieee80211_channel *notify_channel = NULL;\r\nstruct ieee80211_supported_band *band;\r\nstruct brcmf_bss_info_le *bi;\r\nstruct brcmu_chan ch;\r\nu32 freq;\r\ns32 err = 0;\r\nu8 *buf;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nbrcmf_get_assoc_ies(cfg, ifp);\r\nmemcpy(profile->bssid, e->addr, ETH_ALEN);\r\nbrcmf_update_bss_info(cfg, ifp);\r\nbuf = kzalloc(WL_BSS_INFO_MAX, GFP_KERNEL);\r\nif (buf == NULL) {\r\nerr = -ENOMEM;\r\ngoto done;\r\n}\r\n*(__le32 *)buf = cpu_to_le32(WL_BSS_INFO_MAX);\r\nerr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BSS_INFO,\r\nbuf, WL_BSS_INFO_MAX);\r\nif (err)\r\ngoto done;\r\nbi = (struct brcmf_bss_info_le *)(buf + 4);\r\nch.chspec = le16_to_cpu(bi->chanspec);\r\ncfg->d11inf.decchspec(&ch);\r\nif (ch.band == BRCMU_CHAN_BAND_2G)\r\nband = wiphy->bands[IEEE80211_BAND_2GHZ];\r\nelse\r\nband = wiphy->bands[IEEE80211_BAND_5GHZ];\r\nfreq = ieee80211_channel_to_frequency(ch.chnum, band->band);\r\nnotify_channel = ieee80211_get_channel(wiphy, freq);\r\ndone:\r\nkfree(buf);\r\ncfg80211_roamed(ndev, notify_channel, (u8 *)profile->bssid,\r\nconn_info->req_ie, conn_info->req_ie_len,\r\nconn_info->resp_ie, conn_info->resp_ie_len, GFP_KERNEL);\r\nbrcmf_dbg(CONN, "Report roaming result\n");\r\nset_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state);\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_bss_connect_done(struct brcmf_cfg80211_info *cfg,\r\nstruct net_device *ndev, const struct brcmf_event_msg *e,\r\nbool completed)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\nstruct brcmf_cfg80211_connect_info *conn_info = cfg_to_conn(cfg);\r\ns32 err = 0;\r\nbrcmf_dbg(TRACE, "Enter\n");\r\nif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTING,\r\n&ifp->vif->sme_state)) {\r\nif (completed) {\r\nbrcmf_get_assoc_ies(cfg, ifp);\r\nmemcpy(profile->bssid, e->addr, ETH_ALEN);\r\nbrcmf_update_bss_info(cfg, ifp);\r\nset_bit(BRCMF_VIF_STATUS_CONNECTED,\r\n&ifp->vif->sme_state);\r\n}\r\ncfg80211_connect_result(ndev,\r\n(u8 *)profile->bssid,\r\nconn_info->req_ie,\r\nconn_info->req_ie_len,\r\nconn_info->resp_ie,\r\nconn_info->resp_ie_len,\r\ncompleted ? WLAN_STATUS_SUCCESS :\r\nWLAN_STATUS_AUTH_TIMEOUT,\r\nGFP_KERNEL);\r\nbrcmf_dbg(CONN, "Report connect result - connection %s\n",\r\ncompleted ? "succeeded" : "failed");\r\n}\r\nbrcmf_dbg(TRACE, "Exit\n");\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_connect_status_ap(struct brcmf_cfg80211_info *cfg,\r\nstruct net_device *ndev,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstatic int generation;\r\nu32 event = e->event_code;\r\nu32 reason = e->reason;\r\nstruct station_info sinfo;\r\nbrcmf_dbg(CONN, "event %d, reason %d\n", event, reason);\r\nif (event == BRCMF_E_LINK && reason == BRCMF_E_REASON_LINK_BSSCFG_DIS &&\r\nndev != cfg_to_ndev(cfg)) {\r\nbrcmf_dbg(CONN, "AP mode link down\n");\r\ncomplete(&cfg->vif_disabled);\r\nreturn 0;\r\n}\r\nif (((event == BRCMF_E_ASSOC_IND) || (event == BRCMF_E_REASSOC_IND)) &&\r\n(reason == BRCMF_E_STATUS_SUCCESS)) {\r\nmemset(&sinfo, 0, sizeof(sinfo));\r\nsinfo.filled = STATION_INFO_ASSOC_REQ_IES;\r\nif (!data) {\r\nbrcmf_err("No IEs present in ASSOC/REASSOC_IND");\r\nreturn -EINVAL;\r\n}\r\nsinfo.assoc_req_ies = data;\r\nsinfo.assoc_req_ies_len = e->datalen;\r\ngeneration++;\r\nsinfo.generation = generation;\r\ncfg80211_new_sta(ndev, e->addr, &sinfo, GFP_KERNEL);\r\n} else if ((event == BRCMF_E_DISASSOC_IND) ||\r\n(event == BRCMF_E_DEAUTH_IND) ||\r\n(event == BRCMF_E_DEAUTH)) {\r\ncfg80211_del_sta(ndev, e->addr, GFP_KERNEL);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32\r\nbrcmf_notify_connect_status(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct net_device *ndev = ifp->ndev;\r\nstruct brcmf_cfg80211_profile *profile = &ifp->vif->profile;\r\ns32 err = 0;\r\nif (ifp->vif->mode == WL_MODE_AP) {\r\nerr = brcmf_notify_connect_status_ap(cfg, ndev, e, data);\r\n} else if (brcmf_is_linkup(e)) {\r\nbrcmf_dbg(CONN, "Linkup\n");\r\nif (brcmf_is_ibssmode(ifp->vif)) {\r\nmemcpy(profile->bssid, e->addr, ETH_ALEN);\r\nwl_inform_ibss(cfg, ndev, e->addr);\r\ncfg80211_ibss_joined(ndev, e->addr, GFP_KERNEL);\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTING,\r\n&ifp->vif->sme_state);\r\nset_bit(BRCMF_VIF_STATUS_CONNECTED,\r\n&ifp->vif->sme_state);\r\n} else\r\nbrcmf_bss_connect_done(cfg, ndev, e, true);\r\n} else if (brcmf_is_linkdown(e)) {\r\nbrcmf_dbg(CONN, "Linkdown\n");\r\nif (!brcmf_is_ibssmode(ifp->vif)) {\r\nbrcmf_bss_connect_done(cfg, ndev, e, false);\r\nif (test_and_clear_bit(BRCMF_VIF_STATUS_CONNECTED,\r\n&ifp->vif->sme_state))\r\ncfg80211_disconnected(ndev, 0, NULL, 0,\r\nGFP_KERNEL);\r\n}\r\nbrcmf_link_down(ifp->vif);\r\nbrcmf_init_prof(ndev_to_prof(ndev));\r\nif (ndev != cfg_to_ndev(cfg))\r\ncomplete(&cfg->vif_disabled);\r\n} else if (brcmf_is_nonetwork(cfg, e)) {\r\nif (brcmf_is_ibssmode(ifp->vif))\r\nclear_bit(BRCMF_VIF_STATUS_CONNECTING,\r\n&ifp->vif->sme_state);\r\nelse\r\nbrcmf_bss_connect_done(cfg, ndev, e, false);\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_roaming_status(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\ns32 err = 0;\r\nu32 event = e->event_code;\r\nu32 status = e->status;\r\nif (event == BRCMF_E_ROAM && status == BRCMF_E_STATUS_SUCCESS) {\r\nif (test_bit(BRCMF_VIF_STATUS_CONNECTED, &ifp->vif->sme_state))\r\nbrcmf_bss_roaming_done(cfg, ifp->ndev, e);\r\nelse\r\nbrcmf_bss_connect_done(cfg, ifp->ndev, e, true);\r\n}\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_notify_mic_status(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nu16 flags = e->flags;\r\nenum nl80211_key_type key_type;\r\nif (flags & BRCMF_EVENT_MSG_GROUP)\r\nkey_type = NL80211_KEYTYPE_GROUP;\r\nelse\r\nkey_type = NL80211_KEYTYPE_PAIRWISE;\r\ncfg80211_michael_mic_failure(ifp->ndev, (u8 *)&e->addr, key_type, -1,\r\nNULL, GFP_KERNEL);\r\nreturn 0;\r\n}\r\nstatic s32 brcmf_notify_vif_event(struct brcmf_if *ifp,\r\nconst struct brcmf_event_msg *e, void *data)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nstruct brcmf_if_event *ifevent = (struct brcmf_if_event *)data;\r\nstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\r\nstruct brcmf_cfg80211_vif *vif;\r\nbrcmf_dbg(TRACE, "Enter: action %u flags %u ifidx %u bsscfg %u\n",\r\nifevent->action, ifevent->flags, ifevent->ifidx,\r\nifevent->bssidx);\r\nmutex_lock(&event->vif_event_lock);\r\nevent->action = ifevent->action;\r\nvif = event->vif;\r\nswitch (ifevent->action) {\r\ncase BRCMF_E_IF_ADD:\r\nif (!cfg->vif_event.vif) {\r\nmutex_unlock(&event->vif_event_lock);\r\nreturn -EBADF;\r\n}\r\nifp->vif = vif;\r\nvif->ifp = ifp;\r\nif (ifp->ndev) {\r\nvif->wdev.netdev = ifp->ndev;\r\nifp->ndev->ieee80211_ptr = &vif->wdev;\r\nSET_NETDEV_DEV(ifp->ndev, wiphy_dev(cfg->wiphy));\r\n}\r\nmutex_unlock(&event->vif_event_lock);\r\nwake_up(&event->vif_wq);\r\nreturn 0;\r\ncase BRCMF_E_IF_DEL:\r\nmutex_unlock(&event->vif_event_lock);\r\nif (brcmf_cfg80211_vif_event_armed(cfg))\r\nwake_up(&event->vif_wq);\r\nreturn 0;\r\ncase BRCMF_E_IF_CHANGE:\r\nmutex_unlock(&event->vif_event_lock);\r\nwake_up(&event->vif_wq);\r\nreturn 0;\r\ndefault:\r\nmutex_unlock(&event->vif_event_lock);\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void brcmf_init_conf(struct brcmf_cfg80211_conf *conf)\r\n{\r\nconf->frag_threshold = (u32)-1;\r\nconf->rts_threshold = (u32)-1;\r\nconf->retry_short = (u32)-1;\r\nconf->retry_long = (u32)-1;\r\nconf->tx_power = -1;\r\n}\r\nstatic void brcmf_register_event_handlers(struct brcmf_cfg80211_info *cfg)\r\n{\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_LINK,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH_IND,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_DEAUTH,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_DISASSOC_IND,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_ASSOC_IND,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_REASSOC_IND,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_ROAM,\r\nbrcmf_notify_roaming_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_MIC_ERROR,\r\nbrcmf_notify_mic_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_SET_SSID,\r\nbrcmf_notify_connect_status);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_PFN_NET_FOUND,\r\nbrcmf_notify_sched_scan_results);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_IF,\r\nbrcmf_notify_vif_event);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_PROBEREQ_MSG,\r\nbrcmf_p2p_notify_rx_mgmt_p2p_probereq);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_P2P_DISC_LISTEN_COMPLETE,\r\nbrcmf_p2p_notify_listen_complete);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_RX,\r\nbrcmf_p2p_notify_action_frame_rx);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_COMPLETE,\r\nbrcmf_p2p_notify_action_tx_complete);\r\nbrcmf_fweh_register(cfg->pub, BRCMF_E_ACTION_FRAME_OFF_CHAN_COMPLETE,\r\nbrcmf_p2p_notify_action_tx_complete);\r\n}\r\nstatic void brcmf_deinit_priv_mem(struct brcmf_cfg80211_info *cfg)\r\n{\r\nkfree(cfg->conf);\r\ncfg->conf = NULL;\r\nkfree(cfg->escan_ioctl_buf);\r\ncfg->escan_ioctl_buf = NULL;\r\nkfree(cfg->extra_buf);\r\ncfg->extra_buf = NULL;\r\nkfree(cfg->pmk_list);\r\ncfg->pmk_list = NULL;\r\n}\r\nstatic s32 brcmf_init_priv_mem(struct brcmf_cfg80211_info *cfg)\r\n{\r\ncfg->conf = kzalloc(sizeof(*cfg->conf), GFP_KERNEL);\r\nif (!cfg->conf)\r\ngoto init_priv_mem_out;\r\ncfg->escan_ioctl_buf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\r\nif (!cfg->escan_ioctl_buf)\r\ngoto init_priv_mem_out;\r\ncfg->extra_buf = kzalloc(WL_EXTRA_BUF_MAX, GFP_KERNEL);\r\nif (!cfg->extra_buf)\r\ngoto init_priv_mem_out;\r\ncfg->pmk_list = kzalloc(sizeof(*cfg->pmk_list), GFP_KERNEL);\r\nif (!cfg->pmk_list)\r\ngoto init_priv_mem_out;\r\nreturn 0;\r\ninit_priv_mem_out:\r\nbrcmf_deinit_priv_mem(cfg);\r\nreturn -ENOMEM;\r\n}\r\nstatic s32 wl_init_priv(struct brcmf_cfg80211_info *cfg)\r\n{\r\ns32 err = 0;\r\ncfg->scan_request = NULL;\r\ncfg->pwr_save = true;\r\ncfg->roam_on = true;\r\ncfg->active_scan = true;\r\ncfg->dongle_up = false;\r\nerr = brcmf_init_priv_mem(cfg);\r\nif (err)\r\nreturn err;\r\nbrcmf_register_event_handlers(cfg);\r\nmutex_init(&cfg->usr_sync);\r\nbrcmf_init_escan(cfg);\r\nbrcmf_init_conf(cfg->conf);\r\ninit_completion(&cfg->vif_disabled);\r\nreturn err;\r\n}\r\nstatic void wl_deinit_priv(struct brcmf_cfg80211_info *cfg)\r\n{\r\ncfg->dongle_up = false;\r\nbrcmf_abort_scanning(cfg);\r\nbrcmf_deinit_priv_mem(cfg);\r\n}\r\nstatic void init_vif_event(struct brcmf_cfg80211_vif_event *event)\r\n{\r\ninit_waitqueue_head(&event->vif_wq);\r\nmutex_init(&event->vif_event_lock);\r\n}\r\nstruct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,\r\nstruct device *busdev)\r\n{\r\nstruct net_device *ndev = drvr->iflist[0]->ndev;\r\nstruct brcmf_cfg80211_info *cfg;\r\nstruct wiphy *wiphy;\r\nstruct brcmf_cfg80211_vif *vif;\r\nstruct brcmf_if *ifp;\r\ns32 err = 0;\r\ns32 io_type;\r\nif (!ndev) {\r\nbrcmf_err("ndev is invalid\n");\r\nreturn NULL;\r\n}\r\nifp = netdev_priv(ndev);\r\nwiphy = brcmf_setup_wiphy(busdev);\r\nif (IS_ERR(wiphy))\r\nreturn NULL;\r\ncfg = wiphy_priv(wiphy);\r\ncfg->wiphy = wiphy;\r\ncfg->pub = drvr;\r\ninit_vif_event(&cfg->vif_event);\r\nINIT_LIST_HEAD(&cfg->vif_list);\r\nvif = brcmf_alloc_vif(cfg, NL80211_IFTYPE_STATION, false);\r\nif (IS_ERR(vif)) {\r\nwiphy_free(wiphy);\r\nreturn NULL;\r\n}\r\nvif->ifp = ifp;\r\nvif->wdev.netdev = ndev;\r\nndev->ieee80211_ptr = &vif->wdev;\r\nSET_NETDEV_DEV(ndev, wiphy_dev(cfg->wiphy));\r\nerr = wl_init_priv(cfg);\r\nif (err) {\r\nbrcmf_err("Failed to init iwm_priv (%d)\n", err);\r\ngoto cfg80211_attach_out;\r\n}\r\nifp->vif = vif;\r\nerr = brcmf_p2p_attach(cfg);\r\nif (err) {\r\nbrcmf_err("P2P initilisation failed (%d)\n", err);\r\ngoto cfg80211_p2p_attach_out;\r\n}\r\nerr = brcmf_btcoex_attach(cfg);\r\nif (err) {\r\nbrcmf_err("BT-coex initialisation failed (%d)\n", err);\r\nbrcmf_p2p_detach(&cfg->p2p);\r\ngoto cfg80211_p2p_attach_out;\r\n}\r\nerr = brcmf_fil_iovar_int_set(ifp, "tdls_enable", 1);\r\nif (err) {\r\nbrcmf_dbg(INFO, "TDLS not enabled (%d)\n", err);\r\nwiphy->flags &= ~WIPHY_FLAG_SUPPORTS_TDLS;\r\n}\r\nerr = brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_VERSION,\r\n&io_type);\r\nif (err) {\r\nbrcmf_err("Failed to get D11 version (%d)\n", err);\r\ngoto cfg80211_p2p_attach_out;\r\n}\r\ncfg->d11inf.io_type = (u8)io_type;\r\nbrcmu_d11_attach(&cfg->d11inf);\r\nreturn cfg;\r\ncfg80211_p2p_attach_out:\r\nwl_deinit_priv(cfg);\r\ncfg80211_attach_out:\r\nbrcmf_free_vif(cfg, vif);\r\nreturn NULL;\r\n}\r\nvoid brcmf_cfg80211_detach(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nstruct brcmf_cfg80211_vif *tmp;\r\nwl_deinit_priv(cfg);\r\nbrcmf_btcoex_detach(cfg);\r\nlist_for_each_entry_safe(vif, tmp, &cfg->vif_list, list) {\r\nbrcmf_free_vif(cfg, vif);\r\n}\r\n}\r\nstatic s32\r\nbrcmf_dongle_roam(struct brcmf_if *ifp, u32 roamvar, u32 bcn_timeout)\r\n{\r\ns32 err = 0;\r\n__le32 roamtrigger[2];\r\n__le32 roam_delta[2];\r\nif (roamvar) {\r\nerr = brcmf_fil_iovar_int_set(ifp, "bcn_timeout", bcn_timeout);\r\nif (err) {\r\nbrcmf_err("bcn_timeout error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\n}\r\nbrcmf_dbg(INFO, "Internal Roaming = %s\n", roamvar ? "Off" : "On");\r\nerr = brcmf_fil_iovar_int_set(ifp, "roam_off", roamvar);\r\nif (err) {\r\nbrcmf_err("roam_off error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\nroamtrigger[0] = cpu_to_le32(WL_ROAM_TRIGGER_LEVEL);\r\nroamtrigger[1] = cpu_to_le32(BRCM_BAND_ALL);\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_TRIGGER,\r\n(void *)roamtrigger, sizeof(roamtrigger));\r\nif (err) {\r\nbrcmf_err("WLC_SET_ROAM_TRIGGER error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\nroam_delta[0] = cpu_to_le32(WL_ROAM_DELTA);\r\nroam_delta[1] = cpu_to_le32(BRCM_BAND_ALL);\r\nerr = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_ROAM_DELTA,\r\n(void *)roam_delta, sizeof(roam_delta));\r\nif (err) {\r\nbrcmf_err("WLC_SET_ROAM_DELTA error (%d)\n", err);\r\ngoto dongle_rom_out;\r\n}\r\ndongle_rom_out:\r\nreturn err;\r\n}\r\nstatic s32\r\nbrcmf_dongle_scantime(struct brcmf_if *ifp, s32 scan_assoc_time,\r\ns32 scan_unassoc_time, s32 scan_passive_time)\r\n{\r\ns32 err = 0;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\r\nscan_assoc_time);\r\nif (err) {\r\nif (err == -EOPNOTSUPP)\r\nbrcmf_dbg(INFO, "Scan assoc time is not supported\n");\r\nelse\r\nbrcmf_err("Scan assoc time error (%d)\n", err);\r\ngoto dongle_scantime_out;\r\n}\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\r\nscan_unassoc_time);\r\nif (err) {\r\nif (err == -EOPNOTSUPP)\r\nbrcmf_dbg(INFO, "Scan unassoc time is not supported\n");\r\nelse\r\nbrcmf_err("Scan unassoc time error (%d)\n", err);\r\ngoto dongle_scantime_out;\r\n}\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,\r\nscan_passive_time);\r\nif (err) {\r\nif (err == -EOPNOTSUPP)\r\nbrcmf_dbg(INFO, "Scan passive time is not supported\n");\r\nelse\r\nbrcmf_err("Scan passive time error (%d)\n", err);\r\ngoto dongle_scantime_out;\r\n}\r\ndongle_scantime_out:\r\nreturn err;\r\n}\r\nstatic s32 brcmf_construct_reginfo(struct brcmf_cfg80211_info *cfg, u32 bw_cap)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\r\nstruct ieee80211_channel *band_chan_arr;\r\nstruct brcmf_chanspec_list *list;\r\nstruct brcmu_chan ch;\r\ns32 err;\r\nu8 *pbuf;\r\nu32 i, j;\r\nu32 total;\r\nenum ieee80211_band band;\r\nu32 channel;\r\nu32 *n_cnt;\r\nbool ht40_allowed;\r\nu32 index;\r\nu32 ht40_flag;\r\nbool update;\r\nu32 array_size;\r\npbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);\r\nif (pbuf == NULL)\r\nreturn -ENOMEM;\r\nlist = (struct brcmf_chanspec_list *)pbuf;\r\nerr = brcmf_fil_iovar_data_get(ifp, "chanspecs", pbuf,\r\nBRCMF_DCMD_MEDLEN);\r\nif (err) {\r\nbrcmf_err("get chanspecs error (%d)\n", err);\r\ngoto exit;\r\n}\r\n__wl_band_2ghz.n_channels = 0;\r\n__wl_band_5ghz_a.n_channels = 0;\r\ntotal = le32_to_cpu(list->count);\r\nfor (i = 0; i < total; i++) {\r\nch.chspec = (u16)le32_to_cpu(list->element[i]);\r\ncfg->d11inf.decchspec(&ch);\r\nif (ch.band == BRCMU_CHAN_BAND_2G) {\r\nband_chan_arr = __wl_2ghz_channels;\r\narray_size = ARRAY_SIZE(__wl_2ghz_channels);\r\nn_cnt = &__wl_band_2ghz.n_channels;\r\nband = IEEE80211_BAND_2GHZ;\r\nht40_allowed = (bw_cap == WLC_N_BW_40ALL);\r\n} else if (ch.band == BRCMU_CHAN_BAND_5G) {\r\nband_chan_arr = __wl_5ghz_a_channels;\r\narray_size = ARRAY_SIZE(__wl_5ghz_a_channels);\r\nn_cnt = &__wl_band_5ghz_a.n_channels;\r\nband = IEEE80211_BAND_5GHZ;\r\nht40_allowed = !(bw_cap == WLC_N_BW_20ALL);\r\n} else {\r\nbrcmf_err("Invalid channel Sepc. 0x%x.\n", ch.chspec);\r\ncontinue;\r\n}\r\nif (!ht40_allowed && ch.bw == BRCMU_CHAN_BW_40)\r\ncontinue;\r\nupdate = false;\r\nfor (j = 0; (j < *n_cnt && (*n_cnt < array_size)); j++) {\r\nif (band_chan_arr[j].hw_value == ch.chnum) {\r\nupdate = true;\r\nbreak;\r\n}\r\n}\r\nif (update)\r\nindex = j;\r\nelse\r\nindex = *n_cnt;\r\nif (index < array_size) {\r\nband_chan_arr[index].center_freq =\r\nieee80211_channel_to_frequency(ch.chnum, band);\r\nband_chan_arr[index].hw_value = ch.chnum;\r\nif (ch.bw == BRCMU_CHAN_BW_40 && ht40_allowed) {\r\nht40_flag = band_chan_arr[index].flags &\r\nIEEE80211_CHAN_NO_HT40;\r\nif (ch.sb == BRCMU_CHAN_SB_U) {\r\nif (ht40_flag == IEEE80211_CHAN_NO_HT40)\r\nband_chan_arr[index].flags &=\r\n~IEEE80211_CHAN_NO_HT40;\r\nband_chan_arr[index].flags |=\r\nIEEE80211_CHAN_NO_HT40PLUS;\r\n} else {\r\nband_chan_arr[index].flags &=\r\n~IEEE80211_CHAN_NO_HT40;\r\nif (ht40_flag == IEEE80211_CHAN_NO_HT40)\r\nband_chan_arr[index].flags |=\r\nIEEE80211_CHAN_NO_HT40MINUS;\r\n}\r\n} else {\r\nband_chan_arr[index].flags =\r\nIEEE80211_CHAN_NO_HT40;\r\nch.bw = BRCMU_CHAN_BW_20;\r\ncfg->d11inf.encchspec(&ch);\r\nchannel = ch.chspec;\r\nerr = brcmf_fil_bsscfg_int_get(ifp,\r\n"per_chan_info",\r\n&channel);\r\nif (!err) {\r\nif (channel & WL_CHAN_RADAR)\r\nband_chan_arr[index].flags |=\r\n(IEEE80211_CHAN_RADAR |\r\nIEEE80211_CHAN_NO_IBSS);\r\nif (channel & WL_CHAN_PASSIVE)\r\nband_chan_arr[index].flags |=\r\nIEEE80211_CHAN_PASSIVE_SCAN;\r\n}\r\n}\r\nif (!update)\r\n(*n_cnt)++;\r\n}\r\n}\r\nexit:\r\nkfree(pbuf);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_update_wiphybands(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(cfg_to_ndev(cfg));\r\nstruct wiphy *wiphy;\r\ns32 phy_list;\r\nu32 band_list[3];\r\nu32 nmode;\r\nu32 bw_cap = 0;\r\ns8 phy;\r\ns32 err;\r\nu32 nband;\r\ns32 i;\r\nstruct ieee80211_supported_band *bands[IEEE80211_NUM_BANDS];\r\ns32 index;\r\nerr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_PHYLIST,\r\n&phy_list, sizeof(phy_list));\r\nif (err) {\r\nbrcmf_err("BRCMF_C_GET_PHYLIST error (%d)\n", err);\r\nreturn err;\r\n}\r\nphy = ((char *)&phy_list)[0];\r\nbrcmf_dbg(INFO, "BRCMF_C_GET_PHYLIST reported: %c phy\n", phy);\r\nerr = brcmf_fil_cmd_data_get(ifp, BRCMF_C_GET_BANDLIST,\r\n&band_list, sizeof(band_list));\r\nif (err) {\r\nbrcmf_err("BRCMF_C_GET_BANDLIST error (%d)\n", err);\r\nreturn err;\r\n}\r\nbrcmf_dbg(INFO, "BRCMF_C_GET_BANDLIST reported: 0x%08x 0x%08x 0x%08x phy\n",\r\nband_list[0], band_list[1], band_list[2]);\r\nerr = brcmf_fil_iovar_int_get(ifp, "nmode", &nmode);\r\nif (err) {\r\nbrcmf_err("nmode error (%d)\n", err);\r\n} else {\r\nerr = brcmf_fil_iovar_int_get(ifp, "mimo_bw_cap", &bw_cap);\r\nif (err)\r\nbrcmf_err("mimo_bw_cap error (%d)\n", err);\r\n}\r\nbrcmf_dbg(INFO, "nmode=%d, mimo_bw_cap=%d\n", nmode, bw_cap);\r\nerr = brcmf_construct_reginfo(cfg, bw_cap);\r\nif (err) {\r\nbrcmf_err("brcmf_construct_reginfo failed (%d)\n", err);\r\nreturn err;\r\n}\r\nnband = band_list[0];\r\nmemset(bands, 0, sizeof(bands));\r\nfor (i = 1; i <= nband && i < ARRAY_SIZE(band_list); i++) {\r\nindex = -1;\r\nif ((band_list[i] == WLC_BAND_5G) &&\r\n(__wl_band_5ghz_a.n_channels > 0)) {\r\nindex = IEEE80211_BAND_5GHZ;\r\nbands[index] = &__wl_band_5ghz_a;\r\nif ((bw_cap == WLC_N_BW_40ALL) ||\r\n(bw_cap == WLC_N_BW_20IN2G_40IN5G))\r\nbands[index]->ht_cap.cap |=\r\nIEEE80211_HT_CAP_SGI_40;\r\n} else if ((band_list[i] == WLC_BAND_2G) &&\r\n(__wl_band_2ghz.n_channels > 0)) {\r\nindex = IEEE80211_BAND_2GHZ;\r\nbands[index] = &__wl_band_2ghz;\r\nif (bw_cap == WLC_N_BW_40ALL)\r\nbands[index]->ht_cap.cap |=\r\nIEEE80211_HT_CAP_SGI_40;\r\n}\r\nif ((index >= 0) && nmode) {\r\nbands[index]->ht_cap.cap |= IEEE80211_HT_CAP_SGI_20;\r\nbands[index]->ht_cap.cap |= IEEE80211_HT_CAP_DSSSCCK40;\r\nbands[index]->ht_cap.ht_supported = true;\r\nbands[index]->ht_cap.ampdu_factor =\r\nIEEE80211_HT_MAX_AMPDU_64K;\r\nbands[index]->ht_cap.ampdu_density =\r\nIEEE80211_HT_MPDU_DENSITY_16;\r\nbands[index]->ht_cap.mcs.rx_mask[0] = 0xff;\r\n}\r\n}\r\nwiphy = cfg_to_wiphy(cfg);\r\nwiphy->bands[IEEE80211_BAND_2GHZ] = bands[IEEE80211_BAND_2GHZ];\r\nwiphy->bands[IEEE80211_BAND_5GHZ] = bands[IEEE80211_BAND_5GHZ];\r\nwiphy_apply_custom_regulatory(wiphy, &brcmf_regdom);\r\nreturn err;\r\n}\r\nstatic s32 brcmf_dongle_probecap(struct brcmf_cfg80211_info *cfg)\r\n{\r\nreturn brcmf_update_wiphybands(cfg);\r\n}\r\nstatic s32 brcmf_config_dongle(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct net_device *ndev;\r\nstruct wireless_dev *wdev;\r\nstruct brcmf_if *ifp;\r\ns32 power_mode;\r\ns32 err = 0;\r\nif (cfg->dongle_up)\r\nreturn err;\r\nndev = cfg_to_ndev(cfg);\r\nwdev = ndev->ieee80211_ptr;\r\nifp = netdev_priv(ndev);\r\nbrcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 0);\r\nbrcmf_dongle_scantime(ifp, WL_SCAN_CHANNEL_TIME,\r\nWL_SCAN_UNASSOC_TIME, WL_SCAN_PASSIVE_TIME);\r\npower_mode = cfg->pwr_save ? PM_FAST : PM_OFF;\r\nerr = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_PM, power_mode);\r\nif (err)\r\ngoto default_conf_out;\r\nbrcmf_dbg(INFO, "power save set to %s\n",\r\n(power_mode ? "enabled" : "disabled"));\r\nerr = brcmf_dongle_roam(ifp, (cfg->roam_on ? 0 : 1), WL_BEACON_TIMEOUT);\r\nif (err)\r\ngoto default_conf_out;\r\nerr = brcmf_cfg80211_change_iface(wdev->wiphy, ndev, wdev->iftype,\r\nNULL, NULL);\r\nif (err)\r\ngoto default_conf_out;\r\nerr = brcmf_dongle_probecap(cfg);\r\nif (err)\r\ngoto default_conf_out;\r\nbrcmf_configure_arp_offload(ifp, true);\r\ncfg->dongle_up = true;\r\ndefault_conf_out:\r\nreturn err;\r\n}\r\nstatic s32 __brcmf_cfg80211_up(struct brcmf_if *ifp)\r\n{\r\nset_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\r\nreturn brcmf_config_dongle(ifp->drvr->config);\r\n}\r\nstatic s32 __brcmf_cfg80211_down(struct brcmf_if *ifp)\r\n{\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\nif (check_vif_up(ifp->vif)) {\r\nbrcmf_link_down(ifp->vif);\r\nbrcmf_delay(500);\r\n}\r\nbrcmf_abort_scanning(cfg);\r\nclear_bit(BRCMF_VIF_STATUS_READY, &ifp->vif->sme_state);\r\nreturn 0;\r\n}\r\ns32 brcmf_cfg80211_up(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\ns32 err = 0;\r\nmutex_lock(&cfg->usr_sync);\r\nerr = __brcmf_cfg80211_up(ifp);\r\nmutex_unlock(&cfg->usr_sync);\r\nreturn err;\r\n}\r\ns32 brcmf_cfg80211_down(struct net_device *ndev)\r\n{\r\nstruct brcmf_if *ifp = netdev_priv(ndev);\r\nstruct brcmf_cfg80211_info *cfg = ifp->drvr->config;\r\ns32 err = 0;\r\nmutex_lock(&cfg->usr_sync);\r\nerr = __brcmf_cfg80211_down(ifp);\r\nmutex_unlock(&cfg->usr_sync);\r\nreturn err;\r\n}\r\nenum nl80211_iftype brcmf_cfg80211_get_iftype(struct brcmf_if *ifp)\r\n{\r\nstruct wireless_dev *wdev = &ifp->vif->wdev;\r\nreturn wdev->iftype;\r\n}\r\nu32 wl_get_vif_state_all(struct brcmf_cfg80211_info *cfg, unsigned long state)\r\n{\r\nstruct brcmf_cfg80211_vif *vif;\r\nbool result = 0;\r\nlist_for_each_entry(vif, &cfg->vif_list, list) {\r\nif (test_bit(state, &vif->sme_state))\r\nresult++;\r\n}\r\nreturn result;\r\n}\r\nstatic inline bool vif_event_equals(struct brcmf_cfg80211_vif_event *event,\r\nu8 action)\r\n{\r\nu8 evt_action;\r\nmutex_lock(&event->vif_event_lock);\r\nevt_action = event->action;\r\nmutex_unlock(&event->vif_event_lock);\r\nreturn evt_action == action;\r\n}\r\nvoid brcmf_cfg80211_arm_vif_event(struct brcmf_cfg80211_info *cfg,\r\nstruct brcmf_cfg80211_vif *vif)\r\n{\r\nstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\r\nmutex_lock(&event->vif_event_lock);\r\nevent->vif = vif;\r\nevent->action = 0;\r\nmutex_unlock(&event->vif_event_lock);\r\n}\r\nbool brcmf_cfg80211_vif_event_armed(struct brcmf_cfg80211_info *cfg)\r\n{\r\nstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\r\nbool armed;\r\nmutex_lock(&event->vif_event_lock);\r\narmed = event->vif != NULL;\r\nmutex_unlock(&event->vif_event_lock);\r\nreturn armed;\r\n}\r\nint brcmf_cfg80211_wait_vif_event_timeout(struct brcmf_cfg80211_info *cfg,\r\nu8 action, ulong timeout)\r\n{\r\nstruct brcmf_cfg80211_vif_event *event = &cfg->vif_event;\r\nreturn wait_event_timeout(event->vif_wq,\r\nvif_event_equals(event, action), timeout);\r\n}
