static void frontswap_selfshrink(void)\r\n{\r\nstatic unsigned long cur_frontswap_pages;\r\nstatic unsigned long last_frontswap_pages;\r\nstatic unsigned long tgt_frontswap_pages;\r\nlast_frontswap_pages = cur_frontswap_pages;\r\ncur_frontswap_pages = frontswap_curr_pages();\r\nif (!cur_frontswap_pages ||\r\n(cur_frontswap_pages > last_frontswap_pages)) {\r\nfrontswap_inertia_counter = frontswap_inertia;\r\nreturn;\r\n}\r\nif (frontswap_inertia_counter && --frontswap_inertia_counter)\r\nreturn;\r\nif (cur_frontswap_pages <= frontswap_hysteresis)\r\ntgt_frontswap_pages = 0;\r\nelse\r\ntgt_frontswap_pages = cur_frontswap_pages -\r\n(cur_frontswap_pages / frontswap_hysteresis);\r\nfrontswap_shrink(tgt_frontswap_pages);\r\n}\r\nstatic void selfballoon_process(struct work_struct *work)\r\n{\r\nunsigned long cur_pages, goal_pages, tgt_pages, floor_pages;\r\nunsigned long useful_pages;\r\nbool reset_timer = false;\r\nif (xen_selfballooning_enabled) {\r\ncur_pages = totalram_pages;\r\ntgt_pages = cur_pages;\r\ngoal_pages = vm_memory_committed() +\r\ntotalreserve_pages +\r\nMB2PAGES(selfballoon_reserved_mb);\r\n#ifdef CONFIG_FRONTSWAP\r\nif (frontswap_selfshrinking && frontswap_enabled)\r\ngoal_pages += frontswap_curr_pages();\r\n#endif\r\nif (cur_pages > goal_pages)\r\ntgt_pages = cur_pages -\r\n((cur_pages - goal_pages) /\r\nselfballoon_downhysteresis);\r\nelse if (cur_pages < goal_pages)\r\ntgt_pages = cur_pages +\r\n((goal_pages - cur_pages) /\r\nselfballoon_uphysteresis);\r\nuseful_pages = max_pfn - totalreserve_pages;\r\nif (selfballoon_min_usable_mb != 0)\r\nfloor_pages = totalreserve_pages +\r\nMB2PAGES(selfballoon_min_usable_mb);\r\nelse if (useful_pages < MB2PAGES(16))\r\nfloor_pages = max_pfn;\r\nelse if (useful_pages < MB2PAGES(64))\r\nfloor_pages = totalreserve_pages + MB2PAGES(16) +\r\n((useful_pages - MB2PAGES(16)) >> 1);\r\nelse if (useful_pages < MB2PAGES(512))\r\nfloor_pages = totalreserve_pages + MB2PAGES(40) +\r\n((useful_pages - MB2PAGES(40)) >> 3);\r\nelse\r\nfloor_pages = totalreserve_pages + MB2PAGES(99) +\r\n((useful_pages - MB2PAGES(99)) >> 5);\r\nif (tgt_pages < floor_pages)\r\ntgt_pages = floor_pages;\r\nballoon_set_new_target(tgt_pages +\r\nballoon_stats.current_pages - totalram_pages);\r\nreset_timer = true;\r\n}\r\n#ifdef CONFIG_FRONTSWAP\r\nif (frontswap_selfshrinking && frontswap_enabled) {\r\nfrontswap_selfshrink();\r\nreset_timer = true;\r\n}\r\n#endif\r\nif (reset_timer)\r\nschedule_delayed_work(&selfballoon_worker,\r\nselfballoon_interval * HZ);\r\n}\r\nstatic ssize_t store_selfballooning(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nbool was_enabled = xen_selfballooning_enabled;\r\nunsigned long tmp;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &tmp);\r\nif (err)\r\nreturn err;\r\nif ((tmp != 0) && (tmp != 1))\r\nreturn -EINVAL;\r\nxen_selfballooning_enabled = !!tmp;\r\nif (!was_enabled && xen_selfballooning_enabled)\r\nschedule_delayed_work(&selfballoon_worker,\r\nselfballoon_interval * HZ);\r\nreturn count;\r\n}\r\nstatic ssize_t store_selfballoon_interval(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nselfballoon_interval = val;\r\nreturn count;\r\n}\r\nstatic ssize_t store_selfballoon_downhys(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nselfballoon_downhysteresis = val;\r\nreturn count;\r\n}\r\nstatic ssize_t store_selfballoon_uphys(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nselfballoon_uphysteresis = val;\r\nreturn count;\r\n}\r\nstatic ssize_t store_selfballoon_min_usable_mb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nselfballoon_min_usable_mb = val;\r\nreturn count;\r\n}\r\nstatic ssize_t store_selfballoon_reserved_mb(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nselfballoon_reserved_mb = val;\r\nreturn count;\r\n}\r\nstatic ssize_t store_frontswap_selfshrinking(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nbool was_enabled = frontswap_selfshrinking;\r\nunsigned long tmp;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &tmp);\r\nif (err)\r\nreturn err;\r\nif ((tmp != 0) && (tmp != 1))\r\nreturn -EINVAL;\r\nfrontswap_selfshrinking = !!tmp;\r\nif (!was_enabled && !xen_selfballooning_enabled &&\r\nfrontswap_selfshrinking)\r\nschedule_delayed_work(&selfballoon_worker,\r\nselfballoon_interval * HZ);\r\nreturn count;\r\n}\r\nstatic ssize_t store_frontswap_inertia(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nfrontswap_inertia = val;\r\nfrontswap_inertia_counter = val;\r\nreturn count;\r\n}\r\nstatic ssize_t store_frontswap_hysteresis(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nunsigned long val;\r\nint err;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val == 0)\r\nreturn -EINVAL;\r\nfrontswap_hysteresis = val;\r\nreturn count;\r\n}\r\nint register_xen_selfballooning(struct device *dev)\r\n{\r\nint error = -1;\r\n#ifdef CONFIG_SYSFS\r\nerror = sysfs_create_group(&dev->kobj, &selfballoon_group);\r\n#endif\r\nreturn error;\r\n}\r\nint xen_selfballoon_init(bool use_selfballooning, bool use_frontswap_selfshrink)\r\n{\r\nbool enable = false;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nif (xen_initial_domain()) {\r\npr_info("Xen selfballooning driver disabled for domain0\n");\r\nreturn -ENODEV;\r\n}\r\nxen_selfballooning_enabled = tmem_enabled && use_selfballooning;\r\nif (xen_selfballooning_enabled) {\r\npr_info("Initializing Xen selfballooning driver\n");\r\nenable = true;\r\n}\r\n#ifdef CONFIG_FRONTSWAP\r\nfrontswap_selfshrinking = tmem_enabled && use_frontswap_selfshrink;\r\nif (frontswap_selfshrinking) {\r\npr_info("Initializing frontswap selfshrinking driver\n");\r\nenable = true;\r\n}\r\n#endif\r\nif (!enable)\r\nreturn -ENODEV;\r\nschedule_delayed_work(&selfballoon_worker, selfballoon_interval * HZ);\r\nreturn 0;\r\n}
