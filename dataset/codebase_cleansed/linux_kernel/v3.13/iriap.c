static inline void iriap_start_watchdog_timer(struct iriap_cb *self,\r\nint timeout)\r\n{\r\nirda_start_timer(&self->watchdog_timer, timeout, self,\r\niriap_watchdog_timer_expired);\r\n}\r\nint __init iriap_init(void)\r\n{\r\nstruct ias_object *obj;\r\nstruct iriap_cb *server;\r\n__u8 oct_seq[6];\r\n__u16 hints;\r\niriap = hashbin_new(HB_LOCK);\r\nif (!iriap)\r\nreturn -ENOMEM;\r\nirias_objects = hashbin_new(HB_LOCK);\r\nif (!irias_objects) {\r\nIRDA_WARNING("%s: Can't allocate irias_objects hashbin!\n",\r\n__func__);\r\nhashbin_delete(iriap, NULL);\r\nreturn -ENOMEM;\r\n}\r\nlockdep_set_class_and_name(&irias_objects->hb_spinlock, &irias_objects_key,\r\n"irias_objects");\r\nhints = irlmp_service_to_hint(S_COMPUTER);\r\nservice_handle = irlmp_register_service(hints);\r\nobj = irias_new_object("Device", IAS_DEVICE_ID);\r\nirias_add_string_attrib(obj, "DeviceName", "Linux", IAS_KERNEL_ATTR);\r\noct_seq[0] = 0x01;\r\noct_seq[1] = 0x00;\r\noct_seq[2] = 0x00;\r\n#ifdef CONFIG_IRDA_ULTRA\r\noct_seq[2] |= 0x04;\r\n#endif\r\nirias_add_octseq_attrib(obj, "IrLMPSupport", oct_seq, 3,\r\nIAS_KERNEL_ATTR);\r\nirias_insert_object(obj);\r\nserver = iriap_open(LSAP_IAS, IAS_SERVER, NULL, NULL);\r\nif (!server) {\r\nIRDA_DEBUG(0, "%s(), unable to open server\n", __func__);\r\nreturn -1;\r\n}\r\niriap_register_lsap(server, LSAP_IAS, IAS_SERVER);\r\nreturn 0;\r\n}\r\nvoid iriap_cleanup(void)\r\n{\r\nirlmp_unregister_service(service_handle);\r\nhashbin_delete(iriap, (FREE_FUNC) __iriap_close);\r\nhashbin_delete(irias_objects, (FREE_FUNC) __irias_delete_object);\r\n}\r\nstruct iriap_cb *iriap_open(__u8 slsap_sel, int mode, void *priv,\r\nCONFIRM_CALLBACK callback)\r\n{\r\nstruct iriap_cb *self;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nself = kzalloc(sizeof(*self), GFP_ATOMIC);\r\nif (!self) {\r\nIRDA_WARNING("%s: Unable to kmalloc!\n", __func__);\r\nreturn NULL;\r\n}\r\nself->magic = IAS_MAGIC;\r\nself->mode = mode;\r\nif (mode == IAS_CLIENT)\r\niriap_register_lsap(self, slsap_sel, mode);\r\nself->confirm = callback;\r\nself->priv = priv;\r\nself->max_header_size = LMP_MAX_HEADER;\r\ninit_timer(&self->watchdog_timer);\r\nhashbin_insert(iriap, (irda_queue_t *) self, (long) self, NULL);\r\niriap_next_client_state(self, S_DISCONNECT);\r\niriap_next_call_state(self, S_MAKE_CALL);\r\niriap_next_server_state(self, R_DISCONNECT);\r\niriap_next_r_connect_state(self, R_WAITING);\r\nreturn self;\r\n}\r\nstatic void __iriap_close(struct iriap_cb *self)\r\n{\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\ndel_timer(&self->watchdog_timer);\r\nif (self->request_skb)\r\ndev_kfree_skb(self->request_skb);\r\nself->magic = 0;\r\nkfree(self);\r\n}\r\nvoid iriap_close(struct iriap_cb *self)\r\n{\r\nstruct iriap_cb *entry;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nif (self->lsap) {\r\nirlmp_close_lsap(self->lsap);\r\nself->lsap = NULL;\r\n}\r\nentry = (struct iriap_cb *) hashbin_remove(iriap, (long) self, NULL);\r\nIRDA_ASSERT(entry == self, return;);\r\n__iriap_close(self);\r\n}\r\nstatic int iriap_register_lsap(struct iriap_cb *self, __u8 slsap_sel, int mode)\r\n{\r\nnotify_t notify;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nirda_notify_init(&notify);\r\nnotify.connect_confirm = iriap_connect_confirm;\r\nnotify.connect_indication = iriap_connect_indication;\r\nnotify.disconnect_indication = iriap_disconnect_indication;\r\nnotify.data_indication = iriap_data_indication;\r\nnotify.instance = self;\r\nif (mode == IAS_CLIENT)\r\nstrcpy(notify.name, "IrIAS cli");\r\nelse\r\nstrcpy(notify.name, "IrIAS srv");\r\nself->lsap = irlmp_open_lsap(slsap_sel, &notify, 0);\r\nif (self->lsap == NULL) {\r\nIRDA_ERROR("%s: Unable to allocated LSAP!\n", __func__);\r\nreturn -1;\r\n}\r\nself->slsap_sel = self->lsap->slsap_sel;\r\nreturn 0;\r\n}\r\nstatic void iriap_disconnect_indication(void *instance, void *sap,\r\nLM_REASON reason,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iriap_cb *self;\r\nIRDA_DEBUG(4, "%s(), reason=%s [%d]\n", __func__,\r\nirlmp_reason_str(reason), reason);\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nIRDA_ASSERT(iriap != NULL, return;);\r\ndel_timer(&self->watchdog_timer);\r\nif (skb)\r\ndev_kfree_skb(skb);\r\nif (self->mode == IAS_CLIENT) {\r\nIRDA_DEBUG(4, "%s(), disconnect as client\n", __func__);\r\niriap_do_client_event(self, IAP_LM_DISCONNECT_INDICATION,\r\nNULL);\r\nif (self->confirm)\r\nself->confirm(IAS_DISCONNECT, 0, NULL, self->priv);\r\n} else {\r\nIRDA_DEBUG(4, "%s(), disconnect as server\n", __func__);\r\niriap_do_server_event(self, IAP_LM_DISCONNECT_INDICATION,\r\nNULL);\r\niriap_close(self);\r\n}\r\n}\r\nstatic void iriap_disconnect_request(struct iriap_cb *self)\r\n{\r\nstruct sk_buff *tx_skb;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\ntx_skb = alloc_skb(LMP_MAX_HEADER, GFP_ATOMIC);\r\nif (tx_skb == NULL) {\r\nIRDA_DEBUG(0,\r\n"%s(), Could not allocate an sk_buff of length %d\n",\r\n__func__, LMP_MAX_HEADER);\r\nreturn;\r\n}\r\nskb_reserve(tx_skb, LMP_MAX_HEADER);\r\nirlmp_disconnect_request(self->lsap, tx_skb);\r\n}\r\nint iriap_getvaluebyclass_request(struct iriap_cb *self,\r\n__u32 saddr, __u32 daddr,\r\nchar *name, char *attr)\r\n{\r\nstruct sk_buff *tx_skb;\r\nint name_len, attr_len, skb_len;\r\n__u8 *frame;\r\nIRDA_ASSERT(self != NULL, return -1;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return -1;);\r\nif (!daddr)\r\nreturn -1;\r\nself->daddr = daddr;\r\nself->saddr = saddr;\r\nself->operation = GET_VALUE_BY_CLASS;\r\niriap_start_watchdog_timer(self, 10*HZ);\r\nname_len = strlen(name);\r\nattr_len = strlen(attr);\r\nskb_len = self->max_header_size+2+name_len+1+attr_len+4;\r\ntx_skb = alloc_skb(skb_len, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn -ENOMEM;\r\nskb_reserve(tx_skb, self->max_header_size);\r\nskb_put(tx_skb, 3+name_len+attr_len);\r\nframe = tx_skb->data;\r\nframe[0] = IAP_LST | GET_VALUE_BY_CLASS;\r\nframe[1] = name_len;\r\nmemcpy(frame+2, name, name_len);\r\nframe[2+name_len] = attr_len;\r\nmemcpy(frame+3+name_len, attr, attr_len);\r\niriap_do_client_event(self, IAP_CALL_REQUEST_GVBC, tx_skb);\r\ndev_kfree_skb(tx_skb);\r\nreturn 0;\r\n}\r\nstatic void iriap_getvaluebyclass_confirm(struct iriap_cb *self,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ias_value *value;\r\nint charset;\r\n__u32 value_len;\r\n__u32 tmp_cpu32;\r\n__u16 obj_id;\r\n__u16 len;\r\n__u8 type;\r\n__u8 *fp;\r\nint n;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nfp = skb->data;\r\nn = 2;\r\nlen = get_unaligned_be16(fp + n);\r\nn += 2;\r\nIRDA_DEBUG(4, "%s(), len=%d\n", __func__, len);\r\nobj_id = get_unaligned_be16(fp + n);\r\nn += 2;\r\ntype = fp[n++];\r\nIRDA_DEBUG(4, "%s(), Value type = %d\n", __func__, type);\r\nswitch (type) {\r\ncase IAS_INTEGER:\r\nmemcpy(&tmp_cpu32, fp+n, 4); n += 4;\r\nbe32_to_cpus(&tmp_cpu32);\r\nvalue = irias_new_integer_value(tmp_cpu32);\r\nIRDA_DEBUG(4, "%s(), lsap=%d\n", __func__, value->t.integer);\r\nbreak;\r\ncase IAS_STRING:\r\ncharset = fp[n++];\r\nswitch (charset) {\r\ncase CS_ASCII:\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), charset [%d] %s, not supported\n",\r\n__func__, charset,\r\ncharset < ARRAY_SIZE(ias_charset_types) ?\r\nias_charset_types[charset] :\r\n"(unknown)");\r\niriap_disconnect_request(self);\r\nreturn;\r\n}\r\nvalue_len = fp[n++];\r\nIRDA_DEBUG(4, "%s(), strlen=%d\n", __func__, value_len);\r\nif (n + value_len < skb->len)\r\nfp[n + value_len] = 0x00;\r\nIRDA_DEBUG(4, "Got string %s\n", fp+n);\r\nvalue = irias_new_string_value(fp+n);\r\nbreak;\r\ncase IAS_OCT_SEQ:\r\nvalue_len = get_unaligned_be16(fp + n);\r\nn += 2;\r\nvalue = irias_new_octseq_value(fp+n, value_len);\r\nbreak;\r\ndefault:\r\nvalue = irias_new_missing_value();\r\nbreak;\r\n}\r\niriap_disconnect_request(self);\r\nif (self->confirm)\r\nself->confirm(IAS_SUCCESS, obj_id, value, self->priv);\r\nelse {\r\nIRDA_DEBUG(0, "%s(), missing handler!\n", __func__);\r\nirias_delete_value(value);\r\n}\r\n}\r\nstatic void iriap_getvaluebyclass_response(struct iriap_cb *self,\r\n__u16 obj_id,\r\n__u8 ret_code,\r\nstruct ias_value *value)\r\n{\r\nstruct sk_buff *tx_skb;\r\nint n;\r\n__be32 tmp_be32;\r\n__be16 tmp_be16;\r\n__u8 *fp;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nIRDA_ASSERT(value != NULL, return;);\r\nIRDA_ASSERT(value->len <= 1024, return;);\r\nn = 0;\r\ntx_skb = alloc_skb(value->len + self->max_header_size + 32,\r\nGFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nskb_reserve(tx_skb, self->max_header_size);\r\nskb_put(tx_skb, 6);\r\nfp = tx_skb->data;\r\nfp[n++] = GET_VALUE_BY_CLASS | IAP_LST;\r\nfp[n++] = ret_code;\r\ntmp_be16 = htons(0x0001);\r\nmemcpy(fp+n, &tmp_be16, 2); n += 2;\r\ntmp_be16 = cpu_to_be16(obj_id);\r\nmemcpy(fp+n, &tmp_be16, 2); n += 2;\r\nswitch (value->type) {\r\ncase IAS_STRING:\r\nskb_put(tx_skb, 3 + value->len);\r\nfp[n++] = value->type;\r\nfp[n++] = 0;\r\nfp[n++] = (__u8) value->len;\r\nmemcpy(fp+n, value->t.string, value->len); n+=value->len;\r\nbreak;\r\ncase IAS_INTEGER:\r\nskb_put(tx_skb, 5);\r\nfp[n++] = value->type;\r\ntmp_be32 = cpu_to_be32(value->t.integer);\r\nmemcpy(fp+n, &tmp_be32, 4); n += 4;\r\nbreak;\r\ncase IAS_OCT_SEQ:\r\nskb_put(tx_skb, 3 + value->len);\r\nfp[n++] = value->type;\r\ntmp_be16 = cpu_to_be16(value->len);\r\nmemcpy(fp+n, &tmp_be16, 2); n += 2;\r\nmemcpy(fp+n, value->t.oct_seq, value->len); n+=value->len;\r\nbreak;\r\ncase IAS_MISSING:\r\nIRDA_DEBUG( 3, "%s: sending IAS_MISSING\n", __func__);\r\nskb_put(tx_skb, 1);\r\nfp[n++] = value->type;\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), type not implemented!\n", __func__);\r\nbreak;\r\n}\r\niriap_do_r_connect_event(self, IAP_CALL_RESPONSE, tx_skb);\r\ndev_kfree_skb(tx_skb);\r\n}\r\nstatic void iriap_getvaluebyclass_indication(struct iriap_cb *self,\r\nstruct sk_buff *skb)\r\n{\r\nstruct ias_object *obj;\r\nstruct ias_attrib *attrib;\r\nint name_len;\r\nint attr_len;\r\nchar name[IAS_MAX_CLASSNAME + 1];\r\nchar attr[IAS_MAX_ATTRIBNAME + 1];\r\n__u8 *fp;\r\nint n;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nfp = skb->data;\r\nn = 1;\r\nname_len = fp[n++];\r\nIRDA_ASSERT(name_len < IAS_MAX_CLASSNAME + 1, return;);\r\nmemcpy(name, fp+n, name_len); n+=name_len;\r\nname[name_len] = '\0';\r\nattr_len = fp[n++];\r\nIRDA_ASSERT(attr_len < IAS_MAX_ATTRIBNAME + 1, return;);\r\nmemcpy(attr, fp+n, attr_len); n+=attr_len;\r\nattr[attr_len] = '\0';\r\nIRDA_DEBUG(4, "LM-IAS: Looking up %s: %s\n", name, attr);\r\nobj = irias_find_object(name);\r\nif (obj == NULL) {\r\nIRDA_DEBUG(2, "LM-IAS: Object %s not found\n", name);\r\niriap_getvaluebyclass_response(self, 0x1235, IAS_CLASS_UNKNOWN,\r\n&irias_missing);\r\nreturn;\r\n}\r\nIRDA_DEBUG(4, "LM-IAS: found %s, id=%d\n", obj->name, obj->id);\r\nattrib = irias_find_attrib(obj, attr);\r\nif (attrib == NULL) {\r\nIRDA_DEBUG(2, "LM-IAS: Attribute %s not found\n", attr);\r\niriap_getvaluebyclass_response(self, obj->id,\r\nIAS_ATTRIB_UNKNOWN,\r\n&irias_missing);\r\nreturn;\r\n}\r\niriap_getvaluebyclass_response(self, obj->id, IAS_SUCCESS,\r\nattrib->value);\r\n}\r\nvoid iriap_send_ack(struct iriap_cb *self)\r\n{\r\nstruct sk_buff *tx_skb;\r\n__u8 *frame;\r\nIRDA_DEBUG(2, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\ntx_skb = alloc_skb(LMP_MAX_HEADER + 1, GFP_ATOMIC);\r\nif (!tx_skb)\r\nreturn;\r\nskb_reserve(tx_skb, self->max_header_size);\r\nskb_put(tx_skb, 1);\r\nframe = tx_skb->data;\r\nframe[0] = IAP_LST | IAP_ACK | self->operation;\r\nirlmp_data_request(self->lsap, tx_skb);\r\n}\r\nvoid iriap_connect_request(struct iriap_cb *self)\r\n{\r\nint ret;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nret = irlmp_connect_request(self->lsap, LSAP_IAS,\r\nself->saddr, self->daddr,\r\nNULL, NULL);\r\nif (ret < 0) {\r\nIRDA_DEBUG(0, "%s(), connect failed!\n", __func__);\r\nself->confirm(IAS_DISCONNECT, 0, NULL, self->priv);\r\n}\r\n}\r\nstatic void iriap_connect_confirm(void *instance, void *sap,\r\nstruct qos_info *qos, __u32 max_seg_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iriap_cb *self;\r\nself = instance;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nself->max_data_size = max_seg_size;\r\nself->max_header_size = max_header_size;\r\ndel_timer(&self->watchdog_timer);\r\niriap_do_client_event(self, IAP_LM_CONNECT_CONFIRM, skb);\r\ndev_kfree_skb(skb);\r\n}\r\nstatic void iriap_connect_indication(void *instance, void *sap,\r\nstruct qos_info *qos, __u32 max_seg_size,\r\n__u8 max_header_size,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iriap_cb *self, *new;\r\nIRDA_DEBUG(1, "%s()\n", __func__);\r\nself = instance;\r\nIRDA_ASSERT(skb != NULL, return;);\r\nIRDA_ASSERT(self != NULL, goto out;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, goto out;);\r\nnew = iriap_open(LSAP_IAS, IAS_SERVER, NULL, NULL);\r\nif (!new) {\r\nIRDA_DEBUG(0, "%s(), open failed\n", __func__);\r\ngoto out;\r\n}\r\nnew->lsap = irlmp_dup(self->lsap, new);\r\nif (!new->lsap) {\r\nIRDA_DEBUG(0, "%s(), dup failed!\n", __func__);\r\ngoto out;\r\n}\r\nnew->max_data_size = max_seg_size;\r\nnew->max_header_size = max_header_size;\r\nirlmp_listen(self->lsap);\r\niriap_do_server_event(new, IAP_LM_CONNECT_INDICATION, skb);\r\nout:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int iriap_data_indication(void *instance, void *sap,\r\nstruct sk_buff *skb)\r\n{\r\nstruct iriap_cb *self;\r\n__u8 *frame;\r\n__u8 opcode;\r\nIRDA_DEBUG(3, "%s()\n", __func__);\r\nself = instance;\r\nIRDA_ASSERT(skb != NULL, return 0;);\r\nIRDA_ASSERT(self != NULL, goto out;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, goto out;);\r\nframe = skb->data;\r\nif (self->mode == IAS_SERVER) {\r\nIRDA_DEBUG(4, "%s(), Calling server!\n", __func__);\r\niriap_do_r_connect_event(self, IAP_RECV_F_LST, skb);\r\ngoto out;\r\n}\r\nopcode = frame[0];\r\nif (~opcode & IAP_LST) {\r\nIRDA_WARNING("%s:, IrIAS multiframe commands or "\r\n"results is not implemented yet!\n",\r\n__func__);\r\ngoto out;\r\n}\r\nif (opcode & IAP_ACK) {\r\nIRDA_DEBUG(0, "%s() Got ack frame!\n", __func__);\r\ngoto out;\r\n}\r\nopcode &= ~IAP_LST;\r\nswitch (opcode) {\r\ncase GET_INFO_BASE:\r\nIRDA_DEBUG(0, "IrLMP GetInfoBaseDetails not implemented!\n");\r\nbreak;\r\ncase GET_VALUE_BY_CLASS:\r\niriap_do_call_event(self, IAP_RECV_F_LST, NULL);\r\nswitch (frame[1]) {\r\ncase IAS_SUCCESS:\r\niriap_getvaluebyclass_confirm(self, skb);\r\nbreak;\r\ncase IAS_CLASS_UNKNOWN:\r\nIRDA_DEBUG(1, "%s(), No such class!\n", __func__);\r\niriap_disconnect_request(self);\r\nif (self->confirm)\r\nself->confirm(IAS_CLASS_UNKNOWN, 0, NULL,\r\nself->priv);\r\nbreak;\r\ncase IAS_ATTRIB_UNKNOWN:\r\nIRDA_DEBUG(1, "%s(), No such attribute!\n", __func__);\r\niriap_disconnect_request(self);\r\nif (self->confirm)\r\nself->confirm(IAS_ATTRIB_UNKNOWN, 0, NULL,\r\nself->priv);\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nIRDA_DEBUG(0, "%s(), Unknown op-code: %02x\n", __func__,\r\nopcode);\r\nbreak;\r\n}\r\nout:\r\ndev_kfree_skb(skb);\r\nreturn 0;\r\n}\r\nvoid iriap_call_indication(struct iriap_cb *self, struct sk_buff *skb)\r\n{\r\n__u8 *fp;\r\n__u8 opcode;\r\nIRDA_DEBUG(4, "%s()\n", __func__);\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\nIRDA_ASSERT(skb != NULL, return;);\r\nfp = skb->data;\r\nopcode = fp[0];\r\nif (~opcode & 0x80) {\r\nIRDA_WARNING("%s: IrIAS multiframe commands or results "\r\n"is not implemented yet!\n", __func__);\r\nreturn;\r\n}\r\nopcode &= 0x7f;\r\nswitch (opcode) {\r\ncase GET_INFO_BASE:\r\nIRDA_WARNING("%s: GetInfoBaseDetails not implemented yet!\n",\r\n__func__);\r\nbreak;\r\ncase GET_VALUE_BY_CLASS:\r\niriap_getvaluebyclass_indication(self, skb);\r\nbreak;\r\n}\r\n}\r\nstatic void iriap_watchdog_timer_expired(void *data)\r\n{\r\nstruct iriap_cb *self = (struct iriap_cb *) data;\r\nIRDA_ASSERT(self != NULL, return;);\r\nIRDA_ASSERT(self->magic == IAS_MAGIC, return;);\r\n}\r\nstatic inline struct ias_object *irias_seq_idx(loff_t pos)\r\n{\r\nstruct ias_object *obj;\r\nfor (obj = (struct ias_object *) hashbin_get_first(irias_objects);\r\nobj; obj = (struct ias_object *) hashbin_get_next(irias_objects)) {\r\nif (pos-- == 0)\r\nbreak;\r\n}\r\nreturn obj;\r\n}\r\nstatic void *irias_seq_start(struct seq_file *seq, loff_t *pos)\r\n{\r\nspin_lock_irq(&irias_objects->hb_spinlock);\r\nreturn *pos ? irias_seq_idx(*pos - 1) : SEQ_START_TOKEN;\r\n}\r\nstatic void *irias_seq_next(struct seq_file *seq, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn (v == SEQ_START_TOKEN)\r\n? (void *) hashbin_get_first(irias_objects)\r\n: (void *) hashbin_get_next(irias_objects);\r\n}\r\nstatic void irias_seq_stop(struct seq_file *seq, void *v)\r\n{\r\nspin_unlock_irq(&irias_objects->hb_spinlock);\r\n}\r\nstatic int irias_seq_show(struct seq_file *seq, void *v)\r\n{\r\nif (v == SEQ_START_TOKEN)\r\nseq_puts(seq, "LM-IAS Objects:\n");\r\nelse {\r\nstruct ias_object *obj = v;\r\nstruct ias_attrib *attrib;\r\nIRDA_ASSERT(obj->magic == IAS_OBJECT_MAGIC, return -EINVAL;);\r\nseq_printf(seq, "name: %s, id=%d\n",\r\nobj->name, obj->id);\r\nspin_lock(&obj->attribs->hb_spinlock);\r\nfor (attrib = (struct ias_attrib *) hashbin_get_first(obj->attribs);\r\nattrib != NULL;\r\nattrib = (struct ias_attrib *) hashbin_get_next(obj->attribs)) {\r\nIRDA_ASSERT(attrib->magic == IAS_ATTRIB_MAGIC,\r\ngoto outloop; );\r\nseq_printf(seq, " - Attribute name: \"%s\", ",\r\nattrib->name);\r\nseq_printf(seq, "value[%s]: ",\r\nias_value_types[attrib->value->type]);\r\nswitch (attrib->value->type) {\r\ncase IAS_INTEGER:\r\nseq_printf(seq, "%d\n",\r\nattrib->value->t.integer);\r\nbreak;\r\ncase IAS_STRING:\r\nseq_printf(seq, "\"%s\"\n",\r\nattrib->value->t.string);\r\nbreak;\r\ncase IAS_OCT_SEQ:\r\nseq_printf(seq, "octet sequence (%d bytes)\n",\r\nattrib->value->len);\r\nbreak;\r\ncase IAS_MISSING:\r\nseq_puts(seq, "missing\n");\r\nbreak;\r\ndefault:\r\nseq_printf(seq, "type %d?\n",\r\nattrib->value->type);\r\n}\r\nseq_putc(seq, '\n');\r\n}\r\nIRDA_ASSERT_LABEL(outloop:)\r\nspin_unlock(&obj->attribs->hb_spinlock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int irias_seq_open(struct inode *inode, struct file *file)\r\n{\r\nIRDA_ASSERT( irias_objects != NULL, return -EINVAL;);\r\nreturn seq_open(file, &irias_seq_ops);\r\n}
