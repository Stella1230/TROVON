static void pxav3_set_private_registers(struct sdhci_host *host, u8 mask)\r\n{\r\nstruct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));\r\nstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\r\nif (mask == SDHCI_RESET_ALL) {\r\nif (pdata && 0 != pdata->clk_delay_cycles) {\r\nu16 tmp;\r\ntmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\r\ntmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)\r\n<< SDCLK_DELAY_SHIFT;\r\ntmp |= SDCLK_SEL;\r\nwritew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\r\n}\r\n}\r\n}\r\nstatic void pxav3_gen_init_74_clocks(struct sdhci_host *host, u8 power_mode)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = pltfm_host->priv;\r\nu16 tmp;\r\nint count;\r\nif (pxa->power_mode == MMC_POWER_UP\r\n&& power_mode == MMC_POWER_ON) {\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%s: slot->power_mode = %d,"\r\n"ios->power_mode = %d\n",\r\n__func__,\r\npxa->power_mode,\r\npower_mode);\r\ntmp = readw(host->ioaddr + SD_CE_ATA_2);\r\ntmp |= SDCE_MISC_INT_EN;\r\nwritew(tmp, host->ioaddr + SD_CE_ATA_2);\r\ntmp = readw(host->ioaddr + SD_CFG_FIFO_PARAM);\r\ntmp |= SDCFG_GEN_PAD_CLK_ON;\r\nwritew(tmp, host->ioaddr + SD_CFG_FIFO_PARAM);\r\nudelay(740);\r\ncount = 0;\r\nwhile (count++ < MAX_WAIT_COUNT) {\r\nif ((readw(host->ioaddr + SD_CE_ATA_2)\r\n& SDCE_MISC_INT) == 0)\r\nbreak;\r\nudelay(10);\r\n}\r\nif (count == MAX_WAIT_COUNT)\r\ndev_warn(mmc_dev(host->mmc), "74 clock interrupt not cleared\n");\r\ntmp = readw(host->ioaddr + SD_CE_ATA_2);\r\ntmp |= SDCE_MISC_INT;\r\nwritew(tmp, host->ioaddr + SD_CE_ATA_2);\r\n}\r\npxa->power_mode = power_mode;\r\n}\r\nstatic int pxav3_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)\r\n{\r\nu16 ctrl_2;\r\nctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\r\nctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\r\nswitch (uhs) {\r\ncase MMC_TIMING_UHS_SDR12:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR12;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR25:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR25;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR50:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR50 | SDHCI_CTRL_VDD_180;\r\nbreak;\r\ncase MMC_TIMING_UHS_SDR104:\r\nctrl_2 |= SDHCI_CTRL_UHS_SDR104 | SDHCI_CTRL_VDD_180;\r\nbreak;\r\ncase MMC_TIMING_UHS_DDR50:\r\nctrl_2 |= SDHCI_CTRL_UHS_DDR50 | SDHCI_CTRL_VDD_180;\r\nbreak;\r\n}\r\nsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\r\ndev_dbg(mmc_dev(host->mmc),\r\n"%s uhs = %d, ctrl_2 = %04X\n",\r\n__func__, uhs, ctrl_2);\r\nreturn 0;\r\n}\r\nstatic struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)\r\n{\r\nstruct sdhci_pxa_platdata *pdata;\r\nstruct device_node *np = dev->of_node;\r\nu32 clk_delay_cycles;\r\npdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nof_property_read_u32(np, "mrvl,clk-delay-cycles", &clk_delay_cycles);\r\nif (clk_delay_cycles > 0)\r\npdata->clk_delay_cycles = clk_delay_cycles;\r\nreturn pdata;\r\n}\r\nstatic inline struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int sdhci_pxav3_probe(struct platform_device *pdev)\r\n{\r\nstruct sdhci_pltfm_host *pltfm_host;\r\nstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct sdhci_host *host = NULL;\r\nstruct sdhci_pxa *pxa = NULL;\r\nconst struct of_device_id *match;\r\nint ret;\r\nstruct clk *clk;\r\npxa = kzalloc(sizeof(struct sdhci_pxa), GFP_KERNEL);\r\nif (!pxa)\r\nreturn -ENOMEM;\r\nhost = sdhci_pltfm_init(pdev, &sdhci_pxav3_pdata, 0);\r\nif (IS_ERR(host)) {\r\nkfree(pxa);\r\nreturn PTR_ERR(host);\r\n}\r\npltfm_host = sdhci_priv(host);\r\npltfm_host->priv = pxa;\r\nclk = clk_get(dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(dev, "failed to get io clock\n");\r\nret = PTR_ERR(clk);\r\ngoto err_clk_get;\r\n}\r\npltfm_host->clk = clk;\r\nclk_prepare_enable(clk);\r\nhost->mmc->caps |= MMC_CAP_1_8V_DDR;\r\nmatch = of_match_device(of_match_ptr(sdhci_pxav3_of_match), &pdev->dev);\r\nif (match) {\r\nret = mmc_of_parse(host->mmc);\r\nif (ret)\r\ngoto err_of_parse;\r\nsdhci_get_of_property(pdev);\r\npdata = pxav3_get_mmc_pdata(dev);\r\n} else if (pdata) {\r\nif (pdata->flags & PXA_FLAG_CARD_PERMANENT)\r\nhost->mmc->caps |= MMC_CAP_NONREMOVABLE;\r\nif (pdata->flags & PXA_FLAG_SD_8_BIT_CAPABLE_SLOT)\r\nhost->mmc->caps |= MMC_CAP_8_BIT_DATA;\r\nif (pdata->quirks)\r\nhost->quirks |= pdata->quirks;\r\nif (pdata->quirks2)\r\nhost->quirks2 |= pdata->quirks2;\r\nif (pdata->host_caps)\r\nhost->mmc->caps |= pdata->host_caps;\r\nif (pdata->host_caps2)\r\nhost->mmc->caps2 |= pdata->host_caps2;\r\nif (pdata->pm_caps)\r\nhost->mmc->pm_caps |= pdata->pm_caps;\r\nif (gpio_is_valid(pdata->ext_cd_gpio)) {\r\nret = mmc_gpio_request_cd(host->mmc, pdata->ext_cd_gpio,\r\n0);\r\nif (ret) {\r\ndev_err(mmc_dev(host->mmc),\r\n"failed to allocate card detect gpio\n");\r\ngoto err_cd_req;\r\n}\r\n}\r\n}\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, PXAV3_RPM_DELAY_MS);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_suspend_ignore_children(&pdev->dev, 1);\r\nret = sdhci_add_host(host);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to add host\n");\r\ngoto err_add_host;\r\n}\r\nplatform_set_drvdata(pdev, host);\r\nif (host->mmc->pm_caps & MMC_PM_KEEP_POWER) {\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nhost->mmc->pm_flags |= MMC_PM_WAKE_SDIO_IRQ;\r\n} else {\r\ndevice_init_wakeup(&pdev->dev, 0);\r\n}\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\nerr_of_parse:\r\nerr_cd_req:\r\nerr_add_host:\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(clk);\r\nclk_put(clk);\r\nerr_clk_get:\r\nsdhci_pltfm_free(pdev);\r\nkfree(pxa);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav3_remove(struct platform_device *pdev)\r\n{\r\nstruct sdhci_host *host = platform_get_drvdata(pdev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nstruct sdhci_pxa *pxa = pltfm_host->priv;\r\npm_runtime_get_sync(&pdev->dev);\r\nsdhci_remove_host(host, 1);\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(pltfm_host->clk);\r\nclk_put(pltfm_host->clk);\r\nsdhci_pltfm_free(pdev);\r\nkfree(pxa);\r\nreturn 0;\r\n}\r\nstatic int sdhci_pxav3_suspend(struct device *dev)\r\n{\r\nint ret;\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nret = sdhci_suspend_host(host);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav3_resume(struct device *dev)\r\n{\r\nint ret;\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\npm_runtime_get_sync(dev);\r\nret = sdhci_resume_host(host);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\nreturn ret;\r\n}\r\nstatic int sdhci_pxav3_runtime_suspend(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nunsigned long flags;\r\nif (pltfm_host->clk) {\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->runtime_suspended = true;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\nclk_disable_unprepare(pltfm_host->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sdhci_pxav3_runtime_resume(struct device *dev)\r\n{\r\nstruct sdhci_host *host = dev_get_drvdata(dev);\r\nstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\r\nunsigned long flags;\r\nif (pltfm_host->clk) {\r\nclk_prepare_enable(pltfm_host->clk);\r\nspin_lock_irqsave(&host->lock, flags);\r\nhost->runtime_suspended = false;\r\nspin_unlock_irqrestore(&host->lock, flags);\r\n}\r\nreturn 0;\r\n}
