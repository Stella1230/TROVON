static int st_irq_xlate(struct platform_device *pdev,\r\nint device, int channel, bool irq)\r\n{\r\nstruct st_irq_syscfg *ddata = dev_get_drvdata(&pdev->dev);\r\nswitch (device) {\r\ncase ST_IRQ_SYSCFG_EXT_0:\r\nddata->config |= ST_A9_IRQ_EN_EXT_0;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_EXT_1:\r\nddata->config |= ST_A9_IRQ_EN_EXT_1;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_EXT_2:\r\nddata->config |= ST_A9_IRQ_EN_EXT_2;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_CTI_0:\r\nddata->config |= ST_A9_IRQ_EN_CTI_0;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_CTI_1:\r\nddata->config |= ST_A9_IRQ_EN_CTI_1;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_PMU_0:\r\nddata->config |= ST_A9_IRQ_EN_PMU_0;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_PMU_1:\r\nddata->config |= ST_A9_IRQ_EN_PMU_1;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_pl310_L2:\r\nddata->config |= ST_A9_IRQ_EN_PL310_L2;\r\nbreak;\r\ncase ST_IRQ_SYSCFG_DISABLED:\r\nreturn 0;\r\ndefault:\r\ndev_err(&pdev->dev, "Unrecognised device %d\n", device);\r\nreturn -EINVAL;\r\n}\r\nddata->config |= irq ?\r\nST_A9_IRQ_N_SEL(device, channel) :\r\nST_A9_FIQ_N_SEL(device, channel);\r\nreturn 0;\r\n}\r\nstatic int st_irq_syscfg_enable(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct st_irq_syscfg *ddata = dev_get_drvdata(&pdev->dev);\r\nint channels, ret, i;\r\nu32 device, invert;\r\nchannels = of_property_count_u32_elems(np, "st,irq-device");\r\nif (channels != ST_A9_IRQ_MAX_CHANS) {\r\ndev_err(&pdev->dev, "st,enable-irq-device must have 2 elems\n");\r\nreturn -EINVAL;\r\n}\r\nchannels = of_property_count_u32_elems(np, "st,fiq-device");\r\nif (channels != ST_A9_IRQ_MAX_CHANS) {\r\ndev_err(&pdev->dev, "st,enable-fiq-device must have 2 elems\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ST_A9_IRQ_MAX_CHANS; i++) {\r\nof_property_read_u32_index(np, "st,irq-device", i, &device);\r\nret = st_irq_xlate(pdev, device, i, true);\r\nif (ret)\r\nreturn ret;\r\nof_property_read_u32_index(np, "st,fiq-device", i, &device);\r\nret = st_irq_xlate(pdev, device, i, false);\r\nif (ret)\r\nreturn ret;\r\n}\r\nof_property_read_u32(np, "st,invert-ext", &invert);\r\nddata->config |= ST_A9_EXTIRQ_INV_SEL(invert);\r\nreturn regmap_update_bits(ddata->regmap, ddata->syscfg,\r\nST_A9_IRQ_MASK, ddata->config);\r\n}\r\nstatic int st_irq_syscfg_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *match;\r\nstruct st_irq_syscfg *ddata;\r\nddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nmatch = of_match_device(st_irq_syscfg_match, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nddata->syscfg = (unsigned int)match->data;\r\nddata->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(ddata->regmap)) {\r\ndev_err(&pdev->dev, "syscfg phandle missing\n");\r\nreturn PTR_ERR(ddata->regmap);\r\n}\r\ndev_set_drvdata(&pdev->dev, ddata);\r\nreturn st_irq_syscfg_enable(pdev);\r\n}\r\nstatic int __maybe_unused st_irq_syscfg_resume(struct device *dev)\r\n{\r\nstruct st_irq_syscfg *ddata = dev_get_drvdata(dev);\r\nreturn regmap_update_bits(ddata->regmap, ddata->syscfg,\r\nST_A9_IRQ_MASK, ddata->config);\r\n}\r\nstatic int __init st_irq_syscfg_init(void)\r\n{\r\nreturn platform_driver_register(&st_irq_syscfg_driver);\r\n}
