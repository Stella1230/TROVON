static void s3c_adc_bat_ext_power_changed(struct power_supply *psy)\r\n{\r\nschedule_delayed_work(&bat_work,\r\nmsecs_to_jiffies(JITTER_DELAY));\r\n}\r\nstatic int gather_samples(struct s3c_adc_client *client, int num, int channel)\r\n{\r\nint value, i;\r\nif (num < 1)\r\nnum = 1;\r\nvalue = 0;\r\nfor (i = 0; i < num; i++)\r\nvalue += s3c_adc_read(client, channel);\r\nvalue /= num;\r\nreturn value;\r\n}\r\nstatic int s3c_adc_backup_bat_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct s3c_adc_bat *bat = power_supply_get_drvdata(psy);\r\nif (!bat) {\r\ndev_err(&psy->dev, "%s: no battery infos ?!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (bat->volt_value < 0 ||\r\njiffies_to_msecs(jiffies - bat->timestamp) >\r\nBAT_POLL_INTERVAL) {\r\nbat->volt_value = gather_samples(bat->client,\r\nbat->pdata->backup_volt_samples,\r\nbat->pdata->backup_volt_channel);\r\nbat->volt_value *= bat->pdata->backup_volt_mult;\r\nbat->timestamp = jiffies;\r\n}\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = bat->volt_value;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN:\r\nval->intval = bat->pdata->backup_volt_min;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nval->intval = bat->pdata->backup_volt_max;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int calc_full_volt(int volt_val, int cur_val, int impedance)\r\n{\r\nreturn volt_val + cur_val * impedance / 1000;\r\n}\r\nstatic int charge_finished(struct s3c_adc_bat *bat)\r\n{\r\nreturn bat->pdata->gpio_inverted ?\r\n!gpio_get_value(bat->pdata->gpio_charge_finished) :\r\ngpio_get_value(bat->pdata->gpio_charge_finished);\r\n}\r\nstatic int s3c_adc_bat_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct s3c_adc_bat *bat = power_supply_get_drvdata(psy);\r\nint new_level;\r\nint full_volt;\r\nconst struct s3c_adc_bat_thresh *lut;\r\nunsigned int lut_size;\r\nif (!bat) {\r\ndev_err(&psy->dev, "no battery infos ?!\n");\r\nreturn -EINVAL;\r\n}\r\nlut = bat->pdata->lut_noac;\r\nlut_size = bat->pdata->lut_noac_cnt;\r\nif (bat->volt_value < 0 || bat->cur_value < 0 ||\r\njiffies_to_msecs(jiffies - bat->timestamp) >\r\nBAT_POLL_INTERVAL) {\r\nbat->volt_value = gather_samples(bat->client,\r\nbat->pdata->volt_samples,\r\nbat->pdata->volt_channel) * bat->pdata->volt_mult;\r\nbat->cur_value = gather_samples(bat->client,\r\nbat->pdata->current_samples,\r\nbat->pdata->current_channel) * bat->pdata->current_mult;\r\nbat->timestamp = jiffies;\r\n}\r\nif (bat->cable_plugged &&\r\n((bat->pdata->gpio_charge_finished < 0) ||\r\n!charge_finished(bat))) {\r\nlut = bat->pdata->lut_acin;\r\nlut_size = bat->pdata->lut_acin_cnt;\r\n}\r\nnew_level = 100000;\r\nfull_volt = calc_full_volt((bat->volt_value / 1000),\r\n(bat->cur_value / 1000), bat->pdata->internal_impedance);\r\nif (full_volt < calc_full_volt(lut->volt, lut->cur,\r\nbat->pdata->internal_impedance)) {\r\nlut_size--;\r\nwhile (lut_size--) {\r\nint lut_volt1;\r\nint lut_volt2;\r\nlut_volt1 = calc_full_volt(lut[0].volt, lut[0].cur,\r\nbat->pdata->internal_impedance);\r\nlut_volt2 = calc_full_volt(lut[1].volt, lut[1].cur,\r\nbat->pdata->internal_impedance);\r\nif (full_volt < lut_volt1 && full_volt >= lut_volt2) {\r\nnew_level = (lut[1].level +\r\n(lut[0].level - lut[1].level) *\r\n(full_volt - lut_volt2) /\r\n(lut_volt1 - lut_volt2)) * 1000;\r\nbreak;\r\n}\r\nnew_level = lut[1].level * 1000;\r\nlut++;\r\n}\r\n}\r\nbat->level = new_level;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (bat->pdata->gpio_charge_finished < 0)\r\nval->intval = bat->level == 100000 ?\r\nPOWER_SUPPLY_STATUS_FULL : bat->status;\r\nelse\r\nval->intval = bat->status;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = 100000;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN:\r\nval->intval = 0;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nval->intval = bat->level;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nval->intval = bat->volt_value;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nval->intval = bat->cur_value;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void s3c_adc_bat_work(struct work_struct *work)\r\n{\r\nstruct s3c_adc_bat *bat = &main_bat;\r\nint is_charged;\r\nint is_plugged;\r\nstatic int was_plugged;\r\nis_plugged = power_supply_am_i_supplied(bat->psy);\r\nbat->cable_plugged = is_plugged;\r\nif (is_plugged != was_plugged) {\r\nwas_plugged = is_plugged;\r\nif (is_plugged) {\r\nif (bat->pdata->enable_charger)\r\nbat->pdata->enable_charger();\r\nbat->status = POWER_SUPPLY_STATUS_CHARGING;\r\n} else {\r\nif (bat->pdata->disable_charger)\r\nbat->pdata->disable_charger();\r\nbat->status = POWER_SUPPLY_STATUS_DISCHARGING;\r\n}\r\n} else {\r\nif ((bat->pdata->gpio_charge_finished >= 0) && is_plugged) {\r\nis_charged = charge_finished(&main_bat);\r\nif (is_charged) {\r\nif (bat->pdata->disable_charger)\r\nbat->pdata->disable_charger();\r\nbat->status = POWER_SUPPLY_STATUS_FULL;\r\n} else {\r\nif (bat->pdata->enable_charger)\r\nbat->pdata->enable_charger();\r\nbat->status = POWER_SUPPLY_STATUS_CHARGING;\r\n}\r\n}\r\n}\r\npower_supply_changed(bat->psy);\r\n}\r\nstatic irqreturn_t s3c_adc_bat_charged(int irq, void *dev_id)\r\n{\r\nschedule_delayed_work(&bat_work,\r\nmsecs_to_jiffies(JITTER_DELAY));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int s3c_adc_bat_probe(struct platform_device *pdev)\r\n{\r\nstruct s3c_adc_client *client;\r\nstruct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;\r\nint ret;\r\nclient = s3c_adc_register(pdev, NULL, NULL, 0);\r\nif (IS_ERR(client)) {\r\ndev_err(&pdev->dev, "cannot register adc\n");\r\nreturn PTR_ERR(client);\r\n}\r\nplatform_set_drvdata(pdev, client);\r\nmain_bat.client = client;\r\nmain_bat.pdata = pdata;\r\nmain_bat.volt_value = -1;\r\nmain_bat.cur_value = -1;\r\nmain_bat.cable_plugged = 0;\r\nmain_bat.status = POWER_SUPPLY_STATUS_DISCHARGING;\r\nmain_bat.psy = power_supply_register(&pdev->dev, &main_bat_desc, NULL);\r\nif (IS_ERR(main_bat.psy)) {\r\nret = PTR_ERR(main_bat.psy);\r\ngoto err_reg_main;\r\n}\r\nif (pdata->backup_volt_mult) {\r\nconst struct power_supply_config psy_cfg\r\n= { .drv_data = &backup_bat, };\r\nbackup_bat.client = client;\r\nbackup_bat.pdata = pdev->dev.platform_data;\r\nbackup_bat.volt_value = -1;\r\nbackup_bat.psy = power_supply_register(&pdev->dev,\r\n&backup_bat_desc,\r\n&psy_cfg);\r\nif (IS_ERR(backup_bat.psy)) {\r\nret = PTR_ERR(backup_bat.psy);\r\ngoto err_reg_backup;\r\n}\r\n}\r\nINIT_DELAYED_WORK(&bat_work, s3c_adc_bat_work);\r\nif (pdata->gpio_charge_finished >= 0) {\r\nret = gpio_request(pdata->gpio_charge_finished, "charged");\r\nif (ret)\r\ngoto err_gpio;\r\nret = request_irq(gpio_to_irq(pdata->gpio_charge_finished),\r\ns3c_adc_bat_charged,\r\nIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,\r\n"battery charged", NULL);\r\nif (ret)\r\ngoto err_irq;\r\n}\r\nif (pdata->init) {\r\nret = pdata->init();\r\nif (ret)\r\ngoto err_platform;\r\n}\r\ndev_info(&pdev->dev, "successfully loaded\n");\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nschedule_delayed_work(&bat_work,\r\nmsecs_to_jiffies(JITTER_DELAY));\r\nreturn 0;\r\nerr_platform:\r\nif (pdata->gpio_charge_finished >= 0)\r\nfree_irq(gpio_to_irq(pdata->gpio_charge_finished), NULL);\r\nerr_irq:\r\nif (pdata->gpio_charge_finished >= 0)\r\ngpio_free(pdata->gpio_charge_finished);\r\nerr_gpio:\r\nif (pdata->backup_volt_mult)\r\npower_supply_unregister(backup_bat.psy);\r\nerr_reg_backup:\r\npower_supply_unregister(main_bat.psy);\r\nerr_reg_main:\r\nreturn ret;\r\n}\r\nstatic int s3c_adc_bat_remove(struct platform_device *pdev)\r\n{\r\nstruct s3c_adc_client *client = platform_get_drvdata(pdev);\r\nstruct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;\r\npower_supply_unregister(main_bat.psy);\r\nif (pdata->backup_volt_mult)\r\npower_supply_unregister(backup_bat.psy);\r\ns3c_adc_release(client);\r\nif (pdata->gpio_charge_finished >= 0) {\r\nfree_irq(gpio_to_irq(pdata->gpio_charge_finished), NULL);\r\ngpio_free(pdata->gpio_charge_finished);\r\n}\r\ncancel_delayed_work(&bat_work);\r\nif (pdata->exit)\r\npdata->exit();\r\nreturn 0;\r\n}\r\nstatic int s3c_adc_bat_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;\r\nif (pdata->gpio_charge_finished >= 0) {\r\nif (device_may_wakeup(&pdev->dev))\r\nenable_irq_wake(\r\ngpio_to_irq(pdata->gpio_charge_finished));\r\nelse {\r\ndisable_irq(gpio_to_irq(pdata->gpio_charge_finished));\r\nmain_bat.pdata->disable_charger();\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c_adc_bat_resume(struct platform_device *pdev)\r\n{\r\nstruct s3c_adc_bat_pdata *pdata = pdev->dev.platform_data;\r\nif (pdata->gpio_charge_finished >= 0) {\r\nif (device_may_wakeup(&pdev->dev))\r\ndisable_irq_wake(\r\ngpio_to_irq(pdata->gpio_charge_finished));\r\nelse\r\nenable_irq(gpio_to_irq(pdata->gpio_charge_finished));\r\n}\r\nschedule_delayed_work(&bat_work,\r\nmsecs_to_jiffies(JITTER_DELAY));\r\nreturn 0;\r\n}
