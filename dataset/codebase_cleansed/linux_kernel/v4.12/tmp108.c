static inline int tmp108_temp_reg_to_mC(s16 val)\r\n{\r\nreturn (val & ~0x0f) * 1000 / 256;\r\n}\r\nstatic inline u16 tmp108_mC_to_temp_reg(int val)\r\n{\r\nreturn (val * 256) / 1000;\r\n}\r\nstatic int tmp108_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *temp)\r\n{\r\nstruct tmp108 *tmp108 = dev_get_drvdata(dev);\r\nunsigned int regval;\r\nint err, hyst;\r\nif (type == hwmon_chip) {\r\nif (attr == hwmon_chip_update_interval) {\r\nerr = regmap_read(tmp108->regmap, TMP108_REG_CONF,\r\n&regval);\r\nif (err < 0)\r\nreturn err;\r\nswitch (regval & TMP108_CONF_CONVRATE_MASK) {\r\ncase TMP108_CONVRATE_0P25HZ:\r\ndefault:\r\n*temp = 4000;\r\nbreak;\r\ncase TMP108_CONVRATE_1HZ:\r\n*temp = 1000;\r\nbreak;\r\ncase TMP108_CONVRATE_4HZ:\r\n*temp = 250;\r\nbreak;\r\ncase TMP108_CONVRATE_16HZ:\r\n*temp = 63;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nif (time_before(jiffies, tmp108->ready_time)) {\r\ndev_dbg(dev, "%s: Conversion not ready yet..\n",\r\n__func__);\r\nreturn -EAGAIN;\r\n}\r\nerr = regmap_read(tmp108->regmap, TMP108_REG_TEMP, &regval);\r\nif (err < 0)\r\nreturn err;\r\n*temp = tmp108_temp_reg_to_mC(regval);\r\nbreak;\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\nerr = regmap_read(tmp108->regmap, attr == hwmon_temp_min ?\r\nTMP108_REG_TLOW : TMP108_REG_THIGH, &regval);\r\nif (err < 0)\r\nreturn err;\r\n*temp = tmp108_temp_reg_to_mC(regval);\r\nbreak;\r\ncase hwmon_temp_min_alarm:\r\ncase hwmon_temp_max_alarm:\r\nerr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &regval);\r\nif (err < 0)\r\nreturn err;\r\n*temp = !!(regval & (attr == hwmon_temp_min_alarm ?\r\nTMP108_CONF_FL : TMP108_CONF_FH));\r\nbreak;\r\ncase hwmon_temp_min_hyst:\r\ncase hwmon_temp_max_hyst:\r\nerr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &regval);\r\nif (err < 0)\r\nreturn err;\r\nswitch (regval & TMP108_CONF_HYSTERESIS_MASK) {\r\ncase TMP108_HYSTERESIS_0C:\r\ndefault:\r\nhyst = 0;\r\nbreak;\r\ncase TMP108_HYSTERESIS_1C:\r\nhyst = 1000;\r\nbreak;\r\ncase TMP108_HYSTERESIS_2C:\r\nhyst = 2000;\r\nbreak;\r\ncase TMP108_HYSTERESIS_4C:\r\nhyst = 4000;\r\nbreak;\r\n}\r\nerr = regmap_read(tmp108->regmap, attr == hwmon_temp_min_hyst ?\r\nTMP108_REG_TLOW : TMP108_REG_THIGH, &regval);\r\nif (err < 0)\r\nreturn err;\r\n*temp = tmp108_temp_reg_to_mC(regval);\r\nif (attr == hwmon_temp_min_hyst)\r\n*temp += hyst;\r\nelse\r\n*temp -= hyst;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tmp108_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long temp)\r\n{\r\nstruct tmp108 *tmp108 = dev_get_drvdata(dev);\r\nu32 regval, mask;\r\nint err;\r\nif (type == hwmon_chip) {\r\nif (attr == hwmon_chip_update_interval) {\r\nif (temp < 156)\r\nmask = TMP108_CONVRATE_16HZ;\r\nelse if (temp < 625)\r\nmask = TMP108_CONVRATE_4HZ;\r\nelse if (temp < 2500)\r\nmask = TMP108_CONVRATE_1HZ;\r\nelse\r\nmask = TMP108_CONVRATE_0P25HZ;\r\nreturn regmap_update_bits(tmp108->regmap,\r\nTMP108_REG_CONF,\r\nTMP108_CONF_CONVRATE_MASK,\r\nmask);\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nswitch (attr) {\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\ntemp = clamp_val(temp, TMP108_TEMP_MIN_MC, TMP108_TEMP_MAX_MC);\r\nreturn regmap_write(tmp108->regmap,\r\nattr == hwmon_temp_min ?\r\nTMP108_REG_TLOW : TMP108_REG_THIGH,\r\ntmp108_mC_to_temp_reg(temp));\r\ncase hwmon_temp_min_hyst:\r\ncase hwmon_temp_max_hyst:\r\ntemp = clamp_val(temp, TMP108_TEMP_MIN_MC, TMP108_TEMP_MAX_MC);\r\nerr = regmap_read(tmp108->regmap,\r\nattr == hwmon_temp_min_hyst ?\r\nTMP108_REG_TLOW : TMP108_REG_THIGH,\r\n&regval);\r\nif (err < 0)\r\nreturn err;\r\nif (attr == hwmon_temp_min_hyst)\r\ntemp -= tmp108_temp_reg_to_mC(regval);\r\nelse\r\ntemp = tmp108_temp_reg_to_mC(regval) - temp;\r\nif (temp < 500)\r\nmask = TMP108_HYSTERESIS_0C;\r\nelse if (temp < 1500)\r\nmask = TMP108_HYSTERESIS_1C;\r\nelse if (temp < 3000)\r\nmask = TMP108_HYSTERESIS_2C;\r\nelse\r\nmask = TMP108_HYSTERESIS_4C;\r\nreturn regmap_update_bits(tmp108->regmap, TMP108_REG_CONF,\r\nTMP108_CONF_HYSTERESIS_MASK, mask);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t tmp108_is_visible(const void *data, enum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nif (type == hwmon_chip && attr == hwmon_chip_update_interval)\r\nreturn 0644;\r\nif (type != hwmon_temp)\r\nreturn 0;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\ncase hwmon_temp_min_alarm:\r\ncase hwmon_temp_max_alarm:\r\nreturn 0444;\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\ncase hwmon_temp_min_hyst:\r\ncase hwmon_temp_max_hyst:\r\nreturn 0644;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void tmp108_restore_config(void *data)\r\n{\r\nstruct tmp108 *tmp108 = data;\r\nregmap_write(tmp108->regmap, TMP108_REG_CONF, tmp108->orig_config);\r\n}\r\nstatic bool tmp108_is_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg != TMP108_REG_TEMP;\r\n}\r\nstatic bool tmp108_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nreturn reg == TMP108_REG_TEMP || reg == TMP108_REG_CONF;\r\n}\r\nstatic int tmp108_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct device *hwmon_dev;\r\nstruct tmp108 *tmp108;\r\nint err;\r\nu32 config;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA)) {\r\ndev_err(dev,\r\n"adapter doesn't support SMBus word transactions\n");\r\nreturn -ENODEV;\r\n}\r\ntmp108 = devm_kzalloc(dev, sizeof(*tmp108), GFP_KERNEL);\r\nif (!tmp108)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, tmp108);\r\ntmp108->regmap = devm_regmap_init_i2c(client, &tmp108_regmap_config);\r\nif (IS_ERR(tmp108->regmap)) {\r\nerr = PTR_ERR(tmp108->regmap);\r\ndev_err(dev, "regmap init failed: %d", err);\r\nreturn err;\r\n}\r\nerr = regmap_read(tmp108->regmap, TMP108_REG_CONF, &config);\r\nif (err < 0) {\r\ndev_err(dev, "error reading config register: %d", err);\r\nreturn err;\r\n}\r\ntmp108->orig_config = config;\r\nconfig &= ~TMP108_CONF_MODE_MASK;\r\nconfig |= TMP108_MODE_CONTINUOUS;\r\nconfig &= ~TMP108_CONF_TM;\r\nerr = regmap_write(tmp108->regmap, TMP108_REG_CONF, config);\r\nif (err < 0) {\r\ndev_err(dev, "error writing config register: %d", err);\r\nreturn err;\r\n}\r\ntmp108->ready_time = jiffies;\r\nif ((tmp108->orig_config & TMP108_CONF_MODE_MASK) ==\r\nTMP108_MODE_SHUTDOWN)\r\ntmp108->ready_time +=\r\nmsecs_to_jiffies(TMP108_CONVERSION_TIME_MS);\r\nerr = devm_add_action_or_reset(dev, tmp108_restore_config, tmp108);\r\nif (err) {\r\ndev_err(dev, "add action or reset failed: %d", err);\r\nreturn err;\r\n}\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ntmp108,\r\n&tmp108_chip_info,\r\nNULL);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}\r\nstatic int __maybe_unused tmp108_suspend(struct device *dev)\r\n{\r\nstruct tmp108 *tmp108 = dev_get_drvdata(dev);\r\nreturn regmap_update_bits(tmp108->regmap, TMP108_REG_CONF,\r\nTMP108_CONF_MODE_MASK, TMP108_MODE_SHUTDOWN);\r\n}\r\nstatic int __maybe_unused tmp108_resume(struct device *dev)\r\n{\r\nstruct tmp108 *tmp108 = dev_get_drvdata(dev);\r\nint err;\r\nerr = regmap_update_bits(tmp108->regmap, TMP108_REG_CONF,\r\nTMP108_CONF_MODE_MASK, TMP108_MODE_CONTINUOUS);\r\ntmp108->ready_time = jiffies +\r\nmsecs_to_jiffies(TMP108_CONVERSION_TIME_MS);\r\nreturn err;\r\n}
