static bool bcma_mdio_wait_value(struct bcma_device *core, u16 reg, u32 mask,\r\nu32 value, int timeout)\r\n{\r\nu32 val;\r\nint i;\r\nfor (i = 0; i < timeout / 10; i++) {\r\nval = bcma_read32(core, reg);\r\nif ((val & mask) == value)\r\nreturn true;\r\nudelay(10);\r\n}\r\ndev_err(&core->dev, "Timeout waiting for reg 0x%X\n", reg);\r\nreturn false;\r\n}\r\nstatic u16 bcma_mdio_phy_read(struct bgmac *bgmac, u8 phyaddr, u8 reg)\r\n{\r\nstruct bcma_device *core;\r\nu16 phy_access_addr;\r\nu16 phy_ctl_addr;\r\nu32 tmp;\r\nBUILD_BUG_ON(BGMAC_PA_DATA_MASK != BCMA_GMAC_CMN_PA_DATA_MASK);\r\nBUILD_BUG_ON(BGMAC_PA_ADDR_MASK != BCMA_GMAC_CMN_PA_ADDR_MASK);\r\nBUILD_BUG_ON(BGMAC_PA_ADDR_SHIFT != BCMA_GMAC_CMN_PA_ADDR_SHIFT);\r\nBUILD_BUG_ON(BGMAC_PA_REG_MASK != BCMA_GMAC_CMN_PA_REG_MASK);\r\nBUILD_BUG_ON(BGMAC_PA_REG_SHIFT != BCMA_GMAC_CMN_PA_REG_SHIFT);\r\nBUILD_BUG_ON(BGMAC_PA_WRITE != BCMA_GMAC_CMN_PA_WRITE);\r\nBUILD_BUG_ON(BGMAC_PA_START != BCMA_GMAC_CMN_PA_START);\r\nBUILD_BUG_ON(BGMAC_PC_EPA_MASK != BCMA_GMAC_CMN_PC_EPA_MASK);\r\nBUILD_BUG_ON(BGMAC_PC_MCT_MASK != BCMA_GMAC_CMN_PC_MCT_MASK);\r\nBUILD_BUG_ON(BGMAC_PC_MCT_SHIFT != BCMA_GMAC_CMN_PC_MCT_SHIFT);\r\nBUILD_BUG_ON(BGMAC_PC_MTE != BCMA_GMAC_CMN_PC_MTE);\r\nif (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {\r\ncore = bgmac->bcma.core->bus->drv_gmac_cmn.core;\r\nphy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;\r\nphy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;\r\n} else {\r\ncore = bgmac->bcma.core;\r\nphy_access_addr = BGMAC_PHY_ACCESS;\r\nphy_ctl_addr = BGMAC_PHY_CNTL;\r\n}\r\ntmp = bcma_read32(core, phy_ctl_addr);\r\ntmp &= ~BGMAC_PC_EPA_MASK;\r\ntmp |= phyaddr;\r\nbcma_write32(core, phy_ctl_addr, tmp);\r\ntmp = BGMAC_PA_START;\r\ntmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;\r\ntmp |= reg << BGMAC_PA_REG_SHIFT;\r\nbcma_write32(core, phy_access_addr, tmp);\r\nif (!bcma_mdio_wait_value(core, phy_access_addr, BGMAC_PA_START, 0,\r\n1000)) {\r\ndev_err(&core->dev, "Reading PHY %d register 0x%X failed\n",\r\nphyaddr, reg);\r\nreturn 0xffff;\r\n}\r\nreturn bcma_read32(core, phy_access_addr) & BGMAC_PA_DATA_MASK;\r\n}\r\nstatic int bcma_mdio_phy_write(struct bgmac *bgmac, u8 phyaddr, u8 reg,\r\nu16 value)\r\n{\r\nstruct bcma_device *core;\r\nu16 phy_access_addr;\r\nu16 phy_ctl_addr;\r\nu32 tmp;\r\nif (bgmac->bcma.core->id.id == BCMA_CORE_4706_MAC_GBIT) {\r\ncore = bgmac->bcma.core->bus->drv_gmac_cmn.core;\r\nphy_access_addr = BCMA_GMAC_CMN_PHY_ACCESS;\r\nphy_ctl_addr = BCMA_GMAC_CMN_PHY_CTL;\r\n} else {\r\ncore = bgmac->bcma.core;\r\nphy_access_addr = BGMAC_PHY_ACCESS;\r\nphy_ctl_addr = BGMAC_PHY_CNTL;\r\n}\r\ntmp = bcma_read32(core, phy_ctl_addr);\r\ntmp &= ~BGMAC_PC_EPA_MASK;\r\ntmp |= phyaddr;\r\nbcma_write32(core, phy_ctl_addr, tmp);\r\nbcma_write32(bgmac->bcma.core, BGMAC_INT_STATUS, BGMAC_IS_MDIO);\r\nif (bcma_read32(bgmac->bcma.core, BGMAC_INT_STATUS) & BGMAC_IS_MDIO)\r\ndev_warn(&core->dev, "Error setting MDIO int\n");\r\ntmp = BGMAC_PA_START;\r\ntmp |= BGMAC_PA_WRITE;\r\ntmp |= phyaddr << BGMAC_PA_ADDR_SHIFT;\r\ntmp |= reg << BGMAC_PA_REG_SHIFT;\r\ntmp |= value;\r\nbcma_write32(core, phy_access_addr, tmp);\r\nif (!bcma_mdio_wait_value(core, phy_access_addr, BGMAC_PA_START, 0,\r\n1000)) {\r\ndev_err(&core->dev, "Writing to PHY %d register 0x%X failed\n",\r\nphyaddr, reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcma_mdio_phy_init(struct bgmac *bgmac)\r\n{\r\nstruct bcma_chipinfo *ci = &bgmac->bcma.core->bus->chipinfo;\r\nu8 i;\r\nif (ci->id == BCMA_CHIP_ID_BCM5356) {\r\nfor (i = 0; i < 5; i++) {\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x008b);\r\nbcma_mdio_phy_write(bgmac, i, 0x15, 0x0100);\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);\r\nbcma_mdio_phy_write(bgmac, i, 0x12, 0x2aaa);\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);\r\n}\r\nreturn;\r\n}\r\nif ((ci->id == BCMA_CHIP_ID_BCM5357 && ci->pkg != 10) ||\r\n(ci->id == BCMA_CHIP_ID_BCM4749 && ci->pkg != 10) ||\r\n(ci->id == BCMA_CHIP_ID_BCM53572 && ci->pkg != 9)) {\r\nstruct bcma_drv_cc *cc = &bgmac->bcma.core->bus->drv_cc;\r\nbcma_chipco_chipctl_maskset(cc, 2, ~0xc0000000, 0);\r\nbcma_chipco_chipctl_maskset(cc, 4, ~0x80000000, 0);\r\nfor (i = 0; i < 5; i++) {\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);\r\nbcma_mdio_phy_write(bgmac, i, 0x16, 0x5284);\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);\r\nbcma_mdio_phy_write(bgmac, i, 0x17, 0x0010);\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000f);\r\nbcma_mdio_phy_write(bgmac, i, 0x16, 0x5296);\r\nbcma_mdio_phy_write(bgmac, i, 0x17, 0x1073);\r\nbcma_mdio_phy_write(bgmac, i, 0x17, 0x9073);\r\nbcma_mdio_phy_write(bgmac, i, 0x16, 0x52b6);\r\nbcma_mdio_phy_write(bgmac, i, 0x17, 0x9273);\r\nbcma_mdio_phy_write(bgmac, i, 0x1f, 0x000b);\r\n}\r\nreturn;\r\n}\r\nif (bgmac->net_dev && bgmac->net_dev->phydev)\r\nphy_init_hw(bgmac->net_dev->phydev);\r\n}\r\nstatic int bcma_mdio_phy_reset(struct mii_bus *bus)\r\n{\r\nstruct bgmac *bgmac = bus->priv;\r\nu8 phyaddr = bgmac->phyaddr;\r\nif (phyaddr == BGMAC_PHY_NOREGS)\r\nreturn 0;\r\nbcma_mdio_phy_write(bgmac, phyaddr, MII_BMCR, BMCR_RESET);\r\nudelay(100);\r\nif (bcma_mdio_phy_read(bgmac, phyaddr, MII_BMCR) & BMCR_RESET)\r\ndev_err(bgmac->dev, "PHY reset failed\n");\r\nbcma_mdio_phy_init(bgmac);\r\nreturn 0;\r\n}\r\nstatic int bcma_mdio_mii_read(struct mii_bus *bus, int mii_id, int regnum)\r\n{\r\nreturn bcma_mdio_phy_read(bus->priv, mii_id, regnum);\r\n}\r\nstatic int bcma_mdio_mii_write(struct mii_bus *bus, int mii_id, int regnum,\r\nu16 value)\r\n{\r\nreturn bcma_mdio_phy_write(bus->priv, mii_id, regnum, value);\r\n}\r\nstruct mii_bus *bcma_mdio_mii_register(struct bgmac *bgmac)\r\n{\r\nstruct bcma_device *core = bgmac->bcma.core;\r\nstruct mii_bus *mii_bus;\r\nint err;\r\nmii_bus = mdiobus_alloc();\r\nif (!mii_bus) {\r\nerr = -ENOMEM;\r\ngoto err;\r\n}\r\nmii_bus->name = "bcma_mdio mii bus";\r\nsprintf(mii_bus->id, "%s-%d-%d", "bcma_mdio", core->bus->num,\r\ncore->core_unit);\r\nmii_bus->priv = bgmac;\r\nmii_bus->read = bcma_mdio_mii_read;\r\nmii_bus->write = bcma_mdio_mii_write;\r\nmii_bus->reset = bcma_mdio_phy_reset;\r\nmii_bus->parent = &core->dev;\r\nmii_bus->phy_mask = ~(1 << bgmac->phyaddr);\r\nerr = mdiobus_register(mii_bus);\r\nif (err) {\r\ndev_err(&core->dev, "Registration of mii bus failed\n");\r\ngoto err_free_bus;\r\n}\r\nreturn mii_bus;\r\nerr_free_bus:\r\nmdiobus_free(mii_bus);\r\nerr:\r\nreturn ERR_PTR(err);\r\n}\r\nvoid bcma_mdio_mii_unregister(struct mii_bus *mii_bus)\r\n{\r\nif (!mii_bus)\r\nreturn;\r\nmdiobus_unregister(mii_bus);\r\nmdiobus_free(mii_bus);\r\n}
