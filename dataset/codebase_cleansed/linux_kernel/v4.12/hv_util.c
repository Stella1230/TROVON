static void perform_shutdown(struct work_struct *dummy)\r\n{\r\norderly_poweroff(true);\r\n}\r\nstatic void shutdown_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nbool execute_shutdown = false;\r\nu8 *shut_txf_buf = util_shutdown.recv_buffer;\r\nstruct shutdown_msg_data *shutdown_msg;\r\nstruct icmsg_hdr *icmsghdrp;\r\nvmbus_recvpacket(channel, shut_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&shut_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nif (vmbus_prep_negotiate_resp(icmsghdrp, shut_txf_buf,\r\nfw_versions, FW_VER_COUNT,\r\nsd_versions, SD_VER_COUNT,\r\nNULL, &sd_srv_version)) {\r\npr_info("Shutdown IC version %d.%d\n",\r\nsd_srv_version >> 16,\r\nsd_srv_version & 0xFFFF);\r\n}\r\n} else {\r\nshutdown_msg =\r\n(struct shutdown_msg_data *)&shut_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nswitch (shutdown_msg->flags) {\r\ncase 0:\r\ncase 1:\r\nicmsghdrp->status = HV_S_OK;\r\nexecute_shutdown = true;\r\npr_info("Shutdown request received -"\r\n" graceful shutdown initiated\n");\r\nbreak;\r\ndefault:\r\nicmsghdrp->status = HV_E_FAIL;\r\nexecute_shutdown = false;\r\npr_info("Shutdown request received -"\r\n" Invalid request\n");\r\nbreak;\r\n}\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, shut_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\nif (execute_shutdown == true)\r\nschedule_work(&shutdown_work);\r\n}\r\nstatic void hv_set_host_time(struct work_struct *work)\r\n{\r\nstruct adj_time_work *wrk;\r\nstruct timespec64 host_ts;\r\nu64 reftime, newtime;\r\nwrk = container_of(work, struct adj_time_work, work);\r\nreftime = hyperv_cs->read(hyperv_cs);\r\nnewtime = wrk->host_time + (reftime - wrk->ref_time);\r\nhost_ts = ns_to_timespec64((newtime - WLTIMEDELTA) * 100);\r\ndo_settimeofday64(&host_ts);\r\n}\r\nstatic inline void adj_guesttime(u64 hosttime, u64 reftime, u8 adj_flags)\r\n{\r\nunsigned long flags;\r\nu64 cur_reftime;\r\nif (adj_flags & ICTIMESYNCFLAG_SYNC) {\r\nif (work_pending(&wrk.work))\r\nreturn;\r\nwrk.host_time = hosttime;\r\nwrk.ref_time = reftime;\r\nwrk.flags = adj_flags;\r\nschedule_work(&wrk.work);\r\n} else {\r\nspin_lock_irqsave(&host_ts.lock, flags);\r\ncur_reftime = hyperv_cs->read(hyperv_cs);\r\nhost_ts.host_time = hosttime;\r\nhost_ts.ref_time = cur_reftime;\r\nktime_get_snapshot(&host_ts.snap);\r\nif (ts_srv_version > TS_VERSION_3)\r\nhost_ts.host_time += (cur_reftime - reftime);\r\nspin_unlock_irqrestore(&host_ts.lock, flags);\r\n}\r\n}\r\nstatic void timesync_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct ictimesync_data *timedatap;\r\nstruct ictimesync_ref_data *refdata;\r\nu8 *time_txf_buf = util_timesynch.recv_buffer;\r\nvmbus_recvpacket(channel, time_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (recvlen > 0) {\r\nicmsghdrp = (struct icmsg_hdr *)&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nif (vmbus_prep_negotiate_resp(icmsghdrp, time_txf_buf,\r\nfw_versions, FW_VER_COUNT,\r\nts_versions, TS_VER_COUNT,\r\nNULL, &ts_srv_version)) {\r\npr_info("TimeSync IC version %d.%d\n",\r\nts_srv_version >> 16,\r\nts_srv_version & 0xFFFF);\r\n}\r\n} else {\r\nif (ts_srv_version > TS_VERSION_3) {\r\nrefdata = (struct ictimesync_ref_data *)\r\n&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nadj_guesttime(refdata->parenttime,\r\nrefdata->vmreferencetime,\r\nrefdata->flags);\r\n} else {\r\ntimedatap = (struct ictimesync_data *)\r\n&time_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nadj_guesttime(timedatap->parenttime,\r\n0,\r\ntimedatap->flags);\r\n}\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, time_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic void heartbeat_onchannelcallback(void *context)\r\n{\r\nstruct vmbus_channel *channel = context;\r\nu32 recvlen;\r\nu64 requestid;\r\nstruct icmsg_hdr *icmsghdrp;\r\nstruct heartbeat_msg_data *heartbeat_msg;\r\nu8 *hbeat_txf_buf = util_heartbeat.recv_buffer;\r\nwhile (1) {\r\nvmbus_recvpacket(channel, hbeat_txf_buf,\r\nPAGE_SIZE, &recvlen, &requestid);\r\nif (!recvlen)\r\nbreak;\r\nicmsghdrp = (struct icmsg_hdr *)&hbeat_txf_buf[\r\nsizeof(struct vmbuspipe_hdr)];\r\nif (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {\r\nif (vmbus_prep_negotiate_resp(icmsghdrp,\r\nhbeat_txf_buf,\r\nfw_versions, FW_VER_COUNT,\r\nhb_versions, HB_VER_COUNT,\r\nNULL, &hb_srv_version)) {\r\npr_info("Heartbeat IC version %d.%d\n",\r\nhb_srv_version >> 16,\r\nhb_srv_version & 0xFFFF);\r\n}\r\n} else {\r\nheartbeat_msg =\r\n(struct heartbeat_msg_data *)&hbeat_txf_buf[\r\nsizeof(struct vmbuspipe_hdr) +\r\nsizeof(struct icmsg_hdr)];\r\nheartbeat_msg->seq_num += 1;\r\n}\r\nicmsghdrp->icflags = ICMSGHDRFLAG_TRANSACTION\r\n| ICMSGHDRFLAG_RESPONSE;\r\nvmbus_sendpacket(channel, hbeat_txf_buf,\r\nrecvlen, requestid,\r\nVM_PKT_DATA_INBAND, 0);\r\n}\r\n}\r\nstatic int util_probe(struct hv_device *dev,\r\nconst struct hv_vmbus_device_id *dev_id)\r\n{\r\nstruct hv_util_service *srv =\r\n(struct hv_util_service *)dev_id->driver_data;\r\nint ret;\r\nsrv->recv_buffer = kmalloc(PAGE_SIZE * 4, GFP_KERNEL);\r\nif (!srv->recv_buffer)\r\nreturn -ENOMEM;\r\nsrv->channel = dev->channel;\r\nif (srv->util_init) {\r\nret = srv->util_init(srv);\r\nif (ret) {\r\nret = -ENODEV;\r\ngoto error1;\r\n}\r\n}\r\nset_channel_read_mode(dev->channel, HV_CALL_DIRECT);\r\nhv_set_drvdata(dev, srv);\r\nret = vmbus_open(dev->channel, 4 * PAGE_SIZE, 4 * PAGE_SIZE, NULL, 0,\r\nsrv->util_cb, dev->channel);\r\nif (ret)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nif (srv->util_deinit)\r\nsrv->util_deinit();\r\nerror1:\r\nkfree(srv->recv_buffer);\r\nreturn ret;\r\n}\r\nstatic int util_remove(struct hv_device *dev)\r\n{\r\nstruct hv_util_service *srv = hv_get_drvdata(dev);\r\nif (srv->util_deinit)\r\nsrv->util_deinit();\r\nvmbus_close(dev->channel);\r\nkfree(srv->recv_buffer);\r\nreturn 0;\r\n}\r\nstatic int hv_ptp_enable(struct ptp_clock_info *info,\r\nstruct ptp_clock_request *request, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int hv_ptp_settime(struct ptp_clock_info *p, const struct timespec64 *ts)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int hv_ptp_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int hv_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int hv_ptp_gettime(struct ptp_clock_info *info, struct timespec64 *ts)\r\n{\r\nunsigned long flags;\r\nu64 newtime, reftime;\r\nspin_lock_irqsave(&host_ts.lock, flags);\r\nreftime = hyperv_cs->read(hyperv_cs);\r\nnewtime = host_ts.host_time + (reftime - host_ts.ref_time);\r\n*ts = ns_to_timespec64((newtime - WLTIMEDELTA) * 100);\r\nspin_unlock_irqrestore(&host_ts.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int hv_ptp_get_syncdevicetime(ktime_t *device,\r\nstruct system_counterval_t *system,\r\nvoid *ctx)\r\n{\r\nsystem->cs = hyperv_cs;\r\nsystem->cycles = host_ts.ref_time;\r\n*device = ns_to_ktime((host_ts.host_time - WLTIMEDELTA) * 100);\r\nreturn 0;\r\n}\r\nstatic int hv_ptp_getcrosststamp(struct ptp_clock_info *ptp,\r\nstruct system_device_crosststamp *xtstamp)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&host_ts.lock, flags);\r\nret = get_device_system_crosststamp(hv_ptp_get_syncdevicetime,\r\nNULL, &host_ts.snap, xtstamp);\r\nspin_unlock_irqrestore(&host_ts.lock, flags);\r\nreturn ret;\r\n}\r\nstatic int hv_timesync_init(struct hv_util_service *srv)\r\n{\r\nif (!hyperv_cs)\r\nreturn -ENODEV;\r\nspin_lock_init(&host_ts.lock);\r\nINIT_WORK(&wrk.work, hv_set_host_time);\r\nhv_ptp_clock = ptp_clock_register(&ptp_hyperv_info, NULL);\r\nif (IS_ERR_OR_NULL(hv_ptp_clock)) {\r\npr_err("cannot register PTP clock: %ld\n",\r\nPTR_ERR(hv_ptp_clock));\r\nhv_ptp_clock = NULL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hv_timesync_deinit(void)\r\n{\r\nif (hv_ptp_clock)\r\nptp_clock_unregister(hv_ptp_clock);\r\ncancel_work_sync(&wrk.work);\r\n}\r\nstatic int __init init_hyperv_utils(void)\r\n{\r\npr_info("Registering HyperV Utility Driver\n");\r\nreturn vmbus_driver_register(&util_drv);\r\n}\r\nstatic void exit_hyperv_utils(void)\r\n{\r\npr_info("De-Registered HyperV Utility Driver\n");\r\nvmbus_driver_unregister(&util_drv);\r\n}
