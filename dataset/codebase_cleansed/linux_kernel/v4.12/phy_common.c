int b43_phy_allocate(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &(dev->phy);\r\nint err;\r\nphy->ops = NULL;\r\nswitch (phy->type) {\r\ncase B43_PHYTYPE_G:\r\n#ifdef CONFIG_B43_PHY_G\r\nphy->ops = &b43_phyops_g;\r\n#endif\r\nbreak;\r\ncase B43_PHYTYPE_N:\r\n#ifdef CONFIG_B43_PHY_N\r\nphy->ops = &b43_phyops_n;\r\n#endif\r\nbreak;\r\ncase B43_PHYTYPE_LP:\r\n#ifdef CONFIG_B43_PHY_LP\r\nphy->ops = &b43_phyops_lp;\r\n#endif\r\nbreak;\r\ncase B43_PHYTYPE_HT:\r\n#ifdef CONFIG_B43_PHY_HT\r\nphy->ops = &b43_phyops_ht;\r\n#endif\r\nbreak;\r\ncase B43_PHYTYPE_LCN:\r\n#ifdef CONFIG_B43_PHY_LCN\r\nphy->ops = &b43_phyops_lcn;\r\n#endif\r\nbreak;\r\ncase B43_PHYTYPE_AC:\r\n#ifdef CONFIG_B43_PHY_AC\r\nphy->ops = &b43_phyops_ac;\r\n#endif\r\nbreak;\r\n}\r\nif (B43_WARN_ON(!phy->ops))\r\nreturn -ENODEV;\r\nerr = phy->ops->allocate(dev);\r\nif (err)\r\nphy->ops = NULL;\r\nreturn err;\r\n}\r\nvoid b43_phy_free(struct b43_wldev *dev)\r\n{\r\ndev->phy.ops->free(dev);\r\ndev->phy.ops = NULL;\r\n}\r\nint b43_phy_init(struct b43_wldev *dev)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nconst struct b43_phy_operations *ops = phy->ops;\r\nint err;\r\nif (!phy->chandef) {\r\nphy->chandef = &dev->wl->hw->conf.chandef;\r\nphy->channel = phy->chandef->chan->hw_value;\r\n}\r\nphy->ops->switch_analog(dev, true);\r\nb43_software_rfkill(dev, false);\r\nerr = ops->init(dev);\r\nif (err) {\r\nb43err(dev->wl, "PHY init failed\n");\r\ngoto err_block_rf;\r\n}\r\nphy->do_full_init = false;\r\nerr = b43_switch_channel(dev, phy->channel);\r\nif (err) {\r\nb43err(dev->wl, "PHY init: Channel switch to default failed\n");\r\ngoto err_phy_exit;\r\n}\r\nreturn 0;\r\nerr_phy_exit:\r\nphy->do_full_init = true;\r\nif (ops->exit)\r\nops->exit(dev);\r\nerr_block_rf:\r\nb43_software_rfkill(dev, true);\r\nreturn err;\r\n}\r\nvoid b43_phy_exit(struct b43_wldev *dev)\r\n{\r\nconst struct b43_phy_operations *ops = dev->phy.ops;\r\nb43_software_rfkill(dev, true);\r\ndev->phy.do_full_init = true;\r\nif (ops->exit)\r\nops->exit(dev);\r\n}\r\nbool b43_has_hardware_pctl(struct b43_wldev *dev)\r\n{\r\nif (!dev->phy.hardware_power_control)\r\nreturn false;\r\nif (!dev->phy.ops->supports_hwpctl)\r\nreturn false;\r\nreturn dev->phy.ops->supports_hwpctl(dev);\r\n}\r\nvoid b43_radio_lock(struct b43_wldev *dev)\r\n{\r\nu32 macctl;\r\n#if B43_DEBUG\r\nB43_WARN_ON(dev->phy.radio_locked);\r\ndev->phy.radio_locked = true;\r\n#endif\r\nmacctl = b43_read32(dev, B43_MMIO_MACCTL);\r\nmacctl |= B43_MACCTL_RADIOLOCK;\r\nb43_write32(dev, B43_MMIO_MACCTL, macctl);\r\nb43_read32(dev, B43_MMIO_MACCTL);\r\nudelay(10);\r\n}\r\nvoid b43_radio_unlock(struct b43_wldev *dev)\r\n{\r\nu32 macctl;\r\n#if B43_DEBUG\r\nB43_WARN_ON(!dev->phy.radio_locked);\r\ndev->phy.radio_locked = false;\r\n#endif\r\nb43_read16(dev, B43_MMIO_PHY_VER);\r\nmacctl = b43_read32(dev, B43_MMIO_MACCTL);\r\nmacctl &= ~B43_MACCTL_RADIOLOCK;\r\nb43_write32(dev, B43_MMIO_MACCTL, macctl);\r\n}\r\nvoid b43_phy_lock(struct b43_wldev *dev)\r\n{\r\n#if B43_DEBUG\r\nB43_WARN_ON(dev->phy.phy_locked);\r\ndev->phy.phy_locked = true;\r\n#endif\r\nB43_WARN_ON(dev->dev->core_rev < 3);\r\nif (!b43_is_mode(dev->wl, NL80211_IFTYPE_AP))\r\nb43_power_saving_ctl_bits(dev, B43_PS_AWAKE);\r\n}\r\nvoid b43_phy_unlock(struct b43_wldev *dev)\r\n{\r\n#if B43_DEBUG\r\nB43_WARN_ON(!dev->phy.phy_locked);\r\ndev->phy.phy_locked = false;\r\n#endif\r\nB43_WARN_ON(dev->dev->core_rev < 3);\r\nif (!b43_is_mode(dev->wl, NL80211_IFTYPE_AP))\r\nb43_power_saving_ctl_bits(dev, 0);\r\n}\r\nstatic inline void assert_mac_suspended(struct b43_wldev *dev)\r\n{\r\nif (!B43_DEBUG)\r\nreturn;\r\nif ((b43_status(dev) >= B43_STAT_INITIALIZED) &&\r\n(dev->mac_suspended <= 0)) {\r\nb43dbg(dev->wl, "PHY/RADIO register access with "\r\n"enabled MAC.\n");\r\ndump_stack();\r\n}\r\n}\r\nu16 b43_radio_read(struct b43_wldev *dev, u16 reg)\r\n{\r\nassert_mac_suspended(dev);\r\ndev->phy.writes_counter = 0;\r\nreturn dev->phy.ops->radio_read(dev, reg);\r\n}\r\nvoid b43_radio_write(struct b43_wldev *dev, u16 reg, u16 value)\r\n{\r\nassert_mac_suspended(dev);\r\nif (b43_bus_host_is_pci(dev->dev) &&\r\n++dev->phy.writes_counter > B43_MAX_WRITES_IN_ROW) {\r\nb43_read32(dev, B43_MMIO_MACCTL);\r\ndev->phy.writes_counter = 1;\r\n}\r\ndev->phy.ops->radio_write(dev, reg, value);\r\n}\r\nvoid b43_radio_mask(struct b43_wldev *dev, u16 offset, u16 mask)\r\n{\r\nb43_radio_write16(dev, offset,\r\nb43_radio_read16(dev, offset) & mask);\r\n}\r\nvoid b43_radio_set(struct b43_wldev *dev, u16 offset, u16 set)\r\n{\r\nb43_radio_write16(dev, offset,\r\nb43_radio_read16(dev, offset) | set);\r\n}\r\nvoid b43_radio_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)\r\n{\r\nb43_radio_write16(dev, offset,\r\n(b43_radio_read16(dev, offset) & mask) | set);\r\n}\r\nbool b43_radio_wait_value(struct b43_wldev *dev, u16 offset, u16 mask,\r\nu16 value, int delay, int timeout)\r\n{\r\nu16 val;\r\nint i;\r\nfor (i = 0; i < timeout; i += delay) {\r\nval = b43_radio_read(dev, offset);\r\nif ((val & mask) == value)\r\nreturn true;\r\nudelay(delay);\r\n}\r\nreturn false;\r\n}\r\nu16 b43_phy_read(struct b43_wldev *dev, u16 reg)\r\n{\r\nassert_mac_suspended(dev);\r\ndev->phy.writes_counter = 0;\r\nif (dev->phy.ops->phy_read)\r\nreturn dev->phy.ops->phy_read(dev, reg);\r\nb43_write16f(dev, B43_MMIO_PHY_CONTROL, reg);\r\nreturn b43_read16(dev, B43_MMIO_PHY_DATA);\r\n}\r\nvoid b43_phy_write(struct b43_wldev *dev, u16 reg, u16 value)\r\n{\r\nassert_mac_suspended(dev);\r\nif (b43_bus_host_is_pci(dev->dev) &&\r\n++dev->phy.writes_counter > B43_MAX_WRITES_IN_ROW) {\r\nb43_read16(dev, B43_MMIO_PHY_VER);\r\ndev->phy.writes_counter = 1;\r\n}\r\nif (dev->phy.ops->phy_write)\r\nreturn dev->phy.ops->phy_write(dev, reg, value);\r\nb43_write16f(dev, B43_MMIO_PHY_CONTROL, reg);\r\nb43_write16(dev, B43_MMIO_PHY_DATA, value);\r\n}\r\nvoid b43_phy_copy(struct b43_wldev *dev, u16 destreg, u16 srcreg)\r\n{\r\nb43_phy_write(dev, destreg, b43_phy_read(dev, srcreg));\r\n}\r\nvoid b43_phy_mask(struct b43_wldev *dev, u16 offset, u16 mask)\r\n{\r\nif (dev->phy.ops->phy_maskset) {\r\nassert_mac_suspended(dev);\r\ndev->phy.ops->phy_maskset(dev, offset, mask, 0);\r\n} else {\r\nb43_phy_write(dev, offset,\r\nb43_phy_read(dev, offset) & mask);\r\n}\r\n}\r\nvoid b43_phy_set(struct b43_wldev *dev, u16 offset, u16 set)\r\n{\r\nif (dev->phy.ops->phy_maskset) {\r\nassert_mac_suspended(dev);\r\ndev->phy.ops->phy_maskset(dev, offset, 0xFFFF, set);\r\n} else {\r\nb43_phy_write(dev, offset,\r\nb43_phy_read(dev, offset) | set);\r\n}\r\n}\r\nvoid b43_phy_maskset(struct b43_wldev *dev, u16 offset, u16 mask, u16 set)\r\n{\r\nif (dev->phy.ops->phy_maskset) {\r\nassert_mac_suspended(dev);\r\ndev->phy.ops->phy_maskset(dev, offset, mask, set);\r\n} else {\r\nb43_phy_write(dev, offset,\r\n(b43_phy_read(dev, offset) & mask) | set);\r\n}\r\n}\r\nvoid b43_phy_put_into_reset(struct b43_wldev *dev)\r\n{\r\nu32 tmp;\r\nswitch (dev->dev->bus_type) {\r\n#ifdef CONFIG_B43_BCMA\r\ncase B43_BUS_BCMA:\r\ntmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\r\ntmp &= ~B43_BCMA_IOCTL_GMODE;\r\ntmp |= B43_BCMA_IOCTL_PHY_RESET;\r\ntmp |= BCMA_IOCTL_FGC;\r\nbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\r\nudelay(1);\r\ntmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\r\ntmp &= ~BCMA_IOCTL_FGC;\r\nbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\r\nudelay(1);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_B43_SSB\r\ncase B43_BUS_SSB:\r\ntmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\ntmp &= ~B43_TMSLOW_GMODE;\r\ntmp |= B43_TMSLOW_PHYRESET;\r\ntmp |= SSB_TMSLOW_FGC;\r\nssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\r\nusleep_range(1000, 2000);\r\ntmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\ntmp &= ~SSB_TMSLOW_FGC;\r\nssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\r\nusleep_range(1000, 2000);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nvoid b43_phy_take_out_of_reset(struct b43_wldev *dev)\r\n{\r\nu32 tmp;\r\nswitch (dev->dev->bus_type) {\r\n#ifdef CONFIG_B43_BCMA\r\ncase B43_BUS_BCMA:\r\ntmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\r\ntmp &= ~B43_BCMA_IOCTL_PHY_RESET;\r\ntmp &= ~B43_BCMA_IOCTL_PHY_CLKEN;\r\ntmp |= BCMA_IOCTL_FGC;\r\nbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\r\nudelay(1);\r\ntmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\r\ntmp &= ~BCMA_IOCTL_FGC;\r\ntmp |= B43_BCMA_IOCTL_PHY_CLKEN;\r\nbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\r\nudelay(1);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_B43_SSB\r\ncase B43_BUS_SSB:\r\ntmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\ntmp &= ~B43_TMSLOW_PHYRESET;\r\ntmp &= ~B43_TMSLOW_PHYCLKEN;\r\ntmp |= SSB_TMSLOW_FGC;\r\nssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\r\nssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\nusleep_range(1000, 2000);\r\ntmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\ntmp &= ~SSB_TMSLOW_FGC;\r\ntmp |= B43_TMSLOW_PHYCLKEN;\r\nssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\r\nssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\nusleep_range(1000, 2000);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nint b43_switch_channel(struct b43_wldev *dev, unsigned int new_channel)\r\n{\r\nstruct b43_phy *phy = &(dev->phy);\r\nu16 channelcookie, savedcookie;\r\nint err;\r\nchannelcookie = new_channel;\r\nif (b43_current_band(dev->wl) == NL80211_BAND_5GHZ)\r\nchannelcookie |= B43_SHM_SH_CHAN_5GHZ;\r\nif (0)\r\nchannelcookie |= B43_SHM_SH_CHAN_40MHZ;\r\nsavedcookie = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN);\r\nb43_shm_write16(dev, B43_SHM_SHARED, B43_SHM_SH_CHAN, channelcookie);\r\nerr = phy->ops->switch_channel(dev, new_channel);\r\nif (err)\r\ngoto err_restore_cookie;\r\nmsleep(8);\r\nreturn 0;\r\nerr_restore_cookie:\r\nb43_shm_write16(dev, B43_SHM_SHARED,\r\nB43_SHM_SH_CHAN, savedcookie);\r\nreturn err;\r\n}\r\nvoid b43_software_rfkill(struct b43_wldev *dev, bool blocked)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nb43_mac_suspend(dev);\r\nphy->ops->software_rfkill(dev, blocked);\r\nphy->radio_on = !blocked;\r\nb43_mac_enable(dev);\r\n}\r\nvoid b43_phy_txpower_adjust_work(struct work_struct *work)\r\n{\r\nstruct b43_wl *wl = container_of(work, struct b43_wl,\r\ntxpower_adjust_work);\r\nstruct b43_wldev *dev;\r\nmutex_lock(&wl->mutex);\r\ndev = wl->current_dev;\r\nif (likely(dev && (b43_status(dev) >= B43_STAT_STARTED)))\r\ndev->phy.ops->adjust_txpower(dev);\r\nmutex_unlock(&wl->mutex);\r\n}\r\nvoid b43_phy_txpower_check(struct b43_wldev *dev, unsigned int flags)\r\n{\r\nstruct b43_phy *phy = &dev->phy;\r\nunsigned long now = jiffies;\r\nenum b43_txpwr_result result;\r\nif (!(flags & B43_TXPWR_IGNORE_TIME)) {\r\nif (time_before(now, phy->next_txpwr_check_time))\r\nreturn;\r\n}\r\nphy->next_txpwr_check_time = round_jiffies(now + (HZ * 2));\r\nif ((dev->dev->board_vendor == SSB_BOARDVENDOR_BCM) &&\r\n(dev->dev->board_type == SSB_BOARD_BU4306))\r\nreturn;\r\nresult = phy->ops->recalc_txpower(dev, !!(flags & B43_TXPWR_IGNORE_TSSI));\r\nif (result == B43_TXPWR_RES_DONE)\r\nreturn;\r\nB43_WARN_ON(result != B43_TXPWR_RES_NEED_ADJUST);\r\nB43_WARN_ON(phy->ops->adjust_txpower == NULL);\r\nieee80211_queue_work(dev->wl->hw, &dev->wl->txpower_adjust_work);\r\n}\r\nint b43_phy_shm_tssi_read(struct b43_wldev *dev, u16 shm_offset)\r\n{\r\nconst bool is_ofdm = (shm_offset != B43_SHM_SH_TSSI_CCK);\r\nunsigned int a, b, c, d;\r\nunsigned int average;\r\nu32 tmp;\r\ntmp = b43_shm_read32(dev, B43_SHM_SHARED, shm_offset);\r\na = tmp & 0xFF;\r\nb = (tmp >> 8) & 0xFF;\r\nc = (tmp >> 16) & 0xFF;\r\nd = (tmp >> 24) & 0xFF;\r\nif (a == 0 || a == B43_TSSI_MAX ||\r\nb == 0 || b == B43_TSSI_MAX ||\r\nc == 0 || c == B43_TSSI_MAX ||\r\nd == 0 || d == B43_TSSI_MAX)\r\nreturn -ENOENT;\r\ntmp = B43_TSSI_MAX | (B43_TSSI_MAX << 8) |\r\n(B43_TSSI_MAX << 16) | (B43_TSSI_MAX << 24);\r\nb43_shm_write32(dev, B43_SHM_SHARED, shm_offset, tmp);\r\nif (is_ofdm) {\r\na = (a + 32) & 0x3F;\r\nb = (b + 32) & 0x3F;\r\nc = (c + 32) & 0x3F;\r\nd = (d + 32) & 0x3F;\r\n}\r\naverage = (a + b + c + d + 2) / 4;\r\nif (is_ofdm) {\r\nif (b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_HOSTF1)\r\n& B43_HF_CCKBOOST)\r\naverage = (average >= 13) ? (average - 13) : 0;\r\n}\r\nreturn average;\r\n}\r\nvoid b43_phyop_switch_analog_generic(struct b43_wldev *dev, bool on)\r\n{\r\nb43_write16(dev, B43_MMIO_PHY0, on ? 0 : 0xF4);\r\n}\r\nbool b43_is_40mhz(struct b43_wldev *dev)\r\n{\r\nreturn dev->phy.chandef->width == NL80211_CHAN_WIDTH_40;\r\n}\r\nvoid b43_phy_force_clock(struct b43_wldev *dev, bool force)\r\n{\r\nu32 tmp;\r\nWARN_ON(dev->phy.type != B43_PHYTYPE_N &&\r\ndev->phy.type != B43_PHYTYPE_HT &&\r\ndev->phy.type != B43_PHYTYPE_AC);\r\nswitch (dev->dev->bus_type) {\r\n#ifdef CONFIG_B43_BCMA\r\ncase B43_BUS_BCMA:\r\ntmp = bcma_aread32(dev->dev->bdev, BCMA_IOCTL);\r\nif (force)\r\ntmp |= BCMA_IOCTL_FGC;\r\nelse\r\ntmp &= ~BCMA_IOCTL_FGC;\r\nbcma_awrite32(dev->dev->bdev, BCMA_IOCTL, tmp);\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_B43_SSB\r\ncase B43_BUS_SSB:\r\ntmp = ssb_read32(dev->dev->sdev, SSB_TMSLOW);\r\nif (force)\r\ntmp |= SSB_TMSLOW_FGC;\r\nelse\r\ntmp &= ~SSB_TMSLOW_FGC;\r\nssb_write32(dev->dev->sdev, SSB_TMSLOW, tmp);\r\nbreak;\r\n#endif\r\n}\r\n}\r\nstruct b43_c32 b43_cordic(int theta)\r\n{\r\nstatic const u32 arctg[] = {\r\n2949120, 1740967, 919879, 466945, 234379, 117304,\r\n58666, 29335, 14668, 7334, 3667, 1833,\r\n917, 458, 229, 115, 57, 29,\r\n};\r\nu8 i;\r\ns32 tmp;\r\ns8 signx = 1;\r\nu32 angle = 0;\r\nstruct b43_c32 ret = { .i = 39797, .q = 0, };\r\nwhile (theta > (180 << 16))\r\ntheta -= (360 << 16);\r\nwhile (theta < -(180 << 16))\r\ntheta += (360 << 16);\r\nif (theta > (90 << 16)) {\r\ntheta -= (180 << 16);\r\nsignx = -1;\r\n} else if (theta < -(90 << 16)) {\r\ntheta += (180 << 16);\r\nsignx = -1;\r\n}\r\nfor (i = 0; i <= 17; i++) {\r\nif (theta > angle) {\r\ntmp = ret.i - (ret.q >> i);\r\nret.q += ret.i >> i;\r\nret.i = tmp;\r\nangle += arctg[i];\r\n} else {\r\ntmp = ret.i + (ret.q >> i);\r\nret.q -= ret.i >> i;\r\nret.i = tmp;\r\nangle -= arctg[i];\r\n}\r\n}\r\nret.i *= signx;\r\nret.q *= signx;\r\nreturn ret;\r\n}
