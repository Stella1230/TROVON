static int fsl_mc_io_set_dpmcp(struct fsl_mc_io *mc_io,\r\nstruct fsl_mc_device *dpmcp_dev)\r\n{\r\nint error;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn -EINVAL;\r\nif (WARN_ON(mc_io->dpmcp_dev))\r\nreturn -EINVAL;\r\nif (WARN_ON(dpmcp_dev->mc_io))\r\nreturn -EINVAL;\r\nerror = dpmcp_open(mc_io,\r\n0,\r\ndpmcp_dev->obj_desc.id,\r\n&dpmcp_dev->mc_handle);\r\nif (error < 0)\r\nreturn error;\r\nmc_io->dpmcp_dev = dpmcp_dev;\r\ndpmcp_dev->mc_io = mc_io;\r\nreturn 0;\r\n}\r\nstatic void fsl_mc_io_unset_dpmcp(struct fsl_mc_io *mc_io)\r\n{\r\nint error;\r\nstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn;\r\nif (WARN_ON(dpmcp_dev->mc_io != mc_io))\r\nreturn;\r\nerror = dpmcp_close(mc_io,\r\n0,\r\ndpmcp_dev->mc_handle);\r\nif (error < 0) {\r\ndev_err(&dpmcp_dev->dev, "dpmcp_close() failed: %d\n",\r\nerror);\r\n}\r\nmc_io->dpmcp_dev = NULL;\r\ndpmcp_dev->mc_io = NULL;\r\n}\r\nint __must_check fsl_create_mc_io(struct device *dev,\r\nphys_addr_t mc_portal_phys_addr,\r\nu32 mc_portal_size,\r\nstruct fsl_mc_device *dpmcp_dev,\r\nu32 flags, struct fsl_mc_io **new_mc_io)\r\n{\r\nint error;\r\nstruct fsl_mc_io *mc_io;\r\nvoid __iomem *mc_portal_virt_addr;\r\nstruct resource *res;\r\nmc_io = devm_kzalloc(dev, sizeof(*mc_io), GFP_KERNEL);\r\nif (!mc_io)\r\nreturn -ENOMEM;\r\nmc_io->dev = dev;\r\nmc_io->flags = flags;\r\nmc_io->portal_phys_addr = mc_portal_phys_addr;\r\nmc_io->portal_size = mc_portal_size;\r\nif (flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\r\nspin_lock_init(&mc_io->spinlock);\r\nelse\r\nmutex_init(&mc_io->mutex);\r\nres = devm_request_mem_region(dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size,\r\n"mc_portal");\r\nif (!res) {\r\ndev_err(dev,\r\n"devm_request_mem_region failed for MC portal %#llx\n",\r\nmc_portal_phys_addr);\r\nreturn -EBUSY;\r\n}\r\nmc_portal_virt_addr = devm_ioremap_nocache(dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size);\r\nif (!mc_portal_virt_addr) {\r\ndev_err(dev,\r\n"devm_ioremap_nocache failed for MC portal %#llx\n",\r\nmc_portal_phys_addr);\r\nreturn -ENXIO;\r\n}\r\nmc_io->portal_virt_addr = mc_portal_virt_addr;\r\nif (dpmcp_dev) {\r\nerror = fsl_mc_io_set_dpmcp(mc_io, dpmcp_dev);\r\nif (error < 0)\r\ngoto error_destroy_mc_io;\r\n}\r\n*new_mc_io = mc_io;\r\nreturn 0;\r\nerror_destroy_mc_io:\r\nfsl_destroy_mc_io(mc_io);\r\nreturn error;\r\n}\r\nvoid fsl_destroy_mc_io(struct fsl_mc_io *mc_io)\r\n{\r\nstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\r\nif (dpmcp_dev)\r\nfsl_mc_io_unset_dpmcp(mc_io);\r\ndevm_iounmap(mc_io->dev, mc_io->portal_virt_addr);\r\ndevm_release_mem_region(mc_io->dev,\r\nmc_io->portal_phys_addr,\r\nmc_io->portal_size);\r\nmc_io->portal_virt_addr = NULL;\r\ndevm_kfree(mc_io->dev, mc_io);\r\n}\r\nint __must_check fsl_mc_portal_allocate(struct fsl_mc_device *mc_dev,\r\nu16 mc_io_flags,\r\nstruct fsl_mc_io **new_mc_io)\r\n{\r\nstruct fsl_mc_device *mc_bus_dev;\r\nstruct fsl_mc_bus *mc_bus;\r\nphys_addr_t mc_portal_phys_addr;\r\nsize_t mc_portal_size;\r\nstruct fsl_mc_device *dpmcp_dev;\r\nint error = -EINVAL;\r\nstruct fsl_mc_resource *resource = NULL;\r\nstruct fsl_mc_io *mc_io = NULL;\r\nif (mc_dev->flags & FSL_MC_IS_DPRC) {\r\nmc_bus_dev = mc_dev;\r\n} else {\r\nif (WARN_ON(!dev_is_fsl_mc(mc_dev->dev.parent)))\r\nreturn error;\r\nmc_bus_dev = to_fsl_mc_device(mc_dev->dev.parent);\r\n}\r\nmc_bus = to_fsl_mc_bus(mc_bus_dev);\r\n*new_mc_io = NULL;\r\nerror = fsl_mc_resource_allocate(mc_bus, FSL_MC_POOL_DPMCP, &resource);\r\nif (error < 0)\r\nreturn error;\r\nerror = -EINVAL;\r\ndpmcp_dev = resource->data;\r\nif (WARN_ON(!dpmcp_dev))\r\ngoto error_cleanup_resource;\r\nif (dpmcp_dev->obj_desc.ver_major < DPMCP_MIN_VER_MAJOR ||\r\n(dpmcp_dev->obj_desc.ver_major == DPMCP_MIN_VER_MAJOR &&\r\ndpmcp_dev->obj_desc.ver_minor < DPMCP_MIN_VER_MINOR)) {\r\ndev_err(&dpmcp_dev->dev,\r\n"ERROR: Version %d.%d of DPMCP not supported.\n",\r\ndpmcp_dev->obj_desc.ver_major,\r\ndpmcp_dev->obj_desc.ver_minor);\r\nerror = -ENOTSUPP;\r\ngoto error_cleanup_resource;\r\n}\r\nif (WARN_ON(dpmcp_dev->obj_desc.region_count == 0))\r\ngoto error_cleanup_resource;\r\nmc_portal_phys_addr = dpmcp_dev->regions[0].start;\r\nmc_portal_size = dpmcp_dev->regions[0].end -\r\ndpmcp_dev->regions[0].start + 1;\r\nif (WARN_ON(mc_portal_size != mc_bus_dev->mc_io->portal_size))\r\ngoto error_cleanup_resource;\r\nerror = fsl_create_mc_io(&mc_bus_dev->dev,\r\nmc_portal_phys_addr,\r\nmc_portal_size, dpmcp_dev,\r\nmc_io_flags, &mc_io);\r\nif (error < 0)\r\ngoto error_cleanup_resource;\r\n*new_mc_io = mc_io;\r\nreturn 0;\r\nerror_cleanup_resource:\r\nfsl_mc_resource_free(resource);\r\nreturn error;\r\n}\r\nvoid fsl_mc_portal_free(struct fsl_mc_io *mc_io)\r\n{\r\nstruct fsl_mc_device *dpmcp_dev;\r\nstruct fsl_mc_resource *resource;\r\ndpmcp_dev = mc_io->dpmcp_dev;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn;\r\nresource = dpmcp_dev->resource;\r\nif (WARN_ON(!resource || resource->type != FSL_MC_POOL_DPMCP))\r\nreturn;\r\nif (WARN_ON(resource->data != dpmcp_dev))\r\nreturn;\r\nfsl_destroy_mc_io(mc_io);\r\nfsl_mc_resource_free(resource);\r\n}\r\nint fsl_mc_portal_reset(struct fsl_mc_io *mc_io)\r\n{\r\nint error;\r\nstruct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;\r\nif (WARN_ON(!dpmcp_dev))\r\nreturn -EINVAL;\r\nerror = dpmcp_reset(mc_io, 0, dpmcp_dev->mc_handle);\r\nif (error < 0) {\r\ndev_err(&dpmcp_dev->dev, "dpmcp_reset() failed: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
