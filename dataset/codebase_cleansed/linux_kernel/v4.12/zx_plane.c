static int zx_vl_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *plane_state)\r\n{\r\nstruct drm_framebuffer *fb = plane_state->fb;\r\nstruct drm_crtc *crtc = plane_state->crtc;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_rect clip;\r\nint min_scale = FRAC_16_16(1, 8);\r\nint max_scale = FRAC_16_16(8, 1);\r\nif (!crtc || !fb)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_existing_crtc_state(plane_state->state,\r\ncrtc);\r\nif (WARN_ON(!crtc_state))\r\nreturn -EINVAL;\r\nif (!crtc_state->enable)\r\nreturn 0;\r\nif (!plane_state->crtc)\r\nreturn -EINVAL;\r\nclip.x1 = 0;\r\nclip.y1 = 0;\r\nclip.x2 = crtc_state->adjusted_mode.hdisplay;\r\nclip.y2 = crtc_state->adjusted_mode.vdisplay;\r\nreturn drm_plane_helper_check_state(plane_state, &clip,\r\nmin_scale, max_scale,\r\ntrue, true);\r\n}\r\nstatic int zx_vl_get_fmt(uint32_t format)\r\n{\r\nswitch (format) {\r\ncase DRM_FORMAT_NV12:\r\nreturn VL_FMT_YUV420;\r\ncase DRM_FORMAT_YUV420:\r\nreturn VL_YUV420_PLANAR | VL_FMT_YUV420;\r\ncase DRM_FORMAT_YUYV:\r\nreturn VL_YUV422_YUYV | VL_FMT_YUV422;\r\ncase DRM_FORMAT_YVYU:\r\nreturn VL_YUV422_YVYU | VL_FMT_YUV422;\r\ncase DRM_FORMAT_UYVY:\r\nreturn VL_YUV422_UYVY | VL_FMT_YUV422;\r\ncase DRM_FORMAT_VYUY:\r\nreturn VL_YUV422_VYUY | VL_FMT_YUV422;\r\ncase DRM_FORMAT_YUV444:\r\nreturn VL_FMT_YUV444_8BIT;\r\ndefault:\r\nWARN_ONCE(1, "invalid pixel format %d\n", format);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline void zx_vl_set_update(struct zx_plane *zplane)\r\n{\r\nvoid __iomem *layer = zplane->layer;\r\nzx_writel_mask(layer + VL_CTRL0, VL_UPDATE, VL_UPDATE);\r\n}\r\nstatic inline void zx_vl_rsz_set_update(struct zx_plane *zplane)\r\n{\r\nzx_writel(zplane->rsz + RSZ_VL_ENABLE_CFG, 1);\r\n}\r\nstatic int zx_vl_rsz_get_fmt(uint32_t format)\r\n{\r\nswitch (format) {\r\ncase DRM_FORMAT_NV12:\r\ncase DRM_FORMAT_YUV420:\r\nreturn RSZ_VL_FMT_YCBCR420;\r\ncase DRM_FORMAT_YUYV:\r\ncase DRM_FORMAT_YVYU:\r\ncase DRM_FORMAT_UYVY:\r\ncase DRM_FORMAT_VYUY:\r\nreturn RSZ_VL_FMT_YCBCR422;\r\ncase DRM_FORMAT_YUV444:\r\nreturn RSZ_VL_FMT_YCBCR444;\r\ndefault:\r\nWARN_ONCE(1, "invalid pixel format %d\n", format);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline u32 rsz_step_value(u32 src, u32 dst)\r\n{\r\nu32 val = 0;\r\nif (src == dst)\r\nval = 0;\r\nelse if (src < dst)\r\nval = RSZ_PARA_STEP((src << 16) / dst);\r\nelse if (src > dst)\r\nval = RSZ_DATA_STEP(src / dst) |\r\nRSZ_PARA_STEP(((src << 16) / dst) & 0xffff);\r\nreturn val;\r\n}\r\nstatic void zx_vl_rsz_setup(struct zx_plane *zplane, uint32_t format,\r\nu32 src_w, u32 src_h, u32 dst_w, u32 dst_h)\r\n{\r\nvoid __iomem *rsz = zplane->rsz;\r\nu32 src_chroma_w = src_w;\r\nu32 src_chroma_h = src_h;\r\nint fmt;\r\nzx_writel(rsz + RSZ_SRC_CFG, RSZ_VER(src_h - 1) | RSZ_HOR(src_w - 1));\r\nzx_writel(rsz + RSZ_DEST_CFG, RSZ_VER(dst_h - 1) | RSZ_HOR(dst_w - 1));\r\nfmt = zx_vl_rsz_get_fmt(format);\r\nif (fmt >= 0)\r\nzx_writel_mask(rsz + RSZ_VL_CTRL_CFG, RSZ_VL_FMT_MASK, fmt);\r\nif (fmt == RSZ_VL_FMT_YCBCR420) {\r\nsrc_chroma_w = src_w >> 1;\r\nsrc_chroma_h = src_h >> 1;\r\n} else if (fmt == RSZ_VL_FMT_YCBCR422) {\r\nsrc_chroma_w = src_w >> 1;\r\n}\r\nzx_writel(rsz + RSZ_VL_LUMA_HOR, rsz_step_value(src_w, dst_w));\r\nzx_writel(rsz + RSZ_VL_LUMA_VER, rsz_step_value(src_h, dst_h));\r\nzx_writel(rsz + RSZ_VL_CHROMA_HOR, rsz_step_value(src_chroma_w, dst_w));\r\nzx_writel(rsz + RSZ_VL_CHROMA_VER, rsz_step_value(src_chroma_h, dst_h));\r\nzx_vl_rsz_set_update(zplane);\r\n}\r\nstatic void zx_vl_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct zx_plane *zplane = to_zx_plane(plane);\r\nstruct drm_plane_state *state = plane->state;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_rect *src = &state->src;\r\nstruct drm_rect *dst = &state->dst;\r\nstruct drm_gem_cma_object *cma_obj;\r\nvoid __iomem *layer = zplane->layer;\r\nvoid __iomem *hbsc = zplane->hbsc;\r\nvoid __iomem *paddr_reg;\r\ndma_addr_t paddr;\r\nu32 src_x, src_y, src_w, src_h;\r\nu32 dst_x, dst_y, dst_w, dst_h;\r\nuint32_t format;\r\nint fmt;\r\nint num_planes;\r\nint i;\r\nif (!fb)\r\nreturn;\r\nformat = fb->format->format;\r\nsrc_x = src->x1 >> 16;\r\nsrc_y = src->y1 >> 16;\r\nsrc_w = drm_rect_width(src) >> 16;\r\nsrc_h = drm_rect_height(src) >> 16;\r\ndst_x = dst->x1;\r\ndst_y = dst->y1;\r\ndst_w = drm_rect_width(dst);\r\ndst_h = drm_rect_height(dst);\r\nnum_planes = drm_format_num_planes(format);\r\npaddr_reg = layer + VL_Y;\r\nfor (i = 0; i < num_planes; i++) {\r\ncma_obj = drm_fb_cma_get_gem_obj(fb, i);\r\npaddr = cma_obj->paddr + fb->offsets[i];\r\npaddr += src_y * fb->pitches[i];\r\npaddr += src_x * drm_format_plane_cpp(format, i);\r\nzx_writel(paddr_reg, paddr);\r\npaddr_reg += 4;\r\n}\r\nzx_writel(layer + VL_SRC_SIZE, GL_SRC_W(src_w) | GL_SRC_H(src_h));\r\nzx_writel(layer + VL_POS_START, GL_POS_X(dst_x) | GL_POS_Y(dst_y));\r\nzx_writel(layer + VL_POS_END,\r\nGL_POS_X(dst_x + dst_w) | GL_POS_Y(dst_y + dst_h));\r\nzx_writel(layer + VL_STRIDE, LUMA_STRIDE(fb->pitches[0]) |\r\nCHROMA_STRIDE(fb->pitches[1]));\r\nfmt = zx_vl_get_fmt(format);\r\nif (fmt >= 0)\r\nzx_writel(layer + VL_CTRL1, fmt);\r\nzx_writel_mask(layer + VL_CTRL2, VL_SCALER_BYPASS_MODE,\r\nVL_SCALER_BYPASS_MODE);\r\nzx_vl_rsz_setup(zplane, format, src_w, src_h, dst_w, dst_h);\r\nzx_writel_mask(hbsc + HBSC_CTRL0, HBSC_CTRL_EN, HBSC_CTRL_EN);\r\nzx_vou_layer_enable(plane);\r\nzx_vl_set_update(zplane);\r\n}\r\nstatic void zx_plane_atomic_disable(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct zx_plane *zplane = to_zx_plane(plane);\r\nvoid __iomem *hbsc = zplane->hbsc;\r\nzx_vou_layer_disable(plane);\r\nzx_writel_mask(hbsc + HBSC_CTRL0, HBSC_CTRL_EN, 0);\r\n}\r\nstatic int zx_gl_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *plane_state)\r\n{\r\nstruct drm_framebuffer *fb = plane_state->fb;\r\nstruct drm_crtc *crtc = plane_state->crtc;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_rect clip;\r\nif (!crtc || !fb)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_existing_crtc_state(plane_state->state,\r\ncrtc);\r\nif (WARN_ON(!crtc_state))\r\nreturn -EINVAL;\r\nif (!crtc_state->enable)\r\nreturn 0;\r\nif (!plane_state->crtc)\r\nreturn -EINVAL;\r\nclip.x1 = 0;\r\nclip.y1 = 0;\r\nclip.x2 = crtc_state->adjusted_mode.hdisplay;\r\nclip.y2 = crtc_state->adjusted_mode.vdisplay;\r\nreturn drm_plane_helper_check_state(plane_state, &clip,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\nfalse, true);\r\n}\r\nstatic int zx_gl_get_fmt(uint32_t format)\r\n{\r\nswitch (format) {\r\ncase DRM_FORMAT_ARGB8888:\r\ncase DRM_FORMAT_XRGB8888:\r\nreturn GL_FMT_ARGB8888;\r\ncase DRM_FORMAT_RGB888:\r\nreturn GL_FMT_RGB888;\r\ncase DRM_FORMAT_RGB565:\r\nreturn GL_FMT_RGB565;\r\ncase DRM_FORMAT_ARGB1555:\r\nreturn GL_FMT_ARGB1555;\r\ncase DRM_FORMAT_ARGB4444:\r\nreturn GL_FMT_ARGB4444;\r\ndefault:\r\nWARN_ONCE(1, "invalid pixel format %d\n", format);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline void zx_gl_set_update(struct zx_plane *zplane)\r\n{\r\nvoid __iomem *layer = zplane->layer;\r\nzx_writel_mask(layer + GL_CTRL0, GL_UPDATE, GL_UPDATE);\r\n}\r\nstatic inline void zx_gl_rsz_set_update(struct zx_plane *zplane)\r\n{\r\nzx_writel(zplane->rsz + RSZ_ENABLE_CFG, 1);\r\n}\r\nstatic void zx_gl_rsz_setup(struct zx_plane *zplane, u32 src_w, u32 src_h,\r\nu32 dst_w, u32 dst_h)\r\n{\r\nvoid __iomem *rsz = zplane->rsz;\r\nzx_writel(rsz + RSZ_SRC_CFG, RSZ_VER(src_h - 1) | RSZ_HOR(src_w - 1));\r\nzx_writel(rsz + RSZ_DEST_CFG, RSZ_VER(dst_h - 1) | RSZ_HOR(dst_w - 1));\r\nzx_gl_rsz_set_update(zplane);\r\n}\r\nstatic void zx_gl_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct zx_plane *zplane = to_zx_plane(plane);\r\nstruct drm_framebuffer *fb = plane->state->fb;\r\nstruct drm_gem_cma_object *cma_obj;\r\nvoid __iomem *layer = zplane->layer;\r\nvoid __iomem *csc = zplane->csc;\r\nvoid __iomem *hbsc = zplane->hbsc;\r\nu32 src_x, src_y, src_w, src_h;\r\nu32 dst_x, dst_y, dst_w, dst_h;\r\nunsigned int bpp;\r\nuint32_t format;\r\ndma_addr_t paddr;\r\nu32 stride;\r\nint fmt;\r\nif (!fb)\r\nreturn;\r\nformat = fb->format->format;\r\nstride = fb->pitches[0];\r\nsrc_x = plane->state->src_x >> 16;\r\nsrc_y = plane->state->src_y >> 16;\r\nsrc_w = plane->state->src_w >> 16;\r\nsrc_h = plane->state->src_h >> 16;\r\ndst_x = plane->state->crtc_x;\r\ndst_y = plane->state->crtc_y;\r\ndst_w = plane->state->crtc_w;\r\ndst_h = plane->state->crtc_h;\r\nbpp = fb->format->cpp[0];\r\ncma_obj = drm_fb_cma_get_gem_obj(fb, 0);\r\npaddr = cma_obj->paddr + fb->offsets[0];\r\npaddr += src_y * stride + src_x * bpp / 8;\r\nzx_writel(layer + GL_ADDR, paddr);\r\nzx_writel(layer + GL_SRC_SIZE, GL_SRC_W(src_w) | GL_SRC_H(src_h));\r\nzx_writel(layer + GL_POS_START, GL_POS_X(dst_x) | GL_POS_Y(dst_y));\r\nzx_writel(layer + GL_POS_END,\r\nGL_POS_X(dst_x + dst_w) | GL_POS_Y(dst_y + dst_h));\r\nzx_writel(layer + GL_STRIDE, stride & 0xffff);\r\nfmt = zx_gl_get_fmt(format);\r\nif (fmt >= 0)\r\nzx_writel_mask(layer + GL_CTRL1, GL_DATA_FMT_MASK,\r\nfmt << GL_DATA_FMT_SHIFT);\r\nzx_writel_mask(layer + GL_CTRL2, GL_GLOBAL_ALPHA_MASK,\r\n0xff << GL_GLOBAL_ALPHA_SHIFT);\r\nif (dst_h > 720)\r\nzx_writel_mask(csc + CSC_CTRL0, CSC_COV_MODE_MASK,\r\nCSC_BT709_IMAGE_RGB2YCBCR << CSC_COV_MODE_SHIFT);\r\nelse\r\nzx_writel_mask(csc + CSC_CTRL0, CSC_COV_MODE_MASK,\r\nCSC_BT601_IMAGE_RGB2YCBCR << CSC_COV_MODE_SHIFT);\r\nzx_writel_mask(csc + CSC_CTRL0, CSC_WORK_ENABLE, CSC_WORK_ENABLE);\r\nzx_writel_mask(layer + GL_CTRL3, GL_SCALER_BYPASS_MODE,\r\nGL_SCALER_BYPASS_MODE);\r\nzx_gl_rsz_setup(zplane, src_w, src_h, dst_w, dst_h);\r\nzx_writel_mask(hbsc + HBSC_CTRL0, HBSC_CTRL_EN, HBSC_CTRL_EN);\r\nzx_vou_layer_enable(plane);\r\nzx_gl_set_update(zplane);\r\n}\r\nstatic void zx_plane_destroy(struct drm_plane *plane)\r\n{\r\ndrm_plane_helper_disable(plane);\r\ndrm_plane_cleanup(plane);\r\n}\r\nvoid zx_plane_set_update(struct drm_plane *plane)\r\n{\r\nstruct zx_plane *zplane = to_zx_plane(plane);\r\nif (!plane->state->crtc)\r\nreturn;\r\nswitch (plane->type) {\r\ncase DRM_PLANE_TYPE_PRIMARY:\r\nzx_gl_rsz_set_update(zplane);\r\nzx_gl_set_update(zplane);\r\nbreak;\r\ncase DRM_PLANE_TYPE_OVERLAY:\r\nzx_vl_rsz_set_update(zplane);\r\nzx_vl_set_update(zplane);\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "unsupported plane type %d\n", plane->type);\r\n}\r\n}\r\nstatic void zx_plane_hbsc_init(struct zx_plane *zplane)\r\n{\r\nvoid __iomem *hbsc = zplane->hbsc;\r\nzx_writel(hbsc + HBSC_SATURATION, 0x200);\r\nzx_writel(hbsc + HBSC_HUE, 0x0);\r\nzx_writel(hbsc + HBSC_BRIGHT, 0x0);\r\nzx_writel(hbsc + HBSC_CONTRAST, 0x200);\r\nzx_writel(hbsc + HBSC_THRESHOLD_COL1, (0x3ac << 16) | 0x40);\r\nzx_writel(hbsc + HBSC_THRESHOLD_COL2, (0x3c0 << 16) | 0x40);\r\nzx_writel(hbsc + HBSC_THRESHOLD_COL3, (0x3c0 << 16) | 0x40);\r\n}\r\nint zx_plane_init(struct drm_device *drm, struct zx_plane *zplane,\r\nenum drm_plane_type type)\r\n{\r\nconst struct drm_plane_helper_funcs *helper;\r\nstruct drm_plane *plane = &zplane->plane;\r\nstruct device *dev = zplane->dev;\r\nconst uint32_t *formats;\r\nunsigned int format_count;\r\nint ret;\r\nzx_plane_hbsc_init(zplane);\r\nswitch (type) {\r\ncase DRM_PLANE_TYPE_PRIMARY:\r\nhelper = &zx_gl_plane_helper_funcs;\r\nformats = gl_formats;\r\nformat_count = ARRAY_SIZE(gl_formats);\r\nbreak;\r\ncase DRM_PLANE_TYPE_OVERLAY:\r\nhelper = &zx_vl_plane_helper_funcs;\r\nformats = vl_formats;\r\nformat_count = ARRAY_SIZE(vl_formats);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nret = drm_universal_plane_init(drm, plane, VOU_CRTC_MASK,\r\n&zx_plane_funcs, formats, format_count,\r\ntype, NULL);\r\nif (ret) {\r\nDRM_DEV_ERROR(dev, "failed to init universal plane: %d\n", ret);\r\nreturn ret;\r\n}\r\ndrm_plane_helper_add(plane, helper);\r\nreturn 0;\r\n}
