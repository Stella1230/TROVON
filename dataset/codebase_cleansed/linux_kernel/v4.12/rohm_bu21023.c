static int rohm_i2c_burst_read(struct i2c_client *client, u8 start, void *buf,\r\nsize_t len)\r\n{\r\nstruct i2c_adapter *adap = client->adapter;\r\nstruct i2c_msg msg[2];\r\nint i, ret = 0;\r\nmsg[0].addr = client->addr;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 1;\r\nmsg[0].buf = &start;\r\nmsg[1].addr = client->addr;\r\nmsg[1].flags = I2C_M_RD;\r\nmsg[1].len = len;\r\nmsg[1].buf = buf;\r\ni2c_lock_adapter(adap);\r\nfor (i = 0; i < 2; i++) {\r\nif (__i2c_transfer(adap, &msg[i], 1) < 0) {\r\nret = -EIO;\r\nbreak;\r\n}\r\n}\r\ni2c_unlock_adapter(adap);\r\nreturn ret;\r\n}\r\nstatic int rohm_ts_manual_calibration(struct rohm_ts_data *ts)\r\n{\r\nstruct i2c_client *client = ts->client;\r\nstruct device *dev = &client->dev;\r\nu8 buf[33];\r\nint retry;\r\nbool success = false;\r\nbool first_time = true;\r\nbool calibration_done;\r\nu8 reg1, reg2, reg3;\r\ns32 reg1_orig, reg2_orig, reg3_orig;\r\ns32 val;\r\nint calib_x = 0, calib_y = 0;\r\nint reg_x, reg_y;\r\nint err_x, err_y;\r\nint error, error2;\r\nint i;\r\nreg1_orig = i2c_smbus_read_byte_data(client, CALIBRATION_REG1);\r\nif (reg1_orig < 0)\r\nreturn reg1_orig;\r\nreg2_orig = i2c_smbus_read_byte_data(client, CALIBRATION_REG2);\r\nif (reg2_orig < 0)\r\nreturn reg2_orig;\r\nreg3_orig = i2c_smbus_read_byte_data(client, CALIBRATION_REG3);\r\nif (reg3_orig < 0)\r\nreturn reg3_orig;\r\nerror = i2c_smbus_write_byte_data(client, INT_MASK,\r\nCOORD_UPDATE | SLEEP_IN | SLEEP_OUT |\r\nPROGRAM_LOAD_DONE);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, TEST1,\r\nDUALTOUCH_STABILIZE_ON);\r\nif (error)\r\ngoto out;\r\nfor (retry = 0; retry < CALIBRATION_RETRY_MAX; retry++) {\r\nmdelay(2 * SAMPLING_DELAY);\r\n#define READ_CALIB_BUF(reg) buf[((reg) - PRM1_X_H)]\r\nerror = rohm_i2c_burst_read(client, PRM1_X_H, buf, sizeof(buf));\r\nif (error)\r\ngoto out;\r\nif (READ_CALIB_BUF(TOUCH) & TOUCH_DETECT)\r\ncontinue;\r\nif (first_time) {\r\ncalib_x = ((int)READ_CALIB_BUF(PRM1_X_H) << 2 |\r\nREAD_CALIB_BUF(PRM1_X_L)) - AXIS_OFFSET;\r\ncalib_y = ((int)READ_CALIB_BUF(PRM1_Y_H) << 2 |\r\nREAD_CALIB_BUF(PRM1_Y_L)) - AXIS_OFFSET;\r\nerror = i2c_smbus_write_byte_data(client, TEST1,\r\nDUALTOUCH_STABILIZE_ON | DUALTOUCH_REG_ON);\r\nif (error)\r\ngoto out;\r\nfirst_time = false;\r\n} else {\r\nerr_x = (int)READ_CALIB_BUF(PRM1_X_H) << 2 |\r\nREAD_CALIB_BUF(PRM1_X_L);\r\nerr_y = (int)READ_CALIB_BUF(PRM1_Y_H) << 2 |\r\nREAD_CALIB_BUF(PRM1_Y_L);\r\nif (err_x <= 4)\r\ncalib_x -= AXIS_ADJUST;\r\nelse if (err_x >= 60)\r\ncalib_x += AXIS_ADJUST;\r\nif (err_y <= 4)\r\ncalib_y -= AXIS_ADJUST;\r\nelse if (err_y >= 60)\r\ncalib_y += AXIS_ADJUST;\r\n}\r\nreg_x = calib_x + ((calib_x & 0x200) << 1);\r\nreg_y = calib_y + ((calib_y & 0x200) << 1);\r\nreg1 = reg_x >> 3;\r\nreg2 = (reg_y & 0x7) << 4 | (reg_x & 0x7);\r\nreg3 = reg_y >> 3;\r\nerror = i2c_smbus_write_byte_data(client,\r\nCALIBRATION_REG1, reg1);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client,\r\nCALIBRATION_REG2, reg2);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client,\r\nCALIBRATION_REG3, reg3);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\r\nFORCE_CALIBRATION_OFF);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\r\nFORCE_CALIBRATION_ON);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\r\nif (error)\r\ngoto out;\r\ncalibration_done = false;\r\nfor (i = 0; i < 10; i++) {\r\nmdelay(SAMPLING_DELAY);\r\nval = i2c_smbus_read_byte_data(client, TOUCH_GESTURE);\r\nif (!(val & CALIBRATION_MASK)) {\r\ncalibration_done = true;\r\nbreak;\r\n} else if (val < 0) {\r\nerror = val;\r\ngoto out;\r\n}\r\n}\r\nif (calibration_done) {\r\nval = i2c_smbus_read_byte_data(client, INT_STATUS);\r\nif (val == CALIBRATION_DONE) {\r\nsuccess = true;\r\nbreak;\r\n} else if (val < 0) {\r\nerror = val;\r\ngoto out;\r\n}\r\n} else {\r\ndev_warn(dev, "calibration timeout\n");\r\n}\r\n}\r\nif (!success) {\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_REG1,\r\nreg1_orig);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_REG2,\r\nreg2_orig);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_REG3,\r\nreg3_orig);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, TEST1,\r\nDUALTOUCH_STABILIZE_ON |\r\nDUALTOUCH_REG_ON);\r\nif (error)\r\ngoto out;\r\nmdelay(10 * SAMPLING_DELAY);\r\nerror = -EBUSY;\r\n}\r\nout:\r\nerror2 = i2c_smbus_write_byte_data(client, INT_MASK, INT_ALL);\r\nif (!error2)\r\nerror2 = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\r\nreturn error ? error : error2;\r\n}\r\nstatic irqreturn_t rohm_ts_soft_irq(int irq, void *dev_id)\r\n{\r\nstruct rohm_ts_data *ts = dev_id;\r\nstruct i2c_client *client = ts->client;\r\nstruct input_dev *input_dev = ts->input;\r\nstruct device *dev = &client->dev;\r\nu8 buf[10];\r\nstruct input_mt_pos pos[MAX_CONTACTS];\r\nint slots[MAX_CONTACTS];\r\nu8 touch_flags;\r\nunsigned int threshold;\r\nint finger_count = -1;\r\nint prev_finger_count = ts->finger_count;\r\nint count;\r\nint error;\r\nint i;\r\nerror = i2c_smbus_write_byte_data(client, INT_MASK, INT_ALL);\r\nif (error)\r\nreturn IRQ_HANDLED;\r\nerror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\r\nif (error)\r\nreturn IRQ_HANDLED;\r\n#define READ_POS_BUF(reg) buf[((reg) - POS_X1_H)]\r\nerror = rohm_i2c_burst_read(client, POS_X1_H, buf, sizeof(buf));\r\nif (error)\r\nreturn IRQ_HANDLED;\r\ntouch_flags = READ_POS_BUF(TOUCH_GESTURE) & TOUCH_MASK;\r\nif (touch_flags) {\r\npos[0].x = ((s16)READ_POS_BUF(POS_X1_H) << 2) |\r\nREAD_POS_BUF(POS_X1_L);\r\npos[0].y = ((s16)READ_POS_BUF(POS_Y1_H) << 2) |\r\nREAD_POS_BUF(POS_Y1_L);\r\npos[1].x = ((s16)READ_POS_BUF(POS_X2_H) << 2) |\r\nREAD_POS_BUF(POS_X2_L);\r\npos[1].y = ((s16)READ_POS_BUF(POS_Y2_H) << 2) |\r\nREAD_POS_BUF(POS_Y2_L);\r\n}\r\nswitch (touch_flags) {\r\ncase 0:\r\nthreshold = untouch_threshold[prev_finger_count];\r\nif (++ts->contact_count[0] >= threshold)\r\nfinger_count = 0;\r\nbreak;\r\ncase SINGLE_TOUCH:\r\nthreshold = single_touch_threshold[prev_finger_count];\r\nif (++ts->contact_count[1] >= threshold)\r\nfinger_count = 1;\r\nif (finger_count == 1) {\r\nif (pos[1].x != 0 && pos[1].y != 0) {\r\npos[0].x = pos[1].x;\r\npos[0].y = pos[1].y;\r\npos[1].x = 0;\r\npos[1].y = 0;\r\n}\r\n}\r\nbreak;\r\ncase DUAL_TOUCH:\r\nthreshold = dual_touch_threshold[prev_finger_count];\r\nif (++ts->contact_count[2] >= threshold)\r\nfinger_count = 2;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev,\r\n"Three or more touches are not supported\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (finger_count >= 0) {\r\nif (prev_finger_count != finger_count) {\r\ncount = ts->contact_count[finger_count];\r\nmemset(ts->contact_count, 0, sizeof(ts->contact_count));\r\nts->contact_count[finger_count] = count;\r\n}\r\ninput_mt_assign_slots(input_dev, slots, pos,\r\nfinger_count, ROHM_TS_DISPLACEMENT_MAX);\r\nfor (i = 0; i < finger_count; i++) {\r\ninput_mt_slot(input_dev, slots[i]);\r\ninput_mt_report_slot_state(input_dev,\r\nMT_TOOL_FINGER, true);\r\ninput_report_abs(input_dev,\r\nABS_MT_POSITION_X, pos[i].x);\r\ninput_report_abs(input_dev,\r\nABS_MT_POSITION_Y, pos[i].y);\r\n}\r\ninput_mt_sync_frame(input_dev);\r\ninput_mt_report_pointer_emulation(input_dev, true);\r\ninput_sync(input_dev);\r\nts->finger_count = finger_count;\r\n}\r\nif (READ_POS_BUF(TOUCH_GESTURE) & CALIBRATION_REQUEST) {\r\nerror = rohm_ts_manual_calibration(ts);\r\nif (error)\r\ndev_warn(dev, "manual calibration failed: %d\n",\r\nerror);\r\n}\r\ni2c_smbus_write_byte_data(client, INT_MASK,\r\nCALIBRATION_DONE | SLEEP_OUT | SLEEP_IN |\r\nPROGRAM_LOAD_DONE);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rohm_ts_load_firmware(struct i2c_client *client,\r\nconst char *firmware_name)\r\n{\r\nstruct device *dev = &client->dev;\r\nconst struct firmware *fw;\r\ns32 status;\r\nunsigned int offset, len, xfer_len;\r\nunsigned int retry = 0;\r\nint error, error2;\r\nerror = request_firmware(&fw, firmware_name, dev);\r\nif (error) {\r\ndev_err(dev, "unable to retrieve firmware %s: %d\n",\r\nfirmware_name, error);\r\nreturn error;\r\n}\r\nerror = i2c_smbus_write_byte_data(client, INT_MASK,\r\nCOORD_UPDATE | CALIBRATION_DONE |\r\nSLEEP_IN | SLEEP_OUT);\r\nif (error)\r\ngoto out;\r\ndo {\r\nif (retry) {\r\ndev_warn(dev, "retrying firmware load\n");\r\nerror = i2c_smbus_write_byte_data(client, EX_WDAT, 0);\r\nif (error)\r\ngoto out;\r\n}\r\nerror = i2c_smbus_write_byte_data(client, EX_ADDR_H, 0);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, EX_ADDR_L, 0);\r\nif (error)\r\ngoto out;\r\nerror = i2c_smbus_write_byte_data(client, COMMON_SETUP1,\r\nCOMMON_SETUP1_DEFAULT);\r\nif (error)\r\ngoto out;\r\noffset = 0;\r\nlen = fw->size;\r\nwhile (len) {\r\nxfer_len = min(FIRMWARE_BLOCK_SIZE, len);\r\nerror = i2c_smbus_write_i2c_block_data(client, EX_WDAT,\r\nxfer_len, &fw->data[offset]);\r\nif (error)\r\ngoto out;\r\nlen -= xfer_len;\r\noffset += xfer_len;\r\n}\r\nstatus = i2c_smbus_read_byte_data(client, INT_STATUS);\r\nif (status < 0) {\r\nerror = status;\r\ngoto out;\r\n}\r\nerror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\r\nif (error)\r\ngoto out;\r\nif (status == PROGRAM_LOAD_DONE)\r\nbreak;\r\nerror = -EIO;\r\n} while (++retry <= FIRMWARE_RETRY_MAX);\r\nout:\r\nerror2 = i2c_smbus_write_byte_data(client, INT_MASK, INT_ALL);\r\nrelease_firmware(fw);\r\nreturn error ? error : error2;\r\n}\r\nstatic ssize_t swap_xy_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rohm_ts_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d\n", !!(ts->setup2 & SWAP_XY));\r\n}\r\nstatic ssize_t swap_xy_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rohm_ts_data *ts = i2c_get_clientdata(client);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 0, &val);\r\nif (error)\r\nreturn error;\r\nerror = mutex_lock_interruptible(&ts->input->mutex);\r\nif (error)\r\nreturn error;\r\nif (val)\r\nts->setup2 |= SWAP_XY;\r\nelse\r\nts->setup2 &= ~SWAP_XY;\r\nif (ts->initialized)\r\nerror = i2c_smbus_write_byte_data(ts->client, COMMON_SETUP2,\r\nts->setup2);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn error ? error : count;\r\n}\r\nstatic ssize_t inv_x_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rohm_ts_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d\n", !!(ts->setup2 & INV_X));\r\n}\r\nstatic ssize_t inv_x_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rohm_ts_data *ts = i2c_get_clientdata(client);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 0, &val);\r\nif (error)\r\nreturn error;\r\nerror = mutex_lock_interruptible(&ts->input->mutex);\r\nif (error)\r\nreturn error;\r\nif (val)\r\nts->setup2 |= INV_X;\r\nelse\r\nts->setup2 &= ~INV_X;\r\nif (ts->initialized)\r\nerror = i2c_smbus_write_byte_data(ts->client, COMMON_SETUP2,\r\nts->setup2);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn error ? error : count;\r\n}\r\nstatic ssize_t inv_y_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rohm_ts_data *ts = i2c_get_clientdata(client);\r\nreturn sprintf(buf, "%d\n", !!(ts->setup2 & INV_Y));\r\n}\r\nstatic ssize_t inv_y_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rohm_ts_data *ts = i2c_get_clientdata(client);\r\nunsigned int val;\r\nint error;\r\nerror = kstrtouint(buf, 0, &val);\r\nif (error)\r\nreturn error;\r\nerror = mutex_lock_interruptible(&ts->input->mutex);\r\nif (error)\r\nreturn error;\r\nif (val)\r\nts->setup2 |= INV_Y;\r\nelse\r\nts->setup2 &= ~INV_Y;\r\nif (ts->initialized)\r\nerror = i2c_smbus_write_byte_data(client, COMMON_SETUP2,\r\nts->setup2);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn error ? error : count;\r\n}\r\nstatic int rohm_ts_device_init(struct i2c_client *client, u8 setup2)\r\n{\r\nstruct device *dev = &client->dev;\r\nint error;\r\ndisable_irq(client->irq);\r\nudelay(200);\r\nerror = i2c_smbus_write_byte_data(client, SYSTEM,\r\nANALOG_POWER_ON | CPU_POWER_OFF);\r\nif (error)\r\nreturn error;\r\nudelay(200);\r\nerror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, EX_WDAT, 0);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, COMMON_SETUP1, 0);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, COMMON_SETUP2, setup2);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, COMMON_SETUP3,\r\nSEL_TBL_DEFAULT | EN_MULTI);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, THRESHOLD_GESTURE,\r\nTHRESHOLD_GESTURE_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, INTERVAL_TIME,\r\nINTERVAL_TIME_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, CPU_FREQ, CPU_FREQ_10MHZ);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, PRM_SWOFF_TIME,\r\nPRM_SWOFF_TIME_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, ADC_CTRL, ADC_DIV_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, ADC_WAIT, ADC_WAIT_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, STEP_X, STEP_X_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, STEP_Y, STEP_Y_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, OFFSET_X, OFFSET_X_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, OFFSET_Y, OFFSET_Y_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, THRESHOLD_TOUCH,\r\nTHRESHOLD_TOUCH_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, EVR_XY, EVR_XY_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, EVR_X, EVR_X_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, EVR_Y, EVR_Y_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_ADJUST,\r\nCALIBRATION_ADJUST_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, SWCONT, SWCONT_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, TEST1,\r\nDUALTOUCH_STABILIZE_ON |\r\nDUALTOUCH_REG_ON);\r\nif (error)\r\nreturn error;\r\nerror = rohm_ts_load_firmware(client, BU21023_FIRMWARE_NAME);\r\nif (error) {\r\ndev_err(dev, "failed to load firmware: %d\n", error);\r\nreturn error;\r\n}\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_REG1,\r\nCALIBRATION_REG1_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_REG2,\r\nCALIBRATION_REG2_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, CALIBRATION_REG3,\r\nCALIBRATION_REG3_DEFAULT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\r\nFORCE_CALIBRATION_OFF);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, FORCE_CALIBRATION,\r\nFORCE_CALIBRATION_ON);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, INT_CLEAR, 0xff);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, INT_MASK,\r\nCALIBRATION_DONE | SLEEP_OUT |\r\nSLEEP_IN | PROGRAM_LOAD_DONE);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, ERR_MASK,\r\nPROGRAM_LOAD_ERR | CPU_TIMEOUT |\r\nADC_TIMEOUT);\r\nif (error)\r\nreturn error;\r\nerror = i2c_smbus_write_byte_data(client, SYSTEM,\r\nANALOG_POWER_ON | CPU_POWER_ON);\r\nenable_irq(client->irq);\r\nreturn error;\r\n}\r\nstatic int rohm_ts_power_off(struct i2c_client *client)\r\n{\r\nint error;\r\nerror = i2c_smbus_write_byte_data(client, SYSTEM,\r\nANALOG_POWER_ON | CPU_POWER_OFF);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"failed to power off device CPU: %d\n", error);\r\nreturn error;\r\n}\r\nerror = i2c_smbus_write_byte_data(client, SYSTEM,\r\nANALOG_POWER_OFF | CPU_POWER_OFF);\r\nif (error)\r\ndev_err(&client->dev,\r\n"failed to power off the device: %d\n", error);\r\nreturn error;\r\n}\r\nstatic int rohm_ts_open(struct input_dev *input_dev)\r\n{\r\nstruct rohm_ts_data *ts = input_get_drvdata(input_dev);\r\nstruct i2c_client *client = ts->client;\r\nint error;\r\nif (!ts->initialized) {\r\nerror = rohm_ts_device_init(client, ts->setup2);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"device initialization failed: %d\n", error);\r\nreturn error;\r\n}\r\nts->initialized = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rohm_ts_close(struct input_dev *input_dev)\r\n{\r\nstruct rohm_ts_data *ts = input_get_drvdata(input_dev);\r\nrohm_ts_power_off(ts->client);\r\nts->initialized = false;\r\n}\r\nstatic void rohm_ts_remove_sysfs_group(void *_dev)\r\n{\r\nstruct device *dev = _dev;\r\nsysfs_remove_group(&dev->kobj, &rohm_ts_attr_group);\r\n}\r\nstatic int rohm_bu21023_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct rohm_ts_data *ts;\r\nstruct input_dev *input;\r\nint error;\r\nif (!client->irq) {\r\ndev_err(dev, "IRQ is not assigned\n");\r\nreturn -EINVAL;\r\n}\r\nif (!client->adapter->algo->master_xfer) {\r\ndev_err(dev, "I2C level transfers not supported\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nerror = rohm_ts_power_off(client);\r\nif (error)\r\nreturn error;\r\nts = devm_kzalloc(dev, sizeof(struct rohm_ts_data), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nts->client = client;\r\nts->setup2 = MAF_1SAMPLE;\r\ni2c_set_clientdata(client, ts);\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = BU21023_NAME;\r\ninput->id.bustype = BUS_I2C;\r\ninput->open = rohm_ts_open;\r\ninput->close = rohm_ts_close;\r\nts->input = input;\r\ninput_set_drvdata(input, ts);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X,\r\nROHM_TS_ABS_X_MIN, ROHM_TS_ABS_X_MAX, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y,\r\nROHM_TS_ABS_Y_MIN, ROHM_TS_ABS_Y_MAX, 0, 0);\r\nerror = input_mt_init_slots(input, MAX_CONTACTS,\r\nINPUT_MT_DIRECT | INPUT_MT_TRACK |\r\nINPUT_MT_DROP_UNUSED);\r\nif (error) {\r\ndev_err(dev, "failed to multi touch slots initialization\n");\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(dev, client->irq,\r\nNULL, rohm_ts_soft_irq,\r\nIRQF_ONESHOT, client->name, ts);\r\nif (error) {\r\ndev_err(dev, "failed to request IRQ: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(dev, "failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nerror = sysfs_create_group(&dev->kobj, &rohm_ts_attr_group);\r\nif (error) {\r\ndev_err(dev, "failed to create sysfs group: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_add_action(dev, rohm_ts_remove_sysfs_group, dev);\r\nif (error) {\r\nrohm_ts_remove_sysfs_group(dev);\r\ndev_err(dev, "Failed to add sysfs cleanup action: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nreturn error;\r\n}
