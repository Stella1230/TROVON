static int em2800_i2c_send_bytes(struct em28xx *dev, u8 addr, u8 *buf, u16 len)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(EM28XX_I2C_XFER_TIMEOUT);\r\nint ret;\r\nu8 b2[6];\r\nif (len < 1 || len > 4)\r\nreturn -EOPNOTSUPP;\r\nBUG_ON(len < 1 || len > 4);\r\nb2[5] = 0x80 + len - 1;\r\nb2[4] = addr;\r\nb2[3] = buf[0];\r\nif (len > 1)\r\nb2[2] = buf[1];\r\nif (len > 2)\r\nb2[1] = buf[2];\r\nif (len > 3)\r\nb2[0] = buf[3];\r\nret = dev->em28xx_write_regs(dev, 4 - len, &b2[4 - len], 2 + len);\r\nif (ret != 2 + len) {\r\ndev_warn(&dev->intf->dev,\r\n"failed to trigger write to i2c address 0x%x (error=%i)\n",\r\naddr, ret);\r\nreturn (ret < 0) ? ret : -EIO;\r\n}\r\nwhile (time_is_after_jiffies(timeout)) {\r\nret = dev->em28xx_read_reg(dev, 0x05);\r\nif (ret == 0x80 + len - 1)\r\nreturn len;\r\nif (ret == 0x94 + len - 1) {\r\ndprintk(1, "R05 returned 0x%02x: I2C ACK error\n", ret);\r\nreturn -ENXIO;\r\n}\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"failed to get i2c transfer status from bridge register (error=%i)\n",\r\nret);\r\nreturn ret;\r\n}\r\nmsleep(5);\r\n}\r\ndprintk(0, "write to i2c device at 0x%x timed out\n", addr);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int em2800_i2c_recv_bytes(struct em28xx *dev, u8 addr, u8 *buf, u16 len)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(EM28XX_I2C_XFER_TIMEOUT);\r\nu8 buf2[4];\r\nint ret;\r\nint i;\r\nif (len < 1 || len > 4)\r\nreturn -EOPNOTSUPP;\r\nbuf2[1] = 0x84 + len - 1;\r\nbuf2[0] = addr;\r\nret = dev->em28xx_write_regs(dev, 0x04, buf2, 2);\r\nif (ret != 2) {\r\ndev_warn(&dev->intf->dev,\r\n"failed to trigger read from i2c address 0x%x (error=%i)\n",\r\naddr, ret);\r\nreturn (ret < 0) ? ret : -EIO;\r\n}\r\nwhile (time_is_after_jiffies(timeout)) {\r\nret = dev->em28xx_read_reg(dev, 0x05);\r\nif (ret == 0x84 + len - 1)\r\nbreak;\r\nif (ret == 0x94 + len - 1) {\r\ndprintk(1, "R05 returned 0x%02x: I2C ACK error\n",\r\nret);\r\nreturn -ENXIO;\r\n}\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"failed to get i2c transfer status from bridge register (error=%i)\n",\r\nret);\r\nreturn ret;\r\n}\r\nmsleep(5);\r\n}\r\nif (ret != 0x84 + len - 1) {\r\ndprintk(0, "read from i2c device at 0x%x timed out\n", addr);\r\n}\r\nret = dev->em28xx_read_reg_req_len(dev, 0x00, 4-len, buf2, len);\r\nif (ret != len) {\r\ndev_warn(&dev->intf->dev,\r\n"reading from i2c device at 0x%x failed: couldn't get the received message from the bridge (error=%i)\n",\r\naddr, ret);\r\nreturn (ret < 0) ? ret : -EIO;\r\n}\r\nfor (i = 0; i < len; i++)\r\nbuf[i] = buf2[len - 1 - i];\r\nreturn ret;\r\n}\r\nstatic int em2800_i2c_check_for_device(struct em28xx *dev, u8 addr)\r\n{\r\nu8 buf;\r\nint ret;\r\nret = em2800_i2c_recv_bytes(dev, addr, &buf, 1);\r\nif (ret == 1)\r\nreturn 0;\r\nreturn (ret < 0) ? ret : -EIO;\r\n}\r\nstatic int em28xx_i2c_send_bytes(struct em28xx *dev, u16 addr, u8 *buf,\r\nu16 len, int stop)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(EM28XX_I2C_XFER_TIMEOUT);\r\nint ret;\r\nif (len < 1 || len > 64)\r\nreturn -EOPNOTSUPP;\r\nret = dev->em28xx_write_regs_req(dev, stop ? 2 : 3, addr, buf, len);\r\nif (ret != len) {\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"writing to i2c device at 0x%x failed (error=%i)\n",\r\naddr, ret);\r\nreturn ret;\r\n} else {\r\ndev_warn(&dev->intf->dev,\r\n"%i bytes write to i2c device at 0x%x requested, but %i bytes written\n",\r\nlen, addr, ret);\r\nreturn -EIO;\r\n}\r\n}\r\nwhile (time_is_after_jiffies(timeout)) {\r\nret = dev->em28xx_read_reg(dev, 0x05);\r\nif (ret == 0)\r\nreturn len;\r\nif (ret == 0x10) {\r\ndprintk(1, "I2C ACK error on writing to addr 0x%02x\n",\r\naddr);\r\nreturn -ENXIO;\r\n}\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"failed to get i2c transfer status from bridge register (error=%i)\n",\r\nret);\r\nreturn ret;\r\n}\r\nmsleep(5);\r\n}\r\nif (ret == 0x02 || ret == 0x04) {\r\ndprintk(0,\r\n"write to i2c device at 0x%x timed out (status=%i)\n",\r\naddr, ret);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_warn(&dev->intf->dev,\r\n"write to i2c device at 0x%x failed with unknown error (status=%i)\n",\r\naddr, ret);\r\nreturn -EIO;\r\n}\r\nstatic int em28xx_i2c_recv_bytes(struct em28xx *dev, u16 addr, u8 *buf, u16 len)\r\n{\r\nint ret;\r\nif (len < 1 || len > 64)\r\nreturn -EOPNOTSUPP;\r\nret = dev->em28xx_read_reg_req_len(dev, 2, addr, buf, len);\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"reading from i2c device at 0x%x failed (error=%i)\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nret = dev->em28xx_read_reg(dev, 0x05);\r\nif (ret == 0)\r\nreturn len;\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"failed to get i2c transfer status from bridge register (error=%i)\n",\r\nret);\r\nreturn ret;\r\n}\r\nif (ret == 0x10) {\r\ndprintk(1, "I2C ACK error on writing to addr 0x%02x\n",\r\naddr);\r\nreturn -ENXIO;\r\n}\r\nif (ret == 0x02 || ret == 0x04) {\r\ndprintk(0,\r\n"write to i2c device at 0x%x timed out (status=%i)\n",\r\naddr, ret);\r\nreturn -ETIMEDOUT;\r\n}\r\ndev_warn(&dev->intf->dev,\r\n"write to i2c device at 0x%x failed with unknown error (status=%i)\n",\r\naddr, ret);\r\nreturn -EIO;\r\n}\r\nstatic int em28xx_i2c_check_for_device(struct em28xx *dev, u16 addr)\r\n{\r\nint ret;\r\nu8 buf;\r\nret = em28xx_i2c_recv_bytes(dev, addr, &buf, 1);\r\nif (ret == 1)\r\nreturn 0;\r\nreturn (ret < 0) ? ret : -EIO;\r\n}\r\nstatic int em25xx_bus_B_send_bytes(struct em28xx *dev, u16 addr, u8 *buf,\r\nu16 len)\r\n{\r\nint ret;\r\nif (len < 1 || len > 64)\r\nreturn -EOPNOTSUPP;\r\nret = dev->em28xx_write_regs_req(dev, 0x06, addr, buf, len);\r\nif (ret != len) {\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"writing to i2c device at 0x%x failed (error=%i)\n",\r\naddr, ret);\r\nreturn ret;\r\n} else {\r\ndev_warn(&dev->intf->dev,\r\n"%i bytes write to i2c device at 0x%x requested, but %i bytes written\n",\r\nlen, addr, ret);\r\nreturn -EIO;\r\n}\r\n}\r\nret = dev->em28xx_read_reg_req(dev, 0x08, 0x0000);\r\nif (!ret)\r\nreturn len;\r\nelse if (ret > 0) {\r\ndprintk(1, "Bus B R08 returned 0x%02x: I2C ACK error\n", ret);\r\nreturn -ENXIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int em25xx_bus_B_recv_bytes(struct em28xx *dev, u16 addr, u8 *buf,\r\nu16 len)\r\n{\r\nint ret;\r\nif (len < 1 || len > 64)\r\nreturn -EOPNOTSUPP;\r\nret = dev->em28xx_read_reg_req_len(dev, 0x06, addr, buf, len);\r\nif (ret < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"reading from i2c device at 0x%x failed (error=%i)\n",\r\naddr, ret);\r\nreturn ret;\r\n}\r\nret = dev->em28xx_read_reg_req(dev, 0x08, 0x0000);\r\nif (!ret)\r\nreturn len;\r\nelse if (ret > 0) {\r\ndprintk(1, "Bus B R08 returned 0x%02x: I2C ACK error\n", ret);\r\nreturn -ENXIO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int em25xx_bus_B_check_for_device(struct em28xx *dev, u16 addr)\r\n{\r\nu8 buf;\r\nint ret;\r\nret = em25xx_bus_B_recv_bytes(dev, addr, &buf, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic inline int i2c_check_for_device(struct em28xx_i2c_bus *i2c_bus, u16 addr)\r\n{\r\nstruct em28xx *dev = i2c_bus->dev;\r\nint rc = -EOPNOTSUPP;\r\nif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)\r\nrc = em28xx_i2c_check_for_device(dev, addr);\r\nelse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)\r\nrc = em2800_i2c_check_for_device(dev, addr);\r\nelse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)\r\nrc = em25xx_bus_B_check_for_device(dev, addr);\r\nreturn rc;\r\n}\r\nstatic inline int i2c_recv_bytes(struct em28xx_i2c_bus *i2c_bus,\r\nstruct i2c_msg msg)\r\n{\r\nstruct em28xx *dev = i2c_bus->dev;\r\nu16 addr = msg.addr << 1;\r\nint rc = -EOPNOTSUPP;\r\nif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)\r\nrc = em28xx_i2c_recv_bytes(dev, addr, msg.buf, msg.len);\r\nelse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)\r\nrc = em2800_i2c_recv_bytes(dev, addr, msg.buf, msg.len);\r\nelse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)\r\nrc = em25xx_bus_B_recv_bytes(dev, addr, msg.buf, msg.len);\r\nreturn rc;\r\n}\r\nstatic inline int i2c_send_bytes(struct em28xx_i2c_bus *i2c_bus,\r\nstruct i2c_msg msg, int stop)\r\n{\r\nstruct em28xx *dev = i2c_bus->dev;\r\nu16 addr = msg.addr << 1;\r\nint rc = -EOPNOTSUPP;\r\nif (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX)\r\nrc = em28xx_i2c_send_bytes(dev, addr, msg.buf, msg.len, stop);\r\nelse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800)\r\nrc = em2800_i2c_send_bytes(dev, addr, msg.buf, msg.len);\r\nelse if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)\r\nrc = em25xx_bus_B_send_bytes(dev, addr, msg.buf, msg.len);\r\nreturn rc;\r\n}\r\nstatic int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct em28xx_i2c_bus *i2c_bus = i2c_adap->algo_data;\r\nstruct em28xx *dev = i2c_bus->dev;\r\nunsigned bus = i2c_bus->bus;\r\nint addr, rc, i;\r\nu8 reg;\r\nif (dev->disconnected)\r\nreturn -ENODEV;\r\nif (!rt_mutex_trylock(&dev->i2c_bus_lock))\r\nreturn -EAGAIN;\r\nif (bus != dev->cur_i2c_bus &&\r\ni2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX) {\r\nif (bus == 1)\r\nreg = EM2874_I2C_SECONDARY_BUS_SELECT;\r\nelse\r\nreg = 0;\r\nem28xx_write_reg_bits(dev, EM28XX_R06_I2C_CLK, reg,\r\nEM2874_I2C_SECONDARY_BUS_SELECT);\r\ndev->cur_i2c_bus = bus;\r\n}\r\nif (num <= 0) {\r\nrt_mutex_unlock(&dev->i2c_bus_lock);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < num; i++) {\r\naddr = msgs[i].addr << 1;\r\nif (!msgs[i].len) {\r\nrc = i2c_check_for_device(i2c_bus, addr);\r\nif (rc == -ENXIO)\r\nrc = -ENODEV;\r\n} else if (msgs[i].flags & I2C_M_RD) {\r\nrc = i2c_recv_bytes(i2c_bus, msgs[i]);\r\n} else {\r\nrc = i2c_send_bytes(i2c_bus, msgs[i], i == num - 1);\r\n}\r\nif (rc < 0)\r\ngoto error;\r\ndprintk(2, "%s %s addr=%02x len=%d: %*ph\n",\r\n(msgs[i].flags & I2C_M_RD) ? "read" : "write",\r\ni == num - 1 ? "stop" : "nonstop",\r\naddr, msgs[i].len,\r\nmsgs[i].len, msgs[i].buf);\r\n}\r\nrt_mutex_unlock(&dev->i2c_bus_lock);\r\nreturn num;\r\nerror:\r\ndprintk(2, "%s %s addr=%02x len=%d: %sERROR: %i\n",\r\n(msgs[i].flags & I2C_M_RD) ? "read" : "write",\r\ni == num - 1 ? "stop" : "nonstop",\r\naddr, msgs[i].len,\r\n(rc == -ENODEV) ? "no device " : "",\r\nrc);\r\nrt_mutex_unlock(&dev->i2c_bus_lock);\r\nreturn rc;\r\n}\r\nstatic inline unsigned long em28xx_hash_mem(char *buf, int length, int bits)\r\n{\r\nunsigned long hash = 0;\r\nunsigned long l = 0;\r\nint len = 0;\r\nunsigned char c;\r\ndo {\r\nif (len == length) {\r\nc = (char)len;\r\nlen = -1;\r\n} else\r\nc = *buf++;\r\nl = (l << 8) | c;\r\nlen++;\r\nif ((len & (32 / 8 - 1)) == 0)\r\nhash = ((hash^l) * 0x9e370001UL);\r\n} while (len);\r\nreturn (hash >> (32 - bits)) & 0xffffffffUL;\r\n}\r\nstatic int em28xx_i2c_read_block(struct em28xx *dev, unsigned bus, u16 addr,\r\nbool addr_w16, u16 len, u8 *data)\r\n{\r\nint remain = len, rsize, rsize_max, ret;\r\nu8 buf[2];\r\nif (addr + remain > (addr_w16 * 0xff00 + 0xff + 1))\r\nreturn -EINVAL;\r\nbuf[0] = addr >> 8;\r\nbuf[1] = addr & 0xff;\r\nret = i2c_master_send(&dev->i2c_client[bus], buf + !addr_w16, 1 + addr_w16);\r\nif (ret < 0)\r\nreturn ret;\r\nif (dev->board.is_em2800)\r\nrsize_max = 4;\r\nelse\r\nrsize_max = 64;\r\nwhile (remain > 0) {\r\nif (remain > rsize_max)\r\nrsize = rsize_max;\r\nelse\r\nrsize = remain;\r\nret = i2c_master_recv(&dev->i2c_client[bus], data, rsize);\r\nif (ret < 0)\r\nreturn ret;\r\nremain -= rsize;\r\ndata += rsize;\r\n}\r\nreturn len;\r\n}\r\nstatic int em28xx_i2c_eeprom(struct em28xx *dev, unsigned bus,\r\nu8 **eedata, u16 *eedata_len)\r\n{\r\nconst u16 len = 256;\r\nint err;\r\nstruct em28xx_eeprom *dev_config;\r\nu8 buf, *data;\r\n*eedata = NULL;\r\n*eedata_len = 0;\r\ndev->i2c_client[bus].addr = 0xa0 >> 1;\r\nerr = i2c_master_recv(&dev->i2c_client[bus], &buf, 0);\r\nif (err < 0) {\r\ndev_info(&dev->intf->dev, "board has no eeprom\n");\r\nreturn -ENODEV;\r\n}\r\ndata = kzalloc(len, GFP_KERNEL);\r\nif (data == NULL)\r\nreturn -ENOMEM;\r\nerr = em28xx_i2c_read_block(dev, bus, 0x0000,\r\ndev->eeprom_addrwidth_16bit,\r\nlen, data);\r\nif (err != len) {\r\ndev_err(&dev->intf->dev,\r\n"failed to read eeprom (err=%d)\n", err);\r\ngoto error;\r\n}\r\nif (i2c_debug) {\r\nprint_hex_dump(KERN_DEBUG, "em28xx eeprom ", DUMP_PREFIX_OFFSET,\r\n16, 1, data, len, true);\r\nif (dev->eeprom_addrwidth_16bit)\r\ndev_info(&dev->intf->dev,\r\n"eeprom %06x: ... (skipped)\n", 256);\r\n}\r\nif (dev->eeprom_addrwidth_16bit &&\r\ndata[0] == 0x26 && data[3] == 0x00) {\r\nu16 mc_start;\r\nu16 hwconf_offset;\r\ndev->hash = em28xx_hash_mem(data, len, 32);\r\nmc_start = (data[1] << 8) + 4;\r\ndev_info(&dev->intf->dev,\r\n"EEPROM ID = %02x %02x %02x %02x, EEPROM hash = 0x%08lx\n",\r\ndata[0], data[1], data[2], data[3], dev->hash);\r\ndev_info(&dev->intf->dev,\r\n"EEPROM info:\n");\r\ndev_info(&dev->intf->dev,\r\n"\tmicrocode start address = 0x%04x, boot configuration = 0x%02x\n",\r\nmc_start, data[2]);\r\nerr = em28xx_i2c_read_block(dev, bus, mc_start + 46, 1, 2,\r\ndata);\r\nif (err != 2) {\r\ndev_err(&dev->intf->dev,\r\n"failed to read hardware configuration data from eeprom (err=%d)\n",\r\nerr);\r\ngoto error;\r\n}\r\nhwconf_offset = mc_start + data[0] + (data[1] << 8);\r\nerr = em28xx_i2c_read_block(dev, bus, hwconf_offset, 1, len,\r\ndata);\r\nif (err != len) {\r\ndev_err(&dev->intf->dev,\r\n"failed to read hardware configuration data from eeprom (err=%d)\n",\r\nerr);\r\ngoto error;\r\n}\r\nif (data[0] != 0x1a || data[1] != 0xeb ||\r\ndata[2] != 0x67 || data[3] != 0x95) {\r\ndev_info(&dev->intf->dev,\r\n"\tno hardware configuration dataset found in eeprom\n");\r\nkfree(data);\r\nreturn 0;\r\n}\r\n} else if (!dev->eeprom_addrwidth_16bit &&\r\ndata[0] == 0x1a && data[1] == 0xeb &&\r\ndata[2] == 0x67 && data[3] == 0x95) {\r\ndev->hash = em28xx_hash_mem(data, len, 32);\r\ndev_info(&dev->intf->dev,\r\n"EEPROM ID = %02x %02x %02x %02x, EEPROM hash = 0x%08lx\n",\r\ndata[0], data[1], data[2], data[3], dev->hash);\r\ndev_info(&dev->intf->dev,\r\n"EEPROM info:\n");\r\n} else {\r\ndev_info(&dev->intf->dev,\r\n"unknown eeprom format or eeprom corrupted !\n");\r\nerr = -ENODEV;\r\ngoto error;\r\n}\r\n*eedata = data;\r\n*eedata_len = len;\r\ndev_config = (void *)*eedata;\r\nswitch (le16_to_cpu(dev_config->chip_conf) >> 4 & 0x3) {\r\ncase 0:\r\ndev_info(&dev->intf->dev, "\tNo audio on board.\n");\r\nbreak;\r\ncase 1:\r\ndev_info(&dev->intf->dev, "\tAC97 audio (5 sample rates)\n");\r\nbreak;\r\ncase 2:\r\nif (dev->chip_id < CHIP_ID_EM2860)\r\ndev_info(&dev->intf->dev,\r\n"\tI2S audio, sample rate=32k\n");\r\nelse\r\ndev_info(&dev->intf->dev,\r\n"\tI2S audio, 3 sample rates\n");\r\nbreak;\r\ncase 3:\r\nif (dev->chip_id < CHIP_ID_EM2860)\r\ndev_info(&dev->intf->dev,\r\n"\tI2S audio, 3 sample rates\n");\r\nelse\r\ndev_info(&dev->intf->dev,\r\n"\tI2S audio, 5 sample rates\n");\r\nbreak;\r\n}\r\nif (le16_to_cpu(dev_config->chip_conf) & 1 << 3)\r\ndev_info(&dev->intf->dev, "\tUSB Remote wakeup capable\n");\r\nif (le16_to_cpu(dev_config->chip_conf) & 1 << 2)\r\ndev_info(&dev->intf->dev, "\tUSB Self power capable\n");\r\nswitch (le16_to_cpu(dev_config->chip_conf) & 0x3) {\r\ncase 0:\r\ndev_info(&dev->intf->dev, "\t500mA max power\n");\r\nbreak;\r\ncase 1:\r\ndev_info(&dev->intf->dev, "\t400mA max power\n");\r\nbreak;\r\ncase 2:\r\ndev_info(&dev->intf->dev, "\t300mA max power\n");\r\nbreak;\r\ncase 3:\r\ndev_info(&dev->intf->dev, "\t200mA max power\n");\r\nbreak;\r\n}\r\ndev_info(&dev->intf->dev,\r\n"\tTable at offset 0x%02x, strings=0x%04x, 0x%04x, 0x%04x\n",\r\ndev_config->string_idx_table,\r\nle16_to_cpu(dev_config->string1),\r\nle16_to_cpu(dev_config->string2),\r\nle16_to_cpu(dev_config->string3));\r\nreturn 0;\r\nerror:\r\nkfree(data);\r\nreturn err;\r\n}\r\nstatic u32 functionality(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct em28xx_i2c_bus *i2c_bus = i2c_adap->algo_data;\r\nif ((i2c_bus->algo_type == EM28XX_I2C_ALGO_EM28XX) ||\r\n(i2c_bus->algo_type == EM28XX_I2C_ALGO_EM25XX_BUS_B)) {\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n} else if (i2c_bus->algo_type == EM28XX_I2C_ALGO_EM2800) {\r\nreturn (I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL) &\r\n~I2C_FUNC_SMBUS_WRITE_BLOCK_DATA;\r\n}\r\nWARN(1, "Unknown i2c bus algorithm.\n");\r\nreturn 0;\r\n}\r\nvoid em28xx_do_i2c_scan(struct em28xx *dev, unsigned bus)\r\n{\r\nu8 i2c_devicelist[128];\r\nunsigned char buf;\r\nint i, rc;\r\nmemset(i2c_devicelist, 0, ARRAY_SIZE(i2c_devicelist));\r\nfor (i = 0; i < ARRAY_SIZE(i2c_devs); i++) {\r\ndev->i2c_client[bus].addr = i;\r\nrc = i2c_master_recv(&dev->i2c_client[bus], &buf, 0);\r\nif (rc < 0)\r\ncontinue;\r\ni2c_devicelist[i] = i;\r\ndev_info(&dev->intf->dev,\r\n"found i2c device @ 0x%x on bus %d [%s]\n",\r\ni << 1, bus, i2c_devs[i] ? i2c_devs[i] : "???");\r\n}\r\nif (bus == dev->def_i2c_bus)\r\ndev->i2c_hash = em28xx_hash_mem(i2c_devicelist,\r\nARRAY_SIZE(i2c_devicelist), 32);\r\n}\r\nint em28xx_i2c_register(struct em28xx *dev, unsigned bus,\r\nenum em28xx_i2c_algo_type algo_type)\r\n{\r\nint retval;\r\nBUG_ON(!dev->em28xx_write_regs || !dev->em28xx_read_reg);\r\nBUG_ON(!dev->em28xx_write_regs_req || !dev->em28xx_read_reg_req);\r\nif (bus >= NUM_I2C_BUSES)\r\nreturn -ENODEV;\r\ndev->i2c_adap[bus] = em28xx_adap_template;\r\ndev->i2c_adap[bus].dev.parent = &dev->intf->dev;\r\nstrcpy(dev->i2c_adap[bus].name, dev_name(&dev->intf->dev));\r\ndev->i2c_bus[bus].bus = bus;\r\ndev->i2c_bus[bus].algo_type = algo_type;\r\ndev->i2c_bus[bus].dev = dev;\r\ndev->i2c_adap[bus].algo_data = &dev->i2c_bus[bus];\r\nretval = i2c_add_adapter(&dev->i2c_adap[bus]);\r\nif (retval < 0) {\r\ndev_err(&dev->intf->dev,\r\n"%s: i2c_add_adapter failed! retval [%d]\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\ndev->i2c_client[bus] = em28xx_client_template;\r\ndev->i2c_client[bus].adapter = &dev->i2c_adap[bus];\r\nif (!bus) {\r\nretval = em28xx_i2c_eeprom(dev, bus, &dev->eedata, &dev->eedata_len);\r\nif ((retval < 0) && (retval != -ENODEV)) {\r\ndev_err(&dev->intf->dev,\r\n"%s: em28xx_i2_eeprom failed! retval [%d]\n",\r\n__func__, retval);\r\nreturn retval;\r\n}\r\n}\r\nif (i2c_scan)\r\nem28xx_do_i2c_scan(dev, bus);\r\nreturn 0;\r\n}\r\nint em28xx_i2c_unregister(struct em28xx *dev, unsigned bus)\r\n{\r\nif (bus >= NUM_I2C_BUSES)\r\nreturn -ENODEV;\r\ni2c_del_adapter(&dev->i2c_adap[bus]);\r\nreturn 0;\r\n}
