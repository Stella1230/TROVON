static void fc_disc_stop_rports(struct fc_disc *disc)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_rport_priv *rdata;\r\nlport = fc_disc_lport(disc);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(rdata, &disc->rports, peers) {\r\nif (kref_get_unless_zero(&rdata->kref)) {\r\nfc_rport_logoff(rdata);\r\nkref_put(&rdata->kref, fc_rport_destroy);\r\n}\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void fc_disc_recv_rscn_req(struct fc_disc *disc, struct fc_frame *fp)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_els_rscn *rp;\r\nstruct fc_els_rscn_page *pp;\r\nstruct fc_seq_els_data rjt_data;\r\nunsigned int len;\r\nint redisc = 0;\r\nenum fc_els_rscn_ev_qual ev_qual;\r\nenum fc_els_rscn_addr_fmt fmt;\r\nLIST_HEAD(disc_ports);\r\nstruct fc_disc_port *dp, *next;\r\nlport = fc_disc_lport(disc);\r\nFC_DISC_DBG(disc, "Received an RSCN event\n");\r\nrp = fc_frame_payload_get(fp, sizeof(*rp));\r\nif (!rp)\r\ngoto reject;\r\nif (rp->rscn_page_len != sizeof(*pp))\r\ngoto reject;\r\nlen = ntohs(rp->rscn_plen);\r\nif (len < sizeof(*rp))\r\ngoto reject;\r\nrp = fc_frame_payload_get(fp, len);\r\nif (!rp)\r\ngoto reject;\r\nlen -= sizeof(*rp);\r\nif (len % sizeof(*pp))\r\ngoto reject;\r\nfor (pp = (void *)(rp + 1); len > 0; len -= sizeof(*pp), pp++) {\r\nev_qual = pp->rscn_page_flags >> ELS_RSCN_EV_QUAL_BIT;\r\nev_qual &= ELS_RSCN_EV_QUAL_MASK;\r\nfmt = pp->rscn_page_flags >> ELS_RSCN_ADDR_FMT_BIT;\r\nfmt &= ELS_RSCN_ADDR_FMT_MASK;\r\nswitch (fmt) {\r\ncase ELS_ADDR_FMT_PORT:\r\nFC_DISC_DBG(disc, "Port address format for port "\r\n"(%6.6x)\n", ntoh24(pp->rscn_fid));\r\ndp = kzalloc(sizeof(*dp), GFP_KERNEL);\r\nif (!dp) {\r\nredisc = 1;\r\nbreak;\r\n}\r\ndp->lp = lport;\r\ndp->port_id = ntoh24(pp->rscn_fid);\r\nlist_add_tail(&dp->peers, &disc_ports);\r\nbreak;\r\ncase ELS_ADDR_FMT_AREA:\r\ncase ELS_ADDR_FMT_DOM:\r\ncase ELS_ADDR_FMT_FAB:\r\ndefault:\r\nFC_DISC_DBG(disc, "Address format is (%d)\n", fmt);\r\nredisc = 1;\r\nbreak;\r\n}\r\n}\r\nfc_seq_els_rsp_send(fp, ELS_LS_ACC, NULL);\r\nlist_for_each_entry_safe(dp, next, &disc_ports, peers) {\r\nlist_del(&dp->peers);\r\nif (!redisc)\r\nredisc = fc_disc_single(lport, dp);\r\nkfree(dp);\r\n}\r\nif (redisc) {\r\nFC_DISC_DBG(disc, "RSCN received: rediscovering\n");\r\nfc_disc_restart(disc);\r\n} else {\r\nFC_DISC_DBG(disc, "RSCN received: not rediscovering. "\r\n"redisc %d state %d in_prog %d\n",\r\nredisc, lport->state, disc->pending);\r\n}\r\nfc_frame_free(fp);\r\nreturn;\r\nreject:\r\nFC_DISC_DBG(disc, "Received a bad RSCN frame\n");\r\nrjt_data.reason = ELS_RJT_LOGIC;\r\nrjt_data.explan = ELS_EXPL_NONE;\r\nfc_seq_els_rsp_send(fp, ELS_LS_RJT, &rjt_data);\r\nfc_frame_free(fp);\r\n}\r\nstatic void fc_disc_recv_req(struct fc_lport *lport, struct fc_frame *fp)\r\n{\r\nu8 op;\r\nstruct fc_disc *disc = &lport->disc;\r\nop = fc_frame_payload_op(fp);\r\nswitch (op) {\r\ncase ELS_RSCN:\r\nmutex_lock(&disc->disc_mutex);\r\nfc_disc_recv_rscn_req(disc, fp);\r\nmutex_unlock(&disc->disc_mutex);\r\nbreak;\r\ndefault:\r\nFC_DISC_DBG(disc, "Received an unsupported request, "\r\n"the opcode is (%x)\n", op);\r\nfc_frame_free(fp);\r\nbreak;\r\n}\r\n}\r\nstatic void fc_disc_restart(struct fc_disc *disc)\r\n{\r\nif (!disc->disc_callback)\r\nreturn;\r\nFC_DISC_DBG(disc, "Restarting discovery\n");\r\ndisc->requested = 1;\r\nif (disc->pending)\r\nreturn;\r\ndisc->disc_id = (disc->disc_id + 2) | 1;\r\ndisc->retry_count = 0;\r\nfc_disc_gpn_ft_req(disc);\r\n}\r\nstatic void fc_disc_start(void (*disc_callback)(struct fc_lport *,\r\nenum fc_disc_event),\r\nstruct fc_lport *lport)\r\n{\r\nstruct fc_disc *disc = &lport->disc;\r\nmutex_lock(&disc->disc_mutex);\r\ndisc->disc_callback = disc_callback;\r\nfc_disc_restart(disc);\r\nmutex_unlock(&disc->disc_mutex);\r\n}\r\nstatic void fc_disc_done(struct fc_disc *disc, enum fc_disc_event event)\r\n{\r\nstruct fc_lport *lport = fc_disc_lport(disc);\r\nstruct fc_rport_priv *rdata;\r\nFC_DISC_DBG(disc, "Discovery complete\n");\r\ndisc->pending = 0;\r\nif (disc->requested) {\r\nfc_disc_restart(disc);\r\nreturn;\r\n}\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(rdata, &disc->rports, peers) {\r\nif (!kref_get_unless_zero(&rdata->kref))\r\ncontinue;\r\nif (rdata->disc_id) {\r\nif (rdata->disc_id == disc->disc_id)\r\nfc_rport_login(rdata);\r\nelse\r\nfc_rport_logoff(rdata);\r\n}\r\nkref_put(&rdata->kref, fc_rport_destroy);\r\n}\r\nrcu_read_unlock();\r\nmutex_unlock(&disc->disc_mutex);\r\ndisc->disc_callback(lport, event);\r\nmutex_lock(&disc->disc_mutex);\r\n}\r\nstatic void fc_disc_error(struct fc_disc *disc, struct fc_frame *fp)\r\n{\r\nstruct fc_lport *lport = fc_disc_lport(disc);\r\nunsigned long delay = 0;\r\nFC_DISC_DBG(disc, "Error %ld, retries %d/%d\n",\r\nPTR_ERR(fp), disc->retry_count,\r\nFC_DISC_RETRY_LIMIT);\r\nif (!fp || PTR_ERR(fp) == -FC_EX_TIMEOUT) {\r\nif (disc->retry_count < FC_DISC_RETRY_LIMIT) {\r\nif (!fp)\r\ndelay = msecs_to_jiffies(FC_DISC_RETRY_DELAY);\r\nelse {\r\ndelay = msecs_to_jiffies(lport->e_d_tov);\r\nif (!disc->retry_count)\r\ndelay /= 4;\r\n}\r\ndisc->retry_count++;\r\nschedule_delayed_work(&disc->disc_work, delay);\r\n} else\r\nfc_disc_done(disc, DISC_EV_FAILED);\r\n} else if (PTR_ERR(fp) == -FC_EX_CLOSED) {\r\ndisc->pending = 0;\r\n}\r\n}\r\nstatic void fc_disc_gpn_ft_req(struct fc_disc *disc)\r\n{\r\nstruct fc_frame *fp;\r\nstruct fc_lport *lport = fc_disc_lport(disc);\r\nWARN_ON(!fc_lport_test_ready(lport));\r\ndisc->pending = 1;\r\ndisc->requested = 0;\r\ndisc->buf_len = 0;\r\ndisc->seq_count = 0;\r\nfp = fc_frame_alloc(lport,\r\nsizeof(struct fc_ct_hdr) +\r\nsizeof(struct fc_ns_gid_ft));\r\nif (!fp)\r\ngoto err;\r\nif (lport->tt.elsct_send(lport, 0, fp,\r\nFC_NS_GPN_FT,\r\nfc_disc_gpn_ft_resp,\r\ndisc, 3 * lport->r_a_tov))\r\nreturn;\r\nerr:\r\nfc_disc_error(disc, NULL);\r\n}\r\nstatic int fc_disc_gpn_ft_parse(struct fc_disc *disc, void *buf, size_t len)\r\n{\r\nstruct fc_lport *lport;\r\nstruct fc_gpn_ft_resp *np;\r\nchar *bp;\r\nsize_t plen;\r\nsize_t tlen;\r\nint error = 0;\r\nstruct fc_rport_identifiers ids;\r\nstruct fc_rport_priv *rdata;\r\nlport = fc_disc_lport(disc);\r\ndisc->seq_count++;\r\nbp = buf;\r\nplen = len;\r\nnp = (struct fc_gpn_ft_resp *)bp;\r\ntlen = disc->buf_len;\r\ndisc->buf_len = 0;\r\nif (tlen) {\r\nWARN_ON(tlen >= sizeof(*np));\r\nplen = sizeof(*np) - tlen;\r\nWARN_ON(plen <= 0);\r\nWARN_ON(plen >= sizeof(*np));\r\nif (plen > len)\r\nplen = len;\r\nnp = &disc->partial_buf;\r\nmemcpy((char *)np + tlen, bp, plen);\r\nbp -= tlen;\r\nlen += tlen;\r\nplen += tlen;\r\ndisc->buf_len = (unsigned char) plen;\r\nif (plen == sizeof(*np))\r\ndisc->buf_len = 0;\r\n}\r\nwhile (plen >= sizeof(*np)) {\r\nids.port_id = ntoh24(np->fp_fid);\r\nids.port_name = ntohll(np->fp_wwpn);\r\nif (ids.port_id != lport->port_id &&\r\nids.port_name != lport->wwpn) {\r\nrdata = fc_rport_create(lport, ids.port_id);\r\nif (rdata) {\r\nrdata->ids.port_name = ids.port_name;\r\nrdata->disc_id = disc->disc_id;\r\n} else {\r\nprintk(KERN_WARNING "libfc: Failed to allocate "\r\n"memory for the newly discovered port "\r\n"(%6.6x)\n", ids.port_id);\r\nerror = -ENOMEM;\r\n}\r\n}\r\nif (np->fp_flags & FC_NS_FID_LAST) {\r\nfc_disc_done(disc, DISC_EV_SUCCESS);\r\nlen = 0;\r\nbreak;\r\n}\r\nlen -= sizeof(*np);\r\nbp += sizeof(*np);\r\nnp = (struct fc_gpn_ft_resp *)bp;\r\nplen = len;\r\n}\r\nif (error == 0 && len > 0 && len < sizeof(*np)) {\r\nif (np != &disc->partial_buf) {\r\nFC_DISC_DBG(disc, "Partial buffer remains "\r\n"for discovery\n");\r\nmemcpy(&disc->partial_buf, np, len);\r\n}\r\ndisc->buf_len = (unsigned char) len;\r\n}\r\nreturn error;\r\n}\r\nstatic void fc_disc_timeout(struct work_struct *work)\r\n{\r\nstruct fc_disc *disc = container_of(work,\r\nstruct fc_disc,\r\ndisc_work.work);\r\nmutex_lock(&disc->disc_mutex);\r\nfc_disc_gpn_ft_req(disc);\r\nmutex_unlock(&disc->disc_mutex);\r\n}\r\nstatic void fc_disc_gpn_ft_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *disc_arg)\r\n{\r\nstruct fc_disc *disc = disc_arg;\r\nstruct fc_ct_hdr *cp;\r\nstruct fc_frame_header *fh;\r\nenum fc_disc_event event = DISC_EV_NONE;\r\nunsigned int seq_cnt;\r\nunsigned int len;\r\nint error = 0;\r\nmutex_lock(&disc->disc_mutex);\r\nFC_DISC_DBG(disc, "Received a GPN_FT response\n");\r\nif (IS_ERR(fp)) {\r\nfc_disc_error(disc, fp);\r\nmutex_unlock(&disc->disc_mutex);\r\nreturn;\r\n}\r\nWARN_ON(!fc_frame_is_linear(fp));\r\nfh = fc_frame_header_get(fp);\r\nlen = fr_len(fp) - sizeof(*fh);\r\nseq_cnt = ntohs(fh->fh_seq_cnt);\r\nif (fr_sof(fp) == FC_SOF_I3 && seq_cnt == 0 && disc->seq_count == 0) {\r\ncp = fc_frame_payload_get(fp, sizeof(*cp));\r\nif (!cp) {\r\nFC_DISC_DBG(disc, "GPN_FT response too short, len %d\n",\r\nfr_len(fp));\r\nevent = DISC_EV_FAILED;\r\n} else if (ntohs(cp->ct_cmd) == FC_FS_ACC) {\r\nlen -= sizeof(*cp);\r\nerror = fc_disc_gpn_ft_parse(disc, cp + 1, len);\r\n} else if (ntohs(cp->ct_cmd) == FC_FS_RJT) {\r\nFC_DISC_DBG(disc, "GPN_FT rejected reason %x exp %x "\r\n"(check zoning)\n", cp->ct_reason,\r\ncp->ct_explan);\r\nevent = DISC_EV_FAILED;\r\nif (cp->ct_reason == FC_FS_RJT_UNABL &&\r\ncp->ct_explan == FC_FS_EXP_FTNR)\r\nevent = DISC_EV_SUCCESS;\r\n} else {\r\nFC_DISC_DBG(disc, "GPN_FT unexpected response code "\r\n"%x\n", ntohs(cp->ct_cmd));\r\nevent = DISC_EV_FAILED;\r\n}\r\n} else if (fr_sof(fp) == FC_SOF_N3 && seq_cnt == disc->seq_count) {\r\nerror = fc_disc_gpn_ft_parse(disc, fh + 1, len);\r\n} else {\r\nFC_DISC_DBG(disc, "GPN_FT unexpected frame - out of sequence? "\r\n"seq_cnt %x expected %x sof %x eof %x\n",\r\nseq_cnt, disc->seq_count, fr_sof(fp), fr_eof(fp));\r\nevent = DISC_EV_FAILED;\r\n}\r\nif (error)\r\nfc_disc_error(disc, fp);\r\nelse if (event != DISC_EV_NONE)\r\nfc_disc_done(disc, event);\r\nfc_frame_free(fp);\r\nmutex_unlock(&disc->disc_mutex);\r\n}\r\nstatic void fc_disc_gpn_id_resp(struct fc_seq *sp, struct fc_frame *fp,\r\nvoid *rdata_arg)\r\n{\r\nstruct fc_rport_priv *rdata = rdata_arg;\r\nstruct fc_rport_priv *new_rdata;\r\nstruct fc_lport *lport;\r\nstruct fc_disc *disc;\r\nstruct fc_ct_hdr *cp;\r\nstruct fc_ns_gid_pn *pn;\r\nu64 port_name;\r\nlport = rdata->local_port;\r\ndisc = &lport->disc;\r\nif (PTR_ERR(fp) == -FC_EX_CLOSED)\r\ngoto out;\r\nif (IS_ERR(fp))\r\ngoto redisc;\r\ncp = fc_frame_payload_get(fp, sizeof(*cp));\r\nif (!cp)\r\ngoto redisc;\r\nif (ntohs(cp->ct_cmd) == FC_FS_ACC) {\r\nif (fr_len(fp) < sizeof(struct fc_frame_header) +\r\nsizeof(*cp) + sizeof(*pn))\r\ngoto redisc;\r\npn = (struct fc_ns_gid_pn *)(cp + 1);\r\nport_name = get_unaligned_be64(&pn->fn_wwpn);\r\nmutex_lock(&rdata->rp_mutex);\r\nif (rdata->ids.port_name == -1)\r\nrdata->ids.port_name = port_name;\r\nelse if (rdata->ids.port_name != port_name) {\r\nFC_DISC_DBG(disc, "GPN_ID accepted. WWPN changed. "\r\n"Port-id %6.6x wwpn %16.16llx\n",\r\nrdata->ids.port_id, port_name);\r\nmutex_unlock(&rdata->rp_mutex);\r\nfc_rport_logoff(rdata);\r\nmutex_lock(&lport->disc.disc_mutex);\r\nnew_rdata = fc_rport_create(lport, rdata->ids.port_id);\r\nmutex_unlock(&lport->disc.disc_mutex);\r\nif (new_rdata) {\r\nnew_rdata->disc_id = disc->disc_id;\r\nfc_rport_login(new_rdata);\r\n}\r\ngoto out;\r\n}\r\nrdata->disc_id = disc->disc_id;\r\nmutex_unlock(&rdata->rp_mutex);\r\nfc_rport_login(rdata);\r\n} else if (ntohs(cp->ct_cmd) == FC_FS_RJT) {\r\nFC_DISC_DBG(disc, "GPN_ID rejected reason %x exp %x\n",\r\ncp->ct_reason, cp->ct_explan);\r\nfc_rport_logoff(rdata);\r\n} else {\r\nFC_DISC_DBG(disc, "GPN_ID unexpected response code %x\n",\r\nntohs(cp->ct_cmd));\r\nredisc:\r\nmutex_lock(&disc->disc_mutex);\r\nfc_disc_restart(disc);\r\nmutex_unlock(&disc->disc_mutex);\r\n}\r\nout:\r\nkref_put(&rdata->kref, fc_rport_destroy);\r\n}\r\nstatic int fc_disc_gpn_id_req(struct fc_lport *lport,\r\nstruct fc_rport_priv *rdata)\r\n{\r\nstruct fc_frame *fp;\r\nfp = fc_frame_alloc(lport, sizeof(struct fc_ct_hdr) +\r\nsizeof(struct fc_ns_fid));\r\nif (!fp)\r\nreturn -ENOMEM;\r\nif (!lport->tt.elsct_send(lport, rdata->ids.port_id, fp, FC_NS_GPN_ID,\r\nfc_disc_gpn_id_resp, rdata,\r\n3 * lport->r_a_tov))\r\nreturn -ENOMEM;\r\nkref_get(&rdata->kref);\r\nreturn 0;\r\n}\r\nstatic int fc_disc_single(struct fc_lport *lport, struct fc_disc_port *dp)\r\n{\r\nstruct fc_rport_priv *rdata;\r\nrdata = fc_rport_create(lport, dp->port_id);\r\nif (!rdata)\r\nreturn -ENOMEM;\r\nrdata->disc_id = 0;\r\nreturn fc_disc_gpn_id_req(lport, rdata);\r\n}\r\nstatic void fc_disc_stop(struct fc_lport *lport)\r\n{\r\nstruct fc_disc *disc = &lport->disc;\r\nif (disc->pending)\r\ncancel_delayed_work_sync(&disc->disc_work);\r\nfc_disc_stop_rports(disc);\r\n}\r\nstatic void fc_disc_stop_final(struct fc_lport *lport)\r\n{\r\nfc_disc_stop(lport);\r\nfc_rport_flush_queue();\r\n}\r\nvoid fc_disc_config(struct fc_lport *lport, void *priv)\r\n{\r\nstruct fc_disc *disc = &lport->disc;\r\nif (!lport->tt.disc_start)\r\nlport->tt.disc_start = fc_disc_start;\r\nif (!lport->tt.disc_stop)\r\nlport->tt.disc_stop = fc_disc_stop;\r\nif (!lport->tt.disc_stop_final)\r\nlport->tt.disc_stop_final = fc_disc_stop_final;\r\nif (!lport->tt.disc_recv_req)\r\nlport->tt.disc_recv_req = fc_disc_recv_req;\r\ndisc = &lport->disc;\r\ndisc->priv = priv;\r\n}\r\nvoid fc_disc_init(struct fc_lport *lport)\r\n{\r\nstruct fc_disc *disc = &lport->disc;\r\nINIT_DELAYED_WORK(&disc->disc_work, fc_disc_timeout);\r\nmutex_init(&disc->disc_mutex);\r\nINIT_LIST_HEAD(&disc->rports);\r\n}
