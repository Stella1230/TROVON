static void rtc_delayed_write(u32 val, struct armada38x_rtc *rtc, int offset)\r\n{\r\nwritel(0, rtc->regs + RTC_STATUS);\r\nwritel(0, rtc->regs + RTC_STATUS);\r\nwritel(val, rtc->regs + offset);\r\nudelay(5);\r\n}\r\nstatic void rtc_update_38x_mbus_timing_params(struct armada38x_rtc *rtc)\r\n{\r\nu32 reg;\r\nreg = readl(rtc->regs_soc + RTC_38X_BRIDGE_TIMING_CTL);\r\nreg &= ~RTC_38X_PERIOD_MASK;\r\nreg |= 0x3FF << RTC_38X_PERIOD_OFFS;\r\nreg &= ~RTC_38X_READ_DELAY_MASK;\r\nreg |= 0x1F << RTC_38X_READ_DELAY_OFFS;\r\nwritel(reg, rtc->regs_soc + RTC_38X_BRIDGE_TIMING_CTL);\r\n}\r\nstatic void rtc_update_8k_mbus_timing_params(struct armada38x_rtc *rtc)\r\n{\r\nu32 reg;\r\nreg = readl(rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL0);\r\nreg &= ~RTC_8K_WRCLK_PERIOD_MASK;\r\nreg |= 0x3FF << RTC_8K_WRCLK_PERIOD_OFFS;\r\nreg &= ~RTC_8K_WRCLK_SETUP_MASK;\r\nreg |= 0x29 << RTC_8K_WRCLK_SETUP_OFFS;\r\nwritel(reg, rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL0);\r\nreg = readl(rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL1);\r\nreg &= ~RTC_8K_READ_DELAY_MASK;\r\nreg |= 0x3F << RTC_8K_READ_DELAY_OFFS;\r\nwritel(reg, rtc->regs_soc + RTC_8K_BRIDGE_TIMING_CTL1);\r\n}\r\nstatic u32 read_rtc_register(struct armada38x_rtc *rtc, u8 rtc_reg)\r\n{\r\nreturn readl(rtc->regs + rtc_reg);\r\n}\r\nstatic u32 read_rtc_register_38x_wa(struct armada38x_rtc *rtc, u8 rtc_reg)\r\n{\r\nint i, index_max = 0, max = 0;\r\nfor (i = 0; i < SAMPLE_NR; i++) {\r\nrtc->val_to_freq[i].value = readl(rtc->regs + rtc_reg);\r\nrtc->val_to_freq[i].freq = 0;\r\n}\r\nfor (i = 0; i < SAMPLE_NR; i++) {\r\nint j = 0;\r\nu32 value = rtc->val_to_freq[i].value;\r\nwhile (rtc->val_to_freq[j].freq) {\r\nif (rtc->val_to_freq[j].value == value) {\r\nrtc->val_to_freq[j].freq++;\r\nbreak;\r\n}\r\nj++;\r\n}\r\nif (!rtc->val_to_freq[j].freq) {\r\nrtc->val_to_freq[j].value = value;\r\nrtc->val_to_freq[j].freq = 1;\r\n}\r\nif (rtc->val_to_freq[j].freq > max) {\r\nindex_max = j;\r\nmax = rtc->val_to_freq[j].freq;\r\n}\r\nif (max > SAMPLE_NR / 2)\r\nbreak;\r\n}\r\nreturn rtc->val_to_freq[index_max].value;\r\n}\r\nstatic void armada38x_clear_isr(struct armada38x_rtc *rtc)\r\n{\r\nu32 val = readl(rtc->regs_soc + SOC_RTC_INTERRUPT);\r\nwritel(val & ~SOC_RTC_ALARM1, rtc->regs_soc + SOC_RTC_INTERRUPT);\r\n}\r\nstatic void armada38x_unmask_interrupt(struct armada38x_rtc *rtc)\r\n{\r\nu32 val = readl(rtc->regs_soc + SOC_RTC_INTERRUPT);\r\nwritel(val | SOC_RTC_ALARM1_MASK, rtc->regs_soc + SOC_RTC_INTERRUPT);\r\n}\r\nstatic void armada8k_clear_isr(struct armada38x_rtc *rtc)\r\n{\r\nwritel(RTC_8K_ALARM2, rtc->regs_soc + RTC_8K_ISR);\r\n}\r\nstatic void armada8k_unmask_interrupt(struct armada38x_rtc *rtc)\r\n{\r\nwritel(RTC_8K_ALARM2, rtc->regs_soc + RTC_8K_IMR);\r\n}\r\nstatic int armada38x_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long time, flags;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\ntime = rtc->data->read_rtc_reg(rtc, RTC_TIME);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nrtc_time_to_tm(time, tm);\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_set_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nint ret = 0;\r\nunsigned long time, flags;\r\nret = rtc_tm_to_time(tm, &time);\r\nif (ret)\r\ngoto out;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nrtc_delayed_write(time, rtc, RTC_TIME);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int armada38x_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long time, flags;\r\nu32 reg = ALARM_REG(RTC_ALARM1, rtc->data->alarm);\r\nu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\r\nu32 val;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\ntime = rtc->data->read_rtc_reg(rtc, reg);\r\nval = rtc->data->read_rtc_reg(rtc, reg_irq) & RTC_IRQ_AL_EN;\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nalrm->enabled = val ? 1 : 0;\r\nrtc_time_to_tm(time, &alrm->time);\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nu32 reg = ALARM_REG(RTC_ALARM1, rtc->data->alarm);\r\nu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\r\nunsigned long time, flags;\r\nint ret = 0;\r\nret = rtc_tm_to_time(&alrm->time, &time);\r\nif (ret)\r\ngoto out;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nrtc_delayed_write(time, rtc, reg);\r\nif (alrm->enabled) {\r\nrtc_delayed_write(RTC_IRQ_AL_EN, rtc, reg_irq);\r\nrtc->data->unmask_interrupt(rtc);\r\n}\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int armada38x_rtc_alarm_irq_enable(struct device *dev,\r\nunsigned int enabled)\r\n{\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\r\nunsigned long flags;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nif (enabled)\r\nrtc_delayed_write(RTC_IRQ_AL_EN, rtc, reg_irq);\r\nelse\r\nrtc_delayed_write(0, rtc, reg_irq);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t armada38x_rtc_alarm_irq(int irq, void *data)\r\n{\r\nstruct armada38x_rtc *rtc = data;\r\nu32 val;\r\nint event = RTC_IRQF | RTC_AF;\r\nu32 reg_irq = ALARM_REG(RTC_IRQ1_CONF, rtc->data->alarm);\r\ndev_dbg(&rtc->rtc_dev->dev, "%s:irq(%d)\n", __func__, irq);\r\nspin_lock(&rtc->lock);\r\nrtc->data->clear_isr(rtc);\r\nval = rtc->data->read_rtc_reg(rtc, reg_irq);\r\nrtc_delayed_write(0, rtc, reg_irq);\r\nrtc_delayed_write(1 << rtc->data->alarm, rtc, RTC_STATUS);\r\nspin_unlock(&rtc->lock);\r\nif (val & RTC_IRQ_FREQ_EN) {\r\nif (val & RTC_IRQ_FREQ_1HZ)\r\nevent |= RTC_UF;\r\nelse\r\nevent |= RTC_PF;\r\n}\r\nrtc_update_irq(rtc->rtc_dev, 1, event);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic __init int armada38x_rtc_probe(struct platform_device *pdev)\r\n{\r\nconst struct rtc_class_ops *ops;\r\nstruct resource *res;\r\nstruct armada38x_rtc *rtc;\r\nconst struct of_device_id *match;\r\nint ret;\r\nmatch = of_match_device(armada38x_rtc_of_match_table, &pdev->dev);\r\nif (!match)\r\nreturn -ENODEV;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(struct armada38x_rtc),\r\nGFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nrtc->val_to_freq = devm_kcalloc(&pdev->dev, SAMPLE_NR,\r\nsizeof(struct value_to_freq), GFP_KERNEL);\r\nif (!rtc->val_to_freq)\r\nreturn -ENOMEM;\r\nspin_lock_init(&rtc->lock);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rtc");\r\nrtc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->regs))\r\nreturn PTR_ERR(rtc->regs);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rtc-soc");\r\nrtc->regs_soc = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->regs_soc))\r\nreturn PTR_ERR(rtc->regs_soc);\r\nrtc->irq = platform_get_irq(pdev, 0);\r\nif (rtc->irq < 0) {\r\ndev_err(&pdev->dev, "no irq\n");\r\nreturn rtc->irq;\r\n}\r\nif (devm_request_irq(&pdev->dev, rtc->irq, armada38x_rtc_alarm_irq,\r\n0, pdev->name, rtc) < 0) {\r\ndev_warn(&pdev->dev, "Interrupt not available.\n");\r\nrtc->irq = -1;\r\n}\r\nplatform_set_drvdata(pdev, rtc);\r\nif (rtc->irq != -1) {\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nops = &armada38x_rtc_ops;\r\n} else {\r\nops = &armada38x_rtc_ops_noirq;\r\n}\r\nrtc->data = (struct armada38x_rtc_data *)match->data;\r\nrtc->data->update_mbus_timing(rtc);\r\nrtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,\r\nops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc_dev)) {\r\nret = PTR_ERR(rtc->rtc_dev);\r\ndev_err(&pdev->dev, "Failed to register RTC device: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_suspend(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev)) {\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nreturn enable_irq_wake(rtc->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int armada38x_rtc_resume(struct device *dev)\r\n{\r\nif (device_may_wakeup(dev)) {\r\nstruct armada38x_rtc *rtc = dev_get_drvdata(dev);\r\nrtc->data->update_mbus_timing(rtc);\r\nreturn disable_irq_wake(rtc->irq);\r\n}\r\nreturn 0;\r\n}
