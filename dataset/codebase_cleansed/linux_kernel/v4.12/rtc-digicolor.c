static int dc_rtc_cmds(struct dc_rtc *rtc, const u8 *cmds, int len)\r\n{\r\nu8 val;\r\nint i, ret;\r\nfor (i = 0; i < len; i++) {\r\nwriteb_relaxed((cmds[i] & DC_RTC_CMD_MASK) | DC_RTC_GO_BUSY,\r\nrtc->regs + DC_RTC_CONTROL);\r\nret = readb_relaxed_poll_timeout(\r\nrtc->regs + DC_RTC_CONTROL, val,\r\n!(val & DC_RTC_GO_BUSY), CMD_DELAY_US, CMD_TIMEOUT_US);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dc_rtc_read(struct dc_rtc *rtc, unsigned long *val)\r\n{\r\nstatic const u8 read_cmds[] = {CMD_READ, CMD_NOP};\r\nu32 reference, time1, time2;\r\nint ret;\r\nret = dc_rtc_cmds(rtc, read_cmds, ARRAY_SIZE(read_cmds));\r\nif (ret < 0)\r\nreturn ret;\r\nreference = readl_relaxed(rtc->regs + DC_RTC_REFERENCE);\r\ntime1 = readl_relaxed(rtc->regs + DC_RTC_TIME);\r\nwhile (1) {\r\ntime2 = readl_relaxed(rtc->regs + DC_RTC_TIME);\r\nif (time1 == time2)\r\nbreak;\r\ntime1 = time2;\r\n}\r\n*val = reference + time1;\r\nreturn 0;\r\n}\r\nstatic int dc_rtc_write(struct dc_rtc *rtc, u32 val)\r\n{\r\nstatic const u8 write_cmds[] = {CMD_WRITE, CMD_NOP, CMD_RESET, CMD_NOP};\r\nwritel_relaxed(val, rtc->regs + DC_RTC_REFERENCE);\r\nreturn dc_rtc_cmds(rtc, write_cmds, ARRAY_SIZE(write_cmds));\r\n}\r\nstatic int dc_rtc_read_time(struct device *dev, struct rtc_time *tm)\r\n{\r\nstruct dc_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long now;\r\nint ret;\r\nret = dc_rtc_read(rtc, &now);\r\nif (ret < 0)\r\nreturn ret;\r\nrtc_time64_to_tm(now, tm);\r\nreturn 0;\r\n}\r\nstatic int dc_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct dc_rtc *rtc = dev_get_drvdata(dev);\r\nreturn dc_rtc_write(rtc, secs);\r\n}\r\nstatic int dc_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct dc_rtc *rtc = dev_get_drvdata(dev);\r\nu32 alarm_reg, reference;\r\nunsigned long now;\r\nint ret;\r\nalarm_reg = readl_relaxed(rtc->regs + DC_RTC_ALARM);\r\nreference = readl_relaxed(rtc->regs + DC_RTC_REFERENCE);\r\nrtc_time64_to_tm(reference + alarm_reg, &alarm->time);\r\nret = dc_rtc_read(rtc, &now);\r\nif (ret < 0)\r\nreturn ret;\r\nalarm->pending = alarm_reg + reference > now;\r\nalarm->enabled = readl_relaxed(rtc->regs + DC_RTC_INTENABLE);\r\nreturn 0;\r\n}\r\nstatic int dc_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)\r\n{\r\nstruct dc_rtc *rtc = dev_get_drvdata(dev);\r\ntime64_t alarm_time;\r\nu32 reference;\r\nalarm_time = rtc_tm_to_time64(&alarm->time);\r\nreference = readl_relaxed(rtc->regs + DC_RTC_REFERENCE);\r\nwritel_relaxed(alarm_time - reference, rtc->regs + DC_RTC_ALARM);\r\nwriteb_relaxed(!!alarm->enabled, rtc->regs + DC_RTC_INTENABLE);\r\nreturn 0;\r\n}\r\nstatic int dc_rtc_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct dc_rtc *rtc = dev_get_drvdata(dev);\r\nwriteb_relaxed(!!enabled, rtc->regs + DC_RTC_INTENABLE);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t dc_rtc_irq(int irq, void *dev_id)\r\n{\r\nstruct dc_rtc *rtc = dev_id;\r\nwriteb_relaxed(1, rtc->regs + DC_RTC_INTFLAG_CLEAR);\r\nrtc_update_irq(rtc->rtc_dev, 1, RTC_AF | RTC_IRQF);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init dc_rtc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nstruct dc_rtc *rtc;\r\nint irq, ret;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrtc->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rtc->regs))\r\nreturn PTR_ERR(rtc->regs);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn irq;\r\nret = devm_request_irq(&pdev->dev, irq, dc_rtc_irq, 0, pdev->name, rtc);\r\nif (ret < 0)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, rtc);\r\nrtc->rtc_dev = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&dc_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc_dev))\r\nreturn PTR_ERR(rtc->rtc_dev);\r\nreturn 0;\r\n}
