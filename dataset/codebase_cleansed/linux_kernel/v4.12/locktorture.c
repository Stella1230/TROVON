static int torture_lock_busted_write_lock(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void torture_lock_busted_write_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_lock_busted_write_unlock(void)\r\n{\r\n}\r\nstatic void torture_boost_dummy(struct torture_random_state *trsp)\r\n{\r\n}\r\nstatic int torture_spin_lock_write_lock(void) __acquires(torture_spinlock)\r\n{\r\nspin_lock(&torture_spinlock);\r\nreturn 0;\r\n}\r\nstatic void torture_spin_lock_write_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long shortdelay_us = 2;\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms);\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2 * shortdelay_us)))\r\nudelay(shortdelay_us);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_spin_lock_write_unlock(void) __releases(torture_spinlock)\r\n{\r\nspin_unlock(&torture_spinlock);\r\n}\r\nstatic int torture_spin_lock_write_lock_irq(void)\r\n__acquires(torture_spinlock)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&torture_spinlock, flags);\r\ncxt.cur_ops->flags = flags;\r\nreturn 0;\r\n}\r\nstatic void torture_lock_spin_write_unlock_irq(void)\r\n__releases(torture_spinlock)\r\n{\r\nspin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);\r\n}\r\nstatic int torture_rwlock_write_lock(void) __acquires(torture_rwlock)\r\n{\r\nwrite_lock(&torture_rwlock);\r\nreturn 0;\r\n}\r\nstatic void torture_rwlock_write_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long shortdelay_us = 2;\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms);\r\nelse\r\nudelay(shortdelay_us);\r\n}\r\nstatic void torture_rwlock_write_unlock(void) __releases(torture_rwlock)\r\n{\r\nwrite_unlock(&torture_rwlock);\r\n}\r\nstatic int torture_rwlock_read_lock(void) __acquires(torture_rwlock)\r\n{\r\nread_lock(&torture_rwlock);\r\nreturn 0;\r\n}\r\nstatic void torture_rwlock_read_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long shortdelay_us = 10;\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealreaders_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms);\r\nelse\r\nudelay(shortdelay_us);\r\n}\r\nstatic void torture_rwlock_read_unlock(void) __releases(torture_rwlock)\r\n{\r\nread_unlock(&torture_rwlock);\r\n}\r\nstatic int torture_rwlock_write_lock_irq(void) __acquires(torture_rwlock)\r\n{\r\nunsigned long flags;\r\nwrite_lock_irqsave(&torture_rwlock, flags);\r\ncxt.cur_ops->flags = flags;\r\nreturn 0;\r\n}\r\nstatic void torture_rwlock_write_unlock_irq(void)\r\n__releases(torture_rwlock)\r\n{\r\nwrite_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\r\n}\r\nstatic int torture_rwlock_read_lock_irq(void) __acquires(torture_rwlock)\r\n{\r\nunsigned long flags;\r\nread_lock_irqsave(&torture_rwlock, flags);\r\ncxt.cur_ops->flags = flags;\r\nreturn 0;\r\n}\r\nstatic void torture_rwlock_read_unlock_irq(void)\r\n__releases(torture_rwlock)\r\n{\r\nread_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);\r\n}\r\nstatic int torture_mutex_lock(void) __acquires(torture_mutex)\r\n{\r\nmutex_lock(&torture_mutex);\r\nreturn 0;\r\n}\r\nstatic void torture_mutex_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms * 5);\r\nelse\r\nmdelay(longdelay_ms / 5);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_mutex_unlock(void) __releases(torture_mutex)\r\n{\r\nmutex_unlock(&torture_mutex);\r\n}\r\nstatic int torture_ww_mutex_lock(void)\r\n__acquires(torture_ww_mutex_0)\r\n__acquires(torture_ww_mutex_1)\r\n__acquires(torture_ww_mutex_2)\r\n{\r\nLIST_HEAD(list);\r\nstruct reorder_lock {\r\nstruct list_head link;\r\nstruct ww_mutex *lock;\r\n} locks[3], *ll, *ln;\r\nstruct ww_acquire_ctx ctx;\r\nlocks[0].lock = &torture_ww_mutex_0;\r\nlist_add(&locks[0].link, &list);\r\nlocks[1].lock = &torture_ww_mutex_1;\r\nlist_add(&locks[1].link, &list);\r\nlocks[2].lock = &torture_ww_mutex_2;\r\nlist_add(&locks[2].link, &list);\r\nww_acquire_init(&ctx, &torture_ww_class);\r\nlist_for_each_entry(ll, &list, link) {\r\nint err;\r\nerr = ww_mutex_lock(ll->lock, &ctx);\r\nif (!err)\r\ncontinue;\r\nln = ll;\r\nlist_for_each_entry_continue_reverse(ln, &list, link)\r\nww_mutex_unlock(ln->lock);\r\nif (err != -EDEADLK)\r\nreturn err;\r\nww_mutex_lock_slow(ll->lock, &ctx);\r\nlist_move(&ll->link, &list);\r\n}\r\nww_acquire_fini(&ctx);\r\nreturn 0;\r\n}\r\nstatic void torture_ww_mutex_unlock(void)\r\n__releases(torture_ww_mutex_0)\r\n__releases(torture_ww_mutex_1)\r\n__releases(torture_ww_mutex_2)\r\n{\r\nww_mutex_unlock(&torture_ww_mutex_0);\r\nww_mutex_unlock(&torture_ww_mutex_1);\r\nww_mutex_unlock(&torture_ww_mutex_2);\r\n}\r\nstatic int torture_rtmutex_lock(void) __acquires(torture_rtmutex)\r\n{\r\nrt_mutex_lock(&torture_rtmutex);\r\nreturn 0;\r\n}\r\nstatic void torture_rtmutex_boost(struct torture_random_state *trsp)\r\n{\r\nint policy;\r\nstruct sched_param param;\r\nconst unsigned int factor = 50000;\r\nif (!rt_task(current)) {\r\nif (trsp && !(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * factor))) {\r\npolicy = SCHED_FIFO;\r\nparam.sched_priority = MAX_RT_PRIO - 1;\r\n} else\r\nreturn;\r\n} else {\r\nif (!trsp || !(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * factor * 2))) {\r\npolicy = SCHED_NORMAL;\r\nparam.sched_priority = 0;\r\n} else\r\nreturn;\r\n}\r\nsched_setscheduler_nocheck(current, policy, &param);\r\n}\r\nstatic void torture_rtmutex_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long shortdelay_us = 2;\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms);\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2 * shortdelay_us)))\r\nudelay(shortdelay_us);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_rtmutex_unlock(void) __releases(torture_rtmutex)\r\n{\r\nrt_mutex_unlock(&torture_rtmutex);\r\n}\r\nstatic int torture_rwsem_down_write(void) __acquires(torture_rwsem)\r\n{\r\ndown_write(&torture_rwsem);\r\nreturn 0;\r\n}\r\nstatic void torture_rwsem_write_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms * 10);\r\nelse\r\nmdelay(longdelay_ms / 10);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_rwsem_up_write(void) __releases(torture_rwsem)\r\n{\r\nup_write(&torture_rwsem);\r\n}\r\nstatic int torture_rwsem_down_read(void) __acquires(torture_rwsem)\r\n{\r\ndown_read(&torture_rwsem);\r\nreturn 0;\r\n}\r\nstatic void torture_rwsem_read_delay(struct torture_random_state *trsp)\r\n{\r\nconst unsigned long longdelay_ms = 100;\r\nif (!(torture_random(trsp) %\r\n(cxt.nrealwriters_stress * 2000 * longdelay_ms)))\r\nmdelay(longdelay_ms * 2);\r\nelse\r\nmdelay(longdelay_ms / 2);\r\n#ifdef CONFIG_PREEMPT\r\nif (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))\r\npreempt_schedule();\r\n#endif\r\n}\r\nstatic void torture_rwsem_up_read(void) __releases(torture_rwsem)\r\n{\r\nup_read(&torture_rwsem);\r\n}\r\nvoid torture_percpu_rwsem_init(void)\r\n{\r\nBUG_ON(percpu_init_rwsem(&pcpu_rwsem));\r\n}\r\nstatic int torture_percpu_rwsem_down_write(void) __acquires(pcpu_rwsem)\r\n{\r\npercpu_down_write(&pcpu_rwsem);\r\nreturn 0;\r\n}\r\nstatic void torture_percpu_rwsem_up_write(void) __releases(pcpu_rwsem)\r\n{\r\npercpu_up_write(&pcpu_rwsem);\r\n}\r\nstatic int torture_percpu_rwsem_down_read(void) __acquires(pcpu_rwsem)\r\n{\r\npercpu_down_read(&pcpu_rwsem);\r\nreturn 0;\r\n}\r\nstatic void torture_percpu_rwsem_up_read(void) __releases(pcpu_rwsem)\r\n{\r\npercpu_up_read(&pcpu_rwsem);\r\n}\r\nstatic int lock_torture_writer(void *arg)\r\n{\r\nstruct lock_stress_stats *lwsp = arg;\r\nstatic DEFINE_TORTURE_RANDOM(rand);\r\nVERBOSE_TOROUT_STRING("lock_torture_writer task started");\r\nset_user_nice(current, MAX_NICE);\r\ndo {\r\nif ((torture_random(&rand) & 0xfffff) == 0)\r\nschedule_timeout_uninterruptible(1);\r\ncxt.cur_ops->task_boost(&rand);\r\ncxt.cur_ops->writelock();\r\nif (WARN_ON_ONCE(lock_is_write_held))\r\nlwsp->n_lock_fail++;\r\nlock_is_write_held = 1;\r\nif (WARN_ON_ONCE(lock_is_read_held))\r\nlwsp->n_lock_fail++;\r\nlwsp->n_lock_acquired++;\r\ncxt.cur_ops->write_delay(&rand);\r\nlock_is_write_held = 0;\r\ncxt.cur_ops->writeunlock();\r\nstutter_wait("lock_torture_writer");\r\n} while (!torture_must_stop());\r\ncxt.cur_ops->task_boost(NULL);\r\ntorture_kthread_stopping("lock_torture_writer");\r\nreturn 0;\r\n}\r\nstatic int lock_torture_reader(void *arg)\r\n{\r\nstruct lock_stress_stats *lrsp = arg;\r\nstatic DEFINE_TORTURE_RANDOM(rand);\r\nVERBOSE_TOROUT_STRING("lock_torture_reader task started");\r\nset_user_nice(current, MAX_NICE);\r\ndo {\r\nif ((torture_random(&rand) & 0xfffff) == 0)\r\nschedule_timeout_uninterruptible(1);\r\ncxt.cur_ops->readlock();\r\nlock_is_read_held = 1;\r\nif (WARN_ON_ONCE(lock_is_write_held))\r\nlrsp->n_lock_fail++;\r\nlrsp->n_lock_acquired++;\r\ncxt.cur_ops->read_delay(&rand);\r\nlock_is_read_held = 0;\r\ncxt.cur_ops->readunlock();\r\nstutter_wait("lock_torture_reader");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("lock_torture_reader");\r\nreturn 0;\r\n}\r\nstatic void __torture_print_stats(char *page,\r\nstruct lock_stress_stats *statp, bool write)\r\n{\r\nbool fail = 0;\r\nint i, n_stress;\r\nlong max = 0;\r\nlong min = statp[0].n_lock_acquired;\r\nlong long sum = 0;\r\nn_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;\r\nfor (i = 0; i < n_stress; i++) {\r\nif (statp[i].n_lock_fail)\r\nfail = true;\r\nsum += statp[i].n_lock_acquired;\r\nif (max < statp[i].n_lock_fail)\r\nmax = statp[i].n_lock_fail;\r\nif (min > statp[i].n_lock_fail)\r\nmin = statp[i].n_lock_fail;\r\n}\r\npage += sprintf(page,\r\n"%s: Total: %lld Max/Min: %ld/%ld %s Fail: %d %s\n",\r\nwrite ? "Writes" : "Reads ",\r\nsum, max, min, max / 2 > min ? "???" : "",\r\nfail, fail ? "!!!" : "");\r\nif (fail)\r\natomic_inc(&cxt.n_lock_torture_errors);\r\n}\r\nstatic void lock_torture_stats_print(void)\r\n{\r\nint size = cxt.nrealwriters_stress * 200 + 8192;\r\nchar *buf;\r\nif (cxt.cur_ops->readlock)\r\nsize += cxt.nrealreaders_stress * 200 + 8192;\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\npr_err("lock_torture_stats_print: Out of memory, need: %d",\r\nsize);\r\nreturn;\r\n}\r\n__torture_print_stats(buf, cxt.lwsa, true);\r\npr_alert("%s", buf);\r\nkfree(buf);\r\nif (cxt.cur_ops->readlock) {\r\nbuf = kmalloc(size, GFP_KERNEL);\r\nif (!buf) {\r\npr_err("lock_torture_stats_print: Out of memory, need: %d",\r\nsize);\r\nreturn;\r\n}\r\n__torture_print_stats(buf, cxt.lrsa, false);\r\npr_alert("%s", buf);\r\nkfree(buf);\r\n}\r\n}\r\nstatic int lock_torture_stats(void *arg)\r\n{\r\nVERBOSE_TOROUT_STRING("lock_torture_stats task started");\r\ndo {\r\nschedule_timeout_interruptible(stat_interval * HZ);\r\nlock_torture_stats_print();\r\ntorture_shutdown_absorb("lock_torture_stats");\r\n} while (!torture_must_stop());\r\ntorture_kthread_stopping("lock_torture_stats");\r\nreturn 0;\r\n}\r\nstatic inline void\r\nlock_torture_print_module_parms(struct lock_torture_ops *cur_ops,\r\nconst char *tag)\r\n{\r\npr_alert("%s" TORTURE_FLAG\r\n"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\n",\r\ntorture_type, tag, cxt.debug_lock ? " [debug]": "",\r\ncxt.nrealwriters_stress, cxt.nrealreaders_stress, stat_interval,\r\nverbose, shuffle_interval, stutter, shutdown_secs,\r\nonoff_interval, onoff_holdoff);\r\n}\r\nstatic void lock_torture_cleanup(void)\r\n{\r\nint i;\r\nif (torture_cleanup_begin())\r\nreturn;\r\nif (!cxt.lwsa)\r\ngoto end;\r\nif (writer_tasks) {\r\nfor (i = 0; i < cxt.nrealwriters_stress; i++)\r\ntorture_stop_kthread(lock_torture_writer,\r\nwriter_tasks[i]);\r\nkfree(writer_tasks);\r\nwriter_tasks = NULL;\r\n}\r\nif (reader_tasks) {\r\nfor (i = 0; i < cxt.nrealreaders_stress; i++)\r\ntorture_stop_kthread(lock_torture_reader,\r\nreader_tasks[i]);\r\nkfree(reader_tasks);\r\nreader_tasks = NULL;\r\n}\r\ntorture_stop_kthread(lock_torture_stats, stats_task);\r\nlock_torture_stats_print();\r\nif (atomic_read(&cxt.n_lock_torture_errors))\r\nlock_torture_print_module_parms(cxt.cur_ops,\r\n"End of test: FAILURE");\r\nelse if (torture_onoff_failures())\r\nlock_torture_print_module_parms(cxt.cur_ops,\r\n"End of test: LOCK_HOTPLUG");\r\nelse\r\nlock_torture_print_module_parms(cxt.cur_ops,\r\n"End of test: SUCCESS");\r\nkfree(cxt.lwsa);\r\nkfree(cxt.lrsa);\r\nend:\r\ntorture_cleanup_end();\r\n}\r\nstatic int __init lock_torture_init(void)\r\n{\r\nint i, j;\r\nint firsterr = 0;\r\nstatic struct lock_torture_ops *torture_ops[] = {\r\n&lock_busted_ops,\r\n&spin_lock_ops, &spin_lock_irq_ops,\r\n&rw_lock_ops, &rw_lock_irq_ops,\r\n&mutex_lock_ops,\r\n&ww_mutex_lock_ops,\r\n#ifdef CONFIG_RT_MUTEXES\r\n&rtmutex_lock_ops,\r\n#endif\r\n&rwsem_lock_ops,\r\n&percpu_rwsem_lock_ops,\r\n};\r\nif (!torture_init_begin(torture_type, verbose, &torture_runnable))\r\nreturn -EBUSY;\r\nfor (i = 0; i < ARRAY_SIZE(torture_ops); i++) {\r\ncxt.cur_ops = torture_ops[i];\r\nif (strcmp(torture_type, cxt.cur_ops->name) == 0)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(torture_ops)) {\r\npr_alert("lock-torture: invalid torture type: \"%s\"\n",\r\ntorture_type);\r\npr_alert("lock-torture types:");\r\nfor (i = 0; i < ARRAY_SIZE(torture_ops); i++)\r\npr_alert(" %s", torture_ops[i]->name);\r\npr_alert("\n");\r\nfirsterr = -EINVAL;\r\ngoto unwind;\r\n}\r\nif (cxt.cur_ops->init)\r\ncxt.cur_ops->init();\r\nif (nwriters_stress >= 0)\r\ncxt.nrealwriters_stress = nwriters_stress;\r\nelse\r\ncxt.nrealwriters_stress = 2 * num_online_cpus();\r\n#ifdef CONFIG_DEBUG_MUTEXES\r\nif (strncmp(torture_type, "mutex", 5) == 0)\r\ncxt.debug_lock = true;\r\n#endif\r\n#ifdef CONFIG_DEBUG_RT_MUTEXES\r\nif (strncmp(torture_type, "rtmutex", 7) == 0)\r\ncxt.debug_lock = true;\r\n#endif\r\n#ifdef CONFIG_DEBUG_SPINLOCK\r\nif ((strncmp(torture_type, "spin", 4) == 0) ||\r\n(strncmp(torture_type, "rw_lock", 7) == 0))\r\ncxt.debug_lock = true;\r\n#endif\r\nlock_is_write_held = 0;\r\ncxt.lwsa = kmalloc(sizeof(*cxt.lwsa) * cxt.nrealwriters_stress, GFP_KERNEL);\r\nif (cxt.lwsa == NULL) {\r\nVERBOSE_TOROUT_STRING("cxt.lwsa: Out of memory");\r\nfirsterr = -ENOMEM;\r\ngoto unwind;\r\n}\r\nfor (i = 0; i < cxt.nrealwriters_stress; i++) {\r\ncxt.lwsa[i].n_lock_fail = 0;\r\ncxt.lwsa[i].n_lock_acquired = 0;\r\n}\r\nif (cxt.cur_ops->readlock) {\r\nif (nreaders_stress >= 0)\r\ncxt.nrealreaders_stress = nreaders_stress;\r\nelse {\r\nif (nwriters_stress < 0)\r\ncxt.nrealwriters_stress = num_online_cpus();\r\ncxt.nrealreaders_stress = cxt.nrealwriters_stress;\r\n}\r\nlock_is_read_held = 0;\r\ncxt.lrsa = kmalloc(sizeof(*cxt.lrsa) * cxt.nrealreaders_stress, GFP_KERNEL);\r\nif (cxt.lrsa == NULL) {\r\nVERBOSE_TOROUT_STRING("cxt.lrsa: Out of memory");\r\nfirsterr = -ENOMEM;\r\nkfree(cxt.lwsa);\r\ncxt.lwsa = NULL;\r\ngoto unwind;\r\n}\r\nfor (i = 0; i < cxt.nrealreaders_stress; i++) {\r\ncxt.lrsa[i].n_lock_fail = 0;\r\ncxt.lrsa[i].n_lock_acquired = 0;\r\n}\r\n}\r\nlock_torture_print_module_parms(cxt.cur_ops, "Start of test");\r\nif (onoff_interval > 0) {\r\nfirsterr = torture_onoff_init(onoff_holdoff * HZ,\r\nonoff_interval * HZ);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (shuffle_interval > 0) {\r\nfirsterr = torture_shuffle_init(shuffle_interval);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (shutdown_secs > 0) {\r\nfirsterr = torture_shutdown_init(shutdown_secs,\r\nlock_torture_cleanup);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (stutter > 0) {\r\nfirsterr = torture_stutter_init(stutter);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nwriter_tasks = kzalloc(cxt.nrealwriters_stress * sizeof(writer_tasks[0]),\r\nGFP_KERNEL);\r\nif (writer_tasks == NULL) {\r\nVERBOSE_TOROUT_ERRSTRING("writer_tasks: Out of memory");\r\nfirsterr = -ENOMEM;\r\ngoto unwind;\r\n}\r\nif (cxt.cur_ops->readlock) {\r\nreader_tasks = kzalloc(cxt.nrealreaders_stress * sizeof(reader_tasks[0]),\r\nGFP_KERNEL);\r\nif (reader_tasks == NULL) {\r\nVERBOSE_TOROUT_ERRSTRING("reader_tasks: Out of memory");\r\nkfree(writer_tasks);\r\nwriter_tasks = NULL;\r\nfirsterr = -ENOMEM;\r\ngoto unwind;\r\n}\r\n}\r\nfor (i = 0, j = 0; i < cxt.nrealwriters_stress ||\r\nj < cxt.nrealreaders_stress; i++, j++) {\r\nif (i >= cxt.nrealwriters_stress)\r\ngoto create_reader;\r\nfirsterr = torture_create_kthread(lock_torture_writer, &cxt.lwsa[i],\r\nwriter_tasks[i]);\r\nif (firsterr)\r\ngoto unwind;\r\ncreate_reader:\r\nif (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))\r\ncontinue;\r\nfirsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],\r\nreader_tasks[j]);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\nif (stat_interval > 0) {\r\nfirsterr = torture_create_kthread(lock_torture_stats, NULL,\r\nstats_task);\r\nif (firsterr)\r\ngoto unwind;\r\n}\r\ntorture_init_end();\r\nreturn 0;\r\nunwind:\r\ntorture_init_end();\r\nlock_torture_cleanup();\r\nreturn firsterr;\r\n}
