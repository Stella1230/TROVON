static bool mdt_phdr_valid(const struct elf32_phdr *phdr)\r\n{\r\nif (phdr->p_type != PT_LOAD)\r\nreturn false;\r\nif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\r\nreturn false;\r\nif (!phdr->p_memsz)\r\nreturn false;\r\nreturn true;\r\n}\r\nssize_t qcom_mdt_get_size(const struct firmware *fw)\r\n{\r\nconst struct elf32_phdr *phdrs;\r\nconst struct elf32_phdr *phdr;\r\nconst struct elf32_hdr *ehdr;\r\nphys_addr_t min_addr = (phys_addr_t)ULLONG_MAX;\r\nphys_addr_t max_addr = 0;\r\nint i;\r\nehdr = (struct elf32_hdr *)fw->data;\r\nphdrs = (struct elf32_phdr *)(ehdr + 1);\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (!mdt_phdr_valid(phdr))\r\ncontinue;\r\nif (phdr->p_paddr < min_addr)\r\nmin_addr = phdr->p_paddr;\r\nif (phdr->p_paddr + phdr->p_memsz > max_addr)\r\nmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\r\n}\r\nreturn min_addr < max_addr ? max_addr - min_addr : -EINVAL;\r\n}\r\nint qcom_mdt_load(struct device *dev, const struct firmware *fw,\r\nconst char *firmware, int pas_id, void *mem_region,\r\nphys_addr_t mem_phys, size_t mem_size)\r\n{\r\nconst struct elf32_phdr *phdrs;\r\nconst struct elf32_phdr *phdr;\r\nconst struct elf32_hdr *ehdr;\r\nconst struct firmware *seg_fw;\r\nphys_addr_t mem_reloc;\r\nphys_addr_t min_addr = (phys_addr_t)ULLONG_MAX;\r\nphys_addr_t max_addr = 0;\r\nsize_t fw_name_len;\r\nssize_t offset;\r\nchar *fw_name;\r\nbool relocate = false;\r\nvoid *ptr;\r\nint ret;\r\nint i;\r\nif (!fw || !mem_region || !mem_phys || !mem_size)\r\nreturn -EINVAL;\r\nehdr = (struct elf32_hdr *)fw->data;\r\nphdrs = (struct elf32_phdr *)(ehdr + 1);\r\nfw_name_len = strlen(firmware);\r\nif (fw_name_len <= 4)\r\nreturn -EINVAL;\r\nfw_name = kstrdup(firmware, GFP_KERNEL);\r\nif (!fw_name)\r\nreturn -ENOMEM;\r\nret = qcom_scm_pas_init_image(pas_id, fw->data, fw->size);\r\nif (ret) {\r\ndev_err(dev, "invalid firmware metadata\n");\r\ngoto out;\r\n}\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (!mdt_phdr_valid(phdr))\r\ncontinue;\r\nif (phdr->p_flags & QCOM_MDT_RELOCATABLE)\r\nrelocate = true;\r\nif (phdr->p_paddr < min_addr)\r\nmin_addr = phdr->p_paddr;\r\nif (phdr->p_paddr + phdr->p_memsz > max_addr)\r\nmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\r\n}\r\nif (relocate) {\r\nret = qcom_scm_pas_mem_setup(pas_id, mem_phys, max_addr - min_addr);\r\nif (ret) {\r\ndev_err(dev, "unable to setup relocation\n");\r\ngoto out;\r\n}\r\nmem_reloc = min_addr;\r\n} else {\r\nmem_reloc = mem_phys;\r\n}\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (!mdt_phdr_valid(phdr))\r\ncontinue;\r\noffset = phdr->p_paddr - mem_reloc;\r\nif (offset < 0 || offset + phdr->p_memsz > mem_size) {\r\ndev_err(dev, "segment outside memory range\n");\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nptr = mem_region + offset;\r\nif (phdr->p_filesz) {\r\nsprintf(fw_name + fw_name_len - 3, "b%02d", i);\r\nret = request_firmware(&seg_fw, fw_name, dev);\r\nif (ret) {\r\ndev_err(dev, "failed to load %s\n", fw_name);\r\nbreak;\r\n}\r\nmemcpy(ptr, seg_fw->data, seg_fw->size);\r\nrelease_firmware(seg_fw);\r\n}\r\nif (phdr->p_memsz > phdr->p_filesz)\r\nmemset(ptr + phdr->p_filesz, 0, phdr->p_memsz - phdr->p_filesz);\r\n}\r\nout:\r\nkfree(fw_name);\r\nreturn ret;\r\n}
