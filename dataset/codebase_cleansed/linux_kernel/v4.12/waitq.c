void autofs4_catatonic_mode(struct autofs_sb_info *sbi)\r\n{\r\nstruct autofs_wait_queue *wq, *nwq;\r\nmutex_lock(&sbi->wq_mutex);\r\nif (sbi->catatonic) {\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn;\r\n}\r\npr_debug("entering catatonic mode\n");\r\nsbi->catatonic = 1;\r\nwq = sbi->queues;\r\nsbi->queues = NULL;\r\nwhile (wq) {\r\nnwq = wq->next;\r\nwq->status = -ENOENT;\r\nkfree(wq->name.name);\r\nwq->name.name = NULL;\r\nwq->wait_ctr--;\r\nwake_up_interruptible(&wq->queue);\r\nwq = nwq;\r\n}\r\nfput(sbi->pipe);\r\nsbi->pipe = NULL;\r\nsbi->pipefd = -1;\r\nmutex_unlock(&sbi->wq_mutex);\r\n}\r\nstatic int autofs4_write(struct autofs_sb_info *sbi,\r\nstruct file *file, const void *addr, int bytes)\r\n{\r\nunsigned long sigpipe, flags;\r\nmm_segment_t fs;\r\nconst char *data = (const char *)addr;\r\nssize_t wr = 0;\r\nsigpipe = sigismember(&current->pending.signal, SIGPIPE);\r\nfs = get_fs();\r\nset_fs(KERNEL_DS);\r\nmutex_lock(&sbi->pipe_mutex);\r\nwhile (bytes) {\r\nwr = __vfs_write(file, data, bytes, &file->f_pos);\r\nif (wr <= 0)\r\nbreak;\r\ndata += wr;\r\nbytes -= wr;\r\n}\r\nmutex_unlock(&sbi->pipe_mutex);\r\nset_fs(fs);\r\nif (wr == -EPIPE && !sigpipe) {\r\nspin_lock_irqsave(&current->sighand->siglock, flags);\r\nsigdelset(&current->pending.signal, SIGPIPE);\r\nrecalc_sigpending();\r\nspin_unlock_irqrestore(&current->sighand->siglock, flags);\r\n}\r\nreturn (bytes > 0);\r\n}\r\nstatic void autofs4_notify_daemon(struct autofs_sb_info *sbi,\r\nstruct autofs_wait_queue *wq,\r\nint type)\r\n{\r\nunion {\r\nstruct autofs_packet_hdr hdr;\r\nunion autofs_packet_union v4_pkt;\r\nunion autofs_v5_packet_union v5_pkt;\r\n} pkt;\r\nstruct file *pipe = NULL;\r\nsize_t pktsz;\r\npr_debug("wait id = 0x%08lx, name = %.*s, type=%d\n",\r\n(unsigned long) wq->wait_queue_token,\r\nwq->name.len, wq->name.name, type);\r\nmemset(&pkt, 0, sizeof(pkt));\r\npkt.hdr.proto_version = sbi->version;\r\npkt.hdr.type = type;\r\nswitch (type) {\r\ncase autofs_ptype_missing:\r\n{\r\nstruct autofs_packet_missing *mp = &pkt.v4_pkt.missing;\r\npktsz = sizeof(*mp);\r\nmp->wait_queue_token = wq->wait_queue_token;\r\nmp->len = wq->name.len;\r\nmemcpy(mp->name, wq->name.name, wq->name.len);\r\nmp->name[wq->name.len] = '\0';\r\nbreak;\r\n}\r\ncase autofs_ptype_expire_multi:\r\n{\r\nstruct autofs_packet_expire_multi *ep =\r\n&pkt.v4_pkt.expire_multi;\r\npktsz = sizeof(*ep);\r\nep->wait_queue_token = wq->wait_queue_token;\r\nep->len = wq->name.len;\r\nmemcpy(ep->name, wq->name.name, wq->name.len);\r\nep->name[wq->name.len] = '\0';\r\nbreak;\r\n}\r\ncase autofs_ptype_missing_indirect:\r\ncase autofs_ptype_expire_indirect:\r\ncase autofs_ptype_missing_direct:\r\ncase autofs_ptype_expire_direct:\r\n{\r\nstruct autofs_v5_packet *packet = &pkt.v5_pkt.v5_packet;\r\nstruct user_namespace *user_ns = sbi->pipe->f_cred->user_ns;\r\npktsz = sizeof(*packet);\r\npacket->wait_queue_token = wq->wait_queue_token;\r\npacket->len = wq->name.len;\r\nmemcpy(packet->name, wq->name.name, wq->name.len);\r\npacket->name[wq->name.len] = '\0';\r\npacket->dev = wq->dev;\r\npacket->ino = wq->ino;\r\npacket->uid = from_kuid_munged(user_ns, wq->uid);\r\npacket->gid = from_kgid_munged(user_ns, wq->gid);\r\npacket->pid = wq->pid;\r\npacket->tgid = wq->tgid;\r\nbreak;\r\n}\r\ndefault:\r\npr_warn("bad type %d!\n", type);\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn;\r\n}\r\npipe = get_file(sbi->pipe);\r\nmutex_unlock(&sbi->wq_mutex);\r\nif (autofs4_write(sbi, pipe, &pkt, pktsz))\r\nautofs4_catatonic_mode(sbi);\r\nfput(pipe);\r\n}\r\nstatic int autofs4_getpath(struct autofs_sb_info *sbi,\r\nstruct dentry *dentry, char **name)\r\n{\r\nstruct dentry *root = sbi->sb->s_root;\r\nstruct dentry *tmp;\r\nchar *buf;\r\nchar *p;\r\nint len;\r\nunsigned seq;\r\nrename_retry:\r\nbuf = *name;\r\nlen = 0;\r\nseq = read_seqbegin(&rename_lock);\r\nrcu_read_lock();\r\nspin_lock(&sbi->fs_lock);\r\nfor (tmp = dentry ; tmp != root ; tmp = tmp->d_parent)\r\nlen += tmp->d_name.len + 1;\r\nif (!len || --len > NAME_MAX) {\r\nspin_unlock(&sbi->fs_lock);\r\nrcu_read_unlock();\r\nif (read_seqretry(&rename_lock, seq))\r\ngoto rename_retry;\r\nreturn 0;\r\n}\r\n*(buf + len) = '\0';\r\np = buf + len - dentry->d_name.len;\r\nstrncpy(p, dentry->d_name.name, dentry->d_name.len);\r\nfor (tmp = dentry->d_parent; tmp != root ; tmp = tmp->d_parent) {\r\n*(--p) = '/';\r\np -= tmp->d_name.len;\r\nstrncpy(p, tmp->d_name.name, tmp->d_name.len);\r\n}\r\nspin_unlock(&sbi->fs_lock);\r\nrcu_read_unlock();\r\nif (read_seqretry(&rename_lock, seq))\r\ngoto rename_retry;\r\nreturn len;\r\n}\r\nstatic struct autofs_wait_queue *\r\nautofs4_find_wait(struct autofs_sb_info *sbi, const struct qstr *qstr)\r\n{\r\nstruct autofs_wait_queue *wq;\r\nfor (wq = sbi->queues; wq; wq = wq->next) {\r\nif (wq->name.hash == qstr->hash &&\r\nwq->name.len == qstr->len &&\r\nwq->name.name &&\r\n!memcmp(wq->name.name, qstr->name, qstr->len))\r\nbreak;\r\n}\r\nreturn wq;\r\n}\r\nstatic int validate_request(struct autofs_wait_queue **wait,\r\nstruct autofs_sb_info *sbi,\r\nconst struct qstr *qstr,\r\nconst struct path *path, enum autofs_notify notify)\r\n{\r\nstruct dentry *dentry = path->dentry;\r\nstruct autofs_wait_queue *wq;\r\nstruct autofs_info *ino;\r\nif (sbi->catatonic)\r\nreturn -ENOENT;\r\nwq = autofs4_find_wait(sbi, qstr);\r\nif (wq) {\r\n*wait = wq;\r\nreturn 1;\r\n}\r\n*wait = NULL;\r\nino = autofs4_dentry_ino(dentry);\r\nif (!ino)\r\nreturn 1;\r\nif (notify == NFY_NONE) {\r\nwhile (ino->flags & AUTOFS_INF_EXPIRING) {\r\nmutex_unlock(&sbi->wq_mutex);\r\nschedule_timeout_interruptible(HZ/10);\r\nif (mutex_lock_interruptible(&sbi->wq_mutex))\r\nreturn -EINTR;\r\nif (sbi->catatonic)\r\nreturn -ENOENT;\r\nwq = autofs4_find_wait(sbi, qstr);\r\nif (wq) {\r\n*wait = wq;\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nif (notify == NFY_MOUNT) {\r\nstruct dentry *new = NULL;\r\nstruct path this;\r\nint valid = 1;\r\nif (!IS_ROOT(dentry)) {\r\nif (d_unhashed(dentry) &&\r\nd_really_is_positive(dentry)) {\r\nstruct dentry *parent = dentry->d_parent;\r\nnew = d_lookup(parent, &dentry->d_name);\r\nif (new)\r\ndentry = new;\r\n}\r\n}\r\nthis.mnt = path->mnt;\r\nthis.dentry = dentry;\r\nif (path_has_submounts(&this))\r\nvalid = 0;\r\nif (new)\r\ndput(new);\r\nreturn valid;\r\n}\r\nreturn 1;\r\n}\r\nint autofs4_wait(struct autofs_sb_info *sbi,\r\nconst struct path *path, enum autofs_notify notify)\r\n{\r\nstruct dentry *dentry = path->dentry;\r\nstruct autofs_wait_queue *wq;\r\nstruct qstr qstr;\r\nchar *name;\r\nint status, ret, type;\r\npid_t pid;\r\npid_t tgid;\r\nif (sbi->catatonic)\r\nreturn -ENOENT;\r\npid = task_pid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\r\ntgid = task_tgid_nr_ns(current, ns_of_pid(sbi->oz_pgrp));\r\nif (pid == 0 || tgid == 0)\r\nreturn -ENOENT;\r\nif (d_really_is_negative(dentry)) {\r\nif (autofs_type_trigger(sbi->type))\r\nreturn -ENOENT;\r\nelse if (!IS_ROOT(dentry->d_parent))\r\nreturn -ENOENT;\r\n}\r\nname = kmalloc(NAME_MAX + 1, GFP_KERNEL);\r\nif (!name)\r\nreturn -ENOMEM;\r\nif (IS_ROOT(dentry) && autofs_type_trigger(sbi->type))\r\nqstr.len = sprintf(name, "%p", dentry);\r\nelse {\r\nqstr.len = autofs4_getpath(sbi, dentry, &name);\r\nif (!qstr.len) {\r\nkfree(name);\r\nreturn -ENOENT;\r\n}\r\n}\r\nqstr.name = name;\r\nqstr.hash = full_name_hash(dentry, name, qstr.len);\r\nif (mutex_lock_interruptible(&sbi->wq_mutex)) {\r\nkfree(qstr.name);\r\nreturn -EINTR;\r\n}\r\nret = validate_request(&wq, sbi, &qstr, path, notify);\r\nif (ret <= 0) {\r\nif (ret != -EINTR)\r\nmutex_unlock(&sbi->wq_mutex);\r\nkfree(qstr.name);\r\nreturn ret;\r\n}\r\nif (!wq) {\r\nwq = kmalloc(sizeof(struct autofs_wait_queue), GFP_KERNEL);\r\nif (!wq) {\r\nkfree(qstr.name);\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn -ENOMEM;\r\n}\r\nwq->wait_queue_token = autofs4_next_wait_queue;\r\nif (++autofs4_next_wait_queue == 0)\r\nautofs4_next_wait_queue = 1;\r\nwq->next = sbi->queues;\r\nsbi->queues = wq;\r\ninit_waitqueue_head(&wq->queue);\r\nmemcpy(&wq->name, &qstr, sizeof(struct qstr));\r\nwq->dev = autofs4_get_dev(sbi);\r\nwq->ino = autofs4_get_ino(sbi);\r\nwq->uid = current_cred()->uid;\r\nwq->gid = current_cred()->gid;\r\nwq->pid = pid;\r\nwq->tgid = tgid;\r\nwq->status = -EINTR;\r\nwq->wait_ctr = 2;\r\nif (sbi->version < 5) {\r\nif (notify == NFY_MOUNT)\r\ntype = autofs_ptype_missing;\r\nelse\r\ntype = autofs_ptype_expire_multi;\r\n} else {\r\nif (notify == NFY_MOUNT)\r\ntype = autofs_type_trigger(sbi->type) ?\r\nautofs_ptype_missing_direct :\r\nautofs_ptype_missing_indirect;\r\nelse\r\ntype = autofs_type_trigger(sbi->type) ?\r\nautofs_ptype_expire_direct :\r\nautofs_ptype_expire_indirect;\r\n}\r\npr_debug("new wait id = 0x%08lx, name = %.*s, nfy=%d\n",\r\n(unsigned long) wq->wait_queue_token, wq->name.len,\r\nwq->name.name, notify);\r\nautofs4_notify_daemon(sbi, wq, type);\r\n} else {\r\nwq->wait_ctr++;\r\npr_debug("existing wait id = 0x%08lx, name = %.*s, nfy=%d\n",\r\n(unsigned long) wq->wait_queue_token, wq->name.len,\r\nwq->name.name, notify);\r\nmutex_unlock(&sbi->wq_mutex);\r\nkfree(qstr.name);\r\n}\r\nif (wq->name.name) {\r\nunsigned long shutdown_sigs_mask;\r\nunsigned long irqflags;\r\nsigset_t oldset;\r\nspin_lock_irqsave(&current->sighand->siglock, irqflags);\r\noldset = current->blocked;\r\nshutdown_sigs_mask = SHUTDOWN_SIGS & ~oldset.sig[0];\r\nsiginitsetinv(&current->blocked, shutdown_sigs_mask);\r\nrecalc_sigpending();\r\nspin_unlock_irqrestore(&current->sighand->siglock, irqflags);\r\nwait_event_interruptible(wq->queue, wq->name.name == NULL);\r\nspin_lock_irqsave(&current->sighand->siglock, irqflags);\r\ncurrent->blocked = oldset;\r\nrecalc_sigpending();\r\nspin_unlock_irqrestore(&current->sighand->siglock, irqflags);\r\n} else {\r\npr_debug("skipped sleeping\n");\r\n}\r\nstatus = wq->status;\r\nif (!status) {\r\nstruct autofs_info *ino;\r\nstruct dentry *de = NULL;\r\nino = autofs4_dentry_ino(dentry);\r\nif (!ino) {\r\nde = d_lookup(dentry->d_parent, &dentry->d_name);\r\nif (de)\r\nino = autofs4_dentry_ino(de);\r\n}\r\nif (ino) {\r\nspin_lock(&sbi->fs_lock);\r\nino->uid = wq->uid;\r\nino->gid = wq->gid;\r\nspin_unlock(&sbi->fs_lock);\r\n}\r\nif (de)\r\ndput(de);\r\n}\r\nmutex_lock(&sbi->wq_mutex);\r\nif (!--wq->wait_ctr)\r\nkfree(wq);\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn status;\r\n}\r\nint autofs4_wait_release(struct autofs_sb_info *sbi, autofs_wqt_t wait_queue_token, int status)\r\n{\r\nstruct autofs_wait_queue *wq, **wql;\r\nmutex_lock(&sbi->wq_mutex);\r\nfor (wql = &sbi->queues; (wq = *wql) != NULL; wql = &wq->next) {\r\nif (wq->wait_queue_token == wait_queue_token)\r\nbreak;\r\n}\r\nif (!wq) {\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn -EINVAL;\r\n}\r\n*wql = wq->next;\r\nkfree(wq->name.name);\r\nwq->name.name = NULL;\r\nwq->status = status;\r\nwake_up_interruptible(&wq->queue);\r\nif (!--wq->wait_ctr)\r\nkfree(wq);\r\nmutex_unlock(&sbi->wq_mutex);\r\nreturn 0;\r\n}
