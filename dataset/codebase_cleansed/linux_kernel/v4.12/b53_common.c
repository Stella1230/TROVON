static int b53_do_vlan_op(struct b53_device *dev, u8 op)\r\n{\r\nunsigned int i;\r\nb53_write8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], VTA_START_CMD | op);\r\nfor (i = 0; i < 10; i++) {\r\nu8 vta;\r\nb53_read8(dev, B53_ARLIO_PAGE, dev->vta_regs[0], &vta);\r\nif (!(vta & VTA_START_CMD))\r\nreturn 0;\r\nusleep_range(100, 200);\r\n}\r\nreturn -EIO;\r\n}\r\nstatic void b53_set_vlan_entry(struct b53_device *dev, u16 vid,\r\nstruct b53_vlan *vlan)\r\n{\r\nif (is5325(dev)) {\r\nu32 entry = 0;\r\nif (vlan->members) {\r\nentry = ((vlan->untag & VA_UNTAG_MASK_25) <<\r\nVA_UNTAG_S_25) | vlan->members;\r\nif (dev->core_rev >= 3)\r\nentry |= VA_VALID_25_R4 | vid << VA_VID_HIGH_S;\r\nelse\r\nentry |= VA_VALID_25;\r\n}\r\nb53_write32(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_25, entry);\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, vid |\r\nVTA_RW_STATE_WR | VTA_RW_OP_EN);\r\n} else if (is5365(dev)) {\r\nu16 entry = 0;\r\nif (vlan->members)\r\nentry = ((vlan->untag & VA_UNTAG_MASK_65) <<\r\nVA_UNTAG_S_65) | vlan->members | VA_VALID_65;\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_65, entry);\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_65, vid |\r\nVTA_RW_STATE_WR | VTA_RW_OP_EN);\r\n} else {\r\nb53_write16(dev, B53_ARLIO_PAGE, dev->vta_regs[1], vid);\r\nb53_write32(dev, B53_ARLIO_PAGE, dev->vta_regs[2],\r\n(vlan->untag << VTE_UNTAG_S) | vlan->members);\r\nb53_do_vlan_op(dev, VTA_CMD_WRITE);\r\n}\r\ndev_dbg(dev->ds->dev, "VID: %d, members: 0x%04x, untag: 0x%04x\n",\r\nvid, vlan->members, vlan->untag);\r\n}\r\nstatic void b53_get_vlan_entry(struct b53_device *dev, u16 vid,\r\nstruct b53_vlan *vlan)\r\n{\r\nif (is5325(dev)) {\r\nu32 entry = 0;\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, vid |\r\nVTA_RW_STATE_RD | VTA_RW_OP_EN);\r\nb53_read32(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_25, &entry);\r\nif (dev->core_rev >= 3)\r\nvlan->valid = !!(entry & VA_VALID_25_R4);\r\nelse\r\nvlan->valid = !!(entry & VA_VALID_25);\r\nvlan->members = entry & VA_MEMBER_MASK;\r\nvlan->untag = (entry >> VA_UNTAG_S_25) & VA_UNTAG_MASK_25;\r\n} else if (is5365(dev)) {\r\nu16 entry = 0;\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_65, vid |\r\nVTA_RW_STATE_WR | VTA_RW_OP_EN);\r\nb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_WRITE_65, &entry);\r\nvlan->valid = !!(entry & VA_VALID_65);\r\nvlan->members = entry & VA_MEMBER_MASK;\r\nvlan->untag = (entry >> VA_UNTAG_S_65) & VA_UNTAG_MASK_65;\r\n} else {\r\nu32 entry = 0;\r\nb53_write16(dev, B53_ARLIO_PAGE, dev->vta_regs[1], vid);\r\nb53_do_vlan_op(dev, VTA_CMD_READ);\r\nb53_read32(dev, B53_ARLIO_PAGE, dev->vta_regs[2], &entry);\r\nvlan->members = entry & VTE_MEMBERS;\r\nvlan->untag = (entry >> VTE_UNTAG_S) & VTE_MEMBERS;\r\nvlan->valid = true;\r\n}\r\n}\r\nstatic void b53_set_forwarding(struct b53_device *dev, int enable)\r\n{\r\nstruct dsa_switch *ds = dev->ds;\r\nu8 mgmt;\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\r\nif (enable)\r\nmgmt |= SM_SW_FWD_EN;\r\nelse\r\nmgmt &= ~SM_SW_FWD_EN;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);\r\nif (ds->ops->get_tag_protocol(ds) == DSA_TAG_PROTO_NONE) {\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_CTRL, &mgmt);\r\nmgmt |= B53_MII_DUMB_FWDG_EN;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_CTRL, mgmt);\r\n}\r\n}\r\nstatic void b53_enable_vlan(struct b53_device *dev, bool enable)\r\n{\r\nu8 mgmt, vc0, vc1, vc4 = 0, vc5;\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL0, &vc0);\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL1, &vc1);\r\nif (is5325(dev) || is5365(dev)) {\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_25, &vc4);\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_25, &vc5);\r\n} else if (is63xx(dev)) {\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_63XX, &vc4);\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_63XX, &vc5);\r\n} else {\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4, &vc4);\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5, &vc5);\r\n}\r\nmgmt &= ~SM_SW_FWD_MODE;\r\nif (enable) {\r\nvc0 |= VC0_VLAN_EN | VC0_VID_CHK_EN | VC0_VID_HASH_VID;\r\nvc1 |= VC1_RX_MCST_UNTAG_EN | VC1_RX_MCST_FWD_EN;\r\nvc4 &= ~VC4_ING_VID_CHECK_MASK;\r\nvc4 |= VC4_ING_VID_VIO_DROP << VC4_ING_VID_CHECK_S;\r\nvc5 |= VC5_DROP_VTABLE_MISS;\r\nif (is5325(dev))\r\nvc0 &= ~VC0_RESERVED_1;\r\nif (is5325(dev) || is5365(dev))\r\nvc1 |= VC1_RX_MCST_TAG_EN;\r\n} else {\r\nvc0 &= ~(VC0_VLAN_EN | VC0_VID_CHK_EN | VC0_VID_HASH_VID);\r\nvc1 &= ~(VC1_RX_MCST_UNTAG_EN | VC1_RX_MCST_FWD_EN);\r\nvc4 &= ~VC4_ING_VID_CHECK_MASK;\r\nvc5 &= ~VC5_DROP_VTABLE_MISS;\r\nif (is5325(dev) || is5365(dev))\r\nvc4 |= VC4_ING_VID_VIO_FWD << VC4_ING_VID_CHECK_S;\r\nelse\r\nvc4 |= VC4_ING_VID_VIO_TO_IMP << VC4_ING_VID_CHECK_S;\r\nif (is5325(dev) || is5365(dev))\r\nvc1 &= ~VC1_RX_MCST_TAG_EN;\r\n}\r\nif (!is5325(dev) && !is5365(dev))\r\nvc5 &= ~VC5_VID_FFF_EN;\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL0, vc0);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL1, vc1);\r\nif (is5325(dev) || is5365(dev)) {\r\nif (is5325(dev) && enable)\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3,\r\nVC3_HIGH_8BIT_EN);\r\nelse\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3, 0);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_25, vc4);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_25, vc5);\r\n} else if (is63xx(dev)) {\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3_63XX, 0);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_63XX, vc4);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5_63XX, vc5);\r\n} else {\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_CTRL3, 0);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4, vc4);\r\nb53_write8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL5, vc5);\r\n}\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);\r\n}\r\nstatic int b53_set_jumbo(struct b53_device *dev, bool enable, bool allow_10_100)\r\n{\r\nu32 port_mask = 0;\r\nu16 max_size = JMS_MIN_SIZE;\r\nif (is5325(dev) || is5365(dev))\r\nreturn -EINVAL;\r\nif (enable) {\r\nport_mask = dev->enabled_ports;\r\nmax_size = JMS_MAX_SIZE;\r\nif (allow_10_100)\r\nport_mask |= JPM_10_100_JUMBO_EN;\r\n}\r\nb53_write32(dev, B53_JUMBO_PAGE, dev->jumbo_pm_reg, port_mask);\r\nreturn b53_write16(dev, B53_JUMBO_PAGE, dev->jumbo_size_reg, max_size);\r\n}\r\nstatic int b53_flush_arl(struct b53_device *dev, u8 mask)\r\n{\r\nunsigned int i;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL,\r\nFAST_AGE_DONE | FAST_AGE_DYNAMIC | mask);\r\nfor (i = 0; i < 10; i++) {\r\nu8 fast_age_ctrl;\r\nb53_read8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL,\r\n&fast_age_ctrl);\r\nif (!(fast_age_ctrl & FAST_AGE_DONE))\r\ngoto out;\r\nmsleep(1);\r\n}\r\nreturn -ETIMEDOUT;\r\nout:\r\nb53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_CTRL, FAST_AGE_DYNAMIC);\r\nreturn 0;\r\n}\r\nstatic int b53_fast_age_port(struct b53_device *dev, int port)\r\n{\r\nb53_write8(dev, B53_CTRL_PAGE, B53_FAST_AGE_PORT_CTRL, port);\r\nreturn b53_flush_arl(dev, FAST_AGE_PORT);\r\n}\r\nstatic int b53_fast_age_vlan(struct b53_device *dev, u16 vid)\r\n{\r\nb53_write16(dev, B53_CTRL_PAGE, B53_FAST_AGE_VID_CTRL, vid);\r\nreturn b53_flush_arl(dev, FAST_AGE_VLAN);\r\n}\r\nstatic void b53_imp_vlan_setup(struct dsa_switch *ds, int cpu_port)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nunsigned int i;\r\nu16 pvlan;\r\nb53_for_each_port(dev, i) {\r\nb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &pvlan);\r\npvlan |= BIT(cpu_port);\r\nb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), pvlan);\r\n}\r\n}\r\nstatic int b53_enable_port(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nunsigned int cpu_port = dev->cpu_port;\r\nu16 pvlan;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), 0);\r\nb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), &pvlan);\r\npvlan &= ~0x1ff;\r\npvlan |= BIT(port);\r\npvlan |= dev->ports[port].vlan_ctl_mask;\r\nb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), pvlan);\r\nb53_imp_vlan_setup(ds, cpu_port);\r\nreturn 0;\r\n}\r\nstatic void b53_disable_port(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nu8 reg;\r\nb53_read8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), &reg);\r\nreg |= PORT_CTRL_RX_DISABLE | PORT_CTRL_TX_DISABLE;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), reg);\r\n}\r\nstatic void b53_enable_cpu_port(struct b53_device *dev)\r\n{\r\nunsigned int cpu_port = dev->cpu_port;\r\nu8 port_ctrl;\r\nif ((is5325(dev) || is5365(dev)) && cpu_port == B53_CPU_PORT_25)\r\ncpu_port = B53_CPU_PORT;\r\nport_ctrl = PORT_CTRL_RX_BCST_EN |\r\nPORT_CTRL_RX_MCST_EN |\r\nPORT_CTRL_RX_UCST_EN;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(cpu_port), port_ctrl);\r\n}\r\nstatic void b53_enable_mib(struct b53_device *dev)\r\n{\r\nu8 gc;\r\nb53_read8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);\r\ngc &= ~(GC_RESET_MIB | GC_MIB_AC_EN);\r\nb53_write8(dev, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc);\r\n}\r\nstatic int b53_configure_vlan(struct b53_device *dev)\r\n{\r\nstruct b53_vlan vl = { 0 };\r\nint i;\r\nif (is5325(dev) || is5365(dev)) {\r\nfor (i = 1; i < dev->num_vlans; i++)\r\nb53_set_vlan_entry(dev, i, &vl);\r\n} else {\r\nb53_do_vlan_op(dev, VTA_CMD_CLEAR);\r\n}\r\nb53_enable_vlan(dev, false);\r\nb53_for_each_port(dev, i)\r\nb53_write16(dev, B53_VLAN_PAGE,\r\nB53_VLAN_PORT_DEF_TAG(i), 1);\r\nif (!is5325(dev) && !is5365(dev))\r\nb53_set_jumbo(dev, dev->enable_jumbo, false);\r\nreturn 0;\r\n}\r\nstatic void b53_switch_reset_gpio(struct b53_device *dev)\r\n{\r\nint gpio = dev->reset_gpio;\r\nif (gpio < 0)\r\nreturn;\r\ngpio_set_value(gpio, 0);\r\nmdelay(50);\r\ngpio_set_value(gpio, 1);\r\nmdelay(20);\r\ndev->current_page = 0xff;\r\n}\r\nstatic int b53_switch_reset(struct b53_device *dev)\r\n{\r\nunsigned int timeout = 1000;\r\nu8 mgmt, reg;\r\nb53_switch_reset_gpio(dev);\r\nif (is539x(dev)) {\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, 0x83);\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, 0x00);\r\n}\r\nif (dev->chip_id == BCM58XX_DEVICE_ID) {\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SOFTRESET, &reg);\r\nreg |= SW_RST | EN_SW_RST | EN_CH_RST;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SOFTRESET, reg);\r\ndo {\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SOFTRESET, &reg);\r\nif (!(reg & SW_RST))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (timeout-- > 0);\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\n}\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\r\nif (!(mgmt & SM_SW_FWD_EN)) {\r\nmgmt &= ~SM_SW_FWD_MODE;\r\nmgmt |= SM_SW_FWD_EN;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, mgmt);\r\nb53_read8(dev, B53_CTRL_PAGE, B53_SWITCH_MODE, &mgmt);\r\nif (!(mgmt & SM_SW_FWD_EN)) {\r\ndev_err(dev->dev, "Failed to enable switch!\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nb53_enable_mib(dev);\r\nreturn b53_flush_arl(dev, FAST_AGE_STATIC);\r\n}\r\nstatic int b53_phy_read16(struct dsa_switch *ds, int addr, int reg)\r\n{\r\nstruct b53_device *priv = ds->priv;\r\nu16 value = 0;\r\nint ret;\r\nif (priv->ops->phy_read16)\r\nret = priv->ops->phy_read16(priv, addr, reg, &value);\r\nelse\r\nret = b53_read16(priv, B53_PORT_MII_PAGE(addr),\r\nreg * 2, &value);\r\nreturn ret ? ret : value;\r\n}\r\nstatic int b53_phy_write16(struct dsa_switch *ds, int addr, int reg, u16 val)\r\n{\r\nstruct b53_device *priv = ds->priv;\r\nif (priv->ops->phy_write16)\r\nreturn priv->ops->phy_write16(priv, addr, reg, val);\r\nreturn b53_write16(priv, B53_PORT_MII_PAGE(addr), reg * 2, val);\r\n}\r\nstatic int b53_reset_switch(struct b53_device *priv)\r\n{\r\npriv->enable_jumbo = false;\r\nmemset(priv->vlans, 0, sizeof(*priv->vlans) * priv->num_vlans);\r\nmemset(priv->ports, 0, sizeof(*priv->ports) * priv->num_ports);\r\nreturn b53_switch_reset(priv);\r\n}\r\nstatic int b53_apply_config(struct b53_device *priv)\r\n{\r\nb53_set_forwarding(priv, 0);\r\nb53_configure_vlan(priv);\r\nb53_set_forwarding(priv, 1);\r\nreturn 0;\r\n}\r\nstatic void b53_reset_mib(struct b53_device *priv)\r\n{\r\nu8 gc;\r\nb53_read8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, &gc);\r\nb53_write8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc | GC_RESET_MIB);\r\nmsleep(1);\r\nb53_write8(priv, B53_MGMT_PAGE, B53_GLOBAL_CONFIG, gc & ~GC_RESET_MIB);\r\nmsleep(1);\r\n}\r\nstatic const struct b53_mib_desc *b53_get_mib(struct b53_device *dev)\r\n{\r\nif (is5365(dev))\r\nreturn b53_mibs_65;\r\nelse if (is63xx(dev))\r\nreturn b53_mibs_63xx;\r\nelse if (is58xx(dev))\r\nreturn b53_mibs_58xx;\r\nelse\r\nreturn b53_mibs;\r\n}\r\nstatic unsigned int b53_get_mib_size(struct b53_device *dev)\r\n{\r\nif (is5365(dev))\r\nreturn B53_MIBS_65_SIZE;\r\nelse if (is63xx(dev))\r\nreturn B53_MIBS_63XX_SIZE;\r\nelse if (is58xx(dev))\r\nreturn B53_MIBS_58XX_SIZE;\r\nelse\r\nreturn B53_MIBS_SIZE;\r\n}\r\nvoid b53_get_strings(struct dsa_switch *ds, int port, uint8_t *data)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nconst struct b53_mib_desc *mibs = b53_get_mib(dev);\r\nunsigned int mib_size = b53_get_mib_size(dev);\r\nunsigned int i;\r\nfor (i = 0; i < mib_size; i++)\r\nmemcpy(data + i * ETH_GSTRING_LEN,\r\nmibs[i].name, ETH_GSTRING_LEN);\r\n}\r\nvoid b53_get_ethtool_stats(struct dsa_switch *ds, int port, uint64_t *data)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nconst struct b53_mib_desc *mibs = b53_get_mib(dev);\r\nunsigned int mib_size = b53_get_mib_size(dev);\r\nconst struct b53_mib_desc *s;\r\nunsigned int i;\r\nu64 val = 0;\r\nif (is5365(dev) && port == 5)\r\nport = 8;\r\nmutex_lock(&dev->stats_mutex);\r\nfor (i = 0; i < mib_size; i++) {\r\ns = &mibs[i];\r\nif (s->size == 8) {\r\nb53_read64(dev, B53_MIB_PAGE(port), s->offset, &val);\r\n} else {\r\nu32 val32;\r\nb53_read32(dev, B53_MIB_PAGE(port), s->offset,\r\n&val32);\r\nval = val32;\r\n}\r\ndata[i] = (u64)val;\r\n}\r\nmutex_unlock(&dev->stats_mutex);\r\n}\r\nint b53_get_sset_count(struct dsa_switch *ds)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nreturn b53_get_mib_size(dev);\r\n}\r\nstatic int b53_setup(struct dsa_switch *ds)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nunsigned int port;\r\nint ret;\r\nret = b53_reset_switch(dev);\r\nif (ret) {\r\ndev_err(ds->dev, "failed to reset switch\n");\r\nreturn ret;\r\n}\r\nb53_reset_mib(dev);\r\nret = b53_apply_config(dev);\r\nif (ret)\r\ndev_err(ds->dev, "failed to apply configuration\n");\r\nfor (port = 0; port < dev->num_ports; port++) {\r\nif (BIT(port) & ds->enabled_port_mask)\r\nb53_enable_port(ds, port, NULL);\r\nelse if (dsa_is_cpu_port(ds, port))\r\nb53_enable_cpu_port(dev);\r\nelse\r\nb53_disable_port(ds, port, NULL);\r\n}\r\nreturn ret;\r\n}\r\nstatic void b53_adjust_link(struct dsa_switch *ds, int port,\r\nstruct phy_device *phydev)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nu8 rgmii_ctrl = 0, reg = 0, off;\r\nif (!phy_is_pseudo_fixed_link(phydev))\r\nreturn;\r\nif (port == dev->cpu_port) {\r\noff = B53_PORT_OVERRIDE_CTRL;\r\nreg = PORT_OVERRIDE_EN;\r\n} else {\r\noff = B53_GMII_PORT_OVERRIDE_CTRL(port);\r\nreg = GMII_PO_EN;\r\n}\r\nif (phydev->link)\r\nreg |= PORT_OVERRIDE_LINK;\r\nif (phydev->duplex == DUPLEX_FULL)\r\nreg |= PORT_OVERRIDE_FULL_DUPLEX;\r\nswitch (phydev->speed) {\r\ncase 2000:\r\nreg |= PORT_OVERRIDE_SPEED_2000M;\r\ncase SPEED_1000:\r\nreg |= PORT_OVERRIDE_SPEED_1000M;\r\nbreak;\r\ncase SPEED_100:\r\nreg |= PORT_OVERRIDE_SPEED_100M;\r\nbreak;\r\ncase SPEED_10:\r\nreg |= PORT_OVERRIDE_SPEED_10M;\r\nbreak;\r\ndefault:\r\ndev_err(ds->dev, "unknown speed: %d\n", phydev->speed);\r\nreturn;\r\n}\r\nif (is5301x(dev) && port == dev->cpu_port)\r\nreg |= PORT_OVERRIDE_RX_FLOW | PORT_OVERRIDE_TX_FLOW;\r\nif (phydev->pause) {\r\nif (phydev->asym_pause)\r\nreg |= PORT_OVERRIDE_TX_FLOW;\r\nreg |= PORT_OVERRIDE_RX_FLOW;\r\n}\r\nb53_write8(dev, B53_CTRL_PAGE, off, reg);\r\nif (is531x5(dev) && phy_interface_is_rgmii(phydev)) {\r\nif (port == 8)\r\noff = B53_RGMII_CTRL_IMP;\r\nelse\r\noff = B53_RGMII_CTRL_P(port);\r\nb53_read8(dev, B53_CTRL_PAGE, off, &rgmii_ctrl);\r\nrgmii_ctrl &= ~(RGMII_CTRL_DLL_RXC | RGMII_CTRL_DLL_TXC |\r\nRGMII_CTRL_TIMING_SEL);\r\nif (phydev->interface == PHY_INTERFACE_MODE_RGMII_TXID)\r\nrgmii_ctrl |= RGMII_CTRL_DLL_TXC;\r\nif (phydev->interface == PHY_INTERFACE_MODE_RGMII)\r\nrgmii_ctrl |= RGMII_CTRL_DLL_TXC | RGMII_CTRL_DLL_RXC;\r\nrgmii_ctrl |= RGMII_CTRL_TIMING_SEL;\r\nb53_write8(dev, B53_CTRL_PAGE, off, rgmii_ctrl);\r\ndev_info(ds->dev, "Configured port %d for %s\n", port,\r\nphy_modes(phydev->interface));\r\n}\r\nif (is5325(dev)) {\r\nb53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,\r\n&reg);\r\nif (!(reg & PORT_OVERRIDE_RV_MII_25)) {\r\nb53_write8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,\r\nreg | PORT_OVERRIDE_RV_MII_25);\r\nb53_read8(dev, B53_CTRL_PAGE, B53_PORT_OVERRIDE_CTRL,\r\n&reg);\r\nif (!(reg & PORT_OVERRIDE_RV_MII_25)) {\r\ndev_err(ds->dev,\r\n"Failed to enable reverse MII mode\n");\r\nreturn;\r\n}\r\n}\r\n} else if (is5301x(dev)) {\r\nif (port != dev->cpu_port) {\r\nu8 po_reg = B53_GMII_PORT_OVERRIDE_CTRL(dev->cpu_port);\r\nu8 gmii_po;\r\nb53_read8(dev, B53_CTRL_PAGE, po_reg, &gmii_po);\r\ngmii_po |= GMII_PO_LINK |\r\nGMII_PO_RX_FLOW |\r\nGMII_PO_TX_FLOW |\r\nGMII_PO_EN |\r\nGMII_PO_SPEED_2000M;\r\nb53_write8(dev, B53_CTRL_PAGE, po_reg, gmii_po);\r\n}\r\n}\r\n}\r\nint b53_vlan_filtering(struct dsa_switch *ds, int port, bool vlan_filtering)\r\n{\r\nreturn 0;\r\n}\r\nint b53_vlan_prepare(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_vlan *vlan,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nif ((is5325(dev) || is5365(dev)) && vlan->vid_begin == 0)\r\nreturn -EOPNOTSUPP;\r\nif (vlan->vid_end > dev->num_vlans)\r\nreturn -ERANGE;\r\nb53_enable_vlan(dev, true);\r\nreturn 0;\r\n}\r\nvoid b53_vlan_add(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_vlan *vlan,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\r\nbool pvid = vlan->flags & BRIDGE_VLAN_INFO_PVID;\r\nunsigned int cpu_port = dev->cpu_port;\r\nstruct b53_vlan *vl;\r\nu16 vid;\r\nfor (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {\r\nvl = &dev->vlans[vid];\r\nb53_get_vlan_entry(dev, vid, vl);\r\nvl->members |= BIT(port) | BIT(cpu_port);\r\nif (untagged)\r\nvl->untag |= BIT(port);\r\nelse\r\nvl->untag &= ~BIT(port);\r\nvl->untag &= ~BIT(cpu_port);\r\nb53_set_vlan_entry(dev, vid, vl);\r\nb53_fast_age_vlan(dev, vid);\r\n}\r\nif (pvid) {\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port),\r\nvlan->vid_end);\r\nb53_fast_age_vlan(dev, vid);\r\n}\r\n}\r\nint b53_vlan_del(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_vlan *vlan)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nbool untagged = vlan->flags & BRIDGE_VLAN_INFO_UNTAGGED;\r\nstruct b53_vlan *vl;\r\nu16 vid;\r\nu16 pvid;\r\nb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), &pvid);\r\nfor (vid = vlan->vid_begin; vid <= vlan->vid_end; ++vid) {\r\nvl = &dev->vlans[vid];\r\nb53_get_vlan_entry(dev, vid, vl);\r\nvl->members &= ~BIT(port);\r\nif (pvid == vid) {\r\nif (is5325(dev) || is5365(dev))\r\npvid = 1;\r\nelse\r\npvid = 0;\r\n}\r\nif (untagged)\r\nvl->untag &= ~(BIT(port));\r\nb53_set_vlan_entry(dev, vid, vl);\r\nb53_fast_age_vlan(dev, vid);\r\n}\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), pvid);\r\nb53_fast_age_vlan(dev, pvid);\r\nreturn 0;\r\n}\r\nint b53_vlan_dump(struct dsa_switch *ds, int port,\r\nstruct switchdev_obj_port_vlan *vlan,\r\nint (*cb)(struct switchdev_obj *obj))\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nu16 vid, vid_start = 0, pvid;\r\nstruct b53_vlan *vl;\r\nint err = 0;\r\nif (is5325(dev) || is5365(dev))\r\nvid_start = 1;\r\nb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_PORT_DEF_TAG(port), &pvid);\r\nfor (vid = vid_start; vid < dev->num_vlans; vid++) {\r\nvl = &dev->vlans[vid];\r\nif (!vl->valid)\r\ncontinue;\r\nif (!(vl->members & BIT(port)))\r\ncontinue;\r\nvlan->vid_begin = vlan->vid_end = vid;\r\nvlan->flags = 0;\r\nif (vl->untag & BIT(port))\r\nvlan->flags |= BRIDGE_VLAN_INFO_UNTAGGED;\r\nif (pvid == vid)\r\nvlan->flags |= BRIDGE_VLAN_INFO_PVID;\r\nerr = cb(&vlan->obj);\r\nif (err)\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int b53_arl_op_wait(struct b53_device *dev)\r\n{\r\nunsigned int timeout = 10;\r\nu8 reg;\r\ndo {\r\nb53_read8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, &reg);\r\nif (!(reg & ARLTBL_START_DONE))\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\ndev_warn(dev->dev, "timeout waiting for ARL to finish: 0x%02x\n", reg);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int b53_arl_rw_op(struct b53_device *dev, unsigned int op)\r\n{\r\nu8 reg;\r\nif (op > ARLTBL_RW)\r\nreturn -EINVAL;\r\nb53_read8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, &reg);\r\nreg |= ARLTBL_START_DONE;\r\nif (op)\r\nreg |= ARLTBL_RW;\r\nelse\r\nreg &= ~ARLTBL_RW;\r\nb53_write8(dev, B53_ARLIO_PAGE, B53_ARLTBL_RW_CTRL, reg);\r\nreturn b53_arl_op_wait(dev);\r\n}\r\nstatic int b53_arl_read(struct b53_device *dev, u64 mac,\r\nu16 vid, struct b53_arl_entry *ent, u8 *idx,\r\nbool is_valid)\r\n{\r\nunsigned int i;\r\nint ret;\r\nret = b53_arl_op_wait(dev);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < dev->num_arl_entries; i++) {\r\nu64 mac_vid;\r\nu32 fwd_entry;\r\nb53_read64(dev, B53_ARLIO_PAGE,\r\nB53_ARLTBL_MAC_VID_ENTRY(i), &mac_vid);\r\nb53_read32(dev, B53_ARLIO_PAGE,\r\nB53_ARLTBL_DATA_ENTRY(i), &fwd_entry);\r\nb53_arl_to_entry(ent, mac_vid, fwd_entry);\r\nif (!(fwd_entry & ARLTBL_VALID))\r\ncontinue;\r\nif ((mac_vid & ARLTBL_MAC_MASK) != mac)\r\ncontinue;\r\n*idx = i;\r\n}\r\nreturn -ENOENT;\r\n}\r\nstatic int b53_arl_op(struct b53_device *dev, int op, int port,\r\nconst unsigned char *addr, u16 vid, bool is_valid)\r\n{\r\nstruct b53_arl_entry ent;\r\nu32 fwd_entry;\r\nu64 mac, mac_vid = 0;\r\nu8 idx = 0;\r\nint ret;\r\nmac = ether_addr_to_u64(addr);\r\nb53_write48(dev, B53_ARLIO_PAGE, B53_MAC_ADDR_IDX, mac);\r\nb53_write16(dev, B53_ARLIO_PAGE, B53_VLAN_ID_IDX, vid);\r\nret = b53_arl_rw_op(dev, 1);\r\nif (ret)\r\nreturn ret;\r\nret = b53_arl_read(dev, mac, vid, &ent, &idx, is_valid);\r\nif (op)\r\nreturn ret;\r\nif (ret) {\r\nfwd_entry = 0;\r\nidx = 1;\r\n}\r\nmemset(&ent, 0, sizeof(ent));\r\nent.port = port;\r\nent.is_valid = is_valid;\r\nent.vid = vid;\r\nent.is_static = true;\r\nmemcpy(ent.mac, addr, ETH_ALEN);\r\nb53_arl_from_entry(&mac_vid, &fwd_entry, &ent);\r\nb53_write64(dev, B53_ARLIO_PAGE,\r\nB53_ARLTBL_MAC_VID_ENTRY(idx), mac_vid);\r\nb53_write32(dev, B53_ARLIO_PAGE,\r\nB53_ARLTBL_DATA_ENTRY(idx), fwd_entry);\r\nreturn b53_arl_rw_op(dev, 0);\r\n}\r\nint b53_fdb_prepare(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct b53_device *priv = ds->priv;\r\nif (is5325(priv) || is5365(priv))\r\nreturn -EOPNOTSUPP;\r\nreturn 0;\r\n}\r\nvoid b53_fdb_add(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct b53_device *priv = ds->priv;\r\nif (b53_arl_op(priv, 0, port, fdb->addr, fdb->vid, true))\r\npr_err("%s: failed to add MAC address\n", __func__);\r\n}\r\nint b53_fdb_del(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb)\r\n{\r\nstruct b53_device *priv = ds->priv;\r\nreturn b53_arl_op(priv, 0, port, fdb->addr, fdb->vid, false);\r\n}\r\nstatic int b53_arl_search_wait(struct b53_device *dev)\r\n{\r\nunsigned int timeout = 1000;\r\nu8 reg;\r\ndo {\r\nb53_read8(dev, B53_ARLIO_PAGE, B53_ARL_SRCH_CTL, &reg);\r\nif (!(reg & ARL_SRCH_STDN))\r\nreturn 0;\r\nif (reg & ARL_SRCH_VLID)\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void b53_arl_search_rd(struct b53_device *dev, u8 idx,\r\nstruct b53_arl_entry *ent)\r\n{\r\nu64 mac_vid;\r\nu32 fwd_entry;\r\nb53_read64(dev, B53_ARLIO_PAGE,\r\nB53_ARL_SRCH_RSTL_MACVID(idx), &mac_vid);\r\nb53_read32(dev, B53_ARLIO_PAGE,\r\nB53_ARL_SRCH_RSTL(idx), &fwd_entry);\r\nb53_arl_to_entry(ent, mac_vid, fwd_entry);\r\n}\r\nstatic int b53_fdb_copy(struct net_device *dev, int port,\r\nconst struct b53_arl_entry *ent,\r\nstruct switchdev_obj_port_fdb *fdb,\r\nint (*cb)(struct switchdev_obj *obj))\r\n{\r\nif (!ent->is_valid)\r\nreturn 0;\r\nif (port != ent->port)\r\nreturn 0;\r\nether_addr_copy(fdb->addr, ent->mac);\r\nfdb->vid = ent->vid;\r\nfdb->ndm_state = ent->is_static ? NUD_NOARP : NUD_REACHABLE;\r\nreturn cb(&fdb->obj);\r\n}\r\nint b53_fdb_dump(struct dsa_switch *ds, int port,\r\nstruct switchdev_obj_port_fdb *fdb,\r\nint (*cb)(struct switchdev_obj *obj))\r\n{\r\nstruct b53_device *priv = ds->priv;\r\nstruct net_device *dev = ds->ports[port].netdev;\r\nstruct b53_arl_entry results[2];\r\nunsigned int count = 0;\r\nint ret;\r\nu8 reg;\r\nreg = ARL_SRCH_STDN;\r\nb53_write8(priv, B53_ARLIO_PAGE, B53_ARL_SRCH_CTL, reg);\r\ndo {\r\nret = b53_arl_search_wait(priv);\r\nif (ret)\r\nreturn ret;\r\nb53_arl_search_rd(priv, 0, &results[0]);\r\nret = b53_fdb_copy(dev, port, &results[0], fdb, cb);\r\nif (ret)\r\nreturn ret;\r\nif (priv->num_arl_entries > 2) {\r\nb53_arl_search_rd(priv, 1, &results[1]);\r\nret = b53_fdb_copy(dev, port, &results[1], fdb, cb);\r\nif (ret)\r\nreturn ret;\r\nif (!results[0].is_valid && !results[1].is_valid)\r\nbreak;\r\n}\r\n} while (count++ < 1024);\r\nreturn 0;\r\n}\r\nint b53_br_join(struct dsa_switch *ds, int port, struct net_device *br)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\ns8 cpu_port = ds->dst->cpu_port;\r\nu16 pvlan, reg;\r\nunsigned int i;\r\nif (is58xx(dev)) {\r\nb53_read16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, &reg);\r\nreg &= ~BIT(port);\r\nif ((reg & BIT(cpu_port)) == BIT(cpu_port))\r\nreg &= ~BIT(cpu_port);\r\nb53_write16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, reg);\r\n}\r\nb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), &pvlan);\r\nb53_for_each_port(dev, i) {\r\nif (ds->ports[i].bridge_dev != br)\r\ncontinue;\r\nb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &reg);\r\nreg |= BIT(port);\r\nb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), reg);\r\ndev->ports[i].vlan_ctl_mask = reg;\r\npvlan |= BIT(i);\r\n}\r\nb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), pvlan);\r\ndev->ports[port].vlan_ctl_mask = pvlan;\r\nreturn 0;\r\n}\r\nvoid b53_br_leave(struct dsa_switch *ds, int port, struct net_device *br)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nstruct b53_vlan *vl = &dev->vlans[0];\r\ns8 cpu_port = ds->dst->cpu_port;\r\nunsigned int i;\r\nu16 pvlan, reg, pvid;\r\nb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), &pvlan);\r\nb53_for_each_port(dev, i) {\r\nif (ds->ports[i].bridge_dev != br)\r\ncontinue;\r\nb53_read16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), &reg);\r\nreg &= ~BIT(port);\r\nb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(i), reg);\r\ndev->ports[port].vlan_ctl_mask = reg;\r\nif (port != i)\r\npvlan &= ~BIT(i);\r\n}\r\nb53_write16(dev, B53_PVLAN_PAGE, B53_PVLAN_PORT_MASK(port), pvlan);\r\ndev->ports[port].vlan_ctl_mask = pvlan;\r\nif (is5325(dev) || is5365(dev))\r\npvid = 1;\r\nelse\r\npvid = 0;\r\nif (is58xx(dev)) {\r\nb53_read16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, &reg);\r\nreg |= BIT(port);\r\nif (!(reg & BIT(cpu_port)))\r\nreg |= BIT(cpu_port);\r\nb53_write16(dev, B53_VLAN_PAGE, B53_JOIN_ALL_VLAN_EN, reg);\r\n} else {\r\nb53_get_vlan_entry(dev, pvid, vl);\r\nvl->members |= BIT(port) | BIT(dev->cpu_port);\r\nvl->untag |= BIT(port) | BIT(dev->cpu_port);\r\nb53_set_vlan_entry(dev, pvid, vl);\r\n}\r\n}\r\nvoid b53_br_set_stp_state(struct dsa_switch *ds, int port, u8 state)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nu8 hw_state;\r\nu8 reg;\r\nswitch (state) {\r\ncase BR_STATE_DISABLED:\r\nhw_state = PORT_CTRL_DIS_STATE;\r\nbreak;\r\ncase BR_STATE_LISTENING:\r\nhw_state = PORT_CTRL_LISTEN_STATE;\r\nbreak;\r\ncase BR_STATE_LEARNING:\r\nhw_state = PORT_CTRL_LEARN_STATE;\r\nbreak;\r\ncase BR_STATE_FORWARDING:\r\nhw_state = PORT_CTRL_FWD_STATE;\r\nbreak;\r\ncase BR_STATE_BLOCKING:\r\nhw_state = PORT_CTRL_BLOCK_STATE;\r\nbreak;\r\ndefault:\r\ndev_err(ds->dev, "invalid STP state: %d\n", state);\r\nreturn;\r\n}\r\nb53_read8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), &reg);\r\nreg &= ~PORT_CTRL_STP_STATE_MASK;\r\nreg |= hw_state;\r\nb53_write8(dev, B53_CTRL_PAGE, B53_PORT_CTRL(port), reg);\r\n}\r\nvoid b53_br_fast_age(struct dsa_switch *ds, int port)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nif (b53_fast_age_port(dev, port))\r\ndev_err(ds->dev, "fast ageing failed\n");\r\n}\r\nstatic enum dsa_tag_protocol b53_get_tag_protocol(struct dsa_switch *ds)\r\n{\r\nreturn DSA_TAG_PROTO_NONE;\r\n}\r\nint b53_mirror_add(struct dsa_switch *ds, int port,\r\nstruct dsa_mall_mirror_tc_entry *mirror, bool ingress)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nu16 reg, loc;\r\nif (ingress)\r\nloc = B53_IG_MIR_CTL;\r\nelse\r\nloc = B53_EG_MIR_CTL;\r\nb53_read16(dev, B53_MGMT_PAGE, loc, &reg);\r\nreg &= ~MIRROR_MASK;\r\nreg |= BIT(port);\r\nb53_write16(dev, B53_MGMT_PAGE, loc, reg);\r\nb53_read16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, &reg);\r\nreg &= ~CAP_PORT_MASK;\r\nreg |= mirror->to_local_port;\r\nreg |= MIRROR_EN;\r\nb53_write16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, reg);\r\nreturn 0;\r\n}\r\nvoid b53_mirror_del(struct dsa_switch *ds, int port,\r\nstruct dsa_mall_mirror_tc_entry *mirror)\r\n{\r\nstruct b53_device *dev = ds->priv;\r\nbool loc_disable = false, other_loc_disable = false;\r\nu16 reg, loc;\r\nif (mirror->ingress)\r\nloc = B53_IG_MIR_CTL;\r\nelse\r\nloc = B53_EG_MIR_CTL;\r\nb53_read16(dev, B53_MGMT_PAGE, loc, &reg);\r\nreg &= ~BIT(port);\r\nif (!(reg & MIRROR_MASK))\r\nloc_disable = true;\r\nb53_write16(dev, B53_MGMT_PAGE, loc, reg);\r\nif (mirror->ingress)\r\nb53_read16(dev, B53_MGMT_PAGE, B53_EG_MIR_CTL, &reg);\r\nelse\r\nb53_read16(dev, B53_MGMT_PAGE, B53_IG_MIR_CTL, &reg);\r\nif (!(reg & MIRROR_MASK))\r\nother_loc_disable = true;\r\nb53_read16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, &reg);\r\nif (loc_disable && other_loc_disable) {\r\nreg &= ~MIRROR_EN;\r\nreg &= ~mirror->to_local_port;\r\n}\r\nb53_write16(dev, B53_MGMT_PAGE, B53_MIR_CAP_CTL, reg);\r\n}\r\nstatic int b53_switch_init(struct b53_device *dev)\r\n{\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(b53_switch_chips); i++) {\r\nconst struct b53_chip_data *chip = &b53_switch_chips[i];\r\nif (chip->chip_id == dev->chip_id) {\r\nif (!dev->enabled_ports)\r\ndev->enabled_ports = chip->enabled_ports;\r\ndev->name = chip->dev_name;\r\ndev->duplex_reg = chip->duplex_reg;\r\ndev->vta_regs[0] = chip->vta_regs[0];\r\ndev->vta_regs[1] = chip->vta_regs[1];\r\ndev->vta_regs[2] = chip->vta_regs[2];\r\ndev->jumbo_pm_reg = chip->jumbo_pm_reg;\r\ndev->cpu_port = chip->cpu_port;\r\ndev->num_vlans = chip->vlans;\r\ndev->num_arl_entries = chip->arl_entries;\r\nbreak;\r\n}\r\n}\r\nif (is5325(dev)) {\r\nu8 vc4;\r\nb53_read8(dev, B53_VLAN_PAGE, B53_VLAN_CTRL4_25, &vc4);\r\nswitch (vc4 & 3) {\r\ncase 1:\r\nbreak;\r\ncase 3:\r\ndev->enabled_ports &= ~BIT(4);\r\nbreak;\r\ndefault:\r\n#ifndef CONFIG_BCM47XX\r\nreturn -EINVAL;\r\n#else\r\nbreak;\r\n#endif\r\n}\r\n} else if (dev->chip_id == BCM53115_DEVICE_ID) {\r\nu64 strap_value;\r\nb53_read48(dev, B53_STAT_PAGE, B53_STRAP_VALUE, &strap_value);\r\nif (strap_value & SV_GMII_CTRL_115)\r\ndev->cpu_port = 5;\r\n}\r\ndev->num_ports = dev->cpu_port + 1;\r\ndev->enabled_ports |= BIT(dev->cpu_port);\r\ndev->ports = devm_kzalloc(dev->dev,\r\nsizeof(struct b53_port) * dev->num_ports,\r\nGFP_KERNEL);\r\nif (!dev->ports)\r\nreturn -ENOMEM;\r\ndev->vlans = devm_kzalloc(dev->dev,\r\nsizeof(struct b53_vlan) * dev->num_vlans,\r\nGFP_KERNEL);\r\nif (!dev->vlans)\r\nreturn -ENOMEM;\r\ndev->reset_gpio = b53_switch_get_reset_gpio(dev);\r\nif (dev->reset_gpio >= 0) {\r\nret = devm_gpio_request_one(dev->dev, dev->reset_gpio,\r\nGPIOF_OUT_INIT_HIGH, "robo_reset");\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstruct b53_device *b53_switch_alloc(struct device *base,\r\nconst struct b53_io_ops *ops,\r\nvoid *priv)\r\n{\r\nstruct dsa_switch *ds;\r\nstruct b53_device *dev;\r\nds = dsa_switch_alloc(base, DSA_MAX_PORTS);\r\nif (!ds)\r\nreturn NULL;\r\ndev = devm_kzalloc(base, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn NULL;\r\nds->priv = dev;\r\ndev->dev = base;\r\ndev->ds = ds;\r\ndev->priv = priv;\r\ndev->ops = ops;\r\nds->ops = &b53_switch_ops;\r\nmutex_init(&dev->reg_mutex);\r\nmutex_init(&dev->stats_mutex);\r\nreturn dev;\r\n}\r\nint b53_switch_detect(struct b53_device *dev)\r\n{\r\nu32 id32;\r\nu16 tmp;\r\nu8 id8;\r\nint ret;\r\nret = b53_read8(dev, B53_MGMT_PAGE, B53_DEVICE_ID, &id8);\r\nif (ret)\r\nreturn ret;\r\nswitch (id8) {\r\ncase 0:\r\nb53_write16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, 0xf);\r\nb53_read16(dev, B53_VLAN_PAGE, B53_VLAN_TABLE_ACCESS_25, &tmp);\r\nif (tmp == 0xf)\r\ndev->chip_id = BCM5325_DEVICE_ID;\r\nelse\r\ndev->chip_id = BCM5365_DEVICE_ID;\r\nbreak;\r\ncase BCM5395_DEVICE_ID:\r\ncase BCM5397_DEVICE_ID:\r\ncase BCM5398_DEVICE_ID:\r\ndev->chip_id = id8;\r\nbreak;\r\ndefault:\r\nret = b53_read32(dev, B53_MGMT_PAGE, B53_DEVICE_ID, &id32);\r\nif (ret)\r\nreturn ret;\r\nswitch (id32) {\r\ncase BCM53115_DEVICE_ID:\r\ncase BCM53125_DEVICE_ID:\r\ncase BCM53128_DEVICE_ID:\r\ncase BCM53010_DEVICE_ID:\r\ncase BCM53011_DEVICE_ID:\r\ncase BCM53012_DEVICE_ID:\r\ncase BCM53018_DEVICE_ID:\r\ncase BCM53019_DEVICE_ID:\r\ndev->chip_id = id32;\r\nbreak;\r\ndefault:\r\npr_err("unsupported switch detected (BCM53%02x/BCM%x)\n",\r\nid8, id32);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (dev->chip_id == BCM5325_DEVICE_ID)\r\nreturn b53_read8(dev, B53_STAT_PAGE, B53_REV_ID_25,\r\n&dev->core_rev);\r\nelse\r\nreturn b53_read8(dev, B53_MGMT_PAGE, B53_REV_ID,\r\n&dev->core_rev);\r\n}\r\nint b53_switch_register(struct b53_device *dev)\r\n{\r\nint ret;\r\nif (dev->pdata) {\r\ndev->chip_id = dev->pdata->chip_id;\r\ndev->enabled_ports = dev->pdata->enabled_ports;\r\n}\r\nif (!dev->chip_id && b53_switch_detect(dev))\r\nreturn -EINVAL;\r\nret = b53_switch_init(dev);\r\nif (ret)\r\nreturn ret;\r\npr_info("found switch: %s, rev %i\n", dev->name, dev->core_rev);\r\nreturn dsa_register_switch(dev->ds, dev->ds->dev);\r\n}
