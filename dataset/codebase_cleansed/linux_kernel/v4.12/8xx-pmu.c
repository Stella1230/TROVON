static s64 get_insn_ctr(void)\r\n{\r\nint ctr;\r\nunsigned long counta;\r\ndo {\r\nctr = atomic_read(&instruction_counter);\r\ncounta = mfspr(SPRN_COUNTA);\r\n} while (ctr != atomic_read(&instruction_counter));\r\nreturn ((s64)ctr << 16) | (counta >> 16);\r\n}\r\nstatic int event_type(struct perf_event *event)\r\n{\r\nswitch (event->attr.type) {\r\ncase PERF_TYPE_HARDWARE:\r\nif (event->attr.config == PERF_COUNT_HW_CPU_CYCLES)\r\nreturn PERF_8xx_ID_CPU_CYCLES;\r\nif (event->attr.config == PERF_COUNT_HW_INSTRUCTIONS)\r\nreturn PERF_8xx_ID_HW_INSTRUCTIONS;\r\nbreak;\r\ncase PERF_TYPE_HW_CACHE:\r\nif (event->attr.config == ITLB_LOAD_MISS)\r\nreturn PERF_8xx_ID_ITLB_LOAD_MISS;\r\nif (event->attr.config == DTLB_LOAD_MISS)\r\nreturn PERF_8xx_ID_DTLB_LOAD_MISS;\r\nbreak;\r\ncase PERF_TYPE_RAW:\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int mpc8xx_pmu_event_init(struct perf_event *event)\r\n{\r\nint type = event_type(event);\r\nif (type < 0)\r\nreturn type;\r\nreturn 0;\r\n}\r\nstatic int mpc8xx_pmu_add(struct perf_event *event, int flags)\r\n{\r\nint type = event_type(event);\r\ns64 val = 0;\r\nif (type < 0)\r\nreturn type;\r\nswitch (type) {\r\ncase PERF_8xx_ID_CPU_CYCLES:\r\nval = get_tb();\r\nbreak;\r\ncase PERF_8xx_ID_HW_INSTRUCTIONS:\r\nif (atomic_inc_return(&insn_ctr_ref) == 1)\r\nmtspr(SPRN_ICTRL, 0xc0080007);\r\nval = get_insn_ctr();\r\nbreak;\r\ncase PERF_8xx_ID_ITLB_LOAD_MISS:\r\nval = itlb_miss_counter;\r\nbreak;\r\ncase PERF_8xx_ID_DTLB_LOAD_MISS:\r\nval = dtlb_miss_counter;\r\nbreak;\r\n}\r\nlocal64_set(&event->hw.prev_count, val);\r\nreturn 0;\r\n}\r\nstatic void mpc8xx_pmu_read(struct perf_event *event)\r\n{\r\nint type = event_type(event);\r\ns64 prev, val = 0, delta = 0;\r\nif (type < 0)\r\nreturn;\r\ndo {\r\nprev = local64_read(&event->hw.prev_count);\r\nswitch (type) {\r\ncase PERF_8xx_ID_CPU_CYCLES:\r\nval = get_tb();\r\ndelta = 16 * (val - prev);\r\nbreak;\r\ncase PERF_8xx_ID_HW_INSTRUCTIONS:\r\nval = get_insn_ctr();\r\ndelta = prev - val;\r\nif (delta < 0)\r\ndelta += 0x1000000000000LL;\r\nbreak;\r\ncase PERF_8xx_ID_ITLB_LOAD_MISS:\r\nval = itlb_miss_counter;\r\ndelta = (s64)((s32)val - (s32)prev);\r\nbreak;\r\ncase PERF_8xx_ID_DTLB_LOAD_MISS:\r\nval = dtlb_miss_counter;\r\ndelta = (s64)((s32)val - (s32)prev);\r\nbreak;\r\n}\r\n} while (local64_cmpxchg(&event->hw.prev_count, prev, val) != prev);\r\nlocal64_add(delta, &event->count);\r\n}\r\nstatic void mpc8xx_pmu_del(struct perf_event *event, int flags)\r\n{\r\nmpc8xx_pmu_read(event);\r\nif (event_type(event) != PERF_8xx_ID_HW_INSTRUCTIONS)\r\nreturn;\r\nif (atomic_dec_return(&insn_ctr_ref) == 0)\r\nmtspr(SPRN_ICTRL, 7);\r\n}\r\nstatic int init_mpc8xx_pmu(void)\r\n{\r\nmtspr(SPRN_ICTRL, 7);\r\nmtspr(SPRN_CMPA, 0);\r\nmtspr(SPRN_COUNTA, 0xffff);\r\nreturn perf_pmu_register(&mpc8xx_pmu, "cpu", PERF_TYPE_RAW);\r\n}
