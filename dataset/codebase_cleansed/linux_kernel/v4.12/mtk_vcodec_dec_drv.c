static void wake_up_ctx(struct mtk_vcodec_ctx *ctx)\r\n{\r\nctx->int_cond = 1;\r\nwake_up_interruptible(&ctx->queue);\r\n}\r\nstatic irqreturn_t mtk_vcodec_dec_irq_handler(int irq, void *priv)\r\n{\r\nstruct mtk_vcodec_dev *dev = priv;\r\nstruct mtk_vcodec_ctx *ctx;\r\nu32 cg_status = 0;\r\nunsigned int dec_done_status = 0;\r\nvoid __iomem *vdec_misc_addr = dev->reg_base[VDEC_MISC] +\r\nVDEC_IRQ_CFG_REG;\r\nctx = mtk_vcodec_get_curr_ctx(dev);\r\ncg_status = readl(dev->reg_base[0]);\r\nif ((cg_status & VDEC_HW_ACTIVE) != 0) {\r\nmtk_v4l2_err("DEC ISR, VDEC active is not 0x0 (0x%08x)",\r\ncg_status);\r\nreturn IRQ_HANDLED;\r\n}\r\ndec_done_status = readl(vdec_misc_addr);\r\nctx->irq_status = dec_done_status;\r\nif ((dec_done_status & MTK_VDEC_IRQ_STATUS_DEC_SUCCESS) !=\r\nMTK_VDEC_IRQ_STATUS_DEC_SUCCESS)\r\nreturn IRQ_HANDLED;\r\nwritel((readl(vdec_misc_addr) | VDEC_IRQ_CFG),\r\ndev->reg_base[VDEC_MISC] + VDEC_IRQ_CFG_REG);\r\nwritel((readl(vdec_misc_addr) & ~VDEC_IRQ_CLR),\r\ndev->reg_base[VDEC_MISC] + VDEC_IRQ_CFG_REG);\r\nwake_up_ctx(ctx);\r\nmtk_v4l2_debug(3,\r\n"mtk_vcodec_dec_irq_handler :wake up ctx %d, dec_done_status=%x",\r\nctx->id, dec_done_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mtk_vcodec_dec_reset_handler(void *priv)\r\n{\r\nstruct mtk_vcodec_dev *dev = priv;\r\nstruct mtk_vcodec_ctx *ctx;\r\nmtk_v4l2_err("Watchdog timeout!!");\r\nmutex_lock(&dev->dev_mutex);\r\nlist_for_each_entry(ctx, &dev->ctx_list, list) {\r\nctx->state = MTK_STATE_ABORT;\r\nmtk_v4l2_debug(0, "[%d] Change to state MTK_STATE_ERROR",\r\nctx->id);\r\n}\r\nmutex_unlock(&dev->dev_mutex);\r\n}\r\nstatic int fops_vcodec_open(struct file *file)\r\n{\r\nstruct mtk_vcodec_dev *dev = video_drvdata(file);\r\nstruct mtk_vcodec_ctx *ctx = NULL;\r\nstruct mtk_video_dec_buf *mtk_buf = NULL;\r\nint ret = 0;\r\nstruct vb2_queue *src_vq;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nmtk_buf = kzalloc(sizeof(*mtk_buf), GFP_KERNEL);\r\nif (!mtk_buf) {\r\nkfree(ctx);\r\nreturn -ENOMEM;\r\n}\r\nmutex_lock(&dev->dev_mutex);\r\nctx->empty_flush_buf = mtk_buf;\r\nctx->id = dev->id_counter++;\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nINIT_LIST_HEAD(&ctx->list);\r\nctx->dev = dev;\r\ninit_waitqueue_head(&ctx->queue);\r\nmutex_init(&ctx->lock);\r\nctx->type = MTK_INST_DECODER;\r\nret = mtk_vcodec_dec_ctrls_setup(ctx);\r\nif (ret) {\r\nmtk_v4l2_err("Failed to setup mt vcodec controls");\r\ngoto err_ctrls_setup;\r\n}\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(dev->m2m_dev_dec, ctx,\r\n&mtk_vcodec_dec_queue_init);\r\nif (IS_ERR((__force void *)ctx->m2m_ctx)) {\r\nret = PTR_ERR((__force void *)ctx->m2m_ctx);\r\nmtk_v4l2_err("Failed to v4l2_m2m_ctx_init() (%d)",\r\nret);\r\ngoto err_m2m_ctx_init;\r\n}\r\nsrc_vq = v4l2_m2m_get_vq(ctx->m2m_ctx,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\nctx->empty_flush_buf->vb.vb2_buf.vb2_queue = src_vq;\r\nctx->empty_flush_buf->lastframe = true;\r\nmtk_vcodec_dec_set_default_params(ctx);\r\nif (v4l2_fh_is_singular(&ctx->fh)) {\r\nmtk_vcodec_dec_pw_on(&dev->pm);\r\nret = vpu_load_firmware(dev->vpu_plat_dev);\r\nif (ret < 0) {\r\nmtk_v4l2_err("vpu_load_firmware failed!");\r\ngoto err_load_fw;\r\n}\r\ndev->dec_capability =\r\nvpu_get_vdec_hw_capa(dev->vpu_plat_dev);\r\nmtk_v4l2_debug(0, "decoder capability %x", dev->dec_capability);\r\n}\r\nlist_add(&ctx->list, &dev->ctx_list);\r\nmutex_unlock(&dev->dev_mutex);\r\nmtk_v4l2_debug(0, "%s decoder [%d]", dev_name(&dev->plat_dev->dev),\r\nctx->id);\r\nreturn ret;\r\nerr_load_fw:\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nerr_m2m_ctx_init:\r\nv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\r\nerr_ctrls_setup:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx->empty_flush_buf);\r\nkfree(ctx);\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn ret;\r\n}\r\nstatic int fops_vcodec_release(struct file *file)\r\n{\r\nstruct mtk_vcodec_dev *dev = video_drvdata(file);\r\nstruct mtk_vcodec_ctx *ctx = fh_to_ctx(file->private_data);\r\nmtk_v4l2_debug(0, "[%d] decoder", ctx->id);\r\nmutex_lock(&dev->dev_mutex);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nmtk_vcodec_dec_release(ctx);\r\nif (v4l2_fh_is_singular(&ctx->fh))\r\nmtk_vcodec_dec_pw_off(&dev->pm);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_hdl);\r\nlist_del_init(&ctx->list);\r\nkfree(ctx->empty_flush_buf);\r\nkfree(ctx);\r\nmutex_unlock(&dev->dev_mutex);\r\nreturn 0;\r\n}\r\nstatic int mtk_vcodec_probe(struct platform_device *pdev)\r\n{\r\nstruct mtk_vcodec_dev *dev;\r\nstruct video_device *vfd_dec;\r\nstruct resource *res;\r\nint i, ret;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nINIT_LIST_HEAD(&dev->ctx_list);\r\ndev->plat_dev = pdev;\r\ndev->vpu_plat_dev = vpu_get_plat_device(dev->plat_dev);\r\nif (dev->vpu_plat_dev == NULL) {\r\nmtk_v4l2_err("[VPU] vpu device in not ready");\r\nreturn -EPROBE_DEFER;\r\n}\r\nvpu_wdt_reg_handler(dev->vpu_plat_dev, mtk_vcodec_dec_reset_handler,\r\ndev, VPU_RST_DEC);\r\nret = mtk_vcodec_init_dec_pm(dev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get mt vcodec clock source");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < NUM_MAX_VDEC_REG_BASE; i++) {\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "get memory resource failed.");\r\nret = -ENXIO;\r\ngoto err_res;\r\n}\r\ndev->reg_base[i] = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR((__force void *)dev->reg_base[i])) {\r\nret = PTR_ERR((__force void *)dev->reg_base[i]);\r\ngoto err_res;\r\n}\r\nmtk_v4l2_debug(2, "reg[%d] base=%p", i, dev->reg_base[i]);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (res == NULL) {\r\ndev_err(&pdev->dev, "failed to get irq resource");\r\nret = -ENOENT;\r\ngoto err_res;\r\n}\r\ndev->dec_irq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(&pdev->dev, dev->dec_irq,\r\nmtk_vcodec_dec_irq_handler, 0, pdev->name, dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to install dev->dec_irq %d (%d)",\r\ndev->dec_irq,\r\nret);\r\ngoto err_res;\r\n}\r\ndisable_irq(dev->dec_irq);\r\nmutex_init(&dev->dec_mutex);\r\nmutex_init(&dev->dev_mutex);\r\nspin_lock_init(&dev->irqlock);\r\nsnprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name), "%s",\r\n"[/MTK_V4L2_VDEC]");\r\nret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);\r\nif (ret) {\r\nmtk_v4l2_err("v4l2_device_register err=%d", ret);\r\ngoto err_res;\r\n}\r\ninit_waitqueue_head(&dev->queue);\r\nvfd_dec = video_device_alloc();\r\nif (!vfd_dec) {\r\nmtk_v4l2_err("Failed to allocate video device");\r\nret = -ENOMEM;\r\ngoto err_dec_alloc;\r\n}\r\nvfd_dec->fops = &mtk_vcodec_fops;\r\nvfd_dec->ioctl_ops = &mtk_vdec_ioctl_ops;\r\nvfd_dec->release = video_device_release;\r\nvfd_dec->lock = &dev->dev_mutex;\r\nvfd_dec->v4l2_dev = &dev->v4l2_dev;\r\nvfd_dec->vfl_dir = VFL_DIR_M2M;\r\nvfd_dec->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE |\r\nV4L2_CAP_STREAMING;\r\nsnprintf(vfd_dec->name, sizeof(vfd_dec->name), "%s",\r\nMTK_VCODEC_DEC_NAME);\r\nvideo_set_drvdata(vfd_dec, dev);\r\ndev->vfd_dec = vfd_dec;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->m2m_dev_dec = v4l2_m2m_init(&mtk_vdec_m2m_ops);\r\nif (IS_ERR((__force void *)dev->m2m_dev_dec)) {\r\nmtk_v4l2_err("Failed to init mem2mem dec device");\r\nret = PTR_ERR((__force void *)dev->m2m_dev_dec);\r\ngoto err_dec_mem_init;\r\n}\r\ndev->decode_workqueue =\r\nalloc_ordered_workqueue(MTK_VCODEC_DEC_NAME,\r\nWQ_MEM_RECLAIM | WQ_FREEZABLE);\r\nif (!dev->decode_workqueue) {\r\nmtk_v4l2_err("Failed to create decode workqueue");\r\nret = -EINVAL;\r\ngoto err_event_workq;\r\n}\r\nret = video_register_device(vfd_dec, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nmtk_v4l2_err("Failed to register video device");\r\ngoto err_dec_reg;\r\n}\r\nmtk_v4l2_debug(0, "decoder registered as /dev/video%d",\r\nvfd_dec->num);\r\nreturn 0;\r\nerr_dec_reg:\r\ndestroy_workqueue(dev->decode_workqueue);\r\nerr_event_workq:\r\nv4l2_m2m_release(dev->m2m_dev_dec);\r\nerr_dec_mem_init:\r\nvideo_unregister_device(vfd_dec);\r\nerr_dec_alloc:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_res:\r\nmtk_vcodec_release_dec_pm(dev);\r\nreturn ret;\r\n}\r\nstatic int mtk_vcodec_dec_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_vcodec_dev *dev = platform_get_drvdata(pdev);\r\nflush_workqueue(dev->decode_workqueue);\r\ndestroy_workqueue(dev->decode_workqueue);\r\nif (dev->m2m_dev_dec)\r\nv4l2_m2m_release(dev->m2m_dev_dec);\r\nif (dev->vfd_dec)\r\nvideo_unregister_device(dev->vfd_dec);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nmtk_vcodec_release_dec_pm(dev);\r\nreturn 0;\r\n}
