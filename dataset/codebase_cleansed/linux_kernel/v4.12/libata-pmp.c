static unsigned int sata_pmp_read(struct ata_link *link, int reg, u32 *r_val)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *pmp_dev = ap->link.device;\r\nstruct ata_taskfile tf;\r\nunsigned int err_mask;\r\nata_tf_init(pmp_dev, &tf);\r\ntf.command = ATA_CMD_PMP_READ;\r\ntf.protocol = ATA_PROT_NODATA;\r\ntf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\r\ntf.feature = reg;\r\ntf.device = link->pmp;\r\nerr_mask = ata_exec_internal(pmp_dev, &tf, NULL, DMA_NONE, NULL, 0,\r\nSATA_PMP_RW_TIMEOUT);\r\nif (err_mask)\r\nreturn err_mask;\r\n*r_val = tf.nsect | tf.lbal << 8 | tf.lbam << 16 | tf.lbah << 24;\r\nreturn 0;\r\n}\r\nstatic unsigned int sata_pmp_write(struct ata_link *link, int reg, u32 val)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_device *pmp_dev = ap->link.device;\r\nstruct ata_taskfile tf;\r\nata_tf_init(pmp_dev, &tf);\r\ntf.command = ATA_CMD_PMP_WRITE;\r\ntf.protocol = ATA_PROT_NODATA;\r\ntf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48;\r\ntf.feature = reg;\r\ntf.device = link->pmp;\r\ntf.nsect = val & 0xff;\r\ntf.lbal = (val >> 8) & 0xff;\r\ntf.lbam = (val >> 16) & 0xff;\r\ntf.lbah = (val >> 24) & 0xff;\r\nreturn ata_exec_internal(pmp_dev, &tf, NULL, DMA_NONE, NULL, 0,\r\nSATA_PMP_RW_TIMEOUT);\r\n}\r\nint sata_pmp_qc_defer_cmd_switch(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_link *link = qc->dev->link;\r\nstruct ata_port *ap = link->ap;\r\nif (ap->excl_link == NULL || ap->excl_link == link) {\r\nif (ap->nr_active_links == 0 || ata_link_active(link)) {\r\nqc->flags |= ATA_QCFLAG_CLEAR_EXCL;\r\nreturn ata_std_qc_defer(qc);\r\n}\r\nap->excl_link = link;\r\n}\r\nreturn ATA_DEFER_PORT;\r\n}\r\nint sata_pmp_scr_read(struct ata_link *link, int reg, u32 *r_val)\r\n{\r\nunsigned int err_mask;\r\nif (reg > SATA_PMP_PSCR_CONTROL)\r\nreturn -EINVAL;\r\nerr_mask = sata_pmp_read(link, reg, r_val);\r\nif (err_mask) {\r\nata_link_warn(link, "failed to read SCR %d (Emask=0x%x)\n",\r\nreg, err_mask);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint sata_pmp_scr_write(struct ata_link *link, int reg, u32 val)\r\n{\r\nunsigned int err_mask;\r\nif (reg > SATA_PMP_PSCR_CONTROL)\r\nreturn -EINVAL;\r\nerr_mask = sata_pmp_write(link, reg, val);\r\nif (err_mask) {\r\nata_link_warn(link, "failed to write SCR %d (Emask=0x%x)\n",\r\nreg, err_mask);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint sata_pmp_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,\r\nunsigned hints)\r\n{\r\nreturn sata_link_scr_lpm(link, policy, true);\r\n}\r\nstatic int sata_pmp_read_gscr(struct ata_device *dev, u32 *gscr)\r\n{\r\nstatic const int gscr_to_read[] = { 0, 1, 2, 32, 33, 64, 96 };\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(gscr_to_read); i++) {\r\nint reg = gscr_to_read[i];\r\nunsigned int err_mask;\r\nerr_mask = sata_pmp_read(dev->link, reg, &gscr[reg]);\r\nif (err_mask) {\r\nata_dev_err(dev, "failed to read PMP GSCR[%d] (Emask=0x%x)\n",\r\nreg, err_mask);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic const char *sata_pmp_spec_rev_str(const u32 *gscr)\r\n{\r\nu32 rev = gscr[SATA_PMP_GSCR_REV];\r\nif (rev & (1 << 3))\r\nreturn "1.2";\r\nif (rev & (1 << 2))\r\nreturn "1.1";\r\nif (rev & (1 << 1))\r\nreturn "1.0";\r\nreturn "<unknown>";\r\n}\r\nstatic int sata_pmp_configure(struct ata_device *dev, int print_info)\r\n{\r\nstruct ata_port *ap = dev->link->ap;\r\nu32 *gscr = dev->gscr;\r\nu16 vendor = sata_pmp_gscr_vendor(gscr);\r\nu16 devid = sata_pmp_gscr_devid(gscr);\r\nunsigned int err_mask = 0;\r\nconst char *reason;\r\nint nr_ports, rc;\r\nnr_ports = sata_pmp_gscr_ports(gscr);\r\nif (nr_ports <= 0 || nr_ports > SATA_PMP_MAX_PORTS) {\r\nrc = -EINVAL;\r\nreason = "invalid nr_ports";\r\ngoto fail;\r\n}\r\nif ((ap->flags & ATA_FLAG_AN) &&\r\n(gscr[SATA_PMP_GSCR_FEAT] & SATA_PMP_FEAT_NOTIFY))\r\ndev->flags |= ATA_DFLAG_AN;\r\nerr_mask = sata_pmp_write(dev->link, SATA_PMP_GSCR_ERROR_EN,\r\nSERR_PHYRDY_CHG);\r\nif (err_mask) {\r\nrc = -EIO;\r\nreason = "failed to write GSCR_ERROR_EN";\r\ngoto fail;\r\n}\r\nif (vendor == 0x1095 && (devid == 0x3726 || devid == 0x3826)) {\r\nu32 reg;\r\nerr_mask = sata_pmp_read(&ap->link, PMP_GSCR_SII_POL, &reg);\r\nif (err_mask) {\r\nrc = -EIO;\r\nreason = "failed to read Sil3x26 Private Register";\r\ngoto fail;\r\n}\r\nreg &= ~0x1;\r\nerr_mask = sata_pmp_write(&ap->link, PMP_GSCR_SII_POL, reg);\r\nif (err_mask) {\r\nrc = -EIO;\r\nreason = "failed to write Sil3x26 Private Register";\r\ngoto fail;\r\n}\r\n}\r\nif (print_info) {\r\nata_dev_info(dev, "Port Multiplier %s, "\r\n"0x%04x:0x%04x r%d, %d ports, feat 0x%x/0x%x\n",\r\nsata_pmp_spec_rev_str(gscr), vendor, devid,\r\nsata_pmp_gscr_rev(gscr),\r\nnr_ports, gscr[SATA_PMP_GSCR_FEAT_EN],\r\ngscr[SATA_PMP_GSCR_FEAT]);\r\nif (!(dev->flags & ATA_DFLAG_AN))\r\nata_dev_info(dev,\r\n"Asynchronous notification not supported, "\r\n"hotplug won't work on fan-out ports. Use warm-plug instead.\n");\r\n}\r\nreturn 0;\r\nfail:\r\nata_dev_err(dev,\r\n"failed to configure Port Multiplier (%s, Emask=0x%x)\n",\r\nreason, err_mask);\r\nreturn rc;\r\n}\r\nstatic int sata_pmp_init_links (struct ata_port *ap, int nr_ports)\r\n{\r\nstruct ata_link *pmp_link = ap->pmp_link;\r\nint i, err;\r\nif (!pmp_link) {\r\npmp_link = kzalloc(sizeof(pmp_link[0]) * SATA_PMP_MAX_PORTS,\r\nGFP_NOIO);\r\nif (!pmp_link)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < SATA_PMP_MAX_PORTS; i++)\r\nata_link_init(ap, &pmp_link[i], i);\r\nap->pmp_link = pmp_link;\r\nfor (i = 0; i < SATA_PMP_MAX_PORTS; i++) {\r\nerr = ata_tlink_add(&pmp_link[i]);\r\nif (err) {\r\ngoto err_tlink;\r\n}\r\n}\r\n}\r\nfor (i = 0; i < nr_ports; i++) {\r\nstruct ata_link *link = &pmp_link[i];\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nlink->flags = 0;\r\nehc->i.probe_mask |= ATA_ALL_DEVICES;\r\nehc->i.action |= ATA_EH_RESET;\r\n}\r\nreturn 0;\r\nerr_tlink:\r\nwhile (--i >= 0)\r\nata_tlink_delete(&pmp_link[i]);\r\nkfree(pmp_link);\r\nap->pmp_link = NULL;\r\nreturn err;\r\n}\r\nstatic void sata_pmp_quirks(struct ata_port *ap)\r\n{\r\nu32 *gscr = ap->link.device->gscr;\r\nu16 vendor = sata_pmp_gscr_vendor(gscr);\r\nu16 devid = sata_pmp_gscr_devid(gscr);\r\nstruct ata_link *link;\r\nif (vendor == 0x1095 && (devid == 0x3726 || devid == 0x3826)) {\r\nata_for_each_link(link, ap, EDGE) {\r\nlink->flags |= ATA_LFLAG_NO_LPM;\r\nif (link->pmp < 5)\r\nlink->flags |= ATA_LFLAG_NO_SRST |\r\nATA_LFLAG_ASSUME_ATA;\r\nif (link->pmp == 5)\r\nlink->flags |= ATA_LFLAG_NO_SRST |\r\nATA_LFLAG_ASSUME_SEMB;\r\n}\r\n} else if (vendor == 0x1095 && devid == 0x4723) {\r\nata_for_each_link(link, ap, EDGE)\r\nlink->flags |= ATA_LFLAG_NO_LPM |\r\nATA_LFLAG_NO_SRST |\r\nATA_LFLAG_ASSUME_ATA;\r\n} else if (vendor == 0x1095 && devid == 0x4726) {\r\nata_for_each_link(link, ap, EDGE) {\r\nlink->flags |= ATA_LFLAG_NO_LPM;\r\nif (link->pmp <= 5)\r\nlink->flags |= ATA_LFLAG_NO_SRST |\r\nATA_LFLAG_ASSUME_ATA;\r\nif (link->pmp == 6)\r\nlink->flags |= ATA_LFLAG_NO_SRST |\r\nATA_LFLAG_ASSUME_SEMB;\r\n}\r\n} else if (vendor == 0x1095 && (devid == 0x5723 || devid == 0x5733 ||\r\ndevid == 0x5734 || devid == 0x5744)) {\r\nap->pmp_link[ap->nr_pmp_links - 1].flags |= ATA_LFLAG_NO_RETRY;\r\n} else if (vendor == 0x197b && (devid == 0x2352 || devid == 0x0325)) {\r\nata_for_each_link(link, ap, EDGE) {\r\nlink->flags |= ATA_LFLAG_NO_LPM |\r\nATA_LFLAG_NO_SRST |\r\nATA_LFLAG_ASSUME_ATA;\r\n}\r\n} else if (vendor == 0x11ab && devid == 0x4140) {\r\nata_for_each_link(link, ap, EDGE) {\r\nif (link->pmp == 4)\r\nlink->flags |= ATA_LFLAG_DISABLED;\r\n}\r\n}\r\n}\r\nint sata_pmp_attach(struct ata_device *dev)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nunsigned long flags;\r\nstruct ata_link *tlink;\r\nint rc;\r\nif (!sata_pmp_supported(ap)) {\r\nata_dev_err(dev, "host does not support Port Multiplier\n");\r\nreturn -EINVAL;\r\n}\r\nif (!ata_is_host_link(link)) {\r\nata_dev_err(dev, "Port Multipliers cannot be nested\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev->devno) {\r\nata_dev_err(dev, "Port Multiplier must be the first device\n");\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(link->pmp != 0);\r\nlink->pmp = SATA_PMP_CTRL_PORT;\r\nrc = sata_pmp_read_gscr(dev, dev->gscr);\r\nif (rc)\r\ngoto fail;\r\nrc = sata_pmp_configure(dev, 1);\r\nif (rc)\r\ngoto fail;\r\nrc = sata_pmp_init_links(ap, sata_pmp_gscr_ports(dev->gscr));\r\nif (rc) {\r\nata_dev_info(dev, "failed to initialize PMP links\n");\r\ngoto fail;\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\nWARN_ON(ap->nr_pmp_links);\r\nap->nr_pmp_links = sata_pmp_gscr_ports(dev->gscr);\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nsata_pmp_quirks(ap);\r\nif (ap->ops->pmp_attach)\r\nap->ops->pmp_attach(ap);\r\nata_for_each_link(tlink, ap, EDGE)\r\nsata_link_init_spd(tlink);\r\nreturn 0;\r\nfail:\r\nlink->pmp = 0;\r\nreturn rc;\r\n}\r\nstatic void sata_pmp_detach(struct ata_device *dev)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_link *tlink;\r\nunsigned long flags;\r\nata_dev_info(dev, "Port Multiplier detaching\n");\r\nWARN_ON(!ata_is_host_link(link) || dev->devno ||\r\nlink->pmp != SATA_PMP_CTRL_PORT);\r\nif (ap->ops->pmp_detach)\r\nap->ops->pmp_detach(ap);\r\nata_for_each_link(tlink, ap, EDGE)\r\nata_eh_detach_dev(tlink->device);\r\nspin_lock_irqsave(ap->lock, flags);\r\nap->nr_pmp_links = 0;\r\nlink->pmp = 0;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nstatic int sata_pmp_same_pmp(struct ata_device *dev, const u32 *new_gscr)\r\n{\r\nconst u32 *old_gscr = dev->gscr;\r\nu16 old_vendor, new_vendor, old_devid, new_devid;\r\nint old_nr_ports, new_nr_ports;\r\nold_vendor = sata_pmp_gscr_vendor(old_gscr);\r\nnew_vendor = sata_pmp_gscr_vendor(new_gscr);\r\nold_devid = sata_pmp_gscr_devid(old_gscr);\r\nnew_devid = sata_pmp_gscr_devid(new_gscr);\r\nold_nr_ports = sata_pmp_gscr_ports(old_gscr);\r\nnew_nr_ports = sata_pmp_gscr_ports(new_gscr);\r\nif (old_vendor != new_vendor) {\r\nata_dev_info(dev,\r\n"Port Multiplier vendor mismatch '0x%x' != '0x%x'\n",\r\nold_vendor, new_vendor);\r\nreturn 0;\r\n}\r\nif (old_devid != new_devid) {\r\nata_dev_info(dev,\r\n"Port Multiplier device ID mismatch '0x%x' != '0x%x'\n",\r\nold_devid, new_devid);\r\nreturn 0;\r\n}\r\nif (old_nr_ports != new_nr_ports) {\r\nata_dev_info(dev,\r\n"Port Multiplier nr_ports mismatch '0x%x' != '0x%x'\n",\r\nold_nr_ports, new_nr_ports);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int sata_pmp_revalidate(struct ata_device *dev, unsigned int new_class)\r\n{\r\nstruct ata_link *link = dev->link;\r\nstruct ata_port *ap = link->ap;\r\nu32 *gscr = (void *)ap->sector_buf;\r\nint rc;\r\nDPRINTK("ENTER\n");\r\nata_eh_about_to_do(link, NULL, ATA_EH_REVALIDATE);\r\nif (!ata_dev_enabled(dev)) {\r\nrc = -ENODEV;\r\ngoto fail;\r\n}\r\nif (ata_class_enabled(new_class) && new_class != ATA_DEV_PMP) {\r\nrc = -ENODEV;\r\ngoto fail;\r\n}\r\nrc = sata_pmp_read_gscr(dev, gscr);\r\nif (rc)\r\ngoto fail;\r\nif (!sata_pmp_same_pmp(dev, gscr)) {\r\nrc = -ENODEV;\r\ngoto fail;\r\n}\r\nmemcpy(dev->gscr, gscr, sizeof(gscr[0]) * SATA_PMP_GSCR_DWORDS);\r\nrc = sata_pmp_configure(dev, 0);\r\nif (rc)\r\ngoto fail;\r\nata_eh_done(link, NULL, ATA_EH_REVALIDATE);\r\nDPRINTK("EXIT, rc=0\n");\r\nreturn 0;\r\nfail:\r\nata_dev_err(dev, "PMP revalidation failed (errno=%d)\n", rc);\r\nDPRINTK("EXIT, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int sata_pmp_revalidate_quick(struct ata_device *dev)\r\n{\r\nunsigned int err_mask;\r\nu32 prod_id;\r\nerr_mask = sata_pmp_read(dev->link, SATA_PMP_GSCR_PROD_ID, &prod_id);\r\nif (err_mask) {\r\nata_dev_err(dev,\r\n"failed to read PMP product ID (Emask=0x%x)\n",\r\nerr_mask);\r\nreturn -EIO;\r\n}\r\nif (prod_id != dev->gscr[SATA_PMP_GSCR_PROD_ID]) {\r\nata_dev_err(dev, "PMP product ID mismatch\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sata_pmp_eh_recover_pmp(struct ata_port *ap,\r\nata_prereset_fn_t prereset, ata_reset_fn_t softreset,\r\nata_reset_fn_t hardreset, ata_postreset_fn_t postreset)\r\n{\r\nstruct ata_link *link = &ap->link;\r\nstruct ata_eh_context *ehc = &link->eh_context;\r\nstruct ata_device *dev = link->device;\r\nint tries = ATA_EH_PMP_TRIES;\r\nint detach = 0, rc = 0;\r\nint reval_failed = 0;\r\nDPRINTK("ENTER\n");\r\nif (dev->flags & ATA_DFLAG_DETACH) {\r\ndetach = 1;\r\ngoto fail;\r\n}\r\nretry:\r\nehc->classes[0] = ATA_DEV_UNKNOWN;\r\nif (ehc->i.action & ATA_EH_RESET) {\r\nstruct ata_link *tlink;\r\nrc = ata_eh_reset(link, 0, prereset, softreset, hardreset,\r\npostreset);\r\nif (rc) {\r\nata_link_err(link, "failed to reset PMP, giving up\n");\r\ngoto fail;\r\n}\r\nata_for_each_link(tlink, ap, EDGE) {\r\nstruct ata_eh_context *ehc = &tlink->eh_context;\r\nehc->i.probe_mask |= ATA_ALL_DEVICES;\r\nehc->i.action |= ATA_EH_RESET;\r\n}\r\n}\r\nif (ehc->i.action & ATA_EH_REVALIDATE)\r\nrc = sata_pmp_revalidate(dev, ehc->classes[0]);\r\nelse\r\nrc = sata_pmp_revalidate_quick(dev);\r\nif (rc) {\r\ntries--;\r\nif (rc == -ENODEV) {\r\nehc->i.probe_mask |= ATA_ALL_DEVICES;\r\ndetach = 1;\r\ntries = min(tries, 2);\r\n}\r\nif (tries) {\r\nif (reval_failed)\r\nsata_down_spd_limit(link, 0);\r\nelse\r\nreval_failed = 1;\r\nehc->i.action |= ATA_EH_RESET;\r\ngoto retry;\r\n} else {\r\nata_dev_err(dev,\r\n"failed to recover PMP after %d tries, giving up\n",\r\nATA_EH_PMP_TRIES);\r\ngoto fail;\r\n}\r\n}\r\nehc->i.flags = 0;\r\nDPRINTK("EXIT, rc=0\n");\r\nreturn 0;\r\nfail:\r\nsata_pmp_detach(dev);\r\nif (detach)\r\nata_eh_detach_dev(dev);\r\nelse\r\nata_dev_disable(dev);\r\nDPRINTK("EXIT, rc=%d\n", rc);\r\nreturn rc;\r\n}\r\nstatic int sata_pmp_eh_handle_disabled_links(struct ata_port *ap)\r\n{\r\nstruct ata_link *link;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(ap->lock, flags);\r\nata_for_each_link(link, ap, EDGE) {\r\nif (!(link->flags & ATA_LFLAG_DISABLED))\r\ncontinue;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nsata_link_hardreset(link, sata_deb_timing_normal,\r\nata_deadline(jiffies, ATA_TMOUT_INTERNAL_QUICK),\r\nNULL, NULL);\r\nrc = sata_scr_write(link, SCR_ERROR, SERR_PHYRDY_CHG);\r\nif (rc) {\r\nata_link_err(link,\r\n"failed to clear SError.N (errno=%d)\n",\r\nrc);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(ap->lock, flags);\r\n}\r\nspin_unlock_irqrestore(ap->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sata_pmp_handle_link_fail(struct ata_link *link, int *link_tries)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nunsigned long flags;\r\nif (link_tries[link->pmp] && --link_tries[link->pmp])\r\nreturn 1;\r\nif (!(link->flags & ATA_LFLAG_DISABLED)) {\r\nata_link_warn(link,\r\n"failed to recover link after %d tries, disabling\n",\r\nATA_EH_PMP_LINK_TRIES);\r\nspin_lock_irqsave(ap->lock, flags);\r\nlink->flags |= ATA_LFLAG_DISABLED;\r\nspin_unlock_irqrestore(ap->lock, flags);\r\n}\r\nata_dev_disable(link->device);\r\nlink->eh_context.i.action = 0;\r\nreturn 0;\r\n}\r\nstatic int sata_pmp_eh_recover(struct ata_port *ap)\r\n{\r\nstruct ata_port_operations *ops = ap->ops;\r\nint pmp_tries, link_tries[SATA_PMP_MAX_PORTS];\r\nstruct ata_link *pmp_link = &ap->link;\r\nstruct ata_device *pmp_dev = pmp_link->device;\r\nstruct ata_eh_context *pmp_ehc = &pmp_link->eh_context;\r\nu32 *gscr = pmp_dev->gscr;\r\nstruct ata_link *link;\r\nstruct ata_device *dev;\r\nunsigned int err_mask;\r\nu32 gscr_error, sntf;\r\nint cnt, rc;\r\npmp_tries = ATA_EH_PMP_TRIES;\r\nata_for_each_link(link, ap, EDGE)\r\nlink_tries[link->pmp] = ATA_EH_PMP_LINK_TRIES;\r\nretry:\r\nif (!sata_pmp_attached(ap)) {\r\nrc = ata_eh_recover(ap, ops->prereset, ops->softreset,\r\nops->hardreset, ops->postreset, NULL);\r\nif (rc) {\r\nata_for_each_dev(dev, &ap->link, ALL)\r\nata_dev_disable(dev);\r\nreturn rc;\r\n}\r\nif (pmp_dev->class != ATA_DEV_PMP)\r\nreturn 0;\r\nata_for_each_link(link, ap, EDGE)\r\nlink_tries[link->pmp] = ATA_EH_PMP_LINK_TRIES;\r\n}\r\nrc = sata_pmp_eh_recover_pmp(ap, ops->prereset, ops->softreset,\r\nops->hardreset, ops->postreset);\r\nif (rc)\r\ngoto pmp_fail;\r\nif (gscr[SATA_PMP_GSCR_FEAT_EN] & SATA_PMP_FEAT_NOTIFY) {\r\ngscr[SATA_PMP_GSCR_FEAT_EN] &= ~SATA_PMP_FEAT_NOTIFY;\r\nerr_mask = sata_pmp_write(pmp_link, SATA_PMP_GSCR_FEAT_EN,\r\ngscr[SATA_PMP_GSCR_FEAT_EN]);\r\nif (err_mask) {\r\nata_link_warn(pmp_link,\r\n"failed to disable NOTIFY (err_mask=0x%x)\n",\r\nerr_mask);\r\ngoto pmp_fail;\r\n}\r\n}\r\nrc = sata_pmp_eh_handle_disabled_links(ap);\r\nif (rc)\r\ngoto pmp_fail;\r\nrc = ata_eh_recover(ap, ops->pmp_prereset, ops->pmp_softreset,\r\nops->pmp_hardreset, ops->pmp_postreset, &link);\r\nif (rc)\r\ngoto link_fail;\r\nrc = sata_scr_read(&ap->link, SCR_NOTIFICATION, &sntf);\r\nif (rc == 0)\r\nsata_scr_write(&ap->link, SCR_NOTIFICATION, sntf);\r\nata_for_each_link(link, ap, EDGE)\r\nif (link->lpm_policy > ATA_LPM_MAX_POWER)\r\nreturn 0;\r\nif (pmp_dev->flags & ATA_DFLAG_AN) {\r\ngscr[SATA_PMP_GSCR_FEAT_EN] |= SATA_PMP_FEAT_NOTIFY;\r\nerr_mask = sata_pmp_write(pmp_link, SATA_PMP_GSCR_FEAT_EN,\r\ngscr[SATA_PMP_GSCR_FEAT_EN]);\r\nif (err_mask) {\r\nata_dev_err(pmp_dev,\r\n"failed to write PMP_FEAT_EN (Emask=0x%x)\n",\r\nerr_mask);\r\nrc = -EIO;\r\ngoto pmp_fail;\r\n}\r\n}\r\nerr_mask = sata_pmp_read(pmp_link, SATA_PMP_GSCR_ERROR, &gscr_error);\r\nif (err_mask) {\r\nata_dev_err(pmp_dev,\r\n"failed to read PMP_GSCR_ERROR (Emask=0x%x)\n",\r\nerr_mask);\r\nrc = -EIO;\r\ngoto pmp_fail;\r\n}\r\ncnt = 0;\r\nata_for_each_link(link, ap, EDGE) {\r\nif (!(gscr_error & (1 << link->pmp)))\r\ncontinue;\r\nif (sata_pmp_handle_link_fail(link, link_tries)) {\r\nata_ehi_hotplugged(&link->eh_context.i);\r\ncnt++;\r\n} else {\r\nata_link_warn(link,\r\n"PHY status changed but maxed out on retries, giving up\n");\r\nata_link_warn(link,\r\n"Manually issue scan to resume this link\n");\r\n}\r\n}\r\nif (cnt) {\r\nata_port_info(ap,\r\n"PMP SError.N set for some ports, repeating recovery\n");\r\ngoto retry;\r\n}\r\nreturn 0;\r\nlink_fail:\r\nif (sata_pmp_handle_link_fail(link, link_tries)) {\r\npmp_ehc->i.action |= ATA_EH_RESET;\r\ngoto retry;\r\n}\r\npmp_fail:\r\nif (ap->pflags & ATA_PFLAG_UNLOADING)\r\nreturn rc;\r\nif (!sata_pmp_attached(ap))\r\ngoto retry;\r\nif (--pmp_tries) {\r\npmp_ehc->i.action |= ATA_EH_RESET;\r\ngoto retry;\r\n}\r\nata_port_err(ap, "failed to recover PMP after %d tries, giving up\n",\r\nATA_EH_PMP_TRIES);\r\nsata_pmp_detach(pmp_dev);\r\nata_dev_disable(pmp_dev);\r\nreturn rc;\r\n}\r\nvoid sata_pmp_error_handler(struct ata_port *ap)\r\n{\r\nata_eh_autopsy(ap);\r\nata_eh_report(ap);\r\nsata_pmp_eh_recover(ap);\r\nata_eh_finish(ap);\r\n}
