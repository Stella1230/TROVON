static void fw_req_release(struct kref *kref)\r\n{\r\nstruct fw_request *fw_req = container_of(kref, struct fw_request, kref);\r\ndev_dbg(fw_req->fw_download->parent, "firmware %s released\n",\r\nfw_req->name);\r\nrelease_firmware(fw_req->fw);\r\nif (!fw_req->timedout)\r\nida_simple_remove(&fw_req->fw_download->id_map,\r\nfw_req->firmware_id);\r\nkfree(fw_req);\r\n}\r\nstatic void put_fw_req(struct fw_request *fw_req)\r\n{\r\nkref_put(&fw_req->kref, fw_req_release);\r\n}\r\nstatic struct fw_request *get_fw_req(struct fw_download *fw_download,\r\nu8 firmware_id)\r\n{\r\nstruct fw_request *fw_req;\r\nmutex_lock(&fw_download->mutex);\r\nlist_for_each_entry(fw_req, &fw_download->fw_requests, node) {\r\nif (fw_req->firmware_id == firmware_id) {\r\nkref_get(&fw_req->kref);\r\ngoto unlock;\r\n}\r\n}\r\nfw_req = NULL;\r\nunlock:\r\nmutex_unlock(&fw_download->mutex);\r\nreturn fw_req;\r\n}\r\nstatic void free_firmware(struct fw_download *fw_download,\r\nstruct fw_request *fw_req)\r\n{\r\nif (fw_req->disabled)\r\nreturn;\r\nmutex_lock(&fw_download->mutex);\r\nlist_del(&fw_req->node);\r\nmutex_unlock(&fw_download->mutex);\r\nfw_req->disabled = true;\r\nput_fw_req(fw_req);\r\n}\r\nstatic void fw_request_timedout(struct work_struct *work)\r\n{\r\nstruct delayed_work *dwork = to_delayed_work(work);\r\nstruct fw_request *fw_req = container_of(dwork,\r\nstruct fw_request, dwork);\r\nstruct fw_download *fw_download = fw_req->fw_download;\r\ndev_err(fw_download->parent,\r\n"Timed out waiting for fetch / release firmware requests: %u\n",\r\nfw_req->firmware_id);\r\nfw_req->timedout = true;\r\nfree_firmware(fw_download, fw_req);\r\n}\r\nstatic int exceeds_release_timeout(struct fw_request *fw_req)\r\n{\r\nstruct fw_download *fw_download = fw_req->fw_download;\r\nif (time_before(jiffies, fw_req->release_timeout_j))\r\nreturn 0;\r\ndev_err(fw_download->parent,\r\n"Firmware download didn't finish in time, abort: %d\n",\r\nfw_req->firmware_id);\r\nfw_req->timedout = true;\r\nfree_firmware(fw_download, fw_req);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic struct fw_request *find_firmware(struct fw_download *fw_download,\r\nconst char *tag)\r\n{\r\nstruct gb_interface *intf = fw_download->connection->bundle->intf;\r\nstruct fw_request *fw_req;\r\nint ret, req_count;\r\nfw_req = kzalloc(sizeof(*fw_req), GFP_KERNEL);\r\nif (!fw_req)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = ida_simple_get(&fw_download->id_map, 1, 256, GFP_KERNEL);\r\nif (ret < 0) {\r\ndev_err(fw_download->parent,\r\n"failed to allocate firmware id (%d)\n", ret);\r\ngoto err_free_req;\r\n}\r\nfw_req->firmware_id = ret;\r\nsnprintf(fw_req->name, sizeof(fw_req->name),\r\nFW_NAME_PREFIX "%08x_%08x_%08x_%08x_%s.tftf",\r\nintf->ddbl1_manufacturer_id, intf->ddbl1_product_id,\r\nintf->vendor_id, intf->product_id, tag);\r\ndev_info(fw_download->parent, "Requested firmware package '%s'\n",\r\nfw_req->name);\r\nret = request_firmware(&fw_req->fw, fw_req->name, fw_download->parent);\r\nif (ret) {\r\ndev_err(fw_download->parent,\r\n"firmware request failed for %s (%d)\n", fw_req->name,\r\nret);\r\ngoto err_free_id;\r\n}\r\nfw_req->fw_download = fw_download;\r\nkref_init(&fw_req->kref);\r\nmutex_lock(&fw_download->mutex);\r\nlist_add(&fw_req->node, &fw_download->fw_requests);\r\nmutex_unlock(&fw_download->mutex);\r\nreq_count = DIV_ROUND_UP(fw_req->fw->size, MIN_FETCH_SIZE);\r\nfw_req->release_timeout_j = jiffies + req_count * NEXT_REQ_TIMEOUT_J;\r\nINIT_DELAYED_WORK(&fw_req->dwork, fw_request_timedout);\r\nschedule_delayed_work(&fw_req->dwork, NEXT_REQ_TIMEOUT_J);\r\nreturn fw_req;\r\nerr_free_id:\r\nida_simple_remove(&fw_download->id_map, fw_req->firmware_id);\r\nerr_free_req:\r\nkfree(fw_req);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int fw_download_find_firmware(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct fw_download *fw_download = gb_connection_get_data(connection);\r\nstruct gb_fw_download_find_firmware_request *request;\r\nstruct gb_fw_download_find_firmware_response *response;\r\nstruct fw_request *fw_req;\r\nconst char *tag;\r\nif (op->request->payload_size != sizeof(*request)) {\r\ndev_err(fw_download->parent,\r\n"illegal size of find firmware request (%zu != %zu)\n",\r\nop->request->payload_size, sizeof(*request));\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request->payload;\r\ntag = (const char *)request->firmware_tag;\r\nif (strnlen(tag, GB_FIRMWARE_TAG_MAX_SIZE) ==\r\nGB_FIRMWARE_TAG_MAX_SIZE) {\r\ndev_err(fw_download->parent,\r\n"firmware-tag is not null-terminated\n");\r\nreturn -EINVAL;\r\n}\r\nfw_req = find_firmware(fw_download, tag);\r\nif (IS_ERR(fw_req))\r\nreturn PTR_ERR(fw_req);\r\nif (!gb_operation_response_alloc(op, sizeof(*response), GFP_KERNEL)) {\r\ndev_err(fw_download->parent, "error allocating response\n");\r\nfree_firmware(fw_download, fw_req);\r\nreturn -ENOMEM;\r\n}\r\nresponse = op->response->payload;\r\nresponse->firmware_id = fw_req->firmware_id;\r\nresponse->size = cpu_to_le32(fw_req->fw->size);\r\ndev_dbg(fw_download->parent,\r\n"firmware size is %zu bytes\n", fw_req->fw->size);\r\nreturn 0;\r\n}\r\nstatic int fw_download_fetch_firmware(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct fw_download *fw_download = gb_connection_get_data(connection);\r\nstruct gb_fw_download_fetch_firmware_request *request;\r\nstruct gb_fw_download_fetch_firmware_response *response;\r\nstruct fw_request *fw_req;\r\nconst struct firmware *fw;\r\nunsigned int offset, size;\r\nu8 firmware_id;\r\nint ret = 0;\r\nif (op->request->payload_size != sizeof(*request)) {\r\ndev_err(fw_download->parent,\r\n"Illegal size of fetch firmware request (%zu %zu)\n",\r\nop->request->payload_size, sizeof(*request));\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request->payload;\r\noffset = le32_to_cpu(request->offset);\r\nsize = le32_to_cpu(request->size);\r\nfirmware_id = request->firmware_id;\r\nfw_req = get_fw_req(fw_download, firmware_id);\r\nif (!fw_req) {\r\ndev_err(fw_download->parent,\r\n"firmware not available for id: %02u\n", firmware_id);\r\nreturn -EINVAL;\r\n}\r\ncancel_delayed_work_sync(&fw_req->dwork);\r\nif (fw_req->disabled) {\r\nret = -ETIMEDOUT;\r\ngoto put_fw;\r\n}\r\nret = exceeds_release_timeout(fw_req);\r\nif (ret)\r\ngoto put_fw;\r\nfw = fw_req->fw;\r\nif (offset >= fw->size || size > fw->size - offset) {\r\ndev_err(fw_download->parent,\r\n"bad fetch firmware request (offs = %u, size = %u)\n",\r\noffset, size);\r\nret = -EINVAL;\r\ngoto put_fw;\r\n}\r\nif (!gb_operation_response_alloc(op, sizeof(*response) + size,\r\nGFP_KERNEL)) {\r\ndev_err(fw_download->parent,\r\n"error allocating fetch firmware response\n");\r\nret = -ENOMEM;\r\ngoto put_fw;\r\n}\r\nresponse = op->response->payload;\r\nmemcpy(response->data, fw->data + offset, size);\r\ndev_dbg(fw_download->parent,\r\n"responding with firmware (offs = %u, size = %u)\n", offset,\r\nsize);\r\nschedule_delayed_work(&fw_req->dwork, NEXT_REQ_TIMEOUT_J);\r\nput_fw:\r\nput_fw_req(fw_req);\r\nreturn ret;\r\n}\r\nstatic int fw_download_release_firmware(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct fw_download *fw_download = gb_connection_get_data(connection);\r\nstruct gb_fw_download_release_firmware_request *request;\r\nstruct fw_request *fw_req;\r\nu8 firmware_id;\r\nif (op->request->payload_size != sizeof(*request)) {\r\ndev_err(fw_download->parent,\r\n"Illegal size of release firmware request (%zu %zu)\n",\r\nop->request->payload_size, sizeof(*request));\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request->payload;\r\nfirmware_id = request->firmware_id;\r\nfw_req = get_fw_req(fw_download, firmware_id);\r\nif (!fw_req) {\r\ndev_err(fw_download->parent,\r\n"firmware not available for id: %02u\n", firmware_id);\r\nreturn -EINVAL;\r\n}\r\ncancel_delayed_work_sync(&fw_req->dwork);\r\nfree_firmware(fw_download, fw_req);\r\nput_fw_req(fw_req);\r\ndev_dbg(fw_download->parent, "release firmware\n");\r\nreturn 0;\r\n}\r\nint gb_fw_download_request_handler(struct gb_operation *op)\r\n{\r\nu8 type = op->type;\r\nswitch (type) {\r\ncase GB_FW_DOWNLOAD_TYPE_FIND_FIRMWARE:\r\nreturn fw_download_find_firmware(op);\r\ncase GB_FW_DOWNLOAD_TYPE_FETCH_FIRMWARE:\r\nreturn fw_download_fetch_firmware(op);\r\ncase GB_FW_DOWNLOAD_TYPE_RELEASE_FIRMWARE:\r\nreturn fw_download_release_firmware(op);\r\ndefault:\r\ndev_err(&op->connection->bundle->dev,\r\n"unsupported request: %u\n", type);\r\nreturn -EINVAL;\r\n}\r\n}\r\nint gb_fw_download_connection_init(struct gb_connection *connection)\r\n{\r\nstruct fw_download *fw_download;\r\nint ret;\r\nif (!connection)\r\nreturn 0;\r\nfw_download = kzalloc(sizeof(*fw_download), GFP_KERNEL);\r\nif (!fw_download)\r\nreturn -ENOMEM;\r\nfw_download->parent = &connection->bundle->dev;\r\nINIT_LIST_HEAD(&fw_download->fw_requests);\r\nida_init(&fw_download->id_map);\r\ngb_connection_set_data(connection, fw_download);\r\nfw_download->connection = connection;\r\nmutex_init(&fw_download->mutex);\r\nret = gb_connection_enable(connection);\r\nif (ret)\r\ngoto err_destroy_id_map;\r\nreturn 0;\r\nerr_destroy_id_map:\r\nida_destroy(&fw_download->id_map);\r\nkfree(fw_download);\r\nreturn ret;\r\n}\r\nvoid gb_fw_download_connection_exit(struct gb_connection *connection)\r\n{\r\nstruct fw_download *fw_download;\r\nstruct fw_request *fw_req, *tmp;\r\nif (!connection)\r\nreturn;\r\nfw_download = gb_connection_get_data(connection);\r\ngb_connection_disable(fw_download->connection);\r\nmutex_lock(&fw_download->mutex);\r\nlist_for_each_entry(fw_req, &fw_download->fw_requests, node)\r\nkref_get(&fw_req->kref);\r\nmutex_unlock(&fw_download->mutex);\r\nlist_for_each_entry_safe(fw_req, tmp, &fw_download->fw_requests, node) {\r\ncancel_delayed_work_sync(&fw_req->dwork);\r\nfree_firmware(fw_download, fw_req);\r\nput_fw_req(fw_req);\r\n}\r\nida_destroy(&fw_download->id_map);\r\nkfree(fw_download);\r\n}
