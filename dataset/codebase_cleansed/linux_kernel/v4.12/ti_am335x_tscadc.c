void am335x_tsc_se_set_cache(struct ti_tscadc_dev *tscadc, u32 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tscadc->reg_lock, flags);\r\ntscadc->reg_se_cache |= val;\r\nif (tscadc->adc_waiting)\r\nwake_up(&tscadc->reg_se_wait);\r\nelse if (!tscadc->adc_in_use)\r\nregmap_write(tscadc->regmap, REG_SE, tscadc->reg_se_cache);\r\nspin_unlock_irqrestore(&tscadc->reg_lock, flags);\r\n}\r\nstatic void am335x_tscadc_need_adc(struct ti_tscadc_dev *tscadc)\r\n{\r\nDEFINE_WAIT(wait);\r\nu32 reg;\r\nregmap_read(tscadc->regmap, REG_ADCFSM, &reg);\r\nif (reg & SEQ_STATUS) {\r\ntscadc->adc_waiting = true;\r\nprepare_to_wait(&tscadc->reg_se_wait, &wait,\r\nTASK_UNINTERRUPTIBLE);\r\nspin_unlock_irq(&tscadc->reg_lock);\r\nschedule();\r\nspin_lock_irq(&tscadc->reg_lock);\r\nfinish_wait(&tscadc->reg_se_wait, &wait);\r\nregmap_read(tscadc->regmap, REG_ADCFSM, &reg);\r\nWARN_ON((reg & SEQ_STATUS) && !(reg & CHARGE_STEP));\r\ntscadc->adc_waiting = false;\r\n}\r\ntscadc->adc_in_use = true;\r\n}\r\nvoid am335x_tsc_se_set_once(struct ti_tscadc_dev *tscadc, u32 val)\r\n{\r\nspin_lock_irq(&tscadc->reg_lock);\r\nam335x_tscadc_need_adc(tscadc);\r\nregmap_write(tscadc->regmap, REG_SE, val);\r\nspin_unlock_irq(&tscadc->reg_lock);\r\n}\r\nvoid am335x_tsc_se_adc_done(struct ti_tscadc_dev *tscadc)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tscadc->reg_lock, flags);\r\ntscadc->adc_in_use = false;\r\nregmap_write(tscadc->regmap, REG_SE, tscadc->reg_se_cache);\r\nspin_unlock_irqrestore(&tscadc->reg_lock, flags);\r\n}\r\nvoid am335x_tsc_se_clr(struct ti_tscadc_dev *tscadc, u32 val)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&tscadc->reg_lock, flags);\r\ntscadc->reg_se_cache &= ~val;\r\nregmap_write(tscadc->regmap, REG_SE, tscadc->reg_se_cache);\r\nspin_unlock_irqrestore(&tscadc->reg_lock, flags);\r\n}\r\nstatic void tscadc_idle_config(struct ti_tscadc_dev *tscadc)\r\n{\r\nunsigned int idleconfig;\r\nidleconfig = STEPCONFIG_YNN | STEPCONFIG_INM_ADCREFM |\r\nSTEPCONFIG_INP_ADCREFM | STEPCONFIG_YPN;\r\nregmap_write(tscadc->regmap, REG_IDLECONFIG, idleconfig);\r\n}\r\nstatic int ti_tscadc_probe(struct platform_device *pdev)\r\n{\r\nstruct ti_tscadc_dev *tscadc;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct mfd_cell *cell;\r\nstruct property *prop;\r\nconst __be32 *cur;\r\nu32 val;\r\nint err, ctrl;\r\nint clock_rate;\r\nint tsc_wires = 0, adc_channels = 0, total_channels;\r\nint readouts = 0;\r\nif (!pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "Could not find valid DT data.\n");\r\nreturn -EINVAL;\r\n}\r\nnode = of_get_child_by_name(pdev->dev.of_node, "tsc");\r\nof_property_read_u32(node, "ti,wires", &tsc_wires);\r\nof_property_read_u32(node, "ti,coordiante-readouts", &readouts);\r\nnode = of_get_child_by_name(pdev->dev.of_node, "adc");\r\nof_property_for_each_u32(node, "ti,adc-channels", prop, cur, val) {\r\nadc_channels++;\r\nif (val > 7) {\r\ndev_err(&pdev->dev, " PIN numbers are 0..7 (not %d)\n",\r\nval);\r\nreturn -EINVAL;\r\n}\r\n}\r\ntotal_channels = tsc_wires + adc_channels;\r\nif (total_channels > 8) {\r\ndev_err(&pdev->dev, "Number of i/p channels more than 8\n");\r\nreturn -EINVAL;\r\n}\r\nif (total_channels == 0) {\r\ndev_err(&pdev->dev, "Need atleast one channel.\n");\r\nreturn -EINVAL;\r\n}\r\nif (readouts * 2 + 2 + adc_channels > 16) {\r\ndev_err(&pdev->dev, "Too many step configurations requested\n");\r\nreturn -EINVAL;\r\n}\r\ntscadc = devm_kzalloc(&pdev->dev, sizeof(*tscadc), GFP_KERNEL);\r\nif (!tscadc) {\r\ndev_err(&pdev->dev, "failed to allocate memory.\n");\r\nreturn -ENOMEM;\r\n}\r\ntscadc->dev = &pdev->dev;\r\nerr = platform_get_irq(pdev, 0);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "no irq ID is specified.\n");\r\ngoto ret;\r\n} else\r\ntscadc->irq = err;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ntscadc->tscadc_phys_base = res->start;\r\ntscadc->tscadc_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(tscadc->tscadc_base))\r\nreturn PTR_ERR(tscadc->tscadc_base);\r\ntscadc->regmap = devm_regmap_init_mmio(&pdev->dev,\r\ntscadc->tscadc_base, &tscadc_regmap_config);\r\nif (IS_ERR(tscadc->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nerr = PTR_ERR(tscadc->regmap);\r\ngoto ret;\r\n}\r\nspin_lock_init(&tscadc->reg_lock);\r\ninit_waitqueue_head(&tscadc->reg_se_wait);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nclk = clk_get(&pdev->dev, "adc_tsc_fck");\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "failed to get TSC fck\n");\r\nerr = PTR_ERR(clk);\r\ngoto err_disable_clk;\r\n}\r\nclock_rate = clk_get_rate(clk);\r\nclk_put(clk);\r\ntscadc->clk_div = clock_rate / ADC_CLK;\r\ntscadc->clk_div--;\r\nregmap_write(tscadc->regmap, REG_CLKDIV, tscadc->clk_div);\r\nctrl = CNTRLREG_STEPCONFIGWRT | CNTRLREG_STEPID;\r\nregmap_write(tscadc->regmap, REG_CTRL, ctrl);\r\nif (tsc_wires > 0) {\r\ntscadc->tsc_wires = tsc_wires;\r\nif (tsc_wires == 5)\r\nctrl |= CNTRLREG_5WIRE | CNTRLREG_TSCENB;\r\nelse\r\nctrl |= CNTRLREG_4WIRE | CNTRLREG_TSCENB;\r\ntscadc_idle_config(tscadc);\r\n}\r\nctrl |= CNTRLREG_TSCSSENB;\r\nregmap_write(tscadc->regmap, REG_CTRL, ctrl);\r\ntscadc->used_cells = 0;\r\ntscadc->tsc_cell = -1;\r\ntscadc->adc_cell = -1;\r\nif (tsc_wires > 0) {\r\ntscadc->tsc_cell = tscadc->used_cells;\r\ncell = &tscadc->cells[tscadc->used_cells++];\r\ncell->name = "TI-am335x-tsc";\r\ncell->of_compatible = "ti,am3359-tsc";\r\ncell->platform_data = &tscadc;\r\ncell->pdata_size = sizeof(tscadc);\r\n}\r\nif (adc_channels > 0) {\r\ntscadc->adc_cell = tscadc->used_cells;\r\ncell = &tscadc->cells[tscadc->used_cells++];\r\ncell->name = "TI-am335x-adc";\r\ncell->of_compatible = "ti,am3359-adc";\r\ncell->platform_data = &tscadc;\r\ncell->pdata_size = sizeof(tscadc);\r\n}\r\nerr = mfd_add_devices(&pdev->dev, pdev->id, tscadc->cells,\r\ntscadc->used_cells, NULL, 0, NULL);\r\nif (err < 0)\r\ngoto err_disable_clk;\r\ndevice_init_wakeup(&pdev->dev, true);\r\nplatform_set_drvdata(pdev, tscadc);\r\nreturn 0;\r\nerr_disable_clk:\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nret:\r\nreturn err;\r\n}\r\nstatic int ti_tscadc_remove(struct platform_device *pdev)\r\n{\r\nstruct ti_tscadc_dev *tscadc = platform_get_drvdata(pdev);\r\nregmap_write(tscadc->regmap, REG_SE, 0x00);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nmfd_remove_devices(tscadc->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tscadc_suspend(struct device *dev)\r\n{\r\nstruct ti_tscadc_dev *tscadc = dev_get_drvdata(dev);\r\nregmap_write(tscadc->regmap, REG_SE, 0x00);\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tscadc_resume(struct device *dev)\r\n{\r\nstruct ti_tscadc_dev *tscadc = dev_get_drvdata(dev);\r\nu32 ctrl;\r\npm_runtime_get_sync(dev);\r\nctrl = CNTRLREG_STEPCONFIGWRT | CNTRLREG_STEPID;\r\nregmap_write(tscadc->regmap, REG_CTRL, ctrl);\r\nif (tscadc->tsc_cell != -1) {\r\nif (tscadc->tsc_wires == 5)\r\nctrl |= CNTRLREG_5WIRE | CNTRLREG_TSCENB;\r\nelse\r\nctrl |= CNTRLREG_4WIRE | CNTRLREG_TSCENB;\r\ntscadc_idle_config(tscadc);\r\n}\r\nctrl |= CNTRLREG_TSCSSENB;\r\nregmap_write(tscadc->regmap, REG_CTRL, ctrl);\r\nregmap_write(tscadc->regmap, REG_CLKDIV, tscadc->clk_div);\r\nreturn 0;\r\n}
