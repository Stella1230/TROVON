static int clk_corediv_is_enabled(struct clk_hw *hwclk)\r\n{\r\nstruct clk_corediv *corediv = to_corediv_clk(hwclk);\r\nconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\r\nconst struct clk_corediv_desc *desc = corediv->desc;\r\nu32 enable_mask = BIT(desc->fieldbit) << soc_desc->enable_bit_offset;\r\nreturn !!(readl(corediv->reg) & enable_mask);\r\n}\r\nstatic int clk_corediv_enable(struct clk_hw *hwclk)\r\n{\r\nstruct clk_corediv *corediv = to_corediv_clk(hwclk);\r\nconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\r\nconst struct clk_corediv_desc *desc = corediv->desc;\r\nunsigned long flags = 0;\r\nu32 reg;\r\nspin_lock_irqsave(&corediv->lock, flags);\r\nreg = readl(corediv->reg);\r\nreg |= (BIT(desc->fieldbit) << soc_desc->enable_bit_offset);\r\nwritel(reg, corediv->reg);\r\nspin_unlock_irqrestore(&corediv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void clk_corediv_disable(struct clk_hw *hwclk)\r\n{\r\nstruct clk_corediv *corediv = to_corediv_clk(hwclk);\r\nconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\r\nconst struct clk_corediv_desc *desc = corediv->desc;\r\nunsigned long flags = 0;\r\nu32 reg;\r\nspin_lock_irqsave(&corediv->lock, flags);\r\nreg = readl(corediv->reg);\r\nreg &= ~(BIT(desc->fieldbit) << soc_desc->enable_bit_offset);\r\nwritel(reg, corediv->reg);\r\nspin_unlock_irqrestore(&corediv->lock, flags);\r\n}\r\nstatic unsigned long clk_corediv_recalc_rate(struct clk_hw *hwclk,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_corediv *corediv = to_corediv_clk(hwclk);\r\nconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\r\nconst struct clk_corediv_desc *desc = corediv->desc;\r\nu32 reg, div;\r\nreg = readl(corediv->reg + soc_desc->ratio_offset);\r\ndiv = (reg >> desc->offset) & desc->mask;\r\nreturn parent_rate / div;\r\n}\r\nstatic long clk_corediv_round_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nu32 div;\r\ndiv = *parent_rate / rate;\r\nif (div < 4)\r\ndiv = 4;\r\nelse if (div > 6)\r\ndiv = 8;\r\nreturn *parent_rate / div;\r\n}\r\nstatic int clk_corediv_set_rate(struct clk_hw *hwclk, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_corediv *corediv = to_corediv_clk(hwclk);\r\nconst struct clk_corediv_soc_desc *soc_desc = corediv->soc_desc;\r\nconst struct clk_corediv_desc *desc = corediv->desc;\r\nunsigned long flags = 0;\r\nu32 reg, div;\r\ndiv = parent_rate / rate;\r\nspin_lock_irqsave(&corediv->lock, flags);\r\nreg = readl(corediv->reg + soc_desc->ratio_offset);\r\nreg &= ~(desc->mask << desc->offset);\r\nreg |= (div & desc->mask) << desc->offset;\r\nwritel(reg, corediv->reg + soc_desc->ratio_offset);\r\nreg = readl(corediv->reg) | BIT(desc->fieldbit);\r\nwritel(reg, corediv->reg);\r\nreg = readl(corediv->reg) | soc_desc->ratio_reload;\r\nwritel(reg, corediv->reg);\r\nudelay(1000);\r\nreg &= ~(CORE_CLK_DIV_RATIO_MASK | soc_desc->ratio_reload);\r\nwritel(reg, corediv->reg);\r\nudelay(1000);\r\nspin_unlock_irqrestore(&corediv->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __init\r\nmvebu_corediv_clk_init(struct device_node *node,\r\nconst struct clk_corediv_soc_desc *soc_desc)\r\n{\r\nstruct clk_init_data init;\r\nstruct clk_corediv *corediv;\r\nstruct clk **clks;\r\nvoid __iomem *base;\r\nconst char *parent_name;\r\nconst char *clk_name;\r\nint i;\r\nbase = of_iomap(node, 0);\r\nif (WARN_ON(!base))\r\nreturn;\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nclk_data.clk_num = soc_desc->ndescs;\r\nclks = kcalloc(clk_data.clk_num, sizeof(struct clk *),\r\nGFP_KERNEL);\r\nif (WARN_ON(!clks))\r\ngoto err_unmap;\r\ncorediv = kcalloc(clk_data.clk_num, sizeof(struct clk_corediv),\r\nGFP_KERNEL);\r\nif (WARN_ON(!corediv))\r\ngoto err_free_clks;\r\nspin_lock_init(&corediv->lock);\r\nfor (i = 0; i < clk_data.clk_num; i++) {\r\nof_property_read_string_index(node, "clock-output-names",\r\ni, &clk_name);\r\ninit.num_parents = 1;\r\ninit.parent_names = &parent_name;\r\ninit.name = clk_name;\r\ninit.ops = &soc_desc->ops;\r\ninit.flags = 0;\r\ncorediv[i].soc_desc = soc_desc;\r\ncorediv[i].desc = soc_desc->descs + i;\r\ncorediv[i].reg = base;\r\ncorediv[i].hw.init = &init;\r\nclks[i] = clk_register(NULL, &corediv[i].hw);\r\nWARN_ON(IS_ERR(clks[i]));\r\n}\r\nclk_data.clks = clks;\r\nof_clk_add_provider(node, of_clk_src_onecell_get, &clk_data);\r\nreturn;\r\nerr_free_clks:\r\nkfree(clks);\r\nerr_unmap:\r\niounmap(base);\r\n}\r\nstatic void __init armada370_corediv_clk_init(struct device_node *node)\r\n{\r\nreturn mvebu_corediv_clk_init(node, &armada370_corediv_soc);\r\n}\r\nstatic void __init armada375_corediv_clk_init(struct device_node *node)\r\n{\r\nreturn mvebu_corediv_clk_init(node, &armada375_corediv_soc);\r\n}\r\nstatic void __init armada380_corediv_clk_init(struct device_node *node)\r\n{\r\nreturn mvebu_corediv_clk_init(node, &armada380_corediv_soc);\r\n}\r\nstatic void __init mv98dx3236_corediv_clk_init(struct device_node *node)\r\n{\r\nreturn mvebu_corediv_clk_init(node, &mv98dx3236_corediv_soc);\r\n}
