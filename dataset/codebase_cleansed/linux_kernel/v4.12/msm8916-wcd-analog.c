static void pm8916_wcd_analog_micbias_enable(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_CTL,\r\nMICB_1_CTL_EXT_PRECHARG_EN_MASK |\r\nMICB_1_CTL_INT_PRECHARG_BYP_MASK,\r\nMICB_1_CTL_INT_PRECHARG_BYP_EXT_PRECHRG_SEL\r\n| MICB_1_CTL_EXT_PRECHARG_EN_ENABLE);\r\nsnd_soc_write(codec, CDC_A_MICB_1_VAL, MICB_1_VAL_MICB_OUT_VAL_V2P70V);\r\nmsleep(50);\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_CTL,\r\nMICB_1_CTL_EXT_PRECHARG_EN_MASK |\r\nMICB_1_CTL_INT_PRECHARG_BYP_MASK, 0);\r\n}\r\nstatic int pm8916_wcd_analog_enable_micbias_ext(struct snd_soc_codec\r\n*codec, int event,\r\nint reg, u32 cap_mode)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\npm8916_wcd_analog_micbias_enable(codec);\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_EN,\r\nMICB_1_EN_BYP_CAP_MASK, cap_mode);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8916_wcd_analog_enable_micbias_int(struct snd_soc_codec\r\n*codec, int event,\r\nint reg, u32 cap_mode)\r\n{\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_INT_RBIAS,\r\nMICB_1_INT_TX2_INT_RBIAS_EN_MASK,\r\nMICB_1_INT_TX2_INT_RBIAS_EN_ENABLE);\r\nsnd_soc_update_bits(codec, reg, MICB_1_EN_PULL_DOWN_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_EN,\r\nMICB_1_EN_OPA_STG2_TAIL_CURR_MASK,\r\nMICB_1_EN_OPA_STG2_TAIL_CURR_1_60UA);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\npm8916_wcd_analog_micbias_enable(codec);\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_EN,\r\nMICB_1_EN_BYP_CAP_MASK, cap_mode);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8916_wcd_analog_enable_micbias_ext1(struct\r\nsnd_soc_dapm_widget\r\n*w, struct snd_kcontrol\r\n*kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct pm8916_wcd_analog_priv *wcd = snd_soc_codec_get_drvdata(codec);\r\nreturn pm8916_wcd_analog_enable_micbias_ext(codec, event, w->reg,\r\nwcd->micbias1_cap_mode);\r\n}\r\nstatic int pm8916_wcd_analog_enable_micbias_ext2(struct\r\nsnd_soc_dapm_widget\r\n*w, struct snd_kcontrol\r\n*kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct pm8916_wcd_analog_priv *wcd = snd_soc_codec_get_drvdata(codec);\r\nreturn pm8916_wcd_analog_enable_micbias_ext(codec, event, w->reg,\r\nwcd->micbias2_cap_mode);\r\n}\r\nstatic int pm8916_wcd_analog_enable_micbias_int1(struct\r\nsnd_soc_dapm_widget\r\n*w, struct snd_kcontrol\r\n*kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct pm8916_wcd_analog_priv *wcd = snd_soc_codec_get_drvdata(codec);\r\nreturn pm8916_wcd_analog_enable_micbias_int(codec, event, w->reg,\r\nwcd->micbias1_cap_mode);\r\n}\r\nstatic int pm8916_wcd_analog_enable_micbias_int2(struct\r\nsnd_soc_dapm_widget\r\n*w, struct snd_kcontrol\r\n*kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct pm8916_wcd_analog_priv *wcd = snd_soc_codec_get_drvdata(codec);\r\nreturn pm8916_wcd_analog_enable_micbias_int(codec, event, w->reg,\r\nwcd->micbias2_cap_mode);\r\n}\r\nstatic int pm8916_wcd_analog_enable_adc(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nu16 adc_reg = CDC_A_TX_1_2_TEST_CTL_2;\r\nu8 init_bit_shift;\r\nif (w->reg == CDC_A_TX_1_EN)\r\ninit_bit_shift = 5;\r\nelse\r\ninit_bit_shift = 4;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nif (w->reg == CDC_A_TX_2_EN)\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_CTL,\r\nMICB_1_CTL_CFILT_REF_SEL_MASK,\r\nMICB_1_CTL_CFILT_REF_SEL_HPF_REF);\r\nusleep_range(10000, 10010);\r\nsnd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift,\r\n1 << init_bit_shift);\r\nswitch (w->reg) {\r\ncase CDC_A_TX_1_EN:\r\nsnd_soc_update_bits(codec, CDC_D_CDC_CONN_TX1_CTL,\r\nCONN_TX1_SERIAL_TX1_MUX,\r\nCONN_TX1_SERIAL_TX1_ADC_1);\r\nbreak;\r\ncase CDC_A_TX_2_EN:\r\ncase CDC_A_TX_3_EN:\r\nsnd_soc_update_bits(codec, CDC_D_CDC_CONN_TX2_CTL,\r\nCONN_TX2_SERIAL_TX2_MUX,\r\nCONN_TX2_SERIAL_TX2_ADC_2);\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nusleep_range(12000, 12010);\r\nsnd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift, 0x00);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nswitch (w->reg) {\r\ncase CDC_A_TX_1_EN:\r\nsnd_soc_update_bits(codec, CDC_D_CDC_CONN_TX1_CTL,\r\nCONN_TX1_SERIAL_TX1_MUX,\r\nCONN_TX1_SERIAL_TX1_ZERO);\r\nbreak;\r\ncase CDC_A_TX_2_EN:\r\nsnd_soc_update_bits(codec, CDC_A_MICB_1_CTL,\r\nMICB_1_CTL_CFILT_REF_SEL_MASK, 0);\r\ncase CDC_A_TX_3_EN:\r\nsnd_soc_update_bits(codec, CDC_D_CDC_CONN_TX2_CTL,\r\nCONN_TX2_SERIAL_TX2_MUX,\r\nCONN_TX2_SERIAL_TX2_ZERO);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8916_wcd_analog_enable_spk_pa(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, CDC_A_SPKR_PWRSTG_CTL,\r\nSPKR_PWRSTG_CTL_DAC_EN_MASK |\r\nSPKR_PWRSTG_CTL_BBM_MASK |\r\nSPKR_PWRSTG_CTL_HBRDGE_EN_MASK |\r\nSPKR_PWRSTG_CTL_CLAMP_EN_MASK,\r\nSPKR_PWRSTG_CTL_DAC_EN|\r\nSPKR_PWRSTG_CTL_BBM_EN |\r\nSPKR_PWRSTG_CTL_HBRDGE_EN |\r\nSPKR_PWRSTG_CTL_CLAMP_EN);\r\nsnd_soc_update_bits(codec, CDC_A_RX_EAR_CTL,\r\nRX_EAR_CTL_SPK_VBAT_LDO_EN_MASK,\r\nRX_EAR_CTL_SPK_VBAT_LDO_EN_ENABLE);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, CDC_A_SPKR_DRV_CTL,\r\nSPKR_DRV_CTL_DEF_MASK,\r\nSPKR_DRV_CTL_DEF_VAL);\r\nsnd_soc_update_bits(codec, w->reg,\r\nSPKR_DRV_CLASSD_PA_EN_MASK,\r\nSPKR_DRV_CLASSD_PA_EN_ENABLE);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, CDC_A_SPKR_PWRSTG_CTL,\r\nSPKR_PWRSTG_CTL_DAC_EN_MASK|\r\nSPKR_PWRSTG_CTL_BBM_MASK |\r\nSPKR_PWRSTG_CTL_HBRDGE_EN_MASK |\r\nSPKR_PWRSTG_CTL_CLAMP_EN_MASK, 0);\r\nsnd_soc_update_bits(codec, CDC_A_SPKR_DAC_CTL,\r\nSPKR_DAC_CTL_DAC_RESET_MASK,\r\nSPKR_DAC_CTL_DAC_RESET_NORMAL);\r\nsnd_soc_update_bits(codec, CDC_A_RX_EAR_CTL,\r\nRX_EAR_CTL_SPK_VBAT_LDO_EN_MASK, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pm8916_wcd_analog_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct pm8916_wcd_analog_priv *priv = dev_get_drvdata(codec->dev);\r\nint err, reg;\r\nerr = regulator_bulk_enable(ARRAY_SIZE(priv->supplies), priv->supplies);\r\nif (err != 0) {\r\ndev_err(codec->dev, "failed to enable regulators (%d)\n", err);\r\nreturn err;\r\n}\r\nsnd_soc_codec_set_drvdata(codec, priv);\r\npriv->pmic_rev = snd_soc_read(codec, CDC_D_REVISION1);\r\npriv->codec_version = snd_soc_read(codec, CDC_D_PERPH_SUBTYPE);\r\ndev_info(codec->dev, "PMIC REV: %d\t CODEC Version: %d\n",\r\npriv->pmic_rev, priv->codec_version);\r\nsnd_soc_write(codec, CDC_D_PERPH_RESET_CTL4, 0x01);\r\nsnd_soc_write(codec, CDC_A_PERPH_RESET_CTL4, 0x01);\r\nfor (reg = 0; reg < ARRAY_SIZE(wcd_reg_defaults_2_0); reg++)\r\nsnd_soc_write(codec, wcd_reg_defaults_2_0[reg].reg,\r\nwcd_reg_defaults_2_0[reg].def);\r\nreturn 0;\r\n}\r\nstatic int pm8916_wcd_analog_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct pm8916_wcd_analog_priv *priv = dev_get_drvdata(codec->dev);\r\nreturn regulator_bulk_disable(ARRAY_SIZE(priv->supplies),\r\npriv->supplies);\r\n}\r\nstatic struct regmap *pm8916_get_regmap(struct device *dev)\r\n{\r\nreturn dev_get_regmap(dev->parent, NULL);\r\n}\r\nstatic int pm8916_wcd_analog_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_soc_update_bits(dai->codec, CDC_D_CDC_RST_CTL,\r\nRST_CTL_DIG_SW_RST_N_MASK,\r\nRST_CTL_DIG_SW_RST_N_REMOVE_RESET);\r\nreturn 0;\r\n}\r\nstatic void pm8916_wcd_analog_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nsnd_soc_update_bits(dai->codec, CDC_D_CDC_RST_CTL,\r\nRST_CTL_DIG_SW_RST_N_MASK, 0);\r\n}\r\nstatic int pm8916_wcd_analog_parse_dt(struct device *dev,\r\nstruct pm8916_wcd_analog_priv *priv)\r\n{\r\nif (of_property_read_bool(dev->of_node, "qcom,micbias1-ext-cap"))\r\npriv->micbias1_cap_mode = MICB_1_EN_EXT_BYP_CAP;\r\nelse\r\npriv->micbias1_cap_mode = MICB_1_EN_NO_EXT_BYP_CAP;\r\nif (of_property_read_bool(dev->of_node, "qcom,micbias2-ext-cap"))\r\npriv->micbias2_cap_mode = MICB_1_EN_EXT_BYP_CAP;\r\nelse\r\npriv->micbias2_cap_mode = MICB_1_EN_NO_EXT_BYP_CAP;\r\nreturn 0;\r\n}\r\nstatic int pm8916_wcd_analog_spmi_probe(struct platform_device *pdev)\r\n{\r\nstruct pm8916_wcd_analog_priv *priv;\r\nstruct device *dev = &pdev->dev;\r\nint ret, i;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nret = pm8916_wcd_analog_parse_dt(dev, priv);\r\nif (ret < 0)\r\nreturn ret;\r\npriv->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(priv->mclk)) {\r\ndev_err(dev, "failed to get mclk\n");\r\nreturn PTR_ERR(priv->mclk);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(supply_names); i++)\r\npriv->supplies[i].supply = supply_names[i];\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(priv->supplies),\r\npriv->supplies);\r\nif (ret) {\r\ndev_err(dev, "Failed to get regulator supplies %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(priv->mclk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to enable mclk %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, priv);\r\nreturn snd_soc_register_codec(dev, &pm8916_wcd_analog,\r\npm8916_wcd_analog_dai,\r\nARRAY_SIZE(pm8916_wcd_analog_dai));\r\n}\r\nstatic int pm8916_wcd_analog_spmi_remove(struct platform_device *pdev)\r\n{\r\nstruct pm8916_wcd_analog_priv *priv = dev_get_drvdata(&pdev->dev);\r\nsnd_soc_unregister_codec(&pdev->dev);\r\nclk_disable_unprepare(priv->mclk);\r\nreturn 0;\r\n}
