void fsl_tcon_bypass_disable(struct fsl_tcon *tcon)\r\n{\r\nregmap_update_bits(tcon->regs, FSL_TCON_CTRL1,\r\nFSL_TCON_CTRL1_TCON_BYPASS, 0);\r\n}\r\nvoid fsl_tcon_bypass_enable(struct fsl_tcon *tcon)\r\n{\r\nregmap_update_bits(tcon->regs, FSL_TCON_CTRL1,\r\nFSL_TCON_CTRL1_TCON_BYPASS,\r\nFSL_TCON_CTRL1_TCON_BYPASS);\r\n}\r\nstatic int fsl_tcon_init_regmap(struct device *dev,\r\nstruct fsl_tcon *tcon,\r\nstruct device_node *np)\r\n{\r\nstruct resource res;\r\nvoid __iomem *regs;\r\nif (of_address_to_resource(np, 0, &res))\r\nreturn -EINVAL;\r\nregs = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\ntcon->regs = devm_regmap_init_mmio(dev, regs,\r\n&fsl_tcon_regmap_config);\r\nreturn PTR_ERR_OR_ZERO(tcon->regs);\r\n}\r\nstruct fsl_tcon *fsl_tcon_init(struct device *dev)\r\n{\r\nstruct fsl_tcon *tcon;\r\nstruct device_node *np;\r\nint ret;\r\nnp = of_parse_phandle(dev->of_node, "fsl,tcon", 0);\r\nif (!np)\r\nreturn NULL;\r\ntcon = devm_kzalloc(dev, sizeof(*tcon), GFP_KERNEL);\r\nif (!tcon)\r\ngoto err_node_put;\r\nret = fsl_tcon_init_regmap(dev, tcon, np);\r\nif (ret) {\r\ndev_err(dev, "Couldn't create the TCON regmap\n");\r\ngoto err_node_put;\r\n}\r\ntcon->ipg_clk = of_clk_get_by_name(np, "ipg");\r\nif (IS_ERR(tcon->ipg_clk)) {\r\ndev_err(dev, "Couldn't get the TCON bus clock\n");\r\ngoto err_node_put;\r\n}\r\nret = clk_prepare_enable(tcon->ipg_clk);\r\nif (ret) {\r\ndev_err(dev, "Couldn't enable the TCON clock\n");\r\ngoto err_node_put;\r\n}\r\nof_node_put(np);\r\ndev_info(dev, "Using TCON in bypass mode\n");\r\nreturn tcon;\r\nerr_node_put:\r\nof_node_put(np);\r\nreturn NULL;\r\n}\r\nvoid fsl_tcon_free(struct fsl_tcon *tcon)\r\n{\r\nclk_disable_unprepare(tcon->ipg_clk);\r\nclk_put(tcon->ipg_clk);\r\n}
