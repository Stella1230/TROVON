static int onyx_read_register(struct onyx *onyx, u8 reg, u8 *value)\r\n{\r\ns32 v;\r\nif (reg != ONYX_REG_CONTROL) {\r\n*value = onyx->cache[reg-FIRSTREGISTER];\r\nreturn 0;\r\n}\r\nv = i2c_smbus_read_byte_data(onyx->i2c, reg);\r\nif (v < 0)\r\nreturn -1;\r\n*value = (u8)v;\r\nonyx->cache[ONYX_REG_CONTROL-FIRSTREGISTER] = *value;\r\nreturn 0;\r\n}\r\nstatic int onyx_write_register(struct onyx *onyx, u8 reg, u8 value)\r\n{\r\nint result;\r\nresult = i2c_smbus_write_byte_data(onyx->i2c, reg, value);\r\nif (!result)\r\nonyx->cache[reg-FIRSTREGISTER] = value;\r\nreturn result;\r\n}\r\nstatic int onyx_dev_register(struct snd_device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_vol_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 2;\r\nuinfo->value.integer.min = -128 + VOLUME_RANGE_SHIFT;\r\nuinfo->value.integer.max = -1 + VOLUME_RANGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_vol_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\ns8 l, r;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_LEFT, &l);\r\nonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_RIGHT, &r);\r\nmutex_unlock(&onyx->mutex);\r\nucontrol->value.integer.value[0] = l + VOLUME_RANGE_SHIFT;\r\nucontrol->value.integer.value[1] = r + VOLUME_RANGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_vol_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\ns8 l, r;\r\nif (ucontrol->value.integer.value[0] < -128 + VOLUME_RANGE_SHIFT ||\r\nucontrol->value.integer.value[0] > -1 + VOLUME_RANGE_SHIFT)\r\nreturn -EINVAL;\r\nif (ucontrol->value.integer.value[1] < -128 + VOLUME_RANGE_SHIFT ||\r\nucontrol->value.integer.value[1] > -1 + VOLUME_RANGE_SHIFT)\r\nreturn -EINVAL;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_LEFT, &l);\r\nonyx_read_register(onyx, ONYX_REG_DAC_ATTEN_RIGHT, &r);\r\nif (l + VOLUME_RANGE_SHIFT == ucontrol->value.integer.value[0] &&\r\nr + VOLUME_RANGE_SHIFT == ucontrol->value.integer.value[1]) {\r\nmutex_unlock(&onyx->mutex);\r\nreturn 0;\r\n}\r\nonyx_write_register(onyx, ONYX_REG_DAC_ATTEN_LEFT,\r\nucontrol->value.integer.value[0]\r\n- VOLUME_RANGE_SHIFT);\r\nonyx_write_register(onyx, ONYX_REG_DAC_ATTEN_RIGHT,\r\nucontrol->value.integer.value[1]\r\n- VOLUME_RANGE_SHIFT);\r\nmutex_unlock(&onyx->mutex);\r\nreturn 1;\r\n}\r\nstatic int onyx_snd_inputgain_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\nuinfo->count = 1;\r\nuinfo->value.integer.min = 3 + INPUTGAIN_RANGE_SHIFT;\r\nuinfo->value.integer.max = 28 + INPUTGAIN_RANGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_inputgain_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 ig;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &ig);\r\nmutex_unlock(&onyx->mutex);\r\nucontrol->value.integer.value[0] =\r\n(ig & ONYX_ADC_PGA_GAIN_MASK) + INPUTGAIN_RANGE_SHIFT;\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_inputgain_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 v, n;\r\nif (ucontrol->value.integer.value[0] < 3 + INPUTGAIN_RANGE_SHIFT ||\r\nucontrol->value.integer.value[0] > 28 + INPUTGAIN_RANGE_SHIFT)\r\nreturn -EINVAL;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &v);\r\nn = v;\r\nn &= ~ONYX_ADC_PGA_GAIN_MASK;\r\nn |= (ucontrol->value.integer.value[0] - INPUTGAIN_RANGE_SHIFT)\r\n& ONYX_ADC_PGA_GAIN_MASK;\r\nonyx_write_register(onyx, ONYX_REG_ADC_CONTROL, n);\r\nmutex_unlock(&onyx->mutex);\r\nreturn n != v;\r\n}\r\nstatic int onyx_snd_capture_source_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstatic const char * const texts[] = { "Line-In", "Microphone" };\r\nreturn snd_ctl_enum_info(uinfo, 1, 2, texts);\r\n}\r\nstatic int onyx_snd_capture_source_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\ns8 v;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &v);\r\nmutex_unlock(&onyx->mutex);\r\nucontrol->value.enumerated.item[0] = !!(v&ONYX_ADC_INPUT_MIC);\r\nreturn 0;\r\n}\r\nstatic void onyx_set_capture_source(struct onyx *onyx, int mic)\r\n{\r\ns8 v;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_ADC_CONTROL, &v);\r\nv &= ~ONYX_ADC_INPUT_MIC;\r\nif (mic)\r\nv |= ONYX_ADC_INPUT_MIC;\r\nonyx_write_register(onyx, ONYX_REG_ADC_CONTROL, v);\r\nmutex_unlock(&onyx->mutex);\r\n}\r\nstatic int onyx_snd_capture_source_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nif (ucontrol->value.enumerated.item[0] > 1)\r\nreturn -EINVAL;\r\nonyx_set_capture_source(snd_kcontrol_chip(kcontrol),\r\nucontrol->value.enumerated.item[0]);\r\nreturn 1;\r\n}\r\nstatic int onyx_snd_mute_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 c;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &c);\r\nmutex_unlock(&onyx->mutex);\r\nucontrol->value.integer.value[0] = !(c & ONYX_MUTE_LEFT);\r\nucontrol->value.integer.value[1] = !(c & ONYX_MUTE_RIGHT);\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_mute_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 v = 0, c = 0;\r\nint err = -EBUSY;\r\nmutex_lock(&onyx->mutex);\r\nif (onyx->analog_locked)\r\ngoto out_unlock;\r\nonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &v);\r\nc = v;\r\nc &= ~(ONYX_MUTE_RIGHT | ONYX_MUTE_LEFT);\r\nif (!ucontrol->value.integer.value[0])\r\nc |= ONYX_MUTE_LEFT;\r\nif (!ucontrol->value.integer.value[1])\r\nc |= ONYX_MUTE_RIGHT;\r\nerr = onyx_write_register(onyx, ONYX_REG_DAC_CONTROL, c);\r\nout_unlock:\r\nmutex_unlock(&onyx->mutex);\r\nreturn !err ? (v != c) : err;\r\n}\r\nstatic int onyx_snd_single_bit_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 c;\r\nlong int pv = kcontrol->private_value;\r\nu8 polarity = (pv >> 16) & FLAG_POLARITY_INVERT;\r\nu8 address = (pv >> 8) & 0xff;\r\nu8 mask = pv & 0xff;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, address, &c);\r\nmutex_unlock(&onyx->mutex);\r\nucontrol->value.integer.value[0] = !!(c & mask) ^ polarity;\r\nreturn 0;\r\n}\r\nstatic int onyx_snd_single_bit_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 v = 0, c = 0;\r\nint err;\r\nlong int pv = kcontrol->private_value;\r\nu8 polarity = (pv >> 16) & FLAG_POLARITY_INVERT;\r\nu8 spdiflock = (pv >> 16) & FLAG_SPDIFLOCK;\r\nu8 address = (pv >> 8) & 0xff;\r\nu8 mask = pv & 0xff;\r\nmutex_lock(&onyx->mutex);\r\nif (spdiflock && onyx->spdif_locked) {\r\nerr = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nonyx_read_register(onyx, address, &v);\r\nc = v;\r\nc &= ~(mask);\r\nif (!!ucontrol->value.integer.value[0] ^ polarity)\r\nc |= mask;\r\nerr = onyx_write_register(onyx, address, c);\r\nout_unlock:\r\nmutex_unlock(&onyx->mutex);\r\nreturn !err ? (v != c) : err;\r\n}\r\nstatic int onyx_spdif_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int onyx_spdif_mask_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0x3e;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[3] = 0x3f;\r\nucontrol->value.iec958.status[4] = 0x0f;\r\nreturn 0;\r\n}\r\nstatic int onyx_spdif_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 v;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO1, &v);\r\nucontrol->value.iec958.status[0] = v & 0x3e;\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO2, &v);\r\nucontrol->value.iec958.status[1] = v;\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO3, &v);\r\nucontrol->value.iec958.status[3] = v & 0x3f;\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\r\nucontrol->value.iec958.status[4] = v & 0x0f;\r\nmutex_unlock(&onyx->mutex);\r\nreturn 0;\r\n}\r\nstatic int onyx_spdif_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct onyx *onyx = snd_kcontrol_chip(kcontrol);\r\nu8 v;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO1, &v);\r\nv = (v & ~0x3e) | (ucontrol->value.iec958.status[0] & 0x3e);\r\nonyx_write_register(onyx, ONYX_REG_DIG_INFO1, v);\r\nv = ucontrol->value.iec958.status[1];\r\nonyx_write_register(onyx, ONYX_REG_DIG_INFO2, v);\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO3, &v);\r\nv = (v & ~0x3f) | (ucontrol->value.iec958.status[3] & 0x3f);\r\nonyx_write_register(onyx, ONYX_REG_DIG_INFO3, v);\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\r\nv = (v & ~0x0f) | (ucontrol->value.iec958.status[4] & 0x0f);\r\nonyx_write_register(onyx, ONYX_REG_DIG_INFO4, v);\r\nmutex_unlock(&onyx->mutex);\r\nreturn 1;\r\n}\r\nstatic int onyx_register_init(struct onyx *onyx)\r\n{\r\nint i;\r\nu8 val;\r\nu8 regs[sizeof(initial_values)];\r\nif (!onyx->initialised) {\r\nmemcpy(regs, initial_values, sizeof(initial_values));\r\nif (onyx_read_register(onyx, ONYX_REG_CONTROL, &val))\r\nreturn -1;\r\nval &= ~ONYX_SILICONVERSION;\r\nval |= initial_values[3];\r\nregs[3] = val;\r\n} else {\r\nfor (i=0; i<sizeof(register_map); i++)\r\nregs[i] = onyx->cache[register_map[i]-FIRSTREGISTER];\r\n}\r\nfor (i=0; i<sizeof(register_map); i++) {\r\nif (onyx_write_register(onyx, register_map[i], regs[i]))\r\nreturn -1;\r\n}\r\nonyx->initialised = 1;\r\nreturn 0;\r\n}\r\nstatic int onyx_usable(struct codec_info_item *cii,\r\nstruct transfer_info *ti,\r\nstruct transfer_info *out)\r\n{\r\nu8 v;\r\nstruct onyx *onyx = cii->codec_data;\r\nint spdif_enabled, analog_enabled;\r\nmutex_lock(&onyx->mutex);\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\r\nspdif_enabled = !!(v & ONYX_SPDIF_ENABLE);\r\nonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &v);\r\nanalog_enabled =\r\n(v & (ONYX_MUTE_RIGHT|ONYX_MUTE_LEFT))\r\n!= (ONYX_MUTE_RIGHT|ONYX_MUTE_LEFT);\r\nmutex_unlock(&onyx->mutex);\r\nswitch (ti->tag) {\r\ncase 0: return 1;\r\ncase 1: return analog_enabled;\r\ncase 2: return spdif_enabled;\r\n}\r\nreturn 1;\r\n}\r\nstatic int onyx_prepare(struct codec_info_item *cii,\r\nstruct bus_info *bi,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nu8 v;\r\nstruct onyx *onyx = cii->codec_data;\r\nint err = -EBUSY;\r\nmutex_lock(&onyx->mutex);\r\n#ifdef SNDRV_PCM_FMTBIT_COMPRESSED_16BE\r\nif (substream->runtime->format == SNDRV_PCM_FMTBIT_COMPRESSED_16BE) {\r\nonyx_read_register(onyx, ONYX_REG_DAC_CONTROL, &v);\r\nif (onyx_write_register(onyx,\r\nONYX_REG_DAC_CONTROL,\r\nv | ONYX_MUTE_RIGHT | ONYX_MUTE_LEFT))\r\ngoto out_unlock;\r\nonyx->analog_locked = 1;\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\n#endif\r\nswitch (substream->runtime->rate) {\r\ncase 32000:\r\ncase 44100:\r\ncase 48000:\r\nerr = 0;\r\ngoto out_unlock;\r\ndefault:\r\nonyx_read_register(cii->codec_data, ONYX_REG_DIG_INFO4, &v);\r\nif (onyx_write_register(onyx,\r\nONYX_REG_DIG_INFO4,\r\nv & ~ONYX_SPDIF_ENABLE))\r\ngoto out_unlock;\r\nonyx->spdif_locked = 1;\r\nerr = 0;\r\ngoto out_unlock;\r\n}\r\nout_unlock:\r\nmutex_unlock(&onyx->mutex);\r\nreturn err;\r\n}\r\nstatic int onyx_open(struct codec_info_item *cii,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct onyx *onyx = cii->codec_data;\r\nmutex_lock(&onyx->mutex);\r\nonyx->open_count++;\r\nmutex_unlock(&onyx->mutex);\r\nreturn 0;\r\n}\r\nstatic int onyx_close(struct codec_info_item *cii,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstruct onyx *onyx = cii->codec_data;\r\nmutex_lock(&onyx->mutex);\r\nonyx->open_count--;\r\nif (!onyx->open_count)\r\nonyx->spdif_locked = onyx->analog_locked = 0;\r\nmutex_unlock(&onyx->mutex);\r\nreturn 0;\r\n}\r\nstatic int onyx_switch_clock(struct codec_info_item *cii,\r\nenum clock_switch what)\r\n{\r\nstruct onyx *onyx = cii->codec_data;\r\nmutex_lock(&onyx->mutex);\r\nswitch (what) {\r\ncase CLOCK_SWITCH_PREPARE_SLAVE:\r\nonyx->codec.gpio->methods->all_amps_off(onyx->codec.gpio);\r\nbreak;\r\ncase CLOCK_SWITCH_SLAVE:\r\nonyx->codec.gpio->methods->all_amps_restore(onyx->codec.gpio);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&onyx->mutex);\r\nreturn 0;\r\n}\r\nstatic int onyx_suspend(struct codec_info_item *cii, pm_message_t state)\r\n{\r\nstruct onyx *onyx = cii->codec_data;\r\nu8 v;\r\nint err = -ENXIO;\r\nmutex_lock(&onyx->mutex);\r\nif (onyx_read_register(onyx, ONYX_REG_CONTROL, &v))\r\ngoto out_unlock;\r\nonyx_write_register(onyx, ONYX_REG_CONTROL, v | ONYX_ADPSV | ONYX_DAPSV);\r\nerr = 0;\r\nout_unlock:\r\nmutex_unlock(&onyx->mutex);\r\nreturn err;\r\n}\r\nstatic int onyx_resume(struct codec_info_item *cii)\r\n{\r\nstruct onyx *onyx = cii->codec_data;\r\nu8 v;\r\nint err = -ENXIO;\r\nmutex_lock(&onyx->mutex);\r\nonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\r\nmsleep(1);\r\nonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 1);\r\nmsleep(1);\r\nonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\r\nmsleep(1);\r\nif (onyx_read_register(onyx, ONYX_REG_CONTROL, &v))\r\ngoto out_unlock;\r\nonyx_write_register(onyx, ONYX_REG_CONTROL, v & ~(ONYX_ADPSV | ONYX_DAPSV));\r\nmsleep(2205000/8000);\r\nonyx_register_init(onyx);\r\nerr = 0;\r\nout_unlock:\r\nmutex_unlock(&onyx->mutex);\r\nreturn err;\r\n}\r\nstatic int onyx_init_codec(struct aoa_codec *codec)\r\n{\r\nstruct onyx *onyx = codec_to_onyx(codec);\r\nstruct snd_kcontrol *ctl;\r\nstruct codec_info *ci = &onyx_codec_info;\r\nu8 v;\r\nint err;\r\nif (!onyx->codec.gpio || !onyx->codec.gpio->methods) {\r\nprintk(KERN_ERR PFX "gpios not assigned!!\n");\r\nreturn -EINVAL;\r\n}\r\nonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\r\nmsleep(1);\r\nonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 1);\r\nmsleep(1);\r\nonyx->codec.gpio->methods->set_hw_reset(onyx->codec.gpio, 0);\r\nmsleep(1);\r\nif (onyx_register_init(onyx)) {\r\nprintk(KERN_ERR PFX "failed to initialise onyx registers\n");\r\nreturn -ENODEV;\r\n}\r\nif (aoa_snd_device_new(SNDRV_DEV_CODEC, onyx, &ops)) {\r\nprintk(KERN_ERR PFX "failed to create onyx snd device!\n");\r\nreturn -ENODEV;\r\n}\r\nif ((onyx->codec.connected & 0xF) == 0)\r\nreturn -ENOTCONN;\r\nif ((onyx->codec.connected & 0xC) == 0) {\r\nif (!onyx->codec_info)\r\nonyx->codec_info = kmalloc(sizeof(struct codec_info), GFP_KERNEL);\r\nif (!onyx->codec_info)\r\nreturn -ENOMEM;\r\nci = onyx->codec_info;\r\n*ci = onyx_codec_info;\r\nci->transfers++;\r\n}\r\nif ((onyx->codec.connected & 3) == 0) {\r\nif (!onyx->codec_info)\r\nonyx->codec_info = kmalloc(sizeof(struct codec_info), GFP_KERNEL);\r\nif (!onyx->codec_info)\r\nreturn -ENOMEM;\r\nci = onyx->codec_info;\r\n*ci = onyx_codec_info;\r\nci->transfers[1].formats = 0;\r\n}\r\nif (onyx->codec.soundbus_dev->attach_codec(onyx->codec.soundbus_dev,\r\naoa_get_card(),\r\nci, onyx)) {\r\nprintk(KERN_ERR PFX "error creating onyx pcm\n");\r\nreturn -ENODEV;\r\n}\r\n#define ADDCTL(n) \\r\ndo { \\r\nctl = snd_ctl_new1(&n, onyx); \\r\nif (ctl) { \\r\nctl->id.device = \\r\nonyx->codec.soundbus_dev->pcm->device; \\r\nerr = aoa_snd_ctl_add(ctl); \\r\nif (err) \\r\ngoto error; \\r\n} \\r\n} while (0)\r\nif (onyx->codec.soundbus_dev->pcm) {\r\nif ((onyx->codec.connected & 0xC) == 0xC)\r\nADDCTL(capture_source_control);\r\nelse if (onyx->codec.connected & 4)\r\nonyx_set_capture_source(onyx, 0);\r\nelse\r\nonyx_set_capture_source(onyx, 1);\r\nif (onyx->codec.connected & 0xC)\r\nADDCTL(inputgain_control);\r\nif (onyx->codec.connected & 1) {\r\nADDCTL(volume_control);\r\nADDCTL(mute_control);\r\nADDCTL(ovr1_control);\r\nADDCTL(flt0_control);\r\nADDCTL(hpf_control);\r\nADDCTL(dm12_control);\r\n}\r\nif (onyx->codec.connected & 2) {\r\nADDCTL(onyx_spdif_mask);\r\nADDCTL(onyx_spdif_ctrl);\r\n}\r\nif ((onyx->codec.connected & 3) == 3)\r\nADDCTL(spdif_control);\r\nif ((onyx->codec.connected & 3) == 2) {\r\nonyx_read_register(onyx, ONYX_REG_DIG_INFO4, &v);\r\nv |= ONYX_SPDIF_ENABLE;\r\nonyx_write_register(onyx, ONYX_REG_DIG_INFO4, v);\r\n}\r\n}\r\n#undef ADDCTL\r\nprintk(KERN_INFO PFX "attached to onyx codec via i2c\n");\r\nreturn 0;\r\nerror:\r\nonyx->codec.soundbus_dev->detach_codec(onyx->codec.soundbus_dev, onyx);\r\nsnd_device_free(aoa_get_card(), onyx);\r\nreturn err;\r\n}\r\nstatic void onyx_exit_codec(struct aoa_codec *codec)\r\n{\r\nstruct onyx *onyx = codec_to_onyx(codec);\r\nif (!onyx->codec.soundbus_dev) {\r\nprintk(KERN_ERR PFX "onyx_exit_codec called without soundbus_dev!\n");\r\nreturn;\r\n}\r\nonyx->codec.soundbus_dev->detach_codec(onyx->codec.soundbus_dev, onyx);\r\n}\r\nstatic int onyx_i2c_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device_node *node = client->dev.of_node;\r\nstruct onyx *onyx;\r\nu8 dummy;\r\nonyx = kzalloc(sizeof(struct onyx), GFP_KERNEL);\r\nif (!onyx)\r\nreturn -ENOMEM;\r\nmutex_init(&onyx->mutex);\r\nonyx->i2c = client;\r\ni2c_set_clientdata(client, onyx);\r\nif (onyx_read_register(onyx, ONYX_REG_CONTROL, &dummy) != 0) {\r\nprintk(KERN_ERR PFX "failed to read control register\n");\r\ngoto fail;\r\n}\r\nstrlcpy(onyx->codec.name, "onyx", MAX_CODEC_NAME_LEN);\r\nonyx->codec.owner = THIS_MODULE;\r\nonyx->codec.init = onyx_init_codec;\r\nonyx->codec.exit = onyx_exit_codec;\r\nonyx->codec.node = of_node_get(node);\r\nif (aoa_codec_register(&onyx->codec)) {\r\ngoto fail;\r\n}\r\nprintk(KERN_DEBUG PFX "created and attached onyx instance\n");\r\nreturn 0;\r\nfail:\r\nkfree(onyx);\r\nreturn -ENODEV;\r\n}\r\nstatic int onyx_i2c_remove(struct i2c_client *client)\r\n{\r\nstruct onyx *onyx = i2c_get_clientdata(client);\r\naoa_codec_unregister(&onyx->codec);\r\nof_node_put(onyx->codec.node);\r\nkfree(onyx->codec_info);\r\nkfree(onyx);\r\nreturn 0;\r\n}
