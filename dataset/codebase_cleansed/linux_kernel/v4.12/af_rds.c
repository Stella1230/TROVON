static int rds_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rds_sock *rs;\r\nif (!sk)\r\ngoto out;\r\nrs = rds_sk_to_rs(sk);\r\nsock_orphan(sk);\r\nrds_clear_recv_queue(rs);\r\nrds_cong_remove_socket(rs);\r\nrds_remove_bound(rs);\r\nrds_send_drop_to(rs, NULL);\r\nrds_rdma_drop_keys(rs);\r\nrds_notify_queue_get(rs, NULL);\r\nspin_lock_bh(&rds_sock_lock);\r\nlist_del_init(&rs->rs_item);\r\nrds_sock_count--;\r\nspin_unlock_bh(&rds_sock_lock);\r\nrds_trans_put(rs->rs_transport);\r\nsock->sk = NULL;\r\nsock_put(sk);\r\nout:\r\nreturn 0;\r\n}\r\nvoid rds_wake_sk_sleep(struct rds_sock *rs)\r\n{\r\nunsigned long flags;\r\nread_lock_irqsave(&rs->rs_recv_lock, flags);\r\n__rds_wake_sk_sleep(rds_rs_to_sk(rs));\r\nread_unlock_irqrestore(&rs->rs_recv_lock, flags);\r\n}\r\nstatic int rds_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)uaddr;\r\nstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\r\nmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\r\nif (peer) {\r\nif (!rs->rs_conn_addr)\r\nreturn -ENOTCONN;\r\nsin->sin_port = rs->rs_conn_port;\r\nsin->sin_addr.s_addr = rs->rs_conn_addr;\r\n} else {\r\nsin->sin_port = rs->rs_bound_port;\r\nsin->sin_addr.s_addr = rs->rs_bound_addr;\r\n}\r\nsin->sin_family = AF_INET;\r\n*uaddr_len = sizeof(*sin);\r\nreturn 0;\r\n}\r\nstatic unsigned int rds_poll(struct file *file, struct socket *sock,\r\npoll_table *wait)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct rds_sock *rs = rds_sk_to_rs(sk);\r\nunsigned int mask = 0;\r\nunsigned long flags;\r\npoll_wait(file, sk_sleep(sk), wait);\r\nif (rs->rs_seen_congestion)\r\npoll_wait(file, &rds_poll_waitq, wait);\r\nread_lock_irqsave(&rs->rs_recv_lock, flags);\r\nif (!rs->rs_cong_monitor) {\r\nif (rds_cong_updated_since(&rs->rs_cong_track))\r\nmask |= (POLLIN | POLLRDNORM | POLLWRBAND);\r\n} else {\r\nspin_lock(&rs->rs_lock);\r\nif (rs->rs_cong_notify)\r\nmask |= (POLLIN | POLLRDNORM);\r\nspin_unlock(&rs->rs_lock);\r\n}\r\nif (!list_empty(&rs->rs_recv_queue) ||\r\n!list_empty(&rs->rs_notify_queue))\r\nmask |= (POLLIN | POLLRDNORM);\r\nif (rs->rs_snd_bytes < rds_sk_sndbuf(rs))\r\nmask |= (POLLOUT | POLLWRNORM);\r\nread_unlock_irqrestore(&rs->rs_recv_lock, flags);\r\nif (mask)\r\nrs->rs_seen_congestion = 0;\r\nreturn mask;\r\n}\r\nstatic int rds_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\r\n{\r\nreturn -ENOIOCTLCMD;\r\n}\r\nstatic int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,\r\nint len)\r\n{\r\nstruct sockaddr_in sin;\r\nint ret = 0;\r\nif (rs->rs_bound_addr == 0) {\r\nret = -ENOTCONN;\r\ngoto out;\r\n}\r\nif (len < sizeof(struct sockaddr_in)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_from_user(&sin, optval, sizeof(sin))) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nrds_send_drop_to(rs, &sin);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rds_set_bool_option(unsigned char *optvar, char __user *optval,\r\nint optlen)\r\n{\r\nint value;\r\nif (optlen < sizeof(int))\r\nreturn -EINVAL;\r\nif (get_user(value, (int __user *) optval))\r\nreturn -EFAULT;\r\n*optvar = !!value;\r\nreturn 0;\r\n}\r\nstatic int rds_cong_monitor(struct rds_sock *rs, char __user *optval,\r\nint optlen)\r\n{\r\nint ret;\r\nret = rds_set_bool_option(&rs->rs_cong_monitor, optval, optlen);\r\nif (ret == 0) {\r\nif (rs->rs_cong_monitor) {\r\nrds_cong_add_socket(rs);\r\n} else {\r\nrds_cong_remove_socket(rs);\r\nrs->rs_cong_mask = 0;\r\nrs->rs_cong_notify = 0;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int rds_set_transport(struct rds_sock *rs, char __user *optval,\r\nint optlen)\r\n{\r\nint t_type;\r\nif (rs->rs_transport)\r\nreturn -EOPNOTSUPP;\r\nif (optlen != sizeof(int))\r\nreturn -EINVAL;\r\nif (copy_from_user(&t_type, (int __user *)optval, sizeof(t_type)))\r\nreturn -EFAULT;\r\nif (t_type < 0 || t_type >= RDS_TRANS_COUNT)\r\nreturn -EINVAL;\r\nrs->rs_transport = rds_trans_get(t_type);\r\nreturn rs->rs_transport ? 0 : -ENOPROTOOPT;\r\n}\r\nstatic int rds_enable_recvtstamp(struct sock *sk, char __user *optval,\r\nint optlen)\r\n{\r\nint val, valbool;\r\nif (optlen != sizeof(int))\r\nreturn -EFAULT;\r\nif (get_user(val, (int __user *)optval))\r\nreturn -EFAULT;\r\nvalbool = val ? 1 : 0;\r\nif (valbool)\r\nsock_set_flag(sk, SOCK_RCVTSTAMP);\r\nelse\r\nsock_reset_flag(sk, SOCK_RCVTSTAMP);\r\nreturn 0;\r\n}\r\nstatic int rds_recv_track_latency(struct rds_sock *rs, char __user *optval,\r\nint optlen)\r\n{\r\nstruct rds_rx_trace_so trace;\r\nint i;\r\nif (optlen != sizeof(struct rds_rx_trace_so))\r\nreturn -EFAULT;\r\nif (copy_from_user(&trace, optval, sizeof(trace)))\r\nreturn -EFAULT;\r\nif (trace.rx_traces > RDS_MSG_RX_DGRAM_TRACE_MAX)\r\nreturn -EFAULT;\r\nrs->rs_rx_traces = trace.rx_traces;\r\nfor (i = 0; i < rs->rs_rx_traces; i++) {\r\nif (trace.rx_trace_pos[i] > RDS_MSG_RX_DGRAM_TRACE_MAX) {\r\nrs->rs_rx_traces = 0;\r\nreturn -EFAULT;\r\n}\r\nrs->rs_rx_trace[i] = trace.rx_trace_pos[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int rds_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\r\nint ret;\r\nif (level != SOL_RDS) {\r\nret = -ENOPROTOOPT;\r\ngoto out;\r\n}\r\nswitch (optname) {\r\ncase RDS_CANCEL_SENT_TO:\r\nret = rds_cancel_sent_to(rs, optval, optlen);\r\nbreak;\r\ncase RDS_GET_MR:\r\nret = rds_get_mr(rs, optval, optlen);\r\nbreak;\r\ncase RDS_GET_MR_FOR_DEST:\r\nret = rds_get_mr_for_dest(rs, optval, optlen);\r\nbreak;\r\ncase RDS_FREE_MR:\r\nret = rds_free_mr(rs, optval, optlen);\r\nbreak;\r\ncase RDS_RECVERR:\r\nret = rds_set_bool_option(&rs->rs_recverr, optval, optlen);\r\nbreak;\r\ncase RDS_CONG_MONITOR:\r\nret = rds_cong_monitor(rs, optval, optlen);\r\nbreak;\r\ncase SO_RDS_TRANSPORT:\r\nlock_sock(sock->sk);\r\nret = rds_set_transport(rs, optval, optlen);\r\nrelease_sock(sock->sk);\r\nbreak;\r\ncase SO_TIMESTAMP:\r\nlock_sock(sock->sk);\r\nret = rds_enable_recvtstamp(sock->sk, optval, optlen);\r\nrelease_sock(sock->sk);\r\nbreak;\r\ncase SO_RDS_MSG_RXPATH_LATENCY:\r\nret = rds_recv_track_latency(rs, optval, optlen);\r\nbreak;\r\ndefault:\r\nret = -ENOPROTOOPT;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rds_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct rds_sock *rs = rds_sk_to_rs(sock->sk);\r\nint ret = -ENOPROTOOPT, len;\r\nint trans;\r\nif (level != SOL_RDS)\r\ngoto out;\r\nif (get_user(len, optlen)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nswitch (optname) {\r\ncase RDS_INFO_FIRST ... RDS_INFO_LAST:\r\nret = rds_info_getsockopt(sock, optname, optval,\r\noptlen);\r\nbreak;\r\ncase RDS_RECVERR:\r\nif (len < sizeof(int))\r\nret = -EINVAL;\r\nelse\r\nif (put_user(rs->rs_recverr, (int __user *) optval) ||\r\nput_user(sizeof(int), optlen))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\ncase SO_RDS_TRANSPORT:\r\nif (len < sizeof(int)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ntrans = (rs->rs_transport ? rs->rs_transport->t_type :\r\nRDS_TRANS_NONE);\r\nif (put_user(trans, (int __user *)optval) ||\r\nput_user(sizeof(int), optlen))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int rds_connect(struct socket *sock, struct sockaddr *uaddr,\r\nint addr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_in *sin = (struct sockaddr_in *)uaddr;\r\nstruct rds_sock *rs = rds_sk_to_rs(sk);\r\nint ret = 0;\r\nlock_sock(sk);\r\nif (addr_len != sizeof(struct sockaddr_in)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (sin->sin_family != AF_INET) {\r\nret = -EAFNOSUPPORT;\r\ngoto out;\r\n}\r\nif (sin->sin_addr.s_addr == htonl(INADDR_ANY)) {\r\nret = -EDESTADDRREQ;\r\ngoto out;\r\n}\r\nrs->rs_conn_addr = sin->sin_addr.s_addr;\r\nrs->rs_conn_port = sin->sin_port;\r\nout:\r\nrelease_sock(sk);\r\nreturn ret;\r\n}\r\nstatic void rds_sock_destruct(struct sock *sk)\r\n{\r\nstruct rds_sock *rs = rds_sk_to_rs(sk);\r\nWARN_ON((&rs->rs_item != rs->rs_item.next ||\r\n&rs->rs_item != rs->rs_item.prev));\r\n}\r\nstatic int __rds_create(struct socket *sock, struct sock *sk, int protocol)\r\n{\r\nstruct rds_sock *rs;\r\nsock_init_data(sock, sk);\r\nsock->ops = &rds_proto_ops;\r\nsk->sk_protocol = protocol;\r\nsk->sk_destruct = rds_sock_destruct;\r\nrs = rds_sk_to_rs(sk);\r\nspin_lock_init(&rs->rs_lock);\r\nrwlock_init(&rs->rs_recv_lock);\r\nINIT_LIST_HEAD(&rs->rs_send_queue);\r\nINIT_LIST_HEAD(&rs->rs_recv_queue);\r\nINIT_LIST_HEAD(&rs->rs_notify_queue);\r\nINIT_LIST_HEAD(&rs->rs_cong_list);\r\nspin_lock_init(&rs->rs_rdma_lock);\r\nrs->rs_rdma_keys = RB_ROOT;\r\nrs->rs_rx_traces = 0;\r\nspin_lock_bh(&rds_sock_lock);\r\nlist_add_tail(&rs->rs_item, &rds_sock_list);\r\nrds_sock_count++;\r\nspin_unlock_bh(&rds_sock_lock);\r\nreturn 0;\r\n}\r\nstatic int rds_create(struct net *net, struct socket *sock, int protocol,\r\nint kern)\r\n{\r\nstruct sock *sk;\r\nif (sock->type != SOCK_SEQPACKET || protocol)\r\nreturn -ESOCKTNOSUPPORT;\r\nsk = sk_alloc(net, AF_RDS, GFP_ATOMIC, &rds_proto, kern);\r\nif (!sk)\r\nreturn -ENOMEM;\r\nreturn __rds_create(sock, sk, protocol);\r\n}\r\nvoid rds_sock_addref(struct rds_sock *rs)\r\n{\r\nsock_hold(rds_rs_to_sk(rs));\r\n}\r\nvoid rds_sock_put(struct rds_sock *rs)\r\n{\r\nsock_put(rds_rs_to_sk(rs));\r\n}\r\nstatic void rds_sock_inc_info(struct socket *sock, unsigned int len,\r\nstruct rds_info_iterator *iter,\r\nstruct rds_info_lengths *lens)\r\n{\r\nstruct rds_sock *rs;\r\nstruct rds_incoming *inc;\r\nunsigned int total = 0;\r\nlen /= sizeof(struct rds_info_message);\r\nspin_lock_bh(&rds_sock_lock);\r\nlist_for_each_entry(rs, &rds_sock_list, rs_item) {\r\nread_lock(&rs->rs_recv_lock);\r\nlist_for_each_entry(inc, &rs->rs_recv_queue, i_item) {\r\ntotal++;\r\nif (total <= len)\r\nrds_inc_info_copy(inc, iter, inc->i_saddr,\r\nrs->rs_bound_addr, 1);\r\n}\r\nread_unlock(&rs->rs_recv_lock);\r\n}\r\nspin_unlock_bh(&rds_sock_lock);\r\nlens->nr = total;\r\nlens->each = sizeof(struct rds_info_message);\r\n}\r\nstatic void rds_sock_info(struct socket *sock, unsigned int len,\r\nstruct rds_info_iterator *iter,\r\nstruct rds_info_lengths *lens)\r\n{\r\nstruct rds_info_socket sinfo;\r\nstruct rds_sock *rs;\r\nlen /= sizeof(struct rds_info_socket);\r\nspin_lock_bh(&rds_sock_lock);\r\nif (len < rds_sock_count)\r\ngoto out;\r\nlist_for_each_entry(rs, &rds_sock_list, rs_item) {\r\nsinfo.sndbuf = rds_sk_sndbuf(rs);\r\nsinfo.rcvbuf = rds_sk_rcvbuf(rs);\r\nsinfo.bound_addr = rs->rs_bound_addr;\r\nsinfo.connected_addr = rs->rs_conn_addr;\r\nsinfo.bound_port = rs->rs_bound_port;\r\nsinfo.connected_port = rs->rs_conn_port;\r\nsinfo.inum = sock_i_ino(rds_rs_to_sk(rs));\r\nrds_info_copy(iter, &sinfo, sizeof(sinfo));\r\n}\r\nout:\r\nlens->nr = rds_sock_count;\r\nlens->each = sizeof(struct rds_info_socket);\r\nspin_unlock_bh(&rds_sock_lock);\r\n}\r\nstatic void rds_exit(void)\r\n{\r\nsock_unregister(rds_family_ops.family);\r\nproto_unregister(&rds_proto);\r\nrds_conn_exit();\r\nrds_cong_exit();\r\nrds_sysctl_exit();\r\nrds_threads_exit();\r\nrds_stats_exit();\r\nrds_page_exit();\r\nrds_bind_lock_destroy();\r\nrds_info_deregister_func(RDS_INFO_SOCKETS, rds_sock_info);\r\nrds_info_deregister_func(RDS_INFO_RECV_MESSAGES, rds_sock_inc_info);\r\n}\r\nstatic int rds_init(void)\r\n{\r\nint ret;\r\nnet_get_random_once(&rds_gen_num, sizeof(rds_gen_num));\r\nret = rds_bind_lock_init();\r\nif (ret)\r\ngoto out;\r\nret = rds_conn_init();\r\nif (ret)\r\ngoto out_bind;\r\nret = rds_threads_init();\r\nif (ret)\r\ngoto out_conn;\r\nret = rds_sysctl_init();\r\nif (ret)\r\ngoto out_threads;\r\nret = rds_stats_init();\r\nif (ret)\r\ngoto out_sysctl;\r\nret = proto_register(&rds_proto, 1);\r\nif (ret)\r\ngoto out_stats;\r\nret = sock_register(&rds_family_ops);\r\nif (ret)\r\ngoto out_proto;\r\nrds_info_register_func(RDS_INFO_SOCKETS, rds_sock_info);\r\nrds_info_register_func(RDS_INFO_RECV_MESSAGES, rds_sock_inc_info);\r\ngoto out;\r\nout_proto:\r\nproto_unregister(&rds_proto);\r\nout_stats:\r\nrds_stats_exit();\r\nout_sysctl:\r\nrds_sysctl_exit();\r\nout_threads:\r\nrds_threads_exit();\r\nout_conn:\r\nrds_conn_exit();\r\nrds_cong_exit();\r\nrds_page_exit();\r\nout_bind:\r\nrds_bind_lock_destroy();\r\nout:\r\nreturn ret;\r\n}
