static inline int adt7470_read_word_data(struct i2c_client *client, u8 reg)\r\n{\r\nu16 foo;\r\nfoo = i2c_smbus_read_byte_data(client, reg);\r\nfoo |= ((u16)i2c_smbus_read_byte_data(client, reg + 1) << 8);\r\nreturn foo;\r\n}\r\nstatic inline int adt7470_write_word_data(struct i2c_client *client, u8 reg,\r\nu16 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, value & 0xFF)\r\n|| i2c_smbus_write_byte_data(client, reg + 1, value >> 8);\r\n}\r\nstatic int adt7470_read_temperatures(struct i2c_client *client,\r\nstruct adt7470_data *data)\r\n{\r\nunsigned long res;\r\nint i;\r\nu8 cfg, pwm[4], pwm_cfg[2];\r\npwm_cfg[0] = i2c_smbus_read_byte_data(client, ADT7470_REG_PWM_CFG(0));\r\npwm_cfg[1] = i2c_smbus_read_byte_data(client, ADT7470_REG_PWM_CFG(2));\r\nfor (i = 0; i < ADT7470_FAN_COUNT; i++)\r\npwm[i] = i2c_smbus_read_byte_data(client, ADT7470_REG_PWM(i));\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_CFG(0),\r\npwm_cfg[0] & ~(ADT7470_PWM_AUTO_MASK));\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_CFG(2),\r\npwm_cfg[1] & ~(ADT7470_PWM_AUTO_MASK));\r\nfor (i = 0; i < ADT7470_FAN_COUNT; i++)\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM(i), pwm[i]);\r\ncfg = i2c_smbus_read_byte_data(client, ADT7470_REG_CFG);\r\ncfg |= 0x80;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_CFG, cfg);\r\nres = msleep_interruptible((data->num_temp_sensors >= 0 ?\r\ndata->num_temp_sensors * 200 :\r\nTEMP_COLLECTION_TIME));\r\ncfg = i2c_smbus_read_byte_data(client, ADT7470_REG_CFG);\r\ncfg &= ~0x80;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_CFG, cfg);\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_CFG(0), pwm_cfg[0]);\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_CFG(2), pwm_cfg[1]);\r\nif (res) {\r\npr_err("ha ha, interrupted\n");\r\nreturn -EAGAIN;\r\n}\r\nif (data->num_temp_sensors >= 0)\r\nreturn 0;\r\nfor (i = 0; i < ADT7470_TEMP_COUNT; i++) {\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_TEMP_REG(i));\r\nif (data->temp[i])\r\ndata->num_temp_sensors = i + 1;\r\n}\r\ndata->temperatures_probed = 1;\r\nreturn 0;\r\n}\r\nstatic int adt7470_update_thread(void *p)\r\n{\r\nstruct i2c_client *client = p;\r\nstruct adt7470_data *data = i2c_get_clientdata(client);\r\nwhile (!kthread_should_stop()) {\r\nmutex_lock(&data->lock);\r\nadt7470_read_temperatures(client, data);\r\nmutex_unlock(&data->lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nif (kthread_should_stop())\r\nbreak;\r\nschedule_timeout(msecs_to_jiffies(data->auto_update_interval));\r\n}\r\nreturn 0;\r\n}\r\nstatic struct adt7470_data *adt7470_update_device(struct device *dev)\r\n{\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nunsigned long local_jiffies = jiffies;\r\nu8 cfg;\r\nint i;\r\nint need_sensors = 1;\r\nint need_limits = 1;\r\nif (time_before(local_jiffies, data->sensors_last_updated +\r\nSENSOR_REFRESH_INTERVAL) &&\r\ndata->sensors_valid)\r\nneed_sensors = 0;\r\nif (time_before(local_jiffies, data->limits_last_updated +\r\nLIMIT_REFRESH_INTERVAL) &&\r\ndata->limits_valid)\r\nneed_limits = 0;\r\nif (!need_sensors && !need_limits)\r\nreturn data;\r\nmutex_lock(&data->lock);\r\nif (!need_sensors)\r\ngoto no_sensor_update;\r\nif (!data->temperatures_probed)\r\nadt7470_read_temperatures(client, data);\r\nelse\r\nfor (i = 0; i < ADT7470_TEMP_COUNT; i++)\r\ndata->temp[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_TEMP_REG(i));\r\nfor (i = 0; i < ADT7470_FAN_COUNT; i++)\r\ndata->fan[i] = adt7470_read_word_data(client,\r\nADT7470_REG_FAN(i));\r\nfor (i = 0; i < ADT7470_PWM_COUNT; i++) {\r\nint reg;\r\nint reg_mask;\r\ndata->pwm[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_REG_PWM(i));\r\nif (i % 2)\r\nreg_mask = ADT7470_PWM2_AUTO_MASK;\r\nelse\r\nreg_mask = ADT7470_PWM1_AUTO_MASK;\r\nreg = ADT7470_REG_PWM_CFG(i);\r\nif (i2c_smbus_read_byte_data(client, reg) & reg_mask)\r\ndata->pwm_automatic[i] = 1;\r\nelse\r\ndata->pwm_automatic[i] = 0;\r\nreg = ADT7470_REG_PWM_AUTO_TEMP(i);\r\ncfg = i2c_smbus_read_byte_data(client, reg);\r\nif (!(i % 2))\r\ndata->pwm_auto_temp[i] = cfg >> 4;\r\nelse\r\ndata->pwm_auto_temp[i] = cfg & 0xF;\r\n}\r\nif (i2c_smbus_read_byte_data(client, ADT7470_REG_CFG) &\r\nADT7470_FSPD_MASK)\r\ndata->force_pwm_max = 1;\r\nelse\r\ndata->force_pwm_max = 0;\r\ndata->alarm = i2c_smbus_read_byte_data(client, ADT7470_REG_ALARM1);\r\nif (data->alarm & ADT7470_OOL_ALARM)\r\ndata->alarm |= ALARM2(i2c_smbus_read_byte_data(client,\r\nADT7470_REG_ALARM2));\r\ndata->alarms_mask = adt7470_read_word_data(client,\r\nADT7470_REG_ALARM1_MASK);\r\ndata->sensors_last_updated = local_jiffies;\r\ndata->sensors_valid = 1;\r\nno_sensor_update:\r\nif (!need_limits)\r\ngoto out;\r\nfor (i = 0; i < ADT7470_TEMP_COUNT; i++) {\r\ndata->temp_min[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_TEMP_MIN_REG(i));\r\ndata->temp_max[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_TEMP_MAX_REG(i));\r\n}\r\nfor (i = 0; i < ADT7470_FAN_COUNT; i++) {\r\ndata->fan_min[i] = adt7470_read_word_data(client,\r\nADT7470_REG_FAN_MIN(i));\r\ndata->fan_max[i] = adt7470_read_word_data(client,\r\nADT7470_REG_FAN_MAX(i));\r\n}\r\nfor (i = 0; i < ADT7470_PWM_COUNT; i++) {\r\ndata->pwm_max[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_REG_PWM_MAX(i));\r\ndata->pwm_min[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_REG_PWM_MIN(i));\r\ndata->pwm_tmin[i] = i2c_smbus_read_byte_data(client,\r\nADT7470_REG_PWM_TMIN(i));\r\n}\r\ndata->limits_last_updated = local_jiffies;\r\ndata->limits_valid = 1;\r\nout:\r\nmutex_unlock(&data->lock);\r\nreturn data;\r\n}\r\nstatic ssize_t auto_update_interval_show(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->auto_update_interval);\r\n}\r\nstatic ssize_t auto_update_interval_store(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, 0, 60000);\r\nmutex_lock(&data->lock);\r\ndata->auto_update_interval = temp;\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t num_temp_sensors_show(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->num_temp_sensors);\r\n}\r\nstatic ssize_t num_temp_sensors_store(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, -1, 10);\r\nmutex_lock(&data->lock);\r\ndata->num_temp_sensors = temp;\r\nif (temp < 0)\r\ndata->temperatures_probed = 0;\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 * data->temp_min[attr->index]);\r\n}\r\nstatic ssize_t set_temp_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, -128000, 127000);\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000);\r\nmutex_lock(&data->lock);\r\ndata->temp_min[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7470_TEMP_MIN_REG(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 * data->temp_max[attr->index]);\r\n}\r\nstatic ssize_t set_temp_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, -128000, 127000);\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000);\r\nmutex_lock(&data->lock);\r\ndata->temp_max[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7470_TEMP_MAX_REG(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_temp(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 * data->temp[attr->index]);\r\n}\r\nstatic ssize_t alarm_mask_show(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%x\n", data->alarms_mask);\r\n}\r\nstatic ssize_t alarm_mask_store(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nlong mask;\r\nif (kstrtoul(buf, 0, &mask))\r\nreturn -EINVAL;\r\nif (mask & ~0xffff)\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->alarms_mask = mask;\r\nadt7470_write_word_data(data->client, ADT7470_REG_ALARM1_MASK, mask);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nif (FAN_DATA_VALID(data->fan_max[attr->index]))\r\nreturn sprintf(buf, "%d\n",\r\nFAN_PERIOD_TO_RPM(data->fan_max[attr->index]));\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t set_fan_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp) || !temp)\r\nreturn -EINVAL;\r\ntemp = FAN_RPM_TO_PERIOD(temp);\r\ntemp = clamp_val(temp, 1, 65534);\r\nmutex_lock(&data->lock);\r\ndata->fan_max[attr->index] = temp;\r\nadt7470_write_word_data(client, ADT7470_REG_FAN_MAX(attr->index), temp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nif (FAN_DATA_VALID(data->fan_min[attr->index]))\r\nreturn sprintf(buf, "%d\n",\r\nFAN_PERIOD_TO_RPM(data->fan_min[attr->index]));\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp) || !temp)\r\nreturn -EINVAL;\r\ntemp = FAN_RPM_TO_PERIOD(temp);\r\ntemp = clamp_val(temp, 1, 65534);\r\nmutex_lock(&data->lock);\r\ndata->fan_min[attr->index] = temp;\r\nadt7470_write_word_data(client, ADT7470_REG_FAN_MIN(attr->index), temp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_fan(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nif (FAN_DATA_VALID(data->fan[attr->index]))\r\nreturn sprintf(buf, "%d\n",\r\nFAN_PERIOD_TO_RPM(data->fan[attr->index]));\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t show_force_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->force_pwm_max);\r\n}\r\nstatic ssize_t set_force_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\nmutex_lock(&data->lock);\r\ndata->force_pwm_max = temp;\r\nreg = i2c_smbus_read_byte_data(client, ADT7470_REG_CFG);\r\nif (temp)\r\nreg |= ADT7470_FSPD_MASK;\r\nelse\r\nreg &= ~ADT7470_FSPD_MASK;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_CFG, reg);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm(struct device *dev, struct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm[attr->index]);\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM(attr->index), temp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t pwm1_freq_show(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nunsigned char cfg_reg_1;\r\nunsigned char cfg_reg_2;\r\nint index;\r\nmutex_lock(&data->lock);\r\ncfg_reg_1 = i2c_smbus_read_byte_data(data->client, ADT7470_REG_CFG);\r\ncfg_reg_2 = i2c_smbus_read_byte_data(data->client, ADT7470_REG_CFG_2);\r\nmutex_unlock(&data->lock);\r\nindex = (cfg_reg_2 & ADT7470_FREQ_MASK) >> ADT7470_FREQ_SHIFT;\r\nif (!(cfg_reg_1 & ADT7470_CFG_LF))\r\nindex += 8;\r\nif (index >= ARRAY_SIZE(adt7470_freq_map))\r\nindex = ARRAY_SIZE(adt7470_freq_map) - 1;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", adt7470_freq_map[index]);\r\n}\r\nstatic ssize_t pwm1_freq_store(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong freq;\r\nint index;\r\nint low_freq = ADT7470_CFG_LF;\r\nunsigned char val;\r\nif (kstrtol(buf, 10, &freq))\r\nreturn -EINVAL;\r\nindex = find_closest(freq, adt7470_freq_map,\r\nARRAY_SIZE(adt7470_freq_map));\r\nif (index >= 8) {\r\nindex -= 8;\r\nlow_freq = 0;\r\n}\r\nmutex_lock(&data->lock);\r\nval = i2c_smbus_read_byte_data(client, ADT7470_REG_CFG);\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_CFG,\r\n(val & ~ADT7470_CFG_LF) | low_freq);\r\nval = i2c_smbus_read_byte_data(client, ADT7470_REG_CFG_2);\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_CFG_2,\r\n(val & ~ADT7470_FREQ_MASK) | (index << ADT7470_FREQ_SHIFT));\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_max[attr->index]);\r\n}\r\nstatic ssize_t set_pwm_max(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm_max[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_MAX(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", data->pwm_min[attr->index]);\r\n}\r\nstatic ssize_t set_pwm_min(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, 0, 255);\r\nmutex_lock(&data->lock);\r\ndata->pwm_min[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_MIN(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_tmax(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 * (20 + data->pwm_tmin[attr->index]));\r\n}\r\nstatic ssize_t show_pwm_tmin(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1000 * data->pwm_tmin[attr->index]);\r\n}\r\nstatic ssize_t set_pwm_tmin(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nlong temp;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = clamp_val(temp, -128000, 127000);\r\ntemp = DIV_ROUND_CLOSEST(temp, 1000);\r\nmutex_lock(&data->lock);\r\ndata->pwm_tmin[attr->index] = temp;\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_PWM_TMIN(attr->index),\r\ntemp);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nreturn sprintf(buf, "%d\n", 1 + data->pwm_automatic[attr->index]);\r\n}\r\nstatic ssize_t set_pwm_auto(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint pwm_auto_reg = ADT7470_REG_PWM_CFG(attr->index);\r\nint pwm_auto_reg_mask;\r\nlong temp;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\nif (attr->index % 2)\r\npwm_auto_reg_mask = ADT7470_PWM2_AUTO_MASK;\r\nelse\r\npwm_auto_reg_mask = ADT7470_PWM1_AUTO_MASK;\r\nif (temp != 2 && temp != 1)\r\nreturn -EINVAL;\r\ntemp--;\r\nmutex_lock(&data->lock);\r\ndata->pwm_automatic[attr->index] = temp;\r\nreg = i2c_smbus_read_byte_data(client, pwm_auto_reg);\r\nif (temp)\r\nreg |= pwm_auto_reg_mask;\r\nelse\r\nreg &= ~pwm_auto_reg_mask;\r\ni2c_smbus_write_byte_data(client, pwm_auto_reg, reg);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_pwm_auto_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nu8 ctrl = data->pwm_auto_temp[attr->index];\r\nif (ctrl)\r\nreturn sprintf(buf, "%d\n", 1 << (ctrl - 1));\r\nelse\r\nreturn sprintf(buf, "%d\n", ADT7470_PWM_ALL_TEMPS);\r\n}\r\nstatic int cvt_auto_temp(int input)\r\n{\r\nif (input == ADT7470_PWM_ALL_TEMPS)\r\nreturn 0;\r\nif (input < 1 || !is_power_of_2(input))\r\nreturn -EINVAL;\r\nreturn ilog2(input) + 1;\r\n}\r\nstatic ssize_t set_pwm_auto_temp(struct device *dev,\r\nstruct device_attribute *devattr,\r\nconst char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint pwm_auto_reg = ADT7470_REG_PWM_AUTO_TEMP(attr->index);\r\nlong temp;\r\nu8 reg;\r\nif (kstrtol(buf, 10, &temp))\r\nreturn -EINVAL;\r\ntemp = cvt_auto_temp(temp);\r\nif (temp < 0)\r\nreturn temp;\r\nmutex_lock(&data->lock);\r\ndata->pwm_automatic[attr->index] = temp;\r\nreg = i2c_smbus_read_byte_data(client, pwm_auto_reg);\r\nif (!(attr->index % 2)) {\r\nreg &= 0xF;\r\nreg |= (temp << 4) & 0xF0;\r\n} else {\r\nreg &= 0xF0;\r\nreg |= temp & 0xF;\r\n}\r\ni2c_smbus_write_byte_data(client, pwm_auto_reg, reg);\r\nmutex_unlock(&data->lock);\r\nreturn count;\r\n}\r\nstatic ssize_t show_alarm(struct device *dev,\r\nstruct device_attribute *devattr,\r\nchar *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct adt7470_data *data = adt7470_update_device(dev);\r\nif (data->alarm & attr->index)\r\nreturn sprintf(buf, "1\n");\r\nelse\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic int adt7470_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint vendor, device, revision;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nvendor = i2c_smbus_read_byte_data(client, ADT7470_REG_VENDOR);\r\nif (vendor != ADT7470_VENDOR)\r\nreturn -ENODEV;\r\ndevice = i2c_smbus_read_byte_data(client, ADT7470_REG_DEVICE);\r\nif (device != ADT7470_DEVICE)\r\nreturn -ENODEV;\r\nrevision = i2c_smbus_read_byte_data(client, ADT7470_REG_REVISION);\r\nif (revision != ADT7470_REVISION)\r\nreturn -ENODEV;\r\nstrlcpy(info->type, "adt7470", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic void adt7470_init_client(struct i2c_client *client)\r\n{\r\nint reg = i2c_smbus_read_byte_data(client, ADT7470_REG_CFG);\r\nif (reg < 0) {\r\ndev_err(&client->dev, "cannot read configuration register\n");\r\n} else {\r\ni2c_smbus_write_byte_data(client, ADT7470_REG_CFG, reg | 3);\r\n}\r\n}\r\nstatic int adt7470_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct adt7470_data *data;\r\nstruct device *hwmon_dev;\r\ndata = devm_kzalloc(dev, sizeof(struct adt7470_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->num_temp_sensors = -1;\r\ndata->auto_update_interval = AUTO_UPDATE_INTERVAL;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->lock);\r\ndev_info(&client->dev, "%s chip found\n", client->name);\r\nadt7470_init_client(client);\r\nhwmon_dev = devm_hwmon_device_register_with_groups(dev, client->name,\r\ndata,\r\nadt7470_groups);\r\nif (IS_ERR(hwmon_dev))\r\nreturn PTR_ERR(hwmon_dev);\r\ndata->auto_update = kthread_run(adt7470_update_thread, client, "%s",\r\ndev_name(hwmon_dev));\r\nif (IS_ERR(data->auto_update)) {\r\nreturn PTR_ERR(data->auto_update);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adt7470_remove(struct i2c_client *client)\r\n{\r\nstruct adt7470_data *data = i2c_get_clientdata(client);\r\nkthread_stop(data->auto_update);\r\nreturn 0;\r\n}
