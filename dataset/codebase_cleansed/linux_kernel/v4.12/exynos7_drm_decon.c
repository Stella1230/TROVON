static void decon_wait_for_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nif (ctx->suspended)\r\nreturn;\r\natomic_set(&ctx->wait_vsync_event, 1);\r\nif (!wait_event_timeout(ctx->wait_vsync_queue,\r\n!atomic_read(&ctx->wait_vsync_event),\r\nHZ/20))\r\nDRM_DEBUG_KMS("vblank wait timed out.\n");\r\n}\r\nstatic void decon_clear_channels(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nunsigned int win, ch_enabled = 0;\r\nDRM_DEBUG_KMS("%s\n", __FILE__);\r\nfor (win = 0; win < WINDOWS_NR; win++) {\r\nu32 val = readl(ctx->regs + WINCON(win));\r\nif (val & WINCONx_ENWIN) {\r\nval &= ~WINCONx_ENWIN;\r\nwritel(val, ctx->regs + WINCON(win));\r\nch_enabled = 1;\r\n}\r\n}\r\nif (ch_enabled)\r\ndecon_wait_for_vblank(ctx->crtc);\r\n}\r\nstatic int decon_ctx_initialize(struct decon_context *ctx,\r\nstruct drm_device *drm_dev)\r\n{\r\nstruct exynos_drm_private *priv = drm_dev->dev_private;\r\nint ret;\r\nctx->drm_dev = drm_dev;\r\nctx->pipe = priv->pipe++;\r\ndecon_clear_channels(ctx->crtc);\r\nret = drm_iommu_attach_device(drm_dev, ctx->dev);\r\nif (ret)\r\npriv->pipe--;\r\nreturn ret;\r\n}\r\nstatic void decon_ctx_remove(struct decon_context *ctx)\r\n{\r\ndrm_iommu_detach_device(ctx->drm_dev, ctx->dev);\r\n}\r\nstatic u32 decon_calc_clkdiv(struct decon_context *ctx,\r\nconst struct drm_display_mode *mode)\r\n{\r\nunsigned long ideal_clk = mode->htotal * mode->vtotal * mode->vrefresh;\r\nu32 clkdiv;\r\nclkdiv = DIV_ROUND_UP(clk_get_rate(ctx->vclk), ideal_clk);\r\nreturn (clkdiv < 0x100) ? clkdiv : 0xff;\r\n}\r\nstatic void decon_commit(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nstruct drm_display_mode *mode = &crtc->base.state->adjusted_mode;\r\nu32 val, clkdiv;\r\nif (ctx->suspended)\r\nreturn;\r\nif (mode->htotal == 0 || mode->vtotal == 0)\r\nreturn;\r\nif (!ctx->i80_if) {\r\nint vsync_len, vbpd, vfpd, hsync_len, hbpd, hfpd;\r\nvsync_len = mode->crtc_vsync_end - mode->crtc_vsync_start;\r\nvbpd = mode->crtc_vtotal - mode->crtc_vsync_end;\r\nvfpd = mode->crtc_vsync_start - mode->crtc_vdisplay;\r\nval = VIDTCON0_VBPD(vbpd - 1) | VIDTCON0_VFPD(vfpd - 1);\r\nwritel(val, ctx->regs + VIDTCON0);\r\nval = VIDTCON1_VSPW(vsync_len - 1);\r\nwritel(val, ctx->regs + VIDTCON1);\r\nhsync_len = mode->crtc_hsync_end - mode->crtc_hsync_start;\r\nhbpd = mode->crtc_htotal - mode->crtc_hsync_end;\r\nhfpd = mode->crtc_hsync_start - mode->crtc_hdisplay;\r\nval = VIDTCON2_HBPD(hbpd - 1) | VIDTCON2_HFPD(hfpd - 1);\r\nwritel(val, ctx->regs + VIDTCON2);\r\nval = VIDTCON3_HSPW(hsync_len - 1);\r\nwritel(val, ctx->regs + VIDTCON3);\r\n}\r\nval = VIDTCON4_LINEVAL(mode->vdisplay - 1) |\r\nVIDTCON4_HOZVAL(mode->hdisplay - 1);\r\nwritel(val, ctx->regs + VIDTCON4);\r\nwritel(mode->vdisplay - 1, ctx->regs + LINECNT_OP_THRESHOLD);\r\nval = VIDCON0_ENVID | VIDCON0_ENVID_F;\r\nwritel(val, ctx->regs + VIDCON0);\r\nclkdiv = decon_calc_clkdiv(ctx, mode);\r\nif (clkdiv > 1) {\r\nval = VCLKCON1_CLKVAL_NUM_VCLK(clkdiv - 1);\r\nwritel(val, ctx->regs + VCLKCON1);\r\nwritel(val, ctx->regs + VCLKCON2);\r\n}\r\nval = readl(ctx->regs + DECON_UPDATE);\r\nval |= DECON_UPDATE_STANDALONE_F;\r\nwritel(val, ctx->regs + DECON_UPDATE);\r\n}\r\nstatic int decon_enable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn -EPERM;\r\nif (!test_and_set_bit(0, &ctx->irq_flags)) {\r\nval = readl(ctx->regs + VIDINTCON0);\r\nval |= VIDINTCON0_INT_ENABLE;\r\nif (!ctx->i80_if) {\r\nval |= VIDINTCON0_INT_FRAME;\r\nval &= ~VIDINTCON0_FRAMESEL0_MASK;\r\nval |= VIDINTCON0_FRAMESEL0_VSYNC;\r\n}\r\nwritel(val, ctx->regs + VIDINTCON0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void decon_disable_vblank(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn;\r\nif (test_and_clear_bit(0, &ctx->irq_flags)) {\r\nval = readl(ctx->regs + VIDINTCON0);\r\nval &= ~VIDINTCON0_INT_ENABLE;\r\nif (!ctx->i80_if)\r\nval &= ~VIDINTCON0_INT_FRAME;\r\nwritel(val, ctx->regs + VIDINTCON0);\r\n}\r\n}\r\nstatic void decon_win_set_pixfmt(struct decon_context *ctx, unsigned int win,\r\nstruct drm_framebuffer *fb)\r\n{\r\nunsigned long val;\r\nint padding;\r\nval = readl(ctx->regs + WINCON(win));\r\nval &= ~WINCONx_BPPMODE_MASK;\r\nswitch (fb->format->format) {\r\ncase DRM_FORMAT_RGB565:\r\nval |= WINCONx_BPPMODE_16BPP_565;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\nval |= WINCONx_BPPMODE_24BPP_xRGB;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_XBGR8888:\r\nval |= WINCONx_BPPMODE_24BPP_xBGR;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_RGBX8888:\r\nval |= WINCONx_BPPMODE_24BPP_RGBx;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_BGRX8888:\r\nval |= WINCONx_BPPMODE_24BPP_BGRx;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_ARGB8888:\r\nval |= WINCONx_BPPMODE_32BPP_ARGB | WINCONx_BLD_PIX |\r\nWINCONx_ALPHA_SEL;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_ABGR8888:\r\nval |= WINCONx_BPPMODE_32BPP_ABGR | WINCONx_BLD_PIX |\r\nWINCONx_ALPHA_SEL;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_RGBA8888:\r\nval |= WINCONx_BPPMODE_32BPP_RGBA | WINCONx_BLD_PIX |\r\nWINCONx_ALPHA_SEL;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ncase DRM_FORMAT_BGRA8888:\r\nval |= WINCONx_BPPMODE_32BPP_BGRA | WINCONx_BLD_PIX |\r\nWINCONx_ALPHA_SEL;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\ndefault:\r\nDRM_DEBUG_KMS("invalid pixel size so using unpacked 24bpp.\n");\r\nval |= WINCONx_BPPMODE_24BPP_xRGB;\r\nval |= WINCONx_BURSTLEN_16WORD;\r\nbreak;\r\n}\r\nDRM_DEBUG_KMS("bpp = %d\n", fb->format->cpp[0] * 8);\r\npadding = (fb->pitches[0] / fb->format->cpp[0]) - fb->width;\r\nif (fb->width + padding < MIN_FB_WIDTH_FOR_16WORD_BURST) {\r\nval &= ~WINCONx_BURSTLEN_MASK;\r\nval |= WINCONx_BURSTLEN_8WORD;\r\n}\r\nwritel(val, ctx->regs + WINCON(win));\r\n}\r\nstatic void decon_win_set_colkey(struct decon_context *ctx, unsigned int win)\r\n{\r\nunsigned int keycon0 = 0, keycon1 = 0;\r\nkeycon0 = ~(WxKEYCON0_KEYBL_EN | WxKEYCON0_KEYEN_F |\r\nWxKEYCON0_DIRCON) | WxKEYCON0_COMPKEY(0);\r\nkeycon1 = WxKEYCON1_COLVAL(0xffffffff);\r\nwritel(keycon0, ctx->regs + WKEYCON0_BASE(win));\r\nwritel(keycon1, ctx->regs + WKEYCON1_BASE(win));\r\n}\r\nstatic void decon_shadow_protect_win(struct decon_context *ctx,\r\nunsigned int win, bool protect)\r\n{\r\nu32 bits, val;\r\nbits = SHADOWCON_WINx_PROTECT(win);\r\nval = readl(ctx->regs + SHADOWCON);\r\nif (protect)\r\nval |= bits;\r\nelse\r\nval &= ~bits;\r\nwritel(val, ctx->regs + SHADOWCON);\r\n}\r\nstatic void decon_atomic_begin(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint i;\r\nif (ctx->suspended)\r\nreturn;\r\nfor (i = 0; i < WINDOWS_NR; i++)\r\ndecon_shadow_protect_win(ctx, i, true);\r\n}\r\nstatic void decon_update_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct exynos_drm_plane_state *state =\r\nto_exynos_plane_state(plane->base.state);\r\nstruct decon_context *ctx = crtc->ctx;\r\nstruct drm_framebuffer *fb = state->base.fb;\r\nint padding;\r\nunsigned long val, alpha;\r\nunsigned int last_x;\r\nunsigned int last_y;\r\nunsigned int win = plane->index;\r\nunsigned int bpp = fb->format->cpp[0];\r\nunsigned int pitch = fb->pitches[0];\r\nif (ctx->suspended)\r\nreturn;\r\nval = (unsigned long)exynos_drm_fb_dma_addr(fb, 0);\r\nwritel(val, ctx->regs + VIDW_BUF_START(win));\r\npadding = (pitch / bpp) - fb->width;\r\nwritel(fb->width + padding, ctx->regs + VIDW_WHOLE_X(win));\r\nwritel(fb->height, ctx->regs + VIDW_WHOLE_Y(win));\r\nwritel(state->src.x, ctx->regs + VIDW_OFFSET_X(win));\r\nwritel(state->src.y, ctx->regs + VIDW_OFFSET_Y(win));\r\nDRM_DEBUG_KMS("start addr = 0x%lx\n",\r\n(unsigned long)val);\r\nDRM_DEBUG_KMS("ovl_width = %d, ovl_height = %d\n",\r\nstate->crtc.w, state->crtc.h);\r\nval = VIDOSDxA_TOPLEFT_X(state->crtc.x) |\r\nVIDOSDxA_TOPLEFT_Y(state->crtc.y);\r\nwritel(val, ctx->regs + VIDOSD_A(win));\r\nlast_x = state->crtc.x + state->crtc.w;\r\nif (last_x)\r\nlast_x--;\r\nlast_y = state->crtc.y + state->crtc.h;\r\nif (last_y)\r\nlast_y--;\r\nval = VIDOSDxB_BOTRIGHT_X(last_x) | VIDOSDxB_BOTRIGHT_Y(last_y);\r\nwritel(val, ctx->regs + VIDOSD_B(win));\r\nDRM_DEBUG_KMS("osd pos: tx = %d, ty = %d, bx = %d, by = %d\n",\r\nstate->crtc.x, state->crtc.y, last_x, last_y);\r\nalpha = VIDOSDxC_ALPHA0_R_F(0x0) |\r\nVIDOSDxC_ALPHA0_G_F(0x0) |\r\nVIDOSDxC_ALPHA0_B_F(0x0);\r\nwritel(alpha, ctx->regs + VIDOSD_C(win));\r\nalpha = VIDOSDxD_ALPHA1_R_F(0xff) |\r\nVIDOSDxD_ALPHA1_G_F(0xff) |\r\nVIDOSDxD_ALPHA1_B_F(0xff);\r\nwritel(alpha, ctx->regs + VIDOSD_D(win));\r\ndecon_win_set_pixfmt(ctx, win, fb);\r\nif (win != 0)\r\ndecon_win_set_colkey(ctx, win);\r\nval = readl(ctx->regs + WINCON(win));\r\nval |= WINCONx_TRIPLE_BUF_MODE;\r\nval |= WINCONx_ENWIN;\r\nwritel(val, ctx->regs + WINCON(win));\r\ndecon_shadow_protect_win(ctx, win, false);\r\nval = readl(ctx->regs + DECON_UPDATE);\r\nval |= DECON_UPDATE_STANDALONE_F;\r\nwritel(val, ctx->regs + DECON_UPDATE);\r\n}\r\nstatic void decon_disable_plane(struct exynos_drm_crtc *crtc,\r\nstruct exynos_drm_plane *plane)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nunsigned int win = plane->index;\r\nu32 val;\r\nif (ctx->suspended)\r\nreturn;\r\ndecon_shadow_protect_win(ctx, win, true);\r\nval = readl(ctx->regs + WINCON(win));\r\nval &= ~WINCONx_ENWIN;\r\nwritel(val, ctx->regs + WINCON(win));\r\nval = readl(ctx->regs + DECON_UPDATE);\r\nval |= DECON_UPDATE_STANDALONE_F;\r\nwritel(val, ctx->regs + DECON_UPDATE);\r\n}\r\nstatic void decon_atomic_flush(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint i;\r\nif (ctx->suspended)\r\nreturn;\r\nfor (i = 0; i < WINDOWS_NR; i++)\r\ndecon_shadow_protect_win(ctx, i, false);\r\nexynos_crtc_handle_event(crtc);\r\n}\r\nstatic void decon_init(struct decon_context *ctx)\r\n{\r\nu32 val;\r\nwritel(VIDCON0_SWRESET, ctx->regs + VIDCON0);\r\nval = VIDOUTCON0_DISP_IF_0_ON;\r\nif (!ctx->i80_if)\r\nval |= VIDOUTCON0_RGBIF;\r\nwritel(val, ctx->regs + VIDOUTCON0);\r\nwritel(VCLKCON0_CLKVALUP | VCLKCON0_VCLKFREE, ctx->regs + VCLKCON0);\r\nif (!ctx->i80_if)\r\nwritel(VIDCON1_VCLK_HOLD, ctx->regs + VIDCON1(0));\r\n}\r\nstatic void decon_enable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nif (!ctx->suspended)\r\nreturn;\r\npm_runtime_get_sync(ctx->dev);\r\ndecon_init(ctx);\r\nif (test_and_clear_bit(0, &ctx->irq_flags))\r\ndecon_enable_vblank(ctx->crtc);\r\ndecon_commit(ctx->crtc);\r\nctx->suspended = false;\r\n}\r\nstatic void decon_disable(struct exynos_drm_crtc *crtc)\r\n{\r\nstruct decon_context *ctx = crtc->ctx;\r\nint i;\r\nif (ctx->suspended)\r\nreturn;\r\nfor (i = 0; i < WINDOWS_NR; i++)\r\ndecon_disable_plane(crtc, &ctx->planes[i]);\r\npm_runtime_put_sync(ctx->dev);\r\nctx->suspended = true;\r\n}\r\nstatic irqreturn_t decon_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct decon_context *ctx = (struct decon_context *)dev_id;\r\nu32 val, clear_bit;\r\nval = readl(ctx->regs + VIDINTCON1);\r\nclear_bit = ctx->i80_if ? VIDINTCON1_INT_I80 : VIDINTCON1_INT_FRAME;\r\nif (val & clear_bit)\r\nwritel(clear_bit, ctx->regs + VIDINTCON1);\r\nif (ctx->pipe < 0 || !ctx->drm_dev)\r\ngoto out;\r\nif (!ctx->i80_if) {\r\ndrm_crtc_handle_vblank(&ctx->crtc->base);\r\nif (atomic_read(&ctx->wait_vsync_event)) {\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nwake_up(&ctx->wait_vsync_queue);\r\n}\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int decon_bind(struct device *dev, struct device *master, void *data)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\nstruct drm_device *drm_dev = data;\r\nstruct exynos_drm_plane *exynos_plane;\r\nunsigned int i;\r\nint ret;\r\nret = decon_ctx_initialize(ctx, drm_dev);\r\nif (ret) {\r\nDRM_ERROR("decon_ctx_initialize failed.\n");\r\nreturn ret;\r\n}\r\nfor (i = 0; i < WINDOWS_NR; i++) {\r\nctx->configs[i].pixel_formats = decon_formats;\r\nctx->configs[i].num_pixel_formats = ARRAY_SIZE(decon_formats);\r\nctx->configs[i].zpos = i;\r\nctx->configs[i].type = decon_win_types[i];\r\nret = exynos_plane_init(drm_dev, &ctx->planes[i], i,\r\n1 << ctx->pipe, &ctx->configs[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nexynos_plane = &ctx->planes[DEFAULT_WIN];\r\nctx->crtc = exynos_drm_crtc_create(drm_dev, &exynos_plane->base,\r\nctx->pipe, EXYNOS_DISPLAY_TYPE_LCD,\r\n&decon_crtc_ops, ctx);\r\nif (IS_ERR(ctx->crtc)) {\r\ndecon_ctx_remove(ctx);\r\nreturn PTR_ERR(ctx->crtc);\r\n}\r\nif (ctx->encoder)\r\nexynos_dpi_bind(drm_dev, ctx->encoder);\r\nreturn 0;\r\n}\r\nstatic void decon_unbind(struct device *dev, struct device *master,\r\nvoid *data)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\ndecon_disable(ctx->crtc);\r\nif (ctx->encoder)\r\nexynos_dpi_remove(ctx->encoder);\r\ndecon_ctx_remove(ctx);\r\n}\r\nstatic int decon_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct decon_context *ctx;\r\nstruct device_node *i80_if_timings;\r\nstruct resource *res;\r\nint ret;\r\nif (!dev->of_node)\r\nreturn -ENODEV;\r\nctx = devm_kzalloc(dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->dev = dev;\r\nctx->suspended = true;\r\ni80_if_timings = of_get_child_by_name(dev->of_node, "i80-if-timings");\r\nif (i80_if_timings)\r\nctx->i80_if = true;\r\nof_node_put(i80_if_timings);\r\nctx->regs = of_iomap(dev->of_node, 0);\r\nif (!ctx->regs)\r\nreturn -ENOMEM;\r\nctx->pclk = devm_clk_get(dev, "pclk_decon0");\r\nif (IS_ERR(ctx->pclk)) {\r\ndev_err(dev, "failed to get bus clock pclk\n");\r\nret = PTR_ERR(ctx->pclk);\r\ngoto err_iounmap;\r\n}\r\nctx->aclk = devm_clk_get(dev, "aclk_decon0");\r\nif (IS_ERR(ctx->aclk)) {\r\ndev_err(dev, "failed to get bus clock aclk\n");\r\nret = PTR_ERR(ctx->aclk);\r\ngoto err_iounmap;\r\n}\r\nctx->eclk = devm_clk_get(dev, "decon0_eclk");\r\nif (IS_ERR(ctx->eclk)) {\r\ndev_err(dev, "failed to get eclock\n");\r\nret = PTR_ERR(ctx->eclk);\r\ngoto err_iounmap;\r\n}\r\nctx->vclk = devm_clk_get(dev, "decon0_vclk");\r\nif (IS_ERR(ctx->vclk)) {\r\ndev_err(dev, "failed to get vclock\n");\r\nret = PTR_ERR(ctx->vclk);\r\ngoto err_iounmap;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_IRQ,\r\nctx->i80_if ? "lcd_sys" : "vsync");\r\nif (!res) {\r\ndev_err(dev, "irq request failed.\n");\r\nret = -ENXIO;\r\ngoto err_iounmap;\r\n}\r\nret = devm_request_irq(dev, res->start, decon_irq_handler,\r\n0, "drm_decon", ctx);\r\nif (ret) {\r\ndev_err(dev, "irq request failed.\n");\r\ngoto err_iounmap;\r\n}\r\ninit_waitqueue_head(&ctx->wait_vsync_queue);\r\natomic_set(&ctx->wait_vsync_event, 0);\r\nplatform_set_drvdata(pdev, ctx);\r\nctx->encoder = exynos_dpi_probe(dev);\r\nif (IS_ERR(ctx->encoder)) {\r\nret = PTR_ERR(ctx->encoder);\r\ngoto err_iounmap;\r\n}\r\npm_runtime_enable(dev);\r\nret = component_add(dev, &decon_component_ops);\r\nif (ret)\r\ngoto err_disable_pm_runtime;\r\nreturn ret;\r\nerr_disable_pm_runtime:\r\npm_runtime_disable(dev);\r\nerr_iounmap:\r\niounmap(ctx->regs);\r\nreturn ret;\r\n}\r\nstatic int decon_remove(struct platform_device *pdev)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\niounmap(ctx->regs);\r\ncomponent_del(&pdev->dev, &decon_component_ops);\r\nreturn 0;\r\n}\r\nstatic int exynos7_decon_suspend(struct device *dev)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\nclk_disable_unprepare(ctx->vclk);\r\nclk_disable_unprepare(ctx->eclk);\r\nclk_disable_unprepare(ctx->aclk);\r\nclk_disable_unprepare(ctx->pclk);\r\nreturn 0;\r\n}\r\nstatic int exynos7_decon_resume(struct device *dev)\r\n{\r\nstruct decon_context *ctx = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(ctx->pclk);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the pclk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(ctx->aclk);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the aclk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(ctx->eclk);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the eclk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(ctx->vclk);\r\nif (ret < 0) {\r\nDRM_ERROR("Failed to prepare_enable the vclk [%d]\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
