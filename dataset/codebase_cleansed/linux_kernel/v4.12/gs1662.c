static int gs_read_register(struct spi_device *spi, u16 addr, u16 *value)\r\n{\r\nint ret;\r\nu16 buf_addr = (0x8000 | (0x0FFF & addr));\r\nu16 buf_value = 0;\r\nstruct spi_message msg;\r\nstruct spi_transfer tx[] = {\r\n{\r\n.tx_buf = &buf_addr,\r\n.len = 2,\r\n.delay_usecs = 1,\r\n}, {\r\n.rx_buf = &buf_value,\r\n.len = 2,\r\n.delay_usecs = 1,\r\n},\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&tx[0], &msg);\r\nspi_message_add_tail(&tx[1], &msg);\r\nret = spi_sync(spi, &msg);\r\n*value = buf_value;\r\nreturn ret;\r\n}\r\nstatic int gs_write_register(struct spi_device *spi, u16 addr, u16 value)\r\n{\r\nint ret;\r\nu16 buf_addr = addr;\r\nu16 buf_value = value;\r\nstruct spi_message msg;\r\nstruct spi_transfer tx[] = {\r\n{\r\n.tx_buf = &buf_addr,\r\n.len = 2,\r\n.delay_usecs = 1,\r\n}, {\r\n.tx_buf = &buf_value,\r\n.len = 2,\r\n.delay_usecs = 1,\r\n},\r\n};\r\nspi_message_init(&msg);\r\nspi_message_add_tail(&tx[0], &msg);\r\nspi_message_add_tail(&tx[1], &msg);\r\nret = spi_sync(spi, &msg);\r\nreturn ret;\r\n}\r\nstatic int gs_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct spi_device *spi = v4l2_get_subdevdata(sd);\r\nu16 val;\r\nint ret;\r\nret = gs_read_register(spi, reg->reg & 0xFFFF, &val);\r\nreg->val = val;\r\nreg->size = 2;\r\nreturn ret;\r\n}\r\nstatic int gs_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct spi_device *spi = v4l2_get_subdevdata(sd);\r\nreturn gs_write_register(spi, reg->reg & 0xFFFF, reg->val & 0xFFFF);\r\n}\r\nstatic int gs_status_format(u16 status, struct v4l2_dv_timings *timings)\r\n{\r\nint std = (status & MASK_STD_STATUS) >> 5;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reg_fmt); i++) {\r\nif (reg_fmt[i].reg_value == std) {\r\n*timings = reg_fmt[i].format;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ERANGE;\r\n}\r\nstatic u16 get_register_timings(struct v4l2_dv_timings *timings)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(reg_fmt); i++) {\r\nif (v4l2_match_dv_timings(timings, &reg_fmt[i].format, 0,\r\nfalse))\r\nreturn reg_fmt[i].reg_value | MASK_FORCE_STD;\r\n}\r\nreturn 0x0;\r\n}\r\nstatic inline struct gs *to_gs(struct v4l2_subdev *sd)\r\n{\r\nreturn container_of(sd, struct gs, sd);\r\n}\r\nstatic int gs_s_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct gs *gs = to_gs(sd);\r\nint reg_value;\r\nreg_value = get_register_timings(timings);\r\nif (reg_value == 0x0)\r\nreturn -EINVAL;\r\ngs->current_timings = *timings;\r\nreturn 0;\r\n}\r\nstatic int gs_g_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct gs *gs = to_gs(sd);\r\n*timings = gs->current_timings;\r\nreturn 0;\r\n}\r\nstatic int gs_query_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct gs *gs = to_gs(sd);\r\nstruct v4l2_dv_timings fmt;\r\nu16 reg_value, i;\r\nint ret;\r\nif (gs->enabled)\r\nreturn -EBUSY;\r\nfor (i = 0; i < 4; i++) {\r\ngs_read_register(gs->pdev, REG_LINES_PER_FRAME + i, &reg_value);\r\nif (reg_value)\r\nbreak;\r\n}\r\nif (i >= 4)\r\nreturn -ENOLINK;\r\ngs_read_register(gs->pdev, REG_STATUS, &reg_value);\r\nif (!(reg_value & MASK_H_LOCK) || !(reg_value & MASK_V_LOCK))\r\nreturn -ENOLCK;\r\nif (!(reg_value & MASK_STD_LOCK))\r\nreturn -ERANGE;\r\nret = gs_status_format(reg_value, &fmt);\r\nif (ret < 0)\r\nreturn ret;\r\n*timings = fmt;\r\nreturn 0;\r\n}\r\nstatic int gs_enum_dv_timings(struct v4l2_subdev *sd,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nif (timings->index >= ARRAY_SIZE(fmt_cap))\r\nreturn -EINVAL;\r\nif (timings->pad != 0)\r\nreturn -EINVAL;\r\ntimings->timings = fmt_cap[timings->index];\r\nreturn 0;\r\n}\r\nstatic int gs_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct gs *gs = to_gs(sd);\r\nint reg_value;\r\nif (gs->enabled == enable)\r\nreturn 0;\r\ngs->enabled = enable;\r\nif (enable) {\r\nreg_value = get_register_timings(&gs->current_timings);\r\nreturn gs_write_register(gs->pdev, REG_FORCE_FMT, reg_value);\r\n}\r\nreturn gs_write_register(gs->pdev, REG_FORCE_FMT, 0x0);\r\n}\r\nstatic int gs_g_input_status(struct v4l2_subdev *sd, u32 *status)\r\n{\r\nstruct gs *gs = to_gs(sd);\r\nu16 reg_value, i;\r\nint ret;\r\nfor (i = 0; i < 4; i++) {\r\nret = gs_read_register(gs->pdev,\r\nREG_LINES_PER_FRAME + i, &reg_value);\r\nif (reg_value)\r\nbreak;\r\nif (ret) {\r\n*status = V4L2_IN_ST_NO_POWER;\r\nreturn ret;\r\n}\r\n}\r\nif (i >= 4)\r\n*status |= V4L2_IN_ST_NO_SIGNAL;\r\nret = gs_read_register(gs->pdev, REG_STATUS, &reg_value);\r\nif (!(reg_value & MASK_H_LOCK))\r\n*status |= V4L2_IN_ST_NO_H_LOCK;\r\nif (!(reg_value & MASK_V_LOCK))\r\n*status |= V4L2_IN_ST_NO_V_LOCK;\r\nif (!(reg_value & MASK_STD_LOCK))\r\n*status |= V4L2_IN_ST_NO_STD_LOCK;\r\nreturn ret;\r\n}\r\nstatic int gs_dv_timings_cap(struct v4l2_subdev *sd,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nif (cap->pad != 0)\r\nreturn -EINVAL;\r\n*cap = gs_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int gs_probe(struct spi_device *spi)\r\n{\r\nint ret;\r\nstruct gs *gs;\r\nstruct v4l2_subdev *sd;\r\ngs = devm_kzalloc(&spi->dev, sizeof(struct gs), GFP_KERNEL);\r\nif (!gs)\r\nreturn -ENOMEM;\r\ngs->pdev = spi;\r\nsd = &gs->sd;\r\nspi->mode = SPI_MODE_0;\r\nspi->irq = -1;\r\nspi->max_speed_hz = 10000000;\r\nspi->bits_per_word = 16;\r\nret = spi_setup(spi);\r\nv4l2_spi_subdev_init(sd, spi, &gs_ops);\r\ngs->current_timings = reg_fmt[0].format;\r\ngs->enabled = 0;\r\ngs_write_register(spi, 0x0, 0x300);\r\nreturn ret;\r\n}\r\nstatic int gs_remove(struct spi_device *spi)\r\n{\r\nstruct v4l2_subdev *sd = spi_get_drvdata(spi);\r\nv4l2_device_unregister_subdev(sd);\r\nreturn 0;\r\n}
