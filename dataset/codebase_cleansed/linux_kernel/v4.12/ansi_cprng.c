static void hexdump(char *note, unsigned char *buf, unsigned int len)\r\n{\r\nif (dbg) {\r\nprintk(KERN_CRIT "%s", note);\r\nprint_hex_dump(KERN_CONT, "", DUMP_PREFIX_OFFSET,\r\n16, 1,\r\nbuf, len, false);\r\n}\r\n}\r\nstatic void xor_vectors(unsigned char *in1, unsigned char *in2,\r\nunsigned char *out, unsigned int size)\r\n{\r\nint i;\r\nfor (i = 0; i < size; i++)\r\nout[i] = in1[i] ^ in2[i];\r\n}\r\nstatic int _get_more_prng_bytes(struct prng_context *ctx, int cont_test)\r\n{\r\nint i;\r\nunsigned char tmp[DEFAULT_BLK_SZ];\r\nunsigned char *output = NULL;\r\ndbgprint(KERN_CRIT "Calling _get_more_prng_bytes for context %p\n",\r\nctx);\r\nhexdump("Input DT: ", ctx->DT, DEFAULT_BLK_SZ);\r\nhexdump("Input I: ", ctx->I, DEFAULT_BLK_SZ);\r\nhexdump("Input V: ", ctx->V, DEFAULT_BLK_SZ);\r\nfor (i = 0; i < 3; i++) {\r\nswitch (i) {\r\ncase 0:\r\nmemcpy(tmp, ctx->DT, DEFAULT_BLK_SZ);\r\noutput = ctx->I;\r\nhexdump("tmp stage 0: ", tmp, DEFAULT_BLK_SZ);\r\nbreak;\r\ncase 1:\r\nxor_vectors(ctx->I, ctx->V, tmp, DEFAULT_BLK_SZ);\r\nhexdump("tmp stage 1: ", tmp, DEFAULT_BLK_SZ);\r\noutput = ctx->rand_data;\r\nbreak;\r\ncase 2:\r\nif (!memcmp(ctx->rand_data, ctx->last_rand_data,\r\nDEFAULT_BLK_SZ)) {\r\nif (cont_test) {\r\npanic("cprng %p Failed repetition check!\n",\r\nctx);\r\n}\r\nprintk(KERN_ERR\r\n"ctx %p Failed repetition check!\n",\r\nctx);\r\nctx->flags |= PRNG_NEED_RESET;\r\nreturn -EINVAL;\r\n}\r\nmemcpy(ctx->last_rand_data, ctx->rand_data,\r\nDEFAULT_BLK_SZ);\r\nxor_vectors(ctx->rand_data, ctx->I, tmp,\r\nDEFAULT_BLK_SZ);\r\noutput = ctx->V;\r\nhexdump("tmp stage 2: ", tmp, DEFAULT_BLK_SZ);\r\nbreak;\r\n}\r\ncrypto_cipher_encrypt_one(ctx->tfm, output, tmp);\r\n}\r\nfor (i = DEFAULT_BLK_SZ - 1; i >= 0; i--) {\r\nctx->DT[i] += 1;\r\nif (ctx->DT[i] != 0)\r\nbreak;\r\n}\r\ndbgprint("Returning new block for context %p\n", ctx);\r\nctx->rand_data_valid = 0;\r\nhexdump("Output DT: ", ctx->DT, DEFAULT_BLK_SZ);\r\nhexdump("Output I: ", ctx->I, DEFAULT_BLK_SZ);\r\nhexdump("Output V: ", ctx->V, DEFAULT_BLK_SZ);\r\nhexdump("New Random Data: ", ctx->rand_data, DEFAULT_BLK_SZ);\r\nreturn 0;\r\n}\r\nstatic int get_prng_bytes(char *buf, size_t nbytes, struct prng_context *ctx,\r\nint do_cont_test)\r\n{\r\nunsigned char *ptr = buf;\r\nunsigned int byte_count = (unsigned int)nbytes;\r\nint err;\r\nspin_lock_bh(&ctx->prng_lock);\r\nerr = -EINVAL;\r\nif (ctx->flags & PRNG_NEED_RESET)\r\ngoto done;\r\nerr = -EINVAL;\r\nif (ctx->flags & PRNG_FIXED_SIZE) {\r\nif (nbytes < DEFAULT_BLK_SZ)\r\ngoto done;\r\nbyte_count = DEFAULT_BLK_SZ;\r\n}\r\nerr = 0;\r\ndbgprint(KERN_CRIT "getting %d random bytes for context %p\n",\r\nbyte_count, ctx);\r\nremainder:\r\nif (ctx->rand_data_valid == DEFAULT_BLK_SZ) {\r\nif (_get_more_prng_bytes(ctx, do_cont_test) < 0) {\r\nmemset(buf, 0, nbytes);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\n}\r\nif (byte_count < DEFAULT_BLK_SZ) {\r\nempty_rbuf:\r\nwhile (ctx->rand_data_valid < DEFAULT_BLK_SZ) {\r\n*ptr = ctx->rand_data[ctx->rand_data_valid];\r\nptr++;\r\nbyte_count--;\r\nctx->rand_data_valid++;\r\nif (byte_count == 0)\r\ngoto done;\r\n}\r\n}\r\nfor (; byte_count >= DEFAULT_BLK_SZ; byte_count -= DEFAULT_BLK_SZ) {\r\nif (ctx->rand_data_valid == DEFAULT_BLK_SZ) {\r\nif (_get_more_prng_bytes(ctx, do_cont_test) < 0) {\r\nmemset(buf, 0, nbytes);\r\nerr = -EINVAL;\r\ngoto done;\r\n}\r\n}\r\nif (ctx->rand_data_valid > 0)\r\ngoto empty_rbuf;\r\nmemcpy(ptr, ctx->rand_data, DEFAULT_BLK_SZ);\r\nctx->rand_data_valid += DEFAULT_BLK_SZ;\r\nptr += DEFAULT_BLK_SZ;\r\n}\r\nif (byte_count)\r\ngoto remainder;\r\ndone:\r\nspin_unlock_bh(&ctx->prng_lock);\r\ndbgprint(KERN_CRIT "returning %d from get_prng_bytes in context %p\n",\r\nerr, ctx);\r\nreturn err;\r\n}\r\nstatic void free_prng_context(struct prng_context *ctx)\r\n{\r\ncrypto_free_cipher(ctx->tfm);\r\n}\r\nstatic int reset_prng_context(struct prng_context *ctx,\r\nconst unsigned char *key, size_t klen,\r\nconst unsigned char *V, const unsigned char *DT)\r\n{\r\nint ret;\r\nconst unsigned char *prng_key;\r\nspin_lock_bh(&ctx->prng_lock);\r\nctx->flags |= PRNG_NEED_RESET;\r\nprng_key = (key != NULL) ? key : (unsigned char *)DEFAULT_PRNG_KEY;\r\nif (!key)\r\nklen = DEFAULT_PRNG_KSZ;\r\nif (V)\r\nmemcpy(ctx->V, V, DEFAULT_BLK_SZ);\r\nelse\r\nmemcpy(ctx->V, DEFAULT_V_SEED, DEFAULT_BLK_SZ);\r\nif (DT)\r\nmemcpy(ctx->DT, DT, DEFAULT_BLK_SZ);\r\nelse\r\nmemset(ctx->DT, 0, DEFAULT_BLK_SZ);\r\nmemset(ctx->rand_data, 0, DEFAULT_BLK_SZ);\r\nmemset(ctx->last_rand_data, 0, DEFAULT_BLK_SZ);\r\nctx->rand_data_valid = DEFAULT_BLK_SZ;\r\nret = crypto_cipher_setkey(ctx->tfm, prng_key, klen);\r\nif (ret) {\r\ndbgprint(KERN_CRIT "PRNG: setkey() failed flags=%x\n",\r\ncrypto_cipher_get_flags(ctx->tfm));\r\ngoto out;\r\n}\r\nret = 0;\r\nctx->flags &= ~PRNG_NEED_RESET;\r\nout:\r\nspin_unlock_bh(&ctx->prng_lock);\r\nreturn ret;\r\n}\r\nstatic int cprng_init(struct crypto_tfm *tfm)\r\n{\r\nstruct prng_context *ctx = crypto_tfm_ctx(tfm);\r\nspin_lock_init(&ctx->prng_lock);\r\nctx->tfm = crypto_alloc_cipher("aes", 0, 0);\r\nif (IS_ERR(ctx->tfm)) {\r\ndbgprint(KERN_CRIT "Failed to alloc tfm for context %p\n",\r\nctx);\r\nreturn PTR_ERR(ctx->tfm);\r\n}\r\nif (reset_prng_context(ctx, NULL, DEFAULT_PRNG_KSZ, NULL, NULL) < 0)\r\nreturn -EINVAL;\r\nctx->flags |= PRNG_NEED_RESET;\r\nreturn 0;\r\n}\r\nstatic void cprng_exit(struct crypto_tfm *tfm)\r\n{\r\nfree_prng_context(crypto_tfm_ctx(tfm));\r\n}\r\nstatic int cprng_get_random(struct crypto_rng *tfm,\r\nconst u8 *src, unsigned int slen,\r\nu8 *rdata, unsigned int dlen)\r\n{\r\nstruct prng_context *prng = crypto_rng_ctx(tfm);\r\nreturn get_prng_bytes(rdata, dlen, prng, 0);\r\n}\r\nstatic int cprng_reset(struct crypto_rng *tfm,\r\nconst u8 *seed, unsigned int slen)\r\n{\r\nstruct prng_context *prng = crypto_rng_ctx(tfm);\r\nconst u8 *key = seed + DEFAULT_BLK_SZ;\r\nconst u8 *dt = NULL;\r\nif (slen < DEFAULT_PRNG_KSZ + DEFAULT_BLK_SZ)\r\nreturn -EINVAL;\r\nif (slen >= (2 * DEFAULT_BLK_SZ + DEFAULT_PRNG_KSZ))\r\ndt = key + DEFAULT_PRNG_KSZ;\r\nreset_prng_context(prng, key, DEFAULT_PRNG_KSZ, seed, dt);\r\nif (prng->flags & PRNG_NEED_RESET)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int fips_cprng_get_random(struct crypto_rng *tfm,\r\nconst u8 *src, unsigned int slen,\r\nu8 *rdata, unsigned int dlen)\r\n{\r\nstruct prng_context *prng = crypto_rng_ctx(tfm);\r\nreturn get_prng_bytes(rdata, dlen, prng, 1);\r\n}\r\nstatic int fips_cprng_reset(struct crypto_rng *tfm,\r\nconst u8 *seed, unsigned int slen)\r\n{\r\nu8 rdata[DEFAULT_BLK_SZ];\r\nconst u8 *key = seed + DEFAULT_BLK_SZ;\r\nint rc;\r\nstruct prng_context *prng = crypto_rng_ctx(tfm);\r\nif (slen < DEFAULT_PRNG_KSZ + DEFAULT_BLK_SZ)\r\nreturn -EINVAL;\r\nif (!memcmp(seed, key, DEFAULT_PRNG_KSZ))\r\nreturn -EINVAL;\r\nrc = cprng_reset(tfm, seed, slen);\r\nif (!rc)\r\ngoto out;\r\nrc = get_prng_bytes(rdata, DEFAULT_BLK_SZ, prng, 0);\r\nprng->rand_data_valid = DEFAULT_BLK_SZ;\r\nout:\r\nreturn rc;\r\n}\r\nstatic int __init prng_mod_init(void)\r\n{\r\nreturn crypto_register_rngs(rng_algs, ARRAY_SIZE(rng_algs));\r\n}\r\nstatic void __exit prng_mod_fini(void)\r\n{\r\ncrypto_unregister_rngs(rng_algs, ARRAY_SIZE(rng_algs));\r\n}
