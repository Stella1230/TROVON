static void ems_usb_read_interrupt_callback(struct urb *urb)\r\n{\r\nstruct ems_usb *dev = urb->context;\r\nstruct net_device *netdev = dev->netdev;\r\nint err;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\ndev->free_slots = dev->intr_in_buffer[1];\r\nif (dev->free_slots > CPC_TX_QUEUE_TRIGGER_HIGH &&\r\nnetif_queue_stopped(netdev))\r\nnetif_wake_queue(netdev);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nnetdev_info(netdev, "Rx interrupt aborted %d\n", urb->status);\r\nbreak;\r\n}\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (err == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse if (err)\r\nnetdev_err(netdev, "failed resubmitting intr urb: %d\n", err);\r\n}\r\nstatic void ems_usb_rx_can_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nint i;\r\nstruct net_device_stats *stats = &dev->netdev->stats;\r\nskb = alloc_can_skb(dev->netdev, &cf);\r\nif (skb == NULL)\r\nreturn;\r\ncf->can_id = le32_to_cpu(msg->msg.can_msg.id);\r\ncf->can_dlc = get_can_dlc(msg->msg.can_msg.length & 0xF);\r\nif (msg->type == CPC_MSG_TYPE_EXT_CAN_FRAME ||\r\nmsg->type == CPC_MSG_TYPE_EXT_RTR_FRAME)\r\ncf->can_id |= CAN_EFF_FLAG;\r\nif (msg->type == CPC_MSG_TYPE_RTR_FRAME ||\r\nmsg->type == CPC_MSG_TYPE_EXT_RTR_FRAME) {\r\ncf->can_id |= CAN_RTR_FLAG;\r\n} else {\r\nfor (i = 0; i < cf->can_dlc; i++)\r\ncf->data[i] = msg->msg.can_msg.msg[i];\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic void ems_usb_rx_err(struct ems_usb *dev, struct ems_cpc_msg *msg)\r\n{\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nstruct net_device_stats *stats = &dev->netdev->stats;\r\nskb = alloc_can_err_skb(dev->netdev, &cf);\r\nif (skb == NULL)\r\nreturn;\r\nif (msg->type == CPC_MSG_TYPE_CAN_STATE) {\r\nu8 state = msg->msg.can_state;\r\nif (state & SJA1000_SR_BS) {\r\ndev->can.state = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\ndev->can.can_stats.bus_off++;\r\ncan_bus_off(dev->netdev);\r\n} else if (state & SJA1000_SR_ES) {\r\ndev->can.state = CAN_STATE_ERROR_WARNING;\r\ndev->can.can_stats.error_warning++;\r\n} else {\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\ndev->can.can_stats.error_passive++;\r\n}\r\n} else if (msg->type == CPC_MSG_TYPE_CAN_FRAME_ERROR) {\r\nu8 ecc = msg->msg.error.cc.regs.sja1000.ecc;\r\nu8 txerr = msg->msg.error.cc.regs.sja1000.txerr;\r\nu8 rxerr = msg->msg.error.cc.regs.sja1000.rxerr;\r\ndev->can.can_stats.bus_error++;\r\nstats->rx_errors++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (ecc & SJA1000_ECC_MASK) {\r\ncase SJA1000_ECC_BIT:\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nbreak;\r\ncase SJA1000_ECC_FORM:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase SJA1000_ECC_STUFF:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ndefault:\r\ncf->data[3] = ecc & SJA1000_ECC_SEG;\r\nbreak;\r\n}\r\nif ((ecc & SJA1000_ECC_DIR) == 0)\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\nif (dev->can.state == CAN_STATE_ERROR_WARNING ||\r\ndev->can.state == CAN_STATE_ERROR_PASSIVE) {\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE : CAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\n} else if (msg->type == CPC_MSG_TYPE_OVERRUN) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_rx(skb);\r\n}\r\nstatic void ems_usb_read_bulk_callback(struct urb *urb)\r\n{\r\nstruct ems_usb *dev = urb->context;\r\nstruct net_device *netdev;\r\nint retval;\r\nnetdev = dev->netdev;\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nswitch (urb->status) {\r\ncase 0:\r\nbreak;\r\ncase -ENOENT:\r\nreturn;\r\ndefault:\r\nnetdev_info(netdev, "Rx URB aborted (%d)\n", urb->status);\r\ngoto resubmit_urb;\r\n}\r\nif (urb->actual_length > CPC_HEADER_SIZE) {\r\nstruct ems_cpc_msg *msg;\r\nu8 *ibuf = urb->transfer_buffer;\r\nu8 msg_count, start;\r\nmsg_count = ibuf[0] & ~0x80;\r\nstart = CPC_HEADER_SIZE;\r\nwhile (msg_count) {\r\nmsg = (struct ems_cpc_msg *)&ibuf[start];\r\nswitch (msg->type) {\r\ncase CPC_MSG_TYPE_CAN_STATE:\r\nems_usb_rx_err(dev, msg);\r\nbreak;\r\ncase CPC_MSG_TYPE_CAN_FRAME:\r\ncase CPC_MSG_TYPE_EXT_CAN_FRAME:\r\ncase CPC_MSG_TYPE_RTR_FRAME:\r\ncase CPC_MSG_TYPE_EXT_RTR_FRAME:\r\nems_usb_rx_can_msg(dev, msg);\r\nbreak;\r\ncase CPC_MSG_TYPE_CAN_FRAME_ERROR:\r\nems_usb_rx_err(dev, msg);\r\nbreak;\r\ncase CPC_MSG_TYPE_OVERRUN:\r\nems_usb_rx_err(dev, msg);\r\nbreak;\r\n}\r\nstart += CPC_MSG_HEADER_LEN + msg->length;\r\nmsg_count--;\r\nif (start > urb->transfer_buffer_length) {\r\nnetdev_err(netdev, "format error\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nresubmit_urb:\r\nusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),\r\nurb->transfer_buffer, RX_BUFFER_SIZE,\r\nems_usb_read_bulk_callback, dev);\r\nretval = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (retval == -ENODEV)\r\nnetif_device_detach(netdev);\r\nelse if (retval)\r\nnetdev_err(netdev,\r\n"failed resubmitting read bulk urb: %d\n", retval);\r\n}\r\nstatic void ems_usb_write_bulk_callback(struct urb *urb)\r\n{\r\nstruct ems_tx_urb_context *context = urb->context;\r\nstruct ems_usb *dev;\r\nstruct net_device *netdev;\r\nBUG_ON(!context);\r\ndev = context->dev;\r\nnetdev = dev->netdev;\r\nusb_free_coherent(urb->dev, urb->transfer_buffer_length,\r\nurb->transfer_buffer, urb->transfer_dma);\r\natomic_dec(&dev->active_tx_urbs);\r\nif (!netif_device_present(netdev))\r\nreturn;\r\nif (urb->status)\r\nnetdev_info(netdev, "Tx URB aborted (%d)\n", urb->status);\r\nnetif_trans_update(netdev);\r\nnetdev->stats.tx_packets++;\r\nnetdev->stats.tx_bytes += context->dlc;\r\ncan_get_echo_skb(netdev, context->echo_index);\r\ncontext->echo_index = MAX_TX_URBS;\r\n}\r\nstatic int ems_usb_command_msg(struct ems_usb *dev, struct ems_cpc_msg *msg)\r\n{\r\nint actual_length;\r\nmemcpy(&dev->tx_msg_buffer[CPC_HEADER_SIZE], msg,\r\nmsg->length + CPC_MSG_HEADER_LEN);\r\nmemset(&dev->tx_msg_buffer[0], 0, CPC_HEADER_SIZE);\r\nreturn usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 2),\r\n&dev->tx_msg_buffer[0],\r\nmsg->length + CPC_MSG_HEADER_LEN + CPC_HEADER_SIZE,\r\n&actual_length, 1000);\r\n}\r\nstatic int ems_usb_write_mode(struct ems_usb *dev, u8 mode)\r\n{\r\ndev->active_params.msg.can_params.cc_params.sja1000.mode = mode;\r\nreturn ems_usb_command_msg(dev, &dev->active_params);\r\n}\r\nstatic int ems_usb_control_cmd(struct ems_usb *dev, u8 val)\r\n{\r\nstruct ems_cpc_msg cmd;\r\ncmd.type = CPC_CMD_TYPE_CONTROL;\r\ncmd.length = CPC_MSG_HEADER_LEN + 1;\r\ncmd.msgid = 0;\r\ncmd.msg.generic[0] = val;\r\nreturn ems_usb_command_msg(dev, &cmd);\r\n}\r\nstatic int ems_usb_start(struct ems_usb *dev)\r\n{\r\nstruct net_device *netdev = dev->netdev;\r\nint err, i;\r\ndev->intr_in_buffer[0] = 0;\r\ndev->free_slots = 50;\r\nfor (i = 0; i < MAX_RX_URBS; i++) {\r\nstruct urb *urb = NULL;\r\nu8 *buf = NULL;\r\nurb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!urb) {\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nbuf = usb_alloc_coherent(dev->udev, RX_BUFFER_SIZE, GFP_KERNEL,\r\n&urb->transfer_dma);\r\nif (!buf) {\r\nnetdev_err(netdev, "No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\nerr = -ENOMEM;\r\nbreak;\r\n}\r\nusb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),\r\nbuf, RX_BUFFER_SIZE,\r\nems_usb_read_bulk_callback, dev);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->rx_submitted);\r\nerr = usb_submit_urb(urb, GFP_KERNEL);\r\nif (err) {\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(dev->udev, RX_BUFFER_SIZE, buf,\r\nurb->transfer_dma);\r\nusb_free_urb(urb);\r\nbreak;\r\n}\r\nusb_free_urb(urb);\r\n}\r\nif (i == 0) {\r\nnetdev_warn(netdev, "couldn't setup read URBs\n");\r\nreturn err;\r\n}\r\nif (i < MAX_RX_URBS)\r\nnetdev_warn(netdev, "rx performance may be slow\n");\r\nusb_fill_int_urb(dev->intr_urb, dev->udev,\r\nusb_rcvintpipe(dev->udev, 1),\r\ndev->intr_in_buffer,\r\nINTR_IN_BUFFER_SIZE,\r\nems_usb_read_interrupt_callback, dev, 1);\r\nerr = usb_submit_urb(dev->intr_urb, GFP_KERNEL);\r\nif (err) {\r\nnetdev_warn(netdev, "intr URB submit failed: %d\n", err);\r\nreturn err;\r\n}\r\nerr = ems_usb_control_cmd(dev, CONTR_CAN_MESSAGE | CONTR_CONT_ON);\r\nif (err)\r\ngoto failed;\r\nerr = ems_usb_control_cmd(dev, CONTR_CAN_STATE | CONTR_CONT_ON);\r\nif (err)\r\ngoto failed;\r\nerr = ems_usb_control_cmd(dev, CONTR_BUS_ERROR | CONTR_CONT_ON);\r\nif (err)\r\ngoto failed;\r\nerr = ems_usb_write_mode(dev, SJA1000_MOD_NORMAL);\r\nif (err)\r\ngoto failed;\r\ndev->can.state = CAN_STATE_ERROR_ACTIVE;\r\nreturn 0;\r\nfailed:\r\nnetdev_warn(netdev, "couldn't submit control: %d\n", err);\r\nreturn err;\r\n}\r\nstatic void unlink_all_urbs(struct ems_usb *dev)\r\n{\r\nint i;\r\nusb_unlink_urb(dev->intr_urb);\r\nusb_kill_anchored_urbs(&dev->rx_submitted);\r\nusb_kill_anchored_urbs(&dev->tx_submitted);\r\natomic_set(&dev->active_tx_urbs, 0);\r\nfor (i = 0; i < MAX_TX_URBS; i++)\r\ndev->tx_contexts[i].echo_index = MAX_TX_URBS;\r\n}\r\nstatic int ems_usb_open(struct net_device *netdev)\r\n{\r\nstruct ems_usb *dev = netdev_priv(netdev);\r\nint err;\r\nerr = ems_usb_write_mode(dev, SJA1000_MOD_RM);\r\nif (err)\r\nreturn err;\r\nerr = open_candev(netdev);\r\nif (err)\r\nreturn err;\r\nerr = ems_usb_start(dev);\r\nif (err) {\r\nif (err == -ENODEV)\r\nnetif_device_detach(dev->netdev);\r\nnetdev_warn(netdev, "couldn't start device: %d\n", err);\r\nclose_candev(netdev);\r\nreturn err;\r\n}\r\nnetif_start_queue(netdev);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct ems_usb *dev = netdev_priv(netdev);\r\nstruct ems_tx_urb_context *context = NULL;\r\nstruct net_device_stats *stats = &netdev->stats;\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct ems_cpc_msg *msg;\r\nstruct urb *urb;\r\nu8 *buf;\r\nint i, err;\r\nsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\r\n+ sizeof(struct cpc_can_msg);\r\nif (can_dropped_invalid_skb(netdev, skb))\r\nreturn NETDEV_TX_OK;\r\nurb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!urb)\r\ngoto nomem;\r\nbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\r\nif (!buf) {\r\nnetdev_err(netdev, "No memory left for USB buffer\n");\r\nusb_free_urb(urb);\r\ngoto nomem;\r\n}\r\nmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\r\nmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\r\nmsg->msg.can_msg.length = cf->can_dlc;\r\nif (cf->can_id & CAN_RTR_FLAG) {\r\nmsg->type = cf->can_id & CAN_EFF_FLAG ?\r\nCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\r\nmsg->length = CPC_CAN_MSG_MIN_SIZE;\r\n} else {\r\nmsg->type = cf->can_id & CAN_EFF_FLAG ?\r\nCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\r\nfor (i = 0; i < cf->can_dlc; i++)\r\nmsg->msg.can_msg.msg[i] = cf->data[i];\r\nmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->can_dlc;\r\n}\r\nfor (i = 0; i < MAX_TX_URBS; i++) {\r\nif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\r\ncontext = &dev->tx_contexts[i];\r\nbreak;\r\n}\r\n}\r\nif (!context) {\r\nusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\r\nusb_free_urb(urb);\r\nnetdev_warn(netdev, "couldn't find free context\n");\r\nreturn NETDEV_TX_BUSY;\r\n}\r\ncontext->dev = dev;\r\ncontext->echo_index = i;\r\ncontext->dlc = cf->can_dlc;\r\nusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\r\nsize, ems_usb_write_bulk_callback, context);\r\nurb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_anchor_urb(urb, &dev->tx_submitted);\r\ncan_put_echo_skb(skb, netdev, context->echo_index);\r\natomic_inc(&dev->active_tx_urbs);\r\nerr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (unlikely(err)) {\r\ncan_free_echo_skb(netdev, context->echo_index);\r\nusb_unanchor_urb(urb);\r\nusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\r\ndev_kfree_skb(skb);\r\natomic_dec(&dev->active_tx_urbs);\r\nif (err == -ENODEV) {\r\nnetif_device_detach(netdev);\r\n} else {\r\nnetdev_warn(netdev, "failed tx_urb %d\n", err);\r\nstats->tx_dropped++;\r\n}\r\n} else {\r\nnetif_trans_update(netdev);\r\nif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\r\ndev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\r\nnetif_stop_queue(netdev);\r\n}\r\n}\r\nusb_free_urb(urb);\r\nreturn NETDEV_TX_OK;\r\nnomem:\r\ndev_kfree_skb(skb);\r\nstats->tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ems_usb_close(struct net_device *netdev)\r\n{\r\nstruct ems_usb *dev = netdev_priv(netdev);\r\nunlink_all_urbs(dev);\r\nnetif_stop_queue(netdev);\r\nif (ems_usb_write_mode(dev, SJA1000_MOD_RM))\r\nnetdev_warn(netdev, "couldn't stop device");\r\nclose_candev(netdev);\r\nreturn 0;\r\n}\r\nstatic int ems_usb_set_mode(struct net_device *netdev, enum can_mode mode)\r\n{\r\nstruct ems_usb *dev = netdev_priv(netdev);\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nif (ems_usb_write_mode(dev, SJA1000_MOD_NORMAL))\r\nnetdev_warn(netdev, "couldn't start device");\r\nif (netif_queue_stopped(netdev))\r\nnetif_wake_queue(netdev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ems_usb_set_bittiming(struct net_device *netdev)\r\n{\r\nstruct ems_usb *dev = netdev_priv(netdev);\r\nstruct can_bittiming *bt = &dev->can.bittiming;\r\nu8 btr0, btr1;\r\nbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\r\nbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\r\n(((bt->phase_seg2 - 1) & 0x7) << 4);\r\nif (dev->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nbtr1 |= 0x80;\r\nnetdev_info(netdev, "setting BTR0=0x%02x BTR1=0x%02x\n", btr0, btr1);\r\ndev->active_params.msg.can_params.cc_params.sja1000.btr0 = btr0;\r\ndev->active_params.msg.can_params.cc_params.sja1000.btr1 = btr1;\r\nreturn ems_usb_command_msg(dev, &dev->active_params);\r\n}\r\nstatic void init_params_sja1000(struct ems_cpc_msg *msg)\r\n{\r\nstruct cpc_sja1000_params *sja1000 =\r\n&msg->msg.can_params.cc_params.sja1000;\r\nmsg->type = CPC_CMD_TYPE_CAN_PARAMS;\r\nmsg->length = sizeof(struct cpc_can_params);\r\nmsg->msgid = 0;\r\nmsg->msg.can_params.cc_type = CPC_CC_TYPE_SJA1000;\r\nsja1000->acc_code0 = 0x00;\r\nsja1000->acc_code1 = 0x00;\r\nsja1000->acc_code2 = 0x00;\r\nsja1000->acc_code3 = 0x00;\r\nsja1000->acc_mask0 = 0xFF;\r\nsja1000->acc_mask1 = 0xFF;\r\nsja1000->acc_mask2 = 0xFF;\r\nsja1000->acc_mask3 = 0xFF;\r\nsja1000->btr0 = 0;\r\nsja1000->btr1 = 0;\r\nsja1000->outp_contr = SJA1000_DEFAULT_OUTPUT_CONTROL;\r\nsja1000->mode = SJA1000_MOD_RM;\r\n}\r\nstatic int ems_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct net_device *netdev;\r\nstruct ems_usb *dev;\r\nint i, err = -ENOMEM;\r\nnetdev = alloc_candev(sizeof(struct ems_usb), MAX_TX_URBS);\r\nif (!netdev) {\r\ndev_err(&intf->dev, "ems_usb: Couldn't alloc candev\n");\r\nreturn -ENOMEM;\r\n}\r\ndev = netdev_priv(netdev);\r\ndev->udev = interface_to_usbdev(intf);\r\ndev->netdev = netdev;\r\ndev->can.state = CAN_STATE_STOPPED;\r\ndev->can.clock.freq = EMS_USB_ARM7_CLOCK;\r\ndev->can.bittiming_const = &ems_usb_bittiming_const;\r\ndev->can.do_set_bittiming = ems_usb_set_bittiming;\r\ndev->can.do_set_mode = ems_usb_set_mode;\r\ndev->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES;\r\nnetdev->netdev_ops = &ems_usb_netdev_ops;\r\nnetdev->flags |= IFF_ECHO;\r\ninit_usb_anchor(&dev->rx_submitted);\r\ninit_usb_anchor(&dev->tx_submitted);\r\natomic_set(&dev->active_tx_urbs, 0);\r\nfor (i = 0; i < MAX_TX_URBS; i++)\r\ndev->tx_contexts[i].echo_index = MAX_TX_URBS;\r\ndev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!dev->intr_urb)\r\ngoto cleanup_candev;\r\ndev->intr_in_buffer = kzalloc(INTR_IN_BUFFER_SIZE, GFP_KERNEL);\r\nif (!dev->intr_in_buffer)\r\ngoto cleanup_intr_urb;\r\ndev->tx_msg_buffer = kzalloc(CPC_HEADER_SIZE +\r\nsizeof(struct ems_cpc_msg), GFP_KERNEL);\r\nif (!dev->tx_msg_buffer)\r\ngoto cleanup_intr_in_buffer;\r\nusb_set_intfdata(intf, dev);\r\nSET_NETDEV_DEV(netdev, &intf->dev);\r\ninit_params_sja1000(&dev->active_params);\r\nerr = ems_usb_command_msg(dev, &dev->active_params);\r\nif (err) {\r\nnetdev_err(netdev, "couldn't initialize controller: %d\n", err);\r\ngoto cleanup_tx_msg_buffer;\r\n}\r\nerr = register_candev(netdev);\r\nif (err) {\r\nnetdev_err(netdev, "couldn't register CAN device: %d\n", err);\r\ngoto cleanup_tx_msg_buffer;\r\n}\r\nreturn 0;\r\ncleanup_tx_msg_buffer:\r\nkfree(dev->tx_msg_buffer);\r\ncleanup_intr_in_buffer:\r\nkfree(dev->intr_in_buffer);\r\ncleanup_intr_urb:\r\nusb_free_urb(dev->intr_urb);\r\ncleanup_candev:\r\nfree_candev(netdev);\r\nreturn err;\r\n}\r\nstatic void ems_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct ems_usb *dev = usb_get_intfdata(intf);\r\nusb_set_intfdata(intf, NULL);\r\nif (dev) {\r\nunregister_netdev(dev->netdev);\r\nfree_candev(dev->netdev);\r\nunlink_all_urbs(dev);\r\nusb_free_urb(dev->intr_urb);\r\nkfree(dev->intr_in_buffer);\r\n}\r\n}
