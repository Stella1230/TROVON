static struct mtk_drm_gem_obj *mtk_drm_gem_init(struct drm_device *dev,\r\nunsigned long size)\r\n{\r\nstruct mtk_drm_gem_obj *mtk_gem_obj;\r\nint ret;\r\nsize = round_up(size, PAGE_SIZE);\r\nmtk_gem_obj = kzalloc(sizeof(*mtk_gem_obj), GFP_KERNEL);\r\nif (!mtk_gem_obj)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = drm_gem_object_init(dev, &mtk_gem_obj->base, size);\r\nif (ret < 0) {\r\nDRM_ERROR("failed to initialize gem object\n");\r\nkfree(mtk_gem_obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn mtk_gem_obj;\r\n}\r\nstruct mtk_drm_gem_obj *mtk_drm_gem_create(struct drm_device *dev,\r\nsize_t size, bool alloc_kmap)\r\n{\r\nstruct mtk_drm_private *priv = dev->dev_private;\r\nstruct mtk_drm_gem_obj *mtk_gem;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nmtk_gem = mtk_drm_gem_init(dev, size);\r\nif (IS_ERR(mtk_gem))\r\nreturn ERR_CAST(mtk_gem);\r\nobj = &mtk_gem->base;\r\nmtk_gem->dma_attrs = DMA_ATTR_WRITE_COMBINE;\r\nif (!alloc_kmap)\r\nmtk_gem->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;\r\nmtk_gem->cookie = dma_alloc_attrs(priv->dma_dev, obj->size,\r\n&mtk_gem->dma_addr, GFP_KERNEL,\r\nmtk_gem->dma_attrs);\r\nif (!mtk_gem->cookie) {\r\nDRM_ERROR("failed to allocate %zx byte dma buffer", obj->size);\r\nret = -ENOMEM;\r\ngoto err_gem_free;\r\n}\r\nif (alloc_kmap)\r\nmtk_gem->kvaddr = mtk_gem->cookie;\r\nDRM_DEBUG_DRIVER("cookie = %p dma_addr = %pad size = %zu\n",\r\nmtk_gem->cookie, &mtk_gem->dma_addr,\r\nsize);\r\nreturn mtk_gem;\r\nerr_gem_free:\r\ndrm_gem_object_release(obj);\r\nkfree(mtk_gem);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid mtk_drm_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\r\nstruct mtk_drm_private *priv = obj->dev->dev_private;\r\nif (mtk_gem->sg)\r\ndrm_prime_gem_destroy(obj, mtk_gem->sg);\r\nelse\r\ndma_free_attrs(priv->dma_dev, obj->size, mtk_gem->cookie,\r\nmtk_gem->dma_addr, mtk_gem->dma_attrs);\r\ndrm_gem_object_release(obj);\r\nkfree(mtk_gem);\r\n}\r\nint mtk_drm_gem_dumb_create(struct drm_file *file_priv, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct mtk_drm_gem_obj *mtk_gem;\r\nint ret;\r\nargs->pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\r\nargs->size = args->pitch * args->height;\r\nmtk_gem = mtk_drm_gem_create(dev, args->size, false);\r\nif (IS_ERR(mtk_gem))\r\nreturn PTR_ERR(mtk_gem);\r\nret = drm_gem_handle_create(file_priv, &mtk_gem->base, &args->handle);\r\nif (ret)\r\ngoto err_handle_create;\r\ndrm_gem_object_unreference_unlocked(&mtk_gem->base);\r\nreturn 0;\r\nerr_handle_create:\r\nmtk_drm_gem_free_object(&mtk_gem->base);\r\nreturn ret;\r\n}\r\nint mtk_drm_gem_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *dev, uint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nobj = drm_gem_object_lookup(file_priv, handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn -EINVAL;\r\n}\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto out;\r\n*offset = drm_vma_node_offset_addr(&obj->vma_node);\r\nDRM_DEBUG_KMS("offset = 0x%llx\n", *offset);\r\nout:\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ret;\r\n}\r\nstatic int mtk_drm_gem_object_mmap(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nint ret;\r\nstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\r\nstruct mtk_drm_private *priv = obj->dev->dev_private;\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_pgoff = 0;\r\nret = dma_mmap_attrs(priv->dma_dev, vma, mtk_gem->cookie,\r\nmtk_gem->dma_addr, obj->size, mtk_gem->dma_attrs);\r\nif (ret)\r\ndrm_gem_vm_close(vma);\r\nreturn ret;\r\n}\r\nint mtk_drm_gem_mmap_buf(struct drm_gem_object *obj, struct vm_area_struct *vma)\r\n{\r\nint ret;\r\nret = drm_gem_mmap_obj(obj, obj->size, vma);\r\nif (ret)\r\nreturn ret;\r\nreturn mtk_drm_gem_object_mmap(obj, vma);\r\n}\r\nint mtk_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret)\r\nreturn ret;\r\nobj = vma->vm_private_data;\r\nreturn mtk_drm_gem_object_mmap(obj, vma);\r\n}\r\nstruct sg_table *mtk_gem_prime_get_sg_table(struct drm_gem_object *obj)\r\n{\r\nstruct mtk_drm_gem_obj *mtk_gem = to_mtk_gem_obj(obj);\r\nstruct mtk_drm_private *priv = obj->dev->dev_private;\r\nstruct sg_table *sgt;\r\nint ret;\r\nsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\r\nif (!sgt)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = dma_get_sgtable_attrs(priv->dma_dev, sgt, mtk_gem->cookie,\r\nmtk_gem->dma_addr, obj->size,\r\nmtk_gem->dma_attrs);\r\nif (ret) {\r\nDRM_ERROR("failed to allocate sgt, %d\n", ret);\r\nkfree(sgt);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn sgt;\r\n}\r\nstruct drm_gem_object *mtk_gem_prime_import_sg_table(struct drm_device *dev,\r\nstruct dma_buf_attachment *attach, struct sg_table *sg)\r\n{\r\nstruct mtk_drm_gem_obj *mtk_gem;\r\nint ret;\r\nstruct scatterlist *s;\r\nunsigned int i;\r\ndma_addr_t expected;\r\nmtk_gem = mtk_drm_gem_init(dev, attach->dmabuf->size);\r\nif (IS_ERR(mtk_gem))\r\nreturn ERR_PTR(PTR_ERR(mtk_gem));\r\nexpected = sg_dma_address(sg->sgl);\r\nfor_each_sg(sg->sgl, s, sg->nents, i) {\r\nif (sg_dma_address(s) != expected) {\r\nDRM_ERROR("sg_table is not contiguous");\r\nret = -EINVAL;\r\ngoto err_gem_free;\r\n}\r\nexpected = sg_dma_address(s) + sg_dma_len(s);\r\n}\r\nmtk_gem->dma_addr = sg_dma_address(sg->sgl);\r\nmtk_gem->sg = sg;\r\nreturn &mtk_gem->base;\r\nerr_gem_free:\r\nkfree(mtk_gem);\r\nreturn ERR_PTR(ret);\r\n}
