static ssize_t sta_flags_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[16 * NUM_WLAN_STA_FLAGS], *pos = buf;\r\nchar *end = buf + sizeof(buf) - 1;\r\nstruct sta_info *sta = file->private_data;\r\nunsigned int flg;\r\nBUILD_BUG_ON(ARRAY_SIZE(sta_flag_names) != NUM_WLAN_STA_FLAGS);\r\nfor (flg = 0; flg < NUM_WLAN_STA_FLAGS; flg++) {\r\nif (test_sta_flag(sta, flg))\r\npos += scnprintf(pos, end - pos, "%s\n",\r\nsta_flag_names[flg]);\r\n}\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, strlen(buf));\r\n}\r\nstatic ssize_t sta_num_ps_buf_frames_read(struct file *file,\r\nchar __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct sta_info *sta = file->private_data;\r\nchar buf[17*IEEE80211_NUM_ACS], *p = buf;\r\nint ac;\r\nfor (ac = 0; ac < IEEE80211_NUM_ACS; ac++)\r\np += scnprintf(p, sizeof(buf)+buf-p, "AC%d: %d\n", ac,\r\nskb_queue_len(&sta->ps_tx_buf[ac]) +\r\nskb_queue_len(&sta->tx_filtered[ac]));\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_last_seq_ctrl_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[15*IEEE80211_NUM_TIDS], *p = buf;\r\nint i;\r\nstruct sta_info *sta = file->private_data;\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++)\r\np += scnprintf(p, sizeof(buf)+buf-p, "%x ",\r\nle16_to_cpu(sta->last_seq_ctrl[i]));\r\np += scnprintf(p, sizeof(buf)+buf-p, "\n");\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_aqm_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct sta_info *sta = file->private_data;\r\nstruct ieee80211_local *local = sta->local;\r\nsize_t bufsz = AQM_TXQ_ENTRY_LEN*(IEEE80211_NUM_TIDS+1);\r\nchar *buf = kzalloc(bufsz, GFP_KERNEL), *p = buf;\r\nstruct txq_info *txqi;\r\nssize_t rv;\r\nint i;\r\nif (!buf)\r\nreturn -ENOMEM;\r\nspin_lock_bh(&local->fq.lock);\r\nrcu_read_lock();\r\np += scnprintf(p,\r\nbufsz+buf-p,\r\n"tid ac backlog-bytes backlog-packets new-flows drops marks overlimit collisions tx-bytes tx-packets\n");\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\ntxqi = to_txq_info(sta->sta.txq[i]);\r\np += scnprintf(p, bufsz+buf-p,\r\n"%d %d %u %u %u %u %u %u %u %u %u\n",\r\ntxqi->txq.tid,\r\ntxqi->txq.ac,\r\ntxqi->tin.backlog_bytes,\r\ntxqi->tin.backlog_packets,\r\ntxqi->tin.flows,\r\ntxqi->cstats.drop_count,\r\ntxqi->cstats.ecn_mark,\r\ntxqi->tin.overlimit,\r\ntxqi->tin.collisions,\r\ntxqi->tin.tx_bytes,\r\ntxqi->tin.tx_packets);\r\n}\r\nrcu_read_unlock();\r\nspin_unlock_bh(&local->fq.lock);\r\nrv = simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\nkfree(buf);\r\nreturn rv;\r\n}\r\nstatic ssize_t sta_agg_status_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[71 + IEEE80211_NUM_TIDS * 40], *p = buf;\r\nint i;\r\nstruct sta_info *sta = file->private_data;\r\nstruct tid_ampdu_rx *tid_rx;\r\nstruct tid_ampdu_tx *tid_tx;\r\nrcu_read_lock();\r\np += scnprintf(p, sizeof(buf) + buf - p, "next dialog_token: %#02x\n",\r\nsta->ampdu_mlme.dialog_token_allocator + 1);\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"TID\t\tRX\tDTKN\tSSN\t\tTX\tDTKN\tpending\n");\r\nfor (i = 0; i < IEEE80211_NUM_TIDS; i++) {\r\nbool tid_rx_valid;\r\ntid_rx = rcu_dereference(sta->ampdu_mlme.tid_rx[i]);\r\ntid_tx = rcu_dereference(sta->ampdu_mlme.tid_tx[i]);\r\ntid_rx_valid = test_bit(i, sta->ampdu_mlme.agg_session_valid);\r\np += scnprintf(p, sizeof(buf) + buf - p, "%02d", i);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t\t%x",\r\ntid_rx_valid);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%#.2x",\r\ntid_rx_valid ?\r\nsta->ampdu_mlme.tid_rx_token[i] : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%#.3x",\r\ntid_rx ? tid_rx->ssn : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t\t%x", !!tid_tx);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%#.2x",\r\ntid_tx ? tid_tx->dialog_token : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\t%03d",\r\ntid_tx ? skb_queue_len(&tid_tx->pending) : 0);\r\np += scnprintf(p, sizeof(buf) + buf - p, "\n");\r\n}\r\nrcu_read_unlock();\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_agg_status_write(struct file *file, const char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar _buf[25] = {}, *buf = _buf;\r\nstruct sta_info *sta = file->private_data;\r\nbool start, tx;\r\nunsigned long tid;\r\nchar *pos;\r\nint ret, timeout = 5000;\r\nif (count > sizeof(_buf))\r\nreturn -EINVAL;\r\nif (copy_from_user(buf, userbuf, count))\r\nreturn -EFAULT;\r\nbuf[sizeof(_buf) - 1] = '\0';\r\npos = buf;\r\nbuf = strsep(&pos, " ");\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (!strcmp(buf, "tx"))\r\ntx = true;\r\nelse if (!strcmp(buf, "rx"))\r\ntx = false;\r\nelse\r\nreturn -EINVAL;\r\nbuf = strsep(&pos, " ");\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (!strcmp(buf, "start")) {\r\nstart = true;\r\nif (!tx)\r\nreturn -EINVAL;\r\n} else if (!strcmp(buf, "stop")) {\r\nstart = false;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nbuf = strsep(&pos, " ");\r\nif (!buf)\r\nreturn -EINVAL;\r\nif (sscanf(buf, "timeout=%d", &timeout) == 1) {\r\nbuf = strsep(&pos, " ");\r\nif (!buf || !tx || !start)\r\nreturn -EINVAL;\r\n}\r\nret = kstrtoul(buf, 0, &tid);\r\nif (ret || tid >= IEEE80211_NUM_TIDS)\r\nreturn -EINVAL;\r\nif (tx) {\r\nif (start)\r\nret = ieee80211_start_tx_ba_session(&sta->sta, tid,\r\ntimeout);\r\nelse\r\nret = ieee80211_stop_tx_ba_session(&sta->sta, tid);\r\n} else {\r\n__ieee80211_stop_rx_ba_session(sta, tid, WLAN_BACK_RECIPIENT,\r\n3, true);\r\nret = 0;\r\n}\r\nreturn ret ?: count;\r\n}\r\nstatic ssize_t sta_ht_capa_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\n#define PRINT_HT_CAP(_cond, _str) \\r\ndo { \\r\nif (_cond) \\r\np += scnprintf(p, sizeof(buf)+buf-p, "\t" _str "\n"); \\r\n} while (0)\r\nchar buf[512], *p = buf;\r\nint i;\r\nstruct sta_info *sta = file->private_data;\r\nstruct ieee80211_sta_ht_cap *htc = &sta->sta.ht_cap;\r\np += scnprintf(p, sizeof(buf) + buf - p, "ht %ssupported\n",\r\nhtc->ht_supported ? "" : "not ");\r\nif (htc->ht_supported) {\r\np += scnprintf(p, sizeof(buf)+buf-p, "cap: %#.4x\n", htc->cap);\r\nPRINT_HT_CAP((htc->cap & BIT(0)), "RX LDPC");\r\nPRINT_HT_CAP((htc->cap & BIT(1)), "HT20/HT40");\r\nPRINT_HT_CAP(!(htc->cap & BIT(1)), "HT20");\r\nPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 0, "Static SM Power Save");\r\nPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 1, "Dynamic SM Power Save");\r\nPRINT_HT_CAP(((htc->cap >> 2) & 0x3) == 3, "SM Power Save disabled");\r\nPRINT_HT_CAP((htc->cap & BIT(4)), "RX Greenfield");\r\nPRINT_HT_CAP((htc->cap & BIT(5)), "RX HT20 SGI");\r\nPRINT_HT_CAP((htc->cap & BIT(6)), "RX HT40 SGI");\r\nPRINT_HT_CAP((htc->cap & BIT(7)), "TX STBC");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 0, "No RX STBC");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 1, "RX STBC 1-stream");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 2, "RX STBC 2-streams");\r\nPRINT_HT_CAP(((htc->cap >> 8) & 0x3) == 3, "RX STBC 3-streams");\r\nPRINT_HT_CAP((htc->cap & BIT(10)), "HT Delayed Block Ack");\r\nPRINT_HT_CAP(!(htc->cap & BIT(11)), "Max AMSDU length: "\r\n"3839 bytes");\r\nPRINT_HT_CAP((htc->cap & BIT(11)), "Max AMSDU length: "\r\n"7935 bytes");\r\nPRINT_HT_CAP((htc->cap & BIT(12)), "DSSS/CCK HT40");\r\nPRINT_HT_CAP(!(htc->cap & BIT(12)), "No DSSS/CCK HT40");\r\nPRINT_HT_CAP((htc->cap & BIT(14)), "40 MHz Intolerant");\r\nPRINT_HT_CAP((htc->cap & BIT(15)), "L-SIG TXOP protection");\r\np += scnprintf(p, sizeof(buf)+buf-p, "ampdu factor/density: %d/%d\n",\r\nhtc->ampdu_factor, htc->ampdu_density);\r\np += scnprintf(p, sizeof(buf)+buf-p, "MCS mask:");\r\nfor (i = 0; i < IEEE80211_HT_MCS_MASK_LEN; i++)\r\np += scnprintf(p, sizeof(buf)+buf-p, " %.2x",\r\nhtc->mcs.rx_mask[i]);\r\np += scnprintf(p, sizeof(buf)+buf-p, "\n");\r\nif (le16_to_cpu(htc->mcs.rx_highest)) {\r\np += scnprintf(p, sizeof(buf)+buf-p,\r\n"MCS rx highest: %d Mbps\n",\r\nle16_to_cpu(htc->mcs.rx_highest));\r\n}\r\np += scnprintf(p, sizeof(buf)+buf-p, "MCS tx params: %x\n",\r\nhtc->mcs.tx_params);\r\n}\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nstatic ssize_t sta_vht_capa_read(struct file *file, char __user *userbuf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar buf[512], *p = buf;\r\nstruct sta_info *sta = file->private_data;\r\nstruct ieee80211_sta_vht_cap *vhtc = &sta->sta.vht_cap;\r\np += scnprintf(p, sizeof(buf) + buf - p, "VHT %ssupported\n",\r\nvhtc->vht_supported ? "" : "not ");\r\nif (vhtc->vht_supported) {\r\np += scnprintf(p, sizeof(buf) + buf - p, "cap: %#.8x\n",\r\nvhtc->cap);\r\n#define PFLAG(a, b) \\r\ndo { \\r\nif (vhtc->cap & IEEE80211_VHT_CAP_ ## a) \\r\np += scnprintf(p, sizeof(buf) + buf - p, \\r\n"\t\t%s\n", b); \\r\n} while (0)\r\nswitch (vhtc->cap & 0x3) {\r\ncase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_3895:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tMAX-MPDU-3895\n");\r\nbreak;\r\ncase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_7991:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tMAX-MPDU-7991\n");\r\nbreak;\r\ncase IEEE80211_VHT_CAP_MAX_MPDU_LENGTH_11454:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tMAX-MPDU-11454\n");\r\nbreak;\r\ndefault:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tMAX-MPDU-UNKNOWN\n");\r\n};\r\nswitch (vhtc->cap & IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_MASK) {\r\ncase 0:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\t80Mhz\n");\r\nbreak;\r\ncase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160MHZ:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\t160Mhz\n");\r\nbreak;\r\ncase IEEE80211_VHT_CAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\t80+80Mhz\n");\r\nbreak;\r\ndefault:\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tUNKNOWN-MHZ: 0x%x\n",\r\n(vhtc->cap >> 2) & 0x3);\r\n};\r\nPFLAG(RXLDPC, "RXLDPC");\r\nPFLAG(SHORT_GI_80, "SHORT-GI-80");\r\nPFLAG(SHORT_GI_160, "SHORT-GI-160");\r\nPFLAG(TXSTBC, "TXSTBC");\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tRXSTBC_%d\n", (vhtc->cap >> 8) & 0x7);\r\nPFLAG(SU_BEAMFORMER_CAPABLE, "SU-BEAMFORMER-CAPABLE");\r\nPFLAG(SU_BEAMFORMEE_CAPABLE, "SU-BEAMFORMEE-CAPABLE");\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tBEAMFORMEE-STS: 0x%x\n",\r\n(vhtc->cap & IEEE80211_VHT_CAP_BEAMFORMEE_STS_MASK) >>\r\nIEEE80211_VHT_CAP_BEAMFORMEE_STS_SHIFT);\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tSOUNDING-DIMENSIONS: 0x%x\n",\r\n(vhtc->cap & IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_MASK)\r\n>> IEEE80211_VHT_CAP_SOUNDING_DIMENSIONS_SHIFT);\r\nPFLAG(MU_BEAMFORMER_CAPABLE, "MU-BEAMFORMER-CAPABLE");\r\nPFLAG(MU_BEAMFORMEE_CAPABLE, "MU-BEAMFORMEE-CAPABLE");\r\nPFLAG(VHT_TXOP_PS, "TXOP-PS");\r\nPFLAG(HTC_VHT, "HTC-VHT");\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tMPDU-LENGTH-EXPONENT: 0x%x\n",\r\n(vhtc->cap & IEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK) >>\r\nIEEE80211_VHT_CAP_MAX_A_MPDU_LENGTH_EXPONENT_SHIFT);\r\nPFLAG(VHT_LINK_ADAPTATION_VHT_UNSOL_MFB,\r\n"LINK-ADAPTATION-VHT-UNSOL-MFB");\r\np += scnprintf(p, sizeof(buf) + buf - p,\r\n"\t\tLINK-ADAPTATION-VHT-MRQ-MFB: 0x%x\n",\r\n(vhtc->cap & IEEE80211_VHT_CAP_VHT_LINK_ADAPTATION_VHT_MRQ_MFB) >> 26);\r\nPFLAG(RX_ANTENNA_PATTERN, "RX-ANTENNA-PATTERN");\r\nPFLAG(TX_ANTENNA_PATTERN, "TX-ANTENNA-PATTERN");\r\np += scnprintf(p, sizeof(buf)+buf-p, "RX MCS: %.4x\n",\r\nle16_to_cpu(vhtc->vht_mcs.rx_mcs_map));\r\nif (vhtc->vht_mcs.rx_highest)\r\np += scnprintf(p, sizeof(buf)+buf-p,\r\n"MCS RX highest: %d Mbps\n",\r\nle16_to_cpu(vhtc->vht_mcs.rx_highest));\r\np += scnprintf(p, sizeof(buf)+buf-p, "TX MCS: %.4x\n",\r\nle16_to_cpu(vhtc->vht_mcs.tx_mcs_map));\r\nif (vhtc->vht_mcs.tx_highest)\r\np += scnprintf(p, sizeof(buf)+buf-p,\r\n"MCS TX highest: %d Mbps\n",\r\nle16_to_cpu(vhtc->vht_mcs.tx_highest));\r\n}\r\nreturn simple_read_from_buffer(userbuf, count, ppos, buf, p - buf);\r\n}\r\nvoid ieee80211_sta_debugfs_add(struct sta_info *sta)\r\n{\r\nstruct ieee80211_local *local = sta->local;\r\nstruct ieee80211_sub_if_data *sdata = sta->sdata;\r\nstruct dentry *stations_dir = sta->sdata->debugfs.subdir_stations;\r\nu8 mac[3*ETH_ALEN];\r\nif (!stations_dir)\r\nreturn;\r\nsnprintf(mac, sizeof(mac), "%pM", sta->sta.addr);\r\nsta->debugfs_dir = debugfs_create_dir(mac, stations_dir);\r\nif (!sta->debugfs_dir)\r\nreturn;\r\nDEBUGFS_ADD(flags);\r\nDEBUGFS_ADD(aid);\r\nDEBUGFS_ADD(num_ps_buf_frames);\r\nDEBUGFS_ADD(last_seq_ctrl);\r\nDEBUGFS_ADD(agg_status);\r\nDEBUGFS_ADD(ht_capa);\r\nDEBUGFS_ADD(vht_capa);\r\nDEBUGFS_ADD_COUNTER(rx_duplicates, rx_stats.num_duplicates);\r\nDEBUGFS_ADD_COUNTER(rx_fragments, rx_stats.fragments);\r\nDEBUGFS_ADD_COUNTER(tx_filtered, status_stats.filtered);\r\nif (local->ops->wake_tx_queue)\r\nDEBUGFS_ADD(aqm);\r\nif (sizeof(sta->driver_buffered_tids) == sizeof(u32))\r\ndebugfs_create_x32("driver_buffered_tids", 0400,\r\nsta->debugfs_dir,\r\n(u32 *)&sta->driver_buffered_tids);\r\nelse\r\ndebugfs_create_x64("driver_buffered_tids", 0400,\r\nsta->debugfs_dir,\r\n(u64 *)&sta->driver_buffered_tids);\r\ndrv_sta_add_debugfs(local, sdata, &sta->sta, sta->debugfs_dir);\r\n}\r\nvoid ieee80211_sta_debugfs_remove(struct sta_info *sta)\r\n{\r\ndebugfs_remove_recursive(sta->debugfs_dir);\r\nsta->debugfs_dir = NULL;\r\n}
