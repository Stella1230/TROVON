static inline void sif_set_bit(struct mtk_hdmi_ddc *ddc, unsigned int offset,\r\nunsigned int val)\r\n{\r\nwritel(readl(ddc->regs + offset) | val, ddc->regs + offset);\r\n}\r\nstatic inline void sif_clr_bit(struct mtk_hdmi_ddc *ddc, unsigned int offset,\r\nunsigned int val)\r\n{\r\nwritel(readl(ddc->regs + offset) & ~val, ddc->regs + offset);\r\n}\r\nstatic inline bool sif_bit_is_set(struct mtk_hdmi_ddc *ddc, unsigned int offset,\r\nunsigned int val)\r\n{\r\nreturn (readl(ddc->regs + offset) & val) == val;\r\n}\r\nstatic inline void sif_write_mask(struct mtk_hdmi_ddc *ddc, unsigned int offset,\r\nunsigned int mask, unsigned int shift,\r\nunsigned int val)\r\n{\r\nunsigned int tmp;\r\ntmp = readl(ddc->regs + offset);\r\ntmp &= ~mask;\r\ntmp |= (val << shift) & mask;\r\nwritel(tmp, ddc->regs + offset);\r\n}\r\nstatic inline unsigned int sif_read_mask(struct mtk_hdmi_ddc *ddc,\r\nunsigned int offset, unsigned int mask,\r\nunsigned int shift)\r\n{\r\nreturn (readl(ddc->regs + offset) & mask) >> shift;\r\n}\r\nstatic void ddcm_trigger_mode(struct mtk_hdmi_ddc *ddc, int mode)\r\n{\r\nu32 val;\r\nsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_SIF_MODE_MASK,\r\nDDCM_SIF_MODE_OFFSET, mode);\r\nsif_set_bit(ddc, DDC_DDCMCTL1, DDCM_TRI);\r\nreadl_poll_timeout(ddc->regs + DDC_DDCMCTL1, val,\r\n(val & DDCM_TRI) != DDCM_TRI, 4, 20000);\r\n}\r\nstatic int mtk_hdmi_ddc_read_msg(struct mtk_hdmi_ddc *ddc, struct i2c_msg *msg)\r\n{\r\nstruct device *dev = ddc->adap.dev.parent;\r\nu32 remain_count, ack_count, ack_final, read_count, temp_count;\r\nu32 index = 0;\r\nu32 ack;\r\nint i;\r\nddcm_trigger_mode(ddc, DDCM_START);\r\nsif_write_mask(ddc, DDC_DDCMD0, 0xff, 0, (msg->addr << 1) | 0x01);\r\nsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_PGLEN_MASK, DDCM_PGLEN_OFFSET,\r\n0x00);\r\nddcm_trigger_mode(ddc, DDCM_WRITE_DATA);\r\nack = sif_read_mask(ddc, DDC_DDCMCTL1, DDCM_ACK_MASK, DDCM_ACK_OFFSET);\r\ndev_dbg(dev, "ack = 0x%x\n", ack);\r\nif (ack != 0x01) {\r\ndev_err(dev, "i2c ack err!\n");\r\nreturn -ENXIO;\r\n}\r\nremain_count = msg->len;\r\nack_count = (msg->len - 1) / 8;\r\nack_final = 0;\r\nwhile (remain_count > 0) {\r\nif (ack_count > 0) {\r\nread_count = 8;\r\nack_final = 0;\r\nack_count--;\r\n} else {\r\nread_count = remain_count;\r\nack_final = 1;\r\n}\r\nsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_PGLEN_MASK,\r\nDDCM_PGLEN_OFFSET, read_count - 1);\r\nddcm_trigger_mode(ddc, (ack_final == 1) ?\r\nDDCM_READ_DATA_NO_ACK :\r\nDDCM_READ_DATA_ACK);\r\nack = sif_read_mask(ddc, DDC_DDCMCTL1, DDCM_ACK_MASK,\r\nDDCM_ACK_OFFSET);\r\ntemp_count = 0;\r\nwhile (((ack & (1 << temp_count)) != 0) && (temp_count < 8))\r\ntemp_count++;\r\nif (((ack_final == 1) && (temp_count != (read_count - 1))) ||\r\n((ack_final == 0) && (temp_count != read_count))) {\r\ndev_err(dev, "Address NACK! ACK(0x%x)\n", ack);\r\nbreak;\r\n}\r\nfor (i = read_count; i >= 1; i--) {\r\nint shift;\r\nint offset;\r\nif (i > 4) {\r\noffset = DDC_DDCMD1;\r\nshift = (i - 5) * 8;\r\n} else {\r\noffset = DDC_DDCMD0;\r\nshift = (i - 1) * 8;\r\n}\r\nmsg->buf[index + i - 1] = sif_read_mask(ddc, offset,\r\n0xff << shift,\r\nshift);\r\n}\r\nremain_count -= read_count;\r\nindex += read_count;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_hdmi_ddc_write_msg(struct mtk_hdmi_ddc *ddc, struct i2c_msg *msg)\r\n{\r\nstruct device *dev = ddc->adap.dev.parent;\r\nu32 ack;\r\nddcm_trigger_mode(ddc, DDCM_START);\r\nsif_write_mask(ddc, DDC_DDCMD0, DDCM_DATA0, 0, msg->addr << 1);\r\nsif_write_mask(ddc, DDC_DDCMD0, DDCM_DATA1, 8, msg->buf[0]);\r\nsif_write_mask(ddc, DDC_DDCMCTL1, DDCM_PGLEN_MASK, DDCM_PGLEN_OFFSET,\r\n0x1);\r\nddcm_trigger_mode(ddc, DDCM_WRITE_DATA);\r\nack = sif_read_mask(ddc, DDC_DDCMCTL1, DDCM_ACK_MASK, DDCM_ACK_OFFSET);\r\ndev_dbg(dev, "ack = %d\n", ack);\r\nif (ack != 0x03) {\r\ndev_err(dev, "i2c ack err!\n");\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_hdmi_ddc_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nstruct mtk_hdmi_ddc *ddc = adapter->algo_data;\r\nstruct device *dev = adapter->dev.parent;\r\nint ret;\r\nint i;\r\nif (!ddc) {\r\ndev_err(dev, "invalid arguments\n");\r\nreturn -EINVAL;\r\n}\r\nsif_set_bit(ddc, DDC_DDCMCTL0, DDCM_SCL_STRECH);\r\nsif_set_bit(ddc, DDC_DDCMCTL0, DDCM_SM0EN);\r\nsif_clr_bit(ddc, DDC_DDCMCTL0, DDCM_ODRAIN);\r\nif (sif_bit_is_set(ddc, DDC_DDCMCTL1, DDCM_TRI)) {\r\ndev_err(dev, "ddc line is busy!\n");\r\nreturn -EBUSY;\r\n}\r\nsif_write_mask(ddc, DDC_DDCMCTL0, DDCM_CLK_DIV_MASK,\r\nDDCM_CLK_DIV_OFFSET, SIF1_CLOK);\r\nfor (i = 0; i < num; i++) {\r\nstruct i2c_msg *msg = &msgs[i];\r\ndev_dbg(dev, "i2c msg, adr:0x%x, flags:%d, len :0x%x\n",\r\nmsg->addr, msg->flags, msg->len);\r\nif (msg->flags & I2C_M_RD)\r\nret = mtk_hdmi_ddc_read_msg(ddc, msg);\r\nelse\r\nret = mtk_hdmi_ddc_write_msg(ddc, msg);\r\nif (ret < 0)\r\ngoto xfer_end;\r\n}\r\nddcm_trigger_mode(ddc, DDCM_STOP);\r\nreturn i;\r\nxfer_end:\r\nddcm_trigger_mode(ddc, DDCM_STOP);\r\ndev_err(dev, "ddc failed!\n");\r\nreturn ret;\r\n}\r\nstatic u32 mtk_hdmi_ddc_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int mtk_hdmi_ddc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct mtk_hdmi_ddc *ddc;\r\nstruct resource *mem;\r\nint ret;\r\nddc = devm_kzalloc(dev, sizeof(struct mtk_hdmi_ddc), GFP_KERNEL);\r\nif (!ddc)\r\nreturn -ENOMEM;\r\nddc->clk = devm_clk_get(dev, "ddc-i2c");\r\nif (IS_ERR(ddc->clk)) {\r\ndev_err(dev, "get ddc_clk failed: %p ,\n", ddc->clk);\r\nreturn PTR_ERR(ddc->clk);\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nddc->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(ddc->regs))\r\nreturn PTR_ERR(ddc->regs);\r\nret = clk_prepare_enable(ddc->clk);\r\nif (ret) {\r\ndev_err(dev, "enable ddc clk failed!\n");\r\nreturn ret;\r\n}\r\nstrlcpy(ddc->adap.name, "mediatek-hdmi-ddc", sizeof(ddc->adap.name));\r\nddc->adap.owner = THIS_MODULE;\r\nddc->adap.class = I2C_CLASS_DDC;\r\nddc->adap.algo = &mtk_hdmi_ddc_algorithm;\r\nddc->adap.retries = 3;\r\nddc->adap.dev.of_node = dev->of_node;\r\nddc->adap.algo_data = ddc;\r\nddc->adap.dev.parent = &pdev->dev;\r\nret = i2c_add_adapter(&ddc->adap);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to add bus to i2c core\n");\r\ngoto err_clk_disable;\r\n}\r\nplatform_set_drvdata(pdev, ddc);\r\ndev_dbg(dev, "ddc->adap: %p\n", &ddc->adap);\r\ndev_dbg(dev, "ddc->clk: %p\n", ddc->clk);\r\ndev_dbg(dev, "physical adr: %pa, end: %pa\n", &mem->start,\r\n&mem->end);\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(ddc->clk);\r\nreturn ret;\r\n}\r\nstatic int mtk_hdmi_ddc_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_hdmi_ddc *ddc = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&ddc->adap);\r\nclk_disable_unprepare(ddc->clk);\r\nreturn 0;\r\n}
