int ef4_nic_alloc_buffer(struct ef4_nic *efx, struct ef4_buffer *buffer,\r\nunsigned int len, gfp_t gfp_flags)\r\n{\r\nbuffer->addr = dma_zalloc_coherent(&efx->pci_dev->dev, len,\r\n&buffer->dma_addr, gfp_flags);\r\nif (!buffer->addr)\r\nreturn -ENOMEM;\r\nbuffer->len = len;\r\nreturn 0;\r\n}\r\nvoid ef4_nic_free_buffer(struct ef4_nic *efx, struct ef4_buffer *buffer)\r\n{\r\nif (buffer->addr) {\r\ndma_free_coherent(&efx->pci_dev->dev, buffer->len,\r\nbuffer->addr, buffer->dma_addr);\r\nbuffer->addr = NULL;\r\n}\r\n}\r\nbool ef4_nic_event_present(struct ef4_channel *channel)\r\n{\r\nreturn ef4_event_present(ef4_event(channel, channel->eventq_read_ptr));\r\n}\r\nvoid ef4_nic_event_test_start(struct ef4_channel *channel)\r\n{\r\nchannel->event_test_cpu = -1;\r\nsmp_wmb();\r\nchannel->efx->type->ev_test_generate(channel);\r\n}\r\nint ef4_nic_irq_test_start(struct ef4_nic *efx)\r\n{\r\nefx->last_irq_cpu = -1;\r\nsmp_wmb();\r\nreturn efx->type->irq_test_generate(efx);\r\n}\r\nint ef4_nic_init_interrupt(struct ef4_nic *efx)\r\n{\r\nstruct ef4_channel *channel;\r\nunsigned int n_irqs;\r\nint rc;\r\nif (!EF4_INT_MODE_USE_MSI(efx)) {\r\nrc = request_irq(efx->legacy_irq,\r\nefx->type->irq_handle_legacy, IRQF_SHARED,\r\nefx->name, efx);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to hook legacy IRQ %d\n",\r\nefx->pci_dev->irq);\r\ngoto fail1;\r\n}\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_RFS_ACCEL\r\nif (efx->interrupt_mode == EF4_INT_MODE_MSIX) {\r\nefx->net_dev->rx_cpu_rmap =\r\nalloc_irq_cpu_rmap(efx->n_rx_channels);\r\nif (!efx->net_dev->rx_cpu_rmap) {\r\nrc = -ENOMEM;\r\ngoto fail1;\r\n}\r\n}\r\n#endif\r\nn_irqs = 0;\r\nef4_for_each_channel(channel, efx) {\r\nrc = request_irq(channel->irq, efx->type->irq_handle_msi,\r\nIRQF_PROBE_SHARED,\r\nefx->msi_context[channel->channel].name,\r\n&efx->msi_context[channel->channel]);\r\nif (rc) {\r\nnetif_err(efx, drv, efx->net_dev,\r\n"failed to hook IRQ %d\n", channel->irq);\r\ngoto fail2;\r\n}\r\n++n_irqs;\r\n#ifdef CONFIG_RFS_ACCEL\r\nif (efx->interrupt_mode == EF4_INT_MODE_MSIX &&\r\nchannel->channel < efx->n_rx_channels) {\r\nrc = irq_cpu_rmap_add(efx->net_dev->rx_cpu_rmap,\r\nchannel->irq);\r\nif (rc)\r\ngoto fail2;\r\n}\r\n#endif\r\n}\r\nreturn 0;\r\nfail2:\r\n#ifdef CONFIG_RFS_ACCEL\r\nfree_irq_cpu_rmap(efx->net_dev->rx_cpu_rmap);\r\nefx->net_dev->rx_cpu_rmap = NULL;\r\n#endif\r\nef4_for_each_channel(channel, efx) {\r\nif (n_irqs-- == 0)\r\nbreak;\r\nfree_irq(channel->irq, &efx->msi_context[channel->channel]);\r\n}\r\nfail1:\r\nreturn rc;\r\n}\r\nvoid ef4_nic_fini_interrupt(struct ef4_nic *efx)\r\n{\r\nstruct ef4_channel *channel;\r\n#ifdef CONFIG_RFS_ACCEL\r\nfree_irq_cpu_rmap(efx->net_dev->rx_cpu_rmap);\r\nefx->net_dev->rx_cpu_rmap = NULL;\r\n#endif\r\nif (EF4_INT_MODE_USE_MSI(efx)) {\r\nef4_for_each_channel(channel, efx)\r\nfree_irq(channel->irq,\r\n&efx->msi_context[channel->channel]);\r\n} else {\r\nfree_irq(efx->legacy_irq, efx);\r\n}\r\n}\r\nsize_t ef4_nic_get_regs_len(struct ef4_nic *efx)\r\n{\r\nconst struct ef4_nic_reg *reg;\r\nconst struct ef4_nic_reg_table *table;\r\nsize_t len = 0;\r\nfor (reg = ef4_nic_regs;\r\nreg < ef4_nic_regs + ARRAY_SIZE(ef4_nic_regs);\r\nreg++)\r\nif (efx->type->revision >= reg->min_revision &&\r\nefx->type->revision <= reg->max_revision)\r\nlen += sizeof(ef4_oword_t);\r\nfor (table = ef4_nic_reg_tables;\r\ntable < ef4_nic_reg_tables + ARRAY_SIZE(ef4_nic_reg_tables);\r\ntable++)\r\nif (efx->type->revision >= table->min_revision &&\r\nefx->type->revision <= table->max_revision)\r\nlen += table->rows * min_t(size_t, table->step, 16);\r\nreturn len;\r\n}\r\nvoid ef4_nic_get_regs(struct ef4_nic *efx, void *buf)\r\n{\r\nconst struct ef4_nic_reg *reg;\r\nconst struct ef4_nic_reg_table *table;\r\nfor (reg = ef4_nic_regs;\r\nreg < ef4_nic_regs + ARRAY_SIZE(ef4_nic_regs);\r\nreg++) {\r\nif (efx->type->revision >= reg->min_revision &&\r\nefx->type->revision <= reg->max_revision) {\r\nef4_reado(efx, (ef4_oword_t *)buf, reg->offset);\r\nbuf += sizeof(ef4_oword_t);\r\n}\r\n}\r\nfor (table = ef4_nic_reg_tables;\r\ntable < ef4_nic_reg_tables + ARRAY_SIZE(ef4_nic_reg_tables);\r\ntable++) {\r\nsize_t size, i;\r\nif (!(efx->type->revision >= table->min_revision &&\r\nefx->type->revision <= table->max_revision))\r\ncontinue;\r\nsize = min_t(size_t, table->step, 16);\r\nfor (i = 0; i < table->rows; i++) {\r\nswitch (table->step) {\r\ncase 4:\r\nef4_readd(efx, buf, table->offset + 4 * i);\r\nbreak;\r\ncase 8:\r\nef4_sram_readq(efx,\r\nefx->membase + table->offset,\r\nbuf, i);\r\nbreak;\r\ncase 16:\r\nef4_reado_table(efx, buf, table->offset, i);\r\nbreak;\r\ncase 32:\r\nef4_reado_table(efx, buf, table->offset, 2 * i);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nreturn;\r\n}\r\nbuf += size;\r\n}\r\n}\r\n}\r\nsize_t ef4_nic_describe_stats(const struct ef4_hw_stat_desc *desc, size_t count,\r\nconst unsigned long *mask, u8 *names)\r\n{\r\nsize_t visible = 0;\r\nsize_t index;\r\nfor_each_set_bit(index, mask, count) {\r\nif (desc[index].name) {\r\nif (names) {\r\nstrlcpy(names, desc[index].name,\r\nETH_GSTRING_LEN);\r\nnames += ETH_GSTRING_LEN;\r\n}\r\n++visible;\r\n}\r\n}\r\nreturn visible;\r\n}\r\nvoid ef4_nic_update_stats(const struct ef4_hw_stat_desc *desc, size_t count,\r\nconst unsigned long *mask,\r\nu64 *stats, const void *dma_buf, bool accumulate)\r\n{\r\nsize_t index;\r\nfor_each_set_bit(index, mask, count) {\r\nif (desc[index].dma_width) {\r\nconst void *addr = dma_buf + desc[index].offset;\r\nu64 val;\r\nswitch (desc[index].dma_width) {\r\ncase 16:\r\nval = le16_to_cpup((__le16 *)addr);\r\nbreak;\r\ncase 32:\r\nval = le32_to_cpup((__le32 *)addr);\r\nbreak;\r\ncase 64:\r\nval = le64_to_cpup((__le64 *)addr);\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nval = 0;\r\nbreak;\r\n}\r\nif (accumulate)\r\nstats[index] += val;\r\nelse\r\nstats[index] = val;\r\n}\r\n}\r\n}\r\nvoid ef4_nic_fix_nodesc_drop_stat(struct ef4_nic *efx, u64 *rx_nodesc_drops)\r\n{\r\nif (!(efx->net_dev->flags & IFF_UP) || !efx->rx_nodesc_drops_prev_state)\r\nefx->rx_nodesc_drops_while_down +=\r\n*rx_nodesc_drops - efx->rx_nodesc_drops_total;\r\nefx->rx_nodesc_drops_total = *rx_nodesc_drops;\r\nefx->rx_nodesc_drops_prev_state = !!(efx->net_dev->flags & IFF_UP);\r\n*rx_nodesc_drops -= efx->rx_nodesc_drops_while_down;\r\n}
