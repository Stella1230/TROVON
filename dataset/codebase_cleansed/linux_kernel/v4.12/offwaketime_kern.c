int waker(struct pt_regs *ctx)\r\n{\r\nstruct task_struct *p = (void *) PT_REGS_PARM1(ctx);\r\nstruct wokeby_t woke;\r\nu32 pid;\r\npid = _(p->pid);\r\nbpf_get_current_comm(&woke.name, sizeof(woke.name));\r\nwoke.ret = bpf_get_stackid(ctx, &stackmap, STACKID_FLAGS);\r\nbpf_map_update_elem(&wokeby, &pid, &woke, BPF_ANY);\r\nreturn 0;\r\n}\r\nstatic inline int update_counts(void *ctx, u32 pid, u64 delta)\r\n{\r\nstruct wokeby_t *woke;\r\nu64 zero = 0, *val;\r\nstruct key_t key;\r\n__builtin_memset(&key.waker, 0, sizeof(key.waker));\r\nbpf_get_current_comm(&key.target, sizeof(key.target));\r\nkey.tret = bpf_get_stackid(ctx, &stackmap, STACKID_FLAGS);\r\nkey.wret = 0;\r\nwoke = bpf_map_lookup_elem(&wokeby, &pid);\r\nif (woke) {\r\nkey.wret = woke->ret;\r\n__builtin_memcpy(&key.waker, woke->name, sizeof(key.waker));\r\nbpf_map_delete_elem(&wokeby, &pid);\r\n}\r\nval = bpf_map_lookup_elem(&counts, &key);\r\nif (!val) {\r\nbpf_map_update_elem(&counts, &key, &zero, BPF_NOEXIST);\r\nval = bpf_map_lookup_elem(&counts, &key);\r\nif (!val)\r\nreturn 0;\r\n}\r\n(*val) += delta;\r\nreturn 0;\r\n}\r\nint oncpu(struct pt_regs *ctx)\r\n{\r\nstruct task_struct *p = (void *) PT_REGS_PARM1(ctx);\r\nu32 pid = _(p->pid);\r\n#endif\r\nu64 delta, ts, *tsp;\r\nts = bpf_ktime_get_ns();\r\nbpf_map_update_elem(&start, &pid, &ts, BPF_ANY);\r\npid = bpf_get_current_pid_tgid();\r\ntsp = bpf_map_lookup_elem(&start, &pid);\r\nif (!tsp)\r\nreturn 0;\r\ndelta = bpf_ktime_get_ns() - *tsp;\r\nbpf_map_delete_elem(&start, &pid);\r\ndelta = delta / 1000;\r\nif (delta < MINBLOCK_US)\r\nreturn 0;\r\nreturn update_counts(ctx, pid, delta);\r\n}
