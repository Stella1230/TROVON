static int sg_calculate_split(struct scatterlist *in, int nents, int nb_splits,\r\noff_t skip, const size_t *sizes,\r\nstruct sg_splitter *splitters, bool mapped)\r\n{\r\nint i;\r\nunsigned int sglen;\r\nsize_t size = sizes[0], len;\r\nstruct sg_splitter *curr = splitters;\r\nstruct scatterlist *sg;\r\nfor (i = 0; i < nb_splits; i++) {\r\nsplitters[i].in_sg0 = NULL;\r\nsplitters[i].nents = 0;\r\n}\r\nfor_each_sg(in, sg, nents, i) {\r\nsglen = mapped ? sg_dma_len(sg) : sg->length;\r\nif (skip > sglen) {\r\nskip -= sglen;\r\ncontinue;\r\n}\r\nlen = min_t(size_t, size, sglen - skip);\r\nif (!curr->in_sg0) {\r\ncurr->in_sg0 = sg;\r\ncurr->skip_sg0 = skip;\r\n}\r\nsize -= len;\r\ncurr->nents++;\r\ncurr->length_last_sg = len;\r\nwhile (!size && (skip + len < sglen) && (--nb_splits > 0)) {\r\ncurr++;\r\nsize = *(++sizes);\r\nskip += len;\r\nlen = min_t(size_t, size, sglen - skip);\r\ncurr->in_sg0 = sg;\r\ncurr->skip_sg0 = skip;\r\ncurr->nents = 1;\r\ncurr->length_last_sg = len;\r\nsize -= len;\r\n}\r\nskip = 0;\r\nif (!size && --nb_splits > 0) {\r\ncurr++;\r\nsize = *(++sizes);\r\n}\r\nif (!nb_splits)\r\nbreak;\r\n}\r\nreturn (size || !splitters[0].in_sg0) ? -EINVAL : 0;\r\n}\r\nstatic void sg_split_phys(struct sg_splitter *splitters, const int nb_splits)\r\n{\r\nint i, j;\r\nstruct scatterlist *in_sg, *out_sg;\r\nstruct sg_splitter *split;\r\nfor (i = 0, split = splitters; i < nb_splits; i++, split++) {\r\nin_sg = split->in_sg0;\r\nout_sg = split->out_sg;\r\nfor (j = 0; j < split->nents; j++, out_sg++) {\r\n*out_sg = *in_sg;\r\nif (!j) {\r\nout_sg->offset += split->skip_sg0;\r\nout_sg->length -= split->skip_sg0;\r\n} else {\r\nout_sg->offset = 0;\r\n}\r\nsg_dma_address(out_sg) = 0;\r\nsg_dma_len(out_sg) = 0;\r\nin_sg = sg_next(in_sg);\r\n}\r\nout_sg[-1].length = split->length_last_sg;\r\nsg_mark_end(out_sg - 1);\r\n}\r\n}\r\nstatic void sg_split_mapped(struct sg_splitter *splitters, const int nb_splits)\r\n{\r\nint i, j;\r\nstruct scatterlist *in_sg, *out_sg;\r\nstruct sg_splitter *split;\r\nfor (i = 0, split = splitters; i < nb_splits; i++, split++) {\r\nin_sg = split->in_sg0;\r\nout_sg = split->out_sg;\r\nfor (j = 0; j < split->nents; j++, out_sg++) {\r\nsg_dma_address(out_sg) = sg_dma_address(in_sg);\r\nsg_dma_len(out_sg) = sg_dma_len(in_sg);\r\nif (!j) {\r\nsg_dma_address(out_sg) += split->skip_sg0;\r\nsg_dma_len(out_sg) -= split->skip_sg0;\r\n}\r\nin_sg = sg_next(in_sg);\r\n}\r\nsg_dma_len(--out_sg) = split->length_last_sg;\r\n}\r\n}\r\nint sg_split(struct scatterlist *in, const int in_mapped_nents,\r\nconst off_t skip, const int nb_splits,\r\nconst size_t *split_sizes,\r\nstruct scatterlist **out, int *out_mapped_nents,\r\ngfp_t gfp_mask)\r\n{\r\nint i, ret;\r\nstruct sg_splitter *splitters;\r\nsplitters = kcalloc(nb_splits, sizeof(*splitters), gfp_mask);\r\nif (!splitters)\r\nreturn -ENOMEM;\r\nret = sg_calculate_split(in, sg_nents(in), nb_splits, skip, split_sizes,\r\nsplitters, false);\r\nif (ret < 0)\r\ngoto err;\r\nret = -ENOMEM;\r\nfor (i = 0; i < nb_splits; i++) {\r\nsplitters[i].out_sg = kmalloc_array(splitters[i].nents,\r\nsizeof(struct scatterlist),\r\ngfp_mask);\r\nif (!splitters[i].out_sg)\r\ngoto err;\r\n}\r\nsg_split_phys(splitters, nb_splits);\r\nret = sg_calculate_split(in, in_mapped_nents, nb_splits, skip,\r\nsplit_sizes, splitters, true);\r\nif (ret < 0)\r\ngoto err;\r\nsg_split_mapped(splitters, nb_splits);\r\nfor (i = 0; i < nb_splits; i++) {\r\nout[i] = splitters[i].out_sg;\r\nif (out_mapped_nents)\r\nout_mapped_nents[i] = splitters[i].nents;\r\n}\r\nkfree(splitters);\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < nb_splits; i++)\r\nkfree(splitters[i].out_sg);\r\nkfree(splitters);\r\nreturn ret;\r\n}
