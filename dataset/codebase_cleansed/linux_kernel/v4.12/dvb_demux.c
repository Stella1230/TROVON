static inline u16 section_length(const u8 *buf)\r\n{\r\nreturn 3 + ((buf[1] & 0x0f) << 8) + buf[2];\r\n}\r\nstatic inline u16 ts_pid(const u8 *buf)\r\n{\r\nreturn ((buf[1] & 0x1f) << 8) + buf[2];\r\n}\r\nstatic inline u8 payload(const u8 *tsp)\r\n{\r\nif (!(tsp[3] & 0x10))\r\nreturn 0;\r\nif (tsp[3] & 0x20) {\r\nif (tsp[4] > 183)\r\nreturn 0;\r\nelse\r\nreturn 184 - 1 - tsp[4];\r\n}\r\nreturn 184;\r\n}\r\nstatic u32 dvb_dmx_crc32(struct dvb_demux_feed *f, const u8 *src, size_t len)\r\n{\r\nreturn (f->feed.sec.crc_val = crc32_be(f->feed.sec.crc_val, src, len));\r\n}\r\nstatic void dvb_dmx_memcopy(struct dvb_demux_feed *f, u8 *d, const u8 *s,\r\nsize_t len)\r\n{\r\nmemcpy(d, s, len);\r\n}\r\nstatic inline int dvb_dmx_swfilter_payload(struct dvb_demux_feed *feed,\r\nconst u8 *buf)\r\n{\r\nint count = payload(buf);\r\nint p;\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\nint ccok;\r\nu8 cc;\r\n#endif\r\nif (count == 0)\r\nreturn -1;\r\np = 188 - count;\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\ncc = buf[3] & 0x0f;\r\nccok = ((feed->cc + 1) & 0x0f) == cc;\r\nfeed->cc = cc;\r\nif (!ccok)\r\ndprintk("missed packet!\n");\r\n#endif\r\nif (buf[1] & 0x40)\r\nfeed->peslen = 0xfffa;\r\nfeed->peslen += count;\r\nreturn feed->cb.ts(&buf[p], count, NULL, 0, &feed->feed.ts);\r\n}\r\nstatic int dvb_dmx_swfilter_sectionfilter(struct dvb_demux_feed *feed,\r\nstruct dvb_demux_filter *f)\r\n{\r\nu8 neq = 0;\r\nint i;\r\nfor (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {\r\nu8 xor = f->filter.filter_value[i] ^ feed->feed.sec.secbuf[i];\r\nif (f->maskandmode[i] & xor)\r\nreturn 0;\r\nneq |= f->maskandnotmode[i] & xor;\r\n}\r\nif (f->doneq && !neq)\r\nreturn 0;\r\nreturn feed->cb.sec(feed->feed.sec.secbuf, feed->feed.sec.seclen,\r\nNULL, 0, &f->filter);\r\n}\r\nstatic inline int dvb_dmx_swfilter_section_feed(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct dvb_demux_filter *f = feed->filter;\r\nstruct dmx_section_feed *sec = &feed->feed.sec;\r\nint section_syntax_indicator;\r\nif (!sec->is_filtering)\r\nreturn 0;\r\nif (!f)\r\nreturn 0;\r\nif (sec->check_crc) {\r\nsection_syntax_indicator = ((sec->secbuf[1] & 0x80) != 0);\r\nif (section_syntax_indicator &&\r\ndemux->check_crc32(feed, sec->secbuf, sec->seclen))\r\nreturn -1;\r\n}\r\ndo {\r\nif (dvb_dmx_swfilter_sectionfilter(feed, f) < 0)\r\nreturn -1;\r\n} while ((f = f->next) && sec->is_filtering);\r\nsec->seclen = 0;\r\nreturn 0;\r\n}\r\nstatic void dvb_dmx_swfilter_section_new(struct dvb_demux_feed *feed)\r\n{\r\nstruct dmx_section_feed *sec = &feed->feed.sec;\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\nif (sec->secbufp < sec->tsfeedp) {\r\nint i, n = sec->tsfeedp - sec->secbufp;\r\nif (sec->secbuf[0] != 0xff || sec->secbuf[n - 1] != 0xff) {\r\ndprintk("dvb_demux.c section ts padding loss: %d/%d\n",\r\nn, sec->tsfeedp);\r\ndprintk("dvb_demux.c pad data:");\r\nfor (i = 0; i < n; i++)\r\npr_cont(" %02x", sec->secbuf[i]);\r\npr_cont("\n");\r\n}\r\n}\r\n#endif\r\nsec->tsfeedp = sec->secbufp = sec->seclen = 0;\r\nsec->secbuf = sec->secbuf_base;\r\n}\r\nstatic int dvb_dmx_swfilter_section_copy_dump(struct dvb_demux_feed *feed,\r\nconst u8 *buf, u8 len)\r\n{\r\nstruct dvb_demux *demux = feed->demux;\r\nstruct dmx_section_feed *sec = &feed->feed.sec;\r\nu16 limit, seclen, n;\r\nif (sec->tsfeedp >= DMX_MAX_SECFEED_SIZE)\r\nreturn 0;\r\nif (sec->tsfeedp + len > DMX_MAX_SECFEED_SIZE) {\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\ndprintk("dvb_demux.c section buffer full loss: %d/%d\n",\r\nsec->tsfeedp + len - DMX_MAX_SECFEED_SIZE,\r\nDMX_MAX_SECFEED_SIZE);\r\n#endif\r\nlen = DMX_MAX_SECFEED_SIZE - sec->tsfeedp;\r\n}\r\nif (len <= 0)\r\nreturn 0;\r\ndemux->memcopy(feed, sec->secbuf_base + sec->tsfeedp, buf, len);\r\nsec->tsfeedp += len;\r\nlimit = sec->tsfeedp;\r\nif (limit > DMX_MAX_SECFEED_SIZE)\r\nreturn -1;\r\nsec->secbuf = sec->secbuf_base + sec->secbufp;\r\nfor (n = 0; sec->secbufp + 2 < limit; n++) {\r\nseclen = section_length(sec->secbuf);\r\nif (seclen <= 0 || seclen > DMX_MAX_SECTION_SIZE\r\n|| seclen + sec->secbufp > limit)\r\nreturn 0;\r\nsec->seclen = seclen;\r\nsec->crc_val = ~0;\r\nif (feed->pusi_seen)\r\ndvb_dmx_swfilter_section_feed(feed);\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\nelse\r\ndprintk("dvb_demux.c pusi not seen, discarding section data\n");\r\n#endif\r\nsec->secbufp += seclen;\r\nsec->secbuf += seclen;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvb_dmx_swfilter_section_packet(struct dvb_demux_feed *feed,\r\nconst u8 *buf)\r\n{\r\nu8 p, count;\r\nint ccok, dc_i = 0;\r\nu8 cc;\r\ncount = payload(buf);\r\nif (count == 0)\r\nreturn -1;\r\np = 188 - count;\r\ncc = buf[3] & 0x0f;\r\nccok = ((feed->cc + 1) & 0x0f) == cc;\r\nfeed->cc = cc;\r\nif (buf[3] & 0x20) {\r\nif ((buf[4] > 0) && (buf[5] & 0x80))\r\ndc_i = 1;\r\n}\r\nif (!ccok || dc_i) {\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\ndprintk("dvb_demux.c discontinuity detected %d bytes lost\n",\r\ncount);\r\n#endif\r\nfeed->pusi_seen = 0;\r\ndvb_dmx_swfilter_section_new(feed);\r\n}\r\nif (buf[1] & 0x40) {\r\nif (count > 1 && buf[p] < count) {\r\nconst u8 *before = &buf[p + 1];\r\nu8 before_len = buf[p];\r\nconst u8 *after = &before[before_len];\r\nu8 after_len = count - 1 - before_len;\r\ndvb_dmx_swfilter_section_copy_dump(feed, before,\r\nbefore_len);\r\nfeed->pusi_seen = 1;\r\ndvb_dmx_swfilter_section_new(feed);\r\ndvb_dmx_swfilter_section_copy_dump(feed, after,\r\nafter_len);\r\n}\r\n#ifdef CONFIG_DVB_DEMUX_SECTION_LOSS_LOG\r\nelse if (count > 0)\r\ndprintk("dvb_demux.c PUSI=1 but %d bytes lost\n",\r\ncount);\r\n#endif\r\n} else {\r\ndvb_dmx_swfilter_section_copy_dump(feed, &buf[p], count);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void dvb_dmx_swfilter_packet_type(struct dvb_demux_feed *feed,\r\nconst u8 *buf)\r\n{\r\nswitch (feed->type) {\r\ncase DMX_TYPE_TS:\r\nif (!feed->feed.ts.is_filtering)\r\nbreak;\r\nif (feed->ts_type & TS_PACKET) {\r\nif (feed->ts_type & TS_PAYLOAD_ONLY)\r\ndvb_dmx_swfilter_payload(feed, buf);\r\nelse\r\nfeed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts);\r\n}\r\nif (feed->ts_type & TS_DECODER)\r\nif (feed->demux->write_to_decoder)\r\nfeed->demux->write_to_decoder(feed, buf, 188);\r\nbreak;\r\ncase DMX_TYPE_SEC:\r\nif (!feed->feed.sec.is_filtering)\r\nbreak;\r\nif (dvb_dmx_swfilter_section_packet(feed, buf) < 0)\r\nfeed->feed.sec.seclen = feed->feed.sec.secbufp = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf)\r\n{\r\nstruct dvb_demux_feed *feed;\r\nu16 pid = ts_pid(buf);\r\nint dvr_done = 0;\r\nif (dvb_demux_speedcheck) {\r\nktime_t cur_time;\r\nu64 speed_bytes, speed_timedelta;\r\ndemux->speed_pkts_cnt++;\r\nif (!(demux->speed_pkts_cnt % SPEED_PKTS_INTERVAL)) {\r\ncur_time = ktime_get();\r\nif (ktime_to_ns(demux->speed_last_time) != 0) {\r\nspeed_bytes = (u64)demux->speed_pkts_cnt\r\n* 188 * 8;\r\nspeed_bytes = 1000 * div64_u64(speed_bytes,\r\n1024);\r\nspeed_timedelta = ktime_ms_delta(cur_time,\r\ndemux->speed_last_time);\r\ndprintk("TS speed %llu Kbits/sec \n",\r\ndiv64_u64(speed_bytes,\r\nspeed_timedelta));\r\n}\r\ndemux->speed_last_time = cur_time;\r\ndemux->speed_pkts_cnt = 0;\r\n}\r\n}\r\nif (buf[1] & 0x80) {\r\ndprintk_tscheck("TEI detected. PID=0x%x data1=0x%x\n",\r\npid, buf[1]);\r\nif (!dvb_demux_feed_err_pkts)\r\nreturn;\r\n} else\r\nif (demux->cnt_storage && dvb_demux_tscheck) {\r\nif (pid < MAX_PID) {\r\nif (buf[3] & 0x10)\r\ndemux->cnt_storage[pid] =\r\n(demux->cnt_storage[pid] + 1) & 0xf;\r\nif ((buf[3] & 0xf) != demux->cnt_storage[pid]) {\r\ndprintk_tscheck("TS packet counter mismatch. PID=0x%x expected 0x%x got 0x%x\n",\r\npid, demux->cnt_storage[pid],\r\nbuf[3] & 0xf);\r\ndemux->cnt_storage[pid] = buf[3] & 0xf;\r\n}\r\n}\r\n}\r\nlist_for_each_entry(feed, &demux->feed_list, list_head) {\r\nif ((feed->pid != pid) && (feed->pid != 0x2000))\r\ncontinue;\r\nif ((DVR_FEED(feed)) && (dvr_done++))\r\ncontinue;\r\nif (feed->pid == pid)\r\ndvb_dmx_swfilter_packet_type(feed, buf);\r\nelse if (feed->pid == 0x2000)\r\nfeed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts);\r\n}\r\n}\r\nvoid dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf,\r\nsize_t count)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&demux->lock, flags);\r\nwhile (count--) {\r\nif (buf[0] == 0x47)\r\ndvb_dmx_swfilter_packet(demux, buf);\r\nbuf += 188;\r\n}\r\nspin_unlock_irqrestore(&demux->lock, flags);\r\n}\r\nstatic inline int find_next_packet(const u8 *buf, int pos, size_t count,\r\nconst int pktsize)\r\n{\r\nint start = pos, lost;\r\nwhile (pos < count) {\r\nif (buf[pos] == 0x47 ||\r\n(pktsize == 204 && buf[pos] == 0xB8))\r\nbreak;\r\npos++;\r\n}\r\nlost = pos - start;\r\nif (lost) {\r\nint backtrack = pos - pktsize;\r\nif (backtrack >= 0 && (buf[backtrack] == 0x47 ||\r\n(pktsize == 204 && buf[backtrack] == 0xB8)))\r\nreturn backtrack;\r\n}\r\nreturn pos;\r\n}\r\nstatic inline void _dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf,\r\nsize_t count, const int pktsize)\r\n{\r\nint p = 0, i, j;\r\nconst u8 *q;\r\nunsigned long flags;\r\nspin_lock_irqsave(&demux->lock, flags);\r\nif (demux->tsbufp) {\r\ni = demux->tsbufp;\r\nj = pktsize - i;\r\nif (count < j) {\r\nmemcpy(&demux->tsbuf[i], buf, count);\r\ndemux->tsbufp += count;\r\ngoto bailout;\r\n}\r\nmemcpy(&demux->tsbuf[i], buf, j);\r\nif (demux->tsbuf[0] == 0x47)\r\ndvb_dmx_swfilter_packet(demux, demux->tsbuf);\r\ndemux->tsbufp = 0;\r\np += j;\r\n}\r\nwhile (1) {\r\np = find_next_packet(buf, p, count, pktsize);\r\nif (p >= count)\r\nbreak;\r\nif (count - p < pktsize)\r\nbreak;\r\nq = &buf[p];\r\nif (pktsize == 204 && (*q == 0xB8)) {\r\nmemcpy(demux->tsbuf, q, 188);\r\ndemux->tsbuf[0] = 0x47;\r\nq = demux->tsbuf;\r\n}\r\ndvb_dmx_swfilter_packet(demux, q);\r\np += pktsize;\r\n}\r\ni = count - p;\r\nif (i) {\r\nmemcpy(demux->tsbuf, &buf[p], i);\r\ndemux->tsbufp = i;\r\nif (pktsize == 204 && demux->tsbuf[0] == 0xB8)\r\ndemux->tsbuf[0] = 0x47;\r\n}\r\nbailout:\r\nspin_unlock_irqrestore(&demux->lock, flags);\r\n}\r\nvoid dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf, size_t count)\r\n{\r\n_dvb_dmx_swfilter(demux, buf, count, 188);\r\n}\r\nvoid dvb_dmx_swfilter_204(struct dvb_demux *demux, const u8 *buf, size_t count)\r\n{\r\n_dvb_dmx_swfilter(demux, buf, count, 204);\r\n}\r\nvoid dvb_dmx_swfilter_raw(struct dvb_demux *demux, const u8 *buf, size_t count)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&demux->lock, flags);\r\ndemux->feed->cb.ts(buf, count, NULL, 0, &demux->feed->feed.ts);\r\nspin_unlock_irqrestore(&demux->lock, flags);\r\n}\r\nstatic struct dvb_demux_filter *dvb_dmx_filter_alloc(struct dvb_demux *demux)\r\n{\r\nint i;\r\nfor (i = 0; i < demux->filternum; i++)\r\nif (demux->filter[i].state == DMX_STATE_FREE)\r\nbreak;\r\nif (i == demux->filternum)\r\nreturn NULL;\r\ndemux->filter[i].state = DMX_STATE_ALLOCATED;\r\nreturn &demux->filter[i];\r\n}\r\nstatic struct dvb_demux_feed *dvb_dmx_feed_alloc(struct dvb_demux *demux)\r\n{\r\nint i;\r\nfor (i = 0; i < demux->feednum; i++)\r\nif (demux->feed[i].state == DMX_STATE_FREE)\r\nbreak;\r\nif (i == demux->feednum)\r\nreturn NULL;\r\ndemux->feed[i].state = DMX_STATE_ALLOCATED;\r\nreturn &demux->feed[i];\r\n}\r\nstatic int dvb_demux_feed_find(struct dvb_demux_feed *feed)\r\n{\r\nstruct dvb_demux_feed *entry;\r\nlist_for_each_entry(entry, &feed->demux->feed_list, list_head)\r\nif (entry == feed)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void dvb_demux_feed_add(struct dvb_demux_feed *feed)\r\n{\r\nspin_lock_irq(&feed->demux->lock);\r\nif (dvb_demux_feed_find(feed)) {\r\npr_err("%s: feed already in list (type=%x state=%x pid=%x)\n",\r\n__func__, feed->type, feed->state, feed->pid);\r\ngoto out;\r\n}\r\nlist_add(&feed->list_head, &feed->demux->feed_list);\r\nout:\r\nspin_unlock_irq(&feed->demux->lock);\r\n}\r\nstatic void dvb_demux_feed_del(struct dvb_demux_feed *feed)\r\n{\r\nspin_lock_irq(&feed->demux->lock);\r\nif (!(dvb_demux_feed_find(feed))) {\r\npr_err("%s: feed not in list (type=%x state=%x pid=%x)\n",\r\n__func__, feed->type, feed->state, feed->pid);\r\ngoto out;\r\n}\r\nlist_del(&feed->list_head);\r\nout:\r\nspin_unlock_irq(&feed->demux->lock);\r\n}\r\nstatic int dmx_ts_feed_set(struct dmx_ts_feed *ts_feed, u16 pid, int ts_type,\r\nenum dmx_ts_pes pes_type, ktime_t timeout)\r\n{\r\nstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\r\nstruct dvb_demux *demux = feed->demux;\r\nif (pid > DMX_MAX_PID)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&demux->mutex))\r\nreturn -ERESTARTSYS;\r\nif (ts_type & TS_DECODER) {\r\nif (pes_type >= DMX_PES_OTHER) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -EINVAL;\r\n}\r\nif (demux->pesfilter[pes_type] &&\r\ndemux->pesfilter[pes_type] != feed) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -EINVAL;\r\n}\r\ndemux->pesfilter[pes_type] = feed;\r\ndemux->pids[pes_type] = pid;\r\n}\r\ndvb_demux_feed_add(feed);\r\nfeed->pid = pid;\r\nfeed->timeout = timeout;\r\nfeed->ts_type = ts_type;\r\nfeed->pes_type = pes_type;\r\nfeed->state = DMX_STATE_READY;\r\nmutex_unlock(&demux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dmx_ts_feed_start_filtering(struct dmx_ts_feed *ts_feed)\r\n{\r\nstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\r\nstruct dvb_demux *demux = feed->demux;\r\nint ret;\r\nif (mutex_lock_interruptible(&demux->mutex))\r\nreturn -ERESTARTSYS;\r\nif (feed->state != DMX_STATE_READY || feed->type != DMX_TYPE_TS) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -EINVAL;\r\n}\r\nif (!demux->start_feed) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -ENODEV;\r\n}\r\nif ((ret = demux->start_feed(feed)) < 0) {\r\nmutex_unlock(&demux->mutex);\r\nreturn ret;\r\n}\r\nspin_lock_irq(&demux->lock);\r\nts_feed->is_filtering = 1;\r\nfeed->state = DMX_STATE_GO;\r\nspin_unlock_irq(&demux->lock);\r\nmutex_unlock(&demux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dmx_ts_feed_stop_filtering(struct dmx_ts_feed *ts_feed)\r\n{\r\nstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\r\nstruct dvb_demux *demux = feed->demux;\r\nint ret;\r\nmutex_lock(&demux->mutex);\r\nif (feed->state < DMX_STATE_GO) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -EINVAL;\r\n}\r\nif (!demux->stop_feed) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -ENODEV;\r\n}\r\nret = demux->stop_feed(feed);\r\nspin_lock_irq(&demux->lock);\r\nts_feed->is_filtering = 0;\r\nfeed->state = DMX_STATE_ALLOCATED;\r\nspin_unlock_irq(&demux->lock);\r\nmutex_unlock(&demux->mutex);\r\nreturn ret;\r\n}\r\nstatic int dvbdmx_allocate_ts_feed(struct dmx_demux *dmx,\r\nstruct dmx_ts_feed **ts_feed,\r\ndmx_ts_cb callback)\r\n{\r\nstruct dvb_demux *demux = (struct dvb_demux *)dmx;\r\nstruct dvb_demux_feed *feed;\r\nif (mutex_lock_interruptible(&demux->mutex))\r\nreturn -ERESTARTSYS;\r\nif (!(feed = dvb_dmx_feed_alloc(demux))) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -EBUSY;\r\n}\r\nfeed->type = DMX_TYPE_TS;\r\nfeed->cb.ts = callback;\r\nfeed->demux = demux;\r\nfeed->pid = 0xffff;\r\nfeed->peslen = 0xfffa;\r\n(*ts_feed) = &feed->feed.ts;\r\n(*ts_feed)->parent = dmx;\r\n(*ts_feed)->priv = NULL;\r\n(*ts_feed)->is_filtering = 0;\r\n(*ts_feed)->start_filtering = dmx_ts_feed_start_filtering;\r\n(*ts_feed)->stop_filtering = dmx_ts_feed_stop_filtering;\r\n(*ts_feed)->set = dmx_ts_feed_set;\r\nif (!(feed->filter = dvb_dmx_filter_alloc(demux))) {\r\nfeed->state = DMX_STATE_FREE;\r\nmutex_unlock(&demux->mutex);\r\nreturn -EBUSY;\r\n}\r\nfeed->filter->type = DMX_TYPE_TS;\r\nfeed->filter->feed = feed;\r\nfeed->filter->state = DMX_STATE_READY;\r\nmutex_unlock(&demux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_release_ts_feed(struct dmx_demux *dmx,\r\nstruct dmx_ts_feed *ts_feed)\r\n{\r\nstruct dvb_demux *demux = (struct dvb_demux *)dmx;\r\nstruct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;\r\nmutex_lock(&demux->mutex);\r\nif (feed->state == DMX_STATE_FREE) {\r\nmutex_unlock(&demux->mutex);\r\nreturn -EINVAL;\r\n}\r\nfeed->state = DMX_STATE_FREE;\r\nfeed->filter->state = DMX_STATE_FREE;\r\ndvb_demux_feed_del(feed);\r\nfeed->pid = 0xffff;\r\nif (feed->ts_type & TS_DECODER && feed->pes_type < DMX_PES_OTHER)\r\ndemux->pesfilter[feed->pes_type] = NULL;\r\nmutex_unlock(&demux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dmx_section_feed_allocate_filter(struct dmx_section_feed *feed,\r\nstruct dmx_section_filter **filter)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\r\nstruct dvb_demux *dvbdemux = dvbdmxfeed->demux;\r\nstruct dvb_demux_filter *dvbdmxfilter;\r\nif (mutex_lock_interruptible(&dvbdemux->mutex))\r\nreturn -ERESTARTSYS;\r\ndvbdmxfilter = dvb_dmx_filter_alloc(dvbdemux);\r\nif (!dvbdmxfilter) {\r\nmutex_unlock(&dvbdemux->mutex);\r\nreturn -EBUSY;\r\n}\r\nspin_lock_irq(&dvbdemux->lock);\r\n*filter = &dvbdmxfilter->filter;\r\n(*filter)->parent = feed;\r\n(*filter)->priv = NULL;\r\ndvbdmxfilter->feed = dvbdmxfeed;\r\ndvbdmxfilter->type = DMX_TYPE_SEC;\r\ndvbdmxfilter->state = DMX_STATE_READY;\r\ndvbdmxfilter->next = dvbdmxfeed->filter;\r\ndvbdmxfeed->filter = dvbdmxfilter;\r\nspin_unlock_irq(&dvbdemux->lock);\r\nmutex_unlock(&dvbdemux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dmx_section_feed_set(struct dmx_section_feed *feed,\r\nu16 pid, int check_crc)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nif (pid > 0x1fff)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&dvbdmx->mutex))\r\nreturn -ERESTARTSYS;\r\ndvb_demux_feed_add(dvbdmxfeed);\r\ndvbdmxfeed->pid = pid;\r\ndvbdmxfeed->feed.sec.check_crc = check_crc;\r\ndvbdmxfeed->state = DMX_STATE_READY;\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn 0;\r\n}\r\nstatic void prepare_secfilters(struct dvb_demux_feed *dvbdmxfeed)\r\n{\r\nint i;\r\nstruct dvb_demux_filter *f;\r\nstruct dmx_section_filter *sf;\r\nu8 mask, mode, doneq;\r\nif (!(f = dvbdmxfeed->filter))\r\nreturn;\r\ndo {\r\nsf = &f->filter;\r\ndoneq = 0;\r\nfor (i = 0; i < DVB_DEMUX_MASK_MAX; i++) {\r\nmode = sf->filter_mode[i];\r\nmask = sf->filter_mask[i];\r\nf->maskandmode[i] = mask & mode;\r\ndoneq |= f->maskandnotmode[i] = mask & ~mode;\r\n}\r\nf->doneq = doneq ? 1 : 0;\r\n} while ((f = f->next));\r\n}\r\nstatic int dmx_section_feed_start_filtering(struct dmx_section_feed *feed)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nint ret;\r\nif (mutex_lock_interruptible(&dvbdmx->mutex))\r\nreturn -ERESTARTSYS;\r\nif (feed->is_filtering) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -EBUSY;\r\n}\r\nif (!dvbdmxfeed->filter) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -EINVAL;\r\n}\r\ndvbdmxfeed->feed.sec.tsfeedp = 0;\r\ndvbdmxfeed->feed.sec.secbuf = dvbdmxfeed->feed.sec.secbuf_base;\r\ndvbdmxfeed->feed.sec.secbufp = 0;\r\ndvbdmxfeed->feed.sec.seclen = 0;\r\nif (!dvbdmx->start_feed) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -ENODEV;\r\n}\r\nprepare_secfilters(dvbdmxfeed);\r\nif ((ret = dvbdmx->start_feed(dvbdmxfeed)) < 0) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn ret;\r\n}\r\nspin_lock_irq(&dvbdmx->lock);\r\nfeed->is_filtering = 1;\r\ndvbdmxfeed->state = DMX_STATE_GO;\r\nspin_unlock_irq(&dvbdmx->lock);\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn 0;\r\n}\r\nstatic int dmx_section_feed_stop_filtering(struct dmx_section_feed *feed)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nint ret;\r\nmutex_lock(&dvbdmx->mutex);\r\nif (!dvbdmx->stop_feed) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -ENODEV;\r\n}\r\nret = dvbdmx->stop_feed(dvbdmxfeed);\r\nspin_lock_irq(&dvbdmx->lock);\r\ndvbdmxfeed->state = DMX_STATE_READY;\r\nfeed->is_filtering = 0;\r\nspin_unlock_irq(&dvbdmx->lock);\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn ret;\r\n}\r\nstatic int dmx_section_feed_release_filter(struct dmx_section_feed *feed,\r\nstruct dmx_section_filter *filter)\r\n{\r\nstruct dvb_demux_filter *dvbdmxfilter = (struct dvb_demux_filter *)filter, *f;\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\r\nstruct dvb_demux *dvbdmx = dvbdmxfeed->demux;\r\nmutex_lock(&dvbdmx->mutex);\r\nif (dvbdmxfilter->feed != dvbdmxfeed) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -EINVAL;\r\n}\r\nif (feed->is_filtering) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nfeed->stop_filtering(feed);\r\nmutex_lock(&dvbdmx->mutex);\r\n}\r\nspin_lock_irq(&dvbdmx->lock);\r\nf = dvbdmxfeed->filter;\r\nif (f == dvbdmxfilter) {\r\ndvbdmxfeed->filter = dvbdmxfilter->next;\r\n} else {\r\nwhile (f->next != dvbdmxfilter)\r\nf = f->next;\r\nf->next = f->next->next;\r\n}\r\ndvbdmxfilter->state = DMX_STATE_FREE;\r\nspin_unlock_irq(&dvbdmx->lock);\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_allocate_section_feed(struct dmx_demux *demux,\r\nstruct dmx_section_feed **feed,\r\ndmx_section_cb callback)\r\n{\r\nstruct dvb_demux *dvbdmx = (struct dvb_demux *)demux;\r\nstruct dvb_demux_feed *dvbdmxfeed;\r\nif (mutex_lock_interruptible(&dvbdmx->mutex))\r\nreturn -ERESTARTSYS;\r\nif (!(dvbdmxfeed = dvb_dmx_feed_alloc(dvbdmx))) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -EBUSY;\r\n}\r\ndvbdmxfeed->type = DMX_TYPE_SEC;\r\ndvbdmxfeed->cb.sec = callback;\r\ndvbdmxfeed->demux = dvbdmx;\r\ndvbdmxfeed->pid = 0xffff;\r\ndvbdmxfeed->feed.sec.secbuf = dvbdmxfeed->feed.sec.secbuf_base;\r\ndvbdmxfeed->feed.sec.secbufp = dvbdmxfeed->feed.sec.seclen = 0;\r\ndvbdmxfeed->feed.sec.tsfeedp = 0;\r\ndvbdmxfeed->filter = NULL;\r\n(*feed) = &dvbdmxfeed->feed.sec;\r\n(*feed)->is_filtering = 0;\r\n(*feed)->parent = demux;\r\n(*feed)->priv = NULL;\r\n(*feed)->set = dmx_section_feed_set;\r\n(*feed)->allocate_filter = dmx_section_feed_allocate_filter;\r\n(*feed)->start_filtering = dmx_section_feed_start_filtering;\r\n(*feed)->stop_filtering = dmx_section_feed_stop_filtering;\r\n(*feed)->release_filter = dmx_section_feed_release_filter;\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_release_section_feed(struct dmx_demux *demux,\r\nstruct dmx_section_feed *feed)\r\n{\r\nstruct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;\r\nstruct dvb_demux *dvbdmx = (struct dvb_demux *)demux;\r\nmutex_lock(&dvbdmx->mutex);\r\nif (dvbdmxfeed->state == DMX_STATE_FREE) {\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn -EINVAL;\r\n}\r\ndvbdmxfeed->state = DMX_STATE_FREE;\r\ndvb_demux_feed_del(dvbdmxfeed);\r\ndvbdmxfeed->pid = 0xffff;\r\nmutex_unlock(&dvbdmx->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_open(struct dmx_demux *demux)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nif (dvbdemux->users >= MAX_DVB_DEMUX_USERS)\r\nreturn -EUSERS;\r\ndvbdemux->users++;\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_close(struct dmx_demux *demux)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nif (dvbdemux->users == 0)\r\nreturn -ENODEV;\r\ndvbdemux->users--;\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_write(struct dmx_demux *demux, const char __user *buf, size_t count)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nvoid *p;\r\nif ((!demux->frontend) || (demux->frontend->source != DMX_MEMORY_FE))\r\nreturn -EINVAL;\r\np = memdup_user(buf, count);\r\nif (IS_ERR(p))\r\nreturn PTR_ERR(p);\r\nif (mutex_lock_interruptible(&dvbdemux->mutex)) {\r\nkfree(p);\r\nreturn -ERESTARTSYS;\r\n}\r\ndvb_dmx_swfilter(dvbdemux, p, count);\r\nkfree(p);\r\nmutex_unlock(&dvbdemux->mutex);\r\nif (signal_pending(current))\r\nreturn -EINTR;\r\nreturn count;\r\n}\r\nstatic int dvbdmx_add_frontend(struct dmx_demux *demux,\r\nstruct dmx_frontend *frontend)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nstruct list_head *head = &dvbdemux->frontend_list;\r\nlist_add(&(frontend->connectivity_list), head);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_remove_frontend(struct dmx_demux *demux,\r\nstruct dmx_frontend *frontend)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nstruct list_head *pos, *n, *head = &dvbdemux->frontend_list;\r\nlist_for_each_safe(pos, n, head) {\r\nif (DMX_FE_ENTRY(pos) == frontend) {\r\nlist_del(pos);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic struct list_head *dvbdmx_get_frontends(struct dmx_demux *demux)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nif (list_empty(&dvbdemux->frontend_list))\r\nreturn NULL;\r\nreturn &dvbdemux->frontend_list;\r\n}\r\nstatic int dvbdmx_connect_frontend(struct dmx_demux *demux,\r\nstruct dmx_frontend *frontend)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nif (demux->frontend)\r\nreturn -EINVAL;\r\nmutex_lock(&dvbdemux->mutex);\r\ndemux->frontend = frontend;\r\nmutex_unlock(&dvbdemux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_disconnect_frontend(struct dmx_demux *demux)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nmutex_lock(&dvbdemux->mutex);\r\ndemux->frontend = NULL;\r\nmutex_unlock(&dvbdemux->mutex);\r\nreturn 0;\r\n}\r\nstatic int dvbdmx_get_pes_pids(struct dmx_demux *demux, u16 * pids)\r\n{\r\nstruct dvb_demux *dvbdemux = (struct dvb_demux *)demux;\r\nmemcpy(pids, dvbdemux->pids, 5 * sizeof(u16));\r\nreturn 0;\r\n}\r\nint dvb_dmx_init(struct dvb_demux *dvbdemux)\r\n{\r\nint i;\r\nstruct dmx_demux *dmx = &dvbdemux->dmx;\r\ndvbdemux->cnt_storage = NULL;\r\ndvbdemux->users = 0;\r\ndvbdemux->filter = vmalloc(dvbdemux->filternum * sizeof(struct dvb_demux_filter));\r\nif (!dvbdemux->filter)\r\nreturn -ENOMEM;\r\ndvbdemux->feed = vmalloc(dvbdemux->feednum * sizeof(struct dvb_demux_feed));\r\nif (!dvbdemux->feed) {\r\nvfree(dvbdemux->filter);\r\ndvbdemux->filter = NULL;\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < dvbdemux->filternum; i++) {\r\ndvbdemux->filter[i].state = DMX_STATE_FREE;\r\ndvbdemux->filter[i].index = i;\r\n}\r\nfor (i = 0; i < dvbdemux->feednum; i++) {\r\ndvbdemux->feed[i].state = DMX_STATE_FREE;\r\ndvbdemux->feed[i].index = i;\r\n}\r\ndvbdemux->cnt_storage = vmalloc(MAX_PID + 1);\r\nif (!dvbdemux->cnt_storage)\r\npr_warn("Couldn't allocate memory for TS/TEI check. Disabling it\n");\r\nINIT_LIST_HEAD(&dvbdemux->frontend_list);\r\nfor (i = 0; i < DMX_PES_OTHER; i++) {\r\ndvbdemux->pesfilter[i] = NULL;\r\ndvbdemux->pids[i] = 0xffff;\r\n}\r\nINIT_LIST_HEAD(&dvbdemux->feed_list);\r\ndvbdemux->playing = 0;\r\ndvbdemux->recording = 0;\r\ndvbdemux->tsbufp = 0;\r\nif (!dvbdemux->check_crc32)\r\ndvbdemux->check_crc32 = dvb_dmx_crc32;\r\nif (!dvbdemux->memcopy)\r\ndvbdemux->memcopy = dvb_dmx_memcopy;\r\ndmx->frontend = NULL;\r\ndmx->priv = dvbdemux;\r\ndmx->open = dvbdmx_open;\r\ndmx->close = dvbdmx_close;\r\ndmx->write = dvbdmx_write;\r\ndmx->allocate_ts_feed = dvbdmx_allocate_ts_feed;\r\ndmx->release_ts_feed = dvbdmx_release_ts_feed;\r\ndmx->allocate_section_feed = dvbdmx_allocate_section_feed;\r\ndmx->release_section_feed = dvbdmx_release_section_feed;\r\ndmx->add_frontend = dvbdmx_add_frontend;\r\ndmx->remove_frontend = dvbdmx_remove_frontend;\r\ndmx->get_frontends = dvbdmx_get_frontends;\r\ndmx->connect_frontend = dvbdmx_connect_frontend;\r\ndmx->disconnect_frontend = dvbdmx_disconnect_frontend;\r\ndmx->get_pes_pids = dvbdmx_get_pes_pids;\r\nmutex_init(&dvbdemux->mutex);\r\nspin_lock_init(&dvbdemux->lock);\r\nreturn 0;\r\n}\r\nvoid dvb_dmx_release(struct dvb_demux *dvbdemux)\r\n{\r\nvfree(dvbdemux->cnt_storage);\r\nvfree(dvbdemux->filter);\r\nvfree(dvbdemux->feed);\r\n}
