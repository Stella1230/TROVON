static int ptp_kvm_get_time_fn(ktime_t *device_time,\r\nstruct system_counterval_t *system_counter,\r\nvoid *ctx)\r\n{\r\nunsigned long ret;\r\nstruct timespec64 tspec;\r\nunsigned version;\r\nint cpu;\r\nstruct pvclock_vcpu_time_info *src;\r\nspin_lock(&kvm_ptp_lock);\r\npreempt_disable_notrace();\r\ncpu = smp_processor_id();\r\nsrc = &hv_clock[cpu].pvti;\r\ndo {\r\nversion = pvclock_read_begin(src);\r\nret = kvm_hypercall2(KVM_HC_CLOCK_PAIRING,\r\nclock_pair_gpa,\r\nKVM_CLOCK_PAIRING_WALLCLOCK);\r\nif (ret != 0) {\r\npr_err_ratelimited("clock pairing hypercall ret %lu\n", ret);\r\nspin_unlock(&kvm_ptp_lock);\r\npreempt_enable_notrace();\r\nreturn -EOPNOTSUPP;\r\n}\r\ntspec.tv_sec = clock_pair.sec;\r\ntspec.tv_nsec = clock_pair.nsec;\r\nret = __pvclock_read_cycles(src, clock_pair.tsc);\r\n} while (pvclock_read_retry(src, version));\r\npreempt_enable_notrace();\r\nsystem_counter->cycles = ret;\r\nsystem_counter->cs = &kvm_clock;\r\n*device_time = timespec64_to_ktime(tspec);\r\nspin_unlock(&kvm_ptp_lock);\r\nreturn 0;\r\n}\r\nstatic int ptp_kvm_getcrosststamp(struct ptp_clock_info *ptp,\r\nstruct system_device_crosststamp *xtstamp)\r\n{\r\nreturn get_device_system_crosststamp(ptp_kvm_get_time_fn, NULL,\r\nNULL, xtstamp);\r\n}\r\nstatic int ptp_kvm_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ptp_kvm_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ptp_kvm_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int ptp_kvm_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nunsigned long ret;\r\nstruct timespec64 tspec;\r\nspin_lock(&kvm_ptp_lock);\r\nret = kvm_hypercall2(KVM_HC_CLOCK_PAIRING,\r\nclock_pair_gpa,\r\nKVM_CLOCK_PAIRING_WALLCLOCK);\r\nif (ret != 0) {\r\npr_err_ratelimited("clock offset hypercall ret %lu\n", ret);\r\nspin_unlock(&kvm_ptp_lock);\r\nreturn -EOPNOTSUPP;\r\n}\r\ntspec.tv_sec = clock_pair.sec;\r\ntspec.tv_nsec = clock_pair.nsec;\r\nspin_unlock(&kvm_ptp_lock);\r\nmemcpy(ts, &tspec, sizeof(struct timespec64));\r\nreturn 0;\r\n}\r\nstatic int ptp_kvm_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void __exit ptp_kvm_exit(void)\r\n{\r\nptp_clock_unregister(kvm_ptp_clock.ptp_clock);\r\n}\r\nstatic int __init ptp_kvm_init(void)\r\n{\r\nlong ret;\r\nclock_pair_gpa = slow_virt_to_phys(&clock_pair);\r\nhv_clock = pvclock_pvti_cpu0_va();\r\nif (!hv_clock)\r\nreturn -ENODEV;\r\nret = kvm_hypercall2(KVM_HC_CLOCK_PAIRING, clock_pair_gpa,\r\nKVM_CLOCK_PAIRING_WALLCLOCK);\r\nif (ret == -KVM_ENOSYS || ret == -KVM_EOPNOTSUPP)\r\nreturn -ENODEV;\r\nkvm_ptp_clock.caps = ptp_kvm_caps;\r\nkvm_ptp_clock.ptp_clock = ptp_clock_register(&kvm_ptp_clock.caps, NULL);\r\nreturn PTR_ERR_OR_ZERO(kvm_ptp_clock.ptp_clock);\r\n}
