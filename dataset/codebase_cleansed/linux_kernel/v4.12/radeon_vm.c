static unsigned radeon_vm_num_pdes(struct radeon_device *rdev)\r\n{\r\nreturn rdev->vm_manager.max_pfn >> radeon_vm_block_size;\r\n}\r\nstatic unsigned radeon_vm_directory_size(struct radeon_device *rdev)\r\n{\r\nreturn RADEON_GPU_PAGE_ALIGN(radeon_vm_num_pdes(rdev) * 8);\r\n}\r\nint radeon_vm_manager_init(struct radeon_device *rdev)\r\n{\r\nint r;\r\nif (!rdev->vm_manager.enabled) {\r\nr = radeon_asic_vm_init(rdev);\r\nif (r)\r\nreturn r;\r\nrdev->vm_manager.enabled = true;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_vm_manager_fini(struct radeon_device *rdev)\r\n{\r\nint i;\r\nif (!rdev->vm_manager.enabled)\r\nreturn;\r\nfor (i = 0; i < RADEON_NUM_VM; ++i)\r\nradeon_fence_unref(&rdev->vm_manager.active[i]);\r\nradeon_asic_vm_fini(rdev);\r\nrdev->vm_manager.enabled = false;\r\n}\r\nstruct radeon_bo_list *radeon_vm_get_bos(struct radeon_device *rdev,\r\nstruct radeon_vm *vm,\r\nstruct list_head *head)\r\n{\r\nstruct radeon_bo_list *list;\r\nunsigned i, idx;\r\nlist = drm_malloc_ab(vm->max_pde_used + 2,\r\nsizeof(struct radeon_bo_list));\r\nif (!list)\r\nreturn NULL;\r\nlist[0].robj = vm->page_directory;\r\nlist[0].prefered_domains = RADEON_GEM_DOMAIN_VRAM;\r\nlist[0].allowed_domains = RADEON_GEM_DOMAIN_VRAM;\r\nlist[0].tv.bo = &vm->page_directory->tbo;\r\nlist[0].tv.shared = true;\r\nlist[0].tiling_flags = 0;\r\nlist_add(&list[0].tv.head, head);\r\nfor (i = 0, idx = 1; i <= vm->max_pde_used; i++) {\r\nif (!vm->page_tables[i].bo)\r\ncontinue;\r\nlist[idx].robj = vm->page_tables[i].bo;\r\nlist[idx].prefered_domains = RADEON_GEM_DOMAIN_VRAM;\r\nlist[idx].allowed_domains = RADEON_GEM_DOMAIN_VRAM;\r\nlist[idx].tv.bo = &list[idx].robj->tbo;\r\nlist[idx].tv.shared = true;\r\nlist[idx].tiling_flags = 0;\r\nlist_add(&list[idx++].tv.head, head);\r\n}\r\nreturn list;\r\n}\r\nstruct radeon_fence *radeon_vm_grab_id(struct radeon_device *rdev,\r\nstruct radeon_vm *vm, int ring)\r\n{\r\nstruct radeon_fence *best[RADEON_NUM_RINGS] = {};\r\nstruct radeon_vm_id *vm_id = &vm->ids[ring];\r\nunsigned choices[2] = {};\r\nunsigned i;\r\nif (vm_id->id && vm_id->last_id_use &&\r\nvm_id->last_id_use == rdev->vm_manager.active[vm_id->id])\r\nreturn NULL;\r\nvm_id->pd_gpu_addr = ~0ll;\r\nfor (i = 1; i < rdev->vm_manager.nvm; ++i) {\r\nstruct radeon_fence *fence = rdev->vm_manager.active[i];\r\nif (fence == NULL) {\r\nvm_id->id = i;\r\ntrace_radeon_vm_grab_id(i, ring);\r\nreturn NULL;\r\n}\r\nif (radeon_fence_is_earlier(fence, best[fence->ring])) {\r\nbest[fence->ring] = fence;\r\nchoices[fence->ring == ring ? 0 : 1] = i;\r\n}\r\n}\r\nfor (i = 0; i < 2; ++i) {\r\nif (choices[i]) {\r\nvm_id->id = choices[i];\r\ntrace_radeon_vm_grab_id(choices[i], ring);\r\nreturn rdev->vm_manager.active[choices[i]];\r\n}\r\n}\r\nBUG();\r\nreturn NULL;\r\n}\r\nvoid radeon_vm_flush(struct radeon_device *rdev,\r\nstruct radeon_vm *vm,\r\nint ring, struct radeon_fence *updates)\r\n{\r\nuint64_t pd_addr = radeon_bo_gpu_offset(vm->page_directory);\r\nstruct radeon_vm_id *vm_id = &vm->ids[ring];\r\nif (pd_addr != vm_id->pd_gpu_addr || !vm_id->flushed_updates ||\r\nradeon_fence_is_earlier(vm_id->flushed_updates, updates)) {\r\ntrace_radeon_vm_flush(pd_addr, ring, vm->ids[ring].id);\r\nradeon_fence_unref(&vm_id->flushed_updates);\r\nvm_id->flushed_updates = radeon_fence_ref(updates);\r\nvm_id->pd_gpu_addr = pd_addr;\r\nradeon_ring_vm_flush(rdev, &rdev->ring[ring],\r\nvm_id->id, vm_id->pd_gpu_addr);\r\n}\r\n}\r\nvoid radeon_vm_fence(struct radeon_device *rdev,\r\nstruct radeon_vm *vm,\r\nstruct radeon_fence *fence)\r\n{\r\nunsigned vm_id = vm->ids[fence->ring].id;\r\nradeon_fence_unref(&rdev->vm_manager.active[vm_id]);\r\nrdev->vm_manager.active[vm_id] = radeon_fence_ref(fence);\r\nradeon_fence_unref(&vm->ids[fence->ring].last_id_use);\r\nvm->ids[fence->ring].last_id_use = radeon_fence_ref(fence);\r\n}\r\nstruct radeon_bo_va *radeon_vm_bo_find(struct radeon_vm *vm,\r\nstruct radeon_bo *bo)\r\n{\r\nstruct radeon_bo_va *bo_va;\r\nlist_for_each_entry(bo_va, &bo->va, bo_list) {\r\nif (bo_va->vm == vm) {\r\nreturn bo_va;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstruct radeon_bo_va *radeon_vm_bo_add(struct radeon_device *rdev,\r\nstruct radeon_vm *vm,\r\nstruct radeon_bo *bo)\r\n{\r\nstruct radeon_bo_va *bo_va;\r\nbo_va = kzalloc(sizeof(struct radeon_bo_va), GFP_KERNEL);\r\nif (bo_va == NULL) {\r\nreturn NULL;\r\n}\r\nbo_va->vm = vm;\r\nbo_va->bo = bo;\r\nbo_va->it.start = 0;\r\nbo_va->it.last = 0;\r\nbo_va->flags = 0;\r\nbo_va->ref_count = 1;\r\nINIT_LIST_HEAD(&bo_va->bo_list);\r\nINIT_LIST_HEAD(&bo_va->vm_status);\r\nmutex_lock(&vm->mutex);\r\nlist_add_tail(&bo_va->bo_list, &bo->va);\r\nmutex_unlock(&vm->mutex);\r\nreturn bo_va;\r\n}\r\nstatic void radeon_vm_set_pages(struct radeon_device *rdev,\r\nstruct radeon_ib *ib,\r\nuint64_t pe,\r\nuint64_t addr, unsigned count,\r\nuint32_t incr, uint32_t flags)\r\n{\r\ntrace_radeon_vm_set_page(pe, addr, count, incr, flags);\r\nif ((flags & R600_PTE_GART_MASK) == R600_PTE_GART_MASK) {\r\nuint64_t src = rdev->gart.table_addr + (addr >> 12) * 8;\r\nradeon_asic_vm_copy_pages(rdev, ib, pe, src, count);\r\n} else if ((flags & R600_PTE_SYSTEM) || (count < 3)) {\r\nradeon_asic_vm_write_pages(rdev, ib, pe, addr,\r\ncount, incr, flags);\r\n} else {\r\nradeon_asic_vm_set_pages(rdev, ib, pe, addr,\r\ncount, incr, flags);\r\n}\r\n}\r\nstatic int radeon_vm_clear_bo(struct radeon_device *rdev,\r\nstruct radeon_bo *bo)\r\n{\r\nstruct radeon_ib ib;\r\nunsigned entries;\r\nuint64_t addr;\r\nint r;\r\nr = radeon_bo_reserve(bo, false);\r\nif (r)\r\nreturn r;\r\nr = ttm_bo_validate(&bo->tbo, &bo->placement, true, false);\r\nif (r)\r\ngoto error_unreserve;\r\naddr = radeon_bo_gpu_offset(bo);\r\nentries = radeon_bo_size(bo) / 8;\r\nr = radeon_ib_get(rdev, R600_RING_TYPE_DMA_INDEX, &ib, NULL, 256);\r\nif (r)\r\ngoto error_unreserve;\r\nib.length_dw = 0;\r\nradeon_vm_set_pages(rdev, &ib, addr, 0, entries, 0, 0);\r\nradeon_asic_vm_pad_ib(rdev, &ib);\r\nWARN_ON(ib.length_dw > 64);\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (r)\r\ngoto error_free;\r\nib.fence->is_vm_update = true;\r\nradeon_bo_fence(bo, ib.fence, false);\r\nerror_free:\r\nradeon_ib_free(rdev, &ib);\r\nerror_unreserve:\r\nradeon_bo_unreserve(bo);\r\nreturn r;\r\n}\r\nint radeon_vm_bo_set_addr(struct radeon_device *rdev,\r\nstruct radeon_bo_va *bo_va,\r\nuint64_t soffset,\r\nuint32_t flags)\r\n{\r\nuint64_t size = radeon_bo_size(bo_va->bo);\r\nstruct radeon_vm *vm = bo_va->vm;\r\nunsigned last_pfn, pt_idx;\r\nuint64_t eoffset;\r\nint r;\r\nif (soffset) {\r\neoffset = soffset + size - 1;\r\nif (soffset >= eoffset) {\r\nr = -EINVAL;\r\ngoto error_unreserve;\r\n}\r\nlast_pfn = eoffset / RADEON_GPU_PAGE_SIZE;\r\nif (last_pfn >= rdev->vm_manager.max_pfn) {\r\ndev_err(rdev->dev, "va above limit (0x%08X >= 0x%08X)\n",\r\nlast_pfn, rdev->vm_manager.max_pfn);\r\nr = -EINVAL;\r\ngoto error_unreserve;\r\n}\r\n} else {\r\neoffset = last_pfn = 0;\r\n}\r\nmutex_lock(&vm->mutex);\r\nsoffset /= RADEON_GPU_PAGE_SIZE;\r\neoffset /= RADEON_GPU_PAGE_SIZE;\r\nif (soffset || eoffset) {\r\nstruct interval_tree_node *it;\r\nit = interval_tree_iter_first(&vm->va, soffset, eoffset);\r\nif (it && it != &bo_va->it) {\r\nstruct radeon_bo_va *tmp;\r\ntmp = container_of(it, struct radeon_bo_va, it);\r\ndev_err(rdev->dev, "bo %p va 0x%010Lx conflict with "\r\n"(bo %p 0x%010lx 0x%010lx)\n", bo_va->bo,\r\nsoffset, tmp->bo, tmp->it.start, tmp->it.last);\r\nmutex_unlock(&vm->mutex);\r\nr = -EINVAL;\r\ngoto error_unreserve;\r\n}\r\n}\r\nif (bo_va->it.start || bo_va->it.last) {\r\nstruct radeon_bo_va *tmp;\r\ntmp = kzalloc(sizeof(struct radeon_bo_va), GFP_KERNEL);\r\nif (!tmp) {\r\nmutex_unlock(&vm->mutex);\r\nr = -ENOMEM;\r\ngoto error_unreserve;\r\n}\r\ntmp->it.start = bo_va->it.start;\r\ntmp->it.last = bo_va->it.last;\r\ntmp->vm = vm;\r\ntmp->bo = radeon_bo_ref(bo_va->bo);\r\ninterval_tree_remove(&bo_va->it, &vm->va);\r\nspin_lock(&vm->status_lock);\r\nbo_va->it.start = 0;\r\nbo_va->it.last = 0;\r\nlist_del_init(&bo_va->vm_status);\r\nlist_add(&tmp->vm_status, &vm->freed);\r\nspin_unlock(&vm->status_lock);\r\n}\r\nif (soffset || eoffset) {\r\nspin_lock(&vm->status_lock);\r\nbo_va->it.start = soffset;\r\nbo_va->it.last = eoffset;\r\nlist_add(&bo_va->vm_status, &vm->cleared);\r\nspin_unlock(&vm->status_lock);\r\ninterval_tree_insert(&bo_va->it, &vm->va);\r\n}\r\nbo_va->flags = flags;\r\nsoffset >>= radeon_vm_block_size;\r\neoffset >>= radeon_vm_block_size;\r\nBUG_ON(eoffset >= radeon_vm_num_pdes(rdev));\r\nif (eoffset > vm->max_pde_used)\r\nvm->max_pde_used = eoffset;\r\nradeon_bo_unreserve(bo_va->bo);\r\nfor (pt_idx = soffset; pt_idx <= eoffset; ++pt_idx) {\r\nstruct radeon_bo *pt;\r\nif (vm->page_tables[pt_idx].bo)\r\ncontinue;\r\nmutex_unlock(&vm->mutex);\r\nr = radeon_bo_create(rdev, RADEON_VM_PTE_COUNT * 8,\r\nRADEON_GPU_PAGE_SIZE, true,\r\nRADEON_GEM_DOMAIN_VRAM, 0,\r\nNULL, NULL, &pt);\r\nif (r)\r\nreturn r;\r\nr = radeon_vm_clear_bo(rdev, pt);\r\nif (r) {\r\nradeon_bo_unref(&pt);\r\nreturn r;\r\n}\r\nmutex_lock(&vm->mutex);\r\nif (vm->page_tables[pt_idx].bo) {\r\nmutex_unlock(&vm->mutex);\r\nradeon_bo_unref(&pt);\r\nmutex_lock(&vm->mutex);\r\ncontinue;\r\n}\r\nvm->page_tables[pt_idx].addr = 0;\r\nvm->page_tables[pt_idx].bo = pt;\r\n}\r\nmutex_unlock(&vm->mutex);\r\nreturn 0;\r\nerror_unreserve:\r\nradeon_bo_unreserve(bo_va->bo);\r\nreturn r;\r\n}\r\nuint64_t radeon_vm_map_gart(struct radeon_device *rdev, uint64_t addr)\r\n{\r\nuint64_t result;\r\nresult = rdev->gart.pages_entry[addr >> RADEON_GPU_PAGE_SHIFT];\r\nresult &= ~RADEON_GPU_PAGE_MASK;\r\nreturn result;\r\n}\r\nstatic uint32_t radeon_vm_page_flags(uint32_t flags)\r\n{\r\nuint32_t hw_flags = 0;\r\nhw_flags |= (flags & RADEON_VM_PAGE_VALID) ? R600_PTE_VALID : 0;\r\nhw_flags |= (flags & RADEON_VM_PAGE_READABLE) ? R600_PTE_READABLE : 0;\r\nhw_flags |= (flags & RADEON_VM_PAGE_WRITEABLE) ? R600_PTE_WRITEABLE : 0;\r\nif (flags & RADEON_VM_PAGE_SYSTEM) {\r\nhw_flags |= R600_PTE_SYSTEM;\r\nhw_flags |= (flags & RADEON_VM_PAGE_SNOOPED) ? R600_PTE_SNOOPED : 0;\r\n}\r\nreturn hw_flags;\r\n}\r\nint radeon_vm_update_page_directory(struct radeon_device *rdev,\r\nstruct radeon_vm *vm)\r\n{\r\nstruct radeon_bo *pd = vm->page_directory;\r\nuint64_t pd_addr = radeon_bo_gpu_offset(pd);\r\nuint32_t incr = RADEON_VM_PTE_COUNT * 8;\r\nuint64_t last_pde = ~0, last_pt = ~0;\r\nunsigned count = 0, pt_idx, ndw;\r\nstruct radeon_ib ib;\r\nint r;\r\nndw = 64;\r\nndw += vm->max_pde_used * 6;\r\nif (ndw > 0xfffff)\r\nreturn -ENOMEM;\r\nr = radeon_ib_get(rdev, R600_RING_TYPE_DMA_INDEX, &ib, NULL, ndw * 4);\r\nif (r)\r\nreturn r;\r\nib.length_dw = 0;\r\nfor (pt_idx = 0; pt_idx <= vm->max_pde_used; ++pt_idx) {\r\nstruct radeon_bo *bo = vm->page_tables[pt_idx].bo;\r\nuint64_t pde, pt;\r\nif (bo == NULL)\r\ncontinue;\r\npt = radeon_bo_gpu_offset(bo);\r\nif (vm->page_tables[pt_idx].addr == pt)\r\ncontinue;\r\nvm->page_tables[pt_idx].addr = pt;\r\npde = pd_addr + pt_idx * 8;\r\nif (((last_pde + 8 * count) != pde) ||\r\n((last_pt + incr * count) != pt)) {\r\nif (count) {\r\nradeon_vm_set_pages(rdev, &ib, last_pde,\r\nlast_pt, count, incr,\r\nR600_PTE_VALID);\r\n}\r\ncount = 1;\r\nlast_pde = pde;\r\nlast_pt = pt;\r\n} else {\r\n++count;\r\n}\r\n}\r\nif (count)\r\nradeon_vm_set_pages(rdev, &ib, last_pde, last_pt, count,\r\nincr, R600_PTE_VALID);\r\nif (ib.length_dw != 0) {\r\nradeon_asic_vm_pad_ib(rdev, &ib);\r\nradeon_sync_resv(rdev, &ib.sync, pd->tbo.resv, true);\r\nWARN_ON(ib.length_dw > ndw);\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (r) {\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nib.fence->is_vm_update = true;\r\nradeon_bo_fence(pd, ib.fence, false);\r\n}\r\nradeon_ib_free(rdev, &ib);\r\nreturn 0;\r\n}\r\nstatic void radeon_vm_frag_ptes(struct radeon_device *rdev,\r\nstruct radeon_ib *ib,\r\nuint64_t pe_start, uint64_t pe_end,\r\nuint64_t addr, uint32_t flags)\r\n{\r\nuint64_t frag_flags = ((rdev->family == CHIP_CAYMAN) ||\r\n(rdev->family == CHIP_ARUBA)) ?\r\nR600_PTE_FRAG_256KB : R600_PTE_FRAG_64KB;\r\nuint64_t frag_align = ((rdev->family == CHIP_CAYMAN) ||\r\n(rdev->family == CHIP_ARUBA)) ? 0x200 : 0x80;\r\nuint64_t frag_start = ALIGN(pe_start, frag_align);\r\nuint64_t frag_end = pe_end & ~(frag_align - 1);\r\nunsigned count;\r\nif ((flags & R600_PTE_SYSTEM) || !(flags & R600_PTE_VALID) ||\r\n(frag_start >= frag_end)) {\r\ncount = (pe_end - pe_start) / 8;\r\nradeon_vm_set_pages(rdev, ib, pe_start, addr, count,\r\nRADEON_GPU_PAGE_SIZE, flags);\r\nreturn;\r\n}\r\nif (pe_start != frag_start) {\r\ncount = (frag_start - pe_start) / 8;\r\nradeon_vm_set_pages(rdev, ib, pe_start, addr, count,\r\nRADEON_GPU_PAGE_SIZE, flags);\r\naddr += RADEON_GPU_PAGE_SIZE * count;\r\n}\r\ncount = (frag_end - frag_start) / 8;\r\nradeon_vm_set_pages(rdev, ib, frag_start, addr, count,\r\nRADEON_GPU_PAGE_SIZE, flags | frag_flags);\r\nif (frag_end != pe_end) {\r\naddr += RADEON_GPU_PAGE_SIZE * count;\r\ncount = (pe_end - frag_end) / 8;\r\nradeon_vm_set_pages(rdev, ib, frag_end, addr, count,\r\nRADEON_GPU_PAGE_SIZE, flags);\r\n}\r\n}\r\nstatic int radeon_vm_update_ptes(struct radeon_device *rdev,\r\nstruct radeon_vm *vm,\r\nstruct radeon_ib *ib,\r\nuint64_t start, uint64_t end,\r\nuint64_t dst, uint32_t flags)\r\n{\r\nuint64_t mask = RADEON_VM_PTE_COUNT - 1;\r\nuint64_t last_pte = ~0, last_dst = ~0;\r\nunsigned count = 0;\r\nuint64_t addr;\r\nfor (addr = start; addr < end; ) {\r\nuint64_t pt_idx = addr >> radeon_vm_block_size;\r\nstruct radeon_bo *pt = vm->page_tables[pt_idx].bo;\r\nunsigned nptes;\r\nuint64_t pte;\r\nint r;\r\nradeon_sync_resv(rdev, &ib->sync, pt->tbo.resv, true);\r\nr = reservation_object_reserve_shared(pt->tbo.resv);\r\nif (r)\r\nreturn r;\r\nif ((addr & ~mask) == (end & ~mask))\r\nnptes = end - addr;\r\nelse\r\nnptes = RADEON_VM_PTE_COUNT - (addr & mask);\r\npte = radeon_bo_gpu_offset(pt);\r\npte += (addr & mask) * 8;\r\nif ((last_pte + 8 * count) != pte) {\r\nif (count) {\r\nradeon_vm_frag_ptes(rdev, ib, last_pte,\r\nlast_pte + 8 * count,\r\nlast_dst, flags);\r\n}\r\ncount = nptes;\r\nlast_pte = pte;\r\nlast_dst = dst;\r\n} else {\r\ncount += nptes;\r\n}\r\naddr += nptes;\r\ndst += nptes * RADEON_GPU_PAGE_SIZE;\r\n}\r\nif (count) {\r\nradeon_vm_frag_ptes(rdev, ib, last_pte,\r\nlast_pte + 8 * count,\r\nlast_dst, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic void radeon_vm_fence_pts(struct radeon_vm *vm,\r\nuint64_t start, uint64_t end,\r\nstruct radeon_fence *fence)\r\n{\r\nunsigned i;\r\nstart >>= radeon_vm_block_size;\r\nend = (end - 1) >> radeon_vm_block_size;\r\nfor (i = start; i <= end; ++i)\r\nradeon_bo_fence(vm->page_tables[i].bo, fence, true);\r\n}\r\nint radeon_vm_bo_update(struct radeon_device *rdev,\r\nstruct radeon_bo_va *bo_va,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct radeon_vm *vm = bo_va->vm;\r\nstruct radeon_ib ib;\r\nunsigned nptes, ncmds, ndw;\r\nuint64_t addr;\r\nuint32_t flags;\r\nint r;\r\nif (!bo_va->it.start) {\r\ndev_err(rdev->dev, "bo %p don't has a mapping in vm %p\n",\r\nbo_va->bo, vm);\r\nreturn -EINVAL;\r\n}\r\nspin_lock(&vm->status_lock);\r\nif (mem) {\r\nif (list_empty(&bo_va->vm_status)) {\r\nspin_unlock(&vm->status_lock);\r\nreturn 0;\r\n}\r\nlist_del_init(&bo_va->vm_status);\r\n} else {\r\nlist_del(&bo_va->vm_status);\r\nlist_add(&bo_va->vm_status, &vm->cleared);\r\n}\r\nspin_unlock(&vm->status_lock);\r\nbo_va->flags &= ~RADEON_VM_PAGE_VALID;\r\nbo_va->flags &= ~RADEON_VM_PAGE_SYSTEM;\r\nbo_va->flags &= ~RADEON_VM_PAGE_SNOOPED;\r\nif (bo_va->bo && radeon_ttm_tt_is_readonly(bo_va->bo->tbo.ttm))\r\nbo_va->flags &= ~RADEON_VM_PAGE_WRITEABLE;\r\nif (mem) {\r\naddr = mem->start << PAGE_SHIFT;\r\nif (mem->mem_type != TTM_PL_SYSTEM) {\r\nbo_va->flags |= RADEON_VM_PAGE_VALID;\r\n}\r\nif (mem->mem_type == TTM_PL_TT) {\r\nbo_va->flags |= RADEON_VM_PAGE_SYSTEM;\r\nif (!(bo_va->bo->flags & (RADEON_GEM_GTT_WC | RADEON_GEM_GTT_UC)))\r\nbo_va->flags |= RADEON_VM_PAGE_SNOOPED;\r\n} else {\r\naddr += rdev->vm_manager.vram_base_offset;\r\n}\r\n} else {\r\naddr = 0;\r\n}\r\ntrace_radeon_vm_bo_update(bo_va);\r\nnptes = bo_va->it.last - bo_va->it.start + 1;\r\nncmds = (nptes >> min(radeon_vm_block_size, 11)) + 1;\r\nndw = 64;\r\nflags = radeon_vm_page_flags(bo_va->flags);\r\nif ((flags & R600_PTE_GART_MASK) == R600_PTE_GART_MASK) {\r\nndw += ncmds * 7;\r\n} else if (flags & R600_PTE_SYSTEM) {\r\nndw += ncmds * 4;\r\nndw += nptes * 2;\r\n} else {\r\nndw += ncmds * 10;\r\nndw += 2 * 10;\r\n}\r\nif (ndw > 0xfffff)\r\nreturn -ENOMEM;\r\nr = radeon_ib_get(rdev, R600_RING_TYPE_DMA_INDEX, &ib, NULL, ndw * 4);\r\nif (r)\r\nreturn r;\r\nib.length_dw = 0;\r\nif (!(bo_va->flags & RADEON_VM_PAGE_VALID)) {\r\nunsigned i;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i)\r\nradeon_sync_fence(&ib.sync, vm->ids[i].last_id_use);\r\n}\r\nr = radeon_vm_update_ptes(rdev, vm, &ib, bo_va->it.start,\r\nbo_va->it.last + 1, addr,\r\nradeon_vm_page_flags(bo_va->flags));\r\nif (r) {\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nradeon_asic_vm_pad_ib(rdev, &ib);\r\nWARN_ON(ib.length_dw > ndw);\r\nr = radeon_ib_schedule(rdev, &ib, NULL, false);\r\nif (r) {\r\nradeon_ib_free(rdev, &ib);\r\nreturn r;\r\n}\r\nib.fence->is_vm_update = true;\r\nradeon_vm_fence_pts(vm, bo_va->it.start, bo_va->it.last + 1, ib.fence);\r\nradeon_fence_unref(&bo_va->last_pt_update);\r\nbo_va->last_pt_update = radeon_fence_ref(ib.fence);\r\nradeon_ib_free(rdev, &ib);\r\nreturn 0;\r\n}\r\nint radeon_vm_clear_freed(struct radeon_device *rdev,\r\nstruct radeon_vm *vm)\r\n{\r\nstruct radeon_bo_va *bo_va;\r\nint r = 0;\r\nspin_lock(&vm->status_lock);\r\nwhile (!list_empty(&vm->freed)) {\r\nbo_va = list_first_entry(&vm->freed,\r\nstruct radeon_bo_va, vm_status);\r\nspin_unlock(&vm->status_lock);\r\nr = radeon_vm_bo_update(rdev, bo_va, NULL);\r\nradeon_bo_unref(&bo_va->bo);\r\nradeon_fence_unref(&bo_va->last_pt_update);\r\nspin_lock(&vm->status_lock);\r\nlist_del(&bo_va->vm_status);\r\nkfree(bo_va);\r\nif (r)\r\nbreak;\r\n}\r\nspin_unlock(&vm->status_lock);\r\nreturn r;\r\n}\r\nint radeon_vm_clear_invalids(struct radeon_device *rdev,\r\nstruct radeon_vm *vm)\r\n{\r\nstruct radeon_bo_va *bo_va;\r\nint r;\r\nspin_lock(&vm->status_lock);\r\nwhile (!list_empty(&vm->invalidated)) {\r\nbo_va = list_first_entry(&vm->invalidated,\r\nstruct radeon_bo_va, vm_status);\r\nspin_unlock(&vm->status_lock);\r\nr = radeon_vm_bo_update(rdev, bo_va, NULL);\r\nif (r)\r\nreturn r;\r\nspin_lock(&vm->status_lock);\r\n}\r\nspin_unlock(&vm->status_lock);\r\nreturn 0;\r\n}\r\nvoid radeon_vm_bo_rmv(struct radeon_device *rdev,\r\nstruct radeon_bo_va *bo_va)\r\n{\r\nstruct radeon_vm *vm = bo_va->vm;\r\nlist_del(&bo_va->bo_list);\r\nmutex_lock(&vm->mutex);\r\nif (bo_va->it.start || bo_va->it.last)\r\ninterval_tree_remove(&bo_va->it, &vm->va);\r\nspin_lock(&vm->status_lock);\r\nlist_del(&bo_va->vm_status);\r\nif (bo_va->it.start || bo_va->it.last) {\r\nbo_va->bo = radeon_bo_ref(bo_va->bo);\r\nlist_add(&bo_va->vm_status, &vm->freed);\r\n} else {\r\nradeon_fence_unref(&bo_va->last_pt_update);\r\nkfree(bo_va);\r\n}\r\nspin_unlock(&vm->status_lock);\r\nmutex_unlock(&vm->mutex);\r\n}\r\nvoid radeon_vm_bo_invalidate(struct radeon_device *rdev,\r\nstruct radeon_bo *bo)\r\n{\r\nstruct radeon_bo_va *bo_va;\r\nlist_for_each_entry(bo_va, &bo->va, bo_list) {\r\nspin_lock(&bo_va->vm->status_lock);\r\nif (list_empty(&bo_va->vm_status) &&\r\n(bo_va->it.start || bo_va->it.last))\r\nlist_add(&bo_va->vm_status, &bo_va->vm->invalidated);\r\nspin_unlock(&bo_va->vm->status_lock);\r\n}\r\n}\r\nint radeon_vm_init(struct radeon_device *rdev, struct radeon_vm *vm)\r\n{\r\nconst unsigned align = min(RADEON_VM_PTB_ALIGN_SIZE,\r\nRADEON_VM_PTE_COUNT * 8);\r\nunsigned pd_size, pd_entries, pts_size;\r\nint i, r;\r\nvm->ib_bo_va = NULL;\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nvm->ids[i].id = 0;\r\nvm->ids[i].flushed_updates = NULL;\r\nvm->ids[i].last_id_use = NULL;\r\n}\r\nmutex_init(&vm->mutex);\r\nvm->va = RB_ROOT;\r\nspin_lock_init(&vm->status_lock);\r\nINIT_LIST_HEAD(&vm->invalidated);\r\nINIT_LIST_HEAD(&vm->freed);\r\nINIT_LIST_HEAD(&vm->cleared);\r\npd_size = radeon_vm_directory_size(rdev);\r\npd_entries = radeon_vm_num_pdes(rdev);\r\npts_size = pd_entries * sizeof(struct radeon_vm_pt);\r\nvm->page_tables = kzalloc(pts_size, GFP_KERNEL);\r\nif (vm->page_tables == NULL) {\r\nDRM_ERROR("Cannot allocate memory for page table array\n");\r\nreturn -ENOMEM;\r\n}\r\nr = radeon_bo_create(rdev, pd_size, align, true,\r\nRADEON_GEM_DOMAIN_VRAM, 0, NULL,\r\nNULL, &vm->page_directory);\r\nif (r)\r\nreturn r;\r\nr = radeon_vm_clear_bo(rdev, vm->page_directory);\r\nif (r) {\r\nradeon_bo_unref(&vm->page_directory);\r\nvm->page_directory = NULL;\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nvoid radeon_vm_fini(struct radeon_device *rdev, struct radeon_vm *vm)\r\n{\r\nstruct radeon_bo_va *bo_va, *tmp;\r\nint i, r;\r\nif (!RB_EMPTY_ROOT(&vm->va)) {\r\ndev_err(rdev->dev, "still active bo inside vm\n");\r\n}\r\nrbtree_postorder_for_each_entry_safe(bo_va, tmp, &vm->va, it.rb) {\r\ninterval_tree_remove(&bo_va->it, &vm->va);\r\nr = radeon_bo_reserve(bo_va->bo, false);\r\nif (!r) {\r\nlist_del_init(&bo_va->bo_list);\r\nradeon_bo_unreserve(bo_va->bo);\r\nradeon_fence_unref(&bo_va->last_pt_update);\r\nkfree(bo_va);\r\n}\r\n}\r\nlist_for_each_entry_safe(bo_va, tmp, &vm->freed, vm_status) {\r\nradeon_bo_unref(&bo_va->bo);\r\nradeon_fence_unref(&bo_va->last_pt_update);\r\nkfree(bo_va);\r\n}\r\nfor (i = 0; i < radeon_vm_num_pdes(rdev); i++)\r\nradeon_bo_unref(&vm->page_tables[i].bo);\r\nkfree(vm->page_tables);\r\nradeon_bo_unref(&vm->page_directory);\r\nfor (i = 0; i < RADEON_NUM_RINGS; ++i) {\r\nradeon_fence_unref(&vm->ids[i].flushed_updates);\r\nradeon_fence_unref(&vm->ids[i].last_id_use);\r\n}\r\nmutex_destroy(&vm->mutex);\r\n}
