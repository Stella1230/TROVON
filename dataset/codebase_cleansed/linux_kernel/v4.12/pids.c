static struct pids_cgroup *css_pids(struct cgroup_subsys_state *css)\r\n{\r\nreturn container_of(css, struct pids_cgroup, css);\r\n}\r\nstatic struct pids_cgroup *parent_pids(struct pids_cgroup *pids)\r\n{\r\nreturn css_pids(pids->css.parent);\r\n}\r\nstatic struct cgroup_subsys_state *\r\npids_css_alloc(struct cgroup_subsys_state *parent)\r\n{\r\nstruct pids_cgroup *pids;\r\npids = kzalloc(sizeof(struct pids_cgroup), GFP_KERNEL);\r\nif (!pids)\r\nreturn ERR_PTR(-ENOMEM);\r\npids->limit = PIDS_MAX;\r\natomic64_set(&pids->counter, 0);\r\natomic64_set(&pids->events_limit, 0);\r\nreturn &pids->css;\r\n}\r\nstatic void pids_css_free(struct cgroup_subsys_state *css)\r\n{\r\nkfree(css_pids(css));\r\n}\r\nstatic void pids_cancel(struct pids_cgroup *pids, int num)\r\n{\r\nWARN_ON_ONCE(atomic64_add_negative(-num, &pids->counter));\r\n}\r\nstatic void pids_uncharge(struct pids_cgroup *pids, int num)\r\n{\r\nstruct pids_cgroup *p;\r\nfor (p = pids; parent_pids(p); p = parent_pids(p))\r\npids_cancel(p, num);\r\n}\r\nstatic void pids_charge(struct pids_cgroup *pids, int num)\r\n{\r\nstruct pids_cgroup *p;\r\nfor (p = pids; parent_pids(p); p = parent_pids(p))\r\natomic64_add(num, &p->counter);\r\n}\r\nstatic int pids_try_charge(struct pids_cgroup *pids, int num)\r\n{\r\nstruct pids_cgroup *p, *q;\r\nfor (p = pids; parent_pids(p); p = parent_pids(p)) {\r\nint64_t new = atomic64_add_return(num, &p->counter);\r\nif (new > p->limit)\r\ngoto revert;\r\n}\r\nreturn 0;\r\nrevert:\r\nfor (q = pids; q != p; q = parent_pids(q))\r\npids_cancel(q, num);\r\npids_cancel(p, num);\r\nreturn -EAGAIN;\r\n}\r\nstatic int pids_can_attach(struct cgroup_taskset *tset)\r\n{\r\nstruct task_struct *task;\r\nstruct cgroup_subsys_state *dst_css;\r\ncgroup_taskset_for_each(task, dst_css, tset) {\r\nstruct pids_cgroup *pids = css_pids(dst_css);\r\nstruct cgroup_subsys_state *old_css;\r\nstruct pids_cgroup *old_pids;\r\nold_css = task_css(task, pids_cgrp_id);\r\nold_pids = css_pids(old_css);\r\npids_charge(pids, 1);\r\npids_uncharge(old_pids, 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pids_cancel_attach(struct cgroup_taskset *tset)\r\n{\r\nstruct task_struct *task;\r\nstruct cgroup_subsys_state *dst_css;\r\ncgroup_taskset_for_each(task, dst_css, tset) {\r\nstruct pids_cgroup *pids = css_pids(dst_css);\r\nstruct cgroup_subsys_state *old_css;\r\nstruct pids_cgroup *old_pids;\r\nold_css = task_css(task, pids_cgrp_id);\r\nold_pids = css_pids(old_css);\r\npids_charge(old_pids, 1);\r\npids_uncharge(pids, 1);\r\n}\r\n}\r\nstatic int pids_can_fork(struct task_struct *task)\r\n{\r\nstruct cgroup_subsys_state *css;\r\nstruct pids_cgroup *pids;\r\nint err;\r\ncss = task_css_check(current, pids_cgrp_id, true);\r\npids = css_pids(css);\r\nerr = pids_try_charge(pids, 1);\r\nif (err) {\r\nif (atomic64_inc_return(&pids->events_limit) == 1) {\r\npr_info("cgroup: fork rejected by pids controller in ");\r\npr_cont_cgroup_path(css->cgroup);\r\npr_cont("\n");\r\n}\r\ncgroup_file_notify(&pids->events_file);\r\n}\r\nreturn err;\r\n}\r\nstatic void pids_cancel_fork(struct task_struct *task)\r\n{\r\nstruct cgroup_subsys_state *css;\r\nstruct pids_cgroup *pids;\r\ncss = task_css_check(current, pids_cgrp_id, true);\r\npids = css_pids(css);\r\npids_uncharge(pids, 1);\r\n}\r\nstatic void pids_free(struct task_struct *task)\r\n{\r\nstruct pids_cgroup *pids = css_pids(task_css(task, pids_cgrp_id));\r\npids_uncharge(pids, 1);\r\n}\r\nstatic ssize_t pids_max_write(struct kernfs_open_file *of, char *buf,\r\nsize_t nbytes, loff_t off)\r\n{\r\nstruct cgroup_subsys_state *css = of_css(of);\r\nstruct pids_cgroup *pids = css_pids(css);\r\nint64_t limit;\r\nint err;\r\nbuf = strstrip(buf);\r\nif (!strcmp(buf, PIDS_MAX_STR)) {\r\nlimit = PIDS_MAX;\r\ngoto set_limit;\r\n}\r\nerr = kstrtoll(buf, 0, &limit);\r\nif (err)\r\nreturn err;\r\nif (limit < 0 || limit >= PIDS_MAX)\r\nreturn -EINVAL;\r\nset_limit:\r\npids->limit = limit;\r\nreturn nbytes;\r\n}\r\nstatic int pids_max_show(struct seq_file *sf, void *v)\r\n{\r\nstruct cgroup_subsys_state *css = seq_css(sf);\r\nstruct pids_cgroup *pids = css_pids(css);\r\nint64_t limit = pids->limit;\r\nif (limit >= PIDS_MAX)\r\nseq_printf(sf, "%s\n", PIDS_MAX_STR);\r\nelse\r\nseq_printf(sf, "%lld\n", limit);\r\nreturn 0;\r\n}\r\nstatic s64 pids_current_read(struct cgroup_subsys_state *css,\r\nstruct cftype *cft)\r\n{\r\nstruct pids_cgroup *pids = css_pids(css);\r\nreturn atomic64_read(&pids->counter);\r\n}\r\nstatic int pids_events_show(struct seq_file *sf, void *v)\r\n{\r\nstruct pids_cgroup *pids = css_pids(seq_css(sf));\r\nseq_printf(sf, "max %lld\n", (s64)atomic64_read(&pids->events_limit));\r\nreturn 0;\r\n}
