int nf_log_dump_udp_header(struct nf_log_buf *m, const struct sk_buff *skb,\r\nu8 proto, int fragment, unsigned int offset)\r\n{\r\nstruct udphdr _udph;\r\nconst struct udphdr *uh;\r\nif (proto == IPPROTO_UDP)\r\nnf_log_buf_add(m, "PROTO=UDP ");\r\nelse\r\nnf_log_buf_add(m, "PROTO=UDPLITE ");\r\nif (fragment)\r\ngoto out;\r\nuh = skb_header_pointer(skb, offset, sizeof(_udph), &_udph);\r\nif (uh == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ", skb->len - offset);\r\nreturn 1;\r\n}\r\nnf_log_buf_add(m, "SPT=%u DPT=%u LEN=%u ",\r\nntohs(uh->source), ntohs(uh->dest), ntohs(uh->len));\r\nout:\r\nreturn 0;\r\n}\r\nint nf_log_dump_tcp_header(struct nf_log_buf *m, const struct sk_buff *skb,\r\nu8 proto, int fragment, unsigned int offset,\r\nunsigned int logflags)\r\n{\r\nstruct tcphdr _tcph;\r\nconst struct tcphdr *th;\r\nnf_log_buf_add(m, "PROTO=TCP ");\r\nif (fragment)\r\nreturn 0;\r\nth = skb_header_pointer(skb, offset, sizeof(_tcph), &_tcph);\r\nif (th == NULL) {\r\nnf_log_buf_add(m, "INCOMPLETE [%u bytes] ", skb->len - offset);\r\nreturn 1;\r\n}\r\nnf_log_buf_add(m, "SPT=%u DPT=%u ",\r\nntohs(th->source), ntohs(th->dest));\r\nif (logflags & NF_LOG_TCPSEQ) {\r\nnf_log_buf_add(m, "SEQ=%u ACK=%u ",\r\nntohl(th->seq), ntohl(th->ack_seq));\r\n}\r\nnf_log_buf_add(m, "WINDOW=%u ", ntohs(th->window));\r\nnf_log_buf_add(m, "RES=0x%02x ", (u_int8_t)(ntohl(tcp_flag_word(th) &\r\nTCP_RESERVED_BITS) >> 22));\r\nif (th->cwr)\r\nnf_log_buf_add(m, "CWR ");\r\nif (th->ece)\r\nnf_log_buf_add(m, "ECE ");\r\nif (th->urg)\r\nnf_log_buf_add(m, "URG ");\r\nif (th->ack)\r\nnf_log_buf_add(m, "ACK ");\r\nif (th->psh)\r\nnf_log_buf_add(m, "PSH ");\r\nif (th->rst)\r\nnf_log_buf_add(m, "RST ");\r\nif (th->syn)\r\nnf_log_buf_add(m, "SYN ");\r\nif (th->fin)\r\nnf_log_buf_add(m, "FIN ");\r\nnf_log_buf_add(m, "URGP=%u ", ntohs(th->urg_ptr));\r\nif ((logflags & NF_LOG_TCPOPT) && th->doff*4 > sizeof(struct tcphdr)) {\r\nu_int8_t _opt[60 - sizeof(struct tcphdr)];\r\nconst u_int8_t *op;\r\nunsigned int i;\r\nunsigned int optsize = th->doff*4 - sizeof(struct tcphdr);\r\nop = skb_header_pointer(skb, offset + sizeof(struct tcphdr),\r\noptsize, _opt);\r\nif (op == NULL) {\r\nnf_log_buf_add(m, "OPT (TRUNCATED)");\r\nreturn 1;\r\n}\r\nnf_log_buf_add(m, "OPT (");\r\nfor (i = 0; i < optsize; i++)\r\nnf_log_buf_add(m, "%02X", op[i]);\r\nnf_log_buf_add(m, ") ");\r\n}\r\nreturn 0;\r\n}\r\nvoid nf_log_dump_sk_uid_gid(struct nf_log_buf *m, struct sock *sk)\r\n{\r\nif (!sk || !sk_fullsock(sk))\r\nreturn;\r\nread_lock_bh(&sk->sk_callback_lock);\r\nif (sk->sk_socket && sk->sk_socket->file) {\r\nconst struct cred *cred = sk->sk_socket->file->f_cred;\r\nnf_log_buf_add(m, "UID=%u GID=%u ",\r\nfrom_kuid_munged(&init_user_ns, cred->fsuid),\r\nfrom_kgid_munged(&init_user_ns, cred->fsgid));\r\n}\r\nread_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nvoid\r\nnf_log_dump_packet_common(struct nf_log_buf *m, u_int8_t pf,\r\nunsigned int hooknum, const struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo, const char *prefix)\r\n{\r\nnf_log_buf_add(m, KERN_SOH "%c%sIN=%s OUT=%s ",\r\n'0' + loginfo->u.log.level, prefix,\r\nin ? in->name : "",\r\nout ? out->name : "");\r\n#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)\r\nif (skb->nf_bridge) {\r\nconst struct net_device *physindev;\r\nconst struct net_device *physoutdev;\r\nphysindev = nf_bridge_get_physindev(skb);\r\nif (physindev && in != physindev)\r\nnf_log_buf_add(m, "PHYSIN=%s ", physindev->name);\r\nphysoutdev = nf_bridge_get_physoutdev(skb);\r\nif (physoutdev && out != physoutdev)\r\nnf_log_buf_add(m, "PHYSOUT=%s ", physoutdev->name);\r\n}\r\n#endif\r\n}\r\nvoid nf_log_l2packet(struct net *net, u_int8_t pf,\r\n__be16 protocol,\r\nunsigned int hooknum,\r\nconst struct sk_buff *skb,\r\nconst struct net_device *in,\r\nconst struct net_device *out,\r\nconst struct nf_loginfo *loginfo,\r\nconst char *prefix)\r\n{\r\nswitch (protocol) {\r\ncase htons(ETH_P_IP):\r\nnf_log_packet(net, NFPROTO_IPV4, hooknum, skb, in, out,\r\nloginfo, "%s", prefix);\r\nbreak;\r\ncase htons(ETH_P_IPV6):\r\nnf_log_packet(net, NFPROTO_IPV6, hooknum, skb, in, out,\r\nloginfo, "%s", prefix);\r\nbreak;\r\ncase htons(ETH_P_ARP):\r\ncase htons(ETH_P_RARP):\r\nnf_log_packet(net, NFPROTO_ARP, hooknum, skb, in, out,\r\nloginfo, "%s", prefix);\r\nbreak;\r\n}\r\n}\r\nstatic int __init nf_log_common_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit nf_log_common_exit(void) {}
