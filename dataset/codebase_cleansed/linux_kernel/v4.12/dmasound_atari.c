static ssize_t ata_ct_law(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nchar *table = dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8\r\n: dmasound_alaw2dma8;\r\nssize_t count, used;\r\nu_char *p = &frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft);\r\nif (dmasound.soft.stereo)\r\ncount &= ~1;\r\nused = count;\r\nwhile (count > 0) {\r\nu_char data;\r\nif (get_user(data, userPtr++))\r\nreturn -EFAULT;\r\n*p++ = table[data];\r\ncount--;\r\n}\r\n*frameUsed += used;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ct_s8(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\nvoid *p = &frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft);\r\nif (dmasound.soft.stereo)\r\ncount &= ~1;\r\nused = count;\r\nif (copy_from_user(p, userPtr, count))\r\nreturn -EFAULT;\r\n*frameUsed += used;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ct_u8(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\nif (!dmasound.soft.stereo) {\r\nu_char *p = &frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft);\r\nused = count;\r\nwhile (count > 0) {\r\nu_char data;\r\nif (get_user(data, userPtr++))\r\nreturn -EFAULT;\r\n*p++ = data ^ 0x80;\r\ncount--;\r\n}\r\n} else {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>1;\r\nused = count*2;\r\nwhile (count > 0) {\r\nu_short data;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\n*p++ = data ^ 0x8080;\r\ncount--;\r\n}\r\n}\r\n*frameUsed += used;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ct_s16be(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>1;\r\nused = count*2;\r\nwhile (count > 0) {\r\nu_short data;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\n*p++ = data;\r\n*p++ = data;\r\ncount--;\r\n}\r\n*frameUsed += used*2;\r\n} else {\r\nvoid *p = (u_short *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft) & ~3;\r\nused = count;\r\nif (copy_from_user(p, userPtr, count))\r\nreturn -EFAULT;\r\n*frameUsed += used;\r\n}\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ct_u16be(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>1;\r\nused = count*2;\r\nwhile (count > 0) {\r\nu_short data;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata ^= 0x8000;\r\n*p++ = data;\r\n*p++ = data;\r\ncount--;\r\n}\r\n*frameUsed += used*2;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>2;\r\nused = count*4;\r\nwhile (count > 0) {\r\nu_int data;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\n*p++ = data ^ 0x80008000;\r\ncount--;\r\n}\r\n*frameUsed += used;\r\n}\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ct_s16le(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\ncount = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>1;\r\nused = count*2;\r\nwhile (count > 0) {\r\nu_short data;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata = le2be16(data);\r\n*p++ = data;\r\n*p++ = data;\r\ncount--;\r\n}\r\n*frameUsed += used*2;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>2;\r\nused = count*4;\r\nwhile (count > 0) {\r\nu_long data;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\ndata = le2be16dbl(data);\r\n*p++ = data;\r\ncount--;\r\n}\r\n*frameUsed += used;\r\n}\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ct_u16le(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nssize_t count, used;\r\ncount = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>1;\r\nused = count*2;\r\nwhile (count > 0) {\r\nu_short data;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata = le2be16(data) ^ 0x8000;\r\n*p++ = data;\r\n*p++ = data;\r\n}\r\n*frameUsed += used*2;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\ncount = min_t(unsigned long, userCount, frameLeft)>>2;\r\nused = count;\r\nwhile (count > 0) {\r\nu_long data;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\ndata = le2be16dbl(data) ^ 0x80008000;\r\n*p++ = data;\r\ncount--;\r\n}\r\n*frameUsed += used;\r\n}\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_law(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nchar *table = dmasound.soft.format == AFMT_MU_LAW ? dmasound_ulaw2dma8\r\n: dmasound_alaw2dma8;\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_char *p = &frame[*frameUsed];\r\nu_char data = expand_data;\r\nwhile (frameLeft) {\r\nu_char c;\r\nif (bal < 0) {\r\nif (!userCount)\r\nbreak;\r\nif (get_user(c, userPtr++))\r\nreturn -EFAULT;\r\ndata = table[c];\r\nuserCount--;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft--;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 2) {\r\nu_char c;\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(c, userPtr++))\r\nreturn -EFAULT;\r\ndata = table[c] << 8;\r\nif (get_user(c, userPtr++))\r\nreturn -EFAULT;\r\ndata |= table[c];\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 2;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_s8(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_char *p = &frame[*frameUsed];\r\nu_char data = expand_data;\r\nwhile (frameLeft) {\r\nif (bal < 0) {\r\nif (!userCount)\r\nbreak;\r\nif (get_user(data, userPtr++))\r\nreturn -EFAULT;\r\nuserCount--;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft--;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 2) {\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 2;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_u8(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_char *p = &frame[*frameUsed];\r\nu_char data = expand_data;\r\nwhile (frameLeft) {\r\nif (bal < 0) {\r\nif (!userCount)\r\nbreak;\r\nif (get_user(data, userPtr++))\r\nreturn -EFAULT;\r\ndata ^= 0x80;\r\nuserCount--;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft--;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 2) {\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata ^= 0x8080;\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 2;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_s16be(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\nu_long data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 4)\r\nbreak;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\nuserCount -= 4;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_u16be(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata ^= 0x8000;\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\nu_long data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 4)\r\nbreak;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\ndata ^= 0x80008000;\r\nuserCount -= 4;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_s16le(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata = le2be16(data);\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\nu_long data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 4)\r\nbreak;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\ndata = le2be16dbl(data);\r\nuserCount -= 4;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic ssize_t ata_ctx_u16le(const u_char __user *userPtr, size_t userCount,\r\nu_char frame[], ssize_t *frameUsed,\r\nssize_t frameLeft)\r\n{\r\nlong bal = expand_bal;\r\nlong hSpeed = dmasound.hard.speed, sSpeed = dmasound.soft.speed;\r\nssize_t used, usedf;\r\nused = userCount;\r\nusedf = frameLeft;\r\nif (!dmasound.soft.stereo) {\r\nu_short *p = (u_short *)&frame[*frameUsed];\r\nu_short data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 2)\r\nbreak;\r\nif (get_user(data, (u_short __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 2;\r\ndata = le2be16(data) ^ 0x8000;\r\nuserCount -= 2;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n} else {\r\nu_long *p = (u_long *)&frame[*frameUsed];\r\nu_long data = expand_data;\r\nwhile (frameLeft >= 4) {\r\nif (bal < 0) {\r\nif (userCount < 4)\r\nbreak;\r\nif (get_user(data, (u_int __user *)userPtr))\r\nreturn -EFAULT;\r\nuserPtr += 4;\r\ndata = le2be16dbl(data) ^ 0x80008000;\r\nuserCount -= 4;\r\nbal += hSpeed;\r\n}\r\n*p++ = data;\r\nframeLeft -= 4;\r\nbal -= sSpeed;\r\n}\r\nexpand_data = data;\r\n}\r\nexpand_bal = bal;\r\nused -= userCount;\r\n*frameUsed += usedf-frameLeft;\r\nreturn used;\r\n}\r\nstatic void *AtaAlloc(unsigned int size, gfp_t flags)\r\n{\r\nreturn atari_stram_alloc(size, "dmasound");\r\n}\r\nstatic void AtaFree(void *obj, unsigned int size)\r\n{\r\natari_stram_free( obj );\r\n}\r\nstatic int __init AtaIrqInit(void)\r\n{\r\nst_mfp.tim_ct_a = 0;\r\nst_mfp.tim_dt_a = 1;\r\nst_mfp.tim_ct_a = 8;\r\nif (request_irq(IRQ_MFP_TIMA, AtaInterrupt, 0, "DMA sound",\r\nAtaInterrupt))\r\nreturn 0;\r\nst_mfp.int_en_a |= 0x20;\r\nst_mfp.int_mk_a |= 0x20;\r\nreturn 1;\r\n}\r\nstatic void AtaIrqCleanUp(void)\r\n{\r\nst_mfp.tim_ct_a = 0;\r\nst_mfp.int_en_a &= ~0x20;\r\nfree_irq(IRQ_MFP_TIMA, AtaInterrupt);\r\n}\r\nstatic int AtaSetBass(int bass)\r\n{\r\ndmasound.bass = TONE_VOXWARE_TO_DB(bass);\r\natari_microwire_cmd(MW_LM1992_BASS(dmasound.bass));\r\nreturn TONE_DB_TO_VOXWARE(dmasound.bass);\r\n}\r\nstatic int AtaSetTreble(int treble)\r\n{\r\ndmasound.treble = TONE_VOXWARE_TO_DB(treble);\r\natari_microwire_cmd(MW_LM1992_TREBLE(dmasound.treble));\r\nreturn TONE_DB_TO_VOXWARE(dmasound.treble);\r\n}\r\nstatic void TTSilence(void)\r\n{\r\ntt_dmasnd.ctrl = DMASND_CTRL_OFF;\r\natari_microwire_cmd(MW_LM1992_PSG_HIGH);\r\n}\r\nstatic void TTInit(void)\r\n{\r\nint mode, i, idx;\r\nconst int freq[4] = {50066, 25033, 12517, 6258};\r\nidx = -1;\r\nfor (i = 0; i < ARRAY_SIZE(freq); i++)\r\nif ((100 * abs(dmasound.soft.speed - freq[i]) / freq[i]) < catchRadius)\r\nidx = i;\r\nif (idx > -1) {\r\ndmasound.soft.speed = freq[idx];\r\ndmasound.trans_write = &transTTNormal;\r\n} else\r\ndmasound.trans_write = &transTTExpanding;\r\nTTSilence();\r\ndmasound.hard = dmasound.soft;\r\nif (dmasound.hard.speed > 50066) {\r\ndmasound.hard.speed = 50066;\r\nmode = DMASND_MODE_50KHZ;\r\ndmasound.trans_write = &transTTNormal;\r\n} else if (dmasound.hard.speed > 25033) {\r\ndmasound.hard.speed = 50066;\r\nmode = DMASND_MODE_50KHZ;\r\n} else if (dmasound.hard.speed > 12517) {\r\ndmasound.hard.speed = 25033;\r\nmode = DMASND_MODE_25KHZ;\r\n} else if (dmasound.hard.speed > 6258) {\r\ndmasound.hard.speed = 12517;\r\nmode = DMASND_MODE_12KHZ;\r\n} else {\r\ndmasound.hard.speed = 6258;\r\nmode = DMASND_MODE_6KHZ;\r\n}\r\ntt_dmasnd.mode = (dmasound.hard.stereo ?\r\nDMASND_MODE_STEREO : DMASND_MODE_MONO) |\r\nDMASND_MODE_8BIT | mode;\r\nexpand_bal = -dmasound.soft.speed;\r\n}\r\nstatic int TTSetFormat(int format)\r\n{\r\nswitch (format) {\r\ncase AFMT_QUERY:\r\nreturn dmasound.soft.format;\r\ncase AFMT_MU_LAW:\r\ncase AFMT_A_LAW:\r\ncase AFMT_S8:\r\ncase AFMT_U8:\r\nbreak;\r\ndefault:\r\nformat = AFMT_S8;\r\n}\r\ndmasound.soft.format = format;\r\ndmasound.soft.size = 8;\r\nif (dmasound.minDev == SND_DEV_DSP) {\r\ndmasound.dsp.format = format;\r\ndmasound.dsp.size = 8;\r\n}\r\nTTInit();\r\nreturn format;\r\n}\r\nstatic int TTSetVolume(int volume)\r\n{\r\ndmasound.volume_left = VOLUME_VOXWARE_TO_DB(volume & 0xff);\r\natari_microwire_cmd(MW_LM1992_BALLEFT(dmasound.volume_left));\r\ndmasound.volume_right = VOLUME_VOXWARE_TO_DB((volume & 0xff00) >> 8);\r\natari_microwire_cmd(MW_LM1992_BALRIGHT(dmasound.volume_right));\r\nreturn VOLUME_DB_TO_VOXWARE(dmasound.volume_left) |\r\n(VOLUME_DB_TO_VOXWARE(dmasound.volume_right) << 8);\r\n}\r\nstatic int TTSetGain(int gain)\r\n{\r\ndmasound.gain = GAIN_VOXWARE_TO_DB(gain);\r\natari_microwire_cmd(MW_LM1992_VOLUME(dmasound.gain));\r\nreturn GAIN_DB_TO_VOXWARE(dmasound.gain);\r\n}\r\nstatic void FalconSilence(void)\r\n{\r\ntt_dmasnd.ctrl = DMASND_CTRL_OFF;\r\ntt_dmasnd.mode = DMASND_MODE_50KHZ | DMASND_MODE_STEREO | DMASND_MODE_8BIT;\r\ntt_dmasnd.int_div = 0;\r\ntt_dmasnd.int_ctrl = 0x0;\r\ntt_dmasnd.cbar_src = 0x0000;\r\ntt_dmasnd.cbar_dst = 0x0000;\r\ntt_dmasnd.dac_src = 1;\r\ntt_dmasnd.adc_src = 3;\r\n}\r\nstatic void FalconInit(void)\r\n{\r\nint divider, i, idx;\r\nconst int freq[8] = {49170, 32780, 24585, 19668, 16390, 12292, 9834, 8195};\r\nidx = -1;\r\nfor (i = 0; i < ARRAY_SIZE(freq); i++)\r\nif ((100 * abs(dmasound.soft.speed - freq[i]) / freq[i]) < catchRadius)\r\nidx = i;\r\nif (idx > -1) {\r\ndmasound.soft.speed = freq[idx];\r\ndmasound.trans_write = &transFalconNormal;\r\n} else\r\ndmasound.trans_write = &transFalconExpanding;\r\nFalconSilence();\r\ndmasound.hard = dmasound.soft;\r\nif (dmasound.hard.size == 16) {\r\ndmasound.hard.stereo = 1;\r\n}\r\nif (dmasound.hard.speed > 49170) {\r\ndmasound.hard.speed = 49170;\r\ndivider = 1;\r\ndmasound.trans_write = &transFalconNormal;\r\n} else if (dmasound.hard.speed > 32780) {\r\ndmasound.hard.speed = 49170;\r\ndivider = 1;\r\n} else if (dmasound.hard.speed > 24585) {\r\ndmasound.hard.speed = 32780;\r\ndivider = 2;\r\n} else if (dmasound.hard.speed > 19668) {\r\ndmasound.hard.speed = 24585;\r\ndivider = 3;\r\n} else if (dmasound.hard.speed > 16390) {\r\ndmasound.hard.speed = 19668;\r\ndivider = 4;\r\n} else if (dmasound.hard.speed > 12292) {\r\ndmasound.hard.speed = 16390;\r\ndivider = 5;\r\n} else if (dmasound.hard.speed > 9834) {\r\ndmasound.hard.speed = 12292;\r\ndivider = 7;\r\n} else if (dmasound.hard.speed > 8195) {\r\ndmasound.hard.speed = 9834;\r\ndivider = 9;\r\n} else {\r\ndmasound.hard.speed = 8195;\r\ndivider = 11;\r\n}\r\ntt_dmasnd.int_div = divider;\r\ntt_dmasnd.int_ctrl = 0x4;\r\ntt_dmasnd.track_select = 0x0;\r\ntt_dmasnd.cbar_src = 0x0001;\r\ntt_dmasnd.cbar_dst = 0x0000;\r\ntt_dmasnd.rec_track_select = 0;\r\ntt_dmasnd.dac_src = 2;\r\ntt_dmasnd.adc_src = 0;\r\ntt_dmasnd.mode = (dmasound.hard.stereo ?\r\nDMASND_MODE_STEREO : DMASND_MODE_MONO) |\r\n((dmasound.hard.size == 8) ?\r\nDMASND_MODE_8BIT : DMASND_MODE_16BIT) |\r\nDMASND_MODE_6KHZ;\r\nexpand_bal = -dmasound.soft.speed;\r\n}\r\nstatic int FalconSetFormat(int format)\r\n{\r\nint size;\r\nswitch (format) {\r\ncase AFMT_QUERY:\r\nreturn dmasound.soft.format;\r\ncase AFMT_MU_LAW:\r\ncase AFMT_A_LAW:\r\ncase AFMT_U8:\r\ncase AFMT_S8:\r\nsize = 8;\r\nbreak;\r\ncase AFMT_S16_BE:\r\ncase AFMT_U16_BE:\r\ncase AFMT_S16_LE:\r\ncase AFMT_U16_LE:\r\nsize = 16;\r\nbreak;\r\ndefault:\r\nsize = 8;\r\nformat = AFMT_S8;\r\n}\r\ndmasound.soft.format = format;\r\ndmasound.soft.size = size;\r\nif (dmasound.minDev == SND_DEV_DSP) {\r\ndmasound.dsp.format = format;\r\ndmasound.dsp.size = dmasound.soft.size;\r\n}\r\nFalconInit();\r\nreturn format;\r\n}\r\nstatic int FalconSetVolume(int volume)\r\n{\r\ndmasound.volume_left = VOLUME_VOXWARE_TO_ATT(volume & 0xff);\r\ndmasound.volume_right = VOLUME_VOXWARE_TO_ATT((volume & 0xff00) >> 8);\r\ntt_dmasnd.output_atten = dmasound.volume_left << 8 | dmasound.volume_right << 4;\r\nreturn VOLUME_ATT_TO_VOXWARE(dmasound.volume_left) |\r\nVOLUME_ATT_TO_VOXWARE(dmasound.volume_right) << 8;\r\n}\r\nstatic void AtaPlayNextFrame(int index)\r\n{\r\nchar *start, *end;\r\nstart = write_sq.buffers[write_sq.front];\r\nend = start+((write_sq.count == index) ? write_sq.rear_size\r\n: write_sq.block_size);\r\nDMASNDSetEnd(virt_to_phys(end - 1) + 1);\r\nDMASNDSetBase(virt_to_phys(start));\r\nwrite_sq.front = (write_sq.front+1) % write_sq.max_count;\r\nwrite_sq.active++;\r\ntt_dmasnd.ctrl = DMASND_CTRL_ON | DMASND_CTRL_REPEAT;\r\n}\r\nstatic void AtaPlay(void)\r\n{\r\natari_disable_irq(IRQ_MFP_TIMA);\r\nif (write_sq.active == 2 ||\r\nwrite_sq.count <= 0) {\r\natari_enable_irq(IRQ_MFP_TIMA);\r\nreturn;\r\n}\r\nif (write_sq.active == 0) {\r\nif (write_sq.count == 1 &&\r\nwrite_sq.rear_size < write_sq.block_size &&\r\n!write_sq.syncing) {\r\natari_enable_irq(IRQ_MFP_TIMA);\r\nreturn;\r\n}\r\nAtaPlayNextFrame(1);\r\nif (write_sq.count == 1) {\r\natari_enable_irq(IRQ_MFP_TIMA);\r\nreturn;\r\n}\r\nif (write_sq.count == 2 &&\r\nwrite_sq.rear_size < write_sq.block_size &&\r\n!write_sq.syncing) {\r\natari_enable_irq(IRQ_MFP_TIMA);\r\nreturn;\r\n}\r\nAtaPlayNextFrame(2);\r\n} else {\r\nif (write_sq.count == 2 &&\r\nwrite_sq.rear_size < write_sq.block_size &&\r\n!write_sq.syncing) {\r\natari_enable_irq(IRQ_MFP_TIMA);\r\nreturn;\r\n}\r\nAtaPlayNextFrame(2);\r\n}\r\natari_enable_irq(IRQ_MFP_TIMA);\r\n}\r\nstatic irqreturn_t AtaInterrupt(int irq, void *dummy)\r\n{\r\n#if 0\r\nstatic int cnt;\r\nif (write_sq.active == 2)\r\nif (++cnt == 10) {\r\ncnt = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\n#endif\r\nspin_lock(&dmasound.lock);\r\nif (write_sq_ignore_int && is_falcon) {\r\nwrite_sq_ignore_int = 0;\r\ngoto out;\r\n}\r\nif (!write_sq.active) {\r\nWAKE_UP(write_sq.sync_queue);\r\ngoto out;\r\n}\r\nwrite_sq.count--;\r\nwrite_sq.active--;\r\nif (!write_sq.active) {\r\ntt_dmasnd.ctrl = DMASND_CTRL_OFF;\r\nwrite_sq_ignore_int = 1;\r\n}\r\nWAKE_UP(write_sq.action_queue);\r\nif ((write_sq.active != 1) || (write_sq.count != 1))\r\nAtaPlay();\r\nif (!write_sq.active) WAKE_UP(write_sq.sync_queue);\r\nout:\r\nspin_unlock(&dmasound.lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void __init TTMixerInit(void)\r\n{\r\natari_microwire_cmd(MW_LM1992_VOLUME(0));\r\ndmasound.volume_left = 0;\r\natari_microwire_cmd(MW_LM1992_BALLEFT(0));\r\ndmasound.volume_right = 0;\r\natari_microwire_cmd(MW_LM1992_BALRIGHT(0));\r\natari_microwire_cmd(MW_LM1992_TREBLE(0));\r\natari_microwire_cmd(MW_LM1992_BASS(0));\r\n}\r\nstatic void __init FalconMixerInit(void)\r\n{\r\ndmasound.volume_left = (tt_dmasnd.output_atten & 0xf00) >> 8;\r\ndmasound.volume_right = (tt_dmasnd.output_atten & 0xf0) >> 4;\r\n}\r\nstatic int AtaMixerIoctl(u_int cmd, u_long arg)\r\n{\r\nint data;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SOUND_MIXER_READ_SPEAKER:\r\nif (is_falcon || MACH_IS_TT) {\r\nint porta;\r\nspin_lock_irqsave(&dmasound.lock, flags);\r\nsound_ym.rd_data_reg_sel = 14;\r\nporta = sound_ym.rd_data_reg_sel;\r\nspin_unlock_irqrestore(&dmasound.lock, flags);\r\nreturn IOCTL_OUT(arg, porta & 0x40 ? 0 : 100);\r\n}\r\nbreak;\r\ncase SOUND_MIXER_WRITE_VOLUME:\r\nIOCTL_IN(arg, data);\r\nreturn IOCTL_OUT(arg, dmasound_set_volume(data));\r\ncase SOUND_MIXER_WRITE_SPEAKER:\r\nif (is_falcon || MACH_IS_TT) {\r\nint porta;\r\nIOCTL_IN(arg, data);\r\nspin_lock_irqsave(&dmasound.lock, flags);\r\nsound_ym.rd_data_reg_sel = 14;\r\nporta = (sound_ym.rd_data_reg_sel & ~0x40) |\r\n(data < 50 ? 0x40 : 0);\r\nsound_ym.wd_data = porta;\r\nspin_unlock_irqrestore(&dmasound.lock, flags);\r\nreturn IOCTL_OUT(arg, porta & 0x40 ? 0 : 100);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int TTMixerIoctl(u_int cmd, u_long arg)\r\n{\r\nint data;\r\nswitch (cmd) {\r\ncase SOUND_MIXER_READ_RECMASK:\r\nreturn IOCTL_OUT(arg, 0);\r\ncase SOUND_MIXER_READ_DEVMASK:\r\nreturn IOCTL_OUT(arg,\r\nSOUND_MASK_VOLUME | SOUND_MASK_TREBLE | SOUND_MASK_BASS |\r\n(MACH_IS_TT ? SOUND_MASK_SPEAKER : 0));\r\ncase SOUND_MIXER_READ_STEREODEVS:\r\nreturn IOCTL_OUT(arg, SOUND_MASK_VOLUME);\r\ncase SOUND_MIXER_READ_VOLUME:\r\nreturn IOCTL_OUT(arg,\r\nVOLUME_DB_TO_VOXWARE(dmasound.volume_left) |\r\n(VOLUME_DB_TO_VOXWARE(dmasound.volume_right) << 8));\r\ncase SOUND_MIXER_READ_BASS:\r\nreturn IOCTL_OUT(arg, TONE_DB_TO_VOXWARE(dmasound.bass));\r\ncase SOUND_MIXER_READ_TREBLE:\r\nreturn IOCTL_OUT(arg, TONE_DB_TO_VOXWARE(dmasound.treble));\r\ncase SOUND_MIXER_READ_OGAIN:\r\nreturn IOCTL_OUT(arg, GAIN_DB_TO_VOXWARE(dmasound.gain));\r\ncase SOUND_MIXER_WRITE_BASS:\r\nIOCTL_IN(arg, data);\r\nreturn IOCTL_OUT(arg, dmasound_set_bass(data));\r\ncase SOUND_MIXER_WRITE_TREBLE:\r\nIOCTL_IN(arg, data);\r\nreturn IOCTL_OUT(arg, dmasound_set_treble(data));\r\ncase SOUND_MIXER_WRITE_OGAIN:\r\nIOCTL_IN(arg, data);\r\nreturn IOCTL_OUT(arg, dmasound_set_gain(data));\r\n}\r\nreturn AtaMixerIoctl(cmd, arg);\r\n}\r\nstatic int FalconMixerIoctl(u_int cmd, u_long arg)\r\n{\r\nint data;\r\nswitch (cmd) {\r\ncase SOUND_MIXER_READ_RECMASK:\r\nreturn IOCTL_OUT(arg, SOUND_MASK_MIC);\r\ncase SOUND_MIXER_READ_DEVMASK:\r\nreturn IOCTL_OUT(arg, SOUND_MASK_VOLUME | SOUND_MASK_MIC | SOUND_MASK_SPEAKER);\r\ncase SOUND_MIXER_READ_STEREODEVS:\r\nreturn IOCTL_OUT(arg, SOUND_MASK_VOLUME | SOUND_MASK_MIC);\r\ncase SOUND_MIXER_READ_VOLUME:\r\nreturn IOCTL_OUT(arg,\r\nVOLUME_ATT_TO_VOXWARE(dmasound.volume_left) |\r\nVOLUME_ATT_TO_VOXWARE(dmasound.volume_right) << 8);\r\ncase SOUND_MIXER_READ_CAPS:\r\nreturn IOCTL_OUT(arg, SOUND_CAP_EXCL_INPUT);\r\ncase SOUND_MIXER_WRITE_MIC:\r\nIOCTL_IN(arg, data);\r\ntt_dmasnd.input_gain =\r\nRECLEVEL_VOXWARE_TO_GAIN(data & 0xff) << 4 |\r\nRECLEVEL_VOXWARE_TO_GAIN(data >> 8 & 0xff);\r\ncase SOUND_MIXER_READ_MIC:\r\nreturn IOCTL_OUT(arg,\r\nRECLEVEL_GAIN_TO_VOXWARE(tt_dmasnd.input_gain >> 4 & 0xf) |\r\nRECLEVEL_GAIN_TO_VOXWARE(tt_dmasnd.input_gain & 0xf) << 8);\r\n}\r\nreturn AtaMixerIoctl(cmd, arg);\r\n}\r\nstatic int AtaWriteSqSetup(void)\r\n{\r\nwrite_sq_ignore_int = 0;\r\nreturn 0 ;\r\n}\r\nstatic int AtaSqOpen(fmode_t mode)\r\n{\r\nwrite_sq_ignore_int = 1;\r\nreturn 0 ;\r\n}\r\nstatic int TTStateInfo(char *buffer, size_t space)\r\n{\r\nint len = 0;\r\nlen += sprintf(buffer+len, "\tvol left %ddB [-40... 0]\n",\r\ndmasound.volume_left);\r\nlen += sprintf(buffer+len, "\tvol right %ddB [-40... 0]\n",\r\ndmasound.volume_right);\r\nlen += sprintf(buffer+len, "\tbass %ddB [-12...+12]\n",\r\ndmasound.bass);\r\nlen += sprintf(buffer+len, "\ttreble %ddB [-12...+12]\n",\r\ndmasound.treble);\r\nif (len >= space) {\r\nprintk(KERN_ERR "dmasound_atari: overflowed state buffer alloc.\n") ;\r\nlen = space ;\r\n}\r\nreturn len;\r\n}\r\nstatic int FalconStateInfo(char *buffer, size_t space)\r\n{\r\nint len = 0;\r\nlen += sprintf(buffer+len, "\tvol left %ddB [-22.5 ... 0]\n",\r\ndmasound.volume_left);\r\nlen += sprintf(buffer+len, "\tvol right %ddB [-22.5 ... 0]\n",\r\ndmasound.volume_right);\r\nif (len >= space) {\r\nprintk(KERN_ERR "dmasound_atari: overflowed state buffer alloc.\n") ;\r\nlen = space ;\r\n}\r\nreturn len;\r\n}\r\nstatic int __init dmasound_atari_init(void)\r\n{\r\nif (MACH_IS_ATARI && ATARIHW_PRESENT(PCM_8BIT)) {\r\nif (ATARIHW_PRESENT(CODEC)) {\r\ndmasound.mach = machFalcon;\r\ndmasound.mach.default_soft = def_soft ;\r\ndmasound.mach.default_hard = def_hard_falcon ;\r\nis_falcon = 1;\r\n} else if (ATARIHW_PRESENT(MICROWIRE)) {\r\ndmasound.mach = machTT;\r\ndmasound.mach.default_soft = def_soft ;\r\ndmasound.mach.default_hard = def_hard_tt ;\r\nis_falcon = 0;\r\n} else\r\nreturn -ENODEV;\r\nif ((st_mfp.int_en_a & st_mfp.int_mk_a & 0x20) == 0)\r\nreturn dmasound_init();\r\nelse {\r\nprintk("DMA sound driver: Timer A interrupt already in use\n");\r\nreturn -EBUSY;\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit dmasound_atari_cleanup(void)\r\n{\r\ndmasound_deinit();\r\n}
