static int alpha_core_agp_vm_fault(struct vm_fault *vmf)\r\n{\r\nalpha_agp_info *agp = agp_bridge->dev_private_data;\r\ndma_addr_t dma_addr;\r\nunsigned long pa;\r\nstruct page *page;\r\ndma_addr = vmf->address - vmf->vma->vm_start + agp->aperture.bus_base;\r\npa = agp->ops->translate(agp, dma_addr);\r\nif (pa == (unsigned long)-EINVAL)\r\nreturn VM_FAULT_SIGBUS;\r\npage = virt_to_page(__va(pa));\r\nget_page(page);\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nstatic int alpha_core_agp_fetch_size(void)\r\n{\r\nreturn alpha_core_agp_sizes[0].size;\r\n}\r\nstatic int alpha_core_agp_configure(void)\r\n{\r\nalpha_agp_info *agp = agp_bridge->dev_private_data;\r\nagp_bridge->gart_bus_addr = agp->aperture.bus_base;\r\nreturn 0;\r\n}\r\nstatic void alpha_core_agp_cleanup(void)\r\n{\r\nalpha_agp_info *agp = agp_bridge->dev_private_data;\r\nagp->ops->cleanup(agp);\r\n}\r\nstatic void alpha_core_agp_tlbflush(struct agp_memory *mem)\r\n{\r\nalpha_agp_info *agp = agp_bridge->dev_private_data;\r\nalpha_mv.mv_pci_tbi(agp->hose, 0, -1);\r\n}\r\nstatic void alpha_core_agp_enable(struct agp_bridge_data *bridge, u32 mode)\r\n{\r\nalpha_agp_info *agp = bridge->dev_private_data;\r\nagp->mode.lw = agp_collect_device_status(bridge, mode,\r\nagp->capability.lw);\r\nagp->mode.bits.enable = 1;\r\nagp->ops->configure(agp);\r\nagp_device_command(agp->mode.lw, false);\r\n}\r\nstatic int alpha_core_agp_insert_memory(struct agp_memory *mem, off_t pg_start,\r\nint type)\r\n{\r\nalpha_agp_info *agp = agp_bridge->dev_private_data;\r\nint num_entries, status;\r\nvoid *temp;\r\nif (type >= AGP_USER_TYPES || mem->type >= AGP_USER_TYPES)\r\nreturn -EINVAL;\r\ntemp = agp_bridge->current_size;\r\nnum_entries = A_SIZE_FIX(temp)->num_entries;\r\nif ((pg_start + mem->page_count) > num_entries)\r\nreturn -EINVAL;\r\nstatus = agp->ops->bind(agp, pg_start, mem);\r\nmb();\r\nalpha_core_agp_tlbflush(mem);\r\nreturn status;\r\n}\r\nstatic int alpha_core_agp_remove_memory(struct agp_memory *mem, off_t pg_start,\r\nint type)\r\n{\r\nalpha_agp_info *agp = agp_bridge->dev_private_data;\r\nint status;\r\nstatus = agp->ops->unbind(agp, pg_start, mem);\r\nalpha_core_agp_tlbflush(mem);\r\nreturn status;\r\n}\r\nstatic int alpha_core_agp_create_free_gatt_table(struct agp_bridge_data *a)\r\n{\r\nreturn 0;\r\n}\r\nint __init\r\nalpha_core_agp_setup(void)\r\n{\r\nalpha_agp_info *agp = alpha_mv.agp_info();\r\nstruct pci_dev *pdev;\r\nstruct aper_size_info_fixed *aper_size;\r\nif (!agp)\r\nreturn -ENODEV;\r\nif (agp->ops->setup(agp))\r\nreturn -ENODEV;\r\naper_size = alpha_core_agp_sizes;\r\naper_size->size = agp->aperture.size / (1024 * 1024);\r\naper_size->num_entries = agp->aperture.size / PAGE_SIZE;\r\naper_size->page_order = __ffs(aper_size->num_entries / 1024);\r\npdev = pci_alloc_dev(NULL);\r\nif (!pdev)\r\nreturn -ENOMEM;\r\npdev->vendor = 0xffff;\r\npdev->device = 0xffff;\r\npdev->sysdata = agp->hose;\r\nalpha_bridge = agp_alloc_bridge();\r\nif (!alpha_bridge)\r\ngoto fail;\r\nalpha_bridge->driver = &alpha_core_agp_driver;\r\nalpha_bridge->vm_ops = &alpha_core_agp_vm_ops;\r\nalpha_bridge->current_size = aper_size;\r\nalpha_bridge->dev_private_data = agp;\r\nalpha_bridge->dev = pdev;\r\nalpha_bridge->mode = agp->capability.lw;\r\nprintk(KERN_INFO PFX "Detected AGP on hose %d\n", agp->hose->index);\r\nreturn agp_add_bridge(alpha_bridge);\r\nfail:\r\nkfree(pdev);\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init agp_alpha_core_init(void)\r\n{\r\nif (agp_off)\r\nreturn -EINVAL;\r\nif (alpha_mv.agp_info)\r\nreturn alpha_core_agp_setup();\r\nreturn -ENODEV;\r\n}\r\nstatic void __exit agp_alpha_core_cleanup(void)\r\n{\r\nagp_remove_bridge(alpha_bridge);\r\nagp_put_bridge(alpha_bridge);\r\n}
