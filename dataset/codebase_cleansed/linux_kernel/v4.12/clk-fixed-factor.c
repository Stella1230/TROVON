static unsigned long clk_factor_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_fixed_factor *fix = to_clk_fixed_factor(hw);\r\nunsigned long long int rate;\r\nrate = (unsigned long long int)parent_rate * fix->mult;\r\ndo_div(rate, fix->div);\r\nreturn (unsigned long)rate;\r\n}\r\nstatic long clk_factor_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_fixed_factor *fix = to_clk_fixed_factor(hw);\r\nif (clk_hw_get_flags(hw) & CLK_SET_RATE_PARENT) {\r\nunsigned long best_parent;\r\nbest_parent = (rate / fix->mult) * fix->div;\r\n*prate = clk_hw_round_rate(clk_hw_get_parent(hw), best_parent);\r\n}\r\nreturn (*prate / fix->div) * fix->mult;\r\n}\r\nstatic int clk_factor_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nreturn 0;\r\n}\r\nstruct clk_hw *clk_hw_register_fixed_factor(struct device *dev,\r\nconst char *name, const char *parent_name, unsigned long flags,\r\nunsigned int mult, unsigned int div)\r\n{\r\nstruct clk_fixed_factor *fix;\r\nstruct clk_init_data init;\r\nstruct clk_hw *hw;\r\nint ret;\r\nfix = kmalloc(sizeof(*fix), GFP_KERNEL);\r\nif (!fix)\r\nreturn ERR_PTR(-ENOMEM);\r\nfix->mult = mult;\r\nfix->div = div;\r\nfix->hw.init = &init;\r\ninit.name = name;\r\ninit.ops = &clk_fixed_factor_ops;\r\ninit.flags = flags | CLK_IS_BASIC;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nhw = &fix->hw;\r\nret = clk_hw_register(dev, hw);\r\nif (ret) {\r\nkfree(fix);\r\nhw = ERR_PTR(ret);\r\n}\r\nreturn hw;\r\n}\r\nstruct clk *clk_register_fixed_factor(struct device *dev, const char *name,\r\nconst char *parent_name, unsigned long flags,\r\nunsigned int mult, unsigned int div)\r\n{\r\nstruct clk_hw *hw;\r\nhw = clk_hw_register_fixed_factor(dev, name, parent_name, flags, mult,\r\ndiv);\r\nif (IS_ERR(hw))\r\nreturn ERR_CAST(hw);\r\nreturn hw->clk;\r\n}\r\nvoid clk_unregister_fixed_factor(struct clk *clk)\r\n{\r\nstruct clk_hw *hw;\r\nhw = __clk_get_hw(clk);\r\nif (!hw)\r\nreturn;\r\nclk_unregister(clk);\r\nkfree(to_clk_fixed_factor(hw));\r\n}\r\nvoid clk_hw_unregister_fixed_factor(struct clk_hw *hw)\r\n{\r\nstruct clk_fixed_factor *fix;\r\nfix = to_clk_fixed_factor(hw);\r\nclk_hw_unregister(hw);\r\nkfree(fix);\r\n}\r\nstatic struct clk *_of_fixed_factor_clk_setup(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nconst char *clk_name = node->name;\r\nconst char *parent_name;\r\nunsigned long flags = 0;\r\nu32 div, mult;\r\nint ret;\r\nif (of_property_read_u32(node, "clock-div", &div)) {\r\npr_err("%s Fixed factor clock <%s> must have a clock-div property\n",\r\n__func__, node->name);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nif (of_property_read_u32(node, "clock-mult", &mult)) {\r\npr_err("%s Fixed factor clock <%s> must have a clock-mult property\n",\r\n__func__, node->name);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nof_property_read_string(node, "clock-output-names", &clk_name);\r\nparent_name = of_clk_get_parent_name(node, 0);\r\nif (of_match_node(set_rate_parent_matches, node))\r\nflags |= CLK_SET_RATE_PARENT;\r\nclk = clk_register_fixed_factor(NULL, clk_name, parent_name, flags,\r\nmult, div);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\nret = of_clk_add_provider(node, of_clk_src_simple_get, clk);\r\nif (ret) {\r\nclk_unregister(clk);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn clk;\r\n}\r\nvoid __init of_fixed_factor_clk_setup(struct device_node *node)\r\n{\r\n_of_fixed_factor_clk_setup(node);\r\n}\r\nstatic int of_fixed_factor_clk_remove(struct platform_device *pdev)\r\n{\r\nstruct clk *clk = platform_get_drvdata(pdev);\r\nclk_unregister_fixed_factor(clk);\r\nreturn 0;\r\n}\r\nstatic int of_fixed_factor_clk_probe(struct platform_device *pdev)\r\n{\r\nstruct clk *clk;\r\nclk = _of_fixed_factor_clk_setup(pdev->dev.of_node);\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nplatform_set_drvdata(pdev, clk);\r\nreturn 0;\r\n}
