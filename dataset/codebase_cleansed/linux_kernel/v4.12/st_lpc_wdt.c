static void st_wdog_setup(struct st_wdog *st_wdog, bool enable)\r\n{\r\nif (st_wdog->syscfg->reset_type_reg)\r\nregmap_update_bits(st_wdog->regmap,\r\nst_wdog->syscfg->reset_type_reg,\r\nst_wdog->syscfg->reset_type_mask,\r\nst_wdog->warm_reset);\r\nregmap_update_bits(st_wdog->regmap,\r\nst_wdog->syscfg->enable_reg,\r\nst_wdog->syscfg->enable_mask,\r\nenable ? 0 : st_wdog->syscfg->enable_mask);\r\n}\r\nstatic void st_wdog_load_timer(struct st_wdog *st_wdog, unsigned int timeout)\r\n{\r\nunsigned long clkrate = st_wdog->clkrate;\r\nwritel_relaxed(timeout * clkrate, st_wdog->base + LPC_LPA_LSB_OFF);\r\nwritel_relaxed(1, st_wdog->base + LPC_LPA_START_OFF);\r\n}\r\nstatic int st_wdog_start(struct watchdog_device *wdd)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\r\nwritel_relaxed(1, st_wdog->base + LPC_WDT_OFF);\r\nreturn 0;\r\n}\r\nstatic int st_wdog_stop(struct watchdog_device *wdd)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\r\nwritel_relaxed(0, st_wdog->base + LPC_WDT_OFF);\r\nreturn 0;\r\n}\r\nstatic int st_wdog_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\r\nwdd->timeout = timeout;\r\nst_wdog_load_timer(st_wdog, timeout);\r\nreturn 0;\r\n}\r\nstatic int st_wdog_keepalive(struct watchdog_device *wdd)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(wdd);\r\nst_wdog_load_timer(st_wdog, wdd->timeout);\r\nreturn 0;\r\n}\r\nstatic int st_wdog_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *match;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct st_wdog *st_wdog;\r\nstruct regmap *regmap;\r\nstruct resource *res;\r\nstruct clk *clk;\r\nvoid __iomem *base;\r\nuint32_t mode;\r\nint ret;\r\nret = of_property_read_u32(np, "st,lpc-mode", &mode);\r\nif (ret) {\r\ndev_err(&pdev->dev, "An LPC mode must be provided\n");\r\nreturn -EINVAL;\r\n}\r\nif (mode != ST_LPC_MODE_WDT)\r\nreturn -ENODEV;\r\nst_wdog = devm_kzalloc(&pdev->dev, sizeof(*st_wdog), GFP_KERNEL);\r\nif (!st_wdog)\r\nreturn -ENOMEM;\r\nmatch = of_match_device(st_wdog_match, &pdev->dev);\r\nif (!match) {\r\ndev_err(&pdev->dev, "Couldn't match device\n");\r\nreturn -ENODEV;\r\n}\r\nst_wdog->syscfg = (struct st_wdog_syscfg *)match->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nregmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(regmap)) {\r\ndev_err(&pdev->dev, "No syscfg phandle specified\n");\r\nreturn PTR_ERR(regmap);\r\n}\r\nclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(clk)) {\r\ndev_err(&pdev->dev, "Unable to request clock\n");\r\nreturn PTR_ERR(clk);\r\n}\r\nst_wdog->dev = &pdev->dev;\r\nst_wdog->base = base;\r\nst_wdog->clk = clk;\r\nst_wdog->regmap = regmap;\r\nst_wdog->warm_reset = of_property_read_bool(np, "st,warm_reset");\r\nst_wdog->clkrate = clk_get_rate(st_wdog->clk);\r\nif (!st_wdog->clkrate) {\r\ndev_err(&pdev->dev, "Unable to fetch clock rate\n");\r\nreturn -EINVAL;\r\n}\r\nst_wdog_dev.max_timeout = 0xFFFFFFFF / st_wdog->clkrate;\r\nst_wdog_dev.parent = &pdev->dev;\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to enable clock\n");\r\nreturn ret;\r\n}\r\nwatchdog_set_drvdata(&st_wdog_dev, st_wdog);\r\nwatchdog_set_nowayout(&st_wdog_dev, WATCHDOG_NOWAYOUT);\r\nret = watchdog_init_timeout(&st_wdog_dev, 0, &pdev->dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to initialise watchdog timeout\n");\r\nclk_disable_unprepare(clk);\r\nreturn ret;\r\n}\r\nret = watchdog_register_device(&st_wdog_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Unable to register watchdog\n");\r\nclk_disable_unprepare(clk);\r\nreturn ret;\r\n}\r\nst_wdog_setup(st_wdog, true);\r\ndev_info(&pdev->dev, "LPC Watchdog driver registered, reset type is %s",\r\nst_wdog->warm_reset ? "warm" : "cold");\r\nreturn ret;\r\n}\r\nstatic int st_wdog_remove(struct platform_device *pdev)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(&st_wdog_dev);\r\nst_wdog_setup(st_wdog, false);\r\nwatchdog_unregister_device(&st_wdog_dev);\r\nclk_disable_unprepare(st_wdog->clk);\r\nreturn 0;\r\n}\r\nstatic int st_wdog_suspend(struct device *dev)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(&st_wdog_dev);\r\nif (watchdog_active(&st_wdog_dev))\r\nst_wdog_stop(&st_wdog_dev);\r\nst_wdog_setup(st_wdog, false);\r\nclk_disable(st_wdog->clk);\r\nreturn 0;\r\n}\r\nstatic int st_wdog_resume(struct device *dev)\r\n{\r\nstruct st_wdog *st_wdog = watchdog_get_drvdata(&st_wdog_dev);\r\nint ret;\r\nret = clk_enable(st_wdog->clk);\r\nif (ret) {\r\ndev_err(dev, "Unable to re-enable clock\n");\r\nwatchdog_unregister_device(&st_wdog_dev);\r\nclk_unprepare(st_wdog->clk);\r\nreturn ret;\r\n}\r\nst_wdog_setup(st_wdog, true);\r\nif (watchdog_active(&st_wdog_dev)) {\r\nst_wdog_load_timer(st_wdog, st_wdog_dev.timeout);\r\nst_wdog_start(&st_wdog_dev);\r\n}\r\nreturn 0;\r\n}
