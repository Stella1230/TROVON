int fb_alloc_cmap_gfp(struct fb_cmap *cmap, int len, int transp, gfp_t flags)\r\n{\r\nint size = len * sizeof(u16);\r\nint ret = -ENOMEM;\r\nif (cmap->len != len) {\r\nfb_dealloc_cmap(cmap);\r\nif (!len)\r\nreturn 0;\r\ncmap->red = kmalloc(size, flags);\r\nif (!cmap->red)\r\ngoto fail;\r\ncmap->green = kmalloc(size, flags);\r\nif (!cmap->green)\r\ngoto fail;\r\ncmap->blue = kmalloc(size, flags);\r\nif (!cmap->blue)\r\ngoto fail;\r\nif (transp) {\r\ncmap->transp = kmalloc(size, flags);\r\nif (!cmap->transp)\r\ngoto fail;\r\n} else {\r\ncmap->transp = NULL;\r\n}\r\n}\r\ncmap->start = 0;\r\ncmap->len = len;\r\nret = fb_copy_cmap(fb_default_cmap(len), cmap);\r\nif (ret)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nfb_dealloc_cmap(cmap);\r\nreturn ret;\r\n}\r\nint fb_alloc_cmap(struct fb_cmap *cmap, int len, int transp)\r\n{\r\nreturn fb_alloc_cmap_gfp(cmap, len, transp, GFP_ATOMIC);\r\n}\r\nvoid fb_dealloc_cmap(struct fb_cmap *cmap)\r\n{\r\nkfree(cmap->red);\r\nkfree(cmap->green);\r\nkfree(cmap->blue);\r\nkfree(cmap->transp);\r\ncmap->red = cmap->green = cmap->blue = cmap->transp = NULL;\r\ncmap->len = 0;\r\n}\r\nint fb_copy_cmap(const struct fb_cmap *from, struct fb_cmap *to)\r\n{\r\nunsigned int tooff = 0, fromoff = 0;\r\nsize_t size;\r\nif (to->start > from->start)\r\nfromoff = to->start - from->start;\r\nelse\r\ntooff = from->start - to->start;\r\nif (fromoff >= from->len || tooff >= to->len)\r\nreturn -EINVAL;\r\nsize = min_t(size_t, to->len - tooff, from->len - fromoff);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nsize *= sizeof(u16);\r\nmemcpy(to->red+tooff, from->red+fromoff, size);\r\nmemcpy(to->green+tooff, from->green+fromoff, size);\r\nmemcpy(to->blue+tooff, from->blue+fromoff, size);\r\nif (from->transp && to->transp)\r\nmemcpy(to->transp+tooff, from->transp+fromoff, size);\r\nreturn 0;\r\n}\r\nint fb_cmap_to_user(const struct fb_cmap *from, struct fb_cmap_user *to)\r\n{\r\nunsigned int tooff = 0, fromoff = 0;\r\nsize_t size;\r\nif (to->start > from->start)\r\nfromoff = to->start - from->start;\r\nelse\r\ntooff = from->start - to->start;\r\nif (fromoff >= from->len || tooff >= to->len)\r\nreturn -EINVAL;\r\nsize = min_t(size_t, to->len - tooff, from->len - fromoff);\r\nif (size == 0)\r\nreturn -EINVAL;\r\nsize *= sizeof(u16);\r\nif (copy_to_user(to->red+tooff, from->red+fromoff, size))\r\nreturn -EFAULT;\r\nif (copy_to_user(to->green+tooff, from->green+fromoff, size))\r\nreturn -EFAULT;\r\nif (copy_to_user(to->blue+tooff, from->blue+fromoff, size))\r\nreturn -EFAULT;\r\nif (from->transp && to->transp)\r\nif (copy_to_user(to->transp+tooff, from->transp+fromoff, size))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nint fb_set_cmap(struct fb_cmap *cmap, struct fb_info *info)\r\n{\r\nint i, start, rc = 0;\r\nu16 *red, *green, *blue, *transp;\r\nu_int hred, hgreen, hblue, htransp = 0xffff;\r\nred = cmap->red;\r\ngreen = cmap->green;\r\nblue = cmap->blue;\r\ntransp = cmap->transp;\r\nstart = cmap->start;\r\nif (start < 0 || (!info->fbops->fb_setcolreg &&\r\n!info->fbops->fb_setcmap))\r\nreturn -EINVAL;\r\nif (info->fbops->fb_setcmap) {\r\nrc = info->fbops->fb_setcmap(cmap, info);\r\n} else {\r\nfor (i = 0; i < cmap->len; i++) {\r\nhred = *red++;\r\nhgreen = *green++;\r\nhblue = *blue++;\r\nif (transp)\r\nhtransp = *transp++;\r\nif (info->fbops->fb_setcolreg(start++,\r\nhred, hgreen, hblue,\r\nhtransp, info))\r\nbreak;\r\n}\r\n}\r\nif (rc == 0)\r\nfb_copy_cmap(cmap, &info->cmap);\r\nreturn rc;\r\n}\r\nint fb_set_user_cmap(struct fb_cmap_user *cmap, struct fb_info *info)\r\n{\r\nint rc, size = cmap->len * sizeof(u16);\r\nstruct fb_cmap umap;\r\nif (size < 0 || size < cmap->len)\r\nreturn -E2BIG;\r\nmemset(&umap, 0, sizeof(struct fb_cmap));\r\nrc = fb_alloc_cmap_gfp(&umap, cmap->len, cmap->transp != NULL,\r\nGFP_KERNEL);\r\nif (rc)\r\nreturn rc;\r\nif (copy_from_user(umap.red, cmap->red, size) ||\r\ncopy_from_user(umap.green, cmap->green, size) ||\r\ncopy_from_user(umap.blue, cmap->blue, size) ||\r\n(cmap->transp && copy_from_user(umap.transp, cmap->transp, size))) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\numap.start = cmap->start;\r\nif (!lock_fb_info(info)) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nrc = fb_set_cmap(&umap, info);\r\nunlock_fb_info(info);\r\nout:\r\nfb_dealloc_cmap(&umap);\r\nreturn rc;\r\n}\r\nconst struct fb_cmap *fb_default_cmap(int len)\r\n{\r\nif (len <= 2)\r\nreturn &default_2_colors;\r\nif (len <= 4)\r\nreturn &default_4_colors;\r\nif (len <= 8)\r\nreturn &default_8_colors;\r\nreturn &default_16_colors;\r\n}\r\nvoid fb_invert_cmaps(void)\r\n{\r\nu_int i;\r\nfor (i = 0; i < ARRAY_SIZE(red2); i++) {\r\nred2[i] = ~red2[i];\r\ngreen2[i] = ~green2[i];\r\nblue2[i] = ~blue2[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(red4); i++) {\r\nred4[i] = ~red4[i];\r\ngreen4[i] = ~green4[i];\r\nblue4[i] = ~blue4[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(red8); i++) {\r\nred8[i] = ~red8[i];\r\ngreen8[i] = ~green8[i];\r\nblue8[i] = ~blue8[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(red16); i++) {\r\nred16[i] = ~red16[i];\r\ngreen16[i] = ~green16[i];\r\nblue16[i] = ~blue16[i];\r\n}\r\n}
