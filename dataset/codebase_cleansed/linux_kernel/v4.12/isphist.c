static void hist_reset_mem(struct ispstat *hist)\r\n{\r\nstruct isp_device *isp = hist->isp;\r\nstruct omap3isp_hist_config *conf = hist->priv;\r\nunsigned int i;\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\r\nfor (i = OMAP3ISP_HIST_MEM_SIZE / 4; i > 0; i--) {\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\nisp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n}\r\nisp_reg_clr(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\r\nhist->wait_acc_frames = conf->num_acc_frames;\r\n}\r\nstatic void hist_setup_regs(struct ispstat *hist, void *priv)\r\n{\r\nstruct isp_device *isp = hist->isp;\r\nstruct omap3isp_hist_config *conf = priv;\r\nint c;\r\nu32 cnt;\r\nu32 wb_gain;\r\nu32 reg_hor[OMAP3ISP_HIST_MAX_REGIONS];\r\nu32 reg_ver[OMAP3ISP_HIST_MAX_REGIONS];\r\nif (!hist->update || hist->state == ISPSTAT_DISABLED ||\r\nhist->state == ISPSTAT_DISABLING)\r\nreturn;\r\ncnt = conf->cfa << ISPHIST_CNT_CFA_SHIFT;\r\nwb_gain = conf->wg[0] << ISPHIST_WB_GAIN_WG00_SHIFT;\r\nwb_gain |= conf->wg[1] << ISPHIST_WB_GAIN_WG01_SHIFT;\r\nwb_gain |= conf->wg[2] << ISPHIST_WB_GAIN_WG02_SHIFT;\r\nif (conf->cfa == OMAP3ISP_HIST_CFA_BAYER)\r\nwb_gain |= conf->wg[3] << ISPHIST_WB_GAIN_WG03_SHIFT;\r\nfor (c = 0; c < OMAP3ISP_HIST_MAX_REGIONS; c++) {\r\nif (c < conf->num_regions) {\r\nreg_hor[c] = (conf->region[c].h_start <<\r\nISPHIST_REG_START_SHIFT)\r\n| (conf->region[c].h_end <<\r\nISPHIST_REG_END_SHIFT);\r\nreg_ver[c] = (conf->region[c].v_start <<\r\nISPHIST_REG_START_SHIFT)\r\n| (conf->region[c].v_end <<\r\nISPHIST_REG_END_SHIFT);\r\n} else {\r\nreg_hor[c] = 0;\r\nreg_ver[c] = 0;\r\n}\r\n}\r\ncnt |= conf->hist_bins << ISPHIST_CNT_BINS_SHIFT;\r\nswitch (conf->hist_bins) {\r\ncase OMAP3ISP_HIST_BINS_256:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 8) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\ncase OMAP3ISP_HIST_BINS_128:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 7) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\ncase OMAP3ISP_HIST_BINS_64:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 6) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\ndefault:\r\ncnt |= (ISPHIST_IN_BIT_WIDTH_CCDC - 5) <<\r\nISPHIST_CNT_SHIFT_SHIFT;\r\nbreak;\r\n}\r\nhist_reset_mem(hist);\r\nisp_reg_writel(isp, cnt, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT);\r\nisp_reg_writel(isp, wb_gain, OMAP3_ISP_IOMEM_HIST, ISPHIST_WB_GAIN);\r\nisp_reg_writel(isp, reg_hor[0], OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_HORZ);\r\nisp_reg_writel(isp, reg_ver[0], OMAP3_ISP_IOMEM_HIST, ISPHIST_R0_VERT);\r\nisp_reg_writel(isp, reg_hor[1], OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_HORZ);\r\nisp_reg_writel(isp, reg_ver[1], OMAP3_ISP_IOMEM_HIST, ISPHIST_R1_VERT);\r\nisp_reg_writel(isp, reg_hor[2], OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_HORZ);\r\nisp_reg_writel(isp, reg_ver[2], OMAP3_ISP_IOMEM_HIST, ISPHIST_R2_VERT);\r\nisp_reg_writel(isp, reg_hor[3], OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_HORZ);\r\nisp_reg_writel(isp, reg_ver[3], OMAP3_ISP_IOMEM_HIST, ISPHIST_R3_VERT);\r\nhist->update = 0;\r\nhist->config_counter += hist->inc_config;\r\nhist->inc_config = 0;\r\nhist->buf_size = conf->buf_size;\r\n}\r\nstatic void hist_enable(struct ispstat *hist, int enable)\r\n{\r\nif (enable) {\r\nisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,\r\nISPHIST_PCR_ENABLE);\r\nomap3isp_subclk_enable(hist->isp, OMAP3_ISP_SUBCLK_HIST);\r\n} else {\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR,\r\nISPHIST_PCR_ENABLE);\r\nomap3isp_subclk_disable(hist->isp, OMAP3_ISP_SUBCLK_HIST);\r\n}\r\n}\r\nstatic int hist_busy(struct ispstat *hist)\r\n{\r\nreturn isp_reg_readl(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_PCR)\r\n& ISPHIST_PCR_BUSY;\r\n}\r\nstatic void hist_dma_cb(void *data)\r\n{\r\nstruct ispstat *hist = data;\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\r\nISPHIST_CNT_CLEAR);\r\nomap3isp_stat_dma_isr(hist);\r\nif (hist->state != ISPSTAT_DISABLED)\r\nomap3isp_hist_dma_done(hist->isp);\r\n}\r\nstatic int hist_buf_dma(struct ispstat *hist)\r\n{\r\ndma_addr_t dma_addr = hist->active_buf->dma_addr;\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dma_slave_config cfg;\r\ndma_cookie_t cookie;\r\nint ret;\r\nif (unlikely(!dma_addr)) {\r\ndev_dbg(hist->isp->dev, "hist: invalid DMA buffer address\n");\r\ngoto error;\r\n}\r\nisp_reg_writel(hist->isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\r\nisp_reg_set(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\r\nISPHIST_CNT_CLEAR);\r\nomap3isp_flush(hist->isp);\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.src_addr = hist->isp->mmio_hist_base_phys + ISPHIST_DATA;\r\ncfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.src_maxburst = hist->buf_size / 4;\r\nret = dmaengine_slave_config(hist->dma_ch, &cfg);\r\nif (ret < 0) {\r\ndev_dbg(hist->isp->dev,\r\n"hist: DMA slave configuration failed\n");\r\ngoto error;\r\n}\r\ntx = dmaengine_prep_slave_single(hist->dma_ch, dma_addr,\r\nhist->buf_size, DMA_DEV_TO_MEM,\r\nDMA_CTRL_ACK);\r\nif (tx == NULL) {\r\ndev_dbg(hist->isp->dev,\r\n"hist: DMA slave preparation failed\n");\r\ngoto error;\r\n}\r\ntx->callback = hist_dma_cb;\r\ntx->callback_param = hist;\r\ncookie = tx->tx_submit(tx);\r\nif (dma_submit_error(cookie)) {\r\ndev_dbg(hist->isp->dev, "hist: DMA submission failed\n");\r\ngoto error;\r\n}\r\ndma_async_issue_pending(hist->dma_ch);\r\nreturn STAT_BUF_WAITING_DMA;\r\nerror:\r\nhist_reset_mem(hist);\r\nreturn STAT_NO_BUF;\r\n}\r\nstatic int hist_buf_pio(struct ispstat *hist)\r\n{\r\nstruct isp_device *isp = hist->isp;\r\nu32 *buf = hist->active_buf->virt_addr;\r\nunsigned int i;\r\nif (!buf) {\r\ndev_dbg(isp->dev, "hist: invalid PIO buffer address\n");\r\nhist_reset_mem(hist);\r\nreturn STAT_NO_BUF;\r\n}\r\nisp_reg_writel(isp, 0, OMAP3_ISP_IOMEM_HIST, ISPHIST_ADDR);\r\nisp_reg_set(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT, ISPHIST_CNT_CLEAR);\r\nfor (i = hist->buf_size / 16; i > 0; i--) {\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n*buf++ = isp_reg_readl(isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_DATA);\r\n}\r\nisp_reg_clr(hist->isp, OMAP3_ISP_IOMEM_HIST, ISPHIST_CNT,\r\nISPHIST_CNT_CLEAR);\r\nreturn STAT_BUF_DONE;\r\n}\r\nstatic int hist_buf_process(struct ispstat *hist)\r\n{\r\nstruct omap3isp_hist_config *user_cfg = hist->priv;\r\nint ret;\r\nif (atomic_read(&hist->buf_err) || hist->state != ISPSTAT_ENABLED) {\r\nhist_reset_mem(hist);\r\nreturn STAT_NO_BUF;\r\n}\r\nif (--(hist->wait_acc_frames))\r\nreturn STAT_NO_BUF;\r\nif (hist->dma_ch)\r\nret = hist_buf_dma(hist);\r\nelse\r\nret = hist_buf_pio(hist);\r\nhist->wait_acc_frames = user_cfg->num_acc_frames;\r\nreturn ret;\r\n}\r\nstatic u32 hist_get_buf_size(struct omap3isp_hist_config *conf)\r\n{\r\nreturn OMAP3ISP_HIST_MEM_SIZE_BINS(conf->hist_bins) * conf->num_regions;\r\n}\r\nstatic int hist_validate_params(struct ispstat *hist, void *new_conf)\r\n{\r\nstruct omap3isp_hist_config *user_cfg = new_conf;\r\nint c;\r\nu32 buf_size;\r\nif (user_cfg->cfa > OMAP3ISP_HIST_CFA_FOVEONX3)\r\nreturn -EINVAL;\r\nif ((user_cfg->num_regions < OMAP3ISP_HIST_MIN_REGIONS) ||\r\n(user_cfg->num_regions > OMAP3ISP_HIST_MAX_REGIONS))\r\nreturn -EINVAL;\r\nfor (c = 0; c < user_cfg->num_regions; c++) {\r\nif (user_cfg->region[c].h_start & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].h_end & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].v_start & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].v_end & ~ISPHIST_REG_START_END_MASK)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].h_start > user_cfg->region[c].h_end)\r\nreturn -EINVAL;\r\nif (user_cfg->region[c].v_start > user_cfg->region[c].v_end)\r\nreturn -EINVAL;\r\n}\r\nswitch (user_cfg->num_regions) {\r\ncase 1:\r\nif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_256)\r\nreturn -EINVAL;\r\nbreak;\r\ncase 2:\r\nif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_128)\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nif (user_cfg->hist_bins > OMAP3ISP_HIST_BINS_64)\r\nreturn -EINVAL;\r\nbreak;\r\n}\r\nbuf_size = hist_get_buf_size(user_cfg);\r\nif (buf_size > user_cfg->buf_size)\r\nuser_cfg->buf_size = buf_size;\r\nelse if (user_cfg->buf_size > OMAP3ISP_HIST_MAX_BUF_SIZE)\r\nuser_cfg->buf_size = OMAP3ISP_HIST_MAX_BUF_SIZE;\r\nreturn 0;\r\n}\r\nstatic int hist_comp_params(struct ispstat *hist,\r\nstruct omap3isp_hist_config *user_cfg)\r\n{\r\nstruct omap3isp_hist_config *cur_cfg = hist->priv;\r\nint c;\r\nif (cur_cfg->cfa != user_cfg->cfa)\r\nreturn 1;\r\nif (cur_cfg->num_acc_frames != user_cfg->num_acc_frames)\r\nreturn 1;\r\nif (cur_cfg->hist_bins != user_cfg->hist_bins)\r\nreturn 1;\r\nfor (c = 0; c < OMAP3ISP_HIST_MAX_WG; c++) {\r\nif (c == 3 && user_cfg->cfa == OMAP3ISP_HIST_CFA_FOVEONX3)\r\nbreak;\r\nelse if (cur_cfg->wg[c] != user_cfg->wg[c])\r\nreturn 1;\r\n}\r\nif (cur_cfg->num_regions != user_cfg->num_regions)\r\nreturn 1;\r\nfor (c = 0; c < user_cfg->num_regions; c++) {\r\nif (cur_cfg->region[c].h_start != user_cfg->region[c].h_start)\r\nreturn 1;\r\nif (cur_cfg->region[c].h_end != user_cfg->region[c].h_end)\r\nreturn 1;\r\nif (cur_cfg->region[c].v_start != user_cfg->region[c].v_start)\r\nreturn 1;\r\nif (cur_cfg->region[c].v_end != user_cfg->region[c].v_end)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hist_set_params(struct ispstat *hist, void *new_conf)\r\n{\r\nstruct omap3isp_hist_config *user_cfg = new_conf;\r\nstruct omap3isp_hist_config *cur_cfg = hist->priv;\r\nif (!hist->configured || hist_comp_params(hist, user_cfg)) {\r\nmemcpy(cur_cfg, user_cfg, sizeof(*user_cfg));\r\nif (user_cfg->num_acc_frames == 0)\r\nuser_cfg->num_acc_frames = 1;\r\nhist->inc_config++;\r\nhist->update = 1;\r\ncur_cfg->buf_size = hist_get_buf_size(cur_cfg);\r\n}\r\n}\r\nstatic long hist_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)\r\n{\r\nstruct ispstat *stat = v4l2_get_subdevdata(sd);\r\nswitch (cmd) {\r\ncase VIDIOC_OMAP3ISP_HIST_CFG:\r\nreturn omap3isp_stat_config(stat, arg);\r\ncase VIDIOC_OMAP3ISP_STAT_REQ:\r\nreturn omap3isp_stat_request_statistics(stat, arg);\r\ncase VIDIOC_OMAP3ISP_STAT_EN: {\r\nint *en = arg;\r\nreturn omap3isp_stat_enable(stat, !!*en);\r\n}\r\n}\r\nreturn -ENOIOCTLCMD;\r\n}\r\nint omap3isp_hist_init(struct isp_device *isp)\r\n{\r\nstruct ispstat *hist = &isp->isp_hist;\r\nstruct omap3isp_hist_config *hist_cfg;\r\nint ret = -1;\r\nhist_cfg = devm_kzalloc(isp->dev, sizeof(*hist_cfg), GFP_KERNEL);\r\nif (hist_cfg == NULL)\r\nreturn -ENOMEM;\r\nhist->isp = isp;\r\nif (HIST_CONFIG_DMA) {\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhist->dma_ch = dma_request_chan_by_mask(&mask);\r\nif (IS_ERR(hist->dma_ch)) {\r\nret = PTR_ERR(hist->dma_ch);\r\nif (ret == -EPROBE_DEFER)\r\nreturn ret;\r\nhist->dma_ch = NULL;\r\ndev_warn(isp->dev,\r\n"hist: DMA channel request failed, using PIO\n");\r\n} else {\r\ndev_dbg(isp->dev, "hist: using DMA channel %s\n",\r\ndma_chan_name(hist->dma_ch));\r\n}\r\n}\r\nhist->ops = &hist_ops;\r\nhist->priv = hist_cfg;\r\nhist->event_type = V4L2_EVENT_OMAP3ISP_HIST;\r\nret = omap3isp_stat_init(hist, "histogram", &hist_subdev_ops);\r\nif (ret) {\r\nif (hist->dma_ch)\r\ndma_release_channel(hist->dma_ch);\r\n}\r\nreturn ret;\r\n}\r\nvoid omap3isp_hist_cleanup(struct isp_device *isp)\r\n{\r\nstruct ispstat *hist = &isp->isp_hist;\r\nif (hist->dma_ch)\r\ndma_release_channel(hist->dma_ch);\r\nomap3isp_stat_cleanup(hist);\r\n}
