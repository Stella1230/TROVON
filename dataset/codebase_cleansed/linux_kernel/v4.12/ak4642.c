static int ak4642_lout_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMD:\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec, SG_SL2, LOPS, LOPS);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nmsleep(300);\r\nsnd_soc_update_bits(codec, SG_SL2, LOPS, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak4642_dai_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (is_play) {\r\nsnd_soc_write(codec, L_IVC, 0x91);\r\nsnd_soc_write(codec, R_IVC, 0x91);\r\n} else {\r\nsnd_soc_update_bits(codec, SG_SL1, PMMP | MGAIN0, PMMP | MGAIN0);\r\nsnd_soc_write(codec, TIMER, ZTM(0x3) | WTM(0x3));\r\nsnd_soc_write(codec, ALC_CTL1, ALC | LMTH0);\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMADL, PMADL);\r\nsnd_soc_update_bits(codec, PW_MGMT3, PMADR, PMADR);\r\n}\r\nreturn 0;\r\n}\r\nstatic void ak4642_dai_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint is_play = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nif (is_play) {\r\n} else {\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMADL, 0);\r\nsnd_soc_update_bits(codec, PW_MGMT3, PMADR, 0);\r\nsnd_soc_update_bits(codec, ALC_CTL1, ALC, 0);\r\n}\r\n}\r\nstatic int ak4642_dai_set_sysclk(struct snd_soc_dai *codec_dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct ak4642_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nu8 pll;\r\nint extended_freq = 0;\r\nswitch (freq) {\r\ncase 11289600:\r\npll = PLL2;\r\nbreak;\r\ncase 12288000:\r\npll = PLL2 | PLL0;\r\nbreak;\r\ncase 12000000:\r\npll = PLL2 | PLL1;\r\nbreak;\r\ncase 24000000:\r\npll = PLL2 | PLL1 | PLL0;\r\nbreak;\r\ncase 13500000:\r\npll = PLL3 | PLL2;\r\nbreak;\r\ncase 27000000:\r\npll = PLL3 | PLL2 | PLL0;\r\nbreak;\r\ncase 19200000:\r\npll = PLL3;\r\nextended_freq = 1;\r\nbreak;\r\ncase 13000000:\r\npll = PLL3 | PLL2 | PLL1;\r\nextended_freq = 1;\r\nbreak;\r\ncase 26000000:\r\npll = PLL3 | PLL2 | PLL1 | PLL0;\r\nextended_freq = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (extended_freq && !priv->drvdata->extended_frequencies)\r\nreturn -EINVAL;\r\nsnd_soc_update_bits(codec, MD_CTL1, PLL_MASK, pll);\r\nreturn 0;\r\n}\r\nstatic int ak4642_dai_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu8 data;\r\nu8 bcko;\r\ndata = MCKO | PMPLL;\r\nbcko = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ndata |= MS;\r\nbcko = BCKO_64;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, PW_MGMT2, MS | MCKO | PMPLL, data);\r\nsnd_soc_update_bits(codec, MD_CTL1, BCKO_MASK, bcko);\r\ndata = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ndata = LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ndata = I2S;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, MD_CTL1, DIF_MASK, data);\r\nreturn 0;\r\n}\r\nstatic int ak4642_set_mcko(struct snd_soc_codec *codec,\r\nu32 frequency)\r\n{\r\nu32 fs_list[] = {\r\n[0] = 8000,\r\n[1] = 12000,\r\n[2] = 16000,\r\n[3] = 24000,\r\n[4] = 7350,\r\n[5] = 11025,\r\n[6] = 14700,\r\n[7] = 22050,\r\n[10] = 32000,\r\n[11] = 48000,\r\n[14] = 29400,\r\n[15] = 44100,\r\n};\r\nu32 ps_list[] = {\r\n[0] = 256,\r\n[1] = 128,\r\n[2] = 64,\r\n[3] = 32\r\n};\r\nint ps, fs;\r\nfor (ps = 0; ps < ARRAY_SIZE(ps_list); ps++) {\r\nfor (fs = 0; fs < ARRAY_SIZE(fs_list); fs++) {\r\nif (frequency == ps_list[ps] * fs_list[fs]) {\r\nsnd_soc_write(codec, MD_CTL2,\r\nPSs(ps) | FSs(fs));\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak4642_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct ak4642_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nu32 rate = clk_get_rate(priv->mcko);\r\nif (!rate)\r\nrate = params_rate(params) * 256;\r\nreturn ak4642_set_mcko(codec, rate);\r\n}\r\nstatic int ak4642_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_OFF:\r\nsnd_soc_write(codec, PW_MGMT1, 0x00);\r\nbreak;\r\ndefault:\r\nsnd_soc_update_bits(codec, PW_MGMT1, PMVCM, PMVCM);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak4642_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct regmap *regmap = dev_get_regmap(codec->dev, NULL);\r\nregcache_cache_only(regmap, true);\r\nregcache_mark_dirty(regmap);\r\nreturn 0;\r\n}\r\nstatic int ak4642_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct regmap *regmap = dev_get_regmap(codec->dev, NULL);\r\nregcache_cache_only(regmap, false);\r\nregcache_sync(regmap);\r\nreturn 0;\r\n}\r\nstatic int ak4642_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct ak4642_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nif (priv->mcko)\r\nak4642_set_mcko(codec, clk_get_rate(priv->mcko));\r\nreturn 0;\r\n}\r\nstatic struct clk *ak4642_of_parse_mcko(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nstruct clk *clk;\r\nconst char *clk_name = np->name;\r\nconst char *parent_clk_name = NULL;\r\nu32 rate;\r\nif (of_property_read_u32(np, "clock-frequency", &rate))\r\nreturn NULL;\r\nif (of_property_read_bool(np, "clocks"))\r\nparent_clk_name = of_clk_get_parent_name(np, 0);\r\nof_property_read_string(np, "clock-output-names", &clk_name);\r\nclk = clk_register_fixed_rate(dev, clk_name, parent_clk_name, 0, rate);\r\nif (!IS_ERR(clk))\r\nof_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nreturn clk;\r\n}\r\nstatic int ak4642_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst struct ak4642_drvdata *drvdata = NULL;\r\nstruct regmap *regmap;\r\nstruct ak4642_priv *priv;\r\nstruct clk *mcko = NULL;\r\nif (np) {\r\nconst struct of_device_id *of_id;\r\nmcko = ak4642_of_parse_mcko(dev);\r\nif (IS_ERR(mcko))\r\nmcko = NULL;\r\nof_id = of_match_device(ak4642_of_match, dev);\r\nif (of_id)\r\ndrvdata = of_id->data;\r\n} else {\r\ndrvdata = (const struct ak4642_drvdata *)id->driver_data;\r\n}\r\nif (!drvdata) {\r\ndev_err(dev, "Unknown device type\n");\r\nreturn -EINVAL;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->drvdata = drvdata;\r\npriv->mcko = mcko;\r\ni2c_set_clientdata(i2c, priv);\r\nregmap = devm_regmap_init_i2c(i2c, drvdata->regmap_config);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nreturn snd_soc_register_codec(dev,\r\n&soc_codec_dev_ak4642, &ak4642_dai, 1);\r\n}\r\nstatic int ak4642_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
