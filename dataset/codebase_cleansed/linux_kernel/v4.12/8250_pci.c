static void moan_device(const char *str, struct pci_dev *dev)\r\n{\r\ndev_err(&dev->dev,\r\n"%s: %s\n"\r\n"Please send the output of lspci -vv, this\n"\r\n"message (0x%04x,0x%04x,0x%04x,0x%04x), the\n"\r\n"manufacturer and name of serial board or\n"\r\n"modem board to <linux-serial@vger.kernel.org>.\n",\r\npci_name(dev), str, dev->vendor, dev->device,\r\ndev->subsystem_vendor, dev->subsystem_device);\r\n}\r\nstatic int\r\nsetup_port(struct serial_private *priv, struct uart_8250_port *port,\r\nint bar, int offset, int regshift)\r\n{\r\nstruct pci_dev *dev = priv->dev;\r\nif (bar >= PCI_NUM_BAR_RESOURCES)\r\nreturn -EINVAL;\r\nif (pci_resource_flags(dev, bar) & IORESOURCE_MEM) {\r\nif (!pcim_iomap(dev, bar, 0) && !pcim_iomap_table(dev))\r\nreturn -ENOMEM;\r\nport->port.iotype = UPIO_MEM;\r\nport->port.iobase = 0;\r\nport->port.mapbase = pci_resource_start(dev, bar) + offset;\r\nport->port.membase = pcim_iomap_table(dev)[bar] + offset;\r\nport->port.regshift = regshift;\r\n} else {\r\nport->port.iotype = UPIO_PORT;\r\nport->port.iobase = pci_resource_start(dev, bar) + offset;\r\nport->port.mapbase = 0;\r\nport->port.membase = NULL;\r\nport->port.regshift = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addidata_apci7800_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar = 0, offset = board->first_offset;\r\nbar = FL_GET_BASE(board->flags);\r\nif (idx < 2) {\r\noffset += idx * board->uart_offset;\r\n} else if ((idx >= 2) && (idx < 4)) {\r\nbar += 1;\r\noffset += ((idx - 2) * board->uart_offset);\r\n} else if ((idx >= 4) && (idx < 6)) {\r\nbar += 2;\r\noffset += ((idx - 4) * board->uart_offset);\r\n} else if (idx >= 6) {\r\nbar += 3;\r\noffset += ((idx - 6) * board->uart_offset);\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int\r\nafavlab_setup(struct serial_private *priv, const struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset;\r\nbar = FL_GET_BASE(board->flags);\r\nif (idx < 4)\r\nbar += idx;\r\nelse {\r\nbar = 4;\r\noffset += (idx - 4) * board->uart_offset;\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_hp_diva_init(struct pci_dev *dev)\r\n{\r\nint rc = 0;\r\nswitch (dev->subsystem_device) {\r\ncase PCI_DEVICE_ID_HP_DIVA_TOSCA1:\r\ncase PCI_DEVICE_ID_HP_DIVA_HALFDOME:\r\ncase PCI_DEVICE_ID_HP_DIVA_KEYSTONE:\r\ncase PCI_DEVICE_ID_HP_DIVA_EVEREST:\r\nrc = 3;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_TOSCA2:\r\nrc = 2;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_MAESTRO:\r\nrc = 4;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_POWERBAR:\r\ncase PCI_DEVICE_ID_HP_DIVA_HURRICANE:\r\nrc = 1;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\npci_hp_diva_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int offset = board->first_offset;\r\nunsigned int bar = FL_GET_BASE(board->flags);\r\nswitch (priv->dev->subsystem_device) {\r\ncase PCI_DEVICE_ID_HP_DIVA_MAESTRO:\r\nif (idx == 3)\r\nidx++;\r\nbreak;\r\ncase PCI_DEVICE_ID_HP_DIVA_EVEREST:\r\nif (idx > 0)\r\nidx++;\r\nif (idx > 2)\r\nidx++;\r\nbreak;\r\n}\r\nif (idx > 2)\r\noffset = 0x18;\r\noffset += idx * board->uart_offset;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_inteli960ni_init(struct pci_dev *dev)\r\n{\r\nu32 oldval;\r\nif (!(dev->subsystem_device & 0x1000))\r\nreturn -ENODEV;\r\npci_read_config_dword(dev, 0x44, &oldval);\r\nif (oldval == 0x00001000L) {\r\ndev_dbg(&dev->dev, "Local i960 firmware missing\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_plx9050_init(struct pci_dev *dev)\r\n{\r\nu8 irq_config;\r\nvoid __iomem *p;\r\nif ((pci_resource_flags(dev, 0) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar 0", dev);\r\nreturn 0;\r\n}\r\nirq_config = 0x41;\r\nif (dev->vendor == PCI_VENDOR_ID_PANACOM ||\r\ndev->subsystem_vendor == PCI_SUBVENDOR_ID_EXSYS)\r\nirq_config = 0x43;\r\nif ((dev->vendor == PCI_VENDOR_ID_PLX) &&\r\n(dev->device == PCI_DEVICE_ID_PLX_ROMULUS))\r\nirq_config = 0x5b;\r\np = ioremap_nocache(pci_resource_start(dev, 0), 0x80);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwritel(irq_config, p + 0x4c);\r\nreadl(p + 0x4c);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic void pci_plx9050_exit(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\nif ((pci_resource_flags(dev, 0) & IORESOURCE_MEM) == 0)\r\nreturn;\r\np = ioremap_nocache(pci_resource_start(dev, 0), 0x80);\r\nif (p != NULL) {\r\nwritel(0, p + 0x4c);\r\nreadl(p + 0x4c);\r\niounmap(p);\r\n}\r\n}\r\nstatic void pci_ni8420_exit(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn;\r\n}\r\np = pci_ioremap_bar(dev, bar);\r\nif (p == NULL)\r\nreturn;\r\nwritel(readl(p + NI8420_INT_ENABLE_REG) & ~(NI8420_INT_ENABLE_BIT),\r\np + NI8420_INT_ENABLE_REG);\r\niounmap(p);\r\n}\r\nstatic void pci_ni8430_exit(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn;\r\n}\r\np = pci_ioremap_bar(dev, bar);\r\nif (p == NULL)\r\nreturn;\r\nwritel(MITE_LCIMR2_CLR_CPU_IE, p + MITE_LCIMR2);\r\niounmap(p);\r\n}\r\nstatic int\r\nsbs_setup(struct serial_private *priv, const struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset;\r\nbar = 0;\r\nif (idx < 4) {\r\noffset += idx * board->uart_offset;\r\n} else if (idx < 8) {\r\noffset += idx * board->uart_offset + 0xC00;\r\n} else\r\nreturn 1;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int sbs_init(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\np = pci_ioremap_bar(dev, 0);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwriteb(0x10, p + OCT_REG_CR_OFF);\r\nudelay(50);\r\nwriteb(0x0, p + OCT_REG_CR_OFF);\r\nwriteb(0x4, p + OCT_REG_CR_OFF);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic void sbs_exit(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\np = pci_ioremap_bar(dev, 0);\r\nif (p != NULL)\r\nwriteb(0, p + OCT_REG_CR_OFF);\r\niounmap(p);\r\n}\r\nstatic int pci_siig10x_init(struct pci_dev *dev)\r\n{\r\nu16 data;\r\nvoid __iomem *p;\r\nswitch (dev->device & 0xfff8) {\r\ncase PCI_DEVICE_ID_SIIG_1S_10x:\r\ndata = 0xffdf;\r\nbreak;\r\ncase PCI_DEVICE_ID_SIIG_2S_10x:\r\ndata = 0xf7ff;\r\nbreak;\r\ndefault:\r\ndata = 0xfffb;\r\nbreak;\r\n}\r\np = ioremap_nocache(pci_resource_start(dev, 0), 0x80);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwritew(readw(p + 0x28) & data, p + 0x28);\r\nreadw(p + 0x28);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int pci_siig20x_init(struct pci_dev *dev)\r\n{\r\nu8 data;\r\npci_read_config_byte(dev, 0x6f, &data);\r\npci_write_config_byte(dev, 0x6f, data & 0xef);\r\nif (((dev->device & 0xfffc) == PCI_DEVICE_ID_SIIG_2S_20x) ||\r\n((dev->device & 0xfffc) == PCI_DEVICE_ID_SIIG_2S1P_20x)) {\r\npci_read_config_byte(dev, 0x73, &data);\r\npci_write_config_byte(dev, 0x73, data & 0xef);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_siig_init(struct pci_dev *dev)\r\n{\r\nunsigned int type = dev->device & 0xff00;\r\nif (type == 0x1000)\r\nreturn pci_siig10x_init(dev);\r\nelse if (type == 0x2000)\r\nreturn pci_siig20x_init(dev);\r\nmoan_device("Unknown SIIG card", dev);\r\nreturn -ENODEV;\r\n}\r\nstatic int pci_siig_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar = FL_GET_BASE(board->flags) + idx, offset = 0;\r\nif (idx > 3) {\r\nbar = 4;\r\noffset = (idx - 4) * 8;\r\n}\r\nreturn setup_port(priv, port, bar, offset, 0);\r\n}\r\nstatic int pci_timedia_probe(struct pci_dev *dev)\r\n{\r\nif ((dev->subsystem_device & 0x00f0) >= 0x70) {\r\ndev_info(&dev->dev,\r\n"ignoring Timedia subdevice %04x for parport_serial\n",\r\ndev->subsystem_device);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_timedia_init(struct pci_dev *dev)\r\n{\r\nconst unsigned short *ids;\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(timedia_data); i++) {\r\nids = timedia_data[i].ids;\r\nfor (j = 0; ids[j]; j++)\r\nif (dev->subsystem_device == ids[j])\r\nreturn timedia_data[i].num;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\npci_timedia_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar = 0, offset = board->first_offset;\r\nswitch (idx) {\r\ncase 0:\r\nbar = 0;\r\nbreak;\r\ncase 1:\r\noffset = board->uart_offset;\r\nbar = 0;\r\nbreak;\r\ncase 2:\r\nbar = 1;\r\nbreak;\r\ncase 3:\r\noffset = board->uart_offset;\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nbar = idx - 2;\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int\r\ntitan_400l_800l_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset;\r\nswitch (idx) {\r\ncase 0:\r\nbar = 1;\r\nbreak;\r\ncase 1:\r\nbar = 2;\r\nbreak;\r\ndefault:\r\nbar = 4;\r\noffset = (idx - 2) * board->uart_offset;\r\n}\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_xircom_init(struct pci_dev *dev)\r\n{\r\nmsleep(100);\r\nreturn 0;\r\n}\r\nstatic int pci_ni8420_init(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn 0;\r\n}\r\np = pci_ioremap_bar(dev, bar);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\nwritel(readl(p + NI8420_INT_ENABLE_REG) | NI8420_INT_ENABLE_BIT,\r\np + NI8420_INT_ENABLE_REG);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int pci_ni8430_init(struct pci_dev *dev)\r\n{\r\nvoid __iomem *p;\r\nstruct pci_bus_region region;\r\nu32 device_window;\r\nunsigned int bar = 0;\r\nif ((pci_resource_flags(dev, bar) & IORESOURCE_MEM) == 0) {\r\nmoan_device("no memory in bar", dev);\r\nreturn 0;\r\n}\r\np = pci_ioremap_bar(dev, bar);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\npcibios_resource_to_bus(dev->bus, &region, &dev->resource[bar]);\r\ndevice_window = ((region.start + MITE_IOWBSR1_WIN_OFFSET) & 0xffffff00)\r\n| MITE_IOWBSR1_WENAB | MITE_IOWBSR1_WSIZE;\r\nwritel(device_window, p + MITE_IOWBSR1);\r\nwritel((readl(p + MITE_IOWCR1) & MITE_IOWCR1_RAMSEL_MASK),\r\np + MITE_IOWCR1);\r\nwritel(MITE_LCIMR1_IO_IE_0, p + MITE_LCIMR1);\r\nwritel(MITE_LCIMR2_SET_CPU_IE, p + MITE_LCIMR2);\r\niounmap(p);\r\nreturn 0;\r\n}\r\nstatic int\r\npci_ni8430_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nstruct pci_dev *dev = priv->dev;\r\nvoid __iomem *p;\r\nunsigned int bar, offset = board->first_offset;\r\nif (idx >= board->num_ports)\r\nreturn 1;\r\nbar = FL_GET_BASE(board->flags);\r\noffset += idx * board->uart_offset;\r\np = pci_ioremap_bar(dev, bar);\r\nif (!p)\r\nreturn -ENOMEM;\r\nwriteb(readb(p + offset + NI8430_PORTCON) | NI8430_PORTCON_TXVR_ENABLE,\r\np + offset + NI8430_PORTCON);\r\niounmap(p);\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_netmos_9900_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar;\r\nif ((priv->dev->device != PCI_DEVICE_ID_NETMOS_9865) &&\r\n(priv->dev->subsystem_device & 0xff00) == 0x3000) {\r\nbar = 3 * idx;\r\nreturn setup_port(priv, port, bar, 0, board->reg_shift);\r\n} else {\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\n}\r\nstatic int pci_netmos_9900_numports(struct pci_dev *dev)\r\n{\r\nunsigned int c = dev->class;\r\nunsigned int pi;\r\nunsigned short sub_serports;\r\npi = c & 0xff;\r\nif (pi == 2)\r\nreturn 1;\r\nif ((pi == 0) && (dev->device == PCI_DEVICE_ID_NETMOS_9900)) {\r\nsub_serports = dev->subsystem_device & 0xf;\r\nif (sub_serports > 0)\r\nreturn sub_serports;\r\ndev_err(&dev->dev,\r\n"NetMos/Mostech serial driver ignoring port on ambiguous config.\n");\r\nreturn 0;\r\n}\r\nmoan_device("unknown NetMos/Mostech program interface", dev);\r\nreturn 0;\r\n}\r\nstatic int pci_netmos_init(struct pci_dev *dev)\r\n{\r\nunsigned int num_serial = dev->subsystem_device & 0xf;\r\nif ((dev->device == PCI_DEVICE_ID_NETMOS_9901) ||\r\n(dev->device == PCI_DEVICE_ID_NETMOS_9865))\r\nreturn 0;\r\nif (dev->subsystem_vendor == PCI_VENDOR_ID_IBM &&\r\ndev->subsystem_device == 0x0299)\r\nreturn 0;\r\nswitch (dev->device) {\r\ncase PCI_DEVICE_ID_NETMOS_9904:\r\ncase PCI_DEVICE_ID_NETMOS_9912:\r\ncase PCI_DEVICE_ID_NETMOS_9922:\r\ncase PCI_DEVICE_ID_NETMOS_9900:\r\nnum_serial = pci_netmos_9900_numports(dev);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (num_serial == 0) {\r\nmoan_device("unknown NetMos/Mostech device", dev);\r\nreturn -ENODEV;\r\n}\r\nreturn num_serial;\r\n}\r\nstatic int pci_ite887x_init(struct pci_dev *dev)\r\n{\r\nstatic const short inta_addr[] = { 0x2a0, 0x2c0, 0x220, 0x240, 0x1e0,\r\n0x200, 0x280, 0 };\r\nint ret, i, type;\r\nstruct resource *iobase = NULL;\r\nu32 miscr, uartbar, ioport;\r\ni = 0;\r\nwhile (inta_addr[i] && iobase == NULL) {\r\niobase = request_region(inta_addr[i], ITE_887x_IOSIZE,\r\n"ite887x");\r\nif (iobase != NULL) {\r\npci_write_config_dword(dev, ITE_887x_POSIO0,\r\nITE_887x_POSIO_ENABLE | ITE_887x_POSIO_SPEED |\r\nITE_887x_POSIO_IOSIZE_32 | inta_addr[i]);\r\npci_write_config_dword(dev, ITE_887x_INTCBAR,\r\ninta_addr[i]);\r\nret = inb(inta_addr[i]);\r\nif (ret != 0xff) {\r\nbreak;\r\n}\r\nrelease_region(iobase->start, ITE_887x_IOSIZE);\r\niobase = NULL;\r\n}\r\ni++;\r\n}\r\nif (!inta_addr[i]) {\r\ndev_err(&dev->dev, "ite887x: could not find iobase\n");\r\nreturn -ENODEV;\r\n}\r\ntype = inb(iobase->start + 0x18) & 0x0f;\r\nswitch (type) {\r\ncase 0x2:\r\ncase 0xa:\r\nret = 0;\r\nbreak;\r\ncase 0xe:\r\nret = 2;\r\nbreak;\r\ncase 0x6:\r\nret = 1;\r\nbreak;\r\ncase 0x8:\r\nret = 2;\r\nbreak;\r\ndefault:\r\nmoan_device("Unknown ITE887x", dev);\r\nret = -ENODEV;\r\n}\r\nfor (i = 0; i < ret; i++) {\r\npci_read_config_dword(dev, ITE_887x_PS0BAR + (0x4 * (i + 1)),\r\n&ioport);\r\nioport &= 0x0000FF00;\r\npci_write_config_dword(dev, ITE_887x_POSIO0 + (0x4 * (i + 1)),\r\nITE_887x_POSIO_ENABLE | ITE_887x_POSIO_SPEED |\r\nITE_887x_POSIO_IOSIZE_8 | ioport);\r\npci_read_config_dword(dev, ITE_887x_UARTBAR, &uartbar);\r\nuartbar &= ~(0xffff << (16 * i));\r\nuartbar |= (ioport << (16 * i));\r\npci_write_config_dword(dev, ITE_887x_UARTBAR, uartbar);\r\npci_read_config_dword(dev, ITE_887x_MISCR, &miscr);\r\nmiscr &= ~(0xf << (12 - 4 * i));\r\nmiscr |= 1 << (23 - i);\r\npci_write_config_dword(dev, ITE_887x_MISCR, miscr);\r\n}\r\nif (ret <= 0) {\r\nrelease_region(iobase->start, ITE_887x_IOSIZE);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pci_ite887x_exit(struct pci_dev *dev)\r\n{\r\nu32 ioport;\r\npci_read_config_dword(dev, ITE_887x_POSIO0, &ioport);\r\nioport &= 0xffff;\r\nrelease_region(ioport, ITE_887x_IOSIZE);\r\n}\r\nstatic int pci_endrun_init(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\nunsigned long deviceID;\r\nunsigned int number_uarts = 0;\r\nif (dev->vendor == PCI_VENDOR_ID_ENDRUN &&\r\n(dev->device & 0xf000) != 0xe000)\r\nreturn 0;\r\np = pci_iomap(dev, 0, 5);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\ndeviceID = ioread32(p);\r\nif (deviceID == 0x07000200) {\r\nnumber_uarts = ioread8(p + 4);\r\ndev_dbg(&dev->dev,\r\n"%d ports detected on EndRun PCI Express device\n",\r\nnumber_uarts);\r\n}\r\npci_iounmap(dev, p);\r\nreturn number_uarts;\r\n}\r\nstatic int pci_oxsemi_tornado_init(struct pci_dev *dev)\r\n{\r\nu8 __iomem *p;\r\nunsigned long deviceID;\r\nunsigned int number_uarts = 0;\r\nif (dev->vendor == PCI_VENDOR_ID_OXSEMI &&\r\n(dev->device & 0xF000) != 0xC000)\r\nreturn 0;\r\np = pci_iomap(dev, 0, 5);\r\nif (p == NULL)\r\nreturn -ENOMEM;\r\ndeviceID = ioread32(p);\r\nif (deviceID == 0x07000200) {\r\nnumber_uarts = ioread8(p + 4);\r\ndev_dbg(&dev->dev,\r\n"%d ports detected on Oxford PCI Express device\n",\r\nnumber_uarts);\r\n}\r\npci_iounmap(dev, p);\r\nreturn number_uarts;\r\n}\r\nstatic int pci_asix_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->bugs |= UART_BUG_PARITY;\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic int pci_quatech_amcc(u16 devid)\r\n{\r\nstruct quatech_feature *qf = &quatech_cards[0];\r\nwhile (qf->devid) {\r\nif (qf->devid == devid)\r\nreturn qf->amcc;\r\nqf++;\r\n}\r\npr_err("quatech: unknown port type '0x%04X'.\n", devid);\r\nreturn 0;\r\n}\r\nstatic int pci_quatech_rqopr(struct uart_8250_port *port)\r\n{\r\nunsigned long base = port->port.iobase;\r\nu8 LCR, val;\r\nLCR = inb(base + UART_LCR);\r\noutb(0xBF, base + UART_LCR);\r\nval = inb(base + UART_SCR);\r\noutb(LCR, base + UART_LCR);\r\nreturn val;\r\n}\r\nstatic void pci_quatech_wqopr(struct uart_8250_port *port, u8 qopr)\r\n{\r\nunsigned long base = port->port.iobase;\r\nu8 LCR;\r\nLCR = inb(base + UART_LCR);\r\noutb(0xBF, base + UART_LCR);\r\ninb(base + UART_SCR);\r\noutb(qopr, base + UART_SCR);\r\noutb(LCR, base + UART_LCR);\r\n}\r\nstatic int pci_quatech_rqmcr(struct uart_8250_port *port)\r\n{\r\nunsigned long base = port->port.iobase;\r\nu8 LCR, val, qmcr;\r\nLCR = inb(base + UART_LCR);\r\noutb(0xBF, base + UART_LCR);\r\nval = inb(base + UART_SCR);\r\noutb(val | 0x10, base + UART_SCR);\r\nqmcr = inb(base + UART_MCR);\r\noutb(val, base + UART_SCR);\r\noutb(LCR, base + UART_LCR);\r\nreturn qmcr;\r\n}\r\nstatic void pci_quatech_wqmcr(struct uart_8250_port *port, u8 qmcr)\r\n{\r\nunsigned long base = port->port.iobase;\r\nu8 LCR, val;\r\nLCR = inb(base + UART_LCR);\r\noutb(0xBF, base + UART_LCR);\r\nval = inb(base + UART_SCR);\r\noutb(val | 0x10, base + UART_SCR);\r\noutb(qmcr, base + UART_MCR);\r\noutb(val, base + UART_SCR);\r\noutb(LCR, base + UART_LCR);\r\n}\r\nstatic int pci_quatech_has_qmcr(struct uart_8250_port *port)\r\n{\r\nunsigned long base = port->port.iobase;\r\nu8 LCR, val;\r\nLCR = inb(base + UART_LCR);\r\noutb(0xBF, base + UART_LCR);\r\nval = inb(base + UART_SCR);\r\nif (val & 0x20) {\r\noutb(0x80, UART_LCR);\r\nif (!(inb(UART_SCR) & 0x20)) {\r\noutb(LCR, base + UART_LCR);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_quatech_test(struct uart_8250_port *port)\r\n{\r\nu8 reg, qopr;\r\nqopr = pci_quatech_rqopr(port);\r\npci_quatech_wqopr(port, qopr & QPCR_TEST_FOR1);\r\nreg = pci_quatech_rqopr(port) & 0xC0;\r\nif (reg != QPCR_TEST_GET1)\r\nreturn -EINVAL;\r\npci_quatech_wqopr(port, (qopr & QPCR_TEST_FOR1)|QPCR_TEST_FOR2);\r\nreg = pci_quatech_rqopr(port) & 0xC0;\r\nif (reg != QPCR_TEST_GET2)\r\nreturn -EINVAL;\r\npci_quatech_wqopr(port, (qopr & QPCR_TEST_FOR1)|QPCR_TEST_FOR3);\r\nreg = pci_quatech_rqopr(port) & 0xC0;\r\nif (reg != QPCR_TEST_GET3)\r\nreturn -EINVAL;\r\npci_quatech_wqopr(port, (qopr & QPCR_TEST_FOR1)|QPCR_TEST_FOR4);\r\nreg = pci_quatech_rqopr(port) & 0xC0;\r\nif (reg != QPCR_TEST_GET4)\r\nreturn -EINVAL;\r\npci_quatech_wqopr(port, qopr);\r\nreturn 0;\r\n}\r\nstatic int pci_quatech_clock(struct uart_8250_port *port)\r\n{\r\nu8 qopr, reg, set;\r\nunsigned long clock;\r\nif (pci_quatech_test(port) < 0)\r\nreturn 1843200;\r\nqopr = pci_quatech_rqopr(port);\r\npci_quatech_wqopr(port, qopr & ~QOPR_CLOCK_X8);\r\nreg = pci_quatech_rqopr(port);\r\nif (reg & QOPR_CLOCK_X8) {\r\nclock = 1843200;\r\ngoto out;\r\n}\r\npci_quatech_wqopr(port, qopr | QOPR_CLOCK_X8);\r\nreg = pci_quatech_rqopr(port);\r\nif (!(reg & QOPR_CLOCK_X8)) {\r\nclock = 1843200;\r\ngoto out;\r\n}\r\nreg &= QOPR_CLOCK_X8;\r\nif (reg == QOPR_CLOCK_X2) {\r\nclock = 3685400;\r\nset = QOPR_CLOCK_X2;\r\n} else if (reg == QOPR_CLOCK_X4) {\r\nclock = 7372800;\r\nset = QOPR_CLOCK_X4;\r\n} else if (reg == QOPR_CLOCK_X8) {\r\nclock = 14745600;\r\nset = QOPR_CLOCK_X8;\r\n} else {\r\nclock = 1843200;\r\nset = QOPR_CLOCK_X1;\r\n}\r\nqopr &= ~QOPR_CLOCK_RATE_MASK;\r\nqopr |= set;\r\nout:\r\npci_quatech_wqopr(port, qopr);\r\nreturn clock;\r\n}\r\nstatic int pci_quatech_rs422(struct uart_8250_port *port)\r\n{\r\nu8 qmcr;\r\nint rs422 = 0;\r\nif (!pci_quatech_has_qmcr(port))\r\nreturn 0;\r\nqmcr = pci_quatech_rqmcr(port);\r\npci_quatech_wqmcr(port, 0xFF);\r\nif (pci_quatech_rqmcr(port))\r\nrs422 = 1;\r\npci_quatech_wqmcr(port, qmcr);\r\nreturn rs422;\r\n}\r\nstatic int pci_quatech_init(struct pci_dev *dev)\r\n{\r\nif (pci_quatech_amcc(dev->device)) {\r\nunsigned long base = pci_resource_start(dev, 0);\r\nif (base) {\r\nu32 tmp;\r\noutl(inl(base + 0x38) | 0x00002000, base + 0x38);\r\ntmp = inl(base + 0x3c);\r\noutl(tmp | 0x01000000, base + 0x3c);\r\noutl(tmp &= ~0x01000000, base + 0x3c);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pci_quatech_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->port.iobase = pci_resource_start(priv->dev, FL_GET_BASE(board->flags));\r\nport->port.uartclk = pci_quatech_clock(port);\r\nif (pci_quatech_rs422(port))\r\npr_warn("quatech: software control of RS422 features not currently supported.\n");\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic void pci_quatech_exit(struct pci_dev *dev)\r\n{\r\n}\r\nstatic int pci_default_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset, maxnr;\r\nbar = FL_GET_BASE(board->flags);\r\nif (board->flags & FL_BASE_BARS)\r\nbar += idx;\r\nelse\r\noffset += idx * board->uart_offset;\r\nmaxnr = (pci_resource_len(priv->dev, bar) - board->first_offset) >>\r\n(board->reg_shift + 3);\r\nif (board->flags & FL_REGION_SZ_CAP && idx >= maxnr)\r\nreturn 1;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int pci_pericom_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nunsigned int bar, offset = board->first_offset, maxnr;\r\nbar = FL_GET_BASE(board->flags);\r\nif (board->flags & FL_BASE_BARS)\r\nbar += idx;\r\nelse\r\noffset += idx * board->uart_offset;\r\nif (idx==3)\r\noffset = 0x38;\r\nmaxnr = (pci_resource_len(priv->dev, bar) - board->first_offset) >>\r\n(board->reg_shift + 3);\r\nif (board->flags & FL_REGION_SZ_CAP && idx >= maxnr)\r\nreturn 1;\r\nreturn setup_port(priv, port, bar, offset, board->reg_shift);\r\n}\r\nstatic int\r\nce4100_serial_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nint ret;\r\nret = setup_port(priv, port, idx, 0, board->reg_shift);\r\nport->port.iotype = UPIO_MEM32;\r\nport->port.type = PORT_XSCALE;\r\nport->port.flags = (port->port.flags | UPF_FIXED_PORT | UPF_FIXED_TYPE);\r\nport->port.regshift = 2;\r\nreturn ret;\r\n}\r\nstatic int\r\npci_omegapci_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nreturn setup_port(priv, port, 2, idx * 8, 0);\r\n}\r\nstatic int\r\npci_brcm_trumanage_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nint ret = pci_default_setup(priv, board, port, idx);\r\nport->port.type = PORT_BRCM_TRUMANAGE;\r\nport->port.flags = (port->port.flags | UPF_FIXED_PORT | UPF_FIXED_TYPE);\r\nreturn ret;\r\n}\r\nstatic int pci_fintek_rs485_config(struct uart_port *port,\r\nstruct serial_rs485 *rs485)\r\n{\r\nstruct pci_dev *pci_dev = to_pci_dev(port->dev);\r\nu8 setting;\r\nu8 *index = (u8 *) port->private_data;\r\npci_read_config_byte(pci_dev, 0x40 + 8 * *index + 7, &setting);\r\nif (!rs485)\r\nrs485 = &port->rs485;\r\nelse if (rs485->flags & SER_RS485_ENABLED)\r\nmemset(rs485->padding, 0, sizeof(rs485->padding));\r\nelse\r\nmemset(rs485, 0, sizeof(*rs485));\r\nrs485->flags &= SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND;\r\nif (rs485->flags & SER_RS485_ENABLED) {\r\nsetting |= FINTEK_RTS_CONTROL_BY_HW;\r\nif (rs485->flags & SER_RS485_RTS_ON_SEND) {\r\nsetting &= ~FINTEK_RTS_INVERT;\r\n} else {\r\nsetting |= FINTEK_RTS_INVERT;\r\n}\r\nrs485->delay_rts_after_send = 0;\r\nrs485->delay_rts_before_send = 0;\r\n} else {\r\nsetting &= ~(FINTEK_RTS_CONTROL_BY_HW | FINTEK_RTS_INVERT);\r\n}\r\npci_write_config_byte(pci_dev, 0x40 + 8 * *index + 7, setting);\r\nif (rs485 != &port->rs485)\r\nport->rs485 = *rs485;\r\nreturn 0;\r\n}\r\nstatic int pci_fintek_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nstruct pci_dev *pdev = priv->dev;\r\nu8 *data;\r\nu8 config_base;\r\nu16 iobase;\r\nconfig_base = 0x40 + 0x08 * idx;\r\npci_read_config_word(pdev, config_base + 4, &iobase);\r\ndev_dbg(&pdev->dev, "%s: idx=%d iobase=0x%x", __func__, idx, iobase);\r\nport->port.iotype = UPIO_PORT;\r\nport->port.iobase = iobase;\r\nport->port.rs485_config = pci_fintek_rs485_config;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(u8), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\n*data = idx;\r\nport->port.private_data = data;\r\nreturn 0;\r\n}\r\nstatic int pci_fintek_init(struct pci_dev *dev)\r\n{\r\nunsigned long iobase;\r\nu32 max_port, i;\r\nresource_size_t bar_data[3];\r\nu8 config_base;\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\nstruct uart_8250_port *port;\r\nif (!(pci_resource_flags(dev, 5) & IORESOURCE_IO) ||\r\n!(pci_resource_flags(dev, 4) & IORESOURCE_IO) ||\r\n!(pci_resource_flags(dev, 3) & IORESOURCE_IO))\r\nreturn -ENODEV;\r\nswitch (dev->device) {\r\ncase 0x1104:\r\ncase 0x1108:\r\nmax_port = dev->device & 0xff;\r\nbreak;\r\ncase 0x1112:\r\nmax_port = 12;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbar_data[0] = pci_resource_start(dev, 5);\r\nbar_data[1] = pci_resource_start(dev, 4);\r\nbar_data[2] = pci_resource_start(dev, 3);\r\nfor (i = 0; i < max_port; ++i) {\r\nconfig_base = 0x40 + 0x08 * i;\r\niobase = (bar_data[i / 4] & 0xffffffe0) + (i % 4) * 8;\r\npci_write_config_byte(dev, config_base + 0x00, 0x01);\r\npci_write_config_byte(dev, config_base + 0x01, 0x33);\r\npci_write_config_byte(dev, config_base + 0x04,\r\n(u8)(iobase & 0xff));\r\npci_write_config_byte(dev, config_base + 0x05,\r\n(u8)((iobase & 0xff00) >> 8));\r\npci_write_config_byte(dev, config_base + 0x06, dev->irq);\r\nif (priv) {\r\nport = serial8250_get_port(priv->line[i]);\r\npci_fintek_rs485_config(&port->port, NULL);\r\n} else {\r\npci_write_config_byte(dev, config_base + 0x07, 0x01);\r\n}\r\n}\r\nreturn max_port;\r\n}\r\nstatic int skip_tx_en_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->port.flags |= UPF_NO_TXEN_TEST;\r\ndev_dbg(&priv->dev->dev,\r\n"serial8250: skipping TxEn test for device [%04x:%04x] subsystem [%04x:%04x]\n",\r\npriv->dev->vendor, priv->dev->device,\r\npriv->dev->subsystem_vendor, priv->dev->subsystem_device);\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic void kt_handle_break(struct uart_port *p)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(p);\r\nserial8250_clear_and_reinit_fifos(up);\r\n}\r\nstatic unsigned int kt_serial_in(struct uart_port *p, int offset)\r\n{\r\nstruct uart_8250_port *up = up_to_u8250p(p);\r\nunsigned int val;\r\nval = inb(p->iobase + offset);\r\nif (offset == UART_IER) {\r\nif (val == 0)\r\nval = up->ier;\r\n}\r\nreturn val;\r\n}\r\nstatic int kt_serial_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->port.flags |= UPF_BUG_THRE;\r\nport->port.serial_in = kt_serial_in;\r\nport->port.handle_break = kt_handle_break;\r\nreturn skip_tx_en_setup(priv, board, port, idx);\r\n}\r\nstatic int pci_eg20t_init(struct pci_dev *dev)\r\n{\r\n#if defined(CONFIG_SERIAL_PCH_UART) || defined(CONFIG_SERIAL_PCH_UART_MODULE)\r\nreturn -ENODEV;\r\n#else\r\nreturn 0;\r\n#endif\r\n}\r\nstatic int\r\npci_wch_ch353_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->port.flags |= UPF_FIXED_TYPE;\r\nport->port.type = PORT_16550A;\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic int\r\npci_wch_ch355_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->port.flags |= UPF_FIXED_TYPE;\r\nport->port.type = PORT_16550A;\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic int\r\npci_wch_ch38x_setup(struct serial_private *priv,\r\nconst struct pciserial_board *board,\r\nstruct uart_8250_port *port, int idx)\r\n{\r\nport->port.flags |= UPF_FIXED_TYPE;\r\nport->port.type = PORT_16850;\r\nreturn pci_default_setup(priv, board, port, idx);\r\n}\r\nstatic inline int quirk_id_matches(u32 quirk_id, u32 dev_id)\r\n{\r\nreturn quirk_id == PCI_ANY_ID || quirk_id == dev_id;\r\n}\r\nstatic struct pci_serial_quirk *find_quirk(struct pci_dev *dev)\r\n{\r\nstruct pci_serial_quirk *quirk;\r\nfor (quirk = pci_serial_quirks; ; quirk++)\r\nif (quirk_id_matches(quirk->vendor, dev->vendor) &&\r\nquirk_id_matches(quirk->device, dev->device) &&\r\nquirk_id_matches(quirk->subvendor, dev->subsystem_vendor) &&\r\nquirk_id_matches(quirk->subdevice, dev->subsystem_device))\r\nbreak;\r\nreturn quirk;\r\n}\r\nstatic inline int get_pci_irq(struct pci_dev *dev,\r\nconst struct pciserial_board *board)\r\n{\r\nif (board->flags & FL_NOIRQ)\r\nreturn 0;\r\nelse\r\nreturn dev->irq;\r\n}\r\nstatic int\r\nserial_pci_guess_board(struct pci_dev *dev, struct pciserial_board *board)\r\n{\r\nconst struct pci_device_id *bldev;\r\nint num_iomem, num_port, first_port = -1, i;\r\nif ((((dev->class >> 8) != PCI_CLASS_COMMUNICATION_SERIAL) &&\r\n((dev->class >> 8) != PCI_CLASS_COMMUNICATION_MODEM)) ||\r\n(dev->class & 0xff) > 6)\r\nreturn -ENODEV;\r\nfor (bldev = blacklist;\r\nbldev < blacklist + ARRAY_SIZE(blacklist);\r\nbldev++) {\r\nif (dev->vendor == bldev->vendor &&\r\ndev->device == bldev->device)\r\nreturn -ENODEV;\r\n}\r\nnum_iomem = num_port = 0;\r\nfor (i = 0; i < PCI_NUM_BAR_RESOURCES; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_IO) {\r\nnum_port++;\r\nif (first_port == -1)\r\nfirst_port = i;\r\n}\r\nif (pci_resource_flags(dev, i) & IORESOURCE_MEM)\r\nnum_iomem++;\r\n}\r\nif (num_iomem <= 1 && num_port == 1) {\r\nboard->flags = first_port;\r\nboard->num_ports = pci_resource_len(dev, first_port) / 8;\r\nreturn 0;\r\n}\r\nfirst_port = -1;\r\nnum_port = 0;\r\nfor (i = 0; i < PCI_NUM_BAR_RESOURCES; i++) {\r\nif (pci_resource_flags(dev, i) & IORESOURCE_IO &&\r\npci_resource_len(dev, i) == 8 &&\r\n(first_port == -1 || (first_port + num_port) == i)) {\r\nnum_port++;\r\nif (first_port == -1)\r\nfirst_port = i;\r\n}\r\n}\r\nif (num_port > 1) {\r\nboard->flags = first_port | FL_BASE_BARS;\r\nboard->num_ports = num_port;\r\nreturn 0;\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic inline int\r\nserial_pci_matches(const struct pciserial_board *board,\r\nconst struct pciserial_board *guessed)\r\n{\r\nreturn\r\nboard->num_ports == guessed->num_ports &&\r\nboard->base_baud == guessed->base_baud &&\r\nboard->uart_offset == guessed->uart_offset &&\r\nboard->reg_shift == guessed->reg_shift &&\r\nboard->first_offset == guessed->first_offset;\r\n}\r\nstruct serial_private *\r\npciserial_init_ports(struct pci_dev *dev, const struct pciserial_board *board)\r\n{\r\nstruct uart_8250_port uart;\r\nstruct serial_private *priv;\r\nstruct pci_serial_quirk *quirk;\r\nint rc, nr_ports, i;\r\nnr_ports = board->num_ports;\r\nquirk = find_quirk(dev);\r\nif (quirk->init) {\r\nrc = quirk->init(dev);\r\nif (rc < 0) {\r\npriv = ERR_PTR(rc);\r\ngoto err_out;\r\n}\r\nif (rc)\r\nnr_ports = rc;\r\n}\r\npriv = kzalloc(sizeof(struct serial_private) +\r\nsizeof(unsigned int) * nr_ports,\r\nGFP_KERNEL);\r\nif (!priv) {\r\npriv = ERR_PTR(-ENOMEM);\r\ngoto err_deinit;\r\n}\r\npriv->dev = dev;\r\npriv->quirk = quirk;\r\nmemset(&uart, 0, sizeof(uart));\r\nuart.port.flags = UPF_SKIP_TEST | UPF_BOOT_AUTOCONF | UPF_SHARE_IRQ;\r\nuart.port.uartclk = board->base_baud * 16;\r\nuart.port.irq = get_pci_irq(dev, board);\r\nuart.port.dev = &dev->dev;\r\nfor (i = 0; i < nr_ports; i++) {\r\nif (quirk->setup(priv, board, &uart, i))\r\nbreak;\r\ndev_dbg(&dev->dev, "Setup PCI port: port %lx, irq %d, type %d\n",\r\nuart.port.iobase, uart.port.irq, uart.port.iotype);\r\npriv->line[i] = serial8250_register_8250_port(&uart);\r\nif (priv->line[i] < 0) {\r\ndev_err(&dev->dev,\r\n"Couldn't register serial port %lx, irq %d, type %d, error %d\n",\r\nuart.port.iobase, uart.port.irq,\r\nuart.port.iotype, priv->line[i]);\r\nbreak;\r\n}\r\n}\r\npriv->nr = i;\r\npriv->board = board;\r\nreturn priv;\r\nerr_deinit:\r\nif (quirk->exit)\r\nquirk->exit(dev);\r\nerr_out:\r\nreturn priv;\r\n}\r\nstatic void pciserial_detach_ports(struct serial_private *priv)\r\n{\r\nstruct pci_serial_quirk *quirk;\r\nint i;\r\nfor (i = 0; i < priv->nr; i++)\r\nserial8250_unregister_port(priv->line[i]);\r\nquirk = find_quirk(priv->dev);\r\nif (quirk->exit)\r\nquirk->exit(priv->dev);\r\n}\r\nvoid pciserial_remove_ports(struct serial_private *priv)\r\n{\r\npciserial_detach_ports(priv);\r\nkfree(priv);\r\n}\r\nvoid pciserial_suspend_ports(struct serial_private *priv)\r\n{\r\nint i;\r\nfor (i = 0; i < priv->nr; i++)\r\nif (priv->line[i] >= 0)\r\nserial8250_suspend_port(priv->line[i]);\r\nif (priv->quirk->exit)\r\npriv->quirk->exit(priv->dev);\r\n}\r\nvoid pciserial_resume_ports(struct serial_private *priv)\r\n{\r\nint i;\r\nif (priv->quirk->init)\r\npriv->quirk->init(priv->dev);\r\nfor (i = 0; i < priv->nr; i++)\r\nif (priv->line[i] >= 0)\r\nserial8250_resume_port(priv->line[i]);\r\n}\r\nstatic int\r\npciserial_init_one(struct pci_dev *dev, const struct pci_device_id *ent)\r\n{\r\nstruct pci_serial_quirk *quirk;\r\nstruct serial_private *priv;\r\nconst struct pciserial_board *board;\r\nstruct pciserial_board tmp;\r\nint rc;\r\nquirk = find_quirk(dev);\r\nif (quirk->probe) {\r\nrc = quirk->probe(dev);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (ent->driver_data >= ARRAY_SIZE(pci_boards)) {\r\ndev_err(&dev->dev, "invalid driver_data: %ld\n",\r\nent->driver_data);\r\nreturn -EINVAL;\r\n}\r\nboard = &pci_boards[ent->driver_data];\r\nrc = pcim_enable_device(dev);\r\npci_save_state(dev);\r\nif (rc)\r\nreturn rc;\r\nif (ent->driver_data == pbn_default) {\r\nmemcpy(&tmp, board, sizeof(struct pciserial_board));\r\nboard = &tmp;\r\nrc = serial_pci_guess_board(dev, &tmp);\r\nif (rc)\r\nreturn rc;\r\n} else {\r\nmemcpy(&tmp, &pci_boards[pbn_default],\r\nsizeof(struct pciserial_board));\r\nrc = serial_pci_guess_board(dev, &tmp);\r\nif (rc == 0 && serial_pci_matches(board, &tmp))\r\nmoan_device("Redundant entry in serial pci_table.",\r\ndev);\r\n}\r\npriv = pciserial_init_ports(dev, board);\r\nif (IS_ERR(priv))\r\nreturn PTR_ERR(priv);\r\npci_set_drvdata(dev, priv);\r\nreturn 0;\r\n}\r\nstatic void pciserial_remove_one(struct pci_dev *dev)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\npciserial_remove_ports(priv);\r\n}\r\nstatic int pciserial_suspend_one(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct serial_private *priv = pci_get_drvdata(pdev);\r\nif (priv)\r\npciserial_suspend_ports(priv);\r\nreturn 0;\r\n}\r\nstatic int pciserial_resume_one(struct device *dev)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct serial_private *priv = pci_get_drvdata(pdev);\r\nint err;\r\nif (priv) {\r\nerr = pci_enable_device(pdev);\r\nif (err)\r\ndev_err(dev, "Unable to re-enable ports, trying to continue.\n");\r\npciserial_resume_ports(priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic pci_ers_result_t serial8250_io_error_detected(struct pci_dev *dev,\r\npci_channel_state_t state)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\nif (state == pci_channel_io_perm_failure)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\nif (priv)\r\npciserial_detach_ports(priv);\r\npci_disable_device(dev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t serial8250_io_slot_reset(struct pci_dev *dev)\r\n{\r\nint rc;\r\nrc = pci_enable_device(dev);\r\nif (rc)\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\npci_restore_state(dev);\r\npci_save_state(dev);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void serial8250_io_resume(struct pci_dev *dev)\r\n{\r\nstruct serial_private *priv = pci_get_drvdata(dev);\r\nstruct serial_private *new;\r\nif (!priv)\r\nreturn;\r\nnew = pciserial_init_ports(dev, priv->board);\r\nif (!IS_ERR(new)) {\r\npci_set_drvdata(dev, new);\r\nkfree(priv);\r\n}\r\n}
