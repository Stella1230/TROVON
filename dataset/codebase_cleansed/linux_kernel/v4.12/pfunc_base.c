static irqreturn_t macio_gpio_irq(int irq, void *data)\r\n{\r\npmf_do_irq(data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int macio_do_gpio_irq_enable(struct pmf_function *func)\r\n{\r\nunsigned int irq = irq_of_parse_and_map(func->node, 0);\r\nif (!irq)\r\nreturn -EINVAL;\r\nreturn request_irq(irq, macio_gpio_irq, 0, func->node->name, func);\r\n}\r\nstatic int macio_do_gpio_irq_disable(struct pmf_function *func)\r\n{\r\nunsigned int irq = irq_of_parse_and_map(func->node, 0);\r\nif (!irq)\r\nreturn -EINVAL;\r\nfree_irq(irq, func);\r\nreturn 0;\r\n}\r\nstatic int macio_do_gpio_write(PMF_STD_ARGS, u8 value, u8 mask)\r\n{\r\nu8 __iomem *addr = (u8 __iomem *)func->driver_data;\r\nunsigned long flags;\r\nu8 tmp;\r\nif (args && args->count && !args->u[0].v)\r\nvalue = ~value;\r\nraw_spin_lock_irqsave(&feature_lock, flags);\r\ntmp = readb(addr);\r\ntmp = (tmp & ~mask) | (value & mask);\r\nDBG("Do write 0x%02x to GPIO %s (%p)\n",\r\ntmp, func->node->full_name, addr);\r\nwriteb(tmp, addr);\r\nraw_spin_unlock_irqrestore(&feature_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int macio_do_gpio_read(PMF_STD_ARGS, u8 mask, int rshift, u8 xor)\r\n{\r\nu8 __iomem *addr = (u8 __iomem *)func->driver_data;\r\nu32 value;\r\nif (args == NULL || args->count == 0 || args->u[0].p == NULL)\r\nreturn -EINVAL;\r\nvalue = readb(addr);\r\n*args->u[0].p = ((value & mask) >> rshift) ^ xor;\r\nreturn 0;\r\n}\r\nstatic int macio_do_delay(PMF_STD_ARGS, u32 duration)\r\n{\r\nmsleep((duration + 999) / 1000);\r\nreturn 0;\r\n}\r\nstatic void macio_gpio_init_one(struct macio_chip *macio)\r\n{\r\nstruct device_node *gparent, *gp;\r\nfor (gparent = NULL;\r\n(gparent = of_get_next_child(macio->of_node, gparent)) != NULL;)\r\nif (strcmp(gparent->name, "gpio") == 0)\r\nbreak;\r\nif (gparent == NULL)\r\nreturn;\r\nDBG("Installing GPIO functions for macio %s\n",\r\nmacio->of_node->full_name);\r\nfor (gp = NULL; (gp = of_get_next_child(gparent, gp)) != NULL;) {\r\nconst u32 *reg = of_get_property(gp, "reg", NULL);\r\nunsigned long offset;\r\nif (reg == NULL)\r\ncontinue;\r\noffset = *reg;\r\nif (offset < 0x50)\r\noffset += 0x50;\r\noffset += (unsigned long)macio->base;\r\npmf_register_driver(gp, &macio_gpio_handlers, (void *)offset);\r\n}\r\nDBG("Calling initial GPIO functions for macio %s\n",\r\nmacio->of_node->full_name);\r\nfor (gp = NULL; (gp = of_get_next_child(gparent, gp)) != NULL;)\r\npmf_do_functions(gp, NULL, 0, PMF_FLAGS_ON_INIT, NULL);\r\n}\r\nstatic int macio_do_write_reg32(PMF_STD_ARGS, u32 offset, u32 value, u32 mask)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&feature_lock, flags);\r\nMACIO_OUT32(offset, (MACIO_IN32(offset) & ~mask) | (value & mask));\r\nraw_spin_unlock_irqrestore(&feature_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int macio_do_read_reg32(PMF_STD_ARGS, u32 offset)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nif (args == NULL || args->count == 0 || args->u[0].p == NULL)\r\nreturn -EINVAL;\r\n*args->u[0].p = MACIO_IN32(offset);\r\nreturn 0;\r\n}\r\nstatic int macio_do_write_reg8(PMF_STD_ARGS, u32 offset, u8 value, u8 mask)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&feature_lock, flags);\r\nMACIO_OUT8(offset, (MACIO_IN8(offset) & ~mask) | (value & mask));\r\nraw_spin_unlock_irqrestore(&feature_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int macio_do_read_reg8(PMF_STD_ARGS, u32 offset)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nif (args == NULL || args->count == 0 || args->u[0].p == NULL)\r\nreturn -EINVAL;\r\n*((u8 *)(args->u[0].p)) = MACIO_IN8(offset);\r\nreturn 0;\r\n}\r\nstatic int macio_do_read_reg32_msrx(PMF_STD_ARGS, u32 offset, u32 mask,\r\nu32 shift, u32 xor)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nif (args == NULL || args->count == 0 || args->u[0].p == NULL)\r\nreturn -EINVAL;\r\n*args->u[0].p = ((MACIO_IN32(offset) & mask) >> shift) ^ xor;\r\nreturn 0;\r\n}\r\nstatic int macio_do_read_reg8_msrx(PMF_STD_ARGS, u32 offset, u32 mask,\r\nu32 shift, u32 xor)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nif (args == NULL || args->count == 0 || args->u[0].p == NULL)\r\nreturn -EINVAL;\r\n*((u8 *)(args->u[0].p)) = ((MACIO_IN8(offset) & mask) >> shift) ^ xor;\r\nreturn 0;\r\n}\r\nstatic int macio_do_write_reg32_slm(PMF_STD_ARGS, u32 offset, u32 shift,\r\nu32 mask)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nunsigned long flags;\r\nu32 tmp, val;\r\nif (args == NULL || args->count == 0)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&feature_lock, flags);\r\ntmp = MACIO_IN32(offset);\r\nval = args->u[0].v << shift;\r\ntmp = (tmp & ~mask) | (val & mask);\r\nMACIO_OUT32(offset, tmp);\r\nraw_spin_unlock_irqrestore(&feature_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int macio_do_write_reg8_slm(PMF_STD_ARGS, u32 offset, u32 shift,\r\nu32 mask)\r\n{\r\nstruct macio_chip *macio = func->driver_data;\r\nunsigned long flags;\r\nu32 tmp, val;\r\nif (args == NULL || args->count == 0)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&feature_lock, flags);\r\ntmp = MACIO_IN8(offset);\r\nval = args->u[0].v << shift;\r\ntmp = (tmp & ~mask) | (val & mask);\r\nMACIO_OUT8(offset, tmp);\r\nraw_spin_unlock_irqrestore(&feature_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void macio_mmio_init_one(struct macio_chip *macio)\r\n{\r\nDBG("Installing MMIO functions for macio %s\n",\r\nmacio->of_node->full_name);\r\npmf_register_driver(macio->of_node, &macio_mmio_handlers, macio);\r\n}\r\nstatic int unin_do_write_reg32(PMF_STD_ARGS, u32 offset, u32 value, u32 mask)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&feature_lock, flags);\r\nUN_OUT(offset, (UN_IN(offset) & ~mask) | (value & mask));\r\nraw_spin_unlock_irqrestore(&feature_lock, flags);\r\nreturn 0;\r\n}\r\nstatic void uninorth_install_pfunc(void)\r\n{\r\nstruct device_node *np;\r\nDBG("Installing functions for UniN %s\n",\r\nuninorth_node->full_name);\r\npmf_register_driver(uninorth_node, &unin_mmio_handlers, NULL);\r\npmf_do_functions(uninorth_node, NULL, 0, PMF_FLAGS_ON_INIT, NULL);\r\nfor (np = NULL; (np = of_get_next_child(uninorth_node, np)) != NULL;)\r\nif (strcmp(np->name, "hw-clock") == 0) {\r\nunin_hwclock = np;\r\nbreak;\r\n}\r\nif (unin_hwclock) {\r\nDBG("Installing functions for UniN clock %s\n",\r\nunin_hwclock->full_name);\r\npmf_register_driver(unin_hwclock, &unin_mmio_handlers, NULL);\r\npmf_do_functions(unin_hwclock, NULL, 0, PMF_FLAGS_ON_INIT,\r\nNULL);\r\n}\r\n}\r\nint __init pmac_pfunc_base_install(void)\r\n{\r\nstatic int pfbase_inited;\r\nint i;\r\nif (pfbase_inited)\r\nreturn 0;\r\npfbase_inited = 1;\r\nif (!machine_is(powermac))\r\nreturn 0;\r\nDBG("Installing base platform functions...\n");\r\nfor (i = 0 ; i < MAX_MACIO_CHIPS; i++) {\r\nif (macio_chips[i].of_node) {\r\nmacio_mmio_init_one(&macio_chips[i]);\r\nmacio_gpio_init_one(&macio_chips[i]);\r\n}\r\n}\r\nif (uninorth_node && uninorth_base)\r\nuninorth_install_pfunc();\r\nDBG("All base functions installed\n");\r\nreturn 0;\r\n}\r\nvoid pmac_pfunc_base_suspend(void)\r\n{\r\nint i;\r\nfor (i = 0 ; i < MAX_MACIO_CHIPS; i++) {\r\nif (macio_chips[i].of_node)\r\npmf_do_functions(macio_chips[i].of_node, NULL, 0,\r\nPMF_FLAGS_ON_SLEEP, NULL);\r\n}\r\nif (uninorth_node)\r\npmf_do_functions(uninorth_node, NULL, 0,\r\nPMF_FLAGS_ON_SLEEP, NULL);\r\nif (unin_hwclock)\r\npmf_do_functions(unin_hwclock, NULL, 0,\r\nPMF_FLAGS_ON_SLEEP, NULL);\r\n}\r\nvoid pmac_pfunc_base_resume(void)\r\n{\r\nint i;\r\nif (unin_hwclock)\r\npmf_do_functions(unin_hwclock, NULL, 0,\r\nPMF_FLAGS_ON_WAKE, NULL);\r\nif (uninorth_node)\r\npmf_do_functions(uninorth_node, NULL, 0,\r\nPMF_FLAGS_ON_WAKE, NULL);\r\nfor (i = 0 ; i < MAX_MACIO_CHIPS; i++) {\r\nif (macio_chips[i].of_node)\r\npmf_do_functions(macio_chips[i].of_node, NULL, 0,\r\nPMF_FLAGS_ON_WAKE, NULL);\r\n}\r\n}
