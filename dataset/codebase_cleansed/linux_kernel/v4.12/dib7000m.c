static u16 dib7000m_read_word(struct dib7000m_state *state, u16 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn 0;\r\n}\r\nstate->i2c_write_buffer[0] = (reg >> 8) | 0x80;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c_addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 2;\r\nstate->msg[1].addr = state->i2c_addr >> 1;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c_adap, state->msg, 2) != 2)\r\ndprintk("i2c read error on %d\n", reg);\r\nret = (state->i2c_read_buffer[0] << 8) | state->i2c_read_buffer[1];\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib7000m_write_word(struct dib7000m_state *state, u16 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = (reg >> 8) & 0xff;\r\nstate->i2c_write_buffer[1] = reg & 0xff;\r\nstate->i2c_write_buffer[2] = (val >> 8) & 0xff;\r\nstate->i2c_write_buffer[3] = val & 0xff;\r\nmemset(&state->msg[0], 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->i2c_addr >> 1;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 4;\r\nret = (i2c_transfer(state->i2c_adap, state->msg, 1) != 1 ?\r\n-EREMOTEIO : 0);\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic void dib7000m_write_tab(struct dib7000m_state *state, u16 *buf)\r\n{\r\nu16 l = 0, r, *n;\r\nn = buf;\r\nl = *n++;\r\nwhile (l) {\r\nr = *n++;\r\nif (state->reg_offs && (r >= 112 && r <= 331))\r\nr++;\r\ndo {\r\ndib7000m_write_word(state, r, *n++);\r\nr++;\r\n} while (--l);\r\nl = *n++;\r\n}\r\n}\r\nstatic int dib7000m_set_output_mode(struct dib7000m_state *state, int mode)\r\n{\r\nint ret = 0;\r\nu16 outreg, fifo_threshold, smo_mode,\r\nsram = 0x0005;\r\noutreg = 0;\r\nfifo_threshold = 1792;\r\nsmo_mode = (dib7000m_read_word(state, 294 + state->reg_offs) & 0x0010) | (1 << 1);\r\ndprintk("setting output mode for demod %p to %d\n", &state->demod, mode);\r\nswitch (mode) {\r\ncase OUTMODE_MPEG2_PAR_GATED_CLK:\r\noutreg = (1 << 10);\r\nbreak;\r\ncase OUTMODE_MPEG2_PAR_CONT_CLK:\r\noutreg = (1 << 10) | (1 << 6);\r\nbreak;\r\ncase OUTMODE_MPEG2_SERIAL:\r\noutreg = (1 << 10) | (2 << 6) | (0 << 1);\r\nbreak;\r\ncase OUTMODE_DIVERSITY:\r\nif (state->cfg.hostbus_diversity)\r\noutreg = (1 << 10) | (4 << 6);\r\nelse\r\nsram |= 0x0c00;\r\nbreak;\r\ncase OUTMODE_MPEG2_FIFO:\r\nsmo_mode |= (3 << 1);\r\nfifo_threshold = 512;\r\noutreg = (1 << 10) | (5 << 6);\r\nbreak;\r\ncase OUTMODE_HIGH_Z:\r\noutreg = 0;\r\nbreak;\r\ndefault:\r\ndprintk("Unhandled output_mode passed to be set for demod %p\n", &state->demod);\r\nbreak;\r\n}\r\nif (state->cfg.output_mpeg2_in_188_bytes)\r\nsmo_mode |= (1 << 5) ;\r\nret |= dib7000m_write_word(state, 294 + state->reg_offs, smo_mode);\r\nret |= dib7000m_write_word(state, 295 + state->reg_offs, fifo_threshold);\r\nret |= dib7000m_write_word(state, 1795, outreg);\r\nret |= dib7000m_write_word(state, 1805, sram);\r\nif (state->revision == 0x4003) {\r\nu16 clk_cfg1 = dib7000m_read_word(state, 909) & 0xfffd;\r\nif (mode == OUTMODE_DIVERSITY)\r\nclk_cfg1 |= (1 << 1);\r\ndib7000m_write_word(state, 909, clk_cfg1);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dib7000m_set_power_mode(struct dib7000m_state *state, enum dib7000m_power_mode mode)\r\n{\r\nu16 reg_903 = 0xffff, reg_904 = 0xffff, reg_905 = 0xffff, reg_906 = 0x3fff;\r\nu8 offset = 0;\r\nswitch (mode) {\r\ncase DIB7000M_POWER_ALL:\r\nreg_903 = 0x0000; reg_904 = 0x0000; reg_905 = 0x0000; reg_906 = 0x0000;\r\nbreak;\r\ncase DIB7000M_POWER_INTERFACE_ONLY:\r\nreg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 2));\r\nbreak;\r\ncase DIB7000M_POWER_INTERF_ANALOG_AGC:\r\nreg_903 &= ~((1 << 15) | (1 << 14) | (1 << 11) | (1 << 10));\r\nreg_905 &= ~((1 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (1 << 2));\r\nreg_906 &= ~((1 << 0));\r\nbreak;\r\ncase DIB7000M_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD:\r\nreg_903 = 0x0000; reg_904 = 0x801f; reg_905 = 0x0000; reg_906 = 0x0000;\r\nbreak;\r\ncase DIB7000M_POWER_COR4_CRY_ESRAM_MOUT_NUD:\r\nreg_903 = 0x0000; reg_904 = 0x8000; reg_905 = 0x010b; reg_906 = 0x0000;\r\nbreak;\r\ncase DIB7000M_POWER_NO:\r\nbreak;\r\n}\r\nif (!state->cfg.mobile_mode)\r\nreg_904 |= (1 << 7) | (1 << 6) | (1 << 4) | (1 << 2) | (1 << 1);\r\nif (state->revision != 0x4000)\r\nreg_906 <<= 1;\r\nif (state->revision == 0x4003)\r\noffset = 1;\r\ndib7000m_write_word(state, 903 + offset, reg_903);\r\ndib7000m_write_word(state, 904 + offset, reg_904);\r\ndib7000m_write_word(state, 905 + offset, reg_905);\r\ndib7000m_write_word(state, 906 + offset, reg_906);\r\n}\r\nstatic int dib7000m_set_adc_state(struct dib7000m_state *state, enum dibx000_adc_states no)\r\n{\r\nint ret = 0;\r\nu16 reg_913 = dib7000m_read_word(state, 913),\r\nreg_914 = dib7000m_read_word(state, 914);\r\nswitch (no) {\r\ncase DIBX000_SLOW_ADC_ON:\r\nreg_914 |= (1 << 1) | (1 << 0);\r\nret |= dib7000m_write_word(state, 914, reg_914);\r\nreg_914 &= ~(1 << 1);\r\nbreak;\r\ncase DIBX000_SLOW_ADC_OFF:\r\nreg_914 |= (1 << 1) | (1 << 0);\r\nbreak;\r\ncase DIBX000_ADC_ON:\r\nif (state->revision == 0x4000) {\r\ndib7000m_write_word(state, 913, 0);\r\ndib7000m_write_word(state, 914, reg_914 & 0x3);\r\ndib7000m_write_word(state, 913, (1 << 15));\r\ndib7000m_write_word(state, 914, reg_914 & 0x3);\r\n}\r\nreg_913 &= 0x0fff;\r\nreg_914 &= 0x0003;\r\nbreak;\r\ncase DIBX000_ADC_OFF:\r\nreg_913 |= (1 << 14) | (1 << 13) | (1 << 12);\r\nreg_914 |= (1 << 5) | (1 << 4) | (1 << 3) | (1 << 2);\r\nbreak;\r\ncase DIBX000_VBG_ENABLE:\r\nreg_913 &= ~(1 << 15);\r\nbreak;\r\ncase DIBX000_VBG_DISABLE:\r\nreg_913 |= (1 << 15);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret |= dib7000m_write_word(state, 913, reg_913);\r\nret |= dib7000m_write_word(state, 914, reg_914);\r\nreturn ret;\r\n}\r\nstatic int dib7000m_set_bandwidth(struct dib7000m_state *state, u32 bw)\r\n{\r\nu32 timf;\r\nif (!bw)\r\nbw = 8000;\r\nstate->current_bandwidth = bw;\r\nif (state->timf == 0) {\r\ndprintk("using default timf\n");\r\ntimf = state->timf_default;\r\n} else {\r\ndprintk("using updated timf\n");\r\ntimf = state->timf;\r\n}\r\ntimf = timf * (bw / 50) / 160;\r\ndib7000m_write_word(state, 23, (u16) ((timf >> 16) & 0xffff));\r\ndib7000m_write_word(state, 24, (u16) ((timf ) & 0xffff));\r\nreturn 0;\r\n}\r\nstatic int dib7000m_set_diversity_in(struct dvb_frontend *demod, int onoff)\r\n{\r\nstruct dib7000m_state *state = demod->demodulator_priv;\r\nif (state->div_force_off) {\r\ndprintk("diversity combination deactivated - forced by COFDM parameters\n");\r\nonoff = 0;\r\n}\r\nstate->div_state = (u8)onoff;\r\nif (onoff) {\r\ndib7000m_write_word(state, 263 + state->reg_offs, 6);\r\ndib7000m_write_word(state, 264 + state->reg_offs, 6);\r\ndib7000m_write_word(state, 266 + state->reg_offs, (state->div_sync_wait << 4) | (1 << 2) | (2 << 0));\r\n} else {\r\ndib7000m_write_word(state, 263 + state->reg_offs, 1);\r\ndib7000m_write_word(state, 264 + state->reg_offs, 0);\r\ndib7000m_write_word(state, 266 + state->reg_offs, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000m_sad_calib(struct dib7000m_state *state)\r\n{\r\ndib7000m_write_word(state, 929, (0 << 1) | (0 << 0));\r\ndib7000m_write_word(state, 930, 776);\r\ndib7000m_write_word(state, 929, (1 << 0));\r\ndib7000m_write_word(state, 929, (0 << 0));\r\nmsleep(1);\r\nreturn 0;\r\n}\r\nstatic void dib7000m_reset_pll_common(struct dib7000m_state *state, const struct dibx000_bandwidth_config *bw)\r\n{\r\ndib7000m_write_word(state, 18, (u16) (((bw->internal*1000) >> 16) & 0xffff));\r\ndib7000m_write_word(state, 19, (u16) ( (bw->internal*1000) & 0xffff));\r\ndib7000m_write_word(state, 21, (u16) ( (bw->ifreq >> 16) & 0xffff));\r\ndib7000m_write_word(state, 22, (u16) ( bw->ifreq & 0xffff));\r\ndib7000m_write_word(state, 928, bw->sad_cfg);\r\n}\r\nstatic void dib7000m_reset_pll(struct dib7000m_state *state)\r\n{\r\nconst struct dibx000_bandwidth_config *bw = state->cfg.bw;\r\nu16 reg_907,reg_910;\r\nreg_907 = (bw->pll_bypass << 15) | (bw->modulo << 7) |\r\n(bw->ADClkSrc << 6) | (bw->IO_CLK_en_core << 5) | (bw->bypclk_div << 2) |\r\n(bw->enable_refdiv << 1) | (0 << 0);\r\nreg_910 = (((bw->pll_ratio >> 6) & 0x3) << 3) | (bw->pll_range << 1) | bw->pll_reset;\r\nif (!state->cfg.quartz_direct) {\r\nreg_910 |= (1 << 5);\r\nif(state->cfg.input_clk_is_div_2)\r\nreg_907 |= (16 << 9);\r\nelse\r\nreg_907 |= (8 << 9);\r\n} else {\r\nreg_907 |= (bw->pll_ratio & 0x3f) << 9;\r\nreg_910 |= (bw->pll_prediv << 5);\r\n}\r\ndib7000m_write_word(state, 910, reg_910);\r\ndib7000m_write_word(state, 907, reg_907);\r\ndib7000m_write_word(state, 908, 0x0006);\r\ndib7000m_reset_pll_common(state, bw);\r\n}\r\nstatic void dib7000mc_reset_pll(struct dib7000m_state *state)\r\n{\r\nconst struct dibx000_bandwidth_config *bw = state->cfg.bw;\r\nu16 clk_cfg1;\r\ndib7000m_write_word(state, 907, (bw->pll_prediv << 8) | (bw->pll_ratio << 0));\r\nclk_cfg1 = (0 << 14) | (3 << 12) |(0 << 11) |\r\n(bw->IO_CLK_en_core << 10) | (bw->bypclk_div << 5) | (bw->enable_refdiv << 4) |\r\n(1 << 3) | (bw->pll_range << 1) | (bw->pll_reset << 0);\r\ndib7000m_write_word(state, 908, clk_cfg1);\r\nclk_cfg1 = (clk_cfg1 & 0xfff7) | (bw->pll_bypass << 3);\r\ndib7000m_write_word(state, 908, clk_cfg1);\r\ndib7000m_write_word(state, 910, (1 << 12) | (2 << 10) | (bw->modulo << 8) | (bw->ADClkSrc << 7));\r\ndib7000m_reset_pll_common(state, bw);\r\n}\r\nstatic int dib7000m_reset_gpio(struct dib7000m_state *st)\r\n{\r\ndib7000m_write_word(st, 773, st->cfg.gpio_dir);\r\ndib7000m_write_word(st, 774, st->cfg.gpio_val);\r\ndib7000m_write_word(st, 775, st->cfg.gpio_pwm_pos);\r\ndib7000m_write_word(st, 780, st->cfg.pwm_freq_div);\r\nreturn 0;\r\n}\r\nstatic int dib7000m_demod_reset(struct dib7000m_state *state)\r\n{\r\ndib7000m_set_power_mode(state, DIB7000M_POWER_ALL);\r\ndib7000m_set_adc_state(state, DIBX000_VBG_ENABLE);\r\ndib7000m_write_word(state, 898, 0xffff);\r\ndib7000m_write_word(state, 899, 0xffff);\r\ndib7000m_write_word(state, 900, 0xff0f);\r\ndib7000m_write_word(state, 901, 0xfffc);\r\ndib7000m_write_word(state, 898, 0);\r\ndib7000m_write_word(state, 899, 0);\r\ndib7000m_write_word(state, 900, 0);\r\ndib7000m_write_word(state, 901, 0);\r\nif (state->revision == 0x4000)\r\ndib7000m_reset_pll(state);\r\nelse\r\ndib7000mc_reset_pll(state);\r\nif (dib7000m_reset_gpio(state) != 0)\r\ndprintk("GPIO reset was not successful.\n");\r\nif (dib7000m_set_output_mode(state, OUTMODE_HIGH_Z) != 0)\r\ndprintk("OUTPUT_MODE could not be reset.\n");\r\ndib7000m_write_word(state, 1794, dib7000m_read_word(state, 1794) & ~(1 << 1) );\r\ndib7000m_set_bandwidth(state, 8000);\r\ndib7000m_set_adc_state(state, DIBX000_SLOW_ADC_ON);\r\ndib7000m_sad_calib(state);\r\ndib7000m_set_adc_state(state, DIBX000_SLOW_ADC_OFF);\r\nif (state->cfg.dvbt_mode)\r\ndib7000m_write_word(state, 1796, 0x0);\r\nif (state->cfg.mobile_mode)\r\ndib7000m_write_word(state, 261 + state->reg_offs, 2);\r\nelse\r\ndib7000m_write_word(state, 224 + state->reg_offs, 1);\r\nif(state->cfg.tuner_is_baseband)\r\ndib7000m_write_word(state, 36, 0x0755);\r\nelse\r\ndib7000m_write_word(state, 36, 0x1f55);\r\nif (state->revision == 0x4000)\r\ndib7000m_write_word(state, 909, (3 << 10) | (1 << 6));\r\nelse\r\ndib7000m_write_word(state, 909, (3 << 4) | 1);\r\ndib7000m_write_tab(state, dib7000m_defaults_common);\r\ndib7000m_write_tab(state, dib7000m_defaults);\r\ndib7000m_set_power_mode(state, DIB7000M_POWER_INTERFACE_ONLY);\r\nstate->internal_clk = state->cfg.bw->internal;\r\nreturn 0;\r\n}\r\nstatic void dib7000m_restart_agc(struct dib7000m_state *state)\r\n{\r\ndib7000m_write_word(state, 898, 0x0c00);\r\ndib7000m_write_word(state, 898, 0x0000);\r\n}\r\nstatic int dib7000m_agc_soft_split(struct dib7000m_state *state)\r\n{\r\nu16 agc,split_offset;\r\nif(!state->current_agc || !state->current_agc->perform_agc_softsplit || state->current_agc->split.max == 0)\r\nreturn 0;\r\nagc = dib7000m_read_word(state, 390);\r\nif (agc > state->current_agc->split.min_thres)\r\nsplit_offset = state->current_agc->split.min;\r\nelse if (agc < state->current_agc->split.max_thres)\r\nsplit_offset = state->current_agc->split.max;\r\nelse\r\nsplit_offset = state->current_agc->split.max *\r\n(agc - state->current_agc->split.min_thres) /\r\n(state->current_agc->split.max_thres - state->current_agc->split.min_thres);\r\ndprintk("AGC split_offset: %d\n", split_offset);\r\nreturn dib7000m_write_word(state, 103, (dib7000m_read_word(state, 103) & 0xff00) | split_offset);\r\n}\r\nstatic int dib7000m_update_lna(struct dib7000m_state *state)\r\n{\r\nu16 dyn_gain;\r\nif (state->cfg.update_lna) {\r\ndyn_gain = dib7000m_read_word(state, 390);\r\nif (state->cfg.update_lna(&state->demod,dyn_gain)) {\r\ndib7000m_restart_agc(state);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000m_set_agc_config(struct dib7000m_state *state, u8 band)\r\n{\r\nstruct dibx000_agc_config *agc = NULL;\r\nint i;\r\nif (state->current_band == band && state->current_agc != NULL)\r\nreturn 0;\r\nstate->current_band = band;\r\nfor (i = 0; i < state->cfg.agc_config_count; i++)\r\nif (state->cfg.agc[i].band_caps & band) {\r\nagc = &state->cfg.agc[i];\r\nbreak;\r\n}\r\nif (agc == NULL) {\r\ndprintk("no valid AGC configuration found for band 0x%02x\n", band);\r\nreturn -EINVAL;\r\n}\r\nstate->current_agc = agc;\r\ndib7000m_write_word(state, 72 , agc->setup);\r\ndib7000m_write_word(state, 73 , agc->inv_gain);\r\ndib7000m_write_word(state, 74 , agc->time_stabiliz);\r\ndib7000m_write_word(state, 97 , (agc->alpha_level << 12) | agc->thlock);\r\ndib7000m_write_word(state, 98, (agc->alpha_mant << 5) | agc->alpha_exp);\r\ndib7000m_write_word(state, 99, (agc->beta_mant << 6) | agc->beta_exp);\r\ndprintk("WBD: ref: %d, sel: %d, active: %d, alpha: %d\n",\r\nstate->wbd_ref != 0 ? state->wbd_ref : agc->wbd_ref, agc->wbd_sel, !agc->perform_agc_softsplit, agc->wbd_sel);\r\nif (state->wbd_ref != 0)\r\ndib7000m_write_word(state, 102, state->wbd_ref);\r\nelse\r\ndib7000m_write_word(state, 102, agc->wbd_ref);\r\ndib7000m_write_word(state, 103, (agc->wbd_alpha << 9) | (agc->perform_agc_softsplit << 8) );\r\ndib7000m_write_word(state, 104, agc->agc1_max);\r\ndib7000m_write_word(state, 105, agc->agc1_min);\r\ndib7000m_write_word(state, 106, agc->agc2_max);\r\ndib7000m_write_word(state, 107, agc->agc2_min);\r\ndib7000m_write_word(state, 108, (agc->agc1_pt1 << 8) | agc->agc1_pt2 );\r\ndib7000m_write_word(state, 109, (agc->agc1_slope1 << 8) | agc->agc1_slope2);\r\ndib7000m_write_word(state, 110, (agc->agc2_pt1 << 8) | agc->agc2_pt2);\r\ndib7000m_write_word(state, 111, (agc->agc2_slope1 << 8) | agc->agc2_slope2);\r\nif (state->revision > 0x4000) {\r\ndib7000m_write_word(state, 71, agc->agc1_pt3);\r\ndib7000m_write_word(state, 929, (dib7000m_read_word(state, 929) & 0xffe3) | (agc->wbd_inv << 4) | (agc->wbd_sel << 2));\r\n} else {\r\nu16 b[9] = { 676, 696, 717, 737, 758, 778, 799, 819, 840 };\r\nfor (i = 0; i < 9; i++)\r\ndib7000m_write_word(state, 88 + i, b[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dib7000m_update_timf(struct dib7000m_state *state)\r\n{\r\nu32 timf = (dib7000m_read_word(state, 436) << 16) | dib7000m_read_word(state, 437);\r\nstate->timf = timf * 160 / (state->current_bandwidth / 50);\r\ndib7000m_write_word(state, 23, (u16) (timf >> 16));\r\ndib7000m_write_word(state, 24, (u16) (timf & 0xffff));\r\ndprintk("updated timf_frequency: %d (default: %d)\n", state->timf, state->timf_default);\r\n}\r\nstatic int dib7000m_agc_startup(struct dvb_frontend *demod)\r\n{\r\nstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\r\nstruct dib7000m_state *state = demod->demodulator_priv;\r\nu16 cfg_72 = dib7000m_read_word(state, 72);\r\nint ret = -1;\r\nu8 *agc_state = &state->agc_state;\r\nu8 agc_split;\r\nswitch (state->agc_state) {\r\ncase 0:\r\ndib7000m_set_power_mode(state, DIB7000M_POWER_INTERF_ANALOG_AGC);\r\ndib7000m_set_adc_state(state, DIBX000_ADC_ON);\r\nif (dib7000m_set_agc_config(state, BAND_OF_FREQUENCY(ch->frequency/1000)) != 0)\r\nreturn -1;\r\nret = 7;\r\n(*agc_state)++;\r\nbreak;\r\ncase 1:\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(&state->demod, 1);\r\ndib7000m_write_word(state, 75, 32768);\r\nif (!state->current_agc->perform_agc_softsplit) {\r\ndib7000m_write_word(state, 103, 1 << 8);\r\n(*agc_state)++;\r\nret = 5;\r\n} else {\r\n(*agc_state) = 4;\r\nret = 7;\r\n}\r\ndib7000m_restart_agc(state);\r\nbreak;\r\ncase 2:\r\ndib7000m_write_word(state, 72, cfg_72 | (1 << 4));\r\ndib7000m_write_word(state, 103, 2 << 9);\r\n(*agc_state)++;\r\nret = 14;\r\nbreak;\r\ncase 3:\r\nagc_split = (u8)dib7000m_read_word(state, 392);\r\ndib7000m_write_word(state, 75, dib7000m_read_word(state, 390));\r\ndib7000m_write_word(state, 72, cfg_72 & ~(1 << 4));\r\ndib7000m_write_word(state, 103, (state->current_agc->wbd_alpha << 9) | agc_split);\r\ndib7000m_restart_agc(state);\r\ndprintk("SPLIT %p: %hd\n", demod, agc_split);\r\n(*agc_state)++;\r\nret = 5;\r\nbreak;\r\ncase 4:\r\nret = 7;\r\nif (dib7000m_update_lna(state))\r\nret = 5;\r\nelse\r\n(*agc_state)++;\r\nbreak;\r\ncase 5:\r\ndib7000m_agc_soft_split(state);\r\nif (state->cfg.agc_control)\r\nstate->cfg.agc_control(&state->demod, 0);\r\n(*agc_state)++;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void dib7000m_set_channel(struct dib7000m_state *state, struct dtv_frontend_properties *ch,\r\nu8 seq)\r\n{\r\nu16 value, est[4];\r\ndib7000m_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\r\nvalue = 0;\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K: value |= (0 << 7); break;\r\ncase TRANSMISSION_MODE_4K: value |= (2 << 7); break;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K: value |= (1 << 7); break;\r\n}\r\nswitch (ch->guard_interval) {\r\ncase GUARD_INTERVAL_1_32: value |= (0 << 5); break;\r\ncase GUARD_INTERVAL_1_16: value |= (1 << 5); break;\r\ncase GUARD_INTERVAL_1_4: value |= (3 << 5); break;\r\ndefault:\r\ncase GUARD_INTERVAL_1_8: value |= (2 << 5); break;\r\n}\r\nswitch (ch->modulation) {\r\ncase QPSK: value |= (0 << 3); break;\r\ncase QAM_16: value |= (1 << 3); break;\r\ndefault:\r\ncase QAM_64: value |= (2 << 3); break;\r\n}\r\nswitch (HIERARCHY_1) {\r\ncase HIERARCHY_2: value |= 2; break;\r\ncase HIERARCHY_4: value |= 4; break;\r\ndefault:\r\ncase HIERARCHY_1: value |= 1; break;\r\n}\r\ndib7000m_write_word(state, 0, value);\r\ndib7000m_write_word(state, 5, (seq << 4));\r\nvalue = 0;\r\nif (1 != 0)\r\nvalue |= (1 << 6);\r\nif (ch->hierarchy == 1)\r\nvalue |= (1 << 4);\r\nif (1 == 1)\r\nvalue |= 1;\r\nswitch ((ch->hierarchy == 0 || 1 == 1) ? ch->code_rate_HP : ch->code_rate_LP) {\r\ncase FEC_2_3: value |= (2 << 1); break;\r\ncase FEC_3_4: value |= (3 << 1); break;\r\ncase FEC_5_6: value |= (5 << 1); break;\r\ncase FEC_7_8: value |= (7 << 1); break;\r\ndefault:\r\ncase FEC_1_2: value |= (1 << 1); break;\r\n}\r\ndib7000m_write_word(state, 267 + state->reg_offs, value);\r\ndib7000m_write_word(state, 26, (6 << 12) | (6 << 8) | 0x80);\r\ndib7000m_write_word(state, 29, (0 << 14) | (4 << 10) | (1 << 9) | (3 << 5) | (1 << 4) | (0x3));\r\ndib7000m_write_word(state, 32, (0 << 4) | 0x3);\r\ndib7000m_write_word(state, 33, (0 << 4) | 0x5);\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_8K: value = 256; break;\r\ncase TRANSMISSION_MODE_4K: value = 128; break;\r\ncase TRANSMISSION_MODE_2K:\r\ndefault: value = 64; break;\r\n}\r\nswitch (ch->guard_interval) {\r\ncase GUARD_INTERVAL_1_16: value *= 2; break;\r\ncase GUARD_INTERVAL_1_8: value *= 4; break;\r\ncase GUARD_INTERVAL_1_4: value *= 8; break;\r\ndefault:\r\ncase GUARD_INTERVAL_1_32: value *= 1; break;\r\n}\r\nstate->div_sync_wait = (value * 3) / 2 + 32;\r\nif (1 == 1 || state->revision > 0x4000)\r\nstate->div_force_off = 0;\r\nelse\r\nstate->div_force_off = 1;\r\ndib7000m_set_diversity_in(&state->demod, state->div_state);\r\nswitch (ch->modulation) {\r\ncase QAM_64:\r\nest[0] = 0x0148;\r\nest[1] = 0xfff0;\r\nest[2] = 0x00a4;\r\nest[3] = 0xfff8;\r\nbreak;\r\ncase QAM_16:\r\nest[0] = 0x023d;\r\nest[1] = 0xffdf;\r\nest[2] = 0x00a4;\r\nest[3] = 0xfff0;\r\nbreak;\r\ndefault:\r\nest[0] = 0x099a;\r\nest[1] = 0xffae;\r\nest[2] = 0x0333;\r\nest[3] = 0xfff8;\r\nbreak;\r\n}\r\nfor (value = 0; value < 4; value++)\r\ndib7000m_write_word(state, 214 + value + state->reg_offs, est[value]);\r\ndib7000m_set_power_mode(state, DIB7000M_POWER_COR4_DINTLV_ICIRM_EQUAL_CFROD);\r\n}\r\nstatic int dib7000m_autosearch_start(struct dvb_frontend *demod)\r\n{\r\nstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\r\nstruct dib7000m_state *state = demod->demodulator_priv;\r\nstruct dtv_frontend_properties schan;\r\nint ret = 0;\r\nu32 value, factor;\r\nschan = *ch;\r\nschan.modulation = QAM_64;\r\nschan.guard_interval = GUARD_INTERVAL_1_32;\r\nschan.transmission_mode = TRANSMISSION_MODE_8K;\r\nschan.code_rate_HP = FEC_2_3;\r\nschan.code_rate_LP = FEC_3_4;\r\nschan.hierarchy = 0;\r\ndib7000m_set_channel(state, &schan, 7);\r\nfactor = BANDWIDTH_TO_KHZ(schan.bandwidth_hz);\r\nif (factor >= 5000)\r\nfactor = 1;\r\nelse\r\nfactor = 6;\r\nvalue = 30 * state->internal_clk * factor;\r\nret |= dib7000m_write_word(state, 6, (u16) ((value >> 16) & 0xffff));\r\nret |= dib7000m_write_word(state, 7, (u16) (value & 0xffff));\r\nvalue = 100 * state->internal_clk * factor;\r\nret |= dib7000m_write_word(state, 8, (u16) ((value >> 16) & 0xffff));\r\nret |= dib7000m_write_word(state, 9, (u16) (value & 0xffff));\r\nvalue = 500 * state->internal_clk * factor;\r\nret |= dib7000m_write_word(state, 10, (u16) ((value >> 16) & 0xffff));\r\nret |= dib7000m_write_word(state, 11, (u16) (value & 0xffff));\r\nvalue = dib7000m_read_word(state, 0);\r\nret |= dib7000m_write_word(state, 0, (u16) (value | (1 << 9)));\r\nif (state->revision == 0x4000)\r\ndib7000m_write_word(state, 1793, 0);\r\nelse\r\ndib7000m_read_word(state, 537);\r\nret |= dib7000m_write_word(state, 0, (u16) value);\r\nreturn ret;\r\n}\r\nstatic int dib7000m_autosearch_irq(struct dib7000m_state *state, u16 reg)\r\n{\r\nu16 irq_pending = dib7000m_read_word(state, reg);\r\nif (irq_pending & 0x1) {\r\ndprintk("autosearch failed\n");\r\nreturn 1;\r\n}\r\nif (irq_pending & 0x2) {\r\ndprintk("autosearch succeeded\n");\r\nreturn 2;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000m_autosearch_is_irq(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000m_state *state = demod->demodulator_priv;\r\nif (state->revision == 0x4000)\r\nreturn dib7000m_autosearch_irq(state, 1793);\r\nelse\r\nreturn dib7000m_autosearch_irq(state, 537);\r\n}\r\nstatic int dib7000m_tune(struct dvb_frontend *demod)\r\n{\r\nstruct dtv_frontend_properties *ch = &demod->dtv_property_cache;\r\nstruct dib7000m_state *state = demod->demodulator_priv;\r\nint ret = 0;\r\nu16 value;\r\ndib7000m_set_channel(state, ch, 0);\r\nret |= dib7000m_write_word(state, 898, 0x4000);\r\nret |= dib7000m_write_word(state, 898, 0x0000);\r\nmsleep(45);\r\ndib7000m_set_power_mode(state, DIB7000M_POWER_COR4_CRY_ESRAM_MOUT_NUD);\r\nret |= dib7000m_write_word(state, 29, (0 << 14) | (4 << 10) | (0 << 9) | (3 << 5) | (1 << 4) | (0x3));\r\nif (state->timf == 0)\r\nmsleep(200);\r\nvalue = (6 << 8) | 0x80;\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K: value |= (7 << 12); break;\r\ncase TRANSMISSION_MODE_4K: value |= (8 << 12); break;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K: value |= (9 << 12); break;\r\n}\r\nret |= dib7000m_write_word(state, 26, value);\r\nvalue = (0 << 4);\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K: value |= 0x6; break;\r\ncase TRANSMISSION_MODE_4K: value |= 0x7; break;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K: value |= 0x8; break;\r\n}\r\nret |= dib7000m_write_word(state, 32, value);\r\nvalue = (0 << 4);\r\nswitch (ch->transmission_mode) {\r\ncase TRANSMISSION_MODE_2K: value |= 0x6; break;\r\ncase TRANSMISSION_MODE_4K: value |= 0x7; break;\r\ndefault:\r\ncase TRANSMISSION_MODE_8K: value |= 0x8; break;\r\n}\r\nret |= dib7000m_write_word(state, 33, value);\r\nif ((dib7000m_read_word(state, 535) >> 6) & 0x1)\r\ndib7000m_update_timf(state);\r\ndib7000m_set_bandwidth(state, BANDWIDTH_TO_KHZ(ch->bandwidth_hz));\r\nreturn ret;\r\n}\r\nstatic int dib7000m_wakeup(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000m_state *state = demod->demodulator_priv;\r\ndib7000m_set_power_mode(state, DIB7000M_POWER_ALL);\r\nif (dib7000m_set_adc_state(state, DIBX000_SLOW_ADC_ON) != 0)\r\ndprintk("could not start Slow ADC\n");\r\nreturn 0;\r\n}\r\nstatic int dib7000m_sleep(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000m_state *st = demod->demodulator_priv;\r\ndib7000m_set_output_mode(st, OUTMODE_HIGH_Z);\r\ndib7000m_set_power_mode(st, DIB7000M_POWER_INTERFACE_ONLY);\r\nreturn dib7000m_set_adc_state(st, DIBX000_SLOW_ADC_OFF) |\r\ndib7000m_set_adc_state(st, DIBX000_ADC_OFF);\r\n}\r\nstatic int dib7000m_identify(struct dib7000m_state *state)\r\n{\r\nu16 value;\r\nif ((value = dib7000m_read_word(state, 896)) != 0x01b3) {\r\ndprintk("wrong Vendor ID (0x%x)\n", value);\r\nreturn -EREMOTEIO;\r\n}\r\nstate->revision = dib7000m_read_word(state, 897);\r\nif (state->revision != 0x4000 &&\r\nstate->revision != 0x4001 &&\r\nstate->revision != 0x4002 &&\r\nstate->revision != 0x4003) {\r\ndprintk("wrong Device ID (0x%x)\n", value);\r\nreturn -EREMOTEIO;\r\n}\r\nif (state->revision == 0x4000 && dib7000m_read_word(state, 769) == 0x4000) {\r\ndprintk("this driver does not work with DiB7000PC\n");\r\nreturn -EREMOTEIO;\r\n}\r\nswitch (state->revision) {\r\ncase 0x4000: dprintk("found DiB7000MA/PA/MB/PB\n"); break;\r\ncase 0x4001: state->reg_offs = 1; dprintk("found DiB7000HC\n"); break;\r\ncase 0x4002: state->reg_offs = 1; dprintk("found DiB7000MC\n"); break;\r\ncase 0x4003: state->reg_offs = 1; dprintk("found DiB9000\n"); break;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000m_get_frontend(struct dvb_frontend* fe,\r\nstruct dtv_frontend_properties *fep)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\nu16 tps = dib7000m_read_word(state,480);\r\nfep->inversion = INVERSION_AUTO;\r\nfep->bandwidth_hz = BANDWIDTH_TO_HZ(state->current_bandwidth);\r\nswitch ((tps >> 8) & 0x3) {\r\ncase 0: fep->transmission_mode = TRANSMISSION_MODE_2K; break;\r\ncase 1: fep->transmission_mode = TRANSMISSION_MODE_8K; break;\r\n}\r\nswitch (tps & 0x3) {\r\ncase 0: fep->guard_interval = GUARD_INTERVAL_1_32; break;\r\ncase 1: fep->guard_interval = GUARD_INTERVAL_1_16; break;\r\ncase 2: fep->guard_interval = GUARD_INTERVAL_1_8; break;\r\ncase 3: fep->guard_interval = GUARD_INTERVAL_1_4; break;\r\n}\r\nswitch ((tps >> 14) & 0x3) {\r\ncase 0: fep->modulation = QPSK; break;\r\ncase 1: fep->modulation = QAM_16; break;\r\ncase 2:\r\ndefault: fep->modulation = QAM_64; break;\r\n}\r\nfep->hierarchy = HIERARCHY_NONE;\r\nswitch ((tps >> 5) & 0x7) {\r\ncase 1: fep->code_rate_HP = FEC_1_2; break;\r\ncase 2: fep->code_rate_HP = FEC_2_3; break;\r\ncase 3: fep->code_rate_HP = FEC_3_4; break;\r\ncase 5: fep->code_rate_HP = FEC_5_6; break;\r\ncase 7:\r\ndefault: fep->code_rate_HP = FEC_7_8; break;\r\n}\r\nswitch ((tps >> 2) & 0x7) {\r\ncase 1: fep->code_rate_LP = FEC_1_2; break;\r\ncase 2: fep->code_rate_LP = FEC_2_3; break;\r\ncase 3: fep->code_rate_LP = FEC_3_4; break;\r\ncase 5: fep->code_rate_LP = FEC_5_6; break;\r\ncase 7:\r\ndefault: fep->code_rate_LP = FEC_7_8; break;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib7000m_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *fep = &fe->dtv_property_cache;\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\nint time, ret;\r\ndib7000m_set_output_mode(state, OUTMODE_HIGH_Z);\r\ndib7000m_set_bandwidth(state, BANDWIDTH_TO_KHZ(fep->bandwidth_hz));\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nstate->agc_state = 0;\r\ndo {\r\ntime = dib7000m_agc_startup(fe);\r\nif (time != -1)\r\nmsleep(time);\r\n} while (time != -1);\r\nif (fep->transmission_mode == TRANSMISSION_MODE_AUTO ||\r\nfep->guard_interval == GUARD_INTERVAL_AUTO ||\r\nfep->modulation == QAM_AUTO ||\r\nfep->code_rate_HP == FEC_AUTO) {\r\nint i = 800, found;\r\ndib7000m_autosearch_start(fe);\r\ndo {\r\nmsleep(1);\r\nfound = dib7000m_autosearch_is_irq(fe);\r\n} while (found == 0 && i--);\r\ndprintk("autosearch returns: %d\n", found);\r\nif (found == 0 || found == 1)\r\nreturn 0;\r\ndib7000m_get_frontend(fe, fep);\r\n}\r\nret = dib7000m_tune(fe);\r\ndib7000m_set_output_mode(state, OUTMODE_MPEG2_FIFO);\r\nreturn ret;\r\n}\r\nstatic int dib7000m_read_status(struct dvb_frontend *fe, enum fe_status *stat)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\nu16 lock = dib7000m_read_word(state, 535);\r\n*stat = 0;\r\nif (lock & 0x8000)\r\n*stat |= FE_HAS_SIGNAL;\r\nif (lock & 0x3000)\r\n*stat |= FE_HAS_CARRIER;\r\nif (lock & 0x0100)\r\n*stat |= FE_HAS_VITERBI;\r\nif (lock & 0x0010)\r\n*stat |= FE_HAS_SYNC;\r\nif (lock & 0x0008)\r\n*stat |= FE_HAS_LOCK;\r\nreturn 0;\r\n}\r\nstatic int dib7000m_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\n*ber = (dib7000m_read_word(state, 526) << 16) | dib7000m_read_word(state, 527);\r\nreturn 0;\r\n}\r\nstatic int dib7000m_read_unc_blocks(struct dvb_frontend *fe, u32 *unc)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\n*unc = dib7000m_read_word(state, 534);\r\nreturn 0;\r\n}\r\nstatic int dib7000m_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\nu16 val = dib7000m_read_word(state, 390);\r\n*strength = 65535 - val;\r\nreturn 0;\r\n}\r\nstatic int dib7000m_read_snr(struct dvb_frontend* fe, u16 *snr)\r\n{\r\n*snr = 0x0000;\r\nreturn 0;\r\n}\r\nstatic int dib7000m_fe_get_tune_settings(struct dvb_frontend* fe, struct dvb_frontend_tune_settings *tune)\r\n{\r\ntune->min_delay_ms = 1000;\r\nreturn 0;\r\n}\r\nstatic void dib7000m_release(struct dvb_frontend *demod)\r\n{\r\nstruct dib7000m_state *st = demod->demodulator_priv;\r\ndibx000_exit_i2c_master(&st->i2c_master);\r\nkfree(st);\r\n}\r\nstruct i2c_adapter * dib7000m_get_i2c_master(struct dvb_frontend *demod, enum dibx000_i2c_interface intf, int gating)\r\n{\r\nstruct dib7000m_state *st = demod->demodulator_priv;\r\nreturn dibx000_get_i2c_adapter(&st->i2c_master, intf, gating);\r\n}\r\nint dib7000m_pid_filter_ctrl(struct dvb_frontend *fe, u8 onoff)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\nu16 val = dib7000m_read_word(state, 294 + state->reg_offs) & 0xffef;\r\nval |= (onoff & 0x1) << 4;\r\ndprintk("PID filter enabled %d\n", onoff);\r\nreturn dib7000m_write_word(state, 294 + state->reg_offs, val);\r\n}\r\nint dib7000m_pid_filter(struct dvb_frontend *fe, u8 id, u16 pid, u8 onoff)\r\n{\r\nstruct dib7000m_state *state = fe->demodulator_priv;\r\ndprintk("PID filter: index %x, PID %d, OnOff %d\n", id, pid, onoff);\r\nreturn dib7000m_write_word(state, 300 + state->reg_offs + id,\r\nonoff ? (1 << 13) | pid : 0);\r\n}\r\nstruct dvb_frontend * dib7000m_attach(struct i2c_adapter *i2c_adap, u8 i2c_addr, struct dib7000m_config *cfg)\r\n{\r\nstruct dvb_frontend *demod;\r\nstruct dib7000m_state *st;\r\nst = kzalloc(sizeof(struct dib7000m_state), GFP_KERNEL);\r\nif (st == NULL)\r\nreturn NULL;\r\nmemcpy(&st->cfg, cfg, sizeof(struct dib7000m_config));\r\nst->i2c_adap = i2c_adap;\r\nst->i2c_addr = i2c_addr;\r\ndemod = &st->demod;\r\ndemod->demodulator_priv = st;\r\nmemcpy(&st->demod.ops, &dib7000m_ops, sizeof(struct dvb_frontend_ops));\r\nmutex_init(&st->i2c_buffer_lock);\r\nst->timf_default = cfg->bw->timf;\r\nif (dib7000m_identify(st) != 0)\r\ngoto error;\r\nif (st->revision == 0x4000)\r\ndibx000_init_i2c_master(&st->i2c_master, DIB7000, st->i2c_adap, st->i2c_addr);\r\nelse\r\ndibx000_init_i2c_master(&st->i2c_master, DIB7000MC, st->i2c_adap, st->i2c_addr);\r\ndib7000m_demod_reset(st);\r\nreturn demod;\r\nerror:\r\nkfree(st);\r\nreturn NULL;\r\n}
