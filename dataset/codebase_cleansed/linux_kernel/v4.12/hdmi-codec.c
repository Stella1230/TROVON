static int hdmi_eld_ctl_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;\r\nuinfo->count = sizeof(hcp->eld);\r\nreturn 0;\r\n}\r\nstatic int hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_component *component = snd_kcontrol_chip(kcontrol);\r\nstruct hdmi_codec_priv *hcp = snd_soc_component_get_drvdata(component);\r\nmemcpy(ucontrol->value.bytes.data, hcp->eld, sizeof(hcp->eld));\r\nreturn 0;\r\n}\r\nstatic unsigned long hdmi_codec_spk_mask_from_alloc(int spk_alloc)\r\n{\r\nint i;\r\nconst unsigned long hdmi_codec_eld_spk_alloc_bits[] = {\r\n[0] = FL | FR, [1] = LFE, [2] = FC, [3] = RL | RR,\r\n[4] = RC, [5] = FLC | FRC, [6] = RLC | RRC,\r\n};\r\nunsigned long spk_mask = 0;\r\nfor (i = 0; i < ARRAY_SIZE(hdmi_codec_eld_spk_alloc_bits); i++) {\r\nif (spk_alloc & (1 << i))\r\nspk_mask |= hdmi_codec_eld_spk_alloc_bits[i];\r\n}\r\nreturn spk_mask;\r\n}\r\nvoid hdmi_codec_eld_chmap(struct hdmi_codec_priv *hcp)\r\n{\r\nu8 spk_alloc;\r\nunsigned long spk_mask;\r\nspk_alloc = drm_eld_get_spk_alloc(hcp->eld);\r\nspk_mask = hdmi_codec_spk_mask_from_alloc(spk_alloc);\r\nif ((spk_mask & ~(FL | FR)) && hcp->chmap_info->max_channels > 2)\r\nhcp->chmap_info->chmap = hdmi_codec_8ch_chmaps;\r\nelse\r\nhcp->chmap_info->chmap = hdmi_codec_stereo_chmaps;\r\n}\r\nstatic int hdmi_codec_get_ch_alloc_table_idx(struct hdmi_codec_priv *hcp,\r\nunsigned char channels)\r\n{\r\nint i;\r\nu8 spk_alloc;\r\nunsigned long spk_mask;\r\nconst struct hdmi_codec_cea_spk_alloc *cap = hdmi_codec_channel_alloc;\r\nspk_alloc = drm_eld_get_spk_alloc(hcp->eld);\r\nspk_mask = hdmi_codec_spk_mask_from_alloc(spk_alloc);\r\nfor (i = 0; i < ARRAY_SIZE(hdmi_codec_channel_alloc); i++, cap++) {\r\nif (!spk_alloc && cap->ca_id == 0)\r\nreturn i;\r\nif (cap->n_ch != channels)\r\ncontinue;\r\nif (!(cap->mask == (spk_mask & cap->mask)))\r\ncontinue;\r\nreturn i;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int hdmi_codec_chmap_ctl_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nunsigned const char *map;\r\nunsigned int i;\r\nstruct snd_pcm_chmap *info = snd_kcontrol_chip(kcontrol);\r\nstruct hdmi_codec_priv *hcp = info->private_data;\r\nmap = info->chmap[hcp->chmap_idx].map;\r\nfor (i = 0; i < info->max_channels; i++) {\r\nif (hcp->chmap_idx == HDMI_CODEC_CHMAP_IDX_UNKNOWN)\r\nucontrol->value.integer.value[i] = 0;\r\nelse\r\nucontrol->value.integer.value[i] = map[i];\r\n}\r\nreturn 0;\r\n}\r\nstatic int hdmi_codec_new_stream(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\nint ret = 0;\r\nmutex_lock(&hcp->current_stream_lock);\r\nif (!hcp->current_stream) {\r\nhcp->current_stream = substream;\r\n} else if (hcp->current_stream != substream) {\r\ndev_err(dai->dev, "Only one simultaneous stream supported!\n");\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&hcp->current_stream_lock);\r\nreturn ret;\r\n}\r\nstatic int hdmi_codec_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\nint ret = 0;\r\ndev_dbg(dai->dev, "%s()\n", __func__);\r\nret = hdmi_codec_new_stream(substream, dai);\r\nif (ret)\r\nreturn ret;\r\nif (hcp->hcd.ops->audio_startup) {\r\nret = hcp->hcd.ops->audio_startup(dai->dev->parent, hcp->hcd.data);\r\nif (ret) {\r\nmutex_lock(&hcp->current_stream_lock);\r\nhcp->current_stream = NULL;\r\nmutex_unlock(&hcp->current_stream_lock);\r\nreturn ret;\r\n}\r\n}\r\nif (hcp->hcd.ops->get_eld) {\r\nret = hcp->hcd.ops->get_eld(dai->dev->parent, hcp->hcd.data,\r\nhcp->eld, sizeof(hcp->eld));\r\nif (!ret) {\r\nret = snd_pcm_hw_constraint_eld(substream->runtime,\r\nhcp->eld);\r\nif (ret)\r\nreturn ret;\r\n}\r\nhdmi_codec_eld_chmap(hcp);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hdmi_codec_shutdown(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\ndev_dbg(dai->dev, "%s()\n", __func__);\r\nWARN_ON(hcp->current_stream != substream);\r\nhcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\r\nhcp->hcd.ops->audio_shutdown(dai->dev->parent, hcp->hcd.data);\r\nmutex_lock(&hcp->current_stream_lock);\r\nhcp->current_stream = NULL;\r\nmutex_unlock(&hcp->current_stream_lock);\r\n}\r\nstatic int hdmi_codec_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\nstruct hdmi_codec_params hp = {\r\n.iec = {\r\n.status = { 0 },\r\n.subcode = { 0 },\r\n.pad = 0,\r\n.dig_subframe = { 0 },\r\n}\r\n};\r\nint ret, idx;\r\ndev_dbg(dai->dev, "%s() width %d rate %d channels %d\n", __func__,\r\nparams_width(params), params_rate(params),\r\nparams_channels(params));\r\nif (params_width(params) > 24)\r\nparams->msbits = 24;\r\nret = snd_pcm_create_iec958_consumer_hw_params(params, hp.iec.status,\r\nsizeof(hp.iec.status));\r\nif (ret < 0) {\r\ndev_err(dai->dev, "Creating IEC958 channel status failed %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nret = hdmi_codec_new_stream(substream, dai);\r\nif (ret)\r\nreturn ret;\r\nhdmi_audio_infoframe_init(&hp.cea);\r\nhp.cea.channels = params_channels(params);\r\nhp.cea.coding_type = HDMI_AUDIO_CODING_TYPE_STREAM;\r\nhp.cea.sample_size = HDMI_AUDIO_SAMPLE_SIZE_STREAM;\r\nhp.cea.sample_frequency = HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM;\r\nidx = hdmi_codec_get_ch_alloc_table_idx(hcp, hp.cea.channels);\r\nif (idx < 0) {\r\ndev_err(dai->dev, "Not able to map channels to speakers (%d)\n",\r\nidx);\r\nhcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\r\nreturn idx;\r\n}\r\nhp.cea.channel_allocation = hdmi_codec_channel_alloc[idx].ca_id;\r\nhcp->chmap_idx = hdmi_codec_channel_alloc[idx].ca_id;\r\nhp.sample_width = params_width(params);\r\nhp.sample_rate = params_rate(params);\r\nhp.channels = params_channels(params);\r\nreturn hcp->hcd.ops->hw_params(dai->dev->parent, hcp->hcd.data,\r\n&hcp->daifmt[dai->id], &hp);\r\n}\r\nstatic int hdmi_codec_set_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\nstruct hdmi_codec_daifmt cf = { 0 };\r\nint ret = 0;\r\ndev_dbg(dai->dev, "%s()\n", __func__);\r\nif (dai->id == DAI_ID_SPDIF) {\r\ncf.fmt = HDMI_SPDIF;\r\n} else {\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncf.bit_clk_master = 1;\r\ncf.frame_clk_master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\ncf.frame_clk_master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\ncf.bit_clk_master = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ncf.frame_clk_inv = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ncf.bit_clk_inv = 1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ncf.frame_clk_inv = 1;\r\ncf.bit_clk_inv = 1;\r\nbreak;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\ncf.fmt = HDMI_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncf.fmt = HDMI_DSP_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\ncf.fmt = HDMI_DSP_B;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncf.fmt = HDMI_RIGHT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncf.fmt = HDMI_LEFT_J;\r\nbreak;\r\ncase SND_SOC_DAIFMT_AC97:\r\ncf.fmt = HDMI_AC97;\r\nbreak;\r\ndefault:\r\ndev_err(dai->dev, "Invalid DAI interface format\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nhcp->daifmt[dai->id] = cf;\r\nreturn ret;\r\n}\r\nstatic int hdmi_codec_digital_mute(struct snd_soc_dai *dai, int mute)\r\n{\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\ndev_dbg(dai->dev, "%s()\n", __func__);\r\nif (hcp->hcd.ops->digital_mute)\r\nreturn hcp->hcd.ops->digital_mute(dai->dev->parent,\r\nhcp->hcd.data, mute);\r\nreturn 0;\r\n}\r\nstatic int hdmi_codec_pcm_new(struct snd_soc_pcm_runtime *rtd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_dai_driver *drv = dai->driver;\r\nstruct hdmi_codec_priv *hcp = snd_soc_dai_get_drvdata(dai);\r\nint ret;\r\ndev_dbg(dai->dev, "%s()\n", __func__);\r\nret = snd_pcm_add_chmap_ctls(rtd->pcm, SNDRV_PCM_STREAM_PLAYBACK,\r\nNULL, drv->playback.channels_max, 0,\r\n&hcp->chmap_info);\r\nif (ret < 0)\r\nreturn ret;\r\nhcp->chmap_info->private_data = hcp;\r\nhcp->chmap_info->kctl->get = hdmi_codec_chmap_ctl_get;\r\nhcp->chmap_info->chmap = hdmi_codec_stereo_chmaps;\r\nhcp->chmap_idx = HDMI_CODEC_CHMAP_IDX_UNKNOWN;\r\nreturn 0;\r\n}\r\nstatic int hdmi_of_xlate_dai_name(struct snd_soc_component *component,\r\nstruct of_phandle_args *args,\r\nconst char **dai_name)\r\n{\r\nint id;\r\nif (args->args_count)\r\nid = args->args[0];\r\nelse\r\nid = 0;\r\nif (id < ARRAY_SIZE(hdmi_dai_name)) {\r\n*dai_name = hdmi_dai_name[id];\r\nreturn 0;\r\n}\r\nreturn -EAGAIN;\r\n}\r\nstatic int hdmi_codec_probe(struct platform_device *pdev)\r\n{\r\nstruct hdmi_codec_pdata *hcd = pdev->dev.platform_data;\r\nstruct device *dev = &pdev->dev;\r\nstruct hdmi_codec_priv *hcp;\r\nstruct hdmi_device *hd;\r\nstruct list_head *pos;\r\nint dai_count, i = 0;\r\nint ret;\r\ndev_dbg(dev, "%s()\n", __func__);\r\nif (!hcd) {\r\ndev_err(dev, "%s: No plalform data\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndai_count = hcd->i2s + hcd->spdif;\r\nif (dai_count < 1 || !hcd->ops || !hcd->ops->hw_params ||\r\n!hcd->ops->audio_shutdown) {\r\ndev_err(dev, "%s: Invalid parameters\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nhcp = devm_kzalloc(dev, sizeof(*hcp), GFP_KERNEL);\r\nif (!hcp)\r\nreturn -ENOMEM;\r\nhd = NULL;\r\nmutex_lock(&hdmi_mutex);\r\nlist_for_each(pos, &hdmi_device_list) {\r\nstruct hdmi_device *tmp = pos_to_hdmi_device(pos);\r\nif (tmp->dev == dev->parent) {\r\nhd = tmp;\r\nbreak;\r\n}\r\n}\r\nif (!hd) {\r\nhd = devm_kzalloc(dev, sizeof(*hd), GFP_KERNEL);\r\nif (!hd) {\r\nmutex_unlock(&hdmi_mutex);\r\nreturn -ENOMEM;\r\n}\r\nhd->dev = dev->parent;\r\nlist_add_tail(&hd->list, &hdmi_device_list);\r\n}\r\nmutex_unlock(&hdmi_mutex);\r\nif (hd->cnt >= ARRAY_SIZE(hdmi_dai_name)) {\r\ndev_err(dev, "too many hdmi codec are deteced\n");\r\nreturn -EINVAL;\r\n}\r\nhcp->hcd = *hcd;\r\nmutex_init(&hcp->current_stream_lock);\r\nhcp->daidrv = devm_kzalloc(dev, dai_count * sizeof(*hcp->daidrv),\r\nGFP_KERNEL);\r\nif (!hcp->daidrv)\r\nreturn -ENOMEM;\r\nif (hcd->i2s) {\r\nhcp->daidrv[i] = hdmi_i2s_dai;\r\nhcp->daidrv[i].playback.channels_max =\r\nhcd->max_i2s_channels;\r\nhcp->daidrv[i].name = hdmi_dai_name[hd->cnt++];\r\ni++;\r\n}\r\nif (hcd->spdif) {\r\nhcp->daidrv[i] = hdmi_spdif_dai;\r\nhcp->daidrv[i].name = hdmi_dai_name[hd->cnt++];\r\n}\r\nret = snd_soc_register_codec(dev, &hdmi_codec, hcp->daidrv,\r\ndai_count);\r\nif (ret) {\r\ndev_err(dev, "%s: snd_soc_register_codec() failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, hcp);\r\nreturn 0;\r\n}\r\nstatic int hdmi_codec_remove(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct list_head *pos;\r\nstruct hdmi_codec_priv *hcp;\r\nmutex_lock(&hdmi_mutex);\r\nlist_for_each(pos, &hdmi_device_list) {\r\nstruct hdmi_device *tmp = pos_to_hdmi_device(pos);\r\nif (tmp->dev == dev->parent) {\r\nlist_del(pos);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&hdmi_mutex);\r\nhcp = dev_get_drvdata(dev);\r\nkfree(hcp->chmap_info);\r\nsnd_soc_unregister_codec(dev);\r\nreturn 0;\r\n}
