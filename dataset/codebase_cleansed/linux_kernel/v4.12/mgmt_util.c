static struct sk_buff *create_monitor_ctrl_event(__le16 index, u32 cookie,\r\nu16 opcode, u16 len, void *buf)\r\n{\r\nstruct hci_mon_hdr *hdr;\r\nstruct sk_buff *skb;\r\nskb = bt_skb_alloc(6 + len, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NULL;\r\nput_unaligned_le32(cookie, skb_put(skb, 4));\r\nput_unaligned_le16(opcode, skb_put(skb, 2));\r\nif (buf)\r\nmemcpy(skb_put(skb, len), buf, len);\r\n__net_timestamp(skb);\r\nhdr = (void *)skb_push(skb, HCI_MON_HDR_SIZE);\r\nhdr->opcode = cpu_to_le16(HCI_MON_CTRL_EVENT);\r\nhdr->index = index;\r\nhdr->len = cpu_to_le16(skb->len - HCI_MON_HDR_SIZE);\r\nreturn skb;\r\n}\r\nint mgmt_send_event(u16 event, struct hci_dev *hdev, unsigned short channel,\r\nvoid *data, u16 data_len, int flag, struct sock *skip_sk)\r\n{\r\nstruct sk_buff *skb;\r\nstruct mgmt_hdr *hdr;\r\nskb = alloc_skb(sizeof(*hdr) + data_len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr));\r\nhdr->opcode = cpu_to_le16(event);\r\nif (hdev)\r\nhdr->index = cpu_to_le16(hdev->id);\r\nelse\r\nhdr->index = cpu_to_le16(MGMT_INDEX_NONE);\r\nhdr->len = cpu_to_le16(data_len);\r\nif (data)\r\nmemcpy(skb_put(skb, data_len), data, data_len);\r\n__net_timestamp(skb);\r\nhci_send_to_channel(channel, skb, flag, skip_sk);\r\nif (channel == HCI_CHANNEL_CONTROL)\r\nhci_send_monitor_ctrl_event(hdev, event, data, data_len,\r\nskb_get_ktime(skb), flag, skip_sk);\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint mgmt_cmd_status(struct sock *sk, u16 index, u16 cmd, u8 status)\r\n{\r\nstruct sk_buff *skb, *mskb;\r\nstruct mgmt_hdr *hdr;\r\nstruct mgmt_ev_cmd_status *ev;\r\nint err;\r\nBT_DBG("sock %p, index %u, cmd %u, status %u", sk, index, cmd, status);\r\nskb = alloc_skb(sizeof(*hdr) + sizeof(*ev), GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr));\r\nhdr->opcode = cpu_to_le16(MGMT_EV_CMD_STATUS);\r\nhdr->index = cpu_to_le16(index);\r\nhdr->len = cpu_to_le16(sizeof(*ev));\r\nev = (void *) skb_put(skb, sizeof(*ev));\r\nev->status = status;\r\nev->opcode = cpu_to_le16(cmd);\r\nmskb = create_monitor_ctrl_event(hdr->index, hci_sock_get_cookie(sk),\r\nMGMT_EV_CMD_STATUS, sizeof(*ev), ev);\r\nif (mskb)\r\nskb->tstamp = mskb->tstamp;\r\nelse\r\n__net_timestamp(skb);\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err < 0)\r\nkfree_skb(skb);\r\nif (mskb) {\r\nhci_send_to_channel(HCI_CHANNEL_MONITOR, mskb,\r\nHCI_SOCK_TRUSTED, NULL);\r\nkfree_skb(mskb);\r\n}\r\nreturn err;\r\n}\r\nint mgmt_cmd_complete(struct sock *sk, u16 index, u16 cmd, u8 status,\r\nvoid *rp, size_t rp_len)\r\n{\r\nstruct sk_buff *skb, *mskb;\r\nstruct mgmt_hdr *hdr;\r\nstruct mgmt_ev_cmd_complete *ev;\r\nint err;\r\nBT_DBG("sock %p", sk);\r\nskb = alloc_skb(sizeof(*hdr) + sizeof(*ev) + rp_len, GFP_KERNEL);\r\nif (!skb)\r\nreturn -ENOMEM;\r\nhdr = (void *) skb_put(skb, sizeof(*hdr));\r\nhdr->opcode = cpu_to_le16(MGMT_EV_CMD_COMPLETE);\r\nhdr->index = cpu_to_le16(index);\r\nhdr->len = cpu_to_le16(sizeof(*ev) + rp_len);\r\nev = (void *) skb_put(skb, sizeof(*ev) + rp_len);\r\nev->opcode = cpu_to_le16(cmd);\r\nev->status = status;\r\nif (rp)\r\nmemcpy(ev->data, rp, rp_len);\r\nmskb = create_monitor_ctrl_event(hdr->index, hci_sock_get_cookie(sk),\r\nMGMT_EV_CMD_COMPLETE,\r\nsizeof(*ev) + rp_len, ev);\r\nif (mskb)\r\nskb->tstamp = mskb->tstamp;\r\nelse\r\n__net_timestamp(skb);\r\nerr = sock_queue_rcv_skb(sk, skb);\r\nif (err < 0)\r\nkfree_skb(skb);\r\nif (mskb) {\r\nhci_send_to_channel(HCI_CHANNEL_MONITOR, mskb,\r\nHCI_SOCK_TRUSTED, NULL);\r\nkfree_skb(mskb);\r\n}\r\nreturn err;\r\n}\r\nstruct mgmt_pending_cmd *mgmt_pending_find(unsigned short channel, u16 opcode,\r\nstruct hci_dev *hdev)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nif (hci_sock_get_channel(cmd->sk) != channel)\r\ncontinue;\r\nif (cmd->opcode == opcode)\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstruct mgmt_pending_cmd *mgmt_pending_find_data(unsigned short channel,\r\nu16 opcode,\r\nstruct hci_dev *hdev,\r\nconst void *data)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\nlist_for_each_entry(cmd, &hdev->mgmt_pending, list) {\r\nif (cmd->user_data != data)\r\ncontinue;\r\nif (cmd->opcode == opcode)\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nvoid mgmt_pending_foreach(u16 opcode, struct hci_dev *hdev,\r\nvoid (*cb)(struct mgmt_pending_cmd *cmd, void *data),\r\nvoid *data)\r\n{\r\nstruct mgmt_pending_cmd *cmd, *tmp;\r\nlist_for_each_entry_safe(cmd, tmp, &hdev->mgmt_pending, list) {\r\nif (opcode > 0 && cmd->opcode != opcode)\r\ncontinue;\r\ncb(cmd, data);\r\n}\r\n}\r\nstruct mgmt_pending_cmd *mgmt_pending_add(struct sock *sk, u16 opcode,\r\nstruct hci_dev *hdev,\r\nvoid *data, u16 len)\r\n{\r\nstruct mgmt_pending_cmd *cmd;\r\ncmd = kzalloc(sizeof(*cmd), GFP_KERNEL);\r\nif (!cmd)\r\nreturn NULL;\r\ncmd->opcode = opcode;\r\ncmd->index = hdev->id;\r\ncmd->param = kmemdup(data, len, GFP_KERNEL);\r\nif (!cmd->param) {\r\nkfree(cmd);\r\nreturn NULL;\r\n}\r\ncmd->param_len = len;\r\ncmd->sk = sk;\r\nsock_hold(sk);\r\nlist_add(&cmd->list, &hdev->mgmt_pending);\r\nreturn cmd;\r\n}\r\nvoid mgmt_pending_free(struct mgmt_pending_cmd *cmd)\r\n{\r\nsock_put(cmd->sk);\r\nkfree(cmd->param);\r\nkfree(cmd);\r\n}\r\nvoid mgmt_pending_remove(struct mgmt_pending_cmd *cmd)\r\n{\r\nlist_del(&cmd->list);\r\nmgmt_pending_free(cmd);\r\n}
