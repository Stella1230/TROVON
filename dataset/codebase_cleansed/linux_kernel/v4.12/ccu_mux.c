void ccu_mux_helper_adjust_parent_for_prediv(struct ccu_common *common,\r\nstruct ccu_mux_internal *cm,\r\nint parent_index,\r\nunsigned long *parent_rate)\r\n{\r\nu16 prediv = 1;\r\nu32 reg;\r\nint i;\r\nif (!((common->features & CCU_FEATURE_FIXED_PREDIV) ||\r\n(common->features & CCU_FEATURE_VARIABLE_PREDIV) ||\r\n(common->features & CCU_FEATURE_ALL_PREDIV)))\r\nreturn;\r\nif (common->features & CCU_FEATURE_ALL_PREDIV) {\r\n*parent_rate = *parent_rate / common->prediv;\r\nreturn;\r\n}\r\nreg = readl(common->base + common->reg);\r\nif (parent_index < 0) {\r\nparent_index = reg >> cm->shift;\r\nparent_index &= (1 << cm->width) - 1;\r\n}\r\nif (common->features & CCU_FEATURE_FIXED_PREDIV)\r\nfor (i = 0; i < cm->n_predivs; i++)\r\nif (parent_index == cm->fixed_predivs[i].index)\r\nprediv = cm->fixed_predivs[i].div;\r\nif (common->features & CCU_FEATURE_VARIABLE_PREDIV)\r\nif (parent_index == cm->variable_prediv.index) {\r\nu8 div;\r\ndiv = reg >> cm->variable_prediv.shift;\r\ndiv &= (1 << cm->variable_prediv.width) - 1;\r\nprediv = div + 1;\r\n}\r\n*parent_rate = *parent_rate / prediv;\r\n}\r\nu8 ccu_mux_helper_get_parent(struct ccu_common *common,\r\nstruct ccu_mux_internal *cm)\r\n{\r\nu32 reg;\r\nu8 parent;\r\nreg = readl(common->base + common->reg);\r\nparent = reg >> cm->shift;\r\nparent &= (1 << cm->width) - 1;\r\nif (cm->table) {\r\nint num_parents = clk_hw_get_num_parents(&common->hw);\r\nint i;\r\nfor (i = 0; i < num_parents; i++)\r\nif (cm->table[i] == parent)\r\nreturn i;\r\n}\r\nreturn parent;\r\n}\r\nint ccu_mux_helper_set_parent(struct ccu_common *common,\r\nstruct ccu_mux_internal *cm,\r\nu8 index)\r\n{\r\nunsigned long flags;\r\nu32 reg;\r\nif (cm->table)\r\nindex = cm->table[index];\r\nspin_lock_irqsave(common->lock, flags);\r\nreg = readl(common->base + common->reg);\r\nreg &= ~GENMASK(cm->width + cm->shift - 1, cm->shift);\r\nwritel(reg | (index << cm->shift), common->base + common->reg);\r\nspin_unlock_irqrestore(common->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void ccu_mux_disable(struct clk_hw *hw)\r\n{\r\nstruct ccu_mux *cm = hw_to_ccu_mux(hw);\r\nreturn ccu_gate_helper_disable(&cm->common, cm->enable);\r\n}\r\nstatic int ccu_mux_enable(struct clk_hw *hw)\r\n{\r\nstruct ccu_mux *cm = hw_to_ccu_mux(hw);\r\nreturn ccu_gate_helper_enable(&cm->common, cm->enable);\r\n}\r\nstatic int ccu_mux_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct ccu_mux *cm = hw_to_ccu_mux(hw);\r\nreturn ccu_gate_helper_is_enabled(&cm->common, cm->enable);\r\n}\r\nstatic u8 ccu_mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ccu_mux *cm = hw_to_ccu_mux(hw);\r\nreturn ccu_mux_helper_get_parent(&cm->common, &cm->mux);\r\n}\r\nstatic int ccu_mux_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct ccu_mux *cm = hw_to_ccu_mux(hw);\r\nreturn ccu_mux_helper_set_parent(&cm->common, &cm->mux, index);\r\n}\r\nstatic unsigned long ccu_mux_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct ccu_mux *cm = hw_to_ccu_mux(hw);\r\nccu_mux_helper_adjust_parent_for_prediv(&cm->common, &cm->mux, -1,\r\n&parent_rate);\r\nreturn parent_rate;\r\n}\r\nstatic int ccu_mux_notifier_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct ccu_mux_nb *mux = to_ccu_mux_nb(nb);\r\nint ret = 0;\r\nif (event == PRE_RATE_CHANGE) {\r\nmux->original_index = ccu_mux_helper_get_parent(mux->common,\r\nmux->cm);\r\nret = ccu_mux_helper_set_parent(mux->common, mux->cm,\r\nmux->bypass_index);\r\n} else if (event == POST_RATE_CHANGE) {\r\nret = ccu_mux_helper_set_parent(mux->common, mux->cm,\r\nmux->original_index);\r\n}\r\nudelay(mux->delay_us);\r\nreturn notifier_from_errno(ret);\r\n}\r\nint ccu_mux_notifier_register(struct clk *clk, struct ccu_mux_nb *mux_nb)\r\n{\r\nmux_nb->clk_nb.notifier_call = ccu_mux_notifier_cb;\r\nreturn clk_notifier_register(clk, &mux_nb->clk_nb);\r\n}
