struct udl_gem_object *udl_gem_alloc_object(struct drm_device *dev,\r\nsize_t size)\r\n{\r\nstruct udl_gem_object *obj;\r\nobj = kzalloc(sizeof(*obj), GFP_KERNEL);\r\nif (obj == NULL)\r\nreturn NULL;\r\nif (drm_gem_object_init(dev, &obj->base, size) != 0) {\r\nkfree(obj);\r\nreturn NULL;\r\n}\r\nobj->flags = UDL_BO_CACHEABLE;\r\nreturn obj;\r\n}\r\nstatic int\r\nudl_gem_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nuint64_t size,\r\nuint32_t *handle_p)\r\n{\r\nstruct udl_gem_object *obj;\r\nint ret;\r\nu32 handle;\r\nsize = roundup(size, PAGE_SIZE);\r\nobj = udl_gem_alloc_object(dev, size);\r\nif (obj == NULL)\r\nreturn -ENOMEM;\r\nret = drm_gem_handle_create(file, &obj->base, &handle);\r\nif (ret) {\r\ndrm_gem_object_release(&obj->base);\r\nkfree(obj);\r\nreturn ret;\r\n}\r\ndrm_gem_object_unreference_unlocked(&obj->base);\r\n*handle_p = handle;\r\nreturn 0;\r\n}\r\nstatic void update_vm_cache_attr(struct udl_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nDRM_DEBUG_KMS("flags = 0x%x\n", obj->flags);\r\nif (obj->flags & UDL_BO_CACHEABLE) {\r\nvma->vm_page_prot = vm_get_page_prot(vma->vm_flags);\r\n} else if (obj->flags & UDL_BO_WC) {\r\nvma->vm_page_prot =\r\npgprot_writecombine(vm_get_page_prot(vma->vm_flags));\r\n} else {\r\nvma->vm_page_prot =\r\npgprot_noncached(vm_get_page_prot(vma->vm_flags));\r\n}\r\n}\r\nint udl_dumb_create(struct drm_file *file,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nargs->pitch = args->width * DIV_ROUND_UP(args->bpp, 8);\r\nargs->size = args->pitch * args->height;\r\nreturn udl_gem_create(file, dev,\r\nargs->size, &args->handle);\r\n}\r\nint udl_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret)\r\nreturn ret;\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_flags |= VM_MIXEDMAP;\r\nupdate_vm_cache_attr(to_udl_bo(vma->vm_private_data), vma);\r\nreturn ret;\r\n}\r\nint udl_gem_fault(struct vm_fault *vmf)\r\n{\r\nstruct vm_area_struct *vma = vmf->vma;\r\nstruct udl_gem_object *obj = to_udl_bo(vma->vm_private_data);\r\nstruct page *page;\r\nunsigned int page_offset;\r\nint ret = 0;\r\npage_offset = (vmf->address - vma->vm_start) >> PAGE_SHIFT;\r\nif (!obj->pages)\r\nreturn VM_FAULT_SIGBUS;\r\npage = obj->pages[page_offset];\r\nret = vm_insert_page(vma, vmf->address, page);\r\nswitch (ret) {\r\ncase -EAGAIN:\r\ncase 0:\r\ncase -ERESTARTSYS:\r\nreturn VM_FAULT_NOPAGE;\r\ncase -ENOMEM:\r\nreturn VM_FAULT_OOM;\r\ndefault:\r\nreturn VM_FAULT_SIGBUS;\r\n}\r\n}\r\nint udl_gem_get_pages(struct udl_gem_object *obj)\r\n{\r\nstruct page **pages;\r\nif (obj->pages)\r\nreturn 0;\r\npages = drm_gem_get_pages(&obj->base);\r\nif (IS_ERR(pages))\r\nreturn PTR_ERR(pages);\r\nobj->pages = pages;\r\nreturn 0;\r\n}\r\nvoid udl_gem_put_pages(struct udl_gem_object *obj)\r\n{\r\nif (obj->base.import_attach) {\r\ndrm_free_large(obj->pages);\r\nobj->pages = NULL;\r\nreturn;\r\n}\r\ndrm_gem_put_pages(&obj->base, obj->pages, false, false);\r\nobj->pages = NULL;\r\n}\r\nint udl_gem_vmap(struct udl_gem_object *obj)\r\n{\r\nint page_count = obj->base.size / PAGE_SIZE;\r\nint ret;\r\nif (obj->base.import_attach) {\r\nobj->vmapping = dma_buf_vmap(obj->base.import_attach->dmabuf);\r\nif (!obj->vmapping)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nret = udl_gem_get_pages(obj);\r\nif (ret)\r\nreturn ret;\r\nobj->vmapping = vmap(obj->pages, page_count, 0, PAGE_KERNEL);\r\nif (!obj->vmapping)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid udl_gem_vunmap(struct udl_gem_object *obj)\r\n{\r\nif (obj->base.import_attach) {\r\ndma_buf_vunmap(obj->base.import_attach->dmabuf, obj->vmapping);\r\nreturn;\r\n}\r\nvunmap(obj->vmapping);\r\nudl_gem_put_pages(obj);\r\n}\r\nvoid udl_gem_free_object(struct drm_gem_object *gem_obj)\r\n{\r\nstruct udl_gem_object *obj = to_udl_bo(gem_obj);\r\nif (obj->vmapping)\r\nudl_gem_vunmap(obj);\r\nif (gem_obj->import_attach) {\r\ndrm_prime_gem_destroy(gem_obj, obj->sg);\r\nput_device(gem_obj->dev->dev);\r\n}\r\nif (obj->pages)\r\nudl_gem_put_pages(obj);\r\ndrm_gem_free_mmap_offset(gem_obj);\r\n}\r\nint udl_gem_mmap(struct drm_file *file, struct drm_device *dev,\r\nuint32_t handle, uint64_t *offset)\r\n{\r\nstruct udl_gem_object *gobj;\r\nstruct drm_gem_object *obj;\r\nint ret = 0;\r\nmutex_lock(&dev->struct_mutex);\r\nobj = drm_gem_object_lookup(file, handle);\r\nif (obj == NULL) {\r\nret = -ENOENT;\r\ngoto unlock;\r\n}\r\ngobj = to_udl_bo(obj);\r\nret = udl_gem_get_pages(gobj);\r\nif (ret)\r\ngoto out;\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto out;\r\n*offset = drm_vma_node_offset_addr(&gobj->base.vma_node);\r\nout:\r\ndrm_gem_object_unreference(&gobj->base);\r\nunlock:\r\nmutex_unlock(&dev->struct_mutex);\r\nreturn ret;\r\n}
