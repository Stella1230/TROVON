static int usb_serial_device_match(struct device *dev,\r\nstruct device_driver *drv)\r\n{\r\nstruct usb_serial_driver *driver;\r\nconst struct usb_serial_port *port;\r\nport = to_usb_serial_port(dev);\r\nif (!port)\r\nreturn 0;\r\ndriver = to_usb_serial_driver(drv);\r\nif (driver == port->serial->type)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int usb_serial_device_probe(struct device *dev)\r\n{\r\nstruct usb_serial_driver *driver;\r\nstruct usb_serial_port *port;\r\nstruct device *tty_dev;\r\nint retval = 0;\r\nint minor;\r\nport = to_usb_serial_port(dev);\r\nif (!port)\r\nreturn -ENODEV;\r\nretval = usb_autopm_get_interface(port->serial->interface);\r\nif (retval)\r\nreturn retval;\r\ndriver = port->serial->type;\r\nif (driver->port_probe) {\r\nretval = driver->port_probe(port);\r\nif (retval)\r\ngoto err_autopm_put;\r\n}\r\nminor = port->minor;\r\ntty_dev = tty_register_device(usb_serial_tty_driver, minor, dev);\r\nif (IS_ERR(tty_dev)) {\r\nretval = PTR_ERR(tty_dev);\r\ngoto err_port_remove;\r\n}\r\nusb_autopm_put_interface(port->serial->interface);\r\ndev_info(&port->serial->dev->dev,\r\n"%s converter now attached to ttyUSB%d\n",\r\ndriver->description, minor);\r\nreturn 0;\r\nerr_port_remove:\r\nif (driver->port_remove)\r\ndriver->port_remove(port);\r\nerr_autopm_put:\r\nusb_autopm_put_interface(port->serial->interface);\r\nreturn retval;\r\n}\r\nstatic int usb_serial_device_remove(struct device *dev)\r\n{\r\nstruct usb_serial_driver *driver;\r\nstruct usb_serial_port *port;\r\nint retval = 0;\r\nint minor;\r\nint autopm_err;\r\nport = to_usb_serial_port(dev);\r\nif (!port)\r\nreturn -ENODEV;\r\nautopm_err = usb_autopm_get_interface(port->serial->interface);\r\nminor = port->minor;\r\ntty_unregister_device(usb_serial_tty_driver, minor);\r\ndriver = port->serial->type;\r\nif (driver->port_remove)\r\nretval = driver->port_remove(port);\r\ndev_info(dev, "%s converter now disconnected from ttyUSB%d\n",\r\ndriver->description, minor);\r\nif (!autopm_err)\r\nusb_autopm_put_interface(port->serial->interface);\r\nreturn retval;\r\n}\r\nstatic ssize_t new_id_store(struct device_driver *driver,\r\nconst char *buf, size_t count)\r\n{\r\nstruct usb_serial_driver *usb_drv = to_usb_serial_driver(driver);\r\nssize_t retval = usb_store_new_id(&usb_drv->dynids, usb_drv->id_table,\r\ndriver, buf, count);\r\nif (retval >= 0 && usb_drv->usb_driver != NULL)\r\nretval = usb_store_new_id(&usb_drv->usb_driver->dynids,\r\nusb_drv->usb_driver->id_table,\r\n&usb_drv->usb_driver->drvwrap.driver,\r\nbuf, count);\r\nreturn retval;\r\n}\r\nstatic ssize_t new_id_show(struct device_driver *driver, char *buf)\r\n{\r\nstruct usb_serial_driver *usb_drv = to_usb_serial_driver(driver);\r\nreturn usb_show_dynids(&usb_drv->dynids, buf);\r\n}\r\nstatic void free_dynids(struct usb_serial_driver *drv)\r\n{\r\nstruct usb_dynid *dynid, *n;\r\nspin_lock(&drv->dynids.lock);\r\nlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\r\nlist_del(&dynid->node);\r\nkfree(dynid);\r\n}\r\nspin_unlock(&drv->dynids.lock);\r\n}\r\nint usb_serial_bus_register(struct usb_serial_driver *driver)\r\n{\r\nint retval;\r\ndriver->driver.bus = &usb_serial_bus_type;\r\nspin_lock_init(&driver->dynids.lock);\r\nINIT_LIST_HEAD(&driver->dynids.list);\r\nretval = driver_register(&driver->driver);\r\nreturn retval;\r\n}\r\nvoid usb_serial_bus_deregister(struct usb_serial_driver *driver)\r\n{\r\nfree_dynids(driver);\r\ndriver_unregister(&driver->driver);\r\n}
