static unsigned int pv88060_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct pv88060_regulator *info = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret, mode = 0;\r\nret = regmap_read(rdev->regmap, info->conf, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (data & PV88060_BUCK_MODE_MASK) {\r\ncase PV88060_BUCK_MODE_SYNC:\r\nmode = REGULATOR_MODE_FAST;\r\nbreak;\r\ncase PV88060_BUCK_MODE_AUTO:\r\nmode = REGULATOR_MODE_NORMAL;\r\nbreak;\r\ncase PV88060_BUCK_MODE_SLEEP:\r\nmode = REGULATOR_MODE_STANDBY;\r\nbreak;\r\n}\r\nreturn mode;\r\n}\r\nstatic int pv88060_buck_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct pv88060_regulator *info = rdev_get_drvdata(rdev);\r\nint val = 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = PV88060_BUCK_MODE_SYNC;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = PV88060_BUCK_MODE_AUTO;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = PV88060_BUCK_MODE_SLEEP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, info->conf,\r\nPV88060_BUCK_MODE_MASK, val);\r\n}\r\nstatic int pv88060_set_current_limit(struct regulator_dev *rdev, int min,\r\nint max)\r\n{\r\nstruct pv88060_regulator *info = rdev_get_drvdata(rdev);\r\nint i;\r\nfor (i = info->n_current_limits; i >= 0; i--) {\r\nif (min <= info->current_limits[i]\r\n&& max >= info->current_limits[i]) {\r\nreturn regmap_update_bits(rdev->regmap,\r\ninfo->conf,\r\ninfo->limit_mask,\r\ni << PV88060_BUCK_ILIM_SHIFT);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pv88060_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct pv88060_regulator *info = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret;\r\nret = regmap_read(rdev->regmap, info->conf, &data);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = (data & info->limit_mask) >> PV88060_BUCK_ILIM_SHIFT;\r\nreturn info->current_limits[data];\r\n}\r\nstatic irqreturn_t pv88060_irq_handler(int irq, void *data)\r\n{\r\nstruct pv88060 *chip = data;\r\nint i, reg_val, err, ret = IRQ_NONE;\r\nerr = regmap_read(chip->regmap, PV88060_REG_EVENT_A, &reg_val);\r\nif (err < 0)\r\ngoto error_i2c;\r\nif (reg_val & PV88060_E_VDD_FLT) {\r\nfor (i = 0; i < PV88060_MAX_REGULATORS; i++) {\r\nif (chip->rdev[i] != NULL) {\r\nregulator_notifier_call_chain(chip->rdev[i],\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nNULL);\r\n}\r\n}\r\nerr = regmap_write(chip->regmap, PV88060_REG_EVENT_A,\r\nPV88060_E_VDD_FLT);\r\nif (err < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nif (reg_val & PV88060_E_OVER_TEMP) {\r\nfor (i = 0; i < PV88060_MAX_REGULATORS; i++) {\r\nif (chip->rdev[i] != NULL) {\r\nregulator_notifier_call_chain(chip->rdev[i],\r\nREGULATOR_EVENT_OVER_TEMP,\r\nNULL);\r\n}\r\n}\r\nerr = regmap_write(chip->regmap, PV88060_REG_EVENT_A,\r\nPV88060_E_OVER_TEMP);\r\nif (err < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\nerror_i2c:\r\ndev_err(chip->dev, "I2C error : %d\n", err);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pv88060_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct regulator_init_data *init_data = dev_get_platdata(&i2c->dev);\r\nstruct pv88060 *chip;\r\nstruct regulator_config config = { };\r\nint error, i, ret = 0;\r\nchip = devm_kzalloc(&i2c->dev, sizeof(struct pv88060), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = &i2c->dev;\r\nchip->regmap = devm_regmap_init_i2c(i2c, &pv88060_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\nerror = PTR_ERR(chip->regmap);\r\ndev_err(chip->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\ni2c_set_clientdata(i2c, chip);\r\nif (i2c->irq != 0) {\r\nret = regmap_write(chip->regmap, PV88060_REG_MASK_A, 0xFF);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to mask A reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(chip->regmap, PV88060_REG_MASK_B, 0xFF);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to mask B reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(chip->regmap, PV88060_REG_MASK_C, 0xFF);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to mask C reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\r\npv88060_irq_handler,\r\nIRQF_TRIGGER_LOW|IRQF_ONESHOT,\r\n"pv88060", chip);\r\nif (ret != 0) {\r\ndev_err(chip->dev, "Failed to request IRQ: %d\n",\r\ni2c->irq);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(chip->regmap, PV88060_REG_MASK_A,\r\nPV88060_M_VDD_FLT | PV88060_M_OVER_TEMP, 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to update mask reg: %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\ndev_warn(chip->dev, "No IRQ configured\n");\r\n}\r\nconfig.dev = chip->dev;\r\nconfig.regmap = chip->regmap;\r\nfor (i = 0; i < PV88060_MAX_REGULATORS; i++) {\r\nif (init_data)\r\nconfig.init_data = &init_data[i];\r\nconfig.driver_data = (void *)&pv88060_regulator_info[i];\r\nchip->rdev[i] = devm_regulator_register(chip->dev,\r\n&pv88060_regulator_info[i].desc, &config);\r\nif (IS_ERR(chip->rdev[i])) {\r\ndev_err(chip->dev,\r\n"Failed to register PV88060 regulator\n");\r\nreturn PTR_ERR(chip->rdev[i]);\r\n}\r\n}\r\nreturn 0;\r\n}
