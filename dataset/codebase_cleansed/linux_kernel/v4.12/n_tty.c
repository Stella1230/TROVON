static inline size_t read_cnt(struct n_tty_data *ldata)\r\n{\r\nreturn ldata->read_head - ldata->read_tail;\r\n}\r\nstatic inline unsigned char read_buf(struct n_tty_data *ldata, size_t i)\r\n{\r\nreturn ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\r\n}\r\nstatic inline unsigned char *read_buf_addr(struct n_tty_data *ldata, size_t i)\r\n{\r\nreturn &ldata->read_buf[i & (N_TTY_BUF_SIZE - 1)];\r\n}\r\nstatic inline unsigned char echo_buf(struct n_tty_data *ldata, size_t i)\r\n{\r\nreturn ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\r\n}\r\nstatic inline unsigned char *echo_buf_addr(struct n_tty_data *ldata, size_t i)\r\n{\r\nreturn &ldata->echo_buf[i & (N_TTY_BUF_SIZE - 1)];\r\n}\r\nstatic int tty_copy_to_user(struct tty_struct *tty, void __user *to,\r\nsize_t tail, size_t n)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nsize_t size = N_TTY_BUF_SIZE - tail;\r\nconst void *from = read_buf_addr(ldata, tail);\r\nint uncopied;\r\nif (n > size) {\r\ntty_audit_add_data(tty, from, size);\r\nuncopied = copy_to_user(to, from, size);\r\nif (uncopied)\r\nreturn uncopied;\r\nto += size;\r\nn -= size;\r\nfrom = ldata->read_buf;\r\n}\r\ntty_audit_add_data(tty, from, n);\r\nreturn copy_to_user(to, from, n);\r\n}\r\nstatic void n_tty_kick_worker(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (unlikely(ldata->no_room)) {\r\nldata->no_room = 0;\r\nWARN_RATELIMIT(tty->port->itty == NULL,\r\n"scheduling with invalid itty\n");\r\nWARN_RATELIMIT(test_bit(TTY_LDISC_HALTED, &tty->flags),\r\n"scheduling buffer work for halted ldisc\n");\r\ntty_buffer_restart_work(tty->port);\r\n}\r\n}\r\nstatic ssize_t chars_in_buffer(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nssize_t n = 0;\r\nif (!ldata->icanon)\r\nn = ldata->commit_head - ldata->read_tail;\r\nelse\r\nn = ldata->canon_head - ldata->read_tail;\r\nreturn n;\r\n}\r\nstatic void n_tty_write_wakeup(struct tty_struct *tty)\r\n{\r\nclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nkill_fasync(&tty->fasync, SIGIO, POLL_OUT);\r\n}\r\nstatic void n_tty_check_throttle(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (ldata->icanon && ldata->canon_head == ldata->read_tail)\r\nreturn;\r\nwhile (1) {\r\nint throttled;\r\ntty_set_flow_change(tty, TTY_THROTTLE_SAFE);\r\nif (N_TTY_BUF_SIZE - read_cnt(ldata) >= TTY_THRESHOLD_THROTTLE)\r\nbreak;\r\nthrottled = tty_throttle_safe(tty);\r\nif (!throttled)\r\nbreak;\r\n}\r\n__tty_set_flow_change(tty, 0);\r\n}\r\nstatic void n_tty_check_unthrottle(struct tty_struct *tty)\r\n{\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\r\nif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\r\nreturn;\r\nn_tty_kick_worker(tty);\r\ntty_wakeup(tty->link);\r\nreturn;\r\n}\r\nwhile (1) {\r\nint unthrottled;\r\ntty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\r\nif (chars_in_buffer(tty) > TTY_THRESHOLD_UNTHROTTLE)\r\nbreak;\r\nn_tty_kick_worker(tty);\r\nunthrottled = tty_unthrottle_safe(tty);\r\nif (!unthrottled)\r\nbreak;\r\n}\r\n__tty_set_flow_change(tty, 0);\r\n}\r\nstatic inline void put_tty_queue(unsigned char c, struct n_tty_data *ldata)\r\n{\r\n*read_buf_addr(ldata, ldata->read_head) = c;\r\nldata->read_head++;\r\n}\r\nstatic void reset_buffer_flags(struct n_tty_data *ldata)\r\n{\r\nldata->read_head = ldata->canon_head = ldata->read_tail = 0;\r\nldata->echo_head = ldata->echo_tail = ldata->echo_commit = 0;\r\nldata->commit_head = 0;\r\nldata->echo_mark = 0;\r\nldata->line_start = 0;\r\nldata->erasing = 0;\r\nbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\r\nldata->push = 0;\r\n}\r\nstatic void n_tty_packet_mode_flush(struct tty_struct *tty)\r\n{\r\nunsigned long flags;\r\nif (tty->link->packet) {\r\nspin_lock_irqsave(&tty->ctrl_lock, flags);\r\ntty->ctrl_status |= TIOCPKT_FLUSHREAD;\r\nspin_unlock_irqrestore(&tty->ctrl_lock, flags);\r\nwake_up_interruptible(&tty->link->read_wait);\r\n}\r\n}\r\nstatic void n_tty_flush_buffer(struct tty_struct *tty)\r\n{\r\ndown_write(&tty->termios_rwsem);\r\nreset_buffer_flags(tty->disc_data);\r\nn_tty_kick_worker(tty);\r\nif (tty->link)\r\nn_tty_packet_mode_flush(tty);\r\nup_write(&tty->termios_rwsem);\r\n}\r\nstatic inline int is_utf8_continuation(unsigned char c)\r\n{\r\nreturn (c & 0xc0) == 0x80;\r\n}\r\nstatic inline int is_continuation(unsigned char c, struct tty_struct *tty)\r\n{\r\nreturn I_IUTF8(tty) && is_utf8_continuation(c);\r\n}\r\nstatic int do_output_char(unsigned char c, struct tty_struct *tty, int space)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint spaces;\r\nif (!space)\r\nreturn -1;\r\nswitch (c) {\r\ncase '\n':\r\nif (O_ONLRET(tty))\r\nldata->column = 0;\r\nif (O_ONLCR(tty)) {\r\nif (space < 2)\r\nreturn -1;\r\nldata->canon_column = ldata->column = 0;\r\ntty->ops->write(tty, "\r\n", 2);\r\nreturn 2;\r\n}\r\nldata->canon_column = ldata->column;\r\nbreak;\r\ncase '\r':\r\nif (O_ONOCR(tty) && ldata->column == 0)\r\nreturn 0;\r\nif (O_OCRNL(tty)) {\r\nc = '\n';\r\nif (O_ONLRET(tty))\r\nldata->canon_column = ldata->column = 0;\r\nbreak;\r\n}\r\nldata->canon_column = ldata->column = 0;\r\nbreak;\r\ncase '\t':\r\nspaces = 8 - (ldata->column & 7);\r\nif (O_TABDLY(tty) == XTABS) {\r\nif (space < spaces)\r\nreturn -1;\r\nldata->column += spaces;\r\ntty->ops->write(tty, " ", spaces);\r\nreturn spaces;\r\n}\r\nldata->column += spaces;\r\nbreak;\r\ncase '\b':\r\nif (ldata->column > 0)\r\nldata->column--;\r\nbreak;\r\ndefault:\r\nif (!iscntrl(c)) {\r\nif (O_OLCUC(tty))\r\nc = toupper(c);\r\nif (!is_continuation(c, tty))\r\nldata->column++;\r\n}\r\nbreak;\r\n}\r\ntty_put_char(tty, c);\r\nreturn 1;\r\n}\r\nstatic int process_output(unsigned char c, struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint space, retval;\r\nmutex_lock(&ldata->output_lock);\r\nspace = tty_write_room(tty);\r\nretval = do_output_char(c, tty, space);\r\nmutex_unlock(&ldata->output_lock);\r\nif (retval < 0)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic ssize_t process_output_block(struct tty_struct *tty,\r\nconst unsigned char *buf, unsigned int nr)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint space;\r\nint i;\r\nconst unsigned char *cp;\r\nmutex_lock(&ldata->output_lock);\r\nspace = tty_write_room(tty);\r\nif (!space) {\r\nmutex_unlock(&ldata->output_lock);\r\nreturn 0;\r\n}\r\nif (nr > space)\r\nnr = space;\r\nfor (i = 0, cp = buf; i < nr; i++, cp++) {\r\nunsigned char c = *cp;\r\nswitch (c) {\r\ncase '\n':\r\nif (O_ONLRET(tty))\r\nldata->column = 0;\r\nif (O_ONLCR(tty))\r\ngoto break_out;\r\nldata->canon_column = ldata->column;\r\nbreak;\r\ncase '\r':\r\nif (O_ONOCR(tty) && ldata->column == 0)\r\ngoto break_out;\r\nif (O_OCRNL(tty))\r\ngoto break_out;\r\nldata->canon_column = ldata->column = 0;\r\nbreak;\r\ncase '\t':\r\ngoto break_out;\r\ncase '\b':\r\nif (ldata->column > 0)\r\nldata->column--;\r\nbreak;\r\ndefault:\r\nif (!iscntrl(c)) {\r\nif (O_OLCUC(tty))\r\ngoto break_out;\r\nif (!is_continuation(c, tty))\r\nldata->column++;\r\n}\r\nbreak;\r\n}\r\n}\r\nbreak_out:\r\ni = tty->ops->write(tty, buf, i);\r\nmutex_unlock(&ldata->output_lock);\r\nreturn i;\r\n}\r\nstatic size_t __process_echoes(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint space, old_space;\r\nsize_t tail;\r\nunsigned char c;\r\nold_space = space = tty_write_room(tty);\r\ntail = ldata->echo_tail;\r\nwhile (ldata->echo_commit != tail) {\r\nc = echo_buf(ldata, tail);\r\nif (c == ECHO_OP_START) {\r\nunsigned char op;\r\nint no_space_left = 0;\r\nop = echo_buf(ldata, tail + 1);\r\nswitch (op) {\r\nunsigned int num_chars, num_bs;\r\ncase ECHO_OP_ERASE_TAB:\r\nnum_chars = echo_buf(ldata, tail + 2);\r\nif (!(num_chars & 0x80))\r\nnum_chars += ldata->canon_column;\r\nnum_bs = 8 - (num_chars & 7);\r\nif (num_bs > space) {\r\nno_space_left = 1;\r\nbreak;\r\n}\r\nspace -= num_bs;\r\nwhile (num_bs--) {\r\ntty_put_char(tty, '\b');\r\nif (ldata->column > 0)\r\nldata->column--;\r\n}\r\ntail += 3;\r\nbreak;\r\ncase ECHO_OP_SET_CANON_COL:\r\nldata->canon_column = ldata->column;\r\ntail += 2;\r\nbreak;\r\ncase ECHO_OP_MOVE_BACK_COL:\r\nif (ldata->column > 0)\r\nldata->column--;\r\ntail += 2;\r\nbreak;\r\ncase ECHO_OP_START:\r\nif (!space) {\r\nno_space_left = 1;\r\nbreak;\r\n}\r\ntty_put_char(tty, ECHO_OP_START);\r\nldata->column++;\r\nspace--;\r\ntail += 2;\r\nbreak;\r\ndefault:\r\nif (space < 2) {\r\nno_space_left = 1;\r\nbreak;\r\n}\r\ntty_put_char(tty, '^');\r\ntty_put_char(tty, op ^ 0100);\r\nldata->column += 2;\r\nspace -= 2;\r\ntail += 2;\r\n}\r\nif (no_space_left)\r\nbreak;\r\n} else {\r\nif (O_OPOST(tty)) {\r\nint retval = do_output_char(c, tty, space);\r\nif (retval < 0)\r\nbreak;\r\nspace -= retval;\r\n} else {\r\nif (!space)\r\nbreak;\r\ntty_put_char(tty, c);\r\nspace -= 1;\r\n}\r\ntail += 1;\r\n}\r\n}\r\nwhile (ldata->echo_commit - tail >= ECHO_DISCARD_WATERMARK) {\r\nif (echo_buf(ldata, tail) == ECHO_OP_START) {\r\nif (echo_buf(ldata, tail + 1) == ECHO_OP_ERASE_TAB)\r\ntail += 3;\r\nelse\r\ntail += 2;\r\n} else\r\ntail++;\r\n}\r\nldata->echo_tail = tail;\r\nreturn old_space - space;\r\n}\r\nstatic void commit_echoes(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nsize_t nr, old, echoed;\r\nsize_t head;\r\nhead = ldata->echo_head;\r\nldata->echo_mark = head;\r\nold = ldata->echo_commit - ldata->echo_tail;\r\nnr = head - ldata->echo_tail;\r\nif (nr < ECHO_COMMIT_WATERMARK || (nr % ECHO_BLOCK > old % ECHO_BLOCK))\r\nreturn;\r\nmutex_lock(&ldata->output_lock);\r\nldata->echo_commit = head;\r\nechoed = __process_echoes(tty);\r\nmutex_unlock(&ldata->output_lock);\r\nif (echoed && tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n}\r\nstatic void process_echoes(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nsize_t echoed;\r\nif (ldata->echo_mark == ldata->echo_tail)\r\nreturn;\r\nmutex_lock(&ldata->output_lock);\r\nldata->echo_commit = ldata->echo_mark;\r\nechoed = __process_echoes(tty);\r\nmutex_unlock(&ldata->output_lock);\r\nif (echoed && tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n}\r\nstatic void flush_echoes(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif ((!L_ECHO(tty) && !L_ECHONL(tty)) ||\r\nldata->echo_commit == ldata->echo_head)\r\nreturn;\r\nmutex_lock(&ldata->output_lock);\r\nldata->echo_commit = ldata->echo_head;\r\n__process_echoes(tty);\r\nmutex_unlock(&ldata->output_lock);\r\n}\r\nstatic inline void add_echo_byte(unsigned char c, struct n_tty_data *ldata)\r\n{\r\n*echo_buf_addr(ldata, ldata->echo_head++) = c;\r\n}\r\nstatic void echo_move_back_col(struct n_tty_data *ldata)\r\n{\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\nadd_echo_byte(ECHO_OP_MOVE_BACK_COL, ldata);\r\n}\r\nstatic void echo_set_canon_col(struct n_tty_data *ldata)\r\n{\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\nadd_echo_byte(ECHO_OP_SET_CANON_COL, ldata);\r\n}\r\nstatic void echo_erase_tab(unsigned int num_chars, int after_tab,\r\nstruct n_tty_data *ldata)\r\n{\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\nadd_echo_byte(ECHO_OP_ERASE_TAB, ldata);\r\nnum_chars &= 7;\r\nif (after_tab)\r\nnum_chars |= 0x80;\r\nadd_echo_byte(num_chars, ldata);\r\n}\r\nstatic void echo_char_raw(unsigned char c, struct n_tty_data *ldata)\r\n{\r\nif (c == ECHO_OP_START) {\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\n} else {\r\nadd_echo_byte(c, ldata);\r\n}\r\n}\r\nstatic void echo_char(unsigned char c, struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (c == ECHO_OP_START) {\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\n} else {\r\nif (L_ECHOCTL(tty) && iscntrl(c) && c != '\t')\r\nadd_echo_byte(ECHO_OP_START, ldata);\r\nadd_echo_byte(c, ldata);\r\n}\r\n}\r\nstatic inline void finish_erasing(struct n_tty_data *ldata)\r\n{\r\nif (ldata->erasing) {\r\necho_char_raw('/', ldata);\r\nldata->erasing = 0;\r\n}\r\n}\r\nstatic void eraser(unsigned char c, struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nenum { ERASE, WERASE, KILL } kill_type;\r\nsize_t head;\r\nsize_t cnt;\r\nint seen_alnums;\r\nif (ldata->read_head == ldata->canon_head) {\r\nreturn;\r\n}\r\nif (c == ERASE_CHAR(tty))\r\nkill_type = ERASE;\r\nelse if (c == WERASE_CHAR(tty))\r\nkill_type = WERASE;\r\nelse {\r\nif (!L_ECHO(tty)) {\r\nldata->read_head = ldata->canon_head;\r\nreturn;\r\n}\r\nif (!L_ECHOK(tty) || !L_ECHOKE(tty) || !L_ECHOE(tty)) {\r\nldata->read_head = ldata->canon_head;\r\nfinish_erasing(ldata);\r\necho_char(KILL_CHAR(tty), tty);\r\nif (L_ECHOK(tty))\r\necho_char_raw('\n', ldata);\r\nreturn;\r\n}\r\nkill_type = KILL;\r\n}\r\nseen_alnums = 0;\r\nwhile (ldata->read_head != ldata->canon_head) {\r\nhead = ldata->read_head;\r\ndo {\r\nhead--;\r\nc = read_buf(ldata, head);\r\n} while (is_continuation(c, tty) && head != ldata->canon_head);\r\nif (is_continuation(c, tty))\r\nbreak;\r\nif (kill_type == WERASE) {\r\nif (isalnum(c) || c == '_')\r\nseen_alnums++;\r\nelse if (seen_alnums)\r\nbreak;\r\n}\r\ncnt = ldata->read_head - head;\r\nldata->read_head = head;\r\nif (L_ECHO(tty)) {\r\nif (L_ECHOPRT(tty)) {\r\nif (!ldata->erasing) {\r\necho_char_raw('\\', ldata);\r\nldata->erasing = 1;\r\n}\r\necho_char(c, tty);\r\nwhile (--cnt > 0) {\r\nhead++;\r\necho_char_raw(read_buf(ldata, head), ldata);\r\necho_move_back_col(ldata);\r\n}\r\n} else if (kill_type == ERASE && !L_ECHOE(tty)) {\r\necho_char(ERASE_CHAR(tty), tty);\r\n} else if (c == '\t') {\r\nunsigned int num_chars = 0;\r\nint after_tab = 0;\r\nsize_t tail = ldata->read_head;\r\nwhile (tail != ldata->canon_head) {\r\ntail--;\r\nc = read_buf(ldata, tail);\r\nif (c == '\t') {\r\nafter_tab = 1;\r\nbreak;\r\n} else if (iscntrl(c)) {\r\nif (L_ECHOCTL(tty))\r\nnum_chars += 2;\r\n} else if (!is_continuation(c, tty)) {\r\nnum_chars++;\r\n}\r\n}\r\necho_erase_tab(num_chars, after_tab, ldata);\r\n} else {\r\nif (iscntrl(c) && L_ECHOCTL(tty)) {\r\necho_char_raw('\b', ldata);\r\necho_char_raw(' ', ldata);\r\necho_char_raw('\b', ldata);\r\n}\r\nif (!iscntrl(c) || L_ECHOCTL(tty)) {\r\necho_char_raw('\b', ldata);\r\necho_char_raw(' ', ldata);\r\necho_char_raw('\b', ldata);\r\n}\r\n}\r\n}\r\nif (kill_type == ERASE)\r\nbreak;\r\n}\r\nif (ldata->read_head == ldata->canon_head && L_ECHO(tty))\r\nfinish_erasing(ldata);\r\n}\r\nstatic void __isig(int sig, struct tty_struct *tty)\r\n{\r\nstruct pid *tty_pgrp = tty_get_pgrp(tty);\r\nif (tty_pgrp) {\r\nkill_pgrp(tty_pgrp, sig, 1);\r\nput_pid(tty_pgrp);\r\n}\r\n}\r\nstatic void isig(int sig, struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (L_NOFLSH(tty)) {\r\n__isig(sig, tty);\r\n} else {\r\nup_read(&tty->termios_rwsem);\r\ndown_write(&tty->termios_rwsem);\r\n__isig(sig, tty);\r\nmutex_lock(&ldata->output_lock);\r\nldata->echo_head = ldata->echo_tail = 0;\r\nldata->echo_mark = ldata->echo_commit = 0;\r\nmutex_unlock(&ldata->output_lock);\r\ntty_driver_flush_buffer(tty);\r\nreset_buffer_flags(tty->disc_data);\r\nif (tty->link)\r\nn_tty_packet_mode_flush(tty);\r\nup_write(&tty->termios_rwsem);\r\ndown_read(&tty->termios_rwsem);\r\n}\r\n}\r\nstatic void n_tty_receive_break(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (I_IGNBRK(tty))\r\nreturn;\r\nif (I_BRKINT(tty)) {\r\nisig(SIGINT, tty);\r\nreturn;\r\n}\r\nif (I_PARMRK(tty)) {\r\nput_tty_queue('\377', ldata);\r\nput_tty_queue('\0', ldata);\r\n}\r\nput_tty_queue('\0', ldata);\r\n}\r\nstatic void n_tty_receive_overrun(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nldata->num_overrun++;\r\nif (time_after(jiffies, ldata->overrun_time + HZ) ||\r\ntime_after(ldata->overrun_time, jiffies)) {\r\ntty_warn(tty, "%d input overrun(s)\n", ldata->num_overrun);\r\nldata->overrun_time = jiffies;\r\nldata->num_overrun = 0;\r\n}\r\n}\r\nstatic void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (I_INPCK(tty)) {\r\nif (I_IGNPAR(tty))\r\nreturn;\r\nif (I_PARMRK(tty)) {\r\nput_tty_queue('\377', ldata);\r\nput_tty_queue('\0', ldata);\r\nput_tty_queue(c, ldata);\r\n} else\r\nput_tty_queue('\0', ldata);\r\n} else\r\nput_tty_queue(c, ldata);\r\n}\r\nstatic void\r\nn_tty_receive_signal_char(struct tty_struct *tty, int signal, unsigned char c)\r\n{\r\nisig(signal, tty);\r\nif (I_IXON(tty))\r\nstart_tty(tty);\r\nif (L_ECHO(tty)) {\r\necho_char(c, tty);\r\ncommit_echoes(tty);\r\n} else\r\nprocess_echoes(tty);\r\nreturn;\r\n}\r\nstatic int\r\nn_tty_receive_char_special(struct tty_struct *tty, unsigned char c)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (I_IXON(tty)) {\r\nif (c == START_CHAR(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\nreturn 0;\r\n}\r\nif (c == STOP_CHAR(tty)) {\r\nstop_tty(tty);\r\nreturn 0;\r\n}\r\n}\r\nif (L_ISIG(tty)) {\r\nif (c == INTR_CHAR(tty)) {\r\nn_tty_receive_signal_char(tty, SIGINT, c);\r\nreturn 0;\r\n} else if (c == QUIT_CHAR(tty)) {\r\nn_tty_receive_signal_char(tty, SIGQUIT, c);\r\nreturn 0;\r\n} else if (c == SUSP_CHAR(tty)) {\r\nn_tty_receive_signal_char(tty, SIGTSTP, c);\r\nreturn 0;\r\n}\r\n}\r\nif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n}\r\nif (c == '\r') {\r\nif (I_IGNCR(tty))\r\nreturn 0;\r\nif (I_ICRNL(tty))\r\nc = '\n';\r\n} else if (c == '\n' && I_INLCR(tty))\r\nc = '\r';\r\nif (ldata->icanon) {\r\nif (c == ERASE_CHAR(tty) || c == KILL_CHAR(tty) ||\r\n(c == WERASE_CHAR(tty) && L_IEXTEN(tty))) {\r\neraser(c, tty);\r\ncommit_echoes(tty);\r\nreturn 0;\r\n}\r\nif (c == LNEXT_CHAR(tty) && L_IEXTEN(tty)) {\r\nldata->lnext = 1;\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(ldata);\r\nif (L_ECHOCTL(tty)) {\r\necho_char_raw('^', ldata);\r\necho_char_raw('\b', ldata);\r\ncommit_echoes(tty);\r\n}\r\n}\r\nreturn 1;\r\n}\r\nif (c == REPRINT_CHAR(tty) && L_ECHO(tty) && L_IEXTEN(tty)) {\r\nsize_t tail = ldata->canon_head;\r\nfinish_erasing(ldata);\r\necho_char(c, tty);\r\necho_char_raw('\n', ldata);\r\nwhile (tail != ldata->read_head) {\r\necho_char(read_buf(ldata, tail), tty);\r\ntail++;\r\n}\r\ncommit_echoes(tty);\r\nreturn 0;\r\n}\r\nif (c == '\n') {\r\nif (L_ECHO(tty) || L_ECHONL(tty)) {\r\necho_char_raw('\n', ldata);\r\ncommit_echoes(tty);\r\n}\r\ngoto handle_newline;\r\n}\r\nif (c == EOF_CHAR(tty)) {\r\nc = __DISABLED_CHAR;\r\ngoto handle_newline;\r\n}\r\nif ((c == EOL_CHAR(tty)) ||\r\n(c == EOL2_CHAR(tty) && L_IEXTEN(tty))) {\r\nif (L_ECHO(tty)) {\r\nif (ldata->canon_head == ldata->read_head)\r\necho_set_canon_col(ldata);\r\necho_char(c, tty);\r\ncommit_echoes(tty);\r\n}\r\nif (c == (unsigned char) '\377' && I_PARMRK(tty))\r\nput_tty_queue(c, ldata);\r\nhandle_newline:\r\nset_bit(ldata->read_head & (N_TTY_BUF_SIZE - 1), ldata->read_flags);\r\nput_tty_queue(c, ldata);\r\nsmp_store_release(&ldata->canon_head, ldata->read_head);\r\nkill_fasync(&tty->fasync, SIGIO, POLL_IN);\r\nwake_up_interruptible_poll(&tty->read_wait, POLLIN);\r\nreturn 0;\r\n}\r\n}\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(ldata);\r\nif (c == '\n')\r\necho_char_raw('\n', ldata);\r\nelse {\r\nif (ldata->canon_head == ldata->read_head)\r\necho_set_canon_col(ldata);\r\necho_char(c, tty);\r\n}\r\ncommit_echoes(tty);\r\n}\r\nif (c == (unsigned char) '\377' && I_PARMRK(tty))\r\nput_tty_queue(c, ldata);\r\nput_tty_queue(c, ldata);\r\nreturn 0;\r\n}\r\nstatic inline void\r\nn_tty_receive_char_inline(struct tty_struct *tty, unsigned char c)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n}\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(ldata);\r\nif (ldata->canon_head == ldata->read_head)\r\necho_set_canon_col(ldata);\r\necho_char(c, tty);\r\ncommit_echoes(tty);\r\n}\r\nif (c == (unsigned char) '\377' && I_PARMRK(tty))\r\nput_tty_queue(c, ldata);\r\nput_tty_queue(c, ldata);\r\n}\r\nstatic void n_tty_receive_char(struct tty_struct *tty, unsigned char c)\r\n{\r\nn_tty_receive_char_inline(tty, c);\r\n}\r\nstatic inline void\r\nn_tty_receive_char_fast(struct tty_struct *tty, unsigned char c)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (tty->stopped && !tty->flow_stopped && I_IXON(tty) && I_IXANY(tty)) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n}\r\nif (L_ECHO(tty)) {\r\nfinish_erasing(ldata);\r\nif (ldata->canon_head == ldata->read_head)\r\necho_set_canon_col(ldata);\r\necho_char(c, tty);\r\ncommit_echoes(tty);\r\n}\r\nput_tty_queue(c, ldata);\r\n}\r\nstatic void n_tty_receive_char_closing(struct tty_struct *tty, unsigned char c)\r\n{\r\nif (I_ISTRIP(tty))\r\nc &= 0x7f;\r\nif (I_IUCLC(tty) && L_IEXTEN(tty))\r\nc = tolower(c);\r\nif (I_IXON(tty)) {\r\nif (c == STOP_CHAR(tty))\r\nstop_tty(tty);\r\nelse if (c == START_CHAR(tty) ||\r\n(tty->stopped && !tty->flow_stopped && I_IXANY(tty) &&\r\nc != INTR_CHAR(tty) && c != QUIT_CHAR(tty) &&\r\nc != SUSP_CHAR(tty))) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n}\r\n}\r\n}\r\nstatic void\r\nn_tty_receive_char_flagged(struct tty_struct *tty, unsigned char c, char flag)\r\n{\r\nswitch (flag) {\r\ncase TTY_BREAK:\r\nn_tty_receive_break(tty);\r\nbreak;\r\ncase TTY_PARITY:\r\ncase TTY_FRAME:\r\nn_tty_receive_parity_error(tty, c);\r\nbreak;\r\ncase TTY_OVERRUN:\r\nn_tty_receive_overrun(tty);\r\nbreak;\r\ndefault:\r\ntty_err(tty, "unknown flag %d\n", flag);\r\nbreak;\r\n}\r\n}\r\nstatic void\r\nn_tty_receive_char_lnext(struct tty_struct *tty, unsigned char c, char flag)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nldata->lnext = 0;\r\nif (likely(flag == TTY_NORMAL)) {\r\nif (I_ISTRIP(tty))\r\nc &= 0x7f;\r\nif (I_IUCLC(tty) && L_IEXTEN(tty))\r\nc = tolower(c);\r\nn_tty_receive_char(tty, c);\r\n} else\r\nn_tty_receive_char_flagged(tty, c, flag);\r\n}\r\nstatic void\r\nn_tty_receive_buf_real_raw(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nsize_t n, head;\r\nhead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\r\nn = min_t(size_t, count, N_TTY_BUF_SIZE - head);\r\nmemcpy(read_buf_addr(ldata, head), cp, n);\r\nldata->read_head += n;\r\ncp += n;\r\ncount -= n;\r\nhead = ldata->read_head & (N_TTY_BUF_SIZE - 1);\r\nn = min_t(size_t, count, N_TTY_BUF_SIZE - head);\r\nmemcpy(read_buf_addr(ldata, head), cp, n);\r\nldata->read_head += n;\r\n}\r\nstatic void\r\nn_tty_receive_buf_raw(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nchar flag = TTY_NORMAL;\r\nwhile (count--) {\r\nif (fp)\r\nflag = *fp++;\r\nif (likely(flag == TTY_NORMAL))\r\nput_tty_queue(*cp++, ldata);\r\nelse\r\nn_tty_receive_char_flagged(tty, *cp++, flag);\r\n}\r\n}\r\nstatic void\r\nn_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nchar flag = TTY_NORMAL;\r\nwhile (count--) {\r\nif (fp)\r\nflag = *fp++;\r\nif (likely(flag == TTY_NORMAL))\r\nn_tty_receive_char_closing(tty, *cp++);\r\n}\r\n}\r\nstatic void\r\nn_tty_receive_buf_standard(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nchar flag = TTY_NORMAL;\r\nwhile (count--) {\r\nif (fp)\r\nflag = *fp++;\r\nif (likely(flag == TTY_NORMAL)) {\r\nunsigned char c = *cp++;\r\nif (I_ISTRIP(tty))\r\nc &= 0x7f;\r\nif (I_IUCLC(tty) && L_IEXTEN(tty))\r\nc = tolower(c);\r\nif (L_EXTPROC(tty)) {\r\nput_tty_queue(c, ldata);\r\ncontinue;\r\n}\r\nif (!test_bit(c, ldata->char_map))\r\nn_tty_receive_char_inline(tty, c);\r\nelse if (n_tty_receive_char_special(tty, c) && count) {\r\nif (fp)\r\nflag = *fp++;\r\nn_tty_receive_char_lnext(tty, *cp++, flag);\r\ncount--;\r\n}\r\n} else\r\nn_tty_receive_char_flagged(tty, *cp++, flag);\r\n}\r\n}\r\nstatic void\r\nn_tty_receive_buf_fast(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nchar flag = TTY_NORMAL;\r\nwhile (count--) {\r\nif (fp)\r\nflag = *fp++;\r\nif (likely(flag == TTY_NORMAL)) {\r\nunsigned char c = *cp++;\r\nif (!test_bit(c, ldata->char_map))\r\nn_tty_receive_char_fast(tty, c);\r\nelse if (n_tty_receive_char_special(tty, c) && count) {\r\nif (fp)\r\nflag = *fp++;\r\nn_tty_receive_char_lnext(tty, *cp++, flag);\r\ncount--;\r\n}\r\n} else\r\nn_tty_receive_char_flagged(tty, *cp++, flag);\r\n}\r\n}\r\nstatic void __receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nbool preops = I_ISTRIP(tty) || (I_IUCLC(tty) && L_IEXTEN(tty));\r\nif (ldata->real_raw)\r\nn_tty_receive_buf_real_raw(tty, cp, fp, count);\r\nelse if (ldata->raw || (L_EXTPROC(tty) && !preops))\r\nn_tty_receive_buf_raw(tty, cp, fp, count);\r\nelse if (tty->closing && !L_EXTPROC(tty))\r\nn_tty_receive_buf_closing(tty, cp, fp, count);\r\nelse {\r\nif (ldata->lnext) {\r\nchar flag = TTY_NORMAL;\r\nif (fp)\r\nflag = *fp++;\r\nn_tty_receive_char_lnext(tty, *cp++, flag);\r\ncount--;\r\n}\r\nif (!preops && !I_PARMRK(tty))\r\nn_tty_receive_buf_fast(tty, cp, fp, count);\r\nelse\r\nn_tty_receive_buf_standard(tty, cp, fp, count);\r\nflush_echoes(tty);\r\nif (tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n}\r\nif (ldata->icanon && !L_EXTPROC(tty))\r\nreturn;\r\nsmp_store_release(&ldata->commit_head, ldata->read_head);\r\nif (read_cnt(ldata)) {\r\nkill_fasync(&tty->fasync, SIGIO, POLL_IN);\r\nwake_up_interruptible_poll(&tty->read_wait, POLLIN);\r\n}\r\n}\r\nstatic int\r\nn_tty_receive_buf_common(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count, int flow)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint room, n, rcvd = 0, overflow;\r\ndown_read(&tty->termios_rwsem);\r\nwhile (1) {\r\nsize_t tail = smp_load_acquire(&ldata->read_tail);\r\nroom = N_TTY_BUF_SIZE - (ldata->read_head - tail);\r\nif (I_PARMRK(tty))\r\nroom = (room + 2) / 3;\r\nroom--;\r\nif (room <= 0) {\r\noverflow = ldata->icanon && ldata->canon_head == tail;\r\nif (overflow && room < 0)\r\nldata->read_head--;\r\nroom = overflow;\r\nldata->no_room = flow && !room;\r\n} else\r\noverflow = 0;\r\nn = min(count, room);\r\nif (!n)\r\nbreak;\r\nif (!overflow || !fp || *fp != TTY_PARITY)\r\n__receive_buf(tty, cp, fp, n);\r\ncp += n;\r\nif (fp)\r\nfp += n;\r\ncount -= n;\r\nrcvd += n;\r\n}\r\ntty->receive_room = room;\r\nif (tty->driver->type == TTY_DRIVER_TYPE_PTY) {\r\nif (overflow) {\r\ntty_set_flow_change(tty, TTY_UNTHROTTLE_SAFE);\r\ntty_unthrottle_safe(tty);\r\n__tty_set_flow_change(tty, 0);\r\n}\r\n} else\r\nn_tty_check_throttle(tty);\r\nup_read(&tty->termios_rwsem);\r\nreturn rcvd;\r\n}\r\nstatic void n_tty_receive_buf(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nn_tty_receive_buf_common(tty, cp, fp, count, 0);\r\n}\r\nstatic int n_tty_receive_buf2(struct tty_struct *tty, const unsigned char *cp,\r\nchar *fp, int count)\r\n{\r\nreturn n_tty_receive_buf_common(tty, cp, fp, count, 1);\r\n}\r\nstatic void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (!old || (old->c_lflag ^ tty->termios.c_lflag) & ICANON) {\r\nbitmap_zero(ldata->read_flags, N_TTY_BUF_SIZE);\r\nldata->line_start = ldata->read_tail;\r\nif (!L_ICANON(tty) || !read_cnt(ldata)) {\r\nldata->canon_head = ldata->read_tail;\r\nldata->push = 0;\r\n} else {\r\nset_bit((ldata->read_head - 1) & (N_TTY_BUF_SIZE - 1),\r\nldata->read_flags);\r\nldata->canon_head = ldata->read_head;\r\nldata->push = 1;\r\n}\r\nldata->commit_head = ldata->read_head;\r\nldata->erasing = 0;\r\nldata->lnext = 0;\r\n}\r\nldata->icanon = (L_ICANON(tty) != 0);\r\nif (I_ISTRIP(tty) || I_IUCLC(tty) || I_IGNCR(tty) ||\r\nI_ICRNL(tty) || I_INLCR(tty) || L_ICANON(tty) ||\r\nI_IXON(tty) || L_ISIG(tty) || L_ECHO(tty) ||\r\nI_PARMRK(tty)) {\r\nbitmap_zero(ldata->char_map, 256);\r\nif (I_IGNCR(tty) || I_ICRNL(tty))\r\nset_bit('\r', ldata->char_map);\r\nif (I_INLCR(tty))\r\nset_bit('\n', ldata->char_map);\r\nif (L_ICANON(tty)) {\r\nset_bit(ERASE_CHAR(tty), ldata->char_map);\r\nset_bit(KILL_CHAR(tty), ldata->char_map);\r\nset_bit(EOF_CHAR(tty), ldata->char_map);\r\nset_bit('\n', ldata->char_map);\r\nset_bit(EOL_CHAR(tty), ldata->char_map);\r\nif (L_IEXTEN(tty)) {\r\nset_bit(WERASE_CHAR(tty), ldata->char_map);\r\nset_bit(LNEXT_CHAR(tty), ldata->char_map);\r\nset_bit(EOL2_CHAR(tty), ldata->char_map);\r\nif (L_ECHO(tty))\r\nset_bit(REPRINT_CHAR(tty),\r\nldata->char_map);\r\n}\r\n}\r\nif (I_IXON(tty)) {\r\nset_bit(START_CHAR(tty), ldata->char_map);\r\nset_bit(STOP_CHAR(tty), ldata->char_map);\r\n}\r\nif (L_ISIG(tty)) {\r\nset_bit(INTR_CHAR(tty), ldata->char_map);\r\nset_bit(QUIT_CHAR(tty), ldata->char_map);\r\nset_bit(SUSP_CHAR(tty), ldata->char_map);\r\n}\r\nclear_bit(__DISABLED_CHAR, ldata->char_map);\r\nldata->raw = 0;\r\nldata->real_raw = 0;\r\n} else {\r\nldata->raw = 1;\r\nif ((I_IGNBRK(tty) || (!I_BRKINT(tty) && !I_PARMRK(tty))) &&\r\n(I_IGNPAR(tty) || !I_INPCK(tty)) &&\r\n(tty->driver->flags & TTY_DRIVER_REAL_RAW))\r\nldata->real_raw = 1;\r\nelse\r\nldata->real_raw = 0;\r\n}\r\nif (!I_IXON(tty) && old && (old->c_iflag & IXON) && !tty->flow_stopped) {\r\nstart_tty(tty);\r\nprocess_echoes(tty);\r\n}\r\nwake_up_interruptible(&tty->write_wait);\r\nwake_up_interruptible(&tty->read_wait);\r\n}\r\nstatic void n_tty_close(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nif (tty->link)\r\nn_tty_packet_mode_flush(tty);\r\nvfree(ldata);\r\ntty->disc_data = NULL;\r\n}\r\nstatic int n_tty_open(struct tty_struct *tty)\r\n{\r\nstruct n_tty_data *ldata;\r\nldata = vmalloc(sizeof(*ldata));\r\nif (!ldata)\r\ngoto err;\r\nldata->overrun_time = jiffies;\r\nmutex_init(&ldata->atomic_read_lock);\r\nmutex_init(&ldata->output_lock);\r\ntty->disc_data = ldata;\r\nreset_buffer_flags(tty->disc_data);\r\nldata->column = 0;\r\nldata->canon_column = 0;\r\nldata->num_overrun = 0;\r\nldata->no_room = 0;\r\nldata->lnext = 0;\r\ntty->closing = 0;\r\nclear_bit(TTY_LDISC_HALTED, &tty->flags);\r\nn_tty_set_termios(tty, NULL);\r\ntty_unthrottle(tty);\r\nreturn 0;\r\nerr:\r\nreturn -ENOMEM;\r\n}\r\nstatic inline int input_available_p(struct tty_struct *tty, int poll)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint amt = poll && !TIME_CHAR(tty) && MIN_CHAR(tty) ? MIN_CHAR(tty) : 1;\r\nif (ldata->icanon && !L_EXTPROC(tty))\r\nreturn ldata->canon_head != ldata->read_tail;\r\nelse\r\nreturn ldata->commit_head - ldata->read_tail >= amt;\r\n}\r\nstatic int copy_from_read_buf(struct tty_struct *tty,\r\nunsigned char __user **b,\r\nsize_t *nr)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint retval;\r\nsize_t n;\r\nbool is_eof;\r\nsize_t head = smp_load_acquire(&ldata->commit_head);\r\nsize_t tail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\r\nretval = 0;\r\nn = min(head - ldata->read_tail, N_TTY_BUF_SIZE - tail);\r\nn = min(*nr, n);\r\nif (n) {\r\nconst unsigned char *from = read_buf_addr(ldata, tail);\r\nretval = copy_to_user(*b, from, n);\r\nn -= retval;\r\nis_eof = n == 1 && *from == EOF_CHAR(tty);\r\ntty_audit_add_data(tty, from, n);\r\nsmp_store_release(&ldata->read_tail, ldata->read_tail + n);\r\nif (L_EXTPROC(tty) && ldata->icanon && is_eof &&\r\n(head == ldata->read_tail))\r\nn = 0;\r\n*b += n;\r\n*nr -= n;\r\n}\r\nreturn retval;\r\n}\r\nstatic int canon_copy_from_read_buf(struct tty_struct *tty,\r\nunsigned char __user **b,\r\nsize_t *nr)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nsize_t n, size, more, c;\r\nsize_t eol;\r\nsize_t tail;\r\nint ret, found = 0;\r\nif (!*nr)\r\nreturn 0;\r\nn = min(*nr + 1, smp_load_acquire(&ldata->canon_head) - ldata->read_tail);\r\ntail = ldata->read_tail & (N_TTY_BUF_SIZE - 1);\r\nsize = min_t(size_t, tail + n, N_TTY_BUF_SIZE);\r\nn_tty_trace("%s: nr:%zu tail:%zu n:%zu size:%zu\n",\r\n__func__, *nr, tail, n, size);\r\neol = find_next_bit(ldata->read_flags, size, tail);\r\nmore = n - (size - tail);\r\nif (eol == N_TTY_BUF_SIZE && more) {\r\neol = find_next_bit(ldata->read_flags, more, 0);\r\nfound = eol != more;\r\n} else\r\nfound = eol != size;\r\nn = eol - tail;\r\nif (n > N_TTY_BUF_SIZE)\r\nn += N_TTY_BUF_SIZE;\r\nc = n + found;\r\nif (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {\r\nc = min(*nr, c);\r\nn = c;\r\n}\r\nn_tty_trace("%s: eol:%zu found:%d n:%zu c:%zu tail:%zu more:%zu\n",\r\n__func__, eol, found, n, c, tail, more);\r\nret = tty_copy_to_user(tty, *b, tail, n);\r\nif (ret)\r\nreturn -EFAULT;\r\n*b += n;\r\n*nr -= n;\r\nif (found)\r\nclear_bit(eol, ldata->read_flags);\r\nsmp_store_release(&ldata->read_tail, ldata->read_tail + c);\r\nif (found) {\r\nif (!ldata->push)\r\nldata->line_start = ldata->read_tail;\r\nelse\r\nldata->push = 0;\r\ntty_audit_push();\r\n}\r\nreturn 0;\r\n}\r\nstatic int job_control(struct tty_struct *tty, struct file *file)\r\n{\r\nif (file->f_op->write == redirected_tty_write)\r\nreturn 0;\r\nreturn __tty_check_change(tty, SIGTTIN);\r\n}\r\nstatic ssize_t n_tty_read(struct tty_struct *tty, struct file *file,\r\nunsigned char __user *buf, size_t nr)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nunsigned char __user *b = buf;\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nint c;\r\nint minimum, time;\r\nssize_t retval = 0;\r\nlong timeout;\r\nint packet;\r\nsize_t tail;\r\nc = job_control(tty, file);\r\nif (c < 0)\r\nreturn c;\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!mutex_trylock(&ldata->atomic_read_lock))\r\nreturn -EAGAIN;\r\n} else {\r\nif (mutex_lock_interruptible(&ldata->atomic_read_lock))\r\nreturn -ERESTARTSYS;\r\n}\r\ndown_read(&tty->termios_rwsem);\r\nminimum = time = 0;\r\ntimeout = MAX_SCHEDULE_TIMEOUT;\r\nif (!ldata->icanon) {\r\nminimum = MIN_CHAR(tty);\r\nif (minimum) {\r\ntime = (HZ / 10) * TIME_CHAR(tty);\r\n} else {\r\ntimeout = (HZ / 10) * TIME_CHAR(tty);\r\nminimum = 1;\r\n}\r\n}\r\npacket = tty->packet;\r\ntail = ldata->read_tail;\r\nadd_wait_queue(&tty->read_wait, &wait);\r\nwhile (nr) {\r\nif (packet && tty->link->ctrl_status) {\r\nunsigned char cs;\r\nif (b != buf)\r\nbreak;\r\nspin_lock_irq(&tty->link->ctrl_lock);\r\ncs = tty->link->ctrl_status;\r\ntty->link->ctrl_status = 0;\r\nspin_unlock_irq(&tty->link->ctrl_lock);\r\nif (put_user(cs, b)) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nb++;\r\nnr--;\r\nbreak;\r\n}\r\nif (!input_available_p(tty, 0)) {\r\nup_read(&tty->termios_rwsem);\r\ntty_buffer_flush_work(tty->port);\r\ndown_read(&tty->termios_rwsem);\r\nif (!input_available_p(tty, 0)) {\r\nif (test_bit(TTY_OTHER_CLOSED, &tty->flags)) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file))\r\nbreak;\r\nif (!timeout)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nup_read(&tty->termios_rwsem);\r\ntimeout = wait_woken(&wait, TASK_INTERRUPTIBLE,\r\ntimeout);\r\ndown_read(&tty->termios_rwsem);\r\ncontinue;\r\n}\r\n}\r\nif (ldata->icanon && !L_EXTPROC(tty)) {\r\nretval = canon_copy_from_read_buf(tty, &b, &nr);\r\nif (retval)\r\nbreak;\r\n} else {\r\nint uncopied;\r\nif (packet && b == buf) {\r\nif (put_user(TIOCPKT_DATA, b)) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nb++;\r\nnr--;\r\n}\r\nuncopied = copy_from_read_buf(tty, &b, &nr);\r\nuncopied += copy_from_read_buf(tty, &b, &nr);\r\nif (uncopied) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\n}\r\nn_tty_check_unthrottle(tty);\r\nif (b - buf >= minimum)\r\nbreak;\r\nif (time)\r\ntimeout = time;\r\n}\r\nif (tail != ldata->read_tail)\r\nn_tty_kick_worker(tty);\r\nup_read(&tty->termios_rwsem);\r\nremove_wait_queue(&tty->read_wait, &wait);\r\nmutex_unlock(&ldata->atomic_read_lock);\r\nif (b - buf)\r\nretval = b - buf;\r\nreturn retval;\r\n}\r\nstatic ssize_t n_tty_write(struct tty_struct *tty, struct file *file,\r\nconst unsigned char *buf, size_t nr)\r\n{\r\nconst unsigned char *b = buf;\r\nDEFINE_WAIT_FUNC(wait, woken_wake_function);\r\nint c;\r\nssize_t retval = 0;\r\nif (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {\r\nretval = tty_check_change(tty);\r\nif (retval)\r\nreturn retval;\r\n}\r\ndown_read(&tty->termios_rwsem);\r\nprocess_echoes(tty);\r\nadd_wait_queue(&tty->write_wait, &wait);\r\nwhile (1) {\r\nif (signal_pending(current)) {\r\nretval = -ERESTARTSYS;\r\nbreak;\r\n}\r\nif (tty_hung_up_p(file) || (tty->link && !tty->link->count)) {\r\nretval = -EIO;\r\nbreak;\r\n}\r\nif (O_OPOST(tty)) {\r\nwhile (nr > 0) {\r\nssize_t num = process_output_block(tty, b, nr);\r\nif (num < 0) {\r\nif (num == -EAGAIN)\r\nbreak;\r\nretval = num;\r\ngoto break_out;\r\n}\r\nb += num;\r\nnr -= num;\r\nif (nr == 0)\r\nbreak;\r\nc = *b;\r\nif (process_output(c, tty) < 0)\r\nbreak;\r\nb++; nr--;\r\n}\r\nif (tty->ops->flush_chars)\r\ntty->ops->flush_chars(tty);\r\n} else {\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nwhile (nr > 0) {\r\nmutex_lock(&ldata->output_lock);\r\nc = tty->ops->write(tty, b, nr);\r\nmutex_unlock(&ldata->output_lock);\r\nif (c < 0) {\r\nretval = c;\r\ngoto break_out;\r\n}\r\nif (!c)\r\nbreak;\r\nb += c;\r\nnr -= c;\r\n}\r\n}\r\nif (!nr)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nretval = -EAGAIN;\r\nbreak;\r\n}\r\nup_read(&tty->termios_rwsem);\r\nwait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\r\ndown_read(&tty->termios_rwsem);\r\n}\r\nbreak_out:\r\nremove_wait_queue(&tty->write_wait, &wait);\r\nif (nr && tty->fasync)\r\nset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\r\nup_read(&tty->termios_rwsem);\r\nreturn (b - buf) ? b - buf : retval;\r\n}\r\nstatic unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,\r\npoll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\npoll_wait(file, &tty->read_wait, wait);\r\npoll_wait(file, &tty->write_wait, wait);\r\nif (input_available_p(tty, 1))\r\nmask |= POLLIN | POLLRDNORM;\r\nelse {\r\ntty_buffer_flush_work(tty->port);\r\nif (input_available_p(tty, 1))\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nif (tty->packet && tty->link->ctrl_status)\r\nmask |= POLLPRI | POLLIN | POLLRDNORM;\r\nif (test_bit(TTY_OTHER_CLOSED, &tty->flags))\r\nmask |= POLLHUP;\r\nif (tty_hung_up_p(file))\r\nmask |= POLLHUP;\r\nif (tty->ops->write && !tty_is_writelocked(tty) &&\r\ntty_chars_in_buffer(tty) < WAKEUP_CHARS &&\r\ntty_write_room(tty) > 0)\r\nmask |= POLLOUT | POLLWRNORM;\r\nreturn mask;\r\n}\r\nstatic unsigned long inq_canon(struct n_tty_data *ldata)\r\n{\r\nsize_t nr, head, tail;\r\nif (ldata->canon_head == ldata->read_tail)\r\nreturn 0;\r\nhead = ldata->canon_head;\r\ntail = ldata->read_tail;\r\nnr = head - tail;\r\nwhile (head != tail) {\r\nif (test_bit(tail & (N_TTY_BUF_SIZE - 1), ldata->read_flags) &&\r\nread_buf(ldata, tail) == __DISABLED_CHAR)\r\nnr--;\r\ntail++;\r\n}\r\nreturn nr;\r\n}\r\nstatic int n_tty_ioctl(struct tty_struct *tty, struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct n_tty_data *ldata = tty->disc_data;\r\nint retval;\r\nswitch (cmd) {\r\ncase TIOCOUTQ:\r\nreturn put_user(tty_chars_in_buffer(tty), (int __user *) arg);\r\ncase TIOCINQ:\r\ndown_write(&tty->termios_rwsem);\r\nif (L_ICANON(tty))\r\nretval = inq_canon(ldata);\r\nelse\r\nretval = read_cnt(ldata);\r\nup_write(&tty->termios_rwsem);\r\nreturn put_user(retval, (unsigned int __user *) arg);\r\ndefault:\r\nreturn n_tty_ioctl_helper(tty, file, cmd, arg);\r\n}\r\n}\r\nvoid n_tty_inherit_ops(struct tty_ldisc_ops *ops)\r\n{\r\n*ops = n_tty_ops;\r\nops->owner = NULL;\r\nops->refcount = ops->flags = 0;\r\n}\r\nvoid __init n_tty_init(void)\r\n{\r\ntty_register_ldisc(N_TTY, &n_tty_ops);\r\n}
