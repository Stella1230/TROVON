static void authenc_esn_request_complete(struct aead_request *req, int err)\r\n{\r\nif (err != -EINPROGRESS)\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_authenc_esn_setauthsize(struct crypto_aead *authenc_esn,\r\nunsigned int authsize)\r\n{\r\nif (authsize > 0 && authsize < 4)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int crypto_authenc_esn_setkey(struct crypto_aead *authenc_esn, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nstruct crypto_skcipher *enc = ctx->enc;\r\nstruct crypto_authenc_keys keys;\r\nint err = -EINVAL;\r\nif (crypto_authenc_extractkeys(&keys, key, keylen) != 0)\r\ngoto badkey;\r\ncrypto_ahash_clear_flags(auth, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(auth, crypto_aead_get_flags(authenc_esn) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(auth, keys.authkey, keys.authkeylen);\r\ncrypto_aead_set_flags(authenc_esn, crypto_ahash_get_flags(auth) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\ngoto out;\r\ncrypto_skcipher_clear_flags(enc, CRYPTO_TFM_REQ_MASK);\r\ncrypto_skcipher_set_flags(enc, crypto_aead_get_flags(authenc_esn) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_skcipher_setkey(enc, keys.enckey, keys.enckeylen);\r\ncrypto_aead_set_flags(authenc_esn, crypto_skcipher_get_flags(enc) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nreturn err;\r\nbadkey:\r\ncrypto_aead_set_flags(authenc_esn, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\ngoto out;\r\n}\r\nstatic int crypto_authenc_esn_genicv_tail(struct aead_request *req,\r\nunsigned int flags)\r\n{\r\nstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nu8 *hash = PTR_ALIGN((u8 *)areq_ctx->tail,\r\ncrypto_ahash_alignmask(auth) + 1);\r\nunsigned int authsize = crypto_aead_authsize(authenc_esn);\r\nunsigned int assoclen = req->assoclen;\r\nunsigned int cryptlen = req->cryptlen;\r\nstruct scatterlist *dst = req->dst;\r\nu32 tmp[2];\r\nscatterwalk_map_and_copy(tmp, dst, 4, 4, 0);\r\nscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 0);\r\nscatterwalk_map_and_copy(tmp, dst, 0, 8, 1);\r\nscatterwalk_map_and_copy(hash, dst, assoclen + cryptlen, authsize, 1);\r\nreturn 0;\r\n}\r\nstatic void authenc_esn_geniv_ahash_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nerr = err ?: crypto_authenc_esn_genicv_tail(req, 0);\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_authenc_esn_genicv(struct aead_request *req,\r\nunsigned int flags)\r\n{\r\nstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\r\nstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nu8 *hash = PTR_ALIGN((u8 *)areq_ctx->tail,\r\ncrypto_ahash_alignmask(auth) + 1);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nunsigned int authsize = crypto_aead_authsize(authenc_esn);\r\nunsigned int assoclen = req->assoclen;\r\nunsigned int cryptlen = req->cryptlen;\r\nstruct scatterlist *dst = req->dst;\r\nu32 tmp[2];\r\nif (!authsize)\r\nreturn 0;\r\nscatterwalk_map_and_copy(tmp, dst, 0, 8, 0);\r\nscatterwalk_map_and_copy(tmp, dst, 4, 4, 1);\r\nscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 1);\r\nsg_init_table(areq_ctx->dst, 2);\r\ndst = scatterwalk_ffwd(areq_ctx->dst, dst, 4);\r\nahash_request_set_tfm(ahreq, auth);\r\nahash_request_set_crypt(ahreq, dst, hash, assoclen + cryptlen);\r\nahash_request_set_callback(ahreq, flags,\r\nauthenc_esn_geniv_ahash_done, req);\r\nreturn crypto_ahash_digest(ahreq) ?:\r\ncrypto_authenc_esn_genicv_tail(req, aead_request_flags(req));\r\n}\r\nstatic void crypto_authenc_esn_encrypt_done(struct crypto_async_request *req,\r\nint err)\r\n{\r\nstruct aead_request *areq = req->data;\r\nif (!err)\r\nerr = crypto_authenc_esn_genicv(areq, 0);\r\nauthenc_esn_request_complete(areq, err);\r\n}\r\nstatic int crypto_authenc_esn_copy(struct aead_request *req, unsigned int len)\r\n{\r\nstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nSKCIPHER_REQUEST_ON_STACK(skreq, ctx->null);\r\nskcipher_request_set_tfm(skreq, ctx->null);\r\nskcipher_request_set_callback(skreq, aead_request_flags(req),\r\nNULL, NULL);\r\nskcipher_request_set_crypt(skreq, req->src, req->dst, len, NULL);\r\nreturn crypto_skcipher_encrypt(skreq);\r\n}\r\nstatic int crypto_authenc_esn_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\r\nstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nstruct skcipher_request *skreq = (void *)(areq_ctx->tail +\r\nctx->reqoff);\r\nstruct crypto_skcipher *enc = ctx->enc;\r\nunsigned int assoclen = req->assoclen;\r\nunsigned int cryptlen = req->cryptlen;\r\nstruct scatterlist *src, *dst;\r\nint err;\r\nsg_init_table(areq_ctx->src, 2);\r\nsrc = scatterwalk_ffwd(areq_ctx->src, req->src, assoclen);\r\ndst = src;\r\nif (req->src != req->dst) {\r\nerr = crypto_authenc_esn_copy(req, assoclen);\r\nif (err)\r\nreturn err;\r\nsg_init_table(areq_ctx->dst, 2);\r\ndst = scatterwalk_ffwd(areq_ctx->dst, req->dst, assoclen);\r\n}\r\nskcipher_request_set_tfm(skreq, enc);\r\nskcipher_request_set_callback(skreq, aead_request_flags(req),\r\ncrypto_authenc_esn_encrypt_done, req);\r\nskcipher_request_set_crypt(skreq, src, dst, cryptlen, req->iv);\r\nerr = crypto_skcipher_encrypt(skreq);\r\nif (err)\r\nreturn err;\r\nreturn crypto_authenc_esn_genicv(req, aead_request_flags(req));\r\n}\r\nstatic int crypto_authenc_esn_decrypt_tail(struct aead_request *req,\r\nunsigned int flags)\r\n{\r\nstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\r\nunsigned int authsize = crypto_aead_authsize(authenc_esn);\r\nstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nstruct skcipher_request *skreq = (void *)(areq_ctx->tail +\r\nctx->reqoff);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nu8 *ohash = PTR_ALIGN((u8 *)areq_ctx->tail,\r\ncrypto_ahash_alignmask(auth) + 1);\r\nunsigned int cryptlen = req->cryptlen - authsize;\r\nunsigned int assoclen = req->assoclen;\r\nstruct scatterlist *dst = req->dst;\r\nu8 *ihash = ohash + crypto_ahash_digestsize(auth);\r\nu32 tmp[2];\r\nscatterwalk_map_and_copy(tmp, dst, 4, 4, 0);\r\nscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 0);\r\nscatterwalk_map_and_copy(tmp, dst, 0, 8, 1);\r\nif (crypto_memneq(ihash, ohash, authsize))\r\nreturn -EBADMSG;\r\nsg_init_table(areq_ctx->dst, 2);\r\ndst = scatterwalk_ffwd(areq_ctx->dst, dst, assoclen);\r\nskcipher_request_set_tfm(skreq, ctx->enc);\r\nskcipher_request_set_callback(skreq, flags,\r\nreq->base.complete, req->base.data);\r\nskcipher_request_set_crypt(skreq, dst, dst, cryptlen, req->iv);\r\nreturn crypto_skcipher_decrypt(skreq);\r\n}\r\nstatic void authenc_esn_verify_ahash_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nerr = err ?: crypto_authenc_esn_decrypt_tail(req, 0);\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_authenc_esn_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *authenc_esn = crypto_aead_reqtfm(req);\r\nstruct authenc_esn_request_ctx *areq_ctx = aead_request_ctx(req);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(authenc_esn);\r\nstruct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);\r\nunsigned int authsize = crypto_aead_authsize(authenc_esn);\r\nstruct crypto_ahash *auth = ctx->auth;\r\nu8 *ohash = PTR_ALIGN((u8 *)areq_ctx->tail,\r\ncrypto_ahash_alignmask(auth) + 1);\r\nunsigned int assoclen = req->assoclen;\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *ihash = ohash + crypto_ahash_digestsize(auth);\r\nstruct scatterlist *dst = req->dst;\r\nu32 tmp[2];\r\nint err;\r\ncryptlen -= authsize;\r\nif (req->src != dst) {\r\nerr = crypto_authenc_esn_copy(req, assoclen + cryptlen);\r\nif (err)\r\nreturn err;\r\n}\r\nscatterwalk_map_and_copy(ihash, req->src, assoclen + cryptlen,\r\nauthsize, 0);\r\nif (!authsize)\r\ngoto tail;\r\nscatterwalk_map_and_copy(tmp, dst, 0, 8, 0);\r\nscatterwalk_map_and_copy(tmp, dst, 4, 4, 1);\r\nscatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 1);\r\nsg_init_table(areq_ctx->dst, 2);\r\ndst = scatterwalk_ffwd(areq_ctx->dst, dst, 4);\r\nahash_request_set_tfm(ahreq, auth);\r\nahash_request_set_crypt(ahreq, dst, ohash, assoclen + cryptlen);\r\nahash_request_set_callback(ahreq, aead_request_flags(req),\r\nauthenc_esn_verify_ahash_done, req);\r\nerr = crypto_ahash_digest(ahreq);\r\nif (err)\r\nreturn err;\r\ntail:\r\nreturn crypto_authenc_esn_decrypt_tail(req, aead_request_flags(req));\r\n}\r\nstatic int crypto_authenc_esn_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct authenc_esn_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_ahash *auth;\r\nstruct crypto_skcipher *enc;\r\nstruct crypto_skcipher *null;\r\nint err;\r\nauth = crypto_spawn_ahash(&ictx->auth);\r\nif (IS_ERR(auth))\r\nreturn PTR_ERR(auth);\r\nenc = crypto_spawn_skcipher(&ictx->enc);\r\nerr = PTR_ERR(enc);\r\nif (IS_ERR(enc))\r\ngoto err_free_ahash;\r\nnull = crypto_get_default_null_skcipher2();\r\nerr = PTR_ERR(null);\r\nif (IS_ERR(null))\r\ngoto err_free_skcipher;\r\nctx->auth = auth;\r\nctx->enc = enc;\r\nctx->null = null;\r\nctx->reqoff = ALIGN(2 * crypto_ahash_digestsize(auth),\r\ncrypto_ahash_alignmask(auth) + 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nsizeof(struct authenc_esn_request_ctx) +\r\nctx->reqoff +\r\nmax_t(unsigned int,\r\ncrypto_ahash_reqsize(auth) +\r\nsizeof(struct ahash_request),\r\nsizeof(struct skcipher_request) +\r\ncrypto_skcipher_reqsize(enc)));\r\nreturn 0;\r\nerr_free_skcipher:\r\ncrypto_free_skcipher(enc);\r\nerr_free_ahash:\r\ncrypto_free_ahash(auth);\r\nreturn err;\r\n}\r\nstatic void crypto_authenc_esn_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_authenc_esn_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_ahash(ctx->auth);\r\ncrypto_free_skcipher(ctx->enc);\r\ncrypto_put_default_null_skcipher2();\r\n}\r\nstatic void crypto_authenc_esn_free(struct aead_instance *inst)\r\n{\r\nstruct authenc_esn_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_skcipher(&ctx->enc);\r\ncrypto_drop_ahash(&ctx->auth);\r\nkfree(inst);\r\n}\r\nstatic int crypto_authenc_esn_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct hash_alg_common *auth;\r\nstruct crypto_alg *auth_base;\r\nstruct skcipher_alg *enc;\r\nstruct authenc_esn_instance_ctx *ctx;\r\nconst char *enc_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nauth = ahash_attr_alg(tb[1], CRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK |\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (IS_ERR(auth))\r\nreturn PTR_ERR(auth);\r\nauth_base = &auth->base;\r\nenc_name = crypto_attr_alg_name(tb[2]);\r\nerr = PTR_ERR(enc_name);\r\nif (IS_ERR(enc_name))\r\ngoto out_put_auth;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ctx), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!inst)\r\ngoto out_put_auth;\r\nctx = aead_instance_ctx(inst);\r\nerr = crypto_init_ahash_spawn(&ctx->auth, auth,\r\naead_crypto_instance(inst));\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ctx->enc, aead_crypto_instance(inst));\r\nerr = crypto_grab_skcipher(&ctx->enc, enc_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_auth;\r\nenc = crypto_spawn_skcipher_alg(&ctx->enc);\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"authencesn(%s,%s)", auth_base->cra_name,\r\nenc->base.cra_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_enc;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"authencesn(%s,%s)", auth_base->cra_driver_name,\r\nenc->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_enc;\r\ninst->alg.base.cra_flags = (auth_base->cra_flags |\r\nenc->base.cra_flags) & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = enc->base.cra_priority * 10 +\r\nauth_base->cra_priority;\r\ninst->alg.base.cra_blocksize = enc->base.cra_blocksize;\r\ninst->alg.base.cra_alignmask = auth_base->cra_alignmask |\r\nenc->base.cra_alignmask;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_authenc_esn_ctx);\r\ninst->alg.ivsize = crypto_skcipher_alg_ivsize(enc);\r\ninst->alg.chunksize = crypto_skcipher_alg_chunksize(enc);\r\ninst->alg.maxauthsize = auth->digestsize;\r\ninst->alg.init = crypto_authenc_esn_init_tfm;\r\ninst->alg.exit = crypto_authenc_esn_exit_tfm;\r\ninst->alg.setkey = crypto_authenc_esn_setkey;\r\ninst->alg.setauthsize = crypto_authenc_esn_setauthsize;\r\ninst->alg.encrypt = crypto_authenc_esn_encrypt;\r\ninst->alg.decrypt = crypto_authenc_esn_decrypt;\r\ninst->free = crypto_authenc_esn_free,\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto err_drop_enc;\r\nout:\r\ncrypto_mod_put(auth_base);\r\nreturn err;\r\nerr_drop_enc:\r\ncrypto_drop_skcipher(&ctx->enc);\r\nerr_drop_auth:\r\ncrypto_drop_ahash(&ctx->auth);\r\nerr_free_inst:\r\nkfree(inst);\r\nout_put_auth:\r\ngoto out;\r\n}\r\nstatic int __init crypto_authenc_esn_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_authenc_esn_tmpl);\r\n}\r\nstatic void __exit crypto_authenc_esn_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_authenc_esn_tmpl);\r\n}
