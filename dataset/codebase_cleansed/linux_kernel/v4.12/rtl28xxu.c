static int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)\r\n{\r\nstruct rtl28xxu_dev *dev = d->priv;\r\nint ret;\r\nunsigned int pipe;\r\nu8 requesttype;\r\nmutex_lock(&d->usb_mutex);\r\nif (req->size > sizeof(dev->buf)) {\r\ndev_err(&d->intf->dev, "too large message %u\n", req->size);\r\nret = -EINVAL;\r\ngoto err_mutex_unlock;\r\n}\r\nif (req->index & CMD_WR_FLAG) {\r\nmemcpy(dev->buf, req->data, req->size);\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\npipe = usb_sndctrlpipe(d->udev, 0);\r\n} else {\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\npipe = usb_rcvctrlpipe(d->udev, 0);\r\n}\r\nret = usb_control_msg(d->udev, pipe, 0, requesttype, req->value,\r\nreq->index, dev->buf, req->size, 1000);\r\ndvb_usb_dbg_usb_control_msg(d->udev, 0, requesttype, req->value,\r\nreq->index, dev->buf, req->size);\r\nif (ret < 0)\r\ngoto err_mutex_unlock;\r\nif (requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))\r\nmemcpy(req->data, dev->buf, req->size);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn 0;\r\nerr_mutex_unlock:\r\nmutex_unlock(&d->usb_mutex);\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xxu_wr_regs(struct dvb_usb_device *d, u16 reg, u8 *val, int len)\r\n{\r\nstruct rtl28xxu_req req;\r\nif (reg < 0x3000)\r\nreq.index = CMD_USB_WR;\r\nelse if (reg < 0x4000)\r\nreq.index = CMD_SYS_WR;\r\nelse\r\nreq.index = CMD_IR_WR;\r\nreq.value = reg;\r\nreq.size = len;\r\nreq.data = val;\r\nreturn rtl28xxu_ctrl_msg(d, &req);\r\n}\r\nstatic int rtl28xxu_rd_regs(struct dvb_usb_device *d, u16 reg, u8 *val, int len)\r\n{\r\nstruct rtl28xxu_req req;\r\nif (reg < 0x3000)\r\nreq.index = CMD_USB_RD;\r\nelse if (reg < 0x4000)\r\nreq.index = CMD_SYS_RD;\r\nelse\r\nreq.index = CMD_IR_RD;\r\nreq.value = reg;\r\nreq.size = len;\r\nreq.data = val;\r\nreturn rtl28xxu_ctrl_msg(d, &req);\r\n}\r\nstatic int rtl28xxu_wr_reg(struct dvb_usb_device *d, u16 reg, u8 val)\r\n{\r\nreturn rtl28xxu_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int rtl28xxu_rd_reg(struct dvb_usb_device *d, u16 reg, u8 *val)\r\n{\r\nreturn rtl28xxu_rd_regs(d, reg, val, 1);\r\n}\r\nstatic int rtl28xxu_wr_reg_mask(struct dvb_usb_device *d, u16 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = rtl28xxu_rd_reg(d, reg, &tmp);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn rtl28xxu_wr_reg(d, reg, val);\r\n}\r\nstatic int rtl28xxu_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct rtl28xxu_dev *dev = d->priv;\r\nstruct rtl28xxu_req req;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num == 2 && !(msg[0].flags & I2C_M_RD) &&\r\n(msg[1].flags & I2C_M_RD)) {\r\nif (msg[0].len > 24 || msg[1].len > 24) {\r\nret = -EOPNOTSUPP;\r\ngoto err_mutex_unlock;\r\n} else if (msg[0].addr == 0x10) {\r\nif (msg[0].buf[0] == 0x00) {\r\nmsg[1].buf[0] = dev->page;\r\nret = 0;\r\n} else {\r\nreq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\r\nreq.index = CMD_DEMOD_RD | dev->page;\r\nreq.size = msg[1].len;\r\nreq.data = &msg[1].buf[0];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else if (msg[0].len < 2) {\r\nreq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\r\nreq.index = CMD_I2C_RD;\r\nreq.size = msg[1].len;\r\nreq.data = &msg[1].buf[0];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n} else {\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_WR;\r\nreq.size = msg[0].len;\r\nreq.data = msg[0].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\nif (ret)\r\ngoto err_mutex_unlock;\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_RD;\r\nreq.size = msg[1].len;\r\nreq.data = msg[1].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else if (num == 1 && !(msg[0].flags & I2C_M_RD)) {\r\nif (msg[0].len > 22) {\r\nret = -EOPNOTSUPP;\r\ngoto err_mutex_unlock;\r\n} else if (msg[0].addr == 0x10) {\r\nif (msg[0].buf[0] == 0x00) {\r\ndev->page = msg[0].buf[1];\r\nret = 0;\r\n} else {\r\nreq.value = (msg[0].buf[0] << 8) |\r\n(msg[0].addr << 1);\r\nreq.index = CMD_DEMOD_WR | dev->page;\r\nreq.size = msg[0].len-1;\r\nreq.data = &msg[0].buf[1];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else if ((msg[0].len < 23) && (!dev->new_i2c_write)) {\r\nreq.value = (msg[0].buf[0] << 8) | (msg[0].addr << 1);\r\nreq.index = CMD_I2C_WR;\r\nreq.size = msg[0].len-1;\r\nreq.data = &msg[0].buf[1];\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n} else {\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_WR;\r\nreq.size = msg[0].len;\r\nreq.data = msg[0].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n}\r\n} else if (num == 1 && (msg[0].flags & I2C_M_RD)) {\r\nreq.value = (msg[0].addr << 1);\r\nreq.index = CMD_I2C_DA_RD;\r\nreq.size = msg[0].len;\r\nreq.data = msg[0].buf;\r\nret = rtl28xxu_ctrl_msg(d, &req);\r\n} else {\r\nret = -EOPNOTSUPP;\r\n}\r\nif (ret == -EPIPE)\r\nret = -EAGAIN;\r\nerr_mutex_unlock:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret ? ret : num;\r\n}\r\nstatic u32 rtl28xxu_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int rtl2831u_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nint ret;\r\nu8 buf[1];\r\nstruct rtl28xxu_req req_gate_open = {0x0120, 0x0011, 0x0001, "\x08"};\r\nstruct rtl28xxu_req req_mt2060 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_qt1010 = {0x0fc4, CMD_I2C_RD, 1, buf};\r\ndev_dbg(&d->intf->dev, "\n");\r\nret = rtl28xxu_wr_reg(d, SYS_GPIO_DIR, 0x0a);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg(d, SYS_GPIO_OUT_EN, 0x15);\r\nif (ret)\r\ngoto err;\r\nmsleep(20);\r\ndev->tuner_name = "NONE";\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_open);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_qt1010);\r\nif (ret == 0 && buf[0] == 0x2c) {\r\ndev->tuner = TUNER_RTL2830_QT1010;\r\ndev->tuner_name = "QT1010";\r\ngoto found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_open);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_mt2060);\r\nif (ret == 0 && buf[0] == 0x63) {\r\ndev->tuner = TUNER_RTL2830_MT2060;\r\ndev->tuner_name = "MT2060";\r\ngoto found;\r\n}\r\ndev->tuner = TUNER_RTL2830_MXL5005S;\r\ndev->tuner_name = "MXL5005S";\r\ngoto found;\r\nfound:\r\ndev_dbg(&d->intf->dev, "tuner=%s\n", dev->tuner_name);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nint ret;\r\nu8 buf[2];\r\nstruct rtl28xxu_req req_gate_open = {0x0120, 0x0011, 0x0001, "\x18"};\r\nstruct rtl28xxu_req req_gate_close = {0x0120, 0x0011, 0x0001, "\x10"};\r\nstruct rtl28xxu_req req_fc0012 = {0x00c6, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_fc0013 = {0x00c6, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_mt2266 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_fc2580 = {0x01ac, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_mt2063 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_max3543 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_tua9001 = {0x7ec0, CMD_I2C_RD, 2, buf};\r\nstruct rtl28xxu_req req_mxl5007t = {0xd9c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_e4000 = {0x02c8, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_tda18272 = {0x00c0, CMD_I2C_RD, 2, buf};\r\nstruct rtl28xxu_req req_r820t = {0x0034, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_r828d = {0x0074, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_mn88472 = {0xff38, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_mn88473 = {0xff38, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_si2157 = {0x00c0, CMD_I2C_RD, 1, buf};\r\nstruct rtl28xxu_req req_si2168 = {0x00c8, CMD_I2C_RD, 1, buf};\r\ndev_dbg(&d->intf->dev, "\n");\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x40);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x48, 0x48);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_open);\r\nif (ret)\r\ngoto err;\r\ndev->tuner_name = "NONE";\r\nret = rtl28xxu_ctrl_msg(d, &req_fc0012);\r\nif (ret == 0 && buf[0] == 0xa1) {\r\ndev->tuner = TUNER_RTL2832_FC0012;\r\ndev->tuner_name = "FC0012";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_fc0013);\r\nif (ret == 0 && buf[0] == 0xa3) {\r\ndev->tuner = TUNER_RTL2832_FC0013;\r\ndev->tuner_name = "FC0013";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mt2266);\r\nif (ret == 0 && buf[0] == 0x85) {\r\ndev->tuner = TUNER_RTL2832_MT2266;\r\ndev->tuner_name = "MT2266";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_fc2580);\r\nif (ret == 0 && buf[0] == 0x56) {\r\ndev->tuner = TUNER_RTL2832_FC2580;\r\ndev->tuner_name = "FC2580";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mt2063);\r\nif (ret == 0 && (buf[0] == 0x9e || buf[0] == 0x9c)) {\r\ndev->tuner = TUNER_RTL2832_MT2063;\r\ndev->tuner_name = "MT2063";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_max3543);\r\nif (ret == 0 && buf[0] == 0x38) {\r\ndev->tuner = TUNER_RTL2832_MAX3543;\r\ndev->tuner_name = "MAX3543";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_tua9001);\r\nif (ret == 0 && buf[0] == 0x23 && buf[1] == 0x28) {\r\ndev->tuner = TUNER_RTL2832_TUA9001;\r\ndev->tuner_name = "TUA9001";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mxl5007t);\r\nif (ret == 0 && buf[0] == 0x14) {\r\ndev->tuner = TUNER_RTL2832_MXL5007T;\r\ndev->tuner_name = "MXL5007T";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_e4000);\r\nif (ret == 0 && buf[0] == 0x40) {\r\ndev->tuner = TUNER_RTL2832_E4000;\r\ndev->tuner_name = "E4000";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_tda18272);\r\nif (ret == 0 && (buf[0] == 0xc7 || buf[1] == 0x60)) {\r\ndev->tuner = TUNER_RTL2832_TDA18272;\r\ndev->tuner_name = "TDA18272";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_r820t);\r\nif (ret == 0 && buf[0] == 0x69) {\r\ndev->tuner = TUNER_RTL2832_R820T;\r\ndev->tuner_name = "R820T";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_r828d);\r\nif (ret == 0 && buf[0] == 0x69) {\r\ndev->tuner = TUNER_RTL2832_R828D;\r\ndev->tuner_name = "R828D";\r\ngoto tuner_found;\r\n}\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x00, 0x21);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x00, 0x21);\r\nif (ret)\r\ngoto err;\r\nmsleep(50);\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x21, 0x21);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x21, 0x21);\r\nif (ret)\r\ngoto err;\r\nmsleep(50);\r\nret = rtl28xxu_ctrl_msg(d, &req_si2157);\r\nif (ret == 0 && ((buf[0] & 0x80) == 0x80)) {\r\ndev->tuner = TUNER_RTL2832_SI2157;\r\ndev->tuner_name = "SI2157";\r\ngoto tuner_found;\r\n}\r\ntuner_found:\r\ndev_dbg(&d->intf->dev, "tuner=%s\n", dev->tuner_name);\r\nif (dev->tuner == TUNER_RTL2832_R828D) {\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_ctrl_msg(d, &req_mn88472);\r\nif (ret == 0 && buf[0] == 0x02) {\r\ndev_dbg(&d->intf->dev, "MN88472 found\n");\r\ndev->slave_demod = SLAVE_DEMOD_MN88472;\r\ngoto demod_found;\r\n}\r\nret = rtl28xxu_ctrl_msg(d, &req_mn88473);\r\nif (ret == 0 && buf[0] == 0x03) {\r\ndev_dbg(&d->intf->dev, "MN88473 found\n");\r\ndev->slave_demod = SLAVE_DEMOD_MN88473;\r\ngoto demod_found;\r\n}\r\n}\r\nif (dev->tuner == TUNER_RTL2832_SI2157) {\r\nret = rtl28xxu_ctrl_msg(d, &req_si2168);\r\nif (ret == 0 && ((buf[0] & 0x80) == 0x80)) {\r\ndev_dbg(&d->intf->dev, "Si2168 found\n");\r\ndev->slave_demod = SLAVE_DEMOD_SI2168;\r\ngoto demod_found;\r\n}\r\n}\r\ndemod_found:\r\nret = rtl28xxu_ctrl_msg(d, &req_gate_close);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xxu_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nif (dev->chip_id == CHIP_ID_RTL2831U)\r\nreturn rtl2831u_read_config(d);\r\nelse\r\nreturn rtl2832u_read_config(d);\r\n}\r\nstatic int rtl28xxu_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nint ret;\r\nstruct rtl28xxu_req req_demod_i2c = {0x0020, CMD_I2C_DA_RD, 0, NULL};\r\ndev_dbg(&d->intf->dev, "\n");\r\nret = rtl28xxu_ctrl_msg(d, &req_demod_i2c);\r\nif (ret == -EPIPE) {\r\ndev->chip_id = CHIP_ID_RTL2831U;\r\n} else if (ret == 0) {\r\ndev->chip_id = CHIP_ID_RTL2832U;\r\n} else {\r\ndev_err(&d->intf->dev, "chip type detection failed %d\n", ret);\r\ngoto err;\r\n}\r\ndev_dbg(&d->intf->dev, "chip_id=%u\n", dev->chip_id);\r\nd->i2c_adap.retries = 3;\r\nd->i2c_adap.timeout = msecs_to_jiffies(10);\r\nreturn WARM;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nstruct rtl2830_platform_data *pdata = &dev->rtl2830_platform_data;\r\nstruct i2c_board_info board_info;\r\nstruct i2c_client *client;\r\nint ret;\r\ndev_dbg(&d->intf->dev, "\n");\r\nswitch (dev->tuner) {\r\ncase TUNER_RTL2830_QT1010:\r\n*pdata = rtl2830_qt1010_platform_data;\r\nbreak;\r\ncase TUNER_RTL2830_MT2060:\r\n*pdata = rtl2830_mt2060_platform_data;\r\nbreak;\r\ncase TUNER_RTL2830_MXL5005S:\r\n*pdata = rtl2830_mxl5005s_platform_data;\r\nbreak;\r\ndefault:\r\ndev_err(&d->intf->dev, "unknown tuner %s\n", dev->tuner_name);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "rtl2830", I2C_NAME_SIZE);\r\nboard_info.addr = 0x10;\r\nboard_info.platform_data = pdata;\r\nrequest_module("%s", board_info.type);\r\nclient = i2c_new_device(&d->i2c_adap, &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0] = pdata->get_dvb_frontend(client);\r\ndev->demod_i2c_adapter = pdata->get_i2c_adapter(client);\r\ndev->i2c_client_demod = client;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_fc0012_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->intf->dev, "cmd=%d arg=%d\n", cmd, arg);\r\nswitch (cmd) {\r\ncase FC_FE_CALLBACK_VHF_ENABLE:\r\nret = rtl28xxu_rd_reg(d, SYS_GPIO_OUT_VAL, &val);\r\nif (ret)\r\ngoto err;\r\nif (arg)\r\nval &= 0xbf;\r\nelse\r\nval |= 0x40;\r\nret = rtl28xxu_wr_reg(d, SYS_GPIO_OUT_VAL, val);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_tua9001_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->intf->dev, "cmd=%d arg=%d\n", cmd, arg);\r\nswitch (cmd) {\r\ncase TUA9001_CMD_RESETN:\r\nif (arg)\r\nval = (1 << 4);\r\nelse\r\nval = (0 << 4);\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, val, 0x10);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\ncase TUA9001_CMD_RXEN:\r\nif (arg)\r\nval = (1 << 1);\r\nelse\r\nval = (0 << 1);\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, val, 0x02);\r\nif (ret)\r\ngoto err;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_frontend_callback(void *adapter_priv, int component,\r\nint cmd, int arg)\r\n{\r\nstruct i2c_adapter *adapter = adapter_priv;\r\nstruct device *parent = adapter->dev.parent;\r\nstruct i2c_adapter *parent_adapter;\r\nstruct dvb_usb_device *d;\r\nstruct rtl28xxu_dev *dev;\r\nif (parent != NULL && parent->type == &i2c_adapter_type)\r\nparent_adapter = to_i2c_adapter(parent);\r\nelse\r\nreturn -EINVAL;\r\nd = i2c_get_adapdata(parent_adapter);\r\ndev = d->priv;\r\ndev_dbg(&d->intf->dev, "component=%d cmd=%d arg=%d\n",\r\ncomponent, cmd, arg);\r\nswitch (component) {\r\ncase DVB_FRONTEND_COMPONENT_TUNER:\r\nswitch (dev->tuner) {\r\ncase TUNER_RTL2832_FC0012:\r\nreturn rtl2832u_fc0012_tuner_callback(d, cmd, arg);\r\ncase TUNER_RTL2832_TUA9001:\r\nreturn rtl2832u_tua9001_tuner_callback(d, cmd, arg);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2832u_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\r\nstruct i2c_board_info board_info;\r\nstruct i2c_client *client;\r\nint ret;\r\ndev_dbg(&d->intf->dev, "\n");\r\nswitch (dev->tuner) {\r\ncase TUNER_RTL2832_FC0012:\r\n*pdata = rtl2832_fc0012_platform_data;\r\nbreak;\r\ncase TUNER_RTL2832_FC0013:\r\n*pdata = rtl2832_fc0013_platform_data;\r\nbreak;\r\ncase TUNER_RTL2832_FC2580:\r\n*pdata = rtl2832_fc2580_platform_data;\r\nbreak;\r\ncase TUNER_RTL2832_TUA9001:\r\n*pdata = rtl2832_tua9001_platform_data;\r\nbreak;\r\ncase TUNER_RTL2832_E4000:\r\n*pdata = rtl2832_e4000_platform_data;\r\nbreak;\r\ncase TUNER_RTL2832_R820T:\r\ncase TUNER_RTL2832_R828D:\r\n*pdata = rtl2832_r820t_platform_data;\r\nbreak;\r\ncase TUNER_RTL2832_SI2157:\r\n*pdata = rtl2832_si2157_platform_data;\r\nbreak;\r\ndefault:\r\ndev_err(&d->intf->dev, "unknown tuner %s\n", dev->tuner_name);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nmemset(&board_info, 0, sizeof(board_info));\r\nstrlcpy(board_info.type, "rtl2832", I2C_NAME_SIZE);\r\nboard_info.addr = 0x10;\r\nboard_info.platform_data = pdata;\r\nrequest_module("%s", board_info.type);\r\nclient = i2c_new_device(&d->i2c_adap, &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0] = pdata->get_dvb_frontend(client);\r\ndev->demod_i2c_adapter = pdata->get_i2c_adapter(client);\r\ndev->i2c_client_demod = client;\r\nadap->fe[0]->callback = rtl2832u_frontend_callback;\r\nif (dev->slave_demod) {\r\nstruct i2c_board_info info = {};\r\nret = 0;\r\nif (dev->slave_demod == SLAVE_DEMOD_MN88472) {\r\nstruct mn88472_config mn88472_config = {};\r\nmn88472_config.fe = &adap->fe[1];\r\nmn88472_config.i2c_wr_max = 22,\r\nstrlcpy(info.type, "mn88472", I2C_NAME_SIZE);\r\nmn88472_config.xtal = 20500000;\r\nmn88472_config.ts_mode = SERIAL_TS_MODE;\r\nmn88472_config.ts_clock = VARIABLE_TS_CLOCK;\r\ninfo.addr = 0x18;\r\ninfo.platform_data = &mn88472_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&d->i2c_adap, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndev->slave_demod = SLAVE_DEMOD_NONE;\r\ngoto err_slave_demod_failed;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndev->slave_demod = SLAVE_DEMOD_NONE;\r\ngoto err_slave_demod_failed;\r\n}\r\ndev->i2c_client_slave_demod = client;\r\n} else if (dev->slave_demod == SLAVE_DEMOD_MN88473) {\r\nstruct mn88473_config mn88473_config = {};\r\nmn88473_config.fe = &adap->fe[1];\r\nmn88473_config.i2c_wr_max = 22,\r\nstrlcpy(info.type, "mn88473", I2C_NAME_SIZE);\r\ninfo.addr = 0x18;\r\ninfo.platform_data = &mn88473_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&d->i2c_adap, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndev->slave_demod = SLAVE_DEMOD_NONE;\r\ngoto err_slave_demod_failed;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndev->slave_demod = SLAVE_DEMOD_NONE;\r\ngoto err_slave_demod_failed;\r\n}\r\ndev->i2c_client_slave_demod = client;\r\n} else {\r\nstruct si2168_config si2168_config = {};\r\nstruct i2c_adapter *adapter;\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &adap->fe[1];\r\nsi2168_config.ts_mode = SI2168_TS_SERIAL;\r\nsi2168_config.ts_clock_inv = false;\r\nsi2168_config.ts_clock_gapped = true;\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&d->i2c_adap, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndev->slave_demod = SLAVE_DEMOD_NONE;\r\ngoto err_slave_demod_failed;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndev->slave_demod = SLAVE_DEMOD_NONE;\r\ngoto err_slave_demod_failed;\r\n}\r\ndev->i2c_client_slave_demod = client;\r\ndev->new_i2c_write = true;\r\n}\r\n}\r\nreturn 0;\r\nerr_slave_demod_failed:\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xxu_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct rtl28xxu_dev *dev = adap_to_priv(adap);\r\nif (dev->chip_id == CHIP_ID_RTL2831U)\r\nreturn rtl2831u_frontend_attach(adap);\r\nelse\r\nreturn rtl2832u_frontend_attach(adap);\r\n}\r\nstatic int rtl28xxu_frontend_detach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nstruct i2c_client *client;\r\ndev_dbg(&d->intf->dev, "\n");\r\nclient = dev->i2c_client_slave_demod;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = dev->i2c_client_demod;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl2831u_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nstruct dvb_frontend *fe;\r\ndev_dbg(&d->intf->dev, "\n");\r\nswitch (dev->tuner) {\r\ncase TUNER_RTL2830_QT1010:\r\nfe = dvb_attach(qt1010_attach, adap->fe[0],\r\ndev->demod_i2c_adapter,\r\n&rtl28xxu_qt1010_config);\r\nbreak;\r\ncase TUNER_RTL2830_MT2060:\r\nfe = dvb_attach(mt2060_attach, adap->fe[0],\r\ndev->demod_i2c_adapter,\r\n&rtl28xxu_mt2060_config, 1220);\r\nbreak;\r\ncase TUNER_RTL2830_MXL5005S:\r\nfe = dvb_attach(mxl5005s_attach, adap->fe[0],\r\ndev->demod_i2c_adapter,\r\n&rtl28xxu_mxl5005s_config);\r\nbreak;\r\ndefault:\r\nfe = NULL;\r\ndev_err(&d->intf->dev, "unknown tuner %d\n", dev->tuner);\r\n}\r\nif (fe == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nint ret;\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nstruct dvb_frontend *fe = NULL;\r\nstruct i2c_board_info info;\r\nstruct i2c_client *client;\r\nstruct v4l2_subdev *subdev = NULL;\r\nstruct platform_device *pdev;\r\nstruct rtl2832_sdr_platform_data pdata;\r\ndev_dbg(&d->intf->dev, "\n");\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nmemset(&pdata, 0, sizeof(pdata));\r\nswitch (dev->tuner) {\r\ncase TUNER_RTL2832_FC0012:\r\nfe = dvb_attach(fc0012_attach, adap->fe[0],\r\ndev->demod_i2c_adapter, &rtl2832u_fc0012_config);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nbreak;\r\ncase TUNER_RTL2832_FC0013:\r\nfe = dvb_attach(fc0013_attach, adap->fe[0],\r\ndev->demod_i2c_adapter, 0xc6>>1, 0, FC_XTAL_28_8_MHZ);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nbreak;\r\ncase TUNER_RTL2832_E4000: {\r\nstruct e4000_config e4000_config = {\r\n.fe = adap->fe[0],\r\n.clock = 28800000,\r\n};\r\nstrlcpy(info.type, "e4000", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &e4000_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(dev->demod_i2c_adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL)\r\nbreak;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nbreak;\r\n}\r\ndev->i2c_client_tuner = client;\r\nsubdev = i2c_get_clientdata(client);\r\n}\r\nbreak;\r\ncase TUNER_RTL2832_FC2580: {\r\nstruct fc2580_platform_data fc2580_pdata = {\r\n.dvb_frontend = adap->fe[0],\r\n};\r\nstruct i2c_board_info board_info = {};\r\nstrlcpy(board_info.type, "fc2580", I2C_NAME_SIZE);\r\nboard_info.addr = 0x56;\r\nboard_info.platform_data = &fc2580_pdata;\r\nrequest_module("fc2580");\r\nclient = i2c_new_device(dev->demod_i2c_adapter,\r\n&board_info);\r\nif (client == NULL || client->dev.driver == NULL)\r\nbreak;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nbreak;\r\n}\r\ndev->i2c_client_tuner = client;\r\nsubdev = fc2580_pdata.get_v4l2_subdev(client);\r\n}\r\nbreak;\r\ncase TUNER_RTL2832_TUA9001: {\r\nstruct tua9001_platform_data tua9001_pdata = {\r\n.dvb_frontend = adap->fe[0],\r\n};\r\nstruct i2c_board_info board_info = {};\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_DIR, 0x00, 0x12);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_EN, 0x12, 0x12);\r\nif (ret)\r\ngoto err;\r\nstrlcpy(board_info.type, "tua9001", I2C_NAME_SIZE);\r\nboard_info.addr = 0x60;\r\nboard_info.platform_data = &tua9001_pdata;\r\nrequest_module("tua9001");\r\nclient = i2c_new_device(dev->demod_i2c_adapter, &board_info);\r\nif (client == NULL || client->dev.driver == NULL)\r\nbreak;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nbreak;\r\n}\r\ndev->i2c_client_tuner = client;\r\nbreak;\r\n}\r\ncase TUNER_RTL2832_R820T:\r\nfe = dvb_attach(r820t_attach, adap->fe[0],\r\ndev->demod_i2c_adapter,\r\n&rtl2832u_r820t_config);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nbreak;\r\ncase TUNER_RTL2832_R828D:\r\nfe = dvb_attach(r820t_attach, adap->fe[0],\r\ndev->demod_i2c_adapter,\r\n&rtl2832u_r828d_config);\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nif (adap->fe[1]) {\r\nfe = dvb_attach(r820t_attach, adap->fe[1],\r\ndev->demod_i2c_adapter,\r\n&rtl2832u_r828d_config);\r\nadap->fe[1]->ops.read_signal_strength =\r\nadap->fe[1]->ops.tuner_ops.get_rf_strength;\r\n}\r\nbreak;\r\ncase TUNER_RTL2832_SI2157: {\r\nstruct si2157_config si2157_config = {\r\n.fe = adap->fe[0],\r\n.if_port = 0,\r\n.inversion = false,\r\n};\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient = i2c_new_device(&d->i2c_adap, &info);\r\nif (client == NULL || client->dev.driver == NULL)\r\nbreak;\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nbreak;\r\n}\r\ndev->i2c_client_tuner = client;\r\nsubdev = i2c_get_clientdata(client);\r\nif (adap->fe[1]) {\r\nadap->fe[1]->tuner_priv =\r\nadap->fe[0]->tuner_priv;\r\nmemcpy(&adap->fe[1]->ops.tuner_ops,\r\n&adap->fe[0]->ops.tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\n}\r\n}\r\nbreak;\r\ndefault:\r\ndev_err(&d->intf->dev, "unknown tuner %d\n", dev->tuner);\r\n}\r\nif (fe == NULL && dev->i2c_client_tuner == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nswitch (dev->tuner) {\r\ncase TUNER_RTL2832_FC2580:\r\ncase TUNER_RTL2832_FC0012:\r\ncase TUNER_RTL2832_FC0013:\r\ncase TUNER_RTL2832_E4000:\r\ncase TUNER_RTL2832_R820T:\r\ncase TUNER_RTL2832_R828D:\r\npdata.clk = dev->rtl2832_platform_data.clk;\r\npdata.tuner = dev->tuner;\r\npdata.regmap = dev->rtl2832_platform_data.regmap;\r\npdata.dvb_frontend = adap->fe[0];\r\npdata.dvb_usb_device = d;\r\npdata.v4l2_subdev = subdev;\r\nrequest_module("%s", "rtl2832_sdr");\r\npdev = platform_device_register_data(&d->intf->dev,\r\n"rtl2832_sdr",\r\nPLATFORM_DEVID_AUTO,\r\n&pdata, sizeof(pdata));\r\nif (IS_ERR(pdev) || pdev->dev.driver == NULL)\r\nbreak;\r\ndev->platform_device_sdr = pdev;\r\nbreak;\r\ndefault:\r\ndev_dbg(&d->intf->dev, "no SDR for tuner=%d\n", dev->tuner);\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xxu_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct rtl28xxu_dev *dev = adap_to_priv(adap);\r\nif (dev->chip_id == CHIP_ID_RTL2831U)\r\nreturn rtl2831u_tuner_attach(adap);\r\nelse\r\nreturn rtl2832u_tuner_attach(adap);\r\n}\r\nstatic int rtl28xxu_tuner_detach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nstruct i2c_client *client;\r\nstruct platform_device *pdev;\r\ndev_dbg(&d->intf->dev, "\n");\r\npdev = dev->platform_device_sdr;\r\nif (pdev)\r\nplatform_device_unregister(pdev);\r\nclient = dev->i2c_client_tuner;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nreturn 0;\r\n}\r\nstatic int rtl28xxu_init(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->intf->dev, "\n");\r\nret = rtl28xxu_rd_reg(d, USB_SYSCTL_0, &val);\r\nif (ret)\r\ngoto err;\r\nval |= 0x09;\r\nret = rtl28xxu_wr_reg(d, USB_SYSCTL_0, val);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_regs(d, USB_EPA_MAXPKT, "\x00\x02\x00\x00", 4);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_regs(d, USB_EPA_FIFO_CFG, "\x14\x00\x00\x00", 4);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\nu8 gpio, sys0, epa_ctl[2];\r\ndev_dbg(&d->intf->dev, "onoff=%d\n", onoff);\r\nret = rtl28xxu_rd_reg(d, SYS_SYS0, &sys0);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_rd_reg(d, SYS_GPIO_OUT_VAL, &gpio);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&d->intf->dev, "RD SYS0=%02x GPIO_OUT_VAL=%02x\n", sys0, gpio);\r\nif (onoff) {\r\ngpio |= 0x01;\r\ngpio &= (~0x10);\r\ngpio |= 0x04;\r\nsys0 = sys0 & 0x0f;\r\nsys0 |= 0xe0;\r\nepa_ctl[0] = 0x00;\r\nepa_ctl[1] = 0x00;\r\n} else {\r\ngpio &= (~0x01);\r\ngpio |= 0x10;\r\ngpio &= (~0x04);\r\nsys0 = sys0 & (~0xc0);\r\nepa_ctl[0] = 0x10;\r\nepa_ctl[1] = 0x02;\r\n}\r\ndev_dbg(&d->intf->dev, "WR SYS0=%02x GPIO_OUT_VAL=%02x\n", sys0, gpio);\r\nret = rtl28xxu_wr_reg(d, SYS_SYS0, sys0);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg(d, SYS_GPIO_OUT_VAL, gpio);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_regs(d, USB_EPA_CTL, epa_ctl, 2);\r\nif (ret)\r\ngoto err;\r\nif (onoff)\r\nusb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x81));\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nint ret;\r\ndev_dbg(&d->intf->dev, "onoff=%d\n", onoff);\r\nif (onoff) {\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x08, 0x18);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL1, 0x00, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, 0x80, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, 0x20, 0x20);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_regs(d, USB_EPA_CTL, "\x00\x00", 2);\r\nif (ret)\r\ngoto err;\r\nret = usb_clear_halt(d->udev, usb_rcvbulkpipe(d->udev, 0x81));\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = rtl28xxu_wr_reg_mask(d, SYS_GPIO_OUT_VAL, 0x10, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, 0x00, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_regs(d, USB_EPA_CTL, "\x10\x02", 2);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl28xxu_power_ctrl(struct dvb_usb_device *d, int onoff)\r\n{\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nif (dev->chip_id == CHIP_ID_RTL2831U)\r\nreturn rtl2831u_power_ctrl(d, onoff);\r\nelse\r\nreturn rtl2832u_power_ctrl(d, onoff);\r\n}\r\nstatic int rtl28xxu_frontend_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct rtl28xxu_dev *dev = fe_to_priv(fe);\r\nstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\r\nint ret;\r\nu8 val;\r\ndev_dbg(&d->intf->dev, "fe=%d onoff=%d\n", fe->id, onoff);\r\nif (dev->chip_id == CHIP_ID_RTL2831U)\r\nreturn 0;\r\nif (fe->id == 0) {\r\nif (onoff)\r\nval = 0x48;\r\nelse\r\nval = 0x00;\r\nret = rtl28xxu_wr_reg_mask(d, SYS_DEMOD_CTL, val, 0x48);\r\nif (ret)\r\ngoto err;\r\n} else if (fe->id == 1) {\r\nret = pdata->slave_ts_ctrl(dev->i2c_client_demod, onoff);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret, i;\r\nstruct rtl28xxu_dev *dev = d->priv;\r\nu8 buf[5];\r\nu32 rc_code;\r\nstruct rtl28xxu_reg_val rc_nec_tab[] = {\r\n{ 0x3033, 0x80 },\r\n{ 0x3020, 0x43 },\r\n{ 0x3021, 0x16 },\r\n{ 0x3022, 0x16 },\r\n{ 0x3023, 0x5a },\r\n{ 0x3024, 0x2d },\r\n{ 0x3025, 0x16 },\r\n{ 0x3026, 0x01 },\r\n{ 0x3028, 0xb0 },\r\n{ 0x3029, 0x04 },\r\n{ 0x302c, 0x88 },\r\n{ 0x302e, 0x13 },\r\n{ 0x3030, 0xdf },\r\n{ 0x3031, 0x05 },\r\n};\r\nif (!dev->rc_active) {\r\nfor (i = 0; i < ARRAY_SIZE(rc_nec_tab); i++) {\r\nret = rtl28xxu_wr_reg(d, rc_nec_tab[i].reg,\r\nrc_nec_tab[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev->rc_active = true;\r\n}\r\nret = rtl28xxu_rd_regs(d, SYS_IRRC_RP, buf, 5);\r\nif (ret)\r\ngoto err;\r\nif (buf[4] & 0x01) {\r\nenum rc_type proto;\r\nif (buf[2] == (u8) ~buf[3]) {\r\nif (buf[0] == (u8) ~buf[1]) {\r\nrc_code = RC_SCANCODE_NEC(buf[0], buf[2]);\r\nproto = RC_TYPE_NEC;\r\n} else {\r\nrc_code = RC_SCANCODE_NECX(buf[0] << 8 | buf[1],\r\nbuf[2]);\r\nproto = RC_TYPE_NECX;\r\n}\r\n} else {\r\nrc_code = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |\r\nbuf[2] << 8 | buf[3]);\r\nproto = RC_TYPE_NEC32;\r\n}\r\nrc_keydown(d->rc_dev, proto, rc_code, 0);\r\nret = rtl28xxu_wr_reg(d, SYS_IRRC_SR, 1);\r\nif (ret)\r\ngoto err;\r\nret = rtl28xxu_wr_reg(d, SYS_IRRC_SR, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2831u_get_rc_config(struct dvb_usb_device *d,\r\nstruct dvb_usb_rc *rc)\r\n{\r\nrc->map_name = RC_MAP_EMPTY;\r\nrc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX | RC_BIT_NEC32;\r\nrc->query = rtl2831u_rc_query;\r\nrc->interval = 400;\r\nreturn 0;\r\n}\r\nstatic int rtl2832u_rc_query(struct dvb_usb_device *d)\r\n{\r\nint ret, i, len;\r\nstruct rtl28xxu_dev *dev = d->priv;\r\nstruct ir_raw_event ev;\r\nu8 buf[128];\r\nstatic const struct rtl28xxu_reg_val_mask refresh_tab[] = {\r\n{IR_RX_IF, 0x03, 0xff},\r\n{IR_RX_BUF_CTRL, 0x80, 0xff},\r\n{IR_RX_CTRL, 0x80, 0xff},\r\n};\r\nif (!dev->rc_active) {\r\nstatic const struct rtl28xxu_reg_val_mask init_tab[] = {\r\n{SYS_DEMOD_CTL1, 0x00, 0x04},\r\n{SYS_DEMOD_CTL1, 0x00, 0x08},\r\n{USB_CTRL, 0x20, 0x20},\r\n{SYS_GPIO_DIR, 0x00, 0x08},\r\n{SYS_GPIO_OUT_EN, 0x08, 0x08},\r\n{SYS_GPIO_OUT_VAL, 0x08, 0x08},\r\n{IR_MAX_DURATION0, 0xd0, 0xff},\r\n{IR_MAX_DURATION1, 0x07, 0xff},\r\n{IR_IDLE_LEN0, 0xc0, 0xff},\r\n{IR_IDLE_LEN1, 0x00, 0xff},\r\n{IR_GLITCH_LEN, 0x03, 0xff},\r\n{IR_RX_CLK, 0x09, 0xff},\r\n{IR_RX_CFG, 0x1c, 0xff},\r\n{IR_MAX_H_TOL_LEN, 0x1e, 0xff},\r\n{IR_MAX_L_TOL_LEN, 0x1e, 0xff},\r\n{IR_RX_CTRL, 0x80, 0xff},\r\n};\r\nfor (i = 0; i < ARRAY_SIZE(init_tab); i++) {\r\nret = rtl28xxu_wr_reg_mask(d, init_tab[i].reg,\r\ninit_tab[i].val, init_tab[i].mask);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev->rc_active = true;\r\n}\r\nret = rtl28xxu_rd_reg(d, IR_RX_IF, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nif (buf[0] != 0x83)\r\ngoto exit;\r\nret = rtl28xxu_rd_reg(d, IR_RX_BC, &buf[0]);\r\nif (ret)\r\ngoto err;\r\nlen = buf[0];\r\nret = rtl28xxu_rd_regs(d, IR_RX_BUF, buf, len);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(refresh_tab); i++) {\r\nret = rtl28xxu_wr_reg_mask(d, refresh_tab[i].reg,\r\nrefresh_tab[i].val, refresh_tab[i].mask);\r\nif (ret)\r\ngoto err;\r\n}\r\ninit_ir_raw_event(&ev);\r\nfor (i = 0; i < len; i++) {\r\nev.pulse = buf[i] >> 7;\r\nev.duration = 50800 * (buf[i] & 0x7f);\r\nir_raw_event_store_with_filter(d->rc_dev, &ev);\r\n}\r\nir_raw_event_set_idle(d->rc_dev, true);\r\nir_raw_event_handle(d->rc_dev);\r\nexit:\r\nreturn ret;\r\nerr:\r\ndev_dbg(&d->intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int rtl2832u_get_rc_config(struct dvb_usb_device *d,\r\nstruct dvb_usb_rc *rc)\r\n{\r\nif (rtl28xxu_disable_rc)\r\nreturn rtl28xxu_wr_reg(d, IR_RX_IE, 0x00);\r\nif (!rc->map_name)\r\nrc->map_name = RC_MAP_EMPTY;\r\nrc->allowed_protos = RC_BIT_ALL_IR_DECODER;\r\nrc->driver_type = RC_DRIVER_IR_RAW;\r\nrc->query = rtl2832u_rc_query;\r\nrc->interval = 200;\r\nreturn 0;\r\n}\r\nstatic int rtl28xxu_get_rc_config(struct dvb_usb_device *d,\r\nstruct dvb_usb_rc *rc)\r\n{\r\nstruct rtl28xxu_dev *dev = d_to_priv(d);\r\nif (dev->chip_id == CHIP_ID_RTL2831U)\r\nreturn rtl2831u_get_rc_config(d, rc);\r\nelse\r\nreturn rtl2832u_get_rc_config(d, rc);\r\n}\r\nstatic int rtl28xxu_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct rtl28xxu_dev *dev = adap_to_priv(adap);\r\nif (dev->chip_id == CHIP_ID_RTL2831U) {\r\nstruct rtl2830_platform_data *pdata = &dev->rtl2830_platform_data;\r\nreturn pdata->pid_filter_ctrl(adap->fe[0], onoff);\r\n} else {\r\nstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\r\nreturn pdata->pid_filter_ctrl(adap->fe[0], onoff);\r\n}\r\n}\r\nstatic int rtl28xxu_pid_filter(struct dvb_usb_adapter *adap, int index,\r\nu16 pid, int onoff)\r\n{\r\nstruct rtl28xxu_dev *dev = adap_to_priv(adap);\r\nif (dev->chip_id == CHIP_ID_RTL2831U) {\r\nstruct rtl2830_platform_data *pdata = &dev->rtl2830_platform_data;\r\nreturn pdata->pid_filter(adap->fe[0], index, pid, onoff);\r\n} else {\r\nstruct rtl2832_platform_data *pdata = &dev->rtl2832_platform_data;\r\nreturn pdata->pid_filter(adap->fe[0], index, pid, onoff);\r\n}\r\n}
