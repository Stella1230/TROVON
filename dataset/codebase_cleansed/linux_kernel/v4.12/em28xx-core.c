int em28xx_read_reg_req_len(struct em28xx *dev, u8 req, u16 reg,\r\nchar *buf, int len)\r\n{\r\nint ret;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint pipe = usb_rcvctrlpipe(udev, 0);\r\nif (dev->disconnected)\r\nreturn -ENODEV;\r\nif (len > URB_MAX_CTRL_SIZE)\r\nreturn -EINVAL;\r\nem28xx_regdbg("(pipe 0x%08x): IN: %02x %02x %02x %02x %02x %02x %02x %02x ",\r\npipe, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, 0,\r\nreg & 0xff, reg >> 8,\r\nlen & 0xff, len >> 8);\r\nmutex_lock(&dev->ctrl_urb_lock);\r\nret = usb_control_msg(udev, pipe, req,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, reg, dev->urb_buf, len, HZ);\r\nif (ret < 0) {\r\nem28xx_regdbg("(pipe 0x%08x): IN: %02x %02x %02x %02x %02x %02x %02x %02x failed\n",\r\npipe, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, 0,\r\nreg & 0xff, reg >> 8,\r\nlen & 0xff, len >> 8);\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nreturn usb_translate_errors(ret);\r\n}\r\nif (len)\r\nmemcpy(buf, dev->urb_buf, len);\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nem28xx_regdbg("(pipe 0x%08x): IN: %02x %02x %02x %02x %02x %02x %02x %02x failed <<< %*ph\n",\r\npipe, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, 0,\r\nreg & 0xff, reg >> 8,\r\nlen & 0xff, len >> 8, len, buf);\r\nreturn ret;\r\n}\r\nint em28xx_read_reg_req(struct em28xx *dev, u8 req, u16 reg)\r\n{\r\nint ret;\r\nu8 val;\r\nret = em28xx_read_reg_req_len(dev, req, reg, &val, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn val;\r\n}\r\nint em28xx_read_reg(struct em28xx *dev, u16 reg)\r\n{\r\nreturn em28xx_read_reg_req(dev, USB_REQ_GET_STATUS, reg);\r\n}\r\nint em28xx_write_regs_req(struct em28xx *dev, u8 req, u16 reg, char *buf,\r\nint len)\r\n{\r\nint ret;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint pipe = usb_sndctrlpipe(udev, 0);\r\nif (dev->disconnected)\r\nreturn -ENODEV;\r\nif ((len < 1) || (len > URB_MAX_CTRL_SIZE))\r\nreturn -EINVAL;\r\nem28xx_regdbg("(pipe 0x%08x): OUT: %02x %02x %02x %02x %02x %02x %02x %02x >>> %*ph\n",\r\npipe,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nreq, 0, 0,\r\nreg & 0xff, reg >> 8,\r\nlen & 0xff, len >> 8, len, buf);\r\nmutex_lock(&dev->ctrl_urb_lock);\r\nmemcpy(dev->urb_buf, buf, len);\r\nret = usb_control_msg(udev, pipe, req,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x0000, reg, dev->urb_buf, len, HZ);\r\nmutex_unlock(&dev->ctrl_urb_lock);\r\nif (ret < 0)\r\nreturn usb_translate_errors(ret);\r\nif (dev->wait_after_write)\r\nmsleep(dev->wait_after_write);\r\nreturn ret;\r\n}\r\nint em28xx_write_regs(struct em28xx *dev, u16 reg, char *buf, int len)\r\n{\r\nreturn em28xx_write_regs_req(dev, USB_REQ_GET_STATUS, reg, buf, len);\r\n}\r\nint em28xx_write_reg(struct em28xx *dev, u16 reg, u8 val)\r\n{\r\nreturn em28xx_write_regs(dev, reg, &val, 1);\r\n}\r\nint em28xx_write_reg_bits(struct em28xx *dev, u16 reg, u8 val,\r\nu8 bitmask)\r\n{\r\nint oldval;\r\nu8 newval;\r\noldval = em28xx_read_reg(dev, reg);\r\nif (oldval < 0)\r\nreturn oldval;\r\nnewval = (((u8)oldval) & ~bitmask) | (val & bitmask);\r\nreturn em28xx_write_regs(dev, reg, &newval, 1);\r\n}\r\nint em28xx_toggle_reg_bits(struct em28xx *dev, u16 reg, u8 bitmask)\r\n{\r\nint oldval;\r\nu8 newval;\r\noldval = em28xx_read_reg(dev, reg);\r\nif (oldval < 0)\r\nreturn oldval;\r\nnewval = (~oldval & bitmask) | (oldval & ~bitmask);\r\nreturn em28xx_write_reg(dev, reg, newval);\r\n}\r\nstatic int em28xx_is_ac97_ready(struct em28xx *dev)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(EM28XX_AC97_XFER_TIMEOUT);\r\nint ret;\r\nwhile (time_is_after_jiffies(timeout)) {\r\nret = em28xx_read_reg(dev, EM28XX_R43_AC97BUSY);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!(ret & 0x01))\r\nreturn 0;\r\nmsleep(5);\r\n}\r\ndev_warn(&dev->intf->dev,\r\n"AC97 command still being executed: not handled properly!\n");\r\nreturn -EBUSY;\r\n}\r\nint em28xx_read_ac97(struct em28xx *dev, u8 reg)\r\n{\r\nint ret;\r\nu8 addr = (reg & 0x7f) | 0x80;\r\n__le16 val;\r\nret = em28xx_is_ac97_ready(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_regs(dev, EM28XX_R42_AC97ADDR, &addr, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nret = dev->em28xx_read_reg_req_len(dev, 0, EM28XX_R40_AC97LSB,\r\n(u8 *)&val, sizeof(val));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn le16_to_cpu(val);\r\n}\r\nint em28xx_write_ac97(struct em28xx *dev, u8 reg, u16 val)\r\n{\r\nint ret;\r\nu8 addr = reg & 0x7f;\r\n__le16 value;\r\nvalue = cpu_to_le16(val);\r\nret = em28xx_is_ac97_ready(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_regs(dev, EM28XX_R40_AC97LSB, (u8 *)&value, 2);\r\nif (ret < 0)\r\nreturn ret;\r\nret = em28xx_write_regs(dev, EM28XX_R42_AC97ADDR, &addr, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int set_ac97_input(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nenum em28xx_amux amux = dev->ctl_ainput;\r\nif (amux == EM28XX_AMUX_VIDEO2)\r\namux = EM28XX_AMUX_VIDEO;\r\nfor (i = 0; i < ARRAY_SIZE(inputs); i++) {\r\nif (amux == inputs[i].mux)\r\nret = em28xx_write_ac97(dev, inputs[i].reg, 0x0808);\r\nelse\r\nret = em28xx_write_ac97(dev, inputs[i].reg, 0x8000);\r\nif (ret < 0)\r\ndev_warn(&dev->intf->dev,\r\n"couldn't setup AC97 register %d\n",\r\ninputs[i].reg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int em28xx_set_audio_source(struct em28xx *dev)\r\n{\r\nint ret;\r\nu8 input;\r\nif (dev->board.is_em2800) {\r\nif (dev->ctl_ainput == EM28XX_AMUX_VIDEO)\r\ninput = EM2800_AUDIO_SRC_TUNER;\r\nelse\r\ninput = EM2800_AUDIO_SRC_LINE;\r\nret = em28xx_write_regs(dev, EM2800_R08_AUDIOSRC, &input, 1);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (dev->board.has_msp34xx)\r\ninput = EM28XX_AUDIO_SRC_TUNER;\r\nelse {\r\nswitch (dev->ctl_ainput) {\r\ncase EM28XX_AMUX_VIDEO:\r\ninput = EM28XX_AUDIO_SRC_TUNER;\r\nbreak;\r\ndefault:\r\ninput = EM28XX_AUDIO_SRC_LINE;\r\nbreak;\r\n}\r\n}\r\nif (dev->board.mute_gpio && dev->mute)\r\nem28xx_gpio_set(dev, dev->board.mute_gpio);\r\nelse\r\nem28xx_gpio_set(dev, INPUT(dev->ctl_input)->gpio);\r\nret = em28xx_write_reg_bits(dev, EM28XX_R0E_AUDIOSRC, input, 0xc0);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(5);\r\nswitch (dev->audio_mode.ac97) {\r\ncase EM28XX_NO_AC97:\r\nbreak;\r\ndefault:\r\nret = set_ac97_input(dev);\r\n}\r\nreturn ret;\r\n}\r\nint em28xx_audio_analog_set(struct em28xx *dev)\r\n{\r\nint ret, i;\r\nu8 xclk;\r\nif (dev->int_audio_type == EM28XX_INT_AUDIO_NONE)\r\nreturn 0;\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\r\nfor (i = 0; i < ARRAY_SIZE(outputs); i++) {\r\nret = em28xx_write_ac97(dev, outputs[i].reg, 0x8000);\r\nif (ret < 0)\r\ndev_warn(&dev->intf->dev,\r\n"couldn't setup AC97 register %d\n",\r\noutputs[i].reg);\r\n}\r\n}\r\nxclk = dev->board.xclk & 0x7f;\r\nif (!dev->mute)\r\nxclk |= EM28XX_XCLK_AUDIO_UNMUTE;\r\nret = em28xx_write_reg(dev, EM28XX_R0F_XCLK, xclk);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(10);\r\nret = em28xx_set_audio_source(dev);\r\nif (dev->audio_mode.ac97 != EM28XX_NO_AC97) {\r\nint vol;\r\nem28xx_write_ac97(dev, AC97_POWERDOWN, 0x4200);\r\nem28xx_write_ac97(dev, AC97_EXTENDED_STATUS, 0x0031);\r\nem28xx_write_ac97(dev, AC97_PCM_LR_ADC_RATE, 0xbb80);\r\nvol = (0x1f - dev->volume) | ((0x1f - dev->volume) << 8);\r\nif (dev->mute)\r\nvol |= 0x8000;\r\nfor (i = 0; i < ARRAY_SIZE(outputs); i++) {\r\nif (dev->ctl_aoutput & outputs[i].mux)\r\nret = em28xx_write_ac97(dev, outputs[i].reg,\r\nvol);\r\nif (ret < 0)\r\ndev_warn(&dev->intf->dev,\r\n"couldn't setup AC97 register %d\n",\r\noutputs[i].reg);\r\n}\r\nif (dev->ctl_aoutput & EM28XX_AOUT_PCM_IN) {\r\nint sel = ac97_return_record_select(dev->ctl_aoutput);\r\nsel |= (sel << 8);\r\nem28xx_write_ac97(dev, AC97_REC_SEL, sel);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint em28xx_audio_setup(struct em28xx *dev)\r\n{\r\nint vid1, vid2, feat, cfg;\r\nu32 vid = 0;\r\nu8 i2s_samplerates;\r\nif (dev->chip_id == CHIP_ID_EM2870 ||\r\ndev->chip_id == CHIP_ID_EM2874 ||\r\ndev->chip_id == CHIP_ID_EM28174 ||\r\ndev->chip_id == CHIP_ID_EM28178) {\r\ndev->int_audio_type = EM28XX_INT_AUDIO_NONE;\r\ndev->usb_audio_type = EM28XX_USB_AUDIO_NONE;\r\nreturn 0;\r\n}\r\ncfg = em28xx_read_reg(dev, EM28XX_R00_CHIPCFG);\r\ndev_info(&dev->intf->dev, "Config register raw data: 0x%02x\n", cfg);\r\nif (cfg < 0) {\r\ndev->int_audio_type = EM28XX_INT_AUDIO_AC97;\r\n} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) == 0x00) {\r\ndev->int_audio_type = EM28XX_INT_AUDIO_NONE;\r\ndev->usb_audio_type = EM28XX_USB_AUDIO_NONE;\r\nreturn 0;\r\n} else if ((cfg & EM28XX_CHIPCFG_AUDIOMASK) != EM28XX_CHIPCFG_AC97) {\r\ndev->int_audio_type = EM28XX_INT_AUDIO_I2S;\r\nif (dev->chip_id < CHIP_ID_EM2860 &&\r\n(cfg & EM28XX_CHIPCFG_AUDIOMASK) ==\r\nEM2820_CHIPCFG_I2S_1_SAMPRATE)\r\ni2s_samplerates = 1;\r\nelse if (dev->chip_id >= CHIP_ID_EM2860 &&\r\n(cfg & EM28XX_CHIPCFG_AUDIOMASK) ==\r\nEM2860_CHIPCFG_I2S_5_SAMPRATES)\r\ni2s_samplerates = 5;\r\nelse\r\ni2s_samplerates = 3;\r\ndev_info(&dev->intf->dev, "I2S Audio (%d sample rate(s))\n",\r\ni2s_samplerates);\r\ndev->audio_mode.ac97 = EM28XX_NO_AC97;\r\ngoto init_audio;\r\n} else {\r\ndev->int_audio_type = EM28XX_INT_AUDIO_AC97;\r\n}\r\ndev->audio_mode.ac97 = EM28XX_AC97_OTHER;\r\nvid1 = em28xx_read_ac97(dev, AC97_VENDOR_ID1);\r\nif (vid1 < 0) {\r\ndev_warn(&dev->intf->dev,\r\n"AC97 chip type couldn't be determined\n");\r\ndev->audio_mode.ac97 = EM28XX_NO_AC97;\r\nif (dev->usb_audio_type == EM28XX_USB_AUDIO_VENDOR)\r\ndev->usb_audio_type = EM28XX_USB_AUDIO_NONE;\r\ndev->int_audio_type = EM28XX_INT_AUDIO_NONE;\r\ngoto init_audio;\r\n}\r\nvid2 = em28xx_read_ac97(dev, AC97_VENDOR_ID2);\r\nif (vid2 < 0)\r\ngoto init_audio;\r\nvid = vid1 << 16 | vid2;\r\ndev_warn(&dev->intf->dev, "AC97 vendor ID = 0x%08x\n", vid);\r\nfeat = em28xx_read_ac97(dev, AC97_RESET);\r\nif (feat < 0)\r\ngoto init_audio;\r\ndev_warn(&dev->intf->dev, "AC97 features = 0x%04x\n", feat);\r\nif (((vid == 0xffffffff) || (vid == 0x83847650)) && (feat == 0x6a90))\r\ndev->audio_mode.ac97 = EM28XX_AC97_EM202;\r\nelse if ((vid >> 8) == 0x838476)\r\ndev->audio_mode.ac97 = EM28XX_AC97_SIGMATEL;\r\ninit_audio:\r\nswitch (dev->audio_mode.ac97) {\r\ncase EM28XX_NO_AC97:\r\ndev_info(&dev->intf->dev, "No AC97 audio processor\n");\r\nbreak;\r\ncase EM28XX_AC97_EM202:\r\ndev_info(&dev->intf->dev,\r\n"Empia 202 AC97 audio processor detected\n");\r\nbreak;\r\ncase EM28XX_AC97_SIGMATEL:\r\ndev_info(&dev->intf->dev,\r\n"Sigmatel audio processor detected (stac 97%02x)\n",\r\nvid & 0xff);\r\nbreak;\r\ncase EM28XX_AC97_OTHER:\r\ndev_warn(&dev->intf->dev,\r\n"Unknown AC97 audio processor detected!\n");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn em28xx_audio_analog_set(dev);\r\n}\r\nconst struct em28xx_led *em28xx_find_led(struct em28xx *dev,\r\nenum em28xx_led_role role)\r\n{\r\nif (dev->board.leds) {\r\nu8 k = 0;\r\nwhile (dev->board.leds[k].role >= 0 &&\r\ndev->board.leds[k].role < EM28XX_NUM_LED_ROLES) {\r\nif (dev->board.leds[k].role == role)\r\nreturn &dev->board.leds[k];\r\nk++;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint em28xx_capture_start(struct em28xx *dev, int start)\r\n{\r\nint rc;\r\nconst struct em28xx_led *led = NULL;\r\nif (dev->chip_id == CHIP_ID_EM2874 ||\r\ndev->chip_id == CHIP_ID_EM2884 ||\r\ndev->chip_id == CHIP_ID_EM28174 ||\r\ndev->chip_id == CHIP_ID_EM28178) {\r\nrc = em28xx_write_reg_bits(dev, EM2874_R5F_TS_ENABLE,\r\nstart ?\r\nEM2874_TS1_CAPTURE_ENABLE : 0x00,\r\nEM2874_TS1_CAPTURE_ENABLE);\r\n} else {\r\nrc = em28xx_write_reg_bits(dev, EM28XX_R0C_USBSUSP,\r\nstart ? 0x10 : 0x00, 0x10);\r\nif (rc < 0)\r\nreturn rc;\r\nif (start) {\r\nif (dev->board.is_webcam)\r\nrc = em28xx_write_reg(dev, 0x13, 0x0c);\r\nrc = em28xx_write_reg(dev, 0x48, 0x00);\r\nif (rc < 0)\r\nreturn rc;\r\nif (dev->mode == EM28XX_ANALOG_MODE)\r\nrc = em28xx_write_reg(dev,\r\nEM28XX_R12_VINENABLE,\r\n0x67);\r\nelse\r\nrc = em28xx_write_reg(dev,\r\nEM28XX_R12_VINENABLE,\r\n0x37);\r\nif (rc < 0)\r\nreturn rc;\r\nmsleep(6);\r\n} else {\r\nrc = em28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x27);\r\n}\r\n}\r\nif (dev->mode == EM28XX_ANALOG_MODE)\r\nled = em28xx_find_led(dev, EM28XX_LED_ANALOG_CAPTURING);\r\nelse\r\nled = em28xx_find_led(dev, EM28XX_LED_DIGITAL_CAPTURING);\r\nif (led)\r\nem28xx_write_reg_bits(dev, led->gpio_reg,\r\n(!start ^ led->inverted) ?\r\n~led->gpio_mask : led->gpio_mask,\r\nled->gpio_mask);\r\nreturn rc;\r\n}\r\nint em28xx_gpio_set(struct em28xx *dev, struct em28xx_reg_seq *gpio)\r\n{\r\nint rc = 0;\r\nif (!gpio)\r\nreturn rc;\r\nif (dev->mode != EM28XX_SUSPEND) {\r\nem28xx_write_reg(dev, 0x48, 0x00);\r\nif (dev->mode == EM28XX_ANALOG_MODE)\r\nem28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x67);\r\nelse\r\nem28xx_write_reg(dev, EM28XX_R12_VINENABLE, 0x37);\r\nmsleep(6);\r\n}\r\nwhile (gpio->sleep >= 0) {\r\nif (gpio->reg >= 0) {\r\nrc = em28xx_write_reg_bits(dev,\r\ngpio->reg,\r\ngpio->val,\r\ngpio->mask);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nif (gpio->sleep > 0)\r\nmsleep(gpio->sleep);\r\ngpio++;\r\n}\r\nreturn rc;\r\n}\r\nint em28xx_set_mode(struct em28xx *dev, enum em28xx_mode set_mode)\r\n{\r\nif (dev->mode == set_mode)\r\nreturn 0;\r\nif (set_mode == EM28XX_SUSPEND) {\r\ndev->mode = set_mode;\r\nreturn em28xx_gpio_set(dev, dev->board.suspend_gpio);\r\n}\r\ndev->mode = set_mode;\r\nif (dev->mode == EM28XX_DIGITAL_MODE)\r\nreturn em28xx_gpio_set(dev, dev->board.dvb_gpio);\r\nelse\r\nreturn em28xx_gpio_set(dev, INPUT(dev->ctl_input)->gpio);\r\n}\r\nstatic void em28xx_irq_callback(struct urb *urb)\r\n{\r\nstruct em28xx *dev = urb->context;\r\nint i;\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\nem28xx_isocdbg("urb completition error %d.\n", urb->status);\r\nbreak;\r\n}\r\nspin_lock(&dev->slock);\r\ndev->usb_ctl.urb_data_copy(dev, urb);\r\nspin_unlock(&dev->slock);\r\nfor (i = 0; i < urb->number_of_packets; i++) {\r\nurb->iso_frame_desc[i].status = 0;\r\nurb->iso_frame_desc[i].actual_length = 0;\r\n}\r\nurb->status = 0;\r\nurb->status = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (urb->status) {\r\nem28xx_isocdbg("urb resubmit failed (error=%i)\n",\r\nurb->status);\r\n}\r\n}\r\nvoid em28xx_uninit_usb_xfer(struct em28xx *dev, enum em28xx_mode mode)\r\n{\r\nstruct urb *urb;\r\nstruct em28xx_usb_bufs *usb_bufs;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint i;\r\nem28xx_isocdbg("em28xx: called em28xx_uninit_usb_xfer in mode %d\n",\r\nmode);\r\nif (mode == EM28XX_DIGITAL_MODE)\r\nusb_bufs = &dev->usb_ctl.digital_bufs;\r\nelse\r\nusb_bufs = &dev->usb_ctl.analog_bufs;\r\nfor (i = 0; i < usb_bufs->num_bufs; i++) {\r\nurb = usb_bufs->urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\nif (usb_bufs->transfer_buffer[i]) {\r\nusb_free_coherent(udev,\r\nurb->transfer_buffer_length,\r\nusb_bufs->transfer_buffer[i],\r\nurb->transfer_dma);\r\n}\r\nusb_free_urb(urb);\r\nusb_bufs->urb[i] = NULL;\r\n}\r\nusb_bufs->transfer_buffer[i] = NULL;\r\n}\r\nkfree(usb_bufs->urb);\r\nkfree(usb_bufs->transfer_buffer);\r\nusb_bufs->urb = NULL;\r\nusb_bufs->transfer_buffer = NULL;\r\nusb_bufs->num_bufs = 0;\r\nem28xx_capture_start(dev, 0);\r\n}\r\nvoid em28xx_stop_urbs(struct em28xx *dev)\r\n{\r\nint i;\r\nstruct urb *urb;\r\nstruct em28xx_usb_bufs *isoc_bufs = &dev->usb_ctl.digital_bufs;\r\nem28xx_isocdbg("em28xx: called em28xx_stop_urbs\n");\r\nfor (i = 0; i < isoc_bufs->num_bufs; i++) {\r\nurb = isoc_bufs->urb[i];\r\nif (urb) {\r\nif (!irqs_disabled())\r\nusb_kill_urb(urb);\r\nelse\r\nusb_unlink_urb(urb);\r\n}\r\n}\r\nem28xx_capture_start(dev, 0);\r\n}\r\nint em28xx_alloc_urbs(struct em28xx *dev, enum em28xx_mode mode, int xfer_bulk,\r\nint num_bufs, int max_pkt_size, int packet_multiplier)\r\n{\r\nstruct em28xx_usb_bufs *usb_bufs;\r\nstruct urb *urb;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint i;\r\nint sb_size, pipe;\r\nint j, k;\r\nem28xx_isocdbg("em28xx: called em28xx_alloc_isoc in mode %d\n", mode);\r\nif (mode == EM28XX_DIGITAL_MODE) {\r\nif ((xfer_bulk && !dev->dvb_ep_bulk) ||\r\n(!xfer_bulk && !dev->dvb_ep_isoc)) {\r\ndev_err(&dev->intf->dev,\r\n"no endpoint for DVB mode and transfer type %d\n",\r\nxfer_bulk > 0);\r\nreturn -EINVAL;\r\n}\r\nusb_bufs = &dev->usb_ctl.digital_bufs;\r\n} else if (mode == EM28XX_ANALOG_MODE) {\r\nif ((xfer_bulk && !dev->analog_ep_bulk) ||\r\n(!xfer_bulk && !dev->analog_ep_isoc)) {\r\ndev_err(&dev->intf->dev,\r\n"no endpoint for analog mode and transfer type %d\n",\r\nxfer_bulk > 0);\r\nreturn -EINVAL;\r\n}\r\nusb_bufs = &dev->usb_ctl.analog_bufs;\r\n} else {\r\ndev_err(&dev->intf->dev, "invalid mode selected\n");\r\nreturn -EINVAL;\r\n}\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nusb_bufs->num_bufs = num_bufs;\r\nusb_bufs->urb = kzalloc(sizeof(void *)*num_bufs, GFP_KERNEL);\r\nif (!usb_bufs->urb)\r\nreturn -ENOMEM;\r\nusb_bufs->transfer_buffer = kzalloc(sizeof(void *)*num_bufs,\r\nGFP_KERNEL);\r\nif (!usb_bufs->transfer_buffer) {\r\nkfree(usb_bufs->urb);\r\nreturn -ENOMEM;\r\n}\r\nusb_bufs->max_pkt_size = max_pkt_size;\r\nif (xfer_bulk)\r\nusb_bufs->num_packets = 0;\r\nelse\r\nusb_bufs->num_packets = packet_multiplier;\r\ndev->usb_ctl.vid_buf = NULL;\r\ndev->usb_ctl.vbi_buf = NULL;\r\nsb_size = packet_multiplier * usb_bufs->max_pkt_size;\r\nfor (i = 0; i < usb_bufs->num_bufs; i++) {\r\nurb = usb_alloc_urb(usb_bufs->num_packets, GFP_KERNEL);\r\nif (!urb) {\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn -ENOMEM;\r\n}\r\nusb_bufs->urb[i] = urb;\r\nusb_bufs->transfer_buffer[i] = usb_alloc_coherent(udev,\r\nsb_size, GFP_KERNEL, &urb->transfer_dma);\r\nif (!usb_bufs->transfer_buffer[i]) {\r\ndev_err(&dev->intf->dev,\r\n"unable to allocate %i bytes for transfer buffer %i%s\n",\r\nsb_size, i,\r\nin_interrupt() ? " while in int" : "");\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn -ENOMEM;\r\n}\r\nmemset(usb_bufs->transfer_buffer[i], 0, sb_size);\r\nif (xfer_bulk) {\r\npipe = usb_rcvbulkpipe(udev,\r\nmode == EM28XX_ANALOG_MODE ?\r\ndev->analog_ep_bulk :\r\ndev->dvb_ep_bulk);\r\nusb_fill_bulk_urb(urb, udev, pipe,\r\nusb_bufs->transfer_buffer[i], sb_size,\r\nem28xx_irq_callback, dev);\r\nurb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\n} else {\r\npipe = usb_rcvisocpipe(udev,\r\nmode == EM28XX_ANALOG_MODE ?\r\ndev->analog_ep_isoc :\r\ndev->dvb_ep_isoc);\r\nusb_fill_int_urb(urb, udev, pipe,\r\nusb_bufs->transfer_buffer[i], sb_size,\r\nem28xx_irq_callback, dev, 1);\r\nurb->transfer_flags = URB_ISO_ASAP |\r\nURB_NO_TRANSFER_DMA_MAP;\r\nk = 0;\r\nfor (j = 0; j < usb_bufs->num_packets; j++) {\r\nurb->iso_frame_desc[j].offset = k;\r\nurb->iso_frame_desc[j].length =\r\nusb_bufs->max_pkt_size;\r\nk += usb_bufs->max_pkt_size;\r\n}\r\n}\r\nurb->number_of_packets = usb_bufs->num_packets;\r\n}\r\nreturn 0;\r\n}\r\nint em28xx_init_usb_xfer(struct em28xx *dev, enum em28xx_mode mode,\r\nint xfer_bulk, int num_bufs, int max_pkt_size,\r\nint packet_multiplier,\r\nint (*urb_data_copy)(struct em28xx *dev, struct urb *urb))\r\n{\r\nstruct em28xx_dmaqueue *dma_q = &dev->vidq;\r\nstruct em28xx_dmaqueue *vbi_dma_q = &dev->vbiq;\r\nstruct em28xx_usb_bufs *usb_bufs;\r\nstruct usb_device *udev = interface_to_usbdev(dev->intf);\r\nint i;\r\nint rc;\r\nint alloc;\r\nem28xx_isocdbg("em28xx: called em28xx_init_usb_xfer in mode %d\n",\r\nmode);\r\ndev->usb_ctl.urb_data_copy = urb_data_copy;\r\nif (mode == EM28XX_DIGITAL_MODE) {\r\nusb_bufs = &dev->usb_ctl.digital_bufs;\r\nalloc = 0;\r\n} else {\r\nusb_bufs = &dev->usb_ctl.analog_bufs;\r\nalloc = 1;\r\n}\r\nif (alloc) {\r\nrc = em28xx_alloc_urbs(dev, mode, xfer_bulk, num_bufs,\r\nmax_pkt_size, packet_multiplier);\r\nif (rc)\r\nreturn rc;\r\n}\r\nif (xfer_bulk) {\r\nrc = usb_clear_halt(udev, usb_bufs->urb[0]->pipe);\r\nif (rc < 0) {\r\ndev_err(&dev->intf->dev,\r\n"failed to clear USB bulk endpoint stall/halt condition (error=%i)\n",\r\nrc);\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn rc;\r\n}\r\n}\r\ninit_waitqueue_head(&dma_q->wq);\r\ninit_waitqueue_head(&vbi_dma_q->wq);\r\nem28xx_capture_start(dev, 1);\r\nfor (i = 0; i < usb_bufs->num_bufs; i++) {\r\nrc = usb_submit_urb(usb_bufs->urb[i], GFP_ATOMIC);\r\nif (rc) {\r\ndev_err(&dev->intf->dev,\r\n"submit of urb %i failed (error=%i)\n", i, rc);\r\nem28xx_uninit_usb_xfer(dev, mode);\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint em28xx_register_extension(struct em28xx_ops *ops)\r\n{\r\nstruct em28xx *dev = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_add_tail(&ops->next, &em28xx_extension_devlist);\r\nlist_for_each_entry(dev, &em28xx_devlist, devlist) {\r\nops->init(dev);\r\n}\r\nmutex_unlock(&em28xx_devlist_mutex);\r\npr_info("em28xx: Registered (%s) extension\n", ops->name);\r\nreturn 0;\r\n}\r\nvoid em28xx_unregister_extension(struct em28xx_ops *ops)\r\n{\r\nstruct em28xx *dev = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_for_each_entry(dev, &em28xx_devlist, devlist) {\r\nops->fini(dev);\r\n}\r\nlist_del(&ops->next);\r\nmutex_unlock(&em28xx_devlist_mutex);\r\npr_info("em28xx: Removed (%s) extension\n", ops->name);\r\n}\r\nvoid em28xx_init_extension(struct em28xx *dev)\r\n{\r\nconst struct em28xx_ops *ops = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_add_tail(&dev->devlist, &em28xx_devlist);\r\nlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\r\nif (ops->init)\r\nops->init(dev);\r\n}\r\nmutex_unlock(&em28xx_devlist_mutex);\r\n}\r\nvoid em28xx_close_extension(struct em28xx *dev)\r\n{\r\nconst struct em28xx_ops *ops = NULL;\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\r\nif (ops->fini)\r\nops->fini(dev);\r\n}\r\nlist_del(&dev->devlist);\r\nmutex_unlock(&em28xx_devlist_mutex);\r\n}\r\nint em28xx_suspend_extension(struct em28xx *dev)\r\n{\r\nconst struct em28xx_ops *ops = NULL;\r\ndev_info(&dev->intf->dev, "Suspending extensions\n");\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\r\nif (ops->suspend)\r\nops->suspend(dev);\r\n}\r\nmutex_unlock(&em28xx_devlist_mutex);\r\nreturn 0;\r\n}\r\nint em28xx_resume_extension(struct em28xx *dev)\r\n{\r\nconst struct em28xx_ops *ops = NULL;\r\ndev_info(&dev->intf->dev, "Resuming extensions\n");\r\nmutex_lock(&em28xx_devlist_mutex);\r\nlist_for_each_entry(ops, &em28xx_extension_devlist, next) {\r\nif (ops->resume)\r\nops->resume(dev);\r\n}\r\nmutex_unlock(&em28xx_devlist_mutex);\r\nreturn 0;\r\n}
