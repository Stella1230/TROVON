static struct max63xx_timeout *\r\nmax63xx_select_timeout(struct max63xx_timeout *table, int value)\r\n{\r\nwhile (table->twd) {\r\nif (value <= table->twd) {\r\nif (nodelay && table->tdelay == 0)\r\nreturn table;\r\nif (!nodelay)\r\nreturn table;\r\n}\r\ntable++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int max63xx_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct max63xx_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->ping(wdt);\r\nreturn 0;\r\n}\r\nstatic int max63xx_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct max63xx_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->set(wdt, wdt->timeout->wdset);\r\nif (wdt->timeout->tdelay == 0)\r\nwdt->ping(wdt);\r\nreturn 0;\r\n}\r\nstatic int max63xx_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct max63xx_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwdt->set(wdt, MAX6369_WDSET_DISABLED);\r\nreturn 0;\r\n}\r\nstatic void max63xx_mmap_ping(struct max63xx_wdt *wdt)\r\n{\r\nu8 val;\r\nspin_lock(&wdt->lock);\r\nval = __raw_readb(wdt->base);\r\n__raw_writeb(val | MAX6369_WDI, wdt->base);\r\n__raw_writeb(val & ~MAX6369_WDI, wdt->base);\r\nspin_unlock(&wdt->lock);\r\n}\r\nstatic void max63xx_mmap_set(struct max63xx_wdt *wdt, u8 set)\r\n{\r\nu8 val;\r\nspin_lock(&wdt->lock);\r\nval = __raw_readb(wdt->base);\r\nval &= ~MAX6369_WDSET;\r\nval |= set & MAX6369_WDSET;\r\n__raw_writeb(val, wdt->base);\r\nspin_unlock(&wdt->lock);\r\n}\r\nstatic int max63xx_mmap_init(struct platform_device *p, struct max63xx_wdt *wdt)\r\n{\r\nstruct resource *mem = platform_get_resource(p, IORESOURCE_MEM, 0);\r\nwdt->base = devm_ioremap_resource(&p->dev, mem);\r\nif (IS_ERR(wdt->base))\r\nreturn PTR_ERR(wdt->base);\r\nspin_lock_init(&wdt->lock);\r\nwdt->ping = max63xx_mmap_ping;\r\nwdt->set = max63xx_mmap_set;\r\nreturn 0;\r\n}\r\nstatic int max63xx_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct max63xx_wdt *wdt;\r\nstruct max63xx_timeout *table;\r\nint err;\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\ntable = (struct max63xx_timeout *)pdev->id_entry->driver_data;\r\nif (heartbeat < 1 || heartbeat > MAX_HEARTBEAT)\r\nheartbeat = DEFAULT_HEARTBEAT;\r\nwdt->timeout = max63xx_select_timeout(table, heartbeat);\r\nif (!wdt->timeout) {\r\ndev_err(&pdev->dev, "unable to satisfy %ds heartbeat request\n",\r\nheartbeat);\r\nreturn -EINVAL;\r\n}\r\nerr = max63xx_mmap_init(pdev, wdt);\r\nif (err)\r\nreturn err;\r\nplatform_set_drvdata(pdev, &wdt->wdd);\r\nwatchdog_set_drvdata(&wdt->wdd, wdt);\r\nwdt->wdd.parent = &pdev->dev;\r\nwdt->wdd.timeout = wdt->timeout->twd;\r\nwdt->wdd.info = &max63xx_wdt_info;\r\nwdt->wdd.ops = &max63xx_wdt_ops;\r\nwatchdog_set_nowayout(&wdt->wdd, nowayout);\r\nerr = watchdog_register_device(&wdt->wdd);\r\nif (err)\r\nreturn err;\r\ndev_info(&pdev->dev, "using %ds heartbeat with %ds initial delay\n",\r\nwdt->timeout->twd, wdt->timeout->tdelay);\r\nreturn 0;\r\n}\r\nstatic int max63xx_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdd = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(wdd);\r\nreturn 0;\r\n}
