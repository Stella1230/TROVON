static struct intel_community *intel_get_community(struct intel_pinctrl *pctrl,\r\nunsigned pin)\r\n{\r\nstruct intel_community *community;\r\nint i;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\ncommunity = &pctrl->communities[i];\r\nif (pin >= community->pin_base &&\r\npin < community->pin_base + community->npins)\r\nreturn community;\r\n}\r\ndev_warn(pctrl->dev, "failed to find community for pin %u\n", pin);\r\nreturn NULL;\r\n}\r\nstatic void __iomem *intel_get_padcfg(struct intel_pinctrl *pctrl, unsigned pin,\r\nunsigned reg)\r\n{\r\nconst struct intel_community *community;\r\nunsigned padno;\r\nsize_t nregs;\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (!community)\r\nreturn NULL;\r\npadno = pin_to_padno(community, pin);\r\nnregs = (community->features & PINCTRL_FEATURE_DEBOUNCE) ? 4 : 2;\r\nif (reg == PADCFG2 && !(community->features & PINCTRL_FEATURE_DEBOUNCE))\r\nreturn NULL;\r\nreturn community->pad_regs + reg + padno * nregs * 4;\r\n}\r\nstatic bool intel_pad_owned_by_host(struct intel_pinctrl *pctrl, unsigned pin)\r\n{\r\nconst struct intel_community *community;\r\nunsigned padno, gpp, offset, group;\r\nvoid __iomem *padown;\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (!community)\r\nreturn false;\r\nif (!community->padown_offset)\r\nreturn true;\r\npadno = pin_to_padno(community, pin);\r\ngroup = padno / community->gpp_size;\r\ngpp = PADOWN_GPP(padno % community->gpp_size);\r\noffset = community->padown_offset + 0x10 * group + gpp * 4;\r\npadown = community->regs + offset;\r\nreturn !(readl(padown) & PADOWN_MASK(padno));\r\n}\r\nstatic bool intel_pad_acpi_mode(struct intel_pinctrl *pctrl, unsigned pin)\r\n{\r\nconst struct intel_community *community;\r\nunsigned padno, gpp, offset;\r\nvoid __iomem *hostown;\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (!community)\r\nreturn true;\r\nif (!community->hostown_offset)\r\nreturn false;\r\npadno = pin_to_padno(community, pin);\r\ngpp = padno / community->gpp_size;\r\noffset = community->hostown_offset + gpp * 4;\r\nhostown = community->regs + offset;\r\nreturn !(readl(hostown) & BIT(padno % community->gpp_size));\r\n}\r\nstatic bool intel_pad_locked(struct intel_pinctrl *pctrl, unsigned pin)\r\n{\r\nstruct intel_community *community;\r\nunsigned padno, gpp, offset;\r\nu32 value;\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (!community)\r\nreturn true;\r\nif (!community->padcfglock_offset)\r\nreturn false;\r\npadno = pin_to_padno(community, pin);\r\ngpp = padno / community->gpp_size;\r\noffset = community->padcfglock_offset + gpp * 8;\r\nvalue = readl(community->regs + offset);\r\nif (value & BIT(pin % community->gpp_size))\r\nreturn true;\r\noffset = community->padcfglock_offset + 4 + gpp * 8;\r\nvalue = readl(community->regs + offset);\r\nif (value & BIT(pin % community->gpp_size))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool intel_pad_usable(struct intel_pinctrl *pctrl, unsigned pin)\r\n{\r\nreturn intel_pad_owned_by_host(pctrl, pin) &&\r\n!intel_pad_locked(pctrl, pin);\r\n}\r\nstatic int intel_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->ngroups;\r\n}\r\nstatic const char *intel_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->groups[group].name;\r\n}\r\nstatic int intel_get_group_pins(struct pinctrl_dev *pctldev, unsigned group,\r\nconst unsigned **pins, unsigned *npins)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pctrl->soc->groups[group].pins;\r\n*npins = pctrl->soc->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic void intel_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned pin)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nvoid __iomem *padcfg;\r\nu32 cfg0, cfg1, mode;\r\nbool locked, acpi;\r\nif (!intel_pad_owned_by_host(pctrl, pin)) {\r\nseq_puts(s, "not available");\r\nreturn;\r\n}\r\ncfg0 = readl(intel_get_padcfg(pctrl, pin, PADCFG0));\r\ncfg1 = readl(intel_get_padcfg(pctrl, pin, PADCFG1));\r\nmode = (cfg0 & PADCFG0_PMODE_MASK) >> PADCFG0_PMODE_SHIFT;\r\nif (!mode)\r\nseq_puts(s, "GPIO ");\r\nelse\r\nseq_printf(s, "mode %d ", mode);\r\nseq_printf(s, "0x%08x 0x%08x", cfg0, cfg1);\r\npadcfg = intel_get_padcfg(pctrl, pin, PADCFG2);\r\nif (padcfg)\r\nseq_printf(s, " 0x%08x", readl(padcfg));\r\nlocked = intel_pad_locked(pctrl, pin);\r\nacpi = intel_pad_acpi_mode(pctrl, pin);\r\nif (locked || acpi) {\r\nseq_puts(s, " [");\r\nif (locked) {\r\nseq_puts(s, "LOCKED");\r\nif (acpi)\r\nseq_puts(s, ", ");\r\n}\r\nif (acpi)\r\nseq_puts(s, "ACPI");\r\nseq_puts(s, "]");\r\n}\r\n}\r\nstatic int intel_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->nfunctions;\r\n}\r\nstatic const char *intel_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->functions[function].name;\r\n}\r\nstatic int intel_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const ngroups)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctrl->soc->functions[function].groups;\r\n*ngroups = pctrl->soc->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int intel_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,\r\nunsigned group)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct intel_pingroup *grp = &pctrl->soc->groups[group];\r\nunsigned long flags;\r\nint i;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nfor (i = 0; i < grp->npins; i++) {\r\nif (!intel_pad_usable(pctrl, grp->pins[i])) {\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EBUSY;\r\n}\r\n}\r\nfor (i = 0; i < grp->npins; i++) {\r\nvoid __iomem *padcfg0;\r\nu32 value;\r\npadcfg0 = intel_get_padcfg(pctrl, grp->pins[i], PADCFG0);\r\nvalue = readl(padcfg0);\r\nvalue &= ~PADCFG0_PMODE_MASK;\r\nvalue |= grp->mode << PADCFG0_PMODE_SHIFT;\r\nwritel(value, padcfg0);\r\n}\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void __intel_gpio_set_direction(void __iomem *padcfg0, bool input)\r\n{\r\nu32 value;\r\nvalue = readl(padcfg0);\r\nif (input) {\r\nvalue &= ~PADCFG0_GPIORXDIS;\r\nvalue |= PADCFG0_GPIOTXDIS;\r\n} else {\r\nvalue &= ~PADCFG0_GPIOTXDIS;\r\nvalue |= PADCFG0_GPIORXDIS;\r\n}\r\nwritel(value, padcfg0);\r\n}\r\nstatic int intel_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned pin)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nvoid __iomem *padcfg0;\r\nunsigned long flags;\r\nu32 value;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nif (!intel_pad_usable(pctrl, pin)) {\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn -EBUSY;\r\n}\r\npadcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);\r\nvalue = readl(padcfg0) & ~PADCFG0_PMODE_MASK;\r\nvalue &= ~(PADCFG0_GPIROUTIOXAPIC | PADCFG0_GPIROUTSCI);\r\nvalue &= ~(PADCFG0_GPIROUTSMI | PADCFG0_GPIROUTNMI);\r\nwritel(value, padcfg0);\r\n__intel_gpio_set_direction(padcfg0, true);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int intel_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned pin, bool input)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nvoid __iomem *padcfg0;\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\npadcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);\r\n__intel_gpio_set_direction(padcfg0, input);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int intel_config_get(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *config)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nenum pin_config_param param = pinconf_to_config_param(*config);\r\nconst struct intel_community *community;\r\nu32 value, term;\r\nu32 arg = 0;\r\nif (!intel_pad_owned_by_host(pctrl, pin))\r\nreturn -ENOTSUPP;\r\ncommunity = intel_get_community(pctrl, pin);\r\nvalue = readl(intel_get_padcfg(pctrl, pin, PADCFG1));\r\nterm = (value & PADCFG1_TERM_MASK) >> PADCFG1_TERM_SHIFT;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nif (term)\r\nreturn -EINVAL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nif (!term || !(value & PADCFG1_TERM_UP))\r\nreturn -EINVAL;\r\nswitch (term) {\r\ncase PADCFG1_TERM_1K:\r\narg = 1000;\r\nbreak;\r\ncase PADCFG1_TERM_2K:\r\narg = 2000;\r\nbreak;\r\ncase PADCFG1_TERM_5K:\r\narg = 5000;\r\nbreak;\r\ncase PADCFG1_TERM_20K:\r\narg = 20000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nif (!term || value & PADCFG1_TERM_UP)\r\nreturn -EINVAL;\r\nswitch (term) {\r\ncase PADCFG1_TERM_1K:\r\nif (!(community->features & PINCTRL_FEATURE_1K_PD))\r\nreturn -EINVAL;\r\narg = 1000;\r\nbreak;\r\ncase PADCFG1_TERM_5K:\r\narg = 5000;\r\nbreak;\r\ncase PADCFG1_TERM_20K:\r\narg = 20000;\r\nbreak;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_INPUT_DEBOUNCE: {\r\nvoid __iomem *padcfg2;\r\nu32 v;\r\npadcfg2 = intel_get_padcfg(pctrl, pin, PADCFG2);\r\nif (!padcfg2)\r\nreturn -ENOTSUPP;\r\nv = readl(padcfg2);\r\nif (!(v & PADCFG2_DEBEN))\r\nreturn -EINVAL;\r\nv = (v & PADCFG2_DEBOUNCE_MASK) >> PADCFG2_DEBOUNCE_SHIFT;\r\narg = BIT(v) * DEBOUNCE_PERIOD / 1000;\r\nbreak;\r\n}\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int intel_config_set_pull(struct intel_pinctrl *pctrl, unsigned pin,\r\nunsigned long config)\r\n{\r\nunsigned param = pinconf_to_config_param(config);\r\nunsigned arg = pinconf_to_config_argument(config);\r\nconst struct intel_community *community;\r\nvoid __iomem *padcfg1;\r\nunsigned long flags;\r\nint ret = 0;\r\nu32 value;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\ncommunity = intel_get_community(pctrl, pin);\r\npadcfg1 = intel_get_padcfg(pctrl, pin, PADCFG1);\r\nvalue = readl(padcfg1);\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\nvalue &= ~(PADCFG1_TERM_MASK | PADCFG1_TERM_UP);\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\nvalue &= ~PADCFG1_TERM_MASK;\r\nvalue |= PADCFG1_TERM_UP;\r\nswitch (arg) {\r\ncase 20000:\r\nvalue |= PADCFG1_TERM_20K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ncase 5000:\r\nvalue |= PADCFG1_TERM_5K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ncase 2000:\r\nvalue |= PADCFG1_TERM_2K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ncase 1000:\r\nvalue |= PADCFG1_TERM_1K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nvalue &= ~(PADCFG1_TERM_UP | PADCFG1_TERM_MASK);\r\nswitch (arg) {\r\ncase 20000:\r\nvalue |= PADCFG1_TERM_20K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ncase 5000:\r\nvalue |= PADCFG1_TERM_5K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ncase 1000:\r\nif (!(community->features & PINCTRL_FEATURE_1K_PD)) {\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nvalue |= PADCFG1_TERM_1K << PADCFG1_TERM_SHIFT;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (!ret)\r\nwritel(value, padcfg1);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int intel_config_set_debounce(struct intel_pinctrl *pctrl, unsigned pin,\r\nunsigned debounce)\r\n{\r\nvoid __iomem *padcfg0, *padcfg2;\r\nunsigned long flags;\r\nu32 value0, value2;\r\nint ret = 0;\r\npadcfg2 = intel_get_padcfg(pctrl, pin, PADCFG2);\r\nif (!padcfg2)\r\nreturn -ENOTSUPP;\r\npadcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nvalue0 = readl(padcfg0);\r\nvalue2 = readl(padcfg2);\r\nvalue0 &= ~PADCFG0_PREGFRXSEL;\r\nvalue2 &= ~(PADCFG2_DEBEN | PADCFG2_DEBOUNCE_MASK);\r\nif (debounce) {\r\nunsigned long v;\r\nv = order_base_2(debounce * 1000 / DEBOUNCE_PERIOD);\r\nif (v < 3 || v > 15) {\r\nret = -EINVAL;\r\ngoto exit_unlock;\r\n} else {\r\nvalue0 |= PADCFG0_PREGFRXSEL;\r\nvalue2 |= v << PADCFG2_DEBOUNCE_SHIFT;\r\nvalue2 |= PADCFG2_DEBEN;\r\n}\r\n}\r\nwritel(value0, padcfg0);\r\nwritel(value2, padcfg2);\r\nexit_unlock:\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int intel_config_set(struct pinctrl_dev *pctldev, unsigned pin,\r\nunsigned long *configs, unsigned nconfigs)\r\n{\r\nstruct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nint i, ret;\r\nif (!intel_pad_usable(pctrl, pin))\r\nreturn -ENOTSUPP;\r\nfor (i = 0; i < nconfigs; i++) {\r\nswitch (pinconf_to_config_param(configs[i])) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\nret = intel_config_set_pull(pctrl, pin, configs[i]);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_DEBOUNCE:\r\nret = intel_config_set_debounce(pctrl, pin,\r\npinconf_to_config_argument(configs[i]));\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int intel_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\r\nvoid __iomem *reg;\r\nreg = intel_get_padcfg(pctrl, offset, PADCFG0);\r\nif (!reg)\r\nreturn -EINVAL;\r\nreturn !!(readl(reg) & PADCFG0_GPIORXSTATE);\r\n}\r\nstatic void intel_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(chip);\r\nvoid __iomem *reg;\r\nreg = intel_get_padcfg(pctrl, offset, PADCFG0);\r\nif (reg) {\r\nunsigned long flags;\r\nu32 padcfg0;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\npadcfg0 = readl(reg);\r\nif (value)\r\npadcfg0 |= PADCFG0_GPIOTXSTATE;\r\nelse\r\npadcfg0 &= ~PADCFG0_GPIOTXSTATE;\r\nwritel(padcfg0, reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\n}\r\nstatic int intel_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nreturn pinctrl_gpio_direction_input(chip->base + offset);\r\n}\r\nstatic int intel_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nintel_gpio_set(chip, offset, value);\r\nreturn pinctrl_gpio_direction_output(chip->base + offset);\r\n}\r\nstatic void intel_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct intel_community *community;\r\nunsigned pin = irqd_to_hwirq(d);\r\nraw_spin_lock(&pctrl->lock);\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (community) {\r\nunsigned padno = pin_to_padno(community, pin);\r\nunsigned gpp_offset = padno % community->gpp_size;\r\nunsigned gpp = padno / community->gpp_size;\r\nwritel(BIT(gpp_offset), community->regs + GPI_IS + gpp * 4);\r\n}\r\nraw_spin_unlock(&pctrl->lock);\r\n}\r\nstatic void intel_gpio_irq_enable(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct intel_community *community;\r\nunsigned pin = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (community) {\r\nunsigned padno = pin_to_padno(community, pin);\r\nunsigned gpp_size = community->gpp_size;\r\nunsigned gpp_offset = padno % gpp_size;\r\nunsigned gpp = padno / gpp_size;\r\nu32 value;\r\nwritel(BIT(gpp_offset), community->regs + GPI_IS + gpp * 4);\r\nvalue = readl(community->regs + community->ie_offset + gpp * 4);\r\nvalue |= BIT(gpp_offset);\r\nwritel(value, community->regs + community->ie_offset + gpp * 4);\r\n}\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic void intel_gpio_irq_mask_unmask(struct irq_data *d, bool mask)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct intel_community *community;\r\nunsigned pin = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\ncommunity = intel_get_community(pctrl, pin);\r\nif (community) {\r\nunsigned padno = pin_to_padno(community, pin);\r\nunsigned gpp_offset = padno % community->gpp_size;\r\nunsigned gpp = padno / community->gpp_size;\r\nvoid __iomem *reg;\r\nu32 value;\r\nreg = community->regs + community->ie_offset + gpp * 4;\r\nvalue = readl(reg);\r\nif (mask)\r\nvalue &= ~BIT(gpp_offset);\r\nelse\r\nvalue |= BIT(gpp_offset);\r\nwritel(value, reg);\r\n}\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic void intel_gpio_irq_mask(struct irq_data *d)\r\n{\r\nintel_gpio_irq_mask_unmask(d, true);\r\n}\r\nstatic void intel_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nintel_gpio_irq_mask_unmask(d, false);\r\n}\r\nstatic int intel_gpio_irq_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\r\nunsigned pin = irqd_to_hwirq(d);\r\nunsigned long flags;\r\nvoid __iomem *reg;\r\nu32 value;\r\nreg = intel_get_padcfg(pctrl, pin, PADCFG0);\r\nif (!reg)\r\nreturn -EINVAL;\r\nif (intel_pad_acpi_mode(pctrl, pin)) {\r\ndev_warn(pctrl->dev, "pin %u cannot be used as IRQ\n", pin);\r\nreturn -EPERM;\r\n}\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nvalue = readl(reg);\r\nvalue &= ~(PADCFG0_RXEVCFG_MASK | PADCFG0_RXINV);\r\nif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\nvalue |= PADCFG0_RXEVCFG_EDGE_BOTH << PADCFG0_RXEVCFG_SHIFT;\r\n} else if (type & IRQ_TYPE_EDGE_FALLING) {\r\nvalue |= PADCFG0_RXEVCFG_EDGE << PADCFG0_RXEVCFG_SHIFT;\r\nvalue |= PADCFG0_RXINV;\r\n} else if (type & IRQ_TYPE_EDGE_RISING) {\r\nvalue |= PADCFG0_RXEVCFG_EDGE << PADCFG0_RXEVCFG_SHIFT;\r\n} else if (type & IRQ_TYPE_LEVEL_MASK) {\r\nif (type & IRQ_TYPE_LEVEL_LOW)\r\nvalue |= PADCFG0_RXINV;\r\n} else {\r\nvalue |= PADCFG0_RXEVCFG_DISABLED << PADCFG0_RXEVCFG_SHIFT;\r\n}\r\nwritel(value, reg);\r\nif (type & IRQ_TYPE_EDGE_BOTH)\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nelse if (type & IRQ_TYPE_LEVEL_MASK)\r\nirq_set_handler_locked(d, handle_level_irq);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int intel_gpio_irq_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct intel_pinctrl *pctrl = gpiochip_get_data(gc);\r\nunsigned pin = irqd_to_hwirq(d);\r\nif (on)\r\nenable_irq_wake(pctrl->irq);\r\nelse\r\ndisable_irq_wake(pctrl->irq);\r\ndev_dbg(pctrl->dev, "%sable wake for pin %u\n", on ? "en" : "dis", pin);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t intel_gpio_community_irq_handler(struct intel_pinctrl *pctrl,\r\nconst struct intel_community *community)\r\n{\r\nstruct gpio_chip *gc = &pctrl->chip;\r\nirqreturn_t ret = IRQ_NONE;\r\nint gpp;\r\nfor (gpp = 0; gpp < community->ngpps; gpp++) {\r\nunsigned long pending, enabled, gpp_offset;\r\npending = readl(community->regs + GPI_IS + gpp * 4);\r\nenabled = readl(community->regs + community->ie_offset +\r\ngpp * 4);\r\npending &= enabled;\r\nfor_each_set_bit(gpp_offset, &pending, community->gpp_size) {\r\nunsigned padno, irq;\r\npadno = gpp_offset + gpp * community->gpp_size;\r\nif (padno >= community->npins)\r\nbreak;\r\nirq = irq_find_mapping(gc->irqdomain,\r\ncommunity->pin_base + padno);\r\ngeneric_handle_irq(irq);\r\nret |= IRQ_HANDLED;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic irqreturn_t intel_gpio_irq(int irq, void *data)\r\n{\r\nconst struct intel_community *community;\r\nstruct intel_pinctrl *pctrl = data;\r\nirqreturn_t ret = IRQ_NONE;\r\nint i;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\ncommunity = &pctrl->communities[i];\r\nret |= intel_gpio_community_irq_handler(pctrl, community);\r\n}\r\nreturn ret;\r\n}\r\nstatic int intel_gpio_probe(struct intel_pinctrl *pctrl, int irq)\r\n{\r\nint ret;\r\npctrl->chip = intel_gpio_chip;\r\npctrl->chip.ngpio = pctrl->soc->npins;\r\npctrl->chip.label = dev_name(pctrl->dev);\r\npctrl->chip.parent = pctrl->dev;\r\npctrl->chip.base = -1;\r\npctrl->irq = irq;\r\nret = devm_gpiochip_add_data(pctrl->dev, &pctrl->chip, pctrl);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to register gpiochip\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev),\r\n0, 0, pctrl->soc->npins);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to add GPIO pin range\n");\r\nreturn ret;\r\n}\r\nret = devm_request_irq(pctrl->dev, irq, intel_gpio_irq,\r\nIRQF_SHARED | IRQF_NO_THREAD,\r\ndev_name(pctrl->dev), pctrl);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to request interrupt\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(&pctrl->chip, &intel_gpio_irqchip, 0,\r\nhandle_bad_irq, IRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(pctrl->dev, "failed to add irqchip\n");\r\nreturn ret;\r\n}\r\ngpiochip_set_chained_irqchip(&pctrl->chip, &intel_gpio_irqchip, irq,\r\nNULL);\r\nreturn 0;\r\n}\r\nstatic int intel_pinctrl_pm_init(struct intel_pinctrl *pctrl)\r\n{\r\n#ifdef CONFIG_PM_SLEEP\r\nconst struct intel_pinctrl_soc_data *soc = pctrl->soc;\r\nstruct intel_community_context *communities;\r\nstruct intel_pad_context *pads;\r\nint i;\r\npads = devm_kcalloc(pctrl->dev, soc->npins, sizeof(*pads), GFP_KERNEL);\r\nif (!pads)\r\nreturn -ENOMEM;\r\ncommunities = devm_kcalloc(pctrl->dev, pctrl->ncommunities,\r\nsizeof(*communities), GFP_KERNEL);\r\nif (!communities)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\nstruct intel_community *community = &pctrl->communities[i];\r\nu32 *intmask;\r\nintmask = devm_kcalloc(pctrl->dev, community->ngpps,\r\nsizeof(*intmask), GFP_KERNEL);\r\nif (!intmask)\r\nreturn -ENOMEM;\r\ncommunities[i].intmask = intmask;\r\n}\r\npctrl->context.pads = pads;\r\npctrl->context.communities = communities;\r\n#endif\r\nreturn 0;\r\n}\r\nint intel_pinctrl_probe(struct platform_device *pdev,\r\nconst struct intel_pinctrl_soc_data *soc_data)\r\n{\r\nstruct intel_pinctrl *pctrl;\r\nint i, ret, irq;\r\nif (!soc_data)\r\nreturn -EINVAL;\r\npctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\r\nif (!pctrl)\r\nreturn -ENOMEM;\r\npctrl->dev = &pdev->dev;\r\npctrl->soc = soc_data;\r\nraw_spin_lock_init(&pctrl->lock);\r\npctrl->ncommunities = pctrl->soc->ncommunities;\r\npctrl->communities = devm_kcalloc(&pdev->dev, pctrl->ncommunities,\r\nsizeof(*pctrl->communities), GFP_KERNEL);\r\nif (!pctrl->communities)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\nstruct intel_community *community = &pctrl->communities[i];\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nu32 padbar;\r\n*community = pctrl->soc->communities[i];\r\nres = platform_get_resource(pdev, IORESOURCE_MEM,\r\ncommunity->barno);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nif (!community->features) {\r\nu32 rev;\r\nrev = (readl(regs + REVID) & REVID_MASK) >> REVID_SHIFT;\r\nif (rev >= 0x94) {\r\ncommunity->features |= PINCTRL_FEATURE_DEBOUNCE;\r\ncommunity->features |= PINCTRL_FEATURE_1K_PD;\r\n}\r\n}\r\npadbar = readl(regs + PADBAR);\r\ncommunity->regs = regs;\r\ncommunity->pad_regs = regs + padbar;\r\ncommunity->ngpps = DIV_ROUND_UP(community->npins,\r\ncommunity->gpp_size);\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get interrupt number\n");\r\nreturn irq;\r\n}\r\nret = intel_pinctrl_pm_init(pctrl);\r\nif (ret)\r\nreturn ret;\r\npctrl->pctldesc = intel_pinctrl_desc;\r\npctrl->pctldesc.name = dev_name(&pdev->dev);\r\npctrl->pctldesc.pins = pctrl->soc->pins;\r\npctrl->pctldesc.npins = pctrl->soc->npins;\r\npctrl->pctldev = devm_pinctrl_register(&pdev->dev, &pctrl->pctldesc,\r\npctrl);\r\nif (IS_ERR(pctrl->pctldev)) {\r\ndev_err(&pdev->dev, "failed to register pinctrl driver\n");\r\nreturn PTR_ERR(pctrl->pctldev);\r\n}\r\nret = intel_gpio_probe(pctrl, irq);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, pctrl);\r\nreturn 0;\r\n}\r\nstatic bool intel_pinctrl_should_save(struct intel_pinctrl *pctrl, unsigned pin)\r\n{\r\nconst struct pin_desc *pd = pin_desc_get(pctrl->pctldev, pin);\r\nif (!pd || !intel_pad_usable(pctrl, pin))\r\nreturn false;\r\nif (pd->mux_owner || pd->gpio_owner ||\r\ngpiochip_line_is_irq(&pctrl->chip, pin))\r\nreturn true;\r\nreturn false;\r\n}\r\nint intel_pinctrl_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct intel_pinctrl *pctrl = platform_get_drvdata(pdev);\r\nstruct intel_community_context *communities;\r\nstruct intel_pad_context *pads;\r\nint i;\r\npads = pctrl->context.pads;\r\nfor (i = 0; i < pctrl->soc->npins; i++) {\r\nconst struct pinctrl_pin_desc *desc = &pctrl->soc->pins[i];\r\nvoid __iomem *padcfg;\r\nu32 val;\r\nif (!intel_pinctrl_should_save(pctrl, desc->number))\r\ncontinue;\r\nval = readl(intel_get_padcfg(pctrl, desc->number, PADCFG0));\r\npads[i].padcfg0 = val & ~PADCFG0_GPIORXSTATE;\r\nval = readl(intel_get_padcfg(pctrl, desc->number, PADCFG1));\r\npads[i].padcfg1 = val;\r\npadcfg = intel_get_padcfg(pctrl, desc->number, PADCFG2);\r\nif (padcfg)\r\npads[i].padcfg2 = readl(padcfg);\r\n}\r\ncommunities = pctrl->context.communities;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\nstruct intel_community *community = &pctrl->communities[i];\r\nvoid __iomem *base;\r\nunsigned gpp;\r\nbase = community->regs + community->ie_offset;\r\nfor (gpp = 0; gpp < community->ngpps; gpp++)\r\ncommunities[i].intmask[gpp] = readl(base + gpp * 4);\r\n}\r\nreturn 0;\r\n}\r\nstatic void intel_gpio_irq_init(struct intel_pinctrl *pctrl)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\nconst struct intel_community *community;\r\nvoid __iomem *base;\r\nunsigned gpp;\r\ncommunity = &pctrl->communities[i];\r\nbase = community->regs;\r\nfor (gpp = 0; gpp < community->ngpps; gpp++) {\r\nwritel(0, base + community->ie_offset + gpp * 4);\r\nwritel(0xffff, base + GPI_IS + gpp * 4);\r\n}\r\n}\r\n}\r\nint intel_pinctrl_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct intel_pinctrl *pctrl = platform_get_drvdata(pdev);\r\nconst struct intel_community_context *communities;\r\nconst struct intel_pad_context *pads;\r\nint i;\r\nintel_gpio_irq_init(pctrl);\r\npads = pctrl->context.pads;\r\nfor (i = 0; i < pctrl->soc->npins; i++) {\r\nconst struct pinctrl_pin_desc *desc = &pctrl->soc->pins[i];\r\nvoid __iomem *padcfg;\r\nu32 val;\r\nif (!intel_pinctrl_should_save(pctrl, desc->number))\r\ncontinue;\r\npadcfg = intel_get_padcfg(pctrl, desc->number, PADCFG0);\r\nval = readl(padcfg) & ~PADCFG0_GPIORXSTATE;\r\nif (val != pads[i].padcfg0) {\r\nwritel(pads[i].padcfg0, padcfg);\r\ndev_dbg(dev, "restored pin %u padcfg0 %#08x\n",\r\ndesc->number, readl(padcfg));\r\n}\r\npadcfg = intel_get_padcfg(pctrl, desc->number, PADCFG1);\r\nval = readl(padcfg);\r\nif (val != pads[i].padcfg1) {\r\nwritel(pads[i].padcfg1, padcfg);\r\ndev_dbg(dev, "restored pin %u padcfg1 %#08x\n",\r\ndesc->number, readl(padcfg));\r\n}\r\npadcfg = intel_get_padcfg(pctrl, desc->number, PADCFG2);\r\nif (padcfg) {\r\nval = readl(padcfg);\r\nif (val != pads[i].padcfg2) {\r\nwritel(pads[i].padcfg2, padcfg);\r\ndev_dbg(dev, "restored pin %u padcfg2 %#08x\n",\r\ndesc->number, readl(padcfg));\r\n}\r\n}\r\n}\r\ncommunities = pctrl->context.communities;\r\nfor (i = 0; i < pctrl->ncommunities; i++) {\r\nstruct intel_community *community = &pctrl->communities[i];\r\nvoid __iomem *base;\r\nunsigned gpp;\r\nbase = community->regs + community->ie_offset;\r\nfor (gpp = 0; gpp < community->ngpps; gpp++) {\r\nwritel(communities[i].intmask[gpp], base + gpp * 4);\r\ndev_dbg(dev, "restored mask %d/%u %#08x\n", i, gpp,\r\nreadl(base + gpp * 4));\r\n}\r\n}\r\nreturn 0;\r\n}
