static void meson_ir_set_mask(struct meson_ir *ir, unsigned int reg,\r\nu32 mask, u32 value)\r\n{\r\nu32 data;\r\ndata = readl(ir->reg + reg);\r\ndata &= ~mask;\r\ndata |= (value & mask);\r\nwritel(data, ir->reg + reg);\r\n}\r\nstatic irqreturn_t meson_ir_irq(int irqno, void *dev_id)\r\n{\r\nstruct meson_ir *ir = dev_id;\r\nu32 duration;\r\nDEFINE_IR_RAW_EVENT(rawir);\r\nspin_lock(&ir->lock);\r\nduration = readl(ir->reg + IR_DEC_REG1);\r\nduration = (duration & REG1_TIME_IV_MASK) >> REG1_TIME_IV_SHIFT;\r\nrawir.duration = US_TO_NS(duration * MESON_TRATE);\r\nrawir.pulse = !!(readl(ir->reg + IR_DEC_STATUS) & STATUS_IR_DEC_IN);\r\nir_raw_event_store_with_filter(ir->rc, &rawir);\r\nir_raw_event_handle(ir->rc);\r\nspin_unlock(&ir->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int meson_ir_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource *res;\r\nconst char *map_name;\r\nstruct meson_ir *ir;\r\nint ret;\r\nir = devm_kzalloc(dev, sizeof(struct meson_ir), GFP_KERNEL);\r\nif (!ir)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nir->reg = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ir->reg)) {\r\ndev_err(dev, "failed to map registers\n");\r\nreturn PTR_ERR(ir->reg);\r\n}\r\nir->irq = platform_get_irq(pdev, 0);\r\nif (ir->irq < 0) {\r\ndev_err(dev, "no irq resource\n");\r\nreturn ir->irq;\r\n}\r\nir->rc = rc_allocate_device(RC_DRIVER_IR_RAW);\r\nif (!ir->rc) {\r\ndev_err(dev, "failed to allocate rc device\n");\r\nreturn -ENOMEM;\r\n}\r\nir->rc->priv = ir;\r\nir->rc->input_name = DRIVER_NAME;\r\nir->rc->input_phys = DRIVER_NAME "/input0";\r\nir->rc->input_id.bustype = BUS_HOST;\r\nmap_name = of_get_property(node, "linux,rc-map-name", NULL);\r\nir->rc->map_name = map_name ? map_name : RC_MAP_EMPTY;\r\nir->rc->dev.parent = dev;\r\nir->rc->allowed_protocols = RC_BIT_ALL_IR_DECODER;\r\nir->rc->rx_resolution = US_TO_NS(MESON_TRATE);\r\nir->rc->timeout = MS_TO_NS(200);\r\nir->rc->driver_name = DRIVER_NAME;\r\nspin_lock_init(&ir->lock);\r\nplatform_set_drvdata(pdev, ir);\r\nret = rc_register_device(ir->rc);\r\nif (ret) {\r\ndev_err(dev, "failed to register rc device\n");\r\ngoto out_free;\r\n}\r\nret = devm_request_irq(dev, ir->irq, meson_ir_irq, 0, "ir-meson", ir);\r\nif (ret) {\r\ndev_err(dev, "failed to request irq\n");\r\ngoto out_unreg;\r\n}\r\nmeson_ir_set_mask(ir, IR_DEC_REG1, REG1_RESET, REG1_RESET);\r\nmeson_ir_set_mask(ir, IR_DEC_REG1, REG1_RESET, 0);\r\nif (of_device_is_compatible(node, "amlogic,meson6-ir"))\r\nmeson_ir_set_mask(ir, IR_DEC_REG1, REG1_MODE_MASK,\r\nDECODE_MODE_RAW << REG1_MODE_SHIFT);\r\nelse\r\nmeson_ir_set_mask(ir, IR_DEC_REG2, REG2_MODE_MASK,\r\nDECODE_MODE_RAW << REG2_MODE_SHIFT);\r\nmeson_ir_set_mask(ir, IR_DEC_REG0, REG0_RATE_MASK, MESON_TRATE - 1);\r\nmeson_ir_set_mask(ir, IR_DEC_REG1, REG1_IRQSEL_MASK,\r\nREG1_IRQSEL_RISE_FALL);\r\nmeson_ir_set_mask(ir, IR_DEC_REG1, REG1_ENABLE, REG1_ENABLE);\r\ndev_info(dev, "receiver initialized\n");\r\nreturn 0;\r\nout_unreg:\r\nrc_unregister_device(ir->rc);\r\nir->rc = NULL;\r\nout_free:\r\nrc_free_device(ir->rc);\r\nreturn ret;\r\n}\r\nstatic int meson_ir_remove(struct platform_device *pdev)\r\n{\r\nstruct meson_ir *ir = platform_get_drvdata(pdev);\r\nunsigned long flags;\r\nspin_lock_irqsave(&ir->lock, flags);\r\nmeson_ir_set_mask(ir, IR_DEC_REG1, REG1_ENABLE, 0);\r\nspin_unlock_irqrestore(&ir->lock, flags);\r\nrc_unregister_device(ir->rc);\r\nreturn 0;\r\n}
