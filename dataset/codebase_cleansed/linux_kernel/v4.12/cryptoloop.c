static int\r\ncryptoloop_init(struct loop_device *lo, const struct loop_info64 *info)\r\n{\r\nint err = -EINVAL;\r\nint cipher_len;\r\nint mode_len;\r\nchar cms[LO_NAME_SIZE];\r\nchar *cipher;\r\nchar *mode;\r\nchar *cmsp = cms;\r\nstruct crypto_skcipher *tfm;\r\nif (info->lo_offset % LOOP_IV_SECTOR_SIZE)\r\ngoto out;\r\nstrncpy(cms, info->lo_crypt_name, LO_NAME_SIZE);\r\ncms[LO_NAME_SIZE - 1] = 0;\r\ncipher = cmsp;\r\ncipher_len = strcspn(cmsp, "-");\r\nmode = cmsp + cipher_len;\r\nmode_len = 0;\r\nif (*mode) {\r\nmode++;\r\nmode_len = strcspn(mode, "-");\r\n}\r\nif (!mode_len) {\r\nmode = "cbc";\r\nmode_len = 3;\r\n}\r\nif (cipher_len + mode_len + 3 > LO_NAME_SIZE)\r\nreturn -EINVAL;\r\nmemmove(cms, mode, mode_len);\r\ncmsp = cms + mode_len;\r\n*cmsp++ = '(';\r\nmemcpy(cmsp, info->lo_crypt_name, cipher_len);\r\ncmsp += cipher_len;\r\n*cmsp++ = ')';\r\n*cmsp = 0;\r\ntfm = crypto_alloc_skcipher(cms, 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nerr = crypto_skcipher_setkey(tfm, info->lo_encrypt_key,\r\ninfo->lo_encrypt_key_size);\r\nif (err != 0)\r\ngoto out_free_tfm;\r\nlo->key_data = tfm;\r\nreturn 0;\r\nout_free_tfm:\r\ncrypto_free_skcipher(tfm);\r\nout:\r\nreturn err;\r\n}\r\nstatic int\r\ncryptoloop_transfer(struct loop_device *lo, int cmd,\r\nstruct page *raw_page, unsigned raw_off,\r\nstruct page *loop_page, unsigned loop_off,\r\nint size, sector_t IV)\r\n{\r\nstruct crypto_skcipher *tfm = lo->key_data;\r\nSKCIPHER_REQUEST_ON_STACK(req, tfm);\r\nstruct scatterlist sg_out;\r\nstruct scatterlist sg_in;\r\nencdec_cbc_t encdecfunc;\r\nstruct page *in_page, *out_page;\r\nunsigned in_offs, out_offs;\r\nint err;\r\nskcipher_request_set_tfm(req, tfm);\r\nskcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,\r\nNULL, NULL);\r\nsg_init_table(&sg_out, 1);\r\nsg_init_table(&sg_in, 1);\r\nif (cmd == READ) {\r\nin_page = raw_page;\r\nin_offs = raw_off;\r\nout_page = loop_page;\r\nout_offs = loop_off;\r\nencdecfunc = crypto_skcipher_decrypt;\r\n} else {\r\nin_page = loop_page;\r\nin_offs = loop_off;\r\nout_page = raw_page;\r\nout_offs = raw_off;\r\nencdecfunc = crypto_skcipher_encrypt;\r\n}\r\nwhile (size > 0) {\r\nconst int sz = min(size, LOOP_IV_SECTOR_SIZE);\r\nu32 iv[4] = { 0, };\r\niv[0] = cpu_to_le32(IV & 0xffffffff);\r\nsg_set_page(&sg_in, in_page, sz, in_offs);\r\nsg_set_page(&sg_out, out_page, sz, out_offs);\r\nskcipher_request_set_crypt(req, &sg_in, &sg_out, sz, iv);\r\nerr = encdecfunc(req);\r\nif (err)\r\ngoto out;\r\nIV++;\r\nsize -= sz;\r\nin_offs += sz;\r\nout_offs += sz;\r\n}\r\nerr = 0;\r\nout:\r\nskcipher_request_zero(req);\r\nreturn err;\r\n}\r\nstatic int\r\ncryptoloop_ioctl(struct loop_device *lo, int cmd, unsigned long arg)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ncryptoloop_release(struct loop_device *lo)\r\n{\r\nstruct crypto_skcipher *tfm = lo->key_data;\r\nif (tfm != NULL) {\r\ncrypto_free_skcipher(tfm);\r\nlo->key_data = NULL;\r\nreturn 0;\r\n}\r\nprintk(KERN_ERR "cryptoloop_release(): tfm == NULL?\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int __init\r\ninit_cryptoloop(void)\r\n{\r\nint rc = loop_register_transfer(&cryptoloop_funcs);\r\nif (rc)\r\nprintk(KERN_ERR "cryptoloop: loop_register_transfer failed\n");\r\nreturn rc;\r\n}\r\nstatic void __exit\r\ncleanup_cryptoloop(void)\r\n{\r\nif (loop_unregister_transfer(LO_CRYPT_CRYPTOAPI))\r\nprintk(KERN_ERR\r\n"cryptoloop: loop_unregister_transfer failed\n");\r\n}
