static unsigned int pv88080_buck_get_mode(struct regulator_dev *rdev)\r\n{\r\nstruct pv88080_regulator *info = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret, mode = 0;\r\nret = regmap_read(rdev->regmap, info->mode_reg, &data);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (data & PV88080_BUCK1_MODE_MASK) {\r\ncase PV88080_BUCK_MODE_SYNC:\r\nmode = REGULATOR_MODE_FAST;\r\nbreak;\r\ncase PV88080_BUCK_MODE_AUTO:\r\nmode = REGULATOR_MODE_NORMAL;\r\nbreak;\r\ncase PV88080_BUCK_MODE_SLEEP:\r\nmode = REGULATOR_MODE_STANDBY;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn mode;\r\n}\r\nstatic int pv88080_buck_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nstruct pv88080_regulator *info = rdev_get_drvdata(rdev);\r\nint val = 0;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_FAST:\r\nval = PV88080_BUCK_MODE_SYNC;\r\nbreak;\r\ncase REGULATOR_MODE_NORMAL:\r\nval = PV88080_BUCK_MODE_AUTO;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nval = PV88080_BUCK_MODE_SLEEP;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, info->mode_reg,\r\nPV88080_BUCK1_MODE_MASK, val);\r\n}\r\nstatic int pv88080_set_current_limit(struct regulator_dev *rdev, int min,\r\nint max)\r\n{\r\nstruct pv88080_regulator *info = rdev_get_drvdata(rdev);\r\nint i;\r\nfor (i = info->n_current_limits; i >= 0; i--) {\r\nif (min <= info->current_limits[i]\r\n&& max >= info->current_limits[i]) {\r\nreturn regmap_update_bits(rdev->regmap,\r\ninfo->limit_reg,\r\ninfo->limit_mask,\r\ni << PV88080_BUCK1_ILIM_SHIFT);\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int pv88080_get_current_limit(struct regulator_dev *rdev)\r\n{\r\nstruct pv88080_regulator *info = rdev_get_drvdata(rdev);\r\nunsigned int data;\r\nint ret;\r\nret = regmap_read(rdev->regmap, info->limit_reg, &data);\r\nif (ret < 0)\r\nreturn ret;\r\ndata = (data & info->limit_mask) >> PV88080_BUCK1_ILIM_SHIFT;\r\nreturn info->current_limits[data];\r\n}\r\nstatic irqreturn_t pv88080_irq_handler(int irq, void *data)\r\n{\r\nstruct pv88080 *chip = data;\r\nint i, reg_val, err, ret = IRQ_NONE;\r\nerr = regmap_read(chip->regmap, PV88080_REG_EVENT_A, &reg_val);\r\nif (err < 0)\r\ngoto error_i2c;\r\nif (reg_val & PV88080_E_VDD_FLT) {\r\nfor (i = 0; i < PV88080_MAX_REGULATORS; i++) {\r\nif (chip->rdev[i] != NULL) {\r\nregulator_notifier_call_chain(chip->rdev[i],\r\nREGULATOR_EVENT_UNDER_VOLTAGE,\r\nNULL);\r\n}\r\n}\r\nerr = regmap_write(chip->regmap, PV88080_REG_EVENT_A,\r\nPV88080_E_VDD_FLT);\r\nif (err < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nif (reg_val & PV88080_E_OVER_TEMP) {\r\nfor (i = 0; i < PV88080_MAX_REGULATORS; i++) {\r\nif (chip->rdev[i] != NULL) {\r\nregulator_notifier_call_chain(chip->rdev[i],\r\nREGULATOR_EVENT_OVER_TEMP,\r\nNULL);\r\n}\r\n}\r\nerr = regmap_write(chip->regmap, PV88080_REG_EVENT_A,\r\nPV88080_E_OVER_TEMP);\r\nif (err < 0)\r\ngoto error_i2c;\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\nerror_i2c:\r\ndev_err(chip->dev, "I2C error : %d\n", err);\r\nreturn IRQ_NONE;\r\n}\r\nstatic int pv88080_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct regulator_init_data *init_data = dev_get_platdata(&i2c->dev);\r\nstruct pv88080 *chip;\r\nconst struct pv88080_compatible_regmap *regmap_config;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config = { };\r\nint i, error, ret;\r\nunsigned int conf2, conf5;\r\nchip = devm_kzalloc(&i2c->dev, sizeof(struct pv88080), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nchip->dev = &i2c->dev;\r\nchip->regmap = devm_regmap_init_i2c(i2c, &pv88080_regmap_config);\r\nif (IS_ERR(chip->regmap)) {\r\nerror = PTR_ERR(chip->regmap);\r\ndev_err(chip->dev, "Failed to allocate register map: %d\n",\r\nerror);\r\nreturn error;\r\n}\r\nif (i2c->dev.of_node) {\r\nmatch = of_match_node(pv88080_dt_ids, i2c->dev.of_node);\r\nif (!match) {\r\ndev_err(chip->dev, "Failed to get of_match_node\n");\r\nreturn -EINVAL;\r\n}\r\nchip->type = (unsigned long)match->data;\r\n} else {\r\nchip->type = id->driver_data;\r\n}\r\ni2c_set_clientdata(i2c, chip);\r\nif (i2c->irq != 0) {\r\nret = regmap_write(chip->regmap, PV88080_REG_MASK_A, 0xFF);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to mask A reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(chip->regmap, PV88080_REG_MASK_B, 0xFF);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to mask B reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(chip->regmap, PV88080_REG_MASK_C, 0xFF);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to mask C reg: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\r\npv88080_irq_handler,\r\nIRQF_TRIGGER_LOW|IRQF_ONESHOT,\r\n"pv88080", chip);\r\nif (ret != 0) {\r\ndev_err(chip->dev, "Failed to request IRQ: %d\n",\r\ni2c->irq);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(chip->regmap, PV88080_REG_MASK_A,\r\nPV88080_M_VDD_FLT | PV88080_M_OVER_TEMP, 0);\r\nif (ret < 0) {\r\ndev_err(chip->dev,\r\n"Failed to update mask reg: %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\ndev_warn(chip->dev, "No IRQ configured\n");\r\n}\r\nswitch (chip->type) {\r\ncase TYPE_PV88080_AA:\r\nchip->regmap_config = &pv88080_aa_regs;\r\nbreak;\r\ncase TYPE_PV88080_BA:\r\nchip->regmap_config = &pv88080_ba_regs;\r\nbreak;\r\n}\r\nregmap_config = chip->regmap_config;\r\nconfig.dev = chip->dev;\r\nconfig.regmap = chip->regmap;\r\nfor (i = 0; i < PV88080_MAX_REGULATORS-1; i++) {\r\nif (init_data)\r\nconfig.init_data = &init_data[i];\r\npv88080_regulator_info[i].limit_reg\r\n= regmap_config->buck_regmap[i].buck_limit_reg;\r\npv88080_regulator_info[i].limit_mask\r\n= regmap_config->buck_regmap[i].buck_limit_mask;\r\npv88080_regulator_info[i].mode_reg\r\n= regmap_config->buck_regmap[i].buck_mode_reg;\r\npv88080_regulator_info[i].conf2\r\n= regmap_config->buck_regmap[i].buck_vdac_range_reg;\r\npv88080_regulator_info[i].conf5\r\n= regmap_config->buck_regmap[i].buck_vrange_gain_reg;\r\npv88080_regulator_info[i].desc.enable_reg\r\n= regmap_config->buck_regmap[i].buck_enable_reg;\r\npv88080_regulator_info[i].desc.enable_mask\r\n= regmap_config->buck_regmap[i].buck_enable_mask;\r\npv88080_regulator_info[i].desc.vsel_reg\r\n= regmap_config->buck_regmap[i].buck_vsel_reg;\r\npv88080_regulator_info[i].desc.vsel_mask\r\n= regmap_config->buck_regmap[i].buck_vsel_mask;\r\nret = regmap_read(chip->regmap,\r\npv88080_regulator_info[i].conf2, &conf2);\r\nif (ret < 0)\r\nreturn ret;\r\nconf2 = ((conf2 >> PV88080_BUCK_VDAC_RANGE_SHIFT) &\r\nPV88080_BUCK_VDAC_RANGE_MASK);\r\nret = regmap_read(chip->regmap,\r\npv88080_regulator_info[i].conf5, &conf5);\r\nif (ret < 0)\r\nreturn ret;\r\nconf5 = ((conf5 >> PV88080_BUCK_VRANGE_GAIN_SHIFT) &\r\nPV88080_BUCK_VRANGE_GAIN_MASK);\r\npv88080_regulator_info[i].desc.min_uV =\r\npv88080_buck_vol[conf2].min_uV * (conf5+1);\r\npv88080_regulator_info[i].desc.uV_step =\r\npv88080_buck_vol[conf2].uV_step * (conf5+1);\r\npv88080_regulator_info[i].desc.n_voltages =\r\n((pv88080_buck_vol[conf2].max_uV * (conf5+1))\r\n- (pv88080_regulator_info[i].desc.min_uV))\r\n/(pv88080_regulator_info[i].desc.uV_step) + 1;\r\nconfig.driver_data = (void *)&pv88080_regulator_info[i];\r\nchip->rdev[i] = devm_regulator_register(chip->dev,\r\n&pv88080_regulator_info[i].desc, &config);\r\nif (IS_ERR(chip->rdev[i])) {\r\ndev_err(chip->dev,\r\n"Failed to register PV88080 regulator\n");\r\nreturn PTR_ERR(chip->rdev[i]);\r\n}\r\n}\r\npv88080_regulator_info[PV88080_ID_HVBUCK].desc.enable_reg\r\n= regmap_config->hvbuck_enable_reg;\r\npv88080_regulator_info[PV88080_ID_HVBUCK].desc.enable_mask\r\n= regmap_config->hvbuck_enable_mask;\r\npv88080_regulator_info[PV88080_ID_HVBUCK].desc.vsel_reg\r\n= regmap_config->hvbuck_vsel_reg;\r\npv88080_regulator_info[PV88080_ID_HVBUCK].desc.vsel_mask\r\n= regmap_config->hvbuck_vsel_mask;\r\nif (init_data)\r\nconfig.init_data = &init_data[PV88080_ID_HVBUCK];\r\nconfig.driver_data = (void *)&pv88080_regulator_info[PV88080_ID_HVBUCK];\r\nchip->rdev[PV88080_ID_HVBUCK] = devm_regulator_register(chip->dev,\r\n&pv88080_regulator_info[PV88080_ID_HVBUCK].desc, &config);\r\nif (IS_ERR(chip->rdev[PV88080_ID_HVBUCK])) {\r\ndev_err(chip->dev, "Failed to register PV88080 regulator\n");\r\nreturn PTR_ERR(chip->rdev[PV88080_ID_HVBUCK]);\r\n}\r\nreturn 0;\r\n}
