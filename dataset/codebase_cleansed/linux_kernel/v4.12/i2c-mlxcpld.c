static void mlxcpld_i2c_lpc_write_buf(u8 *data, u8 len, u32 addr)\r\n{\r\nint i;\r\nfor (i = 0; i < len - len % 4; i += 4)\r\noutl(*(u32 *)(data + i), addr + i);\r\nfor (; i < len; ++i)\r\noutb(*(data + i), addr + i);\r\n}\r\nstatic void mlxcpld_i2c_lpc_read_buf(u8 *data, u8 len, u32 addr)\r\n{\r\nint i;\r\nfor (i = 0; i < len - len % 4; i += 4)\r\n*(u32 *)(data + i) = inl(addr + i);\r\nfor (; i < len; ++i)\r\n*(data + i) = inb(addr + i);\r\n}\r\nstatic void mlxcpld_i2c_read_comm(struct mlxcpld_i2c_priv *priv, u8 offs,\r\nu8 *data, u8 datalen)\r\n{\r\nu32 addr = priv->base_addr + offs;\r\nswitch (datalen) {\r\ncase 1:\r\n*(data) = inb(addr);\r\nbreak;\r\ncase 2:\r\n*((u16 *)data) = inw(addr);\r\nbreak;\r\ncase 3:\r\n*((u16 *)data) = inw(addr);\r\n*(data + 2) = inb(addr + 2);\r\nbreak;\r\ncase 4:\r\n*((u32 *)data) = inl(addr);\r\nbreak;\r\ndefault:\r\nmlxcpld_i2c_lpc_read_buf(data, datalen, addr);\r\nbreak;\r\n}\r\n}\r\nstatic void mlxcpld_i2c_write_comm(struct mlxcpld_i2c_priv *priv, u8 offs,\r\nu8 *data, u8 datalen)\r\n{\r\nu32 addr = priv->base_addr + offs;\r\nswitch (datalen) {\r\ncase 1:\r\noutb(*(data), addr);\r\nbreak;\r\ncase 2:\r\noutw(*((u16 *)data), addr);\r\nbreak;\r\ncase 3:\r\noutw(*((u16 *)data), addr);\r\noutb(*(data + 2), addr + 2);\r\nbreak;\r\ncase 4:\r\noutl(*((u32 *)data), addr);\r\nbreak;\r\ndefault:\r\nmlxcpld_i2c_lpc_write_buf(data, datalen, addr);\r\nbreak;\r\n}\r\n}\r\nstatic int mlxcpld_i2c_check_msg_params(struct mlxcpld_i2c_priv *priv,\r\nstruct i2c_msg *msgs, int num)\r\n{\r\nint i;\r\nif (!num) {\r\ndev_err(priv->dev, "Incorrect 0 num of messages\n");\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(msgs[0].addr > 0x7f)) {\r\ndev_err(priv->dev, "Invalid address 0x%03x\n",\r\nmsgs[0].addr);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num; ++i) {\r\nif (unlikely(!msgs[i].buf)) {\r\ndev_err(priv->dev, "Invalid buf in msg[%d]\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\nif (unlikely(msgs[0].addr != msgs[i].addr)) {\r\ndev_err(priv->dev, "Invalid addr in msg[%d]\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxcpld_i2c_check_status(struct mlxcpld_i2c_priv *priv, int *status)\r\n{\r\nu8 val;\r\nmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_STATUS_REG, &val, 1);\r\nif (val & MLXCPLD_LPCI2C_TRANS_END) {\r\nif (val & MLXCPLD_LPCI2C_STATUS_NACK)\r\n*status = MLXCPLD_LPCI2C_NACK_IND;\r\nelse\r\n*status = MLXCPLD_LPCI2C_ACK_IND;\r\nreturn 0;\r\n}\r\n*status = MLXCPLD_LPCI2C_NO_IND;\r\nreturn -EIO;\r\n}\r\nstatic void mlxcpld_i2c_set_transf_data(struct mlxcpld_i2c_priv *priv,\r\nstruct i2c_msg *msgs, int num,\r\nu8 comm_len)\r\n{\r\npriv->xfer.msg = msgs;\r\npriv->xfer.msg_num = num;\r\npriv->xfer.cmd = msgs[num - 1].flags & I2C_M_RD;\r\nif (priv->xfer.cmd == I2C_M_RD && comm_len != msgs[0].len) {\r\npriv->xfer.addr_width = msgs[0].len;\r\npriv->xfer.data_len = comm_len - priv->xfer.addr_width;\r\n} else {\r\npriv->xfer.addr_width = 0;\r\npriv->xfer.data_len = comm_len;\r\n}\r\n}\r\nstatic void mlxcpld_i2c_reset(struct mlxcpld_i2c_priv *priv)\r\n{\r\nu8 val;\r\nmutex_lock(&priv->lock);\r\nmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_CTRL_REG, &val, 1);\r\nval &= ~MLXCPLD_LPCI2C_RST_SEL_MASK;\r\nmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_CTRL_REG, &val, 1);\r\nmutex_unlock(&priv->lock);\r\n}\r\nstatic int mlxcpld_i2c_check_busy(struct mlxcpld_i2c_priv *priv)\r\n{\r\nu8 val;\r\nmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_STATUS_REG, &val, 1);\r\nif (val & MLXCPLD_LPCI2C_TRANS_END)\r\nreturn 0;\r\nreturn -EIO;\r\n}\r\nstatic int mlxcpld_i2c_wait_for_free(struct mlxcpld_i2c_priv *priv)\r\n{\r\nint timeout = 0;\r\ndo {\r\nif (!mlxcpld_i2c_check_busy(priv))\r\nbreak;\r\nusleep_range(MLXCPLD_I2C_POLL_TIME / 2, MLXCPLD_I2C_POLL_TIME);\r\ntimeout += MLXCPLD_I2C_POLL_TIME;\r\n} while (timeout <= MLXCPLD_I2C_XFER_TO);\r\nif (timeout > MLXCPLD_I2C_XFER_TO)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int mlxcpld_i2c_wait_for_tc(struct mlxcpld_i2c_priv *priv)\r\n{\r\nint status, i, timeout = 0;\r\nu8 datalen;\r\ndo {\r\nusleep_range(MLXCPLD_I2C_POLL_TIME / 2, MLXCPLD_I2C_POLL_TIME);\r\nif (!mlxcpld_i2c_check_status(priv, &status))\r\nbreak;\r\ntimeout += MLXCPLD_I2C_POLL_TIME;\r\n} while (status == 0 && timeout < MLXCPLD_I2C_XFER_TO);\r\nswitch (status) {\r\ncase MLXCPLD_LPCI2C_NO_IND:\r\nreturn -ETIMEDOUT;\r\ncase MLXCPLD_LPCI2C_ACK_IND:\r\nif (priv->xfer.cmd != I2C_M_RD)\r\nreturn (priv->xfer.addr_width + priv->xfer.data_len);\r\nif (priv->xfer.msg_num == 1)\r\ni = 0;\r\nelse\r\ni = 1;\r\nif (!priv->xfer.msg[i].buf)\r\nreturn -EINVAL;\r\ndatalen = priv->xfer.data_len;\r\nmlxcpld_i2c_read_comm(priv, MLXCPLD_LPCI2C_DATA_REG,\r\npriv->xfer.msg[i].buf, datalen);\r\nreturn datalen;\r\ncase MLXCPLD_LPCI2C_NACK_IND:\r\nreturn -ENXIO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic void mlxcpld_i2c_xfer_msg(struct mlxcpld_i2c_priv *priv)\r\n{\r\nint i, len = 0;\r\nu8 cmd;\r\nmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_NUM_DAT_REG,\r\n&priv->xfer.data_len, 1);\r\nmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_NUM_ADDR_REG,\r\n&priv->xfer.addr_width, 1);\r\nfor (i = 0; i < priv->xfer.msg_num; i++) {\r\nif ((priv->xfer.msg[i].flags & I2C_M_RD) != I2C_M_RD) {\r\nmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_DATA_REG +\r\nlen, priv->xfer.msg[i].buf,\r\npriv->xfer.msg[i].len);\r\nlen += priv->xfer.msg[i].len;\r\n}\r\n}\r\ncmd = (priv->xfer.msg[0].addr << 1) | priv->xfer.cmd;\r\nmlxcpld_i2c_write_comm(priv, MLXCPLD_LPCI2C_CMD_REG, &cmd, 1);\r\n}\r\nstatic int mlxcpld_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs,\r\nint num)\r\n{\r\nstruct mlxcpld_i2c_priv *priv = i2c_get_adapdata(adap);\r\nu8 comm_len = 0;\r\nint i, err;\r\nerr = mlxcpld_i2c_check_msg_params(priv, msgs, num);\r\nif (err) {\r\ndev_err(priv->dev, "Incorrect message\n");\r\nreturn err;\r\n}\r\nfor (i = 0; i < num; ++i)\r\ncomm_len += msgs[i].len;\r\nif (mlxcpld_i2c_wait_for_free(priv)) {\r\ndev_err(priv->dev, "LPCI2C bridge is busy\n");\r\nmlxcpld_i2c_reset(priv);\r\nif (mlxcpld_i2c_check_busy(priv)) {\r\ndev_err(priv->dev, "LPCI2C bridge is busy after reset\n");\r\nreturn -EIO;\r\n}\r\n}\r\nmlxcpld_i2c_set_transf_data(priv, msgs, num, comm_len);\r\nmutex_lock(&priv->lock);\r\nmlxcpld_i2c_xfer_msg(priv);\r\nerr = mlxcpld_i2c_wait_for_tc(priv);\r\nmutex_unlock(&priv->lock);\r\nreturn err < 0 ? err : num;\r\n}\r\nstatic u32 mlxcpld_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL | I2C_FUNC_SMBUS_BLOCK_DATA;\r\n}\r\nstatic int mlxcpld_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct mlxcpld_i2c_priv *priv;\r\nint err;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmutex_init(&priv->lock);\r\nplatform_set_drvdata(pdev, priv);\r\npriv->dev = &pdev->dev;\r\nmlxcpld_i2c_adapter.timeout = usecs_to_jiffies(MLXCPLD_I2C_XFER_TO);\r\npriv->adap = mlxcpld_i2c_adapter;\r\npriv->adap.dev.parent = &pdev->dev;\r\npriv->base_addr = MLXPLAT_CPLD_LPC_I2C_BASE_ADDR;\r\ni2c_set_adapdata(&priv->adap, priv);\r\nerr = i2c_add_numbered_adapter(&priv->adap);\r\nif (err)\r\nmutex_destroy(&priv->lock);\r\nreturn err;\r\n}\r\nstatic int mlxcpld_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct mlxcpld_i2c_priv *priv = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&priv->adap);\r\nmutex_destroy(&priv->lock);\r\nreturn 0;\r\n}
