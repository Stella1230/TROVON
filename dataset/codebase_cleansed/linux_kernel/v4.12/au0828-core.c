u32 au0828_readreg(struct au0828_dev *dev, u16 reg)\r\n{\r\nu8 result = 0;\r\nrecv_control_msg(dev, CMD_REQUEST_IN, 0, reg, &result, 1);\r\ndprintk(8, "%s(0x%04x) = 0x%02x\n", __func__, reg, result);\r\nreturn result;\r\n}\r\nu32 au0828_writereg(struct au0828_dev *dev, u16 reg, u32 val)\r\n{\r\ndprintk(8, "%s(0x%04x, 0x%02x)\n", __func__, reg, val);\r\nreturn send_control_msg(dev, CMD_REQUEST_OUT, val, reg);\r\n}\r\nstatic int send_control_msg(struct au0828_dev *dev, u16 request, u32 value,\r\nu16 index)\r\n{\r\nint status = -ENODEV;\r\nif (dev->usbdev) {\r\nstatus = usb_control_msg(dev->usbdev,\r\nusb_sndctrlpipe(dev->usbdev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR |\r\nUSB_RECIP_DEVICE,\r\nvalue, index, NULL, 0, 1000);\r\nstatus = min(status, 0);\r\nif (status < 0) {\r\npr_err("%s() Failed sending control message, error %d.\n",\r\n__func__, status);\r\n}\r\n}\r\nreturn status;\r\n}\r\nstatic int recv_control_msg(struct au0828_dev *dev, u16 request, u32 value,\r\nu16 index, unsigned char *cp, u16 size)\r\n{\r\nint status = -ENODEV;\r\nmutex_lock(&dev->mutex);\r\nif (dev->usbdev) {\r\nstatus = usb_control_msg(dev->usbdev,\r\nusb_rcvctrlpipe(dev->usbdev, 0),\r\nrequest,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index,\r\ndev->ctrlmsg, size, 1000);\r\nstatus = min(status, 0);\r\nif (status < 0) {\r\npr_err("%s() Failed receiving control message, error %d.\n",\r\n__func__, status);\r\n}\r\nmemcpy(cp, dev->ctrlmsg, size);\r\n}\r\nmutex_unlock(&dev->mutex);\r\nreturn status;\r\n}\r\nstatic void au0828_unregister_media_device(struct au0828_dev *dev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct media_device *mdev = dev->media_dev;\r\nstruct media_entity_notify *notify, *nextp;\r\nif (!mdev || !media_devnode_is_registered(mdev->devnode))\r\nreturn;\r\nlist_for_each_entry_safe(notify, nextp, &mdev->entity_notify, list) {\r\nif (notify->notify != au0828_media_graph_notify)\r\ncontinue;\r\nmedia_device_unregister_entity_notify(mdev, notify);\r\n}\r\nmutex_lock(&mdev->graph_mutex);\r\ndev->media_dev->source_priv = NULL;\r\ndev->media_dev->enable_source = NULL;\r\ndev->media_dev->disable_source = NULL;\r\nmutex_unlock(&mdev->graph_mutex);\r\nmedia_device_unregister(dev->media_dev);\r\nmedia_device_cleanup(dev->media_dev);\r\nkfree(dev->media_dev);\r\ndev->media_dev = NULL;\r\n#endif\r\n}\r\nvoid au0828_usb_release(struct au0828_dev *dev)\r\n{\r\nau0828_unregister_media_device(dev);\r\nau0828_i2c_unregister(dev);\r\nkfree(dev);\r\n}\r\nstatic void au0828_usb_disconnect(struct usb_interface *interface)\r\n{\r\nstruct au0828_dev *dev = usb_get_intfdata(interface);\r\ndprintk(1, "%s()\n", __func__);\r\nset_bit(DEV_DISCONNECTED, &dev->dev_state);\r\nau0828_rc_unregister(dev);\r\nau0828_dvb_unregister(dev);\r\nusb_set_intfdata(interface, NULL);\r\nmutex_lock(&dev->mutex);\r\ndev->usbdev = NULL;\r\nmutex_unlock(&dev->mutex);\r\nif (au0828_analog_unregister(dev)) {\r\nreturn;\r\n}\r\nau0828_usb_release(dev);\r\n}\r\nstatic int au0828_media_device_init(struct au0828_dev *dev,\r\nstruct usb_device *udev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nstruct media_device *mdev;\r\nmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\r\nif (!mdev)\r\nreturn -ENOMEM;\r\nif (!mdev->dev)\r\nmedia_device_usb_init(mdev, udev, udev->product);\r\ndev->media_dev = mdev;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void au0828_media_graph_notify(struct media_entity *new,\r\nvoid *notify_data)\r\n{\r\nstruct au0828_dev *dev = (struct au0828_dev *) notify_data;\r\nint ret;\r\nstruct media_entity *entity, *mixer = NULL, *decoder = NULL;\r\nif (!new) {\r\nmedia_device_for_each_entity(entity, dev->media_dev) {\r\nif (entity->function == MEDIA_ENT_F_AUDIO_MIXER)\r\nmixer = entity;\r\nelse if (entity->function == MEDIA_ENT_F_ATV_DECODER)\r\ndecoder = entity;\r\n}\r\ngoto create_link;\r\n}\r\nswitch (new->function) {\r\ncase MEDIA_ENT_F_AUDIO_MIXER:\r\nmixer = new;\r\nif (dev->decoder)\r\ndecoder = dev->decoder;\r\nbreak;\r\ncase MEDIA_ENT_F_ATV_DECODER:\r\nmedia_device_for_each_entity(entity, dev->media_dev) {\r\nif (entity->function == MEDIA_ENT_F_AUDIO_MIXER)\r\nmixer = entity;\r\n}\r\ndecoder = new;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncreate_link:\r\nif (decoder && mixer) {\r\nret = media_create_pad_link(decoder,\r\nDEMOD_PAD_AUDIO_OUT,\r\nmixer, 0,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\ndev_err(&dev->usbdev->dev,\r\n"Mixer Pad Link Create Error: %d\n", ret);\r\n}\r\n}\r\nstatic int au0828_enable_source(struct media_entity *entity,\r\nstruct media_pipeline *pipe)\r\n{\r\nstruct media_entity *source, *find_source;\r\nstruct media_entity *sink;\r\nstruct media_link *link, *found_link = NULL;\r\nint ret = 0;\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nstruct au0828_dev *dev;\r\nif (!mdev)\r\nreturn -ENODEV;\r\ndev = mdev->source_priv;\r\nif (entity->function == MEDIA_ENT_F_DTV_DEMOD) {\r\nsink = entity;\r\nfind_source = dev->tuner;\r\n} else {\r\nif (!dev->decoder) {\r\nret = -ENODEV;\r\ngoto end;\r\n}\r\nsink = dev->decoder;\r\nif (dev->input_type == AU0828_VMUX_TELEVISION)\r\nfind_source = dev->tuner;\r\nelse if (dev->input_type == AU0828_VMUX_SVIDEO ||\r\ndev->input_type == AU0828_VMUX_COMPOSITE)\r\nfind_source = &dev->input_ent[dev->input_type];\r\nelse {\r\nret = 0;\r\ngoto end;\r\n}\r\n}\r\nif (dev->active_link) {\r\nif (dev->active_link->sink->entity == sink &&\r\ndev->active_link->source->entity == find_source) {\r\nif (dev->active_link_owner != entity &&\r\ndev->active_link_owner->function ==\r\nMEDIA_ENT_F_AUDIO_CAPTURE) {\r\npr_debug("ALSA has the tuner\n");\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = 0;\r\ngoto end;\r\n} else {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\n}\r\nlist_for_each_entry(link, &sink->links, list) {\r\nif (link->sink->entity == sink &&\r\nlink->source->entity == find_source) {\r\nfound_link = link;\r\nbreak;\r\n}\r\n}\r\nif (!found_link) {\r\nret = -ENODEV;\r\ngoto end;\r\n}\r\nsource = found_link->source->entity;\r\nret = __media_entity_setup_link(found_link, MEDIA_LNK_FL_ENABLED);\r\nif (ret) {\r\npr_err("Activate tuner link %s->%s. Error %d\n",\r\nsource->name, sink->name, ret);\r\ngoto end;\r\n}\r\nret = __media_pipeline_start(entity, pipe);\r\nif (ret) {\r\npr_err("Start Pipeline: %s->%s Error %d\n",\r\nsource->name, entity->name, ret);\r\nret = __media_entity_setup_link(found_link, 0);\r\npr_err("Deactivate link Error %d\n", ret);\r\ngoto end;\r\n}\r\ndev->active_link = found_link;\r\ndev->active_link_owner = entity;\r\ndev->active_source = source;\r\ndev->active_sink = sink;\r\npr_debug("Enabled Source: %s->%s->%s Ret %d\n",\r\ndev->active_source->name, dev->active_sink->name,\r\ndev->active_link_owner->name, ret);\r\nend:\r\npr_debug("au0828_enable_source() end %s %d %d\n",\r\nentity->name, entity->function, ret);\r\nreturn ret;\r\n}\r\nstatic void au0828_disable_source(struct media_entity *entity)\r\n{\r\nint ret = 0;\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nstruct au0828_dev *dev;\r\nif (!mdev)\r\nreturn;\r\ndev = mdev->source_priv;\r\nif (!dev->active_link)\r\nreturn;\r\nif (dev->active_link->sink->entity == dev->active_sink &&\r\ndev->active_link->source->entity == dev->active_source) {\r\nif (dev->active_link_owner != entity)\r\nreturn;\r\n__media_pipeline_stop(entity);\r\nret = __media_entity_setup_link(dev->active_link, 0);\r\nif (ret)\r\npr_err("Deactivate link Error %d\n", ret);\r\npr_debug("Disabled Source: %s->%s->%s Ret %d\n",\r\ndev->active_source->name, dev->active_sink->name,\r\ndev->active_link_owner->name, ret);\r\ndev->active_link = NULL;\r\ndev->active_link_owner = NULL;\r\ndev->active_source = NULL;\r\ndev->active_sink = NULL;\r\n}\r\n}\r\nstatic int au0828_media_device_register(struct au0828_dev *dev,\r\nstruct usb_device *udev)\r\n{\r\n#ifdef CONFIG_MEDIA_CONTROLLER\r\nint ret;\r\nstruct media_entity *entity, *demod = NULL;\r\nstruct media_link *link;\r\nif (!dev->media_dev)\r\nreturn 0;\r\nif (!media_devnode_is_registered(dev->media_dev->devnode)) {\r\nret = media_device_register(dev->media_dev);\r\nif (ret) {\r\ndev_err(&udev->dev,\r\n"Media Device Register Error: %d\n", ret);\r\nreturn ret;\r\n}\r\n} else {\r\nau0828_media_graph_notify(NULL, (void *) dev);\r\n}\r\nmedia_device_for_each_entity(entity, dev->media_dev) {\r\nswitch (entity->function) {\r\ncase MEDIA_ENT_F_TUNER:\r\ndev->tuner = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_ATV_DECODER:\r\ndev->decoder = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_DTV_DEMOD:\r\ndemod = entity;\r\nbreak;\r\n}\r\n}\r\nif (dev->tuner) {\r\nlist_for_each_entry(link, &dev->tuner->links, list) {\r\nif (demod && link->sink->entity == demod)\r\nmedia_entity_setup_link(link, 0);\r\nif (dev->decoder && link->sink->entity == dev->decoder)\r\nmedia_entity_setup_link(link, 0);\r\n}\r\n}\r\ndev->entity_notify.notify_data = (void *) dev;\r\ndev->entity_notify.notify = (void *) au0828_media_graph_notify;\r\nret = media_device_register_entity_notify(dev->media_dev,\r\n&dev->entity_notify);\r\nif (ret) {\r\ndev_err(&udev->dev,\r\n"Media Device register entity_notify Error: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nmutex_lock(&dev->media_dev->graph_mutex);\r\ndev->media_dev->source_priv = (void *) dev;\r\ndev->media_dev->enable_source = au0828_enable_source;\r\ndev->media_dev->disable_source = au0828_disable_source;\r\nmutex_unlock(&dev->media_dev->graph_mutex);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int au0828_usb_probe(struct usb_interface *interface,\r\nconst struct usb_device_id *id)\r\n{\r\nint ifnum;\r\nint retval = 0;\r\nstruct au0828_dev *dev;\r\nstruct usb_device *usbdev = interface_to_usbdev(interface);\r\nifnum = interface->altsetting->desc.bInterfaceNumber;\r\nif (ifnum != 0)\r\nreturn -ENODEV;\r\ndprintk(1, "%s() vendor id 0x%x device id 0x%x ifnum:%d\n", __func__,\r\nle16_to_cpu(usbdev->descriptor.idVendor),\r\nle16_to_cpu(usbdev->descriptor.idProduct),\r\nifnum);\r\nif (usbdev->speed != USB_SPEED_HIGH && disable_usb_speed_check == 0) {\r\npr_err("au0828: Device initialization failed.\n");\r\npr_err("au0828: Device must be connected to a high-speed USB 2.0 port.\n");\r\nreturn -ENODEV;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (dev == NULL) {\r\npr_err("%s() Unable to allocate memory\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&dev->lock);\r\nmutex_lock(&dev->lock);\r\nmutex_init(&dev->mutex);\r\nmutex_init(&dev->dvb.lock);\r\ndev->usbdev = usbdev;\r\ndev->boardnr = id->driver_info;\r\ndev->board = au0828_boards[dev->boardnr];\r\nretval = au0828_media_device_init(dev, usbdev);\r\nif (retval) {\r\npr_err("%s() au0828_media_device_init failed\n",\r\n__func__);\r\nmutex_unlock(&dev->lock);\r\nkfree(dev);\r\nreturn retval;\r\n}\r\nretval = au0828_v4l2_device_register(interface, dev);\r\nif (retval) {\r\nau0828_usb_v4l2_media_release(dev);\r\nmutex_unlock(&dev->lock);\r\nkfree(dev);\r\nreturn retval;\r\n}\r\nau0828_write(dev, REG_600, 1 << 4);\r\nau0828_gpio_setup(dev);\r\nau0828_i2c_register(dev);\r\nau0828_card_setup(dev);\r\nretval = au0828_analog_register(dev, interface);\r\nif (retval) {\r\npr_err("%s() au0282_dev_register failed to register on V4L2\n",\r\n__func__);\r\ngoto done;\r\n}\r\nretval = au0828_dvb_register(dev);\r\nif (retval)\r\npr_err("%s() au0282_dev_register failed\n",\r\n__func__);\r\nau0828_rc_register(dev);\r\nusb_set_intfdata(interface, dev);\r\npr_info("Registered device AU0828 [%s]\n",\r\ndev->board.name == NULL ? "Unset" : dev->board.name);\r\nmutex_unlock(&dev->lock);\r\nretval = au0828_media_device_register(dev, usbdev);\r\ndone:\r\nif (retval < 0)\r\nau0828_usb_disconnect(interface);\r\nreturn retval;\r\n}\r\nstatic int au0828_suspend(struct usb_interface *interface,\r\npm_message_t message)\r\n{\r\nstruct au0828_dev *dev = usb_get_intfdata(interface);\r\nif (!dev)\r\nreturn 0;\r\npr_info("Suspend\n");\r\nau0828_rc_suspend(dev);\r\nau0828_v4l2_suspend(dev);\r\nau0828_dvb_suspend(dev);\r\nreturn 0;\r\n}\r\nstatic int au0828_resume(struct usb_interface *interface)\r\n{\r\nstruct au0828_dev *dev = usb_get_intfdata(interface);\r\nif (!dev)\r\nreturn 0;\r\npr_info("Resume\n");\r\nau0828_write(dev, REG_600, 1 << 4);\r\nau0828_gpio_setup(dev);\r\nau0828_rc_resume(dev);\r\nau0828_v4l2_resume(dev);\r\nau0828_dvb_resume(dev);\r\nreturn 0;\r\n}\r\nstatic int __init au0828_init(void)\r\n{\r\nint ret;\r\nif (au0828_debug & 1)\r\npr_info("%s() Debugging is enabled\n", __func__);\r\nif (au0828_debug & 2)\r\npr_info("%s() USB Debugging is enabled\n", __func__);\r\nif (au0828_debug & 4)\r\npr_info("%s() I2C Debugging is enabled\n", __func__);\r\nif (au0828_debug & 8)\r\npr_info("%s() Bridge Debugging is enabled\n",\r\n__func__);\r\nif (au0828_debug & 16)\r\npr_info("%s() IR Debugging is enabled\n",\r\n__func__);\r\npr_info("au0828 driver loaded\n");\r\nret = usb_register(&au0828_usb_driver);\r\nif (ret)\r\npr_err("usb_register failed, error = %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit au0828_exit(void)\r\n{\r\nusb_deregister(&au0828_usb_driver);\r\n}
