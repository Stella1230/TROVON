int ocfs2_write_block(struct ocfs2_super *osb, struct buffer_head *bh,\r\nstruct ocfs2_caching_info *ci)\r\n{\r\nint ret = 0;\r\ntrace_ocfs2_write_block((unsigned long long)bh->b_blocknr, ci);\r\nBUG_ON(bh->b_blocknr < OCFS2_SUPER_BLOCK_BLKNO);\r\nBUG_ON(buffer_jbd(bh));\r\nif (ocfs2_is_hard_readonly(osb)) {\r\nret = -EROFS;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nocfs2_metadata_cache_io_lock(ci);\r\nlock_buffer(bh);\r\nset_buffer_uptodate(bh);\r\nclear_buffer_dirty(bh);\r\nget_bh(bh);\r\nbh->b_end_io = end_buffer_write_sync;\r\nsubmit_bh(REQ_OP_WRITE, 0, bh);\r\nwait_on_buffer(bh);\r\nif (buffer_uptodate(bh)) {\r\nocfs2_set_buffer_uptodate(ci, bh);\r\n} else {\r\nret = -EIO;\r\nmlog_errno(ret);\r\n}\r\nocfs2_metadata_cache_io_unlock(ci);\r\nout:\r\nreturn ret;\r\n}\r\nint ocfs2_read_blocks_sync(struct ocfs2_super *osb, u64 block,\r\nunsigned int nr, struct buffer_head *bhs[])\r\n{\r\nint status = 0;\r\nunsigned int i;\r\nstruct buffer_head *bh;\r\ntrace_ocfs2_read_blocks_sync((unsigned long long)block, nr);\r\nif (!nr)\r\ngoto bail;\r\nfor (i = 0 ; i < nr ; i++) {\r\nif (bhs[i] == NULL) {\r\nbhs[i] = sb_getblk(osb->sb, block++);\r\nif (bhs[i] == NULL) {\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n}\r\nbh = bhs[i];\r\nif (buffer_jbd(bh)) {\r\ntrace_ocfs2_read_blocks_sync_jbd(\r\n(unsigned long long)bh->b_blocknr);\r\ncontinue;\r\n}\r\nif (buffer_dirty(bh)) {\r\nmlog(ML_ERROR,\r\n"trying to sync read a dirty "\r\n"buffer! (blocknr = %llu), skipping\n",\r\n(unsigned long long)bh->b_blocknr);\r\ncontinue;\r\n}\r\nlock_buffer(bh);\r\nif (buffer_jbd(bh)) {\r\n#ifdef CATCH_BH_JBD_RACES\r\nmlog(ML_ERROR,\r\n"block %llu had the JBD bit set "\r\n"while I was in lock_buffer!",\r\n(unsigned long long)bh->b_blocknr);\r\nBUG();\r\n#else\r\nunlock_buffer(bh);\r\ncontinue;\r\n#endif\r\n}\r\nclear_buffer_uptodate(bh);\r\nget_bh(bh);\r\nbh->b_end_io = end_buffer_read_sync;\r\nsubmit_bh(REQ_OP_READ, 0, bh);\r\n}\r\nfor (i = nr; i > 0; i--) {\r\nbh = bhs[i - 1];\r\nif (!buffer_jbd(bh))\r\nwait_on_buffer(bh);\r\nif (!buffer_uptodate(bh)) {\r\nstatus = -EIO;\r\nput_bh(bh);\r\nbhs[i - 1] = NULL;\r\n}\r\n}\r\nbail:\r\nreturn status;\r\n}\r\nint ocfs2_read_blocks(struct ocfs2_caching_info *ci, u64 block, int nr,\r\nstruct buffer_head *bhs[], int flags,\r\nint (*validate)(struct super_block *sb,\r\nstruct buffer_head *bh))\r\n{\r\nint status = 0;\r\nint i, ignore_cache = 0;\r\nstruct buffer_head *bh;\r\nstruct super_block *sb = ocfs2_metadata_cache_get_super(ci);\r\ntrace_ocfs2_read_blocks_begin(ci, (unsigned long long)block, nr, flags);\r\nBUG_ON(!ci);\r\nBUG_ON((flags & OCFS2_BH_READAHEAD) &&\r\n(flags & OCFS2_BH_IGNORE_CACHE));\r\nif (bhs == NULL) {\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nif (nr < 0) {\r\nmlog(ML_ERROR, "asked to read %d blocks!\n", nr);\r\nstatus = -EINVAL;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\nif (nr == 0) {\r\nstatus = 0;\r\ngoto bail;\r\n}\r\nocfs2_metadata_cache_io_lock(ci);\r\nfor (i = 0 ; i < nr ; i++) {\r\nif (bhs[i] == NULL) {\r\nbhs[i] = sb_getblk(sb, block++);\r\nif (bhs[i] == NULL) {\r\nocfs2_metadata_cache_io_unlock(ci);\r\nstatus = -ENOMEM;\r\nmlog_errno(status);\r\ngoto bail;\r\n}\r\n}\r\nbh = bhs[i];\r\nignore_cache = (flags & OCFS2_BH_IGNORE_CACHE);\r\nif (!ignore_cache && !ocfs2_buffer_uptodate(ci, bh)) {\r\ntrace_ocfs2_read_blocks_from_disk(\r\n(unsigned long long)bh->b_blocknr,\r\n(unsigned long long)ocfs2_metadata_cache_owner(ci));\r\nignore_cache = 1;\r\n}\r\ntrace_ocfs2_read_blocks_bh((unsigned long long)bh->b_blocknr,\r\nignore_cache, buffer_jbd(bh), buffer_dirty(bh));\r\nif (buffer_jbd(bh)) {\r\ncontinue;\r\n}\r\nif (ignore_cache) {\r\nif (buffer_dirty(bh)) {\r\ncontinue;\r\n}\r\nif ((flags & OCFS2_BH_READAHEAD)\r\n&& ocfs2_buffer_read_ahead(ci, bh))\r\ncontinue;\r\nlock_buffer(bh);\r\nif (buffer_jbd(bh)) {\r\n#ifdef CATCH_BH_JBD_RACES\r\nmlog(ML_ERROR, "block %llu had the JBD bit set "\r\n"while I was in lock_buffer!",\r\n(unsigned long long)bh->b_blocknr);\r\nBUG();\r\n#else\r\nunlock_buffer(bh);\r\ncontinue;\r\n#endif\r\n}\r\nif (!(flags & OCFS2_BH_IGNORE_CACHE)\r\n&& !(flags & OCFS2_BH_READAHEAD)\r\n&& ocfs2_buffer_uptodate(ci, bh)) {\r\nunlock_buffer(bh);\r\ncontinue;\r\n}\r\nclear_buffer_uptodate(bh);\r\nget_bh(bh);\r\nif (validate)\r\nset_buffer_needs_validate(bh);\r\nbh->b_end_io = end_buffer_read_sync;\r\nsubmit_bh(REQ_OP_READ, 0, bh);\r\ncontinue;\r\n}\r\n}\r\nstatus = 0;\r\nfor (i = (nr - 1); i >= 0; i--) {\r\nbh = bhs[i];\r\nif (!(flags & OCFS2_BH_READAHEAD)) {\r\nif (status) {\r\nput_bh(bh);\r\nbhs[i] = NULL;\r\ncontinue;\r\n}\r\nif (!buffer_jbd(bh))\r\nwait_on_buffer(bh);\r\nif (!buffer_uptodate(bh)) {\r\nstatus = -EIO;\r\nput_bh(bh);\r\nbhs[i] = NULL;\r\ncontinue;\r\n}\r\nif (buffer_needs_validate(bh)) {\r\nBUG_ON(buffer_jbd(bh));\r\nclear_buffer_needs_validate(bh);\r\nstatus = validate(sb, bh);\r\nif (status) {\r\nput_bh(bh);\r\nbhs[i] = NULL;\r\ncontinue;\r\n}\r\n}\r\n}\r\nocfs2_set_buffer_uptodate(ci, bh);\r\n}\r\nocfs2_metadata_cache_io_unlock(ci);\r\ntrace_ocfs2_read_blocks_end((unsigned long long)block, nr,\r\nflags, ignore_cache);\r\nbail:\r\nreturn status;\r\n}\r\nstatic void ocfs2_check_super_or_backup(struct super_block *sb,\r\nsector_t blkno)\r\n{\r\nint i;\r\nu64 backup_blkno;\r\nif (blkno == OCFS2_SUPER_BLOCK_BLKNO)\r\nreturn;\r\nfor (i = 0; i < OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {\r\nbackup_blkno = ocfs2_backup_super_blkno(sb, i);\r\nif (backup_blkno == blkno)\r\nreturn;\r\n}\r\nBUG();\r\n}\r\nint ocfs2_write_super_or_backup(struct ocfs2_super *osb,\r\nstruct buffer_head *bh)\r\n{\r\nint ret = 0;\r\nstruct ocfs2_dinode *di = (struct ocfs2_dinode *)bh->b_data;\r\nBUG_ON(buffer_jbd(bh));\r\nocfs2_check_super_or_backup(osb->sb, bh->b_blocknr);\r\nif (ocfs2_is_hard_readonly(osb) || ocfs2_is_soft_readonly(osb)) {\r\nret = -EROFS;\r\nmlog_errno(ret);\r\ngoto out;\r\n}\r\nlock_buffer(bh);\r\nset_buffer_uptodate(bh);\r\nclear_buffer_dirty(bh);\r\nget_bh(bh);\r\nbh->b_end_io = end_buffer_write_sync;\r\nocfs2_compute_meta_ecc(osb->sb, bh->b_data, &di->i_check);\r\nsubmit_bh(REQ_OP_WRITE, 0, bh);\r\nwait_on_buffer(bh);\r\nif (!buffer_uptodate(bh)) {\r\nret = -EIO;\r\nmlog_errno(ret);\r\n}\r\nout:\r\nreturn ret;\r\n}
