static void crypto_pump_requests(struct crypto_engine *engine,\r\nbool in_kthread)\r\n{\r\nstruct crypto_async_request *async_req, *backlog;\r\nstruct ahash_request *hreq;\r\nstruct ablkcipher_request *breq;\r\nunsigned long flags;\r\nbool was_busy = false;\r\nint ret, rtype;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nif (engine->cur_req)\r\ngoto out;\r\nif (engine->idling) {\r\nkthread_queue_work(engine->kworker, &engine->pump_requests);\r\ngoto out;\r\n}\r\nif (!crypto_queue_len(&engine->queue) || !engine->running) {\r\nif (!engine->busy)\r\ngoto out;\r\nif (!in_kthread) {\r\nkthread_queue_work(engine->kworker,\r\n&engine->pump_requests);\r\ngoto out;\r\n}\r\nengine->busy = false;\r\nengine->idling = true;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nif (engine->unprepare_crypt_hardware &&\r\nengine->unprepare_crypt_hardware(engine))\r\npr_err("failed to unprepare crypt hardware\n");\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nengine->idling = false;\r\ngoto out;\r\n}\r\nbacklog = crypto_get_backlog(&engine->queue);\r\nasync_req = crypto_dequeue_request(&engine->queue);\r\nif (!async_req)\r\ngoto out;\r\nengine->cur_req = async_req;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nif (engine->busy)\r\nwas_busy = true;\r\nelse\r\nengine->busy = true;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nrtype = crypto_tfm_alg_type(engine->cur_req->tfm);\r\nif (!was_busy && engine->prepare_crypt_hardware) {\r\nret = engine->prepare_crypt_hardware(engine);\r\nif (ret) {\r\npr_err("failed to prepare crypt hardware\n");\r\ngoto req_err;\r\n}\r\n}\r\nswitch (rtype) {\r\ncase CRYPTO_ALG_TYPE_AHASH:\r\nhreq = ahash_request_cast(engine->cur_req);\r\nif (engine->prepare_hash_request) {\r\nret = engine->prepare_hash_request(engine, hreq);\r\nif (ret) {\r\npr_err("failed to prepare request: %d\n", ret);\r\ngoto req_err;\r\n}\r\nengine->cur_req_prepared = true;\r\n}\r\nret = engine->hash_one_request(engine, hreq);\r\nif (ret) {\r\npr_err("failed to hash one request from queue\n");\r\ngoto req_err;\r\n}\r\nreturn;\r\ncase CRYPTO_ALG_TYPE_ABLKCIPHER:\r\nbreq = ablkcipher_request_cast(engine->cur_req);\r\nif (engine->prepare_cipher_request) {\r\nret = engine->prepare_cipher_request(engine, breq);\r\nif (ret) {\r\npr_err("failed to prepare request: %d\n", ret);\r\ngoto req_err;\r\n}\r\nengine->cur_req_prepared = true;\r\n}\r\nret = engine->cipher_one_request(engine, breq);\r\nif (ret) {\r\npr_err("failed to cipher one request from queue\n");\r\ngoto req_err;\r\n}\r\nreturn;\r\ndefault:\r\npr_err("failed to prepare request of unknown type\n");\r\nreturn;\r\n}\r\nreq_err:\r\nswitch (rtype) {\r\ncase CRYPTO_ALG_TYPE_AHASH:\r\nhreq = ahash_request_cast(engine->cur_req);\r\ncrypto_finalize_hash_request(engine, hreq, ret);\r\nbreak;\r\ncase CRYPTO_ALG_TYPE_ABLKCIPHER:\r\nbreq = ablkcipher_request_cast(engine->cur_req);\r\ncrypto_finalize_cipher_request(engine, breq, ret);\r\nbreak;\r\n}\r\nreturn;\r\nout:\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\n}\r\nstatic void crypto_pump_work(struct kthread_work *work)\r\n{\r\nstruct crypto_engine *engine =\r\ncontainer_of(work, struct crypto_engine, pump_requests);\r\ncrypto_pump_requests(engine, true);\r\n}\r\nint crypto_transfer_cipher_request(struct crypto_engine *engine,\r\nstruct ablkcipher_request *req,\r\nbool need_pump)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nif (!engine->running) {\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nret = ablkcipher_enqueue_request(&engine->queue, req);\r\nif (!engine->busy && need_pump)\r\nkthread_queue_work(engine->kworker, &engine->pump_requests);\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nreturn ret;\r\n}\r\nint crypto_transfer_cipher_request_to_engine(struct crypto_engine *engine,\r\nstruct ablkcipher_request *req)\r\n{\r\nreturn crypto_transfer_cipher_request(engine, req, true);\r\n}\r\nint crypto_transfer_hash_request(struct crypto_engine *engine,\r\nstruct ahash_request *req, bool need_pump)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nif (!engine->running) {\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nret = ahash_enqueue_request(&engine->queue, req);\r\nif (!engine->busy && need_pump)\r\nkthread_queue_work(engine->kworker, &engine->pump_requests);\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nreturn ret;\r\n}\r\nint crypto_transfer_hash_request_to_engine(struct crypto_engine *engine,\r\nstruct ahash_request *req)\r\n{\r\nreturn crypto_transfer_hash_request(engine, req, true);\r\n}\r\nvoid crypto_finalize_cipher_request(struct crypto_engine *engine,\r\nstruct ablkcipher_request *req, int err)\r\n{\r\nunsigned long flags;\r\nbool finalize_cur_req = false;\r\nint ret;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nif (engine->cur_req == &req->base)\r\nfinalize_cur_req = true;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nif (finalize_cur_req) {\r\nif (engine->cur_req_prepared &&\r\nengine->unprepare_cipher_request) {\r\nret = engine->unprepare_cipher_request(engine, req);\r\nif (ret)\r\npr_err("failed to unprepare request\n");\r\n}\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nengine->cur_req = NULL;\r\nengine->cur_req_prepared = false;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\n}\r\nreq->base.complete(&req->base, err);\r\nkthread_queue_work(engine->kworker, &engine->pump_requests);\r\n}\r\nvoid crypto_finalize_hash_request(struct crypto_engine *engine,\r\nstruct ahash_request *req, int err)\r\n{\r\nunsigned long flags;\r\nbool finalize_cur_req = false;\r\nint ret;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nif (engine->cur_req == &req->base)\r\nfinalize_cur_req = true;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nif (finalize_cur_req) {\r\nif (engine->cur_req_prepared &&\r\nengine->unprepare_hash_request) {\r\nret = engine->unprepare_hash_request(engine, req);\r\nif (ret)\r\npr_err("failed to unprepare request\n");\r\n}\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nengine->cur_req = NULL;\r\nengine->cur_req_prepared = false;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\n}\r\nreq->base.complete(&req->base, err);\r\nkthread_queue_work(engine->kworker, &engine->pump_requests);\r\n}\r\nint crypto_engine_start(struct crypto_engine *engine)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nif (engine->running || engine->busy) {\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nreturn -EBUSY;\r\n}\r\nengine->running = true;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nkthread_queue_work(engine->kworker, &engine->pump_requests);\r\nreturn 0;\r\n}\r\nint crypto_engine_stop(struct crypto_engine *engine)\r\n{\r\nunsigned long flags;\r\nunsigned int limit = 500;\r\nint ret = 0;\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\nwhile ((crypto_queue_len(&engine->queue) || engine->busy) && limit--) {\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nmsleep(20);\r\nspin_lock_irqsave(&engine->queue_lock, flags);\r\n}\r\nif (crypto_queue_len(&engine->queue) || engine->busy)\r\nret = -EBUSY;\r\nelse\r\nengine->running = false;\r\nspin_unlock_irqrestore(&engine->queue_lock, flags);\r\nif (ret)\r\npr_warn("could not stop engine\n");\r\nreturn ret;\r\n}\r\nstruct crypto_engine *crypto_engine_alloc_init(struct device *dev, bool rt)\r\n{\r\nstruct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };\r\nstruct crypto_engine *engine;\r\nif (!dev)\r\nreturn NULL;\r\nengine = devm_kzalloc(dev, sizeof(*engine), GFP_KERNEL);\r\nif (!engine)\r\nreturn NULL;\r\nengine->rt = rt;\r\nengine->running = false;\r\nengine->busy = false;\r\nengine->idling = false;\r\nengine->cur_req_prepared = false;\r\nengine->priv_data = dev;\r\nsnprintf(engine->name, sizeof(engine->name),\r\n"%s-engine", dev_name(dev));\r\ncrypto_init_queue(&engine->queue, CRYPTO_ENGINE_MAX_QLEN);\r\nspin_lock_init(&engine->queue_lock);\r\nengine->kworker = kthread_create_worker(0, "%s", engine->name);\r\nif (IS_ERR(engine->kworker)) {\r\ndev_err(dev, "failed to create crypto request pump task\n");\r\nreturn NULL;\r\n}\r\nkthread_init_work(&engine->pump_requests, crypto_pump_work);\r\nif (engine->rt) {\r\ndev_info(dev, "will run requests pump with realtime priority\n");\r\nsched_setscheduler(engine->kworker->task, SCHED_FIFO, &param);\r\n}\r\nreturn engine;\r\n}\r\nint crypto_engine_exit(struct crypto_engine *engine)\r\n{\r\nint ret;\r\nret = crypto_engine_stop(engine);\r\nif (ret)\r\nreturn ret;\r\nkthread_destroy_worker(engine->kworker);\r\nreturn 0;\r\n}
