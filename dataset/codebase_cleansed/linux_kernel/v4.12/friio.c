static int gl861_i2c_ctrlmsg_data(struct dvb_usb_device *d, u8 addr,\r\nu8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\r\n{\r\nu16 index = wbuf[0];\r\nu16 value = addr << (8 + 1);\r\nint wo = (rbuf == NULL || rlen == 0);\r\nu8 req, type;\r\ndeb_xfer("write to PLL:0x%02x via FE reg:0x%02x, len:%d\n",\r\nwbuf[1], wbuf[0], wlen - 1);\r\nif (wo && wlen >= 2) {\r\nreq = GL861_REQ_I2C_DATA_CTRL_WRITE;\r\ntype = GL861_WRITE;\r\nudelay(20);\r\nreturn usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\r\nreq, type, value, index,\r\n&wbuf[1], wlen - 1, 2000);\r\n}\r\ndeb_xfer("not supported ctrl-msg, aborting.");\r\nreturn -EINVAL;\r\n}\r\nstatic int gl861_i2c_msg(struct dvb_usb_device *d, u8 addr,\r\nu8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\r\n{\r\nu16 index;\r\nu16 value = addr << (8 + 1);\r\nint wo = (rbuf == NULL || rlen == 0);\r\nu8 req, type;\r\nunsigned int pipe;\r\nif (addr == friio_fe_config.demod_address &&\r\nwbuf[0] == JDVBT90502_2ND_I2C_REG)\r\nreturn gl861_i2c_ctrlmsg_data(d, addr, wbuf, wlen, rbuf, rlen);\r\nif (wo) {\r\nreq = GL861_REQ_I2C_WRITE;\r\ntype = GL861_WRITE;\r\npipe = usb_sndctrlpipe(d->udev, 0);\r\n} else {\r\nreq = GL861_REQ_I2C_READ;\r\ntype = GL861_READ;\r\npipe = usb_rcvctrlpipe(d->udev, 0);\r\n}\r\nswitch (wlen) {\r\ncase 1:\r\nindex = wbuf[0];\r\nbreak;\r\ncase 2:\r\nindex = wbuf[0];\r\nvalue = value + wbuf[1];\r\nbreak;\r\ncase 3:\r\nindex = (wbuf[2] << 8) | wbuf[0];\r\nvalue = value + wbuf[1];\r\nbreak;\r\ndefault:\r\ndeb_xfer("wlen = %x, aborting.", wlen);\r\nreturn -EINVAL;\r\n}\r\nmsleep(1);\r\nreturn usb_control_msg(d->udev, pipe, req, type,\r\nvalue, index, rbuf, rlen, 2000);\r\n}\r\nstatic int gl861_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint i;\r\nif (num > 2)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nfor (i = 0; i < num; i++) {\r\nif (i + 1 < num && (msg[i + 1].flags & I2C_M_RD)) {\r\nif (gl861_i2c_msg(d, msg[i].addr,\r\nmsg[i].buf, msg[i].len,\r\nmsg[i + 1].buf, msg[i + 1].len) < 0)\r\nbreak;\r\ni++;\r\n} else\r\nif (gl861_i2c_msg(d, msg[i].addr, msg[i].buf,\r\nmsg[i].len, NULL, 0) < 0)\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 gl861_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int friio_ext_ctl(struct dvb_usb_adapter *adap,\r\nu32 sat_color, int lnb_on)\r\n{\r\nint i;\r\nint ret;\r\nstruct i2c_msg msg;\r\nu8 *buf;\r\nu32 mask;\r\nu8 lnb = (lnb_on) ? FRIIO_CTL_LNB : 0;\r\nbuf = kmalloc(2, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nmsg.addr = 0x00;\r\nmsg.flags = 0;\r\nmsg.len = 2;\r\nmsg.buf = buf;\r\nbuf[0] = 0x00;\r\nbuf[1] = lnb | FRIIO_CTL_LED | FRIIO_CTL_STROBE;\r\nret = gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nbuf[1] |= FRIIO_CTL_CLK;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nbuf[1] = lnb | FRIIO_CTL_STROBE;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nbuf[1] |= FRIIO_CTL_CLK;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nmask = 1 << 31;\r\nfor (i = 0; i < 32; i++) {\r\nbuf[1] = lnb | FRIIO_CTL_STROBE;\r\nif (sat_color & mask)\r\nbuf[1] |= FRIIO_CTL_LED;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nbuf[1] |= FRIIO_CTL_CLK;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nmask >>= 1;\r\n}\r\nbuf[1] = lnb;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nbuf[1] |= FRIIO_CTL_CLK;\r\nret += gl861_i2c_xfer(&adap->dev->i2c_adap, &msg, 1);\r\nkfree(buf);\r\nreturn (ret == 70);\r\n}\r\nstatic int friio_initialize(struct dvb_usb_device *d)\r\n{\r\nint ret;\r\nint i;\r\nint retry = 0;\r\nu8 *rbuf, *wbuf;\r\ndeb_info("%s called.\n", __func__);\r\nwbuf = kmalloc(3, GFP_KERNEL);\r\nif (!wbuf)\r\nreturn -ENOMEM;\r\nrbuf = kmalloc(2, GFP_KERNEL);\r\nif (!rbuf) {\r\nkfree(wbuf);\r\nreturn -ENOMEM;\r\n}\r\nwbuf[0] = 0x11;\r\nwbuf[1] = 0x02;\r\nret = gl861_i2c_msg(d, 0x00, wbuf, 2, NULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(2);\r\nwbuf[0] = 0x11;\r\nwbuf[1] = 0x00;\r\nret = gl861_i2c_msg(d, 0x00, wbuf, 2, NULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(1);\r\nwbuf[0] = 0x03;\r\nwbuf[1] = 0x80;\r\nret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\r\nGL861_REQ_I2C_DATA_CTRL_WRITE, GL861_WRITE,\r\n0x1200, 0x0100, wbuf, 2, 2000);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(2);\r\nwbuf[0] = 0x00;\r\nwbuf[2] = 0x01;\r\nwbuf[1] = 0x00;\r\nret = gl861_i2c_msg(d, 0x12 >> 1, wbuf, 3, rbuf, 2);\r\nif (ret < 0 || rbuf[0] != 0xff || rbuf[1] != 0xff)\r\ngoto error;\r\nmsleep(2);\r\nwbuf[0] = 0x03;\r\nwbuf[1] = 0x80;\r\nret = usb_control_msg(d->udev, usb_sndctrlpipe(d->udev, 0),\r\nGL861_REQ_I2C_DATA_CTRL_WRITE, GL861_WRITE,\r\n0x9000, 0x0100, wbuf, 2, 2000);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(2);\r\nwbuf[0] = 0x00;\r\nwbuf[2] = 0x01;\r\nwbuf[1] = 0x00;\r\nret = gl861_i2c_msg(d, 0x90 >> 1, wbuf, 3, rbuf, 2);\r\nif (ret < 0 || rbuf[0] != 0xff || rbuf[1] != 0xff)\r\ngoto error;\r\nmsleep(1);\r\nrestart:\r\nwbuf[0] = JDVBT90502_2ND_I2C_REG;\r\nwbuf[1] = (FRIIO_PLL_ADDR << 1) + 1;\r\nret = gl861_i2c_msg(d, FRIIO_DEMOD_ADDR, wbuf, 2, NULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(5);\r\nwbuf[0] = 0x00;\r\nwbuf[2] = 0x01;\r\nwbuf[1] = 0x00;\r\nret = gl861_i2c_msg(d, FRIIO_DEMOD_ADDR, wbuf, 3, rbuf, 1);\r\nif (ret < 0)\r\ngoto error;\r\nif (rbuf[0] & 0x80) {\r\nif (++retry > 3) {\r\ndeb_info("failed to get the correct FE demod status:0x%02x\n",\r\nrbuf[0]);\r\ngoto error;\r\n}\r\nmsleep(100);\r\ngoto restart;\r\n}\r\nmsleep(1);\r\nwbuf[0] = 0x30;\r\nwbuf[1] = 0x04;\r\nret = gl861_i2c_msg(d, 0x00, wbuf, 2, NULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(2);\r\nwbuf[0] = 0x00;\r\nwbuf[1] = 0x01;\r\nret = gl861_i2c_msg(d, 0x00, wbuf, 2, NULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nwbuf[0] = 0x06;\r\nwbuf[1] = 0x0F;\r\nret = gl861_i2c_msg(d, 0x00, wbuf, 2, NULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(10);\r\nfor (i = 0; i < cmdlen; i++) {\r\nret = gl861_i2c_msg(d, 0x00, streaming_init_cmds[i], 2,\r\nNULL, 0);\r\nif (ret < 0)\r\ngoto error;\r\nmsleep(1);\r\n}\r\nmsleep(20);\r\nret = friio_streaming_ctrl(&d->adapter[0], 0);\r\nif (ret < 0)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nkfree(wbuf);\r\nkfree(rbuf);\r\ndeb_info("%s:ret == %d\n", __func__, ret);\r\nreturn -EIO;\r\n}\r\nstatic int friio_streaming_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nint ret;\r\ndeb_info("%s called.(%d)\n", __func__, onoff);\r\nif (onoff)\r\nret = friio_ext_ctl(adap, 0x6400ff64, 1);\r\nelse\r\nret = friio_ext_ctl(adap, 0x96ff00ff, 1);\r\nif (ret != 1) {\r\ndeb_info("%s failed to send cmdx. ret==%d\n", __func__, ret);\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int friio_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nif (friio_initialize(adap->dev) < 0)\r\nreturn -EIO;\r\nadap->fe_adap[0].fe = jdvbt90502_attach(adap->dev);\r\nif (adap->fe_adap[0].fe == NULL)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int friio_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct dvb_usb_device *d;\r\nstruct usb_host_interface *alt;\r\nint ret;\r\nif (intf->num_altsetting < GL861_ALTSETTING_COUNT)\r\nreturn -ENODEV;\r\nalt = usb_altnum_to_altsetting(intf, FRIIO_BULK_ALTSETTING);\r\nif (alt == NULL) {\r\ndeb_rc("not alt found!\n");\r\nreturn -ENODEV;\r\n}\r\nret = usb_set_interface(interface_to_usbdev(intf),\r\nalt->desc.bInterfaceNumber,\r\nalt->desc.bAlternateSetting);\r\nif (ret != 0) {\r\ndeb_rc("failed to set alt-setting!\n");\r\nreturn ret;\r\n}\r\nret = dvb_usb_device_init(intf, &friio_properties,\r\nTHIS_MODULE, &d, adapter_nr);\r\nif (ret == 0)\r\nfriio_streaming_ctrl(&d->adapter[0], 1);\r\nreturn ret;\r\n}
