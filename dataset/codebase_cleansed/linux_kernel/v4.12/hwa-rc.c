static\r\nint hwarc_filter_evt_beacon_WUSB_0100(struct uwb_rc *rc,\r\nstruct uwb_rceb **header,\r\nconst size_t buf_size,\r\nsize_t *new_size)\r\n{\r\nstruct uwb_rc_evt_beacon_WUSB_0100 *be;\r\nstruct uwb_rc_evt_beacon *newbe;\r\nsize_t bytes_left, ielength;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nbe = container_of(*header, struct uwb_rc_evt_beacon_WUSB_0100, rceb);\r\nbytes_left = buf_size;\r\nif (bytes_left < sizeof(*be)) {\r\ndev_err(dev, "Beacon Received Notification: Not enough data "\r\n"to decode for filtering (%zu vs %zu bytes needed)\n",\r\nbytes_left, sizeof(*be));\r\nreturn -EINVAL;\r\n}\r\nbytes_left -= sizeof(*be);\r\nielength = le16_to_cpu(be->wBeaconInfoLength);\r\nif (bytes_left < ielength) {\r\ndev_err(dev, "Beacon Received Notification: Not enough data "\r\n"to decode IEs (%zu vs %zu bytes needed)\n",\r\nbytes_left, ielength);\r\nreturn -EINVAL;\r\n}\r\nnewbe = kzalloc(sizeof(*newbe) + ielength, GFP_ATOMIC);\r\nif (newbe == NULL)\r\nreturn -ENOMEM;\r\nnewbe->rceb = be->rceb;\r\nnewbe->bChannelNumber = be->bChannelNumber;\r\nnewbe->bBeaconType = UWB_RC_BEACON_TYPE_NEIGHBOR;\r\nnewbe->wBPSTOffset = be->wBPSTOffset;\r\nnewbe->bLQI = be->bLQI;\r\nnewbe->bRSSI = be->bRSSI;\r\nnewbe->wBeaconInfoLength = be->wBeaconInfoLength;\r\nmemcpy(newbe->BeaconInfo, be->BeaconInfo, ielength);\r\n*header = &newbe->rceb;\r\n*new_size = sizeof(*newbe) + ielength;\r\nreturn 1;\r\n}\r\nstatic\r\nint hwarc_filter_evt_drp_avail_WUSB_0100(struct uwb_rc *rc,\r\nstruct uwb_rceb **header,\r\nconst size_t buf_size,\r\nsize_t *new_size)\r\n{\r\nstruct uwb_rc_evt_drp_avail_WUSB_0100 *da;\r\nstruct uwb_rc_evt_drp_avail *newda;\r\nstruct uwb_ie_hdr *ie_hdr;\r\nsize_t bytes_left, ielength;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nda = container_of(*header, struct uwb_rc_evt_drp_avail_WUSB_0100, rceb);\r\nbytes_left = buf_size;\r\nif (bytes_left < sizeof(*da)) {\r\ndev_err(dev, "Not enough data to decode DRP Avail "\r\n"Notification for filtering. Expected %zu, "\r\n"received %zu.\n", (size_t)sizeof(*da), bytes_left);\r\nreturn -EINVAL;\r\n}\r\nbytes_left -= sizeof(*da);\r\nielength = le16_to_cpu(da->wIELength);\r\nif (bytes_left < ielength) {\r\ndev_err(dev, "DRP Avail Notification filter: IE length "\r\n"[%zu bytes] does not match actual length "\r\n"[%zu bytes].\n", ielength, bytes_left);\r\nreturn -EINVAL;\r\n}\r\nif (ielength < sizeof(*ie_hdr)) {\r\ndev_err(dev, "DRP Avail Notification filter: Not enough "\r\n"data to decode IE [%zu bytes, %zu needed]\n",\r\nielength, sizeof(*ie_hdr));\r\nreturn -EINVAL;\r\n}\r\nie_hdr = (void *) da->IEData;\r\nif (ie_hdr->length > 32) {\r\ndev_err(dev, "DRP Availability Change event has unexpected "\r\n"length for filtering. Expected < 32 bytes, "\r\n"got %zu bytes.\n", (size_t)ie_hdr->length);\r\nreturn -EINVAL;\r\n}\r\nnewda = kzalloc(sizeof(*newda), GFP_ATOMIC);\r\nif (newda == NULL)\r\nreturn -ENOMEM;\r\nnewda->rceb = da->rceb;\r\nmemcpy(newda->bmp, (u8 *) ie_hdr + sizeof(*ie_hdr), ie_hdr->length);\r\n*header = &newda->rceb;\r\n*new_size = sizeof(*newda);\r\nreturn 1;\r\n}\r\nstatic\r\nint hwarc_filter_evt_drp_WUSB_0100(struct uwb_rc *rc,\r\nstruct uwb_rceb **header,\r\nconst size_t buf_size,\r\nsize_t *new_size)\r\n{\r\nstruct uwb_rc_evt_drp_WUSB_0100 *drpev;\r\nstruct uwb_rc_evt_drp *newdrpev;\r\nsize_t bytes_left, ielength;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\ndrpev = container_of(*header, struct uwb_rc_evt_drp_WUSB_0100, rceb);\r\nbytes_left = buf_size;\r\nif (bytes_left < sizeof(*drpev)) {\r\ndev_err(dev, "Not enough data to decode DRP Notification "\r\n"for filtering. Expected %zu, received %zu.\n",\r\n(size_t)sizeof(*drpev), bytes_left);\r\nreturn -EINVAL;\r\n}\r\nielength = le16_to_cpu(drpev->wIELength);\r\nbytes_left -= sizeof(*drpev);\r\nif (bytes_left < ielength) {\r\ndev_err(dev, "DRP Notification filter: header length [%zu "\r\n"bytes] does not match actual length [%zu "\r\n"bytes].\n", ielength, bytes_left);\r\nreturn -EINVAL;\r\n}\r\nnewdrpev = kzalloc(sizeof(*newdrpev) + ielength, GFP_ATOMIC);\r\nif (newdrpev == NULL)\r\nreturn -ENOMEM;\r\nnewdrpev->rceb = drpev->rceb;\r\nnewdrpev->src_addr = drpev->wSrcAddr;\r\nnewdrpev->reason = UWB_DRP_NOTIF_DRP_IE_RCVD;\r\nnewdrpev->beacon_slot_number = 0;\r\nnewdrpev->ie_length = drpev->wIELength;\r\nmemcpy(newdrpev->ie_data, drpev->IEData, ielength);\r\n*header = &newdrpev->rceb;\r\n*new_size = sizeof(*newdrpev) + ielength;\r\nreturn 1;\r\n}\r\nstatic\r\nint hwarc_filter_cmd_scan_WUSB_0100(struct uwb_rc *rc,\r\nstruct uwb_rccb **header,\r\nsize_t *size)\r\n{\r\nstruct uwb_rc_cmd_scan *sc;\r\nsc = container_of(*header, struct uwb_rc_cmd_scan, rccb);\r\nif (sc->bScanState == UWB_SCAN_ONLY_STARTTIME)\r\nsc->bScanState = UWB_SCAN_ONLY;\r\n*size -= 2;\r\nreturn 0;\r\n}\r\nstatic\r\nint hwarc_filter_cmd_set_drp_ie_WUSB_0100(struct uwb_rc *rc,\r\nstruct uwb_rccb **header,\r\nsize_t *size)\r\n{\r\nstruct uwb_rc_cmd_set_drp_ie *orgcmd;\r\nstruct uwb_rc_cmd_set_drp_ie_WUSB_0100 *cmd;\r\nsize_t ielength;\r\norgcmd = container_of(*header, struct uwb_rc_cmd_set_drp_ie, rccb);\r\nielength = le16_to_cpu(orgcmd->wIELength);\r\ncmd = kzalloc(sizeof(*cmd) + ielength, GFP_KERNEL);\r\nif (cmd == NULL)\r\nreturn -ENOMEM;\r\ncmd->rccb = orgcmd->rccb;\r\ncmd->bExplicit = 0;\r\ncmd->wIELength = orgcmd->wIELength;\r\nmemcpy(cmd->IEData, orgcmd->IEData, ielength);\r\n*header = &cmd->rccb;\r\n*size = sizeof(*cmd) + ielength;\r\nreturn 1;\r\n}\r\nstatic\r\nint hwarc_filter_cmd_WUSB_0100(struct uwb_rc *rc, struct uwb_rccb **header,\r\nsize_t *size)\r\n{\r\nint result;\r\nstruct uwb_rccb *rccb = *header;\r\nint cmd = le16_to_cpu(rccb->wCommand);\r\nswitch (cmd) {\r\ncase UWB_RC_CMD_SCAN:\r\nresult = hwarc_filter_cmd_scan_WUSB_0100(rc, header, size);\r\nbreak;\r\ncase UWB_RC_CMD_SET_DRP_IE:\r\nresult = hwarc_filter_cmd_set_drp_ie_WUSB_0100(rc, header, size);\r\nbreak;\r\ndefault:\r\nresult = -ENOANO;\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic\r\nint hwarc_filter_cmd(struct uwb_rc *rc, struct uwb_rccb **header,\r\nsize_t *size)\r\n{\r\nint result = -ENOANO;\r\nif (rc->version == 0x0100)\r\nresult = hwarc_filter_cmd_WUSB_0100(rc, header, size);\r\nreturn result;\r\n}\r\nstatic\r\nssize_t hwarc_get_event_size(struct uwb_rc *rc, const struct uwb_rceb *rceb,\r\nsize_t core_size, size_t offset,\r\nconst size_t buf_size)\r\n{\r\nssize_t size = -ENOSPC;\r\nconst void *ptr = rceb;\r\nsize_t type_size = sizeof(__le16);\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nif (offset + type_size >= buf_size) {\r\ndev_err(dev, "Not enough data to read extra size of event "\r\n"0x%02x/%04x/%02x, only got %zu bytes.\n",\r\nrceb->bEventType, le16_to_cpu(rceb->wEvent),\r\nrceb->bEventContext, buf_size);\r\ngoto out;\r\n}\r\nptr += offset;\r\nsize = core_size + le16_to_cpu(*(__le16 *)ptr);\r\nout:\r\nreturn size;\r\n}\r\nstatic\r\nint hwarc_filter_event_WUSB_0100(struct uwb_rc *rc, struct uwb_rceb **header,\r\nconst size_t buf_size, size_t *_real_size,\r\nsize_t *_new_size)\r\n{\r\nint result = -ENOANO;\r\nstruct uwb_rceb *rceb = *header;\r\nint event = le16_to_cpu(rceb->wEvent);\r\nssize_t event_size;\r\nsize_t core_size, offset;\r\nif (rceb->bEventType != UWB_RC_CET_GENERAL)\r\ngoto out;\r\nswitch (event) {\r\ncase UWB_RC_EVT_BEACON:\r\ncore_size = sizeof(struct uwb_rc_evt_beacon_WUSB_0100);\r\noffset = offsetof(struct uwb_rc_evt_beacon_WUSB_0100,\r\nwBeaconInfoLength);\r\nevent_size = hwarc_get_event_size(rc, rceb, core_size,\r\noffset, buf_size);\r\nif (event_size < 0)\r\ngoto out;\r\n*_real_size = event_size;\r\nresult = hwarc_filter_evt_beacon_WUSB_0100(rc, header,\r\nbuf_size, _new_size);\r\nbreak;\r\ncase UWB_RC_EVT_BP_SLOT_CHANGE:\r\n*_new_size = *_real_size =\r\nsizeof(struct uwb_rc_evt_bp_slot_change_WUSB_0100);\r\nresult = 0;\r\nbreak;\r\ncase UWB_RC_EVT_DRP_AVAIL:\r\ncore_size = sizeof(struct uwb_rc_evt_drp_avail_WUSB_0100);\r\noffset = offsetof(struct uwb_rc_evt_drp_avail_WUSB_0100,\r\nwIELength);\r\nevent_size = hwarc_get_event_size(rc, rceb, core_size,\r\noffset, buf_size);\r\nif (event_size < 0)\r\ngoto out;\r\n*_real_size = event_size;\r\nresult = hwarc_filter_evt_drp_avail_WUSB_0100(\r\nrc, header, buf_size, _new_size);\r\nbreak;\r\ncase UWB_RC_EVT_DRP:\r\ncore_size = sizeof(struct uwb_rc_evt_drp_WUSB_0100);\r\noffset = offsetof(struct uwb_rc_evt_drp_WUSB_0100, wIELength);\r\nevent_size = hwarc_get_event_size(rc, rceb, core_size,\r\noffset, buf_size);\r\nif (event_size < 0)\r\ngoto out;\r\n*_real_size = event_size;\r\nresult = hwarc_filter_evt_drp_WUSB_0100(rc, header,\r\nbuf_size, _new_size);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nreturn result;\r\n}\r\nstatic\r\nint hwarc_filter_event(struct uwb_rc *rc, struct uwb_rceb **header,\r\nconst size_t buf_size, size_t *_real_size,\r\nsize_t *_new_size)\r\n{\r\nint result = -ENOANO;\r\nif (rc->version == 0x0100)\r\nresult = hwarc_filter_event_WUSB_0100(\r\nrc, header, buf_size, _real_size, _new_size);\r\nreturn result;\r\n}\r\nstatic\r\nint hwarc_cmd(struct uwb_rc *uwb_rc, const struct uwb_rccb *cmd, size_t cmd_size)\r\n{\r\nstruct hwarc *hwarc = uwb_rc->priv;\r\nreturn usb_control_msg(\r\nhwarc->usb_dev, usb_sndctrlpipe(hwarc->usb_dev, 0),\r\nWA_EXEC_RC_CMD, USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\r\n0, hwarc->usb_iface->cur_altsetting->desc.bInterfaceNumber,\r\n(void *) cmd, cmd_size, 100 );\r\n}\r\nstatic\r\nint hwarc_reset(struct uwb_rc *uwb_rc)\r\n{\r\nstruct hwarc *hwarc = uwb_rc->priv;\r\nint result;\r\nresult = usb_lock_device_for_reset(hwarc->usb_dev, NULL);\r\nif (result >= 0) {\r\nresult = usb_reset_device(hwarc->usb_dev);\r\nusb_unlock_device(hwarc->usb_dev);\r\n}\r\nreturn result;\r\n}\r\nstatic\r\nvoid hwarc_neep_cb(struct urb *urb)\r\n{\r\nstruct hwarc *hwarc = urb->context;\r\nstruct usb_interface *usb_iface = hwarc->usb_iface;\r\nstruct device *dev = &usb_iface->dev;\r\nint result;\r\nswitch (result = urb->status) {\r\ncase 0:\r\nuwb_rc_neh_grok(hwarc->uwb_rc, urb->transfer_buffer,\r\nurb->actual_length);\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ngoto out;\r\ncase -ESHUTDOWN:\r\ngoto out;\r\ndefault:\r\nif (edc_inc(&hwarc->neep_edc, EDC_MAX_ERRORS,\r\nEDC_ERROR_TIMEFRAME))\r\ngoto error_exceeded;\r\ndev_err(dev, "NEEP: URB error %d\n", urb->status);\r\n}\r\nresult = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (result < 0 && result != -ENODEV && result != -EPERM) {\r\ndev_err(dev, "NEEP: Can't resubmit URB (%d) resetting device\n",\r\nresult);\r\ngoto error;\r\n}\r\nout:\r\nreturn;\r\nerror_exceeded:\r\ndev_err(dev, "NEEP: URB max acceptable errors "\r\n"exceeded, resetting device\n");\r\nerror:\r\nuwb_rc_neh_error(hwarc->uwb_rc, result);\r\nuwb_rc_reset_all(hwarc->uwb_rc);\r\nreturn;\r\n}\r\nstatic void hwarc_init(struct hwarc *hwarc)\r\n{\r\nedc_init(&hwarc->neep_edc);\r\n}\r\nstatic int hwarc_neep_init(struct uwb_rc *rc)\r\n{\r\nstruct hwarc *hwarc = rc->priv;\r\nstruct usb_interface *iface = hwarc->usb_iface;\r\nstruct usb_device *usb_dev = interface_to_usbdev(iface);\r\nstruct device *dev = &iface->dev;\r\nint result;\r\nstruct usb_endpoint_descriptor *epd;\r\nepd = &iface->cur_altsetting->endpoint[0].desc;\r\nhwarc->rd_buffer = (void *) __get_free_page(GFP_KERNEL);\r\nif (hwarc->rd_buffer == NULL) {\r\ndev_err(dev, "Unable to allocate notification's read buffer\n");\r\ngoto error_rd_buffer;\r\n}\r\nhwarc->neep_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (hwarc->neep_urb == NULL)\r\ngoto error_urb_alloc;\r\nusb_fill_int_urb(hwarc->neep_urb, usb_dev,\r\nusb_rcvintpipe(usb_dev, epd->bEndpointAddress),\r\nhwarc->rd_buffer, PAGE_SIZE,\r\nhwarc_neep_cb, hwarc, epd->bInterval);\r\nresult = usb_submit_urb(hwarc->neep_urb, GFP_ATOMIC);\r\nif (result < 0) {\r\ndev_err(dev, "Cannot submit notification URB: %d\n", result);\r\ngoto error_neep_submit;\r\n}\r\nreturn 0;\r\nerror_neep_submit:\r\nusb_free_urb(hwarc->neep_urb);\r\nhwarc->neep_urb = NULL;\r\nerror_urb_alloc:\r\nfree_page((unsigned long)hwarc->rd_buffer);\r\nhwarc->rd_buffer = NULL;\r\nerror_rd_buffer:\r\nreturn -ENOMEM;\r\n}\r\nstatic void hwarc_neep_release(struct uwb_rc *rc)\r\n{\r\nstruct hwarc *hwarc = rc->priv;\r\nusb_kill_urb(hwarc->neep_urb);\r\nusb_free_urb(hwarc->neep_urb);\r\nhwarc->neep_urb = NULL;\r\nfree_page((unsigned long)hwarc->rd_buffer);\r\nhwarc->rd_buffer = NULL;\r\n}\r\nstatic int hwarc_get_version(struct uwb_rc *rc)\r\n{\r\nint result;\r\nstruct hwarc *hwarc = rc->priv;\r\nstruct uwb_rc_control_intf_class_desc *descr;\r\nstruct device *dev = &rc->uwb_dev.dev;\r\nstruct usb_device *usb_dev = hwarc->usb_dev;\r\nchar *itr;\r\nstruct usb_descriptor_header *hdr;\r\nsize_t itr_size, actconfig_idx;\r\nu16 version;\r\nactconfig_idx = (usb_dev->actconfig - usb_dev->config) /\r\nsizeof(usb_dev->config[0]);\r\nitr = usb_dev->rawdescriptors[actconfig_idx];\r\nitr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\r\nwhile (itr_size >= sizeof(*hdr)) {\r\nhdr = (struct usb_descriptor_header *) itr;\r\ndev_dbg(dev, "Extra device descriptor: "\r\n"type %02x/%u bytes @ %zu (%zu left)\n",\r\nhdr->bDescriptorType, hdr->bLength,\r\n(itr - usb_dev->rawdescriptors[actconfig_idx]),\r\nitr_size);\r\nif (hdr->bDescriptorType == USB_DT_CS_RADIO_CONTROL)\r\ngoto found;\r\nitr += hdr->bLength;\r\nitr_size -= hdr->bLength;\r\n}\r\ndev_err(dev, "cannot find Radio Control Interface Class descriptor\n");\r\nreturn -ENODEV;\r\nfound:\r\nresult = -EINVAL;\r\nif (hdr->bLength > itr_size) {\r\ndev_err(dev, "incomplete Radio Control Interface Class "\r\n"descriptor (%zu bytes left, %u needed)\n",\r\nitr_size, hdr->bLength);\r\ngoto error;\r\n}\r\nif (hdr->bLength < sizeof(*descr)) {\r\ndev_err(dev, "short Radio Control Interface Class "\r\n"descriptor\n");\r\ngoto error;\r\n}\r\ndescr = (struct uwb_rc_control_intf_class_desc *) hdr;\r\nversion = __le16_to_cpu(descr->bcdRCIVersion);\r\nif (version != 0x0100) {\r\ndev_err(dev, "Device reports protocol version 0x%04x. We "\r\n"do not support that. \n", version);\r\nresult = -EINVAL;\r\ngoto error;\r\n}\r\nrc->version = version;\r\ndev_dbg(dev, "Device supports WUSB protocol version 0x%04x \n", rc->version);\r\nresult = 0;\r\nerror:\r\nreturn result;\r\n}\r\nstatic int hwarc_probe(struct usb_interface *iface,\r\nconst struct usb_device_id *id)\r\n{\r\nint result;\r\nstruct uwb_rc *uwb_rc;\r\nstruct hwarc *hwarc;\r\nstruct device *dev = &iface->dev;\r\nif (iface->cur_altsetting->desc.bNumEndpoints < 1)\r\nreturn -ENODEV;\r\nresult = -ENOMEM;\r\nuwb_rc = uwb_rc_alloc();\r\nif (uwb_rc == NULL) {\r\ndev_err(dev, "unable to allocate RC instance\n");\r\ngoto error_rc_alloc;\r\n}\r\nhwarc = kzalloc(sizeof(*hwarc), GFP_KERNEL);\r\nif (hwarc == NULL) {\r\ndev_err(dev, "unable to allocate HWA RC instance\n");\r\ngoto error_alloc;\r\n}\r\nhwarc_init(hwarc);\r\nhwarc->usb_dev = usb_get_dev(interface_to_usbdev(iface));\r\nhwarc->usb_iface = usb_get_intf(iface);\r\nhwarc->uwb_rc = uwb_rc;\r\nuwb_rc->owner = THIS_MODULE;\r\nuwb_rc->start = hwarc_neep_init;\r\nuwb_rc->stop = hwarc_neep_release;\r\nuwb_rc->cmd = hwarc_cmd;\r\nuwb_rc->reset = hwarc_reset;\r\nif (id->driver_info & WUSB_QUIRK_WHCI_CMD_EVT) {\r\nuwb_rc->filter_cmd = NULL;\r\nuwb_rc->filter_event = NULL;\r\n} else {\r\nuwb_rc->filter_cmd = hwarc_filter_cmd;\r\nuwb_rc->filter_event = hwarc_filter_event;\r\n}\r\nresult = uwb_rc_add(uwb_rc, dev, hwarc);\r\nif (result < 0)\r\ngoto error_rc_add;\r\nresult = hwarc_get_version(uwb_rc);\r\nif (result < 0) {\r\ndev_err(dev, "cannot retrieve version of RC \n");\r\ngoto error_get_version;\r\n}\r\nusb_set_intfdata(iface, hwarc);\r\nreturn 0;\r\nerror_get_version:\r\nuwb_rc_rm(uwb_rc);\r\nerror_rc_add:\r\nusb_put_intf(iface);\r\nusb_put_dev(hwarc->usb_dev);\r\nerror_alloc:\r\nuwb_rc_put(uwb_rc);\r\nerror_rc_alloc:\r\nreturn result;\r\n}\r\nstatic void hwarc_disconnect(struct usb_interface *iface)\r\n{\r\nstruct hwarc *hwarc = usb_get_intfdata(iface);\r\nstruct uwb_rc *uwb_rc = hwarc->uwb_rc;\r\nusb_set_intfdata(hwarc->usb_iface, NULL);\r\nuwb_rc_rm(uwb_rc);\r\nusb_put_intf(hwarc->usb_iface);\r\nusb_put_dev(hwarc->usb_dev);\r\nkfree(hwarc);\r\nuwb_rc_put(uwb_rc);\r\n}\r\nstatic int hwarc_pre_reset(struct usb_interface *iface)\r\n{\r\nstruct hwarc *hwarc = usb_get_intfdata(iface);\r\nstruct uwb_rc *uwb_rc = hwarc->uwb_rc;\r\nuwb_rc_pre_reset(uwb_rc);\r\nreturn 0;\r\n}\r\nstatic int hwarc_post_reset(struct usb_interface *iface)\r\n{\r\nstruct hwarc *hwarc = usb_get_intfdata(iface);\r\nstruct uwb_rc *uwb_rc = hwarc->uwb_rc;\r\nreturn uwb_rc_post_reset(uwb_rc);\r\n}
