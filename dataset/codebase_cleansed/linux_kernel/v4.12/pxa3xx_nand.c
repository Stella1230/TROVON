static int pxa3xx_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint nchunks = mtd->writesize / info->chunk_size;\r\nif (section >= nchunks)\r\nreturn -ERANGE;\r\noobregion->offset = ((info->ecc_size + info->spare_size) * section) +\r\ninfo->spare_size;\r\noobregion->length = info->ecc_size;\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint nchunks = mtd->writesize / info->chunk_size;\r\nif (section >= nchunks)\r\nreturn -ERANGE;\r\nif (!info->spare_size)\r\nreturn 0;\r\noobregion->offset = section * (info->ecc_size + info->spare_size);\r\noobregion->length = info->spare_size;\r\nif (!section) {\r\nif (mtd->writesize == 4096 && info->chunk_size == 2048) {\r\noobregion->offset += 6;\r\noobregion->length -= 6;\r\n} else {\r\noobregion->offset += 2;\r\noobregion->length -= 2;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic enum pxa3xx_nand_variant\r\npxa3xx_nand_get_variant(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa3xx_nand_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn PXA3XX_NAND_VARIANT_PXA;\r\nreturn (enum pxa3xx_nand_variant)of_id->data;\r\n}\r\nstatic void pxa3xx_nand_set_timing(struct pxa3xx_nand_host *host,\r\nconst struct pxa3xx_nand_timing *t)\r\n{\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nunsigned long nand_clk = clk_get_rate(info->clk);\r\nuint32_t ndtr0, ndtr1;\r\nndtr0 = NDTR0_tCH(ns2cycle(t->tCH, nand_clk)) |\r\nNDTR0_tCS(ns2cycle(t->tCS, nand_clk)) |\r\nNDTR0_tWH(ns2cycle(t->tWH, nand_clk)) |\r\nNDTR0_tWP(ns2cycle(t->tWP, nand_clk)) |\r\nNDTR0_tRH(ns2cycle(t->tRH, nand_clk)) |\r\nNDTR0_tRP(ns2cycle(t->tRP, nand_clk));\r\nndtr1 = NDTR1_tR(ns2cycle(t->tR, nand_clk)) |\r\nNDTR1_tWHR(ns2cycle(t->tWHR, nand_clk)) |\r\nNDTR1_tAR(ns2cycle(t->tAR, nand_clk));\r\ninfo->ndtr0cs0 = ndtr0;\r\ninfo->ndtr1cs0 = ndtr1;\r\nnand_writel(info, NDTR0CS0, ndtr0);\r\nnand_writel(info, NDTR1CS0, ndtr1);\r\n}\r\nstatic void pxa3xx_nand_set_sdr_timing(struct pxa3xx_nand_host *host,\r\nconst struct nand_sdr_timings *t)\r\n{\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nstruct nand_chip *chip = &host->chip;\r\nunsigned long nand_clk = clk_get_rate(info->clk);\r\nuint32_t ndtr0, ndtr1;\r\nu32 tCH_min = DIV_ROUND_UP(t->tCH_min, 1000);\r\nu32 tCS_min = DIV_ROUND_UP(t->tCS_min, 1000);\r\nu32 tWH_min = DIV_ROUND_UP(t->tWH_min, 1000);\r\nu32 tWP_min = DIV_ROUND_UP(t->tWC_min - t->tWH_min, 1000);\r\nu32 tREH_min = DIV_ROUND_UP(t->tREH_min, 1000);\r\nu32 tRP_min = DIV_ROUND_UP(t->tRC_min - t->tREH_min, 1000);\r\nu32 tR = chip->chip_delay * 1000;\r\nu32 tWHR_min = DIV_ROUND_UP(t->tWHR_min, 1000);\r\nu32 tAR_min = DIV_ROUND_UP(t->tAR_min, 1000);\r\nif (!tR)\r\ntR = 20000;\r\nndtr0 = NDTR0_tCH(ns2cycle(tCH_min, nand_clk)) |\r\nNDTR0_tCS(ns2cycle(tCS_min, nand_clk)) |\r\nNDTR0_tWH(ns2cycle(tWH_min, nand_clk)) |\r\nNDTR0_tWP(ns2cycle(tWP_min, nand_clk)) |\r\nNDTR0_tRH(ns2cycle(tREH_min, nand_clk)) |\r\nNDTR0_tRP(ns2cycle(tRP_min, nand_clk));\r\nndtr1 = NDTR1_tR(ns2cycle(tR, nand_clk)) |\r\nNDTR1_tWHR(ns2cycle(tWHR_min, nand_clk)) |\r\nNDTR1_tAR(ns2cycle(tAR_min, nand_clk));\r\ninfo->ndtr0cs0 = ndtr0;\r\ninfo->ndtr1cs0 = ndtr1;\r\nnand_writel(info, NDTR0CS0, ndtr0);\r\nnand_writel(info, NDTR1CS0, ndtr1);\r\n}\r\nstatic int pxa3xx_nand_init_timings_compat(struct pxa3xx_nand_host *host,\r\nunsigned int *flash_width,\r\nunsigned int *dfc_width)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nconst struct pxa3xx_nand_flash *f = NULL;\r\nstruct mtd_info *mtd = nand_to_mtd(&host->chip);\r\nint i, id, ntypes;\r\nntypes = ARRAY_SIZE(builtin_flash_types);\r\nchip->cmdfunc(mtd, NAND_CMD_READID, 0x00, -1);\r\nid = chip->read_byte(mtd);\r\nid |= chip->read_byte(mtd) << 0x8;\r\nfor (i = 0; i < ntypes; i++) {\r\nf = &builtin_flash_types[i];\r\nif (f->chip_id == id)\r\nbreak;\r\n}\r\nif (i == ntypes) {\r\ndev_err(&info->pdev->dev, "Error: timings not found\n");\r\nreturn -EINVAL;\r\n}\r\npxa3xx_nand_set_timing(host, f->timing);\r\n*flash_width = f->flash_width;\r\n*dfc_width = f->dfc_width;\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_init_timings_onfi(struct pxa3xx_nand_host *host,\r\nint mode)\r\n{\r\nconst struct nand_sdr_timings *timings;\r\nmode = fls(mode) - 1;\r\nif (mode < 0)\r\nmode = 0;\r\ntimings = onfi_async_timing_mode_to_sdr_timings(mode);\r\nif (IS_ERR(timings))\r\nreturn PTR_ERR(timings);\r\npxa3xx_nand_set_sdr_timing(host, timings);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_init(struct pxa3xx_nand_host *host)\r\n{\r\nstruct nand_chip *chip = &host->chip;\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nunsigned int flash_width = 0, dfc_width = 0;\r\nint mode, err;\r\nmode = onfi_get_async_timing_mode(chip);\r\nif (mode == ONFI_TIMING_MODE_UNKNOWN) {\r\nerr = pxa3xx_nand_init_timings_compat(host, &flash_width,\r\n&dfc_width);\r\nif (err)\r\nreturn err;\r\nif (flash_width == 16) {\r\ninfo->reg_ndcr |= NDCR_DWIDTH_M;\r\nchip->options |= NAND_BUSWIDTH_16;\r\n}\r\ninfo->reg_ndcr |= (dfc_width == 16) ? NDCR_DWIDTH_C : 0;\r\n} else {\r\nerr = pxa3xx_nand_init_timings_onfi(host, mode);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pxa3xx_nand_start(struct pxa3xx_nand_info *info)\r\n{\r\nuint32_t ndcr;\r\nndcr = info->reg_ndcr;\r\nif (info->use_ecc) {\r\nndcr |= NDCR_ECC_EN;\r\nif (info->ecc_bch)\r\nnand_writel(info, NDECCCTRL, 0x1);\r\n} else {\r\nndcr &= ~NDCR_ECC_EN;\r\nif (info->ecc_bch)\r\nnand_writel(info, NDECCCTRL, 0x0);\r\n}\r\nif (info->use_dma)\r\nndcr |= NDCR_DMA_EN;\r\nelse\r\nndcr &= ~NDCR_DMA_EN;\r\nif (info->use_spare)\r\nndcr |= NDCR_SPARE_EN;\r\nelse\r\nndcr &= ~NDCR_SPARE_EN;\r\nndcr |= NDCR_ND_RUN;\r\nnand_writel(info, NDSR, NDSR_MASK);\r\nnand_writel(info, NDCR, 0);\r\nnand_writel(info, NDCR, ndcr);\r\n}\r\nstatic void pxa3xx_nand_stop(struct pxa3xx_nand_info *info)\r\n{\r\nuint32_t ndcr;\r\nint timeout = NAND_STOP_DELAY;\r\nndcr = nand_readl(info, NDCR);\r\nwhile ((ndcr & NDCR_ND_RUN) && (timeout-- > 0)) {\r\nndcr = nand_readl(info, NDCR);\r\nudelay(1);\r\n}\r\nif (timeout <= 0) {\r\nndcr &= ~NDCR_ND_RUN;\r\nnand_writel(info, NDCR, ndcr);\r\n}\r\nif (info->dma_chan)\r\ndmaengine_terminate_all(info->dma_chan);\r\nnand_writel(info, NDSR, NDSR_MASK);\r\n}\r\nstatic void __maybe_unused\r\nenable_int(struct pxa3xx_nand_info *info, uint32_t int_mask)\r\n{\r\nuint32_t ndcr;\r\nndcr = nand_readl(info, NDCR);\r\nnand_writel(info, NDCR, ndcr & ~int_mask);\r\n}\r\nstatic void disable_int(struct pxa3xx_nand_info *info, uint32_t int_mask)\r\n{\r\nuint32_t ndcr;\r\nndcr = nand_readl(info, NDCR);\r\nnand_writel(info, NDCR, ndcr | int_mask);\r\n}\r\nstatic void drain_fifo(struct pxa3xx_nand_info *info, void *data, int len)\r\n{\r\nif (info->ecc_bch) {\r\nu32 val;\r\nint ret;\r\nwhile (len > 8) {\r\nioread32_rep(info->mmio_base + NDDB, data, 8);\r\nret = readl_relaxed_poll_timeout(info->mmio_base + NDSR, val,\r\nval & NDSR_RDDREQ, 1000, 5000);\r\nif (ret) {\r\ndev_err(&info->pdev->dev,\r\n"Timeout on RDDREQ while draining the FIFO\n");\r\nreturn;\r\n}\r\ndata += 32;\r\nlen -= 8;\r\n}\r\n}\r\nioread32_rep(info->mmio_base + NDDB, data, len);\r\n}\r\nstatic void handle_data_pio(struct pxa3xx_nand_info *info)\r\n{\r\nswitch (info->state) {\r\ncase STATE_PIO_WRITING:\r\nif (info->step_chunk_size)\r\nwritesl(info->mmio_base + NDDB,\r\ninfo->data_buff + info->data_buff_pos,\r\nDIV_ROUND_UP(info->step_chunk_size, 4));\r\nif (info->step_spare_size)\r\nwritesl(info->mmio_base + NDDB,\r\ninfo->oob_buff + info->oob_buff_pos,\r\nDIV_ROUND_UP(info->step_spare_size, 4));\r\nbreak;\r\ncase STATE_PIO_READING:\r\nif (info->step_chunk_size)\r\ndrain_fifo(info,\r\ninfo->data_buff + info->data_buff_pos,\r\nDIV_ROUND_UP(info->step_chunk_size, 4));\r\nif (info->step_spare_size)\r\ndrain_fifo(info,\r\ninfo->oob_buff + info->oob_buff_pos,\r\nDIV_ROUND_UP(info->step_spare_size, 4));\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,\r\ninfo->state);\r\nBUG();\r\n}\r\ninfo->data_buff_pos += info->step_chunk_size;\r\ninfo->oob_buff_pos += info->step_spare_size;\r\n}\r\nstatic void pxa3xx_nand_data_dma_irq(void *data)\r\n{\r\nstruct pxa3xx_nand_info *info = data;\r\nstruct dma_tx_state state;\r\nenum dma_status status;\r\nstatus = dmaengine_tx_status(info->dma_chan, info->dma_cookie, &state);\r\nif (likely(status == DMA_COMPLETE)) {\r\ninfo->state = STATE_DMA_DONE;\r\n} else {\r\ndev_err(&info->pdev->dev, "DMA error on data channel\n");\r\ninfo->retcode = ERR_DMABUSERR;\r\n}\r\ndma_unmap_sg(info->dma_chan->device->dev, &info->sg, 1, info->dma_dir);\r\nnand_writel(info, NDSR, NDSR_WRDREQ | NDSR_RDDREQ);\r\nenable_int(info, NDCR_INT_MASK);\r\n}\r\nstatic void start_data_dma(struct pxa3xx_nand_info *info)\r\n{\r\nenum dma_transfer_direction direction;\r\nstruct dma_async_tx_descriptor *tx;\r\nswitch (info->state) {\r\ncase STATE_DMA_WRITING:\r\ninfo->dma_dir = DMA_TO_DEVICE;\r\ndirection = DMA_MEM_TO_DEV;\r\nbreak;\r\ncase STATE_DMA_READING:\r\ninfo->dma_dir = DMA_FROM_DEVICE;\r\ndirection = DMA_DEV_TO_MEM;\r\nbreak;\r\ndefault:\r\ndev_err(&info->pdev->dev, "%s: invalid state %d\n", __func__,\r\ninfo->state);\r\nBUG();\r\n}\r\ninfo->sg.length = info->chunk_size;\r\nif (info->use_spare)\r\ninfo->sg.length += info->spare_size + info->ecc_size;\r\ndma_map_sg(info->dma_chan->device->dev, &info->sg, 1, info->dma_dir);\r\ntx = dmaengine_prep_slave_sg(info->dma_chan, &info->sg, 1, direction,\r\nDMA_PREP_INTERRUPT);\r\nif (!tx) {\r\ndev_err(&info->pdev->dev, "prep_slave_sg() failed\n");\r\nreturn;\r\n}\r\ntx->callback = pxa3xx_nand_data_dma_irq;\r\ntx->callback_param = info;\r\ninfo->dma_cookie = dmaengine_submit(tx);\r\ndma_async_issue_pending(info->dma_chan);\r\ndev_dbg(&info->pdev->dev, "%s(dir=%d cookie=%x size=%u)\n",\r\n__func__, direction, info->dma_cookie, info->sg.length);\r\n}\r\nstatic irqreturn_t pxa3xx_nand_irq_thread(int irq, void *data)\r\n{\r\nstruct pxa3xx_nand_info *info = data;\r\nhandle_data_pio(info);\r\ninfo->state = STATE_CMD_DONE;\r\nnand_writel(info, NDSR, NDSR_WRDREQ | NDSR_RDDREQ);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pxa3xx_nand_irq(int irq, void *devid)\r\n{\r\nstruct pxa3xx_nand_info *info = devid;\r\nunsigned int status, is_completed = 0, is_ready = 0;\r\nunsigned int ready, cmd_done;\r\nirqreturn_t ret = IRQ_HANDLED;\r\nif (info->cs == 0) {\r\nready = NDSR_FLASH_RDY;\r\ncmd_done = NDSR_CS0_CMDD;\r\n} else {\r\nready = NDSR_RDY;\r\ncmd_done = NDSR_CS1_CMDD;\r\n}\r\nstatus = nand_readl(info, NDSR);\r\nif (status & NDSR_UNCORERR)\r\ninfo->retcode = ERR_UNCORERR;\r\nif (status & NDSR_CORERR) {\r\ninfo->retcode = ERR_CORERR;\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370 &&\r\ninfo->ecc_bch)\r\ninfo->ecc_err_cnt = NDSR_ERR_CNT(status);\r\nelse\r\ninfo->ecc_err_cnt = 1;\r\ninfo->max_bitflips = max_t(unsigned int,\r\ninfo->max_bitflips,\r\ninfo->ecc_err_cnt);\r\n}\r\nif (status & (NDSR_RDDREQ | NDSR_WRDREQ)) {\r\nif (info->use_dma) {\r\ndisable_int(info, NDCR_INT_MASK);\r\ninfo->state = (status & NDSR_RDDREQ) ?\r\nSTATE_DMA_READING : STATE_DMA_WRITING;\r\nstart_data_dma(info);\r\ngoto NORMAL_IRQ_EXIT;\r\n} else {\r\ninfo->state = (status & NDSR_RDDREQ) ?\r\nSTATE_PIO_READING : STATE_PIO_WRITING;\r\nret = IRQ_WAKE_THREAD;\r\ngoto NORMAL_IRQ_EXIT;\r\n}\r\n}\r\nif (status & cmd_done) {\r\ninfo->state = STATE_CMD_DONE;\r\nis_completed = 1;\r\n}\r\nif (status & ready) {\r\ninfo->state = STATE_READY;\r\nis_ready = 1;\r\n}\r\nnand_writel(info, NDSR, status);\r\nif (status & NDSR_WRCMDREQ) {\r\nstatus &= ~NDSR_WRCMDREQ;\r\ninfo->state = STATE_CMD_HANDLE;\r\nnand_writel(info, NDCB0, info->ndcb0);\r\nnand_writel(info, NDCB0, info->ndcb1);\r\nnand_writel(info, NDCB0, info->ndcb2);\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370)\r\nnand_writel(info, NDCB0, info->ndcb3);\r\n}\r\nif (is_completed)\r\ncomplete(&info->cmd_complete);\r\nif (is_ready)\r\ncomplete(&info->dev_ready);\r\nNORMAL_IRQ_EXIT:\r\nreturn ret;\r\n}\r\nstatic inline int is_buf_blank(uint8_t *buf, size_t len)\r\n{\r\nfor (; len > 0; len--)\r\nif (*buf++ != 0xff)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic void set_command_address(struct pxa3xx_nand_info *info,\r\nunsigned int page_size, uint16_t column, int page_addr)\r\n{\r\nif (page_size < PAGE_CHUNK_SIZE) {\r\ninfo->ndcb1 = ((page_addr & 0xFFFFFF) << 8)\r\n| (column & 0xFF);\r\ninfo->ndcb2 = 0;\r\n} else {\r\ninfo->ndcb1 = ((page_addr & 0xFFFF) << 16)\r\n| (column & 0xFFFF);\r\nif (page_addr & 0xFF0000)\r\ninfo->ndcb2 = (page_addr & 0xFF0000) >> 16;\r\nelse\r\ninfo->ndcb2 = 0;\r\n}\r\n}\r\nstatic void prepare_start_command(struct pxa3xx_nand_info *info, int command)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nstruct mtd_info *mtd = nand_to_mtd(&host->chip);\r\ninfo->buf_start = 0;\r\ninfo->buf_count = 0;\r\ninfo->data_buff_pos = 0;\r\ninfo->oob_buff_pos = 0;\r\ninfo->step_chunk_size = 0;\r\ninfo->step_spare_size = 0;\r\ninfo->cur_chunk = 0;\r\ninfo->use_ecc = 0;\r\ninfo->use_spare = 1;\r\ninfo->retcode = ERR_NONE;\r\ninfo->ecc_err_cnt = 0;\r\ninfo->ndcb3 = 0;\r\ninfo->need_wait = 0;\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_PAGEPROG:\r\ninfo->use_ecc = 1;\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\ninfo->use_spare = 0;\r\nbreak;\r\ndefault:\r\ninfo->ndcb1 = 0;\r\ninfo->ndcb2 = 0;\r\nbreak;\r\n}\r\nif (command == NAND_CMD_READ0 ||\r\ncommand == NAND_CMD_READOOB ||\r\ncommand == NAND_CMD_SEQIN) {\r\ninfo->buf_count = mtd->writesize + mtd->oobsize;\r\nmemset(info->data_buff, 0xFF, info->buf_count);\r\n}\r\n}\r\nstatic int prepare_set_command(struct pxa3xx_nand_info *info, int command,\r\nint ext_cmd_type, uint16_t column, int page_addr)\r\n{\r\nint addr_cycle, exec_cmd;\r\nstruct pxa3xx_nand_host *host;\r\nstruct mtd_info *mtd;\r\nhost = info->host[info->cs];\r\nmtd = nand_to_mtd(&host->chip);\r\naddr_cycle = 0;\r\nexec_cmd = 1;\r\nif (info->cs != 0)\r\ninfo->ndcb0 = NDCB0_CSEL;\r\nelse\r\ninfo->ndcb0 = 0;\r\nif (command == NAND_CMD_SEQIN)\r\nexec_cmd = 0;\r\naddr_cycle = NDCB0_ADDR_CYC(host->row_addr_cycles\r\n+ host->col_addr_cycles);\r\nswitch (command) {\r\ncase NAND_CMD_READOOB:\r\ncase NAND_CMD_READ0:\r\ninfo->buf_start = column;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0)\r\n| addr_cycle\r\n| NAND_CMD_READ0;\r\nif (command == NAND_CMD_READOOB)\r\ninfo->buf_start += mtd->writesize;\r\nif (info->cur_chunk < info->nfullchunks) {\r\ninfo->step_chunk_size = info->chunk_size;\r\ninfo->step_spare_size = info->spare_size;\r\n} else {\r\ninfo->step_chunk_size = info->last_chunk_size;\r\ninfo->step_spare_size = info->last_spare_size;\r\n}\r\nif (mtd->writesize == PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_DBC | (NAND_CMD_READSTART << 8);\r\n} else if (mtd->writesize > PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_DBC | (NAND_CMD_READSTART << 8)\r\n| NDCB0_LEN_OVRD\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type);\r\ninfo->ndcb3 = info->step_chunk_size +\r\ninfo->step_spare_size;\r\n}\r\nset_command_address(info, mtd->writesize, column, page_addr);\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\ninfo->buf_start = column;\r\nset_command_address(info, mtd->writesize, 0, page_addr);\r\nif (mtd->writesize > PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type)\r\n| addr_cycle\r\n| command;\r\nexec_cmd = 1;\r\n}\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\nif (is_buf_blank(info->data_buff,\r\n(mtd->writesize + mtd->oobsize))) {\r\nexec_cmd = 0;\r\nbreak;\r\n}\r\nif (info->cur_chunk < info->nfullchunks) {\r\ninfo->step_chunk_size = info->chunk_size;\r\ninfo->step_spare_size = info->spare_size;\r\n} else {\r\ninfo->step_chunk_size = info->last_chunk_size;\r\ninfo->step_spare_size = info->last_spare_size;\r\n}\r\nif (mtd->writesize > PAGE_CHUNK_SIZE) {\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_LEN_OVRD\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type);\r\ninfo->ndcb3 = info->step_chunk_size +\r\ninfo->step_spare_size;\r\nif (info->cur_chunk == info->ntotalchunks) {\r\ninfo->ndcb0 = NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_EXT_CMD_TYPE(ext_cmd_type)\r\n| command;\r\ninfo->ndcb1 = 0;\r\ninfo->ndcb2 = 0;\r\ninfo->ndcb3 = 0;\r\n}\r\n} else {\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0x1)\r\n| NDCB0_AUTO_RS\r\n| NDCB0_ST_ROW_EN\r\n| NDCB0_DBC\r\n| (NAND_CMD_PAGEPROG << 8)\r\n| NAND_CMD_SEQIN\r\n| addr_cycle;\r\n}\r\nbreak;\r\ncase NAND_CMD_PARAM:\r\ninfo->buf_count = INIT_BUFFER_SIZE;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(0)\r\n| NDCB0_ADDR_CYC(1)\r\n| NDCB0_LEN_OVRD\r\n| command;\r\ninfo->ndcb1 = (column & 0xFF);\r\ninfo->ndcb3 = INIT_BUFFER_SIZE;\r\ninfo->step_chunk_size = INIT_BUFFER_SIZE;\r\nbreak;\r\ncase NAND_CMD_READID:\r\ninfo->buf_count = READ_ID_BYTES;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(3)\r\n| NDCB0_ADDR_CYC(1)\r\n| command;\r\ninfo->ndcb1 = (column & 0xFF);\r\ninfo->step_chunk_size = 8;\r\nbreak;\r\ncase NAND_CMD_STATUS:\r\ninfo->buf_count = 1;\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(4)\r\n| NDCB0_ADDR_CYC(1)\r\n| command;\r\ninfo->step_chunk_size = 8;\r\nbreak;\r\ncase NAND_CMD_ERASE1:\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(2)\r\n| NDCB0_AUTO_RS\r\n| NDCB0_ADDR_CYC(3)\r\n| NDCB0_DBC\r\n| (NAND_CMD_ERASE2 << 8)\r\n| NAND_CMD_ERASE1;\r\ninfo->ndcb1 = page_addr;\r\ninfo->ndcb2 = 0;\r\nbreak;\r\ncase NAND_CMD_RESET:\r\ninfo->ndcb0 |= NDCB0_CMD_TYPE(5)\r\n| command;\r\nbreak;\r\ncase NAND_CMD_ERASE2:\r\nexec_cmd = 0;\r\nbreak;\r\ndefault:\r\nexec_cmd = 0;\r\ndev_err(&info->pdev->dev, "non-supported command %x\n",\r\ncommand);\r\nbreak;\r\n}\r\nreturn exec_cmd;\r\n}\r\nstatic void nand_cmdfunc(struct mtd_info *mtd, unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint exec_cmd;\r\nif (info->reg_ndcr & NDCR_DWIDTH_M)\r\ncolumn /= 2;\r\nif (info->cs != host->cs) {\r\ninfo->cs = host->cs;\r\nnand_writel(info, NDTR0CS0, info->ndtr0cs0);\r\nnand_writel(info, NDTR1CS0, info->ndtr1cs0);\r\n}\r\nprepare_start_command(info, command);\r\ninfo->state = STATE_PREPARED;\r\nexec_cmd = prepare_set_command(info, command, 0, column, page_addr);\r\nif (exec_cmd) {\r\ninit_completion(&info->cmd_complete);\r\ninit_completion(&info->dev_ready);\r\ninfo->need_wait = 1;\r\npxa3xx_nand_start(info);\r\nif (!wait_for_completion_timeout(&info->cmd_complete,\r\nCHIP_DELAY_TIMEOUT)) {\r\ndev_err(&info->pdev->dev, "Wait time out!!!\n");\r\npxa3xx_nand_stop(info);\r\n}\r\n}\r\ninfo->state = STATE_IDLE;\r\n}\r\nstatic void nand_cmdfunc_extended(struct mtd_info *mtd,\r\nconst unsigned command,\r\nint column, int page_addr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint exec_cmd, ext_cmd_type;\r\nif (info->reg_ndcr & NDCR_DWIDTH_M)\r\ncolumn /= 2;\r\nif (info->cs != host->cs) {\r\ninfo->cs = host->cs;\r\nnand_writel(info, NDTR0CS0, info->ndtr0cs0);\r\nnand_writel(info, NDTR1CS0, info->ndtr1cs0);\r\n}\r\nswitch (command) {\r\ncase NAND_CMD_READ0:\r\ncase NAND_CMD_READOOB:\r\next_cmd_type = EXT_CMD_TYPE_MONO;\r\nbreak;\r\ncase NAND_CMD_SEQIN:\r\next_cmd_type = EXT_CMD_TYPE_DISPATCH;\r\nbreak;\r\ncase NAND_CMD_PAGEPROG:\r\next_cmd_type = EXT_CMD_TYPE_NAKED_RW;\r\nbreak;\r\ndefault:\r\next_cmd_type = 0;\r\nbreak;\r\n}\r\nprepare_start_command(info, command);\r\ninfo->need_wait = 1;\r\ninit_completion(&info->dev_ready);\r\ndo {\r\ninfo->state = STATE_PREPARED;\r\nexec_cmd = prepare_set_command(info, command, ext_cmd_type,\r\ncolumn, page_addr);\r\nif (!exec_cmd) {\r\ninfo->need_wait = 0;\r\ncomplete(&info->dev_ready);\r\nbreak;\r\n}\r\ninit_completion(&info->cmd_complete);\r\npxa3xx_nand_start(info);\r\nif (!wait_for_completion_timeout(&info->cmd_complete,\r\nCHIP_DELAY_TIMEOUT)) {\r\ndev_err(&info->pdev->dev, "Wait time out!!!\n");\r\npxa3xx_nand_stop(info);\r\nbreak;\r\n}\r\nif (command != NAND_CMD_PAGEPROG &&\r\ncommand != NAND_CMD_READ0 &&\r\ncommand != NAND_CMD_READOOB)\r\nbreak;\r\ninfo->cur_chunk++;\r\nif (info->cur_chunk == info->ntotalchunks && command != NAND_CMD_PAGEPROG)\r\nbreak;\r\nif (info->cur_chunk == (info->ntotalchunks + 1) &&\r\ncommand == NAND_CMD_PAGEPROG &&\r\next_cmd_type == EXT_CMD_TYPE_DISPATCH)\r\nbreak;\r\nif (command == NAND_CMD_READ0 || command == NAND_CMD_READOOB) {\r\nif (info->cur_chunk == info->ntotalchunks - 1)\r\next_cmd_type = EXT_CMD_TYPE_LAST_RW;\r\nelse\r\next_cmd_type = EXT_CMD_TYPE_NAKED_RW;\r\n} else if (command == NAND_CMD_PAGEPROG &&\r\ninfo->cur_chunk == info->ntotalchunks) {\r\next_cmd_type = EXT_CMD_TYPE_DISPATCH;\r\n}\r\n} while (1);\r\ninfo->state = STATE_IDLE;\r\n}\r\nstatic int pxa3xx_nand_write_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, const uint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nchip->write_buf(mtd, buf, mtd->writesize);\r\nchip->write_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_read_page_hwecc(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nchip->read_buf(mtd, buf, mtd->writesize);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (info->retcode == ERR_CORERR && info->use_ecc) {\r\nmtd->ecc_stats.corrected += info->ecc_err_cnt;\r\n} else if (info->retcode == ERR_UNCORERR) {\r\nif (is_buf_blank(buf, mtd->writesize))\r\ninfo->retcode = ERR_NONE;\r\nelse\r\nmtd->ecc_stats.failed++;\r\n}\r\nreturn info->max_bitflips;\r\n}\r\nstatic uint8_t pxa3xx_nand_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nchar retval = 0xFF;\r\nif (info->buf_start < info->buf_count)\r\nretval = info->data_buff[info->buf_start++];\r\nreturn retval;\r\n}\r\nstatic u16 pxa3xx_nand_read_word(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nu16 retval = 0xFFFF;\r\nif (!(info->buf_start & 0x01) && info->buf_start < info->buf_count) {\r\nretval = *((u16 *)(info->data_buff+info->buf_start));\r\ninfo->buf_start += 2;\r\n}\r\nreturn retval;\r\n}\r\nstatic void pxa3xx_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint real_len = min_t(size_t, len, info->buf_count - info->buf_start);\r\nmemcpy(buf, info->data_buff + info->buf_start, real_len);\r\ninfo->buf_start += real_len;\r\n}\r\nstatic void pxa3xx_nand_write_buf(struct mtd_info *mtd,\r\nconst uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nint real_len = min_t(size_t, len, info->buf_count - info->buf_start);\r\nmemcpy(info->data_buff + info->buf_start, buf, real_len);\r\ninfo->buf_start += real_len;\r\n}\r\nstatic void pxa3xx_nand_select_chip(struct mtd_info *mtd, int chip)\r\n{\r\nreturn;\r\n}\r\nstatic int pxa3xx_nand_waitfunc(struct mtd_info *mtd, struct nand_chip *this)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nif (info->need_wait) {\r\ninfo->need_wait = 0;\r\nif (!wait_for_completion_timeout(&info->dev_ready,\r\nCHIP_DELAY_TIMEOUT)) {\r\ndev_err(&info->pdev->dev, "Ready time out!!!\n");\r\nreturn NAND_STATUS_FAIL;\r\n}\r\n}\r\nif (this->state == FL_WRITING || this->state == FL_ERASING) {\r\nif (info->retcode == ERR_NONE)\r\nreturn 0;\r\nelse\r\nreturn NAND_STATUS_FAIL;\r\n}\r\nreturn NAND_STATUS_READY;\r\n}\r\nstatic int pxa3xx_nand_config_ident(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nconst struct nand_sdr_timings *timings;\r\ninfo->chunk_size = PAGE_CHUNK_SIZE;\r\ninfo->reg_ndcr = 0x0;\r\ninfo->reg_ndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;\r\ninfo->reg_ndcr |= NDCR_RD_ID_CNT(READ_ID_BYTES);\r\ninfo->reg_ndcr |= NDCR_SPARE_EN;\r\ntimings = onfi_async_timing_mode_to_sdr_timings(0);\r\nif (IS_ERR(timings))\r\nreturn PTR_ERR(timings);\r\npxa3xx_nand_set_sdr_timing(host, timings);\r\nreturn 0;\r\n}\r\nstatic void pxa3xx_nand_config_tail(struct pxa3xx_nand_info *info)\r\n{\r\nstruct pxa3xx_nand_host *host = info->host[info->cs];\r\nstruct nand_chip *chip = &host->chip;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\ninfo->reg_ndcr |= (host->col_addr_cycles == 2) ? NDCR_RA_START : 0;\r\ninfo->reg_ndcr |= (chip->page_shift == 6) ? NDCR_PG_PER_BLK : 0;\r\ninfo->reg_ndcr |= (mtd->writesize == 2048) ? NDCR_PAGE_SZ : 0;\r\n}\r\nstatic void pxa3xx_nand_detect_config(struct pxa3xx_nand_info *info)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nuint32_t ndcr = nand_readl(info, NDCR);\r\ninfo->chunk_size = ndcr & NDCR_PAGE_SZ ? 2048 : 512;\r\ninfo->reg_ndcr = ndcr &\r\n~(NDCR_INT_MASK | NDCR_ND_ARB_EN | NFCV1_NDCR_ARB_CNTL);\r\ninfo->reg_ndcr |= (pdata->enable_arbiter) ? NDCR_ND_ARB_EN : 0;\r\ninfo->ndtr0cs0 = nand_readl(info, NDTR0CS0);\r\ninfo->ndtr1cs0 = nand_readl(info, NDTR1CS0);\r\n}\r\nstatic int pxa3xx_nand_init_buff(struct pxa3xx_nand_info *info)\r\n{\r\nstruct platform_device *pdev = info->pdev;\r\nstruct dma_slave_config config;\r\ndma_cap_mask_t mask;\r\nstruct pxad_param param;\r\nint ret;\r\ninfo->data_buff = kmalloc(info->buf_size, GFP_KERNEL);\r\nif (info->data_buff == NULL)\r\nreturn -ENOMEM;\r\nif (use_dma == 0)\r\nreturn 0;\r\nret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\r\nif (ret)\r\nreturn ret;\r\nsg_init_one(&info->sg, info->data_buff, info->buf_size);\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nparam.prio = PXAD_PRIO_LOWEST;\r\nparam.drcmr = info->drcmr_dat;\r\ninfo->dma_chan = dma_request_slave_channel_compat(mask, pxad_filter_fn,\r\n&param, &pdev->dev,\r\n"data");\r\nif (!info->dma_chan) {\r\ndev_err(&pdev->dev, "unable to request data dma channel\n");\r\nreturn -ENODEV;\r\n}\r\nmemset(&config, 0, sizeof(config));\r\nconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nconfig.src_addr = info->mmio_phys + NDDB;\r\nconfig.dst_addr = info->mmio_phys + NDDB;\r\nconfig.src_maxburst = 32;\r\nconfig.dst_maxburst = 32;\r\nret = dmaengine_slave_config(info->dma_chan, &config);\r\nif (ret < 0) {\r\ndev_err(&info->pdev->dev,\r\n"dma channel configuration failed: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ninfo->use_dma = 1;\r\nreturn 0;\r\n}\r\nstatic void pxa3xx_nand_free_buff(struct pxa3xx_nand_info *info)\r\n{\r\nif (info->use_dma) {\r\ndmaengine_terminate_all(info->dma_chan);\r\ndma_release_channel(info->dma_chan);\r\n}\r\nkfree(info->data_buff);\r\n}\r\nstatic int pxa_ecc_init(struct pxa3xx_nand_info *info,\r\nstruct mtd_info *mtd,\r\nint strength, int ecc_stepsize, int page_size)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nif (strength == 1 && ecc_stepsize == 512 && page_size == 2048) {\r\ninfo->nfullchunks = 1;\r\ninfo->ntotalchunks = 1;\r\ninfo->chunk_size = 2048;\r\ninfo->spare_size = 40;\r\ninfo->ecc_size = 24;\r\necc->mode = NAND_ECC_HW;\r\necc->size = 512;\r\necc->strength = 1;\r\n} else if (strength == 1 && ecc_stepsize == 512 && page_size == 512) {\r\ninfo->nfullchunks = 1;\r\ninfo->ntotalchunks = 1;\r\ninfo->chunk_size = 512;\r\ninfo->spare_size = 8;\r\ninfo->ecc_size = 8;\r\necc->mode = NAND_ECC_HW;\r\necc->size = 512;\r\necc->strength = 1;\r\n} else if (strength == 4 && ecc_stepsize == 512 && page_size == 2048) {\r\ninfo->ecc_bch = 1;\r\ninfo->nfullchunks = 1;\r\ninfo->ntotalchunks = 1;\r\ninfo->chunk_size = 2048;\r\ninfo->spare_size = 32;\r\ninfo->ecc_size = 32;\r\necc->mode = NAND_ECC_HW;\r\necc->size = info->chunk_size;\r\nmtd_set_ooblayout(mtd, &pxa3xx_ooblayout_ops);\r\necc->strength = 16;\r\n} else if (strength == 4 && ecc_stepsize == 512 && page_size == 4096) {\r\ninfo->ecc_bch = 1;\r\ninfo->nfullchunks = 2;\r\ninfo->ntotalchunks = 2;\r\ninfo->chunk_size = 2048;\r\ninfo->spare_size = 32;\r\ninfo->ecc_size = 32;\r\necc->mode = NAND_ECC_HW;\r\necc->size = info->chunk_size;\r\nmtd_set_ooblayout(mtd, &pxa3xx_ooblayout_ops);\r\necc->strength = 16;\r\n} else if (strength == 8 && ecc_stepsize == 512 && page_size == 4096) {\r\ninfo->ecc_bch = 1;\r\ninfo->nfullchunks = 4;\r\ninfo->ntotalchunks = 5;\r\ninfo->chunk_size = 1024;\r\ninfo->spare_size = 0;\r\ninfo->last_chunk_size = 0;\r\ninfo->last_spare_size = 64;\r\ninfo->ecc_size = 32;\r\necc->mode = NAND_ECC_HW;\r\necc->size = info->chunk_size;\r\nmtd_set_ooblayout(mtd, &pxa3xx_ooblayout_ops);\r\necc->strength = 16;\r\n} else {\r\ndev_err(&info->pdev->dev,\r\n"ECC strength %d at page size %d is not supported\n",\r\nstrength, page_size);\r\nreturn -ENODEV;\r\n}\r\ndev_info(&info->pdev->dev, "ECC strength %d, ECC step size %d\n",\r\necc->strength, ecc->size);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_scan(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct pxa3xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct pxa3xx_nand_info *info = host->info_data;\r\nstruct platform_device *pdev = info->pdev;\r\nstruct pxa3xx_nand_platform_data *pdata = dev_get_platdata(&pdev->dev);\r\nint ret;\r\nuint16_t ecc_strength, ecc_step;\r\nif (pdata->keep_config) {\r\npxa3xx_nand_detect_config(info);\r\n} else {\r\nret = pxa3xx_nand_config_ident(info);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (info->reg_ndcr & NDCR_DWIDTH_M)\r\nchip->options |= NAND_BUSWIDTH_16;\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370)\r\nnand_writel(info, NDECCCTRL, 0x0);\r\nif (pdata->flash_bbt)\r\nchip->bbt_options |= NAND_BBT_USE_FLASH;\r\nchip->ecc.strength = pdata->ecc_strength;\r\nchip->ecc.size = pdata->ecc_step_size;\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (ret)\r\nreturn ret;\r\nif (!pdata->keep_config) {\r\nret = pxa3xx_nand_init(host);\r\nif (ret) {\r\ndev_err(&info->pdev->dev, "Failed to init nand: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (chip->bbt_options & NAND_BBT_USE_FLASH) {\r\nchip->bbt_options |= NAND_BBT_NO_OOB_BBM;\r\nchip->bbt_td = &bbt_main_descr;\r\nchip->bbt_md = &bbt_mirror_descr;\r\n}\r\nif (mtd->writesize > PAGE_CHUNK_SIZE) {\r\nif (info->variant == PXA3XX_NAND_VARIANT_ARMADA370) {\r\nchip->cmdfunc = nand_cmdfunc_extended;\r\n} else {\r\ndev_err(&info->pdev->dev,\r\n"unsupported page size on this variant\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\necc_strength = chip->ecc.strength;\r\necc_step = chip->ecc.size;\r\nif (!ecc_strength || !ecc_step) {\r\necc_strength = chip->ecc_strength_ds;\r\necc_step = chip->ecc_step_ds;\r\n}\r\nif (ecc_strength < 1 && ecc_step < 1) {\r\necc_strength = 1;\r\necc_step = 512;\r\n}\r\nret = pxa_ecc_init(info, mtd, ecc_strength,\r\necc_step, mtd->writesize);\r\nif (ret)\r\nreturn ret;\r\nif (mtd->writesize >= 2048)\r\nhost->col_addr_cycles = 2;\r\nelse\r\nhost->col_addr_cycles = 1;\r\nkfree(info->data_buff);\r\ninfo->buf_size = mtd->writesize + mtd->oobsize;\r\nret = pxa3xx_nand_init_buff(info);\r\nif (ret)\r\nreturn ret;\r\ninfo->oob_buff = info->data_buff + mtd->writesize;\r\nif ((mtd->size >> chip->page_shift) > 65536)\r\nhost->row_addr_cycles = 3;\r\nelse\r\nhost->row_addr_cycles = 2;\r\nif (!pdata->keep_config)\r\npxa3xx_nand_config_tail(info);\r\nreturn nand_scan_tail(mtd);\r\n}\r\nstatic int alloc_nand_resource(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct pxa3xx_nand_info *info;\r\nstruct pxa3xx_nand_host *host;\r\nstruct nand_chip *chip = NULL;\r\nstruct mtd_info *mtd;\r\nstruct resource *r;\r\nint ret, irq, cs;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (pdata->num_cs <= 0) {\r\ndev_err(&pdev->dev, "invalid number of chip selects\n");\r\nreturn -ENODEV;\r\n}\r\ninfo = devm_kzalloc(&pdev->dev,\r\nsizeof(*info) + sizeof(*host) * pdata->num_cs,\r\nGFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->pdev = pdev;\r\ninfo->variant = pxa3xx_nand_get_variant(pdev);\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nhost = (void *)&info[1] + sizeof(*host) * cs;\r\nchip = &host->chip;\r\nnand_set_controller_data(chip, host);\r\nmtd = nand_to_mtd(chip);\r\ninfo->host[cs] = host;\r\nhost->cs = cs;\r\nhost->info_data = info;\r\nmtd->dev.parent = &pdev->dev;\r\nnand_set_flash_node(chip, np);\r\nnand_set_controller_data(chip, host);\r\nchip->ecc.read_page = pxa3xx_nand_read_page_hwecc;\r\nchip->ecc.write_page = pxa3xx_nand_write_page_hwecc;\r\nchip->controller = &info->controller;\r\nchip->waitfunc = pxa3xx_nand_waitfunc;\r\nchip->select_chip = pxa3xx_nand_select_chip;\r\nchip->read_word = pxa3xx_nand_read_word;\r\nchip->read_byte = pxa3xx_nand_read_byte;\r\nchip->read_buf = pxa3xx_nand_read_buf;\r\nchip->write_buf = pxa3xx_nand_write_buf;\r\nchip->options |= NAND_NO_SUBPAGE_WRITE;\r\nchip->cmdfunc = nand_cmdfunc;\r\n}\r\nnand_hw_control_init(chip->controller);\r\ninfo->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(info->clk)) {\r\nret = PTR_ERR(info->clk);\r\ndev_err(&pdev->dev, "failed to get nand clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(info->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!np && use_dma) {\r\nr = platform_get_resource(pdev, IORESOURCE_DMA, 0);\r\nif (r == NULL) {\r\ndev_err(&pdev->dev,\r\n"no resource defined for data DMA\n");\r\nret = -ENXIO;\r\ngoto fail_disable_clk;\r\n}\r\ninfo->drcmr_dat = r->start;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "no IRQ resource defined\n");\r\nret = -ENXIO;\r\ngoto fail_disable_clk;\r\n}\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ninfo->mmio_base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(info->mmio_base)) {\r\nret = PTR_ERR(info->mmio_base);\r\ndev_err(&pdev->dev, "failed to map register space: %d\n", ret);\r\ngoto fail_disable_clk;\r\n}\r\ninfo->mmio_phys = r->start;\r\ninfo->buf_size = INIT_BUFFER_SIZE;\r\ninfo->data_buff = kmalloc(info->buf_size, GFP_KERNEL);\r\nif (info->data_buff == NULL) {\r\nret = -ENOMEM;\r\ngoto fail_disable_clk;\r\n}\r\ndisable_int(info, NDSR_MASK);\r\nret = request_threaded_irq(irq, pxa3xx_nand_irq,\r\npxa3xx_nand_irq_thread, IRQF_ONESHOT,\r\npdev->name, info);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request IRQ: %d\n", ret);\r\ngoto fail_free_buf;\r\n}\r\nplatform_set_drvdata(pdev, info);\r\nreturn 0;\r\nfail_free_buf:\r\nfree_irq(irq, info);\r\nkfree(info->data_buff);\r\nfail_disable_clk:\r\nclk_disable_unprepare(info->clk);\r\nreturn ret;\r\n}\r\nstatic int pxa3xx_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_info *info = platform_get_drvdata(pdev);\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nint irq, cs;\r\nif (!info)\r\nreturn 0;\r\npdata = dev_get_platdata(&pdev->dev);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq >= 0)\r\nfree_irq(irq, info);\r\npxa3xx_nand_free_buff(info);\r\nnand_writel(info, NDCR,\r\n(nand_readl(info, NDCR) & ~NDCR_ND_ARB_EN) |\r\nNFCV1_NDCR_ARB_CNTL);\r\nclk_disable_unprepare(info->clk);\r\nfor (cs = 0; cs < pdata->num_cs; cs++)\r\nnand_release(nand_to_mtd(&info->host[cs]->chip));\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_probe_dt(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(pxa3xx_nand_dt_ids, &pdev->dev);\r\nif (!of_id)\r\nreturn 0;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nif (of_get_property(np, "marvell,nand-enable-arbiter", NULL))\r\npdata->enable_arbiter = 1;\r\nif (of_get_property(np, "marvell,nand-keep-config", NULL))\r\npdata->keep_config = 1;\r\nof_property_read_u32(np, "num-cs", &pdata->num_cs);\r\npdev->dev.platform_data = pdata;\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct pxa3xx_nand_platform_data *pdata;\r\nstruct pxa3xx_nand_info *info;\r\nint ret, cs, probe_success, dma_available;\r\ndma_available = IS_ENABLED(CONFIG_ARM) &&\r\n(IS_ENABLED(CONFIG_ARCH_PXA) || IS_ENABLED(CONFIG_ARCH_MMP));\r\nif (use_dma && !dma_available) {\r\nuse_dma = 0;\r\ndev_warn(&pdev->dev,\r\n"This platform can't do DMA on this device\n");\r\n}\r\nret = pxa3xx_nand_probe_dt(pdev);\r\nif (ret)\r\nreturn ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata) {\r\ndev_err(&pdev->dev, "no platform data defined\n");\r\nreturn -ENODEV;\r\n}\r\nret = alloc_nand_resource(pdev);\r\nif (ret)\r\nreturn ret;\r\ninfo = platform_get_drvdata(pdev);\r\nprobe_success = 0;\r\nfor (cs = 0; cs < pdata->num_cs; cs++) {\r\nstruct mtd_info *mtd = nand_to_mtd(&info->host[cs]->chip);\r\nmtd->name = "pxa3xx_nand-0";\r\ninfo->cs = cs;\r\nret = pxa3xx_nand_scan(mtd);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "failed to scan nand at cs %d\n",\r\ncs);\r\ncontinue;\r\n}\r\nret = mtd_device_register(mtd, pdata->parts[cs],\r\npdata->nr_parts[cs]);\r\nif (!ret)\r\nprobe_success = 1;\r\n}\r\nif (!probe_success) {\r\npxa3xx_nand_remove(pdev);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_suspend(struct device *dev)\r\n{\r\nstruct pxa3xx_nand_info *info = dev_get_drvdata(dev);\r\nif (info->state) {\r\ndev_err(dev, "driver busy, state = %d\n", info->state);\r\nreturn -EAGAIN;\r\n}\r\nclk_disable(info->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa3xx_nand_resume(struct device *dev)\r\n{\r\nstruct pxa3xx_nand_info *info = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_enable(info->clk);\r\nif (ret < 0)\r\nreturn ret;\r\ndisable_int(info, NDCR_INT_MASK);\r\ninfo->cs = 0xff;\r\nnand_writel(info, NDSR, NDSR_MASK);\r\nreturn 0;\r\n}
