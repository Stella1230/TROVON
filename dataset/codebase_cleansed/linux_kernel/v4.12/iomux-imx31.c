void mxc_iomux_mode(unsigned int pin_mode)\r\n{\r\nu32 field;\r\nu32 l;\r\nu32 mode;\r\nvoid __iomem *reg;\r\nreg = IOMUXSW_MUX_CTL + (pin_mode & IOMUX_REG_MASK);\r\nfield = pin_mode & 0x3;\r\nmode = (pin_mode & IOMUX_MODE_MASK) >> IOMUX_MODE_SHIFT;\r\nspin_lock(&gpio_mux_lock);\r\nl = imx_readl(reg);\r\nl &= ~(0xff << (field * 8));\r\nl |= mode << (field * 8);\r\nimx_writel(l, reg);\r\nspin_unlock(&gpio_mux_lock);\r\n}\r\nvoid mxc_iomux_set_pad(enum iomux_pins pin, u32 config)\r\n{\r\nu32 field, l;\r\nvoid __iomem *reg;\r\npin &= IOMUX_PADNUM_MASK;\r\nreg = IOMUXSW_PAD_CTL + (pin + 2) / 3 * 4;\r\nfield = (pin + 2) % 3;\r\npr_debug("%s: reg offset = 0x%x, field = %d\n",\r\n__func__, (pin + 2) / 3, field);\r\nspin_lock(&gpio_mux_lock);\r\nl = imx_readl(reg);\r\nl &= ~(0x1ff << (field * 10));\r\nl |= config << (field * 10);\r\nimx_writel(l, reg);\r\nspin_unlock(&gpio_mux_lock);\r\n}\r\nint mxc_iomux_alloc_pin(unsigned int pin, const char *label)\r\n{\r\nunsigned pad = pin & IOMUX_PADNUM_MASK;\r\nif (pad >= (PIN_MAX + 1)) {\r\nprintk(KERN_ERR "mxc_iomux: Attempt to request nonexistent pin %u for \"%s\"\n",\r\npad, label ? label : "?");\r\nreturn -EINVAL;\r\n}\r\nif (test_and_set_bit(pad, mxc_pin_alloc_map)) {\r\nprintk(KERN_ERR "mxc_iomux: pin %u already used. Allocation for \"%s\" failed\n",\r\npad, label ? label : "?");\r\nreturn -EBUSY;\r\n}\r\nmxc_iomux_mode(pin);\r\nreturn 0;\r\n}\r\nint mxc_iomux_setup_multiple_pins(const unsigned int *pin_list, unsigned count,\r\nconst char *label)\r\n{\r\nconst unsigned int *p = pin_list;\r\nint i;\r\nint ret = -EINVAL;\r\nfor (i = 0; i < count; i++) {\r\nret = mxc_iomux_alloc_pin(*p, label);\r\nif (ret)\r\ngoto setup_error;\r\np++;\r\n}\r\nreturn 0;\r\nsetup_error:\r\nmxc_iomux_release_multiple_pins(pin_list, i);\r\nreturn ret;\r\n}\r\nvoid mxc_iomux_release_pin(unsigned int pin)\r\n{\r\nunsigned pad = pin & IOMUX_PADNUM_MASK;\r\nif (pad < (PIN_MAX + 1))\r\nclear_bit(pad, mxc_pin_alloc_map);\r\n}\r\nvoid mxc_iomux_release_multiple_pins(const unsigned int *pin_list, int count)\r\n{\r\nconst unsigned int *p = pin_list;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nmxc_iomux_release_pin(*p);\r\np++;\r\n}\r\n}\r\nvoid mxc_iomux_set_gpr(enum iomux_gp_func gp, bool en)\r\n{\r\nu32 l;\r\nspin_lock(&gpio_mux_lock);\r\nl = imx_readl(IOMUXGPR);\r\nif (en)\r\nl |= gp;\r\nelse\r\nl &= ~gp;\r\nimx_writel(l, IOMUXGPR);\r\nspin_unlock(&gpio_mux_lock);\r\n}
