static irqreturn_t tps6521x_pb_irq(int irq, void *_pwr)\r\n{\r\nstruct tps6521x_pwrbutton *pwr = _pwr;\r\nconst struct tps6521x_data *tps_data = pwr->data;\r\nunsigned int reg;\r\nint error;\r\nerror = regmap_read(pwr->regmap, tps_data->reg_status, &reg);\r\nif (error) {\r\ndev_err(pwr->dev, "can't read register: %d\n", error);\r\ngoto out;\r\n}\r\nif (reg & tps_data->pb_mask) {\r\ninput_report_key(pwr->idev, KEY_POWER, 1);\r\npm_wakeup_event(pwr->dev, 0);\r\n} else {\r\ninput_report_key(pwr->idev, KEY_POWER, 0);\r\n}\r\ninput_sync(pwr->idev);\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int tps6521x_pb_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct tps6521x_pwrbutton *pwr;\r\nstruct input_dev *idev;\r\nconst struct of_device_id *match;\r\nint error;\r\nint irq;\r\nmatch = of_match_node(of_tps6521x_pb_match, dev->of_node);\r\nif (!match)\r\nreturn -ENXIO;\r\npwr = devm_kzalloc(dev, sizeof(*pwr), GFP_KERNEL);\r\nif (!pwr)\r\nreturn -ENOMEM;\r\npwr->data = match->data;\r\nidev = devm_input_allocate_device(dev);\r\nif (!idev)\r\nreturn -ENOMEM;\r\nidev->name = pwr->data->name;\r\nsnprintf(pwr->phys, sizeof(pwr->phys), "%s/input0",\r\npwr->data->name);\r\nidev->phys = pwr->phys;\r\nidev->dev.parent = dev;\r\nidev->id.bustype = BUS_I2C;\r\ninput_set_capability(idev, EV_KEY, KEY_POWER);\r\npwr->regmap = dev_get_regmap(dev->parent, NULL);\r\npwr->dev = dev;\r\npwr->idev = idev;\r\ndevice_init_wakeup(dev, true);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "No IRQ resource!\n");\r\nreturn -EINVAL;\r\n}\r\nerror = devm_request_threaded_irq(dev, irq, NULL, tps6521x_pb_irq,\r\nIRQF_TRIGGER_RISING |\r\nIRQF_TRIGGER_FALLING |\r\nIRQF_ONESHOT,\r\npwr->data->name, pwr);\r\nif (error) {\r\ndev_err(dev, "failed to request IRQ #%d: %d\n", irq, error);\r\nreturn error;\r\n}\r\nerror= input_register_device(idev);\r\nif (error) {\r\ndev_err(dev, "Can't register power button: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
