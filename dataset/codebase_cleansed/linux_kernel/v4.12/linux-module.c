int obd_ioctl_getdata(char **buf, int *len, void __user *arg)\r\n{\r\nstruct obd_ioctl_hdr hdr;\r\nstruct obd_ioctl_data *data;\r\nint err;\r\nint offset = 0;\r\nif (copy_from_user(&hdr, arg, sizeof(hdr)))\r\nreturn -EFAULT;\r\nif (hdr.ioc_version != OBD_IOCTL_VERSION) {\r\nCERROR("Version mismatch kernel (%x) vs application (%x)\n",\r\nOBD_IOCTL_VERSION, hdr.ioc_version);\r\nreturn -EINVAL;\r\n}\r\nif (hdr.ioc_len > OBD_MAX_IOCTL_BUFFER) {\r\nCERROR("User buffer len %d exceeds %d max buffer\n",\r\nhdr.ioc_len, OBD_MAX_IOCTL_BUFFER);\r\nreturn -EINVAL;\r\n}\r\nif (hdr.ioc_len < sizeof(struct obd_ioctl_data)) {\r\nCERROR("User buffer too small for ioctl (%d)\n", hdr.ioc_len);\r\nreturn -EINVAL;\r\n}\r\n*buf = libcfs_kvzalloc(hdr.ioc_len, GFP_NOFS);\r\nif (!*buf) {\r\nCERROR("Cannot allocate control buffer of len %d\n",\r\nhdr.ioc_len);\r\nreturn -EINVAL;\r\n}\r\n*len = hdr.ioc_len;\r\ndata = (struct obd_ioctl_data *)*buf;\r\nif (copy_from_user(*buf, arg, hdr.ioc_len)) {\r\nerr = -EFAULT;\r\ngoto free_buf;\r\n}\r\nif (hdr.ioc_len != data->ioc_len) {\r\nerr = -EINVAL;\r\ngoto free_buf;\r\n}\r\nif (obd_ioctl_is_invalid(data)) {\r\nCERROR("ioctl not correctly formatted\n");\r\nerr = -EINVAL;\r\ngoto free_buf;\r\n}\r\nif (data->ioc_inllen1) {\r\ndata->ioc_inlbuf1 = &data->ioc_bulk[0];\r\noffset += cfs_size_round(data->ioc_inllen1);\r\n}\r\nif (data->ioc_inllen2) {\r\ndata->ioc_inlbuf2 = &data->ioc_bulk[0] + offset;\r\noffset += cfs_size_round(data->ioc_inllen2);\r\n}\r\nif (data->ioc_inllen3) {\r\ndata->ioc_inlbuf3 = &data->ioc_bulk[0] + offset;\r\noffset += cfs_size_round(data->ioc_inllen3);\r\n}\r\nif (data->ioc_inllen4)\r\ndata->ioc_inlbuf4 = &data->ioc_bulk[0] + offset;\r\nreturn 0;\r\nfree_buf:\r\nkvfree(*buf);\r\nreturn err;\r\n}\r\nint obd_ioctl_popdata(void __user *arg, void *data, int len)\r\n{\r\nint err;\r\nerr = copy_to_user(arg, data, len) ? -EFAULT : 0;\r\nreturn err;\r\n}\r\nstatic int obd_class_open(struct inode *inode, struct file *file)\r\n{\r\ntry_module_get(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic int obd_class_release(struct inode *inode, struct file *file)\r\n{\r\nmodule_put(THIS_MODULE);\r\nreturn 0;\r\n}\r\nstatic long obd_class_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nint err = 0;\r\nif (!capable(CFS_CAP_SYS_ADMIN) && (cmd != OBD_IOC_PING_TARGET))\r\nreturn err = -EACCES;\r\nif ((cmd & 0xffffff00) == ((int)'T') << 8)\r\nreturn err = -ENOTTY;\r\nerr = class_handle_ioctl(cmd, (unsigned long)arg);\r\nreturn err;\r\n}\r\nstatic ssize_t version_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", LUSTRE_VERSION_STRING);\r\n}\r\nstatic ssize_t pinger_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn sprintf(buf, "%s\n", "on");\r\n}\r\nstatic ssize_t\r\nhealth_check_show(struct kobject *kobj, struct attribute *attr, char *buf)\r\n{\r\nbool healthy = true;\r\nint i;\r\nsize_t len = 0;\r\nif (libcfs_catastrophe)\r\nreturn sprintf(buf, "LBUG\n");\r\nread_lock(&obd_dev_lock);\r\nfor (i = 0; i < class_devno_max(); i++) {\r\nstruct obd_device *obd;\r\nobd = class_num2obd(i);\r\nif (!obd || !obd->obd_attached || !obd->obd_set_up)\r\ncontinue;\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nif (obd->obd_stopping)\r\ncontinue;\r\nclass_incref(obd, __func__, current);\r\nread_unlock(&obd_dev_lock);\r\nif (obd_health_check(NULL, obd))\r\nhealthy = false;\r\nclass_decref(obd, __func__, current);\r\nread_lock(&obd_dev_lock);\r\n}\r\nread_unlock(&obd_dev_lock);\r\nif (healthy)\r\nlen = sprintf(buf, "healthy\n");\r\nelse\r\nlen = sprintf(buf, "NOT HEALTHY\n");\r\nreturn len;\r\n}\r\nstatic ssize_t jobid_var_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", obd_jobid_var);\r\n}\r\nstatic ssize_t jobid_var_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nif (!count || count > JOBSTATS_JOBID_VAR_MAX_LEN)\r\nreturn -EINVAL;\r\nmemset(obd_jobid_var, 0, JOBSTATS_JOBID_VAR_MAX_LEN + 1);\r\nmemcpy(obd_jobid_var, buffer, count);\r\nif (obd_jobid_var[count - 1] == '\n')\r\nobd_jobid_var[count - 1] = 0;\r\nreturn count;\r\n}\r\nstatic ssize_t jobid_name_show(struct kobject *kobj, struct attribute *attr,\r\nchar *buf)\r\n{\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", obd_jobid_node);\r\n}\r\nstatic ssize_t jobid_name_store(struct kobject *kobj, struct attribute *attr,\r\nconst char *buffer,\r\nsize_t count)\r\n{\r\nif (!count || count > LUSTRE_JOBID_SIZE)\r\nreturn -EINVAL;\r\nmemcpy(obd_jobid_node, buffer, count);\r\nobd_jobid_node[count] = 0;\r\nif (obd_jobid_node[count - 1] == '\n')\r\nobd_jobid_node[count - 1] = 0;\r\nreturn count;\r\n}\r\nstatic void *obd_device_list_seq_start(struct seq_file *p, loff_t *pos)\r\n{\r\nif (*pos >= class_devno_max())\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic void obd_device_list_seq_stop(struct seq_file *p, void *v)\r\n{\r\n}\r\nstatic void *obd_device_list_seq_next(struct seq_file *p, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nif (*pos >= class_devno_max())\r\nreturn NULL;\r\nreturn pos;\r\n}\r\nstatic int obd_device_list_seq_show(struct seq_file *p, void *v)\r\n{\r\nloff_t index = *(loff_t *)v;\r\nstruct obd_device *obd = class_num2obd((int)index);\r\nchar *status;\r\nif (!obd)\r\nreturn 0;\r\nLASSERT(obd->obd_magic == OBD_DEVICE_MAGIC);\r\nif (obd->obd_stopping)\r\nstatus = "ST";\r\nelse if (obd->obd_inactive)\r\nstatus = "IN";\r\nelse if (obd->obd_set_up)\r\nstatus = "UP";\r\nelse if (obd->obd_attached)\r\nstatus = "AT";\r\nelse\r\nstatus = "--";\r\nseq_printf(p, "%3d %s %s %s %s %d\n",\r\n(int)index, status, obd->obd_type->typ_name,\r\nobd->obd_name, obd->obd_uuid.uuid,\r\natomic_read(&obd->obd_refcount));\r\nreturn 0;\r\n}\r\nstatic int obd_device_list_open(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq;\r\nint rc = seq_open(file, &obd_device_list_sops);\r\nif (rc)\r\nreturn rc;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\nreturn 0;\r\n}\r\nint class_procfs_init(void)\r\n{\r\nint rc = -ENOMEM;\r\nstruct dentry *file;\r\nlustre_kobj = kobject_create_and_add("lustre", fs_kobj);\r\nif (!lustre_kobj)\r\ngoto out;\r\nrc = sysfs_create_group(lustre_kobj, &lustre_attr_group);\r\nif (rc) {\r\nkobject_put(lustre_kobj);\r\ngoto out;\r\n}\r\ndebugfs_lustre_root = debugfs_create_dir("lustre", NULL);\r\nif (IS_ERR_OR_NULL(debugfs_lustre_root)) {\r\nrc = debugfs_lustre_root ? PTR_ERR(debugfs_lustre_root)\r\n: -ENOMEM;\r\ndebugfs_lustre_root = NULL;\r\nkobject_put(lustre_kobj);\r\ngoto out;\r\n}\r\nfile = debugfs_create_file("devices", 0444, debugfs_lustre_root, NULL,\r\n&obd_device_list_fops);\r\nif (IS_ERR_OR_NULL(file)) {\r\nrc = file ? PTR_ERR(file) : -ENOMEM;\r\nkobject_put(lustre_kobj);\r\ngoto out;\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint class_procfs_clean(void)\r\n{\r\ndebugfs_remove_recursive(debugfs_lustre_root);\r\ndebugfs_lustre_root = NULL;\r\nkobject_put(lustre_kobj);\r\nreturn 0;\r\n}
