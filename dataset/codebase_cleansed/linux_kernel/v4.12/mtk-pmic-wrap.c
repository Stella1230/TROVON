static u32 pwrap_readl(struct pmic_wrapper *wrp, enum pwrap_regs reg)\r\n{\r\nreturn readl(wrp->base + wrp->master->regs[reg]);\r\n}\r\nstatic void pwrap_writel(struct pmic_wrapper *wrp, u32 val, enum pwrap_regs reg)\r\n{\r\nwritel(val, wrp->base + wrp->master->regs[reg]);\r\n}\r\nstatic bool pwrap_is_fsm_idle(struct pmic_wrapper *wrp)\r\n{\r\nu32 val = pwrap_readl(wrp, PWRAP_WACS2_RDATA);\r\nreturn PWRAP_GET_WACS_FSM(val) == PWRAP_WACS_FSM_IDLE;\r\n}\r\nstatic bool pwrap_is_fsm_vldclr(struct pmic_wrapper *wrp)\r\n{\r\nu32 val = pwrap_readl(wrp, PWRAP_WACS2_RDATA);\r\nreturn PWRAP_GET_WACS_FSM(val) == PWRAP_WACS_FSM_WFVLDCLR;\r\n}\r\nstatic inline void pwrap_leave_fsm_vldclr(struct pmic_wrapper *wrp)\r\n{\r\nif (pwrap_is_fsm_vldclr(wrp))\r\npwrap_writel(wrp, 1, PWRAP_WACS2_VLDCLR);\r\n}\r\nstatic bool pwrap_is_sync_idle(struct pmic_wrapper *wrp)\r\n{\r\nreturn pwrap_readl(wrp, PWRAP_WACS2_RDATA) & PWRAP_STATE_SYNC_IDLE0;\r\n}\r\nstatic bool pwrap_is_fsm_idle_and_sync_idle(struct pmic_wrapper *wrp)\r\n{\r\nu32 val = pwrap_readl(wrp, PWRAP_WACS2_RDATA);\r\nreturn (PWRAP_GET_WACS_FSM(val) == PWRAP_WACS_FSM_IDLE) &&\r\n(val & PWRAP_STATE_SYNC_IDLE0);\r\n}\r\nstatic int pwrap_wait_for_state(struct pmic_wrapper *wrp,\r\nbool (*fp)(struct pmic_wrapper *))\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + usecs_to_jiffies(10000);\r\ndo {\r\nif (time_after(jiffies, timeout))\r\nreturn fp(wrp) ? 0 : -ETIMEDOUT;\r\nif (fp(wrp))\r\nreturn 0;\r\n} while (1);\r\n}\r\nstatic int pwrap_write(struct pmic_wrapper *wrp, u32 adr, u32 wdata)\r\n{\r\nint ret;\r\nret = pwrap_wait_for_state(wrp, pwrap_is_fsm_idle);\r\nif (ret) {\r\npwrap_leave_fsm_vldclr(wrp);\r\nreturn ret;\r\n}\r\npwrap_writel(wrp, (1 << 31) | ((adr >> 1) << 16) | wdata,\r\nPWRAP_WACS2_CMD);\r\nreturn 0;\r\n}\r\nstatic int pwrap_read(struct pmic_wrapper *wrp, u32 adr, u32 *rdata)\r\n{\r\nint ret;\r\nret = pwrap_wait_for_state(wrp, pwrap_is_fsm_idle);\r\nif (ret) {\r\npwrap_leave_fsm_vldclr(wrp);\r\nreturn ret;\r\n}\r\npwrap_writel(wrp, (adr >> 1) << 16, PWRAP_WACS2_CMD);\r\nret = pwrap_wait_for_state(wrp, pwrap_is_fsm_vldclr);\r\nif (ret)\r\nreturn ret;\r\n*rdata = PWRAP_GET_WACS_RDATA(pwrap_readl(wrp, PWRAP_WACS2_RDATA));\r\npwrap_writel(wrp, 1, PWRAP_WACS2_VLDCLR);\r\nreturn 0;\r\n}\r\nstatic int pwrap_regmap_read(void *context, u32 adr, u32 *rdata)\r\n{\r\nreturn pwrap_read(context, adr, rdata);\r\n}\r\nstatic int pwrap_regmap_write(void *context, u32 adr, u32 wdata)\r\n{\r\nreturn pwrap_write(context, adr, wdata);\r\n}\r\nstatic int pwrap_reset_spislave(struct pmic_wrapper *wrp)\r\n{\r\nint ret, i;\r\npwrap_writel(wrp, 0, PWRAP_HIPRIO_ARB_EN);\r\npwrap_writel(wrp, 0, PWRAP_WRAP_EN);\r\npwrap_writel(wrp, 1, PWRAP_MUX_SEL);\r\npwrap_writel(wrp, 1, PWRAP_MAN_EN);\r\npwrap_writel(wrp, 0, PWRAP_DIO_EN);\r\npwrap_writel(wrp, wrp->master->spi_w | PWRAP_MAN_CMD_OP_CSL,\r\nPWRAP_MAN_CMD);\r\npwrap_writel(wrp, wrp->master->spi_w | PWRAP_MAN_CMD_OP_OUTS,\r\nPWRAP_MAN_CMD);\r\npwrap_writel(wrp, wrp->master->spi_w | PWRAP_MAN_CMD_OP_CSH,\r\nPWRAP_MAN_CMD);\r\nfor (i = 0; i < 4; i++)\r\npwrap_writel(wrp, wrp->master->spi_w | PWRAP_MAN_CMD_OP_OUTS,\r\nPWRAP_MAN_CMD);\r\nret = pwrap_wait_for_state(wrp, pwrap_is_sync_idle);\r\nif (ret) {\r\ndev_err(wrp->dev, "%s fail, ret=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npwrap_writel(wrp, 0, PWRAP_MAN_EN);\r\npwrap_writel(wrp, 0, PWRAP_MUX_SEL);\r\nreturn 0;\r\n}\r\nstatic int pwrap_init_sidly(struct pmic_wrapper *wrp)\r\n{\r\nu32 rdata;\r\nu32 i;\r\nu32 pass = 0;\r\nsigned char dly[16] = {\r\n-1, 0, 1, 0, 2, -1, 1, 1, 3, -1, -1, -1, 3, -1, 2, 1\r\n};\r\nfor (i = 0; i < 4; i++) {\r\npwrap_writel(wrp, i, PWRAP_SIDLY);\r\npwrap_read(wrp, wrp->slave->dew_regs[PWRAP_DEW_READ_TEST],\r\n&rdata);\r\nif (rdata == PWRAP_DEW_READ_TEST_VAL) {\r\ndev_dbg(wrp->dev, "[Read Test] pass, SIDLY=%x\n", i);\r\npass |= 1 << i;\r\n}\r\n}\r\nif (dly[pass] < 0) {\r\ndev_err(wrp->dev, "sidly pass range 0x%x not continuous\n",\r\npass);\r\nreturn -EIO;\r\n}\r\npwrap_writel(wrp, dly[pass], PWRAP_SIDLY);\r\nreturn 0;\r\n}\r\nstatic int pwrap_mt8135_init_reg_clock(struct pmic_wrapper *wrp)\r\n{\r\npwrap_writel(wrp, 0x4, PWRAP_CSHEXT);\r\npwrap_writel(wrp, 0x0, PWRAP_CSHEXT_WRITE);\r\npwrap_writel(wrp, 0x4, PWRAP_CSHEXT_READ);\r\npwrap_writel(wrp, 0x0, PWRAP_CSLEXT_START);\r\npwrap_writel(wrp, 0x0, PWRAP_CSLEXT_END);\r\nreturn 0;\r\n}\r\nstatic int pwrap_mt8173_init_reg_clock(struct pmic_wrapper *wrp)\r\n{\r\npwrap_writel(wrp, 0x0, PWRAP_CSHEXT_WRITE);\r\npwrap_writel(wrp, 0x4, PWRAP_CSHEXT_READ);\r\npwrap_writel(wrp, 0x2, PWRAP_CSLEXT_START);\r\npwrap_writel(wrp, 0x2, PWRAP_CSLEXT_END);\r\nreturn 0;\r\n}\r\nstatic int pwrap_mt2701_init_reg_clock(struct pmic_wrapper *wrp)\r\n{\r\nswitch (wrp->slave->type) {\r\ncase PMIC_MT6397:\r\npwrap_writel(wrp, 0xc, PWRAP_RDDMY);\r\npwrap_writel(wrp, 0x4, PWRAP_CSHEXT_WRITE);\r\npwrap_writel(wrp, 0x0, PWRAP_CSHEXT_READ);\r\npwrap_writel(wrp, 0x2, PWRAP_CSLEXT_START);\r\npwrap_writel(wrp, 0x2, PWRAP_CSLEXT_END);\r\nbreak;\r\ncase PMIC_MT6323:\r\npwrap_writel(wrp, 0x8, PWRAP_RDDMY);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_RDDMY_NO],\r\n0x8);\r\npwrap_writel(wrp, 0x5, PWRAP_CSHEXT_WRITE);\r\npwrap_writel(wrp, 0x0, PWRAP_CSHEXT_READ);\r\npwrap_writel(wrp, 0x2, PWRAP_CSLEXT_START);\r\npwrap_writel(wrp, 0x2, PWRAP_CSLEXT_END);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool pwrap_is_cipher_ready(struct pmic_wrapper *wrp)\r\n{\r\nreturn pwrap_readl(wrp, PWRAP_CIPHER_RDY) & 1;\r\n}\r\nstatic bool pwrap_is_pmic_cipher_ready(struct pmic_wrapper *wrp)\r\n{\r\nu32 rdata;\r\nint ret;\r\nret = pwrap_read(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_RDY],\r\n&rdata);\r\nif (ret)\r\nreturn 0;\r\nreturn rdata == 1;\r\n}\r\nstatic int pwrap_init_cipher(struct pmic_wrapper *wrp)\r\n{\r\nint ret;\r\nu32 rdata;\r\npwrap_writel(wrp, 0x1, PWRAP_CIPHER_SWRST);\r\npwrap_writel(wrp, 0x0, PWRAP_CIPHER_SWRST);\r\npwrap_writel(wrp, 0x1, PWRAP_CIPHER_KEY_SEL);\r\npwrap_writel(wrp, 0x2, PWRAP_CIPHER_IV_SEL);\r\nswitch (wrp->master->type) {\r\ncase PWRAP_MT8135:\r\npwrap_writel(wrp, 1, PWRAP_CIPHER_LOAD);\r\npwrap_writel(wrp, 1, PWRAP_CIPHER_START);\r\nbreak;\r\ncase PWRAP_MT2701:\r\ncase PWRAP_MT8173:\r\npwrap_writel(wrp, 1, PWRAP_CIPHER_EN);\r\nbreak;\r\n}\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_SWRST], 0x1);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_SWRST], 0x0);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_KEY_SEL], 0x1);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_IV_SEL], 0x2);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_LOAD], 0x1);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_START], 0x1);\r\nswitch (wrp->slave->type) {\r\ncase PMIC_MT6397:\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_LOAD],\r\n0x1);\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_START],\r\n0x1);\r\nbreak;\r\ncase PMIC_MT6323:\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_EN],\r\n0x1);\r\nbreak;\r\n}\r\nret = pwrap_wait_for_state(wrp, pwrap_is_cipher_ready);\r\nif (ret) {\r\ndev_err(wrp->dev, "cipher data ready@AP fail, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nret = pwrap_wait_for_state(wrp, pwrap_is_pmic_cipher_ready);\r\nif (ret) {\r\ndev_err(wrp->dev, "timeout waiting for cipher data ready@PMIC\n");\r\nreturn ret;\r\n}\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CIPHER_MODE], 0x1);\r\nret = pwrap_wait_for_state(wrp, pwrap_is_fsm_idle_and_sync_idle);\r\nif (ret) {\r\ndev_err(wrp->dev, "cipher mode idle fail, ret=%d\n", ret);\r\nreturn ret;\r\n}\r\npwrap_writel(wrp, 1, PWRAP_CIPHER_MODE);\r\nif (pwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_WRITE_TEST],\r\nPWRAP_DEW_WRITE_TEST_VAL) ||\r\npwrap_read(wrp, wrp->slave->dew_regs[PWRAP_DEW_WRITE_TEST],\r\n&rdata) ||\r\n(rdata != PWRAP_DEW_WRITE_TEST_VAL)) {\r\ndev_err(wrp->dev, "rdata=0x%04X\n", rdata);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pwrap_mt8135_init_soc_specific(struct pmic_wrapper *wrp)\r\n{\r\npwrap_writel(wrp, 0x1, PWRAP_EVENT_IN_EN);\r\npwrap_writel(wrp, 0xffff, PWRAP_EVENT_DST_EN);\r\nwritel(0x7f, wrp->bridge_base + PWRAP_MT8135_BRIDGE_IORD_ARB_EN);\r\nwritel(0x1, wrp->bridge_base + PWRAP_MT8135_BRIDGE_WACS3_EN);\r\nwritel(0x1, wrp->bridge_base + PWRAP_MT8135_BRIDGE_WACS4_EN);\r\nwritel(0x1, wrp->bridge_base + PWRAP_MT8135_BRIDGE_WDT_UNIT);\r\nwritel(0xffff, wrp->bridge_base + PWRAP_MT8135_BRIDGE_WDT_SRC_EN);\r\nwritel(0x1, wrp->bridge_base + PWRAP_MT8135_BRIDGE_TIMER_EN);\r\nwritel(0x7ff, wrp->bridge_base + PWRAP_MT8135_BRIDGE_INT_EN);\r\nif (pwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_EVENT_OUT_EN],\r\n0x1) ||\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_EVENT_SRC_EN],\r\n0xffff)) {\r\ndev_err(wrp->dev, "enable dewrap fail\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pwrap_mt8173_init_soc_specific(struct pmic_wrapper *wrp)\r\n{\r\nif (pwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_EVENT_OUT_EN],\r\n0x1) ||\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_EVENT_SRC_EN],\r\n0xffff)) {\r\ndev_err(wrp->dev, "enable dewrap fail\n");\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pwrap_mt2701_init_soc_specific(struct pmic_wrapper *wrp)\r\n{\r\nswitch (wrp->slave->type) {\r\ncase PMIC_MT6323:\r\npwrap_writel(wrp, 0x076c, PWRAP_ADC_CMD_ADDR);\r\npwrap_writel(wrp, 0x8000, PWRAP_PWRAP_ADC_CMD);\r\npwrap_writel(wrp, 0x072c, PWRAP_ADC_RDY_ADDR);\r\npwrap_writel(wrp, 0x072e, PWRAP_ADC_RDATA_ADDR1);\r\npwrap_writel(wrp, 0x0730, PWRAP_ADC_RDATA_ADDR2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pwrap_init(struct pmic_wrapper *wrp)\r\n{\r\nint ret;\r\nu32 rdata;\r\nreset_control_reset(wrp->rstc);\r\nif (wrp->rstc_bridge)\r\nreset_control_reset(wrp->rstc_bridge);\r\nif (wrp->master->type == PWRAP_MT8173) {\r\npwrap_writel(wrp, 3, PWRAP_DCM_EN);\r\npwrap_writel(wrp, 0, PWRAP_DCM_DBC_PRD);\r\n}\r\nret = pwrap_reset_spislave(wrp);\r\nif (ret)\r\nreturn ret;\r\npwrap_writel(wrp, 1, PWRAP_WRAP_EN);\r\npwrap_writel(wrp, wrp->master->arb_en_all, PWRAP_HIPRIO_ARB_EN);\r\npwrap_writel(wrp, 1, PWRAP_WACS2_EN);\r\nret = wrp->master->init_reg_clock(wrp);\r\nif (ret)\r\nreturn ret;\r\nret = pwrap_init_sidly(wrp);\r\nif (ret)\r\nreturn ret;\r\npwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_DIO_EN], 1);\r\nret = pwrap_wait_for_state(wrp, pwrap_is_fsm_idle_and_sync_idle);\r\nif (ret) {\r\ndev_err(wrp->dev, "%s fail, ret=%d\n", __func__, ret);\r\nreturn ret;\r\n}\r\npwrap_writel(wrp, 1, PWRAP_DIO_EN);\r\npwrap_read(wrp, wrp->slave->dew_regs[PWRAP_DEW_READ_TEST], &rdata);\r\nif (rdata != PWRAP_DEW_READ_TEST_VAL) {\r\ndev_err(wrp->dev, "Read test failed after switch to DIO mode: 0x%04x != 0x%04x\n",\r\nPWRAP_DEW_READ_TEST_VAL, rdata);\r\nreturn -EFAULT;\r\n}\r\nret = pwrap_init_cipher(wrp);\r\nif (ret)\r\nreturn ret;\r\nif (pwrap_write(wrp, wrp->slave->dew_regs[PWRAP_DEW_CRC_EN], 0x1))\r\nreturn -EFAULT;\r\npwrap_writel(wrp, 0x1, PWRAP_CRC_EN);\r\npwrap_writel(wrp, 0x0, PWRAP_SIG_MODE);\r\npwrap_writel(wrp, wrp->slave->dew_regs[PWRAP_DEW_CRC_VAL],\r\nPWRAP_SIG_ADR);\r\npwrap_writel(wrp, wrp->master->arb_en_all, PWRAP_HIPRIO_ARB_EN);\r\nif (wrp->master->type == PWRAP_MT8135)\r\npwrap_writel(wrp, 0x7, PWRAP_RRARB_EN);\r\npwrap_writel(wrp, 0x1, PWRAP_WACS0_EN);\r\npwrap_writel(wrp, 0x1, PWRAP_WACS1_EN);\r\npwrap_writel(wrp, 0x1, PWRAP_WACS2_EN);\r\npwrap_writel(wrp, 0x5, PWRAP_STAUPD_PRD);\r\npwrap_writel(wrp, 0xff, PWRAP_STAUPD_GRPEN);\r\nif (wrp->master->init_soc_specific) {\r\nret = wrp->master->init_soc_specific(wrp);\r\nif (ret)\r\nreturn ret;\r\n}\r\npwrap_writel(wrp, 1, PWRAP_INIT_DONE2);\r\npwrap_writel(wrp, 1, PWRAP_INIT_DONE0);\r\npwrap_writel(wrp, 1, PWRAP_INIT_DONE1);\r\nif (wrp->master->has_bridge) {\r\nwritel(1, wrp->bridge_base + PWRAP_MT8135_BRIDGE_INIT_DONE3);\r\nwritel(1, wrp->bridge_base + PWRAP_MT8135_BRIDGE_INIT_DONE4);\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t pwrap_interrupt(int irqno, void *dev_id)\r\n{\r\nu32 rdata;\r\nstruct pmic_wrapper *wrp = dev_id;\r\nrdata = pwrap_readl(wrp, PWRAP_INT_FLG);\r\ndev_err(wrp->dev, "unexpected interrupt int=0x%x\n", rdata);\r\npwrap_writel(wrp, 0xffffffff, PWRAP_INT_CLR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pwrap_probe(struct platform_device *pdev)\r\n{\r\nint ret, irq;\r\nstruct pmic_wrapper *wrp;\r\nstruct device_node *np = pdev->dev.of_node;\r\nconst struct of_device_id *of_id =\r\nof_match_device(of_pwrap_match_tbl, &pdev->dev);\r\nconst struct of_device_id *of_slave_id = NULL;\r\nstruct resource *res;\r\nif (pdev->dev.of_node->child)\r\nof_slave_id = of_match_node(of_slave_match_tbl,\r\npdev->dev.of_node->child);\r\nif (!of_slave_id) {\r\ndev_dbg(&pdev->dev, "slave pmic should be defined in dts\n");\r\nreturn -EINVAL;\r\n}\r\nwrp = devm_kzalloc(&pdev->dev, sizeof(*wrp), GFP_KERNEL);\r\nif (!wrp)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, wrp);\r\nwrp->master = of_id->data;\r\nwrp->slave = of_slave_id->data;\r\nwrp->dev = &pdev->dev;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pwrap");\r\nwrp->base = devm_ioremap_resource(wrp->dev, res);\r\nif (IS_ERR(wrp->base))\r\nreturn PTR_ERR(wrp->base);\r\nwrp->rstc = devm_reset_control_get(wrp->dev, "pwrap");\r\nif (IS_ERR(wrp->rstc)) {\r\nret = PTR_ERR(wrp->rstc);\r\ndev_dbg(wrp->dev, "cannot get pwrap reset: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (wrp->master->has_bridge) {\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"pwrap-bridge");\r\nwrp->bridge_base = devm_ioremap_resource(wrp->dev, res);\r\nif (IS_ERR(wrp->bridge_base))\r\nreturn PTR_ERR(wrp->bridge_base);\r\nwrp->rstc_bridge = devm_reset_control_get(wrp->dev, "pwrap-bridge");\r\nif (IS_ERR(wrp->rstc_bridge)) {\r\nret = PTR_ERR(wrp->rstc_bridge);\r\ndev_dbg(wrp->dev, "cannot get pwrap-bridge reset: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nwrp->clk_spi = devm_clk_get(wrp->dev, "spi");\r\nif (IS_ERR(wrp->clk_spi)) {\r\ndev_dbg(wrp->dev, "failed to get clock: %ld\n", PTR_ERR(wrp->clk_spi));\r\nreturn PTR_ERR(wrp->clk_spi);\r\n}\r\nwrp->clk_wrap = devm_clk_get(wrp->dev, "wrap");\r\nif (IS_ERR(wrp->clk_wrap)) {\r\ndev_dbg(wrp->dev, "failed to get clock: %ld\n", PTR_ERR(wrp->clk_wrap));\r\nreturn PTR_ERR(wrp->clk_wrap);\r\n}\r\nret = clk_prepare_enable(wrp->clk_spi);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(wrp->clk_wrap);\r\nif (ret)\r\ngoto err_out1;\r\npwrap_writel(wrp, 1, PWRAP_DCM_EN);\r\npwrap_writel(wrp, 0, PWRAP_DCM_DBC_PRD);\r\nif (!pwrap_readl(wrp, PWRAP_INIT_DONE2)) {\r\nret = pwrap_init(wrp);\r\nif (ret) {\r\ndev_dbg(wrp->dev, "init failed with %d\n", ret);\r\ngoto err_out2;\r\n}\r\n}\r\nif (!(pwrap_readl(wrp, PWRAP_WACS2_RDATA) & PWRAP_STATE_INIT_DONE0)) {\r\ndev_dbg(wrp->dev, "initialization isn't finished\n");\r\nreturn -ENODEV;\r\n}\r\npwrap_writel(wrp, 0xf, PWRAP_WDT_UNIT);\r\npwrap_writel(wrp, wrp->master->wdt_src, PWRAP_WDT_SRC_EN);\r\npwrap_writel(wrp, 0x1, PWRAP_TIMER_EN);\r\npwrap_writel(wrp, wrp->master->int_en_all, PWRAP_INT_EN);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(wrp->dev, irq, pwrap_interrupt, IRQF_TRIGGER_HIGH,\r\n"mt-pmic-pwrap", wrp);\r\nif (ret)\r\ngoto err_out2;\r\nwrp->regmap = devm_regmap_init(wrp->dev, NULL, wrp, &pwrap_regmap_config);\r\nif (IS_ERR(wrp->regmap))\r\nreturn PTR_ERR(wrp->regmap);\r\nret = of_platform_populate(np, NULL, NULL, wrp->dev);\r\nif (ret) {\r\ndev_dbg(wrp->dev, "failed to create child devices at %s\n",\r\nnp->full_name);\r\ngoto err_out2;\r\n}\r\nreturn 0;\r\nerr_out2:\r\nclk_disable_unprepare(wrp->clk_wrap);\r\nerr_out1:\r\nclk_disable_unprepare(wrp->clk_spi);\r\nreturn ret;\r\n}
