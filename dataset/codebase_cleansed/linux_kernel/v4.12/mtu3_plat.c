int ssusb_check_clocks(struct ssusb_mtk *ssusb, u32 ex_clks)\r\n{\r\nvoid __iomem *ibase = ssusb->ippc_base;\r\nu32 value, check_val;\r\nint ret;\r\ncheck_val = ex_clks | SSUSB_SYS125_RST_B_STS | SSUSB_SYSPLL_STABLE |\r\nSSUSB_REF_RST_B_STS;\r\nret = readl_poll_timeout(ibase + U3D_SSUSB_IP_PW_STS1, value,\r\n(check_val == (value & check_val)), 100, 20000);\r\nif (ret) {\r\ndev_err(ssusb->dev, "clks of sts1 are not stable!\n");\r\nreturn ret;\r\n}\r\nret = readl_poll_timeout(ibase + U3D_SSUSB_IP_PW_STS2, value,\r\n(value & SSUSB_U2_MAC_SYS_RST_B_STS), 100, 10000);\r\nif (ret) {\r\ndev_err(ssusb->dev, "mac2 clock is not stable\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssusb_phy_init(struct ssusb_mtk *ssusb)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < ssusb->num_phys; i++) {\r\nret = phy_init(ssusb->phys[i]);\r\nif (ret)\r\ngoto exit_phy;\r\n}\r\nreturn 0;\r\nexit_phy:\r\nfor (; i > 0; i--)\r\nphy_exit(ssusb->phys[i - 1]);\r\nreturn ret;\r\n}\r\nstatic int ssusb_phy_exit(struct ssusb_mtk *ssusb)\r\n{\r\nint i;\r\nfor (i = 0; i < ssusb->num_phys; i++)\r\nphy_exit(ssusb->phys[i]);\r\nreturn 0;\r\n}\r\nstatic int ssusb_phy_power_on(struct ssusb_mtk *ssusb)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < ssusb->num_phys; i++) {\r\nret = phy_power_on(ssusb->phys[i]);\r\nif (ret)\r\ngoto power_off_phy;\r\n}\r\nreturn 0;\r\npower_off_phy:\r\nfor (; i > 0; i--)\r\nphy_power_off(ssusb->phys[i - 1]);\r\nreturn ret;\r\n}\r\nstatic void ssusb_phy_power_off(struct ssusb_mtk *ssusb)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ssusb->num_phys; i++)\r\nphy_power_off(ssusb->phys[i]);\r\n}\r\nstatic int ssusb_rscs_init(struct ssusb_mtk *ssusb)\r\n{\r\nint ret = 0;\r\nret = regulator_enable(ssusb->vusb33);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to enable vusb33\n");\r\ngoto vusb33_err;\r\n}\r\nret = clk_prepare_enable(ssusb->sys_clk);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to enable sys_clk\n");\r\ngoto sys_clk_err;\r\n}\r\nret = clk_prepare_enable(ssusb->ref_clk);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to enable ref_clk\n");\r\ngoto ref_clk_err;\r\n}\r\nret = ssusb_phy_init(ssusb);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to init phy\n");\r\ngoto phy_init_err;\r\n}\r\nret = ssusb_phy_power_on(ssusb);\r\nif (ret) {\r\ndev_err(ssusb->dev, "failed to power on phy\n");\r\ngoto phy_err;\r\n}\r\nreturn 0;\r\nphy_err:\r\nssusb_phy_exit(ssusb);\r\nphy_init_err:\r\nclk_disable_unprepare(ssusb->ref_clk);\r\nref_clk_err:\r\nclk_disable_unprepare(ssusb->sys_clk);\r\nsys_clk_err:\r\nregulator_disable(ssusb->vusb33);\r\nvusb33_err:\r\nreturn ret;\r\n}\r\nstatic void ssusb_rscs_exit(struct ssusb_mtk *ssusb)\r\n{\r\nclk_disable_unprepare(ssusb->sys_clk);\r\nclk_disable_unprepare(ssusb->ref_clk);\r\nregulator_disable(ssusb->vusb33);\r\nssusb_phy_power_off(ssusb);\r\nssusb_phy_exit(ssusb);\r\n}\r\nstatic void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb)\r\n{\r\nmtu3_setbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);\r\nudelay(1);\r\nmtu3_clrbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);\r\n}\r\nstatic int get_iddig_pinctrl(struct ssusb_mtk *ssusb)\r\n{\r\nstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\r\notg_sx->id_pinctrl = devm_pinctrl_get(ssusb->dev);\r\nif (IS_ERR(otg_sx->id_pinctrl)) {\r\ndev_err(ssusb->dev, "Cannot find id pinctrl!\n");\r\nreturn PTR_ERR(otg_sx->id_pinctrl);\r\n}\r\notg_sx->id_float =\r\npinctrl_lookup_state(otg_sx->id_pinctrl, "id_float");\r\nif (IS_ERR(otg_sx->id_float)) {\r\ndev_err(ssusb->dev, "Cannot find pinctrl id_float!\n");\r\nreturn PTR_ERR(otg_sx->id_float);\r\n}\r\notg_sx->id_ground =\r\npinctrl_lookup_state(otg_sx->id_pinctrl, "id_ground");\r\nif (IS_ERR(otg_sx->id_ground)) {\r\ndev_err(ssusb->dev, "Cannot find pinctrl id_ground!\n");\r\nreturn PTR_ERR(otg_sx->id_ground);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\r\nstruct device *dev = &pdev->dev;\r\nstruct regulator *vbus;\r\nstruct resource *res;\r\nint i;\r\nint ret;\r\nssusb->vusb33 = devm_regulator_get(&pdev->dev, "vusb33");\r\nif (IS_ERR(ssusb->vusb33)) {\r\ndev_err(dev, "failed to get vusb33\n");\r\nreturn PTR_ERR(ssusb->vusb33);\r\n}\r\nssusb->sys_clk = devm_clk_get(dev, "sys_ck");\r\nif (IS_ERR(ssusb->sys_clk)) {\r\ndev_err(dev, "failed to get sys clock\n");\r\nreturn PTR_ERR(ssusb->sys_clk);\r\n}\r\nssusb->ref_clk = devm_clk_get(dev, "ref_ck");\r\nif (IS_ERR(ssusb->ref_clk)) {\r\nif (PTR_ERR(ssusb->ref_clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nssusb->ref_clk = NULL;\r\n}\r\nssusb->num_phys = of_count_phandle_with_args(node,\r\n"phys", "#phy-cells");\r\nif (ssusb->num_phys > 0) {\r\nssusb->phys = devm_kcalloc(dev, ssusb->num_phys,\r\nsizeof(*ssusb->phys), GFP_KERNEL);\r\nif (!ssusb->phys)\r\nreturn -ENOMEM;\r\n} else {\r\nssusb->num_phys = 0;\r\n}\r\nfor (i = 0; i < ssusb->num_phys; i++) {\r\nssusb->phys[i] = devm_of_phy_get_by_index(dev, node, i);\r\nif (IS_ERR(ssusb->phys[i])) {\r\ndev_err(dev, "failed to get phy-%d\n", i);\r\nreturn PTR_ERR(ssusb->phys[i]);\r\n}\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ippc");\r\nssusb->ippc_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ssusb->ippc_base))\r\nreturn PTR_ERR(ssusb->ippc_base);\r\nssusb->dr_mode = usb_get_dr_mode(dev);\r\nif (ssusb->dr_mode == USB_DR_MODE_UNKNOWN) {\r\ndev_err(dev, "dr_mode is error\n");\r\nreturn -EINVAL;\r\n}\r\nif (ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)\r\nreturn 0;\r\nret = ssusb_wakeup_of_property_parse(ssusb, node);\r\nif (ret)\r\nreturn ret;\r\nif (ssusb->dr_mode != USB_DR_MODE_OTG)\r\nreturn 0;\r\nvbus = devm_regulator_get(&pdev->dev, "vbus");\r\nif (IS_ERR(vbus)) {\r\ndev_err(dev, "failed to get vbus\n");\r\nreturn PTR_ERR(vbus);\r\n}\r\notg_sx->vbus = vbus;\r\notg_sx->is_u3_drd = of_property_read_bool(node, "mediatek,usb3-drd");\r\notg_sx->manual_drd_enabled =\r\nof_property_read_bool(node, "enable-manual-drd");\r\nif (of_property_read_bool(node, "extcon")) {\r\notg_sx->edev = extcon_get_edev_by_phandle(ssusb->dev, 0);\r\nif (IS_ERR(otg_sx->edev)) {\r\ndev_err(ssusb->dev, "couldn't get extcon device\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nif (otg_sx->manual_drd_enabled) {\r\nret = get_iddig_pinctrl(ssusb);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\ndev_info(dev, "dr_mode: %d, is_u3_dr: %d\n",\r\nssusb->dr_mode, otg_sx->is_u3_drd);\r\nreturn 0;\r\n}\r\nstatic int mtu3_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct ssusb_mtk *ssusb;\r\nint ret = -ENOMEM;\r\nssusb = devm_kzalloc(dev, sizeof(*ssusb), GFP_KERNEL);\r\nif (!ssusb)\r\nreturn -ENOMEM;\r\nret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(dev, "No suitable DMA config available\n");\r\nreturn -ENOTSUPP;\r\n}\r\nplatform_set_drvdata(pdev, ssusb);\r\nssusb->dev = dev;\r\nret = get_ssusb_rscs(pdev, ssusb);\r\nif (ret)\r\nreturn ret;\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\ndevice_enable_async_suspend(dev);\r\nret = ssusb_rscs_init(ssusb);\r\nif (ret)\r\ngoto comm_init_err;\r\nssusb_ip_sw_reset(ssusb);\r\nif (IS_ENABLED(CONFIG_USB_MTU3_HOST))\r\nssusb->dr_mode = USB_DR_MODE_HOST;\r\nelse if (IS_ENABLED(CONFIG_USB_MTU3_GADGET))\r\nssusb->dr_mode = USB_DR_MODE_PERIPHERAL;\r\nssusb->is_host = !(ssusb->dr_mode == USB_DR_MODE_PERIPHERAL);\r\nswitch (ssusb->dr_mode) {\r\ncase USB_DR_MODE_PERIPHERAL:\r\nret = ssusb_gadget_init(ssusb);\r\nif (ret) {\r\ndev_err(dev, "failed to initialize gadget\n");\r\ngoto comm_exit;\r\n}\r\nbreak;\r\ncase USB_DR_MODE_HOST:\r\nret = ssusb_host_init(ssusb, node);\r\nif (ret) {\r\ndev_err(dev, "failed to initialize host\n");\r\ngoto comm_exit;\r\n}\r\nbreak;\r\ncase USB_DR_MODE_OTG:\r\nret = ssusb_gadget_init(ssusb);\r\nif (ret) {\r\ndev_err(dev, "failed to initialize gadget\n");\r\ngoto comm_exit;\r\n}\r\nret = ssusb_host_init(ssusb, node);\r\nif (ret) {\r\ndev_err(dev, "failed to initialize host\n");\r\ngoto gadget_exit;\r\n}\r\nssusb_otg_switch_init(ssusb);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "unsupported mode: %d\n", ssusb->dr_mode);\r\nret = -EINVAL;\r\ngoto comm_exit;\r\n}\r\nreturn 0;\r\ngadget_exit:\r\nssusb_gadget_exit(ssusb);\r\ncomm_exit:\r\nssusb_rscs_exit(ssusb);\r\ncomm_init_err:\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int mtu3_remove(struct platform_device *pdev)\r\n{\r\nstruct ssusb_mtk *ssusb = platform_get_drvdata(pdev);\r\nswitch (ssusb->dr_mode) {\r\ncase USB_DR_MODE_PERIPHERAL:\r\nssusb_gadget_exit(ssusb);\r\nbreak;\r\ncase USB_DR_MODE_HOST:\r\nssusb_host_exit(ssusb);\r\nbreak;\r\ncase USB_DR_MODE_OTG:\r\nssusb_otg_switch_exit(ssusb);\r\nssusb_gadget_exit(ssusb);\r\nssusb_host_exit(ssusb);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nssusb_rscs_exit(ssusb);\r\npm_runtime_put_sync(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mtu3_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ssusb_mtk *ssusb = platform_get_drvdata(pdev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (!ssusb->is_host)\r\nreturn 0;\r\nssusb_host_disable(ssusb, true);\r\nssusb_phy_power_off(ssusb);\r\nclk_disable_unprepare(ssusb->sys_clk);\r\nclk_disable_unprepare(ssusb->ref_clk);\r\nssusb_wakeup_enable(ssusb);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mtu3_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct ssusb_mtk *ssusb = platform_get_drvdata(pdev);\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (!ssusb->is_host)\r\nreturn 0;\r\nssusb_wakeup_disable(ssusb);\r\nclk_prepare_enable(ssusb->sys_clk);\r\nclk_prepare_enable(ssusb->ref_clk);\r\nssusb_phy_power_on(ssusb);\r\nssusb_host_enable(ssusb);\r\nreturn 0;\r\n}
