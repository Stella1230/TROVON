static inline u8 pmc_core_reg_read_byte(struct pmc_dev *pmcdev, int offset)\r\n{\r\nreturn readb(pmcdev->regbase + offset);\r\n}\r\nstatic inline u32 pmc_core_reg_read(struct pmc_dev *pmcdev, int reg_offset)\r\n{\r\nreturn readl(pmcdev->regbase + reg_offset);\r\n}\r\nstatic inline void pmc_core_reg_write(struct pmc_dev *pmcdev, int\r\nreg_offset, u32 val)\r\n{\r\nwritel(val, pmcdev->regbase + reg_offset);\r\n}\r\nstatic inline u32 pmc_core_adjust_slp_s0_step(u32 value)\r\n{\r\nreturn value * SPT_PMC_SLP_S0_RES_COUNTER_STEP;\r\n}\r\nint intel_pmc_slp_s0_counter_read(u32 *data)\r\n{\r\nstruct pmc_dev *pmcdev = &pmc;\r\nu32 value;\r\nif (!pmcdev->has_slp_s0_res)\r\nreturn -EACCES;\r\nvalue = pmc_core_reg_read(pmcdev, SPT_PMC_SLP_S0_RES_COUNTER_OFFSET);\r\n*data = pmc_core_adjust_slp_s0_step(value);\r\nreturn 0;\r\n}\r\nstatic int pmc_core_dev_state_get(void *data, u64 *val)\r\n{\r\nstruct pmc_dev *pmcdev = data;\r\nu32 value;\r\nvalue = pmc_core_reg_read(pmcdev, SPT_PMC_SLP_S0_RES_COUNTER_OFFSET);\r\n*val = pmc_core_adjust_slp_s0_step(value);\r\nreturn 0;\r\n}\r\nstatic int pmc_core_check_read_lock_bit(void)\r\n{\r\nstruct pmc_dev *pmcdev = &pmc;\r\nu32 value;\r\nvalue = pmc_core_reg_read(pmcdev, SPT_PMC_PM_CFG_OFFSET);\r\nreturn value & BIT(SPT_PMC_READ_DISABLE_BIT);\r\n}\r\nstatic void pmc_core_display_map(struct seq_file *s, int index,\r\nu8 pf_reg, const struct pmc_bit_map *pf_map)\r\n{\r\nseq_printf(s, "PCH IP: %-2d - %-32s\tState: %s\n",\r\nindex, pf_map[index].name,\r\npf_map[index].bit_mask & pf_reg ? "Off" : "On");\r\n}\r\nstatic int pmc_core_ppfear_sts_show(struct seq_file *s, void *unused)\r\n{\r\nstruct pmc_dev *pmcdev = s->private;\r\nconst struct pmc_bit_map *map = pmcdev->map->pfear_sts;\r\nu8 pf_regs[NUM_ENTRIES];\r\nint index, iter;\r\niter = SPT_PMC_XRAM_PPFEAR0A;\r\nfor (index = 0; index < NUM_ENTRIES; index++, iter++)\r\npf_regs[index] = pmc_core_reg_read_byte(pmcdev, iter);\r\nfor (index = 0; map[index].name; index++)\r\npmc_core_display_map(s, index, pf_regs[index / 8], map);\r\nreturn 0;\r\n}\r\nstatic int pmc_core_ppfear_sts_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_core_ppfear_sts_show, inode->i_private);\r\n}\r\nstatic int pmc_core_mtpmc_link_status(void)\r\n{\r\nstruct pmc_dev *pmcdev = &pmc;\r\nu32 value;\r\nvalue = pmc_core_reg_read(pmcdev, SPT_PMC_PM_STS_OFFSET);\r\nreturn value & BIT(SPT_PMC_MSG_FULL_STS_BIT);\r\n}\r\nstatic int pmc_core_send_msg(u32 *addr_xram)\r\n{\r\nstruct pmc_dev *pmcdev = &pmc;\r\nu32 dest;\r\nint timeout;\r\nfor (timeout = NUM_RETRIES; timeout > 0; timeout--) {\r\nif (pmc_core_mtpmc_link_status() == 0)\r\nbreak;\r\nmsleep(5);\r\n}\r\nif (timeout <= 0 && pmc_core_mtpmc_link_status())\r\nreturn -EBUSY;\r\ndest = (*addr_xram & MTPMC_MASK) | (1U << 1);\r\npmc_core_reg_write(pmcdev, SPT_PMC_MTPMC_OFFSET, dest);\r\nreturn 0;\r\n}\r\nstatic int pmc_core_mphy_pg_sts_show(struct seq_file *s, void *unused)\r\n{\r\nstruct pmc_dev *pmcdev = s->private;\r\nconst struct pmc_bit_map *map = pmcdev->map->mphy_sts;\r\nu32 mphy_core_reg_low, mphy_core_reg_high;\r\nu32 val_low, val_high;\r\nint index, err = 0;\r\nif (pmcdev->pmc_xram_read_bit) {\r\nseq_puts(s, "Access denied: please disable PMC_READ_DISABLE setting in BIOS.");\r\nreturn 0;\r\n}\r\nmphy_core_reg_low = (SPT_PMC_MPHY_CORE_STS_0 << 16);\r\nmphy_core_reg_high = (SPT_PMC_MPHY_CORE_STS_1 << 16);\r\nmutex_lock(&pmcdev->lock);\r\nif (pmc_core_send_msg(&mphy_core_reg_low) != 0) {\r\nerr = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nmsleep(10);\r\nval_low = pmc_core_reg_read(pmcdev, SPT_PMC_MFPMC_OFFSET);\r\nif (pmc_core_send_msg(&mphy_core_reg_high) != 0) {\r\nerr = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nmsleep(10);\r\nval_high = pmc_core_reg_read(pmcdev, SPT_PMC_MFPMC_OFFSET);\r\nfor (index = 0; map[index].name && index < 8; index++) {\r\nseq_printf(s, "%-32s\tState: %s\n",\r\nmap[index].name,\r\nmap[index].bit_mask & val_low ? "Not power gated" :\r\n"Power gated");\r\n}\r\nfor (index = 8; map[index].name; index++) {\r\nseq_printf(s, "%-32s\tState: %s\n",\r\nmap[index].name,\r\nmap[index].bit_mask & val_high ? "Not power gated" :\r\n"Power gated");\r\n}\r\nout_unlock:\r\nmutex_unlock(&pmcdev->lock);\r\nreturn err;\r\n}\r\nstatic int pmc_core_mphy_pg_sts_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_core_mphy_pg_sts_show, inode->i_private);\r\n}\r\nstatic int pmc_core_pll_show(struct seq_file *s, void *unused)\r\n{\r\nstruct pmc_dev *pmcdev = s->private;\r\nconst struct pmc_bit_map *map = pmcdev->map->pll_sts;\r\nu32 mphy_common_reg, val;\r\nint index, err = 0;\r\nif (pmcdev->pmc_xram_read_bit) {\r\nseq_puts(s, "Access denied: please disable PMC_READ_DISABLE setting in BIOS.");\r\nreturn 0;\r\n}\r\nmphy_common_reg = (SPT_PMC_MPHY_COM_STS_0 << 16);\r\nmutex_lock(&pmcdev->lock);\r\nif (pmc_core_send_msg(&mphy_common_reg) != 0) {\r\nerr = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nmsleep(10);\r\nval = pmc_core_reg_read(pmcdev, SPT_PMC_MFPMC_OFFSET);\r\nfor (index = 0; map[index].name ; index++) {\r\nseq_printf(s, "%-32s\tState: %s\n",\r\nmap[index].name,\r\nmap[index].bit_mask & val ? "Active" : "Idle");\r\n}\r\nout_unlock:\r\nmutex_unlock(&pmcdev->lock);\r\nreturn err;\r\n}\r\nstatic int pmc_core_pll_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_core_pll_show, inode->i_private);\r\n}\r\nstatic ssize_t pmc_core_ltr_ignore_write(struct file *file, const char __user\r\n*userbuf, size_t count, loff_t *ppos)\r\n{\r\nstruct pmc_dev *pmcdev = &pmc;\r\nu32 val, buf_size, fd;\r\nint err = 0;\r\nbuf_size = count < 64 ? count : 64;\r\nmutex_lock(&pmcdev->lock);\r\nif (kstrtou32_from_user(userbuf, buf_size, 10, &val)) {\r\nerr = -EFAULT;\r\ngoto out_unlock;\r\n}\r\nif (val > NUM_IP_IGN_ALLOWED) {\r\nerr = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nfd = pmc_core_reg_read(pmcdev, SPT_PMC_LTR_IGNORE_OFFSET);\r\nfd |= (1U << val);\r\npmc_core_reg_write(pmcdev, SPT_PMC_LTR_IGNORE_OFFSET, fd);\r\nout_unlock:\r\nmutex_unlock(&pmcdev->lock);\r\nreturn err == 0 ? count : err;\r\n}\r\nstatic int pmc_core_ltr_ignore_show(struct seq_file *s, void *unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pmc_core_ltr_ignore_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pmc_core_ltr_ignore_show, inode->i_private);\r\n}\r\nstatic void pmc_core_dbgfs_unregister(struct pmc_dev *pmcdev)\r\n{\r\ndebugfs_remove_recursive(pmcdev->dbgfs_dir);\r\n}\r\nstatic int pmc_core_dbgfs_register(struct pmc_dev *pmcdev)\r\n{\r\nstruct dentry *dir, *file;\r\ndir = debugfs_create_dir("pmc_core", NULL);\r\nif (!dir)\r\nreturn -ENOMEM;\r\npmcdev->dbgfs_dir = dir;\r\nfile = debugfs_create_file("slp_s0_residency_usec", S_IFREG | S_IRUGO,\r\ndir, pmcdev, &pmc_core_dev_state);\r\nif (!file)\r\ngoto err;\r\nfile = debugfs_create_file("pch_ip_power_gating_status",\r\nS_IFREG | S_IRUGO, dir, pmcdev,\r\n&pmc_core_ppfear_ops);\r\nif (!file)\r\ngoto err;\r\nfile = debugfs_create_file("mphy_core_lanes_power_gating_status",\r\nS_IFREG | S_IRUGO, dir, pmcdev,\r\n&pmc_core_mphy_pg_ops);\r\nif (!file)\r\ngoto err;\r\nfile = debugfs_create_file("pll_status",\r\nS_IFREG | S_IRUGO, dir, pmcdev,\r\n&pmc_core_pll_ops);\r\nif (!file)\r\ngoto err;\r\nfile = debugfs_create_file("ltr_ignore",\r\nS_IFREG | S_IRUGO, dir, pmcdev,\r\n&pmc_core_ltr_ignore_ops);\r\nif (!file)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\npmc_core_dbgfs_unregister(pmcdev);\r\nreturn -ENODEV;\r\n}\r\nstatic inline int pmc_core_dbgfs_register(struct pmc_dev *pmcdev)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline void pmc_core_dbgfs_unregister(struct pmc_dev *pmcdev)\r\n{\r\n}\r\nstatic int pmc_core_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nstruct device *ptr_dev = &dev->dev;\r\nstruct pmc_dev *pmcdev = &pmc;\r\nconst struct x86_cpu_id *cpu_id;\r\nconst struct pmc_reg_map *map = (struct pmc_reg_map *)id->driver_data;\r\nint err;\r\ncpu_id = x86_match_cpu(intel_pmc_core_ids);\r\nif (!cpu_id) {\r\ndev_dbg(&dev->dev, "PMC Core: cpuid mismatch.\n");\r\nreturn -EINVAL;\r\n}\r\nerr = pcim_enable_device(dev);\r\nif (err < 0) {\r\ndev_dbg(&dev->dev, "PMC Core: failed to enable Power Management Controller.\n");\r\nreturn err;\r\n}\r\nerr = pci_read_config_dword(dev,\r\nSPT_PMC_BASE_ADDR_OFFSET,\r\n&pmcdev->base_addr);\r\nif (err < 0) {\r\ndev_dbg(&dev->dev, "PMC Core: failed to read PCI config space.\n");\r\nreturn err;\r\n}\r\npmcdev->base_addr &= PMC_BASE_ADDR_MASK;\r\ndev_dbg(&dev->dev, "PMC Core: PWRMBASE is %#x\n", pmcdev->base_addr);\r\npmcdev->regbase = devm_ioremap_nocache(ptr_dev,\r\npmcdev->base_addr,\r\nSPT_PMC_MMIO_REG_LEN);\r\nif (!pmcdev->regbase) {\r\ndev_dbg(&dev->dev, "PMC Core: ioremap failed.\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&pmcdev->lock);\r\npmcdev->pmc_xram_read_bit = pmc_core_check_read_lock_bit();\r\npmcdev->map = map;\r\nerr = pmc_core_dbgfs_register(pmcdev);\r\nif (err < 0)\r\ndev_warn(&dev->dev, "PMC Core: debugfs register failed.\n");\r\npmc.has_slp_s0_res = true;\r\nreturn 0;\r\n}
