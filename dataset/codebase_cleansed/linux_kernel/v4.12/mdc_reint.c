static int mdc_reint(struct ptlrpc_request *request, int level)\r\n{\r\nint rc;\r\nrequest->rq_send_state = level;\r\nmdc_get_mod_rpc_slot(request, NULL);\r\nrc = ptlrpc_queue_wait(request);\r\nmdc_put_mod_rpc_slot(request, NULL);\r\nif (rc)\r\nCDEBUG(D_INFO, "error in handling %d\n", rc);\r\nelse if (!req_capsule_server_get(&request->rq_pill, &RMF_MDT_BODY))\r\nrc = -EPROTO;\r\nreturn rc;\r\n}\r\nint mdc_resource_get_unused(struct obd_export *exp, const struct lu_fid *fid,\r\nstruct list_head *cancels, enum ldlm_mode mode,\r\n__u64 bits)\r\n{\r\nstruct ldlm_namespace *ns = exp->exp_obd->obd_namespace;\r\nunion ldlm_policy_data policy = {};\r\nstruct ldlm_res_id res_id;\r\nstruct ldlm_resource *res;\r\nint count;\r\nif (exp_connect_cancelset(exp) && !ns_connect_cancelset(ns))\r\nreturn 0;\r\nfid_build_reg_res_name(fid, &res_id);\r\nres = ldlm_resource_get(exp->exp_obd->obd_namespace,\r\nNULL, &res_id, 0, 0);\r\nif (IS_ERR(res))\r\nreturn 0;\r\nLDLM_RESOURCE_ADDREF(res);\r\npolicy.l_inodebits.bits = bits;\r\ncount = ldlm_cancel_resource_local(res, cancels, &policy,\r\nmode, 0, 0, NULL);\r\nLDLM_RESOURCE_DELREF(res);\r\nldlm_resource_putref(res);\r\nreturn count;\r\n}\r\nint mdc_setattr(struct obd_export *exp, struct md_op_data *op_data,\r\nvoid *ea, size_t ealen, struct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct ptlrpc_request *req;\r\nint count = 0, rc;\r\n__u64 bits;\r\nbits = MDS_INODELOCK_UPDATE;\r\nif (op_data->op_attr.ia_valid & (ATTR_MODE | ATTR_UID | ATTR_GID))\r\nbits |= MDS_INODELOCK_LOOKUP;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX, bits);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_SETATTR);\r\nif (!req) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_EPOCH, RCL_CLIENT, 0);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT, ealen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_LOGCOOKIES, RCL_CLIENT, 0);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nif (op_data->op_attr.ia_valid & (ATTR_MTIME | ATTR_CTIME))\r\nCDEBUG(D_INODE, "setting mtime %ld, ctime %ld\n",\r\nLTIME_S(op_data->op_attr.ia_mtime),\r\nLTIME_S(op_data->op_attr.ia_ctime));\r\nmdc_setattr_pack(req, op_data, ea, ealen);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_reint(req, LUSTRE_IMP_FULL);\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\n*request = req;\r\nreturn rc;\r\n}\r\nint mdc_create(struct obd_export *exp, struct md_op_data *op_data,\r\nconst void *data, size_t datalen, umode_t mode,\r\nuid_t uid, gid_t gid, cfs_cap_t cap_effective,\r\n__u64 rdev, struct ptlrpc_request **request)\r\n{\r\nstruct ptlrpc_request *req;\r\nint level, rc;\r\nint count, resends = 0;\r\nstruct obd_import *import = exp->exp_obd->u.cli.cl_import;\r\nint generation = import->imp_generation;\r\nLIST_HEAD(cancels);\r\nif (!fid_is_sane(&op_data->op_fid2)) {\r\nrc = mdc_fid_alloc(NULL, exp, &op_data->op_fid2, op_data);\r\nif (rc < 0)\r\nreturn rc;\r\n}\r\nrebuild:\r\ncount = 0;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_CREATE_ACL);\r\nif (!req) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_EADATA, RCL_CLIENT,\r\ndata && datalen ? datalen : 0);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_create_pack(req, op_data, data, datalen, mode, uid,\r\ngid, cap_effective, rdev);\r\nptlrpc_request_set_replen(req);\r\nreq->rq_no_retry_einprogress = 1;\r\nif (resends) {\r\nreq->rq_generation_set = 1;\r\nreq->rq_import_generation = generation;\r\nreq->rq_sent = ktime_get_real_seconds() + resends;\r\n}\r\nlevel = LUSTRE_IMP_FULL;\r\nresend:\r\nrc = mdc_reint(req, level);\r\nif (rc == -ERESTARTSYS) {\r\nlevel = LUSTRE_IMP_RECOVER;\r\ngoto resend;\r\n} else if (rc == -EINPROGRESS) {\r\nptlrpc_req_finished(req);\r\nresends++;\r\nCDEBUG(D_HA, "%s: resend:%d create on "DFID"/"DFID"\n",\r\nexp->exp_obd->obd_name, resends,\r\nPFID(&op_data->op_fid1), PFID(&op_data->op_fid2));\r\nif (generation == import->imp_generation) {\r\ngoto rebuild;\r\n} else {\r\nCDEBUG(D_HA, "resend cross eviction\n");\r\nreturn -EIO;\r\n}\r\n}\r\n*request = req;\r\nreturn rc;\r\n}\r\nint mdc_unlink(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct obd_device *obd = class_exp2obd(exp);\r\nstruct ptlrpc_request *req = *request;\r\nint count = 0, rc;\r\nLASSERT(!req);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID3) &&\r\n(fid_is_sane(&op_data->op_fid3)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid3,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_FULL);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\n&RQF_MDS_REINT_UNLINK);\r\nif (!req) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_unlink_pack(req, op_data);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobd->u.cli.cl_default_mds_easize);\r\nptlrpc_request_set_replen(req);\r\n*request = req;\r\nrc = mdc_reint(req, LUSTRE_IMP_FULL);\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint mdc_link(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct ptlrpc_request *req;\r\nint count = 0, rc;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID2) &&\r\n(fid_is_sane(&op_data->op_fid2)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid2,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp), &RQF_MDS_REINT_LINK);\r\nif (!req) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT,\r\nop_data->op_namelen + 1);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nmdc_link_pack(req, op_data);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_reint(req, LUSTRE_IMP_FULL);\r\n*request = req;\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\nreturn rc;\r\n}\r\nint mdc_rename(struct obd_export *exp, struct md_op_data *op_data,\r\nconst char *old, size_t oldlen, const char *new, size_t newlen,\r\nstruct ptlrpc_request **request)\r\n{\r\nLIST_HEAD(cancels);\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct ptlrpc_request *req;\r\nint count = 0, rc;\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID1) &&\r\n(fid_is_sane(&op_data->op_fid1)))\r\ncount = mdc_resource_get_unused(exp, &op_data->op_fid1,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID2) &&\r\n(fid_is_sane(&op_data->op_fid2)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid2,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_UPDATE);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID3) &&\r\n(fid_is_sane(&op_data->op_fid3)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid3,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_LOOKUP);\r\nif ((op_data->op_flags & MF_MDC_CANCEL_FID4) &&\r\n(fid_is_sane(&op_data->op_fid4)))\r\ncount += mdc_resource_get_unused(exp, &op_data->op_fid4,\r\n&cancels, LCK_EX,\r\nMDS_INODELOCK_FULL);\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(exp),\r\nop_data->op_cli_flags & CLI_MIGRATE ?\r\n&RQF_MDS_REINT_MIGRATE : &RQF_MDS_REINT_RENAME);\r\nif (!req) {\r\nldlm_lock_list_put(&cancels, l_bl_ast, count);\r\nreturn -ENOMEM;\r\n}\r\nreq_capsule_set_size(&req->rq_pill, &RMF_NAME, RCL_CLIENT, oldlen + 1);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SYMTGT, RCL_CLIENT,\r\nnewlen + 1);\r\nrc = mdc_prep_elc_req(exp, req, MDS_REINT, &cancels, count);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\nif (op_data->op_cli_flags & CLI_MIGRATE && op_data->op_data) {\r\nstruct md_open_data *mod = op_data->op_data;\r\nLASSERTF(mod->mod_open_req &&\r\nmod->mod_open_req->rq_type != LI_POISON,\r\n"POISONED open %p!\n", mod->mod_open_req);\r\nDEBUG_REQ(D_HA, mod->mod_open_req, "matched open");\r\nspin_lock(&mod->mod_open_req->rq_lock);\r\nmod->mod_open_req->rq_replay = 0;\r\nspin_unlock(&mod->mod_open_req->rq_lock);\r\n}\r\nif (exp_connect_cancelset(exp) && req)\r\nldlm_cli_cancel_list(&cancels, count, req, 0);\r\nmdc_rename_pack(req, op_data, old, oldlen, new, newlen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_MDT_MD, RCL_SERVER,\r\nobd->u.cli.cl_default_mds_easize);\r\nptlrpc_request_set_replen(req);\r\nrc = mdc_reint(req, LUSTRE_IMP_FULL);\r\n*request = req;\r\nif (rc == -ERESTARTSYS)\r\nrc = 0;\r\nreturn rc;\r\n}
