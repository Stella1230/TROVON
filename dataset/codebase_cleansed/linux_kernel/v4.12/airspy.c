static int airspy_ctrl_msg(struct airspy *s, u8 request, u16 value, u16 index,\r\nu8 *data, u16 size)\r\n{\r\nint ret;\r\nunsigned int pipe;\r\nu8 requesttype;\r\nswitch (request) {\r\ncase CMD_RECEIVER_MODE:\r\ncase CMD_SET_FREQ:\r\npipe = usb_sndctrlpipe(s->udev, 0);\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nbreak;\r\ncase CMD_BOARD_ID_READ:\r\ncase CMD_VERSION_STRING_READ:\r\ncase CMD_BOARD_PARTID_SERIALNO_READ:\r\ncase CMD_SET_LNA_GAIN:\r\ncase CMD_SET_MIXER_GAIN:\r\ncase CMD_SET_VGA_GAIN:\r\ncase CMD_SET_LNA_AGC:\r\ncase CMD_SET_MIXER_AGC:\r\npipe = usb_rcvctrlpipe(s->udev, 0);\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nbreak;\r\ndefault:\r\ndev_err(s->dev, "Unknown command %02x\n", request);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (!(requesttype & USB_DIR_IN))\r\nmemcpy(s->buf, data, size);\r\nret = usb_control_msg(s->udev, pipe, request, requesttype, value,\r\nindex, s->buf, size, 1000);\r\nairspy_dbg_usb_control_msg(s->dev, request, requesttype, value,\r\nindex, s->buf, size);\r\nif (ret < 0) {\r\ndev_err(s->dev, "usb_control_msg() failed %d request %02x\n",\r\nret, request);\r\ngoto err;\r\n}\r\nif (requesttype & USB_DIR_IN)\r\nmemcpy(data, s->buf, size);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic struct airspy_frame_buf *airspy_get_next_fill_buf(struct airspy *s)\r\n{\r\nunsigned long flags;\r\nstruct airspy_frame_buf *buf = NULL;\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nif (list_empty(&s->queued_bufs))\r\ngoto leave;\r\nbuf = list_entry(s->queued_bufs.next,\r\nstruct airspy_frame_buf, list);\r\nlist_del(&buf->list);\r\nleave:\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\nreturn buf;\r\n}\r\nstatic unsigned int airspy_convert_stream(struct airspy *s,\r\nvoid *dst, void *src, unsigned int src_len)\r\n{\r\nunsigned int dst_len;\r\nif (s->pixelformat == V4L2_SDR_FMT_RU12LE) {\r\nmemcpy(dst, src, src_len);\r\ndst_len = src_len;\r\n} else {\r\ndst_len = 0;\r\n}\r\nif (unlikely(time_is_before_jiffies(s->jiffies_next))) {\r\n#define MSECS 10000UL\r\nunsigned int msecs = jiffies_to_msecs(jiffies -\r\ns->jiffies_next + msecs_to_jiffies(MSECS));\r\nunsigned int samples = s->sample - s->sample_measured;\r\ns->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\r\ns->sample_measured = s->sample;\r\ndev_dbg(s->dev, "slen=%u samples=%u msecs=%u sample rate=%lu\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs);\r\n}\r\ns->sample += src_len / 2;\r\nreturn dst_len;\r\n}\r\nstatic void airspy_urb_complete(struct urb *urb)\r\n{\r\nstruct airspy *s = urb->context;\r\nstruct airspy_frame_buf *fbuf;\r\ndev_dbg_ratelimited(s->dev, "status=%d length=%d/%d errors=%d\n",\r\nurb->status, urb->actual_length,\r\nurb->transfer_buffer_length, urb->error_count);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_err_ratelimited(s->dev, "URB failed %d\n", urb->status);\r\nbreak;\r\n}\r\nif (likely(urb->actual_length > 0)) {\r\nvoid *ptr;\r\nunsigned int len;\r\nfbuf = airspy_get_next_fill_buf(s);\r\nif (unlikely(fbuf == NULL)) {\r\ns->vb_full++;\r\ndev_notice_ratelimited(s->dev,\r\n"videobuf is full, %d packets dropped\n",\r\ns->vb_full);\r\ngoto skip;\r\n}\r\nptr = vb2_plane_vaddr(&fbuf->vb.vb2_buf, 0);\r\nlen = airspy_convert_stream(s, ptr, urb->transfer_buffer,\r\nurb->actual_length);\r\nvb2_set_plane_payload(&fbuf->vb.vb2_buf, 0, len);\r\nfbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nfbuf->vb.sequence = s->sequence++;\r\nvb2_buffer_done(&fbuf->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\n}\r\nskip:\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int airspy_kill_urbs(struct airspy *s)\r\n{\r\nint i;\r\nfor (i = s->urbs_submitted - 1; i >= 0; i--) {\r\ndev_dbg(s->dev, "kill urb=%d\n", i);\r\nusb_kill_urb(s->urb_list[i]);\r\n}\r\ns->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nstatic int airspy_submit_urbs(struct airspy *s)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < s->urbs_initialized; i++) {\r\ndev_dbg(s->dev, "submit urb=%d\n", i);\r\nret = usb_submit_urb(s->urb_list[i], GFP_ATOMIC);\r\nif (ret) {\r\ndev_err(s->dev, "Could not submit URB no. %d - get them all back\n",\r\ni);\r\nairspy_kill_urbs(s);\r\nreturn ret;\r\n}\r\ns->urbs_submitted++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int airspy_free_stream_bufs(struct airspy *s)\r\n{\r\nif (test_bit(USB_STATE_URB_BUF, &s->flags)) {\r\nwhile (s->buf_num) {\r\ns->buf_num--;\r\ndev_dbg(s->dev, "free buf=%d\n", s->buf_num);\r\nusb_free_coherent(s->udev, s->buf_size,\r\ns->buf_list[s->buf_num],\r\ns->dma_addr[s->buf_num]);\r\n}\r\n}\r\nclear_bit(USB_STATE_URB_BUF, &s->flags);\r\nreturn 0;\r\n}\r\nstatic int airspy_alloc_stream_bufs(struct airspy *s)\r\n{\r\ns->buf_num = 0;\r\ns->buf_size = BULK_BUFFER_SIZE;\r\ndev_dbg(s->dev, "all in all I will use %u bytes for streaming\n",\r\nMAX_BULK_BUFS * BULK_BUFFER_SIZE);\r\nfor (s->buf_num = 0; s->buf_num < MAX_BULK_BUFS; s->buf_num++) {\r\ns->buf_list[s->buf_num] = usb_alloc_coherent(s->udev,\r\nBULK_BUFFER_SIZE, GFP_ATOMIC,\r\n&s->dma_addr[s->buf_num]);\r\nif (!s->buf_list[s->buf_num]) {\r\ndev_dbg(s->dev, "alloc buf=%d failed\n", s->buf_num);\r\nairspy_free_stream_bufs(s);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(s->dev, "alloc buf=%d %p (dma %llu)\n", s->buf_num,\r\ns->buf_list[s->buf_num],\r\n(long long)s->dma_addr[s->buf_num]);\r\nset_bit(USB_STATE_URB_BUF, &s->flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int airspy_free_urbs(struct airspy *s)\r\n{\r\nint i;\r\nairspy_kill_urbs(s);\r\nfor (i = s->urbs_initialized - 1; i >= 0; i--) {\r\nif (s->urb_list[i]) {\r\ndev_dbg(s->dev, "free urb=%d\n", i);\r\nusb_free_urb(s->urb_list[i]);\r\n}\r\n}\r\ns->urbs_initialized = 0;\r\nreturn 0;\r\n}\r\nstatic int airspy_alloc_urbs(struct airspy *s)\r\n{\r\nint i, j;\r\nfor (i = 0; i < MAX_BULK_BUFS; i++) {\r\ndev_dbg(s->dev, "alloc urb=%d\n", i);\r\ns->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!s->urb_list[i]) {\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(s->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(s->urb_list[i],\r\ns->udev,\r\nusb_rcvbulkpipe(s->udev, 0x81),\r\ns->buf_list[i],\r\nBULK_BUFFER_SIZE,\r\nairspy_urb_complete, s);\r\ns->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\ns->urb_list[i]->transfer_dma = s->dma_addr[i];\r\ns->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void airspy_cleanup_queued_bufs(struct airspy *s)\r\n{\r\nunsigned long flags;\r\ndev_dbg(s->dev, "\n");\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nwhile (!list_empty(&s->queued_bufs)) {\r\nstruct airspy_frame_buf *buf;\r\nbuf = list_entry(s->queued_bufs.next,\r\nstruct airspy_frame_buf, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}\r\nstatic void airspy_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v = usb_get_intfdata(intf);\r\nstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\r\ndev_dbg(s->dev, "\n");\r\nmutex_lock(&s->vb_queue_lock);\r\nmutex_lock(&s->v4l2_lock);\r\ns->udev = NULL;\r\nv4l2_device_disconnect(&s->v4l2_dev);\r\nvideo_unregister_device(&s->vdev);\r\nmutex_unlock(&s->v4l2_lock);\r\nmutex_unlock(&s->vb_queue_lock);\r\nv4l2_device_put(&s->v4l2_dev);\r\n}\r\nstatic int airspy_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct airspy *s = vb2_get_drv_priv(vq);\r\ndev_dbg(s->dev, "nbuffers=%d\n", *nbuffers);\r\nif (vq->num_buffers + *nbuffers < 8)\r\n*nbuffers = 8 - vq->num_buffers;\r\n*nplanes = 1;\r\nsizes[0] = PAGE_ALIGN(s->buffersize);\r\ndev_dbg(s->dev, "nbuffers=%d sizes[0]=%d\n", *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic void airspy_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct airspy *s = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct airspy_frame_buf *buf =\r\ncontainer_of(vbuf, struct airspy_frame_buf, vb);\r\nunsigned long flags;\r\nif (unlikely(!s->udev)) {\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nreturn;\r\n}\r\nspin_lock_irqsave(&s->queued_bufs_lock, flags);\r\nlist_add_tail(&buf->list, &s->queued_bufs);\r\nspin_unlock_irqrestore(&s->queued_bufs_lock, flags);\r\n}\r\nstatic int airspy_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct airspy *s = vb2_get_drv_priv(vq);\r\nint ret;\r\ndev_dbg(s->dev, "\n");\r\nif (!s->udev)\r\nreturn -ENODEV;\r\nmutex_lock(&s->v4l2_lock);\r\ns->sequence = 0;\r\nset_bit(POWER_ON, &s->flags);\r\nret = airspy_alloc_stream_bufs(s);\r\nif (ret)\r\ngoto err_clear_bit;\r\nret = airspy_alloc_urbs(s);\r\nif (ret)\r\ngoto err_free_stream_bufs;\r\nret = airspy_submit_urbs(s);\r\nif (ret)\r\ngoto err_free_urbs;\r\nret = airspy_ctrl_msg(s, CMD_RECEIVER_MODE, 1, 0, NULL, 0);\r\nif (ret)\r\ngoto err_kill_urbs;\r\ngoto exit_mutex_unlock;\r\nerr_kill_urbs:\r\nairspy_kill_urbs(s);\r\nerr_free_urbs:\r\nairspy_free_urbs(s);\r\nerr_free_stream_bufs:\r\nairspy_free_stream_bufs(s);\r\nerr_clear_bit:\r\nclear_bit(POWER_ON, &s->flags);\r\n{\r\nstruct airspy_frame_buf *buf, *tmp;\r\nlist_for_each_entry_safe(buf, tmp, &s->queued_bufs, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf,\r\nVB2_BUF_STATE_QUEUED);\r\n}\r\n}\r\nexit_mutex_unlock:\r\nmutex_unlock(&s->v4l2_lock);\r\nreturn ret;\r\n}\r\nstatic void airspy_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct airspy *s = vb2_get_drv_priv(vq);\r\ndev_dbg(s->dev, "\n");\r\nmutex_lock(&s->v4l2_lock);\r\nairspy_ctrl_msg(s, CMD_RECEIVER_MODE, 0, 0, NULL, 0);\r\nairspy_kill_urbs(s);\r\nairspy_free_urbs(s);\r\nairspy_free_stream_bufs(s);\r\nairspy_cleanup_queued_bufs(s);\r\nclear_bit(POWER_ON, &s->flags);\r\nmutex_unlock(&s->v4l2_lock);\r\n}\r\nstatic int airspy_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct airspy *s = video_drvdata(file);\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, s->vdev.name, sizeof(cap->card));\r\nusb_make_path(s->udev, cap->bus_info, sizeof(cap->bus_info));\r\ncap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE | V4L2_CAP_TUNER;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int airspy_enum_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index >= NUM_FORMATS)\r\nreturn -EINVAL;\r\nstrlcpy(f->description, formats[f->index].name, sizeof(f->description));\r\nf->pixelformat = formats[f->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int airspy_g_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct airspy *s = video_drvdata(file);\r\nf->fmt.sdr.pixelformat = s->pixelformat;\r\nf->fmt.sdr.buffersize = s->buffersize;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nreturn 0;\r\n}\r\nstatic int airspy_s_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct airspy *s = video_drvdata(file);\r\nstruct vb2_queue *q = &s->vb_queue;\r\nint i;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\ns->pixelformat = formats[i].pixelformat;\r\ns->buffersize = formats[i].buffersize;\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\ns->pixelformat = formats[0].pixelformat;\r\ns->buffersize = formats[0].buffersize;\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int airspy_try_fmt_sdr_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint i;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int airspy_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nint ret;\r\nif (v->index == 0)\r\nret = 0;\r\nelse if (v->index == 1)\r\nret = 0;\r\nelse\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int airspy_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\r\n{\r\nint ret;\r\nif (v->index == 0) {\r\nstrlcpy(v->name, "AirSpy ADC", sizeof(v->name));\r\nv->type = V4L2_TUNER_ADC;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = bands[0].rangelow;\r\nv->rangehigh = bands[0].rangehigh;\r\nret = 0;\r\n} else if (v->index == 1) {\r\nstrlcpy(v->name, "AirSpy RF", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = bands_rf[0].rangelow;\r\nv->rangehigh = bands_rf[0].rangehigh;\r\nret = 0;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int airspy_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct airspy *s = video_drvdata(file);\r\nint ret;\r\nif (f->tuner == 0) {\r\nf->type = V4L2_TUNER_ADC;\r\nf->frequency = s->f_adc;\r\ndev_dbg(s->dev, "ADC frequency=%u Hz\n", s->f_adc);\r\nret = 0;\r\n} else if (f->tuner == 1) {\r\nf->type = V4L2_TUNER_RF;\r\nf->frequency = s->f_rf;\r\ndev_dbg(s->dev, "RF frequency=%u Hz\n", s->f_rf);\r\nret = 0;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int airspy_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct airspy *s = video_drvdata(file);\r\nint ret;\r\nu8 buf[4];\r\nif (f->tuner == 0) {\r\ns->f_adc = clamp_t(unsigned int, f->frequency,\r\nbands[0].rangelow,\r\nbands[0].rangehigh);\r\ndev_dbg(s->dev, "ADC frequency=%u Hz\n", s->f_adc);\r\nret = 0;\r\n} else if (f->tuner == 1) {\r\ns->f_rf = clamp_t(unsigned int, f->frequency,\r\nbands_rf[0].rangelow,\r\nbands_rf[0].rangehigh);\r\ndev_dbg(s->dev, "RF frequency=%u Hz\n", s->f_rf);\r\nbuf[0] = (s->f_rf >> 0) & 0xff;\r\nbuf[1] = (s->f_rf >> 8) & 0xff;\r\nbuf[2] = (s->f_rf >> 16) & 0xff;\r\nbuf[3] = (s->f_rf >> 24) & 0xff;\r\nret = airspy_ctrl_msg(s, CMD_SET_FREQ, 0, 0, buf, 4);\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int airspy_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nint ret;\r\nif (band->tuner == 0) {\r\nif (band->index >= ARRAY_SIZE(bands)) {\r\nret = -EINVAL;\r\n} else {\r\n*band = bands[band->index];\r\nret = 0;\r\n}\r\n} else if (band->tuner == 1) {\r\nif (band->index >= ARRAY_SIZE(bands_rf)) {\r\nret = -EINVAL;\r\n} else {\r\n*band = bands_rf[band->index];\r\nret = 0;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void airspy_video_release(struct v4l2_device *v)\r\n{\r\nstruct airspy *s = container_of(v, struct airspy, v4l2_dev);\r\nv4l2_ctrl_handler_free(&s->hdl);\r\nv4l2_device_unregister(&s->v4l2_dev);\r\nkfree(s);\r\n}\r\nstatic int airspy_set_lna_gain(struct airspy *s)\r\n{\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(s->dev, "lna auto=%d->%d val=%d->%d\n",\r\ns->lna_gain_auto->cur.val, s->lna_gain_auto->val,\r\ns->lna_gain->cur.val, s->lna_gain->val);\r\nret = airspy_ctrl_msg(s, CMD_SET_LNA_AGC, 0, s->lna_gain_auto->val,\r\n&u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\nif (s->lna_gain_auto->val == false) {\r\nret = airspy_ctrl_msg(s, CMD_SET_LNA_GAIN, 0, s->lna_gain->val,\r\n&u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(s->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int airspy_set_mixer_gain(struct airspy *s)\r\n{\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(s->dev, "mixer auto=%d->%d val=%d->%d\n",\r\ns->mixer_gain_auto->cur.val, s->mixer_gain_auto->val,\r\ns->mixer_gain->cur.val, s->mixer_gain->val);\r\nret = airspy_ctrl_msg(s, CMD_SET_MIXER_AGC, 0, s->mixer_gain_auto->val,\r\n&u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\nif (s->mixer_gain_auto->val == false) {\r\nret = airspy_ctrl_msg(s, CMD_SET_MIXER_GAIN, 0,\r\ns->mixer_gain->val, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nerr:\r\nif (ret)\r\ndev_dbg(s->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int airspy_set_if_gain(struct airspy *s)\r\n{\r\nint ret;\r\nu8 u8tmp;\r\ndev_dbg(s->dev, "val=%d->%d\n", s->if_gain->cur.val, s->if_gain->val);\r\nret = airspy_ctrl_msg(s, CMD_SET_VGA_GAIN, 0, s->if_gain->val,\r\n&u8tmp, 1);\r\nif (ret)\r\ndev_dbg(s->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int airspy_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct airspy *s = container_of(ctrl->handler, struct airspy, hdl);\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nret = airspy_set_lna_gain(s);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN_AUTO:\r\ncase V4L2_CID_RF_TUNER_MIXER_GAIN:\r\nret = airspy_set_mixer_gain(s);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\nret = airspy_set_if_gain(s);\r\nbreak;\r\ndefault:\r\ndev_dbg(s->dev, "unknown ctrl: id=%d name=%s\n",\r\nctrl->id, ctrl->name);\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int airspy_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct airspy *s;\r\nint ret;\r\nu8 u8tmp, buf[BUF_SIZE];\r\ns = kzalloc(sizeof(struct airspy), GFP_KERNEL);\r\nif (s == NULL) {\r\ndev_err(&intf->dev, "Could not allocate memory for state\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&s->v4l2_lock);\r\nmutex_init(&s->vb_queue_lock);\r\nspin_lock_init(&s->queued_bufs_lock);\r\nINIT_LIST_HEAD(&s->queued_bufs);\r\ns->dev = &intf->dev;\r\ns->udev = interface_to_usbdev(intf);\r\ns->f_adc = bands[0].rangelow;\r\ns->f_rf = bands_rf[0].rangelow;\r\ns->pixelformat = formats[0].pixelformat;\r\ns->buffersize = formats[0].buffersize;\r\nret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\r\nif (ret == 0)\r\nret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\r\nbuf, BUF_SIZE);\r\nif (ret) {\r\ndev_err(s->dev, "Could not detect board\n");\r\ngoto err_free_mem;\r\n}\r\nbuf[BUF_SIZE - 1] = '\0';\r\ndev_info(s->dev, "Board ID: %02x\n", u8tmp);\r\ndev_info(s->dev, "Firmware version: %s\n", buf);\r\ns->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\ns->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\r\ns->vb_queue.drv_priv = s;\r\ns->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\r\ns->vb_queue.ops = &airspy_vb2_ops;\r\ns->vb_queue.mem_ops = &vb2_vmalloc_memops;\r\ns->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&s->vb_queue);\r\nif (ret) {\r\ndev_err(s->dev, "Could not initialize vb2 queue\n");\r\ngoto err_free_mem;\r\n}\r\ns->vdev = airspy_template;\r\ns->vdev.queue = &s->vb_queue;\r\ns->vdev.queue->lock = &s->vb_queue_lock;\r\nvideo_set_drvdata(&s->vdev, s);\r\ns->v4l2_dev.release = airspy_video_release;\r\nret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\r\nif (ret) {\r\ndev_err(s->dev, "Failed to register v4l2-device (%d)\n", ret);\r\ngoto err_free_mem;\r\n}\r\nv4l2_ctrl_handler_init(&s->hdl, 5);\r\ns->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\r\ns->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\nV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\r\nv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\r\ns->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\r\ns->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\nV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\r\nv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\r\ns->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\r\nV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\r\nif (s->hdl.error) {\r\nret = s->hdl.error;\r\ndev_err(s->dev, "Could not initialize controls\n");\r\ngoto err_free_controls;\r\n}\r\nv4l2_ctrl_handler_setup(&s->hdl);\r\ns->v4l2_dev.ctrl_handler = &s->hdl;\r\ns->vdev.v4l2_dev = &s->v4l2_dev;\r\ns->vdev.lock = &s->v4l2_lock;\r\nret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\r\nif (ret) {\r\ndev_err(s->dev, "Failed to register as video device (%d)\n",\r\nret);\r\ngoto err_free_controls;\r\n}\r\ndev_info(s->dev, "Registered as %s\n",\r\nvideo_device_node_name(&s->vdev));\r\ndev_notice(s->dev, "SDR API is still slightly experimental and functionality changes may follow\n");\r\nreturn 0;\r\nerr_free_controls:\r\nv4l2_ctrl_handler_free(&s->hdl);\r\nv4l2_device_unregister(&s->v4l2_dev);\r\nerr_free_mem:\r\nkfree(s);\r\nreturn ret;\r\n}
