static int qcom_usb_hs_phy_set_mode(struct phy *phy, enum phy_mode mode)\r\n{\r\nstruct qcom_usb_hs_phy *uphy = phy_get_drvdata(phy);\r\nu8 addr;\r\nint ret;\r\nif (!uphy->vbus_edev) {\r\nu8 val = 0;\r\nswitch (mode) {\r\ncase PHY_MODE_USB_OTG:\r\ncase PHY_MODE_USB_HOST:\r\nval |= ULPI_INT_IDGRD;\r\ncase PHY_MODE_USB_DEVICE:\r\nval |= ULPI_INT_SESS_VALID;\r\ndefault:\r\nbreak;\r\n}\r\nret = ulpi_write(uphy->ulpi, ULPI_USB_INT_EN_RISE, val);\r\nif (ret)\r\nreturn ret;\r\nret = ulpi_write(uphy->ulpi, ULPI_USB_INT_EN_FALL, val);\r\n} else {\r\nswitch (mode) {\r\ncase PHY_MODE_USB_OTG:\r\ncase PHY_MODE_USB_DEVICE:\r\naddr = ULPI_SET(ULPI_MISC_A);\r\nbreak;\r\ncase PHY_MODE_USB_HOST:\r\naddr = ULPI_CLR(ULPI_MISC_A);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = ulpi_write(uphy->ulpi, ULPI_SET(ULPI_PWR_CLK_MNG_REG),\r\nULPI_PWR_OTG_COMP_DISABLE);\r\nif (ret)\r\nreturn ret;\r\nret = ulpi_write(uphy->ulpi, addr, ULPI_MISC_A_VBUSVLDEXTSEL);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nqcom_usb_hs_phy_vbus_notifier(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct qcom_usb_hs_phy *uphy;\r\nu8 addr;\r\nuphy = container_of(nb, struct qcom_usb_hs_phy, vbus_notify);\r\nif (event)\r\naddr = ULPI_SET(ULPI_MISC_A);\r\nelse\r\naddr = ULPI_CLR(ULPI_MISC_A);\r\nreturn ulpi_write(uphy->ulpi, addr, ULPI_MISC_A_VBUSVLDEXT);\r\n}\r\nstatic int qcom_usb_hs_phy_power_on(struct phy *phy)\r\n{\r\nstruct qcom_usb_hs_phy *uphy = phy_get_drvdata(phy);\r\nstruct ulpi *ulpi = uphy->ulpi;\r\nconst struct ulpi_seq *seq;\r\nint ret, state;\r\nret = clk_prepare_enable(uphy->ref_clk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(uphy->sleep_clk);\r\nif (ret)\r\ngoto err_sleep;\r\nret = regulator_set_load(uphy->v1p8, 50000);\r\nif (ret < 0)\r\ngoto err_1p8;\r\nret = regulator_enable(uphy->v1p8);\r\nif (ret)\r\ngoto err_1p8;\r\nret = regulator_set_voltage_triplet(uphy->v3p3, 3050000, 3300000,\r\n3300000);\r\nif (ret)\r\ngoto err_3p3;\r\nret = regulator_set_load(uphy->v3p3, 50000);\r\nif (ret < 0)\r\ngoto err_3p3;\r\nret = regulator_enable(uphy->v3p3);\r\nif (ret)\r\ngoto err_3p3;\r\nfor (seq = uphy->init_seq; seq->addr; seq++) {\r\nret = ulpi_write(ulpi, ULPI_EXT_VENDOR_SPECIFIC + seq->addr,\r\nseq->val);\r\nif (ret)\r\ngoto err_ulpi;\r\n}\r\nif (uphy->reset) {\r\nret = reset_control_reset(uphy->reset);\r\nif (ret)\r\ngoto err_ulpi;\r\n}\r\nif (uphy->vbus_edev) {\r\nstate = extcon_get_cable_state_(uphy->vbus_edev, EXTCON_USB);\r\nqcom_usb_hs_phy_vbus_notifier(&uphy->vbus_notify, state,\r\nuphy->vbus_edev);\r\nret = extcon_register_notifier(uphy->vbus_edev, EXTCON_USB,\r\n&uphy->vbus_notify);\r\nif (ret)\r\ngoto err_ulpi;\r\n}\r\nreturn 0;\r\nerr_ulpi:\r\nregulator_disable(uphy->v3p3);\r\nerr_3p3:\r\nregulator_disable(uphy->v1p8);\r\nerr_1p8:\r\nclk_disable_unprepare(uphy->sleep_clk);\r\nerr_sleep:\r\nclk_disable_unprepare(uphy->ref_clk);\r\nreturn ret;\r\n}\r\nstatic int qcom_usb_hs_phy_power_off(struct phy *phy)\r\n{\r\nint ret;\r\nstruct qcom_usb_hs_phy *uphy = phy_get_drvdata(phy);\r\nif (uphy->vbus_edev) {\r\nret = extcon_unregister_notifier(uphy->vbus_edev, EXTCON_USB,\r\n&uphy->vbus_notify);\r\nif (ret)\r\nreturn ret;\r\n}\r\nregulator_disable(uphy->v3p3);\r\nregulator_disable(uphy->v1p8);\r\nclk_disable_unprepare(uphy->sleep_clk);\r\nclk_disable_unprepare(uphy->ref_clk);\r\nreturn 0;\r\n}\r\nstatic int qcom_usb_hs_phy_probe(struct ulpi *ulpi)\r\n{\r\nstruct qcom_usb_hs_phy *uphy;\r\nstruct phy_provider *p;\r\nstruct clk *clk;\r\nstruct regulator *reg;\r\nstruct reset_control *reset;\r\nint size;\r\nint ret;\r\nuphy = devm_kzalloc(&ulpi->dev, sizeof(*uphy), GFP_KERNEL);\r\nif (!uphy)\r\nreturn -ENOMEM;\r\nulpi_set_drvdata(ulpi, uphy);\r\nuphy->ulpi = ulpi;\r\nsize = of_property_count_u8_elems(ulpi->dev.of_node, "qcom,init-seq");\r\nif (size < 0)\r\nsize = 0;\r\nuphy->init_seq = devm_kmalloc_array(&ulpi->dev, (size / 2) + 1,\r\nsizeof(*uphy->init_seq), GFP_KERNEL);\r\nif (!uphy->init_seq)\r\nreturn -ENOMEM;\r\nret = of_property_read_u8_array(ulpi->dev.of_node, "qcom,init-seq",\r\n(u8 *)uphy->init_seq, size);\r\nif (ret && size)\r\nreturn ret;\r\nuphy->init_seq[size / 2].addr = uphy->init_seq[size / 2].val = 0;\r\nuphy->ref_clk = clk = devm_clk_get(&ulpi->dev, "ref");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nuphy->sleep_clk = clk = devm_clk_get(&ulpi->dev, "sleep");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nuphy->v1p8 = reg = devm_regulator_get(&ulpi->dev, "v1p8");\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nuphy->v3p3 = reg = devm_regulator_get(&ulpi->dev, "v3p3");\r\nif (IS_ERR(reg))\r\nreturn PTR_ERR(reg);\r\nuphy->reset = reset = devm_reset_control_get(&ulpi->dev, "por");\r\nif (IS_ERR(reset)) {\r\nif (PTR_ERR(reset) == -EPROBE_DEFER)\r\nreturn PTR_ERR(reset);\r\nuphy->reset = NULL;\r\n}\r\nuphy->phy = devm_phy_create(&ulpi->dev, ulpi->dev.of_node,\r\n&qcom_usb_hs_phy_ops);\r\nif (IS_ERR(uphy->phy))\r\nreturn PTR_ERR(uphy->phy);\r\nuphy->vbus_edev = extcon_get_edev_by_phandle(&ulpi->dev, 0);\r\nif (IS_ERR(uphy->vbus_edev)) {\r\nif (PTR_ERR(uphy->vbus_edev) != -ENODEV)\r\nreturn PTR_ERR(uphy->vbus_edev);\r\nuphy->vbus_edev = NULL;\r\n}\r\nuphy->vbus_notify.notifier_call = qcom_usb_hs_phy_vbus_notifier;\r\nphy_set_drvdata(uphy->phy, uphy);\r\np = devm_of_phy_provider_register(&ulpi->dev, of_phy_simple_xlate);\r\nreturn PTR_ERR_OR_ZERO(p);\r\n}
