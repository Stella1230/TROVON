static int rockchip_gem_iommu_map(struct rockchip_gem_object *rk_obj)\r\n{\r\nstruct drm_device *drm = rk_obj->base.dev;\r\nstruct rockchip_drm_private *private = drm->dev_private;\r\nint prot = IOMMU_READ | IOMMU_WRITE;\r\nssize_t ret;\r\nmutex_lock(&private->mm_lock);\r\nret = drm_mm_insert_node_generic(&private->mm, &rk_obj->mm,\r\nrk_obj->base.size, PAGE_SIZE,\r\n0, 0);\r\nmutex_unlock(&private->mm_lock);\r\nif (ret < 0) {\r\nDRM_ERROR("out of I/O virtual memory: %zd\n", ret);\r\nreturn ret;\r\n}\r\nrk_obj->dma_addr = rk_obj->mm.start;\r\nret = iommu_map_sg(private->domain, rk_obj->dma_addr, rk_obj->sgt->sgl,\r\nrk_obj->sgt->nents, prot);\r\nif (ret < rk_obj->base.size) {\r\nDRM_ERROR("failed to map buffer: size=%zd request_size=%zd\n",\r\nret, rk_obj->base.size);\r\nret = -ENOMEM;\r\ngoto err_remove_node;\r\n}\r\nrk_obj->size = ret;\r\nreturn 0;\r\nerr_remove_node:\r\ndrm_mm_remove_node(&rk_obj->mm);\r\nreturn ret;\r\n}\r\nstatic int rockchip_gem_iommu_unmap(struct rockchip_gem_object *rk_obj)\r\n{\r\nstruct drm_device *drm = rk_obj->base.dev;\r\nstruct rockchip_drm_private *private = drm->dev_private;\r\niommu_unmap(private->domain, rk_obj->dma_addr, rk_obj->size);\r\nmutex_lock(&private->mm_lock);\r\ndrm_mm_remove_node(&rk_obj->mm);\r\nmutex_unlock(&private->mm_lock);\r\nreturn 0;\r\n}\r\nstatic int rockchip_gem_get_pages(struct rockchip_gem_object *rk_obj)\r\n{\r\nstruct drm_device *drm = rk_obj->base.dev;\r\nint ret, i;\r\nstruct scatterlist *s;\r\nrk_obj->pages = drm_gem_get_pages(&rk_obj->base);\r\nif (IS_ERR(rk_obj->pages))\r\nreturn PTR_ERR(rk_obj->pages);\r\nrk_obj->num_pages = rk_obj->base.size >> PAGE_SHIFT;\r\nrk_obj->sgt = drm_prime_pages_to_sg(rk_obj->pages, rk_obj->num_pages);\r\nif (IS_ERR(rk_obj->sgt)) {\r\nret = PTR_ERR(rk_obj->sgt);\r\ngoto err_put_pages;\r\n}\r\nfor_each_sg(rk_obj->sgt->sgl, s, rk_obj->sgt->nents, i)\r\nsg_dma_address(s) = sg_phys(s);\r\ndma_sync_sg_for_device(drm->dev, rk_obj->sgt->sgl, rk_obj->sgt->nents,\r\nDMA_TO_DEVICE);\r\nreturn 0;\r\nerr_put_pages:\r\ndrm_gem_put_pages(&rk_obj->base, rk_obj->pages, false, false);\r\nreturn ret;\r\n}\r\nstatic void rockchip_gem_put_pages(struct rockchip_gem_object *rk_obj)\r\n{\r\nsg_free_table(rk_obj->sgt);\r\nkfree(rk_obj->sgt);\r\ndrm_gem_put_pages(&rk_obj->base, rk_obj->pages, true, true);\r\n}\r\nstatic int rockchip_gem_alloc_iommu(struct rockchip_gem_object *rk_obj,\r\nbool alloc_kmap)\r\n{\r\nint ret;\r\nret = rockchip_gem_get_pages(rk_obj);\r\nif (ret < 0)\r\nreturn ret;\r\nret = rockchip_gem_iommu_map(rk_obj);\r\nif (ret < 0)\r\ngoto err_free;\r\nif (alloc_kmap) {\r\nrk_obj->kvaddr = vmap(rk_obj->pages, rk_obj->num_pages, VM_MAP,\r\npgprot_writecombine(PAGE_KERNEL));\r\nif (!rk_obj->kvaddr) {\r\nDRM_ERROR("failed to vmap() buffer\n");\r\nret = -ENOMEM;\r\ngoto err_unmap;\r\n}\r\n}\r\nreturn 0;\r\nerr_unmap:\r\nrockchip_gem_iommu_unmap(rk_obj);\r\nerr_free:\r\nrockchip_gem_put_pages(rk_obj);\r\nreturn ret;\r\n}\r\nstatic int rockchip_gem_alloc_dma(struct rockchip_gem_object *rk_obj,\r\nbool alloc_kmap)\r\n{\r\nstruct drm_gem_object *obj = &rk_obj->base;\r\nstruct drm_device *drm = obj->dev;\r\nrk_obj->dma_attrs = DMA_ATTR_WRITE_COMBINE;\r\nif (!alloc_kmap)\r\nrk_obj->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;\r\nrk_obj->kvaddr = dma_alloc_attrs(drm->dev, obj->size,\r\n&rk_obj->dma_addr, GFP_KERNEL,\r\nrk_obj->dma_attrs);\r\nif (!rk_obj->kvaddr) {\r\nDRM_ERROR("failed to allocate %zu byte dma buffer", obj->size);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_gem_alloc_buf(struct rockchip_gem_object *rk_obj,\r\nbool alloc_kmap)\r\n{\r\nstruct drm_gem_object *obj = &rk_obj->base;\r\nstruct drm_device *drm = obj->dev;\r\nstruct rockchip_drm_private *private = drm->dev_private;\r\nif (private->domain)\r\nreturn rockchip_gem_alloc_iommu(rk_obj, alloc_kmap);\r\nelse\r\nreturn rockchip_gem_alloc_dma(rk_obj, alloc_kmap);\r\n}\r\nstatic void rockchip_gem_free_iommu(struct rockchip_gem_object *rk_obj)\r\n{\r\nvunmap(rk_obj->kvaddr);\r\nrockchip_gem_iommu_unmap(rk_obj);\r\nrockchip_gem_put_pages(rk_obj);\r\n}\r\nstatic void rockchip_gem_free_dma(struct rockchip_gem_object *rk_obj)\r\n{\r\nstruct drm_gem_object *obj = &rk_obj->base;\r\nstruct drm_device *drm = obj->dev;\r\ndma_free_attrs(drm->dev, obj->size, rk_obj->kvaddr, rk_obj->dma_addr,\r\nrk_obj->dma_attrs);\r\n}\r\nstatic void rockchip_gem_free_buf(struct rockchip_gem_object *rk_obj)\r\n{\r\nif (rk_obj->pages)\r\nrockchip_gem_free_iommu(rk_obj);\r\nelse\r\nrockchip_gem_free_dma(rk_obj);\r\n}\r\nstatic int rockchip_drm_gem_object_mmap_iommu(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);\r\nunsigned int i, count = obj->size >> PAGE_SHIFT;\r\nunsigned long user_count = (vma->vm_end - vma->vm_start) >> PAGE_SHIFT;\r\nunsigned long uaddr = vma->vm_start;\r\nunsigned long offset = vma->vm_pgoff;\r\nunsigned long end = user_count + offset;\r\nint ret;\r\nif (user_count == 0)\r\nreturn -ENXIO;\r\nif (end > count)\r\nreturn -ENXIO;\r\nfor (i = offset; i < end; i++) {\r\nret = vm_insert_page(vma, uaddr, rk_obj->pages[i]);\r\nif (ret)\r\nreturn ret;\r\nuaddr += PAGE_SIZE;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rockchip_drm_gem_object_mmap_dma(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);\r\nstruct drm_device *drm = obj->dev;\r\nreturn dma_mmap_attrs(drm->dev, vma, rk_obj->kvaddr, rk_obj->dma_addr,\r\nobj->size, rk_obj->dma_attrs);\r\n}\r\nstatic int rockchip_drm_gem_object_mmap(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nint ret;\r\nstruct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);\r\nvma->vm_flags &= ~VM_PFNMAP;\r\nvma->vm_pgoff = 0;\r\nif (rk_obj->pages)\r\nret = rockchip_drm_gem_object_mmap_iommu(obj, vma);\r\nelse\r\nret = rockchip_drm_gem_object_mmap_dma(obj, vma);\r\nif (ret)\r\ndrm_gem_vm_close(vma);\r\nreturn ret;\r\n}\r\nint rockchip_gem_mmap_buf(struct drm_gem_object *obj,\r\nstruct vm_area_struct *vma)\r\n{\r\nint ret;\r\nret = drm_gem_mmap_obj(obj, obj->size, vma);\r\nif (ret)\r\nreturn ret;\r\nreturn rockchip_drm_gem_object_mmap(obj, vma);\r\n}\r\nint rockchip_gem_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nret = drm_gem_mmap(filp, vma);\r\nif (ret)\r\nreturn ret;\r\nobj = vma->vm_private_data;\r\nreturn rockchip_drm_gem_object_mmap(obj, vma);\r\n}\r\nstatic void rockchip_gem_release_object(struct rockchip_gem_object *rk_obj)\r\n{\r\ndrm_gem_object_release(&rk_obj->base);\r\nkfree(rk_obj);\r\n}\r\nstruct rockchip_gem_object *\r\nrockchip_gem_create_object(struct drm_device *drm, unsigned int size,\r\nbool alloc_kmap)\r\n{\r\nstruct rockchip_gem_object *rk_obj;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nsize = round_up(size, PAGE_SIZE);\r\nrk_obj = kzalloc(sizeof(*rk_obj), GFP_KERNEL);\r\nif (!rk_obj)\r\nreturn ERR_PTR(-ENOMEM);\r\nobj = &rk_obj->base;\r\ndrm_gem_object_init(drm, obj, size);\r\nret = rockchip_gem_alloc_buf(rk_obj, alloc_kmap);\r\nif (ret)\r\ngoto err_free_rk_obj;\r\nreturn rk_obj;\r\nerr_free_rk_obj:\r\nrockchip_gem_release_object(rk_obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nvoid rockchip_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct rockchip_gem_object *rk_obj;\r\nrk_obj = to_rockchip_obj(obj);\r\nrockchip_gem_free_buf(rk_obj);\r\nrockchip_gem_release_object(rk_obj);\r\n}\r\nstatic struct rockchip_gem_object *\r\nrockchip_gem_create_with_handle(struct drm_file *file_priv,\r\nstruct drm_device *drm, unsigned int size,\r\nunsigned int *handle)\r\n{\r\nstruct rockchip_gem_object *rk_obj;\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nrk_obj = rockchip_gem_create_object(drm, size, false);\r\nif (IS_ERR(rk_obj))\r\nreturn ERR_CAST(rk_obj);\r\nobj = &rk_obj->base;\r\nret = drm_gem_handle_create(file_priv, obj, handle);\r\nif (ret)\r\ngoto err_handle_create;\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn rk_obj;\r\nerr_handle_create:\r\nrockchip_gem_free_object(obj);\r\nreturn ERR_PTR(ret);\r\n}\r\nint rockchip_gem_dumb_map_offset(struct drm_file *file_priv,\r\nstruct drm_device *dev, uint32_t handle,\r\nuint64_t *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nint ret;\r\nobj = drm_gem_object_lookup(file_priv, handle);\r\nif (!obj) {\r\nDRM_ERROR("failed to lookup gem object.\n");\r\nreturn -EINVAL;\r\n}\r\nret = drm_gem_create_mmap_offset(obj);\r\nif (ret)\r\ngoto out;\r\n*offset = drm_vma_node_offset_addr(&obj->vma_node);\r\nDRM_DEBUG_KMS("offset = 0x%llx\n", *offset);\r\nout:\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nint rockchip_gem_dumb_create(struct drm_file *file_priv,\r\nstruct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct rockchip_gem_object *rk_obj;\r\nint min_pitch = DIV_ROUND_UP(args->width * args->bpp, 8);\r\nargs->pitch = ALIGN(min_pitch, 64);\r\nargs->size = args->pitch * args->height;\r\nrk_obj = rockchip_gem_create_with_handle(file_priv, dev, args->size,\r\n&args->handle);\r\nreturn PTR_ERR_OR_ZERO(rk_obj);\r\n}\r\nstruct sg_table *rockchip_gem_prime_get_sg_table(struct drm_gem_object *obj)\r\n{\r\nstruct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);\r\nstruct drm_device *drm = obj->dev;\r\nstruct sg_table *sgt;\r\nint ret;\r\nif (rk_obj->pages)\r\nreturn drm_prime_pages_to_sg(rk_obj->pages, rk_obj->num_pages);\r\nsgt = kzalloc(sizeof(*sgt), GFP_KERNEL);\r\nif (!sgt)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = dma_get_sgtable_attrs(drm->dev, sgt, rk_obj->kvaddr,\r\nrk_obj->dma_addr, obj->size,\r\nrk_obj->dma_attrs);\r\nif (ret) {\r\nDRM_ERROR("failed to allocate sgt, %d\n", ret);\r\nkfree(sgt);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn sgt;\r\n}\r\nvoid *rockchip_gem_prime_vmap(struct drm_gem_object *obj)\r\n{\r\nstruct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);\r\nif (rk_obj->pages)\r\nreturn vmap(rk_obj->pages, rk_obj->num_pages, VM_MAP,\r\npgprot_writecombine(PAGE_KERNEL));\r\nif (rk_obj->dma_attrs & DMA_ATTR_NO_KERNEL_MAPPING)\r\nreturn NULL;\r\nreturn rk_obj->kvaddr;\r\n}\r\nvoid rockchip_gem_prime_vunmap(struct drm_gem_object *obj, void *vaddr)\r\n{\r\nstruct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);\r\nif (rk_obj->pages) {\r\nvunmap(vaddr);\r\nreturn;\r\n}\r\n}
