static inline struct pci_dev *ctrl_dev(struct controller *ctrl)\r\n{\r\nreturn ctrl->pcie->port;\r\n}\r\nstatic void int_poll_timeout(unsigned long data)\r\n{\r\nstruct controller *ctrl = (struct controller *)data;\r\npcie_isr(0, ctrl);\r\ninit_timer(&ctrl->poll_timer);\r\nif (!pciehp_poll_time)\r\npciehp_poll_time = 2;\r\nstart_int_poll_timer(ctrl, pciehp_poll_time);\r\n}\r\nstatic void start_int_poll_timer(struct controller *ctrl, int sec)\r\n{\r\nif ((sec <= 0) || (sec > 60))\r\nsec = 2;\r\nctrl->poll_timer.function = &int_poll_timeout;\r\nctrl->poll_timer.data = (unsigned long)ctrl;\r\nctrl->poll_timer.expires = jiffies + sec * HZ;\r\nadd_timer(&ctrl->poll_timer);\r\n}\r\nstatic inline int pciehp_request_irq(struct controller *ctrl)\r\n{\r\nint retval, irq = ctrl->pcie->irq;\r\nif (pciehp_poll_mode) {\r\ninit_timer(&ctrl->poll_timer);\r\nstart_int_poll_timer(ctrl, 10);\r\nreturn 0;\r\n}\r\nretval = request_irq(irq, pcie_isr, IRQF_SHARED, MY_NAME, ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "Cannot get irq %d for the hotplug controller\n",\r\nirq);\r\nreturn retval;\r\n}\r\nstatic inline void pciehp_free_irq(struct controller *ctrl)\r\n{\r\nif (pciehp_poll_mode)\r\ndel_timer_sync(&ctrl->poll_timer);\r\nelse\r\nfree_irq(ctrl->pcie->irq, ctrl);\r\n}\r\nstatic int pcie_poll_cmd(struct controller *ctrl, int timeout)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_status;\r\nwhile (true) {\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nif (slot_status == (u16) ~0) {\r\nctrl_info(ctrl, "%s: no response from device\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nif (slot_status & PCI_EXP_SLTSTA_CC) {\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_CC);\r\nreturn 1;\r\n}\r\nif (timeout < 0)\r\nbreak;\r\nmsleep(10);\r\ntimeout -= 10;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_wait_cmd(struct controller *ctrl)\r\n{\r\nunsigned int msecs = pciehp_poll_mode ? 2500 : 1000;\r\nunsigned long duration = msecs_to_jiffies(msecs);\r\nunsigned long cmd_timeout = ctrl->cmd_started + duration;\r\nunsigned long now, timeout;\r\nint rc;\r\nif (NO_CMD_CMPL(ctrl))\r\nreturn;\r\nif (!ctrl->cmd_busy)\r\nreturn;\r\nnow = jiffies;\r\nif (time_before_eq(cmd_timeout, now))\r\ntimeout = 1;\r\nelse\r\ntimeout = cmd_timeout - now;\r\nif (ctrl->slot_ctrl & PCI_EXP_SLTCTL_HPIE &&\r\nctrl->slot_ctrl & PCI_EXP_SLTCTL_CCIE)\r\nrc = wait_event_timeout(ctrl->queue, !ctrl->cmd_busy, timeout);\r\nelse\r\nrc = pcie_poll_cmd(ctrl, jiffies_to_msecs(timeout));\r\nif (!rc)\r\nctrl_info(ctrl, "Timeout on hotplug command %#06x (issued %u msec ago)\n",\r\nctrl->slot_ctrl,\r\njiffies_to_msecs(jiffies - ctrl->cmd_started));\r\n}\r\nstatic void pcie_do_write_cmd(struct controller *ctrl, u16 cmd,\r\nu16 mask, bool wait)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_ctrl;\r\nmutex_lock(&ctrl->ctrl_lock);\r\npcie_wait_cmd(ctrl);\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\nif (slot_ctrl == (u16) ~0) {\r\nctrl_info(ctrl, "%s: no response from device\n", __func__);\r\ngoto out;\r\n}\r\nslot_ctrl &= ~mask;\r\nslot_ctrl |= (cmd & mask);\r\nctrl->cmd_busy = 1;\r\nsmp_mb();\r\npcie_capability_write_word(pdev, PCI_EXP_SLTCTL, slot_ctrl);\r\nctrl->cmd_started = jiffies;\r\nctrl->slot_ctrl = slot_ctrl;\r\nif (wait)\r\npcie_wait_cmd(ctrl);\r\nout:\r\nmutex_unlock(&ctrl->ctrl_lock);\r\n}\r\nstatic void pcie_write_cmd(struct controller *ctrl, u16 cmd, u16 mask)\r\n{\r\npcie_do_write_cmd(ctrl, cmd, mask, true);\r\n}\r\nstatic void pcie_write_cmd_nowait(struct controller *ctrl, u16 cmd, u16 mask)\r\n{\r\npcie_do_write_cmd(ctrl, cmd, mask, false);\r\n}\r\nbool pciehp_check_link_active(struct controller *ctrl)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 lnk_status;\r\nbool ret;\r\npcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\r\nret = !!(lnk_status & PCI_EXP_LNKSTA_DLLLA);\r\nif (ret)\r\nctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);\r\nreturn ret;\r\n}\r\nstatic void __pcie_wait_link_active(struct controller *ctrl, bool active)\r\n{\r\nint timeout = 1000;\r\nif (pciehp_check_link_active(ctrl) == active)\r\nreturn;\r\nwhile (timeout > 0) {\r\nmsleep(10);\r\ntimeout -= 10;\r\nif (pciehp_check_link_active(ctrl) == active)\r\nreturn;\r\n}\r\nctrl_dbg(ctrl, "Data Link Layer Link Active not %s in 1000 msec\n",\r\nactive ? "set" : "cleared");\r\n}\r\nstatic void pcie_wait_link_active(struct controller *ctrl)\r\n{\r\n__pcie_wait_link_active(ctrl, true);\r\n}\r\nstatic bool pci_bus_check_dev(struct pci_bus *bus, int devfn)\r\n{\r\nu32 l;\r\nint count = 0;\r\nint delay = 1000, step = 20;\r\nbool found = false;\r\ndo {\r\nfound = pci_bus_read_dev_vendor_id(bus, devfn, &l, 0);\r\ncount++;\r\nif (found)\r\nbreak;\r\nmsleep(step);\r\ndelay -= step;\r\n} while (delay > 0);\r\nif (count > 1 && pciehp_debug)\r\nprintk(KERN_DEBUG "pci %04x:%02x:%02x.%d id reading try %d times with interval %d ms to get %08x\n",\r\npci_domain_nr(bus), bus->number, PCI_SLOT(devfn),\r\nPCI_FUNC(devfn), count, step, l);\r\nreturn found;\r\n}\r\nint pciehp_check_link_status(struct controller *ctrl)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nbool found;\r\nu16 lnk_status;\r\nif (ctrl->link_active_reporting)\r\npcie_wait_link_active(ctrl);\r\nelse\r\nmsleep(1000);\r\nmsleep(100);\r\nfound = pci_bus_check_dev(ctrl->pcie->port->subordinate,\r\nPCI_DEVFN(0, 0));\r\npcie_capability_read_word(pdev, PCI_EXP_LNKSTA, &lnk_status);\r\nctrl_dbg(ctrl, "%s: lnk_status = %x\n", __func__, lnk_status);\r\nif ((lnk_status & PCI_EXP_LNKSTA_LT) ||\r\n!(lnk_status & PCI_EXP_LNKSTA_NLW)) {\r\nctrl_err(ctrl, "link training error: status %#06x\n",\r\nlnk_status);\r\nreturn -1;\r\n}\r\npcie_update_link_speed(ctrl->pcie->port->subordinate, lnk_status);\r\nif (!found)\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int __pciehp_link_set(struct controller *ctrl, bool enable)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 lnk_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &lnk_ctrl);\r\nif (enable)\r\nlnk_ctrl &= ~PCI_EXP_LNKCTL_LD;\r\nelse\r\nlnk_ctrl |= PCI_EXP_LNKCTL_LD;\r\npcie_capability_write_word(pdev, PCI_EXP_LNKCTL, lnk_ctrl);\r\nctrl_dbg(ctrl, "%s: lnk_ctrl = %x\n", __func__, lnk_ctrl);\r\nreturn 0;\r\n}\r\nstatic int pciehp_link_enable(struct controller *ctrl)\r\n{\r\nreturn __pciehp_link_set(ctrl, true);\r\n}\r\nint pciehp_get_raw_indicator_status(struct hotplug_slot *hotplug_slot,\r\nu8 *status)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\n*status = (slot_ctrl & (PCI_EXP_SLTCTL_AIC | PCI_EXP_SLTCTL_PIC)) >> 6;\r\nreturn 0;\r\n}\r\nvoid pciehp_get_attention_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x, value read %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\r\nswitch (slot_ctrl & PCI_EXP_SLTCTL_AIC) {\r\ncase PCI_EXP_SLTCTL_ATTN_IND_ON:\r\n*status = 1;\r\nbreak;\r\ncase PCI_EXP_SLTCTL_ATTN_IND_BLINK:\r\n*status = 2;\r\nbreak;\r\ncase PCI_EXP_SLTCTL_ATTN_IND_OFF:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\n}\r\nvoid pciehp_get_power_status(struct slot *slot, u8 *status)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_ctrl;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &slot_ctrl);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x value read %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_ctrl);\r\nswitch (slot_ctrl & PCI_EXP_SLTCTL_PCC) {\r\ncase PCI_EXP_SLTCTL_PWR_ON:\r\n*status = 1;\r\nbreak;\r\ncase PCI_EXP_SLTCTL_PWR_OFF:\r\n*status = 0;\r\nbreak;\r\ndefault:\r\n*status = 0xFF;\r\nbreak;\r\n}\r\n}\r\nvoid pciehp_get_latch_status(struct slot *slot, u8 *status)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\n*status = !!(slot_status & PCI_EXP_SLTSTA_MRLSS);\r\n}\r\nvoid pciehp_get_adapter_status(struct slot *slot, u8 *status)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\n*status = !!(slot_status & PCI_EXP_SLTSTA_PDS);\r\n}\r\nint pciehp_query_power_fault(struct slot *slot)\r\n{\r\nstruct pci_dev *pdev = ctrl_dev(slot->ctrl);\r\nu16 slot_status;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nreturn !!(slot_status & PCI_EXP_SLTSTA_PFD);\r\n}\r\nint pciehp_set_raw_indicator_status(struct hotplug_slot *hotplug_slot,\r\nu8 status)\r\n{\r\nstruct slot *slot = hotplug_slot->private;\r\nstruct controller *ctrl = slot->ctrl;\r\npcie_write_cmd_nowait(ctrl, status << 6,\r\nPCI_EXP_SLTCTL_AIC | PCI_EXP_SLTCTL_PIC);\r\nreturn 0;\r\n}\r\nvoid pciehp_set_attention_status(struct slot *slot, u8 value)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nu16 slot_cmd;\r\nif (!ATTN_LED(ctrl))\r\nreturn;\r\nswitch (value) {\r\ncase 0:\r\nslot_cmd = PCI_EXP_SLTCTL_ATTN_IND_OFF;\r\nbreak;\r\ncase 1:\r\nslot_cmd = PCI_EXP_SLTCTL_ATTN_IND_ON;\r\nbreak;\r\ncase 2:\r\nslot_cmd = PCI_EXP_SLTCTL_ATTN_IND_BLINK;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\npcie_write_cmd_nowait(ctrl, slot_cmd, PCI_EXP_SLTCTL_AIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, slot_cmd);\r\n}\r\nvoid pciehp_green_led_on(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nif (!PWR_LED(ctrl))\r\nreturn;\r\npcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_PWR_IND_ON,\r\nPCI_EXP_SLTCTL_PIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_IND_ON);\r\n}\r\nvoid pciehp_green_led_off(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nif (!PWR_LED(ctrl))\r\nreturn;\r\npcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_PWR_IND_OFF,\r\nPCI_EXP_SLTCTL_PIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_IND_OFF);\r\n}\r\nvoid pciehp_green_led_blink(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nif (!PWR_LED(ctrl))\r\nreturn;\r\npcie_write_cmd_nowait(ctrl, PCI_EXP_SLTCTL_PWR_IND_BLINK,\r\nPCI_EXP_SLTCTL_PIC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_IND_BLINK);\r\n}\r\nint pciehp_power_on_slot(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 slot_status;\r\nint retval;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &slot_status);\r\nif (slot_status & PCI_EXP_SLTSTA_PFD)\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_PFD);\r\nctrl->power_fault_detected = 0;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_ON, PCI_EXP_SLTCTL_PCC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_ON);\r\nretval = pciehp_link_enable(ctrl);\r\nif (retval)\r\nctrl_err(ctrl, "%s: Can not enable the link!\n", __func__);\r\nreturn retval;\r\n}\r\nvoid pciehp_power_off_slot(struct slot *slot)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\npcie_write_cmd(ctrl, PCI_EXP_SLTCTL_PWR_OFF, PCI_EXP_SLTCTL_PCC);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_PWR_OFF);\r\n}\r\nstatic irqreturn_t pciehp_isr(int irq, void *dev_id)\r\n{\r\nstruct controller *ctrl = (struct controller *)dev_id;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nstruct pci_bus *subordinate = pdev->subordinate;\r\nstruct pci_dev *dev;\r\nstruct slot *slot = ctrl->slot;\r\nu16 status, events;\r\nu8 present;\r\nbool link;\r\nif (pdev->current_state == PCI_D3cold)\r\nreturn IRQ_NONE;\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &status);\r\nif (status == (u16) ~0) {\r\nctrl_info(ctrl, "%s: no response from device\n", __func__);\r\nreturn IRQ_NONE;\r\n}\r\nevents = status & (PCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\r\nPCI_EXP_SLTSTA_PDC | PCI_EXP_SLTSTA_CC |\r\nPCI_EXP_SLTSTA_DLLSC);\r\nif (!events)\r\nreturn IRQ_NONE;\r\nif (events & PCI_EXP_SLTSTA_DLLSC)\r\nlink = pciehp_check_link_active(ctrl);\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA, events);\r\nctrl_dbg(ctrl, "pending interrupts %#06x from Slot Status\n", events);\r\nif (events & PCI_EXP_SLTSTA_CC) {\r\nctrl->cmd_busy = 0;\r\nsmp_mb();\r\nwake_up(&ctrl->queue);\r\n}\r\nif (subordinate) {\r\nlist_for_each_entry(dev, &subordinate->devices, bus_list) {\r\nif (dev->ignore_hotplug) {\r\nctrl_dbg(ctrl, "ignoring hotplug event %#06x (%s requested no hotplug)\n",\r\nevents, pci_name(dev));\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\n}\r\nif (events & PCI_EXP_SLTSTA_ABP) {\r\nctrl_info(ctrl, "Slot(%s): Attention button pressed\n",\r\nslot_name(slot));\r\npciehp_queue_interrupt_event(slot, INT_BUTTON_PRESS);\r\n}\r\nif (events & PCI_EXP_SLTSTA_DLLSC) {\r\nctrl_info(ctrl, "Slot(%s): Link %s\n", slot_name(slot),\r\nlink ? "Up" : "Down");\r\npciehp_queue_interrupt_event(slot, link ? INT_LINK_UP :\r\nINT_LINK_DOWN);\r\n} else if (events & PCI_EXP_SLTSTA_PDC) {\r\npresent = !!(status & PCI_EXP_SLTSTA_PDS);\r\nctrl_info(ctrl, "Slot(%s): Card %spresent\n", slot_name(slot),\r\npresent ? "" : "not ");\r\npciehp_queue_interrupt_event(slot, present ? INT_PRESENCE_ON :\r\nINT_PRESENCE_OFF);\r\n}\r\nif ((events & PCI_EXP_SLTSTA_PFD) && !ctrl->power_fault_detected) {\r\nctrl->power_fault_detected = 1;\r\nctrl_err(ctrl, "Slot(%s): Power fault\n", slot_name(slot));\r\npciehp_queue_interrupt_event(slot, INT_POWER_FAULT);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pcie_isr(int irq, void *dev_id)\r\n{\r\nirqreturn_t rc, handled = IRQ_NONE;\r\ndo {\r\nrc = pciehp_isr(irq, dev_id);\r\nif (rc == IRQ_HANDLED)\r\nhandled = IRQ_HANDLED;\r\n} while (rc == IRQ_HANDLED);\r\nreturn handled;\r\n}\r\nvoid pcie_enable_notification(struct controller *ctrl)\r\n{\r\nu16 cmd, mask;\r\ncmd = PCI_EXP_SLTCTL_DLLSCE;\r\nif (ATTN_BUTTN(ctrl))\r\ncmd |= PCI_EXP_SLTCTL_ABPE;\r\nelse\r\ncmd |= PCI_EXP_SLTCTL_PDCE;\r\nif (!pciehp_poll_mode)\r\ncmd |= PCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE;\r\nmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\r\nPCI_EXP_SLTCTL_PFDE |\r\nPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\npcie_write_cmd_nowait(ctrl, cmd, mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, cmd);\r\n}\r\nstatic void pcie_disable_notification(struct controller *ctrl)\r\n{\r\nu16 mask;\r\nmask = (PCI_EXP_SLTCTL_PDCE | PCI_EXP_SLTCTL_ABPE |\r\nPCI_EXP_SLTCTL_MRLSCE | PCI_EXP_SLTCTL_PFDE |\r\nPCI_EXP_SLTCTL_HPIE | PCI_EXP_SLTCTL_CCIE |\r\nPCI_EXP_SLTCTL_DLLSCE);\r\npcie_write_cmd(ctrl, 0, mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);\r\n}\r\nint pciehp_reset_slot(struct slot *slot, int probe)\r\n{\r\nstruct controller *ctrl = slot->ctrl;\r\nstruct pci_dev *pdev = ctrl_dev(ctrl);\r\nu16 stat_mask = 0, ctrl_mask = 0;\r\nif (probe)\r\nreturn 0;\r\nif (!ATTN_BUTTN(ctrl)) {\r\nctrl_mask |= PCI_EXP_SLTCTL_PDCE;\r\nstat_mask |= PCI_EXP_SLTSTA_PDC;\r\n}\r\nctrl_mask |= PCI_EXP_SLTCTL_DLLSCE;\r\nstat_mask |= PCI_EXP_SLTSTA_DLLSC;\r\npcie_write_cmd(ctrl, 0, ctrl_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, 0);\r\nif (pciehp_poll_mode)\r\ndel_timer_sync(&ctrl->poll_timer);\r\npci_reset_bridge_secondary_bus(ctrl->pcie->port);\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA, stat_mask);\r\npcie_write_cmd_nowait(ctrl, ctrl_mask, ctrl_mask);\r\nctrl_dbg(ctrl, "%s: SLOTCTRL %x write cmd %x\n", __func__,\r\npci_pcie_cap(ctrl->pcie->port) + PCI_EXP_SLTCTL, ctrl_mask);\r\nif (pciehp_poll_mode)\r\nint_poll_timeout(ctrl->poll_timer.data);\r\nreturn 0;\r\n}\r\nint pcie_init_notification(struct controller *ctrl)\r\n{\r\nif (pciehp_request_irq(ctrl))\r\nreturn -1;\r\npcie_enable_notification(ctrl);\r\nctrl->notification_enabled = 1;\r\nreturn 0;\r\n}\r\nstatic void pcie_shutdown_notification(struct controller *ctrl)\r\n{\r\nif (ctrl->notification_enabled) {\r\npcie_disable_notification(ctrl);\r\npciehp_free_irq(ctrl);\r\nctrl->notification_enabled = 0;\r\n}\r\n}\r\nstatic int pcie_init_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot;\r\nslot = kzalloc(sizeof(*slot), GFP_KERNEL);\r\nif (!slot)\r\nreturn -ENOMEM;\r\nslot->wq = alloc_workqueue("pciehp-%u", 0, 0, PSN(ctrl));\r\nif (!slot->wq)\r\ngoto abort;\r\nslot->ctrl = ctrl;\r\nmutex_init(&slot->lock);\r\nmutex_init(&slot->hotplug_lock);\r\nINIT_DELAYED_WORK(&slot->work, pciehp_queue_pushbutton_work);\r\nctrl->slot = slot;\r\nreturn 0;\r\nabort:\r\nkfree(slot);\r\nreturn -ENOMEM;\r\n}\r\nstatic void pcie_cleanup_slot(struct controller *ctrl)\r\n{\r\nstruct slot *slot = ctrl->slot;\r\ncancel_delayed_work(&slot->work);\r\ndestroy_workqueue(slot->wq);\r\nkfree(slot);\r\n}\r\nstatic inline void dbg_ctrl(struct controller *ctrl)\r\n{\r\nstruct pci_dev *pdev = ctrl->pcie->port;\r\nu16 reg16;\r\nif (!pciehp_debug)\r\nreturn;\r\nctrl_info(ctrl, "Slot Capabilities : 0x%08x\n", ctrl->slot_cap);\r\npcie_capability_read_word(pdev, PCI_EXP_SLTSTA, &reg16);\r\nctrl_info(ctrl, "Slot Status : 0x%04x\n", reg16);\r\npcie_capability_read_word(pdev, PCI_EXP_SLTCTL, &reg16);\r\nctrl_info(ctrl, "Slot Control : 0x%04x\n", reg16);\r\n}\r\nstruct controller *pcie_init(struct pcie_device *dev)\r\n{\r\nstruct controller *ctrl;\r\nu32 slot_cap, link_cap;\r\nstruct pci_dev *pdev = dev->port;\r\nctrl = kzalloc(sizeof(*ctrl), GFP_KERNEL);\r\nif (!ctrl) {\r\ndev_err(&dev->device, "%s: Out of memory\n", __func__);\r\ngoto abort;\r\n}\r\nctrl->pcie = dev;\r\npcie_capability_read_dword(pdev, PCI_EXP_SLTCAP, &slot_cap);\r\nif (pdev->hotplug_user_indicators)\r\nslot_cap &= ~(PCI_EXP_SLTCAP_AIP | PCI_EXP_SLTCAP_PIP);\r\nctrl->slot_cap = slot_cap;\r\nmutex_init(&ctrl->ctrl_lock);\r\ninit_waitqueue_head(&ctrl->queue);\r\ndbg_ctrl(ctrl);\r\npcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &link_cap);\r\nif (link_cap & PCI_EXP_LNKCAP_DLLLARC)\r\nctrl->link_active_reporting = 1;\r\npcie_capability_write_word(pdev, PCI_EXP_SLTSTA,\r\nPCI_EXP_SLTSTA_ABP | PCI_EXP_SLTSTA_PFD |\r\nPCI_EXP_SLTSTA_MRLSC | PCI_EXP_SLTSTA_PDC |\r\nPCI_EXP_SLTSTA_CC | PCI_EXP_SLTSTA_DLLSC);\r\nctrl_info(ctrl, "Slot #%d AttnBtn%c PwrCtrl%c MRL%c AttnInd%c PwrInd%c HotPlug%c Surprise%c Interlock%c NoCompl%c LLActRep%c\n",\r\n(slot_cap & PCI_EXP_SLTCAP_PSN) >> 19,\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_ABP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_PCP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_MRLSP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_AIP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_PIP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_HPC),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_HPS),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_EIP),\r\nFLAG(slot_cap, PCI_EXP_SLTCAP_NCCS),\r\nFLAG(link_cap, PCI_EXP_LNKCAP_DLLLARC));\r\nif (pcie_init_slot(ctrl))\r\ngoto abort_ctrl;\r\nreturn ctrl;\r\nabort_ctrl:\r\nkfree(ctrl);\r\nabort:\r\nreturn NULL;\r\n}\r\nvoid pciehp_release_ctrl(struct controller *ctrl)\r\n{\r\npcie_shutdown_notification(ctrl);\r\npcie_cleanup_slot(ctrl);\r\nkfree(ctrl);\r\n}
