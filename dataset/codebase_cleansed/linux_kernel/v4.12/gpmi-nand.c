static int gpmi_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nif (section)\r\nreturn -ERANGE;\r\noobregion->offset = 0;\r\noobregion->length = geo->page_size - mtd->writesize;\r\nreturn 0;\r\n}\r\nstatic int gpmi_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nif (section)\r\nreturn -ERANGE;\r\nif (geo->page_size < mtd->writesize + mtd->oobsize) {\r\noobregion->offset = geo->page_size - mtd->writesize;\r\noobregion->length = mtd->oobsize - oobregion->offset;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bch_irq(int irq, void *cookie)\r\n{\r\nstruct gpmi_nand_data *this = cookie;\r\ngpmi_clear_bch(this);\r\ncomplete(&this->bch_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic inline int get_ecc_strength(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct mtd_info *mtd = nand_to_mtd(&this->nand);\r\nint ecc_strength;\r\necc_strength = ((mtd->oobsize - geo->metadata_size) * 8)\r\n/ (geo->gf_len * geo->ecc_chunk_count);\r\nreturn round_down(ecc_strength, 2);\r\n}\r\nstatic inline bool gpmi_check_ecc(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nif (GPMI_IS_MX23(this) || GPMI_IS_MX28(this)) {\r\nif (geo->gf_len == 14)\r\nreturn false;\r\n}\r\nreturn geo->ecc_strength <= this->devdata->bch_max_ecc_strength;\r\n}\r\nstatic int set_geometry_by_ecc_info(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nunsigned int block_mark_bit_offset;\r\nif (!(chip->ecc_strength_ds > 0 && chip->ecc_step_ds > 0))\r\nreturn -EINVAL;\r\nswitch (chip->ecc_step_ds) {\r\ncase SZ_512:\r\ngeo->gf_len = 13;\r\nbreak;\r\ncase SZ_1K:\r\ngeo->gf_len = 14;\r\nbreak;\r\ndefault:\r\ndev_err(this->dev,\r\n"unsupported nand chip. ecc bits : %d, ecc size : %d\n",\r\nchip->ecc_strength_ds, chip->ecc_step_ds);\r\nreturn -EINVAL;\r\n}\r\ngeo->ecc_chunk_size = chip->ecc_step_ds;\r\ngeo->ecc_strength = round_up(chip->ecc_strength_ds, 2);\r\nif (!gpmi_check_ecc(this))\r\nreturn -EINVAL;\r\nif (geo->ecc_chunk_size < mtd->oobsize) {\r\ndev_err(this->dev,\r\n"unsupported nand chip. ecc size: %d, oob size : %d\n",\r\nchip->ecc_step_ds, mtd->oobsize);\r\nreturn -EINVAL;\r\n}\r\ngeo->metadata_size = 10;\r\ngeo->ecc_chunk_count = mtd->writesize / geo->ecc_chunk_size;\r\ngeo->page_size = mtd->writesize + geo->metadata_size +\r\n(geo->gf_len * geo->ecc_strength * geo->ecc_chunk_count) / 8;\r\ngeo->payload_size = mtd->writesize;\r\ngeo->auxiliary_status_offset = ALIGN(geo->metadata_size, 4);\r\ngeo->auxiliary_size = ALIGN(geo->metadata_size, 4)\r\n+ ALIGN(geo->ecc_chunk_count, 4);\r\nif (!this->swap_block_mark)\r\nreturn 0;\r\nblock_mark_bit_offset = mtd->writesize * 8 -\r\n(geo->ecc_strength * geo->gf_len * (geo->ecc_chunk_count - 1)\r\n+ geo->metadata_size * 8);\r\ngeo->block_mark_byte_offset = block_mark_bit_offset / 8;\r\ngeo->block_mark_bit_offset = block_mark_bit_offset % 8;\r\nreturn 0;\r\n}\r\nstatic int legacy_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct mtd_info *mtd = nand_to_mtd(&this->nand);\r\nunsigned int metadata_size;\r\nunsigned int status_size;\r\nunsigned int block_mark_bit_offset;\r\ngeo->metadata_size = 10;\r\ngeo->gf_len = 13;\r\ngeo->ecc_chunk_size = 512;\r\nwhile (geo->ecc_chunk_size < mtd->oobsize) {\r\ngeo->ecc_chunk_size *= 2;\r\ngeo->gf_len = 14;\r\n}\r\ngeo->ecc_chunk_count = mtd->writesize / geo->ecc_chunk_size;\r\ngeo->ecc_strength = get_ecc_strength(this);\r\nif (!gpmi_check_ecc(this)) {\r\ndev_err(this->dev,\r\n"ecc strength: %d cannot be supported by the controller (%d)\n"\r\n"try to use minimum ecc strength that NAND chip required\n",\r\ngeo->ecc_strength,\r\nthis->devdata->bch_max_ecc_strength);\r\nreturn -EINVAL;\r\n}\r\ngeo->page_size = mtd->writesize + geo->metadata_size +\r\n(geo->gf_len * geo->ecc_strength * geo->ecc_chunk_count) / 8;\r\ngeo->payload_size = mtd->writesize;\r\nmetadata_size = ALIGN(geo->metadata_size, 4);\r\nstatus_size = ALIGN(geo->ecc_chunk_count, 4);\r\ngeo->auxiliary_size = metadata_size + status_size;\r\ngeo->auxiliary_status_offset = metadata_size;\r\nif (!this->swap_block_mark)\r\nreturn 0;\r\nblock_mark_bit_offset = mtd->writesize * 8 -\r\n(geo->ecc_strength * geo->gf_len * (geo->ecc_chunk_count - 1)\r\n+ geo->metadata_size * 8);\r\ngeo->block_mark_byte_offset = block_mark_bit_offset / 8;\r\ngeo->block_mark_bit_offset = block_mark_bit_offset % 8;\r\nreturn 0;\r\n}\r\nint common_nfc_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nif ((of_property_read_bool(this->dev->of_node, "fsl,use-minimum-ecc"))\r\n|| legacy_set_geometry(this))\r\nreturn set_geometry_by_ecc_info(this);\r\nreturn 0;\r\n}\r\nstruct dma_chan *get_dma_chan(struct gpmi_nand_data *this)\r\n{\r\nreturn this->dma_chans[0];\r\n}\r\nvoid prepare_data_dma(struct gpmi_nand_data *this, enum dma_data_direction dr)\r\n{\r\nstruct scatterlist *sgl = &this->data_sgl;\r\nint ret;\r\nif (virt_addr_valid(this->upper_buf) &&\r\n!object_is_on_stack(this->upper_buf)) {\r\nsg_init_one(sgl, this->upper_buf, this->upper_len);\r\nret = dma_map_sg(this->dev, sgl, 1, dr);\r\nif (ret == 0)\r\ngoto map_fail;\r\nthis->direct_dma_map_ok = true;\r\nreturn;\r\n}\r\nmap_fail:\r\nsg_init_one(sgl, this->data_buffer_dma, this->upper_len);\r\nif (dr == DMA_TO_DEVICE)\r\nmemcpy(this->data_buffer_dma, this->upper_buf, this->upper_len);\r\ndma_map_sg(this->dev, sgl, 1, dr);\r\nthis->direct_dma_map_ok = false;\r\n}\r\nstatic void dma_irq_callback(void *param)\r\n{\r\nstruct gpmi_nand_data *this = param;\r\nstruct completion *dma_c = &this->dma_done;\r\nswitch (this->dma_type) {\r\ncase DMA_FOR_COMMAND:\r\ndma_unmap_sg(this->dev, &this->cmd_sgl, 1, DMA_TO_DEVICE);\r\nbreak;\r\ncase DMA_FOR_READ_DATA:\r\ndma_unmap_sg(this->dev, &this->data_sgl, 1, DMA_FROM_DEVICE);\r\nif (this->direct_dma_map_ok == false)\r\nmemcpy(this->upper_buf, this->data_buffer_dma,\r\nthis->upper_len);\r\nbreak;\r\ncase DMA_FOR_WRITE_DATA:\r\ndma_unmap_sg(this->dev, &this->data_sgl, 1, DMA_TO_DEVICE);\r\nbreak;\r\ncase DMA_FOR_READ_ECC_PAGE:\r\ncase DMA_FOR_WRITE_ECC_PAGE:\r\nbreak;\r\ndefault:\r\ndev_err(this->dev, "in wrong DMA operation.\n");\r\n}\r\ncomplete(dma_c);\r\n}\r\nint start_dma_without_bch_irq(struct gpmi_nand_data *this,\r\nstruct dma_async_tx_descriptor *desc)\r\n{\r\nstruct completion *dma_c = &this->dma_done;\r\nunsigned long timeout;\r\ninit_completion(dma_c);\r\ndesc->callback = dma_irq_callback;\r\ndesc->callback_param = this;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(get_dma_chan(this));\r\ntimeout = wait_for_completion_timeout(dma_c, msecs_to_jiffies(1000));\r\nif (!timeout) {\r\ndev_err(this->dev, "DMA timeout, last DMA :%d\n",\r\nthis->last_dma_type);\r\ngpmi_dump_info(this);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nint start_dma_with_bch_irq(struct gpmi_nand_data *this,\r\nstruct dma_async_tx_descriptor *desc)\r\n{\r\nstruct completion *bch_c = &this->bch_done;\r\nunsigned long timeout;\r\ninit_completion(bch_c);\r\nstart_dma_without_bch_irq(this, desc);\r\ntimeout = wait_for_completion_timeout(bch_c, msecs_to_jiffies(1000));\r\nif (!timeout) {\r\ndev_err(this->dev, "BCH timeout, last DMA :%d\n",\r\nthis->last_dma_type);\r\ngpmi_dump_info(this);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int acquire_register_block(struct gpmi_nand_data *this,\r\nconst char *res_name)\r\n{\r\nstruct platform_device *pdev = this->pdev;\r\nstruct resources *res = &this->resources;\r\nstruct resource *r;\r\nvoid __iomem *p;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_MEM, res_name);\r\np = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(p))\r\nreturn PTR_ERR(p);\r\nif (!strcmp(res_name, GPMI_NAND_GPMI_REGS_ADDR_RES_NAME))\r\nres->gpmi_regs = p;\r\nelse if (!strcmp(res_name, GPMI_NAND_BCH_REGS_ADDR_RES_NAME))\r\nres->bch_regs = p;\r\nelse\r\ndev_err(this->dev, "unknown resource name : %s\n", res_name);\r\nreturn 0;\r\n}\r\nstatic int acquire_bch_irq(struct gpmi_nand_data *this, irq_handler_t irq_h)\r\n{\r\nstruct platform_device *pdev = this->pdev;\r\nconst char *res_name = GPMI_NAND_BCH_INTERRUPT_RES_NAME;\r\nstruct resource *r;\r\nint err;\r\nr = platform_get_resource_byname(pdev, IORESOURCE_IRQ, res_name);\r\nif (!r) {\r\ndev_err(this->dev, "Can't get resource for %s\n", res_name);\r\nreturn -ENODEV;\r\n}\r\nerr = devm_request_irq(this->dev, r->start, irq_h, 0, res_name, this);\r\nif (err)\r\ndev_err(this->dev, "error requesting BCH IRQ\n");\r\nreturn err;\r\n}\r\nstatic void release_dma_channels(struct gpmi_nand_data *this)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < DMA_CHANS; i++)\r\nif (this->dma_chans[i]) {\r\ndma_release_channel(this->dma_chans[i]);\r\nthis->dma_chans[i] = NULL;\r\n}\r\n}\r\nstatic int acquire_dma_channels(struct gpmi_nand_data *this)\r\n{\r\nstruct platform_device *pdev = this->pdev;\r\nstruct dma_chan *dma_chan;\r\ndma_chan = dma_request_slave_channel(&pdev->dev, "rx-tx");\r\nif (!dma_chan) {\r\ndev_err(this->dev, "Failed to request DMA channel.\n");\r\ngoto acquire_err;\r\n}\r\nthis->dma_chans[0] = dma_chan;\r\nreturn 0;\r\nacquire_err:\r\nrelease_dma_channels(this);\r\nreturn -EINVAL;\r\n}\r\nstatic int gpmi_get_clks(struct gpmi_nand_data *this)\r\n{\r\nstruct resources *r = &this->resources;\r\nchar **extra_clks = NULL;\r\nstruct clk *clk;\r\nint err, i;\r\nr->clock[0] = devm_clk_get(this->dev, "gpmi_io");\r\nif (IS_ERR(r->clock[0])) {\r\nerr = PTR_ERR(r->clock[0]);\r\ngoto err_clock;\r\n}\r\nif (GPMI_IS_MX6(this))\r\nextra_clks = extra_clks_for_mx6q;\r\nif (!extra_clks)\r\nreturn 0;\r\nfor (i = 1; i < GPMI_CLK_MAX; i++) {\r\nif (extra_clks[i - 1] == NULL)\r\nbreak;\r\nclk = devm_clk_get(this->dev, extra_clks[i - 1]);\r\nif (IS_ERR(clk)) {\r\nerr = PTR_ERR(clk);\r\ngoto err_clock;\r\n}\r\nr->clock[i] = clk;\r\n}\r\nif (GPMI_IS_MX6(this))\r\nclk_set_rate(r->clock[0], 22000000);\r\nreturn 0;\r\nerr_clock:\r\ndev_dbg(this->dev, "failed in finding the clocks.\n");\r\nreturn err;\r\n}\r\nstatic int acquire_resources(struct gpmi_nand_data *this)\r\n{\r\nint ret;\r\nret = acquire_register_block(this, GPMI_NAND_GPMI_REGS_ADDR_RES_NAME);\r\nif (ret)\r\ngoto exit_regs;\r\nret = acquire_register_block(this, GPMI_NAND_BCH_REGS_ADDR_RES_NAME);\r\nif (ret)\r\ngoto exit_regs;\r\nret = acquire_bch_irq(this, bch_irq);\r\nif (ret)\r\ngoto exit_regs;\r\nret = acquire_dma_channels(this);\r\nif (ret)\r\ngoto exit_regs;\r\nret = gpmi_get_clks(this);\r\nif (ret)\r\ngoto exit_clock;\r\nreturn 0;\r\nexit_clock:\r\nrelease_dma_channels(this);\r\nexit_regs:\r\nreturn ret;\r\n}\r\nstatic void release_resources(struct gpmi_nand_data *this)\r\n{\r\nrelease_dma_channels(this);\r\n}\r\nstatic int init_hardware(struct gpmi_nand_data *this)\r\n{\r\nint ret;\r\nstruct nand_timing safe_timing = {\r\n.data_setup_in_ns = 80,\r\n.data_hold_in_ns = 60,\r\n.address_setup_in_ns = 25,\r\n.gpmi_sample_delay_in_ns = 6,\r\n.tREA_in_ns = -1,\r\n.tRLOH_in_ns = -1,\r\n.tRHOH_in_ns = -1,\r\n};\r\nret = gpmi_init(this);\r\nif (ret)\r\nreturn ret;\r\nthis->timing = safe_timing;\r\nreturn 0;\r\n}\r\nstatic int read_page_prepare(struct gpmi_nand_data *this,\r\nvoid *destination, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nvoid **use_virt, dma_addr_t *use_phys)\r\n{\r\nstruct device *dev = this->dev;\r\nif (virt_addr_valid(destination)) {\r\ndma_addr_t dest_phys;\r\ndest_phys = dma_map_single(dev, destination,\r\nlength, DMA_FROM_DEVICE);\r\nif (dma_mapping_error(dev, dest_phys)) {\r\nif (alt_size < length) {\r\ndev_err(dev, "Alternate buffer is too small\n");\r\nreturn -ENOMEM;\r\n}\r\ngoto map_failed;\r\n}\r\n*use_virt = destination;\r\n*use_phys = dest_phys;\r\nthis->direct_dma_map_ok = true;\r\nreturn 0;\r\n}\r\nmap_failed:\r\n*use_virt = alt_virt;\r\n*use_phys = alt_phys;\r\nthis->direct_dma_map_ok = false;\r\nreturn 0;\r\n}\r\nstatic inline void read_page_end(struct gpmi_nand_data *this,\r\nvoid *destination, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nvoid *used_virt, dma_addr_t used_phys)\r\n{\r\nif (this->direct_dma_map_ok)\r\ndma_unmap_single(this->dev, used_phys, length, DMA_FROM_DEVICE);\r\n}\r\nstatic inline void read_page_swap_end(struct gpmi_nand_data *this,\r\nvoid *destination, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nvoid *used_virt, dma_addr_t used_phys)\r\n{\r\nif (!this->direct_dma_map_ok)\r\nmemcpy(destination, alt_virt, length);\r\n}\r\nstatic int send_page_prepare(struct gpmi_nand_data *this,\r\nconst void *source, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nconst void **use_virt, dma_addr_t *use_phys)\r\n{\r\nstruct device *dev = this->dev;\r\nif (virt_addr_valid(source)) {\r\ndma_addr_t source_phys;\r\nsource_phys = dma_map_single(dev, (void *)source, length,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, source_phys)) {\r\nif (alt_size < length) {\r\ndev_err(dev, "Alternate buffer is too small\n");\r\nreturn -ENOMEM;\r\n}\r\ngoto map_failed;\r\n}\r\n*use_virt = source;\r\n*use_phys = source_phys;\r\nreturn 0;\r\n}\r\nmap_failed:\r\nmemcpy(alt_virt, source, length);\r\n*use_virt = alt_virt;\r\n*use_phys = alt_phys;\r\nreturn 0;\r\n}\r\nstatic void send_page_end(struct gpmi_nand_data *this,\r\nconst void *source, unsigned length,\r\nvoid *alt_virt, dma_addr_t alt_phys, unsigned alt_size,\r\nconst void *used_virt, dma_addr_t used_phys)\r\n{\r\nstruct device *dev = this->dev;\r\nif (used_virt == source)\r\ndma_unmap_single(dev, used_phys, length, DMA_TO_DEVICE);\r\n}\r\nstatic void gpmi_free_dma_buffer(struct gpmi_nand_data *this)\r\n{\r\nstruct device *dev = this->dev;\r\nif (this->page_buffer_virt && virt_addr_valid(this->page_buffer_virt))\r\ndma_free_coherent(dev, this->page_buffer_size,\r\nthis->page_buffer_virt,\r\nthis->page_buffer_phys);\r\nkfree(this->cmd_buffer);\r\nkfree(this->data_buffer_dma);\r\nkfree(this->raw_buffer);\r\nthis->cmd_buffer = NULL;\r\nthis->data_buffer_dma = NULL;\r\nthis->raw_buffer = NULL;\r\nthis->page_buffer_virt = NULL;\r\nthis->page_buffer_size = 0;\r\n}\r\nstatic int gpmi_alloc_dma_buffer(struct gpmi_nand_data *this)\r\n{\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nstruct device *dev = this->dev;\r\nstruct mtd_info *mtd = nand_to_mtd(&this->nand);\r\nthis->cmd_buffer = kzalloc(PAGE_SIZE, GFP_DMA | GFP_KERNEL);\r\nif (this->cmd_buffer == NULL)\r\ngoto error_alloc;\r\nthis->data_buffer_dma = kzalloc(mtd->writesize ?: PAGE_SIZE,\r\nGFP_DMA | GFP_KERNEL);\r\nif (this->data_buffer_dma == NULL)\r\ngoto error_alloc;\r\nthis->page_buffer_size = geo->payload_size + geo->auxiliary_size;\r\nthis->page_buffer_virt = dma_alloc_coherent(dev, this->page_buffer_size,\r\n&this->page_buffer_phys, GFP_DMA);\r\nif (!this->page_buffer_virt)\r\ngoto error_alloc;\r\nthis->raw_buffer = kzalloc(mtd->writesize + mtd->oobsize, GFP_KERNEL);\r\nif (!this->raw_buffer)\r\ngoto error_alloc;\r\nthis->payload_virt = this->page_buffer_virt;\r\nthis->payload_phys = this->page_buffer_phys;\r\nthis->auxiliary_virt = this->payload_virt + geo->payload_size;\r\nthis->auxiliary_phys = this->payload_phys + geo->payload_size;\r\nreturn 0;\r\nerror_alloc:\r\ngpmi_free_dma_buffer(this);\r\nreturn -ENOMEM;\r\n}\r\nstatic void gpmi_cmd_ctrl(struct mtd_info *mtd, int data, unsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nint ret;\r\nif ((ctrl & (NAND_ALE | NAND_CLE))) {\r\nif (data != NAND_CMD_NONE)\r\nthis->cmd_buffer[this->command_length++] = data;\r\nreturn;\r\n}\r\nif (!this->command_length)\r\nreturn;\r\nret = gpmi_send_command(this);\r\nif (ret)\r\ndev_err(this->dev, "Chip: %u, Error %d\n",\r\nthis->current_chip, ret);\r\nthis->command_length = 0;\r\n}\r\nstatic int gpmi_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nreturn gpmi_is_ready(this, this->current_chip);\r\n}\r\nstatic void gpmi_select_chip(struct mtd_info *mtd, int chipnr)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nif ((this->current_chip < 0) && (chipnr >= 0))\r\ngpmi_begin(this);\r\nelse if ((this->current_chip >= 0) && (chipnr < 0))\r\ngpmi_end(this);\r\nthis->current_chip = chipnr;\r\n}\r\nstatic void gpmi_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\ndev_dbg(this->dev, "len is %d\n", len);\r\nthis->upper_buf = buf;\r\nthis->upper_len = len;\r\ngpmi_read_data(this);\r\n}\r\nstatic void gpmi_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\ndev_dbg(this->dev, "len is %d\n", len);\r\nthis->upper_buf = (uint8_t *)buf;\r\nthis->upper_len = len;\r\ngpmi_send_data(this);\r\n}\r\nstatic uint8_t gpmi_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nuint8_t *buf = this->data_buffer_dma;\r\ngpmi_read_buf(mtd, buf, 1);\r\nreturn buf[0];\r\n}\r\nstatic void block_mark_swapping(struct gpmi_nand_data *this,\r\nvoid *payload, void *auxiliary)\r\n{\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nunsigned char *p;\r\nunsigned char *a;\r\nunsigned int bit;\r\nunsigned char mask;\r\nunsigned char from_data;\r\nunsigned char from_oob;\r\nif (!this->swap_block_mark)\r\nreturn;\r\nbit = nfc_geo->block_mark_bit_offset;\r\np = payload + nfc_geo->block_mark_byte_offset;\r\na = auxiliary;\r\nfrom_data = (p[0] >> bit) | (p[1] << (8 - bit));\r\nfrom_oob = a[0];\r\na[0] = from_data;\r\nmask = (0x1 << bit) - 1;\r\np[0] = (p[0] & mask) | (from_oob << bit);\r\nmask = ~0 << bit;\r\np[1] = (p[1] & mask) | (from_oob >> (8 - bit));\r\n}\r\nstatic int gpmi_ecc_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nvoid *payload_virt;\r\ndma_addr_t payload_phys;\r\nvoid *auxiliary_virt;\r\ndma_addr_t auxiliary_phys;\r\nunsigned int i;\r\nunsigned char *status;\r\nunsigned int max_bitflips = 0;\r\nint ret;\r\ndev_dbg(this->dev, "page number is : %d\n", page);\r\nret = read_page_prepare(this, buf, nfc_geo->payload_size,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\n&payload_virt, &payload_phys);\r\nif (ret) {\r\ndev_err(this->dev, "Inadequate DMA buffer\n");\r\nret = -ENOMEM;\r\nreturn ret;\r\n}\r\nauxiliary_virt = this->auxiliary_virt;\r\nauxiliary_phys = this->auxiliary_phys;\r\nret = gpmi_read_page(this, payload_phys, auxiliary_phys);\r\nread_page_end(this, buf, nfc_geo->payload_size,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\npayload_virt, payload_phys);\r\nif (ret) {\r\ndev_err(this->dev, "Error in ECC-based read: %d\n", ret);\r\nreturn ret;\r\n}\r\nblock_mark_swapping(this, payload_virt, auxiliary_virt);\r\nstatus = auxiliary_virt + nfc_geo->auxiliary_status_offset;\r\nread_page_swap_end(this, buf, nfc_geo->payload_size,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\npayload_virt, payload_phys);\r\nfor (i = 0; i < nfc_geo->ecc_chunk_count; i++, status++) {\r\nif ((*status == STATUS_GOOD) || (*status == STATUS_ERASED))\r\ncontinue;\r\nif (*status == STATUS_UNCORRECTABLE) {\r\nint eccbits = nfc_geo->ecc_strength * nfc_geo->gf_len;\r\nu8 *eccbuf = this->raw_buffer;\r\nint offset, bitoffset;\r\nint eccbytes;\r\nint flips;\r\noffset = nfc_geo->metadata_size * 8;\r\noffset += ((8 * nfc_geo->ecc_chunk_size) + eccbits) * (i + 1);\r\noffset -= eccbits;\r\nbitoffset = offset % 8;\r\neccbytes = DIV_ROUND_UP(offset + eccbits, 8);\r\noffset /= 8;\r\neccbytes -= offset;\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, offset, -1);\r\nchip->read_buf(mtd, eccbuf, eccbytes);\r\nif (bitoffset)\r\neccbuf[0] |= GENMASK(bitoffset - 1, 0);\r\nbitoffset = (bitoffset + eccbits) % 8;\r\nif (bitoffset)\r\neccbuf[eccbytes - 1] |= GENMASK(7, bitoffset);\r\nif (i == 0) {\r\nflips = nand_check_erased_ecc_chunk(\r\nbuf + i * nfc_geo->ecc_chunk_size,\r\nnfc_geo->ecc_chunk_size,\r\neccbuf, eccbytes,\r\nauxiliary_virt,\r\nnfc_geo->metadata_size,\r\nnfc_geo->ecc_strength);\r\n} else {\r\nflips = nand_check_erased_ecc_chunk(\r\nbuf + i * nfc_geo->ecc_chunk_size,\r\nnfc_geo->ecc_chunk_size,\r\neccbuf, eccbytes,\r\nNULL, 0,\r\nnfc_geo->ecc_strength);\r\n}\r\nif (flips > 0) {\r\nmax_bitflips = max_t(unsigned int, max_bitflips,\r\nflips);\r\nmtd->ecc_stats.corrected += flips;\r\ncontinue;\r\n}\r\nmtd->ecc_stats.failed++;\r\ncontinue;\r\n}\r\nmtd->ecc_stats.corrected += *status;\r\nmax_bitflips = max_t(unsigned int, max_bitflips, *status);\r\n}\r\nif (oob_required) {\r\nmemset(chip->oob_poi, ~0, mtd->oobsize);\r\nchip->oob_poi[0] = ((uint8_t *) auxiliary_virt)[0];\r\n}\r\nreturn max_bitflips;\r\n}\r\nstatic int gpmi_ecc_read_subpage(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint32_t offs, uint32_t len, uint8_t *buf, int page)\r\n{\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nvoid __iomem *bch_regs = this->resources.bch_regs;\r\nstruct bch_geometry old_geo = this->bch_geometry;\r\nstruct bch_geometry *geo = &this->bch_geometry;\r\nint size = chip->ecc.size;\r\nint meta, n, page_size;\r\nu32 r1_old, r2_old, r1_new, r2_new;\r\nunsigned int max_bitflips;\r\nint first, last, marker_pos;\r\nint ecc_parity_size;\r\nint col = 0;\r\nint old_swap_block_mark = this->swap_block_mark;\r\necc_parity_size = geo->gf_len * geo->ecc_strength / 8;\r\nfirst = offs / size;\r\nlast = (offs + len - 1) / size;\r\nif (this->swap_block_mark) {\r\nmarker_pos = geo->block_mark_byte_offset / size;\r\nif (last >= marker_pos && first <= marker_pos) {\r\ndev_dbg(this->dev,\r\n"page:%d, first:%d, last:%d, marker at:%d\n",\r\npage, first, last, marker_pos);\r\nreturn gpmi_ecc_read_page(mtd, chip, buf, 0, page);\r\n}\r\n}\r\nmeta = geo->metadata_size;\r\nif (first) {\r\ncol = meta + (size + ecc_parity_size) * first;\r\nchip->cmdfunc(mtd, NAND_CMD_RNDOUT, col, -1);\r\nmeta = 0;\r\nbuf = buf + first * size;\r\n}\r\nr1_old = r1_new = readl(bch_regs + HW_BCH_FLASH0LAYOUT0);\r\nr2_old = r2_new = readl(bch_regs + HW_BCH_FLASH0LAYOUT1);\r\nn = last - first + 1;\r\npage_size = meta + (size + ecc_parity_size) * n;\r\nr1_new &= ~(BM_BCH_FLASH0LAYOUT0_NBLOCKS |\r\nBM_BCH_FLASH0LAYOUT0_META_SIZE);\r\nr1_new |= BF_BCH_FLASH0LAYOUT0_NBLOCKS(n - 1)\r\n| BF_BCH_FLASH0LAYOUT0_META_SIZE(meta);\r\nwritel(r1_new, bch_regs + HW_BCH_FLASH0LAYOUT0);\r\nr2_new &= ~BM_BCH_FLASH0LAYOUT1_PAGE_SIZE;\r\nr2_new |= BF_BCH_FLASH0LAYOUT1_PAGE_SIZE(page_size);\r\nwritel(r2_new, bch_regs + HW_BCH_FLASH0LAYOUT1);\r\ngeo->ecc_chunk_count = n;\r\ngeo->payload_size = n * size;\r\ngeo->page_size = page_size;\r\ngeo->auxiliary_status_offset = ALIGN(meta, 4);\r\ndev_dbg(this->dev, "page:%d(%d:%d)%d, chunk:(%d:%d), BCH PG size:%d\n",\r\npage, offs, len, col, first, n, page_size);\r\nthis->swap_block_mark = false;\r\nmax_bitflips = gpmi_ecc_read_page(mtd, chip, buf, 0, page);\r\nwritel(r1_old, bch_regs + HW_BCH_FLASH0LAYOUT0);\r\nwritel(r2_old, bch_regs + HW_BCH_FLASH0LAYOUT1);\r\nthis->bch_geometry = old_geo;\r\nthis->swap_block_mark = old_swap_block_mark;\r\nreturn max_bitflips;\r\n}\r\nstatic int gpmi_ecc_write_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required, int page)\r\n{\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nconst void *payload_virt;\r\ndma_addr_t payload_phys;\r\nconst void *auxiliary_virt;\r\ndma_addr_t auxiliary_phys;\r\nint ret;\r\ndev_dbg(this->dev, "ecc write page.\n");\r\nif (this->swap_block_mark) {\r\nmemcpy(this->payload_virt, buf, mtd->writesize);\r\npayload_virt = this->payload_virt;\r\npayload_phys = this->payload_phys;\r\nmemcpy(this->auxiliary_virt, chip->oob_poi,\r\nnfc_geo->auxiliary_size);\r\nauxiliary_virt = this->auxiliary_virt;\r\nauxiliary_phys = this->auxiliary_phys;\r\nblock_mark_swapping(this,\r\n(void *)payload_virt, (void *)auxiliary_virt);\r\n} else {\r\nret = send_page_prepare(this,\r\nbuf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\n&payload_virt, &payload_phys);\r\nif (ret) {\r\ndev_err(this->dev, "Inadequate payload DMA buffer\n");\r\nreturn 0;\r\n}\r\nret = send_page_prepare(this,\r\nchip->oob_poi, mtd->oobsize,\r\nthis->auxiliary_virt, this->auxiliary_phys,\r\nnfc_geo->auxiliary_size,\r\n&auxiliary_virt, &auxiliary_phys);\r\nif (ret) {\r\ndev_err(this->dev, "Inadequate auxiliary DMA buffer\n");\r\ngoto exit_auxiliary;\r\n}\r\n}\r\nret = gpmi_send_page(this, payload_phys, auxiliary_phys);\r\nif (ret)\r\ndev_err(this->dev, "Error in ECC-based write: %d\n", ret);\r\nif (!this->swap_block_mark) {\r\nsend_page_end(this, chip->oob_poi, mtd->oobsize,\r\nthis->auxiliary_virt, this->auxiliary_phys,\r\nnfc_geo->auxiliary_size,\r\nauxiliary_virt, auxiliary_phys);\r\nexit_auxiliary:\r\nsend_page_end(this, buf, mtd->writesize,\r\nthis->payload_virt, this->payload_phys,\r\nnfc_geo->payload_size,\r\npayload_virt, payload_phys);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpmi_ecc_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\ndev_dbg(this->dev, "page number is %d\n", page);\r\nmemset(chip->oob_poi, ~0, mtd->oobsize);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);\r\nchip->read_buf(mtd, chip->oob_poi, mtd->oobsize);\r\nif (GPMI_IS_MX23(this)) {\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nchip->oob_poi[0] = chip->read_byte(mtd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\ngpmi_ecc_write_oob(struct mtd_info *mtd, struct nand_chip *chip, int page)\r\n{\r\nstruct mtd_oob_region of = { };\r\nint status = 0;\r\nmtd_ooblayout_free(mtd, 0, &of);\r\nif (!of.length)\r\nreturn -EPERM;\r\nif (!nand_is_slc(chip))\r\nreturn -EPERM;\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize + of.offset, page);\r\nchip->write_buf(mtd, chip->oob_poi + of.offset, of.length);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nreturn status & NAND_STATUS_FAIL ? -EIO : 0;\r\n}\r\nstatic int gpmi_ecc_read_page_raw(struct mtd_info *mtd,\r\nstruct nand_chip *chip, uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nint eccsize = nfc_geo->ecc_chunk_size;\r\nint eccbits = nfc_geo->ecc_strength * nfc_geo->gf_len;\r\nu8 *tmp_buf = this->raw_buffer;\r\nsize_t src_bit_off;\r\nsize_t oob_bit_off;\r\nsize_t oob_byte_off;\r\nuint8_t *oob = chip->oob_poi;\r\nint step;\r\nchip->read_buf(mtd, tmp_buf,\r\nmtd->writesize + mtd->oobsize);\r\nif (this->swap_block_mark) {\r\nu8 swap = tmp_buf[0];\r\ntmp_buf[0] = tmp_buf[mtd->writesize];\r\ntmp_buf[mtd->writesize] = swap;\r\n}\r\nif (oob_required)\r\nmemcpy(oob, tmp_buf, nfc_geo->metadata_size);\r\noob_bit_off = nfc_geo->metadata_size * 8;\r\nsrc_bit_off = oob_bit_off;\r\nfor (step = 0; step < nfc_geo->ecc_chunk_count; step++) {\r\nif (buf)\r\ngpmi_copy_bits(buf, step * eccsize * 8,\r\ntmp_buf, src_bit_off,\r\neccsize * 8);\r\nsrc_bit_off += eccsize * 8;\r\nif (step == nfc_geo->ecc_chunk_count - 1 &&\r\n(oob_bit_off + eccbits) % 8)\r\neccbits += 8 - ((oob_bit_off + eccbits) % 8);\r\nif (oob_required)\r\ngpmi_copy_bits(oob, oob_bit_off,\r\ntmp_buf, src_bit_off,\r\neccbits);\r\nsrc_bit_off += eccbits;\r\noob_bit_off += eccbits;\r\n}\r\nif (oob_required) {\r\noob_byte_off = oob_bit_off / 8;\r\nif (oob_byte_off < mtd->oobsize)\r\nmemcpy(oob + oob_byte_off,\r\ntmp_buf + mtd->writesize + oob_byte_off,\r\nmtd->oobsize - oob_byte_off);\r\n}\r\nreturn 0;\r\n}\r\nstatic int gpmi_ecc_write_page_raw(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf,\r\nint oob_required, int page)\r\n{\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nstruct bch_geometry *nfc_geo = &this->bch_geometry;\r\nint eccsize = nfc_geo->ecc_chunk_size;\r\nint eccbits = nfc_geo->ecc_strength * nfc_geo->gf_len;\r\nu8 *tmp_buf = this->raw_buffer;\r\nuint8_t *oob = chip->oob_poi;\r\nsize_t dst_bit_off;\r\nsize_t oob_bit_off;\r\nsize_t oob_byte_off;\r\nint step;\r\nif (!buf || !oob_required)\r\nmemset(tmp_buf, 0xff, mtd->writesize + mtd->oobsize);\r\nmemcpy(tmp_buf, oob, nfc_geo->metadata_size);\r\noob_bit_off = nfc_geo->metadata_size * 8;\r\ndst_bit_off = oob_bit_off;\r\nfor (step = 0; step < nfc_geo->ecc_chunk_count; step++) {\r\nif (buf)\r\ngpmi_copy_bits(tmp_buf, dst_bit_off,\r\nbuf, step * eccsize * 8, eccsize * 8);\r\ndst_bit_off += eccsize * 8;\r\nif (step == nfc_geo->ecc_chunk_count - 1 &&\r\n(oob_bit_off + eccbits) % 8)\r\neccbits += 8 - ((oob_bit_off + eccbits) % 8);\r\nif (oob_required)\r\ngpmi_copy_bits(tmp_buf, dst_bit_off,\r\noob, oob_bit_off, eccbits);\r\ndst_bit_off += eccbits;\r\noob_bit_off += eccbits;\r\n}\r\noob_byte_off = oob_bit_off / 8;\r\nif (oob_required && oob_byte_off < mtd->oobsize)\r\nmemcpy(tmp_buf + mtd->writesize + oob_byte_off,\r\noob + oob_byte_off, mtd->oobsize - oob_byte_off);\r\nif (this->swap_block_mark) {\r\nu8 swap = tmp_buf[0];\r\ntmp_buf[0] = tmp_buf[mtd->writesize];\r\ntmp_buf[mtd->writesize] = swap;\r\n}\r\nchip->write_buf(mtd, tmp_buf, mtd->writesize + mtd->oobsize);\r\nreturn 0;\r\n}\r\nstatic int gpmi_ecc_read_oob_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nreturn gpmi_ecc_read_page_raw(mtd, chip, NULL, 1, page);\r\n}\r\nstatic int gpmi_ecc_write_oob_raw(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0, page);\r\nreturn gpmi_ecc_write_page_raw(mtd, chip, NULL, 1, page);\r\n}\r\nstatic int gpmi_block_markbad(struct mtd_info *mtd, loff_t ofs)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct gpmi_nand_data *this = nand_get_controller_data(chip);\r\nint ret = 0;\r\nuint8_t *block_mark;\r\nint column, page, status, chipnr;\r\nchipnr = (int)(ofs >> chip->chip_shift);\r\nchip->select_chip(mtd, chipnr);\r\ncolumn = !GPMI_IS_MX23(this) ? mtd->writesize : 0;\r\nblock_mark = this->data_buffer_dma;\r\nblock_mark[0] = 0;\r\npage = (int)(ofs >> chip->page_shift);\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, column, page);\r\nchip->write_buf(mtd, block_mark, 1);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\nret = -EIO;\r\nchip->select_chip(mtd, -1);\r\nreturn ret;\r\n}\r\nstatic int nand_boot_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nstruct boot_rom_geometry *geometry = &this->rom_geometry;\r\ngeometry->stride_size_in_pages = 64;\r\ngeometry->search_area_stride_exponent = 2;\r\nreturn 0;\r\n}\r\nstatic int mx23_check_transcription_stamp(struct gpmi_nand_data *this)\r\n{\r\nstruct boot_rom_geometry *rom_geo = &this->rom_geometry;\r\nstruct device *dev = this->dev;\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nunsigned int search_area_size_in_strides;\r\nunsigned int stride;\r\nunsigned int page;\r\nuint8_t *buffer = chip->buffers->databuf;\r\nint saved_chip_number;\r\nint found_an_ncb_fingerprint = false;\r\nsearch_area_size_in_strides = 1 << rom_geo->search_area_stride_exponent;\r\nsaved_chip_number = this->current_chip;\r\nchip->select_chip(mtd, 0);\r\ndev_dbg(dev, "Scanning for an NCB fingerprint...\n");\r\nfor (stride = 0; stride < search_area_size_in_strides; stride++) {\r\npage = stride * rom_geo->stride_size_in_pages;\r\ndev_dbg(dev, "Looking for a fingerprint in page 0x%x\n", page);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 12, page);\r\nchip->read_buf(mtd, buffer, strlen(fingerprint));\r\nif (!memcmp(buffer, fingerprint, strlen(fingerprint))) {\r\nfound_an_ncb_fingerprint = true;\r\nbreak;\r\n}\r\n}\r\nchip->select_chip(mtd, saved_chip_number);\r\nif (found_an_ncb_fingerprint)\r\ndev_dbg(dev, "\tFound a fingerprint\n");\r\nelse\r\ndev_dbg(dev, "\tNo fingerprint found\n");\r\nreturn found_an_ncb_fingerprint;\r\n}\r\nstatic int mx23_write_transcription_stamp(struct gpmi_nand_data *this)\r\n{\r\nstruct device *dev = this->dev;\r\nstruct boot_rom_geometry *rom_geo = &this->rom_geometry;\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nunsigned int block_size_in_pages;\r\nunsigned int search_area_size_in_strides;\r\nunsigned int search_area_size_in_pages;\r\nunsigned int search_area_size_in_blocks;\r\nunsigned int block;\r\nunsigned int stride;\r\nunsigned int page;\r\nuint8_t *buffer = chip->buffers->databuf;\r\nint saved_chip_number;\r\nint status;\r\nblock_size_in_pages = mtd->erasesize / mtd->writesize;\r\nsearch_area_size_in_strides = 1 << rom_geo->search_area_stride_exponent;\r\nsearch_area_size_in_pages = search_area_size_in_strides *\r\nrom_geo->stride_size_in_pages;\r\nsearch_area_size_in_blocks =\r\n(search_area_size_in_pages + (block_size_in_pages - 1)) /\r\nblock_size_in_pages;\r\ndev_dbg(dev, "Search Area Geometry :\n");\r\ndev_dbg(dev, "\tin Blocks : %u\n", search_area_size_in_blocks);\r\ndev_dbg(dev, "\tin Strides: %u\n", search_area_size_in_strides);\r\ndev_dbg(dev, "\tin Pages : %u\n", search_area_size_in_pages);\r\nsaved_chip_number = this->current_chip;\r\nchip->select_chip(mtd, 0);\r\ndev_dbg(dev, "Erasing the search area...\n");\r\nfor (block = 0; block < search_area_size_in_blocks; block++) {\r\npage = block * block_size_in_pages;\r\ndev_dbg(dev, "\tErasing block 0x%x\n", block);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE1, -1, page);\r\nchip->cmdfunc(mtd, NAND_CMD_ERASE2, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\ndev_err(dev, "[%s] Erase failed.\n", __func__);\r\n}\r\nmemset(buffer, ~0, mtd->writesize);\r\nmemcpy(buffer + 12, fingerprint, strlen(fingerprint));\r\ndev_dbg(dev, "Writing NCB fingerprints...\n");\r\nfor (stride = 0; stride < search_area_size_in_strides; stride++) {\r\npage = stride * rom_geo->stride_size_in_pages;\r\ndev_dbg(dev, "Writing an NCB fingerprint in page 0x%x\n", page);\r\nchip->cmdfunc(mtd, NAND_CMD_SEQIN, 0x00, page);\r\nchip->ecc.write_page_raw(mtd, chip, buffer, 0, page);\r\nchip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);\r\nstatus = chip->waitfunc(mtd, chip);\r\nif (status & NAND_STATUS_FAIL)\r\ndev_err(dev, "[%s] Write failed.\n", __func__);\r\n}\r\nchip->select_chip(mtd, saved_chip_number);\r\nreturn 0;\r\n}\r\nstatic int mx23_boot_init(struct gpmi_nand_data *this)\r\n{\r\nstruct device *dev = this->dev;\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nunsigned int block_count;\r\nunsigned int block;\r\nint chipnr;\r\nint page;\r\nloff_t byte;\r\nuint8_t block_mark;\r\nint ret = 0;\r\nif (mx23_check_transcription_stamp(this))\r\nreturn 0;\r\ndev_dbg(dev, "Transcribing bad block marks...\n");\r\nblock_count = chip->chipsize >> chip->phys_erase_shift;\r\nfor (block = 0; block < block_count; block++) {\r\nchipnr = block >> (chip->chip_shift - chip->phys_erase_shift);\r\npage = block << (chip->phys_erase_shift - chip->page_shift);\r\nbyte = block << chip->phys_erase_shift;\r\nchip->select_chip(mtd, chipnr);\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, mtd->writesize, page);\r\nblock_mark = chip->read_byte(mtd);\r\nchip->select_chip(mtd, -1);\r\nif (block_mark != 0xff) {\r\ndev_dbg(dev, "Transcribing mark in block %u\n", block);\r\nret = chip->block_markbad(mtd, byte);\r\nif (ret)\r\ndev_err(dev,\r\n"Failed to mark block bad with ret %d\n",\r\nret);\r\n}\r\n}\r\nmx23_write_transcription_stamp(this);\r\nreturn 0;\r\n}\r\nstatic int nand_boot_init(struct gpmi_nand_data *this)\r\n{\r\nnand_boot_set_geometry(this);\r\nif (GPMI_IS_MX23(this))\r\nreturn mx23_boot_init(this);\r\nreturn 0;\r\n}\r\nstatic int gpmi_set_geometry(struct gpmi_nand_data *this)\r\n{\r\nint ret;\r\ngpmi_free_dma_buffer(this);\r\nret = bch_set_geometry(this);\r\nif (ret) {\r\ndev_err(this->dev, "Error setting BCH geometry : %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn gpmi_alloc_dma_buffer(this);\r\n}\r\nstatic void gpmi_nand_exit(struct gpmi_nand_data *this)\r\n{\r\nnand_release(nand_to_mtd(&this->nand));\r\ngpmi_free_dma_buffer(this);\r\n}\r\nstatic int gpmi_init_last(struct gpmi_nand_data *this)\r\n{\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nstruct nand_ecc_ctrl *ecc = &chip->ecc;\r\nstruct bch_geometry *bch_geo = &this->bch_geometry;\r\nint ret;\r\nret = gpmi_set_geometry(this);\r\nif (ret)\r\nreturn ret;\r\necc->read_page = gpmi_ecc_read_page;\r\necc->write_page = gpmi_ecc_write_page;\r\necc->read_oob = gpmi_ecc_read_oob;\r\necc->write_oob = gpmi_ecc_write_oob;\r\necc->read_page_raw = gpmi_ecc_read_page_raw;\r\necc->write_page_raw = gpmi_ecc_write_page_raw;\r\necc->read_oob_raw = gpmi_ecc_read_oob_raw;\r\necc->write_oob_raw = gpmi_ecc_write_oob_raw;\r\necc->mode = NAND_ECC_HW;\r\necc->size = bch_geo->ecc_chunk_size;\r\necc->strength = bch_geo->ecc_strength;\r\nmtd_set_ooblayout(mtd, &gpmi_ooblayout_ops);\r\nif (GPMI_IS_MX6(this) &&\r\n((bch_geo->gf_len * bch_geo->ecc_strength) % 8) == 0) {\r\necc->read_subpage = gpmi_ecc_read_subpage;\r\nchip->options |= NAND_SUBPAGE_READ;\r\n}\r\ngpmi_extra_init(this);\r\nreturn 0;\r\n}\r\nstatic int gpmi_nand_init(struct gpmi_nand_data *this)\r\n{\r\nstruct nand_chip *chip = &this->nand;\r\nstruct mtd_info *mtd = nand_to_mtd(chip);\r\nint ret;\r\nthis->current_chip = -1;\r\nmtd->name = "gpmi-nand";\r\nmtd->dev.parent = this->dev;\r\nnand_set_controller_data(chip, this);\r\nnand_set_flash_node(chip, this->pdev->dev.of_node);\r\nchip->select_chip = gpmi_select_chip;\r\nchip->cmd_ctrl = gpmi_cmd_ctrl;\r\nchip->dev_ready = gpmi_dev_ready;\r\nchip->read_byte = gpmi_read_byte;\r\nchip->read_buf = gpmi_read_buf;\r\nchip->write_buf = gpmi_write_buf;\r\nchip->badblock_pattern = &gpmi_bbt_descr;\r\nchip->block_markbad = gpmi_block_markbad;\r\nchip->options |= NAND_NO_SUBPAGE_WRITE;\r\nthis->swap_block_mark = !GPMI_IS_MX23(this);\r\nthis->bch_geometry.payload_size = 1024;\r\nthis->bch_geometry.auxiliary_size = 128;\r\nret = gpmi_alloc_dma_buffer(this);\r\nif (ret)\r\ngoto err_out;\r\nret = nand_scan_ident(mtd, GPMI_IS_MX6(this) ? 2 : 1, NULL);\r\nif (ret)\r\ngoto err_out;\r\nif (chip->bbt_options & NAND_BBT_USE_FLASH) {\r\nchip->bbt_options |= NAND_BBT_NO_OOB;\r\nif (of_property_read_bool(this->dev->of_node,\r\n"fsl,no-blockmark-swap"))\r\nthis->swap_block_mark = false;\r\n}\r\ndev_dbg(this->dev, "Blockmark swapping %sabled\n",\r\nthis->swap_block_mark ? "en" : "dis");\r\nret = gpmi_init_last(this);\r\nif (ret)\r\ngoto err_out;\r\nchip->options |= NAND_SKIP_BBTSCAN;\r\nret = nand_scan_tail(mtd);\r\nif (ret)\r\ngoto err_out;\r\nret = nand_boot_init(this);\r\nif (ret)\r\ngoto err_out;\r\nret = chip->scan_bbt(mtd);\r\nif (ret)\r\ngoto err_out;\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret)\r\ngoto err_out;\r\nreturn 0;\r\nerr_out:\r\ngpmi_nand_exit(this);\r\nreturn ret;\r\n}\r\nstatic int gpmi_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct gpmi_nand_data *this;\r\nconst struct of_device_id *of_id;\r\nint ret;\r\nthis = devm_kzalloc(&pdev->dev, sizeof(*this), GFP_KERNEL);\r\nif (!this)\r\nreturn -ENOMEM;\r\nof_id = of_match_device(gpmi_nand_id_table, &pdev->dev);\r\nif (of_id) {\r\nthis->devdata = of_id->data;\r\n} else {\r\ndev_err(&pdev->dev, "Failed to find the right device id.\n");\r\nreturn -ENODEV;\r\n}\r\nplatform_set_drvdata(pdev, this);\r\nthis->pdev = pdev;\r\nthis->dev = &pdev->dev;\r\nret = acquire_resources(this);\r\nif (ret)\r\ngoto exit_acquire_resources;\r\nret = init_hardware(this);\r\nif (ret)\r\ngoto exit_nfc_init;\r\nret = gpmi_nand_init(this);\r\nif (ret)\r\ngoto exit_nfc_init;\r\ndev_info(this->dev, "driver registered.\n");\r\nreturn 0;\r\nexit_nfc_init:\r\nrelease_resources(this);\r\nexit_acquire_resources:\r\nreturn ret;\r\n}\r\nstatic int gpmi_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct gpmi_nand_data *this = platform_get_drvdata(pdev);\r\ngpmi_nand_exit(this);\r\nrelease_resources(this);\r\nreturn 0;\r\n}\r\nstatic int gpmi_pm_suspend(struct device *dev)\r\n{\r\nstruct gpmi_nand_data *this = dev_get_drvdata(dev);\r\nrelease_dma_channels(this);\r\nreturn 0;\r\n}\r\nstatic int gpmi_pm_resume(struct device *dev)\r\n{\r\nstruct gpmi_nand_data *this = dev_get_drvdata(dev);\r\nint ret;\r\nret = acquire_dma_channels(this);\r\nif (ret < 0)\r\nreturn ret;\r\nthis->flags &= ~GPMI_TIMING_INIT_OK;\r\nret = gpmi_init(this);\r\nif (ret) {\r\ndev_err(this->dev, "Error setting GPMI : %d\n", ret);\r\nreturn ret;\r\n}\r\nret = bch_set_geometry(this);\r\nif (ret) {\r\ndev_err(this->dev, "Error setting BCH : %d\n", ret);\r\nreturn ret;\r\n}\r\ngpmi_extra_init(this);\r\nreturn 0;\r\n}
