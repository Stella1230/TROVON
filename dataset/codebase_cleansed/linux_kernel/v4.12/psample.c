static int psample_group_nl_fill(struct sk_buff *msg,\r\nstruct psample_group *group,\r\nenum psample_command cmd, u32 portid, u32 seq,\r\nint flags)\r\n{\r\nvoid *hdr;\r\nint ret;\r\nhdr = genlmsg_put(msg, portid, seq, &psample_nl_family, flags, cmd);\r\nif (!hdr)\r\nreturn -EMSGSIZE;\r\nret = nla_put_u32(msg, PSAMPLE_ATTR_SAMPLE_GROUP, group->group_num);\r\nif (ret < 0)\r\ngoto error;\r\nret = nla_put_u32(msg, PSAMPLE_ATTR_GROUP_REFCOUNT, group->refcount);\r\nif (ret < 0)\r\ngoto error;\r\nret = nla_put_u32(msg, PSAMPLE_ATTR_GROUP_SEQ, group->seq);\r\nif (ret < 0)\r\ngoto error;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nerror:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int psample_nl_cmd_get_group_dumpit(struct sk_buff *msg,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct psample_group *group;\r\nint start = cb->args[0];\r\nint idx = 0;\r\nint err;\r\nspin_lock(&psample_groups_lock);\r\nlist_for_each_entry(group, &psample_groups_list, list) {\r\nif (!net_eq(group->net, sock_net(msg->sk)))\r\ncontinue;\r\nif (idx < start) {\r\nidx++;\r\ncontinue;\r\n}\r\nerr = psample_group_nl_fill(msg, group, PSAMPLE_CMD_NEW_GROUP,\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI);\r\nif (err)\r\nbreak;\r\nidx++;\r\n}\r\nspin_unlock(&psample_groups_lock);\r\ncb->args[0] = idx;\r\nreturn msg->len;\r\n}\r\nstatic void psample_group_notify(struct psample_group *group,\r\nenum psample_command cmd)\r\n{\r\nstruct sk_buff *msg;\r\nint err;\r\nmsg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\r\nif (!msg)\r\nreturn;\r\nerr = psample_group_nl_fill(msg, group, cmd, 0, 0, NLM_F_MULTI);\r\nif (!err)\r\ngenlmsg_multicast_netns(&psample_nl_family, group->net, msg, 0,\r\nPSAMPLE_NL_MCGRP_CONFIG, GFP_ATOMIC);\r\nelse\r\nnlmsg_free(msg);\r\n}\r\nstatic struct psample_group *psample_group_create(struct net *net,\r\nu32 group_num)\r\n{\r\nstruct psample_group *group;\r\ngroup = kzalloc(sizeof(*group), GFP_ATOMIC);\r\nif (!group)\r\nreturn NULL;\r\ngroup->net = net;\r\ngroup->group_num = group_num;\r\nlist_add_tail(&group->list, &psample_groups_list);\r\npsample_group_notify(group, PSAMPLE_CMD_NEW_GROUP);\r\nreturn group;\r\n}\r\nstatic void psample_group_destroy(struct psample_group *group)\r\n{\r\npsample_group_notify(group, PSAMPLE_CMD_DEL_GROUP);\r\nlist_del(&group->list);\r\nkfree(group);\r\n}\r\nstatic struct psample_group *\r\npsample_group_lookup(struct net *net, u32 group_num)\r\n{\r\nstruct psample_group *group;\r\nlist_for_each_entry(group, &psample_groups_list, list)\r\nif ((group->group_num == group_num) && (group->net == net))\r\nreturn group;\r\nreturn NULL;\r\n}\r\nstruct psample_group *psample_group_get(struct net *net, u32 group_num)\r\n{\r\nstruct psample_group *group;\r\nspin_lock(&psample_groups_lock);\r\ngroup = psample_group_lookup(net, group_num);\r\nif (!group) {\r\ngroup = psample_group_create(net, group_num);\r\nif (!group)\r\ngoto out;\r\n}\r\ngroup->refcount++;\r\nout:\r\nspin_unlock(&psample_groups_lock);\r\nreturn group;\r\n}\r\nvoid psample_group_put(struct psample_group *group)\r\n{\r\nspin_lock(&psample_groups_lock);\r\nif (--group->refcount == 0)\r\npsample_group_destroy(group);\r\nspin_unlock(&psample_groups_lock);\r\n}\r\nvoid psample_sample_packet(struct psample_group *group, struct sk_buff *skb,\r\nu32 trunc_size, int in_ifindex, int out_ifindex,\r\nu32 sample_rate)\r\n{\r\nstruct sk_buff *nl_skb;\r\nint data_len;\r\nint meta_len;\r\nvoid *data;\r\nint ret;\r\nmeta_len = (in_ifindex ? nla_total_size(sizeof(u16)) : 0) +\r\n(out_ifindex ? nla_total_size(sizeof(u16)) : 0) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32)) +\r\nnla_total_size(sizeof(u32));\r\ndata_len = min(skb->len, trunc_size);\r\nif (meta_len + nla_total_size(data_len) > PSAMPLE_MAX_PACKET_SIZE)\r\ndata_len = PSAMPLE_MAX_PACKET_SIZE - meta_len - NLA_HDRLEN\r\n- NLA_ALIGNTO;\r\nnl_skb = genlmsg_new(meta_len + data_len, GFP_ATOMIC);\r\nif (unlikely(!nl_skb))\r\nreturn;\r\ndata = genlmsg_put(nl_skb, 0, 0, &psample_nl_family, 0,\r\nPSAMPLE_CMD_SAMPLE);\r\nif (unlikely(!data))\r\ngoto error;\r\nif (in_ifindex) {\r\nret = nla_put_u16(nl_skb, PSAMPLE_ATTR_IIFINDEX, in_ifindex);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\n}\r\nif (out_ifindex) {\r\nret = nla_put_u16(nl_skb, PSAMPLE_ATTR_OIFINDEX, out_ifindex);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\n}\r\nret = nla_put_u32(nl_skb, PSAMPLE_ATTR_SAMPLE_RATE, sample_rate);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nret = nla_put_u32(nl_skb, PSAMPLE_ATTR_ORIGSIZE, skb->len);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nret = nla_put_u32(nl_skb, PSAMPLE_ATTR_SAMPLE_GROUP, group->group_num);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nret = nla_put_u32(nl_skb, PSAMPLE_ATTR_GROUP_SEQ, group->seq++);\r\nif (unlikely(ret < 0))\r\ngoto error;\r\nif (data_len) {\r\nint nla_len = nla_total_size(data_len);\r\nstruct nlattr *nla;\r\nnla = (struct nlattr *)skb_put(nl_skb, nla_len);\r\nnla->nla_type = PSAMPLE_ATTR_DATA;\r\nnla->nla_len = nla_attr_size(data_len);\r\nif (skb_copy_bits(skb, 0, nla_data(nla), data_len))\r\ngoto error;\r\n}\r\ngenlmsg_end(nl_skb, data);\r\ngenlmsg_multicast_netns(&psample_nl_family, group->net, nl_skb, 0,\r\nPSAMPLE_NL_MCGRP_SAMPLE, GFP_ATOMIC);\r\nreturn;\r\nerror:\r\npr_err_ratelimited("Could not create psample log message\n");\r\nnlmsg_free(nl_skb);\r\n}\r\nstatic int __init psample_module_init(void)\r\n{\r\nreturn genl_register_family(&psample_nl_family);\r\n}\r\nstatic void __exit psample_module_exit(void)\r\n{\r\ngenl_unregister_family(&psample_nl_family);\r\n}
