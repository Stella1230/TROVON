static int\r\nath10k_wmi_tlv_iter(struct ath10k *ar, const void *ptr, size_t len,\r\nint (*iter)(struct ath10k *ar, u16 tag, u16 len,\r\nconst void *ptr, void *data),\r\nvoid *data)\r\n{\r\nconst void *begin = ptr;\r\nconst struct wmi_tlv *tlv;\r\nu16 tlv_tag, tlv_len;\r\nint ret;\r\nwhile (len > 0) {\r\nif (len < sizeof(*tlv)) {\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv parse failure at byte %zd (%zu bytes left, %zu expected)\n",\r\nptr - begin, len, sizeof(*tlv));\r\nreturn -EINVAL;\r\n}\r\ntlv = ptr;\r\ntlv_tag = __le16_to_cpu(tlv->tag);\r\ntlv_len = __le16_to_cpu(tlv->len);\r\nptr += sizeof(*tlv);\r\nlen -= sizeof(*tlv);\r\nif (tlv_len > len) {\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv parse failure of tag %hhu at byte %zd (%zu bytes left, %hhu expected)\n",\r\ntlv_tag, ptr - begin, len, tlv_len);\r\nreturn -EINVAL;\r\n}\r\nif (tlv_tag < ARRAY_SIZE(wmi_tlv_policies) &&\r\nwmi_tlv_policies[tlv_tag].min_len &&\r\nwmi_tlv_policies[tlv_tag].min_len > tlv_len) {\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv parse failure of tag %hhu at byte %zd (%hhu bytes is less than min length %zu)\n",\r\ntlv_tag, ptr - begin, tlv_len,\r\nwmi_tlv_policies[tlv_tag].min_len);\r\nreturn -EINVAL;\r\n}\r\nret = iter(ar, tlv_tag, tlv_len, ptr, data);\r\nif (ret)\r\nreturn ret;\r\nptr += tlv_len;\r\nlen -= tlv_len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_iter_parse(struct ath10k *ar, u16 tag, u16 len,\r\nconst void *ptr, void *data)\r\n{\r\nconst void **tb = data;\r\nif (tag < WMI_TLV_TAG_MAX)\r\ntb[tag] = ptr;\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_parse(struct ath10k *ar, const void **tb,\r\nconst void *ptr, size_t len)\r\n{\r\nreturn ath10k_wmi_tlv_iter(ar, ptr, len, ath10k_wmi_tlv_iter_parse,\r\n(void *)tb);\r\n}\r\nstatic const void **\r\nath10k_wmi_tlv_parse_alloc(struct ath10k *ar, const void *ptr,\r\nsize_t len, gfp_t gfp)\r\n{\r\nconst void **tb;\r\nint ret;\r\ntb = kzalloc(sizeof(*tb) * WMI_TLV_TAG_MAX, gfp);\r\nif (!tb)\r\nreturn ERR_PTR(-ENOMEM);\r\nret = ath10k_wmi_tlv_parse(ar, tb, ptr, len);\r\nif (ret) {\r\nkfree(tb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn tb;\r\n}\r\nstatic u16 ath10k_wmi_tlv_len(const void *ptr)\r\n{\r\nreturn __le16_to_cpu((((const struct wmi_tlv *)ptr) - 1)->len);\r\n}\r\nstatic int ath10k_wmi_tlv_event_bcn_tx_status(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_bcn_tx_status_ev *ev;\r\nstruct ath10k_vif *arvif;\r\nu32 vdev_id, tx_status;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_OFFLOAD_BCN_TX_STATUS_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\ntx_status = __le32_to_cpu(ev->tx_status);\r\nvdev_id = __le32_to_cpu(ev->vdev_id);\r\nswitch (tx_status) {\r\ncase WMI_TLV_BCN_TX_STATUS_OK:\r\nbreak;\r\ncase WMI_TLV_BCN_TX_STATUS_XRETRY:\r\ncase WMI_TLV_BCN_TX_STATUS_DROP:\r\ncase WMI_TLV_BCN_TX_STATUS_FILTERED:\r\nath10k_warn(ar, "received bcn tmpl tx status on vdev %i: %d",\r\nvdev_id, tx_status);\r\nbreak;\r\n}\r\narvif = ath10k_get_arvif(ar, vdev_id);\r\nif (arvif && arvif->is_up && arvif->vif->csa_active)\r\nieee80211_queue_work(ar->hw, &arvif->ap_csa_work);\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_event_diag_data(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_diag_data_ev *ev;\r\nconst struct wmi_tlv_diag_item *item;\r\nconst void *data;\r\nint ret, num_items, len;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_DIAG_DATA_CONTAINER_EVENT];\r\ndata = tb[WMI_TLV_TAG_ARRAY_BYTE];\r\nif (!ev || !data) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\nnum_items = __le32_to_cpu(ev->num_items);\r\nlen = ath10k_wmi_tlv_len(data);\r\nwhile (num_items--) {\r\nif (len == 0)\r\nbreak;\r\nif (len < sizeof(*item)) {\r\nath10k_warn(ar, "failed to parse diag data: can't fit item header\n");\r\nbreak;\r\n}\r\nitem = data;\r\nif (len < sizeof(*item) + __le16_to_cpu(item->len)) {\r\nath10k_warn(ar, "failed to parse diag data: item is too long\n");\r\nbreak;\r\n}\r\ntrace_ath10k_wmi_diag_container(ar,\r\nitem->type,\r\n__le32_to_cpu(item->timestamp),\r\n__le32_to_cpu(item->code),\r\n__le16_to_cpu(item->len),\r\nitem->payload);\r\nlen -= sizeof(*item);\r\nlen -= roundup(__le16_to_cpu(item->len), 4);\r\ndata += sizeof(*item);\r\ndata += roundup(__le16_to_cpu(item->len), 4);\r\n}\r\nif (num_items != -1 || len != 0)\r\nath10k_warn(ar, "failed to parse diag data event: num_items %d len %d\n",\r\nnum_items, len);\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_event_diag(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nconst void **tb;\r\nconst void *data;\r\nint ret, len;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\ndata = tb[WMI_TLV_TAG_ARRAY_BYTE];\r\nif (!data) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\nlen = ath10k_wmi_tlv_len(data);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv diag event len %d\n", len);\r\ntrace_ath10k_wmi_diag(ar, data, len);\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_event_p2p_noa(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_p2p_noa_ev *ev;\r\nconst struct wmi_p2p_noa_info *noa;\r\nint ret, vdev_id;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_P2P_NOA_EVENT];\r\nnoa = tb[WMI_TLV_TAG_STRUCT_P2P_NOA_INFO];\r\nif (!ev || !noa) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\nvdev_id = __le32_to_cpu(ev->vdev_id);\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv p2p noa vdev_id %i descriptors %hhu\n",\r\nvdev_id, noa->num_descriptors);\r\nath10k_p2p_noa_update_by_vdev_id(ar, vdev_id, noa);\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_event_tx_pause(struct ath10k *ar,\r\nstruct sk_buff *skb)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_tx_pause_ev *ev;\r\nint ret, vdev_id;\r\nu32 pause_id, action, vdev_map, peer_id, tid_map;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_TX_PAUSE_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\npause_id = __le32_to_cpu(ev->pause_id);\r\naction = __le32_to_cpu(ev->action);\r\nvdev_map = __le32_to_cpu(ev->vdev_map);\r\npeer_id = __le32_to_cpu(ev->peer_id);\r\ntid_map = __le32_to_cpu(ev->tid_map);\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv tx pause pause_id %u action %u vdev_map 0x%08x peer_id %u tid_map 0x%08x\n",\r\npause_id, action, vdev_map, peer_id, tid_map);\r\nswitch (pause_id) {\r\ncase WMI_TLV_TX_PAUSE_ID_MCC:\r\ncase WMI_TLV_TX_PAUSE_ID_P2P_CLI_NOA:\r\ncase WMI_TLV_TX_PAUSE_ID_P2P_GO_PS:\r\ncase WMI_TLV_TX_PAUSE_ID_AP_PS:\r\ncase WMI_TLV_TX_PAUSE_ID_IBSS_PS:\r\nfor (vdev_id = 0; vdev_map; vdev_id++) {\r\nif (!(vdev_map & BIT(vdev_id)))\r\ncontinue;\r\nvdev_map &= ~BIT(vdev_id);\r\nath10k_mac_handle_tx_pause_vdev(ar, vdev_id, pause_id,\r\naction);\r\n}\r\nbreak;\r\ncase WMI_TLV_TX_PAUSE_ID_AP_PEER_PS:\r\ncase WMI_TLV_TX_PAUSE_ID_AP_PEER_UAPSD:\r\ncase WMI_TLV_TX_PAUSE_ID_STA_ADD_BA:\r\ncase WMI_TLV_TX_PAUSE_ID_HOST:\r\nath10k_dbg(ar, ATH10K_DBG_MAC,\r\n"mac ignoring unsupported tx pause id %d\n",\r\npause_id);\r\nbreak;\r\ndefault:\r\nath10k_dbg(ar, ATH10K_DBG_MAC,\r\n"mac ignoring unknown tx pause vdev %d\n",\r\npause_id);\r\nbreak;\r\n}\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic void ath10k_wmi_tlv_op_rx(struct ath10k *ar, struct sk_buff *skb)\r\n{\r\nstruct wmi_cmd_hdr *cmd_hdr;\r\nenum wmi_tlv_event_id id;\r\nbool consumed;\r\ncmd_hdr = (struct wmi_cmd_hdr *)skb->data;\r\nid = MS(__le32_to_cpu(cmd_hdr->cmd_id), WMI_CMD_HDR_CMD_ID);\r\nif (skb_pull(skb, sizeof(struct wmi_cmd_hdr)) == NULL)\r\ngoto out;\r\ntrace_ath10k_wmi_event(ar, id, skb->data, skb->len);\r\nconsumed = ath10k_tm_event_wmi(ar, id, skb);\r\nif (consumed && id != WMI_TLV_READY_EVENTID) {\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv testmode consumed 0x%x\n", id);\r\ngoto out;\r\n}\r\nswitch (id) {\r\ncase WMI_TLV_MGMT_RX_EVENTID:\r\nath10k_wmi_event_mgmt_rx(ar, skb);\r\nreturn;\r\ncase WMI_TLV_SCAN_EVENTID:\r\nath10k_wmi_event_scan(ar, skb);\r\nbreak;\r\ncase WMI_TLV_CHAN_INFO_EVENTID:\r\nath10k_wmi_event_chan_info(ar, skb);\r\nbreak;\r\ncase WMI_TLV_ECHO_EVENTID:\r\nath10k_wmi_event_echo(ar, skb);\r\nbreak;\r\ncase WMI_TLV_DEBUG_MESG_EVENTID:\r\nath10k_wmi_event_debug_mesg(ar, skb);\r\nbreak;\r\ncase WMI_TLV_UPDATE_STATS_EVENTID:\r\nath10k_wmi_event_update_stats(ar, skb);\r\nbreak;\r\ncase WMI_TLV_VDEV_START_RESP_EVENTID:\r\nath10k_wmi_event_vdev_start_resp(ar, skb);\r\nbreak;\r\ncase WMI_TLV_VDEV_STOPPED_EVENTID:\r\nath10k_wmi_event_vdev_stopped(ar, skb);\r\nbreak;\r\ncase WMI_TLV_PEER_STA_KICKOUT_EVENTID:\r\nath10k_wmi_event_peer_sta_kickout(ar, skb);\r\nbreak;\r\ncase WMI_TLV_HOST_SWBA_EVENTID:\r\nath10k_wmi_event_host_swba(ar, skb);\r\nbreak;\r\ncase WMI_TLV_TBTTOFFSET_UPDATE_EVENTID:\r\nath10k_wmi_event_tbttoffset_update(ar, skb);\r\nbreak;\r\ncase WMI_TLV_PHYERR_EVENTID:\r\nath10k_wmi_event_phyerr(ar, skb);\r\nbreak;\r\ncase WMI_TLV_ROAM_EVENTID:\r\nath10k_wmi_event_roam(ar, skb);\r\nbreak;\r\ncase WMI_TLV_PROFILE_MATCH:\r\nath10k_wmi_event_profile_match(ar, skb);\r\nbreak;\r\ncase WMI_TLV_DEBUG_PRINT_EVENTID:\r\nath10k_wmi_event_debug_print(ar, skb);\r\nbreak;\r\ncase WMI_TLV_PDEV_QVIT_EVENTID:\r\nath10k_wmi_event_pdev_qvit(ar, skb);\r\nbreak;\r\ncase WMI_TLV_WLAN_PROFILE_DATA_EVENTID:\r\nath10k_wmi_event_wlan_profile_data(ar, skb);\r\nbreak;\r\ncase WMI_TLV_RTT_MEASUREMENT_REPORT_EVENTID:\r\nath10k_wmi_event_rtt_measurement_report(ar, skb);\r\nbreak;\r\ncase WMI_TLV_TSF_MEASUREMENT_REPORT_EVENTID:\r\nath10k_wmi_event_tsf_measurement_report(ar, skb);\r\nbreak;\r\ncase WMI_TLV_RTT_ERROR_REPORT_EVENTID:\r\nath10k_wmi_event_rtt_error_report(ar, skb);\r\nbreak;\r\ncase WMI_TLV_WOW_WAKEUP_HOST_EVENTID:\r\nath10k_wmi_event_wow_wakeup_host(ar, skb);\r\nbreak;\r\ncase WMI_TLV_DCS_INTERFERENCE_EVENTID:\r\nath10k_wmi_event_dcs_interference(ar, skb);\r\nbreak;\r\ncase WMI_TLV_PDEV_TPC_CONFIG_EVENTID:\r\nath10k_wmi_event_pdev_tpc_config(ar, skb);\r\nbreak;\r\ncase WMI_TLV_PDEV_FTM_INTG_EVENTID:\r\nath10k_wmi_event_pdev_ftm_intg(ar, skb);\r\nbreak;\r\ncase WMI_TLV_GTK_OFFLOAD_STATUS_EVENTID:\r\nath10k_wmi_event_gtk_offload_status(ar, skb);\r\nbreak;\r\ncase WMI_TLV_GTK_REKEY_FAIL_EVENTID:\r\nath10k_wmi_event_gtk_rekey_fail(ar, skb);\r\nbreak;\r\ncase WMI_TLV_TX_DELBA_COMPLETE_EVENTID:\r\nath10k_wmi_event_delba_complete(ar, skb);\r\nbreak;\r\ncase WMI_TLV_TX_ADDBA_COMPLETE_EVENTID:\r\nath10k_wmi_event_addba_complete(ar, skb);\r\nbreak;\r\ncase WMI_TLV_VDEV_INSTALL_KEY_COMPLETE_EVENTID:\r\nath10k_wmi_event_vdev_install_key_complete(ar, skb);\r\nbreak;\r\ncase WMI_TLV_SERVICE_READY_EVENTID:\r\nath10k_wmi_event_service_ready(ar, skb);\r\nreturn;\r\ncase WMI_TLV_READY_EVENTID:\r\nath10k_wmi_event_ready(ar, skb);\r\nbreak;\r\ncase WMI_TLV_OFFLOAD_BCN_TX_STATUS_EVENTID:\r\nath10k_wmi_tlv_event_bcn_tx_status(ar, skb);\r\nbreak;\r\ncase WMI_TLV_DIAG_DATA_CONTAINER_EVENTID:\r\nath10k_wmi_tlv_event_diag_data(ar, skb);\r\nbreak;\r\ncase WMI_TLV_DIAG_EVENTID:\r\nath10k_wmi_tlv_event_diag(ar, skb);\r\nbreak;\r\ncase WMI_TLV_P2P_NOA_EVENTID:\r\nath10k_wmi_tlv_event_p2p_noa(ar, skb);\r\nbreak;\r\ncase WMI_TLV_TX_PAUSE_EVENTID:\r\nath10k_wmi_tlv_event_tx_pause(ar, skb);\r\nbreak;\r\ndefault:\r\nath10k_warn(ar, "Unknown eventid: %d\n", id);\r\nbreak;\r\n}\r\nout:\r\ndev_kfree_skb(skb);\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_scan_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_scan_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_scan_event *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_SCAN_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->event_type = ev->event_type;\r\narg->reason = ev->reason;\r\narg->channel_freq = ev->channel_freq;\r\narg->scan_req_id = ev->scan_req_id;\r\narg->scan_id = ev->scan_id;\r\narg->vdev_id = ev->vdev_id;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_mgmt_rx_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_mgmt_rx_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_mgmt_rx_ev *ev;\r\nconst u8 *frame;\r\nu32 msdu_len;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_MGMT_RX_HDR];\r\nframe = tb[WMI_TLV_TAG_ARRAY_BYTE];\r\nif (!ev || !frame) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->channel = ev->channel;\r\narg->buf_len = ev->buf_len;\r\narg->status = ev->status;\r\narg->snr = ev->snr;\r\narg->phy_mode = ev->phy_mode;\r\narg->rate = ev->rate;\r\nmsdu_len = __le32_to_cpu(arg->buf_len);\r\nif (skb->len < (frame - skb->data) + msdu_len) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\nskb_trim(skb, 0);\r\nskb_put(skb, frame - skb->data);\r\nskb_pull(skb, frame - skb->data);\r\nskb_put(skb, msdu_len);\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_ch_info_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_ch_info_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_chan_info_event *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_CHAN_INFO_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->err_code = ev->err_code;\r\narg->freq = ev->freq;\r\narg->cmd_flags = ev->cmd_flags;\r\narg->noise_floor = ev->noise_floor;\r\narg->rx_clear_count = ev->rx_clear_count;\r\narg->cycle_count = ev->cycle_count;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int\r\nath10k_wmi_tlv_op_pull_vdev_start_ev(struct ath10k *ar, struct sk_buff *skb,\r\nstruct wmi_vdev_start_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_vdev_start_response_event *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_VDEV_START_RESPONSE_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\nskb_pull(skb, sizeof(*ev));\r\narg->vdev_id = ev->vdev_id;\r\narg->req_id = ev->req_id;\r\narg->resp_type = ev->resp_type;\r\narg->status = ev->status;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_peer_kick_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_peer_kick_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_peer_sta_kickout_event *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_PEER_STA_KICKOUT_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->mac_addr = ev->peer_macaddr.addr;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_swba_tim_parse(struct ath10k *ar, u16 tag, u16 len,\r\nconst void *ptr, void *data)\r\n{\r\nstruct wmi_tlv_swba_parse *swba = data;\r\nstruct wmi_tim_info_arg *tim_info_arg;\r\nconst struct wmi_tim_info *tim_info_ev = ptr;\r\nif (tag != WMI_TLV_TAG_STRUCT_TIM_INFO)\r\nreturn -EPROTO;\r\nif (swba->n_tim >= ARRAY_SIZE(swba->arg->tim_info))\r\nreturn -ENOBUFS;\r\nif (__le32_to_cpu(tim_info_ev->tim_len) >\r\nsizeof(tim_info_ev->tim_bitmap)) {\r\nath10k_warn(ar, "refusing to parse invalid swba structure\n");\r\nreturn -EPROTO;\r\n}\r\ntim_info_arg = &swba->arg->tim_info[swba->n_tim];\r\ntim_info_arg->tim_len = tim_info_ev->tim_len;\r\ntim_info_arg->tim_mcast = tim_info_ev->tim_mcast;\r\ntim_info_arg->tim_bitmap = tim_info_ev->tim_bitmap;\r\ntim_info_arg->tim_changed = tim_info_ev->tim_changed;\r\ntim_info_arg->tim_num_ps_pending = tim_info_ev->tim_num_ps_pending;\r\nswba->n_tim++;\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_swba_noa_parse(struct ath10k *ar, u16 tag, u16 len,\r\nconst void *ptr, void *data)\r\n{\r\nstruct wmi_tlv_swba_parse *swba = data;\r\nif (tag != WMI_TLV_TAG_STRUCT_P2P_NOA_INFO)\r\nreturn -EPROTO;\r\nif (swba->n_noa >= ARRAY_SIZE(swba->arg->noa_info))\r\nreturn -ENOBUFS;\r\nswba->arg->noa_info[swba->n_noa++] = ptr;\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_swba_parse(struct ath10k *ar, u16 tag, u16 len,\r\nconst void *ptr, void *data)\r\n{\r\nstruct wmi_tlv_swba_parse *swba = data;\r\nint ret;\r\nswitch (tag) {\r\ncase WMI_TLV_TAG_STRUCT_HOST_SWBA_EVENT:\r\nswba->ev = ptr;\r\nbreak;\r\ncase WMI_TLV_TAG_ARRAY_STRUCT:\r\nif (!swba->tim_done) {\r\nswba->tim_done = true;\r\nret = ath10k_wmi_tlv_iter(ar, ptr, len,\r\nath10k_wmi_tlv_swba_tim_parse,\r\nswba);\r\nif (ret)\r\nreturn ret;\r\n} else if (!swba->noa_done) {\r\nswba->noa_done = true;\r\nret = ath10k_wmi_tlv_iter(ar, ptr, len,\r\nath10k_wmi_tlv_swba_noa_parse,\r\nswba);\r\nif (ret)\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_swba_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_swba_ev_arg *arg)\r\n{\r\nstruct wmi_tlv_swba_parse swba = { .arg = arg };\r\nu32 map;\r\nsize_t n_vdevs;\r\nint ret;\r\nret = ath10k_wmi_tlv_iter(ar, skb->data, skb->len,\r\nath10k_wmi_tlv_swba_parse, &swba);\r\nif (ret) {\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!swba.ev)\r\nreturn -EPROTO;\r\narg->vdev_map = swba.ev->vdev_map;\r\nfor (map = __le32_to_cpu(arg->vdev_map), n_vdevs = 0; map; map >>= 1)\r\nif (map & BIT(0))\r\nn_vdevs++;\r\nif (n_vdevs != swba.n_tim ||\r\nn_vdevs != swba.n_noa)\r\nreturn -EPROTO;\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_phyerr_ev_hdr(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_phyerr_hdr_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_phyerr_ev *ev;\r\nconst void *phyerrs;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_COMB_PHYERR_RX_HDR];\r\nphyerrs = tb[WMI_TLV_TAG_ARRAY_BYTE];\r\nif (!ev || !phyerrs) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->num_phyerrs = __le32_to_cpu(ev->num_phyerrs);\r\narg->tsf_l32 = __le32_to_cpu(ev->tsf_l32);\r\narg->tsf_u32 = __le32_to_cpu(ev->tsf_u32);\r\narg->buf_len = __le32_to_cpu(ev->buf_len);\r\narg->phyerrs = phyerrs;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int\r\nath10k_wmi_tlv_parse_mem_reqs(struct ath10k *ar, u16 tag, u16 len,\r\nconst void *ptr, void *data)\r\n{\r\nstruct wmi_svc_rdy_ev_arg *arg = data;\r\nint i;\r\nif (tag != WMI_TLV_TAG_STRUCT_WLAN_HOST_MEM_REQ)\r\nreturn -EPROTO;\r\nfor (i = 0; i < ARRAY_SIZE(arg->mem_reqs); i++) {\r\nif (!arg->mem_reqs[i]) {\r\narg->mem_reqs[i] = ptr;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_svc_rdy_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_svc_rdy_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct hal_reg_capabilities *reg;\r\nconst struct wmi_tlv_svc_rdy_ev *ev;\r\nconst __le32 *svc_bmap;\r\nconst struct wlan_host_mem_req *mem_reqs;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_SERVICE_READY_EVENT];\r\nreg = tb[WMI_TLV_TAG_STRUCT_HAL_REG_CAPABILITIES];\r\nsvc_bmap = tb[WMI_TLV_TAG_ARRAY_UINT32];\r\nmem_reqs = tb[WMI_TLV_TAG_ARRAY_STRUCT];\r\nif (!ev || !reg || !svc_bmap || !mem_reqs) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv abi 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x, 0x%08x ?= 0x%08x\n",\r\n__le32_to_cpu(ev->abi.abi_ver0), WMI_TLV_ABI_VER0,\r\n__le32_to_cpu(ev->abi.abi_ver_ns0), WMI_TLV_ABI_VER_NS0,\r\n__le32_to_cpu(ev->abi.abi_ver_ns1), WMI_TLV_ABI_VER_NS1,\r\n__le32_to_cpu(ev->abi.abi_ver_ns2), WMI_TLV_ABI_VER_NS2,\r\n__le32_to_cpu(ev->abi.abi_ver_ns3), WMI_TLV_ABI_VER_NS3);\r\nif (__le32_to_cpu(ev->abi.abi_ver0) != WMI_TLV_ABI_VER0 ||\r\n__le32_to_cpu(ev->abi.abi_ver_ns0) != WMI_TLV_ABI_VER_NS0 ||\r\n__le32_to_cpu(ev->abi.abi_ver_ns1) != WMI_TLV_ABI_VER_NS1 ||\r\n__le32_to_cpu(ev->abi.abi_ver_ns2) != WMI_TLV_ABI_VER_NS2 ||\r\n__le32_to_cpu(ev->abi.abi_ver_ns3) != WMI_TLV_ABI_VER_NS3) {\r\nkfree(tb);\r\nreturn -ENOTSUPP;\r\n}\r\narg->min_tx_power = ev->hw_min_tx_power;\r\narg->max_tx_power = ev->hw_max_tx_power;\r\narg->ht_cap = ev->ht_cap_info;\r\narg->vht_cap = ev->vht_cap_info;\r\narg->sw_ver0 = ev->abi.abi_ver0;\r\narg->sw_ver1 = ev->abi.abi_ver1;\r\narg->fw_build = ev->fw_build_vers;\r\narg->phy_capab = ev->phy_capability;\r\narg->num_rf_chains = ev->num_rf_chains;\r\narg->eeprom_rd = reg->eeprom_rd;\r\narg->num_mem_reqs = ev->num_mem_reqs;\r\narg->service_map = svc_bmap;\r\narg->service_map_len = ath10k_wmi_tlv_len(svc_bmap);\r\nret = ath10k_wmi_tlv_iter(ar, mem_reqs, ath10k_wmi_tlv_len(mem_reqs),\r\nath10k_wmi_tlv_parse_mem_reqs, arg);\r\nif (ret) {\r\nkfree(tb);\r\nath10k_warn(ar, "failed to parse mem_reqs tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_rdy_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_rdy_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_rdy_ev *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_READY_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->sw_version = ev->abi.abi_ver0;\r\narg->abi_version = ev->abi.abi_ver1;\r\narg->status = ev->status;\r\narg->mac_addr = ev->mac_addr.addr;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic void ath10k_wmi_tlv_pull_vdev_stats(const struct wmi_tlv_vdev_stats *src,\r\nstruct ath10k_fw_stats_vdev *dst)\r\n{\r\nint i;\r\ndst->vdev_id = __le32_to_cpu(src->vdev_id);\r\ndst->beacon_snr = __le32_to_cpu(src->beacon_snr);\r\ndst->data_snr = __le32_to_cpu(src->data_snr);\r\ndst->num_rx_frames = __le32_to_cpu(src->num_rx_frames);\r\ndst->num_rts_fail = __le32_to_cpu(src->num_rts_fail);\r\ndst->num_rts_success = __le32_to_cpu(src->num_rts_success);\r\ndst->num_rx_err = __le32_to_cpu(src->num_rx_err);\r\ndst->num_rx_discard = __le32_to_cpu(src->num_rx_discard);\r\ndst->num_tx_not_acked = __le32_to_cpu(src->num_tx_not_acked);\r\nfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames); i++)\r\ndst->num_tx_frames[i] =\r\n__le32_to_cpu(src->num_tx_frames[i]);\r\nfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_retries); i++)\r\ndst->num_tx_frames_retries[i] =\r\n__le32_to_cpu(src->num_tx_frames_retries[i]);\r\nfor (i = 0; i < ARRAY_SIZE(src->num_tx_frames_failures); i++)\r\ndst->num_tx_frames_failures[i] =\r\n__le32_to_cpu(src->num_tx_frames_failures[i]);\r\nfor (i = 0; i < ARRAY_SIZE(src->tx_rate_history); i++)\r\ndst->tx_rate_history[i] =\r\n__le32_to_cpu(src->tx_rate_history[i]);\r\nfor (i = 0; i < ARRAY_SIZE(src->beacon_rssi_history); i++)\r\ndst->beacon_rssi_history[i] =\r\n__le32_to_cpu(src->beacon_rssi_history[i]);\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_fw_stats(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct ath10k_fw_stats *stats)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_stats_ev *ev;\r\nconst void *data;\r\nu32 num_pdev_stats;\r\nu32 num_vdev_stats;\r\nu32 num_peer_stats;\r\nu32 num_bcnflt_stats;\r\nu32 num_chan_stats;\r\nsize_t data_len;\r\nint ret;\r\nint i;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_STATS_EVENT];\r\ndata = tb[WMI_TLV_TAG_ARRAY_BYTE];\r\nif (!ev || !data) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\ndata_len = ath10k_wmi_tlv_len(data);\r\nnum_pdev_stats = __le32_to_cpu(ev->num_pdev_stats);\r\nnum_vdev_stats = __le32_to_cpu(ev->num_vdev_stats);\r\nnum_peer_stats = __le32_to_cpu(ev->num_peer_stats);\r\nnum_bcnflt_stats = __le32_to_cpu(ev->num_bcnflt_stats);\r\nnum_chan_stats = __le32_to_cpu(ev->num_chan_stats);\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv stats update pdev %i vdev %i peer %i bcnflt %i chan %i\n",\r\nnum_pdev_stats, num_vdev_stats, num_peer_stats,\r\nnum_bcnflt_stats, num_chan_stats);\r\nfor (i = 0; i < num_pdev_stats; i++) {\r\nconst struct wmi_pdev_stats *src;\r\nstruct ath10k_fw_stats_pdev *dst;\r\nsrc = data;\r\nif (data_len < sizeof(*src)) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\ndata += sizeof(*src);\r\ndata_len -= sizeof(*src);\r\ndst = kzalloc(sizeof(*dst), GFP_ATOMIC);\r\nif (!dst)\r\ncontinue;\r\nath10k_wmi_pull_pdev_stats_base(&src->base, dst);\r\nath10k_wmi_pull_pdev_stats_tx(&src->tx, dst);\r\nath10k_wmi_pull_pdev_stats_rx(&src->rx, dst);\r\nlist_add_tail(&dst->list, &stats->pdevs);\r\n}\r\nfor (i = 0; i < num_vdev_stats; i++) {\r\nconst struct wmi_tlv_vdev_stats *src;\r\nstruct ath10k_fw_stats_vdev *dst;\r\nsrc = data;\r\nif (data_len < sizeof(*src)) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\ndata += sizeof(*src);\r\ndata_len -= sizeof(*src);\r\ndst = kzalloc(sizeof(*dst), GFP_ATOMIC);\r\nif (!dst)\r\ncontinue;\r\nath10k_wmi_tlv_pull_vdev_stats(src, dst);\r\nlist_add_tail(&dst->list, &stats->vdevs);\r\n}\r\nfor (i = 0; i < num_peer_stats; i++) {\r\nconst struct wmi_10x_peer_stats *src;\r\nstruct ath10k_fw_stats_peer *dst;\r\nsrc = data;\r\nif (data_len < sizeof(*src)) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\ndata += sizeof(*src);\r\ndata_len -= sizeof(*src);\r\ndst = kzalloc(sizeof(*dst), GFP_ATOMIC);\r\nif (!dst)\r\ncontinue;\r\nath10k_wmi_pull_peer_stats(&src->old, dst);\r\ndst->peer_rx_rate = __le32_to_cpu(src->peer_rx_rate);\r\nlist_add_tail(&dst->list, &stats->peers);\r\n}\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_roam_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_roam_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_roam_ev *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_ROAM_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->vdev_id = ev->vdev_id;\r\narg->reason = ev->reason;\r\narg->rssi = ev->rssi;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int\r\nath10k_wmi_tlv_op_pull_wow_ev(struct ath10k *ar, struct sk_buff *skb,\r\nstruct wmi_wow_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_tlv_wow_event_info *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_WOW_EVENT_INFO];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->vdev_id = __le32_to_cpu(ev->vdev_id);\r\narg->flag = __le32_to_cpu(ev->flag);\r\narg->wake_reason = __le32_to_cpu(ev->wake_reason);\r\narg->data_len = __le32_to_cpu(ev->data_len);\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic int ath10k_wmi_tlv_op_pull_echo_ev(struct ath10k *ar,\r\nstruct sk_buff *skb,\r\nstruct wmi_echo_ev_arg *arg)\r\n{\r\nconst void **tb;\r\nconst struct wmi_echo_event *ev;\r\nint ret;\r\ntb = ath10k_wmi_tlv_parse_alloc(ar, skb->data, skb->len, GFP_ATOMIC);\r\nif (IS_ERR(tb)) {\r\nret = PTR_ERR(tb);\r\nath10k_warn(ar, "failed to parse tlv: %d\n", ret);\r\nreturn ret;\r\n}\r\nev = tb[WMI_TLV_TAG_STRUCT_ECHO_EVENT];\r\nif (!ev) {\r\nkfree(tb);\r\nreturn -EPROTO;\r\n}\r\narg->value = ev->value;\r\nkfree(tb);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pdev_suspend(struct ath10k *ar, u32 opt)\r\n{\r\nstruct wmi_tlv_pdev_suspend *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SUSPEND_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->opt = __cpu_to_le32(opt);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pdev suspend\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pdev_resume(struct ath10k *ar)\r\n{\r\nstruct wmi_tlv_resume_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_RESUME_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->reserved = __cpu_to_le32(0);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pdev resume\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pdev_set_rd(struct ath10k *ar,\r\nu16 rd, u16 rd2g, u16 rd5g,\r\nu16 ctl2g, u16 ctl5g,\r\nenum wmi_dfs_region dfs_reg)\r\n{\r\nstruct wmi_tlv_pdev_set_rd_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_REGDOMAIN_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->regd = __cpu_to_le32(rd);\r\ncmd->regd_2ghz = __cpu_to_le32(rd2g);\r\ncmd->regd_5ghz = __cpu_to_le32(rd5g);\r\ncmd->conform_limit_2ghz = __cpu_to_le32(ctl2g);\r\ncmd->conform_limit_5ghz = __cpu_to_le32(ctl5g);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pdev set rd\n");\r\nreturn skb;\r\n}\r\nstatic enum wmi_txbf_conf ath10k_wmi_tlv_txbf_conf_scheme(struct ath10k *ar)\r\n{\r\nreturn WMI_TXBF_CONF_AFTER_ASSOC;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pdev_set_param(struct ath10k *ar, u32 param_id,\r\nu32 param_value)\r\n{\r\nstruct wmi_tlv_pdev_set_param_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_PARAM_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->param_id = __cpu_to_le32(param_id);\r\ncmd->param_value = __cpu_to_le32(param_value);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pdev set param\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *ath10k_wmi_tlv_op_gen_init(struct ath10k *ar)\r\n{\r\nstruct sk_buff *skb;\r\nstruct wmi_tlv *tlv;\r\nstruct wmi_tlv_init_cmd *cmd;\r\nstruct wmi_tlv_resource_config *cfg;\r\nstruct wmi_host_mem_chunks *chunks;\r\nsize_t len, chunks_len;\r\nvoid *ptr;\r\nchunks_len = ar->wmi.num_mem_chunks * sizeof(struct host_memory_chunk);\r\nlen = (sizeof(*tlv) + sizeof(*cmd)) +\r\n(sizeof(*tlv) + sizeof(*cfg)) +\r\n(sizeof(*tlv) + chunks_len);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_INIT_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_RESOURCE_CONFIG);\r\ntlv->len = __cpu_to_le16(sizeof(*cfg));\r\ncfg = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cfg);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(chunks_len);\r\nchunks = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nptr += chunks_len;\r\ncmd->abi.abi_ver0 = __cpu_to_le32(WMI_TLV_ABI_VER0);\r\ncmd->abi.abi_ver1 = __cpu_to_le32(WMI_TLV_ABI_VER1);\r\ncmd->abi.abi_ver_ns0 = __cpu_to_le32(WMI_TLV_ABI_VER_NS0);\r\ncmd->abi.abi_ver_ns1 = __cpu_to_le32(WMI_TLV_ABI_VER_NS1);\r\ncmd->abi.abi_ver_ns2 = __cpu_to_le32(WMI_TLV_ABI_VER_NS2);\r\ncmd->abi.abi_ver_ns3 = __cpu_to_le32(WMI_TLV_ABI_VER_NS3);\r\ncmd->num_host_mem_chunks = __cpu_to_le32(ar->wmi.num_mem_chunks);\r\ncfg->num_vdevs = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\r\ncfg->num_peers = __cpu_to_le32(TARGET_TLV_NUM_PEERS);\r\nif (test_bit(WMI_SERVICE_RX_FULL_REORDER, ar->wmi.svc_map)) {\r\ncfg->num_offload_peers = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\r\ncfg->num_offload_reorder_bufs = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\r\n} else {\r\ncfg->num_offload_peers = __cpu_to_le32(0);\r\ncfg->num_offload_reorder_bufs = __cpu_to_le32(0);\r\n}\r\ncfg->num_peer_keys = __cpu_to_le32(2);\r\ncfg->num_tids = __cpu_to_le32(TARGET_TLV_NUM_TIDS);\r\ncfg->ast_skid_limit = __cpu_to_le32(0x10);\r\ncfg->tx_chain_mask = __cpu_to_le32(0x7);\r\ncfg->rx_chain_mask = __cpu_to_le32(0x7);\r\ncfg->rx_timeout_pri[0] = __cpu_to_le32(0x64);\r\ncfg->rx_timeout_pri[1] = __cpu_to_le32(0x64);\r\ncfg->rx_timeout_pri[2] = __cpu_to_le32(0x64);\r\ncfg->rx_timeout_pri[3] = __cpu_to_le32(0x28);\r\ncfg->rx_decap_mode = __cpu_to_le32(ar->wmi.rx_decap_mode);\r\ncfg->scan_max_pending_reqs = __cpu_to_le32(4);\r\ncfg->bmiss_offload_max_vdev = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\r\ncfg->roam_offload_max_vdev = __cpu_to_le32(TARGET_TLV_NUM_VDEVS);\r\ncfg->roam_offload_max_ap_profiles = __cpu_to_le32(8);\r\ncfg->num_mcast_groups = __cpu_to_le32(0);\r\ncfg->num_mcast_table_elems = __cpu_to_le32(0);\r\ncfg->mcast2ucast_mode = __cpu_to_le32(0);\r\ncfg->tx_dbg_log_size = __cpu_to_le32(0x400);\r\ncfg->num_wds_entries = __cpu_to_le32(0x20);\r\ncfg->dma_burst_size = __cpu_to_le32(0);\r\ncfg->mac_aggr_delim = __cpu_to_le32(0);\r\ncfg->rx_skip_defrag_timeout_dup_detection_check = __cpu_to_le32(0);\r\ncfg->vow_config = __cpu_to_le32(0);\r\ncfg->gtk_offload_max_vdev = __cpu_to_le32(2);\r\ncfg->num_msdu_desc = __cpu_to_le32(TARGET_TLV_NUM_MSDU_DESC);\r\ncfg->max_frag_entries = __cpu_to_le32(2);\r\ncfg->num_tdls_vdevs = __cpu_to_le32(TARGET_TLV_NUM_TDLS_VDEVS);\r\ncfg->num_tdls_conn_table_entries = __cpu_to_le32(0x20);\r\ncfg->beacon_tx_offload_max_vdev = __cpu_to_le32(2);\r\ncfg->num_multicast_filter_entries = __cpu_to_le32(5);\r\ncfg->num_wow_filters = __cpu_to_le32(ar->wow.max_num_patterns);\r\ncfg->num_keep_alive_pattern = __cpu_to_le32(6);\r\ncfg->keep_alive_pattern_size = __cpu_to_le32(0);\r\ncfg->max_tdls_concurrent_sleep_sta = __cpu_to_le32(1);\r\ncfg->max_tdls_concurrent_buffer_sta = __cpu_to_le32(1);\r\nath10k_wmi_put_host_mem_chunks(ar, chunks);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv init\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_start_scan(struct ath10k *ar,\r\nconst struct wmi_start_scan_arg *arg)\r\n{\r\nstruct wmi_tlv_start_scan_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len, chan_len, ssid_len, bssid_len, ie_len;\r\n__le32 *chans;\r\nstruct wmi_ssid *ssids;\r\nstruct wmi_mac_addr *addrs;\r\nvoid *ptr;\r\nint i, ret;\r\nret = ath10k_wmi_start_scan_verify(arg);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nchan_len = arg->n_channels * sizeof(__le32);\r\nssid_len = arg->n_ssids * sizeof(struct wmi_ssid);\r\nbssid_len = arg->n_bssids * sizeof(struct wmi_mac_addr);\r\nie_len = roundup(arg->ie_len, 4);\r\nlen = (sizeof(*tlv) + sizeof(*cmd)) +\r\n(arg->n_channels ? sizeof(*tlv) + chan_len : 0) +\r\n(arg->n_ssids ? sizeof(*tlv) + ssid_len : 0) +\r\n(arg->n_bssids ? sizeof(*tlv) + bssid_len : 0) +\r\n(arg->ie_len ? sizeof(*tlv) + ie_len : 0);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_START_SCAN_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\nath10k_wmi_put_start_scan_common(&cmd->common, arg);\r\ncmd->burst_duration_ms = __cpu_to_le32(arg->burst_duration_ms);\r\ncmd->num_channels = __cpu_to_le32(arg->n_channels);\r\ncmd->num_ssids = __cpu_to_le32(arg->n_ssids);\r\ncmd->num_bssids = __cpu_to_le32(arg->n_bssids);\r\ncmd->ie_len = __cpu_to_le32(arg->ie_len);\r\ncmd->num_probes = __cpu_to_le32(3);\r\ncmd->common.scan_ctrl_flags ^= __cpu_to_le32(WMI_SCAN_FILTER_PROBE_REQ);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\r\ntlv->len = __cpu_to_le16(chan_len);\r\nchans = (void *)tlv->value;\r\nfor (i = 0; i < arg->n_channels; i++)\r\nchans[i] = __cpu_to_le32(arg->channels[i]);\r\nptr += sizeof(*tlv);\r\nptr += chan_len;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_FIXED_STRUCT);\r\ntlv->len = __cpu_to_le16(ssid_len);\r\nssids = (void *)tlv->value;\r\nfor (i = 0; i < arg->n_ssids; i++) {\r\nssids[i].ssid_len = __cpu_to_le32(arg->ssids[i].len);\r\nmemcpy(ssids[i].ssid, arg->ssids[i].ssid, arg->ssids[i].len);\r\n}\r\nptr += sizeof(*tlv);\r\nptr += ssid_len;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_FIXED_STRUCT);\r\ntlv->len = __cpu_to_le16(bssid_len);\r\naddrs = (void *)tlv->value;\r\nfor (i = 0; i < arg->n_bssids; i++)\r\nether_addr_copy(addrs[i].addr, arg->bssids[i].bssid);\r\nptr += sizeof(*tlv);\r\nptr += bssid_len;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(ie_len);\r\nmemcpy(tlv->value, arg->ie, arg->ie_len);\r\nptr += sizeof(*tlv);\r\nptr += ie_len;\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv start scan\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_stop_scan(struct ath10k *ar,\r\nconst struct wmi_stop_scan_arg *arg)\r\n{\r\nstruct wmi_stop_scan_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nu32 scan_id;\r\nu32 req_id;\r\nif (arg->req_id > 0xFFF)\r\nreturn ERR_PTR(-EINVAL);\r\nif (arg->req_type == WMI_SCAN_STOP_ONE && arg->u.scan_id > 0xFFF)\r\nreturn ERR_PTR(-EINVAL);\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nscan_id = arg->u.scan_id;\r\nscan_id |= WMI_HOST_SCAN_REQ_ID_PREFIX;\r\nreq_id = arg->req_id;\r\nreq_id |= WMI_HOST_SCAN_REQUESTOR_ID_PREFIX;\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STOP_SCAN_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->req_type = __cpu_to_le32(arg->req_type);\r\ncmd->vdev_id = __cpu_to_le32(arg->u.vdev_id);\r\ncmd->scan_id = __cpu_to_le32(scan_id);\r\ncmd->scan_req_id = __cpu_to_le32(req_id);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv stop scan\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_create(struct ath10k *ar,\r\nu32 vdev_id,\r\nenum wmi_vdev_type vdev_type,\r\nenum wmi_vdev_subtype vdev_subtype,\r\nconst u8 mac_addr[ETH_ALEN])\r\n{\r\nstruct wmi_vdev_create_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_CREATE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->vdev_type = __cpu_to_le32(vdev_type);\r\ncmd->vdev_subtype = __cpu_to_le32(vdev_subtype);\r\nether_addr_copy(cmd->vdev_macaddr.addr, mac_addr);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev create\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_delete(struct ath10k *ar, u32 vdev_id)\r\n{\r\nstruct wmi_vdev_delete_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_DELETE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev delete\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_start(struct ath10k *ar,\r\nconst struct wmi_vdev_start_request_arg *arg,\r\nbool restart)\r\n{\r\nstruct wmi_tlv_vdev_start_cmd *cmd;\r\nstruct wmi_channel *ch;\r\nstruct wmi_p2p_noa_descriptor *noa;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nvoid *ptr;\r\nu32 flags = 0;\r\nif (WARN_ON(arg->hidden_ssid && !arg->ssid))\r\nreturn ERR_PTR(-EINVAL);\r\nif (WARN_ON(arg->ssid_len > sizeof(cmd->ssid.ssid)))\r\nreturn ERR_PTR(-EINVAL);\r\nlen = (sizeof(*tlv) + sizeof(*cmd)) +\r\n(sizeof(*tlv) + sizeof(*ch)) +\r\n(sizeof(*tlv) + 0);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nif (arg->hidden_ssid)\r\nflags |= WMI_VDEV_START_HIDDEN_SSID;\r\nif (arg->pmf_enabled)\r\nflags |= WMI_VDEV_START_PMF_ENABLED;\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_START_REQUEST_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(arg->vdev_id);\r\ncmd->bcn_intval = __cpu_to_le32(arg->bcn_intval);\r\ncmd->dtim_period = __cpu_to_le32(arg->dtim_period);\r\ncmd->flags = __cpu_to_le32(flags);\r\ncmd->bcn_tx_rate = __cpu_to_le32(arg->bcn_tx_rate);\r\ncmd->bcn_tx_power = __cpu_to_le32(arg->bcn_tx_power);\r\ncmd->disable_hw_ack = __cpu_to_le32(arg->disable_hw_ack);\r\nif (arg->ssid) {\r\ncmd->ssid.ssid_len = __cpu_to_le32(arg->ssid_len);\r\nmemcpy(cmd->ssid.ssid, arg->ssid, arg->ssid_len);\r\n}\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);\r\ntlv->len = __cpu_to_le16(sizeof(*ch));\r\nch = (void *)tlv->value;\r\nath10k_wmi_put_wmi_channel(ch, &arg->channel);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*ch);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = 0;\r\nnoa = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nptr += 0;\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev start\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_stop(struct ath10k *ar, u32 vdev_id)\r\n{\r\nstruct wmi_vdev_stop_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_STOP_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev stop\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_up(struct ath10k *ar, u32 vdev_id, u32 aid,\r\nconst u8 *bssid)\r\n{\r\nstruct wmi_vdev_up_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_UP_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->vdev_assoc_id = __cpu_to_le32(aid);\r\nether_addr_copy(cmd->vdev_bssid.addr, bssid);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev up\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_down(struct ath10k *ar, u32 vdev_id)\r\n{\r\nstruct wmi_vdev_down_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_DOWN_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev down\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_set_param(struct ath10k *ar, u32 vdev_id,\r\nu32 param_id, u32 param_value)\r\n{\r\nstruct wmi_vdev_set_param_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SET_PARAM_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->param_id = __cpu_to_le32(param_id);\r\ncmd->param_value = __cpu_to_le32(param_value);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev set param\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_install_key(struct ath10k *ar,\r\nconst struct wmi_vdev_install_key_arg *arg)\r\n{\r\nstruct wmi_vdev_install_key_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nvoid *ptr;\r\nif (arg->key_cipher == WMI_CIPHER_NONE && arg->key_data != NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nif (arg->key_cipher != WMI_CIPHER_NONE && arg->key_data == NULL)\r\nreturn ERR_PTR(-EINVAL);\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + roundup(arg->key_len, sizeof(__le32));\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_INSTALL_KEY_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(arg->vdev_id);\r\ncmd->key_idx = __cpu_to_le32(arg->key_idx);\r\ncmd->key_flags = __cpu_to_le32(arg->key_flags);\r\ncmd->key_cipher = __cpu_to_le32(arg->key_cipher);\r\ncmd->key_len = __cpu_to_le32(arg->key_len);\r\ncmd->key_txmic_len = __cpu_to_le32(arg->key_txmic_len);\r\ncmd->key_rxmic_len = __cpu_to_le32(arg->key_rxmic_len);\r\nif (arg->macaddr)\r\nether_addr_copy(cmd->peer_macaddr.addr, arg->macaddr);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(roundup(arg->key_len, sizeof(__le32)));\r\nif (arg->key_data)\r\nmemcpy(tlv->value, arg->key_data, arg->key_len);\r\nptr += sizeof(*tlv);\r\nptr += roundup(arg->key_len, sizeof(__le32));\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev install key\n");\r\nreturn skb;\r\n}\r\nstatic void *ath10k_wmi_tlv_put_uapsd_ac(struct ath10k *ar, void *ptr,\r\nconst struct wmi_sta_uapsd_auto_trig_arg *arg)\r\n{\r\nstruct wmi_sta_uapsd_auto_trig_param *ac;\r\nstruct wmi_tlv *tlv;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_UAPSD_AUTO_TRIG_PARAM);\r\ntlv->len = __cpu_to_le16(sizeof(*ac));\r\nac = (void *)tlv->value;\r\nac->wmm_ac = __cpu_to_le32(arg->wmm_ac);\r\nac->user_priority = __cpu_to_le32(arg->user_priority);\r\nac->service_interval = __cpu_to_le32(arg->service_interval);\r\nac->suspend_interval = __cpu_to_le32(arg->suspend_interval);\r\nac->delay_interval = __cpu_to_le32(arg->delay_interval);\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv vdev sta uapsd auto trigger ac %d prio %d svc int %d susp int %d delay int %d\n",\r\nac->wmm_ac, ac->user_priority, ac->service_interval,\r\nac->suspend_interval, ac->delay_interval);\r\nreturn ptr + sizeof(*tlv) + sizeof(*ac);\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_sta_uapsd(struct ath10k *ar, u32 vdev_id,\r\nconst u8 peer_addr[ETH_ALEN],\r\nconst struct wmi_sta_uapsd_auto_trig_arg *args,\r\nu32 num_ac)\r\n{\r\nstruct wmi_sta_uapsd_auto_trig_cmd_fixed_param *cmd;\r\nstruct wmi_sta_uapsd_auto_trig_param *ac;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nsize_t ac_tlv_len;\r\nvoid *ptr;\r\nint i;\r\nac_tlv_len = num_ac * (sizeof(*tlv) + sizeof(*ac));\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + ac_tlv_len;\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_UAPSD_AUTO_TRIG_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->num_ac = __cpu_to_le32(num_ac);\r\nether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(ac_tlv_len);\r\nac = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nfor (i = 0; i < num_ac; i++)\r\nptr = ath10k_wmi_tlv_put_uapsd_ac(ar, ptr, &args[i]);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev sta uapsd auto trigger\n");\r\nreturn skb;\r\n}\r\nstatic void *ath10k_wmi_tlv_put_wmm(void *ptr,\r\nconst struct wmi_wmm_params_arg *arg)\r\n{\r\nstruct wmi_wmm_params *wmm;\r\nstruct wmi_tlv *tlv;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WMM_PARAMS);\r\ntlv->len = __cpu_to_le16(sizeof(*wmm));\r\nwmm = (void *)tlv->value;\r\nath10k_wmi_set_wmm_param(wmm, arg);\r\nreturn ptr + sizeof(*tlv) + sizeof(*wmm);\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_wmm_conf(struct ath10k *ar, u32 vdev_id,\r\nconst struct wmi_wmm_params_all_arg *arg)\r\n{\r\nstruct wmi_tlv_vdev_set_wmm_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nvoid *ptr;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SET_WMM_PARAMS_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\nath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[0].params, &arg->ac_be);\r\nath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[1].params, &arg->ac_bk);\r\nath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[2].params, &arg->ac_vi);\r\nath10k_wmi_set_wmm_param(&cmd->vdev_wmm_params[3].params, &arg->ac_vo);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv vdev wmm conf\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_sta_keepalive(struct ath10k *ar,\r\nconst struct wmi_sta_keepalive_arg *arg)\r\n{\r\nstruct wmi_tlv_sta_keepalive_cmd *cmd;\r\nstruct wmi_sta_keepalive_arp_resp *arp;\r\nstruct sk_buff *skb;\r\nstruct wmi_tlv *tlv;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + sizeof(*arp);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_KEEPALIVE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(arg->vdev_id);\r\ncmd->enabled = __cpu_to_le32(arg->enabled);\r\ncmd->method = __cpu_to_le32(arg->method);\r\ncmd->interval = __cpu_to_le32(arg->interval);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_KEEPALVE_ARP_RESPONSE);\r\ntlv->len = __cpu_to_le16(sizeof(*arp));\r\narp = (void *)tlv->value;\r\narp->src_ip4_addr = arg->src_ip4_addr;\r\narp->dest_ip4_addr = arg->dest_ip4_addr;\r\nether_addr_copy(arp->dest_mac_addr.addr, arg->dest_mac_addr);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv sta keepalive vdev %d enabled %d method %d inverval %d\n",\r\narg->vdev_id, arg->enabled, arg->method, arg->interval);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_peer_create(struct ath10k *ar, u32 vdev_id,\r\nconst u8 peer_addr[ETH_ALEN],\r\nenum wmi_peer_type peer_type)\r\n{\r\nstruct wmi_tlv_peer_create_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_CREATE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->peer_type = __cpu_to_le32(peer_type);\r\nether_addr_copy(cmd->peer_addr.addr, peer_addr);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv peer create\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_peer_delete(struct ath10k *ar, u32 vdev_id,\r\nconst u8 peer_addr[ETH_ALEN])\r\n{\r\nstruct wmi_peer_delete_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_DELETE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\nether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv peer delete\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_peer_flush(struct ath10k *ar, u32 vdev_id,\r\nconst u8 peer_addr[ETH_ALEN], u32 tid_bitmap)\r\n{\r\nstruct wmi_peer_flush_tids_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_FLUSH_TIDS_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->peer_tid_bitmap = __cpu_to_le32(tid_bitmap);\r\nether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv peer flush\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,\r\nconst u8 *peer_addr,\r\nenum wmi_peer_param param_id,\r\nu32 param_value)\r\n{\r\nstruct wmi_peer_set_param_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_SET_PARAM_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->param_id = __cpu_to_le32(param_id);\r\ncmd->param_value = __cpu_to_le32(param_value);\r\nether_addr_copy(cmd->peer_macaddr.addr, peer_addr);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv peer set param\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_peer_assoc(struct ath10k *ar,\r\nconst struct wmi_peer_assoc_complete_arg *arg)\r\n{\r\nstruct wmi_tlv_peer_assoc_cmd *cmd;\r\nstruct wmi_vht_rate_set *vht_rate;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len, legacy_rate_len, ht_rate_len;\r\nvoid *ptr;\r\nif (arg->peer_mpdu_density > 16)\r\nreturn ERR_PTR(-EINVAL);\r\nif (arg->peer_legacy_rates.num_rates > MAX_SUPPORTED_RATES)\r\nreturn ERR_PTR(-EINVAL);\r\nif (arg->peer_ht_rates.num_rates > MAX_SUPPORTED_RATES)\r\nreturn ERR_PTR(-EINVAL);\r\nlegacy_rate_len = roundup(arg->peer_legacy_rates.num_rates,\r\nsizeof(__le32));\r\nht_rate_len = roundup(arg->peer_ht_rates.num_rates, sizeof(__le32));\r\nlen = (sizeof(*tlv) + sizeof(*cmd)) +\r\n(sizeof(*tlv) + legacy_rate_len) +\r\n(sizeof(*tlv) + ht_rate_len) +\r\n(sizeof(*tlv) + sizeof(*vht_rate));\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PEER_ASSOC_COMPLETE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(arg->vdev_id);\r\ncmd->new_assoc = __cpu_to_le32(arg->peer_reassoc ? 0 : 1);\r\ncmd->assoc_id = __cpu_to_le32(arg->peer_aid);\r\ncmd->flags = __cpu_to_le32(arg->peer_flags);\r\ncmd->caps = __cpu_to_le32(arg->peer_caps);\r\ncmd->listen_intval = __cpu_to_le32(arg->peer_listen_intval);\r\ncmd->ht_caps = __cpu_to_le32(arg->peer_ht_caps);\r\ncmd->max_mpdu = __cpu_to_le32(arg->peer_max_mpdu);\r\ncmd->mpdu_density = __cpu_to_le32(arg->peer_mpdu_density);\r\ncmd->rate_caps = __cpu_to_le32(arg->peer_rate_caps);\r\ncmd->nss = __cpu_to_le32(arg->peer_num_spatial_streams);\r\ncmd->vht_caps = __cpu_to_le32(arg->peer_vht_caps);\r\ncmd->phy_mode = __cpu_to_le32(arg->peer_phymode);\r\ncmd->num_legacy_rates = __cpu_to_le32(arg->peer_legacy_rates.num_rates);\r\ncmd->num_ht_rates = __cpu_to_le32(arg->peer_ht_rates.num_rates);\r\nether_addr_copy(cmd->mac_addr.addr, arg->addr);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(legacy_rate_len);\r\nmemcpy(tlv->value, arg->peer_legacy_rates.rates,\r\narg->peer_legacy_rates.num_rates);\r\nptr += sizeof(*tlv);\r\nptr += legacy_rate_len;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(ht_rate_len);\r\nmemcpy(tlv->value, arg->peer_ht_rates.rates,\r\narg->peer_ht_rates.num_rates);\r\nptr += sizeof(*tlv);\r\nptr += ht_rate_len;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VHT_RATE_SET);\r\ntlv->len = __cpu_to_le16(sizeof(*vht_rate));\r\nvht_rate = (void *)tlv->value;\r\nvht_rate->rx_max_rate = __cpu_to_le32(arg->peer_vht_rates.rx_max_rate);\r\nvht_rate->rx_mcs_set = __cpu_to_le32(arg->peer_vht_rates.rx_mcs_set);\r\nvht_rate->tx_max_rate = __cpu_to_le32(arg->peer_vht_rates.tx_max_rate);\r\nvht_rate->tx_mcs_set = __cpu_to_le32(arg->peer_vht_rates.tx_mcs_set);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*vht_rate);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv peer assoc\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,\r\nenum wmi_sta_ps_mode psmode)\r\n{\r\nstruct wmi_sta_powersave_mode_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_POWERSAVE_MODE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->sta_ps_mode = __cpu_to_le32(psmode);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv set psmode\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_set_sta_ps(struct ath10k *ar, u32 vdev_id,\r\nenum wmi_sta_powersave_param param_id,\r\nu32 param_value)\r\n{\r\nstruct wmi_sta_powersave_param_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_STA_POWERSAVE_PARAM_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->param_id = __cpu_to_le32(param_id);\r\ncmd->param_value = __cpu_to_le32(param_value);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv set sta ps\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_set_ap_ps(struct ath10k *ar, u32 vdev_id, const u8 *mac,\r\nenum wmi_ap_ps_peer_param param_id, u32 value)\r\n{\r\nstruct wmi_ap_ps_peer_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nif (!mac)\r\nreturn ERR_PTR(-EINVAL);\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_AP_PS_PEER_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->param_id = __cpu_to_le32(param_id);\r\ncmd->param_value = __cpu_to_le32(value);\r\nether_addr_copy(cmd->peer_macaddr.addr, mac);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv ap ps param\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_scan_chan_list(struct ath10k *ar,\r\nconst struct wmi_scan_chan_list_arg *arg)\r\n{\r\nstruct wmi_tlv_scan_chan_list_cmd *cmd;\r\nstruct wmi_channel *ci;\r\nstruct wmi_channel_arg *ch;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t chans_len, len;\r\nint i;\r\nvoid *ptr, *chans;\r\nchans_len = arg->n_channels * (sizeof(*tlv) + sizeof(*ci));\r\nlen = (sizeof(*tlv) + sizeof(*cmd)) +\r\n(sizeof(*tlv) + chans_len);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_SCAN_CHAN_LIST_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->num_scan_chans = __cpu_to_le32(arg->n_channels);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(chans_len);\r\nchans = (void *)tlv->value;\r\nfor (i = 0; i < arg->n_channels; i++) {\r\nch = &arg->channels[i];\r\ntlv = chans;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);\r\ntlv->len = __cpu_to_le16(sizeof(*ci));\r\nci = (void *)tlv->value;\r\nath10k_wmi_put_wmi_channel(ci, ch);\r\nchans += sizeof(*tlv);\r\nchans += sizeof(*ci);\r\n}\r\nptr += sizeof(*tlv);\r\nptr += chans_len;\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv scan chan list\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_beacon_dma(struct ath10k *ar, u32 vdev_id,\r\nconst void *bcn, size_t bcn_len,\r\nu32 bcn_paddr, bool dtim_zero,\r\nbool deliver_cab)\r\n{\r\nstruct wmi_bcn_tx_ref_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nstruct ieee80211_hdr *hdr;\r\nu16 fc;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nhdr = (struct ieee80211_hdr *)bcn;\r\nfc = le16_to_cpu(hdr->frame_control);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_SEND_FROM_HOST_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->data_len = __cpu_to_le32(bcn_len);\r\ncmd->data_ptr = __cpu_to_le32(bcn_paddr);\r\ncmd->msdu_id = 0;\r\ncmd->frame_control = __cpu_to_le32(fc);\r\ncmd->flags = 0;\r\nif (dtim_zero)\r\ncmd->flags |= __cpu_to_le32(WMI_BCN_TX_REF_FLAG_DTIM_ZERO);\r\nif (deliver_cab)\r\ncmd->flags |= __cpu_to_le32(WMI_BCN_TX_REF_FLAG_DELIVER_CAB);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv beacon dma\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pdev_set_wmm(struct ath10k *ar,\r\nconst struct wmi_wmm_params_all_arg *arg)\r\n{\r\nstruct wmi_tlv_pdev_set_wmm_cmd *cmd;\r\nstruct wmi_wmm_params *wmm;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nvoid *ptr;\r\nlen = (sizeof(*tlv) + sizeof(*cmd)) +\r\n(4 * (sizeof(*tlv) + sizeof(*wmm)));\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_SET_WMM_PARAMS_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\nptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_be);\r\nptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_bk);\r\nptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_vi);\r\nptr = ath10k_wmi_tlv_put_wmm(ptr, &arg->ac_vo);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pdev set wmm\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_request_stats(struct ath10k *ar, u32 stats_mask)\r\n{\r\nstruct wmi_request_stats_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_REQUEST_STATS_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->stats_id = __cpu_to_le32(stats_mask);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv request stats\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_force_fw_hang(struct ath10k *ar,\r\nenum wmi_force_fw_hang_type type,\r\nu32 delay_ms)\r\n{\r\nstruct wmi_force_fw_hang_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nskb = ath10k_wmi_alloc_skb(ar, sizeof(*tlv) + sizeof(*cmd));\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (void *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_FORCE_FW_HANG_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->type = __cpu_to_le32(type);\r\ncmd->delay_ms = __cpu_to_le32(delay_ms);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv force fw hang\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_dbglog_cfg(struct ath10k *ar, u64 module_enable,\r\nu32 log_level) {\r\nstruct wmi_tlv_dbglog_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len, bmap_len;\r\nu32 value;\r\nvoid *ptr;\r\nif (module_enable) {\r\nvalue = WMI_TLV_DBGLOG_LOG_LEVEL_VALUE(\r\nmodule_enable,\r\nWMI_TLV_DBGLOG_LOG_LEVEL_VERBOSE);\r\n} else {\r\nvalue = WMI_TLV_DBGLOG_LOG_LEVEL_VALUE(\r\nWMI_TLV_DBGLOG_ALL_MODULES,\r\nWMI_TLV_DBGLOG_LOG_LEVEL_WARN);\r\n}\r\nbmap_len = 0;\r\nlen = sizeof(*tlv) + sizeof(*cmd) + sizeof(*tlv) + bmap_len;\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_DEBUG_LOG_CONFIG_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->param = __cpu_to_le32(WMI_TLV_DBGLOG_PARAM_LOG_LEVEL);\r\ncmd->value = __cpu_to_le32(value);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\r\ntlv->len = __cpu_to_le16(bmap_len);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(bmap_len);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv dbglog value 0x%08x\n", value);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pktlog_enable(struct ath10k *ar, u32 filter)\r\n{\r\nstruct wmi_tlv_pktlog_enable *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_PKTLOG_ENABLE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->filter = __cpu_to_le32(filter);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pktlog enable filter 0x%08x\n",\r\nfilter);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_pktlog_disable(struct ath10k *ar)\r\n{\r\nstruct wmi_tlv_pktlog_disable *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PDEV_PKTLOG_DISABLE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv pktlog disable\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_bcn_tmpl(struct ath10k *ar, u32 vdev_id,\r\nu32 tim_ie_offset, struct sk_buff *bcn,\r\nu32 prb_caps, u32 prb_erp, void *prb_ies,\r\nsize_t prb_ies_len)\r\n{\r\nstruct wmi_tlv_bcn_tmpl_cmd *cmd;\r\nstruct wmi_tlv_bcn_prb_info *info;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nif (WARN_ON(prb_ies_len > 0 && !prb_ies))\r\nreturn ERR_PTR(-EINVAL);\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + sizeof(*info) + prb_ies_len +\r\nsizeof(*tlv) + roundup(bcn->len, 4);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_TMPL_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->tim_ie_offset = __cpu_to_le32(tim_ie_offset);\r\ncmd->buf_len = __cpu_to_le32(bcn->len);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_PRB_INFO);\r\ntlv->len = __cpu_to_le16(sizeof(*info) + prb_ies_len);\r\ninfo = (void *)tlv->value;\r\ninfo->caps = __cpu_to_le32(prb_caps);\r\ninfo->erp = __cpu_to_le32(prb_erp);\r\nmemcpy(info->ies, prb_ies, prb_ies_len);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*info);\r\nptr += prb_ies_len;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(roundup(bcn->len, 4));\r\nmemcpy(tlv->value, bcn->data, bcn->len);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv bcn tmpl vdev_id %i\n",\r\nvdev_id);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_prb_tmpl(struct ath10k *ar, u32 vdev_id,\r\nstruct sk_buff *prb)\r\n{\r\nstruct wmi_tlv_prb_tmpl_cmd *cmd;\r\nstruct wmi_tlv_bcn_prb_info *info;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + sizeof(*info) +\r\nsizeof(*tlv) + roundup(prb->len, 4);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_PRB_TMPL_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->buf_len = __cpu_to_le32(prb->len);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_BCN_PRB_INFO);\r\ntlv->len = __cpu_to_le16(sizeof(*info));\r\ninfo = (void *)tlv->value;\r\ninfo->caps = 0;\r\ninfo->erp = 0;\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*info);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(roundup(prb->len, 4));\r\nmemcpy(tlv->value, prb->data, prb->len);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv prb tmpl vdev_id %i\n",\r\nvdev_id);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_p2p_go_bcn_ie(struct ath10k *ar, u32 vdev_id,\r\nconst u8 *p2p_ie)\r\n{\r\nstruct wmi_tlv_p2p_go_bcn_ie *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + roundup(p2p_ie[1] + 2, 4);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_P2P_GO_SET_BEACON_IE);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->ie_len = __cpu_to_le32(p2p_ie[1] + 2);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_BYTE);\r\ntlv->len = __cpu_to_le16(roundup(p2p_ie[1] + 2, 4));\r\nmemcpy(tlv->value, p2p_ie, p2p_ie[1] + 2);\r\nptr += sizeof(*tlv);\r\nptr += roundup(p2p_ie[1] + 2, 4);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv p2p go bcn ie for vdev %i\n",\r\nvdev_id);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_update_fw_tdls_state(struct ath10k *ar, u32 vdev_id,\r\nenum wmi_tdls_state state)\r\n{\r\nstruct wmi_tdls_set_state_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nu32 options = 0;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_SET_STATE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->state = __cpu_to_le32(state);\r\ncmd->notification_interval_ms = __cpu_to_le32(5000);\r\ncmd->tx_discovery_threshold = __cpu_to_le32(100);\r\ncmd->tx_teardown_threshold = __cpu_to_le32(5);\r\ncmd->rssi_teardown_threshold = __cpu_to_le32(-75);\r\ncmd->rssi_delta = __cpu_to_le32(-20);\r\ncmd->tdls_options = __cpu_to_le32(options);\r\ncmd->tdls_peer_traffic_ind_window = __cpu_to_le32(2);\r\ncmd->tdls_peer_traffic_response_timeout_ms = __cpu_to_le32(5000);\r\ncmd->tdls_puapsd_mask = __cpu_to_le32(0xf);\r\ncmd->tdls_puapsd_inactivity_time_ms = __cpu_to_le32(0);\r\ncmd->tdls_puapsd_rx_frame_threshold = __cpu_to_le32(10);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv update fw tdls state %d for vdev %i\n",\r\nstate, vdev_id);\r\nreturn skb;\r\n}\r\nstatic u32 ath10k_wmi_tlv_prepare_peer_qos(u8 uapsd_queues, u8 sp)\r\n{\r\nu32 peer_qos = 0;\r\nif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)\r\npeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_VO;\r\nif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_VI)\r\npeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_VI;\r\nif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BK)\r\npeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_BK;\r\nif (uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_BE)\r\npeer_qos |= WMI_TLV_TDLS_PEER_QOS_AC_BE;\r\npeer_qos |= SM(sp, WMI_TLV_TDLS_PEER_SP);\r\nreturn peer_qos;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_tdls_peer_update(struct ath10k *ar,\r\nconst struct wmi_tdls_peer_update_cmd_arg *arg,\r\nconst struct wmi_tdls_peer_capab_arg *cap,\r\nconst struct wmi_channel_arg *chan_arg)\r\n{\r\nstruct wmi_tdls_peer_update_cmd *cmd;\r\nstruct wmi_tdls_peer_capab *peer_cap;\r\nstruct wmi_channel *chan;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nu32 peer_qos;\r\nvoid *ptr;\r\nint len;\r\nint i;\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) + sizeof(*peer_cap) +\r\nsizeof(*tlv) + cap->peer_chan_len * sizeof(*chan);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_PEER_UPDATE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(arg->vdev_id);\r\nether_addr_copy(cmd->peer_macaddr.addr, arg->addr);\r\ncmd->peer_state = __cpu_to_le32(arg->peer_state);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_TDLS_PEER_CAPABILITIES);\r\ntlv->len = __cpu_to_le16(sizeof(*peer_cap));\r\npeer_cap = (void *)tlv->value;\r\npeer_qos = ath10k_wmi_tlv_prepare_peer_qos(cap->peer_uapsd_queues,\r\ncap->peer_max_sp);\r\npeer_cap->peer_qos = __cpu_to_le32(peer_qos);\r\npeer_cap->buff_sta_support = __cpu_to_le32(cap->buff_sta_support);\r\npeer_cap->off_chan_support = __cpu_to_le32(cap->off_chan_support);\r\npeer_cap->peer_curr_operclass = __cpu_to_le32(cap->peer_curr_operclass);\r\npeer_cap->self_curr_operclass = __cpu_to_le32(cap->self_curr_operclass);\r\npeer_cap->peer_chan_len = __cpu_to_le32(cap->peer_chan_len);\r\npeer_cap->peer_operclass_len = __cpu_to_le32(cap->peer_operclass_len);\r\nfor (i = 0; i < WMI_TDLS_MAX_SUPP_OPER_CLASSES; i++)\r\npeer_cap->peer_operclass[i] = cap->peer_operclass[i];\r\npeer_cap->is_peer_responder = __cpu_to_le32(cap->is_peer_responder);\r\npeer_cap->pref_offchan_num = __cpu_to_le32(cap->pref_offchan_num);\r\npeer_cap->pref_offchan_bw = __cpu_to_le32(cap->pref_offchan_bw);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*peer_cap);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(cap->peer_chan_len * sizeof(*chan));\r\nptr += sizeof(*tlv);\r\nfor (i = 0; i < cap->peer_chan_len; i++) {\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_CHANNEL);\r\ntlv->len = __cpu_to_le16(sizeof(*chan));\r\nchan = (void *)tlv->value;\r\nath10k_wmi_put_wmi_channel(chan, &chan_arg[i]);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*chan);\r\n}\r\nath10k_dbg(ar, ATH10K_DBG_WMI,\r\n"wmi tlv tdls peer update vdev %i state %d n_chans %u\n",\r\narg->vdev_id, arg->peer_state, cap->peer_chan_len);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_wow_enable(struct ath10k *ar)\r\n{\r\nstruct wmi_tlv_wow_enable_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (struct wmi_tlv *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ENABLE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->enable = __cpu_to_le32(1);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv wow enable\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_wow_add_wakeup_event(struct ath10k *ar,\r\nu32 vdev_id,\r\nenum wmi_wow_wakeup_event event,\r\nu32 enable)\r\n{\r\nstruct wmi_tlv_wow_add_del_event_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (struct wmi_tlv *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ADD_DEL_EVT_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->is_add = __cpu_to_le32(enable);\r\ncmd->event_bitmap = __cpu_to_le32(1 << event);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv wow add wakeup event %s enable %d vdev_id %d\n",\r\nwow_wakeup_event(event), enable, vdev_id);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_gen_wow_host_wakeup_ind(struct ath10k *ar)\r\n{\r\nstruct wmi_tlv_wow_host_wakeup_ind *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (struct wmi_tlv *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_HOSTWAKEUP_FROM_SLEEP_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv wow host wakeup ind\n");\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_wow_add_pattern(struct ath10k *ar, u32 vdev_id,\r\nu32 pattern_id, const u8 *pattern,\r\nconst u8 *bitmask, int pattern_len,\r\nint pattern_offset)\r\n{\r\nstruct wmi_tlv_wow_add_pattern_cmd *cmd;\r\nstruct wmi_tlv_wow_bitmap_pattern *bitmap;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd) +\r\nsizeof(*tlv) +\r\nsizeof(*tlv) + sizeof(*bitmap) +\r\nsizeof(*tlv) +\r\nsizeof(*tlv) +\r\nsizeof(*tlv) +\r\nsizeof(*tlv) +\r\nsizeof(*tlv) + sizeof(u32);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_ADD_PATTERN_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->pattern_id = __cpu_to_le32(pattern_id);\r\ncmd->pattern_type = __cpu_to_le32(WOW_BITMAP_PATTERN);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(sizeof(*tlv) + sizeof(*bitmap));\r\nptr += sizeof(*tlv);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_BITMAP_PATTERN_T);\r\ntlv->len = __cpu_to_le16(sizeof(*bitmap));\r\nbitmap = (void *)tlv->value;\r\nmemcpy(bitmap->patternbuf, pattern, pattern_len);\r\nmemcpy(bitmap->bitmaskbuf, bitmask, pattern_len);\r\nbitmap->pattern_offset = __cpu_to_le32(pattern_offset);\r\nbitmap->pattern_len = __cpu_to_le32(pattern_len);\r\nbitmap->bitmask_len = __cpu_to_le32(pattern_len);\r\nbitmap->pattern_id = __cpu_to_le32(pattern_id);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*bitmap);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(0);\r\nptr += sizeof(*tlv);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(0);\r\nptr += sizeof(*tlv);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_STRUCT);\r\ntlv->len = __cpu_to_le16(0);\r\nptr += sizeof(*tlv);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\r\ntlv->len = __cpu_to_le16(0);\r\nptr += sizeof(*tlv);\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_ARRAY_UINT32);\r\ntlv->len = __cpu_to_le16(sizeof(u32));\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv wow add pattern vdev_id %d pattern_id %d, pattern_offset %d\n",\r\nvdev_id, pattern_id, pattern_offset);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_wow_del_pattern(struct ath10k *ar, u32 vdev_id,\r\nu32 pattern_id)\r\n{\r\nstruct wmi_tlv_wow_del_pattern_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\ntlv = (struct wmi_tlv *)skb->data;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_WOW_DEL_PATTERN_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->pattern_id = __cpu_to_le32(pattern_id);\r\ncmd->pattern_type = __cpu_to_le32(WOW_BITMAP_PATTERN);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv wow del pattern vdev_id %d pattern_id %d\n",\r\nvdev_id, pattern_id);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_adaptive_qcs(struct ath10k *ar, bool enable)\r\n{\r\nstruct wmi_tlv_adaptive_qcs *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_RESMGR_ADAPTIVE_OCS_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->enable = __cpu_to_le32(enable ? 1 : 0);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv adaptive qcs %d\n", enable);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_echo(struct ath10k *ar, u32 value)\r\n{\r\nstruct wmi_echo_cmd *cmd;\r\nstruct wmi_tlv *tlv;\r\nstruct sk_buff *skb;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_ECHO_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->value = cpu_to_le32(value);\r\nptr += sizeof(*tlv);\r\nptr += sizeof(*cmd);\r\nath10k_dbg(ar, ATH10K_DBG_WMI, "wmi tlv echo value 0x%08x\n", value);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_spectral_conf(struct ath10k *ar,\r\nconst struct wmi_vdev_spectral_conf_arg *arg)\r\n{\r\nstruct wmi_vdev_spectral_conf_cmd *cmd;\r\nstruct sk_buff *skb;\r\nstruct wmi_tlv *tlv;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SPECTRAL_CONFIGURE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(arg->vdev_id);\r\ncmd->scan_count = __cpu_to_le32(arg->scan_count);\r\ncmd->scan_period = __cpu_to_le32(arg->scan_period);\r\ncmd->scan_priority = __cpu_to_le32(arg->scan_priority);\r\ncmd->scan_fft_size = __cpu_to_le32(arg->scan_fft_size);\r\ncmd->scan_gc_ena = __cpu_to_le32(arg->scan_gc_ena);\r\ncmd->scan_restart_ena = __cpu_to_le32(arg->scan_restart_ena);\r\ncmd->scan_noise_floor_ref = __cpu_to_le32(arg->scan_noise_floor_ref);\r\ncmd->scan_init_delay = __cpu_to_le32(arg->scan_init_delay);\r\ncmd->scan_nb_tone_thr = __cpu_to_le32(arg->scan_nb_tone_thr);\r\ncmd->scan_str_bin_thr = __cpu_to_le32(arg->scan_str_bin_thr);\r\ncmd->scan_wb_rpt_mode = __cpu_to_le32(arg->scan_wb_rpt_mode);\r\ncmd->scan_rssi_rpt_mode = __cpu_to_le32(arg->scan_rssi_rpt_mode);\r\ncmd->scan_rssi_thr = __cpu_to_le32(arg->scan_rssi_thr);\r\ncmd->scan_pwr_format = __cpu_to_le32(arg->scan_pwr_format);\r\ncmd->scan_rpt_mode = __cpu_to_le32(arg->scan_rpt_mode);\r\ncmd->scan_bin_scale = __cpu_to_le32(arg->scan_bin_scale);\r\ncmd->scan_dbm_adj = __cpu_to_le32(arg->scan_dbm_adj);\r\ncmd->scan_chn_mask = __cpu_to_le32(arg->scan_chn_mask);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *\r\nath10k_wmi_tlv_op_gen_vdev_spectral_enable(struct ath10k *ar, u32 vdev_id,\r\nu32 trigger, u32 enable)\r\n{\r\nstruct wmi_vdev_spectral_enable_cmd *cmd;\r\nstruct sk_buff *skb;\r\nstruct wmi_tlv *tlv;\r\nvoid *ptr;\r\nsize_t len;\r\nlen = sizeof(*tlv) + sizeof(*cmd);\r\nskb = ath10k_wmi_alloc_skb(ar, len);\r\nif (!skb)\r\nreturn ERR_PTR(-ENOMEM);\r\nptr = (void *)skb->data;\r\ntlv = ptr;\r\ntlv->tag = __cpu_to_le16(WMI_TLV_TAG_STRUCT_VDEV_SPECTRAL_ENABLE_CMD);\r\ntlv->len = __cpu_to_le16(sizeof(*cmd));\r\ncmd = (void *)tlv->value;\r\ncmd->vdev_id = __cpu_to_le32(vdev_id);\r\ncmd->trigger_cmd = __cpu_to_le32(trigger);\r\ncmd->enable_cmd = __cpu_to_le32(enable);\r\nreturn skb;\r\n}\r\nvoid ath10k_wmi_tlv_attach(struct ath10k *ar)\r\n{\r\nar->wmi.cmd = &wmi_tlv_cmd_map;\r\nar->wmi.vdev_param = &wmi_tlv_vdev_param_map;\r\nar->wmi.pdev_param = &wmi_tlv_pdev_param_map;\r\nar->wmi.ops = &wmi_tlv_ops;\r\nar->wmi.peer_flags = &wmi_tlv_peer_flags_map;\r\n}
