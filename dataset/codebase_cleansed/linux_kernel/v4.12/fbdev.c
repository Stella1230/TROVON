static int riva_bl_get_level_brightness(struct riva_par *par,\r\nint level)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\nint nlevel;\r\nnlevel = MIN_LEVEL + info->bl_curve[level] * LEVEL_STEP;\r\nif (nlevel < 0)\r\nnlevel = 0;\r\nelse if (nlevel < MIN_LEVEL)\r\nnlevel = MIN_LEVEL;\r\nelse if (nlevel > MAX_LEVEL)\r\nnlevel = MAX_LEVEL;\r\nreturn nlevel;\r\n}\r\nstatic int riva_bl_update_status(struct backlight_device *bd)\r\n{\r\nstruct riva_par *par = bl_get_data(bd);\r\nU032 tmp_pcrt, tmp_pmc;\r\nint level;\r\nif (bd->props.power != FB_BLANK_UNBLANK ||\r\nbd->props.fb_blank != FB_BLANK_UNBLANK)\r\nlevel = 0;\r\nelse\r\nlevel = bd->props.brightness;\r\ntmp_pmc = NV_RD32(par->riva.PMC, 0x10F0) & 0x0000FFFF;\r\ntmp_pcrt = NV_RD32(par->riva.PCRTC0, 0x081C) & 0xFFFFFFFC;\r\nif(level > 0) {\r\ntmp_pcrt |= 0x1;\r\ntmp_pmc |= (1 << 31);\r\ntmp_pmc |= riva_bl_get_level_brightness(par, level) << 16;\r\n}\r\nNV_WR32(par->riva.PCRTC0, 0x081C, tmp_pcrt);\r\nNV_WR32(par->riva.PMC, 0x10F0, tmp_pmc);\r\nreturn 0;\r\n}\r\nstatic void riva_bl_init(struct riva_par *par)\r\n{\r\nstruct backlight_properties props;\r\nstruct fb_info *info = pci_get_drvdata(par->pdev);\r\nstruct backlight_device *bd;\r\nchar name[12];\r\nif (!par->FlatPanel)\r\nreturn;\r\n#ifdef CONFIG_PMAC_BACKLIGHT\r\nif (!machine_is(powermac) ||\r\n!pmac_has_backlight_type("mnca"))\r\nreturn;\r\n#endif\r\nsnprintf(name, sizeof(name), "rivabl%d", info->node);\r\nmemset(&props, 0, sizeof(struct backlight_properties));\r\nprops.type = BACKLIGHT_RAW;\r\nprops.max_brightness = FB_BACKLIGHT_LEVELS - 1;\r\nbd = backlight_device_register(name, info->dev, par, &riva_bl_ops,\r\n&props);\r\nif (IS_ERR(bd)) {\r\ninfo->bl_dev = NULL;\r\nprintk(KERN_WARNING "riva: Backlight registration failed\n");\r\ngoto error;\r\n}\r\ninfo->bl_dev = bd;\r\nfb_bl_default_curve(info, 0,\r\nMIN_LEVEL * FB_BACKLIGHT_MAX / MAX_LEVEL,\r\nFB_BACKLIGHT_MAX);\r\nbd->props.brightness = bd->props.max_brightness;\r\nbd->props.power = FB_BLANK_UNBLANK;\r\nbacklight_update_status(bd);\r\nprintk("riva: Backlight initialized (%s)\n", name);\r\nreturn;\r\nerror:\r\nreturn;\r\n}\r\nstatic void riva_bl_exit(struct fb_info *info)\r\n{\r\nstruct backlight_device *bd = info->bl_dev;\r\nbacklight_device_unregister(bd);\r\nprintk("riva: Backlight unloaded\n");\r\n}\r\nstatic inline void riva_bl_init(struct riva_par *par) {}\r\nstatic inline void riva_bl_exit(struct fb_info *info) {}\r\nstatic inline void CRTCout(struct riva_par *par, unsigned char index,\r\nunsigned char val)\r\n{\r\nVGA_WR08(par->riva.PCIO, 0x3d4, index);\r\nVGA_WR08(par->riva.PCIO, 0x3d5, val);\r\n}\r\nstatic inline unsigned char CRTCin(struct riva_par *par,\r\nunsigned char index)\r\n{\r\nVGA_WR08(par->riva.PCIO, 0x3d4, index);\r\nreturn (VGA_RD08(par->riva.PCIO, 0x3d5));\r\n}\r\nstatic inline void GRAout(struct riva_par *par, unsigned char index,\r\nunsigned char val)\r\n{\r\nVGA_WR08(par->riva.PVIO, 0x3ce, index);\r\nVGA_WR08(par->riva.PVIO, 0x3cf, val);\r\n}\r\nstatic inline unsigned char GRAin(struct riva_par *par,\r\nunsigned char index)\r\n{\r\nVGA_WR08(par->riva.PVIO, 0x3ce, index);\r\nreturn (VGA_RD08(par->riva.PVIO, 0x3cf));\r\n}\r\nstatic inline void SEQout(struct riva_par *par, unsigned char index,\r\nunsigned char val)\r\n{\r\nVGA_WR08(par->riva.PVIO, 0x3c4, index);\r\nVGA_WR08(par->riva.PVIO, 0x3c5, val);\r\n}\r\nstatic inline unsigned char SEQin(struct riva_par *par,\r\nunsigned char index)\r\n{\r\nVGA_WR08(par->riva.PVIO, 0x3c4, index);\r\nreturn (VGA_RD08(par->riva.PVIO, 0x3c5));\r\n}\r\nstatic inline void ATTRout(struct riva_par *par, unsigned char index,\r\nunsigned char val)\r\n{\r\nVGA_WR08(par->riva.PCIO, 0x3c0, index);\r\nVGA_WR08(par->riva.PCIO, 0x3c0, val);\r\n}\r\nstatic inline unsigned char ATTRin(struct riva_par *par,\r\nunsigned char index)\r\n{\r\nVGA_WR08(par->riva.PCIO, 0x3c0, index);\r\nreturn (VGA_RD08(par->riva.PCIO, 0x3c1));\r\n}\r\nstatic inline void MISCout(struct riva_par *par, unsigned char val)\r\n{\r\nVGA_WR08(par->riva.PVIO, 0x3c2, val);\r\n}\r\nstatic inline unsigned char MISCin(struct riva_par *par)\r\n{\r\nreturn (VGA_RD08(par->riva.PVIO, 0x3cc));\r\n}\r\nstatic inline void reverse_order(u32 *l)\r\n{\r\nu8 *a = (u8 *)l;\r\na[0] = bitrev8(a[0]);\r\na[1] = bitrev8(a[1]);\r\na[2] = bitrev8(a[2]);\r\na[3] = bitrev8(a[3]);\r\n}\r\nstatic void rivafb_load_cursor_image(struct riva_par *par, u8 *data8,\r\nu16 bg, u16 fg, u32 w, u32 h)\r\n{\r\nint i, j, k = 0;\r\nu32 b, tmp;\r\nu32 *data = (u32 *)data8;\r\nbg = le16_to_cpu(bg);\r\nfg = le16_to_cpu(fg);\r\nw = (w + 1) & ~1;\r\nfor (i = 0; i < h; i++) {\r\nb = *data++;\r\nreverse_order(&b);\r\nfor (j = 0; j < w/2; j++) {\r\ntmp = 0;\r\n#if defined (__BIG_ENDIAN)\r\ntmp = (b & (1 << 31)) ? fg << 16 : bg << 16;\r\nb <<= 1;\r\ntmp |= (b & (1 << 31)) ? fg : bg;\r\nb <<= 1;\r\n#else\r\ntmp = (b & 1) ? fg : bg;\r\nb >>= 1;\r\ntmp |= (b & 1) ? fg << 16 : bg << 16;\r\nb >>= 1;\r\n#endif\r\nwritel(tmp, &par->riva.CURSOR[k++]);\r\n}\r\nk += (MAX_CURS - w)/2;\r\n}\r\n}\r\nstatic void riva_wclut(RIVA_HW_INST *chip,\r\nunsigned char regnum, unsigned char red,\r\nunsigned char green, unsigned char blue)\r\n{\r\nVGA_WR08(chip->PDIO, 0x3c8, regnum);\r\nVGA_WR08(chip->PDIO, 0x3c9, red);\r\nVGA_WR08(chip->PDIO, 0x3c9, green);\r\nVGA_WR08(chip->PDIO, 0x3c9, blue);\r\n}\r\nstatic void riva_rclut(RIVA_HW_INST *chip,\r\nunsigned char regnum, unsigned char *red,\r\nunsigned char *green, unsigned char *blue)\r\n{\r\nVGA_WR08(chip->PDIO, 0x3c7, regnum);\r\n*red = VGA_RD08(chip->PDIO, 0x3c9);\r\n*green = VGA_RD08(chip->PDIO, 0x3c9);\r\n*blue = VGA_RD08(chip->PDIO, 0x3c9);\r\n}\r\nstatic void riva_save_state(struct riva_par *par, struct riva_regs *regs)\r\n{\r\nint i;\r\nNVTRACE_ENTER();\r\npar->riva.LockUnlock(&par->riva, 0);\r\npar->riva.UnloadStateExt(&par->riva, &regs->ext);\r\nregs->misc_output = MISCin(par);\r\nfor (i = 0; i < NUM_CRT_REGS; i++)\r\nregs->crtc[i] = CRTCin(par, i);\r\nfor (i = 0; i < NUM_ATC_REGS; i++)\r\nregs->attr[i] = ATTRin(par, i);\r\nfor (i = 0; i < NUM_GRC_REGS; i++)\r\nregs->gra[i] = GRAin(par, i);\r\nfor (i = 0; i < NUM_SEQ_REGS; i++)\r\nregs->seq[i] = SEQin(par, i);\r\nNVTRACE_LEAVE();\r\n}\r\nstatic void riva_load_state(struct riva_par *par, struct riva_regs *regs)\r\n{\r\nRIVA_HW_STATE *state = &regs->ext;\r\nint i;\r\nNVTRACE_ENTER();\r\nCRTCout(par, 0x11, 0x00);\r\npar->riva.LockUnlock(&par->riva, 0);\r\npar->riva.LoadStateExt(&par->riva, state);\r\nMISCout(par, regs->misc_output);\r\nfor (i = 0; i < NUM_CRT_REGS; i++) {\r\nswitch (i) {\r\ncase 0x19:\r\ncase 0x20 ... 0x40:\r\nbreak;\r\ndefault:\r\nCRTCout(par, i, regs->crtc[i]);\r\n}\r\n}\r\nfor (i = 0; i < NUM_ATC_REGS; i++)\r\nATTRout(par, i, regs->attr[i]);\r\nfor (i = 0; i < NUM_GRC_REGS; i++)\r\nGRAout(par, i, regs->gra[i]);\r\nfor (i = 0; i < NUM_SEQ_REGS; i++)\r\nSEQout(par, i, regs->seq[i]);\r\nNVTRACE_LEAVE();\r\n}\r\nstatic int riva_load_video_mode(struct fb_info *info)\r\n{\r\nint bpp, width, hDisplaySize, hDisplay, hStart,\r\nhEnd, hTotal, height, vDisplay, vStart, vEnd, vTotal, dotClock;\r\nint hBlankStart, hBlankEnd, vBlankStart, vBlankEnd;\r\nint rc;\r\nstruct riva_par *par = info->par;\r\nstruct riva_regs newmode;\r\nNVTRACE_ENTER();\r\nrivafb_blank(FB_BLANK_NORMAL, info);\r\nbpp = info->var.bits_per_pixel;\r\nif (bpp == 16 && info->var.green.length == 5)\r\nbpp = 15;\r\nwidth = info->var.xres_virtual;\r\nhDisplaySize = info->var.xres;\r\nhDisplay = (hDisplaySize / 8) - 1;\r\nhStart = (hDisplaySize + info->var.right_margin) / 8 - 1;\r\nhEnd = (hDisplaySize + info->var.right_margin +\r\ninfo->var.hsync_len) / 8 - 1;\r\nhTotal = (hDisplaySize + info->var.right_margin +\r\ninfo->var.hsync_len + info->var.left_margin) / 8 - 5;\r\nhBlankStart = hDisplay;\r\nhBlankEnd = hTotal + 4;\r\nheight = info->var.yres_virtual;\r\nvDisplay = info->var.yres - 1;\r\nvStart = info->var.yres + info->var.lower_margin - 1;\r\nvEnd = info->var.yres + info->var.lower_margin +\r\ninfo->var.vsync_len - 1;\r\nvTotal = info->var.yres + info->var.lower_margin +\r\ninfo->var.vsync_len + info->var.upper_margin + 2;\r\nvBlankStart = vDisplay;\r\nvBlankEnd = vTotal + 1;\r\ndotClock = 1000000000 / info->var.pixclock;\r\nmemcpy(&newmode, &reg_template, sizeof(struct riva_regs));\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED)\r\nvTotal |= 1;\r\nif (par->FlatPanel) {\r\nvStart = vTotal - 3;\r\nvEnd = vTotal - 2;\r\nvBlankStart = vStart;\r\nhStart = hTotal - 3;\r\nhEnd = hTotal - 2;\r\nhBlankEnd = hTotal + 4;\r\n}\r\nnewmode.crtc[0x0] = Set8Bits (hTotal);\r\nnewmode.crtc[0x1] = Set8Bits (hDisplay);\r\nnewmode.crtc[0x2] = Set8Bits (hBlankStart);\r\nnewmode.crtc[0x3] = SetBitField (hBlankEnd, 4: 0, 4:0) | SetBit (7);\r\nnewmode.crtc[0x4] = Set8Bits (hStart);\r\nnewmode.crtc[0x5] = SetBitField (hBlankEnd, 5: 5, 7:7)\r\n| SetBitField (hEnd, 4: 0, 4:0);\r\nnewmode.crtc[0x6] = SetBitField (vTotal, 7: 0, 7:0);\r\nnewmode.crtc[0x7] = SetBitField (vTotal, 8: 8, 0:0)\r\n| SetBitField (vDisplay, 8: 8, 1:1)\r\n| SetBitField (vStart, 8: 8, 2:2)\r\n| SetBitField (vBlankStart, 8: 8, 3:3)\r\n| SetBit (4)\r\n| SetBitField (vTotal, 9: 9, 5:5)\r\n| SetBitField (vDisplay, 9: 9, 6:6)\r\n| SetBitField (vStart, 9: 9, 7:7);\r\nnewmode.crtc[0x9] = SetBitField (vBlankStart, 9: 9, 5:5)\r\n| SetBit (6);\r\nnewmode.crtc[0x10] = Set8Bits (vStart);\r\nnewmode.crtc[0x11] = SetBitField (vEnd, 3: 0, 3:0)\r\n| SetBit (5);\r\nnewmode.crtc[0x12] = Set8Bits (vDisplay);\r\nnewmode.crtc[0x13] = (width / 8) * ((bpp + 1) / 8);\r\nnewmode.crtc[0x15] = Set8Bits (vBlankStart);\r\nnewmode.crtc[0x16] = Set8Bits (vBlankEnd);\r\nnewmode.ext.screen = SetBitField(hBlankEnd,6:6,4:4)\r\n| SetBitField(vBlankStart,10:10,3:3)\r\n| SetBitField(vStart,10:10,2:2)\r\n| SetBitField(vDisplay,10:10,1:1)\r\n| SetBitField(vTotal,10:10,0:0);\r\nnewmode.ext.horiz = SetBitField(hTotal,8:8,0:0)\r\n| SetBitField(hDisplay,8:8,1:1)\r\n| SetBitField(hBlankStart,8:8,2:2)\r\n| SetBitField(hStart,8:8,3:3);\r\nnewmode.ext.extra = SetBitField(vTotal,11:11,0:0)\r\n| SetBitField(vDisplay,11:11,2:2)\r\n| SetBitField(vStart,11:11,4:4)\r\n| SetBitField(vBlankStart,11:11,6:6);\r\nif ((info->var.vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {\r\nint tmp = (hTotal >> 1) & ~1;\r\nnewmode.ext.interlace = Set8Bits(tmp);\r\nnewmode.ext.horiz |= SetBitField(tmp, 8:8,4:4);\r\n} else\r\nnewmode.ext.interlace = 0xff;\r\nif (par->riva.Architecture >= NV_ARCH_10)\r\npar->riva.CURSOR = (U032 __iomem *)(info->screen_base + par->riva.CursorStart);\r\nif (info->var.sync & FB_SYNC_HOR_HIGH_ACT)\r\nnewmode.misc_output &= ~0x40;\r\nelse\r\nnewmode.misc_output |= 0x40;\r\nif (info->var.sync & FB_SYNC_VERT_HIGH_ACT)\r\nnewmode.misc_output &= ~0x80;\r\nelse\r\nnewmode.misc_output |= 0x80;\r\nrc = CalcStateExt(&par->riva, &newmode.ext, bpp, width,\r\nhDisplaySize, height, dotClock);\r\nif (rc)\r\ngoto out;\r\nnewmode.ext.scale = NV_RD32(par->riva.PRAMDAC, 0x00000848) &\r\n0xfff000ff;\r\nif (par->FlatPanel == 1) {\r\nnewmode.ext.pixel |= (1 << 7);\r\nnewmode.ext.scale |= (1 << 8);\r\n}\r\nif (par->SecondCRTC) {\r\nnewmode.ext.head = NV_RD32(par->riva.PCRTC0, 0x00000860) &\r\n~0x00001000;\r\nnewmode.ext.head2 = NV_RD32(par->riva.PCRTC0, 0x00002860) |\r\n0x00001000;\r\nnewmode.ext.crtcOwner = 3;\r\nnewmode.ext.pllsel |= 0x20000800;\r\nnewmode.ext.vpll2 = newmode.ext.vpll;\r\n} else if (par->riva.twoHeads) {\r\nnewmode.ext.head = NV_RD32(par->riva.PCRTC0, 0x00000860) |\r\n0x00001000;\r\nnewmode.ext.head2 = NV_RD32(par->riva.PCRTC0, 0x00002860) &\r\n~0x00001000;\r\nnewmode.ext.crtcOwner = 0;\r\nnewmode.ext.vpll2 = NV_RD32(par->riva.PRAMDAC0, 0x00000520);\r\n}\r\nif (par->FlatPanel == 1) {\r\nnewmode.ext.pixel |= (1 << 7);\r\nnewmode.ext.scale |= (1 << 8);\r\n}\r\nnewmode.ext.cursorConfig = 0x02000100;\r\npar->current_state = newmode;\r\nriva_load_state(par, &par->current_state);\r\npar->riva.LockUnlock(&par->riva, 0);\r\nout:\r\nrivafb_blank(FB_BLANK_UNBLANK, info);\r\nNVTRACE_LEAVE();\r\nreturn rc;\r\n}\r\nstatic void riva_update_var(struct fb_var_screeninfo *var,\r\nconst struct fb_videomode *modedb)\r\n{\r\nNVTRACE_ENTER();\r\nvar->xres = var->xres_virtual = modedb->xres;\r\nvar->yres = modedb->yres;\r\nif (var->yres_virtual < var->yres)\r\nvar->yres_virtual = var->yres;\r\nvar->xoffset = var->yoffset = 0;\r\nvar->pixclock = modedb->pixclock;\r\nvar->left_margin = modedb->left_margin;\r\nvar->right_margin = modedb->right_margin;\r\nvar->upper_margin = modedb->upper_margin;\r\nvar->lower_margin = modedb->lower_margin;\r\nvar->hsync_len = modedb->hsync_len;\r\nvar->vsync_len = modedb->vsync_len;\r\nvar->sync = modedb->sync;\r\nvar->vmode = modedb->vmode;\r\nNVTRACE_LEAVE();\r\n}\r\nstatic int rivafb_do_maximize(struct fb_info *info,\r\nstruct fb_var_screeninfo *var,\r\nint nom, int den)\r\n{\r\nstatic struct {\r\nint xres, yres;\r\n} modes[] = {\r\n{1600, 1280},\r\n{1280, 1024},\r\n{1024, 768},\r\n{800, 600},\r\n{640, 480},\r\n{-1, -1}\r\n};\r\nint i;\r\nNVTRACE_ENTER();\r\nif (var->xres_virtual == -1 && var->yres_virtual == -1) {\r\nprintk(KERN_WARNING PFX\r\n"using maximum available virtual resolution\n");\r\nfor (i = 0; modes[i].xres != -1; i++) {\r\nif (modes[i].xres * nom / den * modes[i].yres <\r\ninfo->fix.smem_len)\r\nbreak;\r\n}\r\nif (modes[i].xres == -1) {\r\nprintk(KERN_ERR PFX\r\n"could not find a virtual resolution that fits into video memory!!\n");\r\nNVTRACE("EXIT - EINVAL error\n");\r\nreturn -EINVAL;\r\n}\r\nvar->xres_virtual = modes[i].xres;\r\nvar->yres_virtual = modes[i].yres;\r\nprintk(KERN_INFO PFX\r\n"virtual resolution set to maximum of %dx%d\n",\r\nvar->xres_virtual, var->yres_virtual);\r\n} else if (var->xres_virtual == -1) {\r\nvar->xres_virtual = (info->fix.smem_len * den /\r\n(nom * var->yres_virtual)) & ~15;\r\nprintk(KERN_WARNING PFX\r\n"setting virtual X resolution to %d\n", var->xres_virtual);\r\n} else if (var->yres_virtual == -1) {\r\nvar->xres_virtual = (var->xres_virtual + 15) & ~15;\r\nvar->yres_virtual = info->fix.smem_len * den /\r\n(nom * var->xres_virtual);\r\nprintk(KERN_WARNING PFX\r\n"setting virtual Y resolution to %d\n", var->yres_virtual);\r\n} else {\r\nvar->xres_virtual = (var->xres_virtual + 15) & ~15;\r\nif (var->xres_virtual * nom / den * var->yres_virtual > info->fix.smem_len) {\r\nprintk(KERN_ERR PFX\r\n"mode %dx%dx%d rejected...resolution too high to fit into video memory!\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nNVTRACE("EXIT - EINVAL error\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (var->xres_virtual * nom / den >= 8192) {\r\nprintk(KERN_WARNING PFX\r\n"virtual X resolution (%d) is too high, lowering to %d\n",\r\nvar->xres_virtual, 8192 * den / nom - 16);\r\nvar->xres_virtual = 8192 * den / nom - 16;\r\n}\r\nif (var->xres_virtual < var->xres) {\r\nprintk(KERN_ERR PFX\r\n"virtual X resolution (%d) is smaller than real\n", var->xres_virtual);\r\nreturn -EINVAL;\r\n}\r\nif (var->yres_virtual < var->yres) {\r\nprintk(KERN_ERR PFX\r\n"virtual Y resolution (%d) is smaller than real\n", var->yres_virtual);\r\nreturn -EINVAL;\r\n}\r\nif (var->yres_virtual > 0x7fff/nom)\r\nvar->yres_virtual = 0x7fff/nom;\r\nif (var->xres_virtual > 0x7fff/nom)\r\nvar->xres_virtual = 0x7fff/nom;\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic void\r\nriva_set_pattern(struct riva_par *par, int clr0, int clr1, int pat0, int pat1)\r\n{\r\nRIVA_FIFO_FREE(par->riva, Patt, 4);\r\nNV_WR32(&par->riva.Patt->Color0, 0, clr0);\r\nNV_WR32(&par->riva.Patt->Color1, 0, clr1);\r\nNV_WR32(par->riva.Patt->Monochrome, 0, pat0);\r\nNV_WR32(par->riva.Patt->Monochrome, 4, pat1);\r\n}\r\nstatic inline void wait_for_idle(struct riva_par *par)\r\n{\r\nwhile (par->riva.Busy(&par->riva));\r\n}\r\nstatic void\r\nriva_set_rop_solid(struct riva_par *par, int rop)\r\n{\r\nriva_set_pattern(par, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF);\r\nRIVA_FIFO_FREE(par->riva, Rop, 1);\r\nNV_WR32(&par->riva.Rop->Rop3, 0, rop);\r\n}\r\nstatic void riva_setup_accel(struct fb_info *info)\r\n{\r\nstruct riva_par *par = info->par;\r\nRIVA_FIFO_FREE(par->riva, Clip, 2);\r\nNV_WR32(&par->riva.Clip->TopLeft, 0, 0x0);\r\nNV_WR32(&par->riva.Clip->WidthHeight, 0,\r\n(info->var.xres_virtual & 0xffff) |\r\n(info->var.yres_virtual << 16));\r\nriva_set_rop_solid(par, 0xcc);\r\nwait_for_idle(par);\r\n}\r\nstatic int riva_get_cmap_len(const struct fb_var_screeninfo *var)\r\n{\r\nint rc = 256;\r\nswitch (var->green.length) {\r\ncase 8:\r\nrc = 256;\r\nbreak;\r\ncase 5:\r\nrc = 32;\r\nbreak;\r\ncase 6:\r\nrc = 64;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int rivafb_open(struct fb_info *info, int user)\r\n{\r\nstruct riva_par *par = info->par;\r\nNVTRACE_ENTER();\r\nmutex_lock(&par->open_lock);\r\nif (!par->ref_count) {\r\n#ifdef CONFIG_X86\r\nmemset(&par->state, 0, sizeof(struct vgastate));\r\npar->state.flags = VGA_SAVE_MODE | VGA_SAVE_FONTS;\r\nif (par->riva.Architecture == NV_ARCH_03)\r\npar->state.flags |= VGA_SAVE_CMAP;\r\nsave_vga(&par->state);\r\n#endif\r\nCRTCout(par, 0x11, 0xFF);\r\npar->riva.LockUnlock(&par->riva, 0);\r\nriva_save_state(par, &par->initial_state);\r\n}\r\npar->ref_count++;\r\nmutex_unlock(&par->open_lock);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int rivafb_release(struct fb_info *info, int user)\r\n{\r\nstruct riva_par *par = info->par;\r\nNVTRACE_ENTER();\r\nmutex_lock(&par->open_lock);\r\nif (!par->ref_count) {\r\nmutex_unlock(&par->open_lock);\r\nreturn -EINVAL;\r\n}\r\nif (par->ref_count == 1) {\r\npar->riva.LockUnlock(&par->riva, 0);\r\npar->riva.LoadStateExt(&par->riva, &par->initial_state.ext);\r\nriva_load_state(par, &par->initial_state);\r\n#ifdef CONFIG_X86\r\nrestore_vga(&par->state);\r\n#endif\r\npar->riva.LockUnlock(&par->riva, 1);\r\n}\r\npar->ref_count--;\r\nmutex_unlock(&par->open_lock);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int rivafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)\r\n{\r\nconst struct fb_videomode *mode;\r\nstruct riva_par *par = info->par;\r\nint nom, den;\r\nint mode_valid = 0;\r\nNVTRACE_ENTER();\r\nswitch (var->bits_per_pixel) {\r\ncase 1 ... 8:\r\nvar->red.offset = var->green.offset = var->blue.offset = 0;\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nvar->bits_per_pixel = 8;\r\nnom = den = 1;\r\nbreak;\r\ncase 9 ... 15:\r\nvar->green.length = 5;\r\ncase 16:\r\nvar->bits_per_pixel = 16;\r\nif (par->riva.Architecture == NV_ARCH_03)\r\nvar->green.length = 5;\r\nif (var->green.length == 5) {\r\nvar->red.offset = 10;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 5;\r\nvar->blue.length = 5;\r\n} else {\r\nvar->red.offset = 11;\r\nvar->green.offset = 5;\r\nvar->blue.offset = 0;\r\nvar->red.length = 5;\r\nvar->green.length = 6;\r\nvar->blue.length = 5;\r\n}\r\nnom = 2;\r\nden = 1;\r\nbreak;\r\ncase 17 ... 32:\r\nvar->red.length = var->green.length = var->blue.length = 8;\r\nvar->bits_per_pixel = 32;\r\nvar->red.offset = 16;\r\nvar->green.offset = 8;\r\nvar->blue.offset = 0;\r\nnom = 4;\r\nden = 1;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR PFX\r\n"mode %dx%dx%d rejected...color depth not supported.\n",\r\nvar->xres, var->yres, var->bits_per_pixel);\r\nNVTRACE("EXIT, returning -EINVAL\n");\r\nreturn -EINVAL;\r\n}\r\nif (!strictmode) {\r\nif (!info->monspecs.vfmax || !info->monspecs.hfmax ||\r\n!info->monspecs.dclkmax || !fb_validate_mode(var, info))\r\nmode_valid = 1;\r\n}\r\nif (!mode_valid && info->monspecs.gtf) {\r\nif (!fb_get_mode(FB_MAXTIMINGS, 0, var, info))\r\nmode_valid = 1;\r\n}\r\nif (!mode_valid) {\r\nmode = fb_find_best_mode(var, &info->modelist);\r\nif (mode) {\r\nriva_update_var(var, mode);\r\nmode_valid = 1;\r\n}\r\n}\r\nif (!mode_valid && info->monspecs.modedb_len)\r\nreturn -EINVAL;\r\nif (var->xres_virtual < var->xres)\r\nvar->xres_virtual = var->xres;\r\nif (var->yres_virtual <= var->yres)\r\nvar->yres_virtual = -1;\r\nif (rivafb_do_maximize(info, var, nom, den) < 0)\r\nreturn -EINVAL;\r\nif (var->xoffset > var->xres_virtual - var->xres)\r\nvar->xoffset = var->xres_virtual - var->xres - 1;\r\nif (var->yoffset > var->yres_virtual - var->yres)\r\nvar->yoffset = var->yres_virtual - var->yres - 1;\r\nvar->red.msb_right =\r\nvar->green.msb_right =\r\nvar->blue.msb_right =\r\nvar->transp.offset = var->transp.length = var->transp.msb_right = 0;\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int rivafb_set_par(struct fb_info *info)\r\n{\r\nstruct riva_par *par = info->par;\r\nint rc = 0;\r\nNVTRACE_ENTER();\r\nCRTCout(par, 0x11, 0xFF);\r\npar->riva.LockUnlock(&par->riva, 0);\r\nrc = riva_load_video_mode(info);\r\nif (rc)\r\ngoto out;\r\nif(!(info->flags & FBINFO_HWACCEL_DISABLED))\r\nriva_setup_accel(info);\r\npar->cursor_reset = 1;\r\ninfo->fix.line_length = (info->var.xres_virtual * (info->var.bits_per_pixel >> 3));\r\ninfo->fix.visual = (info->var.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\nif (info->flags & FBINFO_HWACCEL_DISABLED)\r\ninfo->pixmap.scan_align = 1;\r\nelse\r\ninfo->pixmap.scan_align = 4;\r\nout:\r\nNVTRACE_LEAVE();\r\nreturn rc;\r\n}\r\nstatic int rivafb_pan_display(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct riva_par *par = info->par;\r\nunsigned int base;\r\nNVTRACE_ENTER();\r\nbase = var->yoffset * info->fix.line_length + var->xoffset;\r\npar->riva.SetStartAddress(&par->riva, base);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int rivafb_blank(int blank, struct fb_info *info)\r\n{\r\nstruct riva_par *par= info->par;\r\nunsigned char tmp, vesa;\r\ntmp = SEQin(par, 0x01) & ~0x20;\r\nvesa = CRTCin(par, 0x1a) & ~0xc0;\r\nNVTRACE_ENTER();\r\nif (blank)\r\ntmp |= 0x20;\r\nswitch (blank) {\r\ncase FB_BLANK_UNBLANK:\r\ncase FB_BLANK_NORMAL:\r\nbreak;\r\ncase FB_BLANK_VSYNC_SUSPEND:\r\nvesa |= 0x80;\r\nbreak;\r\ncase FB_BLANK_HSYNC_SUSPEND:\r\nvesa |= 0x40;\r\nbreak;\r\ncase FB_BLANK_POWERDOWN:\r\nvesa |= 0xc0;\r\nbreak;\r\n}\r\nSEQout(par, 0x01, tmp);\r\nCRTCout(par, 0x1a, vesa);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int rivafb_setcolreg(unsigned regno, unsigned red, unsigned green,\r\nunsigned blue, unsigned transp,\r\nstruct fb_info *info)\r\n{\r\nstruct riva_par *par = info->par;\r\nRIVA_HW_INST *chip = &par->riva;\r\nint i;\r\nif (regno >= riva_get_cmap_len(&info->var))\r\nreturn -EINVAL;\r\nif (info->var.grayscale) {\r\nred = green = blue =\r\n(red * 77 + green * 151 + blue * 28) >> 8;\r\n}\r\nif (regno < 16 && info->fix.visual == FB_VISUAL_DIRECTCOLOR) {\r\n((u32 *) info->pseudo_palette)[regno] =\r\n(regno << info->var.red.offset) |\r\n(regno << info->var.green.offset) |\r\n(regno << info->var.blue.offset);\r\nif (par->riva.Architecture == NV_ARCH_03) {\r\nswitch (info->var.bits_per_pixel) {\r\ncase 16:\r\npar->palette[regno] = ((red & 0xf800) >> 1) |\r\n((green & 0xf800) >> 6) |\r\n((blue & 0xf800) >> 11);\r\nbreak;\r\ncase 32:\r\npar->palette[regno] = ((red & 0xff00) << 8) |\r\n((green & 0xff00)) |\r\n((blue & 0xff00) >> 8);\r\nbreak;\r\n}\r\n}\r\n}\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nriva_wclut(chip, regno, red >> 8, green >> 8, blue >> 8);\r\nbreak;\r\ncase 16:\r\nif (info->var.green.length == 5) {\r\nfor (i = 0; i < 8; i++) {\r\nriva_wclut(chip, regno*8+i, red >> 8,\r\ngreen >> 8, blue >> 8);\r\n}\r\n} else {\r\nu8 r, g, b;\r\nif (regno < 32) {\r\nfor (i = 0; i < 8; i++) {\r\nriva_wclut(chip, regno*8+i,\r\nred >> 8, green >> 8,\r\nblue >> 8);\r\n}\r\n}\r\nriva_rclut(chip, regno*4, &r, &g, &b);\r\nfor (i = 0; i < 4; i++)\r\nriva_wclut(chip, regno*4+i, r,\r\ngreen >> 8, b);\r\n}\r\nbreak;\r\ncase 32:\r\nriva_wclut(chip, regno, red >> 8, green >> 8, blue >> 8);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rivafb_fillrect(struct fb_info *info, const struct fb_fillrect *rect)\r\n{\r\nstruct riva_par *par = info->par;\r\nu_int color, rop = 0;\r\nif ((info->flags & FBINFO_HWACCEL_DISABLED)) {\r\ncfb_fillrect(info, rect);\r\nreturn;\r\n}\r\nif (info->var.bits_per_pixel == 8)\r\ncolor = rect->color;\r\nelse {\r\nif (par->riva.Architecture != NV_ARCH_03)\r\ncolor = ((u32 *)info->pseudo_palette)[rect->color];\r\nelse\r\ncolor = par->palette[rect->color];\r\n}\r\nswitch (rect->rop) {\r\ncase ROP_XOR:\r\nrop = 0x66;\r\nbreak;\r\ncase ROP_COPY:\r\ndefault:\r\nrop = 0xCC;\r\nbreak;\r\n}\r\nriva_set_rop_solid(par, rop);\r\nRIVA_FIFO_FREE(par->riva, Bitmap, 1);\r\nNV_WR32(&par->riva.Bitmap->Color1A, 0, color);\r\nRIVA_FIFO_FREE(par->riva, Bitmap, 2);\r\nNV_WR32(&par->riva.Bitmap->UnclippedRectangle[0].TopLeft, 0,\r\n(rect->dx << 16) | rect->dy);\r\nmb();\r\nNV_WR32(&par->riva.Bitmap->UnclippedRectangle[0].WidthHeight, 0,\r\n(rect->width << 16) | rect->height);\r\nmb();\r\nriva_set_rop_solid(par, 0xcc);\r\n}\r\nstatic void rivafb_copyarea(struct fb_info *info, const struct fb_copyarea *region)\r\n{\r\nstruct riva_par *par = info->par;\r\nif ((info->flags & FBINFO_HWACCEL_DISABLED)) {\r\ncfb_copyarea(info, region);\r\nreturn;\r\n}\r\nRIVA_FIFO_FREE(par->riva, Blt, 3);\r\nNV_WR32(&par->riva.Blt->TopLeftSrc, 0,\r\n(region->sy << 16) | region->sx);\r\nNV_WR32(&par->riva.Blt->TopLeftDst, 0,\r\n(region->dy << 16) | region->dx);\r\nmb();\r\nNV_WR32(&par->riva.Blt->WidthHeight, 0,\r\n(region->height << 16) | region->width);\r\nmb();\r\n}\r\nstatic inline void convert_bgcolor_16(u32 *col)\r\n{\r\n*col = ((*col & 0x0000F800) << 8)\r\n| ((*col & 0x00007E0) << 5)\r\n| ((*col & 0x0000001F) << 3)\r\n| 0xFF000000;\r\nmb();\r\n}\r\nstatic void rivafb_imageblit(struct fb_info *info,\r\nconst struct fb_image *image)\r\n{\r\nstruct riva_par *par = info->par;\r\nu32 fgx = 0, bgx = 0, width, tmp;\r\nu8 *cdat = (u8 *) image->data;\r\nvolatile u32 __iomem *d;\r\nint i, size;\r\nif ((info->flags & FBINFO_HWACCEL_DISABLED) || image->depth != 1) {\r\ncfb_imageblit(info, image);\r\nreturn;\r\n}\r\nswitch (info->var.bits_per_pixel) {\r\ncase 8:\r\nfgx = image->fg_color;\r\nbgx = image->bg_color;\r\nbreak;\r\ncase 16:\r\ncase 32:\r\nif (par->riva.Architecture != NV_ARCH_03) {\r\nfgx = ((u32 *)info->pseudo_palette)[image->fg_color];\r\nbgx = ((u32 *)info->pseudo_palette)[image->bg_color];\r\n} else {\r\nfgx = par->palette[image->fg_color];\r\nbgx = par->palette[image->bg_color];\r\n}\r\nif (info->var.green.length == 6)\r\nconvert_bgcolor_16(&bgx);\r\nbreak;\r\n}\r\nRIVA_FIFO_FREE(par->riva, Bitmap, 7);\r\nNV_WR32(&par->riva.Bitmap->ClipE.TopLeft, 0,\r\n(image->dy << 16) | (image->dx & 0xFFFF));\r\nNV_WR32(&par->riva.Bitmap->ClipE.BottomRight, 0,\r\n(((image->dy + image->height) << 16) |\r\n((image->dx + image->width) & 0xffff)));\r\nNV_WR32(&par->riva.Bitmap->Color0E, 0, bgx);\r\nNV_WR32(&par->riva.Bitmap->Color1E, 0, fgx);\r\nNV_WR32(&par->riva.Bitmap->WidthHeightInE, 0,\r\n(image->height << 16) | ((image->width + 31) & ~31));\r\nNV_WR32(&par->riva.Bitmap->WidthHeightOutE, 0,\r\n(image->height << 16) | ((image->width + 31) & ~31));\r\nNV_WR32(&par->riva.Bitmap->PointE, 0,\r\n(image->dy << 16) | (image->dx & 0xFFFF));\r\nd = &par->riva.Bitmap->MonochromeData01E;\r\nwidth = (image->width + 31)/32;\r\nsize = width * image->height;\r\nwhile (size >= 16) {\r\nRIVA_FIFO_FREE(par->riva, Bitmap, 16);\r\nfor (i = 0; i < 16; i++) {\r\ntmp = *((u32 *)cdat);\r\ncdat = (u8 *)((u32 *)cdat + 1);\r\nreverse_order(&tmp);\r\nNV_WR32(d, i*4, tmp);\r\n}\r\nsize -= 16;\r\n}\r\nif (size) {\r\nRIVA_FIFO_FREE(par->riva, Bitmap, size);\r\nfor (i = 0; i < size; i++) {\r\ntmp = *((u32 *) cdat);\r\ncdat = (u8 *)((u32 *)cdat + 1);\r\nreverse_order(&tmp);\r\nNV_WR32(d, i*4, tmp);\r\n}\r\n}\r\n}\r\nstatic int rivafb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nstruct riva_par *par = info->par;\r\nu8 data[MAX_CURS * MAX_CURS/8];\r\nint i, set = cursor->set;\r\nu16 fg, bg;\r\nif (cursor->image.width > MAX_CURS || cursor->image.height > MAX_CURS)\r\nreturn -ENXIO;\r\npar->riva.ShowHideCursor(&par->riva, 0);\r\nif (par->cursor_reset) {\r\nset = FB_CUR_SETALL;\r\npar->cursor_reset = 0;\r\n}\r\nif (set & FB_CUR_SETSIZE)\r\nmemset_io(par->riva.CURSOR, 0, MAX_CURS * MAX_CURS * 2);\r\nif (set & FB_CUR_SETPOS) {\r\nu32 xx, yy, temp;\r\nyy = cursor->image.dy - info->var.yoffset;\r\nxx = cursor->image.dx - info->var.xoffset;\r\ntemp = xx & 0xFFFF;\r\ntemp |= yy << 16;\r\nNV_WR32(par->riva.PRAMDAC, 0x0000300, temp);\r\n}\r\nif (set & (FB_CUR_SETSHAPE | FB_CUR_SETCMAP | FB_CUR_SETIMAGE)) {\r\nu32 bg_idx = cursor->image.bg_color;\r\nu32 fg_idx = cursor->image.fg_color;\r\nu32 s_pitch = (cursor->image.width+7) >> 3;\r\nu32 d_pitch = MAX_CURS/8;\r\nu8 *dat = (u8 *) cursor->image.data;\r\nu8 *msk = (u8 *) cursor->mask;\r\nu8 *src;\r\nsrc = kmalloc(s_pitch * cursor->image.height, GFP_ATOMIC);\r\nif (src) {\r\nswitch (cursor->rop) {\r\ncase ROP_XOR:\r\nfor (i = 0; i < s_pitch * cursor->image.height; i++)\r\nsrc[i] = dat[i] ^ msk[i];\r\nbreak;\r\ncase ROP_COPY:\r\ndefault:\r\nfor (i = 0; i < s_pitch * cursor->image.height; i++)\r\nsrc[i] = dat[i] & msk[i];\r\nbreak;\r\n}\r\nfb_pad_aligned_buffer(data, d_pitch, src, s_pitch,\r\ncursor->image.height);\r\nbg = ((info->cmap.red[bg_idx] & 0xf8) << 7) |\r\n((info->cmap.green[bg_idx] & 0xf8) << 2) |\r\n((info->cmap.blue[bg_idx] & 0xf8) >> 3) |\r\n1 << 15;\r\nfg = ((info->cmap.red[fg_idx] & 0xf8) << 7) |\r\n((info->cmap.green[fg_idx] & 0xf8) << 2) |\r\n((info->cmap.blue[fg_idx] & 0xf8) >> 3) |\r\n1 << 15;\r\npar->riva.LockUnlock(&par->riva, 0);\r\nrivafb_load_cursor_image(par, data, bg, fg,\r\ncursor->image.width,\r\ncursor->image.height);\r\nkfree(src);\r\n}\r\n}\r\nif (cursor->enable)\r\npar->riva.ShowHideCursor(&par->riva, 1);\r\nreturn 0;\r\n}\r\nstatic int rivafb_sync(struct fb_info *info)\r\n{\r\nstruct riva_par *par = info->par;\r\nwait_for_idle(par);\r\nreturn 0;\r\n}\r\nstatic int riva_set_fbinfo(struct fb_info *info)\r\n{\r\nunsigned int cmap_len;\r\nstruct riva_par *par = info->par;\r\nNVTRACE_ENTER();\r\ninfo->flags = FBINFO_DEFAULT\r\n| FBINFO_HWACCEL_XPAN\r\n| FBINFO_HWACCEL_YPAN\r\n| FBINFO_HWACCEL_COPYAREA\r\n| FBINFO_HWACCEL_FILLRECT\r\n| FBINFO_HWACCEL_IMAGEBLIT;\r\nif ((par->riva.Architecture == NV_ARCH_30) || noaccel) {\r\nprintk(KERN_DEBUG PFX "disabling acceleration\n");\r\ninfo->flags |= FBINFO_HWACCEL_DISABLED;\r\n}\r\ninfo->var = rivafb_default_var;\r\ninfo->fix.visual = (info->var.bits_per_pixel == 8) ?\r\nFB_VISUAL_PSEUDOCOLOR : FB_VISUAL_DIRECTCOLOR;\r\ninfo->pseudo_palette = par->pseudo_palette;\r\ncmap_len = riva_get_cmap_len(&info->var);\r\nfb_alloc_cmap(&info->cmap, cmap_len, 0);\r\ninfo->pixmap.size = 8 * 1024;\r\ninfo->pixmap.buf_align = 4;\r\ninfo->pixmap.access_align = 32;\r\ninfo->pixmap.flags = FB_PIXMAP_SYSTEM;\r\ninfo->var.yres_virtual = -1;\r\nNVTRACE_LEAVE();\r\nreturn (rivafb_check_var(&info->var, info));\r\n}\r\nstatic int riva_get_EDID_OF(struct fb_info *info, struct pci_dev *pd)\r\n{\r\nstruct riva_par *par = info->par;\r\nstruct device_node *dp;\r\nconst unsigned char *pedid = NULL;\r\nconst unsigned char *disptype = NULL;\r\nstatic char *propnames[] = {\r\n"DFP,EDID", "LCD,EDID", "EDID", "EDID1", "EDID,B", "EDID,A", NULL };\r\nint i;\r\nNVTRACE_ENTER();\r\ndp = pci_device_to_OF_node(pd);\r\nfor (; dp != NULL; dp = dp->child) {\r\ndisptype = of_get_property(dp, "display-type", NULL);\r\nif (disptype == NULL)\r\ncontinue;\r\nif (strncmp(disptype, "LCD", 3) != 0)\r\ncontinue;\r\nfor (i = 0; propnames[i] != NULL; ++i) {\r\npedid = of_get_property(dp, propnames[i], NULL);\r\nif (pedid != NULL) {\r\npar->EDID = (unsigned char *)pedid;\r\nNVTRACE("LCD found.\n");\r\nreturn 1;\r\n}\r\n}\r\n}\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int riva_get_EDID_i2c(struct fb_info *info)\r\n{\r\nstruct riva_par *par = info->par;\r\nstruct fb_var_screeninfo var;\r\nint i;\r\nNVTRACE_ENTER();\r\npar->riva.LockUnlock(&par->riva, 0);\r\nriva_create_i2c_busses(par);\r\nfor (i = 0; i < 3; i++) {\r\nif (!par->chan[i].par)\r\ncontinue;\r\nriva_probe_i2c_connector(par, i, &par->EDID);\r\nif (par->EDID && !fb_parse_edid(par->EDID, &var)) {\r\nprintk(PFX "Found EDID Block from BUS %i\n", i);\r\nbreak;\r\n}\r\n}\r\nNVTRACE_LEAVE();\r\nreturn (par->EDID) ? 1 : 0;\r\n}\r\nstatic void riva_update_default_var(struct fb_var_screeninfo *var,\r\nstruct fb_info *info)\r\n{\r\nstruct fb_monspecs *specs = &info->monspecs;\r\nstruct fb_videomode modedb;\r\nNVTRACE_ENTER();\r\nif (mode_option) {\r\nfb_find_mode(var, info, mode_option,\r\nspecs->modedb, specs->modedb_len,\r\nNULL, 8);\r\n} else if (specs->modedb != NULL) {\r\nmodedb = specs->modedb[0];\r\nif (info->monspecs.misc & FB_MISC_1ST_DETAIL) {\r\nint i;\r\nfor (i = 0; i < specs->modedb_len; i++) {\r\nif (specs->modedb[i].flag & FB_MODE_IS_FIRST) {\r\nmodedb = specs->modedb[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nvar->bits_per_pixel = 8;\r\nriva_update_var(var, &modedb);\r\n}\r\nNVTRACE_LEAVE();\r\n}\r\nstatic void riva_get_EDID(struct fb_info *info, struct pci_dev *pdev)\r\n{\r\nNVTRACE_ENTER();\r\nif (riva_get_EDID_OF(info, pdev)) {\r\nNVTRACE_LEAVE();\r\nreturn;\r\n}\r\nif (IS_ENABLED(CONFIG_OF))\r\nprintk(PFX "could not retrieve EDID from OF\n");\r\n#if defined(CONFIG_FB_RIVA_I2C)\r\nif (!riva_get_EDID_i2c(info))\r\nprintk(PFX "could not retrieve EDID from DDC/I2C\n");\r\n#endif\r\nNVTRACE_LEAVE();\r\n}\r\nstatic void riva_get_edidinfo(struct fb_info *info)\r\n{\r\nstruct fb_var_screeninfo *var = &rivafb_default_var;\r\nstruct riva_par *par = info->par;\r\nfb_edid_to_monspecs(par->EDID, &info->monspecs);\r\nfb_videomode_to_modelist(info->monspecs.modedb, info->monspecs.modedb_len,\r\n&info->modelist);\r\nriva_update_default_var(var, info);\r\nif (info->monspecs.input & FB_DISP_DDI)\r\npar->FlatPanel = 1;\r\n}\r\nstatic u32 riva_get_arch(struct pci_dev *pd)\r\n{\r\nu32 arch = 0;\r\nswitch (pd->device & 0x0ff0) {\r\ncase 0x0100:\r\ncase 0x0110:\r\ncase 0x0150:\r\ncase 0x0170:\r\ncase 0x0180:\r\ncase 0x01A0:\r\ncase 0x01F0:\r\narch = NV_ARCH_10;\r\nbreak;\r\ncase 0x0200:\r\ncase 0x0250:\r\ncase 0x0280:\r\narch = NV_ARCH_20;\r\nbreak;\r\ncase 0x0300:\r\ncase 0x0310:\r\ncase 0x0320:\r\ncase 0x0330:\r\ncase 0x0340:\r\narch = NV_ARCH_30;\r\nbreak;\r\ncase 0x0020:\r\narch = NV_ARCH_04;\r\nbreak;\r\ncase 0x0010:\r\narch = NV_ARCH_03;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn arch;\r\n}\r\nstatic int rivafb_probe(struct pci_dev *pd, const struct pci_device_id *ent)\r\n{\r\nstruct riva_par *default_par;\r\nstruct fb_info *info;\r\nint ret;\r\nNVTRACE_ENTER();\r\nassert(pd != NULL);\r\ninfo = framebuffer_alloc(sizeof(struct riva_par), &pd->dev);\r\nif (!info) {\r\nprintk (KERN_ERR PFX "could not allocate memory\n");\r\nret = -ENOMEM;\r\ngoto err_ret;\r\n}\r\ndefault_par = info->par;\r\ndefault_par->pdev = pd;\r\ninfo->pixmap.addr = kzalloc(8 * 1024, GFP_KERNEL);\r\nif (info->pixmap.addr == NULL) {\r\nret = -ENOMEM;\r\ngoto err_framebuffer_release;\r\n}\r\nret = pci_enable_device(pd);\r\nif (ret < 0) {\r\nprintk(KERN_ERR PFX "cannot enable PCI device\n");\r\ngoto err_free_pixmap;\r\n}\r\nret = pci_request_regions(pd, "rivafb");\r\nif (ret < 0) {\r\nprintk(KERN_ERR PFX "cannot request PCI regions\n");\r\ngoto err_disable_device;\r\n}\r\nmutex_init(&default_par->open_lock);\r\ndefault_par->riva.Architecture = riva_get_arch(pd);\r\ndefault_par->Chipset = (pd->vendor << 16) | pd->device;\r\nprintk(KERN_INFO PFX "nVidia device/chipset %X\n",default_par->Chipset);\r\nif(default_par->riva.Architecture == 0) {\r\nprintk(KERN_ERR PFX "unknown NV_ARCH\n");\r\nret=-ENODEV;\r\ngoto err_release_region;\r\n}\r\nif(default_par->riva.Architecture == NV_ARCH_10 ||\r\ndefault_par->riva.Architecture == NV_ARCH_20 ||\r\ndefault_par->riva.Architecture == NV_ARCH_30) {\r\nsprintf(rivafb_fix.id, "NV%x", (pd->device & 0x0ff0) >> 4);\r\n} else {\r\nsprintf(rivafb_fix.id, "NV%x", default_par->riva.Architecture);\r\n}\r\ndefault_par->FlatPanel = flatpanel;\r\nif (flatpanel == 1)\r\nprintk(KERN_INFO PFX "flatpanel support enabled\n");\r\ndefault_par->forceCRTC = forceCRTC;\r\nrivafb_fix.mmio_len = pci_resource_len(pd, 0);\r\nrivafb_fix.smem_len = pci_resource_len(pd, 1);\r\n{\r\nunsigned short cmd;\r\npci_read_config_word(pd, PCI_COMMAND, &cmd);\r\ncmd |= (PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\r\npci_write_config_word(pd, PCI_COMMAND, cmd);\r\n}\r\nrivafb_fix.mmio_start = pci_resource_start(pd, 0);\r\nrivafb_fix.smem_start = pci_resource_start(pd, 1);\r\ndefault_par->ctrl_base = ioremap(rivafb_fix.mmio_start,\r\nrivafb_fix.mmio_len);\r\nif (!default_par->ctrl_base) {\r\nprintk(KERN_ERR PFX "cannot ioremap MMIO base\n");\r\nret = -EIO;\r\ngoto err_release_region;\r\n}\r\nswitch (default_par->riva.Architecture) {\r\ncase NV_ARCH_03:\r\ndefault_par->riva.PRAMIN = ioremap(rivafb_fix.smem_start + 0x00C00000, 0x00008000);\r\nif (!default_par->riva.PRAMIN) {\r\nprintk(KERN_ERR PFX "cannot ioremap PRAMIN region\n");\r\nret = -EIO;\r\ngoto err_iounmap_ctrl_base;\r\n}\r\nbreak;\r\ncase NV_ARCH_04:\r\ncase NV_ARCH_10:\r\ncase NV_ARCH_20:\r\ncase NV_ARCH_30:\r\ndefault_par->riva.PCRTC0 =\r\n(u32 __iomem *)(default_par->ctrl_base + 0x00600000);\r\ndefault_par->riva.PRAMIN =\r\n(u32 __iomem *)(default_par->ctrl_base + 0x00710000);\r\nbreak;\r\n}\r\nriva_common_setup(default_par);\r\nif (default_par->riva.Architecture == NV_ARCH_03) {\r\ndefault_par->riva.PCRTC = default_par->riva.PCRTC0\r\n= default_par->riva.PGRAPH;\r\n}\r\nrivafb_fix.smem_len = riva_get_memlen(default_par) * 1024;\r\ndefault_par->dclk_max = riva_get_maxdclk(default_par) * 1000;\r\ninfo->screen_base = ioremap_wc(rivafb_fix.smem_start,\r\nrivafb_fix.smem_len);\r\nif (!info->screen_base) {\r\nprintk(KERN_ERR PFX "cannot ioremap FB base\n");\r\nret = -EIO;\r\ngoto err_iounmap_pramin;\r\n}\r\nif (!nomtrr)\r\ndefault_par->wc_cookie =\r\narch_phys_wc_add(rivafb_fix.smem_start,\r\nrivafb_fix.smem_len);\r\ninfo->fbops = &riva_fb_ops;\r\ninfo->fix = rivafb_fix;\r\nriva_get_EDID(info, pd);\r\nriva_get_edidinfo(info);\r\nret=riva_set_fbinfo(info);\r\nif (ret < 0) {\r\nprintk(KERN_ERR PFX "error setting initial video mode\n");\r\ngoto err_iounmap_screen_base;\r\n}\r\nfb_destroy_modedb(info->monspecs.modedb);\r\ninfo->monspecs.modedb = NULL;\r\npci_set_drvdata(pd, info);\r\nif (backlight)\r\nriva_bl_init(info->par);\r\nret = register_framebuffer(info);\r\nif (ret < 0) {\r\nprintk(KERN_ERR PFX\r\n"error registering riva framebuffer\n");\r\ngoto err_iounmap_screen_base;\r\n}\r\nprintk(KERN_INFO PFX\r\n"PCI nVidia %s framebuffer ver %s (%dMB @ 0x%lX)\n",\r\ninfo->fix.id,\r\nRIVAFB_VERSION,\r\ninfo->fix.smem_len / (1024 * 1024),\r\ninfo->fix.smem_start);\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\nerr_iounmap_screen_base:\r\n#ifdef CONFIG_FB_RIVA_I2C\r\nriva_delete_i2c_busses(info->par);\r\n#endif\r\niounmap(info->screen_base);\r\nerr_iounmap_pramin:\r\nif (default_par->riva.Architecture == NV_ARCH_03)\r\niounmap(default_par->riva.PRAMIN);\r\nerr_iounmap_ctrl_base:\r\niounmap(default_par->ctrl_base);\r\nerr_release_region:\r\npci_release_regions(pd);\r\nerr_disable_device:\r\nerr_free_pixmap:\r\nkfree(info->pixmap.addr);\r\nerr_framebuffer_release:\r\nframebuffer_release(info);\r\nerr_ret:\r\nreturn ret;\r\n}\r\nstatic void rivafb_remove(struct pci_dev *pd)\r\n{\r\nstruct fb_info *info = pci_get_drvdata(pd);\r\nstruct riva_par *par = info->par;\r\nNVTRACE_ENTER();\r\n#ifdef CONFIG_FB_RIVA_I2C\r\nriva_delete_i2c_busses(par);\r\nkfree(par->EDID);\r\n#endif\r\nunregister_framebuffer(info);\r\nriva_bl_exit(info);\r\narch_phys_wc_del(par->wc_cookie);\r\niounmap(par->ctrl_base);\r\niounmap(info->screen_base);\r\nif (par->riva.Architecture == NV_ARCH_03)\r\niounmap(par->riva.PRAMIN);\r\npci_release_regions(pd);\r\nkfree(info->pixmap.addr);\r\nframebuffer_release(info);\r\nNVTRACE_LEAVE();\r\n}\r\nstatic int rivafb_setup(char *options)\r\n{\r\nchar *this_opt;\r\nNVTRACE_ENTER();\r\nif (!options || !*options)\r\nreturn 0;\r\nwhile ((this_opt = strsep(&options, ",")) != NULL) {\r\nif (!strncmp(this_opt, "forceCRTC", 9)) {\r\nchar *p;\r\np = this_opt + 9;\r\nif (!*p || !*(++p)) continue;\r\nforceCRTC = *p - '0';\r\nif (forceCRTC < 0 || forceCRTC > 1)\r\nforceCRTC = -1;\r\n} else if (!strncmp(this_opt, "flatpanel", 9)) {\r\nflatpanel = 1;\r\n} else if (!strncmp(this_opt, "backlight:", 10)) {\r\nbacklight = simple_strtoul(this_opt+10, NULL, 0);\r\n} else if (!strncmp(this_opt, "nomtrr", 6)) {\r\nnomtrr = 1;\r\n} else if (!strncmp(this_opt, "strictmode", 10)) {\r\nstrictmode = 1;\r\n} else if (!strncmp(this_opt, "noaccel", 7)) {\r\nnoaccel = 1;\r\n} else\r\nmode_option = this_opt;\r\n}\r\nNVTRACE_LEAVE();\r\nreturn 0;\r\n}\r\nstatic int rivafb_init(void)\r\n{\r\n#ifndef MODULE\r\nchar *option = NULL;\r\nif (fb_get_options("rivafb", &option))\r\nreturn -ENODEV;\r\nrivafb_setup(option);\r\n#endif\r\nreturn pci_register_driver(&rivafb_driver);\r\n}\r\nstatic void __exit rivafb_exit(void)\r\n{\r\npci_unregister_driver(&rivafb_driver);\r\n}
