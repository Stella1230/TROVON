static void igb_write_vfta_i350(struct e1000_hw *hw, u32 offset, u32 value)\r\n{\r\nstruct igb_adapter *adapter = hw->back;\r\nint i;\r\nfor (i = 10; i--;)\r\narray_wr32(E1000_VFTA, offset, value);\r\nwrfl();\r\nadapter->shadow_vfta[offset] = value;\r\n}\r\nstatic bool igb_sgmii_uses_mdio_82575(struct e1000_hw *hw)\r\n{\r\nu32 reg = 0;\r\nbool ext_mdio = false;\r\nswitch (hw->mac.type) {\r\ncase e1000_82575:\r\ncase e1000_82576:\r\nreg = rd32(E1000_MDIC);\r\next_mdio = !!(reg & E1000_MDIC_DEST);\r\nbreak;\r\ncase e1000_82580:\r\ncase e1000_i350:\r\ncase e1000_i354:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nreg = rd32(E1000_MDICNFG);\r\next_mdio = !!(reg & E1000_MDICNFG_EXT_MDIO);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ext_mdio;\r\n}\r\nstatic s32 igb_check_for_link_media_swap(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu16 data;\r\nu8 port = 0;\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 0);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = phy->ops.read_reg(hw, E1000_M88E1112_STATUS, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (data & E1000_M88E1112_STATUS_LINK)\r\nport = E1000_MEDIA_PORT_COPPER;\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 1);\r\nif (ret_val)\r\nreturn ret_val;\r\nret_val = phy->ops.read_reg(hw, E1000_M88E1112_STATUS, &data);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (data & E1000_M88E1112_STATUS_LINK)\r\nport = E1000_MEDIA_PORT_OTHER;\r\nif (port && (hw->dev_spec._82575.media_port != port)) {\r\nhw->dev_spec._82575.media_port = port;\r\nhw->dev_spec._82575.media_changed = true;\r\n}\r\nif (port == E1000_MEDIA_PORT_COPPER) {\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 0);\r\nif (ret_val)\r\nreturn ret_val;\r\nigb_check_for_link_82575(hw);\r\n} else {\r\nigb_check_for_link_82575(hw);\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1112_PAGE_ADDR, 0);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 igb_init_phy_params_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val = 0;\r\nu32 ctrl_ext;\r\nif (hw->phy.media_type != e1000_media_type_copper) {\r\nphy->type = e1000_phy_none;\r\ngoto out;\r\n}\r\nphy->autoneg_mask = AUTONEG_ADVERTISE_SPEED_DEFAULT;\r\nphy->reset_delay_us = 100;\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\nif (igb_sgmii_active_82575(hw)) {\r\nphy->ops.reset = igb_phy_hw_reset_sgmii_82575;\r\nctrl_ext |= E1000_CTRL_I2C_ENA;\r\n} else {\r\nphy->ops.reset = igb_phy_hw_reset;\r\nctrl_ext &= ~E1000_CTRL_I2C_ENA;\r\n}\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\nigb_reset_mdicnfg_82580(hw);\r\nif (igb_sgmii_active_82575(hw) && !igb_sgmii_uses_mdio_82575(hw)) {\r\nphy->ops.read_reg = igb_read_phy_reg_sgmii_82575;\r\nphy->ops.write_reg = igb_write_phy_reg_sgmii_82575;\r\n} else {\r\nswitch (hw->mac.type) {\r\ncase e1000_82580:\r\ncase e1000_i350:\r\ncase e1000_i354:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nphy->ops.read_reg = igb_read_phy_reg_82580;\r\nphy->ops.write_reg = igb_write_phy_reg_82580;\r\nbreak;\r\ndefault:\r\nphy->ops.read_reg = igb_read_phy_reg_igp;\r\nphy->ops.write_reg = igb_write_phy_reg_igp;\r\n}\r\n}\r\nhw->bus.func = (rd32(E1000_STATUS) & E1000_STATUS_FUNC_MASK) >>\r\nE1000_STATUS_FUNC_SHIFT;\r\nret_val = hw->phy.ops.reset(hw);\r\nif (ret_val) {\r\nhw_dbg("Error resetting the PHY.\n");\r\ngoto out;\r\n}\r\nret_val = igb_get_phy_id_82575(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\nswitch (phy->id) {\r\ncase M88E1543_E_PHY_ID:\r\ncase M88E1512_E_PHY_ID:\r\ncase I347AT4_E_PHY_ID:\r\ncase M88E1112_E_PHY_ID:\r\ncase M88E1111_I_PHY_ID:\r\nphy->type = e1000_phy_m88;\r\nphy->ops.check_polarity = igb_check_polarity_m88;\r\nphy->ops.get_phy_info = igb_get_phy_info_m88;\r\nif (phy->id != M88E1111_I_PHY_ID)\r\nphy->ops.get_cable_length =\r\nigb_get_cable_length_m88_gen2;\r\nelse\r\nphy->ops.get_cable_length = igb_get_cable_length_m88;\r\nphy->ops.force_speed_duplex = igb_phy_force_speed_duplex_m88;\r\nif (phy->id == M88E1112_E_PHY_ID) {\r\nu16 data;\r\nret_val = phy->ops.write_reg(hw,\r\nE1000_M88E1112_PAGE_ADDR,\r\n2);\r\nif (ret_val)\r\ngoto out;\r\nret_val = phy->ops.read_reg(hw,\r\nE1000_M88E1112_MAC_CTRL_1,\r\n&data);\r\nif (ret_val)\r\ngoto out;\r\ndata = (data & E1000_M88E1112_MAC_CTRL_1_MODE_MASK) >>\r\nE1000_M88E1112_MAC_CTRL_1_MODE_SHIFT;\r\nif (data == E1000_M88E1112_AUTO_COPPER_SGMII ||\r\ndata == E1000_M88E1112_AUTO_COPPER_BASEX)\r\nhw->mac.ops.check_for_link =\r\nigb_check_for_link_media_swap;\r\n}\r\nif (phy->id == M88E1512_E_PHY_ID) {\r\nret_val = igb_initialize_M88E1512_phy(hw);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nif (phy->id == M88E1543_E_PHY_ID) {\r\nret_val = igb_initialize_M88E1543_phy(hw);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nbreak;\r\ncase IGP03E1000_E_PHY_ID:\r\nphy->type = e1000_phy_igp_3;\r\nphy->ops.get_phy_info = igb_get_phy_info_igp;\r\nphy->ops.get_cable_length = igb_get_cable_length_igp_2;\r\nphy->ops.force_speed_duplex = igb_phy_force_speed_duplex_igp;\r\nphy->ops.set_d0_lplu_state = igb_set_d0_lplu_state_82575;\r\nphy->ops.set_d3_lplu_state = igb_set_d3_lplu_state;\r\nbreak;\r\ncase I82580_I_PHY_ID:\r\ncase I350_I_PHY_ID:\r\nphy->type = e1000_phy_82580;\r\nphy->ops.force_speed_duplex =\r\nigb_phy_force_speed_duplex_82580;\r\nphy->ops.get_cable_length = igb_get_cable_length_82580;\r\nphy->ops.get_phy_info = igb_get_phy_info_82580;\r\nphy->ops.set_d0_lplu_state = igb_set_d0_lplu_state_82580;\r\nphy->ops.set_d3_lplu_state = igb_set_d3_lplu_state_82580;\r\nbreak;\r\ncase I210_I_PHY_ID:\r\nphy->type = e1000_phy_i210;\r\nphy->ops.check_polarity = igb_check_polarity_m88;\r\nphy->ops.get_cfg_done = igb_get_cfg_done_i210;\r\nphy->ops.get_phy_info = igb_get_phy_info_m88;\r\nphy->ops.get_cable_length = igb_get_cable_length_m88_gen2;\r\nphy->ops.set_d0_lplu_state = igb_set_d0_lplu_state_82580;\r\nphy->ops.set_d3_lplu_state = igb_set_d3_lplu_state_82580;\r\nphy->ops.force_speed_duplex = igb_phy_force_speed_duplex_m88;\r\nbreak;\r\ndefault:\r\nret_val = -E1000_ERR_PHY;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_init_nvm_params_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_nvm_info *nvm = &hw->nvm;\r\nu32 eecd = rd32(E1000_EECD);\r\nu16 size;\r\nsize = (u16)((eecd & E1000_EECD_SIZE_EX_MASK) >>\r\nE1000_EECD_SIZE_EX_SHIFT);\r\nsize += NVM_WORD_SIZE_BASE_SHIFT;\r\nif (size > 15)\r\nsize = 15;\r\nnvm->word_size = BIT(size);\r\nnvm->opcode_bits = 8;\r\nnvm->delay_usec = 1;\r\nswitch (nvm->override) {\r\ncase e1000_nvm_override_spi_large:\r\nnvm->page_size = 32;\r\nnvm->address_bits = 16;\r\nbreak;\r\ncase e1000_nvm_override_spi_small:\r\nnvm->page_size = 8;\r\nnvm->address_bits = 8;\r\nbreak;\r\ndefault:\r\nnvm->page_size = eecd & E1000_EECD_ADDR_BITS ? 32 : 8;\r\nnvm->address_bits = eecd & E1000_EECD_ADDR_BITS ?\r\n16 : 8;\r\nbreak;\r\n}\r\nif (nvm->word_size == BIT(15))\r\nnvm->page_size = 128;\r\nnvm->type = e1000_nvm_eeprom_spi;\r\nnvm->ops.acquire = igb_acquire_nvm_82575;\r\nnvm->ops.release = igb_release_nvm_82575;\r\nnvm->ops.write = igb_write_nvm_spi;\r\nnvm->ops.validate = igb_validate_nvm_checksum;\r\nnvm->ops.update = igb_update_nvm_checksum;\r\nif (nvm->word_size < BIT(15))\r\nnvm->ops.read = igb_read_nvm_eerd;\r\nelse\r\nnvm->ops.read = igb_read_nvm_spi;\r\nswitch (hw->mac.type) {\r\ncase e1000_82580:\r\nnvm->ops.validate = igb_validate_nvm_checksum_82580;\r\nnvm->ops.update = igb_update_nvm_checksum_82580;\r\nbreak;\r\ncase e1000_i354:\r\ncase e1000_i350:\r\nnvm->ops.validate = igb_validate_nvm_checksum_i350;\r\nnvm->ops.update = igb_update_nvm_checksum_i350;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 igb_init_mac_params_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\r\nmac->mta_reg_count = 128;\r\nmac->uta_reg_count = (hw->mac.type == e1000_82575) ? 0 : 128;\r\nswitch (mac->type) {\r\ncase e1000_82576:\r\nmac->rar_entry_count = E1000_RAR_ENTRIES_82576;\r\nbreak;\r\ncase e1000_82580:\r\nmac->rar_entry_count = E1000_RAR_ENTRIES_82580;\r\nbreak;\r\ncase e1000_i350:\r\ncase e1000_i354:\r\nmac->rar_entry_count = E1000_RAR_ENTRIES_I350;\r\nbreak;\r\ndefault:\r\nmac->rar_entry_count = E1000_RAR_ENTRIES_82575;\r\nbreak;\r\n}\r\nif (mac->type >= e1000_82580)\r\nmac->ops.reset_hw = igb_reset_hw_82580;\r\nelse\r\nmac->ops.reset_hw = igb_reset_hw_82575;\r\nif (mac->type >= e1000_i210) {\r\nmac->ops.acquire_swfw_sync = igb_acquire_swfw_sync_i210;\r\nmac->ops.release_swfw_sync = igb_release_swfw_sync_i210;\r\n} else {\r\nmac->ops.acquire_swfw_sync = igb_acquire_swfw_sync_82575;\r\nmac->ops.release_swfw_sync = igb_release_swfw_sync_82575;\r\n}\r\nif ((hw->mac.type == e1000_i350) || (hw->mac.type == e1000_i354))\r\nmac->ops.write_vfta = igb_write_vfta_i350;\r\nelse\r\nmac->ops.write_vfta = igb_write_vfta;\r\nmac->asf_firmware_present = true;\r\nmac->arc_subsystem_valid =\r\n(rd32(E1000_FWSM) & E1000_FWSM_MODE_MASK)\r\n? true : false;\r\nif (mac->type >= e1000_i350)\r\ndev_spec->eee_disable = false;\r\nelse\r\ndev_spec->eee_disable = true;\r\nif (mac->type >= e1000_i210)\r\ndev_spec->clear_semaphore_once = true;\r\nmac->ops.setup_physical_interface =\r\n(hw->phy.media_type == e1000_media_type_copper)\r\n? igb_setup_copper_link_82575\r\n: igb_setup_serdes_link_82575;\r\nif (mac->type == e1000_82580) {\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_DH89XXCC_SGMII:\r\ncase E1000_DEV_ID_DH89XXCC_SERDES:\r\ncase E1000_DEV_ID_DH89XXCC_BACKPLANE:\r\ncase E1000_DEV_ID_DH89XXCC_SFP:\r\nbreak;\r\ndefault:\r\nhw->dev_spec._82575.mas_capable = true;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 igb_set_sfp_media_type_82575(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = E1000_ERR_CONFIG;\r\nu32 ctrl_ext = 0;\r\nstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\r\nstruct e1000_sfp_flags *eth_flags = &dev_spec->eth_flags;\r\nu8 tranceiver_type = 0;\r\ns32 timeout = 3;\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\nctrl_ext &= ~E1000_CTRL_EXT_SDP3_DATA;\r\nwr32(E1000_CTRL_EXT, ctrl_ext | E1000_CTRL_I2C_ENA);\r\nwrfl();\r\nwhile (timeout) {\r\nret_val = igb_read_sfp_data_byte(hw,\r\nE1000_I2CCMD_SFP_DATA_ADDR(E1000_SFF_IDENTIFIER_OFFSET),\r\n&tranceiver_type);\r\nif (ret_val == 0)\r\nbreak;\r\nmsleep(100);\r\ntimeout--;\r\n}\r\nif (ret_val != 0)\r\ngoto out;\r\nret_val = igb_read_sfp_data_byte(hw,\r\nE1000_I2CCMD_SFP_DATA_ADDR(E1000_SFF_ETH_FLAGS_OFFSET),\r\n(u8 *)eth_flags);\r\nif (ret_val != 0)\r\ngoto out;\r\nif ((tranceiver_type == E1000_SFF_IDENTIFIER_SFP) ||\r\n(tranceiver_type == E1000_SFF_IDENTIFIER_SFF)) {\r\ndev_spec->module_plugged = true;\r\nif (eth_flags->e1000_base_lx || eth_flags->e1000_base_sx) {\r\nhw->phy.media_type = e1000_media_type_internal_serdes;\r\n} else if (eth_flags->e100_base_fx) {\r\ndev_spec->sgmii_active = true;\r\nhw->phy.media_type = e1000_media_type_internal_serdes;\r\n} else if (eth_flags->e1000_base_t) {\r\ndev_spec->sgmii_active = true;\r\nhw->phy.media_type = e1000_media_type_copper;\r\n} else {\r\nhw->phy.media_type = e1000_media_type_unknown;\r\nhw_dbg("PHY module has not been recognized\n");\r\ngoto out;\r\n}\r\n} else {\r\nhw->phy.media_type = e1000_media_type_unknown;\r\n}\r\nret_val = 0;\r\nout:\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_get_invariants_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\r\ns32 ret_val;\r\nu32 ctrl_ext = 0;\r\nu32 link_mode = 0;\r\nswitch (hw->device_id) {\r\ncase E1000_DEV_ID_82575EB_COPPER:\r\ncase E1000_DEV_ID_82575EB_FIBER_SERDES:\r\ncase E1000_DEV_ID_82575GB_QUAD_COPPER:\r\nmac->type = e1000_82575;\r\nbreak;\r\ncase E1000_DEV_ID_82576:\r\ncase E1000_DEV_ID_82576_NS:\r\ncase E1000_DEV_ID_82576_NS_SERDES:\r\ncase E1000_DEV_ID_82576_FIBER:\r\ncase E1000_DEV_ID_82576_SERDES:\r\ncase E1000_DEV_ID_82576_QUAD_COPPER:\r\ncase E1000_DEV_ID_82576_QUAD_COPPER_ET2:\r\ncase E1000_DEV_ID_82576_SERDES_QUAD:\r\nmac->type = e1000_82576;\r\nbreak;\r\ncase E1000_DEV_ID_82580_COPPER:\r\ncase E1000_DEV_ID_82580_FIBER:\r\ncase E1000_DEV_ID_82580_QUAD_FIBER:\r\ncase E1000_DEV_ID_82580_SERDES:\r\ncase E1000_DEV_ID_82580_SGMII:\r\ncase E1000_DEV_ID_82580_COPPER_DUAL:\r\ncase E1000_DEV_ID_DH89XXCC_SGMII:\r\ncase E1000_DEV_ID_DH89XXCC_SERDES:\r\ncase E1000_DEV_ID_DH89XXCC_BACKPLANE:\r\ncase E1000_DEV_ID_DH89XXCC_SFP:\r\nmac->type = e1000_82580;\r\nbreak;\r\ncase E1000_DEV_ID_I350_COPPER:\r\ncase E1000_DEV_ID_I350_FIBER:\r\ncase E1000_DEV_ID_I350_SERDES:\r\ncase E1000_DEV_ID_I350_SGMII:\r\nmac->type = e1000_i350;\r\nbreak;\r\ncase E1000_DEV_ID_I210_COPPER:\r\ncase E1000_DEV_ID_I210_FIBER:\r\ncase E1000_DEV_ID_I210_SERDES:\r\ncase E1000_DEV_ID_I210_SGMII:\r\ncase E1000_DEV_ID_I210_COPPER_FLASHLESS:\r\ncase E1000_DEV_ID_I210_SERDES_FLASHLESS:\r\nmac->type = e1000_i210;\r\nbreak;\r\ncase E1000_DEV_ID_I211_COPPER:\r\nmac->type = e1000_i211;\r\nbreak;\r\ncase E1000_DEV_ID_I354_BACKPLANE_1GBPS:\r\ncase E1000_DEV_ID_I354_SGMII:\r\ncase E1000_DEV_ID_I354_BACKPLANE_2_5GBPS:\r\nmac->type = e1000_i354;\r\nbreak;\r\ndefault:\r\nreturn -E1000_ERR_MAC_INIT;\r\n}\r\nhw->phy.media_type = e1000_media_type_copper;\r\ndev_spec->sgmii_active = false;\r\ndev_spec->module_plugged = false;\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\nlink_mode = ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK;\r\nswitch (link_mode) {\r\ncase E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:\r\nhw->phy.media_type = e1000_media_type_internal_serdes;\r\nbreak;\r\ncase E1000_CTRL_EXT_LINK_MODE_SGMII:\r\nif (igb_sgmii_uses_mdio_82575(hw)) {\r\nhw->phy.media_type = e1000_media_type_copper;\r\ndev_spec->sgmii_active = true;\r\nbreak;\r\n}\r\ncase E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES:\r\nret_val = igb_set_sfp_media_type_82575(hw);\r\nif ((ret_val != 0) ||\r\n(hw->phy.media_type == e1000_media_type_unknown)) {\r\nhw->phy.media_type = e1000_media_type_internal_serdes;\r\nif (link_mode == E1000_CTRL_EXT_LINK_MODE_SGMII) {\r\nhw->phy.media_type = e1000_media_type_copper;\r\ndev_spec->sgmii_active = true;\r\n}\r\nbreak;\r\n}\r\nif (dev_spec->eth_flags.e100_base_fx)\r\nbreak;\r\nctrl_ext &= ~E1000_CTRL_EXT_LINK_MODE_MASK;\r\nif (hw->phy.media_type == e1000_media_type_copper)\r\nctrl_ext |= E1000_CTRL_EXT_LINK_MODE_SGMII;\r\nelse\r\nctrl_ext |= E1000_CTRL_EXT_LINK_MODE_PCIE_SERDES;\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret_val = igb_init_mac_params_82575(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_init_nvm_params_82575(hw);\r\nswitch (hw->mac.type) {\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nret_val = igb_init_nvm_params_i210(hw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret_val)\r\ngoto out;\r\nswitch (mac->type) {\r\ncase e1000_82576:\r\ncase e1000_i350:\r\nigb_init_mbx_params_pf(hw);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret_val = igb_init_phy_params_82575(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_acquire_phy_82575(struct e1000_hw *hw)\r\n{\r\nu16 mask = E1000_SWFW_PHY0_SM;\r\nif (hw->bus.func == E1000_FUNC_1)\r\nmask = E1000_SWFW_PHY1_SM;\r\nelse if (hw->bus.func == E1000_FUNC_2)\r\nmask = E1000_SWFW_PHY2_SM;\r\nelse if (hw->bus.func == E1000_FUNC_3)\r\nmask = E1000_SWFW_PHY3_SM;\r\nreturn hw->mac.ops.acquire_swfw_sync(hw, mask);\r\n}\r\nstatic void igb_release_phy_82575(struct e1000_hw *hw)\r\n{\r\nu16 mask = E1000_SWFW_PHY0_SM;\r\nif (hw->bus.func == E1000_FUNC_1)\r\nmask = E1000_SWFW_PHY1_SM;\r\nelse if (hw->bus.func == E1000_FUNC_2)\r\nmask = E1000_SWFW_PHY2_SM;\r\nelse if (hw->bus.func == E1000_FUNC_3)\r\nmask = E1000_SWFW_PHY3_SM;\r\nhw->mac.ops.release_swfw_sync(hw, mask);\r\n}\r\nstatic s32 igb_read_phy_reg_sgmii_82575(struct e1000_hw *hw, u32 offset,\r\nu16 *data)\r\n{\r\ns32 ret_val = -E1000_ERR_PARAM;\r\nif (offset > E1000_MAX_SGMII_PHY_REG_ADDR) {\r\nhw_dbg("PHY Address %u is out of range\n", offset);\r\ngoto out;\r\n}\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_read_phy_reg_i2c(hw, offset, data);\r\nhw->phy.ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_write_phy_reg_sgmii_82575(struct e1000_hw *hw, u32 offset,\r\nu16 data)\r\n{\r\ns32 ret_val = -E1000_ERR_PARAM;\r\nif (offset > E1000_MAX_SGMII_PHY_REG_ADDR) {\r\nhw_dbg("PHY Address %d is out of range\n", offset);\r\ngoto out;\r\n}\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_write_phy_reg_i2c(hw, offset, data);\r\nhw->phy.ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_get_phy_id_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val = 0;\r\nu16 phy_id;\r\nu32 ctrl_ext;\r\nu32 mdic;\r\nif (hw->mac.type == e1000_i354)\r\nigb_get_phy_id(hw);\r\nif (!(igb_sgmii_active_82575(hw))) {\r\nphy->addr = 1;\r\nret_val = igb_get_phy_id(hw);\r\ngoto out;\r\n}\r\nif (igb_sgmii_uses_mdio_82575(hw)) {\r\nswitch (hw->mac.type) {\r\ncase e1000_82575:\r\ncase e1000_82576:\r\nmdic = rd32(E1000_MDIC);\r\nmdic &= E1000_MDIC_PHY_MASK;\r\nphy->addr = mdic >> E1000_MDIC_PHY_SHIFT;\r\nbreak;\r\ncase e1000_82580:\r\ncase e1000_i350:\r\ncase e1000_i354:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nmdic = rd32(E1000_MDICNFG);\r\nmdic &= E1000_MDICNFG_PHY_MASK;\r\nphy->addr = mdic >> E1000_MDICNFG_PHY_SHIFT;\r\nbreak;\r\ndefault:\r\nret_val = -E1000_ERR_PHY;\r\ngoto out;\r\n}\r\nret_val = igb_get_phy_id(hw);\r\ngoto out;\r\n}\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\nwr32(E1000_CTRL_EXT, ctrl_ext & ~E1000_CTRL_EXT_SDP3_DATA);\r\nwrfl();\r\nmsleep(300);\r\nfor (phy->addr = 1; phy->addr < 8; phy->addr++) {\r\nret_val = igb_read_phy_reg_sgmii_82575(hw, PHY_ID1, &phy_id);\r\nif (ret_val == 0) {\r\nhw_dbg("Vendor ID 0x%08X read at address %u\n",\r\nphy_id, phy->addr);\r\nif (phy_id == M88_VENDOR)\r\nbreak;\r\n} else {\r\nhw_dbg("PHY address %u was unreadable\n", phy->addr);\r\n}\r\n}\r\nif (phy->addr == 8) {\r\nphy->addr = 0;\r\nret_val = -E1000_ERR_PHY;\r\ngoto out;\r\n} else {\r\nret_val = igb_get_phy_id(hw);\r\n}\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_phy_hw_reset_sgmii_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nhw_dbg("Soft resetting SGMII attached PHY...\n");\r\nret_val = hw->phy.ops.write_reg(hw, 0x1B, 0x8084);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_phy_sw_reset(hw);\r\nif (ret_val)\r\ngoto out;\r\nif (phy->id == M88E1512_E_PHY_ID)\r\nret_val = igb_initialize_M88E1512_phy(hw);\r\nif (phy->id == M88E1543_E_PHY_ID)\r\nret_val = igb_initialize_M88E1543_phy(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_set_d0_lplu_state_82575(struct e1000_hw *hw, bool active)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val;\r\nu16 data;\r\nret_val = phy->ops.read_reg(hw, IGP02E1000_PHY_POWER_MGMT, &data);\r\nif (ret_val)\r\ngoto out;\r\nif (active) {\r\ndata |= IGP02E1000_PM_D0_LPLU;\r\nret_val = phy->ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,\r\ndata);\r\nif (ret_val)\r\ngoto out;\r\nret_val = phy->ops.read_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\n&data);\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = phy->ops.write_reg(hw, IGP01E1000_PHY_PORT_CONFIG,\r\ndata);\r\nif (ret_val)\r\ngoto out;\r\n} else {\r\ndata &= ~IGP02E1000_PM_D0_LPLU;\r\nret_val = phy->ops.write_reg(hw, IGP02E1000_PHY_POWER_MGMT,\r\ndata);\r\nif (phy->smart_speed == e1000_smart_speed_on) {\r\nret_val = phy->ops.read_reg(hw,\r\nIGP01E1000_PHY_PORT_CONFIG, &data);\r\nif (ret_val)\r\ngoto out;\r\ndata |= IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = phy->ops.write_reg(hw,\r\nIGP01E1000_PHY_PORT_CONFIG, data);\r\nif (ret_val)\r\ngoto out;\r\n} else if (phy->smart_speed == e1000_smart_speed_off) {\r\nret_val = phy->ops.read_reg(hw,\r\nIGP01E1000_PHY_PORT_CONFIG, &data);\r\nif (ret_val)\r\ngoto out;\r\ndata &= ~IGP01E1000_PSCFR_SMART_SPEED;\r\nret_val = phy->ops.write_reg(hw,\r\nIGP01E1000_PHY_PORT_CONFIG, data);\r\nif (ret_val)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_set_d0_lplu_state_82580(struct e1000_hw *hw, bool active)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nu16 data;\r\ndata = rd32(E1000_82580_PHY_POWER_MGMT);\r\nif (active) {\r\ndata |= E1000_82580_PM_D0_LPLU;\r\ndata &= ~E1000_82580_PM_SPD;\r\n} else {\r\ndata &= ~E1000_82580_PM_D0_LPLU;\r\nif (phy->smart_speed == e1000_smart_speed_on)\r\ndata |= E1000_82580_PM_SPD;\r\nelse if (phy->smart_speed == e1000_smart_speed_off)\r\ndata &= ~E1000_82580_PM_SPD; }\r\nwr32(E1000_82580_PHY_POWER_MGMT, data);\r\nreturn 0;\r\n}\r\nstatic s32 igb_set_d3_lplu_state_82580(struct e1000_hw *hw, bool active)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\nu16 data;\r\ndata = rd32(E1000_82580_PHY_POWER_MGMT);\r\nif (!active) {\r\ndata &= ~E1000_82580_PM_D3_LPLU;\r\nif (phy->smart_speed == e1000_smart_speed_on)\r\ndata |= E1000_82580_PM_SPD;\r\nelse if (phy->smart_speed == e1000_smart_speed_off)\r\ndata &= ~E1000_82580_PM_SPD;\r\n} else if ((phy->autoneg_advertised == E1000_ALL_SPEED_DUPLEX) ||\r\n(phy->autoneg_advertised == E1000_ALL_NOT_GIG) ||\r\n(phy->autoneg_advertised == E1000_ALL_10_SPEED)) {\r\ndata |= E1000_82580_PM_D3_LPLU;\r\ndata &= ~E1000_82580_PM_SPD;\r\n}\r\nwr32(E1000_82580_PHY_POWER_MGMT, data);\r\nreturn 0;\r\n}\r\nstatic s32 igb_acquire_nvm_82575(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nret_val = hw->mac.ops.acquire_swfw_sync(hw, E1000_SWFW_EEP_SM);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_acquire_nvm(hw);\r\nif (ret_val)\r\nhw->mac.ops.release_swfw_sync(hw, E1000_SWFW_EEP_SM);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic void igb_release_nvm_82575(struct e1000_hw *hw)\r\n{\r\nigb_release_nvm(hw);\r\nhw->mac.ops.release_swfw_sync(hw, E1000_SWFW_EEP_SM);\r\n}\r\nstatic s32 igb_acquire_swfw_sync_82575(struct e1000_hw *hw, u16 mask)\r\n{\r\nu32 swfw_sync;\r\nu32 swmask = mask;\r\nu32 fwmask = mask << 16;\r\ns32 ret_val = 0;\r\ns32 i = 0, timeout = 200;\r\nwhile (i < timeout) {\r\nif (igb_get_hw_semaphore(hw)) {\r\nret_val = -E1000_ERR_SWFW_SYNC;\r\ngoto out;\r\n}\r\nswfw_sync = rd32(E1000_SW_FW_SYNC);\r\nif (!(swfw_sync & (fwmask | swmask)))\r\nbreak;\r\nigb_put_hw_semaphore(hw);\r\nmdelay(5);\r\ni++;\r\n}\r\nif (i == timeout) {\r\nhw_dbg("Driver can't access resource, SW_FW_SYNC timeout.\n");\r\nret_val = -E1000_ERR_SWFW_SYNC;\r\ngoto out;\r\n}\r\nswfw_sync |= swmask;\r\nwr32(E1000_SW_FW_SYNC, swfw_sync);\r\nigb_put_hw_semaphore(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic void igb_release_swfw_sync_82575(struct e1000_hw *hw, u16 mask)\r\n{\r\nu32 swfw_sync;\r\nwhile (igb_get_hw_semaphore(hw) != 0)\r\n;\r\nswfw_sync = rd32(E1000_SW_FW_SYNC);\r\nswfw_sync &= ~mask;\r\nwr32(E1000_SW_FW_SYNC, swfw_sync);\r\nigb_put_hw_semaphore(hw);\r\n}\r\nstatic s32 igb_get_cfg_done_82575(struct e1000_hw *hw)\r\n{\r\ns32 timeout = PHY_CFG_TIMEOUT;\r\nu32 mask = E1000_NVM_CFG_DONE_PORT_0;\r\nif (hw->bus.func == 1)\r\nmask = E1000_NVM_CFG_DONE_PORT_1;\r\nelse if (hw->bus.func == E1000_FUNC_2)\r\nmask = E1000_NVM_CFG_DONE_PORT_2;\r\nelse if (hw->bus.func == E1000_FUNC_3)\r\nmask = E1000_NVM_CFG_DONE_PORT_3;\r\nwhile (timeout) {\r\nif (rd32(E1000_EEMNGCTL) & mask)\r\nbreak;\r\nusleep_range(1000, 2000);\r\ntimeout--;\r\n}\r\nif (!timeout)\r\nhw_dbg("MNG configuration cycle has not completed.\n");\r\nif (((rd32(E1000_EECD) & E1000_EECD_PRES) == 0) &&\r\n(hw->phy.type == e1000_phy_igp_3))\r\nigb_phy_init_script_igp3(hw);\r\nreturn 0;\r\n}\r\nstatic s32 igb_get_link_up_info_82575(struct e1000_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\ns32 ret_val;\r\nif (hw->phy.media_type != e1000_media_type_copper)\r\nret_val = igb_get_pcs_speed_and_duplex_82575(hw, speed,\r\nduplex);\r\nelse\r\nret_val = igb_get_speed_and_duplex_copper(hw, speed,\r\nduplex);\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_check_for_link_82575(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 speed, duplex;\r\nif (hw->phy.media_type != e1000_media_type_copper) {\r\nret_val = igb_get_pcs_speed_and_duplex_82575(hw, &speed,\r\n&duplex);\r\nhw->mac.get_link_status = !hw->mac.serdes_has_link;\r\nret_val = igb_config_fc_after_link_up(hw);\r\nif (ret_val)\r\nhw_dbg("Error configuring flow control\n");\r\n} else {\r\nret_val = igb_check_for_copper_link(hw);\r\n}\r\nreturn ret_val;\r\n}\r\nvoid igb_power_up_serdes_link_82575(struct e1000_hw *hw)\r\n{\r\nu32 reg;\r\nif ((hw->phy.media_type != e1000_media_type_internal_serdes) &&\r\n!igb_sgmii_active_82575(hw))\r\nreturn;\r\nreg = rd32(E1000_PCS_CFG0);\r\nreg |= E1000_PCS_CFG_PCS_EN;\r\nwr32(E1000_PCS_CFG0, reg);\r\nreg = rd32(E1000_CTRL_EXT);\r\nreg &= ~E1000_CTRL_EXT_SDP3_DATA;\r\nwr32(E1000_CTRL_EXT, reg);\r\nwrfl();\r\nusleep_range(1000, 2000);\r\n}\r\nstatic s32 igb_get_pcs_speed_and_duplex_82575(struct e1000_hw *hw, u16 *speed,\r\nu16 *duplex)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\nu32 pcs, status;\r\nmac->serdes_has_link = false;\r\n*speed = 0;\r\n*duplex = 0;\r\npcs = rd32(E1000_PCS_LSTAT);\r\nif ((pcs & E1000_PCS_LSTS_LINK_OK) && (pcs & E1000_PCS_LSTS_SYNK_OK)) {\r\nmac->serdes_has_link = true;\r\nif (pcs & E1000_PCS_LSTS_SPEED_1000)\r\n*speed = SPEED_1000;\r\nelse if (pcs & E1000_PCS_LSTS_SPEED_100)\r\n*speed = SPEED_100;\r\nelse\r\n*speed = SPEED_10;\r\nif (pcs & E1000_PCS_LSTS_DUPLEX_FULL)\r\n*duplex = FULL_DUPLEX;\r\nelse\r\n*duplex = HALF_DUPLEX;\r\nif (mac->type == e1000_i354) {\r\nstatus = rd32(E1000_STATUS);\r\nif ((status & E1000_STATUS_2P5_SKU) &&\r\n!(status & E1000_STATUS_2P5_SKU_OVER)) {\r\n*speed = SPEED_2500;\r\n*duplex = FULL_DUPLEX;\r\nhw_dbg("2500 Mbs, ");\r\nhw_dbg("Full Duplex\n");\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid igb_shutdown_serdes_link_82575(struct e1000_hw *hw)\r\n{\r\nu32 reg;\r\nif (hw->phy.media_type != e1000_media_type_internal_serdes &&\r\nigb_sgmii_active_82575(hw))\r\nreturn;\r\nif (!igb_enable_mng_pass_thru(hw)) {\r\nreg = rd32(E1000_PCS_CFG0);\r\nreg &= ~E1000_PCS_CFG_PCS_EN;\r\nwr32(E1000_PCS_CFG0, reg);\r\nreg = rd32(E1000_CTRL_EXT);\r\nreg |= E1000_CTRL_EXT_SDP3_DATA;\r\nwr32(E1000_CTRL_EXT, reg);\r\nwrfl();\r\nusleep_range(1000, 2000);\r\n}\r\n}\r\nstatic s32 igb_reset_hw_82575(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nret_val = igb_disable_pcie_master(hw);\r\nif (ret_val)\r\nhw_dbg("PCI-E Master disable polling has failed.\n");\r\nret_val = igb_set_pcie_completion_timeout(hw);\r\nif (ret_val)\r\nhw_dbg("PCI-E Set completion timeout has failed.\n");\r\nhw_dbg("Masking off all interrupts\n");\r\nwr32(E1000_IMC, 0xffffffff);\r\nwr32(E1000_RCTL, 0);\r\nwr32(E1000_TCTL, E1000_TCTL_PSP);\r\nwrfl();\r\nusleep_range(10000, 20000);\r\nctrl = rd32(E1000_CTRL);\r\nhw_dbg("Issuing a global reset to MAC\n");\r\nwr32(E1000_CTRL, ctrl | E1000_CTRL_RST);\r\nret_val = igb_get_auto_rd_done(hw);\r\nif (ret_val) {\r\nhw_dbg("Auto Read Done did not complete\n");\r\n}\r\nif ((rd32(E1000_EECD) & E1000_EECD_PRES) == 0)\r\nigb_reset_init_script_82575(hw);\r\nwr32(E1000_IMC, 0xffffffff);\r\nrd32(E1000_ICR);\r\nret_val = igb_check_alt_mac_addr(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_init_hw_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_mac_info *mac = &hw->mac;\r\ns32 ret_val;\r\nu16 i, rar_count = mac->rar_entry_count;\r\nif ((hw->mac.type >= e1000_i210) &&\r\n!(igb_get_flash_presence_i210(hw))) {\r\nret_val = igb_pll_workaround_i210(hw);\r\nif (ret_val)\r\nreturn ret_val;\r\n}\r\nret_val = igb_id_led_init(hw);\r\nif (ret_val) {\r\nhw_dbg("Error initializing identification LED\n");\r\n}\r\nhw_dbg("Initializing the IEEE VLAN\n");\r\nigb_clear_vfta(hw);\r\nigb_init_rx_addrs(hw, rar_count);\r\nhw_dbg("Zeroing the MTA\n");\r\nfor (i = 0; i < mac->mta_reg_count; i++)\r\narray_wr32(E1000_MTA, i, 0);\r\nhw_dbg("Zeroing the UTA\n");\r\nfor (i = 0; i < mac->uta_reg_count; i++)\r\narray_wr32(E1000_UTA, i, 0);\r\nret_val = igb_setup_link(hw);\r\nigb_clear_hw_cntrs_82575(hw);\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_setup_copper_link_82575(struct e1000_hw *hw)\r\n{\r\nu32 ctrl;\r\ns32 ret_val;\r\nu32 phpm_reg;\r\nctrl = rd32(E1000_CTRL);\r\nctrl |= E1000_CTRL_SLU;\r\nctrl &= ~(E1000_CTRL_FRCSPD | E1000_CTRL_FRCDPX);\r\nwr32(E1000_CTRL, ctrl);\r\nswitch (hw->mac.type) {\r\ncase e1000_82580:\r\ncase e1000_i350:\r\ncase e1000_i210:\r\ncase e1000_i211:\r\nphpm_reg = rd32(E1000_82580_PHY_POWER_MGMT);\r\nphpm_reg &= ~E1000_82580_PM_GO_LINKD;\r\nwr32(E1000_82580_PHY_POWER_MGMT, phpm_reg);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nret_val = igb_setup_serdes_link_82575(hw);\r\nif (ret_val)\r\ngoto out;\r\nif (igb_sgmii_active_82575(hw) && !hw->phy.reset_disable) {\r\nmsleep(300);\r\nret_val = hw->phy.ops.reset(hw);\r\nif (ret_val) {\r\nhw_dbg("Error resetting the PHY.\n");\r\ngoto out;\r\n}\r\n}\r\nswitch (hw->phy.type) {\r\ncase e1000_phy_i210:\r\ncase e1000_phy_m88:\r\nswitch (hw->phy.id) {\r\ncase I347AT4_E_PHY_ID:\r\ncase M88E1112_E_PHY_ID:\r\ncase M88E1543_E_PHY_ID:\r\ncase M88E1512_E_PHY_ID:\r\ncase I210_I_PHY_ID:\r\nret_val = igb_copper_link_setup_m88_gen2(hw);\r\nbreak;\r\ndefault:\r\nret_val = igb_copper_link_setup_m88(hw);\r\nbreak;\r\n}\r\nbreak;\r\ncase e1000_phy_igp_3:\r\nret_val = igb_copper_link_setup_igp(hw);\r\nbreak;\r\ncase e1000_phy_82580:\r\nret_val = igb_copper_link_setup_82580(hw);\r\nbreak;\r\ndefault:\r\nret_val = -E1000_ERR_PHY;\r\nbreak;\r\n}\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_setup_copper_link(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_setup_serdes_link_82575(struct e1000_hw *hw)\r\n{\r\nu32 ctrl_ext, ctrl_reg, reg, anadv_reg;\r\nbool pcs_autoneg;\r\ns32 ret_val = 0;\r\nu16 data;\r\nif ((hw->phy.media_type != e1000_media_type_internal_serdes) &&\r\n!igb_sgmii_active_82575(hw))\r\nreturn ret_val;\r\nwr32(E1000_SCTL, E1000_SCTL_DISABLE_SERDES_LOOPBACK);\r\nctrl_ext = rd32(E1000_CTRL_EXT);\r\nctrl_ext &= ~E1000_CTRL_EXT_SDP3_DATA;\r\nctrl_ext |= E1000_CTRL_I2C_ENA;\r\nwr32(E1000_CTRL_EXT, ctrl_ext);\r\nctrl_reg = rd32(E1000_CTRL);\r\nctrl_reg |= E1000_CTRL_SLU;\r\nif (hw->mac.type == e1000_82575 || hw->mac.type == e1000_82576) {\r\nctrl_reg |= E1000_CTRL_SWDPIN0 | E1000_CTRL_SWDPIN1;\r\nreg = rd32(E1000_CONNSW);\r\nreg |= E1000_CONNSW_ENRGSRC;\r\nwr32(E1000_CONNSW, reg);\r\n}\r\nreg = rd32(E1000_PCS_LCTL);\r\npcs_autoneg = hw->mac.autoneg;\r\nswitch (ctrl_ext & E1000_CTRL_EXT_LINK_MODE_MASK) {\r\ncase E1000_CTRL_EXT_LINK_MODE_SGMII:\r\npcs_autoneg = true;\r\nreg &= ~(E1000_PCS_LCTL_AN_TIMEOUT);\r\nbreak;\r\ncase E1000_CTRL_EXT_LINK_MODE_1000BASE_KX:\r\npcs_autoneg = false;\r\ndefault:\r\nif (hw->mac.type == e1000_82575 ||\r\nhw->mac.type == e1000_82576) {\r\nret_val = hw->nvm.ops.read(hw, NVM_COMPAT, 1, &data);\r\nif (ret_val) {\r\nhw_dbg(KERN_DEBUG "NVM Read Error\n\n");\r\nreturn ret_val;\r\n}\r\nif (data & E1000_EEPROM_PCS_AUTONEG_DISABLE_BIT)\r\npcs_autoneg = false;\r\n}\r\nctrl_reg |= E1000_CTRL_SPD_1000 | E1000_CTRL_FRCSPD |\r\nE1000_CTRL_FD | E1000_CTRL_FRCDPX;\r\nreg |= E1000_PCS_LCTL_FSV_1000 | E1000_PCS_LCTL_FDV_FULL;\r\nbreak;\r\n}\r\nwr32(E1000_CTRL, ctrl_reg);\r\nreg &= ~(E1000_PCS_LCTL_AN_ENABLE | E1000_PCS_LCTL_FLV_LINK_UP |\r\nE1000_PCS_LCTL_FSD | E1000_PCS_LCTL_FORCE_LINK);\r\nif (pcs_autoneg) {\r\nreg |= E1000_PCS_LCTL_AN_ENABLE |\r\nE1000_PCS_LCTL_AN_RESTART;\r\nreg &= ~E1000_PCS_LCTL_FORCE_FCTRL;\r\nanadv_reg = rd32(E1000_PCS_ANADV);\r\nanadv_reg &= ~(E1000_TXCW_ASM_DIR | E1000_TXCW_PAUSE);\r\nswitch (hw->fc.requested_mode) {\r\ncase e1000_fc_full:\r\ncase e1000_fc_rx_pause:\r\nanadv_reg |= E1000_TXCW_ASM_DIR;\r\nanadv_reg |= E1000_TXCW_PAUSE;\r\nbreak;\r\ncase e1000_fc_tx_pause:\r\nanadv_reg |= E1000_TXCW_ASM_DIR;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwr32(E1000_PCS_ANADV, anadv_reg);\r\nhw_dbg("Configuring Autoneg:PCS_LCTL=0x%08X\n", reg);\r\n} else {\r\nreg |= E1000_PCS_LCTL_FSD;\r\nreg |= E1000_PCS_LCTL_FORCE_FCTRL;\r\nhw_dbg("Configuring Forced Link:PCS_LCTL=0x%08X\n", reg);\r\n}\r\nwr32(E1000_PCS_LCTL, reg);\r\nif (!pcs_autoneg && !igb_sgmii_active_82575(hw))\r\nigb_force_mac_fc(hw);\r\nreturn ret_val;\r\n}\r\nstatic bool igb_sgmii_active_82575(struct e1000_hw *hw)\r\n{\r\nstruct e1000_dev_spec_82575 *dev_spec = &hw->dev_spec._82575;\r\nreturn dev_spec->sgmii_active;\r\n}\r\nstatic s32 igb_reset_init_script_82575(struct e1000_hw *hw)\r\n{\r\nif (hw->mac.type == e1000_82575) {\r\nhw_dbg("Running reset init script for 82575\n");\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x00, 0x0C);\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x01, 0x78);\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x1B, 0x23);\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCTL, 0x23, 0x15);\r\nigb_write_8bit_ctrl_reg(hw, E1000_CCMCTL, 0x14, 0x00);\r\nigb_write_8bit_ctrl_reg(hw, E1000_CCMCTL, 0x10, 0x00);\r\nigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x00, 0xEC);\r\nigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x61, 0xDF);\r\nigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x34, 0x05);\r\nigb_write_8bit_ctrl_reg(hw, E1000_GIOCTL, 0x2F, 0x81);\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCCTL, 0x02, 0x47);\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCCTL, 0x14, 0x00);\r\nigb_write_8bit_ctrl_reg(hw, E1000_SCCTL, 0x10, 0x00);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 igb_read_mac_addr_82575(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nret_val = igb_check_alt_mac_addr(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_read_mac_addr(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nvoid igb_power_down_phy_copper_82575(struct e1000_hw *hw)\r\n{\r\nif (!(igb_enable_mng_pass_thru(hw) || igb_check_reset_block(hw)))\r\nigb_power_down_phy_copper(hw);\r\n}\r\nstatic void igb_clear_hw_cntrs_82575(struct e1000_hw *hw)\r\n{\r\nigb_clear_hw_cntrs_base(hw);\r\nrd32(E1000_PRC64);\r\nrd32(E1000_PRC127);\r\nrd32(E1000_PRC255);\r\nrd32(E1000_PRC511);\r\nrd32(E1000_PRC1023);\r\nrd32(E1000_PRC1522);\r\nrd32(E1000_PTC64);\r\nrd32(E1000_PTC127);\r\nrd32(E1000_PTC255);\r\nrd32(E1000_PTC511);\r\nrd32(E1000_PTC1023);\r\nrd32(E1000_PTC1522);\r\nrd32(E1000_ALGNERRC);\r\nrd32(E1000_RXERRC);\r\nrd32(E1000_TNCRS);\r\nrd32(E1000_CEXTERR);\r\nrd32(E1000_TSCTC);\r\nrd32(E1000_TSCTFC);\r\nrd32(E1000_MGTPRC);\r\nrd32(E1000_MGTPDC);\r\nrd32(E1000_MGTPTC);\r\nrd32(E1000_IAC);\r\nrd32(E1000_ICRXOC);\r\nrd32(E1000_ICRXPTC);\r\nrd32(E1000_ICRXATC);\r\nrd32(E1000_ICTXPTC);\r\nrd32(E1000_ICTXATC);\r\nrd32(E1000_ICTXQEC);\r\nrd32(E1000_ICTXQMTC);\r\nrd32(E1000_ICRXDMTC);\r\nrd32(E1000_CBTMPC);\r\nrd32(E1000_HTDPMC);\r\nrd32(E1000_CBRMPC);\r\nrd32(E1000_RPTHC);\r\nrd32(E1000_HGPTC);\r\nrd32(E1000_HTCBDPC);\r\nrd32(E1000_HGORCL);\r\nrd32(E1000_HGORCH);\r\nrd32(E1000_HGOTCL);\r\nrd32(E1000_HGOTCH);\r\nrd32(E1000_LENERRS);\r\nif (hw->phy.media_type == e1000_media_type_internal_serdes ||\r\nigb_sgmii_active_82575(hw))\r\nrd32(E1000_SCVPC);\r\n}\r\nvoid igb_rx_fifo_flush_82575(struct e1000_hw *hw)\r\n{\r\nu32 rctl, rlpml, rxdctl[4], rfctl, temp_rctl, rx_enabled;\r\nint i, ms_wait;\r\nrfctl = rd32(E1000_RFCTL);\r\nrfctl |= E1000_RFCTL_IPV6_EX_DIS;\r\nwr32(E1000_RFCTL, rfctl);\r\nif (hw->mac.type != e1000_82575 ||\r\n!(rd32(E1000_MANC) & E1000_MANC_RCV_TCO_EN))\r\nreturn;\r\nfor (i = 0; i < 4; i++) {\r\nrxdctl[i] = rd32(E1000_RXDCTL(i));\r\nwr32(E1000_RXDCTL(i),\r\nrxdctl[i] & ~E1000_RXDCTL_QUEUE_ENABLE);\r\n}\r\nfor (ms_wait = 0; ms_wait < 10; ms_wait++) {\r\nusleep_range(1000, 2000);\r\nrx_enabled = 0;\r\nfor (i = 0; i < 4; i++)\r\nrx_enabled |= rd32(E1000_RXDCTL(i));\r\nif (!(rx_enabled & E1000_RXDCTL_QUEUE_ENABLE))\r\nbreak;\r\n}\r\nif (ms_wait == 10)\r\nhw_dbg("Queue disable timed out after 10ms\n");\r\nwr32(E1000_RFCTL, rfctl & ~E1000_RFCTL_LEF);\r\nrlpml = rd32(E1000_RLPML);\r\nwr32(E1000_RLPML, 0);\r\nrctl = rd32(E1000_RCTL);\r\ntemp_rctl = rctl & ~(E1000_RCTL_EN | E1000_RCTL_SBP);\r\ntemp_rctl |= E1000_RCTL_LPE;\r\nwr32(E1000_RCTL, temp_rctl);\r\nwr32(E1000_RCTL, temp_rctl | E1000_RCTL_EN);\r\nwrfl();\r\nusleep_range(2000, 3000);\r\nfor (i = 0; i < 4; i++)\r\nwr32(E1000_RXDCTL(i), rxdctl[i]);\r\nwr32(E1000_RCTL, rctl);\r\nwrfl();\r\nwr32(E1000_RLPML, rlpml);\r\nwr32(E1000_RFCTL, rfctl);\r\nrd32(E1000_ROC);\r\nrd32(E1000_RNBC);\r\nrd32(E1000_MPC);\r\n}\r\nstatic s32 igb_set_pcie_completion_timeout(struct e1000_hw *hw)\r\n{\r\nu32 gcr = rd32(E1000_GCR);\r\ns32 ret_val = 0;\r\nu16 pcie_devctl2;\r\nif (gcr & E1000_GCR_CMPL_TMOUT_MASK)\r\ngoto out;\r\nif (!(gcr & E1000_GCR_CAP_VER2)) {\r\ngcr |= E1000_GCR_CMPL_TMOUT_10ms;\r\ngoto out;\r\n}\r\nret_val = igb_read_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,\r\n&pcie_devctl2);\r\nif (ret_val)\r\ngoto out;\r\npcie_devctl2 |= PCIE_DEVICE_CONTROL2_16ms;\r\nret_val = igb_write_pcie_cap_reg(hw, PCIE_DEVICE_CONTROL2,\r\n&pcie_devctl2);\r\nout:\r\ngcr &= ~E1000_GCR_CMPL_TMOUT_RESEND;\r\nwr32(E1000_GCR, gcr);\r\nreturn ret_val;\r\n}\r\nvoid igb_vmdq_set_anti_spoofing_pf(struct e1000_hw *hw, bool enable, int pf)\r\n{\r\nu32 reg_val, reg_offset;\r\nswitch (hw->mac.type) {\r\ncase e1000_82576:\r\nreg_offset = E1000_DTXSWC;\r\nbreak;\r\ncase e1000_i350:\r\ncase e1000_i354:\r\nreg_offset = E1000_TXSWC;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nreg_val = rd32(reg_offset);\r\nif (enable) {\r\nreg_val |= (E1000_DTXSWC_MAC_SPOOF_MASK |\r\nE1000_DTXSWC_VLAN_SPOOF_MASK);\r\nreg_val ^= (BIT(pf) | BIT(pf + MAX_NUM_VFS));\r\n} else {\r\nreg_val &= ~(E1000_DTXSWC_MAC_SPOOF_MASK |\r\nE1000_DTXSWC_VLAN_SPOOF_MASK);\r\n}\r\nwr32(reg_offset, reg_val);\r\n}\r\nvoid igb_vmdq_set_loopback_pf(struct e1000_hw *hw, bool enable)\r\n{\r\nu32 dtxswc;\r\nswitch (hw->mac.type) {\r\ncase e1000_82576:\r\ndtxswc = rd32(E1000_DTXSWC);\r\nif (enable)\r\ndtxswc |= E1000_DTXSWC_VMDQ_LOOPBACK_EN;\r\nelse\r\ndtxswc &= ~E1000_DTXSWC_VMDQ_LOOPBACK_EN;\r\nwr32(E1000_DTXSWC, dtxswc);\r\nbreak;\r\ncase e1000_i354:\r\ncase e1000_i350:\r\ndtxswc = rd32(E1000_TXSWC);\r\nif (enable)\r\ndtxswc |= E1000_DTXSWC_VMDQ_LOOPBACK_EN;\r\nelse\r\ndtxswc &= ~E1000_DTXSWC_VMDQ_LOOPBACK_EN;\r\nwr32(E1000_TXSWC, dtxswc);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid igb_vmdq_set_replication_pf(struct e1000_hw *hw, bool enable)\r\n{\r\nu32 vt_ctl = rd32(E1000_VT_CTL);\r\nif (enable)\r\nvt_ctl |= E1000_VT_CTL_VM_REPL_EN;\r\nelse\r\nvt_ctl &= ~E1000_VT_CTL_VM_REPL_EN;\r\nwr32(E1000_VT_CTL, vt_ctl);\r\n}\r\ns32 igb_read_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 *data)\r\n{\r\ns32 ret_val;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_read_phy_reg_mdic(hw, offset, data);\r\nhw->phy.ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_write_phy_reg_82580(struct e1000_hw *hw, u32 offset, u16 data)\r\n{\r\ns32 ret_val;\r\nret_val = hw->phy.ops.acquire(hw);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_write_phy_reg_mdic(hw, offset, data);\r\nhw->phy.ops.release(hw);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_reset_mdicnfg_82580(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu32 mdicnfg;\r\nu16 nvm_data = 0;\r\nif (hw->mac.type != e1000_82580)\r\ngoto out;\r\nif (!igb_sgmii_active_82575(hw))\r\ngoto out;\r\nret_val = hw->nvm.ops.read(hw, NVM_INIT_CONTROL3_PORT_A +\r\nNVM_82580_LAN_FUNC_OFFSET(hw->bus.func), 1,\r\n&nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nmdicnfg = rd32(E1000_MDICNFG);\r\nif (nvm_data & NVM_WORD24_EXT_MDIO)\r\nmdicnfg |= E1000_MDICNFG_EXT_MDIO;\r\nif (nvm_data & NVM_WORD24_COM_MDIO)\r\nmdicnfg |= E1000_MDICNFG_COM_MDIO;\r\nwr32(E1000_MDICNFG, mdicnfg);\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_reset_hw_82580(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 swmbsw_mask = E1000_SW_SYNCH_MB;\r\nu32 ctrl;\r\nbool global_device_reset = hw->dev_spec._82575.global_device_reset;\r\nhw->dev_spec._82575.global_device_reset = false;\r\nif (hw->mac.type == e1000_82580)\r\nglobal_device_reset = false;\r\nctrl = rd32(E1000_CTRL);\r\nret_val = igb_disable_pcie_master(hw);\r\nif (ret_val)\r\nhw_dbg("PCI-E Master disable polling has failed.\n");\r\nhw_dbg("Masking off all interrupts\n");\r\nwr32(E1000_IMC, 0xffffffff);\r\nwr32(E1000_RCTL, 0);\r\nwr32(E1000_TCTL, E1000_TCTL_PSP);\r\nwrfl();\r\nusleep_range(10000, 11000);\r\nif (global_device_reset &&\r\nhw->mac.ops.acquire_swfw_sync(hw, swmbsw_mask))\r\nglobal_device_reset = false;\r\nif (global_device_reset &&\r\n!(rd32(E1000_STATUS) & E1000_STAT_DEV_RST_SET))\r\nctrl |= E1000_CTRL_DEV_RST;\r\nelse\r\nctrl |= E1000_CTRL_RST;\r\nwr32(E1000_CTRL, ctrl);\r\nwrfl();\r\nif (global_device_reset)\r\nusleep_range(5000, 6000);\r\nret_val = igb_get_auto_rd_done(hw);\r\nif (ret_val) {\r\nhw_dbg("Auto Read Done did not complete\n");\r\n}\r\nwr32(E1000_STATUS, E1000_STAT_DEV_RST_SET);\r\nwr32(E1000_IMC, 0xffffffff);\r\nrd32(E1000_ICR);\r\nret_val = igb_reset_mdicnfg_82580(hw);\r\nif (ret_val)\r\nhw_dbg("Could not reset MDICNFG based on EEPROM\n");\r\nret_val = igb_check_alt_mac_addr(hw);\r\nif (global_device_reset)\r\nhw->mac.ops.release_swfw_sync(hw, swmbsw_mask);\r\nreturn ret_val;\r\n}\r\nu16 igb_rxpbs_adjust_82580(u32 data)\r\n{\r\nu16 ret_val = 0;\r\nif (data < ARRAY_SIZE(e1000_82580_rxpbs_table))\r\nret_val = e1000_82580_rxpbs_table[data];\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_validate_nvm_checksum_with_offset(struct e1000_hw *hw,\r\nu16 offset)\r\n{\r\ns32 ret_val = 0;\r\nu16 checksum = 0;\r\nu16 i, nvm_data;\r\nfor (i = offset; i < ((NVM_CHECKSUM_REG + offset) + 1); i++) {\r\nret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nchecksum += nvm_data;\r\n}\r\nif (checksum != (u16) NVM_SUM) {\r\nhw_dbg("NVM Checksum Invalid\n");\r\nret_val = -E1000_ERR_NVM;\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_update_nvm_checksum_with_offset(struct e1000_hw *hw, u16 offset)\r\n{\r\ns32 ret_val;\r\nu16 checksum = 0;\r\nu16 i, nvm_data;\r\nfor (i = offset; i < (NVM_CHECKSUM_REG + offset); i++) {\r\nret_val = hw->nvm.ops.read(hw, i, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error while updating checksum.\n");\r\ngoto out;\r\n}\r\nchecksum += nvm_data;\r\n}\r\nchecksum = (u16) NVM_SUM - checksum;\r\nret_val = hw->nvm.ops.write(hw, (NVM_CHECKSUM_REG + offset), 1,\r\n&checksum);\r\nif (ret_val)\r\nhw_dbg("NVM Write Error while updating checksum.\n");\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_validate_nvm_checksum_82580(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 eeprom_regions_count = 1;\r\nu16 j, nvm_data;\r\nu16 nvm_offset;\r\nret_val = hw->nvm.ops.read(hw, NVM_COMPATIBILITY_REG_3, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error\n");\r\ngoto out;\r\n}\r\nif (nvm_data & NVM_COMPATIBILITY_BIT_MASK) {\r\neeprom_regions_count = 4;\r\n}\r\nfor (j = 0; j < eeprom_regions_count; j++) {\r\nnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\r\nret_val = igb_validate_nvm_checksum_with_offset(hw,\r\nnvm_offset);\r\nif (ret_val != 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_update_nvm_checksum_82580(struct e1000_hw *hw)\r\n{\r\ns32 ret_val;\r\nu16 j, nvm_data;\r\nu16 nvm_offset;\r\nret_val = hw->nvm.ops.read(hw, NVM_COMPATIBILITY_REG_3, 1, &nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Read Error while updating checksum compatibility bit.\n");\r\ngoto out;\r\n}\r\nif ((nvm_data & NVM_COMPATIBILITY_BIT_MASK) == 0) {\r\nnvm_data = nvm_data | NVM_COMPATIBILITY_BIT_MASK;\r\nret_val = hw->nvm.ops.write(hw, NVM_COMPATIBILITY_REG_3, 1,\r\n&nvm_data);\r\nif (ret_val) {\r\nhw_dbg("NVM Write Error while updating checksum compatibility bit.\n");\r\ngoto out;\r\n}\r\n}\r\nfor (j = 0; j < 4; j++) {\r\nnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\r\nret_val = igb_update_nvm_checksum_with_offset(hw, nvm_offset);\r\nif (ret_val)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_validate_nvm_checksum_i350(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 j;\r\nu16 nvm_offset;\r\nfor (j = 0; j < 4; j++) {\r\nnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\r\nret_val = igb_validate_nvm_checksum_with_offset(hw,\r\nnvm_offset);\r\nif (ret_val != 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_update_nvm_checksum_i350(struct e1000_hw *hw)\r\n{\r\ns32 ret_val = 0;\r\nu16 j;\r\nu16 nvm_offset;\r\nfor (j = 0; j < 4; j++) {\r\nnvm_offset = NVM_82580_LAN_FUNC_OFFSET(j);\r\nret_val = igb_update_nvm_checksum_with_offset(hw, nvm_offset);\r\nif (ret_val != 0)\r\ngoto out;\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 __igb_access_emi_reg(struct e1000_hw *hw, u16 address,\r\nu16 *data, bool read)\r\n{\r\ns32 ret_val = 0;\r\nret_val = hw->phy.ops.write_reg(hw, E1000_EMIADD, address);\r\nif (ret_val)\r\nreturn ret_val;\r\nif (read)\r\nret_val = hw->phy.ops.read_reg(hw, E1000_EMIDATA, data);\r\nelse\r\nret_val = hw->phy.ops.write_reg(hw, E1000_EMIDATA, *data);\r\nreturn ret_val;\r\n}\r\ns32 igb_read_emi_reg(struct e1000_hw *hw, u16 addr, u16 *data)\r\n{\r\nreturn __igb_access_emi_reg(hw, addr, data, true);\r\n}\r\ns32 igb_set_eee_i350(struct e1000_hw *hw, bool adv1G, bool adv100M)\r\n{\r\nu32 ipcnfg, eeer;\r\nif ((hw->mac.type < e1000_i350) ||\r\n(hw->phy.media_type != e1000_media_type_copper))\r\ngoto out;\r\nipcnfg = rd32(E1000_IPCNFG);\r\neeer = rd32(E1000_EEER);\r\nif (!(hw->dev_spec._82575.eee_disable)) {\r\nu32 eee_su = rd32(E1000_EEE_SU);\r\nif (adv100M)\r\nipcnfg |= E1000_IPCNFG_EEE_100M_AN;\r\nelse\r\nipcnfg &= ~E1000_IPCNFG_EEE_100M_AN;\r\nif (adv1G)\r\nipcnfg |= E1000_IPCNFG_EEE_1G_AN;\r\nelse\r\nipcnfg &= ~E1000_IPCNFG_EEE_1G_AN;\r\neeer |= (E1000_EEER_TX_LPI_EN | E1000_EEER_RX_LPI_EN |\r\nE1000_EEER_LPI_FC);\r\nif (eee_su & E1000_EEE_SU_LPI_CLK_STP)\r\nhw_dbg("LPI Clock Stop Bit should not be set!\n");\r\n} else {\r\nipcnfg &= ~(E1000_IPCNFG_EEE_1G_AN |\r\nE1000_IPCNFG_EEE_100M_AN);\r\neeer &= ~(E1000_EEER_TX_LPI_EN |\r\nE1000_EEER_RX_LPI_EN |\r\nE1000_EEER_LPI_FC);\r\n}\r\nwr32(E1000_IPCNFG, ipcnfg);\r\nwr32(E1000_EEER, eeer);\r\nrd32(E1000_IPCNFG);\r\nrd32(E1000_EEER);\r\nout:\r\nreturn 0;\r\n}\r\ns32 igb_set_eee_i354(struct e1000_hw *hw, bool adv1G, bool adv100M)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val = 0;\r\nu16 phy_data;\r\nif ((hw->phy.media_type != e1000_media_type_copper) ||\r\n((phy->id != M88E1543_E_PHY_ID) &&\r\n(phy->id != M88E1512_E_PHY_ID)))\r\ngoto out;\r\nif (!hw->dev_spec._82575.eee_disable) {\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 18);\r\nif (ret_val)\r\ngoto out;\r\nret_val = phy->ops.read_reg(hw, E1000_M88E1543_EEE_CTRL_1,\r\n&phy_data);\r\nif (ret_val)\r\ngoto out;\r\nphy_data |= E1000_M88E1543_EEE_CTRL_1_MS;\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1543_EEE_CTRL_1,\r\nphy_data);\r\nif (ret_val)\r\ngoto out;\r\nret_val = phy->ops.write_reg(hw, E1000_M88E1543_PAGE_ADDR, 0);\r\nif (ret_val)\r\ngoto out;\r\nret_val = igb_read_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\r\nE1000_EEE_ADV_DEV_I354,\r\n&phy_data);\r\nif (ret_val)\r\ngoto out;\r\nif (adv100M)\r\nphy_data |= E1000_EEE_ADV_100_SUPPORTED;\r\nelse\r\nphy_data &= ~E1000_EEE_ADV_100_SUPPORTED;\r\nif (adv1G)\r\nphy_data |= E1000_EEE_ADV_1000_SUPPORTED;\r\nelse\r\nphy_data &= ~E1000_EEE_ADV_1000_SUPPORTED;\r\nret_val = igb_write_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\r\nE1000_EEE_ADV_DEV_I354,\r\nphy_data);\r\n} else {\r\nret_val = igb_read_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\r\nE1000_EEE_ADV_DEV_I354,\r\n&phy_data);\r\nif (ret_val)\r\ngoto out;\r\nphy_data &= ~(E1000_EEE_ADV_100_SUPPORTED |\r\nE1000_EEE_ADV_1000_SUPPORTED);\r\nret_val = igb_write_xmdio_reg(hw, E1000_EEE_ADV_ADDR_I354,\r\nE1000_EEE_ADV_DEV_I354,\r\nphy_data);\r\n}\r\nout:\r\nreturn ret_val;\r\n}\r\ns32 igb_get_eee_status_i354(struct e1000_hw *hw, bool *status)\r\n{\r\nstruct e1000_phy_info *phy = &hw->phy;\r\ns32 ret_val = 0;\r\nu16 phy_data;\r\nif ((hw->phy.media_type != e1000_media_type_copper) ||\r\n((phy->id != M88E1543_E_PHY_ID) &&\r\n(phy->id != M88E1512_E_PHY_ID)))\r\ngoto out;\r\nret_val = igb_read_xmdio_reg(hw, E1000_PCS_STATUS_ADDR_I354,\r\nE1000_PCS_STATUS_DEV_I354,\r\n&phy_data);\r\nif (ret_val)\r\ngoto out;\r\n*status = phy_data & (E1000_PCS_STATUS_TX_LPI_RCVD |\r\nE1000_PCS_STATUS_RX_LPI_RCVD) ? true : false;\r\nout:\r\nreturn ret_val;\r\n}\r\nstatic s32 igb_get_thermal_sensor_data_generic(struct e1000_hw *hw)\r\n{\r\nu16 ets_offset;\r\nu16 ets_cfg;\r\nu16 ets_sensor;\r\nu8 num_sensors;\r\nu8 sensor_index;\r\nu8 sensor_location;\r\nu8 i;\r\nstruct e1000_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\r\nif ((hw->mac.type != e1000_i350) || (hw->bus.func != 0))\r\nreturn E1000_NOT_IMPLEMENTED;\r\ndata->sensor[0].temp = (rd32(E1000_THMJT) & 0xFF);\r\nhw->nvm.ops.read(hw, NVM_ETS_CFG, 1, &ets_offset);\r\nif ((ets_offset == 0x0000) || (ets_offset == 0xFFFF))\r\nreturn 0;\r\nhw->nvm.ops.read(hw, ets_offset, 1, &ets_cfg);\r\nif (((ets_cfg & NVM_ETS_TYPE_MASK) >> NVM_ETS_TYPE_SHIFT)\r\n!= NVM_ETS_TYPE_EMC)\r\nreturn E1000_NOT_IMPLEMENTED;\r\nnum_sensors = (ets_cfg & NVM_ETS_NUM_SENSORS_MASK);\r\nif (num_sensors > E1000_MAX_SENSORS)\r\nnum_sensors = E1000_MAX_SENSORS;\r\nfor (i = 1; i < num_sensors; i++) {\r\nhw->nvm.ops.read(hw, (ets_offset + i), 1, &ets_sensor);\r\nsensor_index = ((ets_sensor & NVM_ETS_DATA_INDEX_MASK) >>\r\nNVM_ETS_DATA_INDEX_SHIFT);\r\nsensor_location = ((ets_sensor & NVM_ETS_DATA_LOC_MASK) >>\r\nNVM_ETS_DATA_LOC_SHIFT);\r\nif (sensor_location != 0)\r\nhw->phy.ops.read_i2c_byte(hw,\r\ne1000_emc_temp_data[sensor_index],\r\nE1000_I2C_THERMAL_SENSOR_ADDR,\r\n&data->sensor[i].temp);\r\n}\r\nreturn 0;\r\n}\r\nstatic s32 igb_init_thermal_sensor_thresh_generic(struct e1000_hw *hw)\r\n{\r\nu16 ets_offset;\r\nu16 ets_cfg;\r\nu16 ets_sensor;\r\nu8 low_thresh_delta;\r\nu8 num_sensors;\r\nu8 sensor_index;\r\nu8 sensor_location;\r\nu8 therm_limit;\r\nu8 i;\r\nstruct e1000_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;\r\nif ((hw->mac.type != e1000_i350) || (hw->bus.func != 0))\r\nreturn E1000_NOT_IMPLEMENTED;\r\nmemset(data, 0, sizeof(struct e1000_thermal_sensor_data));\r\ndata->sensor[0].location = 0x1;\r\ndata->sensor[0].caution_thresh =\r\n(rd32(E1000_THHIGHTC) & 0xFF);\r\ndata->sensor[0].max_op_thresh =\r\n(rd32(E1000_THLOWTC) & 0xFF);\r\nhw->nvm.ops.read(hw, NVM_ETS_CFG, 1, &ets_offset);\r\nif ((ets_offset == 0x0000) || (ets_offset == 0xFFFF))\r\nreturn 0;\r\nhw->nvm.ops.read(hw, ets_offset, 1, &ets_cfg);\r\nif (((ets_cfg & NVM_ETS_TYPE_MASK) >> NVM_ETS_TYPE_SHIFT)\r\n!= NVM_ETS_TYPE_EMC)\r\nreturn E1000_NOT_IMPLEMENTED;\r\nlow_thresh_delta = ((ets_cfg & NVM_ETS_LTHRES_DELTA_MASK) >>\r\nNVM_ETS_LTHRES_DELTA_SHIFT);\r\nnum_sensors = (ets_cfg & NVM_ETS_NUM_SENSORS_MASK);\r\nfor (i = 1; i <= num_sensors; i++) {\r\nhw->nvm.ops.read(hw, (ets_offset + i), 1, &ets_sensor);\r\nsensor_index = ((ets_sensor & NVM_ETS_DATA_INDEX_MASK) >>\r\nNVM_ETS_DATA_INDEX_SHIFT);\r\nsensor_location = ((ets_sensor & NVM_ETS_DATA_LOC_MASK) >>\r\nNVM_ETS_DATA_LOC_SHIFT);\r\ntherm_limit = ets_sensor & NVM_ETS_DATA_HTHRESH_MASK;\r\nhw->phy.ops.write_i2c_byte(hw,\r\ne1000_emc_therm_limit[sensor_index],\r\nE1000_I2C_THERMAL_SENSOR_ADDR,\r\ntherm_limit);\r\nif ((i < E1000_MAX_SENSORS) && (sensor_location != 0)) {\r\ndata->sensor[i].location = sensor_location;\r\ndata->sensor[i].caution_thresh = therm_limit;\r\ndata->sensor[i].max_op_thresh = therm_limit -\r\nlow_thresh_delta;\r\n}\r\n}\r\nreturn 0;\r\n}
