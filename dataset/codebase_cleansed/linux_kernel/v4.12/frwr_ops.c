bool\r\nfrwr_is_supported(struct rpcrdma_ia *ia)\r\n{\r\nstruct ib_device_attr *attrs = &ia->ri_device->attrs;\r\nif (!(attrs->device_cap_flags & IB_DEVICE_MEM_MGT_EXTENSIONS))\r\ngoto out_not_supported;\r\nif (attrs->max_fast_reg_page_list_len == 0)\r\ngoto out_not_supported;\r\nreturn true;\r\nout_not_supported:\r\npr_info("rpcrdma: 'frwr' mode is not supported by device %s\n",\r\nia->ri_device->name);\r\nreturn false;\r\n}\r\nstatic int\r\nfrwr_op_init_mr(struct rpcrdma_ia *ia, struct rpcrdma_mw *r)\r\n{\r\nunsigned int depth = ia->ri_max_frmr_depth;\r\nstruct rpcrdma_frmr *f = &r->frmr;\r\nint rc;\r\nf->fr_mr = ib_alloc_mr(ia->ri_pd, ia->ri_mrtype, depth);\r\nif (IS_ERR(f->fr_mr))\r\ngoto out_mr_err;\r\nr->mw_sg = kcalloc(depth, sizeof(*r->mw_sg), GFP_KERNEL);\r\nif (!r->mw_sg)\r\ngoto out_list_err;\r\nsg_init_table(r->mw_sg, depth);\r\ninit_completion(&f->fr_linv_done);\r\nreturn 0;\r\nout_mr_err:\r\nrc = PTR_ERR(f->fr_mr);\r\ndprintk("RPC: %s: ib_alloc_mr status %i\n",\r\n__func__, rc);\r\nreturn rc;\r\nout_list_err:\r\nrc = -ENOMEM;\r\ndprintk("RPC: %s: sg allocation failure\n",\r\n__func__);\r\nib_dereg_mr(f->fr_mr);\r\nreturn rc;\r\n}\r\nstatic void\r\nfrwr_op_release_mr(struct rpcrdma_mw *r)\r\n{\r\nint rc;\r\nif (!list_empty(&r->mw_list))\r\nlist_del(&r->mw_list);\r\nrc = ib_dereg_mr(r->frmr.fr_mr);\r\nif (rc)\r\npr_err("rpcrdma: final ib_dereg_mr for %p returned %i\n",\r\nr, rc);\r\nkfree(r->mw_sg);\r\nkfree(r);\r\n}\r\nstatic int\r\n__frwr_reset_mr(struct rpcrdma_ia *ia, struct rpcrdma_mw *r)\r\n{\r\nstruct rpcrdma_frmr *f = &r->frmr;\r\nint rc;\r\nrc = ib_dereg_mr(f->fr_mr);\r\nif (rc) {\r\npr_warn("rpcrdma: ib_dereg_mr status %d, frwr %p orphaned\n",\r\nrc, r);\r\nreturn rc;\r\n}\r\nf->fr_mr = ib_alloc_mr(ia->ri_pd, ia->ri_mrtype,\r\nia->ri_max_frmr_depth);\r\nif (IS_ERR(f->fr_mr)) {\r\npr_warn("rpcrdma: ib_alloc_mr status %ld, frwr %p orphaned\n",\r\nPTR_ERR(f->fr_mr), r);\r\nreturn PTR_ERR(f->fr_mr);\r\n}\r\ndprintk("RPC: %s: recovered FRMR %p\n", __func__, f);\r\nf->fr_state = FRMR_IS_INVALID;\r\nreturn 0;\r\n}\r\nstatic void\r\nfrwr_op_recover_mr(struct rpcrdma_mw *mw)\r\n{\r\nenum rpcrdma_frmr_state state = mw->frmr.fr_state;\r\nstruct rpcrdma_xprt *r_xprt = mw->mw_xprt;\r\nstruct rpcrdma_ia *ia = &r_xprt->rx_ia;\r\nint rc;\r\nrc = __frwr_reset_mr(ia, mw);\r\nif (state != FRMR_FLUSHED_LI)\r\nib_dma_unmap_sg(ia->ri_device,\r\nmw->mw_sg, mw->mw_nents, mw->mw_dir);\r\nif (rc)\r\ngoto out_release;\r\nrpcrdma_put_mw(r_xprt, mw);\r\nr_xprt->rx_stats.mrs_recovered++;\r\nreturn;\r\nout_release:\r\npr_err("rpcrdma: FRMR reset failed %d, %p release\n", rc, mw);\r\nr_xprt->rx_stats.mrs_orphaned++;\r\nspin_lock(&r_xprt->rx_buf.rb_mwlock);\r\nlist_del(&mw->mw_all);\r\nspin_unlock(&r_xprt->rx_buf.rb_mwlock);\r\nfrwr_op_release_mr(mw);\r\n}\r\nstatic int\r\nfrwr_op_open(struct rpcrdma_ia *ia, struct rpcrdma_ep *ep,\r\nstruct rpcrdma_create_data_internal *cdata)\r\n{\r\nstruct ib_device_attr *attrs = &ia->ri_device->attrs;\r\nint depth, delta;\r\nia->ri_mrtype = IB_MR_TYPE_MEM_REG;\r\nif (attrs->device_cap_flags & IB_DEVICE_SG_GAPS_REG)\r\nia->ri_mrtype = IB_MR_TYPE_SG_GAPS;\r\nia->ri_max_frmr_depth =\r\nmin_t(unsigned int, RPCRDMA_MAX_DATA_SEGS,\r\nattrs->max_fast_reg_page_list_len);\r\ndprintk("RPC: %s: device's max FR page list len = %u\n",\r\n__func__, ia->ri_max_frmr_depth);\r\ndepth = 7;\r\nif (ia->ri_max_frmr_depth < RPCRDMA_MAX_DATA_SEGS) {\r\ndelta = RPCRDMA_MAX_DATA_SEGS - ia->ri_max_frmr_depth;\r\ndo {\r\ndepth += 2;\r\ndelta -= ia->ri_max_frmr_depth;\r\n} while (delta > 0);\r\n}\r\nep->rep_attr.cap.max_send_wr *= depth;\r\nif (ep->rep_attr.cap.max_send_wr > attrs->max_qp_wr) {\r\ncdata->max_requests = attrs->max_qp_wr / depth;\r\nif (!cdata->max_requests)\r\nreturn -EINVAL;\r\nep->rep_attr.cap.max_send_wr = cdata->max_requests *\r\ndepth;\r\n}\r\nia->ri_max_segs = max_t(unsigned int, 1, RPCRDMA_MAX_DATA_SEGS /\r\nia->ri_max_frmr_depth);\r\nreturn 0;\r\n}\r\nstatic size_t\r\nfrwr_op_maxpages(struct rpcrdma_xprt *r_xprt)\r\n{\r\nstruct rpcrdma_ia *ia = &r_xprt->rx_ia;\r\nreturn min_t(unsigned int, RPCRDMA_MAX_DATA_SEGS,\r\nRPCRDMA_MAX_HDR_SEGS * ia->ri_max_frmr_depth);\r\n}\r\nstatic void\r\n__frwr_sendcompletion_flush(struct ib_wc *wc, const char *wr)\r\n{\r\nif (wc->status != IB_WC_WR_FLUSH_ERR)\r\npr_err("rpcrdma: %s: %s (%u/0x%x)\n",\r\nwr, ib_wc_status_msg(wc->status),\r\nwc->status, wc->vendor_err);\r\n}\r\nstatic void\r\nfrwr_wc_fastreg(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct rpcrdma_frmr *frmr;\r\nstruct ib_cqe *cqe;\r\nif (wc->status != IB_WC_SUCCESS) {\r\ncqe = wc->wr_cqe;\r\nfrmr = container_of(cqe, struct rpcrdma_frmr, fr_cqe);\r\nfrmr->fr_state = FRMR_FLUSHED_FR;\r\n__frwr_sendcompletion_flush(wc, "fastreg");\r\n}\r\n}\r\nstatic void\r\nfrwr_wc_localinv(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct rpcrdma_frmr *frmr;\r\nstruct ib_cqe *cqe;\r\nif (wc->status != IB_WC_SUCCESS) {\r\ncqe = wc->wr_cqe;\r\nfrmr = container_of(cqe, struct rpcrdma_frmr, fr_cqe);\r\nfrmr->fr_state = FRMR_FLUSHED_LI;\r\n__frwr_sendcompletion_flush(wc, "localinv");\r\n}\r\n}\r\nstatic void\r\nfrwr_wc_localinv_wake(struct ib_cq *cq, struct ib_wc *wc)\r\n{\r\nstruct rpcrdma_frmr *frmr;\r\nstruct ib_cqe *cqe;\r\ncqe = wc->wr_cqe;\r\nfrmr = container_of(cqe, struct rpcrdma_frmr, fr_cqe);\r\nif (wc->status != IB_WC_SUCCESS) {\r\nfrmr->fr_state = FRMR_FLUSHED_LI;\r\n__frwr_sendcompletion_flush(wc, "localinv");\r\n}\r\ncomplete(&frmr->fr_linv_done);\r\n}\r\nstatic int\r\nfrwr_op_map(struct rpcrdma_xprt *r_xprt, struct rpcrdma_mr_seg *seg,\r\nint nsegs, bool writing, struct rpcrdma_mw **out)\r\n{\r\nstruct rpcrdma_ia *ia = &r_xprt->rx_ia;\r\nbool holes_ok = ia->ri_mrtype == IB_MR_TYPE_SG_GAPS;\r\nstruct rpcrdma_mw *mw;\r\nstruct rpcrdma_frmr *frmr;\r\nstruct ib_mr *mr;\r\nstruct ib_reg_wr *reg_wr;\r\nstruct ib_send_wr *bad_wr;\r\nint rc, i, n, dma_nents;\r\nu8 key;\r\nmw = NULL;\r\ndo {\r\nif (mw)\r\nrpcrdma_defer_mr_recovery(mw);\r\nmw = rpcrdma_get_mw(r_xprt);\r\nif (!mw)\r\nreturn -ENOBUFS;\r\n} while (mw->frmr.fr_state != FRMR_IS_INVALID);\r\nfrmr = &mw->frmr;\r\nfrmr->fr_state = FRMR_IS_VALID;\r\nmr = frmr->fr_mr;\r\nreg_wr = &frmr->fr_regwr;\r\nif (nsegs > ia->ri_max_frmr_depth)\r\nnsegs = ia->ri_max_frmr_depth;\r\nfor (i = 0; i < nsegs;) {\r\nif (seg->mr_page)\r\nsg_set_page(&mw->mw_sg[i],\r\nseg->mr_page,\r\nseg->mr_len,\r\noffset_in_page(seg->mr_offset));\r\nelse\r\nsg_set_buf(&mw->mw_sg[i], seg->mr_offset,\r\nseg->mr_len);\r\n++seg;\r\n++i;\r\nif (holes_ok)\r\ncontinue;\r\nif ((i < nsegs && offset_in_page(seg->mr_offset)) ||\r\noffset_in_page((seg-1)->mr_offset + (seg-1)->mr_len))\r\nbreak;\r\n}\r\nmw->mw_nents = i;\r\nmw->mw_dir = rpcrdma_data_dir(writing);\r\nif (i == 0)\r\ngoto out_dmamap_err;\r\ndma_nents = ib_dma_map_sg(ia->ri_device,\r\nmw->mw_sg, mw->mw_nents, mw->mw_dir);\r\nif (!dma_nents)\r\ngoto out_dmamap_err;\r\nn = ib_map_mr_sg(mr, mw->mw_sg, mw->mw_nents, NULL, PAGE_SIZE);\r\nif (unlikely(n != mw->mw_nents))\r\ngoto out_mapmr_err;\r\ndprintk("RPC: %s: Using frmr %p to map %u segments (%u bytes)\n",\r\n__func__, frmr, mw->mw_nents, mr->length);\r\nkey = (u8)(mr->rkey & 0x000000FF);\r\nib_update_fast_reg_key(mr, ++key);\r\nreg_wr->wr.next = NULL;\r\nreg_wr->wr.opcode = IB_WR_REG_MR;\r\nfrmr->fr_cqe.done = frwr_wc_fastreg;\r\nreg_wr->wr.wr_cqe = &frmr->fr_cqe;\r\nreg_wr->wr.num_sge = 0;\r\nreg_wr->wr.send_flags = 0;\r\nreg_wr->mr = mr;\r\nreg_wr->key = mr->rkey;\r\nreg_wr->access = writing ?\r\nIB_ACCESS_REMOTE_WRITE | IB_ACCESS_LOCAL_WRITE :\r\nIB_ACCESS_REMOTE_READ;\r\nrpcrdma_set_signaled(&r_xprt->rx_ep, &reg_wr->wr);\r\nrc = ib_post_send(ia->ri_id->qp, &reg_wr->wr, &bad_wr);\r\nif (rc)\r\ngoto out_senderr;\r\nmw->mw_handle = mr->rkey;\r\nmw->mw_length = mr->length;\r\nmw->mw_offset = mr->iova;\r\n*out = mw;\r\nreturn mw->mw_nents;\r\nout_dmamap_err:\r\npr_err("rpcrdma: failed to dma map sg %p sg_nents %u\n",\r\nmw->mw_sg, mw->mw_nents);\r\nrpcrdma_defer_mr_recovery(mw);\r\nreturn -EIO;\r\nout_mapmr_err:\r\npr_err("rpcrdma: failed to map mr %p (%u/%u)\n",\r\nfrmr->fr_mr, n, mw->mw_nents);\r\nrpcrdma_defer_mr_recovery(mw);\r\nreturn -EIO;\r\nout_senderr:\r\npr_err("rpcrdma: FRMR registration ib_post_send returned %i\n", rc);\r\nrpcrdma_defer_mr_recovery(mw);\r\nreturn -ENOTCONN;\r\n}\r\nstatic void\r\nfrwr_op_unmap_sync(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req)\r\n{\r\nstruct ib_send_wr *first, **prev, *last, *bad_wr;\r\nstruct rpcrdma_rep *rep = req->rl_reply;\r\nstruct rpcrdma_ia *ia = &r_xprt->rx_ia;\r\nstruct rpcrdma_frmr *f;\r\nstruct rpcrdma_mw *mw;\r\nint count, rc;\r\ndprintk("RPC: %s: req %p\n", __func__, req);\r\nf = NULL;\r\ncount = 0;\r\nprev = &first;\r\nlist_for_each_entry(mw, &req->rl_registered, mw_list) {\r\nmw->frmr.fr_state = FRMR_IS_INVALID;\r\nif ((rep->rr_wc_flags & IB_WC_WITH_INVALIDATE) &&\r\n(mw->mw_handle == rep->rr_inv_rkey))\r\ncontinue;\r\nf = &mw->frmr;\r\ndprintk("RPC: %s: invalidating frmr %p\n",\r\n__func__, f);\r\nf->fr_cqe.done = frwr_wc_localinv;\r\nlast = &f->fr_invwr;\r\nmemset(last, 0, sizeof(*last));\r\nlast->wr_cqe = &f->fr_cqe;\r\nlast->opcode = IB_WR_LOCAL_INV;\r\nlast->ex.invalidate_rkey = mw->mw_handle;\r\ncount++;\r\n*prev = last;\r\nprev = &last->next;\r\n}\r\nif (!f)\r\ngoto unmap;\r\nlast->send_flags = IB_SEND_SIGNALED;\r\nf->fr_cqe.done = frwr_wc_localinv_wake;\r\nreinit_completion(&f->fr_linv_done);\r\nrpcrdma_init_cqcount(&r_xprt->rx_ep, count);\r\nr_xprt->rx_stats.local_inv_needed++;\r\nrc = ib_post_send(ia->ri_id->qp, first, &bad_wr);\r\nif (rc)\r\ngoto reset_mrs;\r\nwait_for_completion(&f->fr_linv_done);\r\nunmap:\r\nwhile (!list_empty(&req->rl_registered)) {\r\nmw = rpcrdma_pop_mw(&req->rl_registered);\r\ndprintk("RPC: %s: DMA unmapping frmr %p\n",\r\n__func__, &mw->frmr);\r\nib_dma_unmap_sg(ia->ri_device,\r\nmw->mw_sg, mw->mw_nents, mw->mw_dir);\r\nrpcrdma_put_mw(r_xprt, mw);\r\n}\r\nreturn;\r\nreset_mrs:\r\npr_err("rpcrdma: FRMR invalidate ib_post_send returned %i\n", rc);\r\nrdma_disconnect(ia->ri_id);\r\nlist_for_each_entry(mw, &req->rl_registered, mw_list) {\r\nf = &mw->frmr;\r\nif (mw->mw_handle == bad_wr->ex.invalidate_rkey) {\r\n__frwr_reset_mr(ia, mw);\r\nbad_wr = bad_wr->next;\r\n}\r\n}\r\ngoto unmap;\r\n}\r\nstatic void\r\nfrwr_op_unmap_safe(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req,\r\nbool sync)\r\n{\r\nstruct rpcrdma_mw *mw;\r\nwhile (!list_empty(&req->rl_registered)) {\r\nmw = rpcrdma_pop_mw(&req->rl_registered);\r\nif (sync)\r\nfrwr_op_recover_mr(mw);\r\nelse\r\nrpcrdma_defer_mr_recovery(mw);\r\n}\r\n}
