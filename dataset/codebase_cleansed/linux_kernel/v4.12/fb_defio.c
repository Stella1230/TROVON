static struct page *fb_deferred_io_page(struct fb_info *info, unsigned long offs)\r\n{\r\nvoid *screen_base = (void __force *) info->screen_base;\r\nstruct page *page;\r\nif (is_vmalloc_addr(screen_base + offs))\r\npage = vmalloc_to_page(screen_base + offs);\r\nelse\r\npage = pfn_to_page((info->fix.smem_start + offs) >> PAGE_SHIFT);\r\nreturn page;\r\n}\r\nstatic int fb_deferred_io_fault(struct vm_fault *vmf)\r\n{\r\nunsigned long offset;\r\nstruct page *page;\r\nstruct fb_info *info = vmf->vma->vm_private_data;\r\noffset = vmf->pgoff << PAGE_SHIFT;\r\nif (offset >= info->fix.smem_len)\r\nreturn VM_FAULT_SIGBUS;\r\npage = fb_deferred_io_page(info, offset);\r\nif (!page)\r\nreturn VM_FAULT_SIGBUS;\r\nget_page(page);\r\nif (vmf->vma->vm_file)\r\npage->mapping = vmf->vma->vm_file->f_mapping;\r\nelse\r\nprintk(KERN_ERR "no mapping available\n");\r\nBUG_ON(!page->mapping);\r\npage->index = vmf->pgoff;\r\nvmf->page = page;\r\nreturn 0;\r\n}\r\nint fb_deferred_io_fsync(struct file *file, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct fb_info *info = file->private_data;\r\nstruct inode *inode = file_inode(file);\r\nint err = filemap_write_and_wait_range(inode->i_mapping, start, end);\r\nif (err)\r\nreturn err;\r\nif (!info->fbdefio)\r\nreturn 0;\r\ninode_lock(inode);\r\ncancel_delayed_work_sync(&info->deferred_work);\r\nschedule_delayed_work(&info->deferred_work, 0);\r\ninode_unlock(inode);\r\nreturn 0;\r\n}\r\nstatic int fb_deferred_io_mkwrite(struct vm_fault *vmf)\r\n{\r\nstruct page *page = vmf->page;\r\nstruct fb_info *info = vmf->vma->vm_private_data;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nstruct page *cur;\r\nfile_update_time(vmf->vma->vm_file);\r\nmutex_lock(&fbdefio->lock);\r\nif (fbdefio->first_io && list_empty(&fbdefio->pagelist))\r\nfbdefio->first_io(info);\r\nlock_page(page);\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nif (unlikely(cur == page))\r\ngoto page_already_added;\r\nelse if (cur->index > page->index)\r\nbreak;\r\n}\r\nlist_add_tail(&page->lru, &cur->lru);\r\npage_already_added:\r\nmutex_unlock(&fbdefio->lock);\r\nschedule_delayed_work(&info->deferred_work, fbdefio->delay);\r\nreturn VM_FAULT_LOCKED;\r\n}\r\nstatic int fb_deferred_io_set_page_dirty(struct page *page)\r\n{\r\nif (!PageDirty(page))\r\nSetPageDirty(page);\r\nreturn 0;\r\n}\r\nint fb_deferred_io_mmap(struct fb_info *info, struct vm_area_struct *vma)\r\n{\r\nvma->vm_ops = &fb_deferred_io_vm_ops;\r\nvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\r\nif (!(info->flags & FBINFO_VIRTFB))\r\nvma->vm_flags |= VM_IO;\r\nvma->vm_private_data = info;\r\nreturn 0;\r\n}\r\nstatic void fb_deferred_io_work(struct work_struct *work)\r\n{\r\nstruct fb_info *info = container_of(work, struct fb_info,\r\ndeferred_work.work);\r\nstruct list_head *node, *next;\r\nstruct page *cur;\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nmutex_lock(&fbdefio->lock);\r\nlist_for_each_entry(cur, &fbdefio->pagelist, lru) {\r\nlock_page(cur);\r\npage_mkclean(cur);\r\nunlock_page(cur);\r\n}\r\nfbdefio->deferred_io(info, &fbdefio->pagelist);\r\nlist_for_each_safe(node, next, &fbdefio->pagelist) {\r\nlist_del(node);\r\n}\r\nmutex_unlock(&fbdefio->lock);\r\n}\r\nvoid fb_deferred_io_init(struct fb_info *info)\r\n{\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nBUG_ON(!fbdefio);\r\nmutex_init(&fbdefio->lock);\r\ninfo->fbops->fb_mmap = fb_deferred_io_mmap;\r\nINIT_DELAYED_WORK(&info->deferred_work, fb_deferred_io_work);\r\nINIT_LIST_HEAD(&fbdefio->pagelist);\r\nif (fbdefio->delay == 0)\r\nfbdefio->delay = HZ;\r\n}\r\nvoid fb_deferred_io_open(struct fb_info *info,\r\nstruct inode *inode,\r\nstruct file *file)\r\n{\r\nfile->f_mapping->a_ops = &fb_deferred_io_aops;\r\n}\r\nvoid fb_deferred_io_cleanup(struct fb_info *info)\r\n{\r\nstruct fb_deferred_io *fbdefio = info->fbdefio;\r\nstruct page *page;\r\nint i;\r\nBUG_ON(!fbdefio);\r\ncancel_delayed_work_sync(&info->deferred_work);\r\nfor (i = 0 ; i < info->fix.smem_len; i += PAGE_SIZE) {\r\npage = fb_deferred_io_page(info, i);\r\npage->mapping = NULL;\r\n}\r\ninfo->fbops->fb_mmap = NULL;\r\nmutex_destroy(&fbdefio->lock);\r\n}
