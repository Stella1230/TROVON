static void ccu_mp_find_best(unsigned long parent, unsigned long rate,\r\nunsigned int max_m, unsigned int max_p,\r\nunsigned int *m, unsigned int *p)\r\n{\r\nunsigned long best_rate = 0;\r\nunsigned int best_m = 0, best_p = 0;\r\nunsigned int _m, _p;\r\nfor (_p = 1; _p <= max_p; _p <<= 1) {\r\nfor (_m = 1; _m <= max_m; _m++) {\r\nunsigned long tmp_rate = parent / _p / _m;\r\nif (tmp_rate > rate)\r\ncontinue;\r\nif ((rate - tmp_rate) < (rate - best_rate)) {\r\nbest_rate = tmp_rate;\r\nbest_m = _m;\r\nbest_p = _p;\r\n}\r\n}\r\n}\r\n*m = best_m;\r\n*p = best_p;\r\n}\r\nstatic unsigned long ccu_mp_round_rate(struct ccu_mux_internal *mux,\r\nunsigned long parent_rate,\r\nunsigned long rate,\r\nvoid *data)\r\n{\r\nstruct ccu_mp *cmp = data;\r\nunsigned int max_m, max_p;\r\nunsigned int m, p;\r\nmax_m = cmp->m.max ?: 1 << cmp->m.width;\r\nmax_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);\r\nccu_mp_find_best(parent_rate, rate, max_m, max_p, &m, &p);\r\nreturn parent_rate / p / m;\r\n}\r\nstatic void ccu_mp_disable(struct clk_hw *hw)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nreturn ccu_gate_helper_disable(&cmp->common, cmp->enable);\r\n}\r\nstatic int ccu_mp_enable(struct clk_hw *hw)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nreturn ccu_gate_helper_enable(&cmp->common, cmp->enable);\r\n}\r\nstatic int ccu_mp_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nreturn ccu_gate_helper_is_enabled(&cmp->common, cmp->enable);\r\n}\r\nstatic unsigned long ccu_mp_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nunsigned int m, p;\r\nu32 reg;\r\nccu_mux_helper_adjust_parent_for_prediv(&cmp->common, &cmp->mux,\r\n-1, &parent_rate);\r\nreg = readl(cmp->common.base + cmp->common.reg);\r\nm = reg >> cmp->m.shift;\r\nm &= (1 << cmp->m.width) - 1;\r\nm += cmp->m.offset;\r\nif (!m)\r\nm++;\r\np = reg >> cmp->p.shift;\r\np &= (1 << cmp->p.width) - 1;\r\nreturn (parent_rate >> p) / m;\r\n}\r\nstatic int ccu_mp_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nreturn ccu_mux_helper_determine_rate(&cmp->common, &cmp->mux,\r\nreq, ccu_mp_round_rate, cmp);\r\n}\r\nstatic int ccu_mp_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nunsigned long flags;\r\nunsigned int max_m, max_p;\r\nunsigned int m, p;\r\nu32 reg;\r\nccu_mux_helper_adjust_parent_for_prediv(&cmp->common, &cmp->mux,\r\n-1, &parent_rate);\r\nmax_m = cmp->m.max ?: 1 << cmp->m.width;\r\nmax_p = cmp->p.max ?: 1 << ((1 << cmp->p.width) - 1);\r\nccu_mp_find_best(parent_rate, rate, max_m, max_p, &m, &p);\r\nspin_lock_irqsave(cmp->common.lock, flags);\r\nreg = readl(cmp->common.base + cmp->common.reg);\r\nreg &= ~GENMASK(cmp->m.width + cmp->m.shift - 1, cmp->m.shift);\r\nreg &= ~GENMASK(cmp->p.width + cmp->p.shift - 1, cmp->p.shift);\r\nreg |= (m - cmp->m.offset) << cmp->m.shift;\r\nreg |= ilog2(p) << cmp->p.shift;\r\nwritel(reg, cmp->common.base + cmp->common.reg);\r\nspin_unlock_irqrestore(cmp->common.lock, flags);\r\nreturn 0;\r\n}\r\nstatic u8 ccu_mp_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nreturn ccu_mux_helper_get_parent(&cmp->common, &cmp->mux);\r\n}\r\nstatic int ccu_mp_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct ccu_mp *cmp = hw_to_ccu_mp(hw);\r\nreturn ccu_mux_helper_set_parent(&cmp->common, &cmp->mux, index);\r\n}
