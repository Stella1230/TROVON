static int hw_rule_rate(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *r =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);\r\nconst struct snd_interval *c =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1,\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < SND_DG00X_RATE_COUNT; i++) {\r\nif (!snd_interval_test(c,\r\nsnd_dg00x_stream_pcm_channels[i]))\r\ncontinue;\r\nt.min = min(t.min, snd_dg00x_stream_rates[i]);\r\nt.max = max(t.max, snd_dg00x_stream_rates[i]);\r\n}\r\nreturn snd_interval_refine(r, &t);\r\n}\r\nstatic int hw_rule_channels(struct snd_pcm_hw_params *params,\r\nstruct snd_pcm_hw_rule *rule)\r\n{\r\nstruct snd_interval *c =\r\nhw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);\r\nconst struct snd_interval *r =\r\nhw_param_interval_c(params, SNDRV_PCM_HW_PARAM_RATE);\r\nstruct snd_interval t = {\r\n.min = UINT_MAX, .max = 0, .integer = 1,\r\n};\r\nunsigned int i;\r\nfor (i = 0; i < SND_DG00X_RATE_COUNT; i++) {\r\nif (!snd_interval_test(r, snd_dg00x_stream_rates[i]))\r\ncontinue;\r\nt.min = min(t.min, snd_dg00x_stream_pcm_channels[i]);\r\nt.max = max(t.max, snd_dg00x_stream_pcm_channels[i]);\r\n}\r\nreturn snd_interval_refine(c, &t);\r\n}\r\nstatic int pcm_init_hw_params(struct snd_dg00x *dg00x,\r\nstruct snd_pcm_substream *substream)\r\n{\r\nstatic const struct snd_pcm_hardware hardware = {\r\n.info = SNDRV_PCM_INFO_BATCH |\r\nSNDRV_PCM_INFO_BLOCK_TRANSFER |\r\nSNDRV_PCM_INFO_INTERLEAVED |\r\nSNDRV_PCM_INFO_JOINT_DUPLEX |\r\nSNDRV_PCM_INFO_MMAP |\r\nSNDRV_PCM_INFO_MMAP_VALID,\r\n.rates = SNDRV_PCM_RATE_44100 |\r\nSNDRV_PCM_RATE_48000 |\r\nSNDRV_PCM_RATE_88200 |\r\nSNDRV_PCM_RATE_96000,\r\n.rate_min = 44100,\r\n.rate_max = 96000,\r\n.channels_min = 10,\r\n.channels_max = 18,\r\n.period_bytes_min = 4 * 18,\r\n.period_bytes_max = 4 * 18 * 2048,\r\n.buffer_bytes_max = 4 * 18 * 2048 * 2,\r\n.periods_min = 2,\r\n.periods_max = UINT_MAX,\r\n};\r\nstruct amdtp_stream *s;\r\nint err;\r\nsubstream->runtime->hw = hardware;\r\nif (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {\r\nsubstream->runtime->hw.formats = SNDRV_PCM_FMTBIT_S32;\r\ns = &dg00x->tx_stream;\r\n} else {\r\nsubstream->runtime->hw.formats = SNDRV_PCM_FMTBIT_S16 |\r\nSNDRV_PCM_FMTBIT_S32;\r\ns = &dg00x->rx_stream;\r\n}\r\nerr = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_CHANNELS,\r\nhw_rule_channels, NULL,\r\nSNDRV_PCM_HW_PARAM_RATE, -1);\r\nif (err < 0)\r\nreturn err;\r\nerr = snd_pcm_hw_rule_add(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\nhw_rule_rate, NULL,\r\nSNDRV_PCM_HW_PARAM_CHANNELS, -1);\r\nif (err < 0)\r\nreturn err;\r\nreturn amdtp_dot_add_pcm_hw_constraints(s, substream->runtime);\r\n}\r\nstatic int pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nenum snd_dg00x_clock clock;\r\nbool detect;\r\nunsigned int rate;\r\nint err;\r\nerr = snd_dg00x_stream_lock_try(dg00x);\r\nif (err < 0)\r\ngoto end;\r\nerr = pcm_init_hw_params(dg00x, substream);\r\nif (err < 0)\r\ngoto err_locked;\r\nerr = snd_dg00x_stream_get_clock(dg00x, &clock);\r\nif (err < 0)\r\ngoto err_locked;\r\nif (clock != SND_DG00X_CLOCK_INTERNAL) {\r\nerr = snd_dg00x_stream_check_external_clock(dg00x, &detect);\r\nif (err < 0)\r\ngoto err_locked;\r\nif (!detect) {\r\nerr = -EBUSY;\r\ngoto err_locked;\r\n}\r\n}\r\nif ((clock != SND_DG00X_CLOCK_INTERNAL) ||\r\namdtp_stream_pcm_running(&dg00x->rx_stream) ||\r\namdtp_stream_pcm_running(&dg00x->tx_stream)) {\r\nerr = snd_dg00x_stream_get_external_rate(dg00x, &rate);\r\nif (err < 0)\r\ngoto err_locked;\r\nsubstream->runtime->hw.rate_min = rate;\r\nsubstream->runtime->hw.rate_max = rate;\r\n}\r\nsnd_pcm_set_sync(substream);\r\nend:\r\nreturn err;\r\nerr_locked:\r\nsnd_dg00x_stream_lock_release(dg00x);\r\nreturn err;\r\n}\r\nstatic int pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nsnd_dg00x_stream_lock_release(dg00x);\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&dg00x->mutex);\r\ndg00x->substreams_counter++;\r\nmutex_unlock(&dg00x->mutex);\r\n}\r\namdtp_dot_set_pcm_format(&dg00x->tx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nint err;\r\nerr = snd_pcm_lib_alloc_vmalloc_buffer(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err < 0)\r\nreturn err;\r\nif (substream->runtime->status->state == SNDRV_PCM_STATE_OPEN) {\r\nmutex_lock(&dg00x->mutex);\r\ndg00x->substreams_counter++;\r\nmutex_unlock(&dg00x->mutex);\r\n}\r\namdtp_dot_set_pcm_format(&dg00x->rx_stream, params_format(hw_params));\r\nreturn 0;\r\n}\r\nstatic int pcm_capture_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nmutex_lock(&dg00x->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ndg00x->substreams_counter--;\r\nsnd_dg00x_stream_stop_duplex(dg00x);\r\nmutex_unlock(&dg00x->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_playback_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nmutex_lock(&dg00x->mutex);\r\nif (substream->runtime->status->state != SNDRV_PCM_STATE_OPEN)\r\ndg00x->substreams_counter--;\r\nsnd_dg00x_stream_stop_duplex(dg00x);\r\nmutex_unlock(&dg00x->mutex);\r\nreturn snd_pcm_lib_free_vmalloc_buffer(substream);\r\n}\r\nstatic int pcm_capture_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nmutex_lock(&dg00x->mutex);\r\nerr = snd_dg00x_stream_start_duplex(dg00x, runtime->rate);\r\nif (err >= 0)\r\namdtp_stream_pcm_prepare(&dg00x->tx_stream);\r\nmutex_unlock(&dg00x->mutex);\r\nreturn err;\r\n}\r\nstatic int pcm_playback_prepare(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nint err;\r\nmutex_lock(&dg00x->mutex);\r\nerr = snd_dg00x_stream_start_duplex(dg00x, runtime->rate);\r\nif (err >= 0) {\r\namdtp_stream_pcm_prepare(&dg00x->rx_stream);\r\namdtp_dot_reset(&dg00x->rx_stream);\r\n}\r\nmutex_unlock(&dg00x->mutex);\r\nreturn err;\r\n}\r\nstatic int pcm_capture_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&dg00x->tx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&dg00x->tx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pcm_playback_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_dg00x *dg00x = substream->private_data;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\namdtp_stream_pcm_trigger(&dg00x->rx_stream, substream);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\namdtp_stream_pcm_trigger(&dg00x->rx_stream, NULL);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic snd_pcm_uframes_t pcm_capture_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_dg00x *dg00x = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&dg00x->tx_stream);\r\n}\r\nstatic snd_pcm_uframes_t pcm_playback_pointer(struct snd_pcm_substream *sbstrm)\r\n{\r\nstruct snd_dg00x *dg00x = sbstrm->private_data;\r\nreturn amdtp_stream_pcm_pointer(&dg00x->rx_stream);\r\n}\r\nint snd_dg00x_create_pcm_devices(struct snd_dg00x *dg00x)\r\n{\r\nstatic const struct snd_pcm_ops capture_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = pcm_capture_hw_params,\r\n.hw_free = pcm_capture_hw_free,\r\n.prepare = pcm_capture_prepare,\r\n.trigger = pcm_capture_trigger,\r\n.pointer = pcm_capture_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n};\r\nstatic const struct snd_pcm_ops playback_ops = {\r\n.open = pcm_open,\r\n.close = pcm_close,\r\n.ioctl = snd_pcm_lib_ioctl,\r\n.hw_params = pcm_playback_hw_params,\r\n.hw_free = pcm_playback_hw_free,\r\n.prepare = pcm_playback_prepare,\r\n.trigger = pcm_playback_trigger,\r\n.pointer = pcm_playback_pointer,\r\n.page = snd_pcm_lib_get_vmalloc_page,\r\n.mmap = snd_pcm_lib_mmap_vmalloc,\r\n};\r\nstruct snd_pcm *pcm;\r\nint err;\r\nerr = snd_pcm_new(dg00x->card, dg00x->card->driver, 0, 1, 1, &pcm);\r\nif (err < 0)\r\nreturn err;\r\npcm->private_data = dg00x;\r\nsnprintf(pcm->name, sizeof(pcm->name),\r\n"%s PCM", dg00x->card->shortname);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &playback_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &capture_ops);\r\nreturn 0;\r\n}
