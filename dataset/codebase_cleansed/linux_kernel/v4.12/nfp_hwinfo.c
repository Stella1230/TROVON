static bool nfp_hwinfo_is_updating(struct nfp_hwinfo *hwinfo)\r\n{\r\nreturn le32_to_cpu(hwinfo->version) & NFP_HWINFO_VERSION_UPDATING;\r\n}\r\nstatic int\r\nhwinfo_db_walk(struct nfp_cpp *cpp, struct nfp_hwinfo *hwinfo, u32 size)\r\n{\r\nconst char *key, *val, *end = hwinfo->data + size;\r\nfor (key = hwinfo->data; *key && key < end;\r\nkey = val + strlen(val) + 1) {\r\nval = key + strlen(key) + 1;\r\nif (val >= end) {\r\nnfp_warn(cpp, "Bad HWINFO - overflowing key\n");\r\nreturn -EINVAL;\r\n}\r\nif (val + strlen(val) + 1 > end) {\r\nnfp_warn(cpp, "Bad HWINFO - overflowing value\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nhwinfo_db_validate(struct nfp_cpp *cpp, struct nfp_hwinfo *db, u32 len)\r\n{\r\nu32 size, crc;\r\nsize = le32_to_cpu(db->size);\r\nif (size > len) {\r\nnfp_err(cpp, "Unsupported hwinfo size %u > %u\n", size, len);\r\nreturn -EINVAL;\r\n}\r\nsize -= sizeof(u32);\r\ncrc = crc32_posix(db, size);\r\nif (crc != get_unaligned_le32(db->start + size)) {\r\nnfp_err(cpp, "Corrupt hwinfo table (CRC mismatch), calculated 0x%x, expected 0x%x\n",\r\ncrc, get_unaligned_le32(db->start + size));\r\nreturn -EINVAL;\r\n}\r\nreturn hwinfo_db_walk(cpp, db, size);\r\n}\r\nstatic int hwinfo_try_fetch(struct nfp_cpp *cpp, size_t *cpp_size)\r\n{\r\nstruct nfp_hwinfo *header;\r\nstruct nfp_resource *res;\r\nu64 cpp_addr;\r\nu32 cpp_id;\r\nint err;\r\nu8 *db;\r\nres = nfp_resource_acquire(cpp, NFP_RESOURCE_NFP_HWINFO);\r\nif (!IS_ERR(res)) {\r\ncpp_id = nfp_resource_cpp_id(res);\r\ncpp_addr = nfp_resource_address(res);\r\n*cpp_size = nfp_resource_size(res);\r\nnfp_resource_release(res);\r\nif (*cpp_size < HWINFO_SIZE_MIN)\r\nreturn -ENOENT;\r\n} else if (PTR_ERR(res) == -ENOENT) {\r\ncpp_id = NFP_CPP_ISLAND_ID(NFP_CPP_TARGET_MU,\r\nNFP_CPP_ACTION_RW, 0, 1);\r\ncpp_addr = 0x30000;\r\n*cpp_size = 0x0e000;\r\n} else {\r\nreturn PTR_ERR(res);\r\n}\r\ndb = kmalloc(*cpp_size + 1, GFP_KERNEL);\r\nif (!db)\r\nreturn -ENOMEM;\r\nerr = nfp_cpp_read(cpp, cpp_id, cpp_addr, db, *cpp_size);\r\nif (err != *cpp_size) {\r\nkfree(db);\r\nreturn err < 0 ? err : -EIO;\r\n}\r\nheader = (void *)db;\r\nif (nfp_hwinfo_is_updating(header)) {\r\nkfree(db);\r\nreturn -EBUSY;\r\n}\r\nif (le32_to_cpu(header->version) != NFP_HWINFO_VERSION_2) {\r\nnfp_err(cpp, "Unknown HWInfo version: 0x%08x\n",\r\nle32_to_cpu(header->version));\r\nkfree(db);\r\nreturn -EINVAL;\r\n}\r\ndb[*cpp_size] = '\0';\r\nnfp_hwinfo_cache_set(cpp, db);\r\nreturn 0;\r\n}\r\nstatic int hwinfo_fetch(struct nfp_cpp *cpp, size_t *hwdb_size)\r\n{\r\nconst unsigned long wait_until = jiffies + HWINFO_WAIT * HZ;\r\nint err;\r\nfor (;;) {\r\nconst unsigned long start_time = jiffies;\r\nerr = hwinfo_try_fetch(cpp, hwdb_size);\r\nif (!err)\r\nreturn 0;\r\nerr = msleep_interruptible(100);\r\nif (err || time_after(start_time, wait_until)) {\r\nnfp_err(cpp, "NFP access error\n");\r\nreturn -EIO;\r\n}\r\n}\r\n}\r\nstatic int nfp_hwinfo_load(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_hwinfo *db;\r\nsize_t hwdb_size = 0;\r\nint err;\r\nerr = hwinfo_fetch(cpp, &hwdb_size);\r\nif (err)\r\nreturn err;\r\ndb = nfp_hwinfo_cache(cpp);\r\nerr = hwinfo_db_validate(cpp, db, hwdb_size);\r\nif (err) {\r\nkfree(db);\r\nnfp_hwinfo_cache_set(cpp, NULL);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nconst char *nfp_hwinfo_lookup(struct nfp_cpp *cpp, const char *lookup)\r\n{\r\nconst char *key, *val, *end;\r\nstruct nfp_hwinfo *hwinfo;\r\nint err;\r\nhwinfo = nfp_hwinfo_cache(cpp);\r\nif (!hwinfo) {\r\nerr = nfp_hwinfo_load(cpp);\r\nif (err)\r\nreturn NULL;\r\nhwinfo = nfp_hwinfo_cache(cpp);\r\n}\r\nif (!hwinfo || !lookup)\r\nreturn NULL;\r\nend = hwinfo->data + le32_to_cpu(hwinfo->size) - sizeof(u32);\r\nfor (key = hwinfo->data; *key && key < end;\r\nkey = val + strlen(val) + 1) {\r\nval = key + strlen(key) + 1;\r\nif (strcmp(key, lookup) == 0)\r\nreturn val;\r\n}\r\nreturn NULL;\r\n}
