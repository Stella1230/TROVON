void rxe_mmap_release(struct kref *ref)\r\n{\r\nstruct rxe_mmap_info *ip = container_of(ref,\r\nstruct rxe_mmap_info, ref);\r\nstruct rxe_dev *rxe = to_rdev(ip->context->device);\r\nspin_lock_bh(&rxe->pending_lock);\r\nif (!list_empty(&ip->pending_mmaps))\r\nlist_del(&ip->pending_mmaps);\r\nspin_unlock_bh(&rxe->pending_lock);\r\nvfree(ip->obj);\r\nkfree(ip);\r\n}\r\nstatic void rxe_vma_open(struct vm_area_struct *vma)\r\n{\r\nstruct rxe_mmap_info *ip = vma->vm_private_data;\r\nkref_get(&ip->ref);\r\n}\r\nstatic void rxe_vma_close(struct vm_area_struct *vma)\r\n{\r\nstruct rxe_mmap_info *ip = vma->vm_private_data;\r\nkref_put(&ip->ref, rxe_mmap_release);\r\n}\r\nint rxe_mmap(struct ib_ucontext *context, struct vm_area_struct *vma)\r\n{\r\nstruct rxe_dev *rxe = to_rdev(context->device);\r\nunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\r\nunsigned long size = vma->vm_end - vma->vm_start;\r\nstruct rxe_mmap_info *ip, *pp;\r\nint ret;\r\nspin_lock_bh(&rxe->pending_lock);\r\nlist_for_each_entry_safe(ip, pp, &rxe->pending_mmaps, pending_mmaps) {\r\nif (context != ip->context || (__u64)offset != ip->info.offset)\r\ncontinue;\r\nif (size > ip->info.size) {\r\npr_err("mmap region is larger than the object!\n");\r\nspin_unlock_bh(&rxe->pending_lock);\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\ngoto found_it;\r\n}\r\npr_warn("unable to find pending mmap info\n");\r\nspin_unlock_bh(&rxe->pending_lock);\r\nret = -EINVAL;\r\ngoto done;\r\nfound_it:\r\nlist_del_init(&ip->pending_mmaps);\r\nspin_unlock_bh(&rxe->pending_lock);\r\nret = remap_vmalloc_range(vma, ip->obj, 0);\r\nif (ret) {\r\npr_err("err %d from remap_vmalloc_range\n", ret);\r\ngoto done;\r\n}\r\nvma->vm_ops = &rxe_vm_ops;\r\nvma->vm_private_data = ip;\r\nrxe_vma_open(vma);\r\ndone:\r\nreturn ret;\r\n}\r\nstruct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *rxe,\r\nu32 size,\r\nstruct ib_ucontext *context,\r\nvoid *obj)\r\n{\r\nstruct rxe_mmap_info *ip;\r\nip = kmalloc(sizeof(*ip), GFP_KERNEL);\r\nif (!ip)\r\nreturn NULL;\r\nsize = PAGE_ALIGN(size);\r\nspin_lock_bh(&rxe->mmap_offset_lock);\r\nif (rxe->mmap_offset == 0)\r\nrxe->mmap_offset = ALIGN(PAGE_SIZE, SHMLBA);\r\nip->info.offset = rxe->mmap_offset;\r\nrxe->mmap_offset += ALIGN(size, SHMLBA);\r\nspin_unlock_bh(&rxe->mmap_offset_lock);\r\nINIT_LIST_HEAD(&ip->pending_mmaps);\r\nip->info.size = size;\r\nip->context = context;\r\nip->obj = obj;\r\nkref_init(&ip->ref);\r\nreturn ip;\r\n}
