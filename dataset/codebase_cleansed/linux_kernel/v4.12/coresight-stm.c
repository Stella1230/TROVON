static void stm_hwevent_enable_hw(struct stm_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(drvdata->stmhebsr, drvdata->base + STMHEBSR);\r\nwritel_relaxed(drvdata->stmheter, drvdata->base + STMHETER);\r\nwritel_relaxed(drvdata->stmheer, drvdata->base + STMHEER);\r\nwritel_relaxed(0x01 |\r\n0x04,\r\ndrvdata->base + STMHEMCR);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void stm_port_enable_hw(struct stm_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(0x10,\r\ndrvdata->base + STMSPTRIGCSR);\r\nwritel_relaxed(drvdata->stmspscr, drvdata->base + STMSPSCR);\r\nwritel_relaxed(drvdata->stmsper, drvdata->base + STMSPER);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void stm_enable_hw(struct stm_drvdata *drvdata)\r\n{\r\nif (drvdata->stmheer)\r\nstm_hwevent_enable_hw(drvdata);\r\nstm_port_enable_hw(drvdata);\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(0xFFF, drvdata->base + STMSYNCR);\r\nwritel_relaxed((drvdata->traceid << 16 |\r\n0x02 |\r\n0x01),\r\ndrvdata->base + STMTCSR);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic int stm_enable(struct coresight_device *csdev,\r\nstruct perf_event *event, u32 mode)\r\n{\r\nu32 val;\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (mode != CS_MODE_SYSFS)\r\nreturn -EINVAL;\r\nval = local_cmpxchg(&drvdata->mode, CS_MODE_DISABLED, mode);\r\nif (val)\r\nreturn -EBUSY;\r\npm_runtime_get_sync(drvdata->dev);\r\nspin_lock(&drvdata->spinlock);\r\nstm_enable_hw(drvdata);\r\nspin_unlock(&drvdata->spinlock);\r\ndev_info(drvdata->dev, "STM tracing enabled\n");\r\nreturn 0;\r\n}\r\nstatic void stm_hwevent_disable_hw(struct stm_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(0x0, drvdata->base + STMHEMCR);\r\nwritel_relaxed(0x0, drvdata->base + STMHEER);\r\nwritel_relaxed(0x0, drvdata->base + STMHETER);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void stm_port_disable_hw(struct stm_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(0x0, drvdata->base + STMSPER);\r\nwritel_relaxed(0x0, drvdata->base + STMSPTRIGCSR);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void stm_disable_hw(struct stm_drvdata *drvdata)\r\n{\r\nu32 val;\r\nCS_UNLOCK(drvdata->base);\r\nval = readl_relaxed(drvdata->base + STMTCSR);\r\nval &= ~0x1;\r\nwritel_relaxed(val, drvdata->base + STMTCSR);\r\nCS_LOCK(drvdata->base);\r\nstm_port_disable_hw(drvdata);\r\nif (drvdata->stmheer)\r\nstm_hwevent_disable_hw(drvdata);\r\n}\r\nstatic void stm_disable(struct coresight_device *csdev,\r\nstruct perf_event *event)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (local_read(&drvdata->mode) == CS_MODE_SYSFS) {\r\nspin_lock(&drvdata->spinlock);\r\nstm_disable_hw(drvdata);\r\nspin_unlock(&drvdata->spinlock);\r\ncoresight_timeout(drvdata, STMTCSR, STMTCSR_BUSY_BIT, 0);\r\npm_runtime_put(drvdata->dev);\r\nlocal_set(&drvdata->mode, CS_MODE_DISABLED);\r\ndev_info(drvdata->dev, "STM tracing disabled\n");\r\n}\r\n}\r\nstatic int stm_trace_id(struct coresight_device *csdev)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn drvdata->traceid;\r\n}\r\nstatic inline bool stm_addr_unaligned(const void *addr, u8 write_bytes)\r\n{\r\nreturn ((unsigned long)addr & (write_bytes - 1));\r\n}\r\nstatic void stm_send(void *addr, const void *data, u32 size, u8 write_bytes)\r\n{\r\nu8 paload[8];\r\nif (stm_addr_unaligned(data, write_bytes)) {\r\nmemcpy(paload, data, size);\r\ndata = paload;\r\n}\r\nswitch (size) {\r\n#ifdef CONFIG_64BIT\r\ncase 8:\r\nwriteq_relaxed(*(u64 *)data, addr);\r\nbreak;\r\n#endif\r\ncase 4:\r\nwritel_relaxed(*(u32 *)data, addr);\r\nbreak;\r\ncase 2:\r\nwritew_relaxed(*(u16 *)data, addr);\r\nbreak;\r\ncase 1:\r\nwriteb_relaxed(*(u8 *)data, addr);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int stm_generic_link(struct stm_data *stm_data,\r\nunsigned int master, unsigned int channel)\r\n{\r\nstruct stm_drvdata *drvdata = container_of(stm_data,\r\nstruct stm_drvdata, stm);\r\nif (!drvdata || !drvdata->csdev)\r\nreturn -EINVAL;\r\nreturn coresight_enable(drvdata->csdev);\r\n}\r\nstatic void stm_generic_unlink(struct stm_data *stm_data,\r\nunsigned int master, unsigned int channel)\r\n{\r\nstruct stm_drvdata *drvdata = container_of(stm_data,\r\nstruct stm_drvdata, stm);\r\nif (!drvdata || !drvdata->csdev)\r\nreturn;\r\ncoresight_disable(drvdata->csdev);\r\n}\r\nstatic phys_addr_t\r\nstm_mmio_addr(struct stm_data *stm_data, unsigned int master,\r\nunsigned int channel, unsigned int nr_chans)\r\n{\r\nstruct stm_drvdata *drvdata = container_of(stm_data,\r\nstruct stm_drvdata, stm);\r\nphys_addr_t addr;\r\naddr = drvdata->chs.phys + channel * BYTES_PER_CHANNEL;\r\nif (offset_in_page(addr) ||\r\noffset_in_page(nr_chans * BYTES_PER_CHANNEL))\r\nreturn 0;\r\nreturn addr;\r\n}\r\nstatic long stm_generic_set_options(struct stm_data *stm_data,\r\nunsigned int master,\r\nunsigned int channel,\r\nunsigned int nr_chans,\r\nunsigned long options)\r\n{\r\nstruct stm_drvdata *drvdata = container_of(stm_data,\r\nstruct stm_drvdata, stm);\r\nif (!(drvdata && local_read(&drvdata->mode)))\r\nreturn -EINVAL;\r\nif (channel >= drvdata->numsp)\r\nreturn -EINVAL;\r\nswitch (options) {\r\ncase STM_OPTION_GUARANTEED:\r\nset_bit(channel, drvdata->chs.guaranteed);\r\nbreak;\r\ncase STM_OPTION_INVARIANT:\r\nclear_bit(channel, drvdata->chs.guaranteed);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t notrace stm_generic_packet(struct stm_data *stm_data,\r\nunsigned int master,\r\nunsigned int channel,\r\nunsigned int packet,\r\nunsigned int flags,\r\nunsigned int size,\r\nconst unsigned char *payload)\r\n{\r\nunsigned long ch_addr;\r\nstruct stm_drvdata *drvdata = container_of(stm_data,\r\nstruct stm_drvdata, stm);\r\nif (!(drvdata && local_read(&drvdata->mode)))\r\nreturn -EACCES;\r\nif (channel >= drvdata->numsp)\r\nreturn -EINVAL;\r\nch_addr = (unsigned long)stm_channel_addr(drvdata, channel);\r\nflags = (flags == STP_PACKET_TIMESTAMPED) ? STM_FLAG_TIMESTAMPED : 0;\r\nflags |= test_bit(channel, drvdata->chs.guaranteed) ?\r\nSTM_FLAG_GUARANTEED : 0;\r\nif (size > drvdata->write_bytes)\r\nsize = drvdata->write_bytes;\r\nelse\r\nsize = rounddown_pow_of_two(size);\r\nswitch (packet) {\r\ncase STP_PACKET_FLAG:\r\nch_addr |= stm_channel_off(STM_PKT_TYPE_FLAG, flags);\r\nstm_send((void *)ch_addr, payload, 1, drvdata->write_bytes);\r\nsize = 1;\r\nbreak;\r\ncase STP_PACKET_DATA:\r\nch_addr |= stm_channel_off(STM_PKT_TYPE_DATA, flags);\r\nstm_send((void *)ch_addr, payload, size,\r\ndrvdata->write_bytes);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn size;\r\n}\r\nstatic ssize_t hwevent_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val = drvdata->stmheer;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t hwevent_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val;\r\nint ret = 0;\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn -EINVAL;\r\ndrvdata->stmheer = val;\r\ndrvdata->stmheter = val;\r\nreturn size;\r\n}\r\nstatic ssize_t hwevent_select_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val = drvdata->stmhebsr;\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t hwevent_select_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val;\r\nint ret = 0;\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn -EINVAL;\r\ndrvdata->stmhebsr = val;\r\nreturn size;\r\n}\r\nstatic ssize_t port_select_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val;\r\nif (!local_read(&drvdata->mode)) {\r\nval = drvdata->stmspscr;\r\n} else {\r\nspin_lock(&drvdata->spinlock);\r\nval = readl_relaxed(drvdata->base + STMSPSCR);\r\nspin_unlock(&drvdata->spinlock);\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t port_select_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val, stmsper;\r\nint ret = 0;\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->stmspscr = val;\r\nif (local_read(&drvdata->mode)) {\r\nCS_UNLOCK(drvdata->base);\r\nstmsper = readl_relaxed(drvdata->base + STMSPER);\r\nwritel_relaxed(0x0, drvdata->base + STMSPER);\r\nwritel_relaxed(drvdata->stmspscr, drvdata->base + STMSPSCR);\r\nwritel_relaxed(stmsper, drvdata->base + STMSPER);\r\nCS_LOCK(drvdata->base);\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t port_enable_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val;\r\nif (!local_read(&drvdata->mode)) {\r\nval = drvdata->stmsper;\r\n} else {\r\nspin_lock(&drvdata->spinlock);\r\nval = readl_relaxed(drvdata->base + STMSPER);\r\nspin_unlock(&drvdata->spinlock);\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%#lx\n", val);\r\n}\r\nstatic ssize_t port_enable_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nunsigned long val;\r\nint ret = 0;\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\nspin_lock(&drvdata->spinlock);\r\ndrvdata->stmsper = val;\r\nif (local_read(&drvdata->mode)) {\r\nCS_UNLOCK(drvdata->base);\r\nwritel_relaxed(drvdata->stmsper, drvdata->base + STMSPER);\r\nCS_LOCK(drvdata->base);\r\n}\r\nspin_unlock(&drvdata->spinlock);\r\nreturn size;\r\n}\r\nstatic ssize_t traceid_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nunsigned long val;\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nval = drvdata->traceid;\r\nreturn sprintf(buf, "%#lx\n", val);\r\n}\r\nstatic ssize_t traceid_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t size)\r\n{\r\nint ret;\r\nunsigned long val;\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev->parent);\r\nret = kstrtoul(buf, 16, &val);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->traceid = val & 0x7f;\r\nreturn size;\r\n}\r\nstatic int stm_get_resource_byname(struct device_node *np,\r\nchar *ch_base, struct resource *res)\r\n{\r\nconst char *name = NULL;\r\nint index = 0, found = 0;\r\nwhile (!of_property_read_string_index(np, "reg-names", index, &name)) {\r\nif (strcmp(ch_base, name)) {\r\nindex++;\r\ncontinue;\r\n}\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found)\r\nreturn -EINVAL;\r\nreturn of_address_to_resource(np, index, res);\r\n}\r\nstatic u32 stm_fundamental_data_size(struct stm_drvdata *drvdata)\r\n{\r\nu32 stmspfeat2r;\r\nif (!IS_ENABLED(CONFIG_64BIT))\r\nreturn 4;\r\nstmspfeat2r = readl_relaxed(drvdata->base + STMSPFEAT2R);\r\nreturn BMVAL(stmspfeat2r, 12, 15) ? 8 : 4;\r\n}\r\nstatic u32 stm_num_stimulus_port(struct stm_drvdata *drvdata)\r\n{\r\nu32 numsp;\r\nnumsp = readl_relaxed(drvdata->base + CORESIGHT_DEVID);\r\nnumsp &= 0x1ffff;\r\nif (!numsp)\r\nnumsp = STM_32_CHANNEL;\r\nreturn numsp;\r\n}\r\nstatic void stm_init_default_data(struct stm_drvdata *drvdata)\r\n{\r\ndrvdata->stmspscr = 0x0;\r\ndrvdata->stmsper = ~0x0;\r\ndrvdata->traceid = 0x1;\r\nbitmap_clear(drvdata->chs.guaranteed, 0, drvdata->numsp);\r\n}\r\nstatic void stm_init_generic_data(struct stm_drvdata *drvdata)\r\n{\r\ndrvdata->stm.name = dev_name(drvdata->dev);\r\ndrvdata->stm.sw_start = 1;\r\ndrvdata->stm.sw_end = 1;\r\ndrvdata->stm.hw_override = true;\r\ndrvdata->stm.sw_nchannels = drvdata->numsp;\r\ndrvdata->stm.sw_mmiosz = BYTES_PER_CHANNEL;\r\ndrvdata->stm.packet = stm_generic_packet;\r\ndrvdata->stm.mmio_addr = stm_mmio_addr;\r\ndrvdata->stm.link = stm_generic_link;\r\ndrvdata->stm.unlink = stm_generic_unlink;\r\ndrvdata->stm.set_options = stm_generic_set_options;\r\n}\r\nstatic int stm_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nunsigned long *guaranteed;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct stm_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct resource ch_res;\r\nsize_t res_size, bitmap_size;\r\nstruct coresight_desc desc = { 0 };\r\nstruct device_node *np = adev->dev.of_node;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\n}\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\ndrvdata->dev = &adev->dev;\r\ndrvdata->atclk = devm_clk_get(&adev->dev, "atclk");\r\nif (!IS_ERR(drvdata->atclk)) {\r\nret = clk_prepare_enable(drvdata->atclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nret = stm_get_resource_byname(np, "stm-stimulus-base", &ch_res);\r\nif (ret)\r\nreturn ret;\r\ndrvdata->chs.phys = ch_res.start;\r\nbase = devm_ioremap_resource(dev, &ch_res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->chs.base = base;\r\ndrvdata->write_bytes = stm_fundamental_data_size(drvdata);\r\nif (boot_nr_channel) {\r\ndrvdata->numsp = boot_nr_channel;\r\nres_size = min((resource_size_t)(boot_nr_channel *\r\nBYTES_PER_CHANNEL), resource_size(res));\r\n} else {\r\ndrvdata->numsp = stm_num_stimulus_port(drvdata);\r\nres_size = min((resource_size_t)(drvdata->numsp *\r\nBYTES_PER_CHANNEL), resource_size(res));\r\n}\r\nbitmap_size = BITS_TO_LONGS(drvdata->numsp) * sizeof(long);\r\nguaranteed = devm_kzalloc(dev, bitmap_size, GFP_KERNEL);\r\nif (!guaranteed)\r\nreturn -ENOMEM;\r\ndrvdata->chs.guaranteed = guaranteed;\r\nspin_lock_init(&drvdata->spinlock);\r\nstm_init_default_data(drvdata);\r\nstm_init_generic_data(drvdata);\r\nif (stm_register_device(dev, &drvdata->stm, THIS_MODULE)) {\r\ndev_info(dev,\r\n"stm_register_device failed, probing deffered\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ndesc.type = CORESIGHT_DEV_TYPE_SOURCE;\r\ndesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_SOFTWARE;\r\ndesc.ops = &stm_cs_ops;\r\ndesc.pdata = pdata;\r\ndesc.dev = dev;\r\ndesc.groups = coresight_stm_groups;\r\ndrvdata->csdev = coresight_register(&desc);\r\nif (IS_ERR(drvdata->csdev)) {\r\nret = PTR_ERR(drvdata->csdev);\r\ngoto stm_unregister;\r\n}\r\npm_runtime_put(&adev->dev);\r\ndev_info(dev, "%s initialized\n", (char *)id->data);\r\nreturn 0;\r\nstm_unregister:\r\nstm_unregister_device(&drvdata->stm);\r\nreturn ret;\r\n}\r\nstatic int stm_runtime_suspend(struct device *dev)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev);\r\nif (drvdata && !IS_ERR(drvdata->atclk))\r\nclk_disable_unprepare(drvdata->atclk);\r\nreturn 0;\r\n}\r\nstatic int stm_runtime_resume(struct device *dev)\r\n{\r\nstruct stm_drvdata *drvdata = dev_get_drvdata(dev);\r\nif (drvdata && !IS_ERR(drvdata->atclk))\r\nclk_prepare_enable(drvdata->atclk);\r\nreturn 0;\r\n}
