static void cvm_callback(u32 status, void *arg)\r\n{\r\nstruct crypto_async_request *req = (struct crypto_async_request *)arg;\r\nreq->complete(req, !status);\r\n}\r\nstatic inline void update_input_iv(struct cpt_request_info *req_info,\r\nu8 *iv, u32 enc_iv_len,\r\nu32 *argcnt)\r\n{\r\nreq_info->in[*argcnt].vptr = (void *)iv;\r\nreq_info->in[*argcnt].size = enc_iv_len;\r\nreq_info->req.dlen += enc_iv_len;\r\n++(*argcnt);\r\n}\r\nstatic inline void update_output_iv(struct cpt_request_info *req_info,\r\nu8 *iv, u32 enc_iv_len,\r\nu32 *argcnt)\r\n{\r\nreq_info->out[*argcnt].vptr = (void *)iv;\r\nreq_info->out[*argcnt].size = enc_iv_len;\r\nreq_info->rlen += enc_iv_len;\r\n++(*argcnt);\r\n}\r\nstatic inline void update_input_data(struct cpt_request_info *req_info,\r\nstruct scatterlist *inp_sg,\r\nu32 nbytes, u32 *argcnt)\r\n{\r\nreq_info->req.dlen += nbytes;\r\nwhile (nbytes) {\r\nu32 len = min(nbytes, inp_sg->length);\r\nu8 *ptr = sg_virt(inp_sg);\r\nreq_info->in[*argcnt].vptr = (void *)ptr;\r\nreq_info->in[*argcnt].size = len;\r\nnbytes -= len;\r\n++(*argcnt);\r\n++inp_sg;\r\n}\r\n}\r\nstatic inline void update_output_data(struct cpt_request_info *req_info,\r\nstruct scatterlist *outp_sg,\r\nu32 nbytes, u32 *argcnt)\r\n{\r\nreq_info->rlen += nbytes;\r\nwhile (nbytes) {\r\nu32 len = min(nbytes, outp_sg->length);\r\nu8 *ptr = sg_virt(outp_sg);\r\nreq_info->out[*argcnt].vptr = (void *)ptr;\r\nreq_info->out[*argcnt].size = len;\r\nnbytes -= len;\r\n++(*argcnt);\r\n++outp_sg;\r\n}\r\n}\r\nstatic inline u32 create_ctx_hdr(struct ablkcipher_request *req, u32 enc,\r\nu32 cipher_type, u32 aes_key_type,\r\nu32 *argcnt)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);\r\nstruct cvm_enc_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nstruct cvm_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nstruct fc_context *fctx = &rctx->fctx;\r\nu64 *offset_control = &rctx->control_word;\r\nu32 enc_iv_len = crypto_ablkcipher_ivsize(tfm);\r\nstruct cpt_request_info *req_info = &rctx->cpt_req;\r\nu64 *ctrl_flags = NULL;\r\nreq_info->ctrl.s.grp = 0;\r\nreq_info->ctrl.s.dma_mode = DMA_GATHER_SCATTER;\r\nreq_info->ctrl.s.se_req = SE_CORE_REQ;\r\nreq_info->req.opcode.s.major = MAJOR_OP_FC |\r\nDMA_MODE_FLAG(DMA_GATHER_SCATTER);\r\nif (enc)\r\nreq_info->req.opcode.s.minor = 2;\r\nelse\r\nreq_info->req.opcode.s.minor = 3;\r\nreq_info->req.param1 = req->nbytes;\r\nreq_info->req.param2 = 0;\r\nfctx->enc.enc_ctrl.e.enc_cipher = cipher_type;\r\nfctx->enc.enc_ctrl.e.aes_key = aes_key_type;\r\nfctx->enc.enc_ctrl.e.iv_source = FROM_DPTR;\r\nif (cipher_type == AES_XTS)\r\nmemcpy(fctx->enc.encr_key, ctx->enc_key, ctx->key_len * 2);\r\nelse\r\nmemcpy(fctx->enc.encr_key, ctx->enc_key, ctx->key_len);\r\nctrl_flags = (u64 *)&fctx->enc.enc_ctrl.flags;\r\n*ctrl_flags = cpu_to_be64(*ctrl_flags);\r\n*offset_control = cpu_to_be64(((u64)(enc_iv_len) << 16));\r\nreq_info->in[*argcnt].vptr = (u8 *)offset_control;\r\nreq_info->in[*argcnt].size = CONTROL_WORD_LEN;\r\nreq_info->req.dlen += CONTROL_WORD_LEN;\r\n++(*argcnt);\r\nreq_info->in[*argcnt].vptr = (u8 *)fctx;\r\nreq_info->in[*argcnt].size = sizeof(struct fc_context);\r\nreq_info->req.dlen += sizeof(struct fc_context);\r\n++(*argcnt);\r\nreturn 0;\r\n}\r\nstatic inline u32 create_input_list(struct ablkcipher_request *req, u32 enc,\r\nu32 cipher_type, u32 aes_key_type,\r\nu32 enc_iv_len)\r\n{\r\nstruct cvm_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nstruct cpt_request_info *req_info = &rctx->cpt_req;\r\nu32 argcnt = 0;\r\ncreate_ctx_hdr(req, enc, cipher_type, aes_key_type, &argcnt);\r\nupdate_input_iv(req_info, req->info, enc_iv_len, &argcnt);\r\nupdate_input_data(req_info, req->src, req->nbytes, &argcnt);\r\nreq_info->incnt = argcnt;\r\nreturn 0;\r\n}\r\nstatic inline void store_cb_info(struct ablkcipher_request *req,\r\nstruct cpt_request_info *req_info)\r\n{\r\nreq_info->callback = (void *)cvm_callback;\r\nreq_info->callback_arg = (void *)&req->base;\r\n}\r\nstatic inline void create_output_list(struct ablkcipher_request *req,\r\nu32 cipher_type,\r\nu32 enc_iv_len)\r\n{\r\nstruct cvm_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nstruct cpt_request_info *req_info = &rctx->cpt_req;\r\nu32 argcnt = 0;\r\nupdate_output_iv(req_info, req->info, enc_iv_len, &argcnt);\r\nupdate_output_data(req_info, req->dst, req->nbytes, &argcnt);\r\nreq_info->outcnt = argcnt;\r\n}\r\nstatic inline int cvm_enc_dec(struct ablkcipher_request *req, u32 enc,\r\nu32 cipher_type)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);\r\nstruct cvm_enc_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nu32 key_type = AES_128_BIT;\r\nstruct cvm_req_ctx *rctx = ablkcipher_request_ctx(req);\r\nu32 enc_iv_len = crypto_ablkcipher_ivsize(tfm);\r\nstruct fc_context *fctx = &rctx->fctx;\r\nstruct cpt_request_info *req_info = &rctx->cpt_req;\r\nvoid *cdev = NULL;\r\nint status;\r\nswitch (ctx->key_len) {\r\ncase 16:\r\nkey_type = AES_128_BIT;\r\nbreak;\r\ncase 24:\r\nkey_type = AES_192_BIT;\r\nbreak;\r\ncase 32:\r\nif (cipher_type == AES_XTS)\r\nkey_type = AES_128_BIT;\r\nelse\r\nkey_type = AES_256_BIT;\r\nbreak;\r\ncase 64:\r\nif (cipher_type == AES_XTS)\r\nkey_type = AES_256_BIT;\r\nelse\r\nreturn -EINVAL;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (cipher_type == DES3_CBC)\r\nkey_type = 0;\r\nmemset(req_info, 0, sizeof(struct cpt_request_info));\r\nmemset(fctx, 0, sizeof(struct fc_context));\r\ncreate_input_list(req, enc, cipher_type, key_type, enc_iv_len);\r\ncreate_output_list(req, cipher_type, enc_iv_len);\r\nstore_cb_info(req, req_info);\r\ncdev = dev_handle.cdev[smp_processor_id()];\r\nstatus = cptvf_do_request(cdev, req_info);\r\nif (status)\r\nreturn status;\r\nelse\r\nreturn -EINPROGRESS;\r\n}\r\nint cvm_des3_encrypt_cbc(struct ablkcipher_request *req)\r\n{\r\nreturn cvm_enc_dec(req, true, DES3_CBC);\r\n}\r\nint cvm_des3_decrypt_cbc(struct ablkcipher_request *req)\r\n{\r\nreturn cvm_enc_dec(req, false, DES3_CBC);\r\n}\r\nint cvm_aes_encrypt_xts(struct ablkcipher_request *req)\r\n{\r\nreturn cvm_enc_dec(req, true, AES_XTS);\r\n}\r\nint cvm_aes_decrypt_xts(struct ablkcipher_request *req)\r\n{\r\nreturn cvm_enc_dec(req, false, AES_XTS);\r\n}\r\nint cvm_aes_encrypt_cbc(struct ablkcipher_request *req)\r\n{\r\nreturn cvm_enc_dec(req, true, AES_CBC);\r\n}\r\nint cvm_aes_decrypt_cbc(struct ablkcipher_request *req)\r\n{\r\nreturn cvm_enc_dec(req, false, AES_CBC);\r\n}\r\nint cvm_xts_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nu32 keylen)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct cvm_enc_ctx *ctx = crypto_tfm_ctx(tfm);\r\nint err;\r\nconst u8 *key1 = key;\r\nconst u8 *key2 = key + (keylen / 2);\r\nerr = xts_check_key(tfm, key, keylen);\r\nif (err)\r\nreturn err;\r\nctx->key_len = keylen;\r\nmemcpy(ctx->enc_key, key1, keylen / 2);\r\nmemcpy(ctx->enc_key + KEY2_OFFSET, key2, keylen / 2);\r\nreturn 0;\r\n}\r\nint cvm_enc_dec_setkey(struct crypto_ablkcipher *cipher, const u8 *key,\r\nu32 keylen)\r\n{\r\nstruct crypto_tfm *tfm = crypto_ablkcipher_tfm(cipher);\r\nstruct cvm_enc_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif ((keylen == 16) || (keylen == 24) || (keylen == 32)) {\r\nctx->key_len = keylen;\r\nmemcpy(ctx->enc_key, key, keylen);\r\nreturn 0;\r\n}\r\ncrypto_ablkcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nint cvm_enc_dec_init(struct crypto_tfm *tfm)\r\n{\r\nstruct cvm_enc_ctx *ctx = crypto_tfm_ctx(tfm);\r\nmemset(ctx, 0, sizeof(*ctx));\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct cvm_req_ctx) +\r\nsizeof(struct ablkcipher_request);\r\nreturn 0;\r\n}\r\nstatic inline int cav_register_algs(void)\r\n{\r\nint err = 0;\r\nerr = crypto_register_algs(algs, ARRAY_SIZE(algs));\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic inline void cav_unregister_algs(void)\r\n{\r\ncrypto_unregister_algs(algs, ARRAY_SIZE(algs));\r\n}\r\nint cvm_crypto_init(struct cpt_vf *cptvf)\r\n{\r\nstruct pci_dev *pdev = cptvf->pdev;\r\nu32 dev_count;\r\ndev_count = dev_handle.dev_count;\r\ndev_handle.cdev[dev_count] = cptvf;\r\ndev_handle.dev_count++;\r\nif (dev_count == 3) {\r\nif (cav_register_algs()) {\r\ndev_err(&pdev->dev, "Error in registering crypto algorithms\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid cvm_crypto_exit(void)\r\n{\r\nu32 dev_count;\r\ndev_count = --dev_handle.dev_count;\r\nif (!dev_count)\r\ncav_unregister_algs();\r\n}
