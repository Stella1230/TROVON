static int msm_hdmi_ddc_read(struct hdmi *hdmi, u16 addr, u8 offset,\r\nu8 *data, u16 data_len)\r\n{\r\nint rc;\r\nint retry = 5;\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = addr >> 1,\r\n.flags = 0,\r\n.len = 1,\r\n.buf = &offset,\r\n}, {\r\n.addr = addr >> 1,\r\n.flags = I2C_M_RD,\r\n.len = data_len,\r\n.buf = data,\r\n}\r\n};\r\nDBG("Start DDC read");\r\nretry:\r\nrc = i2c_transfer(hdmi->i2c, msgs, 2);\r\nretry--;\r\nif (rc == 2)\r\nrc = 0;\r\nelse if (retry > 0)\r\ngoto retry;\r\nelse\r\nrc = -EIO;\r\nDBG("End DDC read %d", rc);\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_ddc_write(struct hdmi *hdmi, u16 addr, u8 offset,\r\nu8 *data, u16 data_len)\r\n{\r\nint rc;\r\nint retry = 10;\r\nu8 buf[HDCP_DDC_WRITE_MAX_BYTE_NUM];\r\nstruct i2c_msg msgs[] = {\r\n{\r\n.addr = addr >> 1,\r\n.flags = 0,\r\n.len = 1,\r\n}\r\n};\r\nDBG("Start DDC write");\r\nif (data_len > (HDCP_DDC_WRITE_MAX_BYTE_NUM - 1)) {\r\npr_err("%s: write size too big\n", __func__);\r\nreturn -ERANGE;\r\n}\r\nbuf[0] = offset;\r\nmemcpy(&buf[1], data, data_len);\r\nmsgs[0].buf = buf;\r\nmsgs[0].len = data_len + 1;\r\nretry:\r\nrc = i2c_transfer(hdmi->i2c, msgs, 1);\r\nretry--;\r\nif (rc == 1)\r\nrc = 0;\r\nelse if (retry > 0)\r\ngoto retry;\r\nelse\r\nrc = -EIO;\r\nDBG("End DDC write %d", rc);\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_scm_wr(struct hdmi_hdcp_ctrl *hdcp_ctrl, u32 *preg,\r\nu32 *pdata, u32 count)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nstruct qcom_scm_hdcp_req scm_buf[QCOM_SCM_HDCP_MAX_REQ_CNT];\r\nu32 resp, phy_addr, idx = 0;\r\nint i, ret = 0;\r\nWARN_ON(!pdata || !preg || (count == 0));\r\nif (hdcp_ctrl->tz_hdcp) {\r\nphy_addr = (u32)hdmi->mmio_phy_addr;\r\nwhile (count) {\r\nmemset(scm_buf, 0, sizeof(scm_buf));\r\nfor (i = 0; i < count && i < QCOM_SCM_HDCP_MAX_REQ_CNT;\r\ni++) {\r\nscm_buf[i].addr = phy_addr + preg[idx];\r\nscm_buf[i].val = pdata[idx];\r\nidx++;\r\n}\r\nret = qcom_scm_hdcp_req(scm_buf, i, &resp);\r\nif (ret || resp) {\r\npr_err("%s: error: scm_call ret=%d resp=%u\n",\r\n__func__, ret, resp);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\ncount -= i;\r\n}\r\n} else {\r\nfor (i = 0; i < count; i++)\r\nhdmi_write(hdmi, preg[i], pdata[i]);\r\n}\r\nreturn ret;\r\n}\r\nvoid msm_hdmi_hdcp_irq(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg_val, hdcp_int_status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_INT_CTRL);\r\nhdcp_int_status = reg_val & HDCP_INT_STATUS_MASK;\r\nif (!hdcp_int_status) {\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nreturn;\r\n}\r\nreg_val |= hdcp_int_status << 1;\r\nif (hdcp_int_status & HDMI_HDCP_INT_CTRL_AUTH_FAIL_INT)\r\nreg_val |= HDMI_HDCP_INT_CTRL_AUTH_FAIL_INFO_ACK;\r\nhdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nDBG("hdcp irq %x", hdcp_int_status);\r\nif (hdcp_int_status & HDMI_HDCP_INT_CTRL_AUTH_SUCCESS_INT) {\r\npr_info("%s:AUTH_SUCCESS_INT received\n", __func__);\r\nif (HDCP_STATE_AUTHENTICATING == hdcp_ctrl->hdcp_state) {\r\nset_bit(AUTH_RESULT_RDY_EV, &hdcp_ctrl->auth_event);\r\nwake_up_all(&hdcp_ctrl->auth_event_queue);\r\n}\r\n}\r\nif (hdcp_int_status & HDMI_HDCP_INT_CTRL_AUTH_FAIL_INT) {\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\r\npr_info("%s: AUTH_FAIL_INT rcvd, LINK0_STATUS=0x%08x\n",\r\n__func__, reg_val);\r\nif (HDCP_STATE_AUTHENTICATED == hdcp_ctrl->hdcp_state)\r\nqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_reauth_work);\r\nelse if (HDCP_STATE_AUTHENTICATING ==\r\nhdcp_ctrl->hdcp_state) {\r\nset_bit(AUTH_RESULT_RDY_EV, &hdcp_ctrl->auth_event);\r\nwake_up_all(&hdcp_ctrl->auth_event_queue);\r\n}\r\n}\r\n}\r\nstatic int msm_hdmi_hdcp_msleep(struct hdmi_hdcp_ctrl *hdcp_ctrl, u32 ms, u32 ev)\r\n{\r\nint rc;\r\nrc = wait_event_timeout(hdcp_ctrl->auth_event_queue,\r\n!!test_bit(ev, &hdcp_ctrl->auth_event),\r\nmsecs_to_jiffies(ms));\r\nif (rc) {\r\npr_info("%s: msleep is canceled by event %d\n",\r\n__func__, ev);\r\nclear_bit(ev, &hdcp_ctrl->auth_event);\r\nreturn -ECANCELED;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_read_validate_aksv(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nhdcp_ctrl->aksv_lsb = hdmi_qfprom_read(hdmi, HDCP_KSV_LSB);\r\nhdcp_ctrl->aksv_msb = hdmi_qfprom_read(hdmi, HDCP_KSV_MSB);\r\nif ((hweight32(hdcp_ctrl->aksv_lsb) + hweight32(hdcp_ctrl->aksv_msb))\r\n!= 20) {\r\npr_err("%s: AKSV QFPROM doesn't have 20 1's, 20 0's\n",\r\n__func__);\r\npr_err("%s: QFPROM AKSV chk failed (AKSV=%02x%08x)\n",\r\n__func__, hdcp_ctrl->aksv_msb,\r\nhdcp_ctrl->aksv_lsb);\r\nreturn -EINVAL;\r\n}\r\nDBG("AKSV=%02x%08x", hdcp_ctrl->aksv_msb, hdcp_ctrl->aksv_lsb);\r\nreturn 0;\r\n}\r\nstatic int msm_reset_hdcp_ddc_failures(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg_val, failure, nack0;\r\nint rc = 0;\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_STATUS);\r\nfailure = reg_val & HDMI_HDCP_DDC_STATUS_FAILED;\r\nnack0 = reg_val & HDMI_HDCP_DDC_STATUS_NACK0;\r\nDBG("HDCP_DDC_STATUS=0x%x, FAIL=%d, NACK0=%d",\r\nreg_val, failure, nack0);\r\nif (failure) {\r\nDBG("DDC failure detected");\r\nhdmi_write(hdmi, REG_HDMI_HDCP_DDC_CTRL_0,\r\nHDMI_HDCP_DDC_CTRL_0_DISABLE);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_CTRL_1);\r\nreg_val |= HDMI_HDCP_DDC_CTRL_1_FAILED_ACK;\r\nhdmi_write(hdmi, REG_HDMI_HDCP_DDC_CTRL_1, reg_val);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_STATUS);\r\nif (reg_val & HDMI_HDCP_DDC_STATUS_FAILED)\r\npr_info("%s: Unable to clear HDCP DDC Failure\n",\r\n__func__);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_DDC_CTRL_0, 0);\r\n}\r\nif (nack0) {\r\nDBG("Before: HDMI_DDC_SW_STATUS=0x%08x",\r\nhdmi_read(hdmi, REG_HDMI_DDC_SW_STATUS));\r\nreg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\r\nreg_val |= HDMI_DDC_CTRL_SW_STATUS_RESET;\r\nhdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\r\nreg_val &= ~HDMI_DDC_CTRL_SW_STATUS_RESET;\r\nhdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\r\nreg_val |= HDMI_DDC_CTRL_SOFT_RESET;\r\nhdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\r\nif (!rc)\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_DDC_CTRL);\r\nreg_val &= ~HDMI_DDC_CTRL_SOFT_RESET;\r\nhdmi_write(hdmi, REG_HDMI_DDC_CTRL, reg_val);\r\nDBG("After: HDMI_DDC_SW_STATUS=0x%08x",\r\nhdmi_read(hdmi, REG_HDMI_DDC_SW_STATUS));\r\n}\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_hw_ddc_clean(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc;\r\nu32 hdcp_ddc_status, ddc_hw_status;\r\nu32 xfer_done, xfer_req, hw_done;\r\nbool hw_not_ready;\r\nu32 timeout_count;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nif (hdmi_read(hdmi, REG_HDMI_DDC_HW_STATUS) == 0)\r\nreturn 0;\r\ntimeout_count = 100;\r\ndo {\r\nhdcp_ddc_status = hdmi_read(hdmi, REG_HDMI_HDCP_DDC_STATUS);\r\nddc_hw_status = hdmi_read(hdmi, REG_HDMI_DDC_HW_STATUS);\r\nxfer_done = hdcp_ddc_status & HDMI_HDCP_DDC_STATUS_XFER_DONE;\r\nxfer_req = hdcp_ddc_status & HDMI_HDCP_DDC_STATUS_XFER_REQ;\r\nhw_done = ddc_hw_status & HDMI_DDC_HW_STATUS_DONE;\r\nhw_not_ready = !xfer_done || xfer_req || !hw_done;\r\nif (hw_not_ready)\r\nbreak;\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_warn("%s: hw_ddc_clean failed\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic void msm_hdmi_hdcp_reauth_work(struct work_struct *work)\r\n{\r\nstruct hdmi_hdcp_ctrl *hdcp_ctrl = container_of(work,\r\nstruct hdmi_hdcp_ctrl, hdcp_reauth_work);\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nunsigned long flags;\r\nu32 reg_val;\r\nDBG("HDCP REAUTH WORK");\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\r\nreg_val &= ~HDMI_HPD_CTRL_ENABLE;\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL, 0);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_RESET,\r\nHDMI_HDCP_RESET_LINK0_DEAUTHENTICATE);\r\nif (msm_hdmi_hdcp_hw_ddc_clean(hdcp_ctrl)) {\r\npr_info("%s: reauth work aborted\n", __func__);\r\nreturn;\r\n}\r\nhdmi_write(hdmi, REG_HDMI_HDCP_CTRL, 0);\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\r\nreg_val |= HDMI_HPD_CTRL_ENABLE;\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nif (++hdcp_ctrl->auth_retries == AUTH_RETRIES_TIME) {\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_INACTIVE;\r\nhdcp_ctrl->auth_retries = 0;\r\npr_info("%s: abort reauthentication!\n", __func__);\r\nreturn;\r\n}\r\nDBG("Queue AUTH WORK");\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_AUTHENTICATING;\r\nqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_auth_work);\r\n}\r\nstatic int msm_hdmi_hdcp_auth_prepare(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 link0_status;\r\nu32 reg_val;\r\nunsigned long flags;\r\nint rc;\r\nif (!hdcp_ctrl->aksv_valid) {\r\nrc = msm_hdmi_hdcp_read_validate_aksv(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: ASKV validation failed\n", __func__);\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_NO_AKSV;\r\nreturn -ENOTSUPP;\r\n}\r\nhdcp_ctrl->aksv_valid = true;\r\n}\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nreg_val &= ~HDMI_CTRL_ENCRYPTED;\r\nhdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_DDC_ARBITRATION);\r\nreg_val &= ~HDMI_DDC_ARBITRATION_HW_ARBITRATION;\r\nhdmi_write(hdmi, REG_HDMI_DDC_ARBITRATION, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_SW_LOWER_AKSV, hdcp_ctrl->aksv_lsb);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_SW_UPPER_AKSV, hdcp_ctrl->aksv_msb);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_ENTROPY_CTRL0, 0xB1FFB0FF);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_ENTROPY_CTRL1, 0xF00DFACE);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_DEBUG_CTRL);\r\nreg_val &= ~HDMI_HDCP_DEBUG_CTRL_RNG_CIPHER;\r\nhdmi_write(hdmi, REG_HDMI_HDCP_DEBUG_CTRL, reg_val);\r\nDBG("HDCP_DEBUG_CTRL=0x%08x",\r\nhdmi_read(hdmi, REG_HDMI_HDCP_DEBUG_CTRL));\r\nwmb();\r\nhdmi_write(hdmi, REG_HDMI_HDCP_CTRL, HDMI_HDCP_CTRL_ENABLE);\r\nlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\r\nDBG("After enabling HDCP Link0_Status=0x%08x", link0_status);\r\nif (!(link0_status &\r\n(HDMI_HDCP_LINK0_STATUS_AN_0_READY |\r\nHDMI_HDCP_LINK0_STATUS_AN_1_READY)))\r\nDBG("An not ready after enabling HDCP");\r\nrc = msm_reset_hdcp_ddc_failures(hdcp_ctrl);\r\nreturn rc;\r\n}\r\nstatic void msm_hdmi_hdcp_auth_fail(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg_val;\r\nunsigned long flags;\r\nDBG("hdcp auth failed, queue reauth work");\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nreg_val &= ~HDMI_CTRL_ENCRYPTED;\r\nhdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_AUTH_FAILED;\r\nqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_reauth_work);\r\n}\r\nstatic void msm_hdmi_hdcp_auth_done(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg_val;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_DDC_ARBITRATION);\r\nreg_val |= HDMI_DDC_ARBITRATION_HW_ARBITRATION;\r\nhdmi_write(hdmi, REG_HDMI_DDC_ARBITRATION, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nreg_val |= HDMI_CTRL_ENCRYPTED;\r\nhdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_AUTHENTICATED;\r\nhdcp_ctrl->auth_retries = 0;\r\n}\r\nstatic int msm_hdmi_hdcp_wait_key_an_ready(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 link0_status, keys_state;\r\nu32 timeout_count;\r\nbool an_ready;\r\ntimeout_count = 100;\r\ndo {\r\nlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\r\nkeys_state = (link0_status >> 28) & 0x7;\r\nif (keys_state == HDCP_KEYS_STATE_VALID)\r\nbreak;\r\nDBG("Keys not ready(%d). s=%d, l0=%0x08x",\r\ntimeout_count, keys_state, link0_status);\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_err("%s: Wait key state timedout", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\ntimeout_count = 100;\r\ndo {\r\nlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\r\nan_ready = (link0_status & HDMI_HDCP_LINK0_STATUS_AN_0_READY)\r\n&& (link0_status & HDMI_HDCP_LINK0_STATUS_AN_1_READY);\r\nif (an_ready)\r\nbreak;\r\nDBG("An not ready(%d). l0_status=0x%08x",\r\ntimeout_count, link0_status);\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_err("%s: Wait An timedout", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_send_aksv_an(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc = 0;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 link0_aksv_0, link0_aksv_1;\r\nu32 link0_an[2];\r\nu8 aksv[5];\r\nlink0_an[0] = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA5);\r\nlink0_an[1] = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA6);\r\nlink0_aksv_0 = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA3);\r\nlink0_aksv_1 = hdmi_read(hdmi, REG_HDMI_HDCP_RCVPORT_DATA4);\r\nDBG("Link ASKV=%08x%08x", link0_aksv_0, link0_aksv_1);\r\naksv[0] = link0_aksv_0 & 0xFF;\r\naksv[1] = (link0_aksv_0 >> 8) & 0xFF;\r\naksv[2] = (link0_aksv_0 >> 16) & 0xFF;\r\naksv[3] = (link0_aksv_0 >> 24) & 0xFF;\r\naksv[4] = link0_aksv_1 & 0xFF;\r\nrc = msm_hdmi_ddc_write(hdmi, HDCP_PORT_ADDR, 0x18, (u8 *)link0_an,\r\n(u16)sizeof(link0_an));\r\nif (rc) {\r\npr_err("%s:An write failed\n", __func__);\r\nreturn rc;\r\n}\r\nDBG("Link0-An=%08x%08x", link0_an[0], link0_an[1]);\r\nrc = msm_hdmi_ddc_write(hdmi, HDCP_PORT_ADDR, 0x10, aksv, 5);\r\nif (rc) {\r\npr_err("%s:AKSV write failed\n", __func__);\r\nreturn rc;\r\n}\r\nDBG("Link0-AKSV=%02x%08x", link0_aksv_1 & 0xFF, link0_aksv_0);\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_recv_bksv(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc = 0;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu8 bksv[5];\r\nu32 reg[2], data[2];\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x00, bksv, 5);\r\nif (rc) {\r\npr_err("%s:BKSV read failed\n", __func__);\r\nreturn rc;\r\n}\r\nhdcp_ctrl->bksv_lsb = bksv[0] | (bksv[1] << 8) |\r\n(bksv[2] << 16) | (bksv[3] << 24);\r\nhdcp_ctrl->bksv_msb = bksv[4];\r\nDBG(":BKSV=%02x%08x", hdcp_ctrl->bksv_msb, hdcp_ctrl->bksv_lsb);\r\nif ((hweight32(hdcp_ctrl->bksv_lsb) + hweight32(hdcp_ctrl->bksv_msb))\r\n!= 20) {\r\npr_err(": BKSV doesn't have 20 1's and 20 0's\n");\r\npr_err(": BKSV chk fail. BKSV=%02x%02x%02x%02x%02x\n",\r\nbksv[4], bksv[3], bksv[2], bksv[1], bksv[0]);\r\nreturn -EINVAL;\r\n}\r\nreg[0] = REG_HDMI_HDCP_RCVPORT_DATA0;\r\ndata[0] = hdcp_ctrl->bksv_lsb;\r\nreg[1] = REG_HDMI_HDCP_RCVPORT_DATA1;\r\ndata[1] = hdcp_ctrl->bksv_msb;\r\nrc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, 2);\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_recv_bcaps(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc = 0;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg, data;\r\nu8 bcaps;\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x40, &bcaps, 1);\r\nif (rc) {\r\npr_err("%s:BCAPS read failed\n", __func__);\r\nreturn rc;\r\n}\r\nDBG("BCAPS=%02x", bcaps);\r\nhdcp_ctrl->ds_type = (bcaps & BIT(6)) ? DS_REPEATER : DS_RECEIVER;\r\nreg = REG_HDMI_HDCP_RCVPORT_DATA12;\r\ndata = (u32)bcaps;\r\nrc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part1_key_exchange(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nunsigned long flags;\r\nint rc;\r\nrc = msm_hdmi_hdcp_wait_key_an_ready(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: wait key and an ready failed\n", __func__);\r\nreturn rc;\r\n};\r\nrc = msm_hdmi_hdcp_recv_bcaps(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: read bcaps error, abort\n", __func__);\r\nreturn rc;\r\n}\r\nhdmi_write(hdmi, REG_HDMI_HDCP_RCVPORT_DATA4, 0);\r\nrc = msm_hdmi_hdcp_send_aksv_an(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s:An/Aksv write failed\n", __func__);\r\nreturn rc;\r\n}\r\nrc = msm_hdmi_hdcp_recv_bksv(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s:BKSV Process failed\n", __func__);\r\nreturn rc;\r\n}\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL,\r\nHDMI_HDCP_INT_CTRL_AUTH_SUCCESS_ACK |\r\nHDMI_HDCP_INT_CTRL_AUTH_SUCCESS_MASK |\r\nHDMI_HDCP_INT_CTRL_AUTH_FAIL_ACK |\r\nHDMI_HDCP_INT_CTRL_AUTH_FAIL_MASK |\r\nHDMI_HDCP_INT_CTRL_AUTH_FAIL_INFO_ACK);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part1_recv_r0(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nint rc = 0;\r\nu8 buf[2];\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 125, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x08, buf, 2);\r\nif (rc) {\r\npr_err("%s:R0' read failed\n", __func__);\r\nreturn rc;\r\n}\r\nDBG("R0'=%02x%02x", buf[1], buf[0]);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_RCVPORT_DATA2_0,\r\n(((u32)buf[1]) << 8) | buf[0]);\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part1_verify_r0(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 link0_status;\r\nint rc;\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 10000, AUTH_RESULT_RDY_EV);\r\nif (!rc) {\r\npr_err("%s: Wait Auth IRQ timeout\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\r\nif (!(link0_status & HDMI_HDCP_LINK0_STATUS_RI_MATCHES)) {\r\npr_err("%s: Authentication Part I failed\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nhdmi_write(hdmi, REG_HDMI_HDCP_CTRL,\r\nHDMI_HDCP_CTRL_ENABLE |\r\nHDMI_HDCP_CTRL_ENCRYPTION_ENABLE);\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_recv_check_bstatus(struct hdmi_hdcp_ctrl *hdcp_ctrl,\r\nu16 *pbstatus)\r\n{\r\nint rc;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nbool max_devs_exceeded = false, max_cascade_exceeded = false;\r\nu32 repeater_cascade_depth = 0, down_stream_devices = 0;\r\nu16 bstatus;\r\nu8 buf[2];\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x41, buf, 2);\r\nif (rc) {\r\npr_err("%s: BSTATUS read failed\n", __func__);\r\ngoto error;\r\n}\r\n*pbstatus = bstatus = (buf[1] << 8) | buf[0];\r\ndown_stream_devices = bstatus & 0x7F;\r\nrepeater_cascade_depth = (bstatus >> 8) & 0x7;\r\nmax_devs_exceeded = (bstatus & BIT(7)) ? true : false;\r\nmax_cascade_exceeded = (bstatus & BIT(11)) ? true : false;\r\nif (down_stream_devices == 0) {\r\npr_err("%s: No downstream devices\n", __func__);\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nif (max_devs_exceeded) {\r\npr_err("%s: no. of devs connected exceeds max allowed",\r\n__func__);\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nif (max_cascade_exceeded) {\r\npr_err("%s: no. of cascade conn exceeds max allowed",\r\n__func__);\r\nrc = -EINVAL;\r\ngoto error;\r\n}\r\nerror:\r\nhdcp_ctrl->dev_count = down_stream_devices;\r\nhdcp_ctrl->max_cascade_exceeded = max_cascade_exceeded;\r\nhdcp_ctrl->max_dev_exceeded = max_devs_exceeded;\r\nhdcp_ctrl->depth = repeater_cascade_depth;\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part2_wait_ksv_fifo_ready(\r\nstruct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg, data;\r\nu32 timeout_count;\r\nu16 bstatus;\r\nu8 bcaps;\r\ntimeout_count = 100;\r\ndo {\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x40, &bcaps, 1);\r\nif (rc) {\r\npr_err("%s: BCAPS read failed\n", __func__);\r\nreturn rc;\r\n}\r\nif (bcaps & BIT(5))\r\nbreak;\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_err("%s: Wait KSV fifo ready timedout", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\nrc = msm_hdmi_hdcp_recv_check_bstatus(hdcp_ctrl, &bstatus);\r\nif (rc) {\r\npr_err("%s: bstatus error\n", __func__);\r\nreturn rc;\r\n}\r\nreg = REG_HDMI_HDCP_RCVPORT_DATA12;\r\ndata = bcaps | (bstatus << 8);\r\nrc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);\r\nif (rc) {\r\npr_err("%s: BSTATUS write failed\n", __func__);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_transfer_v_h(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nint rc = 0;\r\nstruct hdmi_hdcp_reg_data reg_data[] = {\r\n{REG_HDMI_HDCP_RCVPORT_DATA7, 0x20, "V' H0"},\r\n{REG_HDMI_HDCP_RCVPORT_DATA8, 0x24, "V' H1"},\r\n{REG_HDMI_HDCP_RCVPORT_DATA9, 0x28, "V' H2"},\r\n{REG_HDMI_HDCP_RCVPORT_DATA10, 0x2C, "V' H3"},\r\n{REG_HDMI_HDCP_RCVPORT_DATA11, 0x30, "V' H4"},\r\n};\r\nstruct hdmi_hdcp_reg_data *rd;\r\nu32 size = ARRAY_SIZE(reg_data);\r\nu32 reg[ARRAY_SIZE(reg_data)];\r\nu32 data[ARRAY_SIZE(reg_data)];\r\nint i;\r\nfor (i = 0; i < size; i++) {\r\nrd = &reg_data[i];\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR,\r\nrd->off, (u8 *)&data[i], (u16)sizeof(data[i]));\r\nif (rc) {\r\npr_err("%s: Read %s failed\n", __func__, rd->name);\r\ngoto error;\r\n}\r\nDBG("%s =%x", rd->name, data[i]);\r\nreg[i] = reg_data[i].reg_id;\r\n}\r\nrc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, size);\r\nerror:\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_recv_ksv_fifo(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 ksv_bytes;\r\nksv_bytes = 5 * hdcp_ctrl->dev_count;\r\nrc = msm_hdmi_ddc_read(hdmi, HDCP_PORT_ADDR, 0x43,\r\nhdcp_ctrl->ksv_list, ksv_bytes);\r\nif (rc)\r\npr_err("%s: KSV FIFO read failed\n", __func__);\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_reset_sha_engine(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nu32 reg[2], data[2];\r\nu32 rc = 0;\r\nreg[0] = REG_HDMI_HDCP_SHA_CTRL;\r\ndata[0] = HDCP_REG_ENABLE;\r\nreg[1] = REG_HDMI_HDCP_SHA_CTRL;\r\ndata[1] = HDCP_REG_DISABLE;\r\nrc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, reg, data, 2);\r\nreturn rc;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part2_recv_ksv_fifo(\r\nstruct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc;\r\nu32 timeout_count;\r\ntimeout_count = 100;\r\ndo {\r\nrc = msm_hdmi_hdcp_recv_ksv_fifo(hdcp_ctrl);\r\nif (!rc)\r\nbreak;\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_err("%s: Recv ksv fifo timedout", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 25, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\nrc = msm_hdmi_hdcp_transfer_v_h(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: transfer V failed\n", __func__);\r\nreturn rc;\r\n}\r\nrc = msm_hdmi_hdcp_reset_sha_engine(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: fail to reset sha engine\n", __func__);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_write_ksv_fifo(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint i;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 ksv_bytes, last_byte = 0;\r\nu8 *ksv_fifo = NULL;\r\nu32 reg_val, data, reg;\r\nu32 rc = 0;\r\nksv_bytes = 5 * hdcp_ctrl->dev_count;\r\nif (hdcp_ctrl->ksv_fifo_w_index) {\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HDCP_SHA_STATUS);\r\nDBG("HDCP_SHA_STATUS=%08x", reg_val);\r\nif (hdcp_ctrl->ksv_fifo_w_index == ksv_bytes) {\r\nif (reg_val & HDMI_HDCP_SHA_STATUS_COMP_DONE) {\r\nDBG("COMP_DONE");\r\nreturn 0;\r\n} else {\r\nreturn -EAGAIN;\r\n}\r\n} else {\r\nif (!(reg_val & HDMI_HDCP_SHA_STATUS_BLOCK_DONE))\r\nreturn -EAGAIN;\r\nDBG("BLOCK_DONE");\r\n}\r\n}\r\nksv_bytes -= hdcp_ctrl->ksv_fifo_w_index;\r\nif (ksv_bytes <= 64)\r\nlast_byte = 1;\r\nelse\r\nksv_bytes = 64;\r\nksv_fifo = hdcp_ctrl->ksv_list;\r\nksv_fifo += hdcp_ctrl->ksv_fifo_w_index;\r\nfor (i = 0; i < ksv_bytes; i++) {\r\nreg_val = ksv_fifo[i] << 16;\r\nif ((i == (ksv_bytes - 1)) && last_byte)\r\nreg_val |= HDMI_HDCP_SHA_DATA_DONE;\r\nreg = REG_HDMI_HDCP_SHA_DATA;\r\ndata = reg_val;\r\nrc = msm_hdmi_hdcp_scm_wr(hdcp_ctrl, &reg, &data, 1);\r\nif (rc)\r\nreturn rc;\r\n}\r\nhdcp_ctrl->ksv_fifo_w_index += ksv_bytes;\r\nreturn -EAGAIN;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part2_write_ksv_fifo(\r\nstruct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc;\r\nu32 timeout_count;\r\nhdcp_ctrl->ksv_fifo_w_index = 0;\r\ntimeout_count = 100;\r\ndo {\r\nrc = msm_hdmi_hdcp_write_ksv_fifo(hdcp_ctrl);\r\nif (!rc)\r\nbreak;\r\nif (rc != -EAGAIN)\r\nreturn rc;\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_err("%s: Write KSV fifo timedout", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic int msm_hdmi_hdcp_auth_part2_check_v_match(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nint rc = 0;\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 link0_status;\r\nu32 timeout_count = 100;\r\ndo {\r\nlink0_status = hdmi_read(hdmi, REG_HDMI_HDCP_LINK0_STATUS);\r\nif (link0_status & HDMI_HDCP_LINK0_STATUS_V_MATCHES)\r\nbreak;\r\ntimeout_count--;\r\nif (!timeout_count) {\r\npr_err("%s: HDCP V Match timedout", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nrc = msm_hdmi_hdcp_msleep(hdcp_ctrl, 20, AUTH_ABORT_EV);\r\nif (rc)\r\nreturn rc;\r\n} while (1);\r\nreturn 0;\r\n}\r\nstatic void msm_hdmi_hdcp_auth_work(struct work_struct *work)\r\n{\r\nstruct hdmi_hdcp_ctrl *hdcp_ctrl = container_of(work,\r\nstruct hdmi_hdcp_ctrl, hdcp_auth_work);\r\nint rc;\r\nrc = msm_hdmi_hdcp_auth_prepare(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: auth prepare failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\nrc = msm_hdmi_hdcp_auth_part1_key_exchange(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: key exchange failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\nrc = msm_hdmi_hdcp_auth_part1_recv_r0(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: receive r0 failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\nrc = msm_hdmi_hdcp_auth_part1_verify_r0(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: verify r0 failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\npr_info("%s: Authentication Part I successful\n", __func__);\r\nif (hdcp_ctrl->ds_type == DS_RECEIVER)\r\ngoto end;\r\nrc = msm_hdmi_hdcp_auth_part2_wait_ksv_fifo_ready(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: wait ksv fifo ready failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\nrc = msm_hdmi_hdcp_auth_part2_recv_ksv_fifo(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: recv ksv fifo failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\nrc = msm_hdmi_hdcp_auth_part2_write_ksv_fifo(hdcp_ctrl);\r\nif (rc) {\r\npr_err("%s: write ksv fifo failed %d\n", __func__, rc);\r\ngoto end;\r\n}\r\nrc = msm_hdmi_hdcp_auth_part2_check_v_match(hdcp_ctrl);\r\nif (rc)\r\npr_err("%s: check v match failed %d\n", __func__, rc);\r\nend:\r\nif (rc == -ECANCELED) {\r\npr_info("%s: hdcp authentication canceled\n", __func__);\r\n} else if (rc == -ENOTSUPP) {\r\npr_info("%s: hdcp is not supported\n", __func__);\r\n} else if (rc) {\r\npr_err("%s: hdcp authentication failed\n", __func__);\r\nmsm_hdmi_hdcp_auth_fail(hdcp_ctrl);\r\n} else {\r\nmsm_hdmi_hdcp_auth_done(hdcp_ctrl);\r\n}\r\n}\r\nvoid msm_hdmi_hdcp_on(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nu32 reg_val;\r\nunsigned long flags;\r\nif ((HDCP_STATE_INACTIVE != hdcp_ctrl->hdcp_state) ||\r\n(HDCP_STATE_NO_AKSV == hdcp_ctrl->hdcp_state)) {\r\nDBG("still active or activating or no askv. returning");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nreg_val &= ~HDMI_CTRL_ENCRYPTED;\r\nhdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nhdcp_ctrl->auth_event = 0;\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_AUTHENTICATING;\r\nhdcp_ctrl->auth_retries = 0;\r\nqueue_work(hdmi->workq, &hdcp_ctrl->hdcp_auth_work);\r\n}\r\nvoid msm_hdmi_hdcp_off(struct hdmi_hdcp_ctrl *hdcp_ctrl)\r\n{\r\nstruct hdmi *hdmi = hdcp_ctrl->hdmi;\r\nunsigned long flags;\r\nu32 reg_val;\r\nif ((HDCP_STATE_INACTIVE == hdcp_ctrl->hdcp_state) ||\r\n(HDCP_STATE_NO_AKSV == hdcp_ctrl->hdcp_state)) {\r\nDBG("hdcp inactive or no aksv. returning");\r\nreturn;\r\n}\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\r\nreg_val &= ~HDMI_HPD_CTRL_ENABLE;\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_INT_CTRL, 0);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nset_bit(AUTH_ABORT_EV, &hdcp_ctrl->auth_event);\r\nwake_up_all(&hdcp_ctrl->auth_event_queue);\r\ncancel_work_sync(&hdcp_ctrl->hdcp_auth_work);\r\ncancel_work_sync(&hdcp_ctrl->hdcp_reauth_work);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_RESET,\r\nHDMI_HDCP_RESET_LINK0_DEAUTHENTICATE);\r\nhdmi_write(hdmi, REG_HDMI_HDCP_CTRL, 0);\r\nspin_lock_irqsave(&hdmi->reg_lock, flags);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_CTRL);\r\nreg_val &= ~HDMI_CTRL_ENCRYPTED;\r\nhdmi_write(hdmi, REG_HDMI_CTRL, reg_val);\r\nreg_val = hdmi_read(hdmi, REG_HDMI_HPD_CTRL);\r\nreg_val |= HDMI_HPD_CTRL_ENABLE;\r\nhdmi_write(hdmi, REG_HDMI_HPD_CTRL, reg_val);\r\nspin_unlock_irqrestore(&hdmi->reg_lock, flags);\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_INACTIVE;\r\nDBG("HDCP: Off");\r\n}\r\nstruct hdmi_hdcp_ctrl *msm_hdmi_hdcp_init(struct hdmi *hdmi)\r\n{\r\nstruct hdmi_hdcp_ctrl *hdcp_ctrl = NULL;\r\nif (!hdmi->qfprom_mmio) {\r\npr_err("%s: HDCP is not supported without qfprom\n",\r\n__func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nhdcp_ctrl = kzalloc(sizeof(*hdcp_ctrl), GFP_KERNEL);\r\nif (!hdcp_ctrl)\r\nreturn ERR_PTR(-ENOMEM);\r\nINIT_WORK(&hdcp_ctrl->hdcp_auth_work, msm_hdmi_hdcp_auth_work);\r\nINIT_WORK(&hdcp_ctrl->hdcp_reauth_work, msm_hdmi_hdcp_reauth_work);\r\ninit_waitqueue_head(&hdcp_ctrl->auth_event_queue);\r\nhdcp_ctrl->hdmi = hdmi;\r\nhdcp_ctrl->hdcp_state = HDCP_STATE_INACTIVE;\r\nhdcp_ctrl->aksv_valid = false;\r\nif (qcom_scm_hdcp_available())\r\nhdcp_ctrl->tz_hdcp = true;\r\nelse\r\nhdcp_ctrl->tz_hdcp = false;\r\nreturn hdcp_ctrl;\r\n}\r\nvoid msm_hdmi_hdcp_destroy(struct hdmi *hdmi)\r\n{\r\nif (hdmi) {\r\nkfree(hdmi->hdcp_ctrl);\r\nhdmi->hdcp_ctrl = NULL;\r\n}\r\n}
