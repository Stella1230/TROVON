static int pvr2_ioread_init(struct pvr2_ioread *cp)\r\n{\r\nunsigned int idx;\r\ncp->stream = NULL;\r\nmutex_init(&cp->mutex);\r\nfor (idx = 0; idx < BUFFER_COUNT; idx++) {\r\ncp->buffer_storage[idx] = kmalloc(BUFFER_SIZE,GFP_KERNEL);\r\nif (!(cp->buffer_storage[idx])) break;\r\n}\r\nif (idx < BUFFER_COUNT) {\r\nfor (idx = 0; idx < BUFFER_COUNT; idx++) {\r\nif (!(cp->buffer_storage[idx])) continue;\r\nkfree(cp->buffer_storage[idx]);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pvr2_ioread_done(struct pvr2_ioread *cp)\r\n{\r\nunsigned int idx;\r\npvr2_ioread_setup(cp,NULL);\r\nfor (idx = 0; idx < BUFFER_COUNT; idx++) {\r\nif (!(cp->buffer_storage[idx])) continue;\r\nkfree(cp->buffer_storage[idx]);\r\n}\r\n}\r\nstruct pvr2_ioread *pvr2_ioread_create(void)\r\n{\r\nstruct pvr2_ioread *cp;\r\ncp = kzalloc(sizeof(*cp),GFP_KERNEL);\r\nif (!cp) return NULL;\r\npvr2_trace(PVR2_TRACE_STRUCT,"pvr2_ioread_create id=%p",cp);\r\nif (pvr2_ioread_init(cp) < 0) {\r\nkfree(cp);\r\nreturn NULL;\r\n}\r\nreturn cp;\r\n}\r\nvoid pvr2_ioread_destroy(struct pvr2_ioread *cp)\r\n{\r\nif (!cp) return;\r\npvr2_ioread_done(cp);\r\npvr2_trace(PVR2_TRACE_STRUCT,"pvr2_ioread_destroy id=%p",cp);\r\nif (cp->sync_key_ptr) {\r\nkfree(cp->sync_key_ptr);\r\ncp->sync_key_ptr = NULL;\r\n}\r\nkfree(cp);\r\n}\r\nvoid pvr2_ioread_set_sync_key(struct pvr2_ioread *cp,\r\nconst char *sync_key_ptr,\r\nunsigned int sync_key_len)\r\n{\r\nif (!cp) return;\r\nif (!sync_key_ptr) sync_key_len = 0;\r\nif ((sync_key_len == cp->sync_key_len) &&\r\n((!sync_key_len) ||\r\n(!memcmp(sync_key_ptr,cp->sync_key_ptr,sync_key_len)))) return;\r\nif (sync_key_len != cp->sync_key_len) {\r\nif (cp->sync_key_ptr) {\r\nkfree(cp->sync_key_ptr);\r\ncp->sync_key_ptr = NULL;\r\n}\r\ncp->sync_key_len = 0;\r\nif (sync_key_len) {\r\ncp->sync_key_ptr = kmalloc(sync_key_len,GFP_KERNEL);\r\nif (cp->sync_key_ptr) {\r\ncp->sync_key_len = sync_key_len;\r\n}\r\n}\r\n}\r\nif (!cp->sync_key_len) return;\r\nmemcpy(cp->sync_key_ptr,sync_key_ptr,cp->sync_key_len);\r\n}\r\nstatic void pvr2_ioread_stop(struct pvr2_ioread *cp)\r\n{\r\nif (!(cp->enabled)) return;\r\npvr2_trace(PVR2_TRACE_START_STOP,\r\n"/*---TRACE_READ---*/ pvr2_ioread_stop id=%p",cp);\r\npvr2_stream_kill(cp->stream);\r\ncp->c_buf = NULL;\r\ncp->c_data_ptr = NULL;\r\ncp->c_data_len = 0;\r\ncp->c_data_offs = 0;\r\ncp->enabled = 0;\r\ncp->stream_running = 0;\r\ncp->spigot_open = 0;\r\nif (cp->sync_state) {\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ sync_state <== 0");\r\ncp->sync_state = 0;\r\n}\r\n}\r\nstatic int pvr2_ioread_start(struct pvr2_ioread *cp)\r\n{\r\nint stat;\r\nstruct pvr2_buffer *bp;\r\nif (cp->enabled) return 0;\r\nif (!(cp->stream)) return 0;\r\npvr2_trace(PVR2_TRACE_START_STOP,\r\n"/*---TRACE_READ---*/ pvr2_ioread_start id=%p",cp);\r\nwhile ((bp = pvr2_stream_get_idle_buffer(cp->stream)) != NULL) {\r\nstat = pvr2_buffer_queue(bp);\r\nif (stat < 0) {\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ pvr2_ioread_start id=%p error=%d",\r\ncp,stat);\r\npvr2_ioread_stop(cp);\r\nreturn stat;\r\n}\r\n}\r\ncp->enabled = !0;\r\ncp->c_buf = NULL;\r\ncp->c_data_ptr = NULL;\r\ncp->c_data_len = 0;\r\ncp->c_data_offs = 0;\r\ncp->stream_running = 0;\r\nif (cp->sync_key_len) {\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ sync_state <== 1");\r\ncp->sync_state = 1;\r\ncp->sync_trashed_count = 0;\r\ncp->sync_buf_offs = 0;\r\n}\r\ncp->spigot_open = 0;\r\nreturn 0;\r\n}\r\nstruct pvr2_stream *pvr2_ioread_get_stream(struct pvr2_ioread *cp)\r\n{\r\nreturn cp->stream;\r\n}\r\nint pvr2_ioread_setup(struct pvr2_ioread *cp,struct pvr2_stream *sp)\r\n{\r\nint ret;\r\nunsigned int idx;\r\nstruct pvr2_buffer *bp;\r\nmutex_lock(&cp->mutex);\r\ndo {\r\nif (cp->stream) {\r\npvr2_trace(PVR2_TRACE_START_STOP,\r\n"/*---TRACE_READ---*/ pvr2_ioread_setup (tear-down) id=%p",\r\ncp);\r\npvr2_ioread_stop(cp);\r\npvr2_stream_kill(cp->stream);\r\nif (pvr2_stream_get_buffer_count(cp->stream)) {\r\npvr2_stream_set_buffer_count(cp->stream,0);\r\n}\r\ncp->stream = NULL;\r\n}\r\nif (sp) {\r\npvr2_trace(PVR2_TRACE_START_STOP,\r\n"/*---TRACE_READ---*/ pvr2_ioread_setup (setup) id=%p",\r\ncp);\r\npvr2_stream_kill(sp);\r\nret = pvr2_stream_set_buffer_count(sp,BUFFER_COUNT);\r\nif (ret < 0) {\r\nmutex_unlock(&cp->mutex);\r\nreturn ret;\r\n}\r\nfor (idx = 0; idx < BUFFER_COUNT; idx++) {\r\nbp = pvr2_stream_get_buffer(sp,idx);\r\npvr2_buffer_set_buffer(bp,\r\ncp->buffer_storage[idx],\r\nBUFFER_SIZE);\r\n}\r\ncp->stream = sp;\r\n}\r\n} while (0);\r\nmutex_unlock(&cp->mutex);\r\nreturn 0;\r\n}\r\nint pvr2_ioread_set_enabled(struct pvr2_ioread *cp,int fl)\r\n{\r\nint ret = 0;\r\nif ((!fl) == (!(cp->enabled))) return ret;\r\nmutex_lock(&cp->mutex);\r\ndo {\r\nif (fl) {\r\nret = pvr2_ioread_start(cp);\r\n} else {\r\npvr2_ioread_stop(cp);\r\n}\r\n} while (0);\r\nmutex_unlock(&cp->mutex);\r\nreturn ret;\r\n}\r\nstatic int pvr2_ioread_get_buffer(struct pvr2_ioread *cp)\r\n{\r\nint stat;\r\nwhile (cp->c_data_len <= cp->c_data_offs) {\r\nif (cp->c_buf) {\r\nstat = pvr2_buffer_queue(cp->c_buf);\r\nif (stat < 0) {\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ pvr2_ioread_read id=%p queue_error=%d",\r\ncp,stat);\r\npvr2_ioread_stop(cp);\r\nreturn 0;\r\n}\r\ncp->c_buf = NULL;\r\ncp->c_data_ptr = NULL;\r\ncp->c_data_len = 0;\r\ncp->c_data_offs = 0;\r\n}\r\ncp->c_buf = pvr2_stream_get_ready_buffer(cp->stream);\r\nif (!cp->c_buf) break;\r\ncp->c_data_len = pvr2_buffer_get_count(cp->c_buf);\r\nif (!cp->c_data_len) {\r\nstat = pvr2_buffer_get_status(cp->c_buf);\r\nif (stat < 0) {\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ pvr2_ioread_read id=%p buffer_error=%d",\r\ncp,stat);\r\npvr2_ioread_stop(cp);\r\nreturn 0;\r\n}\r\ncontinue;\r\n}\r\ncp->c_data_offs = 0;\r\ncp->c_data_ptr = cp->buffer_storage[\r\npvr2_buffer_get_id(cp->c_buf)];\r\n}\r\nreturn !0;\r\n}\r\nstatic void pvr2_ioread_filter(struct pvr2_ioread *cp)\r\n{\r\nunsigned int idx;\r\nif (!cp->enabled) return;\r\nif (cp->sync_state != 1) return;\r\nmutex_lock(&cp->mutex);\r\nwhile (1) {\r\nif (!pvr2_ioread_get_buffer(cp)) break;\r\nif (!cp->c_data_len) break;\r\nfor (idx = cp->c_data_offs; idx < cp->c_data_len; idx++) {\r\nif (cp->sync_buf_offs >= cp->sync_key_len) break;\r\nif (cp->c_data_ptr[idx] ==\r\ncp->sync_key_ptr[cp->sync_buf_offs]) {\r\n(cp->sync_buf_offs)++;\r\n} else {\r\ncp->sync_buf_offs = 0;\r\n}\r\n}\r\ncp->c_data_offs += idx;\r\ncp->sync_trashed_count += idx;\r\nif (cp->sync_buf_offs >= cp->sync_key_len) {\r\ncp->sync_trashed_count -= cp->sync_key_len;\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ sync_state <== 2 (skipped %u bytes)",\r\ncp->sync_trashed_count);\r\ncp->sync_state = 2;\r\ncp->sync_buf_offs = 0;\r\nbreak;\r\n}\r\nif (cp->c_data_offs < cp->c_data_len) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"ERROR: pvr2_ioread filter sync problem len=%u offs=%u",\r\ncp->c_data_len,cp->c_data_offs);\r\nbreak;\r\n}\r\ncontinue;\r\n}\r\nmutex_unlock(&cp->mutex);\r\n}\r\nint pvr2_ioread_avail(struct pvr2_ioread *cp)\r\n{\r\nint ret;\r\nif (!(cp->enabled)) {\r\nreturn -EIO;\r\n}\r\nif (cp->sync_state == 1) {\r\npvr2_ioread_filter(cp);\r\nif (cp->sync_state == 1) return -EAGAIN;\r\n}\r\nret = 0;\r\nif (cp->stream_running) {\r\nif (!pvr2_stream_get_ready_count(cp->stream)) {\r\nret = -EAGAIN;\r\n}\r\n} else {\r\nif (pvr2_stream_get_ready_count(cp->stream) < BUFFER_COUNT/2) {\r\nret = -EAGAIN;\r\n}\r\n}\r\nif ((!(cp->spigot_open)) != (!(ret == 0))) {\r\ncp->spigot_open = (ret == 0);\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ data is %s",\r\ncp->spigot_open ? "available" : "pending");\r\n}\r\nreturn ret;\r\n}\r\nint pvr2_ioread_read(struct pvr2_ioread *cp,void __user *buf,unsigned int cnt)\r\n{\r\nunsigned int copied_cnt;\r\nunsigned int bcnt;\r\nconst char *src;\r\nint stat;\r\nint ret = 0;\r\nunsigned int req_cnt = cnt;\r\nif (!cnt) {\r\npvr2_trace(PVR2_TRACE_TRAP,\r\n"/*---TRACE_READ---*/ pvr2_ioread_read id=%p ZERO Request? Returning zero.",\r\ncp);\r\nreturn 0;\r\n}\r\nstat = pvr2_ioread_avail(cp);\r\nif (stat < 0) return stat;\r\ncp->stream_running = !0;\r\nmutex_lock(&cp->mutex);\r\ndo {\r\ncopied_cnt = 0;\r\nif (!buf) cnt = 0;\r\nwhile (1) {\r\nif (!pvr2_ioread_get_buffer(cp)) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nif (!cnt) break;\r\nif (cp->sync_state == 2) {\r\nsrc = cp->sync_key_ptr + cp->sync_buf_offs;\r\nbcnt = cp->sync_key_len - cp->sync_buf_offs;\r\n} else {\r\nsrc = cp->c_data_ptr + cp->c_data_offs;\r\nbcnt = cp->c_data_len - cp->c_data_offs;\r\n}\r\nif (!bcnt) break;\r\nif (bcnt > cnt) bcnt = cnt;\r\nif (copy_to_user(buf,src,bcnt)) {\r\nret = -EFAULT;\r\nbreak;\r\n}\r\ncnt -= bcnt;\r\nbuf += bcnt;\r\ncopied_cnt += bcnt;\r\nif (cp->sync_state == 2) {\r\ncp->sync_buf_offs += bcnt;\r\nif (cp->sync_buf_offs >= cp->sync_key_len) {\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ sync_state <== 0");\r\ncp->sync_state = 0;\r\n}\r\n} else {\r\ncp->c_data_offs += bcnt;\r\n}\r\n}\r\n} while (0);\r\nmutex_unlock(&cp->mutex);\r\nif (!ret) {\r\nif (copied_cnt) {\r\nret = copied_cnt;\r\n} else {\r\nret = -EAGAIN;\r\n}\r\n}\r\npvr2_trace(PVR2_TRACE_DATA_FLOW,\r\n"/*---TRACE_READ---*/ pvr2_ioread_read id=%p request=%d result=%d",\r\ncp,req_cnt,ret);\r\nreturn ret;\r\n}
