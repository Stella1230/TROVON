static inline\r\nstruct audio_dev *func_to_agdev(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct audio_dev, func);\r\n}\r\nstatic inline\r\nstruct audio_dev *uac2_to_agdev(struct snd_uac2_chip *u)\r\n{\r\nreturn container_of(u, struct audio_dev, uac2);\r\n}\r\nstatic inline\r\nstruct snd_uac2_chip *pdev_to_uac2(struct platform_device *p)\r\n{\r\nreturn container_of(p, struct snd_uac2_chip, pdev);\r\n}\r\nstatic inline\r\nstruct f_uac2_opts *agdev_to_uac2_opts(struct audio_dev *agdev)\r\n{\r\nreturn container_of(agdev->func.fi, struct f_uac2_opts, func_inst);\r\n}\r\nstatic inline\r\nuint num_channels(uint chanmask)\r\n{\r\nuint num = 0;\r\nwhile (chanmask) {\r\nnum += (chanmask & 1);\r\nchanmask >>= 1;\r\n}\r\nreturn num;\r\n}\r\nstatic void\r\nagdev_iso_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nunsigned pending;\r\nunsigned long flags;\r\nunsigned int hw_ptr;\r\nbool update_alsa = false;\r\nint status = req->status;\r\nstruct uac2_req *ur = req->context;\r\nstruct snd_pcm_substream *substream;\r\nstruct uac2_rtd_params *prm = ur->pp;\r\nstruct snd_uac2_chip *uac2 = prm->uac2;\r\nif (!prm->ep_enabled || req->status == -ESHUTDOWN)\r\nreturn;\r\nif (status)\r\npr_debug("%s: iso_complete status(%d) %d/%d\n",\r\n__func__, status, req->actual, req->length);\r\nsubstream = prm->ss;\r\nif (!substream)\r\ngoto exit;\r\nspin_lock_irqsave(&prm->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nreq->length = uac2->p_pktsize;\r\nuac2->p_residue += uac2->p_pktsize_residue;\r\nif (uac2->p_residue / uac2->p_interval >= uac2->p_framesize) {\r\nreq->length += uac2->p_framesize;\r\nuac2->p_residue -= uac2->p_framesize *\r\nuac2->p_interval;\r\n}\r\nreq->actual = req->length;\r\n}\r\npending = prm->hw_ptr % prm->period_size;\r\npending += req->actual;\r\nif (pending >= prm->period_size)\r\nupdate_alsa = true;\r\nhw_ptr = prm->hw_ptr;\r\nprm->hw_ptr = (prm->hw_ptr + req->actual) % prm->dma_bytes;\r\nspin_unlock_irqrestore(&prm->lock, flags);\r\npending = prm->dma_bytes - hw_ptr;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nif (unlikely(pending < req->actual)) {\r\nmemcpy(req->buf, prm->dma_area + hw_ptr, pending);\r\nmemcpy(req->buf + pending, prm->dma_area,\r\nreq->actual - pending);\r\n} else {\r\nmemcpy(req->buf, prm->dma_area + hw_ptr, req->actual);\r\n}\r\n} else {\r\nif (unlikely(pending < req->actual)) {\r\nmemcpy(prm->dma_area + hw_ptr, req->buf, pending);\r\nmemcpy(prm->dma_area, req->buf + pending,\r\nreq->actual - pending);\r\n} else {\r\nmemcpy(prm->dma_area + hw_ptr, req->buf, req->actual);\r\n}\r\n}\r\nexit:\r\nif (usb_ep_queue(ep, req, GFP_ATOMIC))\r\ndev_err(&uac2->pdev.dev, "%d Error!\n", __LINE__);\r\nif (update_alsa)\r\nsnd_pcm_period_elapsed(substream);\r\nreturn;\r\n}\r\nstatic int\r\nuac2_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct audio_dev *agdev = uac2_to_agdev(uac2);\r\nstruct f_uac2_opts *uac2_opts = agdev_to_uac2_opts(agdev);\r\nstruct uac2_rtd_params *prm;\r\nunsigned long flags;\r\nint err = 0;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nspin_lock_irqsave(&prm->lock, flags);\r\nprm->hw_ptr = 0;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\nprm->ss = substream;\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\nprm->ss = NULL;\r\nbreak;\r\ndefault:\r\nerr = -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&prm->lock, flags);\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK && !prm->ss)\r\nmemset(prm->rbuf, 0, prm->max_psize * uac2_opts->req_number);\r\nreturn err;\r\n}\r\nstatic snd_pcm_uframes_t uac2_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nreturn bytes_to_frames(substream->runtime, prm->hw_ptr);\r\n}\r\nstatic int uac2_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *hw_params)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nint err;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nerr = snd_pcm_lib_malloc_pages(substream,\r\nparams_buffer_bytes(hw_params));\r\nif (err >= 0) {\r\nprm->dma_bytes = substream->runtime->dma_bytes;\r\nprm->dma_area = substream->runtime->dma_area;\r\nprm->period_size = params_period_bytes(hw_params);\r\n}\r\nreturn err;\r\n}\r\nstatic int uac2_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct uac2_rtd_params *prm;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nprm = &uac2->p_prm;\r\nelse\r\nprm = &uac2->c_prm;\r\nprm->dma_area = NULL;\r\nprm->dma_bytes = 0;\r\nprm->period_size = 0;\r\nreturn snd_pcm_lib_free_pages(substream);\r\n}\r\nstatic int uac2_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_uac2_chip *uac2 = snd_pcm_substream_chip(substream);\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct audio_dev *audio_dev;\r\nstruct f_uac2_opts *opts;\r\nint p_ssize, c_ssize;\r\nint p_srate, c_srate;\r\nint p_chmask, c_chmask;\r\naudio_dev = uac2_to_agdev(uac2);\r\nopts = container_of(audio_dev->func.fi, struct f_uac2_opts, func_inst);\r\np_ssize = opts->p_ssize;\r\nc_ssize = opts->c_ssize;\r\np_srate = opts->p_srate;\r\nc_srate = opts->c_srate;\r\np_chmask = opts->p_chmask;\r\nc_chmask = opts->c_chmask;\r\nuac2->p_residue = 0;\r\nruntime->hw = uac2_pcm_hardware;\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nspin_lock_init(&uac2->p_prm.lock);\r\nruntime->hw.rate_min = p_srate;\r\nswitch (p_ssize) {\r\ncase 3:\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S24_3LE;\r\nbreak;\r\ncase 4:\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;\r\nbreak;\r\ndefault:\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\r\nbreak;\r\n}\r\nruntime->hw.channels_min = num_channels(p_chmask);\r\nruntime->hw.period_bytes_min = 2 * uac2->p_prm.max_psize\r\n/ runtime->hw.periods_min;\r\n} else {\r\nspin_lock_init(&uac2->c_prm.lock);\r\nruntime->hw.rate_min = c_srate;\r\nswitch (c_ssize) {\r\ncase 3:\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S24_3LE;\r\nbreak;\r\ncase 4:\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S32_LE;\r\nbreak;\r\ndefault:\r\nruntime->hw.formats = SNDRV_PCM_FMTBIT_S16_LE;\r\nbreak;\r\n}\r\nruntime->hw.channels_min = num_channels(c_chmask);\r\nruntime->hw.period_bytes_min = 2 * uac2->c_prm.max_psize\r\n/ runtime->hw.periods_min;\r\n}\r\nruntime->hw.rate_max = runtime->hw.rate_min;\r\nruntime->hw.channels_max = runtime->hw.channels_min;\r\nsnd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);\r\nreturn 0;\r\n}\r\nstatic int uac2_pcm_null(struct snd_pcm_substream *substream)\r\n{\r\nreturn 0;\r\n}\r\nstatic int snd_uac2_probe(struct platform_device *pdev)\r\n{\r\nstruct snd_uac2_chip *uac2 = pdev_to_uac2(pdev);\r\nstruct snd_card *card;\r\nstruct snd_pcm *pcm;\r\nstruct audio_dev *audio_dev;\r\nstruct f_uac2_opts *opts;\r\nint err;\r\nint p_chmask, c_chmask;\r\naudio_dev = uac2_to_agdev(uac2);\r\nopts = container_of(audio_dev->func.fi, struct f_uac2_opts, func_inst);\r\np_chmask = opts->p_chmask;\r\nc_chmask = opts->c_chmask;\r\nerr = snd_card_new(&pdev->dev, -1, NULL, THIS_MODULE, 0, &card);\r\nif (err < 0)\r\nreturn err;\r\nuac2->card = card;\r\nerr = snd_pcm_new(uac2->card, "UAC2 PCM", 0,\r\np_chmask ? 1 : 0, c_chmask ? 1 : 0, &pcm);\r\nif (err < 0)\r\ngoto snd_fail;\r\nstrcpy(pcm->name, "UAC2 PCM");\r\npcm->private_data = uac2;\r\nuac2->pcm = pcm;\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_PLAYBACK, &uac2_pcm_ops);\r\nsnd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &uac2_pcm_ops);\r\nstrcpy(card->driver, "UAC2_Gadget");\r\nstrcpy(card->shortname, "UAC2_Gadget");\r\nsprintf(card->longname, "UAC2_Gadget %i", pdev->id);\r\nsnd_pcm_lib_preallocate_pages_for_all(pcm, SNDRV_DMA_TYPE_CONTINUOUS,\r\nsnd_dma_continuous_data(GFP_KERNEL), 0, BUFF_SIZE_MAX);\r\nerr = snd_card_register(card);\r\nif (!err) {\r\nplatform_set_drvdata(pdev, card);\r\nreturn 0;\r\n}\r\nsnd_fail:\r\nsnd_card_free(card);\r\nuac2->pcm = NULL;\r\nuac2->card = NULL;\r\nreturn err;\r\n}\r\nstatic int snd_uac2_remove(struct platform_device *pdev)\r\n{\r\nstruct snd_card *card = platform_get_drvdata(pdev);\r\nif (card)\r\nreturn snd_card_free(card);\r\nreturn 0;\r\n}\r\nstatic void snd_uac2_release(struct device *dev)\r\n{\r\ndev_dbg(dev, "releasing '%s'\n", dev_name(dev));\r\n}\r\nstatic int alsa_uac2_init(struct audio_dev *agdev)\r\n{\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nint err;\r\nuac2->pdrv.probe = snd_uac2_probe;\r\nuac2->pdrv.remove = snd_uac2_remove;\r\nuac2->pdrv.driver.name = uac2_name;\r\nuac2->pdev.id = 0;\r\nuac2->pdev.name = uac2_name;\r\nuac2->pdev.dev.release = snd_uac2_release;\r\nerr = platform_driver_register(&uac2->pdrv);\r\nif (err)\r\nreturn err;\r\nerr = platform_device_register(&uac2->pdev);\r\nif (err)\r\nplatform_driver_unregister(&uac2->pdrv);\r\nreturn err;\r\n}\r\nstatic void alsa_uac2_exit(struct audio_dev *agdev)\r\n{\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nplatform_driver_unregister(&uac2->pdrv);\r\nplatform_device_unregister(&uac2->pdev);\r\n}\r\nstatic inline void\r\nfree_ep(struct uac2_rtd_params *prm, struct usb_ep *ep)\r\n{\r\nstruct snd_uac2_chip *uac2 = prm->uac2;\r\nstruct audio_dev *agdev = uac2_to_agdev(uac2);\r\nstruct f_uac2_opts *uac2_opts = agdev_to_uac2_opts(agdev);\r\nint i;\r\nif (!prm->ep_enabled)\r\nreturn;\r\nprm->ep_enabled = false;\r\nfor (i = 0; i < uac2_opts->req_number; i++) {\r\nif (prm->ureq[i].req) {\r\nusb_ep_dequeue(ep, prm->ureq[i].req);\r\nusb_ep_free_request(ep, prm->ureq[i].req);\r\nprm->ureq[i].req = NULL;\r\n}\r\n}\r\nif (usb_ep_disable(ep))\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\n}\r\nstatic void set_ep_max_packet_size(const struct f_uac2_opts *uac2_opts,\r\nstruct usb_endpoint_descriptor *ep_desc,\r\nunsigned int factor, bool is_playback)\r\n{\r\nint chmask, srate, ssize;\r\nu16 max_packet_size;\r\nif (is_playback) {\r\nchmask = uac2_opts->p_chmask;\r\nsrate = uac2_opts->p_srate;\r\nssize = uac2_opts->p_ssize;\r\n} else {\r\nchmask = uac2_opts->c_chmask;\r\nsrate = uac2_opts->c_srate;\r\nssize = uac2_opts->c_ssize;\r\n}\r\nmax_packet_size = num_channels(chmask) * ssize *\r\nDIV_ROUND_UP(srate, factor / (1 << (ep_desc->bInterval - 1)));\r\nep_desc->wMaxPacketSize = cpu_to_le16(min_t(u16, max_packet_size,\r\nle16_to_cpu(ep_desc->wMaxPacketSize)));\r\n}\r\nstatic int\r\nafunc_bind(struct usb_configuration *cfg, struct usb_function *fn)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct usb_composite_dev *cdev = cfg->cdev;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct device *dev = &uac2->pdev.dev;\r\nstruct uac2_rtd_params *prm;\r\nstruct f_uac2_opts *uac2_opts;\r\nstruct usb_string *us;\r\nint ret;\r\nuac2_opts = container_of(fn->fi, struct f_uac2_opts, func_inst);\r\nus = usb_gstrings_attach(cdev, fn_strings, ARRAY_SIZE(strings_fn));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\niad_desc.iFunction = us[STR_ASSOC].id;\r\nstd_ac_if_desc.iInterface = us[STR_IF_CTRL].id;\r\nin_clk_src_desc.iClockSource = us[STR_CLKSRC_IN].id;\r\nout_clk_src_desc.iClockSource = us[STR_CLKSRC_OUT].id;\r\nusb_out_it_desc.iTerminal = us[STR_USB_IT].id;\r\nio_in_it_desc.iTerminal = us[STR_IO_IT].id;\r\nusb_in_ot_desc.iTerminal = us[STR_USB_OT].id;\r\nio_out_ot_desc.iTerminal = us[STR_IO_OT].id;\r\nstd_as_out_if0_desc.iInterface = us[STR_AS_OUT_ALT0].id;\r\nstd_as_out_if1_desc.iInterface = us[STR_AS_OUT_ALT1].id;\r\nstd_as_in_if0_desc.iInterface = us[STR_AS_IN_ALT0].id;\r\nstd_as_in_if1_desc.iInterface = us[STR_AS_IN_ALT1].id;\r\nusb_out_it_desc.bNrChannels = num_channels(uac2_opts->c_chmask);\r\nusb_out_it_desc.bmChannelConfig = cpu_to_le32(uac2_opts->c_chmask);\r\nio_in_it_desc.bNrChannels = num_channels(uac2_opts->p_chmask);\r\nio_in_it_desc.bmChannelConfig = cpu_to_le32(uac2_opts->p_chmask);\r\nas_out_hdr_desc.bNrChannels = num_channels(uac2_opts->c_chmask);\r\nas_out_hdr_desc.bmChannelConfig = cpu_to_le32(uac2_opts->c_chmask);\r\nas_in_hdr_desc.bNrChannels = num_channels(uac2_opts->p_chmask);\r\nas_in_hdr_desc.bmChannelConfig = cpu_to_le32(uac2_opts->p_chmask);\r\nas_out_fmt1_desc.bSubslotSize = uac2_opts->c_ssize;\r\nas_out_fmt1_desc.bBitResolution = uac2_opts->c_ssize * 8;\r\nas_in_fmt1_desc.bSubslotSize = uac2_opts->p_ssize;\r\nas_in_fmt1_desc.bBitResolution = uac2_opts->p_ssize * 8;\r\nsnprintf(clksrc_in, sizeof(clksrc_in), "%uHz", uac2_opts->p_srate);\r\nsnprintf(clksrc_out, sizeof(clksrc_out), "%uHz", uac2_opts->c_srate);\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_ac_if_desc.bInterfaceNumber = ret;\r\nagdev->ac_intf = ret;\r\nagdev->ac_alt = 0;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_as_out_if0_desc.bInterfaceNumber = ret;\r\nstd_as_out_if1_desc.bInterfaceNumber = ret;\r\nagdev->as_out_intf = ret;\r\nagdev->as_out_alt = 0;\r\nret = usb_interface_id(cfg, fn);\r\nif (ret < 0) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nstd_as_in_if0_desc.bInterfaceNumber = ret;\r\nstd_as_in_if1_desc.bInterfaceNumber = ret;\r\nagdev->as_in_intf = ret;\r\nagdev->as_in_alt = 0;\r\nagdev->out_ep = usb_ep_autoconfig(gadget, &fs_epout_desc);\r\nif (!agdev->out_ep) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nagdev->in_ep = usb_ep_autoconfig(gadget, &fs_epin_desc);\r\nif (!agdev->in_ep) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn ret;\r\n}\r\nuac2->p_prm.uac2 = uac2;\r\nuac2->c_prm.uac2 = uac2;\r\nset_ep_max_packet_size(uac2_opts, &fs_epin_desc, 1000, true);\r\nset_ep_max_packet_size(uac2_opts, &fs_epout_desc, 1000, false);\r\nset_ep_max_packet_size(uac2_opts, &hs_epin_desc, 8000, true);\r\nset_ep_max_packet_size(uac2_opts, &hs_epout_desc, 8000, false);\r\nhs_epout_desc.bEndpointAddress = fs_epout_desc.bEndpointAddress;\r\nhs_epin_desc.bEndpointAddress = fs_epin_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(fn, fs_audio_desc, hs_audio_desc, NULL,\r\nNULL);\r\nif (ret)\r\nreturn ret;\r\nprm = &agdev->uac2.c_prm;\r\nprm->max_psize = hs_epout_desc.wMaxPacketSize;\r\nprm->ureq = kcalloc(uac2_opts->req_number, sizeof(struct uac2_req),\r\nGFP_KERNEL);\r\nif (!prm->ureq) {\r\nret = -ENOMEM;\r\ngoto err_free_descs;\r\n}\r\nprm->rbuf = kcalloc(uac2_opts->req_number, prm->max_psize, GFP_KERNEL);\r\nif (!prm->rbuf) {\r\nprm->max_psize = 0;\r\nret = -ENOMEM;\r\ngoto err_free_descs;\r\n}\r\nprm = &agdev->uac2.p_prm;\r\nprm->max_psize = hs_epin_desc.wMaxPacketSize;\r\nprm->ureq = kcalloc(uac2_opts->req_number, sizeof(struct uac2_req),\r\nGFP_KERNEL);\r\nif (!prm->ureq) {\r\nret = -ENOMEM;\r\ngoto err_free_descs;\r\n}\r\nprm->rbuf = kcalloc(uac2_opts->req_number, prm->max_psize, GFP_KERNEL);\r\nif (!prm->rbuf) {\r\nprm->max_psize = 0;\r\nret = -ENOMEM;\r\ngoto err_no_memory;\r\n}\r\nret = alsa_uac2_init(agdev);\r\nif (ret)\r\ngoto err_no_memory;\r\nreturn 0;\r\nerr_no_memory:\r\nkfree(agdev->uac2.p_prm.ureq);\r\nkfree(agdev->uac2.c_prm.ureq);\r\nkfree(agdev->uac2.p_prm.rbuf);\r\nkfree(agdev->uac2.c_prm.rbuf);\r\nerr_free_descs:\r\nusb_free_all_descriptors(fn);\r\nreturn ret;\r\n}\r\nstatic int\r\nafunc_set_alt(struct usb_function *fn, unsigned intf, unsigned alt)\r\n{\r\nstruct usb_composite_dev *cdev = fn->config->cdev;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct f_uac2_opts *opts = agdev_to_uac2_opts(agdev);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct usb_gadget *gadget = cdev->gadget;\r\nstruct device *dev = &uac2->pdev.dev;\r\nstruct usb_request *req;\r\nstruct usb_ep *ep;\r\nstruct uac2_rtd_params *prm;\r\nint req_len, i;\r\nif (alt > 1) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (intf == agdev->ac_intf) {\r\nif (alt) {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nif (intf == agdev->as_out_intf) {\r\nep = agdev->out_ep;\r\nprm = &uac2->c_prm;\r\nconfig_ep_by_speed(gadget, fn, ep);\r\nagdev->as_out_alt = alt;\r\nreq_len = prm->max_psize;\r\n} else if (intf == agdev->as_in_intf) {\r\nunsigned int factor, rate;\r\nstruct usb_endpoint_descriptor *ep_desc;\r\nep = agdev->in_ep;\r\nprm = &uac2->p_prm;\r\nconfig_ep_by_speed(gadget, fn, ep);\r\nagdev->as_in_alt = alt;\r\nif (gadget->speed == USB_SPEED_FULL) {\r\nep_desc = &fs_epin_desc;\r\nfactor = 1000;\r\n} else {\r\nep_desc = &hs_epin_desc;\r\nfactor = 8000;\r\n}\r\nuac2->p_framesize = opts->p_ssize *\r\nnum_channels(opts->p_chmask);\r\nrate = opts->p_srate * uac2->p_framesize;\r\nuac2->p_interval = factor / (1 << (ep_desc->bInterval - 1));\r\nuac2->p_pktsize = min_t(unsigned int, rate / uac2->p_interval,\r\nprm->max_psize);\r\nif (uac2->p_pktsize < prm->max_psize)\r\nuac2->p_pktsize_residue = rate % uac2->p_interval;\r\nelse\r\nuac2->p_pktsize_residue = 0;\r\nreq_len = uac2->p_pktsize;\r\nuac2->p_residue = 0;\r\n} else {\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EINVAL;\r\n}\r\nif (alt == 0) {\r\nfree_ep(prm, ep);\r\nreturn 0;\r\n}\r\nprm->ep_enabled = true;\r\nusb_ep_enable(ep);\r\nfor (i = 0; i < opts->req_number; i++) {\r\nif (!prm->ureq[i].req) {\r\nreq = usb_ep_alloc_request(ep, GFP_ATOMIC);\r\nif (req == NULL)\r\nreturn -ENOMEM;\r\nprm->ureq[i].req = req;\r\nprm->ureq[i].pp = prm;\r\nreq->zero = 0;\r\nreq->context = &prm->ureq[i];\r\nreq->length = req_len;\r\nreq->complete = agdev_iso_complete;\r\nreq->buf = prm->rbuf + i * prm->max_psize;\r\n}\r\nif (usb_ep_queue(ep, prm->ureq[i].req, GFP_ATOMIC))\r\ndev_err(dev, "%s:%d Error!\n", __func__, __LINE__);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nafunc_get_alt(struct usb_function *fn, unsigned intf)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nif (intf == agdev->ac_intf)\r\nreturn agdev->ac_alt;\r\nelse if (intf == agdev->as_out_intf)\r\nreturn agdev->as_out_alt;\r\nelse if (intf == agdev->as_in_intf)\r\nreturn agdev->as_in_alt;\r\nelse\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Invalid Interface %d!\n",\r\n__func__, __LINE__, intf);\r\nreturn -EINVAL;\r\n}\r\nstatic void\r\nafunc_disable(struct usb_function *fn)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nfree_ep(&uac2->p_prm, agdev->in_ep);\r\nagdev->as_in_alt = 0;\r\nfree_ep(&uac2->c_prm, agdev->out_ep);\r\nagdev->as_out_alt = 0;\r\n}\r\nstatic int\r\nin_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_request *req = fn->config->cdev->req;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct f_uac2_opts *opts;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 entity_id = (w_index >> 8) & 0xff;\r\nu8 control_selector = w_value >> 8;\r\nint value = -EOPNOTSUPP;\r\nint p_srate, c_srate;\r\nopts = agdev_to_uac2_opts(agdev);\r\np_srate = opts->p_srate;\r\nc_srate = opts->c_srate;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\r\nstruct cntrl_cur_lay3 c;\r\nmemset(&c, 0, sizeof(struct cntrl_cur_lay3));\r\nif (entity_id == USB_IN_CLK_ID)\r\nc.dCUR = p_srate;\r\nelse if (entity_id == USB_OUT_CLK_ID)\r\nc.dCUR = c_srate;\r\nvalue = min_t(unsigned, w_length, sizeof c);\r\nmemcpy(req->buf, &c, value);\r\n} else if (control_selector == UAC2_CS_CONTROL_CLOCK_VALID) {\r\n*(u8 *)req->buf = 1;\r\nvalue = min_t(unsigned, w_length, 1);\r\n} else {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d control_selector=%d TODO!\n",\r\n__func__, __LINE__, control_selector);\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nin_rq_range(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_request *req = fn->config->cdev->req;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct f_uac2_opts *opts;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 entity_id = (w_index >> 8) & 0xff;\r\nu8 control_selector = w_value >> 8;\r\nstruct cntrl_range_lay3 r;\r\nint value = -EOPNOTSUPP;\r\nint p_srate, c_srate;\r\nopts = agdev_to_uac2_opts(agdev);\r\np_srate = opts->p_srate;\r\nc_srate = opts->c_srate;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {\r\nif (entity_id == USB_IN_CLK_ID)\r\nr.dMIN = p_srate;\r\nelse if (entity_id == USB_OUT_CLK_ID)\r\nr.dMIN = c_srate;\r\nelse\r\nreturn -EOPNOTSUPP;\r\nr.dMAX = r.dMIN;\r\nr.dRES = 0;\r\nr.wNumSubRanges = 1;\r\nvalue = min_t(unsigned, w_length, sizeof r);\r\nmemcpy(req->buf, &r, value);\r\n} else {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d control_selector=%d TODO!\n",\r\n__func__, __LINE__, control_selector);\r\n}\r\nreturn value;\r\n}\r\nstatic int\r\nac_rq_in(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nif (cr->bRequest == UAC2_CS_CUR)\r\nreturn in_rq_cur(fn, cr);\r\nelse if (cr->bRequest == UAC2_CS_RANGE)\r\nreturn in_rq_range(fn, cr);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nout_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nu16 w_value = le16_to_cpu(cr->wValue);\r\nu8 control_selector = w_value >> 8;\r\nif (control_selector == UAC2_CS_CONTROL_SAM_FREQ)\r\nreturn w_length;\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nsetup_rq_inf(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nu16 w_index = le16_to_cpu(cr->wIndex);\r\nu8 intf = w_index & 0xff;\r\nif (intf != agdev->ac_intf) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreturn -EOPNOTSUPP;\r\n}\r\nif (cr->bRequestType & USB_DIR_IN)\r\nreturn ac_rq_in(fn, cr);\r\nelse if (cr->bRequest == UAC2_CS_CUR)\r\nreturn out_rq_cur(fn, cr);\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int\r\nafunc_setup(struct usb_function *fn, const struct usb_ctrlrequest *cr)\r\n{\r\nstruct usb_composite_dev *cdev = fn->config->cdev;\r\nstruct audio_dev *agdev = func_to_agdev(fn);\r\nstruct snd_uac2_chip *uac2 = &agdev->uac2;\r\nstruct usb_request *req = cdev->req;\r\nu16 w_length = le16_to_cpu(cr->wLength);\r\nint value = -EOPNOTSUPP;\r\nif ((cr->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS)\r\nreturn -EOPNOTSUPP;\r\nif ((cr->bRequestType & USB_RECIP_MASK) == USB_RECIP_INTERFACE)\r\nvalue = setup_rq_inf(fn, cr);\r\nelse\r\ndev_err(&uac2->pdev.dev, "%s:%d Error!\n", __func__, __LINE__);\r\nif (value >= 0) {\r\nreq->length = value;\r\nreq->zero = value < w_length;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\ndev_err(&uac2->pdev.dev,\r\n"%s:%d Error!\n", __func__, __LINE__);\r\nreq->status = 0;\r\n}\r\n}\r\nreturn value;\r\n}\r\nstatic inline struct f_uac2_opts *to_f_uac2_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_uac2_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void f_uac2_attr_release(struct config_item *item)\r\n{\r\nstruct f_uac2_opts *opts = to_f_uac2_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic void afunc_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_uac2_opts *opts;\r\nopts = container_of(f, struct f_uac2_opts, func_inst);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *afunc_alloc_inst(void)\r\n{\r\nstruct f_uac2_opts *opts;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = afunc_free_inst;\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&f_uac2_func_type);\r\nopts->p_chmask = UAC2_DEF_PCHMASK;\r\nopts->p_srate = UAC2_DEF_PSRATE;\r\nopts->p_ssize = UAC2_DEF_PSSIZE;\r\nopts->c_chmask = UAC2_DEF_CCHMASK;\r\nopts->c_srate = UAC2_DEF_CSRATE;\r\nopts->c_ssize = UAC2_DEF_CSSIZE;\r\nopts->req_number = UAC2_DEF_REQ_NUM;\r\nreturn &opts->func_inst;\r\n}\r\nstatic void afunc_free(struct usb_function *f)\r\n{\r\nstruct audio_dev *agdev;\r\nstruct f_uac2_opts *opts;\r\nagdev = func_to_agdev(f);\r\nopts = container_of(f->fi, struct f_uac2_opts, func_inst);\r\nkfree(agdev);\r\nmutex_lock(&opts->lock);\r\n--opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void afunc_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct audio_dev *agdev = func_to_agdev(f);\r\nstruct uac2_rtd_params *prm;\r\nalsa_uac2_exit(agdev);\r\nprm = &agdev->uac2.p_prm;\r\nkfree(prm->rbuf);\r\nprm = &agdev->uac2.c_prm;\r\nkfree(prm->rbuf);\r\nkfree(prm->ureq);\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *afunc_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct audio_dev *agdev;\r\nstruct f_uac2_opts *opts;\r\nagdev = kzalloc(sizeof(*agdev), GFP_KERNEL);\r\nif (agdev == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_uac2_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\n++opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\nagdev->func.name = "uac2_func";\r\nagdev->func.bind = afunc_bind;\r\nagdev->func.unbind = afunc_unbind;\r\nagdev->func.set_alt = afunc_set_alt;\r\nagdev->func.get_alt = afunc_get_alt;\r\nagdev->func.disable = afunc_disable;\r\nagdev->func.setup = afunc_setup;\r\nagdev->func.free_func = afunc_free;\r\nreturn &agdev->func;\r\n}
