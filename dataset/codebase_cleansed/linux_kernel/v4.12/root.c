int proc_parse_options(char *options, struct pid_namespace *pid)\r\n{\r\nchar *p;\r\nsubstring_t args[MAX_OPT_ARGS];\r\nint option;\r\nif (!options)\r\nreturn 1;\r\nwhile ((p = strsep(&options, ",")) != NULL) {\r\nint token;\r\nif (!*p)\r\ncontinue;\r\nargs[0].to = args[0].from = NULL;\r\ntoken = match_token(p, tokens, args);\r\nswitch (token) {\r\ncase Opt_gid:\r\nif (match_int(&args[0], &option))\r\nreturn 0;\r\npid->pid_gid = make_kgid(current_user_ns(), option);\r\nbreak;\r\ncase Opt_hidepid:\r\nif (match_int(&args[0], &option))\r\nreturn 0;\r\nif (option < HIDEPID_OFF ||\r\noption > HIDEPID_INVISIBLE) {\r\npr_err("proc: hidepid value must be between 0 and 2.\n");\r\nreturn 0;\r\n}\r\npid->hide_pid = option;\r\nbreak;\r\ndefault:\r\npr_err("proc: unrecognized mount option \"%s\" "\r\n"or missing value\n", p);\r\nreturn 0;\r\n}\r\n}\r\nreturn 1;\r\n}\r\nint proc_remount(struct super_block *sb, int *flags, char *data)\r\n{\r\nstruct pid_namespace *pid = sb->s_fs_info;\r\nsync_filesystem(sb);\r\nreturn !proc_parse_options(data, pid);\r\n}\r\nstatic struct dentry *proc_mount(struct file_system_type *fs_type,\r\nint flags, const char *dev_name, void *data)\r\n{\r\nstruct pid_namespace *ns;\r\nif (flags & MS_KERNMOUNT) {\r\nns = data;\r\ndata = NULL;\r\n} else {\r\nns = task_active_pid_ns(current);\r\n}\r\nreturn mount_ns(fs_type, flags, data, ns, ns->user_ns, proc_fill_super);\r\n}\r\nstatic void proc_kill_sb(struct super_block *sb)\r\n{\r\nstruct pid_namespace *ns;\r\nns = (struct pid_namespace *)sb->s_fs_info;\r\nif (ns->proc_self)\r\ndput(ns->proc_self);\r\nif (ns->proc_thread_self)\r\ndput(ns->proc_thread_self);\r\nkill_anon_super(sb);\r\nput_pid_ns(ns);\r\n}\r\nvoid __init proc_root_init(void)\r\n{\r\nint err;\r\nproc_init_inodecache();\r\nset_proc_pid_nlink();\r\nerr = register_filesystem(&proc_fs_type);\r\nif (err)\r\nreturn;\r\nproc_self_init();\r\nproc_thread_self_init();\r\nproc_symlink("mounts", NULL, "self/mounts");\r\nproc_net_init();\r\n#ifdef CONFIG_SYSVIPC\r\nproc_mkdir("sysvipc", NULL);\r\n#endif\r\nproc_mkdir("fs", NULL);\r\nproc_mkdir("driver", NULL);\r\nproc_create_mount_point("fs/nfsd");\r\n#if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)\r\nproc_create_mount_point("openprom");\r\n#endif\r\nproc_tty_init();\r\nproc_mkdir("bus", NULL);\r\nproc_sys_init();\r\n}\r\nstatic int proc_root_getattr(const struct path *path, struct kstat *stat,\r\nu32 request_mask, unsigned int query_flags)\r\n{\r\ngeneric_fillattr(d_inode(path->dentry), stat);\r\nstat->nlink = proc_root.nlink + nr_processes();\r\nreturn 0;\r\n}\r\nstatic struct dentry *proc_root_lookup(struct inode * dir, struct dentry * dentry, unsigned int flags)\r\n{\r\nif (!proc_pid_lookup(dir, dentry, flags))\r\nreturn NULL;\r\nreturn proc_lookup(dir, dentry, flags);\r\n}\r\nstatic int proc_root_readdir(struct file *file, struct dir_context *ctx)\r\n{\r\nif (ctx->pos < FIRST_PROCESS_ENTRY) {\r\nint error = proc_readdir(file, ctx);\r\nif (unlikely(error <= 0))\r\nreturn error;\r\nctx->pos = FIRST_PROCESS_ENTRY;\r\n}\r\nreturn proc_pid_readdir(file, ctx);\r\n}\r\nint pid_ns_prepare_proc(struct pid_namespace *ns)\r\n{\r\nstruct vfsmount *mnt;\r\nmnt = kern_mount_data(&proc_fs_type, ns);\r\nif (IS_ERR(mnt))\r\nreturn PTR_ERR(mnt);\r\nns->proc_mnt = mnt;\r\nreturn 0;\r\n}\r\nvoid pid_ns_release_proc(struct pid_namespace *ns)\r\n{\r\nkern_unmount(ns->proc_mnt);\r\n}
