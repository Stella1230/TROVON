void ctcmpc_dumpit(char *buf, int len)\r\n{\r\n__u32 ct, sw, rm, dup;\r\nchar *ptr, *rptr;\r\nchar tbuf[82], tdup[82];\r\nchar addr[22];\r\nchar boff[12];\r\nchar bhex[82], duphex[82];\r\nchar basc[40];\r\nsw = 0;\r\nrptr = ptr = buf;\r\nrm = 16;\r\nduphex[0] = 0x00;\r\ndup = 0;\r\nfor (ct = 0; ct < len; ct++, ptr++, rptr++) {\r\nif (sw == 0) {\r\nsprintf(addr, "%16.16llx", (__u64)rptr);\r\nsprintf(boff, "%4.4X", (__u32)ct);\r\nbhex[0] = '\0';\r\nbasc[0] = '\0';\r\n}\r\nif ((sw == 4) || (sw == 12))\r\nstrcat(bhex, " ");\r\nif (sw == 8)\r\nstrcat(bhex, " ");\r\nsprintf(tbuf, "%2.2llX", (__u64)*ptr);\r\ntbuf[2] = '\0';\r\nstrcat(bhex, tbuf);\r\nif ((0 != isprint(*ptr)) && (*ptr >= 0x20))\r\nbasc[sw] = *ptr;\r\nelse\r\nbasc[sw] = '.';\r\nbasc[sw+1] = '\0';\r\nsw++;\r\nrm--;\r\nif (sw != 16)\r\ncontinue;\r\nif ((strcmp(duphex, bhex)) != 0) {\r\nif (dup != 0) {\r\nsprintf(tdup,\r\n"Duplicate as above to %s", addr);\r\nctcm_pr_debug(" --- %s ---\n",\r\ntdup);\r\n}\r\nctcm_pr_debug(" %s (+%s) : %s [%s]\n",\r\naddr, boff, bhex, basc);\r\ndup = 0;\r\nstrcpy(duphex, bhex);\r\n} else\r\ndup++;\r\nsw = 0;\r\nrm = 16;\r\n}\r\nif (sw != 0) {\r\nfor ( ; rm > 0; rm--, sw++) {\r\nif ((sw == 4) || (sw == 12))\r\nstrcat(bhex, " ");\r\nif (sw == 8)\r\nstrcat(bhex, " ");\r\nstrcat(bhex, " ");\r\nstrcat(basc, " ");\r\n}\r\nif (dup != 0) {\r\nsprintf(tdup, "Duplicate as above to %s", addr);\r\nctcm_pr_debug(" --- %s ---\n", tdup);\r\n}\r\nctcm_pr_debug(" %s (+%s) : %s [%s]\n",\r\naddr, boff, bhex, basc);\r\n} else {\r\nif (dup >= 1) {\r\nsprintf(tdup, "Duplicate as above to %s", addr);\r\nctcm_pr_debug(" --- %s ---\n", tdup);\r\n}\r\nif (dup != 0) {\r\nctcm_pr_debug(" %s (+%s) : %s [%s]\n",\r\naddr, boff, bhex, basc);\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid ctcmpc_dump_skb(struct sk_buff *skb, int offset)\r\n{\r\n__u8 *p = skb->data;\r\nstruct th_header *header;\r\nstruct pdu *pheader;\r\nint bl = skb->len;\r\nint i;\r\nif (p == NULL)\r\nreturn;\r\np += offset;\r\nheader = (struct th_header *)p;\r\nctcm_pr_debug("dump:\n");\r\nctcm_pr_debug("skb len=%d \n", skb->len);\r\nif (skb->len > 2) {\r\nswitch (header->th_ch_flag) {\r\ncase TH_HAS_PDU:\r\nbreak;\r\ncase 0x00:\r\ncase TH_IS_XID:\r\nif ((header->th_blk_flag == TH_DATA_IS_XID) &&\r\n(header->th_is_xid == 0x01))\r\ngoto dumpth;\r\ncase TH_SWEEP_REQ:\r\ngoto dumpth;\r\ncase TH_SWEEP_RESP:\r\ngoto dumpth;\r\ndefault:\r\nbreak;\r\n}\r\npheader = (struct pdu *)p;\r\nctcm_pr_debug("pdu->offset: %d hex: %04x\n",\r\npheader->pdu_offset, pheader->pdu_offset);\r\nctcm_pr_debug("pdu->flag : %02x\n", pheader->pdu_flag);\r\nctcm_pr_debug("pdu->proto : %02x\n", pheader->pdu_proto);\r\nctcm_pr_debug("pdu->seq : %02x\n", pheader->pdu_seq);\r\ngoto dumpdata;\r\ndumpth:\r\nctcm_pr_debug("th->seg : %02x\n", header->th_seg);\r\nctcm_pr_debug("th->ch : %02x\n", header->th_ch_flag);\r\nctcm_pr_debug("th->blk_flag: %02x\n", header->th_blk_flag);\r\nctcm_pr_debug("th->type : %s\n",\r\n(header->th_is_xid) ? "DATA" : "XID");\r\nctcm_pr_debug("th->seqnum : %04x\n", header->th_seq_num);\r\n}\r\ndumpdata:\r\nif (bl > 32)\r\nbl = 32;\r\nctcm_pr_debug("data: ");\r\nfor (i = 0; i < bl; i++)\r\nctcm_pr_debug("%02x%s", *p++, (i % 16) ? " " : "\n");\r\nctcm_pr_debug("\n");\r\n}\r\nstatic struct net_device *ctcmpc_get_dev(int port_num)\r\n{\r\nchar device[20];\r\nstruct net_device *dev;\r\nstruct ctcm_priv *priv;\r\nsprintf(device, "%s%i", MPC_DEVICE_NAME, port_num);\r\ndev = __dev_get_by_name(&init_net, device);\r\nif (dev == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s: Device not found by name: %s",\r\nCTCM_FUNTAIL, device);\r\nreturn NULL;\r\n}\r\npriv = dev->ml_priv;\r\nif (priv == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): dev->ml_priv is NULL",\r\nCTCM_FUNTAIL, device);\r\nreturn NULL;\r\n}\r\nif (priv->mpcg == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): priv->mpcg is NULL",\r\nCTCM_FUNTAIL, device);\r\nreturn NULL;\r\n}\r\nreturn dev;\r\n}\r\nint ctc_mpc_alloc_channel(int port_num, void (*callback)(int, int))\r\n{\r\nstruct net_device *dev;\r\nstruct mpc_group *grp;\r\nstruct ctcm_priv *priv;\r\ndev = ctcmpc_get_dev(port_num);\r\nif (dev == NULL)\r\nreturn 1;\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\ngrp->allochanfunc = callback;\r\ngrp->port_num = port_num;\r\ngrp->port_persist = 1;\r\nCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_INFO,\r\n"%s(%s): state=%s",\r\nCTCM_FUNTAIL, dev->name, fsm_getstate_str(grp->fsm));\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_INOP:\r\ngrp->alloc_called = 1;\r\nbreak;\r\ncase MPCG_STATE_RESET:\r\nif (callback)\r\ngrp->send_qllc_disc = 1;\r\ncase MPCG_STATE_XID0IOWAIT:\r\nfsm_deltimer(&grp->timer);\r\ngrp->outstanding_xid2 = 0;\r\ngrp->outstanding_xid7 = 0;\r\ngrp->outstanding_xid7_p2 = 0;\r\ngrp->saved_xid2 = NULL;\r\nif (callback)\r\nctcm_open(dev);\r\nfsm_event(priv->fsm, DEV_EVENT_START, dev);\r\nbreak;\r\ncase MPCG_STATE_READY:\r\ngrp->allocchan_callback_retries++;\r\nif (grp->allocchan_callback_retries < 4) {\r\nif (grp->allochanfunc)\r\ngrp->allochanfunc(grp->port_num,\r\ngrp->group_max_buflen);\r\n} else {\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngrp->allocchan_callback_retries = 0;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid ctc_mpc_establish_connectivity(int port_num,\r\nvoid (*callback)(int, int, int))\r\n{\r\nstruct net_device *dev;\r\nstruct mpc_group *grp;\r\nstruct ctcm_priv *priv;\r\nstruct channel *rch, *wch;\r\ndev = ctcmpc_get_dev(port_num);\r\nif (dev == NULL)\r\nreturn;\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\nrch = priv->channel[CTCM_READ];\r\nwch = priv->channel[CTCM_WRITE];\r\nCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_INFO,\r\n"%s(%s): state=%s",\r\nCTCM_FUNTAIL, dev->name, fsm_getstate_str(grp->fsm));\r\ngrp->estconnfunc = callback;\r\ngrp->port_num = port_num;\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_READY:\r\nfsm_deltimer(&grp->timer);\r\ngrp->estconn_callback_retries++;\r\nif (grp->estconn_callback_retries < 4) {\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, 0,\r\ngrp->group_max_buflen);\r\ngrp->estconnfunc = NULL;\r\n}\r\n} else {\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngrp->estconn_callback_retries = 0;\r\n}\r\nbreak;\r\ncase MPCG_STATE_INOP:\r\ncase MPCG_STATE_RESET:\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): REJECTED - inactive channels",\r\nCTCM_FUNTAIL, dev->name);\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, -1, 0);\r\ngrp->estconnfunc = NULL;\r\n}\r\nbreak;\r\ncase MPCG_STATE_XID2INITW:\r\nif ((fsm_getstate(rch->fsm) > CH_XID0_PENDING) ||\r\n(fsm_getstate(wch->fsm) > CH_XID0_PENDING)) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): ABORT - PASSIVE XID",\r\nCTCM_FUNTAIL, dev->name);\r\nbreak;\r\n}\r\ngrp->send_qllc_disc = 1;\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID0IOWAIT);\r\nfsm_deltimer(&grp->timer);\r\nfsm_addtimer(&grp->timer, MPC_XID_TIMEOUT_VALUE,\r\nMPCG_EVENT_TIMER, dev);\r\ngrp->outstanding_xid7 = 0;\r\ngrp->outstanding_xid7_p2 = 0;\r\ngrp->saved_xid2 = NULL;\r\nif ((rch->in_mpcgroup) &&\r\n(fsm_getstate(rch->fsm) == CH_XID0_PENDING))\r\nfsm_event(grp->fsm, MPCG_EVENT_XID0DO, rch);\r\nelse {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): RX-%s not ready for ACTIVE XID0",\r\nCTCM_FUNTAIL, dev->name, rch->id);\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, -1, 0);\r\ngrp->estconnfunc = NULL;\r\n}\r\nfsm_deltimer(&grp->timer);\r\ngoto done;\r\n}\r\nif ((wch->in_mpcgroup) &&\r\n(fsm_getstate(wch->fsm) == CH_XID0_PENDING))\r\nfsm_event(grp->fsm, MPCG_EVENT_XID0DO, wch);\r\nelse {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): WX-%s not ready for ACTIVE XID0",\r\nCTCM_FUNTAIL, dev->name, wch->id);\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, -1, 0);\r\ngrp->estconnfunc = NULL;\r\n}\r\nfsm_deltimer(&grp->timer);\r\ngoto done;\r\n}\r\nbreak;\r\ncase MPCG_STATE_XID0IOWAIT:\r\ndefault:\r\nbreak;\r\n}\r\ndone:\r\nCTCM_PR_DEBUG("Exit %s()\n", __func__);\r\nreturn;\r\n}\r\nvoid ctc_mpc_dealloc_ch(int port_num)\r\n{\r\nstruct net_device *dev;\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\ndev = ctcmpc_get_dev(port_num);\r\nif (dev == NULL)\r\nreturn;\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\nCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_DEBUG,\r\n"%s: %s: refcount = %d\n",\r\nCTCM_FUNTAIL, dev->name, netdev_refcnt_read(dev));\r\nfsm_deltimer(&priv->restart_timer);\r\ngrp->channels_terminating = 0;\r\nfsm_deltimer(&grp->timer);\r\ngrp->allochanfunc = NULL;\r\ngrp->estconnfunc = NULL;\r\ngrp->port_persist = 0;\r\ngrp->send_qllc_disc = 0;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\nctcm_close(dev);\r\nreturn;\r\n}\r\nvoid ctc_mpc_flow_control(int port_num, int flowc)\r\n{\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\nstruct net_device *dev;\r\nstruct channel *rch;\r\nint mpcg_state;\r\ndev = ctcmpc_get_dev(port_num);\r\nif (dev == NULL)\r\nreturn;\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\r\n"%s: %s: flowc = %d",\r\nCTCM_FUNTAIL, dev->name, flowc);\r\nrch = priv->channel[CTCM_READ];\r\nmpcg_state = fsm_getstate(grp->fsm);\r\nswitch (flowc) {\r\ncase 1:\r\nif (mpcg_state == MPCG_STATE_FLOWC)\r\nbreak;\r\nif (mpcg_state == MPCG_STATE_READY) {\r\nif (grp->flow_off_called == 1)\r\ngrp->flow_off_called = 0;\r\nelse\r\nfsm_newstate(grp->fsm, MPCG_STATE_FLOWC);\r\nbreak;\r\n}\r\nbreak;\r\ncase 0:\r\nif (mpcg_state == MPCG_STATE_FLOWC) {\r\nfsm_newstate(grp->fsm, MPCG_STATE_READY);\r\ntasklet_schedule(&rch->ch_tasklet);\r\n}\r\nif (mpcg_state == MPCG_STATE_READY) {\r\ngrp->flow_off_called = 1;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic void mpc_rcvd_sweep_resp(struct mpcg_info *mpcginfo)\r\n{\r\nstruct channel *rch = mpcginfo->ch;\r\nstruct net_device *dev = rch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct channel *ch = priv->channel[CTCM_WRITE];\r\nCTCM_PR_DEBUG("%s: ch=0x%p id=%s\n", __func__, ch, ch->id);\r\nCTCM_D3_DUMP((char *)mpcginfo->sweep, TH_SWEEP_LENGTH);\r\ngrp->sweep_rsp_pend_num--;\r\nif ((grp->sweep_req_pend_num == 0) &&\r\n(grp->sweep_rsp_pend_num == 0)) {\r\nfsm_deltimer(&ch->sweep_timer);\r\ngrp->in_sweep = 0;\r\nrch->th_seq_num = 0x00;\r\nch->th_seq_num = 0x00;\r\nctcm_clear_busy_do(dev);\r\n}\r\nkfree(mpcginfo);\r\nreturn;\r\n}\r\nstatic void ctcmpc_send_sweep_resp(struct channel *rch)\r\n{\r\nstruct net_device *dev = rch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct th_sweep *header;\r\nstruct sk_buff *sweep_skb;\r\nstruct channel *ch = priv->channel[CTCM_WRITE];\r\nCTCM_PR_DEBUG("%s: ch=0x%p id=%s\n", __func__, rch, rch->id);\r\nsweep_skb = __dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC | GFP_DMA);\r\nif (sweep_skb == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): sweep_skb allocation ERROR\n",\r\nCTCM_FUNTAIL, rch->id);\r\ngoto done;\r\n}\r\nheader = kmalloc(sizeof(struct th_sweep), gfp_type());\r\nif (!header) {\r\ndev_kfree_skb_any(sweep_skb);\r\ngoto done;\r\n}\r\nheader->th.th_seg = 0x00 ;\r\nheader->th.th_ch_flag = TH_SWEEP_RESP;\r\nheader->th.th_blk_flag = 0x00;\r\nheader->th.th_is_xid = 0x00;\r\nheader->th.th_seq_num = 0x00;\r\nheader->sw.th_last_seq = ch->th_seq_num;\r\nmemcpy(skb_put(sweep_skb, TH_SWEEP_LENGTH), header, TH_SWEEP_LENGTH);\r\nkfree(header);\r\nnetif_trans_update(dev);\r\nskb_queue_tail(&ch->sweep_queue, sweep_skb);\r\nfsm_addtimer(&ch->sweep_timer, 100, CTC_EVENT_RSWEEP_TIMER, ch);\r\nreturn;\r\ndone:\r\ngrp->in_sweep = 0;\r\nctcm_clear_busy_do(dev);\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\nreturn;\r\n}\r\nstatic void mpc_rcvd_sweep_req(struct mpcg_info *mpcginfo)\r\n{\r\nstruct channel *rch = mpcginfo->ch;\r\nstruct net_device *dev = rch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct channel *ch = priv->channel[CTCM_WRITE];\r\nif (do_debug)\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\r\n" %s(): ch=0x%p id=%s\n", __func__, ch, ch->id);\r\nif (grp->in_sweep == 0) {\r\ngrp->in_sweep = 1;\r\nctcm_test_and_set_busy(dev);\r\ngrp->sweep_req_pend_num = grp->active_channels[CTCM_READ];\r\ngrp->sweep_rsp_pend_num = grp->active_channels[CTCM_READ];\r\n}\r\nCTCM_D3_DUMP((char *)mpcginfo->sweep, TH_SWEEP_LENGTH);\r\ngrp->sweep_req_pend_num--;\r\nctcmpc_send_sweep_resp(ch);\r\nkfree(mpcginfo);\r\nreturn;\r\n}\r\nstatic void mpc_action_go_ready(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nif (grp == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): No MPC group",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn;\r\n}\r\nfsm_deltimer(&grp->timer);\r\nif (grp->saved_xid2->xid2_flag2 == 0x40) {\r\npriv->xid->xid2_flag2 = 0x00;\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, 1,\r\ngrp->group_max_buflen);\r\ngrp->estconnfunc = NULL;\r\n} else if (grp->allochanfunc)\r\ngrp->send_qllc_disc = 1;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): fails",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn;\r\n}\r\ngrp->port_persist = 1;\r\ngrp->out_of_sequence = 0;\r\ngrp->estconn_called = 0;\r\ntasklet_hi_schedule(&grp->mpc_tasklet2);\r\nreturn;\r\n}\r\nvoid mpc_group_ready(unsigned long adev)\r\n{\r\nstruct net_device *dev = (struct net_device *)adev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct channel *ch = NULL;\r\nif (grp == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): No MPC group",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn;\r\n}\r\nCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_NOTICE,\r\n"%s: %s: GROUP TRANSITIONED TO READY, maxbuf = %d\n",\r\nCTCM_FUNTAIL, dev->name, grp->group_max_buflen);\r\nfsm_newstate(grp->fsm, MPCG_STATE_READY);\r\nch = priv->channel[CTCM_READ];\r\nch->pdu_seq = 0;\r\nCTCM_PR_DBGDATA("ctcmpc: %s() ToDCM_pdu_seq= %08x\n" ,\r\n__func__, ch->pdu_seq);\r\nctcmpc_chx_rxidle(ch->fsm, CTC_EVENT_START, ch);\r\nch = priv->channel[CTCM_WRITE];\r\nif (ch->collect_len > 0) {\r\nspin_lock(&ch->collect_lock);\r\nctcm_purge_skb_queue(&ch->collect_queue);\r\nch->collect_len = 0;\r\nspin_unlock(&ch->collect_lock);\r\n}\r\nctcm_chx_txidle(ch->fsm, CTC_EVENT_START, ch);\r\nctcm_clear_busy(dev);\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, 0,\r\ngrp->group_max_buflen);\r\ngrp->estconnfunc = NULL;\r\n} else if (grp->allochanfunc)\r\ngrp->allochanfunc(grp->port_num, grp->group_max_buflen);\r\ngrp->send_qllc_disc = 1;\r\ngrp->changed_side = 0;\r\nreturn;\r\n}\r\nvoid mpc_channel_action(struct channel *ch, int direction, int action)\r\n{\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nif (grp == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): No MPC group",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn;\r\n}\r\nCTCM_PR_DEBUG("enter %s: ch=0x%p id=%s\n", __func__, ch, ch->id);\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\r\n"%s: %i / Grp:%s total_channels=%i, active_channels: "\r\n"read=%i, write=%i\n", __func__, action,\r\nfsm_getstate_str(grp->fsm), grp->num_channel_paths,\r\ngrp->active_channels[CTCM_READ],\r\ngrp->active_channels[CTCM_WRITE]);\r\nif ((action == MPC_CHANNEL_ADD) && (ch->in_mpcgroup == 0)) {\r\ngrp->num_channel_paths++;\r\ngrp->active_channels[direction]++;\r\ngrp->outstanding_xid2++;\r\nch->in_mpcgroup = 1;\r\nif (ch->xid_skb != NULL)\r\ndev_kfree_skb_any(ch->xid_skb);\r\nch->xid_skb = __dev_alloc_skb(MPC_BUFSIZE_DEFAULT,\r\nGFP_ATOMIC | GFP_DMA);\r\nif (ch->xid_skb == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Couldn't alloc ch xid_skb\n",\r\nCTCM_FUNTAIL, dev->name);\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\nreturn;\r\n}\r\nch->xid_skb_data = ch->xid_skb->data;\r\nch->xid_th = (struct th_header *)ch->xid_skb->data;\r\nskb_put(ch->xid_skb, TH_HEADER_LENGTH);\r\nch->xid = (struct xid2 *)skb_tail_pointer(ch->xid_skb);\r\nskb_put(ch->xid_skb, XID2_LENGTH);\r\nch->xid_id = skb_tail_pointer(ch->xid_skb);\r\nch->xid_skb->data = ch->xid_skb_data;\r\nskb_reset_tail_pointer(ch->xid_skb);\r\nch->xid_skb->len = 0;\r\nmemcpy(skb_put(ch->xid_skb, grp->xid_skb->len),\r\ngrp->xid_skb->data,\r\ngrp->xid_skb->len);\r\nch->xid->xid2_dlc_type =\r\n((CHANNEL_DIRECTION(ch->flags) == CTCM_READ)\r\n? XID2_READ_SIDE : XID2_WRITE_SIDE);\r\nif (CHANNEL_DIRECTION(ch->flags) == CTCM_WRITE)\r\nch->xid->xid2_buf_len = 0x00;\r\nch->xid_skb->data = ch->xid_skb_data;\r\nskb_reset_tail_pointer(ch->xid_skb);\r\nch->xid_skb->len = 0;\r\nfsm_newstate(ch->fsm, CH_XID0_PENDING);\r\nif ((grp->active_channels[CTCM_READ] > 0) &&\r\n(grp->active_channels[CTCM_WRITE] > 0) &&\r\n(fsm_getstate(grp->fsm) < MPCG_STATE_XID2INITW)) {\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID2INITW);\r\nCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_NOTICE,\r\n"%s: %s: MPC GROUP CHANNELS ACTIVE\n",\r\n__func__, dev->name);\r\n}\r\n} else if ((action == MPC_CHANNEL_REMOVE) &&\r\n(ch->in_mpcgroup == 1)) {\r\nch->in_mpcgroup = 0;\r\ngrp->num_channel_paths--;\r\ngrp->active_channels[direction]--;\r\nif (ch->xid_skb != NULL)\r\ndev_kfree_skb_any(ch->xid_skb);\r\nch->xid_skb = NULL;\r\nif (grp->channels_terminating)\r\ngoto done;\r\nif (((grp->active_channels[CTCM_READ] == 0) &&\r\n(grp->active_channels[CTCM_WRITE] > 0))\r\n|| ((grp->active_channels[CTCM_WRITE] == 0) &&\r\n(grp->active_channels[CTCM_READ] > 0)))\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\n}\r\ndone:\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\r\n"exit %s: %i / Grp:%s total_channels=%i, active_channels: "\r\n"read=%i, write=%i\n", __func__, action,\r\nfsm_getstate_str(grp->fsm), grp->num_channel_paths,\r\ngrp->active_channels[CTCM_READ],\r\ngrp->active_channels[CTCM_WRITE]);\r\nCTCM_PR_DEBUG("exit %s: ch=0x%p id=%s\n", __func__, ch, ch->id);\r\n}\r\nstatic void ctcmpc_unpack_skb(struct channel *ch, struct sk_buff *pskb)\r\n{\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct pdu *curr_pdu;\r\nstruct mpcg_info *mpcginfo;\r\nstruct th_header *header = NULL;\r\nstruct th_sweep *sweep = NULL;\r\nint pdu_last_seen = 0;\r\n__u32 new_len;\r\nstruct sk_buff *skb;\r\nint skblen;\r\nint sendrc = 0;\r\nCTCM_PR_DEBUG("ctcmpc enter: %s() %s cp:%i ch:%s\n",\r\n__func__, dev->name, smp_processor_id(), ch->id);\r\nheader = (struct th_header *)pskb->data;\r\nif ((header->th_seg == 0) &&\r\n(header->th_ch_flag == 0) &&\r\n(header->th_blk_flag == 0) &&\r\n(header->th_seq_num == 0))\r\ngoto done;\r\nCTCM_PR_DBGDATA("%s: th_header\n", __func__);\r\nCTCM_D3_DUMP((char *)header, TH_HEADER_LENGTH);\r\nCTCM_PR_DBGDATA("%s: pskb len: %04x \n", __func__, pskb->len);\r\npskb->dev = dev;\r\npskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb_pull(pskb, TH_HEADER_LENGTH);\r\nif (likely(header->th_ch_flag == TH_HAS_PDU)) {\r\nCTCM_PR_DBGDATA("%s: came into th_has_pdu\n", __func__);\r\nif ((fsm_getstate(grp->fsm) == MPCG_STATE_FLOWC) ||\r\n((fsm_getstate(grp->fsm) == MPCG_STATE_READY) &&\r\n(header->th_seq_num != ch->th_seq_num + 1) &&\r\n(ch->th_seq_num != 0))) {\r\ngrp->out_of_sequence += 1;\r\n__skb_push(pskb, TH_HEADER_LENGTH);\r\nskb_queue_tail(&ch->io_queue, pskb);\r\nCTCM_PR_DBGDATA("%s: th_seq_num expect:%08x "\r\n"got:%08x\n", __func__,\r\nch->th_seq_num + 1, header->th_seq_num);\r\nreturn;\r\n}\r\ngrp->out_of_sequence = 0;\r\nch->th_seq_num = header->th_seq_num;\r\nCTCM_PR_DBGDATA("ctcmpc: %s() FromVTAM_th_seq=%08x\n",\r\n__func__, ch->th_seq_num);\r\nif (unlikely(fsm_getstate(grp->fsm) != MPCG_STATE_READY))\r\ngoto done;\r\nwhile ((pskb->len > 0) && !pdu_last_seen) {\r\ncurr_pdu = (struct pdu *)pskb->data;\r\nCTCM_PR_DBGDATA("%s: pdu_header\n", __func__);\r\nCTCM_D3_DUMP((char *)pskb->data, PDU_HEADER_LENGTH);\r\nCTCM_PR_DBGDATA("%s: pskb len: %04x \n",\r\n__func__, pskb->len);\r\nskb_pull(pskb, PDU_HEADER_LENGTH);\r\nif (curr_pdu->pdu_flag & PDU_LAST)\r\npdu_last_seen = 1;\r\nif (curr_pdu->pdu_flag & PDU_CNTL)\r\npskb->protocol = htons(ETH_P_SNAP);\r\nelse\r\npskb->protocol = htons(ETH_P_SNA_DIX);\r\nif ((pskb->len <= 0) || (pskb->len > ch->max_bufsize)) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Dropping packet with "\r\n"illegal siize %d",\r\nCTCM_FUNTAIL, dev->name, pskb->len);\r\npriv->stats.rx_dropped++;\r\npriv->stats.rx_length_errors++;\r\ngoto done;\r\n}\r\nskb_reset_mac_header(pskb);\r\nnew_len = curr_pdu->pdu_offset;\r\nCTCM_PR_DBGDATA("%s: new_len: %04x \n",\r\n__func__, new_len);\r\nif ((new_len == 0) || (new_len > pskb->len)) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): non valid pdu_offset: %04x",\r\nCTCM_FUNTAIL, dev->name, new_len);\r\ngoto done;\r\n}\r\nskb = __dev_alloc_skb(new_len+4, GFP_ATOMIC);\r\nif (!skb) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): MEMORY allocation error",\r\nCTCM_FUNTAIL, dev->name);\r\npriv->stats.rx_dropped++;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\ngoto done;\r\n}\r\nmemcpy(skb_put(skb, new_len), pskb->data, new_len);\r\nskb_reset_mac_header(skb);\r\nskb->dev = pskb->dev;\r\nskb->protocol = pskb->protocol;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\n*((__u32 *) skb_push(skb, 4)) = ch->pdu_seq;\r\nch->pdu_seq++;\r\nif (do_debug_data) {\r\nctcm_pr_debug("%s: ToDCM_pdu_seq= %08x\n",\r\n__func__, ch->pdu_seq);\r\nctcm_pr_debug("%s: skb:%0lx "\r\n"skb len: %d \n", __func__,\r\n(unsigned long)skb, skb->len);\r\nctcm_pr_debug("%s: up to 32 bytes "\r\n"of pdu_data sent\n", __func__);\r\nctcmpc_dump32((char *)skb->data, skb->len);\r\n}\r\nskblen = skb->len;\r\nsendrc = netif_rx(skb);\r\npriv->stats.rx_packets++;\r\npriv->stats.rx_bytes += skblen;\r\nskb_pull(pskb, new_len);\r\n}\r\n} else {\r\nmpcginfo = kmalloc(sizeof(struct mpcg_info), gfp_type());\r\nif (mpcginfo == NULL)\r\ngoto done;\r\nmpcginfo->ch = ch;\r\nmpcginfo->th = header;\r\nmpcginfo->skb = pskb;\r\nCTCM_PR_DEBUG("%s: Not PDU - may be control pkt\n",\r\n__func__);\r\nsweep = (struct th_sweep *)pskb->data;\r\nmpcginfo->sweep = sweep;\r\nif (header->th_ch_flag == TH_SWEEP_REQ)\r\nmpc_rcvd_sweep_req(mpcginfo);\r\nelse if (header->th_ch_flag == TH_SWEEP_RESP)\r\nmpc_rcvd_sweep_resp(mpcginfo);\r\nelse if (header->th_blk_flag == TH_DATA_IS_XID) {\r\nstruct xid2 *thisxid = (struct xid2 *)pskb->data;\r\nskb_pull(pskb, XID2_LENGTH);\r\nmpcginfo->xid = thisxid;\r\nfsm_event(grp->fsm, MPCG_EVENT_XID2, mpcginfo);\r\n} else if (header->th_blk_flag == TH_DISCONTACT)\r\nfsm_event(grp->fsm, MPCG_EVENT_DISCONC, mpcginfo);\r\nelse if (header->th_seq_num != 0) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): control pkt expected\n",\r\nCTCM_FUNTAIL, dev->name);\r\npriv->stats.rx_dropped++;\r\nkfree(mpcginfo);\r\nif (do_debug_data)\r\nctcmpc_dump_skb(pskb, -8);\r\n}\r\n}\r\ndone:\r\ndev_kfree_skb_any(pskb);\r\nif (sendrc == NET_RX_DROP) {\r\ndev_warn(&dev->dev,\r\n"The network backlog for %s is exceeded, "\r\n"package dropped\n", __func__);\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\n}\r\nCTCM_PR_DEBUG("exit %s: %s: ch=0x%p id=%s\n",\r\n__func__, dev->name, ch, ch->id);\r\n}\r\nvoid ctcmpc_bh(unsigned long thischan)\r\n{\r\nstruct channel *ch = (struct channel *)thischan;\r\nstruct sk_buff *skb;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("%s cp:%i enter: %s() %s\n",\r\ndev->name, smp_processor_id(), __func__, ch->id);\r\nwhile ((fsm_getstate(grp->fsm) != MPCG_STATE_FLOWC) &&\r\n(skb = skb_dequeue(&ch->io_queue))) {\r\nctcmpc_unpack_skb(ch, skb);\r\nif (grp->out_of_sequence > 20) {\r\ngrp->out_of_sequence = 0;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\nbreak;\r\n}\r\nif (skb == skb_peek(&ch->io_queue))\r\nbreak;\r\n}\r\nCTCM_PR_DEBUG("exit %s: %s: ch=0x%p id=%s\n",\r\n__func__, dev->name, ch, ch->id);\r\nreturn;\r\n}\r\nstruct mpc_group *ctcmpc_init_mpc_group(struct ctcm_priv *priv)\r\n{\r\nstruct mpc_group *grp;\r\nCTCM_DBF_TEXT_(MPC_SETUP, CTC_DBF_INFO,\r\n"Enter %s(%p)", CTCM_FUNTAIL, priv);\r\ngrp = kzalloc(sizeof(struct mpc_group), GFP_KERNEL);\r\nif (grp == NULL)\r\nreturn NULL;\r\ngrp->fsm = init_fsm("mpcg", mpcg_state_names, mpcg_event_names,\r\nMPCG_NR_STATES, MPCG_NR_EVENTS, mpcg_fsm,\r\nmpcg_fsm_len, GFP_KERNEL);\r\nif (grp->fsm == NULL) {\r\nkfree(grp);\r\nreturn NULL;\r\n}\r\nfsm_newstate(grp->fsm, MPCG_STATE_RESET);\r\nfsm_settimer(grp->fsm, &grp->timer);\r\ngrp->xid_skb =\r\n__dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC | GFP_DMA);\r\nif (grp->xid_skb == NULL) {\r\nkfree_fsm(grp->fsm);\r\nkfree(grp);\r\nreturn NULL;\r\n}\r\ngrp->xid_skb_data = grp->xid_skb->data;\r\ngrp->xid_th = (struct th_header *)grp->xid_skb->data;\r\nmemcpy(skb_put(grp->xid_skb, TH_HEADER_LENGTH),\r\n&thnorm, TH_HEADER_LENGTH);\r\ngrp->xid = (struct xid2 *)skb_tail_pointer(grp->xid_skb);\r\nmemcpy(skb_put(grp->xid_skb, XID2_LENGTH), &init_xid, XID2_LENGTH);\r\ngrp->xid->xid2_adj_id = jiffies | 0xfff00000;\r\ngrp->xid->xid2_sender_id = jiffies;\r\ngrp->xid_id = skb_tail_pointer(grp->xid_skb);\r\nmemcpy(skb_put(grp->xid_skb, 4), "VTAM", 4);\r\ngrp->rcvd_xid_skb =\r\n__dev_alloc_skb(MPC_BUFSIZE_DEFAULT, GFP_ATOMIC|GFP_DMA);\r\nif (grp->rcvd_xid_skb == NULL) {\r\nkfree_fsm(grp->fsm);\r\ndev_kfree_skb(grp->xid_skb);\r\nkfree(grp);\r\nreturn NULL;\r\n}\r\ngrp->rcvd_xid_data = grp->rcvd_xid_skb->data;\r\ngrp->rcvd_xid_th = (struct th_header *)grp->rcvd_xid_skb->data;\r\nmemcpy(skb_put(grp->rcvd_xid_skb, TH_HEADER_LENGTH),\r\n&thnorm, TH_HEADER_LENGTH);\r\ngrp->saved_xid2 = NULL;\r\npriv->xid = grp->xid;\r\npriv->mpcg = grp;\r\nreturn grp;\r\n}\r\nstatic void mpc_action_nop(fsm_instance *fi, int event, void *arg)\r\n{\r\n}\r\nstatic void mpc_action_go_inop(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\nstruct channel *wch;\r\nCTCM_PR_DEBUG("Enter %s: %s\n", __func__, dev->name);\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\ngrp->flow_off_called = 0;\r\nfsm_deltimer(&grp->timer);\r\nif (grp->channels_terminating)\r\nreturn;\r\ngrp->channels_terminating = 1;\r\ngrp->saved_state = fsm_getstate(grp->fsm);\r\nfsm_newstate(grp->fsm, MPCG_STATE_INOP);\r\nif (grp->saved_state > MPCG_STATE_XID7INITF)\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\r\n"%s(%s): MPC GROUP INOPERATIVE",\r\nCTCM_FUNTAIL, dev->name);\r\nif ((grp->saved_state != MPCG_STATE_RESET) ||\r\n(grp->port_persist == 0))\r\nfsm_deltimer(&priv->restart_timer);\r\nwch = priv->channel[CTCM_WRITE];\r\nswitch (grp->saved_state) {\r\ncase MPCG_STATE_RESET:\r\ncase MPCG_STATE_INOP:\r\ncase MPCG_STATE_XID2INITW:\r\ncase MPCG_STATE_XID0IOWAIT:\r\ncase MPCG_STATE_XID2INITX:\r\ncase MPCG_STATE_XID7INITW:\r\ncase MPCG_STATE_XID7INITX:\r\ncase MPCG_STATE_XID0IOWAIX:\r\ncase MPCG_STATE_XID7INITI:\r\ncase MPCG_STATE_XID7INITZ:\r\ncase MPCG_STATE_XID7INITF:\r\nbreak;\r\ncase MPCG_STATE_FLOWC:\r\ncase MPCG_STATE_READY:\r\ndefault:\r\ntasklet_hi_schedule(&wch->ch_disc_tasklet);\r\n}\r\ngrp->xid2_tgnum = 0;\r\ngrp->group_max_buflen = 0;\r\ngrp->outstanding_xid2 = 0;\r\ngrp->outstanding_xid7 = 0;\r\ngrp->outstanding_xid7_p2 = 0;\r\ngrp->saved_xid2 = NULL;\r\ngrp->xidnogood = 0;\r\ngrp->changed_side = 0;\r\ngrp->rcvd_xid_skb->data = grp->rcvd_xid_data;\r\nskb_reset_tail_pointer(grp->rcvd_xid_skb);\r\ngrp->rcvd_xid_skb->len = 0;\r\ngrp->rcvd_xid_th = (struct th_header *)grp->rcvd_xid_skb->data;\r\nmemcpy(skb_put(grp->rcvd_xid_skb, TH_HEADER_LENGTH), &thnorm,\r\nTH_HEADER_LENGTH);\r\nif (grp->send_qllc_disc == 1) {\r\ngrp->send_qllc_disc = 0;\r\nmpc_send_qllc_discontact(dev);\r\n}\r\nif ((grp->port_persist == 1) || (grp->alloc_called)) {\r\ngrp->alloc_called = 0;\r\nfsm_deltimer(&priv->restart_timer);\r\nfsm_addtimer(&priv->restart_timer, 500, DEV_EVENT_RESTART, dev);\r\nfsm_newstate(grp->fsm, MPCG_STATE_RESET);\r\nif (grp->saved_state > MPCG_STATE_XID7INITF)\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ALWAYS,\r\n"%s(%s): MPC GROUP RECOVERY SCHEDULED",\r\nCTCM_FUNTAIL, dev->name);\r\n} else {\r\nfsm_deltimer(&priv->restart_timer);\r\nfsm_addtimer(&priv->restart_timer, 500, DEV_EVENT_STOP, dev);\r\nfsm_newstate(grp->fsm, MPCG_STATE_RESET);\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_ALWAYS,\r\n"%s(%s): NO MPC GROUP RECOVERY ATTEMPTED",\r\nCTCM_FUNTAIL, dev->name);\r\n}\r\n}\r\nstatic void mpc_action_timeout(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\nstruct channel *wch;\r\nstruct channel *rch;\r\npriv = dev->ml_priv;\r\ngrp = priv->mpcg;\r\nwch = priv->channel[CTCM_WRITE];\r\nrch = priv->channel[CTCM_READ];\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_XID2INITW:\r\nif ((fsm_getstate(rch->fsm) == CH_XID0_PENDING) &&\r\n(fsm_getstate(wch->fsm) == CH_XID0_PENDING))\r\nbreak;\r\ndefault:\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\n}\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_DEBUG,\r\n"%s: dev=%s exit",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn;\r\n}\r\nvoid mpc_action_discontact(fsm_instance *fi, int event, void *arg)\r\n{\r\nstruct mpcg_info *mpcginfo = arg;\r\nstruct channel *ch = mpcginfo->ch;\r\nstruct net_device *dev;\r\nstruct ctcm_priv *priv;\r\nstruct mpc_group *grp;\r\nif (ch) {\r\ndev = ch->netdev;\r\nif (dev) {\r\npriv = dev->ml_priv;\r\nif (priv) {\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\r\n"%s: %s: %s\n",\r\nCTCM_FUNTAIL, dev->name, ch->id);\r\ngrp = priv->mpcg;\r\ngrp->send_qllc_disc = 1;\r\nfsm_event(grp->fsm, MPCG_EVENT_INOP, dev);\r\n}\r\n}\r\n}\r\nreturn;\r\n}\r\nvoid mpc_action_send_discontact(unsigned long thischan)\r\n{\r\nint rc;\r\nstruct channel *ch = (struct channel *)thischan;\r\nunsigned long saveflags = 0;\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[15],\r\n(unsigned long)ch, 0xff, 0);\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0) {\r\nctcm_ccw_check_rc(ch, rc, (char *)__func__);\r\n}\r\nreturn;\r\n}\r\nstatic int mpc_validate_xid(struct mpcg_info *mpcginfo)\r\n{\r\nstruct channel *ch = mpcginfo->ch;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nstruct xid2 *xid = mpcginfo->xid;\r\nint rc = 0;\r\n__u64 our_id = 0;\r\n__u64 their_id = 0;\r\nint len = TH_HEADER_LENGTH + PDU_HEADER_LENGTH;\r\nCTCM_PR_DEBUG("Enter %s: xid=%p\n", __func__, xid);\r\nif (xid == NULL) {\r\nrc = 1;\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): xid = NULL",\r\nCTCM_FUNTAIL, ch->id);\r\ngoto done;\r\n}\r\nCTCM_D3_DUMP((char *)xid, XID2_LENGTH);\r\nif (((CHANNEL_DIRECTION(ch->flags) == CTCM_READ) ? XID2_WRITE_SIDE :\r\nXID2_READ_SIDE) != xid->xid2_dlc_type) {\r\nrc = 2;\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): r/w channel pairing mismatch",\r\nCTCM_FUNTAIL, ch->id);\r\ngoto done;\r\n}\r\nif (xid->xid2_dlc_type == XID2_READ_SIDE) {\r\nCTCM_PR_DEBUG("%s: grpmaxbuf:%d xid2buflen:%d\n", __func__,\r\ngrp->group_max_buflen, xid->xid2_buf_len);\r\nif (grp->group_max_buflen == 0 || grp->group_max_buflen >\r\nxid->xid2_buf_len - len)\r\ngrp->group_max_buflen = xid->xid2_buf_len - len;\r\n}\r\nif (grp->saved_xid2 == NULL) {\r\ngrp->saved_xid2 =\r\n(struct xid2 *)skb_tail_pointer(grp->rcvd_xid_skb);\r\nmemcpy(skb_put(grp->rcvd_xid_skb,\r\nXID2_LENGTH), xid, XID2_LENGTH);\r\ngrp->rcvd_xid_skb->data = grp->rcvd_xid_data;\r\nskb_reset_tail_pointer(grp->rcvd_xid_skb);\r\ngrp->rcvd_xid_skb->len = 0;\r\nour_id = (__u64)priv->xid->xid2_adj_id;\r\nour_id = our_id << 32;\r\nour_id = our_id + priv->xid->xid2_sender_id;\r\ntheir_id = (__u64)xid->xid2_adj_id;\r\ntheir_id = their_id << 32;\r\ntheir_id = their_id + xid->xid2_sender_id;\r\nif (our_id < their_id) {\r\ngrp->roll = XSIDE;\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\r\n"%s(%s): WE HAVE LOW ID - TAKE XSIDE",\r\nCTCM_FUNTAIL, ch->id);\r\n} else {\r\ngrp->roll = YSIDE;\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_NOTICE,\r\n"%s(%s): WE HAVE HIGH ID - TAKE YSIDE",\r\nCTCM_FUNTAIL, ch->id);\r\n}\r\n} else {\r\nif (xid->xid2_flag4 != grp->saved_xid2->xid2_flag4) {\r\nrc = 3;\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): xid flag byte4 mismatch",\r\nCTCM_FUNTAIL, ch->id);\r\n}\r\nif (xid->xid2_flag2 == 0x40) {\r\nrc = 4;\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): xid NOGOOD",\r\nCTCM_FUNTAIL, ch->id);\r\n}\r\nif (xid->xid2_adj_id != grp->saved_xid2->xid2_adj_id) {\r\nrc = 5;\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Adjacent Station ID Mismatch",\r\nCTCM_FUNTAIL, ch->id);\r\n}\r\nif (xid->xid2_sender_id != grp->saved_xid2->xid2_sender_id) {\r\nrc = 6;\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): Sender Address Mismatch",\r\nCTCM_FUNTAIL, ch->id);\r\n}\r\n}\r\ndone:\r\nif (rc) {\r\ndev_warn(&dev->dev,\r\n"The XID used in the MPC protocol is not valid, "\r\n"rc = %d\n", rc);\r\npriv->xid->xid2_flag2 = 0x40;\r\ngrp->saved_xid2->xid2_flag2 = 0x40;\r\n}\r\nreturn rc;\r\n}\r\nstatic void mpc_action_side_xid(fsm_instance *fsm, void *arg, int side)\r\n{\r\nstruct channel *ch = arg;\r\nint rc = 0;\r\nint gotlock = 0;\r\nunsigned long saveflags = 0;\r\nCTCM_PR_DEBUG("Enter %s: cp=%i ch=0x%p id=%s\n",\r\n__func__, smp_processor_id(), ch, ch->id);\r\nif (ctcm_checkalloc_buffer(ch))\r\ngoto done;\r\nch->trans_skb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nmemset(ch->trans_skb->data, 0, 16);\r\nch->rcvd_xid_th = (struct th_header *)ch->trans_skb_data;\r\nskb_put(ch->trans_skb, TH_HEADER_LENGTH);\r\nch->rcvd_xid = (struct xid2 *)skb_tail_pointer(ch->trans_skb);\r\nskb_put(ch->trans_skb, XID2_LENGTH);\r\nch->rcvd_xid_id = skb_tail_pointer(ch->trans_skb);\r\nch->trans_skb->data = ch->trans_skb_data;\r\nskb_reset_tail_pointer(ch->trans_skb);\r\nch->trans_skb->len = 0;\r\nch->ccw[8].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[8].count = 0;\r\nch->ccw[8].cda = 0x00;\r\nif (!(ch->xid_th && ch->xid && ch->xid_id))\r\nCTCM_DBF_TEXT_(MPC_TRACE, CTC_DBF_INFO,\r\n"%s(%s): xid_th=%p, xid=%p, xid_id=%p",\r\nCTCM_FUNTAIL, ch->id, ch->xid_th, ch->xid, ch->xid_id);\r\nif (side == XSIDE) {\r\nif (ch->xid_th == NULL)\r\ngoto done;\r\nch->ccw[9].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[9].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[9].count = TH_HEADER_LENGTH;\r\nch->ccw[9].cda = virt_to_phys(ch->xid_th);\r\nif (ch->xid == NULL)\r\ngoto done;\r\nch->ccw[10].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[10].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[10].count = XID2_LENGTH;\r\nch->ccw[10].cda = virt_to_phys(ch->xid);\r\nch->ccw[11].cmd_code = CCW_CMD_READ;\r\nch->ccw[11].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[11].count = TH_HEADER_LENGTH;\r\nch->ccw[11].cda = virt_to_phys(ch->rcvd_xid_th);\r\nch->ccw[12].cmd_code = CCW_CMD_READ;\r\nch->ccw[12].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[12].count = XID2_LENGTH;\r\nch->ccw[12].cda = virt_to_phys(ch->rcvd_xid);\r\nch->ccw[13].cmd_code = CCW_CMD_READ;\r\nch->ccw[13].cda = virt_to_phys(ch->rcvd_xid_id);\r\n} else {\r\nch->ccw[9].cmd_code = CCW_CMD_READ;\r\nch->ccw[9].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[9].count = TH_HEADER_LENGTH;\r\nch->ccw[9].cda = virt_to_phys(ch->rcvd_xid_th);\r\nch->ccw[10].cmd_code = CCW_CMD_READ;\r\nch->ccw[10].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[10].count = XID2_LENGTH;\r\nch->ccw[10].cda = virt_to_phys(ch->rcvd_xid);\r\nif (ch->xid_th == NULL)\r\ngoto done;\r\nch->ccw[11].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[11].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[11].count = TH_HEADER_LENGTH;\r\nch->ccw[11].cda = virt_to_phys(ch->xid_th);\r\nif (ch->xid == NULL)\r\ngoto done;\r\nch->ccw[12].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[12].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[12].count = XID2_LENGTH;\r\nch->ccw[12].cda = virt_to_phys(ch->xid);\r\nif (ch->xid_id == NULL)\r\ngoto done;\r\nch->ccw[13].cmd_code = CCW_CMD_WRITE;\r\nch->ccw[13].cda = virt_to_phys(ch->xid_id);\r\n}\r\nch->ccw[13].flags = CCW_FLAG_SLI | CCW_FLAG_CC;\r\nch->ccw[13].count = 4;\r\nch->ccw[14].cmd_code = CCW_CMD_NOOP;\r\nch->ccw[14].flags = CCW_FLAG_SLI;\r\nch->ccw[14].count = 0;\r\nch->ccw[14].cda = 0;\r\nCTCM_CCW_DUMP((char *)&ch->ccw[8], sizeof(struct ccw1) * 7);\r\nCTCM_D3_DUMP((char *)ch->xid_th, TH_HEADER_LENGTH);\r\nCTCM_D3_DUMP((char *)ch->xid, XID2_LENGTH);\r\nCTCM_D3_DUMP((char *)ch->xid_id, 4);\r\nif (!in_irq()) {\r\nspin_lock_irqsave(get_ccwdev_lock(ch->cdev), saveflags);\r\ngotlock = 1;\r\n}\r\nfsm_addtimer(&ch->timer, 5000 , CTC_EVENT_TIMER, ch);\r\nrc = ccw_device_start(ch->cdev, &ch->ccw[8],\r\n(unsigned long)ch, 0xff, 0);\r\nif (gotlock)\r\nspin_unlock_irqrestore(get_ccwdev_lock(ch->cdev), saveflags);\r\nif (rc != 0) {\r\nctcm_ccw_check_rc(ch, rc,\r\n(side == XSIDE) ? "x-side XID" : "y-side XID");\r\n}\r\ndone:\r\nCTCM_PR_DEBUG("Exit %s: ch=0x%p id=%s\n",\r\n__func__, ch, ch->id);\r\nreturn;\r\n}\r\nstatic void mpc_action_xside_xid(fsm_instance *fsm, int event, void *arg)\r\n{\r\nmpc_action_side_xid(fsm, arg, XSIDE);\r\n}\r\nstatic void mpc_action_yside_xid(fsm_instance *fsm, int event, void *arg)\r\n{\r\nmpc_action_side_xid(fsm, arg, YSIDE);\r\n}\r\nstatic void mpc_action_doxid0(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct channel *ch = arg;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("Enter %s: cp=%i ch=0x%p id=%s\n",\r\n__func__, smp_processor_id(), ch, ch->id);\r\nif (ch->xid == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): ch->xid == NULL",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn;\r\n}\r\nfsm_newstate(ch->fsm, CH_XID0_INPROGRESS);\r\nch->xid->xid2_option = XID2_0;\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_XID2INITW:\r\ncase MPCG_STATE_XID2INITX:\r\nch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;\r\nbreak;\r\ncase MPCG_STATE_XID0IOWAIT:\r\ncase MPCG_STATE_XID0IOWAIX:\r\nch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;\r\nbreak;\r\n}\r\nfsm_event(grp->fsm, MPCG_EVENT_DOIO, ch);\r\nreturn;\r\n}\r\nstatic void mpc_action_doxid7(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct net_device *dev = arg;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = NULL;\r\nint direction;\r\nint send = 0;\r\nif (priv)\r\ngrp = priv->mpcg;\r\nif (grp == NULL)\r\nreturn;\r\nfor (direction = CTCM_READ; direction <= CTCM_WRITE; direction++) {\r\nstruct channel *ch = priv->channel[direction];\r\nstruct xid2 *thisxid = ch->xid;\r\nch->xid_skb->data = ch->xid_skb_data;\r\nskb_reset_tail_pointer(ch->xid_skb);\r\nch->xid_skb->len = 0;\r\nthisxid->xid2_option = XID2_7;\r\nsend = 0;\r\nif (grp->outstanding_xid7_p2 > 0) {\r\nif (grp->roll == YSIDE) {\r\nif (fsm_getstate(ch->fsm) == CH_XID7_PENDING1) {\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING2);\r\nch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;\r\nmemcpy(skb_put(ch->xid_skb,\r\nTH_HEADER_LENGTH),\r\n&thdummy, TH_HEADER_LENGTH);\r\nsend = 1;\r\n}\r\n} else if (fsm_getstate(ch->fsm) < CH_XID7_PENDING2) {\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING2);\r\nch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;\r\nmemcpy(skb_put(ch->xid_skb,\r\nTH_HEADER_LENGTH),\r\n&thnorm, TH_HEADER_LENGTH);\r\nsend = 1;\r\n}\r\n} else {\r\nif (grp->roll == YSIDE) {\r\nif (fsm_getstate(ch->fsm) < CH_XID7_PENDING4) {\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING4);\r\nmemcpy(skb_put(ch->xid_skb,\r\nTH_HEADER_LENGTH),\r\n&thnorm, TH_HEADER_LENGTH);\r\nch->ccw[8].cmd_code = CCW_CMD_WRITE_CTL;\r\nsend = 1;\r\n}\r\n} else if (fsm_getstate(ch->fsm) == CH_XID7_PENDING3) {\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING4);\r\nch->ccw[8].cmd_code = CCW_CMD_SENSE_CMD;\r\nmemcpy(skb_put(ch->xid_skb, TH_HEADER_LENGTH),\r\n&thdummy, TH_HEADER_LENGTH);\r\nsend = 1;\r\n}\r\n}\r\nif (send)\r\nfsm_event(grp->fsm, MPCG_EVENT_DOIO, ch);\r\n}\r\nreturn;\r\n}\r\nstatic void mpc_action_rcvd_xid0(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct mpcg_info *mpcginfo = arg;\r\nstruct channel *ch = mpcginfo->ch;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("%s: ch-id:%s xid2:%i xid7:%i xidt_p2:%i \n",\r\n__func__, ch->id, grp->outstanding_xid2,\r\ngrp->outstanding_xid7, grp->outstanding_xid7_p2);\r\nif (fsm_getstate(ch->fsm) < CH_XID7_PENDING)\r\nfsm_newstate(ch->fsm, CH_XID7_PENDING);\r\ngrp->outstanding_xid2--;\r\ngrp->outstanding_xid7++;\r\ngrp->outstanding_xid7_p2++;\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_XID2INITW:\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID2INITX);\r\nmpc_validate_xid(mpcginfo);\r\nbreak;\r\ncase MPCG_STATE_XID0IOWAIT:\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID0IOWAIX);\r\nmpc_validate_xid(mpcginfo);\r\nbreak;\r\ncase MPCG_STATE_XID2INITX:\r\nif (grp->outstanding_xid2 == 0) {\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID7INITW);\r\nmpc_validate_xid(mpcginfo);\r\nfsm_event(grp->fsm, MPCG_EVENT_XID2DONE, dev);\r\n}\r\nbreak;\r\ncase MPCG_STATE_XID0IOWAIX:\r\nif (grp->outstanding_xid2 == 0) {\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID7INITI);\r\nmpc_validate_xid(mpcginfo);\r\nfsm_event(grp->fsm, MPCG_EVENT_XID2DONE, dev);\r\n}\r\nbreak;\r\n}\r\nkfree(mpcginfo);\r\nCTCM_PR_DEBUG("ctcmpc:%s() %s xid2:%i xid7:%i xidt_p2:%i \n",\r\n__func__, ch->id, grp->outstanding_xid2,\r\ngrp->outstanding_xid7, grp->outstanding_xid7_p2);\r\nCTCM_PR_DEBUG("ctcmpc:%s() %s grpstate: %s chanstate: %s \n",\r\n__func__, ch->id,\r\nfsm_getstate_str(grp->fsm), fsm_getstate_str(ch->fsm));\r\nreturn;\r\n}\r\nstatic void mpc_action_rcvd_xid7(fsm_instance *fsm, int event, void *arg)\r\n{\r\nstruct mpcg_info *mpcginfo = arg;\r\nstruct channel *ch = mpcginfo->ch;\r\nstruct net_device *dev = ch->netdev;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("Enter %s: cp=%i ch=0x%p id=%s\n",\r\n__func__, smp_processor_id(), ch, ch->id);\r\nCTCM_PR_DEBUG("%s: outstanding_xid7: %i, outstanding_xid7_p2: %i\n",\r\n__func__, grp->outstanding_xid7, grp->outstanding_xid7_p2);\r\ngrp->outstanding_xid7--;\r\nch->xid_skb->data = ch->xid_skb_data;\r\nskb_reset_tail_pointer(ch->xid_skb);\r\nch->xid_skb->len = 0;\r\nswitch (fsm_getstate(grp->fsm)) {\r\ncase MPCG_STATE_XID7INITI:\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID7INITZ);\r\nmpc_validate_xid(mpcginfo);\r\nbreak;\r\ncase MPCG_STATE_XID7INITW:\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID7INITX);\r\nmpc_validate_xid(mpcginfo);\r\nbreak;\r\ncase MPCG_STATE_XID7INITZ:\r\ncase MPCG_STATE_XID7INITX:\r\nif (grp->outstanding_xid7 == 0) {\r\nif (grp->outstanding_xid7_p2 > 0) {\r\ngrp->outstanding_xid7 =\r\ngrp->outstanding_xid7_p2;\r\ngrp->outstanding_xid7_p2 = 0;\r\n} else\r\nfsm_newstate(grp->fsm, MPCG_STATE_XID7INITF);\r\nmpc_validate_xid(mpcginfo);\r\nfsm_event(grp->fsm, MPCG_EVENT_XID7DONE, dev);\r\nbreak;\r\n}\r\nmpc_validate_xid(mpcginfo);\r\nbreak;\r\n}\r\nkfree(mpcginfo);\r\nreturn;\r\n}\r\nstatic int mpc_send_qllc_discontact(struct net_device *dev)\r\n{\r\n__u32 new_len = 0;\r\nstruct sk_buff *skb;\r\nstruct qllc *qllcptr;\r\nstruct ctcm_priv *priv = dev->ml_priv;\r\nstruct mpc_group *grp = priv->mpcg;\r\nCTCM_PR_DEBUG("%s: GROUP STATE: %s\n",\r\n__func__, mpcg_state_names[grp->saved_state]);\r\nswitch (grp->saved_state) {\r\ncase MPCG_STATE_XID0IOWAIT:\r\ncase MPCG_STATE_XID0IOWAIX:\r\ncase MPCG_STATE_XID7INITI:\r\ncase MPCG_STATE_XID7INITZ:\r\ncase MPCG_STATE_XID2INITW:\r\ncase MPCG_STATE_XID2INITX:\r\ncase MPCG_STATE_XID7INITW:\r\ncase MPCG_STATE_XID7INITX:\r\nif (grp->estconnfunc) {\r\ngrp->estconnfunc(grp->port_num, -1, 0);\r\ngrp->estconnfunc = NULL;\r\nbreak;\r\n}\r\ncase MPCG_STATE_FLOWC:\r\ncase MPCG_STATE_READY:\r\ngrp->send_qllc_disc = 2;\r\nnew_len = sizeof(struct qllc);\r\nqllcptr = kzalloc(new_len, gfp_type() | GFP_DMA);\r\nif (qllcptr == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): qllcptr allocation error",\r\nCTCM_FUNTAIL, dev->name);\r\nreturn -ENOMEM;\r\n}\r\nqllcptr->qllc_address = 0xcc;\r\nqllcptr->qllc_commands = 0x03;\r\nskb = __dev_alloc_skb(new_len, GFP_ATOMIC);\r\nif (skb == NULL) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): skb allocation error",\r\nCTCM_FUNTAIL, dev->name);\r\npriv->stats.rx_dropped++;\r\nkfree(qllcptr);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(skb_put(skb, new_len), qllcptr, new_len);\r\nkfree(qllcptr);\r\nif (skb_headroom(skb) < 4) {\r\nCTCM_DBF_TEXT_(MPC_ERROR, CTC_DBF_ERROR,\r\n"%s(%s): skb_headroom error",\r\nCTCM_FUNTAIL, dev->name);\r\ndev_kfree_skb_any(skb);\r\nreturn -ENOMEM;\r\n}\r\n*((__u32 *)skb_push(skb, 4)) =\r\npriv->channel[CTCM_READ]->pdu_seq;\r\npriv->channel[CTCM_READ]->pdu_seq++;\r\nCTCM_PR_DBGDATA("ctcmpc: %s ToDCM_pdu_seq= %08x\n",\r\n__func__, priv->channel[CTCM_READ]->pdu_seq);\r\npriv->channel[CTCM_READ]->pdu_seq = 0x00;\r\nskb_reset_mac_header(skb);\r\nskb->dev = dev;\r\nskb->protocol = htons(ETH_P_SNAP);\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nCTCM_D3_DUMP(skb->data, (sizeof(struct qllc) + 4));\r\nnetif_rx(skb);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}
