static irqreturn_t mpc512x_lpbfifo_irq(int irq, void *param)\r\n{\r\nstruct device *dev = (struct device *)param;\r\nstruct mpc512x_lpbfifo_request *req = NULL;\r\nunsigned long flags;\r\nu32 status;\r\nspin_lock_irqsave(&lpbfifo.lock, flags);\r\nif (!lpbfifo.regs)\r\ngoto end;\r\nreq = lpbfifo.req;\r\nif (!req || req->dir == MPC512X_LPBFIFO_REQ_DIR_READ) {\r\ndev_err(dev, "bogus LPBFIFO IRQ\n");\r\ngoto end;\r\n}\r\nstatus = in_be32(&lpbfifo.regs->status);\r\nif (status != MPC512X_SCLPC_SUCCESS) {\r\ndev_err(dev, "DMA transfer from RAM to peripheral failed\n");\r\nout_be32(&lpbfifo.regs->enable,\r\nMPC512X_SCLPC_RESET | MPC512X_SCLPC_FIFO_RESET);\r\ngoto end;\r\n}\r\nout_be32(&lpbfifo.regs->status, MPC512X_SCLPC_SUCCESS);\r\nlpbfifo.wait_lpbfifo_irq = false;\r\nif (lpbfifo.wait_lpbfifo_callback)\r\ngoto end;\r\nlpbfifo.req = NULL;\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\nif (req->callback)\r\nreq->callback(req);\r\nreturn IRQ_HANDLED;\r\nend:\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mpc512x_lpbfifo_callback(void *param)\r\n{\r\nunsigned long flags;\r\nstruct mpc512x_lpbfifo_request *req = NULL;\r\nenum dma_data_direction dir;\r\nspin_lock_irqsave(&lpbfifo.lock, flags);\r\nif (!lpbfifo.regs) {\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\nreturn;\r\n}\r\nreq = lpbfifo.req;\r\nif (!req) {\r\npr_err("bogus LPBFIFO callback\n");\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\nreturn;\r\n}\r\nif (req->dir == MPC512X_LPBFIFO_REQ_DIR_WRITE)\r\ndir = DMA_TO_DEVICE;\r\nelse\r\ndir = DMA_FROM_DEVICE;\r\ndma_unmap_single(lpbfifo.chan->device->dev,\r\nlpbfifo.ram_bus_addr, req->size, dir);\r\nlpbfifo.wait_lpbfifo_callback = false;\r\nif (!lpbfifo.wait_lpbfifo_irq) {\r\nlpbfifo.req = NULL;\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\nif (req->callback)\r\nreq->callback(req);\r\n} else {\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\n}\r\n}\r\nstatic int mpc512x_lpbfifo_kick(void)\r\n{\r\nu32 bits;\r\nbool no_incr = false;\r\nu32 bpt = 32;\r\nu32 cs = 0;\r\nsize_t i;\r\nstruct dma_device *dma_dev = NULL;\r\nstruct scatterlist sg;\r\nenum dma_data_direction dir;\r\nstruct dma_slave_config dma_conf = {};\r\nstruct dma_async_tx_descriptor *dma_tx = NULL;\r\ndma_cookie_t cookie;\r\nint ret;\r\nif (lpbfifo.req->size == 0 || !IS_ALIGNED(lpbfifo.req->size, 4))\r\nreturn -EINVAL;\r\nif (lpbfifo.req->portsize != LPB_DEV_PORTSIZE_UNDEFINED) {\r\nbpt = lpbfifo.req->portsize;\r\nno_incr = true;\r\n}\r\nwhile (bpt > 1) {\r\nif (IS_ALIGNED(lpbfifo.req->dev_phys_addr, min(bpt, 0x8u)) &&\r\nIS_ALIGNED(lpbfifo.req->size, bpt)) {\r\nbreak;\r\n}\r\nif (no_incr)\r\nreturn -EINVAL;\r\nbpt >>= 1;\r\n}\r\ndma_conf.dst_maxburst = max(bpt, 0x4u) / 4;\r\ndma_conf.src_maxburst = max(bpt, 0x4u) / 4;\r\nfor (i = 0; i < lpbfifo.cs_n; i++) {\r\nphys_addr_t cs_start = lpbfifo.cs_ranges[i].addr;\r\nphys_addr_t cs_end = cs_start + lpbfifo.cs_ranges[i].size;\r\nphys_addr_t access_start = lpbfifo.req->dev_phys_addr;\r\nphys_addr_t access_end = access_start + lpbfifo.req->size;\r\nif (access_start >= cs_start && access_end <= cs_end) {\r\ncs = lpbfifo.cs_ranges[i].csnum;\r\nbreak;\r\n}\r\n}\r\nif (i == lpbfifo.cs_n)\r\nreturn -EFAULT;\r\ndma_dev = lpbfifo.chan->device;\r\nif (lpbfifo.req->dir == MPC512X_LPBFIFO_REQ_DIR_WRITE) {\r\ndir = DMA_TO_DEVICE;\r\ndma_conf.direction = DMA_MEM_TO_DEV;\r\ndma_conf.dst_addr = lpbfifo.regs_phys +\r\noffsetof(struct mpc512x_lpbfifo, data_word);\r\n} else {\r\ndir = DMA_FROM_DEVICE;\r\ndma_conf.direction = DMA_DEV_TO_MEM;\r\ndma_conf.src_addr = lpbfifo.regs_phys +\r\noffsetof(struct mpc512x_lpbfifo, data_word);\r\n}\r\ndma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ndma_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nif (dma_dev->device_config(lpbfifo.chan, &dma_conf)) {\r\nret = -EINVAL;\r\ngoto err_dma_prep;\r\n}\r\nsg_init_table(&sg, 1);\r\nsg_dma_address(&sg) = dma_map_single(dma_dev->dev,\r\nlpbfifo.req->ram_virt_addr, lpbfifo.req->size, dir);\r\nif (dma_mapping_error(dma_dev->dev, sg_dma_address(&sg)))\r\nreturn -EFAULT;\r\nlpbfifo.ram_bus_addr = sg_dma_address(&sg);\r\nsg_dma_len(&sg) = lpbfifo.req->size;\r\ndma_tx = dmaengine_prep_slave_sg(lpbfifo.chan, &sg,\r\n1, dma_conf.direction, 0);\r\nif (!dma_tx) {\r\nret = -ENOSPC;\r\ngoto err_dma_prep;\r\n}\r\ndma_tx->callback = mpc512x_lpbfifo_callback;\r\ndma_tx->callback_param = NULL;\r\nout_be32(&lpbfifo.regs->enable,\r\nMPC512X_SCLPC_RESET | MPC512X_SCLPC_FIFO_RESET);\r\nout_be32(&lpbfifo.regs->enable, 0x0);\r\nout_be32(&lpbfifo.regs->fifo_ctrl, MPC512X_SCLPC_FIFO_CTRL(0x7));\r\nout_be32(&lpbfifo.regs->fifo_alarm, MPC512X_SCLPC_FIFO_ALARM(0x200));\r\nout_be32(&lpbfifo.regs->start_addr, lpbfifo.req->dev_phys_addr);\r\nbits = MPC512X_SCLPC_CS(cs);\r\nif (lpbfifo.req->dir == MPC512X_LPBFIFO_REQ_DIR_READ)\r\nbits |= MPC512X_SCLPC_READ | MPC512X_SCLPC_FLUSH;\r\nif (no_incr)\r\nbits |= MPC512X_SCLPC_DAI;\r\nbits |= MPC512X_SCLPC_BPT(bpt);\r\nout_be32(&lpbfifo.regs->ctrl, bits);\r\nbits = MPC512X_SCLPC_ENABLE | MPC512X_SCLPC_ABORT_INT_ENABLE;\r\nif (lpbfifo.req->dir == MPC512X_LPBFIFO_REQ_DIR_WRITE)\r\nbits |= MPC512X_SCLPC_NORM_INT_ENABLE;\r\nelse\r\nlpbfifo.wait_lpbfifo_irq = false;\r\nout_be32(&lpbfifo.regs->enable, bits);\r\nbits = lpbfifo.req->size | MPC512X_SCLPC_START;\r\nout_be32(&lpbfifo.regs->pkt_size, bits);\r\ncookie = dma_tx->tx_submit(dma_tx);\r\nif (dma_submit_error(cookie)) {\r\nret = -ENOSPC;\r\ngoto err_dma_submit;\r\n}\r\nreturn 0;\r\nerr_dma_submit:\r\nout_be32(&lpbfifo.regs->enable,\r\nMPC512X_SCLPC_RESET | MPC512X_SCLPC_FIFO_RESET);\r\nerr_dma_prep:\r\ndma_unmap_single(dma_dev->dev, sg_dma_address(&sg),\r\nlpbfifo.req->size, dir);\r\nreturn ret;\r\n}\r\nstatic int mpc512x_lpbfifo_submit_locked(struct mpc512x_lpbfifo_request *req)\r\n{\r\nint ret = 0;\r\nif (!lpbfifo.regs)\r\nreturn -ENODEV;\r\nif (lpbfifo.req)\r\nreturn -EBUSY;\r\nlpbfifo.wait_lpbfifo_irq = true;\r\nlpbfifo.wait_lpbfifo_callback = true;\r\nlpbfifo.req = req;\r\nret = mpc512x_lpbfifo_kick();\r\nif (ret != 0)\r\nlpbfifo.req = NULL;\r\nreturn ret;\r\n}\r\nint mpc512x_lpbfifo_submit(struct mpc512x_lpbfifo_request *req)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nspin_lock_irqsave(&lpbfifo.lock, flags);\r\nret = mpc512x_lpbfifo_submit_locked(req);\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\nreturn ret;\r\n}\r\nstatic int get_cs_ranges(struct device *dev)\r\n{\r\nint ret = -ENODEV;\r\nstruct device_node *lb_node;\r\nconst u32 *addr_cells_p;\r\nconst u32 *size_cells_p;\r\nint proplen;\r\nsize_t i;\r\nlb_node = of_find_compatible_node(NULL, NULL, "fsl,mpc5121-localbus");\r\nif (!lb_node)\r\nreturn ret;\r\naddr_cells_p = of_get_property(lb_node, "#address-cells", NULL);\r\nsize_cells_p = of_get_property(lb_node, "#size-cells", NULL);\r\nif (addr_cells_p == NULL || *addr_cells_p != 2 ||\r\nsize_cells_p == NULL || *size_cells_p != 1) {\r\ngoto end;\r\n}\r\nproplen = of_property_count_u32_elems(lb_node, "ranges");\r\nif (proplen <= 0 || proplen % 4 != 0)\r\ngoto end;\r\nlpbfifo.cs_n = proplen / 4;\r\nlpbfifo.cs_ranges = devm_kcalloc(dev, lpbfifo.cs_n,\r\nsizeof(struct cs_range), GFP_KERNEL);\r\nif (!lpbfifo.cs_ranges)\r\ngoto end;\r\nif (of_property_read_u32_array(lb_node, "ranges",\r\n(u32 *)lpbfifo.cs_ranges, proplen) != 0) {\r\ngoto end;\r\n}\r\nfor (i = 0; i < lpbfifo.cs_n; i++) {\r\nif (lpbfifo.cs_ranges[i].base != 0)\r\ngoto end;\r\n}\r\nret = 0;\r\nend:\r\nof_node_put(lb_node);\r\nreturn ret;\r\n}\r\nstatic int mpc512x_lpbfifo_probe(struct platform_device *pdev)\r\n{\r\nstruct resource r;\r\nint ret = 0;\r\nmemset(&lpbfifo, 0, sizeof(struct lpbfifo_data));\r\nspin_lock_init(&lpbfifo.lock);\r\nlpbfifo.chan = dma_request_slave_channel(&pdev->dev, "rx-tx");\r\nif (lpbfifo.chan == NULL)\r\nreturn -EPROBE_DEFER;\r\nif (of_address_to_resource(pdev->dev.of_node, 0, &r) != 0) {\r\ndev_err(&pdev->dev, "bad 'reg' in 'sclpc' device tree node\n");\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nlpbfifo.regs_phys = r.start;\r\nlpbfifo.regs_size = resource_size(&r);\r\nif (!devm_request_mem_region(&pdev->dev, lpbfifo.regs_phys,\r\nlpbfifo.regs_size, DRV_NAME)) {\r\ndev_err(&pdev->dev, "unable to request region\n");\r\nret = -EBUSY;\r\ngoto err0;\r\n}\r\nlpbfifo.regs = devm_ioremap(&pdev->dev,\r\nlpbfifo.regs_phys, lpbfifo.regs_size);\r\nif (!lpbfifo.regs) {\r\ndev_err(&pdev->dev, "mapping registers failed\n");\r\nret = -ENOMEM;\r\ngoto err0;\r\n}\r\nout_be32(&lpbfifo.regs->enable,\r\nMPC512X_SCLPC_RESET | MPC512X_SCLPC_FIFO_RESET);\r\nif (get_cs_ranges(&pdev->dev) != 0) {\r\ndev_err(&pdev->dev, "bad '/localbus' device tree node\n");\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nlpbfifo.irq = irq_of_parse_and_map(pdev->dev.of_node, 0);\r\nif (!lpbfifo.irq) {\r\ndev_err(&pdev->dev, "mapping irq failed\n");\r\nret = -ENODEV;\r\ngoto err0;\r\n}\r\nif (request_irq(lpbfifo.irq, mpc512x_lpbfifo_irq, 0,\r\nDRV_NAME, &pdev->dev) != 0) {\r\ndev_err(&pdev->dev, "requesting irq failed\n");\r\nret = -ENODEV;\r\ngoto err1;\r\n}\r\ndev_info(&pdev->dev, "probe succeeded\n");\r\nreturn 0;\r\nerr1:\r\nirq_dispose_mapping(lpbfifo.irq);\r\nerr0:\r\ndma_release_channel(lpbfifo.chan);\r\nreturn ret;\r\n}\r\nstatic int mpc512x_lpbfifo_remove(struct platform_device *pdev)\r\n{\r\nunsigned long flags;\r\nstruct dma_device *dma_dev = lpbfifo.chan->device;\r\nstruct mpc512x_lpbfifo __iomem *regs = NULL;\r\nspin_lock_irqsave(&lpbfifo.lock, flags);\r\nregs = lpbfifo.regs;\r\nlpbfifo.regs = NULL;\r\nspin_unlock_irqrestore(&lpbfifo.lock, flags);\r\ndma_dev->device_terminate_all(lpbfifo.chan);\r\nout_be32(&regs->enable, MPC512X_SCLPC_RESET | MPC512X_SCLPC_FIFO_RESET);\r\nfree_irq(lpbfifo.irq, &pdev->dev);\r\nirq_dispose_mapping(lpbfifo.irq);\r\ndma_release_channel(lpbfifo.chan);\r\nreturn 0;\r\n}
