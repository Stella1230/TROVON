static int u1_read_write_register(struct hid_device *hdev, u32 address,\r\nu8 *read_val, u8 write_val, bool read_flag)\r\n{\r\nint ret, i;\r\nu8 check_sum;\r\nu8 *input;\r\nu8 *readbuf;\r\ninput = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput[0] = U1_FEATURE_REPORT_ID;\r\nif (read_flag) {\r\ninput[1] = U1_CMD_REGISTER_READ;\r\ninput[6] = 0x00;\r\n} else {\r\ninput[1] = U1_CMD_REGISTER_WRITE;\r\ninput[6] = write_val;\r\n}\r\nput_unaligned_le32(address, input + 2);\r\ncheck_sum = U1_FEATURE_REPORT_LEN_ALL;\r\nfor (i = 0; i < U1_FEATURE_REPORT_LEN - 1; i++)\r\ncheck_sum += input[i];\r\ninput[7] = check_sum;\r\nret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, input,\r\nU1_FEATURE_REPORT_LEN,\r\nHID_FEATURE_REPORT, HID_REQ_SET_REPORT);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to read command (%d)\n", ret);\r\ngoto exit;\r\n}\r\nif (read_flag) {\r\nreadbuf = kzalloc(U1_FEATURE_REPORT_LEN, GFP_KERNEL);\r\nif (!readbuf) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nret = hid_hw_raw_request(hdev, U1_FEATURE_REPORT_ID, readbuf,\r\nU1_FEATURE_REPORT_LEN,\r\nHID_FEATURE_REPORT, HID_REQ_GET_REPORT);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed read register (%d)\n", ret);\r\nkfree(readbuf);\r\ngoto exit;\r\n}\r\n*read_val = readbuf[6];\r\nkfree(readbuf);\r\n}\r\nret = 0;\r\nexit:\r\nkfree(input);\r\nreturn ret;\r\n}\r\nstatic int alps_raw_event(struct hid_device *hdev,\r\nstruct hid_report *report, u8 *data, int size)\r\n{\r\nunsigned int x, y, z;\r\nint i;\r\nshort sp_x, sp_y;\r\nstruct u1_dev *hdata = hid_get_drvdata(hdev);\r\nswitch (data[0]) {\r\ncase U1_MOUSE_REPORT_ID:\r\nbreak;\r\ncase U1_FEATURE_REPORT_ID:\r\nbreak;\r\ncase U1_ABSOLUTE_REPORT_ID:\r\nfor (i = 0; i < MAX_TOUCHES; i++) {\r\nu8 *contact = &data[i * 5];\r\nx = get_unaligned_le16(contact + 3);\r\ny = get_unaligned_le16(contact + 5);\r\nz = contact[7] & 0x7F;\r\ninput_mt_slot(hdata->input, i);\r\nif (z != 0) {\r\ninput_mt_report_slot_state(hdata->input,\r\nMT_TOOL_FINGER, 1);\r\ninput_report_abs(hdata->input,\r\nABS_MT_POSITION_X, x);\r\ninput_report_abs(hdata->input,\r\nABS_MT_POSITION_Y, y);\r\ninput_report_abs(hdata->input,\r\nABS_MT_PRESSURE, z);\r\n} else {\r\ninput_mt_report_slot_state(hdata->input,\r\nMT_TOOL_FINGER, 0);\r\n}\r\n}\r\ninput_mt_sync_frame(hdata->input);\r\ninput_report_key(hdata->input, BTN_LEFT,\r\ndata[1] & 0x1);\r\ninput_report_key(hdata->input, BTN_RIGHT,\r\n(data[1] & 0x2));\r\ninput_report_key(hdata->input, BTN_MIDDLE,\r\n(data[1] & 0x4));\r\ninput_sync(hdata->input);\r\nreturn 1;\r\ncase U1_SP_ABSOLUTE_REPORT_ID:\r\nsp_x = get_unaligned_le16(data+2);\r\nsp_y = get_unaligned_le16(data+4);\r\nsp_x = sp_x / 8;\r\nsp_y = sp_y / 8;\r\ninput_report_rel(hdata->input2, REL_X, sp_x);\r\ninput_report_rel(hdata->input2, REL_Y, sp_y);\r\ninput_report_key(hdata->input2, BTN_LEFT,\r\ndata[1] & 0x1);\r\ninput_report_key(hdata->input2, BTN_RIGHT,\r\n(data[1] & 0x2));\r\ninput_report_key(hdata->input2, BTN_MIDDLE,\r\n(data[1] & 0x4));\r\ninput_sync(hdata->input2);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int alps_post_reset(struct hid_device *hdev)\r\n{\r\nreturn u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\r\nNULL, U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);\r\n}\r\nstatic int alps_post_resume(struct hid_device *hdev)\r\n{\r\nreturn u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\r\nNULL, U1_TP_ABS_MODE | U1_SP_ABS_MODE, false);\r\n}\r\nstatic int alps_input_configured(struct hid_device *hdev, struct hid_input *hi)\r\n{\r\nstruct u1_dev *data = hid_get_drvdata(hdev);\r\nstruct input_dev *input = hi->input, *input2;\r\nstruct u1_dev devInfo;\r\nint ret;\r\nint res_x, res_y, i;\r\ndata->input = input;\r\nhid_dbg(hdev, "Opening low level driver\n");\r\nret = hid_hw_open(hdev);\r\nif (ret)\r\nreturn ret;\r\nhid_device_io_start(hdev);\r\nret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\r\n&devInfo.dev_ctrl, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_DEV_CTRL_1 (%d)\n", ret);\r\ngoto exit;\r\n}\r\ndevInfo.dev_ctrl &= ~U1_DISABLE_DEV;\r\ndevInfo.dev_ctrl |= U1_TP_ABS_MODE;\r\nret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\r\nNULL, devInfo.dev_ctrl, false);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed to change TP mode (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_X,\r\n&devInfo.sen_line_num_x, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_NUM_SENS_X (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_NUM_SENS_Y,\r\n&devInfo.sen_line_num_y, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_NUM_SENS_Y (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_X,\r\n&devInfo.pitch_x, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_PITCH_SENS_X (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_PITCH_SENS_Y,\r\n&devInfo.pitch_y, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_PITCH_SENS_Y (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_RESO_DWN_ABS,\r\n&devInfo.resolution, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_RESO_DWN_ABS (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_PAD_BTN,\r\n&devInfo.btn_info, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_PAD_BTN (%d)\n", ret);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_DEVICE_TYP,\r\n&devInfo.dev_type, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_DEVICE_TYP (%d)\n", ret);\r\ngoto exit;\r\n}\r\ndevInfo.x_active_len_mm =\r\n(devInfo.pitch_x * (devInfo.sen_line_num_x - 1)) / 10;\r\ndevInfo.y_active_len_mm =\r\n(devInfo.pitch_y * (devInfo.sen_line_num_y - 1)) / 10;\r\ndevInfo.x_max =\r\n(devInfo.resolution << 2) * (devInfo.sen_line_num_x - 1);\r\ndevInfo.y_max =\r\n(devInfo.resolution << 2) * (devInfo.sen_line_num_y - 1);\r\n__set_bit(EV_ABS, input->evbit);\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 1, devInfo.x_max, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 1, devInfo.y_max, 0, 0);\r\nif (devInfo.x_active_len_mm && devInfo.y_active_len_mm) {\r\nres_x = (devInfo.x_max - 1) / devInfo.x_active_len_mm;\r\nres_y = (devInfo.y_max - 1) / devInfo.y_active_len_mm;\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, res_x);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, res_y);\r\n}\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, 64, 0, 0);\r\ninput_mt_init_slots(input, MAX_TOUCHES, INPUT_MT_POINTER);\r\n__set_bit(EV_KEY, input->evbit);\r\nif ((devInfo.btn_info & 0x0F) == (devInfo.btn_info & 0xF0) >> 4) {\r\ndevInfo.btn_cnt = (devInfo.btn_info & 0x0F);\r\n} else {\r\ndevInfo.btn_cnt = 1;\r\n__set_bit(INPUT_PROP_BUTTONPAD, input->propbit);\r\n}\r\nfor (i = 0; i < devInfo.btn_cnt; i++)\r\n__set_bit(BTN_LEFT + i, input->keybit);\r\nif (devInfo.dev_type & U1_DEVTYPE_SP_SUPPORT) {\r\ninput2 = input_allocate_device();\r\nif (!input2) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->input2 = input2;\r\ndevInfo.dev_ctrl |= U1_SP_ABS_MODE;\r\nret = u1_read_write_register(hdev, ADDRESS_U1_DEV_CTRL_1,\r\nNULL, devInfo.dev_ctrl, false);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed SP mode (%d)\n", ret);\r\ninput_free_device(input2);\r\ngoto exit;\r\n}\r\nret = u1_read_write_register(hdev, ADDRESS_U1_SP_BTN,\r\n&devInfo.sp_btn_info, 0, true);\r\nif (ret < 0) {\r\ndev_err(&hdev->dev, "failed U1_SP_BTN (%d)\n", ret);\r\ninput_free_device(input2);\r\ngoto exit;\r\n}\r\ninput2->phys = input->phys;\r\ninput2->name = "DualPoint Stick";\r\ninput2->id.bustype = BUS_I2C;\r\ninput2->id.vendor = input->id.vendor;\r\ninput2->id.product = input->id.product;\r\ninput2->id.version = input->id.version;\r\ninput2->dev.parent = input->dev.parent;\r\n__set_bit(EV_KEY, input2->evbit);\r\ndevInfo.sp_btn_cnt = (devInfo.sp_btn_info & 0x0F);\r\nfor (i = 0; i < devInfo.sp_btn_cnt; i++)\r\n__set_bit(BTN_LEFT + i, input2->keybit);\r\n__set_bit(EV_REL, input2->evbit);\r\n__set_bit(REL_X, input2->relbit);\r\n__set_bit(REL_Y, input2->relbit);\r\n__set_bit(INPUT_PROP_POINTER, input2->propbit);\r\n__set_bit(INPUT_PROP_POINTING_STICK, input2->propbit);\r\nret = input_register_device(data->input2);\r\nif (ret) {\r\ninput_free_device(input2);\r\ngoto exit;\r\n}\r\n}\r\nexit:\r\nhid_device_io_stop(hdev);\r\nhid_hw_close(hdev);\r\nreturn ret;\r\n}\r\nstatic int alps_input_mapping(struct hid_device *hdev,\r\nstruct hid_input *hi, struct hid_field *field,\r\nstruct hid_usage *usage, unsigned long **bit, int *max)\r\n{\r\nreturn -1;\r\n}\r\nstatic int alps_probe(struct hid_device *hdev, const struct hid_device_id *id)\r\n{\r\nstruct u1_dev *data = NULL;\r\nint ret;\r\ndata = devm_kzalloc(&hdev->dev, sizeof(struct u1_dev), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->hdev = hdev;\r\nhid_set_drvdata(hdev, data);\r\nhdev->quirks |= HID_QUIRK_NO_INIT_REPORTS;\r\nret = hid_parse(hdev);\r\nif (ret) {\r\nhid_err(hdev, "parse failed\n");\r\nreturn ret;\r\n}\r\nret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\r\nif (ret) {\r\nhid_err(hdev, "hw start failed\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void alps_remove(struct hid_device *hdev)\r\n{\r\nhid_hw_stop(hdev);\r\n}
