static void imx25_setup_queue_cfgs(struct mx25_tcq_priv *priv,\r\nunsigned int settling_cnt)\r\n{\r\nu32 precharge_cfg =\r\nMX25_PRECHARGE_VALUE |\r\nMX25_ADCQ_CFG_SETTLING_TIME(settling_cnt);\r\nu32 touch_detect_cfg =\r\nMX25_TOUCH_DETECT_VALUE |\r\nMX25_ADCQ_CFG_NOS(1) |\r\nMX25_ADCQ_CFG_SETTLING_TIME(settling_cnt);\r\nregmap_write(priv->core_regs, MX25_TSC_TICR, precharge_cfg);\r\nregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_PRECHARGE),\r\nprecharge_cfg);\r\nregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_TOUCH_DETECT),\r\ntouch_detect_cfg);\r\nregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_X_MEASUREMENT),\r\nMX25_ADCQ_CFG_YPLL_OFF |\r\nMX25_ADCQ_CFG_XNUR_LOW |\r\nMX25_ADCQ_CFG_XPUL_HIGH |\r\nMX25_ADCQ_CFG_REFP_XP |\r\nMX25_ADCQ_CFG_IN_YP |\r\nMX25_ADCQ_CFG_REFN_XN |\r\nMX25_ADCQ_CFG_NOS(priv->sample_count) |\r\nMX25_ADCQ_CFG_SETTLING_TIME(settling_cnt));\r\nregmap_write(priv->regs, MX25_ADCQ_CFG(MX25_CFG_Y_MEASUREMENT),\r\nMX25_ADCQ_CFG_YNLR |\r\nMX25_ADCQ_CFG_YPLL_HIGH |\r\nMX25_ADCQ_CFG_XNUR_OFF |\r\nMX25_ADCQ_CFG_XPUL_OFF |\r\nMX25_ADCQ_CFG_REFP_YP |\r\nMX25_ADCQ_CFG_IN_XP |\r\nMX25_ADCQ_CFG_REFN_YN |\r\nMX25_ADCQ_CFG_NOS(priv->sample_count) |\r\nMX25_ADCQ_CFG_SETTLING_TIME(settling_cnt));\r\nregmap_write(priv->core_regs, MX25_TSC_TICR, touch_detect_cfg |\r\nMX25_ADCQ_CFG_IGS);\r\n}\r\nstatic int imx25_setup_queue_4wire(struct mx25_tcq_priv *priv,\r\nunsigned settling_cnt, int *items)\r\n{\r\nimx25_setup_queue_cfgs(priv, settling_cnt);\r\nregmap_write(priv->regs, MX25_ADCQ_ITEM_7_0,\r\nMX25_ADCQ_ITEM(0, MX25_CFG_PRECHARGE) |\r\nMX25_ADCQ_ITEM(1, MX25_CFG_TOUCH_DETECT) |\r\nMX25_ADCQ_ITEM(2, MX25_CFG_X_MEASUREMENT) |\r\nMX25_ADCQ_ITEM(3, MX25_CFG_Y_MEASUREMENT) |\r\nMX25_ADCQ_ITEM(4, MX25_CFG_PRECHARGE) |\r\nMX25_ADCQ_ITEM(5, MX25_CFG_TOUCH_DETECT));\r\npriv->expected_samples = priv->sample_count * 2 + 2;\r\n*items = 6;\r\nreturn 0;\r\n}\r\nstatic void mx25_tcq_disable_touch_irq(struct mx25_tcq_priv *priv)\r\n{\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_PDMSK,\r\nMX25_ADCQ_CR_PDMSK);\r\n}\r\nstatic void mx25_tcq_enable_touch_irq(struct mx25_tcq_priv *priv)\r\n{\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_PDMSK, 0);\r\n}\r\nstatic void mx25_tcq_disable_fifo_irq(struct mx25_tcq_priv *priv)\r\n{\r\nregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_FDRY_IRQ,\r\nMX25_ADCQ_MR_FDRY_IRQ);\r\n}\r\nstatic void mx25_tcq_enable_fifo_irq(struct mx25_tcq_priv *priv)\r\n{\r\nregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_FDRY_IRQ, 0);\r\n}\r\nstatic void mx25_tcq_force_queue_start(struct mx25_tcq_priv *priv)\r\n{\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_FQS,\r\nMX25_ADCQ_CR_FQS);\r\n}\r\nstatic void mx25_tcq_force_queue_stop(struct mx25_tcq_priv *priv)\r\n{\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_FQS, 0);\r\n}\r\nstatic void mx25_tcq_fifo_reset(struct mx25_tcq_priv *priv)\r\n{\r\nu32 tcqcr;\r\nregmap_read(priv->regs, MX25_ADCQ_CR, &tcqcr);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FRST,\r\nMX25_ADCQ_CR_FRST);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_FRST, 0);\r\nregmap_write(priv->regs, MX25_ADCQ_CR, tcqcr);\r\n}\r\nstatic void mx25_tcq_re_enable_touch_detection(struct mx25_tcq_priv *priv)\r\n{\r\nmx25_tcq_force_queue_stop(priv);\r\nregmap_write(priv->core_regs, MX25_TSC_TICR, MX25_PRECHARGE_VALUE);\r\nmx25_tcq_fifo_reset(priv);\r\nregmap_write(priv->core_regs, MX25_TSC_TICR,\r\nMX25_TOUCH_DETECT_VALUE | MX25_ADCQ_CFG_IGS);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_SR, MX25_ADCQ_SR_PD,\r\nMX25_ADCQ_SR_PD);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_MR, MX25_ADCQ_MR_PD_IRQ, 0);\r\nmx25_tcq_enable_touch_irq(priv);\r\n}\r\nstatic void mx25_tcq_create_event_for_4wire(struct mx25_tcq_priv *priv,\r\nu32 *sample_buf,\r\nunsigned int samples)\r\n{\r\nunsigned int x_pos = 0;\r\nunsigned int y_pos = 0;\r\nunsigned int touch_pre = 0;\r\nunsigned int touch_post = 0;\r\nunsigned int i;\r\nfor (i = 0; i < samples; i++) {\r\nunsigned int index = MX25_ADCQ_FIFO_ID(sample_buf[i]);\r\nunsigned int val = MX25_ADCQ_FIFO_DATA(sample_buf[i]);\r\nswitch (index) {\r\ncase 1:\r\ntouch_pre = val;\r\nbreak;\r\ncase 2:\r\nx_pos = val;\r\nbreak;\r\ncase 3:\r\ny_pos = val;\r\nbreak;\r\ncase 5:\r\ntouch_post = val;\r\nbreak;\r\ndefault:\r\ndev_dbg(priv->dev, "Dropped samples because of invalid index %d\n",\r\nindex);\r\nreturn;\r\n}\r\n}\r\nif (samples != 0) {\r\nif (touch_pre < priv->pen_threshold &&\r\ntouch_post < priv->pen_threshold) {\r\nx_pos /= priv->sample_count;\r\ny_pos /= priv->sample_count;\r\ninput_report_abs(priv->idev, ABS_X, x_pos);\r\ninput_report_abs(priv->idev, ABS_Y, y_pos);\r\ninput_report_key(priv->idev, BTN_TOUCH, 1);\r\ninput_sync(priv->idev);\r\nmx25_tcq_enable_fifo_irq(priv);\r\n} else if (touch_pre >= priv->pen_threshold &&\r\ntouch_post >= priv->pen_threshold) {\r\ninput_report_key(priv->idev, BTN_TOUCH, 0);\r\ninput_sync(priv->idev);\r\nmx25_tcq_re_enable_touch_detection(priv);\r\n} else {\r\nmx25_tcq_enable_fifo_irq(priv);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t mx25_tcq_irq_thread(int irq, void *dev_id)\r\n{\r\nstruct mx25_tcq_priv *priv = dev_id;\r\nu32 sample_buf[TSC_MAX_SAMPLES];\r\nunsigned int samples;\r\nu32 stats;\r\nunsigned int i;\r\nregmap_read(priv->regs, MX25_ADCQ_SR, &stats);\r\nsamples = MX25_ADCQ_SR_FDN(stats);\r\nsamples -= samples % priv->sample_count;\r\nif (!samples)\r\nreturn IRQ_HANDLED;\r\nfor (i = 0; i != samples; ++i)\r\nregmap_read(priv->regs, MX25_ADCQ_FIFO, &sample_buf[i]);\r\nmx25_tcq_create_event_for_4wire(priv, sample_buf, samples);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t mx25_tcq_irq(int irq, void *dev_id)\r\n{\r\nstruct mx25_tcq_priv *priv = dev_id;\r\nu32 stat;\r\nint ret = IRQ_HANDLED;\r\nregmap_read(priv->regs, MX25_ADCQ_SR, &stat);\r\nif (stat & (MX25_ADCQ_SR_FRR | MX25_ADCQ_SR_FUR | MX25_ADCQ_SR_FOR))\r\nmx25_tcq_re_enable_touch_detection(priv);\r\nif (stat & MX25_ADCQ_SR_PD) {\r\nmx25_tcq_disable_touch_irq(priv);\r\nmx25_tcq_force_queue_start(priv);\r\nmx25_tcq_enable_fifo_irq(priv);\r\n}\r\nif (stat & MX25_ADCQ_SR_FDRY) {\r\nmx25_tcq_disable_fifo_irq(priv);\r\nret = IRQ_WAKE_THREAD;\r\n}\r\nregmap_update_bits(priv->regs, MX25_ADCQ_SR, MX25_ADCQ_SR_FRR |\r\nMX25_ADCQ_SR_FUR | MX25_ADCQ_SR_FOR |\r\nMX25_ADCQ_SR_PD,\r\nMX25_ADCQ_SR_FRR | MX25_ADCQ_SR_FUR |\r\nMX25_ADCQ_SR_FOR | MX25_ADCQ_SR_PD);\r\nreturn ret;\r\n}\r\nstatic int mx25_tcq_init(struct mx25_tcq_priv *priv)\r\n{\r\nu32 tgcr;\r\nunsigned int ipg_div;\r\nunsigned int adc_period;\r\nunsigned int debounce_cnt;\r\nunsigned int settling_cnt;\r\nint itemct;\r\nint error;\r\nregmap_read(priv->core_regs, MX25_TSC_TGCR, &tgcr);\r\nipg_div = max_t(unsigned int, 4, MX25_TGCR_GET_ADCCLK(tgcr));\r\nadc_period = USEC_PER_SEC * ipg_div * 2 + 2;\r\nadc_period /= clk_get_rate(priv->clk) / 1000 + 1;\r\ndebounce_cnt = DIV_ROUND_UP(priv->pen_debounce, adc_period * 8) - 1;\r\nsettling_cnt = DIV_ROUND_UP(priv->settling_time, adc_period * 8) - 1;\r\nregmap_write(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_QRST | MX25_ADCQ_CR_FRST);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_QRST | MX25_ADCQ_CR_FRST, 0);\r\nif (debounce_cnt > 127)\r\ndebounce_cnt = 127;\r\nif (settling_cnt > 255)\r\nsettling_cnt = 255;\r\nerror = imx25_setup_queue_4wire(priv, settling_cnt, &itemct);\r\nif (error)\r\nreturn error;\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_LITEMID_MASK | MX25_ADCQ_CR_WMRK_MASK,\r\nMX25_ADCQ_CR_LITEMID(itemct - 1) |\r\nMX25_ADCQ_CR_WMRK(priv->expected_samples - 1));\r\nregmap_update_bits(priv->core_regs, MX25_TSC_TGCR,\r\nMX25_TGCR_PDBTIME_MASK,\r\nMX25_TGCR_PDBTIME(debounce_cnt));\r\nregmap_update_bits(priv->core_regs, MX25_TSC_TGCR, MX25_TGCR_PDBEN,\r\nMX25_TGCR_PDBEN);\r\nregmap_update_bits(priv->core_regs, MX25_TSC_TGCR, MX25_TGCR_PDEN,\r\nMX25_TGCR_PDEN);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR, MX25_ADCQ_CR_QSM_MASK,\r\nMX25_ADCQ_CR_QSM_FQS);\r\nregmap_update_bits(priv->regs, MX25_ADCQ_CR,\r\nMX25_ADCQ_CR_RPT | MX25_ADCQ_CR_RWAIT_MASK,\r\nMX25_ADCQ_CR_RPT |\r\nMX25_ADCQ_CR_RWAIT(MX25_TSC_REPEAT_WAIT));\r\nreturn 0;\r\n}\r\nstatic int mx25_tcq_parse_dt(struct platform_device *pdev,\r\nstruct mx25_tcq_priv *priv)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 wires;\r\nint error;\r\npriv->pen_threshold = 500;\r\npriv->sample_count = 3;\r\npriv->pen_debounce = 1000000;\r\npriv->settling_time = 250000;\r\nerror = of_property_read_u32(np, "fsl,wires", &wires);\r\nif (error) {\r\ndev_err(&pdev->dev, "Failed to find fsl,wires properties\n");\r\nreturn error;\r\n}\r\nif (wires == 4) {\r\npriv->mode = MX25_TS_4WIRE;\r\n} else {\r\ndev_err(&pdev->dev, "%u-wire mode not supported\n", wires);\r\nreturn -EINVAL;\r\n}\r\nof_property_read_u32(np, "fsl,pen-threshold", &priv->pen_threshold);\r\nof_property_read_u32(np, "fsl,settling-time-ns", &priv->settling_time);\r\nof_property_read_u32(np, "fsl,pen-debounce-ns", &priv->pen_debounce);\r\nreturn 0;\r\n}\r\nstatic int mx25_tcq_open(struct input_dev *idev)\r\n{\r\nstruct device *dev = &idev->dev;\r\nstruct mx25_tcq_priv *priv = dev_get_drvdata(dev);\r\nint error;\r\nerror = clk_prepare_enable(priv->clk);\r\nif (error) {\r\ndev_err(dev, "Failed to enable ipg clock\n");\r\nreturn error;\r\n}\r\nerror = mx25_tcq_init(priv);\r\nif (error) {\r\ndev_err(dev, "Failed to init tcq\n");\r\nclk_disable_unprepare(priv->clk);\r\nreturn error;\r\n}\r\nmx25_tcq_re_enable_touch_detection(priv);\r\nreturn 0;\r\n}\r\nstatic void mx25_tcq_close(struct input_dev *idev)\r\n{\r\nstruct mx25_tcq_priv *priv = input_get_drvdata(idev);\r\nmx25_tcq_force_queue_stop(priv);\r\nmx25_tcq_disable_touch_irq(priv);\r\nmx25_tcq_disable_fifo_irq(priv);\r\nclk_disable_unprepare(priv->clk);\r\n}\r\nstatic int mx25_tcq_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct input_dev *idev;\r\nstruct mx25_tcq_priv *priv;\r\nstruct mx25_tsadc *tsadc = dev_get_drvdata(dev->parent);\r\nstruct resource *res;\r\nvoid __iomem *mem;\r\nint error;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->dev = dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmem = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mem))\r\nreturn PTR_ERR(mem);\r\nerror = mx25_tcq_parse_dt(pdev, priv);\r\nif (error)\r\nreturn error;\r\npriv->regs = devm_regmap_init_mmio(dev, mem, &mx25_tcq_regconfig);\r\nif (IS_ERR(priv->regs)) {\r\ndev_err(dev, "Failed to initialize regmap\n");\r\nreturn PTR_ERR(priv->regs);\r\n}\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq <= 0) {\r\ndev_err(dev, "Failed to get IRQ\n");\r\nreturn priv->irq;\r\n}\r\nidev = devm_input_allocate_device(dev);\r\nif (!idev) {\r\ndev_err(dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\nidev->name = mx25_tcq_name;\r\ninput_set_capability(idev, EV_KEY, BTN_TOUCH);\r\ninput_set_abs_params(idev, ABS_X, 0, 0xfff, 0, 0);\r\ninput_set_abs_params(idev, ABS_Y, 0, 0xfff, 0, 0);\r\nidev->id.bustype = BUS_HOST;\r\nidev->open = mx25_tcq_open;\r\nidev->close = mx25_tcq_close;\r\npriv->idev = idev;\r\ninput_set_drvdata(idev, priv);\r\npriv->core_regs = tsadc->regs;\r\nif (!priv->core_regs)\r\nreturn -EINVAL;\r\npriv->clk = tsadc->clk;\r\nif (!priv->clk)\r\nreturn -EINVAL;\r\nplatform_set_drvdata(pdev, priv);\r\nerror = devm_request_threaded_irq(dev, priv->irq, mx25_tcq_irq,\r\nmx25_tcq_irq_thread, 0, pdev->name,\r\npriv);\r\nif (error) {\r\ndev_err(dev, "Failed requesting IRQ\n");\r\nreturn error;\r\n}\r\nerror = input_register_device(idev);\r\nif (error) {\r\ndev_err(dev, "Failed to register input device\n");\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
