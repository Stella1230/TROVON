static void mcip_setup_per_cpu(int cpu)\r\n{\r\nsmp_ipi_irq_setup(cpu, IPI_IRQ);\r\nsmp_ipi_irq_setup(cpu, SOFTIRQ_IRQ);\r\n}\r\nstatic void mcip_ipi_send(int cpu)\r\n{\r\nunsigned long flags;\r\nint ipi_was_pending;\r\nif (unlikely(cpu == raw_smp_processor_id())) {\r\narc_softirq_trigger(SOFTIRQ_IRQ);\r\nreturn;\r\n}\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd(CMD_INTRPT_READ_STATUS, cpu);\r\nipi_was_pending = read_aux_reg(ARC_REG_MCIP_READBACK);\r\nif (!ipi_was_pending)\r\n__mcip_cmd(CMD_INTRPT_GENERATE_IRQ, cpu);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic void mcip_ipi_clear(int irq)\r\n{\r\nunsigned int cpu, c;\r\nunsigned long flags;\r\nif (unlikely(irq == SOFTIRQ_IRQ)) {\r\narc_softirq_clear(irq);\r\nreturn;\r\n}\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd(CMD_INTRPT_CHECK_SOURCE, 0);\r\ncpu = read_aux_reg(ARC_REG_MCIP_READBACK);\r\ndo {\r\nc = __ffs(cpu);\r\n__mcip_cmd(CMD_INTRPT_GENERATE_ACK, c);\r\ncpu &= ~(1U << c);\r\n} while (cpu);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic void mcip_probe_n_setup(void)\r\n{\r\nstruct mcip_bcr mp;\r\nREAD_BCR(ARC_REG_MCIP_BCR, mp);\r\nsprintf(smp_cpuinfo_buf,\r\n"Extn [SMP]\t: ARConnect (v%d): %d cores with %s%s%s%s\n",\r\nmp.ver, mp.num_cores,\r\nIS_AVAIL1(mp.ipi, "IPI "),\r\nIS_AVAIL1(mp.idu, "IDU "),\r\nIS_AVAIL1(mp.dbg, "DEBUG "),\r\nIS_AVAIL1(mp.gfrc, "GFRC"));\r\ncpuinfo_arc700[0].extn.gfrc = mp.gfrc;\r\nif (mp.dbg) {\r\n__mcip_cmd_data(CMD_DEBUG_SET_SELECT, 0, 0xf);\r\n__mcip_cmd_data(CMD_DEBUG_SET_MASK, 0xf, 0xf);\r\n}\r\n}\r\nstatic void idu_set_dest(unsigned int cmn_irq, unsigned int cpu_mask)\r\n{\r\n__mcip_cmd_data(CMD_IDU_SET_DEST, cmn_irq, cpu_mask);\r\n}\r\nstatic void idu_set_mode(unsigned int cmn_irq, unsigned int lvl,\r\nunsigned int distr)\r\n{\r\nunion {\r\nunsigned int word;\r\nstruct {\r\nunsigned int distr:2, pad:2, lvl:1, pad2:27;\r\n};\r\n} data;\r\ndata.distr = distr;\r\ndata.lvl = lvl;\r\n__mcip_cmd_data(CMD_IDU_SET_MODE, cmn_irq, data.word);\r\n}\r\nstatic void idu_irq_mask_raw(irq_hw_number_t hwirq)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd_data(CMD_IDU_SET_MASK, hwirq, 1);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic void idu_irq_mask(struct irq_data *data)\r\n{\r\nidu_irq_mask_raw(data->hwirq);\r\n}\r\nstatic void idu_irq_unmask(struct irq_data *data)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\n__mcip_cmd_data(CMD_IDU_SET_MASK, data->hwirq, 0);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\n}\r\nstatic int\r\nidu_irq_set_affinity(struct irq_data *data, const struct cpumask *cpumask,\r\nbool force)\r\n{\r\nunsigned long flags;\r\ncpumask_t online;\r\nunsigned int destination_bits;\r\nunsigned int distribution_mode;\r\nif (!cpumask_and(&online, cpumask, cpu_online_mask))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&mcip_lock, flags);\r\ndestination_bits = cpumask_bits(&online)[0];\r\nidu_set_dest(data->hwirq, destination_bits);\r\nif (ffs(destination_bits) == fls(destination_bits))\r\ndistribution_mode = IDU_M_DISTRI_DEST;\r\nelse\r\ndistribution_mode = IDU_M_DISTRI_RR;\r\nidu_set_mode(data->hwirq, IDU_M_TRIG_LEVEL, distribution_mode);\r\nraw_spin_unlock_irqrestore(&mcip_lock, flags);\r\nreturn IRQ_SET_MASK_OK;\r\n}\r\nstatic void idu_irq_enable(struct irq_data *data)\r\n{\r\nidu_irq_set_affinity(data, cpu_online_mask, false);\r\nidu_irq_unmask(data);\r\n}\r\nstatic void idu_cascade_isr(struct irq_desc *desc)\r\n{\r\nstruct irq_domain *idu_domain = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *core_chip = irq_desc_get_chip(desc);\r\nirq_hw_number_t core_hwirq = irqd_to_hwirq(irq_desc_get_irq_data(desc));\r\nirq_hw_number_t idu_hwirq = core_hwirq - FIRST_EXT_IRQ;\r\nchained_irq_enter(core_chip, desc);\r\ngeneric_handle_irq(irq_find_mapping(idu_domain, idu_hwirq));\r\nchained_irq_exit(core_chip, desc);\r\n}\r\nstatic int idu_irq_map(struct irq_domain *d, unsigned int virq, irq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(virq, &idu_irq_chip, handle_level_irq);\r\nirq_set_status_flags(virq, IRQ_MOVE_PCNTXT);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nidu_of_init(struct device_node *intc, struct device_node *parent)\r\n{\r\nstruct irq_domain *domain;\r\nint nr_irqs;\r\nint i, virq;\r\nstruct mcip_bcr mp;\r\nstruct mcip_idu_bcr idu_bcr;\r\nREAD_BCR(ARC_REG_MCIP_BCR, mp);\r\nif (!mp.idu)\r\npanic("IDU not detected, but DeviceTree using it");\r\nREAD_BCR(ARC_REG_MCIP_IDU_BCR, idu_bcr);\r\nnr_irqs = mcip_idu_bcr_to_nr_irqs(idu_bcr);\r\npr_info("MCIP: IDU supports %u common irqs\n", nr_irqs);\r\ndomain = irq_domain_add_linear(intc, nr_irqs, &idu_irq_ops, NULL);\r\nfor (i = 0; i < nr_irqs; i++) {\r\nidu_irq_mask_raw(i);\r\nvirq = irq_create_mapping(NULL, i + FIRST_EXT_IRQ);\r\nBUG_ON(!virq);\r\nirq_set_chained_handler_and_data(virq, idu_cascade_isr, domain);\r\n}\r\n__mcip_cmd(CMD_IDU_ENABLE, 0);\r\nreturn 0;\r\n}
