static struct adfs_discrecord *\r\nadfs_partition(struct parsed_partitions *state, char *name, char *data,\r\nunsigned long first_sector, int slot)\r\n{\r\nstruct adfs_discrecord *dr;\r\nunsigned int nr_sects;\r\nif (adfs_checkbblk(data))\r\nreturn NULL;\r\ndr = (struct adfs_discrecord *)(data + 0x1c0);\r\nif (dr->disc_size == 0 && dr->disc_size_high == 0)\r\nreturn NULL;\r\nnr_sects = (le32_to_cpu(dr->disc_size_high) << 23) |\r\n(le32_to_cpu(dr->disc_size) >> 9);\r\nif (name) {\r\nstrlcat(state->pp_buf, " [", PAGE_SIZE);\r\nstrlcat(state->pp_buf, name, PAGE_SIZE);\r\nstrlcat(state->pp_buf, "]", PAGE_SIZE);\r\n}\r\nput_partition(state, slot, first_sector, nr_sects);\r\nreturn dr;\r\n}\r\nstatic int riscix_partition(struct parsed_partitions *state,\r\nunsigned long first_sect, int slot,\r\nunsigned long nr_sects)\r\n{\r\nSector sect;\r\nstruct riscix_record *rr;\r\nrr = read_part_sector(state, first_sect, &sect);\r\nif (!rr)\r\nreturn -1;\r\nstrlcat(state->pp_buf, " [RISCiX]", PAGE_SIZE);\r\nif (rr->magic == RISCIX_MAGIC) {\r\nunsigned long size = nr_sects > 2 ? 2 : nr_sects;\r\nint part;\r\nstrlcat(state->pp_buf, " <", PAGE_SIZE);\r\nput_partition(state, slot++, first_sect, size);\r\nfor (part = 0; part < 8; part++) {\r\nif (rr->part[part].one &&\r\nmemcmp(rr->part[part].name, "All\0", 4)) {\r\nput_partition(state, slot++,\r\nle32_to_cpu(rr->part[part].start),\r\nle32_to_cpu(rr->part[part].length));\r\nstrlcat(state->pp_buf, "(", PAGE_SIZE);\r\nstrlcat(state->pp_buf, rr->part[part].name, PAGE_SIZE);\r\nstrlcat(state->pp_buf, ")", PAGE_SIZE);\r\n}\r\n}\r\nstrlcat(state->pp_buf, " >\n", PAGE_SIZE);\r\n} else {\r\nput_partition(state, slot++, first_sect, nr_sects);\r\n}\r\nput_dev_sector(sect);\r\nreturn slot;\r\n}\r\nstatic int linux_partition(struct parsed_partitions *state,\r\nunsigned long first_sect, int slot,\r\nunsigned long nr_sects)\r\n{\r\nSector sect;\r\nstruct linux_part *linuxp;\r\nunsigned long size = nr_sects > 2 ? 2 : nr_sects;\r\nstrlcat(state->pp_buf, " [Linux]", PAGE_SIZE);\r\nput_partition(state, slot++, first_sect, size);\r\nlinuxp = read_part_sector(state, first_sect, &sect);\r\nif (!linuxp)\r\nreturn -1;\r\nstrlcat(state->pp_buf, " <", PAGE_SIZE);\r\nwhile (linuxp->magic == cpu_to_le32(LINUX_NATIVE_MAGIC) ||\r\nlinuxp->magic == cpu_to_le32(LINUX_SWAP_MAGIC)) {\r\nif (slot == state->limit)\r\nbreak;\r\nput_partition(state, slot++, first_sect +\r\nle32_to_cpu(linuxp->start_sect),\r\nle32_to_cpu(linuxp->nr_sects));\r\nlinuxp ++;\r\n}\r\nstrlcat(state->pp_buf, " >", PAGE_SIZE);\r\nput_dev_sector(sect);\r\nreturn slot;\r\n}\r\nint adfspart_check_CUMANA(struct parsed_partitions *state)\r\n{\r\nunsigned long first_sector = 0;\r\nunsigned int start_blk = 0;\r\nSector sect;\r\nunsigned char *data;\r\nchar *name = "CUMANA/ADFS";\r\nint first = 1;\r\nint slot = 1;\r\ndo {\r\nstruct adfs_discrecord *dr;\r\nunsigned int nr_sects;\r\ndata = read_part_sector(state, start_blk * 2 + 6, &sect);\r\nif (!data)\r\nreturn -1;\r\nif (slot == state->limit)\r\nbreak;\r\ndr = adfs_partition(state, name, data, first_sector, slot++);\r\nif (!dr)\r\nbreak;\r\nname = NULL;\r\nnr_sects = (data[0x1fd] + (data[0x1fe] << 8)) *\r\n(dr->heads + (dr->lowsector & 0x40 ? 1 : 0)) *\r\ndr->secspertrack;\r\nif (!nr_sects)\r\nbreak;\r\nfirst = 0;\r\nfirst_sector += nr_sects;\r\nstart_blk += nr_sects >> (BLOCK_SIZE_BITS - 9);\r\nnr_sects = 0;\r\nswitch (data[0x1fc] & 15) {\r\ncase 0:\r\nbreak;\r\n#ifdef CONFIG_ACORN_PARTITION_RISCIX\r\ncase PARTITION_RISCIX_SCSI:\r\nslot = riscix_partition(state, first_sector, slot,\r\nnr_sects);\r\nbreak;\r\n#endif\r\ncase PARTITION_LINUX:\r\nslot = linux_partition(state, first_sector, slot,\r\nnr_sects);\r\nbreak;\r\n}\r\nput_dev_sector(sect);\r\nif (slot == -1)\r\nreturn -1;\r\n} while (1);\r\nput_dev_sector(sect);\r\nreturn first ? 0 : 1;\r\n}\r\nint adfspart_check_ADFS(struct parsed_partitions *state)\r\n{\r\nunsigned long start_sect, nr_sects, sectscyl, heads;\r\nSector sect;\r\nunsigned char *data;\r\nstruct adfs_discrecord *dr;\r\nunsigned char id;\r\nint slot = 1;\r\ndata = read_part_sector(state, 6, &sect);\r\nif (!data)\r\nreturn -1;\r\ndr = adfs_partition(state, "ADFS", data, 0, slot++);\r\nif (!dr) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nheads = dr->heads + ((dr->lowsector >> 6) & 1);\r\nsectscyl = dr->secspertrack * heads;\r\nstart_sect = ((data[0x1fe] << 8) + data[0x1fd]) * sectscyl;\r\nid = data[0x1fc] & 15;\r\nput_dev_sector(sect);\r\nnr_sects = (state->bdev->bd_inode->i_size >> 9) - start_sect;\r\nif (start_sect) {\r\nswitch (id) {\r\n#ifdef CONFIG_ACORN_PARTITION_RISCIX\r\ncase PARTITION_RISCIX_SCSI:\r\ncase PARTITION_RISCIX_MFM:\r\nslot = riscix_partition(state, start_sect, slot,\r\nnr_sects);\r\nbreak;\r\n#endif\r\ncase PARTITION_LINUX:\r\nslot = linux_partition(state, start_sect, slot,\r\nnr_sects);\r\nbreak;\r\n}\r\n}\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}\r\nstatic int adfspart_check_ICSLinux(struct parsed_partitions *state,\r\nunsigned long block)\r\n{\r\nSector sect;\r\nunsigned char *data = read_part_sector(state, block, &sect);\r\nint result = 0;\r\nif (data) {\r\nif (memcmp(data, "LinuxPart", 9) == 0)\r\nresult = 1;\r\nput_dev_sector(sect);\r\n}\r\nreturn result;\r\n}\r\nstatic inline int valid_ics_sector(const unsigned char *data)\r\n{\r\nunsigned long sum;\r\nint i;\r\nfor (i = 0, sum = 0x50617274; i < 508; i++)\r\nsum += data[i];\r\nsum -= le32_to_cpu(*(__le32 *)(&data[508]));\r\nreturn sum == 0;\r\n}\r\nint adfspart_check_ICS(struct parsed_partitions *state)\r\n{\r\nconst unsigned char *data;\r\nconst struct ics_part *p;\r\nint slot;\r\nSector sect;\r\ndata = read_part_sector(state, 0, &sect);\r\nif (!data)\r\nreturn -1;\r\nif (!valid_ics_sector(data)) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nstrlcat(state->pp_buf, " [ICS]", PAGE_SIZE);\r\nfor (slot = 1, p = (const struct ics_part *)data; p->size; p++) {\r\nu32 start = le32_to_cpu(p->start);\r\ns32 size = le32_to_cpu(p->size);\r\nif (slot == state->limit)\r\nbreak;\r\nif (size < 0) {\r\nsize = -size;\r\nif (size > 1 && adfspart_check_ICSLinux(state, start)) {\r\nstart += 1;\r\nsize -= 1;\r\n}\r\n}\r\nif (size)\r\nput_partition(state, slot++, start, size);\r\n}\r\nput_dev_sector(sect);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}\r\nstatic inline int valid_ptec_sector(const unsigned char *data)\r\n{\r\nunsigned char checksum = 0x2a;\r\nint i;\r\nif (data[510] == 0x55 && data[511] == 0xaa)\r\nreturn 0;\r\nfor (i = 0; i < 511; i++)\r\nchecksum += data[i];\r\nreturn checksum == data[511];\r\n}\r\nint adfspart_check_POWERTEC(struct parsed_partitions *state)\r\n{\r\nSector sect;\r\nconst unsigned char *data;\r\nconst struct ptec_part *p;\r\nint slot = 1;\r\nint i;\r\ndata = read_part_sector(state, 0, &sect);\r\nif (!data)\r\nreturn -1;\r\nif (!valid_ptec_sector(data)) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\nstrlcat(state->pp_buf, " [POWERTEC]", PAGE_SIZE);\r\nfor (i = 0, p = (const struct ptec_part *)data; i < 12; i++, p++) {\r\nu32 start = le32_to_cpu(p->start);\r\nu32 size = le32_to_cpu(p->size);\r\nif (size)\r\nput_partition(state, slot++, start, size);\r\n}\r\nput_dev_sector(sect);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}\r\nint adfspart_check_EESOX(struct parsed_partitions *state)\r\n{\r\nSector sect;\r\nconst unsigned char *data;\r\nunsigned char buffer[256];\r\nstruct eesox_part *p;\r\nsector_t start = 0;\r\nint i, slot = 1;\r\ndata = read_part_sector(state, 7, &sect);\r\nif (!data)\r\nreturn -1;\r\nfor (i = 0; i < 256; i++)\r\nbuffer[i] = data[i] ^ eesox_name[i & 15];\r\nput_dev_sector(sect);\r\nfor (i = 0, p = (struct eesox_part *)buffer; i < 8; i++, p++) {\r\nsector_t next;\r\nif (memcmp(p->magic, "Eesox", 6))\r\nbreak;\r\nnext = le32_to_cpu(p->start);\r\nif (i)\r\nput_partition(state, slot++, start, next - start);\r\nstart = next;\r\n}\r\nif (i != 0) {\r\nsector_t size;\r\nsize = get_capacity(state->bdev->bd_disk);\r\nput_partition(state, slot++, start, size - start);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\n}\r\nreturn i ? 1 : 0;\r\n}
