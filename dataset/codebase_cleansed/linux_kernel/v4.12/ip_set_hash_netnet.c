static inline bool\r\nhash_netnet4_data_equal(const struct hash_netnet4_elem *ip1,\r\nconst struct hash_netnet4_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ip1->ipcmp == ip2->ipcmp &&\r\nip1->ccmp == ip2->ccmp;\r\n}\r\nstatic inline int\r\nhash_netnet4_do_data_match(const struct hash_netnet4_elem *elem)\r\n{\r\nreturn elem->nomatch ? -ENOTEMPTY : 1;\r\n}\r\nstatic inline void\r\nhash_netnet4_data_set_flags(struct hash_netnet4_elem *elem, u32 flags)\r\n{\r\nelem->nomatch = (flags >> 16) & IPSET_FLAG_NOMATCH;\r\n}\r\nstatic inline void\r\nhash_netnet4_data_reset_flags(struct hash_netnet4_elem *elem, u8 *flags)\r\n{\r\nswap(*flags, elem->nomatch);\r\n}\r\nstatic inline void\r\nhash_netnet4_data_reset_elem(struct hash_netnet4_elem *elem,\r\nstruct hash_netnet4_elem *orig)\r\n{\r\nelem->ip[1] = orig->ip[1];\r\n}\r\nstatic inline void\r\nhash_netnet4_data_netmask(struct hash_netnet4_elem *elem, u8 cidr, bool inner)\r\n{\r\nif (inner) {\r\nelem->ip[1] &= ip_set_netmask(cidr);\r\nelem->cidr[1] = cidr;\r\n} else {\r\nelem->ip[0] &= ip_set_netmask(cidr);\r\nelem->cidr[0] = cidr;\r\n}\r\n}\r\nstatic bool\r\nhash_netnet4_data_list(struct sk_buff *skb,\r\nconst struct hash_netnet4_elem *data)\r\n{\r\nu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\r\nif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip[0]) ||\r\nnla_put_ipaddr4(skb, IPSET_ATTR_IP2, data->ip[1]) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\r\n(flags &&\r\nnla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\r\ngoto nla_put_failure;\r\nreturn false;\r\nnla_put_failure:\r\nreturn true;\r\n}\r\nstatic inline void\r\nhash_netnet4_data_next(struct hash_netnet4_elem *next,\r\nconst struct hash_netnet4_elem *d)\r\n{\r\nnext->ipcmp = d->ipcmp;\r\n}\r\nstatic void\r\nhash_netnet4_init(struct hash_netnet4_elem *e)\r\n{\r\ne->cidr[0] = HOST_MASK;\r\ne->cidr[1] = HOST_MASK;\r\n}\r\nstatic int\r\nhash_netnet4_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nconst struct hash_netnet4 *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netnet4_elem e = { };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\ne.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\r\ne.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\r\nif (adt == IPSET_TEST)\r\ne.ccmp = (HOST_MASK << (sizeof(e.cidr[0]) * 8)) | HOST_MASK;\r\nip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0]);\r\nip4addrptr(skb, opt->flags & IPSET_DIM_TWO_SRC, &e.ip[1]);\r\ne.ip[0] &= ip_set_netmask(e.cidr[0]);\r\ne.ip[1] &= ip_set_netmask(e.cidr[1]);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nhash_netnet4_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nconst struct hash_netnet4 *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netnet4_elem e = { };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nu32 ip = 0, ip_to = 0, last;\r\nu32 ip2 = 0, ip2_from = 0, ip2_to = 0, last2;\r\nint ret;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nhash_netnet4_init(&e);\r\nif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2], &ip2_from);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_CIDR]) {\r\ne.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (!e.cidr[0] || e.cidr[0] > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\n}\r\nif (tb[IPSET_ATTR_CIDR2]) {\r\ne.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\r\nif (!e.cidr[1] || e.cidr[1] > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\n}\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\nif (cadt_flags & IPSET_FLAG_NOMATCH)\r\nflags |= (IPSET_FLAG_NOMATCH << 16);\r\n}\r\nif (adt == IPSET_TEST || !(tb[IPSET_ATTR_IP_TO] ||\r\ntb[IPSET_ATTR_IP2_TO])) {\r\ne.ip[0] = htonl(ip & ip_set_hostmask(e.cidr[0]));\r\ne.ip[1] = htonl(ip2_from & ip_set_hostmask(e.cidr[1]));\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nreturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\r\nip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nip_to = ip;\r\nif (tb[IPSET_ATTR_IP_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip_to < ip)\r\nswap(ip, ip_to);\r\nif (unlikely(ip + UINT_MAX == ip_to))\r\nreturn -IPSET_ERR_HASH_RANGE;\r\n} else {\r\nip_set_mask_from_to(ip, ip_to, e.cidr[0]);\r\n}\r\nip2_to = ip2_from;\r\nif (tb[IPSET_ATTR_IP2_TO]) {\r\nret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2_TO], &ip2_to);\r\nif (ret)\r\nreturn ret;\r\nif (ip2_to < ip2_from)\r\nswap(ip2_from, ip2_to);\r\nif (unlikely(ip2_from + UINT_MAX == ip2_to))\r\nreturn -IPSET_ERR_HASH_RANGE;\r\n} else {\r\nip_set_mask_from_to(ip2_from, ip2_to, e.cidr[1]);\r\n}\r\nif (retried)\r\nip = ntohl(h->next.ip[0]);\r\nwhile (!after(ip, ip_to)) {\r\ne.ip[0] = htonl(ip);\r\nlast = ip_set_range_to_cidr(ip, ip_to, &e.cidr[0]);\r\nip2 = (retried &&\r\nip == ntohl(h->next.ip[0])) ? ntohl(h->next.ip[1])\r\n: ip2_from;\r\nwhile (!after(ip2, ip2_to)) {\r\ne.ip[1] = htonl(ip2);\r\nlast2 = ip_set_range_to_cidr(ip2, ip2_to, &e.cidr[1]);\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nif (ret && !ip_set_eexist(ret, flags))\r\nreturn ret;\r\nret = 0;\r\nip2 = last2 + 1;\r\n}\r\nip = last + 1;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline bool\r\nhash_netnet6_data_equal(const struct hash_netnet6_elem *ip1,\r\nconst struct hash_netnet6_elem *ip2,\r\nu32 *multi)\r\n{\r\nreturn ipv6_addr_equal(&ip1->ip[0].in6, &ip2->ip[0].in6) &&\r\nipv6_addr_equal(&ip1->ip[1].in6, &ip2->ip[1].in6) &&\r\nip1->ccmp == ip2->ccmp;\r\n}\r\nstatic inline int\r\nhash_netnet6_do_data_match(const struct hash_netnet6_elem *elem)\r\n{\r\nreturn elem->nomatch ? -ENOTEMPTY : 1;\r\n}\r\nstatic inline void\r\nhash_netnet6_data_set_flags(struct hash_netnet6_elem *elem, u32 flags)\r\n{\r\nelem->nomatch = (flags >> 16) & IPSET_FLAG_NOMATCH;\r\n}\r\nstatic inline void\r\nhash_netnet6_data_reset_flags(struct hash_netnet6_elem *elem, u8 *flags)\r\n{\r\nswap(*flags, elem->nomatch);\r\n}\r\nstatic inline void\r\nhash_netnet6_data_reset_elem(struct hash_netnet6_elem *elem,\r\nstruct hash_netnet6_elem *orig)\r\n{\r\nelem->ip[1] = orig->ip[1];\r\n}\r\nstatic inline void\r\nhash_netnet6_data_netmask(struct hash_netnet6_elem *elem, u8 cidr, bool inner)\r\n{\r\nif (inner) {\r\nip6_netmask(&elem->ip[1], cidr);\r\nelem->cidr[1] = cidr;\r\n} else {\r\nip6_netmask(&elem->ip[0], cidr);\r\nelem->cidr[0] = cidr;\r\n}\r\n}\r\nstatic bool\r\nhash_netnet6_data_list(struct sk_buff *skb,\r\nconst struct hash_netnet6_elem *data)\r\n{\r\nu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\r\nif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &data->ip[0].in6) ||\r\nnla_put_ipaddr6(skb, IPSET_ATTR_IP2, &data->ip[1].in6) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\r\nnla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\r\n(flags &&\r\nnla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\r\ngoto nla_put_failure;\r\nreturn false;\r\nnla_put_failure:\r\nreturn true;\r\n}\r\nstatic inline void\r\nhash_netnet6_data_next(struct hash_netnet6_elem *next,\r\nconst struct hash_netnet6_elem *d)\r\n{\r\n}\r\nstatic void\r\nhash_netnet6_init(struct hash_netnet6_elem *e)\r\n{\r\ne->cidr[0] = HOST_MASK;\r\ne->cidr[1] = HOST_MASK;\r\n}\r\nstatic int\r\nhash_netnet6_kadt(struct ip_set *set, const struct sk_buff *skb,\r\nconst struct xt_action_param *par,\r\nenum ipset_adt adt, struct ip_set_adt_opt *opt)\r\n{\r\nconst struct hash_netnet6 *h = set->data;\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netnet6_elem e = { };\r\nstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\r\ne.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\r\ne.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\r\nif (adt == IPSET_TEST)\r\ne.ccmp = (HOST_MASK << (sizeof(u8) * 8)) | HOST_MASK;\r\nip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0].in6);\r\nip6addrptr(skb, opt->flags & IPSET_DIM_TWO_SRC, &e.ip[1].in6);\r\nip6_netmask(&e.ip[0], e.cidr[0]);\r\nip6_netmask(&e.ip[1], e.cidr[1]);\r\nreturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\r\n}\r\nstatic int\r\nhash_netnet6_uadt(struct ip_set *set, struct nlattr *tb[],\r\nenum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\r\n{\r\nipset_adtfn adtfn = set->variant->adt[adt];\r\nstruct hash_netnet6_elem e = { };\r\nstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\r\nint ret;\r\nif (tb[IPSET_ATTR_LINENO])\r\n*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\r\nhash_netnet6_init(&e);\r\nif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\r\n!ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\r\nreturn -IPSET_ERR_PROTOCOL;\r\nif (unlikely(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_IP2_TO]))\r\nreturn -IPSET_ERR_HASH_RANGE_UNSUPPORTED;\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip[0]);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP2], &e.ip[1]);\r\nif (ret)\r\nreturn ret;\r\nret = ip_set_get_extensions(set, tb, &ext);\r\nif (ret)\r\nreturn ret;\r\nif (tb[IPSET_ATTR_CIDR]) {\r\ne.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\r\nif (!e.cidr[0] || e.cidr[0] > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\n}\r\nif (tb[IPSET_ATTR_CIDR2]) {\r\ne.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\r\nif (!e.cidr[1] || e.cidr[1] > HOST_MASK)\r\nreturn -IPSET_ERR_INVALID_CIDR;\r\n}\r\nip6_netmask(&e.ip[0], e.cidr[0]);\r\nip6_netmask(&e.ip[1], e.cidr[1]);\r\nif (tb[IPSET_ATTR_CADT_FLAGS]) {\r\nu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\r\nif (cadt_flags & IPSET_FLAG_NOMATCH)\r\nflags |= (IPSET_FLAG_NOMATCH << 16);\r\n}\r\nret = adtfn(set, &e, &ext, &ext, flags);\r\nreturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\r\nip_set_eexist(ret, flags) ? 0 : ret;\r\n}\r\nstatic int __init\r\nhash_netnet_init(void)\r\n{\r\nreturn ip_set_type_register(&hash_netnet_type);\r\n}\r\nstatic void __exit\r\nhash_netnet_fini(void)\r\n{\r\nrcu_barrier();\r\nip_set_type_unregister(&hash_netnet_type);\r\n}
