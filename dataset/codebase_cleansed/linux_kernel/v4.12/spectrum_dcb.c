static u8 mlxsw_sp_dcbnl_getdcbx(struct net_device __always_unused *dev)\r\n{\r\nreturn DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE;\r\n}\r\nstatic u8 mlxsw_sp_dcbnl_setdcbx(struct net_device __always_unused *dev,\r\nu8 mode)\r\n{\r\nreturn (mode != (DCB_CAP_DCBX_HOST | DCB_CAP_DCBX_VER_IEEE)) ? 1 : 0;\r\n}\r\nstatic int mlxsw_sp_dcbnl_ieee_getets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nmemcpy(ets, mlxsw_sp_port->dcb.ets, sizeof(*ets));\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_ets_validate(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct net_device *dev = mlxsw_sp_port->dev;\r\nbool has_ets_tc = false;\r\nint i, tx_bw_sum = 0;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\nhas_ets_tc = true;\r\ntx_bw_sum += ets->tc_tx_bw[i];\r\nbreak;\r\ndefault:\r\nnetdev_err(dev, "Only strict priority and ETS are supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (ets->prio_tc[i] >= IEEE_8021QAZ_MAX_TCS) {\r\nnetdev_err(dev, "Invalid TC\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (has_ets_tc && tx_bw_sum != 100) {\r\nnetdev_err(dev, "Total ETS bandwidth should equal 100\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_pg_prio_map(struct mlxsw_sp_port *mlxsw_sp_port,\r\nu8 *prio_tc)\r\n{\r\nchar pptb_pl[MLXSW_REG_PPTB_LEN];\r\nint i;\r\nmlxsw_reg_pptb_pack(pptb_pl, mlxsw_sp_port->local_port);\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nmlxsw_reg_pptb_prio_to_buff_pack(pptb_pl, i, prio_tc[i]);\r\nreturn mlxsw_reg_write(mlxsw_sp_port->mlxsw_sp->core, MLXSW_REG(pptb),\r\npptb_pl);\r\n}\r\nstatic bool mlxsw_sp_ets_has_pg(u8 *prio_tc, u8 pg)\r\n{\r\nint i;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nif (prio_tc[i] == pg)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int mlxsw_sp_port_pg_destroy(struct mlxsw_sp_port *mlxsw_sp_port,\r\nu8 *old_prio_tc, u8 *new_prio_tc)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nchar pbmc_pl[MLXSW_REG_PBMC_LEN];\r\nint err, i;\r\nmlxsw_reg_pbmc_pack(pbmc_pl, mlxsw_sp_port->local_port, 0, 0);\r\nerr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(pbmc), pbmc_pl);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nu8 pg = old_prio_tc[i];\r\nif (!mlxsw_sp_ets_has_pg(new_prio_tc, pg))\r\nmlxsw_reg_pbmc_lossy_buffer_pack(pbmc_pl, pg, 0);\r\n}\r\nreturn mlxsw_reg_write(mlxsw_sp->core, MLXSW_REG(pbmc), pbmc_pl);\r\n}\r\nstatic int mlxsw_sp_port_headroom_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct ieee_ets *ets)\r\n{\r\nbool pause_en = mlxsw_sp_port_is_pause_en(mlxsw_sp_port);\r\nstruct ieee_ets *my_ets = mlxsw_sp_port->dcb.ets;\r\nstruct net_device *dev = mlxsw_sp_port->dev;\r\nint err;\r\nerr = __mlxsw_sp_port_headroom_set(mlxsw_sp_port, dev->mtu,\r\nets->prio_tc, pause_en,\r\nmlxsw_sp_port->dcb.pfc);\r\nif (err) {\r\nnetdev_err(dev, "Failed to configure port's headroom\n");\r\nreturn err;\r\n}\r\nerr = mlxsw_sp_port_pg_prio_map(mlxsw_sp_port, ets->prio_tc);\r\nif (err) {\r\nnetdev_err(dev, "Failed to set PG-priority mapping\n");\r\ngoto err_port_prio_pg_map;\r\n}\r\nerr = mlxsw_sp_port_pg_destroy(mlxsw_sp_port, my_ets->prio_tc,\r\nets->prio_tc);\r\nif (err)\r\nnetdev_warn(dev, "Failed to remove ununsed PGs\n");\r\nreturn 0;\r\nerr_port_prio_pg_map:\r\nmlxsw_sp_port_pg_destroy(mlxsw_sp_port, ets->prio_tc, my_ets->prio_tc);\r\nreturn err;\r\n}\r\nstatic int __mlxsw_sp_dcbnl_ieee_setets(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct ieee_ets *my_ets = mlxsw_sp_port->dcb.ets;\r\nstruct net_device *dev = mlxsw_sp_port->dev;\r\nint i, err;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nbool dwrr = ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS;\r\nu8 weight = ets->tc_tx_bw[i];\r\nerr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\r\nMLXSW_REG_QEEC_HIERARCY_SUBGROUP, i,\r\n0, dwrr, weight);\r\nif (err) {\r\nnetdev_err(dev, "Failed to link subgroup ETS element %d to group\n",\r\ni);\r\ngoto err_port_ets_set;\r\n}\r\n}\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nerr = mlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i,\r\nets->prio_tc[i]);\r\nif (err) {\r\nnetdev_err(dev, "Failed to map prio %d to TC %d\n", i,\r\nets->prio_tc[i]);\r\ngoto err_port_prio_tc_set;\r\n}\r\n}\r\nerr = mlxsw_sp_port_headroom_set(mlxsw_sp_port, ets);\r\nif (err)\r\ngoto err_port_headroom_set;\r\nreturn 0;\r\nerr_port_headroom_set:\r\ni = IEEE_8021QAZ_MAX_TCS;\r\nerr_port_prio_tc_set:\r\nfor (i--; i >= 0; i--)\r\nmlxsw_sp_port_prio_tc_set(mlxsw_sp_port, i, my_ets->prio_tc[i]);\r\ni = IEEE_8021QAZ_MAX_TCS;\r\nerr_port_ets_set:\r\nfor (i--; i >= 0; i--) {\r\nbool dwrr = my_ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS;\r\nu8 weight = my_ets->tc_tx_bw[i];\r\nerr = mlxsw_sp_port_ets_set(mlxsw_sp_port,\r\nMLXSW_REG_QEEC_HIERARCY_SUBGROUP, i,\r\n0, dwrr, weight);\r\n}\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_dcbnl_ieee_setets(struct net_device *dev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nint err;\r\nerr = mlxsw_sp_port_ets_validate(mlxsw_sp_port, ets);\r\nif (err)\r\nreturn err;\r\nerr = __mlxsw_sp_dcbnl_ieee_setets(mlxsw_sp_port, ets);\r\nif (err)\r\nreturn err;\r\nmemcpy(mlxsw_sp_port->dcb.ets, ets, sizeof(*ets));\r\nmlxsw_sp_port->dcb.ets->ets_cap = IEEE_8021QAZ_MAX_TCS;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_dcbnl_ieee_getmaxrate(struct net_device *dev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nmemcpy(maxrate, mlxsw_sp_port->dcb.maxrate, sizeof(*maxrate));\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_dcbnl_ieee_setmaxrate(struct net_device *dev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nstruct ieee_maxrate *my_maxrate = mlxsw_sp_port->dcb.maxrate;\r\nint err, i;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nerr = mlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\r\nMLXSW_REG_QEEC_HIERARCY_SUBGROUP,\r\ni, 0,\r\nmaxrate->tc_maxrate[i]);\r\nif (err) {\r\nnetdev_err(dev, "Failed to set maxrate for TC %d\n", i);\r\ngoto err_port_ets_maxrate_set;\r\n}\r\n}\r\nmemcpy(mlxsw_sp_port->dcb.maxrate, maxrate, sizeof(*maxrate));\r\nreturn 0;\r\nerr_port_ets_maxrate_set:\r\nfor (i--; i >= 0; i--)\r\nmlxsw_sp_port_ets_maxrate_set(mlxsw_sp_port,\r\nMLXSW_REG_QEEC_HIERARCY_SUBGROUP,\r\ni, 0, my_maxrate->tc_maxrate[i]);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_pfc_cnt_get(struct mlxsw_sp_port *mlxsw_sp_port,\r\nu8 prio)\r\n{\r\nstruct mlxsw_sp *mlxsw_sp = mlxsw_sp_port->mlxsw_sp;\r\nstruct ieee_pfc *my_pfc = mlxsw_sp_port->dcb.pfc;\r\nchar ppcnt_pl[MLXSW_REG_PPCNT_LEN];\r\nint err;\r\nmlxsw_reg_ppcnt_pack(ppcnt_pl, mlxsw_sp_port->local_port,\r\nMLXSW_REG_PPCNT_PRIO_CNT, prio);\r\nerr = mlxsw_reg_query(mlxsw_sp->core, MLXSW_REG(ppcnt), ppcnt_pl);\r\nif (err)\r\nreturn err;\r\nmy_pfc->requests[prio] = mlxsw_reg_ppcnt_tx_pause_get(ppcnt_pl);\r\nmy_pfc->indications[prio] = mlxsw_reg_ppcnt_rx_pause_get(ppcnt_pl);\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_dcbnl_ieee_getpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nint err, i;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nerr = mlxsw_sp_port_pfc_cnt_get(mlxsw_sp_port, i);\r\nif (err) {\r\nnetdev_err(dev, "Failed to get PFC count for priority %d\n",\r\ni);\r\nreturn err;\r\n}\r\n}\r\nmemcpy(pfc, mlxsw_sp_port->dcb.pfc, sizeof(*pfc));\r\nreturn 0;\r\n}\r\nstatic int mlxsw_sp_port_pfc_set(struct mlxsw_sp_port *mlxsw_sp_port,\r\nstruct ieee_pfc *pfc)\r\n{\r\nchar pfcc_pl[MLXSW_REG_PFCC_LEN];\r\nmlxsw_reg_pfcc_pack(pfcc_pl, mlxsw_sp_port->local_port);\r\nmlxsw_reg_pfcc_pprx_set(pfcc_pl, mlxsw_sp_port->link.rx_pause);\r\nmlxsw_reg_pfcc_pptx_set(pfcc_pl, mlxsw_sp_port->link.tx_pause);\r\nmlxsw_reg_pfcc_prio_pack(pfcc_pl, pfc->pfc_en);\r\nreturn mlxsw_reg_write(mlxsw_sp_port->mlxsw_sp->core, MLXSW_REG(pfcc),\r\npfcc_pl);\r\n}\r\nstatic int mlxsw_sp_dcbnl_ieee_setpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlxsw_sp_port *mlxsw_sp_port = netdev_priv(dev);\r\nbool pause_en = mlxsw_sp_port_is_pause_en(mlxsw_sp_port);\r\nint err;\r\nif (pause_en && pfc->pfc_en) {\r\nnetdev_err(dev, "PAUSE frames already enabled on port\n");\r\nreturn -EINVAL;\r\n}\r\nerr = __mlxsw_sp_port_headroom_set(mlxsw_sp_port, dev->mtu,\r\nmlxsw_sp_port->dcb.ets->prio_tc,\r\npause_en, pfc);\r\nif (err) {\r\nnetdev_err(dev, "Failed to configure port's headroom for PFC\n");\r\nreturn err;\r\n}\r\nerr = mlxsw_sp_port_pfc_set(mlxsw_sp_port, pfc);\r\nif (err) {\r\nnetdev_err(dev, "Failed to configure PFC\n");\r\ngoto err_port_pfc_set;\r\n}\r\nmemcpy(mlxsw_sp_port->dcb.pfc, pfc, sizeof(*pfc));\r\nmlxsw_sp_port->dcb.pfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\r\nreturn 0;\r\nerr_port_pfc_set:\r\n__mlxsw_sp_port_headroom_set(mlxsw_sp_port, dev->mtu,\r\nmlxsw_sp_port->dcb.ets->prio_tc, pause_en,\r\nmlxsw_sp_port->dcb.pfc);\r\nreturn err;\r\n}\r\nstatic int mlxsw_sp_port_ets_init(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nmlxsw_sp_port->dcb.ets = kzalloc(sizeof(*mlxsw_sp_port->dcb.ets),\r\nGFP_KERNEL);\r\nif (!mlxsw_sp_port->dcb.ets)\r\nreturn -ENOMEM;\r\nmlxsw_sp_port->dcb.ets->ets_cap = IEEE_8021QAZ_MAX_TCS;\r\nreturn 0;\r\n}\r\nstatic void mlxsw_sp_port_ets_fini(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nkfree(mlxsw_sp_port->dcb.ets);\r\n}\r\nstatic int mlxsw_sp_port_maxrate_init(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nint i;\r\nmlxsw_sp_port->dcb.maxrate = kmalloc(sizeof(*mlxsw_sp_port->dcb.maxrate),\r\nGFP_KERNEL);\r\nif (!mlxsw_sp_port->dcb.maxrate)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++)\r\nmlxsw_sp_port->dcb.maxrate->tc_maxrate[i] = MLXSW_REG_QEEC_MAS_DIS;\r\nreturn 0;\r\n}\r\nstatic void mlxsw_sp_port_maxrate_fini(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nkfree(mlxsw_sp_port->dcb.maxrate);\r\n}\r\nstatic int mlxsw_sp_port_pfc_init(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nmlxsw_sp_port->dcb.pfc = kzalloc(sizeof(*mlxsw_sp_port->dcb.pfc),\r\nGFP_KERNEL);\r\nif (!mlxsw_sp_port->dcb.pfc)\r\nreturn -ENOMEM;\r\nmlxsw_sp_port->dcb.pfc->pfc_cap = IEEE_8021QAZ_MAX_TCS;\r\nreturn 0;\r\n}\r\nstatic void mlxsw_sp_port_pfc_fini(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nkfree(mlxsw_sp_port->dcb.pfc);\r\n}\r\nint mlxsw_sp_port_dcb_init(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nint err;\r\nerr = mlxsw_sp_port_ets_init(mlxsw_sp_port);\r\nif (err)\r\nreturn err;\r\nerr = mlxsw_sp_port_maxrate_init(mlxsw_sp_port);\r\nif (err)\r\ngoto err_port_maxrate_init;\r\nerr = mlxsw_sp_port_pfc_init(mlxsw_sp_port);\r\nif (err)\r\ngoto err_port_pfc_init;\r\nmlxsw_sp_port->dev->dcbnl_ops = &mlxsw_sp_dcbnl_ops;\r\nreturn 0;\r\nerr_port_pfc_init:\r\nmlxsw_sp_port_maxrate_fini(mlxsw_sp_port);\r\nerr_port_maxrate_init:\r\nmlxsw_sp_port_ets_fini(mlxsw_sp_port);\r\nreturn err;\r\n}\r\nvoid mlxsw_sp_port_dcb_fini(struct mlxsw_sp_port *mlxsw_sp_port)\r\n{\r\nmlxsw_sp_port_pfc_fini(mlxsw_sp_port);\r\nmlxsw_sp_port_maxrate_fini(mlxsw_sp_port);\r\nmlxsw_sp_port_ets_fini(mlxsw_sp_port);\r\n}
