static inline int\r\nldlm_same_flock_owner(struct ldlm_lock *lock, struct ldlm_lock *new)\r\n{\r\nreturn((new->l_policy_data.l_flock.owner ==\r\nlock->l_policy_data.l_flock.owner) &&\r\n(new->l_export == lock->l_export));\r\n}\r\nstatic inline int\r\nldlm_flocks_overlap(struct ldlm_lock *lock, struct ldlm_lock *new)\r\n{\r\nreturn((new->l_policy_data.l_flock.start <=\r\nlock->l_policy_data.l_flock.end) &&\r\n(new->l_policy_data.l_flock.end >=\r\nlock->l_policy_data.l_flock.start));\r\n}\r\nstatic inline void\r\nldlm_flock_destroy(struct ldlm_lock *lock, enum ldlm_mode mode, __u64 flags)\r\n{\r\nLDLM_DEBUG(lock, "ldlm_flock_destroy(mode: %d, flags: 0x%llx)",\r\nmode, flags);\r\nLASSERT(hlist_unhashed(&lock->l_exp_flock_hash));\r\nlist_del_init(&lock->l_res_link);\r\nif (flags == LDLM_FL_WAIT_NOREPROC) {\r\nlock->l_flags |= LDLM_FL_LOCAL_ONLY | LDLM_FL_CBPENDING;\r\nldlm_lock_decref_internal_nolock(lock, mode);\r\n}\r\nldlm_lock_destroy_nolock(lock);\r\n}\r\nstatic int ldlm_process_flock_lock(struct ldlm_lock *req, __u64 *flags,\r\nint first_enq, enum ldlm_error *err,\r\nstruct list_head *work_list)\r\n{\r\nstruct ldlm_resource *res = req->l_resource;\r\nstruct ldlm_namespace *ns = ldlm_res_to_ns(res);\r\nstruct list_head *tmp;\r\nstruct list_head *ownlocks = NULL;\r\nstruct ldlm_lock *lock = NULL;\r\nstruct ldlm_lock *new = req;\r\nstruct ldlm_lock *new2 = NULL;\r\nenum ldlm_mode mode = req->l_req_mode;\r\nint added = (mode == LCK_NL);\r\nint overlaps = 0;\r\nint splitted = 0;\r\nconst struct ldlm_callback_suite null_cbs = { };\r\nCDEBUG(D_DLMTRACE,\r\n"flags %#llx owner %llu pid %u mode %u start %llu end %llu\n",\r\n*flags, new->l_policy_data.l_flock.owner,\r\nnew->l_policy_data.l_flock.pid, mode,\r\nreq->l_policy_data.l_flock.start,\r\nreq->l_policy_data.l_flock.end);\r\n*err = ELDLM_OK;\r\nreq->l_blocking_ast = NULL;\r\nreprocess:\r\nif ((*flags == LDLM_FL_WAIT_NOREPROC) || (mode == LCK_NL)) {\r\nlist_for_each(tmp, &res->lr_granted) {\r\nlock = list_entry(tmp, struct ldlm_lock,\r\nl_res_link);\r\nif (ldlm_same_flock_owner(lock, req)) {\r\nownlocks = tmp;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nint reprocess_failed = 0;\r\nlockmode_verify(mode);\r\nlist_for_each(tmp, &res->lr_granted) {\r\nlock = list_entry(tmp, struct ldlm_lock,\r\nl_res_link);\r\nif (ldlm_same_flock_owner(lock, req)) {\r\nif (!ownlocks)\r\nownlocks = tmp;\r\ncontinue;\r\n}\r\nif (lockmode_compat(lock->l_granted_mode, mode))\r\ncontinue;\r\nif (!ldlm_flocks_overlap(lock, req))\r\ncontinue;\r\nif (!first_enq) {\r\nreprocess_failed = 1;\r\ncontinue;\r\n}\r\nif (*flags & LDLM_FL_BLOCK_NOWAIT) {\r\nldlm_flock_destroy(req, mode, *flags);\r\n*err = -EAGAIN;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nif (*flags & LDLM_FL_TEST_LOCK) {\r\nldlm_flock_destroy(req, mode, *flags);\r\nreq->l_req_mode = lock->l_granted_mode;\r\nreq->l_policy_data.l_flock.pid =\r\nlock->l_policy_data.l_flock.pid;\r\nreq->l_policy_data.l_flock.start =\r\nlock->l_policy_data.l_flock.start;\r\nreq->l_policy_data.l_flock.end =\r\nlock->l_policy_data.l_flock.end;\r\n*flags |= LDLM_FL_LOCK_CHANGED;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nldlm_resource_add_lock(res, &res->lr_waiting, req);\r\n*flags |= LDLM_FL_BLOCK_GRANTED;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nif (reprocess_failed)\r\nreturn LDLM_ITER_CONTINUE;\r\n}\r\nif (*flags & LDLM_FL_TEST_LOCK) {\r\nldlm_flock_destroy(req, mode, *flags);\r\nreq->l_req_mode = LCK_NL;\r\n*flags |= LDLM_FL_LOCK_CHANGED;\r\nreturn LDLM_ITER_STOP;\r\n}\r\nif (!ownlocks)\r\nownlocks = &res->lr_granted;\r\nlist_for_remaining_safe(ownlocks, tmp, &res->lr_granted) {\r\nlock = list_entry(ownlocks, struct ldlm_lock, l_res_link);\r\nif (!ldlm_same_flock_owner(lock, new))\r\nbreak;\r\nif (lock->l_granted_mode == mode) {\r\nif ((new->l_policy_data.l_flock.start >\r\n(lock->l_policy_data.l_flock.end + 1)) &&\r\n(lock->l_policy_data.l_flock.end != OBD_OBJECT_EOF))\r\ncontinue;\r\nif ((new->l_policy_data.l_flock.end <\r\n(lock->l_policy_data.l_flock.start - 1)) &&\r\n(lock->l_policy_data.l_flock.start != 0))\r\nbreak;\r\nif (new->l_policy_data.l_flock.start <\r\nlock->l_policy_data.l_flock.start) {\r\nlock->l_policy_data.l_flock.start =\r\nnew->l_policy_data.l_flock.start;\r\n} else {\r\nnew->l_policy_data.l_flock.start =\r\nlock->l_policy_data.l_flock.start;\r\n}\r\nif (new->l_policy_data.l_flock.end >\r\nlock->l_policy_data.l_flock.end) {\r\nlock->l_policy_data.l_flock.end =\r\nnew->l_policy_data.l_flock.end;\r\n} else {\r\nnew->l_policy_data.l_flock.end =\r\nlock->l_policy_data.l_flock.end;\r\n}\r\nif (added) {\r\nldlm_flock_destroy(lock, mode, *flags);\r\n} else {\r\nnew = lock;\r\nadded = 1;\r\n}\r\ncontinue;\r\n}\r\nif (new->l_policy_data.l_flock.start >\r\nlock->l_policy_data.l_flock.end)\r\ncontinue;\r\nif (new->l_policy_data.l_flock.end <\r\nlock->l_policy_data.l_flock.start)\r\nbreak;\r\n++overlaps;\r\nif (new->l_policy_data.l_flock.start <=\r\nlock->l_policy_data.l_flock.start) {\r\nif (new->l_policy_data.l_flock.end <\r\nlock->l_policy_data.l_flock.end) {\r\nlock->l_policy_data.l_flock.start =\r\nnew->l_policy_data.l_flock.end + 1;\r\nbreak;\r\n}\r\nldlm_flock_destroy(lock, lock->l_req_mode, *flags);\r\ncontinue;\r\n}\r\nif (new->l_policy_data.l_flock.end >=\r\nlock->l_policy_data.l_flock.end) {\r\nlock->l_policy_data.l_flock.end =\r\nnew->l_policy_data.l_flock.start - 1;\r\ncontinue;\r\n}\r\nif (!new2) {\r\nunlock_res_and_lock(req);\r\nnew2 = ldlm_lock_create(ns, &res->lr_name, LDLM_FLOCK,\r\nlock->l_granted_mode, &null_cbs,\r\nNULL, 0, LVB_T_NONE);\r\nlock_res_and_lock(req);\r\nif (IS_ERR(new2)) {\r\nldlm_flock_destroy(req, lock->l_granted_mode,\r\n*flags);\r\n*err = PTR_ERR(new2);\r\nreturn LDLM_ITER_STOP;\r\n}\r\ngoto reprocess;\r\n}\r\nsplitted = 1;\r\nnew2->l_granted_mode = lock->l_granted_mode;\r\nnew2->l_policy_data.l_flock.pid =\r\nnew->l_policy_data.l_flock.pid;\r\nnew2->l_policy_data.l_flock.owner =\r\nnew->l_policy_data.l_flock.owner;\r\nnew2->l_policy_data.l_flock.start =\r\nlock->l_policy_data.l_flock.start;\r\nnew2->l_policy_data.l_flock.end =\r\nnew->l_policy_data.l_flock.start - 1;\r\nlock->l_policy_data.l_flock.start =\r\nnew->l_policy_data.l_flock.end + 1;\r\nnew2->l_conn_export = lock->l_conn_export;\r\nif (lock->l_export) {\r\nnew2->l_export = class_export_lock_get(lock->l_export,\r\nnew2);\r\nif (new2->l_export->exp_lock_hash &&\r\nhlist_unhashed(&new2->l_exp_hash))\r\ncfs_hash_add(new2->l_export->exp_lock_hash,\r\n&new2->l_remote_handle,\r\n&new2->l_exp_hash);\r\n}\r\nif (*flags == LDLM_FL_WAIT_NOREPROC)\r\nldlm_lock_addref_internal_nolock(new2,\r\nlock->l_granted_mode);\r\nldlm_resource_add_lock(res, ownlocks, new2);\r\nLDLM_LOCK_RELEASE(new2);\r\nbreak;\r\n}\r\nif (splitted == 0 && new2)\r\nldlm_lock_destroy_nolock(new2);\r\nreq->l_granted_mode = req->l_req_mode;\r\nif (!added) {\r\nlist_del_init(&req->l_res_link);\r\nldlm_resource_add_lock(res, ownlocks, req);\r\n}\r\nif (*flags != LDLM_FL_WAIT_NOREPROC) {\r\nCERROR("Illegal parameter for client-side-only module.\n");\r\nLBUG();\r\n}\r\nif (added)\r\nldlm_flock_destroy(req, mode, *flags);\r\nldlm_resource_dump(D_INFO, res);\r\nreturn LDLM_ITER_CONTINUE;\r\n}\r\nstatic void\r\nldlm_flock_interrupted_wait(void *data)\r\n{\r\nstruct ldlm_lock *lock;\r\nlock = ((struct ldlm_flock_wait_data *)data)->fwd_lock;\r\nlock_res_and_lock(lock);\r\nldlm_set_cbpending(lock);\r\nunlock_res_and_lock(lock);\r\n}\r\nint\r\nldlm_flock_completion_ast(struct ldlm_lock *lock, __u64 flags, void *data)\r\n{\r\nstruct file_lock *getlk = lock->l_ast_data;\r\nstruct obd_device *obd;\r\nstruct obd_import *imp = NULL;\r\nstruct ldlm_flock_wait_data fwd;\r\nstruct l_wait_info lwi;\r\nenum ldlm_error err;\r\nint rc = 0;\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT2, 4);\r\nif (OBD_FAIL_PRECHECK(OBD_FAIL_LDLM_CP_CB_WAIT3)) {\r\nlock_res_and_lock(lock);\r\nlock->l_flags |= LDLM_FL_FAIL_LOC;\r\nunlock_res_and_lock(lock);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT3, 4);\r\n}\r\nCDEBUG(D_DLMTRACE, "flags: 0x%llx data: %p getlk: %p\n",\r\nflags, data, getlk);\r\nLASSERT(flags != LDLM_FL_WAIT_NOREPROC);\r\nif (flags & LDLM_FL_FAILED)\r\ngoto granted;\r\nif (!(flags & LDLM_FL_BLOCKED_MASK)) {\r\nif (!data)\r\ngoto granted;\r\nwake_up(&lock->l_waitq);\r\nreturn 0;\r\n}\r\nLDLM_DEBUG(lock, "client-side enqueue returned a blocked lock, sleeping");\r\nfwd.fwd_lock = lock;\r\nobd = class_exp2obd(lock->l_conn_export);\r\nif (obd)\r\nimp = obd->u.cli.cl_import;\r\nif (imp) {\r\nspin_lock(&imp->imp_lock);\r\nfwd.fwd_generation = imp->imp_generation;\r\nspin_unlock(&imp->imp_lock);\r\n}\r\nlwi = LWI_TIMEOUT_INTR(0, NULL, ldlm_flock_interrupted_wait, &fwd);\r\nrc = l_wait_event(lock->l_waitq, is_granted_or_cancelled(lock), &lwi);\r\nif (rc) {\r\nLDLM_DEBUG(lock, "client-side enqueue waking up: failed (%d)",\r\nrc);\r\nreturn rc;\r\n}\r\ngranted:\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT, 10);\r\nif (OBD_FAIL_PRECHECK(OBD_FAIL_LDLM_CP_CB_WAIT4)) {\r\nlock_res_and_lock(lock);\r\nlock->l_flags |= LDLM_FL_FLOCK_DEADLOCK | LDLM_FL_CBPENDING;\r\nunlock_res_and_lock(lock);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT4, 4);\r\n}\r\nif (OBD_FAIL_PRECHECK(OBD_FAIL_LDLM_CP_CB_WAIT5)) {\r\nlock_res_and_lock(lock);\r\nlock->l_flags |= LDLM_FL_FAIL_LOC |\r\nLDLM_FL_FLOCK_DEADLOCK | LDLM_FL_CBPENDING;\r\nunlock_res_and_lock(lock);\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_LDLM_CP_CB_WAIT5, 4);\r\n}\r\nlock_res_and_lock(lock);\r\nif (ldlm_is_destroyed(lock)) {\r\nunlock_res_and_lock(lock);\r\nLDLM_DEBUG(lock, "client-side enqueue waking up: destroyed");\r\nreturn -EIO;\r\n}\r\nldlm_resource_unlink_lock(lock);\r\nif (ldlm_is_failed(lock) || ldlm_is_flock_deadlock(lock)) {\r\nint mode;\r\nif (flags & LDLM_FL_TEST_LOCK)\r\nLASSERT(ldlm_is_test_lock(lock));\r\nif (ldlm_is_test_lock(lock) || ldlm_is_flock_deadlock(lock))\r\nmode = getlk->fl_type;\r\nelse\r\nmode = lock->l_granted_mode;\r\nif (ldlm_is_flock_deadlock(lock)) {\r\nLDLM_DEBUG(lock, "client-side enqueue deadlock received");\r\nrc = -EDEADLK;\r\n}\r\nldlm_flock_destroy(lock, mode, LDLM_FL_WAIT_NOREPROC);\r\nunlock_res_and_lock(lock);\r\nwake_up(&lock->l_waitq);\r\nreturn rc ? : -EIO;\r\n}\r\nLDLM_DEBUG(lock, "client-side enqueue granted");\r\nif (flags & LDLM_FL_TEST_LOCK) {\r\nLASSERT(ldlm_is_test_lock(lock));\r\nldlm_flock_destroy(lock, getlk->fl_type, LDLM_FL_WAIT_NOREPROC);\r\nswitch (lock->l_granted_mode) {\r\ncase LCK_PR:\r\ngetlk->fl_type = F_RDLCK;\r\nbreak;\r\ncase LCK_PW:\r\ngetlk->fl_type = F_WRLCK;\r\nbreak;\r\ndefault:\r\ngetlk->fl_type = F_UNLCK;\r\n}\r\ngetlk->fl_pid = (pid_t)lock->l_policy_data.l_flock.pid;\r\ngetlk->fl_start = (loff_t)lock->l_policy_data.l_flock.start;\r\ngetlk->fl_end = (loff_t)lock->l_policy_data.l_flock.end;\r\n} else {\r\n__u64 noreproc = LDLM_FL_WAIT_NOREPROC;\r\nldlm_process_flock_lock(lock, &noreproc, 1, &err, NULL);\r\n}\r\nunlock_res_and_lock(lock);\r\nreturn rc;\r\n}\r\nvoid ldlm_flock_policy_wire_to_local(const union ldlm_wire_policy_data *wpolicy,\r\nunion ldlm_policy_data *lpolicy)\r\n{\r\nlpolicy->l_flock.start = wpolicy->l_flock.lfw_start;\r\nlpolicy->l_flock.end = wpolicy->l_flock.lfw_end;\r\nlpolicy->l_flock.pid = wpolicy->l_flock.lfw_pid;\r\nlpolicy->l_flock.owner = wpolicy->l_flock.lfw_owner;\r\n}\r\nvoid ldlm_flock_policy_local_to_wire(const union ldlm_policy_data *lpolicy,\r\nunion ldlm_wire_policy_data *wpolicy)\r\n{\r\nmemset(wpolicy, 0, sizeof(*wpolicy));\r\nwpolicy->l_flock.lfw_start = lpolicy->l_flock.start;\r\nwpolicy->l_flock.lfw_end = lpolicy->l_flock.end;\r\nwpolicy->l_flock.lfw_pid = lpolicy->l_flock.pid;\r\nwpolicy->l_flock.lfw_owner = lpolicy->l_flock.owner;\r\n}
