static struct platform_device *mtd_to_platdev(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct txx9ndfmc_priv *txx9_priv = nand_get_controller_data(chip);\r\nreturn txx9_priv->dev;\r\n}\r\nstatic void __iomem *ndregaddr(struct platform_device *dev, unsigned int reg)\r\n{\r\nstruct txx9ndfmc_drvdata *drvdata = platform_get_drvdata(dev);\r\nstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\r\nreturn drvdata->base + (reg << plat->shift);\r\n}\r\nstatic u32 txx9ndfmc_read(struct platform_device *dev, unsigned int reg)\r\n{\r\nreturn __raw_readl(ndregaddr(dev, reg));\r\n}\r\nstatic void txx9ndfmc_write(struct platform_device *dev,\r\nu32 val, unsigned int reg)\r\n{\r\n__raw_writel(val, ndregaddr(dev, reg));\r\n}\r\nstatic uint8_t txx9ndfmc_read_byte(struct mtd_info *mtd)\r\n{\r\nstruct platform_device *dev = mtd_to_platdev(mtd);\r\nreturn txx9ndfmc_read(dev, TXX9_NDFDTR);\r\n}\r\nstatic void txx9ndfmc_write_buf(struct mtd_info *mtd, const uint8_t *buf,\r\nint len)\r\n{\r\nstruct platform_device *dev = mtd_to_platdev(mtd);\r\nvoid __iomem *ndfdtr = ndregaddr(dev, TXX9_NDFDTR);\r\nu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_WE, TXX9_NDFMCR);\r\nwhile (len--)\r\n__raw_writel(*buf++, ndfdtr);\r\ntxx9ndfmc_write(dev, mcr, TXX9_NDFMCR);\r\n}\r\nstatic void txx9ndfmc_read_buf(struct mtd_info *mtd, uint8_t *buf, int len)\r\n{\r\nstruct platform_device *dev = mtd_to_platdev(mtd);\r\nvoid __iomem *ndfdtr = ndregaddr(dev, TXX9_NDFDTR);\r\nwhile (len--)\r\n*buf++ = __raw_readl(ndfdtr);\r\n}\r\nstatic void txx9ndfmc_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct txx9ndfmc_priv *txx9_priv = nand_get_controller_data(chip);\r\nstruct platform_device *dev = txx9_priv->dev;\r\nstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\r\nif (ctrl & NAND_CTRL_CHANGE) {\r\nu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\r\nmcr &= ~(TXX9_NDFMCR_CLE | TXX9_NDFMCR_ALE | TXX9_NDFMCR_CE);\r\nmcr |= ctrl & NAND_CLE ? TXX9_NDFMCR_CLE : 0;\r\nmcr |= ctrl & NAND_ALE ? TXX9_NDFMCR_ALE : 0;\r\nmcr |= ctrl & NAND_NCE ? TXX9_NDFMCR_CE : 0;\r\nif (txx9_priv->cs >= 0 && (ctrl & NAND_NCE)) {\r\nmcr &= ~TXX9_NDFMCR_CS_MASK;\r\nmcr |= TXX9_NDFMCR_CS(txx9_priv->cs);\r\n}\r\ntxx9ndfmc_write(dev, mcr, TXX9_NDFMCR);\r\n}\r\nif (cmd != NAND_CMD_NONE)\r\ntxx9ndfmc_write(dev, cmd & 0xff, TXX9_NDFDTR);\r\nif (plat->flags & NDFMC_PLAT_FLAG_DUMMYWRITE) {\r\nif ((ctrl & NAND_CTRL_CHANGE) && cmd == NAND_CMD_NONE)\r\ntxx9ndfmc_write(dev, 0, TXX9_NDFDTR);\r\n}\r\nmmiowb();\r\n}\r\nstatic int txx9ndfmc_dev_ready(struct mtd_info *mtd)\r\n{\r\nstruct platform_device *dev = mtd_to_platdev(mtd);\r\nreturn !(txx9ndfmc_read(dev, TXX9_NDFSR) & TXX9_NDFSR_BUSY);\r\n}\r\nstatic int txx9ndfmc_calculate_ecc(struct mtd_info *mtd, const uint8_t *dat,\r\nuint8_t *ecc_code)\r\n{\r\nstruct platform_device *dev = mtd_to_platdev(mtd);\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nint eccbytes;\r\nu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\r\nmcr &= ~TXX9_NDFMCR_ECC_ALL;\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_OFF, TXX9_NDFMCR);\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_READ, TXX9_NDFMCR);\r\nfor (eccbytes = chip->ecc.bytes; eccbytes > 0; eccbytes -= 3) {\r\necc_code[1] = txx9ndfmc_read(dev, TXX9_NDFDTR);\r\necc_code[0] = txx9ndfmc_read(dev, TXX9_NDFDTR);\r\necc_code[2] = txx9ndfmc_read(dev, TXX9_NDFDTR);\r\necc_code += 3;\r\n}\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_OFF, TXX9_NDFMCR);\r\nreturn 0;\r\n}\r\nstatic int txx9ndfmc_correct_data(struct mtd_info *mtd, unsigned char *buf,\r\nunsigned char *read_ecc, unsigned char *calc_ecc)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nint eccsize;\r\nint corrected = 0;\r\nint stat;\r\nfor (eccsize = chip->ecc.size; eccsize > 0; eccsize -= 256) {\r\nstat = __nand_correct_data(buf, read_ecc, calc_ecc, 256);\r\nif (stat < 0)\r\nreturn stat;\r\ncorrected += stat;\r\nbuf += 256;\r\nread_ecc += 3;\r\ncalc_ecc += 3;\r\n}\r\nreturn corrected;\r\n}\r\nstatic void txx9ndfmc_enable_hwecc(struct mtd_info *mtd, int mode)\r\n{\r\nstruct platform_device *dev = mtd_to_platdev(mtd);\r\nu32 mcr = txx9ndfmc_read(dev, TXX9_NDFMCR);\r\nmcr &= ~TXX9_NDFMCR_ECC_ALL;\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_RESET, TXX9_NDFMCR);\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_OFF, TXX9_NDFMCR);\r\ntxx9ndfmc_write(dev, mcr | TXX9_NDFMCR_ECC_ON, TXX9_NDFMCR);\r\n}\r\nstatic void txx9ndfmc_initialize(struct platform_device *dev)\r\n{\r\nstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\r\nstruct txx9ndfmc_drvdata *drvdata = platform_get_drvdata(dev);\r\nint tmout = 100;\r\nif (plat->flags & NDFMC_PLAT_FLAG_NO_RSTR)\r\n;\r\nelse {\r\ntxx9ndfmc_write(dev,\r\ntxx9ndfmc_read(dev, TXX9_NDFRSTR) |\r\nTXX9_NDFRSTR_RST,\r\nTXX9_NDFRSTR);\r\nwhile (txx9ndfmc_read(dev, TXX9_NDFRSTR) & TXX9_NDFRSTR_RST) {\r\nif (--tmout == 0) {\r\ndev_err(&dev->dev, "reset failed.\n");\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\ntxx9ndfmc_write(dev, (drvdata->hold << 4) | drvdata->spw, TXX9_NDFSPR);\r\ntxx9ndfmc_write(dev,\r\n(plat->flags & NDFMC_PLAT_FLAG_USE_BSPRT) ?\r\nTXX9_NDFMCR_BSPRT : 0, TXX9_NDFMCR);\r\n}\r\nstatic int txx9ndfmc_nand_scan(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nint ret;\r\nret = nand_scan_ident(mtd, 1, NULL);\r\nif (!ret) {\r\nif (mtd->writesize >= 512) {\r\nchip->ecc.size = 512;\r\nchip->ecc.bytes = 6;\r\n}\r\nret = nand_scan_tail(mtd);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init txx9ndfmc_probe(struct platform_device *dev)\r\n{\r\nstruct txx9ndfmc_platform_data *plat = dev_get_platdata(&dev->dev);\r\nint hold, spw;\r\nint i;\r\nstruct txx9ndfmc_drvdata *drvdata;\r\nunsigned long gbusclk = plat->gbus_clock;\r\nstruct resource *res;\r\ndrvdata = devm_kzalloc(&dev->dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\ndrvdata->base = devm_ioremap_resource(&dev->dev, res);\r\nif (IS_ERR(drvdata->base))\r\nreturn PTR_ERR(drvdata->base);\r\nhold = plat->hold ?: 20;\r\nspw = plat->spw ?: 90;\r\nhold = TXX9NDFMC_NS_TO_CYC(gbusclk, hold);\r\nspw = TXX9NDFMC_NS_TO_CYC(gbusclk, spw);\r\nif (plat->flags & NDFMC_PLAT_FLAG_HOLDADD)\r\nhold -= 2;\r\nspw -= 1;\r\nhold = clamp(hold, 1, 15);\r\ndrvdata->hold = hold;\r\nspw = clamp(spw, 1, 15);\r\ndrvdata->spw = spw;\r\ndev_info(&dev->dev, "CLK:%ldMHz HOLD:%d SPW:%d\n",\r\n(gbusclk + 500000) / 1000000, hold, spw);\r\nnand_hw_control_init(&drvdata->hw_control);\r\nplatform_set_drvdata(dev, drvdata);\r\ntxx9ndfmc_initialize(dev);\r\nfor (i = 0; i < MAX_TXX9NDFMC_DEV; i++) {\r\nstruct txx9ndfmc_priv *txx9_priv;\r\nstruct nand_chip *chip;\r\nstruct mtd_info *mtd;\r\nif (!(plat->ch_mask & (1 << i)))\r\ncontinue;\r\ntxx9_priv = kzalloc(sizeof(struct txx9ndfmc_priv),\r\nGFP_KERNEL);\r\nif (!txx9_priv)\r\ncontinue;\r\nchip = &txx9_priv->chip;\r\nmtd = nand_to_mtd(chip);\r\nmtd->dev.parent = &dev->dev;\r\nchip->read_byte = txx9ndfmc_read_byte;\r\nchip->read_buf = txx9ndfmc_read_buf;\r\nchip->write_buf = txx9ndfmc_write_buf;\r\nchip->cmd_ctrl = txx9ndfmc_cmd_ctrl;\r\nchip->dev_ready = txx9ndfmc_dev_ready;\r\nchip->ecc.calculate = txx9ndfmc_calculate_ecc;\r\nchip->ecc.correct = txx9ndfmc_correct_data;\r\nchip->ecc.hwctl = txx9ndfmc_enable_hwecc;\r\nchip->ecc.mode = NAND_ECC_HW;\r\nchip->ecc.size = 256;\r\nchip->ecc.bytes = 3;\r\nchip->ecc.strength = 1;\r\nchip->chip_delay = 100;\r\nchip->controller = &drvdata->hw_control;\r\nnand_set_controller_data(chip, txx9_priv);\r\ntxx9_priv->dev = dev;\r\nif (plat->ch_mask != 1) {\r\ntxx9_priv->cs = i;\r\ntxx9_priv->mtdname = kasprintf(GFP_KERNEL, "%s.%u",\r\ndev_name(&dev->dev), i);\r\n} else {\r\ntxx9_priv->cs = -1;\r\ntxx9_priv->mtdname = kstrdup(dev_name(&dev->dev),\r\nGFP_KERNEL);\r\n}\r\nif (!txx9_priv->mtdname) {\r\nkfree(txx9_priv);\r\ndev_err(&dev->dev, "Unable to allocate MTD name.\n");\r\ncontinue;\r\n}\r\nif (plat->wide_mask & (1 << i))\r\nchip->options |= NAND_BUSWIDTH_16;\r\nif (txx9ndfmc_nand_scan(mtd)) {\r\nkfree(txx9_priv->mtdname);\r\nkfree(txx9_priv);\r\ncontinue;\r\n}\r\nmtd->name = txx9_priv->mtdname;\r\nmtd_device_parse_register(mtd, NULL, NULL, NULL, 0);\r\ndrvdata->mtds[i] = mtd;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __exit txx9ndfmc_remove(struct platform_device *dev)\r\n{\r\nstruct txx9ndfmc_drvdata *drvdata = platform_get_drvdata(dev);\r\nint i;\r\nif (!drvdata)\r\nreturn 0;\r\nfor (i = 0; i < MAX_TXX9NDFMC_DEV; i++) {\r\nstruct mtd_info *mtd = drvdata->mtds[i];\r\nstruct nand_chip *chip;\r\nstruct txx9ndfmc_priv *txx9_priv;\r\nif (!mtd)\r\ncontinue;\r\nchip = mtd_to_nand(mtd);\r\ntxx9_priv = nand_get_controller_data(chip);\r\nnand_release(mtd);\r\nkfree(txx9_priv->mtdname);\r\nkfree(txx9_priv);\r\n}\r\nreturn 0;\r\n}\r\nstatic int txx9ndfmc_resume(struct platform_device *dev)\r\n{\r\nif (platform_get_drvdata(dev))\r\ntxx9ndfmc_initialize(dev);\r\nreturn 0;\r\n}
