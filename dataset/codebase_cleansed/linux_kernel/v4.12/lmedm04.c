static int lme2510_bulk_write(struct usb_device *dev,\r\nu8 *snd, int len, u8 pipe)\r\n{\r\nint actual_l;\r\nreturn usb_bulk_msg(dev, usb_sndbulkpipe(dev, pipe),\r\nsnd, len, &actual_l, 100);\r\n}\r\nstatic int lme2510_bulk_read(struct usb_device *dev,\r\nu8 *rev, int len, u8 pipe)\r\n{\r\nint actual_l;\r\nreturn usb_bulk_msg(dev, usb_rcvbulkpipe(dev, pipe),\r\nrev, len, &actual_l, 200);\r\n}\r\nstatic int lme2510_usb_talk(struct dvb_usb_device *d,\r\nu8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nu8 *buff;\r\nint ret = 0;\r\nif (st->usb_buffer == NULL) {\r\nst->usb_buffer = kmalloc(64, GFP_KERNEL);\r\nif (st->usb_buffer == NULL) {\r\ninfo("MEM Error no memory");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nbuff = st->usb_buffer;\r\nret = mutex_lock_interruptible(&d->usb_mutex);\r\nif (ret < 0)\r\nreturn -EAGAIN;\r\nmemcpy(buff, wbuf, (wlen < 64) ? wlen : 64);\r\nret |= lme2510_bulk_write(d->udev, buff, wlen , 0x01);\r\nret |= lme2510_bulk_read(d->udev, buff, (rlen < 64) ?\r\nrlen : 64 , 0x01);\r\nif (rlen > 0)\r\nmemcpy(rbuf, buff, rlen);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int lme2510_stream_restart(struct dvb_usb_device *d)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nu8 all_pids[] = LME_ALL_PIDS;\r\nu8 stream_on[] = LME_ST_ON_W;\r\nint ret;\r\nu8 rbuff[1];\r\nif (st->pid_off)\r\nret = lme2510_usb_talk(d, all_pids, sizeof(all_pids),\r\nrbuff, sizeof(rbuff));\r\nret = lme2510_usb_talk(d, stream_on, sizeof(stream_on),\r\nrbuff, sizeof(rbuff));\r\nreturn ret;\r\n}\r\nstatic int lme2510_enable_pid(struct dvb_usb_device *d, u8 index, u16 pid_out)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstatic u8 pid_buff[] = LME_ZERO_PID;\r\nstatic u8 rbuf[1];\r\nu8 pid_no = index * 2;\r\nu8 pid_len = pid_no + 2;\r\nint ret = 0;\r\ndeb_info(1, "PID Setting Pid %04x", pid_out);\r\nif (st->pid_size == 0)\r\nret |= lme2510_stream_restart(d);\r\npid_buff[2] = pid_no;\r\npid_buff[3] = (u8)pid_out & 0xff;\r\npid_buff[4] = pid_no + 1;\r\npid_buff[5] = (u8)(pid_out >> 8);\r\nif (pid_len > st->pid_size)\r\nst->pid_size = pid_len;\r\npid_buff[7] = 0x80 + st->pid_size;\r\nret |= lme2510_usb_talk(d, pid_buff ,\r\nsizeof(pid_buff) , rbuf, sizeof(rbuf));\r\nif (st->stream_on)\r\nret |= lme2510_stream_restart(d);\r\nreturn ret;\r\n}\r\nstatic void lme2510_update_stats(struct dvb_usb_adapter *adap)\r\n{\r\nstruct lme2510_state *st = adap_to_priv(adap);\r\nstruct dvb_frontend *fe = adap->fe[0];\r\nstruct dtv_frontend_properties *c;\r\nu32 s_tmp = 0, c_tmp = 0;\r\nif (!fe)\r\nreturn;\r\nc = &fe->dtv_property_cache;\r\nc->block_count.len = 1;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nif (st->i2c_talk_onoff) {\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn;\r\n}\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\ns_tmp = reg_to_16bits(0xff - st->signal_level);\r\nc_tmp = reg_to_16bits(0xff - st->signal_sn);\r\nbreak;\r\ncase TUNER_S7395:\r\ncase TUNER_S0194:\r\ns_tmp = 0xffff - (((st->signal_level * 2) << 8) * 5 / 4);\r\nc_tmp = reg_to_16bits((0xff - st->signal_sn - 0xa1) * 3);\r\nbreak;\r\ncase TUNER_RS2000:\r\ns_tmp = reg_to_16bits(st->signal_level);\r\nc_tmp = reg_to_16bits(st->signal_sn);\r\n}\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->strength.stat[0].uvalue = (u64)s_tmp;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_RELATIVE;\r\nc->cnr.stat[0].uvalue = (u64)c_tmp;\r\n}\r\nstatic void lme2510_int_response(struct urb *lme_urb)\r\n{\r\nstruct dvb_usb_adapter *adap = lme_urb->context;\r\nstruct lme2510_state *st = adap_to_priv(adap);\r\nu8 *ibuf, *rbuf;\r\nint i = 0, offset;\r\nu32 key;\r\nu8 signal_lock = 0;\r\nswitch (lme_urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ninfo("Error %x", lme_urb->status);\r\nbreak;\r\n}\r\nrbuf = (u8 *) lme_urb->transfer_buffer;\r\noffset = ((lme_urb->actual_length/8) > 4)\r\n? 4 : (lme_urb->actual_length/8) ;\r\nfor (i = 0; i < offset; ++i) {\r\nibuf = (u8 *)&rbuf[i*8];\r\ndeb_info(5, "INT O/S C =%02x C/O=%02x Type =%02x%02x",\r\noffset, i, ibuf[0], ibuf[1]);\r\nswitch (ibuf[0]) {\r\ncase 0xaa:\r\ndebug_data_snipet(1, "INT Remote data snipet", ibuf);\r\nif (!adap_to_d(adap)->rc_dev)\r\nbreak;\r\nkey = RC_SCANCODE_NEC32(ibuf[2] << 24 |\r\nibuf[3] << 16 |\r\nibuf[4] << 8 |\r\nibuf[5]);\r\ndeb_info(1, "INT Key = 0x%08x", key);\r\nrc_keydown(adap_to_d(adap)->rc_dev, RC_TYPE_NEC32, key,\r\n0);\r\nbreak;\r\ncase 0xbb:\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\nsignal_lock = ibuf[2] & BIT(5);\r\nst->signal_level = ibuf[4];\r\nst->signal_sn = ibuf[3];\r\nst->time_key = ibuf[7];\r\nbreak;\r\ncase TUNER_S7395:\r\ncase TUNER_S0194:\r\nif (ibuf[1] == 0x03) {\r\nsignal_lock = ibuf[2] & BIT(4);\r\nst->signal_level = ibuf[3];\r\nst->signal_sn = ibuf[4];\r\n} else {\r\nst->signal_level = ibuf[4];\r\nst->signal_sn = ibuf[5];\r\n}\r\nbreak;\r\ncase TUNER_RS2000:\r\nsignal_lock = ibuf[2] & 0xee;\r\nst->signal_level = ibuf[5];\r\nst->signal_sn = ibuf[4];\r\nst->time_key = ibuf[7];\r\ndefault:\r\nbreak;\r\n}\r\nsignal_lock |= ibuf[2] & BIT(0);\r\nif (!signal_lock)\r\nst->lock_status &= ~FE_HAS_LOCK;\r\nlme2510_update_stats(adap);\r\ndebug_data_snipet(5, "INT Remote data snipet in", ibuf);\r\nbreak;\r\ncase 0xcc:\r\ndebug_data_snipet(1, "INT Control data snipet", ibuf);\r\nbreak;\r\ndefault:\r\ndebug_data_snipet(1, "INT Unknown data snipet", ibuf);\r\nbreak;\r\n}\r\n}\r\nusb_submit_urb(lme_urb, GFP_ATOMIC);\r\nst->int_urb_due = jiffies + msecs_to_jiffies(200);\r\n}\r\nstatic int lme2510_int_read(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct lme2510_state *lme_int = adap_to_priv(adap);\r\nstruct usb_host_endpoint *ep;\r\nlme_int->lme_urb = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (lme_int->lme_urb == NULL)\r\nreturn -ENOMEM;\r\nlme_int->buffer = usb_alloc_coherent(d->udev, 128, GFP_ATOMIC,\r\n&lme_int->lme_urb->transfer_dma);\r\nif (lme_int->buffer == NULL)\r\nreturn -ENOMEM;\r\nusb_fill_int_urb(lme_int->lme_urb,\r\nd->udev,\r\nusb_rcvintpipe(d->udev, 0xa),\r\nlme_int->buffer,\r\n128,\r\nlme2510_int_response,\r\nadap,\r\n8);\r\nep = usb_pipe_endpoint(d->udev, lme_int->lme_urb->pipe);\r\nif (usb_endpoint_type(&ep->desc) == USB_ENDPOINT_XFER_BULK)\r\nlme_int->lme_urb->pipe = usb_rcvbulkpipe(d->udev, 0xa),\r\nlme_int->lme_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\r\nusb_submit_urb(lme_int->lme_urb, GFP_ATOMIC);\r\ninfo("INT Interrupt Service Started");\r\nreturn 0;\r\n}\r\nstatic int lme2510_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct lme2510_state *st = adap_to_priv(adap);\r\nstatic u8 clear_pid_reg[] = LME_ALL_PIDS;\r\nstatic u8 rbuf[1];\r\nint ret = 0;\r\ndeb_info(1, "PID Clearing Filter");\r\nmutex_lock(&d->i2c_mutex);\r\nif (!onoff) {\r\nret |= lme2510_usb_talk(d, clear_pid_reg,\r\nsizeof(clear_pid_reg), rbuf, sizeof(rbuf));\r\nst->pid_off = true;\r\n} else\r\nst->pid_off = false;\r\nst->pid_size = 0;\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn 0;\r\n}\r\nstatic int lme2510_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\ndeb_info(3, "%s PID=%04x Index=%04x onoff=%02x", __func__,\r\npid, index, onoff);\r\nif (onoff) {\r\nmutex_lock(&d->i2c_mutex);\r\nret |= lme2510_enable_pid(d, index, pid);\r\nmutex_unlock(&d->i2c_mutex);\r\n}\r\nreturn ret;\r\n}\r\nstatic int lme2510_return_status(struct dvb_usb_device *d)\r\n{\r\nint ret = 0;\r\nu8 *data;\r\ndata = kzalloc(10, GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nret |= usb_control_msg(d->udev, usb_rcvctrlpipe(d->udev, 0),\r\n0x06, 0x80, 0x0302, 0x00, data, 0x0006, 200);\r\ninfo("Firmware Status: %x (%x)", ret , data[2]);\r\nret = (ret < 0) ? -ENODEV : data[2];\r\nkfree(data);\r\nreturn ret;\r\n}\r\nstatic int lme2510_msg(struct dvb_usb_device *d,\r\nu8 *wbuf, int wlen, u8 *rbuf, int rlen)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nst->i2c_talk_onoff = 1;\r\nreturn lme2510_usb_talk(d, wbuf, wlen, rbuf, rlen);\r\n}\r\nstatic int lme2510_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct lme2510_state *st = d->priv;\r\nstatic u8 obuf[64], ibuf[64];\r\nint i, read, read_o;\r\nu16 len;\r\nu8 gate = st->i2c_gate;\r\nmutex_lock(&d->i2c_mutex);\r\nif (gate == 0)\r\ngate = 5;\r\nfor (i = 0; i < num; i++) {\r\nread_o = msg[i].flags & I2C_M_RD;\r\nread = i + 1 < num && msg[i + 1].flags & I2C_M_RD;\r\nread |= read_o;\r\ngate = (msg[i].addr == st->i2c_tuner_addr)\r\n? (read) ? st->i2c_tuner_gate_r\r\n: st->i2c_tuner_gate_w\r\n: st->i2c_gate;\r\nobuf[0] = gate | (read << 7);\r\nif (gate == 5)\r\nobuf[1] = (read) ? 2 : msg[i].len + 1;\r\nelse\r\nobuf[1] = msg[i].len + read + 1;\r\nobuf[2] = msg[i].addr << 1;\r\nif (read) {\r\nif (read_o)\r\nlen = 3;\r\nelse {\r\nmemcpy(&obuf[3], msg[i].buf, msg[i].len);\r\nobuf[msg[i].len+3] = msg[i+1].len;\r\nlen = msg[i].len+4;\r\n}\r\n} else {\r\nmemcpy(&obuf[3], msg[i].buf, msg[i].len);\r\nlen = msg[i].len+3;\r\n}\r\nif (lme2510_msg(d, obuf, len, ibuf, 64) < 0) {\r\ndeb_info(1, "i2c transfer failed.");\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn -EAGAIN;\r\n}\r\nif (read) {\r\nif (read_o)\r\nmemcpy(msg[i].buf, &ibuf[1], msg[i].len);\r\nelse {\r\nmemcpy(msg[i+1].buf, &ibuf[1], msg[i+1].len);\r\ni++;\r\n}\r\n}\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn i;\r\n}\r\nstatic u32 lme2510_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int lme2510_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_adapter *adap = fe_to_adap(fe);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct lme2510_state *st = adap_to_priv(adap);\r\nstatic u8 clear_reg_3[] = LME_ALL_PIDS;\r\nstatic u8 rbuf[1];\r\nint ret = 0, rlen = sizeof(rbuf);\r\ndeb_info(1, "STM (%02x)", onoff);\r\nif (onoff == 1)\r\nst->stream_on = 1;\r\nelse {\r\ndeb_info(1, "STM Steam Off");\r\nmutex_lock(&d->i2c_mutex);\r\nret = lme2510_usb_talk(d, clear_reg_3,\r\nsizeof(clear_reg_3), rbuf, rlen);\r\nst->stream_on = 0;\r\nst->i2c_talk_onoff = 1;\r\nmutex_unlock(&d->i2c_mutex);\r\n}\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic u8 check_sum(u8 *p, u8 len)\r\n{\r\nu8 sum = 0;\r\nwhile (len--)\r\nsum += *p++;\r\nreturn sum;\r\n}\r\nstatic int lme2510_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nint ret = 0;\r\nu8 *data;\r\nu16 j, wlen, len_in, start, end;\r\nu8 packet_size, dlen, i;\r\nu8 *fw_data;\r\npacket_size = 0x31;\r\nlen_in = 1;\r\ndata = kzalloc(128, GFP_KERNEL);\r\nif (!data) {\r\ninfo("FRM Could not start Firmware Download"\\r\n"(Buffer allocation failed)");\r\nreturn -ENOMEM;\r\n}\r\ninfo("FRM Starting Firmware Download");\r\nfor (i = 1; i < 3; i++) {\r\nstart = (i == 1) ? 0 : 512;\r\nend = (i == 1) ? 512 : fw->size;\r\nfor (j = start; j < end; j += (packet_size+1)) {\r\nfw_data = (u8 *)(fw->data + j);\r\nif ((end - j) > packet_size) {\r\ndata[0] = i;\r\ndlen = packet_size;\r\n} else {\r\ndata[0] = i | 0x80;\r\ndlen = (u8)(end - j)-1;\r\n}\r\ndata[1] = dlen;\r\nmemcpy(&data[2], fw_data, dlen+1);\r\nwlen = (u8) dlen + 4;\r\ndata[wlen-1] = check_sum(fw_data, dlen+1);\r\ndeb_info(1, "Data S=%02x:E=%02x CS= %02x", data[3],\r\ndata[dlen+2], data[dlen+3]);\r\nlme2510_usb_talk(d, data, wlen, data, len_in);\r\nret |= (data[0] == 0x88) ? 0 : -1;\r\n}\r\n}\r\ndata[0] = 0x8a;\r\nlen_in = 1;\r\nmsleep(2000);\r\nlme2510_usb_talk(d, data, len_in, data, len_in);\r\nmsleep(400);\r\nif (ret < 0)\r\ninfo("FRM Firmware Download Failed (%04x)" , ret);\r\nelse\r\ninfo("FRM Firmware Download Completed - Resetting Device");\r\nkfree(data);\r\nreturn RECONNECTS_USB;\r\n}\r\nstatic void lme_coldreset(struct dvb_usb_device *d)\r\n{\r\nu8 data[1] = {0};\r\ndata[0] = 0x0a;\r\ninfo("FRM Firmware Cold Reset");\r\nlme2510_usb_talk(d, data, sizeof(data), data, sizeof(data));\r\nreturn;\r\n}\r\nstatic const char *lme_firmware_switch(struct dvb_usb_device *d, int cold)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstruct usb_device *udev = d->udev;\r\nconst struct firmware *fw = NULL;\r\nconst char *fw_lme;\r\nint ret = 0;\r\ncold = (cold > 0) ? (cold & 1) : 0;\r\nswitch (le16_to_cpu(udev->descriptor.idProduct)) {\r\ncase 0x1122:\r\nswitch (st->dvb_usb_lme2510_firmware) {\r\ndefault:\r\ncase TUNER_S0194:\r\nfw_lme = fw_s0194;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\nst->dvb_usb_lme2510_firmware = TUNER_S0194;\r\ncold = 0;\r\nbreak;\r\n}\r\ncase TUNER_LG:\r\nfw_lme = fw_lg;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\nst->dvb_usb_lme2510_firmware = TUNER_LG;\r\nbreak;\r\n}\r\nst->dvb_usb_lme2510_firmware = TUNER_DEFAULT;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x1120:\r\nswitch (st->dvb_usb_lme2510_firmware) {\r\ndefault:\r\ncase TUNER_S7395:\r\nfw_lme = fw_c_s7395;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\nst->dvb_usb_lme2510_firmware = TUNER_S7395;\r\ncold = 0;\r\nbreak;\r\n}\r\ncase TUNER_LG:\r\nfw_lme = fw_c_lg;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\nst->dvb_usb_lme2510_firmware = TUNER_LG;\r\nbreak;\r\n}\r\ncase TUNER_S0194:\r\nfw_lme = fw_c_s0194;\r\nret = request_firmware(&fw, fw_lme, &udev->dev);\r\nif (ret == 0) {\r\nst->dvb_usb_lme2510_firmware = TUNER_S0194;\r\nbreak;\r\n}\r\nst->dvb_usb_lme2510_firmware = TUNER_DEFAULT;\r\ncold = 0;\r\nbreak;\r\n}\r\nbreak;\r\ncase 0x22f0:\r\nfw_lme = fw_c_rs2000;\r\nst->dvb_usb_lme2510_firmware = TUNER_RS2000;\r\nbreak;\r\ndefault:\r\nfw_lme = fw_c_s7395;\r\n}\r\nrelease_firmware(fw);\r\nif (cold) {\r\ndvb_usb_lme2510_firmware = st->dvb_usb_lme2510_firmware;\r\ninfo("FRM Changing to %s firmware", fw_lme);\r\nlme_coldreset(d);\r\nreturn NULL;\r\n}\r\nreturn fw_lme;\r\n}\r\nstatic int lme2510_kill_urb(struct usb_data_stream *stream)\r\n{\r\nint i;\r\nfor (i = 0; i < stream->urbs_submitted; i++) {\r\ndeb_info(3, "killing URB no. %d.", i);\r\nusb_kill_urb(stream->urb_list[i]);\r\n}\r\nstream->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nstatic int dm04_lme2510_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct lme2510_state *st = fe_to_priv(fe);\r\nstatic u8 voltage_low[] = LME_VOLTAGE_L;\r\nstatic u8 voltage_high[] = LME_VOLTAGE_H;\r\nstatic u8 rbuf[1];\r\nint ret = 0, len = 3, rlen = 1;\r\nmutex_lock(&d->i2c_mutex);\r\nswitch (voltage) {\r\ncase SEC_VOLTAGE_18:\r\nret |= lme2510_usb_talk(d,\r\nvoltage_high, len, rbuf, rlen);\r\nbreak;\r\ncase SEC_VOLTAGE_OFF:\r\ncase SEC_VOLTAGE_13:\r\ndefault:\r\nret |= lme2510_usb_talk(d,\r\nvoltage_low, len, rbuf, rlen);\r\nbreak;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nif (st->tuner_config == TUNER_RS2000)\r\nif (st->fe_set_voltage)\r\nst->fe_set_voltage(fe, voltage);\r\nreturn (ret < 0) ? -ENODEV : 0;\r\n}\r\nstatic int dm04_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct lme2510_state *st = d->priv;\r\nint ret = 0;\r\nif (st->i2c_talk_onoff) {\r\nif (st->fe_read_status) {\r\nret = st->fe_read_status(fe, status);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nst->lock_status = *status;\r\nif (*status & FE_HAS_LOCK && st->stream_on) {\r\nmutex_lock(&d->i2c_mutex);\r\nst->i2c_talk_onoff = 0;\r\nret = lme2510_stream_restart(d);\r\nmutex_unlock(&d->i2c_mutex);\r\n}\r\nreturn ret;\r\n}\r\nif (st->tuner_config == TUNER_RS2000 &&\r\ntime_after(jiffies, st->int_urb_due))\r\nst->lock_status &= ~FE_HAS_LOCK;\r\n*status = st->lock_status;\r\nif (!(*status & FE_HAS_LOCK)) {\r\nstruct dvb_usb_adapter *adap = fe_to_adap(fe);\r\nst->i2c_talk_onoff = 1;\r\nlme2510_update_stats(adap);\r\n}\r\nreturn ret;\r\n}\r\nstatic int dm04_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct lme2510_state *st = fe_to_priv(fe);\r\nif (st->fe_read_signal_strength && !st->stream_on)\r\nreturn st->fe_read_signal_strength(fe, strength);\r\nif (c->strength.stat[0].scale == FE_SCALE_RELATIVE)\r\n*strength = (u16)c->strength.stat[0].uvalue;\r\nelse\r\n*strength = 0;\r\nreturn 0;\r\n}\r\nstatic int dm04_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct lme2510_state *st = fe_to_priv(fe);\r\nif (st->fe_read_snr && !st->stream_on)\r\nreturn st->fe_read_snr(fe, snr);\r\nif (c->cnr.stat[0].scale == FE_SCALE_RELATIVE)\r\n*snr = (u16)c->cnr.stat[0].uvalue;\r\nelse\r\n*snr = 0;\r\nreturn 0;\r\n}\r\nstatic int dm04_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct lme2510_state *st = fe_to_priv(fe);\r\nif (st->fe_read_ber && !st->stream_on)\r\nreturn st->fe_read_ber(fe, ber);\r\n*ber = 0;\r\nreturn 0;\r\n}\r\nstatic int dm04_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct lme2510_state *st = fe_to_priv(fe);\r\nif (st->fe_read_ucblocks && !st->stream_on)\r\nreturn st->fe_read_ucblocks(fe, ucblocks);\r\n*ucblocks = 0;\r\nreturn 0;\r\n}\r\nstatic int lme_name(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct lme2510_state *st = adap_to_priv(adap);\r\nconst char *desc = d->name;\r\nstatic const char * const fe_name[] = {\r\n"", " LG TDQY-P001F", " SHARP:BS2F7HZ7395",\r\n" SHARP:BS2F7HZ0194", " RS2000"};\r\nchar *name = adap->fe[0]->ops.info.name;\r\nstrlcpy(name, desc, 128);\r\nstrlcat(name, fe_name[st->tuner_config], 128);\r\nreturn 0;\r\n}\r\nstatic int dm04_lme2510_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct lme2510_state *st = d->priv;\r\nint ret = 0;\r\nst->i2c_talk_onoff = 1;\r\nswitch (le16_to_cpu(d->udev->descriptor.idProduct)) {\r\ncase 0x1122:\r\ncase 0x1120:\r\nst->i2c_gate = 4;\r\nadap->fe[0] = dvb_attach(tda10086_attach,\r\n&tda10086_config, &d->i2c_adap);\r\nif (adap->fe[0]) {\r\ninfo("TUN Found Frontend TDA10086");\r\nst->i2c_tuner_gate_w = 4;\r\nst->i2c_tuner_gate_r = 4;\r\nst->i2c_tuner_addr = 0x60;\r\nst->tuner_config = TUNER_LG;\r\nif (st->dvb_usb_lme2510_firmware != TUNER_LG) {\r\nst->dvb_usb_lme2510_firmware = TUNER_LG;\r\nret = lme_firmware_switch(d, 1) ? 0 : -ENODEV;\r\n}\r\nbreak;\r\n}\r\nst->i2c_gate = 4;\r\nadap->fe[0] = dvb_attach(stv0299_attach,\r\n&sharp_z0194_config, &d->i2c_adap);\r\nif (adap->fe[0]) {\r\ninfo("FE Found Stv0299");\r\nst->i2c_tuner_gate_w = 4;\r\nst->i2c_tuner_gate_r = 5;\r\nst->i2c_tuner_addr = 0x60;\r\nst->tuner_config = TUNER_S0194;\r\nif (st->dvb_usb_lme2510_firmware != TUNER_S0194) {\r\nst->dvb_usb_lme2510_firmware = TUNER_S0194;\r\nret = lme_firmware_switch(d, 1) ? 0 : -ENODEV;\r\n}\r\nbreak;\r\n}\r\nst->i2c_gate = 5;\r\nadap->fe[0] = dvb_attach(stv0288_attach, &lme_config,\r\n&d->i2c_adap);\r\nif (adap->fe[0]) {\r\ninfo("FE Found Stv0288");\r\nst->i2c_tuner_gate_w = 4;\r\nst->i2c_tuner_gate_r = 5;\r\nst->i2c_tuner_addr = 0x60;\r\nst->tuner_config = TUNER_S7395;\r\nif (st->dvb_usb_lme2510_firmware != TUNER_S7395) {\r\nst->dvb_usb_lme2510_firmware = TUNER_S7395;\r\nret = lme_firmware_switch(d, 1) ? 0 : -ENODEV;\r\n}\r\nbreak;\r\n}\r\ncase 0x22f0:\r\nst->i2c_gate = 5;\r\nadap->fe[0] = dvb_attach(m88rs2000_attach,\r\n&m88rs2000_config, &d->i2c_adap);\r\nif (adap->fe[0]) {\r\ninfo("FE Found M88RS2000");\r\ndvb_attach(ts2020_attach, adap->fe[0], &ts2020_config,\r\n&d->i2c_adap);\r\nst->i2c_tuner_gate_w = 5;\r\nst->i2c_tuner_gate_r = 5;\r\nst->i2c_tuner_addr = 0x60;\r\nst->tuner_config = TUNER_RS2000;\r\nst->fe_set_voltage =\r\nadap->fe[0]->ops.set_voltage;\r\n}\r\nbreak;\r\n}\r\nif (adap->fe[0] == NULL) {\r\ninfo("DM04/QQBOX Not Powered up or not Supported");\r\nreturn -ENODEV;\r\n}\r\nif (ret) {\r\nif (adap->fe[0]) {\r\ndvb_frontend_detach(adap->fe[0]);\r\nadap->fe[0] = NULL;\r\n}\r\nd->rc_map = NULL;\r\nreturn -ENODEV;\r\n}\r\nst->fe_read_status = adap->fe[0]->ops.read_status;\r\nst->fe_read_signal_strength = adap->fe[0]->ops.read_signal_strength;\r\nst->fe_read_snr = adap->fe[0]->ops.read_snr;\r\nst->fe_read_ber = adap->fe[0]->ops.read_ber;\r\nst->fe_read_ucblocks = adap->fe[0]->ops.read_ucblocks;\r\nadap->fe[0]->ops.read_status = dm04_read_status;\r\nadap->fe[0]->ops.read_signal_strength = dm04_read_signal_strength;\r\nadap->fe[0]->ops.read_snr = dm04_read_snr;\r\nadap->fe[0]->ops.read_ber = dm04_read_ber;\r\nadap->fe[0]->ops.read_ucblocks = dm04_read_ucblocks;\r\nadap->fe[0]->ops.set_voltage = dm04_lme2510_set_voltage;\r\nret = lme_name(adap);\r\nreturn ret;\r\n}\r\nstatic int dm04_lme2510_tuner(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct lme2510_state *st = adap_to_priv(adap);\r\nstatic const char * const tun_msg[] = {"", "TDA8263", "IX2505V", "DVB_PLL_OPERA", "RS2000"};\r\nint ret = 0;\r\nswitch (st->tuner_config) {\r\ncase TUNER_LG:\r\nif (dvb_attach(tda826x_attach, adap->fe[0], 0x60,\r\n&d->i2c_adap, 1))\r\nret = st->tuner_config;\r\nbreak;\r\ncase TUNER_S7395:\r\nif (dvb_attach(ix2505v_attach , adap->fe[0], &lme_tuner,\r\n&d->i2c_adap))\r\nret = st->tuner_config;\r\nbreak;\r\ncase TUNER_S0194:\r\nif (dvb_attach(dvb_pll_attach , adap->fe[0], 0x60,\r\n&d->i2c_adap, DVB_PLL_OPERA1))\r\nret = st->tuner_config;\r\nbreak;\r\ncase TUNER_RS2000:\r\nret = st->tuner_config;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ret)\r\ninfo("TUN Found %s tuner", tun_msg[ret]);\r\nelse {\r\ninfo("TUN No tuner found --- resetting device");\r\nlme_coldreset(d);\r\nreturn -ENODEV;\r\n}\r\nret = lme2510_int_read(adap);\r\nif (ret < 0) {\r\ninfo("INT Unable to start Interrupt Service");\r\nreturn -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic int lme2510_powerup(struct dvb_usb_device *d, int onoff)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstatic u8 lnb_on[] = LNB_ON;\r\nstatic u8 lnb_off[] = LNB_OFF;\r\nstatic u8 rbuf[1];\r\nint ret = 0, len = 3, rlen = 1;\r\nmutex_lock(&d->i2c_mutex);\r\nret = lme2510_usb_talk(d, onoff ? lnb_on : lnb_off, len, rbuf, rlen);\r\nst->i2c_talk_onoff = 1;\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn ret;\r\n}\r\nstatic int lme2510_get_adapter_count(struct dvb_usb_device *d)\r\n{\r\nreturn 1;\r\n}\r\nstatic int lme2510_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nusb_reset_configuration(d->udev);\r\nusb_set_interface(d->udev,\r\nd->props->bInterfaceNumber, 1);\r\nst->dvb_usb_lme2510_firmware = dvb_usb_lme2510_firmware;\r\nif (lme2510_return_status(d) == 0x44) {\r\n*name = lme_firmware_switch(d, 0);\r\nreturn COLD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int lme2510_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\r\nstruct usb_data_stream_properties *stream)\r\n{\r\nstruct dvb_usb_adapter *adap = fe_to_adap(fe);\r\nstruct dvb_usb_device *d;\r\nif (adap == NULL)\r\nreturn 0;\r\nd = adap_to_d(adap);\r\nif (pid_filter == 2) {\r\nadap->pid_filtering = true;\r\nadap->max_feed_count = 15;\r\n}\r\nif (!(le16_to_cpu(d->udev->descriptor.idProduct)\r\n== 0x1122))\r\nstream->endpoint = 0x8;\r\nreturn 0;\r\n}\r\nstatic int lme2510_get_rc_config(struct dvb_usb_device *d,\r\nstruct dvb_usb_rc *rc)\r\n{\r\nrc->allowed_protos = RC_BIT_NEC32;\r\nreturn 0;\r\n}\r\nstatic void *lme2510_exit_int(struct dvb_usb_device *d)\r\n{\r\nstruct lme2510_state *st = d->priv;\r\nstruct dvb_usb_adapter *adap = &d->adapter[0];\r\nvoid *buffer = NULL;\r\nif (adap != NULL) {\r\nlme2510_kill_urb(&adap->stream);\r\n}\r\nif (st->usb_buffer != NULL) {\r\nst->i2c_talk_onoff = 1;\r\nst->signal_level = 0;\r\nst->signal_sn = 0;\r\nbuffer = st->usb_buffer;\r\n}\r\nif (st->lme_urb != NULL) {\r\nusb_kill_urb(st->lme_urb);\r\nusb_free_coherent(d->udev, 128, st->buffer,\r\nst->lme_urb->transfer_dma);\r\ninfo("Interrupt Service Stopped");\r\n}\r\nreturn buffer;\r\n}\r\nstatic void lme2510_exit(struct dvb_usb_device *d)\r\n{\r\nvoid *usb_buffer;\r\nif (d != NULL) {\r\nusb_buffer = lme2510_exit_int(d);\r\nkfree(usb_buffer);\r\n}\r\n}
