struct ab8500_fg *ab8500_fg_get(void)\r\n{\r\nreturn list_first_entry_or_null(&ab8500_fg_list, struct ab8500_fg,\r\nnode);\r\n}\r\nstatic u8 ab8500_volt_to_regval(int voltage)\r\n{\r\nint i;\r\nif (voltage < ab8500_fg_lowbat_voltage_map[0])\r\nreturn 0;\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_fg_lowbat_voltage_map); i++) {\r\nif (voltage < ab8500_fg_lowbat_voltage_map[i])\r\nreturn (u8) i - 1;\r\n}\r\nreturn (u8) ARRAY_SIZE(ab8500_fg_lowbat_voltage_map) - 1;\r\n}\r\nstatic int ab8500_fg_is_low_curr(struct ab8500_fg *di, int curr)\r\n{\r\nif (curr > -di->bm->fg_params->high_curr_threshold)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic int ab8500_fg_add_cap_sample(struct ab8500_fg *di, int sample)\r\n{\r\nstruct timespec64 ts64;\r\nstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\r\ngetnstimeofday64(&ts64);\r\ndo {\r\navg->sum += sample - avg->samples[avg->pos];\r\navg->samples[avg->pos] = sample;\r\navg->time_stamps[avg->pos] = ts64.tv_sec;\r\navg->pos++;\r\nif (avg->pos == NBR_AVG_SAMPLES)\r\navg->pos = 0;\r\nif (avg->nbr_samples < NBR_AVG_SAMPLES)\r\navg->nbr_samples++;\r\n} while (ts64.tv_sec - VALID_CAPACITY_SEC > avg->time_stamps[avg->pos]);\r\navg->avg = avg->sum / avg->nbr_samples;\r\nreturn avg->avg;\r\n}\r\nstatic void ab8500_fg_clear_cap_samples(struct ab8500_fg *di)\r\n{\r\nint i;\r\nstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\r\navg->pos = 0;\r\navg->nbr_samples = 0;\r\navg->sum = 0;\r\navg->avg = 0;\r\nfor (i = 0; i < NBR_AVG_SAMPLES; i++) {\r\navg->samples[i] = 0;\r\navg->time_stamps[i] = 0;\r\n}\r\n}\r\nstatic void ab8500_fg_fill_cap_sample(struct ab8500_fg *di, int sample)\r\n{\r\nint i;\r\nstruct timespec64 ts64;\r\nstruct ab8500_fg_avg_cap *avg = &di->avg_cap;\r\ngetnstimeofday64(&ts64);\r\nfor (i = 0; i < NBR_AVG_SAMPLES; i++) {\r\navg->samples[i] = sample;\r\navg->time_stamps[i] = ts64.tv_sec;\r\n}\r\navg->pos = 0;\r\navg->nbr_samples = NBR_AVG_SAMPLES;\r\navg->sum = sample * NBR_AVG_SAMPLES;\r\navg->avg = sample;\r\n}\r\nstatic int ab8500_fg_coulomb_counter(struct ab8500_fg *di, bool enable)\r\n{\r\nint ret = 0;\r\nmutex_lock(&di->cc_lock);\r\nif (enable) {\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, 0x00);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU,\r\ndi->fg_samples);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG,\r\n(CC_DEEP_SLEEP_ENA | CC_PWR_UP_ENA));\r\nif (ret)\r\ngoto cc_err;\r\ndi->flags.fg_enabled = true;\r\n} else {\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\n(RESET_ACCU | READ_REQ), 0);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU_CTRL, 0);\r\nif (ret)\r\ngoto cc_err;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, 0);\r\nif (ret)\r\ngoto cc_err;\r\ndi->flags.fg_enabled = false;\r\n}\r\ndev_dbg(di->dev, " CC enabled: %d Samples: %d\n",\r\nenable, di->fg_samples);\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\ncc_err:\r\ndev_err(di->dev, "%s Enabling coulomb counter failed\n", __func__);\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nint ab8500_fg_inst_curr_start(struct ab8500_fg *di)\r\n{\r\nu8 reg_val;\r\nint ret;\r\nmutex_lock(&di->cc_lock);\r\ndi->nbr_cceoc_irq_cnt = 0;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, &reg_val);\r\nif (ret < 0)\r\ngoto fail;\r\nif (!(reg_val & CC_PWR_UP_ENA)) {\r\ndev_dbg(di->dev, "%s Enable FG\n", __func__);\r\ndi->turn_off_fg = true;\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_NCOV_ACCU,\r\nSEC_TO_SAMPLE(10));\r\nif (ret)\r\ngoto fail;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG,\r\n(CC_DEEP_SLEEP_ENA | CC_PWR_UP_ENA));\r\nif (ret)\r\ngoto fail;\r\n} else {\r\ndi->turn_off_fg = false;\r\n}\r\nreinit_completion(&di->ab8500_fg_started);\r\nreinit_completion(&di->ab8500_fg_complete);\r\nenable_irq(di->irq);\r\nreturn 0;\r\nfail:\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nint ab8500_fg_inst_curr_started(struct ab8500_fg *di)\r\n{\r\nreturn completion_done(&di->ab8500_fg_started);\r\n}\r\nint ab8500_fg_inst_curr_done(struct ab8500_fg *di)\r\n{\r\nreturn completion_done(&di->ab8500_fg_complete);\r\n}\r\nint ab8500_fg_inst_curr_finalize(struct ab8500_fg *di, int *res)\r\n{\r\nu8 low, high;\r\nint val;\r\nint ret;\r\nunsigned long timeout;\r\nif (!completion_done(&di->ab8500_fg_complete)) {\r\ntimeout = wait_for_completion_timeout(\r\n&di->ab8500_fg_complete,\r\nINS_CURR_TIMEOUT);\r\ndev_dbg(di->dev, "Finalize time: %d ms\n",\r\njiffies_to_msecs(INS_CURR_TIMEOUT - timeout));\r\nif (!timeout) {\r\nret = -ETIME;\r\ndisable_irq(di->irq);\r\ndi->nbr_cceoc_irq_cnt = 0;\r\ndev_err(di->dev, "completion timed out [%d]\n",\r\n__LINE__);\r\ngoto fail;\r\n}\r\n}\r\ndisable_irq(di->irq);\r\ndi->nbr_cceoc_irq_cnt = 0;\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nREAD_REQ, READ_REQ);\r\nusleep_range(100, 100);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_SMPL_CNVL_REG, &low);\r\nif (ret < 0)\r\ngoto fail;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_SMPL_CNVH_REG, &high);\r\nif (ret < 0)\r\ngoto fail;\r\nif (high & 0x10)\r\nval = (low | (high << 8) | 0xFFFFE000);\r\nelse\r\nval = (low | (high << 8));\r\nval = (val * QLSB_NANO_AMP_HOURS_X10 * 36 * 4) /\r\n(1000 * di->bm->fg_res);\r\nif (di->turn_off_fg) {\r\ndev_dbg(di->dev, "%s Disable FG\n", __func__);\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG, 0);\r\nif (ret)\r\ngoto fail;\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8500_RTC_CC_CONF_REG, 0);\r\nif (ret)\r\ngoto fail;\r\n}\r\nmutex_unlock(&di->cc_lock);\r\n(*res) = val;\r\nreturn 0;\r\nfail:\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nint ab8500_fg_inst_curr_blocking(struct ab8500_fg *di)\r\n{\r\nint ret;\r\nunsigned long timeout;\r\nint res = 0;\r\nret = ab8500_fg_inst_curr_start(di);\r\nif (ret) {\r\ndev_err(di->dev, "Failed to initialize fg_inst\n");\r\nreturn 0;\r\n}\r\nif (!completion_done(&di->ab8500_fg_started)) {\r\ntimeout = wait_for_completion_timeout(\r\n&di->ab8500_fg_started,\r\nINS_CURR_TIMEOUT);\r\ndev_dbg(di->dev, "Start time: %d ms\n",\r\njiffies_to_msecs(INS_CURR_TIMEOUT - timeout));\r\nif (!timeout) {\r\nret = -ETIME;\r\ndev_err(di->dev, "completion timed out [%d]\n",\r\n__LINE__);\r\ngoto fail;\r\n}\r\n}\r\nret = ab8500_fg_inst_curr_finalize(di, &res);\r\nif (ret) {\r\ndev_err(di->dev, "Failed to finalize fg_inst\n");\r\nreturn 0;\r\n}\r\ndev_dbg(di->dev, "%s instant current: %d", __func__, res);\r\nreturn res;\r\nfail:\r\ndisable_irq(di->irq);\r\nmutex_unlock(&di->cc_lock);\r\nreturn ret;\r\n}\r\nstatic void ab8500_fg_acc_cur_work(struct work_struct *work)\r\n{\r\nint val;\r\nint ret;\r\nu8 low, med, high;\r\nstruct ab8500_fg *di = container_of(work,\r\nstruct ab8500_fg, fg_acc_cur_work);\r\nmutex_lock(&di->cc_lock);\r\nret = abx500_set_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_CTRL, RD_NCONV_ACCU_REQ);\r\nif (ret)\r\ngoto exit;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_LOW, &low);\r\nif (ret < 0)\r\ngoto exit;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_MED, &med);\r\nif (ret < 0)\r\ngoto exit;\r\nret = abx500_get_register_interruptible(di->dev, AB8500_GAS_GAUGE,\r\nAB8500_GASG_CC_NCOV_ACCU_HIGH, &high);\r\nif (ret < 0)\r\ngoto exit;\r\nif (high & 0x10)\r\nval = (low | (med << 8) | (high << 16) | 0xFFE00000);\r\nelse\r\nval = (low | (med << 8) | (high << 16));\r\ndi->accu_charge = (val * QLSB_NANO_AMP_HOURS_X10) /\r\n(100 * di->bm->fg_res);\r\ndi->avg_curr = (val * QLSB_NANO_AMP_HOURS_X10 * 36) /\r\n(1000 * di->bm->fg_res * (di->fg_samples / 4));\r\ndi->flags.conv_done = true;\r\nmutex_unlock(&di->cc_lock);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\ndev_dbg(di->dev, "fg_res: %d, fg_samples: %d, gasg: %d, accu_charge: %d \n",\r\ndi->bm->fg_res, di->fg_samples, val, di->accu_charge);\r\nreturn;\r\nexit:\r\ndev_err(di->dev,\r\n"Failed to read or write gas gauge registers\n");\r\nmutex_unlock(&di->cc_lock);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\n}\r\nstatic int ab8500_fg_bat_voltage(struct ab8500_fg *di)\r\n{\r\nint vbat;\r\nstatic int prev;\r\nvbat = ab8500_gpadc_convert(di->gpadc, MAIN_BAT_V);\r\nif (vbat < 0) {\r\ndev_err(di->dev,\r\n"%s gpadc conversion failed, using previous value\n",\r\n__func__);\r\nreturn prev;\r\n}\r\nprev = vbat;\r\nreturn vbat;\r\n}\r\nstatic int ab8500_fg_volt_to_capacity(struct ab8500_fg *di, int voltage)\r\n{\r\nint i, tbl_size;\r\nconst struct abx500_v_to_cap *tbl;\r\nint cap = 0;\r\ntbl = di->bm->bat_type[di->bm->batt_id].v_to_cap_tbl,\r\ntbl_size = di->bm->bat_type[di->bm->batt_id].n_v_cap_tbl_elements;\r\nfor (i = 0; i < tbl_size; ++i) {\r\nif (voltage > tbl[i].voltage)\r\nbreak;\r\n}\r\nif ((i > 0) && (i < tbl_size)) {\r\ncap = interpolate(voltage,\r\ntbl[i].voltage,\r\ntbl[i].capacity * 10,\r\ntbl[i-1].voltage,\r\ntbl[i-1].capacity * 10);\r\n} else if (i == 0) {\r\ncap = 1000;\r\n} else {\r\ncap = 0;\r\n}\r\ndev_dbg(di->dev, "%s Vbat: %d, Cap: %d per mille",\r\n__func__, voltage, cap);\r\nreturn cap;\r\n}\r\nstatic int ab8500_fg_uncomp_volt_to_capacity(struct ab8500_fg *di)\r\n{\r\ndi->vbat = ab8500_fg_bat_voltage(di);\r\nreturn ab8500_fg_volt_to_capacity(di, di->vbat);\r\n}\r\nstatic int ab8500_fg_battery_resistance(struct ab8500_fg *di)\r\n{\r\nint i, tbl_size;\r\nconst struct batres_vs_temp *tbl;\r\nint resist = 0;\r\ntbl = di->bm->bat_type[di->bm->batt_id].batres_tbl;\r\ntbl_size = di->bm->bat_type[di->bm->batt_id].n_batres_tbl_elements;\r\nfor (i = 0; i < tbl_size; ++i) {\r\nif (di->bat_temp / 10 > tbl[i].temp)\r\nbreak;\r\n}\r\nif ((i > 0) && (i < tbl_size)) {\r\nresist = interpolate(di->bat_temp / 10,\r\ntbl[i].temp,\r\ntbl[i].resist,\r\ntbl[i-1].temp,\r\ntbl[i-1].resist);\r\n} else if (i == 0) {\r\nresist = tbl[0].resist;\r\n} else {\r\nresist = tbl[tbl_size - 1].resist;\r\n}\r\ndev_dbg(di->dev, "%s Temp: %d battery internal resistance: %d"\r\n" fg resistance %d, total: %d (mOhm)\n",\r\n__func__, di->bat_temp, resist, di->bm->fg_res / 10,\r\n(di->bm->fg_res / 10) + resist);\r\nresist += di->bm->fg_res / 10;\r\nreturn resist;\r\n}\r\nstatic int ab8500_fg_load_comp_volt_to_capacity(struct ab8500_fg *di)\r\n{\r\nint vbat_comp, res;\r\nint i = 0;\r\nint vbat = 0;\r\nab8500_fg_inst_curr_start(di);\r\ndo {\r\nvbat += ab8500_fg_bat_voltage(di);\r\ni++;\r\nusleep_range(5000, 6000);\r\n} while (!ab8500_fg_inst_curr_done(di));\r\nab8500_fg_inst_curr_finalize(di, &di->inst_curr);\r\ndi->vbat = vbat / i;\r\nres = ab8500_fg_battery_resistance(di);\r\nvbat_comp = di->vbat - (di->inst_curr * res) / 1000;\r\ndev_dbg(di->dev, "%s Measured Vbat: %dmV,Compensated Vbat %dmV, "\r\n"R: %dmOhm, Current: %dmA Vbat Samples: %d\n",\r\n__func__, di->vbat, vbat_comp, res, di->inst_curr, i);\r\nreturn ab8500_fg_volt_to_capacity(di, vbat_comp);\r\n}\r\nstatic int ab8500_fg_convert_mah_to_permille(struct ab8500_fg *di, int cap_mah)\r\n{\r\nreturn (cap_mah * 1000) / di->bat_cap.max_mah_design;\r\n}\r\nstatic int ab8500_fg_convert_permille_to_mah(struct ab8500_fg *di, int cap_pm)\r\n{\r\nreturn cap_pm * di->bat_cap.max_mah_design / 1000;\r\n}\r\nstatic int ab8500_fg_convert_mah_to_uwh(struct ab8500_fg *di, int cap_mah)\r\n{\r\nu64 div_res;\r\nu32 div_rem;\r\ndiv_res = ((u64) cap_mah) * ((u64) di->vbat_nom);\r\ndiv_rem = do_div(div_res, 1000);\r\nif (div_rem >= 1000 / 2)\r\ndiv_res++;\r\nreturn (int) div_res;\r\n}\r\nstatic int ab8500_fg_calc_cap_charging(struct ab8500_fg *di)\r\n{\r\ndev_dbg(di->dev, "%s cap_mah %d accu_charge %d\n",\r\n__func__,\r\ndi->bat_cap.mah,\r\ndi->accu_charge);\r\nif (di->bat_cap.mah + di->accu_charge > 0)\r\ndi->bat_cap.mah += di->accu_charge;\r\nelse\r\ndi->bat_cap.mah = 0;\r\nif (di->bat_cap.mah >= di->bat_cap.max_mah_design ||\r\ndi->flags.force_full) {\r\ndi->bat_cap.mah = di->bat_cap.max_mah_design;\r\n}\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\r\ndi->bat_cap.permille =\r\nab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\ndi->vbat = ab8500_fg_bat_voltage(di);\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nreturn di->bat_cap.mah;\r\n}\r\nstatic int ab8500_fg_calc_cap_discharge_voltage(struct ab8500_fg *di, bool comp)\r\n{\r\nint permille, mah;\r\nif (comp)\r\npermille = ab8500_fg_load_comp_volt_to_capacity(di);\r\nelse\r\npermille = ab8500_fg_uncomp_volt_to_capacity(di);\r\nmah = ab8500_fg_convert_permille_to_mah(di, permille);\r\ndi->bat_cap.mah = ab8500_fg_add_cap_sample(di, mah);\r\ndi->bat_cap.permille =\r\nab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\nreturn di->bat_cap.mah;\r\n}\r\nstatic int ab8500_fg_calc_cap_discharge_fg(struct ab8500_fg *di)\r\n{\r\nint permille_volt, permille;\r\ndev_dbg(di->dev, "%s cap_mah %d accu_charge %d\n",\r\n__func__,\r\ndi->bat_cap.mah,\r\ndi->accu_charge);\r\nif (di->bat_cap.mah + di->accu_charge > 0)\r\ndi->bat_cap.mah += di->accu_charge;\r\nelse\r\ndi->bat_cap.mah = 0;\r\nif (di->bat_cap.mah >= di->bat_cap.max_mah_design)\r\ndi->bat_cap.mah = di->bat_cap.max_mah_design;\r\npermille = ab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\npermille_volt = ab8500_fg_uncomp_volt_to_capacity(di);\r\nif (permille < permille_volt) {\r\ndi->bat_cap.permille = permille_volt;\r\ndi->bat_cap.mah = ab8500_fg_convert_permille_to_mah(di,\r\ndi->bat_cap.permille);\r\ndev_dbg(di->dev, "%s voltage based: perm %d perm_volt %d\n",\r\n__func__,\r\npermille,\r\npermille_volt);\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\r\n} else {\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.mah);\r\ndi->bat_cap.permille =\r\nab8500_fg_convert_mah_to_permille(di, di->bat_cap.mah);\r\n}\r\nreturn di->bat_cap.mah;\r\n}\r\nstatic int ab8500_fg_capacity_level(struct ab8500_fg *di)\r\n{\r\nint ret, percent;\r\npercent = DIV_ROUND_CLOSEST(di->bat_cap.permille, 10);\r\nif (percent <= di->bm->cap_levels->critical ||\r\ndi->flags.low_bat)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;\r\nelse if (percent <= di->bm->cap_levels->low)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_LOW;\r\nelse if (percent <= di->bm->cap_levels->normal)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;\r\nelse if (percent <= di->bm->cap_levels->high)\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_HIGH;\r\nelse\r\nret = POWER_SUPPLY_CAPACITY_LEVEL_FULL;\r\nreturn ret;\r\n}\r\nstatic int ab8500_fg_calculate_scaled_capacity(struct ab8500_fg *di)\r\n{\r\nstruct ab8500_fg_cap_scaling *cs = &di->bat_cap.cap_scale;\r\nint capacity = di->bat_cap.prev_percent;\r\nif (!cs->enable)\r\nreturn capacity;\r\nif (di->flags.fully_charged) {\r\ncs->cap_to_scale[0] = 100;\r\ncs->cap_to_scale[1] =\r\nmax(capacity, di->bm->fg_params->maint_thres);\r\ndev_dbg(di->dev, "Scale cap with %d/%d\n",\r\ncs->cap_to_scale[0], cs->cap_to_scale[1]);\r\n}\r\nif ((cs->cap_to_scale[0] != cs->cap_to_scale[1])\r\n&& (cs->cap_to_scale[1] > 0))\r\ncapacity = min(100,\r\nDIV_ROUND_CLOSEST(di->bat_cap.prev_percent *\r\ncs->cap_to_scale[0],\r\ncs->cap_to_scale[1]));\r\nif (di->flags.charging) {\r\nif (capacity < cs->disable_cap_level) {\r\ncs->disable_cap_level = capacity;\r\ndev_dbg(di->dev, "Cap to stop scale lowered %d%%\n",\r\ncs->disable_cap_level);\r\n} else if (!di->flags.fully_charged) {\r\nif (di->bat_cap.prev_percent >=\r\ncs->disable_cap_level) {\r\ndev_dbg(di->dev, "Disabling scaled capacity\n");\r\ncs->enable = false;\r\ncapacity = di->bat_cap.prev_percent;\r\n} else {\r\ndev_dbg(di->dev,\r\n"Waiting in cap to level %d%%\n",\r\ncs->disable_cap_level);\r\ncapacity = cs->disable_cap_level;\r\n}\r\n}\r\n}\r\nreturn capacity;\r\n}\r\nstatic void ab8500_fg_update_cap_scalers(struct ab8500_fg *di)\r\n{\r\nstruct ab8500_fg_cap_scaling *cs = &di->bat_cap.cap_scale;\r\nif (!cs->enable)\r\nreturn;\r\nif (di->flags.charging) {\r\ndi->bat_cap.cap_scale.disable_cap_level =\r\ndi->bat_cap.cap_scale.scaled_cap;\r\ndev_dbg(di->dev, "Cap to stop scale at charge %d%%\n",\r\ndi->bat_cap.cap_scale.disable_cap_level);\r\n} else {\r\nif (cs->scaled_cap != 100) {\r\ncs->cap_to_scale[0] = cs->scaled_cap;\r\ncs->cap_to_scale[1] = di->bat_cap.prev_percent;\r\n} else {\r\ncs->cap_to_scale[0] = 100;\r\ncs->cap_to_scale[1] =\r\nmax(di->bat_cap.prev_percent,\r\ndi->bm->fg_params->maint_thres);\r\n}\r\ndev_dbg(di->dev, "Cap to scale at discharge %d/%d\n",\r\ncs->cap_to_scale[0], cs->cap_to_scale[1]);\r\n}\r\n}\r\nstatic void ab8500_fg_check_capacity_limits(struct ab8500_fg *di, bool init)\r\n{\r\nbool changed = false;\r\nint percent = DIV_ROUND_CLOSEST(di->bat_cap.permille, 10);\r\ndi->bat_cap.level = ab8500_fg_capacity_level(di);\r\nif (di->bat_cap.level != di->bat_cap.prev_level) {\r\nif (!(!di->flags.charging && di->bat_cap.level >\r\ndi->bat_cap.prev_level) || init) {\r\ndev_dbg(di->dev, "level changed from %d to %d\n",\r\ndi->bat_cap.prev_level,\r\ndi->bat_cap.level);\r\ndi->bat_cap.prev_level = di->bat_cap.level;\r\nchanged = true;\r\n} else {\r\ndev_dbg(di->dev, "level not allowed to go up "\r\n"since no charger is connected: %d to %d\n",\r\ndi->bat_cap.prev_level,\r\ndi->bat_cap.level);\r\n}\r\n}\r\nif (di->flags.low_bat) {\r\ndev_dbg(di->dev, "Battery low, set capacity to 0\n");\r\ndi->bat_cap.prev_percent = 0;\r\ndi->bat_cap.permille = 0;\r\npercent = 0;\r\ndi->bat_cap.prev_mah = 0;\r\ndi->bat_cap.mah = 0;\r\nchanged = true;\r\n} else if (di->flags.fully_charged) {\r\nif (di->flags.force_full) {\r\ndi->bat_cap.prev_percent = percent;\r\ndi->bat_cap.prev_mah = di->bat_cap.mah;\r\nchanged = true;\r\nif (!di->bat_cap.cap_scale.enable &&\r\ndi->bm->capacity_scaling) {\r\ndi->bat_cap.cap_scale.enable = true;\r\ndi->bat_cap.cap_scale.cap_to_scale[0] = 100;\r\ndi->bat_cap.cap_scale.cap_to_scale[1] =\r\ndi->bat_cap.prev_percent;\r\ndi->bat_cap.cap_scale.disable_cap_level = 100;\r\n}\r\n} else if (di->bat_cap.prev_percent != percent) {\r\ndev_dbg(di->dev,\r\n"battery reported full "\r\n"but capacity dropping: %d\n",\r\npercent);\r\ndi->bat_cap.prev_percent = percent;\r\ndi->bat_cap.prev_mah = di->bat_cap.mah;\r\nchanged = true;\r\n}\r\n} else if (di->bat_cap.prev_percent != percent) {\r\nif (percent == 0) {\r\ndi->bat_cap.prev_percent = 1;\r\npercent = 1;\r\nchanged = true;\r\n} else if (!(!di->flags.charging &&\r\npercent > di->bat_cap.prev_percent) || init) {\r\ndev_dbg(di->dev,\r\n"capacity changed from %d to %d (%d)\n",\r\ndi->bat_cap.prev_percent,\r\npercent,\r\ndi->bat_cap.permille);\r\ndi->bat_cap.prev_percent = percent;\r\ndi->bat_cap.prev_mah = di->bat_cap.mah;\r\nchanged = true;\r\n} else {\r\ndev_dbg(di->dev, "capacity not allowed to go up since "\r\n"no charger is connected: %d to %d (%d)\n",\r\ndi->bat_cap.prev_percent,\r\npercent,\r\ndi->bat_cap.permille);\r\n}\r\n}\r\nif (changed) {\r\nif (di->bm->capacity_scaling) {\r\ndi->bat_cap.cap_scale.scaled_cap =\r\nab8500_fg_calculate_scaled_capacity(di);\r\ndev_info(di->dev, "capacity=%d (%d)\n",\r\ndi->bat_cap.prev_percent,\r\ndi->bat_cap.cap_scale.scaled_cap);\r\n}\r\npower_supply_changed(di->fg_psy);\r\nif (di->flags.fully_charged && di->flags.force_full) {\r\ndev_dbg(di->dev, "Battery full, notifying.\n");\r\ndi->flags.force_full = false;\r\nsysfs_notify(&di->fg_kobject, NULL, "charge_full");\r\n}\r\nsysfs_notify(&di->fg_kobject, NULL, "charge_now");\r\n}\r\n}\r\nstatic void ab8500_fg_charge_state_to(struct ab8500_fg *di,\r\nenum ab8500_fg_charge_state new_state)\r\n{\r\ndev_dbg(di->dev, "Charge state from %d [%s] to %d [%s]\n",\r\ndi->charge_state,\r\ncharge_state[di->charge_state],\r\nnew_state,\r\ncharge_state[new_state]);\r\ndi->charge_state = new_state;\r\n}\r\nstatic void ab8500_fg_discharge_state_to(struct ab8500_fg *di,\r\nenum ab8500_fg_discharge_state new_state)\r\n{\r\ndev_dbg(di->dev, "Disharge state from %d [%s] to %d [%s]\n",\r\ndi->discharge_state,\r\ndischarge_state[di->discharge_state],\r\nnew_state,\r\ndischarge_state[new_state]);\r\ndi->discharge_state = new_state;\r\n}\r\nstatic void ab8500_fg_algorithm_charging(struct ab8500_fg *di)\r\n{\r\nif (di->discharge_state != AB8500_FG_DISCHARGE_INIT_RECOVERY)\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_INIT_RECOVERY);\r\nswitch (di->charge_state) {\r\ncase AB8500_FG_CHARGE_INIT:\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bm->fg_params->accu_charging);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_READOUT);\r\nbreak;\r\ncase AB8500_FG_CHARGE_READOUT:\r\nmutex_lock(&di->cc_lock);\r\nif (!di->flags.conv_done && !di->flags.force_full) {\r\nmutex_unlock(&di->cc_lock);\r\ndev_dbg(di->dev, "%s CC conv not done\n",\r\n__func__);\r\nbreak;\r\n}\r\ndi->flags.conv_done = false;\r\nmutex_unlock(&di->cc_lock);\r\nab8500_fg_calc_cap_charging(di);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nab8500_fg_check_capacity_limits(di, false);\r\n}\r\nstatic void force_capacity(struct ab8500_fg *di)\r\n{\r\nint cap;\r\nab8500_fg_clear_cap_samples(di);\r\ncap = di->bat_cap.user_mah;\r\nif (cap > di->bat_cap.max_mah_design) {\r\ndev_dbg(di->dev, "Remaining cap %d can't be bigger than total"\r\n" %d\n", cap, di->bat_cap.max_mah_design);\r\ncap = di->bat_cap.max_mah_design;\r\n}\r\nab8500_fg_fill_cap_sample(di, di->bat_cap.user_mah);\r\ndi->bat_cap.permille = ab8500_fg_convert_mah_to_permille(di, cap);\r\ndi->bat_cap.mah = cap;\r\nab8500_fg_check_capacity_limits(di, true);\r\n}\r\nstatic bool check_sysfs_capacity(struct ab8500_fg *di)\r\n{\r\nint cap, lower, upper;\r\nint cap_permille;\r\ncap = di->bat_cap.user_mah;\r\ncap_permille = ab8500_fg_convert_mah_to_permille(di,\r\ndi->bat_cap.user_mah);\r\nlower = di->bat_cap.permille - di->bm->fg_params->user_cap_limit * 10;\r\nupper = di->bat_cap.permille + di->bm->fg_params->user_cap_limit * 10;\r\nif (lower < 0)\r\nlower = 0;\r\nif (upper > 1000)\r\nupper = 1000;\r\ndev_dbg(di->dev, "Capacity limits:"\r\n" (Lower: %d User: %d Upper: %d) [user: %d, was: %d]\n",\r\nlower, cap_permille, upper, cap, di->bat_cap.mah);\r\nif (cap_permille > lower && cap_permille < upper) {\r\ndev_dbg(di->dev, "OK! Using users cap %d uAh now\n", cap);\r\nforce_capacity(di);\r\nreturn true;\r\n}\r\ndev_dbg(di->dev, "Capacity from user out of limits, ignoring");\r\nreturn false;\r\n}\r\nstatic void ab8500_fg_algorithm_discharging(struct ab8500_fg *di)\r\n{\r\nint sleep_time;\r\nif (di->charge_state != AB8500_FG_CHARGE_INIT)\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\r\nswitch (di->discharge_state) {\r\ncase AB8500_FG_DISCHARGE_INIT:\r\ndi->init_cnt = 0;\r\ndi->fg_samples = SEC_TO_SAMPLE(di->bm->fg_params->init_timer);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_INITMEASURING);\r\ncase AB8500_FG_DISCHARGE_INITMEASURING:\r\nsleep_time = di->bm->fg_params->init_timer;\r\nif (di->init_cnt > di->bm->fg_params->init_discard_time) {\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\nab8500_fg_check_capacity_limits(di, true);\r\n}\r\ndi->init_cnt += sleep_time;\r\nif (di->init_cnt > di->bm->fg_params->init_total_time)\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT_INIT);\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_INIT_RECOVERY:\r\ndi->recovery_cnt = 0;\r\ndi->recovery_needed = true;\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_RECOVERY);\r\ncase AB8500_FG_DISCHARGE_RECOVERY:\r\nsleep_time = di->bm->fg_params->recovery_sleep_timer;\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nif (ab8500_fg_is_low_curr(di, di->inst_curr)) {\r\nif (di->recovery_cnt >\r\ndi->bm->fg_params->recovery_total_time) {\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bm->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\ndi->recovery_needed = false;\r\n} else {\r\nqueue_delayed_work(di->fg_wq,\r\n&di->fg_periodic_work,\r\nsleep_time * HZ);\r\n}\r\ndi->recovery_cnt += sleep_time;\r\n} else {\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bm->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\n}\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_READOUT_INIT:\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bm->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_READOUT:\r\ndi->inst_curr = ab8500_fg_inst_curr_blocking(di);\r\nif (ab8500_fg_is_low_curr(di, di->inst_curr)) {\r\nif (di->high_curr_mode) {\r\ndi->high_curr_mode = false;\r\ndi->high_curr_cnt = 0;\r\n}\r\nif (di->recovery_needed) {\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_INIT_RECOVERY);\r\nqueue_delayed_work(di->fg_wq,\r\n&di->fg_periodic_work, 0);\r\nbreak;\r\n}\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\n} else {\r\nmutex_lock(&di->cc_lock);\r\nif (!di->flags.conv_done) {\r\nmutex_unlock(&di->cc_lock);\r\ndev_dbg(di->dev, "%s CC conv not done\n",\r\n__func__);\r\nbreak;\r\n}\r\ndi->flags.conv_done = false;\r\nmutex_unlock(&di->cc_lock);\r\nif (!di->high_curr_mode) {\r\ndi->high_curr_mode = true;\r\ndi->high_curr_cnt = 0;\r\n}\r\ndi->high_curr_cnt +=\r\ndi->bm->fg_params->accu_high_curr;\r\nif (di->high_curr_cnt >\r\ndi->bm->fg_params->high_curr_time)\r\ndi->recovery_needed = true;\r\nab8500_fg_calc_cap_discharge_fg(di);\r\n}\r\nab8500_fg_check_capacity_limits(di, false);\r\nbreak;\r\ncase AB8500_FG_DISCHARGE_WAKEUP:\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\ndi->fg_samples = SEC_TO_SAMPLE(\r\ndi->bm->fg_params->accu_high_curr);\r\nab8500_fg_coulomb_counter(di, true);\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT);\r\nab8500_fg_check_capacity_limits(di, false);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void ab8500_fg_algorithm_calibrate(struct ab8500_fg *di)\r\n{\r\nint ret;\r\nswitch (di->calib_state) {\r\ncase AB8500_FG_CALIB_INIT:\r\ndev_dbg(di->dev, "Calibration ongoing...\n");\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nCC_INT_CAL_N_AVG_MASK, CC_INT_CAL_SAMPLES_8);\r\nif (ret < 0)\r\ngoto err;\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nCC_INTAVGOFFSET_ENA, CC_INTAVGOFFSET_ENA);\r\nif (ret < 0)\r\ngoto err;\r\ndi->calib_state = AB8500_FG_CALIB_WAIT;\r\nbreak;\r\ncase AB8500_FG_CALIB_END:\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_GAS_GAUGE, AB8500_GASG_CC_CTRL_REG,\r\nCC_MUXOFFSET, CC_MUXOFFSET);\r\nif (ret < 0)\r\ngoto err;\r\ndi->flags.calibrate = false;\r\ndev_dbg(di->dev, "Calibration done...\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\nbreak;\r\ncase AB8500_FG_CALIB_WAIT:\r\ndev_dbg(di->dev, "Calibration WFI\n");\r\ndefault:\r\nbreak;\r\n}\r\nreturn;\r\nerr:\r\ndev_err(di->dev, "failed to calibrate the CC\n");\r\ndi->flags.calibrate = false;\r\ndi->calib_state = AB8500_FG_CALIB_INIT;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n}\r\nstatic void ab8500_fg_algorithm(struct ab8500_fg *di)\r\n{\r\nif (di->flags.calibrate)\r\nab8500_fg_algorithm_calibrate(di);\r\nelse {\r\nif (di->flags.charging)\r\nab8500_fg_algorithm_charging(di);\r\nelse\r\nab8500_fg_algorithm_discharging(di);\r\n}\r\ndev_dbg(di->dev, "[FG_DATA] %d %d %d %d %d %d %d %d %d %d "\r\n"%d %d %d %d %d %d %d\n",\r\ndi->bat_cap.max_mah_design,\r\ndi->bat_cap.max_mah,\r\ndi->bat_cap.mah,\r\ndi->bat_cap.permille,\r\ndi->bat_cap.level,\r\ndi->bat_cap.prev_mah,\r\ndi->bat_cap.prev_percent,\r\ndi->bat_cap.prev_level,\r\ndi->vbat,\r\ndi->inst_curr,\r\ndi->avg_curr,\r\ndi->accu_charge,\r\ndi->flags.charging,\r\ndi->charge_state,\r\ndi->discharge_state,\r\ndi->high_curr_mode,\r\ndi->recovery_needed);\r\n}\r\nstatic void ab8500_fg_periodic_work(struct work_struct *work)\r\n{\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_periodic_work.work);\r\nif (di->init_capacity) {\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\nab8500_fg_check_capacity_limits(di, true);\r\ndi->init_capacity = false;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n} else if (di->flags.user_cap) {\r\nif (check_sysfs_capacity(di)) {\r\nab8500_fg_check_capacity_limits(di, true);\r\nif (di->flags.charging)\r\nab8500_fg_charge_state_to(di,\r\nAB8500_FG_CHARGE_INIT);\r\nelse\r\nab8500_fg_discharge_state_to(di,\r\nAB8500_FG_DISCHARGE_READOUT_INIT);\r\n}\r\ndi->flags.user_cap = false;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n} else\r\nab8500_fg_algorithm(di);\r\n}\r\nstatic void ab8500_fg_check_hw_failure_work(struct work_struct *work)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_check_hw_failure_work.work);\r\nret = abx500_get_register_interruptible(di->dev,\r\nAB8500_CHARGER, AB8500_CH_STAT_REG,\r\n&reg_value);\r\nif (ret < 0) {\r\ndev_err(di->dev, "%s ab8500 read failed\n", __func__);\r\nreturn;\r\n}\r\nif ((reg_value & BATT_OVV) == BATT_OVV) {\r\nif (!di->flags.bat_ovv) {\r\ndev_dbg(di->dev, "Battery OVV\n");\r\ndi->flags.bat_ovv = true;\r\npower_supply_changed(di->fg_psy);\r\n}\r\nqueue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work,\r\nHZ);\r\n} else {\r\ndev_dbg(di->dev, "Battery recovered from OVV\n");\r\ndi->flags.bat_ovv = false;\r\npower_supply_changed(di->fg_psy);\r\n}\r\n}\r\nstatic void ab8500_fg_low_bat_work(struct work_struct *work)\r\n{\r\nint vbat;\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_low_bat_work.work);\r\nvbat = ab8500_fg_bat_voltage(di);\r\nif (vbat < di->bm->fg_params->lowbat_threshold) {\r\nif (di->low_bat_cnt < 1) {\r\ndi->flags.low_bat = true;\r\ndev_warn(di->dev, "Shut down pending...\n");\r\n} else {\r\ndi->low_bat_cnt--;\r\ndev_warn(di->dev, "Battery voltage still LOW\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_low_bat_work,\r\nround_jiffies(LOW_BAT_CHECK_INTERVAL));\r\n}\r\n} else {\r\ndi->flags.low_bat_delay = false;\r\ndi->low_bat_cnt = 10;\r\ndev_warn(di->dev, "Battery voltage OK again\n");\r\n}\r\nab8500_fg_check_capacity_limits(di, false);\r\n}\r\nstatic int ab8500_fg_battok_calc(struct ab8500_fg *di, int target)\r\n{\r\nif (target > BATT_OK_MIN +\r\n(BATT_OK_INCREMENT * BATT_OK_MAX_NR_INCREMENTS))\r\nreturn BATT_OK_MAX_NR_INCREMENTS;\r\nif (target < BATT_OK_MIN)\r\nreturn 0;\r\nreturn (target - BATT_OK_MIN) / BATT_OK_INCREMENT;\r\n}\r\nstatic int ab8500_fg_battok_init_hw_register(struct ab8500_fg *di)\r\n{\r\nint selected;\r\nint sel0;\r\nint sel1;\r\nint cbp_sel0;\r\nint cbp_sel1;\r\nint ret;\r\nint new_val;\r\nsel0 = di->bm->fg_params->battok_falling_th_sel0;\r\nsel1 = di->bm->fg_params->battok_raising_th_sel1;\r\ncbp_sel0 = ab8500_fg_battok_calc(di, sel0);\r\ncbp_sel1 = ab8500_fg_battok_calc(di, sel1);\r\nselected = BATT_OK_MIN + cbp_sel0 * BATT_OK_INCREMENT;\r\nif (selected != sel0)\r\ndev_warn(di->dev, "Invalid voltage step:%d, using %d %d\n",\r\nsel0, selected, cbp_sel0);\r\nselected = BATT_OK_MIN + cbp_sel1 * BATT_OK_INCREMENT;\r\nif (selected != sel1)\r\ndev_warn(di->dev, "Invalid voltage step:%d, using %d %d\n",\r\nsel1, selected, cbp_sel1);\r\nnew_val = cbp_sel0 | (cbp_sel1 << 4);\r\ndev_dbg(di->dev, "using: %x %d %d\n", new_val, cbp_sel0, cbp_sel1);\r\nret = abx500_set_register_interruptible(di->dev, AB8500_SYS_CTRL2_BLOCK,\r\nAB8500_BATT_OK_REG, new_val);\r\nreturn ret;\r\n}\r\nstatic void ab8500_fg_instant_work(struct work_struct *work)\r\n{\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg, fg_work);\r\nab8500_fg_algorithm(di);\r\n}\r\nstatic irqreturn_t ab8500_fg_cc_data_end_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\nif (!di->nbr_cceoc_irq_cnt) {\r\ndi->nbr_cceoc_irq_cnt++;\r\ncomplete(&di->ab8500_fg_started);\r\n} else {\r\ndi->nbr_cceoc_irq_cnt = 0;\r\ncomplete(&di->ab8500_fg_complete);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_cc_int_calib_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\ndi->calib_state = AB8500_FG_CALIB_END;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_cc_convend_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\nqueue_work(di->fg_wq, &di->fg_acc_cur_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_batt_ovv_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\ndev_dbg(di->dev, "Battery OVV\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_check_hw_failure_work, 0);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t ab8500_fg_lowbatf_handler(int irq, void *_di)\r\n{\r\nstruct ab8500_fg *di = _di;\r\nif (!di->flags.low_bat_delay) {\r\ndev_warn(di->dev, "Battery voltage is below LOW threshold\n");\r\ndi->flags.low_bat_delay = true;\r\nqueue_delayed_work(di->fg_wq, &di->fg_low_bat_work,\r\nround_jiffies(LOW_BAT_CHECK_INTERVAL));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ab8500_fg_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (di->flags.bat_ovv)\r\nval->intval = BATT_OVV_VALUE * 1000;\r\nelse\r\nval->intval = di->vbat * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nval->intval = di->inst_curr * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_AVG:\r\nval->intval = di->avg_curr * 1000;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.max_mah_design);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_FULL:\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.max_mah);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ENERGY_NOW:\r\nif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.max_mah);\r\nelse\r\nval->intval = ab8500_fg_convert_mah_to_uwh(di,\r\ndi->bat_cap.prev_mah);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nval->intval = di->bat_cap.max_mah_design;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_FULL:\r\nval->intval = di->bat_cap.max_mah;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_NOW:\r\nif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = di->bat_cap.max_mah;\r\nelse\r\nval->intval = di->bat_cap.prev_mah;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY:\r\nif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = 100;\r\nelse\r\nval->intval = di->bat_cap.prev_percent;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nif (di->flags.batt_unknown && !di->bm->chg_unknown_bat &&\r\ndi->flags.batt_id_received)\r\nval->intval = POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;\r\nelse\r\nval->intval = di->bat_cap.prev_level;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_get_ext_psy_data(struct device *dev, void *data)\r\n{\r\nstruct power_supply *psy;\r\nstruct power_supply *ext = dev_get_drvdata(dev);\r\nconst char **supplicants = (const char **)ext->supplied_to;\r\nstruct ab8500_fg *di;\r\nunion power_supply_propval ret;\r\nint j;\r\npsy = (struct power_supply *)data;\r\ndi = power_supply_get_drvdata(psy);\r\nj = match_string(supplicants, ext->num_supplicants, psy->desc->name);\r\nif (j < 0)\r\nreturn 0;\r\nfor (j = 0; j < ext->desc->num_properties; j++) {\r\nenum power_supply_property prop;\r\nprop = ext->desc->properties[j];\r\nif (power_supply_get_property(ext, prop, &ret))\r\ncontinue;\r\nswitch (prop) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nswitch (ext->desc->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nswitch (ret.intval) {\r\ncase POWER_SUPPLY_STATUS_UNKNOWN:\r\ncase POWER_SUPPLY_STATUS_DISCHARGING:\r\ncase POWER_SUPPLY_STATUS_NOT_CHARGING:\r\nif (!di->flags.charging)\r\nbreak;\r\ndi->flags.charging = false;\r\ndi->flags.fully_charged = false;\r\nif (di->bm->capacity_scaling)\r\nab8500_fg_update_cap_scalers(di);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nbreak;\r\ncase POWER_SUPPLY_STATUS_FULL:\r\nif (di->flags.fully_charged)\r\nbreak;\r\ndi->flags.fully_charged = true;\r\ndi->flags.force_full = true;\r\ndi->bat_cap.max_mah = di->bat_cap.mah;\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nbreak;\r\ncase POWER_SUPPLY_STATUS_CHARGING:\r\nif (di->flags.charging &&\r\n!di->flags.fully_charged)\r\nbreak;\r\ndi->flags.charging = true;\r\ndi->flags.fully_charged = false;\r\nif (di->bm->capacity_scaling)\r\nab8500_fg_update_cap_scalers(di);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\nbreak;\r\n};\r\ndefault:\r\nbreak;\r\n};\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nswitch (ext->desc->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nif (!di->flags.batt_id_received &&\r\ndi->bm->batt_id != BATTERY_UNKNOWN) {\r\nconst struct abx500_battery_type *b;\r\nb = &(di->bm->bat_type[di->bm->batt_id]);\r\ndi->flags.batt_id_received = true;\r\ndi->bat_cap.max_mah_design =\r\nMILLI_TO_MICRO *\r\nb->charge_full_design;\r\ndi->bat_cap.max_mah =\r\ndi->bat_cap.max_mah_design;\r\ndi->vbat_nom = b->nominal_voltage;\r\n}\r\nif (ret.intval)\r\ndi->flags.batt_unknown = false;\r\nelse\r\ndi->flags.batt_unknown = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TEMP:\r\nswitch (ext->desc->type) {\r\ncase POWER_SUPPLY_TYPE_BATTERY:\r\nif (di->flags.batt_id_received)\r\ndi->bat_temp = ret.intval;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_init_hw_registers(struct ab8500_fg *di)\r\n{\r\nint ret;\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER,\r\nAB8500_BATT_OVV,\r\nBATT_OVV_TH_4P75,\r\nBATT_OVV_TH_4P75);\r\nif (ret) {\r\ndev_err(di->dev, "failed to set BATT_OVV\n");\r\ngoto out;\r\n}\r\nret = abx500_mask_and_set_register_interruptible(di->dev,\r\nAB8500_CHARGER,\r\nAB8500_BATT_OVV,\r\nBATT_OVV_ENA,\r\nBATT_OVV_ENA);\r\nif (ret) {\r\ndev_err(di->dev, "failed to enable BATT_OVV\n");\r\ngoto out;\r\n}\r\nret = abx500_set_register_interruptible(di->dev,\r\nAB8500_SYS_CTRL2_BLOCK,\r\nAB8500_LOW_BAT_REG,\r\nab8500_volt_to_regval(\r\ndi->bm->fg_params->lowbat_threshold) << 1 |\r\nLOW_BAT_ENABLE);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed\n", __func__);\r\ngoto out;\r\n}\r\nret = ab8500_fg_battok_init_hw_register(di);\r\nif (ret) {\r\ndev_err(di->dev, "BattOk init write failed.\n");\r\ngoto out;\r\n}\r\nif (((is_ab8505(di->parent) || is_ab9540(di->parent)) &&\r\nabx500_get_chip_id(di->dev) >= AB8500_CUT2P0)\r\n|| is_ab8540(di->parent)) {\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_MAX_TIME_REG, di->bm->fg_params->pcut_max_time);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed AB8505_RTC_PCUT_MAX_TIME_REG\n", __func__);\r\ngoto out;\r\n};\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_FLAG_TIME_REG, di->bm->fg_params->pcut_flag_time);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed AB8505_RTC_PCUT_FLAG_TIME_REG\n", __func__);\r\ngoto out;\r\n};\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_RESTART_REG, di->bm->fg_params->pcut_max_restart);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed AB8505_RTC_PCUT_RESTART_REG\n", __func__);\r\ngoto out;\r\n};\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_DEBOUNCE_REG, di->bm->fg_params->pcut_debounce_time);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed AB8505_RTC_PCUT_DEBOUNCE_REG\n", __func__);\r\ngoto out;\r\n};\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_CTL_STATUS_REG, di->bm->fg_params->pcut_enable);\r\nif (ret) {\r\ndev_err(di->dev, "%s write failed AB8505_RTC_PCUT_CTL_STATUS_REG\n", __func__);\r\ngoto out;\r\n};\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic void ab8500_fg_external_power_changed(struct power_supply *psy)\r\n{\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nclass_for_each_device(power_supply_class, NULL,\r\ndi->fg_psy, ab8500_fg_get_ext_psy_data);\r\n}\r\nstatic void ab8500_fg_reinit_work(struct work_struct *work)\r\n{\r\nstruct ab8500_fg *di = container_of(work, struct ab8500_fg,\r\nfg_reinit_work.work);\r\nif (di->flags.calibrate == false) {\r\ndev_dbg(di->dev, "Resetting FG state machine to init.\n");\r\nab8500_fg_clear_cap_samples(di);\r\nab8500_fg_calc_cap_discharge_voltage(di, true);\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\r\nab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n} else {\r\ndev_err(di->dev, "Residual offset calibration ongoing "\r\n"retrying..\n");\r\nqueue_delayed_work(di->fg_wq, &di->fg_reinit_work,\r\nround_jiffies(1));\r\n}\r\n}\r\nstatic ssize_t charge_full_show(struct ab8500_fg *di, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", di->bat_cap.max_mah);\r\n}\r\nstatic ssize_t charge_full_store(struct ab8500_fg *di, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long charge_full;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &charge_full);\r\ndev_dbg(di->dev, "Ret %zd charge_full %lu", ret, charge_full);\r\nif (!ret) {\r\ndi->bat_cap.max_mah = (int) charge_full;\r\nret = count;\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t charge_now_show(struct ab8500_fg *di, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", di->bat_cap.prev_mah);\r\n}\r\nstatic ssize_t charge_now_store(struct ab8500_fg *di, const char *buf,\r\nsize_t count)\r\n{\r\nunsigned long charge_now;\r\nssize_t ret;\r\nret = kstrtoul(buf, 10, &charge_now);\r\ndev_dbg(di->dev, "Ret %zd charge_now %lu was %d",\r\nret, charge_now, di->bat_cap.prev_mah);\r\nif (!ret) {\r\ndi->bat_cap.user_mah = (int) charge_now;\r\ndi->flags.user_cap = true;\r\nret = count;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t\r\nab8500_fg_show(struct kobject *kobj, struct attribute *attr, char *buf)\r\n{\r\nstruct ab8500_fg_sysfs_entry *entry;\r\nstruct ab8500_fg *di;\r\nentry = container_of(attr, struct ab8500_fg_sysfs_entry, attr);\r\ndi = container_of(kobj, struct ab8500_fg, fg_kobject);\r\nif (!entry->show)\r\nreturn -EIO;\r\nreturn entry->show(di, buf);\r\n}\r\nstatic ssize_t\r\nab8500_fg_store(struct kobject *kobj, struct attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct ab8500_fg_sysfs_entry *entry;\r\nstruct ab8500_fg *di;\r\nentry = container_of(attr, struct ab8500_fg_sysfs_entry, attr);\r\ndi = container_of(kobj, struct ab8500_fg, fg_kobject);\r\nif (!entry->store)\r\nreturn -EIO;\r\nreturn entry->store(di, buf, count);\r\n}\r\nstatic void ab8500_fg_sysfs_exit(struct ab8500_fg *di)\r\n{\r\nkobject_del(&di->fg_kobject);\r\n}\r\nstatic int ab8500_fg_sysfs_init(struct ab8500_fg *di)\r\n{\r\nint ret = 0;\r\nret = kobject_init_and_add(&di->fg_kobject,\r\n&ab8500_fg_ktype,\r\nNULL, "battery");\r\nif (ret < 0)\r\ndev_err(di->dev, "failed to create sysfs entry\n");\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_flagtime_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_FLAG_TIME_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_FLAG_TIME_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0x7F));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_flagtime_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nlong unsigned reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nreg_value = simple_strtoul(buf, NULL, 10);\r\nif (reg_value > 0x7F) {\r\ndev_err(dev, "Incorrect parameter, echo 0 (1.98s) - 127 (15.625ms) for flagtime\n");\r\ngoto fail;\r\n}\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_FLAG_TIME_REG, (u8)reg_value);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to set AB8505_RTC_PCUT_FLAG_TIME_REG\n");\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t ab8505_powercut_maxtime_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_MAX_TIME_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_MAX_TIME_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0x7F));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_maxtime_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nint reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nreg_value = simple_strtoul(buf, NULL, 10);\r\nif (reg_value > 0x7F) {\r\ndev_err(dev, "Incorrect parameter, echo 0 (0.0s) - 127 (1.98s) for maxtime\n");\r\ngoto fail;\r\n}\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_MAX_TIME_REG, (u8)reg_value);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to set AB8505_RTC_PCUT_MAX_TIME_REG\n");\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t ab8505_powercut_restart_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_RESTART_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_RESTART_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0xF));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_restart_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nint reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nreg_value = simple_strtoul(buf, NULL, 10);\r\nif (reg_value > 0xF) {\r\ndev_err(dev, "Incorrect parameter, echo 0 - 15 for number of restart\n");\r\ngoto fail;\r\n}\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_RESTART_REG, (u8)reg_value);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to set AB8505_RTC_PCUT_RESTART_REG\n");\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t ab8505_powercut_timer_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_TIME_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_TIME_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0x7F));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_restart_counter_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_RESTART_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_RESTART_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0xF0) >> 4);\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_CTL_STATUS_REG, &reg_value);\r\nif (ret < 0)\r\ngoto fail;\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0x1));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nint reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nreg_value = simple_strtoul(buf, NULL, 10);\r\nif (reg_value > 0x1) {\r\ndev_err(dev, "Incorrect parameter, echo 0/1 to disable/enable Pcut feature\n");\r\ngoto fail;\r\n}\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_CTL_STATUS_REG, (u8)reg_value);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to set AB8505_RTC_PCUT_CTL_STATUS_REG\n");\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t ab8505_powercut_flag_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_CTL_STATUS_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_CTL_STATUS_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", ((reg_value & 0x10) >> 4));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_debounce_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_DEBOUNCE_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_DEBOUNCE_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", (reg_value & 0x7));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic ssize_t ab8505_powercut_debounce_write(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nint reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nreg_value = simple_strtoul(buf, NULL, 10);\r\nif (reg_value > 0x7) {\r\ndev_err(dev, "Incorrect parameter, echo 0 to 7 for debounce setting\n");\r\ngoto fail;\r\n}\r\nret = abx500_set_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_DEBOUNCE_REG, (u8)reg_value);\r\nif (ret < 0)\r\ndev_err(dev, "Failed to set AB8505_RTC_PCUT_DEBOUNCE_REG\n");\r\nfail:\r\nreturn count;\r\n}\r\nstatic ssize_t ab8505_powercut_enable_status_read(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint ret;\r\nu8 reg_value;\r\nstruct power_supply *psy = dev_get_drvdata(dev);\r\nstruct ab8500_fg *di = power_supply_get_drvdata(psy);\r\nret = abx500_get_register_interruptible(di->dev, AB8500_RTC,\r\nAB8505_RTC_PCUT_CTL_STATUS_REG, &reg_value);\r\nif (ret < 0) {\r\ndev_err(dev, "Failed to read AB8505_RTC_PCUT_CTL_STATUS_REG\n");\r\ngoto fail;\r\n}\r\nreturn scnprintf(buf, PAGE_SIZE, "%d\n", ((reg_value & 0x20) >> 5));\r\nfail:\r\nreturn ret;\r\n}\r\nstatic int ab8500_fg_sysfs_psy_create_attrs(struct ab8500_fg *di)\r\n{\r\nunsigned int i;\r\nif (((is_ab8505(di->parent) || is_ab9540(di->parent)) &&\r\nabx500_get_chip_id(di->dev) >= AB8500_CUT2P0)\r\n|| is_ab8540(di->parent)) {\r\nfor (i = 0; i < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); i++)\r\nif (device_create_file(&di->fg_psy->dev,\r\n&ab8505_fg_sysfs_psy_attrs[i]))\r\ngoto sysfs_psy_create_attrs_failed_ab8505;\r\n}\r\nreturn 0;\r\nsysfs_psy_create_attrs_failed_ab8505:\r\ndev_err(&di->fg_psy->dev, "Failed creating sysfs psy attrs for ab8505.\n");\r\nwhile (i--)\r\ndevice_remove_file(&di->fg_psy->dev,\r\n&ab8505_fg_sysfs_psy_attrs[i]);\r\nreturn -EIO;\r\n}\r\nstatic void ab8500_fg_sysfs_psy_remove_attrs(struct ab8500_fg *di)\r\n{\r\nunsigned int i;\r\nif (((is_ab8505(di->parent) || is_ab9540(di->parent)) &&\r\nabx500_get_chip_id(di->dev) >= AB8500_CUT2P0)\r\n|| is_ab8540(di->parent)) {\r\nfor (i = 0; i < ARRAY_SIZE(ab8505_fg_sysfs_psy_attrs); i++)\r\n(void)device_remove_file(&di->fg_psy->dev,\r\n&ab8505_fg_sysfs_psy_attrs[i]);\r\n}\r\n}\r\nstatic int ab8500_fg_resume(struct platform_device *pdev)\r\n{\r\nstruct ab8500_fg *di = platform_get_drvdata(pdev);\r\nif (!di->flags.charging) {\r\nab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_WAKEUP);\r\nqueue_work(di->fg_wq, &di->fg_work);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct ab8500_fg *di = platform_get_drvdata(pdev);\r\nflush_delayed_work(&di->fg_periodic_work);\r\nflush_work(&di->fg_work);\r\nflush_work(&di->fg_acc_cur_work);\r\nflush_delayed_work(&di->fg_reinit_work);\r\nflush_delayed_work(&di->fg_low_bat_work);\r\nflush_delayed_work(&di->fg_check_hw_failure_work);\r\nif (di->flags.fg_enabled && !di->flags.charging)\r\nab8500_fg_coulomb_counter(di, false);\r\nreturn 0;\r\n}\r\nstatic int ab8500_fg_remove(struct platform_device *pdev)\r\n{\r\nint ret = 0;\r\nstruct ab8500_fg *di = platform_get_drvdata(pdev);\r\nlist_del(&di->node);\r\nret = ab8500_fg_coulomb_counter(di, false);\r\nif (ret)\r\ndev_err(di->dev, "failed to disable coulomb counter\n");\r\ndestroy_workqueue(di->fg_wq);\r\nab8500_fg_sysfs_exit(di);\r\nflush_scheduled_work();\r\nab8500_fg_sysfs_psy_remove_attrs(di);\r\npower_supply_unregister(di->fg_psy);\r\nreturn ret;\r\n}\r\nstatic int ab8500_fg_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct abx500_bm_data *plat = pdev->dev.platform_data;\r\nstruct power_supply_config psy_cfg = {};\r\nstruct ab8500_fg *di;\r\nint i, irq;\r\nint ret = 0;\r\ndi = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);\r\nif (!di) {\r\ndev_err(&pdev->dev, "%s no mem for ab8500_fg\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nif (!plat) {\r\ndev_err(&pdev->dev, "no battery management data supplied\n");\r\nreturn -EINVAL;\r\n}\r\ndi->bm = plat;\r\nif (np) {\r\nret = ab8500_bm_of_probe(&pdev->dev, np, di->bm);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get battery information\n");\r\nreturn ret;\r\n}\r\n}\r\nmutex_init(&di->cc_lock);\r\ndi->dev = &pdev->dev;\r\ndi->parent = dev_get_drvdata(pdev->dev.parent);\r\ndi->gpadc = ab8500_gpadc_get("ab8500-gpadc.0");\r\npsy_cfg.supplied_to = supply_interface;\r\npsy_cfg.num_supplicants = ARRAY_SIZE(supply_interface);\r\npsy_cfg.drv_data = di;\r\ndi->bat_cap.max_mah_design = MILLI_TO_MICRO *\r\ndi->bm->bat_type[di->bm->batt_id].charge_full_design;\r\ndi->bat_cap.max_mah = di->bat_cap.max_mah_design;\r\ndi->vbat_nom = di->bm->bat_type[di->bm->batt_id].nominal_voltage;\r\ndi->init_capacity = true;\r\nab8500_fg_charge_state_to(di, AB8500_FG_CHARGE_INIT);\r\nab8500_fg_discharge_state_to(di, AB8500_FG_DISCHARGE_INIT);\r\ndi->fg_wq = alloc_ordered_workqueue("ab8500_fg_wq", WQ_MEM_RECLAIM);\r\nif (di->fg_wq == NULL) {\r\ndev_err(di->dev, "failed to create work queue\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_WORK(&di->fg_work, ab8500_fg_instant_work);\r\nINIT_WORK(&di->fg_acc_cur_work, ab8500_fg_acc_cur_work);\r\nINIT_DEFERRABLE_WORK(&di->fg_reinit_work,\r\nab8500_fg_reinit_work);\r\nINIT_DEFERRABLE_WORK(&di->fg_periodic_work,\r\nab8500_fg_periodic_work);\r\nINIT_DEFERRABLE_WORK(&di->fg_low_bat_work,\r\nab8500_fg_low_bat_work);\r\nINIT_DEFERRABLE_WORK(&di->fg_check_hw_failure_work,\r\nab8500_fg_check_hw_failure_work);\r\ndi->flags.low_bat = false;\r\ndi->low_bat_cnt = 10;\r\nret = ab8500_fg_init_hw_registers(di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to initialize registers\n");\r\ngoto free_inst_curr_wq;\r\n}\r\ndi->flags.batt_unknown = true;\r\ndi->flags.batt_id_received = false;\r\ndi->fg_psy = power_supply_register(di->dev, &ab8500_fg_desc, &psy_cfg);\r\nif (IS_ERR(di->fg_psy)) {\r\ndev_err(di->dev, "failed to register FG psy\n");\r\nret = PTR_ERR(di->fg_psy);\r\ngoto free_inst_curr_wq;\r\n}\r\ndi->fg_samples = SEC_TO_SAMPLE(di->bm->fg_params->init_timer);\r\nab8500_fg_coulomb_counter(di, true);\r\ninit_completion(&di->ab8500_fg_started);\r\ninit_completion(&di->ab8500_fg_complete);\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_fg_irq_th); i++) {\r\nirq = platform_get_irq_byname(pdev, ab8500_fg_irq_th[i].name);\r\nret = request_irq(irq, ab8500_fg_irq_th[i].isr,\r\nIRQF_SHARED | IRQF_NO_SUSPEND,\r\nab8500_fg_irq_th[i].name, di);\r\nif (ret != 0) {\r\ndev_err(di->dev, "failed to request %s IRQ %d: %d\n",\r\nab8500_fg_irq_th[i].name, irq, ret);\r\ngoto free_irq;\r\n}\r\ndev_dbg(di->dev, "Requested %s IRQ %d: %d\n",\r\nab8500_fg_irq_th[i].name, irq, ret);\r\n}\r\nirq = platform_get_irq_byname(pdev, ab8500_fg_irq_bh[0].name);\r\nret = request_threaded_irq(irq, NULL, ab8500_fg_irq_bh[0].isr,\r\nIRQF_SHARED | IRQF_NO_SUSPEND | IRQF_ONESHOT,\r\nab8500_fg_irq_bh[0].name, di);\r\nif (ret != 0) {\r\ndev_err(di->dev, "failed to request %s IRQ %d: %d\n",\r\nab8500_fg_irq_bh[0].name, irq, ret);\r\ngoto free_irq;\r\n}\r\ndev_dbg(di->dev, "Requested %s IRQ %d: %d\n",\r\nab8500_fg_irq_bh[0].name, irq, ret);\r\ndi->irq = platform_get_irq_byname(pdev, "CCEOC");\r\ndisable_irq(di->irq);\r\ndi->nbr_cceoc_irq_cnt = 0;\r\nplatform_set_drvdata(pdev, di);\r\nret = ab8500_fg_sysfs_init(di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to create sysfs entry\n");\r\ngoto free_irq;\r\n}\r\nret = ab8500_fg_sysfs_psy_create_attrs(di);\r\nif (ret) {\r\ndev_err(di->dev, "failed to create FG psy\n");\r\nab8500_fg_sysfs_exit(di);\r\ngoto free_irq;\r\n}\r\ndi->flags.calibrate = true;\r\ndi->calib_state = AB8500_FG_CALIB_INIT;\r\ndi->bat_temp = 210;\r\nqueue_delayed_work(di->fg_wq, &di->fg_periodic_work, 0);\r\nlist_add_tail(&di->node, &ab8500_fg_list);\r\nreturn ret;\r\nfree_irq:\r\npower_supply_unregister(di->fg_psy);\r\nfor (i = 0; i < ARRAY_SIZE(ab8500_fg_irq_th); i++) {\r\nirq = platform_get_irq_byname(pdev, ab8500_fg_irq_th[i].name);\r\nfree_irq(irq, di);\r\n}\r\nirq = platform_get_irq_byname(pdev, ab8500_fg_irq_bh[0].name);\r\nfree_irq(irq, di);\r\nfree_inst_curr_wq:\r\ndestroy_workqueue(di->fg_wq);\r\nreturn ret;\r\n}\r\nstatic int __init ab8500_fg_init(void)\r\n{\r\nreturn platform_driver_register(&ab8500_fg_driver);\r\n}\r\nstatic void __exit ab8500_fg_exit(void)\r\n{\r\nplatform_driver_unregister(&ab8500_fg_driver);\r\n}
