static void efm32_spi_write32(struct efm32_spi_ddata *ddata,\r\nu32 value, unsigned offset)\r\n{\r\nwritel_relaxed(value, ddata->base + offset);\r\n}\r\nstatic u32 efm32_spi_read32(struct efm32_spi_ddata *ddata, unsigned offset)\r\n{\r\nreturn readl_relaxed(ddata->base + offset);\r\n}\r\nstatic void efm32_spi_chipselect(struct spi_device *spi, int is_on)\r\n{\r\nstruct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);\r\nint value = !(spi->mode & SPI_CS_HIGH) == !(is_on == BITBANG_CS_ACTIVE);\r\ngpio_set_value(ddata->csgpio[spi->chip_select], value);\r\n}\r\nstatic int efm32_spi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);\r\nunsigned bpw = t->bits_per_word ?: spi->bits_per_word;\r\nunsigned speed = t->speed_hz ?: spi->max_speed_hz;\r\nunsigned long clkfreq = clk_get_rate(ddata->clk);\r\nu32 clkdiv;\r\nefm32_spi_write32(ddata, REG_CTRL_SYNC | REG_CTRL_MSBF |\r\n(spi->mode & SPI_CPHA ? REG_CTRL_CLKPHA : 0) |\r\n(spi->mode & SPI_CPOL ? REG_CTRL_CLKPOL : 0), REG_CTRL);\r\nefm32_spi_write32(ddata,\r\nREG_FRAME_DATABITS(bpw), REG_FRAME);\r\nif (2 * speed >= clkfreq)\r\nclkdiv = 0;\r\nelse\r\nclkdiv = 64 * (DIV_ROUND_UP(2 * clkfreq, speed) - 4);\r\nif (clkdiv > (1U << 21))\r\nreturn -EINVAL;\r\nefm32_spi_write32(ddata, clkdiv, REG_CLKDIV);\r\nefm32_spi_write32(ddata, REG_CMD_MASTEREN, REG_CMD);\r\nefm32_spi_write32(ddata, REG_CMD_RXEN | REG_CMD_TXEN, REG_CMD);\r\nreturn 0;\r\n}\r\nstatic void efm32_spi_tx_u8(struct efm32_spi_ddata *ddata)\r\n{\r\nu8 val = 0;\r\nif (ddata->tx_buf) {\r\nval = *ddata->tx_buf;\r\nddata->tx_buf++;\r\n}\r\nddata->tx_len--;\r\nefm32_spi_write32(ddata, val, REG_TXDATA);\r\nefm32_spi_vdbg(ddata, "%s: tx 0x%x\n", __func__, val);\r\n}\r\nstatic void efm32_spi_rx_u8(struct efm32_spi_ddata *ddata)\r\n{\r\nu32 rxdata = efm32_spi_read32(ddata, REG_RXDATAX);\r\nefm32_spi_vdbg(ddata, "%s: rx 0x%x\n", __func__, rxdata);\r\nif (ddata->rx_buf) {\r\n*ddata->rx_buf = rxdata;\r\nddata->rx_buf++;\r\n}\r\nddata->rx_len--;\r\n}\r\nstatic void efm32_spi_filltx(struct efm32_spi_ddata *ddata)\r\n{\r\nwhile (ddata->tx_len &&\r\nddata->tx_len + 2 > ddata->rx_len &&\r\nefm32_spi_read32(ddata, REG_STATUS) & REG_STATUS_TXBL) {\r\nefm32_spi_tx_u8(ddata);\r\n}\r\n}\r\nstatic int efm32_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct efm32_spi_ddata *ddata = spi_master_get_devdata(spi->master);\r\nint ret = -EBUSY;\r\nspin_lock_irq(&ddata->lock);\r\nif (ddata->tx_buf || ddata->rx_buf)\r\ngoto out_unlock;\r\nddata->tx_buf = t->tx_buf;\r\nddata->rx_buf = t->rx_buf;\r\nddata->tx_len = ddata->rx_len =\r\nt->len * DIV_ROUND_UP(t->bits_per_word, 8);\r\nefm32_spi_filltx(ddata);\r\nreinit_completion(&ddata->done);\r\nefm32_spi_write32(ddata, REG_IF_TXBL | REG_IF_RXDATAV, REG_IEN);\r\nspin_unlock_irq(&ddata->lock);\r\nwait_for_completion(&ddata->done);\r\nspin_lock_irq(&ddata->lock);\r\nret = t->len - max(ddata->tx_len, ddata->rx_len);\r\nefm32_spi_write32(ddata, 0, REG_IEN);\r\nddata->tx_buf = ddata->rx_buf = NULL;\r\nout_unlock:\r\nspin_unlock_irq(&ddata->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t efm32_spi_rxirq(int irq, void *data)\r\n{\r\nstruct efm32_spi_ddata *ddata = data;\r\nirqreturn_t ret = IRQ_NONE;\r\nspin_lock(&ddata->lock);\r\nwhile (ddata->rx_len > 0 &&\r\nefm32_spi_read32(ddata, REG_STATUS) &\r\nREG_STATUS_RXDATAV) {\r\nefm32_spi_rx_u8(ddata);\r\nret = IRQ_HANDLED;\r\n}\r\nif (!ddata->rx_len) {\r\nu32 ien = efm32_spi_read32(ddata, REG_IEN);\r\nien &= ~REG_IF_RXDATAV;\r\nefm32_spi_write32(ddata, ien, REG_IEN);\r\ncomplete(&ddata->done);\r\n}\r\nspin_unlock(&ddata->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t efm32_spi_txirq(int irq, void *data)\r\n{\r\nstruct efm32_spi_ddata *ddata = data;\r\nefm32_spi_vdbg(ddata,\r\n"%s: txlen = %u, rxlen = %u, if=0x%08x, stat=0x%08x\n",\r\n__func__, ddata->tx_len, ddata->rx_len,\r\nefm32_spi_read32(ddata, REG_IF),\r\nefm32_spi_read32(ddata, REG_STATUS));\r\nspin_lock(&ddata->lock);\r\nefm32_spi_filltx(ddata);\r\nefm32_spi_vdbg(ddata, "%s: txlen = %u, rxlen = %u\n",\r\n__func__, ddata->tx_len, ddata->rx_len);\r\nif (!ddata->tx_len) {\r\nu32 ien = efm32_spi_read32(ddata, REG_IEN);\r\nien &= ~REG_IF_TXBL;\r\nefm32_spi_write32(ddata, ien, REG_IEN);\r\nefm32_spi_vdbg(ddata, "disable TXBL\n");\r\n}\r\nspin_unlock(&ddata->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic u32 efm32_spi_get_configured_location(struct efm32_spi_ddata *ddata)\r\n{\r\nu32 reg = efm32_spi_read32(ddata, REG_ROUTE);\r\nreturn (reg & REG_ROUTE_LOCATION__MASK) >> __ffs(REG_ROUTE_LOCATION__MASK);\r\n}\r\nstatic void efm32_spi_probe_dt(struct platform_device *pdev,\r\nstruct spi_master *master, struct efm32_spi_ddata *ddata)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 location;\r\nint ret;\r\nret = of_property_read_u32(np, "energymicro,location", &location);\r\nif (ret)\r\nret = of_property_read_u32(np, "efm32,location", &location);\r\nif (ret)\r\nret = of_property_read_u32(np, "location", &location);\r\nif (!ret) {\r\ndev_dbg(&pdev->dev, "using location %u\n", location);\r\n} else {\r\nlocation = efm32_spi_get_configured_location(ddata);\r\ndev_info(&pdev->dev, "fall back to location %u\n", location);\r\n}\r\nddata->pdata.location = location;\r\n}\r\nstatic int efm32_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct efm32_spi_ddata *ddata;\r\nstruct resource *res;\r\nint ret;\r\nstruct spi_master *master;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint num_cs, i;\r\nif (!np)\r\nreturn -EINVAL;\r\nnum_cs = of_gpio_named_count(np, "cs-gpios");\r\nif (num_cs < 0)\r\nreturn num_cs;\r\nmaster = spi_alloc_master(&pdev->dev,\r\nsizeof(*ddata) + num_cs * sizeof(unsigned));\r\nif (!master) {\r\ndev_dbg(&pdev->dev,\r\n"failed to allocate spi master controller\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->num_chipselect = num_cs;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\r\nddata = spi_master_get_devdata(master);\r\nddata->bitbang.master = master;\r\nddata->bitbang.chipselect = efm32_spi_chipselect;\r\nddata->bitbang.setup_transfer = efm32_spi_setup_transfer;\r\nddata->bitbang.txrx_bufs = efm32_spi_txrx_bufs;\r\nspin_lock_init(&ddata->lock);\r\ninit_completion(&ddata->done);\r\nddata->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(ddata->clk)) {\r\nret = PTR_ERR(ddata->clk);\r\ndev_err(&pdev->dev, "failed to get clock: %d\n", ret);\r\ngoto err;\r\n}\r\nfor (i = 0; i < num_cs; ++i) {\r\nret = of_get_named_gpio(np, "cs-gpios", i);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to get csgpio#%u (%d)\n",\r\ni, ret);\r\ngoto err;\r\n}\r\nddata->csgpio[i] = ret;\r\ndev_dbg(&pdev->dev, "csgpio#%u = %u\n", i, ddata->csgpio[i]);\r\nret = devm_gpio_request_one(&pdev->dev, ddata->csgpio[i],\r\nGPIOF_OUT_INIT_LOW, DRIVER_NAME);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev,\r\n"failed to configure csgpio#%u (%d)\n",\r\ni, ret);\r\ngoto err;\r\n}\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nret = -ENODEV;\r\ndev_err(&pdev->dev, "failed to determine base address\n");\r\ngoto err;\r\n}\r\nif (resource_size(res) < 0x60) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "memory resource too small\n");\r\ngoto err;\r\n}\r\nddata->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ddata->base)) {\r\nret = PTR_ERR(ddata->base);\r\ngoto err;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret <= 0) {\r\ndev_err(&pdev->dev, "failed to get rx irq (%d)\n", ret);\r\ngoto err;\r\n}\r\nddata->rxirq = ret;\r\nret = platform_get_irq(pdev, 1);\r\nif (ret <= 0)\r\nret = ddata->rxirq + 1;\r\nddata->txirq = ret;\r\nret = clk_prepare_enable(ddata->clk);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to enable clock (%d)\n", ret);\r\ngoto err;\r\n}\r\nefm32_spi_probe_dt(pdev, master, ddata);\r\nefm32_spi_write32(ddata, 0, REG_IEN);\r\nefm32_spi_write32(ddata, REG_ROUTE_TXPEN | REG_ROUTE_RXPEN |\r\nREG_ROUTE_CLKPEN |\r\nREG_ROUTE_LOCATION(ddata->pdata.location), REG_ROUTE);\r\nret = request_irq(ddata->rxirq, efm32_spi_rxirq,\r\n0, DRIVER_NAME " rx", ddata);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register rxirq (%d)\n", ret);\r\ngoto err_disable_clk;\r\n}\r\nret = request_irq(ddata->txirq, efm32_spi_txirq,\r\n0, DRIVER_NAME " tx", ddata);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register txirq (%d)\n", ret);\r\ngoto err_free_rx_irq;\r\n}\r\nret = spi_bitbang_start(&ddata->bitbang);\r\nif (ret) {\r\ndev_err(&pdev->dev, "spi_bitbang_start failed (%d)\n", ret);\r\nfree_irq(ddata->txirq, ddata);\r\nerr_free_rx_irq:\r\nfree_irq(ddata->rxirq, ddata);\r\nerr_disable_clk:\r\nclk_disable_unprepare(ddata->clk);\r\nerr:\r\nspi_master_put(master);\r\n}\r\nreturn ret;\r\n}\r\nstatic int efm32_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct efm32_spi_ddata *ddata = spi_master_get_devdata(master);\r\nspi_bitbang_stop(&ddata->bitbang);\r\nefm32_spi_write32(ddata, 0, REG_IEN);\r\nfree_irq(ddata->txirq, ddata);\r\nfree_irq(ddata->rxirq, ddata);\r\nclk_disable_unprepare(ddata->clk);\r\nspi_master_put(master);\r\nreturn 0;\r\n}
