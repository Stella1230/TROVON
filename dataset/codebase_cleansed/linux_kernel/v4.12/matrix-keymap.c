static bool matrix_keypad_map_key(struct input_dev *input_dev,\r\nunsigned int rows, unsigned int cols,\r\nunsigned int row_shift, unsigned int key)\r\n{\r\nunsigned short *keymap = input_dev->keycode;\r\nunsigned int row = KEY_ROW(key);\r\nunsigned int col = KEY_COL(key);\r\nunsigned short code = KEY_VAL(key);\r\nif (row >= rows || col >= cols) {\r\ndev_err(input_dev->dev.parent,\r\n"%s: invalid keymap entry 0x%x (row: %d, col: %d, rows: %d, cols: %d)\n",\r\n__func__, key, row, col, rows, cols);\r\nreturn false;\r\n}\r\nkeymap[MATRIX_SCAN_CODE(row, col, row_shift)] = code;\r\n__set_bit(code, input_dev->keybit);\r\nreturn true;\r\n}\r\nint matrix_keypad_parse_properties(struct device *dev,\r\nunsigned int *rows, unsigned int *cols)\r\n{\r\n*rows = *cols = 0;\r\ndevice_property_read_u32(dev, "keypad,num-rows", rows);\r\ndevice_property_read_u32(dev, "keypad,num-columns", cols);\r\nif (!*rows || !*cols) {\r\ndev_err(dev, "number of keypad rows/columns not specified\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int matrix_keypad_parse_keymap(const char *propname,\r\nunsigned int rows, unsigned int cols,\r\nstruct input_dev *input_dev)\r\n{\r\nstruct device *dev = input_dev->dev.parent;\r\nunsigned int row_shift = get_count_order(cols);\r\nunsigned int max_keys = rows << row_shift;\r\nu32 *keys;\r\nint i;\r\nint size;\r\nint retval;\r\nif (!propname)\r\npropname = "linux,keymap";\r\nsize = device_property_read_u32_array(dev, propname, NULL, 0);\r\nif (size <= 0) {\r\ndev_err(dev, "missing or malformed property %s: %d\n",\r\npropname, size);\r\nreturn size < 0 ? size : -EINVAL;\r\n}\r\nif (size > max_keys) {\r\ndev_err(dev, "%s size overflow (%d vs max %u)\n",\r\npropname, size, max_keys);\r\nreturn -EINVAL;\r\n}\r\nkeys = kmalloc_array(size, sizeof(u32), GFP_KERNEL);\r\nif (!keys)\r\nreturn -ENOMEM;\r\nretval = device_property_read_u32_array(dev, propname, keys, size);\r\nif (retval) {\r\ndev_err(dev, "failed to read %s property: %d\n",\r\npropname, retval);\r\ngoto out;\r\n}\r\nfor (i = 0; i < size; i++) {\r\nif (!matrix_keypad_map_key(input_dev, rows, cols,\r\nrow_shift, keys[i])) {\r\nretval = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nretval = 0;\r\nout:\r\nkfree(keys);\r\nreturn retval;\r\n}\r\nint matrix_keypad_build_keymap(const struct matrix_keymap_data *keymap_data,\r\nconst char *keymap_name,\r\nunsigned int rows, unsigned int cols,\r\nunsigned short *keymap,\r\nstruct input_dev *input_dev)\r\n{\r\nunsigned int row_shift = get_count_order(cols);\r\nsize_t max_keys = rows << row_shift;\r\nint i;\r\nint error;\r\nif (WARN_ON(!input_dev->dev.parent))\r\nreturn -EINVAL;\r\nif (!keymap) {\r\nkeymap = devm_kzalloc(input_dev->dev.parent,\r\nmax_keys * sizeof(*keymap),\r\nGFP_KERNEL);\r\nif (!keymap) {\r\ndev_err(input_dev->dev.parent,\r\n"Unable to allocate memory for keymap");\r\nreturn -ENOMEM;\r\n}\r\n}\r\ninput_dev->keycode = keymap;\r\ninput_dev->keycodesize = sizeof(*keymap);\r\ninput_dev->keycodemax = max_keys;\r\n__set_bit(EV_KEY, input_dev->evbit);\r\nif (keymap_data) {\r\nfor (i = 0; i < keymap_data->keymap_size; i++) {\r\nunsigned int key = keymap_data->keymap[i];\r\nif (!matrix_keypad_map_key(input_dev, rows, cols,\r\nrow_shift, key))\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nerror = matrix_keypad_parse_keymap(keymap_name, rows, cols,\r\ninput_dev);\r\nif (error)\r\nreturn error;\r\n}\r\n__clear_bit(KEY_RESERVED, input_dev->keybit);\r\nreturn 0;\r\n}
