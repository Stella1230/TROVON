bool dim2_sysfs_get_state_cb(void)\r\n{\r\nbool state;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dim_lock, flags);\r\nstate = dim_get_lock_state();\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn state;\r\n}\r\nu32 dimcb_io_read(u32 __iomem *ptr32)\r\n{\r\nreturn readl(ptr32);\r\n}\r\nvoid dimcb_io_write(u32 __iomem *ptr32, u32 value)\r\n{\r\nwritel(value, ptr32);\r\n}\r\nvoid dimcb_on_error(u8 error_id, const char *error_message)\r\n{\r\npr_err("dimcb_on_error: error_id - %d, error_message - %s\n", error_id,\r\nerror_message);\r\n}\r\nstatic int startup_dim(struct platform_device *pdev)\r\n{\r\nstruct dim2_hdm *dev = platform_get_drvdata(pdev);\r\nstruct dim2_platform_data *pdata = pdev->dev.platform_data;\r\nu8 hal_ret;\r\ndev->clk_speed = -1;\r\nif (clock_speed) {\r\nif (!strcmp(clock_speed, "256fs"))\r\ndev->clk_speed = CLK_256FS;\r\nelse if (!strcmp(clock_speed, "512fs"))\r\ndev->clk_speed = CLK_512FS;\r\nelse if (!strcmp(clock_speed, "1024fs"))\r\ndev->clk_speed = CLK_1024FS;\r\nelse if (!strcmp(clock_speed, "2048fs"))\r\ndev->clk_speed = CLK_2048FS;\r\nelse if (!strcmp(clock_speed, "3072fs"))\r\ndev->clk_speed = CLK_3072FS;\r\nelse if (!strcmp(clock_speed, "4096fs"))\r\ndev->clk_speed = CLK_4096FS;\r\nelse if (!strcmp(clock_speed, "6144fs"))\r\ndev->clk_speed = CLK_6144FS;\r\nelse if (!strcmp(clock_speed, "8192fs"))\r\ndev->clk_speed = CLK_8192FS;\r\n}\r\nif (dev->clk_speed == -1) {\r\npr_info("Bad or missing clock speed parameter, using default value: 3072fs\n");\r\ndev->clk_speed = CLK_3072FS;\r\n} else {\r\npr_info("Selected clock speed: %s\n", clock_speed);\r\n}\r\nif (pdata && pdata->init) {\r\nint ret = pdata->init(pdata, dev->io_base, dev->clk_speed);\r\nif (ret)\r\nreturn ret;\r\n}\r\npr_info("sync: num of frames per sub-buffer: %u\n", fcnt);\r\nhal_ret = dim_startup(dev->io_base, dev->clk_speed, fcnt);\r\nif (hal_ret != DIM_NO_ERROR) {\r\npr_err("dim_startup failed: %d\n", hal_ret);\r\nif (pdata && pdata->destroy)\r\npdata->destroy(pdata);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int try_start_dim_transfer(struct hdm_channel *hdm_ch)\r\n{\r\nu16 buf_size;\r\nstruct list_head *head = &hdm_ch->pending_list;\r\nstruct mbo *mbo;\r\nunsigned long flags;\r\nstruct dim_ch_state_t st;\r\nBUG_ON(!hdm_ch);\r\nBUG_ON(!hdm_ch->is_initialized);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nif (list_empty(head)) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nif (!dim_get_channel_state(&hdm_ch->ch, &st)->ready) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nmbo = list_first_entry(head, struct mbo, list);\r\nbuf_size = mbo->buffer_length;\r\nif (dim_dbr_space(&hdm_ch->ch) < buf_size) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nBUG_ON(mbo->bus_address == 0);\r\nif (!dim_enqueue_buffer(&hdm_ch->ch, mbo->bus_address, buf_size)) {\r\nlist_del(head->next);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nmbo->processed_length = 0;\r\nmbo->status = MBO_E_INVAL;\r\nmbo->complete(mbo);\r\nreturn -EFAULT;\r\n}\r\nlist_move_tail(head->next, &hdm_ch->started_list);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int deliver_netinfo_thread(void *data)\r\n{\r\nstruct dim2_hdm *dev = data;\r\nwhile (!kthread_should_stop()) {\r\nwait_event_interruptible(dev->netinfo_waitq,\r\ndev->deliver_netinfo ||\r\nkthread_should_stop());\r\nif (dev->deliver_netinfo) {\r\ndev->deliver_netinfo--;\r\nmost_deliver_netinfo(&dev->most_iface, dev->link_state,\r\ndev->mac_addrs);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void retrieve_netinfo(struct dim2_hdm *dev, struct mbo *mbo)\r\n{\r\nu8 *data = mbo->virt_address;\r\npr_info("Node Address: 0x%03x\n", (u16)data[16] << 8 | data[17]);\r\ndev->link_state = data[18];\r\npr_info("NIState: %d\n", dev->link_state);\r\nmemcpy(dev->mac_addrs, data + 19, 6);\r\ndev->deliver_netinfo++;\r\nwake_up_interruptible(&dev->netinfo_waitq);\r\n}\r\nstatic void service_done_flag(struct dim2_hdm *dev, int ch_idx)\r\n{\r\nstruct hdm_channel *hdm_ch = dev->hch + ch_idx;\r\nstruct dim_ch_state_t st;\r\nstruct list_head *head;\r\nstruct mbo *mbo;\r\nint done_buffers;\r\nunsigned long flags;\r\nu8 *data;\r\nBUG_ON(!hdm_ch);\r\nBUG_ON(!hdm_ch->is_initialized);\r\nspin_lock_irqsave(&dim_lock, flags);\r\ndone_buffers = dim_get_channel_state(&hdm_ch->ch, &st)->done_buffers;\r\nif (!done_buffers) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn;\r\n}\r\nif (!dim_detach_buffers(&hdm_ch->ch, done_buffers)) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nhead = &hdm_ch->started_list;\r\nwhile (done_buffers) {\r\nspin_lock_irqsave(&dim_lock, flags);\r\nif (list_empty(head)) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\npr_crit("hard error: started_mbo list is empty whereas DIM2 has sent buffers\n");\r\nbreak;\r\n}\r\nmbo = list_first_entry(head, struct mbo, list);\r\nlist_del(head->next);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\ndata = mbo->virt_address;\r\nif (hdm_ch->data_type == MOST_CH_ASYNC &&\r\nhdm_ch->direction == MOST_CH_RX &&\r\nPACKET_IS_NET_INFO(data)) {\r\nretrieve_netinfo(dev, mbo);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nlist_add_tail(&mbo->list, &hdm_ch->pending_list);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\n} else {\r\nif (hdm_ch->data_type == MOST_CH_CONTROL ||\r\nhdm_ch->data_type == MOST_CH_ASYNC) {\r\nu32 const data_size =\r\n(u32)data[0] * 256 + data[1] + 2;\r\nmbo->processed_length =\r\nmin_t(u32, data_size,\r\nmbo->buffer_length);\r\n} else {\r\nmbo->processed_length = mbo->buffer_length;\r\n}\r\nmbo->status = MBO_SUCCESS;\r\nmbo->complete(mbo);\r\n}\r\ndone_buffers--;\r\n}\r\n}\r\nstatic struct dim_channel **get_active_channels(struct dim2_hdm *dev,\r\nstruct dim_channel **buffer)\r\n{\r\nint idx = 0;\r\nint ch_idx;\r\nfor (ch_idx = 0; ch_idx < DMA_CHANNELS; ch_idx++) {\r\nif (dev->hch[ch_idx].is_initialized)\r\nbuffer[idx++] = &dev->hch[ch_idx].ch;\r\n}\r\nbuffer[idx++] = NULL;\r\nreturn buffer;\r\n}\r\nstatic irqreturn_t dim2_mlb_isr(int irq, void *_dev)\r\n{\r\nstruct dim2_hdm *dev = _dev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dim_lock, flags);\r\ndim_service_mlb_int_irq();\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nif (dev->atx_idx >= 0 && dev->hch[dev->atx_idx].is_initialized)\r\nwhile (!try_start_dim_transfer(dev->hch + dev->atx_idx))\r\ncontinue;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dim2_tasklet_fn(unsigned long data)\r\n{\r\nstruct dim2_hdm *dev = (struct dim2_hdm *)data;\r\nunsigned long flags;\r\nint ch_idx;\r\nfor (ch_idx = 0; ch_idx < DMA_CHANNELS; ch_idx++) {\r\nif (!dev->hch[ch_idx].is_initialized)\r\ncontinue;\r\nspin_lock_irqsave(&dim_lock, flags);\r\ndim_service_channel(&dev->hch[ch_idx].ch);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nservice_done_flag(dev, ch_idx);\r\nwhile (!try_start_dim_transfer(dev->hch + ch_idx))\r\ncontinue;\r\n}\r\n}\r\nstatic irqreturn_t dim2_ahb_isr(int irq, void *_dev)\r\n{\r\nstruct dim2_hdm *dev = _dev;\r\nstruct dim_channel *buffer[DMA_CHANNELS + 1];\r\nunsigned long flags;\r\nspin_lock_irqsave(&dim_lock, flags);\r\ndim_service_ahb_int_irq(get_active_channels(dev, buffer));\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\ndim2_tasklet.data = (unsigned long)dev;\r\ntasklet_schedule(&dim2_tasklet);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void complete_all_mbos(struct list_head *head)\r\n{\r\nunsigned long flags;\r\nstruct mbo *mbo;\r\nfor (;;) {\r\nspin_lock_irqsave(&dim_lock, flags);\r\nif (list_empty(head)) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nbreak;\r\n}\r\nmbo = list_first_entry(head, struct mbo, list);\r\nlist_del(head->next);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nmbo->processed_length = 0;\r\nmbo->status = MBO_E_CLOSE;\r\nmbo->complete(mbo);\r\n}\r\n}\r\nstatic int configure_channel(struct most_interface *most_iface, int ch_idx,\r\nstruct most_channel_config *ccfg)\r\n{\r\nstruct dim2_hdm *dev = iface_to_hdm(most_iface);\r\nbool const is_tx = ccfg->direction == MOST_CH_TX;\r\nu16 const sub_size = ccfg->subbuffer_size;\r\nu16 const buf_size = ccfg->buffer_size;\r\nu16 new_size;\r\nunsigned long flags;\r\nu8 hal_ret;\r\nint const ch_addr = ch_idx * 2 + 2;\r\nstruct hdm_channel *const hdm_ch = dev->hch + ch_idx;\r\nBUG_ON(ch_idx < 0 || ch_idx >= DMA_CHANNELS);\r\nif (hdm_ch->is_initialized)\r\nreturn -EPERM;\r\nswitch (ccfg->data_type) {\r\ncase MOST_CH_CONTROL:\r\nnew_size = dim_norm_ctrl_async_buffer_size(buf_size);\r\nif (new_size == 0) {\r\npr_err("%s: too small buffer size\n", hdm_ch->name);\r\nreturn -EINVAL;\r\n}\r\nccfg->buffer_size = new_size;\r\nif (new_size != buf_size)\r\npr_warn("%s: fixed buffer size (%d -> %d)\n",\r\nhdm_ch->name, buf_size, new_size);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nhal_ret = dim_init_control(&hdm_ch->ch, is_tx, ch_addr,\r\nis_tx ? new_size * 2 : new_size);\r\nbreak;\r\ncase MOST_CH_ASYNC:\r\nnew_size = dim_norm_ctrl_async_buffer_size(buf_size);\r\nif (new_size == 0) {\r\npr_err("%s: too small buffer size\n", hdm_ch->name);\r\nreturn -EINVAL;\r\n}\r\nccfg->buffer_size = new_size;\r\nif (new_size != buf_size)\r\npr_warn("%s: fixed buffer size (%d -> %d)\n",\r\nhdm_ch->name, buf_size, new_size);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nhal_ret = dim_init_async(&hdm_ch->ch, is_tx, ch_addr,\r\nis_tx ? new_size * 2 : new_size);\r\nbreak;\r\ncase MOST_CH_ISOC:\r\nnew_size = dim_norm_isoc_buffer_size(buf_size, sub_size);\r\nif (new_size == 0) {\r\npr_err("%s: invalid sub-buffer size or too small buffer size\n",\r\nhdm_ch->name);\r\nreturn -EINVAL;\r\n}\r\nccfg->buffer_size = new_size;\r\nif (new_size != buf_size)\r\npr_warn("%s: fixed buffer size (%d -> %d)\n",\r\nhdm_ch->name, buf_size, new_size);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nhal_ret = dim_init_isoc(&hdm_ch->ch, is_tx, ch_addr, sub_size);\r\nbreak;\r\ncase MOST_CH_SYNC:\r\nnew_size = dim_norm_sync_buffer_size(buf_size, sub_size);\r\nif (new_size == 0) {\r\npr_err("%s: invalid sub-buffer size or too small buffer size\n",\r\nhdm_ch->name);\r\nreturn -EINVAL;\r\n}\r\nccfg->buffer_size = new_size;\r\nif (new_size != buf_size)\r\npr_warn("%s: fixed buffer size (%d -> %d)\n",\r\nhdm_ch->name, buf_size, new_size);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nhal_ret = dim_init_sync(&hdm_ch->ch, is_tx, ch_addr, sub_size);\r\nbreak;\r\ndefault:\r\npr_err("%s: configure failed, bad channel type: %d\n",\r\nhdm_ch->name, ccfg->data_type);\r\nreturn -EINVAL;\r\n}\r\nif (hal_ret != DIM_NO_ERROR) {\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\npr_err("%s: configure failed (%d), type: %d, is_tx: %d\n",\r\nhdm_ch->name, hal_ret, ccfg->data_type, (int)is_tx);\r\nreturn -ENODEV;\r\n}\r\nhdm_ch->data_type = ccfg->data_type;\r\nhdm_ch->direction = ccfg->direction;\r\nhdm_ch->is_initialized = true;\r\nif (hdm_ch->data_type == MOST_CH_ASYNC &&\r\nhdm_ch->direction == MOST_CH_TX &&\r\ndev->atx_idx < 0)\r\ndev->atx_idx = ch_idx;\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int enqueue(struct most_interface *most_iface, int ch_idx,\r\nstruct mbo *mbo)\r\n{\r\nstruct dim2_hdm *dev = iface_to_hdm(most_iface);\r\nstruct hdm_channel *hdm_ch = dev->hch + ch_idx;\r\nunsigned long flags;\r\nBUG_ON(ch_idx < 0 || ch_idx >= DMA_CHANNELS);\r\nif (!hdm_ch->is_initialized)\r\nreturn -EPERM;\r\nif (mbo->bus_address == 0)\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&dim_lock, flags);\r\nlist_add_tail(&mbo->list, &hdm_ch->pending_list);\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\n(void)try_start_dim_transfer(hdm_ch);\r\nreturn 0;\r\n}\r\nstatic void request_netinfo(struct most_interface *most_iface, int ch_idx)\r\n{\r\nstruct dim2_hdm *dev = iface_to_hdm(most_iface);\r\nstruct mbo *mbo;\r\nu8 *data;\r\nif (dev->atx_idx < 0) {\r\npr_err("Async Tx Not initialized\n");\r\nreturn;\r\n}\r\nmbo = most_get_mbo(&dev->most_iface, dev->atx_idx, NULL);\r\nif (!mbo)\r\nreturn;\r\nmbo->buffer_length = 5;\r\ndata = mbo->virt_address;\r\ndata[0] = 0x00;\r\ndata[1] = 0x03;\r\ndata[2] = 0x02;\r\ndata[3] = 0x08;\r\ndata[4] = 0x40;\r\nmost_submit_mbo(mbo);\r\n}\r\nstatic int poison_channel(struct most_interface *most_iface, int ch_idx)\r\n{\r\nstruct dim2_hdm *dev = iface_to_hdm(most_iface);\r\nstruct hdm_channel *hdm_ch = dev->hch + ch_idx;\r\nunsigned long flags;\r\nu8 hal_ret;\r\nint ret = 0;\r\nBUG_ON(ch_idx < 0 || ch_idx >= DMA_CHANNELS);\r\nif (!hdm_ch->is_initialized)\r\nreturn -EPERM;\r\ntasklet_disable(&dim2_tasklet);\r\nspin_lock_irqsave(&dim_lock, flags);\r\nhal_ret = dim_destroy_channel(&hdm_ch->ch);\r\nhdm_ch->is_initialized = false;\r\nif (ch_idx == dev->atx_idx)\r\ndev->atx_idx = -1;\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\ntasklet_enable(&dim2_tasklet);\r\nif (hal_ret != DIM_NO_ERROR) {\r\npr_err("HAL Failed to close channel %s\n", hdm_ch->name);\r\nret = -EFAULT;\r\n}\r\ncomplete_all_mbos(&hdm_ch->started_list);\r\ncomplete_all_mbos(&hdm_ch->pending_list);\r\nreturn ret;\r\n}\r\nstatic int dim2_probe(struct platform_device *pdev)\r\n{\r\nstruct dim2_hdm *dev;\r\nstruct resource *res;\r\nint ret, i;\r\nstruct kobject *kobj;\r\nint irq;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->atx_idx = -1;\r\nplatform_set_drvdata(pdev, dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ndev->io_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(dev->io_base))\r\nreturn PTR_ERR(dev->io_base);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get ahb0_int irq\n");\r\nreturn -ENODEV;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, dim2_ahb_isr, 0,\r\n"dim2_ahb0_int", dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request ahb0_int irq %d\n", irq);\r\nreturn ret;\r\n}\r\nirq = platform_get_irq(pdev, 1);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get mlb_int irq\n");\r\nreturn -ENODEV;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, dim2_mlb_isr, 0,\r\n"dim2_mlb_int", dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request mlb_int irq %d\n", irq);\r\nreturn ret;\r\n}\r\ninit_waitqueue_head(&dev->netinfo_waitq);\r\ndev->deliver_netinfo = 0;\r\ndev->netinfo_task = kthread_run(&deliver_netinfo_thread, (void *)dev,\r\n"dim2_netinfo");\r\nif (IS_ERR(dev->netinfo_task))\r\nreturn PTR_ERR(dev->netinfo_task);\r\nfor (i = 0; i < DMA_CHANNELS; i++) {\r\nstruct most_channel_capability *cap = dev->capabilities + i;\r\nstruct hdm_channel *hdm_ch = dev->hch + i;\r\nINIT_LIST_HEAD(&hdm_ch->pending_list);\r\nINIT_LIST_HEAD(&hdm_ch->started_list);\r\nhdm_ch->is_initialized = false;\r\nsnprintf(hdm_ch->name, sizeof(hdm_ch->name), "ca%d", i * 2 + 2);\r\ncap->name_suffix = hdm_ch->name;\r\ncap->direction = MOST_CH_RX | MOST_CH_TX;\r\ncap->data_type = MOST_CH_CONTROL | MOST_CH_ASYNC |\r\nMOST_CH_ISOC | MOST_CH_SYNC;\r\ncap->num_buffers_packet = MAX_BUFFERS_PACKET;\r\ncap->buffer_size_packet = MAX_BUF_SIZE_PACKET;\r\ncap->num_buffers_streaming = MAX_BUFFERS_STREAMING;\r\ncap->buffer_size_streaming = MAX_BUF_SIZE_STREAMING;\r\n}\r\n{\r\nconst char *fmt;\r\nif (sizeof(res->start) == sizeof(long long))\r\nfmt = "dim2-%016llx";\r\nelse if (sizeof(res->start) == sizeof(long))\r\nfmt = "dim2-%016lx";\r\nelse\r\nfmt = "dim2-%016x";\r\nsnprintf(dev->name, sizeof(dev->name), fmt, res->start);\r\n}\r\ndev->most_iface.interface = ITYPE_MEDIALB_DIM2;\r\ndev->most_iface.description = dev->name;\r\ndev->most_iface.num_channels = DMA_CHANNELS;\r\ndev->most_iface.channel_vector = dev->capabilities;\r\ndev->most_iface.configure = configure_channel;\r\ndev->most_iface.enqueue = enqueue;\r\ndev->most_iface.poison_channel = poison_channel;\r\ndev->most_iface.request_netinfo = request_netinfo;\r\nkobj = most_register_interface(&dev->most_iface);\r\nif (IS_ERR(kobj)) {\r\nret = PTR_ERR(kobj);\r\ndev_err(&pdev->dev, "failed to register MOST interface\n");\r\ngoto err_stop_thread;\r\n}\r\nret = dim2_sysfs_probe(&dev->bus, kobj);\r\nif (ret)\r\ngoto err_unreg_iface;\r\nret = startup_dim(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to initialize DIM2\n");\r\ngoto err_destroy_bus;\r\n}\r\nreturn 0;\r\nerr_destroy_bus:\r\ndim2_sysfs_destroy(&dev->bus);\r\nerr_unreg_iface:\r\nmost_deregister_interface(&dev->most_iface);\r\nerr_stop_thread:\r\nkthread_stop(dev->netinfo_task);\r\nreturn ret;\r\n}\r\nstatic int dim2_remove(struct platform_device *pdev)\r\n{\r\nstruct dim2_hdm *dev = platform_get_drvdata(pdev);\r\nstruct dim2_platform_data *pdata = pdev->dev.platform_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dim_lock, flags);\r\ndim_shutdown();\r\nspin_unlock_irqrestore(&dim_lock, flags);\r\nif (pdata && pdata->destroy)\r\npdata->destroy(pdata);\r\ndim2_sysfs_destroy(&dev->bus);\r\nmost_deregister_interface(&dev->most_iface);\r\nkthread_stop(dev->netinfo_task);\r\npdev->id_entry = NULL;\r\nreturn 0;\r\n}
