static inline u32 flexcan_read(void __iomem *addr)\r\n{\r\nreturn in_be32(addr);\r\n}\r\nstatic inline void flexcan_write(u32 val, void __iomem *addr)\r\n{\r\nout_be32(addr, val);\r\n}\r\nstatic inline u32 flexcan_read(void __iomem *addr)\r\n{\r\nreturn readl(addr);\r\n}\r\nstatic inline void flexcan_write(u32 val, void __iomem *addr)\r\n{\r\nwritel(val, addr);\r\n}\r\nstatic inline int flexcan_transceiver_enable(const struct flexcan_priv *priv)\r\n{\r\nif (!priv->reg_xceiver)\r\nreturn 0;\r\nreturn regulator_enable(priv->reg_xceiver);\r\n}\r\nstatic inline int flexcan_transceiver_disable(const struct flexcan_priv *priv)\r\n{\r\nif (!priv->reg_xceiver)\r\nreturn 0;\r\nreturn regulator_disable(priv->reg_xceiver);\r\n}\r\nstatic int flexcan_chip_enable(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\r\nu32 reg;\r\nreg = flexcan_read(&regs->mcr);\r\nreg &= ~FLEXCAN_MCR_MDIS;\r\nflexcan_write(reg, &regs->mcr);\r\nwhile (timeout-- && (flexcan_read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK))\r\nudelay(10);\r\nif (flexcan_read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int flexcan_chip_disable(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\r\nu32 reg;\r\nreg = flexcan_read(&regs->mcr);\r\nreg |= FLEXCAN_MCR_MDIS;\r\nflexcan_write(reg, &regs->mcr);\r\nwhile (timeout-- && !(flexcan_read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK))\r\nudelay(10);\r\nif (!(flexcan_read(&regs->mcr) & FLEXCAN_MCR_LPM_ACK))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int flexcan_chip_freeze(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nunsigned int timeout = 1000 * 1000 * 10 / priv->can.bittiming.bitrate;\r\nu32 reg;\r\nreg = flexcan_read(&regs->mcr);\r\nreg |= FLEXCAN_MCR_HALT;\r\nflexcan_write(reg, &regs->mcr);\r\nwhile (timeout-- && !(flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))\r\nudelay(100);\r\nif (!(flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int flexcan_chip_unfreeze(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\r\nu32 reg;\r\nreg = flexcan_read(&regs->mcr);\r\nreg &= ~FLEXCAN_MCR_HALT;\r\nflexcan_write(reg, &regs->mcr);\r\nwhile (timeout-- && (flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK))\r\nudelay(10);\r\nif (flexcan_read(&regs->mcr) & FLEXCAN_MCR_FRZ_ACK)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int flexcan_chip_softreset(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nunsigned int timeout = FLEXCAN_TIMEOUT_US / 10;\r\nflexcan_write(FLEXCAN_MCR_SOFTRST, &regs->mcr);\r\nwhile (timeout-- && (flexcan_read(&regs->mcr) & FLEXCAN_MCR_SOFTRST))\r\nudelay(10);\r\nif (flexcan_read(&regs->mcr) & FLEXCAN_MCR_SOFTRST)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int __flexcan_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nu32 reg = flexcan_read(&regs->ecr);\r\nbec->txerr = (reg >> 0) & 0xff;\r\nbec->rxerr = (reg >> 8) & 0xff;\r\nreturn 0;\r\n}\r\nstatic int flexcan_get_berr_counter(const struct net_device *dev,\r\nstruct can_berr_counter *bec)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = clk_prepare_enable(priv->clk_ipg);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(priv->clk_per);\r\nif (err)\r\ngoto out_disable_ipg;\r\nerr = __flexcan_get_berr_counter(dev, bec);\r\nclk_disable_unprepare(priv->clk_per);\r\nout_disable_ipg:\r\nclk_disable_unprepare(priv->clk_ipg);\r\nreturn err;\r\n}\r\nstatic int flexcan_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nu32 can_id;\r\nu32 data;\r\nu32 ctrl = FLEXCAN_MB_CODE_TX_DATA | (cf->can_dlc << 16);\r\nif (can_dropped_invalid_skb(dev, skb))\r\nreturn NETDEV_TX_OK;\r\nnetif_stop_queue(dev);\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\ncan_id = cf->can_id & CAN_EFF_MASK;\r\nctrl |= FLEXCAN_MB_CNT_IDE | FLEXCAN_MB_CNT_SRR;\r\n} else {\r\ncan_id = (cf->can_id & CAN_SFF_MASK) << 18;\r\n}\r\nif (cf->can_id & CAN_RTR_FLAG)\r\nctrl |= FLEXCAN_MB_CNT_RTR;\r\nif (cf->can_dlc > 0) {\r\ndata = be32_to_cpup((__be32 *)&cf->data[0]);\r\nflexcan_write(data, &priv->tx_mb->data[0]);\r\n}\r\nif (cf->can_dlc > 3) {\r\ndata = be32_to_cpup((__be32 *)&cf->data[4]);\r\nflexcan_write(data, &priv->tx_mb->data[1]);\r\n}\r\ncan_put_echo_skb(skb, dev, 0);\r\nflexcan_write(can_id, &priv->tx_mb->can_id);\r\nflexcan_write(ctrl, &priv->tx_mb->can_ctrl);\r\nflexcan_write(FLEXCAN_MB_CODE_TX_INACTIVE,\r\n&priv->tx_mb_reserved->can_ctrl);\r\nflexcan_write(FLEXCAN_MB_CODE_TX_INACTIVE,\r\n&priv->tx_mb_reserved->can_ctrl);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void flexcan_irq_bus_err(struct net_device *dev, u32 reg_esr)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nbool rx_errors = false, tx_errors = false;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nif (reg_esr & FLEXCAN_ESR_BIT1_ERR) {\r\nnetdev_dbg(dev, "BIT1_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT1;\r\ntx_errors = true;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_BIT0_ERR) {\r\nnetdev_dbg(dev, "BIT0_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT0;\r\ntx_errors = true;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_ACK_ERR) {\r\nnetdev_dbg(dev, "ACK_ERR irq\n");\r\ncf->can_id |= CAN_ERR_ACK;\r\ncf->data[3] = CAN_ERR_PROT_LOC_ACK;\r\ntx_errors = true;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_CRC_ERR) {\r\nnetdev_dbg(dev, "CRC_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\ncf->data[3] = CAN_ERR_PROT_LOC_CRC_SEQ;\r\nrx_errors = true;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_FRM_ERR) {\r\nnetdev_dbg(dev, "FRM_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nrx_errors = true;\r\n}\r\nif (reg_esr & FLEXCAN_ESR_STF_ERR) {\r\nnetdev_dbg(dev, "STF_ERR irq\n");\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nrx_errors = true;\r\n}\r\npriv->can.can_stats.bus_error++;\r\nif (rx_errors)\r\ndev->stats.rx_errors++;\r\nif (tx_errors)\r\ndev->stats.tx_errors++;\r\ncan_rx_offload_irq_queue_err_skb(&priv->offload, skb);\r\n}\r\nstatic void flexcan_irq_state(struct net_device *dev, u32 reg_esr)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct sk_buff *skb;\r\nstruct can_frame *cf;\r\nenum can_state new_state, rx_state, tx_state;\r\nint flt;\r\nstruct can_berr_counter bec;\r\nflt = reg_esr & FLEXCAN_ESR_FLT_CONF_MASK;\r\nif (likely(flt == FLEXCAN_ESR_FLT_CONF_ACTIVE)) {\r\ntx_state = unlikely(reg_esr & FLEXCAN_ESR_TX_WRN) ?\r\nCAN_STATE_ERROR_WARNING : CAN_STATE_ERROR_ACTIVE;\r\nrx_state = unlikely(reg_esr & FLEXCAN_ESR_RX_WRN) ?\r\nCAN_STATE_ERROR_WARNING : CAN_STATE_ERROR_ACTIVE;\r\nnew_state = max(tx_state, rx_state);\r\n} else {\r\n__flexcan_get_berr_counter(dev, &bec);\r\nnew_state = flt == FLEXCAN_ESR_FLT_CONF_PASSIVE ?\r\nCAN_STATE_ERROR_PASSIVE : CAN_STATE_BUS_OFF;\r\nrx_state = bec.rxerr >= bec.txerr ? new_state : 0;\r\ntx_state = bec.rxerr <= bec.txerr ? new_state : 0;\r\n}\r\nif (likely(new_state == priv->can.state))\r\nreturn;\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (unlikely(!skb))\r\nreturn;\r\ncan_change_state(dev, cf, tx_state, rx_state);\r\nif (unlikely(new_state == CAN_STATE_BUS_OFF))\r\ncan_bus_off(dev);\r\ncan_rx_offload_irq_queue_err_skb(&priv->offload, skb);\r\n}\r\nstatic inline struct flexcan_priv *rx_offload_to_priv(struct can_rx_offload *offload)\r\n{\r\nreturn container_of(offload, struct flexcan_priv, offload);\r\n}\r\nstatic unsigned int flexcan_mailbox_read(struct can_rx_offload *offload,\r\nstruct can_frame *cf,\r\nu32 *timestamp, unsigned int n)\r\n{\r\nstruct flexcan_priv *priv = rx_offload_to_priv(offload);\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nstruct flexcan_mb __iomem *mb = &regs->mb[n];\r\nu32 reg_ctrl, reg_id, reg_iflag1;\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\nu32 code;\r\ndo {\r\nreg_ctrl = flexcan_read(&mb->can_ctrl);\r\n} while (reg_ctrl & FLEXCAN_MB_CODE_RX_BUSY_BIT);\r\ncode = reg_ctrl & FLEXCAN_MB_CODE_MASK;\r\nif ((code != FLEXCAN_MB_CODE_RX_FULL) &&\r\n(code != FLEXCAN_MB_CODE_RX_OVERRUN))\r\nreturn 0;\r\nif (code == FLEXCAN_MB_CODE_RX_OVERRUN) {\r\noffload->dev->stats.rx_over_errors++;\r\noffload->dev->stats.rx_errors++;\r\n}\r\n} else {\r\nreg_iflag1 = flexcan_read(&regs->iflag1);\r\nif (!(reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE))\r\nreturn 0;\r\nreg_ctrl = flexcan_read(&mb->can_ctrl);\r\n}\r\n*timestamp = reg_ctrl << 16;\r\nreg_id = flexcan_read(&mb->can_id);\r\nif (reg_ctrl & FLEXCAN_MB_CNT_IDE)\r\ncf->can_id = ((reg_id >> 0) & CAN_EFF_MASK) | CAN_EFF_FLAG;\r\nelse\r\ncf->can_id = (reg_id >> 18) & CAN_SFF_MASK;\r\nif (reg_ctrl & FLEXCAN_MB_CNT_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_dlc = get_can_dlc((reg_ctrl >> 16) & 0xf);\r\n*(__be32 *)(cf->data + 0) = cpu_to_be32(flexcan_read(&mb->data[0]));\r\n*(__be32 *)(cf->data + 4) = cpu_to_be32(flexcan_read(&mb->data[1]));\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\nif (n < 32)\r\nflexcan_write(BIT(n), &regs->iflag1);\r\nelse\r\nflexcan_write(BIT(n - 32), &regs->iflag2);\r\n} else {\r\nflexcan_write(FLEXCAN_IFLAG_RX_FIFO_AVAILABLE, &regs->iflag1);\r\nflexcan_read(&regs->timer);\r\n}\r\nreturn 1;\r\n}\r\nstatic inline u64 flexcan_read_reg_iflag_rx(struct flexcan_priv *priv)\r\n{\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nu32 iflag1, iflag2;\r\niflag2 = flexcan_read(&regs->iflag2) & priv->reg_imask2_default;\r\niflag1 = flexcan_read(&regs->iflag1) & priv->reg_imask1_default &\r\n~FLEXCAN_IFLAG_MB(priv->tx_mb_idx);\r\nreturn (u64)iflag2 << 32 | iflag1;\r\n}\r\nstatic irqreturn_t flexcan_irq(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nirqreturn_t handled = IRQ_NONE;\r\nu32 reg_iflag1, reg_esr;\r\nreg_iflag1 = flexcan_read(&regs->iflag1);\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\nu64 reg_iflag;\r\nint ret;\r\nwhile ((reg_iflag = flexcan_read_reg_iflag_rx(priv))) {\r\nhandled = IRQ_HANDLED;\r\nret = can_rx_offload_irq_offload_timestamp(&priv->offload,\r\nreg_iflag);\r\nif (!ret)\r\nbreak;\r\n}\r\n} else {\r\nif (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_AVAILABLE) {\r\nhandled = IRQ_HANDLED;\r\ncan_rx_offload_irq_offload_fifo(&priv->offload);\r\n}\r\nif (reg_iflag1 & FLEXCAN_IFLAG_RX_FIFO_OVERFLOW) {\r\nhandled = IRQ_HANDLED;\r\nflexcan_write(FLEXCAN_IFLAG_RX_FIFO_OVERFLOW, &regs->iflag1);\r\ndev->stats.rx_over_errors++;\r\ndev->stats.rx_errors++;\r\n}\r\n}\r\nif (reg_iflag1 & FLEXCAN_IFLAG_MB(priv->tx_mb_idx)) {\r\nhandled = IRQ_HANDLED;\r\nstats->tx_bytes += can_get_echo_skb(dev, 0);\r\nstats->tx_packets++;\r\ncan_led_event(dev, CAN_LED_EVENT_TX);\r\nflexcan_write(FLEXCAN_MB_CODE_TX_INACTIVE,\r\n&priv->tx_mb->can_ctrl);\r\nflexcan_write(FLEXCAN_IFLAG_MB(priv->tx_mb_idx), &regs->iflag1);\r\nnetif_wake_queue(dev);\r\n}\r\nreg_esr = flexcan_read(&regs->esr);\r\nif (reg_esr & FLEXCAN_ESR_ALL_INT) {\r\nhandled = IRQ_HANDLED;\r\nflexcan_write(reg_esr & FLEXCAN_ESR_ALL_INT, &regs->esr);\r\n}\r\nif (reg_esr & FLEXCAN_ESR_ERR_STATE)\r\nflexcan_irq_state(dev, reg_esr);\r\nif ((reg_esr & FLEXCAN_ESR_ERR_BUS) &&\r\n(priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\r\nflexcan_irq_bus_err(dev, reg_esr);\r\nreturn handled;\r\n}\r\nstatic void flexcan_set_bittiming(struct net_device *dev)\r\n{\r\nconst struct flexcan_priv *priv = netdev_priv(dev);\r\nconst struct can_bittiming *bt = &priv->can.bittiming;\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nu32 reg;\r\nreg = flexcan_read(&regs->ctrl);\r\nreg &= ~(FLEXCAN_CTRL_PRESDIV(0xff) |\r\nFLEXCAN_CTRL_RJW(0x3) |\r\nFLEXCAN_CTRL_PSEG1(0x7) |\r\nFLEXCAN_CTRL_PSEG2(0x7) |\r\nFLEXCAN_CTRL_PROPSEG(0x7) |\r\nFLEXCAN_CTRL_LPB |\r\nFLEXCAN_CTRL_SMP |\r\nFLEXCAN_CTRL_LOM);\r\nreg |= FLEXCAN_CTRL_PRESDIV(bt->brp - 1) |\r\nFLEXCAN_CTRL_PSEG1(bt->phase_seg1 - 1) |\r\nFLEXCAN_CTRL_PSEG2(bt->phase_seg2 - 1) |\r\nFLEXCAN_CTRL_RJW(bt->sjw - 1) |\r\nFLEXCAN_CTRL_PROPSEG(bt->prop_seg - 1);\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)\r\nreg |= FLEXCAN_CTRL_LPB;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)\r\nreg |= FLEXCAN_CTRL_LOM;\r\nif (priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nreg |= FLEXCAN_CTRL_SMP;\r\nnetdev_dbg(dev, "writing ctrl=0x%08x\n", reg);\r\nflexcan_write(reg, &regs->ctrl);\r\nnetdev_dbg(dev, "%s: mcr=0x%08x ctrl=0x%08x\n", __func__,\r\nflexcan_read(&regs->mcr), flexcan_read(&regs->ctrl));\r\n}\r\nstatic int flexcan_chip_start(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nu32 reg_mcr, reg_ctrl, reg_ctrl2, reg_mecr;\r\nint err, i;\r\nerr = flexcan_chip_enable(priv);\r\nif (err)\r\nreturn err;\r\nerr = flexcan_chip_softreset(priv);\r\nif (err)\r\ngoto out_chip_disable;\r\nflexcan_set_bittiming(dev);\r\nreg_mcr = flexcan_read(&regs->mcr);\r\nreg_mcr &= ~FLEXCAN_MCR_MAXMB(0xff);\r\nreg_mcr |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT | FLEXCAN_MCR_SUPV |\r\nFLEXCAN_MCR_WRN_EN | FLEXCAN_MCR_SRX_DIS | FLEXCAN_MCR_IRMQ |\r\nFLEXCAN_MCR_IDAM_C;\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\nreg_mcr &= ~FLEXCAN_MCR_FEN;\r\nreg_mcr |= FLEXCAN_MCR_MAXMB(priv->offload.mb_last);\r\n} else {\r\nreg_mcr |= FLEXCAN_MCR_FEN |\r\nFLEXCAN_MCR_MAXMB(priv->tx_mb_idx);\r\n}\r\nnetdev_dbg(dev, "%s: writing mcr=0x%08x", __func__, reg_mcr);\r\nflexcan_write(reg_mcr, &regs->mcr);\r\nreg_ctrl = flexcan_read(&regs->ctrl);\r\nreg_ctrl &= ~FLEXCAN_CTRL_TSYN;\r\nreg_ctrl |= FLEXCAN_CTRL_BOFF_REC | FLEXCAN_CTRL_LBUF |\r\nFLEXCAN_CTRL_ERR_STATE;\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_BROKEN_ERR_STATE ||\r\npriv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\r\nreg_ctrl |= FLEXCAN_CTRL_ERR_MSK;\r\nelse\r\nreg_ctrl &= ~FLEXCAN_CTRL_ERR_MSK;\r\npriv->reg_ctrl_default = reg_ctrl;\r\nreg_ctrl &= ~FLEXCAN_CTRL_ERR_ALL;\r\nnetdev_dbg(dev, "%s: writing ctrl=0x%08x", __func__, reg_ctrl);\r\nflexcan_write(reg_ctrl, &regs->ctrl);\r\nif ((priv->devtype_data->quirks & FLEXCAN_QUIRK_ENABLE_EACEN_RRS)) {\r\nreg_ctrl2 = flexcan_read(&regs->ctrl2);\r\nreg_ctrl2 |= FLEXCAN_CTRL2_EACEN | FLEXCAN_CTRL2_RRS;\r\nflexcan_write(reg_ctrl2, &regs->ctrl2);\r\n}\r\nfor (i = priv->tx_mb_idx; i < ARRAY_SIZE(regs->mb); i++) {\r\nflexcan_write(FLEXCAN_MB_CODE_RX_INACTIVE,\r\n&regs->mb[i].can_ctrl);\r\n}\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\nfor (i = priv->offload.mb_first; i <= priv->offload.mb_last; i++)\r\nflexcan_write(FLEXCAN_MB_CODE_RX_EMPTY,\r\n&regs->mb[i].can_ctrl);\r\n}\r\nflexcan_write(FLEXCAN_MB_CODE_TX_INACTIVE,\r\n&priv->tx_mb_reserved->can_ctrl);\r\nflexcan_write(FLEXCAN_MB_CODE_TX_INACTIVE,\r\n&priv->tx_mb->can_ctrl);\r\nflexcan_write(0x0, &regs->rxgmask);\r\nflexcan_write(0x0, &regs->rx14mask);\r\nflexcan_write(0x0, &regs->rx15mask);\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_DISABLE_RXFG)\r\nflexcan_write(0x0, &regs->rxfgmask);\r\nfor (i = 0; i < ARRAY_SIZE(regs->mb); i++)\r\nflexcan_write(0, &regs->rximr[i]);\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_DISABLE_MECR) {\r\nreg_ctrl2 = flexcan_read(&regs->ctrl2);\r\nreg_ctrl2 |= FLEXCAN_CTRL2_ECRWRE;\r\nflexcan_write(reg_ctrl2, &regs->ctrl2);\r\nreg_mecr = flexcan_read(&regs->mecr);\r\nreg_mecr &= ~FLEXCAN_MECR_ECRWRDIS;\r\nflexcan_write(reg_mecr, &regs->mecr);\r\nreg_mecr &= ~(FLEXCAN_MECR_NCEFAFRZ | FLEXCAN_MECR_HANCEI_MSK |\r\nFLEXCAN_MECR_FANCEI_MSK);\r\nflexcan_write(reg_mecr, &regs->mecr);\r\n}\r\nerr = flexcan_transceiver_enable(priv);\r\nif (err)\r\ngoto out_chip_disable;\r\nerr = flexcan_chip_unfreeze(priv);\r\nif (err)\r\ngoto out_transceiver_disable;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\ndisable_irq(dev->irq);\r\nflexcan_write(priv->reg_ctrl_default, &regs->ctrl);\r\nflexcan_write(priv->reg_imask1_default, &regs->imask1);\r\nflexcan_write(priv->reg_imask2_default, &regs->imask2);\r\nenable_irq(dev->irq);\r\nnetdev_dbg(dev, "%s: reading mcr=0x%08x ctrl=0x%08x\n", __func__,\r\nflexcan_read(&regs->mcr), flexcan_read(&regs->ctrl));\r\nreturn 0;\r\nout_transceiver_disable:\r\nflexcan_transceiver_disable(priv);\r\nout_chip_disable:\r\nflexcan_chip_disable(priv);\r\nreturn err;\r\n}\r\nstatic void flexcan_chip_stop(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nflexcan_chip_freeze(priv);\r\nflexcan_chip_disable(priv);\r\nflexcan_write(0, &regs->imask2);\r\nflexcan_write(0, &regs->imask1);\r\nflexcan_write(priv->reg_ctrl_default & ~FLEXCAN_CTRL_ERR_ALL,\r\n&regs->ctrl);\r\nflexcan_transceiver_disable(priv);\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\nstatic int flexcan_open(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nint err;\r\nerr = clk_prepare_enable(priv->clk_ipg);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(priv->clk_per);\r\nif (err)\r\ngoto out_disable_ipg;\r\nerr = open_candev(dev);\r\nif (err)\r\ngoto out_disable_per;\r\nerr = request_irq(dev->irq, flexcan_irq, IRQF_SHARED, dev->name, dev);\r\nif (err)\r\ngoto out_close;\r\nerr = flexcan_chip_start(dev);\r\nif (err)\r\ngoto out_free_irq;\r\ncan_led_event(dev, CAN_LED_EVENT_OPEN);\r\ncan_rx_offload_enable(&priv->offload);\r\nnetif_start_queue(dev);\r\nreturn 0;\r\nout_free_irq:\r\nfree_irq(dev->irq, dev);\r\nout_close:\r\nclose_candev(dev);\r\nout_disable_per:\r\nclk_disable_unprepare(priv->clk_per);\r\nout_disable_ipg:\r\nclk_disable_unprepare(priv->clk_ipg);\r\nreturn err;\r\n}\r\nstatic int flexcan_close(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\ncan_rx_offload_disable(&priv->offload);\r\nflexcan_chip_stop(dev);\r\nfree_irq(dev->irq, dev);\r\nclk_disable_unprepare(priv->clk_per);\r\nclk_disable_unprepare(priv->clk_ipg);\r\nclose_candev(dev);\r\ncan_led_event(dev, CAN_LED_EVENT_STOP);\r\nreturn 0;\r\n}\r\nstatic int flexcan_set_mode(struct net_device *dev, enum can_mode mode)\r\n{\r\nint err;\r\nswitch (mode) {\r\ncase CAN_MODE_START:\r\nerr = flexcan_chip_start(dev);\r\nif (err)\r\nreturn err;\r\nnetif_wake_queue(dev);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int register_flexcandev(struct net_device *dev)\r\n{\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nstruct flexcan_regs __iomem *regs = priv->regs;\r\nu32 reg, err;\r\nerr = clk_prepare_enable(priv->clk_ipg);\r\nif (err)\r\nreturn err;\r\nerr = clk_prepare_enable(priv->clk_per);\r\nif (err)\r\ngoto out_disable_ipg;\r\nerr = flexcan_chip_disable(priv);\r\nif (err)\r\ngoto out_disable_per;\r\nreg = flexcan_read(&regs->ctrl);\r\nreg |= FLEXCAN_CTRL_CLK_SRC;\r\nflexcan_write(reg, &regs->ctrl);\r\nerr = flexcan_chip_enable(priv);\r\nif (err)\r\ngoto out_chip_disable;\r\nreg = flexcan_read(&regs->mcr);\r\nreg |= FLEXCAN_MCR_FRZ | FLEXCAN_MCR_HALT |\r\nFLEXCAN_MCR_FEN | FLEXCAN_MCR_SUPV;\r\nflexcan_write(reg, &regs->mcr);\r\nreg = flexcan_read(&regs->mcr);\r\nif (!(reg & FLEXCAN_MCR_FEN)) {\r\nnetdev_err(dev, "Could not enable RX FIFO, unsupported core\n");\r\nerr = -ENODEV;\r\ngoto out_chip_disable;\r\n}\r\nerr = register_candev(dev);\r\nout_chip_disable:\r\nflexcan_chip_disable(priv);\r\nout_disable_per:\r\nclk_disable_unprepare(priv->clk_per);\r\nout_disable_ipg:\r\nclk_disable_unprepare(priv->clk_ipg);\r\nreturn err;\r\n}\r\nstatic void unregister_flexcandev(struct net_device *dev)\r\n{\r\nunregister_candev(dev);\r\n}\r\nstatic int flexcan_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *of_id;\r\nconst struct flexcan_devtype_data *devtype_data;\r\nstruct net_device *dev;\r\nstruct flexcan_priv *priv;\r\nstruct regulator *reg_xceiver;\r\nstruct resource *mem;\r\nstruct clk *clk_ipg = NULL, *clk_per = NULL;\r\nstruct flexcan_regs __iomem *regs;\r\nint err, irq;\r\nu32 clock_freq = 0;\r\nreg_xceiver = devm_regulator_get(&pdev->dev, "xceiver");\r\nif (PTR_ERR(reg_xceiver) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nelse if (IS_ERR(reg_xceiver))\r\nreg_xceiver = NULL;\r\nif (pdev->dev.of_node)\r\nof_property_read_u32(pdev->dev.of_node,\r\n"clock-frequency", &clock_freq);\r\nif (!clock_freq) {\r\nclk_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(clk_ipg)) {\r\ndev_err(&pdev->dev, "no ipg clock defined\n");\r\nreturn PTR_ERR(clk_ipg);\r\n}\r\nclk_per = devm_clk_get(&pdev->dev, "per");\r\nif (IS_ERR(clk_per)) {\r\ndev_err(&pdev->dev, "no per clock defined\n");\r\nreturn PTR_ERR(clk_per);\r\n}\r\nclock_freq = clk_get_rate(clk_per);\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0)\r\nreturn -ENODEV;\r\nregs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nof_id = of_match_device(flexcan_of_match, &pdev->dev);\r\nif (of_id) {\r\ndevtype_data = of_id->data;\r\n} else if (platform_get_device_id(pdev)->driver_data) {\r\ndevtype_data = (struct flexcan_devtype_data *)\r\nplatform_get_device_id(pdev)->driver_data;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\ndev = alloc_candev(sizeof(struct flexcan_priv), 1);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, dev);\r\nSET_NETDEV_DEV(dev, &pdev->dev);\r\ndev->netdev_ops = &flexcan_netdev_ops;\r\ndev->irq = irq;\r\ndev->flags |= IFF_ECHO;\r\npriv = netdev_priv(dev);\r\npriv->can.clock.freq = clock_freq;\r\npriv->can.bittiming_const = &flexcan_bittiming_const;\r\npriv->can.do_set_mode = flexcan_set_mode;\r\npriv->can.do_get_berr_counter = flexcan_get_berr_counter;\r\npriv->can.ctrlmode_supported = CAN_CTRLMODE_LOOPBACK |\r\nCAN_CTRLMODE_LISTENONLY | CAN_CTRLMODE_3_SAMPLES |\r\nCAN_CTRLMODE_BERR_REPORTING;\r\npriv->regs = regs;\r\npriv->clk_ipg = clk_ipg;\r\npriv->clk_per = clk_per;\r\npriv->devtype_data = devtype_data;\r\npriv->reg_xceiver = reg_xceiver;\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\npriv->tx_mb_idx = FLEXCAN_TX_MB_OFF_TIMESTAMP;\r\npriv->tx_mb_reserved = &regs->mb[FLEXCAN_TX_MB_RESERVED_OFF_TIMESTAMP];\r\n} else {\r\npriv->tx_mb_idx = FLEXCAN_TX_MB_OFF_FIFO;\r\npriv->tx_mb_reserved = &regs->mb[FLEXCAN_TX_MB_RESERVED_OFF_FIFO];\r\n}\r\npriv->tx_mb = &regs->mb[priv->tx_mb_idx];\r\npriv->reg_imask1_default = FLEXCAN_IFLAG_MB(priv->tx_mb_idx);\r\npriv->reg_imask2_default = 0;\r\npriv->offload.mailbox_read = flexcan_mailbox_read;\r\nif (priv->devtype_data->quirks & FLEXCAN_QUIRK_USE_OFF_TIMESTAMP) {\r\nu64 imask;\r\npriv->offload.mb_first = FLEXCAN_RX_MB_OFF_TIMESTAMP_FIRST;\r\npriv->offload.mb_last = FLEXCAN_RX_MB_OFF_TIMESTAMP_LAST;\r\nimask = GENMASK_ULL(priv->offload.mb_last, priv->offload.mb_first);\r\npriv->reg_imask1_default |= imask;\r\npriv->reg_imask2_default |= imask >> 32;\r\nerr = can_rx_offload_add_timestamp(dev, &priv->offload);\r\n} else {\r\npriv->reg_imask1_default |= FLEXCAN_IFLAG_RX_FIFO_OVERFLOW |\r\nFLEXCAN_IFLAG_RX_FIFO_AVAILABLE;\r\nerr = can_rx_offload_add_fifo(dev, &priv->offload, FLEXCAN_NAPI_WEIGHT);\r\n}\r\nif (err)\r\ngoto failed_offload;\r\nerr = register_flexcandev(dev);\r\nif (err) {\r\ndev_err(&pdev->dev, "registering netdev failed\n");\r\ngoto failed_register;\r\n}\r\ndevm_can_led_init(dev);\r\ndev_info(&pdev->dev, "device registered (reg_base=%p, irq=%d)\n",\r\npriv->regs, dev->irq);\r\nreturn 0;\r\nfailed_offload:\r\nfailed_register:\r\nfree_candev(dev);\r\nreturn err;\r\n}\r\nstatic int flexcan_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nunregister_flexcandev(dev);\r\ncan_rx_offload_del(&priv->offload);\r\nfree_candev(dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused flexcan_suspend(struct device *device)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nint err;\r\nif (netif_running(dev)) {\r\nerr = flexcan_chip_disable(priv);\r\nif (err)\r\nreturn err;\r\nnetif_stop_queue(dev);\r\nnetif_device_detach(dev);\r\n}\r\npriv->can.state = CAN_STATE_SLEEPING;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused flexcan_resume(struct device *device)\r\n{\r\nstruct net_device *dev = dev_get_drvdata(device);\r\nstruct flexcan_priv *priv = netdev_priv(dev);\r\nint err;\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_running(dev)) {\r\nnetif_device_attach(dev);\r\nnetif_start_queue(dev);\r\nerr = flexcan_chip_enable(priv);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
