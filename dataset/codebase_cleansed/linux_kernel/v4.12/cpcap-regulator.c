static int cpcap_regulator_enable(struct regulator_dev *rdev)\r\n{\r\nstruct cpcap_regulator *regulator = rdev_get_drvdata(rdev);\r\nint error, ignore;\r\nerror = regulator_enable_regmap(rdev);\r\nif (error)\r\nreturn error;\r\nif (rdev->desc->enable_val & CPCAP_REG_OFF_MODE_SEC) {\r\nerror = regmap_update_bits(rdev->regmap, regulator->assign_reg,\r\nregulator->assign_mask,\r\nregulator->assign_mask);\r\nif (error)\r\nignore = regulator_disable_regmap(rdev);\r\n}\r\nreturn error;\r\n}\r\nstatic int cpcap_regulator_disable(struct regulator_dev *rdev)\r\n{\r\nstruct cpcap_regulator *regulator = rdev_get_drvdata(rdev);\r\nint error, ignore;\r\nif (rdev->desc->enable_val & CPCAP_REG_OFF_MODE_SEC) {\r\nerror = regmap_update_bits(rdev->regmap, regulator->assign_reg,\r\nregulator->assign_mask, 0);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = regulator_disable_regmap(rdev);\r\nif (error && (rdev->desc->enable_val & CPCAP_REG_OFF_MODE_SEC)) {\r\nignore = regmap_update_bits(rdev->regmap, regulator->assign_reg,\r\nregulator->assign_mask,\r\nregulator->assign_mask);\r\n}\r\nreturn error;\r\n}\r\nstatic unsigned int cpcap_regulator_get_mode(struct regulator_dev *rdev)\r\n{\r\nint value;\r\nregmap_read(rdev->regmap, rdev->desc->enable_reg, &value);\r\nif (!(value & CPCAP_BIT_AUDIO_LOW_PWR))\r\nreturn REGULATOR_MODE_STANDBY;\r\nreturn REGULATOR_MODE_NORMAL;\r\n}\r\nstatic int cpcap_regulator_set_mode(struct regulator_dev *rdev,\r\nunsigned int mode)\r\n{\r\nint value;\r\nswitch (mode) {\r\ncase REGULATOR_MODE_NORMAL:\r\nvalue = CPCAP_BIT_AUDIO_LOW_PWR;\r\nbreak;\r\ncase REGULATOR_MODE_STANDBY:\r\nvalue = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(rdev->regmap, rdev->desc->enable_reg,\r\nCPCAP_BIT_AUDIO_LOW_PWR, value);\r\n}\r\nstatic int cpcap_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct cpcap_ddata *ddata;\r\nconst struct of_device_id *match;\r\nstruct regulator_config config;\r\nstruct regulator_init_data init_data;\r\nint i;\r\nmatch = of_match_device(of_match_ptr(cpcap_regulator_id_table),\r\n&pdev->dev);\r\nif (!match)\r\nreturn -EINVAL;\r\nif (!match->data) {\r\ndev_err(&pdev->dev, "no configuration data found\n");\r\nreturn -ENODEV;\r\n}\r\nddata = devm_kzalloc(&pdev->dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nddata->reg = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!ddata->reg)\r\nreturn -ENODEV;\r\nddata->dev = &pdev->dev;\r\nddata->soc = match->data;\r\nplatform_set_drvdata(pdev, ddata);\r\nmemset(&config, 0, sizeof(config));\r\nmemset(&init_data, 0, sizeof(init_data));\r\nconfig.dev = &pdev->dev;\r\nconfig.regmap = ddata->reg;\r\nconfig.init_data = &init_data;\r\nfor (i = 0; i < CPCAP_NR_REGULATORS; i++) {\r\nconst struct cpcap_regulator *regulator = &ddata->soc[i];\r\nstruct regulator_dev *rdev;\r\nif (!regulator->rdesc.name)\r\nbreak;\r\nif (regulator->rdesc.volt_table == unknown_val_tbl)\r\ncontinue;\r\nconfig.driver_data = (void *)regulator;\r\nrdev = devm_regulator_register(&pdev->dev,\r\n&regulator->rdesc,\r\n&config);\r\nif (IS_ERR(rdev)) {\r\ndev_err(&pdev->dev, "failed to register regulator %s\n",\r\nregulator->rdesc.name);\r\nreturn PTR_ERR(rdev);\r\n}\r\n}\r\nreturn 0;\r\n}
