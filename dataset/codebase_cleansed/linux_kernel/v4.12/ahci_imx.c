static int imx_phy_crbit_assert(void __iomem *mmio, u32 bit, bool assert)\r\n{\r\nint timeout = 10;\r\nu32 crval;\r\nu32 srval;\r\ncrval = readl(mmio + IMX_P0PHYCR);\r\nif (assert)\r\ncrval |= bit;\r\nelse\r\ncrval &= ~bit;\r\nwritel(crval, mmio + IMX_P0PHYCR);\r\ndo {\r\nsrval = readl(mmio + IMX_P0PHYSR);\r\nif ((assert ? srval : ~srval) & IMX_P0PHYSR_CR_ACK)\r\nbreak;\r\nusleep_range(100, 200);\r\n} while (--timeout);\r\nreturn timeout ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int imx_phy_reg_addressing(u16 addr, void __iomem *mmio)\r\n{\r\nu32 crval = addr;\r\nint ret;\r\nwritel(crval, mmio + IMX_P0PHYCR);\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_ADDR, true);\r\nif (ret)\r\nreturn ret;\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_ADDR, false);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int imx_phy_reg_write(u16 val, void __iomem *mmio)\r\n{\r\nu32 crval = val;\r\nint ret;\r\nwritel(crval, mmio + IMX_P0PHYCR);\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_DATA, true);\r\nif (ret)\r\nreturn ret;\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_CAP_DATA, false);\r\nif (ret)\r\nreturn ret;\r\nif (val & IMX_CLOCK_RESET_RESET) {\r\ncrval |= IMX_P0PHYCR_CR_WRITE;\r\nwritel(crval, mmio + IMX_P0PHYCR);\r\ngoto out;\r\n}\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_WRITE, true);\r\nif (ret)\r\nreturn ret;\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_WRITE, false);\r\nif (ret)\r\nreturn ret;\r\nout:\r\nreturn 0;\r\n}\r\nstatic int imx_phy_reg_read(u16 *val, void __iomem *mmio)\r\n{\r\nint ret;\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_READ, true);\r\nif (ret)\r\nreturn ret;\r\n*val = readl(mmio + IMX_P0PHYSR) & IMX_P0PHYSR_CR_DATA_OUT;\r\nret = imx_phy_crbit_assert(mmio, IMX_P0PHYCR_CR_READ, false);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic int imx_sata_phy_reset(struct ahci_host_priv *hpriv)\r\n{\r\nvoid __iomem *mmio = hpriv->mmio;\r\nint timeout = 10;\r\nu16 val;\r\nint ret;\r\nret = imx_phy_reg_addressing(IMX_CLOCK_RESET, mmio);\r\nif (ret)\r\nreturn ret;\r\nret = imx_phy_reg_write(IMX_CLOCK_RESET_RESET, mmio);\r\nif (ret)\r\nreturn ret;\r\ndo {\r\nusleep_range(100, 200);\r\nret = imx_phy_reg_addressing(IMX_LANE0_OUT_STAT, mmio);\r\nif (ret)\r\nreturn ret;\r\nret = imx_phy_reg_read(&val, mmio);\r\nif (ret)\r\nreturn ret;\r\nif (val & IMX_LANE0_OUT_STAT_RX_PLL_STATE)\r\nbreak;\r\n} while (--timeout);\r\nreturn timeout ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int read_adc_sum(void *dev, u16 rtune_ctl_reg, void __iomem * mmio)\r\n{\r\nu16 adc_out_reg, read_sum;\r\nu32 index, read_attempt;\r\nconst u32 attempt_limit = 100;\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_RTUNE_CTL, mmio);\r\nimx_phy_reg_write(rtune_ctl_reg, mmio);\r\nindex = 0;\r\nread_attempt = 0;\r\nadc_out_reg = 0;\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_ADC_OUT, mmio);\r\nwhile (index < 2) {\r\nimx_phy_reg_read(&adc_out_reg, mmio);\r\nif (adc_out_reg & 0x400)\r\nindex++;\r\nread_attempt++;\r\nif (read_attempt > attempt_limit) {\r\ndev_err(dev, "Read REG more than %d times!\n",\r\nattempt_limit);\r\nbreak;\r\n}\r\n}\r\nindex = 0;\r\nread_attempt = 0;\r\nread_sum = 0;\r\nwhile (index < 80) {\r\nimx_phy_reg_read(&adc_out_reg, mmio);\r\nif (adc_out_reg & 0x400) {\r\nread_sum = read_sum + (adc_out_reg & 0x3FF);\r\nindex++;\r\n}\r\nread_attempt++;\r\nif (read_attempt > attempt_limit) {\r\ndev_err(dev, "Read REG more than %d times!\n",\r\nattempt_limit);\r\nbreak;\r\n}\r\n}\r\nreturn (read_sum * 1000) / 80;\r\n}\r\nstatic int sata_ahci_read_temperature(void *dev, int *temp)\r\n{\r\nu16 mpll_test_reg, rtune_ctl_reg, dac_ctl_reg, read_sum;\r\nu32 str1, str2, str3, str4;\r\nint m1, m2, a;\r\nstruct ahci_host_priv *hpriv = dev_get_drvdata(dev);\r\nvoid __iomem *mmio = hpriv->mmio;\r\nread_sum = 0;\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT, mmio);\r\nimx_phy_reg_write(read_sum, mmio);\r\nimx_phy_reg_read(&read_sum, mmio);\r\nif ((read_sum & 0xffff) != 0)\r\ndev_err(dev, "Read/Write REG error, 0x%x!\n", read_sum);\r\nimx_phy_reg_write(0x5A5A, mmio);\r\nimx_phy_reg_read(&read_sum, mmio);\r\nif ((read_sum & 0xffff) != 0x5A5A)\r\ndev_err(dev, "Read/Write REG error, 0x%x!\n", read_sum);\r\nimx_phy_reg_write(0x1234, mmio);\r\nimx_phy_reg_read(&read_sum, mmio);\r\nif ((read_sum & 0xffff) != 0x1234)\r\ndev_err(dev, "Read/Write REG error, 0x%x!\n", read_sum);\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_MPLL_TST, mmio);\r\nimx_phy_reg_read(&mpll_test_reg, mmio);\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_RTUNE_CTL, mmio);\r\nimx_phy_reg_read(&rtune_ctl_reg, mmio);\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_DAC_CTL, mmio);\r\nimx_phy_reg_read(&dac_ctl_reg, mmio);\r\nstr1 = (mpll_test_reg >> 2) & 0x7FF;\r\nstr2 = (rtune_ctl_reg) & 0x3;\r\nstr3 = (dac_ctl_reg >> 12) & 0x7;\r\nstr4 = (rtune_ctl_reg >> 4);\r\nmpll_test_reg = (mpll_test_reg & 0xE03) | (512) << 2;\r\nrtune_ctl_reg = (rtune_ctl_reg & 0xFFC) | (1);\r\ndac_ctl_reg = (dac_ctl_reg & 0x8FF) | (4) << 12;\r\nrtune_ctl_reg = (rtune_ctl_reg & 0xFEF) | (0) << 4;\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_MPLL_TST, mmio);\r\nimx_phy_reg_write(mpll_test_reg, mmio);\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_DAC_CTL, mmio);\r\nimx_phy_reg_write(dac_ctl_reg, mmio);\r\nm1 = read_adc_sum(dev, rtune_ctl_reg, mmio);\r\nrtune_ctl_reg = (rtune_ctl_reg & 0xFEF) | (1) << 4;\r\nm2 = read_adc_sum(dev, rtune_ctl_reg, mmio);\r\nmpll_test_reg = (mpll_test_reg & 0xE03) | (str1) << 2;\r\nrtune_ctl_reg = (rtune_ctl_reg & 0xFFC) | (str2);\r\ndac_ctl_reg = (dac_ctl_reg & 0x8FF) | (str3) << 12;\r\nrtune_ctl_reg = (rtune_ctl_reg & 0xFEF) | (str4) << 4;\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_MPLL_TST, mmio);\r\nimx_phy_reg_write(mpll_test_reg, mmio);\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_DAC_CTL, mmio);\r\nimx_phy_reg_write(dac_ctl_reg, mmio);\r\nimx_phy_reg_addressing(SATA_PHY_CR_CLOCK_RTUNE_CTL, mmio);\r\nimx_phy_reg_write(rtune_ctl_reg, mmio);\r\nif (!(m2 / 1000))\r\nm2 = 1000;\r\na = (m2 - m1) / (m2/1000);\r\n*temp = ((-559) * a * a) / 1000 + (1379) * a + (-458000);\r\nreturn 0;\r\n}\r\nstatic ssize_t sata_ahci_show_temp(struct device *dev,\r\nstruct device_attribute *da,\r\nchar *buf)\r\n{\r\nunsigned int temp = 0;\r\nint err;\r\nerr = sata_ahci_read_temperature(dev, &temp);\r\nif (err < 0)\r\nreturn err;\r\nreturn sprintf(buf, "%u\n", temp);\r\n}\r\nstatic int imx_sata_enable(struct ahci_host_priv *hpriv)\r\n{\r\nstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\r\nstruct device *dev = &imxpriv->ahci_pdev->dev;\r\nint ret;\r\nif (imxpriv->no_device)\r\nreturn 0;\r\nret = ahci_platform_enable_regulators(hpriv);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(imxpriv->sata_ref_clk);\r\nif (ret < 0)\r\ngoto disable_regulator;\r\nif (imxpriv->type == AHCI_IMX6Q) {\r\nregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\r\nIMX6Q_GPR13_SATA_RX_EQ_VAL_MASK |\r\nIMX6Q_GPR13_SATA_RX_LOS_LVL_MASK |\r\nIMX6Q_GPR13_SATA_RX_DPLL_MODE_MASK |\r\nIMX6Q_GPR13_SATA_SPD_MODE_MASK |\r\nIMX6Q_GPR13_SATA_MPLL_SS_EN |\r\nIMX6Q_GPR13_SATA_TX_ATTEN_MASK |\r\nIMX6Q_GPR13_SATA_TX_BOOST_MASK |\r\nIMX6Q_GPR13_SATA_TX_LVL_MASK |\r\nIMX6Q_GPR13_SATA_MPLL_CLK_EN |\r\nIMX6Q_GPR13_SATA_TX_EDGE_RATE,\r\nimxpriv->phy_params);\r\nregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\r\nIMX6Q_GPR13_SATA_MPLL_CLK_EN,\r\nIMX6Q_GPR13_SATA_MPLL_CLK_EN);\r\nusleep_range(100, 200);\r\nret = imx_sata_phy_reset(hpriv);\r\nif (ret) {\r\ndev_err(dev, "failed to reset phy: %d\n", ret);\r\ngoto disable_clk;\r\n}\r\n}\r\nusleep_range(1000, 2000);\r\nreturn 0;\r\ndisable_clk:\r\nclk_disable_unprepare(imxpriv->sata_ref_clk);\r\ndisable_regulator:\r\nahci_platform_disable_regulators(hpriv);\r\nreturn ret;\r\n}\r\nstatic void imx_sata_disable(struct ahci_host_priv *hpriv)\r\n{\r\nstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\r\nif (imxpriv->no_device)\r\nreturn;\r\nif (imxpriv->type == AHCI_IMX6Q) {\r\nregmap_update_bits(imxpriv->gpr, IOMUXC_GPR13,\r\nIMX6Q_GPR13_SATA_MPLL_CLK_EN,\r\n!IMX6Q_GPR13_SATA_MPLL_CLK_EN);\r\n}\r\nclk_disable_unprepare(imxpriv->sata_ref_clk);\r\nahci_platform_disable_regulators(hpriv);\r\n}\r\nstatic void ahci_imx_error_handler(struct ata_port *ap)\r\n{\r\nu32 reg_val;\r\nstruct ata_device *dev;\r\nstruct ata_host *host = dev_get_drvdata(ap->dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nvoid __iomem *mmio = hpriv->mmio;\r\nstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\r\nahci_error_handler(ap);\r\nif (!(imxpriv->first_time) || ahci_imx_hotplug)\r\nreturn;\r\nimxpriv->first_time = false;\r\nata_for_each_dev(dev, &ap->link, ENABLED)\r\nreturn;\r\nreg_val = readl(mmio + IMX_P0PHYCR);\r\nwritel(reg_val | IMX_P0PHYCR_TEST_PDDQ, mmio + IMX_P0PHYCR);\r\nimx_sata_disable(hpriv);\r\nimxpriv->no_device = true;\r\ndev_info(ap->dev, "no device found, disabling link.\n");\r\ndev_info(ap->dev, "pass " MODULE_PARAM_PREFIX ".hotplug=1 to enable hotplug\n");\r\n}\r\nstatic int ahci_imx_softreset(struct ata_link *link, unsigned int *class,\r\nunsigned long deadline)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct ata_host *host = dev_get_drvdata(ap->dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\r\nint ret = -EIO;\r\nif (imxpriv->type == AHCI_IMX53)\r\nret = ahci_pmp_retry_srst_ops.softreset(link, class, deadline);\r\nelse if (imxpriv->type == AHCI_IMX6Q)\r\nret = ahci_ops.softreset(link, class, deadline);\r\nreturn ret;\r\n}\r\nstatic u32 imx_ahci_parse_props(struct device *dev,\r\nconst struct reg_property *prop, size_t num)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 reg_value = 0;\r\nint i, j;\r\nfor (i = 0; i < num; i++, prop++) {\r\nu32 of_val;\r\nif (prop->num_values == 0) {\r\nif (of_property_read_bool(np, prop->name))\r\nreg_value |= prop->set_value;\r\nelse\r\nreg_value |= prop->def_value;\r\ncontinue;\r\n}\r\nif (of_property_read_u32(np, prop->name, &of_val)) {\r\ndev_info(dev, "%s not specified, using %08x\n",\r\nprop->name, prop->def_value);\r\nreg_value |= prop->def_value;\r\ncontinue;\r\n}\r\nfor (j = 0; j < prop->num_values; j++) {\r\nif (prop->values[j].of_value == of_val) {\r\ndev_info(dev, "%s value %u, using %08x\n",\r\nprop->name, of_val, prop->values[j].reg_value);\r\nreg_value |= prop->values[j].reg_value;\r\nbreak;\r\n}\r\n}\r\nif (j == prop->num_values) {\r\ndev_err(dev, "DT property %s is not a valid value\n",\r\nprop->name);\r\nreg_value |= prop->def_value;\r\n}\r\n}\r\nreturn reg_value;\r\n}\r\nstatic int imx_ahci_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct ahci_host_priv *hpriv;\r\nstruct imx_ahci_priv *imxpriv;\r\nunsigned int reg_val;\r\nint ret;\r\nof_id = of_match_device(imx_ahci_of_match, dev);\r\nif (!of_id)\r\nreturn -EINVAL;\r\nimxpriv = devm_kzalloc(dev, sizeof(*imxpriv), GFP_KERNEL);\r\nif (!imxpriv)\r\nreturn -ENOMEM;\r\nimxpriv->ahci_pdev = pdev;\r\nimxpriv->no_device = false;\r\nimxpriv->first_time = true;\r\nimxpriv->type = (enum ahci_imx_type)of_id->data;\r\nimxpriv->sata_clk = devm_clk_get(dev, "sata");\r\nif (IS_ERR(imxpriv->sata_clk)) {\r\ndev_err(dev, "can't get sata clock.\n");\r\nreturn PTR_ERR(imxpriv->sata_clk);\r\n}\r\nimxpriv->sata_ref_clk = devm_clk_get(dev, "sata_ref");\r\nif (IS_ERR(imxpriv->sata_ref_clk)) {\r\ndev_err(dev, "can't get sata_ref clock.\n");\r\nreturn PTR_ERR(imxpriv->sata_ref_clk);\r\n}\r\nimxpriv->ahb_clk = devm_clk_get(dev, "ahb");\r\nif (IS_ERR(imxpriv->ahb_clk)) {\r\ndev_err(dev, "can't get ahb clock.\n");\r\nreturn PTR_ERR(imxpriv->ahb_clk);\r\n}\r\nif (imxpriv->type == AHCI_IMX6Q) {\r\nu32 reg_value;\r\nimxpriv->gpr = syscon_regmap_lookup_by_compatible(\r\n"fsl,imx6q-iomuxc-gpr");\r\nif (IS_ERR(imxpriv->gpr)) {\r\ndev_err(dev,\r\n"failed to find fsl,imx6q-iomux-gpr regmap\n");\r\nreturn PTR_ERR(imxpriv->gpr);\r\n}\r\nreg_value = imx_ahci_parse_props(dev, gpr13_props,\r\nARRAY_SIZE(gpr13_props));\r\nimxpriv->phy_params =\r\nIMX6Q_GPR13_SATA_RX_LOS_LVL_SATA2M |\r\nIMX6Q_GPR13_SATA_RX_DPLL_MODE_2P_4F |\r\nIMX6Q_GPR13_SATA_SPD_MODE_3P0G |\r\nreg_value;\r\n}\r\nhpriv = ahci_platform_get_resources(pdev);\r\nif (IS_ERR(hpriv))\r\nreturn PTR_ERR(hpriv);\r\nhpriv->plat_data = imxpriv;\r\nret = clk_prepare_enable(imxpriv->sata_clk);\r\nif (ret)\r\nreturn ret;\r\nif (imxpriv->type == AHCI_IMX53 &&\r\nIS_ENABLED(CONFIG_HWMON)) {\r\nstruct device *hwmon_dev;\r\nhwmon_dev =\r\ndevm_hwmon_device_register_with_groups(dev,\r\n"sata_ahci",\r\nhpriv,\r\nfsl_sata_ahci_groups);\r\nif (IS_ERR(hwmon_dev)) {\r\nret = PTR_ERR(hwmon_dev);\r\ngoto disable_clk;\r\n}\r\ndevm_thermal_zone_of_sensor_register(hwmon_dev, 0, hwmon_dev,\r\n&fsl_sata_ahci_of_thermal_ops);\r\ndev_info(dev, "%s: sensor 'sata_ahci'\n", dev_name(hwmon_dev));\r\n}\r\nret = imx_sata_enable(hpriv);\r\nif (ret)\r\ngoto disable_clk;\r\nreg_val = readl(hpriv->mmio + HOST_CAP);\r\nif (!(reg_val & HOST_CAP_SSS)) {\r\nreg_val |= HOST_CAP_SSS;\r\nwritel(reg_val, hpriv->mmio + HOST_CAP);\r\n}\r\nreg_val = readl(hpriv->mmio + HOST_PORTS_IMPL);\r\nif (!(reg_val & 0x1)) {\r\nreg_val |= 0x1;\r\nwritel(reg_val, hpriv->mmio + HOST_PORTS_IMPL);\r\n}\r\nreg_val = clk_get_rate(imxpriv->ahb_clk) / 1000;\r\nwritel(reg_val, hpriv->mmio + IMX_TIMER1MS);\r\nret = ahci_platform_init_host(pdev, hpriv, &ahci_imx_port_info,\r\n&ahci_platform_sht);\r\nif (ret)\r\ngoto disable_sata;\r\nreturn 0;\r\ndisable_sata:\r\nimx_sata_disable(hpriv);\r\ndisable_clk:\r\nclk_disable_unprepare(imxpriv->sata_clk);\r\nreturn ret;\r\n}\r\nstatic void ahci_imx_host_stop(struct ata_host *host)\r\n{\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nstruct imx_ahci_priv *imxpriv = hpriv->plat_data;\r\nimx_sata_disable(hpriv);\r\nclk_disable_unprepare(imxpriv->sata_clk);\r\n}\r\nstatic int imx_ahci_suspend(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nint ret;\r\nret = ahci_platform_suspend_host(dev);\r\nif (ret)\r\nreturn ret;\r\nimx_sata_disable(hpriv);\r\nreturn 0;\r\n}\r\nstatic int imx_ahci_resume(struct device *dev)\r\n{\r\nstruct ata_host *host = dev_get_drvdata(dev);\r\nstruct ahci_host_priv *hpriv = host->private_data;\r\nint ret;\r\nret = imx_sata_enable(hpriv);\r\nif (ret)\r\nreturn ret;\r\nreturn ahci_platform_resume_host(dev);\r\n}
