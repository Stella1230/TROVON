int xfrm4_extract_input(struct xfrm_state *x, struct sk_buff *skb)\r\n{\r\nreturn xfrm4_extract_header(skb);\r\n}\r\nstatic inline int xfrm4_rcv_encap_finish(struct net *net, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nif (!skb_dst(skb)) {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nif (ip_route_input_noref(skb, iph->daddr, iph->saddr,\r\niph->tos, skb->dev))\r\ngoto drop;\r\n}\r\nreturn dst_input(skb);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nint xfrm4_transport_finish(struct sk_buff *skb, int async)\r\n{\r\nstruct xfrm_offload *xo = xfrm_offload(skb);\r\nstruct iphdr *iph = ip_hdr(skb);\r\niph->protocol = XFRM_MODE_SKB_CB(skb)->protocol;\r\n#ifndef CONFIG_NETFILTER\r\nif (!async)\r\nreturn -iph->protocol;\r\n#endif\r\n__skb_push(skb, skb->data - skb_network_header(skb));\r\niph->tot_len = htons(skb->len);\r\nip_send_check(iph);\r\nif (xo && (xo->flags & XFRM_GRO)) {\r\nskb_mac_header_rebuild(skb);\r\nreturn 0;\r\n}\r\nNF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,\r\ndev_net(skb->dev), NULL, skb, skb->dev, NULL,\r\nxfrm4_rcv_encap_finish);\r\nreturn 0;\r\n}\r\nint xfrm4_udp_encap_rcv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct udp_sock *up = udp_sk(sk);\r\nstruct udphdr *uh;\r\nstruct iphdr *iph;\r\nint iphlen, len;\r\n__u8 *udpdata;\r\n__be32 *udpdata32;\r\n__u16 encap_type = up->encap_type;\r\nif (!encap_type)\r\nreturn 1;\r\nlen = skb->len - sizeof(struct udphdr);\r\nif (!pskb_may_pull(skb, sizeof(struct udphdr) + min(len, 8)))\r\nreturn 1;\r\nuh = udp_hdr(skb);\r\nudpdata = (__u8 *)uh + sizeof(struct udphdr);\r\nudpdata32 = (__be32 *)udpdata;\r\nswitch (encap_type) {\r\ndefault:\r\ncase UDP_ENCAP_ESPINUDP:\r\nif (len == 1 && udpdata[0] == 0xff) {\r\ngoto drop;\r\n} else if (len > sizeof(struct ip_esp_hdr) && udpdata32[0] != 0) {\r\nlen = sizeof(struct udphdr);\r\n} else\r\nreturn 1;\r\nbreak;\r\ncase UDP_ENCAP_ESPINUDP_NON_IKE:\r\nif (len == 1 && udpdata[0] == 0xff) {\r\ngoto drop;\r\n} else if (len > 2 * sizeof(u32) + sizeof(struct ip_esp_hdr) &&\r\nudpdata32[0] == 0 && udpdata32[1] == 0) {\r\nlen = sizeof(struct udphdr) + 2 * sizeof(u32);\r\n} else\r\nreturn 1;\r\nbreak;\r\n}\r\nif (skb_unclone(skb, GFP_ATOMIC))\r\ngoto drop;\r\niph = ip_hdr(skb);\r\niphlen = iph->ihl << 2;\r\niph->tot_len = htons(ntohs(iph->tot_len) - len);\r\nif (skb->len < iphlen + len) {\r\ngoto drop;\r\n}\r\n__skb_pull(skb, len);\r\nskb_reset_transport_header(skb);\r\nreturn xfrm4_rcv_encap(skb, IPPROTO_ESP, 0, encap_type);\r\ndrop:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nint xfrm4_rcv(struct sk_buff *skb)\r\n{\r\nreturn xfrm4_rcv_spi(skb, ip_hdr(skb)->protocol, 0);\r\n}
