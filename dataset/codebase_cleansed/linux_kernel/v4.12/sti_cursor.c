static void cursor_dbg_vpo(struct seq_file *s, u32 val)\r\n{\r\nseq_printf(s, "\txdo:%4d\tydo:%4d", val & 0x0FFF, (val >> 16) & 0x0FFF);\r\n}\r\nstatic void cursor_dbg_size(struct seq_file *s, u32 val)\r\n{\r\nseq_printf(s, "\t%d x %d", val & 0x07FF, (val >> 16) & 0x07FF);\r\n}\r\nstatic void cursor_dbg_pml(struct seq_file *s,\r\nstruct sti_cursor *cursor, u32 val)\r\n{\r\nif (cursor->pixmap.paddr == val)\r\nseq_printf(s, "\tVirt @: %p", cursor->pixmap.base);\r\n}\r\nstatic void cursor_dbg_cml(struct seq_file *s,\r\nstruct sti_cursor *cursor, u32 val)\r\n{\r\nif (cursor->clut_paddr == val)\r\nseq_printf(s, "\tVirt @: %p", cursor->clut);\r\n}\r\nstatic int cursor_dbg_show(struct seq_file *s, void *data)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct sti_cursor *cursor = (struct sti_cursor *)node->info_ent->data;\r\nseq_printf(s, "%s: (vaddr = 0x%p)",\r\nsti_plane_to_str(&cursor->plane), cursor->regs);\r\nDBGFS_DUMP(CUR_CTL);\r\nDBGFS_DUMP(CUR_VPO);\r\ncursor_dbg_vpo(s, readl(cursor->regs + CUR_VPO));\r\nDBGFS_DUMP(CUR_PML);\r\ncursor_dbg_pml(s, cursor, readl(cursor->regs + CUR_PML));\r\nDBGFS_DUMP(CUR_PMP);\r\nDBGFS_DUMP(CUR_SIZE);\r\ncursor_dbg_size(s, readl(cursor->regs + CUR_SIZE));\r\nDBGFS_DUMP(CUR_CML);\r\ncursor_dbg_cml(s, cursor, readl(cursor->regs + CUR_CML));\r\nDBGFS_DUMP(CUR_AWS);\r\nDBGFS_DUMP(CUR_AWE);\r\nseq_puts(s, "\n");\r\nreturn 0;\r\n}\r\nstatic int cursor_debugfs_init(struct sti_cursor *cursor,\r\nstruct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(cursor_debugfs_files); i++)\r\ncursor_debugfs_files[i].data = cursor;\r\nreturn drm_debugfs_create_files(cursor_debugfs_files,\r\nARRAY_SIZE(cursor_debugfs_files),\r\nminor->debugfs_root, minor);\r\n}\r\nstatic void sti_cursor_argb8888_to_clut8(struct sti_cursor *cursor, u32 *src)\r\n{\r\nu8 *dst = cursor->pixmap.base;\r\nunsigned int i, j;\r\nu32 a, r, g, b;\r\nfor (i = 0; i < cursor->height; i++) {\r\nfor (j = 0; j < cursor->width; j++) {\r\na = (*src >> 30) & 3;\r\nr = (*src >> 22) & 3;\r\ng = (*src >> 14) & 3;\r\nb = (*src >> 6) & 3;\r\n*dst = a << 6 | r << 4 | g << 2 | b;\r\nsrc++;\r\ndst++;\r\n}\r\n}\r\n}\r\nstatic void sti_cursor_init(struct sti_cursor *cursor)\r\n{\r\nunsigned short *base = cursor->clut;\r\nunsigned int a, r, g, b;\r\nfor (a = 0; a < 4; a++)\r\nfor (r = 0; r < 4; r++)\r\nfor (g = 0; g < 4; g++)\r\nfor (b = 0; b < 4; b++)\r\n*base++ = (a * 5) << 12 |\r\n(r * 5) << 8 |\r\n(g * 5) << 4 |\r\n(b * 5);\r\n}\r\nstatic int sti_cursor_atomic_check(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_cursor *cursor = to_sti_cursor(plane);\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_display_mode *mode;\r\nint dst_x, dst_y, dst_w, dst_h;\r\nint src_w, src_h;\r\nif (!crtc || !fb)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_crtc_state(state->state, crtc);\r\nmode = &crtc_state->mode;\r\ndst_x = state->crtc_x;\r\ndst_y = state->crtc_y;\r\ndst_w = clamp_val(state->crtc_w, 0, mode->crtc_hdisplay - dst_x);\r\ndst_h = clamp_val(state->crtc_h, 0, mode->crtc_vdisplay - dst_y);\r\nsrc_w = state->src_w >> 16;\r\nsrc_h = state->src_h >> 16;\r\nif (src_w < STI_CURS_MIN_SIZE ||\r\nsrc_h < STI_CURS_MIN_SIZE ||\r\nsrc_w > STI_CURS_MAX_SIZE ||\r\nsrc_h > STI_CURS_MAX_SIZE) {\r\nDRM_ERROR("Invalid cursor size (%dx%d)\n",\r\nsrc_w, src_h);\r\nreturn -EINVAL;\r\n}\r\nif (!cursor->pixmap.base ||\r\n(cursor->width != src_w) ||\r\n(cursor->height != src_h)) {\r\ncursor->width = src_w;\r\ncursor->height = src_h;\r\nif (cursor->pixmap.base)\r\ndma_free_wc(cursor->dev, cursor->pixmap.size,\r\ncursor->pixmap.base, cursor->pixmap.paddr);\r\ncursor->pixmap.size = cursor->width * cursor->height;\r\ncursor->pixmap.base = dma_alloc_wc(cursor->dev,\r\ncursor->pixmap.size,\r\n&cursor->pixmap.paddr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!cursor->pixmap.base) {\r\nDRM_ERROR("Failed to allocate memory for pixmap\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!drm_fb_cma_get_gem_obj(fb, 0)) {\r\nDRM_ERROR("Can't get CMA GEM object for fb\n");\r\nreturn -EINVAL;\r\n}\r\nDRM_DEBUG_KMS("CRTC:%d (%s) drm plane:%d (%s)\n",\r\ncrtc->base.id, sti_mixer_to_str(to_sti_mixer(crtc)),\r\ndrm_plane->base.id, sti_plane_to_str(plane));\r\nDRM_DEBUG_KMS("(%dx%d)@(%d,%d)\n", dst_w, dst_h, dst_x, dst_y);\r\nreturn 0;\r\n}\r\nstatic void sti_cursor_atomic_update(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *oldstate)\r\n{\r\nstruct drm_plane_state *state = drm_plane->state;\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_cursor *cursor = to_sti_cursor(plane);\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_display_mode *mode;\r\nint dst_x, dst_y;\r\nstruct drm_gem_cma_object *cma_obj;\r\nu32 y, x;\r\nu32 val;\r\nif (!crtc || !fb)\r\nreturn;\r\nmode = &crtc->mode;\r\ndst_x = state->crtc_x;\r\ndst_y = state->crtc_y;\r\ncma_obj = drm_fb_cma_get_gem_obj(fb, 0);\r\nsti_cursor_argb8888_to_clut8(cursor, (u32 *)cma_obj->vaddr);\r\ny = sti_vtg_get_line_number(*mode, 0);\r\nx = sti_vtg_get_pixel_number(*mode, 0);\r\nval = y << 16 | x;\r\nwritel(val, cursor->regs + CUR_AWS);\r\ny = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nx = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nval = y << 16 | x;\r\nwritel(val, cursor->regs + CUR_AWE);\r\nwritel(cursor->pixmap.paddr, cursor->regs + CUR_PML);\r\nwritel(cursor->width, cursor->regs + CUR_PMP);\r\nwritel(cursor->height << 16 | cursor->width, cursor->regs + CUR_SIZE);\r\ny = sti_vtg_get_line_number(*mode, dst_y);\r\nx = sti_vtg_get_pixel_number(*mode, dst_x);\r\nwritel((y << 16) | x, cursor->regs + CUR_VPO);\r\nwritel(cursor->clut_paddr, cursor->regs + CUR_CML);\r\nwritel(CUR_CTL_CLUT_UPDATE, cursor->regs + CUR_CTL);\r\nsti_plane_update_fps(plane, true, false);\r\nplane->status = STI_PLANE_UPDATED;\r\n}\r\nstatic void sti_cursor_atomic_disable(struct drm_plane *drm_plane,\r\nstruct drm_plane_state *oldstate)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nif (!oldstate->crtc) {\r\nDRM_DEBUG_DRIVER("drm plane:%d not enabled\n",\r\ndrm_plane->base.id);\r\nreturn;\r\n}\r\nDRM_DEBUG_DRIVER("CRTC:%d (%s) drm plane:%d (%s)\n",\r\noldstate->crtc->base.id,\r\nsti_mixer_to_str(to_sti_mixer(oldstate->crtc)),\r\ndrm_plane->base.id, sti_plane_to_str(plane));\r\nplane->status = STI_PLANE_DISABLING;\r\n}\r\nstatic void sti_cursor_destroy(struct drm_plane *drm_plane)\r\n{\r\nDRM_DEBUG_DRIVER("\n");\r\ndrm_plane_helper_disable(drm_plane);\r\ndrm_plane_cleanup(drm_plane);\r\n}\r\nstatic int sti_cursor_late_register(struct drm_plane *drm_plane)\r\n{\r\nstruct sti_plane *plane = to_sti_plane(drm_plane);\r\nstruct sti_cursor *cursor = to_sti_cursor(plane);\r\nreturn cursor_debugfs_init(cursor, drm_plane->dev->primary);\r\n}\r\nstruct drm_plane *sti_cursor_create(struct drm_device *drm_dev,\r\nstruct device *dev, int desc,\r\nvoid __iomem *baseaddr,\r\nunsigned int possible_crtcs)\r\n{\r\nstruct sti_cursor *cursor;\r\nsize_t size;\r\nint res;\r\ncursor = devm_kzalloc(dev, sizeof(*cursor), GFP_KERNEL);\r\nif (!cursor) {\r\nDRM_ERROR("Failed to allocate memory for cursor\n");\r\nreturn NULL;\r\n}\r\nsize = 0x100 * sizeof(unsigned short);\r\ncursor->clut = dma_alloc_wc(dev, size, &cursor->clut_paddr,\r\nGFP_KERNEL | GFP_DMA);\r\nif (!cursor->clut) {\r\nDRM_ERROR("Failed to allocate memory for cursor clut\n");\r\ngoto err_clut;\r\n}\r\ncursor->dev = dev;\r\ncursor->regs = baseaddr;\r\ncursor->plane.desc = desc;\r\ncursor->plane.status = STI_PLANE_DISABLED;\r\nsti_cursor_init(cursor);\r\nres = drm_universal_plane_init(drm_dev, &cursor->plane.drm_plane,\r\npossible_crtcs,\r\n&sti_cursor_plane_helpers_funcs,\r\ncursor_supported_formats,\r\nARRAY_SIZE(cursor_supported_formats),\r\nDRM_PLANE_TYPE_CURSOR, NULL);\r\nif (res) {\r\nDRM_ERROR("Failed to initialize universal plane\n");\r\ngoto err_plane;\r\n}\r\ndrm_plane_helper_add(&cursor->plane.drm_plane,\r\n&sti_cursor_helpers_funcs);\r\nsti_plane_init_property(&cursor->plane, DRM_PLANE_TYPE_CURSOR);\r\nreturn &cursor->plane.drm_plane;\r\nerr_plane:\r\ndma_free_wc(dev, size, cursor->clut, cursor->clut_paddr);\r\nerr_clut:\r\ndevm_kfree(dev, cursor);\r\nreturn NULL;\r\n}
