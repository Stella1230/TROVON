unsigned ef4_mdio_id_oui(u32 id)\r\n{\r\nunsigned oui = 0;\r\nint i;\r\nfor (i = 0; i < 22; ++i)\r\nif (id & (1 << (i + 10)))\r\noui |= 1 << (i ^ 7);\r\nreturn oui;\r\n}\r\nint ef4_mdio_reset_mmd(struct ef4_nic *port, int mmd,\r\nint spins, int spintime)\r\n{\r\nu32 ctrl;\r\nEF4_BUG_ON_PARANOID(spins * spintime >= 5000);\r\nef4_mdio_write(port, mmd, MDIO_CTRL1, MDIO_CTRL1_RESET);\r\ndo {\r\nmsleep(spintime);\r\nctrl = ef4_mdio_read(port, mmd, MDIO_CTRL1);\r\nspins--;\r\n} while (spins && (ctrl & MDIO_CTRL1_RESET));\r\nreturn spins ? spins : -ETIMEDOUT;\r\n}\r\nstatic int ef4_mdio_check_mmd(struct ef4_nic *efx, int mmd)\r\n{\r\nint status;\r\nif (mmd != MDIO_MMD_AN) {\r\nstatus = ef4_mdio_read(efx, mmd, MDIO_STAT2);\r\nif ((status & MDIO_STAT2_DEVPRST) != MDIO_STAT2_DEVPRST_VAL) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PHY MMD %d not responding.\n", mmd);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint ef4_mdio_wait_reset_mmds(struct ef4_nic *efx, unsigned int mmd_mask)\r\n{\r\nconst int spintime = MDIO45_RESET_TIME / MDIO45_RESET_ITERS;\r\nint tries = MDIO45_RESET_ITERS;\r\nint rc = 0;\r\nint in_reset;\r\nwhile (tries) {\r\nint mask = mmd_mask;\r\nint mmd = 0;\r\nint stat;\r\nin_reset = 0;\r\nwhile (mask) {\r\nif (mask & 1) {\r\nstat = ef4_mdio_read(efx, mmd, MDIO_CTRL1);\r\nif (stat < 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"failed to read status of"\r\n" MMD %d\n", mmd);\r\nreturn -EIO;\r\n}\r\nif (stat & MDIO_CTRL1_RESET)\r\nin_reset |= (1 << mmd);\r\n}\r\nmask = mask >> 1;\r\nmmd++;\r\n}\r\nif (!in_reset)\r\nbreak;\r\ntries--;\r\nmsleep(spintime);\r\n}\r\nif (in_reset != 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"not all MMDs came out of reset in time."\r\n" MMDs still in reset: %x\n", in_reset);\r\nrc = -ETIMEDOUT;\r\n}\r\nreturn rc;\r\n}\r\nint ef4_mdio_check_mmds(struct ef4_nic *efx, unsigned int mmd_mask)\r\n{\r\nint mmd = 0, probe_mmd, devs1, devs2;\r\nu32 devices;\r\nprobe_mmd = (mmd_mask & MDIO_DEVS_PHYXS) ? MDIO_MMD_PHYXS :\r\n__ffs(mmd_mask);\r\ndevs1 = ef4_mdio_read(efx, probe_mmd, MDIO_DEVS1);\r\ndevs2 = ef4_mdio_read(efx, probe_mmd, MDIO_DEVS2);\r\nif (devs1 < 0 || devs2 < 0) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"failed to read devices present\n");\r\nreturn -EIO;\r\n}\r\ndevices = devs1 | (devs2 << 16);\r\nif ((devices & mmd_mask) != mmd_mask) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"required MMDs not present: got %x, wanted %x\n",\r\ndevices, mmd_mask);\r\nreturn -ENODEV;\r\n}\r\nnetif_vdbg(efx, hw, efx->net_dev, "Devices present: %x\n", devices);\r\nwhile (mmd_mask) {\r\nif ((mmd_mask & 1) && ef4_mdio_check_mmd(efx, mmd))\r\nreturn -EIO;\r\nmmd_mask = mmd_mask >> 1;\r\nmmd++;\r\n}\r\nreturn 0;\r\n}\r\nbool ef4_mdio_links_ok(struct ef4_nic *efx, unsigned int mmd_mask)\r\n{\r\nif (LOOPBACK_INTERNAL(efx))\r\nreturn true;\r\nelse if (LOOPBACK_MASK(efx) & LOOPBACKS_WS)\r\nreturn false;\r\nelse if (ef4_phy_mode_disabled(efx->phy_mode))\r\nreturn false;\r\nelse if (efx->loopback_mode == LOOPBACK_PHYXS)\r\nmmd_mask &= ~(MDIO_DEVS_PHYXS |\r\nMDIO_DEVS_PCS |\r\nMDIO_DEVS_PMAPMD |\r\nMDIO_DEVS_AN);\r\nelse if (efx->loopback_mode == LOOPBACK_PCS)\r\nmmd_mask &= ~(MDIO_DEVS_PCS |\r\nMDIO_DEVS_PMAPMD |\r\nMDIO_DEVS_AN);\r\nelse if (efx->loopback_mode == LOOPBACK_PMAPMD)\r\nmmd_mask &= ~(MDIO_DEVS_PMAPMD |\r\nMDIO_DEVS_AN);\r\nreturn mdio45_links_ok(&efx->mdio, mmd_mask);\r\n}\r\nvoid ef4_mdio_transmit_disable(struct ef4_nic *efx)\r\n{\r\nef4_mdio_set_flag(efx, MDIO_MMD_PMAPMD,\r\nMDIO_PMA_TXDIS, MDIO_PMD_TXDIS_GLOBAL,\r\nefx->phy_mode & PHY_MODE_TX_DISABLED);\r\n}\r\nvoid ef4_mdio_phy_reconfigure(struct ef4_nic *efx)\r\n{\r\nef4_mdio_set_flag(efx, MDIO_MMD_PMAPMD,\r\nMDIO_CTRL1, MDIO_PMA_CTRL1_LOOPBACK,\r\nefx->loopback_mode == LOOPBACK_PMAPMD);\r\nef4_mdio_set_flag(efx, MDIO_MMD_PCS,\r\nMDIO_CTRL1, MDIO_PCS_CTRL1_LOOPBACK,\r\nefx->loopback_mode == LOOPBACK_PCS);\r\nef4_mdio_set_flag(efx, MDIO_MMD_PHYXS,\r\nMDIO_CTRL1, MDIO_PHYXS_CTRL1_LOOPBACK,\r\nefx->loopback_mode == LOOPBACK_PHYXS_WS);\r\n}\r\nstatic void ef4_mdio_set_mmd_lpower(struct ef4_nic *efx,\r\nint lpower, int mmd)\r\n{\r\nint stat = ef4_mdio_read(efx, mmd, MDIO_STAT1);\r\nnetif_vdbg(efx, drv, efx->net_dev, "Setting low power mode for MMD %d to %d\n",\r\nmmd, lpower);\r\nif (stat & MDIO_STAT1_LPOWERABLE) {\r\nef4_mdio_set_flag(efx, mmd, MDIO_CTRL1,\r\nMDIO_CTRL1_LPOWER, lpower);\r\n}\r\n}\r\nvoid ef4_mdio_set_mmds_lpower(struct ef4_nic *efx,\r\nint low_power, unsigned int mmd_mask)\r\n{\r\nint mmd = 0;\r\nmmd_mask &= ~MDIO_DEVS_AN;\r\nwhile (mmd_mask) {\r\nif (mmd_mask & 1)\r\nef4_mdio_set_mmd_lpower(efx, low_power, mmd);\r\nmmd_mask = (mmd_mask >> 1);\r\nmmd++;\r\n}\r\n}\r\nint ef4_mdio_set_link_ksettings(struct ef4_nic *efx,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct ethtool_link_ksettings prev = {\r\n.base.cmd = ETHTOOL_GLINKSETTINGS\r\n};\r\nu32 prev_advertising, advertising;\r\nu32 prev_supported;\r\nefx->phy_op->get_link_ksettings(efx, &prev);\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\nethtool_convert_link_mode_to_legacy_u32(&prev_advertising,\r\nprev.link_modes.advertising);\r\nethtool_convert_link_mode_to_legacy_u32(&prev_supported,\r\nprev.link_modes.supported);\r\nif (advertising == prev_advertising &&\r\ncmd->base.speed == prev.base.speed &&\r\ncmd->base.duplex == prev.base.duplex &&\r\ncmd->base.port == prev.base.port &&\r\ncmd->base.autoneg == prev.base.autoneg)\r\nreturn 0;\r\nif (prev.base.port != PORT_TP || cmd->base.port != PORT_TP)\r\nreturn -EINVAL;\r\nif (!cmd->base.autoneg ||\r\n(advertising | SUPPORTED_Autoneg) & ~prev_supported)\r\nreturn -EINVAL;\r\nef4_link_set_advertising(efx, advertising | ADVERTISED_Autoneg);\r\nef4_mdio_an_reconfigure(efx);\r\nreturn 0;\r\n}\r\nvoid ef4_mdio_an_reconfigure(struct ef4_nic *efx)\r\n{\r\nint reg;\r\nWARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));\r\nreg = ADVERTISE_CSMA | ADVERTISE_RESV;\r\nif (efx->link_advertising & ADVERTISED_Pause)\r\nreg |= ADVERTISE_PAUSE_CAP;\r\nif (efx->link_advertising & ADVERTISED_Asym_Pause)\r\nreg |= ADVERTISE_PAUSE_ASYM;\r\nef4_mdio_write(efx, MDIO_MMD_AN, MDIO_AN_ADVERTISE, reg);\r\nefx->phy_op->set_npage_adv(efx, efx->link_advertising);\r\nreg = ef4_mdio_read(efx, MDIO_MMD_AN, MDIO_CTRL1);\r\nreg |= MDIO_AN_CTRL1_ENABLE | MDIO_AN_CTRL1_RESTART | MDIO_AN_CTRL1_XNP;\r\nef4_mdio_write(efx, MDIO_MMD_AN, MDIO_CTRL1, reg);\r\n}\r\nu8 ef4_mdio_get_pause(struct ef4_nic *efx)\r\n{\r\nBUILD_BUG_ON(EF4_FC_AUTO & (EF4_FC_RX | EF4_FC_TX));\r\nif (!(efx->wanted_fc & EF4_FC_AUTO))\r\nreturn efx->wanted_fc;\r\nWARN_ON(!(efx->mdio.mmds & MDIO_DEVS_AN));\r\nreturn mii_resolve_flowctrl_fdx(\r\nmii_advertise_flowctrl(efx->wanted_fc),\r\nef4_mdio_read(efx, MDIO_MMD_AN, MDIO_AN_LPA));\r\n}\r\nint ef4_mdio_test_alive(struct ef4_nic *efx)\r\n{\r\nint rc;\r\nint devad = __ffs(efx->mdio.mmds);\r\nu16 physid1, physid2;\r\nmutex_lock(&efx->mac_lock);\r\nphysid1 = ef4_mdio_read(efx, devad, MDIO_DEVID1);\r\nphysid2 = ef4_mdio_read(efx, devad, MDIO_DEVID2);\r\nif ((physid1 == 0x0000) || (physid1 == 0xffff) ||\r\n(physid2 == 0x0000) || (physid2 == 0xffff)) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"no MDIO PHY present with ID %d\n", efx->mdio.prtad);\r\nrc = -EINVAL;\r\n} else {\r\nrc = ef4_mdio_check_mmds(efx, efx->mdio.mmds);\r\n}\r\nmutex_unlock(&efx->mac_lock);\r\nreturn rc;\r\n}
