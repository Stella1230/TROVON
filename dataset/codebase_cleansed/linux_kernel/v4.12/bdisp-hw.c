int bdisp_hw_reset(struct bdisp_dev *bdisp)\r\n{\r\nunsigned int i;\r\ndev_dbg(bdisp->dev, "%s\n", __func__);\r\nwritel(0, bdisp->regs + BLT_ITM0);\r\nwritel(readl(bdisp->regs + BLT_CTL) | BLT_CTL_RESET,\r\nbdisp->regs + BLT_CTL);\r\nwritel(0, bdisp->regs + BLT_CTL);\r\nfor (i = 0; i < POLL_RST_MAX; i++) {\r\nif (readl(bdisp->regs + BLT_STA1) & BLT_STA1_IDLE)\r\nbreak;\r\nmsleep(POLL_RST_DELAY_MS);\r\n}\r\nif (i == POLL_RST_MAX)\r\ndev_err(bdisp->dev, "Reset timeout\n");\r\nreturn (i == POLL_RST_MAX) ? -EAGAIN : 0;\r\n}\r\nint bdisp_hw_get_and_clear_irq(struct bdisp_dev *bdisp)\r\n{\r\nu32 its;\r\nits = readl(bdisp->regs + BLT_ITS);\r\nif (!(its & BLT_ITS_AQ1_LNA)) {\r\ndev_dbg(bdisp->dev, "Unexpected IT status: 0x%08X\n", its);\r\nwritel(its, bdisp->regs + BLT_ITS);\r\nreturn -1;\r\n}\r\nwritel(its, bdisp->regs + BLT_ITS);\r\nwritel(0, bdisp->regs + BLT_ITM0);\r\nreturn 0;\r\n}\r\nvoid bdisp_hw_free_nodes(struct bdisp_ctx *ctx)\r\n{\r\nif (ctx && ctx->node[0])\r\ndma_free_attrs(ctx->bdisp_dev->dev,\r\nsizeof(struct bdisp_node) * MAX_NB_NODE,\r\nctx->node[0], ctx->node_paddr[0],\r\nDMA_ATTR_WRITE_COMBINE);\r\n}\r\nint bdisp_hw_alloc_nodes(struct bdisp_ctx *ctx)\r\n{\r\nstruct device *dev = ctx->bdisp_dev->dev;\r\nunsigned int i, node_size = sizeof(struct bdisp_node);\r\nvoid *base;\r\ndma_addr_t paddr;\r\nbase = dma_alloc_attrs(dev, node_size * MAX_NB_NODE, &paddr,\r\nGFP_KERNEL | GFP_DMA, DMA_ATTR_WRITE_COMBINE);\r\nif (!base) {\r\ndev_err(dev, "%s no mem\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nmemset(base, 0, node_size * MAX_NB_NODE);\r\nfor (i = 0; i < MAX_NB_NODE; i++) {\r\nctx->node[i] = base;\r\nctx->node_paddr[i] = paddr;\r\ndev_dbg(dev, "node[%d]=0x%p (paddr=%pad)\n", i, ctx->node[i],\r\n&paddr);\r\nbase += node_size;\r\npaddr += node_size;\r\n}\r\nreturn 0;\r\n}\r\nvoid bdisp_hw_free_filters(struct device *dev)\r\n{\r\nint size = (BDISP_HF_NB * NB_H_FILTER) + (BDISP_VF_NB * NB_V_FILTER);\r\nif (bdisp_h_filter[0].virt)\r\ndma_free_attrs(dev, size, bdisp_h_filter[0].virt,\r\nbdisp_h_filter[0].paddr, DMA_ATTR_WRITE_COMBINE);\r\n}\r\nint bdisp_hw_alloc_filters(struct device *dev)\r\n{\r\nunsigned int i, size;\r\nvoid *base;\r\ndma_addr_t paddr;\r\nsize = (BDISP_HF_NB * NB_H_FILTER) + (BDISP_VF_NB * NB_V_FILTER);\r\nbase = dma_alloc_attrs(dev, size, &paddr, GFP_KERNEL | GFP_DMA,\r\nDMA_ATTR_WRITE_COMBINE);\r\nif (!base)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < NB_H_FILTER; i++) {\r\nbdisp_h_filter[i].min = bdisp_h_spec[i].min;\r\nbdisp_h_filter[i].max = bdisp_h_spec[i].max;\r\nmemcpy(base, bdisp_h_spec[i].coef, BDISP_HF_NB);\r\nbdisp_h_filter[i].virt = base;\r\nbdisp_h_filter[i].paddr = paddr;\r\nbase += BDISP_HF_NB;\r\npaddr += BDISP_HF_NB;\r\n}\r\nfor (i = 0; i < NB_V_FILTER; i++) {\r\nbdisp_v_filter[i].min = bdisp_v_spec[i].min;\r\nbdisp_v_filter[i].max = bdisp_v_spec[i].max;\r\nmemcpy(base, bdisp_v_spec[i].coef, BDISP_VF_NB);\r\nbdisp_v_filter[i].virt = base;\r\nbdisp_v_filter[i].paddr = paddr;\r\nbase += BDISP_VF_NB;\r\npaddr += BDISP_VF_NB;\r\n}\r\nreturn 0;\r\n}\r\nstatic dma_addr_t bdisp_hw_get_hf_addr(u16 inc)\r\n{\r\nunsigned int i;\r\nfor (i = NB_H_FILTER - 1; i > 0; i--)\r\nif ((bdisp_h_filter[i].min < inc) &&\r\n(inc <= bdisp_h_filter[i].max))\r\nbreak;\r\nreturn bdisp_h_filter[i].paddr;\r\n}\r\nstatic dma_addr_t bdisp_hw_get_vf_addr(u16 inc)\r\n{\r\nunsigned int i;\r\nfor (i = NB_V_FILTER - 1; i > 0; i--)\r\nif ((bdisp_v_filter[i].min < inc) &&\r\n(inc <= bdisp_v_filter[i].max))\r\nbreak;\r\nreturn bdisp_v_filter[i].paddr;\r\n}\r\nstatic int bdisp_hw_get_inc(u32 from, u32 to, u16 *inc)\r\n{\r\nu32 tmp;\r\nif (!to)\r\nreturn -EINVAL;\r\nif (to == from) {\r\n*inc = 1 << 10;\r\nreturn 0;\r\n}\r\ntmp = (from << 10) / to;\r\nif ((tmp > 0xFFFF) || (!tmp))\r\nreturn -EINVAL;\r\n*inc = (u16)tmp;\r\nreturn 0;\r\n}\r\nstatic int bdisp_hw_get_hv_inc(struct bdisp_ctx *ctx, u16 *h_inc, u16 *v_inc)\r\n{\r\nu32 src_w, src_h, dst_w, dst_h;\r\nsrc_w = ctx->src.crop.width;\r\nsrc_h = ctx->src.crop.height;\r\ndst_w = ctx->dst.crop.width;\r\ndst_h = ctx->dst.crop.height;\r\nif (bdisp_hw_get_inc(src_w, dst_w, h_inc) ||\r\nbdisp_hw_get_inc(src_h, dst_h, v_inc)) {\r\ndev_err(ctx->bdisp_dev->dev,\r\n"scale factors failed (%dx%d)->(%dx%d)\n",\r\nsrc_w, src_h, dst_w, dst_h);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bdisp_hw_get_op_cfg(struct bdisp_ctx *ctx, struct bdisp_op_cfg *c)\r\n{\r\nstruct device *dev = ctx->bdisp_dev->dev;\r\nstruct bdisp_frame *src = &ctx->src;\r\nstruct bdisp_frame *dst = &ctx->dst;\r\nif (src->width > MAX_SRC_WIDTH * MAX_VERTICAL_STRIDES) {\r\ndev_err(dev, "Image width out of HW caps\n");\r\nreturn -EINVAL;\r\n}\r\nc->wide = src->width > MAX_SRC_WIDTH;\r\nc->hflip = ctx->hflip;\r\nc->vflip = ctx->vflip;\r\nc->src_interlaced = (src->field == V4L2_FIELD_INTERLACED);\r\nc->src_nbp = src->fmt->nb_planes;\r\nc->src_yuv = (src->fmt->pixelformat == V4L2_PIX_FMT_NV12) ||\r\n(src->fmt->pixelformat == V4L2_PIX_FMT_YUV420);\r\nc->src_420 = c->src_yuv;\r\nc->dst_nbp = dst->fmt->nb_planes;\r\nc->dst_yuv = (dst->fmt->pixelformat == V4L2_PIX_FMT_NV12) ||\r\n(dst->fmt->pixelformat == V4L2_PIX_FMT_YUV420);\r\nc->dst_420 = c->dst_yuv;\r\nc->cconv = (c->src_yuv != c->dst_yuv);\r\nif (bdisp_hw_get_hv_inc(ctx, &c->h_inc, &c->v_inc)) {\r\ndev_err(dev, "Scale factor out of HW caps\n");\r\nreturn -EINVAL;\r\n}\r\nif (c->src_interlaced)\r\nc->v_inc /= 2;\r\nif ((c->h_inc != (1 << 10)) || (c->v_inc != (1 << 10)))\r\nc->scale = true;\r\nelse\r\nc->scale = false;\r\nreturn 0;\r\n}\r\nstatic u32 bdisp_hw_color_format(u32 pixelformat)\r\n{\r\nu32 ret;\r\nswitch (pixelformat) {\r\ncase V4L2_PIX_FMT_YUV420:\r\nret = (BDISP_YUV_3B << BLT_TTY_COL_SHIFT);\r\nbreak;\r\ncase V4L2_PIX_FMT_NV12:\r\nret = (BDISP_NV12 << BLT_TTY_COL_SHIFT) | BLT_TTY_BIG_END;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\nret = (BDISP_RGB565 << BLT_TTY_COL_SHIFT);\r\nbreak;\r\ncase V4L2_PIX_FMT_XBGR32:\r\nret = (BDISP_XRGB8888 << BLT_TTY_COL_SHIFT);\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB24:\r\nret = (BDISP_RGB888 << BLT_TTY_COL_SHIFT) | BLT_TTY_BIG_END;\r\nbreak;\r\ncase V4L2_PIX_FMT_ABGR32:\r\ndefault:\r\nret = (BDISP_ARGB8888 << BLT_TTY_COL_SHIFT) | BLT_TTY_ALPHA_R;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void bdisp_hw_build_node(struct bdisp_ctx *ctx,\r\nstruct bdisp_op_cfg *cfg,\r\nstruct bdisp_node *node,\r\nenum bdisp_target_plan t_plan, int src_x_offset)\r\n{\r\nstruct bdisp_frame *src = &ctx->src;\r\nstruct bdisp_frame *dst = &ctx->dst;\r\nu16 h_inc, v_inc, yh_inc, yv_inc;\r\nstruct v4l2_rect src_rect = src->crop;\r\nstruct v4l2_rect dst_rect = dst->crop;\r\nint dst_x_offset;\r\ns32 dst_width = dst->crop.width;\r\nu32 src_fmt, dst_fmt;\r\nconst u32 *ivmx;\r\ndev_dbg(ctx->bdisp_dev->dev, "%s\n", __func__);\r\nmemset(node, 0, sizeof(*node));\r\nsrc_rect.left += src_x_offset;\r\nsrc_rect.width -= src_x_offset;\r\nsrc_rect.width = min_t(__s32, MAX_SRC_WIDTH, src_rect.width);\r\ndst_x_offset = (src_x_offset * dst_width) / ctx->src.crop.width;\r\ndst_rect.left += dst_x_offset;\r\ndst_rect.width = (src_rect.width * dst_width) / ctx->src.crop.width;\r\nsrc_fmt = src->fmt->pixelformat;\r\ndst_fmt = dst->fmt->pixelformat;\r\nnode->nip = 0;\r\nnode->cic = BLT_CIC_ALL_GRP;\r\nnode->ack = BLT_ACK_BYPASS_S2S3;\r\nswitch (cfg->src_nbp) {\r\ncase 1:\r\nnode->ins = BLT_INS_S1_OFF | BLT_INS_S2_MEM | BLT_INS_S3_OFF;\r\nbreak;\r\ncase 2:\r\nnode->ins = BLT_INS_S1_OFF | BLT_INS_S3_MEM;\r\nif (t_plan == BDISP_Y)\r\nnode->ins |= BLT_INS_S2_CF;\r\nelse\r\nnode->ins |= BLT_INS_S2_MEM;\r\nbreak;\r\ncase 3:\r\ndefault:\r\nnode->ins = BLT_INS_S3_MEM;\r\nif (t_plan == BDISP_Y)\r\nnode->ins |= BLT_INS_S2_CF | BLT_INS_S1_CF;\r\nelse\r\nnode->ins |= BLT_INS_S2_MEM | BLT_INS_S1_MEM;\r\nbreak;\r\n}\r\nnode->ins |= cfg->cconv ? BLT_INS_IVMX : 0;\r\nnode->ins |= (cfg->scale || cfg->src_420 || cfg->dst_420) ?\r\nBLT_INS_SCALE : 0;\r\nnode->tba = (t_plan == BDISP_CBCR) ? dst->paddr[1] : dst->paddr[0];\r\nnode->tty = dst->bytesperline;\r\nnode->tty |= bdisp_hw_color_format(dst_fmt);\r\nnode->tty |= BLT_TTY_DITHER;\r\nnode->tty |= (t_plan == BDISP_CBCR) ? BLT_TTY_CHROMA : 0;\r\nnode->tty |= cfg->hflip ? BLT_TTY_HSO : 0;\r\nnode->tty |= cfg->vflip ? BLT_TTY_VSO : 0;\r\nif (cfg->dst_420 && (t_plan == BDISP_CBCR)) {\r\ndst_rect.height /= 2;\r\ndst_rect.width /= 2;\r\ndst_rect.left /= 2;\r\ndst_rect.top /= 2;\r\ndst_x_offset /= 2;\r\ndst_width /= 2;\r\n}\r\nnode->txy = cfg->vflip ? (dst_rect.height - 1) : dst_rect.top;\r\nnode->txy <<= 16;\r\nnode->txy |= cfg->hflip ? (dst_width - dst_x_offset - 1) :\r\ndst_rect.left;\r\nnode->tsz = dst_rect.height << 16 | dst_rect.width;\r\nif (cfg->src_interlaced) {\r\nsrc_rect.top /= 2;\r\nsrc_rect.height /= 2;\r\n}\r\nif (cfg->src_nbp == 1) {\r\nnode->s2ba = src->paddr[0];\r\nnode->s2ty = src->bytesperline;\r\nif (cfg->src_interlaced)\r\nnode->s2ty *= 2;\r\nnode->s2ty |= bdisp_hw_color_format(src_fmt);\r\nnode->s2xy = src_rect.top << 16 | src_rect.left;\r\nnode->s2sz = src_rect.height << 16 | src_rect.width;\r\n} else {\r\nif (cfg->src_420) {\r\nsrc_rect.top /= 2;\r\nsrc_rect.left /= 2;\r\nsrc_rect.width /= 2;\r\nsrc_rect.height /= 2;\r\n}\r\nnode->s2ba = src->paddr[1];\r\nnode->s2ty = src->bytesperline;\r\nif (cfg->src_nbp == 3)\r\nnode->s2ty /= 2;\r\nif (cfg->src_interlaced)\r\nnode->s2ty *= 2;\r\nnode->s2ty |= bdisp_hw_color_format(src_fmt);\r\nnode->s2xy = src_rect.top << 16 | src_rect.left;\r\nnode->s2sz = src_rect.height << 16 | src_rect.width;\r\nif (cfg->src_nbp == 3) {\r\nnode->s1ba = src->paddr[2];\r\nnode->s1ty = node->s2ty;\r\nnode->s1xy = node->s2xy;\r\n}\r\nnode->s3ba = src->paddr[0];\r\nnode->s3ty = src->bytesperline;\r\nif (cfg->src_interlaced)\r\nnode->s3ty *= 2;\r\nnode->s3ty |= bdisp_hw_color_format(src_fmt);\r\nif ((t_plan != BDISP_CBCR) && cfg->src_420) {\r\nnode->s3xy = node->s2xy * 2;\r\nnode->s3sz = node->s2sz * 2;\r\n} else {\r\nnode->s3ty |= BLT_S3TY_BLANK_ACC;\r\nnode->s3xy = node->s2xy;\r\nnode->s3sz = node->s2sz;\r\n}\r\n}\r\nif (node->ins & BLT_INS_SCALE) {\r\nbool skip_y = (t_plan == BDISP_CBCR) && !cfg->src_yuv;\r\nif (cfg->scale) {\r\nnode->fctl = BLT_FCTL_HV_SCALE;\r\nif (!skip_y)\r\nnode->fctl |= BLT_FCTL_Y_HV_SCALE;\r\n} else {\r\nnode->fctl = BLT_FCTL_HV_SAMPLE;\r\nif (!skip_y)\r\nnode->fctl |= BLT_FCTL_Y_HV_SAMPLE;\r\n}\r\nh_inc = cfg->h_inc;\r\nv_inc = cfg->v_inc;\r\nif (!cfg->src_420 && cfg->dst_420 && (t_plan == BDISP_CBCR)) {\r\nh_inc *= 2;\r\nv_inc *= 2;\r\n} else if (cfg->src_420 && !cfg->dst_420) {\r\nh_inc /= 2;\r\nv_inc /= 2;\r\n}\r\nnode->rsf = v_inc << 16 | h_inc;\r\nnode->rzi = BLT_RZI_DEFAULT;\r\nnode->hfp = bdisp_hw_get_hf_addr(h_inc);\r\nnode->vfp = bdisp_hw_get_vf_addr(v_inc);\r\nif (!skip_y) {\r\nyh_inc = cfg->h_inc;\r\nyv_inc = cfg->v_inc;\r\nnode->y_rsf = yv_inc << 16 | yh_inc;\r\nnode->y_rzi = BLT_RZI_DEFAULT;\r\nnode->y_hfp = bdisp_hw_get_hf_addr(yh_inc);\r\nnode->y_vfp = bdisp_hw_get_vf_addr(yv_inc);\r\n}\r\n}\r\nif (cfg->cconv) {\r\nivmx = cfg->src_yuv ? bdisp_yuv_to_rgb : bdisp_rgb_to_yuv;\r\nnode->ivmx0 = ivmx[0];\r\nnode->ivmx1 = ivmx[1];\r\nnode->ivmx2 = ivmx[2];\r\nnode->ivmx3 = ivmx[3];\r\n}\r\n}\r\nstatic int bdisp_hw_build_all_nodes(struct bdisp_ctx *ctx)\r\n{\r\nstruct bdisp_op_cfg cfg;\r\nunsigned int i, nid = 0;\r\nint src_x_offset = 0;\r\nfor (i = 0; i < MAX_NB_NODE; i++)\r\nif (!ctx->node[i]) {\r\ndev_err(ctx->bdisp_dev->dev, "node %d is null\n", i);\r\nreturn -EINVAL;\r\n}\r\nif (bdisp_hw_get_op_cfg(ctx, &cfg))\r\nreturn -EINVAL;\r\nfor (i = 0; i < MAX_VERTICAL_STRIDES; i++) {\r\nbdisp_hw_build_node(ctx, &cfg, ctx->node[nid],\r\ncfg.dst_nbp == 1 ? BDISP_RGB : BDISP_Y,\r\nsrc_x_offset);\r\nif (nid)\r\nctx->node[nid - 1]->nip = ctx->node_paddr[nid];\r\nnid++;\r\nif (cfg.dst_nbp > 1) {\r\nbdisp_hw_build_node(ctx, &cfg, ctx->node[nid],\r\nBDISP_CBCR, src_x_offset);\r\nctx->node[nid - 1]->nip = ctx->node_paddr[nid];\r\nnid++;\r\n}\r\nsrc_x_offset += MAX_SRC_WIDTH;\r\nif (src_x_offset >= ctx->src.crop.width)\r\nbreak;\r\n}\r\nctx->node[nid - 1]->nip = 0;\r\nreturn 0;\r\n}\r\nstatic void bdisp_hw_save_request(struct bdisp_ctx *ctx)\r\n{\r\nstruct bdisp_node **copy_node = ctx->bdisp_dev->dbg.copy_node;\r\nstruct bdisp_request *request = &ctx->bdisp_dev->dbg.copy_request;\r\nstruct bdisp_node **node = ctx->node;\r\nint i;\r\nrequest->src = ctx->src;\r\nrequest->dst = ctx->dst;\r\nrequest->hflip = ctx->hflip;\r\nrequest->vflip = ctx->vflip;\r\nrequest->nb_req++;\r\nfor (i = 0; i < MAX_NB_NODE; i++) {\r\nif (!copy_node[i]) {\r\ncopy_node[i] = devm_kzalloc(ctx->bdisp_dev->dev,\r\nsizeof(*copy_node[i]),\r\nGFP_KERNEL);\r\nif (!copy_node[i])\r\nreturn;\r\n}\r\n*copy_node[i] = *node[i];\r\n}\r\n}\r\nint bdisp_hw_update(struct bdisp_ctx *ctx)\r\n{\r\nint ret;\r\nstruct bdisp_dev *bdisp = ctx->bdisp_dev;\r\nstruct device *dev = bdisp->dev;\r\nunsigned int node_id;\r\ndev_dbg(dev, "%s\n", __func__);\r\nret = bdisp_hw_build_all_nodes(ctx);\r\nif (ret) {\r\ndev_err(dev, "cannot build nodes (%d)\n", ret);\r\nreturn ret;\r\n}\r\nbdisp_hw_save_request(ctx);\r\nwritel(BLT_AQ1_CTL_CFG, bdisp->regs + BLT_AQ1_CTL);\r\nwritel(BLT_ITS_AQ1_LNA, bdisp->regs + BLT_ITM0);\r\nwritel(ctx->node_paddr[0], bdisp->regs + BLT_AQ1_IP);\r\nfor (node_id = 0; node_id < MAX_NB_NODE - 1; node_id++) {\r\nif (!ctx->node[node_id]->nip)\r\nbreak;\r\n}\r\nwritel(ctx->node_paddr[node_id], bdisp->regs + BLT_AQ1_LNA);\r\nreturn 0;\r\n}
