static const struct da8xx_mstpri_board_priorities *\r\nda8xx_mstpri_get_board_prio(void)\r\n{\r\nconst struct da8xx_mstpri_board_priorities *board_prio;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(da8xx_mstpri_board_confs); i++) {\r\nboard_prio = &da8xx_mstpri_board_confs[i];\r\nif (of_machine_is_compatible(board_prio->board))\r\nreturn board_prio;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int da8xx_mstpri_probe(struct platform_device *pdev)\r\n{\r\nconst struct da8xx_mstpri_board_priorities *prio_list;\r\nconst struct da8xx_mstpri_descr *prio_descr;\r\nconst struct da8xx_mstpri_priority *prio;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nvoid __iomem *mstpri;\r\nu32 reg;\r\nint i;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmstpri = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mstpri)) {\r\ndev_err(dev, "unable to map MSTPRI registers\n");\r\nreturn PTR_ERR(mstpri);\r\n}\r\nprio_list = da8xx_mstpri_get_board_prio();\r\nif (!prio_list) {\r\ndev_err(dev, "no master priorities defined for this board\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < prio_list->numprio; i++) {\r\nprio = &prio_list->priorities[i];\r\nprio_descr = &da8xx_mstpri_priority_list[prio->which];\r\nif (prio_descr->reg + sizeof(u32) > resource_size(res)) {\r\ndev_warn(dev, "register offset out of range\n");\r\ncontinue;\r\n}\r\nreg = readl(mstpri + prio_descr->reg);\r\nreg &= ~prio_descr->mask;\r\nreg |= prio->val << prio_descr->shift;\r\nwritel(reg, mstpri + prio_descr->reg);\r\n}\r\nreturn 0;\r\n}
