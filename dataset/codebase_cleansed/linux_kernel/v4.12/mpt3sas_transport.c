static struct _sas_node *\r\n_transport_sas_node_find_by_sas_address(struct MPT3SAS_ADAPTER *ioc,\r\nu64 sas_address)\r\n{\r\nif (ioc->sas_hba.sas_address == sas_address)\r\nreturn &ioc->sas_hba;\r\nelse\r\nreturn mpt3sas_scsih_expander_find_by_sas_address(ioc,\r\nsas_address);\r\n}\r\nstatic enum sas_linkrate\r\n_transport_convert_phy_link_rate(u8 link_rate)\r\n{\r\nenum sas_linkrate rc;\r\nswitch (link_rate) {\r\ncase MPI2_SAS_NEG_LINK_RATE_1_5:\r\nrc = SAS_LINK_RATE_1_5_GBPS;\r\nbreak;\r\ncase MPI2_SAS_NEG_LINK_RATE_3_0:\r\nrc = SAS_LINK_RATE_3_0_GBPS;\r\nbreak;\r\ncase MPI2_SAS_NEG_LINK_RATE_6_0:\r\nrc = SAS_LINK_RATE_6_0_GBPS;\r\nbreak;\r\ncase MPI25_SAS_NEG_LINK_RATE_12_0:\r\nrc = SAS_LINK_RATE_12_0_GBPS;\r\nbreak;\r\ncase MPI2_SAS_NEG_LINK_RATE_PHY_DISABLED:\r\nrc = SAS_PHY_DISABLED;\r\nbreak;\r\ncase MPI2_SAS_NEG_LINK_RATE_NEGOTIATION_FAILED:\r\nrc = SAS_LINK_RATE_FAILED;\r\nbreak;\r\ncase MPI2_SAS_NEG_LINK_RATE_PORT_SELECTOR:\r\nrc = SAS_SATA_PORT_SELECTOR;\r\nbreak;\r\ncase MPI2_SAS_NEG_LINK_RATE_SMP_RESET_IN_PROGRESS:\r\nrc = SAS_PHY_RESET_IN_PROGRESS;\r\nbreak;\r\ndefault:\r\ncase MPI2_SAS_NEG_LINK_RATE_SATA_OOB_COMPLETE:\r\ncase MPI2_SAS_NEG_LINK_RATE_UNKNOWN_LINK_RATE:\r\nrc = SAS_LINK_RATE_UNKNOWN;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_set_identify(struct MPT3SAS_ADAPTER *ioc, u16 handle,\r\nstruct sas_identify *identify)\r\n{\r\nMpi2SasDevicePage0_t sas_device_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu32 device_info;\r\nu32 ioc_status;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery) {\r\npr_info(MPT3SAS_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nreturn -EFAULT;\r\n}\r\nif ((mpt3sas_config_get_sas_device_pg0(ioc, &mpi_reply, &sas_device_pg0,\r\nMPI2_SAS_DEVICE_PGAD_FORM_HANDLE, handle))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -ENXIO;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\npr_err(MPT3SAS_FMT\r\n"handle(0x%04x), ioc_status(0x%04x)\nfailure at %s:%d/%s()!\n",\r\nioc->name, handle, ioc_status,\r\n__FILE__, __LINE__, __func__);\r\nreturn -EIO;\r\n}\r\nmemset(identify, 0, sizeof(struct sas_identify));\r\ndevice_info = le32_to_cpu(sas_device_pg0.DeviceInfo);\r\nidentify->sas_address = le64_to_cpu(sas_device_pg0.SASAddress);\r\nidentify->phy_identifier = sas_device_pg0.PhyNum;\r\nswitch (device_info & MPI2_SAS_DEVICE_INFO_MASK_DEVICE_TYPE) {\r\ncase MPI2_SAS_DEVICE_INFO_NO_DEVICE:\r\nidentify->device_type = SAS_PHY_UNUSED;\r\nbreak;\r\ncase MPI2_SAS_DEVICE_INFO_END_DEVICE:\r\nidentify->device_type = SAS_END_DEVICE;\r\nbreak;\r\ncase MPI2_SAS_DEVICE_INFO_EDGE_EXPANDER:\r\nidentify->device_type = SAS_EDGE_EXPANDER_DEVICE;\r\nbreak;\r\ncase MPI2_SAS_DEVICE_INFO_FANOUT_EXPANDER:\r\nidentify->device_type = SAS_FANOUT_EXPANDER_DEVICE;\r\nbreak;\r\n}\r\nif (device_info & MPI2_SAS_DEVICE_INFO_SSP_INITIATOR)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_SSP;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_STP_INITIATOR)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_STP;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_SMP_INITIATOR)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_SMP;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_SATA_HOST)\r\nidentify->initiator_port_protocols |= SAS_PROTOCOL_SATA;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_SSP_TARGET)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_SSP;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_STP_TARGET)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_STP;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_SMP_TARGET)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_SMP;\r\nif (device_info & MPI2_SAS_DEVICE_INFO_SATA_DEVICE)\r\nidentify->target_port_protocols |= SAS_PROTOCOL_SATA;\r\nreturn 0;\r\n}\r\nu8\r\nmpt3sas_transport_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index,\r\nu32 reply)\r\n{\r\nMPI2DefaultReply_t *mpi_reply;\r\nmpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);\r\nif (ioc->transport_cmds.status == MPT3_CMD_NOT_USED)\r\nreturn 1;\r\nif (ioc->transport_cmds.smid != smid)\r\nreturn 1;\r\nioc->transport_cmds.status |= MPT3_CMD_COMPLETE;\r\nif (mpi_reply) {\r\nmemcpy(ioc->transport_cmds.reply, mpi_reply,\r\nmpi_reply->MsgLength*4);\r\nioc->transport_cmds.status |= MPT3_CMD_REPLY_VALID;\r\n}\r\nioc->transport_cmds.status &= ~MPT3_CMD_PENDING;\r\ncomplete(&ioc->transport_cmds.done);\r\nreturn 1;\r\n}\r\nstatic int\r\n_transport_expander_report_manufacture(struct MPT3SAS_ADAPTER *ioc,\r\nu64 sas_address, struct sas_expander_device *edev)\r\n{\r\nMpi2SmpPassthroughRequest_t *mpi_request;\r\nMpi2SmpPassthroughReply_t *mpi_reply;\r\nstruct rep_manu_reply *manufacture_reply;\r\nstruct rep_manu_request *manufacture_request;\r\nint rc;\r\nu16 smid;\r\nu32 ioc_state;\r\nvoid *psge;\r\nu8 issue_reset = 0;\r\nvoid *data_out = NULL;\r\ndma_addr_t data_out_dma;\r\ndma_addr_t data_in_dma;\r\nsize_t data_in_sz;\r\nsize_t data_out_sz;\r\nu16 wait_state_count;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery) {\r\npr_info(MPT3SAS_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&ioc->transport_cmds.mutex);\r\nif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\r\npr_err(MPT3SAS_FMT "%s: transport_cmds in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nioc->transport_cmds.status = MPT3_CMD_PENDING;\r\nwait_state_count = 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nssleep(1);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\npr_info(MPT3SAS_FMT\r\n"%s: waiting for operational state(count=%d)\n",\r\nioc->name, __func__, wait_state_count);\r\n}\r\nif (wait_state_count)\r\npr_info(MPT3SAS_FMT "%s: ioc is operational\n",\r\nioc->name, __func__);\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nrc = 0;\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->transport_cmds.smid = smid;\r\ndata_out_sz = sizeof(struct rep_manu_request);\r\ndata_in_sz = sizeof(struct rep_manu_reply);\r\ndata_out = pci_alloc_consistent(ioc->pdev, data_out_sz + data_in_sz,\r\n&data_out_dma);\r\nif (!data_out) {\r\npr_err("failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nrc = -ENOMEM;\r\nmpt3sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\ndata_in_dma = data_out_dma + sizeof(struct rep_manu_request);\r\nmanufacture_request = data_out;\r\nmanufacture_request->smp_frame_type = 0x40;\r\nmanufacture_request->function = 1;\r\nmanufacture_request->reserved = 0;\r\nmanufacture_request->request_length = 0;\r\nmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\r\nmpi_request->PhysicalPort = 0xFF;\r\nmpi_request->SASAddress = cpu_to_le64(sas_address);\r\nmpi_request->RequestDataLength = cpu_to_le16(data_out_sz);\r\npsge = &mpi_request->SGL;\r\nioc->build_sg(ioc, psge, data_out_dma, data_out_sz, data_in_dma,\r\ndata_in_sz);\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"report_manufacture - send to sas_addr(0x%016llx)\n",\r\nioc->name, (unsigned long long)sas_address));\r\ninit_completion(&ioc->transport_cmds.done);\r\nioc->put_smid_default(ioc, smid);\r\nwait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SmpPassthroughRequest_t)/4);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"report_manufacture - complete\n", ioc->name));\r\nif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\r\nu8 *tmp;\r\nmpi_reply = ioc->transport_cmds.reply;\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"report_manufacture - reply data transfer size(%d)\n",\r\nioc->name, le16_to_cpu(mpi_reply->ResponseDataLength)));\r\nif (le16_to_cpu(mpi_reply->ResponseDataLength) !=\r\nsizeof(struct rep_manu_reply))\r\ngoto out;\r\nmanufacture_reply = data_out + sizeof(struct rep_manu_request);\r\nstrncpy(edev->vendor_id, manufacture_reply->vendor_id,\r\nSAS_EXPANDER_VENDOR_ID_LEN);\r\nstrncpy(edev->product_id, manufacture_reply->product_id,\r\nSAS_EXPANDER_PRODUCT_ID_LEN);\r\nstrncpy(edev->product_rev, manufacture_reply->product_rev,\r\nSAS_EXPANDER_PRODUCT_REV_LEN);\r\nedev->level = manufacture_reply->sas_format & 1;\r\nif (edev->level) {\r\nstrncpy(edev->component_vendor_id,\r\nmanufacture_reply->component_vendor_id,\r\nSAS_EXPANDER_COMPONENT_VENDOR_ID_LEN);\r\ntmp = (u8 *)&manufacture_reply->component_id;\r\nedev->component_id = tmp[0] << 8 | tmp[1];\r\nedev->component_revision_id =\r\nmanufacture_reply->component_revision_id;\r\n}\r\n} else\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"report_manufacture - no reply\n", ioc->name));\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\r\nout:\r\nioc->transport_cmds.status = MPT3_CMD_NOT_USED;\r\nif (data_out)\r\npci_free_consistent(ioc->pdev, data_out_sz + data_in_sz,\r\ndata_out, data_out_dma);\r\nmutex_unlock(&ioc->transport_cmds.mutex);\r\nreturn rc;\r\n}\r\nstatic void\r\n_transport_delete_port(struct MPT3SAS_ADAPTER *ioc,\r\nstruct _sas_port *mpt3sas_port)\r\n{\r\nu64 sas_address = mpt3sas_port->remote_identify.sas_address;\r\nenum sas_device_type device_type =\r\nmpt3sas_port->remote_identify.device_type;\r\ndev_printk(KERN_INFO, &mpt3sas_port->port->dev,\r\n"remove: sas_addr(0x%016llx)\n",\r\n(unsigned long long) sas_address);\r\nioc->logging_level |= MPT_DEBUG_TRANSPORT;\r\nif (device_type == SAS_END_DEVICE)\r\nmpt3sas_device_remove_by_sas_address(ioc, sas_address);\r\nelse if (device_type == SAS_EDGE_EXPANDER_DEVICE ||\r\ndevice_type == SAS_FANOUT_EXPANDER_DEVICE)\r\nmpt3sas_expander_remove(ioc, sas_address);\r\nioc->logging_level &= ~MPT_DEBUG_TRANSPORT;\r\n}\r\nstatic void\r\n_transport_delete_phy(struct MPT3SAS_ADAPTER *ioc,\r\nstruct _sas_port *mpt3sas_port, struct _sas_phy *mpt3sas_phy)\r\n{\r\nu64 sas_address = mpt3sas_port->remote_identify.sas_address;\r\ndev_printk(KERN_INFO, &mpt3sas_phy->phy->dev,\r\n"remove: sas_addr(0x%016llx), phy(%d)\n",\r\n(unsigned long long) sas_address, mpt3sas_phy->phy_id);\r\nlist_del(&mpt3sas_phy->port_siblings);\r\nmpt3sas_port->num_phys--;\r\nsas_port_delete_phy(mpt3sas_port->port, mpt3sas_phy->phy);\r\nmpt3sas_phy->phy_belongs_to_port = 0;\r\n}\r\nstatic void\r\n_transport_add_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_port *mpt3sas_port,\r\nstruct _sas_phy *mpt3sas_phy)\r\n{\r\nu64 sas_address = mpt3sas_port->remote_identify.sas_address;\r\ndev_printk(KERN_INFO, &mpt3sas_phy->phy->dev,\r\n"add: sas_addr(0x%016llx), phy(%d)\n", (unsigned long long)\r\nsas_address, mpt3sas_phy->phy_id);\r\nlist_add_tail(&mpt3sas_phy->port_siblings, &mpt3sas_port->phy_list);\r\nmpt3sas_port->num_phys++;\r\nsas_port_add_phy(mpt3sas_port->port, mpt3sas_phy->phy);\r\nmpt3sas_phy->phy_belongs_to_port = 1;\r\n}\r\nstatic void\r\n_transport_add_phy_to_an_existing_port(struct MPT3SAS_ADAPTER *ioc,\r\nstruct _sas_node *sas_node, struct _sas_phy *mpt3sas_phy,\r\nu64 sas_address)\r\n{\r\nstruct _sas_port *mpt3sas_port;\r\nstruct _sas_phy *phy_srch;\r\nif (mpt3sas_phy->phy_belongs_to_port == 1)\r\nreturn;\r\nlist_for_each_entry(mpt3sas_port, &sas_node->sas_port_list,\r\nport_list) {\r\nif (mpt3sas_port->remote_identify.sas_address !=\r\nsas_address)\r\ncontinue;\r\nlist_for_each_entry(phy_srch, &mpt3sas_port->phy_list,\r\nport_siblings) {\r\nif (phy_srch == mpt3sas_phy)\r\nreturn;\r\n}\r\n_transport_add_phy(ioc, mpt3sas_port, mpt3sas_phy);\r\nreturn;\r\n}\r\n}\r\nstatic void\r\n_transport_del_phy_from_an_existing_port(struct MPT3SAS_ADAPTER *ioc,\r\nstruct _sas_node *sas_node, struct _sas_phy *mpt3sas_phy)\r\n{\r\nstruct _sas_port *mpt3sas_port, *next;\r\nstruct _sas_phy *phy_srch;\r\nif (mpt3sas_phy->phy_belongs_to_port == 0)\r\nreturn;\r\nlist_for_each_entry_safe(mpt3sas_port, next, &sas_node->sas_port_list,\r\nport_list) {\r\nlist_for_each_entry(phy_srch, &mpt3sas_port->phy_list,\r\nport_siblings) {\r\nif (phy_srch != mpt3sas_phy)\r\ncontinue;\r\nif (mpt3sas_port->num_phys == 1)\r\n_transport_delete_port(ioc, mpt3sas_port);\r\nelse\r\n_transport_delete_phy(ioc, mpt3sas_port,\r\nmpt3sas_phy);\r\nreturn;\r\n}\r\n}\r\n}\r\nstatic void\r\n_transport_sanity_check(struct MPT3SAS_ADAPTER *ioc, struct _sas_node *sas_node,\r\nu64 sas_address)\r\n{\r\nint i;\r\nfor (i = 0; i < sas_node->num_phys; i++) {\r\nif (sas_node->phy[i].remote_identify.sas_address != sas_address)\r\ncontinue;\r\nif (sas_node->phy[i].phy_belongs_to_port == 1)\r\n_transport_del_phy_from_an_existing_port(ioc, sas_node,\r\n&sas_node->phy[i]);\r\n}\r\n}\r\nstruct _sas_port *\r\nmpt3sas_transport_port_add(struct MPT3SAS_ADAPTER *ioc, u16 handle,\r\nu64 sas_address)\r\n{\r\nstruct _sas_phy *mpt3sas_phy, *next;\r\nstruct _sas_port *mpt3sas_port;\r\nunsigned long flags;\r\nstruct _sas_node *sas_node;\r\nstruct sas_rphy *rphy;\r\nstruct _sas_device *sas_device = NULL;\r\nint i;\r\nstruct sas_port *port;\r\nmpt3sas_port = kzalloc(sizeof(struct _sas_port),\r\nGFP_KERNEL);\r\nif (!mpt3sas_port) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&mpt3sas_port->port_list);\r\nINIT_LIST_HEAD(&mpt3sas_port->phy_list);\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_node = _transport_sas_node_find_by_sas_address(ioc, sas_address);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (!sas_node) {\r\npr_err(MPT3SAS_FMT\r\n"%s: Could not find parent sas_address(0x%016llx)!\n",\r\nioc->name, __func__, (unsigned long long)sas_address);\r\ngoto out_fail;\r\n}\r\nif ((_transport_set_identify(ioc, handle,\r\n&mpt3sas_port->remote_identify))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out_fail;\r\n}\r\nif (mpt3sas_port->remote_identify.device_type == SAS_PHY_UNUSED) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out_fail;\r\n}\r\n_transport_sanity_check(ioc, sas_node,\r\nmpt3sas_port->remote_identify.sas_address);\r\nfor (i = 0; i < sas_node->num_phys; i++) {\r\nif (sas_node->phy[i].remote_identify.sas_address !=\r\nmpt3sas_port->remote_identify.sas_address)\r\ncontinue;\r\nlist_add_tail(&sas_node->phy[i].port_siblings,\r\n&mpt3sas_port->phy_list);\r\nmpt3sas_port->num_phys++;\r\n}\r\nif (!mpt3sas_port->num_phys) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out_fail;\r\n}\r\nif (!sas_node->parent_dev) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out_fail;\r\n}\r\nport = sas_port_alloc_num(sas_node->parent_dev);\r\nif ((sas_port_add(port))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\ngoto out_fail;\r\n}\r\nlist_for_each_entry(mpt3sas_phy, &mpt3sas_port->phy_list,\r\nport_siblings) {\r\nif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\r\ndev_printk(KERN_INFO, &port->dev,\r\n"add: handle(0x%04x), sas_addr(0x%016llx), phy(%d)\n",\r\nhandle, (unsigned long long)\r\nmpt3sas_port->remote_identify.sas_address,\r\nmpt3sas_phy->phy_id);\r\nsas_port_add_phy(port, mpt3sas_phy->phy);\r\nmpt3sas_phy->phy_belongs_to_port = 1;\r\n}\r\nmpt3sas_port->port = port;\r\nif (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE)\r\nrphy = sas_end_device_alloc(port);\r\nelse\r\nrphy = sas_expander_alloc(port,\r\nmpt3sas_port->remote_identify.device_type);\r\nrphy->identify = mpt3sas_port->remote_identify;\r\nif (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {\r\nsas_device = mpt3sas_get_sdev_by_addr(ioc,\r\nmpt3sas_port->remote_identify.sas_address);\r\nif (!sas_device) {\r\ndfailprintk(ioc, printk(MPT3SAS_FMT\r\n"failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__));\r\ngoto out_fail;\r\n}\r\nsas_device->pend_sas_rphy_add = 1;\r\n}\r\nif ((sas_rphy_add(rphy))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\n}\r\nif (mpt3sas_port->remote_identify.device_type == SAS_END_DEVICE) {\r\nsas_device->pend_sas_rphy_add = 0;\r\nsas_device_put(sas_device);\r\n}\r\nif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\r\ndev_printk(KERN_INFO, &rphy->dev,\r\n"add: handle(0x%04x), sas_addr(0x%016llx)\n",\r\nhandle, (unsigned long long)\r\nmpt3sas_port->remote_identify.sas_address);\r\nmpt3sas_port->rphy = rphy;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nlist_add_tail(&mpt3sas_port->port_list, &sas_node->sas_port_list);\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (mpt3sas_port->remote_identify.device_type ==\r\nMPI2_SAS_DEVICE_INFO_EDGE_EXPANDER ||\r\nmpt3sas_port->remote_identify.device_type ==\r\nMPI2_SAS_DEVICE_INFO_FANOUT_EXPANDER)\r\n_transport_expander_report_manufacture(ioc,\r\nmpt3sas_port->remote_identify.sas_address,\r\nrphy_to_expander_device(rphy));\r\nreturn mpt3sas_port;\r\nout_fail:\r\nlist_for_each_entry_safe(mpt3sas_phy, next, &mpt3sas_port->phy_list,\r\nport_siblings)\r\nlist_del(&mpt3sas_phy->port_siblings);\r\nkfree(mpt3sas_port);\r\nreturn NULL;\r\n}\r\nvoid\r\nmpt3sas_transport_port_remove(struct MPT3SAS_ADAPTER *ioc, u64 sas_address,\r\nu64 sas_address_parent)\r\n{\r\nint i;\r\nunsigned long flags;\r\nstruct _sas_port *mpt3sas_port, *next;\r\nstruct _sas_node *sas_node;\r\nu8 found = 0;\r\nstruct _sas_phy *mpt3sas_phy, *next_phy;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_node = _transport_sas_node_find_by_sas_address(ioc,\r\nsas_address_parent);\r\nif (!sas_node) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(mpt3sas_port, next, &sas_node->sas_port_list,\r\nport_list) {\r\nif (mpt3sas_port->remote_identify.sas_address != sas_address)\r\ncontinue;\r\nfound = 1;\r\nlist_del(&mpt3sas_port->port_list);\r\ngoto out;\r\n}\r\nout:\r\nif (!found) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn;\r\n}\r\nfor (i = 0; i < sas_node->num_phys; i++) {\r\nif (sas_node->phy[i].remote_identify.sas_address == sas_address)\r\nmemset(&sas_node->phy[i].remote_identify, 0 ,\r\nsizeof(struct sas_identify));\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nlist_for_each_entry_safe(mpt3sas_phy, next_phy,\r\n&mpt3sas_port->phy_list, port_siblings) {\r\nif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\r\ndev_printk(KERN_INFO, &mpt3sas_port->port->dev,\r\n"remove: sas_addr(0x%016llx), phy(%d)\n",\r\n(unsigned long long)\r\nmpt3sas_port->remote_identify.sas_address,\r\nmpt3sas_phy->phy_id);\r\nmpt3sas_phy->phy_belongs_to_port = 0;\r\nsas_port_delete_phy(mpt3sas_port->port, mpt3sas_phy->phy);\r\nlist_del(&mpt3sas_phy->port_siblings);\r\n}\r\nsas_port_delete(mpt3sas_port->port);\r\nkfree(mpt3sas_port);\r\n}\r\nint\r\nmpt3sas_transport_add_host_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy\r\n*mpt3sas_phy, Mpi2SasPhyPage0_t phy_pg0, struct device *parent_dev)\r\n{\r\nstruct sas_phy *phy;\r\nint phy_index = mpt3sas_phy->phy_id;\r\nINIT_LIST_HEAD(&mpt3sas_phy->port_siblings);\r\nphy = sas_phy_alloc(parent_dev, phy_index);\r\nif (!phy) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nif ((_transport_set_identify(ioc, mpt3sas_phy->handle,\r\n&mpt3sas_phy->identify))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nsas_phy_free(phy);\r\nreturn -1;\r\n}\r\nphy->identify = mpt3sas_phy->identify;\r\nmpt3sas_phy->attached_handle = le16_to_cpu(phy_pg0.AttachedDevHandle);\r\nif (mpt3sas_phy->attached_handle)\r\n_transport_set_identify(ioc, mpt3sas_phy->attached_handle,\r\n&mpt3sas_phy->remote_identify);\r\nphy->identify.phy_identifier = mpt3sas_phy->phy_id;\r\nphy->negotiated_linkrate = _transport_convert_phy_link_rate(\r\nphy_pg0.NegotiatedLinkRate & MPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);\r\nphy->minimum_linkrate_hw = _transport_convert_phy_link_rate(\r\nphy_pg0.HwLinkRate & MPI2_SAS_HWRATE_MIN_RATE_MASK);\r\nphy->maximum_linkrate_hw = _transport_convert_phy_link_rate(\r\nphy_pg0.HwLinkRate >> 4);\r\nphy->minimum_linkrate = _transport_convert_phy_link_rate(\r\nphy_pg0.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);\r\nphy->maximum_linkrate = _transport_convert_phy_link_rate(\r\nphy_pg0.ProgrammedLinkRate >> 4);\r\nif ((sas_phy_add(phy))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nsas_phy_free(phy);\r\nreturn -1;\r\n}\r\nif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\r\ndev_printk(KERN_INFO, &phy->dev,\r\n"add: handle(0x%04x), sas_addr(0x%016llx)\n"\r\n"\tattached_handle(0x%04x), sas_addr(0x%016llx)\n",\r\nmpt3sas_phy->handle, (unsigned long long)\r\nmpt3sas_phy->identify.sas_address,\r\nmpt3sas_phy->attached_handle,\r\n(unsigned long long)\r\nmpt3sas_phy->remote_identify.sas_address);\r\nmpt3sas_phy->phy = phy;\r\nreturn 0;\r\n}\r\nint\r\nmpt3sas_transport_add_expander_phy(struct MPT3SAS_ADAPTER *ioc, struct _sas_phy\r\n*mpt3sas_phy, Mpi2ExpanderPage1_t expander_pg1,\r\nstruct device *parent_dev)\r\n{\r\nstruct sas_phy *phy;\r\nint phy_index = mpt3sas_phy->phy_id;\r\nINIT_LIST_HEAD(&mpt3sas_phy->port_siblings);\r\nphy = sas_phy_alloc(parent_dev, phy_index);\r\nif (!phy) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -1;\r\n}\r\nif ((_transport_set_identify(ioc, mpt3sas_phy->handle,\r\n&mpt3sas_phy->identify))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nsas_phy_free(phy);\r\nreturn -1;\r\n}\r\nphy->identify = mpt3sas_phy->identify;\r\nmpt3sas_phy->attached_handle =\r\nle16_to_cpu(expander_pg1.AttachedDevHandle);\r\nif (mpt3sas_phy->attached_handle)\r\n_transport_set_identify(ioc, mpt3sas_phy->attached_handle,\r\n&mpt3sas_phy->remote_identify);\r\nphy->identify.phy_identifier = mpt3sas_phy->phy_id;\r\nphy->negotiated_linkrate = _transport_convert_phy_link_rate(\r\nexpander_pg1.NegotiatedLinkRate &\r\nMPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);\r\nphy->minimum_linkrate_hw = _transport_convert_phy_link_rate(\r\nexpander_pg1.HwLinkRate & MPI2_SAS_HWRATE_MIN_RATE_MASK);\r\nphy->maximum_linkrate_hw = _transport_convert_phy_link_rate(\r\nexpander_pg1.HwLinkRate >> 4);\r\nphy->minimum_linkrate = _transport_convert_phy_link_rate(\r\nexpander_pg1.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);\r\nphy->maximum_linkrate = _transport_convert_phy_link_rate(\r\nexpander_pg1.ProgrammedLinkRate >> 4);\r\nif ((sas_phy_add(phy))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nsas_phy_free(phy);\r\nreturn -1;\r\n}\r\nif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\r\ndev_printk(KERN_INFO, &phy->dev,\r\n"add: handle(0x%04x), sas_addr(0x%016llx)\n"\r\n"\tattached_handle(0x%04x), sas_addr(0x%016llx)\n",\r\nmpt3sas_phy->handle, (unsigned long long)\r\nmpt3sas_phy->identify.sas_address,\r\nmpt3sas_phy->attached_handle,\r\n(unsigned long long)\r\nmpt3sas_phy->remote_identify.sas_address);\r\nmpt3sas_phy->phy = phy;\r\nreturn 0;\r\n}\r\nvoid\r\nmpt3sas_transport_update_links(struct MPT3SAS_ADAPTER *ioc,\r\nu64 sas_address, u16 handle, u8 phy_number, u8 link_rate)\r\n{\r\nunsigned long flags;\r\nstruct _sas_node *sas_node;\r\nstruct _sas_phy *mpt3sas_phy;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery)\r\nreturn;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nsas_node = _transport_sas_node_find_by_sas_address(ioc, sas_address);\r\nif (!sas_node) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn;\r\n}\r\nmpt3sas_phy = &sas_node->phy[phy_number];\r\nmpt3sas_phy->attached_handle = handle;\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (handle && (link_rate >= MPI2_SAS_NEG_LINK_RATE_1_5)) {\r\n_transport_set_identify(ioc, handle,\r\n&mpt3sas_phy->remote_identify);\r\n_transport_add_phy_to_an_existing_port(ioc, sas_node,\r\nmpt3sas_phy, mpt3sas_phy->remote_identify.sas_address);\r\n} else\r\nmemset(&mpt3sas_phy->remote_identify, 0 , sizeof(struct\r\nsas_identify));\r\nif (mpt3sas_phy->phy)\r\nmpt3sas_phy->phy->negotiated_linkrate =\r\n_transport_convert_phy_link_rate(link_rate);\r\nif ((ioc->logging_level & MPT_DEBUG_TRANSPORT))\r\ndev_printk(KERN_INFO, &mpt3sas_phy->phy->dev,\r\n"refresh: parent sas_addr(0x%016llx),\n"\r\n"\tlink_rate(0x%02x), phy(%d)\n"\r\n"\tattached_handle(0x%04x), sas_addr(0x%016llx)\n",\r\n(unsigned long long)sas_address,\r\nlink_rate, phy_number, handle, (unsigned long long)\r\nmpt3sas_phy->remote_identify.sas_address);\r\n}\r\nstatic inline void *\r\nphy_to_ioc(struct sas_phy *phy)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(phy->dev.parent);\r\nreturn shost_priv(shost);\r\n}\r\nstatic inline void *\r\nrphy_to_ioc(struct sas_rphy *rphy)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);\r\nreturn shost_priv(shost);\r\n}\r\nstatic int\r\n_transport_get_expander_phy_error_log(struct MPT3SAS_ADAPTER *ioc,\r\nstruct sas_phy *phy)\r\n{\r\nMpi2SmpPassthroughRequest_t *mpi_request;\r\nMpi2SmpPassthroughReply_t *mpi_reply;\r\nstruct phy_error_log_request *phy_error_log_request;\r\nstruct phy_error_log_reply *phy_error_log_reply;\r\nint rc;\r\nu16 smid;\r\nu32 ioc_state;\r\nvoid *psge;\r\nu8 issue_reset = 0;\r\nvoid *data_out = NULL;\r\ndma_addr_t data_out_dma;\r\nu32 sz;\r\nu16 wait_state_count;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery) {\r\npr_info(MPT3SAS_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&ioc->transport_cmds.mutex);\r\nif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\r\npr_err(MPT3SAS_FMT "%s: transport_cmds in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nioc->transport_cmds.status = MPT3_CMD_PENDING;\r\nwait_state_count = 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nssleep(1);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\npr_info(MPT3SAS_FMT\r\n"%s: waiting for operational state(count=%d)\n",\r\nioc->name, __func__, wait_state_count);\r\n}\r\nif (wait_state_count)\r\npr_info(MPT3SAS_FMT "%s: ioc is operational\n",\r\nioc->name, __func__);\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->transport_cmds.smid = smid;\r\nsz = sizeof(struct phy_error_log_request) +\r\nsizeof(struct phy_error_log_reply);\r\ndata_out = pci_alloc_consistent(ioc->pdev, sz, &data_out_dma);\r\nif (!data_out) {\r\npr_err("failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nrc = -ENOMEM;\r\nmpt3sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nmemset(data_out, 0, sz);\r\nphy_error_log_request = data_out;\r\nphy_error_log_request->smp_frame_type = 0x40;\r\nphy_error_log_request->function = 0x11;\r\nphy_error_log_request->request_length = 2;\r\nphy_error_log_request->allocated_response_length = 0;\r\nphy_error_log_request->phy_identifier = phy->number;\r\nmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\r\nmpi_request->PhysicalPort = 0xFF;\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\nmpi_request->SASAddress = cpu_to_le64(phy->identify.sas_address);\r\nmpi_request->RequestDataLength =\r\ncpu_to_le16(sizeof(struct phy_error_log_request));\r\npsge = &mpi_request->SGL;\r\nioc->build_sg(ioc, psge, data_out_dma,\r\nsizeof(struct phy_error_log_request),\r\ndata_out_dma + sizeof(struct phy_error_log_request),\r\nsizeof(struct phy_error_log_reply));\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_error_log - send to sas_addr(0x%016llx), phy(%d)\n",\r\nioc->name, (unsigned long long)phy->identify.sas_address,\r\nphy->number));\r\ninit_completion(&ioc->transport_cmds.done);\r\nioc->put_smid_default(ioc, smid);\r\nwait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SmpPassthroughRequest_t)/4);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_error_log - complete\n", ioc->name));\r\nif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\r\nmpi_reply = ioc->transport_cmds.reply;\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_error_log - reply data transfer size(%d)\n",\r\nioc->name, le16_to_cpu(mpi_reply->ResponseDataLength)));\r\nif (le16_to_cpu(mpi_reply->ResponseDataLength) !=\r\nsizeof(struct phy_error_log_reply))\r\ngoto out;\r\nphy_error_log_reply = data_out +\r\nsizeof(struct phy_error_log_request);\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_error_log - function_result(%d)\n",\r\nioc->name, phy_error_log_reply->function_result));\r\nphy->invalid_dword_count =\r\nbe32_to_cpu(phy_error_log_reply->invalid_dword);\r\nphy->running_disparity_error_count =\r\nbe32_to_cpu(phy_error_log_reply->running_disparity_error);\r\nphy->loss_of_dword_sync_count =\r\nbe32_to_cpu(phy_error_log_reply->loss_of_dword_sync);\r\nphy->phy_reset_problem_count =\r\nbe32_to_cpu(phy_error_log_reply->phy_reset_problem);\r\nrc = 0;\r\n} else\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_error_log - no reply\n", ioc->name));\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\r\nout:\r\nioc->transport_cmds.status = MPT3_CMD_NOT_USED;\r\nif (data_out)\r\npci_free_consistent(ioc->pdev, sz, data_out, data_out_dma);\r\nmutex_unlock(&ioc->transport_cmds.mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_get_linkerrors(struct sas_phy *phy)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\r\nunsigned long flags;\r\nMpi2ConfigReply_t mpi_reply;\r\nMpi2SasPhyPage1_t phy_pg1;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nif (_transport_sas_node_find_by_sas_address(ioc,\r\nphy->identify.sas_address) == NULL) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (phy->identify.sas_address != ioc->sas_hba.sas_address)\r\nreturn _transport_get_expander_phy_error_log(ioc, phy);\r\nif ((mpt3sas_config_get_phy_pg1(ioc, &mpi_reply, &phy_pg1,\r\nphy->number))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -ENXIO;\r\n}\r\nif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo)\r\npr_info(MPT3SAS_FMT\r\n"phy(%d), ioc_status (0x%04x), loginfo(0x%08x)\n",\r\nioc->name, phy->number,\r\nle16_to_cpu(mpi_reply.IOCStatus),\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nphy->invalid_dword_count = le32_to_cpu(phy_pg1.InvalidDwordCount);\r\nphy->running_disparity_error_count =\r\nle32_to_cpu(phy_pg1.RunningDisparityErrorCount);\r\nphy->loss_of_dword_sync_count =\r\nle32_to_cpu(phy_pg1.LossDwordSynchCount);\r\nphy->phy_reset_problem_count =\r\nle32_to_cpu(phy_pg1.PhyResetProblemCount);\r\nreturn 0;\r\n}\r\nstatic int\r\n_transport_get_enclosure_identifier(struct sas_rphy *rphy, u64 *identifier)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = rphy_to_ioc(rphy);\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = __mpt3sas_get_sdev_by_addr(ioc,\r\nrphy->identify.sas_address);\r\nif (sas_device) {\r\n*identifier = sas_device->enclosure_logical_id;\r\nrc = 0;\r\nsas_device_put(sas_device);\r\n} else {\r\n*identifier = 0;\r\nrc = -ENXIO;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_get_bay_identifier(struct sas_rphy *rphy)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = rphy_to_ioc(rphy);\r\nstruct _sas_device *sas_device;\r\nunsigned long flags;\r\nint rc;\r\nspin_lock_irqsave(&ioc->sas_device_lock, flags);\r\nsas_device = __mpt3sas_get_sdev_by_addr(ioc,\r\nrphy->identify.sas_address);\r\nif (sas_device) {\r\nrc = sas_device->slot;\r\nsas_device_put(sas_device);\r\n} else {\r\nrc = -ENXIO;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_device_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_expander_phy_control(struct MPT3SAS_ADAPTER *ioc,\r\nstruct sas_phy *phy, u8 phy_operation)\r\n{\r\nMpi2SmpPassthroughRequest_t *mpi_request;\r\nMpi2SmpPassthroughReply_t *mpi_reply;\r\nstruct phy_control_request *phy_control_request;\r\nstruct phy_control_reply *phy_control_reply;\r\nint rc;\r\nu16 smid;\r\nu32 ioc_state;\r\nvoid *psge;\r\nu8 issue_reset = 0;\r\nvoid *data_out = NULL;\r\ndma_addr_t data_out_dma;\r\nu32 sz;\r\nu16 wait_state_count;\r\nif (ioc->shost_recovery || ioc->pci_error_recovery) {\r\npr_info(MPT3SAS_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&ioc->transport_cmds.mutex);\r\nif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\r\npr_err(MPT3SAS_FMT "%s: transport_cmds in use\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nioc->transport_cmds.status = MPT3_CMD_PENDING;\r\nwait_state_count = 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nssleep(1);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\npr_info(MPT3SAS_FMT\r\n"%s: waiting for operational state(count=%d)\n",\r\nioc->name, __func__, wait_state_count);\r\n}\r\nif (wait_state_count)\r\npr_info(MPT3SAS_FMT "%s: ioc is operational\n",\r\nioc->name, __func__);\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->transport_cmds.smid = smid;\r\nsz = sizeof(struct phy_control_request) +\r\nsizeof(struct phy_control_reply);\r\ndata_out = pci_alloc_consistent(ioc->pdev, sz, &data_out_dma);\r\nif (!data_out) {\r\npr_err("failure at %s:%d/%s()!\n", __FILE__,\r\n__LINE__, __func__);\r\nrc = -ENOMEM;\r\nmpt3sas_base_free_smid(ioc, smid);\r\ngoto out;\r\n}\r\nrc = -EINVAL;\r\nmemset(data_out, 0, sz);\r\nphy_control_request = data_out;\r\nphy_control_request->smp_frame_type = 0x40;\r\nphy_control_request->function = 0x91;\r\nphy_control_request->request_length = 9;\r\nphy_control_request->allocated_response_length = 0;\r\nphy_control_request->phy_identifier = phy->number;\r\nphy_control_request->phy_operation = phy_operation;\r\nphy_control_request->programmed_min_physical_link_rate =\r\nphy->minimum_linkrate << 4;\r\nphy_control_request->programmed_max_physical_link_rate =\r\nphy->maximum_linkrate << 4;\r\nmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\r\nmpi_request->PhysicalPort = 0xFF;\r\nmpi_request->VF_ID = 0;\r\nmpi_request->VP_ID = 0;\r\nmpi_request->SASAddress = cpu_to_le64(phy->identify.sas_address);\r\nmpi_request->RequestDataLength =\r\ncpu_to_le16(sizeof(struct phy_error_log_request));\r\npsge = &mpi_request->SGL;\r\nioc->build_sg(ioc, psge, data_out_dma,\r\nsizeof(struct phy_control_request),\r\ndata_out_dma + sizeof(struct phy_control_request),\r\nsizeof(struct phy_control_reply));\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_control - send to sas_addr(0x%016llx), phy(%d), opcode(%d)\n",\r\nioc->name, (unsigned long long)phy->identify.sas_address,\r\nphy->number, phy_operation));\r\ninit_completion(&ioc->transport_cmds.done);\r\nioc->put_smid_default(ioc, smid);\r\nwait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s: timeout\n",\r\nioc->name, __func__);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SmpPassthroughRequest_t)/4);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_control - complete\n", ioc->name));\r\nif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\r\nmpi_reply = ioc->transport_cmds.reply;\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_control - reply data transfer size(%d)\n",\r\nioc->name, le16_to_cpu(mpi_reply->ResponseDataLength)));\r\nif (le16_to_cpu(mpi_reply->ResponseDataLength) !=\r\nsizeof(struct phy_control_reply))\r\ngoto out;\r\nphy_control_reply = data_out +\r\nsizeof(struct phy_control_request);\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_control - function_result(%d)\n",\r\nioc->name, phy_control_reply->function_result));\r\nrc = 0;\r\n} else\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"phy_control - no reply\n", ioc->name));\r\nissue_host_reset:\r\nif (issue_reset)\r\nmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\r\nout:\r\nioc->transport_cmds.status = MPT3_CMD_NOT_USED;\r\nif (data_out)\r\npci_free_consistent(ioc->pdev, sz, data_out, data_out_dma);\r\nmutex_unlock(&ioc->transport_cmds.mutex);\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_phy_reset(struct sas_phy *phy, int hard_reset)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\r\nMpi2SasIoUnitControlReply_t mpi_reply;\r\nMpi2SasIoUnitControlRequest_t mpi_request;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nif (_transport_sas_node_find_by_sas_address(ioc,\r\nphy->identify.sas_address) == NULL) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (phy->identify.sas_address != ioc->sas_hba.sas_address)\r\nreturn _transport_expander_phy_control(ioc, phy,\r\n(hard_reset == 1) ? SMP_PHY_CONTROL_HARD_RESET :\r\nSMP_PHY_CONTROL_LINK_RESET);\r\nmemset(&mpi_request, 0, sizeof(Mpi2SasIoUnitControlRequest_t));\r\nmpi_request.Function = MPI2_FUNCTION_SAS_IO_UNIT_CONTROL;\r\nmpi_request.Operation = hard_reset ?\r\nMPI2_SAS_OP_PHY_HARD_RESET : MPI2_SAS_OP_PHY_LINK_RESET;\r\nmpi_request.PhyNum = phy->number;\r\nif ((mpt3sas_base_sas_iounit_control(ioc, &mpi_reply, &mpi_request))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nreturn -ENXIO;\r\n}\r\nif (mpi_reply.IOCStatus || mpi_reply.IOCLogInfo)\r\npr_info(MPT3SAS_FMT\r\n"phy(%d), ioc_status(0x%04x), loginfo(0x%08x)\n",\r\nioc->name, phy->number, le16_to_cpu(mpi_reply.IOCStatus),\r\nle32_to_cpu(mpi_reply.IOCLogInfo));\r\nreturn 0;\r\n}\r\nstatic int\r\n_transport_phy_enable(struct sas_phy *phy, int enable)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\r\nMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\r\nMpi2SasIOUnitPage0_t *sas_iounit_pg0 = NULL;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 ioc_status;\r\nu16 sz;\r\nint rc = 0;\r\nunsigned long flags;\r\nint i, discovery_active;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nif (_transport_sas_node_find_by_sas_address(ioc,\r\nphy->identify.sas_address) == NULL) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (phy->identify.sas_address != ioc->sas_hba.sas_address)\r\nreturn _transport_expander_phy_control(ioc, phy,\r\n(enable == 1) ? SMP_PHY_CONTROL_LINK_RESET :\r\nSMP_PHY_CONTROL_DISABLE);\r\nsz = offsetof(Mpi2SasIOUnitPage0_t, PhyData) + (ioc->sas_hba.num_phys *\r\nsizeof(Mpi2SasIOUnit0PhyData_t));\r\nsas_iounit_pg0 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg0) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif ((mpt3sas_config_get_sas_iounit_pg0(ioc, &mpi_reply,\r\nsas_iounit_pg0, sz))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENXIO;\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nfor (i = 0, discovery_active = 0; i < ioc->sas_hba.num_phys ; i++) {\r\nif (sas_iounit_pg0->PhyData[i].PortFlags &\r\nMPI2_SASIOUNIT0_PORTFLAGS_DISCOVERY_IN_PROGRESS) {\r\npr_err(MPT3SAS_FMT "discovery is active on " \\r\n"port = %d, phy = %d: unable to enable/disable "\r\n"phys, try again later!\n", ioc->name,\r\nsas_iounit_pg0->PhyData[i].Port, i);\r\ndiscovery_active = 1;\r\n}\r\n}\r\nif (discovery_active) {\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\r\nsizeof(Mpi2SasIOUnit1PhyData_t));\r\nsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg1) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\r\nsas_iounit_pg1, sz))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENXIO;\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ioc->sas_hba.num_phys ; i++) {\r\nsas_iounit_pg1->PhyData[i].Port =\r\nsas_iounit_pg0->PhyData[i].Port;\r\nsas_iounit_pg1->PhyData[i].PortFlags =\r\n(sas_iounit_pg0->PhyData[i].PortFlags &\r\nMPI2_SASIOUNIT0_PORTFLAGS_AUTO_PORT_CONFIG);\r\nsas_iounit_pg1->PhyData[i].PhyFlags =\r\n(sas_iounit_pg0->PhyData[i].PhyFlags &\r\n(MPI2_SASIOUNIT0_PHYFLAGS_ZONING_ENABLED +\r\nMPI2_SASIOUNIT0_PHYFLAGS_PHY_DISABLED));\r\n}\r\nif (enable)\r\nsas_iounit_pg1->PhyData[phy->number].PhyFlags\r\n&= ~MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;\r\nelse\r\nsas_iounit_pg1->PhyData[phy->number].PhyFlags\r\n|= MPI2_SASIOUNIT1_PHYFLAGS_PHY_DISABLE;\r\nmpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1, sz);\r\nif (enable)\r\n_transport_phy_reset(phy, 0);\r\nout:\r\nkfree(sas_iounit_pg1);\r\nkfree(sas_iounit_pg0);\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_phy_speed(struct sas_phy *phy, struct sas_phy_linkrates *rates)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = phy_to_ioc(phy);\r\nMpi2SasIOUnitPage1_t *sas_iounit_pg1 = NULL;\r\nMpi2SasPhyPage0_t phy_pg0;\r\nMpi2ConfigReply_t mpi_reply;\r\nu16 ioc_status;\r\nu16 sz;\r\nint i;\r\nint rc = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ioc->sas_node_lock, flags);\r\nif (_transport_sas_node_find_by_sas_address(ioc,\r\nphy->identify.sas_address) == NULL) {\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock_irqrestore(&ioc->sas_node_lock, flags);\r\nif (!rates->minimum_linkrate)\r\nrates->minimum_linkrate = phy->minimum_linkrate;\r\nelse if (rates->minimum_linkrate < phy->minimum_linkrate_hw)\r\nrates->minimum_linkrate = phy->minimum_linkrate_hw;\r\nif (!rates->maximum_linkrate)\r\nrates->maximum_linkrate = phy->maximum_linkrate;\r\nelse if (rates->maximum_linkrate > phy->maximum_linkrate_hw)\r\nrates->maximum_linkrate = phy->maximum_linkrate_hw;\r\nif (phy->identify.sas_address != ioc->sas_hba.sas_address) {\r\nphy->minimum_linkrate = rates->minimum_linkrate;\r\nphy->maximum_linkrate = rates->maximum_linkrate;\r\nreturn _transport_expander_phy_control(ioc, phy,\r\nSMP_PHY_CONTROL_LINK_RESET);\r\n}\r\nsz = offsetof(Mpi2SasIOUnitPage1_t, PhyData) + (ioc->sas_hba.num_phys *\r\nsizeof(Mpi2SasIOUnit1PhyData_t));\r\nsas_iounit_pg1 = kzalloc(sz, GFP_KERNEL);\r\nif (!sas_iounit_pg1) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif ((mpt3sas_config_get_sas_iounit_pg1(ioc, &mpi_reply,\r\nsas_iounit_pg1, sz))) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENXIO;\r\ngoto out;\r\n}\r\nioc_status = le16_to_cpu(mpi_reply.IOCStatus) &\r\nMPI2_IOCSTATUS_MASK;\r\nif (ioc_status != MPI2_IOCSTATUS_SUCCESS) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -EIO;\r\ngoto out;\r\n}\r\nfor (i = 0; i < ioc->sas_hba.num_phys; i++) {\r\nif (phy->number != i) {\r\nsas_iounit_pg1->PhyData[i].MaxMinLinkRate =\r\n(ioc->sas_hba.phy[i].phy->minimum_linkrate +\r\n(ioc->sas_hba.phy[i].phy->maximum_linkrate << 4));\r\n} else {\r\nsas_iounit_pg1->PhyData[i].MaxMinLinkRate =\r\n(rates->minimum_linkrate +\r\n(rates->maximum_linkrate << 4));\r\n}\r\n}\r\nif (mpt3sas_config_set_sas_iounit_pg1(ioc, &mpi_reply, sas_iounit_pg1,\r\nsz)) {\r\npr_err(MPT3SAS_FMT "failure at %s:%d/%s()!\n",\r\nioc->name, __FILE__, __LINE__, __func__);\r\nrc = -ENXIO;\r\ngoto out;\r\n}\r\n_transport_phy_reset(phy, 0);\r\nif (!mpt3sas_config_get_phy_pg0(ioc, &mpi_reply, &phy_pg0,\r\nphy->number)) {\r\nphy->minimum_linkrate = _transport_convert_phy_link_rate(\r\nphy_pg0.ProgrammedLinkRate & MPI2_SAS_PRATE_MIN_RATE_MASK);\r\nphy->maximum_linkrate = _transport_convert_phy_link_rate(\r\nphy_pg0.ProgrammedLinkRate >> 4);\r\nphy->negotiated_linkrate = _transport_convert_phy_link_rate(\r\nphy_pg0.NegotiatedLinkRate &\r\nMPI2_SAS_NEG_LINK_RATE_MASK_PHYSICAL);\r\n}\r\nout:\r\nkfree(sas_iounit_pg1);\r\nreturn rc;\r\n}\r\nstatic int\r\n_transport_smp_handler(struct Scsi_Host *shost, struct sas_rphy *rphy,\r\nstruct request *req)\r\n{\r\nstruct MPT3SAS_ADAPTER *ioc = shost_priv(shost);\r\nMpi2SmpPassthroughRequest_t *mpi_request;\r\nMpi2SmpPassthroughReply_t *mpi_reply;\r\nint rc;\r\nu16 smid;\r\nu32 ioc_state;\r\nvoid *psge;\r\nu8 issue_reset = 0;\r\ndma_addr_t dma_addr_in = 0;\r\ndma_addr_t dma_addr_out = 0;\r\ndma_addr_t pci_dma_in = 0;\r\ndma_addr_t pci_dma_out = 0;\r\nvoid *pci_addr_in = NULL;\r\nvoid *pci_addr_out = NULL;\r\nu16 wait_state_count;\r\nstruct request *rsp = req->next_rq;\r\nstruct bio_vec bvec;\r\nstruct bvec_iter iter;\r\nif (!rsp) {\r\npr_err(MPT3SAS_FMT "%s: the smp response space is missing\n",\r\nioc->name, __func__);\r\nreturn -EINVAL;\r\n}\r\nif (ioc->shost_recovery || ioc->pci_error_recovery) {\r\npr_info(MPT3SAS_FMT "%s: host reset in progress!\n",\r\n__func__, ioc->name);\r\nreturn -EFAULT;\r\n}\r\nrc = mutex_lock_interruptible(&ioc->transport_cmds.mutex);\r\nif (rc)\r\nreturn rc;\r\nif (ioc->transport_cmds.status != MPT3_CMD_NOT_USED) {\r\npr_err(MPT3SAS_FMT "%s: transport_cmds in use\n", ioc->name,\r\n__func__);\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nioc->transport_cmds.status = MPT3_CMD_PENDING;\r\nif (bio_multiple_segments(req->bio)) {\r\nu32 offset = 0;\r\npci_addr_out = pci_alloc_consistent(ioc->pdev,\r\nblk_rq_bytes(req), &pci_dma_out);\r\nif (!pci_addr_out) {\r\npr_info(MPT3SAS_FMT "%s(): PCI Addr out = NULL\n",\r\nioc->name, __func__);\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nbio_for_each_segment(bvec, req->bio, iter) {\r\nmemcpy(pci_addr_out + offset,\r\npage_address(bvec.bv_page) + bvec.bv_offset,\r\nbvec.bv_len);\r\noffset += bvec.bv_len;\r\n}\r\n} else {\r\ndma_addr_out = pci_map_single(ioc->pdev, bio_data(req->bio),\r\nblk_rq_bytes(req), PCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(ioc->pdev, dma_addr_out)) {\r\npr_info(MPT3SAS_FMT "%s(): DMA Addr out = NULL\n",\r\nioc->name, __func__);\r\nrc = -ENOMEM;\r\ngoto free_pci;\r\n}\r\n}\r\nif (bio_multiple_segments(rsp->bio)) {\r\npci_addr_in = pci_alloc_consistent(ioc->pdev, blk_rq_bytes(rsp),\r\n&pci_dma_in);\r\nif (!pci_addr_in) {\r\npr_info(MPT3SAS_FMT "%s(): PCI Addr in = NULL\n",\r\nioc->name, __func__);\r\nrc = -ENOMEM;\r\ngoto unmap;\r\n}\r\n} else {\r\ndma_addr_in = pci_map_single(ioc->pdev, bio_data(rsp->bio),\r\nblk_rq_bytes(rsp), PCI_DMA_BIDIRECTIONAL);\r\nif (pci_dma_mapping_error(ioc->pdev, dma_addr_in)) {\r\npr_info(MPT3SAS_FMT "%s(): DMA Addr in = NULL\n",\r\nioc->name, __func__);\r\nrc = -ENOMEM;\r\ngoto unmap;\r\n}\r\n}\r\nwait_state_count = 0;\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\nwhile (ioc_state != MPI2_IOC_STATE_OPERATIONAL) {\r\nif (wait_state_count++ == 10) {\r\npr_err(MPT3SAS_FMT\r\n"%s: failed due to ioc not operational\n",\r\nioc->name, __func__);\r\nrc = -EFAULT;\r\ngoto unmap;\r\n}\r\nssleep(1);\r\nioc_state = mpt3sas_base_get_iocstate(ioc, 1);\r\npr_info(MPT3SAS_FMT\r\n"%s: waiting for operational state(count=%d)\n",\r\nioc->name, __func__, wait_state_count);\r\n}\r\nif (wait_state_count)\r\npr_info(MPT3SAS_FMT "%s: ioc is operational\n",\r\nioc->name, __func__);\r\nsmid = mpt3sas_base_get_smid(ioc, ioc->transport_cb_idx);\r\nif (!smid) {\r\npr_err(MPT3SAS_FMT "%s: failed obtaining a smid\n",\r\nioc->name, __func__);\r\nrc = -EAGAIN;\r\ngoto unmap;\r\n}\r\nrc = 0;\r\nmpi_request = mpt3sas_base_get_msg_frame(ioc, smid);\r\nioc->transport_cmds.smid = smid;\r\nmemset(mpi_request, 0, sizeof(Mpi2SmpPassthroughRequest_t));\r\nmpi_request->Function = MPI2_FUNCTION_SMP_PASSTHROUGH;\r\nmpi_request->PhysicalPort = 0xFF;\r\nmpi_request->SASAddress = (rphy) ?\r\ncpu_to_le64(rphy->identify.sas_address) :\r\ncpu_to_le64(ioc->sas_hba.sas_address);\r\nmpi_request->RequestDataLength = cpu_to_le16(blk_rq_bytes(req) - 4);\r\npsge = &mpi_request->SGL;\r\nif (bio_multiple_segments(req->bio))\r\nioc->build_sg(ioc, psge, pci_dma_out, (blk_rq_bytes(req) - 4),\r\npci_dma_in, (blk_rq_bytes(rsp) + 4));\r\nelse\r\nioc->build_sg(ioc, psge, dma_addr_out, (blk_rq_bytes(req) - 4),\r\ndma_addr_in, (blk_rq_bytes(rsp) + 4));\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s - sending smp request\n", ioc->name, __func__));\r\ninit_completion(&ioc->transport_cmds.done);\r\nioc->put_smid_default(ioc, smid);\r\nwait_for_completion_timeout(&ioc->transport_cmds.done, 10*HZ);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_COMPLETE)) {\r\npr_err(MPT3SAS_FMT "%s : timeout\n",\r\n__func__, ioc->name);\r\n_debug_dump_mf(mpi_request,\r\nsizeof(Mpi2SmpPassthroughRequest_t)/4);\r\nif (!(ioc->transport_cmds.status & MPT3_CMD_RESET))\r\nissue_reset = 1;\r\ngoto issue_host_reset;\r\n}\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s - complete\n", ioc->name, __func__));\r\nif (ioc->transport_cmds.status & MPT3_CMD_REPLY_VALID) {\r\nmpi_reply = ioc->transport_cmds.reply;\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s - reply data transfer size(%d)\n",\r\nioc->name, __func__,\r\nle16_to_cpu(mpi_reply->ResponseDataLength)));\r\nmemcpy(scsi_req(req)->sense, mpi_reply, sizeof(*mpi_reply));\r\nscsi_req(req)->sense_len = sizeof(*mpi_reply);\r\nscsi_req(req)->resid_len = 0;\r\nscsi_req(rsp)->resid_len -=\r\nle16_to_cpu(mpi_reply->ResponseDataLength);\r\nif (bio_multiple_segments(rsp->bio)) {\r\nu32 offset = 0;\r\nu32 bytes_to_copy =\r\nle16_to_cpu(mpi_reply->ResponseDataLength);\r\nbio_for_each_segment(bvec, rsp->bio, iter) {\r\nif (bytes_to_copy <= bvec.bv_len) {\r\nmemcpy(page_address(bvec.bv_page) +\r\nbvec.bv_offset, pci_addr_in +\r\noffset, bytes_to_copy);\r\nbreak;\r\n} else {\r\nmemcpy(page_address(bvec.bv_page) +\r\nbvec.bv_offset, pci_addr_in +\r\noffset, bvec.bv_len);\r\nbytes_to_copy -= bvec.bv_len;\r\n}\r\noffset += bvec.bv_len;\r\n}\r\n}\r\n} else {\r\ndtransportprintk(ioc, pr_info(MPT3SAS_FMT\r\n"%s - no reply\n", ioc->name, __func__));\r\nrc = -ENXIO;\r\n}\r\nissue_host_reset:\r\nif (issue_reset) {\r\nmpt3sas_base_hard_reset_handler(ioc, FORCE_BIG_HAMMER);\r\nrc = -ETIMEDOUT;\r\n}\r\nunmap:\r\nif (dma_addr_out)\r\npci_unmap_single(ioc->pdev, dma_addr_out, blk_rq_bytes(req),\r\nPCI_DMA_BIDIRECTIONAL);\r\nif (dma_addr_in)\r\npci_unmap_single(ioc->pdev, dma_addr_in, blk_rq_bytes(rsp),\r\nPCI_DMA_BIDIRECTIONAL);\r\nfree_pci:\r\nif (pci_addr_out)\r\npci_free_consistent(ioc->pdev, blk_rq_bytes(req), pci_addr_out,\r\npci_dma_out);\r\nif (pci_addr_in)\r\npci_free_consistent(ioc->pdev, blk_rq_bytes(rsp), pci_addr_in,\r\npci_dma_in);\r\nout:\r\nioc->transport_cmds.status = MPT3_CMD_NOT_USED;\r\nmutex_unlock(&ioc->transport_cmds.mutex);\r\nreturn rc;\r\n}
