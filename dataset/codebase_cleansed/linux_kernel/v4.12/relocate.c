int __weak plat_post_relocation(long offset)\r\n{\r\nreturn 0;\r\n}\r\nstatic inline u32 __init get_synci_step(void)\r\n{\r\nu32 res;\r\n__asm__("rdhwr %0, $1" : "=r" (res));\r\nreturn res;\r\n}\r\nstatic void __init sync_icache(void *kbase, unsigned long kernel_length)\r\n{\r\nvoid *kend = kbase + kernel_length;\r\nu32 step = get_synci_step();\r\ndo {\r\n__asm__ __volatile__(\r\n"synci 0(%0)"\r\n:\r\n: "r" (kbase));\r\nkbase += step;\r\n} while (kbase < kend);\r\n__sync();\r\n}\r\nstatic int __init apply_r_mips_64_rel(u32 *loc_orig, u32 *loc_new, long offset)\r\n{\r\n*(u64 *)loc_new += offset;\r\nreturn 0;\r\n}\r\nstatic int __init apply_r_mips_32_rel(u32 *loc_orig, u32 *loc_new, long offset)\r\n{\r\n*loc_new += offset;\r\nreturn 0;\r\n}\r\nstatic int __init apply_r_mips_26_rel(u32 *loc_orig, u32 *loc_new, long offset)\r\n{\r\nunsigned long target_addr = (*loc_orig) & 0x03ffffff;\r\nif (offset % 4) {\r\npr_err("Dangerous R_MIPS_26 REL relocation\n");\r\nreturn -ENOEXEC;\r\n}\r\ntarget_addr <<= 2;\r\ntarget_addr += (unsigned long)loc_orig & ~0x03ffffff;\r\ntarget_addr += offset;\r\nif ((target_addr & 0xf0000000) != ((unsigned long)loc_new & 0xf0000000)) {\r\npr_err("R_MIPS_26 REL relocation overflow\n");\r\nreturn -ENOEXEC;\r\n}\r\ntarget_addr -= (unsigned long)loc_new & ~0x03ffffff;\r\ntarget_addr >>= 2;\r\n*loc_new = (*loc_new & ~0x03ffffff) | (target_addr & 0x03ffffff);\r\nreturn 0;\r\n}\r\nstatic int __init apply_r_mips_hi16_rel(u32 *loc_orig, u32 *loc_new, long offset)\r\n{\r\nunsigned long insn = *loc_orig;\r\nunsigned long target = (insn & 0xffff) << 16;\r\ntarget += offset;\r\n*loc_new = (insn & ~0xffff) | ((target >> 16) & 0xffff);\r\nreturn 0;\r\n}\r\nint __init do_relocations(void *kbase_old, void *kbase_new, long offset)\r\n{\r\nu32 *r;\r\nu32 *loc_orig;\r\nu32 *loc_new;\r\nint type;\r\nint res;\r\nfor (r = _relocation_start; r < _relocation_end; r++) {\r\nif (*r == 0)\r\nbreak;\r\ntype = (*r >> 24) & 0xff;\r\nloc_orig = (void *)(kbase_old + ((*r & 0x00ffffff) << 2));\r\nloc_new = RELOCATED(loc_orig);\r\nif (reloc_handlers_rel[type] == NULL) {\r\npr_err("Unhandled relocation type %d at 0x%pK\n",\r\ntype, loc_orig);\r\nreturn -ENOEXEC;\r\n}\r\nres = reloc_handlers_rel[type](loc_orig, loc_new, offset);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init relocate_exception_table(long offset)\r\n{\r\nunsigned long *etable_start, *etable_end, *e;\r\netable_start = RELOCATED(&__start___ex_table);\r\netable_end = RELOCATED(&__stop___ex_table);\r\nfor (e = etable_start; e < etable_end; e++)\r\n*e += offset;\r\nreturn 0;\r\n}\r\nstatic inline __init unsigned long rotate_xor(unsigned long hash,\r\nconst void *area, size_t size)\r\n{\r\nsize_t i;\r\nunsigned long *ptr = (unsigned long *)area;\r\nfor (i = 0; i < size / sizeof(hash); i++) {\r\nhash = (hash << ((sizeof(hash) * 8) - 7)) | (hash >> 7);\r\nhash ^= ptr[i];\r\n}\r\nreturn hash;\r\n}\r\nstatic inline __init unsigned long get_random_boot(void)\r\n{\r\nunsigned long entropy = random_get_entropy();\r\nunsigned long hash = 0;\r\nhash = rotate_xor(hash, linux_banner, strlen(linux_banner));\r\nhash = rotate_xor(hash, &entropy, sizeof(entropy));\r\n#if defined(CONFIG_USE_OF)\r\nif (initial_boot_params) {\r\nint node, len;\r\nu64 *prop;\r\nnode = fdt_path_offset(initial_boot_params, "/chosen");\r\nif (node >= 0) {\r\nprop = fdt_getprop_w(initial_boot_params, node,\r\n"kaslr-seed", &len);\r\nif (prop && (len == sizeof(u64)))\r\nhash = rotate_xor(hash, prop, sizeof(*prop));\r\n}\r\n}\r\n#endif\r\nreturn hash;\r\n}\r\nstatic inline __init bool kaslr_disabled(void)\r\n{\r\nchar *str;\r\n#if defined(CONFIG_CMDLINE_BOOL)\r\nconst char *builtin_cmdline = CONFIG_CMDLINE;\r\nstr = strstr(builtin_cmdline, "nokaslr");\r\nif (str == builtin_cmdline ||\r\n(str > builtin_cmdline && *(str - 1) == ' '))\r\nreturn true;\r\n#endif\r\nstr = strstr(arcs_cmdline, "nokaslr");\r\nif (str == arcs_cmdline || (str > arcs_cmdline && *(str - 1) == ' '))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline void __init *determine_relocation_address(void)\r\n{\r\nunsigned long kernel_length;\r\nvoid *dest = &_text;\r\nunsigned long offset;\r\nif (kaslr_disabled())\r\nreturn dest;\r\nkernel_length = (long)_end - (long)(&_text);\r\noffset = get_random_boot() << 16;\r\noffset &= (CONFIG_RANDOMIZE_BASE_MAX_OFFSET - 1);\r\nif (offset < kernel_length)\r\noffset += ALIGN(kernel_length, 0xffff);\r\nreturn RELOCATED(dest);\r\n}\r\nstatic inline void __init *determine_relocation_address(void)\r\n{\r\nreturn (void *)0xffffffff81000000;\r\n}\r\nstatic inline int __init relocation_addr_valid(void *loc_new)\r\n{\r\nif ((unsigned long)loc_new & 0x0000ffff) {\r\nreturn 0;\r\n}\r\nif ((unsigned long)loc_new < (unsigned long)&_end) {\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nvoid *__init relocate_kernel(void)\r\n{\r\nvoid *loc_new;\r\nunsigned long kernel_length;\r\nunsigned long bss_length;\r\nlong offset = 0;\r\nint res = 1;\r\nvoid *kernel_entry = start_kernel;\r\nvoid *fdt = NULL;\r\nfw_init_cmdline();\r\n#if defined(CONFIG_USE_OF)\r\nfdt = plat_get_fdt();\r\nearly_init_dt_scan(fdt);\r\nif (boot_command_line[0]) {\r\nstrlcpy(arcs_cmdline, boot_command_line, COMMAND_LINE_SIZE);\r\n}\r\n#endif\r\nkernel_length = (long)(&_relocation_start) - (long)(&_text);\r\nbss_length = (long)&__bss_stop - (long)&__bss_start;\r\nloc_new = determine_relocation_address();\r\nif (relocation_addr_valid(loc_new))\r\noffset = (unsigned long)loc_new - (unsigned long)(&_text);\r\narcs_cmdline[0] = '\0';\r\nif (offset) {\r\nvoid (*fdt_relocated_)(void *) = NULL;\r\n#if defined(CONFIG_USE_OF)\r\nunsigned long fdt_phys = virt_to_phys(fdt);\r\nif (fdt_phys >= virt_to_phys(RELOCATED(&_text)) &&\r\nfdt_phys <= virt_to_phys(RELOCATED(&_end))) {\r\nvoid *fdt_relocated =\r\nRELOCATED(ALIGN((long)&_end, PAGE_SIZE));\r\nmemcpy(fdt_relocated, fdt, fdt_totalsize(fdt));\r\nfdt = fdt_relocated;\r\nfdt_relocated_ = RELOCATED(&plat_fdt_relocated);\r\n}\r\n#endif\r\nmemcpy(loc_new, &_text, kernel_length);\r\nres = do_relocations(&_text, loc_new, offset);\r\nif (res < 0)\r\ngoto out;\r\nsync_icache(loc_new, kernel_length);\r\nres = relocate_exception_table(offset);\r\nif (res < 0)\r\ngoto out;\r\nmemcpy(RELOCATED(&__bss_start), &__bss_start, bss_length);\r\nif (fdt_relocated_)\r\nfdt_relocated_(fdt);\r\nif (plat_post_relocation(offset))\r\ngoto out;\r\n__current_thread_info = RELOCATED(&init_thread_union);\r\nkernel_entry = RELOCATED(start_kernel);\r\n}\r\nout:\r\nreturn kernel_entry;\r\n}\r\nvoid show_kernel_relocation(const char *level)\r\n{\r\nunsigned long offset;\r\noffset = __pa_symbol(_text) - __pa_symbol(VMLINUX_LOAD_ADDRESS);\r\nif (IS_ENABLED(CONFIG_RELOCATABLE) && offset > 0) {\r\nprintk(level);\r\npr_cont("Kernel relocated by 0x%pK\n", (void *)offset);\r\npr_cont(" .text @ 0x%pK\n", _text);\r\npr_cont(" .data @ 0x%pK\n", _sdata);\r\npr_cont(" .bss @ 0x%pK\n", __bss_start);\r\n}\r\n}\r\nstatic int kernel_location_notifier_fn(struct notifier_block *self,\r\nunsigned long v, void *p)\r\n{\r\nshow_kernel_relocation(KERN_EMERG);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init register_kernel_offset_dumper(void)\r\n{\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&kernel_location_notifier);\r\nreturn 0;\r\n}
