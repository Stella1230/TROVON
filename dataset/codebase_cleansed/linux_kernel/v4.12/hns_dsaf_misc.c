static void dsaf_write_sub(struct dsaf_device *dsaf_dev, u32 reg, u32 val)\r\n{\r\nif (dsaf_dev->sub_ctrl)\r\ndsaf_write_syscon(dsaf_dev->sub_ctrl, reg, val);\r\nelse\r\ndsaf_write_reg(dsaf_dev->sc_base, reg, val);\r\n}\r\nstatic u32 dsaf_read_sub(struct dsaf_device *dsaf_dev, u32 reg)\r\n{\r\nu32 ret;\r\nif (dsaf_dev->sub_ctrl)\r\nret = dsaf_read_syscon(dsaf_dev->sub_ctrl, reg);\r\nelse\r\nret = dsaf_read_reg(dsaf_dev->sc_base, reg);\r\nreturn ret;\r\n}\r\nstatic void hns_cpld_set_led(struct hns_mac_cb *mac_cb, int link_status,\r\nu16 speed, int data)\r\n{\r\nint speed_reg = 0;\r\nu8 value;\r\nif (!mac_cb) {\r\npr_err("sfp_led_opt mac_dev is null!\n");\r\nreturn;\r\n}\r\nif (!mac_cb->cpld_ctrl) {\r\ndev_err(mac_cb->dev, "mac_id=%d, cpld syscon is null !\n",\r\nmac_cb->mac_id);\r\nreturn;\r\n}\r\nif (speed == MAC_SPEED_10000)\r\nspeed_reg = 1;\r\nvalue = mac_cb->cpld_led_value;\r\nif (link_status) {\r\ndsaf_set_bit(value, DSAF_LED_LINK_B, link_status);\r\ndsaf_set_field(value, DSAF_LED_SPEED_M,\r\nDSAF_LED_SPEED_S, speed_reg);\r\ndsaf_set_bit(value, DSAF_LED_DATA_B, data);\r\nif (value != mac_cb->cpld_led_value) {\r\ndsaf_write_syscon(mac_cb->cpld_ctrl,\r\nmac_cb->cpld_ctrl_reg, value);\r\nmac_cb->cpld_led_value = value;\r\n}\r\n} else {\r\nvalue = (mac_cb->cpld_led_value) & (0x1 << DSAF_LED_ANCHOR_B);\r\ndsaf_write_syscon(mac_cb->cpld_ctrl,\r\nmac_cb->cpld_ctrl_reg, value);\r\nmac_cb->cpld_led_value = value;\r\n}\r\n}\r\nstatic void cpld_led_reset(struct hns_mac_cb *mac_cb)\r\n{\r\nif (!mac_cb || !mac_cb->cpld_ctrl)\r\nreturn;\r\ndsaf_write_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\r\nCPLD_LED_DEFAULT_VALUE);\r\nmac_cb->cpld_led_value = CPLD_LED_DEFAULT_VALUE;\r\n}\r\nstatic int cpld_set_led_id(struct hns_mac_cb *mac_cb,\r\nenum hnae_led_state status)\r\n{\r\nswitch (status) {\r\ncase HNAE_LED_ACTIVE:\r\nmac_cb->cpld_led_value =\r\ndsaf_read_syscon(mac_cb->cpld_ctrl,\r\nmac_cb->cpld_ctrl_reg);\r\ndsaf_set_bit(mac_cb->cpld_led_value, DSAF_LED_ANCHOR_B,\r\nCPLD_LED_ON_VALUE);\r\ndsaf_write_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\r\nmac_cb->cpld_led_value);\r\nbreak;\r\ncase HNAE_LED_INACTIVE:\r\ndsaf_set_bit(mac_cb->cpld_led_value, DSAF_LED_ANCHOR_B,\r\nCPLD_LED_DEFAULT_VALUE);\r\ndsaf_write_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg,\r\nmac_cb->cpld_led_value);\r\nbreak;\r\ndefault:\r\ndev_err(mac_cb->dev, "invalid led state: %d!", status);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hns_dsaf_acpi_srst_by_port(struct dsaf_device *dsaf_dev, u8 op_type,\r\nu32 port_type, u32 port, u32 val)\r\n{\r\nunion acpi_object *obj;\r\nunion acpi_object obj_args[3], argv4;\r\nobj_args[0].integer.type = ACPI_TYPE_INTEGER;\r\nobj_args[0].integer.value = port_type;\r\nobj_args[1].integer.type = ACPI_TYPE_INTEGER;\r\nobj_args[1].integer.value = port;\r\nobj_args[2].integer.type = ACPI_TYPE_INTEGER;\r\nobj_args[2].integer.value = val;\r\nargv4.type = ACPI_TYPE_PACKAGE;\r\nargv4.package.count = 3;\r\nargv4.package.elements = obj_args;\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(dsaf_dev->dev),\r\nhns_dsaf_acpi_dsm_uuid, 0, op_type, &argv4);\r\nif (!obj) {\r\ndev_warn(dsaf_dev->dev, "reset port_type%d port%d fail!",\r\nport_type, port);\r\nreturn;\r\n}\r\nACPI_FREE(obj);\r\n}\r\nstatic void hns_dsaf_rst(struct dsaf_device *dsaf_dev, bool dereset)\r\n{\r\nu32 xbar_reg_addr;\r\nu32 nt_reg_addr;\r\nif (!dereset) {\r\nxbar_reg_addr = DSAF_SUB_SC_XBAR_RESET_REQ_REG;\r\nnt_reg_addr = DSAF_SUB_SC_NT_RESET_REQ_REG;\r\n} else {\r\nxbar_reg_addr = DSAF_SUB_SC_XBAR_RESET_DREQ_REG;\r\nnt_reg_addr = DSAF_SUB_SC_NT_RESET_DREQ_REG;\r\n}\r\ndsaf_write_sub(dsaf_dev, xbar_reg_addr, RESET_REQ_OR_DREQ);\r\ndsaf_write_sub(dsaf_dev, nt_reg_addr, RESET_REQ_OR_DREQ);\r\n}\r\nstatic void hns_dsaf_rst_acpi(struct dsaf_device *dsaf_dev, bool dereset)\r\n{\r\nhns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\r\nHNS_DSAF_RESET_FUNC,\r\n0, dereset);\r\n}\r\nstatic void hns_dsaf_xge_srst_by_port(struct dsaf_device *dsaf_dev, u32 port,\r\nbool dereset)\r\n{\r\nu32 reg_val = 0;\r\nu32 reg_addr;\r\nif (port >= DSAF_XGE_NUM)\r\nreturn;\r\nreg_val |= RESET_REQ_OR_DREQ;\r\nreg_val |= 0x2082082 << dsaf_dev->mac_cb[port]->port_rst_off;\r\nif (!dereset)\r\nreg_addr = DSAF_SUB_SC_XGE_RESET_REQ_REG;\r\nelse\r\nreg_addr = DSAF_SUB_SC_XGE_RESET_DREQ_REG;\r\ndsaf_write_sub(dsaf_dev, reg_addr, reg_val);\r\n}\r\nstatic void hns_dsaf_xge_srst_by_port_acpi(struct dsaf_device *dsaf_dev,\r\nu32 port, bool dereset)\r\n{\r\nhns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\r\nHNS_XGE_RESET_FUNC, port, dereset);\r\n}\r\nvoid hns_dsaf_srst_chns(struct dsaf_device *dsaf_dev, u32 msk, bool dereset)\r\n{\r\nu32 reg_addr;\r\nif (!dereset)\r\nreg_addr = DSAF_SUB_SC_DSAF_RESET_REQ_REG;\r\nelse\r\nreg_addr = DSAF_SUB_SC_DSAF_RESET_DREQ_REG;\r\ndsaf_write_sub(dsaf_dev, reg_addr, msk);\r\n}\r\nvoid\r\nhns_dsaf_srst_chns_acpi(struct dsaf_device *dsaf_dev, u32 msk, bool dereset)\r\n{\r\nhns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\r\nHNS_DSAF_CHN_RESET_FUNC,\r\nmsk, dereset);\r\n}\r\nvoid hns_dsaf_roce_srst(struct dsaf_device *dsaf_dev, bool dereset)\r\n{\r\nif (!dereset) {\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_ROCEE_RESET_REQ_REG, 1);\r\n} else {\r\ndsaf_write_sub(dsaf_dev,\r\nDSAF_SUB_SC_ROCEE_CLK_DIS_REG, 1);\r\ndsaf_write_sub(dsaf_dev,\r\nDSAF_SUB_SC_ROCEE_RESET_DREQ_REG, 1);\r\nmsleep(20);\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_ROCEE_CLK_EN_REG, 1);\r\n}\r\n}\r\nvoid hns_dsaf_roce_srst_acpi(struct dsaf_device *dsaf_dev, bool dereset)\r\n{\r\nhns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\r\nHNS_ROCE_RESET_FUNC, 0, dereset);\r\n}\r\nstatic void hns_dsaf_ge_srst_by_port(struct dsaf_device *dsaf_dev, u32 port,\r\nbool dereset)\r\n{\r\nu32 reg_val_1;\r\nu32 reg_val_2;\r\nu32 port_rst_off;\r\nif (port >= DSAF_GE_NUM)\r\nreturn;\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\r\nreg_val_1 = 0x1 << port;\r\nport_rst_off = dsaf_dev->mac_cb[port]->port_rst_off;\r\nreg_val_2 = AE_IS_VER1(dsaf_dev->dsaf_ver) ?\r\n0x1041041 : 0x2082082;\r\nreg_val_2 <<= port_rst_off;\r\nif (!dereset) {\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_REQ1_REG,\r\nreg_val_1);\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_REQ0_REG,\r\nreg_val_2);\r\n} else {\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_DREQ0_REG,\r\nreg_val_2);\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_DREQ1_REG,\r\nreg_val_1);\r\n}\r\n} else {\r\nreg_val_1 = 0x15540;\r\nreg_val_2 = AE_IS_VER1(dsaf_dev->dsaf_ver) ? 0x100 : 0x40;\r\nreg_val_1 <<= dsaf_dev->reset_offset;\r\nreg_val_2 <<= dsaf_dev->reset_offset;\r\nif (!dereset) {\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_REQ1_REG,\r\nreg_val_1);\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_PPE_RESET_REQ_REG,\r\nreg_val_2);\r\n} else {\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_GE_RESET_DREQ1_REG,\r\nreg_val_1);\r\ndsaf_write_sub(dsaf_dev, DSAF_SUB_SC_PPE_RESET_DREQ_REG,\r\nreg_val_2);\r\n}\r\n}\r\n}\r\nstatic void hns_dsaf_ge_srst_by_port_acpi(struct dsaf_device *dsaf_dev,\r\nu32 port, bool dereset)\r\n{\r\nhns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\r\nHNS_GE_RESET_FUNC, port, dereset);\r\n}\r\nstatic void hns_ppe_srst_by_port(struct dsaf_device *dsaf_dev, u32 port,\r\nbool dereset)\r\n{\r\nu32 reg_val = 0;\r\nu32 reg_addr;\r\nreg_val |= RESET_REQ_OR_DREQ << dsaf_dev->mac_cb[port]->port_rst_off;\r\nif (!dereset)\r\nreg_addr = DSAF_SUB_SC_PPE_RESET_REQ_REG;\r\nelse\r\nreg_addr = DSAF_SUB_SC_PPE_RESET_DREQ_REG;\r\ndsaf_write_sub(dsaf_dev, reg_addr, reg_val);\r\n}\r\nstatic void\r\nhns_ppe_srst_by_port_acpi(struct dsaf_device *dsaf_dev, u32 port, bool dereset)\r\n{\r\nhns_dsaf_acpi_srst_by_port(dsaf_dev, HNS_OP_RESET_FUNC,\r\nHNS_PPE_RESET_FUNC, port, dereset);\r\n}\r\nstatic void hns_ppe_com_srst(struct dsaf_device *dsaf_dev, bool dereset)\r\n{\r\nu32 reg_val;\r\nu32 reg_addr;\r\nif (!(dev_of_node(dsaf_dev->dev)))\r\nreturn;\r\nif (!HNS_DSAF_IS_DEBUG(dsaf_dev)) {\r\nreg_val = RESET_REQ_OR_DREQ;\r\nif (!dereset)\r\nreg_addr = DSAF_SUB_SC_RCB_PPE_COM_RESET_REQ_REG;\r\nelse\r\nreg_addr = DSAF_SUB_SC_RCB_PPE_COM_RESET_DREQ_REG;\r\n} else {\r\nreg_val = 0x100 << dsaf_dev->reset_offset;\r\nif (!dereset)\r\nreg_addr = DSAF_SUB_SC_PPE_RESET_REQ_REG;\r\nelse\r\nreg_addr = DSAF_SUB_SC_PPE_RESET_DREQ_REG;\r\n}\r\ndsaf_write_sub(dsaf_dev, reg_addr, reg_val);\r\n}\r\nstatic phy_interface_t hns_mac_get_phy_if(struct hns_mac_cb *mac_cb)\r\n{\r\nu32 mode;\r\nu32 reg;\r\nbool is_ver1 = AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver);\r\nint mac_id = mac_cb->mac_id;\r\nphy_interface_t phy_if;\r\nif (is_ver1) {\r\nif (HNS_DSAF_IS_DEBUG(mac_cb->dsaf_dev))\r\nreturn PHY_INTERFACE_MODE_SGMII;\r\nif (mac_id >= 0 && mac_id <= 3)\r\nreg = HNS_MAC_HILINK4_REG;\r\nelse\r\nreg = HNS_MAC_HILINK3_REG;\r\n} else{\r\nif (!HNS_DSAF_IS_DEBUG(mac_cb->dsaf_dev) && mac_id <= 3)\r\nreg = HNS_MAC_HILINK4V2_REG;\r\nelse\r\nreg = HNS_MAC_HILINK3V2_REG;\r\n}\r\nmode = dsaf_read_sub(mac_cb->dsaf_dev, reg);\r\nif (dsaf_get_bit(mode, mac_cb->port_mode_off))\r\nphy_if = PHY_INTERFACE_MODE_XGMII;\r\nelse\r\nphy_if = PHY_INTERFACE_MODE_SGMII;\r\nreturn phy_if;\r\n}\r\nstatic phy_interface_t hns_mac_get_phy_if_acpi(struct hns_mac_cb *mac_cb)\r\n{\r\nphy_interface_t phy_if = PHY_INTERFACE_MODE_NA;\r\nunion acpi_object *obj;\r\nunion acpi_object obj_args, argv4;\r\nobj_args.integer.type = ACPI_TYPE_INTEGER;\r\nobj_args.integer.value = mac_cb->mac_id;\r\nargv4.type = ACPI_TYPE_PACKAGE,\r\nargv4.package.count = 1,\r\nargv4.package.elements = &obj_args,\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(mac_cb->dev),\r\nhns_dsaf_acpi_dsm_uuid, 0,\r\nHNS_OP_GET_PORT_TYPE_FUNC, &argv4);\r\nif (!obj || obj->type != ACPI_TYPE_INTEGER)\r\nreturn phy_if;\r\nphy_if = obj->integer.value ?\r\nPHY_INTERFACE_MODE_XGMII : PHY_INTERFACE_MODE_SGMII;\r\ndev_dbg(mac_cb->dev, "mac_id=%d, phy_if=%d\n", mac_cb->mac_id, phy_if);\r\nACPI_FREE(obj);\r\nreturn phy_if;\r\n}\r\nint hns_mac_get_sfp_prsnt(struct hns_mac_cb *mac_cb, int *sfp_prsnt)\r\n{\r\nif (!mac_cb->cpld_ctrl)\r\nreturn -ENODEV;\r\n*sfp_prsnt = !dsaf_read_syscon(mac_cb->cpld_ctrl, mac_cb->cpld_ctrl_reg\r\n+ MAC_SFP_PORT_OFFSET);\r\nreturn 0;\r\n}\r\nint hns_mac_get_sfp_prsnt_acpi(struct hns_mac_cb *mac_cb, int *sfp_prsnt)\r\n{\r\nunion acpi_object *obj;\r\nunion acpi_object obj_args, argv4;\r\nobj_args.integer.type = ACPI_TYPE_INTEGER;\r\nobj_args.integer.value = mac_cb->mac_id;\r\nargv4.type = ACPI_TYPE_PACKAGE,\r\nargv4.package.count = 1,\r\nargv4.package.elements = &obj_args,\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(mac_cb->dev),\r\nhns_dsaf_acpi_dsm_uuid, 0,\r\nHNS_OP_GET_SFP_STAT_FUNC, &argv4);\r\nif (!obj || obj->type != ACPI_TYPE_INTEGER)\r\nreturn -ENODEV;\r\n*sfp_prsnt = obj->integer.value;\r\nACPI_FREE(obj);\r\nreturn 0;\r\n}\r\nstatic int hns_mac_config_sds_loopback(struct hns_mac_cb *mac_cb, bool en)\r\n{\r\nconst u8 lane_id[] = {\r\n0,\r\n1,\r\n2,\r\n3,\r\n2,\r\n3,\r\n0,\r\n1\r\n};\r\n#define RX_CSR(lane, reg) ((0x4080 + (reg) * 0x0002 + (lane) * 0x0200) * 2)\r\nu64 reg_offset = RX_CSR(lane_id[mac_cb->mac_id], 0);\r\nint sfp_prsnt;\r\nint ret = hns_mac_get_sfp_prsnt(mac_cb, &sfp_prsnt);\r\nif (!mac_cb->phy_dev) {\r\nif (ret)\r\npr_info("please confirm sfp is present or not\n");\r\nelse\r\nif (!sfp_prsnt)\r\npr_info("no sfp in this eth\n");\r\n}\r\nif (mac_cb->serdes_ctrl) {\r\nu32 origin;\r\nif (!AE_IS_VER1(mac_cb->dsaf_dev->dsaf_ver)) {\r\n#define HILINK_ACCESS_SEL_CFG 0x40008\r\nif ((!HNS_DSAF_IS_DEBUG(mac_cb->dsaf_dev)) &&\r\n(mac_cb->mac_id <= 3))\r\ndsaf_write_syscon(mac_cb->serdes_ctrl,\r\nHILINK_ACCESS_SEL_CFG, 0);\r\nelse\r\ndsaf_write_syscon(mac_cb->serdes_ctrl,\r\nHILINK_ACCESS_SEL_CFG, 3);\r\n}\r\norigin = dsaf_read_syscon(mac_cb->serdes_ctrl, reg_offset);\r\ndsaf_set_field(origin, 1ull << 10, 10, en);\r\ndsaf_write_syscon(mac_cb->serdes_ctrl, reg_offset, origin);\r\n} else {\r\nu8 *base_addr = (u8 *)mac_cb->serdes_vaddr +\r\n(mac_cb->mac_id <= 3 ? 0x00280000 : 0x00200000);\r\ndsaf_set_reg_field(base_addr, reg_offset, 1ull << 10, 10, en);\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nhns_mac_config_sds_loopback_acpi(struct hns_mac_cb *mac_cb, bool en)\r\n{\r\nunion acpi_object *obj;\r\nunion acpi_object obj_args[3], argv4;\r\nobj_args[0].integer.type = ACPI_TYPE_INTEGER;\r\nobj_args[0].integer.value = mac_cb->mac_id;\r\nobj_args[1].integer.type = ACPI_TYPE_INTEGER;\r\nobj_args[1].integer.value = !!en;\r\nargv4.type = ACPI_TYPE_PACKAGE;\r\nargv4.package.count = 2;\r\nargv4.package.elements = obj_args;\r\nobj = acpi_evaluate_dsm(ACPI_HANDLE(mac_cb->dsaf_dev->dev),\r\nhns_dsaf_acpi_dsm_uuid, 0,\r\nHNS_OP_SERDES_LP_FUNC, &argv4);\r\nif (!obj) {\r\ndev_warn(mac_cb->dsaf_dev->dev, "set port%d serdes lp fail!",\r\nmac_cb->mac_id);\r\nreturn -ENOTSUPP;\r\n}\r\nACPI_FREE(obj);\r\nreturn 0;\r\n}\r\nstruct dsaf_misc_op *hns_misc_op_get(struct dsaf_device *dsaf_dev)\r\n{\r\nstruct dsaf_misc_op *misc_op;\r\nmisc_op = devm_kzalloc(dsaf_dev->dev, sizeof(*misc_op), GFP_KERNEL);\r\nif (!misc_op)\r\nreturn NULL;\r\nif (dev_of_node(dsaf_dev->dev)) {\r\nmisc_op->cpld_set_led = hns_cpld_set_led;\r\nmisc_op->cpld_reset_led = cpld_led_reset;\r\nmisc_op->cpld_set_led_id = cpld_set_led_id;\r\nmisc_op->dsaf_reset = hns_dsaf_rst;\r\nmisc_op->xge_srst = hns_dsaf_xge_srst_by_port;\r\nmisc_op->ge_srst = hns_dsaf_ge_srst_by_port;\r\nmisc_op->ppe_srst = hns_ppe_srst_by_port;\r\nmisc_op->ppe_comm_srst = hns_ppe_com_srst;\r\nmisc_op->hns_dsaf_srst_chns = hns_dsaf_srst_chns;\r\nmisc_op->hns_dsaf_roce_srst = hns_dsaf_roce_srst;\r\nmisc_op->get_phy_if = hns_mac_get_phy_if;\r\nmisc_op->get_sfp_prsnt = hns_mac_get_sfp_prsnt;\r\nmisc_op->cfg_serdes_loopback = hns_mac_config_sds_loopback;\r\n} else if (is_acpi_node(dsaf_dev->dev->fwnode)) {\r\nmisc_op->cpld_set_led = hns_cpld_set_led;\r\nmisc_op->cpld_reset_led = cpld_led_reset;\r\nmisc_op->cpld_set_led_id = cpld_set_led_id;\r\nmisc_op->dsaf_reset = hns_dsaf_rst_acpi;\r\nmisc_op->xge_srst = hns_dsaf_xge_srst_by_port_acpi;\r\nmisc_op->ge_srst = hns_dsaf_ge_srst_by_port_acpi;\r\nmisc_op->ppe_srst = hns_ppe_srst_by_port_acpi;\r\nmisc_op->ppe_comm_srst = hns_ppe_com_srst;\r\nmisc_op->hns_dsaf_srst_chns = hns_dsaf_srst_chns_acpi;\r\nmisc_op->hns_dsaf_roce_srst = hns_dsaf_roce_srst_acpi;\r\nmisc_op->get_phy_if = hns_mac_get_phy_if_acpi;\r\nmisc_op->get_sfp_prsnt = hns_mac_get_sfp_prsnt_acpi;\r\nmisc_op->cfg_serdes_loopback = hns_mac_config_sds_loopback_acpi;\r\n} else {\r\ndevm_kfree(dsaf_dev->dev, (void *)misc_op);\r\nmisc_op = NULL;\r\n}\r\nreturn (void *)misc_op;\r\n}\r\nstatic int hns_dsaf_dev_match(struct device *dev, void *fwnode)\r\n{\r\nreturn dev->fwnode == fwnode;\r\n}\r\nstruct\r\nplatform_device *hns_dsaf_find_platform_device(struct fwnode_handle *fwnode)\r\n{\r\nstruct device *dev;\r\ndev = bus_find_device(&platform_bus_type, NULL,\r\nfwnode, hns_dsaf_dev_match);\r\nreturn dev ? to_platform_device(dev) : NULL;\r\n}
