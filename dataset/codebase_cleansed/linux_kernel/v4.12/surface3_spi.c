static int surface3_spi_read(struct surface3_ts_data *ts_data)\r\n{\r\nstruct spi_device *spi = ts_data->spi;\r\nmemset(ts_data->rd_buf, 0, sizeof(ts_data->rd_buf));\r\nreturn spi_read(spi, ts_data->rd_buf, sizeof(ts_data->rd_buf));\r\n}\r\nstatic void surface3_spi_report_touch(struct surface3_ts_data *ts_data,\r\nstruct surface3_ts_data_finger *finger)\r\n{\r\nint st = finger->status & 0x01;\r\nint slot;\r\nslot = input_mt_get_slot_by_key(ts_data->input_dev,\r\nget_unaligned_le16(&finger->tracking_id));\r\nif (slot < 0)\r\nreturn;\r\ninput_mt_slot(ts_data->input_dev, slot);\r\ninput_mt_report_slot_state(ts_data->input_dev, MT_TOOL_FINGER, st);\r\nif (st) {\r\ninput_report_abs(ts_data->input_dev,\r\nABS_MT_POSITION_X,\r\nget_unaligned_le16(&finger->x));\r\ninput_report_abs(ts_data->input_dev,\r\nABS_MT_POSITION_Y,\r\nget_unaligned_le16(&finger->y));\r\ninput_report_abs(ts_data->input_dev,\r\nABS_MT_WIDTH_MAJOR,\r\nget_unaligned_le16(&finger->width));\r\ninput_report_abs(ts_data->input_dev,\r\nABS_MT_WIDTH_MINOR,\r\nget_unaligned_le16(&finger->height));\r\n}\r\n}\r\nstatic void surface3_spi_process_touch(struct surface3_ts_data *ts_data, u8 *data)\r\n{\r\nu16 timestamp;\r\nunsigned int i;\r\ntimestamp = get_unaligned_le16(&data[15]);\r\nfor (i = 0; i < 13; i++) {\r\nstruct surface3_ts_data_finger *finger;\r\nfinger = (struct surface3_ts_data_finger *)&data[17 +\r\ni * sizeof(struct surface3_ts_data_finger)];\r\nif (finger->status & 0x10)\r\nbreak;\r\nsurface3_spi_report_touch(ts_data, finger);\r\n}\r\ninput_mt_sync_frame(ts_data->input_dev);\r\ninput_sync(ts_data->input_dev);\r\n}\r\nstatic void surface3_spi_report_pen(struct surface3_ts_data *ts_data,\r\nstruct surface3_ts_data_pen *pen)\r\n{\r\nstruct input_dev *dev = ts_data->pen_input_dev;\r\nint st = pen->status;\r\nint prox = st & 0x01;\r\nint rubber = st & 0x18;\r\nint tool = (prox && rubber) ? BTN_TOOL_RUBBER : BTN_TOOL_PEN;\r\nif (ts_data->pen_tool != tool) {\r\ninput_report_key(dev, ts_data->pen_tool, 0);\r\ninput_sync(dev);\r\nts_data->pen_tool = tool;\r\n}\r\ninput_report_key(dev, BTN_TOUCH, st & 0x12);\r\ninput_report_key(dev, ts_data->pen_tool, prox);\r\nif (st) {\r\ninput_report_key(dev,\r\nBTN_STYLUS,\r\nst & 0x04);\r\ninput_report_abs(dev,\r\nABS_X,\r\nget_unaligned_le16(&pen->x));\r\ninput_report_abs(dev,\r\nABS_Y,\r\nget_unaligned_le16(&pen->y));\r\ninput_report_abs(dev,\r\nABS_PRESSURE,\r\nget_unaligned_le16(&pen->pressure));\r\n}\r\n}\r\nstatic void surface3_spi_process_pen(struct surface3_ts_data *ts_data, u8 *data)\r\n{\r\nstruct surface3_ts_data_pen *pen;\r\npen = (struct surface3_ts_data_pen *)&data[15];\r\nsurface3_spi_report_pen(ts_data, pen);\r\ninput_sync(ts_data->pen_input_dev);\r\n}\r\nstatic void surface3_spi_process(struct surface3_ts_data *ts_data)\r\n{\r\nconst char header[] = {\r\n0xff, 0xff, 0xff, 0xff, 0xa5, 0x5a, 0xe7, 0x7e, 0x01\r\n};\r\nu8 *data = ts_data->rd_buf;\r\nif (memcmp(header, data, sizeof(header)))\r\ndev_err(&ts_data->spi->dev,\r\n"%s header error: %*ph, ignoring...\n",\r\n__func__, (int)sizeof(header), data);\r\nswitch (data[9]) {\r\ncase SURFACE3_REPORT_TOUCH:\r\nsurface3_spi_process_touch(ts_data, data);\r\nbreak;\r\ncase SURFACE3_REPORT_PEN:\r\nsurface3_spi_process_pen(ts_data, data);\r\nbreak;\r\ndefault:\r\ndev_err(&ts_data->spi->dev,\r\n"%s unknown packet type: %x, ignoring...\n",\r\n__func__, data[9]);\r\nbreak;\r\n}\r\n}\r\nstatic irqreturn_t surface3_spi_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct surface3_ts_data *data = dev_id;\r\nif (surface3_spi_read(data))\r\nreturn IRQ_HANDLED;\r\ndev_dbg(&data->spi->dev, "%s received -> %*ph\n",\r\n__func__, SURFACE3_PACKET_SIZE, data->rd_buf);\r\nsurface3_spi_process(data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void surface3_spi_power(struct surface3_ts_data *data, bool on)\r\n{\r\ngpiod_set_value(data->gpiod_rst[0], on);\r\ngpiod_set_value(data->gpiod_rst[1], on);\r\nmsleep(20);\r\n}\r\nstatic int surface3_spi_get_gpio_config(struct surface3_ts_data *data)\r\n{\r\nint error;\r\nstruct device *dev;\r\nstruct gpio_desc *gpiod;\r\nint i;\r\ndev = &data->spi->dev;\r\nfor (i = 0; i < 2; i++) {\r\ngpiod = devm_gpiod_get_index(dev, NULL, i, GPIOD_OUT_LOW);\r\nif (IS_ERR(gpiod)) {\r\nerror = PTR_ERR(gpiod);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev,\r\n"Failed to get power GPIO %d: %d\n",\r\ni,\r\nerror);\r\nreturn error;\r\n}\r\ndata->gpiod_rst[i] = gpiod;\r\n}\r\nreturn 0;\r\n}\r\nstatic int surface3_spi_create_touch_input(struct surface3_ts_data *data)\r\n{\r\nstruct input_dev *input;\r\nint error;\r\ninput = devm_input_allocate_device(&data->spi->dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ndata->input_dev = input;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, 9600, 0, 0);\r\ninput_abs_set_res(input, ABS_MT_POSITION_X, 40);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, 7200, 0, 0);\r\ninput_abs_set_res(input, ABS_MT_POSITION_Y, 48);\r\ninput_set_abs_params(input, ABS_MT_WIDTH_MAJOR, 0, 1024, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_WIDTH_MINOR, 0, 1024, 0, 0);\r\ninput_mt_init_slots(input, 10, INPUT_MT_DIRECT);\r\ninput->name = "Surface3 SPI Capacitive TouchScreen";\r\ninput->phys = "input/ts";\r\ninput->id.bustype = BUS_SPI;\r\ninput->id.vendor = 0x045e;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0000;\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&data->spi->dev,\r\n"Failed to register input device: %d", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int surface3_spi_create_pen_input(struct surface3_ts_data *data)\r\n{\r\nstruct input_dev *input;\r\nint error;\r\ninput = devm_input_allocate_device(&data->spi->dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ndata->pen_input_dev = input;\r\ndata->pen_tool = BTN_TOOL_PEN;\r\n__set_bit(INPUT_PROP_DIRECT, input->propbit);\r\n__set_bit(INPUT_PROP_POINTER, input->propbit);\r\ninput_set_abs_params(input, ABS_X, 0, 9600, 0, 0);\r\ninput_abs_set_res(input, ABS_X, 40);\r\ninput_set_abs_params(input, ABS_Y, 0, 7200, 0, 0);\r\ninput_abs_set_res(input, ABS_Y, 48);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 1024, 0, 0);\r\ninput_set_capability(input, EV_KEY, BTN_TOUCH);\r\ninput_set_capability(input, EV_KEY, BTN_STYLUS);\r\ninput_set_capability(input, EV_KEY, BTN_TOOL_PEN);\r\ninput_set_capability(input, EV_KEY, BTN_TOOL_RUBBER);\r\ninput->name = "Surface3 SPI Pen Input";\r\ninput->phys = "input/ts";\r\ninput->id.bustype = BUS_SPI;\r\ninput->id.vendor = 0x045e;\r\ninput->id.product = 0x0002;\r\ninput->id.version = 0x0000;\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&data->spi->dev,\r\n"Failed to register input device: %d", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int surface3_spi_probe(struct spi_device *spi)\r\n{\r\nstruct surface3_ts_data *data;\r\nint error;\r\nspi->bits_per_word = 8;\r\nspi->mode = SPI_MODE_0;\r\nerror = spi_setup(spi);\r\nif (error)\r\nreturn error;\r\ndata = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->spi = spi;\r\nspi_set_drvdata(spi, data);\r\nerror = surface3_spi_get_gpio_config(data);\r\nif (error)\r\nreturn error;\r\nsurface3_spi_power(data, true);\r\nsurface3_spi_power(data, false);\r\nsurface3_spi_power(data, true);\r\nerror = surface3_spi_create_touch_input(data);\r\nif (error)\r\nreturn error;\r\nerror = surface3_spi_create_pen_input(data);\r\nif (error)\r\nreturn error;\r\nerror = devm_request_threaded_irq(&spi->dev, spi->irq,\r\nNULL, surface3_spi_irq_handler,\r\nIRQF_ONESHOT,\r\n"Surface3-irq", data);\r\nif (error)\r\nreturn error;\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused surface3_spi_suspend(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct surface3_ts_data *data = spi_get_drvdata(spi);\r\ndisable_irq(data->spi->irq);\r\nsurface3_spi_power(data, false);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused surface3_spi_resume(struct device *dev)\r\n{\r\nstruct spi_device *spi = to_spi_device(dev);\r\nstruct surface3_ts_data *data = spi_get_drvdata(spi);\r\nsurface3_spi_power(data, true);\r\nenable_irq(data->spi->irq);\r\nreturn 0;\r\n}
