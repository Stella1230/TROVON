static int mxs_ocotp_wait(struct mxs_ocotp *otp)\r\n{\r\nint timeout = OCOTP_TIMEOUT;\r\nunsigned int status = 0;\r\nwhile (timeout--) {\r\nstatus = readl(otp->base);\r\nif (!(status & (BM_OCOTP_CTRL_BUSY | BM_OCOTP_CTRL_ERROR)))\r\nbreak;\r\ncpu_relax();\r\n}\r\nif (status & BM_OCOTP_CTRL_BUSY)\r\nreturn -EBUSY;\r\nelse if (status & BM_OCOTP_CTRL_ERROR)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int mxs_ocotp_read(void *context, unsigned int offset,\r\nvoid *val, size_t bytes)\r\n{\r\nstruct mxs_ocotp *otp = context;\r\nu32 *buf = val;\r\nint ret;\r\nret = clk_enable(otp->clk);\r\nif (ret)\r\nreturn ret;\r\nwritel(BM_OCOTP_CTRL_ERROR, otp->base + STMP_OFFSET_REG_CLR);\r\nret = mxs_ocotp_wait(otp);\r\nif (ret)\r\ngoto disable_clk;\r\nwritel(BM_OCOTP_CTRL_RD_BANK_OPEN, otp->base + STMP_OFFSET_REG_SET);\r\nudelay(1);\r\nret = mxs_ocotp_wait(otp);\r\nif (ret)\r\ngoto close_banks;\r\nwhile (bytes) {\r\nif ((offset < OCOTP_DATA_OFFSET) || (offset % 16)) {\r\n*buf++ = 0;\r\n} else {\r\n*buf++ = readl(otp->base + offset);\r\n}\r\nbytes -= 4;\r\noffset += 4;\r\n}\r\nclose_banks:\r\nwritel(BM_OCOTP_CTRL_RD_BANK_OPEN, otp->base + STMP_OFFSET_REG_CLR);\r\ndisable_clk:\r\nclk_disable(otp->clk);\r\nreturn ret;\r\n}\r\nstatic int mxs_ocotp_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct mxs_data *data;\r\nstruct mxs_ocotp *otp;\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nint ret;\r\nmatch = of_match_device(dev->driver->of_match_table, dev);\r\nif (!match || !match->data)\r\nreturn -EINVAL;\r\notp = devm_kzalloc(dev, sizeof(*otp), GFP_KERNEL);\r\nif (!otp)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\notp->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(otp->base))\r\nreturn PTR_ERR(otp->base);\r\notp->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(otp->clk))\r\nreturn PTR_ERR(otp->clk);\r\nret = clk_prepare(otp->clk);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to prepare clk: %d\n", ret);\r\nreturn ret;\r\n}\r\ndata = match->data;\r\nocotp_config.size = data->size;\r\nocotp_config.priv = otp;\r\nocotp_config.dev = dev;\r\notp->nvmem = nvmem_register(&ocotp_config);\r\nif (IS_ERR(otp->nvmem)) {\r\nret = PTR_ERR(otp->nvmem);\r\ngoto err_clk;\r\n}\r\nplatform_set_drvdata(pdev, otp);\r\nreturn 0;\r\nerr_clk:\r\nclk_unprepare(otp->clk);\r\nreturn ret;\r\n}\r\nstatic int mxs_ocotp_remove(struct platform_device *pdev)\r\n{\r\nstruct mxs_ocotp *otp = platform_get_drvdata(pdev);\r\nclk_unprepare(otp->clk);\r\nreturn nvmem_unregister(otp->nvmem);\r\n}
