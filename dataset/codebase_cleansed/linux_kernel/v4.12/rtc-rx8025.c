static s32 rx8025_read_reg(const struct i2c_client *client, u8 number)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, number << 4);\r\n}\r\nstatic int rx8025_read_regs(const struct i2c_client *client,\r\nu8 number, u8 length, u8 *values)\r\n{\r\nint ret = i2c_smbus_read_i2c_block_data(client, number << 4, length,\r\nvalues);\r\nif (ret != length)\r\nreturn ret < 0 ? ret : -EIO;\r\nreturn 0;\r\n}\r\nstatic s32 rx8025_write_reg(const struct i2c_client *client, u8 number,\r\nu8 value)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, number << 4, value);\r\n}\r\nstatic s32 rx8025_write_regs(const struct i2c_client *client,\r\nu8 number, u8 length, const u8 *values)\r\n{\r\nreturn i2c_smbus_write_i2c_block_data(client, number << 4,\r\nlength, values);\r\n}\r\nstatic int rx8025_check_validity(struct device *dev)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nint ctrl2;\r\nctrl2 = rx8025_read_reg(rx8025->client, RX8025_REG_CTRL2);\r\nif (ctrl2 < 0)\r\nreturn ctrl2;\r\nif (ctrl2 & RX8025_BIT_CTRL2_VDET)\r\ndev_warn(dev, "power voltage drop detected\n");\r\nif (ctrl2 & RX8025_BIT_CTRL2_PON) {\r\ndev_warn(dev, "power-on reset detected, date is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nif (!(ctrl2 & RX8025_BIT_CTRL2_XST)) {\r\ndev_warn(dev, "crystal stopped, date is invalid\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8025_reset_validity(struct i2c_client *client)\r\n{\r\nint ctrl2 = rx8025_read_reg(client, RX8025_REG_CTRL2);\r\nif (ctrl2 < 0)\r\nreturn ctrl2;\r\nctrl2 &= ~(RX8025_BIT_CTRL2_PON | RX8025_BIT_CTRL2_VDET);\r\nreturn rx8025_write_reg(client, RX8025_REG_CTRL2,\r\nctrl2 | RX8025_BIT_CTRL2_XST);\r\n}\r\nstatic irqreturn_t rx8025_handle_irq(int irq, void *dev_id)\r\n{\r\nstruct i2c_client *client = dev_id;\r\nstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\r\nstruct mutex *lock = &rx8025->rtc->ops_lock;\r\nint status;\r\nmutex_lock(lock);\r\nstatus = rx8025_read_reg(client, RX8025_REG_CTRL2);\r\nif (status < 0)\r\ngoto out;\r\nif (!(status & RX8025_BIT_CTRL2_XST))\r\ndev_warn(&client->dev, "Oscillation stop was detected,"\r\n"you may have to readjust the clock\n");\r\nif (status & RX8025_BIT_CTRL2_CTFG) {\r\nstatus &= ~RX8025_BIT_CTRL2_CTFG;\r\nrtc_update_irq(rx8025->rtc, 1, RTC_PF | RTC_IRQF);\r\n}\r\nif (status & RX8025_BIT_CTRL2_DAFG) {\r\nstatus &= RX8025_BIT_CTRL2_DAFG;\r\nif (rx8025_write_reg(client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1 & ~RX8025_BIT_CTRL1_DALE))\r\ngoto out;\r\nrtc_update_irq(rx8025->rtc, 1, RTC_AF | RTC_IRQF);\r\n}\r\nout:\r\nmutex_unlock(lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rx8025_get_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 date[7];\r\nint err;\r\nerr = rx8025_check_validity(dev);\r\nif (err)\r\nreturn err;\r\nerr = rx8025_read_regs(rx8025->client, RX8025_REG_SEC, 7, date);\r\nif (err)\r\nreturn err;\r\ndev_dbg(dev, "%s: read 0x%02x 0x%02x "\r\n"0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n", __func__,\r\ndate[0], date[1], date[2], date[3], date[4],\r\ndate[5], date[6]);\r\ndt->tm_sec = bcd2bin(date[RX8025_REG_SEC] & 0x7f);\r\ndt->tm_min = bcd2bin(date[RX8025_REG_MIN] & 0x7f);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\ndt->tm_hour = bcd2bin(date[RX8025_REG_HOUR] & 0x3f);\r\nelse\r\ndt->tm_hour = bcd2bin(date[RX8025_REG_HOUR] & 0x1f) % 12\r\n+ (date[RX8025_REG_HOUR] & 0x20 ? 12 : 0);\r\ndt->tm_mday = bcd2bin(date[RX8025_REG_MDAY] & 0x3f);\r\ndt->tm_mon = bcd2bin(date[RX8025_REG_MONTH] & 0x1f) - 1;\r\ndt->tm_year = bcd2bin(date[RX8025_REG_YEAR]) + 100;\r\ndev_dbg(dev, "%s: date %ds %dm %dh %dmd %dm %dy\n", __func__,\r\ndt->tm_sec, dt->tm_min, dt->tm_hour,\r\ndt->tm_mday, dt->tm_mon, dt->tm_year);\r\nreturn rtc_valid_tm(dt);\r\n}\r\nstatic int rx8025_set_time(struct device *dev, struct rtc_time *dt)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 date[7];\r\nint ret;\r\nif ((dt->tm_year < 100) || (dt->tm_year > 199))\r\nreturn -EINVAL;\r\ndate[RX8025_REG_SEC] = bin2bcd(dt->tm_sec);\r\ndate[RX8025_REG_MIN] = bin2bcd(dt->tm_min);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\ndate[RX8025_REG_HOUR] = bin2bcd(dt->tm_hour);\r\nelse\r\ndate[RX8025_REG_HOUR] = (dt->tm_hour >= 12 ? 0x20 : 0)\r\n| bin2bcd((dt->tm_hour + 11) % 12 + 1);\r\ndate[RX8025_REG_WDAY] = bin2bcd(dt->tm_wday);\r\ndate[RX8025_REG_MDAY] = bin2bcd(dt->tm_mday);\r\ndate[RX8025_REG_MONTH] = bin2bcd(dt->tm_mon + 1);\r\ndate[RX8025_REG_YEAR] = bin2bcd(dt->tm_year - 100);\r\ndev_dbg(dev,\r\n"%s: write 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x 0x%02x\n",\r\n__func__,\r\ndate[0], date[1], date[2], date[3], date[4], date[5], date[6]);\r\nret = rx8025_write_regs(rx8025->client, RX8025_REG_SEC, 7, date);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn rx8025_reset_validity(rx8025->client);\r\n}\r\nstatic int rx8025_init_client(struct i2c_client *client)\r\n{\r\nstruct rx8025_data *rx8025 = i2c_get_clientdata(client);\r\nu8 ctrl[2], ctrl2;\r\nint need_clear = 0;\r\nint err;\r\nerr = rx8025_read_regs(rx8025->client, RX8025_REG_CTRL1, 2, ctrl);\r\nif (err)\r\ngoto out;\r\nrx8025->ctrl1 = ctrl[0] & ~RX8025_BIT_CTRL1_TEST;\r\nif (ctrl[1] & (RX8025_BIT_CTRL2_DAFG | RX8025_BIT_CTRL2_WAFG)) {\r\ndev_warn(&client->dev, "Alarm was detected\n");\r\nneed_clear = 1;\r\n}\r\nif (ctrl[1] & RX8025_BIT_CTRL2_CTFG)\r\nneed_clear = 1;\r\nif (need_clear) {\r\nctrl2 = ctrl[1];\r\nctrl2 &= ~(RX8025_BIT_CTRL2_CTFG | RX8025_BIT_CTRL2_WAFG |\r\nRX8025_BIT_CTRL2_DAFG);\r\nerr = rx8025_write_reg(client, RX8025_REG_CTRL2, ctrl2);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic int rx8025_read_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nstruct i2c_client *client = rx8025->client;\r\nu8 ald[2];\r\nint ctrl2, err;\r\nif (client->irq <= 0)\r\nreturn -EINVAL;\r\nerr = rx8025_read_regs(client, RX8025_REG_ALDMIN, 2, ald);\r\nif (err)\r\nreturn err;\r\nctrl2 = rx8025_read_reg(client, RX8025_REG_CTRL2);\r\nif (ctrl2 < 0)\r\nreturn ctrl2;\r\ndev_dbg(dev, "%s: read alarm 0x%02x 0x%02x ctrl2 %02x\n",\r\n__func__, ald[0], ald[1], ctrl2);\r\nt->time.tm_sec = 0;\r\nt->time.tm_min = bcd2bin(ald[0] & 0x7f);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\nt->time.tm_hour = bcd2bin(ald[1] & 0x3f);\r\nelse\r\nt->time.tm_hour = bcd2bin(ald[1] & 0x1f) % 12\r\n+ (ald[1] & 0x20 ? 12 : 0);\r\ndev_dbg(dev, "%s: date: %ds %dm %dh %dmd %dm %dy\n",\r\n__func__,\r\nt->time.tm_sec, t->time.tm_min, t->time.tm_hour,\r\nt->time.tm_mday, t->time.tm_mon, t->time.tm_year);\r\nt->enabled = !!(rx8025->ctrl1 & RX8025_BIT_CTRL1_DALE);\r\nt->pending = (ctrl2 & RX8025_BIT_CTRL2_DAFG) && t->enabled;\r\nreturn err;\r\n}\r\nstatic int rx8025_set_alarm(struct device *dev, struct rtc_wkalrm *t)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 ald[2];\r\nint err;\r\nif (client->irq <= 0)\r\nreturn -EINVAL;\r\nif (t->time.tm_sec) {\r\ntime64_t alarm_time = rtc_tm_to_time64(&t->time);\r\nalarm_time += 60 - t->time.tm_sec;\r\nrtc_time64_to_tm(alarm_time, &t->time);\r\n}\r\nald[0] = bin2bcd(t->time.tm_min);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_1224)\r\nald[1] = bin2bcd(t->time.tm_hour);\r\nelse\r\nald[1] = (t->time.tm_hour >= 12 ? 0x20 : 0)\r\n| bin2bcd((t->time.tm_hour + 11) % 12 + 1);\r\ndev_dbg(dev, "%s: write 0x%02x 0x%02x\n", __func__, ald[0], ald[1]);\r\nif (rx8025->ctrl1 & RX8025_BIT_CTRL1_DALE) {\r\nrx8025->ctrl1 &= ~RX8025_BIT_CTRL1_DALE;\r\nerr = rx8025_write_reg(rx8025->client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = rx8025_write_regs(rx8025->client, RX8025_REG_ALDMIN, 2, ald);\r\nif (err)\r\nreturn err;\r\nif (t->enabled) {\r\nrx8025->ctrl1 |= RX8025_BIT_CTRL1_DALE;\r\nerr = rx8025_write_reg(rx8025->client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8025_alarm_irq_enable(struct device *dev, unsigned int enabled)\r\n{\r\nstruct rx8025_data *rx8025 = dev_get_drvdata(dev);\r\nu8 ctrl1;\r\nint err;\r\nctrl1 = rx8025->ctrl1;\r\nif (enabled)\r\nctrl1 |= RX8025_BIT_CTRL1_DALE;\r\nelse\r\nctrl1 &= ~RX8025_BIT_CTRL1_DALE;\r\nif (ctrl1 != rx8025->ctrl1) {\r\nrx8025->ctrl1 = ctrl1;\r\nerr = rx8025_write_reg(rx8025->client, RX8025_REG_CTRL1,\r\nrx8025->ctrl1);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rx8025_get_clock_adjust(struct device *dev, int *adj)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nint digoff;\r\ndigoff = rx8025_read_reg(client, RX8025_REG_DIGOFF);\r\nif (digoff < 0)\r\nreturn digoff;\r\n*adj = digoff >= 64 ? digoff - 128 : digoff;\r\nif (*adj > 0)\r\n(*adj)--;\r\n*adj *= -RX8025_ADJ_RESOLUTION;\r\nreturn 0;\r\n}\r\nstatic int rx8025_set_clock_adjust(struct device *dev, int adj)\r\n{\r\nstruct i2c_client *client = to_i2c_client(dev);\r\nu8 digoff;\r\nint err;\r\nadj /= -RX8025_ADJ_RESOLUTION;\r\nif (adj > RX8025_ADJ_DATA_MAX)\r\nadj = RX8025_ADJ_DATA_MAX;\r\nelse if (adj < RX8025_ADJ_DATA_MIN)\r\nadj = RX8025_ADJ_DATA_MIN;\r\nelse if (adj > 0)\r\nadj++;\r\nelse if (adj < 0)\r\nadj += 128;\r\ndigoff = adj;\r\nerr = rx8025_write_reg(client, RX8025_REG_DIGOFF, digoff);\r\nif (err)\r\nreturn err;\r\ndev_dbg(dev, "%s: write 0x%02x\n", __func__, digoff);\r\nreturn 0;\r\n}\r\nstatic ssize_t rx8025_sysfs_show_clock_adjust(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nint err, adj;\r\nerr = rx8025_get_clock_adjust(dev, &adj);\r\nif (err)\r\nreturn err;\r\nreturn sprintf(buf, "%d\n", adj);\r\n}\r\nstatic ssize_t rx8025_sysfs_store_clock_adjust(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint adj, err;\r\nif (sscanf(buf, "%i", &adj) != 1)\r\nreturn -EINVAL;\r\nerr = rx8025_set_clock_adjust(dev, adj);\r\nreturn err ? err : count;\r\n}\r\nstatic int rx8025_sysfs_register(struct device *dev)\r\n{\r\nreturn device_create_file(dev, &dev_attr_clock_adjust_ppb);\r\n}\r\nstatic void rx8025_sysfs_unregister(struct device *dev)\r\n{\r\ndevice_remove_file(dev, &dev_attr_clock_adjust_ppb);\r\n}\r\nstatic int rx8025_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct rx8025_data *rx8025;\r\nint err = 0;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_I2C_BLOCK)) {\r\ndev_err(&adapter->dev,\r\n"doesn't support required functionality\n");\r\nreturn -EIO;\r\n}\r\nrx8025 = devm_kzalloc(&client->dev, sizeof(*rx8025), GFP_KERNEL);\r\nif (!rx8025)\r\nreturn -ENOMEM;\r\nrx8025->client = client;\r\ni2c_set_clientdata(client, rx8025);\r\nerr = rx8025_init_client(client);\r\nif (err)\r\nreturn err;\r\nrx8025->rtc = devm_rtc_device_register(&client->dev, client->name,\r\n&rx8025_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rx8025->rtc)) {\r\ndev_err(&client->dev, "unable to register the class device\n");\r\nreturn PTR_ERR(rx8025->rtc);\r\n}\r\nif (client->irq > 0) {\r\ndev_info(&client->dev, "IRQ %d supplied\n", client->irq);\r\nerr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\r\nrx8025_handle_irq,\r\nIRQF_ONESHOT,\r\n"rx8025", client);\r\nif (err) {\r\ndev_err(&client->dev, "unable to request IRQ, alarms disabled\n");\r\nclient->irq = 0;\r\n}\r\n}\r\nrx8025->rtc->max_user_freq = 1;\r\nrx8025->rtc->uie_unsupported = 1;\r\nerr = rx8025_sysfs_register(&client->dev);\r\nreturn err;\r\n}\r\nstatic int rx8025_remove(struct i2c_client *client)\r\n{\r\nrx8025_sysfs_unregister(&client->dev);\r\nreturn 0;\r\n}
