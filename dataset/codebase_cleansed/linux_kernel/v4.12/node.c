static ssize_t node_read_cpumap(struct device *dev, bool list, char *buf)\r\n{\r\nstruct node *node_dev = to_node(dev);\r\nconst struct cpumask *mask = cpumask_of_node(node_dev->dev.id);\r\nBUILD_BUG_ON((NR_CPUS/32 * 9) > (PAGE_SIZE-1));\r\nreturn cpumap_print_to_pagebuf(list, buf, mask);\r\n}\r\nstatic inline ssize_t node_read_cpumask(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn node_read_cpumap(dev, false, buf);\r\n}\r\nstatic inline ssize_t node_read_cpulist(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn node_read_cpumap(dev, true, buf);\r\n}\r\nstatic ssize_t node_read_meminfo(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint n;\r\nint nid = dev->id;\r\nstruct pglist_data *pgdat = NODE_DATA(nid);\r\nstruct sysinfo i;\r\nsi_meminfo_node(&i, nid);\r\nn = sprintf(buf,\r\n"Node %d MemTotal: %8lu kB\n"\r\n"Node %d MemFree: %8lu kB\n"\r\n"Node %d MemUsed: %8lu kB\n"\r\n"Node %d Active: %8lu kB\n"\r\n"Node %d Inactive: %8lu kB\n"\r\n"Node %d Active(anon): %8lu kB\n"\r\n"Node %d Inactive(anon): %8lu kB\n"\r\n"Node %d Active(file): %8lu kB\n"\r\n"Node %d Inactive(file): %8lu kB\n"\r\n"Node %d Unevictable: %8lu kB\n"\r\n"Node %d Mlocked: %8lu kB\n",\r\nnid, K(i.totalram),\r\nnid, K(i.freeram),\r\nnid, K(i.totalram - i.freeram),\r\nnid, K(node_page_state(pgdat, NR_ACTIVE_ANON) +\r\nnode_page_state(pgdat, NR_ACTIVE_FILE)),\r\nnid, K(node_page_state(pgdat, NR_INACTIVE_ANON) +\r\nnode_page_state(pgdat, NR_INACTIVE_FILE)),\r\nnid, K(node_page_state(pgdat, NR_ACTIVE_ANON)),\r\nnid, K(node_page_state(pgdat, NR_INACTIVE_ANON)),\r\nnid, K(node_page_state(pgdat, NR_ACTIVE_FILE)),\r\nnid, K(node_page_state(pgdat, NR_INACTIVE_FILE)),\r\nnid, K(node_page_state(pgdat, NR_UNEVICTABLE)),\r\nnid, K(sum_zone_node_page_state(nid, NR_MLOCK)));\r\n#ifdef CONFIG_HIGHMEM\r\nn += sprintf(buf + n,\r\n"Node %d HighTotal: %8lu kB\n"\r\n"Node %d HighFree: %8lu kB\n"\r\n"Node %d LowTotal: %8lu kB\n"\r\n"Node %d LowFree: %8lu kB\n",\r\nnid, K(i.totalhigh),\r\nnid, K(i.freehigh),\r\nnid, K(i.totalram - i.totalhigh),\r\nnid, K(i.freeram - i.freehigh));\r\n#endif\r\nn += sprintf(buf + n,\r\n"Node %d Dirty: %8lu kB\n"\r\n"Node %d Writeback: %8lu kB\n"\r\n"Node %d FilePages: %8lu kB\n"\r\n"Node %d Mapped: %8lu kB\n"\r\n"Node %d AnonPages: %8lu kB\n"\r\n"Node %d Shmem: %8lu kB\n"\r\n"Node %d KernelStack: %8lu kB\n"\r\n"Node %d PageTables: %8lu kB\n"\r\n"Node %d NFS_Unstable: %8lu kB\n"\r\n"Node %d Bounce: %8lu kB\n"\r\n"Node %d WritebackTmp: %8lu kB\n"\r\n"Node %d Slab: %8lu kB\n"\r\n"Node %d SReclaimable: %8lu kB\n"\r\n"Node %d SUnreclaim: %8lu kB\n"\r\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\r\n"Node %d AnonHugePages: %8lu kB\n"\r\n"Node %d ShmemHugePages: %8lu kB\n"\r\n"Node %d ShmemPmdMapped: %8lu kB\n"\r\n#endif\r\n,\r\nnid, K(node_page_state(pgdat, NR_FILE_DIRTY)),\r\nnid, K(node_page_state(pgdat, NR_WRITEBACK)),\r\nnid, K(node_page_state(pgdat, NR_FILE_PAGES)),\r\nnid, K(node_page_state(pgdat, NR_FILE_MAPPED)),\r\nnid, K(node_page_state(pgdat, NR_ANON_MAPPED)),\r\nnid, K(i.sharedram),\r\nnid, sum_zone_node_page_state(nid, NR_KERNEL_STACK_KB),\r\nnid, K(sum_zone_node_page_state(nid, NR_PAGETABLE)),\r\nnid, K(node_page_state(pgdat, NR_UNSTABLE_NFS)),\r\nnid, K(sum_zone_node_page_state(nid, NR_BOUNCE)),\r\nnid, K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),\r\nnid, K(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE) +\r\nsum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),\r\nnid, K(sum_zone_node_page_state(nid, NR_SLAB_RECLAIMABLE)),\r\n#ifdef CONFIG_TRANSPARENT_HUGEPAGE\r\nnid, K(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)),\r\nnid, K(node_page_state(pgdat, NR_ANON_THPS) *\r\nHPAGE_PMD_NR),\r\nnid, K(node_page_state(pgdat, NR_SHMEM_THPS) *\r\nHPAGE_PMD_NR),\r\nnid, K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED) *\r\nHPAGE_PMD_NR));\r\n#else\r\nnid, K(sum_zone_node_page_state(nid, NR_SLAB_UNRECLAIMABLE)));\r\nstatic ssize_t node_read_numastat(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf,\r\n"numa_hit %lu\n"\r\n"numa_miss %lu\n"\r\n"numa_foreign %lu\n"\r\n"interleave_hit %lu\n"\r\n"local_node %lu\n"\r\n"other_node %lu\n",\r\nsum_zone_node_page_state(dev->id, NUMA_HIT),\r\nsum_zone_node_page_state(dev->id, NUMA_MISS),\r\nsum_zone_node_page_state(dev->id, NUMA_FOREIGN),\r\nsum_zone_node_page_state(dev->id, NUMA_INTERLEAVE_HIT),\r\nsum_zone_node_page_state(dev->id, NUMA_LOCAL),\r\nsum_zone_node_page_state(dev->id, NUMA_OTHER));\r\n}\r\nstatic ssize_t node_read_vmstat(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nid = dev->id;\r\nstruct pglist_data *pgdat = NODE_DATA(nid);\r\nint i;\r\nint n = 0;\r\nfor (i = 0; i < NR_VM_ZONE_STAT_ITEMS; i++)\r\nn += sprintf(buf+n, "%s %lu\n", vmstat_text[i],\r\nsum_zone_node_page_state(nid, i));\r\nfor (i = 0; i < NR_VM_NODE_STAT_ITEMS; i++)\r\nn += sprintf(buf+n, "%s %lu\n",\r\nvmstat_text[i + NR_VM_ZONE_STAT_ITEMS],\r\nnode_page_state(pgdat, i));\r\nreturn n;\r\n}\r\nstatic ssize_t node_read_distance(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nint nid = dev->id;\r\nint len = 0;\r\nint i;\r\nBUILD_BUG_ON(MAX_NUMNODES * 4 > PAGE_SIZE);\r\nfor_each_online_node(i)\r\nlen += sprintf(buf + len, "%s%d", i ? " " : "", node_distance(nid, i));\r\nlen += sprintf(buf + len, "\n");\r\nreturn len;\r\n}\r\nstatic inline bool hugetlb_register_node(struct node *node)\r\n{\r\nif (__hugetlb_register_node &&\r\nnode_state(node->dev.id, N_MEMORY)) {\r\n__hugetlb_register_node(node);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic inline void hugetlb_unregister_node(struct node *node)\r\n{\r\nif (__hugetlb_unregister_node)\r\n__hugetlb_unregister_node(node);\r\n}\r\nvoid register_hugetlbfs_with_node(node_registration_func_t doregister,\r\nnode_registration_func_t unregister)\r\n{\r\n__hugetlb_register_node = doregister;\r\n__hugetlb_unregister_node = unregister;\r\n}\r\nstatic inline void hugetlb_register_node(struct node *node) {}\r\nstatic inline void hugetlb_unregister_node(struct node *node) {}\r\nstatic void node_device_release(struct device *dev)\r\n{\r\nstruct node *node = to_node(dev);\r\n#if defined(CONFIG_MEMORY_HOTPLUG_SPARSE) && defined(CONFIG_HUGETLBFS)\r\nflush_work(&node->node_work);\r\n#endif\r\nkfree(node);\r\n}\r\nstatic int register_node(struct node *node, int num, struct node *parent)\r\n{\r\nint error;\r\nnode->dev.id = num;\r\nnode->dev.bus = &node_subsys;\r\nnode->dev.release = node_device_release;\r\nnode->dev.groups = node_dev_groups;\r\nerror = device_register(&node->dev);\r\nif (!error){\r\nhugetlb_register_node(node);\r\ncompaction_register_node(node);\r\n}\r\nreturn error;\r\n}\r\nvoid unregister_node(struct node *node)\r\n{\r\nhugetlb_unregister_node(node);\r\ndevice_unregister(&node->dev);\r\n}\r\nint register_cpu_under_node(unsigned int cpu, unsigned int nid)\r\n{\r\nint ret;\r\nstruct device *obj;\r\nif (!node_online(nid))\r\nreturn 0;\r\nobj = get_cpu_device(cpu);\r\nif (!obj)\r\nreturn 0;\r\nret = sysfs_create_link(&node_devices[nid]->dev.kobj,\r\n&obj->kobj,\r\nkobject_name(&obj->kobj));\r\nif (ret)\r\nreturn ret;\r\nreturn sysfs_create_link(&obj->kobj,\r\n&node_devices[nid]->dev.kobj,\r\nkobject_name(&node_devices[nid]->dev.kobj));\r\n}\r\nint unregister_cpu_under_node(unsigned int cpu, unsigned int nid)\r\n{\r\nstruct device *obj;\r\nif (!node_online(nid))\r\nreturn 0;\r\nobj = get_cpu_device(cpu);\r\nif (!obj)\r\nreturn 0;\r\nsysfs_remove_link(&node_devices[nid]->dev.kobj,\r\nkobject_name(&obj->kobj));\r\nsysfs_remove_link(&obj->kobj,\r\nkobject_name(&node_devices[nid]->dev.kobj));\r\nreturn 0;\r\n}\r\nstatic int __ref get_nid_for_pfn(unsigned long pfn)\r\n{\r\nstruct page *page;\r\nif (!pfn_valid_within(pfn))\r\nreturn -1;\r\n#ifdef CONFIG_DEFERRED_STRUCT_PAGE_INIT\r\nif (system_state == SYSTEM_BOOTING)\r\nreturn early_pfn_to_nid(pfn);\r\n#endif\r\npage = pfn_to_page(pfn);\r\nif (!page_initialized(page))\r\nreturn -1;\r\nreturn pfn_to_nid(pfn);\r\n}\r\nint register_mem_sect_under_node(struct memory_block *mem_blk, int nid)\r\n{\r\nint ret;\r\nunsigned long pfn, sect_start_pfn, sect_end_pfn;\r\nif (!mem_blk)\r\nreturn -EFAULT;\r\nif (!node_online(nid))\r\nreturn 0;\r\nsect_start_pfn = section_nr_to_pfn(mem_blk->start_section_nr);\r\nsect_end_pfn = section_nr_to_pfn(mem_blk->end_section_nr);\r\nsect_end_pfn += PAGES_PER_SECTION - 1;\r\nfor (pfn = sect_start_pfn; pfn <= sect_end_pfn; pfn++) {\r\nint page_nid;\r\nif (!pfn_present(pfn)) {\r\npfn = round_down(pfn + PAGES_PER_SECTION,\r\nPAGES_PER_SECTION) - 1;\r\ncontinue;\r\n}\r\npage_nid = get_nid_for_pfn(pfn);\r\nif (page_nid < 0)\r\ncontinue;\r\nif (page_nid != nid)\r\ncontinue;\r\nret = sysfs_create_link_nowarn(&node_devices[nid]->dev.kobj,\r\n&mem_blk->dev.kobj,\r\nkobject_name(&mem_blk->dev.kobj));\r\nif (ret)\r\nreturn ret;\r\nreturn sysfs_create_link_nowarn(&mem_blk->dev.kobj,\r\n&node_devices[nid]->dev.kobj,\r\nkobject_name(&node_devices[nid]->dev.kobj));\r\n}\r\nreturn 0;\r\n}\r\nint unregister_mem_sect_under_nodes(struct memory_block *mem_blk,\r\nunsigned long phys_index)\r\n{\r\nNODEMASK_ALLOC(nodemask_t, unlinked_nodes, GFP_KERNEL);\r\nunsigned long pfn, sect_start_pfn, sect_end_pfn;\r\nif (!mem_blk) {\r\nNODEMASK_FREE(unlinked_nodes);\r\nreturn -EFAULT;\r\n}\r\nif (!unlinked_nodes)\r\nreturn -ENOMEM;\r\nnodes_clear(*unlinked_nodes);\r\nsect_start_pfn = section_nr_to_pfn(phys_index);\r\nsect_end_pfn = sect_start_pfn + PAGES_PER_SECTION - 1;\r\nfor (pfn = sect_start_pfn; pfn <= sect_end_pfn; pfn++) {\r\nint nid;\r\nnid = get_nid_for_pfn(pfn);\r\nif (nid < 0)\r\ncontinue;\r\nif (!node_online(nid))\r\ncontinue;\r\nif (node_test_and_set(nid, *unlinked_nodes))\r\ncontinue;\r\nsysfs_remove_link(&node_devices[nid]->dev.kobj,\r\nkobject_name(&mem_blk->dev.kobj));\r\nsysfs_remove_link(&mem_blk->dev.kobj,\r\nkobject_name(&node_devices[nid]->dev.kobj));\r\n}\r\nNODEMASK_FREE(unlinked_nodes);\r\nreturn 0;\r\n}\r\nstatic int link_mem_sections(int nid)\r\n{\r\nunsigned long start_pfn = NODE_DATA(nid)->node_start_pfn;\r\nunsigned long end_pfn = start_pfn + NODE_DATA(nid)->node_spanned_pages;\r\nunsigned long pfn;\r\nstruct memory_block *mem_blk = NULL;\r\nint err = 0;\r\nfor (pfn = start_pfn; pfn < end_pfn; pfn += PAGES_PER_SECTION) {\r\nunsigned long section_nr = pfn_to_section_nr(pfn);\r\nstruct mem_section *mem_sect;\r\nint ret;\r\nif (!present_section_nr(section_nr))\r\ncontinue;\r\nmem_sect = __nr_to_section(section_nr);\r\nif (mem_blk)\r\nif ((section_nr >= mem_blk->start_section_nr) &&\r\n(section_nr <= mem_blk->end_section_nr))\r\ncontinue;\r\nmem_blk = find_memory_block_hinted(mem_sect, mem_blk);\r\nret = register_mem_sect_under_node(mem_blk, nid);\r\nif (!err)\r\nerr = ret;\r\n}\r\nif (mem_blk)\r\nkobject_put(&mem_blk->dev.kobj);\r\nreturn err;\r\n}\r\nstatic void node_hugetlb_work(struct work_struct *work)\r\n{\r\nstruct node *node = container_of(work, struct node, node_work);\r\nif (!hugetlb_register_node(node))\r\nhugetlb_unregister_node(node);\r\n}\r\nstatic void init_node_hugetlb_work(int nid)\r\n{\r\nINIT_WORK(&node_devices[nid]->node_work, node_hugetlb_work);\r\n}\r\nstatic int node_memory_callback(struct notifier_block *self,\r\nunsigned long action, void *arg)\r\n{\r\nstruct memory_notify *mnb = arg;\r\nint nid = mnb->status_change_nid;\r\nswitch (action) {\r\ncase MEM_ONLINE:\r\ncase MEM_OFFLINE:\r\nif (nid != NUMA_NO_NODE)\r\nschedule_work(&node_devices[nid]->node_work);\r\nbreak;\r\ncase MEM_GOING_ONLINE:\r\ncase MEM_GOING_OFFLINE:\r\ncase MEM_CANCEL_ONLINE:\r\ncase MEM_CANCEL_OFFLINE:\r\ndefault:\r\nbreak;\r\n}\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int link_mem_sections(int nid) { return 0; }\r\nstatic inline int node_memory_callback(struct notifier_block *self,\r\nunsigned long action, void *arg)\r\n{\r\nreturn NOTIFY_OK;\r\n}\r\nstatic void init_node_hugetlb_work(int nid) { }\r\nint register_one_node(int nid)\r\n{\r\nint error = 0;\r\nint cpu;\r\nif (node_online(nid)) {\r\nint p_node = parent_node(nid);\r\nstruct node *parent = NULL;\r\nif (p_node != nid)\r\nparent = node_devices[p_node];\r\nnode_devices[nid] = kzalloc(sizeof(struct node), GFP_KERNEL);\r\nif (!node_devices[nid])\r\nreturn -ENOMEM;\r\nerror = register_node(node_devices[nid], nid, parent);\r\nfor_each_present_cpu(cpu) {\r\nif (cpu_to_node(cpu) == nid)\r\nregister_cpu_under_node(cpu, nid);\r\n}\r\nerror = link_mem_sections(nid);\r\ninit_node_hugetlb_work(nid);\r\n}\r\nreturn error;\r\n}\r\nvoid unregister_one_node(int nid)\r\n{\r\nif (!node_devices[nid])\r\nreturn;\r\nunregister_node(node_devices[nid]);\r\nnode_devices[nid] = NULL;\r\n}\r\nstatic ssize_t print_nodes_state(enum node_states state, char *buf)\r\n{\r\nint n;\r\nn = scnprintf(buf, PAGE_SIZE - 1, "%*pbl",\r\nnodemask_pr_args(&node_states[state]));\r\nbuf[n++] = '\n';\r\nbuf[n] = '\0';\r\nreturn n;\r\n}\r\nstatic ssize_t show_node_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct node_attr *na = container_of(attr, struct node_attr, attr);\r\nreturn print_nodes_state(na->state, buf);\r\n}\r\nstatic int __init register_node_type(void)\r\n{\r\nint ret;\r\nBUILD_BUG_ON(ARRAY_SIZE(node_state_attr) != NR_NODE_STATES);\r\nBUILD_BUG_ON(ARRAY_SIZE(node_state_attrs)-1 != NR_NODE_STATES);\r\nret = subsys_system_register(&node_subsys, cpu_root_attr_groups);\r\nif (!ret) {\r\nstatic struct notifier_block node_memory_callback_nb = {\r\n.notifier_call = node_memory_callback,\r\n.priority = NODE_CALLBACK_PRI,\r\n};\r\nregister_hotmemory_notifier(&node_memory_callback_nb);\r\n}\r\nreturn ret;\r\n}
