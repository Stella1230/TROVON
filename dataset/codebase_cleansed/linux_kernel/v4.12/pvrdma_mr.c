struct ib_mr *pvrdma_get_dma_mr(struct ib_pd *pd, int acc)\r\n{\r\nstruct pvrdma_dev *dev = to_vdev(pd->device);\r\nstruct pvrdma_user_mr *mr;\r\nunion pvrdma_cmd_req req;\r\nunion pvrdma_cmd_resp rsp;\r\nstruct pvrdma_cmd_create_mr *cmd = &req.create_mr;\r\nstruct pvrdma_cmd_create_mr_resp *resp = &rsp.create_mr_resp;\r\nint ret;\r\nif (acc & ~IB_ACCESS_LOCAL_WRITE) {\r\ndev_warn(&dev->pdev->dev,\r\n"unsupported dma mr access flags %#x\n", acc);\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\n}\r\nmr = kzalloc(sizeof(*mr), GFP_KERNEL);\r\nif (!mr)\r\nreturn ERR_PTR(-ENOMEM);\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->hdr.cmd = PVRDMA_CMD_CREATE_MR;\r\ncmd->pd_handle = to_vpd(pd)->pd_handle;\r\ncmd->access_flags = acc;\r\ncmd->flags = PVRDMA_MR_FLAG_DMA;\r\nret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_MR_RESP);\r\nif (ret < 0) {\r\ndev_warn(&dev->pdev->dev,\r\n"could not get DMA mem region, error: %d\n", ret);\r\nkfree(mr);\r\nreturn ERR_PTR(ret);\r\n}\r\nmr->mmr.mr_handle = resp->mr_handle;\r\nmr->ibmr.lkey = resp->lkey;\r\nmr->ibmr.rkey = resp->rkey;\r\nreturn &mr->ibmr;\r\n}\r\nstruct ib_mr *pvrdma_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,\r\nu64 virt_addr, int access_flags,\r\nstruct ib_udata *udata)\r\n{\r\nstruct pvrdma_dev *dev = to_vdev(pd->device);\r\nstruct pvrdma_user_mr *mr = NULL;\r\nstruct ib_umem *umem;\r\nunion pvrdma_cmd_req req;\r\nunion pvrdma_cmd_resp rsp;\r\nstruct pvrdma_cmd_create_mr *cmd = &req.create_mr;\r\nstruct pvrdma_cmd_create_mr_resp *resp = &rsp.create_mr_resp;\r\nint nchunks;\r\nint ret;\r\nint entry;\r\nstruct scatterlist *sg;\r\nif (length == 0 || length > dev->dsr->caps.max_mr_size) {\r\ndev_warn(&dev->pdev->dev, "invalid mem region length\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\numem = ib_umem_get(pd->uobject->context, start,\r\nlength, access_flags, 0);\r\nif (IS_ERR(umem)) {\r\ndev_warn(&dev->pdev->dev,\r\n"could not get umem for mem region\n");\r\nreturn ERR_CAST(umem);\r\n}\r\nnchunks = 0;\r\nfor_each_sg(umem->sg_head.sgl, sg, umem->nmap, entry)\r\nnchunks += sg_dma_len(sg) >> PAGE_SHIFT;\r\nif (nchunks < 0 || nchunks > PVRDMA_PAGE_DIR_MAX_PAGES) {\r\ndev_warn(&dev->pdev->dev, "overflow %d pages in mem region\n",\r\nnchunks);\r\nret = -EINVAL;\r\ngoto err_umem;\r\n}\r\nmr = kzalloc(sizeof(*mr), GFP_KERNEL);\r\nif (!mr) {\r\nret = -ENOMEM;\r\ngoto err_umem;\r\n}\r\nmr->mmr.iova = virt_addr;\r\nmr->mmr.size = length;\r\nmr->umem = umem;\r\nret = pvrdma_page_dir_init(dev, &mr->pdir, nchunks, false);\r\nif (ret) {\r\ndev_warn(&dev->pdev->dev,\r\n"could not allocate page directory\n");\r\ngoto err_umem;\r\n}\r\nret = pvrdma_page_dir_insert_umem(&mr->pdir, mr->umem, 0);\r\nif (ret)\r\ngoto err_pdir;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->hdr.cmd = PVRDMA_CMD_CREATE_MR;\r\ncmd->start = start;\r\ncmd->length = length;\r\ncmd->pd_handle = to_vpd(pd)->pd_handle;\r\ncmd->access_flags = access_flags;\r\ncmd->nchunks = nchunks;\r\ncmd->pdir_dma = mr->pdir.dir_dma;\r\nret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_MR_RESP);\r\nif (ret < 0) {\r\ndev_warn(&dev->pdev->dev,\r\n"could not register mem region, error: %d\n", ret);\r\ngoto err_pdir;\r\n}\r\nmr->mmr.mr_handle = resp->mr_handle;\r\nmr->ibmr.lkey = resp->lkey;\r\nmr->ibmr.rkey = resp->rkey;\r\nreturn &mr->ibmr;\r\nerr_pdir:\r\npvrdma_page_dir_cleanup(dev, &mr->pdir);\r\nerr_umem:\r\nib_umem_release(umem);\r\nkfree(mr);\r\nreturn ERR_PTR(ret);\r\n}\r\nstruct ib_mr *pvrdma_alloc_mr(struct ib_pd *pd, enum ib_mr_type mr_type,\r\nu32 max_num_sg)\r\n{\r\nstruct pvrdma_dev *dev = to_vdev(pd->device);\r\nstruct pvrdma_user_mr *mr;\r\nunion pvrdma_cmd_req req;\r\nunion pvrdma_cmd_resp rsp;\r\nstruct pvrdma_cmd_create_mr *cmd = &req.create_mr;\r\nstruct pvrdma_cmd_create_mr_resp *resp = &rsp.create_mr_resp;\r\nint size = max_num_sg * sizeof(u64);\r\nint ret;\r\nif (mr_type != IB_MR_TYPE_MEM_REG ||\r\nmax_num_sg > PVRDMA_MAX_FAST_REG_PAGES)\r\nreturn ERR_PTR(-EINVAL);\r\nmr = kzalloc(sizeof(*mr), GFP_KERNEL);\r\nif (!mr)\r\nreturn ERR_PTR(-ENOMEM);\r\nmr->pages = kzalloc(size, GFP_KERNEL);\r\nif (!mr->pages) {\r\nret = -ENOMEM;\r\ngoto freemr;\r\n}\r\nret = pvrdma_page_dir_init(dev, &mr->pdir, max_num_sg, false);\r\nif (ret) {\r\ndev_warn(&dev->pdev->dev,\r\n"failed to allocate page dir for mr\n");\r\nret = -ENOMEM;\r\ngoto freepages;\r\n}\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->hdr.cmd = PVRDMA_CMD_CREATE_MR;\r\ncmd->pd_handle = to_vpd(pd)->pd_handle;\r\ncmd->access_flags = 0;\r\ncmd->flags = PVRDMA_MR_FLAG_FRMR;\r\ncmd->nchunks = max_num_sg;\r\nret = pvrdma_cmd_post(dev, &req, &rsp, PVRDMA_CMD_CREATE_MR_RESP);\r\nif (ret < 0) {\r\ndev_warn(&dev->pdev->dev,\r\n"could not create FR mem region, error: %d\n", ret);\r\ngoto freepdir;\r\n}\r\nmr->max_pages = max_num_sg;\r\nmr->mmr.mr_handle = resp->mr_handle;\r\nmr->ibmr.lkey = resp->lkey;\r\nmr->ibmr.rkey = resp->rkey;\r\nmr->page_shift = PAGE_SHIFT;\r\nmr->umem = NULL;\r\nreturn &mr->ibmr;\r\nfreepdir:\r\npvrdma_page_dir_cleanup(dev, &mr->pdir);\r\nfreepages:\r\nkfree(mr->pages);\r\nfreemr:\r\nkfree(mr);\r\nreturn ERR_PTR(ret);\r\n}\r\nint pvrdma_dereg_mr(struct ib_mr *ibmr)\r\n{\r\nstruct pvrdma_user_mr *mr = to_vmr(ibmr);\r\nstruct pvrdma_dev *dev = to_vdev(ibmr->device);\r\nunion pvrdma_cmd_req req;\r\nstruct pvrdma_cmd_destroy_mr *cmd = &req.destroy_mr;\r\nint ret;\r\nmemset(cmd, 0, sizeof(*cmd));\r\ncmd->hdr.cmd = PVRDMA_CMD_DESTROY_MR;\r\ncmd->mr_handle = mr->mmr.mr_handle;\r\nret = pvrdma_cmd_post(dev, &req, NULL, 0);\r\nif (ret < 0)\r\ndev_warn(&dev->pdev->dev,\r\n"could not deregister mem region, error: %d\n", ret);\r\npvrdma_page_dir_cleanup(dev, &mr->pdir);\r\nif (mr->umem)\r\nib_umem_release(mr->umem);\r\nkfree(mr->pages);\r\nkfree(mr);\r\nreturn 0;\r\n}\r\nstatic int pvrdma_set_page(struct ib_mr *ibmr, u64 addr)\r\n{\r\nstruct pvrdma_user_mr *mr = to_vmr(ibmr);\r\nif (mr->npages == mr->max_pages)\r\nreturn -ENOMEM;\r\nmr->pages[mr->npages++] = addr;\r\nreturn 0;\r\n}\r\nint pvrdma_map_mr_sg(struct ib_mr *ibmr, struct scatterlist *sg, int sg_nents,\r\nunsigned int *sg_offset)\r\n{\r\nstruct pvrdma_user_mr *mr = to_vmr(ibmr);\r\nstruct pvrdma_dev *dev = to_vdev(ibmr->device);\r\nint ret;\r\nmr->npages = 0;\r\nret = ib_sg_to_pages(ibmr, sg, sg_nents, sg_offset, pvrdma_set_page);\r\nif (ret < 0)\r\ndev_warn(&dev->pdev->dev, "could not map sg to pages\n");\r\nreturn ret;\r\n}
