int op_cache_initialize(void)\r\n{\r\nop_cache = kmem_cache_create("orangefs_op_cache",\r\nsizeof(struct orangefs_kernel_op_s),\r\n0,\r\nORANGEFS_CACHE_CREATE_FLAGS,\r\nNULL);\r\nif (!op_cache) {\r\ngossip_err("Cannot create orangefs_op_cache\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock(&next_tag_value_lock);\r\nnext_tag_value = 100;\r\nspin_unlock(&next_tag_value_lock);\r\nreturn 0;\r\n}\r\nint op_cache_finalize(void)\r\n{\r\nkmem_cache_destroy(op_cache);\r\nreturn 0;\r\n}\r\nchar *get_opname_string(struct orangefs_kernel_op_s *new_op)\r\n{\r\nif (new_op) {\r\n__s32 type = new_op->upcall.type;\r\nif (type == ORANGEFS_VFS_OP_FILE_IO)\r\nreturn "OP_FILE_IO";\r\nelse if (type == ORANGEFS_VFS_OP_LOOKUP)\r\nreturn "OP_LOOKUP";\r\nelse if (type == ORANGEFS_VFS_OP_CREATE)\r\nreturn "OP_CREATE";\r\nelse if (type == ORANGEFS_VFS_OP_GETATTR)\r\nreturn "OP_GETATTR";\r\nelse if (type == ORANGEFS_VFS_OP_REMOVE)\r\nreturn "OP_REMOVE";\r\nelse if (type == ORANGEFS_VFS_OP_MKDIR)\r\nreturn "OP_MKDIR";\r\nelse if (type == ORANGEFS_VFS_OP_READDIR)\r\nreturn "OP_READDIR";\r\nelse if (type == ORANGEFS_VFS_OP_READDIRPLUS)\r\nreturn "OP_READDIRPLUS";\r\nelse if (type == ORANGEFS_VFS_OP_SETATTR)\r\nreturn "OP_SETATTR";\r\nelse if (type == ORANGEFS_VFS_OP_SYMLINK)\r\nreturn "OP_SYMLINK";\r\nelse if (type == ORANGEFS_VFS_OP_RENAME)\r\nreturn "OP_RENAME";\r\nelse if (type == ORANGEFS_VFS_OP_STATFS)\r\nreturn "OP_STATFS";\r\nelse if (type == ORANGEFS_VFS_OP_TRUNCATE)\r\nreturn "OP_TRUNCATE";\r\nelse if (type == ORANGEFS_VFS_OP_RA_FLUSH)\r\nreturn "OP_RA_FLUSH";\r\nelse if (type == ORANGEFS_VFS_OP_FS_MOUNT)\r\nreturn "OP_FS_MOUNT";\r\nelse if (type == ORANGEFS_VFS_OP_FS_UMOUNT)\r\nreturn "OP_FS_UMOUNT";\r\nelse if (type == ORANGEFS_VFS_OP_GETXATTR)\r\nreturn "OP_GETXATTR";\r\nelse if (type == ORANGEFS_VFS_OP_SETXATTR)\r\nreturn "OP_SETXATTR";\r\nelse if (type == ORANGEFS_VFS_OP_LISTXATTR)\r\nreturn "OP_LISTXATTR";\r\nelse if (type == ORANGEFS_VFS_OP_REMOVEXATTR)\r\nreturn "OP_REMOVEXATTR";\r\nelse if (type == ORANGEFS_VFS_OP_PARAM)\r\nreturn "OP_PARAM";\r\nelse if (type == ORANGEFS_VFS_OP_PERF_COUNT)\r\nreturn "OP_PERF_COUNT";\r\nelse if (type == ORANGEFS_VFS_OP_CANCEL)\r\nreturn "OP_CANCEL";\r\nelse if (type == ORANGEFS_VFS_OP_FSYNC)\r\nreturn "OP_FSYNC";\r\nelse if (type == ORANGEFS_VFS_OP_FSKEY)\r\nreturn "OP_FSKEY";\r\nelse if (type == ORANGEFS_VFS_OP_FEATURES)\r\nreturn "OP_FEATURES";\r\n}\r\nreturn "OP_UNKNOWN?";\r\n}\r\nvoid orangefs_new_tag(struct orangefs_kernel_op_s *op)\r\n{\r\nspin_lock(&next_tag_value_lock);\r\nop->tag = next_tag_value++;\r\nif (next_tag_value == 0)\r\nnext_tag_value = 100;\r\nspin_unlock(&next_tag_value_lock);\r\n}\r\nstruct orangefs_kernel_op_s *op_alloc(__s32 type)\r\n{\r\nstruct orangefs_kernel_op_s *new_op = NULL;\r\nnew_op = kmem_cache_zalloc(op_cache, GFP_KERNEL);\r\nif (new_op) {\r\nINIT_LIST_HEAD(&new_op->list);\r\nspin_lock_init(&new_op->lock);\r\ninit_completion(&new_op->waitq);\r\nnew_op->upcall.type = ORANGEFS_VFS_OP_INVALID;\r\nnew_op->downcall.type = ORANGEFS_VFS_OP_INVALID;\r\nnew_op->downcall.status = -1;\r\nnew_op->op_state = OP_VFS_STATE_UNKNOWN;\r\norangefs_new_tag(new_op);\r\nnew_op->upcall.type = type;\r\nnew_op->attempts = 0;\r\ngossip_debug(GOSSIP_CACHE_DEBUG,\r\n"Alloced OP (%p: %llu %s)\n",\r\nnew_op,\r\nllu(new_op->tag),\r\nget_opname_string(new_op));\r\nnew_op->upcall.uid = from_kuid(&init_user_ns,\r\ncurrent_fsuid());\r\nnew_op->upcall.gid = from_kgid(&init_user_ns,\r\ncurrent_fsgid());\r\n} else {\r\ngossip_err("op_alloc: kmem_cache_zalloc failed!\n");\r\n}\r\nreturn new_op;\r\n}\r\nvoid op_release(struct orangefs_kernel_op_s *orangefs_op)\r\n{\r\nif (orangefs_op) {\r\ngossip_debug(GOSSIP_CACHE_DEBUG,\r\n"Releasing OP (%p: %llu)\n",\r\norangefs_op,\r\nllu(orangefs_op->tag));\r\nkmem_cache_free(op_cache, orangefs_op);\r\n} else {\r\ngossip_err("NULL pointer in op_release\n");\r\n}\r\n}
