static int\r\nname_device(struct snd_bebob *bebob)\r\n{\r\nstruct fw_device *fw_dev = fw_parent_device(bebob->unit);\r\nchar vendor[24] = {0};\r\nchar model[32] = {0};\r\nu32 hw_id;\r\nu32 data[2] = {0};\r\nu32 revision;\r\nu32 version;\r\nint err;\r\nerr = fw_csr_string(fw_dev->config_rom + 5, CSR_VENDOR,\r\nvendor, sizeof(vendor));\r\nif (err < 0)\r\ngoto end;\r\nerr = fw_csr_string(bebob->unit->directory, CSR_MODEL,\r\nmodel, sizeof(model));\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_ID,\r\n&hw_id);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_HW_MODEL_REVISION,\r\n&revision);\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_block(bebob->unit, INFO_OFFSET_GUID,\r\ndata, sizeof(data));\r\nif (err < 0)\r\ngoto end;\r\nerr = snd_bebob_read_quad(bebob->unit, INFO_OFFSET_BEBOB_VERSION,\r\n&version);\r\nif (err < 0)\r\ngoto end;\r\nbebob->version = version;\r\nstrcpy(bebob->card->driver, "BeBoB");\r\nstrcpy(bebob->card->shortname, model);\r\nstrcpy(bebob->card->mixername, model);\r\nsnprintf(bebob->card->longname, sizeof(bebob->card->longname),\r\n"%s %s (id:%d, rev:%d), GUID %08x%08x at %s, S%d",\r\nvendor, model, hw_id, revision,\r\ndata[0], data[1], dev_name(&bebob->unit->device),\r\n100 << fw_dev->max_speed);\r\nend:\r\nreturn err;\r\n}\r\nstatic void bebob_free(struct snd_bebob *bebob)\r\n{\r\nsnd_bebob_stream_destroy_duplex(bebob);\r\nfw_unit_put(bebob->unit);\r\nkfree(bebob->maudio_special_quirk);\r\nmutex_destroy(&bebob->mutex);\r\nkfree(bebob);\r\n}\r\nstatic void\r\nbebob_card_free(struct snd_card *card)\r\n{\r\nstruct snd_bebob *bebob = card->private_data;\r\nmutex_lock(&devices_mutex);\r\nclear_bit(bebob->card_index, devices_used);\r\nmutex_unlock(&devices_mutex);\r\nbebob_free(card->private_data);\r\n}\r\nstatic const struct snd_bebob_spec *\r\nget_saffire_spec(struct fw_unit *unit)\r\n{\r\nchar name[24] = {0};\r\nif (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)\r\nreturn NULL;\r\nif (strcmp(name, "SaffireLE") == 0)\r\nreturn &saffire_le_spec;\r\nelse\r\nreturn &saffire_spec;\r\n}\r\nstatic bool\r\ncheck_audiophile_booted(struct fw_unit *unit)\r\n{\r\nchar name[28] = {0};\r\nif (fw_csr_string(unit->directory, CSR_MODEL, name, sizeof(name)) < 0)\r\nreturn false;\r\nreturn strncmp(name, "FW Audiophile Bootloader", 24) != 0;\r\n}\r\nstatic void\r\ndo_registration(struct work_struct *work)\r\n{\r\nstruct snd_bebob *bebob =\r\ncontainer_of(work, struct snd_bebob, dwork.work);\r\nunsigned int card_index;\r\nint err;\r\nif (bebob->registered)\r\nreturn;\r\nmutex_lock(&devices_mutex);\r\nfor (card_index = 0; card_index < SNDRV_CARDS; card_index++) {\r\nif (!test_bit(card_index, devices_used) && enable[card_index])\r\nbreak;\r\n}\r\nif (card_index >= SNDRV_CARDS) {\r\nmutex_unlock(&devices_mutex);\r\nreturn;\r\n}\r\nerr = snd_card_new(&bebob->unit->device, index[card_index],\r\nid[card_index], THIS_MODULE, 0, &bebob->card);\r\nif (err < 0) {\r\nmutex_unlock(&devices_mutex);\r\nreturn;\r\n}\r\nerr = name_device(bebob);\r\nif (err < 0)\r\ngoto error;\r\nif (bebob->spec == &maudio_special_spec) {\r\nif (bebob->entry->model_id == MODEL_MAUDIO_FW1814)\r\nerr = snd_bebob_maudio_special_discover(bebob, true);\r\nelse\r\nerr = snd_bebob_maudio_special_discover(bebob, false);\r\n} else {\r\nerr = snd_bebob_stream_discover(bebob);\r\n}\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_bebob_stream_init_duplex(bebob);\r\nif (err < 0)\r\ngoto error;\r\nsnd_bebob_proc_init(bebob);\r\nif (bebob->midi_input_ports > 0 || bebob->midi_output_ports > 0) {\r\nerr = snd_bebob_create_midi_devices(bebob);\r\nif (err < 0)\r\ngoto error;\r\n}\r\nerr = snd_bebob_create_pcm_devices(bebob);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_bebob_create_hwdep_device(bebob);\r\nif (err < 0)\r\ngoto error;\r\nerr = snd_card_register(bebob->card);\r\nif (err < 0)\r\ngoto error;\r\nset_bit(card_index, devices_used);\r\nmutex_unlock(&devices_mutex);\r\nbebob->card->private_free = bebob_card_free;\r\nbebob->card->private_data = bebob;\r\nbebob->registered = true;\r\nreturn;\r\nerror:\r\nmutex_unlock(&devices_mutex);\r\nsnd_bebob_stream_destroy_duplex(bebob);\r\nsnd_card_free(bebob->card);\r\ndev_info(&bebob->unit->device,\r\n"Sound card registration failed: %d\n", err);\r\n}\r\nstatic int\r\nbebob_probe(struct fw_unit *unit, const struct ieee1394_device_id *entry)\r\n{\r\nstruct snd_bebob *bebob;\r\nconst struct snd_bebob_spec *spec;\r\nif (entry->vendor_id == VEN_FOCUSRITE &&\r\nentry->model_id == MODEL_FOCUSRITE_SAFFIRE_BOTH)\r\nspec = get_saffire_spec(unit);\r\nelse if (entry->vendor_id == VEN_MAUDIO1 &&\r\nentry->model_id == MODEL_MAUDIO_AUDIOPHILE_BOTH &&\r\n!check_audiophile_booted(unit))\r\nspec = NULL;\r\nelse\r\nspec = (const struct snd_bebob_spec *)entry->driver_data;\r\nif (spec == NULL) {\r\nif (entry->vendor_id == VEN_MAUDIO1 ||\r\nentry->vendor_id == VEN_MAUDIO2)\r\nreturn snd_bebob_maudio_load_firmware(unit);\r\nelse\r\nreturn -ENODEV;\r\n}\r\nbebob = kzalloc(sizeof(struct snd_bebob), GFP_KERNEL);\r\nif (bebob == NULL)\r\nreturn -ENOMEM;\r\nbebob->unit = fw_unit_get(unit);\r\nbebob->entry = entry;\r\nbebob->spec = spec;\r\ndev_set_drvdata(&unit->device, bebob);\r\nmutex_init(&bebob->mutex);\r\nspin_lock_init(&bebob->lock);\r\ninit_waitqueue_head(&bebob->hwdep_wait);\r\nINIT_DEFERRABLE_WORK(&bebob->dwork, do_registration);\r\nif (entry->vendor_id != VEN_MAUDIO1 ||\r\n(entry->model_id != MODEL_MAUDIO_FW1814 &&\r\nentry->model_id != MODEL_MAUDIO_PROJECTMIX)) {\r\nsnd_fw_schedule_registration(unit, &bebob->dwork);\r\n} else {\r\nfw_schedule_bus_reset(fw_parent_device(bebob->unit)->card,\r\nfalse, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nbebob_update(struct fw_unit *unit)\r\n{\r\nstruct snd_bebob *bebob = dev_get_drvdata(&unit->device);\r\nif (bebob == NULL)\r\nreturn;\r\nif (!bebob->registered)\r\nsnd_fw_schedule_registration(unit, &bebob->dwork);\r\nelse\r\nfcp_bus_reset(bebob->unit);\r\n}\r\nstatic void bebob_remove(struct fw_unit *unit)\r\n{\r\nstruct snd_bebob *bebob = dev_get_drvdata(&unit->device);\r\nif (bebob == NULL)\r\nreturn;\r\ncancel_delayed_work_sync(&bebob->dwork);\r\nif (bebob->registered) {\r\nsnd_card_free_when_closed(bebob->card);\r\n} else {\r\nbebob_free(bebob);\r\n}\r\n}\r\nstatic int __init\r\nsnd_bebob_init(void)\r\n{\r\nreturn driver_register(&bebob_driver.driver);\r\n}\r\nstatic void __exit\r\nsnd_bebob_exit(void)\r\n{\r\ndriver_unregister(&bebob_driver.driver);\r\n}
