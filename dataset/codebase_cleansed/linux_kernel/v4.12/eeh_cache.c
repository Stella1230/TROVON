static inline struct eeh_dev *__eeh_addr_cache_get_device(unsigned long addr)\r\n{\r\nstruct rb_node *n = pci_io_addr_cache_root.rb_root.rb_node;\r\nwhile (n) {\r\nstruct pci_io_addr_range *piar;\r\npiar = rb_entry(n, struct pci_io_addr_range, rb_node);\r\nif (addr < piar->addr_lo)\r\nn = n->rb_left;\r\nelse if (addr > piar->addr_hi)\r\nn = n->rb_right;\r\nelse\r\nreturn piar->edev;\r\n}\r\nreturn NULL;\r\n}\r\nstruct eeh_dev *eeh_addr_cache_get_dev(unsigned long addr)\r\n{\r\nstruct eeh_dev *edev;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\r\nedev = __eeh_addr_cache_get_device(addr);\r\nspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\r\nreturn edev;\r\n}\r\nstatic void eeh_addr_cache_print(struct pci_io_addr_cache *cache)\r\n{\r\nstruct rb_node *n;\r\nint cnt = 0;\r\nn = rb_first(&cache->rb_root);\r\nwhile (n) {\r\nstruct pci_io_addr_range *piar;\r\npiar = rb_entry(n, struct pci_io_addr_range, rb_node);\r\npr_debug("PCI: %s addr range %d [%pap-%pap]: %s\n",\r\n(piar->flags & IORESOURCE_IO) ? "i/o" : "mem", cnt,\r\n&piar->addr_lo, &piar->addr_hi, pci_name(piar->pcidev));\r\ncnt++;\r\nn = rb_next(n);\r\n}\r\n}\r\nstatic struct pci_io_addr_range *\r\neeh_addr_cache_insert(struct pci_dev *dev, resource_size_t alo,\r\nresource_size_t ahi, unsigned long flags)\r\n{\r\nstruct rb_node **p = &pci_io_addr_cache_root.rb_root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct pci_io_addr_range *piar;\r\nwhile (*p) {\r\nparent = *p;\r\npiar = rb_entry(parent, struct pci_io_addr_range, rb_node);\r\nif (ahi < piar->addr_lo) {\r\np = &parent->rb_left;\r\n} else if (alo > piar->addr_hi) {\r\np = &parent->rb_right;\r\n} else {\r\nif (dev != piar->pcidev ||\r\nalo != piar->addr_lo || ahi != piar->addr_hi) {\r\npr_warn("PIAR: overlapping address range\n");\r\n}\r\nreturn piar;\r\n}\r\n}\r\npiar = kzalloc(sizeof(struct pci_io_addr_range), GFP_ATOMIC);\r\nif (!piar)\r\nreturn NULL;\r\npiar->addr_lo = alo;\r\npiar->addr_hi = ahi;\r\npiar->edev = pci_dev_to_eeh_dev(dev);\r\npiar->pcidev = dev;\r\npiar->flags = flags;\r\n#ifdef DEBUG\r\npr_debug("PIAR: insert range=[%pap:%pap] dev=%s\n",\r\n&alo, &ahi, pci_name(dev));\r\n#endif\r\nrb_link_node(&piar->rb_node, parent, p);\r\nrb_insert_color(&piar->rb_node, &pci_io_addr_cache_root.rb_root);\r\nreturn piar;\r\n}\r\nstatic void __eeh_addr_cache_insert_dev(struct pci_dev *dev)\r\n{\r\nstruct pci_dn *pdn;\r\nstruct eeh_dev *edev;\r\nint i;\r\npdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\r\nif (!pdn) {\r\npr_warn("PCI: no pci dn found for dev=%s\n",\r\npci_name(dev));\r\nreturn;\r\n}\r\nedev = pdn_to_eeh_dev(pdn);\r\nif (!edev) {\r\npr_warn("PCI: no EEH dev found for %s\n",\r\npci_name(dev));\r\nreturn;\r\n}\r\nif (!edev->pe) {\r\ndev_dbg(&dev->dev, "EEH: Skip building address cache\n");\r\nreturn;\r\n}\r\nfor (i = 0; i <= PCI_ROM_RESOURCE; i++) {\r\nresource_size_t start = pci_resource_start(dev,i);\r\nresource_size_t end = pci_resource_end(dev,i);\r\nunsigned long flags = pci_resource_flags(dev,i);\r\nif (0 == (flags & (IORESOURCE_IO | IORESOURCE_MEM)))\r\ncontinue;\r\nif (start == 0 || ~start == 0 || end == 0 || ~end == 0)\r\ncontinue;\r\neeh_addr_cache_insert(dev, start, end, flags);\r\n}\r\n}\r\nvoid eeh_addr_cache_insert_dev(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\r\n__eeh_addr_cache_insert_dev(dev);\r\nspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\r\n}\r\nstatic inline void __eeh_addr_cache_rmv_dev(struct pci_dev *dev)\r\n{\r\nstruct rb_node *n;\r\nrestart:\r\nn = rb_first(&pci_io_addr_cache_root.rb_root);\r\nwhile (n) {\r\nstruct pci_io_addr_range *piar;\r\npiar = rb_entry(n, struct pci_io_addr_range, rb_node);\r\nif (piar->pcidev == dev) {\r\nrb_erase(n, &pci_io_addr_cache_root.rb_root);\r\nkfree(piar);\r\ngoto restart;\r\n}\r\nn = rb_next(n);\r\n}\r\n}\r\nvoid eeh_addr_cache_rmv_dev(struct pci_dev *dev)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&pci_io_addr_cache_root.piar_lock, flags);\r\n__eeh_addr_cache_rmv_dev(dev);\r\nspin_unlock_irqrestore(&pci_io_addr_cache_root.piar_lock, flags);\r\n}\r\nvoid eeh_addr_cache_build(void)\r\n{\r\nstruct pci_dn *pdn;\r\nstruct eeh_dev *edev;\r\nstruct pci_dev *dev = NULL;\r\nspin_lock_init(&pci_io_addr_cache_root.piar_lock);\r\nfor_each_pci_dev(dev) {\r\npdn = pci_get_pdn_by_devfn(dev->bus, dev->devfn);\r\nif (!pdn)\r\ncontinue;\r\nedev = pdn_to_eeh_dev(pdn);\r\nif (!edev)\r\ncontinue;\r\ndev->dev.archdata.edev = edev;\r\nedev->pdev = dev;\r\neeh_addr_cache_insert_dev(dev);\r\neeh_sysfs_add_device(dev);\r\n}\r\n#ifdef DEBUG\r\neeh_addr_cache_print(&pci_io_addr_cache_root);\r\n#endif\r\n}
