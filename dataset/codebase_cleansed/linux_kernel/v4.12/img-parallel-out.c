static int img_prl_out_suspend(struct device *dev)\r\n{\r\nstruct img_prl_out *prl = dev_get_drvdata(dev);\r\nclk_disable_unprepare(prl->clk_ref);\r\nreturn 0;\r\n}\r\nstatic int img_prl_out_resume(struct device *dev)\r\n{\r\nstruct img_prl_out *prl = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(prl->clk_ref);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void img_prl_out_writel(struct img_prl_out *prl,\r\nu32 val, u32 reg)\r\n{\r\nwritel(val, prl->base + reg);\r\n}\r\nstatic inline u32 img_prl_out_readl(struct img_prl_out *prl, u32 reg)\r\n{\r\nreturn readl(prl->base + reg);\r\n}\r\nstatic void img_prl_out_reset(struct img_prl_out *prl)\r\n{\r\nu32 ctl;\r\nctl = img_prl_out_readl(prl, IMG_PRL_OUT_CTL) &\r\n~IMG_PRL_OUT_CTL_ME_MASK;\r\nreset_control_assert(prl->rst);\r\nreset_control_deassert(prl->rst);\r\nimg_prl_out_writel(prl, ctl, IMG_PRL_OUT_CTL);\r\n}\r\nstatic int img_prl_out_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);\r\nu32 reg;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nreg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);\r\nreg |= IMG_PRL_OUT_CTL_ME_MASK;\r\nimg_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nimg_prl_out_reset(prl);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int img_prl_out_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);\r\nunsigned int rate, channels;\r\nu32 reg, control_set = 0;\r\nrate = params_rate(params);\r\nchannels = params_channels(params);\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\ncontrol_set |= IMG_PRL_OUT_CTL_PACKH_MASK;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (channels != 2)\r\nreturn -EINVAL;\r\nclk_set_rate(prl->clk_ref, rate * 256);\r\nreg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);\r\nreg = (reg & ~IMG_PRL_OUT_CTL_PACKH_MASK) | control_set;\r\nimg_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);\r\nreturn 0;\r\n}\r\nstatic int img_prl_out_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);\r\nu32 reg, control_set = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ncontrol_set |= IMG_PRL_OUT_CTL_EDGE_MASK;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);\r\nreg = (reg & ~IMG_PRL_OUT_CTL_EDGE_MASK) | control_set;\r\nimg_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);\r\nreturn 0;\r\n}\r\nstatic int img_prl_out_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct img_prl_out *prl = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &prl->dma_data, NULL);\r\nreturn 0;\r\n}\r\nstatic int img_prl_out_probe(struct platform_device *pdev)\r\n{\r\nstruct img_prl_out *prl;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret;\r\nstruct device *dev = &pdev->dev;\r\nprl = devm_kzalloc(&pdev->dev, sizeof(*prl), GFP_KERNEL);\r\nif (!prl)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, prl);\r\nprl->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nprl->base = base;\r\nprl->rst = devm_reset_control_get(&pdev->dev, "rst");\r\nif (IS_ERR(prl->rst)) {\r\nif (PTR_ERR(prl->rst) != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "No top level reset found\n");\r\nreturn PTR_ERR(prl->rst);\r\n}\r\nprl->clk_sys = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(prl->clk_sys)) {\r\nif (PTR_ERR(prl->clk_sys) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'sys'\n");\r\nreturn PTR_ERR(prl->clk_sys);\r\n}\r\nprl->clk_ref = devm_clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(prl->clk_ref)) {\r\nif (PTR_ERR(prl->clk_ref) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'ref'\n");\r\nreturn PTR_ERR(prl->clk_ref);\r\n}\r\nret = clk_prepare_enable(prl->clk_sys);\r\nif (ret)\r\nreturn ret;\r\nimg_prl_out_writel(prl, IMG_PRL_OUT_CTL_EDGE_MASK, IMG_PRL_OUT_CTL);\r\nimg_prl_out_reset(prl);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = img_prl_out_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nprl->dma_data.addr = res->start + IMG_PRL_OUT_TX_FIFO;\r\nprl->dma_data.addr_width = 4;\r\nprl->dma_data.maxburst = 4;\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&img_prl_out_component,\r\n&img_prl_out_dai, 1);\r\nif (ret)\r\ngoto err_suspend;\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret)\r\ngoto err_suspend;\r\nreturn 0;\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nimg_prl_out_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(prl->clk_sys);\r\nreturn ret;\r\n}\r\nstatic int img_prl_out_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct img_prl_out *prl = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nimg_prl_out_suspend(&pdev->dev);\r\nclk_disable_unprepare(prl->clk_sys);\r\nreturn 0;\r\n}
