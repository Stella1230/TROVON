static void sisusb_free_buffers(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\nfor (i = 0; i < NUMOBUFS; i++) {\r\nkfree(sisusb->obuf[i]);\r\nsisusb->obuf[i] = NULL;\r\n}\r\nkfree(sisusb->ibuf);\r\nsisusb->ibuf = NULL;\r\n}\r\nstatic void sisusb_free_urbs(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\nfor (i = 0; i < NUMOBUFS; i++) {\r\nusb_free_urb(sisusb->sisurbout[i]);\r\nsisusb->sisurbout[i] = NULL;\r\n}\r\nusb_free_urb(sisusb->sisurbin);\r\nsisusb->sisurbin = NULL;\r\n}\r\nstatic int sisusb_all_free(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\nfor (i = 0; i < sisusb->numobufs; i++) {\r\nif (sisusb->urbstatus[i] & SU_URB_BUSY)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic void sisusb_kill_all_busy(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\nif (sisusb_all_free(sisusb))\r\nreturn;\r\nfor (i = 0; i < sisusb->numobufs; i++) {\r\nif (sisusb->urbstatus[i] & SU_URB_BUSY)\r\nusb_kill_urb(sisusb->sisurbout[i]);\r\n}\r\n}\r\nstatic int sisusb_wait_all_out_complete(struct sisusb_usb_data *sisusb)\r\n{\r\nint timeout = 5 * HZ, i = 1;\r\nwait_event_timeout(sisusb->wait_q, (i = sisusb_all_free(sisusb)),\r\ntimeout);\r\nreturn i;\r\n}\r\nstatic int sisusb_outurb_available(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\nfor (i = 0; i < sisusb->numobufs; i++) {\r\nif ((sisusb->urbstatus[i] & (SU_URB_BUSY|SU_URB_ALLOC)) == 0)\r\nreturn i;\r\n}\r\nreturn -1;\r\n}\r\nstatic int sisusb_get_free_outbuf(struct sisusb_usb_data *sisusb)\r\n{\r\nint i, timeout = 5 * HZ;\r\nwait_event_timeout(sisusb->wait_q,\r\n((i = sisusb_outurb_available(sisusb)) >= 0), timeout);\r\nreturn i;\r\n}\r\nstatic int sisusb_alloc_outbuf(struct sisusb_usb_data *sisusb)\r\n{\r\nint i;\r\ni = sisusb_outurb_available(sisusb);\r\nif (i >= 0)\r\nsisusb->urbstatus[i] |= SU_URB_ALLOC;\r\nreturn i;\r\n}\r\nstatic void sisusb_free_outbuf(struct sisusb_usb_data *sisusb, int index)\r\n{\r\nif ((index >= 0) && (index < sisusb->numobufs))\r\nsisusb->urbstatus[index] &= ~SU_URB_ALLOC;\r\n}\r\nstatic void sisusb_bulk_completeout(struct urb *urb)\r\n{\r\nstruct sisusb_urb_context *context = urb->context;\r\nstruct sisusb_usb_data *sisusb;\r\nif (!context)\r\nreturn;\r\nsisusb = context->sisusb;\r\nif (!sisusb || !sisusb->sisusb_dev || !sisusb->present)\r\nreturn;\r\n#ifndef SISUSB_DONTSYNC\r\nif (context->actual_length)\r\n*(context->actual_length) += urb->actual_length;\r\n#endif\r\nsisusb->urbstatus[context->urbindex] &= ~SU_URB_BUSY;\r\nwake_up(&sisusb->wait_q);\r\n}\r\nstatic int sisusb_bulkout_msg(struct sisusb_usb_data *sisusb, int index,\r\nunsigned int pipe, void *data, int len, int *actual_length,\r\nint timeout, unsigned int tflags)\r\n{\r\nstruct urb *urb = sisusb->sisurbout[index];\r\nint retval, byteswritten = 0;\r\nurb->transfer_flags = 0;\r\nusb_fill_bulk_urb(urb, sisusb->sisusb_dev, pipe, data, len,\r\nsisusb_bulk_completeout,\r\n&sisusb->urbout_context[index]);\r\nurb->transfer_flags |= tflags;\r\nurb->actual_length = 0;\r\nsisusb->urbout_context[index].actual_length = (timeout) ?\r\nNULL : actual_length;\r\nsisusb->urbstatus[index] |= SU_URB_BUSY;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif ((retval == 0) && timeout) {\r\nwait_event_timeout(sisusb->wait_q,\r\n(!(sisusb->urbstatus[index] & SU_URB_BUSY)),\r\ntimeout);\r\nif (sisusb->urbstatus[index] & SU_URB_BUSY) {\r\nusb_kill_urb(urb);\r\nretval = -ETIMEDOUT;\r\n} else {\r\nretval = urb->status;\r\nbyteswritten = urb->actual_length;\r\n}\r\n}\r\nif (actual_length)\r\n*actual_length = byteswritten;\r\nreturn retval;\r\n}\r\nstatic void sisusb_bulk_completein(struct urb *urb)\r\n{\r\nstruct sisusb_usb_data *sisusb = urb->context;\r\nif (!sisusb || !sisusb->sisusb_dev || !sisusb->present)\r\nreturn;\r\nsisusb->completein = 1;\r\nwake_up(&sisusb->wait_q);\r\n}\r\nstatic int sisusb_bulkin_msg(struct sisusb_usb_data *sisusb,\r\nunsigned int pipe, void *data, int len,\r\nint *actual_length, int timeout, unsigned int tflags)\r\n{\r\nstruct urb *urb = sisusb->sisurbin;\r\nint retval, readbytes = 0;\r\nurb->transfer_flags = 0;\r\nusb_fill_bulk_urb(urb, sisusb->sisusb_dev, pipe, data, len,\r\nsisusb_bulk_completein, sisusb);\r\nurb->transfer_flags |= tflags;\r\nurb->actual_length = 0;\r\nsisusb->completein = 0;\r\nretval = usb_submit_urb(urb, GFP_KERNEL);\r\nif (retval == 0) {\r\nwait_event_timeout(sisusb->wait_q, sisusb->completein, timeout);\r\nif (!sisusb->completein) {\r\nusb_kill_urb(urb);\r\nretval = -ETIMEDOUT;\r\n} else {\r\nretval = urb->status;\r\nreadbytes = urb->actual_length;\r\n}\r\n}\r\nif (actual_length)\r\n*actual_length = readbytes;\r\nreturn retval;\r\n}\r\nstatic int sisusb_send_bulk_msg(struct sisusb_usb_data *sisusb, int ep, int len,\r\nchar *kernbuffer, const char __user *userbuffer, int index,\r\nssize_t *bytes_written, unsigned int tflags, int async)\r\n{\r\nint result = 0, retry, count = len;\r\nint passsize, thispass, transferred_len = 0;\r\nint fromuser = (userbuffer != NULL) ? 1 : 0;\r\nint fromkern = (kernbuffer != NULL) ? 1 : 0;\r\nunsigned int pipe;\r\nchar *buffer;\r\n(*bytes_written) = 0;\r\nif (!sisusb || !sisusb->present || !sisusb->sisusb_dev)\r\nreturn -ENODEV;\r\nif (fromuser || fromkern)\r\nindex = -1;\r\nelse if (len > sisusb->obufsize)\r\nasync = 0;\r\npipe = usb_sndbulkpipe(sisusb->sisusb_dev, ep);\r\ndo {\r\npasssize = thispass = (sisusb->obufsize < count) ?\r\nsisusb->obufsize : count;\r\nif (index < 0)\r\nindex = sisusb_get_free_outbuf(sisusb);\r\nif (index < 0)\r\nreturn -EIO;\r\nbuffer = sisusb->obuf[index];\r\nif (fromuser) {\r\nif (copy_from_user(buffer, userbuffer, passsize))\r\nreturn -EFAULT;\r\nuserbuffer += passsize;\r\n} else if (fromkern) {\r\nmemcpy(buffer, kernbuffer, passsize);\r\nkernbuffer += passsize;\r\n}\r\nretry = 5;\r\nwhile (thispass) {\r\nif (!sisusb->sisusb_dev)\r\nreturn -ENODEV;\r\nresult = sisusb_bulkout_msg(sisusb, index, pipe,\r\nbuffer, thispass, &transferred_len,\r\nasync ? 0 : 5 * HZ, tflags);\r\nif (result == -ETIMEDOUT) {\r\nif (!retry--)\r\nreturn -ETIME;\r\ncontinue;\r\n}\r\nif ((result == 0) && !async && transferred_len) {\r\nthispass -= transferred_len;\r\nbuffer += transferred_len;\r\n} else\r\nbreak;\r\n}\r\nif (result)\r\nreturn result;\r\n(*bytes_written) += passsize;\r\ncount -= passsize;\r\nif (fromuser || fromkern)\r\nindex = -1;\r\n} while (count > 0);\r\nif (async) {\r\n#ifdef SISUSB_DONTSYNC\r\n(*bytes_written) = len;\r\n#else\r\nsisusb_wait_all_out_complete(sisusb);\r\n(*bytes_written) = transferred_len;\r\n#endif\r\n}\r\nreturn ((*bytes_written) == len) ? 0 : -EIO;\r\n}\r\nstatic int sisusb_recv_bulk_msg(struct sisusb_usb_data *sisusb, int ep, int len,\r\nvoid *kernbuffer, char __user *userbuffer, ssize_t *bytes_read,\r\nunsigned int tflags)\r\n{\r\nint result = 0, retry, count = len;\r\nint bufsize, thispass, transferred_len;\r\nunsigned int pipe;\r\nchar *buffer;\r\n(*bytes_read) = 0;\r\nif (!sisusb || !sisusb->present || !sisusb->sisusb_dev)\r\nreturn -ENODEV;\r\npipe = usb_rcvbulkpipe(sisusb->sisusb_dev, ep);\r\nbuffer = sisusb->ibuf;\r\nbufsize = sisusb->ibufsize;\r\nretry = 5;\r\n#ifdef SISUSB_DONTSYNC\r\nif (!(sisusb_wait_all_out_complete(sisusb)))\r\nreturn -EIO;\r\n#endif\r\nwhile (count > 0) {\r\nif (!sisusb->sisusb_dev)\r\nreturn -ENODEV;\r\nthispass = (bufsize < count) ? bufsize : count;\r\nresult = sisusb_bulkin_msg(sisusb, pipe, buffer, thispass,\r\n&transferred_len, 5 * HZ, tflags);\r\nif (transferred_len)\r\nthispass = transferred_len;\r\nelse if (result == -ETIMEDOUT) {\r\nif (!retry--)\r\nreturn -ETIME;\r\ncontinue;\r\n} else\r\nreturn -EIO;\r\nif (thispass) {\r\n(*bytes_read) += thispass;\r\ncount -= thispass;\r\nif (userbuffer) {\r\nif (copy_to_user(userbuffer, buffer, thispass))\r\nreturn -EFAULT;\r\nuserbuffer += thispass;\r\n} else {\r\nmemcpy(kernbuffer, buffer, thispass);\r\nkernbuffer += thispass;\r\n}\r\n}\r\n}\r\nreturn ((*bytes_read) == len) ? 0 : -EIO;\r\n}\r\nstatic int sisusb_send_packet(struct sisusb_usb_data *sisusb, int len,\r\nstruct sisusb_packet *packet)\r\n{\r\nint ret;\r\nssize_t bytes_transferred = 0;\r\n__le32 tmp;\r\nif (len == 6)\r\npacket->data = 0;\r\n#ifdef SISUSB_DONTSYNC\r\nif (!(sisusb_wait_all_out_complete(sisusb)))\r\nreturn 1;\r\n#endif\r\nSISUSB_CORRECT_ENDIANNESS_PACKET(packet);\r\nret = sisusb_send_bulk_msg(sisusb, SISUSB_EP_GFX_OUT, len,\r\n(char *)packet, NULL, 0, &bytes_transferred, 0, 0);\r\nif ((ret == 0) && (len == 6)) {\r\nret = sisusb_recv_bulk_msg(sisusb, SISUSB_EP_GFX_IN, 4,\r\n(char *)&tmp, NULL, &bytes_transferred, 0);\r\npacket->data = le32_to_cpu(tmp);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_send_bridge_packet(struct sisusb_usb_data *sisusb, int len,\r\nstruct sisusb_packet *packet, unsigned int tflags)\r\n{\r\nint ret;\r\nssize_t bytes_transferred = 0;\r\n__le32 tmp;\r\nif (len == 6)\r\npacket->data = 0;\r\n#ifdef SISUSB_DONTSYNC\r\nif (!(sisusb_wait_all_out_complete(sisusb)))\r\nreturn 1;\r\n#endif\r\nSISUSB_CORRECT_ENDIANNESS_PACKET(packet);\r\nret = sisusb_send_bulk_msg(sisusb, SISUSB_EP_BRIDGE_OUT, len,\r\n(char *)packet, NULL, 0, &bytes_transferred, tflags, 0);\r\nif ((ret == 0) && (len == 6)) {\r\nret = sisusb_recv_bulk_msg(sisusb, SISUSB_EP_BRIDGE_IN, 4,\r\n(char *)&tmp, NULL, &bytes_transferred, 0);\r\npacket->data = le32_to_cpu(tmp);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_write_memio_byte(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u8 data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret;\r\npacket.header = (1 << (addr & 3)) | (type << 6);\r\npacket.address = addr & ~3;\r\npacket.data = data << ((addr & 3) << 3);\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nreturn ret;\r\n}\r\nstatic int sisusb_write_memio_word(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u16 data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\npacket.address = addr & ~3;\r\nswitch (addr & 3) {\r\ncase 0:\r\npacket.header = (type << 6) | 0x0003;\r\npacket.data = (u32)data;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 1:\r\npacket.header = (type << 6) | 0x0006;\r\npacket.data = (u32)data << 8;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 2:\r\npacket.header = (type << 6) | 0x000c;\r\npacket.data = (u32)data << 16;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 3:\r\npacket.header = (type << 6) | 0x0008;\r\npacket.data = (u32)data << 24;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\npacket.header = (type << 6) | 0x0001;\r\npacket.address = (addr & ~3) + 4;\r\npacket.data = (u32)data >> 8;\r\nret |= sisusb_send_packet(sisusb, 10, &packet);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_write_memio_24bit(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u32 data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\npacket.address = addr & ~3;\r\nswitch (addr & 3) {\r\ncase 0:\r\npacket.header = (type << 6) | 0x0007;\r\npacket.data = data & 0x00ffffff;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 1:\r\npacket.header = (type << 6) | 0x000e;\r\npacket.data = data << 8;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 2:\r\npacket.header = (type << 6) | 0x000c;\r\npacket.data = data << 16;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\npacket.header = (type << 6) | 0x0001;\r\npacket.address = (addr & ~3) + 4;\r\npacket.data = (data >> 16) & 0x00ff;\r\nret |= sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 3:\r\npacket.header = (type << 6) | 0x0008;\r\npacket.data = data << 24;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\npacket.header = (type << 6) | 0x0003;\r\npacket.address = (addr & ~3) + 4;\r\npacket.data = (data >> 8) & 0xffff;\r\nret |= sisusb_send_packet(sisusb, 10, &packet);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_write_memio_long(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u32 data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\npacket.address = addr & ~3;\r\nswitch (addr & 3) {\r\ncase 0:\r\npacket.header = (type << 6) | 0x000f;\r\npacket.data = data;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 1:\r\npacket.header = (type << 6) | 0x000e;\r\npacket.data = data << 8;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\npacket.header = (type << 6) | 0x0001;\r\npacket.address = (addr & ~3) + 4;\r\npacket.data = data >> 24;\r\nret |= sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 2:\r\npacket.header = (type << 6) | 0x000c;\r\npacket.data = data << 16;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\npacket.header = (type << 6) | 0x0003;\r\npacket.address = (addr & ~3) + 4;\r\npacket.data = data >> 16;\r\nret |= sisusb_send_packet(sisusb, 10, &packet);\r\nbreak;\r\ncase 3:\r\npacket.header = (type << 6) | 0x0008;\r\npacket.data = data << 24;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\npacket.header = (type << 6) | 0x0007;\r\npacket.address = (addr & ~3) + 4;\r\npacket.data = data >> 8;\r\nret |= sisusb_send_packet(sisusb, 10, &packet);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_write_mem_bulk(struct sisusb_usb_data *sisusb, u32 addr,\r\nchar *kernbuffer, int length, const char __user *userbuffer,\r\nint index, ssize_t *bytes_written)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\nstatic int msgcount;\r\nu8 swap8, fromkern = kernbuffer ? 1 : 0;\r\nu16 swap16;\r\nu32 swap32, flag = (length >> 28) & 1;\r\nchar buf[4];\r\nif (!fromkern && !userbuffer)\r\nkernbuffer = sisusb->obuf[index];\r\n(*bytes_written = 0);\r\nlength &= 0x00ffffff;\r\nwhile (length) {\r\nswitch (length) {\r\ncase 1:\r\nif (userbuffer) {\r\nif (get_user(swap8, (u8 __user *)userbuffer))\r\nreturn -EFAULT;\r\n} else\r\nswap8 = kernbuffer[0];\r\nret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_MEM,\r\naddr, swap8);\r\nif (!ret)\r\n(*bytes_written)++;\r\nreturn ret;\r\ncase 2:\r\nif (userbuffer) {\r\nif (get_user(swap16, (u16 __user *)userbuffer))\r\nreturn -EFAULT;\r\n} else\r\nswap16 = *((u16 *)kernbuffer);\r\nret = sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\r\naddr, swap16);\r\nif (!ret)\r\n(*bytes_written) += 2;\r\nreturn ret;\r\ncase 3:\r\nif (userbuffer) {\r\nif (copy_from_user(&buf, userbuffer, 3))\r\nreturn -EFAULT;\r\n#ifdef __BIG_ENDIAN\r\nswap32 = (buf[0] << 16) |\r\n(buf[1] << 8) |\r\nbuf[2];\r\n#else\r\nswap32 = (buf[2] << 16) |\r\n(buf[1] << 8) |\r\nbuf[0];\r\n#endif\r\n} else\r\n#ifdef __BIG_ENDIAN\r\nswap32 = (kernbuffer[0] << 16) |\r\n(kernbuffer[1] << 8) |\r\nkernbuffer[2];\r\n#else\r\nswap32 = (kernbuffer[2] << 16) |\r\n(kernbuffer[1] << 8) |\r\nkernbuffer[0];\r\n#endif\r\nret = sisusb_write_memio_24bit(sisusb, SISUSB_TYPE_MEM,\r\naddr, swap32);\r\nif (!ret)\r\n(*bytes_written) += 3;\r\nreturn ret;\r\ncase 4:\r\nif (userbuffer) {\r\nif (get_user(swap32, (u32 __user *)userbuffer))\r\nreturn -EFAULT;\r\n} else\r\nswap32 = *((u32 *)kernbuffer);\r\nret = sisusb_write_memio_long(sisusb, SISUSB_TYPE_MEM,\r\naddr, swap32);\r\nif (!ret)\r\n(*bytes_written) += 4;\r\nreturn ret;\r\ndefault:\r\nif ((length & ~3) > 0x10000) {\r\npacket.header = 0x001f;\r\npacket.address = 0x000001d4;\r\npacket.data = addr;\r\nret = sisusb_send_bridge_packet(sisusb, 10,\r\n&packet, 0);\r\npacket.header = 0x001f;\r\npacket.address = 0x000001d0;\r\npacket.data = (length & ~3);\r\nret |= sisusb_send_bridge_packet(sisusb, 10,\r\n&packet, 0);\r\npacket.header = 0x001f;\r\npacket.address = 0x000001c0;\r\npacket.data = flag | 0x16;\r\nret |= sisusb_send_bridge_packet(sisusb, 10,\r\n&packet, 0);\r\nif (userbuffer) {\r\nret |= sisusb_send_bulk_msg(sisusb,\r\nSISUSB_EP_GFX_LBULK_OUT,\r\n(length & ~3),\r\nNULL, userbuffer, 0,\r\nbytes_written, 0, 1);\r\nuserbuffer += (*bytes_written);\r\n} else if (fromkern) {\r\nret |= sisusb_send_bulk_msg(sisusb,\r\nSISUSB_EP_GFX_LBULK_OUT,\r\n(length & ~3),\r\nkernbuffer, NULL, 0,\r\nbytes_written, 0, 1);\r\nkernbuffer += (*bytes_written);\r\n} else {\r\nret |= sisusb_send_bulk_msg(sisusb,\r\nSISUSB_EP_GFX_LBULK_OUT,\r\n(length & ~3),\r\nNULL, NULL, index,\r\nbytes_written, 0, 1);\r\nkernbuffer += ((*bytes_written) &\r\n(sisusb->obufsize-1));\r\n}\r\n} else {\r\npacket.header = 0x001f;\r\npacket.address = 0x00000194;\r\npacket.data = addr;\r\nret = sisusb_send_bridge_packet(sisusb, 10,\r\n&packet, 0);\r\npacket.header = 0x001f;\r\npacket.address = 0x00000190;\r\npacket.data = (length & ~3);\r\nret |= sisusb_send_bridge_packet(sisusb, 10,\r\n&packet, 0);\r\nif (sisusb->flagb0 != 0x16) {\r\npacket.header = 0x001f;\r\npacket.address = 0x00000180;\r\npacket.data = flag | 0x16;\r\nret |= sisusb_send_bridge_packet(sisusb,\r\n10, &packet, 0);\r\nsisusb->flagb0 = 0x16;\r\n}\r\nif (userbuffer) {\r\nret |= sisusb_send_bulk_msg(sisusb,\r\nSISUSB_EP_GFX_BULK_OUT,\r\n(length & ~3),\r\nNULL, userbuffer, 0,\r\nbytes_written, 0, 1);\r\nuserbuffer += (*bytes_written);\r\n} else if (fromkern) {\r\nret |= sisusb_send_bulk_msg(sisusb,\r\nSISUSB_EP_GFX_BULK_OUT,\r\n(length & ~3),\r\nkernbuffer, NULL, 0,\r\nbytes_written, 0, 1);\r\nkernbuffer += (*bytes_written);\r\n} else {\r\nret |= sisusb_send_bulk_msg(sisusb,\r\nSISUSB_EP_GFX_BULK_OUT,\r\n(length & ~3),\r\nNULL, NULL, index,\r\nbytes_written, 0, 1);\r\nkernbuffer += ((*bytes_written) &\r\n(sisusb->obufsize-1));\r\n}\r\n}\r\nif (ret) {\r\nmsgcount++;\r\nif (msgcount < 500)\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"Wrote %zd of %d bytes, error %d\n",\r\n*bytes_written, length,\r\nret);\r\nelse if (msgcount == 500)\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"Too many errors, logging stopped\n");\r\n}\r\naddr += (*bytes_written);\r\nlength -= (*bytes_written);\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret ? -EIO : 0;\r\n}\r\nstatic int sisusb_read_memio_byte(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u8 *data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret;\r\nCLEARPACKET(&packet);\r\npacket.header = (1 << (addr & 3)) | (type << 6);\r\npacket.address = addr & ~3;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = (u8)(packet.data >> ((addr & 3) << 3));\r\nreturn ret;\r\n}\r\nstatic int sisusb_read_memio_word(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u16 *data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\nCLEARPACKET(&packet);\r\npacket.address = addr & ~3;\r\nswitch (addr & 3) {\r\ncase 0:\r\npacket.header = (type << 6) | 0x0003;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = (u16)(packet.data);\r\nbreak;\r\ncase 1:\r\npacket.header = (type << 6) | 0x0006;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = (u16)(packet.data >> 8);\r\nbreak;\r\ncase 2:\r\npacket.header = (type << 6) | 0x000c;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = (u16)(packet.data >> 16);\r\nbreak;\r\ncase 3:\r\npacket.header = (type << 6) | 0x0008;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = (u16)(packet.data >> 24);\r\npacket.header = (type << 6) | 0x0001;\r\npacket.address = (addr & ~3) + 4;\r\nret |= sisusb_send_packet(sisusb, 6, &packet);\r\n*data |= (u16)(packet.data << 8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_read_memio_24bit(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u32 *data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\npacket.address = addr & ~3;\r\nswitch (addr & 3) {\r\ncase 0:\r\npacket.header = (type << 6) | 0x0007;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data & 0x00ffffff;\r\nbreak;\r\ncase 1:\r\npacket.header = (type << 6) | 0x000e;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data >> 8;\r\nbreak;\r\ncase 2:\r\npacket.header = (type << 6) | 0x000c;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data >> 16;\r\npacket.header = (type << 6) | 0x0001;\r\npacket.address = (addr & ~3) + 4;\r\nret |= sisusb_send_packet(sisusb, 6, &packet);\r\n*data |= ((packet.data & 0xff) << 16);\r\nbreak;\r\ncase 3:\r\npacket.header = (type << 6) | 0x0008;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data >> 24;\r\npacket.header = (type << 6) | 0x0003;\r\npacket.address = (addr & ~3) + 4;\r\nret |= sisusb_send_packet(sisusb, 6, &packet);\r\n*data |= ((packet.data & 0xffff) << 8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_read_memio_long(struct sisusb_usb_data *sisusb, int type,\r\nu32 addr, u32 *data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret = 0;\r\npacket.address = addr & ~3;\r\nswitch (addr & 3) {\r\ncase 0:\r\npacket.header = (type << 6) | 0x000f;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data;\r\nbreak;\r\ncase 1:\r\npacket.header = (type << 6) | 0x000e;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data >> 8;\r\npacket.header = (type << 6) | 0x0001;\r\npacket.address = (addr & ~3) + 4;\r\nret |= sisusb_send_packet(sisusb, 6, &packet);\r\n*data |= (packet.data << 24);\r\nbreak;\r\ncase 2:\r\npacket.header = (type << 6) | 0x000c;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data >> 16;\r\npacket.header = (type << 6) | 0x0003;\r\npacket.address = (addr & ~3) + 4;\r\nret |= sisusb_send_packet(sisusb, 6, &packet);\r\n*data |= (packet.data << 16);\r\nbreak;\r\ncase 3:\r\npacket.header = (type << 6) | 0x0008;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data >> 24;\r\npacket.header = (type << 6) | 0x0007;\r\npacket.address = (addr & ~3) + 4;\r\nret |= sisusb_send_packet(sisusb, 6, &packet);\r\n*data |= (packet.data << 8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_read_mem_bulk(struct sisusb_usb_data *sisusb, u32 addr,\r\nchar *kernbuffer, int length, char __user *userbuffer,\r\nssize_t *bytes_read)\r\n{\r\nint ret = 0;\r\nchar buf[4];\r\nu16 swap16;\r\nu32 swap32;\r\n(*bytes_read = 0);\r\nlength &= 0x00ffffff;\r\nwhile (length) {\r\nswitch (length) {\r\ncase 1:\r\nret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_MEM,\r\naddr, &buf[0]);\r\nif (!ret) {\r\n(*bytes_read)++;\r\nif (userbuffer) {\r\nif (put_user(buf[0], (u8 __user *)userbuffer))\r\nreturn -EFAULT;\r\n} else\r\nkernbuffer[0] = buf[0];\r\n}\r\nreturn ret;\r\ncase 2:\r\nret |= sisusb_read_memio_word(sisusb, SISUSB_TYPE_MEM,\r\naddr, &swap16);\r\nif (!ret) {\r\n(*bytes_read) += 2;\r\nif (userbuffer) {\r\nif (put_user(swap16, (u16 __user *)userbuffer))\r\nreturn -EFAULT;\r\n} else {\r\n*((u16 *)kernbuffer) = swap16;\r\n}\r\n}\r\nreturn ret;\r\ncase 3:\r\nret |= sisusb_read_memio_24bit(sisusb, SISUSB_TYPE_MEM,\r\naddr, &swap32);\r\nif (!ret) {\r\n(*bytes_read) += 3;\r\n#ifdef __BIG_ENDIAN\r\nbuf[0] = (swap32 >> 16) & 0xff;\r\nbuf[1] = (swap32 >> 8) & 0xff;\r\nbuf[2] = swap32 & 0xff;\r\n#else\r\nbuf[2] = (swap32 >> 16) & 0xff;\r\nbuf[1] = (swap32 >> 8) & 0xff;\r\nbuf[0] = swap32 & 0xff;\r\n#endif\r\nif (userbuffer) {\r\nif (copy_to_user(userbuffer,\r\n&buf[0], 3))\r\nreturn -EFAULT;\r\n} else {\r\nkernbuffer[0] = buf[0];\r\nkernbuffer[1] = buf[1];\r\nkernbuffer[2] = buf[2];\r\n}\r\n}\r\nreturn ret;\r\ndefault:\r\nret |= sisusb_read_memio_long(sisusb, SISUSB_TYPE_MEM,\r\naddr, &swap32);\r\nif (!ret) {\r\n(*bytes_read) += 4;\r\nif (userbuffer) {\r\nif (put_user(swap32, (u32 __user *)userbuffer))\r\nreturn -EFAULT;\r\nuserbuffer += 4;\r\n} else {\r\n*((u32 *)kernbuffer) = swap32;\r\nkernbuffer += 4;\r\n}\r\naddr += 4;\r\nlength -= 4;\r\n}\r\n}\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint sisusb_setreg(struct sisusb_usb_data *sisusb, int port, u8 data)\r\n{\r\nreturn sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, data);\r\n}\r\nint sisusb_getreg(struct sisusb_usb_data *sisusb, int port, u8 *data)\r\n{\r\nreturn sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port, data);\r\n}\r\nint sisusb_setidxreg(struct sisusb_usb_data *sisusb, int port,\r\nu8 index, u8 data)\r\n{\r\nint ret;\r\nret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, index);\r\nret |= sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, data);\r\nreturn ret;\r\n}\r\nint sisusb_getidxreg(struct sisusb_usb_data *sisusb, int port,\r\nu8 index, u8 *data)\r\n{\r\nint ret;\r\nret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, index);\r\nret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, data);\r\nreturn ret;\r\n}\r\nint sisusb_setidxregandor(struct sisusb_usb_data *sisusb, int port, u8 idx,\r\nu8 myand, u8 myor)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, idx);\r\nret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, &tmp);\r\ntmp &= myand;\r\ntmp |= myor;\r\nret |= sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, tmp);\r\nreturn ret;\r\n}\r\nstatic int sisusb_setidxregmask(struct sisusb_usb_data *sisusb,\r\nint port, u8 idx, u8 data, u8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, idx);\r\nret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, &tmp);\r\ntmp &= ~(mask);\r\ntmp |= (data & mask);\r\nret |= sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, tmp);\r\nreturn ret;\r\n}\r\nint sisusb_setidxregor(struct sisusb_usb_data *sisusb, int port,\r\nu8 index, u8 myor)\r\n{\r\nreturn sisusb_setidxregandor(sisusb, port, index, 0xff, myor);\r\n}\r\nint sisusb_setidxregand(struct sisusb_usb_data *sisusb, int port,\r\nu8 idx, u8 myand)\r\n{\r\nreturn sisusb_setidxregandor(sisusb, port, idx, myand, 0x00);\r\n}\r\nint sisusb_writeb(struct sisusb_usb_data *sisusb, u32 adr, u8 data)\r\n{\r\nreturn sisusb_write_memio_byte(sisusb, SISUSB_TYPE_MEM, adr, data);\r\n}\r\nint sisusb_readb(struct sisusb_usb_data *sisusb, u32 adr, u8 *data)\r\n{\r\nreturn sisusb_read_memio_byte(sisusb, SISUSB_TYPE_MEM, adr, data);\r\n}\r\nint sisusb_copy_memory(struct sisusb_usb_data *sisusb, char *src,\r\nu32 dest, int length)\r\n{\r\nsize_t dummy;\r\nreturn sisusb_write_mem_bulk(sisusb, dest, src, length,\r\nNULL, 0, &dummy);\r\n}\r\nstatic int sisusb_read_memory(struct sisusb_usb_data *sisusb, char *dest,\r\nu32 src, int length)\r\n{\r\nsize_t dummy;\r\nreturn sisusb_read_mem_bulk(sisusb, src, dest, length,\r\nNULL, &dummy);\r\n}\r\nstatic void sisusb_testreadwrite(struct sisusb_usb_data *sisusb)\r\n{\r\nstatic char srcbuffer[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };\r\nchar destbuffer[10];\r\nint i, j;\r\nsisusb_copy_memory(sisusb, srcbuffer, sisusb->vrambase, 7);\r\nfor (i = 1; i <= 7; i++) {\r\ndev_dbg(&sisusb->sisusb_dev->dev,\r\n"sisusb: rwtest %d bytes\n", i);\r\nsisusb_read_memory(sisusb, destbuffer, sisusb->vrambase, i);\r\nfor (j = 0; j < i; j++) {\r\ndev_dbg(&sisusb->sisusb_dev->dev,\r\n"rwtest read[%d] = %x\n",\r\nj, destbuffer[j]);\r\n}\r\n}\r\n}\r\nstatic int sisusb_write_pci_config(struct sisusb_usb_data *sisusb,\r\nint regnum, u32 data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret;\r\npacket.header = 0x008f;\r\npacket.address = regnum | 0x10000;\r\npacket.data = data;\r\nret = sisusb_send_packet(sisusb, 10, &packet);\r\nreturn ret;\r\n}\r\nstatic int sisusb_read_pci_config(struct sisusb_usb_data *sisusb,\r\nint regnum, u32 *data)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret;\r\npacket.header = 0x008f;\r\npacket.address = (u32)regnum | 0x10000;\r\nret = sisusb_send_packet(sisusb, 6, &packet);\r\n*data = packet.data;\r\nreturn ret;\r\n}\r\nstatic int sisusb_clear_vram(struct sisusb_usb_data *sisusb,\r\nu32 address, int length)\r\n{\r\nint ret, i;\r\nssize_t j;\r\nif (address < sisusb->vrambase)\r\nreturn 1;\r\nif (address >= sisusb->vrambase + sisusb->vramsize)\r\nreturn 1;\r\nif (address + length > sisusb->vrambase + sisusb->vramsize)\r\nlength = sisusb->vrambase + sisusb->vramsize - address;\r\nif (length <= 0)\r\nreturn 0;\r\ni = sisusb_alloc_outbuf(sisusb);\r\nif (i < 0)\r\nreturn -EBUSY;\r\nmemset(sisusb->obuf[i], 0, sisusb->obufsize);\r\nret = sisusb_write_mem_bulk(sisusb, address, NULL, length, NULL, i, &j);\r\nsisusb_free_outbuf(sisusb, i);\r\nreturn ret;\r\n}\r\nstatic int sisusb_triggersr16(struct sisusb_usb_data *sisusb, u8 ramtype)\r\n{\r\nint ret;\r\nu8 tmp8;\r\nret = GETIREG(SISSR, 0x16, &tmp8);\r\nif (ramtype <= 1) {\r\ntmp8 &= 0x3f;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 |= 0x80;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\n} else {\r\ntmp8 |= 0xc0;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 &= 0x0f;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 |= 0x80;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 &= 0x0f;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 |= 0xd0;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 &= 0x0f;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\ntmp8 |= 0xa0;\r\nret |= SETIREG(SISSR, 0x16, tmp8);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_getbuswidth(struct sisusb_usb_data *sisusb,\r\nint *bw, int *chab)\r\n{\r\nint ret;\r\nu8 ramtype, done = 0;\r\nu32 t0, t1, t2, t3;\r\nu32 ramptr = SISUSB_PCI_MEMBASE;\r\nret = GETIREG(SISSR, 0x3a, &ramtype);\r\nramtype &= 3;\r\nret |= SETIREG(SISSR, 0x13, 0x00);\r\nif (ramtype <= 1) {\r\nret |= SETIREG(SISSR, 0x14, 0x12);\r\nret |= SETIREGAND(SISSR, 0x15, 0xef);\r\n} else {\r\nret |= SETIREG(SISSR, 0x14, 0x02);\r\n}\r\nret |= sisusb_triggersr16(sisusb, ramtype);\r\nret |= WRITEL(ramptr + 0, 0x01234567);\r\nret |= WRITEL(ramptr + 4, 0x456789ab);\r\nret |= WRITEL(ramptr + 8, 0x89abcdef);\r\nret |= WRITEL(ramptr + 12, 0xcdef0123);\r\nret |= WRITEL(ramptr + 16, 0x55555555);\r\nret |= WRITEL(ramptr + 20, 0x55555555);\r\nret |= WRITEL(ramptr + 24, 0xffffffff);\r\nret |= WRITEL(ramptr + 28, 0xffffffff);\r\nret |= READL(ramptr + 0, &t0);\r\nret |= READL(ramptr + 4, &t1);\r\nret |= READL(ramptr + 8, &t2);\r\nret |= READL(ramptr + 12, &t3);\r\nif (ramtype <= 1) {\r\n*chab = 0; *bw = 64;\r\nif ((t3 != 0xcdef0123) || (t2 != 0x89abcdef)) {\r\nif ((t1 == 0x456789ab) && (t0 == 0x01234567)) {\r\n*chab = 0; *bw = 64;\r\nret |= SETIREGAND(SISSR, 0x14, 0xfd);\r\n}\r\n}\r\nif ((t1 != 0x456789ab) || (t0 != 0x01234567)) {\r\n*chab = 1; *bw = 64;\r\nret |= SETIREGANDOR(SISSR, 0x14, 0xfc, 0x01);\r\nret |= sisusb_triggersr16(sisusb, ramtype);\r\nret |= WRITEL(ramptr + 0, 0x89abcdef);\r\nret |= WRITEL(ramptr + 4, 0xcdef0123);\r\nret |= WRITEL(ramptr + 8, 0x55555555);\r\nret |= WRITEL(ramptr + 12, 0x55555555);\r\nret |= WRITEL(ramptr + 16, 0xaaaaaaaa);\r\nret |= WRITEL(ramptr + 20, 0xaaaaaaaa);\r\nret |= READL(ramptr + 4, &t1);\r\nif (t1 != 0xcdef0123) {\r\n*bw = 32;\r\nret |= SETIREGOR(SISSR, 0x15, 0x10);\r\n}\r\n}\r\n} else {\r\n*chab = 0; *bw = 64;\r\ndone = 0;\r\nif (t1 == 0x456789ab) {\r\nif (t0 == 0x01234567) {\r\n*chab = 0; *bw = 64;\r\ndone = 1;\r\n}\r\n} else {\r\nif (t0 == 0x01234567) {\r\n*chab = 0; *bw = 32;\r\nret |= SETIREG(SISSR, 0x14, 0x00);\r\ndone = 1;\r\n}\r\n}\r\nif (!done) {\r\nret |= SETIREG(SISSR, 0x14, 0x03);\r\nret |= sisusb_triggersr16(sisusb, ramtype);\r\nret |= WRITEL(ramptr + 0, 0x01234567);\r\nret |= WRITEL(ramptr + 4, 0x456789ab);\r\nret |= WRITEL(ramptr + 8, 0x89abcdef);\r\nret |= WRITEL(ramptr + 12, 0xcdef0123);\r\nret |= WRITEL(ramptr + 16, 0x55555555);\r\nret |= WRITEL(ramptr + 20, 0x55555555);\r\nret |= WRITEL(ramptr + 24, 0xffffffff);\r\nret |= WRITEL(ramptr + 28, 0xffffffff);\r\nret |= READL(ramptr + 0, &t0);\r\nret |= READL(ramptr + 4, &t1);\r\nif (t1 == 0x456789ab) {\r\nif (t0 == 0x01234567) {\r\n*chab = 1; *bw = 64;\r\nreturn ret;\r\n}\r\n} else {\r\nif (t0 == 0x01234567) {\r\n*chab = 1; *bw = 32;\r\nret |= SETIREG(SISSR, 0x14, 0x01);\r\n}\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_verify_mclk(struct sisusb_usb_data *sisusb)\r\n{\r\nint ret = 0;\r\nu32 ramptr = SISUSB_PCI_MEMBASE;\r\nu8 tmp1, tmp2, i, j;\r\nret |= WRITEB(ramptr, 0xaa);\r\nret |= WRITEB(ramptr + 16, 0x55);\r\nret |= READB(ramptr, &tmp1);\r\nret |= READB(ramptr + 16, &tmp2);\r\nif ((tmp1 != 0xaa) || (tmp2 != 0x55)) {\r\nfor (i = 0, j = 16; i < 2; i++, j += 16) {\r\nret |= GETIREG(SISSR, 0x21, &tmp1);\r\nret |= SETIREGAND(SISSR, 0x21, (tmp1 & 0xfb));\r\nret |= SETIREGOR(SISSR, 0x3c, 0x01);\r\nret |= SETIREGAND(SISSR, 0x3c, 0xfe);\r\nret |= SETIREG(SISSR, 0x21, tmp1);\r\nret |= WRITEB(ramptr + 16 + j, j);\r\nret |= READB(ramptr + 16 + j, &tmp1);\r\nif (tmp1 == j) {\r\nret |= WRITEB(ramptr + j, j);\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_set_rank(struct sisusb_usb_data *sisusb, int *iret,\r\nint index, u8 rankno, u8 chab, const u8 dramtype[][5], int bw)\r\n{\r\nint ret = 0, ranksize;\r\nu8 tmp;\r\n*iret = 0;\r\nif ((rankno == 2) && (dramtype[index][0] == 2))\r\nreturn ret;\r\nranksize = dramtype[index][3] / 2 * bw / 32;\r\nif ((ranksize * rankno) > 128)\r\nreturn ret;\r\ntmp = 0;\r\nwhile ((ranksize >>= 1) > 0)\r\ntmp += 0x10;\r\ntmp |= ((rankno - 1) << 2);\r\ntmp |= ((bw / 64) & 0x02);\r\ntmp |= (chab & 0x01);\r\nret = SETIREG(SISSR, 0x14, tmp);\r\nret |= sisusb_triggersr16(sisusb, 0);\r\n*iret = 1;\r\nreturn ret;\r\n}\r\nstatic int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,\r\nu32 inc, int testn)\r\n{\r\nint ret = 0, i;\r\nu32 j, tmp;\r\n*iret = 0;\r\nfor (i = 0, j = 0; i < testn; i++) {\r\nret |= WRITEL(sisusb->vrambase + j, j);\r\nj += inc;\r\n}\r\nfor (i = 0, j = 0; i < testn; i++) {\r\nret |= READL(sisusb->vrambase + j, &tmp);\r\nif (tmp != j)\r\nreturn ret;\r\nj += inc;\r\n}\r\n*iret = 1;\r\nreturn ret;\r\n}\r\nstatic int sisusb_check_ranks(struct sisusb_usb_data *sisusb,\r\nint *iret, int rankno, int idx, int bw, const u8 rtype[][5])\r\n{\r\nint ret = 0, i, i2ret;\r\nu32 inc;\r\n*iret = 0;\r\nfor (i = rankno; i >= 1; i--) {\r\ninc = 1 << (rtype[idx][2] + rtype[idx][1] + rtype[idx][0] +\r\nbw / 64 + i);\r\nret |= sisusb_check_rbc(sisusb, &i2ret, inc, 2);\r\nif (!i2ret)\r\nreturn ret;\r\n}\r\ninc = 1 << (rtype[idx][2] + bw / 64 + 2);\r\nret |= sisusb_check_rbc(sisusb, &i2ret, inc, 4);\r\nif (!i2ret)\r\nreturn ret;\r\ninc = 1 << (10 + bw / 64);\r\nret |= sisusb_check_rbc(sisusb, &i2ret, inc, 2);\r\nif (!i2ret)\r\nreturn ret;\r\n*iret = 1;\r\nreturn ret;\r\n}\r\nstatic int sisusb_get_sdram_size(struct sisusb_usb_data *sisusb, int *iret,\r\nint bw, int chab)\r\n{\r\nint ret = 0, i2ret = 0, i, j;\r\nstatic const u8 sdramtype[13][5] = {\r\n{ 2, 12, 9, 64, 0x35 },\r\n{ 1, 13, 9, 64, 0x44 },\r\n{ 2, 12, 8, 32, 0x31 },\r\n{ 2, 11, 9, 32, 0x25 },\r\n{ 1, 12, 9, 32, 0x34 },\r\n{ 1, 13, 8, 32, 0x40 },\r\n{ 2, 11, 8, 16, 0x21 },\r\n{ 1, 12, 8, 16, 0x30 },\r\n{ 1, 11, 9, 16, 0x24 },\r\n{ 1, 11, 8, 8, 0x20 },\r\n{ 2, 9, 8, 4, 0x01 },\r\n{ 1, 10, 8, 4, 0x10 },\r\n{ 1, 9, 8, 2, 0x00 }\r\n};\r\n*iret = 1;\r\nfor (i = 0; i < 13; i++) {\r\nret |= SETIREGANDOR(SISSR, 0x13, 0x80, sdramtype[i][4]);\r\nfor (j = 2; j > 0; j--) {\r\nret |= sisusb_set_rank(sisusb, &i2ret, i, j, chab,\r\nsdramtype, bw);\r\nif (!i2ret)\r\ncontinue;\r\nret |= sisusb_check_ranks(sisusb, &i2ret, j, i, bw,\r\nsdramtype);\r\nif (i2ret) {\r\n*iret = 0;\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_setup_screen(struct sisusb_usb_data *sisusb,\r\nint clrall, int drwfr)\r\n{\r\nint ret = 0;\r\nu32 address;\r\nint i, length, modex, modey, bpp;\r\nmodex = 640; modey = 480; bpp = 2;\r\naddress = sisusb->vrambase;\r\nif (clrall)\r\nlength = sisusb->vramsize;\r\nelse\r\nlength = modex * bpp * modey;\r\nret = sisusb_clear_vram(sisusb, address, length);\r\nif (!ret && drwfr) {\r\nfor (i = 0; i < modex; i++) {\r\naddress = sisusb->vrambase + (i * bpp);\r\nret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\r\naddress, 0xf100);\r\naddress += (modex * (modey-1) * bpp);\r\nret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\r\naddress, 0xf100);\r\n}\r\nfor (i = 0; i < modey; i++) {\r\naddress = sisusb->vrambase + ((i * modex) * bpp);\r\nret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\r\naddress, 0xf100);\r\naddress += ((modex - 1) * bpp);\r\nret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\r\naddress, 0xf100);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_set_default_mode(struct sisusb_usb_data *sisusb,\r\nint touchengines)\r\n{\r\nint ret = 0, i, j, modex, modey, bpp, du;\r\nu8 sr31, cr63, tmp8;\r\nstatic const char attrdata[] = {\r\n0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\r\n0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\r\n0x01, 0x00, 0x00, 0x00\r\n};\r\nstatic const char crtcrdata[] = {\r\n0x5f, 0x4f, 0x50, 0x82, 0x54, 0x80, 0x0b, 0x3e,\r\n0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n0xea, 0x8c, 0xdf, 0x28, 0x40, 0xe7, 0x04, 0xa3,\r\n0xff\r\n};\r\nstatic const char grcdata[] = {\r\n0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0f,\r\n0xff\r\n};\r\nstatic const char crtcdata[] = {\r\n0x5f, 0x4f, 0x4f, 0x83, 0x55, 0x81, 0x0b, 0x3e,\r\n0xe9, 0x8b, 0xdf, 0xe8, 0x0c, 0x00, 0x00, 0x05,\r\n0x00\r\n};\r\nmodex = 640; modey = 480; bpp = 2;\r\nGETIREG(SISSR, 0x31, &sr31);\r\nGETIREG(SISCR, 0x63, &cr63);\r\nSETIREGOR(SISSR, 0x01, 0x20);\r\nSETIREG(SISCR, 0x63, cr63 & 0xbf);\r\nSETIREGOR(SISCR, 0x17, 0x80);\r\nSETIREGOR(SISSR, 0x1f, 0x04);\r\nSETIREGAND(SISSR, 0x07, 0xfb);\r\nSETIREG(SISSR, 0x00, 0x03);\r\nSETIREG(SISSR, 0x01, 0x21);\r\nSETIREG(SISSR, 0x02, 0x0f);\r\nSETIREG(SISSR, 0x03, 0x00);\r\nSETIREG(SISSR, 0x04, 0x0e);\r\nSETREG(SISMISCW, 0x23);\r\nfor (i = 0; i <= 0x18; i++) {\r\nSETIREG(SISCR, i, crtcrdata[i]);\r\n}\r\nfor (i = 0; i <= 0x13; i++) {\r\nGETREG(SISINPSTAT, &tmp8);\r\nSETREG(SISAR, i);\r\nSETREG(SISAR, attrdata[i]);\r\n}\r\nGETREG(SISINPSTAT, &tmp8);\r\nSETREG(SISAR, 0x14);\r\nSETREG(SISAR, 0x00);\r\nGETREG(SISINPSTAT, &tmp8);\r\nSETREG(SISAR, 0x20);\r\nGETREG(SISINPSTAT, &tmp8);\r\nfor (i = 0; i <= 0x08; i++) {\r\nSETIREG(SISGR, i, grcdata[i]);\r\n}\r\nSETIREGAND(SISGR, 0x05, 0xbf);\r\nfor (i = 0x0A; i <= 0x0E; i++) {\r\nSETIREG(SISSR, i, 0x00);\r\n}\r\nSETIREGAND(SISSR, 0x37, 0xfe);\r\nSETREG(SISMISCW, 0xef);\r\nSETIREG(SISCR, 0x11, 0x00);\r\nfor (j = 0x00, i = 0; i <= 7; i++, j++)\r\nSETIREG(SISCR, j, crtcdata[i]);\r\nfor (j = 0x10; i <= 10; i++, j++)\r\nSETIREG(SISCR, j, crtcdata[i]);\r\nfor (j = 0x15; i <= 12; i++, j++)\r\nSETIREG(SISCR, j, crtcdata[i]);\r\nfor (j = 0x0A; i <= 15; i++, j++)\r\nSETIREG(SISSR, j, crtcdata[i]);\r\nSETIREG(SISSR, 0x0E, (crtcdata[16] & 0xE0));\r\nSETIREGANDOR(SISCR, 0x09, 0x5f, ((crtcdata[16] & 0x01) << 5));\r\nSETIREG(SISCR, 0x14, 0x4f);\r\ndu = (modex / 16) * (bpp * 2);\r\nSETIREGANDOR(SISSR, 0x0e, 0xf0, ((du >> 8) & 0x0f));\r\nSETIREG(SISCR, 0x13, (du & 0xff));\r\ndu <<= 5;\r\ntmp8 = du >> 8;\r\nSETIREG(SISSR, 0x10, tmp8);\r\nSETIREG(SISSR, 0x31, 0x00);\r\nSETIREG(SISSR, 0x2b, 0x1b);\r\nSETIREG(SISSR, 0x2c, 0xe1);\r\nSETIREG(SISSR, 0x2d, 0x01);\r\nSETIREGAND(SISSR, 0x3d, 0xfe);\r\nSETIREG(SISSR, 0x08, 0xae);\r\nSETIREGAND(SISSR, 0x09, 0xf0);\r\nSETIREG(SISSR, 0x08, 0x34);\r\nSETIREGOR(SISSR, 0x3d, 0x01);\r\nSETIREGAND(SISSR, 0x1f, 0x3f);\r\nSETIREGANDOR(SISSR, 0x06, 0xc0, 0x0a);\r\nSETIREG(SISCR, 0x19, 0x00);\r\nSETIREGAND(SISCR, 0x1a, 0xfc);\r\nSETIREGAND(SISSR, 0x0f, 0xb7);\r\nSETIREGAND(SISSR, 0x31, 0xfb);\r\nSETIREGANDOR(SISSR, 0x21, 0x1f, 0xa0);\r\nSETIREGAND(SISSR, 0x32, 0xf3);\r\nSETIREGANDOR(SISSR, 0x07, 0xf8, 0x03);\r\nSETIREG(SISCR, 0x52, 0x6c);\r\nSETIREG(SISCR, 0x0d, 0x00);\r\nSETIREG(SISCR, 0x0c, 0x00);\r\nSETIREG(SISSR, 0x0d, 0x00);\r\nSETIREGAND(SISSR, 0x37, 0xfe);\r\nSETIREG(SISCR, 0x32, 0x20);\r\nSETIREGAND(SISSR, 0x01, 0xdf);\r\nSETIREG(SISCR, 0x63, (cr63 & 0xbf));\r\nSETIREG(SISSR, 0x31, (sr31 & 0xfb));\r\nif (touchengines) {\r\nSETIREG(SISSR, 0x20, 0xa1);\r\nSETIREGOR(SISSR, 0x1e, 0x5a);\r\nSETIREG(SISSR, 0x26, 0x01);\r\nSETIREG(SISSR, 0x27, 0x1f);\r\nSETIREG(SISSR, 0x26, 0x00);\r\n}\r\nSETIREG(SISCR, 0x34, 0x44);\r\nreturn ret;\r\n}\r\nstatic int sisusb_init_gfxcore(struct sisusb_usb_data *sisusb)\r\n{\r\nint ret = 0, i, j, bw, chab, iret, retry = 3;\r\nu8 tmp8, ramtype;\r\nu32 tmp32;\r\nstatic const char mclktable[] = {\r\n0x3b, 0x22, 0x01, 143,\r\n0x3b, 0x22, 0x01, 143,\r\n0x3b, 0x22, 0x01, 143,\r\n0x3b, 0x22, 0x01, 143\r\n};\r\nstatic const char eclktable[] = {\r\n0x3b, 0x22, 0x01, 143,\r\n0x3b, 0x22, 0x01, 143,\r\n0x3b, 0x22, 0x01, 143,\r\n0x3b, 0x22, 0x01, 143\r\n};\r\nstatic const char ramtypetable1[] = {\r\n0x00, 0x04, 0x60, 0x60,\r\n0x0f, 0x0f, 0x1f, 0x1f,\r\n0xba, 0xba, 0xba, 0xba,\r\n0xa9, 0xa9, 0xac, 0xac,\r\n0xa0, 0xa0, 0xa0, 0xa8,\r\n0x00, 0x00, 0x02, 0x02,\r\n0x30, 0x30, 0x40, 0x40\r\n};\r\nstatic const char ramtypetable2[] = {\r\n0x77, 0x77, 0x44, 0x44,\r\n0x77, 0x77, 0x44, 0x44,\r\n0x00, 0x00, 0x00, 0x00,\r\n0x5b, 0x5b, 0xab, 0xab,\r\n0x00, 0x00, 0xf0, 0xf8\r\n};\r\nwhile (retry--) {\r\nret = GETREG(SISVGAEN, &tmp8);\r\nret |= SETREG(SISVGAEN, (tmp8 | 0x01));\r\nret |= GETREG(SISMISCR, &tmp8);\r\nret |= SETREG(SISMISCW, (tmp8 | 0x01));\r\nif (ret)\r\ncontinue;\r\nret |= SETIREGAND(SISCR, 0x5b, 0xdf);\r\nret |= SETIREG(SISSR, 0x05, 0x86);\r\nret |= SETIREGOR(SISSR, 0x20, 0x01);\r\nret |= SETREG(SISMISCW, 0x67);\r\nfor (i = 0x06; i <= 0x1f; i++)\r\nret |= SETIREG(SISSR, i, 0x00);\r\nfor (i = 0x21; i <= 0x27; i++)\r\nret |= SETIREG(SISSR, i, 0x00);\r\nfor (i = 0x31; i <= 0x3d; i++)\r\nret |= SETIREG(SISSR, i, 0x00);\r\nfor (i = 0x12; i <= 0x1b; i++)\r\nret |= SETIREG(SISSR, i, 0x00);\r\nfor (i = 0x79; i <= 0x7c; i++)\r\nret |= SETIREG(SISCR, i, 0x00);\r\nif (ret)\r\ncontinue;\r\nret |= SETIREG(SISCR, 0x63, 0x80);\r\nret |= GETIREG(SISSR, 0x3a, &ramtype);\r\nramtype &= 0x03;\r\nret |= SETIREG(SISSR, 0x28, mclktable[ramtype * 4]);\r\nret |= SETIREG(SISSR, 0x29, mclktable[(ramtype * 4) + 1]);\r\nret |= SETIREG(SISSR, 0x2a, mclktable[(ramtype * 4) + 2]);\r\nret |= SETIREG(SISSR, 0x2e, eclktable[ramtype * 4]);\r\nret |= SETIREG(SISSR, 0x2f, eclktable[(ramtype * 4) + 1]);\r\nret |= SETIREG(SISSR, 0x30, eclktable[(ramtype * 4) + 2]);\r\nret |= SETIREG(SISSR, 0x07, 0x18);\r\nret |= SETIREG(SISSR, 0x11, 0x0f);\r\nif (ret)\r\ncontinue;\r\nfor (i = 0x15, j = 0; i <= 0x1b; i++, j++) {\r\nret |= SETIREG(SISSR, i,\r\nramtypetable1[(j*4) + ramtype]);\r\n}\r\nfor (i = 0x40, j = 0; i <= 0x44; i++, j++) {\r\nret |= SETIREG(SISCR, i,\r\nramtypetable2[(j*4) + ramtype]);\r\n}\r\nret |= SETIREG(SISCR, 0x49, 0xaa);\r\nret |= SETIREG(SISSR, 0x1f, 0x00);\r\nret |= SETIREG(SISSR, 0x20, 0xa0);\r\nret |= SETIREG(SISSR, 0x23, 0xf6);\r\nret |= SETIREG(SISSR, 0x24, 0x0d);\r\nret |= SETIREG(SISSR, 0x25, 0x33);\r\nret |= SETIREG(SISSR, 0x11, 0x0f);\r\nret |= SETIREGOR(SISPART1, 0x2f, 0x01);\r\nret |= SETIREGAND(SISCAP, 0x3f, 0xef);\r\nif (ret)\r\ncontinue;\r\nret |= SETIREG(SISPART1, 0x00, 0x00);\r\nret |= GETIREG(SISSR, 0x13, &tmp8);\r\ntmp8 >>= 4;\r\nret |= SETIREG(SISPART1, 0x02, 0x00);\r\nret |= SETIREG(SISPART1, 0x2e, 0x08);\r\nret |= sisusb_read_pci_config(sisusb, 0x50, &tmp32);\r\ntmp32 &= 0x00f00000;\r\ntmp8 = (tmp32 == 0x100000) ? 0x33 : 0x03;\r\nret |= SETIREG(SISSR, 0x25, tmp8);\r\ntmp8 = (tmp32 == 0x100000) ? 0xaa : 0x88;\r\nret |= SETIREG(SISCR, 0x49, tmp8);\r\nret |= SETIREG(SISSR, 0x27, 0x1f);\r\nret |= SETIREG(SISSR, 0x31, 0x00);\r\nret |= SETIREG(SISSR, 0x32, 0x11);\r\nret |= SETIREG(SISSR, 0x33, 0x00);\r\nif (ret)\r\ncontinue;\r\nret |= SETIREG(SISCR, 0x83, 0x00);\r\nret |= sisusb_set_default_mode(sisusb, 0);\r\nret |= SETIREGAND(SISSR, 0x21, 0xdf);\r\nret |= SETIREGOR(SISSR, 0x01, 0x20);\r\nret |= SETIREGOR(SISSR, 0x16, 0x0f);\r\nret |= sisusb_triggersr16(sisusb, ramtype);\r\nret |= SETIREGAND(SISSR, 0x17, 0xf8);\r\nret |= SETIREGOR(SISSR, 0x19, 0x03);\r\nret |= sisusb_getbuswidth(sisusb, &bw, &chab);\r\nret |= sisusb_verify_mclk(sisusb);\r\nif (ramtype <= 1) {\r\nret |= sisusb_get_sdram_size(sisusb, &iret, bw, chab);\r\nif (iret) {\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"RAM size detection failed, assuming 8MB video RAM\n");\r\nret |= SETIREG(SISSR, 0x14, 0x31);\r\n}\r\n} else {\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"DDR RAM device found, assuming 8MB video RAM\n");\r\nret |= SETIREG(SISSR, 0x14, 0x31);\r\n}\r\nret |= SETIREG(SISSR, 0x16, ramtypetable1[4 + ramtype]);\r\nret |= SETIREG(SISSR, 0x17, ramtypetable1[8 + ramtype]);\r\nret |= SETIREG(SISSR, 0x19, ramtypetable1[16 + ramtype]);\r\nret |= SETIREGOR(SISSR, 0x21, 0x20);\r\nret |= SETIREG(SISSR, 0x22, 0xfb);\r\nret |= SETIREG(SISSR, 0x21, 0xa5);\r\nif (ret == 0)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic void sisusb_get_ramconfig(struct sisusb_usb_data *sisusb)\r\n{\r\nu8 tmp8, tmp82, ramtype;\r\nint bw = 0;\r\nchar *ramtypetext1 = NULL;\r\nstatic const char ram_datarate[4] = {'S', 'S', 'D', 'D'};\r\nstatic const char ram_dynamictype[4] = {'D', 'G', 'D', 'G'};\r\nstatic const int busSDR[4] = {64, 64, 128, 128};\r\nstatic const int busDDR[4] = {32, 32, 64, 64};\r\nstatic const int busDDRA[4] = {64+32, 64+32, (64+32)*2, (64+32)*2};\r\nsisusb_getidxreg(sisusb, SISSR, 0x14, &tmp8);\r\nsisusb_getidxreg(sisusb, SISSR, 0x15, &tmp82);\r\nsisusb_getidxreg(sisusb, SISSR, 0x3a, &ramtype);\r\nsisusb->vramsize = (1 << ((tmp8 & 0xf0) >> 4)) * 1024 * 1024;\r\nramtype &= 0x03;\r\nswitch ((tmp8 >> 2) & 0x03) {\r\ncase 0:\r\nramtypetext1 = "1 ch/1 r";\r\nif (tmp82 & 0x10)\r\nbw = 32;\r\nelse\r\nbw = busSDR[(tmp8 & 0x03)];\r\nbreak;\r\ncase 1:\r\nramtypetext1 = "1 ch/2 r";\r\nsisusb->vramsize <<= 1;\r\nbw = busSDR[(tmp8 & 0x03)];\r\nbreak;\r\ncase 2:\r\nramtypetext1 = "asymmeric";\r\nsisusb->vramsize += sisusb->vramsize/2;\r\nbw = busDDRA[(tmp8 & 0x03)];\r\nbreak;\r\ncase 3:\r\nramtypetext1 = "2 channel";\r\nsisusb->vramsize <<= 1;\r\nbw = busDDR[(tmp8 & 0x03)];\r\nbreak;\r\n}\r\ndev_info(&sisusb->sisusb_dev->dev,\r\n"%dMB %s %cDR S%cRAM, bus width %d\n",\r\nsisusb->vramsize >> 20, ramtypetext1,\r\nram_datarate[ramtype], ram_dynamictype[ramtype], bw);\r\n}\r\nstatic int sisusb_do_init_gfxdevice(struct sisusb_usb_data *sisusb)\r\n{\r\nstruct sisusb_packet packet;\r\nint ret;\r\nu32 tmp32;\r\npacket.header = 0x001f;\r\npacket.address = 0x00000324;\r\npacket.data = 0x00000004;\r\nret = sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\r\npacket.header = 0x001f;\r\npacket.address = 0x00000364;\r\npacket.data = 0x00000004;\r\nret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\r\npacket.header = 0x001f;\r\npacket.address = 0x00000384;\r\npacket.data = 0x00000004;\r\nret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\r\npacket.header = 0x001f;\r\npacket.address = 0x00000100;\r\npacket.data = 0x00000700;\r\nret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\r\npacket.header = 0x000f;\r\npacket.address = 0x00000004;\r\nret |= sisusb_send_bridge_packet(sisusb, 6, &packet, 0);\r\npacket.data |= 0x17;\r\nret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\r\nret |= sisusb_read_pci_config(sisusb, 0x10, &tmp32);\r\nret |= sisusb_write_pci_config(sisusb, 0x10, 0xfffffff0);\r\nret |= sisusb_read_pci_config(sisusb, 0x10, &tmp32);\r\ntmp32 &= 0x0f;\r\ntmp32 |= SISUSB_PCI_MEMBASE;\r\nret |= sisusb_write_pci_config(sisusb, 0x10, tmp32);\r\nret |= sisusb_read_pci_config(sisusb, 0x14, &tmp32);\r\nret |= sisusb_write_pci_config(sisusb, 0x14, 0xfffffff0);\r\nret |= sisusb_read_pci_config(sisusb, 0x14, &tmp32);\r\ntmp32 &= 0x0f;\r\ntmp32 |= SISUSB_PCI_MMIOBASE;\r\nret |= sisusb_write_pci_config(sisusb, 0x14, tmp32);\r\nret |= sisusb_read_pci_config(sisusb, 0x18, &tmp32);\r\nret |= sisusb_write_pci_config(sisusb, 0x18, 0xfffffff0);\r\nret |= sisusb_read_pci_config(sisusb, 0x18, &tmp32);\r\ntmp32 &= 0x0f;\r\ntmp32 |= SISUSB_PCI_IOPORTBASE;\r\nret |= sisusb_write_pci_config(sisusb, 0x18, tmp32);\r\nret |= sisusb_read_pci_config(sisusb, 0x04, &tmp32);\r\ntmp32 |= 0x3;\r\nret |= sisusb_write_pci_config(sisusb, 0x04, tmp32);\r\nif (ret == 0) {\r\npacket.header = 0x001f;\r\npacket.address = 0x00000050;\r\npacket.data = 0x000000ff;\r\nret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\r\n}\r\nreturn ret;\r\n}\r\nstatic int sisusb_init_gfxdevice(struct sisusb_usb_data *sisusb, int initscreen)\r\n{\r\nint ret = 0, test = 0;\r\nu32 tmp32;\r\nif (sisusb->devinit == 1) {\r\nret |= sisusb_read_pci_config(sisusb, 0x10, &tmp32);\r\nif (ret)\r\nreturn ret;\r\nif ((tmp32 & 0xfffffff0) == SISUSB_PCI_MEMBASE)\r\ntest++;\r\nret |= sisusb_read_pci_config(sisusb, 0x14, &tmp32);\r\nif (ret)\r\nreturn ret;\r\nif ((tmp32 & 0xfffffff0) == SISUSB_PCI_MMIOBASE)\r\ntest++;\r\nret |= sisusb_read_pci_config(sisusb, 0x18, &tmp32);\r\nif (ret)\r\nreturn ret;\r\nif ((tmp32 & 0xfffffff0) == SISUSB_PCI_IOPORTBASE)\r\ntest++;\r\n}\r\nif ((sisusb->devinit == 0) || (test != 3)) {\r\nret |= sisusb_do_init_gfxdevice(sisusb);\r\nif (ret == 0)\r\nsisusb->devinit = 1;\r\n}\r\nif (sisusb->devinit) {\r\nif (sisusb_init_gfxcore(sisusb) == 0) {\r\nsisusb->gfxinit = 1;\r\nsisusb_get_ramconfig(sisusb);\r\nret |= sisusb_set_default_mode(sisusb, 1);\r\nret |= sisusb_setup_screen(sisusb, 1, initscreen);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint sisusb_reset_text_mode(struct sisusb_usb_data *sisusb, int init)\r\n{\r\nint ret = 0, slot = sisusb->font_slot, i;\r\nconst struct font_desc *myfont;\r\nu8 *tempbuf;\r\nu16 *tempbufb;\r\nstatic const char bootstring[] =\r\n"SiSUSB VGA text console, (C) 2005 Thomas Winischhofer.";\r\nstatic const char bootlogo[] = "(o_ //\\ V_/_";\r\nif (!sisusb->SiS_Pr)\r\nreturn 1;\r\nsisusb->SiS_Pr->IOAddress = SISUSB_PCI_IOPORTBASE + 0x30;\r\nsisusb->SiS_Pr->sisusb = (void *)sisusb;\r\nSiSUSBSetMode(sisusb->SiS_Pr, 0x03);\r\nmyfont = find_font("VGA8x16");\r\nif (!myfont)\r\nreturn 1;\r\ntempbuf = vmalloc(8192);\r\nif (!tempbuf)\r\nreturn 1;\r\nfor (i = 0; i < 256; i++)\r\nmemcpy(tempbuf + (i * 32), myfont->data + (i * 16), 16);\r\nret = sisusbcon_do_font_op(sisusb, 1, 0, tempbuf, 8192,\r\n0, 1, NULL, 16, 0);\r\nvfree(tempbuf);\r\nif (sisusb->font_backup) {\r\nret |= sisusbcon_do_font_op(sisusb, 1, 2, sisusb->font_backup,\r\n8192, sisusb->font_backup_512, 1, NULL,\r\nsisusb->font_backup_height, 0);\r\nif (slot != 2)\r\nsisusbcon_do_font_op(sisusb, 1, 0, NULL, 0, 0, 1,\r\nNULL, 16, 0);\r\n}\r\nif (init && !sisusb->scrbuf) {\r\ntempbuf = vmalloc(8192);\r\nif (tempbuf) {\r\ni = 4096;\r\ntempbufb = (u16 *)tempbuf;\r\nwhile (i--)\r\n*(tempbufb++) = 0x0720;\r\ni = 0;\r\ntempbufb = (u16 *)tempbuf;\r\nwhile (bootlogo[i]) {\r\n*(tempbufb++) = 0x0700 | bootlogo[i++];\r\nif (!(i % 4))\r\ntempbufb += 76;\r\n}\r\ni = 0;\r\ntempbufb = (u16 *)tempbuf + 6;\r\nwhile (bootstring[i])\r\n*(tempbufb++) = 0x0700 | bootstring[i++];\r\nret |= sisusb_copy_memory(sisusb, tempbuf,\r\nsisusb->vrambase, 8192);\r\nvfree(tempbuf);\r\n}\r\n} else if (sisusb->scrbuf) {\r\nret |= sisusb_copy_memory(sisusb, (char *)sisusb->scrbuf,\r\nsisusb->vrambase, sisusb->scrbuf_size);\r\n}\r\nif (sisusb->sisusb_cursor_size_from >= 0 &&\r\nsisusb->sisusb_cursor_size_to >= 0) {\r\nsisusb_setidxreg(sisusb, SISCR, 0x0a,\r\nsisusb->sisusb_cursor_size_from);\r\nsisusb_setidxregandor(sisusb, SISCR, 0x0b, 0xe0,\r\nsisusb->sisusb_cursor_size_to);\r\n} else {\r\nsisusb_setidxreg(sisusb, SISCR, 0x0a, 0x2d);\r\nsisusb_setidxreg(sisusb, SISCR, 0x0b, 0x0e);\r\nsisusb->sisusb_cursor_size_to = -1;\r\n}\r\nslot = sisusb->sisusb_cursor_loc;\r\nif (slot < 0)\r\nslot = 0;\r\nsisusb->sisusb_cursor_loc = -1;\r\nsisusb->bad_cursor_pos = 1;\r\nsisusb_set_cursor(sisusb, slot);\r\nsisusb_setidxreg(sisusb, SISCR, 0x0c, (sisusb->cur_start_addr >> 8));\r\nsisusb_setidxreg(sisusb, SISCR, 0x0d, (sisusb->cur_start_addr & 0xff));\r\nsisusb->textmodedestroyed = 0;\r\nreturn ret;\r\n}\r\nstatic int sisusb_open(struct inode *inode, struct file *file)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nstruct usb_interface *interface;\r\nint subminor = iminor(inode);\r\ninterface = usb_find_interface(&sisusb_driver, subminor);\r\nif (!interface)\r\nreturn -ENODEV;\r\nsisusb = usb_get_intfdata(interface);\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb->present || !sisusb->ready) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -ENODEV;\r\n}\r\nif (sisusb->isopen) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -EBUSY;\r\n}\r\nif (!sisusb->devinit) {\r\nif (sisusb->sisusb_dev->speed == USB_SPEED_HIGH ||\r\nsisusb->sisusb_dev->speed >= USB_SPEED_SUPER) {\r\nif (sisusb_init_gfxdevice(sisusb, 0)) {\r\nmutex_unlock(&sisusb->lock);\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"Failed to initialize device\n");\r\nreturn -EIO;\r\n}\r\n} else {\r\nmutex_unlock(&sisusb->lock);\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"Device not attached to USB 2.0 hub\n");\r\nreturn -EIO;\r\n}\r\n}\r\nkref_get(&sisusb->kref);\r\nsisusb->isopen = 1;\r\nfile->private_data = sisusb;\r\nmutex_unlock(&sisusb->lock);\r\nreturn 0;\r\n}\r\nvoid sisusb_delete(struct kref *kref)\r\n{\r\nstruct sisusb_usb_data *sisusb = to_sisusb_dev(kref);\r\nif (!sisusb)\r\nreturn;\r\nusb_put_dev(sisusb->sisusb_dev);\r\nsisusb->sisusb_dev = NULL;\r\nsisusb_free_buffers(sisusb);\r\nsisusb_free_urbs(sisusb);\r\n#ifdef INCL_SISUSB_CON\r\nkfree(sisusb->SiS_Pr);\r\n#endif\r\nkfree(sisusb);\r\n}\r\nstatic int sisusb_release(struct inode *inode, struct file *file)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nsisusb = file->private_data;\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nmutex_lock(&sisusb->lock);\r\nif (sisusb->present) {\r\nif (!sisusb_wait_all_out_complete(sisusb))\r\nsisusb_kill_all_busy(sisusb);\r\n}\r\nsisusb->isopen = 0;\r\nfile->private_data = NULL;\r\nmutex_unlock(&sisusb->lock);\r\nkref_put(&sisusb->kref, sisusb_delete);\r\nreturn 0;\r\n}\r\nstatic ssize_t sisusb_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nssize_t bytes_read = 0;\r\nint errno = 0;\r\nu8 buf8;\r\nu16 buf16;\r\nu32 buf32, address;\r\nsisusb = file->private_data;\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -ENODEV;\r\n}\r\nif ((*ppos) >= SISUSB_PCI_PSEUDO_IOPORTBASE &&\r\n(*ppos) < SISUSB_PCI_PSEUDO_IOPORTBASE + 128) {\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_IOPORTBASE +\r\nSISUSB_PCI_IOPORTBASE;\r\nswitch (count) {\r\ncase 1:\r\nif (sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO,\r\naddress, &buf8))\r\nerrno = -EIO;\r\nelse if (put_user(buf8, (u8 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse\r\nbytes_read = 1;\r\nbreak;\r\ncase 2:\r\nif (sisusb_read_memio_word(sisusb, SISUSB_TYPE_IO,\r\naddress, &buf16))\r\nerrno = -EIO;\r\nelse if (put_user(buf16, (u16 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse\r\nbytes_read = 2;\r\nbreak;\r\ncase 4:\r\nif (sisusb_read_memio_long(sisusb, SISUSB_TYPE_IO,\r\naddress, &buf32))\r\nerrno = -EIO;\r\nelse if (put_user(buf32, (u32 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse\r\nbytes_read = 4;\r\nbreak;\r\ndefault:\r\nerrno = -EIO;\r\n}\r\n} else if ((*ppos) >= SISUSB_PCI_PSEUDO_MEMBASE && (*ppos) <\r\nSISUSB_PCI_PSEUDO_MEMBASE + sisusb->vramsize) {\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_MEMBASE +\r\nSISUSB_PCI_MEMBASE;\r\nerrno = sisusb_read_mem_bulk(sisusb, address,\r\nNULL, count, buffer, &bytes_read);\r\nif (bytes_read)\r\nerrno = bytes_read;\r\n} else if ((*ppos) >= SISUSB_PCI_PSEUDO_MMIOBASE &&\r\n(*ppos) < SISUSB_PCI_PSEUDO_MMIOBASE +\r\nSISUSB_PCI_MMIOSIZE) {\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_MMIOBASE +\r\nSISUSB_PCI_MMIOBASE;\r\nerrno = sisusb_read_mem_bulk(sisusb, address,\r\nNULL, count, buffer, &bytes_read);\r\nif (bytes_read)\r\nerrno = bytes_read;\r\n} else if ((*ppos) >= SISUSB_PCI_PSEUDO_PCIBASE &&\r\n(*ppos) <= SISUSB_PCI_PSEUDO_PCIBASE + 0x5c) {\r\nif (count != 4) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -EINVAL;\r\n}\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_PCIBASE;\r\nif (sisusb_read_pci_config(sisusb, address, &buf32))\r\nerrno = -EIO;\r\nelse if (put_user(buf32, (u32 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse\r\nbytes_read = 4;\r\n} else {\r\nerrno = -EBADFD;\r\n}\r\n(*ppos) += bytes_read;\r\nmutex_unlock(&sisusb->lock);\r\nreturn errno ? errno : bytes_read;\r\n}\r\nstatic ssize_t sisusb_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nint errno = 0;\r\nssize_t bytes_written = 0;\r\nu8 buf8;\r\nu16 buf16;\r\nu32 buf32, address;\r\nsisusb = file->private_data;\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -ENODEV;\r\n}\r\nif ((*ppos) >= SISUSB_PCI_PSEUDO_IOPORTBASE &&\r\n(*ppos) < SISUSB_PCI_PSEUDO_IOPORTBASE + 128) {\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_IOPORTBASE +\r\nSISUSB_PCI_IOPORTBASE;\r\nswitch (count) {\r\ncase 1:\r\nif (get_user(buf8, (u8 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse if (sisusb_write_memio_byte(sisusb,\r\nSISUSB_TYPE_IO, address, buf8))\r\nerrno = -EIO;\r\nelse\r\nbytes_written = 1;\r\nbreak;\r\ncase 2:\r\nif (get_user(buf16, (u16 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse if (sisusb_write_memio_word(sisusb,\r\nSISUSB_TYPE_IO, address, buf16))\r\nerrno = -EIO;\r\nelse\r\nbytes_written = 2;\r\nbreak;\r\ncase 4:\r\nif (get_user(buf32, (u32 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse if (sisusb_write_memio_long(sisusb,\r\nSISUSB_TYPE_IO, address, buf32))\r\nerrno = -EIO;\r\nelse\r\nbytes_written = 4;\r\nbreak;\r\ndefault:\r\nerrno = -EIO;\r\n}\r\n} else if ((*ppos) >= SISUSB_PCI_PSEUDO_MEMBASE &&\r\n(*ppos) < SISUSB_PCI_PSEUDO_MEMBASE +\r\nsisusb->vramsize) {\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_MEMBASE +\r\nSISUSB_PCI_MEMBASE;\r\nerrno = sisusb_write_mem_bulk(sisusb, address, NULL,\r\ncount, buffer, 0, &bytes_written);\r\nif (bytes_written)\r\nerrno = bytes_written;\r\n} else if ((*ppos) >= SISUSB_PCI_PSEUDO_MMIOBASE &&\r\n(*ppos) < SISUSB_PCI_PSEUDO_MMIOBASE +\r\nSISUSB_PCI_MMIOSIZE) {\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_MMIOBASE +\r\nSISUSB_PCI_MMIOBASE;\r\nerrno = sisusb_write_mem_bulk(sisusb, address, NULL,\r\ncount, buffer, 0, &bytes_written);\r\nif (bytes_written)\r\nerrno = bytes_written;\r\n} else if ((*ppos) >= SISUSB_PCI_PSEUDO_PCIBASE &&\r\n(*ppos) <= SISUSB_PCI_PSEUDO_PCIBASE +\r\nSISUSB_PCI_PCONFSIZE) {\r\nif (count != 4) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -EINVAL;\r\n}\r\naddress = (*ppos) - SISUSB_PCI_PSEUDO_PCIBASE;\r\nif (get_user(buf32, (u32 __user *)buffer))\r\nerrno = -EFAULT;\r\nelse if (sisusb_write_pci_config(sisusb, address, buf32))\r\nerrno = -EIO;\r\nelse\r\nbytes_written = 4;\r\n} else {\r\nerrno = -EBADFD;\r\n}\r\n(*ppos) += bytes_written;\r\nmutex_unlock(&sisusb->lock);\r\nreturn errno ? errno : bytes_written;\r\n}\r\nstatic loff_t sisusb_lseek(struct file *file, loff_t offset, int orig)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nloff_t ret;\r\nsisusb = file->private_data;\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\r\nmutex_unlock(&sisusb->lock);\r\nreturn -ENODEV;\r\n}\r\nret = no_seek_end_llseek(file, offset, orig);\r\nmutex_unlock(&sisusb->lock);\r\nreturn ret;\r\n}\r\nstatic int sisusb_handle_command(struct sisusb_usb_data *sisusb,\r\nstruct sisusb_command *y, unsigned long arg)\r\n{\r\nint retval, port, length;\r\nu32 address;\r\nif (!sisusb->devinit)\r\nreturn -ENODEV;\r\nport = y->data3 -\r\nSISUSB_PCI_PSEUDO_IOPORTBASE +\r\nSISUSB_PCI_IOPORTBASE;\r\nswitch (y->operation) {\r\ncase SUCMD_GET:\r\nretval = sisusb_getidxreg(sisusb, port, y->data0, &y->data1);\r\nif (!retval) {\r\nif (copy_to_user((void __user *)arg, y, sizeof(*y)))\r\nretval = -EFAULT;\r\n}\r\nbreak;\r\ncase SUCMD_SET:\r\nretval = sisusb_setidxreg(sisusb, port, y->data0, y->data1);\r\nbreak;\r\ncase SUCMD_SETOR:\r\nretval = sisusb_setidxregor(sisusb, port, y->data0, y->data1);\r\nbreak;\r\ncase SUCMD_SETAND:\r\nretval = sisusb_setidxregand(sisusb, port, y->data0, y->data1);\r\nbreak;\r\ncase SUCMD_SETANDOR:\r\nretval = sisusb_setidxregandor(sisusb, port, y->data0,\r\ny->data1, y->data2);\r\nbreak;\r\ncase SUCMD_SETMASK:\r\nretval = sisusb_setidxregmask(sisusb, port, y->data0,\r\ny->data1, y->data2);\r\nbreak;\r\ncase SUCMD_CLRSCR:\r\nif (!sisusb->gfxinit)\r\nreturn -ENODEV;\r\nlength = (y->data0 << 16) | (y->data1 << 8) | y->data2;\r\naddress = y->data3 - SISUSB_PCI_PSEUDO_MEMBASE +\r\nSISUSB_PCI_MEMBASE;\r\nretval = sisusb_clear_vram(sisusb, address, length);\r\nbreak;\r\ncase SUCMD_HANDLETEXTMODE:\r\nretval = 0;\r\n#ifdef INCL_SISUSB_CON\r\nif (!sisusb->gfxinit || !sisusb->SiS_Pr)\r\nreturn -ENODEV;\r\nswitch (y->data0) {\r\ncase 0:\r\nretval = sisusb_reset_text_mode(sisusb, 0);\r\nbreak;\r\ncase 1:\r\nsisusb->textmodedestroyed = 1;\r\nbreak;\r\n}\r\n#endif\r\nbreak;\r\n#ifdef INCL_SISUSB_CON\r\ncase SUCMD_SETMODE:\r\nif (!sisusb->gfxinit || !sisusb->SiS_Pr)\r\nreturn -ENODEV;\r\nretval = 0;\r\nsisusb->SiS_Pr->IOAddress = SISUSB_PCI_IOPORTBASE + 0x30;\r\nsisusb->SiS_Pr->sisusb = (void *)sisusb;\r\nif (SiSUSBSetMode(sisusb->SiS_Pr, y->data3))\r\nretval = -EINVAL;\r\nbreak;\r\ncase SUCMD_SETVESAMODE:\r\nif (!sisusb->gfxinit || !sisusb->SiS_Pr)\r\nreturn -ENODEV;\r\nretval = 0;\r\nsisusb->SiS_Pr->IOAddress = SISUSB_PCI_IOPORTBASE + 0x30;\r\nsisusb->SiS_Pr->sisusb = (void *)sisusb;\r\nif (SiSUSBSetVESAMode(sisusb->SiS_Pr, y->data3))\r\nretval = -EINVAL;\r\nbreak;\r\n#endif\r\ndefault:\r\nretval = -EINVAL;\r\n}\r\nif (retval > 0)\r\nretval = -EIO;\r\nreturn retval;\r\n}\r\nstatic long sisusb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nstruct sisusb_info x;\r\nstruct sisusb_command y;\r\nlong retval = 0;\r\nu32 __user *argp = (u32 __user *)arg;\r\nsisusb = file->private_data;\r\nif (!sisusb)\r\nreturn -ENODEV;\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\r\nretval = -ENODEV;\r\ngoto err_out;\r\n}\r\nswitch (cmd) {\r\ncase SISUSB_GET_CONFIG_SIZE:\r\nif (put_user(sizeof(x), argp))\r\nretval = -EFAULT;\r\nbreak;\r\ncase SISUSB_GET_CONFIG:\r\nx.sisusb_id = SISUSB_ID;\r\nx.sisusb_version = SISUSB_VERSION;\r\nx.sisusb_revision = SISUSB_REVISION;\r\nx.sisusb_patchlevel = SISUSB_PATCHLEVEL;\r\nx.sisusb_gfxinit = sisusb->gfxinit;\r\nx.sisusb_vrambase = SISUSB_PCI_PSEUDO_MEMBASE;\r\nx.sisusb_mmiobase = SISUSB_PCI_PSEUDO_MMIOBASE;\r\nx.sisusb_iobase = SISUSB_PCI_PSEUDO_IOPORTBASE;\r\nx.sisusb_pcibase = SISUSB_PCI_PSEUDO_PCIBASE;\r\nx.sisusb_vramsize = sisusb->vramsize;\r\nx.sisusb_minor = sisusb->minor;\r\nx.sisusb_fbdevactive = 0;\r\n#ifdef INCL_SISUSB_CON\r\nx.sisusb_conactive = sisusb->haveconsole ? 1 : 0;\r\n#else\r\nx.sisusb_conactive = 0;\r\n#endif\r\nmemset(x.sisusb_reserved, 0, sizeof(x.sisusb_reserved));\r\nif (copy_to_user((void __user *)arg, &x, sizeof(x)))\r\nretval = -EFAULT;\r\nbreak;\r\ncase SISUSB_COMMAND:\r\nif (copy_from_user(&y, (void __user *)arg, sizeof(y)))\r\nretval = -EFAULT;\r\nelse\r\nretval = sisusb_handle_command(sisusb, &y, arg);\r\nbreak;\r\ndefault:\r\nretval = -ENOTTY;\r\nbreak;\r\n}\r\nerr_out:\r\nmutex_unlock(&sisusb->lock);\r\nreturn retval;\r\n}\r\nstatic long sisusb_compat_ioctl(struct file *f, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nlong retval;\r\nswitch (cmd) {\r\ncase SISUSB_GET_CONFIG_SIZE:\r\ncase SISUSB_GET_CONFIG:\r\ncase SISUSB_COMMAND:\r\nretval = sisusb_ioctl(f, cmd, arg);\r\nreturn retval;\r\ndefault:\r\nreturn -ENOIOCTLCMD;\r\n}\r\n}\r\nstatic int sisusb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *dev = interface_to_usbdev(intf);\r\nstruct sisusb_usb_data *sisusb;\r\nint retval = 0, i;\r\ndev_info(&dev->dev, "USB2VGA dongle found at address %d\n",\r\ndev->devnum);\r\nsisusb = kzalloc(sizeof(*sisusb), GFP_KERNEL);\r\nif (!sisusb)\r\nreturn -ENOMEM;\r\nkref_init(&sisusb->kref);\r\nmutex_init(&(sisusb->lock));\r\nretval = usb_register_dev(intf, &usb_sisusb_class);\r\nif (retval) {\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"Failed to get a minor for device %d\n",\r\ndev->devnum);\r\nretval = -ENODEV;\r\ngoto error_1;\r\n}\r\nsisusb->sisusb_dev = dev;\r\nsisusb->minor = intf->minor;\r\nsisusb->vrambase = SISUSB_PCI_MEMBASE;\r\nsisusb->mmiobase = SISUSB_PCI_MMIOBASE;\r\nsisusb->mmiosize = SISUSB_PCI_MMIOSIZE;\r\nsisusb->ioportbase = SISUSB_PCI_IOPORTBASE;\r\nsisusb->ibufsize = SISUSB_IBUF_SIZE;\r\nsisusb->ibuf = kmalloc(SISUSB_IBUF_SIZE, GFP_KERNEL);\r\nif (!sisusb->ibuf) {\r\nretval = -ENOMEM;\r\ngoto error_2;\r\n}\r\nsisusb->numobufs = 0;\r\nsisusb->obufsize = SISUSB_OBUF_SIZE;\r\nfor (i = 0; i < NUMOBUFS; i++) {\r\nsisusb->obuf[i] = kmalloc(SISUSB_OBUF_SIZE, GFP_KERNEL);\r\nif (!sisusb->obuf[i]) {\r\nif (i == 0) {\r\nretval = -ENOMEM;\r\ngoto error_3;\r\n}\r\nbreak;\r\n}\r\nsisusb->numobufs++;\r\n}\r\nsisusb->sisurbin = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!sisusb->sisurbin) {\r\nretval = -ENOMEM;\r\ngoto error_3;\r\n}\r\nsisusb->completein = 1;\r\nfor (i = 0; i < sisusb->numobufs; i++) {\r\nsisusb->sisurbout[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (!sisusb->sisurbout[i]) {\r\nretval = -ENOMEM;\r\ngoto error_4;\r\n}\r\nsisusb->urbout_context[i].sisusb = (void *)sisusb;\r\nsisusb->urbout_context[i].urbindex = i;\r\nsisusb->urbstatus[i] = 0;\r\n}\r\ndev_info(&sisusb->sisusb_dev->dev, "Allocated %d output buffers\n",\r\nsisusb->numobufs);\r\n#ifdef INCL_SISUSB_CON\r\nsisusb->SiS_Pr = kmalloc(sizeof(struct SiS_Private), GFP_KERNEL);\r\nif (!sisusb->SiS_Pr) {\r\nretval = -ENOMEM;\r\ngoto error_4;\r\n}\r\n#endif\r\ninit_waitqueue_head(&sisusb->wait_q);\r\nusb_set_intfdata(intf, sisusb);\r\nusb_get_dev(sisusb->sisusb_dev);\r\nsisusb->present = 1;\r\nif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\r\nint initscreen = 1;\r\n#ifdef INCL_SISUSB_CON\r\nif (sisusb_first_vc > 0 && sisusb_last_vc > 0 &&\r\nsisusb_first_vc <= sisusb_last_vc &&\r\nsisusb_last_vc <= MAX_NR_CONSOLES)\r\ninitscreen = 0;\r\n#endif\r\nif (sisusb_init_gfxdevice(sisusb, initscreen))\r\ndev_err(&sisusb->sisusb_dev->dev,\r\n"Failed to early initialize device\n");\r\n} else\r\ndev_info(&sisusb->sisusb_dev->dev,\r\n"Not attached to USB 2.0 hub, deferring init\n");\r\nsisusb->ready = 1;\r\n#ifdef SISUSBENDIANTEST\r\ndev_dbg(&sisusb->sisusb_dev->dev, "*** RWTEST ***\n");\r\nsisusb_testreadwrite(sisusb);\r\ndev_dbg(&sisusb->sisusb_dev->dev, "*** RWTEST END ***\n");\r\n#endif\r\n#ifdef INCL_SISUSB_CON\r\nsisusb_console_init(sisusb, sisusb_first_vc, sisusb_last_vc);\r\n#endif\r\nreturn 0;\r\nerror_4:\r\nsisusb_free_urbs(sisusb);\r\nerror_3:\r\nsisusb_free_buffers(sisusb);\r\nerror_2:\r\nusb_deregister_dev(intf, &usb_sisusb_class);\r\nerror_1:\r\nkfree(sisusb);\r\nreturn retval;\r\n}\r\nstatic void sisusb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct sisusb_usb_data *sisusb;\r\nsisusb = usb_get_intfdata(intf);\r\nif (!sisusb)\r\nreturn;\r\n#ifdef INCL_SISUSB_CON\r\nsisusb_console_exit(sisusb);\r\n#endif\r\nusb_deregister_dev(intf, &usb_sisusb_class);\r\nmutex_lock(&sisusb->lock);\r\nif (!sisusb_wait_all_out_complete(sisusb))\r\nsisusb_kill_all_busy(sisusb);\r\nusb_set_intfdata(intf, NULL);\r\nsisusb->present = 0;\r\nsisusb->ready = 0;\r\nmutex_unlock(&sisusb->lock);\r\nkref_put(&sisusb->kref, sisusb_delete);\r\n}\r\nstatic int __init usb_sisusb_init(void)\r\n{\r\n#ifdef INCL_SISUSB_CON\r\nsisusb_init_concode();\r\n#endif\r\nreturn usb_register(&sisusb_driver);\r\n}\r\nstatic void __exit usb_sisusb_exit(void)\r\n{\r\nusb_deregister(&sisusb_driver);\r\n}
