static unsigned int tsi_serial_in(struct uart_port *p, int offset)\r\n{\r\nunsigned int tmp;\r\noffset = offset << p->regshift;\r\nif (offset == UART_IIR) {\r\ntmp = readl(p->membase + (UART_IIR & ~3));\r\nreturn (tmp >> 16) & 0xff;\r\n} else\r\nreturn readb(p->membase + offset);\r\n}\r\nstatic void tsi_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\noffset = offset << p->regshift;\r\nif (!((offset == UART_IER) && (value & UART_IER_UUE)))\r\nwriteb(value, p->membase + offset);\r\n}\r\nstatic int __init add_legacy_port(struct device_node *np, int want_index,\r\nint iotype, phys_addr_t base,\r\nphys_addr_t taddr, unsigned long irq,\r\nupf_t flags, int irq_check_parent)\r\n{\r\nconst __be32 *clk, *spd, *rs;\r\nu32 clock = BASE_BAUD * 16;\r\nu32 shift = 0;\r\nint index;\r\nclk = of_get_property(np, "clock-frequency", NULL);\r\nif (clk && *clk)\r\nclock = be32_to_cpup(clk);\r\nspd = of_get_property(np, "current-speed", NULL);\r\nrs = of_get_property(np, "reg-shift", NULL);\r\nif (rs && *rs)\r\nshift = be32_to_cpup(rs);\r\nif (want_index >= 0 && want_index < MAX_LEGACY_SERIAL_PORTS)\r\nindex = want_index;\r\nelse\r\nindex = legacy_serial_count;\r\nif (index >= MAX_LEGACY_SERIAL_PORTS)\r\nreturn -1;\r\nif (index >= legacy_serial_count)\r\nlegacy_serial_count = index + 1;\r\nif (legacy_serial_infos[index].np != NULL) {\r\nif (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {\r\nprintk(KERN_DEBUG "Moved legacy port %d -> %d\n",\r\nindex, legacy_serial_count);\r\nlegacy_serial_ports[legacy_serial_count] =\r\nlegacy_serial_ports[index];\r\nlegacy_serial_infos[legacy_serial_count] =\r\nlegacy_serial_infos[index];\r\nlegacy_serial_count++;\r\n} else {\r\nprintk(KERN_DEBUG "Replacing legacy port %d\n", index);\r\n}\r\n}\r\nmemset(&legacy_serial_ports[index], 0,\r\nsizeof(struct plat_serial8250_port));\r\nif (iotype == UPIO_PORT)\r\nlegacy_serial_ports[index].iobase = base;\r\nelse\r\nlegacy_serial_ports[index].mapbase = base;\r\nlegacy_serial_ports[index].iotype = iotype;\r\nlegacy_serial_ports[index].uartclk = clock;\r\nlegacy_serial_ports[index].irq = irq;\r\nlegacy_serial_ports[index].flags = flags;\r\nlegacy_serial_ports[index].regshift = shift;\r\nlegacy_serial_infos[index].taddr = taddr;\r\nlegacy_serial_infos[index].np = of_node_get(np);\r\nlegacy_serial_infos[index].clock = clock;\r\nlegacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;\r\nlegacy_serial_infos[index].irq_check_parent = irq_check_parent;\r\nif (iotype == UPIO_TSI) {\r\nlegacy_serial_ports[index].serial_in = tsi_serial_in;\r\nlegacy_serial_ports[index].serial_out = tsi_serial_out;\r\n}\r\nprintk(KERN_DEBUG "Found legacy serial port %d for %s\n",\r\nindex, np->full_name);\r\nprintk(KERN_DEBUG " %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\n",\r\n(iotype == UPIO_PORT) ? "port" : "mem",\r\n(unsigned long long)base, (unsigned long long)taddr, irq,\r\nlegacy_serial_ports[index].uartclk,\r\nlegacy_serial_infos[index].speed);\r\nreturn index;\r\n}\r\nstatic int __init add_legacy_soc_port(struct device_node *np,\r\nstruct device_node *soc_dev)\r\n{\r\nu64 addr;\r\nconst __be32 *addrp;\r\nstruct device_node *tsi = of_get_parent(np);\r\nif (of_get_property(np, "clock-frequency", NULL) == NULL)\r\nreturn -1;\r\nif ((of_get_property(np, "reg-offset", NULL) != NULL))\r\nreturn -1;\r\nif (of_get_property(np, "used-by-rtas", NULL) != NULL)\r\nreturn -1;\r\naddrp = of_get_address(soc_dev, 0, NULL, NULL);\r\nif (addrp == NULL)\r\nreturn -1;\r\naddr = of_translate_address(soc_dev, addrp);\r\nif (addr == OF_BAD_ADDR)\r\nreturn -1;\r\nif (tsi && !strcmp(tsi->type, "tsi-bridge"))\r\nreturn add_legacy_port(np, -1, UPIO_TSI, addr, addr,\r\n0, legacy_port_flags, 0);\r\nelse\r\nreturn add_legacy_port(np, -1, UPIO_MEM, addr, addr,\r\n0, legacy_port_flags, 0);\r\n}\r\nstatic int __init add_legacy_isa_port(struct device_node *np,\r\nstruct device_node *isa_brg)\r\n{\r\nconst __be32 *reg;\r\nconst char *typep;\r\nint index = -1;\r\nu64 taddr;\r\nDBG(" -> add_legacy_isa_port(%s)\n", np->full_name);\r\nreg = of_get_property(np, "reg", NULL);\r\nif (reg == NULL)\r\nreturn -1;\r\nif (!(be32_to_cpu(reg[0]) & 0x00000001))\r\nreturn -1;\r\ntypep = of_get_property(np, "ibm,aix-loc", NULL);\r\nif (typep && *typep == 'S')\r\nindex = simple_strtol(typep+1, NULL, 0) - 1;\r\nif (!of_device_is_compatible(isa_brg, "ibm,power8-lpc") ||\r\nof_get_property(isa_brg, "ranges", NULL)) {\r\ntaddr = of_translate_address(np, reg);\r\nif (taddr == OF_BAD_ADDR)\r\ntaddr = 0;\r\n} else\r\ntaddr = 0;\r\nreturn add_legacy_port(np, index, UPIO_PORT, be32_to_cpu(reg[1]),\r\ntaddr, 0, legacy_port_flags, 0);\r\n}\r\nstatic int __init add_legacy_pci_port(struct device_node *np,\r\nstruct device_node *pci_dev)\r\n{\r\nu64 addr, base;\r\nconst __be32 *addrp;\r\nunsigned int flags;\r\nint iotype, index = -1, lindex = 0;\r\nDBG(" -> add_legacy_pci_port(%s)\n", np->full_name);\r\nif (of_get_property(np, "clock-frequency", NULL) == NULL)\r\nreturn -1;\r\naddrp = of_get_pci_address(pci_dev, 0, NULL, &flags);\r\nif (addrp == NULL)\r\nreturn -1;\r\niotype = (flags & IORESOURCE_MEM) ? UPIO_MEM : UPIO_PORT;\r\naddr = of_translate_address(pci_dev, addrp);\r\nif (addr == OF_BAD_ADDR)\r\nreturn -1;\r\nif (iotype == UPIO_MEM)\r\nbase = addr;\r\nelse\r\nbase = of_read_number(&addrp[2], 1);\r\nif (np != pci_dev) {\r\nconst __be32 *reg = of_get_property(np, "reg", NULL);\r\nif (reg && (be32_to_cpup(reg) < 4))\r\nindex = lindex = be32_to_cpup(reg);\r\n}\r\nif (of_device_is_compatible(pci_dev, "pci13a8,152") ||\r\nof_device_is_compatible(pci_dev, "pci13a8,154") ||\r\nof_device_is_compatible(pci_dev, "pci13a8,158")) {\r\naddr += 0x200 * lindex;\r\nbase += 0x200 * lindex;\r\n} else {\r\naddr += 8 * lindex;\r\nbase += 8 * lindex;\r\n}\r\nreturn add_legacy_port(np, index, iotype, base, addr, 0,\r\nlegacy_port_flags, np != pci_dev);\r\n}\r\nstatic void __init setup_legacy_serial_console(int console)\r\n{\r\nstruct legacy_serial_info *info = &legacy_serial_infos[console];\r\nstruct plat_serial8250_port *port = &legacy_serial_ports[console];\r\nvoid __iomem *addr;\r\nunsigned int stride;\r\nstride = 1 << port->regshift;\r\nif (info->taddr) {\r\naddr = ioremap(info->taddr, 0x1000);\r\nif (addr == NULL)\r\nreturn;\r\nudbg_uart_init_mmio(addr, stride);\r\n} else {\r\nif (port->iotype == UPIO_PORT && isa_io_special)\r\nudbg_uart_init_pio(port->iobase, stride);\r\nelse\r\nreturn;\r\n}\r\nif (info->speed == 0)\r\ninfo->speed = udbg_probe_uart_speed(info->clock);\r\nDBG("default console speed = %d\n", info->speed);\r\nudbg_uart_setup(info->speed, info->clock);\r\n}\r\nvoid __init find_legacy_serial_ports(void)\r\n{\r\nstruct device_node *np, *stdout = NULL;\r\nconst char *path;\r\nint index;\r\nDBG(" -> find_legacy_serial_port()\n");\r\npath = of_get_property(of_chosen, "linux,stdout-path", NULL);\r\nif (path != NULL) {\r\nstdout = of_find_node_by_path(path);\r\nif (stdout)\r\nDBG("stdout is %s\n", stdout->full_name);\r\n} else {\r\nDBG(" no linux,stdout-path !\n");\r\n}\r\nfor_each_compatible_node(np, "serial", "ns16550") {\r\nstruct device_node *parent = of_get_parent(np);\r\nif (!parent)\r\ncontinue;\r\nif (of_match_node(legacy_serial_parents, parent) != NULL) {\r\nif (of_device_is_available(np)) {\r\nindex = add_legacy_soc_port(np, np);\r\nif (index >= 0 && np == stdout)\r\nlegacy_serial_console = index;\r\n}\r\n}\r\nof_node_put(parent);\r\n}\r\nfor_each_node_by_type(np, "serial") {\r\nstruct device_node *isa = of_get_parent(np);\r\nif (isa && (!strcmp(isa->name, "isa") ||\r\n!strcmp(isa->name, "lpc"))) {\r\nif (of_device_is_available(np)) {\r\nindex = add_legacy_isa_port(np, isa);\r\nif (index >= 0 && np == stdout)\r\nlegacy_serial_console = index;\r\n}\r\n}\r\nof_node_put(isa);\r\n}\r\n#ifdef CONFIG_PCI\r\nfor (np = NULL; (np = of_find_all_nodes(np));) {\r\nstruct device_node *pci, *parent = of_get_parent(np);\r\nif (parent && !strcmp(parent->name, "isa")) {\r\nof_node_put(parent);\r\ncontinue;\r\n}\r\nif (strcmp(np->name, "serial") && strcmp(np->type, "serial")) {\r\nof_node_put(parent);\r\ncontinue;\r\n}\r\nif (of_device_is_compatible(np, "pciclass,0700") ||\r\nof_device_is_compatible(np, "pciclass,070002"))\r\npci = np;\r\nelse if (of_device_is_compatible(parent, "pciclass,0700") ||\r\nof_device_is_compatible(parent, "pciclass,070002"))\r\npci = parent;\r\nelse {\r\nof_node_put(parent);\r\ncontinue;\r\n}\r\nindex = add_legacy_pci_port(np, pci);\r\nif (index >= 0 && np == stdout)\r\nlegacy_serial_console = index;\r\nof_node_put(parent);\r\n}\r\n#endif\r\nDBG("legacy_serial_console = %d\n", legacy_serial_console);\r\nif (legacy_serial_console >= 0)\r\nsetup_legacy_serial_console(legacy_serial_console);\r\nDBG(" <- find_legacy_serial_port()\n");\r\n}\r\nstatic void __init fixup_port_irq(int index,\r\nstruct device_node *np,\r\nstruct plat_serial8250_port *port)\r\n{\r\nunsigned int virq;\r\nDBG("fixup_port_irq(%d)\n", index);\r\nvirq = irq_of_parse_and_map(np, 0);\r\nif (!virq && legacy_serial_infos[index].irq_check_parent) {\r\nnp = of_get_parent(np);\r\nif (np == NULL)\r\nreturn;\r\nvirq = irq_of_parse_and_map(np, 0);\r\nof_node_put(np);\r\n}\r\nif (!virq)\r\nreturn;\r\nport->irq = virq;\r\n#ifdef CONFIG_SERIAL_8250_FSL\r\nif (of_device_is_compatible(np, "fsl,ns16550"))\r\nport->handle_irq = fsl8250_handle_irq;\r\n#endif\r\n}\r\nstatic void __init fixup_port_pio(int index,\r\nstruct device_node *np,\r\nstruct plat_serial8250_port *port)\r\n{\r\n#ifdef CONFIG_PCI\r\nstruct pci_controller *hose;\r\nDBG("fixup_port_pio(%d)\n", index);\r\nhose = pci_find_hose_for_OF_device(np);\r\nif (hose) {\r\nunsigned long offset = (unsigned long)hose->io_base_virt -\r\n#ifdef CONFIG_PPC64\r\npci_io_base;\r\n#else\r\nisa_io_base;\r\n#endif\r\nDBG("port %d, IO %lx -> %lx\n",\r\nindex, port->iobase, port->iobase + offset);\r\nport->iobase += offset;\r\n}\r\n#endif\r\n}\r\nstatic void __init fixup_port_mmio(int index,\r\nstruct device_node *np,\r\nstruct plat_serial8250_port *port)\r\n{\r\nDBG("fixup_port_mmio(%d)\n", index);\r\nport->membase = ioremap(port->mapbase, 0x100);\r\n}\r\nstatic int __init serial_dev_init(void)\r\n{\r\nint i;\r\nif (legacy_serial_count == 0)\r\nreturn -ENODEV;\r\nDBG("Fixing serial ports interrupts and IO ports ...\n");\r\nfor (i = 0; i < legacy_serial_count; i++) {\r\nstruct plat_serial8250_port *port = &legacy_serial_ports[i];\r\nstruct device_node *np = legacy_serial_infos[i].np;\r\nif (!port->irq)\r\nfixup_port_irq(i, np, port);\r\nif (port->iotype == UPIO_PORT)\r\nfixup_port_pio(i, np, port);\r\nif ((port->iotype == UPIO_MEM) || (port->iotype == UPIO_TSI))\r\nfixup_port_mmio(i, np, port);\r\n}\r\nDBG("Registering platform serial ports\n");\r\nreturn platform_device_register(&serial_device);\r\n}\r\nstatic int __init check_legacy_serial_console(void)\r\n{\r\nstruct device_node *prom_stdout = NULL;\r\nint i, speed = 0, offset = 0;\r\nconst char *name;\r\nconst __be32 *spd;\r\nDBG(" -> check_legacy_serial_console()\n");\r\nif (strstr(boot_command_line, "console=")) {\r\nDBG(" console was specified !\n");\r\nreturn -EBUSY;\r\n}\r\nif (!of_chosen) {\r\nDBG(" of_chosen is NULL !\n");\r\nreturn -ENODEV;\r\n}\r\nif (legacy_serial_console < 0) {\r\nDBG(" legacy_serial_console not found !\n");\r\nreturn -ENODEV;\r\n}\r\nname = of_get_property(of_chosen, "linux,stdout-path", NULL);\r\nif (name == NULL) {\r\nDBG(" no linux,stdout-path !\n");\r\nreturn -ENODEV;\r\n}\r\nprom_stdout = of_find_node_by_path(name);\r\nif (!prom_stdout) {\r\nDBG(" can't find stdout package %s !\n", name);\r\nreturn -ENODEV;\r\n}\r\nDBG("stdout is %s\n", prom_stdout->full_name);\r\nname = of_get_property(prom_stdout, "name", NULL);\r\nif (!name) {\r\nDBG(" stdout package has no name !\n");\r\ngoto not_found;\r\n}\r\nspd = of_get_property(prom_stdout, "current-speed", NULL);\r\nif (spd)\r\nspeed = be32_to_cpup(spd);\r\nif (strcmp(name, "serial") != 0)\r\ngoto not_found;\r\nfor (i = 0; i < legacy_serial_count; i++) {\r\nif (prom_stdout != legacy_serial_infos[i].np)\r\ncontinue;\r\noffset = i;\r\nspeed = legacy_serial_infos[i].speed;\r\nbreak;\r\n}\r\nif (i >= legacy_serial_count)\r\ngoto not_found;\r\nof_node_put(prom_stdout);\r\nDBG("Found serial console at ttyS%d\n", offset);\r\nif (speed) {\r\nstatic char __initdata opt[16];\r\nsprintf(opt, "%d", speed);\r\nreturn add_preferred_console("ttyS", offset, opt);\r\n} else\r\nreturn add_preferred_console("ttyS", offset, NULL);\r\nnot_found:\r\nDBG("No preferred console found !\n");\r\nof_node_put(prom_stdout);\r\nreturn -ENODEV;\r\n}
