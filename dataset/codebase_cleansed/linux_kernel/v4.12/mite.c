static unsigned int MITE_IODWBSR_1_WSIZE_bits(unsigned int size)\r\n{\r\nreturn (ilog2(size) - 1) & 0x1f;\r\n}\r\nstatic unsigned int mite_retry_limit(unsigned int retry_limit)\r\n{\r\nunsigned int value = 0;\r\nif (retry_limit)\r\nvalue = 1 + ilog2(retry_limit);\r\nif (value > 0x7)\r\nvalue = 0x7;\r\nreturn CR_RL(value);\r\n}\r\nstatic unsigned int mite_drq_reqs(unsigned int drq_line)\r\n{\r\nreturn CR_REQS((drq_line & 0x3) | 0x4);\r\n}\r\nstatic unsigned int mite_fifo_size(struct mite *mite, unsigned int channel)\r\n{\r\nunsigned int fcr_bits = readl(mite->mmio + MITE_FCR(channel));\r\nunsigned int empty_count = (fcr_bits >> 16) & 0xff;\r\nunsigned int full_count = fcr_bits & 0xff;\r\nreturn empty_count + full_count;\r\n}\r\nstatic u32 mite_device_bytes_transferred(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nreturn readl(mite->mmio + MITE_DAR(mite_chan->channel));\r\n}\r\nu32 mite_bytes_in_transit(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nreturn readl(mite->mmio + MITE_FCR(mite_chan->channel)) & 0xff;\r\n}\r\nstatic u32 mite_bytes_written_to_memory_lb(struct mite_channel *mite_chan)\r\n{\r\nu32 device_byte_count;\r\ndevice_byte_count = mite_device_bytes_transferred(mite_chan);\r\nreturn device_byte_count - mite_bytes_in_transit(mite_chan);\r\n}\r\nstatic u32 mite_bytes_written_to_memory_ub(struct mite_channel *mite_chan)\r\n{\r\nu32 in_transit_count;\r\nin_transit_count = mite_bytes_in_transit(mite_chan);\r\nreturn mite_device_bytes_transferred(mite_chan) - in_transit_count;\r\n}\r\nstatic u32 mite_bytes_read_from_memory_lb(struct mite_channel *mite_chan)\r\n{\r\nu32 device_byte_count;\r\ndevice_byte_count = mite_device_bytes_transferred(mite_chan);\r\nreturn device_byte_count + mite_bytes_in_transit(mite_chan);\r\n}\r\nstatic u32 mite_bytes_read_from_memory_ub(struct mite_channel *mite_chan)\r\n{\r\nu32 in_transit_count;\r\nin_transit_count = mite_bytes_in_transit(mite_chan);\r\nreturn mite_device_bytes_transferred(mite_chan) + in_transit_count;\r\n}\r\nstatic void mite_sync_input_dma(struct mite_channel *mite_chan,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nint count;\r\nunsigned int nbytes, old_alloc_count;\r\nold_alloc_count = async->buf_write_alloc_count;\r\ncomedi_buf_write_alloc(s, async->prealloc_bufsz);\r\nnbytes = mite_bytes_written_to_memory_lb(mite_chan);\r\nif ((int)(mite_bytes_written_to_memory_ub(mite_chan) -\r\nold_alloc_count) > 0) {\r\ndev_warn(s->device->class_dev,\r\n"mite: DMA overwrite of free area\n");\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\ncount = nbytes - async->buf_write_count;\r\nif (count > 0) {\r\ncomedi_buf_write_free(s, count);\r\ncomedi_inc_scan_progress(s, count);\r\nasync->events |= COMEDI_CB_BLOCK;\r\n}\r\n}\r\nstatic void mite_sync_output_dma(struct mite_channel *mite_chan,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct comedi_cmd *cmd = &async->cmd;\r\nu32 stop_count = cmd->stop_arg * comedi_bytes_per_scan(s);\r\nunsigned int old_alloc_count = async->buf_read_alloc_count;\r\nu32 nbytes_ub, nbytes_lb;\r\nint count;\r\nbool finite_regen = (cmd->stop_src == TRIG_NONE && stop_count != 0);\r\ncomedi_buf_read_alloc(s, async->prealloc_bufsz);\r\nnbytes_lb = mite_bytes_read_from_memory_lb(mite_chan);\r\nif (cmd->stop_src == TRIG_COUNT && (int)(nbytes_lb - stop_count) > 0)\r\nnbytes_lb = stop_count;\r\nnbytes_ub = mite_bytes_read_from_memory_ub(mite_chan);\r\nif (cmd->stop_src == TRIG_COUNT && (int)(nbytes_ub - stop_count) > 0)\r\nnbytes_ub = stop_count;\r\nif ((!finite_regen || stop_count > old_alloc_count) &&\r\n((int)(nbytes_ub - old_alloc_count) > 0)) {\r\ndev_warn(s->device->class_dev, "mite: DMA underrun\n");\r\nasync->events |= COMEDI_CB_OVERFLOW;\r\nreturn;\r\n}\r\nif (finite_regen) {\r\nreturn;\r\n}\r\ncount = nbytes_lb - async->buf_read_count;\r\nif (count > 0) {\r\ncomedi_buf_read_free(s, count);\r\nasync->events |= COMEDI_CB_BLOCK;\r\n}\r\n}\r\nvoid mite_sync_dma(struct mite_channel *mite_chan, struct comedi_subdevice *s)\r\n{\r\nif (mite_chan->dir == COMEDI_INPUT)\r\nmite_sync_input_dma(mite_chan, s);\r\nelse\r\nmite_sync_output_dma(mite_chan, s);\r\n}\r\nstatic unsigned int mite_get_status(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nunsigned int status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nstatus = readl(mite->mmio + MITE_CHSR(mite_chan->channel));\r\nif (status & CHSR_DONE) {\r\nmite_chan->done = 1;\r\nwritel(CHOR_CLRDONE,\r\nmite->mmio + MITE_CHOR(mite_chan->channel));\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\nreturn status;\r\n}\r\nvoid mite_ack_linkc(struct mite_channel *mite_chan,\r\nstruct comedi_subdevice *s,\r\nbool sync)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nunsigned int status;\r\nstatus = mite_get_status(mite_chan);\r\nif (status & CHSR_LINKC) {\r\nwritel(CHOR_CLRLC, mite->mmio + MITE_CHOR(mite_chan->channel));\r\nsync = true;\r\n}\r\nif (sync)\r\nmite_sync_dma(mite_chan, s);\r\nif (status & CHSR_XFERR) {\r\ndev_err(s->device->class_dev,\r\n"mite: transfer error %08x\n", status);\r\ns->async->events |= COMEDI_CB_ERROR;\r\n}\r\n}\r\nint mite_done(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nunsigned long flags;\r\nint done;\r\nmite_get_status(mite_chan);\r\nspin_lock_irqsave(&mite->lock, flags);\r\ndone = mite_chan->done;\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\nreturn done;\r\n}\r\nstatic void mite_dma_reset(struct mite_channel *mite_chan)\r\n{\r\nwritel(CHOR_DMARESET | CHOR_FRESET,\r\nmite_chan->mite->mmio + MITE_CHOR(mite_chan->channel));\r\n}\r\nvoid mite_dma_arm(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nunsigned long flags;\r\nsmp_mb();\r\nspin_lock_irqsave(&mite->lock, flags);\r\nmite_chan->done = 0;\r\nwritel(CHOR_START, mite->mmio + MITE_CHOR(mite_chan->channel));\r\nmmiowb();\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\n}\r\nvoid mite_dma_disarm(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nwritel(CHOR_ABORT, mite->mmio + MITE_CHOR(mite_chan->channel));\r\n}\r\nvoid mite_prep_dma(struct mite_channel *mite_chan,\r\nunsigned int num_device_bits, unsigned int num_memory_bits)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nunsigned int chcr, mcr, dcr, lkcr;\r\nmite_dma_reset(mite_chan);\r\nchcr = CHCR_SET_DMA_IE | CHCR_LINKSHORT | CHCR_SET_DONE_IE |\r\nCHCR_BURSTEN;\r\nchcr |= CHCR_SET_LC_IE;\r\nif (num_memory_bits == 32 && num_device_bits == 16) {\r\nchcr |= CHCR_BYTE_SWAP_DEVICE | CHCR_BYTE_SWAP_MEMORY;\r\n}\r\nif (mite_chan->dir == COMEDI_INPUT)\r\nchcr |= CHCR_DEV_TO_MEM;\r\nwritel(chcr, mite->mmio + MITE_CHCR(mite_chan->channel));\r\nmcr = mite_retry_limit(64) | CR_ASEQUP;\r\nswitch (num_memory_bits) {\r\ncase 8:\r\nmcr |= CR_PSIZE8;\r\nbreak;\r\ncase 16:\r\nmcr |= CR_PSIZE16;\r\nbreak;\r\ncase 32:\r\nmcr |= CR_PSIZE32;\r\nbreak;\r\ndefault:\r\npr_warn("bug! invalid mem bit width for dma transfer\n");\r\nbreak;\r\n}\r\nwritel(mcr, mite->mmio + MITE_MCR(mite_chan->channel));\r\ndcr = mite_retry_limit(64) | CR_ASEQUP;\r\ndcr |= CR_PORTIO | CR_AMDEVICE | mite_drq_reqs(mite_chan->channel);\r\nswitch (num_device_bits) {\r\ncase 8:\r\ndcr |= CR_PSIZE8;\r\nbreak;\r\ncase 16:\r\ndcr |= CR_PSIZE16;\r\nbreak;\r\ncase 32:\r\ndcr |= CR_PSIZE32;\r\nbreak;\r\ndefault:\r\npr_warn("bug! invalid dev bit width for dma transfer\n");\r\nbreak;\r\n}\r\nwritel(dcr, mite->mmio + MITE_DCR(mite_chan->channel));\r\nwritel(0, mite->mmio + MITE_DAR(mite_chan->channel));\r\nlkcr = mite_retry_limit(64) | CR_ASEQUP | CR_PSIZE32;\r\nwritel(lkcr, mite->mmio + MITE_LKCR(mite_chan->channel));\r\nwritel(mite_chan->ring->dma_addr,\r\nmite->mmio + MITE_LKAR(mite_chan->channel));\r\n}\r\nstatic struct mite_channel *__mite_request_channel(struct mite *mite,\r\nstruct mite_ring *ring,\r\nunsigned int min_channel,\r\nunsigned int max_channel)\r\n{\r\nstruct mite_channel *mite_chan = NULL;\r\nunsigned long flags;\r\nint i;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nfor (i = min_channel; i <= max_channel; ++i) {\r\nmite_chan = &mite->channels[i];\r\nif (!mite_chan->ring) {\r\nmite_chan->ring = ring;\r\nbreak;\r\n}\r\nmite_chan = NULL;\r\n}\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\nreturn mite_chan;\r\n}\r\nstruct mite_channel *mite_request_channel_in_range(struct mite *mite,\r\nstruct mite_ring *ring,\r\nunsigned int min_channel,\r\nunsigned int max_channel)\r\n{\r\nreturn __mite_request_channel(mite, ring, min_channel, max_channel);\r\n}\r\nstruct mite_channel *mite_request_channel(struct mite *mite,\r\nstruct mite_ring *ring)\r\n{\r\nreturn __mite_request_channel(mite, ring, 0, mite->num_channels - 1);\r\n}\r\nvoid mite_release_channel(struct mite_channel *mite_chan)\r\n{\r\nstruct mite *mite = mite_chan->mite;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mite->lock, flags);\r\nif (mite_chan->ring) {\r\nmite_dma_disarm(mite_chan);\r\nmite_dma_reset(mite_chan);\r\nwritel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE |\r\nCHCR_CLR_SAR_IE | CHCR_CLR_DONE_IE |\r\nCHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |\r\nCHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,\r\nmite->mmio + MITE_CHCR(mite_chan->channel));\r\nmite_chan->ring = NULL;\r\nmmiowb();\r\n}\r\nspin_unlock_irqrestore(&mite->lock, flags);\r\n}\r\nint mite_init_ring_descriptors(struct mite_ring *ring,\r\nstruct comedi_subdevice *s,\r\nunsigned int nbytes)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct mite_dma_desc *desc = NULL;\r\nunsigned int n_full_links = nbytes >> PAGE_SHIFT;\r\nunsigned int remainder = nbytes % PAGE_SIZE;\r\nint i;\r\ndev_dbg(s->device->class_dev,\r\n"mite: init ring buffer to %u bytes\n", nbytes);\r\nif ((n_full_links + (remainder > 0 ? 1 : 0)) > ring->n_links) {\r\ndev_err(s->device->class_dev,\r\n"mite: ring buffer too small for requested init\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < n_full_links; ++i) {\r\ndesc = &ring->descs[i];\r\ndesc->count = cpu_to_le32(PAGE_SIZE);\r\ndesc->addr = cpu_to_le32(async->buf_map->page_list[i].dma_addr);\r\ndesc->next = cpu_to_le32(ring->dma_addr +\r\n(i + 1) * sizeof(*desc));\r\n}\r\nif (remainder > 0) {\r\ndesc = &ring->descs[i];\r\ndesc->count = cpu_to_le32(remainder);\r\ndesc->addr = cpu_to_le32(async->buf_map->page_list[i].dma_addr);\r\n}\r\ndesc->next = cpu_to_le32(ring->dma_addr);\r\nsmp_wmb();\r\nreturn 0;\r\n}\r\nstatic void mite_free_dma_descs(struct mite_ring *ring)\r\n{\r\nstruct mite_dma_desc *descs = ring->descs;\r\nif (descs) {\r\ndma_free_coherent(ring->hw_dev,\r\nring->n_links * sizeof(*descs),\r\ndescs, ring->dma_addr);\r\nring->descs = NULL;\r\nring->dma_addr = 0;\r\nring->n_links = 0;\r\n}\r\n}\r\nint mite_buf_change(struct mite_ring *ring, struct comedi_subdevice *s)\r\n{\r\nstruct comedi_async *async = s->async;\r\nstruct mite_dma_desc *descs;\r\nunsigned int n_links;\r\nmite_free_dma_descs(ring);\r\nif (async->prealloc_bufsz == 0)\r\nreturn 0;\r\nn_links = async->prealloc_bufsz >> PAGE_SHIFT;\r\ndescs = dma_alloc_coherent(ring->hw_dev,\r\nn_links * sizeof(*descs),\r\n&ring->dma_addr, GFP_KERNEL);\r\nif (!descs) {\r\ndev_err(s->device->class_dev,\r\n"mite: ring buffer allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nring->descs = descs;\r\nring->n_links = n_links;\r\nreturn mite_init_ring_descriptors(ring, s, n_links << PAGE_SHIFT);\r\n}\r\nstruct mite_ring *mite_alloc_ring(struct mite *mite)\r\n{\r\nstruct mite_ring *ring;\r\nring = kmalloc(sizeof(*ring), GFP_KERNEL);\r\nif (!ring)\r\nreturn NULL;\r\nring->hw_dev = get_device(&mite->pcidev->dev);\r\nif (!ring->hw_dev) {\r\nkfree(ring);\r\nreturn NULL;\r\n}\r\nring->n_links = 0;\r\nring->descs = NULL;\r\nring->dma_addr = 0;\r\nreturn ring;\r\n}\r\nvoid mite_free_ring(struct mite_ring *ring)\r\n{\r\nif (ring) {\r\nmite_free_dma_descs(ring);\r\nput_device(ring->hw_dev);\r\nkfree(ring);\r\n}\r\n}\r\nstatic int mite_setup(struct comedi_device *dev, struct mite *mite,\r\nbool use_win1)\r\n{\r\nresource_size_t daq_phys_addr;\r\nunsigned long length;\r\nint i;\r\nu32 csigr_bits;\r\nunsigned int unknown_dma_burst_bits;\r\nunsigned int wpdep;\r\npci_set_master(mite->pcidev);\r\nmite->mmio = pci_ioremap_bar(mite->pcidev, 0);\r\nif (!mite->mmio)\r\nreturn -ENOMEM;\r\ndev->mmio = pci_ioremap_bar(mite->pcidev, 1);\r\nif (!dev->mmio)\r\nreturn -ENOMEM;\r\ndaq_phys_addr = pci_resource_start(mite->pcidev, 1);\r\nlength = pci_resource_len(mite->pcidev, 1);\r\nif (use_win1) {\r\nwritel(0, mite->mmio + MITE_IODWBSR);\r\ndev_dbg(dev->class_dev,\r\n"mite: using I/O Window Base Size register 1\n");\r\nwritel(daq_phys_addr | WENAB |\r\nMITE_IODWBSR_1_WSIZE_bits(length),\r\nmite->mmio + MITE_IODWBSR_1);\r\nwritel(0, mite->mmio + MITE_IODWCR_1);\r\n} else {\r\nwritel(daq_phys_addr | WENAB, mite->mmio + MITE_IODWBSR);\r\n}\r\nunknown_dma_burst_bits = readl(mite->mmio + MITE_UNKNOWN_DMA_BURST_REG);\r\nunknown_dma_burst_bits |= UNKNOWN_DMA_BURST_ENABLE_BITS;\r\nwritel(unknown_dma_burst_bits, mite->mmio + MITE_UNKNOWN_DMA_BURST_REG);\r\ncsigr_bits = readl(mite->mmio + MITE_CSIGR);\r\nmite->num_channels = CSIGR_TO_DMAC(csigr_bits);\r\nif (mite->num_channels > MAX_MITE_DMA_CHANNELS) {\r\ndev_warn(dev->class_dev,\r\n"mite: bug? chip claims to have %i dma channels. Setting to %i.\n",\r\nmite->num_channels, MAX_MITE_DMA_CHANNELS);\r\nmite->num_channels = MAX_MITE_DMA_CHANNELS;\r\n}\r\nwpdep = CSIGR_TO_WPDEP(csigr_bits);\r\nif (wpdep)\r\nwpdep = BIT(wpdep);\r\ndev_dbg(dev->class_dev,\r\n"mite: version = %i, type = %i, mite mode = %i, interface mode = %i\n",\r\nCSIGR_TO_VER(csigr_bits), CSIGR_TO_TYPE(csigr_bits),\r\nCSIGR_TO_MMODE(csigr_bits), CSIGR_TO_IMODE(csigr_bits));\r\ndev_dbg(dev->class_dev,\r\n"mite: num channels = %i, write post fifo depth = %i, wins = %i, iowins = %i\n",\r\nCSIGR_TO_DMAC(csigr_bits), wpdep,\r\nCSIGR_TO_WINS(csigr_bits), CSIGR_TO_IOWINS(csigr_bits));\r\nfor (i = 0; i < mite->num_channels; i++) {\r\nwritel(CHOR_DMARESET, mite->mmio + MITE_CHOR(i));\r\nwritel(CHCR_CLR_DMA_IE | CHCR_CLR_LINKP_IE | CHCR_CLR_SAR_IE |\r\nCHCR_CLR_DONE_IE | CHCR_CLR_MRDY_IE | CHCR_CLR_DRDY_IE |\r\nCHCR_CLR_LC_IE | CHCR_CLR_CONT_RB_IE,\r\nmite->mmio + MITE_CHCR(i));\r\n}\r\nmite->fifo_size = mite_fifo_size(mite, 0);\r\ndev_dbg(dev->class_dev, "mite: fifo size is %i.\n", mite->fifo_size);\r\nreturn 0;\r\n}\r\nstruct mite *mite_attach(struct comedi_device *dev, bool use_win1)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct mite *mite;\r\nunsigned int i;\r\nint ret;\r\nmite = kzalloc(sizeof(*mite), GFP_KERNEL);\r\nif (!mite)\r\nreturn NULL;\r\nspin_lock_init(&mite->lock);\r\nmite->pcidev = pcidev;\r\nfor (i = 0; i < MAX_MITE_DMA_CHANNELS; ++i) {\r\nmite->channels[i].mite = mite;\r\nmite->channels[i].channel = i;\r\nmite->channels[i].done = 1;\r\n}\r\nret = mite_setup(dev, mite, use_win1);\r\nif (ret) {\r\nif (mite->mmio)\r\niounmap(mite->mmio);\r\nkfree(mite);\r\nreturn NULL;\r\n}\r\nreturn mite;\r\n}\r\nvoid mite_detach(struct mite *mite)\r\n{\r\nif (!mite)\r\nreturn;\r\nif (mite->mmio)\r\niounmap(mite->mmio);\r\nkfree(mite);\r\n}\r\nstatic int __init mite_module_init(void)\r\n{\r\nreturn 0;\r\n}\r\nstatic void __exit mite_module_exit(void)\r\n{\r\n}
