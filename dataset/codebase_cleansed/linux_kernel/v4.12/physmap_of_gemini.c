int of_flash_probe_gemini(struct platform_device *pdev,\r\nstruct device_node *np,\r\nstruct map_info *map)\r\n{\r\nstatic struct regmap *rmap;\r\nstruct device *dev = &pdev->dev;\r\nu32 val;\r\nint ret;\r\nif (!of_device_is_compatible(np, "cortina,gemini-flash"))\r\nreturn 0;\r\nrmap = syscon_regmap_lookup_by_phandle(np, "syscon");\r\nif (IS_ERR(rmap)) {\r\ndev_err(dev, "no syscon\n");\r\nreturn PTR_ERR(rmap);\r\n}\r\nret = regmap_read(rmap, GLOBAL_STATUS, &val);\r\nif (ret) {\r\ndev_err(dev, "failed to read global status register\n");\r\nreturn -ENODEV;\r\n}\r\ndev_dbg(dev, "global status reg: %08x\n", val);\r\nif ((val & FLASH_TYPE_MASK) != FLASH_TYPE_PARALLEL) {\r\ndev_err(dev, "flash is not parallel\n");\r\nreturn -ENODEV;\r\n}\r\nif (val & FLASH_WIDTH_16BIT) {\r\nif (map->bankwidth != 2)\r\ndev_warn(dev, "flash hardware say flash is 16 bit wide but DT says it is %d bits wide\n",\r\nmap->bankwidth * 8);\r\n} else {\r\nif (map->bankwidth != 1)\r\ndev_warn(dev, "flash hardware say flash is 8 bit wide but DT says it is %d bits wide\n",\r\nmap->bankwidth * 8);\r\n}\r\nret = regmap_update_bits(rmap, GLOBAL_MISC_CTRL,\r\nFLASH_PADS_MASK,\r\nSFLASH_PADS_DISABLE | NAND_PADS_DISABLE);\r\nif (ret) {\r\ndev_err(dev, "unable to set up physmap pads\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(&pdev->dev, "initialized Gemini-specific physmap control\n");\r\nreturn 0;\r\n}
