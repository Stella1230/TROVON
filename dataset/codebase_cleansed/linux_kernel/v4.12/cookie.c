void fscache_cookie_init_once(void *_cookie)\r\n{\r\nstruct fscache_cookie *cookie = _cookie;\r\nmemset(cookie, 0, sizeof(*cookie));\r\nspin_lock_init(&cookie->lock);\r\nspin_lock_init(&cookie->stores_lock);\r\nINIT_HLIST_HEAD(&cookie->backing_objects);\r\n}\r\nstruct fscache_cookie *__fscache_acquire_cookie(\r\nstruct fscache_cookie *parent,\r\nconst struct fscache_cookie_def *def,\r\nvoid *netfs_data,\r\nbool enable)\r\n{\r\nstruct fscache_cookie *cookie;\r\nBUG_ON(!def);\r\n_enter("{%s},{%s},%p,%u",\r\nparent ? (char *) parent->def->name : "<no-parent>",\r\ndef->name, netfs_data, enable);\r\nfscache_stat(&fscache_n_acquires);\r\nif (!parent) {\r\nfscache_stat(&fscache_n_acquires_null);\r\n_leave(" [no parent]");\r\nreturn NULL;\r\n}\r\nBUG_ON(!def->get_key);\r\nBUG_ON(!def->name[0]);\r\nBUG_ON(def->type == FSCACHE_COOKIE_TYPE_INDEX &&\r\nparent->def->type != FSCACHE_COOKIE_TYPE_INDEX);\r\ncookie = kmem_cache_alloc(fscache_cookie_jar, GFP_KERNEL);\r\nif (!cookie) {\r\nfscache_stat(&fscache_n_acquires_oom);\r\n_leave(" [ENOMEM]");\r\nreturn NULL;\r\n}\r\natomic_set(&cookie->usage, 1);\r\natomic_set(&cookie->n_children, 0);\r\natomic_set(&cookie->n_active, 1);\r\natomic_inc(&parent->usage);\r\natomic_inc(&parent->n_children);\r\ncookie->def = def;\r\ncookie->parent = parent;\r\ncookie->netfs_data = netfs_data;\r\ncookie->flags = (1 << FSCACHE_COOKIE_NO_DATA_YET);\r\nINIT_RADIX_TREE(&cookie->stores, GFP_NOFS & ~__GFP_DIRECT_RECLAIM);\r\nswitch (cookie->def->type) {\r\ncase FSCACHE_COOKIE_TYPE_INDEX:\r\nfscache_stat(&fscache_n_cookie_index);\r\nbreak;\r\ncase FSCACHE_COOKIE_TYPE_DATAFILE:\r\nfscache_stat(&fscache_n_cookie_data);\r\nbreak;\r\ndefault:\r\nfscache_stat(&fscache_n_cookie_special);\r\nbreak;\r\n}\r\nif (enable) {\r\nif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\r\nif (fscache_acquire_non_index_cookie(cookie) == 0) {\r\nset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\r\n} else {\r\natomic_dec(&parent->n_children);\r\n__fscache_cookie_put(cookie);\r\nfscache_stat(&fscache_n_acquires_nobufs);\r\n_leave(" = NULL");\r\nreturn NULL;\r\n}\r\n} else {\r\nset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\r\n}\r\n}\r\nfscache_stat(&fscache_n_acquires_ok);\r\n_leave(" = %p", cookie);\r\nreturn cookie;\r\n}\r\nvoid __fscache_enable_cookie(struct fscache_cookie *cookie,\r\nbool (*can_enable)(void *data),\r\nvoid *data)\r\n{\r\n_enter("%p", cookie);\r\nwait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\r\nTASK_UNINTERRUPTIBLE);\r\nif (test_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\r\ngoto out_unlock;\r\nif (can_enable && !can_enable(data)) {\r\n} else if (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX) {\r\n__fscache_wait_on_invalidate(cookie);\r\nif (fscache_acquire_non_index_cookie(cookie) == 0)\r\nset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\r\n} else {\r\nset_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags);\r\n}\r\nout_unlock:\r\nclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\r\n}\r\nstatic int fscache_acquire_non_index_cookie(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\nstruct fscache_cache *cache;\r\nuint64_t i_size;\r\nint ret;\r\n_enter("");\r\nset_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags);\r\ndown_read(&fscache_addremove_sem);\r\nif (list_empty(&fscache_cache_list)) {\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = 0 [no caches]");\r\nreturn 0;\r\n}\r\ncache = fscache_select_cache_for_object(cookie->parent);\r\nif (!cache) {\r\nup_read(&fscache_addremove_sem);\r\nfscache_stat(&fscache_n_acquires_no_cache);\r\n_leave(" = -ENOMEDIUM [no cache]");\r\nreturn -ENOMEDIUM;\r\n}\r\n_debug("cache %s", cache->tag->name);\r\nset_bit(FSCACHE_COOKIE_LOOKING_UP, &cookie->flags);\r\nret = fscache_alloc_object(cache, cookie);\r\nif (ret < 0) {\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\ncookie->def->get_attr(cookie->netfs_data, &i_size);\r\nspin_lock(&cookie->lock);\r\nif (hlist_empty(&cookie->backing_objects)) {\r\nspin_unlock(&cookie->lock);\r\ngoto unavailable;\r\n}\r\nobject = hlist_entry(cookie->backing_objects.first,\r\nstruct fscache_object, cookie_link);\r\nfscache_set_store_limit(object, i_size);\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_NEW_CHILD);\r\nspin_unlock(&cookie->lock);\r\nif (!fscache_defer_lookup) {\r\n_debug("non-deferred lookup %p", &cookie->flags);\r\nwait_on_bit(&cookie->flags, FSCACHE_COOKIE_LOOKING_UP,\r\nTASK_UNINTERRUPTIBLE);\r\n_debug("complete");\r\nif (test_bit(FSCACHE_COOKIE_UNAVAILABLE, &cookie->flags))\r\ngoto unavailable;\r\n}\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = 0 [deferred]");\r\nreturn 0;\r\nunavailable:\r\nup_read(&fscache_addremove_sem);\r\n_leave(" = -ENOBUFS");\r\nreturn -ENOBUFS;\r\n}\r\nstatic int fscache_alloc_object(struct fscache_cache *cache,\r\nstruct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\nint ret;\r\n_enter("%p,%p{%s}", cache, cookie, cookie->def->name);\r\nspin_lock(&cookie->lock);\r\nhlist_for_each_entry(object, &cookie->backing_objects,\r\ncookie_link) {\r\nif (object->cache == cache)\r\ngoto object_already_extant;\r\n}\r\nspin_unlock(&cookie->lock);\r\nfscache_stat(&fscache_n_cop_alloc_object);\r\nobject = cache->ops->alloc_object(cache, cookie);\r\nfscache_stat_d(&fscache_n_cop_alloc_object);\r\nif (IS_ERR(object)) {\r\nfscache_stat(&fscache_n_object_no_alloc);\r\nret = PTR_ERR(object);\r\ngoto error;\r\n}\r\nfscache_stat(&fscache_n_object_alloc);\r\nobject->debug_id = atomic_inc_return(&fscache_object_debug_id);\r\n_debug("ALLOC OBJ%x: %s {%lx}",\r\nobject->debug_id, cookie->def->name, object->events);\r\nret = fscache_alloc_object(cache, cookie->parent);\r\nif (ret < 0)\r\ngoto error_put;\r\nif (fscache_attach_object(cookie, object) < 0) {\r\nfscache_stat(&fscache_n_cop_put_object);\r\ncache->ops->put_object(object);\r\nfscache_stat_d(&fscache_n_cop_put_object);\r\n}\r\n_leave(" = 0");\r\nreturn 0;\r\nobject_already_extant:\r\nret = -ENOBUFS;\r\nif (fscache_object_is_dying(object) ||\r\nfscache_cache_is_broken(object)) {\r\nspin_unlock(&cookie->lock);\r\ngoto error;\r\n}\r\nspin_unlock(&cookie->lock);\r\n_leave(" = 0 [found]");\r\nreturn 0;\r\nerror_put:\r\nfscache_stat(&fscache_n_cop_put_object);\r\ncache->ops->put_object(object);\r\nfscache_stat_d(&fscache_n_cop_put_object);\r\nerror:\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nstatic int fscache_attach_object(struct fscache_cookie *cookie,\r\nstruct fscache_object *object)\r\n{\r\nstruct fscache_object *p;\r\nstruct fscache_cache *cache = object->cache;\r\nint ret;\r\n_enter("{%s},{OBJ%x}", cookie->def->name, object->debug_id);\r\nspin_lock(&cookie->lock);\r\nret = -EEXIST;\r\nhlist_for_each_entry(p, &cookie->backing_objects, cookie_link) {\r\nif (p->cache == object->cache) {\r\nif (fscache_object_is_dying(p))\r\nret = -ENOBUFS;\r\ngoto cant_attach_object;\r\n}\r\n}\r\nspin_lock_nested(&cookie->parent->lock, 1);\r\nhlist_for_each_entry(p, &cookie->parent->backing_objects,\r\ncookie_link) {\r\nif (p->cache == object->cache) {\r\nif (fscache_object_is_dying(p)) {\r\nret = -ENOBUFS;\r\nspin_unlock(&cookie->parent->lock);\r\ngoto cant_attach_object;\r\n}\r\nobject->parent = p;\r\nspin_lock(&p->lock);\r\np->n_children++;\r\nspin_unlock(&p->lock);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&cookie->parent->lock);\r\nif (list_empty(&object->cache_link)) {\r\nspin_lock(&cache->object_list_lock);\r\nlist_add(&object->cache_link, &cache->object_list);\r\nspin_unlock(&cache->object_list_lock);\r\n}\r\nobject->cookie = cookie;\r\natomic_inc(&cookie->usage);\r\nhlist_add_head(&object->cookie_link, &cookie->backing_objects);\r\nfscache_objlist_add(object);\r\nret = 0;\r\ncant_attach_object:\r\nspin_unlock(&cookie->lock);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\n}\r\nvoid __fscache_invalidate(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\n_enter("{%s}", cookie->def->name);\r\nfscache_stat(&fscache_n_invalidates);\r\nASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\r\nBUG_ON(!cookie->def->get_aux);\r\nif (!hlist_empty(&cookie->backing_objects)) {\r\nspin_lock(&cookie->lock);\r\nif (fscache_cookie_enabled(cookie) &&\r\n!hlist_empty(&cookie->backing_objects) &&\r\n!test_and_set_bit(FSCACHE_COOKIE_INVALIDATING,\r\n&cookie->flags)) {\r\nobject = hlist_entry(cookie->backing_objects.first,\r\nstruct fscache_object,\r\ncookie_link);\r\nif (fscache_object_is_live(object))\r\nfscache_raise_event(\r\nobject, FSCACHE_OBJECT_EV_INVALIDATE);\r\n}\r\nspin_unlock(&cookie->lock);\r\n}\r\n_leave("");\r\n}\r\nvoid __fscache_wait_on_invalidate(struct fscache_cookie *cookie)\r\n{\r\n_enter("%p", cookie);\r\nwait_on_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING,\r\nTASK_UNINTERRUPTIBLE);\r\n_leave("");\r\n}\r\nvoid __fscache_update_cookie(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_object *object;\r\nfscache_stat(&fscache_n_updates);\r\nif (!cookie) {\r\nfscache_stat(&fscache_n_updates_null);\r\n_leave(" [no cookie]");\r\nreturn;\r\n}\r\n_enter("{%s}", cookie->def->name);\r\nBUG_ON(!cookie->def->get_aux);\r\nspin_lock(&cookie->lock);\r\nif (fscache_cookie_enabled(cookie)) {\r\nhlist_for_each_entry(object,\r\n&cookie->backing_objects, cookie_link) {\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_UPDATE);\r\n}\r\n}\r\nspin_unlock(&cookie->lock);\r\n_leave("");\r\n}\r\nvoid __fscache_disable_cookie(struct fscache_cookie *cookie, bool invalidate)\r\n{\r\nstruct fscache_object *object;\r\nbool awaken = false;\r\n_enter("%p,%u", cookie, invalidate);\r\nASSERTCMP(atomic_read(&cookie->n_active), >, 0);\r\nif (atomic_read(&cookie->n_children) != 0) {\r\npr_err("Cookie '%s' still has children\n",\r\ncookie->def->name);\r\nBUG();\r\n}\r\nwait_on_bit_lock(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK,\r\nTASK_UNINTERRUPTIBLE);\r\nif (!test_and_clear_bit(FSCACHE_COOKIE_ENABLED, &cookie->flags))\r\ngoto out_unlock_enable;\r\n__fscache_wait_on_invalidate(cookie);\r\nset_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags);\r\nspin_lock(&cookie->lock);\r\nif (!hlist_empty(&cookie->backing_objects)) {\r\nhlist_for_each_entry(object, &cookie->backing_objects, cookie_link) {\r\nif (invalidate)\r\nset_bit(FSCACHE_OBJECT_RETIRED, &object->flags);\r\nclear_bit(FSCACHE_OBJECT_PENDING_WRITE, &object->flags);\r\nfscache_raise_event(object, FSCACHE_OBJECT_EV_KILL);\r\n}\r\n} else {\r\nif (test_and_clear_bit(FSCACHE_COOKIE_INVALIDATING, &cookie->flags))\r\nawaken = true;\r\n}\r\nspin_unlock(&cookie->lock);\r\nif (awaken)\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_INVALIDATING);\r\nif (!atomic_dec_and_test(&cookie->n_active))\r\nwait_on_atomic_t(&cookie->n_active, fscache_wait_atomic_t,\r\nTASK_UNINTERRUPTIBLE);\r\nif (cookie->def->type != FSCACHE_COOKIE_TYPE_INDEX)\r\nfscache_invalidate_writes(cookie);\r\nif (!test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags)) {\r\natomic_inc(&cookie->n_active);\r\nset_bit(FSCACHE_COOKIE_NO_DATA_YET, &cookie->flags);\r\n}\r\nout_unlock_enable:\r\nclear_bit_unlock(FSCACHE_COOKIE_ENABLEMENT_LOCK, &cookie->flags);\r\nwake_up_bit(&cookie->flags, FSCACHE_COOKIE_ENABLEMENT_LOCK);\r\n_leave("");\r\n}\r\nvoid __fscache_relinquish_cookie(struct fscache_cookie *cookie, bool retire)\r\n{\r\nfscache_stat(&fscache_n_relinquishes);\r\nif (retire)\r\nfscache_stat(&fscache_n_relinquishes_retire);\r\nif (!cookie) {\r\nfscache_stat(&fscache_n_relinquishes_null);\r\n_leave(" [no cookie]");\r\nreturn;\r\n}\r\n_enter("%p{%s,%p,%d},%d",\r\ncookie, cookie->def->name, cookie->netfs_data,\r\natomic_read(&cookie->n_active), retire);\r\nset_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags);\r\n__fscache_disable_cookie(cookie, retire);\r\ncookie->netfs_data = NULL;\r\ncookie->def = NULL;\r\nBUG_ON(cookie->stores.rnode);\r\nif (cookie->parent) {\r\nASSERTCMP(atomic_read(&cookie->parent->usage), >, 0);\r\nASSERTCMP(atomic_read(&cookie->parent->n_children), >, 0);\r\natomic_dec(&cookie->parent->n_children);\r\n}\r\nASSERTCMP(atomic_read(&cookie->usage), >, 0);\r\nfscache_cookie_put(cookie);\r\n_leave("");\r\n}\r\nvoid __fscache_cookie_put(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_cookie *parent;\r\n_enter("%p", cookie);\r\nfor (;;) {\r\n_debug("FREE COOKIE %p", cookie);\r\nparent = cookie->parent;\r\nBUG_ON(!hlist_empty(&cookie->backing_objects));\r\nkmem_cache_free(fscache_cookie_jar, cookie);\r\nif (!parent)\r\nbreak;\r\ncookie = parent;\r\nBUG_ON(atomic_read(&cookie->usage) <= 0);\r\nif (!atomic_dec_and_test(&cookie->usage))\r\nbreak;\r\n}\r\n_leave("");\r\n}\r\nint __fscache_check_consistency(struct fscache_cookie *cookie)\r\n{\r\nstruct fscache_operation *op;\r\nstruct fscache_object *object;\r\nbool wake_cookie = false;\r\nint ret;\r\n_enter("%p,", cookie);\r\nASSERTCMP(cookie->def->type, ==, FSCACHE_COOKIE_TYPE_DATAFILE);\r\nif (fscache_wait_for_deferred_lookup(cookie) < 0)\r\nreturn -ERESTARTSYS;\r\nif (hlist_empty(&cookie->backing_objects))\r\nreturn 0;\r\nop = kzalloc(sizeof(*op), GFP_NOIO | __GFP_NOMEMALLOC | __GFP_NORETRY);\r\nif (!op)\r\nreturn -ENOMEM;\r\nfscache_operation_init(op, NULL, NULL, NULL);\r\nop->flags = FSCACHE_OP_MYTHREAD |\r\n(1 << FSCACHE_OP_WAITING) |\r\n(1 << FSCACHE_OP_UNUSE_COOKIE);\r\nspin_lock(&cookie->lock);\r\nif (!fscache_cookie_enabled(cookie) ||\r\nhlist_empty(&cookie->backing_objects))\r\ngoto inconsistent;\r\nobject = hlist_entry(cookie->backing_objects.first,\r\nstruct fscache_object, cookie_link);\r\nif (test_bit(FSCACHE_IOERROR, &object->cache->flags))\r\ngoto inconsistent;\r\nop->debug_id = atomic_inc_return(&fscache_op_debug_id);\r\n__fscache_use_cookie(cookie);\r\nif (fscache_submit_op(object, op) < 0)\r\ngoto submit_failed;\r\nspin_unlock(&cookie->lock);\r\nret = fscache_wait_for_operation_activation(object, op, NULL, NULL);\r\nif (ret == 0) {\r\nret = object->cache->ops->check_consistency(op);\r\nfscache_op_complete(op, false);\r\n} else if (ret == -ENOBUFS) {\r\nret = 0;\r\n}\r\nfscache_put_operation(op);\r\n_leave(" = %d", ret);\r\nreturn ret;\r\nsubmit_failed:\r\nwake_cookie = __fscache_unuse_cookie(cookie);\r\ninconsistent:\r\nspin_unlock(&cookie->lock);\r\nif (wake_cookie)\r\n__fscache_wake_unused_cookie(cookie);\r\nkfree(op);\r\n_leave(" = -ESTALE");\r\nreturn -ESTALE;\r\n}
