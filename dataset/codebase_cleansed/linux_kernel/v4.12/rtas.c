static unsigned long lock_rtas(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\npreempt_disable();\r\narch_spin_lock_flags(&rtas.lock, flags);\r\nreturn flags;\r\n}\r\nstatic void unlock_rtas(unsigned long flags)\r\n{\r\narch_spin_unlock(&rtas.lock);\r\nlocal_irq_restore(flags);\r\npreempt_enable();\r\n}\r\nstatic void call_rtas_display_status(unsigned char c)\r\n{\r\nunsigned long s;\r\nif (!rtas.base)\r\nreturn;\r\ns = lock_rtas();\r\nrtas_call_unlocked(&rtas.args, 10, 1, 1, NULL, c);\r\nunlock_rtas(s);\r\n}\r\nstatic void call_rtas_display_status_delay(char c)\r\n{\r\nstatic int pending_newline = 0;\r\nstatic int width = 16;\r\nif (c == '\n') {\r\nwhile (width-- > 0)\r\ncall_rtas_display_status(' ');\r\nwidth = 16;\r\nmdelay(500);\r\npending_newline = 1;\r\n} else {\r\nif (pending_newline) {\r\ncall_rtas_display_status('\r');\r\ncall_rtas_display_status('\n');\r\n}\r\npending_newline = 0;\r\nif (width--) {\r\ncall_rtas_display_status(c);\r\nudelay(10000);\r\n}\r\n}\r\n}\r\nvoid __init udbg_init_rtas_panel(void)\r\n{\r\nudbg_putc = call_rtas_display_status_delay;\r\n}\r\nstatic void udbg_rtascon_putc(char c)\r\n{\r\nint tries;\r\nif (!rtas.base)\r\nreturn;\r\nif (c == '\n')\r\nudbg_rtascon_putc('\r');\r\nfor (tries = 0; tries < 16; tries++) {\r\nif (rtas_call(rtas_putchar_token, 1, 1, NULL, c) == 0)\r\nbreak;\r\nudelay(1000);\r\n}\r\n}\r\nstatic int udbg_rtascon_getc_poll(void)\r\n{\r\nint c;\r\nif (!rtas.base)\r\nreturn -1;\r\nif (rtas_call(rtas_getchar_token, 0, 2, &c))\r\nreturn -1;\r\nreturn c;\r\n}\r\nstatic int udbg_rtascon_getc(void)\r\n{\r\nint c;\r\nwhile ((c = udbg_rtascon_getc_poll()) == -1)\r\n;\r\nreturn c;\r\n}\r\nvoid __init udbg_init_rtas_console(void)\r\n{\r\nudbg_putc = udbg_rtascon_putc;\r\nudbg_getc = udbg_rtascon_getc;\r\nudbg_getc_poll = udbg_rtascon_getc_poll;\r\n}\r\nvoid rtas_progress(char *s, unsigned short hex)\r\n{\r\nstruct device_node *root;\r\nint width;\r\nconst __be32 *p;\r\nchar *os;\r\nstatic int display_character, set_indicator;\r\nstatic int display_width, display_lines, form_feed;\r\nstatic const int *row_width;\r\nstatic DEFINE_SPINLOCK(progress_lock);\r\nstatic int current_line;\r\nstatic int pending_newline = 0;\r\nif (!rtas.base)\r\nreturn;\r\nif (display_width == 0) {\r\ndisplay_width = 0x10;\r\nif ((root = of_find_node_by_path("/rtas"))) {\r\nif ((p = of_get_property(root,\r\n"ibm,display-line-length", NULL)))\r\ndisplay_width = be32_to_cpu(*p);\r\nif ((p = of_get_property(root,\r\n"ibm,form-feed", NULL)))\r\nform_feed = be32_to_cpu(*p);\r\nif ((p = of_get_property(root,\r\n"ibm,display-number-of-lines", NULL)))\r\ndisplay_lines = be32_to_cpu(*p);\r\nrow_width = of_get_property(root,\r\n"ibm,display-truncation-length", NULL);\r\nof_node_put(root);\r\n}\r\ndisplay_character = rtas_token("display-character");\r\nset_indicator = rtas_token("set-indicator");\r\n}\r\nif (display_character == RTAS_UNKNOWN_SERVICE) {\r\nif (set_indicator != RTAS_UNKNOWN_SERVICE)\r\nrtas_call(set_indicator, 3, 1, NULL, 6, 0, hex);\r\nreturn;\r\n}\r\nspin_lock(&progress_lock);\r\nif (pending_newline) {\r\nrtas_call(display_character, 1, 1, NULL, '\r');\r\nrtas_call(display_character, 1, 1, NULL, '\n');\r\npending_newline = 0;\r\n} else {\r\ncurrent_line = 0;\r\nif (form_feed)\r\nrtas_call(display_character, 1, 1, NULL,\r\n(char)form_feed);\r\nelse\r\nrtas_call(display_character, 1, 1, NULL, '\r');\r\n}\r\nif (row_width)\r\nwidth = row_width[current_line];\r\nelse\r\nwidth = display_width;\r\nos = s;\r\nwhile (*os) {\r\nif (*os == '\n' || *os == '\r') {\r\nif (*os == '\n' && !os[1]) {\r\npending_newline = 1;\r\ncurrent_line++;\r\nif (current_line > display_lines-1)\r\ncurrent_line = display_lines-1;\r\nspin_unlock(&progress_lock);\r\nreturn;\r\n}\r\nif (*os == '\n') {\r\nrtas_call(display_character, 1, 1, NULL, '\r');\r\nrtas_call(display_character, 1, 1, NULL, '\n');\r\n} else {\r\nrtas_call(display_character, 1, 1, NULL, *os);\r\n}\r\nif (row_width)\r\nwidth = row_width[current_line];\r\nelse\r\nwidth = display_width;\r\n} else {\r\nwidth--;\r\nrtas_call(display_character, 1, 1, NULL, *os);\r\n}\r\nos++;\r\nif (width <= 0)\r\nwhile ((*os != 0) && (*os != '\n') && (*os != '\r'))\r\nos++;\r\n}\r\nspin_unlock(&progress_lock);\r\n}\r\nint rtas_token(const char *service)\r\n{\r\nconst __be32 *tokp;\r\nif (rtas.dev == NULL)\r\nreturn RTAS_UNKNOWN_SERVICE;\r\ntokp = of_get_property(rtas.dev, service, NULL);\r\nreturn tokp ? be32_to_cpu(*tokp) : RTAS_UNKNOWN_SERVICE;\r\n}\r\nint rtas_service_present(const char *service)\r\n{\r\nreturn rtas_token(service) != RTAS_UNKNOWN_SERVICE;\r\n}\r\nint rtas_get_error_log_max(void)\r\n{\r\nstatic int rtas_error_log_max;\r\nif (rtas_error_log_max)\r\nreturn rtas_error_log_max;\r\nrtas_error_log_max = rtas_token ("rtas-error-log-max");\r\nif ((rtas_error_log_max == RTAS_UNKNOWN_SERVICE) ||\r\n(rtas_error_log_max > RTAS_ERROR_LOG_MAX)) {\r\nprintk (KERN_WARNING "RTAS: bad log buffer size %d\n",\r\nrtas_error_log_max);\r\nrtas_error_log_max = RTAS_ERROR_LOG_MAX;\r\n}\r\nreturn rtas_error_log_max;\r\n}\r\nstatic char *__fetch_rtas_last_error(char *altbuf)\r\n{\r\nstruct rtas_args err_args, save_args;\r\nu32 bufsz;\r\nchar *buf = NULL;\r\nif (rtas_last_error_token == -1)\r\nreturn NULL;\r\nbufsz = rtas_get_error_log_max();\r\nerr_args.token = cpu_to_be32(rtas_last_error_token);\r\nerr_args.nargs = cpu_to_be32(2);\r\nerr_args.nret = cpu_to_be32(1);\r\nerr_args.args[0] = cpu_to_be32(__pa(rtas_err_buf));\r\nerr_args.args[1] = cpu_to_be32(bufsz);\r\nerr_args.args[2] = 0;\r\nsave_args = rtas.args;\r\nrtas.args = err_args;\r\nenter_rtas(__pa(&rtas.args));\r\nerr_args = rtas.args;\r\nrtas.args = save_args;\r\nif (unlikely(err_args.args[2] == 0)) {\r\nif (altbuf) {\r\nbuf = altbuf;\r\n} else {\r\nbuf = rtas_err_buf;\r\nif (slab_is_available())\r\nbuf = kmalloc(RTAS_ERROR_LOG_MAX, GFP_ATOMIC);\r\n}\r\nif (buf)\r\nmemcpy(buf, rtas_err_buf, RTAS_ERROR_LOG_MAX);\r\n}\r\nreturn buf;\r\n}\r\nstatic void\r\nva_rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret,\r\nva_list list)\r\n{\r\nint i;\r\nargs->token = cpu_to_be32(token);\r\nargs->nargs = cpu_to_be32(nargs);\r\nargs->nret = cpu_to_be32(nret);\r\nargs->rets = &(args->args[nargs]);\r\nfor (i = 0; i < nargs; ++i)\r\nargs->args[i] = cpu_to_be32(va_arg(list, __u32));\r\nfor (i = 0; i < nret; ++i)\r\nargs->rets[i] = 0;\r\nenter_rtas(__pa(args));\r\n}\r\nvoid rtas_call_unlocked(struct rtas_args *args, int token, int nargs, int nret, ...)\r\n{\r\nva_list list;\r\nva_start(list, nret);\r\nva_rtas_call_unlocked(args, token, nargs, nret, list);\r\nva_end(list);\r\n}\r\nint rtas_call(int token, int nargs, int nret, int *outputs, ...)\r\n{\r\nva_list list;\r\nint i;\r\nunsigned long s;\r\nstruct rtas_args *rtas_args;\r\nchar *buff_copy = NULL;\r\nint ret;\r\nif (!rtas.entry || token == RTAS_UNKNOWN_SERVICE)\r\nreturn -1;\r\ns = lock_rtas();\r\nrtas_args = &rtas.args;\r\nva_start(list, outputs);\r\nva_rtas_call_unlocked(rtas_args, token, nargs, nret, list);\r\nva_end(list);\r\nif (be32_to_cpu(rtas_args->rets[0]) == -1)\r\nbuff_copy = __fetch_rtas_last_error(NULL);\r\nif (nret > 1 && outputs != NULL)\r\nfor (i = 0; i < nret-1; ++i)\r\noutputs[i] = be32_to_cpu(rtas_args->rets[i+1]);\r\nret = (nret > 0)? be32_to_cpu(rtas_args->rets[0]): 0;\r\nunlock_rtas(s);\r\nif (buff_copy) {\r\nlog_error(buff_copy, ERR_TYPE_RTAS_LOG, 0);\r\nif (slab_is_available())\r\nkfree(buff_copy);\r\n}\r\nreturn ret;\r\n}\r\nunsigned int rtas_busy_delay_time(int status)\r\n{\r\nint order;\r\nunsigned int ms = 0;\r\nif (status == RTAS_BUSY) {\r\nms = 1;\r\n} else if (status >= RTAS_EXTENDED_DELAY_MIN &&\r\nstatus <= RTAS_EXTENDED_DELAY_MAX) {\r\norder = status - RTAS_EXTENDED_DELAY_MIN;\r\nfor (ms = 1; order > 0; order--)\r\nms *= 10;\r\n}\r\nreturn ms;\r\n}\r\nunsigned int rtas_busy_delay(int status)\r\n{\r\nunsigned int ms;\r\nmight_sleep();\r\nms = rtas_busy_delay_time(status);\r\nif (ms && need_resched())\r\nmsleep(ms);\r\nreturn ms;\r\n}\r\nstatic int rtas_error_rc(int rtas_rc)\r\n{\r\nint rc;\r\nswitch (rtas_rc) {\r\ncase -1:\r\nrc = -EIO;\r\nbreak;\r\ncase -3:\r\nrc = -EINVAL;\r\nbreak;\r\ncase -9000:\r\nrc = -EFAULT;\r\nbreak;\r\ncase -9001:\r\nrc = -EEXIST;\r\nbreak;\r\ncase -9002:\r\nrc = -ENODEV;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s: unexpected RTAS error %d\n",\r\n__func__, rtas_rc);\r\nrc = -ERANGE;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint rtas_get_power_level(int powerdomain, int *level)\r\n{\r\nint token = rtas_token("get-power-level");\r\nint rc;\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENOENT;\r\nwhile ((rc = rtas_call(token, 1, 2, level, powerdomain)) == RTAS_BUSY)\r\nudelay(1);\r\nif (rc < 0)\r\nreturn rtas_error_rc(rc);\r\nreturn rc;\r\n}\r\nint rtas_set_power_level(int powerdomain, int level, int *setlevel)\r\n{\r\nint token = rtas_token("set-power-level");\r\nint rc;\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENOENT;\r\ndo {\r\nrc = rtas_call(token, 2, 2, setlevel, powerdomain, level);\r\n} while (rtas_busy_delay(rc));\r\nif (rc < 0)\r\nreturn rtas_error_rc(rc);\r\nreturn rc;\r\n}\r\nint rtas_get_sensor(int sensor, int index, int *state)\r\n{\r\nint token = rtas_token("get-sensor-state");\r\nint rc;\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENOENT;\r\ndo {\r\nrc = rtas_call(token, 2, 2, state, sensor, index);\r\n} while (rtas_busy_delay(rc));\r\nif (rc < 0)\r\nreturn rtas_error_rc(rc);\r\nreturn rc;\r\n}\r\nint rtas_get_sensor_fast(int sensor, int index, int *state)\r\n{\r\nint token = rtas_token("get-sensor-state");\r\nint rc;\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENOENT;\r\nrc = rtas_call(token, 2, 2, state, sensor, index);\r\nWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\r\nrc <= RTAS_EXTENDED_DELAY_MAX));\r\nif (rc < 0)\r\nreturn rtas_error_rc(rc);\r\nreturn rc;\r\n}\r\nbool rtas_indicator_present(int token, int *maxindex)\r\n{\r\nint proplen, count, i;\r\nconst struct indicator_elem {\r\n__be32 token;\r\n__be32 maxindex;\r\n} *indicators;\r\nindicators = of_get_property(rtas.dev, "rtas-indicators", &proplen);\r\nif (!indicators)\r\nreturn false;\r\ncount = proplen / sizeof(struct indicator_elem);\r\nfor (i = 0; i < count; i++) {\r\nif (__be32_to_cpu(indicators[i].token) != token)\r\ncontinue;\r\nif (maxindex)\r\n*maxindex = __be32_to_cpu(indicators[i].maxindex);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nint rtas_set_indicator(int indicator, int index, int new_value)\r\n{\r\nint token = rtas_token("set-indicator");\r\nint rc;\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENOENT;\r\ndo {\r\nrc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\r\n} while (rtas_busy_delay(rc));\r\nif (rc < 0)\r\nreturn rtas_error_rc(rc);\r\nreturn rc;\r\n}\r\nint rtas_set_indicator_fast(int indicator, int index, int new_value)\r\n{\r\nint rc;\r\nint token = rtas_token("set-indicator");\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -ENOENT;\r\nrc = rtas_call(token, 3, 1, NULL, indicator, index, new_value);\r\nWARN_ON(rc == RTAS_BUSY || (rc >= RTAS_EXTENDED_DELAY_MIN &&\r\nrc <= RTAS_EXTENDED_DELAY_MAX));\r\nif (rc < 0)\r\nreturn rtas_error_rc(rc);\r\nreturn rc;\r\n}\r\nvoid __noreturn rtas_restart(char *cmd)\r\n{\r\nif (rtas_flash_term_hook)\r\nrtas_flash_term_hook(SYS_RESTART);\r\nprintk("RTAS system-reboot returned %d\n",\r\nrtas_call(rtas_token("system-reboot"), 0, 1, NULL));\r\nfor (;;);\r\n}\r\nvoid rtas_power_off(void)\r\n{\r\nif (rtas_flash_term_hook)\r\nrtas_flash_term_hook(SYS_POWER_OFF);\r\nprintk("RTAS power-off returned %d\n",\r\nrtas_call(rtas_token("power-off"), 2, 1, NULL, -1, -1));\r\nfor (;;);\r\n}\r\nvoid __noreturn rtas_halt(void)\r\n{\r\nif (rtas_flash_term_hook)\r\nrtas_flash_term_hook(SYS_HALT);\r\nprintk("RTAS power-off returned %d\n",\r\nrtas_call(rtas_token("power-off"), 2, 1, NULL, -1, -1));\r\nfor (;;);\r\n}\r\nvoid rtas_os_term(char *str)\r\n{\r\nint status;\r\nif (RTAS_UNKNOWN_SERVICE == rtas_token("ibm,os-term") ||\r\nRTAS_UNKNOWN_SERVICE == rtas_token("ibm,extended-os-term"))\r\nreturn;\r\nsnprintf(rtas_os_term_buf, 2048, "OS panic: %s", str);\r\ndo {\r\nstatus = rtas_call(rtas_token("ibm,os-term"), 1, 1, NULL,\r\n__pa(rtas_os_term_buf));\r\n} while (rtas_busy_delay(status));\r\nif (status != 0)\r\nprintk(KERN_EMERG "ibm,os-term call failed %d\n", status);\r\n}\r\nstatic int __rtas_suspend_last_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\r\n{\r\nu16 slb_size = mmu_slb_size;\r\nint rc = H_MULTI_THREADS_ACTIVE;\r\nint cpu;\r\nslb_set_size(SLB_MIN_SIZE);\r\nprintk(KERN_DEBUG "calling ibm,suspend-me on cpu %i\n", smp_processor_id());\r\nwhile (rc == H_MULTI_THREADS_ACTIVE && !atomic_read(&data->done) &&\r\n!atomic_read(&data->error))\r\nrc = rtas_call(data->token, 0, 1, NULL);\r\nif (rc || atomic_read(&data->error)) {\r\nprintk(KERN_DEBUG "ibm,suspend-me returned %d\n", rc);\r\nslb_set_size(slb_size);\r\n}\r\nif (atomic_read(&data->error))\r\nrc = atomic_read(&data->error);\r\natomic_set(&data->error, rc);\r\npSeries_coalesce_init();\r\nif (wake_when_done) {\r\natomic_set(&data->done, 1);\r\nfor_each_online_cpu(cpu)\r\nplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\r\n}\r\nif (atomic_dec_return(&data->working) == 0)\r\ncomplete(data->complete);\r\nreturn rc;\r\n}\r\nint rtas_suspend_last_cpu(struct rtas_suspend_me_data *data)\r\n{\r\natomic_inc(&data->working);\r\nreturn __rtas_suspend_last_cpu(data, 0);\r\n}\r\nstatic int __rtas_suspend_cpu(struct rtas_suspend_me_data *data, int wake_when_done)\r\n{\r\nlong rc = H_SUCCESS;\r\nunsigned long msr_save;\r\nint cpu;\r\natomic_inc(&data->working);\r\nmsr_save = mfmsr();\r\nmtmsr(msr_save & ~(MSR_EE));\r\nwhile (rc == H_SUCCESS && !atomic_read(&data->done) && !atomic_read(&data->error))\r\nrc = plpar_hcall_norets(H_JOIN);\r\nmtmsr(msr_save);\r\nif (rc == H_SUCCESS) {\r\ngoto out;\r\n} else if (rc == H_CONTINUE) {\r\nreturn __rtas_suspend_last_cpu(data, wake_when_done);\r\n} else {\r\nprintk(KERN_ERR "H_JOIN on cpu %i failed with rc = %ld\n",\r\nsmp_processor_id(), rc);\r\natomic_set(&data->error, rc);\r\n}\r\nif (wake_when_done) {\r\natomic_set(&data->done, 1);\r\nfor_each_online_cpu(cpu)\r\nplpar_hcall_norets(H_PROD, get_hard_smp_processor_id(cpu));\r\n}\r\nout:\r\nif (atomic_dec_return(&data->working) == 0)\r\ncomplete(data->complete);\r\nreturn rc;\r\n}\r\nint rtas_suspend_cpu(struct rtas_suspend_me_data *data)\r\n{\r\nreturn __rtas_suspend_cpu(data, 0);\r\n}\r\nstatic void rtas_percpu_suspend_me(void *info)\r\n{\r\n__rtas_suspend_cpu((struct rtas_suspend_me_data *)info, 1);\r\n}\r\nstatic int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\r\ncpumask_var_t cpus)\r\n{\r\nif (!cpumask_empty(cpus)) {\r\ncpumask_clear(cpus);\r\nreturn -EINVAL;\r\n} else\r\nreturn 0;\r\n}\r\nstatic int rtas_cpu_state_change_mask(enum rtas_cpu_state state,\r\ncpumask_var_t cpus)\r\n{\r\nint cpu;\r\nint cpuret = 0;\r\nint ret = 0;\r\nif (cpumask_empty(cpus))\r\nreturn 0;\r\nfor_each_cpu(cpu, cpus) {\r\nswitch (state) {\r\ncase DOWN:\r\ncpuret = cpu_down(cpu);\r\nbreak;\r\ncase UP:\r\ncpuret = cpu_up(cpu);\r\nbreak;\r\n}\r\nif (cpuret) {\r\npr_debug("%s: cpu_%s for cpu#%d returned %d.\n",\r\n__func__,\r\n((state == UP) ? "up" : "down"),\r\ncpu, cpuret);\r\nif (!ret)\r\nret = cpuret;\r\nif (state == UP) {\r\ncpumask_shift_right(cpus, cpus, cpu);\r\ncpumask_shift_left(cpus, cpus, cpu);\r\nbreak;\r\n} else {\r\ncpumask_clear_cpu(cpu, cpus);\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nint rtas_online_cpus_mask(cpumask_var_t cpus)\r\n{\r\nint ret;\r\nret = rtas_cpu_state_change_mask(UP, cpus);\r\nif (ret) {\r\ncpumask_var_t tmp_mask;\r\nif (!alloc_cpumask_var(&tmp_mask, GFP_TEMPORARY))\r\nreturn ret;\r\ncpumask_copy(tmp_mask, cpus);\r\nrtas_offline_cpus_mask(tmp_mask);\r\nfree_cpumask_var(tmp_mask);\r\n}\r\nreturn ret;\r\n}\r\nint rtas_offline_cpus_mask(cpumask_var_t cpus)\r\n{\r\nreturn rtas_cpu_state_change_mask(DOWN, cpus);\r\n}\r\nint rtas_ibm_suspend_me(u64 handle)\r\n{\r\nlong state;\r\nlong rc;\r\nunsigned long retbuf[PLPAR_HCALL_BUFSIZE];\r\nstruct rtas_suspend_me_data data;\r\nDECLARE_COMPLETION_ONSTACK(done);\r\ncpumask_var_t offline_mask;\r\nint cpuret;\r\nif (!rtas_service_present("ibm,suspend-me"))\r\nreturn -ENOSYS;\r\nrc = plpar_hcall(H_VASI_STATE, retbuf, handle);\r\nstate = retbuf[0];\r\nif (rc) {\r\nprintk(KERN_ERR "rtas_ibm_suspend_me: vasi_state returned %ld\n",rc);\r\nreturn rc;\r\n} else if (state == H_VASI_ENABLED) {\r\nreturn -EAGAIN;\r\n} else if (state != H_VASI_SUSPENDING) {\r\nprintk(KERN_ERR "rtas_ibm_suspend_me: vasi_state returned state %ld\n",\r\nstate);\r\nreturn -EIO;\r\n}\r\nif (!alloc_cpumask_var(&offline_mask, GFP_TEMPORARY))\r\nreturn -ENOMEM;\r\natomic_set(&data.working, 0);\r\natomic_set(&data.done, 0);\r\natomic_set(&data.error, 0);\r\ndata.token = rtas_token("ibm,suspend-me");\r\ndata.complete = &done;\r\ncpumask_andnot(offline_mask, cpu_present_mask, cpu_online_mask);\r\ncpuret = rtas_online_cpus_mask(offline_mask);\r\nif (cpuret) {\r\npr_err("%s: Could not bring present CPUs online.\n", __func__);\r\natomic_set(&data.error, cpuret);\r\ngoto out;\r\n}\r\nstop_topology_update();\r\nif (on_each_cpu(rtas_percpu_suspend_me, &data, 0))\r\natomic_set(&data.error, -EINVAL);\r\nwait_for_completion(&done);\r\nif (atomic_read(&data.error) != 0)\r\nprintk(KERN_ERR "Error doing global join\n");\r\nstart_topology_update();\r\ncpuret = rtas_offline_cpus_mask(offline_mask);\r\nif (cpuret)\r\npr_warn("%s: Could not restore CPUs to offline state.\n",\r\n__func__);\r\nout:\r\nfree_cpumask_var(offline_mask);\r\nreturn atomic_read(&data.error);\r\n}\r\nint rtas_ibm_suspend_me(u64 handle)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstruct pseries_errorlog *get_pseries_errorlog(struct rtas_error_log *log,\r\nuint16_t section_id)\r\n{\r\nstruct rtas_ext_event_log_v6 *ext_log =\r\n(struct rtas_ext_event_log_v6 *)log->buffer;\r\nstruct pseries_errorlog *sect;\r\nunsigned char *p, *log_end;\r\nuint32_t ext_log_length = rtas_error_extended_log_length(log);\r\nuint8_t log_format = rtas_ext_event_log_format(ext_log);\r\nuint32_t company_id = rtas_ext_event_company_id(ext_log);\r\nif (ext_log_length < sizeof(struct rtas_ext_event_log_v6) ||\r\nlog_format != RTAS_V6EXT_LOG_FORMAT_EVENT_LOG ||\r\ncompany_id != RTAS_V6EXT_COMPANY_ID_IBM)\r\nreturn NULL;\r\nlog_end = log->buffer + ext_log_length;\r\np = ext_log->vendor_log;\r\nwhile (p < log_end) {\r\nsect = (struct pseries_errorlog *)p;\r\nif (pseries_errorlog_id(sect) == section_id)\r\nreturn sect;\r\np += pseries_errorlog_length(sect);\r\n}\r\nreturn NULL;\r\n}\r\nasmlinkage int ppc_rtas(struct rtas_args __user *uargs)\r\n{\r\nstruct rtas_args args;\r\nunsigned long flags;\r\nchar *buff_copy, *errbuf = NULL;\r\nint nargs, nret, token;\r\nif (!capable(CAP_SYS_ADMIN))\r\nreturn -EPERM;\r\nif (!rtas.entry)\r\nreturn -EINVAL;\r\nif (copy_from_user(&args, uargs, 3 * sizeof(u32)) != 0)\r\nreturn -EFAULT;\r\nnargs = be32_to_cpu(args.nargs);\r\nnret = be32_to_cpu(args.nret);\r\ntoken = be32_to_cpu(args.token);\r\nif (nargs >= ARRAY_SIZE(args.args)\r\n|| nret > ARRAY_SIZE(args.args)\r\n|| nargs + nret > ARRAY_SIZE(args.args))\r\nreturn -EINVAL;\r\nif (copy_from_user(args.args, uargs->args,\r\nnargs * sizeof(rtas_arg_t)) != 0)\r\nreturn -EFAULT;\r\nif (token == RTAS_UNKNOWN_SERVICE)\r\nreturn -EINVAL;\r\nargs.rets = &args.args[nargs];\r\nmemset(args.rets, 0, nret * sizeof(rtas_arg_t));\r\nif (token == ibm_suspend_me_token) {\r\nint rc = 0;\r\nu64 handle = ((u64)be32_to_cpu(args.args[0]) << 32)\r\n| be32_to_cpu(args.args[1]);\r\nrc = rtas_ibm_suspend_me(handle);\r\nif (rc == -EAGAIN)\r\nargs.rets[0] = cpu_to_be32(RTAS_NOT_SUSPENDABLE);\r\nelse if (rc == -EIO)\r\nargs.rets[0] = cpu_to_be32(-1);\r\nelse if (rc)\r\nreturn rc;\r\ngoto copy_return;\r\n}\r\nbuff_copy = get_errorlog_buffer();\r\nflags = lock_rtas();\r\nrtas.args = args;\r\nenter_rtas(__pa(&rtas.args));\r\nargs = rtas.args;\r\nif (be32_to_cpu(args.rets[0]) == -1)\r\nerrbuf = __fetch_rtas_last_error(buff_copy);\r\nunlock_rtas(flags);\r\nif (buff_copy) {\r\nif (errbuf)\r\nlog_error(errbuf, ERR_TYPE_RTAS_LOG, 0);\r\nkfree(buff_copy);\r\n}\r\ncopy_return:\r\nif (copy_to_user(uargs->args + nargs,\r\nargs.args + nargs,\r\nnret * sizeof(rtas_arg_t)) != 0)\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nvoid __init rtas_initialize(void)\r\n{\r\nunsigned long rtas_region = RTAS_INSTANTIATE_MAX;\r\nu32 base, size, entry;\r\nint no_base, no_size, no_entry;\r\nrtas.dev = of_find_node_by_name(NULL, "rtas");\r\nif (!rtas.dev)\r\nreturn;\r\nno_base = of_property_read_u32(rtas.dev, "linux,rtas-base", &base);\r\nno_size = of_property_read_u32(rtas.dev, "rtas-size", &size);\r\nif (no_base || no_size) {\r\nof_node_put(rtas.dev);\r\nrtas.dev = NULL;\r\nreturn;\r\n}\r\nrtas.base = base;\r\nrtas.size = size;\r\nno_entry = of_property_read_u32(rtas.dev, "linux,rtas-entry", &entry);\r\nrtas.entry = no_entry ? rtas.base : entry;\r\n#ifdef CONFIG_PPC64\r\nif (firmware_has_feature(FW_FEATURE_LPAR)) {\r\nrtas_region = min(ppc64_rma_size, RTAS_INSTANTIATE_MAX);\r\nibm_suspend_me_token = rtas_token("ibm,suspend-me");\r\n}\r\n#endif\r\nrtas_rmo_buf = memblock_alloc_base(RTAS_RMOBUF_MAX, PAGE_SIZE, rtas_region);\r\n#ifdef CONFIG_RTAS_ERROR_LOGGING\r\nrtas_last_error_token = rtas_token("rtas-last-error");\r\n#endif\r\n}\r\nint __init early_init_dt_scan_rtas(unsigned long node,\r\nconst char *uname, int depth, void *data)\r\n{\r\nconst u32 *basep, *entryp, *sizep;\r\nif (depth != 1 || strcmp(uname, "rtas") != 0)\r\nreturn 0;\r\nbasep = of_get_flat_dt_prop(node, "linux,rtas-base", NULL);\r\nentryp = of_get_flat_dt_prop(node, "linux,rtas-entry", NULL);\r\nsizep = of_get_flat_dt_prop(node, "rtas-size", NULL);\r\nif (basep && entryp && sizep) {\r\nrtas.base = *basep;\r\nrtas.entry = *entryp;\r\nrtas.size = *sizep;\r\n}\r\n#ifdef CONFIG_UDBG_RTAS_CONSOLE\r\nbasep = of_get_flat_dt_prop(node, "put-term-char", NULL);\r\nif (basep)\r\nrtas_putchar_token = *basep;\r\nbasep = of_get_flat_dt_prop(node, "get-term-char", NULL);\r\nif (basep)\r\nrtas_getchar_token = *basep;\r\nif (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&\r\nrtas_getchar_token != RTAS_UNKNOWN_SERVICE)\r\nudbg_init_rtas_console();\r\n#endif\r\nreturn 1;\r\n}\r\nvoid rtas_give_timebase(void)\r\n{\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nhard_irq_disable();\r\narch_spin_lock(&timebase_lock);\r\nrtas_call(rtas_token("freeze-time-base"), 0, 1, NULL);\r\ntimebase = get_tb();\r\narch_spin_unlock(&timebase_lock);\r\nwhile (timebase)\r\nbarrier();\r\nrtas_call(rtas_token("thaw-time-base"), 0, 1, NULL);\r\nlocal_irq_restore(flags);\r\n}\r\nvoid rtas_take_timebase(void)\r\n{\r\nwhile (!timebase)\r\nbarrier();\r\narch_spin_lock(&timebase_lock);\r\nset_tb(timebase >> 32, timebase & 0xffffffff);\r\ntimebase = 0;\r\narch_spin_unlock(&timebase_lock);\r\n}
