static int __init dump_properties_enable(char *arg)\r\n{\r\ndump_properties = true;\r\nreturn 0;\r\n}\r\nstatic void __init unmarshal_key_value_pairs(struct dev_header *dev_header,\r\nstruct device *dev, void *ptr,\r\nstruct property_entry entry[])\r\n{\r\nint i;\r\nfor (i = 0; i < dev_header->prop_count; i++) {\r\nint remaining = dev_header->len - (ptr - (void *)dev_header);\r\nu32 key_len, val_len;\r\nchar *key;\r\nif (sizeof(key_len) > remaining)\r\nbreak;\r\nkey_len = *(typeof(key_len) *)ptr;\r\nif (key_len + sizeof(val_len) > remaining ||\r\nkey_len < sizeof(key_len) + sizeof(efi_char16_t) ||\r\n*(efi_char16_t *)(ptr + sizeof(key_len)) == 0) {\r\ndev_err(dev, "invalid property name len at %#zx\n",\r\nptr - (void *)dev_header);\r\nbreak;\r\n}\r\nval_len = *(typeof(val_len) *)(ptr + key_len);\r\nif (key_len + val_len > remaining ||\r\nval_len < sizeof(val_len)) {\r\ndev_err(dev, "invalid property val len at %#zx\n",\r\nptr - (void *)dev_header + key_len);\r\nbreak;\r\n}\r\nkey = kzalloc((key_len - sizeof(key_len)) * 4 + 1, GFP_KERNEL);\r\nif (!key) {\r\ndev_err(dev, "cannot allocate property name\n");\r\nbreak;\r\n}\r\nucs2_as_utf8(key, ptr + sizeof(key_len),\r\nkey_len - sizeof(key_len));\r\nentry[i].name = key;\r\nentry[i].is_array = true;\r\nentry[i].length = val_len - sizeof(val_len);\r\nentry[i].pointer.raw_data = ptr + key_len + sizeof(val_len);\r\nif (!entry[i].length) {\r\nentry[i].length = 1;\r\nentry[i].pointer.raw_data = &one;\r\n}\r\nif (dump_properties) {\r\ndev_info(dev, "property: %s\n", entry[i].name);\r\nprint_hex_dump(KERN_INFO, pr_fmt(), DUMP_PREFIX_OFFSET,\r\n16, 1, entry[i].pointer.raw_data,\r\nentry[i].length, true);\r\n}\r\nptr += key_len + val_len;\r\n}\r\nif (i != dev_header->prop_count) {\r\ndev_err(dev, "got %d device properties, expected %u\n", i,\r\ndev_header->prop_count);\r\nprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\r\n16, 1, dev_header, dev_header->len, true);\r\nreturn;\r\n}\r\ndev_info(dev, "assigning %d device properties\n", i);\r\n}\r\nstatic int __init unmarshal_devices(struct properties_header *properties)\r\n{\r\nsize_t offset = offsetof(struct properties_header, dev_header[0]);\r\nwhile (offset + sizeof(struct dev_header) < properties->len) {\r\nstruct dev_header *dev_header = (void *)properties + offset;\r\nstruct property_entry *entry = NULL;\r\nstruct device *dev;\r\nsize_t len;\r\nint ret, i;\r\nvoid *ptr;\r\nif (offset + dev_header->len > properties->len ||\r\ndev_header->len <= sizeof(*dev_header)) {\r\npr_err("invalid len in dev_header at %#zx\n", offset);\r\nreturn -EINVAL;\r\n}\r\nptr = dev_header->path;\r\nlen = dev_header->len - sizeof(*dev_header);\r\ndev = efi_get_device_by_path((struct efi_dev_path **)&ptr, &len);\r\nif (IS_ERR(dev)) {\r\npr_err("device path parse error %ld at %#zx:\n",\r\nPTR_ERR(dev), ptr - (void *)dev_header);\r\nprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\r\n16, 1, dev_header, dev_header->len, true);\r\ndev = NULL;\r\ngoto skip_device;\r\n}\r\nentry = kcalloc(dev_header->prop_count + 1, sizeof(*entry),\r\nGFP_KERNEL);\r\nif (!entry) {\r\ndev_err(dev, "cannot allocate properties\n");\r\ngoto skip_device;\r\n}\r\nunmarshal_key_value_pairs(dev_header, dev, ptr, entry);\r\nif (!entry[0].name)\r\ngoto skip_device;\r\nret = device_add_properties(dev, entry);\r\nif (ret)\r\ndev_err(dev, "error %d assigning properties\n", ret);\r\nfor (i = 0; entry[i].name; i++)\r\nkfree(entry[i].name);\r\nskip_device:\r\nkfree(entry);\r\nput_device(dev);\r\noffset += dev_header->len;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init map_properties(void)\r\n{\r\nstruct properties_header *properties;\r\nstruct setup_data *data;\r\nu32 data_len;\r\nu64 pa_data;\r\nint ret;\r\nif (!dmi_match(DMI_SYS_VENDOR, "Apple Inc.") &&\r\n!dmi_match(DMI_SYS_VENDOR, "Apple Computer, Inc."))\r\nreturn 0;\r\npa_data = boot_params.hdr.setup_data;\r\nwhile (pa_data) {\r\ndata = ioremap(pa_data, sizeof(*data));\r\nif (!data) {\r\npr_err("cannot map setup_data header\n");\r\nreturn -ENOMEM;\r\n}\r\nif (data->type != SETUP_APPLE_PROPERTIES) {\r\npa_data = data->next;\r\niounmap(data);\r\ncontinue;\r\n}\r\ndata_len = data->len;\r\niounmap(data);\r\ndata = ioremap(pa_data, sizeof(*data) + data_len);\r\nif (!data) {\r\npr_err("cannot map setup_data payload\n");\r\nreturn -ENOMEM;\r\n}\r\nproperties = (struct properties_header *)data->data;\r\nif (properties->version != 1) {\r\npr_err("unsupported version:\n");\r\nprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\r\n16, 1, properties, data_len, true);\r\nret = -ENOTSUPP;\r\n} else if (properties->len != data_len) {\r\npr_err("length mismatch, expected %u\n", data_len);\r\nprint_hex_dump(KERN_ERR, pr_fmt(), DUMP_PREFIX_OFFSET,\r\n16, 1, properties, data_len, true);\r\nret = -EINVAL;\r\n} else\r\nret = unmarshal_devices(properties);\r\ndata->len = 0;\r\niounmap(data);\r\nfree_bootmem_late(pa_data + sizeof(*data), data_len);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
