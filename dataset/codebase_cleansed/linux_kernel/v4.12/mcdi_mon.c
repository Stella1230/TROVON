void efx_mcdi_sensor_event(struct efx_nic *efx, efx_qword_t *ev)\r\n{\r\nunsigned int type, state, value;\r\nenum efx_hwmon_type hwmon_type = EFX_HWMON_UNKNOWN;\r\nconst char *name = NULL, *state_txt, *unit;\r\ntype = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_MONITOR);\r\nstate = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_STATE);\r\nvalue = EFX_QWORD_FIELD(*ev, MCDI_EVENT_SENSOREVT_VALUE);\r\nif (type < ARRAY_SIZE(efx_mcdi_sensor_type)) {\r\nname = efx_mcdi_sensor_type[type].label;\r\nhwmon_type = efx_mcdi_sensor_type[type].hwmon_type;\r\n}\r\nif (!name)\r\nname = "No sensor name available";\r\nEFX_WARN_ON_PARANOID(state >= ARRAY_SIZE(sensor_status_names));\r\nstate_txt = sensor_status_names[state];\r\nEFX_WARN_ON_PARANOID(hwmon_type >= EFX_HWMON_TYPES_COUNT);\r\nunit = efx_hwmon_unit[hwmon_type];\r\nif (!unit)\r\nunit = "";\r\nnetif_err(efx, hw, efx->net_dev,\r\n"Sensor %d (%s) reports condition '%s' for value %d%s\n",\r\ntype, name, state_txt, value, unit);\r\n}\r\nstatic int efx_mcdi_mon_update(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_READ_SENSORS_EXT_IN_LEN);\r\nint rc;\r\nMCDI_SET_QWORD(inbuf, READ_SENSORS_EXT_IN_DMA_ADDR,\r\nhwmon->dma_buf.dma_addr);\r\nMCDI_SET_DWORD(inbuf, READ_SENSORS_EXT_IN_LENGTH, hwmon->dma_buf.len);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_READ_SENSORS,\r\ninbuf, sizeof(inbuf), NULL, 0, NULL);\r\nif (rc == 0)\r\nhwmon->last_update = jiffies;\r\nreturn rc;\r\n}\r\nstatic int efx_mcdi_mon_get_entry(struct device *dev, unsigned int index,\r\nefx_dword_t *entry)\r\n{\r\nstruct efx_nic *efx = dev_get_drvdata(dev->parent);\r\nstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\r\nint rc;\r\nBUILD_BUG_ON(MC_CMD_READ_SENSORS_OUT_LEN != 0);\r\nmutex_lock(&hwmon->update_lock);\r\nif (time_before(jiffies, hwmon->last_update + HZ))\r\nrc = 0;\r\nelse\r\nrc = efx_mcdi_mon_update(efx);\r\n*entry = ((efx_dword_t *)hwmon->dma_buf.addr)[index];\r\nmutex_unlock(&hwmon->update_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t efx_mcdi_mon_show_value(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efx_mcdi_mon_attribute *mon_attr =\r\ncontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\r\nefx_dword_t entry;\r\nunsigned int value, state;\r\nint rc;\r\nrc = efx_mcdi_mon_get_entry(dev, mon_attr->index, &entry);\r\nif (rc)\r\nreturn rc;\r\nstate = EFX_DWORD_FIELD(entry, MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE);\r\nif (state == MC_CMD_SENSOR_STATE_NO_READING)\r\nreturn -EBUSY;\r\nvalue = EFX_DWORD_FIELD(entry, MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_VALUE);\r\nswitch (mon_attr->hwmon_type) {\r\ncase EFX_HWMON_TEMP:\r\nvalue *= 1000;\r\nbreak;\r\ncase EFX_HWMON_POWER:\r\nvalue *= 1000000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%u\n", value);\r\n}\r\nstatic ssize_t efx_mcdi_mon_show_limit(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efx_mcdi_mon_attribute *mon_attr =\r\ncontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\r\nunsigned int value;\r\nvalue = mon_attr->limit_value;\r\nswitch (mon_attr->hwmon_type) {\r\ncase EFX_HWMON_TEMP:\r\nvalue *= 1000;\r\nbreak;\r\ncase EFX_HWMON_POWER:\r\nvalue *= 1000000;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%u\n", value);\r\n}\r\nstatic ssize_t efx_mcdi_mon_show_alarm(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efx_mcdi_mon_attribute *mon_attr =\r\ncontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\r\nefx_dword_t entry;\r\nint state;\r\nint rc;\r\nrc = efx_mcdi_mon_get_entry(dev, mon_attr->index, &entry);\r\nif (rc)\r\nreturn rc;\r\nstate = EFX_DWORD_FIELD(entry, MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_STATE);\r\nreturn sprintf(buf, "%d\n", state != MC_CMD_SENSOR_STATE_OK);\r\n}\r\nstatic ssize_t efx_mcdi_mon_show_label(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct efx_mcdi_mon_attribute *mon_attr =\r\ncontainer_of(attr, struct efx_mcdi_mon_attribute, dev_attr);\r\nreturn sprintf(buf, "%s\n",\r\nefx_mcdi_sensor_type[mon_attr->type].label);\r\n}\r\nstatic void\r\nefx_mcdi_mon_add_attr(struct efx_nic *efx, const char *name,\r\nssize_t (*reader)(struct device *,\r\nstruct device_attribute *, char *),\r\nunsigned int index, unsigned int type,\r\nunsigned int limit_value)\r\n{\r\nstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\r\nstruct efx_mcdi_mon_attribute *attr = &hwmon->attrs[hwmon->n_attrs];\r\nstrlcpy(attr->name, name, sizeof(attr->name));\r\nattr->index = index;\r\nattr->type = type;\r\nif (type < ARRAY_SIZE(efx_mcdi_sensor_type))\r\nattr->hwmon_type = efx_mcdi_sensor_type[type].hwmon_type;\r\nelse\r\nattr->hwmon_type = EFX_HWMON_UNKNOWN;\r\nattr->limit_value = limit_value;\r\nsysfs_attr_init(&attr->dev_attr.attr);\r\nattr->dev_attr.attr.name = attr->name;\r\nattr->dev_attr.attr.mode = S_IRUGO;\r\nattr->dev_attr.show = reader;\r\nhwmon->group.attrs[hwmon->n_attrs++] = &attr->dev_attr.attr;\r\n}\r\nint efx_mcdi_mon_probe(struct efx_nic *efx)\r\n{\r\nunsigned int n_temp = 0, n_cool = 0, n_in = 0, n_curr = 0, n_power = 0;\r\nstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_SENSOR_INFO_EXT_IN_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_SENSOR_INFO_OUT_LENMAX);\r\nunsigned int n_pages, n_sensors, n_attrs, page;\r\nsize_t outlen;\r\nchar name[12];\r\nu32 mask;\r\nint rc, i, j, type;\r\nn_sensors = 0;\r\npage = 0;\r\ndo {\r\nMCDI_SET_DWORD(inbuf, SENSOR_INFO_EXT_IN_PAGE, page);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_SENSOR_INFO, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &outlen);\r\nif (rc)\r\nreturn rc;\r\nif (outlen < MC_CMD_SENSOR_INFO_OUT_LENMIN)\r\nreturn -EIO;\r\nmask = MCDI_DWORD(outbuf, SENSOR_INFO_OUT_MASK);\r\nn_sensors += hweight32(mask & ~(1 << MC_CMD_SENSOR_PAGE0_NEXT));\r\n++page;\r\n} while (mask & (1 << MC_CMD_SENSOR_PAGE0_NEXT));\r\nn_pages = page;\r\nif (n_sensors == 0)\r\nreturn 0;\r\nrc = efx_nic_alloc_buffer(\r\nefx, &hwmon->dma_buf,\r\nn_sensors * MC_CMD_SENSOR_VALUE_ENTRY_TYPEDEF_LEN,\r\nGFP_KERNEL);\r\nif (rc)\r\nreturn rc;\r\nmutex_init(&hwmon->update_lock);\r\nefx_mcdi_mon_update(efx);\r\nn_attrs = 6 * n_sensors;\r\nhwmon->attrs = kcalloc(n_attrs, sizeof(*hwmon->attrs), GFP_KERNEL);\r\nif (!hwmon->attrs) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nhwmon->group.attrs = kcalloc(n_attrs + 1, sizeof(struct attribute *),\r\nGFP_KERNEL);\r\nif (!hwmon->group.attrs) {\r\nrc = -ENOMEM;\r\ngoto fail;\r\n}\r\nfor (i = 0, j = -1, type = -1; ; i++) {\r\nenum efx_hwmon_type hwmon_type;\r\nconst char *hwmon_prefix;\r\nunsigned hwmon_index;\r\nu16 min1, max1, min2, max2;\r\ndo {\r\ntype++;\r\nif ((type % 32) == 0) {\r\npage = type / 32;\r\nj = -1;\r\nif (page == n_pages)\r\ngoto hwmon_register;\r\nMCDI_SET_DWORD(inbuf, SENSOR_INFO_EXT_IN_PAGE,\r\npage);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_SENSOR_INFO,\r\ninbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf),\r\n&outlen);\r\nif (rc)\r\ngoto fail;\r\nif (outlen < MC_CMD_SENSOR_INFO_OUT_LENMIN) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\nmask = (MCDI_DWORD(outbuf,\r\nSENSOR_INFO_OUT_MASK) &\r\n~(1 << MC_CMD_SENSOR_PAGE0_NEXT));\r\nif (outlen <\r\nMC_CMD_SENSOR_INFO_OUT_LEN(hweight32(mask))) {\r\nrc = -EIO;\r\ngoto fail;\r\n}\r\n}\r\n} while (!(mask & (1 << type % 32)));\r\nj++;\r\nif (type < ARRAY_SIZE(efx_mcdi_sensor_type)) {\r\nhwmon_type = efx_mcdi_sensor_type[type].hwmon_type;\r\nif (hwmon_type != EFX_HWMON_UNKNOWN &&\r\nefx_mcdi_sensor_type[type].port >= 0 &&\r\nefx_mcdi_sensor_type[type].port !=\r\nefx_port_num(efx))\r\ncontinue;\r\n} else {\r\nhwmon_type = EFX_HWMON_UNKNOWN;\r\n}\r\nswitch (hwmon_type) {\r\ncase EFX_HWMON_TEMP:\r\nhwmon_prefix = "temp";\r\nhwmon_index = ++n_temp;\r\nbreak;\r\ncase EFX_HWMON_COOL:\r\nhwmon_prefix = "fan";\r\nhwmon_index = ++n_cool;\r\nbreak;\r\ndefault:\r\nhwmon_prefix = "in";\r\nhwmon_index = n_in++;\r\nbreak;\r\ncase EFX_HWMON_CURR:\r\nhwmon_prefix = "curr";\r\nhwmon_index = ++n_curr;\r\nbreak;\r\ncase EFX_HWMON_POWER:\r\nhwmon_prefix = "power";\r\nhwmon_index = ++n_power;\r\nbreak;\r\n}\r\nmin1 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\r\nSENSOR_INFO_ENTRY, j, MIN1);\r\nmax1 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\r\nSENSOR_INFO_ENTRY, j, MAX1);\r\nmin2 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\r\nSENSOR_INFO_ENTRY, j, MIN2);\r\nmax2 = MCDI_ARRAY_FIELD(outbuf, SENSOR_ENTRY,\r\nSENSOR_INFO_ENTRY, j, MAX2);\r\nif (min1 != max1) {\r\nsnprintf(name, sizeof(name), "%s%u_input",\r\nhwmon_prefix, hwmon_index);\r\nefx_mcdi_mon_add_attr(\r\nefx, name, efx_mcdi_mon_show_value, i, type, 0);\r\nif (hwmon_type != EFX_HWMON_POWER) {\r\nsnprintf(name, sizeof(name), "%s%u_min",\r\nhwmon_prefix, hwmon_index);\r\nefx_mcdi_mon_add_attr(\r\nefx, name, efx_mcdi_mon_show_limit,\r\ni, type, min1);\r\n}\r\nsnprintf(name, sizeof(name), "%s%u_max",\r\nhwmon_prefix, hwmon_index);\r\nefx_mcdi_mon_add_attr(\r\nefx, name, efx_mcdi_mon_show_limit,\r\ni, type, max1);\r\nif (min2 != max2) {\r\nsnprintf(name, sizeof(name), "%s%u_crit",\r\nhwmon_prefix, hwmon_index);\r\nefx_mcdi_mon_add_attr(\r\nefx, name, efx_mcdi_mon_show_limit,\r\ni, type, max2);\r\n}\r\n}\r\nsnprintf(name, sizeof(name), "%s%u_alarm",\r\nhwmon_prefix, hwmon_index);\r\nefx_mcdi_mon_add_attr(\r\nefx, name, efx_mcdi_mon_show_alarm, i, type, 0);\r\nif (type < ARRAY_SIZE(efx_mcdi_sensor_type) &&\r\nefx_mcdi_sensor_type[type].label) {\r\nsnprintf(name, sizeof(name), "%s%u_label",\r\nhwmon_prefix, hwmon_index);\r\nefx_mcdi_mon_add_attr(\r\nefx, name, efx_mcdi_mon_show_label, i, type, 0);\r\n}\r\n}\r\nhwmon_register:\r\nhwmon->groups[0] = &hwmon->group;\r\nhwmon->device = hwmon_device_register_with_groups(&efx->pci_dev->dev,\r\nKBUILD_MODNAME, NULL,\r\nhwmon->groups);\r\nif (IS_ERR(hwmon->device)) {\r\nrc = PTR_ERR(hwmon->device);\r\ngoto fail;\r\n}\r\nreturn 0;\r\nfail:\r\nefx_mcdi_mon_remove(efx);\r\nreturn rc;\r\n}\r\nvoid efx_mcdi_mon_remove(struct efx_nic *efx)\r\n{\r\nstruct efx_mcdi_mon *hwmon = efx_mcdi_mon(efx);\r\nif (hwmon->device)\r\nhwmon_device_unregister(hwmon->device);\r\nkfree(hwmon->attrs);\r\nkfree(hwmon->group.attrs);\r\nefx_nic_free_buffer(efx, &hwmon->dma_buf);\r\n}
