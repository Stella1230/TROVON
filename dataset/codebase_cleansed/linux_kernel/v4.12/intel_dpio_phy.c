static u32 bxt_phy_port_mask(const struct bxt_ddi_phy_info *phy_info)\r\n{\r\nreturn (phy_info->dual_channel * BIT(phy_info->channel[DPIO_CH1].port)) |\r\nBIT(phy_info->channel[DPIO_CH0].port);\r\n}\r\nstatic const struct bxt_ddi_phy_info *\r\nbxt_get_phy_list(struct drm_i915_private *dev_priv, int *count)\r\n{\r\nif (IS_GEMINILAKE(dev_priv)) {\r\n*count = ARRAY_SIZE(glk_ddi_phy_info);\r\nreturn glk_ddi_phy_info;\r\n} else {\r\n*count = ARRAY_SIZE(bxt_ddi_phy_info);\r\nreturn bxt_ddi_phy_info;\r\n}\r\n}\r\nstatic const struct bxt_ddi_phy_info *\r\nbxt_get_phy_info(struct drm_i915_private *dev_priv, enum dpio_phy phy)\r\n{\r\nint count;\r\nconst struct bxt_ddi_phy_info *phy_list =\r\nbxt_get_phy_list(dev_priv, &count);\r\nreturn &phy_list[phy];\r\n}\r\nvoid bxt_port_to_phy_channel(struct drm_i915_private *dev_priv, enum port port,\r\nenum dpio_phy *phy, enum dpio_channel *ch)\r\n{\r\nconst struct bxt_ddi_phy_info *phy_info, *phys;\r\nint i, count;\r\nphys = bxt_get_phy_list(dev_priv, &count);\r\nfor (i = 0; i < count; i++) {\r\nphy_info = &phys[i];\r\nif (port == phy_info->channel[DPIO_CH0].port) {\r\n*phy = i;\r\n*ch = DPIO_CH0;\r\nreturn;\r\n}\r\nif (phy_info->dual_channel &&\r\nport == phy_info->channel[DPIO_CH1].port) {\r\n*phy = i;\r\n*ch = DPIO_CH1;\r\nreturn;\r\n}\r\n}\r\nWARN(1, "PHY not found for PORT %c", port_name(port));\r\n*phy = DPIO_PHY0;\r\n*ch = DPIO_CH0;\r\n}\r\nvoid bxt_ddi_phy_set_signal_level(struct drm_i915_private *dev_priv,\r\nenum port port, u32 margin, u32 scale,\r\nu32 enable, u32 deemphasis)\r\n{\r\nu32 val;\r\nenum dpio_phy phy;\r\nenum dpio_channel ch;\r\nbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\r\nval = I915_READ(BXT_PORT_PCS_DW10_LN01(phy, ch));\r\nval &= ~(TX2_SWING_CALC_INIT | TX1_SWING_CALC_INIT);\r\nI915_WRITE(BXT_PORT_PCS_DW10_GRP(phy, ch), val);\r\nval = I915_READ(BXT_PORT_TX_DW2_LN0(phy, ch));\r\nval &= ~(MARGIN_000 | UNIQ_TRANS_SCALE);\r\nval |= margin << MARGIN_000_SHIFT | scale << UNIQ_TRANS_SCALE_SHIFT;\r\nI915_WRITE(BXT_PORT_TX_DW2_GRP(phy, ch), val);\r\nval = I915_READ(BXT_PORT_TX_DW3_LN0(phy, ch));\r\nval &= ~SCALE_DCOMP_METHOD;\r\nif (enable)\r\nval |= SCALE_DCOMP_METHOD;\r\nif ((val & UNIQUE_TRANGE_EN_METHOD) && !(val & SCALE_DCOMP_METHOD))\r\nDRM_ERROR("Disabled scaling while ouniqetrangenmethod was set");\r\nI915_WRITE(BXT_PORT_TX_DW3_GRP(phy, ch), val);\r\nval = I915_READ(BXT_PORT_TX_DW4_LN0(phy, ch));\r\nval &= ~DE_EMPHASIS;\r\nval |= deemphasis << DEEMPH_SHIFT;\r\nI915_WRITE(BXT_PORT_TX_DW4_GRP(phy, ch), val);\r\nval = I915_READ(BXT_PORT_PCS_DW10_LN01(phy, ch));\r\nval |= TX2_SWING_CALC_INIT | TX1_SWING_CALC_INIT;\r\nI915_WRITE(BXT_PORT_PCS_DW10_GRP(phy, ch), val);\r\n}\r\nbool bxt_ddi_phy_is_enabled(struct drm_i915_private *dev_priv,\r\nenum dpio_phy phy)\r\n{\r\nconst struct bxt_ddi_phy_info *phy_info;\r\nenum port port;\r\nphy_info = bxt_get_phy_info(dev_priv, phy);\r\nif (!(I915_READ(BXT_P_CR_GT_DISP_PWRON) & phy_info->pwron_mask))\r\nreturn false;\r\nif ((I915_READ(BXT_PORT_CL1CM_DW0(phy)) &\r\n(PHY_POWER_GOOD | PHY_RESERVED)) != PHY_POWER_GOOD) {\r\nDRM_DEBUG_DRIVER("DDI PHY %d powered, but power hasn't settled\n",\r\nphy);\r\nreturn false;\r\n}\r\nif (!(I915_READ(BXT_PHY_CTL_FAMILY(phy)) & COMMON_RESET_DIS)) {\r\nDRM_DEBUG_DRIVER("DDI PHY %d powered, but still in reset\n",\r\nphy);\r\nreturn false;\r\n}\r\nfor_each_port_masked(port, bxt_phy_port_mask(phy_info)) {\r\nu32 tmp = I915_READ(BXT_PHY_CTL(port));\r\nif (tmp & BXT_PHY_CMNLANE_POWERDOWN_ACK) {\r\nDRM_DEBUG_DRIVER("DDI PHY %d powered, but common lane "\r\n"for port %c powered down "\r\n"(PHY_CTL %08x)\n",\r\nphy, port_name(port), tmp);\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic u32 bxt_get_grc(struct drm_i915_private *dev_priv, enum dpio_phy phy)\r\n{\r\nu32 val = I915_READ(BXT_PORT_REF_DW6(phy));\r\nreturn (val & GRC_CODE_MASK) >> GRC_CODE_SHIFT;\r\n}\r\nstatic void bxt_phy_wait_grc_done(struct drm_i915_private *dev_priv,\r\nenum dpio_phy phy)\r\n{\r\nif (intel_wait_for_register(dev_priv,\r\nBXT_PORT_REF_DW3(phy),\r\nGRC_DONE, GRC_DONE,\r\n10))\r\nDRM_ERROR("timeout waiting for PHY%d GRC\n", phy);\r\n}\r\nstatic void _bxt_ddi_phy_init(struct drm_i915_private *dev_priv,\r\nenum dpio_phy phy)\r\n{\r\nconst struct bxt_ddi_phy_info *phy_info;\r\nu32 val;\r\nphy_info = bxt_get_phy_info(dev_priv, phy);\r\nif (bxt_ddi_phy_is_enabled(dev_priv, phy)) {\r\nif (phy_info->rcomp_phy != -1)\r\ndev_priv->bxt_phy_grc = bxt_get_grc(dev_priv, phy);\r\nif (bxt_ddi_phy_verify_state(dev_priv, phy)) {\r\nDRM_DEBUG_DRIVER("DDI PHY %d already enabled, "\r\n"won't reprogram it\n", phy);\r\nreturn;\r\n}\r\nDRM_DEBUG_DRIVER("DDI PHY %d enabled with invalid state, "\r\n"force reprogramming it\n", phy);\r\n}\r\nval = I915_READ(BXT_P_CR_GT_DISP_PWRON);\r\nval |= phy_info->pwron_mask;\r\nI915_WRITE(BXT_P_CR_GT_DISP_PWRON, val);\r\nif (wait_for_us(((I915_READ(BXT_PORT_CL1CM_DW0(phy)) &\r\n(PHY_RESERVED | PHY_POWER_GOOD)) == PHY_POWER_GOOD), 100)) {\r\nDRM_ERROR("timeout during PHY%d power on\n", phy);\r\n}\r\nval = I915_READ(BXT_PORT_CL1CM_DW9(phy));\r\nval &= ~IREF0RC_OFFSET_MASK;\r\nval |= 0xE4 << IREF0RC_OFFSET_SHIFT;\r\nI915_WRITE(BXT_PORT_CL1CM_DW9(phy), val);\r\nval = I915_READ(BXT_PORT_CL1CM_DW10(phy));\r\nval &= ~IREF1RC_OFFSET_MASK;\r\nval |= 0xE4 << IREF1RC_OFFSET_SHIFT;\r\nI915_WRITE(BXT_PORT_CL1CM_DW10(phy), val);\r\nval = I915_READ(BXT_PORT_CL1CM_DW28(phy));\r\nval |= OCL1_POWER_DOWN_EN | DW28_OLDO_DYN_PWR_DOWN_EN |\r\nSUS_CLK_CONFIG;\r\nI915_WRITE(BXT_PORT_CL1CM_DW28(phy), val);\r\nif (phy_info->dual_channel) {\r\nval = I915_READ(BXT_PORT_CL2CM_DW6(phy));\r\nval |= DW6_OLDO_DYN_PWR_DOWN_EN;\r\nI915_WRITE(BXT_PORT_CL2CM_DW6(phy), val);\r\n}\r\nif (phy_info->rcomp_phy != -1) {\r\nuint32_t grc_code;\r\nbxt_phy_wait_grc_done(dev_priv, phy_info->rcomp_phy);\r\nval = dev_priv->bxt_phy_grc = bxt_get_grc(dev_priv,\r\nphy_info->rcomp_phy);\r\ngrc_code = val << GRC_CODE_FAST_SHIFT |\r\nval << GRC_CODE_SLOW_SHIFT |\r\nval;\r\nI915_WRITE(BXT_PORT_REF_DW6(phy), grc_code);\r\nval = I915_READ(BXT_PORT_REF_DW8(phy));\r\nval |= GRC_DIS | GRC_RDY_OVRD;\r\nI915_WRITE(BXT_PORT_REF_DW8(phy), val);\r\n}\r\nif (phy_info->reset_delay)\r\nudelay(phy_info->reset_delay);\r\nval = I915_READ(BXT_PHY_CTL_FAMILY(phy));\r\nval |= COMMON_RESET_DIS;\r\nI915_WRITE(BXT_PHY_CTL_FAMILY(phy), val);\r\n}\r\nvoid bxt_ddi_phy_uninit(struct drm_i915_private *dev_priv, enum dpio_phy phy)\r\n{\r\nconst struct bxt_ddi_phy_info *phy_info;\r\nuint32_t val;\r\nphy_info = bxt_get_phy_info(dev_priv, phy);\r\nval = I915_READ(BXT_PHY_CTL_FAMILY(phy));\r\nval &= ~COMMON_RESET_DIS;\r\nI915_WRITE(BXT_PHY_CTL_FAMILY(phy), val);\r\nval = I915_READ(BXT_P_CR_GT_DISP_PWRON);\r\nval &= ~phy_info->pwron_mask;\r\nI915_WRITE(BXT_P_CR_GT_DISP_PWRON, val);\r\n}\r\nvoid bxt_ddi_phy_init(struct drm_i915_private *dev_priv, enum dpio_phy phy)\r\n{\r\nconst struct bxt_ddi_phy_info *phy_info =\r\nbxt_get_phy_info(dev_priv, phy);\r\nenum dpio_phy rcomp_phy = phy_info->rcomp_phy;\r\nbool was_enabled;\r\nlockdep_assert_held(&dev_priv->power_domains.lock);\r\nif (rcomp_phy != -1) {\r\nwas_enabled = bxt_ddi_phy_is_enabled(dev_priv, rcomp_phy);\r\nif (!was_enabled)\r\n_bxt_ddi_phy_init(dev_priv, rcomp_phy);\r\n}\r\n_bxt_ddi_phy_init(dev_priv, phy);\r\nif (rcomp_phy != -1 && !was_enabled)\r\nbxt_ddi_phy_uninit(dev_priv, phy_info->rcomp_phy);\r\n}\r\nbool bxt_ddi_phy_verify_state(struct drm_i915_private *dev_priv,\r\nenum dpio_phy phy)\r\n{\r\nconst struct bxt_ddi_phy_info *phy_info;\r\nuint32_t mask;\r\nbool ok;\r\nphy_info = bxt_get_phy_info(dev_priv, phy);\r\n#define _CHK(reg, mask, exp, fmt, ...) \\r\n__phy_reg_verify_state(dev_priv, phy, reg, mask, exp, fmt, \\r\n## __VA_ARGS__)\r\nif (!bxt_ddi_phy_is_enabled(dev_priv, phy))\r\nreturn false;\r\nok = true;\r\nok &= _CHK(BXT_PORT_CL1CM_DW9(phy),\r\nIREF0RC_OFFSET_MASK, 0xe4 << IREF0RC_OFFSET_SHIFT,\r\n"BXT_PORT_CL1CM_DW9(%d)", phy);\r\nok &= _CHK(BXT_PORT_CL1CM_DW10(phy),\r\nIREF1RC_OFFSET_MASK, 0xe4 << IREF1RC_OFFSET_SHIFT,\r\n"BXT_PORT_CL1CM_DW10(%d)", phy);\r\nmask = OCL1_POWER_DOWN_EN | DW28_OLDO_DYN_PWR_DOWN_EN | SUS_CLK_CONFIG;\r\nok &= _CHK(BXT_PORT_CL1CM_DW28(phy), mask, mask,\r\n"BXT_PORT_CL1CM_DW28(%d)", phy);\r\nif (phy_info->dual_channel)\r\nok &= _CHK(BXT_PORT_CL2CM_DW6(phy),\r\nDW6_OLDO_DYN_PWR_DOWN_EN, DW6_OLDO_DYN_PWR_DOWN_EN,\r\n"BXT_PORT_CL2CM_DW6(%d)", phy);\r\nif (phy_info->rcomp_phy != -1) {\r\nu32 grc_code = dev_priv->bxt_phy_grc;\r\ngrc_code = grc_code << GRC_CODE_FAST_SHIFT |\r\ngrc_code << GRC_CODE_SLOW_SHIFT |\r\ngrc_code;\r\nmask = GRC_CODE_FAST_MASK | GRC_CODE_SLOW_MASK |\r\nGRC_CODE_NOM_MASK;\r\nok &= _CHK(BXT_PORT_REF_DW6(phy), mask, grc_code,\r\n"BXT_PORT_REF_DW6(%d)", phy);\r\nmask = GRC_DIS | GRC_RDY_OVRD;\r\nok &= _CHK(BXT_PORT_REF_DW8(phy), mask, mask,\r\n"BXT_PORT_REF_DW8(%d)", phy);\r\n}\r\nreturn ok;\r\n#undef _CHK\r\n}\r\nuint8_t\r\nbxt_ddi_phy_calc_lane_lat_optim_mask(struct intel_encoder *encoder,\r\nuint8_t lane_count)\r\n{\r\nswitch (lane_count) {\r\ncase 1:\r\nreturn 0;\r\ncase 2:\r\nreturn BIT(2) | BIT(0);\r\ncase 4:\r\nreturn BIT(3) | BIT(2) | BIT(0);\r\ndefault:\r\nMISSING_CASE(lane_count);\r\nreturn 0;\r\n}\r\n}\r\nvoid bxt_ddi_phy_set_lane_optim_mask(struct intel_encoder *encoder,\r\nuint8_t lane_lat_optim_mask)\r\n{\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct drm_i915_private *dev_priv = to_i915(dport->base.base.dev);\r\nenum port port = dport->port;\r\nenum dpio_phy phy;\r\nenum dpio_channel ch;\r\nint lane;\r\nbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\r\nfor (lane = 0; lane < 4; lane++) {\r\nu32 val = I915_READ(BXT_PORT_TX_DW14_LN(phy, ch, lane));\r\nval &= ~LATENCY_OPTIM;\r\nif (lane_lat_optim_mask & BIT(lane))\r\nval |= LATENCY_OPTIM;\r\nI915_WRITE(BXT_PORT_TX_DW14_LN(phy, ch, lane), val);\r\n}\r\n}\r\nuint8_t\r\nbxt_ddi_phy_get_lane_lat_optim_mask(struct intel_encoder *encoder)\r\n{\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct drm_i915_private *dev_priv = to_i915(dport->base.base.dev);\r\nenum port port = dport->port;\r\nenum dpio_phy phy;\r\nenum dpio_channel ch;\r\nint lane;\r\nuint8_t mask;\r\nbxt_port_to_phy_channel(dev_priv, port, &phy, &ch);\r\nmask = 0;\r\nfor (lane = 0; lane < 4; lane++) {\r\nu32 val = I915_READ(BXT_PORT_TX_DW14_LN(phy, ch, lane));\r\nif (val & LATENCY_OPTIM)\r\nmask |= BIT(lane);\r\n}\r\nreturn mask;\r\n}\r\nvoid chv_set_phy_signal_level(struct intel_encoder *encoder,\r\nu32 deemph_reg_value, u32 margin_reg_value,\r\nbool uniq_trans_scale)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(dport->base.base.crtc);\r\nenum dpio_channel ch = vlv_dport_to_channel(dport);\r\nenum pipe pipe = intel_crtc->pipe;\r\nu32 val;\r\nint i;\r\nmutex_lock(&dev_priv->sb_lock);\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW10(ch));\r\nval &= ~(DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3);\r\nval &= ~(DPIO_PCS_TX1DEEMP_MASK | DPIO_PCS_TX2DEEMP_MASK);\r\nval |= DPIO_PCS_TX1DEEMP_9P5 | DPIO_PCS_TX2DEEMP_9P5;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW10(ch), val);\r\nif (intel_crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW10(ch));\r\nval &= ~(DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3);\r\nval &= ~(DPIO_PCS_TX1DEEMP_MASK | DPIO_PCS_TX2DEEMP_MASK);\r\nval |= DPIO_PCS_TX1DEEMP_9P5 | DPIO_PCS_TX2DEEMP_9P5;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW10(ch), val);\r\n}\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW9(ch));\r\nval &= ~(DPIO_PCS_TX1MARGIN_MASK | DPIO_PCS_TX2MARGIN_MASK);\r\nval |= DPIO_PCS_TX1MARGIN_000 | DPIO_PCS_TX2MARGIN_000;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW9(ch), val);\r\nif (intel_crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW9(ch));\r\nval &= ~(DPIO_PCS_TX1MARGIN_MASK | DPIO_PCS_TX2MARGIN_MASK);\r\nval |= DPIO_PCS_TX1MARGIN_000 | DPIO_PCS_TX2MARGIN_000;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW9(ch), val);\r\n}\r\nfor (i = 0; i < intel_crtc->config->lane_count; i++) {\r\nval = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW4(ch, i));\r\nval &= ~DPIO_SWING_DEEMPH9P5_MASK;\r\nval |= deemph_reg_value << DPIO_SWING_DEEMPH9P5_SHIFT;\r\nvlv_dpio_write(dev_priv, pipe, CHV_TX_DW4(ch, i), val);\r\n}\r\nfor (i = 0; i < intel_crtc->config->lane_count; i++) {\r\nval = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW2(ch, i));\r\nval &= ~DPIO_SWING_MARGIN000_MASK;\r\nval |= margin_reg_value << DPIO_SWING_MARGIN000_SHIFT;\r\nval &= ~(0xff << DPIO_UNIQ_TRANS_SCALE_SHIFT);\r\nval |= 0x9a << DPIO_UNIQ_TRANS_SCALE_SHIFT;\r\nvlv_dpio_write(dev_priv, pipe, CHV_TX_DW2(ch, i), val);\r\n}\r\nfor (i = 0; i < intel_crtc->config->lane_count; i++) {\r\nval = vlv_dpio_read(dev_priv, pipe, CHV_TX_DW3(ch, i));\r\nif (uniq_trans_scale)\r\nval |= DPIO_TX_UNIQ_TRANS_SCALE_EN;\r\nelse\r\nval &= ~DPIO_TX_UNIQ_TRANS_SCALE_EN;\r\nvlv_dpio_write(dev_priv, pipe, CHV_TX_DW3(ch, i), val);\r\n}\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW10(ch));\r\nval |= DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW10(ch), val);\r\nif (intel_crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW10(ch));\r\nval |= DPIO_PCS_SWING_CALC_TX0_TX2 | DPIO_PCS_SWING_CALC_TX1_TX3;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW10(ch), val);\r\n}\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nvoid chv_data_lane_soft_reset(struct intel_encoder *encoder,\r\nbool reset)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nenum dpio_channel ch = vlv_dport_to_channel(enc_to_dig_port(&encoder->base));\r\nstruct intel_crtc *crtc = to_intel_crtc(encoder->base.crtc);\r\nenum pipe pipe = crtc->pipe;\r\nuint32_t val;\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW0(ch));\r\nif (reset)\r\nval &= ~(DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET);\r\nelse\r\nval |= DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW0(ch), val);\r\nif (crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW0(ch));\r\nif (reset)\r\nval &= ~(DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET);\r\nelse\r\nval |= DPIO_PCS_TX_LANE2_RESET | DPIO_PCS_TX_LANE1_RESET;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW0(ch), val);\r\n}\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW1(ch));\r\nval |= CHV_PCS_REQ_SOFTRESET_EN;\r\nif (reset)\r\nval &= ~DPIO_PCS_CLK_SOFT_RESET;\r\nelse\r\nval |= DPIO_PCS_CLK_SOFT_RESET;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW1(ch), val);\r\nif (crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW1(ch));\r\nval |= CHV_PCS_REQ_SOFTRESET_EN;\r\nif (reset)\r\nval &= ~DPIO_PCS_CLK_SOFT_RESET;\r\nelse\r\nval |= DPIO_PCS_CLK_SOFT_RESET;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW1(ch), val);\r\n}\r\n}\r\nvoid chv_phy_pre_pll_enable(struct intel_encoder *encoder)\r\n{\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct intel_crtc *intel_crtc =\r\nto_intel_crtc(encoder->base.crtc);\r\nenum dpio_channel ch = vlv_dport_to_channel(dport);\r\nenum pipe pipe = intel_crtc->pipe;\r\nunsigned int lane_mask =\r\nintel_dp_unused_lane_mask(intel_crtc->config->lane_count);\r\nu32 val;\r\nif (ch == DPIO_CH0 && pipe == PIPE_B)\r\ndport->release_cl2_override =\r\n!chv_phy_powergate_ch(dev_priv, DPIO_PHY0, DPIO_CH1, true);\r\nchv_phy_powergate_lanes(encoder, true, lane_mask);\r\nmutex_lock(&dev_priv->sb_lock);\r\nchv_data_lane_soft_reset(encoder, true);\r\nif (pipe != PIPE_B) {\r\nval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW5_CH0);\r\nval &= ~(CHV_BUFLEFTENA1_MASK | CHV_BUFRIGHTENA1_MASK);\r\nif (ch == DPIO_CH0)\r\nval |= CHV_BUFLEFTENA1_FORCE;\r\nif (ch == DPIO_CH1)\r\nval |= CHV_BUFRIGHTENA1_FORCE;\r\nvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW5_CH0, val);\r\n} else {\r\nval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW1_CH1);\r\nval &= ~(CHV_BUFLEFTENA2_MASK | CHV_BUFRIGHTENA2_MASK);\r\nif (ch == DPIO_CH0)\r\nval |= CHV_BUFLEFTENA2_FORCE;\r\nif (ch == DPIO_CH1)\r\nval |= CHV_BUFRIGHTENA2_FORCE;\r\nvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW1_CH1, val);\r\n}\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(ch));\r\nval |= CHV_PCS_USEDCLKCHANNEL_OVRRIDE;\r\nif (pipe != PIPE_B)\r\nval &= ~CHV_PCS_USEDCLKCHANNEL;\r\nelse\r\nval |= CHV_PCS_USEDCLKCHANNEL;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW8(ch), val);\r\nif (intel_crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW8(ch));\r\nval |= CHV_PCS_USEDCLKCHANNEL_OVRRIDE;\r\nif (pipe != PIPE_B)\r\nval &= ~CHV_PCS_USEDCLKCHANNEL;\r\nelse\r\nval |= CHV_PCS_USEDCLKCHANNEL;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW8(ch), val);\r\n}\r\nval = vlv_dpio_read(dev_priv, pipe, CHV_CMN_DW19(ch));\r\nif (pipe != PIPE_B)\r\nval &= ~CHV_CMN_USEDCLKCHANNEL;\r\nelse\r\nval |= CHV_CMN_USEDCLKCHANNEL;\r\nvlv_dpio_write(dev_priv, pipe, CHV_CMN_DW19(ch), val);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nvoid chv_phy_pre_encoder_enable(struct intel_encoder *encoder)\r\n{\r\nstruct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);\r\nstruct intel_digital_port *dport = dp_to_dig_port(intel_dp);\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct intel_crtc *intel_crtc =\r\nto_intel_crtc(encoder->base.crtc);\r\nenum dpio_channel ch = vlv_dport_to_channel(dport);\r\nint pipe = intel_crtc->pipe;\r\nint data, i, stagger;\r\nu32 val;\r\nmutex_lock(&dev_priv->sb_lock);\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW11(ch));\r\nval &= ~DPIO_LANEDESKEW_STRAP_OVRD;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW11(ch), val);\r\nif (intel_crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW11(ch));\r\nval &= ~DPIO_LANEDESKEW_STRAP_OVRD;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW11(ch), val);\r\n}\r\nfor (i = 0; i < intel_crtc->config->lane_count; i++) {\r\nif (intel_crtc->config->lane_count == 1)\r\ndata = 0x0;\r\nelse\r\ndata = (i == 1) ? 0x0 : 0x1;\r\nvlv_dpio_write(dev_priv, pipe, CHV_TX_DW14(ch, i),\r\ndata << DPIO_UPAR_SHIFT);\r\n}\r\nif (intel_crtc->config->port_clock > 270000)\r\nstagger = 0x18;\r\nelse if (intel_crtc->config->port_clock > 135000)\r\nstagger = 0xd;\r\nelse if (intel_crtc->config->port_clock > 67500)\r\nstagger = 0x7;\r\nelse if (intel_crtc->config->port_clock > 33750)\r\nstagger = 0x4;\r\nelse\r\nstagger = 0x2;\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW11(ch));\r\nval |= DPIO_TX2_STAGGER_MASK(0x1f);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW11(ch), val);\r\nif (intel_crtc->config->lane_count > 2) {\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS23_DW11(ch));\r\nval |= DPIO_TX2_STAGGER_MASK(0x1f);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW11(ch), val);\r\n}\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS01_DW12(ch),\r\nDPIO_LANESTAGGER_STRAP(stagger) |\r\nDPIO_LANESTAGGER_STRAP_OVRD |\r\nDPIO_TX1_STAGGER_MASK(0x1f) |\r\nDPIO_TX1_STAGGER_MULT(6) |\r\nDPIO_TX2_STAGGER_MULT(0));\r\nif (intel_crtc->config->lane_count > 2) {\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS23_DW12(ch),\r\nDPIO_LANESTAGGER_STRAP(stagger) |\r\nDPIO_LANESTAGGER_STRAP_OVRD |\r\nDPIO_TX1_STAGGER_MASK(0x1f) |\r\nDPIO_TX1_STAGGER_MULT(7) |\r\nDPIO_TX2_STAGGER_MULT(5));\r\n}\r\nchv_data_lane_soft_reset(encoder, false);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nvoid chv_phy_release_cl2_override(struct intel_encoder *encoder)\r\n{\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nif (dport->release_cl2_override) {\r\nchv_phy_powergate_ch(dev_priv, DPIO_PHY0, DPIO_CH1, false);\r\ndport->release_cl2_override = false;\r\n}\r\n}\r\nvoid chv_phy_post_pll_disable(struct intel_encoder *encoder)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nenum pipe pipe = to_intel_crtc(encoder->base.crtc)->pipe;\r\nu32 val;\r\nmutex_lock(&dev_priv->sb_lock);\r\nif (pipe != PIPE_B) {\r\nval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW5_CH0);\r\nval &= ~(CHV_BUFLEFTENA1_MASK | CHV_BUFRIGHTENA1_MASK);\r\nvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW5_CH0, val);\r\n} else {\r\nval = vlv_dpio_read(dev_priv, pipe, _CHV_CMN_DW1_CH1);\r\nval &= ~(CHV_BUFLEFTENA2_MASK | CHV_BUFRIGHTENA2_MASK);\r\nvlv_dpio_write(dev_priv, pipe, _CHV_CMN_DW1_CH1, val);\r\n}\r\nmutex_unlock(&dev_priv->sb_lock);\r\nchv_phy_powergate_lanes(encoder, false, 0x0);\r\n}\r\nvoid vlv_set_phy_signal_level(struct intel_encoder *encoder,\r\nu32 demph_reg_value, u32 preemph_reg_value,\r\nu32 uniqtranscale_reg_value, u32 tx3_demph)\r\n{\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nenum dpio_channel port = vlv_dport_to_channel(dport);\r\nint pipe = intel_crtc->pipe;\r\nmutex_lock(&dev_priv->sb_lock);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), 0x00000000);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW4(port), demph_reg_value);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW2(port),\r\nuniqtranscale_reg_value);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW3(port), 0x0C782040);\r\nif (tx3_demph)\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX3_DW4(port), tx3_demph);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW11(port), 0x00030000);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW9(port), preemph_reg_value);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW5(port), DPIO_TX_OCALINIT_EN);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nvoid vlv_phy_pre_pll_enable(struct intel_encoder *encoder)\r\n{\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct intel_crtc *intel_crtc =\r\nto_intel_crtc(encoder->base.crtc);\r\nenum dpio_channel port = vlv_dport_to_channel(dport);\r\nint pipe = intel_crtc->pipe;\r\nmutex_lock(&dev_priv->sb_lock);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW0(port),\r\nDPIO_PCS_TX_LANE2_RESET |\r\nDPIO_PCS_TX_LANE1_RESET);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW1(port),\r\nDPIO_PCS_CLK_CRI_RXEB_EIOS_EN |\r\nDPIO_PCS_CLK_CRI_RXDIGFILTSG_EN |\r\n(1<<DPIO_PCS_CLK_DATAWIDTH_SHIFT) |\r\nDPIO_PCS_CLK_SOFT_RESET);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW12(port), 0x00750f00);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW11(port), 0x00001500);\r\nvlv_dpio_write(dev_priv, pipe, VLV_TX_DW14(port), 0x40400000);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nvoid vlv_phy_pre_encoder_enable(struct intel_encoder *encoder)\r\n{\r\nstruct intel_dp *intel_dp = enc_to_intel_dp(&encoder->base);\r\nstruct intel_digital_port *dport = dp_to_dig_port(intel_dp);\r\nstruct drm_device *dev = encoder->base.dev;\r\nstruct drm_i915_private *dev_priv = to_i915(dev);\r\nstruct intel_crtc *intel_crtc = to_intel_crtc(encoder->base.crtc);\r\nenum dpio_channel port = vlv_dport_to_channel(dport);\r\nint pipe = intel_crtc->pipe;\r\nu32 val;\r\nmutex_lock(&dev_priv->sb_lock);\r\nval = vlv_dpio_read(dev_priv, pipe, VLV_PCS01_DW8(port));\r\nval = 0;\r\nif (pipe)\r\nval |= (1<<21);\r\nelse\r\nval &= ~(1<<21);\r\nval |= 0x001000c4;\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW8(port), val);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW14(port), 0x00760018);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW23(port), 0x00400888);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}\r\nvoid vlv_phy_reset_lanes(struct intel_encoder *encoder)\r\n{\r\nstruct intel_digital_port *dport = enc_to_dig_port(&encoder->base);\r\nstruct drm_i915_private *dev_priv = to_i915(encoder->base.dev);\r\nstruct intel_crtc *intel_crtc =\r\nto_intel_crtc(encoder->base.crtc);\r\nenum dpio_channel port = vlv_dport_to_channel(dport);\r\nint pipe = intel_crtc->pipe;\r\nmutex_lock(&dev_priv->sb_lock);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW0(port), 0x00000000);\r\nvlv_dpio_write(dev_priv, pipe, VLV_PCS_DW1(port), 0x00e00060);\r\nmutex_unlock(&dev_priv->sb_lock);\r\n}
