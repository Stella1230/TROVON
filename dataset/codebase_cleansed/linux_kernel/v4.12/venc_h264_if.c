static inline u32 h264_read_reg(struct venc_h264_inst *inst, u32 addr)\r\n{\r\nreturn readl(inst->hw_base + addr);\r\n}\r\nstatic unsigned int h264_get_profile(struct venc_h264_inst *inst,\r\nunsigned int profile)\r\n{\r\nswitch (profile) {\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE:\r\nreturn 66;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_MAIN:\r\nreturn 77;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_HIGH:\r\nreturn 100;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_CONSTRAINED_BASELINE:\r\nmtk_vcodec_err(inst, "unsupported CONSTRAINED_BASELINE");\r\nreturn 0;\r\ncase V4L2_MPEG_VIDEO_H264_PROFILE_EXTENDED:\r\nmtk_vcodec_err(inst, "unsupported EXTENDED");\r\nreturn 0;\r\ndefault:\r\nmtk_vcodec_debug(inst, "unsupported profile %d", profile);\r\nreturn 100;\r\n}\r\n}\r\nstatic unsigned int h264_get_level(struct venc_h264_inst *inst,\r\nunsigned int level)\r\n{\r\nswitch (level) {\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1B:\r\nmtk_vcodec_err(inst, "unsupported 1B");\r\nreturn 0;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_0:\r\nreturn 10;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_1:\r\nreturn 11;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_2:\r\nreturn 12;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_1_3:\r\nreturn 13;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_0:\r\nreturn 20;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_1:\r\nreturn 21;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_2_2:\r\nreturn 22;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_0:\r\nreturn 30;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_1:\r\nreturn 31;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_3_2:\r\nreturn 32;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_4_0:\r\nreturn 40;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_4_1:\r\nreturn 41;\r\ncase V4L2_MPEG_VIDEO_H264_LEVEL_4_2:\r\nreturn 42;\r\ndefault:\r\nmtk_vcodec_debug(inst, "unsupported level %d", level);\r\nreturn 31;\r\n}\r\n}\r\nstatic void h264_enc_free_work_buf(struct venc_h264_inst *inst)\r\n{\r\nint i;\r\nmtk_vcodec_debug_enter(inst);\r\nfor (i = 0; i < VENC_H264_VPU_WORK_BUF_MAX; i++) {\r\nif (i != VENC_H264_VPU_WORK_BUF_SKIP_FRAME)\r\nmtk_vcodec_mem_free(inst->ctx, &inst->work_bufs[i]);\r\n}\r\nmtk_vcodec_mem_free(inst->ctx, &inst->pps_buf);\r\nmtk_vcodec_debug_leave(inst);\r\n}\r\nstatic int h264_enc_alloc_work_buf(struct venc_h264_inst *inst)\r\n{\r\nint i;\r\nint ret = 0;\r\nstruct venc_h264_vpu_buf *wb = inst->vsi->work_bufs;\r\nmtk_vcodec_debug_enter(inst);\r\nfor (i = 0; i < VENC_H264_VPU_WORK_BUF_MAX; i++) {\r\ninst->work_bufs[i].size = wb[i].size;\r\nif (i == VENC_H264_VPU_WORK_BUF_SKIP_FRAME) {\r\ninst->work_bufs[i].va = vpu_mapping_dm_addr(\r\ninst->vpu_inst.dev, wb[i].vpua);\r\ninst->work_bufs[i].dma_addr = 0;\r\n} else {\r\nret = mtk_vcodec_mem_alloc(inst->ctx,\r\n&inst->work_bufs[i]);\r\nif (ret) {\r\nmtk_vcodec_err(inst,\r\n"cannot allocate buf %d", i);\r\ngoto err_alloc;\r\n}\r\nif (i == VENC_H264_VPU_WORK_BUF_RC_CODE) {\r\nvoid *tmp_va;\r\ntmp_va = vpu_mapping_dm_addr(inst->vpu_inst.dev,\r\nwb[i].vpua);\r\nmemcpy(inst->work_bufs[i].va, tmp_va,\r\nwb[i].size);\r\n}\r\n}\r\nwb[i].iova = inst->work_bufs[i].dma_addr;\r\nmtk_vcodec_debug(inst,\r\n"work_buf[%d] va=0x%p iova=%pad size=%zu",\r\ni, inst->work_bufs[i].va,\r\n&inst->work_bufs[i].dma_addr,\r\ninst->work_bufs[i].size);\r\n}\r\ninst->pps_buf.size = 128;\r\nret = mtk_vcodec_mem_alloc(inst->ctx, &inst->pps_buf);\r\nif (ret) {\r\nmtk_vcodec_err(inst, "cannot allocate pps_buf");\r\ngoto err_alloc;\r\n}\r\nmtk_vcodec_debug_leave(inst);\r\nreturn ret;\r\nerr_alloc:\r\nh264_enc_free_work_buf(inst);\r\nreturn ret;\r\n}\r\nstatic unsigned int h264_enc_wait_venc_done(struct venc_h264_inst *inst)\r\n{\r\nunsigned int irq_status = 0;\r\nstruct mtk_vcodec_ctx *ctx = (struct mtk_vcodec_ctx *)inst->ctx;\r\nif (!mtk_vcodec_wait_for_done_ctx(ctx, MTK_INST_IRQ_RECEIVED,\r\nWAIT_INTR_TIMEOUT_MS)) {\r\nirq_status = ctx->irq_status;\r\nmtk_vcodec_debug(inst, "irq_status %x <-", irq_status);\r\n}\r\nreturn irq_status;\r\n}\r\nstatic int h264_encode_sps(struct venc_h264_inst *inst,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nunsigned int *bs_size)\r\n{\r\nint ret = 0;\r\nunsigned int irq_status;\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_encode(&inst->vpu_inst, H264_BS_MODE_SPS, NULL,\r\nbs_buf, bs_size);\r\nif (ret)\r\nreturn ret;\r\nirq_status = h264_enc_wait_venc_done(inst);\r\nif (irq_status != MTK_VENC_IRQ_STATUS_SPS) {\r\nmtk_vcodec_err(inst, "expect irq status %d",\r\nMTK_VENC_IRQ_STATUS_SPS);\r\nreturn -EINVAL;\r\n}\r\n*bs_size = h264_read_reg(inst, VENC_PIC_BITSTREAM_BYTE_CNT);\r\nmtk_vcodec_debug(inst, "bs size %d <-", *bs_size);\r\nreturn ret;\r\n}\r\nstatic int h264_encode_pps(struct venc_h264_inst *inst,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nunsigned int *bs_size)\r\n{\r\nint ret = 0;\r\nunsigned int irq_status;\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_encode(&inst->vpu_inst, H264_BS_MODE_PPS, NULL,\r\nbs_buf, bs_size);\r\nif (ret)\r\nreturn ret;\r\nirq_status = h264_enc_wait_venc_done(inst);\r\nif (irq_status != MTK_VENC_IRQ_STATUS_PPS) {\r\nmtk_vcodec_err(inst, "expect irq status %d",\r\nMTK_VENC_IRQ_STATUS_PPS);\r\nreturn -EINVAL;\r\n}\r\n*bs_size = h264_read_reg(inst, VENC_PIC_BITSTREAM_BYTE_CNT);\r\nmtk_vcodec_debug(inst, "bs size %d <-", *bs_size);\r\nreturn ret;\r\n}\r\nstatic int h264_encode_header(struct venc_h264_inst *inst,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nunsigned int *bs_size)\r\n{\r\nint ret = 0;\r\nunsigned int bs_size_sps;\r\nunsigned int bs_size_pps;\r\nret = h264_encode_sps(inst, bs_buf, &bs_size_sps);\r\nif (ret)\r\nreturn ret;\r\nret = h264_encode_pps(inst, &inst->pps_buf, &bs_size_pps);\r\nif (ret)\r\nreturn ret;\r\nmemcpy(bs_buf->va + bs_size_sps, inst->pps_buf.va, bs_size_pps);\r\n*bs_size = bs_size_sps + bs_size_pps;\r\nreturn ret;\r\n}\r\nstatic int h264_encode_frame(struct venc_h264_inst *inst,\r\nstruct venc_frm_buf *frm_buf,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nunsigned int *bs_size)\r\n{\r\nint ret = 0;\r\nunsigned int irq_status;\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_encode(&inst->vpu_inst, H264_BS_MODE_FRAME, frm_buf,\r\nbs_buf, bs_size);\r\nif (ret)\r\nreturn ret;\r\nif (inst->vpu_inst.state == VEN_IPI_MSG_ENC_STATE_SKIP) {\r\n*bs_size = inst->vpu_inst.bs_size;\r\nmemcpy(bs_buf->va,\r\ninst->work_bufs[VENC_H264_VPU_WORK_BUF_SKIP_FRAME].va,\r\n*bs_size);\r\n++inst->frm_cnt;\r\nreturn ret;\r\n}\r\nirq_status = h264_enc_wait_venc_done(inst);\r\nif (irq_status != MTK_VENC_IRQ_STATUS_FRM) {\r\nmtk_vcodec_err(inst, "irq_status=%d failed", irq_status);\r\nreturn -EIO;\r\n}\r\n*bs_size = h264_read_reg(inst, VENC_PIC_BITSTREAM_BYTE_CNT);\r\n++inst->frm_cnt;\r\nmtk_vcodec_debug(inst, "frm %d bs_size %d key_frm %d <-",\r\ninst->frm_cnt, *bs_size, inst->vpu_inst.is_key_frm);\r\nreturn ret;\r\n}\r\nstatic void h264_encode_filler(struct venc_h264_inst *inst, void *buf,\r\nint size)\r\n{\r\nunsigned char *p = buf;\r\nif (size < H264_FILLER_MARKER_SIZE) {\r\nmtk_vcodec_err(inst, "filler size too small %d", size);\r\nreturn;\r\n}\r\nmemcpy(p, h264_filler_marker, ARRAY_SIZE(h264_filler_marker));\r\nsize -= H264_FILLER_MARKER_SIZE;\r\np += H264_FILLER_MARKER_SIZE;\r\nmemset(p, 0xff, size);\r\n}\r\nstatic int h264_enc_init(struct mtk_vcodec_ctx *ctx, unsigned long *handle)\r\n{\r\nint ret = 0;\r\nstruct venc_h264_inst *inst;\r\ninst = kzalloc(sizeof(*inst), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\ninst->ctx = ctx;\r\ninst->vpu_inst.ctx = ctx;\r\ninst->vpu_inst.dev = ctx->dev->vpu_plat_dev;\r\ninst->vpu_inst.id = IPI_VENC_H264;\r\ninst->hw_base = mtk_vcodec_get_reg_addr(inst->ctx, VENC_SYS);\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_init(&inst->vpu_inst);\r\ninst->vsi = (struct venc_h264_vsi *)inst->vpu_inst.vsi;\r\nmtk_vcodec_debug_leave(inst);\r\nif (ret)\r\nkfree(inst);\r\nelse\r\n(*handle) = (unsigned long)inst;\r\nreturn ret;\r\n}\r\nstatic int h264_enc_encode(unsigned long handle,\r\nenum venc_start_opt opt,\r\nstruct venc_frm_buf *frm_buf,\r\nstruct mtk_vcodec_mem *bs_buf,\r\nstruct venc_done_result *result)\r\n{\r\nint ret = 0;\r\nstruct venc_h264_inst *inst = (struct venc_h264_inst *)handle;\r\nstruct mtk_vcodec_ctx *ctx = inst->ctx;\r\nmtk_vcodec_debug(inst, "opt %d ->", opt);\r\nenable_irq(ctx->dev->enc_irq);\r\nswitch (opt) {\r\ncase VENC_START_OPT_ENCODE_SEQUENCE_HEADER: {\r\nunsigned int bs_size_hdr;\r\nret = h264_encode_header(inst, bs_buf, &bs_size_hdr);\r\nif (ret)\r\ngoto encode_err;\r\nresult->bs_size = bs_size_hdr;\r\nresult->is_key_frm = false;\r\nbreak;\r\n}\r\ncase VENC_START_OPT_ENCODE_FRAME: {\r\nint hdr_sz;\r\nint hdr_sz_ext;\r\nint filler_sz = 0;\r\nconst int bs_alignment = 128;\r\nstruct mtk_vcodec_mem tmp_bs_buf;\r\nunsigned int bs_size_hdr;\r\nunsigned int bs_size_frm;\r\nif (!inst->prepend_hdr) {\r\nret = h264_encode_frame(inst, frm_buf, bs_buf,\r\n&result->bs_size);\r\nif (ret)\r\ngoto encode_err;\r\nresult->is_key_frm = inst->vpu_inst.is_key_frm;\r\nbreak;\r\n}\r\nmtk_vcodec_debug(inst, "h264_encode_frame prepend SPS/PPS");\r\nret = h264_encode_header(inst, bs_buf, &bs_size_hdr);\r\nif (ret)\r\ngoto encode_err;\r\nhdr_sz = bs_size_hdr;\r\nhdr_sz_ext = (hdr_sz & (bs_alignment - 1));\r\nif (hdr_sz_ext) {\r\nfiller_sz = bs_alignment - hdr_sz_ext;\r\nif (hdr_sz_ext + H264_FILLER_MARKER_SIZE > bs_alignment)\r\nfiller_sz += bs_alignment;\r\nh264_encode_filler(inst, bs_buf->va + hdr_sz,\r\nfiller_sz);\r\n}\r\ntmp_bs_buf.va = bs_buf->va + hdr_sz + filler_sz;\r\ntmp_bs_buf.dma_addr = bs_buf->dma_addr + hdr_sz + filler_sz;\r\ntmp_bs_buf.size = bs_buf->size - (hdr_sz + filler_sz);\r\nret = h264_encode_frame(inst, frm_buf, &tmp_bs_buf,\r\n&bs_size_frm);\r\nif (ret)\r\ngoto encode_err;\r\nresult->bs_size = hdr_sz + filler_sz + bs_size_frm;\r\nmtk_vcodec_debug(inst, "hdr %d filler %d frame %d bs %d",\r\nhdr_sz, filler_sz, bs_size_frm,\r\nresult->bs_size);\r\ninst->prepend_hdr = 0;\r\nresult->is_key_frm = inst->vpu_inst.is_key_frm;\r\nbreak;\r\n}\r\ndefault:\r\nmtk_vcodec_err(inst, "venc_start_opt %d not supported", opt);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nencode_err:\r\ndisable_irq(ctx->dev->enc_irq);\r\nmtk_vcodec_debug(inst, "opt %d <-", opt);\r\nreturn ret;\r\n}\r\nstatic int h264_enc_set_param(unsigned long handle,\r\nenum venc_set_param_type type,\r\nstruct venc_enc_param *enc_prm)\r\n{\r\nint ret = 0;\r\nstruct venc_h264_inst *inst = (struct venc_h264_inst *)handle;\r\nmtk_vcodec_debug(inst, "->type=%d", type);\r\nswitch (type) {\r\ncase VENC_SET_PARAM_ENC:\r\ninst->vsi->config.input_fourcc = enc_prm->input_yuv_fmt;\r\ninst->vsi->config.bitrate = enc_prm->bitrate;\r\ninst->vsi->config.pic_w = enc_prm->width;\r\ninst->vsi->config.pic_h = enc_prm->height;\r\ninst->vsi->config.buf_w = enc_prm->buf_width;\r\ninst->vsi->config.buf_h = enc_prm->buf_height;\r\ninst->vsi->config.gop_size = enc_prm->gop_size;\r\ninst->vsi->config.framerate = enc_prm->frm_rate;\r\ninst->vsi->config.intra_period = enc_prm->intra_period;\r\ninst->vsi->config.profile =\r\nh264_get_profile(inst, enc_prm->h264_profile);\r\ninst->vsi->config.level =\r\nh264_get_level(inst, enc_prm->h264_level);\r\ninst->vsi->config.wfd = 0;\r\nret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\r\nif (ret)\r\nbreak;\r\nif (inst->work_buf_allocated) {\r\nh264_enc_free_work_buf(inst);\r\ninst->work_buf_allocated = false;\r\n}\r\nret = h264_enc_alloc_work_buf(inst);\r\nif (ret)\r\nbreak;\r\ninst->work_buf_allocated = true;\r\nbreak;\r\ncase VENC_SET_PARAM_PREPEND_HEADER:\r\ninst->prepend_hdr = 1;\r\nmtk_vcodec_debug(inst, "set prepend header mode");\r\nbreak;\r\ndefault:\r\nret = vpu_enc_set_param(&inst->vpu_inst, type, enc_prm);\r\nbreak;\r\n}\r\nmtk_vcodec_debug_leave(inst);\r\nreturn ret;\r\n}\r\nstatic int h264_enc_deinit(unsigned long handle)\r\n{\r\nint ret = 0;\r\nstruct venc_h264_inst *inst = (struct venc_h264_inst *)handle;\r\nmtk_vcodec_debug_enter(inst);\r\nret = vpu_enc_deinit(&inst->vpu_inst);\r\nif (inst->work_buf_allocated)\r\nh264_enc_free_work_buf(inst);\r\nmtk_vcodec_debug_leave(inst);\r\nkfree(inst);\r\nreturn ret;\r\n}\r\nconst struct venc_common_if *get_h264_enc_comm_if(void)\r\n{\r\nreturn &venc_h264_if;\r\n}
