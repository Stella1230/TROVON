static irqreturn_t nspire_keypad_irq(int irq, void *dev_id)\r\n{\r\nstruct nspire_keypad *keypad = dev_id;\r\nstruct input_dev *input = keypad->input;\r\nunsigned short *keymap = input->keycode;\r\nunsigned int code;\r\nint row, col;\r\nu32 int_sts;\r\nu16 state[8];\r\nu16 bits, changed;\r\nint_sts = readl(keypad->reg_base + KEYPAD_INT) & keypad->int_mask;\r\nif (!int_sts)\r\nreturn IRQ_NONE;\r\nmemcpy_fromio(state, keypad->reg_base + KEYPAD_DATA, sizeof(state));\r\nfor (row = 0; row < KEYPAD_BITMASK_ROWS; row++) {\r\nbits = state[row];\r\nif (keypad->active_low)\r\nbits = ~bits;\r\nchanged = bits ^ keypad->state[row];\r\nif (!changed)\r\ncontinue;\r\nkeypad->state[row] = bits;\r\nfor (col = 0; col < KEYPAD_BITMASK_COLS; col++) {\r\nif (!(changed & (1U << col)))\r\ncontinue;\r\ncode = MATRIX_SCAN_CODE(row, col, keypad->row_shift);\r\ninput_event(input, EV_MSC, MSC_SCAN, code);\r\ninput_report_key(input, keymap[code],\r\nbits & (1U << col));\r\n}\r\n}\r\ninput_sync(input);\r\nwritel(0x3, keypad->reg_base + KEYPAD_INT);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int nspire_keypad_chip_init(struct nspire_keypad *keypad)\r\n{\r\nunsigned long val = 0, cycles_per_us, delay_cycles, row_delay_cycles;\r\ncycles_per_us = (clk_get_rate(keypad->clk) / 1000000);\r\nif (cycles_per_us == 0)\r\ncycles_per_us = 1;\r\ndelay_cycles = cycles_per_us * keypad->scan_interval;\r\nWARN_ON(delay_cycles >= (1 << 16));\r\ndelay_cycles &= 0xffff;\r\nrow_delay_cycles = cycles_per_us * keypad->row_delay;\r\nWARN_ON(row_delay_cycles >= (1 << 14));\r\nrow_delay_cycles &= 0x3fff;\r\nval |= 3 << 0;\r\nval |= row_delay_cycles << 2;\r\nval |= delay_cycles << 16;\r\nwritel(val, keypad->reg_base + KEYPAD_SCAN_MODE);\r\nval = (KEYPAD_BITMASK_ROWS & 0xff) | (KEYPAD_BITMASK_COLS & 0xff)<<8;\r\nwritel(val, keypad->reg_base + KEYPAD_CNTL);\r\nkeypad->int_mask = 1 << 1;\r\nwritel(keypad->int_mask, keypad->reg_base + KEYPAD_INTMSK);\r\nwritel(0, keypad->reg_base + KEYPAD_UNKNOWN_INT);\r\nwritel(~0, keypad->reg_base + KEYPAD_UNKNOWN_INT_STS);\r\nreturn 0;\r\n}\r\nstatic int nspire_keypad_open(struct input_dev *input)\r\n{\r\nstruct nspire_keypad *keypad = input_get_drvdata(input);\r\nint error;\r\nerror = clk_prepare_enable(keypad->clk);\r\nif (error)\r\nreturn error;\r\nerror = nspire_keypad_chip_init(keypad);\r\nif (error) {\r\nclk_disable_unprepare(keypad->clk);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void nspire_keypad_close(struct input_dev *input)\r\n{\r\nstruct nspire_keypad *keypad = input_get_drvdata(input);\r\nclk_disable_unprepare(keypad->clk);\r\n}\r\nstatic int nspire_keypad_probe(struct platform_device *pdev)\r\n{\r\nconst struct device_node *of_node = pdev->dev.of_node;\r\nstruct nspire_keypad *keypad;\r\nstruct input_dev *input;\r\nstruct resource *res;\r\nint irq;\r\nint error;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get keypad irq\n");\r\nreturn -EINVAL;\r\n}\r\nkeypad = devm_kzalloc(&pdev->dev, sizeof(struct nspire_keypad),\r\nGFP_KERNEL);\r\nif (!keypad) {\r\ndev_err(&pdev->dev, "failed to allocate keypad memory\n");\r\nreturn -ENOMEM;\r\n}\r\nkeypad->row_shift = get_count_order(KEYPAD_BITMASK_COLS);\r\nerror = of_property_read_u32(of_node, "scan-interval",\r\n&keypad->scan_interval);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to get scan-interval\n");\r\nreturn error;\r\n}\r\nerror = of_property_read_u32(of_node, "row-delay",\r\n&keypad->row_delay);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to get row-delay\n");\r\nreturn error;\r\n}\r\nkeypad->active_low = of_property_read_bool(of_node, "active-low");\r\nkeypad->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(keypad->clk)) {\r\ndev_err(&pdev->dev, "unable to get clock\n");\r\nreturn PTR_ERR(keypad->clk);\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nkeypad->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(keypad->reg_base))\r\nreturn PTR_ERR(keypad->reg_base);\r\nkeypad->input = input = devm_input_allocate_device(&pdev->dev);\r\nif (!input) {\r\ndev_err(&pdev->dev, "failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput_set_drvdata(input, keypad);\r\ninput->id.bustype = BUS_HOST;\r\ninput->name = "nspire-keypad";\r\ninput->open = nspire_keypad_open;\r\ninput->close = nspire_keypad_close;\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(EV_REP, input->evbit);\r\ninput_set_capability(input, EV_MSC, MSC_SCAN);\r\nerror = matrix_keypad_build_keymap(NULL, NULL,\r\nKEYPAD_BITMASK_ROWS,\r\nKEYPAD_BITMASK_COLS,\r\nNULL, input);\r\nif (error) {\r\ndev_err(&pdev->dev, "building keymap failed\n");\r\nreturn error;\r\n}\r\nerror = devm_request_irq(&pdev->dev, irq, nspire_keypad_irq, 0,\r\n"nspire_keypad", keypad);\r\nif (error) {\r\ndev_err(&pdev->dev, "allocate irq %d failed\n", irq);\r\nreturn error;\r\n}\r\nerror = input_register_device(input);\r\nif (error) {\r\ndev_err(&pdev->dev,\r\n"unable to register input device: %d\n", error);\r\nreturn error;\r\n}\r\ndev_dbg(&pdev->dev,\r\n"TI-NSPIRE keypad at %pR (scan_interval=%uus, row_delay=%uus%s)\n",\r\nres, keypad->row_delay, keypad->scan_interval,\r\nkeypad->active_low ? ", active_low" : "");\r\nreturn 0;\r\n}
