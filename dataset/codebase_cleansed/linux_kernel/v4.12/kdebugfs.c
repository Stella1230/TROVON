static ssize_t setup_data_read(struct file *file, char __user *user_buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct setup_data_node *node = file->private_data;\r\nunsigned long remain;\r\nloff_t pos = *ppos;\r\nstruct page *pg;\r\nvoid *p;\r\nu64 pa;\r\nif (pos < 0)\r\nreturn -EINVAL;\r\nif (pos >= node->len)\r\nreturn 0;\r\nif (count > node->len - pos)\r\ncount = node->len - pos;\r\npa = node->paddr + sizeof(struct setup_data) + pos;\r\npg = pfn_to_page((pa + count - 1) >> PAGE_SHIFT);\r\nif (PageHighMem(pg)) {\r\np = ioremap_cache(pa, count);\r\nif (!p)\r\nreturn -ENXIO;\r\n} else\r\np = __va(pa);\r\nremain = copy_to_user(user_buf, p, count);\r\nif (PageHighMem(pg))\r\niounmap(p);\r\nif (remain)\r\nreturn -EFAULT;\r\n*ppos = pos + count;\r\nreturn count;\r\n}\r\nstatic int __init\r\ncreate_setup_data_node(struct dentry *parent, int no,\r\nstruct setup_data_node *node)\r\n{\r\nstruct dentry *d, *type, *data;\r\nchar buf[16];\r\nsprintf(buf, "%d", no);\r\nd = debugfs_create_dir(buf, parent);\r\nif (!d)\r\nreturn -ENOMEM;\r\ntype = debugfs_create_x32("type", S_IRUGO, d, &node->type);\r\nif (!type)\r\ngoto err_dir;\r\ndata = debugfs_create_file("data", S_IRUGO, d, node, &fops_setup_data);\r\nif (!data)\r\ngoto err_type;\r\nreturn 0;\r\nerr_type:\r\ndebugfs_remove(type);\r\nerr_dir:\r\ndebugfs_remove(d);\r\nreturn -ENOMEM;\r\n}\r\nstatic int __init create_setup_data_nodes(struct dentry *parent)\r\n{\r\nstruct setup_data_node *node;\r\nstruct setup_data *data;\r\nint error;\r\nstruct dentry *d;\r\nstruct page *pg;\r\nu64 pa_data;\r\nint no = 0;\r\nd = debugfs_create_dir("setup_data", parent);\r\nif (!d)\r\nreturn -ENOMEM;\r\npa_data = boot_params.hdr.setup_data;\r\nwhile (pa_data) {\r\nnode = kmalloc(sizeof(*node), GFP_KERNEL);\r\nif (!node) {\r\nerror = -ENOMEM;\r\ngoto err_dir;\r\n}\r\npg = pfn_to_page((pa_data+sizeof(*data)-1) >> PAGE_SHIFT);\r\nif (PageHighMem(pg)) {\r\ndata = ioremap_cache(pa_data, sizeof(*data));\r\nif (!data) {\r\nkfree(node);\r\nerror = -ENXIO;\r\ngoto err_dir;\r\n}\r\n} else\r\ndata = __va(pa_data);\r\nnode->paddr = pa_data;\r\nnode->type = data->type;\r\nnode->len = data->len;\r\nerror = create_setup_data_node(d, no, node);\r\npa_data = data->next;\r\nif (PageHighMem(pg))\r\niounmap(data);\r\nif (error)\r\ngoto err_dir;\r\nno++;\r\n}\r\nreturn 0;\r\nerr_dir:\r\ndebugfs_remove(d);\r\nreturn error;\r\n}\r\nstatic int __init boot_params_kdebugfs_init(void)\r\n{\r\nstruct dentry *dbp, *version, *data;\r\nint error = -ENOMEM;\r\ndbp = debugfs_create_dir("boot_params", arch_debugfs_dir);\r\nif (!dbp)\r\nreturn -ENOMEM;\r\nversion = debugfs_create_x16("version", S_IRUGO, dbp,\r\n&boot_params.hdr.version);\r\nif (!version)\r\ngoto err_dir;\r\ndata = debugfs_create_blob("data", S_IRUGO, dbp,\r\n&boot_params_blob);\r\nif (!data)\r\ngoto err_version;\r\nerror = create_setup_data_nodes(dbp);\r\nif (error)\r\ngoto err_data;\r\nreturn 0;\r\nerr_data:\r\ndebugfs_remove(data);\r\nerr_version:\r\ndebugfs_remove(version);\r\nerr_dir:\r\ndebugfs_remove(dbp);\r\nreturn error;\r\n}\r\nstatic int __init arch_kdebugfs_init(void)\r\n{\r\nint error = 0;\r\narch_debugfs_dir = debugfs_create_dir("x86", NULL);\r\nif (!arch_debugfs_dir)\r\nreturn -ENOMEM;\r\n#ifdef CONFIG_DEBUG_BOOT_PARAMS\r\nerror = boot_params_kdebugfs_init();\r\n#endif\r\nreturn error;\r\n}
