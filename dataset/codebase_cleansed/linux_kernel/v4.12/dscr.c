static struct locked_reg *find_locked_reg(u32 reg)\r\n{\r\nint i;\r\nfor (i = 0; i < MAX_LOCKED_REGS; i++)\r\nif (dscr.locked[i].key && reg == dscr.locked[i].reg)\r\nreturn &dscr.locked[i];\r\nreturn NULL;\r\n}\r\nstatic void dscr_write_locked1(u32 reg, u32 val,\r\nu32 lock, u32 key)\r\n{\r\nvoid __iomem *reg_addr = dscr.base + reg;\r\nvoid __iomem *lock_addr = dscr.base + lock;\r\nasm volatile ("b .s2 0f\n"\r\n"nop 5\n"\r\n" .align 5\n"\r\n"0:\n"\r\n"stw .D1T2 %3,*%2\n"\r\n"stw .D1T2 %1,*%0\n"\r\n:\r\n: "a"(reg_addr), "b"(val), "a"(lock_addr), "b"(key)\r\n);\r\nsoc_writel(0, lock_addr);\r\n}\r\nstatic void dscr_write_locked2(u32 reg, u32 val,\r\nu32 lock0, u32 key0,\r\nu32 lock1, u32 key1)\r\n{\r\nsoc_writel(key0, dscr.base + lock0);\r\nsoc_writel(key1, dscr.base + lock1);\r\nsoc_writel(val, dscr.base + reg);\r\nsoc_writel(0, dscr.base + lock0);\r\nsoc_writel(0, dscr.base + lock1);\r\n}\r\nstatic void dscr_write(u32 reg, u32 val)\r\n{\r\nstruct locked_reg *lock;\r\nlock = find_locked_reg(reg);\r\nif (lock)\r\ndscr_write_locked1(reg, val, lock->lockreg, lock->key);\r\nelse if (dscr.kick_key[0])\r\ndscr_write_locked2(reg, val, dscr.kick_reg[0], dscr.kick_key[0],\r\ndscr.kick_reg[1], dscr.kick_key[1]);\r\nelse\r\nsoc_writel(val, dscr.base + reg);\r\n}\r\nvoid dscr_set_devstate(int id, enum dscr_devstate_t state)\r\n{\r\nstruct devstate_ctl_reg *ctl;\r\nstruct devstate_stat_reg *stat;\r\nstruct devstate_info *info;\r\nu32 ctl_val, val;\r\nint ctl_shift, ctl_mask;\r\nunsigned long flags;\r\nif (!dscr.base)\r\nreturn;\r\nif (id < 0 || id >= MAX_DEVSTATE_IDS)\r\nreturn;\r\ninfo = &dscr.devstate_info[id];\r\nctl = info->ctl;\r\nstat = info->stat;\r\nif (ctl == NULL)\r\nreturn;\r\nctl_shift = ctl->shift + ctl->nbits * (id - ctl->start_id);\r\nctl_mask = ((1 << ctl->nbits) - 1) << ctl_shift;\r\nswitch (state) {\r\ncase DSCR_DEVSTATE_ENABLED:\r\nctl_val = ctl->enable << ctl_shift;\r\nbreak;\r\ncase DSCR_DEVSTATE_DISABLED:\r\nif (ctl->enable_only)\r\nreturn;\r\nctl_val = ctl->disable << ctl_shift;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nspin_lock_irqsave(&dscr.lock, flags);\r\nval = soc_readl(dscr.base + ctl->reg);\r\nval &= ~ctl_mask;\r\nval |= ctl_val;\r\ndscr_write(ctl->reg, val);\r\nspin_unlock_irqrestore(&dscr.lock, flags);\r\nif (!stat)\r\nreturn;\r\nctl_shift = stat->shift + stat->nbits * (id - stat->start_id);\r\nif (state == DSCR_DEVSTATE_ENABLED)\r\nctl_val = stat->enable;\r\nelse\r\nctl_val = stat->disable;\r\ndo {\r\nval = soc_readl(dscr.base + stat->reg);\r\nval >>= ctl_shift;\r\nval &= ((1 << stat->nbits) - 1);\r\n} while (val != ctl_val);\r\n}\r\nvoid dscr_rmii_reset(int id, int assert)\r\n{\r\nstruct rmii_reset_reg *r;\r\nunsigned long flags;\r\nu32 val;\r\nif (id < 0 || id >= MAX_SOC_EMACS)\r\nreturn;\r\nr = &dscr.rmii_resets[id];\r\nif (r->mask == 0)\r\nreturn;\r\nspin_lock_irqsave(&dscr.lock, flags);\r\nval = soc_readl(dscr.base + r->reg);\r\nif (assert)\r\ndscr_write(r->reg, val | r->mask);\r\nelse\r\ndscr_write(r->reg, val & ~(r->mask));\r\nspin_unlock_irqrestore(&dscr.lock, flags);\r\n}\r\nstatic void __init dscr_parse_devstat(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nu32 val;\r\nint err;\r\nerr = of_property_read_u32_array(node, "ti,dscr-devstat", &val, 1);\r\nif (!err)\r\nc6x_devstat = soc_readl(base + val);\r\nprintk(KERN_INFO "DEVSTAT: %08x\n", c6x_devstat);\r\n}\r\nstatic void __init dscr_parse_silicon_rev(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nu32 vals[3];\r\nint err;\r\nerr = of_property_read_u32_array(node, "ti,dscr-silicon-rev", vals, 3);\r\nif (!err) {\r\nc6x_silicon_rev = soc_readl(base + vals[0]);\r\nc6x_silicon_rev >>= vals[1];\r\nc6x_silicon_rev &= vals[2];\r\n}\r\n}\r\nstatic void __init dscr_parse_mac_fuse(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nu32 vals[10], fuse;\r\nint f, i, j, err;\r\nerr = of_property_read_u32_array(node, "ti,dscr-mac-fuse-regs",\r\nvals, 10);\r\nif (err)\r\nreturn;\r\nfor (f = 0; f < 2; f++) {\r\nfuse = soc_readl(base + vals[f * 5]);\r\nfor (j = (f * 5) + 1, i = 24; i >= 0; i -= 8, j++)\r\nif (vals[j] && vals[j] <= 6)\r\nc6x_fuse_mac[vals[j] - 1] = fuse >> i;\r\n}\r\n}\r\nstatic void __init dscr_parse_rmii_resets(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nconst __be32 *p;\r\nint i, size;\r\np = of_get_property(node, "ti,dscr-rmii-resets", &size);\r\nif (p) {\r\nsize /= (sizeof(*p) * 2);\r\nif (size > MAX_SOC_EMACS)\r\nsize = MAX_SOC_EMACS;\r\nfor (i = 0; i < size; i++) {\r\ndscr.rmii_resets[i].reg = be32_to_cpup(p++);\r\ndscr.rmii_resets[i].mask = be32_to_cpup(p++);\r\n}\r\n}\r\n}\r\nstatic void __init dscr_parse_privperm(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nu32 vals[2];\r\nint err;\r\nerr = of_property_read_u32_array(node, "ti,dscr-privperm", vals, 2);\r\nif (err)\r\nreturn;\r\ndscr_write(vals[0], vals[1]);\r\n}\r\nstatic void __init dscr_parse_locked_regs(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nstruct locked_reg *r;\r\nconst __be32 *p;\r\nint i, size;\r\np = of_get_property(node, "ti,dscr-locked-regs", &size);\r\nif (p) {\r\nsize /= (sizeof(*p) * 3);\r\nif (size > MAX_LOCKED_REGS)\r\nsize = MAX_LOCKED_REGS;\r\nfor (i = 0; i < size; i++) {\r\nr = &dscr.locked[i];\r\nr->reg = be32_to_cpup(p++);\r\nr->lockreg = be32_to_cpup(p++);\r\nr->key = be32_to_cpup(p++);\r\n}\r\n}\r\n}\r\nstatic void __init dscr_parse_kick_regs(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nu32 vals[4];\r\nint err;\r\nerr = of_property_read_u32_array(node, "ti,dscr-kick-regs", vals, 4);\r\nif (!err) {\r\ndscr.kick_reg[0] = vals[0];\r\ndscr.kick_key[0] = vals[1];\r\ndscr.kick_reg[1] = vals[2];\r\ndscr.kick_key[1] = vals[3];\r\n}\r\n}\r\nstatic void __init dscr_parse_devstate_ctl_regs(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nstruct devstate_ctl_reg *r;\r\nconst __be32 *p;\r\nint i, j, size;\r\np = of_get_property(node, "ti,dscr-devstate-ctl-regs", &size);\r\nif (p) {\r\nsize /= (sizeof(*p) * 7);\r\nif (size > MAX_DEVCTL_REGS)\r\nsize = MAX_DEVCTL_REGS;\r\nfor (i = 0; i < size; i++) {\r\nr = &dscr.devctl[i];\r\nr->start_id = be32_to_cpup(p++);\r\nr->num_ids = be32_to_cpup(p++);\r\nr->reg = be32_to_cpup(p++);\r\nr->enable = be32_to_cpup(p++);\r\nr->disable = be32_to_cpup(p++);\r\nif (r->disable == 0xffffffff)\r\nr->enable_only = 1;\r\nr->shift = be32_to_cpup(p++);\r\nr->nbits = be32_to_cpup(p++);\r\nfor (j = r->start_id;\r\nj < (r->start_id + r->num_ids);\r\nj++)\r\ndscr.devstate_info[j].ctl = r;\r\n}\r\n}\r\n}\r\nstatic void __init dscr_parse_devstate_stat_regs(struct device_node *node,\r\nvoid __iomem *base)\r\n{\r\nstruct devstate_stat_reg *r;\r\nconst __be32 *p;\r\nint i, j, size;\r\np = of_get_property(node, "ti,dscr-devstate-stat-regs", &size);\r\nif (p) {\r\nsize /= (sizeof(*p) * 7);\r\nif (size > MAX_DEVSTAT_REGS)\r\nsize = MAX_DEVSTAT_REGS;\r\nfor (i = 0; i < size; i++) {\r\nr = &dscr.devstat[i];\r\nr->start_id = be32_to_cpup(p++);\r\nr->num_ids = be32_to_cpup(p++);\r\nr->reg = be32_to_cpup(p++);\r\nr->enable = be32_to_cpup(p++);\r\nr->disable = be32_to_cpup(p++);\r\nr->shift = be32_to_cpup(p++);\r\nr->nbits = be32_to_cpup(p++);\r\nfor (j = r->start_id;\r\nj < (r->start_id + r->num_ids);\r\nj++)\r\ndscr.devstate_info[j].stat = r;\r\n}\r\n}\r\n}\r\nvoid __init dscr_probe(void)\r\n{\r\nstruct device_node *node;\r\nvoid __iomem *base;\r\nspin_lock_init(&dscr.lock);\r\nnode = of_find_matching_node(NULL, dscr_ids);\r\nif (!node)\r\nreturn;\r\nbase = of_iomap(node, 0);\r\nif (!base) {\r\nof_node_put(node);\r\nreturn;\r\n}\r\ndscr.base = base;\r\ndscr_parse_devstat(node, base);\r\ndscr_parse_silicon_rev(node, base);\r\ndscr_parse_mac_fuse(node, base);\r\ndscr_parse_rmii_resets(node, base);\r\ndscr_parse_locked_regs(node, base);\r\ndscr_parse_kick_regs(node, base);\r\ndscr_parse_devstate_ctl_regs(node, base);\r\ndscr_parse_devstate_stat_regs(node, base);\r\ndscr_parse_privperm(node, base);\r\n}
