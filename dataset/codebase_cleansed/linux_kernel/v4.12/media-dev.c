static void __setup_sensor_notification(struct fimc_md *fmd,\r\nstruct v4l2_subdev *sensor,\r\nstruct v4l2_subdev *fimc_sd)\r\n{\r\nstruct fimc_source_info *src_inf;\r\nstruct fimc_sensor_info *md_si;\r\nunsigned long flags;\r\nsrc_inf = v4l2_get_subdev_hostdata(sensor);\r\nif (!src_inf || WARN_ON(fmd == NULL))\r\nreturn;\r\nmd_si = source_to_sensor_info(src_inf);\r\nspin_lock_irqsave(&fmd->slock, flags);\r\nmd_si->host = v4l2_get_subdevdata(fimc_sd);\r\nspin_unlock_irqrestore(&fmd->slock, flags);\r\n}\r\nstatic void fimc_pipeline_prepare(struct fimc_pipeline *p,\r\nstruct media_entity *me)\r\n{\r\nstruct fimc_md *fmd = entity_to_fimc_mdev(me);\r\nstruct v4l2_subdev *sd;\r\nstruct v4l2_subdev *sensor = NULL;\r\nint i;\r\nfor (i = 0; i < IDX_MAX; i++)\r\np->subdevs[i] = NULL;\r\nwhile (1) {\r\nstruct media_pad *pad = NULL;\r\nfor (i = 0; i < me->num_pads; i++) {\r\nstruct media_pad *spad = &me->pads[i];\r\nif (!(spad->flags & MEDIA_PAD_FL_SINK))\r\ncontinue;\r\npad = media_entity_remote_pad(spad);\r\nif (pad)\r\nbreak;\r\n}\r\nif (!pad || !is_media_entity_v4l2_subdev(pad->entity))\r\nbreak;\r\nsd = media_entity_to_v4l2_subdev(pad->entity);\r\nswitch (sd->grp_id) {\r\ncase GRP_ID_SENSOR:\r\nsensor = sd;\r\ncase GRP_ID_FIMC_IS_SENSOR:\r\np->subdevs[IDX_SENSOR] = sd;\r\nbreak;\r\ncase GRP_ID_CSIS:\r\np->subdevs[IDX_CSIS] = sd;\r\nbreak;\r\ncase GRP_ID_FLITE:\r\np->subdevs[IDX_FLITE] = sd;\r\nbreak;\r\ncase GRP_ID_FIMC:\r\np->subdevs[IDX_FIMC] = sd;\r\nbreak;\r\ncase GRP_ID_FIMC_IS:\r\np->subdevs[IDX_IS_ISP] = sd;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nme = &sd->entity;\r\nif (me->num_pads == 1)\r\nbreak;\r\n}\r\nif (sensor && p->subdevs[IDX_FIMC])\r\n__setup_sensor_notification(fmd, sensor, p->subdevs[IDX_FIMC]);\r\n}\r\nstatic int __subdev_set_power(struct v4l2_subdev *sd, int on)\r\n{\r\nint *use_count;\r\nint ret;\r\nif (sd == NULL)\r\nreturn -ENXIO;\r\nuse_count = &sd->entity.use_count;\r\nif (on && (*use_count)++ > 0)\r\nreturn 0;\r\nelse if (!on && (*use_count == 0 || --(*use_count) > 0))\r\nreturn 0;\r\nret = v4l2_subdev_call(sd, core, s_power, on);\r\nreturn ret != -ENOIOCTLCMD ? ret : 0;\r\n}\r\nstatic int fimc_pipeline_s_power(struct fimc_pipeline *p, bool on)\r\n{\r\nstatic const u8 seq[2][IDX_MAX - 1] = {\r\n{ IDX_IS_ISP, IDX_SENSOR, IDX_CSIS, IDX_FLITE },\r\n{ IDX_CSIS, IDX_FLITE, IDX_SENSOR, IDX_IS_ISP },\r\n};\r\nint i, ret = 0;\r\nif (p->subdevs[IDX_SENSOR] == NULL)\r\nreturn -ENXIO;\r\nfor (i = 0; i < IDX_MAX - 1; i++) {\r\nunsigned int idx = seq[on][i];\r\nret = __subdev_set_power(p->subdevs[idx], on);\r\nif (ret < 0 && ret != -ENXIO)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nfor (; i >= 0; i--) {\r\nunsigned int idx = seq[on][i];\r\n__subdev_set_power(p->subdevs[idx], !on);\r\n}\r\nreturn ret;\r\n}\r\nstatic int __fimc_pipeline_enable(struct exynos_media_pipeline *ep,\r\nstruct fimc_md *fmd)\r\n{\r\nstruct fimc_pipeline *p = to_fimc_pipeline(ep);\r\nint ret;\r\nif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP]) {\r\nret = clk_prepare_enable(fmd->wbclk[CLK_IDX_WB_B]);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = fimc_pipeline_s_power(p, 1);\r\nif (!ret)\r\nreturn 0;\r\nif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP])\r\nclk_disable_unprepare(fmd->wbclk[CLK_IDX_WB_B]);\r\nreturn ret;\r\n}\r\nstatic int __fimc_pipeline_open(struct exynos_media_pipeline *ep,\r\nstruct media_entity *me, bool prepare)\r\n{\r\nstruct fimc_md *fmd = entity_to_fimc_mdev(me);\r\nstruct fimc_pipeline *p = to_fimc_pipeline(ep);\r\nstruct v4l2_subdev *sd;\r\nif (WARN_ON(p == NULL || me == NULL))\r\nreturn -EINVAL;\r\nif (prepare)\r\nfimc_pipeline_prepare(p, me);\r\nsd = p->subdevs[IDX_SENSOR];\r\nif (sd == NULL) {\r\npr_warn("%s(): No sensor subdev\n", __func__);\r\nreturn 0;\r\n}\r\nreturn __fimc_pipeline_enable(ep, fmd);\r\n}\r\nstatic int __fimc_pipeline_close(struct exynos_media_pipeline *ep)\r\n{\r\nstruct fimc_pipeline *p = to_fimc_pipeline(ep);\r\nstruct v4l2_subdev *sd = p ? p->subdevs[IDX_SENSOR] : NULL;\r\nstruct fimc_md *fmd;\r\nint ret;\r\nif (sd == NULL) {\r\npr_warn("%s(): No sensor subdev\n", __func__);\r\nreturn 0;\r\n}\r\nret = fimc_pipeline_s_power(p, 0);\r\nfmd = entity_to_fimc_mdev(&sd->entity);\r\nif (!IS_ERR(fmd->wbclk[CLK_IDX_WB_B]) && p->subdevs[IDX_IS_ISP])\r\nclk_disable_unprepare(fmd->wbclk[CLK_IDX_WB_B]);\r\nreturn ret == -ENXIO ? 0 : ret;\r\n}\r\nstatic int __fimc_pipeline_s_stream(struct exynos_media_pipeline *ep, bool on)\r\n{\r\nstatic const u8 seq[2][IDX_MAX] = {\r\n{ IDX_FIMC, IDX_SENSOR, IDX_IS_ISP, IDX_CSIS, IDX_FLITE },\r\n{ IDX_CSIS, IDX_FLITE, IDX_FIMC, IDX_SENSOR, IDX_IS_ISP },\r\n};\r\nstruct fimc_pipeline *p = to_fimc_pipeline(ep);\r\nstruct fimc_md *fmd = entity_to_fimc_mdev(&p->subdevs[IDX_CSIS]->entity);\r\nenum fimc_subdev_index sd_id;\r\nint i, ret = 0;\r\nif (p->subdevs[IDX_SENSOR] == NULL) {\r\nif (!fmd->user_subdev_api) {\r\nreturn -ENODEV;\r\n}\r\nif (p->subdevs[IDX_FIMC])\r\nsd_id = IDX_FIMC;\r\nelse if (p->subdevs[IDX_IS_ISP])\r\nsd_id = IDX_IS_ISP;\r\nelse if (p->subdevs[IDX_FLITE])\r\nsd_id = IDX_FLITE;\r\nelse\r\nreturn -ENODEV;\r\nfimc_pipeline_prepare(p, &p->subdevs[sd_id]->entity);\r\nif (p->subdevs[IDX_SENSOR] == NULL)\r\nreturn -ENODEV;\r\nret = __fimc_pipeline_enable(ep, fmd);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nfor (i = 0; i < IDX_MAX; i++) {\r\nunsigned int idx = seq[on][i];\r\nret = v4l2_subdev_call(p->subdevs[idx], video, s_stream, on);\r\nif (ret < 0 && ret != -ENOIOCTLCMD && ret != -ENODEV)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nfimc_pipeline_s_power(p, !on);\r\nfor (; i >= 0; i--) {\r\nunsigned int idx = seq[on][i];\r\nv4l2_subdev_call(p->subdevs[idx], video, s_stream, !on);\r\n}\r\nreturn ret;\r\n}\r\nstatic struct exynos_media_pipeline *fimc_md_pipeline_create(\r\nstruct fimc_md *fmd)\r\n{\r\nstruct fimc_pipeline *p;\r\np = kzalloc(sizeof(*p), GFP_KERNEL);\r\nif (!p)\r\nreturn NULL;\r\nlist_add_tail(&p->list, &fmd->pipelines);\r\np->ep.ops = &fimc_pipeline_ops;\r\nreturn &p->ep;\r\n}\r\nstatic void fimc_md_pipelines_free(struct fimc_md *fmd)\r\n{\r\nwhile (!list_empty(&fmd->pipelines)) {\r\nstruct fimc_pipeline *p;\r\np = list_entry(fmd->pipelines.next, typeof(*p), list);\r\nlist_del(&p->list);\r\nkfree(p);\r\n}\r\n}\r\nstatic int fimc_md_parse_port_node(struct fimc_md *fmd,\r\nstruct device_node *port,\r\nunsigned int index)\r\n{\r\nstruct fimc_source_info *pd = &fmd->sensor[index].pdata;\r\nstruct device_node *rem, *ep, *np;\r\nstruct v4l2_of_endpoint endpoint;\r\nint ret;\r\nep = of_get_next_child(port, NULL);\r\nif (!ep)\r\nreturn 0;\r\nret = v4l2_of_parse_endpoint(ep, &endpoint);\r\nif (ret) {\r\nof_node_put(ep);\r\nreturn ret;\r\n}\r\nif (WARN_ON(endpoint.base.port == 0) || index >= FIMC_MAX_SENSORS) {\r\nof_node_put(ep);\r\nreturn -EINVAL;\r\n}\r\npd->mux_id = (endpoint.base.port - 1) & 0x1;\r\nrem = of_graph_get_remote_port_parent(ep);\r\nof_node_put(ep);\r\nif (rem == NULL) {\r\nv4l2_info(&fmd->v4l2_dev, "Remote device at %s not found\n",\r\nep->full_name);\r\nreturn 0;\r\n}\r\nif (fimc_input_is_parallel(endpoint.base.port)) {\r\nif (endpoint.bus_type == V4L2_MBUS_PARALLEL)\r\npd->sensor_bus_type = FIMC_BUS_TYPE_ITU_601;\r\nelse\r\npd->sensor_bus_type = FIMC_BUS_TYPE_ITU_656;\r\npd->flags = endpoint.bus.parallel.flags;\r\n} else if (fimc_input_is_mipi_csi(endpoint.base.port)) {\r\npd->sensor_bus_type = FIMC_BUS_TYPE_MIPI_CSI2;\r\n} else {\r\nv4l2_err(&fmd->v4l2_dev, "Wrong port id (%u) at node %s\n",\r\nendpoint.base.port, rem->full_name);\r\n}\r\nnp = of_get_parent(rem);\r\nif (np && !of_node_cmp(np->name, "i2c-isp"))\r\npd->fimc_bus_type = FIMC_BUS_TYPE_ISP_WRITEBACK;\r\nelse\r\npd->fimc_bus_type = pd->sensor_bus_type;\r\nif (WARN_ON(index >= ARRAY_SIZE(fmd->sensor))) {\r\nof_node_put(rem);\r\nreturn -EINVAL;\r\n}\r\nfmd->sensor[index].asd.match_type = V4L2_ASYNC_MATCH_OF;\r\nfmd->sensor[index].asd.match.of.node = rem;\r\nfmd->async_subdevs[index] = &fmd->sensor[index].asd;\r\nfmd->num_sensors++;\r\nof_node_put(rem);\r\nreturn 0;\r\n}\r\nstatic int fimc_md_register_sensor_entities(struct fimc_md *fmd)\r\n{\r\nstruct device_node *parent = fmd->pdev->dev.of_node;\r\nstruct device_node *node, *ports;\r\nint index = 0;\r\nint ret;\r\nif (!fmd->pmf)\r\nreturn -ENXIO;\r\nret = pm_runtime_get_sync(fmd->pmf);\r\nif (ret < 0)\r\nreturn ret;\r\nfmd->num_sensors = 0;\r\nfor_each_available_child_of_node(parent, node) {\r\nstruct device_node *port;\r\nif (of_node_cmp(node->name, "csis"))\r\ncontinue;\r\nport = of_get_next_child(node, NULL);\r\nif (!port)\r\ncontinue;\r\nret = fimc_md_parse_port_node(fmd, port, index);\r\nif (ret < 0) {\r\nof_node_put(node);\r\ngoto rpm_put;\r\n}\r\nindex++;\r\n}\r\nports = of_get_child_by_name(parent, "parallel-ports");\r\nif (!ports)\r\ngoto rpm_put;\r\nfor_each_child_of_node(ports, node) {\r\nret = fimc_md_parse_port_node(fmd, node, index);\r\nif (ret < 0) {\r\nof_node_put(node);\r\nbreak;\r\n}\r\nindex++;\r\n}\r\nrpm_put:\r\npm_runtime_put(fmd->pmf);\r\nreturn ret;\r\n}\r\nstatic int __of_get_csis_id(struct device_node *np)\r\n{\r\nu32 reg = 0;\r\nnp = of_get_child_by_name(np, "port");\r\nif (!np)\r\nreturn -EINVAL;\r\nof_property_read_u32(np, "reg", &reg);\r\nreturn reg - FIMC_INPUT_MIPI_CSI2_0;\r\n}\r\nstatic int register_fimc_lite_entity(struct fimc_md *fmd,\r\nstruct fimc_lite *fimc_lite)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct exynos_media_pipeline *ep;\r\nint ret;\r\nif (WARN_ON(fimc_lite->index >= FIMC_LITE_MAX_DEVS ||\r\nfmd->fimc_lite[fimc_lite->index]))\r\nreturn -EBUSY;\r\nsd = &fimc_lite->subdev;\r\nsd->grp_id = GRP_ID_FLITE;\r\nep = fimc_md_pipeline_create(fmd);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nv4l2_set_subdev_hostdata(sd, ep);\r\nret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\r\nif (!ret)\r\nfmd->fimc_lite[fimc_lite->index] = fimc_lite;\r\nelse\r\nv4l2_err(&fmd->v4l2_dev, "Failed to register FIMC.LITE%d\n",\r\nfimc_lite->index);\r\nreturn ret;\r\n}\r\nstatic int register_fimc_entity(struct fimc_md *fmd, struct fimc_dev *fimc)\r\n{\r\nstruct v4l2_subdev *sd;\r\nstruct exynos_media_pipeline *ep;\r\nint ret;\r\nif (WARN_ON(fimc->id >= FIMC_MAX_DEVS || fmd->fimc[fimc->id]))\r\nreturn -EBUSY;\r\nsd = &fimc->vid_cap.subdev;\r\nsd->grp_id = GRP_ID_FIMC;\r\nep = fimc_md_pipeline_create(fmd);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nv4l2_set_subdev_hostdata(sd, ep);\r\nret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\r\nif (!ret) {\r\nif (!fmd->pmf && fimc->pdev)\r\nfmd->pmf = &fimc->pdev->dev;\r\nfmd->fimc[fimc->id] = fimc;\r\nfimc->vid_cap.user_subdev_api = fmd->user_subdev_api;\r\n} else {\r\nv4l2_err(&fmd->v4l2_dev, "Failed to register FIMC.%d (%d)\n",\r\nfimc->id, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int register_csis_entity(struct fimc_md *fmd,\r\nstruct platform_device *pdev,\r\nstruct v4l2_subdev *sd)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nint id, ret;\r\nid = node ? __of_get_csis_id(node) : max(0, pdev->id);\r\nif (WARN_ON(id < 0 || id >= CSIS_MAX_ENTITIES))\r\nreturn -ENOENT;\r\nif (WARN_ON(fmd->csis[id].sd))\r\nreturn -EBUSY;\r\nsd->grp_id = GRP_ID_CSIS;\r\nret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\r\nif (!ret)\r\nfmd->csis[id].sd = sd;\r\nelse\r\nv4l2_err(&fmd->v4l2_dev,\r\n"Failed to register MIPI-CSIS.%d (%d)\n", id, ret);\r\nreturn ret;\r\n}\r\nstatic int register_fimc_is_entity(struct fimc_md *fmd, struct fimc_is *is)\r\n{\r\nstruct v4l2_subdev *sd = &is->isp.subdev;\r\nstruct exynos_media_pipeline *ep;\r\nint ret;\r\nep = fimc_md_pipeline_create(fmd);\r\nif (!ep)\r\nreturn -ENOMEM;\r\nv4l2_set_subdev_hostdata(sd, ep);\r\nret = v4l2_device_register_subdev(&fmd->v4l2_dev, sd);\r\nif (ret) {\r\nv4l2_err(&fmd->v4l2_dev,\r\n"Failed to register FIMC-ISP (%d)\n", ret);\r\nreturn ret;\r\n}\r\nfmd->fimc_is = is;\r\nreturn 0;\r\n}\r\nstatic int fimc_md_register_platform_entity(struct fimc_md *fmd,\r\nstruct platform_device *pdev,\r\nint plat_entity)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nint ret = -EPROBE_DEFER;\r\nvoid *drvdata;\r\ndevice_lock(dev);\r\nif (!dev->driver || !try_module_get(dev->driver->owner))\r\ngoto dev_unlock;\r\ndrvdata = dev_get_drvdata(dev);\r\nif (drvdata) {\r\nswitch (plat_entity) {\r\ncase IDX_FIMC:\r\nret = register_fimc_entity(fmd, drvdata);\r\nbreak;\r\ncase IDX_FLITE:\r\nret = register_fimc_lite_entity(fmd, drvdata);\r\nbreak;\r\ncase IDX_CSIS:\r\nret = register_csis_entity(fmd, pdev, drvdata);\r\nbreak;\r\ncase IDX_IS_ISP:\r\nret = register_fimc_is_entity(fmd, drvdata);\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\n}\r\n}\r\nmodule_put(dev->driver->owner);\r\ndev_unlock:\r\ndevice_unlock(dev);\r\nif (ret == -EPROBE_DEFER)\r\ndev_info(&fmd->pdev->dev, "deferring %s device registration\n",\r\ndev_name(dev));\r\nelse if (ret < 0)\r\ndev_err(&fmd->pdev->dev, "%s device registration failed (%d)\n",\r\ndev_name(dev), ret);\r\nreturn ret;\r\n}\r\nstatic int fimc_md_register_platform_entities(struct fimc_md *fmd,\r\nstruct device_node *parent)\r\n{\r\nstruct device_node *node;\r\nint ret = 0;\r\nfor_each_available_child_of_node(parent, node) {\r\nstruct platform_device *pdev;\r\nint plat_entity = -1;\r\npdev = of_find_device_by_node(node);\r\nif (!pdev)\r\ncontinue;\r\nif (!strcmp(node->name, CSIS_OF_NODE_NAME))\r\nplat_entity = IDX_CSIS;\r\nelse if (!strcmp(node->name, FIMC_IS_OF_NODE_NAME))\r\nplat_entity = IDX_IS_ISP;\r\nelse if (!strcmp(node->name, FIMC_LITE_OF_NODE_NAME))\r\nplat_entity = IDX_FLITE;\r\nelse if (!strcmp(node->name, FIMC_OF_NODE_NAME) &&\r\n!of_property_read_bool(node, "samsung,lcd-wb"))\r\nplat_entity = IDX_FIMC;\r\nif (plat_entity >= 0)\r\nret = fimc_md_register_platform_entity(fmd, pdev,\r\nplat_entity);\r\nput_device(&pdev->dev);\r\nif (ret < 0) {\r\nof_node_put(node);\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void fimc_md_unregister_entities(struct fimc_md *fmd)\r\n{\r\nint i;\r\nfor (i = 0; i < FIMC_MAX_DEVS; i++) {\r\nstruct fimc_dev *dev = fmd->fimc[i];\r\nif (dev == NULL)\r\ncontinue;\r\nv4l2_device_unregister_subdev(&dev->vid_cap.subdev);\r\ndev->vid_cap.ve.pipe = NULL;\r\nfmd->fimc[i] = NULL;\r\n}\r\nfor (i = 0; i < FIMC_LITE_MAX_DEVS; i++) {\r\nstruct fimc_lite *dev = fmd->fimc_lite[i];\r\nif (dev == NULL)\r\ncontinue;\r\nv4l2_device_unregister_subdev(&dev->subdev);\r\ndev->ve.pipe = NULL;\r\nfmd->fimc_lite[i] = NULL;\r\n}\r\nfor (i = 0; i < CSIS_MAX_ENTITIES; i++) {\r\nif (fmd->csis[i].sd == NULL)\r\ncontinue;\r\nv4l2_device_unregister_subdev(fmd->csis[i].sd);\r\nfmd->csis[i].sd = NULL;\r\n}\r\nif (fmd->fimc_is)\r\nv4l2_device_unregister_subdev(&fmd->fimc_is->isp.subdev);\r\nv4l2_info(&fmd->v4l2_dev, "Unregistered all entities\n");\r\n}\r\nstatic int __fimc_md_create_fimc_sink_links(struct fimc_md *fmd,\r\nstruct media_entity *source,\r\nstruct v4l2_subdev *sensor,\r\nint pad, int link_mask)\r\n{\r\nstruct fimc_source_info *si = NULL;\r\nstruct media_entity *sink;\r\nunsigned int flags = 0;\r\nint i, ret = 0;\r\nif (sensor) {\r\nsi = v4l2_get_subdev_hostdata(sensor);\r\nif (si && si->fimc_bus_type == FIMC_BUS_TYPE_ISP_WRITEBACK)\r\nret = 1;\r\n}\r\nfor (i = 0; !ret && i < FIMC_MAX_DEVS; i++) {\r\nif (!fmd->fimc[i])\r\ncontinue;\r\nif (!fmd->fimc[i]->variant->has_cam_if)\r\ncontinue;\r\nflags = ((1 << i) & link_mask) ? MEDIA_LNK_FL_ENABLED : 0;\r\nsink = &fmd->fimc[i]->vid_cap.subdev.entity;\r\nret = media_create_pad_link(source, pad, sink,\r\nFIMC_SD_PAD_SINK_CAM, flags);\r\nif (ret)\r\nreturn ret;\r\nret = media_entity_call(sink, link_setup, &sink->pads[0],\r\n&source->pads[pad], flags);\r\nif (ret)\r\nbreak;\r\nv4l2_info(&fmd->v4l2_dev, "created link [%s] %c> [%s]\n",\r\nsource->name, flags ? '=' : '-', sink->name);\r\n}\r\nfor (i = 0; i < FIMC_LITE_MAX_DEVS; i++) {\r\nif (!fmd->fimc_lite[i])\r\ncontinue;\r\nsink = &fmd->fimc_lite[i]->subdev.entity;\r\nret = media_create_pad_link(source, pad, sink,\r\nFLITE_SD_PAD_SINK, 0);\r\nif (ret)\r\nreturn ret;\r\nret = media_entity_call(sink, link_setup, &sink->pads[0],\r\n&source->pads[pad], 0);\r\nif (ret)\r\nbreak;\r\nv4l2_info(&fmd->v4l2_dev, "created link [%s] -> [%s]\n",\r\nsource->name, sink->name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __fimc_md_create_flite_source_links(struct fimc_md *fmd)\r\n{\r\nstruct media_entity *source, *sink;\r\nint i, ret = 0;\r\nfor (i = 0; i < FIMC_LITE_MAX_DEVS; i++) {\r\nstruct fimc_lite *fimc = fmd->fimc_lite[i];\r\nif (fimc == NULL)\r\ncontinue;\r\nsource = &fimc->subdev.entity;\r\nsink = &fimc->ve.vdev.entity;\r\nret = media_create_pad_link(source, FLITE_SD_PAD_SOURCE_DMA,\r\nsink, 0, 0);\r\nif (ret)\r\nbreak;\r\nsink = &fmd->fimc_is->isp.subdev.entity;\r\nret = media_create_pad_link(source, FLITE_SD_PAD_SOURCE_ISP,\r\nsink, 0, 0);\r\nif (ret)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __fimc_md_create_fimc_is_links(struct fimc_md *fmd)\r\n{\r\nstruct fimc_isp *isp = &fmd->fimc_is->isp;\r\nstruct media_entity *source, *sink;\r\nint i, ret;\r\nsource = &isp->subdev.entity;\r\nfor (i = 0; i < FIMC_MAX_DEVS; i++) {\r\nif (fmd->fimc[i] == NULL)\r\ncontinue;\r\nsink = &fmd->fimc[i]->vid_cap.subdev.entity;\r\nret = media_create_pad_link(source, FIMC_ISP_SD_PAD_SRC_FIFO,\r\nsink, FIMC_SD_PAD_SINK_FIFO, 0);\r\nif (ret)\r\nreturn ret;\r\n}\r\nsink = &isp->video_capture.ve.vdev.entity;\r\nif (sink->num_pads == 0)\r\nreturn 0;\r\nreturn media_create_pad_link(source, FIMC_ISP_SD_PAD_SRC_DMA,\r\nsink, 0, 0);\r\n}\r\nstatic int fimc_md_create_links(struct fimc_md *fmd)\r\n{\r\nstruct v4l2_subdev *csi_sensors[CSIS_MAX_ENTITIES] = { NULL };\r\nstruct v4l2_subdev *sensor, *csis;\r\nstruct fimc_source_info *pdata;\r\nstruct media_entity *source, *sink;\r\nint i, pad, fimc_id = 0, ret = 0;\r\nu32 flags, link_mask = 0;\r\nfor (i = 0; i < fmd->num_sensors; i++) {\r\nif (fmd->sensor[i].subdev == NULL)\r\ncontinue;\r\nsensor = fmd->sensor[i].subdev;\r\npdata = v4l2_get_subdev_hostdata(sensor);\r\nif (!pdata)\r\ncontinue;\r\nsource = NULL;\r\nswitch (pdata->sensor_bus_type) {\r\ncase FIMC_BUS_TYPE_MIPI_CSI2:\r\nif (WARN(pdata->mux_id >= CSIS_MAX_ENTITIES,\r\n"Wrong CSI channel id: %d\n", pdata->mux_id))\r\nreturn -EINVAL;\r\ncsis = fmd->csis[pdata->mux_id].sd;\r\nif (WARN(csis == NULL,\r\n"MIPI-CSI interface specified but s5p-csis module is not loaded!\n"))\r\nreturn -EINVAL;\r\npad = sensor->entity.num_pads - 1;\r\nret = media_create_pad_link(&sensor->entity, pad,\r\n&csis->entity, CSIS_PAD_SINK,\r\nMEDIA_LNK_FL_IMMUTABLE |\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\nv4l2_info(&fmd->v4l2_dev, "created link [%s] => [%s]\n",\r\nsensor->entity.name, csis->entity.name);\r\nsource = NULL;\r\ncsi_sensors[pdata->mux_id] = sensor;\r\nbreak;\r\ncase FIMC_BUS_TYPE_ITU_601...FIMC_BUS_TYPE_ITU_656:\r\nsource = &sensor->entity;\r\npad = 0;\r\nbreak;\r\ndefault:\r\nv4l2_err(&fmd->v4l2_dev, "Wrong bus_type: %x\n",\r\npdata->sensor_bus_type);\r\nreturn -EINVAL;\r\n}\r\nif (source == NULL)\r\ncontinue;\r\nlink_mask = 1 << fimc_id++;\r\nret = __fimc_md_create_fimc_sink_links(fmd, source, sensor,\r\npad, link_mask);\r\n}\r\nfor (i = 0; i < CSIS_MAX_ENTITIES; i++) {\r\nif (fmd->csis[i].sd == NULL)\r\ncontinue;\r\nsource = &fmd->csis[i].sd->entity;\r\npad = CSIS_PAD_SOURCE;\r\nsensor = csi_sensors[i];\r\nlink_mask = 1 << fimc_id++;\r\nret = __fimc_md_create_fimc_sink_links(fmd, source, sensor,\r\npad, link_mask);\r\n}\r\nflags = MEDIA_LNK_FL_IMMUTABLE | MEDIA_LNK_FL_ENABLED;\r\nfor (i = 0; i < FIMC_MAX_DEVS; i++) {\r\nif (!fmd->fimc[i])\r\ncontinue;\r\nsource = &fmd->fimc[i]->vid_cap.subdev.entity;\r\nsink = &fmd->fimc[i]->vid_cap.ve.vdev.entity;\r\nret = media_create_pad_link(source, FIMC_SD_PAD_SOURCE,\r\nsink, 0, flags);\r\nif (ret)\r\nbreak;\r\n}\r\nret = __fimc_md_create_flite_source_links(fmd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (fmd->use_isp)\r\nret = __fimc_md_create_fimc_is_links(fmd);\r\nreturn ret;\r\n}\r\nstatic void fimc_md_put_clocks(struct fimc_md *fmd)\r\n{\r\nint i = FIMC_MAX_CAMCLKS;\r\nwhile (--i >= 0) {\r\nif (IS_ERR(fmd->camclk[i].clock))\r\ncontinue;\r\nclk_put(fmd->camclk[i].clock);\r\nfmd->camclk[i].clock = ERR_PTR(-EINVAL);\r\n}\r\nfor (i = 0; i < FIMC_MAX_WBCLKS; i++) {\r\nif (IS_ERR(fmd->wbclk[i]))\r\ncontinue;\r\nclk_put(fmd->wbclk[i]);\r\nfmd->wbclk[i] = ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic int fimc_md_get_clocks(struct fimc_md *fmd)\r\n{\r\nstruct device *dev = &fmd->pdev->dev;\r\nchar clk_name[32];\r\nstruct clk *clock;\r\nint i, ret = 0;\r\nfor (i = 0; i < FIMC_MAX_CAMCLKS; i++)\r\nfmd->camclk[i].clock = ERR_PTR(-EINVAL);\r\nfor (i = 0; i < FIMC_MAX_CAMCLKS; i++) {\r\nsnprintf(clk_name, sizeof(clk_name), "sclk_cam%u", i);\r\nclock = clk_get(dev, clk_name);\r\nif (IS_ERR(clock)) {\r\ndev_err(dev, "Failed to get clock: %s\n", clk_name);\r\nret = PTR_ERR(clock);\r\nbreak;\r\n}\r\nfmd->camclk[i].clock = clock;\r\n}\r\nif (ret)\r\nfimc_md_put_clocks(fmd);\r\nif (!fmd->use_isp)\r\nreturn 0;\r\nfmd->wbclk[CLK_IDX_WB_A] = ERR_PTR(-EINVAL);\r\nfor (i = CLK_IDX_WB_B; i < FIMC_MAX_WBCLKS; i++) {\r\nsnprintf(clk_name, sizeof(clk_name), "pxl_async%u", i);\r\nclock = clk_get(dev, clk_name);\r\nif (IS_ERR(clock)) {\r\nv4l2_err(&fmd->v4l2_dev, "Failed to get clock: %s\n",\r\nclk_name);\r\nret = PTR_ERR(clock);\r\nbreak;\r\n}\r\nfmd->wbclk[i] = clock;\r\n}\r\nif (ret)\r\nfimc_md_put_clocks(fmd);\r\nreturn ret;\r\n}\r\nstatic int __fimc_md_modify_pipeline(struct media_entity *entity, bool enable)\r\n{\r\nstruct exynos_video_entity *ve;\r\nstruct fimc_pipeline *p;\r\nstruct video_device *vdev;\r\nint ret;\r\nvdev = media_entity_to_video_device(entity);\r\nif (vdev->entity.use_count == 0)\r\nreturn 0;\r\nve = vdev_to_exynos_video_entity(vdev);\r\np = to_fimc_pipeline(ve->pipe);\r\nif (!enable && p->subdevs[IDX_SENSOR] == NULL)\r\nreturn 0;\r\nif (enable)\r\nret = __fimc_pipeline_open(ve->pipe, entity, true);\r\nelse\r\nret = __fimc_pipeline_close(ve->pipe);\r\nif (ret == 0 && !enable)\r\nmemset(p->subdevs, 0, sizeof(p->subdevs));\r\nreturn ret;\r\n}\r\nstatic int __fimc_md_modify_pipelines(struct media_entity *entity, bool enable,\r\nstruct media_graph *graph)\r\n{\r\nstruct media_entity *entity_err = entity;\r\nint ret;\r\nmedia_graph_walk_start(graph, entity);\r\nwhile ((entity = media_graph_walk_next(graph))) {\r\nif (!is_media_entity_v4l2_video_device(entity))\r\ncontinue;\r\nret = __fimc_md_modify_pipeline(entity, enable);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nmedia_graph_walk_start(graph, entity_err);\r\nwhile ((entity_err = media_graph_walk_next(graph))) {\r\nif (!is_media_entity_v4l2_video_device(entity_err))\r\ncontinue;\r\n__fimc_md_modify_pipeline(entity_err, !enable);\r\nif (entity_err == entity)\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int fimc_md_link_notify(struct media_link *link, unsigned int flags,\r\nunsigned int notification)\r\n{\r\nstruct media_graph *graph =\r\n&container_of(link->graph_obj.mdev, struct fimc_md,\r\nmedia_dev)->link_setup_graph;\r\nstruct media_entity *sink = link->sink->entity;\r\nint ret = 0;\r\nif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH) {\r\nret = media_graph_walk_init(graph,\r\nlink->graph_obj.mdev);\r\nif (ret)\r\nreturn ret;\r\nif (!(flags & MEDIA_LNK_FL_ENABLED))\r\nret = __fimc_md_modify_pipelines(sink, false, graph);\r\n#if 0\r\nelse\r\n#endif\r\n} else if (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH) {\r\nif (link->flags & MEDIA_LNK_FL_ENABLED)\r\nret = __fimc_md_modify_pipelines(sink, true, graph);\r\nmedia_graph_walk_cleanup(graph);\r\n}\r\nreturn ret ? -EPIPE : 0;\r\n}\r\nstatic ssize_t fimc_md_sysfs_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct fimc_md *fmd = platform_get_drvdata(pdev);\r\nif (fmd->user_subdev_api)\r\nreturn strlcpy(buf, "Sub-device API (sub-dev)\n", PAGE_SIZE);\r\nreturn strlcpy(buf, "V4L2 video node only API (vid-dev)\n", PAGE_SIZE);\r\n}\r\nstatic ssize_t fimc_md_sysfs_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct fimc_md *fmd = platform_get_drvdata(pdev);\r\nbool subdev_api;\r\nint i;\r\nif (!strcmp(buf, "vid-dev\n"))\r\nsubdev_api = false;\r\nelse if (!strcmp(buf, "sub-dev\n"))\r\nsubdev_api = true;\r\nelse\r\nreturn count;\r\nfmd->user_subdev_api = subdev_api;\r\nfor (i = 0; i < FIMC_MAX_DEVS; i++)\r\nif (fmd->fimc[i])\r\nfmd->fimc[i]->vid_cap.user_subdev_api = subdev_api;\r\nreturn count;\r\n}\r\nstatic int fimc_md_get_pinctrl(struct fimc_md *fmd)\r\n{\r\nstruct device *dev = &fmd->pdev->dev;\r\nstruct fimc_pinctrl *pctl = &fmd->pinctl;\r\npctl->pinctrl = devm_pinctrl_get(dev);\r\nif (IS_ERR(pctl->pinctrl))\r\nreturn PTR_ERR(pctl->pinctrl);\r\npctl->state_default = pinctrl_lookup_state(pctl->pinctrl,\r\nPINCTRL_STATE_DEFAULT);\r\nif (IS_ERR(pctl->state_default))\r\nreturn PTR_ERR(pctl->state_default);\r\npctl->state_idle = pinctrl_lookup_state(pctl->pinctrl,\r\nPINCTRL_STATE_IDLE);\r\nreturn 0;\r\n}\r\nstatic int cam_clk_prepare(struct clk_hw *hw)\r\n{\r\nstruct cam_clk *camclk = to_cam_clk(hw);\r\nint ret;\r\nif (camclk->fmd->pmf == NULL)\r\nreturn -ENODEV;\r\nret = pm_runtime_get_sync(camclk->fmd->pmf);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic void cam_clk_unprepare(struct clk_hw *hw)\r\n{\r\nstruct cam_clk *camclk = to_cam_clk(hw);\r\nif (camclk->fmd->pmf == NULL)\r\nreturn;\r\npm_runtime_put_sync(camclk->fmd->pmf);\r\n}\r\nstatic void fimc_md_unregister_clk_provider(struct fimc_md *fmd)\r\n{\r\nstruct cam_clk_provider *cp = &fmd->clk_provider;\r\nunsigned int i;\r\nif (cp->of_node)\r\nof_clk_del_provider(cp->of_node);\r\nfor (i = 0; i < cp->num_clocks; i++)\r\nclk_unregister(cp->clks[i]);\r\n}\r\nstatic int fimc_md_register_clk_provider(struct fimc_md *fmd)\r\n{\r\nstruct cam_clk_provider *cp = &fmd->clk_provider;\r\nstruct device *dev = &fmd->pdev->dev;\r\nint i, ret;\r\nfor (i = 0; i < FIMC_MAX_CAMCLKS; i++) {\r\nstruct cam_clk *camclk = &cp->camclk[i];\r\nstruct clk_init_data init;\r\nconst char *p_name;\r\nret = of_property_read_string_index(dev->of_node,\r\n"clock-output-names", i, &init.name);\r\nif (ret < 0)\r\nbreak;\r\np_name = __clk_get_name(fmd->camclk[i].clock);\r\ninit.parent_names = &p_name;\r\ninit.num_parents = 1;\r\ninit.ops = &cam_clk_ops;\r\ninit.flags = CLK_SET_RATE_PARENT;\r\ncamclk->hw.init = &init;\r\ncamclk->fmd = fmd;\r\ncp->clks[i] = clk_register(NULL, &camclk->hw);\r\nif (IS_ERR(cp->clks[i])) {\r\ndev_err(dev, "failed to register clock: %s (%ld)\n",\r\ninit.name, PTR_ERR(cp->clks[i]));\r\nret = PTR_ERR(cp->clks[i]);\r\ngoto err;\r\n}\r\ncp->num_clocks++;\r\n}\r\nif (cp->num_clocks == 0) {\r\ndev_warn(dev, "clk provider not registered\n");\r\nreturn 0;\r\n}\r\ncp->clk_data.clks = cp->clks;\r\ncp->clk_data.clk_num = cp->num_clocks;\r\ncp->of_node = dev->of_node;\r\nret = of_clk_add_provider(dev->of_node, of_clk_src_onecell_get,\r\n&cp->clk_data);\r\nif (ret == 0)\r\nreturn 0;\r\nerr:\r\nfimc_md_unregister_clk_provider(fmd);\r\nreturn ret;\r\n}\r\nstatic int subdev_notifier_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct fimc_md *fmd = notifier_to_fimc_md(notifier);\r\nstruct fimc_sensor_info *si = NULL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fmd->sensor); i++)\r\nif (fmd->sensor[i].asd.match.of.node == subdev->dev->of_node)\r\nsi = &fmd->sensor[i];\r\nif (si == NULL)\r\nreturn -EINVAL;\r\nv4l2_set_subdev_hostdata(subdev, &si->pdata);\r\nif (si->pdata.fimc_bus_type == FIMC_BUS_TYPE_ISP_WRITEBACK)\r\nsubdev->grp_id = GRP_ID_FIMC_IS_SENSOR;\r\nelse\r\nsubdev->grp_id = GRP_ID_SENSOR;\r\nsi->subdev = subdev;\r\nv4l2_info(&fmd->v4l2_dev, "Registered sensor subdevice: %s (%d)\n",\r\nsubdev->name, fmd->num_sensors);\r\nfmd->num_sensors++;\r\nreturn 0;\r\n}\r\nstatic int subdev_notifier_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct fimc_md *fmd = notifier_to_fimc_md(notifier);\r\nint ret;\r\nmutex_lock(&fmd->media_dev.graph_mutex);\r\nret = fimc_md_create_links(fmd);\r\nif (ret < 0)\r\ngoto unlock;\r\nret = v4l2_device_register_subdev_nodes(&fmd->v4l2_dev);\r\nunlock:\r\nmutex_unlock(&fmd->media_dev.graph_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn media_device_register(&fmd->media_dev);\r\n}\r\nstatic int fimc_md_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct v4l2_device *v4l2_dev;\r\nstruct fimc_md *fmd;\r\nint ret;\r\nfmd = devm_kzalloc(dev, sizeof(*fmd), GFP_KERNEL);\r\nif (!fmd)\r\nreturn -ENOMEM;\r\nspin_lock_init(&fmd->slock);\r\nINIT_LIST_HEAD(&fmd->pipelines);\r\nfmd->pdev = pdev;\r\nstrlcpy(fmd->media_dev.model, "SAMSUNG S5P FIMC",\r\nsizeof(fmd->media_dev.model));\r\nfmd->media_dev.ops = &fimc_md_ops;\r\nfmd->media_dev.dev = dev;\r\nv4l2_dev = &fmd->v4l2_dev;\r\nv4l2_dev->mdev = &fmd->media_dev;\r\nv4l2_dev->notify = fimc_sensor_notify;\r\nstrlcpy(v4l2_dev->name, "s5p-fimc-md", sizeof(v4l2_dev->name));\r\nfmd->use_isp = fimc_md_is_isp_available(dev->of_node);\r\nfmd->user_subdev_api = true;\r\nmedia_device_init(&fmd->media_dev);\r\nret = v4l2_device_register(dev, &fmd->v4l2_dev);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "Failed to register v4l2_device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = fimc_md_get_clocks(fmd);\r\nif (ret)\r\ngoto err_md;\r\nret = fimc_md_get_pinctrl(fmd);\r\nif (ret < 0) {\r\nif (ret != EPROBE_DEFER)\r\ndev_err(dev, "Failed to get pinctrl: %d\n", ret);\r\ngoto err_clk;\r\n}\r\nplatform_set_drvdata(pdev, fmd);\r\nret = fimc_md_register_platform_entities(fmd, dev->of_node);\r\nif (ret)\r\ngoto err_clk;\r\nret = fimc_md_register_sensor_entities(fmd);\r\nif (ret)\r\ngoto err_m_ent;\r\nret = device_create_file(&pdev->dev, &dev_attr_subdev_conf_mode);\r\nif (ret)\r\ngoto err_m_ent;\r\nret = fimc_md_register_clk_provider(fmd);\r\nif (ret < 0) {\r\nv4l2_err(v4l2_dev, "clock provider registration failed\n");\r\ngoto err_attr;\r\n}\r\nif (fmd->num_sensors > 0) {\r\nfmd->subdev_notifier.subdevs = fmd->async_subdevs;\r\nfmd->subdev_notifier.num_subdevs = fmd->num_sensors;\r\nfmd->subdev_notifier.bound = subdev_notifier_bound;\r\nfmd->subdev_notifier.complete = subdev_notifier_complete;\r\nfmd->num_sensors = 0;\r\nret = v4l2_async_notifier_register(&fmd->v4l2_dev,\r\n&fmd->subdev_notifier);\r\nif (ret)\r\ngoto err_clk_p;\r\n}\r\nreturn 0;\r\nerr_clk_p:\r\nfimc_md_unregister_clk_provider(fmd);\r\nerr_attr:\r\ndevice_remove_file(&pdev->dev, &dev_attr_subdev_conf_mode);\r\nerr_clk:\r\nfimc_md_put_clocks(fmd);\r\nerr_m_ent:\r\nfimc_md_unregister_entities(fmd);\r\nerr_md:\r\nmedia_device_cleanup(&fmd->media_dev);\r\nv4l2_device_unregister(&fmd->v4l2_dev);\r\nreturn ret;\r\n}\r\nstatic int fimc_md_remove(struct platform_device *pdev)\r\n{\r\nstruct fimc_md *fmd = platform_get_drvdata(pdev);\r\nif (!fmd)\r\nreturn 0;\r\nfimc_md_unregister_clk_provider(fmd);\r\nv4l2_async_notifier_unregister(&fmd->subdev_notifier);\r\nv4l2_device_unregister(&fmd->v4l2_dev);\r\ndevice_remove_file(&pdev->dev, &dev_attr_subdev_conf_mode);\r\nfimc_md_unregister_entities(fmd);\r\nfimc_md_pipelines_free(fmd);\r\nmedia_device_unregister(&fmd->media_dev);\r\nmedia_device_cleanup(&fmd->media_dev);\r\nfimc_md_put_clocks(fmd);\r\nreturn 0;\r\n}\r\nstatic int __init fimc_md_init(void)\r\n{\r\nint ret;\r\nrequest_module("s5p-csis");\r\nret = fimc_register_driver();\r\nif (ret)\r\nreturn ret;\r\nreturn platform_driver_register(&fimc_md_driver);\r\n}\r\nstatic void __exit fimc_md_exit(void)\r\n{\r\nplatform_driver_unregister(&fimc_md_driver);\r\nfimc_unregister_driver();\r\n}
