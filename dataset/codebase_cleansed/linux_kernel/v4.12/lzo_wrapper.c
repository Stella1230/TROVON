static void *lzo_init(struct squashfs_sb_info *msblk, void *buff)\r\n{\r\nint block_size = max_t(int, msblk->block_size, SQUASHFS_METADATA_SIZE);\r\nstruct squashfs_lzo *stream = kzalloc(sizeof(*stream), GFP_KERNEL);\r\nif (stream == NULL)\r\ngoto failed;\r\nstream->input = vmalloc(block_size);\r\nif (stream->input == NULL)\r\ngoto failed;\r\nstream->output = vmalloc(block_size);\r\nif (stream->output == NULL)\r\ngoto failed2;\r\nreturn stream;\r\nfailed2:\r\nvfree(stream->input);\r\nfailed:\r\nERROR("Failed to allocate lzo workspace\n");\r\nkfree(stream);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic void lzo_free(void *strm)\r\n{\r\nstruct squashfs_lzo *stream = strm;\r\nif (stream) {\r\nvfree(stream->input);\r\nvfree(stream->output);\r\n}\r\nkfree(stream);\r\n}\r\nstatic int lzo_uncompress(struct squashfs_sb_info *msblk, void *strm,\r\nstruct buffer_head **bh, int b, int offset, int length,\r\nstruct squashfs_page_actor *output)\r\n{\r\nstruct squashfs_lzo *stream = strm;\r\nvoid *buff = stream->input, *data;\r\nint avail, i, bytes = length, res;\r\nsize_t out_len = output->length;\r\nfor (i = 0; i < b; i++) {\r\navail = min(bytes, msblk->devblksize - offset);\r\nmemcpy(buff, bh[i]->b_data + offset, avail);\r\nbuff += avail;\r\nbytes -= avail;\r\noffset = 0;\r\nput_bh(bh[i]);\r\n}\r\nres = lzo1x_decompress_safe(stream->input, (size_t)length,\r\nstream->output, &out_len);\r\nif (res != LZO_E_OK)\r\ngoto failed;\r\nres = bytes = (int)out_len;\r\ndata = squashfs_first_page(output);\r\nbuff = stream->output;\r\nwhile (data) {\r\nif (bytes <= PAGE_SIZE) {\r\nmemcpy(data, buff, bytes);\r\nbreak;\r\n} else {\r\nmemcpy(data, buff, PAGE_SIZE);\r\nbuff += PAGE_SIZE;\r\nbytes -= PAGE_SIZE;\r\ndata = squashfs_next_page(output);\r\n}\r\n}\r\nsquashfs_finish_page(output);\r\nreturn res;\r\nfailed:\r\nreturn -EIO;\r\n}
