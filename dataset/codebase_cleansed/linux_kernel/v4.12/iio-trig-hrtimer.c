static\r\nssize_t iio_hrtimer_show_sampling_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nstruct iio_hrtimer_info *info = iio_trigger_get_drvdata(trig);\r\nreturn snprintf(buf, PAGE_SIZE, "%lu\n", info->sampling_frequency);\r\n}\r\nstatic\r\nssize_t iio_hrtimer_store_sampling_frequency(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_trigger *trig = to_iio_trigger(dev);\r\nstruct iio_hrtimer_info *info = iio_trigger_get_drvdata(trig);\r\nunsigned long val;\r\nint ret;\r\nret = kstrtoul(buf, 10, &val);\r\nif (ret)\r\nreturn ret;\r\nif (!val || val > NSEC_PER_SEC)\r\nreturn -EINVAL;\r\ninfo->sampling_frequency = val;\r\ninfo->period = NSEC_PER_SEC / val;\r\nreturn len;\r\n}\r\nstatic enum hrtimer_restart iio_hrtimer_trig_handler(struct hrtimer *timer)\r\n{\r\nstruct iio_hrtimer_info *info;\r\ninfo = container_of(timer, struct iio_hrtimer_info, timer);\r\nhrtimer_forward_now(timer, info->period);\r\niio_trigger_poll(info->swt.trigger);\r\nreturn HRTIMER_RESTART;\r\n}\r\nstatic int iio_trig_hrtimer_set_state(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_hrtimer_info *trig_info;\r\ntrig_info = iio_trigger_get_drvdata(trig);\r\nif (state)\r\nhrtimer_start(&trig_info->timer, trig_info->period,\r\nHRTIMER_MODE_REL);\r\nelse\r\nhrtimer_cancel(&trig_info->timer);\r\nreturn 0;\r\n}\r\nstatic struct iio_sw_trigger *iio_trig_hrtimer_probe(const char *name)\r\n{\r\nstruct iio_hrtimer_info *trig_info;\r\nint ret;\r\ntrig_info = kzalloc(sizeof(*trig_info), GFP_KERNEL);\r\nif (!trig_info)\r\nreturn ERR_PTR(-ENOMEM);\r\ntrig_info->swt.trigger = iio_trigger_alloc("%s", name);\r\nif (!trig_info->swt.trigger) {\r\nret = -ENOMEM;\r\ngoto err_free_trig_info;\r\n}\r\niio_trigger_set_drvdata(trig_info->swt.trigger, trig_info);\r\ntrig_info->swt.trigger->ops = &iio_hrtimer_trigger_ops;\r\ntrig_info->swt.trigger->dev.groups = iio_hrtimer_attr_groups;\r\nhrtimer_init(&trig_info->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\r\ntrig_info->timer.function = iio_hrtimer_trig_handler;\r\ntrig_info->sampling_frequency = HRTIMER_DEFAULT_SAMPLING_FREQUENCY;\r\ntrig_info->period = NSEC_PER_SEC / trig_info->sampling_frequency;\r\nret = iio_trigger_register(trig_info->swt.trigger);\r\nif (ret)\r\ngoto err_free_trigger;\r\niio_swt_group_init_type_name(&trig_info->swt, name, &iio_hrtimer_type);\r\nreturn &trig_info->swt;\r\nerr_free_trigger:\r\niio_trigger_free(trig_info->swt.trigger);\r\nerr_free_trig_info:\r\nkfree(trig_info);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic int iio_trig_hrtimer_remove(struct iio_sw_trigger *swt)\r\n{\r\nstruct iio_hrtimer_info *trig_info;\r\ntrig_info = iio_trigger_get_drvdata(swt->trigger);\r\niio_trigger_unregister(swt->trigger);\r\nhrtimer_cancel(&trig_info->timer);\r\niio_trigger_free(swt->trigger);\r\nkfree(trig_info);\r\nreturn 0;\r\n}
