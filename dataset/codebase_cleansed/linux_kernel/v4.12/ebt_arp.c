static bool\r\nebt_arp_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nconst struct ebt_arp_info *info = par->matchinfo;\r\nconst struct arphdr *ah;\r\nstruct arphdr _arph;\r\nah = skb_header_pointer(skb, 0, sizeof(_arph), &_arph);\r\nif (ah == NULL)\r\nreturn false;\r\nif ((info->bitmask & EBT_ARP_OPCODE) &&\r\nNF_INVF(info, EBT_ARP_OPCODE, info->opcode != ah->ar_op))\r\nreturn false;\r\nif ((info->bitmask & EBT_ARP_HTYPE) &&\r\nNF_INVF(info, EBT_ARP_HTYPE, info->htype != ah->ar_hrd))\r\nreturn false;\r\nif ((info->bitmask & EBT_ARP_PTYPE) &&\r\nNF_INVF(info, EBT_ARP_PTYPE, info->ptype != ah->ar_pro))\r\nreturn false;\r\nif (info->bitmask & (EBT_ARP_SRC_IP | EBT_ARP_DST_IP | EBT_ARP_GRAT)) {\r\nconst __be32 *sap, *dap;\r\n__be32 saddr, daddr;\r\nif (ah->ar_pln != sizeof(__be32) || ah->ar_pro != htons(ETH_P_IP))\r\nreturn false;\r\nsap = skb_header_pointer(skb, sizeof(struct arphdr) +\r\nah->ar_hln, sizeof(saddr),\r\n&saddr);\r\nif (sap == NULL)\r\nreturn false;\r\ndap = skb_header_pointer(skb, sizeof(struct arphdr) +\r\n2*ah->ar_hln+sizeof(saddr),\r\nsizeof(daddr), &daddr);\r\nif (dap == NULL)\r\nreturn false;\r\nif ((info->bitmask & EBT_ARP_SRC_IP) &&\r\nNF_INVF(info, EBT_ARP_SRC_IP,\r\ninfo->saddr != (*sap & info->smsk)))\r\nreturn false;\r\nif ((info->bitmask & EBT_ARP_DST_IP) &&\r\nNF_INVF(info, EBT_ARP_DST_IP,\r\ninfo->daddr != (*dap & info->dmsk)))\r\nreturn false;\r\nif ((info->bitmask & EBT_ARP_GRAT) &&\r\nNF_INVF(info, EBT_ARP_GRAT, *dap != *sap))\r\nreturn false;\r\n}\r\nif (info->bitmask & (EBT_ARP_SRC_MAC | EBT_ARP_DST_MAC)) {\r\nconst unsigned char *mp;\r\nunsigned char _mac[ETH_ALEN];\r\nif (ah->ar_hln != ETH_ALEN || ah->ar_hrd != htons(ARPHRD_ETHER))\r\nreturn false;\r\nif (info->bitmask & EBT_ARP_SRC_MAC) {\r\nmp = skb_header_pointer(skb, sizeof(struct arphdr),\r\nsizeof(_mac), &_mac);\r\nif (mp == NULL)\r\nreturn false;\r\nif (NF_INVF(info, EBT_ARP_SRC_MAC,\r\n!ether_addr_equal_masked(mp, info->smaddr,\r\ninfo->smmsk)))\r\nreturn false;\r\n}\r\nif (info->bitmask & EBT_ARP_DST_MAC) {\r\nmp = skb_header_pointer(skb, sizeof(struct arphdr) +\r\nah->ar_hln + ah->ar_pln,\r\nsizeof(_mac), &_mac);\r\nif (mp == NULL)\r\nreturn false;\r\nif (NF_INVF(info, EBT_ARP_DST_MAC,\r\n!ether_addr_equal_masked(mp, info->dmaddr,\r\ninfo->dmmsk)))\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int ebt_arp_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nconst struct ebt_arp_info *info = par->matchinfo;\r\nconst struct ebt_entry *e = par->entryinfo;\r\nif ((e->ethproto != htons(ETH_P_ARP) &&\r\ne->ethproto != htons(ETH_P_RARP)) ||\r\ne->invflags & EBT_IPROTO)\r\nreturn -EINVAL;\r\nif (info->bitmask & ~EBT_ARP_MASK || info->invflags & ~EBT_ARP_MASK)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init ebt_arp_init(void)\r\n{\r\nreturn xt_register_match(&ebt_arp_mt_reg);\r\n}\r\nstatic void __exit ebt_arp_fini(void)\r\n{\r\nxt_unregister_match(&ebt_arp_mt_reg);\r\n}
