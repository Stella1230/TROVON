static int adau17x1_pll_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nadau->pll_regs[5] = 1;\r\n} else {\r\nadau->pll_regs[5] = 0;\r\nregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\r\nADAU17X1_CLOCK_CONTROL_CORECLK_SRC_PLL, 0);\r\n}\r\nregmap_raw_write(adau->regmap, ADAU17X1_PLL_CONTROL,\r\nadau->pll_regs, ARRAY_SIZE(adau->pll_regs));\r\nif (SND_SOC_DAPM_EVENT_ON(event)) {\r\nmdelay(5);\r\nregmap_update_bits(adau->regmap, ADAU17X1_CLOCK_CONTROL,\r\nADAU17X1_CLOCK_CONTROL_CORECLK_SRC_PLL,\r\nADAU17X1_CLOCK_CONTROL_CORECLK_SRC_PLL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adau17x1_dsp_mux_enum_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nstruct snd_soc_dapm_update update = { 0 };\r\nunsigned int stream = e->shift_l;\r\nunsigned int val, change;\r\nint reg;\r\nif (ucontrol->value.enumerated.item[0] >= e->items)\r\nreturn -EINVAL;\r\nswitch (ucontrol->value.enumerated.item[0]) {\r\ncase 0:\r\nval = 0;\r\nadau->dsp_bypass[stream] = false;\r\nbreak;\r\ndefault:\r\nval = (adau->tdm_slot[stream] * 2) + 1;\r\nadau->dsp_bypass[stream] = true;\r\nbreak;\r\n}\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = ADAU17X1_SERIAL_INPUT_ROUTE;\r\nelse\r\nreg = ADAU17X1_SERIAL_OUTPUT_ROUTE;\r\nchange = snd_soc_test_bits(codec, reg, 0xff, val);\r\nif (change) {\r\nupdate.kcontrol = kcontrol;\r\nupdate.mask = 0xff;\r\nupdate.reg = reg;\r\nupdate.val = val;\r\nsnd_soc_dapm_mux_update_power(dapm, kcontrol,\r\nucontrol->value.enumerated.item[0], e, &update);\r\n}\r\nreturn change;\r\n}\r\nstatic int adau17x1_dsp_mux_enum_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_kcontrol_codec(kcontrol);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_enum *e = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int stream = e->shift_l;\r\nunsigned int reg, val;\r\nint ret;\r\nif (stream == SNDRV_PCM_STREAM_PLAYBACK)\r\nreg = ADAU17X1_SERIAL_INPUT_ROUTE;\r\nelse\r\nreg = ADAU17X1_SERIAL_OUTPUT_ROUTE;\r\nret = regmap_read(adau->regmap, reg, &val);\r\nif (ret)\r\nreturn ret;\r\nif (val != 0)\r\nval = 1;\r\nucontrol->value.enumerated.item[0] = val;\r\nreturn 0;\r\n}\r\nbool adau17x1_has_dsp(struct adau *adau)\r\n{\r\nswitch (adau->type) {\r\ncase ADAU1761:\r\ncase ADAU1381:\r\ncase ADAU1781:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int adau17x1_set_dai_pll(struct snd_soc_dai *dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nif (freq_in < 8000000 || freq_in > 27000000)\r\nreturn -EINVAL;\r\nret = adau_calc_pll_cfg(freq_in, freq_out, adau->pll_regs);\r\nif (ret < 0)\r\nreturn ret;\r\nret = regmap_raw_write(adau->regmap, ADAU17X1_PLL_CONTROL,\r\nadau->pll_regs, ARRAY_SIZE(adau->pll_regs));\r\nif (ret)\r\nreturn ret;\r\nadau->pll_freq = freq_out;\r\nreturn 0;\r\n}\r\nstatic int adau17x1_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(dai->codec);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(dai->codec);\r\nbool is_pll;\r\nbool was_pll;\r\nswitch (clk_id) {\r\ncase ADAU17X1_CLK_SRC_MCLK:\r\nis_pll = false;\r\nbreak;\r\ncase ADAU17X1_CLK_SRC_PLL_AUTO:\r\nif (!adau->mclk)\r\nreturn -EINVAL;\r\ncase ADAU17X1_CLK_SRC_PLL:\r\nis_pll = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (adau->clk_src) {\r\ncase ADAU17X1_CLK_SRC_MCLK:\r\nwas_pll = false;\r\nbreak;\r\ncase ADAU17X1_CLK_SRC_PLL:\r\ncase ADAU17X1_CLK_SRC_PLL_AUTO:\r\nwas_pll = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nadau->sysclk = freq;\r\nif (is_pll != was_pll) {\r\nif (is_pll) {\r\nsnd_soc_dapm_add_routes(dapm,\r\n&adau17x1_dapm_pll_route, 1);\r\n} else {\r\nsnd_soc_dapm_del_routes(dapm,\r\n&adau17x1_dapm_pll_route, 1);\r\n}\r\n}\r\nadau->clk_src = clk_id;\r\nreturn 0;\r\n}\r\nstatic int adau17x1_auto_pll(struct snd_soc_dai *dai,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct adau *adau = snd_soc_dai_get_drvdata(dai);\r\nunsigned int pll_rate;\r\nswitch (params_rate(params)) {\r\ncase 48000:\r\ncase 8000:\r\ncase 12000:\r\ncase 16000:\r\ncase 24000:\r\ncase 32000:\r\ncase 96000:\r\npll_rate = 48000 * 1024;\r\nbreak;\r\ncase 44100:\r\ncase 7350:\r\ncase 11025:\r\ncase 14700:\r\ncase 22050:\r\ncase 29400:\r\ncase 88200:\r\npll_rate = 44100 * 1024;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn adau17x1_set_dai_pll(dai, ADAU17X1_PLL, ADAU17X1_PLL_SRC_MCLK,\r\nclk_get_rate(adau->mclk), pll_rate);\r\n}\r\nstatic int adau17x1_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val, div, dsp_div;\r\nunsigned int freq;\r\nint ret;\r\nswitch (adau->clk_src) {\r\ncase ADAU17X1_CLK_SRC_PLL_AUTO:\r\nret = adau17x1_auto_pll(dai, params);\r\nif (ret)\r\nreturn ret;\r\ncase ADAU17X1_CLK_SRC_PLL:\r\nfreq = adau->pll_freq;\r\nbreak;\r\ndefault:\r\nfreq = adau->sysclk;\r\nbreak;\r\n}\r\nif (freq % params_rate(params) != 0)\r\nreturn -EINVAL;\r\nswitch (freq / params_rate(params)) {\r\ncase 1024:\r\ndiv = 0;\r\ndsp_div = 1;\r\nbreak;\r\ncase 6144:\r\ndiv = 1;\r\ndsp_div = 6;\r\nbreak;\r\ncase 4096:\r\ndiv = 2;\r\ndsp_div = 5;\r\nbreak;\r\ncase 3072:\r\ndiv = 3;\r\ndsp_div = 4;\r\nbreak;\r\ncase 2048:\r\ndiv = 4;\r\ndsp_div = 3;\r\nbreak;\r\ncase 1536:\r\ndiv = 5;\r\ndsp_div = 2;\r\nbreak;\r\ncase 512:\r\ndiv = 6;\r\ndsp_div = 0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER0,\r\nADAU17X1_CONVERTER0_CONVSR_MASK, div);\r\nif (adau17x1_has_dsp(adau)) {\r\nregmap_write(adau->regmap, ADAU17X1_SERIAL_SAMPLING_RATE, div);\r\nregmap_write(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, dsp_div);\r\n}\r\nif (adau->sigmadsp) {\r\nret = adau17x1_setup_firmware(adau, params_rate(params));\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nif (adau->dai_fmt != SND_SOC_DAIFMT_RIGHT_J)\r\nreturn 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nval = ADAU17X1_SERIAL_PORT1_DELAY16;\r\nbreak;\r\ncase 24:\r\nval = ADAU17X1_SERIAL_PORT1_DELAY8;\r\nbreak;\r\ncase 32:\r\nval = ADAU17X1_SERIAL_PORT1_DELAY0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT1,\r\nADAU17X1_SERIAL_PORT1_DELAY_MASK, val);\r\n}\r\nstatic int adau17x1_set_dai_fmt(struct snd_soc_dai *dai,\r\nunsigned int fmt)\r\n{\r\nstruct adau *adau = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int ctrl0, ctrl1;\r\nint lrclk_pol;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nctrl0 = ADAU17X1_SERIAL_PORT0_MASTER;\r\nadau->master = true;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nctrl0 = 0;\r\nadau->master = false;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nlrclk_pol = 0;\r\nctrl1 = ADAU17X1_SERIAL_PORT1_DELAY1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nlrclk_pol = 1;\r\nctrl1 = ADAU17X1_SERIAL_PORT1_DELAY0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nlrclk_pol = 1;\r\nctrl0 |= ADAU17X1_SERIAL_PORT0_PULSE_MODE;\r\nctrl1 = ADAU17X1_SERIAL_PORT1_DELAY1;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nlrclk_pol = 1;\r\nctrl0 |= ADAU17X1_SERIAL_PORT0_PULSE_MODE;\r\nctrl1 = ADAU17X1_SERIAL_PORT1_DELAY0;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nctrl0 |= ADAU17X1_SERIAL_PORT0_BCLK_POL;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrclk_pol = !lrclk_pol;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nctrl0 |= ADAU17X1_SERIAL_PORT0_BCLK_POL;\r\nlrclk_pol = !lrclk_pol;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (lrclk_pol)\r\nctrl0 |= ADAU17X1_SERIAL_PORT0_LRCLK_POL;\r\nregmap_write(adau->regmap, ADAU17X1_SERIAL_PORT0, ctrl0);\r\nregmap_write(adau->regmap, ADAU17X1_SERIAL_PORT1, ctrl1);\r\nadau->dai_fmt = fmt & SND_SOC_DAIFMT_FORMAT_MASK;\r\nreturn 0;\r\n}\r\nstatic int adau17x1_set_dai_tdm_slot(struct snd_soc_dai *dai,\r\nunsigned int tx_mask, unsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct adau *adau = snd_soc_codec_get_drvdata(dai->codec);\r\nunsigned int ser_ctrl0, ser_ctrl1;\r\nunsigned int conv_ctrl0, conv_ctrl1;\r\nif (slots == 0) {\r\nslots = 2;\r\nrx_mask = 3;\r\ntx_mask = 3;\r\nslot_width = 32;\r\n}\r\nswitch (slots) {\r\ncase 2:\r\nser_ctrl0 = ADAU17X1_SERIAL_PORT0_STEREO;\r\nbreak;\r\ncase 4:\r\nser_ctrl0 = ADAU17X1_SERIAL_PORT0_TDM4;\r\nbreak;\r\ncase 8:\r\nif (adau->type == ADAU1361)\r\nreturn -EINVAL;\r\nser_ctrl0 = ADAU17X1_SERIAL_PORT0_TDM8;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (slot_width * slots) {\r\ncase 32:\r\nif (adau->type == ADAU1761)\r\nreturn -EINVAL;\r\nser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK32;\r\nbreak;\r\ncase 64:\r\nser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK64;\r\nbreak;\r\ncase 48:\r\nser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK48;\r\nbreak;\r\ncase 128:\r\nser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK128;\r\nbreak;\r\ncase 256:\r\nif (adau->type == ADAU1361)\r\nreturn -EINVAL;\r\nser_ctrl1 = ADAU17X1_SERIAL_PORT1_BCLK256;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (rx_mask) {\r\ncase 0x03:\r\nconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(1);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 0;\r\nbreak;\r\ncase 0x0c:\r\nconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(2);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 1;\r\nbreak;\r\ncase 0x30:\r\nconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(3);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 2;\r\nbreak;\r\ncase 0xc0:\r\nconv_ctrl1 = ADAU17X1_CONVERTER1_ADC_PAIR(4);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (tx_mask) {\r\ncase 0x03:\r\nconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(1);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 0;\r\nbreak;\r\ncase 0x0c:\r\nconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(2);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 1;\r\nbreak;\r\ncase 0x30:\r\nconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(3);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 2;\r\nbreak;\r\ncase 0xc0:\r\nconv_ctrl0 = ADAU17X1_CONVERTER0_DAC_PAIR(4);\r\nadau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER0,\r\nADAU17X1_CONVERTER0_DAC_PAIR_MASK, conv_ctrl0);\r\nregmap_update_bits(adau->regmap, ADAU17X1_CONVERTER1,\r\nADAU17X1_CONVERTER1_ADC_PAIR_MASK, conv_ctrl1);\r\nregmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT0,\r\nADAU17X1_SERIAL_PORT0_TDM_MASK, ser_ctrl0);\r\nregmap_update_bits(adau->regmap, ADAU17X1_SERIAL_PORT1,\r\nADAU17X1_SERIAL_PORT1_BCLK_MASK, ser_ctrl1);\r\nif (!adau17x1_has_dsp(adau))\r\nreturn 0;\r\nif (adau->dsp_bypass[SNDRV_PCM_STREAM_PLAYBACK]) {\r\nregmap_write(adau->regmap, ADAU17X1_SERIAL_INPUT_ROUTE,\r\n(adau->tdm_slot[SNDRV_PCM_STREAM_PLAYBACK] * 2) + 1);\r\n}\r\nif (adau->dsp_bypass[SNDRV_PCM_STREAM_CAPTURE]) {\r\nregmap_write(adau->regmap, ADAU17X1_SERIAL_OUTPUT_ROUTE,\r\n(adau->tdm_slot[SNDRV_PCM_STREAM_CAPTURE] * 2) + 1);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adau17x1_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct adau *adau = snd_soc_codec_get_drvdata(dai->codec);\r\nif (adau->sigmadsp)\r\nreturn sigmadsp_restrict_params(adau->sigmadsp, substream);\r\nreturn 0;\r\n}\r\nint adau17x1_set_micbias_voltage(struct snd_soc_codec *codec,\r\nenum adau17x1_micbias_voltage micbias)\r\n{\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nswitch (micbias) {\r\ncase ADAU17X1_MICBIAS_0_90_AVDD:\r\ncase ADAU17X1_MICBIAS_0_65_AVDD:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn regmap_write(adau->regmap, ADAU17X1_MICBIAS, micbias << 2);\r\n}\r\nbool adau17x1_precious_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg < 0x400)\r\nreturn true;\r\nreturn false;\r\n}\r\nbool adau17x1_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg < 0x400)\r\nreturn true;\r\nswitch (reg) {\r\ncase ADAU17X1_CLOCK_CONTROL:\r\ncase ADAU17X1_PLL_CONTROL:\r\ncase ADAU17X1_REC_POWER_MGMT:\r\ncase ADAU17X1_MICBIAS:\r\ncase ADAU17X1_SERIAL_PORT0:\r\ncase ADAU17X1_SERIAL_PORT1:\r\ncase ADAU17X1_CONVERTER0:\r\ncase ADAU17X1_CONVERTER1:\r\ncase ADAU17X1_LEFT_INPUT_DIGITAL_VOL:\r\ncase ADAU17X1_RIGHT_INPUT_DIGITAL_VOL:\r\ncase ADAU17X1_ADC_CONTROL:\r\ncase ADAU17X1_PLAY_POWER_MGMT:\r\ncase ADAU17X1_DAC_CONTROL0:\r\ncase ADAU17X1_DAC_CONTROL1:\r\ncase ADAU17X1_DAC_CONTROL2:\r\ncase ADAU17X1_SERIAL_PORT_PAD:\r\ncase ADAU17X1_CONTROL_PORT_PAD0:\r\ncase ADAU17X1_CONTROL_PORT_PAD1:\r\ncase ADAU17X1_DSP_SAMPLING_RATE:\r\ncase ADAU17X1_SERIAL_INPUT_ROUTE:\r\ncase ADAU17X1_SERIAL_OUTPUT_ROUTE:\r\ncase ADAU17X1_DSP_ENABLE:\r\ncase ADAU17X1_DSP_RUN:\r\ncase ADAU17X1_SERIAL_SAMPLING_RATE:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nbool adau17x1_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nif (reg < 0x4000)\r\nreturn true;\r\nswitch (reg) {\r\ncase ADAU17X1_PLL_CONTROL:\r\ncase ADAU17X1_PLL_CONTROL + 1:\r\ncase ADAU17X1_PLL_CONTROL + 2:\r\ncase ADAU17X1_PLL_CONTROL + 3:\r\ncase ADAU17X1_PLL_CONTROL + 4:\r\ncase ADAU17X1_PLL_CONTROL + 5:\r\nreturn true;\r\ndefault:\r\nbreak;\r\n}\r\nreturn false;\r\n}\r\nint adau17x1_setup_firmware(struct adau *adau, unsigned int rate)\r\n{\r\nint ret;\r\nint dspsr;\r\nret = regmap_read(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, &dspsr);\r\nif (ret)\r\nreturn ret;\r\nregmap_write(adau->regmap, ADAU17X1_DSP_ENABLE, 1);\r\nregmap_write(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, 0xf);\r\nret = sigmadsp_setup(adau->sigmadsp, rate);\r\nif (ret) {\r\nregmap_write(adau->regmap, ADAU17X1_DSP_ENABLE, 0);\r\nreturn ret;\r\n}\r\nregmap_write(adau->regmap, ADAU17X1_DSP_SAMPLING_RATE, dspsr);\r\nreturn 0;\r\n}\r\nint adau17x1_add_widgets(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_add_codec_controls(codec, adau17x1_controls,\r\nARRAY_SIZE(adau17x1_controls));\r\nif (ret)\r\nreturn ret;\r\nret = snd_soc_dapm_new_controls(dapm, adau17x1_dapm_widgets,\r\nARRAY_SIZE(adau17x1_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nif (adau17x1_has_dsp(adau)) {\r\nret = snd_soc_dapm_new_controls(dapm, adau17x1_dsp_dapm_widgets,\r\nARRAY_SIZE(adau17x1_dsp_dapm_widgets));\r\nif (ret)\r\nreturn ret;\r\nif (!adau->sigmadsp)\r\nreturn 0;\r\nret = sigmadsp_attach(adau->sigmadsp, &codec->component);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to attach firmware: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint adau17x1_add_routes(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nint ret;\r\nret = snd_soc_dapm_add_routes(dapm, adau17x1_dapm_routes,\r\nARRAY_SIZE(adau17x1_dapm_routes));\r\nif (ret)\r\nreturn ret;\r\nif (adau17x1_has_dsp(adau)) {\r\nret = snd_soc_dapm_add_routes(dapm, adau17x1_dsp_dapm_routes,\r\nARRAY_SIZE(adau17x1_dsp_dapm_routes));\r\n} else {\r\nret = snd_soc_dapm_add_routes(dapm, adau17x1_no_dsp_dapm_routes,\r\nARRAY_SIZE(adau17x1_no_dsp_dapm_routes));\r\n}\r\nif (adau->clk_src != ADAU17X1_CLK_SRC_MCLK)\r\nsnd_soc_dapm_add_routes(dapm, &adau17x1_dapm_pll_route, 1);\r\nreturn ret;\r\n}\r\nint adau17x1_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct adau *adau = snd_soc_codec_get_drvdata(codec);\r\nif (adau->switch_mode)\r\nadau->switch_mode(codec->dev);\r\nregcache_sync(adau->regmap);\r\nreturn 0;\r\n}\r\nint adau17x1_probe(struct device *dev, struct regmap *regmap,\r\nenum adau17x1_type type, void (*switch_mode)(struct device *dev),\r\nconst char *firmware_name)\r\n{\r\nstruct adau *adau;\r\nint ret;\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nadau = devm_kzalloc(dev, sizeof(*adau), GFP_KERNEL);\r\nif (!adau)\r\nreturn -ENOMEM;\r\nadau->mclk = devm_clk_get(dev, "mclk");\r\nif (IS_ERR(adau->mclk)) {\r\nif (PTR_ERR(adau->mclk) != -ENOENT)\r\nreturn PTR_ERR(adau->mclk);\r\nadau->mclk = NULL;\r\n} else if (adau->mclk) {\r\nadau->clk_src = ADAU17X1_CLK_SRC_PLL_AUTO;\r\nret = adau_calc_pll_cfg(clk_get_rate(adau->mclk), 48000 * 1024,\r\nadau->pll_regs);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(adau->mclk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nadau->regmap = regmap;\r\nadau->switch_mode = switch_mode;\r\nadau->type = type;\r\ndev_set_drvdata(dev, adau);\r\nif (firmware_name) {\r\nadau->sigmadsp = devm_sigmadsp_init_regmap(dev, regmap, NULL,\r\nfirmware_name);\r\nif (IS_ERR(adau->sigmadsp)) {\r\ndev_warn(dev, "Could not find firmware file: %ld\n",\r\nPTR_ERR(adau->sigmadsp));\r\nadau->sigmadsp = NULL;\r\n}\r\n}\r\nif (switch_mode)\r\nswitch_mode(dev);\r\nreturn 0;\r\n}\r\nvoid adau17x1_remove(struct device *dev)\r\n{\r\nstruct adau *adau = dev_get_drvdata(dev);\r\nsnd_soc_unregister_codec(dev);\r\nif (adau->mclk)\r\nclk_disable_unprepare(adau->mclk);\r\n}
