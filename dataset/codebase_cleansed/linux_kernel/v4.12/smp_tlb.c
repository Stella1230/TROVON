static inline void ipi_flush_tlb_all(void *ignored)\r\n{\r\nlocal_flush_tlb_all();\r\n}\r\nstatic inline void ipi_flush_tlb_mm(void *arg)\r\n{\r\nstruct mm_struct *mm = (struct mm_struct *)arg;\r\nlocal_flush_tlb_mm(mm);\r\n}\r\nstatic inline void ipi_flush_tlb_page(void *arg)\r\n{\r\nstruct tlb_args *ta = (struct tlb_args *)arg;\r\nunsigned int __ua_flags = uaccess_save_and_enable();\r\nlocal_flush_tlb_page(ta->ta_vma, ta->ta_start);\r\nuaccess_restore(__ua_flags);\r\n}\r\nstatic inline void ipi_flush_tlb_kernel_page(void *arg)\r\n{\r\nstruct tlb_args *ta = (struct tlb_args *)arg;\r\nlocal_flush_tlb_kernel_page(ta->ta_start);\r\n}\r\nstatic inline void ipi_flush_tlb_range(void *arg)\r\n{\r\nstruct tlb_args *ta = (struct tlb_args *)arg;\r\nunsigned int __ua_flags = uaccess_save_and_enable();\r\nlocal_flush_tlb_range(ta->ta_vma, ta->ta_start, ta->ta_end);\r\nuaccess_restore(__ua_flags);\r\n}\r\nstatic inline void ipi_flush_tlb_kernel_range(void *arg)\r\n{\r\nstruct tlb_args *ta = (struct tlb_args *)arg;\r\nlocal_flush_tlb_kernel_range(ta->ta_start, ta->ta_end);\r\n}\r\nstatic inline void ipi_flush_bp_all(void *ignored)\r\n{\r\nlocal_flush_bp_all();\r\n}\r\nstatic bool erratum_a15_798181_partial(void)\r\n{\r\nasm("mcr p15, 0, %0, c8, c3, 1" : : "r" (0));\r\ndsb(ish);\r\nreturn false;\r\n}\r\nstatic bool erratum_a15_798181_broadcast(void)\r\n{\r\nasm("mcr p15, 0, %0, c8, c3, 1" : : "r" (0));\r\ndsb(ish);\r\nreturn true;\r\n}\r\nvoid erratum_a15_798181_init(void)\r\n{\r\nunsigned int midr = read_cpuid_id();\r\nunsigned int revidr = read_cpuid(CPUID_REVIDR);\r\nif ((midr & 0xff0ffff0) == 0x420f00f0 && midr <= 0x420f00f2) {\r\nerratum_a15_798181_handler = erratum_a15_798181_broadcast;\r\n} else if ((midr & 0xff0ffff0) == 0x410fc0f0 && midr < 0x412fc0f2) {\r\nerratum_a15_798181_handler = erratum_a15_798181_broadcast;\r\n} else if ((midr & 0xff0ffff0) == 0x410fc0f0 && midr < 0x412fc0f4) {\r\nif (revidr & 0x10)\r\nerratum_a15_798181_handler =\r\nerratum_a15_798181_partial;\r\nelse\r\nerratum_a15_798181_handler =\r\nerratum_a15_798181_broadcast;\r\n} else if ((midr & 0xff0ffff0) == 0x410fc0f0 && midr < 0x413fc0f3) {\r\nif ((revidr & 0x210) == 0)\r\nerratum_a15_798181_handler =\r\nerratum_a15_798181_broadcast;\r\nelse if (revidr & 0x10)\r\nerratum_a15_798181_handler =\r\nerratum_a15_798181_partial;\r\n} else if ((midr & 0xff0ffff0) == 0x410fc0f0 && midr < 0x414fc0f0) {\r\nif ((revidr & 0x200) == 0)\r\nerratum_a15_798181_handler =\r\nerratum_a15_798181_partial;\r\n}\r\n}\r\nstatic void ipi_flush_tlb_a15_erratum(void *arg)\r\n{\r\ndmb();\r\n}\r\nstatic void broadcast_tlb_a15_erratum(void)\r\n{\r\nif (!erratum_a15_798181())\r\nreturn;\r\nsmp_call_function(ipi_flush_tlb_a15_erratum, NULL, 1);\r\n}\r\nstatic void broadcast_tlb_mm_a15_erratum(struct mm_struct *mm)\r\n{\r\nint this_cpu;\r\ncpumask_t mask = { CPU_BITS_NONE };\r\nif (!erratum_a15_798181())\r\nreturn;\r\nthis_cpu = get_cpu();\r\na15_erratum_get_cpumask(this_cpu, mm, &mask);\r\nsmp_call_function_many(&mask, ipi_flush_tlb_a15_erratum, NULL, 1);\r\nput_cpu();\r\n}\r\nvoid flush_tlb_all(void)\r\n{\r\nif (tlb_ops_need_broadcast())\r\non_each_cpu(ipi_flush_tlb_all, NULL, 1);\r\nelse\r\n__flush_tlb_all();\r\nbroadcast_tlb_a15_erratum();\r\n}\r\nvoid flush_tlb_mm(struct mm_struct *mm)\r\n{\r\nif (tlb_ops_need_broadcast())\r\non_each_cpu_mask(mm_cpumask(mm), ipi_flush_tlb_mm, mm, 1);\r\nelse\r\n__flush_tlb_mm(mm);\r\nbroadcast_tlb_mm_a15_erratum(mm);\r\n}\r\nvoid flush_tlb_page(struct vm_area_struct *vma, unsigned long uaddr)\r\n{\r\nif (tlb_ops_need_broadcast()) {\r\nstruct tlb_args ta;\r\nta.ta_vma = vma;\r\nta.ta_start = uaddr;\r\non_each_cpu_mask(mm_cpumask(vma->vm_mm), ipi_flush_tlb_page,\r\n&ta, 1);\r\n} else\r\n__flush_tlb_page(vma, uaddr);\r\nbroadcast_tlb_mm_a15_erratum(vma->vm_mm);\r\n}\r\nvoid flush_tlb_kernel_page(unsigned long kaddr)\r\n{\r\nif (tlb_ops_need_broadcast()) {\r\nstruct tlb_args ta;\r\nta.ta_start = kaddr;\r\non_each_cpu(ipi_flush_tlb_kernel_page, &ta, 1);\r\n} else\r\n__flush_tlb_kernel_page(kaddr);\r\nbroadcast_tlb_a15_erratum();\r\n}\r\nvoid flush_tlb_range(struct vm_area_struct *vma,\r\nunsigned long start, unsigned long end)\r\n{\r\nif (tlb_ops_need_broadcast()) {\r\nstruct tlb_args ta;\r\nta.ta_vma = vma;\r\nta.ta_start = start;\r\nta.ta_end = end;\r\non_each_cpu_mask(mm_cpumask(vma->vm_mm), ipi_flush_tlb_range,\r\n&ta, 1);\r\n} else\r\nlocal_flush_tlb_range(vma, start, end);\r\nbroadcast_tlb_mm_a15_erratum(vma->vm_mm);\r\n}\r\nvoid flush_tlb_kernel_range(unsigned long start, unsigned long end)\r\n{\r\nif (tlb_ops_need_broadcast()) {\r\nstruct tlb_args ta;\r\nta.ta_start = start;\r\nta.ta_end = end;\r\non_each_cpu(ipi_flush_tlb_kernel_range, &ta, 1);\r\n} else\r\nlocal_flush_tlb_kernel_range(start, end);\r\nbroadcast_tlb_a15_erratum();\r\n}\r\nvoid flush_bp_all(void)\r\n{\r\nif (tlb_ops_need_broadcast())\r\non_each_cpu(ipi_flush_bp_all, NULL, 1);\r\nelse\r\n__flush_bp_all();\r\n}
