static void adf_service_add(struct service_hndl *service)\r\n{\r\nmutex_lock(&service_lock);\r\nlist_add(&service->list, &service_table);\r\nmutex_unlock(&service_lock);\r\n}\r\nint adf_service_register(struct service_hndl *service)\r\n{\r\nmemset(service->init_status, 0, sizeof(service->init_status));\r\nmemset(service->start_status, 0, sizeof(service->start_status));\r\nadf_service_add(service);\r\nreturn 0;\r\n}\r\nstatic void adf_service_remove(struct service_hndl *service)\r\n{\r\nmutex_lock(&service_lock);\r\nlist_del(&service->list);\r\nmutex_unlock(&service_lock);\r\n}\r\nint adf_service_unregister(struct service_hndl *service)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(service->init_status); i++) {\r\nif (service->init_status[i] || service->start_status[i]) {\r\npr_err("QAT: Could not remove active service\n");\r\nreturn -EFAULT;\r\n}\r\n}\r\nadf_service_remove(service);\r\nreturn 0;\r\n}\r\nint adf_dev_init(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct service_hndl *service;\r\nstruct list_head *list_itr;\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nif (!hw_data) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to init device - hw_data not set\n");\r\nreturn -EFAULT;\r\n}\r\nif (!test_bit(ADF_STATUS_CONFIGURED, &accel_dev->status)) {\r\ndev_err(&GET_DEV(accel_dev), "Device not configured\n");\r\nreturn -EFAULT;\r\n}\r\nif (adf_init_etr_data(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "Failed initialize etr\n");\r\nreturn -EFAULT;\r\n}\r\nif (hw_data->init_admin_comms && hw_data->init_admin_comms(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "Failed initialize admin comms\n");\r\nreturn -EFAULT;\r\n}\r\nif (hw_data->init_arb && hw_data->init_arb(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "Failed initialize hw arbiter\n");\r\nreturn -EFAULT;\r\n}\r\nhw_data->enable_ints(accel_dev);\r\nif (adf_ae_init(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to initialise Acceleration Engine\n");\r\nreturn -EFAULT;\r\n}\r\nset_bit(ADF_STATUS_AE_INITIALISED, &accel_dev->status);\r\nif (adf_ae_fw_load(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to load acceleration FW\n");\r\nreturn -EFAULT;\r\n}\r\nset_bit(ADF_STATUS_AE_UCODE_LOADED, &accel_dev->status);\r\nif (hw_data->alloc_irq(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "Failed to allocate interrupts\n");\r\nreturn -EFAULT;\r\n}\r\nset_bit(ADF_STATUS_IRQ_ALLOCATED, &accel_dev->status);\r\nlist_for_each(list_itr, &service_table) {\r\nservice = list_entry(list_itr, struct service_hndl, list);\r\nif (service->event_hld(accel_dev, ADF_EVENT_INIT)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to initialise service %s\n",\r\nservice->name);\r\nreturn -EFAULT;\r\n}\r\nset_bit(accel_dev->accel_id, service->init_status);\r\n}\r\nhw_data->enable_error_correction(accel_dev);\r\nhw_data->enable_vf2pf_comms(accel_dev);\r\nreturn 0;\r\n}\r\nint adf_dev_start(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct service_hndl *service;\r\nstruct list_head *list_itr;\r\nset_bit(ADF_STATUS_STARTING, &accel_dev->status);\r\nif (adf_ae_start(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "AE Start Failed\n");\r\nreturn -EFAULT;\r\n}\r\nset_bit(ADF_STATUS_AE_STARTED, &accel_dev->status);\r\nif (hw_data->send_admin_init(accel_dev)) {\r\ndev_err(&GET_DEV(accel_dev), "Failed to send init message\n");\r\nreturn -EFAULT;\r\n}\r\nlist_for_each(list_itr, &service_table) {\r\nservice = list_entry(list_itr, struct service_hndl, list);\r\nif (service->event_hld(accel_dev, ADF_EVENT_START)) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to start service %s\n",\r\nservice->name);\r\nreturn -EFAULT;\r\n}\r\nset_bit(accel_dev->accel_id, service->start_status);\r\n}\r\nclear_bit(ADF_STATUS_STARTING, &accel_dev->status);\r\nset_bit(ADF_STATUS_STARTED, &accel_dev->status);\r\nif (!list_empty(&accel_dev->crypto_list) &&\r\n(qat_algs_register() || qat_asym_algs_register())) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to register crypto algs\n");\r\nset_bit(ADF_STATUS_STARTING, &accel_dev->status);\r\nclear_bit(ADF_STATUS_STARTED, &accel_dev->status);\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nvoid adf_dev_stop(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct service_hndl *service;\r\nstruct list_head *list_itr;\r\nbool wait = false;\r\nint ret;\r\nif (!adf_dev_started(accel_dev) &&\r\n!test_bit(ADF_STATUS_STARTING, &accel_dev->status))\r\nreturn;\r\nclear_bit(ADF_STATUS_STARTING, &accel_dev->status);\r\nclear_bit(ADF_STATUS_STARTED, &accel_dev->status);\r\nif (!list_empty(&accel_dev->crypto_list)) {\r\nqat_algs_unregister();\r\nqat_asym_algs_unregister();\r\n}\r\nlist_for_each(list_itr, &service_table) {\r\nservice = list_entry(list_itr, struct service_hndl, list);\r\nif (!test_bit(accel_dev->accel_id, service->start_status))\r\ncontinue;\r\nret = service->event_hld(accel_dev, ADF_EVENT_STOP);\r\nif (!ret) {\r\nclear_bit(accel_dev->accel_id, service->start_status);\r\n} else if (ret == -EAGAIN) {\r\nwait = true;\r\nclear_bit(accel_dev->accel_id, service->start_status);\r\n}\r\n}\r\nif (wait)\r\nmsleep(100);\r\nif (test_bit(ADF_STATUS_AE_STARTED, &accel_dev->status)) {\r\nif (adf_ae_stop(accel_dev))\r\ndev_err(&GET_DEV(accel_dev), "failed to stop AE\n");\r\nelse\r\nclear_bit(ADF_STATUS_AE_STARTED, &accel_dev->status);\r\n}\r\n}\r\nvoid adf_dev_shutdown(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct adf_hw_device_data *hw_data = accel_dev->hw_device;\r\nstruct service_hndl *service;\r\nstruct list_head *list_itr;\r\nif (!hw_data) {\r\ndev_err(&GET_DEV(accel_dev),\r\n"QAT: Failed to shutdown device - hw_data not set\n");\r\nreturn;\r\n}\r\nif (test_bit(ADF_STATUS_AE_UCODE_LOADED, &accel_dev->status)) {\r\nadf_ae_fw_release(accel_dev);\r\nclear_bit(ADF_STATUS_AE_UCODE_LOADED, &accel_dev->status);\r\n}\r\nif (test_bit(ADF_STATUS_AE_INITIALISED, &accel_dev->status)) {\r\nif (adf_ae_shutdown(accel_dev))\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to shutdown Accel Engine\n");\r\nelse\r\nclear_bit(ADF_STATUS_AE_INITIALISED,\r\n&accel_dev->status);\r\n}\r\nlist_for_each(list_itr, &service_table) {\r\nservice = list_entry(list_itr, struct service_hndl, list);\r\nif (!test_bit(accel_dev->accel_id, service->init_status))\r\ncontinue;\r\nif (service->event_hld(accel_dev, ADF_EVENT_SHUTDOWN))\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to shutdown service %s\n",\r\nservice->name);\r\nelse\r\nclear_bit(accel_dev->accel_id, service->init_status);\r\n}\r\nhw_data->disable_iov(accel_dev);\r\nif (test_bit(ADF_STATUS_IRQ_ALLOCATED, &accel_dev->status)) {\r\nhw_data->free_irq(accel_dev);\r\nclear_bit(ADF_STATUS_IRQ_ALLOCATED, &accel_dev->status);\r\n}\r\nif (!test_bit(ADF_STATUS_RESTARTING, &accel_dev->status))\r\nadf_cfg_del_all(accel_dev);\r\nif (hw_data->exit_arb)\r\nhw_data->exit_arb(accel_dev);\r\nif (hw_data->exit_admin_comms)\r\nhw_data->exit_admin_comms(accel_dev);\r\nadf_cleanup_etr_data(accel_dev);\r\nadf_dev_restore(accel_dev);\r\n}\r\nint adf_dev_restarting_notify(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct service_hndl *service;\r\nstruct list_head *list_itr;\r\nlist_for_each(list_itr, &service_table) {\r\nservice = list_entry(list_itr, struct service_hndl, list);\r\nif (service->event_hld(accel_dev, ADF_EVENT_RESTARTING))\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to restart service %s.\n",\r\nservice->name);\r\n}\r\nreturn 0;\r\n}\r\nint adf_dev_restarted_notify(struct adf_accel_dev *accel_dev)\r\n{\r\nstruct service_hndl *service;\r\nstruct list_head *list_itr;\r\nlist_for_each(list_itr, &service_table) {\r\nservice = list_entry(list_itr, struct service_hndl, list);\r\nif (service->event_hld(accel_dev, ADF_EVENT_RESTARTED))\r\ndev_err(&GET_DEV(accel_dev),\r\n"Failed to restart service %s.\n",\r\nservice->name);\r\n}\r\nreturn 0;\r\n}
