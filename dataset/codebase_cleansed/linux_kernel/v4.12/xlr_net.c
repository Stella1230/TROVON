static inline void xlr_nae_wreg(u32 __iomem *base, unsigned int reg, u32 val)\r\n{\r\n__raw_writel(val, base + reg);\r\n}\r\nstatic inline u32 xlr_nae_rdreg(u32 __iomem *base, unsigned int reg)\r\n{\r\nreturn __raw_readl(base + reg);\r\n}\r\nstatic inline void xlr_reg_update(u32 *base_addr, u32 off, u32 val, u32 mask)\r\n{\r\nu32 tmp;\r\ntmp = xlr_nae_rdreg(base_addr, off);\r\nxlr_nae_wreg(base_addr, off, (tmp & ~mask) | (val & mask));\r\n}\r\nstatic int send_to_rfr_fifo(struct xlr_net_priv *priv, void *addr)\r\n{\r\nstruct nlm_fmn_msg msg;\r\nint ret = 0, num_try = 0, stnid;\r\nunsigned long paddr, mflags;\r\npaddr = virt_to_bus(addr);\r\nmsg.msg0 = (u64)paddr & 0xffffffffe0ULL;\r\nmsg.msg1 = 0;\r\nmsg.msg2 = 0;\r\nmsg.msg3 = 0;\r\nstnid = priv->nd->rfr_station;\r\ndo {\r\nmflags = nlm_cop2_enable_irqsave();\r\nret = nlm_fmn_send(1, 0, stnid, &msg);\r\nnlm_cop2_disable_irqrestore(mflags);\r\nif (ret == 0)\r\nreturn 0;\r\n} while (++num_try < 10000);\r\nnetdev_err(priv->ndev, "Send to RFR failed in RX path\n");\r\nreturn ret;\r\n}\r\nstatic inline unsigned char *xlr_alloc_skb(void)\r\n{\r\nstruct sk_buff *skb;\r\nint buf_len = sizeof(struct sk_buff *);\r\nunsigned char *skb_data;\r\nskb = alloc_skb(XLR_RX_BUF_SIZE, GFP_ATOMIC);\r\nif (!skb)\r\nreturn NULL;\r\nskb_data = skb->data;\r\nskb_put(skb, MAC_SKB_BACK_PTR_SIZE);\r\nskb_pull(skb, MAC_SKB_BACK_PTR_SIZE);\r\nmemcpy(skb_data, &skb, buf_len);\r\nreturn skb->data;\r\n}\r\nstatic void xlr_net_fmn_handler(int bkt, int src_stnid, int size, int code,\r\nstruct nlm_fmn_msg *msg, void *arg)\r\n{\r\nstruct sk_buff *skb;\r\nvoid *skb_data = NULL;\r\nstruct net_device *ndev;\r\nstruct xlr_net_priv *priv;\r\nu32 port, length;\r\nunsigned char *addr;\r\nstruct xlr_adapter *adapter = arg;\r\nlength = (msg->msg0 >> 40) & 0x3fff;\r\nif (length == 0) {\r\naddr = bus_to_virt(msg->msg0 & 0xffffffffffULL);\r\naddr = addr - MAC_SKB_BACK_PTR_SIZE;\r\nskb = (struct sk_buff *)(*(unsigned long *)addr);\r\ndev_kfree_skb_any((struct sk_buff *)addr);\r\n} else {\r\naddr = (unsigned char *)\r\nbus_to_virt(msg->msg0 & 0xffffffffe0ULL);\r\nlength = length - BYTE_OFFSET - MAC_CRC_LEN;\r\nport = ((int)msg->msg0) & 0x0f;\r\naddr = addr - MAC_SKB_BACK_PTR_SIZE;\r\nskb = (struct sk_buff *)(*(unsigned long *)addr);\r\nskb->dev = adapter->netdev[port];\r\nif (!skb->dev)\r\nreturn;\r\nndev = skb->dev;\r\npriv = netdev_priv(ndev);\r\nskb_reserve(skb, BYTE_OFFSET);\r\nskb_put(skb, length);\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\nnetif_rx(skb);\r\nskb_data = xlr_alloc_skb();\r\nif (skb_data)\r\nsend_to_rfr_fifo(priv, skb_data);\r\n}\r\n}\r\nstatic struct phy_device *xlr_get_phydev(struct xlr_net_priv *priv)\r\n{\r\nreturn mdiobus_get_phy(priv->mii_bus, priv->phy_addr);\r\n}\r\nstatic int xlr_get_link_ksettings(struct net_device *ndev,\r\nstruct ethtool_link_ksettings *ecmd)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_ksettings_get(phydev, ecmd);\r\n}\r\nstatic int xlr_set_link_ksettings(struct net_device *ndev,\r\nconst struct ethtool_link_ksettings *ecmd)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nif (!phydev)\r\nreturn -ENODEV;\r\nreturn phy_ethtool_ksettings_set(phydev, ecmd);\r\n}\r\nstatic int xlr_net_fill_rx_ring(struct net_device *ndev)\r\n{\r\nvoid *skb_data;\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nint i;\r\nfor (i = 0; i < MAX_FRIN_SPILL / 4; i++) {\r\nskb_data = xlr_alloc_skb();\r\nif (!skb_data) {\r\nnetdev_err(ndev, "SKB allocation failed\n");\r\nreturn -ENOMEM;\r\n}\r\nsend_to_rfr_fifo(priv, skb_data);\r\n}\r\nnetdev_info(ndev, "Rx ring setup done\n");\r\nreturn 0;\r\n}\r\nstatic int xlr_net_open(struct net_device *ndev)\r\n{\r\nu32 err;\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nphy_start(phydev);\r\nerr = phy_start_aneg(phydev);\r\nif (err) {\r\npr_err("Autoneg failed\n");\r\nreturn err;\r\n}\r\nxlr_set_gmac_speed(priv);\r\nnetif_tx_start_all_queues(ndev);\r\nreturn 0;\r\n}\r\nstatic int xlr_net_stop(struct net_device *ndev)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nphy_stop(phydev);\r\nnetif_tx_stop_all_queues(ndev);\r\nreturn 0;\r\n}\r\nstatic void xlr_make_tx_desc(struct nlm_fmn_msg *msg, unsigned long addr,\r\nstruct sk_buff *skb)\r\n{\r\nunsigned long physkb = virt_to_phys(skb);\r\nint cpu_core = nlm_core_id();\r\nint fr_stn_id = cpu_core * 8 + XLR_FB_STN;\r\nmsg->msg0 = (((u64)1 << 63) |\r\n((u64)127 << 54) |\r\n(u64)skb->len << 40 |\r\n((u64)addr));\r\nmsg->msg1 = (((u64)1 << 63) |\r\n((u64)fr_stn_id << 54) |\r\n(u64)0 << 40 |\r\n((u64)physkb & 0xffffffff));\r\nmsg->msg2 = 0;\r\nmsg->msg3 = 0;\r\n}\r\nstatic netdev_tx_t xlr_net_start_xmit(struct sk_buff *skb,\r\nstruct net_device *ndev)\r\n{\r\nstruct nlm_fmn_msg msg;\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nint ret;\r\nu32 flags;\r\nxlr_make_tx_desc(&msg, virt_to_phys(skb->data), skb);\r\nflags = nlm_cop2_enable_irqsave();\r\nret = nlm_fmn_send(2, 0, priv->tx_stnid, &msg);\r\nnlm_cop2_disable_irqrestore(flags);\r\nif (ret)\r\ndev_kfree_skb_any(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic u16 xlr_net_select_queue(struct net_device *ndev, struct sk_buff *skb,\r\nvoid *accel_priv,\r\nselect_queue_fallback_t fallback)\r\n{\r\nreturn (u16)smp_processor_id();\r\n}\r\nstatic void xlr_hw_set_mac_addr(struct net_device *ndev)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nxlr_nae_wreg(priv->base_addr, R_MAC_ADDR0,\r\n((ndev->dev_addr[5] << 24) | (ndev->dev_addr[4] << 16) |\r\n(ndev->dev_addr[3] << 8) | (ndev->dev_addr[2])));\r\nxlr_nae_wreg(priv->base_addr, R_MAC_ADDR0 + 1,\r\n((ndev->dev_addr[1] << 24) | (ndev->dev_addr[0] << 16)));\r\nxlr_nae_wreg(priv->base_addr, R_MAC_ADDR_MASK2, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_MAC_ADDR_MASK2 + 1, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_MAC_ADDR_MASK3, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_MAC_ADDR_MASK3 + 1, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_MAC_FILTER_CONFIG,\r\n(1 << O_MAC_FILTER_CONFIG__BROADCAST_EN) |\r\n(1 << O_MAC_FILTER_CONFIG__ALL_MCAST_EN) |\r\n(1 << O_MAC_FILTER_CONFIG__MAC_ADDR0_VALID));\r\nif (priv->nd->phy_interface == PHY_INTERFACE_MODE_RGMII ||\r\npriv->nd->phy_interface == PHY_INTERFACE_MODE_SGMII)\r\nxlr_reg_update(priv->base_addr, R_IPG_IFG, MAC_B2B_IPG, 0x7f);\r\n}\r\nstatic int xlr_net_set_mac_addr(struct net_device *ndev, void *data)\r\n{\r\nint err;\r\nerr = eth_mac_addr(ndev, data);\r\nif (err)\r\nreturn err;\r\nxlr_hw_set_mac_addr(ndev);\r\nreturn 0;\r\n}\r\nstatic void xlr_set_rx_mode(struct net_device *ndev)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nu32 regval;\r\nregval = xlr_nae_rdreg(priv->base_addr, R_MAC_FILTER_CONFIG);\r\nif (ndev->flags & IFF_PROMISC) {\r\nregval |= (1 << O_MAC_FILTER_CONFIG__BROADCAST_EN) |\r\n(1 << O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN) |\r\n(1 << O_MAC_FILTER_CONFIG__ALL_MCAST_EN) |\r\n(1 << O_MAC_FILTER_CONFIG__ALL_UCAST_EN);\r\n} else {\r\nregval &= ~((1 << O_MAC_FILTER_CONFIG__PAUSE_FRAME_EN) |\r\n(1 << O_MAC_FILTER_CONFIG__ALL_UCAST_EN));\r\n}\r\nxlr_nae_wreg(priv->base_addr, R_MAC_FILTER_CONFIG, regval);\r\n}\r\nstatic void xlr_stats(struct net_device *ndev, struct rtnl_link_stats64 *stats)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nstats->rx_packets = xlr_nae_rdreg(priv->base_addr, RX_PACKET_COUNTER);\r\nstats->tx_packets = xlr_nae_rdreg(priv->base_addr, TX_PACKET_COUNTER);\r\nstats->rx_bytes = xlr_nae_rdreg(priv->base_addr, RX_BYTE_COUNTER);\r\nstats->tx_bytes = xlr_nae_rdreg(priv->base_addr, TX_BYTE_COUNTER);\r\nstats->tx_errors = xlr_nae_rdreg(priv->base_addr, TX_FCS_ERROR_COUNTER);\r\nstats->rx_dropped = xlr_nae_rdreg(priv->base_addr,\r\nRX_DROP_PACKET_COUNTER);\r\nstats->tx_dropped = xlr_nae_rdreg(priv->base_addr,\r\nTX_DROP_FRAME_COUNTER);\r\nstats->multicast = xlr_nae_rdreg(priv->base_addr,\r\nRX_MULTICAST_PACKET_COUNTER);\r\nstats->collisions = xlr_nae_rdreg(priv->base_addr,\r\nTX_TOTAL_COLLISION_COUNTER);\r\nstats->rx_length_errors = xlr_nae_rdreg(priv->base_addr,\r\nRX_FRAME_LENGTH_ERROR_COUNTER);\r\nstats->rx_over_errors = xlr_nae_rdreg(priv->base_addr,\r\nRX_DROP_PACKET_COUNTER);\r\nstats->rx_crc_errors = xlr_nae_rdreg(priv->base_addr,\r\nRX_FCS_ERROR_COUNTER);\r\nstats->rx_frame_errors = xlr_nae_rdreg(priv->base_addr,\r\nRX_ALIGNMENT_ERROR_COUNTER);\r\nstats->rx_fifo_errors = xlr_nae_rdreg(priv->base_addr,\r\nRX_DROP_PACKET_COUNTER);\r\nstats->rx_missed_errors = xlr_nae_rdreg(priv->base_addr,\r\nRX_CARRIER_SENSE_ERROR_COUNTER);\r\nstats->rx_errors = (stats->rx_over_errors + stats->rx_crc_errors +\r\nstats->rx_frame_errors + stats->rx_fifo_errors +\r\nstats->rx_missed_errors);\r\nstats->tx_aborted_errors = xlr_nae_rdreg(priv->base_addr,\r\nTX_EXCESSIVE_COLLISION_PACKET_COUNTER);\r\nstats->tx_carrier_errors = xlr_nae_rdreg(priv->base_addr,\r\nTX_DROP_FRAME_COUNTER);\r\nstats->tx_fifo_errors = xlr_nae_rdreg(priv->base_addr,\r\nTX_DROP_FRAME_COUNTER);\r\n}\r\nstatic void *xlr_config_spill(struct xlr_net_priv *priv, int reg_start_0,\r\nint reg_start_1, int reg_size, int size)\r\n{\r\nvoid *spill;\r\nu32 *base;\r\nunsigned long phys_addr;\r\nu32 spill_size;\r\nbase = priv->base_addr;\r\nspill_size = size;\r\nspill = kmalloc(spill_size + SMP_CACHE_BYTES, GFP_ATOMIC);\r\nif (!spill) {\r\npr_err("Unable to allocate memory for spill area!\n");\r\nreturn ZERO_SIZE_PTR;\r\n}\r\nspill = PTR_ALIGN(spill, SMP_CACHE_BYTES);\r\nphys_addr = virt_to_phys(spill);\r\ndev_dbg(&priv->ndev->dev, "Allocated spill %d bytes at %lx\n",\r\nsize, phys_addr);\r\nxlr_nae_wreg(base, reg_start_0, (phys_addr >> 5) & 0xffffffff);\r\nxlr_nae_wreg(base, reg_start_1, ((u64)phys_addr >> 37) & 0x07);\r\nxlr_nae_wreg(base, reg_size, spill_size);\r\nreturn spill;\r\n}\r\nstatic void xlr_config_fifo_spill_area(struct xlr_net_priv *priv)\r\n{\r\npriv->frin_spill = xlr_config_spill(priv,\r\nR_REG_FRIN_SPILL_MEM_START_0,\r\nR_REG_FRIN_SPILL_MEM_START_1,\r\nR_REG_FRIN_SPILL_MEM_SIZE,\r\nMAX_FRIN_SPILL *\r\nsizeof(u64));\r\npriv->frout_spill = xlr_config_spill(priv,\r\nR_FROUT_SPILL_MEM_START_0,\r\nR_FROUT_SPILL_MEM_START_1,\r\nR_FROUT_SPILL_MEM_SIZE,\r\nMAX_FROUT_SPILL *\r\nsizeof(u64));\r\npriv->class_0_spill = xlr_config_spill(priv,\r\nR_CLASS0_SPILL_MEM_START_0,\r\nR_CLASS0_SPILL_MEM_START_1,\r\nR_CLASS0_SPILL_MEM_SIZE,\r\nMAX_CLASS_0_SPILL *\r\nsizeof(u64));\r\npriv->class_1_spill = xlr_config_spill(priv,\r\nR_CLASS1_SPILL_MEM_START_0,\r\nR_CLASS1_SPILL_MEM_START_1,\r\nR_CLASS1_SPILL_MEM_SIZE,\r\nMAX_CLASS_1_SPILL *\r\nsizeof(u64));\r\npriv->class_2_spill = xlr_config_spill(priv,\r\nR_CLASS2_SPILL_MEM_START_0,\r\nR_CLASS2_SPILL_MEM_START_1,\r\nR_CLASS2_SPILL_MEM_SIZE,\r\nMAX_CLASS_2_SPILL *\r\nsizeof(u64));\r\npriv->class_3_spill = xlr_config_spill(priv,\r\nR_CLASS3_SPILL_MEM_START_0,\r\nR_CLASS3_SPILL_MEM_START_1,\r\nR_CLASS3_SPILL_MEM_SIZE,\r\nMAX_CLASS_3_SPILL *\r\nsizeof(u64));\r\n}\r\nstatic void xlr_config_pde(struct xlr_net_priv *priv)\r\n{\r\nint i = 0;\r\nu64 bkt_map = 0;\r\nfor (i = 0; i < hweight32(priv->nd->cpu_mask); i++)\r\nbkt_map |= (0xff << (i * 8));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_0, (bkt_map & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_0 + 1,\r\n((bkt_map >> 32) & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_1, (bkt_map & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_1 + 1,\r\n((bkt_map >> 32) & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_2, (bkt_map & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_2 + 1,\r\n((bkt_map >> 32) & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_3, (bkt_map & 0xffffffff));\r\nxlr_nae_wreg(priv->base_addr, R_PDE_CLASS_3 + 1,\r\n((bkt_map >> 32) & 0xffffffff));\r\n}\r\nstatic int xlr_config_common(struct xlr_net_priv *priv)\r\n{\r\nstruct xlr_fmn_info *gmac = priv->nd->gmac_fmn_info;\r\nint start_stn_id = gmac->start_stn_id;\r\nint end_stn_id = gmac->end_stn_id;\r\nint *bucket_size = priv->nd->bucket_size;\r\nint i, j, err;\r\nfor (i = start_stn_id; i <= end_stn_id; i++) {\r\nxlr_nae_wreg(priv->base_addr,\r\nR_GMAC_RFR0_BUCKET_SIZE + i - start_stn_id,\r\nbucket_size[i]);\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nfor (j = 0; j < 8; j++)\r\nxlr_nae_wreg(priv->base_addr,\r\n(R_CC_CPU0_0 + (i * 8)) + j,\r\ngmac->credit_config[(i * 8) + j]);\r\n}\r\nxlr_nae_wreg(priv->base_addr, R_MSG_TX_THRESHOLD, 3);\r\nxlr_nae_wreg(priv->base_addr, R_DMACR0, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_DMACR1, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_DMACR2, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_DMACR3, 0xffffffff);\r\nxlr_nae_wreg(priv->base_addr, R_FREEQCARVE, 0);\r\nerr = xlr_net_fill_rx_ring(priv->ndev);\r\nif (err)\r\nreturn err;\r\nnlm_register_fmn_handler(start_stn_id, end_stn_id, xlr_net_fmn_handler,\r\npriv->adapter);\r\nreturn 0;\r\n}\r\nstatic void xlr_config_translate_table(struct xlr_net_priv *priv)\r\n{\r\nu32 cpu_mask;\r\nu32 val;\r\nint bkts[32];\r\nint b1, b2, c1, c2, i, j, k;\r\nint use_bkt;\r\nuse_bkt = 0;\r\ncpu_mask = priv->nd->cpu_mask;\r\npr_info("Using %s-based distribution\n",\r\n(use_bkt) ? "bucket" : "class");\r\nj = 0;\r\nfor (i = 0; i < 32; i++) {\r\nif ((1 << i) & cpu_mask) {\r\nbkts[j] = ((i / 4) * 8) + (i % 4);\r\nj++;\r\n}\r\n}\r\nk = 0;\r\nc1 = 3;\r\nc2 = 0;\r\nfor (i = 0; i < 64; i++) {\r\nc1 = (c1 + 1) & 3;\r\nc2 = (c1 + 1) & 3;\r\nb1 = bkts[k];\r\nk = (k + 1) % j;\r\nb2 = bkts[k];\r\nk = (k + 1) % j;\r\nval = ((c1 << 23) | (b1 << 17) | (use_bkt << 16) |\r\n(c2 << 7) | (b2 << 1) | (use_bkt << 0));\r\ndev_dbg(&priv->ndev->dev, "Table[%d] b1=%d b2=%d c1=%d c2=%d\n",\r\ni, b1, b2, c1, c2);\r\nxlr_nae_wreg(priv->base_addr, R_TRANSLATETABLE + i, val);\r\nc1 = c2;\r\n}\r\n}\r\nstatic void xlr_config_parser(struct xlr_net_priv *priv)\r\n{\r\nu32 val;\r\nxlr_nae_wreg(priv->base_addr, R_L2TYPE_0, 0x01);\r\nxlr_nae_wreg(priv->base_addr, R_PARSERCONFIGREG,\r\n((0x7f << 8) | (1 << 1)));\r\nxlr_nae_wreg(priv->base_addr, R_L3CTABLE,\r\n(9 << 20) | (1 << 19) | (1 << 18) | (0x01 << 16) |\r\n(0x0800 << 0));\r\nxlr_nae_wreg(priv->base_addr, R_L3CTABLE + 1,\r\n(9 << 25) | (1 << 21) | (12 << 14) | (4 << 10) |\r\n(16 << 4) | 4);\r\nxlr_nae_wreg(priv->base_addr, R_L4CTABLE, 6);\r\nxlr_nae_wreg(priv->base_addr, R_L4CTABLE + 2, 17);\r\nval = ((0 << 21) | (2 << 17) | (2 << 11) | (2 << 7));\r\nxlr_nae_wreg(priv->base_addr, R_L4CTABLE + 1, val);\r\nxlr_nae_wreg(priv->base_addr, R_L4CTABLE + 3, val);\r\nxlr_config_translate_table(priv);\r\n}\r\nstatic int xlr_phy_write(u32 *base_addr, int phy_addr, int regnum, u16 val)\r\n{\r\nunsigned long timeout, stoptime, checktime;\r\nint timedout;\r\ntimeout = msecs_to_jiffies(100);\r\nstoptime = jiffies + timeout;\r\ntimedout = 0;\r\nxlr_nae_wreg(base_addr, R_MII_MGMT_ADDRESS, (phy_addr << 8) | regnum);\r\nxlr_nae_wreg(base_addr, R_MII_MGMT_WRITE_DATA, (u32)val);\r\nwhile (!timedout) {\r\nchecktime = jiffies;\r\nif (xlr_nae_rdreg(base_addr, R_MII_MGMT_INDICATORS) == 0)\r\nbreak;\r\ntimedout = time_after(checktime, stoptime);\r\n}\r\nif (timedout) {\r\npr_info("Phy device write err: device busy");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xlr_phy_read(u32 *base_addr, int phy_addr, int regnum)\r\n{\r\nunsigned long timeout, stoptime, checktime;\r\nint timedout;\r\ntimeout = msecs_to_jiffies(100);\r\nstoptime = jiffies + timeout;\r\ntimedout = 0;\r\nxlr_nae_wreg(base_addr, R_MII_MGMT_ADDRESS,\r\n(phy_addr << 8) | (regnum << 0));\r\nxlr_nae_wreg(base_addr, R_MII_MGMT_COMMAND,\r\n(1 << O_MII_MGMT_COMMAND__rstat));\r\nwhile (!timedout) {\r\nchecktime = jiffies;\r\nif (xlr_nae_rdreg(base_addr, R_MII_MGMT_INDICATORS) == 0)\r\nbreak;\r\ntimedout = time_after(checktime, stoptime);\r\n}\r\nif (timedout) {\r\npr_info("Phy device read err: device busy");\r\nreturn -EBUSY;\r\n}\r\nxlr_nae_wreg(base_addr, R_MII_MGMT_COMMAND, 0);\r\nreturn xlr_nae_rdreg(base_addr, R_MII_MGMT_STATUS);\r\n}\r\nstatic int xlr_mii_write(struct mii_bus *bus, int phy_addr, int regnum, u16 val)\r\n{\r\nstruct xlr_net_priv *priv = bus->priv;\r\nint ret;\r\nret = xlr_phy_write(priv->mii_addr, phy_addr, regnum, val);\r\ndev_dbg(&priv->ndev->dev, "mii_write phy %d : %d <- %x [%x]\n",\r\nphy_addr, regnum, val, ret);\r\nreturn ret;\r\n}\r\nstatic int xlr_mii_read(struct mii_bus *bus, int phy_addr, int regnum)\r\n{\r\nstruct xlr_net_priv *priv = bus->priv;\r\nint ret;\r\nret = xlr_phy_read(priv->mii_addr, phy_addr, regnum);\r\ndev_dbg(&priv->ndev->dev, "mii_read phy %d : %d [%x]\n",\r\nphy_addr, regnum, ret);\r\nreturn ret;\r\n}\r\nstatic void xlr_sgmii_init(struct xlr_net_priv *priv)\r\n{\r\nint phy;\r\nxlr_phy_write(priv->serdes_addr, 26, 0, 0x6DB0);\r\nxlr_phy_write(priv->serdes_addr, 26, 1, 0xFFFF);\r\nxlr_phy_write(priv->serdes_addr, 26, 2, 0xB6D0);\r\nxlr_phy_write(priv->serdes_addr, 26, 3, 0x00FF);\r\nxlr_phy_write(priv->serdes_addr, 26, 4, 0x0000);\r\nxlr_phy_write(priv->serdes_addr, 26, 5, 0x0000);\r\nxlr_phy_write(priv->serdes_addr, 26, 6, 0x0005);\r\nxlr_phy_write(priv->serdes_addr, 26, 7, 0x0001);\r\nxlr_phy_write(priv->serdes_addr, 26, 8, 0x0000);\r\nxlr_phy_write(priv->serdes_addr, 26, 9, 0x0000);\r\nxlr_phy_write(priv->serdes_addr, 26, 10, 0x0000);\r\nxlr_nae_wreg(priv->gpio_addr, 0x20, 0x7e6802);\r\nxlr_nae_wreg(priv->gpio_addr, 0x10, 0x7104);\r\nxlr_nae_wreg(priv->gpio_addr, 0x22, 0x7e6802);\r\nxlr_nae_wreg(priv->gpio_addr, 0x21, 0x7104);\r\nphy = priv->phy_addr % 4 + 27;\r\nxlr_phy_write(priv->pcs_addr, phy, 0, 0x1000);\r\nxlr_phy_write(priv->pcs_addr, phy, 0, 0x0200);\r\n}\r\nvoid xlr_set_gmac_speed(struct xlr_net_priv *priv)\r\n{\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nint speed;\r\nif (phydev->interface == PHY_INTERFACE_MODE_SGMII)\r\nxlr_sgmii_init(priv);\r\nif (phydev->speed != priv->phy_speed) {\r\nspeed = phydev->speed;\r\nif (speed == SPEED_1000) {\r\nxlr_nae_wreg(priv->base_addr, R_MAC_CONFIG_2, 0x7217);\r\npriv->phy_speed = speed;\r\n} else if (speed == SPEED_100 || speed == SPEED_10) {\r\nxlr_nae_wreg(priv->base_addr, R_MAC_CONFIG_2, 0x7117);\r\npriv->phy_speed = speed;\r\n}\r\nif (phydev->interface == PHY_INTERFACE_MODE_SGMII) {\r\nif (speed == SPEED_10)\r\nxlr_nae_wreg(priv->base_addr,\r\nR_INTERFACE_CONTROL,\r\nSGMII_SPEED_10);\r\nif (speed == SPEED_100)\r\nxlr_nae_wreg(priv->base_addr,\r\nR_INTERFACE_CONTROL,\r\nSGMII_SPEED_100);\r\nif (speed == SPEED_1000)\r\nxlr_nae_wreg(priv->base_addr,\r\nR_INTERFACE_CONTROL,\r\nSGMII_SPEED_1000);\r\n}\r\nif (speed == SPEED_10)\r\nxlr_nae_wreg(priv->base_addr, R_CORECONTROL, 0x2);\r\nif (speed == SPEED_100)\r\nxlr_nae_wreg(priv->base_addr, R_CORECONTROL, 0x1);\r\nif (speed == SPEED_1000)\r\nxlr_nae_wreg(priv->base_addr, R_CORECONTROL, 0x0);\r\n}\r\npr_info("gmac%d : %dMbps\n", priv->port_id, priv->phy_speed);\r\n}\r\nstatic void xlr_gmac_link_adjust(struct net_device *ndev)\r\n{\r\nstruct xlr_net_priv *priv = netdev_priv(ndev);\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nu32 intreg;\r\nintreg = xlr_nae_rdreg(priv->base_addr, R_INTREG);\r\nif (phydev->link) {\r\nif (phydev->speed != priv->phy_speed) {\r\nxlr_set_gmac_speed(priv);\r\npr_info("gmac%d : Link up\n", priv->port_id);\r\n}\r\n} else {\r\nxlr_set_gmac_speed(priv);\r\npr_info("gmac%d : Link down\n", priv->port_id);\r\n}\r\n}\r\nstatic int xlr_mii_probe(struct xlr_net_priv *priv)\r\n{\r\nstruct phy_device *phydev = xlr_get_phydev(priv);\r\nif (!phydev) {\r\npr_err("no PHY found on phy_addr %d\n", priv->phy_addr);\r\nreturn -ENODEV;\r\n}\r\nphydev = phy_connect(priv->ndev, phydev_name(phydev),\r\nxlr_gmac_link_adjust, priv->nd->phy_interface);\r\nif (IS_ERR(phydev)) {\r\npr_err("could not attach PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nphydev->supported &= (ADVERTISED_10baseT_Full\r\n| ADVERTISED_10baseT_Half\r\n| ADVERTISED_100baseT_Full\r\n| ADVERTISED_100baseT_Half\r\n| ADVERTISED_1000baseT_Full\r\n| ADVERTISED_Autoneg\r\n| ADVERTISED_MII);\r\nphydev->advertising = phydev->supported;\r\nphy_attached_info(phydev);\r\nreturn 0;\r\n}\r\nstatic int xlr_setup_mdio(struct xlr_net_priv *priv,\r\nstruct platform_device *pdev)\r\n{\r\nint err;\r\npriv->mii_bus = mdiobus_alloc();\r\nif (!priv->mii_bus) {\r\npr_err("mdiobus alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\npriv->mii_bus->priv = priv;\r\npriv->mii_bus->name = "xlr-mdio";\r\nsnprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s-%d",\r\npriv->mii_bus->name, priv->port_id);\r\npriv->mii_bus->read = xlr_mii_read;\r\npriv->mii_bus->write = xlr_mii_write;\r\npriv->mii_bus->parent = &pdev->dev;\r\npriv->mii_bus->phy_mask = ~(1 << priv->phy_addr);\r\nxlr_nae_wreg(priv->base_addr, R_MII_MGMT_CONFIG, 0x7);\r\nerr = mdiobus_register(priv->mii_bus);\r\nif (err) {\r\nmdiobus_free(priv->mii_bus);\r\npr_err("mdio bus registration failed\n");\r\nreturn err;\r\n}\r\npr_info("Registered mdio bus id : %s\n", priv->mii_bus->id);\r\nerr = xlr_mii_probe(priv);\r\nif (err) {\r\nmdiobus_free(priv->mii_bus);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xlr_port_enable(struct xlr_net_priv *priv)\r\n{\r\nu32 prid = (read_c0_prid() & 0xf000);\r\nif ((prid == 0x8000 || prid == 0x4000 || prid == 0xc000) &&\r\npriv->nd->phy_interface == PHY_INTERFACE_MODE_RGMII)\r\nxlr_reg_update(priv->base_addr, R_RX_CONTROL,\r\n(1 << O_RX_CONTROL__RGMII),\r\n(1 << O_RX_CONTROL__RGMII));\r\nxlr_reg_update(priv->base_addr, R_MAC_CONFIG_1,\r\n((1 << O_MAC_CONFIG_1__rxen) |\r\n(1 << O_MAC_CONFIG_1__txen) |\r\n(1 << O_MAC_CONFIG_1__rxfc) |\r\n(1 << O_MAC_CONFIG_1__txfc)),\r\n((1 << O_MAC_CONFIG_1__rxen) |\r\n(1 << O_MAC_CONFIG_1__txen) |\r\n(1 << O_MAC_CONFIG_1__rxfc) |\r\n(1 << O_MAC_CONFIG_1__txfc)));\r\nxlr_reg_update(priv->base_addr, R_TX_CONTROL,\r\n((1 << O_TX_CONTROL__TXENABLE) |\r\n(512 << O_TX_CONTROL__TXTHRESHOLD)), 0x3fff);\r\nxlr_reg_update(priv->base_addr, R_RX_CONTROL,\r\n1 << O_RX_CONTROL__RXENABLE,\r\n1 << O_RX_CONTROL__RXENABLE);\r\n}\r\nstatic void xlr_port_disable(struct xlr_net_priv *priv)\r\n{\r\nxlr_reg_update(priv->base_addr, R_MAC_CONFIG_1,\r\n((1 << O_MAC_CONFIG_1__rxen) |\r\n(1 << O_MAC_CONFIG_1__txen) |\r\n(1 << O_MAC_CONFIG_1__rxfc) |\r\n(1 << O_MAC_CONFIG_1__txfc)), 0x0);\r\nxlr_reg_update(priv->base_addr, R_TX_CONTROL,\r\n((1 << O_TX_CONTROL__TXENABLE) |\r\n(512 << O_TX_CONTROL__TXTHRESHOLD)), 0);\r\nxlr_reg_update(priv->base_addr, R_RX_CONTROL,\r\n1 << O_RX_CONTROL__RXENABLE, 0);\r\n}\r\nstatic int xlr_gmac_init(struct xlr_net_priv *priv,\r\nstruct platform_device *pdev)\r\n{\r\nint ret;\r\npr_info("Initializing the gmac%d\n", priv->port_id);\r\nxlr_port_disable(priv);\r\nxlr_nae_wreg(priv->base_addr, R_DESC_PACK_CTRL,\r\n(1 << O_DESC_PACK_CTRL__MAXENTRY) |\r\n(BYTE_OFFSET << O_DESC_PACK_CTRL__BYTEOFFSET) |\r\n(1600 << O_DESC_PACK_CTRL__REGULARSIZE));\r\nret = xlr_setup_mdio(priv, pdev);\r\nif (ret)\r\nreturn ret;\r\nxlr_port_enable(priv);\r\nxlr_nae_wreg(priv->base_addr, R_MAC_CONFIG_2, 0x7217);\r\nxlr_nae_wreg(priv->base_addr, R_CORECONTROL, 0x02);\r\nxlr_nae_wreg(priv->base_addr, R_INTMASK, (1 << O_INTMASK__TXILLEGAL) |\r\n(1 << O_INTMASK__MDINT) | (1 << O_INTMASK__TXFETCHERROR) |\r\n(1 << O_INTMASK__P2PSPILLECC) | (1 << O_INTMASK__TAGFULL) |\r\n(1 << O_INTMASK__UNDERRUN) | (1 << O_INTMASK__ABORT));\r\nxlr_reg_update(priv->base_addr, R_STATCTRL, 0, 1 << O_STATCTRL__CLRCNT);\r\nxlr_reg_update(priv->base_addr, R_STATCTRL, 1 << 2, 1 << 2);\r\nreturn 0;\r\n}\r\nstatic int xlr_net_probe(struct platform_device *pdev)\r\n{\r\nstruct xlr_net_priv *priv = NULL;\r\nstruct net_device *ndev;\r\nstruct resource *res;\r\nstruct xlr_adapter *adapter;\r\nint err, port;\r\npr_info("XLR/XLS Ethernet Driver controller %d\n", pdev->id);\r\nadapter = (struct xlr_adapter *)\r\ndevm_kzalloc(&pdev->dev, sizeof(*adapter), GFP_KERNEL);\r\nif (!adapter)\r\nreturn -ENOMEM;\r\nfor (port = 0; port < pdev->num_resources / 2; port++) {\r\nndev = alloc_etherdev_mq(sizeof(struct xlr_net_priv), 32);\r\nif (!ndev) {\r\ndev_err(&pdev->dev,\r\n"Allocation of Ethernet device failed\n");\r\nreturn -ENOMEM;\r\n}\r\npriv = netdev_priv(ndev);\r\npriv->pdev = pdev;\r\npriv->ndev = ndev;\r\npriv->port_id = (pdev->id * 4) + port;\r\npriv->nd = (struct xlr_net_data *)pdev->dev.platform_data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, port);\r\npriv->base_addr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(priv->base_addr)) {\r\nerr = PTR_ERR(priv->base_addr);\r\ngoto err_gmac;\r\n}\r\npriv->adapter = adapter;\r\nadapter->netdev[port] = ndev;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, port);\r\nif (!res) {\r\ndev_err(&pdev->dev, "No irq resource for MAC %d\n",\r\npriv->port_id);\r\nerr = -ENODEV;\r\ngoto err_gmac;\r\n}\r\nndev->irq = res->start;\r\npriv->phy_addr = priv->nd->phy_addr[port];\r\npriv->tx_stnid = priv->nd->tx_stnid[port];\r\npriv->mii_addr = priv->nd->mii_addr;\r\npriv->serdes_addr = priv->nd->serdes_addr;\r\npriv->pcs_addr = priv->nd->pcs_addr;\r\npriv->gpio_addr = priv->nd->gpio_addr;\r\nndev->netdev_ops = &xlr_netdev_ops;\r\nndev->watchdog_timeo = HZ;\r\neth_hw_addr_random(ndev);\r\nxlr_hw_set_mac_addr(ndev);\r\nxlr_set_rx_mode(ndev);\r\npriv->num_rx_desc += MAX_NUM_DESC_SPILL;\r\nndev->ethtool_ops = &xlr_ethtool_ops;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nxlr_config_fifo_spill_area(priv);\r\nxlr_config_pde(priv);\r\nxlr_config_parser(priv);\r\nif (strcmp(res->name, "gmac") == 0) {\r\nerr = xlr_gmac_init(priv, pdev);\r\nif (err) {\r\ndev_err(&pdev->dev, "gmac%d init failed\n",\r\npriv->port_id);\r\ngoto err_gmac;\r\n}\r\n}\r\nif (priv->port_id == 0 || priv->port_id == 4) {\r\nerr = xlr_config_common(priv);\r\nif (err)\r\ngoto err_netdev;\r\n}\r\nerr = register_netdev(ndev);\r\nif (err) {\r\ndev_err(&pdev->dev,\r\n"Registering netdev failed for gmac%d\n",\r\npriv->port_id);\r\ngoto err_netdev;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\n}\r\nreturn 0;\r\nerr_netdev:\r\nmdiobus_free(priv->mii_bus);\r\nerr_gmac:\r\nfree_netdev(ndev);\r\nreturn err;\r\n}\r\nstatic int xlr_net_remove(struct platform_device *pdev)\r\n{\r\nstruct xlr_net_priv *priv = platform_get_drvdata(pdev);\r\nunregister_netdev(priv->ndev);\r\nmdiobus_unregister(priv->mii_bus);\r\nmdiobus_free(priv->mii_bus);\r\nfree_netdev(priv->ndev);\r\nreturn 0;\r\n}
