static int insert_page(struct mlx5_core_dev *dev, u64 addr, struct page *page, u16 func_id)\r\n{\r\nstruct rb_root *root = &dev->priv.page_root;\r\nstruct rb_node **new = &root->rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct fw_page *nfp;\r\nstruct fw_page *tfp;\r\nint i;\r\nwhile (*new) {\r\nparent = *new;\r\ntfp = rb_entry(parent, struct fw_page, rb_node);\r\nif (tfp->addr < addr)\r\nnew = &parent->rb_left;\r\nelse if (tfp->addr > addr)\r\nnew = &parent->rb_right;\r\nelse\r\nreturn -EEXIST;\r\n}\r\nnfp = kzalloc(sizeof(*nfp), GFP_KERNEL);\r\nif (!nfp)\r\nreturn -ENOMEM;\r\nnfp->addr = addr;\r\nnfp->page = page;\r\nnfp->func_id = func_id;\r\nnfp->free_count = MLX5_NUM_4K_IN_PAGE;\r\nfor (i = 0; i < MLX5_NUM_4K_IN_PAGE; i++)\r\nset_bit(i, &nfp->bitmask);\r\nrb_link_node(&nfp->rb_node, parent, new);\r\nrb_insert_color(&nfp->rb_node, root);\r\nlist_add(&nfp->list, &dev->priv.free_list);\r\nreturn 0;\r\n}\r\nstatic struct fw_page *find_fw_page(struct mlx5_core_dev *dev, u64 addr)\r\n{\r\nstruct rb_root *root = &dev->priv.page_root;\r\nstruct rb_node *tmp = root->rb_node;\r\nstruct fw_page *result = NULL;\r\nstruct fw_page *tfp;\r\nwhile (tmp) {\r\ntfp = rb_entry(tmp, struct fw_page, rb_node);\r\nif (tfp->addr < addr) {\r\ntmp = tmp->rb_left;\r\n} else if (tfp->addr > addr) {\r\ntmp = tmp->rb_right;\r\n} else {\r\nresult = tfp;\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic int mlx5_cmd_query_pages(struct mlx5_core_dev *dev, u16 *func_id,\r\ns32 *npages, int boot)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(query_pages_out)] = {0};\r\nu32 in[MLX5_ST_SZ_DW(query_pages_in)] = {0};\r\nint err;\r\nMLX5_SET(query_pages_in, in, opcode, MLX5_CMD_OP_QUERY_PAGES);\r\nMLX5_SET(query_pages_in, in, op_mod, boot ?\r\nMLX5_QUERY_PAGES_IN_OP_MOD_BOOT_PAGES :\r\nMLX5_QUERY_PAGES_IN_OP_MOD_INIT_PAGES);\r\nerr = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\r\nif (err)\r\nreturn err;\r\n*npages = MLX5_GET(query_pages_out, out, num_pages);\r\n*func_id = MLX5_GET(query_pages_out, out, function_id);\r\nreturn err;\r\n}\r\nstatic int alloc_4k(struct mlx5_core_dev *dev, u64 *addr)\r\n{\r\nstruct fw_page *fp;\r\nunsigned n;\r\nif (list_empty(&dev->priv.free_list))\r\nreturn -ENOMEM;\r\nfp = list_entry(dev->priv.free_list.next, struct fw_page, list);\r\nn = find_first_bit(&fp->bitmask, 8 * sizeof(fp->bitmask));\r\nif (n >= MLX5_NUM_4K_IN_PAGE) {\r\nmlx5_core_warn(dev, "alloc 4k bug\n");\r\nreturn -ENOENT;\r\n}\r\nclear_bit(n, &fp->bitmask);\r\nfp->free_count--;\r\nif (!fp->free_count)\r\nlist_del(&fp->list);\r\n*addr = fp->addr + n * MLX5_ADAPTER_PAGE_SIZE;\r\nreturn 0;\r\n}\r\nstatic void free_4k(struct mlx5_core_dev *dev, u64 addr)\r\n{\r\nstruct fw_page *fwp;\r\nint n;\r\nfwp = find_fw_page(dev, addr & MLX5_U64_4K_PAGE_MASK);\r\nif (!fwp) {\r\nmlx5_core_warn(dev, "page not found\n");\r\nreturn;\r\n}\r\nn = (addr & ~MLX5_U64_4K_PAGE_MASK) >> MLX5_ADAPTER_PAGE_SHIFT;\r\nfwp->free_count++;\r\nset_bit(n, &fwp->bitmask);\r\nif (fwp->free_count == MLX5_NUM_4K_IN_PAGE) {\r\nrb_erase(&fwp->rb_node, &dev->priv.page_root);\r\nif (fwp->free_count != 1)\r\nlist_del(&fwp->list);\r\ndma_unmap_page(&dev->pdev->dev, addr & MLX5_U64_4K_PAGE_MASK,\r\nPAGE_SIZE, DMA_BIDIRECTIONAL);\r\n__free_page(fwp->page);\r\nkfree(fwp);\r\n} else if (fwp->free_count == 1) {\r\nlist_add(&fwp->list, &dev->priv.free_list);\r\n}\r\n}\r\nstatic int alloc_system_page(struct mlx5_core_dev *dev, u16 func_id)\r\n{\r\nstruct page *page;\r\nu64 zero_addr = 1;\r\nu64 addr;\r\nint err;\r\nint nid = dev_to_node(&dev->pdev->dev);\r\npage = alloc_pages_node(nid, GFP_HIGHUSER, 0);\r\nif (!page) {\r\nmlx5_core_warn(dev, "failed to allocate page\n");\r\nreturn -ENOMEM;\r\n}\r\nmap:\r\naddr = dma_map_page(&dev->pdev->dev, page, 0,\r\nPAGE_SIZE, DMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(&dev->pdev->dev, addr)) {\r\nmlx5_core_warn(dev, "failed dma mapping page\n");\r\nerr = -ENOMEM;\r\ngoto err_mapping;\r\n}\r\nif (addr == 0) {\r\nzero_addr = addr;\r\ngoto map;\r\n}\r\nerr = insert_page(dev, addr, page, func_id);\r\nif (err) {\r\nmlx5_core_err(dev, "failed to track allocated page\n");\r\ndma_unmap_page(&dev->pdev->dev, addr, PAGE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\n}\r\nerr_mapping:\r\nif (err)\r\n__free_page(page);\r\nif (zero_addr == 0)\r\ndma_unmap_page(&dev->pdev->dev, zero_addr, PAGE_SIZE,\r\nDMA_BIDIRECTIONAL);\r\nreturn err;\r\n}\r\nstatic void page_notify_fail(struct mlx5_core_dev *dev, u16 func_id)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(manage_pages_out)] = {0};\r\nu32 in[MLX5_ST_SZ_DW(manage_pages_in)] = {0};\r\nint err;\r\nMLX5_SET(manage_pages_in, in, opcode, MLX5_CMD_OP_MANAGE_PAGES);\r\nMLX5_SET(manage_pages_in, in, op_mod, MLX5_PAGES_CANT_GIVE);\r\nMLX5_SET(manage_pages_in, in, function_id, func_id);\r\nerr = mlx5_cmd_exec(dev, in, sizeof(in), out, sizeof(out));\r\nif (err)\r\nmlx5_core_warn(dev, "page notify failed func_id(%d) err(%d)\n",\r\nfunc_id, err);\r\n}\r\nstatic int give_pages(struct mlx5_core_dev *dev, u16 func_id, int npages,\r\nint notify_fail)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(manage_pages_out)] = {0};\r\nint inlen = MLX5_ST_SZ_BYTES(manage_pages_in);\r\nu64 addr;\r\nint err;\r\nu32 *in;\r\nint i;\r\ninlen += npages * MLX5_FLD_SZ_BYTES(manage_pages_in, pas[0]);\r\nin = mlx5_vzalloc(inlen);\r\nif (!in) {\r\nerr = -ENOMEM;\r\nmlx5_core_warn(dev, "vzalloc failed %d\n", inlen);\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < npages; i++) {\r\nretry:\r\nerr = alloc_4k(dev, &addr);\r\nif (err) {\r\nif (err == -ENOMEM)\r\nerr = alloc_system_page(dev, func_id);\r\nif (err)\r\ngoto out_4k;\r\ngoto retry;\r\n}\r\nMLX5_ARRAY_SET64(manage_pages_in, in, pas, i, addr);\r\n}\r\nMLX5_SET(manage_pages_in, in, opcode, MLX5_CMD_OP_MANAGE_PAGES);\r\nMLX5_SET(manage_pages_in, in, op_mod, MLX5_PAGES_GIVE);\r\nMLX5_SET(manage_pages_in, in, function_id, func_id);\r\nMLX5_SET(manage_pages_in, in, input_num_entries, npages);\r\nerr = mlx5_cmd_exec(dev, in, inlen, out, sizeof(out));\r\nif (err) {\r\nmlx5_core_warn(dev, "func_id 0x%x, npages %d, err %d\n",\r\nfunc_id, npages, err);\r\ngoto out_4k;\r\n}\r\ndev->priv.fw_pages += npages;\r\nif (func_id)\r\ndev->priv.vfs_pages += npages;\r\nmlx5_core_dbg(dev, "err %d\n", err);\r\nkvfree(in);\r\nreturn 0;\r\nout_4k:\r\nfor (i--; i >= 0; i--)\r\nfree_4k(dev, MLX5_GET64(manage_pages_in, in, pas[i]));\r\nout_free:\r\nkvfree(in);\r\nif (notify_fail)\r\npage_notify_fail(dev, func_id);\r\nreturn err;\r\n}\r\nstatic int reclaim_pages_cmd(struct mlx5_core_dev *dev,\r\nu32 *in, int in_size, u32 *out, int out_size)\r\n{\r\nstruct fw_page *fwp;\r\nstruct rb_node *p;\r\nu32 func_id;\r\nu32 npages;\r\nu32 i = 0;\r\nif (dev->state != MLX5_DEVICE_STATE_INTERNAL_ERROR)\r\nreturn mlx5_cmd_exec(dev, in, in_size, out, out_size);\r\nnpages = MLX5_GET(manage_pages_in, in, input_num_entries);\r\nfunc_id = MLX5_GET(manage_pages_in, in, function_id);\r\np = rb_first(&dev->priv.page_root);\r\nwhile (p && i < npages) {\r\nfwp = rb_entry(p, struct fw_page, rb_node);\r\np = rb_next(p);\r\nif (fwp->func_id != func_id)\r\ncontinue;\r\nMLX5_ARRAY_SET64(manage_pages_out, out, pas, i, fwp->addr);\r\ni++;\r\n}\r\nMLX5_SET(manage_pages_out, out, output_num_entries, i);\r\nreturn 0;\r\n}\r\nstatic int reclaim_pages(struct mlx5_core_dev *dev, u32 func_id, int npages,\r\nint *nclaimed)\r\n{\r\nint outlen = MLX5_ST_SZ_BYTES(manage_pages_out);\r\nu32 in[MLX5_ST_SZ_DW(manage_pages_in)] = {0};\r\nint num_claimed;\r\nu32 *out;\r\nint err;\r\nint i;\r\nif (nclaimed)\r\n*nclaimed = 0;\r\noutlen += npages * MLX5_FLD_SZ_BYTES(manage_pages_out, pas[0]);\r\nout = mlx5_vzalloc(outlen);\r\nif (!out)\r\nreturn -ENOMEM;\r\nMLX5_SET(manage_pages_in, in, opcode, MLX5_CMD_OP_MANAGE_PAGES);\r\nMLX5_SET(manage_pages_in, in, op_mod, MLX5_PAGES_TAKE);\r\nMLX5_SET(manage_pages_in, in, function_id, func_id);\r\nMLX5_SET(manage_pages_in, in, input_num_entries, npages);\r\nmlx5_core_dbg(dev, "npages %d, outlen %d\n", npages, outlen);\r\nerr = reclaim_pages_cmd(dev, in, sizeof(in), out, outlen);\r\nif (err) {\r\nmlx5_core_err(dev, "failed reclaiming pages: err %d\n", err);\r\ngoto out_free;\r\n}\r\nnum_claimed = MLX5_GET(manage_pages_out, out, output_num_entries);\r\nif (num_claimed > npages) {\r\nmlx5_core_warn(dev, "fw returned %d, driver asked %d => corruption\n",\r\nnum_claimed, npages);\r\nerr = -EINVAL;\r\ngoto out_free;\r\n}\r\nfor (i = 0; i < num_claimed; i++)\r\nfree_4k(dev, MLX5_GET64(manage_pages_out, out, pas[i]));\r\nif (nclaimed)\r\n*nclaimed = num_claimed;\r\ndev->priv.fw_pages -= num_claimed;\r\nif (func_id)\r\ndev->priv.vfs_pages -= num_claimed;\r\nout_free:\r\nkvfree(out);\r\nreturn err;\r\n}\r\nstatic void pages_work_handler(struct work_struct *work)\r\n{\r\nstruct mlx5_pages_req *req = container_of(work, struct mlx5_pages_req, work);\r\nstruct mlx5_core_dev *dev = req->dev;\r\nint err = 0;\r\nif (req->npages < 0)\r\nerr = reclaim_pages(dev, req->func_id, -1 * req->npages, NULL);\r\nelse if (req->npages > 0)\r\nerr = give_pages(dev, req->func_id, req->npages, 1);\r\nif (err)\r\nmlx5_core_warn(dev, "%s fail %d\n",\r\nreq->npages < 0 ? "reclaim" : "give", err);\r\nkfree(req);\r\n}\r\nvoid mlx5_core_req_pages_handler(struct mlx5_core_dev *dev, u16 func_id,\r\ns32 npages)\r\n{\r\nstruct mlx5_pages_req *req;\r\nreq = kzalloc(sizeof(*req), GFP_ATOMIC);\r\nif (!req) {\r\nmlx5_core_warn(dev, "failed to allocate pages request\n");\r\nreturn;\r\n}\r\nreq->dev = dev;\r\nreq->func_id = func_id;\r\nreq->npages = npages;\r\nINIT_WORK(&req->work, pages_work_handler);\r\nqueue_work(dev->priv.pg_wq, &req->work);\r\n}\r\nint mlx5_satisfy_startup_pages(struct mlx5_core_dev *dev, int boot)\r\n{\r\nu16 uninitialized_var(func_id);\r\ns32 uninitialized_var(npages);\r\nint err;\r\nerr = mlx5_cmd_query_pages(dev, &func_id, &npages, boot);\r\nif (err)\r\nreturn err;\r\nmlx5_core_dbg(dev, "requested %d %s pages for func_id 0x%x\n",\r\nnpages, boot ? "boot" : "init", func_id);\r\nreturn give_pages(dev, func_id, npages, 0);\r\n}\r\nstatic int optimal_reclaimed_pages(void)\r\n{\r\nstruct mlx5_cmd_prot_block *block;\r\nstruct mlx5_cmd_layout *lay;\r\nint ret;\r\nret = (sizeof(lay->out) + MLX5_BLKS_FOR_RECLAIM_PAGES * sizeof(block->data) -\r\nMLX5_ST_SZ_BYTES(manage_pages_out)) /\r\nMLX5_FLD_SZ_BYTES(manage_pages_out, pas[0]);\r\nreturn ret;\r\n}\r\nint mlx5_reclaim_startup_pages(struct mlx5_core_dev *dev)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(MAX_RECLAIM_TIME_MSECS);\r\nstruct fw_page *fwp;\r\nstruct rb_node *p;\r\nint nclaimed = 0;\r\nint err = 0;\r\ndo {\r\np = rb_first(&dev->priv.page_root);\r\nif (p) {\r\nfwp = rb_entry(p, struct fw_page, rb_node);\r\nerr = reclaim_pages(dev, fwp->func_id,\r\noptimal_reclaimed_pages(),\r\n&nclaimed);\r\nif (err) {\r\nmlx5_core_warn(dev, "failed reclaiming pages (%d)\n",\r\nerr);\r\nreturn err;\r\n}\r\nif (nclaimed)\r\nend = jiffies + msecs_to_jiffies(MAX_RECLAIM_TIME_MSECS);\r\n}\r\nif (time_after(jiffies, end)) {\r\nmlx5_core_warn(dev, "FW did not return all pages. giving up...\n");\r\nbreak;\r\n}\r\n} while (p);\r\nWARN(dev->priv.fw_pages,\r\n"FW pages counter is %d after reclaiming all pages\n",\r\ndev->priv.fw_pages);\r\nWARN(dev->priv.vfs_pages,\r\n"VFs FW pages counter is %d after reclaiming all pages\n",\r\ndev->priv.vfs_pages);\r\nreturn 0;\r\n}\r\nvoid mlx5_pagealloc_init(struct mlx5_core_dev *dev)\r\n{\r\ndev->priv.page_root = RB_ROOT;\r\nINIT_LIST_HEAD(&dev->priv.free_list);\r\n}\r\nvoid mlx5_pagealloc_cleanup(struct mlx5_core_dev *dev)\r\n{\r\n}\r\nint mlx5_pagealloc_start(struct mlx5_core_dev *dev)\r\n{\r\ndev->priv.pg_wq = create_singlethread_workqueue("mlx5_page_allocator");\r\nif (!dev->priv.pg_wq)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mlx5_pagealloc_stop(struct mlx5_core_dev *dev)\r\n{\r\ndestroy_workqueue(dev->priv.pg_wq);\r\n}\r\nint mlx5_wait_for_vf_pages(struct mlx5_core_dev *dev)\r\n{\r\nunsigned long end = jiffies + msecs_to_jiffies(MAX_RECLAIM_VFS_PAGES_TIME_MSECS);\r\nint prev_vfs_pages = dev->priv.vfs_pages;\r\nif (dev->state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {\r\nmlx5_core_warn(dev, "Skipping wait for vf pages stage");\r\nreturn 0;\r\n}\r\nmlx5_core_dbg(dev, "Waiting for %d pages from %s\n", prev_vfs_pages,\r\ndev->priv.name);\r\nwhile (dev->priv.vfs_pages) {\r\nif (time_after(jiffies, end)) {\r\nmlx5_core_warn(dev, "aborting while there are %d pending pages\n", dev->priv.vfs_pages);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (dev->priv.vfs_pages < prev_vfs_pages) {\r\nend = jiffies + msecs_to_jiffies(MAX_RECLAIM_VFS_PAGES_TIME_MSECS);\r\nprev_vfs_pages = dev->priv.vfs_pages;\r\n}\r\nmsleep(50);\r\n}\r\nmlx5_core_dbg(dev, "All pages received from %s\n", dev->priv.name);\r\nreturn 0;\r\n}
