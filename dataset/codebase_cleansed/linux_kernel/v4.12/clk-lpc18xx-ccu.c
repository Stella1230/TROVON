static struct clk *lpc18xx_ccu_branch_clk_get(struct of_phandle_args *clkspec,\r\nvoid *data)\r\n{\r\nstruct lpc18xx_branch_clk_data *clk_data = data;\r\nunsigned int offset = clkspec->args[0];\r\nint i, j;\r\nfor (i = 0; i < ARRAY_SIZE(clk_branches); i++) {\r\nif (clk_branches[i].offset != offset)\r\ncontinue;\r\nfor (j = 0; j < clk_data->num; j++) {\r\nif (!strcmp(clk_branches[i].base_name, clk_data->name[j]))\r\nreturn clk_branches[i].clk;\r\n}\r\n}\r\npr_err("%s: invalid clock offset %d\n", __func__, offset);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic int lpc18xx_ccu_gate_endisable(struct clk_hw *hw, bool enable)\r\n{\r\nstruct clk_gate *gate = to_clk_gate(hw);\r\nu32 val;\r\nval = clk_readl(gate->reg);\r\nif (val & LPC18XX_CCU_DIVSTAT)\r\nval |= LPC18XX_CCU_DIV;\r\nif (enable) {\r\nval |= LPC18XX_CCU_RUN;\r\n} else {\r\nval |= LPC18XX_CCU_AUTO;\r\nclk_writel(val, gate->reg);\r\nval &= ~LPC18XX_CCU_RUN;\r\n}\r\nclk_writel(val, gate->reg);\r\nreturn 0;\r\n}\r\nstatic int lpc18xx_ccu_gate_enable(struct clk_hw *hw)\r\n{\r\nreturn lpc18xx_ccu_gate_endisable(hw, true);\r\n}\r\nstatic void lpc18xx_ccu_gate_disable(struct clk_hw *hw)\r\n{\r\nlpc18xx_ccu_gate_endisable(hw, false);\r\n}\r\nstatic int lpc18xx_ccu_gate_is_enabled(struct clk_hw *hw)\r\n{\r\nconst struct clk_hw *parent;\r\nparent = clk_hw_get_parent(hw);\r\nif (!parent)\r\nreturn 0;\r\nif (!clk_hw_is_enabled(parent))\r\nreturn 0;\r\nreturn clk_gate_ops.is_enabled(hw);\r\n}\r\nstatic void lpc18xx_ccu_register_branch_gate_div(struct lpc18xx_clk_branch *branch,\r\nvoid __iomem *reg_base,\r\nconst char *parent)\r\n{\r\nconst struct clk_ops *div_ops = NULL;\r\nstruct clk_divider *div = NULL;\r\nstruct clk_hw *div_hw = NULL;\r\nif (branch->flags & CCU_BRANCH_HAVE_DIV2) {\r\ndiv = kzalloc(sizeof(*div), GFP_KERNEL);\r\nif (!div)\r\nreturn;\r\ndiv->reg = branch->offset + reg_base;\r\ndiv->flags = CLK_DIVIDER_READ_ONLY;\r\ndiv->shift = 27;\r\ndiv->width = 1;\r\ndiv_hw = &div->hw;\r\ndiv_ops = &clk_divider_ro_ops;\r\n}\r\nbranch->gate.reg = branch->offset + reg_base;\r\nbranch->gate.bit_idx = 0;\r\nbranch->clk = clk_register_composite(NULL, branch->name, &parent, 1,\r\nNULL, NULL,\r\ndiv_hw, div_ops,\r\n&branch->gate.hw, &lpc18xx_ccu_gate_ops, 0);\r\nif (IS_ERR(branch->clk)) {\r\nkfree(div);\r\npr_warn("%s: failed to register %s\n", __func__, branch->name);\r\nreturn;\r\n}\r\nswitch (branch->offset) {\r\ncase CLK_CPU_EMC:\r\ncase CLK_CPU_CORE:\r\ncase CLK_CPU_CREG:\r\ncase CLK_CPU_EMCDIV:\r\nclk_prepare_enable(branch->clk);\r\n}\r\n}\r\nstatic void lpc18xx_ccu_register_branch_clks(void __iomem *reg_base,\r\nconst char *base_name)\r\n{\r\nconst char *parent = base_name;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(clk_branches); i++) {\r\nif (strcmp(clk_branches[i].base_name, base_name))\r\ncontinue;\r\nlpc18xx_ccu_register_branch_gate_div(&clk_branches[i], reg_base,\r\nparent);\r\nif (clk_branches[i].flags & CCU_BRANCH_IS_BUS)\r\nparent = clk_branches[i].name;\r\n}\r\n}\r\nstatic void __init lpc18xx_ccu_init(struct device_node *np)\r\n{\r\nstruct lpc18xx_branch_clk_data *clk_data;\r\nvoid __iomem *reg_base;\r\nint i, ret;\r\nreg_base = of_iomap(np, 0);\r\nif (!reg_base) {\r\npr_warn("%s: failed to map address range\n", __func__);\r\nreturn;\r\n}\r\nclk_data = kzalloc(sizeof(*clk_data), GFP_KERNEL);\r\nif (!clk_data) {\r\niounmap(reg_base);\r\nreturn;\r\n}\r\nclk_data->num = of_property_count_strings(np, "clock-names");\r\nclk_data->name = kcalloc(clk_data->num, sizeof(char *), GFP_KERNEL);\r\nif (!clk_data->name) {\r\niounmap(reg_base);\r\nkfree(clk_data);\r\nreturn;\r\n}\r\nfor (i = 0; i < clk_data->num; i++) {\r\nret = of_property_read_string_index(np, "clock-names", i,\r\n&clk_data->name[i]);\r\nif (ret) {\r\npr_warn("%s: failed to get clock name at idx %d\n",\r\n__func__, i);\r\ncontinue;\r\n}\r\nlpc18xx_ccu_register_branch_clks(reg_base, clk_data->name[i]);\r\n}\r\nof_clk_add_provider(np, lpc18xx_ccu_branch_clk_get, clk_data);\r\n}
