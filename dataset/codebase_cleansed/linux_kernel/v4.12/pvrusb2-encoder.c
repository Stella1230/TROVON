static int pvr2_encoder_write_words(struct pvr2_hdw *hdw,\r\nunsigned int offs,\r\nconst u32 *data, unsigned int dlen)\r\n{\r\nunsigned int idx,addr;\r\nunsigned int bAddr;\r\nint ret;\r\nunsigned int chunkCnt;\r\nwhile (dlen) {\r\nchunkCnt = 8;\r\nif (chunkCnt > dlen) chunkCnt = dlen;\r\nmemset(hdw->cmd_buffer,0,sizeof(hdw->cmd_buffer));\r\nbAddr = 0;\r\nhdw->cmd_buffer[bAddr++] = FX2CMD_MEM_WRITE_DWORD;\r\nfor (idx = 0; idx < chunkCnt; idx++) {\r\naddr = idx + offs;\r\nhdw->cmd_buffer[bAddr+6] = (addr & 0xffu);\r\nhdw->cmd_buffer[bAddr+5] = ((addr>>8) & 0xffu);\r\nhdw->cmd_buffer[bAddr+4] = ((addr>>16) & 0xffu);\r\nPVR2_DECOMPOSE_LE(hdw->cmd_buffer, bAddr,data[idx]);\r\nbAddr += 7;\r\n}\r\nret = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,1+(chunkCnt*7),\r\nNULL,0);\r\nif (ret) return ret;\r\ndata += chunkCnt;\r\ndlen -= chunkCnt;\r\noffs += chunkCnt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_encoder_read_words(struct pvr2_hdw *hdw,\r\nunsigned int offs,\r\nu32 *data, unsigned int dlen)\r\n{\r\nunsigned int idx;\r\nint ret;\r\nunsigned int chunkCnt;\r\nwhile (dlen) {\r\nchunkCnt = 16;\r\nif (chunkCnt > dlen) chunkCnt = dlen;\r\nif (chunkCnt < 16) chunkCnt = 1;\r\nhdw->cmd_buffer[0] =\r\n((chunkCnt == 1) ?\r\nFX2CMD_MEM_READ_DWORD : FX2CMD_MEM_READ_64BYTES);\r\nhdw->cmd_buffer[1] = 0;\r\nhdw->cmd_buffer[2] = 0;\r\nhdw->cmd_buffer[3] = 0;\r\nhdw->cmd_buffer[4] = 0;\r\nhdw->cmd_buffer[5] = ((offs>>16) & 0xffu);\r\nhdw->cmd_buffer[6] = ((offs>>8) & 0xffu);\r\nhdw->cmd_buffer[7] = (offs & 0xffu);\r\nret = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,8,\r\nhdw->cmd_buffer,\r\n(chunkCnt == 1 ? 4 : 16 * 4));\r\nif (ret) return ret;\r\nfor (idx = 0; idx < chunkCnt; idx++) {\r\ndata[idx] = PVR2_COMPOSE_LE(hdw->cmd_buffer,idx*4);\r\n}\r\ndata += chunkCnt;\r\ndlen -= chunkCnt;\r\noffs += chunkCnt;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_encoder_cmd(void *ctxt,\r\nu32 cmd,\r\nint arg_cnt_send,\r\nint arg_cnt_recv,\r\nu32 *argp)\r\n{\r\nunsigned int poll_count;\r\nunsigned int try_count = 0;\r\nint retry_flag;\r\nint ret = 0;\r\nunsigned int idx;\r\nu32 wrData[16];\r\nu32 rdData[16];\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)ctxt;\r\nif (arg_cnt_send > (ARRAY_SIZE(wrData) - 4)) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Failed to write cx23416 command - too many input arguments (was given %u limit %lu)",\r\narg_cnt_send, (long unsigned) ARRAY_SIZE(wrData) - 4);\r\nreturn -EINVAL;\r\n}\r\nif (arg_cnt_recv > (ARRAY_SIZE(rdData) - 4)) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Failed to write cx23416 command - too many return arguments (was given %u limit %lu)",\r\narg_cnt_recv, (long unsigned) ARRAY_SIZE(rdData) - 4);\r\nreturn -EINVAL;\r\n}\r\nLOCK_TAKE(hdw->ctl_lock); do {\r\nif (!hdw->state_encoder_ok) {\r\nret = -EIO;\r\nbreak;\r\n}\r\nretry_flag = 0;\r\ntry_count++;\r\nret = 0;\r\nwrData[0] = 0;\r\nwrData[1] = cmd;\r\nwrData[2] = 0;\r\nwrData[3] = 0x00060000;\r\nfor (idx = 0; idx < arg_cnt_send; idx++) {\r\nwrData[idx+4] = argp[idx];\r\n}\r\nfor (; idx < ARRAY_SIZE(wrData) - 4; idx++) {\r\nwrData[idx+4] = 0;\r\n}\r\nret = pvr2_encoder_write_words(hdw,MBOX_BASE,wrData,idx);\r\nif (ret) break;\r\nwrData[0] = IVTV_MBOX_DRIVER_DONE|IVTV_MBOX_DRIVER_BUSY;\r\nret = pvr2_encoder_write_words(hdw,MBOX_BASE,wrData,1);\r\nif (ret) break;\r\npoll_count = 0;\r\nwhile (1) {\r\npoll_count++;\r\nret = pvr2_encoder_read_words(hdw,MBOX_BASE,rdData,\r\narg_cnt_recv+4);\r\nif (ret) {\r\nbreak;\r\n}\r\nif (rdData[0] & IVTV_MBOX_FIRMWARE_DONE) {\r\nbreak;\r\n}\r\nif (rdData[0] && (poll_count < 1000)) continue;\r\nif (!rdData[0]) {\r\nretry_flag = !0;\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Encoder timed out waiting for us; arranging to retry");\r\n} else {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"***WARNING*** device's encoder appears to be stuck (status=0x%08x)",\r\nrdData[0]);\r\n}\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Encoder command: 0x%02x",cmd);\r\nfor (idx = 4; idx < arg_cnt_send; idx++) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Encoder arg%d: 0x%08x",\r\nidx-3,wrData[idx]);\r\n}\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nif (retry_flag) {\r\nif (try_count < 20) continue;\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Too many retries...");\r\nret = -EBUSY;\r\n}\r\nif (ret) {\r\ndel_timer_sync(&hdw->encoder_run_timer);\r\nhdw->state_encoder_ok = 0;\r\npvr2_trace(PVR2_TRACE_STBITS,\r\n"State bit %s <-- %s",\r\n"state_encoder_ok",\r\n(hdw->state_encoder_ok ? "true" : "false"));\r\nif (hdw->state_encoder_runok) {\r\nhdw->state_encoder_runok = 0;\r\npvr2_trace(PVR2_TRACE_STBITS,\r\n"State bit %s <-- %s",\r\n"state_encoder_runok",\r\n(hdw->state_encoder_runok ?\r\n"true" : "false"));\r\n}\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Giving up on command. This is normally recovered via a firmware reload and re-initialization; concern is only warranted if this happens repeatedly and rapidly.");\r\nbreak;\r\n}\r\nwrData[0] = 0x7;\r\nfor (idx = 0; idx < arg_cnt_recv; idx++) {\r\nargp[idx] = rdData[idx+4];\r\n}\r\nwrData[0] = 0x0;\r\nret = pvr2_encoder_write_words(hdw,MBOX_BASE,wrData,1);\r\nif (ret) break;\r\n} while(0); LOCK_GIVE(hdw->ctl_lock);\r\nreturn ret;\r\n}\r\nstatic int pvr2_encoder_vcmd(struct pvr2_hdw *hdw, int cmd,\r\nint args, ...)\r\n{\r\nva_list vl;\r\nunsigned int idx;\r\nu32 data[12];\r\nif (args > ARRAY_SIZE(data)) {\r\npvr2_trace(\r\nPVR2_TRACE_ERROR_LEGS,\r\n"Failed to write cx23416 command - too many arguments (was given %u limit %lu)",\r\nargs, (long unsigned) ARRAY_SIZE(data));\r\nreturn -EINVAL;\r\n}\r\nva_start(vl, args);\r\nfor (idx = 0; idx < args; idx++) {\r\ndata[idx] = va_arg(vl, u32);\r\n}\r\nva_end(vl);\r\nreturn pvr2_encoder_cmd(hdw,cmd,args,0,data);\r\n}\r\nstatic int pvr2_encoder_prep_config(struct pvr2_hdw *hdw)\r\n{\r\nint ret = 0;\r\nint encMisc3Arg = 0;\r\n#if 0\r\nLOCK_TAKE(hdw->ctl_lock); do {\r\nu32 dat[1];\r\ndat[0] = 0x80000640;\r\npvr2_encoder_write_words(hdw,0x01fe,dat,1);\r\npvr2_encoder_write_words(hdw,0x023e,dat,1);\r\n} while(0); LOCK_GIVE(hdw->ctl_lock);\r\n#endif\r\n#if 0\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 5,0,0,0);\r\n#endif\r\nif (hdw->hdw_desc->flag_has_cx25840) {\r\nencMisc3Arg = 1;\r\n} else {\r\nencMisc3Arg = 0;\r\n}\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 3,\r\nencMisc3Arg,0,0);\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 8,0,0,0);\r\n#if 0\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 4,1,0,0);\r\n#endif\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4, 0,3,0,0);\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC,4,15,0,0,0);\r\nret |= pvr2_encoder_vcmd(hdw, CX2341X_ENC_MISC, 2, 4, 1);\r\nreturn ret;\r\n}\r\nint pvr2_encoder_adjust(struct pvr2_hdw *hdw)\r\n{\r\nint ret;\r\nret = cx2341x_update(hdw,pvr2_encoder_cmd,\r\n(hdw->enc_cur_valid ? &hdw->enc_cur_state : NULL),\r\n&hdw->enc_ctl_state);\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Error from cx2341x module code=%d",ret);\r\n} else {\r\nhdw->enc_cur_state = hdw->enc_ctl_state;\r\nhdw->enc_cur_valid = !0;\r\n}\r\nreturn ret;\r\n}\r\nint pvr2_encoder_configure(struct pvr2_hdw *hdw)\r\n{\r\nint ret;\r\nint val;\r\npvr2_trace(PVR2_TRACE_ENCODER, "pvr2_encoder_configure (cx2341x module)");\r\nhdw->enc_ctl_state.port = CX2341X_PORT_STREAMING;\r\nhdw->enc_ctl_state.width = hdw->res_hor_val;\r\nhdw->enc_ctl_state.height = hdw->res_ver_val;\r\nhdw->enc_ctl_state.is_50hz = ((hdw->std_mask_cur & V4L2_STD_525_60) ?\r\n0 : 1);\r\nret = 0;\r\nret |= pvr2_encoder_prep_config(hdw);\r\nval = 0xf0;\r\nif (hdw->hdw_desc->flag_has_cx25840) {\r\nval = 0x140;\r\n}\r\nif (!ret) ret = pvr2_encoder_vcmd(\r\nhdw,CX2341X_ENC_SET_NUM_VSYNC_LINES, 2,\r\nval, val);\r\nif (!ret) ret = pvr2_encoder_vcmd(\r\nhdw,CX2341X_ENC_SET_EVENT_NOTIFICATION, 4,\r\n0, 0, 0x10000000, 0xffffffff);\r\nif (!ret) ret = pvr2_encoder_vcmd(\r\nhdw,CX2341X_ENC_SET_VBI_LINE, 5,\r\n0xffffffff,0,0,0,0);\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failed to configure cx23416");\r\nreturn ret;\r\n}\r\nret = pvr2_encoder_adjust(hdw);\r\nif (ret) return ret;\r\nret = pvr2_encoder_vcmd(\r\nhdw, CX2341X_ENC_INITIALIZE_INPUT, 0);\r\nif (ret) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Failed to initialize cx23416 video input");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint pvr2_encoder_start(struct pvr2_hdw *hdw)\r\n{\r\nint status;\r\npvr2_write_register(hdw, 0x0048, 0xbfffffff);\r\npvr2_encoder_vcmd(hdw,CX2341X_ENC_MUTE_VIDEO,1,\r\nhdw->input_val == PVR2_CVAL_INPUT_RADIO ? 1 : 0);\r\nswitch (hdw->active_stream_type) {\r\ncase pvr2_config_vbi:\r\nstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_START_CAPTURE,2,\r\n0x01,0x14);\r\nbreak;\r\ncase pvr2_config_mpeg:\r\nstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_START_CAPTURE,2,\r\n0,0x13);\r\nbreak;\r\ndefault:\r\nstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_START_CAPTURE,2,\r\n0,0x13);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nint pvr2_encoder_stop(struct pvr2_hdw *hdw)\r\n{\r\nint status;\r\npvr2_write_register(hdw, 0x0048, 0xffffffff);\r\nswitch (hdw->active_stream_type) {\r\ncase pvr2_config_vbi:\r\nstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_STOP_CAPTURE,3,\r\n0x01,0x01,0x14);\r\nbreak;\r\ncase pvr2_config_mpeg:\r\nstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_STOP_CAPTURE,3,\r\n0x01,0,0x13);\r\nbreak;\r\ndefault:\r\nstatus = pvr2_encoder_vcmd(hdw,CX2341X_ENC_STOP_CAPTURE,3,\r\n0x01,0,0x13);\r\nbreak;\r\n}\r\nreturn status;\r\n}
