struct snd_seq_fifo *snd_seq_fifo_new(int poolsize)\r\n{\r\nstruct snd_seq_fifo *f;\r\nf = kzalloc(sizeof(*f), GFP_KERNEL);\r\nif (!f)\r\nreturn NULL;\r\nf->pool = snd_seq_pool_new(poolsize);\r\nif (f->pool == NULL) {\r\nkfree(f);\r\nreturn NULL;\r\n}\r\nif (snd_seq_pool_init(f->pool) < 0) {\r\nsnd_seq_pool_delete(&f->pool);\r\nkfree(f);\r\nreturn NULL;\r\n}\r\nspin_lock_init(&f->lock);\r\nsnd_use_lock_init(&f->use_lock);\r\ninit_waitqueue_head(&f->input_sleep);\r\natomic_set(&f->overflow, 0);\r\nf->head = NULL;\r\nf->tail = NULL;\r\nf->cells = 0;\r\nreturn f;\r\n}\r\nvoid snd_seq_fifo_delete(struct snd_seq_fifo **fifo)\r\n{\r\nstruct snd_seq_fifo *f;\r\nif (snd_BUG_ON(!fifo))\r\nreturn;\r\nf = *fifo;\r\nif (snd_BUG_ON(!f))\r\nreturn;\r\n*fifo = NULL;\r\nif (f->pool)\r\nsnd_seq_pool_mark_closing(f->pool);\r\nsnd_seq_fifo_clear(f);\r\nif (waitqueue_active(&f->input_sleep))\r\nwake_up(&f->input_sleep);\r\nif (f->pool) {\r\nsnd_seq_pool_done(f->pool);\r\nsnd_seq_pool_delete(&f->pool);\r\n}\r\nkfree(f);\r\n}\r\nvoid snd_seq_fifo_clear(struct snd_seq_fifo *f)\r\n{\r\nstruct snd_seq_event_cell *cell;\r\nunsigned long flags;\r\natomic_set(&f->overflow, 0);\r\nsnd_use_lock_sync(&f->use_lock);\r\nspin_lock_irqsave(&f->lock, flags);\r\nwhile ((cell = fifo_cell_out(f)) != NULL) {\r\nsnd_seq_cell_free(cell);\r\n}\r\nspin_unlock_irqrestore(&f->lock, flags);\r\n}\r\nint snd_seq_fifo_event_in(struct snd_seq_fifo *f,\r\nstruct snd_seq_event *event)\r\n{\r\nstruct snd_seq_event_cell *cell;\r\nunsigned long flags;\r\nint err;\r\nif (snd_BUG_ON(!f))\r\nreturn -EINVAL;\r\nsnd_use_lock_use(&f->use_lock);\r\nerr = snd_seq_event_dup(f->pool, event, &cell, 1, NULL);\r\nif (err < 0) {\r\nif ((err == -ENOMEM) || (err == -EAGAIN))\r\natomic_inc(&f->overflow);\r\nsnd_use_lock_free(&f->use_lock);\r\nreturn err;\r\n}\r\nspin_lock_irqsave(&f->lock, flags);\r\nif (f->tail != NULL)\r\nf->tail->next = cell;\r\nf->tail = cell;\r\nif (f->head == NULL)\r\nf->head = cell;\r\ncell->next = NULL;\r\nf->cells++;\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nif (waitqueue_active(&f->input_sleep))\r\nwake_up(&f->input_sleep);\r\nsnd_use_lock_free(&f->use_lock);\r\nreturn 0;\r\n}\r\nstatic struct snd_seq_event_cell *fifo_cell_out(struct snd_seq_fifo *f)\r\n{\r\nstruct snd_seq_event_cell *cell;\r\nif ((cell = f->head) != NULL) {\r\nf->head = cell->next;\r\nif (f->tail == cell)\r\nf->tail = NULL;\r\ncell->next = NULL;\r\nf->cells--;\r\n}\r\nreturn cell;\r\n}\r\nint snd_seq_fifo_cell_out(struct snd_seq_fifo *f,\r\nstruct snd_seq_event_cell **cellp, int nonblock)\r\n{\r\nstruct snd_seq_event_cell *cell;\r\nunsigned long flags;\r\nwait_queue_t wait;\r\nif (snd_BUG_ON(!f))\r\nreturn -EINVAL;\r\n*cellp = NULL;\r\ninit_waitqueue_entry(&wait, current);\r\nspin_lock_irqsave(&f->lock, flags);\r\nwhile ((cell = fifo_cell_out(f)) == NULL) {\r\nif (nonblock) {\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nreturn -EAGAIN;\r\n}\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nadd_wait_queue(&f->input_sleep, &wait);\r\nspin_unlock_irq(&f->lock);\r\nschedule();\r\nspin_lock_irq(&f->lock);\r\nremove_wait_queue(&f->input_sleep, &wait);\r\nif (signal_pending(current)) {\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nspin_unlock_irqrestore(&f->lock, flags);\r\n*cellp = cell;\r\nreturn 0;\r\n}\r\nvoid snd_seq_fifo_cell_putback(struct snd_seq_fifo *f,\r\nstruct snd_seq_event_cell *cell)\r\n{\r\nunsigned long flags;\r\nif (cell) {\r\nspin_lock_irqsave(&f->lock, flags);\r\ncell->next = f->head;\r\nf->head = cell;\r\nif (!f->tail)\r\nf->tail = cell;\r\nf->cells++;\r\nspin_unlock_irqrestore(&f->lock, flags);\r\n}\r\n}\r\nint snd_seq_fifo_poll_wait(struct snd_seq_fifo *f, struct file *file,\r\npoll_table *wait)\r\n{\r\npoll_wait(file, &f->input_sleep, wait);\r\nreturn (f->cells > 0);\r\n}\r\nint snd_seq_fifo_resize(struct snd_seq_fifo *f, int poolsize)\r\n{\r\nunsigned long flags;\r\nstruct snd_seq_pool *newpool, *oldpool;\r\nstruct snd_seq_event_cell *cell, *next, *oldhead;\r\nif (snd_BUG_ON(!f || !f->pool))\r\nreturn -EINVAL;\r\nnewpool = snd_seq_pool_new(poolsize);\r\nif (newpool == NULL)\r\nreturn -ENOMEM;\r\nif (snd_seq_pool_init(newpool) < 0) {\r\nsnd_seq_pool_delete(&newpool);\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_irqsave(&f->lock, flags);\r\noldpool = f->pool;\r\noldhead = f->head;\r\nf->pool = newpool;\r\nf->head = NULL;\r\nf->tail = NULL;\r\nf->cells = 0;\r\nspin_unlock_irqrestore(&f->lock, flags);\r\nsnd_seq_pool_mark_closing(oldpool);\r\nsnd_use_lock_sync(&f->use_lock);\r\nfor (cell = oldhead; cell; cell = next) {\r\nnext = cell->next;\r\nsnd_seq_cell_free(cell);\r\n}\r\nsnd_seq_pool_delete(&oldpool);\r\nreturn 0;\r\n}
