static inline void init_cpu_mask_set(struct cpu_mask_set *set)\r\n{\r\ncpumask_clear(&set->mask);\r\ncpumask_clear(&set->used);\r\nset->gen = 0;\r\n}\r\nvoid init_real_cpu_mask(void)\r\n{\r\nint possible, curr_cpu, i, ht;\r\ncpumask_clear(&node_affinity.real_cpu_mask);\r\ncpumask_copy(&node_affinity.real_cpu_mask, cpu_online_mask);\r\npossible = cpumask_weight(&node_affinity.real_cpu_mask);\r\nht = cpumask_weight(topology_sibling_cpumask(\r\ncpumask_first(&node_affinity.real_cpu_mask)));\r\ncurr_cpu = cpumask_first(&node_affinity.real_cpu_mask);\r\nfor (i = 0; i < possible / ht; i++)\r\ncurr_cpu = cpumask_next(curr_cpu, &node_affinity.real_cpu_mask);\r\nfor (; i < possible; i++) {\r\ncpumask_clear_cpu(curr_cpu, &node_affinity.real_cpu_mask);\r\ncurr_cpu = cpumask_next(curr_cpu, &node_affinity.real_cpu_mask);\r\n}\r\n}\r\nint node_affinity_init(void)\r\n{\r\nint node;\r\nstruct pci_dev *dev = NULL;\r\nconst struct pci_device_id *ids = hfi1_pci_tbl;\r\ncpumask_clear(&node_affinity.proc.used);\r\ncpumask_copy(&node_affinity.proc.mask, cpu_online_mask);\r\nnode_affinity.proc.gen = 0;\r\nnode_affinity.num_core_siblings =\r\ncpumask_weight(topology_sibling_cpumask(\r\ncpumask_first(&node_affinity.proc.mask)\r\n));\r\nnode_affinity.num_possible_nodes = num_possible_nodes();\r\nnode_affinity.num_online_nodes = num_online_nodes();\r\nnode_affinity.num_online_cpus = num_online_cpus();\r\ninit_real_cpu_mask();\r\nhfi1_per_node_cntr = kcalloc(node_affinity.num_possible_nodes,\r\nsizeof(*hfi1_per_node_cntr), GFP_KERNEL);\r\nif (!hfi1_per_node_cntr)\r\nreturn -ENOMEM;\r\nwhile (ids->vendor) {\r\ndev = NULL;\r\nwhile ((dev = pci_get_device(ids->vendor, ids->device, dev))) {\r\nnode = pcibus_to_node(dev->bus);\r\nif (node < 0)\r\nnode = numa_node_id();\r\nhfi1_per_node_cntr[node]++;\r\n}\r\nids++;\r\n}\r\nreturn 0;\r\n}\r\nvoid node_affinity_destroy(void)\r\n{\r\nstruct list_head *pos, *q;\r\nstruct hfi1_affinity_node *entry;\r\nmutex_lock(&node_affinity.lock);\r\nlist_for_each_safe(pos, q, &node_affinity.list) {\r\nentry = list_entry(pos, struct hfi1_affinity_node,\r\nlist);\r\nlist_del(pos);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&node_affinity.lock);\r\nkfree(hfi1_per_node_cntr);\r\n}\r\nstatic struct hfi1_affinity_node *node_affinity_allocate(int node)\r\n{\r\nstruct hfi1_affinity_node *entry;\r\nentry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn NULL;\r\nentry->node = node;\r\nINIT_LIST_HEAD(&entry->list);\r\nreturn entry;\r\n}\r\nstatic void node_affinity_add_tail(struct hfi1_affinity_node *entry)\r\n{\r\nlist_add_tail(&entry->list, &node_affinity.list);\r\n}\r\nstatic struct hfi1_affinity_node *node_affinity_lookup(int node)\r\n{\r\nstruct list_head *pos;\r\nstruct hfi1_affinity_node *entry;\r\nlist_for_each(pos, &node_affinity.list) {\r\nentry = list_entry(pos, struct hfi1_affinity_node, list);\r\nif (entry->node == node)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nint hfi1_dev_affinity_init(struct hfi1_devdata *dd)\r\n{\r\nint node = pcibus_to_node(dd->pcidev->bus);\r\nstruct hfi1_affinity_node *entry;\r\nconst struct cpumask *local_mask;\r\nint curr_cpu, possible, i;\r\nif (node < 0)\r\nnode = numa_node_id();\r\ndd->node = node;\r\nlocal_mask = cpumask_of_node(dd->node);\r\nif (cpumask_first(local_mask) >= nr_cpu_ids)\r\nlocal_mask = topology_core_cpumask(0);\r\nmutex_lock(&node_affinity.lock);\r\nentry = node_affinity_lookup(dd->node);\r\nif (!entry) {\r\nentry = node_affinity_allocate(node);\r\nif (!entry) {\r\ndd_dev_err(dd,\r\n"Unable to allocate global affinity node\n");\r\nmutex_unlock(&node_affinity.lock);\r\nreturn -ENOMEM;\r\n}\r\ninit_cpu_mask_set(&entry->def_intr);\r\ninit_cpu_mask_set(&entry->rcv_intr);\r\ncpumask_clear(&entry->general_intr_mask);\r\ncpumask_and(&entry->def_intr.mask, &node_affinity.real_cpu_mask,\r\nlocal_mask);\r\npossible = cpumask_weight(&entry->def_intr.mask);\r\ncurr_cpu = cpumask_first(&entry->def_intr.mask);\r\nif (possible == 1) {\r\ncpumask_set_cpu(curr_cpu, &entry->rcv_intr.mask);\r\ncpumask_set_cpu(curr_cpu, &entry->general_intr_mask);\r\n} else {\r\ncpumask_clear_cpu(curr_cpu, &entry->def_intr.mask);\r\ncpumask_set_cpu(curr_cpu, &entry->general_intr_mask);\r\ncurr_cpu = cpumask_next(curr_cpu,\r\n&entry->def_intr.mask);\r\nfor (i = 0;\r\ni < (dd->n_krcv_queues - 1) *\r\nhfi1_per_node_cntr[dd->node];\r\ni++) {\r\ncpumask_clear_cpu(curr_cpu,\r\n&entry->def_intr.mask);\r\ncpumask_set_cpu(curr_cpu,\r\n&entry->rcv_intr.mask);\r\ncurr_cpu = cpumask_next(curr_cpu,\r\n&entry->def_intr.mask);\r\nif (curr_cpu >= nr_cpu_ids)\r\nbreak;\r\n}\r\nif (cpumask_weight(&entry->def_intr.mask) == 0)\r\ncpumask_copy(&entry->def_intr.mask,\r\n&entry->general_intr_mask);\r\n}\r\nnode_affinity_add_tail(entry);\r\n}\r\nmutex_unlock(&node_affinity.lock);\r\nreturn 0;\r\n}\r\nstatic void hfi1_update_sdma_affinity(struct hfi1_msix_entry *msix, int cpu)\r\n{\r\nstruct sdma_engine *sde = msix->arg;\r\nstruct hfi1_devdata *dd = sde->dd;\r\nstruct hfi1_affinity_node *entry;\r\nstruct cpu_mask_set *set;\r\nint i, old_cpu;\r\nif (cpu > num_online_cpus() || cpu == sde->cpu)\r\nreturn;\r\nmutex_lock(&node_affinity.lock);\r\nentry = node_affinity_lookup(dd->node);\r\nif (!entry)\r\ngoto unlock;\r\nold_cpu = sde->cpu;\r\nsde->cpu = cpu;\r\ncpumask_clear(&msix->mask);\r\ncpumask_set_cpu(cpu, &msix->mask);\r\ndd_dev_dbg(dd, "IRQ vector: %u, type %s engine %u -> cpu: %d\n",\r\nmsix->msix.vector, irq_type_names[msix->type],\r\nsde->this_idx, cpu);\r\nirq_set_affinity_hint(msix->msix.vector, &msix->mask);\r\nset = &entry->def_intr;\r\ncpumask_set_cpu(cpu, &set->mask);\r\ncpumask_set_cpu(cpu, &set->used);\r\nfor (i = 0; i < dd->num_msix_entries; i++) {\r\nstruct hfi1_msix_entry *other_msix;\r\nother_msix = &dd->msix_entries[i];\r\nif (other_msix->type != IRQ_SDMA || other_msix == msix)\r\ncontinue;\r\nif (cpumask_test_cpu(old_cpu, &other_msix->mask))\r\ngoto unlock;\r\n}\r\ncpumask_clear_cpu(old_cpu, &set->mask);\r\ncpumask_clear_cpu(old_cpu, &set->used);\r\nunlock:\r\nmutex_unlock(&node_affinity.lock);\r\n}\r\nstatic void hfi1_irq_notifier_notify(struct irq_affinity_notify *notify,\r\nconst cpumask_t *mask)\r\n{\r\nint cpu = cpumask_first(mask);\r\nstruct hfi1_msix_entry *msix = container_of(notify,\r\nstruct hfi1_msix_entry,\r\nnotify);\r\nhfi1_update_sdma_affinity(msix, cpu);\r\n}\r\nstatic void hfi1_irq_notifier_release(struct kref *ref)\r\n{\r\n}\r\nstatic void hfi1_setup_sdma_notifier(struct hfi1_msix_entry *msix)\r\n{\r\nstruct irq_affinity_notify *notify = &msix->notify;\r\nnotify->irq = msix->msix.vector;\r\nnotify->notify = hfi1_irq_notifier_notify;\r\nnotify->release = hfi1_irq_notifier_release;\r\nif (irq_set_affinity_notifier(notify->irq, notify))\r\npr_err("Failed to register sdma irq affinity notifier for irq %d\n",\r\nnotify->irq);\r\n}\r\nstatic void hfi1_cleanup_sdma_notifier(struct hfi1_msix_entry *msix)\r\n{\r\nstruct irq_affinity_notify *notify = &msix->notify;\r\nif (irq_set_affinity_notifier(notify->irq, NULL))\r\npr_err("Failed to cleanup sdma irq affinity notifier for irq %d\n",\r\nnotify->irq);\r\n}\r\nstatic int get_irq_affinity(struct hfi1_devdata *dd,\r\nstruct hfi1_msix_entry *msix)\r\n{\r\nint ret;\r\ncpumask_var_t diff;\r\nstruct hfi1_affinity_node *entry;\r\nstruct cpu_mask_set *set = NULL;\r\nstruct sdma_engine *sde = NULL;\r\nstruct hfi1_ctxtdata *rcd = NULL;\r\nchar extra[64];\r\nint cpu = -1;\r\nextra[0] = '\0';\r\ncpumask_clear(&msix->mask);\r\nret = zalloc_cpumask_var(&diff, GFP_KERNEL);\r\nif (!ret)\r\nreturn -ENOMEM;\r\nentry = node_affinity_lookup(dd->node);\r\nswitch (msix->type) {\r\ncase IRQ_SDMA:\r\nsde = (struct sdma_engine *)msix->arg;\r\nscnprintf(extra, 64, "engine %u", sde->this_idx);\r\nset = &entry->def_intr;\r\nbreak;\r\ncase IRQ_GENERAL:\r\ncpu = cpumask_first(&entry->general_intr_mask);\r\nbreak;\r\ncase IRQ_RCVCTXT:\r\nrcd = (struct hfi1_ctxtdata *)msix->arg;\r\nif (rcd->ctxt == HFI1_CTRL_CTXT)\r\ncpu = cpumask_first(&entry->general_intr_mask);\r\nelse\r\nset = &entry->rcv_intr;\r\nscnprintf(extra, 64, "ctxt %u", rcd->ctxt);\r\nbreak;\r\ndefault:\r\ndd_dev_err(dd, "Invalid IRQ type %d\n", msix->type);\r\nreturn -EINVAL;\r\n}\r\nif (cpu == -1 && set) {\r\nif (cpumask_equal(&set->mask, &set->used)) {\r\nset->gen++;\r\ncpumask_clear(&set->used);\r\n}\r\ncpumask_andnot(diff, &set->mask, &set->used);\r\ncpu = cpumask_first(diff);\r\ncpumask_set_cpu(cpu, &set->used);\r\n}\r\ncpumask_set_cpu(cpu, &msix->mask);\r\ndd_dev_info(dd, "IRQ vector: %u, type %s %s -> cpu: %d\n",\r\nmsix->msix.vector, irq_type_names[msix->type],\r\nextra, cpu);\r\nirq_set_affinity_hint(msix->msix.vector, &msix->mask);\r\nif (msix->type == IRQ_SDMA) {\r\nsde->cpu = cpu;\r\nhfi1_setup_sdma_notifier(msix);\r\n}\r\nfree_cpumask_var(diff);\r\nreturn 0;\r\n}\r\nint hfi1_get_irq_affinity(struct hfi1_devdata *dd, struct hfi1_msix_entry *msix)\r\n{\r\nint ret;\r\nmutex_lock(&node_affinity.lock);\r\nret = get_irq_affinity(dd, msix);\r\nmutex_unlock(&node_affinity.lock);\r\nreturn ret;\r\n}\r\nvoid hfi1_put_irq_affinity(struct hfi1_devdata *dd,\r\nstruct hfi1_msix_entry *msix)\r\n{\r\nstruct cpu_mask_set *set = NULL;\r\nstruct hfi1_ctxtdata *rcd;\r\nstruct hfi1_affinity_node *entry;\r\nmutex_lock(&node_affinity.lock);\r\nentry = node_affinity_lookup(dd->node);\r\nswitch (msix->type) {\r\ncase IRQ_SDMA:\r\nset = &entry->def_intr;\r\nhfi1_cleanup_sdma_notifier(msix);\r\nbreak;\r\ncase IRQ_GENERAL:\r\nbreak;\r\ncase IRQ_RCVCTXT:\r\nrcd = (struct hfi1_ctxtdata *)msix->arg;\r\nif (rcd->ctxt != HFI1_CTRL_CTXT)\r\nset = &entry->rcv_intr;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&node_affinity.lock);\r\nreturn;\r\n}\r\nif (set) {\r\ncpumask_andnot(&set->used, &set->used, &msix->mask);\r\nif (cpumask_empty(&set->used) && set->gen) {\r\nset->gen--;\r\ncpumask_copy(&set->used, &set->mask);\r\n}\r\n}\r\nirq_set_affinity_hint(msix->msix.vector, NULL);\r\ncpumask_clear(&msix->mask);\r\nmutex_unlock(&node_affinity.lock);\r\n}\r\nstatic void find_hw_thread_mask(uint hw_thread_no, cpumask_var_t hw_thread_mask,\r\nstruct hfi1_affinity_node_list *affinity)\r\n{\r\nint possible, curr_cpu, i;\r\nuint num_cores_per_socket = node_affinity.num_online_cpus /\r\naffinity->num_core_siblings /\r\nnode_affinity.num_online_nodes;\r\ncpumask_copy(hw_thread_mask, &affinity->proc.mask);\r\nif (affinity->num_core_siblings > 0) {\r\npossible = cpumask_weight(hw_thread_mask);\r\ncurr_cpu = cpumask_first(hw_thread_mask);\r\nfor (i = 0;\r\ni < num_cores_per_socket * node_affinity.num_online_nodes;\r\ni++)\r\ncurr_cpu = cpumask_next(curr_cpu, hw_thread_mask);\r\nfor (; i < possible; i++) {\r\ncpumask_clear_cpu(curr_cpu, hw_thread_mask);\r\ncurr_cpu = cpumask_next(curr_cpu, hw_thread_mask);\r\n}\r\ncpumask_shift_left(hw_thread_mask, hw_thread_mask,\r\nnum_cores_per_socket *\r\nnode_affinity.num_online_nodes *\r\nhw_thread_no);\r\n}\r\n}\r\nint hfi1_get_proc_affinity(int node)\r\n{\r\nint cpu = -1, ret, i;\r\nstruct hfi1_affinity_node *entry;\r\ncpumask_var_t diff, hw_thread_mask, available_mask, intrs_mask;\r\nconst struct cpumask *node_mask,\r\n*proc_mask = &current->cpus_allowed;\r\nstruct hfi1_affinity_node_list *affinity = &node_affinity;\r\nstruct cpu_mask_set *set = &affinity->proc;\r\nif (cpumask_weight(proc_mask) == 1) {\r\nhfi1_cdbg(PROC, "PID %u %s affinity set to CPU %*pbl",\r\ncurrent->pid, current->comm,\r\ncpumask_pr_args(proc_mask));\r\ncpu = cpumask_first(proc_mask);\r\ncpumask_set_cpu(cpu, &set->used);\r\ngoto done;\r\n} else if (cpumask_weight(proc_mask) < cpumask_weight(&set->mask)) {\r\nhfi1_cdbg(PROC, "PID %u %s affinity set to CPU set(s) %*pbl",\r\ncurrent->pid, current->comm,\r\ncpumask_pr_args(proc_mask));\r\ngoto done;\r\n}\r\nret = zalloc_cpumask_var(&diff, GFP_KERNEL);\r\nif (!ret)\r\ngoto done;\r\nret = zalloc_cpumask_var(&hw_thread_mask, GFP_KERNEL);\r\nif (!ret)\r\ngoto free_diff;\r\nret = zalloc_cpumask_var(&available_mask, GFP_KERNEL);\r\nif (!ret)\r\ngoto free_hw_thread_mask;\r\nret = zalloc_cpumask_var(&intrs_mask, GFP_KERNEL);\r\nif (!ret)\r\ngoto free_available_mask;\r\nmutex_lock(&affinity->lock);\r\nif (cpumask_equal(&set->mask, &set->used)) {\r\nset->gen++;\r\ncpumask_clear(&set->used);\r\n}\r\nentry = node_affinity_lookup(node);\r\nif (entry) {\r\ncpumask_copy(intrs_mask, (entry->def_intr.gen ?\r\n&entry->def_intr.mask :\r\n&entry->def_intr.used));\r\ncpumask_or(intrs_mask, intrs_mask, (entry->rcv_intr.gen ?\r\n&entry->rcv_intr.mask :\r\n&entry->rcv_intr.used));\r\ncpumask_or(intrs_mask, intrs_mask, &entry->general_intr_mask);\r\n}\r\nhfi1_cdbg(PROC, "CPUs used by interrupts: %*pbl",\r\ncpumask_pr_args(intrs_mask));\r\ncpumask_copy(hw_thread_mask, &set->mask);\r\nif (affinity->num_core_siblings > 0) {\r\nfor (i = 0; i < affinity->num_core_siblings; i++) {\r\nfind_hw_thread_mask(i, hw_thread_mask, affinity);\r\ncpumask_andnot(diff, hw_thread_mask, &set->used);\r\nif (!cpumask_empty(diff))\r\nbreak;\r\n}\r\n}\r\nhfi1_cdbg(PROC, "Same available HW thread on all physical CPUs: %*pbl",\r\ncpumask_pr_args(hw_thread_mask));\r\nnode_mask = cpumask_of_node(node);\r\nhfi1_cdbg(PROC, "Device on NUMA %u, CPUs %*pbl", node,\r\ncpumask_pr_args(node_mask));\r\ncpumask_and(available_mask, hw_thread_mask, node_mask);\r\ncpumask_andnot(available_mask, available_mask, &set->used);\r\nhfi1_cdbg(PROC, "Available CPUs on NUMA %u: %*pbl", node,\r\ncpumask_pr_args(available_mask));\r\ncpumask_andnot(diff, available_mask, intrs_mask);\r\nif (!cpumask_empty(diff))\r\ncpumask_copy(available_mask, diff);\r\nif (cpumask_empty(available_mask)) {\r\ncpumask_andnot(available_mask, hw_thread_mask, &set->used);\r\ncpumask_andnot(available_mask, available_mask, node_mask);\r\nhfi1_cdbg(PROC,\r\n"Preferred NUMA node cores are taken, cores available in other NUMA nodes: %*pbl",\r\ncpumask_pr_args(available_mask));\r\ncpumask_andnot(diff, available_mask, intrs_mask);\r\nif (!cpumask_empty(diff))\r\ncpumask_copy(available_mask, diff);\r\n}\r\nhfi1_cdbg(PROC, "Possible CPUs for process: %*pbl",\r\ncpumask_pr_args(available_mask));\r\ncpu = cpumask_first(available_mask);\r\nif (cpu >= nr_cpu_ids)\r\ncpu = -1;\r\nelse\r\ncpumask_set_cpu(cpu, &set->used);\r\nmutex_unlock(&affinity->lock);\r\nhfi1_cdbg(PROC, "Process assigned to CPU %d", cpu);\r\nfree_cpumask_var(intrs_mask);\r\nfree_available_mask:\r\nfree_cpumask_var(available_mask);\r\nfree_hw_thread_mask:\r\nfree_cpumask_var(hw_thread_mask);\r\nfree_diff:\r\nfree_cpumask_var(diff);\r\ndone:\r\nreturn cpu;\r\n}\r\nvoid hfi1_put_proc_affinity(int cpu)\r\n{\r\nstruct hfi1_affinity_node_list *affinity = &node_affinity;\r\nstruct cpu_mask_set *set = &affinity->proc;\r\nif (cpu < 0)\r\nreturn;\r\nmutex_lock(&affinity->lock);\r\ncpumask_clear_cpu(cpu, &set->used);\r\nhfi1_cdbg(PROC, "Returning CPU %d for future process assignment", cpu);\r\nif (cpumask_empty(&set->used) && set->gen) {\r\nset->gen--;\r\ncpumask_copy(&set->used, &set->mask);\r\n}\r\nmutex_unlock(&affinity->lock);\r\n}
