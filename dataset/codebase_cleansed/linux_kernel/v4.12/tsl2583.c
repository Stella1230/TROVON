static void tsl2583_defaults(struct tsl2583_chip *chip)\r\n{\r\nchip->als_settings.als_time = 100;\r\nchip->als_settings.als_gain = 0;\r\nchip->als_settings.als_gain_trim = 1000;\r\nchip->als_settings.als_cal_target = 130;\r\nmemcpy(chip->als_settings.als_device_lux, tsl2583_default_lux,\r\nsizeof(tsl2583_default_lux));\r\n}\r\nstatic int tsl2583_get_lux(struct iio_dev *indio_dev)\r\n{\r\nu16 ch0, ch1;\r\nu32 lux;\r\nu64 lux64;\r\nu32 ratio;\r\nu8 buf[5];\r\nstruct tsl2583_lux *p;\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint i, ret;\r\nret = i2c_smbus_read_byte_data(chip->client, TSL2583_CMD_REG);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "%s: failed to read CMD_REG register\n",\r\n__func__);\r\ngoto done;\r\n}\r\nif (!(ret & TSL2583_STA_ADC_INTR)) {\r\ndev_err(&chip->client->dev, "%s: data not valid; returning last value\n",\r\n__func__);\r\nret = chip->als_cur_info.lux;\r\ngoto done;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nint reg = TSL2583_CMD_REG | (TSL2583_ALS_CHAN0LO + i);\r\nret = i2c_smbus_read_byte_data(chip->client, reg);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "%s: failed to read register %x\n",\r\n__func__, reg);\r\ngoto done;\r\n}\r\nbuf[i] = ret;\r\n}\r\nret = i2c_smbus_write_byte(chip->client,\r\n(TSL2583_CMD_REG | TSL2583_CMD_SPL_FN |\r\nTSL2583_CMD_ALS_INT_CLR));\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "%s: failed to clear the interrupt bit\n",\r\n__func__);\r\ngoto done;\r\n}\r\nch0 = le16_to_cpup((const __le16 *)&buf[0]);\r\nch1 = le16_to_cpup((const __le16 *)&buf[2]);\r\nchip->als_cur_info.als_ch0 = ch0;\r\nchip->als_cur_info.als_ch1 = ch1;\r\nif ((ch0 >= chip->als_saturation) || (ch1 >= chip->als_saturation))\r\ngoto return_max;\r\nif (!ch0) {\r\nret = 0;\r\nchip->als_cur_info.lux = 0;\r\ngoto done;\r\n}\r\nratio = (ch1 << 15) / ch0;\r\nfor (p = (struct tsl2583_lux *)chip->als_settings.als_device_lux;\r\np->ratio != 0 && p->ratio < ratio; p++)\r\n;\r\nif (p->ratio == 0) {\r\nlux = 0;\r\n} else {\r\nu32 ch0lux, ch1lux;\r\nch0lux = ((ch0 * p->ch0) +\r\n(gainadj[chip->als_settings.als_gain].ch0 >> 1))\r\n/ gainadj[chip->als_settings.als_gain].ch0;\r\nch1lux = ((ch1 * p->ch1) +\r\n(gainadj[chip->als_settings.als_gain].ch1 >> 1))\r\n/ gainadj[chip->als_settings.als_gain].ch1;\r\nif (ch1lux > ch0lux) {\r\ndev_dbg(&chip->client->dev, "%s: No Data - Returning 0\n",\r\n__func__);\r\nret = 0;\r\nchip->als_cur_info.lux = 0;\r\ngoto done;\r\n}\r\nlux = ch0lux - ch1lux;\r\n}\r\nif (chip->als_time_scale == 0)\r\nlux = 0;\r\nelse\r\nlux = (lux + (chip->als_time_scale >> 1)) /\r\nchip->als_time_scale;\r\nlux64 = lux;\r\nlux64 = lux64 * chip->als_settings.als_gain_trim;\r\nlux64 >>= 13;\r\nlux = lux64;\r\nlux = (lux + 500) / 1000;\r\nif (lux > TSL2583_LUX_CALC_OVER_FLOW) {\r\nreturn_max:\r\nlux = TSL2583_LUX_CALC_OVER_FLOW;\r\n}\r\nchip->als_cur_info.lux = lux;\r\nret = lux;\r\ndone:\r\nreturn ret;\r\n}\r\nstatic int tsl2583_als_calibrate(struct iio_dev *indio_dev)\r\n{\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nunsigned int gain_trim_val;\r\nint ret;\r\nint lux_val;\r\nret = i2c_smbus_read_byte_data(chip->client,\r\nTSL2583_CMD_REG | TSL2583_CNTRL);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed to read from the CNTRL register\n",\r\n__func__);\r\nreturn ret;\r\n}\r\nif ((ret & (TSL2583_CNTL_ADC_ENBL | TSL2583_CNTL_PWR_ON))\r\n!= (TSL2583_CNTL_ADC_ENBL | TSL2583_CNTL_PWR_ON)) {\r\ndev_err(&chip->client->dev,\r\n"%s: Device is not powered on and/or ADC is not enabled\n",\r\n__func__);\r\nreturn -EINVAL;\r\n} else if ((ret & TSL2583_STA_ADC_VALID) != TSL2583_STA_ADC_VALID) {\r\ndev_err(&chip->client->dev,\r\n"%s: The two ADC channels have not completed an integration cycle\n",\r\n__func__);\r\nreturn -ENODATA;\r\n}\r\nlux_val = tsl2583_get_lux(indio_dev);\r\nif (lux_val < 0) {\r\ndev_err(&chip->client->dev, "%s: failed to get lux\n",\r\n__func__);\r\nreturn lux_val;\r\n}\r\ngain_trim_val = (unsigned int)(((chip->als_settings.als_cal_target)\r\n* chip->als_settings.als_gain_trim) / lux_val);\r\nif ((gain_trim_val < 250) || (gain_trim_val > 4000)) {\r\ndev_err(&chip->client->dev,\r\n"%s: trim_val of %d is not within the range [250, 4000]\n",\r\n__func__, gain_trim_val);\r\nreturn -ENODATA;\r\n}\r\nchip->als_settings.als_gain_trim = (int)gain_trim_val;\r\nreturn 0;\r\n}\r\nstatic int tsl2583_set_als_time(struct tsl2583_chip *chip)\r\n{\r\nint als_count, als_time, ret;\r\nu8 val;\r\nals_count = (chip->als_settings.als_time * 100 + 135) / 270;\r\nif (!als_count)\r\nals_count = 1;\r\nals_time = (als_count * 27 + 5) / 10;\r\nval = 256 - als_count;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2583_CMD_REG | TSL2583_ALS_TIME,\r\nval);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev, "%s: failed to set the als time to %d\n",\r\n__func__, val);\r\nreturn ret;\r\n}\r\nchip->als_saturation = als_count * 922;\r\nchip->als_time_scale = (als_time + 25) / 50;\r\nreturn ret;\r\n}\r\nstatic int tsl2583_set_als_gain(struct tsl2583_chip *chip)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2583_CMD_REG | TSL2583_GAIN,\r\nchip->als_settings.als_gain);\r\nif (ret < 0)\r\ndev_err(&chip->client->dev,\r\n"%s: failed to set the gain to %d\n", __func__,\r\nchip->als_settings.als_gain);\r\nreturn ret;\r\n}\r\nstatic int tsl2583_set_power_state(struct tsl2583_chip *chip, u8 state)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2583_CMD_REG | TSL2583_CNTRL, state);\r\nif (ret < 0)\r\ndev_err(&chip->client->dev,\r\n"%s: failed to set the power state to %d\n", __func__,\r\nstate);\r\nreturn ret;\r\n}\r\nstatic int tsl2583_chip_init_and_power_on(struct iio_dev *indio_dev)\r\n{\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nret = tsl2583_set_power_state(chip, TSL2583_CNTL_PWR_ON);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(chip->client,\r\nTSL2583_CMD_REG | TSL2583_INTERRUPT,\r\nTSL2583_INTERRUPT_DISABLED);\r\nif (ret < 0) {\r\ndev_err(&chip->client->dev,\r\n"%s: failed to disable interrupts\n", __func__);\r\nreturn ret;\r\n}\r\nret = tsl2583_set_als_time(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nret = tsl2583_set_als_gain(chip);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(3000, 3500);\r\nret = tsl2583_set_power_state(chip, TSL2583_CNTL_PWR_ON |\r\nTSL2583_CNTL_ADC_ENBL);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->suspended = false;\r\nreturn ret;\r\n}\r\nstatic ssize_t in_illuminance_input_target_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&chip->als_mutex);\r\nret = sprintf(buf, "%d\n", chip->als_settings.als_cal_target);\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t in_illuminance_input_target_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint value;\r\nif (kstrtoint(buf, 0, &value) || !value)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->als_mutex);\r\nchip->als_settings.als_cal_target = value;\r\nmutex_unlock(&chip->als_mutex);\r\nreturn len;\r\n}\r\nstatic ssize_t in_illuminance_calibrate_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint value, ret;\r\nif (kstrtoint(buf, 0, &value) || value != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&chip->als_mutex);\r\nif (chip->suspended) {\r\nret = -EBUSY;\r\ngoto done;\r\n}\r\nret = tsl2583_als_calibrate(indio_dev);\r\nif (ret < 0)\r\ngoto done;\r\nret = len;\r\ndone:\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic ssize_t in_illuminance_lux_table_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nunsigned int i;\r\nint offset = 0;\r\nfor (i = 0; i < ARRAY_SIZE(chip->als_settings.als_device_lux); i++) {\r\noffset += sprintf(buf + offset, "%u,%u,%u,",\r\nchip->als_settings.als_device_lux[i].ratio,\r\nchip->als_settings.als_device_lux[i].ch0,\r\nchip->als_settings.als_device_lux[i].ch1);\r\nif (chip->als_settings.als_device_lux[i].ratio == 0) {\r\noffset--;\r\nbreak;\r\n}\r\n}\r\noffset += sprintf(buf + offset, "\n");\r\nreturn offset;\r\n}\r\nstatic ssize_t in_illuminance_lux_table_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t len)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nconst unsigned int max_ints = TSL2583_MAX_LUX_TABLE_ENTRIES * 3;\r\nint value[TSL2583_MAX_LUX_TABLE_ENTRIES * 3 + 1];\r\nint ret = -EINVAL;\r\nunsigned int n;\r\nmutex_lock(&chip->als_mutex);\r\nget_options(buf, ARRAY_SIZE(value), value);\r\nn = value[0];\r\nif ((n % 3) || n < 6 || n > max_ints) {\r\ndev_err(dev,\r\n"%s: The number of entries in the lux table must be a multiple of 3 and within the range [6, %d]\n",\r\n__func__, max_ints);\r\ngoto done;\r\n}\r\nif ((value[n - 2] | value[n - 1] | value[n]) != 0) {\r\ndev_err(dev, "%s: The last 3 entries in the lux table must be zeros.\n",\r\n__func__);\r\ngoto done;\r\n}\r\nmemcpy(chip->als_settings.als_device_lux, &value[1],\r\nvalue[0] * sizeof(value[1]));\r\nret = len;\r\ndone:\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int tsl2583_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret = -EINVAL;\r\nmutex_lock(&chip->als_mutex);\r\nif (chip->suspended) {\r\nret = -EBUSY;\r\ngoto read_done;\r\n}\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type == IIO_LIGHT) {\r\nret = tsl2583_get_lux(indio_dev);\r\nif (ret < 0)\r\ngoto read_done;\r\nif (chan->channel2 == IIO_MOD_LIGHT_BOTH)\r\n*val = chip->als_cur_info.als_ch0;\r\nelse\r\n*val = chip->als_cur_info.als_ch1;\r\nret = IIO_VAL_INT;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nif (chan->type == IIO_LIGHT) {\r\nret = tsl2583_get_lux(indio_dev);\r\nif (ret < 0)\r\ngoto read_done;\r\n*val = ret;\r\nret = IIO_VAL_INT;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = chip->als_settings.als_gain_trim;\r\nret = IIO_VAL_INT;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = gainadj[chip->als_settings.als_gain].mean;\r\nret = IIO_VAL_INT;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = 0;\r\n*val2 = chip->als_settings.als_time;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nread_done:\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int tsl2583_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret = -EINVAL;\r\nmutex_lock(&chip->als_mutex);\r\nif (chip->suspended) {\r\nret = -EBUSY;\r\ngoto write_done;\r\n}\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBBIAS:\r\nif (chan->type == IIO_LIGHT) {\r\nchip->als_settings.als_gain_trim = val;\r\nret = 0;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_LIGHT) {\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gainadj); i++) {\r\nif (gainadj[i].mean == val) {\r\nchip->als_settings.als_gain = i;\r\nret = tsl2583_set_als_gain(chip);\r\nbreak;\r\n}\r\n}\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (chan->type == IIO_LIGHT && !val && val2 >= 50 &&\r\nval2 <= 650 && !(val2 % 50)) {\r\nchip->als_settings.als_time = val2;\r\nret = tsl2583_set_als_time(chip);\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwrite_done:\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int tsl2583_probe(struct i2c_client *clientp,\r\nconst struct i2c_device_id *idp)\r\n{\r\nint ret;\r\nstruct tsl2583_chip *chip;\r\nstruct iio_dev *indio_dev;\r\nif (!i2c_check_functionality(clientp->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_err(&clientp->dev, "%s: i2c smbus byte data functionality is unsupported\n",\r\n__func__);\r\nreturn -EOPNOTSUPP;\r\n}\r\nindio_dev = devm_iio_device_alloc(&clientp->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\nchip->client = clientp;\r\ni2c_set_clientdata(clientp, indio_dev);\r\nmutex_init(&chip->als_mutex);\r\nchip->suspended = true;\r\nret = i2c_smbus_read_byte_data(clientp,\r\nTSL2583_CMD_REG | TSL2583_CHIPID);\r\nif (ret < 0) {\r\ndev_err(&clientp->dev,\r\n"%s: failed to read the chip ID register\n", __func__);\r\nreturn ret;\r\n}\r\nif ((ret & TSL2583_CHIP_ID_MASK) != TSL2583_CHIP_ID) {\r\ndev_err(&clientp->dev, "%s: received an unknown chip ID %x\n",\r\n__func__, ret);\r\nreturn -EINVAL;\r\n}\r\nindio_dev->info = &tsl2583_info;\r\nindio_dev->channels = tsl2583_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(tsl2583_channels);\r\nindio_dev->dev.parent = &clientp->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nindio_dev->name = chip->client->name;\r\nret = devm_iio_device_register(indio_dev->dev.parent, indio_dev);\r\nif (ret) {\r\ndev_err(&clientp->dev, "%s: iio registration failed\n",\r\n__func__);\r\nreturn ret;\r\n}\r\ntsl2583_defaults(chip);\r\nret = tsl2583_chip_init_and_power_on(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(&clientp->dev, "Light sensor found.\n");\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tsl2583_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&chip->als_mutex);\r\nret = tsl2583_set_power_state(chip, TSL2583_CNTL_PWR_OFF);\r\nchip->suspended = true;\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}\r\nstatic int __maybe_unused tsl2583_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct tsl2583_chip *chip = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&chip->als_mutex);\r\nret = tsl2583_chip_init_and_power_on(indio_dev);\r\nmutex_unlock(&chip->als_mutex);\r\nreturn ret;\r\n}
