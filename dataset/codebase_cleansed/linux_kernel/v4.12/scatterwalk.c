static inline void memcpy_dir(void *buf, void *sgdata, size_t nbytes, int out)\r\n{\r\nvoid *src = out ? buf : sgdata;\r\nvoid *dst = out ? sgdata : buf;\r\nmemcpy(dst, src, nbytes);\r\n}\r\nvoid scatterwalk_copychunks(void *buf, struct scatter_walk *walk,\r\nsize_t nbytes, int out)\r\n{\r\nfor (;;) {\r\nunsigned int len_this_page = scatterwalk_pagelen(walk);\r\nu8 *vaddr;\r\nif (len_this_page > nbytes)\r\nlen_this_page = nbytes;\r\nif (out != 2) {\r\nvaddr = scatterwalk_map(walk);\r\nmemcpy_dir(buf, vaddr, len_this_page, out);\r\nscatterwalk_unmap(vaddr);\r\n}\r\nscatterwalk_advance(walk, len_this_page);\r\nif (nbytes == len_this_page)\r\nbreak;\r\nbuf += len_this_page;\r\nnbytes -= len_this_page;\r\nscatterwalk_pagedone(walk, out & 1, 1);\r\n}\r\n}\r\nvoid scatterwalk_map_and_copy(void *buf, struct scatterlist *sg,\r\nunsigned int start, unsigned int nbytes, int out)\r\n{\r\nstruct scatter_walk walk;\r\nstruct scatterlist tmp[2];\r\nif (!nbytes)\r\nreturn;\r\nsg = scatterwalk_ffwd(tmp, sg, start);\r\nscatterwalk_start(&walk, sg);\r\nscatterwalk_copychunks(buf, &walk, nbytes, out);\r\nscatterwalk_done(&walk, out, 0);\r\n}\r\nstruct scatterlist *scatterwalk_ffwd(struct scatterlist dst[2],\r\nstruct scatterlist *src,\r\nunsigned int len)\r\n{\r\nfor (;;) {\r\nif (!len)\r\nreturn src;\r\nif (src->length > len)\r\nbreak;\r\nlen -= src->length;\r\nsrc = sg_next(src);\r\n}\r\nsg_init_table(dst, 2);\r\nsg_set_page(dst, sg_page(src), src->length - len, src->offset + len);\r\nscatterwalk_crypto_chain(dst, sg_next(src), 0, 2);\r\nreturn dst;\r\n}
