static void hw_guard_start(struct panel_drv_data *ddata, int guard_msec)\r\n{\r\nddata->hw_guard_wait = msecs_to_jiffies(guard_msec);\r\nddata->hw_guard_end = jiffies + ddata->hw_guard_wait;\r\n}\r\nstatic void hw_guard_wait(struct panel_drv_data *ddata)\r\n{\r\nunsigned long wait = ddata->hw_guard_end - jiffies;\r\nif ((long)wait > 0 && wait <= ddata->hw_guard_wait) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(wait);\r\n}\r\n}\r\nstatic int dsicm_dcs_read_1(struct panel_drv_data *ddata, u8 dcs_cmd, u8 *data)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nu8 buf[1];\r\nr = in->ops.dsi->dcs_read(in, ddata->channel, dcs_cmd, buf, 1);\r\nif (r < 0)\r\nreturn r;\r\n*data = buf[0];\r\nreturn 0;\r\n}\r\nstatic int dsicm_dcs_write_0(struct panel_drv_data *ddata, u8 dcs_cmd)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nreturn in->ops.dsi->dcs_write(in, ddata->channel, &dcs_cmd, 1);\r\n}\r\nstatic int dsicm_dcs_write_1(struct panel_drv_data *ddata, u8 dcs_cmd, u8 param)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nu8 buf[2] = { dcs_cmd, param };\r\nreturn in->ops.dsi->dcs_write(in, ddata->channel, buf, 2);\r\n}\r\nstatic int dsicm_sleep_in(struct panel_drv_data *ddata)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nu8 cmd;\r\nint r;\r\nhw_guard_wait(ddata);\r\ncmd = MIPI_DCS_ENTER_SLEEP_MODE;\r\nr = in->ops.dsi->dcs_write_nosync(in, ddata->channel, &cmd, 1);\r\nif (r)\r\nreturn r;\r\nhw_guard_start(ddata, 120);\r\nusleep_range(5000, 10000);\r\nreturn 0;\r\n}\r\nstatic int dsicm_sleep_out(struct panel_drv_data *ddata)\r\n{\r\nint r;\r\nhw_guard_wait(ddata);\r\nr = dsicm_dcs_write_0(ddata, MIPI_DCS_EXIT_SLEEP_MODE);\r\nif (r)\r\nreturn r;\r\nhw_guard_start(ddata, 120);\r\nusleep_range(5000, 10000);\r\nreturn 0;\r\n}\r\nstatic int dsicm_get_id(struct panel_drv_data *ddata, u8 *id1, u8 *id2, u8 *id3)\r\n{\r\nint r;\r\nr = dsicm_dcs_read_1(ddata, DCS_GET_ID1, id1);\r\nif (r)\r\nreturn r;\r\nr = dsicm_dcs_read_1(ddata, DCS_GET_ID2, id2);\r\nif (r)\r\nreturn r;\r\nr = dsicm_dcs_read_1(ddata, DCS_GET_ID3, id3);\r\nif (r)\r\nreturn r;\r\nreturn 0;\r\n}\r\nstatic int dsicm_set_update_window(struct panel_drv_data *ddata,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nu16 x1 = x;\r\nu16 x2 = x + w - 1;\r\nu16 y1 = y;\r\nu16 y2 = y + h - 1;\r\nu8 buf[5];\r\nbuf[0] = MIPI_DCS_SET_COLUMN_ADDRESS;\r\nbuf[1] = (x1 >> 8) & 0xff;\r\nbuf[2] = (x1 >> 0) & 0xff;\r\nbuf[3] = (x2 >> 8) & 0xff;\r\nbuf[4] = (x2 >> 0) & 0xff;\r\nr = in->ops.dsi->dcs_write_nosync(in, ddata->channel, buf, sizeof(buf));\r\nif (r)\r\nreturn r;\r\nbuf[0] = MIPI_DCS_SET_PAGE_ADDRESS;\r\nbuf[1] = (y1 >> 8) & 0xff;\r\nbuf[2] = (y1 >> 0) & 0xff;\r\nbuf[3] = (y2 >> 8) & 0xff;\r\nbuf[4] = (y2 >> 0) & 0xff;\r\nr = in->ops.dsi->dcs_write_nosync(in, ddata->channel, buf, sizeof(buf));\r\nif (r)\r\nreturn r;\r\nin->ops.dsi->bta_sync(in, ddata->channel);\r\nreturn r;\r\n}\r\nstatic void dsicm_queue_ulps_work(struct panel_drv_data *ddata)\r\n{\r\nif (ddata->ulps_timeout > 0)\r\nqueue_delayed_work(ddata->workqueue, &ddata->ulps_work,\r\nmsecs_to_jiffies(ddata->ulps_timeout));\r\n}\r\nstatic void dsicm_cancel_ulps_work(struct panel_drv_data *ddata)\r\n{\r\ncancel_delayed_work(&ddata->ulps_work);\r\n}\r\nstatic int dsicm_enter_ulps(struct panel_drv_data *ddata)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nif (ddata->ulps_enabled)\r\nreturn 0;\r\ndsicm_cancel_ulps_work(ddata);\r\nr = _dsicm_enable_te(ddata, false);\r\nif (r)\r\ngoto err;\r\nif (gpio_is_valid(ddata->ext_te_gpio))\r\ndisable_irq(gpio_to_irq(ddata->ext_te_gpio));\r\nin->ops.dsi->disable(in, false, true);\r\nddata->ulps_enabled = true;\r\nreturn 0;\r\nerr:\r\ndev_err(&ddata->pdev->dev, "enter ULPS failed");\r\ndsicm_panel_reset(ddata);\r\nddata->ulps_enabled = false;\r\ndsicm_queue_ulps_work(ddata);\r\nreturn r;\r\n}\r\nstatic int dsicm_exit_ulps(struct panel_drv_data *ddata)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nif (!ddata->ulps_enabled)\r\nreturn 0;\r\nr = in->ops.dsi->enable(in);\r\nif (r) {\r\ndev_err(&ddata->pdev->dev, "failed to enable DSI\n");\r\ngoto err1;\r\n}\r\nin->ops.dsi->enable_hs(in, ddata->channel, true);\r\nr = _dsicm_enable_te(ddata, true);\r\nif (r) {\r\ndev_err(&ddata->pdev->dev, "failed to re-enable TE");\r\ngoto err2;\r\n}\r\nif (gpio_is_valid(ddata->ext_te_gpio))\r\nenable_irq(gpio_to_irq(ddata->ext_te_gpio));\r\ndsicm_queue_ulps_work(ddata);\r\nddata->ulps_enabled = false;\r\nreturn 0;\r\nerr2:\r\ndev_err(&ddata->pdev->dev, "failed to exit ULPS");\r\nr = dsicm_panel_reset(ddata);\r\nif (!r) {\r\nif (gpio_is_valid(ddata->ext_te_gpio))\r\nenable_irq(gpio_to_irq(ddata->ext_te_gpio));\r\nddata->ulps_enabled = false;\r\n}\r\nerr1:\r\ndsicm_queue_ulps_work(ddata);\r\nreturn r;\r\n}\r\nstatic int dsicm_wake_up(struct panel_drv_data *ddata)\r\n{\r\nif (ddata->ulps_enabled)\r\nreturn dsicm_exit_ulps(ddata);\r\ndsicm_cancel_ulps_work(ddata);\r\ndsicm_queue_ulps_work(ddata);\r\nreturn 0;\r\n}\r\nstatic int dsicm_bl_update_status(struct backlight_device *dev)\r\n{\r\nstruct panel_drv_data *ddata = dev_get_drvdata(&dev->dev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nint level;\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nlevel = dev->props.brightness;\r\nelse\r\nlevel = 0;\r\ndev_dbg(&ddata->pdev->dev, "update brightness to %d\n", level);\r\nmutex_lock(&ddata->lock);\r\nif (ddata->enabled) {\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_wake_up(ddata);\r\nif (!r)\r\nr = dsicm_dcs_write_1(ddata, DCS_BRIGHTNESS, level);\r\nin->ops.dsi->bus_unlock(in);\r\n} else {\r\nr = 0;\r\n}\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic int dsicm_bl_get_intensity(struct backlight_device *dev)\r\n{\r\nif (dev->props.fb_blank == FB_BLANK_UNBLANK &&\r\ndev->props.power == FB_BLANK_UNBLANK)\r\nreturn dev->props.brightness;\r\nreturn 0;\r\n}\r\nstatic void dsicm_get_resolution(struct omap_dss_device *dssdev,\r\nu16 *xres, u16 *yres)\r\n{\r\n*xres = dssdev->panel.vm.hactive;\r\n*yres = dssdev->panel.vm.vactive;\r\n}\r\nstatic ssize_t dsicm_num_errors_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nu8 errors = 0;\r\nint r;\r\nmutex_lock(&ddata->lock);\r\nif (ddata->enabled) {\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_wake_up(ddata);\r\nif (!r)\r\nr = dsicm_dcs_read_1(ddata, DCS_READ_NUM_ERRORS,\r\n&errors);\r\nin->ops.dsi->bus_unlock(in);\r\n} else {\r\nr = -ENODEV;\r\n}\r\nmutex_unlock(&ddata->lock);\r\nif (r)\r\nreturn r;\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", errors);\r\n}\r\nstatic ssize_t dsicm_hw_revision_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nu8 id1, id2, id3;\r\nint r;\r\nmutex_lock(&ddata->lock);\r\nif (ddata->enabled) {\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_wake_up(ddata);\r\nif (!r)\r\nr = dsicm_get_id(ddata, &id1, &id2, &id3);\r\nin->ops.dsi->bus_unlock(in);\r\n} else {\r\nr = -ENODEV;\r\n}\r\nmutex_unlock(&ddata->lock);\r\nif (r)\r\nreturn r;\r\nreturn snprintf(buf, PAGE_SIZE, "%02x.%02x.%02x\n", id1, id2, id3);\r\n}\r\nstatic ssize_t dsicm_store_ulps(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nunsigned long t;\r\nint r;\r\nr = kstrtoul(buf, 0, &t);\r\nif (r)\r\nreturn r;\r\nmutex_lock(&ddata->lock);\r\nif (ddata->enabled) {\r\nin->ops.dsi->bus_lock(in);\r\nif (t)\r\nr = dsicm_enter_ulps(ddata);\r\nelse\r\nr = dsicm_wake_up(ddata);\r\nin->ops.dsi->bus_unlock(in);\r\n}\r\nmutex_unlock(&ddata->lock);\r\nif (r)\r\nreturn r;\r\nreturn count;\r\n}\r\nstatic ssize_t dsicm_show_ulps(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nunsigned t;\r\nmutex_lock(&ddata->lock);\r\nt = ddata->ulps_enabled;\r\nmutex_unlock(&ddata->lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", t);\r\n}\r\nstatic ssize_t dsicm_store_ulps_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nunsigned long t;\r\nint r;\r\nr = kstrtoul(buf, 0, &t);\r\nif (r)\r\nreturn r;\r\nmutex_lock(&ddata->lock);\r\nddata->ulps_timeout = t;\r\nif (ddata->enabled) {\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_wake_up(ddata);\r\nin->ops.dsi->bus_unlock(in);\r\n}\r\nmutex_unlock(&ddata->lock);\r\nif (r)\r\nreturn r;\r\nreturn count;\r\n}\r\nstatic ssize_t dsicm_show_ulps_timeout(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nunsigned t;\r\nmutex_lock(&ddata->lock);\r\nt = ddata->ulps_timeout;\r\nmutex_unlock(&ddata->lock);\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", t);\r\n}\r\nstatic void dsicm_hw_reset(struct panel_drv_data *ddata)\r\n{\r\nif (!gpio_is_valid(ddata->reset_gpio))\r\nreturn;\r\ngpio_set_value(ddata->reset_gpio, 1);\r\nudelay(10);\r\ngpio_set_value(ddata->reset_gpio, 0);\r\nudelay(10);\r\ngpio_set_value(ddata->reset_gpio, 1);\r\nusleep_range(5000, 10000);\r\n}\r\nstatic int dsicm_power_on(struct panel_drv_data *ddata)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nu8 id1, id2, id3;\r\nint r;\r\nstruct omap_dss_dsi_config dsi_config = {\r\n.mode = OMAP_DSS_DSI_CMD_MODE,\r\n.pixel_format = OMAP_DSS_DSI_FMT_RGB888,\r\n.vm = &ddata->vm,\r\n.hs_clk_min = 150000000,\r\n.hs_clk_max = 300000000,\r\n.lp_clk_min = 7000000,\r\n.lp_clk_max = 10000000,\r\n};\r\nif (ddata->pin_config.num_pins > 0) {\r\nr = in->ops.dsi->configure_pins(in, &ddata->pin_config);\r\nif (r) {\r\ndev_err(&ddata->pdev->dev,\r\n"failed to configure DSI pins\n");\r\ngoto err0;\r\n}\r\n}\r\nr = in->ops.dsi->set_config(in, &dsi_config);\r\nif (r) {\r\ndev_err(&ddata->pdev->dev, "failed to configure DSI\n");\r\ngoto err0;\r\n}\r\nr = in->ops.dsi->enable(in);\r\nif (r) {\r\ndev_err(&ddata->pdev->dev, "failed to enable DSI\n");\r\ngoto err0;\r\n}\r\ndsicm_hw_reset(ddata);\r\nin->ops.dsi->enable_hs(in, ddata->channel, false);\r\nr = dsicm_sleep_out(ddata);\r\nif (r)\r\ngoto err;\r\nr = dsicm_get_id(ddata, &id1, &id2, &id3);\r\nif (r)\r\ngoto err;\r\nr = dsicm_dcs_write_1(ddata, DCS_BRIGHTNESS, 0xff);\r\nif (r)\r\ngoto err;\r\nr = dsicm_dcs_write_1(ddata, DCS_CTRL_DISPLAY,\r\n(1<<2) | (1<<5));\r\nif (r)\r\ngoto err;\r\nr = dsicm_dcs_write_1(ddata, MIPI_DCS_SET_PIXEL_FORMAT,\r\nMIPI_DCS_PIXEL_FMT_24BIT);\r\nif (r)\r\ngoto err;\r\nr = dsicm_dcs_write_0(ddata, MIPI_DCS_SET_DISPLAY_ON);\r\nif (r)\r\ngoto err;\r\nr = _dsicm_enable_te(ddata, ddata->te_enabled);\r\nif (r)\r\ngoto err;\r\nr = in->ops.dsi->enable_video_output(in, ddata->channel);\r\nif (r)\r\ngoto err;\r\nddata->enabled = 1;\r\nif (!ddata->intro_printed) {\r\ndev_info(&ddata->pdev->dev, "panel revision %02x.%02x.%02x\n",\r\nid1, id2, id3);\r\nddata->intro_printed = true;\r\n}\r\nin->ops.dsi->enable_hs(in, ddata->channel, true);\r\nreturn 0;\r\nerr:\r\ndev_err(&ddata->pdev->dev, "error while enabling panel, issuing HW reset\n");\r\ndsicm_hw_reset(ddata);\r\nin->ops.dsi->disable(in, true, false);\r\nerr0:\r\nreturn r;\r\n}\r\nstatic void dsicm_power_off(struct panel_drv_data *ddata)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nin->ops.dsi->disable_video_output(in, ddata->channel);\r\nr = dsicm_dcs_write_0(ddata, MIPI_DCS_SET_DISPLAY_OFF);\r\nif (!r)\r\nr = dsicm_sleep_in(ddata);\r\nif (r) {\r\ndev_err(&ddata->pdev->dev,\r\n"error disabling panel, issuing HW reset\n");\r\ndsicm_hw_reset(ddata);\r\n}\r\nin->ops.dsi->disable(in, true, false);\r\nddata->enabled = 0;\r\n}\r\nstatic int dsicm_panel_reset(struct panel_drv_data *ddata)\r\n{\r\ndev_err(&ddata->pdev->dev, "performing LCD reset\n");\r\ndsicm_power_off(ddata);\r\ndsicm_hw_reset(ddata);\r\nreturn dsicm_power_on(ddata);\r\n}\r\nstatic int dsicm_connect(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nstruct device *dev = &ddata->pdev->dev;\r\nint r;\r\nif (omapdss_device_is_connected(dssdev))\r\nreturn 0;\r\nr = in->ops.dsi->connect(in, dssdev);\r\nif (r) {\r\ndev_err(dev, "Failed to connect to video source\n");\r\nreturn r;\r\n}\r\nr = in->ops.dsi->request_vc(ddata->in, &ddata->channel);\r\nif (r) {\r\ndev_err(dev, "failed to get virtual channel\n");\r\ngoto err_req_vc;\r\n}\r\nr = in->ops.dsi->set_vc_id(ddata->in, ddata->channel, TCH);\r\nif (r) {\r\ndev_err(dev, "failed to set VC_ID\n");\r\ngoto err_vc_id;\r\n}\r\nreturn 0;\r\nerr_vc_id:\r\nin->ops.dsi->release_vc(ddata->in, ddata->channel);\r\nerr_req_vc:\r\nin->ops.dsi->disconnect(in, dssdev);\r\nreturn r;\r\n}\r\nstatic void dsicm_disconnect(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nif (!omapdss_device_is_connected(dssdev))\r\nreturn;\r\nin->ops.dsi->release_vc(in, ddata->channel);\r\nin->ops.dsi->disconnect(in, dssdev);\r\n}\r\nstatic int dsicm_enable(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\ndev_dbg(&ddata->pdev->dev, "enable\n");\r\nmutex_lock(&ddata->lock);\r\nif (!omapdss_device_is_connected(dssdev)) {\r\nr = -ENODEV;\r\ngoto err;\r\n}\r\nif (omapdss_device_is_enabled(dssdev)) {\r\nr = 0;\r\ngoto err;\r\n}\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_power_on(ddata);\r\nin->ops.dsi->bus_unlock(in);\r\nif (r)\r\ngoto err;\r\ndssdev->state = OMAP_DSS_DISPLAY_ACTIVE;\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&ddata->pdev->dev, "enable failed\n");\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic void dsicm_disable(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\ndev_dbg(&ddata->pdev->dev, "disable\n");\r\nmutex_lock(&ddata->lock);\r\ndsicm_cancel_ulps_work(ddata);\r\nin->ops.dsi->bus_lock(in);\r\nif (omapdss_device_is_enabled(dssdev)) {\r\nr = dsicm_wake_up(ddata);\r\nif (!r)\r\ndsicm_power_off(ddata);\r\n}\r\nin->ops.dsi->bus_unlock(in);\r\ndssdev->state = OMAP_DSS_DISPLAY_DISABLED;\r\nmutex_unlock(&ddata->lock);\r\n}\r\nstatic void dsicm_framedone_cb(int err, void *data)\r\n{\r\nstruct panel_drv_data *ddata = data;\r\nstruct omap_dss_device *in = ddata->in;\r\ndev_dbg(&ddata->pdev->dev, "framedone, err %d\n", err);\r\nin->ops.dsi->bus_unlock(ddata->in);\r\n}\r\nstatic irqreturn_t dsicm_te_isr(int irq, void *data)\r\n{\r\nstruct panel_drv_data *ddata = data;\r\nstruct omap_dss_device *in = ddata->in;\r\nint old;\r\nint r;\r\nold = atomic_cmpxchg(&ddata->do_update, 1, 0);\r\nif (old) {\r\ncancel_delayed_work(&ddata->te_timeout_work);\r\nr = in->ops.dsi->update(in, ddata->channel, dsicm_framedone_cb,\r\nddata);\r\nif (r)\r\ngoto err;\r\n}\r\nreturn IRQ_HANDLED;\r\nerr:\r\ndev_err(&ddata->pdev->dev, "start update failed\n");\r\nin->ops.dsi->bus_unlock(in);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void dsicm_te_timeout_work_callback(struct work_struct *work)\r\n{\r\nstruct panel_drv_data *ddata = container_of(work, struct panel_drv_data,\r\nte_timeout_work.work);\r\nstruct omap_dss_device *in = ddata->in;\r\ndev_err(&ddata->pdev->dev, "TE not received for 250ms!\n");\r\natomic_set(&ddata->do_update, 0);\r\nin->ops.dsi->bus_unlock(in);\r\n}\r\nstatic int dsicm_update(struct omap_dss_device *dssdev,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\ndev_dbg(&ddata->pdev->dev, "update %d, %d, %d x %d\n", x, y, w, h);\r\nmutex_lock(&ddata->lock);\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_wake_up(ddata);\r\nif (r)\r\ngoto err;\r\nif (!ddata->enabled) {\r\nr = 0;\r\ngoto err;\r\n}\r\nr = dsicm_set_update_window(ddata, 0, 0,\r\ndssdev->panel.vm.hactive,\r\ndssdev->panel.vm.vactive);\r\nif (r)\r\ngoto err;\r\nif (ddata->te_enabled && gpio_is_valid(ddata->ext_te_gpio)) {\r\nschedule_delayed_work(&ddata->te_timeout_work,\r\nmsecs_to_jiffies(250));\r\natomic_set(&ddata->do_update, 1);\r\n} else {\r\nr = in->ops.dsi->update(in, ddata->channel, dsicm_framedone_cb,\r\nddata);\r\nif (r)\r\ngoto err;\r\n}\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\nerr:\r\nin->ops.dsi->bus_unlock(in);\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic int dsicm_sync(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\ndev_dbg(&ddata->pdev->dev, "sync\n");\r\nmutex_lock(&ddata->lock);\r\nin->ops.dsi->bus_lock(in);\r\nin->ops.dsi->bus_unlock(in);\r\nmutex_unlock(&ddata->lock);\r\ndev_dbg(&ddata->pdev->dev, "sync done\n");\r\nreturn 0;\r\n}\r\nstatic int _dsicm_enable_te(struct panel_drv_data *ddata, bool enable)\r\n{\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nif (enable)\r\nr = dsicm_dcs_write_1(ddata, MIPI_DCS_SET_TEAR_ON, 0);\r\nelse\r\nr = dsicm_dcs_write_0(ddata, MIPI_DCS_SET_TEAR_OFF);\r\nif (!gpio_is_valid(ddata->ext_te_gpio))\r\nin->ops.dsi->enable_te(in, enable);\r\nmsleep(100);\r\nreturn r;\r\n}\r\nstatic int dsicm_enable_te(struct omap_dss_device *dssdev, bool enable)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nmutex_lock(&ddata->lock);\r\nif (ddata->te_enabled == enable)\r\ngoto end;\r\nin->ops.dsi->bus_lock(in);\r\nif (ddata->enabled) {\r\nr = dsicm_wake_up(ddata);\r\nif (r)\r\ngoto err;\r\nr = _dsicm_enable_te(ddata, enable);\r\nif (r)\r\ngoto err;\r\n}\r\nddata->te_enabled = enable;\r\nin->ops.dsi->bus_unlock(in);\r\nend:\r\nmutex_unlock(&ddata->lock);\r\nreturn 0;\r\nerr:\r\nin->ops.dsi->bus_unlock(in);\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic int dsicm_get_te(struct omap_dss_device *dssdev)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nint r;\r\nmutex_lock(&ddata->lock);\r\nr = ddata->te_enabled;\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic int dsicm_memory_read(struct omap_dss_device *dssdev,\r\nvoid *buf, size_t size,\r\nu16 x, u16 y, u16 w, u16 h)\r\n{\r\nstruct panel_drv_data *ddata = to_panel_data(dssdev);\r\nstruct omap_dss_device *in = ddata->in;\r\nint r;\r\nint first = 1;\r\nint plen;\r\nunsigned buf_used = 0;\r\nif (size < w * h * 3)\r\nreturn -ENOMEM;\r\nmutex_lock(&ddata->lock);\r\nif (!ddata->enabled) {\r\nr = -ENODEV;\r\ngoto err1;\r\n}\r\nsize = min((u32)w * h * 3,\r\ndssdev->panel.vm.hactive * dssdev->panel.vm.vactive * 3);\r\nin->ops.dsi->bus_lock(in);\r\nr = dsicm_wake_up(ddata);\r\nif (r)\r\ngoto err2;\r\nif (size % 2)\r\nplen = 1;\r\nelse\r\nplen = 2;\r\ndsicm_set_update_window(ddata, x, y, w, h);\r\nr = in->ops.dsi->set_max_rx_packet_size(in, ddata->channel, plen);\r\nif (r)\r\ngoto err2;\r\nwhile (buf_used < size) {\r\nu8 dcs_cmd = first ? 0x2e : 0x3e;\r\nfirst = 0;\r\nr = in->ops.dsi->dcs_read(in, ddata->channel, dcs_cmd,\r\nbuf + buf_used, size - buf_used);\r\nif (r < 0) {\r\ndev_err(dssdev->dev, "read error\n");\r\ngoto err3;\r\n}\r\nbuf_used += r;\r\nif (r < plen) {\r\ndev_err(&ddata->pdev->dev, "short read\n");\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\ndev_err(&ddata->pdev->dev, "signal pending, "\r\n"aborting memory read\n");\r\nr = -ERESTARTSYS;\r\ngoto err3;\r\n}\r\n}\r\nr = buf_used;\r\nerr3:\r\nin->ops.dsi->set_max_rx_packet_size(in, ddata->channel, 1);\r\nerr2:\r\nin->ops.dsi->bus_unlock(in);\r\nerr1:\r\nmutex_unlock(&ddata->lock);\r\nreturn r;\r\n}\r\nstatic void dsicm_ulps_work(struct work_struct *work)\r\n{\r\nstruct panel_drv_data *ddata = container_of(work, struct panel_drv_data,\r\nulps_work.work);\r\nstruct omap_dss_device *dssdev = &ddata->dssdev;\r\nstruct omap_dss_device *in = ddata->in;\r\nmutex_lock(&ddata->lock);\r\nif (dssdev->state != OMAP_DSS_DISPLAY_ACTIVE || !ddata->enabled) {\r\nmutex_unlock(&ddata->lock);\r\nreturn;\r\n}\r\nin->ops.dsi->bus_lock(in);\r\ndsicm_enter_ulps(ddata);\r\nin->ops.dsi->bus_unlock(in);\r\nmutex_unlock(&ddata->lock);\r\n}\r\nstatic int dsicm_probe_of(struct platform_device *pdev)\r\n{\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nstruct omap_dss_device *in;\r\nint gpio;\r\ngpio = of_get_named_gpio(node, "reset-gpios", 0);\r\nif (!gpio_is_valid(gpio)) {\r\ndev_err(&pdev->dev, "failed to parse reset gpio\n");\r\nreturn gpio;\r\n}\r\nddata->reset_gpio = gpio;\r\ngpio = of_get_named_gpio(node, "te-gpios", 0);\r\nif (gpio_is_valid(gpio) || gpio == -ENOENT) {\r\nddata->ext_te_gpio = gpio;\r\n} else {\r\ndev_err(&pdev->dev, "failed to parse TE gpio\n");\r\nreturn gpio;\r\n}\r\nin = omapdss_of_find_source_for_first_ep(node);\r\nif (IS_ERR(in)) {\r\ndev_err(&pdev->dev, "failed to find video source\n");\r\nreturn PTR_ERR(in);\r\n}\r\nddata->in = in;\r\nreturn 0;\r\n}\r\nstatic int dsicm_probe(struct platform_device *pdev)\r\n{\r\nstruct backlight_properties props;\r\nstruct panel_drv_data *ddata;\r\nstruct backlight_device *bldev = NULL;\r\nstruct device *dev = &pdev->dev;\r\nstruct omap_dss_device *dssdev;\r\nint r;\r\ndev_dbg(dev, "probe\n");\r\nddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ddata);\r\nddata->pdev = pdev;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nr = dsicm_probe_of(pdev);\r\nif (r)\r\nreturn r;\r\nddata->vm.hactive = 864;\r\nddata->vm.vactive = 480;\r\nddata->vm.pixelclock = 864 * 480 * 60;\r\ndssdev = &ddata->dssdev;\r\ndssdev->dev = dev;\r\ndssdev->driver = &dsicm_ops;\r\ndssdev->panel.vm = ddata->vm;\r\ndssdev->type = OMAP_DISPLAY_TYPE_DSI;\r\ndssdev->owner = THIS_MODULE;\r\ndssdev->panel.dsi_pix_fmt = OMAP_DSS_DSI_FMT_RGB888;\r\ndssdev->caps = OMAP_DSS_DISPLAY_CAP_MANUAL_UPDATE |\r\nOMAP_DSS_DISPLAY_CAP_TEAR_ELIM;\r\nr = omapdss_register_display(dssdev);\r\nif (r) {\r\ndev_err(dev, "Failed to register panel\n");\r\ngoto err_reg;\r\n}\r\nmutex_init(&ddata->lock);\r\natomic_set(&ddata->do_update, 0);\r\nif (gpio_is_valid(ddata->reset_gpio)) {\r\nr = devm_gpio_request_one(dev, ddata->reset_gpio,\r\nGPIOF_OUT_INIT_LOW, "taal rst");\r\nif (r) {\r\ndev_err(dev, "failed to request reset gpio\n");\r\nreturn r;\r\n}\r\n}\r\nif (gpio_is_valid(ddata->ext_te_gpio)) {\r\nr = devm_gpio_request_one(dev, ddata->ext_te_gpio,\r\nGPIOF_IN, "taal irq");\r\nif (r) {\r\ndev_err(dev, "GPIO request failed\n");\r\nreturn r;\r\n}\r\nr = devm_request_irq(dev, gpio_to_irq(ddata->ext_te_gpio),\r\ndsicm_te_isr,\r\nIRQF_TRIGGER_RISING,\r\n"taal vsync", ddata);\r\nif (r) {\r\ndev_err(dev, "IRQ request failed\n");\r\nreturn r;\r\n}\r\nINIT_DEFERRABLE_WORK(&ddata->te_timeout_work,\r\ndsicm_te_timeout_work_callback);\r\ndev_dbg(dev, "Using GPIO TE\n");\r\n}\r\nddata->workqueue = create_singlethread_workqueue("dsicm_wq");\r\nif (ddata->workqueue == NULL) {\r\ndev_err(dev, "can't create workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nINIT_DELAYED_WORK(&ddata->ulps_work, dsicm_ulps_work);\r\ndsicm_hw_reset(ddata);\r\nif (ddata->use_dsi_backlight) {\r\nmemset(&props, 0, sizeof(props));\r\nprops.max_brightness = 255;\r\nprops.type = BACKLIGHT_RAW;\r\nbldev = backlight_device_register(dev_name(dev),\r\ndev, ddata, &dsicm_bl_ops, &props);\r\nif (IS_ERR(bldev)) {\r\nr = PTR_ERR(bldev);\r\ngoto err_bl;\r\n}\r\nddata->bldev = bldev;\r\nbldev->props.fb_blank = FB_BLANK_UNBLANK;\r\nbldev->props.power = FB_BLANK_UNBLANK;\r\nbldev->props.brightness = 255;\r\ndsicm_bl_update_status(bldev);\r\n}\r\nr = sysfs_create_group(&dev->kobj, &dsicm_attr_group);\r\nif (r) {\r\ndev_err(dev, "failed to create sysfs files\n");\r\ngoto err_sysfs_create;\r\n}\r\nreturn 0;\r\nerr_sysfs_create:\r\nbacklight_device_unregister(bldev);\r\nerr_bl:\r\ndestroy_workqueue(ddata->workqueue);\r\nerr_reg:\r\nreturn r;\r\n}\r\nstatic int __exit dsicm_remove(struct platform_device *pdev)\r\n{\r\nstruct panel_drv_data *ddata = platform_get_drvdata(pdev);\r\nstruct omap_dss_device *dssdev = &ddata->dssdev;\r\nstruct backlight_device *bldev;\r\ndev_dbg(&pdev->dev, "remove\n");\r\nomapdss_unregister_display(dssdev);\r\ndsicm_disable(dssdev);\r\ndsicm_disconnect(dssdev);\r\nsysfs_remove_group(&pdev->dev.kobj, &dsicm_attr_group);\r\nbldev = ddata->bldev;\r\nif (bldev != NULL) {\r\nbldev->props.power = FB_BLANK_POWERDOWN;\r\ndsicm_bl_update_status(bldev);\r\nbacklight_device_unregister(bldev);\r\n}\r\nomap_dss_put_device(ddata->in);\r\ndsicm_cancel_ulps_work(ddata);\r\ndestroy_workqueue(ddata->workqueue);\r\ndsicm_hw_reset(ddata);\r\nreturn 0;\r\n}
