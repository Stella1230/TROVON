static int\r\nnvkm_uclient_new(const struct nvkm_oclass *oclass, void *argv, u32 argc,\r\nstruct nvkm_object **pobject)\r\n{\r\nunion {\r\nstruct nvif_client_v0 v0;\r\n} *args = argv;\r\nstruct nvkm_client *client;\r\nint ret = -ENOSYS;\r\nif (!(ret = nvif_unpack(ret, &argv, &argc, args->v0, 0, 0, false))){\r\nargs->v0.name[sizeof(args->v0.name) - 1] = 0;\r\nret = nvkm_client_new(args->v0.name, args->v0.device, NULL,\r\nNULL, oclass->client->ntfy, &client);\r\nif (ret)\r\nreturn ret;\r\n} else\r\nreturn ret;\r\nclient->object.client = oclass->client;\r\nclient->object.handle = oclass->handle;\r\nclient->object.route = oclass->route;\r\nclient->object.token = oclass->token;\r\nclient->object.object = oclass->object;\r\nclient->debug = oclass->client->debug;\r\n*pobject = &client->object;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_client_notify(struct nvkm_notify *n)\r\n{\r\nstruct nvkm_client_notify *notify = container_of(n, typeof(*notify), n);\r\nstruct nvkm_client *client = notify->client;\r\nreturn client->ntfy(&notify->rep, notify->size, n->data, n->size);\r\n}\r\nint\r\nnvkm_client_notify_put(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_put(&client->notify[index]->n);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_get(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_get(&client->notify[index]->n);\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_del(struct nvkm_client *client, int index)\r\n{\r\nif (index < ARRAY_SIZE(client->notify)) {\r\nif (client->notify[index]) {\r\nnvkm_notify_fini(&client->notify[index]->n);\r\nkfree(client->notify[index]);\r\nclient->notify[index] = NULL;\r\nreturn 0;\r\n}\r\n}\r\nreturn -ENOENT;\r\n}\r\nint\r\nnvkm_client_notify_new(struct nvkm_object *object,\r\nstruct nvkm_event *event, void *data, u32 size)\r\n{\r\nstruct nvkm_client *client = object->client;\r\nstruct nvkm_client_notify *notify;\r\nunion {\r\nstruct nvif_notify_req_v0 v0;\r\n} *req = data;\r\nu8 index, reply;\r\nint ret = -ENOSYS;\r\nfor (index = 0; index < ARRAY_SIZE(client->notify); index++) {\r\nif (!client->notify[index])\r\nbreak;\r\n}\r\nif (index == ARRAY_SIZE(client->notify))\r\nreturn -ENOSPC;\r\nnotify = kzalloc(sizeof(*notify), GFP_KERNEL);\r\nif (!notify)\r\nreturn -ENOMEM;\r\nnvif_ioctl(object, "notify new size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, req->v0, 0, 0, true))) {\r\nnvif_ioctl(object, "notify new vers %d reply %d route %02x "\r\n"token %llx\n", req->v0.version,\r\nreq->v0.reply, req->v0.route, req->v0.token);\r\nnotify->version = req->v0.version;\r\nnotify->size = sizeof(notify->rep.v0);\r\nnotify->rep.v0.version = req->v0.version;\r\nnotify->rep.v0.route = req->v0.route;\r\nnotify->rep.v0.token = req->v0.token;\r\nreply = req->v0.reply;\r\n}\r\nif (ret == 0) {\r\nret = nvkm_notify_init(object, event, nvkm_client_notify,\r\nfalse, data, size, reply, &notify->n);\r\nif (ret == 0) {\r\nclient->notify[index] = notify;\r\nnotify->client = client;\r\nreturn index;\r\n}\r\n}\r\nkfree(notify);\r\nreturn ret;\r\n}\r\nstruct nvkm_client *\r\nnvkm_client_search(struct nvkm_client *client, u64 handle)\r\n{\r\nstruct nvkm_object *object;\r\nobject = nvkm_object_search(client, handle, &nvkm_client);\r\nif (IS_ERR(object))\r\nreturn (void *)object;\r\nreturn nvkm_client(object);\r\n}\r\nstatic int\r\nnvkm_client_mthd_devlist(struct nvkm_client *client, void *data, u32 size)\r\n{\r\nunion {\r\nstruct nvif_client_devlist_v0 v0;\r\n} *args = data;\r\nint ret = -ENOSYS;\r\nnvif_ioctl(&client->object, "client devlist size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, true))) {\r\nnvif_ioctl(&client->object, "client devlist vers %d count %d\n",\r\nargs->v0.version, args->v0.count);\r\nif (size == sizeof(args->v0.device[0]) * args->v0.count) {\r\nret = nvkm_device_list(args->v0.device, args->v0.count);\r\nif (ret >= 0) {\r\nargs->v0.count = ret;\r\nret = 0;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nnvkm_client_mthd(struct nvkm_object *object, u32 mthd, void *data, u32 size)\r\n{\r\nstruct nvkm_client *client = nvkm_client(object);\r\nswitch (mthd) {\r\ncase NVIF_CLIENT_V0_DEVLIST:\r\nreturn nvkm_client_mthd_devlist(client, data, size);\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\nnvkm_client_child_new(const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nreturn oclass->base.ctor(oclass, data, size, pobject);\r\n}\r\nstatic int\r\nnvkm_client_child_get(struct nvkm_object *object, int index,\r\nstruct nvkm_oclass *oclass)\r\n{\r\nconst struct nvkm_sclass *sclass;\r\nswitch (index) {\r\ncase 0: sclass = &nvkm_uclient_sclass; break;\r\ncase 1: sclass = &nvkm_udevice_sclass; break;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\noclass->ctor = nvkm_client_child_new;\r\noclass->base = *sclass;\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_client_fini(struct nvkm_object *object, bool suspend)\r\n{\r\nstruct nvkm_client *client = nvkm_client(object);\r\nconst char *name[2] = { "fini", "suspend" };\r\nint i;\r\nnvif_debug(object, "%s notify\n", name[suspend]);\r\nfor (i = 0; i < ARRAY_SIZE(client->notify); i++)\r\nnvkm_client_notify_put(client, i);\r\nreturn 0;\r\n}\r\nstatic void *\r\nnvkm_client_dtor(struct nvkm_object *object)\r\n{\r\nstruct nvkm_client *client = nvkm_client(object);\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(client->notify); i++)\r\nnvkm_client_notify_del(client, i);\r\nreturn client;\r\n}\r\nint\r\nnvkm_client_new(const char *name, u64 device, const char *cfg,\r\nconst char *dbg,\r\nint (*ntfy)(const void *, u32, const void *, u32),\r\nstruct nvkm_client **pclient)\r\n{\r\nstruct nvkm_oclass oclass = { .base = nvkm_uclient_sclass };\r\nstruct nvkm_client *client;\r\nif (!(client = *pclient = kzalloc(sizeof(*client), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\noclass.client = client;\r\nnvkm_object_ctor(&nvkm_client, &oclass, &client->object);\r\nsnprintf(client->name, sizeof(client->name), "%s", name);\r\nclient->device = device;\r\nclient->debug = nvkm_dbgopt(dbg, "CLIENT");\r\nclient->objroot = RB_ROOT;\r\nclient->ntfy = ntfy;\r\nreturn 0;\r\n}
