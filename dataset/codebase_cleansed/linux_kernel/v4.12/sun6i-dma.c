static struct device *chan2dev(struct dma_chan *chan)\r\n{\r\nreturn &chan->dev->device;\r\n}\r\nstatic inline struct sun6i_dma_dev *to_sun6i_dma_dev(struct dma_device *d)\r\n{\r\nreturn container_of(d, struct sun6i_dma_dev, slave);\r\n}\r\nstatic inline struct sun6i_vchan *to_sun6i_vchan(struct dma_chan *chan)\r\n{\r\nreturn container_of(chan, struct sun6i_vchan, vc.chan);\r\n}\r\nstatic inline struct sun6i_desc *\r\nto_sun6i_desc(struct dma_async_tx_descriptor *tx)\r\n{\r\nreturn container_of(tx, struct sun6i_desc, vd.tx);\r\n}\r\nstatic inline void sun6i_dma_dump_com_regs(struct sun6i_dma_dev *sdev)\r\n{\r\ndev_dbg(sdev->slave.dev, "Common register:\n"\r\n"\tmask0(%04x): 0x%08x\n"\r\n"\tmask1(%04x): 0x%08x\n"\r\n"\tpend0(%04x): 0x%08x\n"\r\n"\tpend1(%04x): 0x%08x\n"\r\n"\tstats(%04x): 0x%08x\n",\r\nDMA_IRQ_EN(0), readl(sdev->base + DMA_IRQ_EN(0)),\r\nDMA_IRQ_EN(1), readl(sdev->base + DMA_IRQ_EN(1)),\r\nDMA_IRQ_STAT(0), readl(sdev->base + DMA_IRQ_STAT(0)),\r\nDMA_IRQ_STAT(1), readl(sdev->base + DMA_IRQ_STAT(1)),\r\nDMA_STAT, readl(sdev->base + DMA_STAT));\r\n}\r\nstatic inline void sun6i_dma_dump_chan_regs(struct sun6i_dma_dev *sdev,\r\nstruct sun6i_pchan *pchan)\r\n{\r\nphys_addr_t reg = virt_to_phys(pchan->base);\r\ndev_dbg(sdev->slave.dev, "Chan %d reg: %pa\n"\r\n"\t___en(%04x): \t0x%08x\n"\r\n"\tpause(%04x): \t0x%08x\n"\r\n"\tstart(%04x): \t0x%08x\n"\r\n"\t__cfg(%04x): \t0x%08x\n"\r\n"\t__src(%04x): \t0x%08x\n"\r\n"\t__dst(%04x): \t0x%08x\n"\r\n"\tcount(%04x): \t0x%08x\n"\r\n"\t_para(%04x): \t0x%08x\n\n",\r\npchan->idx, &reg,\r\nDMA_CHAN_ENABLE,\r\nreadl(pchan->base + DMA_CHAN_ENABLE),\r\nDMA_CHAN_PAUSE,\r\nreadl(pchan->base + DMA_CHAN_PAUSE),\r\nDMA_CHAN_LLI_ADDR,\r\nreadl(pchan->base + DMA_CHAN_LLI_ADDR),\r\nDMA_CHAN_CUR_CFG,\r\nreadl(pchan->base + DMA_CHAN_CUR_CFG),\r\nDMA_CHAN_CUR_SRC,\r\nreadl(pchan->base + DMA_CHAN_CUR_SRC),\r\nDMA_CHAN_CUR_DST,\r\nreadl(pchan->base + DMA_CHAN_CUR_DST),\r\nDMA_CHAN_CUR_CNT,\r\nreadl(pchan->base + DMA_CHAN_CUR_CNT),\r\nDMA_CHAN_CUR_PARA,\r\nreadl(pchan->base + DMA_CHAN_CUR_PARA));\r\n}\r\nstatic inline s8 convert_burst(u32 maxburst)\r\n{\r\nswitch (maxburst) {\r\ncase 1:\r\nreturn 0;\r\ncase 8:\r\nreturn 2;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline s8 convert_buswidth(enum dma_slave_buswidth addr_width)\r\n{\r\nif ((addr_width < DMA_SLAVE_BUSWIDTH_1_BYTE) ||\r\n(addr_width > DMA_SLAVE_BUSWIDTH_4_BYTES))\r\nreturn -EINVAL;\r\nreturn addr_width >> 1;\r\n}\r\nstatic size_t sun6i_get_chan_size(struct sun6i_pchan *pchan)\r\n{\r\nstruct sun6i_desc *txd = pchan->desc;\r\nstruct sun6i_dma_lli *lli;\r\nsize_t bytes;\r\ndma_addr_t pos;\r\npos = readl(pchan->base + DMA_CHAN_LLI_ADDR);\r\nbytes = readl(pchan->base + DMA_CHAN_CUR_CNT);\r\nif (pos == LLI_LAST_ITEM)\r\nreturn bytes;\r\nfor (lli = txd->v_lli; lli; lli = lli->v_lli_next) {\r\nif (lli->p_lli_next == pos) {\r\nfor (lli = lli->v_lli_next; lli; lli = lli->v_lli_next)\r\nbytes += lli->len;\r\nbreak;\r\n}\r\n}\r\nreturn bytes;\r\n}\r\nstatic void *sun6i_dma_lli_add(struct sun6i_dma_lli *prev,\r\nstruct sun6i_dma_lli *next,\r\ndma_addr_t next_phy,\r\nstruct sun6i_desc *txd)\r\n{\r\nif ((!prev && !txd) || !next)\r\nreturn NULL;\r\nif (!prev) {\r\ntxd->p_lli = next_phy;\r\ntxd->v_lli = next;\r\n} else {\r\nprev->p_lli_next = next_phy;\r\nprev->v_lli_next = next;\r\n}\r\nnext->p_lli_next = LLI_LAST_ITEM;\r\nnext->v_lli_next = NULL;\r\nreturn next;\r\n}\r\nstatic inline void sun6i_dma_dump_lli(struct sun6i_vchan *vchan,\r\nstruct sun6i_dma_lli *lli)\r\n{\r\nphys_addr_t p_lli = virt_to_phys(lli);\r\ndev_dbg(chan2dev(&vchan->vc.chan),\r\n"\n\tdesc: p - %pa v - 0x%p\n"\r\n"\t\tc - 0x%08x s - 0x%08x d - 0x%08x\n"\r\n"\t\tl - 0x%08x p - 0x%08x n - 0x%08x\n",\r\n&p_lli, lli,\r\nlli->cfg, lli->src, lli->dst,\r\nlli->len, lli->para, lli->p_lli_next);\r\n}\r\nstatic void sun6i_dma_free_desc(struct virt_dma_desc *vd)\r\n{\r\nstruct sun6i_desc *txd = to_sun6i_desc(&vd->tx);\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(vd->tx.chan->device);\r\nstruct sun6i_dma_lli *v_lli, *v_next;\r\ndma_addr_t p_lli, p_next;\r\nif (unlikely(!txd))\r\nreturn;\r\np_lli = txd->p_lli;\r\nv_lli = txd->v_lli;\r\nwhile (v_lli) {\r\nv_next = v_lli->v_lli_next;\r\np_next = v_lli->p_lli_next;\r\ndma_pool_free(sdev->pool, v_lli, p_lli);\r\nv_lli = v_next;\r\np_lli = p_next;\r\n}\r\nkfree(txd);\r\n}\r\nstatic int sun6i_dma_start_desc(struct sun6i_vchan *vchan)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(vchan->vc.chan.device);\r\nstruct virt_dma_desc *desc = vchan_next_desc(&vchan->vc);\r\nstruct sun6i_pchan *pchan = vchan->phy;\r\nu32 irq_val, irq_reg, irq_offset;\r\nif (!pchan)\r\nreturn -EAGAIN;\r\nif (!desc) {\r\npchan->desc = NULL;\r\npchan->done = NULL;\r\nreturn -EAGAIN;\r\n}\r\nlist_del(&desc->node);\r\npchan->desc = to_sun6i_desc(&desc->tx);\r\npchan->done = NULL;\r\nsun6i_dma_dump_lli(vchan, pchan->desc->v_lli);\r\nirq_reg = pchan->idx / DMA_IRQ_CHAN_NR;\r\nirq_offset = pchan->idx % DMA_IRQ_CHAN_NR;\r\nvchan->irq_type = vchan->cyclic ? DMA_IRQ_PKG : DMA_IRQ_QUEUE;\r\nirq_val = readl(sdev->base + DMA_IRQ_EN(irq_reg));\r\nirq_val &= ~((DMA_IRQ_HALF | DMA_IRQ_PKG | DMA_IRQ_QUEUE) <<\r\n(irq_offset * DMA_IRQ_CHAN_WIDTH));\r\nirq_val |= vchan->irq_type << (irq_offset * DMA_IRQ_CHAN_WIDTH);\r\nwritel(irq_val, sdev->base + DMA_IRQ_EN(irq_reg));\r\nwritel(pchan->desc->p_lli, pchan->base + DMA_CHAN_LLI_ADDR);\r\nwritel(DMA_CHAN_ENABLE_START, pchan->base + DMA_CHAN_ENABLE);\r\nsun6i_dma_dump_com_regs(sdev);\r\nsun6i_dma_dump_chan_regs(sdev, pchan);\r\nreturn 0;\r\n}\r\nstatic void sun6i_dma_tasklet(unsigned long data)\r\n{\r\nstruct sun6i_dma_dev *sdev = (struct sun6i_dma_dev *)data;\r\nconst struct sun6i_dma_config *cfg = sdev->cfg;\r\nstruct sun6i_vchan *vchan;\r\nstruct sun6i_pchan *pchan;\r\nunsigned int pchan_alloc = 0;\r\nunsigned int pchan_idx;\r\nlist_for_each_entry(vchan, &sdev->slave.channels, vc.chan.device_node) {\r\nspin_lock_irq(&vchan->vc.lock);\r\npchan = vchan->phy;\r\nif (pchan && pchan->done) {\r\nif (sun6i_dma_start_desc(vchan)) {\r\ndev_dbg(sdev->slave.dev, "pchan %u: free\n",\r\npchan->idx);\r\nvchan->phy = NULL;\r\npchan->vchan = NULL;\r\n}\r\n}\r\nspin_unlock_irq(&vchan->vc.lock);\r\n}\r\nspin_lock_irq(&sdev->lock);\r\nfor (pchan_idx = 0; pchan_idx < cfg->nr_max_channels; pchan_idx++) {\r\npchan = &sdev->pchans[pchan_idx];\r\nif (pchan->vchan || list_empty(&sdev->pending))\r\ncontinue;\r\nvchan = list_first_entry(&sdev->pending,\r\nstruct sun6i_vchan, node);\r\nlist_del_init(&vchan->node);\r\npchan_alloc |= BIT(pchan_idx);\r\npchan->vchan = vchan;\r\nvchan->phy = pchan;\r\ndev_dbg(sdev->slave.dev, "pchan %u: alloc vchan %p\n",\r\npchan->idx, &vchan->vc);\r\n}\r\nspin_unlock_irq(&sdev->lock);\r\nfor (pchan_idx = 0; pchan_idx < cfg->nr_max_channels; pchan_idx++) {\r\nif (!(pchan_alloc & BIT(pchan_idx)))\r\ncontinue;\r\npchan = sdev->pchans + pchan_idx;\r\nvchan = pchan->vchan;\r\nif (vchan) {\r\nspin_lock_irq(&vchan->vc.lock);\r\nsun6i_dma_start_desc(vchan);\r\nspin_unlock_irq(&vchan->vc.lock);\r\n}\r\n}\r\n}\r\nstatic irqreturn_t sun6i_dma_interrupt(int irq, void *dev_id)\r\n{\r\nstruct sun6i_dma_dev *sdev = dev_id;\r\nstruct sun6i_vchan *vchan;\r\nstruct sun6i_pchan *pchan;\r\nint i, j, ret = IRQ_NONE;\r\nu32 status;\r\nfor (i = 0; i < sdev->cfg->nr_max_channels / DMA_IRQ_CHAN_NR; i++) {\r\nstatus = readl(sdev->base + DMA_IRQ_STAT(i));\r\nif (!status)\r\ncontinue;\r\ndev_dbg(sdev->slave.dev, "DMA irq status %s: 0x%x\n",\r\ni ? "high" : "low", status);\r\nwritel(status, sdev->base + DMA_IRQ_STAT(i));\r\nfor (j = 0; (j < DMA_IRQ_CHAN_NR) && status; j++) {\r\npchan = sdev->pchans + j;\r\nvchan = pchan->vchan;\r\nif (vchan && (status & vchan->irq_type)) {\r\nif (vchan->cyclic) {\r\nvchan_cyclic_callback(&pchan->desc->vd);\r\n} else {\r\nspin_lock(&vchan->vc.lock);\r\nvchan_cookie_complete(&pchan->desc->vd);\r\npchan->done = pchan->desc;\r\nspin_unlock(&vchan->vc.lock);\r\n}\r\n}\r\nstatus = status >> DMA_IRQ_CHAN_WIDTH;\r\n}\r\nif (!atomic_read(&sdev->tasklet_shutdown))\r\ntasklet_schedule(&sdev->task);\r\nret = IRQ_HANDLED;\r\n}\r\nreturn ret;\r\n}\r\nstatic int set_config(struct sun6i_dma_dev *sdev,\r\nstruct dma_slave_config *sconfig,\r\nenum dma_transfer_direction direction,\r\nu32 *p_cfg)\r\n{\r\ns8 src_width, dst_width, src_burst, dst_burst;\r\nswitch (direction) {\r\ncase DMA_MEM_TO_DEV:\r\nsrc_burst = convert_burst(sconfig->src_maxburst ?\r\nsconfig->src_maxburst : 8);\r\nsrc_width = convert_buswidth(sconfig->src_addr_width !=\r\nDMA_SLAVE_BUSWIDTH_UNDEFINED ?\r\nsconfig->src_addr_width :\r\nDMA_SLAVE_BUSWIDTH_4_BYTES);\r\ndst_burst = convert_burst(sconfig->dst_maxburst);\r\ndst_width = convert_buswidth(sconfig->dst_addr_width);\r\nbreak;\r\ncase DMA_DEV_TO_MEM:\r\nsrc_burst = convert_burst(sconfig->src_maxburst);\r\nsrc_width = convert_buswidth(sconfig->src_addr_width);\r\ndst_burst = convert_burst(sconfig->dst_maxburst ?\r\nsconfig->dst_maxburst : 8);\r\ndst_width = convert_buswidth(sconfig->dst_addr_width !=\r\nDMA_SLAVE_BUSWIDTH_UNDEFINED ?\r\nsconfig->dst_addr_width :\r\nDMA_SLAVE_BUSWIDTH_4_BYTES);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (src_burst < 0)\r\nreturn src_burst;\r\nif (src_width < 0)\r\nreturn src_width;\r\nif (dst_burst < 0)\r\nreturn dst_burst;\r\nif (dst_width < 0)\r\nreturn dst_width;\r\n*p_cfg = DMA_CHAN_CFG_SRC_BURST(src_burst) |\r\nDMA_CHAN_CFG_SRC_WIDTH(src_width) |\r\nDMA_CHAN_CFG_DST_BURST(dst_burst) |\r\nDMA_CHAN_CFG_DST_WIDTH(dst_width);\r\nreturn 0;\r\n}\r\nstatic struct dma_async_tx_descriptor *sun6i_dma_prep_dma_memcpy(\r\nstruct dma_chan *chan, dma_addr_t dest, dma_addr_t src,\r\nsize_t len, unsigned long flags)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct sun6i_dma_lli *v_lli;\r\nstruct sun6i_desc *txd;\r\ndma_addr_t p_lli;\r\ns8 burst, width;\r\ndev_dbg(chan2dev(chan),\r\n"%s; chan: %d, dest: %pad, src: %pad, len: %zu. flags: 0x%08lx\n",\r\n__func__, vchan->vc.chan.chan_id, &dest, &src, len, flags);\r\nif (!len)\r\nreturn NULL;\r\ntxd = kzalloc(sizeof(*txd), GFP_NOWAIT);\r\nif (!txd)\r\nreturn NULL;\r\nv_lli = dma_pool_alloc(sdev->pool, GFP_NOWAIT, &p_lli);\r\nif (!v_lli) {\r\ndev_err(sdev->slave.dev, "Failed to alloc lli memory\n");\r\ngoto err_txd_free;\r\n}\r\nv_lli->src = src;\r\nv_lli->dst = dest;\r\nv_lli->len = len;\r\nv_lli->para = NORMAL_WAIT;\r\nburst = convert_burst(8);\r\nwidth = convert_buswidth(DMA_SLAVE_BUSWIDTH_4_BYTES);\r\nv_lli->cfg = DMA_CHAN_CFG_SRC_DRQ(DRQ_SDRAM) |\r\nDMA_CHAN_CFG_DST_DRQ(DRQ_SDRAM) |\r\nDMA_CHAN_CFG_DST_LINEAR_MODE |\r\nDMA_CHAN_CFG_SRC_LINEAR_MODE |\r\nDMA_CHAN_CFG_SRC_BURST(burst) |\r\nDMA_CHAN_CFG_SRC_WIDTH(width) |\r\nDMA_CHAN_CFG_DST_BURST(burst) |\r\nDMA_CHAN_CFG_DST_WIDTH(width);\r\nsun6i_dma_lli_add(NULL, v_lli, p_lli, txd);\r\nsun6i_dma_dump_lli(vchan, v_lli);\r\nreturn vchan_tx_prep(&vchan->vc, &txd->vd, flags);\r\nerr_txd_free:\r\nkfree(txd);\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *sun6i_dma_prep_slave_sg(\r\nstruct dma_chan *chan, struct scatterlist *sgl,\r\nunsigned int sg_len, enum dma_transfer_direction dir,\r\nunsigned long flags, void *context)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct dma_slave_config *sconfig = &vchan->cfg;\r\nstruct sun6i_dma_lli *v_lli, *prev = NULL;\r\nstruct sun6i_desc *txd;\r\nstruct scatterlist *sg;\r\ndma_addr_t p_lli;\r\nu32 lli_cfg;\r\nint i, ret;\r\nif (!sgl)\r\nreturn NULL;\r\nret = set_config(sdev, sconfig, dir, &lli_cfg);\r\nif (ret) {\r\ndev_err(chan2dev(chan), "Invalid DMA configuration\n");\r\nreturn NULL;\r\n}\r\ntxd = kzalloc(sizeof(*txd), GFP_NOWAIT);\r\nif (!txd)\r\nreturn NULL;\r\nfor_each_sg(sgl, sg, sg_len, i) {\r\nv_lli = dma_pool_alloc(sdev->pool, GFP_NOWAIT, &p_lli);\r\nif (!v_lli)\r\ngoto err_lli_free;\r\nv_lli->len = sg_dma_len(sg);\r\nv_lli->para = NORMAL_WAIT;\r\nif (dir == DMA_MEM_TO_DEV) {\r\nv_lli->src = sg_dma_address(sg);\r\nv_lli->dst = sconfig->dst_addr;\r\nv_lli->cfg = lli_cfg |\r\nDMA_CHAN_CFG_DST_IO_MODE |\r\nDMA_CHAN_CFG_SRC_LINEAR_MODE |\r\nDMA_CHAN_CFG_SRC_DRQ(DRQ_SDRAM) |\r\nDMA_CHAN_CFG_DST_DRQ(vchan->port);\r\ndev_dbg(chan2dev(chan),\r\n"%s; chan: %d, dest: %pad, src: %pad, len: %u. flags: 0x%08lx\n",\r\n__func__, vchan->vc.chan.chan_id,\r\n&sconfig->dst_addr, &sg_dma_address(sg),\r\nsg_dma_len(sg), flags);\r\n} else {\r\nv_lli->src = sconfig->src_addr;\r\nv_lli->dst = sg_dma_address(sg);\r\nv_lli->cfg = lli_cfg |\r\nDMA_CHAN_CFG_DST_LINEAR_MODE |\r\nDMA_CHAN_CFG_SRC_IO_MODE |\r\nDMA_CHAN_CFG_DST_DRQ(DRQ_SDRAM) |\r\nDMA_CHAN_CFG_SRC_DRQ(vchan->port);\r\ndev_dbg(chan2dev(chan),\r\n"%s; chan: %d, dest: %pad, src: %pad, len: %u. flags: 0x%08lx\n",\r\n__func__, vchan->vc.chan.chan_id,\r\n&sg_dma_address(sg), &sconfig->src_addr,\r\nsg_dma_len(sg), flags);\r\n}\r\nprev = sun6i_dma_lli_add(prev, v_lli, p_lli, txd);\r\n}\r\ndev_dbg(chan2dev(chan), "First: %pad\n", &txd->p_lli);\r\nfor (prev = txd->v_lli; prev; prev = prev->v_lli_next)\r\nsun6i_dma_dump_lli(vchan, prev);\r\nreturn vchan_tx_prep(&vchan->vc, &txd->vd, flags);\r\nerr_lli_free:\r\nfor (prev = txd->v_lli; prev; prev = prev->v_lli_next)\r\ndma_pool_free(sdev->pool, prev, virt_to_phys(prev));\r\nkfree(txd);\r\nreturn NULL;\r\n}\r\nstatic struct dma_async_tx_descriptor *sun6i_dma_prep_dma_cyclic(\r\nstruct dma_chan *chan,\r\ndma_addr_t buf_addr,\r\nsize_t buf_len,\r\nsize_t period_len,\r\nenum dma_transfer_direction dir,\r\nunsigned long flags)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct dma_slave_config *sconfig = &vchan->cfg;\r\nstruct sun6i_dma_lli *v_lli, *prev = NULL;\r\nstruct sun6i_desc *txd;\r\ndma_addr_t p_lli;\r\nu32 lli_cfg;\r\nunsigned int i, periods = buf_len / period_len;\r\nint ret;\r\nret = set_config(sdev, sconfig, dir, &lli_cfg);\r\nif (ret) {\r\ndev_err(chan2dev(chan), "Invalid DMA configuration\n");\r\nreturn NULL;\r\n}\r\ntxd = kzalloc(sizeof(*txd), GFP_NOWAIT);\r\nif (!txd)\r\nreturn NULL;\r\nfor (i = 0; i < periods; i++) {\r\nv_lli = dma_pool_alloc(sdev->pool, GFP_NOWAIT, &p_lli);\r\nif (!v_lli) {\r\ndev_err(sdev->slave.dev, "Failed to alloc lli memory\n");\r\ngoto err_lli_free;\r\n}\r\nv_lli->len = period_len;\r\nv_lli->para = NORMAL_WAIT;\r\nif (dir == DMA_MEM_TO_DEV) {\r\nv_lli->src = buf_addr + period_len * i;\r\nv_lli->dst = sconfig->dst_addr;\r\nv_lli->cfg = lli_cfg |\r\nDMA_CHAN_CFG_DST_IO_MODE |\r\nDMA_CHAN_CFG_SRC_LINEAR_MODE |\r\nDMA_CHAN_CFG_SRC_DRQ(DRQ_SDRAM) |\r\nDMA_CHAN_CFG_DST_DRQ(vchan->port);\r\n} else {\r\nv_lli->src = sconfig->src_addr;\r\nv_lli->dst = buf_addr + period_len * i;\r\nv_lli->cfg = lli_cfg |\r\nDMA_CHAN_CFG_DST_LINEAR_MODE |\r\nDMA_CHAN_CFG_SRC_IO_MODE |\r\nDMA_CHAN_CFG_DST_DRQ(DRQ_SDRAM) |\r\nDMA_CHAN_CFG_SRC_DRQ(vchan->port);\r\n}\r\nprev = sun6i_dma_lli_add(prev, v_lli, p_lli, txd);\r\n}\r\nprev->p_lli_next = txd->p_lli;\r\nvchan->cyclic = true;\r\nreturn vchan_tx_prep(&vchan->vc, &txd->vd, flags);\r\nerr_lli_free:\r\nfor (prev = txd->v_lli; prev; prev = prev->v_lli_next)\r\ndma_pool_free(sdev->pool, prev, virt_to_phys(prev));\r\nkfree(txd);\r\nreturn NULL;\r\n}\r\nstatic int sun6i_dma_config(struct dma_chan *chan,\r\nstruct dma_slave_config *config)\r\n{\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nmemcpy(&vchan->cfg, config, sizeof(*config));\r\nreturn 0;\r\n}\r\nstatic int sun6i_dma_pause(struct dma_chan *chan)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct sun6i_pchan *pchan = vchan->phy;\r\ndev_dbg(chan2dev(chan), "vchan %p: pause\n", &vchan->vc);\r\nif (pchan) {\r\nwritel(DMA_CHAN_PAUSE_PAUSE,\r\npchan->base + DMA_CHAN_PAUSE);\r\n} else {\r\nspin_lock(&sdev->lock);\r\nlist_del_init(&vchan->node);\r\nspin_unlock(&sdev->lock);\r\n}\r\nreturn 0;\r\n}\r\nstatic int sun6i_dma_resume(struct dma_chan *chan)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct sun6i_pchan *pchan = vchan->phy;\r\nunsigned long flags;\r\ndev_dbg(chan2dev(chan), "vchan %p: resume\n", &vchan->vc);\r\nspin_lock_irqsave(&vchan->vc.lock, flags);\r\nif (pchan) {\r\nwritel(DMA_CHAN_PAUSE_RESUME,\r\npchan->base + DMA_CHAN_PAUSE);\r\n} else if (!list_empty(&vchan->vc.desc_issued)) {\r\nspin_lock(&sdev->lock);\r\nlist_add_tail(&vchan->node, &sdev->pending);\r\nspin_unlock(&sdev->lock);\r\n}\r\nspin_unlock_irqrestore(&vchan->vc.lock, flags);\r\nreturn 0;\r\n}\r\nstatic int sun6i_dma_terminate_all(struct dma_chan *chan)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct sun6i_pchan *pchan = vchan->phy;\r\nunsigned long flags;\r\nLIST_HEAD(head);\r\nspin_lock(&sdev->lock);\r\nlist_del_init(&vchan->node);\r\nspin_unlock(&sdev->lock);\r\nspin_lock_irqsave(&vchan->vc.lock, flags);\r\nif (vchan->cyclic) {\r\nvchan->cyclic = false;\r\nif (pchan && pchan->desc) {\r\nstruct virt_dma_desc *vd = &pchan->desc->vd;\r\nstruct virt_dma_chan *vc = &vchan->vc;\r\nlist_add_tail(&vd->node, &vc->desc_completed);\r\n}\r\n}\r\nvchan_get_all_descriptors(&vchan->vc, &head);\r\nif (pchan) {\r\nwritel(DMA_CHAN_ENABLE_STOP, pchan->base + DMA_CHAN_ENABLE);\r\nwritel(DMA_CHAN_PAUSE_RESUME, pchan->base + DMA_CHAN_PAUSE);\r\nvchan->phy = NULL;\r\npchan->vchan = NULL;\r\npchan->desc = NULL;\r\npchan->done = NULL;\r\n}\r\nspin_unlock_irqrestore(&vchan->vc.lock, flags);\r\nvchan_dma_desc_free_list(&vchan->vc, &head);\r\nreturn 0;\r\n}\r\nstatic enum dma_status sun6i_dma_tx_status(struct dma_chan *chan,\r\ndma_cookie_t cookie,\r\nstruct dma_tx_state *state)\r\n{\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nstruct sun6i_pchan *pchan = vchan->phy;\r\nstruct sun6i_dma_lli *lli;\r\nstruct virt_dma_desc *vd;\r\nstruct sun6i_desc *txd;\r\nenum dma_status ret;\r\nunsigned long flags;\r\nsize_t bytes = 0;\r\nret = dma_cookie_status(chan, cookie, state);\r\nif (ret == DMA_COMPLETE || !state)\r\nreturn ret;\r\nspin_lock_irqsave(&vchan->vc.lock, flags);\r\nvd = vchan_find_desc(&vchan->vc, cookie);\r\ntxd = to_sun6i_desc(&vd->tx);\r\nif (vd) {\r\nfor (lli = txd->v_lli; lli != NULL; lli = lli->v_lli_next)\r\nbytes += lli->len;\r\n} else if (!pchan || !pchan->desc) {\r\nbytes = 0;\r\n} else {\r\nbytes = sun6i_get_chan_size(pchan);\r\n}\r\nspin_unlock_irqrestore(&vchan->vc.lock, flags);\r\ndma_set_residue(state, bytes);\r\nreturn ret;\r\n}\r\nstatic void sun6i_dma_issue_pending(struct dma_chan *chan)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vchan->vc.lock, flags);\r\nif (vchan_issue_pending(&vchan->vc)) {\r\nspin_lock(&sdev->lock);\r\nif (!vchan->phy && list_empty(&vchan->node)) {\r\nlist_add_tail(&vchan->node, &sdev->pending);\r\ntasklet_schedule(&sdev->task);\r\ndev_dbg(chan2dev(chan), "vchan %p: issued\n",\r\n&vchan->vc);\r\n}\r\nspin_unlock(&sdev->lock);\r\n} else {\r\ndev_dbg(chan2dev(chan), "vchan %p: nothing to issue\n",\r\n&vchan->vc);\r\n}\r\nspin_unlock_irqrestore(&vchan->vc.lock, flags);\r\n}\r\nstatic void sun6i_dma_free_chan_resources(struct dma_chan *chan)\r\n{\r\nstruct sun6i_dma_dev *sdev = to_sun6i_dma_dev(chan->device);\r\nstruct sun6i_vchan *vchan = to_sun6i_vchan(chan);\r\nunsigned long flags;\r\nspin_lock_irqsave(&sdev->lock, flags);\r\nlist_del_init(&vchan->node);\r\nspin_unlock_irqrestore(&sdev->lock, flags);\r\nvchan_free_chan_resources(&vchan->vc);\r\n}\r\nstatic struct dma_chan *sun6i_dma_of_xlate(struct of_phandle_args *dma_spec,\r\nstruct of_dma *ofdma)\r\n{\r\nstruct sun6i_dma_dev *sdev = ofdma->of_dma_data;\r\nstruct sun6i_vchan *vchan;\r\nstruct dma_chan *chan;\r\nu8 port = dma_spec->args[0];\r\nif (port > sdev->cfg->nr_max_requests)\r\nreturn NULL;\r\nchan = dma_get_any_slave_channel(&sdev->slave);\r\nif (!chan)\r\nreturn NULL;\r\nvchan = to_sun6i_vchan(chan);\r\nvchan->port = port;\r\nreturn chan;\r\n}\r\nstatic inline void sun6i_kill_tasklet(struct sun6i_dma_dev *sdev)\r\n{\r\nwritel(0, sdev->base + DMA_IRQ_EN(0));\r\nwritel(0, sdev->base + DMA_IRQ_EN(1));\r\natomic_inc(&sdev->tasklet_shutdown);\r\ndevm_free_irq(sdev->slave.dev, sdev->irq, sdev);\r\ntasklet_kill(&sdev->task);\r\n}\r\nstatic inline void sun6i_dma_free(struct sun6i_dma_dev *sdev)\r\n{\r\nint i;\r\nfor (i = 0; i < sdev->cfg->nr_max_vchans; i++) {\r\nstruct sun6i_vchan *vchan = &sdev->vchans[i];\r\nlist_del(&vchan->vc.chan.device_node);\r\ntasklet_kill(&vchan->vc.task);\r\n}\r\n}\r\nstatic int sun6i_dma_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *device;\r\nstruct sun6i_dma_dev *sdc;\r\nstruct resource *res;\r\nint ret, i;\r\nsdc = devm_kzalloc(&pdev->dev, sizeof(*sdc), GFP_KERNEL);\r\nif (!sdc)\r\nreturn -ENOMEM;\r\ndevice = of_match_device(sun6i_dma_match, &pdev->dev);\r\nif (!device)\r\nreturn -ENODEV;\r\nsdc->cfg = device->data;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nsdc->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(sdc->base))\r\nreturn PTR_ERR(sdc->base);\r\nsdc->irq = platform_get_irq(pdev, 0);\r\nif (sdc->irq < 0) {\r\ndev_err(&pdev->dev, "Cannot claim IRQ\n");\r\nreturn sdc->irq;\r\n}\r\nsdc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sdc->clk)) {\r\ndev_err(&pdev->dev, "No clock specified\n");\r\nreturn PTR_ERR(sdc->clk);\r\n}\r\nsdc->rstc = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(sdc->rstc)) {\r\ndev_err(&pdev->dev, "No reset controller specified\n");\r\nreturn PTR_ERR(sdc->rstc);\r\n}\r\nsdc->pool = dmam_pool_create(dev_name(&pdev->dev), &pdev->dev,\r\nsizeof(struct sun6i_dma_lli), 4, 0);\r\nif (!sdc->pool) {\r\ndev_err(&pdev->dev, "No memory for descriptors dma pool\n");\r\nreturn -ENOMEM;\r\n}\r\nplatform_set_drvdata(pdev, sdc);\r\nINIT_LIST_HEAD(&sdc->pending);\r\nspin_lock_init(&sdc->lock);\r\ndma_cap_set(DMA_PRIVATE, sdc->slave.cap_mask);\r\ndma_cap_set(DMA_MEMCPY, sdc->slave.cap_mask);\r\ndma_cap_set(DMA_SLAVE, sdc->slave.cap_mask);\r\ndma_cap_set(DMA_CYCLIC, sdc->slave.cap_mask);\r\nINIT_LIST_HEAD(&sdc->slave.channels);\r\nsdc->slave.device_free_chan_resources = sun6i_dma_free_chan_resources;\r\nsdc->slave.device_tx_status = sun6i_dma_tx_status;\r\nsdc->slave.device_issue_pending = sun6i_dma_issue_pending;\r\nsdc->slave.device_prep_slave_sg = sun6i_dma_prep_slave_sg;\r\nsdc->slave.device_prep_dma_memcpy = sun6i_dma_prep_dma_memcpy;\r\nsdc->slave.device_prep_dma_cyclic = sun6i_dma_prep_dma_cyclic;\r\nsdc->slave.copy_align = DMAENGINE_ALIGN_4_BYTES;\r\nsdc->slave.device_config = sun6i_dma_config;\r\nsdc->slave.device_pause = sun6i_dma_pause;\r\nsdc->slave.device_resume = sun6i_dma_resume;\r\nsdc->slave.device_terminate_all = sun6i_dma_terminate_all;\r\nsdc->slave.src_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\r\nBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\r\nBIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\r\nsdc->slave.dst_addr_widths = BIT(DMA_SLAVE_BUSWIDTH_1_BYTE) |\r\nBIT(DMA_SLAVE_BUSWIDTH_2_BYTES) |\r\nBIT(DMA_SLAVE_BUSWIDTH_4_BYTES);\r\nsdc->slave.directions = BIT(DMA_DEV_TO_MEM) |\r\nBIT(DMA_MEM_TO_DEV);\r\nsdc->slave.residue_granularity = DMA_RESIDUE_GRANULARITY_BURST;\r\nsdc->slave.dev = &pdev->dev;\r\nsdc->pchans = devm_kcalloc(&pdev->dev, sdc->cfg->nr_max_channels,\r\nsizeof(struct sun6i_pchan), GFP_KERNEL);\r\nif (!sdc->pchans)\r\nreturn -ENOMEM;\r\nsdc->vchans = devm_kcalloc(&pdev->dev, sdc->cfg->nr_max_vchans,\r\nsizeof(struct sun6i_vchan), GFP_KERNEL);\r\nif (!sdc->vchans)\r\nreturn -ENOMEM;\r\ntasklet_init(&sdc->task, sun6i_dma_tasklet, (unsigned long)sdc);\r\nfor (i = 0; i < sdc->cfg->nr_max_channels; i++) {\r\nstruct sun6i_pchan *pchan = &sdc->pchans[i];\r\npchan->idx = i;\r\npchan->base = sdc->base + 0x100 + i * 0x40;\r\n}\r\nfor (i = 0; i < sdc->cfg->nr_max_vchans; i++) {\r\nstruct sun6i_vchan *vchan = &sdc->vchans[i];\r\nINIT_LIST_HEAD(&vchan->node);\r\nvchan->vc.desc_free = sun6i_dma_free_desc;\r\nvchan_init(&vchan->vc, &sdc->slave);\r\n}\r\nret = reset_control_deassert(sdc->rstc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't deassert the device from reset\n");\r\ngoto err_chan_free;\r\n}\r\nret = clk_prepare_enable(sdc->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Couldn't enable the clock\n");\r\ngoto err_reset_assert;\r\n}\r\nret = devm_request_irq(&pdev->dev, sdc->irq, sun6i_dma_interrupt, 0,\r\ndev_name(&pdev->dev), sdc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Cannot request IRQ\n");\r\ngoto err_clk_disable;\r\n}\r\nret = dma_async_device_register(&sdc->slave);\r\nif (ret) {\r\ndev_warn(&pdev->dev, "Failed to register DMA engine device\n");\r\ngoto err_irq_disable;\r\n}\r\nret = of_dma_controller_register(pdev->dev.of_node, sun6i_dma_of_xlate,\r\nsdc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "of_dma_controller_register failed\n");\r\ngoto err_dma_unregister;\r\n}\r\nif (of_device_is_compatible(pdev->dev.of_node,\r\n"allwinner,sun8i-a23-dma"))\r\nwritel(SUN8I_DMA_GATE_ENABLE, sdc->base + SUN8I_DMA_GATE);\r\nreturn 0;\r\nerr_dma_unregister:\r\ndma_async_device_unregister(&sdc->slave);\r\nerr_irq_disable:\r\nsun6i_kill_tasklet(sdc);\r\nerr_clk_disable:\r\nclk_disable_unprepare(sdc->clk);\r\nerr_reset_assert:\r\nreset_control_assert(sdc->rstc);\r\nerr_chan_free:\r\nsun6i_dma_free(sdc);\r\nreturn ret;\r\n}\r\nstatic int sun6i_dma_remove(struct platform_device *pdev)\r\n{\r\nstruct sun6i_dma_dev *sdc = platform_get_drvdata(pdev);\r\nof_dma_controller_free(pdev->dev.of_node);\r\ndma_async_device_unregister(&sdc->slave);\r\nsun6i_kill_tasklet(sdc);\r\nclk_disable_unprepare(sdc->clk);\r\nreset_control_assert(sdc->rstc);\r\nsun6i_dma_free(sdc);\r\nreturn 0;\r\n}
