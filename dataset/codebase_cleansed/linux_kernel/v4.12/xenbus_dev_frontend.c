static ssize_t xenbus_file_read(struct file *filp,\r\nchar __user *ubuf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct xenbus_file_priv *u = filp->private_data;\r\nstruct read_buffer *rb;\r\nunsigned i;\r\nint ret;\r\nmutex_lock(&u->reply_mutex);\r\nagain:\r\nwhile (list_empty(&u->read_buffers)) {\r\nmutex_unlock(&u->reply_mutex);\r\nif (filp->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nret = wait_event_interruptible(u->read_waitq,\r\n!list_empty(&u->read_buffers));\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&u->reply_mutex);\r\n}\r\nrb = list_entry(u->read_buffers.next, struct read_buffer, list);\r\ni = 0;\r\nwhile (i < len) {\r\nunsigned sz = min((unsigned)len - i, rb->len - rb->cons);\r\nret = copy_to_user(ubuf + i, &rb->msg[rb->cons], sz);\r\ni += sz - ret;\r\nrb->cons += sz - ret;\r\nif (ret != 0) {\r\nif (i == 0)\r\ni = -EFAULT;\r\ngoto out;\r\n}\r\nif (rb->cons == rb->len) {\r\nlist_del(&rb->list);\r\nkfree(rb);\r\nif (list_empty(&u->read_buffers))\r\nbreak;\r\nrb = list_entry(u->read_buffers.next,\r\nstruct read_buffer, list);\r\n}\r\n}\r\nif (i == 0)\r\ngoto again;\r\nout:\r\nmutex_unlock(&u->reply_mutex);\r\nreturn i;\r\n}\r\nstatic int queue_reply(struct list_head *queue, const void *data, size_t len)\r\n{\r\nstruct read_buffer *rb;\r\nif (len == 0)\r\nreturn 0;\r\nif (len > XENSTORE_PAYLOAD_MAX)\r\nreturn -EINVAL;\r\nrb = kmalloc(sizeof(*rb) + len, GFP_KERNEL);\r\nif (rb == NULL)\r\nreturn -ENOMEM;\r\nrb->cons = 0;\r\nrb->len = len;\r\nmemcpy(rb->msg, data, len);\r\nlist_add_tail(&rb->list, queue);\r\nreturn 0;\r\n}\r\nstatic void queue_cleanup(struct list_head *list)\r\n{\r\nstruct read_buffer *rb;\r\nwhile (!list_empty(list)) {\r\nrb = list_entry(list->next, struct read_buffer, list);\r\nlist_del(list->next);\r\nkfree(rb);\r\n}\r\n}\r\nstatic void free_watch_adapter(struct watch_adapter *watch)\r\n{\r\nkfree(watch->watch.node);\r\nkfree(watch->token);\r\nkfree(watch);\r\n}\r\nstatic struct watch_adapter *alloc_watch_adapter(const char *path,\r\nconst char *token)\r\n{\r\nstruct watch_adapter *watch;\r\nwatch = kzalloc(sizeof(*watch), GFP_KERNEL);\r\nif (watch == NULL)\r\ngoto out_fail;\r\nwatch->watch.node = kstrdup(path, GFP_KERNEL);\r\nif (watch->watch.node == NULL)\r\ngoto out_free;\r\nwatch->token = kstrdup(token, GFP_KERNEL);\r\nif (watch->token == NULL)\r\ngoto out_free;\r\nreturn watch;\r\nout_free:\r\nfree_watch_adapter(watch);\r\nout_fail:\r\nreturn NULL;\r\n}\r\nstatic void watch_fired(struct xenbus_watch *watch,\r\nconst char *path,\r\nconst char *token)\r\n{\r\nstruct watch_adapter *adap;\r\nstruct xsd_sockmsg hdr;\r\nconst char *token_caller;\r\nint path_len, tok_len, body_len;\r\nint ret;\r\nLIST_HEAD(staging_q);\r\nadap = container_of(watch, struct watch_adapter, watch);\r\ntoken_caller = adap->token;\r\npath_len = strlen(path) + 1;\r\ntok_len = strlen(token_caller) + 1;\r\nbody_len = path_len + tok_len;\r\nhdr.type = XS_WATCH_EVENT;\r\nhdr.len = body_len;\r\nmutex_lock(&adap->dev_data->reply_mutex);\r\nret = queue_reply(&staging_q, &hdr, sizeof(hdr));\r\nif (!ret)\r\nret = queue_reply(&staging_q, path, path_len);\r\nif (!ret)\r\nret = queue_reply(&staging_q, token_caller, tok_len);\r\nif (!ret) {\r\nlist_splice_tail(&staging_q, &adap->dev_data->read_buffers);\r\nwake_up(&adap->dev_data->read_waitq);\r\n} else\r\nqueue_cleanup(&staging_q);\r\nmutex_unlock(&adap->dev_data->reply_mutex);\r\n}\r\nstatic void xenbus_file_free(struct kref *kref)\r\n{\r\nstruct xenbus_file_priv *u;\r\nstruct xenbus_transaction_holder *trans, *tmp;\r\nstruct watch_adapter *watch, *tmp_watch;\r\nstruct read_buffer *rb, *tmp_rb;\r\nu = container_of(kref, struct xenbus_file_priv, kref);\r\nlist_for_each_entry_safe(trans, tmp, &u->transactions, list) {\r\nxenbus_transaction_end(trans->handle, 1);\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n}\r\nlist_for_each_entry_safe(watch, tmp_watch, &u->watches, list) {\r\nunregister_xenbus_watch(&watch->watch);\r\nlist_del(&watch->list);\r\nfree_watch_adapter(watch);\r\n}\r\nlist_for_each_entry_safe(rb, tmp_rb, &u->read_buffers, list) {\r\nlist_del(&rb->list);\r\nkfree(rb);\r\n}\r\nkfree(u);\r\n}\r\nstatic struct xenbus_transaction_holder *xenbus_get_transaction(\r\nstruct xenbus_file_priv *u, uint32_t tx_id)\r\n{\r\nstruct xenbus_transaction_holder *trans;\r\nlist_for_each_entry(trans, &u->transactions, list)\r\nif (trans->handle.id == tx_id)\r\nreturn trans;\r\nreturn NULL;\r\n}\r\nvoid xenbus_dev_queue_reply(struct xb_req_data *req)\r\n{\r\nstruct xenbus_file_priv *u = req->par;\r\nstruct xenbus_transaction_holder *trans = NULL;\r\nint rc;\r\nLIST_HEAD(staging_q);\r\nxs_request_exit(req);\r\nmutex_lock(&u->msgbuffer_mutex);\r\nif (req->type == XS_TRANSACTION_START) {\r\ntrans = xenbus_get_transaction(u, 0);\r\nif (WARN_ON(!trans))\r\ngoto out;\r\nif (req->msg.type == XS_ERROR) {\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n} else {\r\nrc = kstrtou32(req->body, 10, &trans->handle.id);\r\nif (WARN_ON(rc))\r\ngoto out;\r\n}\r\n} else if (req->msg.type == XS_TRANSACTION_END) {\r\ntrans = xenbus_get_transaction(u, req->msg.tx_id);\r\nif (WARN_ON(!trans))\r\ngoto out;\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n}\r\nmutex_unlock(&u->msgbuffer_mutex);\r\nmutex_lock(&u->reply_mutex);\r\nrc = queue_reply(&staging_q, &req->msg, sizeof(req->msg));\r\nif (!rc)\r\nrc = queue_reply(&staging_q, req->body, req->msg.len);\r\nif (!rc) {\r\nlist_splice_tail(&staging_q, &u->read_buffers);\r\nwake_up(&u->read_waitq);\r\n} else {\r\nqueue_cleanup(&staging_q);\r\n}\r\nmutex_unlock(&u->reply_mutex);\r\nkfree(req->body);\r\nkfree(req);\r\nkref_put(&u->kref, xenbus_file_free);\r\nreturn;\r\nout:\r\nmutex_unlock(&u->msgbuffer_mutex);\r\n}\r\nstatic int xenbus_command_reply(struct xenbus_file_priv *u,\r\nunsigned int msg_type, const char *reply)\r\n{\r\nstruct {\r\nstruct xsd_sockmsg hdr;\r\nconst char body[16];\r\n} msg;\r\nint rc;\r\nmsg.hdr = u->u.msg;\r\nmsg.hdr.type = msg_type;\r\nmsg.hdr.len = strlen(reply) + 1;\r\nif (msg.hdr.len > sizeof(msg.body))\r\nreturn -E2BIG;\r\nmutex_lock(&u->reply_mutex);\r\nrc = queue_reply(&u->read_buffers, &msg, sizeof(msg.hdr) + msg.hdr.len);\r\nwake_up(&u->read_waitq);\r\nmutex_unlock(&u->reply_mutex);\r\nif (!rc)\r\nkref_put(&u->kref, xenbus_file_free);\r\nreturn rc;\r\n}\r\nstatic int xenbus_write_transaction(unsigned msg_type,\r\nstruct xenbus_file_priv *u)\r\n{\r\nint rc;\r\nstruct xenbus_transaction_holder *trans = NULL;\r\nif (msg_type == XS_TRANSACTION_START) {\r\ntrans = kzalloc(sizeof(*trans), GFP_KERNEL);\r\nif (!trans) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nlist_add(&trans->list, &u->transactions);\r\n} else if (u->u.msg.tx_id != 0 &&\r\n!xenbus_get_transaction(u, u->u.msg.tx_id))\r\nreturn xenbus_command_reply(u, XS_ERROR, "ENOENT");\r\nrc = xenbus_dev_request_and_reply(&u->u.msg, u);\r\nif (rc && trans) {\r\nlist_del(&trans->list);\r\nkfree(trans);\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int xenbus_write_watch(unsigned msg_type, struct xenbus_file_priv *u)\r\n{\r\nstruct watch_adapter *watch;\r\nchar *path, *token;\r\nint err, rc;\r\nLIST_HEAD(staging_q);\r\npath = u->u.buffer + sizeof(u->u.msg);\r\ntoken = memchr(path, 0, u->u.msg.len);\r\nif (token == NULL) {\r\nrc = xenbus_command_reply(u, XS_ERROR, "EINVAL");\r\ngoto out;\r\n}\r\ntoken++;\r\nif (memchr(token, 0, u->u.msg.len - (token - path)) == NULL) {\r\nrc = xenbus_command_reply(u, XS_ERROR, "EINVAL");\r\ngoto out;\r\n}\r\nif (msg_type == XS_WATCH) {\r\nwatch = alloc_watch_adapter(path, token);\r\nif (watch == NULL) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nwatch->watch.callback = watch_fired;\r\nwatch->dev_data = u;\r\nerr = register_xenbus_watch(&watch->watch);\r\nif (err) {\r\nfree_watch_adapter(watch);\r\nrc = err;\r\ngoto out;\r\n}\r\nlist_add(&watch->list, &u->watches);\r\n} else {\r\nlist_for_each_entry(watch, &u->watches, list) {\r\nif (!strcmp(watch->token, token) &&\r\n!strcmp(watch->watch.node, path)) {\r\nunregister_xenbus_watch(&watch->watch);\r\nlist_del(&watch->list);\r\nfree_watch_adapter(watch);\r\nbreak;\r\n}\r\n}\r\n}\r\nrc = xenbus_command_reply(u, msg_type, "OK");\r\nout:\r\nreturn rc;\r\n}\r\nstatic ssize_t xenbus_file_write(struct file *filp,\r\nconst char __user *ubuf,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct xenbus_file_priv *u = filp->private_data;\r\nuint32_t msg_type;\r\nint rc = len;\r\nint ret;\r\nLIST_HEAD(staging_q);\r\nmutex_lock(&u->msgbuffer_mutex);\r\nif (len == 0)\r\ngoto out;\r\nif (len > sizeof(u->u.buffer) - u->len) {\r\nu->len = 0;\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nret = copy_from_user(u->u.buffer + u->len, ubuf, len);\r\nif (ret != 0) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nlen -= ret;\r\nrc = len;\r\nu->len += len;\r\nif (u->len < sizeof(u->u.msg))\r\ngoto out;\r\nif ((sizeof(u->u.msg) + u->u.msg.len) > sizeof(u->u.buffer)) {\r\nrc = -E2BIG;\r\nu->len = 0;\r\ngoto out;\r\n}\r\nif (u->len < (sizeof(u->u.msg) + u->u.msg.len))\r\ngoto out;\r\nkref_get(&u->kref);\r\nmsg_type = u->u.msg.type;\r\nswitch (msg_type) {\r\ncase XS_WATCH:\r\ncase XS_UNWATCH:\r\nret = xenbus_write_watch(msg_type, u);\r\nbreak;\r\ndefault:\r\nret = xenbus_write_transaction(msg_type, u);\r\nbreak;\r\n}\r\nif (ret != 0) {\r\nrc = ret;\r\nkref_put(&u->kref, xenbus_file_free);\r\n}\r\nu->len = 0;\r\nout:\r\nmutex_unlock(&u->msgbuffer_mutex);\r\nreturn rc;\r\n}\r\nstatic int xenbus_file_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct xenbus_file_priv *u;\r\nif (xen_store_evtchn == 0)\r\nreturn -ENOENT;\r\nnonseekable_open(inode, filp);\r\nfilp->f_mode &= ~FMODE_ATOMIC_POS;\r\nu = kzalloc(sizeof(*u), GFP_KERNEL);\r\nif (u == NULL)\r\nreturn -ENOMEM;\r\nkref_init(&u->kref);\r\nINIT_LIST_HEAD(&u->transactions);\r\nINIT_LIST_HEAD(&u->watches);\r\nINIT_LIST_HEAD(&u->read_buffers);\r\ninit_waitqueue_head(&u->read_waitq);\r\nmutex_init(&u->reply_mutex);\r\nmutex_init(&u->msgbuffer_mutex);\r\nfilp->private_data = u;\r\nreturn 0;\r\n}\r\nstatic int xenbus_file_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct xenbus_file_priv *u = filp->private_data;\r\nkref_put(&u->kref, xenbus_file_free);\r\nreturn 0;\r\n}\r\nstatic unsigned int xenbus_file_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct xenbus_file_priv *u = file->private_data;\r\npoll_wait(file, &u->read_waitq, wait);\r\nif (!list_empty(&u->read_buffers))\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}\r\nstatic int __init xenbus_init(void)\r\n{\r\nint err;\r\nif (!xen_domain())\r\nreturn -ENODEV;\r\nerr = misc_register(&xenbus_dev);\r\nif (err)\r\npr_err("Could not register xenbus frontend device\n");\r\nreturn err;\r\n}
