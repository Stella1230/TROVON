static int syscon_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\r\nunsigned int val, offs;\r\nint ret;\r\noffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\r\nret = regmap_read(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE, &val);\r\nif (ret)\r\nreturn ret;\r\nreturn !!(val & BIT(offs % SYSCON_REG_BITS));\r\n}\r\nstatic void syscon_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\r\nunsigned int offs;\r\noffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\r\nregmap_update_bits(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS),\r\nval ? BIT(offs % SYSCON_REG_BITS) : 0);\r\n}\r\nstatic int syscon_gpio_dir_in(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_DIR) {\r\nunsigned int offs;\r\noffs = priv->dir_reg_offset +\r\npriv->data->dir_bit_offset + offset;\r\nregmap_update_bits(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS), 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int syscon_gpio_dir_out(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_DIR) {\r\nunsigned int offs;\r\noffs = priv->dir_reg_offset +\r\npriv->data->dir_bit_offset + offset;\r\nregmap_update_bits(priv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS),\r\nBIT(offs % SYSCON_REG_BITS));\r\n}\r\npriv->data->set(chip, offset, val);\r\nreturn 0;\r\n}\r\nstatic void keystone_gpio_set(struct gpio_chip *chip, unsigned offset, int val)\r\n{\r\nstruct syscon_gpio_priv *priv = gpiochip_get_data(chip);\r\nunsigned int offs;\r\nint ret;\r\noffs = priv->dreg_offset + priv->data->dat_bit_offset + offset;\r\nif (!val)\r\nreturn;\r\nret = regmap_update_bits(\r\npriv->syscon,\r\n(offs / SYSCON_REG_BITS) * SYSCON_REG_SIZE,\r\nBIT(offs % SYSCON_REG_BITS) | KEYSTONE_LOCK_BIT,\r\nBIT(offs % SYSCON_REG_BITS) | KEYSTONE_LOCK_BIT);\r\nif (ret < 0)\r\ndev_err(chip->parent, "gpio write failed ret(%d)\n", ret);\r\n}\r\nstatic int syscon_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct of_device_id *of_id;\r\nstruct syscon_gpio_priv *priv;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\nof_id = of_match_device(syscon_gpio_ids, dev);\r\nif (!of_id)\r\nreturn -ENODEV;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->data = of_id->data;\r\nif (priv->data->compatible) {\r\npriv->syscon = syscon_regmap_lookup_by_compatible(\r\npriv->data->compatible);\r\nif (IS_ERR(priv->syscon))\r\nreturn PTR_ERR(priv->syscon);\r\n} else {\r\npriv->syscon =\r\nsyscon_regmap_lookup_by_phandle(np, "gpio,syscon-dev");\r\nif (IS_ERR(priv->syscon))\r\nreturn PTR_ERR(priv->syscon);\r\nret = of_property_read_u32_index(np, "gpio,syscon-dev", 1,\r\n&priv->dreg_offset);\r\nif (ret)\r\ndev_err(dev, "can't read the data register offset!\n");\r\npriv->dreg_offset <<= 3;\r\nret = of_property_read_u32_index(np, "gpio,syscon-dev", 2,\r\n&priv->dir_reg_offset);\r\nif (ret)\r\ndev_dbg(dev, "can't read the dir register offset!\n");\r\npriv->dir_reg_offset <<= 3;\r\n}\r\npriv->chip.parent = dev;\r\npriv->chip.owner = THIS_MODULE;\r\npriv->chip.label = dev_name(dev);\r\npriv->chip.base = -1;\r\npriv->chip.ngpio = priv->data->bit_count;\r\npriv->chip.get = syscon_gpio_get;\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_IN)\r\npriv->chip.direction_input = syscon_gpio_dir_in;\r\nif (priv->data->flags & GPIO_SYSCON_FEAT_OUT) {\r\npriv->chip.set = priv->data->set ? : syscon_gpio_set;\r\npriv->chip.direction_output = syscon_gpio_dir_out;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn devm_gpiochip_add_data(&pdev->dev, &priv->chip, priv);\r\n}
