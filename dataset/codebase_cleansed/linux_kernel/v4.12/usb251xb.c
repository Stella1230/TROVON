static void usb251xb_reset(struct usb251xb *hub, int state)\r\n{\r\nif (!gpio_is_valid(hub->gpio_reset))\r\nreturn;\r\ngpio_set_value_cansleep(hub->gpio_reset, state);\r\nif (state)\r\nusleep_range(500, 750);\r\nelse\r\nusleep_range(1, 10);\r\n}\r\nstatic int usb251xb_connect(struct usb251xb *hub)\r\n{\r\nstruct device *dev = hub->dev;\r\nint err, i;\r\nchar i2c_wb[USB251XB_I2C_REG_SZ];\r\nmemset(i2c_wb, 0, USB251XB_I2C_REG_SZ);\r\nif (hub->skip_config) {\r\ndev_info(dev, "Skip hub configuration, only attach.\n");\r\ni2c_wb[0] = 0x01;\r\ni2c_wb[1] = USB251XB_STATUS_COMMAND_ATTACH;\r\nusb251xb_reset(hub, 1);\r\nerr = i2c_smbus_write_i2c_block_data(hub->i2c,\r\nUSB251XB_ADDR_STATUS_COMMAND, 2, i2c_wb);\r\nif (err) {\r\ndev_err(dev, "attaching hub failed: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\ni2c_wb[USB251XB_ADDR_VENDOR_ID_MSB] = (hub->vendor_id >> 8) & 0xFF;\r\ni2c_wb[USB251XB_ADDR_VENDOR_ID_LSB] = hub->vendor_id & 0xFF;\r\ni2c_wb[USB251XB_ADDR_PRODUCT_ID_MSB] = (hub->product_id >> 8) & 0xFF;\r\ni2c_wb[USB251XB_ADDR_PRODUCT_ID_LSB] = hub->product_id & 0xFF;\r\ni2c_wb[USB251XB_ADDR_DEVICE_ID_MSB] = (hub->device_id >> 8) & 0xFF;\r\ni2c_wb[USB251XB_ADDR_DEVICE_ID_LSB] = hub->device_id & 0xFF;\r\ni2c_wb[USB251XB_ADDR_CONFIG_DATA_1] = hub->conf_data1;\r\ni2c_wb[USB251XB_ADDR_CONFIG_DATA_2] = hub->conf_data2;\r\ni2c_wb[USB251XB_ADDR_CONFIG_DATA_3] = hub->conf_data3;\r\ni2c_wb[USB251XB_ADDR_NON_REMOVABLE_DEVICES] = hub->non_rem_dev;\r\ni2c_wb[USB251XB_ADDR_PORT_DISABLE_SELF] = hub->port_disable_sp;\r\ni2c_wb[USB251XB_ADDR_PORT_DISABLE_BUS] = hub->port_disable_bp;\r\ni2c_wb[USB251XB_ADDR_MAX_POWER_SELF] = hub->max_power_sp;\r\ni2c_wb[USB251XB_ADDR_MAX_POWER_BUS] = hub->max_power_bp;\r\ni2c_wb[USB251XB_ADDR_MAX_CURRENT_SELF] = hub->max_current_sp;\r\ni2c_wb[USB251XB_ADDR_MAX_CURRENT_BUS] = hub->max_current_bp;\r\ni2c_wb[USB251XB_ADDR_POWER_ON_TIME] = hub->power_on_time;\r\ni2c_wb[USB251XB_ADDR_LANGUAGE_ID_HIGH] = (hub->lang_id >> 8) & 0xFF;\r\ni2c_wb[USB251XB_ADDR_LANGUAGE_ID_LOW] = hub->lang_id & 0xFF;\r\ni2c_wb[USB251XB_ADDR_MANUFACTURER_STRING_LEN] = hub->manufacturer_len;\r\ni2c_wb[USB251XB_ADDR_PRODUCT_STRING_LEN] = hub->product_len;\r\ni2c_wb[USB251XB_ADDR_SERIAL_STRING_LEN] = hub->serial_len;\r\nmemcpy(&i2c_wb[USB251XB_ADDR_MANUFACTURER_STRING], hub->manufacturer,\r\nUSB251XB_STRING_BUFSIZE);\r\nmemcpy(&i2c_wb[USB251XB_ADDR_SERIAL_STRING], hub->serial,\r\nUSB251XB_STRING_BUFSIZE);\r\nmemcpy(&i2c_wb[USB251XB_ADDR_PRODUCT_STRING], hub->product,\r\nUSB251XB_STRING_BUFSIZE);\r\ni2c_wb[USB251XB_ADDR_BATTERY_CHARGING_ENABLE] = hub->bat_charge_en;\r\ni2c_wb[USB251XB_ADDR_BOOST_UP] = hub->boost_up;\r\ni2c_wb[USB251XB_ADDR_BOOST_X] = hub->boost_x;\r\ni2c_wb[USB251XB_ADDR_PORT_SWAP] = hub->port_swap;\r\ni2c_wb[USB251XB_ADDR_PORT_MAP_12] = hub->port_map12;\r\ni2c_wb[USB251XB_ADDR_PORT_MAP_34] = hub->port_map34;\r\ni2c_wb[USB251XB_ADDR_STATUS_COMMAND] = USB251XB_STATUS_COMMAND_ATTACH;\r\nusb251xb_reset(hub, 1);\r\nfor (i = 0; i < (USB251XB_I2C_REG_SZ / USB251XB_I2C_WRITE_SZ); i++) {\r\nint offset = i * USB251XB_I2C_WRITE_SZ;\r\nchar wbuf[USB251XB_I2C_WRITE_SZ + 1];\r\nwbuf[0] = USB251XB_I2C_WRITE_SZ;\r\nmemcpy(&wbuf[1], &i2c_wb[offset], USB251XB_I2C_WRITE_SZ);\r\ndev_dbg(dev, "writing %d byte block %d to 0x%02X\n",\r\nUSB251XB_I2C_WRITE_SZ, i, offset);\r\nerr = i2c_smbus_write_i2c_block_data(hub->i2c, offset,\r\nUSB251XB_I2C_WRITE_SZ + 1,\r\nwbuf);\r\nif (err)\r\ngoto out_err;\r\n}\r\ndev_info(dev, "Hub configuration was successful.\n");\r\nreturn 0;\r\nout_err:\r\ndev_err(dev, "configuring block %d failed: %d\n", i, err);\r\nreturn err;\r\n}\r\nstatic int usb251xb_get_ofdata(struct usb251xb *hub,\r\nstruct usb251xb_data *data)\r\n{\r\nstruct device *dev = hub->dev;\r\nstruct device_node *np = dev->of_node;\r\nint len, err, i;\r\nu32 *property_u32 = NULL;\r\nconst u32 *cproperty_u32;\r\nconst char *cproperty_char;\r\nchar str[USB251XB_STRING_BUFSIZE / 2];\r\nif (!np) {\r\ndev_err(dev, "failed to get ofdata\n");\r\nreturn -ENODEV;\r\n}\r\nif (of_get_property(np, "skip-config", NULL))\r\nhub->skip_config = 1;\r\nelse\r\nhub->skip_config = 0;\r\nhub->gpio_reset = of_get_named_gpio(np, "reset-gpios", 0);\r\nif (hub->gpio_reset == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (gpio_is_valid(hub->gpio_reset)) {\r\nerr = devm_gpio_request_one(dev, hub->gpio_reset,\r\nGPIOF_OUT_INIT_LOW,\r\n"usb251xb reset");\r\nif (err) {\r\ndev_err(dev,\r\n"unable to request GPIO %d as reset pin (%d)\n",\r\nhub->gpio_reset, err);\r\nreturn err;\r\n}\r\n}\r\nif (of_property_read_u16_array(np, "vendor-id", &hub->vendor_id, 1))\r\nhub->vendor_id = USB251XB_DEF_VENDOR_ID;\r\nif (of_property_read_u16_array(np, "product-id",\r\n&hub->product_id, 1))\r\nhub->product_id = data->product_id;\r\nif (of_property_read_u16_array(np, "device-id", &hub->device_id, 1))\r\nhub->device_id = USB251XB_DEF_DEVICE_ID;\r\nhub->conf_data1 = USB251XB_DEF_CONFIG_DATA_1;\r\nif (of_get_property(np, "self-powered", NULL)) {\r\nhub->conf_data1 |= BIT(7);\r\nhub->conf_data1 &= ~BIT(2);\r\nif (of_get_property(np, "ganged-sensing", NULL))\r\nhub->conf_data1 &= ~BIT(1);\r\nelse if (of_get_property(np, "individual-sensing", NULL))\r\nhub->conf_data1 |= BIT(1);\r\n} else if (of_get_property(np, "bus-powered", NULL)) {\r\nhub->conf_data1 &= ~BIT(7);\r\nhub->conf_data1 |= BIT(2);\r\n}\r\nif (of_get_property(np, "disable-hi-speed", NULL))\r\nhub->conf_data1 |= BIT(5);\r\nif (of_get_property(np, "multi-tt", NULL))\r\nhub->conf_data1 |= BIT(4);\r\nelse if (of_get_property(np, "single-tt", NULL))\r\nhub->conf_data1 &= ~BIT(4);\r\nif (of_get_property(np, "disable-eop", NULL))\r\nhub->conf_data1 |= BIT(3);\r\nif (of_get_property(np, "individual-port-switching", NULL))\r\nhub->conf_data1 |= BIT(0);\r\nelse if (of_get_property(np, "ganged-port-switching", NULL))\r\nhub->conf_data1 &= ~BIT(0);\r\nhub->conf_data2 = USB251XB_DEF_CONFIG_DATA_2;\r\nif (of_get_property(np, "dynamic-power-switching", NULL))\r\nhub->conf_data2 |= BIT(7);\r\nif (!of_property_read_u32(np, "oc-delay-us", property_u32)) {\r\nif (*property_u32 == 100) {\r\nhub->conf_data2 &= ~BIT(5);\r\nhub->conf_data2 &= ~BIT(4);\r\n} else if (*property_u32 == 4000) {\r\nhub->conf_data2 &= ~BIT(5);\r\nhub->conf_data2 |= BIT(4);\r\n} else if (*property_u32 == 16000) {\r\nhub->conf_data2 |= BIT(5);\r\nhub->conf_data2 |= BIT(4);\r\n} else {\r\nhub->conf_data2 |= BIT(5);\r\nhub->conf_data2 &= ~BIT(4);\r\n}\r\n}\r\nif (of_get_property(np, "compound-device", NULL))\r\nhub->conf_data2 |= BIT(3);\r\nhub->conf_data3 = USB251XB_DEF_CONFIG_DATA_3;\r\nif (of_get_property(np, "port-mapping-mode", NULL))\r\nhub->conf_data3 |= BIT(3);\r\nif (of_get_property(np, "string-support", NULL))\r\nhub->conf_data3 |= BIT(0);\r\nhub->non_rem_dev = USB251XB_DEF_NON_REMOVABLE_DEVICES;\r\ncproperty_u32 = of_get_property(np, "non-removable-ports", &len);\r\nif (cproperty_u32 && (len / sizeof(u32)) > 0) {\r\nfor (i = 0; i < len / sizeof(u32); i++) {\r\nu32 port = be32_to_cpu(cproperty_u32[i]);\r\nif ((port >= 1) && (port <= 4))\r\nhub->non_rem_dev |= BIT(port);\r\n}\r\n}\r\nhub->port_disable_sp = USB251XB_DEF_PORT_DISABLE_SELF;\r\ncproperty_u32 = of_get_property(np, "sp-disabled-ports", &len);\r\nif (cproperty_u32 && (len / sizeof(u32)) > 0) {\r\nfor (i = 0; i < len / sizeof(u32); i++) {\r\nu32 port = be32_to_cpu(cproperty_u32[i]);\r\nif ((port >= 1) && (port <= 4))\r\nhub->port_disable_sp |= BIT(port);\r\n}\r\n}\r\nhub->port_disable_bp = USB251XB_DEF_PORT_DISABLE_BUS;\r\ncproperty_u32 = of_get_property(np, "bp-disabled-ports", &len);\r\nif (cproperty_u32 && (len / sizeof(u32)) > 0) {\r\nfor (i = 0; i < len / sizeof(u32); i++) {\r\nu32 port = be32_to_cpu(cproperty_u32[i]);\r\nif ((port >= 1) && (port <= 4))\r\nhub->port_disable_bp |= BIT(port);\r\n}\r\n}\r\nhub->power_on_time = USB251XB_DEF_POWER_ON_TIME;\r\nif (!of_property_read_u32(np, "power-on-time-ms", property_u32))\r\nhub->power_on_time = min_t(u8, *property_u32 / 2, 255);\r\nif (of_property_read_u16_array(np, "language-id", &hub->lang_id, 1))\r\nhub->lang_id = USB251XB_DEF_LANGUAGE_ID;\r\ncproperty_char = of_get_property(np, "manufacturer", NULL);\r\nstrlcpy(str, cproperty_char ? : USB251XB_DEF_MANUFACTURER_STRING,\r\nsizeof(str));\r\nhub->manufacturer_len = strlen(str) & 0xFF;\r\nmemset(hub->manufacturer, 0, USB251XB_STRING_BUFSIZE);\r\nlen = min_t(size_t, USB251XB_STRING_BUFSIZE / 2, strlen(str));\r\nlen = utf8s_to_utf16s(str, len, UTF16_LITTLE_ENDIAN,\r\n(wchar_t *)hub->manufacturer,\r\nUSB251XB_STRING_BUFSIZE);\r\ncproperty_char = of_get_property(np, "product", NULL);\r\nstrlcpy(str, cproperty_char ? : data->product_str, sizeof(str));\r\nhub->product_len = strlen(str) & 0xFF;\r\nmemset(hub->product, 0, USB251XB_STRING_BUFSIZE);\r\nlen = min_t(size_t, USB251XB_STRING_BUFSIZE / 2, strlen(str));\r\nlen = utf8s_to_utf16s(str, len, UTF16_LITTLE_ENDIAN,\r\n(wchar_t *)hub->product,\r\nUSB251XB_STRING_BUFSIZE);\r\ncproperty_char = of_get_property(np, "serial", NULL);\r\nstrlcpy(str, cproperty_char ? : USB251XB_DEF_SERIAL_STRING,\r\nsizeof(str));\r\nhub->serial_len = strlen(str) & 0xFF;\r\nmemset(hub->serial, 0, USB251XB_STRING_BUFSIZE);\r\nlen = min_t(size_t, USB251XB_STRING_BUFSIZE / 2, strlen(str));\r\nlen = utf8s_to_utf16s(str, len, UTF16_LITTLE_ENDIAN,\r\n(wchar_t *)hub->serial,\r\nUSB251XB_STRING_BUFSIZE);\r\nhub->max_power_sp = USB251XB_DEF_MAX_POWER_SELF;\r\nhub->max_power_bp = USB251XB_DEF_MAX_POWER_BUS;\r\nhub->max_current_sp = USB251XB_DEF_MAX_CURRENT_SELF;\r\nhub->max_current_bp = USB251XB_DEF_MAX_CURRENT_BUS;\r\nhub->bat_charge_en = USB251XB_DEF_BATTERY_CHARGING_ENABLE;\r\nhub->boost_up = USB251XB_DEF_BOOST_UP;\r\nhub->boost_x = USB251XB_DEF_BOOST_X;\r\nhub->port_swap = USB251XB_DEF_PORT_SWAP;\r\nhub->port_map12 = USB251XB_DEF_PORT_MAP_12;\r\nhub->port_map34 = USB251XB_DEF_PORT_MAP_34;\r\nreturn 0;\r\n}\r\nstatic int usb251xb_get_ofdata(struct usb251xb *hub,\r\nstruct usb251xb_data *data)\r\n{\r\nreturn 0;\r\n}\r\nstatic int usb251xb_probe(struct usb251xb *hub)\r\n{\r\nstruct device *dev = hub->dev;\r\nstruct device_node *np = dev->of_node;\r\nconst struct of_device_id *of_id = of_match_device(usb251xb_of_match,\r\ndev);\r\nint err;\r\nif (np) {\r\nerr = usb251xb_get_ofdata(hub,\r\n(struct usb251xb_data *)of_id->data);\r\nif (err) {\r\ndev_err(dev, "failed to get ofdata: %d\n", err);\r\nreturn err;\r\n}\r\n}\r\nerr = usb251xb_connect(hub);\r\nif (err) {\r\ndev_err(dev, "Failed to connect hub (%d)\n", err);\r\nreturn err;\r\n}\r\ndev_info(dev, "Hub probed successfully\n");\r\nreturn 0;\r\n}\r\nstatic int usb251xb_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct usb251xb *hub;\r\nhub = devm_kzalloc(&i2c->dev, sizeof(struct usb251xb), GFP_KERNEL);\r\nif (!hub)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, hub);\r\nhub->dev = &i2c->dev;\r\nhub->i2c = i2c;\r\nreturn usb251xb_probe(hub);\r\n}
