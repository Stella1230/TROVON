static struct emmaprp_fmt *find_format(struct v4l2_format *f)\r\n{\r\nstruct emmaprp_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < NUM_FORMATS; k++) {\r\nfmt = &formats[k];\r\nif (fmt->fourcc == f->fmt.pix.pixelformat)\r\nbreak;\r\n}\r\nif (k == NUM_FORMATS)\r\nreturn NULL;\r\nreturn &formats[k];\r\n}\r\nstatic struct emmaprp_q_data *get_q_data(struct emmaprp_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nswitch (type) {\r\ncase V4L2_BUF_TYPE_VIDEO_OUTPUT:\r\nreturn &(ctx->q_data[V4L2_M2M_SRC]);\r\ncase V4L2_BUF_TYPE_VIDEO_CAPTURE:\r\nreturn &(ctx->q_data[V4L2_M2M_DST]);\r\ndefault:\r\nBUG();\r\n}\r\nreturn NULL;\r\n}\r\nstatic void emmaprp_job_abort(void *priv)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nstruct emmaprp_dev *pcdev = ctx->dev;\r\nctx->aborting = 1;\r\ndprintk(pcdev, "Aborting task\n");\r\nv4l2_m2m_job_finish(pcdev->m2m_dev, ctx->m2m_ctx);\r\n}\r\nstatic void emmaprp_lock(void *priv)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nstruct emmaprp_dev *pcdev = ctx->dev;\r\nmutex_lock(&pcdev->dev_mutex);\r\n}\r\nstatic void emmaprp_unlock(void *priv)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nstruct emmaprp_dev *pcdev = ctx->dev;\r\nmutex_unlock(&pcdev->dev_mutex);\r\n}\r\nstatic inline void emmaprp_dump_regs(struct emmaprp_dev *pcdev)\r\n{\r\ndprintk(pcdev,\r\n"eMMa-PrP Registers:\n"\r\n" SOURCE_Y_PTR = 0x%08X\n"\r\n" SRC_FRAME_SIZE = 0x%08X\n"\r\n" DEST_Y_PTR = 0x%08X\n"\r\n" DEST_CR_PTR = 0x%08X\n"\r\n" DEST_CB_PTR = 0x%08X\n"\r\n" CH2_OUT_IMAGE_SIZE = 0x%08X\n"\r\n" CNTL = 0x%08X\n",\r\nreadl(pcdev->base_emma + PRP_SOURCE_Y_PTR),\r\nreadl(pcdev->base_emma + PRP_SRC_FRAME_SIZE),\r\nreadl(pcdev->base_emma + PRP_DEST_Y_PTR),\r\nreadl(pcdev->base_emma + PRP_DEST_CR_PTR),\r\nreadl(pcdev->base_emma + PRP_DEST_CB_PTR),\r\nreadl(pcdev->base_emma + PRP_CH2_OUT_IMAGE_SIZE),\r\nreadl(pcdev->base_emma + PRP_CNTL));\r\n}\r\nstatic void emmaprp_device_run(void *priv)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nstruct emmaprp_q_data *s_q_data, *d_q_data;\r\nstruct vb2_buffer *src_buf, *dst_buf;\r\nstruct emmaprp_dev *pcdev = ctx->dev;\r\nunsigned int s_width, s_height;\r\nunsigned int d_width, d_height;\r\nunsigned int d_size;\r\ndma_addr_t p_in, p_out;\r\nu32 tmp;\r\nsrc_buf = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\ndst_buf = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\ns_q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT);\r\ns_width = s_q_data->width;\r\ns_height = s_q_data->height;\r\nd_q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);\r\nd_width = d_q_data->width;\r\nd_height = d_q_data->height;\r\nd_size = d_width * d_height;\r\np_in = vb2_dma_contig_plane_dma_addr(src_buf, 0);\r\np_out = vb2_dma_contig_plane_dma_addr(dst_buf, 0);\r\nif (!p_in || !p_out) {\r\nv4l2_err(&pcdev->v4l2_dev,\r\n"Acquiring kernel pointers to buffers failed\n");\r\nreturn;\r\n}\r\nwritel(p_in, pcdev->base_emma + PRP_SOURCE_Y_PTR);\r\nwritel(PRP_SIZE_WIDTH(s_width) | PRP_SIZE_HEIGHT(s_height),\r\npcdev->base_emma + PRP_SRC_FRAME_SIZE);\r\nwritel(p_out, pcdev->base_emma + PRP_DEST_Y_PTR);\r\nwritel(p_out + d_size, pcdev->base_emma + PRP_DEST_CB_PTR);\r\nwritel(p_out + d_size + (d_size >> 2),\r\npcdev->base_emma + PRP_DEST_CR_PTR);\r\nwritel(PRP_SIZE_WIDTH(d_width) | PRP_SIZE_HEIGHT(d_height),\r\npcdev->base_emma + PRP_CH2_OUT_IMAGE_SIZE);\r\ntmp = readl(pcdev->base_emma + PRP_INTR_CNTL);\r\nwritel(tmp | PRP_INTR_RDERR |\r\nPRP_INTR_CH2WERR |\r\nPRP_INTR_CH2FC,\r\npcdev->base_emma + PRP_INTR_CNTL);\r\nemmaprp_dump_regs(pcdev);\r\ntmp = readl(pcdev->base_emma + PRP_CNTL);\r\nwritel(tmp | PRP_CNTL_CH2_OUT_YUV420 |\r\nPRP_CNTL_DATA_IN_YUV422 |\r\nPRP_CNTL_CH2EN,\r\npcdev->base_emma + PRP_CNTL);\r\n}\r\nstatic irqreturn_t emmaprp_irq(int irq_emma, void *data)\r\n{\r\nstruct emmaprp_dev *pcdev = data;\r\nstruct emmaprp_ctx *curr_ctx;\r\nstruct vb2_v4l2_buffer *src_vb, *dst_vb;\r\nunsigned long flags;\r\nu32 irqst;\r\nirqst = readl(pcdev->base_emma + PRP_INTRSTATUS);\r\nwritel(irqst, pcdev->base_emma + PRP_INTRSTATUS);\r\ndprintk(pcdev, "irqst = 0x%08x\n", irqst);\r\ncurr_ctx = v4l2_m2m_get_curr_priv(pcdev->m2m_dev);\r\nif (curr_ctx == NULL) {\r\npr_err("Instance released before the end of transaction\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!curr_ctx->aborting) {\r\nif ((irqst & PRP_INTR_ST_RDERR) ||\r\n(irqst & PRP_INTR_ST_CH2WERR)) {\r\npr_err("PrP bus error occurred, this transfer is probably corrupted\n");\r\nwritel(PRP_CNTL_SWRST, pcdev->base_emma + PRP_CNTL);\r\n} else if (irqst & PRP_INTR_ST_CH2B1CI) {\r\nsrc_vb = v4l2_m2m_src_buf_remove(curr_ctx->m2m_ctx);\r\ndst_vb = v4l2_m2m_dst_buf_remove(curr_ctx->m2m_ctx);\r\ndst_vb->vb2_buf.timestamp = src_vb->vb2_buf.timestamp;\r\ndst_vb->flags &=\r\n~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->flags |=\r\nsrc_vb->flags\r\n& V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vb->timecode = src_vb->timecode;\r\nspin_lock_irqsave(&pcdev->irqlock, flags);\r\nv4l2_m2m_buf_done(src_vb, VB2_BUF_STATE_DONE);\r\nv4l2_m2m_buf_done(dst_vb, VB2_BUF_STATE_DONE);\r\nspin_unlock_irqrestore(&pcdev->irqlock, flags);\r\n}\r\n}\r\nv4l2_m2m_job_finish(pcdev->m2m_dev, curr_ctx->m2m_ctx);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstrncpy(cap->driver, MEM2MEM_NAME, sizeof(cap->driver) - 1);\r\nstrncpy(cap->card, MEM2MEM_NAME, sizeof(cap->card) - 1);\r\ncap->device_caps = V4L2_CAP_VIDEO_M2M | V4L2_CAP_STREAMING;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int enum_fmt(struct v4l2_fmtdesc *f, u32 type)\r\n{\r\nint i, num;\r\nstruct emmaprp_fmt *fmt;\r\nnum = 0;\r\nfor (i = 0; i < NUM_FORMATS; ++i) {\r\nif (formats[i].types & type) {\r\nif (num == f->index)\r\nbreak;\r\n++num;\r\n}\r\n}\r\nif (i < NUM_FORMATS) {\r\nfmt = &formats[i];\r\nstrlcpy(f->description, fmt->name, sizeof(f->description) - 1);\r\nf->pixelformat = fmt->fourcc;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int vidioc_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(f, MEM2MEM_CAPTURE);\r\n}\r\nstatic int vidioc_enum_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn enum_fmt(f, MEM2MEM_OUTPUT);\r\n}\r\nstatic int vidioc_g_fmt(struct emmaprp_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct vb2_queue *vq;\r\nstruct emmaprp_q_data *q_data;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nf->fmt.pix.width = q_data->width;\r\nf->fmt.pix.height = q_data->height;\r\nf->fmt.pix.field = V4L2_FIELD_NONE;\r\nf->fmt.pix.pixelformat = q_data->fmt->fourcc;\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420)\r\nf->fmt.pix.bytesperline = q_data->width * 3 / 2;\r\nelse\r\nf->fmt.pix.bytesperline = q_data->width * 2;\r\nf->fmt.pix.sizeimage = q_data->sizeimage;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn vidioc_g_fmt(priv, f);\r\n}\r\nstatic int vidioc_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nreturn vidioc_g_fmt(priv, f);\r\n}\r\nstatic int vidioc_try_fmt(struct v4l2_format *f)\r\n{\r\nenum v4l2_field field;\r\nif (!find_format(f))\r\nreturn -EINVAL;\r\nfield = f->fmt.pix.field;\r\nif (field == V4L2_FIELD_ANY)\r\nfield = V4L2_FIELD_NONE;\r\nelse if (V4L2_FIELD_NONE != field)\r\nreturn -EINVAL;\r\nf->fmt.pix.field = field;\r\nif (f->fmt.pix.pixelformat == V4L2_PIX_FMT_YUV420) {\r\nv4l_bound_align_image(&f->fmt.pix.width, MIN_W, MAX_W,\r\nW_ALIGN_YUV420, &f->fmt.pix.height,\r\nMIN_H, MAX_H, H_ALIGN, S_ALIGN);\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 3 / 2;\r\n} else {\r\nv4l_bound_align_image(&f->fmt.pix.width, MIN_W, MAX_W,\r\nW_ALIGN_OTHERS, &f->fmt.pix.height,\r\nMIN_H, MAX_H, H_ALIGN, S_ALIGN);\r\nf->fmt.pix.bytesperline = f->fmt.pix.width * 2;\r\n}\r\nf->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;\r\nreturn 0;\r\n}\r\nstatic int vidioc_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct emmaprp_fmt *fmt;\r\nstruct emmaprp_ctx *ctx = priv;\r\nfmt = find_format(f);\r\nif (!fmt || !(fmt->types & MEM2MEM_CAPTURE)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nreturn vidioc_try_fmt(f);\r\n}\r\nstatic int vidioc_try_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct emmaprp_fmt *fmt;\r\nstruct emmaprp_ctx *ctx = priv;\r\nfmt = find_format(f);\r\nif (!fmt || !(fmt->types & MEM2MEM_OUTPUT)) {\r\nv4l2_err(&ctx->dev->v4l2_dev,\r\n"Fourcc format (0x%08x) invalid.\n",\r\nf->fmt.pix.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nreturn vidioc_try_fmt(f);\r\n}\r\nstatic int vidioc_s_fmt(struct emmaprp_ctx *ctx, struct v4l2_format *f)\r\n{\r\nstruct emmaprp_q_data *q_data;\r\nstruct vb2_queue *vq;\r\nint ret;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (!vq)\r\nreturn -EINVAL;\r\nq_data = get_q_data(ctx, f->type);\r\nif (!q_data)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(vq)) {\r\nv4l2_err(&ctx->dev->v4l2_dev, "%s queue busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nret = vidioc_try_fmt(f);\r\nif (ret)\r\nreturn ret;\r\nq_data->fmt = find_format(f);\r\nq_data->width = f->fmt.pix.width;\r\nq_data->height = f->fmt.pix.height;\r\nif (q_data->fmt->fourcc == V4L2_PIX_FMT_YUV420)\r\nq_data->sizeimage = q_data->width * q_data->height * 3 / 2;\r\nelse\r\nq_data->sizeimage = q_data->width * q_data->height * 2;\r\ndprintk(ctx->dev,\r\n"Setting format for type %d, wxh: %dx%d, fmt: %d\n",\r\nf->type, q_data->width, q_data->height, q_data->fmt->fourcc);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = vidioc_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn vidioc_s_fmt(priv, f);\r\n}\r\nstatic int vidioc_s_fmt_vid_out(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nint ret;\r\nret = vidioc_try_fmt_vid_out(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nreturn vidioc_s_fmt(priv, f);\r\n}\r\nstatic int vidioc_reqbufs(struct file *file, void *priv,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nreturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\r\n}\r\nstatic int vidioc_querybuf(struct file *file, void *priv,\r\nstruct v4l2_buffer *buf)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nreturn v4l2_m2m_querybuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nreturn v4l2_m2m_qbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *buf)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nreturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\r\n}\r\nstatic int vidioc_streamon(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nreturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int vidioc_streamoff(struct file *file, void *priv,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nreturn v4l2_m2m_streamoff(file, ctx->m2m_ctx, type);\r\n}\r\nstatic int emmaprp_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct emmaprp_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct emmaprp_q_data *q_data;\r\nunsigned int size, count = *nbuffers;\r\nq_data = get_q_data(ctx, vq->type);\r\nif (q_data->fmt->fourcc == V4L2_PIX_FMT_YUV420)\r\nsize = q_data->width * q_data->height * 3 / 2;\r\nelse\r\nsize = q_data->width * q_data->height * 2;\r\nwhile (size * count > MEM2MEM_VID_MEM_LIMIT)\r\n(count)--;\r\n*nplanes = 1;\r\n*nbuffers = count;\r\nsizes[0] = size;\r\ndprintk(ctx->dev, "get %d buffer(s) of size %d each.\n", count, size);\r\nreturn 0;\r\n}\r\nstatic int emmaprp_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct emmaprp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct emmaprp_q_data *q_data;\r\ndprintk(ctx->dev, "type: %d\n", vb->vb2_queue->type);\r\nq_data = get_q_data(ctx, vb->vb2_queue->type);\r\nif (vb2_plane_size(vb, 0) < q_data->sizeimage) {\r\ndprintk(ctx->dev,\r\n"%s data will not fit into plane(%lu < %lu)\n",\r\n__func__, vb2_plane_size(vb, 0),\r\n(long)q_data->sizeimage);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, q_data->sizeimage);\r\nreturn 0;\r\n}\r\nstatic void emmaprp_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct emmaprp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, vbuf);\r\n}\r\nstatic int queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct emmaprp_ctx *ctx = priv;\r\nint ret;\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->ops = &emmaprp_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->dev = ctx->dev->v4l2_dev.dev;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_USERPTR;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->ops = &emmaprp_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->dev = ctx->dev->v4l2_dev.dev;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int emmaprp_open(struct file *file)\r\n{\r\nstruct emmaprp_dev *pcdev = video_drvdata(file);\r\nstruct emmaprp_ctx *ctx;\r\nctx = kzalloc(sizeof *ctx, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nfile->private_data = ctx;\r\nctx->dev = pcdev;\r\nif (mutex_lock_interruptible(&pcdev->dev_mutex)) {\r\nkfree(ctx);\r\nreturn -ERESTARTSYS;\r\n}\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(pcdev->m2m_dev, ctx, &queue_init);\r\nif (IS_ERR(ctx->m2m_ctx)) {\r\nint ret = PTR_ERR(ctx->m2m_ctx);\r\nmutex_unlock(&pcdev->dev_mutex);\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nclk_prepare_enable(pcdev->clk_emma_ipg);\r\nclk_prepare_enable(pcdev->clk_emma_ahb);\r\nctx->q_data[V4L2_M2M_SRC].fmt = &formats[1];\r\nctx->q_data[V4L2_M2M_DST].fmt = &formats[0];\r\nmutex_unlock(&pcdev->dev_mutex);\r\ndprintk(pcdev, "Created instance %p, m2m_ctx: %p\n", ctx, ctx->m2m_ctx);\r\nreturn 0;\r\n}\r\nstatic int emmaprp_release(struct file *file)\r\n{\r\nstruct emmaprp_dev *pcdev = video_drvdata(file);\r\nstruct emmaprp_ctx *ctx = file->private_data;\r\ndprintk(pcdev, "Releasing instance %p\n", ctx);\r\nmutex_lock(&pcdev->dev_mutex);\r\nclk_disable_unprepare(pcdev->clk_emma_ahb);\r\nclk_disable_unprepare(pcdev->clk_emma_ipg);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nmutex_unlock(&pcdev->dev_mutex);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nstatic unsigned int emmaprp_poll(struct file *file,\r\nstruct poll_table_struct *wait)\r\n{\r\nstruct emmaprp_dev *pcdev = video_drvdata(file);\r\nstruct emmaprp_ctx *ctx = file->private_data;\r\nunsigned int res;\r\nmutex_lock(&pcdev->dev_mutex);\r\nres = v4l2_m2m_poll(file, ctx->m2m_ctx, wait);\r\nmutex_unlock(&pcdev->dev_mutex);\r\nreturn res;\r\n}\r\nstatic int emmaprp_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct emmaprp_dev *pcdev = video_drvdata(file);\r\nstruct emmaprp_ctx *ctx = file->private_data;\r\nint ret;\r\nif (mutex_lock_interruptible(&pcdev->dev_mutex))\r\nreturn -ERESTARTSYS;\r\nret = v4l2_m2m_mmap(file, ctx->m2m_ctx, vma);\r\nmutex_unlock(&pcdev->dev_mutex);\r\nreturn ret;\r\n}\r\nstatic int emmaprp_probe(struct platform_device *pdev)\r\n{\r\nstruct emmaprp_dev *pcdev;\r\nstruct video_device *vfd;\r\nstruct resource *res;\r\nint irq, ret;\r\npcdev = devm_kzalloc(&pdev->dev, sizeof(*pcdev), GFP_KERNEL);\r\nif (!pcdev)\r\nreturn -ENOMEM;\r\nspin_lock_init(&pcdev->irqlock);\r\npcdev->clk_emma_ipg = devm_clk_get(&pdev->dev, "ipg");\r\nif (IS_ERR(pcdev->clk_emma_ipg)) {\r\nreturn PTR_ERR(pcdev->clk_emma_ipg);\r\n}\r\npcdev->clk_emma_ahb = devm_clk_get(&pdev->dev, "ahb");\r\nif (IS_ERR(pcdev->clk_emma_ahb))\r\nreturn PTR_ERR(pcdev->clk_emma_ahb);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npcdev->base_emma = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pcdev->base_emma))\r\nreturn PTR_ERR(pcdev->base_emma);\r\nret = v4l2_device_register(&pdev->dev, &pcdev->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&pcdev->dev_mutex);\r\nvfd = video_device_alloc();\r\nif (!vfd) {\r\nv4l2_err(&pcdev->v4l2_dev, "Failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto unreg_dev;\r\n}\r\n*vfd = emmaprp_videodev;\r\nvfd->lock = &pcdev->dev_mutex;\r\nvfd->v4l2_dev = &pcdev->v4l2_dev;\r\nvideo_set_drvdata(vfd, pcdev);\r\nsnprintf(vfd->name, sizeof(vfd->name), "%s", emmaprp_videodev.name);\r\npcdev->vfd = vfd;\r\nv4l2_info(&pcdev->v4l2_dev, EMMAPRP_MODULE_NAME\r\n" Device registered as /dev/video%d\n", vfd->num);\r\nplatform_set_drvdata(pdev, pcdev);\r\nirq = platform_get_irq(pdev, 0);\r\nret = devm_request_irq(&pdev->dev, irq, emmaprp_irq, 0,\r\ndev_name(&pdev->dev), pcdev);\r\nif (ret)\r\ngoto rel_vdev;\r\npcdev->m2m_dev = v4l2_m2m_init(&m2m_ops);\r\nif (IS_ERR(pcdev->m2m_dev)) {\r\nv4l2_err(&pcdev->v4l2_dev, "Failed to init mem2mem device\n");\r\nret = PTR_ERR(pcdev->m2m_dev);\r\ngoto rel_vdev;\r\n}\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, 0);\r\nif (ret) {\r\nv4l2_err(&pcdev->v4l2_dev, "Failed to register video device\n");\r\ngoto rel_m2m;\r\n}\r\nreturn 0;\r\nrel_m2m:\r\nv4l2_m2m_release(pcdev->m2m_dev);\r\nrel_vdev:\r\nvideo_device_release(vfd);\r\nunreg_dev:\r\nv4l2_device_unregister(&pcdev->v4l2_dev);\r\nmutex_destroy(&pcdev->dev_mutex);\r\nreturn ret;\r\n}\r\nstatic int emmaprp_remove(struct platform_device *pdev)\r\n{\r\nstruct emmaprp_dev *pcdev = platform_get_drvdata(pdev);\r\nv4l2_info(&pcdev->v4l2_dev, "Removing " EMMAPRP_MODULE_NAME);\r\nvideo_unregister_device(pcdev->vfd);\r\nv4l2_m2m_release(pcdev->m2m_dev);\r\nv4l2_device_unregister(&pcdev->v4l2_dev);\r\nmutex_destroy(&pcdev->dev_mutex);\r\nreturn 0;\r\n}
