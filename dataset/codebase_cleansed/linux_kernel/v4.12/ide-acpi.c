static int no_acpi_psx(const struct dmi_system_id *id)\r\n{\r\nide_noacpi_psx = true;\r\nprintk(KERN_NOTICE"%s detected - disable ACPI _PSx.\n", id->ident);\r\nreturn 0;\r\n}\r\nint ide_acpi_init(void)\r\n{\r\ndmi_check_system(ide_acpi_dmi_table);\r\nreturn 0;\r\n}\r\nbool ide_port_acpi(ide_hwif_t *hwif)\r\n{\r\nreturn ide_noacpi == 0 && hwif->acpidata;\r\n}\r\nstatic acpi_handle acpi_get_child(acpi_handle handle, u64 addr)\r\n{\r\nstruct acpi_device *adev;\r\nif (!handle || acpi_bus_get_device(handle, &adev))\r\nreturn NULL;\r\nadev = acpi_find_child_device(adev, addr, false);\r\nreturn adev ? adev->handle : NULL;\r\n}\r\nstatic int ide_get_dev_handle(struct device *dev, acpi_handle *handle,\r\nu64 *pcidevfn)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nunsigned int bus, devnum, func;\r\nu64 addr;\r\nacpi_handle dev_handle;\r\nacpi_status status;\r\nstruct acpi_device_info *dinfo = NULL;\r\nint ret = -ENODEV;\r\nbus = pdev->bus->number;\r\ndevnum = PCI_SLOT(pdev->devfn);\r\nfunc = PCI_FUNC(pdev->devfn);\r\naddr = (u64)(devnum << 16 | func);\r\nDEBPRINT("ENTER: pci %02x:%02x.%01x\n", bus, devnum, func);\r\ndev_handle = ACPI_HANDLE(dev);\r\nif (!dev_handle) {\r\nDEBPRINT("no acpi handle for device\n");\r\ngoto err;\r\n}\r\nstatus = acpi_get_object_info(dev_handle, &dinfo);\r\nif (ACPI_FAILURE(status)) {\r\nDEBPRINT("get_object_info for device failed\n");\r\ngoto err;\r\n}\r\nif (dinfo && (dinfo->valid & ACPI_VALID_ADR) &&\r\ndinfo->address == addr) {\r\n*pcidevfn = addr;\r\n*handle = dev_handle;\r\n} else {\r\nDEBPRINT("get_object_info for device has wrong "\r\n" address: %llu, should be %u\n",\r\ndinfo ? (unsigned long long)dinfo->address : -1ULL,\r\n(unsigned int)addr);\r\ngoto err;\r\n}\r\nDEBPRINT("for dev=0x%x.%x, addr=0x%llx, *handle=0x%p\n",\r\ndevnum, func, (unsigned long long)addr, *handle);\r\nret = 0;\r\nerr:\r\nkfree(dinfo);\r\nreturn ret;\r\n}\r\nstatic acpi_handle ide_acpi_hwif_get_handle(ide_hwif_t *hwif)\r\n{\r\nstruct device *dev = hwif->gendev.parent;\r\nacpi_handle uninitialized_var(dev_handle);\r\nu64 pcidevfn;\r\nacpi_handle chan_handle;\r\nint err;\r\nDEBPRINT("ENTER: device %s\n", hwif->name);\r\nif (!dev) {\r\nDEBPRINT("no PCI device for %s\n", hwif->name);\r\nreturn NULL;\r\n}\r\nerr = ide_get_dev_handle(dev, &dev_handle, &pcidevfn);\r\nif (err < 0) {\r\nDEBPRINT("ide_get_dev_handle failed (%d)\n", err);\r\nreturn NULL;\r\n}\r\nchan_handle = acpi_get_child(dev_handle, hwif->channel);\r\nDEBPRINT("chan adr=%d: handle=0x%p\n",\r\nhwif->channel, chan_handle);\r\nreturn chan_handle;\r\n}\r\nstatic int do_drive_get_GTF(ide_drive_t *drive,\r\nunsigned int *gtf_length, unsigned long *gtf_address,\r\nunsigned long *obj_loc)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer output;\r\nunion acpi_object *out_obj;\r\nint err = -ENODEV;\r\n*gtf_length = 0;\r\n*gtf_address = 0UL;\r\n*obj_loc = 0UL;\r\nif (!drive->acpidata->obj_handle) {\r\nDEBPRINT("No ACPI object found for %s\n", drive->name);\r\ngoto out;\r\n}\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nerr = -EIO;\r\nstatus = acpi_evaluate_object(drive->acpidata->obj_handle, "_GTF",\r\nNULL, &output);\r\nif (ACPI_FAILURE(status)) {\r\nprintk(KERN_DEBUG\r\n"%s: Run _GTF error: status = 0x%x\n",\r\n__func__, status);\r\ngoto out;\r\n}\r\nif (!output.length || !output.pointer) {\r\nDEBPRINT("Run _GTF: "\r\n"length or ptr is NULL (0x%llx, 0x%p)\n",\r\n(unsigned long long)output.length,\r\noutput.pointer);\r\ngoto out;\r\n}\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nDEBPRINT("Run _GTF: error: "\r\n"expected object type of ACPI_TYPE_BUFFER, "\r\n"got 0x%x\n", out_obj->type);\r\nerr = -ENOENT;\r\nkfree(output.pointer);\r\ngoto out;\r\n}\r\nif (!out_obj->buffer.length || !out_obj->buffer.pointer ||\r\nout_obj->buffer.length % REGS_PER_GTF) {\r\nprintk(KERN_ERR\r\n"%s: unexpected GTF length (%d) or addr (0x%p)\n",\r\n__func__, out_obj->buffer.length,\r\nout_obj->buffer.pointer);\r\nerr = -ENOENT;\r\nkfree(output.pointer);\r\ngoto out;\r\n}\r\n*gtf_length = out_obj->buffer.length;\r\n*gtf_address = (unsigned long)out_obj->buffer.pointer;\r\n*obj_loc = (unsigned long)out_obj;\r\nDEBPRINT("returning gtf_length=%d, gtf_address=0x%lx, obj_loc=0x%lx\n",\r\n*gtf_length, *gtf_address, *obj_loc);\r\nerr = 0;\r\nout:\r\nreturn err;\r\n}\r\nstatic int do_drive_set_taskfiles(ide_drive_t *drive,\r\nunsigned int gtf_length,\r\nunsigned long gtf_address)\r\n{\r\nint rc = 0, err;\r\nint gtf_count = gtf_length / REGS_PER_GTF;\r\nint ix;\r\nDEBPRINT("total GTF bytes=%u (0x%x), gtf_count=%d, addr=0x%lx\n",\r\ngtf_length, gtf_length, gtf_count, gtf_address);\r\nfor (ix = 0; ix < gtf_count; ix++) {\r\nu8 *gtf = (u8 *)(gtf_address + ix * REGS_PER_GTF);\r\nstruct ide_cmd cmd;\r\nDEBPRINT("(0x1f1-1f7): "\r\n"hex: %02x %02x %02x %02x %02x %02x %02x\n",\r\ngtf[0], gtf[1], gtf[2],\r\ngtf[3], gtf[4], gtf[5], gtf[6]);\r\nif (!ide_acpigtf) {\r\nDEBPRINT("_GTF execution disabled\n");\r\ncontinue;\r\n}\r\nmemset(&cmd, 0, sizeof(cmd));\r\nmemcpy(&cmd.tf.feature, gtf, REGS_PER_GTF);\r\ncmd.valid.out.tf = IDE_VALID_OUT_TF | IDE_VALID_DEVICE;\r\ncmd.valid.in.tf = IDE_VALID_IN_TF | IDE_VALID_DEVICE;\r\nerr = ide_no_data_taskfile(drive, &cmd);\r\nif (err) {\r\nprintk(KERN_ERR "%s: ide_no_data_taskfile failed: %u\n",\r\n__func__, err);\r\nrc = err;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nint ide_acpi_exec_tfs(ide_drive_t *drive)\r\n{\r\nint ret;\r\nunsigned int gtf_length;\r\nunsigned long gtf_address;\r\nunsigned long obj_loc;\r\nDEBPRINT("call get_GTF, drive=%s port=%d\n", drive->name, drive->dn);\r\nret = do_drive_get_GTF(drive, &gtf_length, &gtf_address, &obj_loc);\r\nif (ret < 0) {\r\nDEBPRINT("get_GTF error (%d)\n", ret);\r\nreturn ret;\r\n}\r\nDEBPRINT("call set_taskfiles, drive=%s\n", drive->name);\r\nret = do_drive_set_taskfiles(drive, gtf_length, gtf_address);\r\nkfree((void *)obj_loc);\r\nif (ret < 0) {\r\nDEBPRINT("set_taskfiles error (%d)\n", ret);\r\n}\r\nDEBPRINT("ret=%d\n", ret);\r\nreturn ret;\r\n}\r\nvoid ide_acpi_get_timing(ide_hwif_t *hwif)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer output;\r\nunion acpi_object *out_obj;\r\noutput.length = ACPI_ALLOCATE_BUFFER;\r\noutput.pointer = NULL;\r\nstatus = acpi_evaluate_object(hwif->acpidata->obj_handle, "_GTM",\r\nNULL, &output);\r\nDEBPRINT("_GTM status: %d, outptr: 0x%p, outlen: 0x%llx\n",\r\nstatus, output.pointer,\r\n(unsigned long long)output.length);\r\nif (ACPI_FAILURE(status)) {\r\nDEBPRINT("Run _GTM error: status = 0x%x\n", status);\r\nreturn;\r\n}\r\nif (!output.length || !output.pointer) {\r\nDEBPRINT("Run _GTM: length or ptr is NULL (0x%llx, 0x%p)\n",\r\n(unsigned long long)output.length,\r\noutput.pointer);\r\nkfree(output.pointer);\r\nreturn;\r\n}\r\nout_obj = output.pointer;\r\nif (out_obj->type != ACPI_TYPE_BUFFER) {\r\nDEBPRINT("Run _GTM: error: "\r\n"expected object type of ACPI_TYPE_BUFFER, "\r\n"got 0x%x\n", out_obj->type);\r\nkfree(output.pointer);\r\nreturn;\r\n}\r\nif (!out_obj->buffer.length || !out_obj->buffer.pointer ||\r\nout_obj->buffer.length != sizeof(struct GTM_buffer)) {\r\nprintk(KERN_ERR\r\n"%s: unexpected _GTM length (0x%x)[should be 0x%zx] or "\r\n"addr (0x%p)\n",\r\n__func__, out_obj->buffer.length,\r\nsizeof(struct GTM_buffer), out_obj->buffer.pointer);\r\nkfree(output.pointer);\r\nreturn;\r\n}\r\nmemcpy(&hwif->acpidata->gtm, out_obj->buffer.pointer,\r\nsizeof(struct GTM_buffer));\r\nDEBPRINT("_GTM info: ptr: 0x%p, len: 0x%x, exp.len: 0x%zx\n",\r\nout_obj->buffer.pointer, out_obj->buffer.length,\r\nsizeof(struct GTM_buffer));\r\nDEBPRINT("_GTM fields: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x\n",\r\nhwif->acpidata->gtm.PIO_speed0,\r\nhwif->acpidata->gtm.DMA_speed0,\r\nhwif->acpidata->gtm.PIO_speed1,\r\nhwif->acpidata->gtm.DMA_speed1,\r\nhwif->acpidata->gtm.GTM_flags);\r\nkfree(output.pointer);\r\n}\r\nvoid ide_acpi_push_timing(ide_hwif_t *hwif)\r\n{\r\nacpi_status status;\r\nstruct acpi_object_list input;\r\nunion acpi_object in_params[3];\r\nstruct ide_acpi_drive_link *master = &hwif->acpidata->master;\r\nstruct ide_acpi_drive_link *slave = &hwif->acpidata->slave;\r\ninput.count = 3;\r\ninput.pointer = in_params;\r\nin_params[0].type = ACPI_TYPE_BUFFER;\r\nin_params[0].buffer.length = sizeof(struct GTM_buffer);\r\nin_params[0].buffer.pointer = (u8 *)&hwif->acpidata->gtm;\r\nin_params[1].type = ACPI_TYPE_BUFFER;\r\nin_params[1].buffer.length = ATA_ID_WORDS * 2;\r\nin_params[1].buffer.pointer = (u8 *)&master->idbuff;\r\nin_params[2].type = ACPI_TYPE_BUFFER;\r\nin_params[2].buffer.length = ATA_ID_WORDS * 2;\r\nin_params[2].buffer.pointer = (u8 *)&slave->idbuff;\r\nstatus = acpi_evaluate_object(hwif->acpidata->obj_handle, "_STM",\r\n&input, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nDEBPRINT("Run _STM error: status = 0x%x\n", status);\r\n}\r\nDEBPRINT("_STM status: %d\n", status);\r\n}\r\nvoid ide_acpi_set_state(ide_hwif_t *hwif, int on)\r\n{\r\nide_drive_t *drive;\r\nint i;\r\nif (ide_noacpi_psx)\r\nreturn;\r\nDEBPRINT("ENTER:\n");\r\nif (on)\r\nacpi_bus_set_power(hwif->acpidata->obj_handle, ACPI_STATE_D0);\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nif (drive->acpidata->obj_handle)\r\nacpi_bus_set_power(drive->acpidata->obj_handle,\r\non ? ACPI_STATE_D0 : ACPI_STATE_D3_COLD);\r\n}\r\nif (!on)\r\nacpi_bus_set_power(hwif->acpidata->obj_handle,\r\nACPI_STATE_D3_COLD);\r\n}\r\nvoid ide_acpi_init_port(ide_hwif_t *hwif)\r\n{\r\nhwif->acpidata = kzalloc(sizeof(struct ide_acpi_hwif_link), GFP_KERNEL);\r\nif (!hwif->acpidata)\r\nreturn;\r\nhwif->acpidata->obj_handle = ide_acpi_hwif_get_handle(hwif);\r\nif (!hwif->acpidata->obj_handle) {\r\nDEBPRINT("no ACPI object for %s found\n", hwif->name);\r\nkfree(hwif->acpidata);\r\nhwif->acpidata = NULL;\r\n}\r\n}\r\nvoid ide_acpi_port_init_devices(ide_hwif_t *hwif)\r\n{\r\nide_drive_t *drive;\r\nint i, err;\r\nif (hwif->acpidata == NULL)\r\nreturn;\r\nhwif->devices[0]->acpidata = &hwif->acpidata->master;\r\nhwif->devices[1]->acpidata = &hwif->acpidata->slave;\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nacpi_handle dev_handle;\r\nDEBPRINT("ENTER: %s at channel#: %d port#: %d\n",\r\ndrive->name, hwif->channel, drive->dn & 1);\r\ndev_handle = acpi_get_child(hwif->acpidata->obj_handle,\r\ndrive->dn & 1);\r\nDEBPRINT("drive %s handle 0x%p\n", drive->name, dev_handle);\r\ndrive->acpidata->obj_handle = dev_handle;\r\n}\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nerr = taskfile_lib_get_identify(drive, drive->acpidata->idbuff);\r\nif (err)\r\nDEBPRINT("identify device %s failed (%d)\n",\r\ndrive->name, err);\r\n}\r\nif (ide_noacpi || ide_acpionboot == 0) {\r\nDEBPRINT("ACPI methods disabled on boot\n");\r\nreturn;\r\n}\r\nide_acpi_set_state(hwif, 1);\r\nide_acpi_get_timing(hwif);\r\nide_acpi_push_timing(hwif);\r\nide_port_for_each_present_dev(i, drive, hwif) {\r\nide_acpi_exec_tfs(drive);\r\n}\r\n}
