static unsigned long apds9300_calculate_lux(u16 ch0, u16 ch1)\r\n{\r\nunsigned long lux, tmp;\r\nif (ch0 == 0)\r\nreturn 0;\r\ntmp = DIV_ROUND_UP(ch1 * 100, ch0);\r\nif (tmp <= 52) {\r\nlux = 3150 * ch0 - (unsigned long)DIV_ROUND_UP_ULL(ch0\r\n* apds9300_lux_ratio[tmp] * 5930ull, 1000);\r\n} else if (tmp <= 65) {\r\nlux = 2290 * ch0 - 2910 * ch1;\r\n} else if (tmp <= 80) {\r\nlux = 1570 * ch0 - 1800 * ch1;\r\n} else if (tmp <= 130) {\r\nlux = 338 * ch0 - 260 * ch1;\r\n} else {\r\nlux = 0;\r\n}\r\nreturn lux / 100000;\r\n}\r\nstatic int apds9300_get_adc_val(struct apds9300_data *data, int adc_number)\r\n{\r\nint ret;\r\nu8 flags = APDS9300_CMD | APDS9300_WORD;\r\nif (!data->power_state)\r\nreturn -EBUSY;\r\nflags |= adc_number ? APDS9300_DATA1LOW : APDS9300_DATA0LOW;\r\nret = i2c_smbus_read_word_data(data->client, flags);\r\nif (ret < 0)\r\ndev_err(&data->client->dev,\r\n"failed to read ADC%d value\n", adc_number);\r\nreturn ret;\r\n}\r\nstatic int apds9300_set_thresh_low(struct apds9300_data *data, int value)\r\n{\r\nint ret;\r\nif (!data->power_state)\r\nreturn -EBUSY;\r\nif (value > APDS9300_THRESH_MAX)\r\nreturn -EINVAL;\r\nret = i2c_smbus_write_word_data(data->client, APDS9300_THRESHLOWLOW\r\n| APDS9300_CMD | APDS9300_WORD, value);\r\nif (ret) {\r\ndev_err(&data->client->dev, "failed to set thresh_low\n");\r\nreturn ret;\r\n}\r\ndata->thresh_low = value;\r\nreturn 0;\r\n}\r\nstatic int apds9300_set_thresh_hi(struct apds9300_data *data, int value)\r\n{\r\nint ret;\r\nif (!data->power_state)\r\nreturn -EBUSY;\r\nif (value > APDS9300_THRESH_MAX)\r\nreturn -EINVAL;\r\nret = i2c_smbus_write_word_data(data->client, APDS9300_THRESHHIGHLOW\r\n| APDS9300_CMD | APDS9300_WORD, value);\r\nif (ret) {\r\ndev_err(&data->client->dev, "failed to set thresh_hi\n");\r\nreturn ret;\r\n}\r\ndata->thresh_hi = value;\r\nreturn 0;\r\n}\r\nstatic int apds9300_set_intr_state(struct apds9300_data *data, int state)\r\n{\r\nint ret;\r\nu8 cmd;\r\nif (!data->power_state)\r\nreturn -EBUSY;\r\ncmd = state ? APDS9300_INTR_ENABLE | APDS9300_THRESH_INTR : 0x00;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nAPDS9300_INTERRUPT | APDS9300_CMD, cmd);\r\nif (ret) {\r\ndev_err(&data->client->dev,\r\n"failed to set interrupt state %d\n", state);\r\nreturn ret;\r\n}\r\ndata->intr_en = state;\r\nreturn 0;\r\n}\r\nstatic int apds9300_set_power_state(struct apds9300_data *data, int state)\r\n{\r\nint ret;\r\nu8 cmd;\r\ncmd = state ? APDS9300_POWER_ON : APDS9300_POWER_OFF;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nAPDS9300_CONTROL | APDS9300_CMD, cmd);\r\nif (ret) {\r\ndev_err(&data->client->dev,\r\n"failed to set power state %d\n", state);\r\nreturn ret;\r\n}\r\ndata->power_state = state;\r\nreturn 0;\r\n}\r\nstatic void apds9300_clear_intr(struct apds9300_data *data)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte(data->client, APDS9300_CLEAR | APDS9300_CMD);\r\nif (ret < 0)\r\ndev_err(&data->client->dev, "failed to clear interrupt\n");\r\n}\r\nstatic int apds9300_chip_init(struct apds9300_data *data)\r\n{\r\nint ret;\r\nret = apds9300_set_power_state(data, 0);\r\nif (ret < 0)\r\ngoto err;\r\nret = apds9300_set_power_state(data, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = i2c_smbus_read_byte_data(data->client,\r\nAPDS9300_CONTROL | APDS9300_CMD);\r\nif (ret != APDS9300_POWER_ON) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = apds9300_set_intr_state(data, 0);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_err(&data->client->dev, "failed to init the chip\n");\r\nreturn ret;\r\n}\r\nstatic int apds9300_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan, int *val, int *val2,\r\nlong mask)\r\n{\r\nint ch0, ch1, ret = -EINVAL;\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nmutex_lock(&data->mutex);\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nch0 = apds9300_get_adc_val(data, 0);\r\nif (ch0 < 0) {\r\nret = ch0;\r\nbreak;\r\n}\r\nch1 = apds9300_get_adc_val(data, 1);\r\nif (ch1 < 0) {\r\nret = ch1;\r\nbreak;\r\n}\r\n*val = apds9300_calculate_lux(ch0, ch1);\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_INTENSITY:\r\nret = apds9300_get_adc_val(data, chan->channel);\r\nif (ret < 0)\r\nbreak;\r\n*val = ret;\r\nret = IIO_VAL_INT;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int apds9300_read_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\n*val = data->thresh_hi;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\n*val = data->thresh_low;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn IIO_VAL_INT;\r\n}\r\nstatic int apds9300_write_thresh(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info, int val,\r\nint val2)\r\n{\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nif (dir == IIO_EV_DIR_RISING)\r\nret = apds9300_set_thresh_hi(data, val);\r\nelse\r\nret = apds9300_set_thresh_low(data, val);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int apds9300_read_interrupt_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan,\r\nenum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nreturn data->intr_en;\r\n}\r\nstatic int apds9300_write_interrupt_config(struct iio_dev *indio_dev,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = apds9300_set_intr_state(data, state);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t apds9300_interrupt_handler(int irq, void *private)\r\n{\r\nstruct iio_dev *dev_info = private;\r\nstruct apds9300_data *data = iio_priv(dev_info);\r\niio_push_event(dev_info,\r\nIIO_UNMOD_EVENT_CODE(IIO_INTENSITY, 0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_EITHER),\r\niio_get_time_ns(dev_info));\r\napds9300_clear_intr(data);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int apds9300_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct apds9300_data *data;\r\nstruct iio_dev *indio_dev;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\nret = apds9300_chip_init(data);\r\nif (ret < 0)\r\ngoto err;\r\nmutex_init(&data->mutex);\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->channels = apds9300_channels;\r\nindio_dev->num_channels = ARRAY_SIZE(apds9300_channels);\r\nindio_dev->name = APDS9300_DRV_NAME;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nif (client->irq)\r\nindio_dev->info = &apds9300_info;\r\nelse\r\nindio_dev->info = &apds9300_info_no_irq;\r\nif (client->irq) {\r\nret = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, apds9300_interrupt_handler,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\nAPDS9300_IRQ_NAME, indio_dev);\r\nif (ret) {\r\ndev_err(&client->dev, "irq request error %d\n", -ret);\r\ngoto err;\r\n}\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\napds9300_set_power_state(data, 0);\r\nreturn ret;\r\n}\r\nstatic int apds9300_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\niio_device_unregister(indio_dev);\r\napds9300_set_intr_state(data, 0);\r\napds9300_set_power_state(data, 0);\r\nreturn 0;\r\n}\r\nstatic int apds9300_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = apds9300_set_power_state(data, 0);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}\r\nstatic int apds9300_resume(struct device *dev)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(to_i2c_client(dev));\r\nstruct apds9300_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->mutex);\r\nret = apds9300_set_power_state(data, 1);\r\nmutex_unlock(&data->mutex);\r\nreturn ret;\r\n}
