static void ep93xx_gpio_update_int_params(unsigned port)\r\n{\r\nBUG_ON(port > 2);\r\nwriteb_relaxed(0, EP93XX_GPIO_REG(int_en_register_offset[port]));\r\nwriteb_relaxed(gpio_int_type2[port],\r\nEP93XX_GPIO_REG(int_type2_register_offset[port]));\r\nwriteb_relaxed(gpio_int_type1[port],\r\nEP93XX_GPIO_REG(int_type1_register_offset[port]));\r\nwriteb(gpio_int_unmasked[port] & gpio_int_enabled[port],\r\nEP93XX_GPIO_REG(int_en_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_int_debounce(unsigned int irq, bool enable)\r\n{\r\nint line = irq_to_gpio(irq);\r\nint port = line >> 3;\r\nint port_mask = 1 << (line & 7);\r\nif (enable)\r\ngpio_int_debounce[port] |= port_mask;\r\nelse\r\ngpio_int_debounce[port] &= ~port_mask;\r\nwriteb(gpio_int_debounce[port],\r\nEP93XX_GPIO_REG(int_debounce_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_ab_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned char status;\r\nint i;\r\nstatus = readb(EP93XX_GPIO_A_INT_STATUS);\r\nfor (i = 0; i < 8; i++) {\r\nif (status & (1 << i)) {\r\nint gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_A(0)) + i;\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\n}\r\nstatus = readb(EP93XX_GPIO_B_INT_STATUS);\r\nfor (i = 0; i < 8; i++) {\r\nif (status & (1 << i)) {\r\nint gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_B(0)) + i;\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\n}\r\n}\r\nstatic void ep93xx_gpio_f_irq_handler(struct irq_desc *desc)\r\n{\r\nunsigned int irq = irq_desc_get_irq(desc);\r\nint port_f_idx = ((irq + 1) & 7) ^ 4;\r\nint gpio_irq = gpio_to_irq(EP93XX_GPIO_LINE_F(0)) + port_f_idx;\r\ngeneric_handle_irq(gpio_irq);\r\n}\r\nstatic void ep93xx_gpio_irq_ack(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\nint port_mask = 1 << (line & 7);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\r\ngpio_int_type2[port] ^= port_mask;\r\nep93xx_gpio_update_int_params(port);\r\n}\r\nwriteb(port_mask, EP93XX_GPIO_REG(eoi_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_irq_mask_ack(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\nint port_mask = 1 << (line & 7);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH)\r\ngpio_int_type2[port] ^= port_mask;\r\ngpio_int_unmasked[port] &= ~port_mask;\r\nep93xx_gpio_update_int_params(port);\r\nwriteb(port_mask, EP93XX_GPIO_REG(eoi_register_offset[port]));\r\n}\r\nstatic void ep93xx_gpio_irq_mask(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\ngpio_int_unmasked[port] &= ~(1 << (line & 7));\r\nep93xx_gpio_update_int_params(port);\r\n}\r\nstatic void ep93xx_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nint line = irq_to_gpio(d->irq);\r\nint port = line >> 3;\r\ngpio_int_unmasked[port] |= 1 << (line & 7);\r\nep93xx_gpio_update_int_params(port);\r\n}\r\nstatic int ep93xx_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nconst int gpio = irq_to_gpio(d->irq);\r\nconst int port = gpio >> 3;\r\nconst int port_mask = 1 << (gpio & 7);\r\nirq_flow_handler_t handler;\r\ngpio_direction_input(gpio);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\ngpio_int_type1[port] |= port_mask;\r\ngpio_int_type2[port] |= port_mask;\r\nhandler = handle_edge_irq;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ngpio_int_type1[port] |= port_mask;\r\ngpio_int_type2[port] &= ~port_mask;\r\nhandler = handle_edge_irq;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ngpio_int_type1[port] &= ~port_mask;\r\ngpio_int_type2[port] |= port_mask;\r\nhandler = handle_level_irq;\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ngpio_int_type1[port] &= ~port_mask;\r\ngpio_int_type2[port] &= ~port_mask;\r\nhandler = handle_level_irq;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ngpio_int_type1[port] |= port_mask;\r\nif (gpio_get_value(gpio))\r\ngpio_int_type2[port] &= ~port_mask;\r\nelse\r\ngpio_int_type2[port] |= port_mask;\r\nhandler = handle_edge_irq;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nirq_set_handler_locked(d, handler);\r\ngpio_int_enabled[port] |= port_mask;\r\nep93xx_gpio_update_int_params(port);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_gpio_init_irq(void)\r\n{\r\nint gpio_irq;\r\nfor (gpio_irq = gpio_to_irq(0);\r\ngpio_irq <= gpio_to_irq(EP93XX_GPIO_LINE_MAX_IRQ); ++gpio_irq) {\r\nirq_set_chip_and_handler(gpio_irq, &ep93xx_gpio_irq_chip,\r\nhandle_level_irq);\r\nirq_clear_status_flags(gpio_irq, IRQ_NOREQUEST);\r\n}\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO_AB,\r\nep93xx_gpio_ab_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO0MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO1MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO2MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO3MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO4MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO5MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO6MUX,\r\nep93xx_gpio_f_irq_handler);\r\nirq_set_chained_handler(IRQ_EP93XX_GPIO7MUX,\r\nep93xx_gpio_f_irq_handler);\r\n}\r\nstatic int ep93xx_gpio_set_config(struct gpio_chip *chip, unsigned offset,\r\nunsigned long config)\r\n{\r\nint gpio = chip->base + offset;\r\nint irq = gpio_to_irq(gpio);\r\nu32 debounce;\r\nif (pinconf_to_config_param(config) != PIN_CONFIG_INPUT_DEBOUNCE)\r\nreturn -ENOTSUPP;\r\nif (irq < 0)\r\nreturn -EINVAL;\r\ndebounce = pinconf_to_config_argument(config);\r\nep93xx_gpio_int_debounce(irq, debounce ? true : false);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nint gpio = chip->base + offset;\r\nif (gpio > EP93XX_GPIO_LINE_MAX_IRQ)\r\nreturn -EINVAL;\r\nreturn 64 + gpio;\r\n}\r\nstatic int ep93xx_gpio_add_bank(struct gpio_chip *gc, struct device *dev,\r\nvoid __iomem *mmio_base, struct ep93xx_gpio_bank *bank)\r\n{\r\nvoid __iomem *data = mmio_base + bank->data;\r\nvoid __iomem *dir = mmio_base + bank->dir;\r\nint err;\r\nerr = bgpio_init(gc, dev, 1, data, NULL, NULL, dir, NULL, 0);\r\nif (err)\r\nreturn err;\r\ngc->label = bank->label;\r\ngc->base = bank->base;\r\nif (bank->has_debounce) {\r\ngc->set_config = ep93xx_gpio_set_config;\r\ngc->to_irq = ep93xx_gpio_to_irq;\r\n}\r\nreturn devm_gpiochip_add_data(dev, gc, NULL);\r\n}\r\nstatic int ep93xx_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct ep93xx_gpio *ep93xx_gpio;\r\nstruct resource *res;\r\nint i;\r\nstruct device *dev = &pdev->dev;\r\nep93xx_gpio = devm_kzalloc(dev, sizeof(struct ep93xx_gpio), GFP_KERNEL);\r\nif (!ep93xx_gpio)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nep93xx_gpio->mmio_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(ep93xx_gpio->mmio_base))\r\nreturn PTR_ERR(ep93xx_gpio->mmio_base);\r\nfor (i = 0; i < ARRAY_SIZE(ep93xx_gpio_banks); i++) {\r\nstruct gpio_chip *gc = &ep93xx_gpio->gc[i];\r\nstruct ep93xx_gpio_bank *bank = &ep93xx_gpio_banks[i];\r\nif (ep93xx_gpio_add_bank(gc, &pdev->dev,\r\nep93xx_gpio->mmio_base, bank))\r\ndev_warn(&pdev->dev, "Unable to add gpio bank %s\n",\r\nbank->label);\r\n}\r\nep93xx_gpio_init_irq();\r\nreturn 0;\r\n}\r\nstatic int __init ep93xx_gpio_init(void)\r\n{\r\nreturn platform_driver_register(&ep93xx_gpio_driver);\r\n}
