static unsigned char clear_group_from_set(const unsigned char groups, struct if_group *group)\r\n{\r\nreturn (groups & ~group->group);\r\n}\r\nstatic struct if_group *get_group(const unsigned char groups)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(if_groups); i++) {\r\nif (groups & if_groups[i].group) {\r\nreturn &if_groups[i];\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void notify_watchers(void)\r\n{\r\nstruct watcher *w = watchers;\r\nDBG(printk("io_interface_mux: notifying watchers\n"));\r\nwhile (NULL != w) {\r\nw->notify((const unsigned int)gpio_in_pins,\r\n(const unsigned int)gpio_out_pins,\r\n(const unsigned char)gpio_pa_pins,\r\n(const unsigned char)gpio_pb_pins);\r\nw = w->next;\r\n}\r\n}\r\nint cris_request_io_interface(enum cris_io_interface ioif, const char *device_id)\r\n{\r\nint set_gen_config = 0;\r\nint set_gen_config_ii = 0;\r\nunsigned long int gens;\r\nunsigned long int gens_ii;\r\nstruct if_group *grp;\r\nunsigned char group_set;\r\nunsigned long flags;\r\nint res = 0;\r\n(void)cris_io_interface_init();\r\nDBG(printk("cris_request_io_interface(%d, \"%s\")\n", ioif, device_id));\r\nif ((ioif >= if_max_interfaces) || (ioif < 0)) {\r\nprintk(KERN_CRIT "cris_request_io_interface: Bad interface "\r\n"%u submitted for %s\n",\r\nioif,\r\ndevice_id);\r\nreturn -EINVAL;\r\n}\r\nlocal_irq_save(flags);\r\nif (interfaces[ioif].used) {\r\nprintk(KERN_CRIT "cris_io_interface: Cannot allocate interface "\r\n"%s for %s, in use by %s\n",\r\ninterfaces[ioif].name,\r\ndevice_id,\r\ninterfaces[ioif].owner);\r\nres = -EBUSY;\r\ngoto exit;\r\n}\r\ngroup_set = interfaces[ioif].groups;\r\nwhile (NULL != (grp = get_group(group_set))) {\r\nunsigned int if_group_use = 0;\r\nswitch (grp->group) {\r\ncase group_a:\r\nif_group_use = interfaces[ioif].group_a;\r\nbreak;\r\ncase group_b:\r\nif_group_use = interfaces[ioif].group_b;\r\nbreak;\r\ncase group_c:\r\nif_group_use = interfaces[ioif].group_c;\r\nbreak;\r\ncase group_d:\r\nif_group_use = interfaces[ioif].group_d;\r\nbreak;\r\ncase group_e:\r\nif_group_use = interfaces[ioif].group_e;\r\nbreak;\r\ncase group_f:\r\nif_group_use = interfaces[ioif].group_f;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif (if_group_use & grp->used) {\r\nprintk(KERN_INFO "cris_request_io_interface: group "\r\n"%s needed by %s not available\n",\r\ngrp->name, interfaces[ioif].name);\r\nres = -EBUSY;\r\ngoto exit;\r\n}\r\ngroup_set = clear_group_from_set(group_set, grp);\r\n}\r\nif (((interfaces[ioif].gpio_g_in & gpio_in_pins) !=\r\ninterfaces[ioif].gpio_g_in) ||\r\n((interfaces[ioif].gpio_g_out & gpio_out_pins) !=\r\ninterfaces[ioif].gpio_g_out) ||\r\n((interfaces[ioif].gpio_b & gpio_pb_pins) !=\r\ninterfaces[ioif].gpio_b)) {\r\nprintk(KERN_CRIT "cris_request_io_interface: Could not get "\r\n"required pins for interface %u\n", ioif);\r\nres = -EBUSY;\r\ngoto exit;\r\n}\r\ngens = genconfig_shadow;\r\ngens_ii = gen_config_ii_shadow;\r\nset_gen_config = 1;\r\nswitch (ioif)\r\n{\r\ncase if_eth:\r\ncase if_serial_0:\r\nset_gen_config = 0;\r\nbreak;\r\ncase if_serial_1:\r\nset_gen_config_ii = 1;\r\nSETS(gens_ii, R_GEN_CONFIG_II, sermode1, async);\r\nbreak;\r\ncase if_serial_2:\r\nSETS(gens, R_GEN_CONFIG, ser2, select);\r\nbreak;\r\ncase if_serial_3:\r\nSETS(gens, R_GEN_CONFIG, ser3, select);\r\nset_gen_config_ii = 1;\r\nSETS(gens_ii, R_GEN_CONFIG_II, sermode3, async);\r\nbreak;\r\ncase if_sync_serial_1:\r\nset_gen_config_ii = 1;\r\nSETS(gens_ii, R_GEN_CONFIG_II, sermode1, sync);\r\nbreak;\r\ncase if_sync_serial_3:\r\nSETS(gens, R_GEN_CONFIG, ser3, select);\r\nset_gen_config_ii = 1;\r\nSETS(gens_ii, R_GEN_CONFIG_II, sermode3, sync);\r\nbreak;\r\ncase if_shared_ram:\r\nSETS(gens, R_GEN_CONFIG, mio, select);\r\nbreak;\r\ncase if_shared_ram_w:\r\nSETS(gens, R_GEN_CONFIG, mio_w, select);\r\nbreak;\r\ncase if_par_0:\r\nSETS(gens, R_GEN_CONFIG, par0, select);\r\nbreak;\r\ncase if_par_1:\r\nSETS(gens, R_GEN_CONFIG, par1, select);\r\nbreak;\r\ncase if_par_w:\r\nSETS(gens, R_GEN_CONFIG, par0, select);\r\nSETS(gens, R_GEN_CONFIG, par_w, select);\r\nbreak;\r\ncase if_scsi8_0:\r\nSETS(gens, R_GEN_CONFIG, scsi0, select);\r\nbreak;\r\ncase if_scsi8_1:\r\nSETS(gens, R_GEN_CONFIG, scsi1, select);\r\nbreak;\r\ncase if_scsi_w:\r\nSETS(gens, R_GEN_CONFIG, scsi0, select);\r\nSETS(gens, R_GEN_CONFIG, scsi0w, select);\r\nbreak;\r\ncase if_ata:\r\nSETS(gens, R_GEN_CONFIG, ata, select);\r\nbreak;\r\ncase if_csp:\r\ncase if_i2c:\r\nset_gen_config = 0;\r\nbreak;\r\ncase if_usb_1:\r\nSETS(gens, R_GEN_CONFIG, usb1, select);\r\nbreak;\r\ncase if_usb_2:\r\nSETS(gens, R_GEN_CONFIG, usb2, select);\r\nbreak;\r\ncase if_gpio_grp_a:\r\ncase if_gpio_grp_b:\r\ncase if_gpio_grp_c:\r\ncase if_gpio_grp_d:\r\ncase if_gpio_grp_e:\r\ncase if_gpio_grp_f:\r\nset_gen_config = 0;\r\nbreak;\r\ndefault:\r\nprintk(KERN_INFO "cris_request_io_interface: Bad interface "\r\n"%u submitted for %s\n",\r\nioif, device_id);\r\nres = -EBUSY;\r\ngoto exit;\r\n}\r\ngroup_set = interfaces[ioif].groups;\r\nwhile (NULL != (grp = get_group(group_set))) {\r\nunsigned int if_group_use = 0;\r\nswitch (grp->group) {\r\ncase group_a:\r\nif_group_use = interfaces[ioif].group_a;\r\nbreak;\r\ncase group_b:\r\nif_group_use = interfaces[ioif].group_b;\r\nbreak;\r\ncase group_c:\r\nif_group_use = interfaces[ioif].group_c;\r\nbreak;\r\ncase group_d:\r\nif_group_use = interfaces[ioif].group_d;\r\nbreak;\r\ncase group_e:\r\nif_group_use = interfaces[ioif].group_e;\r\nbreak;\r\ncase group_f:\r\nif_group_use = interfaces[ioif].group_f;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\ngrp->used |= if_group_use;\r\ngroup_set = clear_group_from_set(group_set, grp);\r\n}\r\ninterfaces[ioif].used = 1;\r\ninterfaces[ioif].owner = (char*)device_id;\r\nif (set_gen_config) {\r\nvolatile int i;\r\ngenconfig_shadow = gens;\r\n*R_GEN_CONFIG = genconfig_shadow;\r\nfor(i = 6; i > 0; i--)\r\nnop();\r\n}\r\nif (set_gen_config_ii) {\r\ngen_config_ii_shadow = gens_ii;\r\n*R_GEN_CONFIG_II = gen_config_ii_shadow;\r\n}\r\nDBG(printk(KERN_DEBUG "GPIO pins: available before: "\r\n"g_in=0x%08x g_out=0x%08x pb=0x%02x\n",\r\ngpio_in_pins, gpio_out_pins, gpio_pb_pins));\r\nDBG(printk(KERN_DEBUG\r\n"grabbing pins: g_in=0x%08x g_out=0x%08x pb=0x%02x\n",\r\ninterfaces[ioif].gpio_g_in,\r\ninterfaces[ioif].gpio_g_out,\r\ninterfaces[ioif].gpio_b));\r\ngpio_in_pins &= ~interfaces[ioif].gpio_g_in;\r\ngpio_out_pins &= ~interfaces[ioif].gpio_g_out;\r\ngpio_pb_pins &= ~interfaces[ioif].gpio_b;\r\nDBG(printk(KERN_DEBUG "GPIO pins: available after: "\r\n"g_in=0x%08x g_out=0x%08x pb=0x%02x\n",\r\ngpio_in_pins, gpio_out_pins, gpio_pb_pins));\r\nexit:\r\nlocal_irq_restore(flags);\r\nif (res == 0)\r\nnotify_watchers();\r\nreturn res;\r\n}\r\nvoid cris_free_io_interface(enum cris_io_interface ioif)\r\n{\r\nstruct if_group *grp;\r\nunsigned char group_set;\r\nunsigned long flags;\r\n(void)cris_io_interface_init();\r\nif ((ioif >= if_max_interfaces) || (ioif < 0)) {\r\nprintk(KERN_CRIT "cris_free_io_interface: Bad interface %u\n",\r\nioif);\r\nreturn;\r\n}\r\nlocal_irq_save(flags);\r\nif (!interfaces[ioif].used) {\r\nprintk(KERN_CRIT "cris_free_io_interface: Freeing free interface %u\n",\r\nioif);\r\nlocal_irq_restore(flags);\r\nreturn;\r\n}\r\ngroup_set = interfaces[ioif].groups;\r\nwhile (NULL != (grp = get_group(group_set))) {\r\nunsigned int if_group_use = 0;\r\nswitch (grp->group) {\r\ncase group_a:\r\nif_group_use = interfaces[ioif].group_a;\r\nbreak;\r\ncase group_b:\r\nif_group_use = interfaces[ioif].group_b;\r\nbreak;\r\ncase group_c:\r\nif_group_use = interfaces[ioif].group_c;\r\nbreak;\r\ncase group_d:\r\nif_group_use = interfaces[ioif].group_d;\r\nbreak;\r\ncase group_e:\r\nif_group_use = interfaces[ioif].group_e;\r\nbreak;\r\ncase group_f:\r\nif_group_use = interfaces[ioif].group_f;\r\nbreak;\r\ndefault:\r\nBUG_ON(1);\r\n}\r\nif ((grp->used & if_group_use) != if_group_use)\r\nBUG_ON(1);\r\ngrp->used = grp->used & ~if_group_use;\r\ngroup_set = clear_group_from_set(group_set, grp);\r\n}\r\ninterfaces[ioif].used = 0;\r\ninterfaces[ioif].owner = NULL;\r\nDBG(printk("GPIO pins: available before: g_in=0x%08x g_out=0x%08x pb=0x%02x\n",\r\ngpio_in_pins, gpio_out_pins, gpio_pb_pins));\r\nDBG(printk("freeing pins: g_in=0x%08x g_out=0x%08x pb=0x%02x\n",\r\ninterfaces[ioif].gpio_g_in,\r\ninterfaces[ioif].gpio_g_out,\r\ninterfaces[ioif].gpio_b));\r\ngpio_in_pins |= interfaces[ioif].gpio_g_in;\r\ngpio_out_pins |= interfaces[ioif].gpio_g_out;\r\ngpio_pb_pins |= interfaces[ioif].gpio_b;\r\nDBG(printk("GPIO pins: available after: g_in=0x%08x g_out=0x%08x pb=0x%02x\n",\r\ngpio_in_pins, gpio_out_pins, gpio_pb_pins));\r\nlocal_irq_restore(flags);\r\nnotify_watchers();\r\n}\r\nstatic inline unsigned int create_mask(const unsigned stop_bit)\r\n{\r\nif (stop_bit >= 32) {\r\nreturn 0xffffffff;\r\n}\r\nreturn (1<<stop_bit)-1;\r\n}\r\nint cris_io_interface_allocate_pins(const enum cris_io_interface ioif,\r\nconst char port,\r\nconst unsigned start_bit,\r\nconst unsigned stop_bit)\r\n{\r\nunsigned int i;\r\nunsigned int mask = 0;\r\nunsigned int tmp_mask;\r\nunsigned long int flags;\r\nenum cris_io_interface *owners;\r\n(void)cris_io_interface_init();\r\nDBG(printk("cris_io_interface_allocate_pins: if=%d port=%c start=%u stop=%u\n",\r\nioif, port, start_bit, stop_bit));\r\nif (!((start_bit <= stop_bit) &&\r\n((((port == 'a') || (port == 'b')) && (stop_bit < 8)) ||\r\n((port == 'g') && (stop_bit < 32))))) {\r\nreturn -EINVAL;\r\n}\r\nmask = create_mask(stop_bit + 1);\r\ntmp_mask = create_mask(start_bit);\r\nmask &= ~tmp_mask;\r\nDBG(printk("cris_io_interface_allocate_pins: port=%c start=%u stop=%u mask=0x%08x\n",\r\nport, start_bit, stop_bit, mask));\r\nlocal_irq_save(flags);\r\nswitch (port) {\r\ncase 'a':\r\nif ((gpio_pa_pins & mask) != mask) {\r\nlocal_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nowners = gpio_pa_owners;\r\ngpio_pa_pins &= ~mask;\r\nbreak;\r\ncase 'b':\r\nif ((gpio_pb_pins & mask) != mask) {\r\nlocal_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nowners = gpio_pb_owners;\r\ngpio_pb_pins &= ~mask;\r\nbreak;\r\ncase 'g':\r\nif (((gpio_in_pins & mask) != mask) ||\r\n((gpio_out_pins & mask) != mask)) {\r\nlocal_irq_restore(flags);\r\nreturn -EBUSY;\r\n}\r\nowners = gpio_pg_owners;\r\ngpio_in_pins &= ~mask;\r\ngpio_out_pins &= ~mask;\r\nbreak;\r\ndefault:\r\nlocal_irq_restore(flags);\r\nreturn -EINVAL;\r\n}\r\nfor (i = start_bit; i <= stop_bit; i++) {\r\nowners[i] = ioif;\r\n}\r\nlocal_irq_restore(flags);\r\nnotify_watchers();\r\nreturn 0;\r\n}\r\nint cris_io_interface_free_pins(const enum cris_io_interface ioif,\r\nconst char port,\r\nconst unsigned start_bit,\r\nconst unsigned stop_bit)\r\n{\r\nunsigned int i;\r\nunsigned int mask = 0;\r\nunsigned int tmp_mask;\r\nunsigned long int flags;\r\nenum cris_io_interface *owners;\r\n(void)cris_io_interface_init();\r\nif (!((start_bit <= stop_bit) &&\r\n((((port == 'a') || (port == 'b')) && (stop_bit < 8)) ||\r\n((port == 'g') && (stop_bit < 32))))) {\r\nreturn -EINVAL;\r\n}\r\nmask = create_mask(stop_bit + 1);\r\ntmp_mask = create_mask(start_bit);\r\nmask &= ~tmp_mask;\r\nDBG(printk("cris_io_interface_free_pins: port=%c start=%u stop=%u mask=0x%08x\n",\r\nport, start_bit, stop_bit, mask));\r\nlocal_irq_save(flags);\r\nswitch (port) {\r\ncase 'a':\r\nif ((~gpio_pa_pins & mask) != mask) {\r\nlocal_irq_restore(flags);\r\nprintk(KERN_CRIT "cris_io_interface_free_pins: Freeing free pins");\r\n}\r\nowners = gpio_pa_owners;\r\nbreak;\r\ncase 'b':\r\nif ((~gpio_pb_pins & mask) != mask) {\r\nlocal_irq_restore(flags);\r\nprintk(KERN_CRIT "cris_io_interface_free_pins: Freeing free pins");\r\n}\r\nowners = gpio_pb_owners;\r\nbreak;\r\ncase 'g':\r\nif (((~gpio_in_pins & mask) != mask) ||\r\n((~gpio_out_pins & mask) != mask)) {\r\nlocal_irq_restore(flags);\r\nprintk(KERN_CRIT "cris_io_interface_free_pins: Freeing free pins");\r\n}\r\nowners = gpio_pg_owners;\r\nbreak;\r\ndefault:\r\nowners = NULL;\r\n}\r\nfor (i = start_bit; i <= stop_bit; i++) {\r\nif (owners[i] != ioif) {\r\nprintk(KERN_CRIT "cris_io_interface_free_pins: Freeing unowned pins");\r\n}\r\n}\r\nswitch (port) {\r\ncase 'a':\r\ngpio_pa_pins |= mask;\r\nbreak;\r\ncase 'b':\r\ngpio_pb_pins |= mask;\r\nbreak;\r\ncase 'g':\r\ngpio_in_pins |= mask;\r\ngpio_out_pins |= mask;\r\nbreak;\r\n}\r\nfor (i = start_bit; i <= stop_bit; i++) {\r\nowners[i] = if_unclaimed;\r\n}\r\nlocal_irq_restore(flags);\r\nnotify_watchers();\r\nreturn 0;\r\n}\r\nint cris_io_interface_register_watcher(void (*notify)(const unsigned int gpio_in_available,\r\nconst unsigned int gpio_out_available,\r\nconst unsigned char pa_available,\r\nconst unsigned char pb_available))\r\n{\r\nstruct watcher *w;\r\n(void)cris_io_interface_init();\r\nif (NULL == notify) {\r\nreturn -EINVAL;\r\n}\r\nw = kmalloc(sizeof(*w), GFP_KERNEL);\r\nif (!w) {\r\nreturn -ENOMEM;\r\n}\r\nw->notify = notify;\r\nw->next = watchers;\r\nwatchers = w;\r\nw->notify((const unsigned int)gpio_in_pins,\r\n(const unsigned int)gpio_out_pins,\r\n(const unsigned char)gpio_pa_pins,\r\n(const unsigned char)gpio_pb_pins);\r\nreturn 0;\r\n}\r\nvoid cris_io_interface_delete_watcher(void (*notify)(const unsigned int gpio_in_available,\r\nconst unsigned int gpio_out_available,\r\nconst unsigned char pa_available,\r\nconst unsigned char pb_available))\r\n{\r\nstruct watcher *w = watchers, *prev = NULL;\r\n(void)cris_io_interface_init();\r\nwhile ((NULL != w) && (w->notify != notify)){\r\nprev = w;\r\nw = w->next;\r\n}\r\nif (NULL != w) {\r\nif (NULL != prev) {\r\nprev->next = w->next;\r\n} else {\r\nwatchers = w->next;\r\n}\r\nkfree(w);\r\nreturn;\r\n}\r\nprintk(KERN_WARNING "cris_io_interface_delete_watcher: Deleting unknown watcher 0x%p\n", notify);\r\n}\r\nstatic int cris_io_interface_init(void)\r\n{\r\nstatic int first = 1;\r\nint i;\r\nif (!first) {\r\nreturn 0;\r\n}\r\nfirst = 0;\r\nfor (i = 0; i<8; i++) {\r\ngpio_pa_owners[i] = if_unclaimed;\r\ngpio_pb_owners[i] = if_unclaimed;\r\ngpio_pg_owners[i] = if_unclaimed;\r\n}\r\nfor (; i<32; i++) {\r\ngpio_pg_owners[i] = if_unclaimed;\r\n}\r\nreturn 0;\r\n}
