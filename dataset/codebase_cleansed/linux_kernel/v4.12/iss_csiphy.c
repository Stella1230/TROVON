static void csiphy_lanes_config(struct iss_csiphy *phy)\r\n{\r\nunsigned int i;\r\nu32 reg;\r\nreg = iss_reg_read(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG);\r\nfor (i = 0; i < phy->max_data_lanes; i++) {\r\nreg &= ~(CSI2_COMPLEXIO_CFG_DATA_POL(i + 1) |\r\nCSI2_COMPLEXIO_CFG_DATA_POSITION_MASK(i + 1));\r\nreg |= (phy->lanes.data[i].pol ?\r\nCSI2_COMPLEXIO_CFG_DATA_POL(i + 1) : 0);\r\nreg |= (phy->lanes.data[i].pos <<\r\nCSI2_COMPLEXIO_CFG_DATA_POSITION_SHIFT(i + 1));\r\n}\r\nreg &= ~(CSI2_COMPLEXIO_CFG_CLOCK_POL |\r\nCSI2_COMPLEXIO_CFG_CLOCK_POSITION_MASK);\r\nreg |= phy->lanes.clk.pol ? CSI2_COMPLEXIO_CFG_CLOCK_POL : 0;\r\nreg |= phy->lanes.clk.pos << CSI2_COMPLEXIO_CFG_CLOCK_POSITION_SHIFT;\r\niss_reg_write(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG, reg);\r\n}\r\nstatic int csiphy_set_power(struct iss_csiphy *phy, u32 power)\r\n{\r\nu32 reg;\r\nu8 retry_count;\r\niss_reg_update(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG,\r\nCSI2_COMPLEXIO_CFG_PWD_CMD_MASK,\r\npower | CSI2_COMPLEXIO_CFG_PWR_AUTO);\r\nretry_count = 0;\r\ndo {\r\nudelay(1);\r\nreg = iss_reg_read(phy->iss, phy->cfg_regs, CSI2_COMPLEXIO_CFG)\r\n& CSI2_COMPLEXIO_CFG_PWD_STATUS_MASK;\r\nif (reg != power >> 2)\r\nretry_count++;\r\n} while ((reg != power >> 2) && (retry_count < 250));\r\nif (retry_count == 250) {\r\ndev_err(phy->iss->dev, "CSI2 CIO set power failed!\n");\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void csiphy_dphy_config(struct iss_csiphy *phy)\r\n{\r\nu32 reg;\r\nreg = phy->dphy.ths_term << REGISTER0_THS_TERM_SHIFT;\r\nreg |= phy->dphy.ths_settle << REGISTER0_THS_SETTLE_SHIFT;\r\niss_reg_write(phy->iss, phy->phy_regs, REGISTER0, reg);\r\nreg = phy->dphy.tclk_term << REGISTER1_TCLK_TERM_SHIFT;\r\nreg |= phy->dphy.tclk_miss << REGISTER1_CTRLCLK_DIV_FACTOR_SHIFT;\r\nreg |= phy->dphy.tclk_settle << REGISTER1_TCLK_SETTLE_SHIFT;\r\nreg |= 0xb8 << REGISTER1_DPHY_HS_SYNC_PATTERN_SHIFT;\r\niss_reg_write(phy->iss, phy->phy_regs, REGISTER1, reg);\r\n}\r\nint omap4iss_csiphy_config(struct iss_device *iss,\r\nstruct v4l2_subdev *csi2_subdev)\r\n{\r\nstruct iss_csi2_device *csi2 = v4l2_get_subdevdata(csi2_subdev);\r\nstruct iss_pipeline *pipe = to_iss_pipeline(&csi2_subdev->entity);\r\nstruct iss_v4l2_subdevs_group *subdevs = pipe->external->host_priv;\r\nstruct iss_csiphy_dphy_cfg csi2phy;\r\nint csi2_ddrclk_khz;\r\nstruct iss_csiphy_lanes_cfg *lanes;\r\nunsigned int used_lanes = 0;\r\nu32 cam_rx_ctrl;\r\nunsigned int i;\r\nlanes = &subdevs->bus.csi2.lanecfg;\r\nregmap_read(iss->syscon, 0x68, &cam_rx_ctrl);\r\nif (subdevs->interface == ISS_INTERFACE_CSI2A_PHY1) {\r\ncam_rx_ctrl &= ~(OMAP4_CAMERARX_CSI21_LANEENABLE_MASK |\r\nOMAP4_CAMERARX_CSI21_CAMMODE_MASK);\r\ncam_rx_ctrl |=\r\n0x1f << OMAP4_CAMERARX_CSI21_LANEENABLE_SHIFT;\r\ncam_rx_ctrl |= OMAP4_CAMERARX_CSI21_CTRLCLKEN_MASK;\r\n}\r\nif (subdevs->interface == ISS_INTERFACE_CSI2B_PHY2) {\r\ncam_rx_ctrl &= ~(OMAP4_CAMERARX_CSI22_LANEENABLE_MASK |\r\nOMAP4_CAMERARX_CSI22_CAMMODE_MASK);\r\ncam_rx_ctrl |=\r\n0x3 << OMAP4_CAMERARX_CSI22_LANEENABLE_SHIFT;\r\ncam_rx_ctrl |= OMAP4_CAMERARX_CSI22_CTRLCLKEN_MASK;\r\n}\r\nregmap_write(iss->syscon, 0x68, cam_rx_ctrl);\r\ncsi2->phy->used_data_lanes = 0;\r\nfor (i = 0; i < csi2->phy->max_data_lanes; i++) {\r\nif (lanes->data[i].pos == 0)\r\ncontinue;\r\nif (lanes->data[i].pol > 1 ||\r\nlanes->data[i].pos > (csi2->phy->max_data_lanes + 1))\r\nreturn -EINVAL;\r\nif (used_lanes & (1 << lanes->data[i].pos))\r\nreturn -EINVAL;\r\nused_lanes |= 1 << lanes->data[i].pos;\r\ncsi2->phy->used_data_lanes++;\r\n}\r\nif (lanes->clk.pol > 1 ||\r\nlanes->clk.pos > (csi2->phy->max_data_lanes + 1))\r\nreturn -EINVAL;\r\nif (lanes->clk.pos == 0 || used_lanes & (1 << lanes->clk.pos))\r\nreturn -EINVAL;\r\ncsi2_ddrclk_khz = pipe->external_rate / 1000\r\n/ (2 * csi2->phy->used_data_lanes)\r\n* pipe->external_bpp;\r\ncsi2phy.ths_term = DIV_ROUND_UP(25 * csi2_ddrclk_khz, 2000000) - 1;\r\ncsi2phy.ths_settle = DIV_ROUND_UP(90 * csi2_ddrclk_khz, 1000000) + 3;\r\ncsi2phy.tclk_term = TCLK_TERM;\r\ncsi2phy.tclk_miss = TCLK_MISS;\r\ncsi2phy.tclk_settle = TCLK_SETTLE;\r\nmutex_lock(&csi2->phy->mutex);\r\ncsi2->phy->dphy = csi2phy;\r\ncsi2->phy->lanes = *lanes;\r\nmutex_unlock(&csi2->phy->mutex);\r\nreturn 0;\r\n}\r\nint omap4iss_csiphy_acquire(struct iss_csiphy *phy)\r\n{\r\nint rval;\r\nmutex_lock(&phy->mutex);\r\nrval = omap4iss_csi2_reset(phy->csi2);\r\nif (rval)\r\ngoto done;\r\ncsiphy_dphy_config(phy);\r\ncsiphy_lanes_config(phy);\r\nrval = csiphy_set_power(phy, CSI2_COMPLEXIO_CFG_PWD_CMD_ON);\r\nif (rval)\r\ngoto done;\r\nphy->phy_in_use = 1;\r\ndone:\r\nmutex_unlock(&phy->mutex);\r\nreturn rval;\r\n}\r\nvoid omap4iss_csiphy_release(struct iss_csiphy *phy)\r\n{\r\nmutex_lock(&phy->mutex);\r\nif (phy->phy_in_use) {\r\ncsiphy_set_power(phy, CSI2_COMPLEXIO_CFG_PWD_CMD_OFF);\r\nphy->phy_in_use = 0;\r\n}\r\nmutex_unlock(&phy->mutex);\r\n}\r\nint omap4iss_csiphy_init(struct iss_device *iss)\r\n{\r\nstruct iss_csiphy *phy1 = &iss->csiphy1;\r\nstruct iss_csiphy *phy2 = &iss->csiphy2;\r\nphy1->iss = iss;\r\nphy1->csi2 = &iss->csi2a;\r\nphy1->max_data_lanes = ISS_CSIPHY1_NUM_DATA_LANES;\r\nphy1->used_data_lanes = 0;\r\nphy1->cfg_regs = OMAP4_ISS_MEM_CSI2_A_REGS1;\r\nphy1->phy_regs = OMAP4_ISS_MEM_CAMERARX_CORE1;\r\nmutex_init(&phy1->mutex);\r\nphy2->iss = iss;\r\nphy2->csi2 = &iss->csi2b;\r\nphy2->max_data_lanes = ISS_CSIPHY2_NUM_DATA_LANES;\r\nphy2->used_data_lanes = 0;\r\nphy2->cfg_regs = OMAP4_ISS_MEM_CSI2_B_REGS1;\r\nphy2->phy_regs = OMAP4_ISS_MEM_CAMERARX_CORE2;\r\nmutex_init(&phy2->mutex);\r\nreturn 0;\r\n}
