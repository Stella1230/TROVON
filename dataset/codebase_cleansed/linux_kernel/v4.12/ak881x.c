static int reg_read(struct i2c_client *client, const u8 reg)\r\n{\r\nreturn i2c_smbus_read_byte_data(client, reg);\r\n}\r\nstatic int reg_write(struct i2c_client *client, const u8 reg,\r\nconst u8 data)\r\n{\r\nreturn i2c_smbus_write_byte_data(client, reg, data);\r\n}\r\nstatic int reg_set(struct i2c_client *client, const u8 reg,\r\nconst u8 data, u8 mask)\r\n{\r\nint ret = reg_read(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn reg_write(client, reg, (ret & ~mask) | (data & mask));\r\n}\r\nstatic struct ak881x *to_ak881x(const struct i2c_client *client)\r\n{\r\nreturn container_of(i2c_get_clientdata(client), struct ak881x, subdev);\r\n}\r\nstatic int ak881x_g_register(struct v4l2_subdev *sd,\r\nstruct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0x26)\r\nreturn -EINVAL;\r\nreg->size = 1;\r\nreg->val = reg_read(client, reg->reg);\r\nif (reg->val > 0xffff)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ak881x_s_register(struct v4l2_subdev *sd,\r\nconst struct v4l2_dbg_register *reg)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nif (reg->reg > 0x26)\r\nreturn -EINVAL;\r\nif (reg_write(client, reg->reg, reg->val) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int ak881x_fill_fmt(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *format)\r\n{\r\nstruct v4l2_mbus_framefmt *mf = &format->format;\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nif (format->pad)\r\nreturn -EINVAL;\r\nv4l_bound_align_image(&mf->width, 0, 720, 2,\r\n&mf->height, 0, ak881x->lines, 1, 0);\r\nmf->field = V4L2_FIELD_INTERLACED;\r\nmf->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nmf->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\nreturn 0;\r\n}\r\nstatic int ak881x_enum_mbus_code(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nif (code->pad || code->index)\r\nreturn -EINVAL;\r\ncode->code = MEDIA_BUS_FMT_YUYV8_2X8;\r\nreturn 0;\r\n}\r\nstatic int ak881x_get_selection(struct v4l2_subdev *sd,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_selection *sel)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nif (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)\r\nreturn -EINVAL;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nsel->r.left = 0;\r\nsel->r.top = 0;\r\nsel->r.width = 720;\r\nsel->r.height = ak881x->lines;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int ak881x_s_std_output(struct v4l2_subdev *sd, v4l2_std_id std)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nu8 vp1;\r\nif (std == V4L2_STD_NTSC_443) {\r\nvp1 = 3;\r\nak881x->lines = 480;\r\n} else if (std == V4L2_STD_PAL_M) {\r\nvp1 = 5;\r\nak881x->lines = 480;\r\n} else if (std == V4L2_STD_PAL_60) {\r\nvp1 = 7;\r\nak881x->lines = 480;\r\n} else if (std & V4L2_STD_NTSC) {\r\nvp1 = 0;\r\nak881x->lines = 480;\r\n} else if (std & V4L2_STD_PAL) {\r\nvp1 = 0xf;\r\nak881x->lines = 576;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nreg_set(client, AK881X_VIDEO_PROCESS1, vp1, 0xf);\r\nreturn 0;\r\n}\r\nstatic int ak881x_s_stream(struct v4l2_subdev *sd, int enable)\r\n{\r\nstruct i2c_client *client = v4l2_get_subdevdata(sd);\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nif (enable) {\r\nu8 dac;\r\nif (ak881x->pdata->flags & AK881X_COMPONENT)\r\ndac = 3;\r\nelse\r\ndac = 4;\r\nreg_write(client, AK881X_DAC_MODE, dac);\r\ndev_dbg(&client->dev, "chip status 0x%x\n",\r\nreg_read(client, AK881X_STATUS));\r\n} else {\r\nreg_write(client, AK881X_DAC_MODE, 0);\r\ndev_dbg(&client->dev, "chip status 0x%x\n",\r\nreg_read(client, AK881X_STATUS));\r\n}\r\nreturn 0;\r\n}\r\nstatic int ak881x_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *did)\r\n{\r\nstruct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);\r\nstruct ak881x *ak881x;\r\nu8 ifmode, data;\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA)) {\r\ndev_warn(&adapter->dev,\r\n"I2C-Adapter doesn't support I2C_FUNC_SMBUS_WORD\n");\r\nreturn -EIO;\r\n}\r\nak881x = devm_kzalloc(&client->dev, sizeof(*ak881x), GFP_KERNEL);\r\nif (!ak881x)\r\nreturn -ENOMEM;\r\nv4l2_i2c_subdev_init(&ak881x->subdev, client, &ak881x_subdev_ops);\r\ndata = reg_read(client, AK881X_DEVICE_ID);\r\nswitch (data) {\r\ncase 0x13:\r\ncase 0x14:\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev,\r\n"No ak881x chip detected, register read %x\n", data);\r\nreturn -ENODEV;\r\n}\r\nak881x->revision = reg_read(client, AK881X_DEVICE_REVISION);\r\nak881x->pdata = client->dev.platform_data;\r\nif (ak881x->pdata) {\r\nif (ak881x->pdata->flags & AK881X_FIELD)\r\nifmode = 4;\r\nelse\r\nifmode = 0;\r\nswitch (ak881x->pdata->flags & AK881X_IF_MODE_MASK) {\r\ncase AK881X_IF_MODE_BT656:\r\nifmode |= 1;\r\nbreak;\r\ncase AK881X_IF_MODE_MASTER:\r\nifmode |= 2;\r\nbreak;\r\ncase AK881X_IF_MODE_SLAVE:\r\ndefault:\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "IF mode %x\n", ifmode);\r\nreg_write(client, AK881X_INTERFACE_MODE, ifmode | (20 << 3));\r\n}\r\nak881x->lines = 480;\r\ndev_info(&client->dev, "Detected an ak881x chip ID %x, revision %x\n",\r\ndata, ak881x->revision);\r\nreturn 0;\r\n}\r\nstatic int ak881x_remove(struct i2c_client *client)\r\n{\r\nstruct ak881x *ak881x = to_ak881x(client);\r\nv4l2_device_unregister_subdev(&ak881x->subdev);\r\nreturn 0;\r\n}
