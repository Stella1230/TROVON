void picolcd_leds_set(struct picolcd_data *data)\r\n{\r\nstruct hid_report *report;\r\nunsigned long flags;\r\nif (!data->led[0])\r\nreturn;\r\nreport = picolcd_out_report(REPORT_LED_STATE, data->hdev);\r\nif (!report || report->maxfield != 1 || report->field[0]->report_count != 1)\r\nreturn;\r\nspin_lock_irqsave(&data->lock, flags);\r\nhid_set_field(report->field[0], 0, data->led_state);\r\nif (!(data->status & PICOLCD_FAILED))\r\nhid_hw_request(data->hdev, report, HID_REQ_SET_REPORT);\r\nspin_unlock_irqrestore(&data->lock, flags);\r\n}\r\nstatic void picolcd_led_set_brightness(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nstruct device *dev;\r\nstruct hid_device *hdev;\r\nstruct picolcd_data *data;\r\nint i, state = 0;\r\ndev = led_cdev->dev->parent;\r\nhdev = to_hid_device(dev);\r\ndata = hid_get_drvdata(hdev);\r\nif (!data)\r\nreturn;\r\nfor (i = 0; i < 8; i++) {\r\nif (led_cdev != data->led[i])\r\ncontinue;\r\nstate = (data->led_state >> i) & 1;\r\nif (value == LED_OFF && state) {\r\ndata->led_state &= ~(1 << i);\r\npicolcd_leds_set(data);\r\n} else if (value != LED_OFF && !state) {\r\ndata->led_state |= 1 << i;\r\npicolcd_leds_set(data);\r\n}\r\nbreak;\r\n}\r\n}\r\nstatic enum led_brightness picolcd_led_get_brightness(struct led_classdev *led_cdev)\r\n{\r\nstruct device *dev;\r\nstruct hid_device *hdev;\r\nstruct picolcd_data *data;\r\nint i, value = 0;\r\ndev = led_cdev->dev->parent;\r\nhdev = to_hid_device(dev);\r\ndata = hid_get_drvdata(hdev);\r\nfor (i = 0; i < 8; i++)\r\nif (led_cdev == data->led[i]) {\r\nvalue = (data->led_state >> i) & 1;\r\nbreak;\r\n}\r\nreturn value ? LED_FULL : LED_OFF;\r\n}\r\nint picolcd_init_leds(struct picolcd_data *data, struct hid_report *report)\r\n{\r\nstruct device *dev = &data->hdev->dev;\r\nstruct led_classdev *led;\r\nsize_t name_sz = strlen(dev_name(dev)) + 8;\r\nchar *name;\r\nint i, ret = 0;\r\nif (!report)\r\nreturn -ENODEV;\r\nif (report->maxfield != 1 || report->field[0]->report_count != 1 ||\r\nreport->field[0]->report_size != 8) {\r\ndev_err(dev, "unsupported LED_STATE report");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < 8; i++) {\r\nled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\r\nif (!led) {\r\ndev_err(dev, "can't allocate memory for LED %d\n", i);\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nname = (void *)(&led[1]);\r\nsnprintf(name, name_sz, "%s::GPO%d", dev_name(dev), i);\r\nled->name = name;\r\nled->brightness = 0;\r\nled->max_brightness = 1;\r\nled->brightness_get = picolcd_led_get_brightness;\r\nled->brightness_set = picolcd_led_set_brightness;\r\ndata->led[i] = led;\r\nret = led_classdev_register(dev, data->led[i]);\r\nif (ret) {\r\ndata->led[i] = NULL;\r\nkfree(led);\r\ndev_err(dev, "can't register LED %d\n", i);\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (i = 0; i < 8; i++)\r\nif (data->led[i]) {\r\nled = data->led[i];\r\ndata->led[i] = NULL;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\nreturn ret;\r\n}\r\nvoid picolcd_exit_leds(struct picolcd_data *data)\r\n{\r\nstruct led_classdev *led;\r\nint i;\r\nfor (i = 0; i < 8; i++) {\r\nled = data->led[i];\r\ndata->led[i] = NULL;\r\nif (!led)\r\ncontinue;\r\nled_classdev_unregister(led);\r\nkfree(led);\r\n}\r\n}
