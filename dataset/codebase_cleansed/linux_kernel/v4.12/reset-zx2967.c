static int zx2967_reset_act(struct reset_controller_dev *rcdev,\r\nunsigned long id, bool assert)\r\n{\r\nstruct zx2967_reset *reset = NULL;\r\nint bank = id / 32;\r\nint offset = id % 32;\r\nu32 reg;\r\nunsigned long flags;\r\nreset = container_of(rcdev, struct zx2967_reset, rcdev);\r\nspin_lock_irqsave(&reset->lock, flags);\r\nreg = readl_relaxed(reset->reg_base + (bank * 4));\r\nif (assert)\r\nreg &= ~BIT(offset);\r\nelse\r\nreg |= BIT(offset);\r\nwritel_relaxed(reg, reset->reg_base + (bank * 4));\r\nspin_unlock_irqrestore(&reset->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int zx2967_reset_assert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nreturn zx2967_reset_act(rcdev, id, true);\r\n}\r\nstatic int zx2967_reset_deassert(struct reset_controller_dev *rcdev,\r\nunsigned long id)\r\n{\r\nreturn zx2967_reset_act(rcdev, id, false);\r\n}\r\nstatic int zx2967_reset_probe(struct platform_device *pdev)\r\n{\r\nstruct zx2967_reset *reset;\r\nstruct resource *res;\r\nreset = devm_kzalloc(&pdev->dev, sizeof(*reset), GFP_KERNEL);\r\nif (!reset)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nreset->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(reset->reg_base))\r\nreturn PTR_ERR(reset->reg_base);\r\nspin_lock_init(&reset->lock);\r\nreset->rcdev.owner = THIS_MODULE;\r\nreset->rcdev.nr_resets = resource_size(res) * 8;\r\nreset->rcdev.ops = &zx2967_reset_ops;\r\nreset->rcdev.of_node = pdev->dev.of_node;\r\nreturn devm_reset_controller_register(&pdev->dev, &reset->rcdev);\r\n}
