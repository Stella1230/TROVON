static inline struct f_hidg *func_to_hidg(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct f_hidg, func);\r\n}\r\nstatic ssize_t f_hidg_read(struct file *file, char __user *buffer,\r\nsize_t count, loff_t *ptr)\r\n{\r\nstruct f_hidg *hidg = file->private_data;\r\nstruct f_hidg_req_list *list;\r\nstruct usb_request *req;\r\nunsigned long flags;\r\nint ret;\r\nif (!count)\r\nreturn 0;\r\nif (!access_ok(VERIFY_WRITE, buffer, count))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&hidg->read_spinlock, flags);\r\n#define READ_COND (!list_empty(&hidg->completed_out_req))\r\nwhile (!READ_COND) {\r\nspin_unlock_irqrestore(&hidg->read_spinlock, flags);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible(hidg->read_queue, READ_COND))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&hidg->read_spinlock, flags);\r\n}\r\nlist = list_first_entry(&hidg->completed_out_req,\r\nstruct f_hidg_req_list, list);\r\nlist_del(&list->list);\r\nreq = list->req;\r\ncount = min_t(unsigned int, count, req->actual - list->pos);\r\nspin_unlock_irqrestore(&hidg->read_spinlock, flags);\r\ncount -= copy_to_user(buffer, req->buf + list->pos, count);\r\nlist->pos += count;\r\nif (list->pos == req->actual) {\r\nkfree(list);\r\nreq->length = hidg->report_length;\r\nret = usb_ep_queue(hidg->out_ep, req, GFP_KERNEL);\r\nif (ret < 0) {\r\nfree_ep_req(hidg->out_ep, req);\r\nreturn ret;\r\n}\r\n} else {\r\nspin_lock_irqsave(&hidg->read_spinlock, flags);\r\nlist_add(&list->list, &hidg->completed_out_req);\r\nspin_unlock_irqrestore(&hidg->read_spinlock, flags);\r\nwake_up(&hidg->read_queue);\r\n}\r\nreturn count;\r\n}\r\nstatic void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_hidg *hidg = (struct f_hidg *)ep->driver_data;\r\nunsigned long flags;\r\nif (req->status != 0) {\r\nERROR(hidg->func.config->cdev,\r\n"End Point Request ERROR: %d\n", req->status);\r\n}\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\nhidg->write_pending = 0;\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\nwake_up(&hidg->write_queue);\r\n}\r\nstatic ssize_t f_hidg_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *offp)\r\n{\r\nstruct f_hidg *hidg = file->private_data;\r\nstruct usb_request *req;\r\nunsigned long flags;\r\nssize_t status = -ENOMEM;\r\nif (!access_ok(VERIFY_READ, buffer, count))\r\nreturn -EFAULT;\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\n#define WRITE_COND (!hidg->write_pending)\r\ntry_again:\r\nwhile (!WRITE_COND) {\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (wait_event_interruptible_exclusive(\r\nhidg->write_queue, WRITE_COND))\r\nreturn -ERESTARTSYS;\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\n}\r\nhidg->write_pending = 1;\r\nreq = hidg->req;\r\ncount = min_t(unsigned, count, hidg->report_length);\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\nstatus = copy_from_user(req->buf, buffer, count);\r\nif (status != 0) {\r\nERROR(hidg->func.config->cdev,\r\n"copy_from_user error\n");\r\nstatus = -EINVAL;\r\ngoto release_write_pending;\r\n}\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\nif (!hidg->req) {\r\nfree_ep_req(hidg->in_ep, req);\r\ngoto try_again;\r\n}\r\nreq->status = 0;\r\nreq->zero = 0;\r\nreq->length = count;\r\nreq->complete = f_hidg_req_complete;\r\nreq->context = hidg;\r\nstatus = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);\r\nif (status < 0) {\r\nERROR(hidg->func.config->cdev,\r\n"usb_ep_queue error on int endpoint %zd\n", status);\r\ngoto release_write_pending_unlocked;\r\n} else {\r\nstatus = count;\r\n}\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\nreturn status;\r\nrelease_write_pending:\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\nrelease_write_pending_unlocked:\r\nhidg->write_pending = 0;\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\nwake_up(&hidg->write_queue);\r\nreturn status;\r\n}\r\nstatic unsigned int f_hidg_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct f_hidg *hidg = file->private_data;\r\nunsigned int ret = 0;\r\npoll_wait(file, &hidg->read_queue, wait);\r\npoll_wait(file, &hidg->write_queue, wait);\r\nif (WRITE_COND)\r\nret |= POLLOUT | POLLWRNORM;\r\nif (READ_COND)\r\nret |= POLLIN | POLLRDNORM;\r\nreturn ret;\r\n}\r\nstatic int f_hidg_release(struct inode *inode, struct file *fd)\r\n{\r\nfd->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic int f_hidg_open(struct inode *inode, struct file *fd)\r\n{\r\nstruct f_hidg *hidg =\r\ncontainer_of(inode->i_cdev, struct f_hidg, cdev);\r\nfd->private_data = hidg;\r\nreturn 0;\r\n}\r\nstatic inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,\r\nunsigned length)\r\n{\r\nreturn alloc_ep_req(ep, length);\r\n}\r\nstatic void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct f_hidg *hidg = (struct f_hidg *) req->context;\r\nstruct usb_composite_dev *cdev = hidg->func.config->cdev;\r\nstruct f_hidg_req_list *req_list;\r\nunsigned long flags;\r\nswitch (req->status) {\r\ncase 0:\r\nreq_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);\r\nif (!req_list) {\r\nERROR(cdev, "Unable to allocate mem for req_list\n");\r\ngoto free_req;\r\n}\r\nreq_list->req = req;\r\nspin_lock_irqsave(&hidg->read_spinlock, flags);\r\nlist_add_tail(&req_list->list, &hidg->completed_out_req);\r\nspin_unlock_irqrestore(&hidg->read_spinlock, flags);\r\nwake_up(&hidg->read_queue);\r\nbreak;\r\ndefault:\r\nERROR(cdev, "Set report failed %d\n", req->status);\r\ncase -ECONNABORTED:\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nfree_req:\r\nfree_ep_req(ep, req);\r\nreturn;\r\n}\r\n}\r\nstatic int hidg_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nint status = 0;\r\n__u16 value, length;\r\nvalue = __le16_to_cpu(ctrl->wValue);\r\nlength = __le16_to_cpu(ctrl->wLength);\r\nVDBG(cdev,\r\n"%s crtl_request : bRequestType:0x%x bRequest:0x%x Value:0x%x\n",\r\n__func__, ctrl->bRequestType, ctrl->bRequest, value);\r\nswitch ((ctrl->bRequestType << 8) | ctrl->bRequest) {\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_GET_REPORT):\r\nVDBG(cdev, "get_report\n");\r\nlength = min_t(unsigned, length, hidg->report_length);\r\nmemset(req->buf, 0x0, length);\r\ngoto respond;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_GET_PROTOCOL):\r\nVDBG(cdev, "get_protocol\n");\r\ngoto stall;\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_SET_REPORT):\r\nVDBG(cdev, "set_report | wLength=%d\n", ctrl->wLength);\r\ngoto stall;\r\nbreak;\r\ncase ((USB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE) << 8\r\n| HID_REQ_SET_PROTOCOL):\r\nVDBG(cdev, "set_protocol\n");\r\ngoto stall;\r\nbreak;\r\ncase ((USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_INTERFACE) << 8\r\n| USB_REQ_GET_DESCRIPTOR):\r\nswitch (value >> 8) {\r\ncase HID_DT_HID:\r\n{\r\nstruct hid_descriptor hidg_desc_copy = hidg_desc;\r\nVDBG(cdev, "USB_REQ_GET_DESCRIPTOR: HID\n");\r\nhidg_desc_copy.desc[0].bDescriptorType = HID_DT_REPORT;\r\nhidg_desc_copy.desc[0].wDescriptorLength =\r\ncpu_to_le16(hidg->report_desc_length);\r\nlength = min_t(unsigned short, length,\r\nhidg_desc_copy.bLength);\r\nmemcpy(req->buf, &hidg_desc_copy, length);\r\ngoto respond;\r\nbreak;\r\n}\r\ncase HID_DT_REPORT:\r\nVDBG(cdev, "USB_REQ_GET_DESCRIPTOR: REPORT\n");\r\nlength = min_t(unsigned short, length,\r\nhidg->report_desc_length);\r\nmemcpy(req->buf, hidg->report_desc, length);\r\ngoto respond;\r\nbreak;\r\ndefault:\r\nVDBG(cdev, "Unknown descriptor request 0x%x\n",\r\nvalue >> 8);\r\ngoto stall;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nVDBG(cdev, "Unknown request 0x%x\n",\r\nctrl->bRequest);\r\ngoto stall;\r\nbreak;\r\n}\r\nstall:\r\nreturn -EOPNOTSUPP;\r\nrespond:\r\nreq->zero = 0;\r\nreq->length = length;\r\nstatus = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (status < 0)\r\nERROR(cdev, "usb_ep_queue error on ep0 %d\n", value);\r\nreturn status;\r\n}\r\nstatic void hidg_disable(struct usb_function *f)\r\n{\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nstruct f_hidg_req_list *list, *next;\r\nunsigned long flags;\r\nusb_ep_disable(hidg->in_ep);\r\nusb_ep_disable(hidg->out_ep);\r\nspin_lock_irqsave(&hidg->read_spinlock, flags);\r\nlist_for_each_entry_safe(list, next, &hidg->completed_out_req, list) {\r\nfree_ep_req(hidg->out_ep, list->req);\r\nlist_del(&list->list);\r\nkfree(list);\r\n}\r\nspin_unlock_irqrestore(&hidg->read_spinlock, flags);\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\nif (!hidg->write_pending) {\r\nfree_ep_req(hidg->in_ep, hidg->req);\r\nhidg->write_pending = 1;\r\n}\r\nhidg->req = NULL;\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\n}\r\nstatic int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\r\n{\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nstruct usb_request *req_in = NULL;\r\nunsigned long flags;\r\nint i, status = 0;\r\nVDBG(cdev, "hidg_set_alt intf:%d alt:%d\n", intf, alt);\r\nif (hidg->in_ep != NULL) {\r\nusb_ep_disable(hidg->in_ep);\r\nstatus = config_ep_by_speed(f->config->cdev->gadget, f,\r\nhidg->in_ep);\r\nif (status) {\r\nERROR(cdev, "config_ep_by_speed FAILED!\n");\r\ngoto fail;\r\n}\r\nstatus = usb_ep_enable(hidg->in_ep);\r\nif (status < 0) {\r\nERROR(cdev, "Enable IN endpoint FAILED!\n");\r\ngoto fail;\r\n}\r\nhidg->in_ep->driver_data = hidg;\r\nreq_in = hidg_alloc_ep_req(hidg->in_ep, hidg->report_length);\r\nif (!req_in) {\r\nstatus = -ENOMEM;\r\ngoto disable_ep_in;\r\n}\r\n}\r\nif (hidg->out_ep != NULL) {\r\nusb_ep_disable(hidg->out_ep);\r\nstatus = config_ep_by_speed(f->config->cdev->gadget, f,\r\nhidg->out_ep);\r\nif (status) {\r\nERROR(cdev, "config_ep_by_speed FAILED!\n");\r\ngoto free_req_in;\r\n}\r\nstatus = usb_ep_enable(hidg->out_ep);\r\nif (status < 0) {\r\nERROR(cdev, "Enable OUT endpoint FAILED!\n");\r\ngoto free_req_in;\r\n}\r\nhidg->out_ep->driver_data = hidg;\r\nfor (i = 0; i < hidg->qlen && status == 0; i++) {\r\nstruct usb_request *req =\r\nhidg_alloc_ep_req(hidg->out_ep,\r\nhidg->report_length);\r\nif (req) {\r\nreq->complete = hidg_set_report_complete;\r\nreq->context = hidg;\r\nstatus = usb_ep_queue(hidg->out_ep, req,\r\nGFP_ATOMIC);\r\nif (status) {\r\nERROR(cdev, "%s queue req --> %d\n",\r\nhidg->out_ep->name, status);\r\nfree_ep_req(hidg->out_ep, req);\r\n}\r\n} else {\r\nstatus = -ENOMEM;\r\ngoto disable_out_ep;\r\n}\r\n}\r\n}\r\nif (hidg->in_ep != NULL) {\r\nspin_lock_irqsave(&hidg->write_spinlock, flags);\r\nhidg->req = req_in;\r\nhidg->write_pending = 0;\r\nspin_unlock_irqrestore(&hidg->write_spinlock, flags);\r\nwake_up(&hidg->write_queue);\r\n}\r\nreturn 0;\r\ndisable_out_ep:\r\nusb_ep_disable(hidg->out_ep);\r\nfree_req_in:\r\nif (req_in)\r\nfree_ep_req(hidg->in_ep, req_in);\r\ndisable_ep_in:\r\nif (hidg->in_ep)\r\nusb_ep_disable(hidg->in_ep);\r\nfail:\r\nreturn status;\r\n}\r\nstatic int hidg_bind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct usb_ep *ep;\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\nstruct usb_string *us;\r\nstruct device *device;\r\nint status;\r\ndev_t dev;\r\nus = usb_gstrings_attach(c->cdev, ct_func_strings,\r\nARRAY_SIZE(ct_func_string_defs));\r\nif (IS_ERR(us))\r\nreturn PTR_ERR(us);\r\nhidg_interface_desc.iInterface = us[CT_FUNC_HID_IDX].id;\r\nstatus = usb_interface_id(c, f);\r\nif (status < 0)\r\ngoto fail;\r\nhidg_interface_desc.bInterfaceNumber = status;\r\nstatus = -ENODEV;\r\nep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_in_ep_desc);\r\nif (!ep)\r\ngoto fail;\r\nhidg->in_ep = ep;\r\nep = usb_ep_autoconfig(c->cdev->gadget, &hidg_fs_out_ep_desc);\r\nif (!ep)\r\ngoto fail;\r\nhidg->out_ep = ep;\r\nhidg_interface_desc.bInterfaceSubClass = hidg->bInterfaceSubClass;\r\nhidg_interface_desc.bInterfaceProtocol = hidg->bInterfaceProtocol;\r\nhidg_ss_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_ss_in_comp_desc.wBytesPerInterval =\r\ncpu_to_le16(hidg->report_length);\r\nhidg_hs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_fs_in_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_ss_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_ss_out_comp_desc.wBytesPerInterval =\r\ncpu_to_le16(hidg->report_length);\r\nhidg_hs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_fs_out_ep_desc.wMaxPacketSize = cpu_to_le16(hidg->report_length);\r\nhidg_desc.desc[0].bDescriptorType = HID_DT_REPORT;\r\nhidg_desc.desc[0].wDescriptorLength =\r\ncpu_to_le16(hidg->report_desc_length);\r\nhidg_hs_in_ep_desc.bEndpointAddress =\r\nhidg_fs_in_ep_desc.bEndpointAddress;\r\nhidg_hs_out_ep_desc.bEndpointAddress =\r\nhidg_fs_out_ep_desc.bEndpointAddress;\r\nhidg_ss_in_ep_desc.bEndpointAddress =\r\nhidg_fs_in_ep_desc.bEndpointAddress;\r\nhidg_ss_out_ep_desc.bEndpointAddress =\r\nhidg_fs_out_ep_desc.bEndpointAddress;\r\nstatus = usb_assign_descriptors(f, hidg_fs_descriptors,\r\nhidg_hs_descriptors, hidg_ss_descriptors, NULL);\r\nif (status)\r\ngoto fail;\r\nspin_lock_init(&hidg->write_spinlock);\r\nhidg->write_pending = 1;\r\nhidg->req = NULL;\r\nspin_lock_init(&hidg->read_spinlock);\r\ninit_waitqueue_head(&hidg->write_queue);\r\ninit_waitqueue_head(&hidg->read_queue);\r\nINIT_LIST_HEAD(&hidg->completed_out_req);\r\ncdev_init(&hidg->cdev, &f_hidg_fops);\r\ndev = MKDEV(major, hidg->minor);\r\nstatus = cdev_add(&hidg->cdev, dev, 1);\r\nif (status)\r\ngoto fail_free_descs;\r\ndevice = device_create(hidg_class, NULL, dev, NULL,\r\n"%s%d", "hidg", hidg->minor);\r\nif (IS_ERR(device)) {\r\nstatus = PTR_ERR(device);\r\ngoto del;\r\n}\r\nreturn 0;\r\ndel:\r\ncdev_del(&hidg->cdev);\r\nfail_free_descs:\r\nusb_free_all_descriptors(f);\r\nfail:\r\nERROR(f->config->cdev, "hidg_bind FAILED\n");\r\nif (hidg->req != NULL)\r\nfree_ep_req(hidg->in_ep, hidg->req);\r\nreturn status;\r\n}\r\nstatic inline int hidg_get_minor(void)\r\n{\r\nint ret;\r\nret = ida_simple_get(&hidg_ida, 0, 0, GFP_KERNEL);\r\nif (ret >= HIDG_MINORS) {\r\nida_simple_remove(&hidg_ida, ret);\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline struct f_hid_opts *to_f_hid_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_hid_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void hid_attr_release(struct config_item *item)\r\n{\r\nstruct f_hid_opts *opts = to_f_hid_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic ssize_t f_hid_opts_report_desc_show(struct config_item *item, char *page)\r\n{\r\nstruct f_hid_opts *opts = to_f_hid_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = opts->report_desc_length;\r\nmemcpy(page, opts->report_desc, opts->report_desc_length);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_hid_opts_report_desc_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_hid_opts *opts = to_f_hid_opts(item);\r\nint ret = -EBUSY;\r\nchar *d;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt)\r\ngoto end;\r\nif (len > PAGE_SIZE) {\r\nret = -ENOSPC;\r\ngoto end;\r\n}\r\nd = kmemdup(page, len, GFP_KERNEL);\r\nif (!d) {\r\nret = -ENOMEM;\r\ngoto end;\r\n}\r\nkfree(opts->report_desc);\r\nopts->report_desc = d;\r\nopts->report_desc_length = len;\r\nopts->report_desc_alloc = true;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t f_hid_opts_dev_show(struct config_item *item, char *page)\r\n{\r\nstruct f_hid_opts *opts = to_f_hid_opts(item);\r\nreturn sprintf(page, "%d:%d\n", major, opts->minor);\r\n}\r\nstatic inline void hidg_put_minor(int minor)\r\n{\r\nida_simple_remove(&hidg_ida, minor);\r\n}\r\nstatic void hidg_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_hid_opts *opts;\r\nopts = container_of(f, struct f_hid_opts, func_inst);\r\nmutex_lock(&hidg_ida_lock);\r\nhidg_put_minor(opts->minor);\r\nif (ida_is_empty(&hidg_ida))\r\nghid_cleanup();\r\nmutex_unlock(&hidg_ida_lock);\r\nif (opts->report_desc_alloc)\r\nkfree(opts->report_desc);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *hidg_alloc_inst(void)\r\n{\r\nstruct f_hid_opts *opts;\r\nstruct usb_function_instance *ret;\r\nint status = 0;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = hidg_free_inst;\r\nret = &opts->func_inst;\r\nmutex_lock(&hidg_ida_lock);\r\nif (ida_is_empty(&hidg_ida)) {\r\nstatus = ghid_setup(NULL, HIDG_MINORS);\r\nif (status) {\r\nret = ERR_PTR(status);\r\nkfree(opts);\r\ngoto unlock;\r\n}\r\n}\r\nopts->minor = hidg_get_minor();\r\nif (opts->minor < 0) {\r\nret = ERR_PTR(opts->minor);\r\nkfree(opts);\r\nif (ida_is_empty(&hidg_ida))\r\nghid_cleanup();\r\ngoto unlock;\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "", &hid_func_type);\r\nunlock:\r\nmutex_unlock(&hidg_ida_lock);\r\nreturn ret;\r\n}\r\nstatic void hidg_free(struct usb_function *f)\r\n{\r\nstruct f_hidg *hidg;\r\nstruct f_hid_opts *opts;\r\nhidg = func_to_hidg(f);\r\nopts = container_of(f->fi, struct f_hid_opts, func_inst);\r\nkfree(hidg->report_desc);\r\nkfree(hidg);\r\nmutex_lock(&opts->lock);\r\n--opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void hidg_unbind(struct usb_configuration *c, struct usb_function *f)\r\n{\r\nstruct f_hidg *hidg = func_to_hidg(f);\r\ndevice_destroy(hidg_class, MKDEV(major, hidg->minor));\r\ncdev_del(&hidg->cdev);\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *hidg_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct f_hidg *hidg;\r\nstruct f_hid_opts *opts;\r\nhidg = kzalloc(sizeof(*hidg), GFP_KERNEL);\r\nif (!hidg)\r\nreturn ERR_PTR(-ENOMEM);\r\nopts = container_of(fi, struct f_hid_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\n++opts->refcnt;\r\nhidg->minor = opts->minor;\r\nhidg->bInterfaceSubClass = opts->subclass;\r\nhidg->bInterfaceProtocol = opts->protocol;\r\nhidg->report_length = opts->report_length;\r\nhidg->report_desc_length = opts->report_desc_length;\r\nif (opts->report_desc) {\r\nhidg->report_desc = kmemdup(opts->report_desc,\r\nopts->report_desc_length,\r\nGFP_KERNEL);\r\nif (!hidg->report_desc) {\r\nkfree(hidg);\r\nmutex_unlock(&opts->lock);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n}\r\nmutex_unlock(&opts->lock);\r\nhidg->func.name = "hid";\r\nhidg->func.bind = hidg_bind;\r\nhidg->func.unbind = hidg_unbind;\r\nhidg->func.set_alt = hidg_set_alt;\r\nhidg->func.disable = hidg_disable;\r\nhidg->func.setup = hidg_setup;\r\nhidg->func.free_func = hidg_free;\r\nhidg->qlen = 4;\r\nreturn &hidg->func;\r\n}\r\nint ghid_setup(struct usb_gadget *g, int count)\r\n{\r\nint status;\r\ndev_t dev;\r\nhidg_class = class_create(THIS_MODULE, "hidg");\r\nif (IS_ERR(hidg_class)) {\r\nstatus = PTR_ERR(hidg_class);\r\nhidg_class = NULL;\r\nreturn status;\r\n}\r\nstatus = alloc_chrdev_region(&dev, 0, count, "hidg");\r\nif (status) {\r\nclass_destroy(hidg_class);\r\nhidg_class = NULL;\r\nreturn status;\r\n}\r\nmajor = MAJOR(dev);\r\nminors = count;\r\nreturn 0;\r\n}\r\nvoid ghid_cleanup(void)\r\n{\r\nif (major) {\r\nunregister_chrdev_region(MKDEV(major, 0), minors);\r\nmajor = minors = 0;\r\n}\r\nclass_destroy(hidg_class);\r\nhidg_class = NULL;\r\n}
