static int sis_read_packet(struct i2c_client *client, u8 *buf,\r\nunsigned int *num_contacts,\r\nunsigned int *contact_size)\r\n{\r\nint count_idx;\r\nint ret;\r\nu16 len;\r\nu16 crc, pkg_crc;\r\nu8 report_id;\r\nret = i2c_master_recv(client, buf, SIS_MAX_PACKET_SIZE);\r\nif (ret <= 0)\r\nreturn -EIO;\r\nlen = get_unaligned_le16(&buf[SIS_PKT_LEN_OFFSET]);\r\nif (len > SIS_MAX_PACKET_SIZE) {\r\ndev_err(&client->dev,\r\n"%s: invalid packet length (%d vs %d)\n",\r\n__func__, len, SIS_MAX_PACKET_SIZE);\r\nreturn -E2BIG;\r\n}\r\nif (len < 10)\r\nreturn -EINVAL;\r\nreport_id = buf[SIS_PKT_REPORT_OFFSET];\r\ncount_idx = len - 1;\r\n*contact_size = SIS_BASE_LEN_PER_CONTACT;\r\nif (report_id != SIS_ALL_IN_ONE_PACKAGE) {\r\nif (SIS_PKT_IS_TOUCH(report_id)) {\r\ncrc = crc_itu_t(0, buf + 2, len - 2 - 2);\r\npkg_crc = get_unaligned_le16(&buf[len - 2]);\r\nif (crc != pkg_crc) {\r\ndev_err(&client->dev,\r\n"%s: CRC Error (%d vs %d)\n",\r\n__func__, crc, pkg_crc);\r\nreturn -EINVAL;\r\n}\r\ncount_idx -= 2;\r\n} else if (!SIS_PKT_IS_HIDI2C(report_id)) {\r\ndev_err(&client->dev,\r\n"%s: invalid packet ID %#02x\n",\r\n__func__, report_id);\r\nreturn -EINVAL;\r\n}\r\nif (SIS_PKT_HAS_SCANTIME(report_id))\r\ncount_idx -= SIS_SCAN_TIME_LEN;\r\nif (SIS_PKT_HAS_AREA(report_id))\r\n*contact_size += SIS_AREA_LEN_PER_CONTACT;\r\nif (SIS_PKT_HAS_PRESSURE(report_id))\r\n*contact_size += SIS_PRESSURE_LEN_PER_CONTACT;\r\n}\r\n*num_contacts = buf[count_idx];\r\nreturn 0;\r\n}\r\nstatic int sis_ts_report_contact(struct sis_ts_data *ts, const u8 *data, u8 id)\r\n{\r\nstruct input_dev *input = ts->input;\r\nint slot;\r\nu8 status = data[SIS_CONTACT_STATUS_OFFSET];\r\nu8 pressure;\r\nu8 height, width;\r\nu16 x, y;\r\nif (status != SIS_STATUS_DOWN && status != SIS_STATUS_UP) {\r\ndev_err(&ts->client->dev, "Unexpected touch status: %#02x\n",\r\ndata[SIS_CONTACT_STATUS_OFFSET]);\r\nreturn -EINVAL;\r\n}\r\nslot = input_mt_get_slot_by_key(input, data[SIS_CONTACT_ID_OFFSET]);\r\nif (slot < 0)\r\nreturn -ENOENT;\r\ninput_mt_slot(input, slot);\r\ninput_mt_report_slot_state(input, MT_TOOL_FINGER,\r\nstatus == SIS_STATUS_DOWN);\r\nif (status == SIS_STATUS_DOWN) {\r\npressure = height = width = 1;\r\nif (id != SIS_ALL_IN_ONE_PACKAGE) {\r\nif (SIS_PKT_HAS_AREA(id)) {\r\nwidth = data[SIS_CONTACT_WIDTH_OFFSET];\r\nheight = data[SIS_CONTACT_HEIGHT_OFFSET];\r\n}\r\nif (SIS_PKT_HAS_PRESSURE(id))\r\npressure =\r\ndata[SIS_CONTACT_PRESSURE_OFFSET(id)];\r\n}\r\nx = get_unaligned_le16(&data[SIS_CONTACT_X_OFFSET]);\r\ny = get_unaligned_le16(&data[SIS_CONTACT_Y_OFFSET]);\r\ninput_report_abs(input, ABS_MT_TOUCH_MAJOR,\r\nwidth * SIS_AREA_UNIT);\r\ninput_report_abs(input, ABS_MT_TOUCH_MINOR,\r\nheight * SIS_AREA_UNIT);\r\ninput_report_abs(input, ABS_MT_PRESSURE, pressure);\r\ninput_report_abs(input, ABS_MT_POSITION_X, x);\r\ninput_report_abs(input, ABS_MT_POSITION_Y, y);\r\n}\r\nreturn 0;\r\n}\r\nstatic void sis_ts_handle_packet(struct sis_ts_data *ts)\r\n{\r\nconst u8 *contact;\r\nunsigned int num_to_report = 0;\r\nunsigned int num_contacts;\r\nunsigned int num_reported;\r\nunsigned int contact_size;\r\nint error;\r\nu8 report_id;\r\ndo {\r\nerror = sis_read_packet(ts->client, ts->packet,\r\n&num_contacts, &contact_size);\r\nif (error)\r\nbreak;\r\nif (num_to_report == 0) {\r\nnum_to_report = num_contacts;\r\n} else if (num_contacts != 0) {\r\ndev_err(&ts->client->dev,\r\n"%s: nonzero (%d) point count in tail packet\n",\r\n__func__, num_contacts);\r\nbreak;\r\n}\r\nreport_id = ts->packet[SIS_PKT_REPORT_OFFSET];\r\ncontact = &ts->packet[SIS_PKT_CONTACT_OFFSET];\r\nnum_reported = 0;\r\nwhile (num_to_report > 0) {\r\nerror = sis_ts_report_contact(ts, contact, report_id);\r\nif (error)\r\nbreak;\r\ncontact += contact_size;\r\nnum_to_report--;\r\nnum_reported++;\r\nif (report_id != SIS_ALL_IN_ONE_PACKAGE &&\r\nnum_reported >= 5) {\r\nbreak;\r\n}\r\n}\r\n} while (num_to_report > 0);\r\ninput_mt_sync_frame(ts->input);\r\ninput_sync(ts->input);\r\n}\r\nstatic irqreturn_t sis_ts_irq_handler(int irq, void *dev_id)\r\n{\r\nstruct sis_ts_data *ts = dev_id;\r\ndo {\r\nsis_ts_handle_packet(ts);\r\n} while (ts->attn_gpio && gpiod_get_value_cansleep(ts->attn_gpio));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void sis_ts_reset(struct sis_ts_data *ts)\r\n{\r\nif (ts->reset_gpio) {\r\nusleep_range(1000, 2000);\r\ngpiod_set_value(ts->reset_gpio, 1);\r\nusleep_range(1000, 2000);\r\ngpiod_set_value(ts->reset_gpio, 0);\r\nmsleep(100);\r\n}\r\n}\r\nstatic int sis_ts_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct sis_ts_data *ts;\r\nstruct input_dev *input;\r\nint error;\r\nts = devm_kzalloc(&client->dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nts->client = client;\r\nts->attn_gpio = devm_gpiod_get_optional(&client->dev,\r\n"attn", GPIOD_IN);\r\nif (IS_ERR(ts->attn_gpio)) {\r\nerror = PTR_ERR(ts->attn_gpio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get attention GPIO: %d\n", error);\r\nreturn error;\r\n}\r\nts->reset_gpio = devm_gpiod_get_optional(&client->dev,\r\n"reset", GPIOD_OUT_LOW);\r\nif (IS_ERR(ts->reset_gpio)) {\r\nerror = PTR_ERR(ts->reset_gpio);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(&client->dev,\r\n"Failed to get reset GPIO: %d\n", error);\r\nreturn error;\r\n}\r\nsis_ts_reset(ts);\r\nts->input = input = devm_input_allocate_device(&client->dev);\r\nif (!input) {\r\ndev_err(&client->dev, "Failed to allocate input device\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = "SiS Touchscreen";\r\ninput->id.bustype = BUS_I2C;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, SIS_MAX_X, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, SIS_MAX_Y, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_PRESSURE, 0, SIS_MAX_PRESSURE, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MAJOR,\r\n0, SIS_AREA_LENGTH_LONGER, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_TOUCH_MINOR,\r\n0, SIS_AREA_LENGTH_SHORT, 0, 0);\r\nerror = input_mt_init_slots(input, SIS_MAX_FINGERS, INPUT_MT_DIRECT);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to initialize MT slots: %d\n", error);\r\nreturn error;\r\n}\r\nerror = devm_request_threaded_irq(&client->dev, client->irq,\r\nNULL, sis_ts_irq_handler,\r\nIRQF_ONESHOT,\r\nclient->name, ts);\r\nif (error) {\r\ndev_err(&client->dev, "Failed to request IRQ: %d\n", error);\r\nreturn error;\r\n}\r\nerror = input_register_device(ts->input);\r\nif (error) {\r\ndev_err(&client->dev,\r\n"Failed to register input device: %d\n", error);\r\nreturn error;\r\n}\r\nreturn 0;\r\n}
