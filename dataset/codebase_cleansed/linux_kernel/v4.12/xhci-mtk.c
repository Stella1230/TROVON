static int xhci_mtk_host_enable(struct xhci_hcd_mtk *mtk)\r\n{\r\nstruct mu3c_ippc_regs __iomem *ippc = mtk->ippc_regs;\r\nu32 value, check_val;\r\nint ret;\r\nint i;\r\nif (!mtk->has_ippc)\r\nreturn 0;\r\nvalue = readl(&ippc->ip_pw_ctr1);\r\nvalue &= ~CTRL1_IP_HOST_PDN;\r\nwritel(value, &ippc->ip_pw_ctr1);\r\nfor (i = 0; i < mtk->num_u3_ports; i++) {\r\nvalue = readl(&ippc->u3_ctrl_p[i]);\r\nvalue &= ~(CTRL_U3_PORT_PDN | CTRL_U3_PORT_DIS);\r\nvalue |= CTRL_U3_PORT_HOST_SEL;\r\nwritel(value, &ippc->u3_ctrl_p[i]);\r\n}\r\nfor (i = 0; i < mtk->num_u2_ports; i++) {\r\nvalue = readl(&ippc->u2_ctrl_p[i]);\r\nvalue &= ~(CTRL_U2_PORT_PDN | CTRL_U2_PORT_DIS);\r\nvalue |= CTRL_U2_PORT_HOST_SEL;\r\nwritel(value, &ippc->u2_ctrl_p[i]);\r\n}\r\ncheck_val = STS1_SYSPLL_STABLE | STS1_REF_RST |\r\nSTS1_SYS125_RST | STS1_XHCI_RST;\r\nret = readl_poll_timeout(&ippc->ip_pw_sts1, value,\r\n(check_val == (value & check_val)), 100, 20000);\r\nif (ret) {\r\ndev_err(mtk->dev, "clocks are not stable (0x%x)\n", value);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xhci_mtk_host_disable(struct xhci_hcd_mtk *mtk)\r\n{\r\nstruct mu3c_ippc_regs __iomem *ippc = mtk->ippc_regs;\r\nu32 value;\r\nint ret;\r\nint i;\r\nif (!mtk->has_ippc)\r\nreturn 0;\r\nfor (i = 0; i < mtk->num_u3_ports; i++) {\r\nvalue = readl(&ippc->u3_ctrl_p[i]);\r\nvalue |= CTRL_U3_PORT_PDN;\r\nwritel(value, &ippc->u3_ctrl_p[i]);\r\n}\r\nfor (i = 0; i < mtk->num_u2_ports; i++) {\r\nvalue = readl(&ippc->u2_ctrl_p[i]);\r\nvalue |= CTRL_U2_PORT_PDN;\r\nwritel(value, &ippc->u2_ctrl_p[i]);\r\n}\r\nvalue = readl(&ippc->ip_pw_ctr1);\r\nvalue |= CTRL1_IP_HOST_PDN;\r\nwritel(value, &ippc->ip_pw_ctr1);\r\nret = readl_poll_timeout(&ippc->ip_pw_sts1, value,\r\n(value & STS1_IP_SLEEP_STS), 100, 100000);\r\nif (ret) {\r\ndev_err(mtk->dev, "ip sleep failed!!!\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xhci_mtk_ssusb_config(struct xhci_hcd_mtk *mtk)\r\n{\r\nstruct mu3c_ippc_regs __iomem *ippc = mtk->ippc_regs;\r\nu32 value;\r\nif (!mtk->has_ippc)\r\nreturn 0;\r\nvalue = readl(&ippc->ip_pw_ctr0);\r\nvalue |= CTRL0_IP_SW_RST;\r\nwritel(value, &ippc->ip_pw_ctr0);\r\nudelay(1);\r\nvalue = readl(&ippc->ip_pw_ctr0);\r\nvalue &= ~CTRL0_IP_SW_RST;\r\nwritel(value, &ippc->ip_pw_ctr0);\r\nvalue = readl(&ippc->ip_pw_ctr2);\r\nvalue |= CTRL2_IP_DEV_PDN;\r\nwritel(value, &ippc->ip_pw_ctr2);\r\nvalue = readl(&ippc->ip_xhci_cap);\r\nmtk->num_u3_ports = CAP_U3_PORT_NUM(value);\r\nmtk->num_u2_ports = CAP_U2_PORT_NUM(value);\r\ndev_dbg(mtk->dev, "%s u2p:%d, u3p:%d\n", __func__,\r\nmtk->num_u2_ports, mtk->num_u3_ports);\r\nreturn xhci_mtk_host_enable(mtk);\r\n}\r\nstatic int xhci_mtk_clks_enable(struct xhci_hcd_mtk *mtk)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(mtk->ref_clk);\r\nif (ret) {\r\ndev_err(mtk->dev, "failed to enable ref_clk\n");\r\ngoto ref_clk_err;\r\n}\r\nret = clk_prepare_enable(mtk->sys_clk);\r\nif (ret) {\r\ndev_err(mtk->dev, "failed to enable sys_clk\n");\r\ngoto sys_clk_err;\r\n}\r\nif (mtk->wakeup_src) {\r\nret = clk_prepare_enable(mtk->wk_deb_p0);\r\nif (ret) {\r\ndev_err(mtk->dev, "failed to enable wk_deb_p0\n");\r\ngoto usb_p0_err;\r\n}\r\nret = clk_prepare_enable(mtk->wk_deb_p1);\r\nif (ret) {\r\ndev_err(mtk->dev, "failed to enable wk_deb_p1\n");\r\ngoto usb_p1_err;\r\n}\r\n}\r\nreturn 0;\r\nusb_p1_err:\r\nclk_disable_unprepare(mtk->wk_deb_p0);\r\nusb_p0_err:\r\nclk_disable_unprepare(mtk->sys_clk);\r\nsys_clk_err:\r\nclk_disable_unprepare(mtk->ref_clk);\r\nref_clk_err:\r\nreturn -EINVAL;\r\n}\r\nstatic void xhci_mtk_clks_disable(struct xhci_hcd_mtk *mtk)\r\n{\r\nif (mtk->wakeup_src) {\r\nclk_disable_unprepare(mtk->wk_deb_p1);\r\nclk_disable_unprepare(mtk->wk_deb_p0);\r\n}\r\nclk_disable_unprepare(mtk->sys_clk);\r\nclk_disable_unprepare(mtk->ref_clk);\r\n}\r\nstatic void usb_wakeup_ip_sleep_en(struct xhci_hcd_mtk *mtk)\r\n{\r\nu32 tmp;\r\nstruct regmap *pericfg = mtk->pericfg;\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\ntmp &= ~UWK_CTL1_IS_P;\r\ntmp &= ~(UWK_CTL1_IS_C(0xf));\r\ntmp |= UWK_CTL1_IS_C(0x8);\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp);\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp | UWK_CTL1_IS_E);\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\ndev_dbg(mtk->dev, "%s(): WK_CTRL1[P6,E25,C26:29]=%#x\n",\r\n__func__, tmp);\r\n}\r\nstatic void usb_wakeup_ip_sleep_dis(struct xhci_hcd_mtk *mtk)\r\n{\r\nu32 tmp;\r\nregmap_read(mtk->pericfg, PERI_WK_CTRL1, &tmp);\r\ntmp &= ~UWK_CTL1_IS_E;\r\nregmap_write(mtk->pericfg, PERI_WK_CTRL1, tmp);\r\n}\r\nstatic void usb_wakeup_line_state_en(struct xhci_hcd_mtk *mtk)\r\n{\r\nu32 tmp;\r\nstruct regmap *pericfg = mtk->pericfg;\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\ntmp &= ~UWK_CTL1_0P_LS_P;\r\ntmp &= ~(UWK_CTL1_0P_LS_C(0xf));\r\ntmp |= UWK_CTL1_0P_LS_C(0x8);\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp);\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp | UWK_CTL1_0P_LS_E);\r\nregmap_read(pericfg, PERI_WK_CTRL0, &tmp);\r\ntmp &= ~(UWK_CTL1_1P_LS_C(0xf));\r\ntmp |= UWK_CTL1_1P_LS_C(0x8);\r\nregmap_write(pericfg, PERI_WK_CTRL0, tmp);\r\nregmap_write(pericfg, PERI_WK_CTRL0, tmp | UWK_CTL1_1P_LS_E);\r\n}\r\nstatic void usb_wakeup_line_state_dis(struct xhci_hcd_mtk *mtk)\r\n{\r\nu32 tmp;\r\nstruct regmap *pericfg = mtk->pericfg;\r\nregmap_read(pericfg, PERI_WK_CTRL1, &tmp);\r\ntmp &= ~UWK_CTL1_0P_LS_E;\r\nregmap_write(pericfg, PERI_WK_CTRL1, tmp);\r\nregmap_read(pericfg, PERI_WK_CTRL0, &tmp);\r\ntmp &= ~UWK_CTL1_1P_LS_E;\r\nregmap_write(pericfg, PERI_WK_CTRL0, tmp);\r\n}\r\nstatic void usb_wakeup_enable(struct xhci_hcd_mtk *mtk)\r\n{\r\nif (mtk->wakeup_src == SSUSB_WK_IP_SLEEP)\r\nusb_wakeup_ip_sleep_en(mtk);\r\nelse if (mtk->wakeup_src == SSUSB_WK_LINE_STATE)\r\nusb_wakeup_line_state_en(mtk);\r\n}\r\nstatic void usb_wakeup_disable(struct xhci_hcd_mtk *mtk)\r\n{\r\nif (mtk->wakeup_src == SSUSB_WK_IP_SLEEP)\r\nusb_wakeup_ip_sleep_dis(mtk);\r\nelse if (mtk->wakeup_src == SSUSB_WK_LINE_STATE)\r\nusb_wakeup_line_state_dis(mtk);\r\n}\r\nstatic int usb_wakeup_of_property_parse(struct xhci_hcd_mtk *mtk,\r\nstruct device_node *dn)\r\n{\r\nstruct device *dev = mtk->dev;\r\nof_property_read_u32(dn, "mediatek,wakeup-src", &mtk->wakeup_src);\r\nif (!mtk->wakeup_src)\r\nreturn 0;\r\nmtk->wk_deb_p0 = devm_clk_get(dev, "wakeup_deb_p0");\r\nif (IS_ERR(mtk->wk_deb_p0)) {\r\ndev_err(dev, "fail to get wakeup_deb_p0\n");\r\nreturn PTR_ERR(mtk->wk_deb_p0);\r\n}\r\nmtk->wk_deb_p1 = devm_clk_get(dev, "wakeup_deb_p1");\r\nif (IS_ERR(mtk->wk_deb_p1)) {\r\ndev_err(dev, "fail to get wakeup_deb_p1\n");\r\nreturn PTR_ERR(mtk->wk_deb_p1);\r\n}\r\nmtk->pericfg = syscon_regmap_lookup_by_phandle(dn,\r\n"mediatek,syscon-wakeup");\r\nif (IS_ERR(mtk->pericfg)) {\r\ndev_err(dev, "fail to get pericfg regs\n");\r\nreturn PTR_ERR(mtk->pericfg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xhci_mtk_phy_init(struct xhci_hcd_mtk *mtk)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < mtk->num_phys; i++) {\r\nret = phy_init(mtk->phys[i]);\r\nif (ret)\r\ngoto exit_phy;\r\n}\r\nreturn 0;\r\nexit_phy:\r\nfor (; i > 0; i--)\r\nphy_exit(mtk->phys[i - 1]);\r\nreturn ret;\r\n}\r\nstatic int xhci_mtk_phy_exit(struct xhci_hcd_mtk *mtk)\r\n{\r\nint i;\r\nfor (i = 0; i < mtk->num_phys; i++)\r\nphy_exit(mtk->phys[i]);\r\nreturn 0;\r\n}\r\nstatic int xhci_mtk_phy_power_on(struct xhci_hcd_mtk *mtk)\r\n{\r\nint i;\r\nint ret;\r\nfor (i = 0; i < mtk->num_phys; i++) {\r\nret = phy_power_on(mtk->phys[i]);\r\nif (ret)\r\ngoto power_off_phy;\r\n}\r\nreturn 0;\r\npower_off_phy:\r\nfor (; i > 0; i--)\r\nphy_power_off(mtk->phys[i - 1]);\r\nreturn ret;\r\n}\r\nstatic void xhci_mtk_phy_power_off(struct xhci_hcd_mtk *mtk)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < mtk->num_phys; i++)\r\nphy_power_off(mtk->phys[i]);\r\n}\r\nstatic int xhci_mtk_ldos_enable(struct xhci_hcd_mtk *mtk)\r\n{\r\nint ret;\r\nret = regulator_enable(mtk->vbus);\r\nif (ret) {\r\ndev_err(mtk->dev, "failed to enable vbus\n");\r\nreturn ret;\r\n}\r\nret = regulator_enable(mtk->vusb33);\r\nif (ret) {\r\ndev_err(mtk->dev, "failed to enable vusb33\n");\r\nregulator_disable(mtk->vbus);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xhci_mtk_ldos_disable(struct xhci_hcd_mtk *mtk)\r\n{\r\nregulator_disable(mtk->vbus);\r\nregulator_disable(mtk->vusb33);\r\n}\r\nstatic void xhci_mtk_quirks(struct device *dev, struct xhci_hcd *xhci)\r\n{\r\nstruct usb_hcd *hcd = xhci_to_hcd(xhci);\r\nstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\r\nxhci->quirks |= XHCI_PLAT;\r\nxhci->quirks |= XHCI_MTK_HOST;\r\nxhci->quirks |= XHCI_SPURIOUS_SUCCESS;\r\nif (mtk->lpm_support)\r\nxhci->quirks |= XHCI_LPM_SUPPORT;\r\n}\r\nstatic int xhci_mtk_setup(struct usb_hcd *hcd)\r\n{\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\r\nint ret;\r\nif (usb_hcd_is_primary_hcd(hcd)) {\r\nret = xhci_mtk_ssusb_config(mtk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = xhci_gen_setup(hcd, xhci_mtk_quirks);\r\nif (ret)\r\nreturn ret;\r\nif (usb_hcd_is_primary_hcd(hcd)) {\r\nmtk->num_u3_ports = xhci->num_usb3_ports;\r\nmtk->num_u2_ports = xhci->num_usb2_ports;\r\nret = xhci_mtk_sch_init(mtk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int xhci_mtk_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct xhci_hcd_mtk *mtk;\r\nconst struct hc_driver *driver;\r\nstruct xhci_hcd *xhci;\r\nstruct resource *res;\r\nstruct usb_hcd *hcd;\r\nstruct phy *phy;\r\nint phy_num;\r\nint ret = -ENODEV;\r\nint irq;\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\ndriver = &xhci_mtk_hc_driver;\r\nmtk = devm_kzalloc(dev, sizeof(*mtk), GFP_KERNEL);\r\nif (!mtk)\r\nreturn -ENOMEM;\r\nmtk->dev = dev;\r\nmtk->vbus = devm_regulator_get(dev, "vbus");\r\nif (IS_ERR(mtk->vbus)) {\r\ndev_err(dev, "fail to get vbus\n");\r\nreturn PTR_ERR(mtk->vbus);\r\n}\r\nmtk->vusb33 = devm_regulator_get(dev, "vusb33");\r\nif (IS_ERR(mtk->vusb33)) {\r\ndev_err(dev, "fail to get vusb33\n");\r\nreturn PTR_ERR(mtk->vusb33);\r\n}\r\nmtk->sys_clk = devm_clk_get(dev, "sys_ck");\r\nif (IS_ERR(mtk->sys_clk)) {\r\ndev_err(dev, "fail to get sys_ck\n");\r\nreturn PTR_ERR(mtk->sys_clk);\r\n}\r\nmtk->ref_clk = devm_clk_get(dev, "ref_ck");\r\nif (IS_ERR(mtk->ref_clk)) {\r\nif (PTR_ERR(mtk->ref_clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nmtk->ref_clk = NULL;\r\n}\r\nmtk->lpm_support = of_property_read_bool(node, "usb3-lpm-capable");\r\nret = usb_wakeup_of_property_parse(mtk, node);\r\nif (ret)\r\nreturn ret;\r\nmtk->num_phys = of_count_phandle_with_args(node,\r\n"phys", "#phy-cells");\r\nif (mtk->num_phys > 0) {\r\nmtk->phys = devm_kcalloc(dev, mtk->num_phys,\r\nsizeof(*mtk->phys), GFP_KERNEL);\r\nif (!mtk->phys)\r\nreturn -ENOMEM;\r\n} else {\r\nmtk->num_phys = 0;\r\n}\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\ndevice_enable_async_suspend(dev);\r\nret = xhci_mtk_ldos_enable(mtk);\r\nif (ret)\r\ngoto disable_pm;\r\nret = xhci_mtk_clks_enable(mtk);\r\nif (ret)\r\ngoto disable_ldos;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nret = irq;\r\ngoto disable_clk;\r\n}\r\nret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));\r\nif (ret)\r\ngoto disable_clk;\r\nif (!dev->dma_mask)\r\ndev->dma_mask = &dev->coherent_dma_mask;\r\nelse\r\ndma_set_mask(dev, DMA_BIT_MASK(32));\r\nhcd = usb_create_hcd(driver, dev, dev_name(dev));\r\nif (!hcd) {\r\nret = -ENOMEM;\r\ngoto disable_clk;\r\n}\r\nmtk->hcd = platform_get_drvdata(pdev);\r\nplatform_set_drvdata(pdev, mtk);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mac");\r\nhcd->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(hcd->regs)) {\r\nret = PTR_ERR(hcd->regs);\r\ngoto put_usb2_hcd;\r\n}\r\nhcd->rsrc_start = res->start;\r\nhcd->rsrc_len = resource_size(res);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ippc");\r\nif (res) {\r\nmtk->ippc_regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(mtk->ippc_regs)) {\r\nret = PTR_ERR(mtk->ippc_regs);\r\ngoto put_usb2_hcd;\r\n}\r\nmtk->has_ippc = true;\r\n} else {\r\nmtk->has_ippc = false;\r\n}\r\nfor (phy_num = 0; phy_num < mtk->num_phys; phy_num++) {\r\nphy = devm_of_phy_get_by_index(dev, node, phy_num);\r\nif (IS_ERR(phy)) {\r\nret = PTR_ERR(phy);\r\ngoto put_usb2_hcd;\r\n}\r\nmtk->phys[phy_num] = phy;\r\n}\r\nret = xhci_mtk_phy_init(mtk);\r\nif (ret)\r\ngoto put_usb2_hcd;\r\nret = xhci_mtk_phy_power_on(mtk);\r\nif (ret)\r\ngoto exit_phys;\r\ndevice_init_wakeup(dev, true);\r\nxhci = hcd_to_xhci(hcd);\r\nxhci->main_hcd = hcd;\r\nxhci->shared_hcd = usb_create_shared_hcd(driver, dev,\r\ndev_name(dev), hcd);\r\nif (!xhci->shared_hcd) {\r\nret = -ENOMEM;\r\ngoto power_off_phys;\r\n}\r\nret = usb_add_hcd(hcd, irq, IRQF_SHARED);\r\nif (ret)\r\ngoto put_usb3_hcd;\r\nif (HCC_MAX_PSA(xhci->hcc_params) >= 4)\r\nxhci->shared_hcd->can_do_streams = 1;\r\nret = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);\r\nif (ret)\r\ngoto dealloc_usb2_hcd;\r\nreturn 0;\r\ndealloc_usb2_hcd:\r\nusb_remove_hcd(hcd);\r\nput_usb3_hcd:\r\nxhci_mtk_sch_exit(mtk);\r\nusb_put_hcd(xhci->shared_hcd);\r\npower_off_phys:\r\nxhci_mtk_phy_power_off(mtk);\r\ndevice_init_wakeup(dev, false);\r\nexit_phys:\r\nxhci_mtk_phy_exit(mtk);\r\nput_usb2_hcd:\r\nusb_put_hcd(hcd);\r\ndisable_clk:\r\nxhci_mtk_clks_disable(mtk);\r\ndisable_ldos:\r\nxhci_mtk_ldos_disable(mtk);\r\ndisable_pm:\r\npm_runtime_put_sync(dev);\r\npm_runtime_disable(dev);\r\nreturn ret;\r\n}\r\nstatic int xhci_mtk_remove(struct platform_device *dev)\r\n{\r\nstruct xhci_hcd_mtk *mtk = platform_get_drvdata(dev);\r\nstruct usb_hcd *hcd = mtk->hcd;\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nusb_remove_hcd(xhci->shared_hcd);\r\nxhci_mtk_phy_power_off(mtk);\r\nxhci_mtk_phy_exit(mtk);\r\ndevice_init_wakeup(&dev->dev, false);\r\nusb_remove_hcd(hcd);\r\nusb_put_hcd(xhci->shared_hcd);\r\nusb_put_hcd(hcd);\r\nxhci_mtk_sch_exit(mtk);\r\nxhci_mtk_clks_disable(mtk);\r\nxhci_mtk_ldos_disable(mtk);\r\npm_runtime_put_sync(&dev->dev);\r\npm_runtime_disable(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xhci_mtk_suspend(struct device *dev)\r\n{\r\nstruct xhci_hcd_mtk *mtk = dev_get_drvdata(dev);\r\nstruct usb_hcd *hcd = mtk->hcd;\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nxhci_dbg(xhci, "%s: stop port polling\n", __func__);\r\nclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\ndel_timer_sync(&hcd->rh_timer);\r\nclear_bit(HCD_FLAG_POLL_RH, &xhci->shared_hcd->flags);\r\ndel_timer_sync(&xhci->shared_hcd->rh_timer);\r\nxhci_mtk_host_disable(mtk);\r\nxhci_mtk_phy_power_off(mtk);\r\nxhci_mtk_clks_disable(mtk);\r\nusb_wakeup_enable(mtk);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused xhci_mtk_resume(struct device *dev)\r\n{\r\nstruct xhci_hcd_mtk *mtk = dev_get_drvdata(dev);\r\nstruct usb_hcd *hcd = mtk->hcd;\r\nstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\r\nusb_wakeup_disable(mtk);\r\nxhci_mtk_clks_enable(mtk);\r\nxhci_mtk_phy_power_on(mtk);\r\nxhci_mtk_host_enable(mtk);\r\nxhci_dbg(xhci, "%s: restart port polling\n", __func__);\r\nset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\r\nusb_hcd_poll_rh_status(hcd);\r\nset_bit(HCD_FLAG_POLL_RH, &xhci->shared_hcd->flags);\r\nusb_hcd_poll_rh_status(xhci->shared_hcd);\r\nreturn 0;\r\n}\r\nstatic int __init xhci_mtk_init(void)\r\n{\r\nxhci_init_driver(&xhci_mtk_hc_driver, &xhci_mtk_overrides);\r\nreturn platform_driver_register(&mtk_xhci_driver);\r\n}\r\nstatic void __exit xhci_mtk_exit(void)\r\n{\r\nplatform_driver_unregister(&mtk_xhci_driver);\r\n}
