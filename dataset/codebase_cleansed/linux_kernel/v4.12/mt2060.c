static int mt2060_readreg(struct mt2060_priv *priv, u8 reg, u8 *val)\r\n{\r\nstruct i2c_msg msg[2] = {\r\n{ .addr = priv->cfg->i2c_address, .flags = 0, .buf = &reg, .len = 1 },\r\n{ .addr = priv->cfg->i2c_address, .flags = I2C_M_RD, .buf = val, .len = 1 },\r\n};\r\nif (i2c_transfer(priv->i2c, msg, 2) != 2) {\r\nprintk(KERN_WARNING "mt2060 I2C read failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt2060_writereg(struct mt2060_priv *priv, u8 reg, u8 val)\r\n{\r\nu8 buf[2] = { reg, val };\r\nstruct i2c_msg msg = {\r\n.addr = priv->cfg->i2c_address, .flags = 0, .buf = buf, .len = 2\r\n};\r\nif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\r\nprintk(KERN_WARNING "mt2060 I2C write failed\n");\r\nreturn -EREMOTEIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt2060_writeregs(struct mt2060_priv *priv,u8 *buf, u8 len)\r\n{\r\nint rem, val_len;\r\nu8 xfer_buf[16];\r\nstruct i2c_msg msg = {\r\n.addr = priv->cfg->i2c_address, .flags = 0, .buf = xfer_buf\r\n};\r\nfor (rem = len - 1; rem > 0; rem -= priv->i2c_max_regs) {\r\nval_len = min_t(int, rem, priv->i2c_max_regs);\r\nmsg.len = 1 + val_len;\r\nxfer_buf[0] = buf[0] + len - 1 - rem;\r\nmemcpy(&xfer_buf[1], &buf[1 + len - 1 - rem], val_len);\r\nif (i2c_transfer(priv->i2c, &msg, 1) != 1) {\r\nprintk(KERN_WARNING "mt2060 I2C write failed (len=%i)\n", val_len);\r\nreturn -EREMOTEIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mt2060_spurcalc(u32 lo1,u32 lo2,u32 if2)\r\n{\r\nint I,J;\r\nint dia,diamin,diff;\r\ndiamin=1000000;\r\nfor (I = 1; I < 10; I++) {\r\nJ = ((2*I*lo1)/lo2+1)/2;\r\ndiff = I*(int)lo1-J*(int)lo2;\r\nif (diff < 0) diff=-diff;\r\ndia = (diff-(int)if2);\r\nif (dia < 0) dia=-dia;\r\nif (diamin > dia) diamin=dia;\r\n}\r\nreturn diamin;\r\n}\r\nstatic int mt2060_spurcheck(u32 lo1,u32 lo2,u32 if2)\r\n{\r\nu32 Spur,Sp1,Sp2;\r\nint I,J;\r\nI=0;\r\nJ=1000;\r\nSpur=mt2060_spurcalc(lo1,lo2,if2);\r\nif (Spur < BANDWIDTH) {\r\ndprintk("Spurs before : f_lo1: %d f_lo2: %d (kHz)",\r\n(int)lo1,(int)lo2);\r\nI=1000;\r\nSp1 = mt2060_spurcalc(lo1+I,lo2+I,if2);\r\nSp2 = mt2060_spurcalc(lo1-I,lo2-I,if2);\r\nif (Sp1 < Sp2) {\r\nJ=-J; I=-I; Spur=Sp2;\r\n} else\r\nSpur=Sp1;\r\nwhile (Spur < BANDWIDTH) {\r\nI += J;\r\nSpur = mt2060_spurcalc(lo1+I,lo2+I,if2);\r\n}\r\ndprintk("Spurs after : f_lo1: %d f_lo2: %d (kHz)",\r\n(int)(lo1+I),(int)(lo2+I));\r\n}\r\nreturn I;\r\n}\r\nstatic int mt2060_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct mt2060_priv *priv;\r\nint i=0;\r\nu32 freq;\r\nu8 lnaband;\r\nu32 f_lo1,f_lo2;\r\nu32 div1,num1,div2,num2;\r\nu8 b[8];\r\nu32 if1;\r\npriv = fe->tuner_priv;\r\nif1 = priv->if1_freq;\r\nb[0] = REG_LO1B1;\r\nb[1] = 0xFF;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nmt2060_writeregs(priv,b,2);\r\nfreq = c->frequency / 1000;\r\nf_lo1 = freq + if1 * 1000;\r\nf_lo1 = (f_lo1 / 250) * 250;\r\nf_lo2 = f_lo1 - freq - IF2;\r\nf_lo2 = ((f_lo2 + 25) / 50) * 50;\r\npriv->frequency = (f_lo1 - f_lo2 - IF2) * 1000,\r\n#ifdef MT2060_SPURCHECK\r\nnum1 = mt2060_spurcheck(f_lo1,f_lo2,IF2);\r\nf_lo1 += num1;\r\nf_lo2 += num1;\r\n#endif\r\nnum1 = f_lo1 / (FREF / 64);\r\ndiv1 = num1 / 64;\r\nnum1 &= 0x3f;\r\nnum2 = f_lo2 * 64 / (FREF / 128);\r\ndiv2 = num2 / 8192;\r\nnum2 &= 0x1fff;\r\nif (freq <= 95000) lnaband = 0xB0; else\r\nif (freq <= 180000) lnaband = 0xA0; else\r\nif (freq <= 260000) lnaband = 0x90; else\r\nif (freq <= 335000) lnaband = 0x80; else\r\nif (freq <= 425000) lnaband = 0x70; else\r\nif (freq <= 480000) lnaband = 0x60; else\r\nif (freq <= 570000) lnaband = 0x50; else\r\nif (freq <= 645000) lnaband = 0x40; else\r\nif (freq <= 730000) lnaband = 0x30; else\r\nif (freq <= 810000) lnaband = 0x20; else lnaband = 0x10;\r\nb[0] = REG_LO1C1;\r\nb[1] = lnaband | ((num1 >>2) & 0x0F);\r\nb[2] = div1;\r\nb[3] = (num2 & 0x0F) | ((num1 & 3) << 4);\r\nb[4] = num2 >> 4;\r\nb[5] = ((num2 >>12) & 1) | (div2 << 1);\r\ndprintk("IF1: %dMHz",(int)if1);\r\ndprintk("PLL freq=%dkHz f_lo1=%dkHz f_lo2=%dkHz",(int)freq,(int)f_lo1,(int)f_lo2);\r\ndprintk("PLL div1=%d num1=%d div2=%d num2=%d",(int)div1,(int)num1,(int)div2,(int)num2);\r\ndprintk("PLL [1..5]: %2x %2x %2x %2x %2x",(int)b[1],(int)b[2],(int)b[3],(int)b[4],(int)b[5]);\r\nmt2060_writeregs(priv,b,6);\r\ni = 0;\r\ndo {\r\nmt2060_readreg(priv,REG_LO_STATUS,b);\r\nif ((b[0] & 0x88)==0x88)\r\nbreak;\r\nmsleep(4);\r\ni++;\r\n} while (i<10);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn 0;\r\n}\r\nstatic void mt2060_calibrate(struct mt2060_priv *priv)\r\n{\r\nu8 b = 0;\r\nint i = 0;\r\nif (mt2060_writeregs(priv,mt2060_config1,sizeof(mt2060_config1)))\r\nreturn;\r\nif (mt2060_writeregs(priv,mt2060_config2,sizeof(mt2060_config2)))\r\nreturn;\r\nmt2060_writereg(priv, REG_VGAG, (priv->cfg->clock_out << 6) | 0x30);\r\ndo {\r\nb |= (1 << 6);\r\nmt2060_writereg(priv, REG_LO2C1,b);\r\nmsleep(20);\r\nif (i == 0) {\r\nb |= (1 << 7);\r\nmt2060_writereg(priv, REG_LO2C1,b);\r\nb &= ~(1 << 7);\r\nmsleep(20);\r\n}\r\nb &= ~(1 << 6);\r\nmt2060_writereg(priv, REG_LO2C1,b);\r\nmsleep(20);\r\ni++;\r\n} while (i < 9);\r\ni = 0;\r\nwhile (i++ < 10 && mt2060_readreg(priv, REG_MISC_STAT, &b) == 0 && (b & (1 << 6)) == 0)\r\nmsleep(20);\r\nif (i <= 10) {\r\nmt2060_readreg(priv, REG_FM_FREQ, &priv->fmfreq);\r\ndprintk("calibration was successful: %d", (int)priv->fmfreq);\r\n} else\r\ndprintk("FMCAL timed out");\r\n}\r\nstatic int mt2060_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct mt2060_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int mt2060_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\n*frequency = IF2 * 1000;\r\nreturn 0;\r\n}\r\nstatic int mt2060_init(struct dvb_frontend *fe)\r\n{\r\nstruct mt2060_priv *priv = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (priv->sleep) {\r\nret = mt2060_writereg(priv, REG_MISC_CTRL, 0x20);\r\nif (ret)\r\ngoto err_i2c_gate_ctrl;\r\n}\r\nret = mt2060_writereg(priv, REG_VGAG,\r\n(priv->cfg->clock_out << 6) | 0x33);\r\nerr_i2c_gate_ctrl:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic int mt2060_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct mt2060_priv *priv = fe->tuner_priv;\r\nint ret;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = mt2060_writereg(priv, REG_VGAG,\r\n(priv->cfg->clock_out << 6) | 0x30);\r\nif (ret)\r\ngoto err_i2c_gate_ctrl;\r\nif (priv->sleep)\r\nret = mt2060_writereg(priv, REG_MISC_CTRL, 0xe8);\r\nerr_i2c_gate_ctrl:\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn ret;\r\n}\r\nstatic void mt2060_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstruct dvb_frontend * mt2060_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct mt2060_config *cfg, u16 if1)\r\n{\r\nstruct mt2060_priv *priv = NULL;\r\nu8 id = 0;\r\npriv = kzalloc(sizeof(struct mt2060_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->cfg = cfg;\r\npriv->i2c = i2c;\r\npriv->if1_freq = if1;\r\npriv->i2c_max_regs = ~0;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif (mt2060_readreg(priv,REG_PART_REV,&id) != 0) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nif (id != PART_REV) {\r\nkfree(priv);\r\nreturn NULL;\r\n}\r\nprintk(KERN_INFO "MT2060: successfully identified (IF1 = %d)\n", if1);\r\nmemcpy(&fe->ops.tuner_ops, &mt2060_tuner_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = priv;\r\nmt2060_calibrate(priv);\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\nreturn fe;\r\n}\r\nstatic int mt2060_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mt2060_platform_data *pdata = client->dev.platform_data;\r\nstruct dvb_frontend *fe;\r\nstruct mt2060_priv *dev;\r\nint ret;\r\nu8 chip_id;\r\ndev_dbg(&client->dev, "\n");\r\nif (!pdata) {\r\ndev_err(&client->dev, "Cannot proceed without platform data\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev = devm_kzalloc(&client->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nfe = pdata->dvb_frontend;\r\ndev->config.i2c_address = client->addr;\r\ndev->config.clock_out = pdata->clock_out;\r\ndev->cfg = &dev->config;\r\ndev->i2c = client->adapter;\r\ndev->if1_freq = pdata->if1 ? pdata->if1 : 1220;\r\ndev->client = client;\r\ndev->i2c_max_regs = pdata->i2c_write_max ? pdata->i2c_write_max - 1 : ~0;\r\ndev->sleep = true;\r\nret = mt2060_readreg(dev, REG_PART_REV, &chip_id);\r\nif (ret) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ndev_dbg(&client->dev, "chip id=%02x\n", chip_id);\r\nif (chip_id != PART_REV) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = mt2060_writereg(dev, REG_MISC_CTRL, 0x20);\r\nif (ret)\r\ngoto err;\r\nmt2060_calibrate(dev);\r\nret = mt2060_writereg(dev, REG_MISC_CTRL, 0xe8);\r\nif (ret)\r\ngoto err;\r\ndev_info(&client->dev, "Microtune MT2060 successfully identified\n");\r\nmemcpy(&fe->ops.tuner_ops, &mt2060_tuner_ops, sizeof(fe->ops.tuner_ops));\r\nfe->ops.tuner_ops.release = NULL;\r\nfe->tuner_priv = dev;\r\ni2c_set_clientdata(client, dev);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mt2060_remove(struct i2c_client *client)\r\n{\r\ndev_dbg(&client->dev, "\n");\r\nreturn 0;\r\n}
