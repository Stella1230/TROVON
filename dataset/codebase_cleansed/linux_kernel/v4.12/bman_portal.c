static struct bman_portal *init_pcfg(struct bm_portal_config *pcfg)\r\n{\r\nstruct bman_portal *p = bman_create_affine_portal(pcfg);\r\nif (!p) {\r\ndev_crit(pcfg->dev, "%s: Portal failure on cpu %d\n",\r\n__func__, pcfg->cpu);\r\nreturn NULL;\r\n}\r\nbman_p_irqsource_add(p, BM_PIRQ_RCRI);\r\naffine_bportals[pcfg->cpu] = p;\r\ndev_info(pcfg->dev, "Portal initialised, cpu %d\n", pcfg->cpu);\r\nreturn p;\r\n}\r\nstatic int bman_offline_cpu(unsigned int cpu)\r\n{\r\nstruct bman_portal *p = affine_bportals[cpu];\r\nconst struct bm_portal_config *pcfg;\r\nif (!p)\r\nreturn 0;\r\npcfg = bman_get_bm_portal_config(p);\r\nif (!pcfg)\r\nreturn 0;\r\nirq_set_affinity(pcfg->irq, cpumask_of(0));\r\nreturn 0;\r\n}\r\nstatic int bman_online_cpu(unsigned int cpu)\r\n{\r\nstruct bman_portal *p = affine_bportals[cpu];\r\nconst struct bm_portal_config *pcfg;\r\nif (!p)\r\nreturn 0;\r\npcfg = bman_get_bm_portal_config(p);\r\nif (!pcfg)\r\nreturn 0;\r\nirq_set_affinity(pcfg->irq, cpumask_of(cpu));\r\nreturn 0;\r\n}\r\nstatic int bman_portal_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct bm_portal_config *pcfg;\r\nstruct resource *addr_phys[2];\r\nvoid __iomem *va;\r\nint irq, cpu;\r\npcfg = devm_kmalloc(dev, sizeof(*pcfg), GFP_KERNEL);\r\nif (!pcfg)\r\nreturn -ENOMEM;\r\npcfg->dev = dev;\r\naddr_phys[0] = platform_get_resource(pdev, IORESOURCE_MEM,\r\nDPAA_PORTAL_CE);\r\nif (!addr_phys[0]) {\r\ndev_err(dev, "Can't get %s property 'reg::CE'\n",\r\nnode->full_name);\r\nreturn -ENXIO;\r\n}\r\naddr_phys[1] = platform_get_resource(pdev, IORESOURCE_MEM,\r\nDPAA_PORTAL_CI);\r\nif (!addr_phys[1]) {\r\ndev_err(dev, "Can't get %s property 'reg::CI'\n",\r\nnode->full_name);\r\nreturn -ENXIO;\r\n}\r\npcfg->cpu = -1;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq <= 0) {\r\ndev_err(dev, "Can't get %s IRQ'\n", node->full_name);\r\nreturn -ENXIO;\r\n}\r\npcfg->irq = irq;\r\nva = ioremap_prot(addr_phys[0]->start, resource_size(addr_phys[0]), 0);\r\nif (!va) {\r\ndev_err(dev, "ioremap::CE failed\n");\r\ngoto err_ioremap1;\r\n}\r\npcfg->addr_virt[DPAA_PORTAL_CE] = va;\r\nva = ioremap_prot(addr_phys[1]->start, resource_size(addr_phys[1]),\r\n_PAGE_GUARDED | _PAGE_NO_CACHE);\r\nif (!va) {\r\ndev_err(dev, "ioremap::CI failed\n");\r\ngoto err_ioremap2;\r\n}\r\npcfg->addr_virt[DPAA_PORTAL_CI] = va;\r\nspin_lock(&bman_lock);\r\ncpu = cpumask_next_zero(-1, &portal_cpus);\r\nif (cpu >= nr_cpu_ids) {\r\nspin_unlock(&bman_lock);\r\nreturn 0;\r\n}\r\ncpumask_set_cpu(cpu, &portal_cpus);\r\nspin_unlock(&bman_lock);\r\npcfg->cpu = cpu;\r\nif (!init_pcfg(pcfg)) {\r\ndev_err(dev, "portal init failed\n");\r\ngoto err_portal_init;\r\n}\r\nif (!cpu_online(cpu))\r\nbman_offline_cpu(cpu);\r\nreturn 0;\r\nerr_portal_init:\r\niounmap(pcfg->addr_virt[DPAA_PORTAL_CI]);\r\nerr_ioremap2:\r\niounmap(pcfg->addr_virt[DPAA_PORTAL_CE]);\r\nerr_ioremap1:\r\nreturn -ENXIO;\r\n}\r\nstatic int __init bman_portal_driver_register(struct platform_driver *drv)\r\n{\r\nint ret;\r\nret = platform_driver_register(drv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\r\n"soc/qbman_portal:online",\r\nbman_online_cpu, bman_offline_cpu);\r\nif (ret < 0) {\r\npr_err("bman: failed to register hotplug callbacks.\n");\r\nplatform_driver_unregister(drv);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
