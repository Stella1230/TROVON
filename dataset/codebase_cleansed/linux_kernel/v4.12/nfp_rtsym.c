static int nfp_meid(u8 island_id, u8 menum)\r\n{\r\nreturn (island_id & 0x3F) == island_id && menum < 12 ?\r\n(island_id << 4) | (menum + 4) : -1;\r\n}\r\nstatic void\r\nnfp_rtsym_sw_entry_init(struct nfp_rtsym_cache *cache, u32 strtab_size,\r\nstruct nfp_rtsym *sw, struct nfp_rtsym_entry *fw)\r\n{\r\nsw->type = fw->type;\r\nsw->name = cache->strtab + le16_to_cpu(fw->name) % strtab_size;\r\nsw->addr = ((u64)fw->addr_hi << 32) | le32_to_cpu(fw->addr_lo);\r\nsw->size = ((u64)fw->size_hi << 32) | le32_to_cpu(fw->size_lo);\r\nswitch (fw->target) {\r\ncase SYM_TGT_LMEM:\r\nsw->target = NFP_RTSYM_TARGET_LMEM;\r\nbreak;\r\ncase SYM_TGT_EMU_CACHE:\r\nsw->target = NFP_RTSYM_TARGET_EMU_CACHE;\r\nbreak;\r\ndefault:\r\nsw->target = fw->target;\r\nbreak;\r\n}\r\nif (fw->menum != 0xff)\r\nsw->domain = nfp_meid(fw->island, fw->menum);\r\nelse if (fw->island != 0xff)\r\nsw->domain = fw->island;\r\nelse\r\nsw->domain = -1;\r\n}\r\nstatic int nfp_rtsymtab_probe(struct nfp_cpp *cpp)\r\n{\r\nconst u32 dram = NFP_CPP_ID(NFP_CPP_TARGET_MU, NFP_CPP_ACTION_RW, 0) |\r\nNFP_ISL_EMEM0;\r\nu32 strtab_addr, symtab_addr, strtab_size, symtab_size;\r\nstruct nfp_rtsym_entry *rtsymtab;\r\nstruct nfp_rtsym_cache *cache;\r\nconst struct nfp_mip *mip;\r\nint err, n, size;\r\nmip = nfp_mip_open(cpp);\r\nif (!mip)\r\nreturn -EIO;\r\nnfp_mip_strtab(mip, &strtab_addr, &strtab_size);\r\nnfp_mip_symtab(mip, &symtab_addr, &symtab_size);\r\nnfp_mip_close(mip);\r\nif (!symtab_size || !strtab_size || symtab_size % sizeof(*rtsymtab))\r\nreturn -ENXIO;\r\nsymtab_size = round_up(symtab_size, 8);\r\nstrtab_size = round_up(strtab_size, 8);\r\nrtsymtab = kmalloc(symtab_size, GFP_KERNEL);\r\nif (!rtsymtab)\r\nreturn -ENOMEM;\r\nsize = sizeof(*cache);\r\nsize += symtab_size / sizeof(*rtsymtab) * sizeof(struct nfp_rtsym);\r\nsize += strtab_size + 1;\r\ncache = kmalloc(size, GFP_KERNEL);\r\nif (!cache) {\r\nerr = -ENOMEM;\r\ngoto err_free_rtsym_raw;\r\n}\r\ncache->num = symtab_size / sizeof(*rtsymtab);\r\ncache->strtab = (void *)&cache->symtab[cache->num];\r\nerr = nfp_cpp_read(cpp, dram, symtab_addr, rtsymtab, symtab_size);\r\nif (err != symtab_size)\r\ngoto err_free_cache;\r\nerr = nfp_cpp_read(cpp, dram, strtab_addr, cache->strtab, strtab_size);\r\nif (err != strtab_size)\r\ngoto err_free_cache;\r\ncache->strtab[strtab_size] = '\0';\r\nfor (n = 0; n < cache->num; n++)\r\nnfp_rtsym_sw_entry_init(cache, strtab_size,\r\n&cache->symtab[n], &rtsymtab[n]);\r\nkfree(rtsymtab);\r\nnfp_rtsym_cache_set(cpp, cache);\r\nreturn 0;\r\nerr_free_cache:\r\nkfree(cache);\r\nerr_free_rtsym_raw:\r\nkfree(rtsymtab);\r\nreturn err;\r\n}\r\nstatic struct nfp_rtsym_cache *nfp_rtsym(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_rtsym_cache *cache;\r\nint err;\r\ncache = nfp_rtsym_cache(cpp);\r\nif (cache)\r\nreturn cache;\r\nerr = nfp_rtsymtab_probe(cpp);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn nfp_rtsym_cache(cpp);\r\n}\r\nint nfp_rtsym_count(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_rtsym_cache *cache;\r\ncache = nfp_rtsym(cpp);\r\nif (IS_ERR(cache))\r\nreturn PTR_ERR(cache);\r\nreturn cache->num;\r\n}\r\nconst struct nfp_rtsym *nfp_rtsym_get(struct nfp_cpp *cpp, int idx)\r\n{\r\nstruct nfp_rtsym_cache *cache;\r\ncache = nfp_rtsym(cpp);\r\nif (IS_ERR(cache))\r\nreturn NULL;\r\nif (idx >= cache->num)\r\nreturn NULL;\r\nreturn &cache->symtab[idx];\r\n}\r\nconst struct nfp_rtsym *nfp_rtsym_lookup(struct nfp_cpp *cpp, const char *name)\r\n{\r\nstruct nfp_rtsym_cache *cache;\r\nint n;\r\ncache = nfp_rtsym(cpp);\r\nif (IS_ERR(cache))\r\nreturn NULL;\r\nfor (n = 0; n < cache->num; n++) {\r\nif (strcmp(name, cache->symtab[n].name) == 0)\r\nreturn &cache->symtab[n];\r\n}\r\nreturn NULL;\r\n}\r\nu64 nfp_rtsym_read_le(struct nfp_cpp *cpp, const char *name, int *error)\r\n{\r\nconst struct nfp_rtsym *sym;\r\nu32 val32, id;\r\nu64 val;\r\nint err;\r\nsym = nfp_rtsym_lookup(cpp, name);\r\nif (!sym) {\r\nerr = -ENOENT;\r\ngoto exit;\r\n}\r\nid = NFP_CPP_ISLAND_ID(sym->target, NFP_CPP_ACTION_RW, 0, sym->domain);\r\nswitch (sym->size) {\r\ncase 4:\r\nerr = nfp_cpp_readl(cpp, id, sym->addr, &val32);\r\nval = val32;\r\nbreak;\r\ncase 8:\r\nerr = nfp_cpp_readq(cpp, id, sym->addr, &val);\r\nbreak;\r\ndefault:\r\nnfp_err(cpp,\r\n"rtsym '%s' unsupported or non-scalar size: %lld\n",\r\nname, sym->size);\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nif (err == sym->size)\r\nerr = 0;\r\nelse if (err >= 0)\r\nerr = -EIO;\r\nexit:\r\nif (error)\r\n*error = err;\r\nif (err)\r\nreturn ~0ULL;\r\nreturn val;\r\n}
