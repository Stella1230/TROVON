static inline unsigned int sg_pool_index(unsigned short nents)\r\n{\r\nunsigned int index;\r\nBUG_ON(nents > SG_CHUNK_SIZE);\r\nif (nents <= 8)\r\nindex = 0;\r\nelse\r\nindex = get_count_order(nents) - 3;\r\nreturn index;\r\n}\r\nstatic void sg_pool_free(struct scatterlist *sgl, unsigned int nents)\r\n{\r\nstruct sg_pool *sgp;\r\nsgp = sg_pools + sg_pool_index(nents);\r\nmempool_free(sgl, sgp->pool);\r\n}\r\nstatic struct scatterlist *sg_pool_alloc(unsigned int nents, gfp_t gfp_mask)\r\n{\r\nstruct sg_pool *sgp;\r\nsgp = sg_pools + sg_pool_index(nents);\r\nreturn mempool_alloc(sgp->pool, gfp_mask);\r\n}\r\nvoid sg_free_table_chained(struct sg_table *table, bool first_chunk)\r\n{\r\nif (first_chunk && table->orig_nents <= SG_CHUNK_SIZE)\r\nreturn;\r\n__sg_free_table(table, SG_CHUNK_SIZE, first_chunk, sg_pool_free);\r\n}\r\nint sg_alloc_table_chained(struct sg_table *table, int nents,\r\nstruct scatterlist *first_chunk)\r\n{\r\nint ret;\r\nBUG_ON(!nents);\r\nif (first_chunk) {\r\nif (nents <= SG_CHUNK_SIZE) {\r\ntable->nents = table->orig_nents = nents;\r\nsg_init_table(table->sgl, nents);\r\nreturn 0;\r\n}\r\n}\r\nret = __sg_alloc_table(table, nents, SG_CHUNK_SIZE,\r\nfirst_chunk, GFP_ATOMIC, sg_pool_alloc);\r\nif (unlikely(ret))\r\nsg_free_table_chained(table, (bool)first_chunk);\r\nreturn ret;\r\n}\r\nstatic __init int sg_pool_init(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SG_MEMPOOL_NR; i++) {\r\nstruct sg_pool *sgp = sg_pools + i;\r\nint size = sgp->size * sizeof(struct scatterlist);\r\nsgp->slab = kmem_cache_create(sgp->name, size, 0,\r\nSLAB_HWCACHE_ALIGN, NULL);\r\nif (!sgp->slab) {\r\nprintk(KERN_ERR "SG_POOL: can't init sg slab %s\n",\r\nsgp->name);\r\ngoto cleanup_sdb;\r\n}\r\nsgp->pool = mempool_create_slab_pool(SG_MEMPOOL_SIZE,\r\nsgp->slab);\r\nif (!sgp->pool) {\r\nprintk(KERN_ERR "SG_POOL: can't init sg mempool %s\n",\r\nsgp->name);\r\ngoto cleanup_sdb;\r\n}\r\n}\r\nreturn 0;\r\ncleanup_sdb:\r\nfor (i = 0; i < SG_MEMPOOL_NR; i++) {\r\nstruct sg_pool *sgp = sg_pools + i;\r\nif (sgp->pool)\r\nmempool_destroy(sgp->pool);\r\nif (sgp->slab)\r\nkmem_cache_destroy(sgp->slab);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nstatic __exit void sg_pool_exit(void)\r\n{\r\nint i;\r\nfor (i = 0; i < SG_MEMPOOL_NR; i++) {\r\nstruct sg_pool *sgp = sg_pools + i;\r\nmempool_destroy(sgp->pool);\r\nkmem_cache_destroy(sgp->slab);\r\n}\r\n}
