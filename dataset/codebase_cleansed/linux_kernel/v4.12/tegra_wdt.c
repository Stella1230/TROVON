static int tegra_wdt_start(struct watchdog_device *wdd)\r\n{\r\nstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu32 val;\r\nval = 1000000ul / 4;\r\nval |= (TIMER_EN | TIMER_PERIODIC);\r\nwritel(val, wdt->tmr_regs + TIMER_PTV);\r\nval = WDT_TIMER_ID |\r\n(wdd->timeout << WDT_CFG_PERIOD_SHIFT) |\r\nWDT_CFG_PMC2CAR_RST_EN;\r\nwritel(val, wdt->wdt_regs + WDT_CFG);\r\nwritel(WDT_CMD_START_COUNTER, wdt->wdt_regs + WDT_CMD);\r\nreturn 0;\r\n}\r\nstatic int tegra_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwritel(WDT_UNLOCK_PATTERN, wdt->wdt_regs + WDT_UNLOCK);\r\nwritel(WDT_CMD_DISABLE_COUNTER, wdt->wdt_regs + WDT_CMD);\r\nwritel(0, wdt->tmr_regs + TIMER_PTV);\r\nreturn 0;\r\n}\r\nstatic int tegra_wdt_ping(struct watchdog_device *wdd)\r\n{\r\nstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\r\nwritel(WDT_CMD_START_COUNTER, wdt->wdt_regs + WDT_CMD);\r\nreturn 0;\r\n}\r\nstatic int tegra_wdt_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nwdd->timeout = timeout;\r\nif (watchdog_active(wdd)) {\r\ntegra_wdt_stop(wdd);\r\nreturn tegra_wdt_start(wdd);\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int tegra_wdt_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct tegra_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu32 val;\r\nint count;\r\nint exp;\r\nval = readl(wdt->wdt_regs + WDT_STS);\r\ncount = (val >> WDT_STS_COUNT_SHIFT) & WDT_STS_COUNT_MASK;\r\nexp = (val >> WDT_STS_EXP_SHIFT) & WDT_STS_EXP_MASK;\r\nreturn (((3 - exp) * wdd->timeout) + count) / 4;\r\n}\r\nstatic int tegra_wdt_probe(struct platform_device *pdev)\r\n{\r\nstruct watchdog_device *wdd;\r\nstruct tegra_wdt *wdt;\r\nstruct resource *res;\r\nvoid __iomem *regs;\r\nint ret;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nregs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(regs))\r\nreturn PTR_ERR(regs);\r\nwdt = devm_kzalloc(&pdev->dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\nwdt->wdt_regs = regs + WDT_BASE;\r\nwdt->tmr_regs = regs + WDT_TIMER_BASE;\r\nwdd = &wdt->wdd;\r\nwdd->timeout = heartbeat;\r\nwdd->info = &tegra_wdt_info;\r\nwdd->ops = &tegra_wdt_ops;\r\nwdd->min_timeout = MIN_WDT_TIMEOUT;\r\nwdd->max_timeout = MAX_WDT_TIMEOUT;\r\nwdd->parent = &pdev->dev;\r\nwatchdog_set_drvdata(wdd, wdt);\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nret = devm_watchdog_register_device(&pdev->dev, wdd);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"failed to register watchdog device\n");\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, wdt);\r\ndev_info(&pdev->dev,\r\n"initialized (heartbeat = %d sec, nowayout = %d)\n",\r\nheartbeat, nowayout);\r\nreturn 0;\r\n}\r\nstatic int tegra_wdt_remove(struct platform_device *pdev)\r\n{\r\nstruct tegra_wdt *wdt = platform_get_drvdata(pdev);\r\ntegra_wdt_stop(&wdt->wdd);\r\ndev_info(&pdev->dev, "removed wdt\n");\r\nreturn 0;\r\n}\r\nstatic int tegra_wdt_runtime_suspend(struct device *dev)\r\n{\r\nstruct tegra_wdt *wdt = dev_get_drvdata(dev);\r\nif (watchdog_active(&wdt->wdd))\r\ntegra_wdt_stop(&wdt->wdd);\r\nreturn 0;\r\n}\r\nstatic int tegra_wdt_runtime_resume(struct device *dev)\r\n{\r\nstruct tegra_wdt *wdt = dev_get_drvdata(dev);\r\nif (watchdog_active(&wdt->wdd))\r\ntegra_wdt_start(&wdt->wdd);\r\nreturn 0;\r\n}
