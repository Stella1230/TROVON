static u8 cp210x_interface_num(struct usb_serial *serial)\r\n{\r\nstruct usb_host_interface *cur_altsetting;\r\ncur_altsetting = serial->interface->cur_altsetting;\r\nreturn cur_altsetting->desc.bInterfaceNumber;\r\n}\r\nstatic int cp210x_read_reg_block(struct usb_serial_port *port, u8 req,\r\nvoid *buf, int bufsize)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\r\nvoid *dmabuf;\r\nint result;\r\ndmabuf = kmalloc(bufsize, GFP_KERNEL);\r\nif (!dmabuf) {\r\nmemset(buf, 0, bufsize);\r\nreturn -ENOMEM;\r\n}\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nreq, REQTYPE_INTERFACE_TO_HOST, 0,\r\nport_priv->bInterfaceNumber, dmabuf, bufsize,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (result == bufsize) {\r\nmemcpy(buf, dmabuf, bufsize);\r\nresult = 0;\r\n} else {\r\ndev_err(&port->dev, "failed get req 0x%x size %d status: %d\n",\r\nreq, bufsize, result);\r\nif (result >= 0)\r\nresult = -EIO;\r\nmemset(buf, 0, bufsize);\r\n}\r\nkfree(dmabuf);\r\nreturn result;\r\n}\r\nstatic int cp210x_read_u32_reg(struct usb_serial_port *port, u8 req, u32 *val)\r\n{\r\n__le32 le32_val;\r\nint err;\r\nerr = cp210x_read_reg_block(port, req, &le32_val, sizeof(le32_val));\r\nif (err) {\r\n*val = 0;\r\nreturn err;\r\n}\r\n*val = le32_to_cpu(le32_val);\r\nreturn 0;\r\n}\r\nstatic int cp210x_read_u16_reg(struct usb_serial_port *port, u8 req, u16 *val)\r\n{\r\n__le16 le16_val;\r\nint err;\r\nerr = cp210x_read_reg_block(port, req, &le16_val, sizeof(le16_val));\r\nif (err)\r\nreturn err;\r\n*val = le16_to_cpu(le16_val);\r\nreturn 0;\r\n}\r\nstatic int cp210x_read_u8_reg(struct usb_serial_port *port, u8 req, u8 *val)\r\n{\r\nreturn cp210x_read_reg_block(port, req, val, sizeof(*val));\r\n}\r\nstatic int cp210x_read_vendor_block(struct usb_serial *serial, u8 type, u16 val,\r\nvoid *buf, int bufsize)\r\n{\r\nvoid *dmabuf;\r\nint result;\r\ndmabuf = kmalloc(bufsize, GFP_KERNEL);\r\nif (!dmabuf)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nCP210X_VENDOR_SPECIFIC, type, val,\r\ncp210x_interface_num(serial), dmabuf, bufsize,\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (result == bufsize) {\r\nmemcpy(buf, dmabuf, bufsize);\r\nresult = 0;\r\n} else {\r\ndev_err(&serial->interface->dev,\r\n"failed to get vendor val 0x%04x size %d: %d\n", val,\r\nbufsize, result);\r\nif (result >= 0)\r\nresult = -EIO;\r\n}\r\nkfree(dmabuf);\r\nreturn result;\r\n}\r\nstatic int cp210x_write_u16_reg(struct usb_serial_port *port, u8 req, u16 val)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\r\nint result;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nreq, REQTYPE_HOST_TO_INTERFACE, val,\r\nport_priv->bInterfaceNumber, NULL, 0,\r\nUSB_CTRL_SET_TIMEOUT);\r\nif (result < 0) {\r\ndev_err(&port->dev, "failed set request 0x%x status: %d\n",\r\nreq, result);\r\n}\r\nreturn result;\r\n}\r\nstatic int cp210x_write_reg_block(struct usb_serial_port *port, u8 req,\r\nvoid *buf, int bufsize)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\r\nvoid *dmabuf;\r\nint result;\r\ndmabuf = kmemdup(buf, bufsize, GFP_KERNEL);\r\nif (!dmabuf)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nreq, REQTYPE_HOST_TO_INTERFACE, 0,\r\nport_priv->bInterfaceNumber, dmabuf, bufsize,\r\nUSB_CTRL_SET_TIMEOUT);\r\nkfree(dmabuf);\r\nif (result == bufsize) {\r\nresult = 0;\r\n} else {\r\ndev_err(&port->dev, "failed set req 0x%x size %d status: %d\n",\r\nreq, bufsize, result);\r\nif (result >= 0)\r\nresult = -EIO;\r\n}\r\nreturn result;\r\n}\r\nstatic int cp210x_write_u32_reg(struct usb_serial_port *port, u8 req, u32 val)\r\n{\r\n__le32 le32_val;\r\nle32_val = cpu_to_le32(val);\r\nreturn cp210x_write_reg_block(port, req, &le32_val, sizeof(le32_val));\r\n}\r\nstatic int cp210x_write_vendor_block(struct usb_serial *serial, u8 type,\r\nu16 val, void *buf, int bufsize)\r\n{\r\nvoid *dmabuf;\r\nint result;\r\ndmabuf = kmemdup(buf, bufsize, GFP_KERNEL);\r\nif (!dmabuf)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\r\nCP210X_VENDOR_SPECIFIC, type, val,\r\ncp210x_interface_num(serial), dmabuf, bufsize,\r\nUSB_CTRL_SET_TIMEOUT);\r\nkfree(dmabuf);\r\nif (result == bufsize) {\r\nresult = 0;\r\n} else {\r\ndev_err(&serial->interface->dev,\r\n"failed to set vendor val 0x%04x size %d: %d\n", val,\r\nbufsize, result);\r\nif (result >= 0)\r\nresult = -EIO;\r\n}\r\nreturn result;\r\n}\r\nstatic int cp210x_detect_swapped_line_ctl(struct usb_serial_port *port)\r\n{\r\nstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\r\nu16 line_ctl_save;\r\nu16 line_ctl_test;\r\nint err;\r\nerr = cp210x_read_u16_reg(port, CP210X_GET_LINE_CTL, &line_ctl_save);\r\nif (err)\r\nreturn err;\r\nerr = cp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, 0x800);\r\nif (err)\r\nreturn err;\r\nerr = cp210x_read_u16_reg(port, CP210X_GET_LINE_CTL, &line_ctl_test);\r\nif (err)\r\nreturn err;\r\nif (line_ctl_test == 8) {\r\nport_priv->has_swapped_line_ctl = true;\r\nline_ctl_save = swab16(line_ctl_save);\r\n}\r\nreturn cp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, line_ctl_save);\r\n}\r\nstatic int cp210x_get_line_ctl(struct usb_serial_port *port, u16 *ctl)\r\n{\r\nstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\r\nint err;\r\nerr = cp210x_read_u16_reg(port, CP210X_GET_LINE_CTL, ctl);\r\nif (err)\r\nreturn err;\r\nif (port_priv->has_swapped_line_ctl)\r\n*ctl = swab16(*ctl);\r\nreturn 0;\r\n}\r\nstatic unsigned int cp210x_quantise_baudrate(unsigned int baud)\r\n{\r\nif (baud <= 300)\r\nbaud = 300;\r\nelse if (baud <= 600) baud = 600;\r\nelse if (baud <= 1200) baud = 1200;\r\nelse if (baud <= 1800) baud = 1800;\r\nelse if (baud <= 2400) baud = 2400;\r\nelse if (baud <= 4000) baud = 4000;\r\nelse if (baud <= 4803) baud = 4800;\r\nelse if (baud <= 7207) baud = 7200;\r\nelse if (baud <= 9612) baud = 9600;\r\nelse if (baud <= 14428) baud = 14400;\r\nelse if (baud <= 16062) baud = 16000;\r\nelse if (baud <= 19250) baud = 19200;\r\nelse if (baud <= 28912) baud = 28800;\r\nelse if (baud <= 38601) baud = 38400;\r\nelse if (baud <= 51558) baud = 51200;\r\nelse if (baud <= 56280) baud = 56000;\r\nelse if (baud <= 58053) baud = 57600;\r\nelse if (baud <= 64111) baud = 64000;\r\nelse if (baud <= 77608) baud = 76800;\r\nelse if (baud <= 117028) baud = 115200;\r\nelse if (baud <= 129347) baud = 128000;\r\nelse if (baud <= 156868) baud = 153600;\r\nelse if (baud <= 237832) baud = 230400;\r\nelse if (baud <= 254234) baud = 250000;\r\nelse if (baud <= 273066) baud = 256000;\r\nelse if (baud <= 491520) baud = 460800;\r\nelse if (baud <= 567138) baud = 500000;\r\nelse if (baud <= 670254) baud = 576000;\r\nelse if (baud < 1000000)\r\nbaud = 921600;\r\nelse if (baud > 2000000)\r\nbaud = 2000000;\r\nreturn baud;\r\n}\r\nstatic int cp210x_open(struct tty_struct *tty, struct usb_serial_port *port)\r\n{\r\nint result;\r\nresult = cp210x_write_u16_reg(port, CP210X_IFC_ENABLE, UART_ENABLE);\r\nif (result) {\r\ndev_err(&port->dev, "%s - Unable to enable UART\n", __func__);\r\nreturn result;\r\n}\r\ncp210x_get_termios(tty, port);\r\nif (tty)\r\ncp210x_change_speed(tty, port, NULL);\r\nreturn usb_serial_generic_open(tty, port);\r\n}\r\nstatic void cp210x_close(struct usb_serial_port *port)\r\n{\r\nusb_serial_generic_close(port);\r\ncp210x_write_u16_reg(port, CP210X_PURGE, PURGE_ALL);\r\ncp210x_write_u16_reg(port, CP210X_IFC_ENABLE, UART_DISABLE);\r\n}\r\nstatic int cp210x_get_tx_queue_byte_count(struct usb_serial_port *port,\r\nu32 *count)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\r\nstruct cp210x_comm_status *sts;\r\nint result;\r\nsts = kmalloc(sizeof(*sts), GFP_KERNEL);\r\nif (!sts)\r\nreturn -ENOMEM;\r\nresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\r\nCP210X_GET_COMM_STATUS, REQTYPE_INTERFACE_TO_HOST,\r\n0, port_priv->bInterfaceNumber, sts, sizeof(*sts),\r\nUSB_CTRL_GET_TIMEOUT);\r\nif (result == sizeof(*sts)) {\r\n*count = le32_to_cpu(sts->ulAmountInOutQueue);\r\nresult = 0;\r\n} else {\r\ndev_err(&port->dev, "failed to get comm status: %d\n", result);\r\nif (result >= 0)\r\nresult = -EIO;\r\n}\r\nkfree(sts);\r\nreturn result;\r\n}\r\nstatic bool cp210x_tx_empty(struct usb_serial_port *port)\r\n{\r\nint err;\r\nu32 count;\r\nerr = cp210x_get_tx_queue_byte_count(port, &count);\r\nif (err)\r\nreturn true;\r\nreturn !count;\r\n}\r\nstatic void cp210x_get_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port)\r\n{\r\nunsigned int baud;\r\nif (tty) {\r\ncp210x_get_termios_port(tty->driver_data,\r\n&tty->termios.c_cflag, &baud);\r\ntty_encode_baud_rate(tty, baud, baud);\r\n} else {\r\ntcflag_t cflag;\r\ncflag = 0;\r\ncp210x_get_termios_port(port, &cflag, &baud);\r\n}\r\n}\r\nstatic void cp210x_get_termios_port(struct usb_serial_port *port,\r\ntcflag_t *cflagp, unsigned int *baudp)\r\n{\r\nstruct device *dev = &port->dev;\r\ntcflag_t cflag;\r\nstruct cp210x_flow_ctl flow_ctl;\r\nu32 baud;\r\nu16 bits;\r\nu32 ctl_hs;\r\ncp210x_read_u32_reg(port, CP210X_GET_BAUDRATE, &baud);\r\ndev_dbg(dev, "%s - baud rate = %d\n", __func__, baud);\r\n*baudp = baud;\r\ncflag = *cflagp;\r\ncp210x_get_line_ctl(port, &bits);\r\ncflag &= ~CSIZE;\r\nswitch (bits & BITS_DATA_MASK) {\r\ncase BITS_DATA_5:\r\ndev_dbg(dev, "%s - data bits = 5\n", __func__);\r\ncflag |= CS5;\r\nbreak;\r\ncase BITS_DATA_6:\r\ndev_dbg(dev, "%s - data bits = 6\n", __func__);\r\ncflag |= CS6;\r\nbreak;\r\ncase BITS_DATA_7:\r\ndev_dbg(dev, "%s - data bits = 7\n", __func__);\r\ncflag |= CS7;\r\nbreak;\r\ncase BITS_DATA_8:\r\ndev_dbg(dev, "%s - data bits = 8\n", __func__);\r\ncflag |= CS8;\r\nbreak;\r\ncase BITS_DATA_9:\r\ndev_dbg(dev, "%s - data bits = 9 (not supported, using 8 data bits)\n", __func__);\r\ncflag |= CS8;\r\nbits &= ~BITS_DATA_MASK;\r\nbits |= BITS_DATA_8;\r\ncp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s - Unknown number of data bits, using 8\n", __func__);\r\ncflag |= CS8;\r\nbits &= ~BITS_DATA_MASK;\r\nbits |= BITS_DATA_8;\r\ncp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\r\nbreak;\r\n}\r\nswitch (bits & BITS_PARITY_MASK) {\r\ncase BITS_PARITY_NONE:\r\ndev_dbg(dev, "%s - parity = NONE\n", __func__);\r\ncflag &= ~PARENB;\r\nbreak;\r\ncase BITS_PARITY_ODD:\r\ndev_dbg(dev, "%s - parity = ODD\n", __func__);\r\ncflag |= (PARENB|PARODD);\r\nbreak;\r\ncase BITS_PARITY_EVEN:\r\ndev_dbg(dev, "%s - parity = EVEN\n", __func__);\r\ncflag &= ~PARODD;\r\ncflag |= PARENB;\r\nbreak;\r\ncase BITS_PARITY_MARK:\r\ndev_dbg(dev, "%s - parity = MARK\n", __func__);\r\ncflag |= (PARENB|PARODD|CMSPAR);\r\nbreak;\r\ncase BITS_PARITY_SPACE:\r\ndev_dbg(dev, "%s - parity = SPACE\n", __func__);\r\ncflag &= ~PARODD;\r\ncflag |= (PARENB|CMSPAR);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s - Unknown parity mode, disabling parity\n", __func__);\r\ncflag &= ~PARENB;\r\nbits &= ~BITS_PARITY_MASK;\r\ncp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\r\nbreak;\r\n}\r\ncflag &= ~CSTOPB;\r\nswitch (bits & BITS_STOP_MASK) {\r\ncase BITS_STOP_1:\r\ndev_dbg(dev, "%s - stop bits = 1\n", __func__);\r\nbreak;\r\ncase BITS_STOP_1_5:\r\ndev_dbg(dev, "%s - stop bits = 1.5 (not supported, using 1 stop bit)\n", __func__);\r\nbits &= ~BITS_STOP_MASK;\r\ncp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\r\nbreak;\r\ncase BITS_STOP_2:\r\ndev_dbg(dev, "%s - stop bits = 2\n", __func__);\r\ncflag |= CSTOPB;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s - Unknown number of stop bits, using 1 stop bit\n", __func__);\r\nbits &= ~BITS_STOP_MASK;\r\ncp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\r\nbreak;\r\n}\r\ncp210x_read_reg_block(port, CP210X_GET_FLOW, &flow_ctl,\r\nsizeof(flow_ctl));\r\nctl_hs = le32_to_cpu(flow_ctl.ulControlHandshake);\r\nif (ctl_hs & CP210X_SERIAL_CTS_HANDSHAKE) {\r\ndev_dbg(dev, "%s - flow control = CRTSCTS\n", __func__);\r\ncflag |= CRTSCTS;\r\n} else {\r\ndev_dbg(dev, "%s - flow control = NONE\n", __func__);\r\ncflag &= ~CRTSCTS;\r\n}\r\n*cflagp = cflag;\r\n}\r\nstatic void cp210x_change_speed(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nu32 baud;\r\nbaud = tty->termios.c_ospeed;\r\nbaud = cp210x_quantise_baudrate(baud);\r\ndev_dbg(&port->dev, "%s - setting baud rate to %u\n", __func__, baud);\r\nif (cp210x_write_u32_reg(port, CP210X_SET_BAUDRATE, baud)) {\r\ndev_warn(&port->dev, "failed to set baud rate to %u\n", baud);\r\nif (old_termios)\r\nbaud = old_termios->c_ospeed;\r\nelse\r\nbaud = 9600;\r\n}\r\ntty_encode_baud_rate(tty, baud, baud);\r\n}\r\nstatic void cp210x_set_termios(struct tty_struct *tty,\r\nstruct usb_serial_port *port, struct ktermios *old_termios)\r\n{\r\nstruct device *dev = &port->dev;\r\nunsigned int cflag, old_cflag;\r\nu16 bits;\r\ncflag = tty->termios.c_cflag;\r\nold_cflag = old_termios->c_cflag;\r\nif (tty->termios.c_ospeed != old_termios->c_ospeed)\r\ncp210x_change_speed(tty, port, old_termios);\r\nif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\r\ncp210x_get_line_ctl(port, &bits);\r\nbits &= ~BITS_DATA_MASK;\r\nswitch (cflag & CSIZE) {\r\ncase CS5:\r\nbits |= BITS_DATA_5;\r\ndev_dbg(dev, "%s - data bits = 5\n", __func__);\r\nbreak;\r\ncase CS6:\r\nbits |= BITS_DATA_6;\r\ndev_dbg(dev, "%s - data bits = 6\n", __func__);\r\nbreak;\r\ncase CS7:\r\nbits |= BITS_DATA_7;\r\ndev_dbg(dev, "%s - data bits = 7\n", __func__);\r\nbreak;\r\ncase CS8:\r\ndefault:\r\nbits |= BITS_DATA_8;\r\ndev_dbg(dev, "%s - data bits = 8\n", __func__);\r\nbreak;\r\n}\r\nif (cp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits))\r\ndev_dbg(dev, "Number of data bits requested not supported by device\n");\r\n}\r\nif ((cflag & (PARENB|PARODD|CMSPAR)) !=\r\n(old_cflag & (PARENB|PARODD|CMSPAR))) {\r\ncp210x_get_line_ctl(port, &bits);\r\nbits &= ~BITS_PARITY_MASK;\r\nif (cflag & PARENB) {\r\nif (cflag & CMSPAR) {\r\nif (cflag & PARODD) {\r\nbits |= BITS_PARITY_MARK;\r\ndev_dbg(dev, "%s - parity = MARK\n", __func__);\r\n} else {\r\nbits |= BITS_PARITY_SPACE;\r\ndev_dbg(dev, "%s - parity = SPACE\n", __func__);\r\n}\r\n} else {\r\nif (cflag & PARODD) {\r\nbits |= BITS_PARITY_ODD;\r\ndev_dbg(dev, "%s - parity = ODD\n", __func__);\r\n} else {\r\nbits |= BITS_PARITY_EVEN;\r\ndev_dbg(dev, "%s - parity = EVEN\n", __func__);\r\n}\r\n}\r\n}\r\nif (cp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits))\r\ndev_dbg(dev, "Parity mode not supported by device\n");\r\n}\r\nif ((cflag & CSTOPB) != (old_cflag & CSTOPB)) {\r\ncp210x_get_line_ctl(port, &bits);\r\nbits &= ~BITS_STOP_MASK;\r\nif (cflag & CSTOPB) {\r\nbits |= BITS_STOP_2;\r\ndev_dbg(dev, "%s - stop bits = 2\n", __func__);\r\n} else {\r\nbits |= BITS_STOP_1;\r\ndev_dbg(dev, "%s - stop bits = 1\n", __func__);\r\n}\r\nif (cp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits))\r\ndev_dbg(dev, "Number of stop bits requested not supported by device\n");\r\n}\r\nif ((cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\r\nstruct cp210x_flow_ctl flow_ctl;\r\nu32 ctl_hs;\r\nu32 flow_repl;\r\ncp210x_read_reg_block(port, CP210X_GET_FLOW, &flow_ctl,\r\nsizeof(flow_ctl));\r\nctl_hs = le32_to_cpu(flow_ctl.ulControlHandshake);\r\nflow_repl = le32_to_cpu(flow_ctl.ulFlowReplace);\r\ndev_dbg(dev, "%s - read ulControlHandshake=0x%08x, ulFlowReplace=0x%08x\n",\r\n__func__, ctl_hs, flow_repl);\r\nctl_hs &= ~CP210X_SERIAL_DSR_HANDSHAKE;\r\nctl_hs &= ~CP210X_SERIAL_DCD_HANDSHAKE;\r\nctl_hs &= ~CP210X_SERIAL_DSR_SENSITIVITY;\r\nctl_hs &= ~CP210X_SERIAL_DTR_MASK;\r\nctl_hs |= CP210X_SERIAL_DTR_SHIFT(CP210X_SERIAL_DTR_ACTIVE);\r\nif (cflag & CRTSCTS) {\r\nctl_hs |= CP210X_SERIAL_CTS_HANDSHAKE;\r\nflow_repl &= ~CP210X_SERIAL_RTS_MASK;\r\nflow_repl |= CP210X_SERIAL_RTS_SHIFT(\r\nCP210X_SERIAL_RTS_FLOW_CTL);\r\ndev_dbg(dev, "%s - flow control = CRTSCTS\n", __func__);\r\n} else {\r\nctl_hs &= ~CP210X_SERIAL_CTS_HANDSHAKE;\r\nflow_repl &= ~CP210X_SERIAL_RTS_MASK;\r\nflow_repl |= CP210X_SERIAL_RTS_SHIFT(\r\nCP210X_SERIAL_RTS_ACTIVE);\r\ndev_dbg(dev, "%s - flow control = NONE\n", __func__);\r\n}\r\ndev_dbg(dev, "%s - write ulControlHandshake=0x%08x, ulFlowReplace=0x%08x\n",\r\n__func__, ctl_hs, flow_repl);\r\nflow_ctl.ulControlHandshake = cpu_to_le32(ctl_hs);\r\nflow_ctl.ulFlowReplace = cpu_to_le32(flow_repl);\r\ncp210x_write_reg_block(port, CP210X_SET_FLOW, &flow_ctl,\r\nsizeof(flow_ctl));\r\n}\r\n}\r\nstatic int cp210x_tiocmset(struct tty_struct *tty,\r\nunsigned int set, unsigned int clear)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nreturn cp210x_tiocmset_port(port, set, clear);\r\n}\r\nstatic int cp210x_tiocmset_port(struct usb_serial_port *port,\r\nunsigned int set, unsigned int clear)\r\n{\r\nu16 control = 0;\r\nif (set & TIOCM_RTS) {\r\ncontrol |= CONTROL_RTS;\r\ncontrol |= CONTROL_WRITE_RTS;\r\n}\r\nif (set & TIOCM_DTR) {\r\ncontrol |= CONTROL_DTR;\r\ncontrol |= CONTROL_WRITE_DTR;\r\n}\r\nif (clear & TIOCM_RTS) {\r\ncontrol &= ~CONTROL_RTS;\r\ncontrol |= CONTROL_WRITE_RTS;\r\n}\r\nif (clear & TIOCM_DTR) {\r\ncontrol &= ~CONTROL_DTR;\r\ncontrol |= CONTROL_WRITE_DTR;\r\n}\r\ndev_dbg(&port->dev, "%s - control = 0x%.4x\n", __func__, control);\r\nreturn cp210x_write_u16_reg(port, CP210X_SET_MHS, control);\r\n}\r\nstatic void cp210x_dtr_rts(struct usb_serial_port *p, int on)\r\n{\r\nif (on)\r\ncp210x_tiocmset_port(p, TIOCM_DTR|TIOCM_RTS, 0);\r\nelse\r\ncp210x_tiocmset_port(p, 0, TIOCM_DTR|TIOCM_RTS);\r\n}\r\nstatic int cp210x_tiocmget(struct tty_struct *tty)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nu8 control;\r\nint result;\r\nresult = cp210x_read_u8_reg(port, CP210X_GET_MDMSTS, &control);\r\nif (result)\r\nreturn result;\r\nresult = ((control & CONTROL_DTR) ? TIOCM_DTR : 0)\r\n|((control & CONTROL_RTS) ? TIOCM_RTS : 0)\r\n|((control & CONTROL_CTS) ? TIOCM_CTS : 0)\r\n|((control & CONTROL_DSR) ? TIOCM_DSR : 0)\r\n|((control & CONTROL_RING)? TIOCM_RI : 0)\r\n|((control & CONTROL_DCD) ? TIOCM_CD : 0);\r\ndev_dbg(&port->dev, "%s - control = 0x%.2x\n", __func__, control);\r\nreturn result;\r\n}\r\nstatic void cp210x_break_ctl(struct tty_struct *tty, int break_state)\r\n{\r\nstruct usb_serial_port *port = tty->driver_data;\r\nu16 state;\r\nif (break_state == 0)\r\nstate = BREAK_OFF;\r\nelse\r\nstate = BREAK_ON;\r\ndev_dbg(&port->dev, "%s - turning break %s\n", __func__,\r\nstate == BREAK_OFF ? "off" : "on");\r\ncp210x_write_u16_reg(port, CP210X_SET_BREAK, state);\r\n}\r\nstatic int cp210x_gpio_request(struct gpio_chip *gc, unsigned int offset)\r\n{\r\nstruct usb_serial *serial = gpiochip_get_data(gc);\r\nstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\r\nswitch (offset) {\r\ncase 0:\r\nif (priv->config & CP2105_GPIO0_TXLED_MODE)\r\nreturn -ENODEV;\r\nbreak;\r\ncase 1:\r\nif (priv->config & (CP2105_GPIO1_RXLED_MODE |\r\nCP2105_GPIO1_RS485_MODE))\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cp210x_gpio_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nstruct usb_serial *serial = gpiochip_get_data(gc);\r\nint result;\r\nu8 buf;\r\nresult = cp210x_read_vendor_block(serial, REQTYPE_INTERFACE_TO_HOST,\r\nCP210X_READ_LATCH, &buf, sizeof(buf));\r\nif (result < 0)\r\nreturn result;\r\nreturn !!(buf & BIT(gpio));\r\n}\r\nstatic void cp210x_gpio_set(struct gpio_chip *gc, unsigned int gpio, int value)\r\n{\r\nstruct usb_serial *serial = gpiochip_get_data(gc);\r\nstruct cp210x_gpio_write buf;\r\nif (value == 1)\r\nbuf.state = BIT(gpio);\r\nelse\r\nbuf.state = 0;\r\nbuf.mask = BIT(gpio);\r\ncp210x_write_vendor_block(serial, REQTYPE_HOST_TO_INTERFACE,\r\nCP210X_WRITE_LATCH, &buf, sizeof(buf));\r\n}\r\nstatic int cp210x_gpio_direction_get(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cp210x_gpio_direction_input(struct gpio_chip *gc, unsigned int gpio)\r\n{\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int cp210x_gpio_direction_output(struct gpio_chip *gc, unsigned int gpio,\r\nint value)\r\n{\r\nreturn 0;\r\n}\r\nstatic int cp210x_gpio_set_config(struct gpio_chip *gc, unsigned int gpio,\r\nunsigned long config)\r\n{\r\nstruct usb_serial *serial = gpiochip_get_data(gc);\r\nstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\r\nenum pin_config_param param = pinconf_to_config_param(config);\r\nif ((param == PIN_CONFIG_DRIVE_PUSH_PULL) &&\r\n(priv->gpio_mode & BIT(gpio)))\r\nreturn 0;\r\nif ((param == PIN_CONFIG_DRIVE_OPEN_DRAIN) &&\r\n!(priv->gpio_mode & BIT(gpio)))\r\nreturn 0;\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int cp2105_shared_gpio_init(struct usb_serial *serial)\r\n{\r\nstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\r\nstruct cp210x_pin_mode mode;\r\nstruct cp210x_config config;\r\nu8 intf_num = cp210x_interface_num(serial);\r\nint result;\r\nresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\r\nCP210X_GET_DEVICEMODE, &mode,\r\nsizeof(mode));\r\nif (result < 0)\r\nreturn result;\r\nresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\r\nCP210X_GET_PORTCONFIG, &config,\r\nsizeof(config));\r\nif (result < 0)\r\nreturn result;\r\nif (intf_num == 0) {\r\nif (mode.eci == CP210X_PIN_MODE_MODEM)\r\nreturn 0;\r\npriv->config = config.eci_cfg;\r\npriv->gpio_mode = (u8)((le16_to_cpu(config.gpio_mode) &\r\nCP210X_ECI_GPIO_MODE_MASK) >>\r\nCP210X_ECI_GPIO_MODE_OFFSET);\r\npriv->gc.ngpio = 2;\r\n} else if (intf_num == 1) {\r\nif (mode.sci == CP210X_PIN_MODE_MODEM)\r\nreturn 0;\r\npriv->config = config.sci_cfg;\r\npriv->gpio_mode = (u8)((le16_to_cpu(config.gpio_mode) &\r\nCP210X_SCI_GPIO_MODE_MASK) >>\r\nCP210X_SCI_GPIO_MODE_OFFSET);\r\npriv->gc.ngpio = 3;\r\n} else {\r\nreturn -ENODEV;\r\n}\r\npriv->gc.label = "cp210x";\r\npriv->gc.request = cp210x_gpio_request;\r\npriv->gc.get_direction = cp210x_gpio_direction_get;\r\npriv->gc.direction_input = cp210x_gpio_direction_input;\r\npriv->gc.direction_output = cp210x_gpio_direction_output;\r\npriv->gc.get = cp210x_gpio_get;\r\npriv->gc.set = cp210x_gpio_set;\r\npriv->gc.set_config = cp210x_gpio_set_config;\r\npriv->gc.owner = THIS_MODULE;\r\npriv->gc.parent = &serial->interface->dev;\r\npriv->gc.base = -1;\r\npriv->gc.can_sleep = true;\r\nresult = gpiochip_add_data(&priv->gc, serial);\r\nif (!result)\r\npriv->gpio_registered = true;\r\nreturn result;\r\n}\r\nstatic void cp210x_gpio_remove(struct usb_serial *serial)\r\n{\r\nstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\r\nif (priv->gpio_registered) {\r\ngpiochip_remove(&priv->gc);\r\npriv->gpio_registered = false;\r\n}\r\n}\r\nstatic int cp2105_shared_gpio_init(struct usb_serial *serial)\r\n{\r\nreturn 0;\r\n}\r\nstatic void cp210x_gpio_remove(struct usb_serial *serial)\r\n{\r\n}\r\nstatic int cp210x_port_probe(struct usb_serial_port *port)\r\n{\r\nstruct usb_serial *serial = port->serial;\r\nstruct cp210x_port_private *port_priv;\r\nint ret;\r\nport_priv = kzalloc(sizeof(*port_priv), GFP_KERNEL);\r\nif (!port_priv)\r\nreturn -ENOMEM;\r\nport_priv->bInterfaceNumber = cp210x_interface_num(serial);\r\nusb_set_serial_port_data(port, port_priv);\r\nret = cp210x_detect_swapped_line_ctl(port);\r\nif (ret) {\r\nkfree(port_priv);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cp210x_port_remove(struct usb_serial_port *port)\r\n{\r\nstruct cp210x_port_private *port_priv;\r\nport_priv = usb_get_serial_port_data(port);\r\nkfree(port_priv);\r\nreturn 0;\r\n}\r\nstatic int cp210x_attach(struct usb_serial *serial)\r\n{\r\nint result;\r\nstruct cp210x_serial_private *priv;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\r\nCP210X_GET_PARTNUM, &priv->partnum,\r\nsizeof(priv->partnum));\r\nif (result < 0)\r\ngoto err_free_priv;\r\nusb_set_serial_data(serial, priv);\r\nif (priv->partnum == CP210X_PARTNUM_CP2105) {\r\nresult = cp2105_shared_gpio_init(serial);\r\nif (result < 0) {\r\ndev_err(&serial->interface->dev,\r\n"GPIO initialisation failed, continuing without GPIO support\n");\r\n}\r\n}\r\nreturn 0;\r\nerr_free_priv:\r\nkfree(priv);\r\nreturn result;\r\n}\r\nstatic void cp210x_disconnect(struct usb_serial *serial)\r\n{\r\ncp210x_gpio_remove(serial);\r\n}\r\nstatic void cp210x_release(struct usb_serial *serial)\r\n{\r\nstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\r\ncp210x_gpio_remove(serial);\r\nkfree(priv);\r\n}
