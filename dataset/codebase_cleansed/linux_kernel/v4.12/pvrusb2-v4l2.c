static int pvr2_querycap(struct file *file, void *priv, struct v4l2_capability *cap)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstrlcpy(cap->driver, "pvrusb2", sizeof(cap->driver));\r\nstrlcpy(cap->bus_info, pvr2_hdw_get_bus_info(hdw),\r\nsizeof(cap->bus_info));\r\nstrlcpy(cap->card, pvr2_hdw_get_desc(hdw), sizeof(cap->card));\r\ncap->capabilities = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_TUNER |\r\nV4L2_CAP_AUDIO | V4L2_CAP_RADIO |\r\nV4L2_CAP_READWRITE | V4L2_CAP_DEVICE_CAPS;\r\nswitch (fh->pdi->devbase.vfl_type) {\r\ncase VFL_TYPE_GRABBER:\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_AUDIO;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\ncap->device_caps = V4L2_CAP_RADIO;\r\nbreak;\r\n}\r\ncap->device_caps |= V4L2_CAP_TUNER | V4L2_CAP_READWRITE;\r\nreturn 0;\r\n}\r\nstatic int pvr2_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint val = 0;\r\nint ret;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_STDCUR), &val);\r\n*std = val;\r\nreturn ret;\r\n}\r\nstatic int pvr2_s_std(struct file *file, void *priv, v4l2_std_id std)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nreturn pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_STDCUR), std);\r\n}\r\nstatic int pvr2_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint val = 0;\r\nint ret;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_STDDETECT), &val);\r\n*std = val;\r\nreturn ret;\r\n}\r\nstatic int pvr2_enum_input(struct file *file, void *priv, struct v4l2_input *vi)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct pvr2_ctrl *cptr;\r\nstruct v4l2_input tmp;\r\nunsigned int cnt;\r\nint val;\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT);\r\nmemset(&tmp, 0, sizeof(tmp));\r\ntmp.index = vi->index;\r\nif (vi->index >= fh->input_cnt)\r\nreturn -EINVAL;\r\nval = fh->input_map[vi->index];\r\nswitch (val) {\r\ncase PVR2_CVAL_INPUT_TV:\r\ncase PVR2_CVAL_INPUT_DTV:\r\ncase PVR2_CVAL_INPUT_RADIO:\r\ntmp.type = V4L2_INPUT_TYPE_TUNER;\r\nbreak;\r\ncase PVR2_CVAL_INPUT_SVIDEO:\r\ncase PVR2_CVAL_INPUT_COMPOSITE:\r\ntmp.type = V4L2_INPUT_TYPE_CAMERA;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncnt = 0;\r\npvr2_ctrl_get_valname(cptr, val,\r\ntmp.name, sizeof(tmp.name) - 1, &cnt);\r\ntmp.name[cnt] = 0;\r\n*vi = tmp;\r\nreturn 0;\r\n}\r\nstatic int pvr2_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nunsigned int idx;\r\nstruct pvr2_ctrl *cptr;\r\nint val;\r\nint ret;\r\ncptr = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT);\r\nval = 0;\r\nret = pvr2_ctrl_get_value(cptr, &val);\r\n*i = 0;\r\nfor (idx = 0; idx < fh->input_cnt; idx++) {\r\nif (fh->input_map[idx] == val) {\r\n*i = idx;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int pvr2_s_input(struct file *file, void *priv, unsigned int inp)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nif (inp >= fh->input_cnt)\r\nreturn -EINVAL;\r\nreturn pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT),\r\nfh->input_map[inp]);\r\n}\r\nstatic int pvr2_enumaudio(struct file *file, void *priv, struct v4l2_audio *vin)\r\n{\r\nif (vin->index > 0)\r\nreturn -EINVAL;\r\nstrncpy(vin->name, "PVRUSB2 Audio", 14);\r\nvin->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int pvr2_g_audio(struct file *file, void *priv, struct v4l2_audio *vin)\r\n{\r\nvin->index = 0;\r\nstrncpy(vin->name, "PVRUSB2 Audio", 14);\r\nvin->capability = V4L2_AUDCAP_STEREO;\r\nreturn 0;\r\n}\r\nstatic int pvr2_s_audio(struct file *file, void *priv, const struct v4l2_audio *vout)\r\n{\r\nif (vout->index)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pvr2_g_tuner(struct file *file, void *priv, struct v4l2_tuner *vt)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\npvr2_hdw_execute_tuner_poll(hdw);\r\nreturn pvr2_hdw_get_tuner_status(hdw, vt);\r\n}\r\nstatic int pvr2_s_tuner(struct file *file, void *priv, const struct v4l2_tuner *vt)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nif (vt->index != 0)\r\nreturn -EINVAL;\r\nreturn pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_AUDIOMODE),\r\nvt->audmode);\r\n}\r\nstatic int pvr2_s_frequency(struct file *file, void *priv, const struct v4l2_frequency *vf)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nunsigned long fv;\r\nstruct v4l2_tuner vt;\r\nint cur_input;\r\nstruct pvr2_ctrl *ctrlp;\r\nint ret;\r\nret = pvr2_hdw_get_tuner_status(hdw, &vt);\r\nif (ret != 0)\r\nreturn ret;\r\nctrlp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT);\r\nret = pvr2_ctrl_get_value(ctrlp, &cur_input);\r\nif (ret != 0)\r\nreturn ret;\r\nif (vf->type == V4L2_TUNER_RADIO) {\r\nif (cur_input != PVR2_CVAL_INPUT_RADIO)\r\npvr2_ctrl_set_value(ctrlp, PVR2_CVAL_INPUT_RADIO);\r\n} else {\r\nif (cur_input == PVR2_CVAL_INPUT_RADIO)\r\npvr2_ctrl_set_value(ctrlp, PVR2_CVAL_INPUT_TV);\r\n}\r\nfv = vf->frequency;\r\nif (vt.capability & V4L2_TUNER_CAP_LOW)\r\nfv = (fv * 125) / 2;\r\nelse\r\nfv = fv * 62500;\r\nreturn pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,PVR2_CID_FREQUENCY),fv);\r\n}\r\nstatic int pvr2_g_frequency(struct file *file, void *priv, struct v4l2_frequency *vf)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint val = 0;\r\nint cur_input;\r\nstruct v4l2_tuner vt;\r\nint ret;\r\nret = pvr2_hdw_get_tuner_status(hdw, &vt);\r\nif (ret != 0)\r\nreturn ret;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_FREQUENCY),\r\n&val);\r\nif (ret != 0)\r\nreturn ret;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_INPUT),\r\n&cur_input);\r\nif (cur_input == PVR2_CVAL_INPUT_RADIO)\r\nvf->type = V4L2_TUNER_RADIO;\r\nelse\r\nvf->type = V4L2_TUNER_ANALOG_TV;\r\nif (vt.capability & V4L2_TUNER_CAP_LOW)\r\nval = (val * 2) / 125;\r\nelse\r\nval /= 62500;\r\nvf->frequency = val;\r\nreturn 0;\r\n}\r\nstatic int pvr2_enum_fmt_vid_cap(struct file *file, void *priv, struct v4l2_fmtdesc *fd)\r\n{\r\nif (fd->index != 0)\r\nreturn -EINVAL;\r\nmemcpy(fd, pvr_fmtdesc, sizeof(struct v4l2_fmtdesc));\r\nreturn 0;\r\n}\r\nstatic int pvr2_g_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *vf)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint val;\r\nmemcpy(vf, &pvr_format[PVR_FORMAT_PIX], sizeof(struct v4l2_format));\r\nval = 0;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_HRES),\r\n&val);\r\nvf->fmt.pix.width = val;\r\nval = 0;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_VRES),\r\n&val);\r\nvf->fmt.pix.height = val;\r\nreturn 0;\r\n}\r\nstatic int pvr2_try_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *vf)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint lmin, lmax, ldef;\r\nstruct pvr2_ctrl *hcp, *vcp;\r\nint h = vf->fmt.pix.height;\r\nint w = vf->fmt.pix.width;\r\nhcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_HRES);\r\nvcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_VRES);\r\nlmin = pvr2_ctrl_get_min(hcp);\r\nlmax = pvr2_ctrl_get_max(hcp);\r\npvr2_ctrl_get_def(hcp, &ldef);\r\nif (w == -1)\r\nw = ldef;\r\nelse if (w < lmin)\r\nw = lmin;\r\nelse if (w > lmax)\r\nw = lmax;\r\nlmin = pvr2_ctrl_get_min(vcp);\r\nlmax = pvr2_ctrl_get_max(vcp);\r\npvr2_ctrl_get_def(vcp, &ldef);\r\nif (h == -1)\r\nh = ldef;\r\nelse if (h < lmin)\r\nh = lmin;\r\nelse if (h > lmax)\r\nh = lmax;\r\nmemcpy(vf, &pvr_format[PVR_FORMAT_PIX],\r\nsizeof(struct v4l2_format));\r\nvf->fmt.pix.width = w;\r\nvf->fmt.pix.height = h;\r\nreturn 0;\r\n}\r\nstatic int pvr2_s_fmt_vid_cap(struct file *file, void *priv, struct v4l2_format *vf)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct pvr2_ctrl *hcp, *vcp;\r\nint ret = pvr2_try_fmt_vid_cap(file, fh, vf);\r\nif (ret)\r\nreturn ret;\r\nhcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_HRES);\r\nvcp = pvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_VRES);\r\npvr2_ctrl_set_value(hcp, vf->fmt.pix.width);\r\npvr2_ctrl_set_value(vcp, vf->fmt.pix.height);\r\nreturn 0;\r\n}\r\nstatic int pvr2_streamon(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct pvr2_v4l2_dev *pdi = fh->pdi;\r\nint ret;\r\nif (!fh->pdi->stream) {\r\nreturn -EPERM;\r\n}\r\nret = pvr2_hdw_set_stream_type(hdw, pdi->config);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn pvr2_hdw_set_streaming(hdw, !0);\r\n}\r\nstatic int pvr2_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nif (!fh->pdi->stream) {\r\nreturn -EPERM;\r\n}\r\nreturn pvr2_hdw_set_streaming(hdw, 0);\r\n}\r\nstatic int pvr2_queryctrl(struct file *file, void *priv,\r\nstruct v4l2_queryctrl *vc)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct pvr2_ctrl *cptr;\r\nint val;\r\nif (vc->id & V4L2_CTRL_FLAG_NEXT_CTRL) {\r\ncptr = pvr2_hdw_get_ctrl_nextv4l(\r\nhdw, (vc->id & ~V4L2_CTRL_FLAG_NEXT_CTRL));\r\nif (cptr)\r\nvc->id = pvr2_ctrl_get_v4lid(cptr);\r\n} else {\r\ncptr = pvr2_hdw_get_ctrl_v4l(hdw, vc->id);\r\n}\r\nif (!cptr) {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"QUERYCTRL id=0x%x not implemented here",\r\nvc->id);\r\nreturn -EINVAL;\r\n}\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"QUERYCTRL id=0x%x mapping name=%s (%s)",\r\nvc->id, pvr2_ctrl_get_name(cptr),\r\npvr2_ctrl_get_desc(cptr));\r\nstrlcpy(vc->name, pvr2_ctrl_get_desc(cptr), sizeof(vc->name));\r\nvc->flags = pvr2_ctrl_get_v4lflags(cptr);\r\npvr2_ctrl_get_def(cptr, &val);\r\nvc->default_value = val;\r\nswitch (pvr2_ctrl_get_type(cptr)) {\r\ncase pvr2_ctl_enum:\r\nvc->type = V4L2_CTRL_TYPE_MENU;\r\nvc->minimum = 0;\r\nvc->maximum = pvr2_ctrl_get_cnt(cptr) - 1;\r\nvc->step = 1;\r\nbreak;\r\ncase pvr2_ctl_bool:\r\nvc->type = V4L2_CTRL_TYPE_BOOLEAN;\r\nvc->minimum = 0;\r\nvc->maximum = 1;\r\nvc->step = 1;\r\nbreak;\r\ncase pvr2_ctl_int:\r\nvc->type = V4L2_CTRL_TYPE_INTEGER;\r\nvc->minimum = pvr2_ctrl_get_min(cptr);\r\nvc->maximum = pvr2_ctrl_get_max(cptr);\r\nvc->step = 1;\r\nbreak;\r\ndefault:\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"QUERYCTRL id=0x%x name=%s not mappable",\r\nvc->id, pvr2_ctrl_get_name(cptr));\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_querymenu(struct file *file, void *priv, struct v4l2_querymenu *vm)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nunsigned int cnt = 0;\r\nint ret;\r\nret = pvr2_ctrl_get_valname(pvr2_hdw_get_ctrl_v4l(hdw, vm->id),\r\nvm->index,\r\nvm->name, sizeof(vm->name) - 1,\r\n&cnt);\r\nvm->name[cnt] = 0;\r\nreturn ret;\r\n}\r\nstatic int pvr2_g_ctrl(struct file *file, void *priv, struct v4l2_control *vc)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint val = 0;\r\nint ret;\r\nret = pvr2_ctrl_get_value(pvr2_hdw_get_ctrl_v4l(hdw, vc->id),\r\n&val);\r\nvc->value = val;\r\nreturn ret;\r\n}\r\nstatic int pvr2_s_ctrl(struct file *file, void *priv, struct v4l2_control *vc)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nreturn pvr2_ctrl_set_value(pvr2_hdw_get_ctrl_v4l(hdw, vc->id),\r\nvc->value);\r\n}\r\nstatic int pvr2_g_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctls)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct v4l2_ext_control *ctrl;\r\nstruct pvr2_ctrl *cptr;\r\nunsigned int idx;\r\nint val;\r\nint ret;\r\nret = 0;\r\nfor (idx = 0; idx < ctls->count; idx++) {\r\nctrl = ctls->controls + idx;\r\ncptr = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);\r\nif (cptr) {\r\nif (ctls->which == V4L2_CTRL_WHICH_DEF_VAL)\r\npvr2_ctrl_get_def(cptr, &val);\r\nelse\r\nret = pvr2_ctrl_get_value(cptr, &val);\r\n} else\r\nret = -EINVAL;\r\nif (ret) {\r\nctls->error_idx = idx;\r\nreturn ret;\r\n}\r\nctrl->value64 = 0;\r\nctrl->value = val;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_s_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctls)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct v4l2_ext_control *ctrl;\r\nunsigned int idx;\r\nint ret;\r\nif (ctls->which == V4L2_CTRL_WHICH_DEF_VAL)\r\nreturn -EINVAL;\r\nret = 0;\r\nfor (idx = 0; idx < ctls->count; idx++) {\r\nctrl = ctls->controls + idx;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_v4l(hdw, ctrl->id),\r\nctrl->value);\r\nif (ret) {\r\nctls->error_idx = idx;\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_try_ext_ctrls(struct file *file, void *priv,\r\nstruct v4l2_ext_controls *ctls)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct v4l2_ext_control *ctrl;\r\nstruct pvr2_ctrl *pctl;\r\nunsigned int idx;\r\nfor (idx = 0; idx < ctls->count; idx++) {\r\nctrl = ctls->controls + idx;\r\npctl = pvr2_hdw_get_ctrl_v4l(hdw, ctrl->id);\r\nif (!pctl) {\r\nctls->error_idx = idx;\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_cropcap(struct file *file, void *priv, struct v4l2_cropcap *cap)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint ret;\r\nif (cap->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nret = pvr2_hdw_get_cropcap(hdw, cap);\r\ncap->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn ret;\r\n}\r\nstatic int pvr2_g_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nstruct v4l2_cropcap cap;\r\nint val = 0;\r\nint ret;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\ncap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nswitch (sel->target) {\r\ncase V4L2_SEL_TGT_CROP:\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPL), &val);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nsel->r.left = val;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPT), &val);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nsel->r.top = val;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPW), &val);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nsel->r.width = val;\r\nret = pvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPH), &val);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nsel->r.height = val;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\nret = pvr2_hdw_get_cropcap(hdw, &cap);\r\nsel->r = cap.defrect;\r\nbreak;\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\nret = pvr2_hdw_get_cropcap(hdw, &cap);\r\nsel->r = cap.bounds;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pvr2_s_selection(struct file *file, void *priv,\r\nstruct v4l2_selection *sel)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nint ret;\r\nif (sel->type != V4L2_BUF_TYPE_VIDEO_CAPTURE ||\r\nsel->target != V4L2_SEL_TGT_CROP)\r\nreturn -EINVAL;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPL),\r\nsel->r.left);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPT),\r\nsel->r.top);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPW),\r\nsel->r.width);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nret = pvr2_ctrl_set_value(\r\npvr2_hdw_get_ctrl_by_id(hdw, PVR2_CID_CROPH),\r\nsel->r.height);\r\nif (ret != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int pvr2_log_status(struct file *file, void *priv)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\npvr2_hdw_trigger_module_log(hdw);\r\nreturn 0;\r\n}\r\nstatic void pvr2_v4l2_dev_destroy(struct pvr2_v4l2_dev *dip)\r\n{\r\nstruct pvr2_hdw *hdw = dip->v4lp->channel.mc_head->hdw;\r\nenum pvr2_config cfg = dip->config;\r\nchar msg[80];\r\nunsigned int mcnt;\r\nmcnt = scnprintf(msg, sizeof(msg) - 1,\r\n"pvrusb2: unregistered device %s [%s]",\r\nvideo_device_node_name(&dip->devbase),\r\npvr2_config_get_name(cfg));\r\nmsg[mcnt] = 0;\r\npvr2_hdw_v4l_store_minor_number(hdw,dip->minor_type,-1);\r\ndip->v4lp = NULL;\r\ndip->stream = NULL;\r\nvideo_unregister_device(&dip->devbase);\r\nprintk(KERN_INFO "%s\n", msg);\r\n}\r\nstatic void pvr2_v4l2_dev_disassociate_parent(struct pvr2_v4l2_dev *dip)\r\n{\r\nif (!dip) return;\r\nif (!dip->devbase.v4l2_dev->dev) return;\r\ndip->devbase.v4l2_dev->dev = NULL;\r\ndevice_move(&dip->devbase.dev, NULL, DPM_ORDER_NONE);\r\n}\r\nstatic void pvr2_v4l2_destroy_no_lock(struct pvr2_v4l2 *vp)\r\n{\r\nif (vp->dev_video) {\r\npvr2_v4l2_dev_destroy(vp->dev_video);\r\nvp->dev_video = NULL;\r\n}\r\nif (vp->dev_radio) {\r\npvr2_v4l2_dev_destroy(vp->dev_radio);\r\nvp->dev_radio = NULL;\r\n}\r\npvr2_trace(PVR2_TRACE_STRUCT,"Destroying pvr2_v4l2 id=%p",vp);\r\npvr2_channel_done(&vp->channel);\r\nkfree(vp);\r\n}\r\nstatic void pvr2_video_device_release(struct video_device *vdev)\r\n{\r\nstruct pvr2_v4l2_dev *dev;\r\ndev = container_of(vdev,struct pvr2_v4l2_dev,devbase);\r\nkfree(dev);\r\n}\r\nstatic void pvr2_v4l2_internal_check(struct pvr2_channel *chp)\r\n{\r\nstruct pvr2_v4l2 *vp;\r\nvp = container_of(chp,struct pvr2_v4l2,channel);\r\nif (!vp->channel.mc_head->disconnect_flag) return;\r\npvr2_v4l2_dev_disassociate_parent(vp->dev_video);\r\npvr2_v4l2_dev_disassociate_parent(vp->dev_radio);\r\nif (!list_empty(&vp->dev_video->devbase.fh_list) ||\r\n!list_empty(&vp->dev_radio->devbase.fh_list))\r\nreturn;\r\npvr2_v4l2_destroy_no_lock(vp);\r\n}\r\nstatic long pvr2_v4l2_ioctl(struct file *file,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nlong ret = -EINVAL;\r\nif (pvrusb2_debug & PVR2_TRACE_V4LIOCTL)\r\nv4l_printk_ioctl(pvr2_hdw_get_driver_name(hdw), cmd);\r\nif (!pvr2_hdw_dev_ok(hdw)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"ioctl failed - bad or no context");\r\nreturn -EFAULT;\r\n}\r\nret = video_ioctl2(file, cmd, arg);\r\npvr2_hdw_commit_ctl(hdw);\r\nif (ret < 0) {\r\nif (pvrusb2_debug & PVR2_TRACE_V4LIOCTL) {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"pvr2_v4l2_do_ioctl failure, ret=%ld command was:",\r\nret);\r\nv4l_printk_ioctl(pvr2_hdw_get_driver_name(hdw), cmd);\r\n}\r\n} else {\r\npvr2_trace(PVR2_TRACE_V4LIOCTL,\r\n"pvr2_v4l2_do_ioctl complete, ret=%ld (0x%lx)",\r\nret, ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic int pvr2_v4l2_release(struct file *file)\r\n{\r\nstruct pvr2_v4l2_fh *fhp = file->private_data;\r\nstruct pvr2_v4l2 *vp = fhp->pdi->v4lp;\r\nstruct pvr2_hdw *hdw = fhp->channel.mc_head->hdw;\r\npvr2_trace(PVR2_TRACE_OPEN_CLOSE,"pvr2_v4l2_release");\r\nif (fhp->rhp) {\r\nstruct pvr2_stream *sp;\r\npvr2_hdw_set_streaming(hdw,0);\r\nsp = pvr2_ioread_get_stream(fhp->rhp);\r\nif (sp) pvr2_stream_set_callback(sp,NULL,NULL);\r\npvr2_ioread_destroy(fhp->rhp);\r\nfhp->rhp = NULL;\r\n}\r\nv4l2_fh_del(&fhp->fh);\r\nv4l2_fh_exit(&fhp->fh);\r\nfile->private_data = NULL;\r\npvr2_channel_done(&fhp->channel);\r\npvr2_trace(PVR2_TRACE_STRUCT,\r\n"Destroying pvr_v4l2_fh id=%p",fhp);\r\nif (fhp->input_map) {\r\nkfree(fhp->input_map);\r\nfhp->input_map = NULL;\r\n}\r\nkfree(fhp);\r\nif (vp->channel.mc_head->disconnect_flag &&\r\nlist_empty(&vp->dev_video->devbase.fh_list) &&\r\nlist_empty(&vp->dev_radio->devbase.fh_list)) {\r\npvr2_v4l2_destroy_no_lock(vp);\r\n}\r\nreturn 0;\r\n}\r\nstatic int pvr2_v4l2_open(struct file *file)\r\n{\r\nstruct pvr2_v4l2_dev *dip;\r\nstruct pvr2_v4l2_fh *fhp;\r\nstruct pvr2_v4l2 *vp;\r\nstruct pvr2_hdw *hdw;\r\nunsigned int input_mask = 0;\r\nunsigned int input_cnt,idx;\r\nint ret = 0;\r\ndip = container_of(video_devdata(file),struct pvr2_v4l2_dev,devbase);\r\nvp = dip->v4lp;\r\nhdw = vp->channel.hdw;\r\npvr2_trace(PVR2_TRACE_OPEN_CLOSE,"pvr2_v4l2_open");\r\nif (!pvr2_hdw_dev_ok(hdw)) {\r\npvr2_trace(PVR2_TRACE_OPEN_CLOSE,\r\n"pvr2_v4l2_open: hardware not ready");\r\nreturn -EIO;\r\n}\r\nfhp = kzalloc(sizeof(*fhp),GFP_KERNEL);\r\nif (!fhp) {\r\nreturn -ENOMEM;\r\n}\r\nv4l2_fh_init(&fhp->fh, &dip->devbase);\r\ninit_waitqueue_head(&fhp->wait_data);\r\nfhp->pdi = dip;\r\npvr2_trace(PVR2_TRACE_STRUCT,"Creating pvr_v4l2_fh id=%p",fhp);\r\npvr2_channel_init(&fhp->channel,vp->channel.mc_head);\r\nif (dip->v4l_type == VFL_TYPE_RADIO) {\r\ninput_mask = (1 << PVR2_CVAL_INPUT_RADIO);\r\n} else {\r\ninput_mask = ((1 << PVR2_CVAL_INPUT_RADIO) |\r\n(1 << PVR2_CVAL_INPUT_TV) |\r\n(1 << PVR2_CVAL_INPUT_COMPOSITE) |\r\n(1 << PVR2_CVAL_INPUT_SVIDEO));\r\n}\r\nret = pvr2_channel_limit_inputs(&fhp->channel,input_mask);\r\nif (ret) {\r\npvr2_channel_done(&fhp->channel);\r\npvr2_trace(PVR2_TRACE_STRUCT,\r\n"Destroying pvr_v4l2_fh id=%p (input mask error)",\r\nfhp);\r\nv4l2_fh_exit(&fhp->fh);\r\nkfree(fhp);\r\nreturn ret;\r\n}\r\ninput_mask &= pvr2_hdw_get_input_available(hdw);\r\ninput_cnt = 0;\r\nfor (idx = 0; idx < (sizeof(input_mask) << 3); idx++) {\r\nif (input_mask & (1 << idx)) input_cnt++;\r\n}\r\nfhp->input_cnt = input_cnt;\r\nfhp->input_map = kzalloc(input_cnt,GFP_KERNEL);\r\nif (!fhp->input_map) {\r\npvr2_channel_done(&fhp->channel);\r\npvr2_trace(PVR2_TRACE_STRUCT,\r\n"Destroying pvr_v4l2_fh id=%p (input map failure)",\r\nfhp);\r\nv4l2_fh_exit(&fhp->fh);\r\nkfree(fhp);\r\nreturn -ENOMEM;\r\n}\r\ninput_cnt = 0;\r\nfor (idx = 0; idx < (sizeof(input_mask) << 3); idx++) {\r\nif (!(input_mask & (1 << idx))) continue;\r\nfhp->input_map[input_cnt++] = idx;\r\n}\r\nfhp->file = file;\r\nfile->private_data = fhp;\r\nfhp->fw_mode_flag = pvr2_hdw_cpufw_get_enabled(hdw);\r\nv4l2_fh_add(&fhp->fh);\r\nreturn 0;\r\n}\r\nstatic void pvr2_v4l2_notify(struct pvr2_v4l2_fh *fhp)\r\n{\r\nwake_up(&fhp->wait_data);\r\n}\r\nstatic int pvr2_v4l2_iosetup(struct pvr2_v4l2_fh *fh)\r\n{\r\nint ret;\r\nstruct pvr2_stream *sp;\r\nstruct pvr2_hdw *hdw;\r\nif (fh->rhp) return 0;\r\nif (!fh->pdi->stream) {\r\nreturn -EPERM;\r\n}\r\nif ((ret = pvr2_channel_claim_stream(&fh->channel,\r\nfh->pdi->stream)) != 0) {\r\nreturn ret;\r\n}\r\nfh->rhp = pvr2_channel_create_mpeg_stream(fh->pdi->stream);\r\nif (!fh->rhp) {\r\npvr2_channel_claim_stream(&fh->channel,NULL);\r\nreturn -ENOMEM;\r\n}\r\nhdw = fh->channel.mc_head->hdw;\r\nsp = fh->pdi->stream->stream;\r\npvr2_stream_set_callback(sp,(pvr2_stream_callback)pvr2_v4l2_notify,fh);\r\npvr2_hdw_set_stream_type(hdw,fh->pdi->config);\r\nif ((ret = pvr2_hdw_set_streaming(hdw,!0)) < 0) return ret;\r\nreturn pvr2_ioread_set_enabled(fh->rhp,!0);\r\n}\r\nstatic ssize_t pvr2_v4l2_read(struct file *file,\r\nchar __user *buff, size_t count, loff_t *ppos)\r\n{\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nint ret;\r\nif (fh->fw_mode_flag) {\r\nstruct pvr2_hdw *hdw = fh->channel.mc_head->hdw;\r\nchar *tbuf;\r\nint c1,c2;\r\nint tcnt = 0;\r\nunsigned int offs = *ppos;\r\ntbuf = kmalloc(PAGE_SIZE,GFP_KERNEL);\r\nif (!tbuf) return -ENOMEM;\r\nwhile (count) {\r\nc1 = count;\r\nif (c1 > PAGE_SIZE) c1 = PAGE_SIZE;\r\nc2 = pvr2_hdw_cpufw_get(hdw,offs,tbuf,c1);\r\nif (c2 < 0) {\r\ntcnt = c2;\r\nbreak;\r\n}\r\nif (!c2) break;\r\nif (copy_to_user(buff,tbuf,c2)) {\r\ntcnt = -EFAULT;\r\nbreak;\r\n}\r\noffs += c2;\r\ntcnt += c2;\r\nbuff += c2;\r\ncount -= c2;\r\n*ppos += c2;\r\n}\r\nkfree(tbuf);\r\nreturn tcnt;\r\n}\r\nif (!fh->rhp) {\r\nret = pvr2_v4l2_iosetup(fh);\r\nif (ret) {\r\nreturn ret;\r\n}\r\n}\r\nfor (;;) {\r\nret = pvr2_ioread_read(fh->rhp,buff,count);\r\nif (ret >= 0) break;\r\nif (ret != -EAGAIN) break;\r\nif (file->f_flags & O_NONBLOCK) break;\r\nret = wait_event_interruptible(\r\nfh->wait_data,\r\npvr2_ioread_avail(fh->rhp) >= 0);\r\nif (ret < 0) break;\r\n}\r\nreturn ret;\r\n}\r\nstatic unsigned int pvr2_v4l2_poll(struct file *file, poll_table *wait)\r\n{\r\nunsigned int mask = 0;\r\nstruct pvr2_v4l2_fh *fh = file->private_data;\r\nint ret;\r\nif (fh->fw_mode_flag) {\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nif (!fh->rhp) {\r\nret = pvr2_v4l2_iosetup(fh);\r\nif (ret) return POLLERR;\r\n}\r\npoll_wait(file,&fh->wait_data,wait);\r\nif (pvr2_ioread_avail(fh->rhp) >= 0) {\r\nmask |= POLLIN | POLLRDNORM;\r\n}\r\nreturn mask;\r\n}\r\nstatic void pvr2_v4l2_dev_init(struct pvr2_v4l2_dev *dip,\r\nstruct pvr2_v4l2 *vp,\r\nint v4l_type)\r\n{\r\nint mindevnum;\r\nint unit_number;\r\nstruct pvr2_hdw *hdw;\r\nint *nr_ptr = NULL;\r\ndip->v4lp = vp;\r\nhdw = vp->channel.mc_head->hdw;\r\ndip->v4l_type = v4l_type;\r\nswitch (v4l_type) {\r\ncase VFL_TYPE_GRABBER:\r\ndip->stream = &vp->channel.mc_head->video_stream;\r\ndip->config = pvr2_config_mpeg;\r\ndip->minor_type = pvr2_v4l_type_video;\r\nnr_ptr = video_nr;\r\nif (!dip->stream) {\r\npr_err(KBUILD_MODNAME\r\n": Failed to set up pvrusb2 v4l video dev due to missing stream instance\n");\r\nreturn;\r\n}\r\nbreak;\r\ncase VFL_TYPE_VBI:\r\ndip->config = pvr2_config_vbi;\r\ndip->minor_type = pvr2_v4l_type_vbi;\r\nnr_ptr = vbi_nr;\r\nbreak;\r\ncase VFL_TYPE_RADIO:\r\ndip->stream = &vp->channel.mc_head->video_stream;\r\ndip->config = pvr2_config_mpeg;\r\ndip->minor_type = pvr2_v4l_type_radio;\r\nnr_ptr = radio_nr;\r\nbreak;\r\ndefault:\r\npr_err(KBUILD_MODNAME ": Failed to set up pvrusb2 v4l dev due to unrecognized config\n");\r\nreturn;\r\n}\r\ndip->devbase = vdev_template;\r\ndip->devbase.release = pvr2_video_device_release;\r\ndip->devbase.ioctl_ops = &pvr2_ioctl_ops;\r\n{\r\nint val;\r\npvr2_ctrl_get_value(\r\npvr2_hdw_get_ctrl_by_id(hdw,\r\nPVR2_CID_STDAVAIL), &val);\r\ndip->devbase.tvnorms = (v4l2_std_id)val;\r\n}\r\nmindevnum = -1;\r\nunit_number = pvr2_hdw_get_unit_number(hdw);\r\nif (nr_ptr && (unit_number >= 0) && (unit_number < PVR_NUM)) {\r\nmindevnum = nr_ptr[unit_number];\r\n}\r\npvr2_hdw_set_v4l2_dev(hdw, &dip->devbase);\r\nif ((video_register_device(&dip->devbase,\r\ndip->v4l_type, mindevnum) < 0) &&\r\n(video_register_device(&dip->devbase,\r\ndip->v4l_type, -1) < 0)) {\r\npr_err(KBUILD_MODNAME\r\n": Failed to register pvrusb2 v4l device\n");\r\n}\r\nprintk(KERN_INFO "pvrusb2: registered device %s [%s]\n",\r\nvideo_device_node_name(&dip->devbase),\r\npvr2_config_get_name(dip->config));\r\npvr2_hdw_v4l_store_minor_number(hdw,\r\ndip->minor_type,dip->devbase.minor);\r\n}\r\nstruct pvr2_v4l2 *pvr2_v4l2_create(struct pvr2_context *mnp)\r\n{\r\nstruct pvr2_v4l2 *vp;\r\nvp = kzalloc(sizeof(*vp),GFP_KERNEL);\r\nif (!vp) return vp;\r\npvr2_channel_init(&vp->channel,mnp);\r\npvr2_trace(PVR2_TRACE_STRUCT,"Creating pvr2_v4l2 id=%p",vp);\r\nvp->channel.check_func = pvr2_v4l2_internal_check;\r\nvp->dev_video = kzalloc(sizeof(*vp->dev_video),GFP_KERNEL);\r\nif (!vp->dev_video) goto fail;\r\npvr2_v4l2_dev_init(vp->dev_video,vp,VFL_TYPE_GRABBER);\r\nif (pvr2_hdw_get_input_available(vp->channel.mc_head->hdw) &\r\n(1 << PVR2_CVAL_INPUT_RADIO)) {\r\nvp->dev_radio = kzalloc(sizeof(*vp->dev_radio),GFP_KERNEL);\r\nif (!vp->dev_radio) goto fail;\r\npvr2_v4l2_dev_init(vp->dev_radio,vp,VFL_TYPE_RADIO);\r\n}\r\nreturn vp;\r\nfail:\r\npvr2_trace(PVR2_TRACE_STRUCT,"Failure creating pvr2_v4l2 id=%p",vp);\r\npvr2_v4l2_destroy_no_lock(vp);\r\nreturn NULL;\r\n}
