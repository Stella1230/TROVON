static inline v4l2_std_id vivid_get_std_cap(const struct vivid_dev *dev)\r\n{\r\nif (vivid_is_sdtv_cap(dev))\r\nreturn dev->std_cap;\r\nreturn 0;\r\n}\r\nstatic void copy_pix(struct vivid_dev *dev, int win_y, int win_x,\r\nu16 *cap, const u16 *osd)\r\n{\r\nu16 out;\r\nint left = dev->overlay_out_left;\r\nint top = dev->overlay_out_top;\r\nint fb_x = win_x + left;\r\nint fb_y = win_y + top;\r\nint i;\r\nout = *cap;\r\n*cap = *osd;\r\nif (dev->bitmap_out) {\r\nconst u8 *p = dev->bitmap_out;\r\nunsigned stride = (dev->compose_out.width + 7) / 8;\r\nwin_x -= dev->compose_out.left;\r\nwin_y -= dev->compose_out.top;\r\nif (!(p[stride * win_y + win_x / 8] & (1 << (win_x & 7))))\r\nreturn;\r\n}\r\nfor (i = 0; i < dev->clipcount_out; i++) {\r\nstruct v4l2_rect *r = &dev->clips_out[i].c;\r\nif (fb_y >= r->top && fb_y < r->top + r->height &&\r\nfb_x >= r->left && fb_x < r->left + r->width)\r\nreturn;\r\n}\r\nif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_CHROMAKEY) &&\r\n*osd != dev->chromakey_out)\r\nreturn;\r\nif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_SRC_CHROMAKEY) &&\r\nout == dev->chromakey_out)\r\nreturn;\r\nif (dev->fmt_cap->alpha_mask) {\r\nif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_GLOBAL_ALPHA) &&\r\ndev->global_alpha_out)\r\nreturn;\r\nif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_LOCAL_ALPHA) &&\r\n*cap & dev->fmt_cap->alpha_mask)\r\nreturn;\r\nif ((dev->fbuf_out_flags & V4L2_FBUF_FLAG_LOCAL_INV_ALPHA) &&\r\n!(*cap & dev->fmt_cap->alpha_mask))\r\nreturn;\r\n}\r\n*cap = out;\r\n}\r\nstatic void blend_line(struct vivid_dev *dev, unsigned y_offset, unsigned x_offset,\r\nu8 *vcapbuf, const u8 *vosdbuf,\r\nunsigned width, unsigned pixsize)\r\n{\r\nunsigned x;\r\nfor (x = 0; x < width; x++, vcapbuf += pixsize, vosdbuf += pixsize) {\r\ncopy_pix(dev, y_offset, x_offset + x,\r\n(u16 *)vcapbuf, (const u16 *)vosdbuf);\r\n}\r\n}\r\nstatic void scale_line(const u8 *src, u8 *dst, unsigned srcw, unsigned dstw, unsigned twopixsize)\r\n{\r\nunsigned int_part;\r\nunsigned fract_part;\r\nunsigned src_x = 0;\r\nunsigned error = 0;\r\nunsigned x;\r\nsrcw /= 2;\r\ndstw /= 2;\r\nint_part = srcw / dstw;\r\nfract_part = srcw % dstw;\r\nfor (x = 0; x < dstw; x++, dst += twopixsize) {\r\nmemcpy(dst, src + src_x * twopixsize, twopixsize);\r\nsrc_x += int_part;\r\nerror += fract_part;\r\nif (error >= dstw) {\r\nerror -= dstw;\r\nsrc_x++;\r\n}\r\n}\r\n}\r\nstatic void vivid_precalc_copy_rects(struct vivid_dev *dev)\r\n{\r\nstruct v4l2_rect r_fb = {\r\n0, 0, dev->display_width, dev->display_height\r\n};\r\nstruct v4l2_rect r_overlay = {\r\ndev->overlay_out_left, dev->overlay_out_top,\r\ndev->compose_out.width, dev->compose_out.height\r\n};\r\nv4l2_rect_intersect(&dev->loop_vid_copy, &dev->crop_cap, &dev->compose_out);\r\ndev->loop_vid_out = dev->loop_vid_copy;\r\nv4l2_rect_scale(&dev->loop_vid_out, &dev->compose_out, &dev->crop_out);\r\ndev->loop_vid_out.left += dev->crop_out.left;\r\ndev->loop_vid_out.top += dev->crop_out.top;\r\ndev->loop_vid_cap = dev->loop_vid_copy;\r\nv4l2_rect_scale(&dev->loop_vid_cap, &dev->crop_cap, &dev->compose_cap);\r\ndprintk(dev, 1,\r\n"loop_vid_copy: %dx%d@%dx%d loop_vid_out: %dx%d@%dx%d loop_vid_cap: %dx%d@%dx%d\n",\r\ndev->loop_vid_copy.width, dev->loop_vid_copy.height,\r\ndev->loop_vid_copy.left, dev->loop_vid_copy.top,\r\ndev->loop_vid_out.width, dev->loop_vid_out.height,\r\ndev->loop_vid_out.left, dev->loop_vid_out.top,\r\ndev->loop_vid_cap.width, dev->loop_vid_cap.height,\r\ndev->loop_vid_cap.left, dev->loop_vid_cap.top);\r\nv4l2_rect_intersect(&r_overlay, &r_fb, &r_overlay);\r\nr_overlay.left += dev->compose_out.left - dev->overlay_out_left;\r\nr_overlay.top += dev->compose_out.top - dev->overlay_out_top;\r\nv4l2_rect_intersect(&dev->loop_vid_overlay, &r_overlay, &dev->loop_vid_copy);\r\ndev->loop_fb_copy = dev->loop_vid_overlay;\r\ndev->loop_fb_copy.left -= dev->compose_out.left - dev->overlay_out_left;\r\ndev->loop_fb_copy.top -= dev->compose_out.top - dev->overlay_out_top;\r\ndev->loop_vid_overlay_cap = dev->loop_vid_overlay;\r\nv4l2_rect_scale(&dev->loop_vid_overlay_cap, &dev->crop_cap, &dev->compose_cap);\r\ndprintk(dev, 1,\r\n"loop_fb_copy: %dx%d@%dx%d loop_vid_overlay: %dx%d@%dx%d loop_vid_overlay_cap: %dx%d@%dx%d\n",\r\ndev->loop_fb_copy.width, dev->loop_fb_copy.height,\r\ndev->loop_fb_copy.left, dev->loop_fb_copy.top,\r\ndev->loop_vid_overlay.width, dev->loop_vid_overlay.height,\r\ndev->loop_vid_overlay.left, dev->loop_vid_overlay.top,\r\ndev->loop_vid_overlay_cap.width, dev->loop_vid_overlay_cap.height,\r\ndev->loop_vid_overlay_cap.left, dev->loop_vid_overlay_cap.top);\r\n}\r\nstatic void *plane_vaddr(struct tpg_data *tpg, struct vivid_buffer *buf,\r\nunsigned p, unsigned bpl[TPG_MAX_PLANES], unsigned h)\r\n{\r\nunsigned i;\r\nvoid *vbuf;\r\nif (p == 0 || tpg_g_buffers(tpg) > 1)\r\nreturn vb2_plane_vaddr(&buf->vb.vb2_buf, p);\r\nvbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nfor (i = 0; i < p; i++)\r\nvbuf += bpl[i] * h / tpg->vdownsampling[i];\r\nreturn vbuf;\r\n}\r\nstatic int vivid_copy_buffer(struct vivid_dev *dev, unsigned p, u8 *vcapbuf,\r\nstruct vivid_buffer *vid_cap_buf)\r\n{\r\nbool blank = dev->must_blank[vid_cap_buf->vb.vb2_buf.index];\r\nstruct tpg_data *tpg = &dev->tpg;\r\nstruct vivid_buffer *vid_out_buf = NULL;\r\nunsigned vdiv = dev->fmt_out->vdownsampling[p];\r\nunsigned twopixsize = tpg_g_twopixelsize(tpg, p);\r\nunsigned img_width = tpg_hdiv(tpg, p, dev->compose_cap.width);\r\nunsigned img_height = dev->compose_cap.height;\r\nunsigned stride_cap = tpg->bytesperline[p];\r\nunsigned stride_out = dev->bytesperline_out[p];\r\nunsigned stride_osd = dev->display_byte_stride;\r\nunsigned hmax = (img_height * tpg->perc_fill) / 100;\r\nu8 *voutbuf;\r\nu8 *vosdbuf = NULL;\r\nunsigned y;\r\nbool blend = dev->bitmap_out || dev->clipcount_out || dev->fbuf_out_flags;\r\nunsigned vid_out_int_part;\r\nunsigned vid_out_fract_part;\r\nunsigned vid_out_y = 0;\r\nunsigned vid_out_error = 0;\r\nunsigned vid_overlay_int_part = 0;\r\nunsigned vid_overlay_fract_part = 0;\r\nunsigned vid_overlay_y = 0;\r\nunsigned vid_overlay_error = 0;\r\nunsigned vid_cap_left = tpg_hdiv(tpg, p, dev->loop_vid_cap.left);\r\nunsigned vid_cap_right;\r\nbool quick;\r\nvid_out_int_part = dev->loop_vid_out.height / dev->loop_vid_cap.height;\r\nvid_out_fract_part = dev->loop_vid_out.height % dev->loop_vid_cap.height;\r\nif (!list_empty(&dev->vid_out_active))\r\nvid_out_buf = list_entry(dev->vid_out_active.next,\r\nstruct vivid_buffer, list);\r\nif (vid_out_buf == NULL)\r\nreturn -ENODATA;\r\nvid_cap_buf->vb.field = vid_out_buf->vb.field;\r\nvoutbuf = plane_vaddr(tpg, vid_out_buf, p,\r\ndev->bytesperline_out, dev->fmt_out_rect.height);\r\nif (p < dev->fmt_out->buffers)\r\nvoutbuf += vid_out_buf->vb.vb2_buf.planes[p].data_offset;\r\nvoutbuf += tpg_hdiv(tpg, p, dev->loop_vid_out.left) +\r\n(dev->loop_vid_out.top / vdiv) * stride_out;\r\nvcapbuf += tpg_hdiv(tpg, p, dev->compose_cap.left) +\r\n(dev->compose_cap.top / vdiv) * stride_cap;\r\nif (dev->loop_vid_copy.width == 0 || dev->loop_vid_copy.height == 0) {\r\nfor (y = 0; y < hmax / vdiv; y++, vcapbuf += stride_cap)\r\nmemcpy(vcapbuf, tpg->black_line[p], img_width);\r\nreturn 0;\r\n}\r\nif (dev->overlay_out_enabled &&\r\ndev->loop_vid_overlay.width && dev->loop_vid_overlay.height) {\r\nvosdbuf = dev->video_vbase;\r\nvosdbuf += (dev->loop_fb_copy.left * twopixsize) / 2 +\r\ndev->loop_fb_copy.top * stride_osd;\r\nvid_overlay_int_part = dev->loop_vid_overlay.height /\r\ndev->loop_vid_overlay_cap.height;\r\nvid_overlay_fract_part = dev->loop_vid_overlay.height %\r\ndev->loop_vid_overlay_cap.height;\r\n}\r\nvid_cap_right = tpg_hdiv(tpg, p, dev->loop_vid_cap.left + dev->loop_vid_cap.width);\r\nquick = dev->loop_vid_out.width == dev->loop_vid_cap.width;\r\ndev->cur_scaled_line = dev->loop_vid_out.height;\r\nfor (y = 0; y < hmax; y += vdiv, vcapbuf += stride_cap) {\r\nbool osdline = vosdbuf && y >= dev->loop_vid_overlay_cap.top &&\r\ny < dev->loop_vid_overlay_cap.top + dev->loop_vid_overlay_cap.height;\r\nif (y < dev->loop_vid_cap.top ||\r\ny >= dev->loop_vid_cap.top + dev->loop_vid_cap.height) {\r\nmemcpy(vcapbuf, tpg->black_line[p], img_width);\r\ncontinue;\r\n}\r\nif (dev->loop_vid_cap.left)\r\nmemcpy(vcapbuf, tpg->black_line[p], vid_cap_left);\r\nif (vid_cap_right < img_width)\r\nmemcpy(vcapbuf + vid_cap_right, tpg->black_line[p],\r\nimg_width - vid_cap_right);\r\nif (quick && !osdline) {\r\nmemcpy(vcapbuf + vid_cap_left,\r\nvoutbuf + vid_out_y * stride_out,\r\ntpg_hdiv(tpg, p, dev->loop_vid_cap.width));\r\ngoto update_vid_out_y;\r\n}\r\nif (dev->cur_scaled_line == vid_out_y) {\r\nmemcpy(vcapbuf + vid_cap_left, dev->scaled_line,\r\ntpg_hdiv(tpg, p, dev->loop_vid_cap.width));\r\ngoto update_vid_out_y;\r\n}\r\nif (!osdline) {\r\nscale_line(voutbuf + vid_out_y * stride_out, dev->scaled_line,\r\ntpg_hdiv(tpg, p, dev->loop_vid_out.width),\r\ntpg_hdiv(tpg, p, dev->loop_vid_cap.width),\r\ntpg_g_twopixelsize(tpg, p));\r\n} else {\r\nunsigned offset =\r\n((dev->loop_vid_overlay.left - dev->loop_vid_copy.left) *\r\ntwopixsize) / 2;\r\nu8 *osd = vosdbuf + vid_overlay_y * stride_osd;\r\nscale_line(voutbuf + vid_out_y * stride_out, dev->blended_line,\r\ndev->loop_vid_out.width, dev->loop_vid_copy.width,\r\ntpg_g_twopixelsize(tpg, p));\r\nif (blend)\r\nblend_line(dev, vid_overlay_y + dev->loop_vid_overlay.top,\r\ndev->loop_vid_overlay.left,\r\ndev->blended_line + offset, osd,\r\ndev->loop_vid_overlay.width, twopixsize / 2);\r\nelse\r\nmemcpy(dev->blended_line + offset,\r\nosd, (dev->loop_vid_overlay.width * twopixsize) / 2);\r\nscale_line(dev->blended_line, dev->scaled_line,\r\ndev->loop_vid_copy.width, dev->loop_vid_cap.width,\r\ntpg_g_twopixelsize(tpg, p));\r\n}\r\ndev->cur_scaled_line = vid_out_y;\r\nmemcpy(vcapbuf + vid_cap_left, dev->scaled_line,\r\ntpg_hdiv(tpg, p, dev->loop_vid_cap.width));\r\nupdate_vid_out_y:\r\nif (osdline) {\r\nvid_overlay_y += vid_overlay_int_part;\r\nvid_overlay_error += vid_overlay_fract_part;\r\nif (vid_overlay_error >= dev->loop_vid_overlay_cap.height) {\r\nvid_overlay_error -= dev->loop_vid_overlay_cap.height;\r\nvid_overlay_y++;\r\n}\r\n}\r\nvid_out_y += vid_out_int_part;\r\nvid_out_error += vid_out_fract_part;\r\nif (vid_out_error >= dev->loop_vid_cap.height / vdiv) {\r\nvid_out_error -= dev->loop_vid_cap.height / vdiv;\r\nvid_out_y++;\r\n}\r\n}\r\nif (!blank)\r\nreturn 0;\r\nfor (; y < img_height; y += vdiv, vcapbuf += stride_cap)\r\nmemcpy(vcapbuf, tpg->contrast_line[p], img_width);\r\nreturn 0;\r\n}\r\nstatic void vivid_fillbuff(struct vivid_dev *dev, struct vivid_buffer *buf)\r\n{\r\nstruct tpg_data *tpg = &dev->tpg;\r\nunsigned factor = V4L2_FIELD_HAS_T_OR_B(dev->field_cap) ? 2 : 1;\r\nunsigned line_height = 16 / factor;\r\nbool is_tv = vivid_is_sdtv_cap(dev);\r\nbool is_60hz = is_tv && (dev->std_cap & V4L2_STD_525_60);\r\nunsigned p;\r\nint line = 1;\r\nu8 *basep[TPG_MAX_PLANES][2];\r\nunsigned ms;\r\nchar str[100];\r\ns32 gain;\r\nbool is_loop = false;\r\nif (dev->loop_video && dev->can_loop_video &&\r\n((vivid_is_svid_cap(dev) &&\r\n!VIVID_INVALID_SIGNAL(dev->std_signal_mode)) ||\r\n(vivid_is_hdmi_cap(dev) &&\r\n!VIVID_INVALID_SIGNAL(dev->dv_timings_signal_mode))))\r\nis_loop = true;\r\nbuf->vb.sequence = dev->vid_cap_seq_count;\r\nif (dev->tstamp_src_is_soe)\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nif (dev->field_cap == V4L2_FIELD_ALTERNATE) {\r\nbuf->vb.field = ((dev->vid_cap_seq_count & 1) ^ is_60hz) ?\r\nV4L2_FIELD_BOTTOM : V4L2_FIELD_TOP;\r\nbuf->vb.sequence /= 2;\r\n} else {\r\nbuf->vb.field = dev->field_cap;\r\n}\r\ntpg_s_field(tpg, buf->vb.field,\r\ndev->field_cap == V4L2_FIELD_ALTERNATE);\r\ntpg_s_perc_fill_blank(tpg, dev->must_blank[buf->vb.vb2_buf.index]);\r\nvivid_precalc_copy_rects(dev);\r\nfor (p = 0; p < tpg_g_planes(tpg); p++) {\r\nvoid *vbuf = plane_vaddr(tpg, buf, p,\r\ntpg->bytesperline, tpg->buf_height);\r\nif (p < tpg_g_buffers(tpg) && dev->fmt_cap->data_offset[p]) {\r\nmemset(vbuf, dev->fmt_cap->data_offset[p] & 0xff,\r\ndev->fmt_cap->data_offset[p]);\r\nvbuf += dev->fmt_cap->data_offset[p];\r\n}\r\ntpg_calc_text_basep(tpg, basep, p, vbuf);\r\nif (!is_loop || vivid_copy_buffer(dev, p, vbuf, buf))\r\ntpg_fill_plane_buffer(tpg, vivid_get_std_cap(dev),\r\np, vbuf);\r\n}\r\ndev->must_blank[buf->vb.vb2_buf.index] = false;\r\nif (dev->field_cap != V4L2_FIELD_ALTERNATE ||\r\n(buf->vb.sequence & 1) == 0)\r\ndev->ms_vid_cap =\r\njiffies_to_msecs(jiffies - dev->jiffies_vid_cap);\r\nms = dev->ms_vid_cap;\r\nif (dev->osd_mode <= 1) {\r\nsnprintf(str, sizeof(str), " %02d:%02d:%02d:%03d %u%s",\r\n(ms / (60 * 60 * 1000)) % 24,\r\n(ms / (60 * 1000)) % 60,\r\n(ms / 1000) % 60,\r\nms % 1000,\r\nbuf->vb.sequence,\r\n(dev->field_cap == V4L2_FIELD_ALTERNATE) ?\r\n(buf->vb.field == V4L2_FIELD_TOP ?\r\n" top" : " bottom") : "");\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\n}\r\nif (dev->osd_mode == 0) {\r\nsnprintf(str, sizeof(str), " %dx%d, input %d ",\r\ndev->src_rect.width, dev->src_rect.height, dev->input);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\ngain = v4l2_ctrl_g_ctrl(dev->gain);\r\nmutex_lock(dev->ctrl_hdl_user_vid.lock);\r\nsnprintf(str, sizeof(str),\r\n" brightness %3d, contrast %3d, saturation %3d, hue %d ",\r\ndev->brightness->cur.val,\r\ndev->contrast->cur.val,\r\ndev->saturation->cur.val,\r\ndev->hue->cur.val);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\nsnprintf(str, sizeof(str),\r\n" autogain %d, gain %3d, alpha 0x%02x ",\r\ndev->autogain->cur.val, gain, dev->alpha->cur.val);\r\nmutex_unlock(dev->ctrl_hdl_user_vid.lock);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\nmutex_lock(dev->ctrl_hdl_user_aud.lock);\r\nsnprintf(str, sizeof(str),\r\n" volume %3d, mute %d ",\r\ndev->volume->cur.val, dev->mute->cur.val);\r\nmutex_unlock(dev->ctrl_hdl_user_aud.lock);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\nmutex_lock(dev->ctrl_hdl_user_gen.lock);\r\nsnprintf(str, sizeof(str), " int32 %d, int64 %lld, bitmask %08x ",\r\ndev->int32->cur.val,\r\n*dev->int64->p_cur.p_s64,\r\ndev->bitmask->cur.val);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\nsnprintf(str, sizeof(str), " boolean %d, menu %s, string \"%s\" ",\r\ndev->boolean->cur.val,\r\ndev->menu->qmenu[dev->menu->cur.val],\r\ndev->string->p_cur.p_char);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\nsnprintf(str, sizeof(str), " integer_menu %lld, value %d ",\r\ndev->int_menu->qmenu_int[dev->int_menu->cur.val],\r\ndev->int_menu->cur.val);\r\nmutex_unlock(dev->ctrl_hdl_user_gen.lock);\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\nif (dev->button_pressed) {\r\ndev->button_pressed--;\r\nsnprintf(str, sizeof(str), " button pressed!");\r\ntpg_gen_text(tpg, basep, line++ * line_height, 16, str);\r\n}\r\nif (dev->osd[0]) {\r\nif (vivid_is_hdmi_cap(dev)) {\r\nsnprintf(str, sizeof(str),\r\n" OSD \"%s\"", dev->osd);\r\ntpg_gen_text(tpg, basep, line++ * line_height,\r\n16, str);\r\n}\r\nif (dev->osd_jiffies &&\r\ntime_is_before_jiffies(dev->osd_jiffies + 5 * HZ)) {\r\ndev->osd[0] = 0;\r\ndev->osd_jiffies = 0;\r\n}\r\n}\r\n}\r\nif (!dev->tstamp_src_is_soe)\r\nbuf->vb.vb2_buf.timestamp = ktime_get_ns();\r\nbuf->vb.vb2_buf.timestamp += dev->time_wrap_offset;\r\n}\r\nstatic bool valid_pix(struct vivid_dev *dev, int win_y, int win_x, int fb_y, int fb_x)\r\n{\r\nint i;\r\nif (dev->bitmap_cap) {\r\nconst u8 *p = dev->bitmap_cap;\r\nunsigned stride = (dev->compose_cap.width + 7) / 8;\r\nif (!(p[stride * win_y + win_x / 8] & (1 << (win_x & 7))))\r\nreturn false;\r\n}\r\nfor (i = 0; i < dev->clipcount_cap; i++) {\r\nstruct v4l2_rect *r = &dev->clips_cap[i].c;\r\nif (fb_y >= r->top && fb_y < r->top + r->height &&\r\nfb_x >= r->left && fb_x < r->left + r->width)\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void vivid_overlay(struct vivid_dev *dev, struct vivid_buffer *buf)\r\n{\r\nstruct tpg_data *tpg = &dev->tpg;\r\nunsigned pixsize = tpg_g_twopixelsize(tpg, 0) / 2;\r\nvoid *vbase = dev->fb_vbase_cap;\r\nvoid *vbuf = vb2_plane_vaddr(&buf->vb.vb2_buf, 0);\r\nunsigned img_width = dev->compose_cap.width;\r\nunsigned img_height = dev->compose_cap.height;\r\nunsigned stride = tpg->bytesperline[0];\r\nbool quick = dev->bitmap_cap == NULL && dev->clipcount_cap == 0;\r\nint x, y, w, out_x = 0;\r\nif (WARN_ON(pixsize == 0))\r\nreturn;\r\nif ((dev->overlay_cap_field == V4L2_FIELD_TOP ||\r\ndev->overlay_cap_field == V4L2_FIELD_BOTTOM) &&\r\ndev->overlay_cap_field != buf->vb.field)\r\nreturn;\r\nvbuf += dev->compose_cap.left * pixsize + dev->compose_cap.top * stride;\r\nx = dev->overlay_cap_left;\r\nw = img_width;\r\nif (x < 0) {\r\nout_x = -x;\r\nw = w - out_x;\r\nx = 0;\r\n} else {\r\nw = dev->fb_cap.fmt.width - x;\r\nif (w > img_width)\r\nw = img_width;\r\n}\r\nif (w <= 0)\r\nreturn;\r\nif (dev->overlay_cap_top >= 0)\r\nvbase += dev->overlay_cap_top * dev->fb_cap.fmt.bytesperline;\r\nfor (y = dev->overlay_cap_top;\r\ny < dev->overlay_cap_top + (int)img_height;\r\ny++, vbuf += stride) {\r\nint px;\r\nif (y < 0 || y > dev->fb_cap.fmt.height)\r\ncontinue;\r\nif (quick) {\r\nmemcpy(vbase + x * pixsize,\r\nvbuf + out_x * pixsize, w * pixsize);\r\nvbase += dev->fb_cap.fmt.bytesperline;\r\ncontinue;\r\n}\r\nfor (px = 0; px < w; px++) {\r\nif (!valid_pix(dev, y - dev->overlay_cap_top,\r\npx + out_x, y, px + x))\r\ncontinue;\r\nmemcpy(vbase + (px + x) * pixsize,\r\nvbuf + (px + out_x) * pixsize,\r\npixsize);\r\n}\r\nvbase += dev->fb_cap.fmt.bytesperline;\r\n}\r\n}\r\nstatic void vivid_thread_vid_cap_tick(struct vivid_dev *dev, int dropped_bufs)\r\n{\r\nstruct vivid_buffer *vid_cap_buf = NULL;\r\nstruct vivid_buffer *vbi_cap_buf = NULL;\r\ndprintk(dev, 1, "Video Capture Thread Tick\n");\r\nwhile (dropped_bufs-- > 1)\r\ntpg_update_mv_count(&dev->tpg,\r\ndev->field_cap == V4L2_FIELD_NONE ||\r\ndev->field_cap == V4L2_FIELD_ALTERNATE);\r\nif (dev->perc_dropped_buffers &&\r\nprandom_u32_max(100) < dev->perc_dropped_buffers)\r\ngoto update_mv;\r\nspin_lock(&dev->slock);\r\nif (!list_empty(&dev->vid_cap_active)) {\r\nvid_cap_buf = list_entry(dev->vid_cap_active.next, struct vivid_buffer, list);\r\nlist_del(&vid_cap_buf->list);\r\n}\r\nif (!list_empty(&dev->vbi_cap_active)) {\r\nif (dev->field_cap != V4L2_FIELD_ALTERNATE ||\r\n(dev->vbi_cap_seq_count & 1)) {\r\nvbi_cap_buf = list_entry(dev->vbi_cap_active.next,\r\nstruct vivid_buffer, list);\r\nlist_del(&vbi_cap_buf->list);\r\n}\r\n}\r\nspin_unlock(&dev->slock);\r\nif (!vid_cap_buf && !vbi_cap_buf)\r\ngoto update_mv;\r\nif (vid_cap_buf) {\r\nvivid_fillbuff(dev, vid_cap_buf);\r\ndprintk(dev, 1, "filled buffer %d\n",\r\nvid_cap_buf->vb.vb2_buf.index);\r\nif (dev->overlay_cap_owner && dev->fb_cap.base &&\r\ndev->fb_cap.fmt.pixelformat == dev->fmt_cap->fourcc)\r\nvivid_overlay(dev, vid_cap_buf);\r\nvb2_buffer_done(&vid_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\r\nVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\ndprintk(dev, 2, "vid_cap buffer %d done\n",\r\nvid_cap_buf->vb.vb2_buf.index);\r\n}\r\nif (vbi_cap_buf) {\r\nif (dev->stream_sliced_vbi_cap)\r\nvivid_sliced_vbi_cap_process(dev, vbi_cap_buf);\r\nelse\r\nvivid_raw_vbi_cap_process(dev, vbi_cap_buf);\r\nvb2_buffer_done(&vbi_cap_buf->vb.vb2_buf, dev->dqbuf_error ?\r\nVB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\ndprintk(dev, 2, "vbi_cap %d done\n",\r\nvbi_cap_buf->vb.vb2_buf.index);\r\n}\r\ndev->dqbuf_error = false;\r\nupdate_mv:\r\ntpg_update_mv_count(&dev->tpg, dev->field_cap == V4L2_FIELD_NONE ||\r\ndev->field_cap == V4L2_FIELD_ALTERNATE);\r\n}\r\nstatic int vivid_thread_vid_cap(void *data)\r\n{\r\nstruct vivid_dev *dev = data;\r\nu64 numerators_since_start;\r\nu64 buffers_since_start;\r\nu64 next_jiffies_since_start;\r\nunsigned long jiffies_since_start;\r\nunsigned long cur_jiffies;\r\nunsigned wait_jiffies;\r\nunsigned numerator;\r\nunsigned denominator;\r\nint dropped_bufs;\r\ndprintk(dev, 1, "Video Capture Thread Start\n");\r\nset_freezable();\r\ndev->cap_seq_offset = 0;\r\ndev->cap_seq_count = 0;\r\ndev->cap_seq_resync = false;\r\ndev->jiffies_vid_cap = jiffies;\r\nfor (;;) {\r\ntry_to_freeze();\r\nif (kthread_should_stop())\r\nbreak;\r\nmutex_lock(&dev->mutex);\r\ncur_jiffies = jiffies;\r\nif (dev->cap_seq_resync) {\r\ndev->jiffies_vid_cap = cur_jiffies;\r\ndev->cap_seq_offset = dev->cap_seq_count + 1;\r\ndev->cap_seq_count = 0;\r\ndev->cap_seq_resync = false;\r\n}\r\nnumerator = dev->timeperframe_vid_cap.numerator;\r\ndenominator = dev->timeperframe_vid_cap.denominator;\r\nif (dev->field_cap == V4L2_FIELD_ALTERNATE)\r\ndenominator *= 2;\r\njiffies_since_start = cur_jiffies - dev->jiffies_vid_cap;\r\nbuffers_since_start = (u64)jiffies_since_start * denominator +\r\n(HZ * numerator) / 2;\r\ndo_div(buffers_since_start, HZ * numerator);\r\nif (jiffies_since_start > JIFFIES_RESYNC) {\r\ndev->jiffies_vid_cap = cur_jiffies;\r\ndev->cap_seq_offset = buffers_since_start;\r\nbuffers_since_start = 0;\r\n}\r\ndropped_bufs = buffers_since_start + dev->cap_seq_offset - dev->cap_seq_count;\r\ndev->cap_seq_count = buffers_since_start + dev->cap_seq_offset;\r\ndev->vid_cap_seq_count = dev->cap_seq_count - dev->vid_cap_seq_start;\r\ndev->vbi_cap_seq_count = dev->cap_seq_count - dev->vbi_cap_seq_start;\r\nvivid_thread_vid_cap_tick(dev, dropped_bufs);\r\nnumerators_since_start = ++buffers_since_start * numerator;\r\njiffies_since_start = jiffies - dev->jiffies_vid_cap;\r\nmutex_unlock(&dev->mutex);\r\nnext_jiffies_since_start = numerators_since_start * HZ +\r\ndenominator / 2;\r\ndo_div(next_jiffies_since_start, denominator);\r\nif (next_jiffies_since_start < jiffies_since_start)\r\nnext_jiffies_since_start = jiffies_since_start;\r\nwait_jiffies = next_jiffies_since_start - jiffies_since_start;\r\nschedule_timeout_interruptible(wait_jiffies ? wait_jiffies : 1);\r\n}\r\ndprintk(dev, 1, "Video Capture Thread End\n");\r\nreturn 0;\r\n}\r\nstatic void vivid_grab_controls(struct vivid_dev *dev, bool grab)\r\n{\r\nv4l2_ctrl_grab(dev->ctrl_has_crop_cap, grab);\r\nv4l2_ctrl_grab(dev->ctrl_has_compose_cap, grab);\r\nv4l2_ctrl_grab(dev->ctrl_has_scaler_cap, grab);\r\n}\r\nint vivid_start_generating_vid_cap(struct vivid_dev *dev, bool *pstreaming)\r\n{\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dev->kthread_vid_cap) {\r\nu32 seq_count = dev->cap_seq_count + dev->seq_wrap * 128;\r\nif (pstreaming == &dev->vid_cap_streaming)\r\ndev->vid_cap_seq_start = seq_count;\r\nelse\r\ndev->vbi_cap_seq_start = seq_count;\r\n*pstreaming = true;\r\nreturn 0;\r\n}\r\ntpg_init_mv_count(&dev->tpg);\r\ndev->vid_cap_seq_start = dev->seq_wrap * 128;\r\ndev->vbi_cap_seq_start = dev->seq_wrap * 128;\r\ndev->kthread_vid_cap = kthread_run(vivid_thread_vid_cap, dev,\r\n"%s-vid-cap", dev->v4l2_dev.name);\r\nif (IS_ERR(dev->kthread_vid_cap)) {\r\nv4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");\r\nreturn PTR_ERR(dev->kthread_vid_cap);\r\n}\r\n*pstreaming = true;\r\nvivid_grab_controls(dev, true);\r\ndprintk(dev, 1, "returning from %s\n", __func__);\r\nreturn 0;\r\n}\r\nvoid vivid_stop_generating_vid_cap(struct vivid_dev *dev, bool *pstreaming)\r\n{\r\ndprintk(dev, 1, "%s\n", __func__);\r\nif (dev->kthread_vid_cap == NULL)\r\nreturn;\r\n*pstreaming = false;\r\nif (pstreaming == &dev->vid_cap_streaming) {\r\nwhile (!list_empty(&dev->vid_cap_active)) {\r\nstruct vivid_buffer *buf;\r\nbuf = list_entry(dev->vid_cap_active.next,\r\nstruct vivid_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\ndprintk(dev, 2, "vid_cap buffer %d done\n",\r\nbuf->vb.vb2_buf.index);\r\n}\r\n}\r\nif (pstreaming == &dev->vbi_cap_streaming) {\r\nwhile (!list_empty(&dev->vbi_cap_active)) {\r\nstruct vivid_buffer *buf;\r\nbuf = list_entry(dev->vbi_cap_active.next,\r\nstruct vivid_buffer, list);\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\ndprintk(dev, 2, "vbi_cap buffer %d done\n",\r\nbuf->vb.vb2_buf.index);\r\n}\r\n}\r\nif (dev->vid_cap_streaming || dev->vbi_cap_streaming)\r\nreturn;\r\nvivid_grab_controls(dev, false);\r\nmutex_unlock(&dev->mutex);\r\nkthread_stop(dev->kthread_vid_cap);\r\ndev->kthread_vid_cap = NULL;\r\nmutex_lock(&dev->mutex);\r\n}
