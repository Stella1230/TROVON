static inline unsigned int reg_status(struct bcm7038_l1_chip *intc,\r\nunsigned int word)\r\n{\r\nreturn (0 * intc->n_words + word) * sizeof(u32);\r\n}\r\nstatic inline unsigned int reg_mask_status(struct bcm7038_l1_chip *intc,\r\nunsigned int word)\r\n{\r\nreturn (1 * intc->n_words + word) * sizeof(u32);\r\n}\r\nstatic inline unsigned int reg_mask_set(struct bcm7038_l1_chip *intc,\r\nunsigned int word)\r\n{\r\nreturn (2 * intc->n_words + word) * sizeof(u32);\r\n}\r\nstatic inline unsigned int reg_mask_clr(struct bcm7038_l1_chip *intc,\r\nunsigned int word)\r\n{\r\nreturn (3 * intc->n_words + word) * sizeof(u32);\r\n}\r\nstatic inline u32 l1_readl(void __iomem *reg)\r\n{\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\nreturn ioread32be(reg);\r\nelse\r\nreturn readl(reg);\r\n}\r\nstatic inline void l1_writel(u32 val, void __iomem *reg)\r\n{\r\nif (IS_ENABLED(CONFIG_MIPS) && IS_ENABLED(CONFIG_CPU_BIG_ENDIAN))\r\niowrite32be(val, reg);\r\nelse\r\nwritel(val, reg);\r\n}\r\nstatic void bcm7038_l1_irq_handle(struct irq_desc *desc)\r\n{\r\nstruct bcm7038_l1_chip *intc = irq_desc_get_handler_data(desc);\r\nstruct bcm7038_l1_cpu *cpu;\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nunsigned int idx;\r\n#ifdef CONFIG_SMP\r\ncpu = intc->cpus[cpu_logical_map(smp_processor_id())];\r\n#else\r\ncpu = intc->cpus[0];\r\n#endif\r\nchained_irq_enter(chip, desc);\r\nfor (idx = 0; idx < intc->n_words; idx++) {\r\nint base = idx * IRQS_PER_WORD;\r\nunsigned long pending, flags;\r\nint hwirq;\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\npending = l1_readl(cpu->map_base + reg_status(intc, idx)) &\r\n~cpu->mask_cache[idx];\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\nfor_each_set_bit(hwirq, &pending, IRQS_PER_WORD) {\r\ngeneric_handle_irq(irq_find_mapping(intc->domain,\r\nbase + hwirq));\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void __bcm7038_l1_unmask(struct irq_data *d, unsigned int cpu_idx)\r\n{\r\nstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nu32 word = d->hwirq / IRQS_PER_WORD;\r\nu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\r\nintc->cpus[cpu_idx]->mask_cache[word] &= ~mask;\r\nl1_writel(mask, intc->cpus[cpu_idx]->map_base +\r\nreg_mask_clr(intc, word));\r\n}\r\nstatic void __bcm7038_l1_mask(struct irq_data *d, unsigned int cpu_idx)\r\n{\r\nstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nu32 word = d->hwirq / IRQS_PER_WORD;\r\nu32 mask = BIT(d->hwirq % IRQS_PER_WORD);\r\nintc->cpus[cpu_idx]->mask_cache[word] |= mask;\r\nl1_writel(mask, intc->cpus[cpu_idx]->map_base +\r\nreg_mask_set(intc, word));\r\n}\r\nstatic void bcm7038_l1_unmask(struct irq_data *d)\r\n{\r\nstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\n__bcm7038_l1_unmask(d, intc->affinity[d->hwirq]);\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\n}\r\nstatic void bcm7038_l1_mask(struct irq_data *d)\r\n{\r\nstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\n__bcm7038_l1_mask(d, intc->affinity[d->hwirq]);\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\n}\r\nstatic int bcm7038_l1_set_affinity(struct irq_data *d,\r\nconst struct cpumask *dest,\r\nbool force)\r\n{\r\nstruct bcm7038_l1_chip *intc = irq_data_get_irq_chip_data(d);\r\nunsigned long flags;\r\nirq_hw_number_t hw = d->hwirq;\r\nu32 word = hw / IRQS_PER_WORD;\r\nu32 mask = BIT(hw % IRQS_PER_WORD);\r\nunsigned int first_cpu = cpumask_any_and(dest, cpu_online_mask);\r\nbool was_disabled;\r\nraw_spin_lock_irqsave(&intc->lock, flags);\r\nwas_disabled = !!(intc->cpus[intc->affinity[hw]]->mask_cache[word] &\r\nmask);\r\n__bcm7038_l1_mask(d, intc->affinity[hw]);\r\nintc->affinity[hw] = first_cpu;\r\nif (!was_disabled)\r\n__bcm7038_l1_unmask(d, first_cpu);\r\nraw_spin_unlock_irqrestore(&intc->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void bcm7038_l1_cpu_offline(struct irq_data *d)\r\n{\r\nstruct cpumask *mask = irq_data_get_affinity_mask(d);\r\nint cpu = smp_processor_id();\r\ncpumask_t new_affinity;\r\nif (!cpumask_test_cpu(cpu, mask))\r\nreturn;\r\nif (cpumask_weight(mask) > 1) {\r\ncpumask_copy(&new_affinity, mask);\r\ncpumask_clear_cpu(cpu, &new_affinity);\r\n} else {\r\ncpumask_clear(&new_affinity);\r\ncpumask_set_cpu(cpumask_first(cpu_online_mask), &new_affinity);\r\n}\r\nirq_set_affinity_locked(d, &new_affinity, false);\r\n}\r\nstatic int __init bcm7038_l1_init_one(struct device_node *dn,\r\nunsigned int idx,\r\nstruct bcm7038_l1_chip *intc)\r\n{\r\nstruct resource res;\r\nresource_size_t sz;\r\nstruct bcm7038_l1_cpu *cpu;\r\nunsigned int i, n_words, parent_irq;\r\nif (of_address_to_resource(dn, idx, &res))\r\nreturn -EINVAL;\r\nsz = resource_size(&res);\r\nn_words = sz / REG_BYTES_PER_IRQ_WORD;\r\nif (n_words > MAX_WORDS)\r\nreturn -EINVAL;\r\nelse if (!intc->n_words)\r\nintc->n_words = n_words;\r\nelse if (intc->n_words != n_words)\r\nreturn -EINVAL;\r\ncpu = intc->cpus[idx] = kzalloc(sizeof(*cpu) + n_words * sizeof(u32),\r\nGFP_KERNEL);\r\nif (!cpu)\r\nreturn -ENOMEM;\r\ncpu->map_base = ioremap(res.start, sz);\r\nif (!cpu->map_base)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < n_words; i++) {\r\nl1_writel(0xffffffff, cpu->map_base + reg_mask_set(intc, i));\r\ncpu->mask_cache[i] = 0xffffffff;\r\n}\r\nparent_irq = irq_of_parse_and_map(dn, idx);\r\nif (!parent_irq) {\r\npr_err("failed to map parent interrupt %d\n", parent_irq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_chained_handler_and_data(parent_irq, bcm7038_l1_irq_handle,\r\nintc);\r\nreturn 0;\r\n}\r\nstatic int bcm7038_l1_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw_irq)\r\n{\r\nirq_set_chip_and_handler(virq, &bcm7038_l1_irq_chip, handle_level_irq);\r\nirq_set_chip_data(virq, d->host_data);\r\nreturn 0;\r\n}\r\nint __init bcm7038_l1_of_init(struct device_node *dn,\r\nstruct device_node *parent)\r\n{\r\nstruct bcm7038_l1_chip *intc;\r\nint idx, ret;\r\nintc = kzalloc(sizeof(*intc), GFP_KERNEL);\r\nif (!intc)\r\nreturn -ENOMEM;\r\nraw_spin_lock_init(&intc->lock);\r\nfor_each_possible_cpu(idx) {\r\nret = bcm7038_l1_init_one(dn, idx, intc);\r\nif (ret < 0) {\r\nif (idx)\r\nbreak;\r\npr_err("failed to remap intc L1 registers\n");\r\ngoto out_free;\r\n}\r\n}\r\nintc->domain = irq_domain_add_linear(dn, IRQS_PER_WORD * intc->n_words,\r\n&bcm7038_l1_domain_ops,\r\nintc);\r\nif (!intc->domain) {\r\nret = -ENOMEM;\r\ngoto out_unmap;\r\n}\r\npr_info("registered BCM7038 L1 intc (mem: 0x%p, IRQs: %d)\n",\r\nintc->cpus[0]->map_base, IRQS_PER_WORD * intc->n_words);\r\nreturn 0;\r\nout_unmap:\r\nfor_each_possible_cpu(idx) {\r\nstruct bcm7038_l1_cpu *cpu = intc->cpus[idx];\r\nif (cpu) {\r\nif (cpu->map_base)\r\niounmap(cpu->map_base);\r\nkfree(cpu);\r\n}\r\n}\r\nout_free:\r\nkfree(intc);\r\nreturn ret;\r\n}
