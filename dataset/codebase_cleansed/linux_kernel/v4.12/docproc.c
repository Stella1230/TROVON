static void consume_symbol(const char *sym)\r\n{\r\nint i;\r\nfor (i = 0; i < all_list_len; i++) {\r\nif (!all_list[i])\r\ncontinue;\r\nif (strcmp(sym, all_list[i]))\r\ncontinue;\r\nall_list[i] = NULL;\r\nbreak;\r\n}\r\n}\r\nstatic void usage (void)\r\n{\r\nfprintf(stderr, "Usage: docproc [{--docbook|--rst}] {doc|depend} file\n");\r\nfprintf(stderr, "Input is read from file.tmpl. Output is sent to stdout\n");\r\nfprintf(stderr, "doc: frontend when generating kernel documentation\n");\r\nfprintf(stderr, "depend: generate list of files referenced within file\n");\r\nfprintf(stderr, "Environment variable SRCTREE: absolute path to sources.\n");\r\nfprintf(stderr, " KBUILD_SRC: absolute path to kernel source tree.\n");\r\n}\r\nstatic void exec_kernel_doc(char **svec)\r\n{\r\npid_t pid;\r\nint ret;\r\nchar real_filename[PATH_MAX + 1];\r\nfflush(stdout);\r\nswitch (pid=fork()) {\r\ncase -1:\r\nperror("fork");\r\nexit(1);\r\ncase 0:\r\nmemset(real_filename, 0, sizeof(real_filename));\r\nstrncat(real_filename, kernsrctree, PATH_MAX);\r\nstrncat(real_filename, "/" KERNELDOCPATH KERNELDOC,\r\nPATH_MAX - strlen(real_filename));\r\nexecvp(real_filename, svec);\r\nfprintf(stderr, "exec ");\r\nperror(real_filename);\r\nexit(1);\r\ndefault:\r\nwaitpid(pid, &ret ,0);\r\n}\r\nif (WIFEXITED(ret))\r\nexitstatus |= WEXITSTATUS(ret);\r\nelse\r\nexitstatus = 0xff;\r\n}\r\nstatic void add_new_symbol(struct symfile *sym, char * symname)\r\n{\r\nsym->symbollist =\r\nrealloc(sym->symbollist, (sym->symbolcnt + 1) * sizeof(char *));\r\nsym->symbollist[sym->symbolcnt++].name = strdup(symname);\r\n}\r\nstatic struct symfile * add_new_file(char * filename)\r\n{\r\nsymfilelist[symfilecnt++].filename = strdup(filename);\r\nreturn &symfilelist[symfilecnt - 1];\r\n}\r\nstatic struct symfile * filename_exist(char * filename)\r\n{\r\nint i;\r\nfor (i=0; i < symfilecnt; i++)\r\nif (strcmp(symfilelist[i].filename, filename) == 0)\r\nreturn &symfilelist[i];\r\nreturn NULL;\r\n}\r\nstatic void adddep(char * file) { printf("\t%s", file); }\r\nstatic void adddep2(char * file, char * line) { line = line; adddep(file); }\r\nstatic void noaction(char * line) { line = line; }\r\nstatic void noaction2(char * file, char * line) { file = file; line = line; }\r\nstatic void printline(char * line) { printf("%s", line); }\r\nstatic void find_export_symbols(char * filename)\r\n{\r\nFILE * fp;\r\nstruct symfile *sym;\r\nchar line[MAXLINESZ];\r\nif (filename_exist(filename) == NULL) {\r\nchar real_filename[PATH_MAX + 1];\r\nmemset(real_filename, 0, sizeof(real_filename));\r\nstrncat(real_filename, srctree, PATH_MAX);\r\nstrncat(real_filename, "/", PATH_MAX - strlen(real_filename));\r\nstrncat(real_filename, filename,\r\nPATH_MAX - strlen(real_filename));\r\nsym = add_new_file(filename);\r\nfp = fopen(real_filename, "r");\r\nif (fp == NULL) {\r\nfprintf(stderr, "docproc: ");\r\nperror(real_filename);\r\nexit(1);\r\n}\r\nwhile (fgets(line, MAXLINESZ, fp)) {\r\nchar *p;\r\nchar *e;\r\nif (((p = strstr(line, "EXPORT_SYMBOL_GPL")) != NULL) ||\r\n((p = strstr(line, "EXPORT_SYMBOL")) != NULL)) {\r\nwhile (isalnum(*p) || *p == '_')\r\np++;\r\nwhile (isspace(*p))\r\np++;\r\nif (*p != '(')\r\ncontinue;\r\nelse\r\np++;\r\nwhile (isspace(*p))\r\np++;\r\ne = p;\r\nwhile (isalnum(*e) || *e == '_')\r\ne++;\r\n*e = '\0';\r\nadd_new_symbol(sym, p);\r\n}\r\n}\r\nfclose(fp);\r\n}\r\n}\r\nstatic void docfunctions(char * filename, char * type)\r\n{\r\nint i,j;\r\nint symcnt = 0;\r\nint idx = 0;\r\nchar **vec;\r\nfor (i=0; i <= symfilecnt; i++)\r\nsymcnt += symfilelist[i].symbolcnt;\r\nvec = malloc((2 + 2 * symcnt + 3) * sizeof(char *));\r\nif (vec == NULL) {\r\nperror("docproc: ");\r\nexit(1);\r\n}\r\nvec[idx++] = KERNELDOC;\r\nvec[idx++] = KERNELDOC_FORMAT;\r\nvec[idx++] = NODOCSECTIONS;\r\nfor (i=0; i < symfilecnt; i++) {\r\nstruct symfile * sym = &symfilelist[i];\r\nfor (j=0; j < sym->symbolcnt; j++) {\r\nvec[idx++] = type;\r\nconsume_symbol(sym->symbollist[j].name);\r\nvec[idx++] = sym->symbollist[j].name;\r\n}\r\n}\r\nvec[idx++] = filename;\r\nvec[idx] = NULL;\r\nif (file_format == FORMAT_RST)\r\nprintf(".. %s\n", filename);\r\nelse\r\nprintf("<!-- %s -->\n", filename);\r\nexec_kernel_doc(vec);\r\nfflush(stdout);\r\nfree(vec);\r\n}\r\nstatic void intfunc(char * filename) { docfunctions(filename, NOFUNCTION); }\r\nstatic void extfunc(char * filename) { docfunctions(filename, FUNCTION); }\r\nstatic void singfunc(char * filename, char * line)\r\n{\r\nchar *vec[200];\r\nint i, idx = 0;\r\nint startofsym = 1;\r\nvec[idx++] = KERNELDOC;\r\nvec[idx++] = KERNELDOC_FORMAT;\r\nvec[idx++] = SHOWNOTFOUND;\r\nfor (i=0; line[i]; i++) {\r\nif (isspace(line[i])) {\r\nline[i] = '\0';\r\nstartofsym = 1;\r\ncontinue;\r\n}\r\nif (startofsym) {\r\nstartofsym = 0;\r\nvec[idx++] = FUNCTION;\r\nvec[idx++] = &line[i];\r\n}\r\n}\r\nfor (i = 0; i < idx; i++) {\r\nif (strcmp(vec[i], FUNCTION))\r\ncontinue;\r\nconsume_symbol(vec[i + 1]);\r\n}\r\nvec[idx++] = filename;\r\nvec[idx] = NULL;\r\nexec_kernel_doc(vec);\r\n}\r\nstatic void docsect(char *filename, char *line)\r\n{\r\nchar *vec[7];\r\nchar *s;\r\nfor (s = line; *s; s++)\r\nif (*s == '\n')\r\n*s = '\0';\r\nif (asprintf(&s, "DOC: %s", line) < 0) {\r\nperror("asprintf");\r\nexit(1);\r\n}\r\nconsume_symbol(s);\r\nfree(s);\r\nvec[0] = KERNELDOC;\r\nvec[1] = KERNELDOC_FORMAT;\r\nvec[2] = SHOWNOTFOUND;\r\nvec[3] = FUNCTION;\r\nvec[4] = line;\r\nvec[5] = filename;\r\nvec[6] = NULL;\r\nexec_kernel_doc(vec);\r\n}\r\nstatic void find_all_symbols(char *filename)\r\n{\r\nchar *vec[4];\r\npid_t pid;\r\nint ret, i, count, start;\r\nchar real_filename[PATH_MAX + 1];\r\nint pipefd[2];\r\nchar *data, *str;\r\nsize_t data_len = 0;\r\nvec[0] = KERNELDOC;\r\nvec[1] = LIST;\r\nvec[2] = filename;\r\nvec[3] = NULL;\r\nif (pipe(pipefd)) {\r\nperror("pipe");\r\nexit(1);\r\n}\r\nswitch (pid=fork()) {\r\ncase -1:\r\nperror("fork");\r\nexit(1);\r\ncase 0:\r\nclose(pipefd[0]);\r\ndup2(pipefd[1], 1);\r\nmemset(real_filename, 0, sizeof(real_filename));\r\nstrncat(real_filename, kernsrctree, PATH_MAX);\r\nstrncat(real_filename, "/" KERNELDOCPATH KERNELDOC,\r\nPATH_MAX - strlen(real_filename));\r\nexecvp(real_filename, vec);\r\nfprintf(stderr, "exec ");\r\nperror(real_filename);\r\nexit(1);\r\ndefault:\r\nclose(pipefd[1]);\r\ndata = malloc(4096);\r\ndo {\r\nwhile ((ret = read(pipefd[0],\r\ndata + data_len,\r\n4096)) > 0) {\r\ndata_len += ret;\r\ndata = realloc(data, data_len + 4096);\r\n}\r\n} while (ret == -EAGAIN);\r\nif (ret != 0) {\r\nperror("read");\r\nexit(1);\r\n}\r\nwaitpid(pid, &ret ,0);\r\n}\r\nif (WIFEXITED(ret))\r\nexitstatus |= WEXITSTATUS(ret);\r\nelse\r\nexitstatus = 0xff;\r\ncount = 0;\r\nfor (i = 0; i < data_len; i++) {\r\nif (data[i] == '\n') {\r\ncount++;\r\ndata[i] = '\0';\r\n}\r\n}\r\nstart = all_list_len;\r\nall_list_len += count;\r\nall_list = realloc(all_list, sizeof(char *) * all_list_len);\r\nstr = data;\r\nfor (i = 0; i < data_len && start != all_list_len; i++) {\r\nif (data[i] == '\0') {\r\nall_list[start] = str;\r\nstr = data + i + 1;\r\nstart++;\r\n}\r\n}\r\n}\r\nstatic char *chomp(char *s)\r\n{\r\nwhile (*s && !isspace(*s))\r\ns++;\r\nif (*s)\r\n*s++ = '\0';\r\nreturn s;\r\n}\r\nstatic char *is_directive(char *line)\r\n{\r\nif (file_format == FORMAT_DOCBOOK && line[0] == '!')\r\nreturn line + 1;\r\nelse if (file_format == FORMAT_RST && !strncmp(line, ".. !", 4))\r\nreturn line + 4;\r\nreturn NULL;\r\n}\r\nstatic void parse_file(FILE *infile)\r\n{\r\nchar line[MAXLINESZ];\r\nchar *p, *s;\r\nwhile (fgets(line, MAXLINESZ, infile)) {\r\np = is_directive(line);\r\nif (!p) {\r\ndefaultline(line);\r\ncontinue;\r\n}\r\nswitch (*p++) {\r\ncase 'E':\r\nchomp(p);\r\nexternalfunctions(p);\r\nbreak;\r\ncase 'I':\r\nchomp(p);\r\ninternalfunctions(p);\r\nbreak;\r\ncase 'D':\r\nchomp(p);\r\nsymbolsonly(p);\r\nbreak;\r\ncase 'F':\r\ns = chomp(p);\r\nwhile (isspace(*s))\r\ns++;\r\nsinglefunctions(p, s);\r\nbreak;\r\ncase 'P':\r\ns = chomp(p);\r\nwhile (isspace(*s))\r\ns++;\r\ndocsection(p, s);\r\nbreak;\r\ncase 'C':\r\nchomp(p);\r\nif (findall)\r\nfindall(p);\r\nbreak;\r\ndefault:\r\ndefaultline(line);\r\n}\r\n}\r\nfflush(stdout);\r\n}\r\nstatic int is_rst(const char *file)\r\n{\r\nchar *dot = strrchr(file, '.');\r\nreturn dot && !strcmp(dot + 1, "rst");\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nconst char *subcommand, *filename;\r\nFILE * infile;\r\nint i;\r\nsrctree = getenv("SRCTREE");\r\nif (!srctree)\r\nsrctree = getcwd(NULL, 0);\r\nkernsrctree = getenv("KBUILD_SRC");\r\nif (!kernsrctree || !*kernsrctree)\r\nkernsrctree = srctree;\r\nfor (;;) {\r\nint c;\r\nstruct option opts[] = {\r\n{ "docbook", no_argument, NULL, OPT_DOCBOOK },\r\n{ "rst", no_argument, NULL, OPT_RST },\r\n{ "help", no_argument, NULL, OPT_HELP },\r\n{}\r\n};\r\nc = getopt_long_only(argc, argv, "", opts, NULL);\r\nif (c == -1)\r\nbreak;\r\nswitch (c) {\r\ncase OPT_DOCBOOK:\r\nfile_format = FORMAT_DOCBOOK;\r\nbreak;\r\ncase OPT_RST:\r\nfile_format = FORMAT_RST;\r\nbreak;\r\ncase OPT_HELP:\r\nusage();\r\nreturn 0;\r\ndefault:\r\ncase '?':\r\nusage();\r\nreturn 1;\r\n}\r\n}\r\nargc -= optind;\r\nargv += optind;\r\nif (argc != 2) {\r\nusage();\r\nexit(1);\r\n}\r\nsubcommand = argv[0];\r\nfilename = argv[1];\r\nif (file_format == FORMAT_AUTO)\r\nfile_format = is_rst(filename) ? FORMAT_RST : FORMAT_DOCBOOK;\r\ninfile = fopen(filename, "r");\r\nif (infile == NULL) {\r\nfprintf(stderr, "docproc: ");\r\nperror(filename);\r\nexit(2);\r\n}\r\nif (strcmp("doc", subcommand) == 0) {\r\nif (file_format == FORMAT_RST) {\r\ntime_t t = time(NULL);\r\nprintf(".. generated from %s by docproc %s\n",\r\nfilename, ctime(&t));\r\n}\r\ndefaultline = noaction;\r\ninternalfunctions = find_export_symbols;\r\nexternalfunctions = find_export_symbols;\r\nsymbolsonly = find_export_symbols;\r\nsinglefunctions = noaction2;\r\ndocsection = noaction2;\r\nfindall = find_all_symbols;\r\nparse_file(infile);\r\nfseek(infile, 0, SEEK_SET);\r\ndefaultline = printline;\r\ninternalfunctions = intfunc;\r\nexternalfunctions = extfunc;\r\nsymbolsonly = printline;\r\nsinglefunctions = singfunc;\r\ndocsection = docsect;\r\nfindall = NULL;\r\nparse_file(infile);\r\nfor (i = 0; i < all_list_len; i++) {\r\nif (!all_list[i])\r\ncontinue;\r\nfprintf(stderr, "Warning: didn't use docs for %s\n",\r\nall_list[i]);\r\n}\r\n} else if (strcmp("depend", subcommand) == 0) {\r\nprintf("%s\t", filename);\r\ndefaultline = noaction;\r\ninternalfunctions = adddep;\r\nexternalfunctions = adddep;\r\nsymbolsonly = adddep;\r\nsinglefunctions = adddep2;\r\ndocsection = adddep2;\r\nfindall = adddep;\r\nparse_file(infile);\r\nprintf("\n");\r\n} else {\r\nfprintf(stderr, "Unknown option: %s\n", subcommand);\r\nexit(1);\r\n}\r\nfclose(infile);\r\nfflush(stdout);\r\nreturn exitstatus;\r\n}
