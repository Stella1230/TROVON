static inline u_char\r\nReadISAC(struct IsdnCardState *cs, u_char offset)\r\n{\r\nu_char ret;\r\noffset -= 0x20;\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET, ISAC_REG_OFFSET + offset);\r\nret = bytein(cs->hw.avm.cfg_reg + DATAREG_OFFSET);\r\nreturn ret;\r\n}\r\nstatic inline void\r\nWriteISAC(struct IsdnCardState *cs, u_char offset, u_char value)\r\n{\r\noffset -= 0x20;\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET, ISAC_REG_OFFSET + offset);\r\nbyteout(cs->hw.avm.cfg_reg + DATAREG_OFFSET, value);\r\n}\r\nstatic inline void\r\nReadISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET, ISAC_FIFO_OFFSET);\r\ninsb(cs->hw.avm.cfg_reg + DATAREG_OFFSET, data, size);\r\n}\r\nstatic inline void\r\nWriteISACfifo(struct IsdnCardState *cs, u_char *data, int size)\r\n{\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET, ISAC_FIFO_OFFSET);\r\noutsb(cs->hw.avm.cfg_reg + DATAREG_OFFSET, data, size);\r\n}\r\nstatic inline u_char\r\nReadHSCX(struct IsdnCardState *cs, int hscx, u_char offset)\r\n{\r\nu_char ret;\r\noffset -= 0x20;\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET,\r\nHSCX_REG_OFFSET + hscx * HSCX_CH_DIFF + offset);\r\nret = bytein(cs->hw.avm.cfg_reg + DATAREG_OFFSET);\r\nreturn ret;\r\n}\r\nstatic inline void\r\nWriteHSCX(struct IsdnCardState *cs, int hscx, u_char offset, u_char value)\r\n{\r\noffset -= 0x20;\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET,\r\nHSCX_REG_OFFSET + hscx * HSCX_CH_DIFF + offset);\r\nbyteout(cs->hw.avm.cfg_reg + DATAREG_OFFSET, value);\r\n}\r\nstatic inline void\r\nReadHSCXfifo(struct IsdnCardState *cs, int hscx, u_char *data, int size)\r\n{\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET,\r\nHSCX_FIFO_OFFSET + hscx * HSCX_CH_DIFF);\r\ninsb(cs->hw.avm.cfg_reg + DATAREG_OFFSET, data, size);\r\n}\r\nstatic inline void\r\nWriteHSCXfifo(struct IsdnCardState *cs, int hscx, u_char *data, int size)\r\n{\r\nbyteout(cs->hw.avm.cfg_reg + ADDRREG_OFFSET,\r\nHSCX_FIFO_OFFSET + hscx * HSCX_CH_DIFF);\r\noutsb(cs->hw.avm.cfg_reg + DATAREG_OFFSET, data, size);\r\n}\r\nstatic irqreturn_t\r\navm_a1p_interrupt(int intno, void *dev_id)\r\n{\r\nstruct IsdnCardState *cs = dev_id;\r\nu_char val, sval;\r\nu_long flags;\r\nspin_lock_irqsave(&cs->lock, flags);\r\nwhile ((sval = (~bytein(cs->hw.avm.cfg_reg + ASL0_OFFSET) & ASL0_R_IRQPENDING))) {\r\nif (cs->debug & L1_DEB_INTSTAT)\r\ndebugl1(cs, "avm IntStatus %x", sval);\r\nif (sval & ASL0_R_HSCX) {\r\nval = ReadHSCX(cs, 1, HSCX_ISTA);\r\nif (val)\r\nhscx_int_main(cs, val);\r\n}\r\nif (sval & ASL0_R_ISAC) {\r\nval = ReadISAC(cs, ISAC_ISTA);\r\nif (val)\r\nisac_interrupt(cs, val);\r\n}\r\n}\r\nWriteHSCX(cs, 0, HSCX_MASK, 0xff);\r\nWriteHSCX(cs, 1, HSCX_MASK, 0xff);\r\nWriteISAC(cs, ISAC_MASK, 0xff);\r\nWriteISAC(cs, ISAC_MASK, 0x00);\r\nWriteHSCX(cs, 0, HSCX_MASK, 0x00);\r\nWriteHSCX(cs, 1, HSCX_MASK, 0x00);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int\r\nAVM_card_msg(struct IsdnCardState *cs, int mt, void *arg)\r\n{\r\nu_long flags;\r\nswitch (mt) {\r\ncase CARD_RESET:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, 0x00);\r\nHZDELAY(HZ / 5 + 1);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, ASL0_W_RESET);\r\nHZDELAY(HZ / 5 + 1);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, 0x00);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn 0;\r\ncase CARD_RELEASE:\r\nreturn 0;\r\ncase CARD_INIT:\r\nspin_lock_irqsave(&cs->lock, flags);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, ASL0_W_TDISABLE | ASL0_W_TRESET | ASL0_W_IRQENABLE);\r\nclear_pending_isac_ints(cs);\r\nclear_pending_hscx_ints(cs);\r\ninithscxisac(cs, 1);\r\ninithscxisac(cs, 2);\r\nspin_unlock_irqrestore(&cs->lock, flags);\r\nreturn 0;\r\ncase CARD_TEST:\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nint setup_avm_a1_pcmcia(struct IsdnCard *card)\r\n{\r\nu_char model, vers;\r\nstruct IsdnCardState *cs = card->cs;\r\nchar tmp[64];\r\nstrcpy(tmp, avm_revision);\r\nprintk(KERN_INFO "HiSax: AVM A1 PCMCIA driver Rev. %s\n",\r\nHiSax_getrev(tmp));\r\nif (cs->typ != ISDN_CTYPE_A1_PCMCIA)\r\nreturn (0);\r\ncs->hw.avm.cfg_reg = card->para[1];\r\ncs->irq = card->para[0];\r\nbyteout(cs->hw.avm.cfg_reg + ASL1_OFFSET, ASL1_W_ENABLE_S0);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, 0x00);\r\nHZDELAY(HZ / 5 + 1);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, ASL0_W_RESET);\r\nHZDELAY(HZ / 5 + 1);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, 0x00);\r\nbyteout(cs->hw.avm.cfg_reg + ASL0_OFFSET, ASL0_W_TDISABLE | ASL0_W_TRESET);\r\nmodel = bytein(cs->hw.avm.cfg_reg + MODREG_OFFSET);\r\nvers = bytein(cs->hw.avm.cfg_reg + VERREG_OFFSET);\r\nprintk(KERN_INFO "AVM A1 PCMCIA: io 0x%x irq %d model %d version %d\n",\r\ncs->hw.avm.cfg_reg, cs->irq, model, vers);\r\nsetup_isac(cs);\r\ncs->readisac = &ReadISAC;\r\ncs->writeisac = &WriteISAC;\r\ncs->readisacfifo = &ReadISACfifo;\r\ncs->writeisacfifo = &WriteISACfifo;\r\ncs->BC_Read_Reg = &ReadHSCX;\r\ncs->BC_Write_Reg = &WriteHSCX;\r\ncs->BC_Send_Data = &hscx_fill_fifo;\r\ncs->cardmsg = &AVM_card_msg;\r\ncs->irq_flags = IRQF_SHARED;\r\ncs->irq_func = &avm_a1p_interrupt;\r\nISACVersion(cs, "AVM A1 PCMCIA:");\r\nif (HscxVersion(cs, "AVM A1 PCMCIA:")) {\r\nprintk(KERN_WARNING\r\n"AVM A1 PCMCIA: wrong HSCX versions check IO address\n");\r\nreturn (0);\r\n}\r\nreturn (1);\r\n}
