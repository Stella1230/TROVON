static void ichxrom_cleanup(struct ichxrom_window *window)\r\n{\r\nstruct ichxrom_map_info *map, *scratch;\r\nu16 word;\r\nint ret;\r\nret = pci_read_config_word(window->pdev, BIOS_CNTL, &word);\r\nif (!ret)\r\npci_write_config_word(window->pdev, BIOS_CNTL, word & ~1);\r\npci_dev_put(window->pdev);\r\nlist_for_each_entry_safe(map, scratch, &window->maps, list) {\r\nif (map->rsrc.parent)\r\nrelease_resource(&map->rsrc);\r\nmtd_device_unregister(map->mtd);\r\nmap_destroy(map->mtd);\r\nlist_del(&map->list);\r\nkfree(map);\r\n}\r\nif (window->rsrc.parent)\r\nrelease_resource(&window->rsrc);\r\nif (window->virt) {\r\niounmap(window->virt);\r\nwindow->virt = NULL;\r\nwindow->phys = 0;\r\nwindow->size = 0;\r\nwindow->pdev = NULL;\r\n}\r\n}\r\nstatic int __init ichxrom_init_one(struct pci_dev *pdev,\r\nconst struct pci_device_id *ent)\r\n{\r\nstatic char *rom_probe_types[] = { "cfi_probe", "jedec_probe", NULL };\r\nstruct ichxrom_window *window = &ichxrom_window;\r\nstruct ichxrom_map_info *map = NULL;\r\nunsigned long map_top;\r\nu8 byte;\r\nu16 word;\r\nwindow->pdev = pdev;\r\nwindow->phys = 0;\r\npci_read_config_byte(pdev, FWH_DEC_EN1, &byte);\r\nif (byte == 0xff) {\r\nwindow->phys = 0xffc00000;\r\npci_read_config_byte(pdev, FWH_DEC_EN2, &byte);\r\nif ((byte & 0x0f) == 0x0f) {\r\nwindow->phys = 0xff400000;\r\n}\r\nelse if ((byte & 0x0e) == 0x0e) {\r\nwindow->phys = 0xff500000;\r\n}\r\nelse if ((byte & 0x0c) == 0x0c) {\r\nwindow->phys = 0xff600000;\r\n}\r\nelse if ((byte & 0x08) == 0x08) {\r\nwindow->phys = 0xff700000;\r\n}\r\n}\r\nelse if ((byte & 0xfe) == 0xfe) {\r\nwindow->phys = 0xffc80000;\r\n}\r\nelse if ((byte & 0xfc) == 0xfc) {\r\nwindow->phys = 0xffd00000;\r\n}\r\nelse if ((byte & 0xf8) == 0xf8) {\r\nwindow->phys = 0xffd80000;\r\n}\r\nelse if ((byte & 0xf0) == 0xf0) {\r\nwindow->phys = 0xffe00000;\r\n}\r\nelse if ((byte & 0xe0) == 0xe0) {\r\nwindow->phys = 0xffe80000;\r\n}\r\nelse if ((byte & 0xc0) == 0xc0) {\r\nwindow->phys = 0xfff00000;\r\n}\r\nelse if ((byte & 0x80) == 0x80) {\r\nwindow->phys = 0xfff80000;\r\n}\r\nif (window->phys == 0) {\r\nprintk(KERN_ERR MOD_NAME ": Rom window is closed\n");\r\ngoto out;\r\n}\r\nwindow->phys -= 0x400000UL;\r\nwindow->size = (0xffffffffUL - window->phys) + 1UL;\r\npci_read_config_word(pdev, BIOS_CNTL, &word);\r\nif (!(word & 1) && (word & (1<<1))) {\r\nprintk(KERN_ERR MOD_NAME ": firmware access control, I can't enable writes\n");\r\ngoto out;\r\n}\r\npci_write_config_word(pdev, BIOS_CNTL, word | 1);\r\nwindow->rsrc.name = MOD_NAME;\r\nwindow->rsrc.start = window->phys;\r\nwindow->rsrc.end = window->phys + window->size - 1;\r\nwindow->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&iomem_resource, &window->rsrc)) {\r\nwindow->rsrc.parent = NULL;\r\nprintk(KERN_DEBUG MOD_NAME ": "\r\n"%s(): Unable to register resource %pR - kernel bug?\n",\r\n__func__, &window->rsrc);\r\n}\r\nwindow->virt = ioremap_nocache(window->phys, window->size);\r\nif (!window->virt) {\r\nprintk(KERN_ERR MOD_NAME ": ioremap(%08lx, %08lx) failed\n",\r\nwindow->phys, window->size);\r\ngoto out;\r\n}\r\nmap_top = window->phys;\r\nif ((window->phys & 0x3fffff) != 0) {\r\nmap_top = window->phys + 0x400000;\r\n}\r\n#if 1\r\nif (map_top < 0xffc00000) {\r\nmap_top = 0xffc00000;\r\n}\r\n#endif\r\nwhile((map_top - 1) < 0xffffffffUL) {\r\nstruct cfi_private *cfi;\r\nunsigned long offset;\r\nint i;\r\nif (!map) {\r\nmap = kmalloc(sizeof(*map), GFP_KERNEL);\r\n}\r\nif (!map) {\r\nprintk(KERN_ERR MOD_NAME ": kmalloc failed");\r\ngoto out;\r\n}\r\nmemset(map, 0, sizeof(*map));\r\nINIT_LIST_HEAD(&map->list);\r\nmap->map.name = map->map_name;\r\nmap->map.phys = map_top;\r\noffset = map_top - window->phys;\r\nmap->map.virt = (void __iomem *)\r\n(((unsigned long)(window->virt)) + offset);\r\nmap->map.size = 0xffffffffUL - map_top + 1UL;\r\nsprintf(map->map_name, "%s @%08Lx",\r\nMOD_NAME, (unsigned long long)map->map.phys);\r\nfor(map->map.bankwidth = 32; map->map.bankwidth;\r\nmap->map.bankwidth >>= 1)\r\n{\r\nchar **probe_type;\r\nif (!map_bankwidth_supported(map->map.bankwidth))\r\ncontinue;\r\nsimple_map_init(&map->map);\r\nprobe_type = rom_probe_types;\r\nfor(; *probe_type; probe_type++) {\r\nmap->mtd = do_map_probe(*probe_type, &map->map);\r\nif (map->mtd)\r\ngoto found;\r\n}\r\n}\r\nmap_top += ROM_PROBE_STEP_SIZE;\r\ncontinue;\r\nfound:\r\nif (map->mtd->size > map->map.size) {\r\nprintk(KERN_WARNING MOD_NAME\r\n" rom(%llu) larger than window(%lu). fixing...\n",\r\n(unsigned long long)map->mtd->size, map->map.size);\r\nmap->mtd->size = map->map.size;\r\n}\r\nif (window->rsrc.parent) {\r\nmap->rsrc.name = map->map_name;\r\nmap->rsrc.start = map->map.phys;\r\nmap->rsrc.end = map->map.phys + map->mtd->size - 1;\r\nmap->rsrc.flags = IORESOURCE_MEM | IORESOURCE_BUSY;\r\nif (request_resource(&window->rsrc, &map->rsrc)) {\r\nprintk(KERN_ERR MOD_NAME\r\n": cannot reserve MTD resource\n");\r\nmap->rsrc.parent = NULL;\r\n}\r\n}\r\nmap->map.virt = window->virt;\r\nmap->map.phys = window->phys;\r\ncfi = map->map.fldrv_priv;\r\nfor(i = 0; i < cfi->numchips; i++) {\r\ncfi->chips[i].start += offset;\r\n}\r\nmap->mtd->owner = THIS_MODULE;\r\nif (mtd_device_register(map->mtd, NULL, 0)) {\r\nmap_destroy(map->mtd);\r\nmap->mtd = NULL;\r\ngoto out;\r\n}\r\nmap_top += map->mtd->size;\r\nlist_add(&map->list, &window->maps);\r\nmap = NULL;\r\n}\r\nout:\r\nkfree(map);\r\nif (list_empty(&window->maps)) {\r\nichxrom_cleanup(window);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic void ichxrom_remove_one(struct pci_dev *pdev)\r\n{\r\nstruct ichxrom_window *window = &ichxrom_window;\r\nichxrom_cleanup(window);\r\n}\r\nstatic int __init init_ichxrom(void)\r\n{\r\nstruct pci_dev *pdev;\r\nstruct pci_device_id *id;\r\npdev = NULL;\r\nfor (id = ichxrom_pci_tbl; id->vendor; id++) {\r\npdev = pci_get_device(id->vendor, id->device, NULL);\r\nif (pdev) {\r\nbreak;\r\n}\r\n}\r\nif (pdev) {\r\nreturn ichxrom_init_one(pdev, &ichxrom_pci_tbl[0]);\r\n}\r\nreturn -ENXIO;\r\n#if 0\r\nreturn pci_register_driver(&ichxrom_driver);\r\n#endif\r\n}\r\nstatic void __exit cleanup_ichxrom(void)\r\n{\r\nichxrom_remove_one(ichxrom_window.pdev);\r\n}
