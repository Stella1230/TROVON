static int\r\nkalmia_send_init_packet(struct usbnet *dev, u8 *init_msg, u8 init_msg_len,\r\nu8 *buffer, u8 expected_len)\r\n{\r\nint act_len;\r\nint status;\r\nnetdev_dbg(dev->net, "Sending init packet");\r\nstatus = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, 0x02),\r\ninit_msg, init_msg_len, &act_len, KALMIA_USB_TIMEOUT);\r\nif (status != 0) {\r\nnetdev_err(dev->net,\r\n"Error sending init packet. Status %i, length %i\n",\r\nstatus, act_len);\r\nreturn status;\r\n}\r\nelse if (act_len != init_msg_len) {\r\nnetdev_err(dev->net,\r\n"Did not send all of init packet. Bytes sent: %i",\r\nact_len);\r\n}\r\nelse {\r\nnetdev_dbg(dev->net, "Successfully sent init packet.");\r\n}\r\nstatus = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, 0x81),\r\nbuffer, expected_len, &act_len, KALMIA_USB_TIMEOUT);\r\nif (status != 0)\r\nnetdev_err(dev->net,\r\n"Error receiving init result. Status %i, length %i\n",\r\nstatus, act_len);\r\nelse if (act_len != expected_len)\r\nnetdev_err(dev->net, "Unexpected init result length: %i\n",\r\nact_len);\r\nreturn status;\r\n}\r\nstatic int\r\nkalmia_init_and_get_ethernet_addr(struct usbnet *dev, u8 *ethernet_addr)\r\n{\r\nstatic const char init_msg_1[] =\r\n{ 0x57, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00,\r\n0x00, 0x00 };\r\nstatic const char init_msg_2[] =\r\n{ 0x57, 0x50, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xf4,\r\n0x00, 0x00 };\r\nstatic const int buflen = 28;\r\nchar *usb_buf;\r\nint status;\r\nusb_buf = kmalloc(buflen, GFP_DMA | GFP_KERNEL);\r\nif (!usb_buf)\r\nreturn -ENOMEM;\r\nmemcpy(usb_buf, init_msg_1, 12);\r\nstatus = kalmia_send_init_packet(dev, usb_buf, sizeof(init_msg_1)\r\n/ sizeof(init_msg_1[0]), usb_buf, 24);\r\nif (status != 0)\r\nreturn status;\r\nmemcpy(usb_buf, init_msg_2, 12);\r\nstatus = kalmia_send_init_packet(dev, usb_buf, sizeof(init_msg_2)\r\n/ sizeof(init_msg_2[0]), usb_buf, 28);\r\nif (status != 0)\r\nreturn status;\r\nmemcpy(ethernet_addr, usb_buf + 10, ETH_ALEN);\r\nkfree(usb_buf);\r\nreturn status;\r\n}\r\nstatic int\r\nkalmia_bind(struct usbnet *dev, struct usb_interface *intf)\r\n{\r\nint status;\r\nu8 ethernet_addr[ETH_ALEN];\r\nif (intf->cur_altsetting->desc.bInterfaceClass != USB_CLASS_VENDOR_SPEC)\r\nreturn -EINVAL;\r\ndev->in = usb_rcvbulkpipe(dev->udev, 0x81 & USB_ENDPOINT_NUMBER_MASK);\r\ndev->out = usb_sndbulkpipe(dev->udev, 0x02 & USB_ENDPOINT_NUMBER_MASK);\r\ndev->status = NULL;\r\ndev->net->hard_header_len += KALMIA_HEADER_LENGTH;\r\ndev->hard_mtu = 1400;\r\ndev->rx_urb_size = dev->hard_mtu * 10;\r\nstatus = kalmia_init_and_get_ethernet_addr(dev, ethernet_addr);\r\nif (status) {\r\nusb_set_intfdata(intf, NULL);\r\nusb_driver_release_interface(driver_of(intf), intf);\r\nreturn status;\r\n}\r\nmemcpy(dev->net->dev_addr, ethernet_addr, ETH_ALEN);\r\nreturn status;\r\n}\r\nstatic struct sk_buff *\r\nkalmia_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)\r\n{\r\nstruct sk_buff *skb2 = NULL;\r\nu16 content_len;\r\nunsigned char *header_start;\r\nunsigned char ether_type_1, ether_type_2;\r\nu8 remainder, padlen = 0;\r\nif (!skb_cloned(skb)) {\r\nint headroom = skb_headroom(skb);\r\nint tailroom = skb_tailroom(skb);\r\nif ((tailroom >= KALMIA_ALIGN_SIZE) && (headroom\r\n>= KALMIA_HEADER_LENGTH))\r\ngoto done;\r\nif ((headroom + tailroom) > (KALMIA_HEADER_LENGTH\r\n+ KALMIA_ALIGN_SIZE)) {\r\nskb->data = memmove(skb->head + KALMIA_HEADER_LENGTH,\r\nskb->data, skb->len);\r\nskb_set_tail_pointer(skb, skb->len);\r\ngoto done;\r\n}\r\n}\r\nskb2 = skb_copy_expand(skb, KALMIA_HEADER_LENGTH,\r\nKALMIA_ALIGN_SIZE, flags);\r\nif (!skb2)\r\nreturn NULL;\r\ndev_kfree_skb_any(skb);\r\nskb = skb2;\r\ndone:\r\nheader_start = skb_push(skb, KALMIA_HEADER_LENGTH);\r\nether_type_1 = header_start[KALMIA_HEADER_LENGTH + 12];\r\nether_type_2 = header_start[KALMIA_HEADER_LENGTH + 13];\r\nnetdev_dbg(dev->net, "Sending etherType: %02x%02x", ether_type_1,\r\nether_type_2);\r\nheader_start[0] = 0x57;\r\nheader_start[1] = 0x44;\r\ncontent_len = skb->len - KALMIA_HEADER_LENGTH;\r\nput_unaligned_le16(content_len, &header_start[2]);\r\nheader_start[4] = ether_type_1;\r\nheader_start[5] = ether_type_2;\r\nremainder = skb->len % KALMIA_ALIGN_SIZE;\r\nif (remainder > 0) {\r\npadlen = KALMIA_ALIGN_SIZE - remainder;\r\nmemset(skb_put(skb, padlen), 0, padlen);\r\n}\r\nnetdev_dbg(dev->net,\r\n"Sending package with length %i and padding %i. Header: %6phC.",\r\ncontent_len, padlen, header_start);\r\nreturn skb;\r\n}\r\nstatic int\r\nkalmia_rx_fixup(struct usbnet *dev, struct sk_buff *skb)\r\n{\r\nstatic const u8 HEADER_END_OF_USB_PACKET[] =\r\n{ 0x57, 0x5a, 0x00, 0x00, 0x08, 0x00 };\r\nstatic const u8 EXPECTED_UNKNOWN_HEADER_1[] =\r\n{ 0x57, 0x43, 0x1e, 0x00, 0x15, 0x02 };\r\nstatic const u8 EXPECTED_UNKNOWN_HEADER_2[] =\r\n{ 0x57, 0x50, 0x0e, 0x00, 0x00, 0x00 };\r\nint i = 0;\r\nif (skb->len < KALMIA_HEADER_LENGTH)\r\nreturn 0;\r\ndo {\r\nstruct sk_buff *skb2 = NULL;\r\nu8 *header_start;\r\nu16 usb_packet_length, ether_packet_length;\r\nint is_last;\r\nheader_start = skb->data;\r\nif (unlikely(header_start[0] != 0x57 || header_start[1] != 0x44)) {\r\nif (!memcmp(header_start, EXPECTED_UNKNOWN_HEADER_1,\r\nsizeof(EXPECTED_UNKNOWN_HEADER_1)) || !memcmp(\r\nheader_start, EXPECTED_UNKNOWN_HEADER_2,\r\nsizeof(EXPECTED_UNKNOWN_HEADER_2))) {\r\nnetdev_dbg(dev->net,\r\n"Received expected unknown frame header: %6phC. Package length: %i\n",\r\nheader_start,\r\nskb->len - KALMIA_HEADER_LENGTH);\r\n}\r\nelse {\r\nnetdev_err(dev->net,\r\n"Received unknown frame header: %6phC. Package length: %i\n",\r\nheader_start,\r\nskb->len - KALMIA_HEADER_LENGTH);\r\nreturn 0;\r\n}\r\n}\r\nelse\r\nnetdev_dbg(dev->net,\r\n"Received header: %6phC. Package length: %i\n",\r\nheader_start, skb->len - KALMIA_HEADER_LENGTH);\r\nusb_packet_length = skb->len - (2 * KALMIA_HEADER_LENGTH);\r\nether_packet_length = get_unaligned_le16(&header_start[2]);\r\nskb_pull(skb, KALMIA_HEADER_LENGTH);\r\nif (usb_packet_length < ether_packet_length) {\r\nether_packet_length = usb_packet_length\r\n+ KALMIA_HEADER_LENGTH;\r\nis_last = true;\r\n}\r\nelse {\r\nnetdev_dbg(dev->net, "Correct package length #%i", i\r\n+ 1);\r\nis_last = (memcmp(skb->data + ether_packet_length,\r\nHEADER_END_OF_USB_PACKET,\r\nsizeof(HEADER_END_OF_USB_PACKET)) == 0);\r\nif (!is_last) {\r\nheader_start = skb->data + ether_packet_length;\r\nnetdev_dbg(dev->net,\r\n"End header: %6phC. Package length: %i\n",\r\nheader_start,\r\nskb->len - KALMIA_HEADER_LENGTH);\r\n}\r\n}\r\nif (is_last) {\r\nskb2 = skb;\r\n}\r\nelse {\r\nskb2 = skb_clone(skb, GFP_ATOMIC);\r\nif (unlikely(!skb2))\r\nreturn 0;\r\n}\r\nskb_trim(skb2, ether_packet_length);\r\nif (is_last) {\r\nreturn 1;\r\n}\r\nelse {\r\nusbnet_skb_return(dev, skb2);\r\nskb_pull(skb, ether_packet_length);\r\n}\r\ni++;\r\n}\r\nwhile (skb->len);\r\nreturn 1;\r\n}
