static void emac_reg_write_all(void __iomem *base,\r\nconst struct emac_reg_write *itr, size_t size)\r\n{\r\nsize_t i;\r\nfor (i = 0; i < size; ++itr, ++i)\r\nwritel(itr->val, base + itr->offset);\r\n}\r\nint emac_sgmii_init_qdf2432(struct emac_adapter *adpt)\r\n{\r\nstruct emac_sgmii *phy = &adpt->phy;\r\nvoid __iomem *phy_regs = phy->base;\r\nvoid __iomem *laned = phy->digital;\r\nunsigned int i;\r\nu32 lnstatus;\r\nemac_reg_write_all(phy->base, physical_coding_sublayer_programming,\r\nARRAY_SIZE(physical_coding_sublayer_programming));\r\nemac_reg_write_all(phy->digital, sgmii_laned, ARRAY_SIZE(sgmii_laned));\r\nwritel(0, phy_regs + EMAC_SGMII_PHY_RESET_CTRL);\r\nwritel(1, laned + SGMII_LN_RSM_START);\r\nfor (i = 0; i < SERDES_START_WAIT_TIMES; i++) {\r\nlnstatus = readl(phy_regs + SGMII_PHY_LN_LANE_STATUS);\r\nif (lnstatus & BIT(1))\r\nbreak;\r\nusleep_range(100, 200);\r\n}\r\nif (i == SERDES_START_WAIT_TIMES) {\r\nnetdev_err(adpt->netdev, "SGMII failed to start\n");\r\nreturn -EIO;\r\n}\r\nwritel(0, phy_regs + SGMII_PHY_LN_BIST_GEN0);\r\nwritel(0, phy_regs + SGMII_PHY_LN_BIST_GEN2);\r\nwritel(0, phy_regs + SGMII_PHY_LN_CDR_CTRL1);\r\nwritel(0, phy_regs + EMAC_SGMII_PHY_INTERRUPT_MASK);\r\nreturn 0;\r\n}
