static ssize_t _srom_read(int hv_devhdl, void *buf,\r\nloff_t off, size_t count)\r\n{\r\nint retval, retries = SROM_MAX_WAIT_TRY_TIMES;\r\nfor (;;) {\r\nretval = hv_dev_pread(hv_devhdl, 0, (HV_VirtAddr)buf,\r\ncount, off);\r\nif (retval >= 0)\r\nreturn retval;\r\nif (retval == HV_EAGAIN)\r\ncontinue;\r\nif (retval == HV_EBUSY && --retries > 0) {\r\nmsleep(SROM_WAIT_TRY_INTERVAL);\r\ncontinue;\r\n}\r\npr_err("_srom_read: error %d\n", retval);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic ssize_t _srom_write(int hv_devhdl, const void *buf,\r\nloff_t off, size_t count)\r\n{\r\nint retval, retries = SROM_MAX_WAIT_TRY_TIMES;\r\nfor (;;) {\r\nretval = hv_dev_pwrite(hv_devhdl, 0, (HV_VirtAddr)buf,\r\ncount, off);\r\nif (retval >= 0)\r\nreturn retval;\r\nif (retval == HV_EAGAIN)\r\ncontinue;\r\nif (retval == HV_EBUSY && --retries > 0) {\r\nmsleep(SROM_WAIT_TRY_INTERVAL);\r\ncontinue;\r\n}\r\npr_err("_srom_write: error %d\n", retval);\r\nreturn -EIO;\r\n}\r\n}\r\nstatic int srom_open(struct inode *inode, struct file *filp)\r\n{\r\nfilp->private_data = &srom_devices[iminor(inode)];\r\nreturn 0;\r\n}\r\nstatic int srom_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct srom_dev *srom = filp->private_data;\r\nchar dummy;\r\nmutex_lock(&srom->lock);\r\nif (srom->hv_devhdl >= 0)\r\n_srom_write(srom->hv_devhdl, &dummy, SROM_FLUSH_OFF, 1);\r\nmutex_unlock(&srom->lock);\r\nfilp->private_data = NULL;\r\nreturn 0;\r\n}\r\nstatic ssize_t srom_read(struct file *filp, char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nint retval = 0;\r\nvoid *kernbuf;\r\nstruct srom_dev *srom = filp->private_data;\r\nkernbuf = kmalloc(SROM_CHUNK_SIZE, GFP_KERNEL);\r\nif (!kernbuf)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&srom->lock)) {\r\nretval = -ERESTARTSYS;\r\nkfree(kernbuf);\r\nreturn retval;\r\n}\r\nwhile (count) {\r\nint hv_retval;\r\nint bytes_this_pass = min(count, SROM_CHUNK_SIZE);\r\nhv_retval = _srom_read(srom->hv_devhdl, kernbuf,\r\n*f_pos, bytes_this_pass);\r\nif (hv_retval <= 0) {\r\nif (retval == 0)\r\nretval = hv_retval;\r\nbreak;\r\n}\r\nif (copy_to_user(buf, kernbuf, hv_retval) != 0) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nretval += hv_retval;\r\n*f_pos += hv_retval;\r\nbuf += hv_retval;\r\ncount -= hv_retval;\r\n}\r\nmutex_unlock(&srom->lock);\r\nkfree(kernbuf);\r\nreturn retval;\r\n}\r\nstatic ssize_t srom_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *f_pos)\r\n{\r\nint retval = 0;\r\nvoid *kernbuf;\r\nstruct srom_dev *srom = filp->private_data;\r\nkernbuf = kmalloc(SROM_CHUNK_SIZE, GFP_KERNEL);\r\nif (!kernbuf)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&srom->lock)) {\r\nretval = -ERESTARTSYS;\r\nkfree(kernbuf);\r\nreturn retval;\r\n}\r\nwhile (count) {\r\nint hv_retval;\r\nint bytes_this_pass = min(count, SROM_CHUNK_SIZE);\r\nif (copy_from_user(kernbuf, buf, bytes_this_pass) != 0) {\r\nretval = -EFAULT;\r\nbreak;\r\n}\r\nhv_retval = _srom_write(srom->hv_devhdl, kernbuf,\r\n*f_pos, bytes_this_pass);\r\nif (hv_retval <= 0) {\r\nif (retval == 0)\r\nretval = hv_retval;\r\nbreak;\r\n}\r\nretval += hv_retval;\r\n*f_pos += hv_retval;\r\nbuf += hv_retval;\r\ncount -= hv_retval;\r\n}\r\nmutex_unlock(&srom->lock);\r\nkfree(kernbuf);\r\nreturn retval;\r\n}\r\nloff_t srom_llseek(struct file *file, loff_t offset, int origin)\r\n{\r\nstruct srom_dev *srom = file->private_data;\r\nreturn fixed_size_llseek(file, offset, origin, srom->total_size);\r\n}\r\nstatic ssize_t total_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct srom_dev *srom = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", srom->total_size);\r\n}\r\nstatic ssize_t sector_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct srom_dev *srom = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", srom->sector_size);\r\n}\r\nstatic ssize_t page_size_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct srom_dev *srom = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", srom->page_size);\r\n}\r\nstatic char *srom_devnode(struct device *dev, umode_t *mode)\r\n{\r\nif (mode)\r\n*mode = 0644;\r\nreturn kasprintf(GFP_KERNEL, "srom/%s", dev_name(dev));\r\n}\r\nstatic int srom_setup_minor(struct srom_dev *srom, int devhdl)\r\n{\r\nsrom->hv_devhdl = devhdl;\r\nmutex_init(&srom->lock);\r\nif (_srom_read(devhdl, &srom->total_size,\r\nSROM_TOTAL_SIZE_OFF, sizeof(srom->total_size)) < 0)\r\nreturn -EIO;\r\nif (_srom_read(devhdl, &srom->sector_size,\r\nSROM_SECTOR_SIZE_OFF, sizeof(srom->sector_size)) < 0)\r\nreturn -EIO;\r\nif (_srom_read(devhdl, &srom->page_size,\r\nSROM_PAGE_SIZE_OFF, sizeof(srom->page_size)) < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int srom_init(void)\r\n{\r\nint result, i;\r\ndev_t dev = MKDEV(srom_major, 0);\r\nsrom_devices = kmalloc(4 * sizeof(struct srom_dev), GFP_KERNEL);\r\nfor (i = 0; ; i++) {\r\nint devhdl;\r\nchar buf[20];\r\nstruct srom_dev *new_srom_devices =\r\nkrealloc(srom_devices, (i+1) * sizeof(struct srom_dev),\r\nGFP_KERNEL);\r\nif (!new_srom_devices) {\r\nresult = -ENOMEM;\r\ngoto fail_mem;\r\n}\r\nsrom_devices = new_srom_devices;\r\nsprintf(buf, "srom/0/%d", i);\r\ndevhdl = hv_dev_open((HV_VirtAddr)buf, 0);\r\nif (devhdl < 0) {\r\nif (devhdl != HV_ENODEV)\r\npr_notice("srom/%d: hv_dev_open failed: %d.\n",\r\ni, devhdl);\r\nbreak;\r\n}\r\nresult = srom_setup_minor(&srom_devices[i], devhdl);\r\nif (result != 0)\r\ngoto fail_mem;\r\n}\r\nsrom_devs = i;\r\nif (srom_devs == 0) {\r\nresult = -ENODEV;\r\ngoto fail_mem;\r\n}\r\nif (srom_major)\r\nresult = register_chrdev_region(dev, srom_devs, "srom");\r\nelse {\r\nresult = alloc_chrdev_region(&dev, 0, srom_devs, "srom");\r\nsrom_major = MAJOR(dev);\r\n}\r\nif (result < 0)\r\ngoto fail_mem;\r\ncdev_init(&srom_cdev, &srom_fops);\r\nsrom_cdev.owner = THIS_MODULE;\r\nsrom_cdev.ops = &srom_fops;\r\nresult = cdev_add(&srom_cdev, dev, srom_devs);\r\nif (result < 0)\r\ngoto fail_chrdev;\r\nsrom_parent = platform_device_register_simple("srom", -1, NULL, 0);\r\nif (IS_ERR(srom_parent)) {\r\nresult = PTR_ERR(srom_parent);\r\ngoto fail_pdev;\r\n}\r\nsrom_class = class_create(THIS_MODULE, "srom");\r\nif (IS_ERR(srom_class)) {\r\nresult = PTR_ERR(srom_class);\r\ngoto fail_cdev;\r\n}\r\nsrom_class->dev_groups = srom_dev_groups;\r\nsrom_class->devnode = srom_devnode;\r\nfor (i = 0; i < srom_devs; i++) {\r\nstruct device *dev =\r\ndevice_create(srom_class, &srom_parent->dev,\r\nMKDEV(srom_major, i), srom_devices + i,\r\n"%d", i);\r\nresult = PTR_ERR_OR_ZERO(dev);\r\nif (result < 0)\r\ngoto fail_class;\r\n}\r\nreturn 0;\r\nfail_class:\r\nfor (i = 0; i < srom_devs; i++)\r\ndevice_destroy(srom_class, MKDEV(srom_major, i));\r\nclass_destroy(srom_class);\r\nfail_cdev:\r\nplatform_device_unregister(srom_parent);\r\nfail_pdev:\r\ncdev_del(&srom_cdev);\r\nfail_chrdev:\r\nunregister_chrdev_region(dev, srom_devs);\r\nfail_mem:\r\nkfree(srom_devices);\r\nreturn result;\r\n}\r\nstatic void srom_cleanup(void)\r\n{\r\nint i;\r\nfor (i = 0; i < srom_devs; i++)\r\ndevice_destroy(srom_class, MKDEV(srom_major, i));\r\nclass_destroy(srom_class);\r\ncdev_del(&srom_cdev);\r\nplatform_device_unregister(srom_parent);\r\nunregister_chrdev_region(MKDEV(srom_major, 0), srom_devs);\r\nkfree(srom_devices);\r\n}
