static int phm_run_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_runtime_table_header *rt_table,\r\nvoid *input,\r\nvoid *output,\r\nvoid *temp_storage)\r\n{\r\nint result = 0;\r\nphm_table_function *function;\r\nif (rt_table->function_list == NULL) {\r\npr_debug("this function not implement!\n");\r\nreturn 0;\r\n}\r\nfor (function = rt_table->function_list; NULL != *function; function++) {\r\nint tmp = (*function)(hwmgr, input, output, temp_storage, result);\r\nif (tmp == PP_Result_TableImmediateExit)\r\nbreak;\r\nif (tmp) {\r\nif (0 == result)\r\nresult = tmp;\r\nif (rt_table->exit_error)\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nint phm_dispatch_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_runtime_table_header *rt_table,\r\nvoid *input, void *output)\r\n{\r\nint result;\r\nvoid *temp_storage;\r\nif (hwmgr == NULL || rt_table == NULL) {\r\npr_err("Invalid Parameter!\n");\r\nreturn -EINVAL;\r\n}\r\nif (0 != rt_table->storage_size) {\r\ntemp_storage = kzalloc(rt_table->storage_size, GFP_KERNEL);\r\nif (temp_storage == NULL) {\r\npr_err("Could not allocate table temporary storage\n");\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\ntemp_storage = NULL;\r\n}\r\nresult = phm_run_table(hwmgr, rt_table, input, output, temp_storage);\r\nkfree(temp_storage);\r\nreturn result;\r\n}\r\nint phm_construct_table(struct pp_hwmgr *hwmgr,\r\nconst struct phm_master_table_header *master_table,\r\nstruct phm_runtime_table_header *rt_table)\r\n{\r\nuint32_t function_count = 0;\r\nconst struct phm_master_table_item *table_item;\r\nuint32_t size;\r\nphm_table_function *run_time_list;\r\nphm_table_function *rtf;\r\nif (hwmgr == NULL || master_table == NULL || rt_table == NULL) {\r\npr_err("Invalid Parameter!\n");\r\nreturn -EINVAL;\r\n}\r\nfor (table_item = master_table->master_list;\r\nNULL != table_item->tableFunction; table_item++) {\r\nif ((NULL == table_item->isFunctionNeededInRuntimeTable) ||\r\n(table_item->isFunctionNeededInRuntimeTable(hwmgr)))\r\nfunction_count++;\r\n}\r\nsize = (function_count + 1) * sizeof(phm_table_function);\r\nrun_time_list = kzalloc(size, GFP_KERNEL);\r\nif (NULL == run_time_list)\r\nreturn -ENOMEM;\r\nrtf = run_time_list;\r\nfor (table_item = master_table->master_list;\r\nNULL != table_item->tableFunction; table_item++) {\r\nif ((rtf - run_time_list) > function_count) {\r\npr_err("Check function results have changed\n");\r\nkfree(run_time_list);\r\nreturn -EINVAL;\r\n}\r\nif ((NULL == table_item->isFunctionNeededInRuntimeTable) ||\r\n(table_item->isFunctionNeededInRuntimeTable(hwmgr))) {\r\n*(rtf++) = table_item->tableFunction;\r\n}\r\n}\r\nif ((rtf - run_time_list) > function_count) {\r\npr_err("Check function results have changed\n");\r\nkfree(run_time_list);\r\nreturn -EINVAL;\r\n}\r\n*rtf = NULL;\r\nrt_table->function_list = run_time_list;\r\nrt_table->exit_error = (0 != (master_table->flags & PHM_MasterTableFlag_ExitOnError));\r\nrt_table->storage_size = master_table->storage_size;\r\nreturn 0;\r\n}\r\nint phm_destroy_table(struct pp_hwmgr *hwmgr,\r\nstruct phm_runtime_table_header *rt_table)\r\n{\r\nif (hwmgr == NULL || rt_table == NULL) {\r\npr_err("Invalid Parameter\n");\r\nreturn -EINVAL;\r\n}\r\nif (NULL == rt_table->function_list)\r\nreturn 0;\r\nkfree(rt_table->function_list);\r\nrt_table->function_list = NULL;\r\nrt_table->storage_size = 0;\r\nrt_table->exit_error = false;\r\nreturn 0;\r\n}
