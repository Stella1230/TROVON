static u32 rsi_sdio_set_cmd52_arg(bool rw,\r\nu8 func,\r\nu8 raw,\r\nu32 address,\r\nu8 writedata)\r\n{\r\nreturn ((rw & 1) << 31) | ((func & 0x7) << 28) |\r\n((raw & 1) << 27) | (1 << 26) |\r\n((address & 0x1FFFF) << 9) | (1 << 8) |\r\n(writedata & 0xFF);\r\n}\r\nstatic int rsi_cmd52writebyte(struct mmc_card *card,\r\nu32 address,\r\nu8 byte)\r\n{\r\nstruct mmc_command io_cmd;\r\nu32 arg;\r\nmemset(&io_cmd, 0, sizeof(io_cmd));\r\narg = rsi_sdio_set_cmd52_arg(1, 0, 0, address, byte);\r\nio_cmd.opcode = SD_IO_RW_DIRECT;\r\nio_cmd.arg = arg;\r\nio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\r\nreturn mmc_wait_for_cmd(card->host, &io_cmd, 0);\r\n}\r\nstatic int rsi_cmd52readbyte(struct mmc_card *card,\r\nu32 address,\r\nu8 *byte)\r\n{\r\nstruct mmc_command io_cmd;\r\nu32 arg;\r\nint err;\r\nmemset(&io_cmd, 0, sizeof(io_cmd));\r\narg = rsi_sdio_set_cmd52_arg(0, 0, 0, address, 0);\r\nio_cmd.opcode = SD_IO_RW_DIRECT;\r\nio_cmd.arg = arg;\r\nio_cmd.flags = MMC_RSP_R5 | MMC_CMD_AC;\r\nerr = mmc_wait_for_cmd(card->host, &io_cmd, 0);\r\nif ((!err) && (byte))\r\n*byte = io_cmd.resp[0] & 0xFF;\r\nreturn err;\r\n}\r\nstatic int rsi_issue_sdiocommand(struct sdio_func *func,\r\nu32 opcode,\r\nu32 arg,\r\nu32 flags,\r\nu32 *resp)\r\n{\r\nstruct mmc_command cmd;\r\nstruct mmc_host *host;\r\nint err;\r\nhost = func->card->host;\r\nmemset(&cmd, 0, sizeof(struct mmc_command));\r\ncmd.opcode = opcode;\r\ncmd.arg = arg;\r\ncmd.flags = flags;\r\nerr = mmc_wait_for_cmd(host, &cmd, 3);\r\nif ((!err) && (resp))\r\n*resp = cmd.resp[0];\r\nreturn err;\r\n}\r\nstatic void rsi_handle_interrupt(struct sdio_func *function)\r\n{\r\nstruct rsi_hw *adapter = sdio_get_drvdata(function);\r\nsdio_release_host(function);\r\nrsi_interrupt_handler(adapter);\r\nsdio_claim_host(function);\r\n}\r\nstatic void rsi_reset_card(struct sdio_func *pfunction)\r\n{\r\nint ret = 0;\r\nint err;\r\nstruct mmc_card *card = pfunction->card;\r\nstruct mmc_host *host = card->host;\r\ns32 bit = (fls(host->ocr_avail) - 1);\r\nu8 cmd52_resp;\r\nu32 clock, resp, i;\r\nu16 rca;\r\nret = rsi_cmd52writebyte(pfunction->card,\r\nSDIO_CCCR_ABORT,\r\n(1 << 3));\r\nif (ret != -ETIMEDOUT)\r\nrsi_dbg(ERR_ZONE, "%s: Reset failed : %d\n", __func__, ret);\r\nmsleep(20);\r\nhost->ios.vdd = bit;\r\nhost->ios.chip_select = MMC_CS_DONTCARE;\r\nhost->ios.bus_mode = MMC_BUSMODE_OPENDRAIN;\r\nhost->ios.power_mode = MMC_POWER_UP;\r\nhost->ios.bus_width = MMC_BUS_WIDTH_1;\r\nhost->ios.timing = MMC_TIMING_LEGACY;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(20);\r\nhost->ios.clock = host->f_min;\r\nhost->ios.power_mode = MMC_POWER_ON;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(20);\r\nhost->ios.chip_select = MMC_CS_HIGH;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(20);\r\nerr = rsi_issue_sdiocommand(pfunction,\r\nMMC_GO_IDLE_STATE,\r\n0,\r\n(MMC_RSP_NONE | MMC_CMD_BC),\r\nNULL);\r\nhost->ios.chip_select = MMC_CS_DONTCARE;\r\nhost->ops->set_ios(host, &host->ios);\r\nmsleep(20);\r\nhost->use_spi_crc = 0;\r\nif (err)\r\nrsi_dbg(ERR_ZONE, "%s: CMD0 failed : %d\n", __func__, err);\r\nif (!host->ocr_avail) {\r\nerr = rsi_issue_sdiocommand(pfunction,\r\nSD_IO_SEND_OP_COND,\r\n0,\r\n(MMC_RSP_R4 | MMC_CMD_BCR),\r\n&resp);\r\nif (err)\r\nrsi_dbg(ERR_ZONE, "%s: CMD5 failed : %d\n",\r\n__func__, err);\r\nhost->ocr_avail = resp;\r\n}\r\nfor (i = 0; i < 100; i++) {\r\nerr = rsi_issue_sdiocommand(pfunction,\r\nSD_IO_SEND_OP_COND,\r\nhost->ocr_avail,\r\n(MMC_RSP_R4 | MMC_CMD_BCR),\r\n&resp);\r\nif (err) {\r\nrsi_dbg(ERR_ZONE, "%s: CMD5 failed : %d\n",\r\n__func__, err);\r\nbreak;\r\n}\r\nif (resp & MMC_CARD_BUSY)\r\nbreak;\r\nmsleep(20);\r\n}\r\nif ((i == 100) || (err)) {\r\nrsi_dbg(ERR_ZONE, "%s: card in not ready : %d %d\n",\r\n__func__, i, err);\r\nreturn;\r\n}\r\nerr = rsi_issue_sdiocommand(pfunction,\r\nSD_SEND_RELATIVE_ADDR,\r\n0,\r\n(MMC_RSP_R6 | MMC_CMD_BCR),\r\n&resp);\r\nif (err) {\r\nrsi_dbg(ERR_ZONE, "%s: CMD3 failed : %d\n", __func__, err);\r\nreturn;\r\n}\r\nrca = resp >> 16;\r\nhost->ios.bus_mode = MMC_BUSMODE_PUSHPULL;\r\nhost->ops->set_ios(host, &host->ios);\r\nerr = rsi_issue_sdiocommand(pfunction,\r\nMMC_SELECT_CARD,\r\n(rca << 16),\r\n(MMC_RSP_R1 | MMC_CMD_AC),\r\nNULL);\r\nif (err) {\r\nrsi_dbg(ERR_ZONE, "%s: CMD7 failed : %d\n", __func__, err);\r\nreturn;\r\n}\r\nif (card->host->caps & MMC_CAP_SD_HIGHSPEED) {\r\nrsi_dbg(ERR_ZONE, "%s: Set high speed mode\n", __func__);\r\nerr = rsi_cmd52readbyte(card, SDIO_CCCR_SPEED, &cmd52_resp);\r\nif (err) {\r\nrsi_dbg(ERR_ZONE, "%s: CCCR speed reg read failed: %d\n",\r\n__func__, err);\r\n} else {\r\nerr = rsi_cmd52writebyte(card,\r\nSDIO_CCCR_SPEED,\r\n(cmd52_resp | SDIO_SPEED_EHS));\r\nif (err) {\r\nrsi_dbg(ERR_ZONE,\r\n"%s: CCR speed regwrite failed %d\n",\r\n__func__, err);\r\nreturn;\r\n}\r\nhost->ios.timing = MMC_TIMING_SD_HS;\r\nhost->ops->set_ios(host, &host->ios);\r\n}\r\n}\r\nif (mmc_card_hs(card))\r\nclock = 50000000;\r\nelse\r\nclock = card->cis.max_dtr;\r\nif (clock > host->f_max)\r\nclock = host->f_max;\r\nhost->ios.clock = clock;\r\nhost->ops->set_ios(host, &host->ios);\r\nif (card->host->caps & MMC_CAP_4_BIT_DATA) {\r\nerr = rsi_cmd52writebyte(card,\r\nSDIO_CCCR_IF,\r\n(SDIO_BUS_CD_DISABLE |\r\nSDIO_BUS_WIDTH_4BIT));\r\nif (err) {\r\nrsi_dbg(ERR_ZONE, "%s: Set bus mode failed : %d\n",\r\n__func__, err);\r\nreturn;\r\n}\r\nhost->ios.bus_width = MMC_BUS_WIDTH_4;\r\nhost->ops->set_ios(host, &host->ios);\r\n}\r\n}\r\nstatic void rsi_setclock(struct rsi_hw *adapter, u32 freq)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nstruct mmc_host *host = dev->pfunction->card->host;\r\nu32 clock;\r\nclock = freq * 1000;\r\nif (clock > host->f_max)\r\nclock = host->f_max;\r\nhost->ios.clock = clock;\r\nhost->ops->set_ios(host, &host->ios);\r\n}\r\nstatic int rsi_setblocklength(struct rsi_hw *adapter, u32 length)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nint status;\r\nrsi_dbg(INIT_ZONE, "%s: Setting the block length\n", __func__);\r\nstatus = sdio_set_block_size(dev->pfunction, length);\r\ndev->pfunction->max_blksize = 256;\r\nrsi_dbg(INFO_ZONE,\r\n"%s: Operational blk length is %d\n", __func__, length);\r\nreturn status;\r\n}\r\nstatic int rsi_setupcard(struct rsi_hw *adapter)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nint status = 0;\r\nrsi_setclock(adapter, 50000);\r\ndev->tx_blk_size = 256;\r\nstatus = rsi_setblocklength(adapter, dev->tx_blk_size);\r\nif (status)\r\nrsi_dbg(ERR_ZONE,\r\n"%s: Unable to set block length\n", __func__);\r\nreturn status;\r\n}\r\nint rsi_sdio_read_register(struct rsi_hw *adapter,\r\nu32 addr,\r\nu8 *data)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu8 fun_num = 0;\r\nint status;\r\nsdio_claim_host(dev->pfunction);\r\nif (fun_num == 0)\r\n*data = sdio_f0_readb(dev->pfunction, addr, &status);\r\nelse\r\n*data = sdio_readb(dev->pfunction, addr, &status);\r\nsdio_release_host(dev->pfunction);\r\nreturn status;\r\n}\r\nint rsi_sdio_write_register(struct rsi_hw *adapter,\r\nu8 function,\r\nu32 addr,\r\nu8 *data)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nint status = 0;\r\nsdio_claim_host(dev->pfunction);\r\nif (function == 0)\r\nsdio_f0_writeb(dev->pfunction, *data, addr, &status);\r\nelse\r\nsdio_writeb(dev->pfunction, *data, addr, &status);\r\nsdio_release_host(dev->pfunction);\r\nreturn status;\r\n}\r\nvoid rsi_sdio_ack_intr(struct rsi_hw *adapter, u8 int_bit)\r\n{\r\nint status;\r\nstatus = rsi_sdio_write_register(adapter,\r\n1,\r\n(SDIO_FUN1_INTR_CLR_REG |\r\nRSI_SD_REQUEST_MASTER),\r\n&int_bit);\r\nif (status)\r\nrsi_dbg(ERR_ZONE, "%s: unable to send ack\n", __func__);\r\n}\r\nstatic int rsi_sdio_read_register_multiple(struct rsi_hw *adapter,\r\nu32 addr,\r\nu32 count,\r\nu8 *data)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu32 status;\r\nsdio_claim_host(dev->pfunction);\r\nstatus = sdio_readsb(dev->pfunction, data, addr, count);\r\nsdio_release_host(dev->pfunction);\r\nif (status != 0)\r\nrsi_dbg(ERR_ZONE, "%s: Synch Cmd53 read failed\n", __func__);\r\nreturn status;\r\n}\r\nint rsi_sdio_write_register_multiple(struct rsi_hw *adapter,\r\nu32 addr,\r\nu8 *data,\r\nu32 count)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nint status;\r\nif (dev->write_fail > 1) {\r\nrsi_dbg(ERR_ZONE, "%s: Stopping card writes\n", __func__);\r\nreturn 0;\r\n} else if (dev->write_fail == 1) {\r\nrsi_dbg(ERR_ZONE, "%s: Continue card writes\n", __func__);\r\ndev->write_fail++;\r\n}\r\nsdio_claim_host(dev->pfunction);\r\nstatus = sdio_writesb(dev->pfunction, addr, data, count);\r\nsdio_release_host(dev->pfunction);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE, "%s: Synch Cmd53 write failed %d\n",\r\n__func__, status);\r\ndev->write_fail = 2;\r\n} else {\r\nmemcpy(dev->prev_desc, data, FRAME_DESC_SZ);\r\n}\r\nreturn status;\r\n}\r\nstatic int rsi_sdio_host_intf_write_pkt(struct rsi_hw *adapter,\r\nu8 *pkt,\r\nu32 len)\r\n{\r\nstruct rsi_91x_sdiodev *dev =\r\n(struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\nu32 block_size = dev->tx_blk_size;\r\nu32 num_blocks, address, length;\r\nu32 queueno;\r\nint status;\r\nqueueno = ((pkt[1] >> 4) & 0xf);\r\nnum_blocks = len / block_size;\r\nif (len % block_size)\r\nnum_blocks++;\r\naddress = (num_blocks * block_size | (queueno << 12));\r\nlength = num_blocks * block_size;\r\nstatus = rsi_sdio_write_register_multiple(adapter,\r\naddress,\r\n(u8 *)pkt,\r\nlength);\r\nif (status)\r\nrsi_dbg(ERR_ZONE, "%s: Unable to write onto the card: %d\n",\r\n__func__, status);\r\nrsi_dbg(DATA_TX_ZONE, "%s: Successfully written onto card\n", __func__);\r\nreturn status;\r\n}\r\nint rsi_sdio_host_intf_read_pkt(struct rsi_hw *adapter,\r\nu8 *pkt,\r\nu32 length)\r\n{\r\nint status = -EINVAL;\r\nif (!length) {\r\nrsi_dbg(ERR_ZONE, "%s: Pkt size is zero\n", __func__);\r\nreturn status;\r\n}\r\nstatus = rsi_sdio_read_register_multiple(adapter,\r\nlength,\r\nlength,\r\n(u8 *)pkt);\r\nif (status)\r\nrsi_dbg(ERR_ZONE, "%s: Failed to read frame: %d\n", __func__,\r\nstatus);\r\nreturn status;\r\n}\r\nstatic int rsi_init_sdio_interface(struct rsi_hw *adapter,\r\nstruct sdio_func *pfunction)\r\n{\r\nstruct rsi_91x_sdiodev *rsi_91x_dev;\r\nint status = -ENOMEM;\r\nrsi_91x_dev = kzalloc(sizeof(*rsi_91x_dev), GFP_KERNEL);\r\nif (!rsi_91x_dev)\r\nreturn status;\r\nadapter->rsi_dev = rsi_91x_dev;\r\nsdio_claim_host(pfunction);\r\npfunction->enable_timeout = 100;\r\nstatus = sdio_enable_func(pfunction);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to enable interface\n", __func__);\r\nsdio_release_host(pfunction);\r\nreturn status;\r\n}\r\nrsi_dbg(INIT_ZONE, "%s: Enabled the interface\n", __func__);\r\nrsi_91x_dev->pfunction = pfunction;\r\nadapter->device = &pfunction->dev;\r\nsdio_set_drvdata(pfunction, adapter);\r\nstatus = rsi_setupcard(adapter);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to setup card\n", __func__);\r\ngoto fail;\r\n}\r\nrsi_dbg(INIT_ZONE, "%s: Setup card succesfully\n", __func__);\r\nstatus = rsi_init_sdio_slave_regs(adapter);\r\nif (status) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to init slave regs\n", __func__);\r\ngoto fail;\r\n}\r\nsdio_release_host(pfunction);\r\nadapter->host_intf_write_pkt = rsi_sdio_host_intf_write_pkt;\r\nadapter->host_intf_read_pkt = rsi_sdio_host_intf_read_pkt;\r\nadapter->determine_event_timeout = rsi_sdio_determine_event_timeout;\r\nadapter->check_hw_queue_status = rsi_sdio_read_buffer_status_register;\r\n#ifdef CONFIG_RSI_DEBUGFS\r\nadapter->num_debugfs_entries = MAX_DEBUGFS_ENTRIES;\r\n#endif\r\nreturn status;\r\nfail:\r\nsdio_disable_func(pfunction);\r\nsdio_release_host(pfunction);\r\nreturn status;\r\n}\r\nstatic int rsi_probe(struct sdio_func *pfunction,\r\nconst struct sdio_device_id *id)\r\n{\r\nstruct rsi_hw *adapter;\r\nrsi_dbg(INIT_ZONE, "%s: Init function called\n", __func__);\r\nadapter = rsi_91x_init();\r\nif (!adapter) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to init os intf ops\n",\r\n__func__);\r\nreturn 1;\r\n}\r\nif (rsi_init_sdio_interface(adapter, pfunction)) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to init sdio interface\n",\r\n__func__);\r\ngoto fail;\r\n}\r\nif (rsi_sdio_device_init(adapter->priv)) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed in device init\n", __func__);\r\nsdio_claim_host(pfunction);\r\nsdio_disable_func(pfunction);\r\nsdio_release_host(pfunction);\r\ngoto fail;\r\n}\r\nsdio_claim_host(pfunction);\r\nif (sdio_claim_irq(pfunction, rsi_handle_interrupt)) {\r\nrsi_dbg(ERR_ZONE, "%s: Failed to request IRQ\n", __func__);\r\nsdio_release_host(pfunction);\r\ngoto fail;\r\n}\r\nsdio_release_host(pfunction);\r\nrsi_dbg(INIT_ZONE, "%s: Registered Interrupt handler\n", __func__);\r\nreturn 0;\r\nfail:\r\nrsi_91x_deinit(adapter);\r\nrsi_dbg(ERR_ZONE, "%s: Failed in probe...Exiting\n", __func__);\r\nreturn 1;\r\n}\r\nstatic void rsi_disconnect(struct sdio_func *pfunction)\r\n{\r\nstruct rsi_hw *adapter = sdio_get_drvdata(pfunction);\r\nstruct rsi_91x_sdiodev *dev;\r\nif (!adapter)\r\nreturn;\r\ndev = (struct rsi_91x_sdiodev *)adapter->rsi_dev;\r\ndev->write_fail = 2;\r\nrsi_mac80211_detach(adapter);\r\nsdio_claim_host(pfunction);\r\nsdio_release_irq(pfunction);\r\nsdio_disable_func(pfunction);\r\nrsi_91x_deinit(adapter);\r\nrsi_reset_card(pfunction);\r\nsdio_release_host(pfunction);\r\n}\r\nstatic int rsi_suspend(struct device *dev)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int rsi_resume(struct device *dev)\r\n{\r\nreturn -ENOSYS;\r\n}\r\nstatic int rsi_module_init(void)\r\n{\r\nint ret;\r\nret = sdio_register_driver(&rsi_driver);\r\nrsi_dbg(INIT_ZONE, "%s: Registering driver\n", __func__);\r\nreturn ret;\r\n}\r\nstatic void rsi_module_exit(void)\r\n{\r\nsdio_unregister_driver(&rsi_driver);\r\nrsi_dbg(INFO_ZONE, "%s: Unregistering driver\n", __func__);\r\n}
