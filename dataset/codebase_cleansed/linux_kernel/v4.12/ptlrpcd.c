void ptlrpcd_wake(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_request_set *set = req->rq_set;\r\nwake_up(&set->set_waitq);\r\n}\r\nstatic struct ptlrpcd_ctl *\r\nptlrpcd_select_pc(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpcd *pd;\r\nint cpt;\r\nint idx;\r\nif (req && req->rq_send_state != LUSTRE_IMP_FULL)\r\nreturn &ptlrpcd_rcv;\r\ncpt = cfs_cpt_current(cfs_cpt_table, 1);\r\nif (!ptlrpcds_cpt_idx)\r\nidx = cpt;\r\nelse\r\nidx = ptlrpcds_cpt_idx[cpt];\r\npd = ptlrpcds[idx];\r\nidx = pd->pd_cursor;\r\nif (++idx == pd->pd_nthreads)\r\nidx = 0;\r\npd->pd_cursor = idx;\r\nreturn &pd->pd_threads[idx];\r\n}\r\nstatic int ptlrpcd_steal_rqset(struct ptlrpc_request_set *des,\r\nstruct ptlrpc_request_set *src)\r\n{\r\nstruct list_head *tmp, *pos;\r\nstruct ptlrpc_request *req;\r\nint rc = 0;\r\nspin_lock(&src->set_new_req_lock);\r\nif (likely(!list_empty(&src->set_new_requests))) {\r\nlist_for_each_safe(pos, tmp, &src->set_new_requests) {\r\nreq = list_entry(pos, struct ptlrpc_request,\r\nrq_set_chain);\r\nreq->rq_set = des;\r\n}\r\nlist_splice_init(&src->set_new_requests, &des->set_requests);\r\nrc = atomic_read(&src->set_new_count);\r\natomic_add(rc, &des->set_remaining);\r\natomic_set(&src->set_new_count, 0);\r\n}\r\nspin_unlock(&src->set_new_req_lock);\r\nreturn rc;\r\n}\r\nvoid ptlrpcd_add_req(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpcd_ctl *pc;\r\nif (req->rq_reqmsg)\r\nlustre_msg_set_jobid(req->rq_reqmsg, NULL);\r\nspin_lock(&req->rq_lock);\r\nif (req->rq_invalid_rqset) {\r\nstruct l_wait_info lwi = LWI_TIMEOUT(cfs_time_seconds(5),\r\nback_to_sleep, NULL);\r\nreq->rq_invalid_rqset = 0;\r\nspin_unlock(&req->rq_lock);\r\nl_wait_event(req->rq_set_waitq, !req->rq_set, &lwi);\r\n} else if (req->rq_set) {\r\nLASSERT(req->rq_phase == RQ_PHASE_NEW);\r\nLASSERT(req->rq_send_state == LUSTRE_IMP_REPLAY);\r\natomic_inc(&req->rq_set->set_remaining);\r\nspin_unlock(&req->rq_lock);\r\nwake_up(&req->rq_set->set_waitq);\r\nreturn;\r\n} else {\r\nspin_unlock(&req->rq_lock);\r\n}\r\npc = ptlrpcd_select_pc(req);\r\nDEBUG_REQ(D_INFO, req, "add req [%p] to pc [%s:%d]",\r\nreq, pc->pc_name, pc->pc_index);\r\nptlrpc_set_add_new_req(pc, req);\r\n}\r\nstatic inline void ptlrpc_reqset_get(struct ptlrpc_request_set *set)\r\n{\r\natomic_inc(&set->set_refcount);\r\n}\r\nstatic int ptlrpcd_check(struct lu_env *env, struct ptlrpcd_ctl *pc)\r\n{\r\nstruct list_head *tmp, *pos;\r\nstruct ptlrpc_request *req;\r\nstruct ptlrpc_request_set *set = pc->pc_set;\r\nint rc = 0;\r\nint rc2;\r\nif (atomic_read(&set->set_new_count)) {\r\nspin_lock(&set->set_new_req_lock);\r\nif (likely(!list_empty(&set->set_new_requests))) {\r\nlist_splice_init(&set->set_new_requests,\r\n&set->set_requests);\r\natomic_add(atomic_read(&set->set_new_count),\r\n&set->set_remaining);\r\natomic_set(&set->set_new_count, 0);\r\nrc = 1;\r\n}\r\nspin_unlock(&set->set_new_req_lock);\r\n}\r\nrc2 = lu_env_refill(env);\r\nif (rc2 != 0) {\r\nCERROR("Failure to refill session: %d\n", rc2);\r\nreturn rc;\r\n}\r\nif (atomic_read(&set->set_remaining))\r\nrc |= ptlrpc_check_set(env, set);\r\nlist_for_each_safe(pos, tmp, &set->set_requests) {\r\nreq = list_entry(pos, struct ptlrpc_request, rq_set_chain);\r\nif (req->rq_phase != RQ_PHASE_COMPLETE)\r\nbreak;\r\nlist_del_init(&req->rq_set_chain);\r\nreq->rq_set = NULL;\r\nptlrpc_req_finished(req);\r\n}\r\nif (rc == 0) {\r\nrc = atomic_read(&set->set_new_count);\r\nif (rc == 0 && pc->pc_npartners > 0) {\r\nstruct ptlrpcd_ctl *partner;\r\nstruct ptlrpc_request_set *ps;\r\nint first = pc->pc_cursor;\r\ndo {\r\npartner = pc->pc_partners[pc->pc_cursor++];\r\nif (pc->pc_cursor >= pc->pc_npartners)\r\npc->pc_cursor = 0;\r\nif (!partner)\r\ncontinue;\r\nspin_lock(&partner->pc_lock);\r\nps = partner->pc_set;\r\nif (!ps) {\r\nspin_unlock(&partner->pc_lock);\r\ncontinue;\r\n}\r\nptlrpc_reqset_get(ps);\r\nspin_unlock(&partner->pc_lock);\r\nif (atomic_read(&ps->set_new_count)) {\r\nrc = ptlrpcd_steal_rqset(set, ps);\r\nif (rc > 0)\r\nCDEBUG(D_RPCTRACE, "transfer %d async RPCs [%d->%d]\n",\r\nrc, partner->pc_index,\r\npc->pc_index);\r\n}\r\nptlrpc_reqset_put(ps);\r\n} while (rc == 0 && pc->pc_cursor != first);\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int ptlrpcd(void *arg)\r\n{\r\nstruct ptlrpcd_ctl *pc = arg;\r\nstruct ptlrpc_request_set *set;\r\nstruct lu_context ses = { 0 };\r\nstruct lu_env env = { .le_ses = &ses };\r\nint rc = 0;\r\nint exit = 0;\r\nunshare_fs_struct();\r\nif (cfs_cpt_bind(cfs_cpt_table, pc->pc_cpt) != 0)\r\nCWARN("Failed to bind %s on CPT %d\n", pc->pc_name, pc->pc_cpt);\r\nset = ptlrpc_prep_set();\r\nif (!set) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nspin_lock(&pc->pc_lock);\r\npc->pc_set = set;\r\nspin_unlock(&pc->pc_lock);\r\nrc = lu_context_init(&env.le_ctx,\r\nLCT_CL_THREAD | LCT_REMEMBER | LCT_NOREF);\r\nif (rc == 0) {\r\nrc = lu_context_init(env.le_ses,\r\nLCT_SESSION | LCT_REMEMBER | LCT_NOREF);\r\nif (rc != 0)\r\nlu_context_fini(&env.le_ctx);\r\n}\r\nif (rc != 0)\r\ngoto failed;\r\ncomplete(&pc->pc_starting);\r\ndo {\r\nstruct l_wait_info lwi;\r\nint timeout;\r\ntimeout = ptlrpc_set_next_timeout(set);\r\nlwi = LWI_TIMEOUT(cfs_time_seconds(timeout ? timeout : 1),\r\nptlrpc_expired_set, set);\r\nlu_context_enter(&env.le_ctx);\r\nlu_context_enter(env.le_ses);\r\nl_wait_event(set->set_waitq, ptlrpcd_check(&env, pc), &lwi);\r\nlu_context_exit(&env.le_ctx);\r\nlu_context_exit(env.le_ses);\r\nif (test_bit(LIOD_STOP, &pc->pc_flags)) {\r\nif (test_bit(LIOD_FORCE, &pc->pc_flags))\r\nptlrpc_abort_set(set);\r\nexit++;\r\n}\r\n} while (exit < 2);\r\nif (!list_empty(&set->set_requests))\r\nptlrpc_set_wait(set);\r\nlu_context_fini(&env.le_ctx);\r\nlu_context_fini(env.le_ses);\r\ncomplete(&pc->pc_finishing);\r\nreturn 0;\r\nfailed:\r\npc->pc_error = rc;\r\ncomplete(&pc->pc_starting);\r\nreturn rc;\r\n}\r\nstatic void ptlrpcd_ctl_init(struct ptlrpcd_ctl *pc, int index, int cpt)\r\n{\r\npc->pc_index = index;\r\npc->pc_cpt = cpt;\r\ninit_completion(&pc->pc_starting);\r\ninit_completion(&pc->pc_finishing);\r\nspin_lock_init(&pc->pc_lock);\r\nif (index < 0) {\r\nsnprintf(pc->pc_name, sizeof(pc->pc_name), "ptlrpcd_rcv");\r\n} else {\r\nsnprintf(pc->pc_name, sizeof(pc->pc_name),\r\n"ptlrpcd_%02d_%02d", cpt, index);\r\n}\r\n}\r\nstatic int ptlrpcd_partners(struct ptlrpcd *pd, int index)\r\n{\r\nstruct ptlrpcd_ctl *pc;\r\nstruct ptlrpcd_ctl **ppc;\r\nint first;\r\nint i;\r\nint rc = 0;\r\nint size;\r\nLASSERT(index >= 0 && index < pd->pd_nthreads);\r\npc = &pd->pd_threads[index];\r\npc->pc_npartners = pd->pd_groupsize - 1;\r\nif (pc->pc_npartners <= 0)\r\ngoto out;\r\nsize = sizeof(struct ptlrpcd_ctl *) * pc->pc_npartners;\r\npc->pc_partners = kzalloc_node(size, GFP_NOFS,\r\ncfs_cpt_spread_node(cfs_cpt_table,\r\npc->pc_cpt));\r\nif (!pc->pc_partners) {\r\npc->pc_npartners = 0;\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfirst = index - index % pd->pd_groupsize;\r\nppc = pc->pc_partners;\r\nfor (i = first; i < first + pd->pd_groupsize; i++) {\r\nif (i != index)\r\n*ppc++ = &pd->pd_threads[i];\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nint ptlrpcd_start(struct ptlrpcd_ctl *pc)\r\n{\r\nstruct task_struct *task;\r\nint rc = 0;\r\nif (test_and_set_bit(LIOD_START, &pc->pc_flags)) {\r\nCWARN("Starting second thread (%s) for same pc %p\n",\r\npc->pc_name, pc);\r\nreturn 0;\r\n}\r\ntask = kthread_run(ptlrpcd, pc, "%s", pc->pc_name);\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\ngoto out_set;\r\n}\r\nwait_for_completion(&pc->pc_starting);\r\nrc = pc->pc_error;\r\nif (rc != 0)\r\ngoto out_set;\r\nreturn 0;\r\nout_set:\r\nif (pc->pc_set) {\r\nstruct ptlrpc_request_set *set = pc->pc_set;\r\nspin_lock(&pc->pc_lock);\r\npc->pc_set = NULL;\r\nspin_unlock(&pc->pc_lock);\r\nptlrpc_set_destroy(set);\r\n}\r\nclear_bit(LIOD_START, &pc->pc_flags);\r\nreturn rc;\r\n}\r\nvoid ptlrpcd_stop(struct ptlrpcd_ctl *pc, int force)\r\n{\r\nif (!test_bit(LIOD_START, &pc->pc_flags)) {\r\nCWARN("Thread for pc %p was not started\n", pc);\r\nreturn;\r\n}\r\nset_bit(LIOD_STOP, &pc->pc_flags);\r\nif (force)\r\nset_bit(LIOD_FORCE, &pc->pc_flags);\r\nwake_up(&pc->pc_set->set_waitq);\r\n}\r\nvoid ptlrpcd_free(struct ptlrpcd_ctl *pc)\r\n{\r\nstruct ptlrpc_request_set *set = pc->pc_set;\r\nif (!test_bit(LIOD_START, &pc->pc_flags)) {\r\nCWARN("Thread for pc %p was not started\n", pc);\r\ngoto out;\r\n}\r\nwait_for_completion(&pc->pc_finishing);\r\nspin_lock(&pc->pc_lock);\r\npc->pc_set = NULL;\r\nspin_unlock(&pc->pc_lock);\r\nptlrpc_set_destroy(set);\r\nclear_bit(LIOD_START, &pc->pc_flags);\r\nclear_bit(LIOD_STOP, &pc->pc_flags);\r\nclear_bit(LIOD_FORCE, &pc->pc_flags);\r\nout:\r\nif (pc->pc_npartners > 0) {\r\nLASSERT(pc->pc_partners);\r\nkfree(pc->pc_partners);\r\npc->pc_partners = NULL;\r\n}\r\npc->pc_npartners = 0;\r\npc->pc_error = 0;\r\n}\r\nstatic void ptlrpcd_fini(void)\r\n{\r\nint i;\r\nint j;\r\nif (ptlrpcds) {\r\nfor (i = 0; i < ptlrpcds_num; i++) {\r\nif (!ptlrpcds[i])\r\nbreak;\r\nfor (j = 0; j < ptlrpcds[i]->pd_nthreads; j++)\r\nptlrpcd_stop(&ptlrpcds[i]->pd_threads[j], 0);\r\nfor (j = 0; j < ptlrpcds[i]->pd_nthreads; j++)\r\nptlrpcd_free(&ptlrpcds[i]->pd_threads[j]);\r\nkfree(ptlrpcds[i]);\r\nptlrpcds[i] = NULL;\r\n}\r\nkfree(ptlrpcds);\r\n}\r\nptlrpcds_num = 0;\r\nptlrpcd_stop(&ptlrpcd_rcv, 0);\r\nptlrpcd_free(&ptlrpcd_rcv);\r\nkfree(ptlrpcds_cpt_idx);\r\nptlrpcds_cpt_idx = NULL;\r\n}\r\nstatic int ptlrpcd_init(void)\r\n{\r\nint nthreads;\r\nint groupsize;\r\nint size;\r\nint i;\r\nint j;\r\nint rc = 0;\r\nstruct cfs_cpt_table *cptable;\r\n__u32 *cpts = NULL;\r\nint ncpts;\r\nint cpt;\r\nstruct ptlrpcd *pd;\r\ncptable = cfs_cpt_table;\r\nncpts = cfs_cpt_number(cptable);\r\nif (ptlrpcd_cpts) {\r\nstruct cfs_expr_list *el;\r\nsize = ncpts * sizeof(ptlrpcds_cpt_idx[0]);\r\nptlrpcds_cpt_idx = kzalloc(size, GFP_KERNEL);\r\nif (!ptlrpcds_cpt_idx) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = cfs_expr_list_parse(ptlrpcd_cpts,\r\nstrlen(ptlrpcd_cpts),\r\n0, ncpts - 1, &el);\r\nif (rc != 0) {\r\nCERROR("ptlrpcd_cpts: invalid CPT pattern string: %s",\r\nptlrpcd_cpts);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nrc = cfs_expr_list_values(el, ncpts, &cpts);\r\ncfs_expr_list_free(el);\r\nif (rc <= 0) {\r\nCERROR("ptlrpcd_cpts: failed to parse CPT array %s: %d\n",\r\nptlrpcd_cpts, rc);\r\nif (rc == 0)\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nfor (cpt = 0; cpt < ncpts; cpt++) {\r\nfor (i = 0; i < rc; i++)\r\nif (cpts[i] == cpt)\r\nbreak;\r\nif (i >= rc)\r\ni = cpt % rc;\r\nptlrpcds_cpt_idx[cpt] = i;\r\n}\r\ncfs_expr_list_values_free(cpts, rc);\r\nncpts = rc;\r\n}\r\nptlrpcds_num = ncpts;\r\nsize = ncpts * sizeof(ptlrpcds[0]);\r\nptlrpcds = kzalloc(size, GFP_KERNEL);\r\nif (!ptlrpcds) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nif (max_ptlrpcds != 0) {\r\nCWARN("max_ptlrpcds is obsolete.\n");\r\nif (ptlrpcd_per_cpt_max == 0) {\r\nptlrpcd_per_cpt_max = max_ptlrpcds / ncpts;\r\nif (max_ptlrpcds % ncpts != 0)\r\nptlrpcd_per_cpt_max++;\r\nCWARN("Setting ptlrpcd_per_cpt_max = %d\n",\r\nptlrpcd_per_cpt_max);\r\n} else {\r\nCWARN("ptlrpd_per_cpt_max is also set!\n");\r\n}\r\n}\r\nif (ptlrpcd_bind_policy != 0) {\r\nCWARN("ptlrpcd_bind_policy is obsolete.\n");\r\nif (ptlrpcd_partner_group_size == 0) {\r\nswitch (ptlrpcd_bind_policy) {\r\ncase 1:\r\ncase 2:\r\nptlrpcd_partner_group_size = 1;\r\nbreak;\r\ncase 3:\r\nptlrpcd_partner_group_size = 2;\r\nbreak;\r\ncase 4:\r\n#ifdef CONFIG_NUMA\r\nptlrpcd_partner_group_size = -1;\r\n#else\r\nptlrpcd_partner_group_size = 3;\r\n#endif\r\nbreak;\r\ndefault:\r\nptlrpcd_partner_group_size = 2;\r\nbreak;\r\n}\r\nCWARN("Setting ptlrpcd_partner_group_size = %d\n",\r\nptlrpcd_partner_group_size);\r\n} else {\r\nCWARN("ptlrpcd_partner_group_size is also set!\n");\r\n}\r\n}\r\nif (ptlrpcd_partner_group_size == 0)\r\nptlrpcd_partner_group_size = 2;\r\nelse if (ptlrpcd_partner_group_size < 0)\r\nptlrpcd_partner_group_size = -1;\r\nelse if (ptlrpcd_per_cpt_max > 0 &&\r\nptlrpcd_partner_group_size > ptlrpcd_per_cpt_max)\r\nptlrpcd_partner_group_size = ptlrpcd_per_cpt_max;\r\nset_bit(LIOD_RECOVERY, &ptlrpcd_rcv.pc_flags);\r\nptlrpcd_ctl_init(&ptlrpcd_rcv, -1, CFS_CPT_ANY);\r\nrc = ptlrpcd_start(&ptlrpcd_rcv);\r\nif (rc < 0)\r\ngoto out;\r\nfor (i = 0; i < ncpts; i++) {\r\nif (!cpts)\r\ncpt = i;\r\nelse\r\ncpt = cpts[i];\r\nnthreads = cfs_cpt_weight(cptable, cpt);\r\nif (ptlrpcd_per_cpt_max > 0 && ptlrpcd_per_cpt_max < nthreads)\r\nnthreads = ptlrpcd_per_cpt_max;\r\nif (nthreads < 2)\r\nnthreads = 2;\r\nif (ptlrpcd_partner_group_size <= 0) {\r\ngroupsize = nthreads;\r\n} else if (nthreads <= ptlrpcd_partner_group_size) {\r\ngroupsize = nthreads;\r\n} else {\r\ngroupsize = ptlrpcd_partner_group_size;\r\nif (nthreads % groupsize != 0)\r\nnthreads += groupsize - (nthreads % groupsize);\r\n}\r\nsize = offsetof(struct ptlrpcd, pd_threads[nthreads]);\r\npd = kzalloc_node(size, GFP_NOFS,\r\ncfs_cpt_spread_node(cfs_cpt_table, cpt));\r\nif (!pd) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\npd->pd_size = size;\r\npd->pd_index = i;\r\npd->pd_cpt = cpt;\r\npd->pd_cursor = 0;\r\npd->pd_nthreads = nthreads;\r\npd->pd_groupsize = groupsize;\r\nptlrpcds[i] = pd;\r\nfor (j = 0; j < nthreads; j++) {\r\nptlrpcd_ctl_init(&pd->pd_threads[j], j, cpt);\r\nrc = ptlrpcd_partners(pd, j);\r\nif (rc < 0)\r\ngoto out;\r\n}\r\nfor (j = 0; j < nthreads; j++) {\r\nrc = ptlrpcd_start(&pd->pd_threads[j]);\r\nif (rc < 0)\r\ngoto out;\r\n}\r\n}\r\nout:\r\nif (rc != 0)\r\nptlrpcd_fini();\r\nreturn rc;\r\n}\r\nint ptlrpcd_addref(void)\r\n{\r\nint rc = 0;\r\nmutex_lock(&ptlrpcd_mutex);\r\nif (++ptlrpcd_users == 1) {\r\nrc = ptlrpcd_init();\r\nif (rc < 0)\r\nptlrpcd_users--;\r\n}\r\nmutex_unlock(&ptlrpcd_mutex);\r\nreturn rc;\r\n}\r\nvoid ptlrpcd_decref(void)\r\n{\r\nmutex_lock(&ptlrpcd_mutex);\r\nif (--ptlrpcd_users == 0)\r\nptlrpcd_fini();\r\nmutex_unlock(&ptlrpcd_mutex);\r\n}
