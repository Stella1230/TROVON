void acpi_ns_check_argument_types(struct acpi_evaluate_info *info)\r\n{\r\nu16 arg_type_list;\r\nu8 arg_count;\r\nu8 arg_type;\r\nu8 user_arg_type;\r\nu32 i;\r\nif (!info->predefined) {\r\nreturn;\r\n}\r\narg_type_list = info->predefined->info.argument_list;\r\narg_count = METHOD_GET_ARG_COUNT(arg_type_list);\r\nfor (i = 0; ((i < arg_count) && (i < info->param_count)); i++) {\r\narg_type = METHOD_GET_NEXT_TYPE(arg_type_list);\r\nuser_arg_type = info->parameters[i]->common.type;\r\nif (user_arg_type != arg_type) {\r\nACPI_WARN_PREDEFINED((AE_INFO, info->full_pathname,\r\nACPI_WARN_ALWAYS,\r\n"Argument #%u type mismatch - "\r\n"Found [%s], ACPI requires [%s]",\r\n(i + 1),\r\nacpi_ut_get_type_name\r\n(user_arg_type),\r\nacpi_ut_get_type_name(arg_type)));\r\n}\r\n}\r\n}\r\nvoid\r\nacpi_ns_check_acpi_compliance(char *pathname,\r\nstruct acpi_namespace_node *node,\r\nconst union acpi_predefined_info *predefined)\r\n{\r\nu32 aml_param_count;\r\nu32 required_param_count;\r\nif (!predefined) {\r\nreturn;\r\n}\r\nrequired_param_count =\r\nMETHOD_GET_ARG_COUNT(predefined->info.argument_list);\r\nif (node->type != ACPI_TYPE_METHOD) {\r\nif (required_param_count > 0) {\r\nACPI_BIOS_ERROR_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Object (%s) must be a control method with %u arguments",\r\nacpi_ut_get_type_name(node->\r\ntype),\r\nrequired_param_count));\r\n} else if (!required_param_count\r\n&& !predefined->info.expected_btypes) {\r\nACPI_BIOS_ERROR_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Object (%s) must be a control method "\r\n"with no arguments and no return value",\r\nacpi_ut_get_type_name(node->\r\ntype)));\r\n}\r\nreturn;\r\n}\r\naml_param_count = node->object->method.param_count;\r\nif (aml_param_count < required_param_count) {\r\nACPI_BIOS_ERROR_PREDEFINED((AE_INFO, pathname, ACPI_WARN_ALWAYS,\r\n"Insufficient arguments - "\r\n"ASL declared %u, ACPI requires %u",\r\naml_param_count,\r\nrequired_param_count));\r\n} else if ((aml_param_count > required_param_count)\r\n&& !(predefined->info.\r\nargument_list & ARG_COUNT_IS_MINIMUM)) {\r\nACPI_BIOS_ERROR_PREDEFINED((AE_INFO, pathname, ACPI_WARN_ALWAYS,\r\n"Excess arguments - "\r\n"ASL declared %u, ACPI requires %u",\r\naml_param_count,\r\nrequired_param_count));\r\n}\r\n}\r\nvoid\r\nacpi_ns_check_argument_count(char *pathname,\r\nstruct acpi_namespace_node *node,\r\nu32 user_param_count,\r\nconst union acpi_predefined_info *predefined)\r\n{\r\nu32 aml_param_count;\r\nu32 required_param_count;\r\nif (!predefined) {\r\nif (node->type != ACPI_TYPE_METHOD) {\r\nif (user_param_count) {\r\nACPI_INFO_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"%u arguments were passed to a non-method ACPI object (%s)",\r\nuser_param_count,\r\nacpi_ut_get_type_name\r\n(node->type)));\r\n}\r\nreturn;\r\n}\r\naml_param_count = node->object->method.param_count;\r\nif (user_param_count < aml_param_count) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Insufficient arguments - "\r\n"Caller passed %u, method requires %u",\r\nuser_param_count,\r\naml_param_count));\r\n} else if (user_param_count > aml_param_count) {\r\nACPI_INFO_PREDEFINED((AE_INFO, pathname,\r\nACPI_WARN_ALWAYS,\r\n"Excess arguments - "\r\n"Caller passed %u, method requires %u",\r\nuser_param_count,\r\naml_param_count));\r\n}\r\nreturn;\r\n}\r\nrequired_param_count =\r\nMETHOD_GET_ARG_COUNT(predefined->info.argument_list);\r\nif (user_param_count < required_param_count) {\r\nACPI_WARN_PREDEFINED((AE_INFO, pathname, ACPI_WARN_ALWAYS,\r\n"Insufficient arguments - "\r\n"Caller passed %u, ACPI requires %u",\r\nuser_param_count, required_param_count));\r\n} else if ((user_param_count > required_param_count) &&\r\n!(predefined->info.argument_list & ARG_COUNT_IS_MINIMUM)) {\r\nACPI_INFO_PREDEFINED((AE_INFO, pathname, ACPI_WARN_ALWAYS,\r\n"Excess arguments - "\r\n"Caller passed %u, ACPI requires %u",\r\nuser_param_count, required_param_count));\r\n}\r\n}
