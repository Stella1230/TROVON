static int regmap_smbus_byte_reg_read(void *context, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nint ret;\r\nif (reg > 0xff)\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_byte_data(i2c, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int regmap_smbus_byte_reg_write(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nif (val > 0xff || reg > 0xff)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_byte_data(i2c, reg, val);\r\n}\r\nstatic int regmap_smbus_word_reg_read(void *context, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nint ret;\r\nif (reg > 0xff)\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_word_data(i2c, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int regmap_smbus_word_reg_write(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nif (val > 0xffff || reg > 0xff)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_word_data(i2c, reg, val);\r\n}\r\nstatic int regmap_smbus_word_read_swapped(void *context, unsigned int reg,\r\nunsigned int *val)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nint ret;\r\nif (reg > 0xff)\r\nreturn -EINVAL;\r\nret = i2c_smbus_read_word_swapped(i2c, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int regmap_smbus_word_write_swapped(void *context, unsigned int reg,\r\nunsigned int val)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nif (val > 0xffff || reg > 0xff)\r\nreturn -EINVAL;\r\nreturn i2c_smbus_write_word_swapped(i2c, reg, val);\r\n}\r\nstatic int regmap_i2c_write(void *context, const void *data, size_t count)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nint ret;\r\nret = i2c_master_send(i2c, data, count);\r\nif (ret == count)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int regmap_i2c_gather_write(void *context,\r\nconst void *reg, size_t reg_size,\r\nconst void *val, size_t val_size)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct i2c_msg xfer[2];\r\nint ret;\r\nif (!i2c_check_functionality(i2c->adapter, I2C_FUNC_NOSTART))\r\nreturn -ENOTSUPP;\r\nxfer[0].addr = i2c->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = reg_size;\r\nxfer[0].buf = (void *)reg;\r\nxfer[1].addr = i2c->addr;\r\nxfer[1].flags = I2C_M_NOSTART;\r\nxfer[1].len = val_size;\r\nxfer[1].buf = (void *)val;\r\nret = i2c_transfer(i2c->adapter, xfer, 2);\r\nif (ret == 2)\r\nreturn 0;\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int regmap_i2c_read(void *context,\r\nconst void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nstruct i2c_msg xfer[2];\r\nint ret;\r\nxfer[0].addr = i2c->addr;\r\nxfer[0].flags = 0;\r\nxfer[0].len = reg_size;\r\nxfer[0].buf = (void *)reg;\r\nxfer[1].addr = i2c->addr;\r\nxfer[1].flags = I2C_M_RD;\r\nxfer[1].len = val_size;\r\nxfer[1].buf = val;\r\nret = i2c_transfer(i2c->adapter, xfer, 2);\r\nif (ret == 2)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic int regmap_i2c_smbus_i2c_write(void *context, const void *data,\r\nsize_t count)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nif (count < 1)\r\nreturn -EINVAL;\r\nif (count >= I2C_SMBUS_BLOCK_MAX)\r\nreturn -E2BIG;\r\n--count;\r\nreturn i2c_smbus_write_i2c_block_data(i2c, ((u8 *)data)[0], count,\r\n((u8 *)data + 1));\r\n}\r\nstatic int regmap_i2c_smbus_i2c_read(void *context, const void *reg,\r\nsize_t reg_size, void *val,\r\nsize_t val_size)\r\n{\r\nstruct device *dev = context;\r\nstruct i2c_client *i2c = to_i2c_client(dev);\r\nint ret;\r\nif (reg_size != 1 || val_size < 1)\r\nreturn -EINVAL;\r\nif (val_size >= I2C_SMBUS_BLOCK_MAX)\r\nreturn -E2BIG;\r\nret = i2c_smbus_read_i2c_block_data(i2c, ((u8 *)reg)[0], val_size, val);\r\nif (ret == val_size)\r\nreturn 0;\r\nelse if (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn -EIO;\r\n}\r\nstatic const struct regmap_bus *regmap_get_i2c_bus(struct i2c_client *i2c,\r\nconst struct regmap_config *config)\r\n{\r\nif (i2c_check_functionality(i2c->adapter, I2C_FUNC_I2C))\r\nreturn &regmap_i2c;\r\nelse if (config->val_bits == 8 && config->reg_bits == 8 &&\r\ni2c_check_functionality(i2c->adapter,\r\nI2C_FUNC_SMBUS_I2C_BLOCK))\r\nreturn &regmap_i2c_smbus_i2c_block;\r\nelse if (config->val_bits == 16 && config->reg_bits == 8 &&\r\ni2c_check_functionality(i2c->adapter,\r\nI2C_FUNC_SMBUS_WORD_DATA))\r\nswitch (regmap_get_val_endian(&i2c->dev, NULL, config)) {\r\ncase REGMAP_ENDIAN_LITTLE:\r\nreturn &regmap_smbus_word;\r\ncase REGMAP_ENDIAN_BIG:\r\nreturn &regmap_smbus_word_swapped;\r\ndefault:\r\nbreak;\r\n}\r\nelse if (config->val_bits == 8 && config->reg_bits == 8 &&\r\ni2c_check_functionality(i2c->adapter,\r\nI2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn &regmap_smbus_byte;\r\nreturn ERR_PTR(-ENOTSUPP);\r\n}\r\nstruct regmap *__regmap_init_i2c(struct i2c_client *i2c,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nconst struct regmap_bus *bus = regmap_get_i2c_bus(i2c, config);\r\nif (IS_ERR(bus))\r\nreturn ERR_CAST(bus);\r\nreturn __regmap_init(&i2c->dev, bus, &i2c->dev, config,\r\nlock_key, lock_name);\r\n}\r\nstruct regmap *__devm_regmap_init_i2c(struct i2c_client *i2c,\r\nconst struct regmap_config *config,\r\nstruct lock_class_key *lock_key,\r\nconst char *lock_name)\r\n{\r\nconst struct regmap_bus *bus = regmap_get_i2c_bus(i2c, config);\r\nif (IS_ERR(bus))\r\nreturn ERR_CAST(bus);\r\nreturn __devm_regmap_init(&i2c->dev, bus, &i2c->dev, config,\r\nlock_key, lock_name);\r\n}
