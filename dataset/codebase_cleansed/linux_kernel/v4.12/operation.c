static int gb_operation_get_active(struct gb_operation *operation)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nunsigned long flags;\r\nspin_lock_irqsave(&connection->lock, flags);\r\nswitch (connection->state) {\r\ncase GB_CONNECTION_STATE_ENABLED:\r\nbreak;\r\ncase GB_CONNECTION_STATE_ENABLED_TX:\r\nif (gb_operation_is_incoming(operation))\r\ngoto err_unlock;\r\nbreak;\r\ncase GB_CONNECTION_STATE_DISCONNECTING:\r\nif (!gb_operation_is_core(operation))\r\ngoto err_unlock;\r\nbreak;\r\ndefault:\r\ngoto err_unlock;\r\n}\r\nif (operation->active++ == 0)\r\nlist_add_tail(&operation->links, &connection->operations);\r\ntrace_gb_operation_get_active(operation);\r\nspin_unlock_irqrestore(&connection->lock, flags);\r\nreturn 0;\r\nerr_unlock:\r\nspin_unlock_irqrestore(&connection->lock, flags);\r\nreturn -ENOTCONN;\r\n}\r\nstatic void gb_operation_put_active(struct gb_operation *operation)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nunsigned long flags;\r\nspin_lock_irqsave(&connection->lock, flags);\r\ntrace_gb_operation_put_active(operation);\r\nif (--operation->active == 0) {\r\nlist_del(&operation->links);\r\nif (atomic_read(&operation->waiters))\r\nwake_up(&gb_operation_cancellation_queue);\r\n}\r\nspin_unlock_irqrestore(&connection->lock, flags);\r\n}\r\nstatic bool gb_operation_is_active(struct gb_operation *operation)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nunsigned long flags;\r\nbool ret;\r\nspin_lock_irqsave(&connection->lock, flags);\r\nret = operation->active;\r\nspin_unlock_irqrestore(&connection->lock, flags);\r\nreturn ret;\r\n}\r\nstatic bool gb_operation_result_set(struct gb_operation *operation, int result)\r\n{\r\nunsigned long flags;\r\nint prev;\r\nif (result == -EINPROGRESS) {\r\nspin_lock_irqsave(&gb_operations_lock, flags);\r\nprev = operation->errno;\r\nif (prev == -EBADR)\r\noperation->errno = result;\r\nelse\r\noperation->errno = -EILSEQ;\r\nspin_unlock_irqrestore(&gb_operations_lock, flags);\r\nWARN_ON(prev != -EBADR);\r\nreturn true;\r\n}\r\nif (WARN_ON(result == -EBADR))\r\nresult = -EILSEQ;\r\nspin_lock_irqsave(&gb_operations_lock, flags);\r\nprev = operation->errno;\r\nif (prev == -EINPROGRESS)\r\noperation->errno = result;\r\nspin_unlock_irqrestore(&gb_operations_lock, flags);\r\nreturn prev == -EINPROGRESS;\r\n}\r\nint gb_operation_result(struct gb_operation *operation)\r\n{\r\nint result = operation->errno;\r\nWARN_ON(result == -EBADR);\r\nWARN_ON(result == -EINPROGRESS);\r\nreturn result;\r\n}\r\nstatic struct gb_operation *\r\ngb_operation_find_outgoing(struct gb_connection *connection, u16 operation_id)\r\n{\r\nstruct gb_operation *operation;\r\nunsigned long flags;\r\nbool found = false;\r\nspin_lock_irqsave(&connection->lock, flags);\r\nlist_for_each_entry(operation, &connection->operations, links)\r\nif (operation->id == operation_id &&\r\n!gb_operation_is_incoming(operation)) {\r\ngb_operation_get(operation);\r\nfound = true;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&connection->lock, flags);\r\nreturn found ? operation : NULL;\r\n}\r\nstatic int gb_message_send(struct gb_message *message, gfp_t gfp)\r\n{\r\nstruct gb_connection *connection = message->operation->connection;\r\ntrace_gb_message_send(message);\r\nreturn connection->hd->driver->message_send(connection->hd,\r\nconnection->hd_cport_id,\r\nmessage,\r\ngfp);\r\n}\r\nstatic void gb_message_cancel(struct gb_message *message)\r\n{\r\nstruct gb_host_device *hd = message->operation->connection->hd;\r\nhd->driver->message_cancel(message);\r\n}\r\nstatic void gb_operation_request_handle(struct gb_operation *operation)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nint status;\r\nint ret;\r\nif (connection->handler) {\r\nstatus = connection->handler(operation);\r\n} else {\r\ndev_err(&connection->hd->dev,\r\n"%s: unexpected incoming request of type 0x%02x\n",\r\nconnection->name, operation->type);\r\nstatus = -EPROTONOSUPPORT;\r\n}\r\nret = gb_operation_response_send(operation, status);\r\nif (ret) {\r\ndev_err(&connection->hd->dev,\r\n"%s: failed to send response %d for type 0x%02x: %d\n",\r\nconnection->name, status, operation->type, ret);\r\nreturn;\r\n}\r\n}\r\nstatic void gb_operation_work(struct work_struct *work)\r\n{\r\nstruct gb_operation *operation;\r\nint ret;\r\noperation = container_of(work, struct gb_operation, work);\r\nif (gb_operation_is_incoming(operation)) {\r\ngb_operation_request_handle(operation);\r\n} else {\r\nret = del_timer_sync(&operation->timer);\r\nif (!ret) {\r\nif (gb_operation_result(operation) == -ETIMEDOUT)\r\ngb_message_cancel(operation->request);\r\n}\r\noperation->callback(operation);\r\n}\r\ngb_operation_put_active(operation);\r\ngb_operation_put(operation);\r\n}\r\nstatic void gb_operation_timeout(unsigned long arg)\r\n{\r\nstruct gb_operation *operation = (void *)arg;\r\nif (gb_operation_result_set(operation, -ETIMEDOUT)) {\r\nqueue_work(gb_operation_completion_wq, &operation->work);\r\n}\r\n}\r\nstatic void gb_operation_message_init(struct gb_host_device *hd,\r\nstruct gb_message *message, u16 operation_id,\r\nsize_t payload_size, u8 type)\r\n{\r\nstruct gb_operation_msg_hdr *header;\r\nheader = message->buffer;\r\nmessage->header = header;\r\nmessage->payload = payload_size ? header + 1 : NULL;\r\nmessage->payload_size = payload_size;\r\nif (type != GB_REQUEST_TYPE_INVALID) {\r\nu16 message_size = (u16)(sizeof(*header) + payload_size);\r\nheader->size = cpu_to_le16(message_size);\r\nheader->operation_id = 0;\r\nheader->type = type;\r\nheader->result = 0;\r\n}\r\n}\r\nstatic struct gb_message *\r\ngb_operation_message_alloc(struct gb_host_device *hd, u8 type,\r\nsize_t payload_size, gfp_t gfp_flags)\r\n{\r\nstruct gb_message *message;\r\nstruct gb_operation_msg_hdr *header;\r\nsize_t message_size = payload_size + sizeof(*header);\r\nif (message_size > hd->buffer_size_max) {\r\ndev_warn(&hd->dev, "requested message size too big (%zu > %zu)\n",\r\nmessage_size, hd->buffer_size_max);\r\nreturn NULL;\r\n}\r\nmessage = kmem_cache_zalloc(gb_message_cache, gfp_flags);\r\nif (!message)\r\nreturn NULL;\r\nmessage->buffer = kzalloc(message_size, gfp_flags);\r\nif (!message->buffer)\r\ngoto err_free_message;\r\ngb_operation_message_init(hd, message, 0, payload_size, type);\r\nreturn message;\r\nerr_free_message:\r\nkmem_cache_free(gb_message_cache, message);\r\nreturn NULL;\r\n}\r\nstatic void gb_operation_message_free(struct gb_message *message)\r\n{\r\nkfree(message->buffer);\r\nkmem_cache_free(gb_message_cache, message);\r\n}\r\nstatic int gb_operation_status_map(u8 status)\r\n{\r\nswitch (status) {\r\ncase GB_OP_SUCCESS:\r\nreturn 0;\r\ncase GB_OP_INTERRUPTED:\r\nreturn -EINTR;\r\ncase GB_OP_TIMEOUT:\r\nreturn -ETIMEDOUT;\r\ncase GB_OP_NO_MEMORY:\r\nreturn -ENOMEM;\r\ncase GB_OP_PROTOCOL_BAD:\r\nreturn -EPROTONOSUPPORT;\r\ncase GB_OP_OVERFLOW:\r\nreturn -EMSGSIZE;\r\ncase GB_OP_INVALID:\r\nreturn -EINVAL;\r\ncase GB_OP_RETRY:\r\nreturn -EAGAIN;\r\ncase GB_OP_NONEXISTENT:\r\nreturn -ENODEV;\r\ncase GB_OP_MALFUNCTION:\r\nreturn -EILSEQ;\r\ncase GB_OP_UNKNOWN_ERROR:\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nstatic u8 gb_operation_errno_map(int errno)\r\n{\r\nswitch (errno) {\r\ncase 0:\r\nreturn GB_OP_SUCCESS;\r\ncase -EINTR:\r\nreturn GB_OP_INTERRUPTED;\r\ncase -ETIMEDOUT:\r\nreturn GB_OP_TIMEOUT;\r\ncase -ENOMEM:\r\nreturn GB_OP_NO_MEMORY;\r\ncase -EPROTONOSUPPORT:\r\nreturn GB_OP_PROTOCOL_BAD;\r\ncase -EMSGSIZE:\r\nreturn GB_OP_OVERFLOW;\r\ncase -EINVAL:\r\nreturn GB_OP_INVALID;\r\ncase -EAGAIN:\r\nreturn GB_OP_RETRY;\r\ncase -EILSEQ:\r\nreturn GB_OP_MALFUNCTION;\r\ncase -ENODEV:\r\nreturn GB_OP_NONEXISTENT;\r\ncase -EIO:\r\ndefault:\r\nreturn GB_OP_UNKNOWN_ERROR;\r\n}\r\n}\r\nbool gb_operation_response_alloc(struct gb_operation *operation,\r\nsize_t response_size, gfp_t gfp)\r\n{\r\nstruct gb_host_device *hd = operation->connection->hd;\r\nstruct gb_operation_msg_hdr *request_header;\r\nstruct gb_message *response;\r\nu8 type;\r\ntype = operation->type | GB_MESSAGE_TYPE_RESPONSE;\r\nresponse = gb_operation_message_alloc(hd, type, response_size, gfp);\r\nif (!response)\r\nreturn false;\r\nresponse->operation = operation;\r\nrequest_header = operation->request->header;\r\nresponse->header->operation_id = request_header->operation_id;\r\noperation->response = response;\r\nreturn true;\r\n}\r\nstatic struct gb_operation *\r\ngb_operation_create_common(struct gb_connection *connection, u8 type,\r\nsize_t request_size, size_t response_size,\r\nunsigned long op_flags, gfp_t gfp_flags)\r\n{\r\nstruct gb_host_device *hd = connection->hd;\r\nstruct gb_operation *operation;\r\noperation = kmem_cache_zalloc(gb_operation_cache, gfp_flags);\r\nif (!operation)\r\nreturn NULL;\r\noperation->connection = connection;\r\noperation->request = gb_operation_message_alloc(hd, type, request_size,\r\ngfp_flags);\r\nif (!operation->request)\r\ngoto err_cache;\r\noperation->request->operation = operation;\r\nif (!(op_flags & GB_OPERATION_FLAG_INCOMING)) {\r\nif (!gb_operation_response_alloc(operation, response_size,\r\ngfp_flags)) {\r\ngoto err_request;\r\n}\r\nsetup_timer(&operation->timer, gb_operation_timeout,\r\n(unsigned long)operation);\r\n}\r\noperation->flags = op_flags;\r\noperation->type = type;\r\noperation->errno = -EBADR;\r\nINIT_WORK(&operation->work, gb_operation_work);\r\ninit_completion(&operation->completion);\r\nkref_init(&operation->kref);\r\natomic_set(&operation->waiters, 0);\r\nreturn operation;\r\nerr_request:\r\ngb_operation_message_free(operation->request);\r\nerr_cache:\r\nkmem_cache_free(gb_operation_cache, operation);\r\nreturn NULL;\r\n}\r\nstruct gb_operation *\r\ngb_operation_create_flags(struct gb_connection *connection,\r\nu8 type, size_t request_size,\r\nsize_t response_size, unsigned long flags,\r\ngfp_t gfp)\r\n{\r\nstruct gb_operation *operation;\r\nif (WARN_ON_ONCE(type == GB_REQUEST_TYPE_INVALID))\r\nreturn NULL;\r\nif (WARN_ON_ONCE(type & GB_MESSAGE_TYPE_RESPONSE))\r\ntype &= ~GB_MESSAGE_TYPE_RESPONSE;\r\nif (WARN_ON_ONCE(flags & ~GB_OPERATION_FLAG_USER_MASK))\r\nflags &= GB_OPERATION_FLAG_USER_MASK;\r\noperation = gb_operation_create_common(connection, type,\r\nrequest_size, response_size,\r\nflags, gfp);\r\nif (operation)\r\ntrace_gb_operation_create(operation);\r\nreturn operation;\r\n}\r\nstruct gb_operation *\r\ngb_operation_create_core(struct gb_connection *connection,\r\nu8 type, size_t request_size,\r\nsize_t response_size, unsigned long flags,\r\ngfp_t gfp)\r\n{\r\nstruct gb_operation *operation;\r\nflags |= GB_OPERATION_FLAG_CORE;\r\noperation = gb_operation_create_common(connection, type,\r\nrequest_size, response_size,\r\nflags, gfp);\r\nif (operation)\r\ntrace_gb_operation_create_core(operation);\r\nreturn operation;\r\n}\r\nsize_t gb_operation_get_payload_size_max(struct gb_connection *connection)\r\n{\r\nstruct gb_host_device *hd = connection->hd;\r\nreturn hd->buffer_size_max - sizeof(struct gb_operation_msg_hdr);\r\n}\r\nstatic struct gb_operation *\r\ngb_operation_create_incoming(struct gb_connection *connection, u16 id,\r\nu8 type, void *data, size_t size)\r\n{\r\nstruct gb_operation *operation;\r\nsize_t request_size;\r\nunsigned long flags = GB_OPERATION_FLAG_INCOMING;\r\nrequest_size = size - sizeof(struct gb_operation_msg_hdr);\r\nif (!id)\r\nflags |= GB_OPERATION_FLAG_UNIDIRECTIONAL;\r\noperation = gb_operation_create_common(connection, type,\r\nrequest_size,\r\nGB_REQUEST_TYPE_INVALID,\r\nflags, GFP_ATOMIC);\r\nif (!operation)\r\nreturn NULL;\r\noperation->id = id;\r\nmemcpy(operation->request->header, data, size);\r\ntrace_gb_operation_create_incoming(operation);\r\nreturn operation;\r\n}\r\nvoid gb_operation_get(struct gb_operation *operation)\r\n{\r\nkref_get(&operation->kref);\r\n}\r\nstatic void _gb_operation_destroy(struct kref *kref)\r\n{\r\nstruct gb_operation *operation;\r\noperation = container_of(kref, struct gb_operation, kref);\r\ntrace_gb_operation_destroy(operation);\r\nif (operation->response)\r\ngb_operation_message_free(operation->response);\r\ngb_operation_message_free(operation->request);\r\nkmem_cache_free(gb_operation_cache, operation);\r\n}\r\nvoid gb_operation_put(struct gb_operation *operation)\r\n{\r\nif (WARN_ON(!operation))\r\nreturn;\r\nkref_put(&operation->kref, _gb_operation_destroy);\r\n}\r\nstatic void gb_operation_sync_callback(struct gb_operation *operation)\r\n{\r\ncomplete(&operation->completion);\r\n}\r\nint gb_operation_request_send(struct gb_operation *operation,\r\ngb_operation_callback callback,\r\nunsigned int timeout,\r\ngfp_t gfp)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nstruct gb_operation_msg_hdr *header;\r\nunsigned int cycle;\r\nint ret;\r\nif (gb_connection_is_offloaded(connection))\r\nreturn -EBUSY;\r\nif (!callback)\r\nreturn -EINVAL;\r\noperation->callback = callback;\r\nif (gb_operation_is_unidirectional(operation)) {\r\noperation->id = 0;\r\n} else {\r\ncycle = (unsigned int)atomic_inc_return(&connection->op_cycle);\r\noperation->id = (u16)(cycle % U16_MAX + 1);\r\n}\r\nheader = operation->request->header;\r\nheader->operation_id = cpu_to_le16(operation->id);\r\ngb_operation_result_set(operation, -EINPROGRESS);\r\ngb_operation_get(operation);\r\nret = gb_operation_get_active(operation);\r\nif (ret)\r\ngoto err_put;\r\nret = gb_message_send(operation->request, gfp);\r\nif (ret)\r\ngoto err_put_active;\r\nif (timeout) {\r\noperation->timer.expires = jiffies + msecs_to_jiffies(timeout);\r\nadd_timer(&operation->timer);\r\n}\r\nreturn 0;\r\nerr_put_active:\r\ngb_operation_put_active(operation);\r\nerr_put:\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nint gb_operation_request_send_sync_timeout(struct gb_operation *operation,\r\nunsigned int timeout)\r\n{\r\nint ret;\r\nret = gb_operation_request_send(operation, gb_operation_sync_callback,\r\ntimeout, GFP_KERNEL);\r\nif (ret)\r\nreturn ret;\r\nret = wait_for_completion_interruptible(&operation->completion);\r\nif (ret < 0) {\r\ngb_operation_cancel(operation, -ECANCELED);\r\n}\r\nreturn gb_operation_result(operation);\r\n}\r\nstatic int gb_operation_response_send(struct gb_operation *operation,\r\nint errno)\r\n{\r\nstruct gb_connection *connection = operation->connection;\r\nint ret;\r\nif (!operation->response &&\r\n!gb_operation_is_unidirectional(operation)) {\r\nif (!gb_operation_response_alloc(operation, 0, GFP_KERNEL))\r\nreturn -ENOMEM;\r\n}\r\nif (!gb_operation_result_set(operation, errno)) {\r\ndev_err(&connection->hd->dev, "request result already set\n");\r\nreturn -EIO;\r\n}\r\nif (gb_operation_is_unidirectional(operation))\r\nreturn 0;\r\ngb_operation_get(operation);\r\nret = gb_operation_get_active(operation);\r\nif (ret)\r\ngoto err_put;\r\noperation->response->header->result = gb_operation_errno_map(errno);\r\nret = gb_message_send(operation->response, GFP_KERNEL);\r\nif (ret)\r\ngoto err_put_active;\r\nreturn 0;\r\nerr_put_active:\r\ngb_operation_put_active(operation);\r\nerr_put:\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nvoid greybus_message_sent(struct gb_host_device *hd,\r\nstruct gb_message *message, int status)\r\n{\r\nstruct gb_operation *operation = message->operation;\r\nstruct gb_connection *connection = operation->connection;\r\nif (message == operation->response) {\r\nif (status) {\r\ndev_err(&connection->hd->dev,\r\n"%s: error sending response 0x%02x: %d\n",\r\nconnection->name, operation->type, status);\r\n}\r\ngb_operation_put_active(operation);\r\ngb_operation_put(operation);\r\n} else if (status || gb_operation_is_unidirectional(operation)) {\r\nif (gb_operation_result_set(operation, status)) {\r\nqueue_work(gb_operation_completion_wq,\r\n&operation->work);\r\n}\r\n}\r\n}\r\nstatic void gb_connection_recv_request(struct gb_connection *connection,\r\nconst struct gb_operation_msg_hdr *header,\r\nvoid *data, size_t size)\r\n{\r\nstruct gb_operation *operation;\r\nu16 operation_id;\r\nu8 type;\r\nint ret;\r\noperation_id = le16_to_cpu(header->operation_id);\r\ntype = header->type;\r\noperation = gb_operation_create_incoming(connection, operation_id,\r\ntype, data, size);\r\nif (!operation) {\r\ndev_err(&connection->hd->dev,\r\n"%s: can't create incoming operation\n",\r\nconnection->name);\r\nreturn;\r\n}\r\nret = gb_operation_get_active(operation);\r\nif (ret) {\r\ngb_operation_put(operation);\r\nreturn;\r\n}\r\ntrace_gb_message_recv_request(operation->request);\r\nif (gb_operation_result_set(operation, -EINPROGRESS))\r\nqueue_work(connection->wq, &operation->work);\r\n}\r\nstatic void gb_connection_recv_response(struct gb_connection *connection,\r\nconst struct gb_operation_msg_hdr *header,\r\nvoid *data, size_t size)\r\n{\r\nstruct gb_operation *operation;\r\nstruct gb_message *message;\r\nsize_t message_size;\r\nu16 operation_id;\r\nint errno;\r\noperation_id = le16_to_cpu(header->operation_id);\r\nif (!operation_id) {\r\ndev_err_ratelimited(&connection->hd->dev,\r\n"%s: invalid response id 0 received\n",\r\nconnection->name);\r\nreturn;\r\n}\r\noperation = gb_operation_find_outgoing(connection, operation_id);\r\nif (!operation) {\r\ndev_err_ratelimited(&connection->hd->dev,\r\n"%s: unexpected response id 0x%04x received\n",\r\nconnection->name, operation_id);\r\nreturn;\r\n}\r\nerrno = gb_operation_status_map(header->result);\r\nmessage = operation->response;\r\nmessage_size = sizeof(*header) + message->payload_size;\r\nif (!errno && size > message_size) {\r\ndev_err_ratelimited(&connection->hd->dev,\r\n"%s: malformed response 0x%02x received (%zu > %zu)\n",\r\nconnection->name, header->type,\r\nsize, message_size);\r\nerrno = -EMSGSIZE;\r\n} else if (!errno && size < message_size) {\r\nif (gb_operation_short_response_allowed(operation)) {\r\nmessage->payload_size = size - sizeof(*header);\r\n} else {\r\ndev_err_ratelimited(&connection->hd->dev,\r\n"%s: short response 0x%02x received (%zu < %zu)\n",\r\nconnection->name, header->type,\r\nsize, message_size);\r\nerrno = -EMSGSIZE;\r\n}\r\n}\r\nif (errno)\r\nsize = sizeof(*header);\r\nif (gb_operation_result_set(operation, errno)) {\r\nmemcpy(message->buffer, data, size);\r\ntrace_gb_message_recv_response(message);\r\nqueue_work(gb_operation_completion_wq, &operation->work);\r\n}\r\ngb_operation_put(operation);\r\n}\r\nvoid gb_connection_recv(struct gb_connection *connection,\r\nvoid *data, size_t size)\r\n{\r\nstruct gb_operation_msg_hdr header;\r\nstruct device *dev = &connection->hd->dev;\r\nsize_t msg_size;\r\nif (connection->state == GB_CONNECTION_STATE_DISABLED ||\r\ngb_connection_is_offloaded(connection)) {\r\ndev_warn_ratelimited(dev, "%s: dropping %zu received bytes\n",\r\nconnection->name, size);\r\nreturn;\r\n}\r\nif (size < sizeof(header)) {\r\ndev_err_ratelimited(dev, "%s: short message received\n",\r\nconnection->name);\r\nreturn;\r\n}\r\nmemcpy(&header, data, sizeof(header));\r\nmsg_size = le16_to_cpu(header.size);\r\nif (size < msg_size) {\r\ndev_err_ratelimited(dev,\r\n"%s: incomplete message 0x%04x of type 0x%02x received (%zu < %zu)\n",\r\nconnection->name,\r\nle16_to_cpu(header.operation_id),\r\nheader.type, size, msg_size);\r\nreturn;\r\n}\r\nif (header.type & GB_MESSAGE_TYPE_RESPONSE) {\r\ngb_connection_recv_response(connection, &header, data,\r\nmsg_size);\r\n} else {\r\ngb_connection_recv_request(connection, &header, data,\r\nmsg_size);\r\n}\r\n}\r\nvoid gb_operation_cancel(struct gb_operation *operation, int errno)\r\n{\r\nif (WARN_ON(gb_operation_is_incoming(operation)))\r\nreturn;\r\nif (gb_operation_result_set(operation, errno)) {\r\ngb_message_cancel(operation->request);\r\nqueue_work(gb_operation_completion_wq, &operation->work);\r\n}\r\ntrace_gb_message_cancel_outgoing(operation->request);\r\natomic_inc(&operation->waiters);\r\nwait_event(gb_operation_cancellation_queue,\r\n!gb_operation_is_active(operation));\r\natomic_dec(&operation->waiters);\r\n}\r\nvoid gb_operation_cancel_incoming(struct gb_operation *operation, int errno)\r\n{\r\nif (WARN_ON(!gb_operation_is_incoming(operation)))\r\nreturn;\r\nif (!gb_operation_is_unidirectional(operation)) {\r\nflush_work(&operation->work);\r\nif (!gb_operation_result_set(operation, errno))\r\ngb_message_cancel(operation->response);\r\n}\r\ntrace_gb_message_cancel_incoming(operation->response);\r\natomic_inc(&operation->waiters);\r\nwait_event(gb_operation_cancellation_queue,\r\n!gb_operation_is_active(operation));\r\natomic_dec(&operation->waiters);\r\n}\r\nint gb_operation_sync_timeout(struct gb_connection *connection, int type,\r\nvoid *request, int request_size,\r\nvoid *response, int response_size,\r\nunsigned int timeout)\r\n{\r\nstruct gb_operation *operation;\r\nint ret;\r\nif ((response_size && !response) ||\r\n(request_size && !request))\r\nreturn -EINVAL;\r\noperation = gb_operation_create(connection, type,\r\nrequest_size, response_size,\r\nGFP_KERNEL);\r\nif (!operation)\r\nreturn -ENOMEM;\r\nif (request_size)\r\nmemcpy(operation->request->payload, request, request_size);\r\nret = gb_operation_request_send_sync_timeout(operation, timeout);\r\nif (ret) {\r\ndev_err(&connection->hd->dev,\r\n"%s: synchronous operation id 0x%04x of type 0x%02x failed: %d\n",\r\nconnection->name, operation->id, type, ret);\r\n} else {\r\nif (response_size) {\r\nmemcpy(response, operation->response->payload,\r\nresponse_size);\r\n}\r\n}\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nint gb_operation_unidirectional_timeout(struct gb_connection *connection,\r\nint type, void *request, int request_size,\r\nunsigned int timeout)\r\n{\r\nstruct gb_operation *operation;\r\nint ret;\r\nif (request_size && !request)\r\nreturn -EINVAL;\r\noperation = gb_operation_create_flags(connection, type,\r\nrequest_size, 0,\r\nGB_OPERATION_FLAG_UNIDIRECTIONAL,\r\nGFP_KERNEL);\r\nif (!operation)\r\nreturn -ENOMEM;\r\nif (request_size)\r\nmemcpy(operation->request->payload, request, request_size);\r\nret = gb_operation_request_send_sync_timeout(operation, timeout);\r\nif (ret) {\r\ndev_err(&connection->hd->dev,\r\n"%s: unidirectional operation of type 0x%02x failed: %d\n",\r\nconnection->name, type, ret);\r\n}\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nint __init gb_operation_init(void)\r\n{\r\ngb_message_cache = kmem_cache_create("gb_message_cache",\r\nsizeof(struct gb_message), 0, 0, NULL);\r\nif (!gb_message_cache)\r\nreturn -ENOMEM;\r\ngb_operation_cache = kmem_cache_create("gb_operation_cache",\r\nsizeof(struct gb_operation), 0, 0, NULL);\r\nif (!gb_operation_cache)\r\ngoto err_destroy_message_cache;\r\ngb_operation_completion_wq = alloc_workqueue("greybus_completion",\r\n0, 0);\r\nif (!gb_operation_completion_wq)\r\ngoto err_destroy_operation_cache;\r\nreturn 0;\r\nerr_destroy_operation_cache:\r\nkmem_cache_destroy(gb_operation_cache);\r\ngb_operation_cache = NULL;\r\nerr_destroy_message_cache:\r\nkmem_cache_destroy(gb_message_cache);\r\ngb_message_cache = NULL;\r\nreturn -ENOMEM;\r\n}\r\nvoid gb_operation_exit(void)\r\n{\r\ndestroy_workqueue(gb_operation_completion_wq);\r\ngb_operation_completion_wq = NULL;\r\nkmem_cache_destroy(gb_operation_cache);\r\ngb_operation_cache = NULL;\r\nkmem_cache_destroy(gb_message_cache);\r\ngb_message_cache = NULL;\r\n}
