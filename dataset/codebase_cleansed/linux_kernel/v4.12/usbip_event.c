static void set_event(struct usbip_device *ud, unsigned long event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ud->lock, flags);\r\nud->event |= event;\r\nspin_unlock_irqrestore(&ud->lock, flags);\r\n}\r\nstatic void unset_event(struct usbip_device *ud, unsigned long event)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&ud->lock, flags);\r\nud->event &= ~event;\r\nspin_unlock_irqrestore(&ud->lock, flags);\r\n}\r\nstatic struct usbip_device *get_event(void)\r\n{\r\nstruct usbip_event *ue = NULL;\r\nstruct usbip_device *ud = NULL;\r\nunsigned long flags;\r\nspin_lock_irqsave(&event_lock, flags);\r\nif (!list_empty(&event_list)) {\r\nue = list_first_entry(&event_list, struct usbip_event, node);\r\nlist_del(&ue->node);\r\n}\r\nspin_unlock_irqrestore(&event_lock, flags);\r\nif (ue) {\r\nud = ue->ud;\r\nkfree(ue);\r\n}\r\nreturn ud;\r\n}\r\nstatic void event_handler(struct work_struct *work)\r\n{\r\nstruct usbip_device *ud;\r\nif (worker_context == NULL) {\r\nworker_context = current;\r\n}\r\nwhile ((ud = get_event()) != NULL) {\r\nusbip_dbg_eh("pending event %lx\n", ud->event);\r\nif (ud->event & USBIP_EH_SHUTDOWN) {\r\nud->eh_ops.shutdown(ud);\r\nunset_event(ud, USBIP_EH_SHUTDOWN);\r\n}\r\nif (ud->event & USBIP_EH_RESET) {\r\nud->eh_ops.reset(ud);\r\nunset_event(ud, USBIP_EH_RESET);\r\n}\r\nif (ud->event & USBIP_EH_UNUSABLE) {\r\nud->eh_ops.unusable(ud);\r\nunset_event(ud, USBIP_EH_UNUSABLE);\r\n}\r\nif (ud->event & USBIP_EH_BYE)\r\nusbip_dbg_eh("removed %p\n", ud);\r\nwake_up(&ud->eh_waitq);\r\n}\r\n}\r\nint usbip_start_eh(struct usbip_device *ud)\r\n{\r\ninit_waitqueue_head(&ud->eh_waitq);\r\nud->event = 0;\r\nreturn 0;\r\n}\r\nvoid usbip_stop_eh(struct usbip_device *ud)\r\n{\r\nunsigned long pending = ud->event & ~USBIP_EH_BYE;\r\nif (!(ud->event & USBIP_EH_BYE))\r\nusbip_dbg_eh("usbip_eh stopping but not removed\n");\r\nif (pending)\r\nusbip_dbg_eh("usbip_eh waiting completion %lx\n", pending);\r\nwait_event_interruptible(ud->eh_waitq, !(ud->event & ~USBIP_EH_BYE));\r\nusbip_dbg_eh("usbip_eh has stopped\n");\r\n}\r\nint usbip_init_eh(void)\r\n{\r\nusbip_queue = create_singlethread_workqueue(WORK_QUEUE_NAME);\r\nif (usbip_queue == NULL) {\r\npr_err("failed to create usbip_event\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nvoid usbip_finish_eh(void)\r\n{\r\nflush_workqueue(usbip_queue);\r\ndestroy_workqueue(usbip_queue);\r\nusbip_queue = NULL;\r\n}\r\nvoid usbip_event_add(struct usbip_device *ud, unsigned long event)\r\n{\r\nstruct usbip_event *ue;\r\nunsigned long flags;\r\nif (ud->event & USBIP_EH_BYE)\r\nreturn;\r\nset_event(ud, event);\r\nspin_lock_irqsave(&event_lock, flags);\r\nlist_for_each_entry_reverse(ue, &event_list, node) {\r\nif (ue->ud == ud)\r\ngoto out;\r\n}\r\nue = kmalloc(sizeof(struct usbip_event), GFP_ATOMIC);\r\nif (ue == NULL)\r\ngoto out;\r\nue->ud = ud;\r\nlist_add_tail(&ue->node, &event_list);\r\nqueue_work(usbip_queue, &usbip_work);\r\nout:\r\nspin_unlock_irqrestore(&event_lock, flags);\r\n}\r\nint usbip_event_happened(struct usbip_device *ud)\r\n{\r\nint happened = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&ud->lock, flags);\r\nif (ud->event != 0)\r\nhappened = 1;\r\nspin_unlock_irqrestore(&ud->lock, flags);\r\nreturn happened;\r\n}\r\nint usbip_in_eh(struct task_struct *task)\r\n{\r\nif (task == worker_context)\r\nreturn 1;\r\nreturn 0;\r\n}
