static struct Qdisc *ingress_leaf(struct Qdisc *sch, unsigned long arg)\r\n{\r\nreturn NULL;\r\n}\r\nstatic unsigned long ingress_get(struct Qdisc *sch, u32 classid)\r\n{\r\nreturn TC_H_MIN(classid) + 1;\r\n}\r\nstatic bool ingress_cl_offload(u32 classid)\r\n{\r\nreturn true;\r\n}\r\nstatic unsigned long ingress_bind_filter(struct Qdisc *sch,\r\nunsigned long parent, u32 classid)\r\n{\r\nreturn ingress_get(sch, classid);\r\n}\r\nstatic void ingress_put(struct Qdisc *sch, unsigned long cl)\r\n{\r\n}\r\nstatic void ingress_walk(struct Qdisc *sch, struct qdisc_walker *walker)\r\n{\r\n}\r\nstatic struct tcf_proto __rcu **ingress_find_tcf(struct Qdisc *sch,\r\nunsigned long cl)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nreturn &dev->ingress_cl_list;\r\n}\r\nstatic int ingress_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nnet_inc_ingress_queue();\r\nsch->flags |= TCQ_F_CPUSTATS;\r\nreturn 0;\r\n}\r\nstatic void ingress_destroy(struct Qdisc *sch)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\ntcf_destroy_chain(&dev->ingress_cl_list);\r\nnet_dec_ingress_queue();\r\n}\r\nstatic int ingress_dump(struct Qdisc *sch, struct sk_buff *skb)\r\n{\r\nstruct nlattr *nest;\r\nnest = nla_nest_start(skb, TCA_OPTIONS);\r\nif (nest == NULL)\r\ngoto nla_put_failure;\r\nreturn nla_nest_end(skb, nest);\r\nnla_put_failure:\r\nnla_nest_cancel(skb, nest);\r\nreturn -1;\r\n}\r\nstatic unsigned long clsact_get(struct Qdisc *sch, u32 classid)\r\n{\r\nswitch (TC_H_MIN(classid)) {\r\ncase TC_H_MIN(TC_H_MIN_INGRESS):\r\ncase TC_H_MIN(TC_H_MIN_EGRESS):\r\nreturn TC_H_MIN(classid);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic bool clsact_cl_offload(u32 classid)\r\n{\r\nreturn TC_H_MIN(classid) == TC_H_MIN(TC_H_MIN_INGRESS);\r\n}\r\nstatic unsigned long clsact_bind_filter(struct Qdisc *sch,\r\nunsigned long parent, u32 classid)\r\n{\r\nreturn clsact_get(sch, classid);\r\n}\r\nstatic struct tcf_proto __rcu **clsact_find_tcf(struct Qdisc *sch,\r\nunsigned long cl)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\nswitch (cl) {\r\ncase TC_H_MIN(TC_H_MIN_INGRESS):\r\nreturn &dev->ingress_cl_list;\r\ncase TC_H_MIN(TC_H_MIN_EGRESS):\r\nreturn &dev->egress_cl_list;\r\ndefault:\r\nreturn NULL;\r\n}\r\n}\r\nstatic int clsact_init(struct Qdisc *sch, struct nlattr *opt)\r\n{\r\nnet_inc_ingress_queue();\r\nnet_inc_egress_queue();\r\nsch->flags |= TCQ_F_CPUSTATS;\r\nreturn 0;\r\n}\r\nstatic void clsact_destroy(struct Qdisc *sch)\r\n{\r\nstruct net_device *dev = qdisc_dev(sch);\r\ntcf_destroy_chain(&dev->ingress_cl_list);\r\ntcf_destroy_chain(&dev->egress_cl_list);\r\nnet_dec_ingress_queue();\r\nnet_dec_egress_queue();\r\n}\r\nstatic int __init ingress_module_init(void)\r\n{\r\nint ret;\r\nret = register_qdisc(&ingress_qdisc_ops);\r\nif (!ret) {\r\nret = register_qdisc(&clsact_qdisc_ops);\r\nif (ret)\r\nunregister_qdisc(&ingress_qdisc_ops);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit ingress_module_exit(void)\r\n{\r\nunregister_qdisc(&ingress_qdisc_ops);\r\nunregister_qdisc(&clsact_qdisc_ops);\r\n}
