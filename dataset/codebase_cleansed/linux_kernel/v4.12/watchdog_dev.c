static inline bool watchdog_need_worker(struct watchdog_device *wdd)\r\n{\r\nunsigned int hm = wdd->max_hw_heartbeat_ms;\r\nunsigned int t = wdd->timeout * 1000;\r\nreturn (hm && watchdog_active(wdd) && t > hm) ||\r\n(t && !watchdog_active(wdd) && watchdog_hw_running(wdd));\r\n}\r\nstatic long watchdog_next_keepalive(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nunsigned int timeout_ms = wdd->timeout * 1000;\r\nunsigned long keepalive_interval;\r\nunsigned long last_heartbeat;\r\nunsigned long virt_timeout;\r\nunsigned int hw_heartbeat_ms;\r\nvirt_timeout = wd_data->last_keepalive + msecs_to_jiffies(timeout_ms);\r\nhw_heartbeat_ms = min_not_zero(timeout_ms, wdd->max_hw_heartbeat_ms);\r\nkeepalive_interval = msecs_to_jiffies(hw_heartbeat_ms / 2);\r\nif (!watchdog_active(wdd))\r\nreturn keepalive_interval;\r\nlast_heartbeat = virt_timeout - msecs_to_jiffies(hw_heartbeat_ms);\r\nreturn min_t(long, last_heartbeat - jiffies, keepalive_interval);\r\n}\r\nstatic inline void watchdog_update_worker(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nif (watchdog_need_worker(wdd)) {\r\nlong t = watchdog_next_keepalive(wdd);\r\nif (t > 0)\r\nmod_delayed_work(watchdog_wq, &wd_data->work, t);\r\n} else {\r\ncancel_delayed_work(&wd_data->work);\r\n}\r\n}\r\nstatic int __watchdog_ping(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nunsigned long earliest_keepalive = wd_data->last_hw_keepalive +\r\nmsecs_to_jiffies(wdd->min_hw_heartbeat_ms);\r\nint err;\r\nif (time_is_after_jiffies(earliest_keepalive)) {\r\nmod_delayed_work(watchdog_wq, &wd_data->work,\r\nearliest_keepalive - jiffies);\r\nreturn 0;\r\n}\r\nwd_data->last_hw_keepalive = jiffies;\r\nif (wdd->ops->ping)\r\nerr = wdd->ops->ping(wdd);\r\nelse\r\nerr = wdd->ops->start(wdd);\r\nwatchdog_update_worker(wdd);\r\nreturn err;\r\n}\r\nstatic int watchdog_ping(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nif (!watchdog_active(wdd) && !watchdog_hw_running(wdd))\r\nreturn 0;\r\nset_bit(_WDOG_KEEPALIVE, &wd_data->status);\r\nwd_data->last_keepalive = jiffies;\r\nreturn __watchdog_ping(wdd);\r\n}\r\nstatic void watchdog_ping_work(struct work_struct *work)\r\n{\r\nstruct watchdog_core_data *wd_data;\r\nstruct watchdog_device *wdd;\r\nwd_data = container_of(to_delayed_work(work), struct watchdog_core_data,\r\nwork);\r\nmutex_lock(&wd_data->lock);\r\nwdd = wd_data->wdd;\r\nif (wdd && (watchdog_active(wdd) || watchdog_hw_running(wdd)))\r\n__watchdog_ping(wdd);\r\nmutex_unlock(&wd_data->lock);\r\n}\r\nstatic int watchdog_start(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nunsigned long started_at;\r\nint err;\r\nif (watchdog_active(wdd))\r\nreturn 0;\r\nset_bit(_WDOG_KEEPALIVE, &wd_data->status);\r\nstarted_at = jiffies;\r\nif (watchdog_hw_running(wdd) && wdd->ops->ping)\r\nerr = wdd->ops->ping(wdd);\r\nelse\r\nerr = wdd->ops->start(wdd);\r\nif (err == 0) {\r\nset_bit(WDOG_ACTIVE, &wdd->status);\r\nwd_data->last_keepalive = started_at;\r\nwatchdog_update_worker(wdd);\r\n}\r\nreturn err;\r\n}\r\nstatic int watchdog_stop(struct watchdog_device *wdd)\r\n{\r\nint err = 0;\r\nif (!watchdog_active(wdd))\r\nreturn 0;\r\nif (test_bit(WDOG_NO_WAY_OUT, &wdd->status)) {\r\npr_info("watchdog%d: nowayout prevents watchdog being stopped!\n",\r\nwdd->id);\r\nreturn -EBUSY;\r\n}\r\nif (wdd->ops->stop) {\r\nclear_bit(WDOG_HW_RUNNING, &wdd->status);\r\nerr = wdd->ops->stop(wdd);\r\n} else {\r\nset_bit(WDOG_HW_RUNNING, &wdd->status);\r\n}\r\nif (err == 0) {\r\nclear_bit(WDOG_ACTIVE, &wdd->status);\r\nwatchdog_update_worker(wdd);\r\n}\r\nreturn err;\r\n}\r\nstatic unsigned int watchdog_get_status(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nunsigned int status;\r\nif (wdd->ops->status)\r\nstatus = wdd->ops->status(wdd);\r\nelse\r\nstatus = wdd->bootstatus & (WDIOF_CARDRESET |\r\nWDIOF_OVERHEAT |\r\nWDIOF_FANFAULT |\r\nWDIOF_EXTERN1 |\r\nWDIOF_EXTERN2 |\r\nWDIOF_POWERUNDER |\r\nWDIOF_POWEROVER);\r\nif (test_bit(_WDOG_ALLOW_RELEASE, &wd_data->status))\r\nstatus |= WDIOF_MAGICCLOSE;\r\nif (test_and_clear_bit(_WDOG_KEEPALIVE, &wd_data->status))\r\nstatus |= WDIOF_KEEPALIVEPING;\r\nreturn status;\r\n}\r\nstatic int watchdog_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nint err = 0;\r\nif (!(wdd->info->options & WDIOF_SETTIMEOUT))\r\nreturn -EOPNOTSUPP;\r\nif (watchdog_timeout_invalid(wdd, timeout))\r\nreturn -EINVAL;\r\nif (wdd->ops->set_timeout) {\r\nerr = wdd->ops->set_timeout(wdd, timeout);\r\n} else {\r\nwdd->timeout = timeout;\r\nif (wdd->pretimeout >= wdd->timeout)\r\nwdd->pretimeout = 0;\r\n}\r\nwatchdog_update_worker(wdd);\r\nreturn err;\r\n}\r\nstatic int watchdog_set_pretimeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nint err = 0;\r\nif (!(wdd->info->options & WDIOF_PRETIMEOUT))\r\nreturn -EOPNOTSUPP;\r\nif (watchdog_pretimeout_invalid(wdd, timeout))\r\nreturn -EINVAL;\r\nif (wdd->ops->set_pretimeout)\r\nerr = wdd->ops->set_pretimeout(wdd, timeout);\r\nelse\r\nwdd->pretimeout = timeout;\r\nreturn err;\r\n}\r\nstatic int watchdog_get_timeleft(struct watchdog_device *wdd,\r\nunsigned int *timeleft)\r\n{\r\n*timeleft = 0;\r\nif (!wdd->ops->get_timeleft)\r\nreturn -EOPNOTSUPP;\r\n*timeleft = wdd->ops->get_timeleft(wdd);\r\nreturn 0;\r\n}\r\nstatic ssize_t nowayout_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%d\n", !!test_bit(WDOG_NO_WAY_OUT, &wdd->status));\r\n}\r\nstatic ssize_t status_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nunsigned int status;\r\nmutex_lock(&wd_data->lock);\r\nstatus = watchdog_get_status(wdd);\r\nmutex_unlock(&wd_data->lock);\r\nreturn sprintf(buf, "0x%x\n", status);\r\n}\r\nstatic ssize_t bootstatus_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", wdd->bootstatus);\r\n}\r\nstatic ssize_t timeleft_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\nssize_t status;\r\nunsigned int val;\r\nmutex_lock(&wd_data->lock);\r\nstatus = watchdog_get_timeleft(wdd, &val);\r\nmutex_unlock(&wd_data->lock);\r\nif (!status)\r\nstatus = sprintf(buf, "%u\n", val);\r\nreturn status;\r\n}\r\nstatic ssize_t timeout_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", wdd->timeout);\r\n}\r\nstatic ssize_t pretimeout_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%u\n", wdd->pretimeout);\r\n}\r\nstatic ssize_t identity_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", wdd->info->identity);\r\n}\r\nstatic ssize_t state_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nif (watchdog_active(wdd))\r\nreturn sprintf(buf, "active\n");\r\nreturn sprintf(buf, "inactive\n");\r\n}\r\nstatic ssize_t pretimeout_available_governors_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn watchdog_pretimeout_available_governors_get(buf);\r\n}\r\nstatic ssize_t pretimeout_governor_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nreturn watchdog_pretimeout_governor_get(wdd, buf);\r\n}\r\nstatic ssize_t pretimeout_governor_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\nint ret = watchdog_pretimeout_governor_set(wdd, buf);\r\nif (!ret)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic umode_t wdt_is_visible(struct kobject *kobj, struct attribute *attr,\r\nint n)\r\n{\r\nstruct device *dev = container_of(kobj, struct device, kobj);\r\nstruct watchdog_device *wdd = dev_get_drvdata(dev);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_timeleft.attr && !wdd->ops->get_timeleft)\r\nmode = 0;\r\nelse if (attr == &dev_attr_pretimeout.attr &&\r\n!(wdd->info->options & WDIOF_PRETIMEOUT))\r\nmode = 0;\r\nelse if ((attr == &dev_attr_pretimeout_governor.attr ||\r\nattr == &dev_attr_pretimeout_available_governors.attr) &&\r\n(!(wdd->info->options & WDIOF_PRETIMEOUT) ||\r\n!IS_ENABLED(CONFIG_WATCHDOG_PRETIMEOUT_GOV)))\r\nmode = 0;\r\nreturn mode;\r\n}\r\nstatic int watchdog_ioctl_op(struct watchdog_device *wdd, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nif (!wdd->ops->ioctl)\r\nreturn -ENOIOCTLCMD;\r\nreturn wdd->ops->ioctl(wdd, cmd, arg);\r\n}\r\nstatic ssize_t watchdog_write(struct file *file, const char __user *data,\r\nsize_t len, loff_t *ppos)\r\n{\r\nstruct watchdog_core_data *wd_data = file->private_data;\r\nstruct watchdog_device *wdd;\r\nint err;\r\nsize_t i;\r\nchar c;\r\nif (len == 0)\r\nreturn 0;\r\nclear_bit(_WDOG_ALLOW_RELEASE, &wd_data->status);\r\nfor (i = 0; i != len; i++) {\r\nif (get_user(c, data + i))\r\nreturn -EFAULT;\r\nif (c == 'V')\r\nset_bit(_WDOG_ALLOW_RELEASE, &wd_data->status);\r\n}\r\nerr = -ENODEV;\r\nmutex_lock(&wd_data->lock);\r\nwdd = wd_data->wdd;\r\nif (wdd)\r\nerr = watchdog_ping(wdd);\r\nmutex_unlock(&wd_data->lock);\r\nif (err < 0)\r\nreturn err;\r\nreturn len;\r\n}\r\nstatic long watchdog_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct watchdog_core_data *wd_data = file->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nstruct watchdog_device *wdd;\r\nint __user *p = argp;\r\nunsigned int val;\r\nint err;\r\nmutex_lock(&wd_data->lock);\r\nwdd = wd_data->wdd;\r\nif (!wdd) {\r\nerr = -ENODEV;\r\ngoto out_ioctl;\r\n}\r\nerr = watchdog_ioctl_op(wdd, cmd, arg);\r\nif (err != -ENOIOCTLCMD)\r\ngoto out_ioctl;\r\nswitch (cmd) {\r\ncase WDIOC_GETSUPPORT:\r\nerr = copy_to_user(argp, wdd->info,\r\nsizeof(struct watchdog_info)) ? -EFAULT : 0;\r\nbreak;\r\ncase WDIOC_GETSTATUS:\r\nval = watchdog_get_status(wdd);\r\nerr = put_user(val, p);\r\nbreak;\r\ncase WDIOC_GETBOOTSTATUS:\r\nerr = put_user(wdd->bootstatus, p);\r\nbreak;\r\ncase WDIOC_SETOPTIONS:\r\nif (get_user(val, p)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (val & WDIOS_DISABLECARD) {\r\nerr = watchdog_stop(wdd);\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (val & WDIOS_ENABLECARD)\r\nerr = watchdog_start(wdd);\r\nbreak;\r\ncase WDIOC_KEEPALIVE:\r\nif (!(wdd->info->options & WDIOF_KEEPALIVEPING)) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerr = watchdog_ping(wdd);\r\nbreak;\r\ncase WDIOC_SETTIMEOUT:\r\nif (get_user(val, p)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = watchdog_set_timeout(wdd, val);\r\nif (err < 0)\r\nbreak;\r\nerr = watchdog_ping(wdd);\r\nif (err < 0)\r\nbreak;\r\ncase WDIOC_GETTIMEOUT:\r\nif (wdd->timeout == 0) {\r\nerr = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nerr = put_user(wdd->timeout, p);\r\nbreak;\r\ncase WDIOC_GETTIMELEFT:\r\nerr = watchdog_get_timeleft(wdd, &val);\r\nif (err < 0)\r\nbreak;\r\nerr = put_user(val, p);\r\nbreak;\r\ncase WDIOC_SETPRETIMEOUT:\r\nif (get_user(val, p)) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nerr = watchdog_set_pretimeout(wdd, val);\r\nbreak;\r\ncase WDIOC_GETPRETIMEOUT:\r\nerr = put_user(wdd->pretimeout, p);\r\nbreak;\r\ndefault:\r\nerr = -ENOTTY;\r\nbreak;\r\n}\r\nout_ioctl:\r\nmutex_unlock(&wd_data->lock);\r\nreturn err;\r\n}\r\nstatic int watchdog_open(struct inode *inode, struct file *file)\r\n{\r\nstruct watchdog_core_data *wd_data;\r\nstruct watchdog_device *wdd;\r\nint err;\r\nif (imajor(inode) == MISC_MAJOR)\r\nwd_data = old_wd_data;\r\nelse\r\nwd_data = container_of(inode->i_cdev, struct watchdog_core_data,\r\ncdev);\r\nif (test_and_set_bit(_WDOG_DEV_OPEN, &wd_data->status))\r\nreturn -EBUSY;\r\nwdd = wd_data->wdd;\r\nif (!watchdog_hw_running(wdd) && !try_module_get(wdd->ops->owner)) {\r\nerr = -EBUSY;\r\ngoto out_clear;\r\n}\r\nerr = watchdog_start(wdd);\r\nif (err < 0)\r\ngoto out_mod;\r\nfile->private_data = wd_data;\r\nif (!watchdog_hw_running(wdd))\r\nkref_get(&wd_data->kref);\r\nreturn nonseekable_open(inode, file);\r\nout_mod:\r\nmodule_put(wd_data->wdd->ops->owner);\r\nout_clear:\r\nclear_bit(_WDOG_DEV_OPEN, &wd_data->status);\r\nreturn err;\r\n}\r\nstatic void watchdog_core_data_release(struct kref *kref)\r\n{\r\nstruct watchdog_core_data *wd_data;\r\nwd_data = container_of(kref, struct watchdog_core_data, kref);\r\nkfree(wd_data);\r\n}\r\nstatic int watchdog_release(struct inode *inode, struct file *file)\r\n{\r\nstruct watchdog_core_data *wd_data = file->private_data;\r\nstruct watchdog_device *wdd;\r\nint err = -EBUSY;\r\nbool running;\r\nmutex_lock(&wd_data->lock);\r\nwdd = wd_data->wdd;\r\nif (!wdd)\r\ngoto done;\r\nif (!test_bit(WDOG_ACTIVE, &wdd->status))\r\nerr = 0;\r\nelse if (test_and_clear_bit(_WDOG_ALLOW_RELEASE, &wd_data->status) ||\r\n!(wdd->info->options & WDIOF_MAGICCLOSE))\r\nerr = watchdog_stop(wdd);\r\nif (err < 0) {\r\npr_crit("watchdog%d: watchdog did not stop!\n", wdd->id);\r\nwatchdog_ping(wdd);\r\n}\r\nwatchdog_update_worker(wdd);\r\nclear_bit(_WDOG_DEV_OPEN, &wd_data->status);\r\ndone:\r\nrunning = wdd && watchdog_hw_running(wdd);\r\nmutex_unlock(&wd_data->lock);\r\nif (!running) {\r\nmodule_put(wd_data->cdev.owner);\r\nkref_put(&wd_data->kref, watchdog_core_data_release);\r\n}\r\nreturn 0;\r\n}\r\nstatic int watchdog_cdev_register(struct watchdog_device *wdd, dev_t devno)\r\n{\r\nstruct watchdog_core_data *wd_data;\r\nint err;\r\nwd_data = kzalloc(sizeof(struct watchdog_core_data), GFP_KERNEL);\r\nif (!wd_data)\r\nreturn -ENOMEM;\r\nkref_init(&wd_data->kref);\r\nmutex_init(&wd_data->lock);\r\nwd_data->wdd = wdd;\r\nwdd->wd_data = wd_data;\r\nif (!watchdog_wq)\r\nreturn -ENODEV;\r\nINIT_DELAYED_WORK(&wd_data->work, watchdog_ping_work);\r\nif (wdd->id == 0) {\r\nold_wd_data = wd_data;\r\nwatchdog_miscdev.parent = wdd->parent;\r\nerr = misc_register(&watchdog_miscdev);\r\nif (err != 0) {\r\npr_err("%s: cannot register miscdev on minor=%d (err=%d).\n",\r\nwdd->info->identity, WATCHDOG_MINOR, err);\r\nif (err == -EBUSY)\r\npr_err("%s: a legacy watchdog module is probably present.\n",\r\nwdd->info->identity);\r\nold_wd_data = NULL;\r\nkfree(wd_data);\r\nreturn err;\r\n}\r\n}\r\ncdev_init(&wd_data->cdev, &watchdog_fops);\r\nwd_data->cdev.owner = wdd->ops->owner;\r\nerr = cdev_add(&wd_data->cdev, devno, 1);\r\nif (err) {\r\npr_err("watchdog%d unable to add device %d:%d\n",\r\nwdd->id, MAJOR(watchdog_devt), wdd->id);\r\nif (wdd->id == 0) {\r\nmisc_deregister(&watchdog_miscdev);\r\nold_wd_data = NULL;\r\nkref_put(&wd_data->kref, watchdog_core_data_release);\r\n}\r\nreturn err;\r\n}\r\nwd_data->last_hw_keepalive = jiffies - 1;\r\nif (watchdog_hw_running(wdd)) {\r\n__module_get(wdd->ops->owner);\r\nkref_get(&wd_data->kref);\r\nqueue_delayed_work(watchdog_wq, &wd_data->work, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void watchdog_cdev_unregister(struct watchdog_device *wdd)\r\n{\r\nstruct watchdog_core_data *wd_data = wdd->wd_data;\r\ncdev_del(&wd_data->cdev);\r\nif (wdd->id == 0) {\r\nmisc_deregister(&watchdog_miscdev);\r\nold_wd_data = NULL;\r\n}\r\nmutex_lock(&wd_data->lock);\r\nwd_data->wdd = NULL;\r\nwdd->wd_data = NULL;\r\nmutex_unlock(&wd_data->lock);\r\nif (watchdog_active(wdd) &&\r\ntest_bit(WDOG_STOP_ON_UNREGISTER, &wdd->status)) {\r\nwatchdog_stop(wdd);\r\n}\r\ncancel_delayed_work_sync(&wd_data->work);\r\nkref_put(&wd_data->kref, watchdog_core_data_release);\r\n}\r\nint watchdog_dev_register(struct watchdog_device *wdd)\r\n{\r\nstruct device *dev;\r\ndev_t devno;\r\nint ret;\r\ndevno = MKDEV(MAJOR(watchdog_devt), wdd->id);\r\nret = watchdog_cdev_register(wdd, devno);\r\nif (ret)\r\nreturn ret;\r\ndev = device_create_with_groups(&watchdog_class, wdd->parent,\r\ndevno, wdd, wdd->groups,\r\n"watchdog%d", wdd->id);\r\nif (IS_ERR(dev)) {\r\nwatchdog_cdev_unregister(wdd);\r\nreturn PTR_ERR(dev);\r\n}\r\nret = watchdog_register_pretimeout(wdd);\r\nif (ret) {\r\ndevice_destroy(&watchdog_class, devno);\r\nwatchdog_cdev_unregister(wdd);\r\n}\r\nreturn ret;\r\n}\r\nvoid watchdog_dev_unregister(struct watchdog_device *wdd)\r\n{\r\nwatchdog_unregister_pretimeout(wdd);\r\ndevice_destroy(&watchdog_class, wdd->wd_data->cdev.dev);\r\nwatchdog_cdev_unregister(wdd);\r\n}\r\nint __init watchdog_dev_init(void)\r\n{\r\nint err;\r\nwatchdog_wq = alloc_workqueue("watchdogd",\r\nWQ_HIGHPRI | WQ_MEM_RECLAIM, 0);\r\nif (!watchdog_wq) {\r\npr_err("Failed to create watchdog workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nerr = class_register(&watchdog_class);\r\nif (err < 0) {\r\npr_err("couldn't register class\n");\r\ngoto err_register;\r\n}\r\nerr = alloc_chrdev_region(&watchdog_devt, 0, MAX_DOGS, "watchdog");\r\nif (err < 0) {\r\npr_err("watchdog: unable to allocate char dev region\n");\r\ngoto err_alloc;\r\n}\r\nreturn 0;\r\nerr_alloc:\r\nclass_unregister(&watchdog_class);\r\nerr_register:\r\ndestroy_workqueue(watchdog_wq);\r\nreturn err;\r\n}\r\nvoid __exit watchdog_dev_exit(void)\r\n{\r\nunregister_chrdev_region(watchdog_devt, MAX_DOGS);\r\nclass_unregister(&watchdog_class);\r\ndestroy_workqueue(watchdog_wq);\r\n}
