static inline struct meson_pwm *to_meson_pwm(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct meson_pwm, chip);\r\n}\r\nstatic int meson_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct meson_pwm_channel *channel = pwm_get_chip_data(pwm);\r\nstruct device *dev = chip->dev;\r\nint err;\r\nif (!channel)\r\nreturn -ENODEV;\r\nif (channel->clk_parent) {\r\nerr = clk_set_parent(channel->clk, channel->clk_parent);\r\nif (err < 0) {\r\ndev_err(dev, "failed to set parent %s for %s: %d\n",\r\n__clk_get_name(channel->clk_parent),\r\n__clk_get_name(channel->clk), err);\r\nreturn err;\r\n}\r\n}\r\nerr = clk_prepare_enable(channel->clk);\r\nif (err < 0) {\r\ndev_err(dev, "failed to enable clock %s: %d\n",\r\n__clk_get_name(channel->clk), err);\r\nreturn err;\r\n}\r\nchip->ops->get_state(chip, pwm, &channel->state);\r\nreturn 0;\r\n}\r\nstatic void meson_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct meson_pwm_channel *channel = pwm_get_chip_data(pwm);\r\nif (channel)\r\nclk_disable_unprepare(channel->clk);\r\n}\r\nstatic int meson_pwm_calc(struct meson_pwm *meson,\r\nstruct meson_pwm_channel *channel, unsigned int id,\r\nunsigned int duty, unsigned int period)\r\n{\r\nunsigned int pre_div, cnt, duty_cnt;\r\nunsigned long fin_freq = -1, fin_ns;\r\nif (~(meson->inverter_mask >> id) & 0x1)\r\nduty = period - duty;\r\nif (period == channel->state.period &&\r\nduty == channel->state.duty_cycle)\r\nreturn 0;\r\nfin_freq = clk_get_rate(channel->clk);\r\nif (fin_freq == 0) {\r\ndev_err(meson->chip.dev, "invalid source clock frequency\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(meson->chip.dev, "fin_freq: %lu Hz\n", fin_freq);\r\nfin_ns = NSEC_PER_SEC / fin_freq;\r\nfor (pre_div = 0; pre_div < MISC_CLK_DIV_MASK; pre_div++) {\r\ncnt = DIV_ROUND_CLOSEST(period, fin_ns * (pre_div + 1));\r\ndev_dbg(meson->chip.dev, "fin_ns=%lu pre_div=%u cnt=%u\n",\r\nfin_ns, pre_div, cnt);\r\nif (cnt <= 0xffff)\r\nbreak;\r\n}\r\nif (pre_div == MISC_CLK_DIV_MASK) {\r\ndev_err(meson->chip.dev, "unable to get period pre_div\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(meson->chip.dev, "period=%u pre_div=%u cnt=%u\n", period,\r\npre_div, cnt);\r\nif (duty == period) {\r\nchannel->pre_div = pre_div;\r\nchannel->hi = cnt;\r\nchannel->lo = 0;\r\n} else if (duty == 0) {\r\nchannel->pre_div = pre_div;\r\nchannel->hi = 0;\r\nchannel->lo = cnt;\r\n} else {\r\nduty_cnt = DIV_ROUND_CLOSEST(duty, fin_ns * (pre_div + 1));\r\nif (duty_cnt > 0xffff) {\r\ndev_err(meson->chip.dev, "unable to get duty cycle\n");\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(meson->chip.dev, "duty=%u pre_div=%u duty_cnt=%u\n",\r\nduty, pre_div, duty_cnt);\r\nchannel->pre_div = pre_div;\r\nchannel->hi = duty_cnt;\r\nchannel->lo = cnt - duty_cnt;\r\n}\r\nreturn 0;\r\n}\r\nstatic void meson_pwm_enable(struct meson_pwm *meson,\r\nstruct meson_pwm_channel *channel,\r\nunsigned int id)\r\n{\r\nu32 value, clk_shift, clk_enable, enable;\r\nunsigned int offset;\r\nswitch (id) {\r\ncase 0:\r\nclk_shift = MISC_A_CLK_DIV_SHIFT;\r\nclk_enable = MISC_A_CLK_EN;\r\nenable = MISC_A_EN;\r\noffset = REG_PWM_A;\r\nbreak;\r\ncase 1:\r\nclk_shift = MISC_B_CLK_DIV_SHIFT;\r\nclk_enable = MISC_B_CLK_EN;\r\nenable = MISC_B_EN;\r\noffset = REG_PWM_B;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nvalue = readl(meson->base + REG_MISC_AB);\r\nvalue &= ~(MISC_CLK_DIV_MASK << clk_shift);\r\nvalue |= channel->pre_div << clk_shift;\r\nvalue |= clk_enable;\r\nwritel(value, meson->base + REG_MISC_AB);\r\nvalue = (channel->hi << PWM_HIGH_SHIFT) | channel->lo;\r\nwritel(value, meson->base + offset);\r\nvalue = readl(meson->base + REG_MISC_AB);\r\nvalue |= enable;\r\nwritel(value, meson->base + REG_MISC_AB);\r\n}\r\nstatic void meson_pwm_disable(struct meson_pwm *meson, unsigned int id)\r\n{\r\nu32 value, enable;\r\nswitch (id) {\r\ncase 0:\r\nenable = MISC_A_EN;\r\nbreak;\r\ncase 1:\r\nenable = MISC_B_EN;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nvalue = readl(meson->base + REG_MISC_AB);\r\nvalue &= ~enable;\r\nwritel(value, meson->base + REG_MISC_AB);\r\n}\r\nstatic int meson_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct meson_pwm_channel *channel = pwm_get_chip_data(pwm);\r\nstruct meson_pwm *meson = to_meson_pwm(chip);\r\nunsigned long flags;\r\nint err = 0;\r\nif (!state)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&meson->lock, flags);\r\nif (!state->enabled) {\r\nmeson_pwm_disable(meson, pwm->hwpwm);\r\nchannel->state.enabled = false;\r\ngoto unlock;\r\n}\r\nif (state->period != channel->state.period ||\r\nstate->duty_cycle != channel->state.duty_cycle ||\r\nstate->polarity != channel->state.polarity) {\r\nif (channel->state.enabled) {\r\nmeson_pwm_disable(meson, pwm->hwpwm);\r\nchannel->state.enabled = false;\r\n}\r\nif (state->polarity != channel->state.polarity) {\r\nif (state->polarity == PWM_POLARITY_NORMAL)\r\nmeson->inverter_mask |= BIT(pwm->hwpwm);\r\nelse\r\nmeson->inverter_mask &= ~BIT(pwm->hwpwm);\r\n}\r\nerr = meson_pwm_calc(meson, channel, pwm->hwpwm,\r\nstate->duty_cycle, state->period);\r\nif (err < 0)\r\ngoto unlock;\r\nchannel->state.polarity = state->polarity;\r\nchannel->state.period = state->period;\r\nchannel->state.duty_cycle = state->duty_cycle;\r\n}\r\nif (state->enabled && !channel->state.enabled) {\r\nmeson_pwm_enable(meson, channel, pwm->hwpwm);\r\nchannel->state.enabled = true;\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&meson->lock, flags);\r\nreturn err;\r\n}\r\nstatic void meson_pwm_get_state(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct meson_pwm *meson = to_meson_pwm(chip);\r\nu32 value, mask;\r\nif (!state)\r\nreturn;\r\nswitch (pwm->hwpwm) {\r\ncase 0:\r\nmask = MISC_A_EN;\r\nbreak;\r\ncase 1:\r\nmask = MISC_B_EN;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nvalue = readl(meson->base + REG_MISC_AB);\r\nstate->enabled = (value & mask) != 0;\r\n}\r\nstatic int meson_pwm_init_channels(struct meson_pwm *meson,\r\nstruct meson_pwm_channel *channels)\r\n{\r\nstruct device *dev = meson->chip.dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct clk_init_data init;\r\nunsigned int i;\r\nchar name[255];\r\nint err;\r\nfor (i = 0; i < meson->chip.npwm; i++) {\r\nstruct meson_pwm_channel *channel = &channels[i];\r\nsnprintf(name, sizeof(name), "%s#mux%u", np->full_name, i);\r\ninit.name = name;\r\ninit.ops = &clk_mux_ops;\r\ninit.flags = CLK_IS_BASIC;\r\ninit.parent_names = meson->data->parent_names;\r\ninit.num_parents = 1 << MISC_CLK_SEL_WIDTH;\r\nchannel->mux.reg = meson->base + REG_MISC_AB;\r\nchannel->mux.shift = mux_reg_shifts[i];\r\nchannel->mux.mask = BIT(MISC_CLK_SEL_WIDTH) - 1;\r\nchannel->mux.flags = 0;\r\nchannel->mux.lock = &meson->lock;\r\nchannel->mux.table = NULL;\r\nchannel->mux.hw.init = &init;\r\nchannel->clk = devm_clk_register(dev, &channel->mux.hw);\r\nif (IS_ERR(channel->clk)) {\r\nerr = PTR_ERR(channel->clk);\r\ndev_err(dev, "failed to register %s: %d\n", name, err);\r\nreturn err;\r\n}\r\nsnprintf(name, sizeof(name), "clkin%u", i);\r\nchannel->clk_parent = devm_clk_get(dev, name);\r\nif (IS_ERR(channel->clk_parent)) {\r\nerr = PTR_ERR(channel->clk_parent);\r\nif (err == -EPROBE_DEFER)\r\nreturn err;\r\nchannel->clk_parent = NULL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void meson_pwm_add_channels(struct meson_pwm *meson,\r\nstruct meson_pwm_channel *channels)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < meson->chip.npwm; i++)\r\npwm_set_chip_data(&meson->chip.pwms[i], &channels[i]);\r\n}\r\nstatic int meson_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct meson_pwm_channel *channels;\r\nstruct meson_pwm *meson;\r\nstruct resource *regs;\r\nint err;\r\nmeson = devm_kzalloc(&pdev->dev, sizeof(*meson), GFP_KERNEL);\r\nif (!meson)\r\nreturn -ENOMEM;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nmeson->base = devm_ioremap_resource(&pdev->dev, regs);\r\nif (IS_ERR(meson->base))\r\nreturn PTR_ERR(meson->base);\r\nspin_lock_init(&meson->lock);\r\nmeson->chip.dev = &pdev->dev;\r\nmeson->chip.ops = &meson_pwm_ops;\r\nmeson->chip.base = -1;\r\nmeson->chip.npwm = 2;\r\nmeson->chip.of_xlate = of_pwm_xlate_with_flags;\r\nmeson->chip.of_pwm_n_cells = 3;\r\nmeson->data = of_device_get_match_data(&pdev->dev);\r\nmeson->inverter_mask = BIT(meson->chip.npwm) - 1;\r\nchannels = devm_kcalloc(&pdev->dev, meson->chip.npwm, sizeof(*meson),\r\nGFP_KERNEL);\r\nif (!channels)\r\nreturn -ENOMEM;\r\nerr = meson_pwm_init_channels(meson, channels);\r\nif (err < 0)\r\nreturn err;\r\nerr = pwmchip_add(&meson->chip);\r\nif (err < 0) {\r\ndev_err(&pdev->dev, "failed to register PWM chip: %d\n", err);\r\nreturn err;\r\n}\r\nmeson_pwm_add_channels(meson, channels);\r\nplatform_set_drvdata(pdev, meson);\r\nreturn 0;\r\n}\r\nstatic int meson_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct meson_pwm *meson = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&meson->chip);\r\n}
