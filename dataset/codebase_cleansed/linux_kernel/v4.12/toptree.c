struct toptree __ref *toptree_alloc(int level, int id)\r\n{\r\nstruct toptree *res;\r\nif (slab_is_available())\r\nres = kzalloc(sizeof(*res), GFP_KERNEL);\r\nelse\r\nres = memblock_virt_alloc(sizeof(*res), 8);\r\nif (!res)\r\nreturn res;\r\nINIT_LIST_HEAD(&res->children);\r\nINIT_LIST_HEAD(&res->sibling);\r\ncpumask_clear(&res->mask);\r\nres->level = level;\r\nres->id = id;\r\nreturn res;\r\n}\r\nstatic void toptree_remove(struct toptree *cand)\r\n{\r\nstruct toptree *oldparent;\r\nlist_del_init(&cand->sibling);\r\noldparent = cand->parent;\r\ncand->parent = NULL;\r\ntoptree_update_mask(oldparent);\r\n}\r\nvoid __ref toptree_free(struct toptree *cand)\r\n{\r\nstruct toptree *child, *tmp;\r\nif (cand->parent)\r\ntoptree_remove(cand);\r\ntoptree_for_each_child_safe(child, tmp, cand)\r\ntoptree_free(child);\r\nif (slab_is_available())\r\nkfree(cand);\r\nelse\r\nmemblock_free_early((unsigned long)cand, sizeof(*cand));\r\n}\r\nvoid toptree_update_mask(struct toptree *cand)\r\n{\r\nstruct toptree *child;\r\ncpumask_clear(&cand->mask);\r\nlist_for_each_entry(child, &cand->children, sibling)\r\ncpumask_or(&cand->mask, &cand->mask, &child->mask);\r\nif (cand->parent)\r\ntoptree_update_mask(cand->parent);\r\n}\r\nstatic int toptree_insert(struct toptree *cand, struct toptree *target)\r\n{\r\nif (!cand || !target)\r\nreturn -1;\r\nif (target->level != (cand->level + 1))\r\nreturn -1;\r\nlist_add_tail(&cand->sibling, &target->children);\r\ncand->parent = target;\r\ntoptree_update_mask(target);\r\nreturn 0;\r\n}\r\nstatic void toptree_move_children(struct toptree *cand, struct toptree *target)\r\n{\r\nstruct toptree *child, *tmp;\r\ntoptree_for_each_child_safe(child, tmp, cand)\r\ntoptree_move(child, target);\r\n}\r\nvoid toptree_unify(struct toptree *cand)\r\n{\r\nstruct toptree *child, *tmp, *cand_copy;\r\nif (cand->level < 2)\r\nreturn;\r\ncand_copy = toptree_alloc(cand->level, 0);\r\ntoptree_for_each_child_safe(child, tmp, cand) {\r\nstruct toptree *tmpchild;\r\nif (!cpumask_empty(&child->mask)) {\r\ntmpchild = toptree_get_child(cand_copy, child->id);\r\ntoptree_move_children(child, tmpchild);\r\n}\r\ntoptree_free(child);\r\n}\r\ntoptree_move_children(cand_copy, cand);\r\ntoptree_free(cand_copy);\r\ntoptree_for_each_child(child, cand)\r\ntoptree_unify(child);\r\n}\r\nvoid toptree_move(struct toptree *cand, struct toptree *target)\r\n{\r\nstruct toptree *stack_target, *real_insert_point, *ptr, *tmp;\r\nif (cand->level + 1 == target->level) {\r\ntoptree_remove(cand);\r\ntoptree_insert(cand, target);\r\nreturn;\r\n}\r\nreal_insert_point = NULL;\r\nptr = cand;\r\nstack_target = NULL;\r\ndo {\r\ntmp = stack_target;\r\nstack_target = toptree_alloc(ptr->level + 1,\r\nptr->parent->id);\r\ntoptree_insert(tmp, stack_target);\r\nif (!real_insert_point)\r\nreal_insert_point = stack_target;\r\nptr = ptr->parent;\r\n} while (stack_target->level < (target->level - 1));\r\ntoptree_remove(cand);\r\ntoptree_insert(cand, real_insert_point);\r\ntoptree_insert(stack_target, target);\r\n}\r\nstruct toptree *toptree_get_child(struct toptree *cand, int id)\r\n{\r\nstruct toptree *child;\r\ntoptree_for_each_child(child, cand)\r\nif (child->id == id)\r\nreturn child;\r\nchild = toptree_alloc(cand->level-1, id);\r\ntoptree_insert(child, cand);\r\nreturn child;\r\n}\r\nstruct toptree *toptree_first(struct toptree *context, int level)\r\n{\r\nstruct toptree *child, *tmp;\r\nif (context->level == level)\r\nreturn context;\r\nif (!list_empty(&context->children)) {\r\nlist_for_each_entry(child, &context->children, sibling) {\r\ntmp = toptree_first(child, level);\r\nif (tmp)\r\nreturn tmp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct toptree *toptree_next_sibling(struct toptree *cur)\r\n{\r\nif (cur->parent == NULL)\r\nreturn NULL;\r\nif (cur == list_last_entry(&cur->parent->children,\r\nstruct toptree, sibling))\r\nreturn NULL;\r\nreturn (struct toptree *) list_next_entry(cur, sibling);\r\n}\r\nstruct toptree *toptree_next(struct toptree *cur, struct toptree *context,\r\nint level)\r\n{\r\nstruct toptree *cur_context, *tmp;\r\nif (!cur)\r\nreturn NULL;\r\nif (context->level == level)\r\nreturn NULL;\r\ntmp = toptree_next_sibling(cur);\r\nif (tmp != NULL)\r\nreturn tmp;\r\ncur_context = cur;\r\nwhile (cur_context->level < context->level - 1) {\r\ncur_context = cur_context->parent;\r\ntmp = toptree_next_sibling(cur_context);\r\nif (tmp != NULL) {\r\ntmp = toptree_first(tmp, level);\r\nif (tmp != NULL)\r\nreturn tmp;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint toptree_count(struct toptree *context, int level)\r\n{\r\nstruct toptree *cur;\r\nint cnt = 0;\r\ntoptree_for_each(cur, context, level)\r\ncnt++;\r\nreturn cnt;\r\n}
