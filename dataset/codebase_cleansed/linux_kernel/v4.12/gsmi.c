static struct gsmi_buf *gsmi_buf_alloc(void)\r\n{\r\nstruct gsmi_buf *smibuf;\r\nsmibuf = kzalloc(sizeof(*smibuf), GFP_KERNEL);\r\nif (!smibuf) {\r\nprintk(KERN_ERR "gsmi: out of memory\n");\r\nreturn NULL;\r\n}\r\nsmibuf->start = dma_pool_alloc(gsmi_dev.dma_pool, GFP_KERNEL,\r\n&smibuf->handle);\r\nif (!smibuf->start) {\r\nprintk(KERN_ERR "gsmi: failed to allocate name buffer\n");\r\nkfree(smibuf);\r\nreturn NULL;\r\n}\r\nsmibuf->length = GSMI_BUF_SIZE;\r\nsmibuf->address = (u32)virt_to_phys(smibuf->start);\r\nreturn smibuf;\r\n}\r\nstatic void gsmi_buf_free(struct gsmi_buf *smibuf)\r\n{\r\nif (smibuf) {\r\nif (smibuf->start)\r\ndma_pool_free(gsmi_dev.dma_pool, smibuf->start,\r\nsmibuf->handle);\r\nkfree(smibuf);\r\n}\r\n}\r\nstatic int gsmi_exec(u8 func, u8 sub)\r\n{\r\nu16 cmd = (sub << 8) | func;\r\nu16 result = 0;\r\nint rc = 0;\r\nif (gsmi_dev.handshake_type == GSMI_HANDSHAKE_CF) {\r\nasm volatile (\r\n"stc\n"\r\n"outb %%al, %%dx\n"\r\n"1: jc 1b\n"\r\n: "=a" (result)\r\n: "0" (cmd),\r\n"d" (gsmi_dev.smi_cmd),\r\n"b" (gsmi_dev.param_buf->address)\r\n: "memory", "cc"\r\n);\r\n} else if (gsmi_dev.handshake_type == GSMI_HANDSHAKE_SPIN) {\r\nasm volatile (\r\n"outb %%al, %%dx\n"\r\n"1: loop 1b\n"\r\n: "=a" (result)\r\n: "0" (cmd),\r\n"d" (gsmi_dev.smi_cmd),\r\n"b" (gsmi_dev.param_buf->address),\r\n"c" (spincount)\r\n: "memory", "cc"\r\n);\r\n} else {\r\nasm volatile (\r\n"outb %%al, %%dx\n\t"\r\n: "=a" (result)\r\n: "0" (cmd),\r\n"d" (gsmi_dev.smi_cmd),\r\n"b" (gsmi_dev.param_buf->address)\r\n: "memory", "cc"\r\n);\r\n}\r\nswitch (result) {\r\ncase GSMI_SUCCESS:\r\nbreak;\r\ncase GSMI_VAR_NOT_FOUND:\r\nrc = 1;\r\nbreak;\r\ncase GSMI_INVALID_PARAMETER:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Invalid parameter\n", cmd);\r\nrc = -EINVAL;\r\nbreak;\r\ncase GSMI_BUFFER_TOO_SMALL:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Buffer too small\n", cmd);\r\nrc = -ENOMEM;\r\nbreak;\r\ncase GSMI_UNSUPPORTED:\r\ncase GSMI_UNSUPPORTED2:\r\nif (sub != GSMI_CMD_HANDSHAKE_TYPE)\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Not supported\n",\r\ncmd);\r\nrc = -ENOSYS;\r\nbreak;\r\ncase GSMI_NOT_READY:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Not ready\n", cmd);\r\nrc = -EBUSY;\r\nbreak;\r\ncase GSMI_DEVICE_ERROR:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Device error\n", cmd);\r\nrc = -EFAULT;\r\nbreak;\r\ncase GSMI_NOT_FOUND:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Data not found\n", cmd);\r\nrc = -ENOENT;\r\nbreak;\r\ncase GSMI_LOG_FULL:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Log full\n", cmd);\r\nrc = -ENOSPC;\r\nbreak;\r\ncase GSMI_HANDSHAKE_CF:\r\ncase GSMI_HANDSHAKE_SPIN:\r\ncase GSMI_HANDSHAKE_NONE:\r\nrc = result;\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "gsmi: exec 0x%04x: Unknown error 0x%04x\n",\r\ncmd, result);\r\nrc = -ENXIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic efi_status_t gsmi_get_variable(efi_char16_t *name,\r\nefi_guid_t *vendor, u32 *attr,\r\nunsigned long *data_size,\r\nvoid *data)\r\n{\r\nstruct gsmi_nvram_var_param param = {\r\n.name_ptr = gsmi_dev.name_buf->address,\r\n.data_ptr = gsmi_dev.data_buf->address,\r\n.data_len = (u32)*data_size,\r\n};\r\nefi_status_t ret = EFI_SUCCESS;\r\nunsigned long flags;\r\nsize_t name_len = ucs2_strnlen(name, GSMI_BUF_SIZE / 2);\r\nint rc;\r\nif (name_len >= GSMI_BUF_SIZE / 2)\r\nreturn EFI_BAD_BUFFER_SIZE;\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nmemcpy(&param.guid, vendor, sizeof(param.guid));\r\nmemset(gsmi_dev.name_buf->start, 0, gsmi_dev.name_buf->length);\r\nmemcpy(gsmi_dev.name_buf->start, name, name_len * 2);\r\nmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_GET_NVRAM_VAR);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "gsmi: Get Variable failed\n");\r\nret = EFI_LOAD_ERROR;\r\n} else if (rc == 1) {\r\nret = EFI_NOT_FOUND;\r\n} else {\r\nmemcpy(&param, gsmi_dev.param_buf->start, sizeof(param));\r\n*data_size = min_t(unsigned long, *data_size,\r\ngsmi_dev.data_buf->length);\r\n*data_size = min_t(unsigned long, *data_size, param.data_len);\r\nmemcpy(data, gsmi_dev.data_buf->start, *data_size);\r\n*attr = EFI_VARIABLE_NON_VOLATILE |\r\nEFI_VARIABLE_BOOTSERVICE_ACCESS |\r\nEFI_VARIABLE_RUNTIME_ACCESS;\r\n}\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nreturn ret;\r\n}\r\nstatic efi_status_t gsmi_get_next_variable(unsigned long *name_size,\r\nefi_char16_t *name,\r\nefi_guid_t *vendor)\r\n{\r\nstruct gsmi_get_next_var_param param = {\r\n.name_ptr = gsmi_dev.name_buf->address,\r\n.name_len = gsmi_dev.name_buf->length,\r\n};\r\nefi_status_t ret = EFI_SUCCESS;\r\nint rc;\r\nunsigned long flags;\r\nif (*name_size != GSMI_BUF_SIZE)\r\nreturn EFI_BAD_BUFFER_SIZE;\r\nif (ucs2_strnlen(name, GSMI_BUF_SIZE / 2) == GSMI_BUF_SIZE / 2)\r\nreturn EFI_INVALID_PARAMETER;\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nmemcpy(&param.guid, vendor, sizeof(param.guid));\r\nmemcpy(gsmi_dev.name_buf->start, name, *name_size);\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_GET_NEXT_VAR);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "gsmi: Get Next Variable Name failed\n");\r\nret = EFI_LOAD_ERROR;\r\n} else if (rc == 1) {\r\nret = EFI_NOT_FOUND;\r\n} else {\r\nmemcpy(&param, gsmi_dev.param_buf->start, sizeof(param));\r\nmemcpy(name, gsmi_dev.name_buf->start, GSMI_BUF_SIZE);\r\n*name_size = ucs2_strnlen(name, GSMI_BUF_SIZE / 2) * 2;\r\nmemcpy(vendor, &param.guid, sizeof(param.guid));\r\nret = EFI_SUCCESS;\r\n}\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nreturn ret;\r\n}\r\nstatic efi_status_t gsmi_set_variable(efi_char16_t *name,\r\nefi_guid_t *vendor,\r\nu32 attr,\r\nunsigned long data_size,\r\nvoid *data)\r\n{\r\nstruct gsmi_nvram_var_param param = {\r\n.name_ptr = gsmi_dev.name_buf->address,\r\n.data_ptr = gsmi_dev.data_buf->address,\r\n.data_len = (u32)data_size,\r\n.attributes = EFI_VARIABLE_NON_VOLATILE |\r\nEFI_VARIABLE_BOOTSERVICE_ACCESS |\r\nEFI_VARIABLE_RUNTIME_ACCESS,\r\n};\r\nsize_t name_len = ucs2_strnlen(name, GSMI_BUF_SIZE / 2);\r\nefi_status_t ret = EFI_SUCCESS;\r\nint rc;\r\nunsigned long flags;\r\nif (name_len >= GSMI_BUF_SIZE / 2)\r\nreturn EFI_BAD_BUFFER_SIZE;\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nmemcpy(&param.guid, vendor, sizeof(param.guid));\r\nmemset(gsmi_dev.name_buf->start, 0, gsmi_dev.name_buf->length);\r\nmemcpy(gsmi_dev.name_buf->start, name, name_len * 2);\r\nmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\r\nmemcpy(gsmi_dev.data_buf->start, data, data_size);\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_SET_NVRAM_VAR);\r\nif (rc < 0) {\r\nprintk(KERN_ERR "gsmi: Set Variable failed\n");\r\nret = EFI_INVALID_PARAMETER;\r\n}\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nreturn ret;\r\n}\r\nstatic ssize_t eventlog_write(struct file *filp, struct kobject *kobj,\r\nstruct bin_attribute *bin_attr,\r\nchar *buf, loff_t pos, size_t count)\r\n{\r\nstruct gsmi_set_eventlog_param param = {\r\n.data_ptr = gsmi_dev.data_buf->address,\r\n};\r\nint rc = 0;\r\nunsigned long flags;\r\nif (count < sizeof(u32))\r\nreturn -EINVAL;\r\nparam.type = *(u32 *)buf;\r\ncount -= sizeof(u32);\r\nbuf += sizeof(u32);\r\nif (count > gsmi_dev.data_buf->length)\r\nreturn -EINVAL;\r\nparam.data_len = count - sizeof(u32);\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\r\nmemcpy(gsmi_dev.data_buf->start, buf, param.data_len);\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_SET_EVENT_LOG);\r\nif (rc < 0)\r\nprintk(KERN_ERR "gsmi: Set Event Log failed\n");\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nreturn rc;\r\n}\r\nstatic ssize_t gsmi_clear_eventlog_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nunsigned long val;\r\nstruct {\r\nu32 percentage;\r\nu32 data_type;\r\n} param;\r\nrc = kstrtoul(buf, 0, &val);\r\nif (rc)\r\nreturn rc;\r\nif (val > 100)\r\nreturn -EINVAL;\r\nparam.percentage = val;\r\nparam.data_type = 0;\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_CLEAR_EVENT_LOG);\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic ssize_t gsmi_clear_config_store(struct kobject *kobj,\r\nstruct kobj_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint rc;\r\nunsigned long flags;\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_CLEAR_CONFIG);\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nif (rc)\r\nreturn rc;\r\nreturn count;\r\n}\r\nstatic int gsmi_shutdown_reason(int reason)\r\n{\r\nstruct gsmi_log_entry_type_1 entry = {\r\n.type = GSMI_LOG_ENTRY_TYPE_KERNEL,\r\n.instance = reason,\r\n};\r\nstruct gsmi_set_eventlog_param param = {\r\n.data_len = sizeof(entry),\r\n.type = 1,\r\n};\r\nstatic int saved_reason;\r\nint rc = 0;\r\nunsigned long flags;\r\nif (saved_reason & (1 << reason))\r\nreturn 0;\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\nsaved_reason |= (1 << reason);\r\nmemset(gsmi_dev.data_buf->start, 0, gsmi_dev.data_buf->length);\r\nmemcpy(gsmi_dev.data_buf->start, &entry, sizeof(entry));\r\nparam.data_ptr = gsmi_dev.data_buf->address;\r\nmemset(gsmi_dev.param_buf->start, 0, gsmi_dev.param_buf->length);\r\nmemcpy(gsmi_dev.param_buf->start, &param, sizeof(param));\r\nrc = gsmi_exec(GSMI_CALLBACK, GSMI_CMD_SET_EVENT_LOG);\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nif (rc < 0)\r\nprintk(KERN_ERR "gsmi: Log Shutdown Reason failed\n");\r\nelse\r\nprintk(KERN_EMERG "gsmi: Log Shutdown Reason 0x%02x\n",\r\nreason);\r\nreturn rc;\r\n}\r\nstatic int gsmi_reboot_callback(struct notifier_block *nb,\r\nunsigned long reason, void *arg)\r\n{\r\ngsmi_shutdown_reason(GSMI_SHUTDOWN_CLEAN);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int gsmi_die_callback(struct notifier_block *nb,\r\nunsigned long reason, void *arg)\r\n{\r\nif (reason == DIE_OOPS)\r\ngsmi_shutdown_reason(GSMI_SHUTDOWN_OOPS);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int gsmi_panic_callback(struct notifier_block *nb,\r\nunsigned long reason, void *arg)\r\n{\r\ngsmi_shutdown_reason(GSMI_SHUTDOWN_PANIC);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic u64 __init local_hash_64(u64 val, unsigned bits)\r\n{\r\nu64 hash = val;\r\nu64 n = hash;\r\nn <<= 18;\r\nhash -= n;\r\nn <<= 33;\r\nhash -= n;\r\nn <<= 3;\r\nhash += n;\r\nn <<= 3;\r\nhash -= n;\r\nn <<= 4;\r\nhash += n;\r\nn <<= 2;\r\nhash += n;\r\nreturn hash >> (64 - bits);\r\n}\r\nstatic u32 __init hash_oem_table_id(char s[8])\r\n{\r\nu64 input;\r\nmemcpy(&input, s, 8);\r\nreturn local_hash_64(input, 32);\r\n}\r\nstatic __init int gsmi_system_valid(void)\r\n{\r\nu32 hash;\r\nif (!dmi_check_system(gsmi_dmi_table))\r\nreturn -ENODEV;\r\nif (!strncmp(acpi_gbl_FADT.header.oem_table_id, "FACP", 4)) {\r\nprintk(KERN_INFO "gsmi: Board is too old\n");\r\nreturn -ENODEV;\r\n}\r\nhash = hash_oem_table_id(acpi_gbl_FADT.header.oem_table_id);\r\nif (hash == QUIRKY_BOARD_HASH) {\r\nconst char *bios_ver = dmi_get_system_info(DMI_BIOS_VERSION);\r\nif (strncmp(bios_ver, "1.0", 3) == 0) {\r\npr_info("gsmi: disabled on this board's BIOS %s\n",\r\nbios_ver);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (acpi_gbl_FADT.smi_command == 0) {\r\npr_info("gsmi: missing smi_command\n");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic __init int gsmi_init(void)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nret = gsmi_system_valid();\r\nif (ret)\r\nreturn ret;\r\ngsmi_dev.smi_cmd = acpi_gbl_FADT.smi_command;\r\ngsmi_dev.pdev = platform_device_register_full(&gsmi_dev_info);\r\nif (IS_ERR(gsmi_dev.pdev)) {\r\nprintk(KERN_ERR "gsmi: unable to register platform device\n");\r\nreturn PTR_ERR(gsmi_dev.pdev);\r\n}\r\nspin_lock_init(&gsmi_dev.lock);\r\nret = -ENOMEM;\r\ngsmi_dev.dma_pool = dma_pool_create("gsmi", &gsmi_dev.pdev->dev,\r\nGSMI_BUF_SIZE, GSMI_BUF_ALIGN, 0);\r\nif (!gsmi_dev.dma_pool)\r\ngoto out_err;\r\ngsmi_dev.name_buf = gsmi_buf_alloc();\r\nif (!gsmi_dev.name_buf) {\r\nprintk(KERN_ERR "gsmi: failed to allocate name buffer\n");\r\ngoto out_err;\r\n}\r\ngsmi_dev.data_buf = gsmi_buf_alloc();\r\nif (!gsmi_dev.data_buf) {\r\nprintk(KERN_ERR "gsmi: failed to allocate data buffer\n");\r\ngoto out_err;\r\n}\r\ngsmi_dev.param_buf = gsmi_buf_alloc();\r\nif (!gsmi_dev.param_buf) {\r\nprintk(KERN_ERR "gsmi: failed to allocate param buffer\n");\r\ngoto out_err;\r\n}\r\nspin_lock_irqsave(&gsmi_dev.lock, flags);\r\ngsmi_dev.handshake_type = GSMI_HANDSHAKE_SPIN;\r\ngsmi_dev.handshake_type =\r\ngsmi_exec(GSMI_CALLBACK, GSMI_CMD_HANDSHAKE_TYPE);\r\nif (gsmi_dev.handshake_type == -ENOSYS)\r\ngsmi_dev.handshake_type = GSMI_HANDSHAKE_NONE;\r\nspin_unlock_irqrestore(&gsmi_dev.lock, flags);\r\nif (gsmi_dev.handshake_type == -ENXIO) {\r\nprintk(KERN_INFO "gsmi version " DRIVER_VERSION\r\n" failed to load\n");\r\nret = -ENODEV;\r\ngoto out_err;\r\n}\r\nret = -ENOMEM;\r\ngsmi_kobj = kobject_create_and_add("gsmi", firmware_kobj);\r\nif (!gsmi_kobj) {\r\nprintk(KERN_INFO "gsmi: Failed to create firmware kobj\n");\r\ngoto out_err;\r\n}\r\nret = sysfs_create_bin_file(gsmi_kobj, &eventlog_bin_attr);\r\nif (ret) {\r\nprintk(KERN_INFO "gsmi: Failed to setup eventlog");\r\ngoto out_err;\r\n}\r\nret = sysfs_create_files(gsmi_kobj, gsmi_attrs);\r\nif (ret) {\r\nprintk(KERN_INFO "gsmi: Failed to add attrs");\r\ngoto out_remove_bin_file;\r\n}\r\nret = efivars_register(&efivars, &efivar_ops, gsmi_kobj);\r\nif (ret) {\r\nprintk(KERN_INFO "gsmi: Failed to register efivars\n");\r\ngoto out_remove_sysfs_files;\r\n}\r\nregister_reboot_notifier(&gsmi_reboot_notifier);\r\nregister_die_notifier(&gsmi_die_notifier);\r\natomic_notifier_chain_register(&panic_notifier_list,\r\n&gsmi_panic_notifier);\r\nprintk(KERN_INFO "gsmi version " DRIVER_VERSION " loaded\n");\r\nreturn 0;\r\nout_remove_sysfs_files:\r\nsysfs_remove_files(gsmi_kobj, gsmi_attrs);\r\nout_remove_bin_file:\r\nsysfs_remove_bin_file(gsmi_kobj, &eventlog_bin_attr);\r\nout_err:\r\nkobject_put(gsmi_kobj);\r\ngsmi_buf_free(gsmi_dev.param_buf);\r\ngsmi_buf_free(gsmi_dev.data_buf);\r\ngsmi_buf_free(gsmi_dev.name_buf);\r\ndma_pool_destroy(gsmi_dev.dma_pool);\r\nplatform_device_unregister(gsmi_dev.pdev);\r\npr_info("gsmi: failed to load: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void __exit gsmi_exit(void)\r\n{\r\nunregister_reboot_notifier(&gsmi_reboot_notifier);\r\nunregister_die_notifier(&gsmi_die_notifier);\r\natomic_notifier_chain_unregister(&panic_notifier_list,\r\n&gsmi_panic_notifier);\r\nefivars_unregister(&efivars);\r\nsysfs_remove_files(gsmi_kobj, gsmi_attrs);\r\nsysfs_remove_bin_file(gsmi_kobj, &eventlog_bin_attr);\r\nkobject_put(gsmi_kobj);\r\ngsmi_buf_free(gsmi_dev.param_buf);\r\ngsmi_buf_free(gsmi_dev.data_buf);\r\ngsmi_buf_free(gsmi_dev.name_buf);\r\ndma_pool_destroy(gsmi_dev.dma_pool);\r\nplatform_device_unregister(gsmi_dev.pdev);\r\n}
