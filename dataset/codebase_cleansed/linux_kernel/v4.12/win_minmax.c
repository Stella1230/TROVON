static u32 minmax_subwin_update(struct minmax *m, u32 win,\r\nconst struct minmax_sample *val)\r\n{\r\nu32 dt = val->t - m->s[0].t;\r\nif (unlikely(dt > win)) {\r\nm->s[0] = m->s[1];\r\nm->s[1] = m->s[2];\r\nm->s[2] = *val;\r\nif (unlikely(val->t - m->s[0].t > win)) {\r\nm->s[0] = m->s[1];\r\nm->s[1] = m->s[2];\r\nm->s[2] = *val;\r\n}\r\n} else if (unlikely(m->s[1].t == m->s[0].t) && dt > win/4) {\r\nm->s[2] = m->s[1] = *val;\r\n} else if (unlikely(m->s[2].t == m->s[1].t) && dt > win/2) {\r\nm->s[2] = *val;\r\n}\r\nreturn m->s[0].v;\r\n}\r\nu32 minmax_running_max(struct minmax *m, u32 win, u32 t, u32 meas)\r\n{\r\nstruct minmax_sample val = { .t = t, .v = meas };\r\nif (unlikely(val.v >= m->s[0].v) ||\r\nunlikely(val.t - m->s[2].t > win))\r\nreturn minmax_reset(m, t, meas);\r\nif (unlikely(val.v >= m->s[1].v))\r\nm->s[2] = m->s[1] = val;\r\nelse if (unlikely(val.v >= m->s[2].v))\r\nm->s[2] = val;\r\nreturn minmax_subwin_update(m, win, &val);\r\n}\r\nu32 minmax_running_min(struct minmax *m, u32 win, u32 t, u32 meas)\r\n{\r\nstruct minmax_sample val = { .t = t, .v = meas };\r\nif (unlikely(val.v <= m->s[0].v) ||\r\nunlikely(val.t - m->s[2].t > win))\r\nreturn minmax_reset(m, t, meas);\r\nif (unlikely(val.v <= m->s[1].v))\r\nm->s[2] = m->s[1] = val;\r\nelse if (unlikely(val.v <= m->s[2].v))\r\nm->s[2] = val;\r\nreturn minmax_subwin_update(m, win, &val);\r\n}
