static int sclp_ctl_cmdw_supported(unsigned int cmdw)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(sclp_ctl_sccb_wlist); i++) {\r\nif (cmdw == sclp_ctl_sccb_wlist[i])\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void __user *u64_to_uptr(u64 value)\r\n{\r\nif (is_compat_task())\r\nreturn compat_ptr(value);\r\nelse\r\nreturn (void __user *)(unsigned long)value;\r\n}\r\nstatic int sclp_ctl_ioctl_sccb(void __user *user_area)\r\n{\r\nstruct sclp_ctl_sccb ctl_sccb;\r\nstruct sccb_header *sccb;\r\nunsigned long copied;\r\nint rc;\r\nif (copy_from_user(&ctl_sccb, user_area, sizeof(ctl_sccb)))\r\nreturn -EFAULT;\r\nif (!sclp_ctl_cmdw_supported(ctl_sccb.cmdw))\r\nreturn -EOPNOTSUPP;\r\nsccb = (void *) get_zeroed_page(GFP_KERNEL | GFP_DMA);\r\nif (!sccb)\r\nreturn -ENOMEM;\r\ncopied = PAGE_SIZE -\r\ncopy_from_user(sccb, u64_to_uptr(ctl_sccb.sccb), PAGE_SIZE);\r\nif (offsetof(struct sccb_header, length) +\r\nsizeof(sccb->length) > copied || sccb->length > copied) {\r\nrc = -EFAULT;\r\ngoto out_free;\r\n}\r\nif (sccb->length < 8) {\r\nrc = -EINVAL;\r\ngoto out_free;\r\n}\r\nrc = sclp_sync_request(ctl_sccb.cmdw, sccb);\r\nif (rc)\r\ngoto out_free;\r\nif (copy_to_user(u64_to_uptr(ctl_sccb.sccb), sccb, sccb->length))\r\nrc = -EFAULT;\r\nout_free:\r\nfree_page((unsigned long) sccb);\r\nreturn rc;\r\n}\r\nstatic long sclp_ctl_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nvoid __user *argp;\r\nif (is_compat_task())\r\nargp = compat_ptr(arg);\r\nelse\r\nargp = (void __user *) arg;\r\nswitch (cmd) {\r\ncase SCLP_CTL_SCCB:\r\nreturn sclp_ctl_ioctl_sccb(argp);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}
