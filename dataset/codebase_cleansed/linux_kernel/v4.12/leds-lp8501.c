static inline void lp8501_wait_opmode_done(void)\r\n{\r\nusleep_range(1000, 2000);\r\n}\r\nstatic void lp8501_set_led_current(struct lp55xx_led *led, u8 led_current)\r\n{\r\nled->led_current = led_current;\r\nlp55xx_write(led->chip, LP8501_REG_LED_CURRENT_BASE + led->chan_nr,\r\nled_current);\r\n}\r\nstatic int lp8501_post_init_device(struct lp55xx_chip *chip)\r\n{\r\nint ret;\r\nu8 val = LP8501_DEFAULT_CFG;\r\nret = lp55xx_write(chip, LP8501_REG_ENABLE, LP8501_ENABLE);\r\nif (ret)\r\nreturn ret;\r\nusleep_range(1000, 2000);\r\nif (chip->pdata->clock_mode != LP55XX_CLOCK_EXT)\r\nval |= LP8501_INT_CLK;\r\nret = lp55xx_write(chip, LP8501_REG_CONFIG, val);\r\nif (ret)\r\nreturn ret;\r\nreturn lp55xx_update_bits(chip, LP8501_REG_PWR_CONFIG,\r\nLP8501_PWR_CONFIG_M, chip->pdata->pwr_sel);\r\n}\r\nstatic void lp8501_load_engine(struct lp55xx_chip *chip)\r\n{\r\nenum lp55xx_engine_index idx = chip->engine_idx;\r\nu8 mask[] = {\r\n[LP55XX_ENGINE_1] = LP8501_MODE_ENG1_M,\r\n[LP55XX_ENGINE_2] = LP8501_MODE_ENG2_M,\r\n[LP55XX_ENGINE_3] = LP8501_MODE_ENG3_M,\r\n};\r\nu8 val[] = {\r\n[LP55XX_ENGINE_1] = LP8501_LOAD_ENG1,\r\n[LP55XX_ENGINE_2] = LP8501_LOAD_ENG2,\r\n[LP55XX_ENGINE_3] = LP8501_LOAD_ENG3,\r\n};\r\nu8 page_sel[] = {\r\n[LP55XX_ENGINE_1] = LP8501_PAGE_ENG1,\r\n[LP55XX_ENGINE_2] = LP8501_PAGE_ENG2,\r\n[LP55XX_ENGINE_3] = LP8501_PAGE_ENG3,\r\n};\r\nlp55xx_update_bits(chip, LP8501_REG_OP_MODE, mask[idx], val[idx]);\r\nlp8501_wait_opmode_done();\r\nlp55xx_write(chip, LP8501_REG_PROG_PAGE_SEL, page_sel[idx]);\r\n}\r\nstatic void lp8501_stop_engine(struct lp55xx_chip *chip)\r\n{\r\nlp55xx_write(chip, LP8501_REG_OP_MODE, 0);\r\nlp8501_wait_opmode_done();\r\n}\r\nstatic void lp8501_turn_off_channels(struct lp55xx_chip *chip)\r\n{\r\nint i;\r\nfor (i = 0; i < LP8501_MAX_LEDS; i++)\r\nlp55xx_write(chip, LP8501_REG_LED_PWM_BASE + i, 0);\r\n}\r\nstatic void lp8501_run_engine(struct lp55xx_chip *chip, bool start)\r\n{\r\nint ret;\r\nu8 mode;\r\nu8 exec;\r\nif (!start) {\r\nlp8501_stop_engine(chip);\r\nlp8501_turn_off_channels(chip);\r\nreturn;\r\n}\r\nret = lp55xx_read(chip, LP8501_REG_OP_MODE, &mode);\r\nif (ret)\r\nreturn;\r\nret = lp55xx_read(chip, LP8501_REG_ENABLE, &exec);\r\nif (ret)\r\nreturn;\r\nif (LP8501_ENG1_IS_LOADING(mode)) {\r\nmode = (mode & ~LP8501_MODE_ENG1_M) | LP8501_RUN_ENG1;\r\nexec = (exec & ~LP8501_EXEC_ENG1_M) | LP8501_RUN_ENG1;\r\n}\r\nif (LP8501_ENG2_IS_LOADING(mode)) {\r\nmode = (mode & ~LP8501_MODE_ENG2_M) | LP8501_RUN_ENG2;\r\nexec = (exec & ~LP8501_EXEC_ENG2_M) | LP8501_RUN_ENG2;\r\n}\r\nif (LP8501_ENG3_IS_LOADING(mode)) {\r\nmode = (mode & ~LP8501_MODE_ENG3_M) | LP8501_RUN_ENG3;\r\nexec = (exec & ~LP8501_EXEC_ENG3_M) | LP8501_RUN_ENG3;\r\n}\r\nlp55xx_write(chip, LP8501_REG_OP_MODE, mode);\r\nlp8501_wait_opmode_done();\r\nlp55xx_update_bits(chip, LP8501_REG_ENABLE, LP8501_EXEC_M, exec);\r\n}\r\nstatic int lp8501_update_program_memory(struct lp55xx_chip *chip,\r\nconst u8 *data, size_t size)\r\n{\r\nu8 pattern[LP8501_PROGRAM_LENGTH] = {0};\r\nunsigned cmd;\r\nchar c[3];\r\nint update_size;\r\nint nrchars;\r\nint offset = 0;\r\nint ret;\r\nint i;\r\nfor (i = 0; i < LP8501_PROGRAM_LENGTH; i++)\r\nlp55xx_write(chip, LP8501_REG_PROG_MEM + i, 0);\r\ni = 0;\r\nwhile ((offset < size - 1) && (i < LP8501_PROGRAM_LENGTH)) {\r\nret = sscanf(data + offset, "%2s%n ", c, &nrchars);\r\nif (ret != 1)\r\ngoto err;\r\nret = sscanf(c, "%2x", &cmd);\r\nif (ret != 1)\r\ngoto err;\r\npattern[i] = (u8)cmd;\r\noffset += nrchars;\r\ni++;\r\n}\r\nif (i % 2)\r\ngoto err;\r\nupdate_size = i;\r\nfor (i = 0; i < update_size; i++)\r\nlp55xx_write(chip, LP8501_REG_PROG_MEM + i, pattern[i]);\r\nreturn 0;\r\nerr:\r\ndev_err(&chip->cl->dev, "wrong pattern format\n");\r\nreturn -EINVAL;\r\n}\r\nstatic void lp8501_firmware_loaded(struct lp55xx_chip *chip)\r\n{\r\nconst struct firmware *fw = chip->fw;\r\nif (fw->size > LP8501_PROGRAM_LENGTH) {\r\ndev_err(&chip->cl->dev, "firmware data size overflow: %zu\n",\r\nfw->size);\r\nreturn;\r\n}\r\nlp8501_load_engine(chip);\r\nlp8501_update_program_memory(chip, fw->data, fw->size);\r\n}\r\nstatic int lp8501_led_brightness(struct lp55xx_led *led)\r\n{\r\nstruct lp55xx_chip *chip = led->chip;\r\nint ret;\r\nmutex_lock(&chip->lock);\r\nret = lp55xx_write(chip, LP8501_REG_LED_PWM_BASE + led->chan_nr,\r\nled->brightness);\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int lp8501_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret;\r\nstruct lp55xx_chip *chip;\r\nstruct lp55xx_led *led;\r\nstruct lp55xx_platform_data *pdata = dev_get_platdata(&client->dev);\r\nstruct device_node *np = client->dev.of_node;\r\nif (!pdata) {\r\nif (np) {\r\npdata = lp55xx_of_populate_pdata(&client->dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\n} else {\r\ndev_err(&client->dev, "no platform data\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nled = devm_kzalloc(&client->dev,\r\nsizeof(*led) * pdata->num_channels, GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nchip->cl = client;\r\nchip->pdata = pdata;\r\nchip->cfg = &lp8501_cfg;\r\nmutex_init(&chip->lock);\r\ni2c_set_clientdata(client, led);\r\nret = lp55xx_init_device(chip);\r\nif (ret)\r\ngoto err_init;\r\ndev_info(&client->dev, "%s Programmable led chip found\n", id->name);\r\nret = lp55xx_register_leds(led, chip);\r\nif (ret)\r\ngoto err_register_leds;\r\nret = lp55xx_register_sysfs(chip);\r\nif (ret) {\r\ndev_err(&client->dev, "registering sysfs failed\n");\r\ngoto err_register_sysfs;\r\n}\r\nreturn 0;\r\nerr_register_sysfs:\r\nlp55xx_unregister_leds(led, chip);\r\nerr_register_leds:\r\nlp55xx_deinit_device(chip);\r\nerr_init:\r\nreturn ret;\r\n}\r\nstatic int lp8501_remove(struct i2c_client *client)\r\n{\r\nstruct lp55xx_led *led = i2c_get_clientdata(client);\r\nstruct lp55xx_chip *chip = led->chip;\r\nlp8501_stop_engine(chip);\r\nlp55xx_unregister_sysfs(chip);\r\nlp55xx_unregister_leds(led, chip);\r\nlp55xx_deinit_device(chip);\r\nreturn 0;\r\n}
