static int mgc_name2resid(char *name, int len, struct ldlm_res_id *res_id,\r\nint type)\r\n{\r\n__u64 resname = 0;\r\nif (len > sizeof(resname)) {\r\nCERROR("name too long: %s\n", name);\r\nreturn -EINVAL;\r\n}\r\nif (len <= 0) {\r\nCERROR("missing name: %s\n", name);\r\nreturn -EINVAL;\r\n}\r\nmemcpy(&resname, name, len);\r\nmemset(res_id, 0, sizeof(*res_id));\r\nres_id->name[0] = cpu_to_le64(resname);\r\nswitch (type) {\r\ncase CONFIG_T_CONFIG:\r\ncase CONFIG_T_SPTLRPC:\r\nresname = 0;\r\nbreak;\r\ncase CONFIG_T_RECOVER:\r\ncase CONFIG_T_PARAMS:\r\nresname = type;\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nres_id->name[1] = cpu_to_le64(resname);\r\nCDEBUG(D_MGC, "log %s to resid %#llx/%#llx (%.8s)\n", name,\r\nres_id->name[0], res_id->name[1], (char *)&res_id->name[0]);\r\nreturn 0;\r\n}\r\nint mgc_fsname2resid(char *fsname, struct ldlm_res_id *res_id, int type)\r\n{\r\nreturn mgc_name2resid(fsname, strlen(fsname), res_id, type);\r\n}\r\nstatic int mgc_logname2resid(char *logname, struct ldlm_res_id *res_id, int type)\r\n{\r\nchar *name_end;\r\nint len;\r\nname_end = strrchr(logname, '-');\r\nif (!name_end)\r\nlen = strlen(logname);\r\nelse\r\nlen = name_end - logname;\r\nreturn mgc_name2resid(logname, len, res_id, type);\r\n}\r\nstatic int config_log_get(struct config_llog_data *cld)\r\n{\r\natomic_inc(&cld->cld_refcount);\r\nCDEBUG(D_INFO, "log %s refs %d\n", cld->cld_logname,\r\natomic_read(&cld->cld_refcount));\r\nreturn 0;\r\n}\r\nstatic void config_log_put(struct config_llog_data *cld)\r\n{\r\nCDEBUG(D_INFO, "log %s refs %d\n", cld->cld_logname,\r\natomic_read(&cld->cld_refcount));\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nif (atomic_dec_and_lock(&cld->cld_refcount, &config_list_lock)) {\r\nlist_del(&cld->cld_list_chain);\r\nspin_unlock(&config_list_lock);\r\nCDEBUG(D_MGC, "dropping config log %s\n", cld->cld_logname);\r\nif (cld->cld_recover)\r\nconfig_log_put(cld->cld_recover);\r\nif (cld->cld_params)\r\nconfig_log_put(cld->cld_params);\r\nif (cld->cld_sptlrpc)\r\nconfig_log_put(cld->cld_sptlrpc);\r\nif (cld_is_sptlrpc(cld))\r\nsptlrpc_conf_log_stop(cld->cld_logname);\r\nclass_export_put(cld->cld_mgcexp);\r\nkfree(cld);\r\n}\r\n}\r\nstatic\r\nstruct config_llog_data *config_log_find(char *logname,\r\nstruct config_llog_instance *cfg)\r\n{\r\nstruct config_llog_data *cld;\r\nstruct config_llog_data *found = NULL;\r\nvoid *instance;\r\nLASSERT(logname);\r\ninstance = cfg ? cfg->cfg_instance : NULL;\r\nspin_lock(&config_list_lock);\r\nlist_for_each_entry(cld, &config_llog_list, cld_list_chain) {\r\nif (instance != cld->cld_cfg.cfg_instance)\r\ncontinue;\r\nif (strcmp(logname, cld->cld_logname) == 0) {\r\nfound = cld;\r\nconfig_log_get(found);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&config_list_lock);\r\nreturn found;\r\n}\r\nstatic\r\nstruct config_llog_data *do_config_log_add(struct obd_device *obd,\r\nchar *logname,\r\nint type,\r\nstruct config_llog_instance *cfg,\r\nstruct super_block *sb)\r\n{\r\nstruct config_llog_data *cld;\r\nint rc;\r\nCDEBUG(D_MGC, "do adding config log %s:%p\n", logname,\r\ncfg ? cfg->cfg_instance : NULL);\r\ncld = kzalloc(sizeof(*cld) + strlen(logname) + 1, GFP_NOFS);\r\nif (!cld)\r\nreturn ERR_PTR(-ENOMEM);\r\nrc = mgc_logname2resid(logname, &cld->cld_resid, type);\r\nif (rc) {\r\nkfree(cld);\r\nreturn ERR_PTR(rc);\r\n}\r\nstrcpy(cld->cld_logname, logname);\r\nif (cfg)\r\ncld->cld_cfg = *cfg;\r\nelse\r\ncld->cld_cfg.cfg_callback = class_config_llog_handler;\r\nmutex_init(&cld->cld_lock);\r\ncld->cld_cfg.cfg_last_idx = 0;\r\ncld->cld_cfg.cfg_flags = 0;\r\ncld->cld_cfg.cfg_sb = sb;\r\ncld->cld_type = type;\r\natomic_set(&cld->cld_refcount, 1);\r\ncld->cld_mgcexp = class_export_get(obd->obd_self_export);\r\nif (cld_is_sptlrpc(cld)) {\r\nsptlrpc_conf_log_start(logname);\r\ncld->cld_cfg.cfg_obdname = obd->obd_name;\r\n}\r\nspin_lock(&config_list_lock);\r\nlist_add(&cld->cld_list_chain, &config_llog_list);\r\nspin_unlock(&config_list_lock);\r\nif (cld_is_sptlrpc(cld)) {\r\nrc = mgc_process_log(obd, cld);\r\nif (rc && rc != -ENOENT)\r\nCERROR("failed processing sptlrpc log: %d\n", rc);\r\n}\r\nreturn cld;\r\n}\r\nstatic struct config_llog_data *\r\nconfig_recover_log_add(struct obd_device *obd, char *fsname,\r\nstruct config_llog_instance *cfg,\r\nstruct super_block *sb)\r\n{\r\nstruct config_llog_instance lcfg = *cfg;\r\nstruct config_llog_data *cld;\r\nchar logname[32];\r\nLASSERT(strlen(fsname) < sizeof(logname) / 2);\r\nstrcpy(logname, fsname);\r\nLASSERT(lcfg.cfg_instance);\r\nstrcat(logname, "-cliir");\r\ncld = do_config_log_add(obd, logname, CONFIG_T_RECOVER, &lcfg, sb);\r\nreturn cld;\r\n}\r\nstatic struct config_llog_data *\r\nconfig_params_log_add(struct obd_device *obd,\r\nstruct config_llog_instance *cfg, struct super_block *sb)\r\n{\r\nstruct config_llog_instance lcfg = *cfg;\r\nstruct config_llog_data *cld;\r\nlcfg.cfg_instance = sb;\r\ncld = do_config_log_add(obd, PARAMS_FILENAME, CONFIG_T_PARAMS,\r\n&lcfg, sb);\r\nreturn cld;\r\n}\r\nstatic struct config_llog_data *\r\nconfig_log_add(struct obd_device *obd, char *logname,\r\nstruct config_llog_instance *cfg, struct super_block *sb)\r\n{\r\nstruct lustre_sb_info *lsi = s2lsi(sb);\r\nstruct config_llog_data *cld;\r\nstruct config_llog_data *sptlrpc_cld;\r\nstruct config_llog_data *params_cld;\r\nbool locked = false;\r\nchar seclogname[32];\r\nchar *ptr;\r\nint rc;\r\nCDEBUG(D_MGC, "adding config log %s:%p\n", logname, cfg->cfg_instance);\r\nptr = strrchr(logname, '-');\r\nif (!ptr || ptr - logname > 8) {\r\nCERROR("logname %s is too long\n", logname);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmemcpy(seclogname, logname, ptr - logname);\r\nstrcpy(seclogname + (ptr - logname), "-sptlrpc");\r\nsptlrpc_cld = config_log_find(seclogname, NULL);\r\nif (!sptlrpc_cld) {\r\nsptlrpc_cld = do_config_log_add(obd, seclogname,\r\nCONFIG_T_SPTLRPC, NULL, NULL);\r\nif (IS_ERR(sptlrpc_cld)) {\r\nCERROR("can't create sptlrpc log: %s\n", seclogname);\r\nrc = PTR_ERR(sptlrpc_cld);\r\ngoto out_err;\r\n}\r\n}\r\nparams_cld = config_params_log_add(obd, cfg, sb);\r\nif (IS_ERR(params_cld)) {\r\nrc = PTR_ERR(params_cld);\r\nCERROR("%s: can't create params log: rc = %d\n",\r\nobd->obd_name, rc);\r\ngoto out_sptlrpc;\r\n}\r\ncld = do_config_log_add(obd, logname, CONFIG_T_CONFIG, cfg, sb);\r\nif (IS_ERR(cld)) {\r\nCERROR("can't create log: %s\n", logname);\r\nrc = PTR_ERR(cld);\r\ngoto out_params;\r\n}\r\ncld->cld_sptlrpc = sptlrpc_cld;\r\ncld->cld_params = params_cld;\r\nLASSERT(lsi->lsi_lmd);\r\nif (!(lsi->lsi_lmd->lmd_flags & LMD_FLG_NOIR)) {\r\nstruct config_llog_data *recover_cld;\r\nptr = strrchr(seclogname, '-');\r\nif (ptr) {\r\n*ptr = 0;\r\n} else {\r\nCERROR("%s: sptlrpc log name not correct, %s: rc = %d\n",\r\nobd->obd_name, seclogname, -EINVAL);\r\nconfig_log_put(cld);\r\nrc = -EINVAL;\r\ngoto out_cld;\r\n}\r\nrecover_cld = config_recover_log_add(obd, seclogname, cfg, sb);\r\nif (IS_ERR(recover_cld)) {\r\nrc = PTR_ERR(recover_cld);\r\ngoto out_cld;\r\n}\r\nmutex_lock(&cld->cld_lock);\r\nlocked = true;\r\ncld->cld_recover = recover_cld;\r\n}\r\nif (!locked)\r\nmutex_lock(&cld->cld_lock);\r\ncld->cld_params = params_cld;\r\ncld->cld_sptlrpc = sptlrpc_cld;\r\nmutex_unlock(&cld->cld_lock);\r\nreturn cld;\r\nout_cld:\r\nconfig_log_put(cld);\r\nout_params:\r\nconfig_log_put(params_cld);\r\nout_sptlrpc:\r\nconfig_log_put(sptlrpc_cld);\r\nout_err:\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic inline void config_mark_cld_stop(struct config_llog_data *cld)\r\n{\r\nmutex_lock(&cld->cld_lock);\r\nspin_lock(&config_list_lock);\r\ncld->cld_stopping = 1;\r\nspin_unlock(&config_list_lock);\r\nmutex_unlock(&cld->cld_lock);\r\n}\r\nstatic int config_log_end(char *logname, struct config_llog_instance *cfg)\r\n{\r\nstruct config_llog_data *cld;\r\nstruct config_llog_data *cld_sptlrpc = NULL;\r\nstruct config_llog_data *cld_params = NULL;\r\nstruct config_llog_data *cld_recover = NULL;\r\nint rc = 0;\r\ncld = config_log_find(logname, cfg);\r\nif (!cld)\r\nreturn -ENOENT;\r\nmutex_lock(&cld->cld_lock);\r\nif (unlikely(cld->cld_stopping)) {\r\nmutex_unlock(&cld->cld_lock);\r\nconfig_log_put(cld);\r\nreturn rc;\r\n}\r\nspin_lock(&config_list_lock);\r\ncld->cld_stopping = 1;\r\nspin_unlock(&config_list_lock);\r\ncld_recover = cld->cld_recover;\r\ncld->cld_recover = NULL;\r\ncld_params = cld->cld_params;\r\ncld->cld_params = NULL;\r\ncld_sptlrpc = cld->cld_sptlrpc;\r\ncld->cld_sptlrpc = NULL;\r\nmutex_unlock(&cld->cld_lock);\r\nif (cld_recover) {\r\nconfig_mark_cld_stop(cld_recover);\r\nconfig_log_put(cld_recover);\r\n}\r\nif (cld_params) {\r\nconfig_mark_cld_stop(cld_params);\r\nconfig_log_put(cld_params);\r\n}\r\nif (cld_sptlrpc)\r\nconfig_log_put(cld_sptlrpc);\r\nconfig_log_put(cld);\r\nconfig_log_put(cld);\r\nCDEBUG(D_MGC, "end config log %s (%d)\n", logname ? logname : "client",\r\nrc);\r\nreturn rc;\r\n}\r\nint lprocfs_mgc_rd_ir_state(struct seq_file *m, void *data)\r\n{\r\nstruct obd_device *obd = data;\r\nstruct obd_import *imp;\r\nstruct obd_connect_data *ocd;\r\nstruct config_llog_data *cld;\r\nint rc;\r\nrc = lprocfs_climp_check(obd);\r\nif (rc)\r\nreturn rc;\r\nimp = obd->u.cli.cl_import;\r\nocd = &imp->imp_connect_data;\r\nseq_printf(m, "imperative_recovery: %s\n",\r\nOCD_HAS_FLAG(ocd, IMP_RECOV) ? "ENABLED" : "DISABLED");\r\nseq_printf(m, "client_state:\n");\r\nspin_lock(&config_list_lock);\r\nlist_for_each_entry(cld, &config_llog_list, cld_list_chain) {\r\nif (!cld->cld_recover)\r\ncontinue;\r\nseq_printf(m, " - { client: %s, nidtbl_version: %u }\n",\r\ncld->cld_logname,\r\ncld->cld_recover->cld_cfg.cfg_last_idx);\r\n}\r\nspin_unlock(&config_list_lock);\r\nup_read(&obd->u.cli.cl_sem);\r\nreturn 0;\r\n}\r\nstatic void do_requeue(struct config_llog_data *cld)\r\n{\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\ndown_read_nested(&cld->cld_mgcexp->exp_obd->u.cli.cl_sem,\r\nOBD_CLI_SEM_MGC);\r\nif (cld->cld_mgcexp->exp_obd->u.cli.cl_conn_count != 0) {\r\nint rc;\r\nCDEBUG(D_MGC, "updating log %s\n", cld->cld_logname);\r\nrc = mgc_process_log(cld->cld_mgcexp->exp_obd, cld);\r\nif (rc && rc != -ENOENT)\r\nCERROR("failed processing log: %d\n", rc);\r\n} else {\r\nCDEBUG(D_MGC, "disconnecting, won't update log %s\n",\r\ncld->cld_logname);\r\n}\r\nup_read(&cld->cld_mgcexp->exp_obd->u.cli.cl_sem);\r\n}\r\nstatic int mgc_requeue_thread(void *data)\r\n{\r\nbool first = true;\r\nCDEBUG(D_MGC, "Starting requeue thread\n");\r\nspin_lock(&config_list_lock);\r\nrq_state |= RQ_RUNNING;\r\nwhile (!(rq_state & RQ_STOP)) {\r\nstruct l_wait_info lwi;\r\nstruct config_llog_data *cld, *cld_prev;\r\nint rand = cfs_rand() & MGC_TIMEOUT_RAND_CENTISEC;\r\nint to;\r\nrq_state &= ~(RQ_NOW | RQ_LATER);\r\nspin_unlock(&config_list_lock);\r\nif (first) {\r\nfirst = false;\r\ncomplete(&rq_start);\r\n}\r\nto = msecs_to_jiffies(MGC_TIMEOUT_MIN_SECONDS * MSEC_PER_SEC);\r\nto += msecs_to_jiffies(rand * MSEC_PER_SEC / 100);\r\nlwi = LWI_TIMEOUT(to, NULL, NULL);\r\nl_wait_event(rq_waitq, rq_state & (RQ_STOP | RQ_PRECLEANUP),\r\n&lwi);\r\ncld_prev = NULL;\r\nspin_lock(&config_list_lock);\r\nrq_state &= ~RQ_PRECLEANUP;\r\nlist_for_each_entry(cld, &config_llog_list, cld_list_chain) {\r\nif (!cld->cld_lostlock || cld->cld_stopping)\r\ncontinue;\r\nconfig_log_get(cld);\r\ncld->cld_lostlock = 0;\r\nspin_unlock(&config_list_lock);\r\nif (cld_prev)\r\nconfig_log_put(cld_prev);\r\ncld_prev = cld;\r\nif (likely(!(rq_state & RQ_STOP))) {\r\ndo_requeue(cld);\r\nspin_lock(&config_list_lock);\r\n} else {\r\nspin_lock(&config_list_lock);\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&config_list_lock);\r\nif (cld_prev)\r\nconfig_log_put(cld_prev);\r\nlwi = (struct l_wait_info) { 0 };\r\nl_wait_event(rq_waitq, rq_state & (RQ_NOW | RQ_STOP),\r\n&lwi);\r\nspin_lock(&config_list_lock);\r\n}\r\nrq_state &= ~RQ_RUNNING;\r\nspin_unlock(&config_list_lock);\r\ncomplete(&rq_exit);\r\nCDEBUG(D_MGC, "Ending requeue thread\n");\r\nreturn 0;\r\n}\r\nstatic void mgc_requeue_add(struct config_llog_data *cld)\r\n{\r\nbool wakeup = false;\r\nCDEBUG(D_INFO, "log %s: requeue (r=%d sp=%d st=%x)\n",\r\ncld->cld_logname, atomic_read(&cld->cld_refcount),\r\ncld->cld_stopping, rq_state);\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nmutex_lock(&cld->cld_lock);\r\nspin_lock(&config_list_lock);\r\nif (!(rq_state & RQ_STOP) && !cld->cld_stopping && !cld->cld_lostlock) {\r\ncld->cld_lostlock = 1;\r\nrq_state |= RQ_NOW;\r\nwakeup = true;\r\n}\r\nspin_unlock(&config_list_lock);\r\nmutex_unlock(&cld->cld_lock);\r\nif (wakeup)\r\nwake_up(&rq_waitq);\r\n}\r\nstatic int mgc_llog_init(const struct lu_env *env, struct obd_device *obd)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nint rc;\r\nrc = llog_setup(env, obd, &obd->obd_olg, LLOG_CONFIG_REPL_CTXT, obd,\r\n&llog_client_ops);\r\nif (rc)\r\nreturn rc;\r\nctxt = llog_get_context(obd, LLOG_CONFIG_REPL_CTXT);\r\nLASSERT(ctxt);\r\nllog_initiator_connect(ctxt);\r\nllog_ctxt_put(ctxt);\r\nreturn 0;\r\n}\r\nstatic int mgc_llog_fini(const struct lu_env *env, struct obd_device *obd)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nctxt = llog_get_context(obd, LLOG_CONFIG_REPL_CTXT);\r\nif (ctxt)\r\nllog_cleanup(env, ctxt);\r\nreturn 0;\r\n}\r\nstatic int mgc_precleanup(struct obd_device *obd)\r\n{\r\nint rc = 0;\r\nint temp;\r\nif (atomic_dec_and_test(&mgc_count)) {\r\nLASSERT(rq_state & RQ_RUNNING);\r\ntemp = RQ_STOP;\r\n} else {\r\ntemp = RQ_NOW | RQ_PRECLEANUP;\r\n}\r\nspin_lock(&config_list_lock);\r\nrq_state |= temp;\r\nspin_unlock(&config_list_lock);\r\nwake_up(&rq_waitq);\r\nif (temp & RQ_STOP)\r\nwait_for_completion(&rq_exit);\r\nobd_cleanup_client_import(obd);\r\nrc = mgc_llog_fini(NULL, obd);\r\nif (rc)\r\nCERROR("failed to cleanup llogging subsystems\n");\r\nreturn rc;\r\n}\r\nstatic int mgc_cleanup(struct obd_device *obd)\r\n{\r\nif (obd->obd_type->typ_refcnt <= 1)\r\nclass_del_profiles();\r\nlprocfs_obd_cleanup(obd);\r\nptlrpcd_decref();\r\nreturn client_obd_cleanup(obd);\r\n}\r\nstatic int mgc_setup(struct obd_device *obd, struct lustre_cfg *lcfg)\r\n{\r\nstruct lprocfs_static_vars lvars = { NULL };\r\nstruct task_struct *task;\r\nint rc;\r\nrc = ptlrpcd_addref();\r\nif (rc < 0)\r\ngoto err_noref;\r\nrc = client_obd_setup(obd, lcfg);\r\nif (rc)\r\ngoto err_decref;\r\nrc = mgc_llog_init(NULL, obd);\r\nif (rc) {\r\nCERROR("failed to setup llogging subsystems\n");\r\ngoto err_cleanup;\r\n}\r\nlprocfs_mgc_init_vars(&lvars);\r\nlprocfs_obd_setup(obd, lvars.obd_vars, lvars.sysfs_vars);\r\nsptlrpc_lprocfs_cliobd_attach(obd);\r\nif (atomic_inc_return(&mgc_count) == 1) {\r\nrq_state = 0;\r\ninit_waitqueue_head(&rq_waitq);\r\ntask = kthread_run(mgc_requeue_thread, NULL, "ll_cfg_requeue");\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nCERROR("%s: cannot start requeue thread: rc = %d; no more log updates\n",\r\nobd->obd_name, rc);\r\ngoto err_cleanup;\r\n}\r\nrc = 0;\r\nwait_for_completion(&rq_start);\r\n}\r\nreturn rc;\r\nerr_cleanup:\r\nclient_obd_cleanup(obd);\r\nerr_decref:\r\nptlrpcd_decref();\r\nerr_noref:\r\nreturn rc;\r\n}\r\nstatic int mgc_blocking_ast(struct ldlm_lock *lock, struct ldlm_lock_desc *desc,\r\nvoid *data, int flag)\r\n{\r\nstruct lustre_handle lockh;\r\nstruct config_llog_data *cld = data;\r\nint rc = 0;\r\nswitch (flag) {\r\ncase LDLM_CB_BLOCKING:\r\nLDLM_DEBUG(lock, "MGC blocking CB");\r\nldlm_lock2handle(lock, &lockh);\r\nrc = ldlm_cli_cancel(&lockh, LCF_ASYNC);\r\nbreak;\r\ncase LDLM_CB_CANCELING:\r\nLDLM_DEBUG(lock, "MGC cancel CB");\r\nCDEBUG(D_MGC, "Lock res "DLDLMRES" (%.8s)\n",\r\nPLDLMRES(lock->l_resource),\r\n(char *)&lock->l_resource->lr_name.name[0]);\r\nif (!cld) {\r\nCDEBUG(D_INFO, "missing data, won't requeue\n");\r\nbreak;\r\n}\r\nLASSERT(atomic_read(&cld->cld_refcount) > 0);\r\nlock->l_ast_data = NULL;\r\nif (cld->cld_stopping) {\r\nCDEBUG(D_MGC, "log %s: stopping, won't requeue\n",\r\ncld->cld_logname);\r\nconfig_log_put(cld);\r\nbreak;\r\n}\r\nif (!lock->l_conn_export ||\r\n!lock->l_conn_export->exp_obd->u.cli.cl_conn_count) {\r\nCDEBUG(D_MGC, "log %.8s: disconnecting, won't requeue\n",\r\ncld->cld_logname);\r\nconfig_log_put(cld);\r\nbreak;\r\n}\r\nmgc_requeue_add(cld);\r\nconfig_log_put(cld);\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_set_mgs_param(struct obd_export *exp,\r\nstruct mgs_send_param *msp)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mgs_send_param *req_msp, *rep_msp;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MGS_SET_INFO, LUSTRE_MGS_VERSION,\r\nMGS_SET_INFO);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_msp = req_capsule_client_get(&req->rq_pill, &RMF_MGS_SEND_PARAM);\r\nif (!req_msp) {\r\nptlrpc_req_finished(req);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(req_msp, msp, sizeof(*req_msp));\r\nptlrpc_request_set_replen(req);\r\nreq->rq_delay_limit = MGC_SEND_PARAM_LIMIT;\r\nrc = ptlrpc_queue_wait(req);\r\nif (!rc) {\r\nrep_msp = req_capsule_server_get(&req->rq_pill, &RMF_MGS_SEND_PARAM);\r\nmemcpy(msp, rep_msp, sizeof(*rep_msp));\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mgc_enqueue(struct obd_export *exp, __u32 type,\r\nunion ldlm_policy_data *policy, __u32 mode,\r\n__u64 *flags, void *bl_cb, void *cp_cb, void *gl_cb,\r\nvoid *data, __u32 lvb_len, void *lvb_swabber,\r\nstruct lustre_handle *lockh)\r\n{\r\nstruct config_llog_data *cld = data;\r\nstruct ldlm_enqueue_info einfo = {\r\n.ei_type = type,\r\n.ei_mode = mode,\r\n.ei_cb_bl = mgc_blocking_ast,\r\n.ei_cb_cp = ldlm_completion_ast,\r\n};\r\nstruct ptlrpc_request *req;\r\nint short_limit = cld_is_sptlrpc(cld);\r\nint rc;\r\nCDEBUG(D_MGC, "Enqueue for %s (res %#llx)\n", cld->cld_logname,\r\ncld->cld_resid.name[0]);\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_LDLM_ENQUEUE, LUSTRE_DLM_VERSION,\r\nLDLM_ENQUEUE);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_DLM_LVB, RCL_SERVER, 0);\r\nptlrpc_request_set_replen(req);\r\nreq->rq_delay_limit = short_limit ? 5 : MGC_ENQUEUE_LIMIT;\r\nrc = ldlm_cli_enqueue(exp, &req, &einfo, &cld->cld_resid, NULL, flags,\r\nNULL, 0, LVB_T_NONE, lockh, 0);\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic void mgc_notify_active(struct obd_device *unused)\r\n{\r\nspin_lock(&config_list_lock);\r\nrq_state |= RQ_NOW;\r\nspin_unlock(&config_list_lock);\r\nwake_up(&rq_waitq);\r\n}\r\nstatic int mgc_target_register(struct obd_export *exp,\r\nstruct mgs_target_info *mti)\r\n{\r\nstruct ptlrpc_request *req;\r\nstruct mgs_target_info *req_mti, *rep_mti;\r\nint rc;\r\nreq = ptlrpc_request_alloc_pack(class_exp2cliimp(exp),\r\n&RQF_MGS_TARGET_REG, LUSTRE_MGS_VERSION,\r\nMGS_TARGET_REG);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_mti = req_capsule_client_get(&req->rq_pill, &RMF_MGS_TARGET_INFO);\r\nif (!req_mti) {\r\nptlrpc_req_finished(req);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(req_mti, mti, sizeof(*req_mti));\r\nptlrpc_request_set_replen(req);\r\nCDEBUG(D_MGC, "register %s\n", mti->mti_svname);\r\nreq->rq_delay_limit = MGC_TARGET_REG_LIMIT;\r\nrc = ptlrpc_queue_wait(req);\r\nif (!rc) {\r\nrep_mti = req_capsule_server_get(&req->rq_pill,\r\n&RMF_MGS_TARGET_INFO);\r\nmemcpy(mti, rep_mti, sizeof(*rep_mti));\r\nCDEBUG(D_MGC, "register %s got index = %d\n",\r\nmti->mti_svname, mti->mti_stripe_index);\r\n}\r\nptlrpc_req_finished(req);\r\nreturn rc;\r\n}\r\nstatic int mgc_set_info_async(const struct lu_env *env, struct obd_export *exp,\r\nu32 keylen, void *key, u32 vallen,\r\nvoid *val, struct ptlrpc_request_set *set)\r\n{\r\nint rc = -EINVAL;\r\nif (KEY_IS(KEY_INIT_RECOV_BACKUP)) {\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nint value;\r\nif (vallen != sizeof(int))\r\nreturn -EINVAL;\r\nvalue = *(int *)val;\r\nCDEBUG(D_MGC, "InitRecov %s %d/d%d:i%d:r%d:or%d:%s\n",\r\nimp->imp_obd->obd_name, value,\r\nimp->imp_deactive, imp->imp_invalid,\r\nimp->imp_replayable, imp->imp_obd->obd_replayable,\r\nptlrpc_import_state_name(imp->imp_state));\r\nif ((imp->imp_state != LUSTRE_IMP_FULL &&\r\nimp->imp_state != LUSTRE_IMP_NEW) || value > 1)\r\nptlrpc_reconnect_import(imp);\r\nreturn 0;\r\n}\r\nif (KEY_IS(KEY_SET_INFO)) {\r\nstruct mgs_send_param *msp;\r\nmsp = val;\r\nrc = mgc_set_mgs_param(exp, msp);\r\nreturn rc;\r\n}\r\nif (KEY_IS(KEY_MGSSEC)) {\r\nstruct client_obd *cli = &exp->exp_obd->u.cli;\r\nstruct sptlrpc_flavor flvr;\r\nif (vallen == 0) {\r\nif (cli->cl_flvr_mgc.sf_rpc != SPTLRPC_FLVR_INVALID)\r\nreturn 0;\r\nval = "null";\r\nvallen = 4;\r\n}\r\nrc = sptlrpc_parse_flavor(val, &flvr);\r\nif (rc) {\r\nCERROR("invalid sptlrpc flavor %s to MGS\n",\r\n(char *)val);\r\nreturn rc;\r\n}\r\nif (cli->cl_flvr_mgc.sf_rpc == SPTLRPC_FLVR_INVALID) {\r\ncli->cl_flvr_mgc = flvr;\r\n} else if (memcmp(&cli->cl_flvr_mgc, &flvr,\r\nsizeof(flvr)) != 0) {\r\nchar str[20];\r\nsptlrpc_flavor2name(&cli->cl_flvr_mgc,\r\nstr, sizeof(str));\r\nLCONSOLE_ERROR("asking sptlrpc flavor %s to MGS but currently %s is in use\n",\r\n(char *)val, str);\r\nrc = -EPERM;\r\n}\r\nreturn rc;\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_get_info(const struct lu_env *env, struct obd_export *exp,\r\n__u32 keylen, void *key, __u32 *vallen, void *val)\r\n{\r\nint rc = -EINVAL;\r\nif (KEY_IS(KEY_CONN_DATA)) {\r\nstruct obd_import *imp = class_exp2cliimp(exp);\r\nstruct obd_connect_data *data = val;\r\nif (*vallen == sizeof(*data)) {\r\n*data = imp->imp_connect_data;\r\nrc = 0;\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_import_event(struct obd_device *obd,\r\nstruct obd_import *imp,\r\nenum obd_import_event event)\r\n{\r\nLASSERT(imp->imp_obd == obd);\r\nCDEBUG(D_MGC, "import event %#x\n", event);\r\nswitch (event) {\r\ncase IMP_EVENT_DISCON:\r\nif (OCD_HAS_FLAG(&imp->imp_connect_data, IMP_RECOV))\r\nptlrpc_pinger_ir_down();\r\nbreak;\r\ncase IMP_EVENT_INACTIVE:\r\nbreak;\r\ncase IMP_EVENT_INVALIDATE: {\r\nstruct ldlm_namespace *ns = obd->obd_namespace;\r\nldlm_namespace_cleanup(ns, LDLM_FL_LOCAL_ONLY);\r\nbreak;\r\n}\r\ncase IMP_EVENT_ACTIVE:\r\nCDEBUG(D_INFO, "%s: Reactivating import\n", obd->obd_name);\r\nobd->obd_no_recov = 0;\r\nmgc_notify_active(obd);\r\nif (OCD_HAS_FLAG(&imp->imp_connect_data, IMP_RECOV))\r\nptlrpc_pinger_ir_up();\r\nbreak;\r\ncase IMP_EVENT_OCD:\r\nbreak;\r\ncase IMP_EVENT_DEACTIVATE:\r\ncase IMP_EVENT_ACTIVATE:\r\nbreak;\r\ndefault:\r\nCERROR("Unknown import event %#x\n", event);\r\nLBUG();\r\n}\r\nreturn 0;\r\n}\r\nstatic int mgc_apply_recover_logs(struct obd_device *mgc,\r\nstruct config_llog_data *cld,\r\n__u64 max_version,\r\nvoid *data, int datalen, bool mne_swab)\r\n{\r\nstruct config_llog_instance *cfg = &cld->cld_cfg;\r\nstruct mgs_nidtbl_entry *entry;\r\nstruct lustre_cfg *lcfg;\r\nstruct lustre_cfg_bufs bufs;\r\nu64 prev_version = 0;\r\nchar *inst;\r\nchar *buf;\r\nint bufsz;\r\nint pos;\r\nint rc = 0;\r\nint off = 0;\r\nLASSERT(cfg->cfg_instance);\r\nLASSERT(cfg->cfg_sb == cfg->cfg_instance);\r\ninst = kzalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\npos = snprintf(inst, PAGE_SIZE, "%p", cfg->cfg_instance);\r\nif (pos >= PAGE_SIZE) {\r\nkfree(inst);\r\nreturn -E2BIG;\r\n}\r\n++pos;\r\nbuf = inst + pos;\r\nbufsz = PAGE_SIZE - pos;\r\nwhile (datalen > 0) {\r\nint entry_len = sizeof(*entry);\r\nint is_ost, i;\r\nstruct obd_device *obd;\r\nchar *obdname;\r\nchar *cname;\r\nchar *params;\r\nchar *uuid;\r\nrc = -EINVAL;\r\nif (datalen < sizeof(*entry))\r\nbreak;\r\nentry = (typeof(entry))(data + off);\r\nif (entry->mne_nid_type != 0)\r\nbreak;\r\nif (entry->mne_nid_count == 0)\r\nbreak;\r\nif (entry->mne_nid_size != sizeof(lnet_nid_t))\r\nbreak;\r\nentry_len += entry->mne_nid_count * entry->mne_nid_size;\r\nif (datalen < entry_len)\r\nbreak;\r\nif (mne_swab)\r\nlustre_swab_mgs_nidtbl_entry(entry);\r\nif (entry->mne_length > PAGE_SIZE) {\r\nCERROR("MNE too large (%u)\n", entry->mne_length);\r\nbreak;\r\n}\r\nif (entry->mne_length < entry_len)\r\nbreak;\r\noff += entry->mne_length;\r\ndatalen -= entry->mne_length;\r\nif (datalen < 0)\r\nbreak;\r\nif (entry->mne_version > max_version) {\r\nCERROR("entry index(%lld) is over max_index(%lld)\n",\r\nentry->mne_version, max_version);\r\nbreak;\r\n}\r\nif (prev_version >= entry->mne_version) {\r\nCERROR("index unsorted, prev %lld, now %lld\n",\r\nprev_version, entry->mne_version);\r\nbreak;\r\n}\r\nprev_version = entry->mne_version;\r\nis_ost = entry->mne_type == LDD_F_SV_TYPE_OST;\r\nmemset(buf, 0, bufsz);\r\nobdname = buf;\r\npos = 0;\r\nstrcpy(obdname, cld->cld_logname);\r\ncname = strrchr(obdname, '-');\r\nif (!cname) {\r\nCERROR("mgc %s: invalid logname %s\n",\r\nmgc->obd_name, obdname);\r\nbreak;\r\n}\r\npos = cname - obdname;\r\nobdname[pos] = 0;\r\npos += sprintf(obdname + pos, "-%s%04x",\r\nis_ost ? "OST" : "MDT", entry->mne_index);\r\ncname = is_ost ? "osc" : "mdc";\r\npos += sprintf(obdname + pos, "-%s-%s", cname, inst);\r\nlustre_cfg_bufs_reset(&bufs, obdname);\r\nobd = class_name2obd(obdname);\r\nif (!obd) {\r\nCDEBUG(D_INFO, "mgc %s: cannot find obdname %s\n",\r\nmgc->obd_name, obdname);\r\nrc = 0;\r\ncontinue;\r\n}\r\n++pos;\r\nparams = buf + pos;\r\npos += sprintf(params, "%s.import=%s", cname, "connection=");\r\nuuid = buf + pos;\r\ndown_read(&obd->u.cli.cl_sem);\r\nif (!obd->u.cli.cl_import) {\r\nup_read(&obd->u.cli.cl_sem);\r\nrc = 0;\r\ncontinue;\r\n}\r\nrc = -ENOENT;\r\nfor (i = 0; i < entry->mne_nid_count; i++) {\r\nrc = client_import_find_conn(obd->u.cli.cl_import,\r\nentry->u.nids[0],\r\n(struct obd_uuid *)uuid);\r\nif (!rc)\r\nbreak;\r\n}\r\nup_read(&obd->u.cli.cl_sem);\r\nif (rc < 0) {\r\nCERROR("mgc: cannot find uuid by nid %s\n",\r\nlibcfs_nid2str(entry->u.nids[0]));\r\nbreak;\r\n}\r\nCDEBUG(D_INFO, "Find uuid %s by nid %s\n",\r\nuuid, libcfs_nid2str(entry->u.nids[0]));\r\npos += strlen(uuid);\r\npos += sprintf(buf + pos, "::%u", entry->mne_instance);\r\nLASSERT(pos < bufsz);\r\nlustre_cfg_bufs_set_string(&bufs, 1, params);\r\nrc = -ENOMEM;\r\nlcfg = lustre_cfg_new(LCFG_PARAM, &bufs);\r\nif (IS_ERR(lcfg)) {\r\nCERROR("mgc: cannot allocate memory\n");\r\nbreak;\r\n}\r\nCDEBUG(D_INFO, "ir apply logs %lld/%lld for %s -> %s\n",\r\nprev_version, max_version, obdname, params);\r\nrc = class_process_config(lcfg);\r\nlustre_cfg_free(lcfg);\r\nif (rc)\r\nCDEBUG(D_INFO, "process config for %s error %d\n",\r\nobdname, rc);\r\n}\r\nkfree(inst);\r\nreturn rc;\r\n}\r\nstatic int mgc_process_recover_log(struct obd_device *obd,\r\nstruct config_llog_data *cld)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nstruct config_llog_instance *cfg = &cld->cld_cfg;\r\nstruct mgs_config_body *body;\r\nstruct mgs_config_res *res;\r\nstruct ptlrpc_bulk_desc *desc;\r\nstruct page **pages;\r\nint nrpages;\r\nbool eof = true;\r\nbool mne_swab;\r\nint i;\r\nint ealen;\r\nint rc;\r\nnrpages = CONFIG_READ_NRPAGES;\r\nif (cfg->cfg_last_idx == 0)\r\nnrpages = CONFIG_READ_NRPAGES_INIT;\r\npages = kcalloc(nrpages, sizeof(*pages), GFP_KERNEL);\r\nif (!pages) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < nrpages; i++) {\r\npages[i] = alloc_page(GFP_KERNEL);\r\nif (!pages[i]) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\n}\r\nagain:\r\nLASSERT(cld_is_recover(cld));\r\nLASSERT(mutex_is_locked(&cld->cld_lock));\r\nreq = ptlrpc_request_alloc(class_exp2cliimp(cld->cld_mgcexp),\r\n&RQF_MGS_CONFIG_READ);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = ptlrpc_request_pack(req, LUSTRE_MGS_VERSION, MGS_CONFIG_READ);\r\nif (rc)\r\ngoto out;\r\nbody = req_capsule_client_get(&req->rq_pill, &RMF_MGS_CONFIG_BODY);\r\nLASSERT(sizeof(body->mcb_name) > strlen(cld->cld_logname));\r\nif (strlcpy(body->mcb_name, cld->cld_logname, sizeof(body->mcb_name))\r\n>= sizeof(body->mcb_name)) {\r\nrc = -E2BIG;\r\ngoto out;\r\n}\r\nbody->mcb_offset = cfg->cfg_last_idx + 1;\r\nbody->mcb_type = cld->cld_type;\r\nbody->mcb_bits = PAGE_SHIFT;\r\nbody->mcb_units = nrpages;\r\ndesc = ptlrpc_prep_bulk_imp(req, nrpages, 1,\r\nPTLRPC_BULK_PUT_SINK | PTLRPC_BULK_BUF_KIOV,\r\nMGS_BULK_PORTAL,\r\n&ptlrpc_bulk_kiov_pin_ops);\r\nif (!desc) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < nrpages; i++)\r\ndesc->bd_frag_ops->add_kiov_frag(desc, pages[i], 0, PAGE_SIZE);\r\nptlrpc_request_set_replen(req);\r\nrc = ptlrpc_queue_wait(req);\r\nif (rc)\r\ngoto out;\r\nres = req_capsule_server_get(&req->rq_pill, &RMF_MGS_CONFIG_RES);\r\nif (res->mcr_size < res->mcr_offset) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\ncfg->cfg_last_idx = res->mcr_offset;\r\neof = res->mcr_offset == res->mcr_size;\r\nCDEBUG(D_INFO, "Latest version %lld, more %d.\n",\r\nres->mcr_offset, eof == false);\r\nealen = sptlrpc_cli_unwrap_bulk_read(req, req->rq_bulk, 0);\r\nif (ealen < 0) {\r\nrc = ealen;\r\ngoto out;\r\n}\r\nif (ealen > nrpages << PAGE_SHIFT) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nif (ealen == 0) {\r\nif (!eof)\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmne_swab = !!ptlrpc_rep_need_swab(req);\r\n#if OBD_OCD_VERSION(3, 0, 53, 0) > LUSTRE_VERSION_CODE\r\nif (unlikely(req->rq_import->imp_need_mne_swab))\r\nmne_swab = !mne_swab;\r\n#endif\r\nfor (i = 0; i < nrpages && ealen > 0; i++) {\r\nint rc2;\r\nvoid *ptr;\r\nptr = kmap(pages[i]);\r\nrc2 = mgc_apply_recover_logs(obd, cld, res->mcr_offset, ptr,\r\nmin_t(int, ealen, PAGE_SIZE),\r\nmne_swab);\r\nkunmap(pages[i]);\r\nif (rc2 < 0) {\r\nCWARN("Process recover log %s error %d\n",\r\ncld->cld_logname, rc2);\r\nbreak;\r\n}\r\nealen -= PAGE_SIZE;\r\n}\r\nout:\r\nif (req)\r\nptlrpc_req_finished(req);\r\nif (rc == 0 && !eof)\r\ngoto again;\r\nif (pages) {\r\nfor (i = 0; i < nrpages; i++) {\r\nif (!pages[i])\r\nbreak;\r\n__free_page(pages[i]);\r\n}\r\nkfree(pages);\r\n}\r\nreturn rc;\r\n}\r\nstatic int mgc_process_cfg_log(struct obd_device *mgc,\r\nstruct config_llog_data *cld, int local_only)\r\n{\r\nstruct llog_ctxt *ctxt;\r\nstruct lustre_sb_info *lsi = NULL;\r\nint rc = 0;\r\nbool sptlrpc_started = false;\r\nstruct lu_env *env;\r\nLASSERT(cld);\r\nLASSERT(mutex_is_locked(&cld->cld_lock));\r\nif (cld_is_sptlrpc(cld) && local_only)\r\nreturn 0;\r\nif (cld->cld_cfg.cfg_sb)\r\nlsi = s2lsi(cld->cld_cfg.cfg_sb);\r\nenv = kzalloc(sizeof(*env), GFP_KERNEL);\r\nif (!env)\r\nreturn -ENOMEM;\r\nrc = lu_env_init(env, LCT_MG_THREAD);\r\nif (rc)\r\ngoto out_free;\r\nctxt = llog_get_context(mgc, LLOG_CONFIG_REPL_CTXT);\r\nLASSERT(ctxt);\r\nif (local_only) {\r\nrc = -EIO;\r\ngoto out_pop;\r\n}\r\nif (cld_is_sptlrpc(cld)) {\r\nsptlrpc_conf_log_update_begin(cld->cld_logname);\r\nsptlrpc_started = true;\r\n}\r\nrc = class_config_parse_llog(env, ctxt, cld->cld_logname,\r\n&cld->cld_cfg);\r\nout_pop:\r\n__llog_ctxt_put(env, ctxt);\r\nif (sptlrpc_started) {\r\nLASSERT(cld_is_sptlrpc(cld));\r\nsptlrpc_conf_log_update_end(cld->cld_logname);\r\nclass_notify_sptlrpc_conf(cld->cld_logname,\r\nstrlen(cld->cld_logname) -\r\nstrlen("-sptlrpc"));\r\n}\r\nlu_env_fini(env);\r\nout_free:\r\nkfree(env);\r\nreturn rc;\r\n}\r\nstatic bool mgc_import_in_recovery(struct obd_import *imp)\r\n{\r\nbool in_recovery = true;\r\nspin_lock(&imp->imp_lock);\r\nif (imp->imp_state == LUSTRE_IMP_FULL ||\r\nimp->imp_state == LUSTRE_IMP_CLOSED)\r\nin_recovery = false;\r\nspin_unlock(&imp->imp_lock);\r\nreturn in_recovery;\r\n}\r\nint mgc_process_log(struct obd_device *mgc, struct config_llog_data *cld)\r\n{\r\nstruct lustre_handle lockh = { 0 };\r\n__u64 flags = LDLM_FL_NO_LRU;\r\nbool retry = false;\r\nint rc = 0, rcl;\r\nLASSERT(cld);\r\nrestart:\r\nmutex_lock(&cld->cld_lock);\r\nif (cld->cld_stopping) {\r\nmutex_unlock(&cld->cld_lock);\r\nreturn 0;\r\n}\r\nOBD_FAIL_TIMEOUT(OBD_FAIL_MGC_PAUSE_PROCESS_LOG, 20);\r\nCDEBUG(D_MGC, "Process log %s:%p from %d\n", cld->cld_logname,\r\ncld->cld_cfg.cfg_instance, cld->cld_cfg.cfg_last_idx + 1);\r\nrcl = mgc_enqueue(mgc->u.cli.cl_mgc_mgsexp, LDLM_PLAIN, NULL,\r\nLCK_CR, &flags, NULL, NULL, NULL,\r\ncld, 0, NULL, &lockh);\r\nif (rcl == 0) {\r\nconfig_log_get(cld);\r\nrc = ldlm_lock_set_data(&lockh, (void *)cld);\r\nLASSERT(rc == 0);\r\n} else {\r\nCDEBUG(D_MGC, "Can't get cfg lock: %d\n", rcl);\r\nif (rcl == -ESHUTDOWN &&\r\natomic_read(&mgc->u.cli.cl_mgc_refcount) > 0 && !retry) {\r\nint secs = cfs_time_seconds(obd_timeout);\r\nstruct obd_import *imp;\r\nstruct l_wait_info lwi;\r\nmutex_unlock(&cld->cld_lock);\r\nimp = class_exp2cliimp(mgc->u.cli.cl_mgc_mgsexp);\r\nptlrpc_pinger_force(imp);\r\nlwi = LWI_TIMEOUT(secs, NULL, NULL);\r\nl_wait_event(imp->imp_recovery_waitq,\r\n!mgc_import_in_recovery(imp), &lwi);\r\nif (imp->imp_state == LUSTRE_IMP_FULL) {\r\nretry = true;\r\ngoto restart;\r\n} else {\r\nmutex_lock(&cld->cld_lock);\r\nspin_lock(&config_list_lock);\r\ncld->cld_lostlock = 1;\r\nspin_unlock(&config_list_lock);\r\n}\r\n} else {\r\nspin_lock(&config_list_lock);\r\ncld->cld_lostlock = 1;\r\nspin_unlock(&config_list_lock);\r\n}\r\n}\r\nif (cld_is_recover(cld)) {\r\nrc = 0;\r\nif (!rcl) {\r\nrc = mgc_process_recover_log(mgc, cld);\r\nif (rc) {\r\nCERROR("%s: recover log %s failed: rc = %d not fatal.\n",\r\nmgc->obd_name, cld->cld_logname, rc);\r\nrc = 0;\r\nspin_lock(&config_list_lock);\r\ncld->cld_lostlock = 1;\r\nspin_unlock(&config_list_lock);\r\n}\r\n}\r\n} else {\r\nrc = mgc_process_cfg_log(mgc, cld, rcl != 0);\r\n}\r\nCDEBUG(D_MGC, "%s: configuration from log '%s' %sed (%d).\n",\r\nmgc->obd_name, cld->cld_logname, rc ? "fail" : "succeed", rc);\r\nmutex_unlock(&cld->cld_lock);\r\nif (!rcl)\r\nldlm_lock_decref(&lockh, LCK_CR);\r\nreturn rc;\r\n}\r\nstatic int mgc_process_config(struct obd_device *obd, u32 len, void *buf)\r\n{\r\nstruct lustre_cfg *lcfg = buf;\r\nstruct config_llog_instance *cfg = NULL;\r\nchar *logname;\r\nint rc = 0;\r\nswitch (lcfg->lcfg_command) {\r\ncase LCFG_LOV_ADD_OBD: {\r\nstruct mgs_target_info *mti;\r\nif (LUSTRE_CFG_BUFLEN(lcfg, 1) !=\r\nsizeof(struct mgs_target_info)) {\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nmti = (struct mgs_target_info *)lustre_cfg_buf(lcfg, 1);\r\nCDEBUG(D_MGC, "add_target %s %#x\n",\r\nmti->mti_svname, mti->mti_flags);\r\nrc = mgc_target_register(obd->u.cli.cl_mgc_mgsexp, mti);\r\nbreak;\r\n}\r\ncase LCFG_LOV_DEL_OBD:\r\nCERROR("lov_del_obd unimplemented\n");\r\nrc = -ENOSYS;\r\nbreak;\r\ncase LCFG_SPTLRPC_CONF: {\r\nrc = sptlrpc_process_config(lcfg);\r\nbreak;\r\n}\r\ncase LCFG_LOG_START: {\r\nstruct config_llog_data *cld;\r\nstruct super_block *sb;\r\nlogname = lustre_cfg_string(lcfg, 1);\r\ncfg = (struct config_llog_instance *)lustre_cfg_buf(lcfg, 2);\r\nsb = *(struct super_block **)lustre_cfg_buf(lcfg, 3);\r\nCDEBUG(D_MGC, "parse_log %s from %d\n", logname,\r\ncfg->cfg_last_idx);\r\ncld = config_log_add(obd, logname, cfg, sb);\r\nif (IS_ERR(cld)) {\r\nrc = PTR_ERR(cld);\r\nbreak;\r\n}\r\ncld->cld_cfg.cfg_flags |= CFG_F_COMPAT146;\r\nrc = mgc_process_log(obd, cld);\r\nif (rc == 0 && cld->cld_recover) {\r\nif (OCD_HAS_FLAG(&obd->u.cli.cl_import->\r\nimp_connect_data, IMP_RECOV)) {\r\nrc = mgc_process_log(obd, cld->cld_recover);\r\n} else {\r\nstruct config_llog_data *cir;\r\nmutex_lock(&cld->cld_lock);\r\ncir = cld->cld_recover;\r\ncld->cld_recover = NULL;\r\nmutex_unlock(&cld->cld_lock);\r\nconfig_log_put(cir);\r\n}\r\nif (rc)\r\nCERROR("Cannot process recover llog %d\n", rc);\r\n}\r\nif (rc == 0 && cld->cld_params) {\r\nrc = mgc_process_log(obd, cld->cld_params);\r\nif (rc == -ENOENT) {\r\nCDEBUG(D_MGC,\r\n"There is no params config file yet\n");\r\nrc = 0;\r\n}\r\nif (rc)\r\nCERROR(\r\n"%s: can't process params llog: rc = %d\n",\r\nobd->obd_name, rc);\r\n}\r\nbreak;\r\n}\r\ncase LCFG_LOG_END: {\r\nlogname = lustre_cfg_string(lcfg, 1);\r\nif (lcfg->lcfg_bufcount >= 2)\r\ncfg = (struct config_llog_instance *)lustre_cfg_buf(\r\nlcfg, 2);\r\nrc = config_log_end(logname, cfg);\r\nbreak;\r\n}\r\ndefault: {\r\nCERROR("Unknown command: %d\n", lcfg->lcfg_command);\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\nout:\r\nreturn rc;\r\n}\r\nstatic int __init mgc_init(void)\r\n{\r\nreturn class_register_type(&mgc_obd_ops, NULL,\r\nLUSTRE_MGC_NAME, NULL);\r\n}\r\nstatic void mgc_exit(void)\r\n{\r\nclass_unregister_type(LUSTRE_MGC_NAME);\r\n}
