static uint32_t axi_clkgen_lookup_filter(unsigned int m)\r\n{\r\nswitch (m) {\r\ncase 0:\r\nreturn 0x01001990;\r\ncase 1:\r\nreturn 0x01001190;\r\ncase 2:\r\nreturn 0x01009890;\r\ncase 3:\r\nreturn 0x01001890;\r\ncase 4:\r\nreturn 0x01008890;\r\ncase 5 ... 8:\r\nreturn 0x01009090;\r\ncase 9 ... 11:\r\nreturn 0x01000890;\r\ncase 12:\r\nreturn 0x08009090;\r\ncase 13 ... 22:\r\nreturn 0x01001090;\r\ncase 23 ... 36:\r\nreturn 0x01008090;\r\ncase 37 ... 46:\r\nreturn 0x08001090;\r\ndefault:\r\nreturn 0x08008090;\r\n}\r\n}\r\nstatic uint32_t axi_clkgen_lookup_lock(unsigned int m)\r\n{\r\nif (m < ARRAY_SIZE(axi_clkgen_lock_table))\r\nreturn axi_clkgen_lock_table[m];\r\nreturn 0x1f1f00fa;\r\n}\r\nstatic void axi_clkgen_calc_params(unsigned long fin, unsigned long fout,\r\nunsigned int *best_d, unsigned int *best_m, unsigned int *best_dout)\r\n{\r\nunsigned long d, d_min, d_max, _d_min, _d_max;\r\nunsigned long m, m_min, m_max;\r\nunsigned long f, dout, best_f, fvco;\r\nfin /= 1000;\r\nfout /= 1000;\r\nbest_f = ULONG_MAX;\r\n*best_d = 0;\r\n*best_m = 0;\r\n*best_dout = 0;\r\nd_min = max_t(unsigned long, DIV_ROUND_UP(fin, fpfd_max), 1);\r\nd_max = min_t(unsigned long, fin / fpfd_min, 80);\r\nm_min = max_t(unsigned long, DIV_ROUND_UP(fvco_min, fin) * d_min, 1);\r\nm_max = min_t(unsigned long, fvco_max * d_max / fin, 64);\r\nfor (m = m_min; m <= m_max; m++) {\r\n_d_min = max(d_min, DIV_ROUND_UP(fin * m, fvco_max));\r\n_d_max = min(d_max, fin * m / fvco_min);\r\nfor (d = _d_min; d <= _d_max; d++) {\r\nfvco = fin * m / d;\r\ndout = DIV_ROUND_CLOSEST(fvco, fout);\r\ndout = clamp_t(unsigned long, dout, 1, 128);\r\nf = fvco / dout;\r\nif (abs(f - fout) < abs(best_f - fout)) {\r\nbest_f = f;\r\n*best_d = d;\r\n*best_m = m;\r\n*best_dout = dout;\r\nif (best_f == fout)\r\nreturn;\r\n}\r\n}\r\n}\r\n}\r\nstatic void axi_clkgen_calc_clk_params(unsigned int divider, unsigned int *low,\r\nunsigned int *high, unsigned int *edge, unsigned int *nocount)\r\n{\r\nif (divider == 1)\r\n*nocount = 1;\r\nelse\r\n*nocount = 0;\r\n*high = divider / 2;\r\n*edge = divider % 2;\r\n*low = divider - *high;\r\n}\r\nstatic void axi_clkgen_write(struct axi_clkgen *axi_clkgen,\r\nunsigned int reg, unsigned int val)\r\n{\r\nwritel(val, axi_clkgen->base + reg);\r\n}\r\nstatic void axi_clkgen_read(struct axi_clkgen *axi_clkgen,\r\nunsigned int reg, unsigned int *val)\r\n{\r\n*val = readl(axi_clkgen->base + reg);\r\n}\r\nstatic int axi_clkgen_wait_non_busy(struct axi_clkgen *axi_clkgen)\r\n{\r\nunsigned int timeout = 10000;\r\nunsigned int val;\r\ndo {\r\naxi_clkgen_read(axi_clkgen, AXI_CLKGEN_V2_REG_DRP_STATUS, &val);\r\n} while ((val & AXI_CLKGEN_V2_DRP_STATUS_BUSY) && --timeout);\r\nif (val & AXI_CLKGEN_V2_DRP_STATUS_BUSY)\r\nreturn -EIO;\r\nreturn val & 0xffff;\r\n}\r\nstatic int axi_clkgen_mmcm_read(struct axi_clkgen *axi_clkgen,\r\nunsigned int reg, unsigned int *val)\r\n{\r\nunsigned int reg_val;\r\nint ret;\r\nret = axi_clkgen_wait_non_busy(axi_clkgen);\r\nif (ret < 0)\r\nreturn ret;\r\nreg_val = AXI_CLKGEN_V2_DRP_CNTRL_SEL | AXI_CLKGEN_V2_DRP_CNTRL_READ;\r\nreg_val |= (reg << 16);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_DRP_CNTRL, reg_val);\r\nret = axi_clkgen_wait_non_busy(axi_clkgen);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn 0;\r\n}\r\nstatic int axi_clkgen_mmcm_write(struct axi_clkgen *axi_clkgen,\r\nunsigned int reg, unsigned int val, unsigned int mask)\r\n{\r\nunsigned int reg_val = 0;\r\nint ret;\r\nret = axi_clkgen_wait_non_busy(axi_clkgen);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mask != 0xffff) {\r\naxi_clkgen_mmcm_read(axi_clkgen, reg, &reg_val);\r\nreg_val &= ~mask;\r\n}\r\nreg_val |= AXI_CLKGEN_V2_DRP_CNTRL_SEL | (reg << 16) | (val & mask);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_DRP_CNTRL, reg_val);\r\nreturn 0;\r\n}\r\nstatic void axi_clkgen_mmcm_enable(struct axi_clkgen *axi_clkgen,\r\nbool enable)\r\n{\r\nunsigned int val = AXI_CLKGEN_V2_RESET_ENABLE;\r\nif (enable)\r\nval |= AXI_CLKGEN_V2_RESET_MMCM_ENABLE;\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_RESET, val);\r\n}\r\nstatic struct axi_clkgen *clk_hw_to_axi_clkgen(struct clk_hw *clk_hw)\r\n{\r\nreturn container_of(clk_hw, struct axi_clkgen, clk_hw);\r\n}\r\nstatic int axi_clkgen_set_rate(struct clk_hw *clk_hw,\r\nunsigned long rate, unsigned long parent_rate)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\nunsigned int d, m, dout;\r\nunsigned int nocount;\r\nunsigned int high;\r\nunsigned int edge;\r\nunsigned int low;\r\nuint32_t filter;\r\nuint32_t lock;\r\nif (parent_rate == 0 || rate == 0)\r\nreturn -EINVAL;\r\naxi_clkgen_calc_params(parent_rate, rate, &d, &m, &dout);\r\nif (d == 0 || dout == 0 || m == 0)\r\nreturn -EINVAL;\r\nfilter = axi_clkgen_lookup_filter(m - 1);\r\nlock = axi_clkgen_lookup_lock(m - 1);\r\naxi_clkgen_calc_clk_params(dout, &low, &high, &edge, &nocount);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_CLKOUT0_1,\r\n(high << 6) | low, 0xefff);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_CLKOUT0_2,\r\n(edge << 7) | (nocount << 6), 0x03ff);\r\naxi_clkgen_calc_clk_params(d, &low, &high, &edge, &nocount);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_CLK_DIV,\r\n(edge << 13) | (nocount << 12) | (high << 6) | low, 0x3fff);\r\naxi_clkgen_calc_clk_params(m, &low, &high, &edge, &nocount);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_CLK_FB1,\r\n(high << 6) | low, 0xefff);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_CLK_FB2,\r\n(edge << 7) | (nocount << 6), 0x03ff);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_LOCK1, lock & 0x3ff, 0x3ff);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_LOCK2,\r\n(((lock >> 16) & 0x1f) << 10) | 0x1, 0x7fff);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_LOCK3,\r\n(((lock >> 24) & 0x1f) << 10) | 0x3e9, 0x7fff);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_FILTER1, filter >> 16, 0x9900);\r\naxi_clkgen_mmcm_write(axi_clkgen, MMCM_REG_FILTER2, filter, 0x9900);\r\nreturn 0;\r\n}\r\nstatic long axi_clkgen_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nunsigned int d, m, dout;\r\naxi_clkgen_calc_params(*parent_rate, rate, &d, &m, &dout);\r\nif (d == 0 || dout == 0 || m == 0)\r\nreturn -EINVAL;\r\nreturn *parent_rate / d * m / dout;\r\n}\r\nstatic unsigned long axi_clkgen_recalc_rate(struct clk_hw *clk_hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\nunsigned int d, m, dout;\r\nunsigned int reg;\r\nunsigned long long tmp;\r\naxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLKOUT0_1, &reg);\r\ndout = (reg & 0x3f) + ((reg >> 6) & 0x3f);\r\naxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLK_DIV, &reg);\r\nd = (reg & 0x3f) + ((reg >> 6) & 0x3f);\r\naxi_clkgen_mmcm_read(axi_clkgen, MMCM_REG_CLK_FB1, &reg);\r\nm = (reg & 0x3f) + ((reg >> 6) & 0x3f);\r\nif (d == 0 || dout == 0)\r\nreturn 0;\r\ntmp = (unsigned long long)(parent_rate / d) * m;\r\ndo_div(tmp, dout);\r\nreturn min_t(unsigned long long, tmp, ULONG_MAX);\r\n}\r\nstatic int axi_clkgen_enable(struct clk_hw *clk_hw)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\naxi_clkgen_mmcm_enable(axi_clkgen, true);\r\nreturn 0;\r\n}\r\nstatic void axi_clkgen_disable(struct clk_hw *clk_hw)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\naxi_clkgen_mmcm_enable(axi_clkgen, false);\r\n}\r\nstatic int axi_clkgen_set_parent(struct clk_hw *clk_hw, u8 index)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\naxi_clkgen_write(axi_clkgen, AXI_CLKGEN_V2_REG_CLKSEL, index);\r\nreturn 0;\r\n}\r\nstatic u8 axi_clkgen_get_parent(struct clk_hw *clk_hw)\r\n{\r\nstruct axi_clkgen *axi_clkgen = clk_hw_to_axi_clkgen(clk_hw);\r\nunsigned int parent;\r\naxi_clkgen_read(axi_clkgen, AXI_CLKGEN_V2_REG_CLKSEL, &parent);\r\nreturn parent;\r\n}\r\nstatic int axi_clkgen_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nstruct axi_clkgen *axi_clkgen;\r\nstruct clk_init_data init;\r\nconst char *parent_names[2];\r\nconst char *clk_name;\r\nstruct resource *mem;\r\nunsigned int i;\r\nint ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nid = of_match_node(axi_clkgen_ids, pdev->dev.of_node);\r\nif (!id)\r\nreturn -ENODEV;\r\naxi_clkgen = devm_kzalloc(&pdev->dev, sizeof(*axi_clkgen), GFP_KERNEL);\r\nif (!axi_clkgen)\r\nreturn -ENOMEM;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naxi_clkgen->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(axi_clkgen->base))\r\nreturn PTR_ERR(axi_clkgen->base);\r\ninit.num_parents = of_clk_get_parent_count(pdev->dev.of_node);\r\nif (init.num_parents < 1 || init.num_parents > 2)\r\nreturn -EINVAL;\r\nfor (i = 0; i < init.num_parents; i++) {\r\nparent_names[i] = of_clk_get_parent_name(pdev->dev.of_node, i);\r\nif (!parent_names[i])\r\nreturn -EINVAL;\r\n}\r\nclk_name = pdev->dev.of_node->name;\r\nof_property_read_string(pdev->dev.of_node, "clock-output-names",\r\n&clk_name);\r\ninit.name = clk_name;\r\ninit.ops = &axi_clkgen_ops;\r\ninit.flags = CLK_SET_RATE_GATE | CLK_SET_PARENT_GATE;\r\ninit.parent_names = parent_names;\r\naxi_clkgen_mmcm_enable(axi_clkgen, false);\r\naxi_clkgen->clk_hw.init = &init;\r\nret = devm_clk_hw_register(&pdev->dev, &axi_clkgen->clk_hw);\r\nif (ret)\r\nreturn ret;\r\nreturn of_clk_add_hw_provider(pdev->dev.of_node, of_clk_hw_simple_get,\r\n&axi_clkgen->clk_hw);\r\n}\r\nstatic int axi_clkgen_remove(struct platform_device *pdev)\r\n{\r\nof_clk_del_provider(pdev->dev.of_node);\r\nreturn 0;\r\n}
