static int xilinx_wdt_start(struct watchdog_device *wdd)\r\n{\r\nu32 control_status_reg;\r\nstruct xwdt_device *xdev = watchdog_get_drvdata(wdd);\r\nspin_lock(&xdev->spinlock);\r\ncontrol_status_reg = ioread32(xdev->base + XWT_TWCSR0_OFFSET);\r\ncontrol_status_reg |= (XWT_CSR0_WRS_MASK | XWT_CSR0_WDS_MASK);\r\niowrite32((control_status_reg | XWT_CSR0_EWDT1_MASK),\r\nxdev->base + XWT_TWCSR0_OFFSET);\r\niowrite32(XWT_CSRX_EWDT2_MASK, xdev->base + XWT_TWCSR1_OFFSET);\r\nspin_unlock(&xdev->spinlock);\r\nreturn 0;\r\n}\r\nstatic int xilinx_wdt_stop(struct watchdog_device *wdd)\r\n{\r\nu32 control_status_reg;\r\nstruct xwdt_device *xdev = watchdog_get_drvdata(wdd);\r\nspin_lock(&xdev->spinlock);\r\ncontrol_status_reg = ioread32(xdev->base + XWT_TWCSR0_OFFSET);\r\niowrite32((control_status_reg & ~XWT_CSR0_EWDT1_MASK),\r\nxdev->base + XWT_TWCSR0_OFFSET);\r\niowrite32(0, xdev->base + XWT_TWCSR1_OFFSET);\r\nspin_unlock(&xdev->spinlock);\r\npr_info("Stopped!\n");\r\nreturn 0;\r\n}\r\nstatic int xilinx_wdt_keepalive(struct watchdog_device *wdd)\r\n{\r\nu32 control_status_reg;\r\nstruct xwdt_device *xdev = watchdog_get_drvdata(wdd);\r\nspin_lock(&xdev->spinlock);\r\ncontrol_status_reg = ioread32(xdev->base + XWT_TWCSR0_OFFSET);\r\ncontrol_status_reg |= (XWT_CSR0_WRS_MASK | XWT_CSR0_WDS_MASK);\r\niowrite32(control_status_reg, xdev->base + XWT_TWCSR0_OFFSET);\r\nspin_unlock(&xdev->spinlock);\r\nreturn 0;\r\n}\r\nstatic u32 xwdt_selftest(struct xwdt_device *xdev)\r\n{\r\nint i;\r\nu32 timer_value1;\r\nu32 timer_value2;\r\nspin_lock(&xdev->spinlock);\r\ntimer_value1 = ioread32(xdev->base + XWT_TBR_OFFSET);\r\ntimer_value2 = ioread32(xdev->base + XWT_TBR_OFFSET);\r\nfor (i = 0;\r\n((i <= XWT_MAX_SELFTEST_LOOP_COUNT) &&\r\n(timer_value2 == timer_value1)); i++) {\r\ntimer_value2 = ioread32(xdev->base + XWT_TBR_OFFSET);\r\n}\r\nspin_unlock(&xdev->spinlock);\r\nif (timer_value2 != timer_value1)\r\nreturn ~XWT_TIMER_FAILED;\r\nelse\r\nreturn XWT_TIMER_FAILED;\r\n}\r\nstatic int xwdt_probe(struct platform_device *pdev)\r\n{\r\nint rc;\r\nu32 pfreq = 0, enable_once = 0;\r\nstruct resource *res;\r\nstruct xwdt_device *xdev;\r\nstruct watchdog_device *xilinx_wdt_wdd;\r\nxdev = devm_kzalloc(&pdev->dev, sizeof(*xdev), GFP_KERNEL);\r\nif (!xdev)\r\nreturn -ENOMEM;\r\nxilinx_wdt_wdd = &xdev->xilinx_wdt_wdd;\r\nxilinx_wdt_wdd->info = &xilinx_wdt_ident;\r\nxilinx_wdt_wdd->ops = &xilinx_wdt_ops;\r\nxilinx_wdt_wdd->parent = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nxdev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(xdev->base))\r\nreturn PTR_ERR(xdev->base);\r\nrc = of_property_read_u32(pdev->dev.of_node, "clock-frequency", &pfreq);\r\nif (rc)\r\ndev_warn(&pdev->dev,\r\n"The watchdog clock frequency cannot be obtained\n");\r\nrc = of_property_read_u32(pdev->dev.of_node, "xlnx,wdt-interval",\r\n&xdev->wdt_interval);\r\nif (rc)\r\ndev_warn(&pdev->dev,\r\n"Parameter \"xlnx,wdt-interval\" not found\n");\r\nrc = of_property_read_u32(pdev->dev.of_node, "xlnx,wdt-enable-once",\r\n&enable_once);\r\nif (rc)\r\ndev_warn(&pdev->dev,\r\n"Parameter \"xlnx,wdt-enable-once\" not found\n");\r\nwatchdog_set_nowayout(xilinx_wdt_wdd, enable_once);\r\nif (pfreq && xdev->wdt_interval)\r\nxilinx_wdt_wdd->timeout = 2 * ((1 << xdev->wdt_interval) /\r\npfreq);\r\nspin_lock_init(&xdev->spinlock);\r\nwatchdog_set_drvdata(xilinx_wdt_wdd, xdev);\r\nxdev->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(xdev->clk)) {\r\nif (PTR_ERR(xdev->clk) == -ENOENT)\r\nxdev->clk = NULL;\r\nelse\r\nreturn PTR_ERR(xdev->clk);\r\n}\r\nrc = clk_prepare_enable(xdev->clk);\r\nif (rc) {\r\ndev_err(&pdev->dev, "unable to enable clock\n");\r\nreturn rc;\r\n}\r\nrc = xwdt_selftest(xdev);\r\nif (rc == XWT_TIMER_FAILED) {\r\ndev_err(&pdev->dev, "SelfTest routine error\n");\r\ngoto err_clk_disable;\r\n}\r\nrc = watchdog_register_device(xilinx_wdt_wdd);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot register watchdog (err=%d)\n", rc);\r\ngoto err_clk_disable;\r\n}\r\ndev_info(&pdev->dev, "Xilinx Watchdog Timer at %p with timeout %ds\n",\r\nxdev->base, xilinx_wdt_wdd->timeout);\r\nplatform_set_drvdata(pdev, xdev);\r\nreturn 0;\r\nerr_clk_disable:\r\nclk_disable_unprepare(xdev->clk);\r\nreturn rc;\r\n}\r\nstatic int xwdt_remove(struct platform_device *pdev)\r\n{\r\nstruct xwdt_device *xdev = platform_get_drvdata(pdev);\r\nwatchdog_unregister_device(&xdev->xilinx_wdt_wdd);\r\nclk_disable_unprepare(xdev->clk);\r\nreturn 0;\r\n}
