static int\r\nci_hdrc_msm_por_reset(struct reset_controller_dev *r, unsigned long id)\r\n{\r\nstruct ci_hdrc_msm *ci_msm = container_of(r, struct ci_hdrc_msm, rcdev);\r\nvoid __iomem *addr = ci_msm->base;\r\nu32 val;\r\nif (id)\r\naddr += HS_PHY_SEC_CTRL;\r\nelse\r\naddr += HS_PHY_CTRL;\r\nval = readl_relaxed(addr);\r\nval |= HS_PHY_POR_ASSERT;\r\nwritel(val, addr);\r\nudelay(12);\r\nval &= ~HS_PHY_POR_ASSERT;\r\nwritel(val, addr);\r\nreturn 0;\r\n}\r\nstatic int ci_hdrc_msm_notify_event(struct ci_hdrc *ci, unsigned event)\r\n{\r\nstruct device *dev = ci->dev->parent;\r\nstruct ci_hdrc_msm *msm_ci = dev_get_drvdata(dev);\r\nint ret;\r\nswitch (event) {\r\ncase CI_HDRC_CONTROLLER_RESET_EVENT:\r\ndev_dbg(dev, "CI_HDRC_CONTROLLER_RESET_EVENT received\n");\r\nhw_phymode_configure(ci);\r\nif (msm_ci->secondary_phy) {\r\nu32 val = readl_relaxed(msm_ci->base + HS_PHY_SEC_CTRL);\r\nval |= HS_PHY_DIG_CLAMP_N;\r\nwritel_relaxed(val, msm_ci->base + HS_PHY_SEC_CTRL);\r\n}\r\nret = phy_init(ci->phy);\r\nif (ret)\r\nreturn ret;\r\nret = phy_power_on(ci->phy);\r\nif (ret) {\r\nphy_exit(ci->phy);\r\nreturn ret;\r\n}\r\nhw_write_id_reg(ci, HS_PHY_AHB_MODE, 0xffffffff, 0x8);\r\nhw_write_id_reg(ci, HS_PHY_GENCONFIG,\r\nHS_PHY_TXFIFO_IDLE_FORCE_DIS, 0);\r\nif (!msm_ci->hsic)\r\nhw_write_id_reg(ci, HS_PHY_GENCONFIG_2,\r\nHS_PHY_ULPI_TX_PKT_EN_CLR_FIX, 0);\r\nif (!IS_ERR(ci->platdata->vbus_extcon.edev)) {\r\nhw_write_id_reg(ci, HS_PHY_GENCONFIG_2,\r\nHS_PHY_SESS_VLD_CTRL_EN,\r\nHS_PHY_SESS_VLD_CTRL_EN);\r\nhw_write(ci, OP_USBCMD, HSPHY_SESS_VLD_CTRL,\r\nHSPHY_SESS_VLD_CTRL);\r\n}\r\nbreak;\r\ncase CI_HDRC_CONTROLLER_STOPPED_EVENT:\r\ndev_dbg(dev, "CI_HDRC_CONTROLLER_STOPPED_EVENT received\n");\r\nphy_power_off(ci->phy);\r\nphy_exit(ci->phy);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "unknown ci_hdrc event\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_hdrc_msm_mux_phy(struct ci_hdrc_msm *ci,\r\nstruct platform_device *pdev)\r\n{\r\nstruct regmap *regmap;\r\nstruct device *dev = &pdev->dev;\r\nstruct of_phandle_args args;\r\nu32 val;\r\nint ret;\r\nret = of_parse_phandle_with_fixed_args(dev->of_node, "phy-select", 2, 0,\r\n&args);\r\nif (ret)\r\nreturn 0;\r\nregmap = syscon_node_to_regmap(args.np);\r\nof_node_put(args.np);\r\nif (IS_ERR(regmap))\r\nreturn PTR_ERR(regmap);\r\nret = regmap_write(regmap, args.args[0], args.args[1]);\r\nif (ret)\r\nreturn ret;\r\nci->secondary_phy = !!args.args[1];\r\nif (ci->secondary_phy) {\r\nval = readl_relaxed(ci->base + HS_PHY_SEC_CTRL);\r\nval |= HS_PHY_DIG_CLAMP_N;\r\nwritel_relaxed(val, ci->base + HS_PHY_SEC_CTRL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int ci_hdrc_msm_probe(struct platform_device *pdev)\r\n{\r\nstruct ci_hdrc_msm *ci;\r\nstruct platform_device *plat_ci;\r\nstruct clk *clk;\r\nstruct reset_control *reset;\r\nstruct resource *res;\r\nint ret;\r\nstruct device_node *ulpi_node, *phy_node;\r\ndev_dbg(&pdev->dev, "ci_hdrc_msm_probe\n");\r\nci = devm_kzalloc(&pdev->dev, sizeof(*ci), GFP_KERNEL);\r\nif (!ci)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ci);\r\nci->pdata.name = "ci_hdrc_msm";\r\nci->pdata.capoffset = DEF_CAPOFFSET;\r\nci->pdata.flags = CI_HDRC_REGS_SHARED | CI_HDRC_DISABLE_STREAMING |\r\nCI_HDRC_OVERRIDE_AHB_BURST |\r\nCI_HDRC_OVERRIDE_PHY_CONTROL;\r\nci->pdata.notify_event = ci_hdrc_msm_notify_event;\r\nreset = devm_reset_control_get(&pdev->dev, "core");\r\nif (IS_ERR(reset))\r\nreturn PTR_ERR(reset);\r\nci->core_clk = clk = devm_clk_get(&pdev->dev, "core");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nci->iface_clk = clk = devm_clk_get(&pdev->dev, "iface");\r\nif (IS_ERR(clk))\r\nreturn PTR_ERR(clk);\r\nci->fs_clk = clk = devm_clk_get(&pdev->dev, "fs");\r\nif (IS_ERR(clk)) {\r\nif (PTR_ERR(clk) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nci->fs_clk = NULL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nci->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ci->base))\r\nreturn PTR_ERR(ci->base);\r\nci->rcdev.owner = THIS_MODULE;\r\nci->rcdev.ops = &ci_hdrc_msm_reset_ops;\r\nci->rcdev.of_node = pdev->dev.of_node;\r\nci->rcdev.nr_resets = 2;\r\nret = reset_controller_register(&ci->rcdev);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(ci->fs_clk);\r\nif (ret)\r\ngoto err_fs;\r\nreset_control_assert(reset);\r\nusleep_range(10000, 12000);\r\nreset_control_deassert(reset);\r\nclk_disable_unprepare(ci->fs_clk);\r\nret = clk_prepare_enable(ci->core_clk);\r\nif (ret)\r\ngoto err_fs;\r\nret = clk_prepare_enable(ci->iface_clk);\r\nif (ret)\r\ngoto err_iface;\r\nret = ci_hdrc_msm_mux_phy(ci, pdev);\r\nif (ret)\r\ngoto err_mux;\r\nulpi_node = of_find_node_by_name(pdev->dev.of_node, "ulpi");\r\nif (ulpi_node) {\r\nphy_node = of_get_next_available_child(ulpi_node, NULL);\r\nci->hsic = of_device_is_compatible(phy_node, "qcom,usb-hsic-phy");\r\nof_node_put(phy_node);\r\n}\r\nof_node_put(ulpi_node);\r\nplat_ci = ci_hdrc_add_device(&pdev->dev, pdev->resource,\r\npdev->num_resources, &ci->pdata);\r\nif (IS_ERR(plat_ci)) {\r\nret = PTR_ERR(plat_ci);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "ci_hdrc_add_device failed!\n");\r\ngoto err_mux;\r\n}\r\nci->ci = plat_ci;\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_no_callbacks(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nreturn 0;\r\nerr_mux:\r\nclk_disable_unprepare(ci->iface_clk);\r\nerr_iface:\r\nclk_disable_unprepare(ci->core_clk);\r\nerr_fs:\r\nreset_controller_unregister(&ci->rcdev);\r\nreturn ret;\r\n}\r\nstatic int ci_hdrc_msm_remove(struct platform_device *pdev)\r\n{\r\nstruct ci_hdrc_msm *ci = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nci_hdrc_remove_device(ci->ci);\r\nclk_disable_unprepare(ci->iface_clk);\r\nclk_disable_unprepare(ci->core_clk);\r\nreset_controller_unregister(&ci->rcdev);\r\nreturn 0;\r\n}
