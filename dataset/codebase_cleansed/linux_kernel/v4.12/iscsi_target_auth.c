static int chap_string_to_hex(unsigned char *dst, unsigned char *src, int len)\r\n{\r\nint j = DIV_ROUND_UP(len, 2), rc;\r\nrc = hex2bin(dst, src, j);\r\nif (rc < 0)\r\npr_debug("CHAP string contains non hex digit symbols\n");\r\ndst[j] = '\0';\r\nreturn j;\r\n}\r\nstatic void chap_binaryhex_to_asciihex(char *dst, char *src, int src_len)\r\n{\r\nint i;\r\nfor (i = 0; i < src_len; i++) {\r\nsprintf(&dst[i*2], "%02x", (int) src[i] & 0xff);\r\n}\r\n}\r\nstatic void chap_gen_challenge(\r\nstruct iscsi_conn *conn,\r\nint caller,\r\nchar *c_str,\r\nunsigned int *c_len)\r\n{\r\nunsigned char challenge_asciihex[CHAP_CHALLENGE_LENGTH * 2 + 1];\r\nstruct iscsi_chap *chap = conn->auth_protocol;\r\nmemset(challenge_asciihex, 0, CHAP_CHALLENGE_LENGTH * 2 + 1);\r\nget_random_bytes(chap->challenge, CHAP_CHALLENGE_LENGTH);\r\nchap_binaryhex_to_asciihex(challenge_asciihex, chap->challenge,\r\nCHAP_CHALLENGE_LENGTH);\r\n*c_len += sprintf(c_str + *c_len, "CHAP_C=0x%s", challenge_asciihex);\r\n*c_len += 1;\r\npr_debug("[%s] Sending CHAP_C=0x%s\n\n", (caller) ? "server" : "client",\r\nchallenge_asciihex);\r\n}\r\nstatic int chap_check_algorithm(const char *a_str)\r\n{\r\nchar *tmp, *orig, *token;\r\ntmp = kstrdup(a_str, GFP_KERNEL);\r\nif (!tmp) {\r\npr_err("Memory allocation failed for CHAP_A temporary buffer\n");\r\nreturn CHAP_DIGEST_UNKNOWN;\r\n}\r\norig = tmp;\r\ntoken = strsep(&tmp, "=");\r\nif (!token)\r\ngoto out;\r\nif (strcmp(token, "CHAP_A")) {\r\npr_err("Unable to locate CHAP_A key\n");\r\ngoto out;\r\n}\r\nwhile (token) {\r\ntoken = strsep(&tmp, ",");\r\nif (!token)\r\ngoto out;\r\nif (!strncmp(token, "5", 1)) {\r\npr_debug("Selected MD5 Algorithm\n");\r\nkfree(orig);\r\nreturn CHAP_DIGEST_MD5;\r\n}\r\n}\r\nout:\r\nkfree(orig);\r\nreturn CHAP_DIGEST_UNKNOWN;\r\n}\r\nstatic struct iscsi_chap *chap_server_open(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_node_auth *auth,\r\nconst char *a_str,\r\nchar *aic_str,\r\nunsigned int *aic_len)\r\n{\r\nint ret;\r\nstruct iscsi_chap *chap;\r\nif (!(auth->naf_flags & NAF_USERID_SET) ||\r\n!(auth->naf_flags & NAF_PASSWORD_SET)) {\r\npr_err("CHAP user or password not set for"\r\n" Initiator ACL\n");\r\nreturn NULL;\r\n}\r\nconn->auth_protocol = kzalloc(sizeof(struct iscsi_chap), GFP_KERNEL);\r\nif (!conn->auth_protocol)\r\nreturn NULL;\r\nchap = conn->auth_protocol;\r\nret = chap_check_algorithm(a_str);\r\nswitch (ret) {\r\ncase CHAP_DIGEST_MD5:\r\npr_debug("[server] Got CHAP_A=5\n");\r\n*aic_len = sprintf(aic_str, "CHAP_A=5");\r\n*aic_len += 1;\r\nchap->digest_type = CHAP_DIGEST_MD5;\r\npr_debug("[server] Sending CHAP_A=%d\n", chap->digest_type);\r\nbreak;\r\ncase CHAP_DIGEST_UNKNOWN:\r\ndefault:\r\npr_err("Unsupported CHAP_A value\n");\r\nreturn NULL;\r\n}\r\nchap->id = conn->tpg->tpg_chap_id++;\r\n*aic_len += sprintf(aic_str + *aic_len, "CHAP_I=%d", chap->id);\r\n*aic_len += 1;\r\npr_debug("[server] Sending CHAP_I=%d\n", chap->id);\r\nchap_gen_challenge(conn, 1, aic_str, aic_len);\r\nreturn chap;\r\n}\r\nstatic void chap_close(struct iscsi_conn *conn)\r\n{\r\nkfree(conn->auth_protocol);\r\nconn->auth_protocol = NULL;\r\n}\r\nstatic int chap_server_compute_md5(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_node_auth *auth,\r\nchar *nr_in_ptr,\r\nchar *nr_out_ptr,\r\nunsigned int *nr_out_len)\r\n{\r\nunsigned long id;\r\nunsigned char id_as_uchar;\r\nunsigned char digest[MD5_SIGNATURE_SIZE];\r\nunsigned char type, response[MD5_SIGNATURE_SIZE * 2 + 2];\r\nunsigned char identifier[10], *challenge = NULL;\r\nunsigned char *challenge_binhex = NULL;\r\nunsigned char client_digest[MD5_SIGNATURE_SIZE];\r\nunsigned char server_digest[MD5_SIGNATURE_SIZE];\r\nunsigned char chap_n[MAX_CHAP_N_SIZE], chap_r[MAX_RESPONSE_LENGTH];\r\nsize_t compare_len;\r\nstruct iscsi_chap *chap = conn->auth_protocol;\r\nstruct crypto_shash *tfm = NULL;\r\nstruct shash_desc *desc = NULL;\r\nint auth_ret = -1, ret, challenge_len;\r\nmemset(identifier, 0, 10);\r\nmemset(chap_n, 0, MAX_CHAP_N_SIZE);\r\nmemset(chap_r, 0, MAX_RESPONSE_LENGTH);\r\nmemset(digest, 0, MD5_SIGNATURE_SIZE);\r\nmemset(response, 0, MD5_SIGNATURE_SIZE * 2 + 2);\r\nmemset(client_digest, 0, MD5_SIGNATURE_SIZE);\r\nmemset(server_digest, 0, MD5_SIGNATURE_SIZE);\r\nchallenge = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\r\nif (!challenge) {\r\npr_err("Unable to allocate challenge buffer\n");\r\ngoto out;\r\n}\r\nchallenge_binhex = kzalloc(CHAP_CHALLENGE_STR_LEN, GFP_KERNEL);\r\nif (!challenge_binhex) {\r\npr_err("Unable to allocate challenge_binhex buffer\n");\r\ngoto out;\r\n}\r\nif (extract_param(nr_in_ptr, "CHAP_N", MAX_CHAP_N_SIZE, chap_n,\r\n&type) < 0) {\r\npr_err("Could not find CHAP_N.\n");\r\ngoto out;\r\n}\r\nif (type == HEX) {\r\npr_err("Could not find CHAP_N.\n");\r\ngoto out;\r\n}\r\ncompare_len = strlen(auth->userid) + 1;\r\nif (strncmp(chap_n, auth->userid, compare_len) != 0) {\r\npr_err("CHAP_N values do not match!\n");\r\ngoto out;\r\n}\r\npr_debug("[server] Got CHAP_N=%s\n", chap_n);\r\nif (extract_param(nr_in_ptr, "CHAP_R", MAX_RESPONSE_LENGTH, chap_r,\r\n&type) < 0) {\r\npr_err("Could not find CHAP_R.\n");\r\ngoto out;\r\n}\r\nif (type != HEX) {\r\npr_err("Could not find CHAP_R.\n");\r\ngoto out;\r\n}\r\npr_debug("[server] Got CHAP_R=%s\n", chap_r);\r\nchap_string_to_hex(client_digest, chap_r, strlen(chap_r));\r\ntfm = crypto_alloc_shash("md5", 0, 0);\r\nif (IS_ERR(tfm)) {\r\ntfm = NULL;\r\npr_err("Unable to allocate struct crypto_shash\n");\r\ngoto out;\r\n}\r\ndesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(tfm), GFP_KERNEL);\r\nif (!desc) {\r\npr_err("Unable to allocate struct shash_desc\n");\r\ngoto out;\r\n}\r\ndesc->tfm = tfm;\r\ndesc->flags = 0;\r\nret = crypto_shash_init(desc);\r\nif (ret < 0) {\r\npr_err("crypto_shash_init() failed\n");\r\ngoto out;\r\n}\r\nret = crypto_shash_update(desc, &chap->id, 1);\r\nif (ret < 0) {\r\npr_err("crypto_shash_update() failed for id\n");\r\ngoto out;\r\n}\r\nret = crypto_shash_update(desc, (char *)&auth->password,\r\nstrlen(auth->password));\r\nif (ret < 0) {\r\npr_err("crypto_shash_update() failed for password\n");\r\ngoto out;\r\n}\r\nret = crypto_shash_finup(desc, chap->challenge,\r\nCHAP_CHALLENGE_LENGTH, server_digest);\r\nif (ret < 0) {\r\npr_err("crypto_shash_finup() failed for challenge\n");\r\ngoto out;\r\n}\r\nchap_binaryhex_to_asciihex(response, server_digest, MD5_SIGNATURE_SIZE);\r\npr_debug("[server] MD5 Server Digest: %s\n", response);\r\nif (memcmp(server_digest, client_digest, MD5_SIGNATURE_SIZE) != 0) {\r\npr_debug("[server] MD5 Digests do not match!\n\n");\r\ngoto out;\r\n} else\r\npr_debug("[server] MD5 Digests match, CHAP connection"\r\n" successful.\n\n");\r\nif (!auth->authenticate_target) {\r\nauth_ret = 0;\r\ngoto out;\r\n}\r\nif (extract_param(nr_in_ptr, "CHAP_I", 10, identifier, &type) < 0) {\r\npr_err("Could not find CHAP_I.\n");\r\ngoto out;\r\n}\r\nif (type == HEX)\r\nret = kstrtoul(&identifier[2], 0, &id);\r\nelse\r\nret = kstrtoul(identifier, 0, &id);\r\nif (ret < 0) {\r\npr_err("kstrtoul() failed for CHAP identifier: %d\n", ret);\r\ngoto out;\r\n}\r\nif (id > 255) {\r\npr_err("chap identifier: %lu greater than 255\n", id);\r\ngoto out;\r\n}\r\npr_debug("[server] Got CHAP_I=%lu\n", id);\r\nif (extract_param(nr_in_ptr, "CHAP_C", CHAP_CHALLENGE_STR_LEN,\r\nchallenge, &type) < 0) {\r\npr_err("Could not find CHAP_C.\n");\r\ngoto out;\r\n}\r\nif (type != HEX) {\r\npr_err("Could not find CHAP_C.\n");\r\ngoto out;\r\n}\r\npr_debug("[server] Got CHAP_C=%s\n", challenge);\r\nchallenge_len = chap_string_to_hex(challenge_binhex, challenge,\r\nstrlen(challenge));\r\nif (!challenge_len) {\r\npr_err("Unable to convert incoming challenge\n");\r\ngoto out;\r\n}\r\nif (challenge_len > 1024) {\r\npr_err("CHAP_C exceeds maximum binary size of 1024 bytes\n");\r\ngoto out;\r\n}\r\nif (!memcmp(challenge_binhex, chap->challenge, CHAP_CHALLENGE_LENGTH)) {\r\npr_err("initiator CHAP_C matches target CHAP_C, failing"\r\n" login attempt\n");\r\ngoto out;\r\n}\r\nret = crypto_shash_init(desc);\r\nif (ret < 0) {\r\npr_err("crypto_shash_init() failed\n");\r\ngoto out;\r\n}\r\nid_as_uchar = id;\r\nret = crypto_shash_update(desc, &id_as_uchar, 1);\r\nif (ret < 0) {\r\npr_err("crypto_shash_update() failed for id\n");\r\ngoto out;\r\n}\r\nret = crypto_shash_update(desc, auth->password_mutual,\r\nstrlen(auth->password_mutual));\r\nif (ret < 0) {\r\npr_err("crypto_shash_update() failed for"\r\n" password_mutual\n");\r\ngoto out;\r\n}\r\nret = crypto_shash_finup(desc, challenge_binhex, challenge_len,\r\ndigest);\r\nif (ret < 0) {\r\npr_err("crypto_shash_finup() failed for ma challenge\n");\r\ngoto out;\r\n}\r\n*nr_out_len = sprintf(nr_out_ptr, "CHAP_N=%s", auth->userid_mutual);\r\n*nr_out_len += 1;\r\npr_debug("[server] Sending CHAP_N=%s\n", auth->userid_mutual);\r\nchap_binaryhex_to_asciihex(response, digest, MD5_SIGNATURE_SIZE);\r\n*nr_out_len += sprintf(nr_out_ptr + *nr_out_len, "CHAP_R=0x%s",\r\nresponse);\r\n*nr_out_len += 1;\r\npr_debug("[server] Sending CHAP_R=0x%s\n", response);\r\nauth_ret = 0;\r\nout:\r\nkzfree(desc);\r\ncrypto_free_shash(tfm);\r\nkfree(challenge);\r\nkfree(challenge_binhex);\r\nreturn auth_ret;\r\n}\r\nstatic int chap_got_response(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_node_auth *auth,\r\nchar *nr_in_ptr,\r\nchar *nr_out_ptr,\r\nunsigned int *nr_out_len)\r\n{\r\nstruct iscsi_chap *chap = conn->auth_protocol;\r\nswitch (chap->digest_type) {\r\ncase CHAP_DIGEST_MD5:\r\nif (chap_server_compute_md5(conn, auth, nr_in_ptr,\r\nnr_out_ptr, nr_out_len) < 0)\r\nreturn -1;\r\nreturn 0;\r\ndefault:\r\npr_err("Unknown CHAP digest type %d!\n",\r\nchap->digest_type);\r\nreturn -1;\r\n}\r\n}\r\nu32 chap_main_loop(\r\nstruct iscsi_conn *conn,\r\nstruct iscsi_node_auth *auth,\r\nchar *in_text,\r\nchar *out_text,\r\nint *in_len,\r\nint *out_len)\r\n{\r\nstruct iscsi_chap *chap = conn->auth_protocol;\r\nif (!chap) {\r\nchap = chap_server_open(conn, auth, in_text, out_text, out_len);\r\nif (!chap)\r\nreturn 2;\r\nchap->chap_state = CHAP_STAGE_SERVER_AIC;\r\nreturn 0;\r\n} else if (chap->chap_state == CHAP_STAGE_SERVER_AIC) {\r\nconvert_null_to_semi(in_text, *in_len);\r\nif (chap_got_response(conn, auth, in_text, out_text,\r\nout_len) < 0) {\r\nchap_close(conn);\r\nreturn 2;\r\n}\r\nif (auth->authenticate_target)\r\nchap->chap_state = CHAP_STAGE_SERVER_NR;\r\nelse\r\n*out_len = 0;\r\nchap_close(conn);\r\nreturn 1;\r\n}\r\nreturn 2;\r\n}
