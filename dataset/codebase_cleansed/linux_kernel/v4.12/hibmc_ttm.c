static inline struct hibmc_drm_private *\r\nhibmc_bdev(struct ttm_bo_device *bd)\r\n{\r\nreturn container_of(bd, struct hibmc_drm_private, bdev);\r\n}\r\nstatic int\r\nhibmc_ttm_mem_global_init(struct drm_global_reference *ref)\r\n{\r\nreturn ttm_mem_global_init(ref->object);\r\n}\r\nstatic void\r\nhibmc_ttm_mem_global_release(struct drm_global_reference *ref)\r\n{\r\nttm_mem_global_release(ref->object);\r\n}\r\nstatic int hibmc_ttm_global_init(struct hibmc_drm_private *hibmc)\r\n{\r\nint ret;\r\nhibmc->mem_global_ref.global_type = DRM_GLOBAL_TTM_MEM;\r\nhibmc->mem_global_ref.size = sizeof(struct ttm_mem_global);\r\nhibmc->mem_global_ref.init = &hibmc_ttm_mem_global_init;\r\nhibmc->mem_global_ref.release = &hibmc_ttm_mem_global_release;\r\nret = drm_global_item_ref(&hibmc->mem_global_ref);\r\nif (ret) {\r\nDRM_ERROR("could not get ref on ttm global: %d\n", ret);\r\nreturn ret;\r\n}\r\nhibmc->bo_global_ref.mem_glob =\r\nhibmc->mem_global_ref.object;\r\nhibmc->bo_global_ref.ref.global_type = DRM_GLOBAL_TTM_BO;\r\nhibmc->bo_global_ref.ref.size = sizeof(struct ttm_bo_global);\r\nhibmc->bo_global_ref.ref.init = &ttm_bo_global_init;\r\nhibmc->bo_global_ref.ref.release = &ttm_bo_global_release;\r\nret = drm_global_item_ref(&hibmc->bo_global_ref.ref);\r\nif (ret) {\r\nDRM_ERROR("failed setting up TTM BO subsystem: %d\n", ret);\r\ndrm_global_item_unref(&hibmc->mem_global_ref);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nhibmc_ttm_global_release(struct hibmc_drm_private *hibmc)\r\n{\r\ndrm_global_item_unref(&hibmc->bo_global_ref.ref);\r\ndrm_global_item_unref(&hibmc->mem_global_ref);\r\nhibmc->mem_global_ref.release = NULL;\r\n}\r\nstatic void hibmc_bo_ttm_destroy(struct ttm_buffer_object *tbo)\r\n{\r\nstruct hibmc_bo *bo = container_of(tbo, struct hibmc_bo, bo);\r\ndrm_gem_object_release(&bo->gem);\r\nkfree(bo);\r\n}\r\nstatic bool hibmc_ttm_bo_is_hibmc_bo(struct ttm_buffer_object *bo)\r\n{\r\nreturn bo->destroy == &hibmc_bo_ttm_destroy;\r\n}\r\nstatic int\r\nhibmc_bo_init_mem_type(struct ttm_bo_device *bdev, u32 type,\r\nstruct ttm_mem_type_manager *man)\r\n{\r\nswitch (type) {\r\ncase TTM_PL_SYSTEM:\r\nman->flags = TTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_MASK_CACHING;\r\nman->default_caching = TTM_PL_FLAG_CACHED;\r\nbreak;\r\ncase TTM_PL_VRAM:\r\nman->func = &ttm_bo_manager_func;\r\nman->flags = TTM_MEMTYPE_FLAG_FIXED |\r\nTTM_MEMTYPE_FLAG_MAPPABLE;\r\nman->available_caching = TTM_PL_FLAG_UNCACHED |\r\nTTM_PL_FLAG_WC;\r\nman->default_caching = TTM_PL_FLAG_WC;\r\nbreak;\r\ndefault:\r\nDRM_ERROR("unsupported memory type %u\n", type);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid hibmc_ttm_placement(struct hibmc_bo *bo, int domain)\r\n{\r\nu32 count = 0;\r\nu32 i;\r\nbo->placement.placement = bo->placements;\r\nbo->placement.busy_placement = bo->placements;\r\nif (domain & TTM_PL_FLAG_VRAM)\r\nbo->placements[count++].flags = TTM_PL_FLAG_WC |\r\nTTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_VRAM;\r\nif (domain & TTM_PL_FLAG_SYSTEM)\r\nbo->placements[count++].flags = TTM_PL_MASK_CACHING |\r\nTTM_PL_FLAG_SYSTEM;\r\nif (!count)\r\nbo->placements[count++].flags = TTM_PL_MASK_CACHING |\r\nTTM_PL_FLAG_SYSTEM;\r\nbo->placement.num_placement = count;\r\nbo->placement.num_busy_placement = count;\r\nfor (i = 0; i < count; i++) {\r\nbo->placements[i].fpfn = 0;\r\nbo->placements[i].lpfn = 0;\r\n}\r\n}\r\nstatic void\r\nhibmc_bo_evict_flags(struct ttm_buffer_object *bo, struct ttm_placement *pl)\r\n{\r\nstruct hibmc_bo *hibmcbo = hibmc_bo(bo);\r\nif (!hibmc_ttm_bo_is_hibmc_bo(bo))\r\nreturn;\r\nhibmc_ttm_placement(hibmcbo, TTM_PL_FLAG_SYSTEM);\r\n*pl = hibmcbo->placement;\r\n}\r\nstatic int hibmc_bo_verify_access(struct ttm_buffer_object *bo,\r\nstruct file *filp)\r\n{\r\nstruct hibmc_bo *hibmcbo = hibmc_bo(bo);\r\nreturn drm_vma_node_verify_access(&hibmcbo->gem.vma_node,\r\nfilp->private_data);\r\n}\r\nstatic int hibmc_ttm_io_mem_reserve(struct ttm_bo_device *bdev,\r\nstruct ttm_mem_reg *mem)\r\n{\r\nstruct ttm_mem_type_manager *man = &bdev->man[mem->mem_type];\r\nstruct hibmc_drm_private *hibmc = hibmc_bdev(bdev);\r\nmem->bus.addr = NULL;\r\nmem->bus.offset = 0;\r\nmem->bus.size = mem->num_pages << PAGE_SHIFT;\r\nmem->bus.base = 0;\r\nmem->bus.is_iomem = false;\r\nif (!(man->flags & TTM_MEMTYPE_FLAG_MAPPABLE))\r\nreturn -EINVAL;\r\nswitch (mem->mem_type) {\r\ncase TTM_PL_SYSTEM:\r\nreturn 0;\r\ncase TTM_PL_VRAM:\r\nmem->bus.offset = mem->start << PAGE_SHIFT;\r\nmem->bus.base = pci_resource_start(hibmc->dev->pdev, 0);\r\nmem->bus.is_iomem = true;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hibmc_ttm_backend_destroy(struct ttm_tt *tt)\r\n{\r\nttm_tt_fini(tt);\r\nkfree(tt);\r\n}\r\nstatic struct ttm_tt *hibmc_ttm_tt_create(struct ttm_bo_device *bdev,\r\nunsigned long size,\r\nu32 page_flags,\r\nstruct page *dummy_read_page)\r\n{\r\nstruct ttm_tt *tt;\r\nint ret;\r\ntt = kzalloc(sizeof(*tt), GFP_KERNEL);\r\nif (!tt) {\r\nDRM_ERROR("failed to allocate ttm_tt\n");\r\nreturn NULL;\r\n}\r\ntt->func = &hibmc_tt_backend_func;\r\nret = ttm_tt_init(tt, bdev, size, page_flags, dummy_read_page);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize ttm_tt: %d\n", ret);\r\nkfree(tt);\r\nreturn NULL;\r\n}\r\nreturn tt;\r\n}\r\nstatic int hibmc_ttm_tt_populate(struct ttm_tt *ttm)\r\n{\r\nreturn ttm_pool_populate(ttm);\r\n}\r\nstatic void hibmc_ttm_tt_unpopulate(struct ttm_tt *ttm)\r\n{\r\nttm_pool_unpopulate(ttm);\r\n}\r\nint hibmc_mm_init(struct hibmc_drm_private *hibmc)\r\n{\r\nint ret;\r\nstruct drm_device *dev = hibmc->dev;\r\nstruct ttm_bo_device *bdev = &hibmc->bdev;\r\nret = hibmc_ttm_global_init(hibmc);\r\nif (ret)\r\nreturn ret;\r\nret = ttm_bo_device_init(&hibmc->bdev,\r\nhibmc->bo_global_ref.ref.object,\r\n&hibmc_bo_driver,\r\ndev->anon_inode->i_mapping,\r\nDRM_FILE_PAGE_OFFSET,\r\ntrue);\r\nif (ret) {\r\nhibmc_ttm_global_release(hibmc);\r\nDRM_ERROR("error initializing bo driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = ttm_bo_init_mm(bdev, TTM_PL_VRAM,\r\nhibmc->fb_size >> PAGE_SHIFT);\r\nif (ret) {\r\nhibmc_ttm_global_release(hibmc);\r\nDRM_ERROR("failed ttm VRAM init: %d\n", ret);\r\nreturn ret;\r\n}\r\nhibmc->mm_inited = true;\r\nreturn 0;\r\n}\r\nvoid hibmc_mm_fini(struct hibmc_drm_private *hibmc)\r\n{\r\nif (!hibmc->mm_inited)\r\nreturn;\r\nttm_bo_device_release(&hibmc->bdev);\r\nhibmc_ttm_global_release(hibmc);\r\nhibmc->mm_inited = false;\r\n}\r\nstatic void hibmc_bo_unref(struct hibmc_bo **bo)\r\n{\r\nstruct ttm_buffer_object *tbo;\r\nif ((*bo) == NULL)\r\nreturn;\r\ntbo = &((*bo)->bo);\r\nttm_bo_unref(&tbo);\r\n*bo = NULL;\r\n}\r\nint hibmc_bo_create(struct drm_device *dev, int size, int align,\r\nu32 flags, struct hibmc_bo **phibmcbo)\r\n{\r\nstruct hibmc_drm_private *hibmc = dev->dev_private;\r\nstruct hibmc_bo *hibmcbo;\r\nsize_t acc_size;\r\nint ret;\r\nhibmcbo = kzalloc(sizeof(*hibmcbo), GFP_KERNEL);\r\nif (!hibmcbo) {\r\nDRM_ERROR("failed to allocate hibmcbo\n");\r\nreturn -ENOMEM;\r\n}\r\nret = drm_gem_object_init(dev, &hibmcbo->gem, size);\r\nif (ret) {\r\nDRM_ERROR("failed to initialize drm gem object: %d\n", ret);\r\nkfree(hibmcbo);\r\nreturn ret;\r\n}\r\nhibmcbo->bo.bdev = &hibmc->bdev;\r\nhibmc_ttm_placement(hibmcbo, TTM_PL_FLAG_VRAM | TTM_PL_FLAG_SYSTEM);\r\nacc_size = ttm_bo_dma_acc_size(&hibmc->bdev, size,\r\nsizeof(struct hibmc_bo));\r\nret = ttm_bo_init(&hibmc->bdev, &hibmcbo->bo, size,\r\nttm_bo_type_device, &hibmcbo->placement,\r\nalign >> PAGE_SHIFT, false, NULL, acc_size,\r\nNULL, NULL, hibmc_bo_ttm_destroy);\r\nif (ret) {\r\nhibmc_bo_unref(&hibmcbo);\r\nDRM_ERROR("failed to initialize ttm_bo: %d\n", ret);\r\nreturn ret;\r\n}\r\n*phibmcbo = hibmcbo;\r\nreturn 0;\r\n}\r\nint hibmc_bo_pin(struct hibmc_bo *bo, u32 pl_flag, u64 *gpu_addr)\r\n{\r\nint i, ret;\r\nif (bo->pin_count) {\r\nbo->pin_count++;\r\nif (gpu_addr)\r\n*gpu_addr = bo->bo.offset;\r\nreturn 0;\r\n}\r\nhibmc_ttm_placement(bo, pl_flag);\r\nfor (i = 0; i < bo->placement.num_placement; i++)\r\nbo->placements[i].flags |= TTM_PL_FLAG_NO_EVICT;\r\nret = ttm_bo_validate(&bo->bo, &bo->placement, false, false);\r\nif (ret)\r\nreturn ret;\r\nbo->pin_count = 1;\r\nif (gpu_addr)\r\n*gpu_addr = bo->bo.offset;\r\nreturn 0;\r\n}\r\nint hibmc_bo_unpin(struct hibmc_bo *bo)\r\n{\r\nint i, ret;\r\nif (!bo->pin_count) {\r\nDRM_ERROR("unpin bad %p\n", bo);\r\nreturn 0;\r\n}\r\nbo->pin_count--;\r\nif (bo->pin_count)\r\nreturn 0;\r\nfor (i = 0; i < bo->placement.num_placement ; i++)\r\nbo->placements[i].flags &= ~TTM_PL_FLAG_NO_EVICT;\r\nret = ttm_bo_validate(&bo->bo, &bo->placement, false, false);\r\nif (ret) {\r\nDRM_ERROR("validate failed for unpin: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint hibmc_mmap(struct file *filp, struct vm_area_struct *vma)\r\n{\r\nstruct drm_file *file_priv;\r\nstruct hibmc_drm_private *hibmc;\r\nif (unlikely(vma->vm_pgoff < DRM_FILE_PAGE_OFFSET))\r\nreturn -EINVAL;\r\nfile_priv = filp->private_data;\r\nhibmc = file_priv->minor->dev->dev_private;\r\nreturn ttm_bo_mmap(filp, vma, &hibmc->bdev);\r\n}\r\nint hibmc_gem_create(struct drm_device *dev, u32 size, bool iskernel,\r\nstruct drm_gem_object **obj)\r\n{\r\nstruct hibmc_bo *hibmcbo;\r\nint ret;\r\n*obj = NULL;\r\nsize = PAGE_ALIGN(size);\r\nif (size == 0) {\r\nDRM_ERROR("error: zero size\n");\r\nreturn -EINVAL;\r\n}\r\nret = hibmc_bo_create(dev, size, 0, 0, &hibmcbo);\r\nif (ret) {\r\nif (ret != -ERESTARTSYS)\r\nDRM_ERROR("failed to allocate GEM object: %d\n", ret);\r\nreturn ret;\r\n}\r\n*obj = &hibmcbo->gem;\r\nreturn 0;\r\n}\r\nint hibmc_dumb_create(struct drm_file *file, struct drm_device *dev,\r\nstruct drm_mode_create_dumb *args)\r\n{\r\nstruct drm_gem_object *gobj;\r\nu32 handle;\r\nint ret;\r\nargs->pitch = ALIGN(args->width * DIV_ROUND_UP(args->bpp, 8), 16);\r\nargs->size = args->pitch * args->height;\r\nret = hibmc_gem_create(dev, args->size, false,\r\n&gobj);\r\nif (ret) {\r\nDRM_ERROR("failed to create GEM object: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = drm_gem_handle_create(file, gobj, &handle);\r\ndrm_gem_object_unreference_unlocked(gobj);\r\nif (ret) {\r\nDRM_ERROR("failed to unreference GEM object: %d\n", ret);\r\nreturn ret;\r\n}\r\nargs->handle = handle;\r\nreturn 0;\r\n}\r\nvoid hibmc_gem_free_object(struct drm_gem_object *obj)\r\n{\r\nstruct hibmc_bo *hibmcbo = gem_to_hibmc_bo(obj);\r\nhibmc_bo_unref(&hibmcbo);\r\n}\r\nstatic u64 hibmc_bo_mmap_offset(struct hibmc_bo *bo)\r\n{\r\nreturn drm_vma_node_offset_addr(&bo->bo.vma_node);\r\n}\r\nint hibmc_dumb_mmap_offset(struct drm_file *file, struct drm_device *dev,\r\nu32 handle, u64 *offset)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct hibmc_bo *bo;\r\nobj = drm_gem_object_lookup(file, handle);\r\nif (!obj)\r\nreturn -ENOENT;\r\nbo = gem_to_hibmc_bo(obj);\r\n*offset = hibmc_bo_mmap_offset(bo);\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn 0;\r\n}\r\nstatic void hibmc_user_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct hibmc_framebuffer *hibmc_fb = to_hibmc_framebuffer(fb);\r\ndrm_gem_object_unreference_unlocked(hibmc_fb->obj);\r\ndrm_framebuffer_cleanup(fb);\r\nkfree(hibmc_fb);\r\n}\r\nstruct hibmc_framebuffer *\r\nhibmc_framebuffer_init(struct drm_device *dev,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd,\r\nstruct drm_gem_object *obj)\r\n{\r\nstruct hibmc_framebuffer *hibmc_fb;\r\nint ret;\r\nhibmc_fb = kzalloc(sizeof(*hibmc_fb), GFP_KERNEL);\r\nif (!hibmc_fb) {\r\nDRM_ERROR("failed to allocate hibmc_fb\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\ndrm_helper_mode_fill_fb_struct(dev, &hibmc_fb->fb, mode_cmd);\r\nhibmc_fb->obj = obj;\r\nret = drm_framebuffer_init(dev, &hibmc_fb->fb, &hibmc_fb_funcs);\r\nif (ret) {\r\nDRM_ERROR("drm_framebuffer_init failed: %d\n", ret);\r\nkfree(hibmc_fb);\r\nreturn ERR_PTR(ret);\r\n}\r\nreturn hibmc_fb;\r\n}\r\nstatic struct drm_framebuffer *\r\nhibmc_user_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *filp,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nstruct drm_gem_object *obj;\r\nstruct hibmc_framebuffer *hibmc_fb;\r\nDRM_DEBUG_DRIVER("%dx%d, format %c%c%c%c\n",\r\nmode_cmd->width, mode_cmd->height,\r\n(mode_cmd->pixel_format) & 0xff,\r\n(mode_cmd->pixel_format >> 8) & 0xff,\r\n(mode_cmd->pixel_format >> 16) & 0xff,\r\n(mode_cmd->pixel_format >> 24) & 0xff);\r\nobj = drm_gem_object_lookup(filp, mode_cmd->handles[0]);\r\nif (!obj)\r\nreturn ERR_PTR(-ENOENT);\r\nhibmc_fb = hibmc_framebuffer_init(dev, mode_cmd, obj);\r\nif (IS_ERR(hibmc_fb)) {\r\ndrm_gem_object_unreference_unlocked(obj);\r\nreturn ERR_PTR((long)hibmc_fb);\r\n}\r\nreturn &hibmc_fb->fb;\r\n}
