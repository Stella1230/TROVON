static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct sk_buff *skb = *pskb;\r\nstruct hsr_port *port;\r\nu16 protocol;\r\nif (!skb_mac_header_was_set(skb)) {\r\nWARN_ONCE(1, "%s: skb invalid", __func__);\r\nreturn RX_HANDLER_PASS;\r\n}\r\nrcu_read_lock();\r\nport = hsr_port_get_rcu(skb->dev);\r\nif (hsr_addr_is_self(port->hsr, eth_hdr(skb)->h_source)) {\r\nkfree_skb(skb);\r\ngoto finish_consume;\r\n}\r\nprotocol = eth_hdr(skb)->h_proto;\r\nif (protocol != htons(ETH_P_PRP) && protocol != htons(ETH_P_HSR))\r\ngoto finish_pass;\r\nskb_push(skb, ETH_HLEN);\r\nhsr_forward_skb(skb, port);\r\nfinish_consume:\r\nrcu_read_unlock();\r\nreturn RX_HANDLER_CONSUMED;\r\nfinish_pass:\r\nrcu_read_unlock();\r\nreturn RX_HANDLER_PASS;\r\n}\r\nbool hsr_port_exists(const struct net_device *dev)\r\n{\r\nreturn rcu_access_pointer(dev->rx_handler) == hsr_handle_frame;\r\n}\r\nstatic int hsr_check_dev_ok(struct net_device *dev)\r\n{\r\nif ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||\r\n(dev->addr_len != ETH_ALEN)) {\r\nnetdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");\r\nreturn -EINVAL;\r\n}\r\nif (is_hsr_master(dev)) {\r\nnetdev_info(dev, "Cannot create trees of HSR devices.\n");\r\nreturn -EINVAL;\r\n}\r\nif (hsr_port_exists(dev)) {\r\nnetdev_info(dev, "This device is already a HSR slave.\n");\r\nreturn -EINVAL;\r\n}\r\nif (is_vlan_dev(dev)) {\r\nnetdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");\r\nreturn -EINVAL;\r\n}\r\nif (dev->priv_flags & IFF_DONT_BRIDGE) {\r\nnetdev_info(dev, "This device does not support bridging.\n");\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)\r\n{\r\nint res;\r\ndev_hold(dev);\r\nres = dev_set_promiscuity(dev, 1);\r\nif (res)\r\ngoto fail_promiscuity;\r\nres = netdev_rx_handler_register(dev, hsr_handle_frame, port);\r\nif (res)\r\ngoto fail_rx_handler;\r\ndev_disable_lro(dev);\r\nreturn 0;\r\nfail_rx_handler:\r\ndev_set_promiscuity(dev, -1);\r\nfail_promiscuity:\r\ndev_put(dev);\r\nreturn res;\r\n}\r\nint hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,\r\nenum hsr_port_type type)\r\n{\r\nstruct hsr_port *port, *master;\r\nint res;\r\nif (type != HSR_PT_MASTER) {\r\nres = hsr_check_dev_ok(dev);\r\nif (res)\r\nreturn res;\r\n}\r\nport = hsr_port_get_hsr(hsr, type);\r\nif (port != NULL)\r\nreturn -EBUSY;\r\nport = kzalloc(sizeof(*port), GFP_KERNEL);\r\nif (port == NULL)\r\nreturn -ENOMEM;\r\nif (type != HSR_PT_MASTER) {\r\nres = hsr_portdev_setup(dev, port);\r\nif (res)\r\ngoto fail_dev_setup;\r\n}\r\nport->hsr = hsr;\r\nport->dev = dev;\r\nport->type = type;\r\nlist_add_tail_rcu(&port->port_list, &hsr->ports);\r\nsynchronize_rcu();\r\nmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\r\nnetdev_update_features(master->dev);\r\ndev_set_mtu(master->dev, hsr_get_max_mtu(hsr));\r\nreturn 0;\r\nfail_dev_setup:\r\nkfree(port);\r\nreturn res;\r\n}\r\nvoid hsr_del_port(struct hsr_port *port)\r\n{\r\nstruct hsr_priv *hsr;\r\nstruct hsr_port *master;\r\nhsr = port->hsr;\r\nmaster = hsr_port_get_hsr(hsr, HSR_PT_MASTER);\r\nlist_del_rcu(&port->port_list);\r\nif (port != master) {\r\nif (master != NULL) {\r\nnetdev_update_features(master->dev);\r\ndev_set_mtu(master->dev, hsr_get_max_mtu(hsr));\r\n}\r\nnetdev_rx_handler_unregister(port->dev);\r\ndev_set_promiscuity(port->dev, -1);\r\n}\r\nsynchronize_rcu();\r\nif (port != master)\r\ndev_put(port->dev);\r\n}
