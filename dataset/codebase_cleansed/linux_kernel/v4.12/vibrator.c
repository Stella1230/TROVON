static int turn_off(struct gb_vibrator_device *vib)\r\n{\r\nstruct gb_bundle *bundle = vib->connection->bundle;\r\nint ret;\r\nret = gb_operation_sync(vib->connection, GB_VIBRATOR_TYPE_OFF,\r\nNULL, 0, NULL, 0);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nstatic int turn_on(struct gb_vibrator_device *vib, u16 timeout_ms)\r\n{\r\nstruct gb_bundle *bundle = vib->connection->bundle;\r\nint ret;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\nreturn ret;\r\nif (cancel_delayed_work_sync(&vib->delayed_work))\r\nturn_off(vib);\r\nret = gb_operation_sync(vib->connection, GB_VIBRATOR_TYPE_ON,\r\nNULL, 0, NULL, 0);\r\nif (ret) {\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn ret;\r\n}\r\nschedule_delayed_work(&vib->delayed_work, msecs_to_jiffies(timeout_ms));\r\nreturn 0;\r\n}\r\nstatic void gb_vibrator_worker(struct work_struct *work)\r\n{\r\nstruct delayed_work *delayed_work = to_delayed_work(work);\r\nstruct gb_vibrator_device *vib =\r\ncontainer_of(delayed_work,\r\nstruct gb_vibrator_device,\r\ndelayed_work);\r\nturn_off(vib);\r\n}\r\nstatic ssize_t timeout_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct gb_vibrator_device *vib = dev_get_drvdata(dev);\r\nunsigned long val;\r\nint retval;\r\nretval = kstrtoul(buf, 10, &val);\r\nif (retval < 0) {\r\ndev_err(dev, "could not parse timeout value %d\n", retval);\r\nreturn retval;\r\n}\r\nif (val)\r\nretval = turn_on(vib, (u16)val);\r\nelse\r\nretval = turn_off(vib);\r\nif (retval)\r\nreturn retval;\r\nreturn count;\r\n}\r\nstatic int gb_vibrator_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_connection *connection;\r\nstruct gb_vibrator_device *vib;\r\nstruct device *dev;\r\nint retval;\r\nif (bundle->num_cports != 1)\r\nreturn -ENODEV;\r\ncport_desc = &bundle->cport_desc[0];\r\nif (cport_desc->protocol_id != GREYBUS_PROTOCOL_VIBRATOR)\r\nreturn -ENODEV;\r\nvib = kzalloc(sizeof(*vib), GFP_KERNEL);\r\nif (!vib)\r\nreturn -ENOMEM;\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\nNULL);\r\nif (IS_ERR(connection)) {\r\nretval = PTR_ERR(connection);\r\ngoto err_free_vib;\r\n}\r\ngb_connection_set_data(connection, vib);\r\nvib->connection = connection;\r\ngreybus_set_drvdata(bundle, vib);\r\nretval = gb_connection_enable(connection);\r\nif (retval)\r\ngoto err_connection_destroy;\r\nvib->minor = ida_simple_get(&minors, 0, 0, GFP_KERNEL);\r\nif (vib->minor < 0) {\r\nretval = vib->minor;\r\ngoto err_connection_disable;\r\n}\r\ndev = device_create(&vibrator_class, &bundle->dev,\r\nMKDEV(0, 0), vib, "vibrator%d", vib->minor);\r\nif (IS_ERR(dev)) {\r\nretval = -EINVAL;\r\ngoto err_ida_remove;\r\n}\r\nvib->dev = dev;\r\nINIT_DELAYED_WORK(&vib->delayed_work, gb_vibrator_worker);\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\nerr_ida_remove:\r\nida_simple_remove(&minors, vib->minor);\r\nerr_connection_disable:\r\ngb_connection_disable(connection);\r\nerr_connection_destroy:\r\ngb_connection_destroy(connection);\r\nerr_free_vib:\r\nkfree(vib);\r\nreturn retval;\r\n}\r\nstatic void gb_vibrator_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_vibrator_device *vib = greybus_get_drvdata(bundle);\r\nint ret;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\ngb_pm_runtime_get_noresume(bundle);\r\nif (cancel_delayed_work_sync(&vib->delayed_work))\r\nturn_off(vib);\r\ndevice_unregister(vib->dev);\r\nida_simple_remove(&minors, vib->minor);\r\ngb_connection_disable(vib->connection);\r\ngb_connection_destroy(vib->connection);\r\nkfree(vib);\r\n}\r\nstatic __init int gb_vibrator_init(void)\r\n{\r\nint retval;\r\nretval = class_register(&vibrator_class);\r\nif (retval)\r\nreturn retval;\r\nretval = greybus_register(&gb_vibrator_driver);\r\nif (retval)\r\ngoto err_class_unregister;\r\nreturn 0;\r\nerr_class_unregister:\r\nclass_unregister(&vibrator_class);\r\nreturn retval;\r\n}\r\nstatic __exit void gb_vibrator_exit(void)\r\n{\r\ngreybus_deregister(&gb_vibrator_driver);\r\nclass_unregister(&vibrator_class);\r\nida_destroy(&minors);\r\n}
