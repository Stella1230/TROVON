void ecm_init(struct s_smc *smc)\r\n{\r\nsmc->e.path_test = PT_PASSED ;\r\nsmc->e.trace_prop = 0 ;\r\nsmc->e.sb_flag = 0 ;\r\nsmc->mib.fddiSMTECMState = ACTIONS(EC0_OUT) ;\r\nsmc->e.ecm_line_state = FALSE ;\r\n}\r\nvoid ecm(struct s_smc *smc, int event)\r\n{\r\nint state ;\r\ndo {\r\nDB_ECM("ECM : state %s%s event %s",\r\nsmc->mib.fddiSMTECMState & AFLAG ? "ACTIONS " : "",\r\necm_states[smc->mib.fddiSMTECMState & ~AFLAG],\r\necm_events[event]);\r\nstate = smc->mib.fddiSMTECMState ;\r\necm_fsm(smc,event) ;\r\nevent = 0 ;\r\n} while (state != smc->mib.fddiSMTECMState) ;\r\necm_state_change(smc,(int)smc->mib.fddiSMTECMState) ;\r\n}\r\nstatic void ecm_fsm(struct s_smc *smc, int cmd)\r\n{\r\nint ls_a ;\r\nint ls_b ;\r\nint p ;\r\nsmc->mib.fddiSMTBypassPresent = sm_pm_bypass_present(smc) ;\r\nif (cmd == EC_CONNECT)\r\nsmc->mib.fddiSMTRemoteDisconnectFlag = FALSE ;\r\nif (cmd == EC_DISCONNECT &&\r\nsmc->mib.fddiSMTRemoteDisconnectFlag == TRUE)\r\nAIX_EVENT (smc, (u_long) CIO_HARD_FAIL, (u_long)\r\nFDDI_REMOTE_DISCONNECT, smt_get_event_word(smc),\r\nsmt_get_error_word(smc) );\r\nif (cmd == EC_CONNECT) {\r\nsmc->e.DisconnectFlag = FALSE ;\r\n}\r\nelse if (cmd == EC_DISCONNECT) {\r\nsmc->e.DisconnectFlag = TRUE ;\r\n}\r\nswitch(smc->mib.fddiSMTECMState) {\r\ncase ACTIONS(EC0_OUT) :\r\nsmc->e.path_test = PT_PASSED ;\r\nsmc->e.ecm_line_state = FALSE ;\r\nstop_ecm_timer(smc) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC0_OUT:\r\nif (cmd == EC_CONNECT && !smc->mib.fddiSMTBypassPresent\r\n&& smc->e.path_test==PT_PASSED) {\r\nGO_STATE(EC1_IN) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_CONNECT && (smc->e.path_test==PT_PASSED) &&\r\nsmc->mib.fddiSMTBypassPresent &&\r\n(smc->s.sas == SMT_DAS)) {\r\nGO_STATE(EC5_INSERT) ;\r\nbreak ;\r\n}\r\nbreak;\r\ncase ACTIONS(EC1_IN) :\r\nstop_ecm_timer(smc) ;\r\nsmc->e.trace_prop = 0 ;\r\nsm_ma_control(smc,MA_TREQ) ;\r\nfor (p = 0 ; p < NUMPHYS ; p++)\r\nif (smc->mib.p[p].fddiPORTHardwarePresent)\r\nqueue_event(smc,EVENT_PCMA+p,PC_START) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC1_IN:\r\nif (cmd == EC_TRACE_PROP) {\r\nprop_actions(smc) ;\r\nGO_STATE(EC2_TRACE) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_DISCONNECT) {\r\nGO_STATE(EC3_LEAVE) ;\r\nbreak ;\r\n}\r\nbreak;\r\ncase ACTIONS(EC2_TRACE) :\r\nstart_ecm_timer(smc,MIB2US(smc->mib.fddiSMTTrace_MaxExpiration),\r\nEC_TIMEOUT_TMAX) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC2_TRACE :\r\nif (cmd == EC_TRACE_PROP) {\r\nprop_actions(smc) ;\r\nGO_STATE(EC2_TRACE) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_DISCONNECT) {\r\nsmc->e.path_test = PT_EXITING ;\r\nGO_STATE(EC3_LEAVE) ;\r\nbreak ;\r\n}\r\nelse if (smc->e.path_test == PT_PENDING) {\r\nGO_STATE(EC3_LEAVE) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_TIMEOUT_TMAX) {\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS,\r\n(u_long) FDDI_SMT_ERROR, (u_long)\r\nFDDI_TRACE_MAX, smt_get_error_word(smc));\r\nsmc->e.path_test = PT_PENDING ;\r\nGO_STATE(EC3_LEAVE) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(EC3_LEAVE) :\r\nstart_ecm_timer(smc,smc->s.ecm_td_min,EC_TIMEOUT_TD) ;\r\nfor (p = 0 ; p < NUMPHYS ; p++)\r\nqueue_event(smc,EVENT_PCMA+p,PC_STOP) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC3_LEAVE:\r\nif (cmd == EC_TIMEOUT_TD && !smc->mib.fddiSMTBypassPresent &&\r\n(smc->e.path_test != PT_PENDING)) {\r\nGO_STATE(EC0_OUT) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_TIMEOUT_TD &&\r\n(smc->e.path_test == PT_PENDING)) {\r\nGO_STATE(EC4_PATH_TEST) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_CONNECT && smc->e.path_test == PT_PASSED) {\r\nGO_STATE(EC1_IN) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_DISCONNECT &&\r\nsmc->e.path_test == PT_PENDING) {\r\nsmc->e.path_test = PT_EXITING ;\r\n}\r\nelse if (cmd == EC_TIMEOUT_TD &&\r\nsmc->mib.fddiSMTBypassPresent &&\r\nsmc->e.path_test != PT_PENDING) {\r\nGO_STATE(EC7_DEINSERT) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(EC4_PATH_TEST) :\r\nstop_ecm_timer(smc) ;\r\nsmc->e.path_test = PT_TESTING ;\r\nstart_ecm_timer(smc,smc->s.ecm_test_done,EC_TEST_DONE) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC4_PATH_TEST :\r\nif (cmd == EC_TEST_DONE)\r\nsmc->e.path_test = PT_PASSED ;\r\nif (smc->e.path_test == PT_FAILED)\r\nRS_SET(smc,RS_PATHTEST) ;\r\nif (smc->e.path_test == PT_FAILED &&\r\n!smc->mib.fddiSMTBypassPresent) {\r\nGO_STATE(EC0_OUT) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_DISCONNECT &&\r\n!smc->mib.fddiSMTBypassPresent) {\r\nGO_STATE(EC0_OUT) ;\r\nbreak ;\r\n}\r\nelse if (smc->e.path_test == PT_PASSED) {\r\nGO_STATE(EC1_IN) ;\r\nbreak ;\r\n}\r\nelse if (smc->e.path_test == PT_FAILED &&\r\nsmc->mib.fddiSMTBypassPresent) {\r\nGO_STATE(EC7_DEINSERT) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_DISCONNECT &&\r\nsmc->mib.fddiSMTBypassPresent) {\r\nGO_STATE(EC7_DEINSERT) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(EC5_INSERT) :\r\nsm_pm_bypass_req(smc,BP_INSERT);\r\nstart_ecm_timer(smc,smc->s.ecm_in_max,EC_TIMEOUT_INMAX) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC5_INSERT :\r\nif (cmd == EC_TIMEOUT_INMAX) {\r\nGO_STATE(EC6_CHECK) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_DISCONNECT) {\r\nGO_STATE(EC7_DEINSERT) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(EC6_CHECK) :\r\nstart_ecm_timer(smc,smc->s.ecm_check_poll,0) ;\r\nsmc->e.ecm_line_state = TRUE ;\r\n(void) sm_pm_ls_latch(smc,PA,1) ;\r\n(void) sm_pm_ls_latch(smc,PB,1) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC6_CHECK :\r\nls_a = sm_pm_get_ls(smc,PA) ;\r\nls_b = sm_pm_get_ls(smc,PB) ;\r\nif (((ls_a == PC_QLS) || (ls_a == PC_HLS)) &&\r\n((ls_b == PC_QLS) || (ls_b == PC_HLS)) ) {\r\nsmc->e.sb_flag = FALSE ;\r\nsmc->e.ecm_line_state = FALSE ;\r\nGO_STATE(EC1_IN) ;\r\nbreak ;\r\n}\r\nelse if (!smc->e.sb_flag &&\r\n(((ls_a == PC_ILS) && (ls_b == PC_QLS)) ||\r\n((ls_a == PC_QLS) && (ls_b == PC_ILS)))){\r\nsmc->e.sb_flag = TRUE ;\r\nDB_ECMN(1, "ECM : EC6_CHECK - stuck bypass");\r\nAIX_EVENT(smc, (u_long) FDDI_RING_STATUS, (u_long)\r\nFDDI_SMT_ERROR, (u_long) FDDI_BYPASS_STUCK,\r\nsmt_get_error_word(smc));\r\n}\r\nelse if (cmd == EC_DISCONNECT) {\r\nsmc->e.ecm_line_state = FALSE ;\r\nGO_STATE(EC7_DEINSERT) ;\r\nbreak ;\r\n}\r\nelse {\r\nstart_ecm_timer(smc,smc->s.ecm_check_poll,0) ;\r\n}\r\nbreak ;\r\ncase ACTIONS(EC7_DEINSERT) :\r\nsm_pm_bypass_req(smc,BP_DEINSERT);\r\nstart_ecm_timer(smc,smc->s.ecm_i_max,EC_TIMEOUT_IMAX) ;\r\nACTIONS_DONE() ;\r\nbreak ;\r\ncase EC7_DEINSERT:\r\nif (cmd == EC_TIMEOUT_IMAX) {\r\nGO_STATE(EC0_OUT) ;\r\nbreak ;\r\n}\r\nelse if (cmd == EC_CONNECT && smc->e.path_test == PT_PASSED) {\r\nGO_STATE(EC5_INSERT) ;\r\nbreak ;\r\n}\r\nbreak;\r\ndefault:\r\nSMT_PANIC(smc,SMT_E0107, SMT_E0107_MSG) ;\r\nbreak;\r\n}\r\n}\r\nstatic void prop_actions(struct s_smc *smc)\r\n{\r\nint port_in = 0 ;\r\nint port_out = 0 ;\r\nRS_SET(smc,RS_EVENT) ;\r\nswitch (smc->s.sas) {\r\ncase SMT_SAS :\r\nport_in = port_out = pcm_get_s_port(smc) ;\r\nbreak ;\r\ncase SMT_DAS :\r\nport_in = cfm_get_mac_input(smc) ;\r\nport_out = cfm_get_mac_output(smc) ;\r\nbreak ;\r\ncase SMT_NAC :\r\nSMT_PANIC(smc,SMT_E0108, SMT_E0108_MSG) ;\r\nreturn ;\r\n}\r\nDB_ECM("ECM : prop_actions - trace_prop %lu", smc->e.trace_prop);\r\nDB_ECM("ECM : prop_actions - in %d out %d", port_in, port_out);\r\nif (smc->e.trace_prop & ENTITY_BIT(ENTITY_MAC)) {\r\nDB_ECM("ECM : initiate TRACE on PHY %c", 'A' + port_in - PA);\r\nqueue_event(smc,EVENT_PCM+port_in,PC_TRACE) ;\r\n}\r\nelse if ((smc->e.trace_prop & ENTITY_BIT(ENTITY_PHY(PA))) &&\r\nport_out != PA) {\r\nDB_ECM("ECM : propagate TRACE on PHY B");\r\nqueue_event(smc,EVENT_PCMB,PC_TRACE) ;\r\n}\r\nelse if ((smc->e.trace_prop & ENTITY_BIT(ENTITY_PHY(PB))) &&\r\nport_out != PB) {\r\nDB_ECM("ECM : propagate TRACE on PHY A");\r\nqueue_event(smc,EVENT_PCMA,PC_TRACE) ;\r\n}\r\nelse {\r\nDB_ECM("ECM : TRACE terminated");\r\nsmc->e.path_test = PT_PENDING ;\r\n}\r\nsmc->e.trace_prop = 0 ;\r\n}\r\nstatic void prop_actions(struct s_smc *smc)\r\n{\r\nint initiator ;\r\nint upstream ;\r\nint p ;\r\nRS_SET(smc,RS_EVENT) ;\r\nwhile (smc->e.trace_prop) {\r\nDB_ECM("ECM : prop_actions - trace_prop %d",\r\nsmc->e.trace_prop);\r\nif (smc->e.trace_prop & ENTITY_BIT(ENTITY_MAC)) {\r\ninitiator = ENTITY_MAC ;\r\nsmc->e.trace_prop &= ~ENTITY_BIT(ENTITY_MAC) ;\r\nDB_ECM("ECM: MAC initiates trace");\r\n}\r\nelse {\r\nfor (p = NUMPHYS-1 ; p >= 0 ; p--) {\r\nif (smc->e.trace_prop &\r\nENTITY_BIT(ENTITY_PHY(p)))\r\nbreak ;\r\n}\r\ninitiator = ENTITY_PHY(p) ;\r\nsmc->e.trace_prop &= ~ENTITY_BIT(ENTITY_PHY(p)) ;\r\n}\r\nupstream = cem_get_upstream(smc,initiator) ;\r\nif (upstream == ENTITY_MAC) {\r\nDB_ECM("ECM : TRACE terminated");\r\nsmc->e.path_test = PT_PENDING ;\r\n}\r\nelse {\r\nDB_ECM("ECM : propagate TRACE on PHY %d", upstream);\r\nqueue_event(smc,EVENT_PCM+upstream,PC_TRACE) ;\r\n}\r\n}\r\n}\r\nstatic void start_ecm_timer(struct s_smc *smc, u_long value, int event)\r\n{\r\nsmt_timer_start(smc,&smc->e.ecm_timer,value,EV_TOKEN(EVENT_ECM,event));\r\n}\r\nstatic void stop_ecm_timer(struct s_smc *smc)\r\n{\r\nif (smc->e.ecm_timer.tm_active)\r\nsmt_timer_stop(smc,&smc->e.ecm_timer) ;\r\n}
