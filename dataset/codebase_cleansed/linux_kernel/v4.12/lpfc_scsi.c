static struct lpfc_rport_data *\r\nlpfc_rport_data_from_scsi_device(struct scsi_device *sdev)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *)sdev->host->hostdata;\r\nif (vport->phba->cfg_fof)\r\nreturn ((struct lpfc_device_data *)sdev->hostdata)->rport_data;\r\nelse\r\nreturn (struct lpfc_rport_data *)sdev->hostdata;\r\n}\r\nstatic void\r\nlpfc_debug_save_data(struct lpfc_hba *phba, struct scsi_cmnd *cmnd)\r\n{\r\nvoid *src, *dst;\r\nstruct scatterlist *sgde = scsi_sglist(cmnd);\r\nif (!_dump_buf_data) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9050 BLKGRD: ERROR %s _dump_buf_data is NULL\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (!sgde) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9051 BLKGRD: ERROR: data scatterlist is null\n");\r\nreturn;\r\n}\r\ndst = (void *) _dump_buf_data;\r\nwhile (sgde) {\r\nsrc = sg_virt(sgde);\r\nmemcpy(dst, src, sgde->length);\r\ndst += sgde->length;\r\nsgde = sg_next(sgde);\r\n}\r\n}\r\nstatic void\r\nlpfc_debug_save_dif(struct lpfc_hba *phba, struct scsi_cmnd *cmnd)\r\n{\r\nvoid *src, *dst;\r\nstruct scatterlist *sgde = scsi_prot_sglist(cmnd);\r\nif (!_dump_buf_dif) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9052 BLKGRD: ERROR %s _dump_buf_data is NULL\n",\r\n__func__);\r\nreturn;\r\n}\r\nif (!sgde) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9053 BLKGRD: ERROR: prot scatterlist is null\n");\r\nreturn;\r\n}\r\ndst = _dump_buf_dif;\r\nwhile (sgde) {\r\nsrc = sg_virt(sgde);\r\nmemcpy(dst, src, sgde->length);\r\ndst += sgde->length;\r\nsgde = sg_next(sgde);\r\n}\r\n}\r\nstatic inline unsigned\r\nlpfc_cmd_blksize(struct scsi_cmnd *sc)\r\n{\r\nreturn sc->device->sector_size;\r\n}\r\nstatic inline unsigned\r\nlpfc_cmd_protect(struct scsi_cmnd *sc, int flag)\r\n{\r\nreturn 1;\r\n}\r\nstatic inline unsigned\r\nlpfc_cmd_guard_csum(struct scsi_cmnd *sc)\r\n{\r\nif (lpfc_prot_group_type(NULL, sc) == LPFC_PG_TYPE_NO_DIF)\r\nreturn 0;\r\nif (scsi_host_get_guard(sc->device->host) == SHOST_DIX_GUARD_IP)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_sli4_set_rsp_sgl_last(struct lpfc_hba *phba,\r\nstruct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct sli4_sge *sgl = (struct sli4_sge *)lpfc_cmd->fcp_bpl;\r\nif (sgl) {\r\nsgl += 1;\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nbf_set(lpfc_sli4_sge_last, sgl, 1);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\n}\r\n}\r\nstatic void\r\nlpfc_update_stats(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\r\nstruct lpfc_nodelist *pnode = rdata->pnode;\r\nstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\r\nunsigned long flags;\r\nstruct Scsi_Host *shost = cmd->device->host;\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nunsigned long latency;\r\nint i;\r\nif (cmd->result)\r\nreturn;\r\nlatency = jiffies_to_msecs((long)jiffies - (long)lpfc_cmd->start_time);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (!vport->stat_data_enabled ||\r\nvport->stat_data_blocked ||\r\n!pnode ||\r\n!pnode->lat_data ||\r\n(phba->bucket_type == LPFC_NO_BUCKET)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nreturn;\r\n}\r\nif (phba->bucket_type == LPFC_LINEAR_BUCKET) {\r\ni = (latency + phba->bucket_step - 1 - phba->bucket_base)/\r\nphba->bucket_step;\r\nif (i < 0)\r\ni = 0;\r\nelse if (i >= LPFC_MAX_BUCKET_COUNT)\r\ni = LPFC_MAX_BUCKET_COUNT - 1;\r\n} else {\r\nfor (i = 0; i < LPFC_MAX_BUCKET_COUNT-1; i++)\r\nif (latency <= (phba->bucket_base +\r\n((1<<i)*phba->bucket_step)))\r\nbreak;\r\n}\r\npnode->lat_data[i].cmd_count++;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\nvoid\r\nlpfc_rampdown_queue_depth(struct lpfc_hba *phba)\r\n{\r\nunsigned long flags;\r\nuint32_t evt_posted;\r\nunsigned long expires;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\natomic_inc(&phba->num_rsrc_err);\r\nphba->last_rsrc_error_time = jiffies;\r\nexpires = phba->last_ramp_down_time + QUEUE_RAMP_DOWN_INTERVAL;\r\nif (time_after(expires, jiffies)) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nreturn;\r\n}\r\nphba->last_ramp_down_time = jiffies;\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nspin_lock_irqsave(&phba->pport->work_port_lock, flags);\r\nevt_posted = phba->pport->work_port_events & WORKER_RAMP_DOWN_QUEUE;\r\nif (!evt_posted)\r\nphba->pport->work_port_events |= WORKER_RAMP_DOWN_QUEUE;\r\nspin_unlock_irqrestore(&phba->pport->work_port_lock, flags);\r\nif (!evt_posted)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nvoid\r\nlpfc_ramp_down_queue_handler(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nstruct Scsi_Host *shost;\r\nstruct scsi_device *sdev;\r\nunsigned long new_queue_depth;\r\nunsigned long num_rsrc_err, num_cmd_success;\r\nint i;\r\nnum_rsrc_err = atomic_read(&phba->num_rsrc_err);\r\nnum_cmd_success = atomic_read(&phba->num_cmd_success);\r\nif (num_rsrc_err == 0)\r\nreturn;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nshost_for_each_device(sdev, shost) {\r\nnew_queue_depth =\r\nsdev->queue_depth * num_rsrc_err /\r\n(num_rsrc_err + num_cmd_success);\r\nif (!new_queue_depth)\r\nnew_queue_depth = sdev->queue_depth - 1;\r\nelse\r\nnew_queue_depth = sdev->queue_depth -\r\nnew_queue_depth;\r\nscsi_change_queue_depth(sdev, new_queue_depth);\r\n}\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\natomic_set(&phba->num_rsrc_err, 0);\r\natomic_set(&phba->num_cmd_success, 0);\r\n}\r\nvoid\r\nlpfc_scsi_dev_block(struct lpfc_hba *phba)\r\n{\r\nstruct lpfc_vport **vports;\r\nstruct Scsi_Host *shost;\r\nstruct scsi_device *sdev;\r\nstruct fc_rport *rport;\r\nint i;\r\nvports = lpfc_create_vport_work_array(phba);\r\nif (vports != NULL)\r\nfor (i = 0; i <= phba->max_vports && vports[i] != NULL; i++) {\r\nshost = lpfc_shost_from_vport(vports[i]);\r\nshost_for_each_device(sdev, shost) {\r\nrport = starget_to_rport(scsi_target(sdev));\r\nfc_remote_port_delete(rport);\r\n}\r\n}\r\nlpfc_destroy_vport_work_array(phba, vports);\r\n}\r\nstatic int\r\nlpfc_new_scsi_buf_s3(struct lpfc_vport *vport, int num_to_alloc)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_scsi_buf *psb;\r\nstruct ulp_bde64 *bpl;\r\nIOCB_t *iocb;\r\ndma_addr_t pdma_phys_fcp_cmd;\r\ndma_addr_t pdma_phys_fcp_rsp;\r\ndma_addr_t pdma_phys_bpl;\r\nuint16_t iotag;\r\nint bcnt, bpl_size;\r\nbpl_size = phba->cfg_sg_dma_buf_size -\r\n(sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"9067 ALLOC %d scsi_bufs: %d (%d + %d + %d)\n",\r\nnum_to_alloc, phba->cfg_sg_dma_buf_size,\r\n(int)sizeof(struct fcp_cmnd),\r\n(int)sizeof(struct fcp_rsp), bpl_size);\r\nfor (bcnt = 0; bcnt < num_to_alloc; bcnt++) {\r\npsb = kzalloc(sizeof(struct lpfc_scsi_buf), GFP_KERNEL);\r\nif (!psb)\r\nbreak;\r\npsb->data = pci_pool_zalloc(phba->lpfc_sg_dma_buf_pool,\r\nGFP_KERNEL, &psb->dma_handle);\r\nif (!psb->data) {\r\nkfree(psb);\r\nbreak;\r\n}\r\niotag = lpfc_sli_next_iotag(phba, &psb->cur_iocbq);\r\nif (iotag == 0) {\r\npci_pool_free(phba->lpfc_sg_dma_buf_pool,\r\npsb->data, psb->dma_handle);\r\nkfree(psb);\r\nbreak;\r\n}\r\npsb->cur_iocbq.iocb_flag |= LPFC_IO_FCP;\r\npsb->fcp_cmnd = psb->data;\r\npsb->fcp_rsp = psb->data + sizeof(struct fcp_cmnd);\r\npsb->fcp_bpl = psb->data + sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp);\r\nbpl = psb->fcp_bpl;\r\npdma_phys_fcp_cmd = psb->dma_handle;\r\npdma_phys_fcp_rsp = psb->dma_handle + sizeof(struct fcp_cmnd);\r\npdma_phys_bpl = psb->dma_handle + sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp);\r\nbpl[0].addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys_fcp_cmd));\r\nbpl[0].addrLow = le32_to_cpu(putPaddrLow(pdma_phys_fcp_cmd));\r\nbpl[0].tus.f.bdeSize = sizeof(struct fcp_cmnd);\r\nbpl[0].tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nbpl[0].tus.w = le32_to_cpu(bpl[0].tus.w);\r\nbpl[1].addrHigh = le32_to_cpu(putPaddrHigh(pdma_phys_fcp_rsp));\r\nbpl[1].addrLow = le32_to_cpu(putPaddrLow(pdma_phys_fcp_rsp));\r\nbpl[1].tus.f.bdeSize = sizeof(struct fcp_rsp);\r\nbpl[1].tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nbpl[1].tus.w = le32_to_cpu(bpl[1].tus.w);\r\niocb = &psb->cur_iocbq.iocb;\r\niocb->un.fcpi64.bdl.ulpIoTag32 = 0;\r\nif ((phba->sli_rev == 3) &&\r\n!(phba->sli3_options & LPFC_SLI3_BG_ENABLED)) {\r\niocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BDE_IMMED;\r\niocb->un.fcpi64.bdl.bdeSize = sizeof(struct fcp_cmnd);\r\niocb->un.fcpi64.bdl.addrLow = offsetof(IOCB_t,\r\nunsli3.fcp_ext.icd);\r\niocb->un.fcpi64.bdl.addrHigh = 0;\r\niocb->ulpBdeCount = 0;\r\niocb->ulpLe = 0;\r\niocb->unsli3.fcp_ext.rbde.tus.f.bdeFlags =\r\nBUFF_TYPE_BDE_64;\r\niocb->unsli3.fcp_ext.rbde.tus.f.bdeSize =\r\nsizeof(struct fcp_rsp);\r\niocb->unsli3.fcp_ext.rbde.addrLow =\r\nputPaddrLow(pdma_phys_fcp_rsp);\r\niocb->unsli3.fcp_ext.rbde.addrHigh =\r\nputPaddrHigh(pdma_phys_fcp_rsp);\r\n} else {\r\niocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BLP_64;\r\niocb->un.fcpi64.bdl.bdeSize =\r\n(2 * sizeof(struct ulp_bde64));\r\niocb->un.fcpi64.bdl.addrLow =\r\nputPaddrLow(pdma_phys_bpl);\r\niocb->un.fcpi64.bdl.addrHigh =\r\nputPaddrHigh(pdma_phys_bpl);\r\niocb->ulpBdeCount = 1;\r\niocb->ulpLe = 1;\r\n}\r\niocb->ulpClass = CLASS3;\r\npsb->status = IOSTAT_SUCCESS;\r\npsb->cur_iocbq.context1 = psb;\r\nlpfc_release_scsi_buf_s3(phba, psb);\r\n}\r\nreturn bcnt;\r\n}\r\nvoid\r\nlpfc_sli4_vport_delete_fcp_xri_aborted(struct lpfc_vport *vport)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_scsi_buf *psb, *next_psb;\r\nunsigned long iflag = 0;\r\nif (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\r\nreturn;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nspin_lock(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nlist_for_each_entry_safe(psb, next_psb,\r\n&phba->sli4_hba.lpfc_abts_scsi_buf_list, list) {\r\nif (psb->rdata && psb->rdata->pnode\r\n&& psb->rdata->pnode->vport == vport)\r\npsb->rdata = NULL;\r\n}\r\nspin_unlock(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\n}\r\nvoid\r\nlpfc_sli4_fcp_xri_aborted(struct lpfc_hba *phba,\r\nstruct sli4_wcqe_xri_aborted *axri)\r\n{\r\nuint16_t xri = bf_get(lpfc_wcqe_xa_xri, axri);\r\nuint16_t rxid = bf_get(lpfc_wcqe_xa_remote_xid, axri);\r\nstruct lpfc_scsi_buf *psb, *next_psb;\r\nunsigned long iflag = 0;\r\nstruct lpfc_iocbq *iocbq;\r\nint i;\r\nstruct lpfc_nodelist *ndlp;\r\nint rrq_empty = 0;\r\nstruct lpfc_sli_ring *pring = phba->sli4_hba.els_wq->pring;\r\nif (!(phba->cfg_enable_fc4_type & LPFC_ENABLE_FCP))\r\nreturn;\r\nspin_lock_irqsave(&phba->hbalock, iflag);\r\nspin_lock(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nlist_for_each_entry_safe(psb, next_psb,\r\n&phba->sli4_hba.lpfc_abts_scsi_buf_list, list) {\r\nif (psb->cur_iocbq.sli4_xritag == xri) {\r\nlist_del(&psb->list);\r\npsb->exch_busy = 0;\r\npsb->status = IOSTAT_SUCCESS;\r\nspin_unlock(\r\n&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nif (psb->rdata && psb->rdata->pnode)\r\nndlp = psb->rdata->pnode;\r\nelse\r\nndlp = NULL;\r\nrrq_empty = list_empty(&phba->active_rrq_list);\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nif (ndlp) {\r\nlpfc_set_rrq_active(phba, ndlp,\r\npsb->cur_iocbq.sli4_lxritag, rxid, 1);\r\nlpfc_sli4_abts_err_handler(phba, ndlp, axri);\r\n}\r\nlpfc_release_scsi_buf_s4(phba, psb);\r\nif (rrq_empty)\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\n}\r\nspin_unlock(&phba->sli4_hba.abts_scsi_buf_list_lock);\r\nfor (i = 1; i <= phba->sli.last_iotag; i++) {\r\niocbq = phba->sli.iocbq_lookup[i];\r\nif (!(iocbq->iocb_flag & LPFC_IO_FCP) ||\r\n(iocbq->iocb_flag & LPFC_IO_LIBDFC))\r\ncontinue;\r\nif (iocbq->sli4_xritag != xri)\r\ncontinue;\r\npsb = container_of(iocbq, struct lpfc_scsi_buf, cur_iocbq);\r\npsb->exch_busy = 0;\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\nif (!list_empty(&pring->txq))\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, iflag);\r\n}\r\nstatic int\r\nlpfc_sli4_post_scsi_sgl_list(struct lpfc_hba *phba,\r\nstruct list_head *post_sblist, int sb_count)\r\n{\r\nstruct lpfc_scsi_buf *psb, *psb_next;\r\nint status, sgl_size;\r\nint post_cnt = 0, block_cnt = 0, num_posting = 0, num_posted = 0;\r\ndma_addr_t pdma_phys_bpl1;\r\nint last_xritag = NO_XRI;\r\nLIST_HEAD(prep_sblist);\r\nLIST_HEAD(blck_sblist);\r\nLIST_HEAD(scsi_sblist);\r\nif (sb_count <= 0)\r\nreturn -EINVAL;\r\nsgl_size = phba->cfg_sg_dma_buf_size -\r\n(sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\r\nlist_for_each_entry_safe(psb, psb_next, post_sblist, list) {\r\nlist_del_init(&psb->list);\r\nblock_cnt++;\r\nif ((last_xritag != NO_XRI) &&\r\n(psb->cur_iocbq.sli4_xritag != last_xritag + 1)) {\r\nlist_splice_init(&prep_sblist, &blck_sblist);\r\npost_cnt = block_cnt - 1;\r\nlist_add_tail(&psb->list, &prep_sblist);\r\nblock_cnt = 1;\r\n} else {\r\nlist_add_tail(&psb->list, &prep_sblist);\r\nif (block_cnt == LPFC_NEMBED_MBOX_SGL_CNT) {\r\nlist_splice_init(&prep_sblist, &blck_sblist);\r\npost_cnt = block_cnt;\r\nblock_cnt = 0;\r\n}\r\n}\r\nnum_posting++;\r\nlast_xritag = psb->cur_iocbq.sli4_xritag;\r\nif (num_posting == sb_count) {\r\nif (post_cnt == 0) {\r\nlist_splice_init(&prep_sblist, &blck_sblist);\r\npost_cnt = block_cnt;\r\n} else if (block_cnt == 1) {\r\nif (sgl_size > SGL_PAGE_SIZE)\r\npdma_phys_bpl1 = psb->dma_phys_bpl +\r\nSGL_PAGE_SIZE;\r\nelse\r\npdma_phys_bpl1 = 0;\r\nstatus = lpfc_sli4_post_sgl(phba,\r\npsb->dma_phys_bpl,\r\npdma_phys_bpl1,\r\npsb->cur_iocbq.sli4_xritag);\r\nif (status) {\r\npsb->exch_busy = 1;\r\n} else {\r\npsb->exch_busy = 0;\r\npsb->status = IOSTAT_SUCCESS;\r\nnum_posted++;\r\n}\r\nlist_add_tail(&psb->list, &scsi_sblist);\r\n}\r\n}\r\nif (post_cnt == 0)\r\ncontinue;\r\nstatus = lpfc_sli4_post_scsi_sgl_block(phba, &blck_sblist,\r\npost_cnt);\r\nif (block_cnt == 0)\r\nlast_xritag = NO_XRI;\r\npost_cnt = 0;\r\nwhile (!list_empty(&blck_sblist)) {\r\nlist_remove_head(&blck_sblist, psb,\r\nstruct lpfc_scsi_buf, list);\r\nif (status) {\r\npsb->exch_busy = 1;\r\n} else {\r\npsb->exch_busy = 0;\r\npsb->status = IOSTAT_SUCCESS;\r\nnum_posted++;\r\n}\r\nlist_add_tail(&psb->list, &scsi_sblist);\r\n}\r\n}\r\nwhile (!list_empty(&scsi_sblist)) {\r\nlist_remove_head(&scsi_sblist, psb,\r\nstruct lpfc_scsi_buf, list);\r\nlpfc_release_scsi_buf_s4(phba, psb);\r\n}\r\nreturn num_posted;\r\n}\r\nint\r\nlpfc_sli4_repost_scsi_sgl_list(struct lpfc_hba *phba)\r\n{\r\nLIST_HEAD(post_sblist);\r\nint num_posted, rc = 0;\r\nspin_lock_irq(&phba->scsi_buf_list_get_lock);\r\nspin_lock(&phba->scsi_buf_list_put_lock);\r\nlist_splice_init(&phba->lpfc_scsi_buf_list_get, &post_sblist);\r\nlist_splice(&phba->lpfc_scsi_buf_list_put, &post_sblist);\r\nspin_unlock(&phba->scsi_buf_list_put_lock);\r\nspin_unlock_irq(&phba->scsi_buf_list_get_lock);\r\nif (!list_empty(&post_sblist)) {\r\nnum_posted = lpfc_sli4_post_scsi_sgl_list(phba, &post_sblist,\r\nphba->sli4_hba.scsi_xri_cnt);\r\nif (num_posted == 0)\r\nrc = -EIO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_new_scsi_buf_s4(struct lpfc_vport *vport, int num_to_alloc)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_scsi_buf *psb;\r\nstruct sli4_sge *sgl;\r\nIOCB_t *iocb;\r\ndma_addr_t pdma_phys_fcp_cmd;\r\ndma_addr_t pdma_phys_fcp_rsp;\r\ndma_addr_t pdma_phys_bpl;\r\nuint16_t iotag, lxri = 0;\r\nint bcnt, num_posted, sgl_size;\r\nLIST_HEAD(prep_sblist);\r\nLIST_HEAD(post_sblist);\r\nLIST_HEAD(scsi_sblist);\r\nsgl_size = phba->cfg_sg_dma_buf_size -\r\n(sizeof(struct fcp_cmnd) + sizeof(struct fcp_rsp));\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"9068 ALLOC %d scsi_bufs: %d (%d + %d + %d)\n",\r\nnum_to_alloc, phba->cfg_sg_dma_buf_size, sgl_size,\r\n(int)sizeof(struct fcp_cmnd),\r\n(int)sizeof(struct fcp_rsp));\r\nfor (bcnt = 0; bcnt < num_to_alloc; bcnt++) {\r\npsb = kzalloc(sizeof(struct lpfc_scsi_buf), GFP_KERNEL);\r\nif (!psb)\r\nbreak;\r\npsb->data = pci_pool_zalloc(phba->lpfc_sg_dma_buf_pool,\r\nGFP_KERNEL, &psb->dma_handle);\r\nif (!psb->data) {\r\nkfree(psb);\r\nbreak;\r\n}\r\nif (phba->cfg_enable_bg && (((unsigned long)(psb->data) &\r\n(unsigned long)(SLI4_PAGE_SIZE - 1)) != 0)) {\r\npci_pool_free(phba->lpfc_sg_dma_buf_pool,\r\npsb->data, psb->dma_handle);\r\nkfree(psb);\r\nbreak;\r\n}\r\nlxri = lpfc_sli4_next_xritag(phba);\r\nif (lxri == NO_XRI) {\r\npci_pool_free(phba->lpfc_sg_dma_buf_pool,\r\npsb->data, psb->dma_handle);\r\nkfree(psb);\r\nbreak;\r\n}\r\niotag = lpfc_sli_next_iotag(phba, &psb->cur_iocbq);\r\nif (iotag == 0) {\r\npci_pool_free(phba->lpfc_sg_dma_buf_pool,\r\npsb->data, psb->dma_handle);\r\nkfree(psb);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"3368 Failed to allocate IOTAG for"\r\n" XRI:0x%x\n", lxri);\r\nlpfc_sli4_free_xri(phba, lxri);\r\nbreak;\r\n}\r\npsb->cur_iocbq.sli4_lxritag = lxri;\r\npsb->cur_iocbq.sli4_xritag = phba->sli4_hba.xri_ids[lxri];\r\npsb->cur_iocbq.iocb_flag |= LPFC_IO_FCP;\r\npsb->fcp_bpl = psb->data;\r\npsb->fcp_cmnd = (psb->data + sgl_size);\r\npsb->fcp_rsp = (struct fcp_rsp *)((uint8_t *)psb->fcp_cmnd +\r\nsizeof(struct fcp_cmnd));\r\nsgl = (struct sli4_sge *)psb->fcp_bpl;\r\npdma_phys_bpl = psb->dma_handle;\r\npdma_phys_fcp_cmd = (psb->dma_handle + sgl_size);\r\npdma_phys_fcp_rsp = pdma_phys_fcp_cmd + sizeof(struct fcp_cmnd);\r\nsgl->addr_hi = cpu_to_le32(putPaddrHigh(pdma_phys_fcp_cmd));\r\nsgl->addr_lo = cpu_to_le32(putPaddrLow(pdma_phys_fcp_cmd));\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nbf_set(lpfc_sli4_sge_last, sgl, 0);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\nsgl->sge_len = cpu_to_le32(sizeof(struct fcp_cmnd));\r\nsgl++;\r\nsgl->addr_hi = cpu_to_le32(putPaddrHigh(pdma_phys_fcp_rsp));\r\nsgl->addr_lo = cpu_to_le32(putPaddrLow(pdma_phys_fcp_rsp));\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nbf_set(lpfc_sli4_sge_last, sgl, 1);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\nsgl->sge_len = cpu_to_le32(sizeof(struct fcp_rsp));\r\niocb = &psb->cur_iocbq.iocb;\r\niocb->un.fcpi64.bdl.ulpIoTag32 = 0;\r\niocb->un.fcpi64.bdl.bdeFlags = BUFF_TYPE_BDE_64;\r\niocb->un.fcpi64.bdl.bdeSize = sizeof(struct fcp_cmnd);\r\niocb->un.fcpi64.bdl.addrLow = putPaddrLow(pdma_phys_fcp_cmd);\r\niocb->un.fcpi64.bdl.addrHigh = putPaddrHigh(pdma_phys_fcp_cmd);\r\niocb->ulpBdeCount = 1;\r\niocb->ulpLe = 1;\r\niocb->ulpClass = CLASS3;\r\npsb->cur_iocbq.context1 = psb;\r\npsb->dma_phys_bpl = pdma_phys_bpl;\r\nlist_add_tail(&psb->list, &post_sblist);\r\nspin_lock_irq(&phba->scsi_buf_list_get_lock);\r\nphba->sli4_hba.scsi_xri_cnt++;\r\nspin_unlock_irq(&phba->scsi_buf_list_get_lock);\r\n}\r\nlpfc_printf_log(phba, KERN_INFO, LOG_BG | LOG_FCP,\r\n"3021 Allocate %d out of %d requested new SCSI "\r\n"buffers\n", bcnt, num_to_alloc);\r\nif (!list_empty(&post_sblist))\r\nnum_posted = lpfc_sli4_post_scsi_sgl_list(phba,\r\n&post_sblist, bcnt);\r\nelse\r\nnum_posted = 0;\r\nreturn num_posted;\r\n}\r\nstatic inline int\r\nlpfc_new_scsi_buf(struct lpfc_vport *vport, int num_to_alloc)\r\n{\r\nreturn vport->phba->lpfc_new_scsi_buf(vport, num_to_alloc);\r\n}\r\nstatic struct lpfc_scsi_buf*\r\nlpfc_get_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_scsi_buf * lpfc_cmd = NULL;\r\nstruct list_head *scsi_buf_list_get = &phba->lpfc_scsi_buf_list_get;\r\nunsigned long iflag = 0;\r\nspin_lock_irqsave(&phba->scsi_buf_list_get_lock, iflag);\r\nlist_remove_head(scsi_buf_list_get, lpfc_cmd, struct lpfc_scsi_buf,\r\nlist);\r\nif (!lpfc_cmd) {\r\nspin_lock(&phba->scsi_buf_list_put_lock);\r\nlist_splice(&phba->lpfc_scsi_buf_list_put,\r\n&phba->lpfc_scsi_buf_list_get);\r\nINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_put);\r\nlist_remove_head(scsi_buf_list_get, lpfc_cmd,\r\nstruct lpfc_scsi_buf, list);\r\nspin_unlock(&phba->scsi_buf_list_put_lock);\r\n}\r\nspin_unlock_irqrestore(&phba->scsi_buf_list_get_lock, iflag);\r\nreturn lpfc_cmd;\r\n}\r\nstatic struct lpfc_scsi_buf*\r\nlpfc_get_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\r\n{\r\nstruct lpfc_scsi_buf *lpfc_cmd, *lpfc_cmd_next;\r\nunsigned long iflag = 0;\r\nint found = 0;\r\nspin_lock_irqsave(&phba->scsi_buf_list_get_lock, iflag);\r\nlist_for_each_entry_safe(lpfc_cmd, lpfc_cmd_next,\r\n&phba->lpfc_scsi_buf_list_get, list) {\r\nif (lpfc_test_rrq_active(phba, ndlp,\r\nlpfc_cmd->cur_iocbq.sli4_lxritag))\r\ncontinue;\r\nlist_del(&lpfc_cmd->list);\r\nfound = 1;\r\nbreak;\r\n}\r\nif (!found) {\r\nspin_lock(&phba->scsi_buf_list_put_lock);\r\nlist_splice(&phba->lpfc_scsi_buf_list_put,\r\n&phba->lpfc_scsi_buf_list_get);\r\nINIT_LIST_HEAD(&phba->lpfc_scsi_buf_list_put);\r\nspin_unlock(&phba->scsi_buf_list_put_lock);\r\nlist_for_each_entry_safe(lpfc_cmd, lpfc_cmd_next,\r\n&phba->lpfc_scsi_buf_list_get, list) {\r\nif (lpfc_test_rrq_active(\r\nphba, ndlp, lpfc_cmd->cur_iocbq.sli4_lxritag))\r\ncontinue;\r\nlist_del(&lpfc_cmd->list);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->scsi_buf_list_get_lock, iflag);\r\nif (!found)\r\nreturn NULL;\r\nreturn lpfc_cmd;\r\n}\r\nstatic struct lpfc_scsi_buf*\r\nlpfc_get_scsi_buf(struct lpfc_hba *phba, struct lpfc_nodelist *ndlp)\r\n{\r\nreturn phba->lpfc_get_scsi_buf(phba, ndlp);\r\n}\r\nstatic void\r\nlpfc_release_scsi_buf_s3(struct lpfc_hba *phba, struct lpfc_scsi_buf *psb)\r\n{\r\nunsigned long iflag = 0;\r\npsb->seg_cnt = 0;\r\npsb->nonsg_phys = 0;\r\npsb->prot_seg_cnt = 0;\r\nspin_lock_irqsave(&phba->scsi_buf_list_put_lock, iflag);\r\npsb->pCmd = NULL;\r\npsb->cur_iocbq.iocb_flag = LPFC_IO_FCP;\r\nlist_add_tail(&psb->list, &phba->lpfc_scsi_buf_list_put);\r\nspin_unlock_irqrestore(&phba->scsi_buf_list_put_lock, iflag);\r\n}\r\nstatic void\r\nlpfc_release_scsi_buf_s4(struct lpfc_hba *phba, struct lpfc_scsi_buf *psb)\r\n{\r\nunsigned long iflag = 0;\r\npsb->seg_cnt = 0;\r\npsb->nonsg_phys = 0;\r\npsb->prot_seg_cnt = 0;\r\nif (psb->exch_busy) {\r\nspin_lock_irqsave(&phba->sli4_hba.abts_scsi_buf_list_lock,\r\niflag);\r\npsb->pCmd = NULL;\r\nlist_add_tail(&psb->list,\r\n&phba->sli4_hba.lpfc_abts_scsi_buf_list);\r\nspin_unlock_irqrestore(&phba->sli4_hba.abts_scsi_buf_list_lock,\r\niflag);\r\n} else {\r\npsb->pCmd = NULL;\r\npsb->cur_iocbq.iocb_flag = LPFC_IO_FCP;\r\nspin_lock_irqsave(&phba->scsi_buf_list_put_lock, iflag);\r\nlist_add_tail(&psb->list, &phba->lpfc_scsi_buf_list_put);\r\nspin_unlock_irqrestore(&phba->scsi_buf_list_put_lock, iflag);\r\n}\r\n}\r\nstatic void\r\nlpfc_release_scsi_buf(struct lpfc_hba *phba, struct lpfc_scsi_buf *psb)\r\n{\r\nphba->lpfc_release_scsi_buf(phba, psb);\r\n}\r\nstatic int\r\nlpfc_scsi_prep_dma_buf_s3(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\r\nstruct scatterlist *sgel = NULL;\r\nstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\r\nstruct ulp_bde64 *bpl = lpfc_cmd->fcp_bpl;\r\nstruct lpfc_iocbq *iocbq = &lpfc_cmd->cur_iocbq;\r\nIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\r\nstruct ulp_bde64 *data_bde = iocb_cmd->unsli3.fcp_ext.dbde;\r\ndma_addr_t physaddr;\r\nuint32_t num_bde = 0;\r\nint nseg, datadir = scsi_cmnd->sc_data_direction;\r\nbpl += 2;\r\nif (scsi_sg_count(scsi_cmnd)) {\r\nnseg = dma_map_sg(&phba->pcidev->dev, scsi_sglist(scsi_cmnd),\r\nscsi_sg_count(scsi_cmnd), datadir);\r\nif (unlikely(!nseg))\r\nreturn 1;\r\nlpfc_cmd->seg_cnt = nseg;\r\nif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9064 BLKGRD: %s: Too many sg segments from "\r\n"dma_map_sg. Config %d, seg_cnt %d\n",\r\n__func__, phba->cfg_sg_seg_cnt,\r\nlpfc_cmd->seg_cnt);\r\nlpfc_cmd->seg_cnt = 0;\r\nscsi_dma_unmap(scsi_cmnd);\r\nreturn 1;\r\n}\r\nscsi_for_each_sg(scsi_cmnd, sgel, nseg, num_bde) {\r\nphysaddr = sg_dma_address(sgel);\r\nif (phba->sli_rev == 3 &&\r\n!(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&\r\n!(iocbq->iocb_flag & DSS_SECURITY_OP) &&\r\nnseg <= LPFC_EXT_DATA_BDE_COUNT) {\r\ndata_bde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\ndata_bde->tus.f.bdeSize = sg_dma_len(sgel);\r\ndata_bde->addrLow = putPaddrLow(physaddr);\r\ndata_bde->addrHigh = putPaddrHigh(physaddr);\r\ndata_bde++;\r\n} else {\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nbpl->tus.f.bdeSize = sg_dma_len(sgel);\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nbpl->addrLow =\r\nle32_to_cpu(putPaddrLow(physaddr));\r\nbpl->addrHigh =\r\nle32_to_cpu(putPaddrHigh(physaddr));\r\nbpl++;\r\n}\r\n}\r\n}\r\nif (phba->sli_rev == 3 &&\r\n!(phba->sli3_options & LPFC_SLI3_BG_ENABLED) &&\r\n!(iocbq->iocb_flag & DSS_SECURITY_OP)) {\r\nif (num_bde > LPFC_EXT_DATA_BDE_COUNT) {\r\nphysaddr = lpfc_cmd->dma_handle;\r\ndata_bde->tus.f.bdeFlags = BUFF_TYPE_BLP_64;\r\ndata_bde->tus.f.bdeSize = (num_bde *\r\nsizeof(struct ulp_bde64));\r\nphysaddr += (sizeof(struct fcp_cmnd) +\r\nsizeof(struct fcp_rsp) +\r\n(2 * sizeof(struct ulp_bde64)));\r\ndata_bde->addrHigh = putPaddrHigh(physaddr);\r\ndata_bde->addrLow = putPaddrLow(physaddr);\r\niocb_cmd->unsli3.fcp_ext.ebde_count = 2;\r\n} else {\r\niocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);\r\n}\r\n} else {\r\niocb_cmd->un.fcpi64.bdl.bdeSize =\r\n((num_bde + 2) * sizeof(struct ulp_bde64));\r\niocb_cmd->unsli3.fcp_ext.ebde_count = (num_bde + 1);\r\n}\r\nfcp_cmnd->fcpDl = cpu_to_be32(scsi_bufflen(scsi_cmnd));\r\niocb_cmd->un.fcpi.fcpi_parm = scsi_bufflen(scsi_cmnd);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_bg_err_inject(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nuint32_t *reftag, uint16_t *apptag, uint32_t new_guard)\r\n{\r\nstruct scatterlist *sgpe;\r\nstruct lpfc_scsi_buf *lpfc_cmd = NULL;\r\nstruct scsi_dif_tuple *src = NULL;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_rport_data *rdata;\r\nuint32_t op = scsi_get_prot_op(sc);\r\nuint32_t blksize;\r\nuint32_t numblks;\r\nsector_t lba;\r\nint rc = 0;\r\nint blockoff = 0;\r\nif (op == SCSI_PROT_NORMAL)\r\nreturn 0;\r\nsgpe = scsi_prot_sglist(sc);\r\nlba = scsi_get_lba(sc);\r\nif (phba->lpfc_injerr_lba != LPFC_INJERR_LBA_OFF) {\r\nblksize = lpfc_cmd_blksize(sc);\r\nnumblks = (scsi_bufflen(sc) + blksize - 1) / blksize;\r\nif ((phba->lpfc_injerr_lba < lba) ||\r\n(phba->lpfc_injerr_lba >= (lba + numblks)))\r\nreturn 0;\r\nif (sgpe) {\r\nblockoff = phba->lpfc_injerr_lba - lba;\r\nnumblks = sg_dma_len(sgpe) /\r\nsizeof(struct scsi_dif_tuple);\r\nif (numblks < blockoff)\r\nblockoff = numblks;\r\n}\r\n}\r\nrdata = lpfc_rport_data_from_scsi_device(sc->device);\r\nif (rdata && rdata->pnode) {\r\nndlp = rdata->pnode;\r\nif (phba->lpfc_injerr_nportid &&\r\n(phba->lpfc_injerr_nportid != ndlp->nlp_DID))\r\nreturn 0;\r\nif (phba->lpfc_injerr_wwpn.u.wwn[0] &&\r\n(memcmp(&ndlp->nlp_portname, &phba->lpfc_injerr_wwpn,\r\nsizeof(struct lpfc_name)) != 0))\r\nreturn 0;\r\n}\r\nif (sgpe) {\r\nsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\r\nsrc += blockoff;\r\nlpfc_cmd = (struct lpfc_scsi_buf *)sc->host_scribble;\r\n}\r\nif (reftag) {\r\nif (phba->lpfc_injerr_wref_cnt) {\r\nswitch (op) {\r\ncase SCSI_PROT_WRITE_PASS:\r\nif (src) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9076 BLKGRD: Injecting reftag error: "\r\n"write lba x%lx + x%x oldrefTag x%x\n",\r\n(unsigned long)lba, blockoff,\r\nbe32_to_cpu(src->ref_tag));\r\nif (lpfc_cmd) {\r\nlpfc_cmd->prot_data_type =\r\nLPFC_INJERR_REFTAG;\r\nlpfc_cmd->prot_data_segment =\r\nsrc;\r\nlpfc_cmd->prot_data =\r\nsrc->ref_tag;\r\n}\r\nsrc->ref_tag = cpu_to_be32(0xDEADBEEF);\r\nphba->lpfc_injerr_wref_cnt--;\r\nif (phba->lpfc_injerr_wref_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_TGT | BG_ERR_CHECK;\r\nbreak;\r\n}\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*reftag = 0xDEADBEEF;\r\nphba->lpfc_injerr_wref_cnt--;\r\nif (phba->lpfc_injerr_wref_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_TGT | BG_ERR_CHECK;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9078 BLKGRD: Injecting reftag error: "\r\n"write lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*reftag = 0xDEADBEEF;\r\nphba->lpfc_injerr_wref_cnt--;\r\nif (phba->lpfc_injerr_wref_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_INIT;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9077 BLKGRD: Injecting reftag error: "\r\n"write lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\n}\r\n}\r\nif (phba->lpfc_injerr_rref_cnt) {\r\nswitch (op) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_READ_PASS:\r\n*reftag = 0xDEADBEEF;\r\nphba->lpfc_injerr_rref_cnt--;\r\nif (phba->lpfc_injerr_rref_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_INIT;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9079 BLKGRD: Injecting reftag error: "\r\n"read lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (apptag) {\r\nif (phba->lpfc_injerr_wapp_cnt) {\r\nswitch (op) {\r\ncase SCSI_PROT_WRITE_PASS:\r\nif (src) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9080 BLKGRD: Injecting apptag error: "\r\n"write lba x%lx + x%x oldappTag x%x\n",\r\n(unsigned long)lba, blockoff,\r\nbe16_to_cpu(src->app_tag));\r\nif (lpfc_cmd) {\r\nlpfc_cmd->prot_data_type =\r\nLPFC_INJERR_APPTAG;\r\nlpfc_cmd->prot_data_segment =\r\nsrc;\r\nlpfc_cmd->prot_data =\r\nsrc->app_tag;\r\n}\r\nsrc->app_tag = cpu_to_be16(0xDEAD);\r\nphba->lpfc_injerr_wapp_cnt--;\r\nif (phba->lpfc_injerr_wapp_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_TGT | BG_ERR_CHECK;\r\nbreak;\r\n}\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*apptag = 0xDEAD;\r\nphba->lpfc_injerr_wapp_cnt--;\r\nif (phba->lpfc_injerr_wapp_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_TGT | BG_ERR_CHECK;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"0813 BLKGRD: Injecting apptag error: "\r\n"write lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*apptag = 0xDEAD;\r\nphba->lpfc_injerr_wapp_cnt--;\r\nif (phba->lpfc_injerr_wapp_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_INIT;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"0812 BLKGRD: Injecting apptag error: "\r\n"write lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\n}\r\n}\r\nif (phba->lpfc_injerr_rapp_cnt) {\r\nswitch (op) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_READ_PASS:\r\n*apptag = 0xDEAD;\r\nphba->lpfc_injerr_rapp_cnt--;\r\nif (phba->lpfc_injerr_rapp_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_INIT;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"0814 BLKGRD: Injecting apptag error: "\r\n"read lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (new_guard) {\r\nif (phba->lpfc_injerr_wgrd_cnt) {\r\nswitch (op) {\r\ncase SCSI_PROT_WRITE_PASS:\r\nrc = BG_ERR_CHECK;\r\ncase SCSI_PROT_WRITE_INSERT:\r\nphba->lpfc_injerr_wgrd_cnt--;\r\nif (phba->lpfc_injerr_wgrd_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc |= BG_ERR_TGT | BG_ERR_SWAP;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"0817 BLKGRD: Injecting guard error: "\r\n"write lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\ncase SCSI_PROT_WRITE_STRIP:\r\nphba->lpfc_injerr_wgrd_cnt--;\r\nif (phba->lpfc_injerr_wgrd_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_INIT | BG_ERR_SWAP;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"0816 BLKGRD: Injecting guard error: "\r\n"write lba x%lx\n", (unsigned long)lba);\r\nbreak;\r\n}\r\n}\r\nif (phba->lpfc_injerr_rgrd_cnt) {\r\nswitch (op) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_READ_PASS:\r\nphba->lpfc_injerr_rgrd_cnt--;\r\nif (phba->lpfc_injerr_rgrd_cnt == 0) {\r\nphba->lpfc_injerr_nportid = 0;\r\nphba->lpfc_injerr_lba =\r\nLPFC_INJERR_LBA_OFF;\r\nmemset(&phba->lpfc_injerr_wwpn,\r\n0, sizeof(struct lpfc_name));\r\n}\r\nrc = BG_ERR_INIT | BG_ERR_SWAP;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"0818 BLKGRD: Injecting guard error: "\r\n"read lba x%lx\n", (unsigned long)lba);\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int\r\nlpfc_sc_to_bg_opcodes(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nuint8_t *txop, uint8_t *rxop)\r\n{\r\nuint8_t ret = 0;\r\nif (lpfc_cmd_guard_csum(sc)) {\r\nswitch (scsi_get_prot_op(sc)) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*rxop = BG_OP_IN_NODIF_OUT_CSUM;\r\n*txop = BG_OP_IN_CSUM_OUT_NODIF;\r\nbreak;\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*rxop = BG_OP_IN_CRC_OUT_NODIF;\r\n*txop = BG_OP_IN_NODIF_OUT_CRC;\r\nbreak;\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\n*rxop = BG_OP_IN_CRC_OUT_CSUM;\r\n*txop = BG_OP_IN_CSUM_OUT_CRC;\r\nbreak;\r\ncase SCSI_PROT_NORMAL:\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9063 BLKGRD: Bad op/guard:%d/IP combination\n",\r\nscsi_get_prot_op(sc));\r\nret = 1;\r\nbreak;\r\n}\r\n} else {\r\nswitch (scsi_get_prot_op(sc)) {\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*rxop = BG_OP_IN_CRC_OUT_NODIF;\r\n*txop = BG_OP_IN_NODIF_OUT_CRC;\r\nbreak;\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\n*rxop = BG_OP_IN_CRC_OUT_CRC;\r\n*txop = BG_OP_IN_CRC_OUT_CRC;\r\nbreak;\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*rxop = BG_OP_IN_NODIF_OUT_CRC;\r\n*txop = BG_OP_IN_CRC_OUT_NODIF;\r\nbreak;\r\ncase SCSI_PROT_NORMAL:\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9075 BLKGRD: Bad op/guard:%d/CRC combination\n",\r\nscsi_get_prot_op(sc));\r\nret = 1;\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_bg_err_opcodes(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nuint8_t *txop, uint8_t *rxop)\r\n{\r\nuint8_t ret = 0;\r\nif (lpfc_cmd_guard_csum(sc)) {\r\nswitch (scsi_get_prot_op(sc)) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*rxop = BG_OP_IN_NODIF_OUT_CRC;\r\n*txop = BG_OP_IN_CRC_OUT_NODIF;\r\nbreak;\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*rxop = BG_OP_IN_CSUM_OUT_NODIF;\r\n*txop = BG_OP_IN_NODIF_OUT_CSUM;\r\nbreak;\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\n*rxop = BG_OP_IN_CSUM_OUT_CRC;\r\n*txop = BG_OP_IN_CRC_OUT_CSUM;\r\nbreak;\r\ncase SCSI_PROT_NORMAL:\r\ndefault:\r\nbreak;\r\n}\r\n} else {\r\nswitch (scsi_get_prot_op(sc)) {\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\n*rxop = BG_OP_IN_CSUM_OUT_NODIF;\r\n*txop = BG_OP_IN_NODIF_OUT_CSUM;\r\nbreak;\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\n*rxop = BG_OP_IN_CSUM_OUT_CSUM;\r\n*txop = BG_OP_IN_CSUM_OUT_CSUM;\r\nbreak;\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\n*rxop = BG_OP_IN_NODIF_OUT_CSUM;\r\n*txop = BG_OP_IN_CSUM_OUT_NODIF;\r\nbreak;\r\ncase SCSI_PROT_NORMAL:\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_bg_setup_bpl(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nstruct ulp_bde64 *bpl, int datasegcnt)\r\n{\r\nstruct scatterlist *sgde = NULL;\r\nstruct lpfc_pde5 *pde5 = NULL;\r\nstruct lpfc_pde6 *pde6 = NULL;\r\ndma_addr_t physaddr;\r\nint i = 0, num_bde = 0, status;\r\nint datadir = sc->sc_data_direction;\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nuint32_t rc;\r\n#endif\r\nuint32_t checking = 1;\r\nuint32_t reftag;\r\nuint8_t txop, rxop;\r\nstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\r\nif (status)\r\ngoto out;\r\nreftag = (uint32_t)scsi_get_lba(sc);\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nrc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\r\nif (rc) {\r\nif (rc & BG_ERR_SWAP)\r\nlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\r\nif (rc & BG_ERR_CHECK)\r\nchecking = 0;\r\n}\r\n#endif\r\npde5 = (struct lpfc_pde5 *) bpl;\r\nmemset(pde5, 0, sizeof(struct lpfc_pde5));\r\nbf_set(pde5_type, pde5, LPFC_PDE5_DESCRIPTOR);\r\npde5->word0 = cpu_to_le32(pde5->word0);\r\npde5->reftag = cpu_to_le32(reftag);\r\nnum_bde++;\r\nbpl++;\r\npde6 = (struct lpfc_pde6 *) bpl;\r\nmemset(pde6, 0, sizeof(struct lpfc_pde6));\r\nbf_set(pde6_type, pde6, LPFC_PDE6_DESCRIPTOR);\r\nbf_set(pde6_optx, pde6, txop);\r\nbf_set(pde6_oprx, pde6, rxop);\r\nif (datadir == DMA_FROM_DEVICE) {\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD))\r\nbf_set(pde6_ce, pde6, checking);\r\nelse\r\nbf_set(pde6_ce, pde6, 0);\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\r\nbf_set(pde6_re, pde6, checking);\r\nelse\r\nbf_set(pde6_re, pde6, 0);\r\n}\r\nbf_set(pde6_ai, pde6, 1);\r\nbf_set(pde6_ae, pde6, 0);\r\nbf_set(pde6_apptagval, pde6, 0);\r\npde6->word0 = cpu_to_le32(pde6->word0);\r\npde6->word1 = cpu_to_le32(pde6->word1);\r\npde6->word2 = cpu_to_le32(pde6->word2);\r\nnum_bde++;\r\nbpl++;\r\nscsi_for_each_sg(sc, sgde, datasegcnt, i) {\r\nphysaddr = sg_dma_address(sgde);\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(physaddr));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(physaddr));\r\nbpl->tus.f.bdeSize = sg_dma_len(sgde);\r\nif (datadir == DMA_TO_DEVICE)\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nelse\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nbpl++;\r\nnum_bde++;\r\n}\r\nout:\r\nreturn num_bde;\r\n}\r\nstatic int\r\nlpfc_bg_setup_bpl_prot(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nstruct ulp_bde64 *bpl, int datacnt, int protcnt)\r\n{\r\nstruct scatterlist *sgde = NULL;\r\nstruct scatterlist *sgpe = NULL;\r\nstruct lpfc_pde5 *pde5 = NULL;\r\nstruct lpfc_pde6 *pde6 = NULL;\r\nstruct lpfc_pde7 *pde7 = NULL;\r\ndma_addr_t dataphysaddr, protphysaddr;\r\nunsigned short curr_data = 0, curr_prot = 0;\r\nunsigned int split_offset;\r\nunsigned int protgroup_len, protgroup_offset = 0, protgroup_remainder;\r\nunsigned int protgrp_blks, protgrp_bytes;\r\nunsigned int remainder, subtotal;\r\nint status;\r\nint datadir = sc->sc_data_direction;\r\nunsigned char pgdone = 0, alldone = 0;\r\nunsigned blksize;\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nuint32_t rc;\r\n#endif\r\nuint32_t checking = 1;\r\nuint32_t reftag;\r\nuint8_t txop, rxop;\r\nint num_bde = 0;\r\nsgpe = scsi_prot_sglist(sc);\r\nsgde = scsi_sglist(sc);\r\nif (!sgpe || !sgde) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9020 Invalid s/g entry: data=0x%p prot=0x%p\n",\r\nsgpe, sgde);\r\nreturn 0;\r\n}\r\nstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\r\nif (status)\r\ngoto out;\r\nblksize = lpfc_cmd_blksize(sc);\r\nreftag = (uint32_t)scsi_get_lba(sc);\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nrc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\r\nif (rc) {\r\nif (rc & BG_ERR_SWAP)\r\nlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\r\nif (rc & BG_ERR_CHECK)\r\nchecking = 0;\r\n}\r\n#endif\r\nsplit_offset = 0;\r\ndo {\r\nif (num_bde >= (phba->cfg_total_seg_cnt - 2))\r\nreturn num_bde + 3;\r\npde5 = (struct lpfc_pde5 *) bpl;\r\nmemset(pde5, 0, sizeof(struct lpfc_pde5));\r\nbf_set(pde5_type, pde5, LPFC_PDE5_DESCRIPTOR);\r\npde5->word0 = cpu_to_le32(pde5->word0);\r\npde5->reftag = cpu_to_le32(reftag);\r\nnum_bde++;\r\nbpl++;\r\npde6 = (struct lpfc_pde6 *) bpl;\r\nmemset(pde6, 0, sizeof(struct lpfc_pde6));\r\nbf_set(pde6_type, pde6, LPFC_PDE6_DESCRIPTOR);\r\nbf_set(pde6_optx, pde6, txop);\r\nbf_set(pde6_oprx, pde6, rxop);\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD))\r\nbf_set(pde6_ce, pde6, checking);\r\nelse\r\nbf_set(pde6_ce, pde6, 0);\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\r\nbf_set(pde6_re, pde6, checking);\r\nelse\r\nbf_set(pde6_re, pde6, 0);\r\nbf_set(pde6_ai, pde6, 1);\r\nbf_set(pde6_ae, pde6, 0);\r\nbf_set(pde6_apptagval, pde6, 0);\r\npde6->word0 = cpu_to_le32(pde6->word0);\r\npde6->word1 = cpu_to_le32(pde6->word1);\r\npde6->word2 = cpu_to_le32(pde6->word2);\r\nnum_bde++;\r\nbpl++;\r\nprotphysaddr = sg_dma_address(sgpe) + protgroup_offset;\r\nprotgroup_len = sg_dma_len(sgpe) - protgroup_offset;\r\nBUG_ON(protgroup_len % 8);\r\npde7 = (struct lpfc_pde7 *) bpl;\r\nmemset(pde7, 0, sizeof(struct lpfc_pde7));\r\nbf_set(pde7_type, pde7, LPFC_PDE7_DESCRIPTOR);\r\npde7->addrHigh = le32_to_cpu(putPaddrHigh(protphysaddr));\r\npde7->addrLow = le32_to_cpu(putPaddrLow(protphysaddr));\r\nprotgrp_blks = protgroup_len / 8;\r\nprotgrp_bytes = protgrp_blks * blksize;\r\nif ((pde7->addrLow & 0xfff) + protgroup_len > 0x1000) {\r\nprotgroup_remainder = 0x1000 - (pde7->addrLow & 0xfff);\r\nprotgroup_offset += protgroup_remainder;\r\nprotgrp_blks = protgroup_remainder / 8;\r\nprotgrp_bytes = protgrp_blks * blksize;\r\n} else {\r\nprotgroup_offset = 0;\r\ncurr_prot++;\r\n}\r\nnum_bde++;\r\npgdone = 0;\r\nsubtotal = 0;\r\nwhile (!pgdone) {\r\nif (num_bde >= phba->cfg_total_seg_cnt)\r\nreturn num_bde + 1;\r\nif (!sgde) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9065 BLKGRD:%s Invalid data segment\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nbpl++;\r\ndataphysaddr = sg_dma_address(sgde) + split_offset;\r\nbpl->addrLow = le32_to_cpu(putPaddrLow(dataphysaddr));\r\nbpl->addrHigh = le32_to_cpu(putPaddrHigh(dataphysaddr));\r\nremainder = sg_dma_len(sgde) - split_offset;\r\nif ((subtotal + remainder) <= protgrp_bytes) {\r\nbpl->tus.f.bdeSize = remainder;\r\nsplit_offset = 0;\r\nif ((subtotal + remainder) == protgrp_bytes)\r\npgdone = 1;\r\n} else {\r\nbpl->tus.f.bdeSize = protgrp_bytes - subtotal;\r\nsplit_offset += bpl->tus.f.bdeSize;\r\n}\r\nsubtotal += bpl->tus.f.bdeSize;\r\nif (datadir == DMA_TO_DEVICE)\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nelse\r\nbpl->tus.f.bdeFlags = BUFF_TYPE_BDE_64I;\r\nbpl->tus.w = le32_to_cpu(bpl->tus.w);\r\nnum_bde++;\r\ncurr_data++;\r\nif (split_offset)\r\nbreak;\r\nsgde = sg_next(sgde);\r\n}\r\nif (protgroup_offset) {\r\nreftag += protgrp_blks;\r\nbpl++;\r\ncontinue;\r\n}\r\nif (curr_prot == protcnt) {\r\nalldone = 1;\r\n} else if (curr_prot < protcnt) {\r\nsgpe = sg_next(sgpe);\r\nbpl++;\r\nreftag += protgrp_blks;\r\n} else {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9054 BLKGRD: bug in %s\n", __func__);\r\n}\r\n} while (!alldone);\r\nout:\r\nreturn num_bde;\r\n}\r\nstatic int\r\nlpfc_bg_setup_sgl(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nstruct sli4_sge *sgl, int datasegcnt)\r\n{\r\nstruct scatterlist *sgde = NULL;\r\nstruct sli4_sge_diseed *diseed = NULL;\r\ndma_addr_t physaddr;\r\nint i = 0, num_sge = 0, status;\r\nuint32_t reftag;\r\nuint8_t txop, rxop;\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nuint32_t rc;\r\n#endif\r\nuint32_t checking = 1;\r\nuint32_t dma_len;\r\nuint32_t dma_offset = 0;\r\nstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\r\nif (status)\r\ngoto out;\r\nreftag = (uint32_t)scsi_get_lba(sc);\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nrc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\r\nif (rc) {\r\nif (rc & BG_ERR_SWAP)\r\nlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\r\nif (rc & BG_ERR_CHECK)\r\nchecking = 0;\r\n}\r\n#endif\r\ndiseed = (struct sli4_sge_diseed *) sgl;\r\nmemset(diseed, 0, sizeof(struct sli4_sge_diseed));\r\nbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DISEED);\r\ndiseed->ref_tag = cpu_to_le32(reftag);\r\ndiseed->ref_tag_tran = diseed->ref_tag;\r\nif (sc->sc_data_direction == DMA_FROM_DEVICE) {\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD))\r\nbf_set(lpfc_sli4_sge_dif_ce, diseed, checking);\r\nelse\r\nbf_set(lpfc_sli4_sge_dif_ce, diseed, 0);\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\r\nbf_set(lpfc_sli4_sge_dif_re, diseed, checking);\r\nelse\r\nbf_set(lpfc_sli4_sge_dif_re, diseed, 0);\r\n}\r\nbf_set(lpfc_sli4_sge_dif_optx, diseed, txop);\r\nbf_set(lpfc_sli4_sge_dif_oprx, diseed, rxop);\r\nbf_set(lpfc_sli4_sge_dif_ai, diseed, 1);\r\nbf_set(lpfc_sli4_sge_dif_me, diseed, 0);\r\ndiseed->word2 = cpu_to_le32(diseed->word2);\r\ndiseed->word3 = cpu_to_le32(diseed->word3);\r\nnum_sge++;\r\nsgl++;\r\nscsi_for_each_sg(sc, sgde, datasegcnt, i) {\r\nphysaddr = sg_dma_address(sgde);\r\ndma_len = sg_dma_len(sgde);\r\nsgl->addr_lo = cpu_to_le32(putPaddrLow(physaddr));\r\nsgl->addr_hi = cpu_to_le32(putPaddrHigh(physaddr));\r\nif ((i + 1) == datasegcnt)\r\nbf_set(lpfc_sli4_sge_last, sgl, 1);\r\nelse\r\nbf_set(lpfc_sli4_sge_last, sgl, 0);\r\nbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\r\nbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DATA);\r\nsgl->sge_len = cpu_to_le32(dma_len);\r\ndma_offset += dma_len;\r\nsgl++;\r\nnum_sge++;\r\n}\r\nout:\r\nreturn num_sge;\r\n}\r\nstatic int\r\nlpfc_bg_setup_sgl_prot(struct lpfc_hba *phba, struct scsi_cmnd *sc,\r\nstruct sli4_sge *sgl, int datacnt, int protcnt)\r\n{\r\nstruct scatterlist *sgde = NULL;\r\nstruct scatterlist *sgpe = NULL;\r\nstruct sli4_sge_diseed *diseed = NULL;\r\ndma_addr_t dataphysaddr, protphysaddr;\r\nunsigned short curr_data = 0, curr_prot = 0;\r\nunsigned int split_offset;\r\nunsigned int protgroup_len, protgroup_offset = 0, protgroup_remainder;\r\nunsigned int protgrp_blks, protgrp_bytes;\r\nunsigned int remainder, subtotal;\r\nint status;\r\nunsigned char pgdone = 0, alldone = 0;\r\nunsigned blksize;\r\nuint32_t reftag;\r\nuint8_t txop, rxop;\r\nuint32_t dma_len;\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nuint32_t rc;\r\n#endif\r\nuint32_t checking = 1;\r\nuint32_t dma_offset = 0;\r\nint num_sge = 0;\r\nsgpe = scsi_prot_sglist(sc);\r\nsgde = scsi_sglist(sc);\r\nif (!sgpe || !sgde) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9082 Invalid s/g entry: data=0x%p prot=0x%p\n",\r\nsgpe, sgde);\r\nreturn 0;\r\n}\r\nstatus = lpfc_sc_to_bg_opcodes(phba, sc, &txop, &rxop);\r\nif (status)\r\ngoto out;\r\nblksize = lpfc_cmd_blksize(sc);\r\nreftag = (uint32_t)scsi_get_lba(sc);\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nrc = lpfc_bg_err_inject(phba, sc, &reftag, NULL, 1);\r\nif (rc) {\r\nif (rc & BG_ERR_SWAP)\r\nlpfc_bg_err_opcodes(phba, sc, &txop, &rxop);\r\nif (rc & BG_ERR_CHECK)\r\nchecking = 0;\r\n}\r\n#endif\r\nsplit_offset = 0;\r\ndo {\r\nif (num_sge >= (phba->cfg_total_seg_cnt - 2))\r\nreturn num_sge + 3;\r\ndiseed = (struct sli4_sge_diseed *) sgl;\r\nmemset(diseed, 0, sizeof(struct sli4_sge_diseed));\r\nbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DISEED);\r\ndiseed->ref_tag = cpu_to_le32(reftag);\r\ndiseed->ref_tag_tran = diseed->ref_tag;\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_GUARD)) {\r\nbf_set(lpfc_sli4_sge_dif_ce, diseed, checking);\r\n} else {\r\nbf_set(lpfc_sli4_sge_dif_ce, diseed, 0);\r\nif (txop == BG_OP_IN_CRC_OUT_CRC) {\r\ntxop = BG_OP_RAW_MODE;\r\nrxop = BG_OP_RAW_MODE;\r\n}\r\n}\r\nif (lpfc_cmd_protect(sc, LPFC_CHECK_PROTECT_REF))\r\nbf_set(lpfc_sli4_sge_dif_re, diseed, checking);\r\nelse\r\nbf_set(lpfc_sli4_sge_dif_re, diseed, 0);\r\nbf_set(lpfc_sli4_sge_dif_optx, diseed, txop);\r\nbf_set(lpfc_sli4_sge_dif_oprx, diseed, rxop);\r\nbf_set(lpfc_sli4_sge_dif_ai, diseed, 1);\r\nbf_set(lpfc_sli4_sge_dif_me, diseed, 0);\r\ndiseed->word2 = cpu_to_le32(diseed->word2);\r\ndiseed->word3 = cpu_to_le32(diseed->word3);\r\nnum_sge++;\r\nsgl++;\r\nprotphysaddr = sg_dma_address(sgpe) + protgroup_offset;\r\nprotgroup_len = sg_dma_len(sgpe) - protgroup_offset;\r\nBUG_ON(protgroup_len % 8);\r\nsgl->word2 = 0;\r\nbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DIF);\r\nsgl->addr_hi = le32_to_cpu(putPaddrHigh(protphysaddr));\r\nsgl->addr_lo = le32_to_cpu(putPaddrLow(protphysaddr));\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\nprotgrp_blks = protgroup_len / 8;\r\nprotgrp_bytes = protgrp_blks * blksize;\r\nif ((sgl->addr_lo & 0xfff) + protgroup_len > 0x1000) {\r\nprotgroup_remainder = 0x1000 - (sgl->addr_lo & 0xfff);\r\nprotgroup_offset += protgroup_remainder;\r\nprotgrp_blks = protgroup_remainder / 8;\r\nprotgrp_bytes = protgrp_blks * blksize;\r\n} else {\r\nprotgroup_offset = 0;\r\ncurr_prot++;\r\n}\r\nnum_sge++;\r\npgdone = 0;\r\nsubtotal = 0;\r\nwhile (!pgdone) {\r\nif (num_sge >= phba->cfg_total_seg_cnt)\r\nreturn num_sge + 1;\r\nif (!sgde) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9086 BLKGRD:%s Invalid data segment\n",\r\n__func__);\r\nreturn 0;\r\n}\r\nsgl++;\r\ndataphysaddr = sg_dma_address(sgde) + split_offset;\r\nremainder = sg_dma_len(sgde) - split_offset;\r\nif ((subtotal + remainder) <= protgrp_bytes) {\r\ndma_len = remainder;\r\nsplit_offset = 0;\r\nif ((subtotal + remainder) == protgrp_bytes)\r\npgdone = 1;\r\n} else {\r\ndma_len = protgrp_bytes - subtotal;\r\nsplit_offset += dma_len;\r\n}\r\nsubtotal += dma_len;\r\nsgl->addr_lo = cpu_to_le32(putPaddrLow(dataphysaddr));\r\nsgl->addr_hi = cpu_to_le32(putPaddrHigh(dataphysaddr));\r\nbf_set(lpfc_sli4_sge_last, sgl, 0);\r\nbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\r\nbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DATA);\r\nsgl->sge_len = cpu_to_le32(dma_len);\r\ndma_offset += dma_len;\r\nnum_sge++;\r\ncurr_data++;\r\nif (split_offset)\r\nbreak;\r\nsgde = sg_next(sgde);\r\n}\r\nif (protgroup_offset) {\r\nreftag += protgrp_blks;\r\nsgl++;\r\ncontinue;\r\n}\r\nif (curr_prot == protcnt) {\r\nbf_set(lpfc_sli4_sge_last, sgl, 1);\r\nalldone = 1;\r\n} else if (curr_prot < protcnt) {\r\nsgpe = sg_next(sgpe);\r\nsgl++;\r\nreftag += protgrp_blks;\r\n} else {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9085 BLKGRD: bug in %s\n", __func__);\r\n}\r\n} while (!alldone);\r\nout:\r\nreturn num_sge;\r\n}\r\nstatic int\r\nlpfc_prot_group_type(struct lpfc_hba *phba, struct scsi_cmnd *sc)\r\n{\r\nint ret = LPFC_PG_TYPE_INVALID;\r\nunsigned char op = scsi_get_prot_op(sc);\r\nswitch (op) {\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\nret = LPFC_PG_TYPE_NO_DIF;\r\nbreak;\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\nret = LPFC_PG_TYPE_DIF_BUF;\r\nbreak;\r\ndefault:\r\nif (phba)\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9021 Unsupported protection op:%d\n",\r\nop);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_bg_scsi_adjust_dl(struct lpfc_hba *phba,\r\nstruct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scsi_cmnd *sc = lpfc_cmd->pCmd;\r\nint fcpdl;\r\nfcpdl = scsi_bufflen(sc);\r\nif (sc->sc_data_direction == DMA_FROM_DEVICE) {\r\nif (scsi_get_prot_op(sc) == SCSI_PROT_READ_INSERT)\r\nreturn fcpdl;\r\n} else {\r\nif (scsi_get_prot_op(sc) == SCSI_PROT_WRITE_STRIP)\r\nreturn fcpdl;\r\n}\r\nfcpdl += (fcpdl / lpfc_cmd_blksize(sc)) * 8;\r\nreturn fcpdl;\r\n}\r\nstatic int\r\nlpfc_bg_scsi_prep_dma_buf_s3(struct lpfc_hba *phba,\r\nstruct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\r\nstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\r\nstruct ulp_bde64 *bpl = lpfc_cmd->fcp_bpl;\r\nIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\r\nuint32_t num_bde = 0;\r\nint datasegcnt, protsegcnt, datadir = scsi_cmnd->sc_data_direction;\r\nint prot_group_type = 0;\r\nint fcpdl;\r\nbpl += 2;\r\nif (scsi_sg_count(scsi_cmnd)) {\r\ndatasegcnt = dma_map_sg(&phba->pcidev->dev,\r\nscsi_sglist(scsi_cmnd),\r\nscsi_sg_count(scsi_cmnd), datadir);\r\nif (unlikely(!datasegcnt))\r\nreturn 1;\r\nlpfc_cmd->seg_cnt = datasegcnt;\r\nif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt)\r\ngoto err;\r\nprot_group_type = lpfc_prot_group_type(phba, scsi_cmnd);\r\nswitch (prot_group_type) {\r\ncase LPFC_PG_TYPE_NO_DIF:\r\nif ((lpfc_cmd->seg_cnt + 2) > phba->cfg_total_seg_cnt)\r\ngoto err;\r\nnum_bde = lpfc_bg_setup_bpl(phba, scsi_cmnd, bpl,\r\ndatasegcnt);\r\nif (num_bde < 2)\r\ngoto err;\r\nbreak;\r\ncase LPFC_PG_TYPE_DIF_BUF:\r\nprotsegcnt = dma_map_sg(&phba->pcidev->dev,\r\nscsi_prot_sglist(scsi_cmnd),\r\nscsi_prot_sg_count(scsi_cmnd), datadir);\r\nif (unlikely(!protsegcnt)) {\r\nscsi_dma_unmap(scsi_cmnd);\r\nreturn 1;\r\n}\r\nlpfc_cmd->prot_seg_cnt = protsegcnt;\r\nif ((lpfc_cmd->prot_seg_cnt * 4) >\r\n(phba->cfg_total_seg_cnt - 2))\r\ngoto err;\r\nnum_bde = lpfc_bg_setup_bpl_prot(phba, scsi_cmnd, bpl,\r\ndatasegcnt, protsegcnt);\r\nif ((num_bde < 3) ||\r\n(num_bde > phba->cfg_total_seg_cnt))\r\ngoto err;\r\nbreak;\r\ncase LPFC_PG_TYPE_INVALID:\r\ndefault:\r\nscsi_dma_unmap(scsi_cmnd);\r\nlpfc_cmd->seg_cnt = 0;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9022 Unexpected protection group %i\n",\r\nprot_group_type);\r\nreturn 1;\r\n}\r\n}\r\niocb_cmd->un.fcpi64.bdl.bdeSize = (2 * sizeof(struct ulp_bde64));\r\niocb_cmd->un.fcpi64.bdl.bdeSize += (num_bde * sizeof(struct ulp_bde64));\r\niocb_cmd->ulpBdeCount = 1;\r\niocb_cmd->ulpLe = 1;\r\nfcpdl = lpfc_bg_scsi_adjust_dl(phba, lpfc_cmd);\r\nfcp_cmnd->fcpDl = be32_to_cpu(fcpdl);\r\niocb_cmd->un.fcpi.fcpi_parm = fcpdl;\r\nreturn 0;\r\nerr:\r\nif (lpfc_cmd->seg_cnt)\r\nscsi_dma_unmap(scsi_cmnd);\r\nif (lpfc_cmd->prot_seg_cnt)\r\ndma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(scsi_cmnd),\r\nscsi_prot_sg_count(scsi_cmnd),\r\nscsi_cmnd->sc_data_direction);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9023 Cannot setup S/G List for HBA"\r\n"IO segs %d/%d BPL %d SCSI %d: %d %d\n",\r\nlpfc_cmd->seg_cnt, lpfc_cmd->prot_seg_cnt,\r\nphba->cfg_total_seg_cnt, phba->cfg_sg_seg_cnt,\r\nprot_group_type, num_bde);\r\nlpfc_cmd->seg_cnt = 0;\r\nlpfc_cmd->prot_seg_cnt = 0;\r\nreturn 1;\r\n}\r\nstatic uint16_t\r\nlpfc_bg_crc(uint8_t *data, int count)\r\n{\r\nuint16_t crc = 0;\r\nuint16_t x;\r\ncrc = crc_t10dif(data, count);\r\nx = cpu_to_be16(crc);\r\nreturn x;\r\n}\r\nstatic uint16_t\r\nlpfc_bg_csum(uint8_t *data, int count)\r\n{\r\nuint16_t ret;\r\nret = ip_compute_csum(data, count);\r\nreturn ret;\r\n}\r\nstatic void\r\nlpfc_calc_bg_err(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scatterlist *sgpe;\r\nstruct scatterlist *sgde;\r\nstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\r\nstruct scsi_dif_tuple *src = NULL;\r\nuint8_t *data_src = NULL;\r\nuint16_t guard_tag;\r\nuint16_t start_app_tag, app_tag;\r\nuint32_t start_ref_tag, ref_tag;\r\nint prot, protsegcnt;\r\nint err_type, len, data_len;\r\nint chk_ref, chk_app, chk_guard;\r\nuint16_t sum;\r\nunsigned blksize;\r\nerr_type = BGS_GUARD_ERR_MASK;\r\nsum = 0;\r\nguard_tag = 0;\r\nprot = scsi_get_prot_op(cmd);\r\nif ((prot == SCSI_PROT_READ_STRIP) ||\r\n(prot == SCSI_PROT_WRITE_INSERT) ||\r\n(prot == SCSI_PROT_NORMAL))\r\ngoto out;\r\nchk_ref = 1;\r\nchk_app = 0;\r\nchk_guard = 0;\r\nsgpe = scsi_prot_sglist(cmd);\r\nprotsegcnt = lpfc_cmd->prot_seg_cnt;\r\nif (sgpe && protsegcnt) {\r\nsgde = scsi_sglist(cmd);\r\nblksize = lpfc_cmd_blksize(cmd);\r\ndata_src = (uint8_t *)sg_virt(sgde);\r\ndata_len = sgde->length;\r\nif ((data_len & (blksize - 1)) == 0)\r\nchk_guard = 1;\r\nsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\r\nstart_ref_tag = (uint32_t)scsi_get_lba(cmd);\r\nstart_app_tag = src->app_tag;\r\nlen = sgpe->length;\r\nwhile (src && protsegcnt) {\r\nwhile (len) {\r\nif ((src->ref_tag == 0xffffffff) ||\r\n(src->app_tag == 0xffff)) {\r\nstart_ref_tag++;\r\ngoto skipit;\r\n}\r\nif (chk_guard) {\r\nguard_tag = src->guard_tag;\r\nif (lpfc_cmd_guard_csum(cmd))\r\nsum = lpfc_bg_csum(data_src,\r\nblksize);\r\nelse\r\nsum = lpfc_bg_crc(data_src,\r\nblksize);\r\nif ((guard_tag != sum)) {\r\nerr_type = BGS_GUARD_ERR_MASK;\r\ngoto out;\r\n}\r\n}\r\nref_tag = be32_to_cpu(src->ref_tag);\r\nif (chk_ref && (ref_tag != start_ref_tag)) {\r\nerr_type = BGS_REFTAG_ERR_MASK;\r\ngoto out;\r\n}\r\nstart_ref_tag++;\r\napp_tag = src->app_tag;\r\nif (chk_app && (app_tag != start_app_tag)) {\r\nerr_type = BGS_APPTAG_ERR_MASK;\r\ngoto out;\r\n}\r\nskipit:\r\nlen -= sizeof(struct scsi_dif_tuple);\r\nif (len < 0)\r\nlen = 0;\r\nsrc++;\r\ndata_src += blksize;\r\ndata_len -= blksize;\r\nif (chk_guard && (data_len == 0)) {\r\nchk_guard = 0;\r\nsgde = sg_next(sgde);\r\nif (!sgde)\r\ngoto out;\r\ndata_src = (uint8_t *)sg_virt(sgde);\r\ndata_len = sgde->length;\r\nif ((data_len & (blksize - 1)) == 0)\r\nchk_guard = 1;\r\n}\r\n}\r\nsgpe = sg_next(sgpe);\r\nif (sgpe) {\r\nsrc = (struct scsi_dif_tuple *)sg_virt(sgpe);\r\nlen = sgpe->length;\r\n} else {\r\nsrc = NULL;\r\n}\r\nprotsegcnt--;\r\n}\r\n}\r\nout:\r\nif (err_type == BGS_GUARD_ERR_MASK) {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x1);\r\ncmd->result = DRIVER_SENSE << 24\r\n| ScsiResult(DID_ABORT, SAM_STAT_CHECK_CONDITION);\r\nphba->bg_guard_err_cnt++;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9069 BLKGRD: LBA %lx grd_tag error %x != %x\n",\r\n(unsigned long)scsi_get_lba(cmd),\r\nsum, guard_tag);\r\n} else if (err_type == BGS_REFTAG_ERR_MASK) {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x3);\r\ncmd->result = DRIVER_SENSE << 24\r\n| ScsiResult(DID_ABORT, SAM_STAT_CHECK_CONDITION);\r\nphba->bg_reftag_err_cnt++;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9066 BLKGRD: LBA %lx ref_tag error %x != %x\n",\r\n(unsigned long)scsi_get_lba(cmd),\r\nref_tag, start_ref_tag);\r\n} else if (err_type == BGS_APPTAG_ERR_MASK) {\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x2);\r\ncmd->result = DRIVER_SENSE << 24\r\n| ScsiResult(DID_ABORT, SAM_STAT_CHECK_CONDITION);\r\nphba->bg_apptag_err_cnt++;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9041 BLKGRD: LBA %lx app_tag error %x != %x\n",\r\n(unsigned long)scsi_get_lba(cmd),\r\napp_tag, start_app_tag);\r\n}\r\n}\r\nstatic int\r\nlpfc_parse_bg_err(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd,\r\nstruct lpfc_iocbq *pIocbOut)\r\n{\r\nstruct scsi_cmnd *cmd = lpfc_cmd->pCmd;\r\nstruct sli3_bg_fields *bgf = &pIocbOut->iocb.unsli3.sli3_bg;\r\nint ret = 0;\r\nuint32_t bghm = bgf->bghm;\r\nuint32_t bgstat = bgf->bgstat;\r\nuint64_t failing_sector = 0;\r\nspin_lock(&_dump_buf_lock);\r\nif (!_dump_buf_done) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG, "9070 BLKGRD: Saving"\r\n" Data for %u blocks to debugfs\n",\r\n(cmd->cmnd[7] << 8 | cmd->cmnd[8]));\r\nlpfc_debug_save_data(phba, cmd);\r\nif (lpfc_prot_group_type(phba, cmd) ==\r\nLPFC_PG_TYPE_DIF_BUF) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG, "9071 BLKGRD: "\r\n"Saving DIF for %u blocks to debugfs\n",\r\n(cmd->cmnd[7] << 8 | cmd->cmnd[8]));\r\nlpfc_debug_save_dif(phba, cmd);\r\n}\r\n_dump_buf_done = 1;\r\n}\r\nspin_unlock(&_dump_buf_lock);\r\nif (lpfc_bgs_get_invalid_prof(bgstat)) {\r\ncmd->result = ScsiResult(DID_ERROR, 0);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9072 BLKGRD: Invalid BG Profile in cmd"\r\n" 0x%x lba 0x%llx blk cnt 0x%x "\r\n"bgstat=x%x bghm=x%x\n", cmd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmd),\r\nblk_rq_sectors(cmd->request), bgstat, bghm);\r\nret = (-1);\r\ngoto out;\r\n}\r\nif (lpfc_bgs_get_uninit_dif_block(bgstat)) {\r\ncmd->result = ScsiResult(DID_ERROR, 0);\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9073 BLKGRD: Invalid BG PDIF Block in cmd"\r\n" 0x%x lba 0x%llx blk cnt 0x%x "\r\n"bgstat=x%x bghm=x%x\n", cmd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmd),\r\nblk_rq_sectors(cmd->request), bgstat, bghm);\r\nret = (-1);\r\ngoto out;\r\n}\r\nif (lpfc_bgs_get_guard_err(bgstat)) {\r\nret = 1;\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x1);\r\ncmd->result = DRIVER_SENSE << 24\r\n| ScsiResult(DID_ABORT, SAM_STAT_CHECK_CONDITION);\r\nphba->bg_guard_err_cnt++;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9055 BLKGRD: Guard Tag error in cmd"\r\n" 0x%x lba 0x%llx blk cnt 0x%x "\r\n"bgstat=x%x bghm=x%x\n", cmd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmd),\r\nblk_rq_sectors(cmd->request), bgstat, bghm);\r\n}\r\nif (lpfc_bgs_get_reftag_err(bgstat)) {\r\nret = 1;\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x3);\r\ncmd->result = DRIVER_SENSE << 24\r\n| ScsiResult(DID_ABORT, SAM_STAT_CHECK_CONDITION);\r\nphba->bg_reftag_err_cnt++;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9056 BLKGRD: Ref Tag error in cmd"\r\n" 0x%x lba 0x%llx blk cnt 0x%x "\r\n"bgstat=x%x bghm=x%x\n", cmd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmd),\r\nblk_rq_sectors(cmd->request), bgstat, bghm);\r\n}\r\nif (lpfc_bgs_get_apptag_err(bgstat)) {\r\nret = 1;\r\nscsi_build_sense_buffer(1, cmd->sense_buffer, ILLEGAL_REQUEST,\r\n0x10, 0x2);\r\ncmd->result = DRIVER_SENSE << 24\r\n| ScsiResult(DID_ABORT, SAM_STAT_CHECK_CONDITION);\r\nphba->bg_apptag_err_cnt++;\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9061 BLKGRD: App Tag error in cmd"\r\n" 0x%x lba 0x%llx blk cnt 0x%x "\r\n"bgstat=x%x bghm=x%x\n", cmd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmd),\r\nblk_rq_sectors(cmd->request), bgstat, bghm);\r\n}\r\nif (lpfc_bgs_get_hi_water_mark_present(bgstat)) {\r\ncmd->sense_buffer[7] = 0xc;\r\ncmd->sense_buffer[8] = 0;\r\ncmd->sense_buffer[9] = 0xa;\r\ncmd->sense_buffer[10] = 0x80;\r\nswitch (scsi_get_prot_op(cmd)) {\r\ncase SCSI_PROT_READ_INSERT:\r\ncase SCSI_PROT_WRITE_STRIP:\r\nbghm /= cmd->device->sector_size;\r\nbreak;\r\ncase SCSI_PROT_READ_STRIP:\r\ncase SCSI_PROT_WRITE_INSERT:\r\ncase SCSI_PROT_READ_PASS:\r\ncase SCSI_PROT_WRITE_PASS:\r\nbghm /= (cmd->device->sector_size +\r\nsizeof(struct scsi_dif_tuple));\r\nbreak;\r\n}\r\nfailing_sector = scsi_get_lba(cmd);\r\nfailing_sector += bghm;\r\nput_unaligned_be64(failing_sector, &cmd->sense_buffer[12]);\r\n}\r\nif (!ret) {\r\nlpfc_printf_log(phba, KERN_WARNING, LOG_FCP | LOG_BG,\r\n"9057 BLKGRD: Unknown error in cmd"\r\n" 0x%x lba 0x%llx blk cnt 0x%x "\r\n"bgstat=x%x bghm=x%x\n", cmd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmd),\r\nblk_rq_sectors(cmd->request), bgstat, bghm);\r\nlpfc_calc_bg_err(phba, lpfc_cmd);\r\n}\r\nout:\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_scsi_prep_dma_buf_s4(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\r\nstruct scatterlist *sgel = NULL;\r\nstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\r\nstruct sli4_sge *sgl = (struct sli4_sge *)lpfc_cmd->fcp_bpl;\r\nstruct sli4_sge *first_data_sgl;\r\nIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\r\ndma_addr_t physaddr;\r\nuint32_t num_bde = 0;\r\nuint32_t dma_len;\r\nuint32_t dma_offset = 0;\r\nint nseg;\r\nstruct ulp_bde64 *bde;\r\nif (scsi_sg_count(scsi_cmnd)) {\r\nnseg = scsi_dma_map(scsi_cmnd);\r\nif (unlikely(nseg <= 0))\r\nreturn 1;\r\nsgl += 1;\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nbf_set(lpfc_sli4_sge_last, sgl, 0);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\nsgl += 1;\r\nfirst_data_sgl = sgl;\r\nlpfc_cmd->seg_cnt = nseg;\r\nif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG, "9074 BLKGRD:"\r\n" %s: Too many sg segments from "\r\n"dma_map_sg. Config %d, seg_cnt %d\n",\r\n__func__, phba->cfg_sg_seg_cnt,\r\nlpfc_cmd->seg_cnt);\r\nlpfc_cmd->seg_cnt = 0;\r\nscsi_dma_unmap(scsi_cmnd);\r\nreturn 1;\r\n}\r\nscsi_for_each_sg(scsi_cmnd, sgel, nseg, num_bde) {\r\nphysaddr = sg_dma_address(sgel);\r\ndma_len = sg_dma_len(sgel);\r\nsgl->addr_lo = cpu_to_le32(putPaddrLow(physaddr));\r\nsgl->addr_hi = cpu_to_le32(putPaddrHigh(physaddr));\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nif ((num_bde + 1) == nseg)\r\nbf_set(lpfc_sli4_sge_last, sgl, 1);\r\nelse\r\nbf_set(lpfc_sli4_sge_last, sgl, 0);\r\nbf_set(lpfc_sli4_sge_offset, sgl, dma_offset);\r\nbf_set(lpfc_sli4_sge_type, sgl, LPFC_SGE_TYPE_DATA);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\nsgl->sge_len = cpu_to_le32(dma_len);\r\ndma_offset += dma_len;\r\nsgl++;\r\n}\r\nif (phba->sli3_options & LPFC_SLI4_PERFH_ENABLED) {\r\nbde = (struct ulp_bde64 *)\r\n&(iocb_cmd->unsli3.sli3Words[5]);\r\nbde->addrLow = first_data_sgl->addr_lo;\r\nbde->addrHigh = first_data_sgl->addr_hi;\r\nbde->tus.f.bdeSize =\r\nle32_to_cpu(first_data_sgl->sge_len);\r\nbde->tus.f.bdeFlags = BUFF_TYPE_BDE_64;\r\nbde->tus.w = cpu_to_le32(bde->tus.w);\r\n}\r\n} else {\r\nsgl += 1;\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nbf_set(lpfc_sli4_sge_last, sgl, 1);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\n}\r\nfcp_cmnd->fcpDl = cpu_to_be32(scsi_bufflen(scsi_cmnd));\r\niocb_cmd->un.fcpi.fcpi_parm = scsi_bufflen(scsi_cmnd);\r\nif ((phba->cfg_fof) && ((struct lpfc_device_data *)\r\nscsi_cmnd->device->hostdata)->oas_enabled) {\r\nlpfc_cmd->cur_iocbq.iocb_flag |= (LPFC_IO_OAS | LPFC_IO_FOF);\r\nlpfc_cmd->cur_iocbq.priority = ((struct lpfc_device_data *)\r\nscsi_cmnd->device->hostdata)->priority;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_bg_scsi_prep_dma_buf_s4(struct lpfc_hba *phba,\r\nstruct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\r\nstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\r\nstruct sli4_sge *sgl = (struct sli4_sge *)(lpfc_cmd->fcp_bpl);\r\nIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\r\nuint32_t num_sge = 0;\r\nint datasegcnt, protsegcnt, datadir = scsi_cmnd->sc_data_direction;\r\nint prot_group_type = 0;\r\nint fcpdl;\r\nif (scsi_sg_count(scsi_cmnd)) {\r\ndatasegcnt = dma_map_sg(&phba->pcidev->dev,\r\nscsi_sglist(scsi_cmnd),\r\nscsi_sg_count(scsi_cmnd), datadir);\r\nif (unlikely(!datasegcnt))\r\nreturn 1;\r\nsgl += 1;\r\nsgl->word2 = le32_to_cpu(sgl->word2);\r\nbf_set(lpfc_sli4_sge_last, sgl, 0);\r\nsgl->word2 = cpu_to_le32(sgl->word2);\r\nsgl += 1;\r\nlpfc_cmd->seg_cnt = datasegcnt;\r\nif (lpfc_cmd->seg_cnt > phba->cfg_sg_seg_cnt)\r\ngoto err;\r\nprot_group_type = lpfc_prot_group_type(phba, scsi_cmnd);\r\nswitch (prot_group_type) {\r\ncase LPFC_PG_TYPE_NO_DIF:\r\nif ((lpfc_cmd->seg_cnt + 1) > phba->cfg_total_seg_cnt)\r\ngoto err;\r\nnum_sge = lpfc_bg_setup_sgl(phba, scsi_cmnd, sgl,\r\ndatasegcnt);\r\nif (num_sge < 2)\r\ngoto err;\r\nbreak;\r\ncase LPFC_PG_TYPE_DIF_BUF:\r\nprotsegcnt = dma_map_sg(&phba->pcidev->dev,\r\nscsi_prot_sglist(scsi_cmnd),\r\nscsi_prot_sg_count(scsi_cmnd), datadir);\r\nif (unlikely(!protsegcnt)) {\r\nscsi_dma_unmap(scsi_cmnd);\r\nreturn 1;\r\n}\r\nlpfc_cmd->prot_seg_cnt = protsegcnt;\r\nif ((lpfc_cmd->prot_seg_cnt * 3) >\r\n(phba->cfg_total_seg_cnt - 2))\r\ngoto err;\r\nnum_sge = lpfc_bg_setup_sgl_prot(phba, scsi_cmnd, sgl,\r\ndatasegcnt, protsegcnt);\r\nif ((num_sge < 3) ||\r\n(num_sge > phba->cfg_total_seg_cnt))\r\ngoto err;\r\nbreak;\r\ncase LPFC_PG_TYPE_INVALID:\r\ndefault:\r\nscsi_dma_unmap(scsi_cmnd);\r\nlpfc_cmd->seg_cnt = 0;\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9083 Unexpected protection group %i\n",\r\nprot_group_type);\r\nreturn 1;\r\n}\r\n}\r\nswitch (scsi_get_prot_op(scsi_cmnd)) {\r\ncase SCSI_PROT_WRITE_STRIP:\r\ncase SCSI_PROT_READ_STRIP:\r\nlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_IO_DIF_STRIP;\r\nbreak;\r\ncase SCSI_PROT_WRITE_INSERT:\r\ncase SCSI_PROT_READ_INSERT:\r\nlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_IO_DIF_INSERT;\r\nbreak;\r\ncase SCSI_PROT_WRITE_PASS:\r\ncase SCSI_PROT_READ_PASS:\r\nlpfc_cmd->cur_iocbq.iocb_flag |= LPFC_IO_DIF_PASS;\r\nbreak;\r\n}\r\nfcpdl = lpfc_bg_scsi_adjust_dl(phba, lpfc_cmd);\r\nfcp_cmnd->fcpDl = be32_to_cpu(fcpdl);\r\niocb_cmd->un.fcpi.fcpi_parm = fcpdl;\r\nif ((phba->cfg_fof) && ((struct lpfc_device_data *)\r\nscsi_cmnd->device->hostdata)->oas_enabled)\r\nlpfc_cmd->cur_iocbq.iocb_flag |= (LPFC_IO_OAS | LPFC_IO_FOF);\r\nreturn 0;\r\nerr:\r\nif (lpfc_cmd->seg_cnt)\r\nscsi_dma_unmap(scsi_cmnd);\r\nif (lpfc_cmd->prot_seg_cnt)\r\ndma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(scsi_cmnd),\r\nscsi_prot_sg_count(scsi_cmnd),\r\nscsi_cmnd->sc_data_direction);\r\nlpfc_printf_log(phba, KERN_ERR, LOG_FCP,\r\n"9084 Cannot setup S/G List for HBA"\r\n"IO segs %d/%d SGL %d SCSI %d: %d %d\n",\r\nlpfc_cmd->seg_cnt, lpfc_cmd->prot_seg_cnt,\r\nphba->cfg_total_seg_cnt, phba->cfg_sg_seg_cnt,\r\nprot_group_type, num_sge);\r\nlpfc_cmd->seg_cnt = 0;\r\nlpfc_cmd->prot_seg_cnt = 0;\r\nreturn 1;\r\n}\r\nstatic inline int\r\nlpfc_scsi_prep_dma_buf(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nreturn phba->lpfc_scsi_prep_dma_buf(phba, lpfc_cmd);\r\n}\r\nstatic inline int\r\nlpfc_bg_scsi_prep_dma_buf(struct lpfc_hba *phba, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nreturn phba->lpfc_bg_scsi_prep_dma_buf(phba, lpfc_cmd);\r\n}\r\nstatic void\r\nlpfc_send_scsi_error_event(struct lpfc_hba *phba, struct lpfc_vport *vport,\r\nstruct lpfc_scsi_buf *lpfc_cmd, struct lpfc_iocbq *rsp_iocb) {\r\nstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\r\nstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\r\nuint32_t resp_info = fcprsp->rspStatus2;\r\nuint32_t scsi_status = fcprsp->rspStatus3;\r\nuint32_t fcpi_parm = rsp_iocb->iocb.un.fcpi.fcpi_parm;\r\nstruct lpfc_fast_path_event *fast_path_evt = NULL;\r\nstruct lpfc_nodelist *pnode = lpfc_cmd->rdata->pnode;\r\nunsigned long flags;\r\nif (!pnode || !NLP_CHK_NODE_ACT(pnode))\r\nreturn;\r\nif ((cmnd->result == SAM_STAT_TASK_SET_FULL) ||\r\n(cmnd->result == SAM_STAT_BUSY)) {\r\nfast_path_evt = lpfc_alloc_fast_evt(phba);\r\nif (!fast_path_evt)\r\nreturn;\r\nfast_path_evt->un.scsi_evt.event_type =\r\nFC_REG_SCSI_EVENT;\r\nfast_path_evt->un.scsi_evt.subcategory =\r\n(cmnd->result == SAM_STAT_TASK_SET_FULL) ?\r\nLPFC_EVENT_QFULL : LPFC_EVENT_DEVBSY;\r\nfast_path_evt->un.scsi_evt.lun = cmnd->device->lun;\r\nmemcpy(&fast_path_evt->un.scsi_evt.wwpn,\r\n&pnode->nlp_portname, sizeof(struct lpfc_name));\r\nmemcpy(&fast_path_evt->un.scsi_evt.wwnn,\r\n&pnode->nlp_nodename, sizeof(struct lpfc_name));\r\n} else if ((resp_info & SNS_LEN_VALID) && fcprsp->rspSnsLen &&\r\n((cmnd->cmnd[0] == READ_10) || (cmnd->cmnd[0] == WRITE_10))) {\r\nfast_path_evt = lpfc_alloc_fast_evt(phba);\r\nif (!fast_path_evt)\r\nreturn;\r\nfast_path_evt->un.check_cond_evt.scsi_event.event_type =\r\nFC_REG_SCSI_EVENT;\r\nfast_path_evt->un.check_cond_evt.scsi_event.subcategory =\r\nLPFC_EVENT_CHECK_COND;\r\nfast_path_evt->un.check_cond_evt.scsi_event.lun =\r\ncmnd->device->lun;\r\nmemcpy(&fast_path_evt->un.check_cond_evt.scsi_event.wwpn,\r\n&pnode->nlp_portname, sizeof(struct lpfc_name));\r\nmemcpy(&fast_path_evt->un.check_cond_evt.scsi_event.wwnn,\r\n&pnode->nlp_nodename, sizeof(struct lpfc_name));\r\nfast_path_evt->un.check_cond_evt.sense_key =\r\ncmnd->sense_buffer[2] & 0xf;\r\nfast_path_evt->un.check_cond_evt.asc = cmnd->sense_buffer[12];\r\nfast_path_evt->un.check_cond_evt.ascq = cmnd->sense_buffer[13];\r\n} else if ((cmnd->sc_data_direction == DMA_FROM_DEVICE) &&\r\nfcpi_parm &&\r\n((be32_to_cpu(fcprsp->rspResId) != fcpi_parm) ||\r\n((scsi_status == SAM_STAT_GOOD) &&\r\n!(resp_info & (RESID_UNDER | RESID_OVER))))) {\r\nfast_path_evt = lpfc_alloc_fast_evt(phba);\r\nif (!fast_path_evt)\r\nreturn;\r\nfast_path_evt->un.read_check_error.header.event_type =\r\nFC_REG_FABRIC_EVENT;\r\nfast_path_evt->un.read_check_error.header.subcategory =\r\nLPFC_EVENT_FCPRDCHKERR;\r\nmemcpy(&fast_path_evt->un.read_check_error.header.wwpn,\r\n&pnode->nlp_portname, sizeof(struct lpfc_name));\r\nmemcpy(&fast_path_evt->un.read_check_error.header.wwnn,\r\n&pnode->nlp_nodename, sizeof(struct lpfc_name));\r\nfast_path_evt->un.read_check_error.lun = cmnd->device->lun;\r\nfast_path_evt->un.read_check_error.opcode = cmnd->cmnd[0];\r\nfast_path_evt->un.read_check_error.fcpiparam =\r\nfcpi_parm;\r\n} else\r\nreturn;\r\nfast_path_evt->vport = vport;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nlist_add_tail(&fast_path_evt->work_evt.evt_listp, &phba->work_list);\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nlpfc_worker_wake_up(phba);\r\nreturn;\r\n}\r\nstatic void\r\nlpfc_scsi_unprep_dma_buf(struct lpfc_hba *phba, struct lpfc_scsi_buf *psb)\r\n{\r\nif (psb->seg_cnt > 0)\r\nscsi_dma_unmap(psb->pCmd);\r\nif (psb->prot_seg_cnt > 0)\r\ndma_unmap_sg(&phba->pcidev->dev, scsi_prot_sglist(psb->pCmd),\r\nscsi_prot_sg_count(psb->pCmd),\r\npsb->pCmd->sc_data_direction);\r\n}\r\nstatic void\r\nlpfc_handle_fcp_err(struct lpfc_vport *vport, struct lpfc_scsi_buf *lpfc_cmd,\r\nstruct lpfc_iocbq *rsp_iocb)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\r\nstruct fcp_cmnd *fcpcmd = lpfc_cmd->fcp_cmnd;\r\nstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\r\nuint32_t fcpi_parm = rsp_iocb->iocb.un.fcpi.fcpi_parm;\r\nuint32_t resp_info = fcprsp->rspStatus2;\r\nuint32_t scsi_status = fcprsp->rspStatus3;\r\nuint32_t *lp;\r\nuint32_t host_status = DID_OK;\r\nuint32_t rsplen = 0;\r\nuint32_t fcpDl;\r\nuint32_t logit = LOG_FCP | LOG_FCP_ERROR;\r\nif (fcpcmd->fcpCntl2) {\r\nscsi_status = 0;\r\ngoto out;\r\n}\r\nif (resp_info & RSP_LEN_VALID) {\r\nrsplen = be32_to_cpu(fcprsp->rspRspLen);\r\nif (rsplen != 0 && rsplen != 4 && rsplen != 8) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"2719 Invalid response length: "\r\n"tgt x%x lun x%llx cmnd x%x rsplen x%x\n",\r\ncmnd->device->id,\r\ncmnd->device->lun, cmnd->cmnd[0],\r\nrsplen);\r\nhost_status = DID_ERROR;\r\ngoto out;\r\n}\r\nif (fcprsp->rspInfo3 != RSP_NO_FAILURE) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"2757 Protocol failure detected during "\r\n"processing of FCP I/O op: "\r\n"tgt x%x lun x%llx cmnd x%x rspInfo3 x%x\n",\r\ncmnd->device->id,\r\ncmnd->device->lun, cmnd->cmnd[0],\r\nfcprsp->rspInfo3);\r\nhost_status = DID_ERROR;\r\ngoto out;\r\n}\r\n}\r\nif ((resp_info & SNS_LEN_VALID) && fcprsp->rspSnsLen) {\r\nuint32_t snslen = be32_to_cpu(fcprsp->rspSnsLen);\r\nif (snslen > SCSI_SENSE_BUFFERSIZE)\r\nsnslen = SCSI_SENSE_BUFFERSIZE;\r\nif (resp_info & RSP_LEN_VALID)\r\nrsplen = be32_to_cpu(fcprsp->rspRspLen);\r\nmemcpy(cmnd->sense_buffer, &fcprsp->rspInfo0 + rsplen, snslen);\r\n}\r\nlp = (uint32_t *)cmnd->sense_buffer;\r\nif (!scsi_status && (resp_info & RESID_UNDER)) {\r\nif (vport->cfg_log_verbose & LOG_FCP)\r\nlogit = LOG_FCP_ERROR;\r\nif (vport->cfg_log_verbose & LOG_FCP_UNDER)\r\nlogit = LOG_FCP_UNDER;\r\n}\r\nlpfc_printf_vlog(vport, KERN_WARNING, logit,\r\n"9024 FCP command x%x failed: x%x SNS x%x x%x "\r\n"Data: x%x x%x x%x x%x x%x\n",\r\ncmnd->cmnd[0], scsi_status,\r\nbe32_to_cpu(*lp), be32_to_cpu(*(lp + 3)), resp_info,\r\nbe32_to_cpu(fcprsp->rspResId),\r\nbe32_to_cpu(fcprsp->rspSnsLen),\r\nbe32_to_cpu(fcprsp->rspRspLen),\r\nfcprsp->rspInfo3);\r\nscsi_set_resid(cmnd, 0);\r\nfcpDl = be32_to_cpu(fcpcmd->fcpDl);\r\nif (resp_info & RESID_UNDER) {\r\nscsi_set_resid(cmnd, be32_to_cpu(fcprsp->rspResId));\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_UNDER,\r\n"9025 FCP Read Underrun, expected %d, "\r\n"residual %d Data: x%x x%x x%x\n",\r\nfcpDl,\r\nscsi_get_resid(cmnd), fcpi_parm, cmnd->cmnd[0],\r\ncmnd->underflow);\r\nif ((cmnd->sc_data_direction == DMA_FROM_DEVICE) &&\r\nfcpi_parm &&\r\n(scsi_get_resid(cmnd) != fcpi_parm)) {\r\nlpfc_printf_vlog(vport, KERN_WARNING,\r\nLOG_FCP | LOG_FCP_ERROR,\r\n"9026 FCP Read Check Error "\r\n"and Underrun Data: x%x x%x x%x x%x\n",\r\nfcpDl,\r\nscsi_get_resid(cmnd), fcpi_parm,\r\ncmnd->cmnd[0]);\r\nscsi_set_resid(cmnd, scsi_bufflen(cmnd));\r\nhost_status = DID_ERROR;\r\n}\r\nif (!(resp_info & SNS_LEN_VALID) &&\r\n(scsi_status == SAM_STAT_GOOD) &&\r\n(scsi_bufflen(cmnd) - scsi_get_resid(cmnd)\r\n< cmnd->underflow)) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"9027 FCP command x%x residual "\r\n"underrun converted to error "\r\n"Data: x%x x%x x%x\n",\r\ncmnd->cmnd[0], scsi_bufflen(cmnd),\r\nscsi_get_resid(cmnd), cmnd->underflow);\r\nhost_status = DID_ERROR;\r\n}\r\n} else if (resp_info & RESID_OVER) {\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"9028 FCP command x%x residual overrun error. "\r\n"Data: x%x x%x\n", cmnd->cmnd[0],\r\nscsi_bufflen(cmnd), scsi_get_resid(cmnd));\r\nhost_status = DID_ERROR;\r\n} else if (fcpi_parm) {\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP | LOG_FCP_ERROR,\r\n"9029 FCP %s Check Error xri x%x Data: "\r\n"x%x x%x x%x x%x x%x\n",\r\n((cmnd->sc_data_direction == DMA_FROM_DEVICE) ?\r\n"Read" : "Write"),\r\n((phba->sli_rev == LPFC_SLI_REV4) ?\r\nlpfc_cmd->cur_iocbq.sli4_xritag :\r\nrsp_iocb->iocb.ulpContext),\r\nfcpDl, be32_to_cpu(fcprsp->rspResId),\r\nfcpi_parm, cmnd->cmnd[0], scsi_status);\r\nif (fcpi_parm > fcpDl)\r\ngoto out;\r\nswitch (scsi_status) {\r\ncase SAM_STAT_GOOD:\r\ncase SAM_STAT_CHECK_CONDITION:\r\nhost_status = DID_ERROR;\r\nbreak;\r\n}\r\nscsi_set_resid(cmnd, scsi_bufflen(cmnd));\r\n}\r\nout:\r\ncmnd->result = ScsiResult(host_status, scsi_status);\r\nlpfc_send_scsi_error_event(vport->phba, vport, lpfc_cmd, rsp_iocb);\r\n}\r\nint lpfc_sli4_scmd_to_wqidx_distr(struct lpfc_hba *phba,\r\nstruct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct scsi_cmnd *cmnd = lpfc_cmd->pCmd;\r\nstruct lpfc_vector_map_info *cpup;\r\nint chann, cpu;\r\nuint32_t tag;\r\nuint16_t hwq;\r\nif (cmnd && shost_use_blk_mq(cmnd->device->host)) {\r\ntag = blk_mq_unique_tag(cmnd->request);\r\nhwq = blk_mq_unique_tag_to_hwq(tag);\r\nreturn hwq;\r\n}\r\nif (phba->cfg_fcp_io_sched == LPFC_FCP_SCHED_BY_CPU\r\n&& phba->cfg_fcp_io_channel > 1) {\r\ncpu = smp_processor_id();\r\nif (cpu < phba->sli4_hba.num_present_cpu) {\r\ncpup = phba->sli4_hba.cpu_map;\r\ncpup += cpu;\r\nreturn cpup->channel_id;\r\n}\r\n}\r\nchann = atomic_add_return(1, &phba->fcp_qidx);\r\nchann = chann % phba->cfg_fcp_io_channel;\r\nreturn chann;\r\n}\r\nstatic void\r\nlpfc_scsi_cmd_iocb_cmpl(struct lpfc_hba *phba, struct lpfc_iocbq *pIocbIn,\r\nstruct lpfc_iocbq *pIocbOut)\r\n{\r\nstruct lpfc_scsi_buf *lpfc_cmd =\r\n(struct lpfc_scsi_buf *) pIocbIn->context1;\r\nstruct lpfc_vport *vport = pIocbIn->vport;\r\nstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\r\nstruct lpfc_nodelist *pnode = rdata->pnode;\r\nstruct scsi_cmnd *cmd;\r\nint depth;\r\nunsigned long flags;\r\nstruct lpfc_fast_path_event *fast_path_evt;\r\nstruct Scsi_Host *shost;\r\nuint32_t logit = LOG_FCP;\r\nphba->fc4ScsiIoCmpls++;\r\ncmd = lpfc_cmd->pCmd;\r\nif (!cmd)\r\nreturn;\r\nshost = cmd->device->host;\r\nlpfc_cmd->result = (pIocbOut->iocb.un.ulpWord[4] & IOERR_PARAM_MASK);\r\nlpfc_cmd->status = pIocbOut->iocb.ulpStatus;\r\nlpfc_cmd->exch_busy = pIocbOut->iocb_flag & LPFC_EXCHANGE_BUSY;\r\n#ifdef CONFIG_SCSI_LPFC_DEBUG_FS\r\nif (lpfc_cmd->prot_data_type) {\r\nstruct scsi_dif_tuple *src = NULL;\r\nsrc = (struct scsi_dif_tuple *)lpfc_cmd->prot_data_segment;\r\nswitch (lpfc_cmd->prot_data_type) {\r\ncase LPFC_INJERR_REFTAG:\r\nsrc->ref_tag =\r\nlpfc_cmd->prot_data;\r\nbreak;\r\ncase LPFC_INJERR_APPTAG:\r\nsrc->app_tag =\r\n(uint16_t)lpfc_cmd->prot_data;\r\nbreak;\r\ncase LPFC_INJERR_GUARD:\r\nsrc->guard_tag =\r\n(uint16_t)lpfc_cmd->prot_data;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlpfc_cmd->prot_data = 0;\r\nlpfc_cmd->prot_data_type = 0;\r\nlpfc_cmd->prot_data_segment = NULL;\r\n}\r\n#endif\r\nif (pnode && NLP_CHK_NODE_ACT(pnode))\r\natomic_dec(&pnode->cmd_pending);\r\nif (lpfc_cmd->status) {\r\nif (lpfc_cmd->status == IOSTAT_LOCAL_REJECT &&\r\n(lpfc_cmd->result & IOERR_DRVR_MASK))\r\nlpfc_cmd->status = IOSTAT_DRIVER_REJECT;\r\nelse if (lpfc_cmd->status >= IOSTAT_CNT)\r\nlpfc_cmd->status = IOSTAT_DEFAULT;\r\nif (lpfc_cmd->status == IOSTAT_FCP_RSP_ERROR &&\r\n!lpfc_cmd->fcp_rsp->rspStatus3 &&\r\n(lpfc_cmd->fcp_rsp->rspStatus2 & RESID_UNDER) &&\r\n!(vport->cfg_log_verbose & LOG_FCP_UNDER))\r\nlogit = 0;\r\nelse\r\nlogit = LOG_FCP | LOG_FCP_UNDER;\r\nlpfc_printf_vlog(vport, KERN_WARNING, logit,\r\n"9030 FCP cmd x%x failed <%d/%lld> "\r\n"status: x%x result: x%x "\r\n"sid: x%x did: x%x oxid: x%x "\r\n"Data: x%x x%x\n",\r\ncmd->cmnd[0],\r\ncmd->device ? cmd->device->id : 0xffff,\r\ncmd->device ? cmd->device->lun : 0xffff,\r\nlpfc_cmd->status, lpfc_cmd->result,\r\nvport->fc_myDID,\r\n(pnode) ? pnode->nlp_DID : 0,\r\nphba->sli_rev == LPFC_SLI_REV4 ?\r\nlpfc_cmd->cur_iocbq.sli4_xritag : 0xffff,\r\npIocbOut->iocb.ulpContext,\r\nlpfc_cmd->cur_iocbq.iocb.ulpIoTag);\r\nswitch (lpfc_cmd->status) {\r\ncase IOSTAT_FCP_RSP_ERROR:\r\nlpfc_handle_fcp_err(vport, lpfc_cmd, pIocbOut);\r\nbreak;\r\ncase IOSTAT_NPORT_BSY:\r\ncase IOSTAT_FABRIC_BSY:\r\ncmd->result = ScsiResult(DID_TRANSPORT_DISRUPTED, 0);\r\nfast_path_evt = lpfc_alloc_fast_evt(phba);\r\nif (!fast_path_evt)\r\nbreak;\r\nfast_path_evt->un.fabric_evt.event_type =\r\nFC_REG_FABRIC_EVENT;\r\nfast_path_evt->un.fabric_evt.subcategory =\r\n(lpfc_cmd->status == IOSTAT_NPORT_BSY) ?\r\nLPFC_EVENT_PORT_BUSY : LPFC_EVENT_FABRIC_BUSY;\r\nif (pnode && NLP_CHK_NODE_ACT(pnode)) {\r\nmemcpy(&fast_path_evt->un.fabric_evt.wwpn,\r\n&pnode->nlp_portname,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&fast_path_evt->un.fabric_evt.wwnn,\r\n&pnode->nlp_nodename,\r\nsizeof(struct lpfc_name));\r\n}\r\nfast_path_evt->vport = vport;\r\nfast_path_evt->work_evt.evt =\r\nLPFC_EVT_FASTPATH_MGMT_EVT;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nlist_add_tail(&fast_path_evt->work_evt.evt_listp,\r\n&phba->work_list);\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nlpfc_worker_wake_up(phba);\r\nbreak;\r\ncase IOSTAT_LOCAL_REJECT:\r\ncase IOSTAT_REMOTE_STOP:\r\nif (lpfc_cmd->result == IOERR_ELXSEC_KEY_UNWRAP_ERROR ||\r\nlpfc_cmd->result ==\r\nIOERR_ELXSEC_KEY_UNWRAP_COMPARE_ERROR ||\r\nlpfc_cmd->result == IOERR_ELXSEC_CRYPTO_ERROR ||\r\nlpfc_cmd->result ==\r\nIOERR_ELXSEC_CRYPTO_COMPARE_ERROR) {\r\ncmd->result = ScsiResult(DID_NO_CONNECT, 0);\r\nbreak;\r\n}\r\nif (lpfc_cmd->result == IOERR_INVALID_RPI ||\r\nlpfc_cmd->result == IOERR_NO_RESOURCES ||\r\nlpfc_cmd->result == IOERR_ABORT_REQUESTED ||\r\nlpfc_cmd->result == IOERR_SLER_CMD_RCV_FAILURE) {\r\ncmd->result = ScsiResult(DID_REQUEUE, 0);\r\nbreak;\r\n}\r\nif ((lpfc_cmd->result == IOERR_RX_DMA_FAILED ||\r\nlpfc_cmd->result == IOERR_TX_DMA_FAILED) &&\r\npIocbOut->iocb.unsli3.sli3_bg.bgstat) {\r\nif (scsi_get_prot_op(cmd) != SCSI_PROT_NORMAL) {\r\nlpfc_parse_bg_err(phba, lpfc_cmd,\r\npIocbOut);\r\nbreak;\r\n} else {\r\nlpfc_printf_vlog(vport, KERN_WARNING,\r\nLOG_BG,\r\n"9031 non-zero BGSTAT "\r\n"on unprotected cmd\n");\r\n}\r\n}\r\nif ((lpfc_cmd->status == IOSTAT_REMOTE_STOP)\r\n&& (phba->sli_rev == LPFC_SLI_REV4)\r\n&& (pnode && NLP_CHK_NODE_ACT(pnode))) {\r\nlpfc_set_rrq_active(phba, pnode,\r\nlpfc_cmd->cur_iocbq.sli4_lxritag,\r\n0, 0);\r\n}\r\ndefault:\r\ncmd->result = ScsiResult(DID_ERROR, 0);\r\nbreak;\r\n}\r\nif (!pnode || !NLP_CHK_NODE_ACT(pnode)\r\n|| (pnode->nlp_state != NLP_STE_MAPPED_NODE))\r\ncmd->result = ScsiResult(DID_TRANSPORT_DISRUPTED,\r\nSAM_STAT_BUSY);\r\n} else\r\ncmd->result = ScsiResult(DID_OK, 0);\r\nif (cmd->result || lpfc_cmd->fcp_rsp->rspSnsLen) {\r\nuint32_t *lp = (uint32_t *)cmd->sense_buffer;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0710 Iodone <%d/%llu> cmd %p, error "\r\n"x%x SNS x%x x%x Data: x%x x%x\n",\r\ncmd->device->id, cmd->device->lun, cmd,\r\ncmd->result, *lp, *(lp + 3), cmd->retries,\r\nscsi_get_resid(cmd));\r\n}\r\nlpfc_update_stats(phba, lpfc_cmd);\r\nif (vport->cfg_max_scsicmpl_time &&\r\ntime_after(jiffies, lpfc_cmd->start_time +\r\nmsecs_to_jiffies(vport->cfg_max_scsicmpl_time))) {\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (pnode && NLP_CHK_NODE_ACT(pnode)) {\r\nif (pnode->cmd_qdepth >\r\natomic_read(&pnode->cmd_pending) &&\r\n(atomic_read(&pnode->cmd_pending) >\r\nLPFC_MIN_TGT_QDEPTH) &&\r\n((cmd->cmnd[0] == READ_10) ||\r\n(cmd->cmnd[0] == WRITE_10)))\r\npnode->cmd_qdepth =\r\natomic_read(&pnode->cmd_pending);\r\npnode->last_change_time = jiffies;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n} else if (pnode && NLP_CHK_NODE_ACT(pnode)) {\r\nif ((pnode->cmd_qdepth < vport->cfg_tgt_queue_depth) &&\r\ntime_after(jiffies, pnode->last_change_time +\r\nmsecs_to_jiffies(LPFC_TGTQ_INTERVAL))) {\r\nspin_lock_irqsave(shost->host_lock, flags);\r\ndepth = pnode->cmd_qdepth * LPFC_TGTQ_RAMPUP_PCENT\r\n/ 100;\r\ndepth = depth ? depth : 1;\r\npnode->cmd_qdepth += depth;\r\nif (pnode->cmd_qdepth > vport->cfg_tgt_queue_depth)\r\npnode->cmd_qdepth = vport->cfg_tgt_queue_depth;\r\npnode->last_change_time = jiffies;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\n}\r\n}\r\nlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nlpfc_cmd->pCmd = NULL;\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\ncmd->scsi_done(cmd);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (lpfc_cmd->waitq)\r\nwake_up(lpfc_cmd->waitq);\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nlpfc_release_scsi_buf(phba, lpfc_cmd);\r\n}\r\nstatic void\r\nlpfc_fcpcmd_to_iocb(uint8_t *data, struct fcp_cmnd *fcp_cmnd)\r\n{\r\nint i, j;\r\nfor (i = 0, j = 0; i < sizeof(struct fcp_cmnd);\r\ni += sizeof(uint32_t), j++) {\r\n((uint32_t *)data)[j] = cpu_to_be32(((uint32_t *)fcp_cmnd)[j]);\r\n}\r\n}\r\nstatic void\r\nlpfc_scsi_prep_cmnd(struct lpfc_vport *vport, struct lpfc_scsi_buf *lpfc_cmd,\r\nstruct lpfc_nodelist *pnode)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct scsi_cmnd *scsi_cmnd = lpfc_cmd->pCmd;\r\nstruct fcp_cmnd *fcp_cmnd = lpfc_cmd->fcp_cmnd;\r\nIOCB_t *iocb_cmd = &lpfc_cmd->cur_iocbq.iocb;\r\nstruct lpfc_iocbq *piocbq = &(lpfc_cmd->cur_iocbq);\r\nint datadir = scsi_cmnd->sc_data_direction;\r\nuint8_t *ptr;\r\nbool sli4;\r\nuint32_t fcpdl;\r\nif (!pnode || !NLP_CHK_NODE_ACT(pnode))\r\nreturn;\r\nlpfc_cmd->fcp_rsp->rspSnsLen = 0;\r\nlpfc_cmd->fcp_cmnd->fcpCntl2 = 0;\r\nint_to_scsilun(lpfc_cmd->pCmd->device->lun,\r\n&lpfc_cmd->fcp_cmnd->fcp_lun);\r\nptr = &fcp_cmnd->fcpCdb[0];\r\nmemcpy(ptr, scsi_cmnd->cmnd, scsi_cmnd->cmd_len);\r\nif (scsi_cmnd->cmd_len < LPFC_FCP_CDB_LEN) {\r\nptr += scsi_cmnd->cmd_len;\r\nmemset(ptr, 0, (LPFC_FCP_CDB_LEN - scsi_cmnd->cmd_len));\r\n}\r\nfcp_cmnd->fcpCntl1 = SIMPLE_Q;\r\nsli4 = (phba->sli_rev == LPFC_SLI_REV4);\r\npiocbq->iocb.un.fcpi.fcpi_XRdy = 0;\r\nif (scsi_sg_count(scsi_cmnd)) {\r\nif (datadir == DMA_TO_DEVICE) {\r\niocb_cmd->ulpCommand = CMD_FCP_IWRITE64_CR;\r\niocb_cmd->ulpPU = PARM_READ_CHECK;\r\nif (vport->cfg_first_burst_size &&\r\n(pnode->nlp_flag & NLP_FIRSTBURST)) {\r\nfcpdl = scsi_bufflen(scsi_cmnd);\r\nif (fcpdl < vport->cfg_first_burst_size)\r\npiocbq->iocb.un.fcpi.fcpi_XRdy = fcpdl;\r\nelse\r\npiocbq->iocb.un.fcpi.fcpi_XRdy =\r\nvport->cfg_first_burst_size;\r\n}\r\nfcp_cmnd->fcpCntl3 = WRITE_DATA;\r\nphba->fc4ScsiOutputRequests++;\r\n} else {\r\niocb_cmd->ulpCommand = CMD_FCP_IREAD64_CR;\r\niocb_cmd->ulpPU = PARM_READ_CHECK;\r\nfcp_cmnd->fcpCntl3 = READ_DATA;\r\nphba->fc4ScsiInputRequests++;\r\n}\r\n} else {\r\niocb_cmd->ulpCommand = CMD_FCP_ICMND64_CR;\r\niocb_cmd->un.fcpi.fcpi_parm = 0;\r\niocb_cmd->ulpPU = 0;\r\nfcp_cmnd->fcpCntl3 = 0;\r\nphba->fc4ScsiControlRequests++;\r\n}\r\nif (phba->sli_rev == 3 &&\r\n!(phba->sli3_options & LPFC_SLI3_BG_ENABLED))\r\nlpfc_fcpcmd_to_iocb(iocb_cmd->unsli3.fcp_ext.icd, fcp_cmnd);\r\npiocbq->iocb.ulpContext = pnode->nlp_rpi;\r\nif (sli4)\r\npiocbq->iocb.ulpContext =\r\nphba->sli4_hba.rpi_ids[pnode->nlp_rpi];\r\nif (pnode->nlp_fcp_info & NLP_FCP_2_DEVICE)\r\npiocbq->iocb.ulpFCP2Rcvy = 1;\r\nelse\r\npiocbq->iocb.ulpFCP2Rcvy = 0;\r\npiocbq->iocb.ulpClass = (pnode->nlp_fcp_info & 0x0f);\r\npiocbq->context1 = lpfc_cmd;\r\npiocbq->iocb_cmpl = lpfc_scsi_cmd_iocb_cmpl;\r\npiocbq->iocb.ulpTimeout = lpfc_cmd->timeout;\r\npiocbq->vport = vport;\r\n}\r\nstatic int\r\nlpfc_scsi_prep_task_mgmt_cmd(struct lpfc_vport *vport,\r\nstruct lpfc_scsi_buf *lpfc_cmd,\r\nuint64_t lun,\r\nuint8_t task_mgmt_cmd)\r\n{\r\nstruct lpfc_iocbq *piocbq;\r\nIOCB_t *piocb;\r\nstruct fcp_cmnd *fcp_cmnd;\r\nstruct lpfc_rport_data *rdata = lpfc_cmd->rdata;\r\nstruct lpfc_nodelist *ndlp = rdata->pnode;\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp) ||\r\nndlp->nlp_state != NLP_STE_MAPPED_NODE)\r\nreturn 0;\r\npiocbq = &(lpfc_cmd->cur_iocbq);\r\npiocbq->vport = vport;\r\npiocb = &piocbq->iocb;\r\nfcp_cmnd = lpfc_cmd->fcp_cmnd;\r\nmemset(fcp_cmnd, 0, sizeof(struct fcp_cmnd));\r\nint_to_scsilun(lun, &fcp_cmnd->fcp_lun);\r\nfcp_cmnd->fcpCntl2 = task_mgmt_cmd;\r\nif (vport->phba->sli_rev == 3 &&\r\n!(vport->phba->sli3_options & LPFC_SLI3_BG_ENABLED))\r\nlpfc_fcpcmd_to_iocb(piocb->unsli3.fcp_ext.icd, fcp_cmnd);\r\npiocb->ulpCommand = CMD_FCP_ICMND64_CR;\r\npiocb->ulpContext = ndlp->nlp_rpi;\r\nif (vport->phba->sli_rev == LPFC_SLI_REV4) {\r\npiocb->ulpContext =\r\nvport->phba->sli4_hba.rpi_ids[ndlp->nlp_rpi];\r\n}\r\npiocb->ulpFCP2Rcvy = (ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE) ? 1 : 0;\r\npiocb->ulpClass = (ndlp->nlp_fcp_info & 0x0f);\r\npiocb->ulpPU = 0;\r\npiocb->un.fcpi.fcpi_parm = 0;\r\nif (lpfc_cmd->timeout > 0xff) {\r\npiocb->ulpTimeout = 0;\r\n} else\r\npiocb->ulpTimeout = lpfc_cmd->timeout;\r\nif (vport->phba->sli_rev == LPFC_SLI_REV4)\r\nlpfc_sli4_set_rsp_sgl_last(vport->phba, lpfc_cmd);\r\nreturn 1;\r\n}\r\nint\r\nlpfc_scsi_api_table_setup(struct lpfc_hba *phba, uint8_t dev_grp)\r\n{\r\nphba->lpfc_scsi_unprep_dma_buf = lpfc_scsi_unprep_dma_buf;\r\nphba->lpfc_scsi_prep_cmnd = lpfc_scsi_prep_cmnd;\r\nswitch (dev_grp) {\r\ncase LPFC_PCI_DEV_LP:\r\nphba->lpfc_new_scsi_buf = lpfc_new_scsi_buf_s3;\r\nphba->lpfc_scsi_prep_dma_buf = lpfc_scsi_prep_dma_buf_s3;\r\nphba->lpfc_bg_scsi_prep_dma_buf = lpfc_bg_scsi_prep_dma_buf_s3;\r\nphba->lpfc_release_scsi_buf = lpfc_release_scsi_buf_s3;\r\nphba->lpfc_get_scsi_buf = lpfc_get_scsi_buf_s3;\r\nbreak;\r\ncase LPFC_PCI_DEV_OC:\r\nphba->lpfc_new_scsi_buf = lpfc_new_scsi_buf_s4;\r\nphba->lpfc_scsi_prep_dma_buf = lpfc_scsi_prep_dma_buf_s4;\r\nphba->lpfc_bg_scsi_prep_dma_buf = lpfc_bg_scsi_prep_dma_buf_s4;\r\nphba->lpfc_release_scsi_buf = lpfc_release_scsi_buf_s4;\r\nphba->lpfc_get_scsi_buf = lpfc_get_scsi_buf_s4;\r\nbreak;\r\ndefault:\r\nlpfc_printf_log(phba, KERN_ERR, LOG_INIT,\r\n"1418 Invalid HBA PCI-device group: 0x%x\n",\r\ndev_grp);\r\nreturn -ENODEV;\r\nbreak;\r\n}\r\nphba->lpfc_rampdown_queue_depth = lpfc_rampdown_queue_depth;\r\nphba->lpfc_scsi_cmd_iocb_cmpl = lpfc_scsi_cmd_iocb_cmpl;\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_tskmgmt_def_cmpl(struct lpfc_hba *phba,\r\nstruct lpfc_iocbq *cmdiocbq,\r\nstruct lpfc_iocbq *rspiocbq)\r\n{\r\nstruct lpfc_scsi_buf *lpfc_cmd =\r\n(struct lpfc_scsi_buf *) cmdiocbq->context1;\r\nif (lpfc_cmd)\r\nlpfc_release_scsi_buf(phba, lpfc_cmd);\r\nreturn;\r\n}\r\nconst char *\r\nlpfc_info(struct Scsi_Host *host)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) host->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint len, link_speed = 0;\r\nstatic char lpfcinfobuf[384];\r\nmemset(lpfcinfobuf,0,384);\r\nif (phba && phba->pcidev){\r\nstrncpy(lpfcinfobuf, phba->ModelDesc, 256);\r\nlen = strlen(lpfcinfobuf);\r\nsnprintf(lpfcinfobuf + len,\r\n384-len,\r\n" on PCI bus %02x device %02x irq %d",\r\nphba->pcidev->bus->number,\r\nphba->pcidev->devfn,\r\nphba->pcidev->irq);\r\nlen = strlen(lpfcinfobuf);\r\nif (phba->Port[0]) {\r\nsnprintf(lpfcinfobuf + len,\r\n384-len,\r\n" port %s",\r\nphba->Port);\r\n}\r\nlen = strlen(lpfcinfobuf);\r\nlink_speed = lpfc_sli_port_speed_get(phba);\r\nif (link_speed != 0)\r\nsnprintf(lpfcinfobuf + len, 384-len,\r\n" Logical Link Speed: %d Mbps", link_speed);\r\n}\r\nreturn lpfcinfobuf;\r\n}\r\nstatic __inline__ void lpfc_poll_rearm_timer(struct lpfc_hba * phba)\r\n{\r\nunsigned long poll_tmo_expires =\r\n(jiffies + msecs_to_jiffies(phba->cfg_poll_tmo));\r\nif (!list_empty(&phba->sli.sli3_ring[LPFC_FCP_RING].txcmplq))\r\nmod_timer(&phba->fcp_poll_timer,\r\npoll_tmo_expires);\r\n}\r\nvoid lpfc_poll_start_timer(struct lpfc_hba * phba)\r\n{\r\nlpfc_poll_rearm_timer(phba);\r\n}\r\nvoid lpfc_poll_timeout(unsigned long ptr)\r\n{\r\nstruct lpfc_hba *phba = (struct lpfc_hba *) ptr;\r\nif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\r\nlpfc_sli_handle_fast_ring_event(phba,\r\n&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT)\r\nlpfc_poll_rearm_timer(phba);\r\n}\r\n}\r\nstatic int\r\nlpfc_queuecommand(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_rport_data *rdata;\r\nstruct lpfc_nodelist *ndlp;\r\nstruct lpfc_scsi_buf *lpfc_cmd;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\r\nint err;\r\nrdata = lpfc_rport_data_from_scsi_device(cmnd->device);\r\nerr = fc_remote_port_chkready(rport);\r\nif (err) {\r\ncmnd->result = err;\r\ngoto out_fail_command;\r\n}\r\nndlp = rdata->pnode;\r\nif ((scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) &&\r\n(!(phba->sli3_options & LPFC_SLI3_BG_ENABLED))) {\r\nlpfc_printf_log(phba, KERN_ERR, LOG_BG,\r\n"9058 BLKGRD: ERROR: rcvd protected cmd:%02x"\r\n" op:%02x str=%s without registering for"\r\n" BlockGuard - Rejecting command\n",\r\ncmnd->cmnd[0], scsi_get_prot_op(cmnd),\r\ndif_op_str[scsi_get_prot_op(cmnd)]);\r\ngoto out_fail_command;\r\n}\r\nif (!ndlp || !NLP_CHK_NODE_ACT(ndlp))\r\ngoto out_tgt_busy;\r\nif (atomic_read(&ndlp->cmd_pending) >= ndlp->cmd_qdepth)\r\ngoto out_tgt_busy;\r\nlpfc_cmd = lpfc_get_scsi_buf(phba, ndlp);\r\nif (lpfc_cmd == NULL) {\r\nlpfc_rampdown_queue_depth(phba);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP_ERROR,\r\n"0707 driver's buffer pool is empty, "\r\n"IO busied\n");\r\ngoto out_host_busy;\r\n}\r\nlpfc_cmd->pCmd = cmnd;\r\nlpfc_cmd->rdata = rdata;\r\nlpfc_cmd->timeout = 0;\r\nlpfc_cmd->start_time = jiffies;\r\ncmnd->host_scribble = (unsigned char *)lpfc_cmd;\r\nif (scsi_get_prot_op(cmnd) != SCSI_PROT_NORMAL) {\r\nif (vport->phba->cfg_enable_bg) {\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO, LOG_SCSI_CMD,\r\n"9033 BLKGRD: rcvd %s cmd:x%x "\r\n"sector x%llx cnt %u pt %x\n",\r\ndif_op_str[scsi_get_prot_op(cmnd)],\r\ncmnd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmnd),\r\nblk_rq_sectors(cmnd->request),\r\n(cmnd->cmnd[1]>>5));\r\n}\r\nerr = lpfc_bg_scsi_prep_dma_buf(phba, lpfc_cmd);\r\n} else {\r\nif (vport->phba->cfg_enable_bg) {\r\nlpfc_printf_vlog(vport,\r\nKERN_INFO, LOG_SCSI_CMD,\r\n"9038 BLKGRD: rcvd PROT_NORMAL cmd: "\r\n"x%x sector x%llx cnt %u pt %x\n",\r\ncmnd->cmnd[0],\r\n(unsigned long long)scsi_get_lba(cmnd),\r\nblk_rq_sectors(cmnd->request),\r\n(cmnd->cmnd[1]>>5));\r\n}\r\nerr = lpfc_scsi_prep_dma_buf(phba, lpfc_cmd);\r\n}\r\nif (err)\r\ngoto out_host_busy_free_buf;\r\nlpfc_scsi_prep_cmnd(vport, lpfc_cmd, ndlp);\r\natomic_inc(&ndlp->cmd_pending);\r\nerr = lpfc_sli_issue_iocb(phba, LPFC_FCP_RING,\r\n&lpfc_cmd->cur_iocbq, SLI_IOCB_RET_IOCB);\r\nif (err) {\r\natomic_dec(&ndlp->cmd_pending);\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"3376 FCP could not issue IOCB err %x"\r\n"FCP cmd x%x <%d/%llu> "\r\n"sid: x%x did: x%x oxid: x%x "\r\n"Data: x%x x%x x%x x%x\n",\r\nerr, cmnd->cmnd[0],\r\ncmnd->device ? cmnd->device->id : 0xffff,\r\ncmnd->device ? cmnd->device->lun : (u64) -1,\r\nvport->fc_myDID, ndlp->nlp_DID,\r\nphba->sli_rev == LPFC_SLI_REV4 ?\r\nlpfc_cmd->cur_iocbq.sli4_xritag : 0xffff,\r\nlpfc_cmd->cur_iocbq.iocb.ulpContext,\r\nlpfc_cmd->cur_iocbq.iocb.ulpIoTag,\r\nlpfc_cmd->cur_iocbq.iocb.ulpTimeout,\r\n(uint32_t)\r\n(cmnd->request->timeout / 1000));\r\ngoto out_host_busy_free_buf;\r\n}\r\nif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\r\nlpfc_sli_handle_fast_ring_event(phba,\r\n&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT)\r\nlpfc_poll_rearm_timer(phba);\r\n}\r\nreturn 0;\r\nout_host_busy_free_buf:\r\nlpfc_scsi_unprep_dma_buf(phba, lpfc_cmd);\r\nlpfc_release_scsi_buf(phba, lpfc_cmd);\r\nout_host_busy:\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nout_tgt_busy:\r\nreturn SCSI_MLQUEUE_TARGET_BUSY;\r\nout_fail_command:\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_abort_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_iocbq *iocb;\r\nstruct lpfc_iocbq *abtsiocb;\r\nstruct lpfc_scsi_buf *lpfc_cmd;\r\nIOCB_t *cmd, *icmd;\r\nint ret = SUCCESS, status = 0;\r\nstruct lpfc_sli_ring *pring_s4;\r\nint ret_val;\r\nunsigned long flags, iflags;\r\nDECLARE_WAIT_QUEUE_HEAD_ONSTACK(waitq);\r\nstatus = fc_block_scsi_eh(cmnd);\r\nif (status != 0 && status != SUCCESS)\r\nreturn status;\r\nspin_lock_irqsave(&phba->hbalock, flags);\r\nif (phba->hba_flag & HBA_FCP_IOQ_FLUSH) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"3168 SCSI Layer abort requested I/O has been "\r\n"flushed by LLD.\n");\r\nreturn FAILED;\r\n}\r\nlpfc_cmd = (struct lpfc_scsi_buf *)cmnd->host_scribble;\r\nif (!lpfc_cmd || !lpfc_cmd->pCmd) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"2873 SCSI Layer I/O Abort Request IO CMPL Status "\r\n"x%x ID %d LUN %llu\n",\r\nSUCCESS, cmnd->device->id, cmnd->device->lun);\r\nreturn SUCCESS;\r\n}\r\niocb = &lpfc_cmd->cur_iocbq;\r\nif (!(iocb->iocb_flag & LPFC_IO_ON_TXCMPLQ)) {\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"3169 SCSI Layer abort requested I/O has been "\r\n"cancelled by LLD.\n");\r\nreturn FAILED;\r\n}\r\nif (lpfc_cmd->pCmd != cmnd) {\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"3170 SCSI Layer abort requested I/O has been "\r\n"completed by LLD.\n");\r\ngoto out_unlock;\r\n}\r\nBUG_ON(iocb->context1 != lpfc_cmd);\r\nif (iocb->iocb_flag & LPFC_DRIVER_ABORTED) {\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"3389 SCSI Layer I/O Abort Request is pending\n");\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\ngoto wait_for_cmpl;\r\n}\r\nabtsiocb = __lpfc_sli_get_iocbq(phba);\r\nif (abtsiocb == NULL) {\r\nret = FAILED;\r\ngoto out_unlock;\r\n}\r\niocb->iocb_flag |= LPFC_DRIVER_ABORTED;\r\ncmd = &iocb->iocb;\r\nicmd = &abtsiocb->iocb;\r\nicmd->un.acxri.abortType = ABORT_TYPE_ABTS;\r\nicmd->un.acxri.abortContextTag = cmd->ulpContext;\r\nif (phba->sli_rev == LPFC_SLI_REV4)\r\nicmd->un.acxri.abortIoTag = iocb->sli4_xritag;\r\nelse\r\nicmd->un.acxri.abortIoTag = cmd->ulpIoTag;\r\nicmd->ulpLe = 1;\r\nicmd->ulpClass = cmd->ulpClass;\r\nabtsiocb->hba_wqidx = iocb->hba_wqidx;\r\nabtsiocb->iocb_flag |= LPFC_USE_FCPWQIDX;\r\nif (iocb->iocb_flag & LPFC_IO_FOF)\r\nabtsiocb->iocb_flag |= LPFC_IO_FOF;\r\nif (lpfc_is_link_up(phba))\r\nicmd->ulpCommand = CMD_ABORT_XRI_CN;\r\nelse\r\nicmd->ulpCommand = CMD_CLOSE_XRI_CN;\r\nabtsiocb->iocb_cmpl = lpfc_sli_abort_fcp_cmpl;\r\nabtsiocb->vport = vport;\r\nif (phba->sli_rev == LPFC_SLI_REV4) {\r\npring_s4 = lpfc_sli4_calc_ring(phba, iocb);\r\nif (pring_s4 == NULL) {\r\nret = FAILED;\r\ngoto out_unlock;\r\n}\r\nspin_lock_irqsave(&pring_s4->ring_lock, iflags);\r\nret_val = __lpfc_sli_issue_iocb(phba, pring_s4->ringno,\r\nabtsiocb, 0);\r\nspin_unlock_irqrestore(&pring_s4->ring_lock, iflags);\r\n} else {\r\nret_val = __lpfc_sli_issue_iocb(phba, LPFC_FCP_RING,\r\nabtsiocb, 0);\r\n}\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nif (ret_val == IOCB_ERROR) {\r\nlpfc_sli_release_iocbq(phba, abtsiocb);\r\nret = FAILED;\r\ngoto out;\r\n}\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT)\r\nlpfc_sli_handle_fast_ring_event(phba,\r\n&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\r\nwait_for_cmpl:\r\nlpfc_cmd->waitq = &waitq;\r\nwait_event_timeout(waitq,\r\n(lpfc_cmd->pCmd != cmnd),\r\nmsecs_to_jiffies(2*vport->cfg_devloss_tmo*1000));\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nlpfc_cmd->waitq = NULL;\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nif (lpfc_cmd->pCmd == cmnd) {\r\nret = FAILED;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0748 abort handler timed out waiting "\r\n"for aborting I/O (xri:x%x) to complete: "\r\n"ret %#x, ID %d, LUN %llu\n",\r\niocb->sli4_xritag, ret,\r\ncmnd->device->id, cmnd->device->lun);\r\n}\r\ngoto out;\r\nout_unlock:\r\nspin_unlock_irqrestore(&phba->hbalock, flags);\r\nout:\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"0749 SCSI Layer I/O Abort Request Status x%x ID %d "\r\n"LUN %llu\n", ret, cmnd->device->id,\r\ncmnd->device->lun);\r\nreturn ret;\r\n}\r\nstatic char *\r\nlpfc_taskmgmt_name(uint8_t task_mgmt_cmd)\r\n{\r\nswitch (task_mgmt_cmd) {\r\ncase FCP_ABORT_TASK_SET:\r\nreturn "ABORT_TASK_SET";\r\ncase FCP_CLEAR_TASK_SET:\r\nreturn "FCP_CLEAR_TASK_SET";\r\ncase FCP_BUS_RESET:\r\nreturn "FCP_BUS_RESET";\r\ncase FCP_LUN_RESET:\r\nreturn "FCP_LUN_RESET";\r\ncase FCP_TARGET_RESET:\r\nreturn "FCP_TARGET_RESET";\r\ncase FCP_CLEAR_ACA:\r\nreturn "FCP_CLEAR_ACA";\r\ncase FCP_TERMINATE_TASK:\r\nreturn "FCP_TERMINATE_TASK";\r\ndefault:\r\nreturn "unknown";\r\n}\r\n}\r\nstatic int\r\nlpfc_check_fcp_rsp(struct lpfc_vport *vport, struct lpfc_scsi_buf *lpfc_cmd)\r\n{\r\nstruct fcp_rsp *fcprsp = lpfc_cmd->fcp_rsp;\r\nuint32_t rsp_info;\r\nuint32_t rsp_len;\r\nuint8_t rsp_info_code;\r\nint ret = FAILED;\r\nif (fcprsp == NULL)\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0703 fcp_rsp is missing\n");\r\nelse {\r\nrsp_info = fcprsp->rspStatus2;\r\nrsp_len = be32_to_cpu(fcprsp->rspRspLen);\r\nrsp_info_code = fcprsp->rspInfo3;\r\nlpfc_printf_vlog(vport, KERN_INFO,\r\nLOG_FCP,\r\n"0706 fcp_rsp valid 0x%x,"\r\n" rsp len=%d code 0x%x\n",\r\nrsp_info,\r\nrsp_len, rsp_info_code);\r\nif ((fcprsp->rspStatus2&RSP_LEN_VALID) && (rsp_len == 8)) {\r\nswitch (rsp_info_code) {\r\ncase RSP_NO_FAILURE:\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0715 Task Mgmt No Failure\n");\r\nret = SUCCESS;\r\nbreak;\r\ncase RSP_TM_NOT_SUPPORTED:\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0716 Task Mgmt Target "\r\n"reject\n");\r\nbreak;\r\ncase RSP_TM_NOT_COMPLETED:\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0717 Task Mgmt Target "\r\n"failed TM\n");\r\nbreak;\r\ncase RSP_TM_INVALID_LU:\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0718 Task Mgmt to invalid "\r\n"LUN\n");\r\nbreak;\r\n}\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_send_taskmgmt(struct lpfc_vport *vport, struct scsi_cmnd *cmnd,\r\nunsigned int tgt_id, uint64_t lun_id,\r\nuint8_t task_mgmt_cmd)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct lpfc_scsi_buf *lpfc_cmd;\r\nstruct lpfc_iocbq *iocbq;\r\nstruct lpfc_iocbq *iocbqrsp;\r\nstruct lpfc_rport_data *rdata;\r\nstruct lpfc_nodelist *pnode;\r\nint ret;\r\nint status;\r\nrdata = lpfc_rport_data_from_scsi_device(cmnd->device);\r\nif (!rdata || !rdata->pnode || !NLP_CHK_NODE_ACT(rdata->pnode))\r\nreturn FAILED;\r\npnode = rdata->pnode;\r\nlpfc_cmd = lpfc_get_scsi_buf(phba, pnode);\r\nif (lpfc_cmd == NULL)\r\nreturn FAILED;\r\nlpfc_cmd->timeout = phba->cfg_task_mgmt_tmo;\r\nlpfc_cmd->rdata = rdata;\r\nlpfc_cmd->pCmd = cmnd;\r\nstatus = lpfc_scsi_prep_task_mgmt_cmd(vport, lpfc_cmd, lun_id,\r\ntask_mgmt_cmd);\r\nif (!status) {\r\nlpfc_release_scsi_buf(phba, lpfc_cmd);\r\nreturn FAILED;\r\n}\r\niocbq = &lpfc_cmd->cur_iocbq;\r\niocbqrsp = lpfc_sli_get_iocbq(phba);\r\nif (iocbqrsp == NULL) {\r\nlpfc_release_scsi_buf(phba, lpfc_cmd);\r\nreturn FAILED;\r\n}\r\niocbq->iocb_cmpl = lpfc_tskmgmt_def_cmpl;\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0702 Issue %s to TGT %d LUN %llu "\r\n"rpi x%x nlp_flag x%x Data: x%x x%x\n",\r\nlpfc_taskmgmt_name(task_mgmt_cmd), tgt_id, lun_id,\r\npnode->nlp_rpi, pnode->nlp_flag, iocbq->sli4_xritag,\r\niocbq->iocb_flag);\r\nstatus = lpfc_sli_issue_iocb_wait(phba, LPFC_FCP_RING,\r\niocbq, iocbqrsp, lpfc_cmd->timeout);\r\nif ((status != IOCB_SUCCESS) ||\r\n(iocbqrsp->iocb.ulpStatus != IOSTAT_SUCCESS)) {\r\nif (status != IOCB_SUCCESS ||\r\niocbqrsp->iocb.ulpStatus != IOSTAT_FCP_RSP_ERROR)\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0727 TMF %s to TGT %d LUN %llu "\r\n"failed (%d, %d) iocb_flag x%x\n",\r\nlpfc_taskmgmt_name(task_mgmt_cmd),\r\ntgt_id, lun_id,\r\niocbqrsp->iocb.ulpStatus,\r\niocbqrsp->iocb.un.ulpWord[4],\r\niocbq->iocb_flag);\r\nif (status == IOCB_SUCCESS) {\r\nif (iocbqrsp->iocb.ulpStatus == IOSTAT_FCP_RSP_ERROR)\r\nret = lpfc_check_fcp_rsp(vport, lpfc_cmd);\r\nelse\r\nret = FAILED;\r\n} else if (status == IOCB_TIMEDOUT) {\r\nret = TIMEOUT_ERROR;\r\n} else {\r\nret = FAILED;\r\n}\r\n} else\r\nret = SUCCESS;\r\nlpfc_sli_release_iocbq(phba, iocbqrsp);\r\nif (ret != TIMEOUT_ERROR)\r\nlpfc_release_scsi_buf(phba, lpfc_cmd);\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_chk_tgt_mapped(struct lpfc_vport *vport, struct scsi_cmnd *cmnd)\r\n{\r\nstruct lpfc_rport_data *rdata;\r\nstruct lpfc_nodelist *pnode;\r\nunsigned long later;\r\nrdata = lpfc_rport_data_from_scsi_device(cmnd->device);\r\nif (!rdata) {\r\nlpfc_printf_vlog(vport, KERN_INFO, LOG_FCP,\r\n"0797 Tgt Map rport failure: rdata x%p\n", rdata);\r\nreturn FAILED;\r\n}\r\npnode = rdata->pnode;\r\nlater = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;\r\nwhile (time_after(later, jiffies)) {\r\nif (!pnode || !NLP_CHK_NODE_ACT(pnode))\r\nreturn FAILED;\r\nif (pnode->nlp_state == NLP_STE_MAPPED_NODE)\r\nreturn SUCCESS;\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(500));\r\nrdata = lpfc_rport_data_from_scsi_device(cmnd->device);\r\nif (!rdata)\r\nreturn FAILED;\r\npnode = rdata->pnode;\r\n}\r\nif (!pnode || !NLP_CHK_NODE_ACT(pnode) ||\r\n(pnode->nlp_state != NLP_STE_MAPPED_NODE))\r\nreturn FAILED;\r\nreturn SUCCESS;\r\n}\r\nstatic int\r\nlpfc_reset_flush_io_context(struct lpfc_vport *vport, uint16_t tgt_id,\r\nuint64_t lun_id, lpfc_ctx_cmd context)\r\n{\r\nstruct lpfc_hba *phba = vport->phba;\r\nunsigned long later;\r\nint cnt;\r\ncnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);\r\nif (cnt)\r\nlpfc_sli_abort_taskmgmt(vport,\r\n&phba->sli.sli3_ring[LPFC_FCP_RING],\r\ntgt_id, lun_id, context);\r\nlater = msecs_to_jiffies(2 * vport->cfg_devloss_tmo * 1000) + jiffies;\r\nwhile (time_after(later, jiffies) && cnt) {\r\nschedule_timeout_uninterruptible(msecs_to_jiffies(20));\r\ncnt = lpfc_sli_sum_iocb(vport, tgt_id, lun_id, context);\r\n}\r\nif (cnt) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0724 I/O flush failure for context %s : cnt x%x\n",\r\n((context == LPFC_CTX_LUN) ? "LUN" :\r\n((context == LPFC_CTX_TGT) ? "TGT" :\r\n((context == LPFC_CTX_HOST) ? "HOST" : "Unknown"))),\r\ncnt);\r\nreturn FAILED;\r\n}\r\nreturn SUCCESS;\r\n}\r\nstatic int\r\nlpfc_device_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_rport_data *rdata;\r\nstruct lpfc_nodelist *pnode;\r\nunsigned tgt_id = cmnd->device->id;\r\nuint64_t lun_id = cmnd->device->lun;\r\nstruct lpfc_scsi_event_header scsi_event;\r\nint status;\r\nrdata = lpfc_rport_data_from_scsi_device(cmnd->device);\r\nif (!rdata || !rdata->pnode) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0798 Device Reset rport failure: rdata x%p\n",\r\nrdata);\r\nreturn FAILED;\r\n}\r\npnode = rdata->pnode;\r\nstatus = fc_block_scsi_eh(cmnd);\r\nif (status != 0 && status != SUCCESS)\r\nreturn status;\r\nstatus = lpfc_chk_tgt_mapped(vport, cmnd);\r\nif (status == FAILED) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0721 Device Reset rport failure: rdata x%p\n", rdata);\r\nreturn FAILED;\r\n}\r\nscsi_event.event_type = FC_REG_SCSI_EVENT;\r\nscsi_event.subcategory = LPFC_EVENT_LUNRESET;\r\nscsi_event.lun = lun_id;\r\nmemcpy(scsi_event.wwpn, &pnode->nlp_portname, sizeof(struct lpfc_name));\r\nmemcpy(scsi_event.wwnn, &pnode->nlp_nodename, sizeof(struct lpfc_name));\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\r\nstatus = lpfc_send_taskmgmt(vport, cmnd, tgt_id, lun_id,\r\nFCP_LUN_RESET);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0713 SCSI layer issued Device Reset (%d, %llu) "\r\n"return x%x\n", tgt_id, lun_id, status);\r\nif (status == SUCCESS)\r\nstatus = lpfc_reset_flush_io_context(vport, tgt_id, lun_id,\r\nLPFC_CTX_LUN);\r\nreturn status;\r\n}\r\nstatic int\r\nlpfc_target_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_rport_data *rdata;\r\nstruct lpfc_nodelist *pnode;\r\nunsigned tgt_id = cmnd->device->id;\r\nuint64_t lun_id = cmnd->device->lun;\r\nstruct lpfc_scsi_event_header scsi_event;\r\nint status;\r\nrdata = lpfc_rport_data_from_scsi_device(cmnd->device);\r\nif (!rdata) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0799 Target Reset rport failure: rdata x%p\n", rdata);\r\nreturn FAILED;\r\n}\r\npnode = rdata->pnode;\r\nstatus = fc_block_scsi_eh(cmnd);\r\nif (status != 0 && status != SUCCESS)\r\nreturn status;\r\nstatus = lpfc_chk_tgt_mapped(vport, cmnd);\r\nif (status == FAILED) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0722 Target Reset rport failure: rdata x%p\n", rdata);\r\nif (pnode) {\r\nspin_lock_irq(shost->host_lock);\r\npnode->nlp_flag &= ~NLP_NPR_ADISC;\r\npnode->nlp_fcp_info &= ~NLP_FCP_2_DEVICE;\r\nspin_unlock_irq(shost->host_lock);\r\n}\r\nlpfc_reset_flush_io_context(vport, tgt_id, lun_id,\r\nLPFC_CTX_TGT);\r\nreturn FAST_IO_FAIL;\r\n}\r\nscsi_event.event_type = FC_REG_SCSI_EVENT;\r\nscsi_event.subcategory = LPFC_EVENT_TGTRESET;\r\nscsi_event.lun = 0;\r\nmemcpy(scsi_event.wwpn, &pnode->nlp_portname, sizeof(struct lpfc_name));\r\nmemcpy(scsi_event.wwnn, &pnode->nlp_nodename, sizeof(struct lpfc_name));\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\r\nstatus = lpfc_send_taskmgmt(vport, cmnd, tgt_id, lun_id,\r\nFCP_TARGET_RESET);\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0723 SCSI layer issued Target Reset (%d, %llu) "\r\n"return x%x\n", tgt_id, lun_id, status);\r\nif (status == SUCCESS)\r\nstatus = lpfc_reset_flush_io_context(vport, tgt_id, lun_id,\r\nLPFC_CTX_TGT);\r\nreturn status;\r\n}\r\nstatic int\r\nlpfc_bus_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_nodelist *ndlp = NULL;\r\nstruct lpfc_scsi_event_header scsi_event;\r\nint match;\r\nint ret = SUCCESS, status, i;\r\nscsi_event.event_type = FC_REG_SCSI_EVENT;\r\nscsi_event.subcategory = LPFC_EVENT_BUSRESET;\r\nscsi_event.lun = 0;\r\nmemcpy(scsi_event.wwpn, &vport->fc_portname, sizeof(struct lpfc_name));\r\nmemcpy(scsi_event.wwnn, &vport->fc_nodename, sizeof(struct lpfc_name));\r\nfc_host_post_vendor_event(shost, fc_get_event_number(),\r\nsizeof(scsi_event), (char *)&scsi_event, LPFC_NL_VENDOR_ID);\r\nstatus = fc_block_scsi_eh(cmnd);\r\nif (status != 0 && status != SUCCESS)\r\nreturn status;\r\nfor (i = 0; i < LPFC_MAX_TARGET; i++) {\r\nmatch = 0;\r\nspin_lock_irq(shost->host_lock);\r\nlist_for_each_entry(ndlp, &vport->fc_nodes, nlp_listp) {\r\nif (!NLP_CHK_NODE_ACT(ndlp))\r\ncontinue;\r\nif (vport->phba->cfg_fcp2_no_tgt_reset &&\r\n(ndlp->nlp_fcp_info & NLP_FCP_2_DEVICE))\r\ncontinue;\r\nif (ndlp->nlp_state == NLP_STE_MAPPED_NODE &&\r\nndlp->nlp_sid == i &&\r\nndlp->rport &&\r\nndlp->nlp_type & NLP_FCP_TARGET) {\r\nmatch = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irq(shost->host_lock);\r\nif (!match)\r\ncontinue;\r\nstatus = lpfc_send_taskmgmt(vport, cmnd,\r\ni, 0, FCP_TARGET_RESET);\r\nif (status != SUCCESS) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0700 Bus Reset on target %d failed\n",\r\ni);\r\nret = FAILED;\r\n}\r\n}\r\nstatus = lpfc_reset_flush_io_context(vport, 0, 0, LPFC_CTX_HOST);\r\nif (status != SUCCESS)\r\nret = FAILED;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0714 SCSI layer issued Bus Reset Data: x%x\n", ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_host_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct Scsi_Host *shost = cmnd->device->host;\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) shost->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nint rc, ret = SUCCESS;\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"3172 SCSI layer issued Host Reset Data:\n");\r\nlpfc_offline_prep(phba, LPFC_MBX_WAIT);\r\nlpfc_offline(phba);\r\nrc = lpfc_sli_brdrestart(phba);\r\nif (rc)\r\nret = FAILED;\r\nrc = lpfc_online(phba);\r\nif (rc)\r\nret = FAILED;\r\nlpfc_unblock_mgmt_io(phba);\r\nif (ret == FAILED) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"3323 Failed host reset, bring it offline\n");\r\nlpfc_sli4_offline_eratt(phba);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\nlpfc_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nuint32_t total = 0;\r\nuint32_t num_to_alloc = 0;\r\nint num_allocated = 0;\r\nuint32_t sdev_cnt;\r\nstruct lpfc_device_data *device_data;\r\nunsigned long flags;\r\nstruct lpfc_name target_wwpn;\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nif (phba->cfg_fof) {\r\nu64_to_wwn(rport->port_name, target_wwpn.u.wwn);\r\nspin_lock_irqsave(&phba->devicelock, flags);\r\ndevice_data = __lpfc_get_device_data(phba,\r\n&phba->luns,\r\n&vport->fc_portname,\r\n&target_wwpn,\r\nsdev->lun);\r\nif (!device_data) {\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\ndevice_data = lpfc_create_device_data(phba,\r\n&vport->fc_portname,\r\n&target_wwpn,\r\nsdev->lun,\r\nphba->cfg_XLanePriority,\r\ntrue);\r\nif (!device_data)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&phba->devicelock, flags);\r\nlist_add_tail(&device_data->listentry, &phba->luns);\r\n}\r\ndevice_data->rport_data = rport->dd_data;\r\ndevice_data->available = true;\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nsdev->hostdata = device_data;\r\n} else {\r\nsdev->hostdata = rport->dd_data;\r\n}\r\nsdev_cnt = atomic_inc_return(&phba->sdev_cnt);\r\ntotal = phba->total_scsi_bufs;\r\nnum_to_alloc = vport->cfg_lun_queue_depth + 2;\r\nif ((sdev_cnt * (vport->cfg_lun_queue_depth + 2)) < total)\r\nreturn 0;\r\nif (total >= phba->cfg_hba_queue_depth - LPFC_DISC_IOCB_BUFF_COUNT ) {\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"0704 At limitation of %d preallocated "\r\n"command buffers\n", total);\r\nreturn 0;\r\n} else if (total + num_to_alloc >\r\nphba->cfg_hba_queue_depth - LPFC_DISC_IOCB_BUFF_COUNT ) {\r\nlpfc_printf_vlog(vport, KERN_WARNING, LOG_FCP,\r\n"0705 Allocation request of %d "\r\n"command buffers will exceed max of %d. "\r\n"Reducing allocation request to %d.\n",\r\nnum_to_alloc, phba->cfg_hba_queue_depth,\r\n(phba->cfg_hba_queue_depth - total));\r\nnum_to_alloc = phba->cfg_hba_queue_depth - total;\r\n}\r\nnum_allocated = lpfc_new_scsi_buf(vport, num_to_alloc);\r\nif (num_to_alloc != num_allocated) {\r\nlpfc_printf_vlog(vport, KERN_ERR, LOG_FCP,\r\n"0708 Allocation request of %d "\r\n"command buffers did not succeed. "\r\n"Allocated %d buffers.\n",\r\nnum_to_alloc, num_allocated);\r\n}\r\nif (num_allocated > 0)\r\nphba->total_scsi_bufs += num_allocated;\r\nreturn 0;\r\n}\r\nstatic int\r\nlpfc_slave_configure(struct scsi_device *sdev)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nscsi_change_queue_depth(sdev, vport->cfg_lun_queue_depth);\r\nif (phba->cfg_poll & ENABLE_FCP_RING_POLLING) {\r\nlpfc_sli_handle_fast_ring_event(phba,\r\n&phba->sli.sli3_ring[LPFC_FCP_RING], HA_R0RE_REQ);\r\nif (phba->cfg_poll & DISABLE_FCP_RING_INT)\r\nlpfc_poll_rearm_timer(phba);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nlpfc_slave_destroy(struct scsi_device *sdev)\r\n{\r\nstruct lpfc_vport *vport = (struct lpfc_vport *) sdev->host->hostdata;\r\nstruct lpfc_hba *phba = vport->phba;\r\nunsigned long flags;\r\nstruct lpfc_device_data *device_data = sdev->hostdata;\r\natomic_dec(&phba->sdev_cnt);\r\nif ((phba->cfg_fof) && (device_data)) {\r\nspin_lock_irqsave(&phba->devicelock, flags);\r\ndevice_data->available = false;\r\nif (!device_data->oas_enabled)\r\nlpfc_delete_device_data(phba, device_data);\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\n}\r\nsdev->hostdata = NULL;\r\nreturn;\r\n}\r\nstruct lpfc_device_data*\r\nlpfc_create_device_data(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\r\nstruct lpfc_name *target_wwpn, uint64_t lun,\r\nuint32_t pri, bool atomic_create)\r\n{\r\nstruct lpfc_device_data *lun_info;\r\nint memory_flags;\r\nif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\r\n!(phba->cfg_fof))\r\nreturn NULL;\r\nif (atomic_create)\r\nmemory_flags = GFP_ATOMIC;\r\nelse\r\nmemory_flags = GFP_KERNEL;\r\nlun_info = mempool_alloc(phba->device_data_mem_pool, memory_flags);\r\nif (!lun_info)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&lun_info->listentry);\r\nlun_info->rport_data = NULL;\r\nmemcpy(&lun_info->device_id.vport_wwpn, vport_wwpn,\r\nsizeof(struct lpfc_name));\r\nmemcpy(&lun_info->device_id.target_wwpn, target_wwpn,\r\nsizeof(struct lpfc_name));\r\nlun_info->device_id.lun = lun;\r\nlun_info->oas_enabled = false;\r\nlun_info->priority = pri;\r\nlun_info->available = false;\r\nreturn lun_info;\r\n}\r\nvoid\r\nlpfc_delete_device_data(struct lpfc_hba *phba,\r\nstruct lpfc_device_data *lun_info)\r\n{\r\nif (unlikely(!phba) || !lun_info ||\r\n!(phba->cfg_fof))\r\nreturn;\r\nif (!list_empty(&lun_info->listentry))\r\nlist_del(&lun_info->listentry);\r\nmempool_free(lun_info, phba->device_data_mem_pool);\r\nreturn;\r\n}\r\nstruct lpfc_device_data*\r\n__lpfc_get_device_data(struct lpfc_hba *phba, struct list_head *list,\r\nstruct lpfc_name *vport_wwpn,\r\nstruct lpfc_name *target_wwpn, uint64_t lun)\r\n{\r\nstruct lpfc_device_data *lun_info;\r\nif (unlikely(!phba) || !list || !vport_wwpn || !target_wwpn ||\r\n!phba->cfg_fof)\r\nreturn NULL;\r\nlist_for_each_entry(lun_info, list, listentry) {\r\nif ((memcmp(&lun_info->device_id.vport_wwpn, vport_wwpn,\r\nsizeof(struct lpfc_name)) == 0) &&\r\n(memcmp(&lun_info->device_id.target_wwpn, target_wwpn,\r\nsizeof(struct lpfc_name)) == 0) &&\r\n(lun_info->device_id.lun == lun))\r\nreturn lun_info;\r\n}\r\nreturn NULL;\r\n}\r\nbool\r\nlpfc_find_next_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\r\nstruct lpfc_name *target_wwpn, uint64_t *starting_lun,\r\nstruct lpfc_name *found_vport_wwpn,\r\nstruct lpfc_name *found_target_wwpn,\r\nuint64_t *found_lun,\r\nuint32_t *found_lun_status,\r\nuint32_t *found_lun_pri)\r\n{\r\nunsigned long flags;\r\nstruct lpfc_device_data *lun_info;\r\nstruct lpfc_device_id *device_id;\r\nuint64_t lun;\r\nbool found = false;\r\nif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\r\n!starting_lun || !found_vport_wwpn ||\r\n!found_target_wwpn || !found_lun || !found_lun_status ||\r\n(*starting_lun == NO_MORE_OAS_LUN) ||\r\n!phba->cfg_fof)\r\nreturn false;\r\nlun = *starting_lun;\r\n*found_lun = NO_MORE_OAS_LUN;\r\n*starting_lun = NO_MORE_OAS_LUN;\r\nspin_lock_irqsave(&phba->devicelock, flags);\r\nlist_for_each_entry(lun_info, &phba->luns, listentry) {\r\nif (((wwn_to_u64(vport_wwpn->u.wwn) == 0) ||\r\n(memcmp(&lun_info->device_id.vport_wwpn, vport_wwpn,\r\nsizeof(struct lpfc_name)) == 0)) &&\r\n((wwn_to_u64(target_wwpn->u.wwn) == 0) ||\r\n(memcmp(&lun_info->device_id.target_wwpn, target_wwpn,\r\nsizeof(struct lpfc_name)) == 0)) &&\r\n(lun_info->oas_enabled)) {\r\ndevice_id = &lun_info->device_id;\r\nif ((!found) &&\r\n((lun == FIND_FIRST_OAS_LUN) ||\r\n(device_id->lun == lun))) {\r\n*found_lun = device_id->lun;\r\nmemcpy(found_vport_wwpn,\r\n&device_id->vport_wwpn,\r\nsizeof(struct lpfc_name));\r\nmemcpy(found_target_wwpn,\r\n&device_id->target_wwpn,\r\nsizeof(struct lpfc_name));\r\nif (lun_info->available)\r\n*found_lun_status =\r\nOAS_LUN_STATUS_EXISTS;\r\nelse\r\n*found_lun_status = 0;\r\n*found_lun_pri = lun_info->priority;\r\nif (phba->cfg_oas_flags & OAS_FIND_ANY_VPORT)\r\nmemset(vport_wwpn, 0x0,\r\nsizeof(struct lpfc_name));\r\nif (phba->cfg_oas_flags & OAS_FIND_ANY_TARGET)\r\nmemset(target_wwpn, 0x0,\r\nsizeof(struct lpfc_name));\r\nfound = true;\r\n} else if (found) {\r\n*starting_lun = device_id->lun;\r\nmemcpy(vport_wwpn, &device_id->vport_wwpn,\r\nsizeof(struct lpfc_name));\r\nmemcpy(target_wwpn, &device_id->target_wwpn,\r\nsizeof(struct lpfc_name));\r\nbreak;\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nreturn found;\r\n}\r\nbool\r\nlpfc_enable_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\r\nstruct lpfc_name *target_wwpn, uint64_t lun, uint8_t pri)\r\n{\r\nstruct lpfc_device_data *lun_info;\r\nunsigned long flags;\r\nif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\r\n!phba->cfg_fof)\r\nreturn false;\r\nspin_lock_irqsave(&phba->devicelock, flags);\r\nlun_info = __lpfc_get_device_data(phba, &phba->luns, vport_wwpn,\r\ntarget_wwpn, lun);\r\nif (lun_info) {\r\nif (!lun_info->oas_enabled)\r\nlun_info->oas_enabled = true;\r\nlun_info->priority = pri;\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nreturn true;\r\n}\r\nlun_info = lpfc_create_device_data(phba, vport_wwpn, target_wwpn, lun,\r\npri, false);\r\nif (lun_info) {\r\nlun_info->oas_enabled = true;\r\nlun_info->priority = pri;\r\nlun_info->available = false;\r\nlist_add_tail(&lun_info->listentry, &phba->luns);\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nreturn true;\r\n}\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nreturn false;\r\n}\r\nbool\r\nlpfc_disable_oas_lun(struct lpfc_hba *phba, struct lpfc_name *vport_wwpn,\r\nstruct lpfc_name *target_wwpn, uint64_t lun, uint8_t pri)\r\n{\r\nstruct lpfc_device_data *lun_info;\r\nunsigned long flags;\r\nif (unlikely(!phba) || !vport_wwpn || !target_wwpn ||\r\n!phba->cfg_fof)\r\nreturn false;\r\nspin_lock_irqsave(&phba->devicelock, flags);\r\nlun_info = __lpfc_get_device_data(phba,\r\n&phba->luns, vport_wwpn,\r\ntarget_wwpn, lun);\r\nif (lun_info) {\r\nlun_info->oas_enabled = false;\r\nlun_info->priority = pri;\r\nif (!lun_info->available)\r\nlpfc_delete_device_data(phba, lun_info);\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nreturn true;\r\n}\r\nspin_unlock_irqrestore(&phba->devicelock, flags);\r\nreturn false;\r\n}\r\nstatic int\r\nlpfc_no_command(struct Scsi_Host *shost, struct scsi_cmnd *cmnd)\r\n{\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\n}\r\nstatic int\r\nlpfc_no_handler(struct scsi_cmnd *cmnd)\r\n{\r\nreturn FAILED;\r\n}\r\nstatic int\r\nlpfc_no_slave(struct scsi_device *sdev)\r\n{\r\nreturn -ENODEV;\r\n}
