static unsigned long get_level(struct cpufreq_cooling_device *cpufreq_dev,\r\nunsigned int freq)\r\n{\r\nunsigned long level;\r\nfor (level = 0; level <= cpufreq_dev->max_level; level++) {\r\nif (freq == cpufreq_dev->freq_table[level])\r\nreturn level;\r\nif (freq > cpufreq_dev->freq_table[level])\r\nbreak;\r\n}\r\nreturn THERMAL_CSTATE_INVALID;\r\n}\r\nunsigned long cpufreq_cooling_get_level(unsigned int cpu, unsigned int freq)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nmutex_lock(&cooling_list_lock);\r\nlist_for_each_entry(cpufreq_dev, &cpufreq_dev_list, node) {\r\nif (cpumask_test_cpu(cpu, &cpufreq_dev->allowed_cpus)) {\r\nmutex_unlock(&cooling_list_lock);\r\nreturn get_level(cpufreq_dev, freq);\r\n}\r\n}\r\nmutex_unlock(&cooling_list_lock);\r\npr_err("%s: cpu:%d not part of any cooling device\n", __func__, cpu);\r\nreturn THERMAL_CSTATE_INVALID;\r\n}\r\nstatic int cpufreq_thermal_notifier(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct cpufreq_policy *policy = data;\r\nunsigned long clipped_freq;\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nif (event != CPUFREQ_ADJUST)\r\nreturn NOTIFY_DONE;\r\nmutex_lock(&cooling_list_lock);\r\nlist_for_each_entry(cpufreq_dev, &cpufreq_dev_list, node) {\r\nif (!cpumask_test_cpu(policy->cpu, &cpufreq_dev->allowed_cpus))\r\ncontinue;\r\nclipped_freq = cpufreq_dev->clipped_freq;\r\nif (policy->max > clipped_freq)\r\ncpufreq_verify_within_limits(policy, 0, clipped_freq);\r\nbreak;\r\n}\r\nmutex_unlock(&cooling_list_lock);\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int build_dyn_power_table(struct cpufreq_cooling_device *cpufreq_device,\r\nu32 capacitance)\r\n{\r\nstruct power_table *power_table;\r\nstruct dev_pm_opp *opp;\r\nstruct device *dev = NULL;\r\nint num_opps = 0, cpu, i, ret = 0;\r\nunsigned long freq;\r\nfor_each_cpu(cpu, &cpufreq_device->allowed_cpus) {\r\ndev = get_cpu_device(cpu);\r\nif (!dev) {\r\ndev_warn(&cpufreq_device->cool_dev->device,\r\n"No cpu device for cpu %d\n", cpu);\r\ncontinue;\r\n}\r\nnum_opps = dev_pm_opp_get_opp_count(dev);\r\nif (num_opps > 0)\r\nbreak;\r\nelse if (num_opps < 0)\r\nreturn num_opps;\r\n}\r\nif (num_opps == 0)\r\nreturn -EINVAL;\r\npower_table = kcalloc(num_opps, sizeof(*power_table), GFP_KERNEL);\r\nif (!power_table)\r\nreturn -ENOMEM;\r\nfor (freq = 0, i = 0;\r\nopp = dev_pm_opp_find_freq_ceil(dev, &freq), !IS_ERR(opp);\r\nfreq++, i++) {\r\nu32 freq_mhz, voltage_mv;\r\nu64 power;\r\nif (i >= num_opps) {\r\nret = -EAGAIN;\r\ngoto free_power_table;\r\n}\r\nfreq_mhz = freq / 1000000;\r\nvoltage_mv = dev_pm_opp_get_voltage(opp) / 1000;\r\ndev_pm_opp_put(opp);\r\npower = (u64)capacitance * freq_mhz * voltage_mv * voltage_mv;\r\ndo_div(power, 1000000000);\r\npower_table[i].frequency = freq / 1000;\r\npower_table[i].power = power;\r\n}\r\nif (i != num_opps) {\r\nret = PTR_ERR(opp);\r\ngoto free_power_table;\r\n}\r\ncpufreq_device->cpu_dev = dev;\r\ncpufreq_device->dyn_power_table = power_table;\r\ncpufreq_device->dyn_power_table_entries = i;\r\nreturn 0;\r\nfree_power_table:\r\nkfree(power_table);\r\nreturn ret;\r\n}\r\nstatic u32 cpu_freq_to_power(struct cpufreq_cooling_device *cpufreq_device,\r\nu32 freq)\r\n{\r\nint i;\r\nstruct power_table *pt = cpufreq_device->dyn_power_table;\r\nfor (i = 1; i < cpufreq_device->dyn_power_table_entries; i++)\r\nif (freq < pt[i].frequency)\r\nbreak;\r\nreturn pt[i - 1].power;\r\n}\r\nstatic u32 cpu_power_to_freq(struct cpufreq_cooling_device *cpufreq_device,\r\nu32 power)\r\n{\r\nint i;\r\nstruct power_table *pt = cpufreq_device->dyn_power_table;\r\nfor (i = 1; i < cpufreq_device->dyn_power_table_entries; i++)\r\nif (power < pt[i].power)\r\nbreak;\r\nreturn pt[i - 1].frequency;\r\n}\r\nstatic u32 get_load(struct cpufreq_cooling_device *cpufreq_device, int cpu,\r\nint cpu_idx)\r\n{\r\nu32 load;\r\nu64 now, now_idle, delta_time, delta_idle;\r\nnow_idle = get_cpu_idle_time(cpu, &now, 0);\r\ndelta_idle = now_idle - cpufreq_device->time_in_idle[cpu_idx];\r\ndelta_time = now - cpufreq_device->time_in_idle_timestamp[cpu_idx];\r\nif (delta_time <= delta_idle)\r\nload = 0;\r\nelse\r\nload = div64_u64(100 * (delta_time - delta_idle), delta_time);\r\ncpufreq_device->time_in_idle[cpu_idx] = now_idle;\r\ncpufreq_device->time_in_idle_timestamp[cpu_idx] = now;\r\nreturn load;\r\n}\r\nstatic int get_static_power(struct cpufreq_cooling_device *cpufreq_device,\r\nstruct thermal_zone_device *tz, unsigned long freq,\r\nu32 *power)\r\n{\r\nstruct dev_pm_opp *opp;\r\nunsigned long voltage;\r\nstruct cpumask *cpumask = &cpufreq_device->allowed_cpus;\r\nunsigned long freq_hz = freq * 1000;\r\nif (!cpufreq_device->plat_get_static_power ||\r\n!cpufreq_device->cpu_dev) {\r\n*power = 0;\r\nreturn 0;\r\n}\r\nopp = dev_pm_opp_find_freq_exact(cpufreq_device->cpu_dev, freq_hz,\r\ntrue);\r\nif (IS_ERR(opp)) {\r\ndev_warn_ratelimited(cpufreq_device->cpu_dev,\r\n"Failed to find OPP for frequency %lu: %ld\n",\r\nfreq_hz, PTR_ERR(opp));\r\nreturn -EINVAL;\r\n}\r\nvoltage = dev_pm_opp_get_voltage(opp);\r\ndev_pm_opp_put(opp);\r\nif (voltage == 0) {\r\ndev_err_ratelimited(cpufreq_device->cpu_dev,\r\n"Failed to get voltage for frequency %lu\n",\r\nfreq_hz);\r\nreturn -EINVAL;\r\n}\r\nreturn cpufreq_device->plat_get_static_power(cpumask, tz->passive_delay,\r\nvoltage, power);\r\n}\r\nstatic u32 get_dynamic_power(struct cpufreq_cooling_device *cpufreq_device,\r\nunsigned long freq)\r\n{\r\nu32 raw_cpu_power;\r\nraw_cpu_power = cpu_freq_to_power(cpufreq_device, freq);\r\nreturn (raw_cpu_power * cpufreq_device->last_load) / 100;\r\n}\r\nstatic int cpufreq_get_max_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\n*state = cpufreq_device->max_level;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_get_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long *state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\n*state = cpufreq_device->cpufreq_state;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_set_cur_state(struct thermal_cooling_device *cdev,\r\nunsigned long state)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\nunsigned int cpu = cpumask_any(&cpufreq_device->allowed_cpus);\r\nunsigned int clip_freq;\r\nif (WARN_ON(state > cpufreq_device->max_level))\r\nreturn -EINVAL;\r\nif (cpufreq_device->cpufreq_state == state)\r\nreturn 0;\r\nclip_freq = cpufreq_device->freq_table[state];\r\ncpufreq_device->cpufreq_state = state;\r\ncpufreq_device->clipped_freq = clip_freq;\r\ncpufreq_update_policy(cpu);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_get_requested_power(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nu32 *power)\r\n{\r\nunsigned long freq;\r\nint i = 0, cpu, ret;\r\nu32 static_power, dynamic_power, total_load = 0;\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\nu32 *load_cpu = NULL;\r\ncpu = cpumask_any_and(&cpufreq_device->allowed_cpus, cpu_online_mask);\r\nif (cpu >= nr_cpu_ids) {\r\n*power = 0;\r\nreturn 0;\r\n}\r\nfreq = cpufreq_quick_get(cpu);\r\nif (trace_thermal_power_cpu_get_power_enabled()) {\r\nu32 ncpus = cpumask_weight(&cpufreq_device->allowed_cpus);\r\nload_cpu = kcalloc(ncpus, sizeof(*load_cpu), GFP_KERNEL);\r\n}\r\nfor_each_cpu(cpu, &cpufreq_device->allowed_cpus) {\r\nu32 load;\r\nif (cpu_online(cpu))\r\nload = get_load(cpufreq_device, cpu, i);\r\nelse\r\nload = 0;\r\ntotal_load += load;\r\nif (trace_thermal_power_cpu_limit_enabled() && load_cpu)\r\nload_cpu[i] = load;\r\ni++;\r\n}\r\ncpufreq_device->last_load = total_load;\r\ndynamic_power = get_dynamic_power(cpufreq_device, freq);\r\nret = get_static_power(cpufreq_device, tz, freq, &static_power);\r\nif (ret) {\r\nkfree(load_cpu);\r\nreturn ret;\r\n}\r\nif (load_cpu) {\r\ntrace_thermal_power_cpu_get_power(\r\n&cpufreq_device->allowed_cpus,\r\nfreq, load_cpu, i, dynamic_power, static_power);\r\nkfree(load_cpu);\r\n}\r\n*power = static_power + dynamic_power;\r\nreturn 0;\r\n}\r\nstatic int cpufreq_state2power(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz,\r\nunsigned long state, u32 *power)\r\n{\r\nunsigned int freq, num_cpus;\r\ncpumask_var_t cpumask;\r\nu32 static_power, dynamic_power;\r\nint ret;\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\nif (!alloc_cpumask_var(&cpumask, GFP_KERNEL))\r\nreturn -ENOMEM;\r\ncpumask_and(cpumask, &cpufreq_device->allowed_cpus, cpu_online_mask);\r\nnum_cpus = cpumask_weight(cpumask);\r\nif (num_cpus == 0) {\r\n*power = 0;\r\nret = 0;\r\ngoto out;\r\n}\r\nfreq = cpufreq_device->freq_table[state];\r\nif (!freq) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndynamic_power = cpu_freq_to_power(cpufreq_device, freq) * num_cpus;\r\nret = get_static_power(cpufreq_device, tz, freq, &static_power);\r\nif (ret)\r\ngoto out;\r\n*power = static_power + dynamic_power;\r\nout:\r\nfree_cpumask_var(cpumask);\r\nreturn ret;\r\n}\r\nstatic int cpufreq_power2state(struct thermal_cooling_device *cdev,\r\nstruct thermal_zone_device *tz, u32 power,\r\nunsigned long *state)\r\n{\r\nunsigned int cpu, cur_freq, target_freq;\r\nint ret;\r\ns32 dyn_power;\r\nu32 last_load, normalised_power, static_power;\r\nstruct cpufreq_cooling_device *cpufreq_device = cdev->devdata;\r\ncpu = cpumask_any_and(&cpufreq_device->allowed_cpus, cpu_online_mask);\r\nif (cpu >= nr_cpu_ids)\r\nreturn -ENODEV;\r\ncur_freq = cpufreq_quick_get(cpu);\r\nret = get_static_power(cpufreq_device, tz, cur_freq, &static_power);\r\nif (ret)\r\nreturn ret;\r\ndyn_power = power - static_power;\r\ndyn_power = dyn_power > 0 ? dyn_power : 0;\r\nlast_load = cpufreq_device->last_load ?: 1;\r\nnormalised_power = (dyn_power * 100) / last_load;\r\ntarget_freq = cpu_power_to_freq(cpufreq_device, normalised_power);\r\n*state = cpufreq_cooling_get_level(cpu, target_freq);\r\nif (*state == THERMAL_CSTATE_INVALID) {\r\ndev_err_ratelimited(&cdev->device,\r\n"Failed to convert %dKHz for cpu %d into a cdev state\n",\r\ntarget_freq, cpu);\r\nreturn -EINVAL;\r\n}\r\ntrace_thermal_power_cpu_limit(&cpufreq_device->allowed_cpus,\r\ntarget_freq, *state, power);\r\nreturn 0;\r\n}\r\nstatic unsigned int find_next_max(struct cpufreq_frequency_table *table,\r\nunsigned int prev_max)\r\n{\r\nstruct cpufreq_frequency_table *pos;\r\nunsigned int max = 0;\r\ncpufreq_for_each_valid_entry(pos, table) {\r\nif (pos->frequency > max && pos->frequency < prev_max)\r\nmax = pos->frequency;\r\n}\r\nreturn max;\r\n}\r\nstatic struct thermal_cooling_device *\r\n__cpufreq_cooling_register(struct device_node *np,\r\nconst struct cpumask *clip_cpus, u32 capacitance,\r\nget_static_t plat_static_func)\r\n{\r\nstruct cpufreq_policy *policy;\r\nstruct thermal_cooling_device *cool_dev;\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nchar dev_name[THERMAL_NAME_LENGTH];\r\nstruct cpufreq_frequency_table *pos, *table;\r\ncpumask_var_t temp_mask;\r\nunsigned int freq, i, num_cpus;\r\nint ret;\r\nstruct thermal_cooling_device_ops *cooling_ops;\r\nbool first;\r\nif (!alloc_cpumask_var(&temp_mask, GFP_KERNEL))\r\nreturn ERR_PTR(-ENOMEM);\r\ncpumask_and(temp_mask, clip_cpus, cpu_online_mask);\r\npolicy = cpufreq_cpu_get(cpumask_first(temp_mask));\r\nif (!policy) {\r\npr_debug("%s: CPUFreq policy not found\n", __func__);\r\ncool_dev = ERR_PTR(-EPROBE_DEFER);\r\ngoto free_cpumask;\r\n}\r\ntable = policy->freq_table;\r\nif (!table) {\r\npr_debug("%s: CPUFreq table not found\n", __func__);\r\ncool_dev = ERR_PTR(-ENODEV);\r\ngoto put_policy;\r\n}\r\ncpufreq_dev = kzalloc(sizeof(*cpufreq_dev), GFP_KERNEL);\r\nif (!cpufreq_dev) {\r\ncool_dev = ERR_PTR(-ENOMEM);\r\ngoto put_policy;\r\n}\r\nnum_cpus = cpumask_weight(clip_cpus);\r\ncpufreq_dev->time_in_idle = kcalloc(num_cpus,\r\nsizeof(*cpufreq_dev->time_in_idle),\r\nGFP_KERNEL);\r\nif (!cpufreq_dev->time_in_idle) {\r\ncool_dev = ERR_PTR(-ENOMEM);\r\ngoto free_cdev;\r\n}\r\ncpufreq_dev->time_in_idle_timestamp =\r\nkcalloc(num_cpus, sizeof(*cpufreq_dev->time_in_idle_timestamp),\r\nGFP_KERNEL);\r\nif (!cpufreq_dev->time_in_idle_timestamp) {\r\ncool_dev = ERR_PTR(-ENOMEM);\r\ngoto free_time_in_idle;\r\n}\r\ncpufreq_for_each_valid_entry(pos, table)\r\ncpufreq_dev->max_level++;\r\ncpufreq_dev->freq_table = kmalloc(sizeof(*cpufreq_dev->freq_table) *\r\ncpufreq_dev->max_level, GFP_KERNEL);\r\nif (!cpufreq_dev->freq_table) {\r\ncool_dev = ERR_PTR(-ENOMEM);\r\ngoto free_time_in_idle_timestamp;\r\n}\r\ncpufreq_dev->max_level--;\r\ncpumask_copy(&cpufreq_dev->allowed_cpus, clip_cpus);\r\nif (capacitance) {\r\ncpufreq_dev->plat_get_static_power = plat_static_func;\r\nret = build_dyn_power_table(cpufreq_dev, capacitance);\r\nif (ret) {\r\ncool_dev = ERR_PTR(ret);\r\ngoto free_table;\r\n}\r\ncooling_ops = &cpufreq_power_cooling_ops;\r\n} else {\r\ncooling_ops = &cpufreq_cooling_ops;\r\n}\r\nret = ida_simple_get(&cpufreq_ida, 0, 0, GFP_KERNEL);\r\nif (ret < 0) {\r\ncool_dev = ERR_PTR(ret);\r\ngoto free_power_table;\r\n}\r\ncpufreq_dev->id = ret;\r\nfor (i = 0, freq = -1; i <= cpufreq_dev->max_level; i++) {\r\nfreq = find_next_max(table, freq);\r\ncpufreq_dev->freq_table[i] = freq;\r\nif (!freq)\r\npr_warn("%s: table has duplicate entries\n", __func__);\r\nelse\r\npr_debug("%s: freq:%u KHz\n", __func__, freq);\r\n}\r\nsnprintf(dev_name, sizeof(dev_name), "thermal-cpufreq-%d",\r\ncpufreq_dev->id);\r\ncool_dev = thermal_of_cooling_device_register(np, dev_name, cpufreq_dev,\r\ncooling_ops);\r\nif (IS_ERR(cool_dev))\r\ngoto remove_ida;\r\ncpufreq_dev->clipped_freq = cpufreq_dev->freq_table[0];\r\ncpufreq_dev->cool_dev = cool_dev;\r\nmutex_lock(&cooling_list_lock);\r\nfirst = list_empty(&cpufreq_dev_list);\r\nlist_add(&cpufreq_dev->node, &cpufreq_dev_list);\r\nmutex_unlock(&cooling_list_lock);\r\nif (first)\r\ncpufreq_register_notifier(&thermal_cpufreq_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\ngoto put_policy;\r\nremove_ida:\r\nida_simple_remove(&cpufreq_ida, cpufreq_dev->id);\r\nfree_power_table:\r\nkfree(cpufreq_dev->dyn_power_table);\r\nfree_table:\r\nkfree(cpufreq_dev->freq_table);\r\nfree_time_in_idle_timestamp:\r\nkfree(cpufreq_dev->time_in_idle_timestamp);\r\nfree_time_in_idle:\r\nkfree(cpufreq_dev->time_in_idle);\r\nfree_cdev:\r\nkfree(cpufreq_dev);\r\nput_policy:\r\ncpufreq_cpu_put(policy);\r\nfree_cpumask:\r\nfree_cpumask_var(temp_mask);\r\nreturn cool_dev;\r\n}\r\nstruct thermal_cooling_device *\r\ncpufreq_cooling_register(const struct cpumask *clip_cpus)\r\n{\r\nreturn __cpufreq_cooling_register(NULL, clip_cpus, 0, NULL);\r\n}\r\nstruct thermal_cooling_device *\r\nof_cpufreq_cooling_register(struct device_node *np,\r\nconst struct cpumask *clip_cpus)\r\n{\r\nif (!np)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn __cpufreq_cooling_register(np, clip_cpus, 0, NULL);\r\n}\r\nstruct thermal_cooling_device *\r\ncpufreq_power_cooling_register(const struct cpumask *clip_cpus, u32 capacitance,\r\nget_static_t plat_static_func)\r\n{\r\nreturn __cpufreq_cooling_register(NULL, clip_cpus, capacitance,\r\nplat_static_func);\r\n}\r\nstruct thermal_cooling_device *\r\nof_cpufreq_power_cooling_register(struct device_node *np,\r\nconst struct cpumask *clip_cpus,\r\nu32 capacitance,\r\nget_static_t plat_static_func)\r\n{\r\nif (!np)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn __cpufreq_cooling_register(np, clip_cpus, capacitance,\r\nplat_static_func);\r\n}\r\nvoid cpufreq_cooling_unregister(struct thermal_cooling_device *cdev)\r\n{\r\nstruct cpufreq_cooling_device *cpufreq_dev;\r\nbool last;\r\nif (!cdev)\r\nreturn;\r\ncpufreq_dev = cdev->devdata;\r\nmutex_lock(&cooling_list_lock);\r\nlist_del(&cpufreq_dev->node);\r\nlast = list_empty(&cpufreq_dev_list);\r\nmutex_unlock(&cooling_list_lock);\r\nif (last)\r\ncpufreq_unregister_notifier(&thermal_cpufreq_notifier_block,\r\nCPUFREQ_POLICY_NOTIFIER);\r\nthermal_cooling_device_unregister(cpufreq_dev->cool_dev);\r\nida_simple_remove(&cpufreq_ida, cpufreq_dev->id);\r\nkfree(cpufreq_dev->dyn_power_table);\r\nkfree(cpufreq_dev->time_in_idle_timestamp);\r\nkfree(cpufreq_dev->time_in_idle);\r\nkfree(cpufreq_dev->freq_table);\r\nkfree(cpufreq_dev);\r\n}
