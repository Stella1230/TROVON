static void mmc_omap_fclk_offdelay(struct mmc_omap_slot *slot)\r\n{\r\nunsigned long tick_ns;\r\nif (slot != NULL && slot->host->fclk_enabled && slot->fclk_freq > 0) {\r\ntick_ns = DIV_ROUND_UP(NSEC_PER_SEC, slot->fclk_freq);\r\nndelay(8 * tick_ns);\r\n}\r\n}\r\nstatic void mmc_omap_fclk_enable(struct mmc_omap_host *host, unsigned int enable)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->clk_lock, flags);\r\nif (host->fclk_enabled != enable) {\r\nhost->fclk_enabled = enable;\r\nif (enable)\r\nclk_enable(host->fclk);\r\nelse\r\nclk_disable(host->fclk);\r\n}\r\nspin_unlock_irqrestore(&host->clk_lock, flags);\r\n}\r\nstatic void mmc_omap_select_slot(struct mmc_omap_slot *slot, int claimed)\r\n{\r\nstruct mmc_omap_host *host = slot->host;\r\nunsigned long flags;\r\nif (claimed)\r\ngoto no_claim;\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nwhile (host->mmc != NULL) {\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nwait_event(host->slot_wq, host->mmc == NULL);\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\n}\r\nhost->mmc = slot->mmc;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nno_claim:\r\ndel_timer(&host->clk_timer);\r\nif (host->current_slot != slot || !claimed)\r\nmmc_omap_fclk_offdelay(host->current_slot);\r\nif (host->current_slot != slot) {\r\nOMAP_MMC_WRITE(host, CON, slot->saved_con & 0xFC00);\r\nif (host->pdata->switch_slot != NULL)\r\nhost->pdata->switch_slot(mmc_dev(slot->mmc), slot->id);\r\nhost->current_slot = slot;\r\n}\r\nif (claimed) {\r\nmmc_omap_fclk_enable(host, 1);\r\nOMAP_MMC_READ(host, CON);\r\nOMAP_MMC_WRITE(host, CON, slot->saved_con);\r\n} else\r\nmmc_omap_fclk_enable(host, 0);\r\n}\r\nstatic void mmc_omap_slot_release_work(struct work_struct *work)\r\n{\r\nstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\r\nslot_release_work);\r\nstruct mmc_omap_slot *next_slot = host->next_slot;\r\nstruct mmc_request *rq;\r\nhost->next_slot = NULL;\r\nmmc_omap_select_slot(next_slot, 1);\r\nrq = next_slot->mrq;\r\nnext_slot->mrq = NULL;\r\nmmc_omap_start_request(host, rq);\r\n}\r\nstatic void mmc_omap_release_slot(struct mmc_omap_slot *slot, int clk_enabled)\r\n{\r\nstruct mmc_omap_host *host = slot->host;\r\nunsigned long flags;\r\nint i;\r\nBUG_ON(slot == NULL || host->mmc == NULL);\r\nif (clk_enabled)\r\nmod_timer(&host->clk_timer, jiffies + HZ/10);\r\nelse {\r\ndel_timer(&host->clk_timer);\r\nmmc_omap_fclk_offdelay(slot);\r\nmmc_omap_fclk_enable(host, 0);\r\n}\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nfor (i = 0; i < host->nr_slots; i++) {\r\nstruct mmc_omap_slot *new_slot;\r\nif (host->slots[i] == NULL || host->slots[i]->mrq == NULL)\r\ncontinue;\r\nBUG_ON(host->next_slot != NULL);\r\nnew_slot = host->slots[i];\r\nBUG_ON(new_slot == host->current_slot);\r\nhost->next_slot = new_slot;\r\nhost->mmc = new_slot->mmc;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nqueue_work(host->mmc_omap_wq, &host->slot_release_work);\r\nreturn;\r\n}\r\nhost->mmc = NULL;\r\nwake_up(&host->slot_wq);\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\n}\r\nstatic inline\r\nint mmc_omap_cover_is_open(struct mmc_omap_slot *slot)\r\n{\r\nif (slot->pdata->get_cover_state)\r\nreturn slot->pdata->get_cover_state(mmc_dev(slot->mmc),\r\nslot->id);\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nmmc_omap_show_cover_switch(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n", mmc_omap_cover_is_open(slot) ? "open" :\r\n"closed");\r\n}\r\nstatic ssize_t\r\nmmc_omap_show_slot_name(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nreturn sprintf(buf, "%s\n", slot->pdata->name);\r\n}\r\nstatic void\r\nmmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd)\r\n{\r\nu32 cmdreg;\r\nu32 resptype;\r\nu32 cmdtype;\r\nu16 irq_mask;\r\nhost->cmd = cmd;\r\nresptype = 0;\r\ncmdtype = 0;\r\nswitch (mmc_resp_type(cmd)) {\r\ncase MMC_RSP_NONE:\r\nbreak;\r\ncase MMC_RSP_R1:\r\ncase MMC_RSP_R1B:\r\nresptype = 1;\r\nbreak;\r\ncase MMC_RSP_R2:\r\nresptype = 2;\r\nbreak;\r\ncase MMC_RSP_R3:\r\nresptype = 3;\r\nbreak;\r\ndefault:\r\ndev_err(mmc_dev(host->mmc), "Invalid response type: %04x\n", mmc_resp_type(cmd));\r\nbreak;\r\n}\r\nif (mmc_cmd_type(cmd) == MMC_CMD_ADTC) {\r\ncmdtype = OMAP_MMC_CMDTYPE_ADTC;\r\n} else if (mmc_cmd_type(cmd) == MMC_CMD_BC) {\r\ncmdtype = OMAP_MMC_CMDTYPE_BC;\r\n} else if (mmc_cmd_type(cmd) == MMC_CMD_BCR) {\r\ncmdtype = OMAP_MMC_CMDTYPE_BCR;\r\n} else {\r\ncmdtype = OMAP_MMC_CMDTYPE_AC;\r\n}\r\ncmdreg = cmd->opcode | (resptype << 8) | (cmdtype << 12);\r\nif (host->current_slot->bus_mode == MMC_BUSMODE_OPENDRAIN)\r\ncmdreg |= 1 << 6;\r\nif (cmd->flags & MMC_RSP_BUSY)\r\ncmdreg |= 1 << 11;\r\nif (host->data && !(host->data->flags & MMC_DATA_WRITE))\r\ncmdreg |= 1 << 15;\r\nmod_timer(&host->cmd_abort_timer, jiffies + HZ/2);\r\nOMAP_MMC_WRITE(host, CTO, 200);\r\nOMAP_MMC_WRITE(host, ARGL, cmd->arg & 0xffff);\r\nOMAP_MMC_WRITE(host, ARGH, cmd->arg >> 16);\r\nirq_mask = OMAP_MMC_STAT_A_EMPTY | OMAP_MMC_STAT_A_FULL |\r\nOMAP_MMC_STAT_CMD_CRC | OMAP_MMC_STAT_CMD_TOUT |\r\nOMAP_MMC_STAT_DATA_CRC | OMAP_MMC_STAT_DATA_TOUT |\r\nOMAP_MMC_STAT_END_OF_CMD | OMAP_MMC_STAT_CARD_ERR |\r\nOMAP_MMC_STAT_END_OF_DATA;\r\nif (cmd->opcode == MMC_ERASE)\r\nirq_mask &= ~OMAP_MMC_STAT_DATA_TOUT;\r\nOMAP_MMC_WRITE(host, IE, irq_mask);\r\nOMAP_MMC_WRITE(host, CMD, cmdreg);\r\n}\r\nstatic void\r\nmmc_omap_release_dma(struct mmc_omap_host *host, struct mmc_data *data,\r\nint abort)\r\n{\r\nenum dma_data_direction dma_data_dir;\r\nstruct device *dev = mmc_dev(host->mmc);\r\nstruct dma_chan *c;\r\nif (data->flags & MMC_DATA_WRITE) {\r\ndma_data_dir = DMA_TO_DEVICE;\r\nc = host->dma_tx;\r\n} else {\r\ndma_data_dir = DMA_FROM_DEVICE;\r\nc = host->dma_rx;\r\n}\r\nif (c) {\r\nif (data->error) {\r\ndmaengine_terminate_all(c);\r\ndata->bytes_xfered = 0;\r\n}\r\ndev = c->device->dev;\r\n}\r\ndma_unmap_sg(dev, data->sg, host->sg_len, dma_data_dir);\r\n}\r\nstatic void mmc_omap_send_stop_work(struct work_struct *work)\r\n{\r\nstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\r\nsend_stop_work);\r\nstruct mmc_omap_slot *slot = host->current_slot;\r\nstruct mmc_data *data = host->stop_data;\r\nunsigned long tick_ns;\r\ntick_ns = DIV_ROUND_UP(NSEC_PER_SEC, slot->fclk_freq);\r\nndelay(8*tick_ns);\r\nmmc_omap_start_command(host, data->stop);\r\n}\r\nstatic void\r\nmmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nif (host->dma_in_use)\r\nmmc_omap_release_dma(host, data, data->error);\r\nhost->data = NULL;\r\nhost->sg_len = 0;\r\nif (!data->stop) {\r\nstruct mmc_host *mmc;\r\nhost->mrq = NULL;\r\nmmc = host->mmc;\r\nmmc_omap_release_slot(host->current_slot, 1);\r\nmmc_request_done(mmc, data->mrq);\r\nreturn;\r\n}\r\nhost->stop_data = data;\r\nqueue_work(host->mmc_omap_wq, &host->send_stop_work);\r\n}\r\nstatic void\r\nmmc_omap_send_abort(struct mmc_omap_host *host, int maxloops)\r\n{\r\nstruct mmc_omap_slot *slot = host->current_slot;\r\nunsigned int restarts, passes, timeout;\r\nu16 stat = 0;\r\ntimeout = DIV_ROUND_UP(120 * USEC_PER_SEC, slot->fclk_freq);\r\nrestarts = 0;\r\nwhile (restarts < maxloops) {\r\nOMAP_MMC_WRITE(host, STAT, 0xFFFF);\r\nOMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));\r\npasses = 0;\r\nwhile (passes < timeout) {\r\nstat = OMAP_MMC_READ(host, STAT);\r\nif (stat & OMAP_MMC_STAT_END_OF_CMD)\r\ngoto out;\r\nudelay(1);\r\npasses++;\r\n}\r\nrestarts++;\r\n}\r\nout:\r\nOMAP_MMC_WRITE(host, STAT, stat);\r\n}\r\nstatic void\r\nmmc_omap_abort_xfer(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nif (host->dma_in_use)\r\nmmc_omap_release_dma(host, data, 1);\r\nhost->data = NULL;\r\nhost->sg_len = 0;\r\nmmc_omap_send_abort(host, 10000);\r\n}\r\nstatic void\r\nmmc_omap_end_of_data(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nunsigned long flags;\r\nint done;\r\nif (!host->dma_in_use) {\r\nmmc_omap_xfer_done(host, data);\r\nreturn;\r\n}\r\ndone = 0;\r\nspin_lock_irqsave(&host->dma_lock, flags);\r\nif (host->dma_done)\r\ndone = 1;\r\nelse\r\nhost->brs_received = 1;\r\nspin_unlock_irqrestore(&host->dma_lock, flags);\r\nif (done)\r\nmmc_omap_xfer_done(host, data);\r\n}\r\nstatic void\r\nmmc_omap_dma_done(struct mmc_omap_host *host, struct mmc_data *data)\r\n{\r\nunsigned long flags;\r\nint done;\r\ndone = 0;\r\nspin_lock_irqsave(&host->dma_lock, flags);\r\nif (host->brs_received)\r\ndone = 1;\r\nelse\r\nhost->dma_done = 1;\r\nspin_unlock_irqrestore(&host->dma_lock, flags);\r\nif (done)\r\nmmc_omap_xfer_done(host, data);\r\n}\r\nstatic void\r\nmmc_omap_cmd_done(struct mmc_omap_host *host, struct mmc_command *cmd)\r\n{\r\nhost->cmd = NULL;\r\ndel_timer(&host->cmd_abort_timer);\r\nif (cmd->flags & MMC_RSP_PRESENT) {\r\nif (cmd->flags & MMC_RSP_136) {\r\ncmd->resp[3] =\r\nOMAP_MMC_READ(host, RSP0) |\r\n(OMAP_MMC_READ(host, RSP1) << 16);\r\ncmd->resp[2] =\r\nOMAP_MMC_READ(host, RSP2) |\r\n(OMAP_MMC_READ(host, RSP3) << 16);\r\ncmd->resp[1] =\r\nOMAP_MMC_READ(host, RSP4) |\r\n(OMAP_MMC_READ(host, RSP5) << 16);\r\ncmd->resp[0] =\r\nOMAP_MMC_READ(host, RSP6) |\r\n(OMAP_MMC_READ(host, RSP7) << 16);\r\n} else {\r\ncmd->resp[0] =\r\nOMAP_MMC_READ(host, RSP6) |\r\n(OMAP_MMC_READ(host, RSP7) << 16);\r\n}\r\n}\r\nif (host->data == NULL || cmd->error) {\r\nstruct mmc_host *mmc;\r\nif (host->data != NULL)\r\nmmc_omap_abort_xfer(host, host->data);\r\nhost->mrq = NULL;\r\nmmc = host->mmc;\r\nmmc_omap_release_slot(host->current_slot, 1);\r\nmmc_request_done(mmc, cmd->mrq);\r\n}\r\n}\r\nstatic void mmc_omap_abort_command(struct work_struct *work)\r\n{\r\nstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\r\ncmd_abort_work);\r\nBUG_ON(!host->cmd);\r\ndev_dbg(mmc_dev(host->mmc), "Aborting stuck command CMD%d\n",\r\nhost->cmd->opcode);\r\nif (host->cmd->error == 0)\r\nhost->cmd->error = -ETIMEDOUT;\r\nif (host->data == NULL) {\r\nstruct mmc_command *cmd;\r\nstruct mmc_host *mmc;\r\ncmd = host->cmd;\r\nhost->cmd = NULL;\r\nmmc_omap_send_abort(host, 10000);\r\nhost->mrq = NULL;\r\nmmc = host->mmc;\r\nmmc_omap_release_slot(host->current_slot, 1);\r\nmmc_request_done(mmc, cmd->mrq);\r\n} else\r\nmmc_omap_cmd_done(host, host->cmd);\r\nhost->abort = 0;\r\nenable_irq(host->irq);\r\n}\r\nstatic void\r\nmmc_omap_cmd_timer(unsigned long data)\r\n{\r\nstruct mmc_omap_host *host = (struct mmc_omap_host *) data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nif (host->cmd != NULL && !host->abort) {\r\nOMAP_MMC_WRITE(host, IE, 0);\r\ndisable_irq(host->irq);\r\nhost->abort = 1;\r\nqueue_work(host->mmc_omap_wq, &host->cmd_abort_work);\r\n}\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\n}\r\nstatic void\r\nmmc_omap_sg_to_buf(struct mmc_omap_host *host)\r\n{\r\nstruct scatterlist *sg;\r\nsg = host->data->sg + host->sg_idx;\r\nhost->buffer_bytes_left = sg->length;\r\nhost->buffer = sg_virt(sg);\r\nif (host->buffer_bytes_left > host->total_bytes_left)\r\nhost->buffer_bytes_left = host->total_bytes_left;\r\n}\r\nstatic void\r\nmmc_omap_clk_timer(unsigned long data)\r\n{\r\nstruct mmc_omap_host *host = (struct mmc_omap_host *) data;\r\nmmc_omap_fclk_enable(host, 0);\r\n}\r\nstatic void\r\nmmc_omap_xfer_data(struct mmc_omap_host *host, int write)\r\n{\r\nint n, nwords;\r\nif (host->buffer_bytes_left == 0) {\r\nhost->sg_idx++;\r\nBUG_ON(host->sg_idx == host->sg_len);\r\nmmc_omap_sg_to_buf(host);\r\n}\r\nn = 64;\r\nif (n > host->buffer_bytes_left)\r\nn = host->buffer_bytes_left;\r\nnwords = DIV_ROUND_UP(n, 2);\r\nhost->buffer_bytes_left -= n;\r\nhost->total_bytes_left -= n;\r\nhost->data->bytes_xfered += n;\r\nif (write) {\r\n__raw_writesw(host->virt_base + OMAP_MMC_REG(host, DATA),\r\nhost->buffer, nwords);\r\n} else {\r\n__raw_readsw(host->virt_base + OMAP_MMC_REG(host, DATA),\r\nhost->buffer, nwords);\r\n}\r\nhost->buffer += nwords;\r\n}\r\nstatic void mmc_omap_report_irq(struct mmc_omap_host *host, u16 status)\r\n{\r\nstatic const char *mmc_omap_status_bits[] = {\r\n"EOC", "CD", "CB", "BRS", "EOFB", "DTO", "DCRC", "CTO",\r\n"CCRC", "CRW", "AF", "AE", "OCRB", "CIRQ", "CERR"\r\n};\r\nint i;\r\nchar res[64], *buf = res;\r\nbuf += sprintf(buf, "MMC IRQ 0x%x:", status);\r\nfor (i = 0; i < ARRAY_SIZE(mmc_omap_status_bits); i++)\r\nif (status & (1 << i))\r\nbuf += sprintf(buf, " %s", mmc_omap_status_bits[i]);\r\ndev_vdbg(mmc_dev(host->mmc), "%s\n", res);\r\n}\r\nstatic void mmc_omap_report_irq(struct mmc_omap_host *host, u16 status)\r\n{\r\n}\r\nstatic irqreturn_t mmc_omap_irq(int irq, void *dev_id)\r\n{\r\nstruct mmc_omap_host * host = (struct mmc_omap_host *)dev_id;\r\nu16 status;\r\nint end_command;\r\nint end_transfer;\r\nint transfer_error, cmd_error;\r\nif (host->cmd == NULL && host->data == NULL) {\r\nstatus = OMAP_MMC_READ(host, STAT);\r\ndev_info(mmc_dev(host->slots[0]->mmc),\r\n"Spurious IRQ 0x%04x\n", status);\r\nif (status != 0) {\r\nOMAP_MMC_WRITE(host, STAT, status);\r\nOMAP_MMC_WRITE(host, IE, 0);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nend_command = 0;\r\nend_transfer = 0;\r\ntransfer_error = 0;\r\ncmd_error = 0;\r\nwhile ((status = OMAP_MMC_READ(host, STAT)) != 0) {\r\nint cmd;\r\nOMAP_MMC_WRITE(host, STAT, status);\r\nif (host->cmd != NULL)\r\ncmd = host->cmd->opcode;\r\nelse\r\ncmd = -1;\r\ndev_dbg(mmc_dev(host->mmc), "MMC IRQ %04x (CMD %d): ",\r\nstatus, cmd);\r\nmmc_omap_report_irq(host, status);\r\nif (host->total_bytes_left) {\r\nif ((status & OMAP_MMC_STAT_A_FULL) ||\r\n(status & OMAP_MMC_STAT_END_OF_DATA))\r\nmmc_omap_xfer_data(host, 0);\r\nif (status & OMAP_MMC_STAT_A_EMPTY)\r\nmmc_omap_xfer_data(host, 1);\r\n}\r\nif (status & OMAP_MMC_STAT_END_OF_DATA)\r\nend_transfer = 1;\r\nif (status & OMAP_MMC_STAT_DATA_TOUT) {\r\ndev_dbg(mmc_dev(host->mmc), "data timeout (CMD%d)\n",\r\ncmd);\r\nif (host->data) {\r\nhost->data->error = -ETIMEDOUT;\r\ntransfer_error = 1;\r\n}\r\n}\r\nif (status & OMAP_MMC_STAT_DATA_CRC) {\r\nif (host->data) {\r\nhost->data->error = -EILSEQ;\r\ndev_dbg(mmc_dev(host->mmc),\r\n"data CRC error, bytes left %d\n",\r\nhost->total_bytes_left);\r\ntransfer_error = 1;\r\n} else {\r\ndev_dbg(mmc_dev(host->mmc), "data CRC error\n");\r\n}\r\n}\r\nif (status & OMAP_MMC_STAT_CMD_TOUT) {\r\nif (host->cmd) {\r\nstruct mmc_omap_slot *slot =\r\nhost->current_slot;\r\nif (slot == NULL ||\r\n!mmc_omap_cover_is_open(slot))\r\ndev_err(mmc_dev(host->mmc),\r\n"command timeout (CMD%d)\n",\r\ncmd);\r\nhost->cmd->error = -ETIMEDOUT;\r\nend_command = 1;\r\ncmd_error = 1;\r\n}\r\n}\r\nif (status & OMAP_MMC_STAT_CMD_CRC) {\r\nif (host->cmd) {\r\ndev_err(mmc_dev(host->mmc),\r\n"command CRC error (CMD%d, arg 0x%08x)\n",\r\ncmd, host->cmd->arg);\r\nhost->cmd->error = -EILSEQ;\r\nend_command = 1;\r\ncmd_error = 1;\r\n} else\r\ndev_err(mmc_dev(host->mmc),\r\n"command CRC error without cmd?\n");\r\n}\r\nif (status & OMAP_MMC_STAT_CARD_ERR) {\r\ndev_dbg(mmc_dev(host->mmc),\r\n"ignoring card status error (CMD%d)\n",\r\ncmd);\r\nend_command = 1;\r\n}\r\nif ((status & OMAP_MMC_STAT_END_OF_CMD) &&\r\n(!(status & OMAP_MMC_STAT_A_EMPTY))) {\r\nend_command = 1;\r\n}\r\n}\r\nif (cmd_error && host->data) {\r\ndel_timer(&host->cmd_abort_timer);\r\nhost->abort = 1;\r\nOMAP_MMC_WRITE(host, IE, 0);\r\ndisable_irq_nosync(host->irq);\r\nqueue_work(host->mmc_omap_wq, &host->cmd_abort_work);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (end_command && host->cmd)\r\nmmc_omap_cmd_done(host, host->cmd);\r\nif (host->data != NULL) {\r\nif (transfer_error)\r\nmmc_omap_xfer_done(host, host->data);\r\nelse if (end_transfer)\r\nmmc_omap_end_of_data(host, host->data);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid omap_mmc_notify_cover_event(struct device *dev, int num, int is_closed)\r\n{\r\nint cover_open;\r\nstruct mmc_omap_host *host = dev_get_drvdata(dev);\r\nstruct mmc_omap_slot *slot = host->slots[num];\r\nBUG_ON(num >= host->nr_slots);\r\nif (host->nr_slots == 0 || !host->slots[num])\r\nreturn;\r\ncover_open = mmc_omap_cover_is_open(slot);\r\nif (cover_open != slot->cover_open) {\r\nslot->cover_open = cover_open;\r\nsysfs_notify(&slot->mmc->class_dev.kobj, NULL, "cover_switch");\r\n}\r\ntasklet_hi_schedule(&slot->cover_tasklet);\r\n}\r\nstatic void mmc_omap_cover_timer(unsigned long arg)\r\n{\r\nstruct mmc_omap_slot *slot = (struct mmc_omap_slot *) arg;\r\ntasklet_schedule(&slot->cover_tasklet);\r\n}\r\nstatic void mmc_omap_cover_handler(unsigned long param)\r\n{\r\nstruct mmc_omap_slot *slot = (struct mmc_omap_slot *)param;\r\nint cover_open = mmc_omap_cover_is_open(slot);\r\nmmc_detect_change(slot->mmc, 0);\r\nif (!cover_open)\r\nreturn;\r\nif (slot->mmc->card == NULL)\r\nreturn;\r\nmod_timer(&slot->cover_timer,\r\njiffies + msecs_to_jiffies(OMAP_MMC_COVER_POLL_DELAY));\r\n}\r\nstatic void mmc_omap_dma_callback(void *priv)\r\n{\r\nstruct mmc_omap_host *host = priv;\r\nstruct mmc_data *data = host->data;\r\ndata->bytes_xfered += data->blocks * data->blksz;\r\nmmc_omap_dma_done(host, data);\r\n}\r\nstatic inline void set_cmd_timeout(struct mmc_omap_host *host, struct mmc_request *req)\r\n{\r\nu16 reg;\r\nreg = OMAP_MMC_READ(host, SDIO);\r\nreg &= ~(1 << 5);\r\nOMAP_MMC_WRITE(host, SDIO, reg);\r\nOMAP_MMC_WRITE(host, CTO, 0xff);\r\n}\r\nstatic inline void set_data_timeout(struct mmc_omap_host *host, struct mmc_request *req)\r\n{\r\nunsigned int timeout, cycle_ns;\r\nu16 reg;\r\ncycle_ns = 1000000000 / host->current_slot->fclk_freq;\r\ntimeout = req->data->timeout_ns / cycle_ns;\r\ntimeout += req->data->timeout_clks;\r\nreg = OMAP_MMC_READ(host, SDIO);\r\nif (timeout > 0xffff) {\r\nreg |= (1 << 5);\r\ntimeout /= 1024;\r\n} else\r\nreg &= ~(1 << 5);\r\nOMAP_MMC_WRITE(host, SDIO, reg);\r\nOMAP_MMC_WRITE(host, DTO, timeout);\r\n}\r\nstatic void\r\nmmc_omap_prepare_data(struct mmc_omap_host *host, struct mmc_request *req)\r\n{\r\nstruct mmc_data *data = req->data;\r\nint i, use_dma = 1, block_size;\r\nstruct scatterlist *sg;\r\nunsigned sg_len;\r\nhost->data = data;\r\nif (data == NULL) {\r\nOMAP_MMC_WRITE(host, BLEN, 0);\r\nOMAP_MMC_WRITE(host, NBLK, 0);\r\nOMAP_MMC_WRITE(host, BUF, 0);\r\nhost->dma_in_use = 0;\r\nset_cmd_timeout(host, req);\r\nreturn;\r\n}\r\nblock_size = data->blksz;\r\nOMAP_MMC_WRITE(host, NBLK, data->blocks - 1);\r\nOMAP_MMC_WRITE(host, BLEN, block_size - 1);\r\nset_data_timeout(host, req);\r\nsg_len = (data->blocks == 1) ? 1 : data->sg_len;\r\nfor_each_sg(data->sg, sg, sg_len, i) {\r\nif ((sg->length % block_size) != 0) {\r\nuse_dma = 0;\r\nbreak;\r\n}\r\n}\r\nhost->sg_idx = 0;\r\nif (use_dma) {\r\nenum dma_data_direction dma_data_dir;\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dma_chan *c;\r\nu32 burst, *bp;\r\nu16 buf;\r\nburst = mmc_omap15xx() ? 32 : 64;\r\nif (burst > data->blksz)\r\nburst = data->blksz;\r\nburst >>= 1;\r\nif (data->flags & MMC_DATA_WRITE) {\r\nc = host->dma_tx;\r\nbp = &host->dma_tx_burst;\r\nbuf = 0x0f80 | (burst - 1) << 0;\r\ndma_data_dir = DMA_TO_DEVICE;\r\n} else {\r\nc = host->dma_rx;\r\nbp = &host->dma_rx_burst;\r\nbuf = 0x800f | (burst - 1) << 8;\r\ndma_data_dir = DMA_FROM_DEVICE;\r\n}\r\nif (!c)\r\ngoto use_pio;\r\nif (*bp != burst) {\r\nstruct dma_slave_config cfg = {\r\n.src_addr = host->phys_base +\r\nOMAP_MMC_REG(host, DATA),\r\n.dst_addr = host->phys_base +\r\nOMAP_MMC_REG(host, DATA),\r\n.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES,\r\n.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES,\r\n.src_maxburst = burst,\r\n.dst_maxburst = burst,\r\n};\r\nif (dmaengine_slave_config(c, &cfg))\r\ngoto use_pio;\r\n*bp = burst;\r\n}\r\nhost->sg_len = dma_map_sg(c->device->dev, data->sg, sg_len,\r\ndma_data_dir);\r\nif (host->sg_len == 0)\r\ngoto use_pio;\r\ntx = dmaengine_prep_slave_sg(c, data->sg, host->sg_len,\r\ndata->flags & MMC_DATA_WRITE ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tx)\r\ngoto use_pio;\r\nOMAP_MMC_WRITE(host, BUF, buf);\r\ntx->callback = mmc_omap_dma_callback;\r\ntx->callback_param = host;\r\ndmaengine_submit(tx);\r\nhost->brs_received = 0;\r\nhost->dma_done = 0;\r\nhost->dma_in_use = 1;\r\nreturn;\r\n}\r\nuse_pio:\r\nOMAP_MMC_WRITE(host, BUF, 0x1f1f);\r\nhost->total_bytes_left = data->blocks * block_size;\r\nhost->sg_len = sg_len;\r\nmmc_omap_sg_to_buf(host);\r\nhost->dma_in_use = 0;\r\n}\r\nstatic void mmc_omap_start_request(struct mmc_omap_host *host,\r\nstruct mmc_request *req)\r\n{\r\nBUG_ON(host->mrq != NULL);\r\nhost->mrq = req;\r\nmmc_omap_prepare_data(host, req);\r\nmmc_omap_start_command(host, req->cmd);\r\nif (host->dma_in_use) {\r\nstruct dma_chan *c = host->data->flags & MMC_DATA_WRITE ?\r\nhost->dma_tx : host->dma_rx;\r\ndma_async_issue_pending(c);\r\n}\r\n}\r\nstatic void mmc_omap_request(struct mmc_host *mmc, struct mmc_request *req)\r\n{\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nstruct mmc_omap_host *host = slot->host;\r\nunsigned long flags;\r\nspin_lock_irqsave(&host->slot_lock, flags);\r\nif (host->mmc != NULL) {\r\nBUG_ON(slot->mrq != NULL);\r\nslot->mrq = req;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nreturn;\r\n} else\r\nhost->mmc = mmc;\r\nspin_unlock_irqrestore(&host->slot_lock, flags);\r\nmmc_omap_select_slot(slot, 1);\r\nmmc_omap_start_request(host, req);\r\n}\r\nstatic void mmc_omap_set_power(struct mmc_omap_slot *slot, int power_on,\r\nint vdd)\r\n{\r\nstruct mmc_omap_host *host;\r\nhost = slot->host;\r\nif (slot->pdata->set_power != NULL)\r\nslot->pdata->set_power(mmc_dev(slot->mmc), slot->id, power_on,\r\nvdd);\r\nif (mmc_omap2()) {\r\nu16 w;\r\nif (power_on) {\r\nw = OMAP_MMC_READ(host, CON);\r\nOMAP_MMC_WRITE(host, CON, w | (1 << 11));\r\n} else {\r\nw = OMAP_MMC_READ(host, CON);\r\nOMAP_MMC_WRITE(host, CON, w & ~(1 << 11));\r\n}\r\n}\r\n}\r\nstatic int mmc_omap_calc_divisor(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nstruct mmc_omap_host *host = slot->host;\r\nint func_clk_rate = clk_get_rate(host->fclk);\r\nint dsor;\r\nif (ios->clock == 0)\r\nreturn 0;\r\ndsor = func_clk_rate / ios->clock;\r\nif (dsor < 1)\r\ndsor = 1;\r\nif (func_clk_rate / dsor > ios->clock)\r\ndsor++;\r\nif (dsor > 250)\r\ndsor = 250;\r\nslot->fclk_freq = func_clk_rate / dsor;\r\nif (ios->bus_width == MMC_BUS_WIDTH_4)\r\ndsor |= 1 << 15;\r\nreturn dsor;\r\n}\r\nstatic void mmc_omap_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\r\n{\r\nstruct mmc_omap_slot *slot = mmc_priv(mmc);\r\nstruct mmc_omap_host *host = slot->host;\r\nint i, dsor;\r\nint clk_enabled;\r\nmmc_omap_select_slot(slot, 0);\r\ndsor = mmc_omap_calc_divisor(mmc, ios);\r\nif (ios->vdd != slot->vdd)\r\nslot->vdd = ios->vdd;\r\nclk_enabled = 0;\r\nswitch (ios->power_mode) {\r\ncase MMC_POWER_OFF:\r\nmmc_omap_set_power(slot, 0, ios->vdd);\r\nbreak;\r\ncase MMC_POWER_UP:\r\nmmc_omap_set_power(slot, 1, ios->vdd);\r\ngoto exit;\r\ncase MMC_POWER_ON:\r\nmmc_omap_fclk_enable(host, 1);\r\nclk_enabled = 1;\r\ndsor |= 1 << 11;\r\nbreak;\r\n}\r\nif (slot->bus_mode != ios->bus_mode) {\r\nif (slot->pdata->set_bus_mode != NULL)\r\nslot->pdata->set_bus_mode(mmc_dev(mmc), slot->id,\r\nios->bus_mode);\r\nslot->bus_mode = ios->bus_mode;\r\n}\r\nfor (i = 0; i < 2; i++)\r\nOMAP_MMC_WRITE(host, CON, dsor);\r\nslot->saved_con = dsor;\r\nif (ios->power_mode == MMC_POWER_ON) {\r\nint usecs = 250;\r\nOMAP_MMC_WRITE(host, IE, 0);\r\nOMAP_MMC_WRITE(host, STAT, 0xffff);\r\nOMAP_MMC_WRITE(host, CMD, 1 << 7);\r\nwhile (usecs > 0 && (OMAP_MMC_READ(host, STAT) & 1) == 0) {\r\nudelay(1);\r\nusecs--;\r\n}\r\nOMAP_MMC_WRITE(host, STAT, 1);\r\n}\r\nexit:\r\nmmc_omap_release_slot(slot, clk_enabled);\r\n}\r\nstatic int mmc_omap_new_slot(struct mmc_omap_host *host, int id)\r\n{\r\nstruct mmc_omap_slot *slot = NULL;\r\nstruct mmc_host *mmc;\r\nint r;\r\nmmc = mmc_alloc_host(sizeof(struct mmc_omap_slot), host->dev);\r\nif (mmc == NULL)\r\nreturn -ENOMEM;\r\nslot = mmc_priv(mmc);\r\nslot->host = host;\r\nslot->mmc = mmc;\r\nslot->id = id;\r\nslot->pdata = &host->pdata->slots[id];\r\nhost->slots[id] = slot;\r\nmmc->caps = 0;\r\nif (host->pdata->slots[id].wires >= 4)\r\nmmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_ERASE;\r\nmmc->ops = &mmc_omap_ops;\r\nmmc->f_min = 400000;\r\nif (mmc_omap2())\r\nmmc->f_max = 48000000;\r\nelse\r\nmmc->f_max = 24000000;\r\nif (host->pdata->max_freq)\r\nmmc->f_max = min(host->pdata->max_freq, mmc->f_max);\r\nmmc->ocr_avail = slot->pdata->ocr_mask;\r\nmmc->max_segs = 32;\r\nmmc->max_blk_size = 2048;\r\nmmc->max_blk_count = 2048;\r\nmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\r\nmmc->max_seg_size = mmc->max_req_size;\r\nif (slot->pdata->get_cover_state != NULL) {\r\nsetup_timer(&slot->cover_timer, mmc_omap_cover_timer,\r\n(unsigned long)slot);\r\ntasklet_init(&slot->cover_tasklet, mmc_omap_cover_handler,\r\n(unsigned long)slot);\r\n}\r\nr = mmc_add_host(mmc);\r\nif (r < 0)\r\ngoto err_remove_host;\r\nif (slot->pdata->name != NULL) {\r\nr = device_create_file(&mmc->class_dev,\r\n&dev_attr_slot_name);\r\nif (r < 0)\r\ngoto err_remove_host;\r\n}\r\nif (slot->pdata->get_cover_state != NULL) {\r\nr = device_create_file(&mmc->class_dev,\r\n&dev_attr_cover_switch);\r\nif (r < 0)\r\ngoto err_remove_slot_name;\r\ntasklet_schedule(&slot->cover_tasklet);\r\n}\r\nreturn 0;\r\nerr_remove_slot_name:\r\nif (slot->pdata->name != NULL)\r\ndevice_remove_file(&mmc->class_dev, &dev_attr_slot_name);\r\nerr_remove_host:\r\nmmc_remove_host(mmc);\r\nmmc_free_host(mmc);\r\nreturn r;\r\n}\r\nstatic void mmc_omap_remove_slot(struct mmc_omap_slot *slot)\r\n{\r\nstruct mmc_host *mmc = slot->mmc;\r\nif (slot->pdata->name != NULL)\r\ndevice_remove_file(&mmc->class_dev, &dev_attr_slot_name);\r\nif (slot->pdata->get_cover_state != NULL)\r\ndevice_remove_file(&mmc->class_dev, &dev_attr_cover_switch);\r\ntasklet_kill(&slot->cover_tasklet);\r\ndel_timer_sync(&slot->cover_timer);\r\nflush_workqueue(slot->host->mmc_omap_wq);\r\nmmc_remove_host(mmc);\r\nmmc_free_host(mmc);\r\n}\r\nstatic int mmc_omap_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_mmc_platform_data *pdata = pdev->dev.platform_data;\r\nstruct mmc_omap_host *host = NULL;\r\nstruct resource *res;\r\nint i, ret = 0;\r\nint irq;\r\nif (pdata == NULL) {\r\ndev_err(&pdev->dev, "platform data missing\n");\r\nreturn -ENXIO;\r\n}\r\nif (pdata->nr_slots == 0) {\r\ndev_err(&pdev->dev, "no slots\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\nhost = devm_kzalloc(&pdev->dev, sizeof(struct mmc_omap_host),\r\nGFP_KERNEL);\r\nif (host == NULL)\r\nreturn -ENOMEM;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0)\r\nreturn -ENXIO;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->virt_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(host->virt_base))\r\nreturn PTR_ERR(host->virt_base);\r\nINIT_WORK(&host->slot_release_work, mmc_omap_slot_release_work);\r\nINIT_WORK(&host->send_stop_work, mmc_omap_send_stop_work);\r\nINIT_WORK(&host->cmd_abort_work, mmc_omap_abort_command);\r\nsetup_timer(&host->cmd_abort_timer, mmc_omap_cmd_timer,\r\n(unsigned long) host);\r\nspin_lock_init(&host->clk_lock);\r\nsetup_timer(&host->clk_timer, mmc_omap_clk_timer, (unsigned long) host);\r\nspin_lock_init(&host->dma_lock);\r\nspin_lock_init(&host->slot_lock);\r\ninit_waitqueue_head(&host->slot_wq);\r\nhost->pdata = pdata;\r\nhost->features = host->pdata->slots[0].features;\r\nhost->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, host);\r\nhost->id = pdev->id;\r\nhost->irq = irq;\r\nhost->phys_base = res->start;\r\nhost->iclk = clk_get(&pdev->dev, "ick");\r\nif (IS_ERR(host->iclk))\r\nreturn PTR_ERR(host->iclk);\r\nclk_enable(host->iclk);\r\nhost->fclk = clk_get(&pdev->dev, "fck");\r\nif (IS_ERR(host->fclk)) {\r\nret = PTR_ERR(host->fclk);\r\ngoto err_free_iclk;\r\n}\r\nhost->dma_tx_burst = -1;\r\nhost->dma_rx_burst = -1;\r\nhost->dma_tx = dma_request_chan(&pdev->dev, "tx");\r\nif (IS_ERR(host->dma_tx)) {\r\nret = PTR_ERR(host->dma_tx);\r\nif (ret == -EPROBE_DEFER) {\r\nclk_put(host->fclk);\r\ngoto err_free_iclk;\r\n}\r\nhost->dma_tx = NULL;\r\ndev_warn(host->dev, "TX DMA channel request failed\n");\r\n}\r\nhost->dma_rx = dma_request_chan(&pdev->dev, "rx");\r\nif (IS_ERR(host->dma_rx)) {\r\nret = PTR_ERR(host->dma_rx);\r\nif (ret == -EPROBE_DEFER) {\r\nif (host->dma_tx)\r\ndma_release_channel(host->dma_tx);\r\nclk_put(host->fclk);\r\ngoto err_free_iclk;\r\n}\r\nhost->dma_rx = NULL;\r\ndev_warn(host->dev, "RX DMA channel request failed\n");\r\n}\r\nret = request_irq(host->irq, mmc_omap_irq, 0, DRIVER_NAME, host);\r\nif (ret)\r\ngoto err_free_dma;\r\nif (pdata->init != NULL) {\r\nret = pdata->init(&pdev->dev);\r\nif (ret < 0)\r\ngoto err_free_irq;\r\n}\r\nhost->nr_slots = pdata->nr_slots;\r\nhost->reg_shift = (mmc_omap7xx() ? 1 : 2);\r\nhost->mmc_omap_wq = alloc_workqueue("mmc_omap", 0, 0);\r\nif (!host->mmc_omap_wq) {\r\nret = -ENOMEM;\r\ngoto err_plat_cleanup;\r\n}\r\nfor (i = 0; i < pdata->nr_slots; i++) {\r\nret = mmc_omap_new_slot(host, i);\r\nif (ret < 0) {\r\nwhile (--i >= 0)\r\nmmc_omap_remove_slot(host->slots[i]);\r\ngoto err_destroy_wq;\r\n}\r\n}\r\nreturn 0;\r\nerr_destroy_wq:\r\ndestroy_workqueue(host->mmc_omap_wq);\r\nerr_plat_cleanup:\r\nif (pdata->cleanup)\r\npdata->cleanup(&pdev->dev);\r\nerr_free_irq:\r\nfree_irq(host->irq, host);\r\nerr_free_dma:\r\nif (host->dma_tx)\r\ndma_release_channel(host->dma_tx);\r\nif (host->dma_rx)\r\ndma_release_channel(host->dma_rx);\r\nclk_put(host->fclk);\r\nerr_free_iclk:\r\nclk_disable(host->iclk);\r\nclk_put(host->iclk);\r\nreturn ret;\r\n}\r\nstatic int mmc_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct mmc_omap_host *host = platform_get_drvdata(pdev);\r\nint i;\r\nBUG_ON(host == NULL);\r\nfor (i = 0; i < host->nr_slots; i++)\r\nmmc_omap_remove_slot(host->slots[i]);\r\nif (host->pdata->cleanup)\r\nhost->pdata->cleanup(&pdev->dev);\r\nmmc_omap_fclk_enable(host, 0);\r\nfree_irq(host->irq, host);\r\nclk_put(host->fclk);\r\nclk_disable(host->iclk);\r\nclk_put(host->iclk);\r\nif (host->dma_tx)\r\ndma_release_channel(host->dma_tx);\r\nif (host->dma_rx)\r\ndma_release_channel(host->dma_rx);\r\ndestroy_workqueue(host->mmc_omap_wq);\r\nreturn 0;\r\n}
