static inline void map_dma_buffer(struct musb_request *request,\r\nstruct musb *musb, struct musb_ep *musb_ep)\r\n{\r\nint compatible = true;\r\nstruct dma_controller *dma = musb->dma_controller;\r\nrequest->map_state = UN_MAPPED;\r\nif (!is_dma_capable() || !musb_ep->dma)\r\nreturn;\r\nif (dma->is_compatible)\r\ncompatible = dma->is_compatible(musb_ep->dma,\r\nmusb_ep->packet_sz, request->request.buf,\r\nrequest->request.length);\r\nif (!compatible)\r\nreturn;\r\nif (request->request.dma == DMA_ADDR_INVALID) {\r\ndma_addr_t dma_addr;\r\nint ret;\r\ndma_addr = dma_map_single(\r\nmusb->controller,\r\nrequest->request.buf,\r\nrequest->request.length,\r\nrequest->tx\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nret = dma_mapping_error(musb->controller, dma_addr);\r\nif (ret)\r\nreturn;\r\nrequest->request.dma = dma_addr;\r\nrequest->map_state = MUSB_MAPPED;\r\n} else {\r\ndma_sync_single_for_device(musb->controller,\r\nrequest->request.dma,\r\nrequest->request.length,\r\nrequest->tx\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nrequest->map_state = PRE_MAPPED;\r\n}\r\n}\r\nstatic inline void unmap_dma_buffer(struct musb_request *request,\r\nstruct musb *musb)\r\n{\r\nstruct musb_ep *musb_ep = request->ep;\r\nif (!is_buffer_mapped(request) || !musb_ep->dma)\r\nreturn;\r\nif (request->request.dma == DMA_ADDR_INVALID) {\r\ndev_vdbg(musb->controller,\r\n"not unmapping a never mapped buffer\n");\r\nreturn;\r\n}\r\nif (request->map_state == MUSB_MAPPED) {\r\ndma_unmap_single(musb->controller,\r\nrequest->request.dma,\r\nrequest->request.length,\r\nrequest->tx\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\nrequest->request.dma = DMA_ADDR_INVALID;\r\n} else {\r\ndma_sync_single_for_cpu(musb->controller,\r\nrequest->request.dma,\r\nrequest->request.length,\r\nrequest->tx\r\n? DMA_TO_DEVICE\r\n: DMA_FROM_DEVICE);\r\n}\r\nrequest->map_state = UN_MAPPED;\r\n}\r\nvoid musb_g_giveback(\r\nstruct musb_ep *ep,\r\nstruct usb_request *request,\r\nint status)\r\n__releases(ep->musb->lock)\r\n__acquires(ep->musb->lock)\r\n{\r\nstruct musb_request *req;\r\nstruct musb *musb;\r\nint busy = ep->busy;\r\nreq = to_musb_request(request);\r\nlist_del(&req->list);\r\nif (req->request.status == -EINPROGRESS)\r\nreq->request.status = status;\r\nmusb = req->musb;\r\nep->busy = 1;\r\nspin_unlock(&musb->lock);\r\nif (!dma_mapping_error(&musb->g.dev, request->dma))\r\nunmap_dma_buffer(req, musb);\r\ntrace_musb_req_gb(req);\r\nusb_gadget_giveback_request(&req->ep->end_point, &req->request);\r\nspin_lock(&musb->lock);\r\nep->busy = busy;\r\n}\r\nstatic void nuke(struct musb_ep *ep, const int status)\r\n{\r\nstruct musb *musb = ep->musb;\r\nstruct musb_request *req = NULL;\r\nvoid __iomem *epio = ep->musb->endpoints[ep->current_epnum].regs;\r\nep->busy = 1;\r\nif (is_dma_capable() && ep->dma) {\r\nstruct dma_controller *c = ep->musb->dma_controller;\r\nint value;\r\nif (ep->is_in) {\r\nmusb_writew(epio, MUSB_TXCSR,\r\nMUSB_TXCSR_DMAMODE | MUSB_TXCSR_FLUSHFIFO);\r\nmusb_writew(epio, MUSB_TXCSR,\r\n0 | MUSB_TXCSR_FLUSHFIFO);\r\n} else {\r\nmusb_writew(epio, MUSB_RXCSR,\r\n0 | MUSB_RXCSR_FLUSHFIFO);\r\nmusb_writew(epio, MUSB_RXCSR,\r\n0 | MUSB_RXCSR_FLUSHFIFO);\r\n}\r\nvalue = c->channel_abort(ep->dma);\r\nmusb_dbg(musb, "%s: abort DMA --> %d", ep->name, value);\r\nc->channel_release(ep->dma);\r\nep->dma = NULL;\r\n}\r\nwhile (!list_empty(&ep->req_list)) {\r\nreq = list_first_entry(&ep->req_list, struct musb_request, list);\r\nmusb_g_giveback(ep, &req->request, status);\r\n}\r\n}\r\nstatic inline int max_ep_writesize(struct musb *musb, struct musb_ep *ep)\r\n{\r\nif (can_bulk_split(musb, ep->type))\r\nreturn ep->hw_ep->max_packet_sz_tx;\r\nelse\r\nreturn ep->packet_sz;\r\n}\r\nstatic void txstate(struct musb *musb, struct musb_request *req)\r\n{\r\nu8 epnum = req->epnum;\r\nstruct musb_ep *musb_ep;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nstruct usb_request *request;\r\nu16 fifo_count = 0, csr;\r\nint use_dma = 0;\r\nmusb_ep = req->ep;\r\nif (!musb_ep->desc) {\r\nmusb_dbg(musb, "ep:%s disabled - ignore request",\r\nmusb_ep->end_point.name);\r\nreturn;\r\n}\r\nif (dma_channel_status(musb_ep->dma) == MUSB_DMA_STATUS_BUSY) {\r\nmusb_dbg(musb, "dma pending...");\r\nreturn;\r\n}\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nrequest = &req->request;\r\nfifo_count = min(max_ep_writesize(musb, musb_ep),\r\n(int)(request->length - request->actual));\r\nif (csr & MUSB_TXCSR_TXPKTRDY) {\r\nmusb_dbg(musb, "%s old packet still ready , txcsr %03x",\r\nmusb_ep->end_point.name, csr);\r\nreturn;\r\n}\r\nif (csr & MUSB_TXCSR_P_SENDSTALL) {\r\nmusb_dbg(musb, "%s stalling, txcsr %03x",\r\nmusb_ep->end_point.name, csr);\r\nreturn;\r\n}\r\nmusb_dbg(musb, "hw_ep%d, maxpacket %d, fifo count %d, txcsr %03x",\r\nepnum, musb_ep->packet_sz, fifo_count,\r\ncsr);\r\n#ifndef CONFIG_MUSB_PIO_ONLY\r\nif (is_buffer_mapped(req)) {\r\nstruct dma_controller *c = musb->dma_controller;\r\nsize_t request_size;\r\nrequest_size = min_t(size_t, request->length - request->actual,\r\nmusb_ep->dma->max_len);\r\nuse_dma = (request->dma != DMA_ADDR_INVALID && request_size);\r\nif (musb_dma_inventra(musb) || musb_dma_ux500(musb)) {\r\nif (request_size < musb_ep->packet_sz)\r\nmusb_ep->dma->desired_mode = 0;\r\nelse\r\nmusb_ep->dma->desired_mode = 1;\r\nuse_dma = use_dma && c->channel_program(\r\nmusb_ep->dma, musb_ep->packet_sz,\r\nmusb_ep->dma->desired_mode,\r\nrequest->dma + request->actual, request_size);\r\nif (use_dma) {\r\nif (musb_ep->dma->desired_mode == 0) {\r\ncsr &= ~(MUSB_TXCSR_AUTOSET\r\n| MUSB_TXCSR_DMAENAB);\r\nmusb_writew(epio, MUSB_TXCSR, csr\r\n| MUSB_TXCSR_P_WZC_BITS);\r\ncsr &= ~MUSB_TXCSR_DMAMODE;\r\ncsr |= (MUSB_TXCSR_DMAENAB |\r\nMUSB_TXCSR_MODE);\r\n} else {\r\ncsr |= (MUSB_TXCSR_DMAENAB\r\n| MUSB_TXCSR_DMAMODE\r\n| MUSB_TXCSR_MODE);\r\nif (!musb_ep->hb_mult ||\r\ncan_bulk_split(musb,\r\nmusb_ep->type))\r\ncsr |= MUSB_TXCSR_AUTOSET;\r\n}\r\ncsr &= ~MUSB_TXCSR_P_UNDERRUN;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n}\r\n}\r\nif (is_cppi_enabled(musb)) {\r\ncsr &= ~(MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_TXPKTRDY);\r\ncsr |= MUSB_TXCSR_DMAENAB | MUSB_TXCSR_DMAMODE |\r\nMUSB_TXCSR_MODE;\r\nmusb_writew(epio, MUSB_TXCSR, (MUSB_TXCSR_P_WZC_BITS &\r\n~MUSB_TXCSR_P_UNDERRUN) | csr);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nuse_dma = use_dma && c->channel_program(\r\nmusb_ep->dma, musb_ep->packet_sz,\r\n0,\r\nrequest->dma + request->actual,\r\nrequest_size);\r\nif (!use_dma) {\r\nc->channel_release(musb_ep->dma);\r\nmusb_ep->dma = NULL;\r\ncsr &= ~MUSB_TXCSR_DMAENAB;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n}\r\n} else if (tusb_dma_omap(musb))\r\nuse_dma = use_dma && c->channel_program(\r\nmusb_ep->dma, musb_ep->packet_sz,\r\nrequest->zero,\r\nrequest->dma + request->actual,\r\nrequest_size);\r\n}\r\n#endif\r\nif (!use_dma) {\r\nunmap_dma_buffer(req, musb);\r\nmusb_write_fifo(musb_ep->hw_ep, fifo_count,\r\n(u8 *) (request->buf + request->actual));\r\nrequest->actual += fifo_count;\r\ncsr |= MUSB_TXCSR_TXPKTRDY;\r\ncsr &= ~MUSB_TXCSR_P_UNDERRUN;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n}\r\nmusb_dbg(musb, "%s TX/IN %s len %d/%d, txcsr %04x, fifo %d/%d",\r\nmusb_ep->end_point.name, use_dma ? "dma" : "pio",\r\nrequest->actual, request->length,\r\nmusb_readw(epio, MUSB_TXCSR),\r\nfifo_count,\r\nmusb_readw(epio, MUSB_TXMAXP));\r\n}\r\nvoid musb_g_tx(struct musb *musb, u8 epnum)\r\n{\r\nu16 csr;\r\nstruct musb_request *req;\r\nstruct usb_request *request;\r\nu8 __iomem *mbase = musb->mregs;\r\nstruct musb_ep *musb_ep = &musb->endpoints[epnum].ep_in;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nstruct dma_channel *dma;\r\nmusb_ep_select(mbase, epnum);\r\nreq = next_request(musb_ep);\r\nrequest = &req->request;\r\ntrace_musb_req_tx(req);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nmusb_dbg(musb, "<== %s, txcsr %04x", musb_ep->end_point.name, csr);\r\ndma = is_dma_capable() ? musb_ep->dma : NULL;\r\nif (csr & MUSB_TXCSR_P_SENTSTALL) {\r\ncsr |= MUSB_TXCSR_P_WZC_BITS;\r\ncsr &= ~MUSB_TXCSR_P_SENTSTALL;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\nreturn;\r\n}\r\nif (csr & MUSB_TXCSR_P_UNDERRUN) {\r\ncsr |= MUSB_TXCSR_P_WZC_BITS;\r\ncsr &= ~(MUSB_TXCSR_P_UNDERRUN | MUSB_TXCSR_TXPKTRDY);\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\ndev_vdbg(musb->controller, "underrun on ep%d, req %p\n",\r\nepnum, request);\r\n}\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\nmusb_dbg(musb, "%s dma still busy?", musb_ep->end_point.name);\r\nreturn;\r\n}\r\nif (request) {\r\nu8 is_dma = 0;\r\nbool short_packet = false;\r\nif (dma && (csr & MUSB_TXCSR_DMAENAB)) {\r\nis_dma = 1;\r\ncsr |= MUSB_TXCSR_P_WZC_BITS;\r\ncsr &= ~(MUSB_TXCSR_DMAENAB | MUSB_TXCSR_P_UNDERRUN |\r\nMUSB_TXCSR_TXPKTRDY | MUSB_TXCSR_AUTOSET);\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nrequest->actual += musb_ep->dma->actual_len;\r\nmusb_dbg(musb, "TXCSR%d %04x, DMA off, len %zu, req %p",\r\nepnum, csr, musb_ep->dma->actual_len, request);\r\n}\r\nif ((request->zero && request->length)\r\n&& (request->length % musb_ep->packet_sz == 0)\r\n&& (request->actual == request->length))\r\nshort_packet = true;\r\nif ((musb_dma_inventra(musb) || musb_dma_ux500(musb)) &&\r\n(is_dma && (!dma->desired_mode ||\r\n(request->actual &\r\n(musb_ep->packet_sz - 1)))))\r\nshort_packet = true;\r\nif (short_packet) {\r\nif (csr & MUSB_TXCSR_TXPKTRDY)\r\nreturn;\r\nmusb_writew(epio, MUSB_TXCSR, MUSB_TXCSR_MODE\r\n| MUSB_TXCSR_TXPKTRDY);\r\nrequest->zero = 0;\r\n}\r\nif (request->actual == request->length) {\r\nmusb_g_giveback(musb_ep, request, 0);\r\nmusb_ep_select(mbase, epnum);\r\nreq = musb_ep->desc ? next_request(musb_ep) : NULL;\r\nif (!req) {\r\nmusb_dbg(musb, "%s idle now",\r\nmusb_ep->end_point.name);\r\nreturn;\r\n}\r\n}\r\ntxstate(musb, req);\r\n}\r\n}\r\nstatic void rxstate(struct musb *musb, struct musb_request *req)\r\n{\r\nconst u8 epnum = req->epnum;\r\nstruct usb_request *request = &req->request;\r\nstruct musb_ep *musb_ep;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nunsigned len = 0;\r\nu16 fifo_count;\r\nu16 csr = musb_readw(epio, MUSB_RXCSR);\r\nstruct musb_hw_ep *hw_ep = &musb->endpoints[epnum];\r\nu8 use_mode_1;\r\nif (hw_ep->is_shared_fifo)\r\nmusb_ep = &hw_ep->ep_in;\r\nelse\r\nmusb_ep = &hw_ep->ep_out;\r\nfifo_count = musb_ep->packet_sz;\r\nif (!musb_ep->desc) {\r\nmusb_dbg(musb, "ep:%s disabled - ignore request",\r\nmusb_ep->end_point.name);\r\nreturn;\r\n}\r\nif (dma_channel_status(musb_ep->dma) == MUSB_DMA_STATUS_BUSY) {\r\nmusb_dbg(musb, "DMA pending...");\r\nreturn;\r\n}\r\nif (csr & MUSB_RXCSR_P_SENDSTALL) {\r\nmusb_dbg(musb, "%s stalling, RXCSR %04x",\r\nmusb_ep->end_point.name, csr);\r\nreturn;\r\n}\r\nif (is_cppi_enabled(musb) && is_buffer_mapped(req)) {\r\nstruct dma_controller *c = musb->dma_controller;\r\nstruct dma_channel *channel = musb_ep->dma;\r\nif (c->channel_program(channel,\r\nmusb_ep->packet_sz,\r\n!request->short_not_ok,\r\nrequest->dma + request->actual,\r\nrequest->length - request->actual)) {\r\ncsr &= ~(MUSB_RXCSR_AUTOCLEAR\r\n| MUSB_RXCSR_DMAMODE);\r\ncsr |= MUSB_RXCSR_DMAENAB | MUSB_RXCSR_P_WZC_BITS;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nreturn;\r\n}\r\n}\r\nif (csr & MUSB_RXCSR_RXPKTRDY) {\r\nfifo_count = musb_readw(epio, MUSB_RXCOUNT);\r\nif (request->short_not_ok && fifo_count == musb_ep->packet_sz)\r\nuse_mode_1 = 1;\r\nelse\r\nuse_mode_1 = 0;\r\nif (request->actual < request->length) {\r\nif (!is_buffer_mapped(req))\r\ngoto buffer_aint_mapped;\r\nif (musb_dma_inventra(musb)) {\r\nstruct dma_controller *c;\r\nstruct dma_channel *channel;\r\nint use_dma = 0;\r\nunsigned int transfer_size;\r\nc = musb->dma_controller;\r\nchannel = musb_ep->dma;\r\nif (use_mode_1) {\r\ncsr |= MUSB_RXCSR_AUTOCLEAR;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\ncsr |= MUSB_RXCSR_DMAENAB;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nmusb_writew(epio, MUSB_RXCSR,\r\ncsr | MUSB_RXCSR_DMAMODE);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\ntransfer_size = min_t(unsigned int,\r\nrequest->length -\r\nrequest->actual,\r\nchannel->max_len);\r\nmusb_ep->dma->desired_mode = 1;\r\n} else {\r\nif (!musb_ep->hb_mult &&\r\nmusb_ep->hw_ep->rx_double_buffered)\r\ncsr |= MUSB_RXCSR_AUTOCLEAR;\r\ncsr |= MUSB_RXCSR_DMAENAB;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\ntransfer_size = min(request->length - request->actual,\r\n(unsigned)fifo_count);\r\nmusb_ep->dma->desired_mode = 0;\r\n}\r\nuse_dma = c->channel_program(\r\nchannel,\r\nmusb_ep->packet_sz,\r\nchannel->desired_mode,\r\nrequest->dma\r\n+ request->actual,\r\ntransfer_size);\r\nif (use_dma)\r\nreturn;\r\n}\r\nif ((musb_dma_ux500(musb)) &&\r\n(request->actual < request->length)) {\r\nstruct dma_controller *c;\r\nstruct dma_channel *channel;\r\nunsigned int transfer_size = 0;\r\nc = musb->dma_controller;\r\nchannel = musb_ep->dma;\r\nif (fifo_count < musb_ep->packet_sz)\r\ntransfer_size = fifo_count;\r\nelse if (request->short_not_ok)\r\ntransfer_size = min_t(unsigned int,\r\nrequest->length -\r\nrequest->actual,\r\nchannel->max_len);\r\nelse\r\ntransfer_size = min_t(unsigned int,\r\nrequest->length -\r\nrequest->actual,\r\n(unsigned)fifo_count);\r\ncsr &= ~MUSB_RXCSR_DMAMODE;\r\ncsr |= (MUSB_RXCSR_DMAENAB |\r\nMUSB_RXCSR_AUTOCLEAR);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nif (transfer_size <= musb_ep->packet_sz) {\r\nmusb_ep->dma->desired_mode = 0;\r\n} else {\r\nmusb_ep->dma->desired_mode = 1;\r\ncsr |= MUSB_RXCSR_DMAMODE;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\nif (c->channel_program(channel,\r\nmusb_ep->packet_sz,\r\nchannel->desired_mode,\r\nrequest->dma\r\n+ request->actual,\r\ntransfer_size))\r\nreturn;\r\n}\r\nlen = request->length - request->actual;\r\nmusb_dbg(musb, "%s OUT/RX pio fifo %d/%d, maxpacket %d",\r\nmusb_ep->end_point.name,\r\nfifo_count, len,\r\nmusb_ep->packet_sz);\r\nfifo_count = min_t(unsigned, len, fifo_count);\r\nif (tusb_dma_omap(musb)) {\r\nstruct dma_controller *c = musb->dma_controller;\r\nstruct dma_channel *channel = musb_ep->dma;\r\nu32 dma_addr = request->dma + request->actual;\r\nint ret;\r\nret = c->channel_program(channel,\r\nmusb_ep->packet_sz,\r\nchannel->desired_mode,\r\ndma_addr,\r\nfifo_count);\r\nif (ret)\r\nreturn;\r\n}\r\nunmap_dma_buffer(req, musb);\r\ncsr &= ~(MUSB_RXCSR_DMAENAB | MUSB_RXCSR_AUTOCLEAR);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nbuffer_aint_mapped:\r\nmusb_read_fifo(musb_ep->hw_ep, fifo_count, (u8 *)\r\n(request->buf + request->actual));\r\nrequest->actual += fifo_count;\r\ncsr |= MUSB_RXCSR_P_WZC_BITS;\r\ncsr &= ~MUSB_RXCSR_RXPKTRDY;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\n}\r\nif (request->actual == request->length ||\r\nfifo_count < musb_ep->packet_sz)\r\nmusb_g_giveback(musb_ep, request, 0);\r\n}\r\nvoid musb_g_rx(struct musb *musb, u8 epnum)\r\n{\r\nu16 csr;\r\nstruct musb_request *req;\r\nstruct usb_request *request;\r\nvoid __iomem *mbase = musb->mregs;\r\nstruct musb_ep *musb_ep;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nstruct dma_channel *dma;\r\nstruct musb_hw_ep *hw_ep = &musb->endpoints[epnum];\r\nif (hw_ep->is_shared_fifo)\r\nmusb_ep = &hw_ep->ep_in;\r\nelse\r\nmusb_ep = &hw_ep->ep_out;\r\nmusb_ep_select(mbase, epnum);\r\nreq = next_request(musb_ep);\r\nif (!req)\r\nreturn;\r\ntrace_musb_req_rx(req);\r\nrequest = &req->request;\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ndma = is_dma_capable() ? musb_ep->dma : NULL;\r\nmusb_dbg(musb, "<== %s, rxcsr %04x%s %p", musb_ep->end_point.name,\r\ncsr, dma ? " (dma)" : "", request);\r\nif (csr & MUSB_RXCSR_P_SENTSTALL) {\r\ncsr |= MUSB_RXCSR_P_WZC_BITS;\r\ncsr &= ~MUSB_RXCSR_P_SENTSTALL;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nreturn;\r\n}\r\nif (csr & MUSB_RXCSR_P_OVERRUN) {\r\ncsr &= ~MUSB_RXCSR_P_OVERRUN;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nmusb_dbg(musb, "%s iso overrun on %p", musb_ep->name, request);\r\nif (request->status == -EINPROGRESS)\r\nrequest->status = -EOVERFLOW;\r\n}\r\nif (csr & MUSB_RXCSR_INCOMPRX) {\r\nmusb_dbg(musb, "%s, incomprx", musb_ep->end_point.name);\r\n}\r\nif (dma_channel_status(dma) == MUSB_DMA_STATUS_BUSY) {\r\nmusb_dbg(musb, "%s busy, csr %04x",\r\nmusb_ep->end_point.name, csr);\r\nreturn;\r\n}\r\nif (dma && (csr & MUSB_RXCSR_DMAENAB)) {\r\ncsr &= ~(MUSB_RXCSR_AUTOCLEAR\r\n| MUSB_RXCSR_DMAENAB\r\n| MUSB_RXCSR_DMAMODE);\r\nmusb_writew(epio, MUSB_RXCSR,\r\nMUSB_RXCSR_P_WZC_BITS | csr);\r\nrequest->actual += musb_ep->dma->actual_len;\r\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TUSB_OMAP_DMA) || \\r\ndefined(CONFIG_USB_UX500_DMA)\r\nif ((dma->desired_mode == 0 && !hw_ep->rx_double_buffered)\r\n|| (dma->actual_len\r\n& (musb_ep->packet_sz - 1))) {\r\ncsr &= ~MUSB_RXCSR_RXPKTRDY;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\nif ((request->actual < request->length)\r\n&& (musb_ep->dma->actual_len\r\n== musb_ep->packet_sz)) {\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\nif ((csr & MUSB_RXCSR_RXPKTRDY) &&\r\nhw_ep->rx_double_buffered)\r\ngoto exit;\r\nreturn;\r\n}\r\n#endif\r\nmusb_g_giveback(musb_ep, request, 0);\r\nmusb_ep_select(mbase, epnum);\r\nreq = next_request(musb_ep);\r\nif (!req)\r\nreturn;\r\n}\r\n#if defined(CONFIG_USB_INVENTRA_DMA) || defined(CONFIG_USB_TUSB_OMAP_DMA) || \\r\ndefined(CONFIG_USB_UX500_DMA)\r\nexit:\r\n#endif\r\nrxstate(musb, req);\r\n}\r\nstatic int musb_gadget_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nunsigned long flags;\r\nstruct musb_ep *musb_ep;\r\nstruct musb_hw_ep *hw_ep;\r\nvoid __iomem *regs;\r\nstruct musb *musb;\r\nvoid __iomem *mbase;\r\nu8 epnum;\r\nu16 csr;\r\nunsigned tmp;\r\nint status = -EINVAL;\r\nif (!ep || !desc)\r\nreturn -EINVAL;\r\nmusb_ep = to_musb_ep(ep);\r\nhw_ep = musb_ep->hw_ep;\r\nregs = hw_ep->regs;\r\nmusb = musb_ep->musb;\r\nmbase = musb->mregs;\r\nepnum = musb_ep->current_epnum;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (musb_ep->desc) {\r\nstatus = -EBUSY;\r\ngoto fail;\r\n}\r\nmusb_ep->type = usb_endpoint_type(desc);\r\nif (usb_endpoint_num(desc) != epnum)\r\ngoto fail;\r\ntmp = usb_endpoint_maxp_mult(desc) - 1;\r\nif (tmp) {\r\nint ok;\r\nif (usb_endpoint_dir_in(desc))\r\nok = musb->hb_iso_tx;\r\nelse\r\nok = musb->hb_iso_rx;\r\nif (!ok) {\r\nmusb_dbg(musb, "no support for high bandwidth ISO");\r\ngoto fail;\r\n}\r\nmusb_ep->hb_mult = tmp;\r\n} else {\r\nmusb_ep->hb_mult = 0;\r\n}\r\nmusb_ep->packet_sz = usb_endpoint_maxp(desc);\r\ntmp = musb_ep->packet_sz * (musb_ep->hb_mult + 1);\r\nmusb_ep_select(mbase, epnum);\r\nif (usb_endpoint_dir_in(desc)) {\r\nif (hw_ep->is_shared_fifo)\r\nmusb_ep->is_in = 1;\r\nif (!musb_ep->is_in)\r\ngoto fail;\r\nif (tmp > hw_ep->max_packet_sz_tx) {\r\nmusb_dbg(musb, "packet size beyond hardware FIFO size");\r\ngoto fail;\r\n}\r\nmusb->intrtxe |= (1 << epnum);\r\nmusb_writew(mbase, MUSB_INTRTXE, musb->intrtxe);\r\nif (musb->double_buffer_not_ok) {\r\nmusb_writew(regs, MUSB_TXMAXP, hw_ep->max_packet_sz_tx);\r\n} else {\r\nif (can_bulk_split(musb, musb_ep->type))\r\nmusb_ep->hb_mult = (hw_ep->max_packet_sz_tx /\r\nmusb_ep->packet_sz) - 1;\r\nmusb_writew(regs, MUSB_TXMAXP, musb_ep->packet_sz\r\n| (musb_ep->hb_mult << 11));\r\n}\r\ncsr = MUSB_TXCSR_MODE | MUSB_TXCSR_CLRDATATOG;\r\nif (musb_readw(regs, MUSB_TXCSR)\r\n& MUSB_TXCSR_FIFONOTEMPTY)\r\ncsr |= MUSB_TXCSR_FLUSHFIFO;\r\nif (musb_ep->type == USB_ENDPOINT_XFER_ISOC)\r\ncsr |= MUSB_TXCSR_P_ISO;\r\nmusb_writew(regs, MUSB_TXCSR, csr);\r\nmusb_writew(regs, MUSB_TXCSR, csr);\r\n} else {\r\nif (hw_ep->is_shared_fifo)\r\nmusb_ep->is_in = 0;\r\nif (musb_ep->is_in)\r\ngoto fail;\r\nif (tmp > hw_ep->max_packet_sz_rx) {\r\nmusb_dbg(musb, "packet size beyond hardware FIFO size");\r\ngoto fail;\r\n}\r\nmusb->intrrxe |= (1 << epnum);\r\nmusb_writew(mbase, MUSB_INTRRXE, musb->intrrxe);\r\nif (musb->double_buffer_not_ok)\r\nmusb_writew(regs, MUSB_RXMAXP, hw_ep->max_packet_sz_tx);\r\nelse\r\nmusb_writew(regs, MUSB_RXMAXP, musb_ep->packet_sz\r\n| (musb_ep->hb_mult << 11));\r\nif (hw_ep->is_shared_fifo) {\r\ncsr = musb_readw(regs, MUSB_TXCSR);\r\ncsr &= ~(MUSB_TXCSR_MODE | MUSB_TXCSR_TXPKTRDY);\r\nmusb_writew(regs, MUSB_TXCSR, csr);\r\n}\r\ncsr = MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_CLRDATATOG;\r\nif (musb_ep->type == USB_ENDPOINT_XFER_ISOC)\r\ncsr |= MUSB_RXCSR_P_ISO;\r\nelse if (musb_ep->type == USB_ENDPOINT_XFER_INT)\r\ncsr |= MUSB_RXCSR_DISNYET;\r\nmusb_writew(regs, MUSB_RXCSR, csr);\r\nmusb_writew(regs, MUSB_RXCSR, csr);\r\n}\r\nif (is_dma_capable() && musb->dma_controller) {\r\nstruct dma_controller *c = musb->dma_controller;\r\nmusb_ep->dma = c->channel_alloc(c, hw_ep,\r\n(desc->bEndpointAddress & USB_DIR_IN));\r\n} else\r\nmusb_ep->dma = NULL;\r\nmusb_ep->desc = desc;\r\nmusb_ep->busy = 0;\r\nmusb_ep->wedged = 0;\r\nstatus = 0;\r\npr_debug("%s periph: enabled %s for %s %s, %smaxpacket %d\n",\r\nmusb_driver_name, musb_ep->end_point.name,\r\n({ char *s; switch (musb_ep->type) {\r\ncase USB_ENDPOINT_XFER_BULK: s = "bulk"; break;\r\ncase USB_ENDPOINT_XFER_INT: s = "int"; break;\r\ndefault: s = "iso"; break;\r\n} s; }),\r\nmusb_ep->is_in ? "IN" : "OUT",\r\nmusb_ep->dma ? "dma, " : "",\r\nmusb_ep->packet_sz);\r\nschedule_delayed_work(&musb->irq_work, 0);\r\nfail:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn status;\r\n}\r\nstatic int musb_gadget_disable(struct usb_ep *ep)\r\n{\r\nunsigned long flags;\r\nstruct musb *musb;\r\nu8 epnum;\r\nstruct musb_ep *musb_ep;\r\nvoid __iomem *epio;\r\nint status = 0;\r\nmusb_ep = to_musb_ep(ep);\r\nmusb = musb_ep->musb;\r\nepnum = musb_ep->current_epnum;\r\nepio = musb->endpoints[epnum].regs;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_ep_select(musb->mregs, epnum);\r\nif (musb_ep->is_in) {\r\nmusb->intrtxe &= ~(1 << epnum);\r\nmusb_writew(musb->mregs, MUSB_INTRTXE, musb->intrtxe);\r\nmusb_writew(epio, MUSB_TXMAXP, 0);\r\n} else {\r\nmusb->intrrxe &= ~(1 << epnum);\r\nmusb_writew(musb->mregs, MUSB_INTRRXE, musb->intrrxe);\r\nmusb_writew(epio, MUSB_RXMAXP, 0);\r\n}\r\nnuke(musb_ep, -ESHUTDOWN);\r\nmusb_ep->desc = NULL;\r\nmusb_ep->end_point.desc = NULL;\r\nschedule_delayed_work(&musb->irq_work, 0);\r\nspin_unlock_irqrestore(&(musb->lock), flags);\r\nmusb_dbg(musb, "%s", musb_ep->end_point.name);\r\nreturn status;\r\n}\r\nstruct usb_request *musb_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\r\n{\r\nstruct musb_ep *musb_ep = to_musb_ep(ep);\r\nstruct musb_request *request = NULL;\r\nrequest = kzalloc(sizeof *request, gfp_flags);\r\nif (!request)\r\nreturn NULL;\r\nrequest->request.dma = DMA_ADDR_INVALID;\r\nrequest->epnum = musb_ep->current_epnum;\r\nrequest->ep = musb_ep;\r\ntrace_musb_req_alloc(request);\r\nreturn &request->request;\r\n}\r\nvoid musb_free_request(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct musb_request *request = to_musb_request(req);\r\ntrace_musb_req_free(request);\r\nkfree(request);\r\n}\r\nvoid musb_ep_restart(struct musb *musb, struct musb_request *req)\r\n{\r\ntrace_musb_req_start(req);\r\nmusb_ep_select(musb->mregs, req->epnum);\r\nif (req->tx)\r\ntxstate(musb, req);\r\nelse\r\nrxstate(musb, req);\r\n}\r\nstatic int musb_ep_restart_resume_work(struct musb *musb, void *data)\r\n{\r\nstruct musb_request *req = data;\r\nmusb_ep_restart(musb, req);\r\nreturn 0;\r\n}\r\nstatic int musb_gadget_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct musb_ep *musb_ep;\r\nstruct musb_request *request;\r\nstruct musb *musb;\r\nint status;\r\nunsigned long lockflags;\r\nif (!ep || !req)\r\nreturn -EINVAL;\r\nif (!req->buf)\r\nreturn -ENODATA;\r\nmusb_ep = to_musb_ep(ep);\r\nmusb = musb_ep->musb;\r\nrequest = to_musb_request(req);\r\nrequest->musb = musb;\r\nif (request->ep != musb_ep)\r\nreturn -EINVAL;\r\nstatus = pm_runtime_get(musb->controller);\r\nif ((status != -EINPROGRESS) && status < 0) {\r\ndev_err(musb->controller,\r\n"pm runtime get failed in %s\n",\r\n__func__);\r\npm_runtime_put_noidle(musb->controller);\r\nreturn status;\r\n}\r\nstatus = 0;\r\ntrace_musb_req_enq(request);\r\nrequest->request.actual = 0;\r\nrequest->request.status = -EINPROGRESS;\r\nrequest->epnum = musb_ep->current_epnum;\r\nrequest->tx = musb_ep->is_in;\r\nmap_dma_buffer(request, musb, musb_ep);\r\nspin_lock_irqsave(&musb->lock, lockflags);\r\nif (!musb_ep->desc) {\r\nmusb_dbg(musb, "req %p queued to %s while ep %s",\r\nreq, ep->name, "disabled");\r\nstatus = -ESHUTDOWN;\r\nunmap_dma_buffer(request, musb);\r\ngoto unlock;\r\n}\r\nlist_add_tail(&request->list, &musb_ep->req_list);\r\nif (!musb_ep->busy && &request->list == musb_ep->req_list.next) {\r\nstatus = musb_queue_resume_work(musb,\r\nmusb_ep_restart_resume_work,\r\nrequest);\r\nif (status < 0)\r\ndev_err(musb->controller, "%s resume work: %i\n",\r\n__func__, status);\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&musb->lock, lockflags);\r\npm_runtime_mark_last_busy(musb->controller);\r\npm_runtime_put_autosuspend(musb->controller);\r\nreturn status;\r\n}\r\nstatic int musb_gadget_dequeue(struct usb_ep *ep, struct usb_request *request)\r\n{\r\nstruct musb_ep *musb_ep = to_musb_ep(ep);\r\nstruct musb_request *req = to_musb_request(request);\r\nstruct musb_request *r;\r\nunsigned long flags;\r\nint status = 0;\r\nstruct musb *musb = musb_ep->musb;\r\nif (!ep || !request || req->ep != musb_ep)\r\nreturn -EINVAL;\r\ntrace_musb_req_deq(req);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nlist_for_each_entry(r, &musb_ep->req_list, list) {\r\nif (r == req)\r\nbreak;\r\n}\r\nif (r != req) {\r\ndev_err(musb->controller, "request %p not queued to %s\n",\r\nrequest, ep->name);\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nif (musb_ep->req_list.next != &req->list || musb_ep->busy)\r\nmusb_g_giveback(musb_ep, request, -ECONNRESET);\r\nelse if (is_dma_capable() && musb_ep->dma) {\r\nstruct dma_controller *c = musb->dma_controller;\r\nmusb_ep_select(musb->mregs, musb_ep->current_epnum);\r\nif (c->channel_abort)\r\nstatus = c->channel_abort(musb_ep->dma);\r\nelse\r\nstatus = -EBUSY;\r\nif (status == 0)\r\nmusb_g_giveback(musb_ep, request, -ECONNRESET);\r\n} else {\r\nmusb_g_giveback(musb_ep, request, -ECONNRESET);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn status;\r\n}\r\nstatic int musb_gadget_set_halt(struct usb_ep *ep, int value)\r\n{\r\nstruct musb_ep *musb_ep = to_musb_ep(ep);\r\nu8 epnum = musb_ep->current_epnum;\r\nstruct musb *musb = musb_ep->musb;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nvoid __iomem *mbase;\r\nunsigned long flags;\r\nu16 csr;\r\nstruct musb_request *request;\r\nint status = 0;\r\nif (!ep)\r\nreturn -EINVAL;\r\nmbase = musb->mregs;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif ((USB_ENDPOINT_XFER_ISOC == musb_ep->type)) {\r\nstatus = -EINVAL;\r\ngoto done;\r\n}\r\nmusb_ep_select(mbase, epnum);\r\nrequest = next_request(musb_ep);\r\nif (value) {\r\nif (request) {\r\nmusb_dbg(musb, "request in progress, cannot halt %s",\r\nep->name);\r\nstatus = -EAGAIN;\r\ngoto done;\r\n}\r\nif (musb_ep->is_in) {\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (csr & MUSB_TXCSR_FIFONOTEMPTY) {\r\nmusb_dbg(musb, "FIFO busy, cannot halt %s",\r\nep->name);\r\nstatus = -EAGAIN;\r\ngoto done;\r\n}\r\n}\r\n} else\r\nmusb_ep->wedged = 0;\r\nmusb_dbg(musb, "%s: %s stall", ep->name, value ? "set" : "clear");\r\nif (musb_ep->is_in) {\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\ncsr |= MUSB_TXCSR_P_WZC_BITS\r\n| MUSB_TXCSR_CLRDATATOG;\r\nif (value)\r\ncsr |= MUSB_TXCSR_P_SENDSTALL;\r\nelse\r\ncsr &= ~(MUSB_TXCSR_P_SENDSTALL\r\n| MUSB_TXCSR_P_SENTSTALL);\r\ncsr &= ~MUSB_TXCSR_TXPKTRDY;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n} else {\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_P_WZC_BITS\r\n| MUSB_RXCSR_FLUSHFIFO\r\n| MUSB_RXCSR_CLRDATATOG;\r\nif (value)\r\ncsr |= MUSB_RXCSR_P_SENDSTALL;\r\nelse\r\ncsr &= ~(MUSB_RXCSR_P_SENDSTALL\r\n| MUSB_RXCSR_P_SENTSTALL);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\nif (!musb_ep->busy && !value && request) {\r\nmusb_dbg(musb, "restarting the request");\r\nmusb_ep_restart(musb, request);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn status;\r\n}\r\nstatic int musb_gadget_set_wedge(struct usb_ep *ep)\r\n{\r\nstruct musb_ep *musb_ep = to_musb_ep(ep);\r\nif (!ep)\r\nreturn -EINVAL;\r\nmusb_ep->wedged = 1;\r\nreturn usb_ep_set_halt(ep);\r\n}\r\nstatic int musb_gadget_fifo_status(struct usb_ep *ep)\r\n{\r\nstruct musb_ep *musb_ep = to_musb_ep(ep);\r\nvoid __iomem *epio = musb_ep->hw_ep->regs;\r\nint retval = -EINVAL;\r\nif (musb_ep->desc && !musb_ep->is_in) {\r\nstruct musb *musb = musb_ep->musb;\r\nint epnum = musb_ep->current_epnum;\r\nvoid __iomem *mbase = musb->mregs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_ep_select(mbase, epnum);\r\nretval = musb_readw(epio, MUSB_RXCOUNT);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nreturn retval;\r\n}\r\nstatic void musb_gadget_fifo_flush(struct usb_ep *ep)\r\n{\r\nstruct musb_ep *musb_ep = to_musb_ep(ep);\r\nstruct musb *musb = musb_ep->musb;\r\nu8 epnum = musb_ep->current_epnum;\r\nvoid __iomem *epio = musb->endpoints[epnum].regs;\r\nvoid __iomem *mbase;\r\nunsigned long flags;\r\nu16 csr;\r\nmbase = musb->mregs;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_ep_select(mbase, (u8) epnum);\r\nmusb_writew(mbase, MUSB_INTRTXE, musb->intrtxe & ~(1 << epnum));\r\nif (musb_ep->is_in) {\r\ncsr = musb_readw(epio, MUSB_TXCSR);\r\nif (csr & MUSB_TXCSR_FIFONOTEMPTY) {\r\ncsr |= MUSB_TXCSR_FLUSHFIFO | MUSB_TXCSR_P_WZC_BITS;\r\ncsr &= ~MUSB_TXCSR_TXPKTRDY;\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\nmusb_writew(epio, MUSB_TXCSR, csr);\r\n}\r\n} else {\r\ncsr = musb_readw(epio, MUSB_RXCSR);\r\ncsr |= MUSB_RXCSR_FLUSHFIFO | MUSB_RXCSR_P_WZC_BITS;\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\nmusb_writew(epio, MUSB_RXCSR, csr);\r\n}\r\nmusb_writew(mbase, MUSB_INTRTXE, musb->intrtxe);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nstatic int musb_gadget_get_frame(struct usb_gadget *gadget)\r\n{\r\nstruct musb *musb = gadget_to_musb(gadget);\r\nreturn (int)musb_readw(musb->mregs, MUSB_FRAME);\r\n}\r\nstatic int musb_gadget_wakeup(struct usb_gadget *gadget)\r\n{\r\nstruct musb *musb = gadget_to_musb(gadget);\r\nvoid __iomem *mregs = musb->mregs;\r\nunsigned long flags;\r\nint status = -EINVAL;\r\nu8 power, devctl;\r\nint retries;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_B_PERIPHERAL:\r\nif (musb->may_wakeup && musb->is_suspended)\r\nbreak;\r\ngoto done;\r\ncase OTG_STATE_B_IDLE:\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nmusb_dbg(musb, "Sending SRP: devctl: %02x", devctl);\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\nmusb_writeb(mregs, MUSB_DEVCTL, devctl);\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nretries = 100;\r\nwhile (!(devctl & MUSB_DEVCTL_SESSION)) {\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nif (retries-- < 1)\r\nbreak;\r\n}\r\nretries = 10000;\r\nwhile (devctl & MUSB_DEVCTL_SESSION) {\r\ndevctl = musb_readb(mregs, MUSB_DEVCTL);\r\nif (retries-- < 1)\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\notg_start_srp(musb->xceiv->otg);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_platform_try_idle(musb,\r\njiffies + msecs_to_jiffies(1 * HZ));\r\nstatus = 0;\r\ngoto done;\r\ndefault:\r\nmusb_dbg(musb, "Unhandled wake: %s",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\ngoto done;\r\n}\r\nstatus = 0;\r\npower = musb_readb(mregs, MUSB_POWER);\r\npower |= MUSB_POWER_RESUME;\r\nmusb_writeb(mregs, MUSB_POWER, power);\r\nmusb_dbg(musb, "issue wakeup");\r\nmdelay(2);\r\npower = musb_readb(mregs, MUSB_POWER);\r\npower &= ~MUSB_POWER_RESUME;\r\nmusb_writeb(mregs, MUSB_POWER, power);\r\ndone:\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn status;\r\n}\r\nstatic int\r\nmusb_gadget_set_self_powered(struct usb_gadget *gadget, int is_selfpowered)\r\n{\r\ngadget->is_selfpowered = !!is_selfpowered;\r\nreturn 0;\r\n}\r\nstatic void musb_pullup(struct musb *musb, int is_on)\r\n{\r\nu8 power;\r\npower = musb_readb(musb->mregs, MUSB_POWER);\r\nif (is_on)\r\npower |= MUSB_POWER_SOFTCONN;\r\nelse\r\npower &= ~MUSB_POWER_SOFTCONN;\r\nmusb_dbg(musb, "gadget D+ pullup %s",\r\nis_on ? "on" : "off");\r\nmusb_writeb(musb->mregs, MUSB_POWER, power);\r\n}\r\nstatic int musb_gadget_vbus_draw(struct usb_gadget *gadget, unsigned mA)\r\n{\r\nstruct musb *musb = gadget_to_musb(gadget);\r\nif (!musb->xceiv->set_power)\r\nreturn -EOPNOTSUPP;\r\nreturn usb_phy_set_power(musb->xceiv, mA);\r\n}\r\nstatic void musb_gadget_work(struct work_struct *work)\r\n{\r\nstruct musb *musb;\r\nunsigned long flags;\r\nmusb = container_of(work, struct musb, gadget_work.work);\r\npm_runtime_get_sync(musb->controller);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_pullup(musb, musb->softconnect);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\npm_runtime_mark_last_busy(musb->controller);\r\npm_runtime_put_autosuspend(musb->controller);\r\n}\r\nstatic int musb_gadget_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct musb *musb = gadget_to_musb(gadget);\r\nunsigned long flags;\r\nis_on = !!is_on;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (is_on != musb->softconnect) {\r\nmusb->softconnect = is_on;\r\nschedule_delayed_work(&musb->gadget_work, 0);\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct usb_ep *musb_match_ep(struct usb_gadget *g,\r\nstruct usb_endpoint_descriptor *desc,\r\nstruct usb_ss_ep_comp_descriptor *ep_comp)\r\n{\r\nstruct usb_ep *ep = NULL;\r\nswitch (usb_endpoint_type(desc)) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\ncase USB_ENDPOINT_XFER_BULK:\r\nif (usb_endpoint_dir_in(desc))\r\nep = gadget_find_ep_by_name(g, "ep5in");\r\nelse\r\nep = gadget_find_ep_by_name(g, "ep6out");\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (usb_endpoint_dir_in(desc))\r\nep = gadget_find_ep_by_name(g, "ep1in");\r\nelse\r\nep = gadget_find_ep_by_name(g, "ep2out");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (ep && usb_gadget_ep_match_desc(g, ep, desc, ep_comp))\r\nreturn ep;\r\nreturn NULL;\r\n}\r\nstatic void\r\ninit_peripheral_ep(struct musb *musb, struct musb_ep *ep, u8 epnum, int is_in)\r\n{\r\nstruct musb_hw_ep *hw_ep = musb->endpoints + epnum;\r\nmemset(ep, 0, sizeof *ep);\r\nep->current_epnum = epnum;\r\nep->musb = musb;\r\nep->hw_ep = hw_ep;\r\nep->is_in = is_in;\r\nINIT_LIST_HEAD(&ep->req_list);\r\nsprintf(ep->name, "ep%d%s", epnum,\r\n(!epnum || hw_ep->is_shared_fifo) ? "" : (\r\nis_in ? "in" : "out"));\r\nep->end_point.name = ep->name;\r\nINIT_LIST_HEAD(&ep->end_point.ep_list);\r\nif (!epnum) {\r\nusb_ep_set_maxpacket_limit(&ep->end_point, 64);\r\nep->end_point.caps.type_control = true;\r\nep->end_point.ops = &musb_g_ep0_ops;\r\nmusb->g.ep0 = &ep->end_point;\r\n} else {\r\nif (is_in)\r\nusb_ep_set_maxpacket_limit(&ep->end_point, hw_ep->max_packet_sz_tx);\r\nelse\r\nusb_ep_set_maxpacket_limit(&ep->end_point, hw_ep->max_packet_sz_rx);\r\nep->end_point.caps.type_iso = true;\r\nep->end_point.caps.type_bulk = true;\r\nep->end_point.caps.type_int = true;\r\nep->end_point.ops = &musb_ep_ops;\r\nlist_add_tail(&ep->end_point.ep_list, &musb->g.ep_list);\r\n}\r\nif (!epnum || hw_ep->is_shared_fifo) {\r\nep->end_point.caps.dir_in = true;\r\nep->end_point.caps.dir_out = true;\r\n} else if (is_in)\r\nep->end_point.caps.dir_in = true;\r\nelse\r\nep->end_point.caps.dir_out = true;\r\n}\r\nstatic inline void musb_g_init_endpoints(struct musb *musb)\r\n{\r\nu8 epnum;\r\nstruct musb_hw_ep *hw_ep;\r\nunsigned count = 0;\r\nINIT_LIST_HEAD(&(musb->g.ep_list));\r\nfor (epnum = 0, hw_ep = musb->endpoints;\r\nepnum < musb->nr_endpoints;\r\nepnum++, hw_ep++) {\r\nif (hw_ep->is_shared_fifo ) {\r\ninit_peripheral_ep(musb, &hw_ep->ep_in, epnum, 0);\r\ncount++;\r\n} else {\r\nif (hw_ep->max_packet_sz_tx) {\r\ninit_peripheral_ep(musb, &hw_ep->ep_in,\r\nepnum, 1);\r\ncount++;\r\n}\r\nif (hw_ep->max_packet_sz_rx) {\r\ninit_peripheral_ep(musb, &hw_ep->ep_out,\r\nepnum, 0);\r\ncount++;\r\n}\r\n}\r\n}\r\n}\r\nint musb_gadget_setup(struct musb *musb)\r\n{\r\nint status;\r\nmusb->g.ops = &musb_gadget_operations;\r\nmusb->g.max_speed = USB_SPEED_HIGH;\r\nmusb->g.speed = USB_SPEED_UNKNOWN;\r\nMUSB_DEV_MODE(musb);\r\nmusb->xceiv->otg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nmusb->g.name = musb_driver_name;\r\n#if IS_ENABLED(CONFIG_USB_MUSB_DUAL_ROLE)\r\nmusb->g.is_otg = 1;\r\n#elif IS_ENABLED(CONFIG_USB_MUSB_GADGET)\r\nmusb->g.is_otg = 0;\r\n#endif\r\nINIT_DELAYED_WORK(&musb->gadget_work, musb_gadget_work);\r\nmusb_g_init_endpoints(musb);\r\nmusb->is_active = 0;\r\nmusb_platform_try_idle(musb, 0);\r\nstatus = usb_add_gadget_udc(musb->controller, &musb->g);\r\nif (status)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\nmusb->g.dev.parent = NULL;\r\ndevice_unregister(&musb->g.dev);\r\nreturn status;\r\n}\r\nvoid musb_gadget_cleanup(struct musb *musb)\r\n{\r\nif (musb->port_mode == MUSB_PORT_MODE_HOST)\r\nreturn;\r\ncancel_delayed_work_sync(&musb->gadget_work);\r\nusb_del_gadget_udc(&musb->g);\r\n}\r\nstatic int musb_gadget_start(struct usb_gadget *g,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct musb *musb = gadget_to_musb(g);\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nunsigned long flags;\r\nint retval = 0;\r\nif (driver->max_speed < USB_SPEED_HIGH) {\r\nretval = -EINVAL;\r\ngoto err;\r\n}\r\npm_runtime_get_sync(musb->controller);\r\nmusb->softconnect = 0;\r\nmusb->gadget_driver = driver;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb->is_active = 1;\r\notg_set_peripheral(otg, &musb->g);\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nmusb_start(musb);\r\nif (musb->xceiv->last_event == USB_EVENT_ID)\r\nmusb_platform_set_vbus(musb, 1);\r\npm_runtime_mark_last_busy(musb->controller);\r\npm_runtime_put_autosuspend(musb->controller);\r\nreturn 0;\r\nerr:\r\nreturn retval;\r\n}\r\nstatic int musb_gadget_stop(struct usb_gadget *g)\r\n{\r\nstruct musb *musb = gadget_to_musb(g);\r\nunsigned long flags;\r\npm_runtime_get_sync(musb->controller);\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb_hnp_stop(musb);\r\n(void) musb_gadget_vbus_draw(&musb->g, 0);\r\nmusb->xceiv->otg->state = OTG_STATE_UNDEFINED;\r\nmusb_stop(musb);\r\notg_set_peripheral(musb->xceiv->otg, NULL);\r\nmusb->is_active = 0;\r\nmusb->gadget_driver = NULL;\r\nmusb_platform_try_idle(musb, 0);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nschedule_delayed_work(&musb->irq_work, 0);\r\npm_runtime_mark_last_busy(musb->controller);\r\npm_runtime_put_autosuspend(musb->controller);\r\nreturn 0;\r\n}\r\nvoid musb_g_resume(struct musb *musb)\r\n{\r\nmusb->is_suspended = 0;\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_B_IDLE:\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\ncase OTG_STATE_B_PERIPHERAL:\r\nmusb->is_active = 1;\r\nif (musb->gadget_driver && musb->gadget_driver->resume) {\r\nspin_unlock(&musb->lock);\r\nmusb->gadget_driver->resume(&musb->g);\r\nspin_lock(&musb->lock);\r\n}\r\nbreak;\r\ndefault:\r\nWARNING("unhandled RESUME transition (%s)\n",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\n}\r\n}\r\nvoid musb_g_suspend(struct musb *musb)\r\n{\r\nu8 devctl;\r\ndevctl = musb_readb(musb->mregs, MUSB_DEVCTL);\r\nmusb_dbg(musb, "musb_g_suspend: devctl %02x", devctl);\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_B_IDLE:\r\nif ((devctl & MUSB_DEVCTL_VBUS) == MUSB_DEVCTL_VBUS)\r\nmusb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;\r\nbreak;\r\ncase OTG_STATE_B_PERIPHERAL:\r\nmusb->is_suspended = 1;\r\nif (musb->gadget_driver && musb->gadget_driver->suspend) {\r\nspin_unlock(&musb->lock);\r\nmusb->gadget_driver->suspend(&musb->g);\r\nspin_lock(&musb->lock);\r\n}\r\nbreak;\r\ndefault:\r\nWARNING("unhandled SUSPEND transition (%s)",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\n}\r\n}\r\nvoid musb_g_wakeup(struct musb *musb)\r\n{\r\nmusb_gadget_wakeup(&musb->g);\r\n}\r\nvoid musb_g_disconnect(struct musb *musb)\r\n{\r\nvoid __iomem *mregs = musb->mregs;\r\nu8 devctl = musb_readb(mregs, MUSB_DEVCTL);\r\nmusb_dbg(musb, "musb_g_disconnect: devctl %02x", devctl);\r\nmusb_writeb(mregs, MUSB_DEVCTL, devctl & MUSB_DEVCTL_SESSION);\r\n(void) musb_gadget_vbus_draw(&musb->g, 0);\r\nmusb->g.speed = USB_SPEED_UNKNOWN;\r\nif (musb->gadget_driver && musb->gadget_driver->disconnect) {\r\nspin_unlock(&musb->lock);\r\nmusb->gadget_driver->disconnect(&musb->g);\r\nspin_lock(&musb->lock);\r\n}\r\nswitch (musb->xceiv->otg->state) {\r\ndefault:\r\nmusb_dbg(musb, "Unhandled disconnect %s, setting a_idle",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\nmusb->xceiv->otg->state = OTG_STATE_A_IDLE;\r\nMUSB_HST_MODE(musb);\r\nbreak;\r\ncase OTG_STATE_A_PERIPHERAL:\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\r\nMUSB_HST_MODE(musb);\r\nbreak;\r\ncase OTG_STATE_B_WAIT_ACON:\r\ncase OTG_STATE_B_HOST:\r\ncase OTG_STATE_B_PERIPHERAL:\r\ncase OTG_STATE_B_IDLE:\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nbreak;\r\ncase OTG_STATE_B_SRP_INIT:\r\nbreak;\r\n}\r\nmusb->is_active = 0;\r\n}\r\nvoid musb_g_reset(struct musb *musb)\r\n__releases(musb->lock)\r\n__acquires(musb->lock)\r\n{\r\nvoid __iomem *mbase = musb->mregs;\r\nu8 devctl = musb_readb(mbase, MUSB_DEVCTL);\r\nu8 power;\r\nmusb_dbg(musb, "<== %s driver '%s'",\r\n(devctl & MUSB_DEVCTL_BDEVICE)\r\n? "B-Device" : "A-Device",\r\nmusb->gadget_driver\r\n? musb->gadget_driver->driver.name\r\n: NULL\r\n);\r\nif (musb->gadget_driver && musb->g.speed != USB_SPEED_UNKNOWN) {\r\nspin_unlock(&musb->lock);\r\nusb_gadget_udc_reset(&musb->g, musb->gadget_driver);\r\nspin_lock(&musb->lock);\r\n}\r\nelse if (devctl & MUSB_DEVCTL_HR)\r\nmusb_writeb(mbase, MUSB_DEVCTL, MUSB_DEVCTL_SESSION);\r\npower = musb_readb(mbase, MUSB_POWER);\r\nmusb->g.speed = (power & MUSB_POWER_HSMODE)\r\n? USB_SPEED_HIGH : USB_SPEED_FULL;\r\nmusb->is_active = 1;\r\nmusb->is_suspended = 0;\r\nMUSB_DEV_MODE(musb);\r\nmusb->address = 0;\r\nmusb->ep0_state = MUSB_EP0_STAGE_SETUP;\r\nmusb->may_wakeup = 0;\r\nmusb->g.b_hnp_enable = 0;\r\nmusb->g.a_alt_hnp_support = 0;\r\nmusb->g.a_hnp_support = 0;\r\nmusb->g.quirk_zlp_not_supp = 1;\r\nif (!musb->g.is_otg) {\r\nmusb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;\r\nmusb->g.is_a_peripheral = 0;\r\n} else if (devctl & MUSB_DEVCTL_BDEVICE) {\r\nmusb->xceiv->otg->state = OTG_STATE_B_PERIPHERAL;\r\nmusb->g.is_a_peripheral = 0;\r\n} else {\r\nmusb->xceiv->otg->state = OTG_STATE_A_PERIPHERAL;\r\nmusb->g.is_a_peripheral = 1;\r\n}\r\n(void) musb_gadget_vbus_draw(&musb->g, 8);\r\n}
