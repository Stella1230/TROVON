struct device_node *spu_devnode(struct spu *spu)\r\n{\r\nreturn spu->devnode;\r\n}\r\nstatic u64 __init find_spu_unit_number(struct device_node *spe)\r\n{\r\nconst unsigned int *prop;\r\nint proplen;\r\nprop = of_get_property(spe, "physical-id", &proplen);\r\nif (proplen == 4)\r\nreturn (u64)*prop;\r\nprop = of_get_property(spe, "unit-id", &proplen);\r\nif (proplen == 4)\r\nreturn (u64)*prop;\r\nprop = of_get_property(spe, "reg", &proplen);\r\nif (proplen == 4)\r\nreturn (u64)*prop;\r\nreturn 0;\r\n}\r\nstatic void spu_unmap(struct spu *spu)\r\n{\r\nif (!firmware_has_feature(FW_FEATURE_LPAR))\r\niounmap(spu->priv1);\r\niounmap(spu->priv2);\r\niounmap(spu->problem);\r\niounmap((__force u8 __iomem *)spu->local_store);\r\n}\r\nstatic int __init spu_map_interrupts_old(struct spu *spu,\r\nstruct device_node *np)\r\n{\r\nunsigned int isrc;\r\nconst u32 *tmp;\r\nint nid;\r\ntmp = of_get_property(np, "isrc", NULL);\r\nif (!tmp)\r\nreturn -ENODEV;\r\nisrc = tmp[0];\r\ntmp = of_get_property(np->parent->parent, "node-id", NULL);\r\nif (!tmp) {\r\nprintk(KERN_WARNING "%s: can't find node-id\n", __func__);\r\nnid = spu->node;\r\n} else\r\nnid = tmp[0];\r\nisrc |= nid << IIC_IRQ_NODE_SHIFT;\r\nspu->irqs[0] = irq_create_mapping(NULL, IIC_IRQ_CLASS_0 | isrc);\r\nspu->irqs[1] = irq_create_mapping(NULL, IIC_IRQ_CLASS_1 | isrc);\r\nspu->irqs[2] = irq_create_mapping(NULL, IIC_IRQ_CLASS_2 | isrc);\r\nif (!spu->irqs[2])\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void __iomem * __init spu_map_prop_old(struct spu *spu,\r\nstruct device_node *n,\r\nconst char *name)\r\n{\r\nconst struct address_prop {\r\nunsigned long address;\r\nunsigned int len;\r\n} __attribute__((packed)) *prop;\r\nint proplen;\r\nprop = of_get_property(n, name, &proplen);\r\nif (prop == NULL || proplen != sizeof (struct address_prop))\r\nreturn NULL;\r\nreturn ioremap(prop->address, prop->len);\r\n}\r\nstatic int __init spu_map_device_old(struct spu *spu)\r\n{\r\nstruct device_node *node = spu->devnode;\r\nconst char *prop;\r\nint ret;\r\nret = -ENODEV;\r\nspu->name = of_get_property(node, "name", NULL);\r\nif (!spu->name)\r\ngoto out;\r\nprop = of_get_property(node, "local-store", NULL);\r\nif (!prop)\r\ngoto out;\r\nspu->local_store_phys = *(unsigned long *)prop;\r\nspu->local_store = (void __force *)\r\nspu_map_prop_old(spu, node, "local-store");\r\nif (!spu->local_store)\r\ngoto out;\r\nprop = of_get_property(node, "problem", NULL);\r\nif (!prop)\r\ngoto out_unmap;\r\nspu->problem_phys = *(unsigned long *)prop;\r\nspu->problem = spu_map_prop_old(spu, node, "problem");\r\nif (!spu->problem)\r\ngoto out_unmap;\r\nspu->priv2 = spu_map_prop_old(spu, node, "priv2");\r\nif (!spu->priv2)\r\ngoto out_unmap;\r\nif (!firmware_has_feature(FW_FEATURE_LPAR)) {\r\nspu->priv1 = spu_map_prop_old(spu, node, "priv1");\r\nif (!spu->priv1)\r\ngoto out_unmap;\r\n}\r\nret = 0;\r\ngoto out;\r\nout_unmap:\r\nspu_unmap(spu);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init spu_map_interrupts(struct spu *spu, struct device_node *np)\r\n{\r\nstruct of_phandle_args oirq;\r\nint ret;\r\nint i;\r\nfor (i=0; i < 3; i++) {\r\nret = of_irq_parse_one(np, i, &oirq);\r\nif (ret) {\r\npr_debug("spu_new: failed to get irq %d\n", i);\r\ngoto err;\r\n}\r\nret = -EINVAL;\r\npr_debug(" irq %d no 0x%x on %s\n", i, oirq.args[0],\r\noirq.np->full_name);\r\nspu->irqs[i] = irq_create_of_mapping(&oirq);\r\nif (!spu->irqs[i]) {\r\npr_debug("spu_new: failed to map it !\n");\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\npr_debug("failed to map irq %x for spu %s\n", *oirq.args,\r\nspu->name);\r\nfor (; i >= 0; i--) {\r\nif (spu->irqs[i])\r\nirq_dispose_mapping(spu->irqs[i]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int spu_map_resource(struct spu *spu, int nr,\r\nvoid __iomem** virt, unsigned long *phys)\r\n{\r\nstruct device_node *np = spu->devnode;\r\nstruct resource resource = { };\r\nunsigned long len;\r\nint ret;\r\nret = of_address_to_resource(np, nr, &resource);\r\nif (ret)\r\nreturn ret;\r\nif (phys)\r\n*phys = resource.start;\r\nlen = resource_size(&resource);\r\n*virt = ioremap(resource.start, len);\r\nif (!*virt)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int __init spu_map_device(struct spu *spu)\r\n{\r\nstruct device_node *np = spu->devnode;\r\nint ret = -ENODEV;\r\nspu->name = of_get_property(np, "name", NULL);\r\nif (!spu->name)\r\ngoto out;\r\nret = spu_map_resource(spu, 0, (void __iomem**)&spu->local_store,\r\n&spu->local_store_phys);\r\nif (ret) {\r\npr_debug("spu_new: failed to map %s resource 0\n",\r\nnp->full_name);\r\ngoto out;\r\n}\r\nret = spu_map_resource(spu, 1, (void __iomem**)&spu->problem,\r\n&spu->problem_phys);\r\nif (ret) {\r\npr_debug("spu_new: failed to map %s resource 1\n",\r\nnp->full_name);\r\ngoto out_unmap;\r\n}\r\nret = spu_map_resource(spu, 2, (void __iomem**)&spu->priv2, NULL);\r\nif (ret) {\r\npr_debug("spu_new: failed to map %s resource 2\n",\r\nnp->full_name);\r\ngoto out_unmap;\r\n}\r\nif (!firmware_has_feature(FW_FEATURE_LPAR))\r\nret = spu_map_resource(spu, 3,\r\n(void __iomem**)&spu->priv1, NULL);\r\nif (ret) {\r\npr_debug("spu_new: failed to map %s resource 3\n",\r\nnp->full_name);\r\ngoto out_unmap;\r\n}\r\npr_debug("spu_new: %s maps:\n", np->full_name);\r\npr_debug(" local store : 0x%016lx -> 0x%p\n",\r\nspu->local_store_phys, spu->local_store);\r\npr_debug(" problem state : 0x%016lx -> 0x%p\n",\r\nspu->problem_phys, spu->problem);\r\npr_debug(" priv2 : 0x%p\n", spu->priv2);\r\npr_debug(" priv1 : 0x%p\n", spu->priv1);\r\nreturn 0;\r\nout_unmap:\r\nspu_unmap(spu);\r\nout:\r\npr_debug("failed to map spe %s: %d\n", spu->name, ret);\r\nreturn ret;\r\n}\r\nstatic int __init of_enumerate_spus(int (*fn)(void *data))\r\n{\r\nint ret;\r\nstruct device_node *node;\r\nunsigned int n = 0;\r\nret = -ENODEV;\r\nfor (node = of_find_node_by_type(NULL, "spe");\r\nnode; node = of_find_node_by_type(node, "spe")) {\r\nret = fn(node);\r\nif (ret) {\r\nprintk(KERN_WARNING "%s: Error initializing %s\n",\r\n__func__, node->name);\r\nbreak;\r\n}\r\nn++;\r\n}\r\nreturn ret ? ret : n;\r\n}\r\nstatic int __init of_create_spu(struct spu *spu, void *data)\r\n{\r\nint ret;\r\nstruct device_node *spe = (struct device_node *)data;\r\nstatic int legacy_map = 0, legacy_irq = 0;\r\nspu->devnode = of_node_get(spe);\r\nspu->spe_id = find_spu_unit_number(spe);\r\nspu->node = of_node_to_nid(spe);\r\nif (spu->node >= MAX_NUMNODES) {\r\nprintk(KERN_WARNING "SPE %s on node %d ignored,"\r\n" node number too big\n", spe->full_name, spu->node);\r\nprintk(KERN_WARNING "Check if CONFIG_NUMA is enabled.\n");\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = spu_map_device(spu);\r\nif (ret) {\r\nif (!legacy_map) {\r\nlegacy_map = 1;\r\nprintk(KERN_WARNING "%s: Legacy device tree found, "\r\n"trying to map old style\n", __func__);\r\n}\r\nret = spu_map_device_old(spu);\r\nif (ret) {\r\nprintk(KERN_ERR "Unable to map %s\n",\r\nspu->name);\r\ngoto out;\r\n}\r\n}\r\nret = spu_map_interrupts(spu, spe);\r\nif (ret) {\r\nif (!legacy_irq) {\r\nlegacy_irq = 1;\r\nprintk(KERN_WARNING "%s: Legacy device tree found, "\r\n"trying old style irq\n", __func__);\r\n}\r\nret = spu_map_interrupts_old(spu, spe);\r\nif (ret) {\r\nprintk(KERN_ERR "%s: could not map interrupts\n",\r\nspu->name);\r\ngoto out_unmap;\r\n}\r\n}\r\npr_debug("Using SPE %s %p %p %p %p %d\n", spu->name,\r\nspu->local_store, spu->problem, spu->priv1,\r\nspu->priv2, spu->number);\r\ngoto out;\r\nout_unmap:\r\nspu_unmap(spu);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int of_destroy_spu(struct spu *spu)\r\n{\r\nspu_unmap(spu);\r\nof_node_put(spu->devnode);\r\nreturn 0;\r\n}\r\nstatic void enable_spu_by_master_run(struct spu_context *ctx)\r\n{\r\nctx->ops->master_start(ctx);\r\n}\r\nstatic void disable_spu_by_master_run(struct spu_context *ctx)\r\n{\r\nctx->ops->master_stop(ctx);\r\n}\r\nstatic struct spu *spu_lookup_reg(int node, u32 reg)\r\n{\r\nstruct spu *spu;\r\nconst u32 *spu_reg;\r\nlist_for_each_entry(spu, &cbe_spu_info[node].spus, cbe_list) {\r\nspu_reg = of_get_property(spu_devnode(spu), "reg", NULL);\r\nif (*spu_reg == reg)\r\nreturn spu;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void init_affinity_qs20_harcoded(void)\r\n{\r\nint node, i;\r\nstruct spu *last_spu, *spu;\r\nu32 reg;\r\nfor (node = 0; node < MAX_NUMNODES; node++) {\r\nlast_spu = NULL;\r\nfor (i = 0; i < QS20_SPES_PER_BE; i++) {\r\nreg = qs20_reg_idxs[i];\r\nspu = spu_lookup_reg(node, reg);\r\nif (!spu)\r\ncontinue;\r\nspu->has_mem_affinity = qs20_reg_memory[reg];\r\nif (last_spu)\r\nlist_add_tail(&spu->aff_list,\r\n&last_spu->aff_list);\r\nlast_spu = spu;\r\n}\r\n}\r\n}\r\nstatic int of_has_vicinity(void)\r\n{\r\nstruct device_node *dn;\r\nfor_each_node_by_type(dn, "spe") {\r\nif (of_find_property(dn, "vicinity", NULL)) {\r\nof_node_put(dn);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct spu *devnode_spu(int cbe, struct device_node *dn)\r\n{\r\nstruct spu *spu;\r\nlist_for_each_entry(spu, &cbe_spu_info[cbe].spus, cbe_list)\r\nif (spu_devnode(spu) == dn)\r\nreturn spu;\r\nreturn NULL;\r\n}\r\nstatic struct spu *\r\nneighbour_spu(int cbe, struct device_node *target, struct device_node *avoid)\r\n{\r\nstruct spu *spu;\r\nstruct device_node *spu_dn;\r\nconst phandle *vic_handles;\r\nint lenp, i;\r\nlist_for_each_entry(spu, &cbe_spu_info[cbe].spus, cbe_list) {\r\nspu_dn = spu_devnode(spu);\r\nif (spu_dn == avoid)\r\ncontinue;\r\nvic_handles = of_get_property(spu_dn, "vicinity", &lenp);\r\nfor (i=0; i < (lenp / sizeof(phandle)); i++) {\r\nif (vic_handles[i] == target->phandle)\r\nreturn spu;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void init_affinity_node(int cbe)\r\n{\r\nstruct spu *spu, *last_spu;\r\nstruct device_node *vic_dn, *last_spu_dn;\r\nphandle avoid_ph;\r\nconst phandle *vic_handles;\r\nconst char *name;\r\nint lenp, i, added;\r\nlast_spu = list_first_entry(&cbe_spu_info[cbe].spus, struct spu,\r\ncbe_list);\r\navoid_ph = 0;\r\nfor (added = 1; added < cbe_spu_info[cbe].n_spus; added++) {\r\nlast_spu_dn = spu_devnode(last_spu);\r\nvic_handles = of_get_property(last_spu_dn, "vicinity", &lenp);\r\nfor (i = 0; i < (lenp / sizeof(phandle)); i++) {\r\nif (vic_handles[i] == avoid_ph)\r\ncontinue;\r\nvic_dn = of_find_node_by_phandle(vic_handles[i]);\r\nif (!vic_dn)\r\ncontinue;\r\nname = of_get_property(vic_dn, "name", NULL);\r\nif (!name)\r\ncontinue;\r\nif (strcmp(name, "spe") == 0) {\r\nspu = devnode_spu(cbe, vic_dn);\r\navoid_ph = last_spu_dn->phandle;\r\n} else {\r\nspu = neighbour_spu(cbe, vic_dn, last_spu_dn);\r\nif (!spu)\r\ncontinue;\r\nif (!strcmp(name, "mic-tm")) {\r\nlast_spu->has_mem_affinity = 1;\r\nspu->has_mem_affinity = 1;\r\n}\r\navoid_ph = vic_dn->phandle;\r\n}\r\nlist_add_tail(&spu->aff_list, &last_spu->aff_list);\r\nlast_spu = spu;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void init_affinity_fw(void)\r\n{\r\nint cbe;\r\nfor (cbe = 0; cbe < MAX_NUMNODES; cbe++)\r\ninit_affinity_node(cbe);\r\n}\r\nstatic int __init init_affinity(void)\r\n{\r\nif (of_has_vicinity()) {\r\ninit_affinity_fw();\r\n} else {\r\nif (of_machine_is_compatible("IBM,CPBW-1.0"))\r\ninit_affinity_qs20_harcoded();\r\nelse\r\nprintk("No affinity configuration found\n");\r\n}\r\nreturn 0;\r\n}
