static int set_target(struct cpufreq_policy *policy, unsigned int index)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nreturn dev_pm_opp_set_rate(priv->cpu_dev,\r\npolicy->freq_table[index].frequency * 1000);\r\n}\r\nstatic const char *find_supply_name(struct device *dev)\r\n{\r\nstruct device_node *np;\r\nstruct property *pp;\r\nint cpu = dev->id;\r\nconst char *name = NULL;\r\nnp = of_node_get(dev->of_node);\r\nif (WARN_ON(!np))\r\nreturn NULL;\r\nif (!cpu) {\r\npp = of_find_property(np, "cpu0-supply", NULL);\r\nif (pp) {\r\nname = "cpu0";\r\ngoto node_put;\r\n}\r\n}\r\npp = of_find_property(np, "cpu-supply", NULL);\r\nif (pp) {\r\nname = "cpu";\r\ngoto node_put;\r\n}\r\ndev_dbg(dev, "no regulator for cpu%d\n", cpu);\r\nnode_put:\r\nof_node_put(np);\r\nreturn name;\r\n}\r\nstatic int resources_available(void)\r\n{\r\nstruct device *cpu_dev;\r\nstruct regulator *cpu_reg;\r\nstruct clk *cpu_clk;\r\nint ret = 0;\r\nconst char *name;\r\ncpu_dev = get_cpu_device(0);\r\nif (!cpu_dev) {\r\npr_err("failed to get cpu0 device\n");\r\nreturn -ENODEV;\r\n}\r\ncpu_clk = clk_get(cpu_dev, NULL);\r\nret = PTR_ERR_OR_ZERO(cpu_clk);\r\nif (ret) {\r\nif (ret == -EPROBE_DEFER)\r\ndev_dbg(cpu_dev, "clock not ready, retry\n");\r\nelse\r\ndev_err(cpu_dev, "failed to get clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nclk_put(cpu_clk);\r\nname = find_supply_name(cpu_dev);\r\nif (!name)\r\nreturn 0;\r\ncpu_reg = regulator_get_optional(cpu_dev, name);\r\nret = PTR_ERR_OR_ZERO(cpu_reg);\r\nif (ret) {\r\nif (ret == -EPROBE_DEFER)\r\ndev_dbg(cpu_dev, "cpu0 regulator not ready, retry\n");\r\nelse\r\ndev_dbg(cpu_dev, "no regulator for cpu0: %d\n", ret);\r\nreturn ret;\r\n}\r\nregulator_put(cpu_reg);\r\nreturn 0;\r\n}\r\nstatic int cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_frequency_table *freq_table;\r\nstruct opp_table *opp_table = NULL;\r\nstruct private_data *priv;\r\nstruct device *cpu_dev;\r\nstruct clk *cpu_clk;\r\nunsigned int transition_latency;\r\nbool fallback = false;\r\nconst char *name;\r\nint ret;\r\ncpu_dev = get_cpu_device(policy->cpu);\r\nif (!cpu_dev) {\r\npr_err("failed to get cpu%d device\n", policy->cpu);\r\nreturn -ENODEV;\r\n}\r\ncpu_clk = clk_get(cpu_dev, NULL);\r\nif (IS_ERR(cpu_clk)) {\r\nret = PTR_ERR(cpu_clk);\r\ndev_err(cpu_dev, "%s: failed to get clk: %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nret = dev_pm_opp_of_get_sharing_cpus(cpu_dev, policy->cpus);\r\nif (ret) {\r\nif (ret != -ENOENT)\r\ngoto out_put_clk;\r\nif (dev_pm_opp_get_sharing_cpus(cpu_dev, policy->cpus))\r\nfallback = true;\r\n}\r\nname = find_supply_name(cpu_dev);\r\nif (name) {\r\nopp_table = dev_pm_opp_set_regulators(cpu_dev, &name, 1);\r\nif (IS_ERR(opp_table)) {\r\nret = PTR_ERR(opp_table);\r\ndev_err(cpu_dev, "Failed to set regulator for cpu%d: %d\n",\r\npolicy->cpu, ret);\r\ngoto out_put_clk;\r\n}\r\n}\r\ndev_pm_opp_of_cpumask_add_table(policy->cpus);\r\nret = dev_pm_opp_get_opp_count(cpu_dev);\r\nif (ret <= 0) {\r\ndev_dbg(cpu_dev, "OPP table is not ready, deferring probe\n");\r\nret = -EPROBE_DEFER;\r\ngoto out_free_opp;\r\n}\r\nif (fallback) {\r\ncpumask_setall(policy->cpus);\r\nret = dev_pm_opp_set_sharing_cpus(cpu_dev, policy->cpus);\r\nif (ret)\r\ndev_err(cpu_dev, "%s: failed to mark OPPs as shared: %d\n",\r\n__func__, ret);\r\n}\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv) {\r\nret = -ENOMEM;\r\ngoto out_free_opp;\r\n}\r\npriv->reg_name = name;\r\npriv->opp_table = opp_table;\r\nret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);\r\nif (ret) {\r\ndev_err(cpu_dev, "failed to init cpufreq table: %d\n", ret);\r\ngoto out_free_priv;\r\n}\r\npriv->cpu_dev = cpu_dev;\r\npolicy->driver_data = priv;\r\npolicy->clk = cpu_clk;\r\npolicy->suspend_freq = dev_pm_opp_get_suspend_opp_freq(cpu_dev) / 1000;\r\nret = cpufreq_table_validate_and_show(policy, freq_table);\r\nif (ret) {\r\ndev_err(cpu_dev, "%s: invalid frequency table: %d\n", __func__,\r\nret);\r\ngoto out_free_cpufreq_table;\r\n}\r\nif (policy_has_boost_freq(policy)) {\r\nret = cpufreq_enable_boost_support();\r\nif (ret)\r\ngoto out_free_cpufreq_table;\r\ncpufreq_dt_attr[1] = &cpufreq_freq_attr_scaling_boost_freqs;\r\n}\r\ntransition_latency = dev_pm_opp_get_max_transition_latency(cpu_dev);\r\nif (!transition_latency)\r\ntransition_latency = CPUFREQ_ETERNAL;\r\npolicy->cpuinfo.transition_latency = transition_latency;\r\nreturn 0;\r\nout_free_cpufreq_table:\r\ndev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);\r\nout_free_priv:\r\nkfree(priv);\r\nout_free_opp:\r\ndev_pm_opp_of_cpumask_remove_table(policy->cpus);\r\nif (name)\r\ndev_pm_opp_put_regulators(opp_table);\r\nout_put_clk:\r\nclk_put(cpu_clk);\r\nreturn ret;\r\n}\r\nstatic int cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\ncpufreq_cooling_unregister(priv->cdev);\r\ndev_pm_opp_free_cpufreq_table(priv->cpu_dev, &policy->freq_table);\r\ndev_pm_opp_of_cpumask_remove_table(policy->related_cpus);\r\nif (priv->reg_name)\r\ndev_pm_opp_put_regulators(priv->opp_table);\r\nclk_put(policy->clk);\r\nkfree(priv);\r\nreturn 0;\r\n}\r\nstatic void cpufreq_ready(struct cpufreq_policy *policy)\r\n{\r\nstruct private_data *priv = policy->driver_data;\r\nstruct device_node *np = of_node_get(priv->cpu_dev->of_node);\r\nif (WARN_ON(!np))\r\nreturn;\r\nif (of_find_property(np, "#cooling-cells", NULL)) {\r\nu32 power_coefficient = 0;\r\nof_property_read_u32(np, "dynamic-power-coefficient",\r\n&power_coefficient);\r\npriv->cdev = of_cpufreq_power_cooling_register(np,\r\npolicy->related_cpus, power_coefficient, NULL);\r\nif (IS_ERR(priv->cdev)) {\r\ndev_err(priv->cpu_dev,\r\n"running cpufreq without cooling device: %ld\n",\r\nPTR_ERR(priv->cdev));\r\npriv->cdev = NULL;\r\n}\r\n}\r\nof_node_put(np);\r\n}\r\nstatic int dt_cpufreq_probe(struct platform_device *pdev)\r\n{\r\nstruct cpufreq_dt_platform_data *data = dev_get_platdata(&pdev->dev);\r\nint ret;\r\nret = resources_available();\r\nif (ret)\r\nreturn ret;\r\nif (data && data->have_governor_per_policy)\r\ndt_cpufreq_driver.flags |= CPUFREQ_HAVE_GOVERNOR_PER_POLICY;\r\nret = cpufreq_register_driver(&dt_cpufreq_driver);\r\nif (ret)\r\ndev_err(&pdev->dev, "failed register driver: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int dt_cpufreq_remove(struct platform_device *pdev)\r\n{\r\ncpufreq_unregister_driver(&dt_cpufreq_driver);\r\nreturn 0;\r\n}
