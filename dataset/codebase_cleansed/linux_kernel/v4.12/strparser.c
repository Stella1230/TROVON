static inline struct _strp_rx_msg *_strp_rx_msg(struct sk_buff *skb)\r\n{\r\nreturn (struct _strp_rx_msg *)((void *)skb->cb +\r\noffsetof(struct qdisc_skb_cb, data));\r\n}\r\nstatic void strp_abort_rx_strp(struct strparser *strp, int err)\r\n{\r\nstruct sock *csk = strp->sk;\r\ndel_timer(&strp->rx_msg_timer);\r\nif (strp->rx_stopped)\r\nreturn;\r\nstrp->rx_stopped = 1;\r\ncsk->sk_err = err;\r\ncsk->sk_error_report(csk);\r\n}\r\nstatic void strp_start_rx_timer(struct strparser *strp)\r\n{\r\nif (strp->sk->sk_rcvtimeo)\r\nmod_timer(&strp->rx_msg_timer, strp->sk->sk_rcvtimeo);\r\n}\r\nstatic void strp_parser_err(struct strparser *strp, int err,\r\nread_descriptor_t *desc)\r\n{\r\ndesc->error = err;\r\nkfree_skb(strp->rx_skb_head);\r\nstrp->rx_skb_head = NULL;\r\nstrp->cb.abort_parser(strp, err);\r\n}\r\nstatic inline int strp_peek_len(struct strparser *strp)\r\n{\r\nstruct socket *sock = strp->sk->sk_socket;\r\nreturn sock->ops->peek_len(sock);\r\n}\r\nstatic int strp_recv(read_descriptor_t *desc, struct sk_buff *orig_skb,\r\nunsigned int orig_offset, size_t orig_len)\r\n{\r\nstruct strparser *strp = (struct strparser *)desc->arg.data;\r\nstruct _strp_rx_msg *rxm;\r\nstruct sk_buff *head, *skb;\r\nsize_t eaten = 0, cand_len;\r\nssize_t extra;\r\nint err;\r\nbool cloned_orig = false;\r\nif (strp->rx_paused)\r\nreturn 0;\r\nhead = strp->rx_skb_head;\r\nif (head) {\r\nrxm = _strp_rx_msg(head);\r\nif (unlikely(rxm->early_eaten)) {\r\neaten = orig_len <= rxm->early_eaten ?\r\norig_len : rxm->early_eaten;\r\nrxm->early_eaten -= eaten;\r\nreturn eaten;\r\n}\r\nif (unlikely(orig_offset)) {\r\norig_skb = skb_clone(orig_skb, GFP_ATOMIC);\r\nif (!orig_skb) {\r\nSTRP_STATS_INCR(strp->stats.rx_mem_fail);\r\ndesc->error = -ENOMEM;\r\nreturn 0;\r\n}\r\nif (!pskb_pull(orig_skb, orig_offset)) {\r\nSTRP_STATS_INCR(strp->stats.rx_mem_fail);\r\nkfree_skb(orig_skb);\r\ndesc->error = -ENOMEM;\r\nreturn 0;\r\n}\r\ncloned_orig = true;\r\norig_offset = 0;\r\n}\r\nif (!strp->rx_skb_nextp) {\r\nerr = skb_unclone(head, GFP_ATOMIC);\r\nif (err) {\r\nSTRP_STATS_INCR(strp->stats.rx_mem_fail);\r\ndesc->error = err;\r\nreturn 0;\r\n}\r\nif (unlikely(skb_shinfo(head)->frag_list)) {\r\nif (WARN_ON(head->next)) {\r\ndesc->error = -EINVAL;\r\nreturn 0;\r\n}\r\nskb = alloc_skb(0, GFP_ATOMIC);\r\nif (!skb) {\r\nSTRP_STATS_INCR(strp->stats.rx_mem_fail);\r\ndesc->error = -ENOMEM;\r\nreturn 0;\r\n}\r\nskb->len = head->len;\r\nskb->data_len = head->len;\r\nskb->truesize = head->truesize;\r\n*_strp_rx_msg(skb) = *_strp_rx_msg(head);\r\nstrp->rx_skb_nextp = &head->next;\r\nskb_shinfo(skb)->frag_list = head;\r\nstrp->rx_skb_head = skb;\r\nhead = skb;\r\n} else {\r\nstrp->rx_skb_nextp =\r\n&skb_shinfo(head)->frag_list;\r\n}\r\n}\r\n}\r\nwhile (eaten < orig_len) {\r\nskb = skb_clone(orig_skb, GFP_ATOMIC);\r\nif (!skb) {\r\nSTRP_STATS_INCR(strp->stats.rx_mem_fail);\r\ndesc->error = -ENOMEM;\r\nbreak;\r\n}\r\ncand_len = orig_len - eaten;\r\nhead = strp->rx_skb_head;\r\nif (!head) {\r\nhead = skb;\r\nstrp->rx_skb_head = head;\r\nstrp->rx_skb_nextp = NULL;\r\nrxm = _strp_rx_msg(head);\r\nmemset(rxm, 0, sizeof(*rxm));\r\nrxm->strp.offset = orig_offset + eaten;\r\n} else {\r\nerr = skb_unclone(skb, GFP_ATOMIC);\r\nif (err) {\r\nSTRP_STATS_INCR(strp->stats.rx_mem_fail);\r\ndesc->error = err;\r\nbreak;\r\n}\r\nrxm = _strp_rx_msg(head);\r\n*strp->rx_skb_nextp = skb;\r\nstrp->rx_skb_nextp = &skb->next;\r\nhead->data_len += skb->len;\r\nhead->len += skb->len;\r\nhead->truesize += skb->truesize;\r\n}\r\nif (!rxm->strp.full_len) {\r\nssize_t len;\r\nlen = (*strp->cb.parse_msg)(strp, head);\r\nif (!len) {\r\nif (!rxm->accum_len) {\r\nstrp_start_rx_timer(strp);\r\n}\r\nrxm->accum_len += cand_len;\r\neaten += cand_len;\r\nSTRP_STATS_INCR(strp->stats.rx_need_more_hdr);\r\nWARN_ON(eaten != orig_len);\r\nbreak;\r\n} else if (len < 0) {\r\nif (len == -ESTRPIPE && rxm->accum_len) {\r\nlen = -ENODATA;\r\nstrp->rx_unrecov_intr = 1;\r\n} else {\r\nstrp->rx_interrupted = 1;\r\n}\r\nstrp_parser_err(strp, len, desc);\r\nbreak;\r\n} else if (len > strp->sk->sk_rcvbuf) {\r\nSTRP_STATS_INCR(strp->stats.rx_msg_too_big);\r\nstrp_parser_err(strp, -EMSGSIZE, desc);\r\nbreak;\r\n} else if (len <= (ssize_t)head->len -\r\nskb->len - rxm->strp.offset) {\r\nSTRP_STATS_INCR(strp->stats.rx_bad_hdr_len);\r\nstrp_parser_err(strp, -EPROTO, desc);\r\nbreak;\r\n}\r\nrxm->strp.full_len = len;\r\n}\r\nextra = (ssize_t)(rxm->accum_len + cand_len) -\r\nrxm->strp.full_len;\r\nif (extra < 0) {\r\nif (rxm->strp.full_len - rxm->accum_len >\r\nstrp_peek_len(strp)) {\r\nif (!rxm->accum_len) {\r\nstrp_start_rx_timer(strp);\r\n}\r\nstrp->rx_need_bytes = rxm->strp.full_len -\r\nrxm->accum_len;\r\nrxm->accum_len += cand_len;\r\nrxm->early_eaten = cand_len;\r\nSTRP_STATS_ADD(strp->stats.rx_bytes, cand_len);\r\ndesc->count = 0;\r\nbreak;\r\n}\r\nrxm->accum_len += cand_len;\r\neaten += cand_len;\r\nWARN_ON(eaten != orig_len);\r\nbreak;\r\n}\r\nWARN_ON(extra > cand_len);\r\neaten += (cand_len - extra);\r\ndel_timer(&strp->rx_msg_timer);\r\nstrp->rx_skb_head = NULL;\r\nSTRP_STATS_INCR(strp->stats.rx_msgs);\r\nstrp->cb.rcv_msg(strp, head);\r\nif (unlikely(strp->rx_paused)) {\r\nbreak;\r\n}\r\n}\r\nif (cloned_orig)\r\nkfree_skb(orig_skb);\r\nSTRP_STATS_ADD(strp->stats.rx_bytes, eaten);\r\nreturn eaten;\r\n}\r\nstatic int default_read_sock_done(struct strparser *strp, int err)\r\n{\r\nreturn err;\r\n}\r\nstatic int strp_read_sock(struct strparser *strp)\r\n{\r\nstruct socket *sock = strp->sk->sk_socket;\r\nread_descriptor_t desc;\r\ndesc.arg.data = strp;\r\ndesc.error = 0;\r\ndesc.count = 1;\r\nsock->ops->read_sock(strp->sk, &desc, strp_recv);\r\ndesc.error = strp->cb.read_sock_done(strp, desc.error);\r\nreturn desc.error;\r\n}\r\nvoid strp_data_ready(struct strparser *strp)\r\n{\r\nif (unlikely(strp->rx_stopped))\r\nreturn;\r\nif (sock_owned_by_user(strp->sk)) {\r\nqueue_work(strp_wq, &strp->rx_work);\r\nreturn;\r\n}\r\nif (strp->rx_paused)\r\nreturn;\r\nif (strp->rx_need_bytes) {\r\nif (strp_peek_len(strp) >= strp->rx_need_bytes)\r\nstrp->rx_need_bytes = 0;\r\nelse\r\nreturn;\r\n}\r\nif (strp_read_sock(strp) == -ENOMEM)\r\nqueue_work(strp_wq, &strp->rx_work);\r\n}\r\nstatic void do_strp_rx_work(struct strparser *strp)\r\n{\r\nread_descriptor_t rd_desc;\r\nstruct sock *csk = strp->sk;\r\nlock_sock(csk);\r\nif (unlikely(strp->rx_stopped))\r\ngoto out;\r\nif (strp->rx_paused)\r\ngoto out;\r\nrd_desc.arg.data = strp;\r\nif (strp_read_sock(strp) == -ENOMEM)\r\nqueue_work(strp_wq, &strp->rx_work);\r\nout:\r\nrelease_sock(csk);\r\n}\r\nstatic void strp_rx_work(struct work_struct *w)\r\n{\r\ndo_strp_rx_work(container_of(w, struct strparser, rx_work));\r\n}\r\nstatic void strp_rx_msg_timeout(unsigned long arg)\r\n{\r\nstruct strparser *strp = (struct strparser *)arg;\r\nSTRP_STATS_INCR(strp->stats.rx_msg_timeouts);\r\nlock_sock(strp->sk);\r\nstrp->cb.abort_parser(strp, ETIMEDOUT);\r\nrelease_sock(strp->sk);\r\n}\r\nint strp_init(struct strparser *strp, struct sock *csk,\r\nstruct strp_callbacks *cb)\r\n{\r\nstruct socket *sock = csk->sk_socket;\r\nif (!cb || !cb->rcv_msg || !cb->parse_msg)\r\nreturn -EINVAL;\r\nif (!sock->ops->read_sock || !sock->ops->peek_len)\r\nreturn -EAFNOSUPPORT;\r\nmemset(strp, 0, sizeof(*strp));\r\nstrp->sk = csk;\r\nsetup_timer(&strp->rx_msg_timer, strp_rx_msg_timeout,\r\n(unsigned long)strp);\r\nINIT_WORK(&strp->rx_work, strp_rx_work);\r\nstrp->cb.rcv_msg = cb->rcv_msg;\r\nstrp->cb.parse_msg = cb->parse_msg;\r\nstrp->cb.read_sock_done = cb->read_sock_done ? : default_read_sock_done;\r\nstrp->cb.abort_parser = cb->abort_parser ? : strp_abort_rx_strp;\r\nreturn 0;\r\n}\r\nvoid strp_unpause(struct strparser *strp)\r\n{\r\nstrp->rx_paused = 0;\r\nsmp_mb();\r\nqueue_work(strp_wq, &strp->rx_work);\r\n}\r\nvoid strp_done(struct strparser *strp)\r\n{\r\nWARN_ON(!strp->rx_stopped);\r\ndel_timer_sync(&strp->rx_msg_timer);\r\ncancel_work_sync(&strp->rx_work);\r\nif (strp->rx_skb_head) {\r\nkfree_skb(strp->rx_skb_head);\r\nstrp->rx_skb_head = NULL;\r\n}\r\n}\r\nvoid strp_stop(struct strparser *strp)\r\n{\r\nstrp->rx_stopped = 1;\r\n}\r\nvoid strp_check_rcv(struct strparser *strp)\r\n{\r\nqueue_work(strp_wq, &strp->rx_work);\r\n}\r\nstatic int __init strp_mod_init(void)\r\n{\r\nstrp_wq = create_singlethread_workqueue("kstrp");\r\nreturn 0;\r\n}\r\nstatic void __exit strp_mod_exit(void)\r\n{\r\ndestroy_workqueue(strp_wq);\r\n}
