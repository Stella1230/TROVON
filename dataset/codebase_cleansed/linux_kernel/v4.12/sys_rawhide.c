static inline void\r\nrawhide_update_irq_hw(int hose, int mask)\r\n{\r\n*(vuip)MCPCIA_INT_MASK0(MCPCIA_HOSE2MID(hose)) = mask;\r\nmb();\r\n*(vuip)MCPCIA_INT_MASK0(MCPCIA_HOSE2MID(hose));\r\n}\r\nstatic inline void\r\nrawhide_enable_irq(struct irq_data *d)\r\n{\r\nunsigned int mask, hose;\r\nunsigned int irq = d->irq;\r\nirq -= 16;\r\nhose = irq / 24;\r\nif (!hose_exists(hose))\r\nreturn;\r\nirq -= hose * 24;\r\nmask = 1 << irq;\r\nspin_lock(&rawhide_irq_lock);\r\nmask |= cached_irq_masks[hose];\r\ncached_irq_masks[hose] = mask;\r\nrawhide_update_irq_hw(hose, mask);\r\nspin_unlock(&rawhide_irq_lock);\r\n}\r\nstatic void\r\nrawhide_disable_irq(struct irq_data *d)\r\n{\r\nunsigned int mask, hose;\r\nunsigned int irq = d->irq;\r\nirq -= 16;\r\nhose = irq / 24;\r\nif (!hose_exists(hose))\r\nreturn;\r\nirq -= hose * 24;\r\nmask = ~(1 << irq) | hose_irq_masks[hose];\r\nspin_lock(&rawhide_irq_lock);\r\nmask &= cached_irq_masks[hose];\r\ncached_irq_masks[hose] = mask;\r\nrawhide_update_irq_hw(hose, mask);\r\nspin_unlock(&rawhide_irq_lock);\r\n}\r\nstatic void\r\nrawhide_mask_and_ack_irq(struct irq_data *d)\r\n{\r\nunsigned int mask, mask1, hose;\r\nunsigned int irq = d->irq;\r\nirq -= 16;\r\nhose = irq / 24;\r\nif (!hose_exists(hose))\r\nreturn;\r\nirq -= hose * 24;\r\nmask1 = 1 << irq;\r\nmask = ~mask1 | hose_irq_masks[hose];\r\nspin_lock(&rawhide_irq_lock);\r\nmask &= cached_irq_masks[hose];\r\ncached_irq_masks[hose] = mask;\r\nrawhide_update_irq_hw(hose, mask);\r\n*(vuip)MCPCIA_INT_REQ(MCPCIA_HOSE2MID(hose)) = mask1;\r\nspin_unlock(&rawhide_irq_lock);\r\n}\r\nstatic void\r\nrawhide_srm_device_interrupt(unsigned long vector)\r\n{\r\nint irq;\r\nirq = (vector - 0x800) >> 4;\r\nif (irq == 52) {\r\nirq = 72;\r\n}\r\nirq -= ((irq + 16) >> 2) & 0x38;\r\nhandle_irq(irq);\r\n}\r\nstatic void __init\r\nrawhide_init_irq(void)\r\n{\r\nstruct pci_controller *hose;\r\nlong i;\r\nmcpcia_init_hoses();\r\nfor (i = 0; i < MCPCIA_MAX_HOSES; i++) cached_irq_masks[i] = 0;\r\nfor (hose = hose_head; hose; hose = hose->next) {\r\nunsigned int h = hose->index;\r\nunsigned int mask = hose_irq_masks[h];\r\ncached_irq_masks[h] = mask;\r\n*(vuip)MCPCIA_INT_MASK0(MCPCIA_HOSE2MID(h)) = mask;\r\n*(vuip)MCPCIA_INT_MASK1(MCPCIA_HOSE2MID(h)) = 0;\r\n}\r\nfor (i = 16; i < 128; ++i) {\r\nirq_set_chip_and_handler(i, &rawhide_irq_type,\r\nhandle_level_irq);\r\nirq_set_status_flags(i, IRQ_LEVEL);\r\n}\r\ninit_i8259a_irqs();\r\ncommon_init_isa_dma();\r\n}\r\nstatic int __init\r\nrawhide_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)\r\n{\r\nstatic char irq_tab[5][5] __initdata = {\r\n{ 16+16, 16+16, 16+16, 16+16, 16+16},\r\n{ 16+ 0, 16+ 0, 16+ 1, 16+ 2, 16+ 3},\r\n{ 16+ 4, 16+ 4, 16+ 5, 16+ 6, 16+ 7},\r\n{ 16+ 8, 16+ 8, 16+ 9, 16+10, 16+11},\r\n{ 16+12, 16+12, 16+13, 16+14, 16+15}\r\n};\r\nconst long min_idsel = 1, max_idsel = 5, irqs_per_slot = 5;\r\nstruct pci_controller *hose = dev->sysdata;\r\nint irq = COMMON_TABLE_LOOKUP;\r\nif (irq >= 0)\r\nirq += 24 * hose->index;\r\nreturn irq;\r\n}
