static int arizona_spk_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct arizona *arizona = dev_get_drvdata(codec->dev->parent);\r\nint val;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nval = snd_soc_read(codec, ARIZONA_INTERRUPT_RAW_STATUS_3);\r\nif (val & ARIZONA_SPK_OVERHEAT_STS) {\r\ndev_crit(arizona->dev,\r\n"Speaker not enabled due to temperature\n");\r\nreturn -EBUSY;\r\n}\r\nregmap_update_bits_async(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\n1 << w->shift, 1 << w->shift);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nregmap_update_bits_async(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\n1 << w->shift, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn arizona_out_ev(w, kcontrol, event);\r\n}\r\nstatic irqreturn_t arizona_thermal_warn(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_3,\r\n&val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read thermal status: %d\n",\r\nret);\r\n} else if (val & ARIZONA_SPK_OVERHEAT_WARN_STS) {\r\ndev_crit(arizona->dev, "Thermal warning\n");\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t arizona_thermal_shutdown(int irq, void *data)\r\n{\r\nstruct arizona *arizona = data;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(arizona->regmap, ARIZONA_INTERRUPT_RAW_STATUS_3,\r\n&val);\r\nif (ret != 0) {\r\ndev_err(arizona->dev, "Failed to read thermal status: %d\n",\r\nret);\r\n} else if (val & ARIZONA_SPK_OVERHEAT_STS) {\r\ndev_crit(arizona->dev, "Thermal shutdown\n");\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_OUTPUT_ENABLES_1,\r\nARIZONA_OUT4L_ENA |\r\nARIZONA_OUT4R_ENA, 0);\r\nif (ret != 0)\r\ndev_crit(arizona->dev,\r\n"Failed to disable speaker outputs: %d\n",\r\nret);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint arizona_init_spk(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint ret;\r\nret = snd_soc_dapm_new_controls(dapm, &arizona_spkl, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nswitch (arizona->type) {\r\ncase WM8997:\r\ncase CS47L24:\r\ncase WM1831:\r\nbreak;\r\ndefault:\r\nret = snd_soc_dapm_new_controls(dapm, &arizona_spkr, 1);\r\nif (ret != 0)\r\nreturn ret;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint arizona_init_spk_irqs(struct arizona *arizona)\r\n{\r\nint ret;\r\nret = arizona_request_irq(arizona, ARIZONA_IRQ_SPK_OVERHEAT_WARN,\r\n"Thermal warning", arizona_thermal_warn,\r\narizona);\r\nif (ret != 0)\r\ndev_err(arizona->dev,\r\n"Failed to get thermal warning IRQ: %d\n",\r\nret);\r\nret = arizona_request_irq(arizona, ARIZONA_IRQ_SPK_OVERHEAT,\r\n"Thermal shutdown", arizona_thermal_shutdown,\r\narizona);\r\nif (ret != 0)\r\ndev_err(arizona->dev,\r\n"Failed to get thermal shutdown IRQ: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nint arizona_free_spk_irqs(struct arizona *arizona)\r\n{\r\narizona_free_irq(arizona, ARIZONA_IRQ_SPK_OVERHEAT_WARN, arizona);\r\narizona_free_irq(arizona, ARIZONA_IRQ_SPK_OVERHEAT, arizona);\r\nreturn 0;\r\n}\r\nint arizona_init_mono(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint i;\r\nfor (i = 0; i < ARIZONA_MAX_OUTPUT; ++i) {\r\nif (arizona->pdata.out_mono[i])\r\nsnd_soc_dapm_add_routes(dapm,\r\n&arizona_mono_routes[i], 1);\r\n}\r\nreturn 0;\r\n}\r\nint arizona_init_gpio(struct snd_soc_codec *codec)\r\n{\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct snd_soc_component *component = snd_soc_dapm_to_component(dapm);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint i;\r\nswitch (arizona->type) {\r\ncase WM5110:\r\ncase WM8280:\r\nsnd_soc_component_disable_pin(component,\r\n"DRC2 Signal Activity");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_soc_component_disable_pin(component, "DRC1 Signal Activity");\r\nfor (i = 0; i < ARRAY_SIZE(arizona->pdata.gpio_defaults); i++) {\r\nswitch (arizona->pdata.gpio_defaults[i] & ARIZONA_GPN_FN_MASK) {\r\ncase ARIZONA_GP_FN_DRC1_SIGNAL_DETECT:\r\nsnd_soc_component_enable_pin(component,\r\n"DRC1 Signal Activity");\r\nbreak;\r\ncase ARIZONA_GP_FN_DRC2_SIGNAL_DETECT:\r\nsnd_soc_component_enable_pin(component,\r\n"DRC2 Signal Activity");\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint arizona_init_notifiers(struct snd_soc_codec *codec)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nBLOCKING_INIT_NOTIFIER_HEAD(&arizona->notifier);\r\nreturn 0;\r\n}\r\nconst char *arizona_sample_rate_val_to_name(unsigned int rate_val)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(arizona_sample_rate_val); ++i) {\r\nif (arizona_sample_rate_val[i] == rate_val)\r\nreturn arizona_sample_rate_text[i];\r\n}\r\nreturn "Illegal";\r\n}\r\nstatic void arizona_in_set_vu(struct snd_soc_codec *codec, int ena)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val;\r\nint i;\r\nif (ena)\r\nval = ARIZONA_IN_VU;\r\nelse\r\nval = 0;\r\nfor (i = 0; i < priv->num_inputs; i++)\r\nsnd_soc_update_bits(codec,\r\nARIZONA_ADC_DIGITAL_VOLUME_1L + (i * 4),\r\nARIZONA_IN_VU, val);\r\n}\r\nbool arizona_input_analog(struct snd_soc_codec *codec, int shift)\r\n{\r\nunsigned int reg = ARIZONA_IN1L_CONTROL + ((shift / 2) * 8);\r\nunsigned int val = snd_soc_read(codec, reg);\r\nreturn !(val & ARIZONA_IN1_MODE_MASK);\r\n}\r\nint arizona_in_ev(struct snd_soc_dapm_widget *w, struct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg;\r\nif (w->shift % 2)\r\nreg = ARIZONA_ADC_DIGITAL_VOLUME_1L + ((w->shift / 2) * 8);\r\nelse\r\nreg = ARIZONA_ADC_DIGITAL_VOLUME_1R + ((w->shift / 2) * 8);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\npriv->in_pending++;\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, reg, ARIZONA_IN1L_MUTE, 0);\r\npriv->in_pending--;\r\nif (priv->in_pending == 0) {\r\nmsleep(1);\r\narizona_in_set_vu(codec, 1);\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec, reg,\r\nARIZONA_IN1L_MUTE | ARIZONA_IN_VU,\r\nARIZONA_IN1L_MUTE | ARIZONA_IN_VU);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nreg = snd_soc_read(codec, ARIZONA_INPUT_ENABLES);\r\nif (reg == 0)\r\narizona_in_set_vu(codec, 0);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint arizona_out_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nswitch (w->shift) {\r\ncase ARIZONA_OUT1L_ENA_SHIFT:\r\ncase ARIZONA_OUT1R_ENA_SHIFT:\r\ncase ARIZONA_OUT2L_ENA_SHIFT:\r\ncase ARIZONA_OUT2R_ENA_SHIFT:\r\ncase ARIZONA_OUT3L_ENA_SHIFT:\r\ncase ARIZONA_OUT3R_ENA_SHIFT:\r\npriv->out_up_pending++;\r\npriv->out_up_delay += 17;\r\nbreak;\r\ncase ARIZONA_OUT4L_ENA_SHIFT:\r\ncase ARIZONA_OUT4R_ENA_SHIFT:\r\npriv->out_up_pending++;\r\nswitch (arizona->type) {\r\ncase WM5102:\r\ncase WM8997:\r\nbreak;\r\ndefault:\r\npriv->out_up_delay += 10;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMU:\r\nswitch (w->shift) {\r\ncase ARIZONA_OUT1L_ENA_SHIFT:\r\ncase ARIZONA_OUT1R_ENA_SHIFT:\r\ncase ARIZONA_OUT2L_ENA_SHIFT:\r\ncase ARIZONA_OUT2R_ENA_SHIFT:\r\ncase ARIZONA_OUT3L_ENA_SHIFT:\r\ncase ARIZONA_OUT3R_ENA_SHIFT:\r\ncase ARIZONA_OUT4L_ENA_SHIFT:\r\ncase ARIZONA_OUT4R_ENA_SHIFT:\r\npriv->out_up_pending--;\r\nif (!priv->out_up_pending && priv->out_up_delay) {\r\ndev_dbg(codec->dev, "Power up delay: %d\n",\r\npriv->out_up_delay);\r\nmsleep(priv->out_up_delay);\r\npriv->out_up_delay = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nswitch (w->shift) {\r\ncase ARIZONA_OUT1L_ENA_SHIFT:\r\ncase ARIZONA_OUT1R_ENA_SHIFT:\r\ncase ARIZONA_OUT2L_ENA_SHIFT:\r\ncase ARIZONA_OUT2R_ENA_SHIFT:\r\ncase ARIZONA_OUT3L_ENA_SHIFT:\r\ncase ARIZONA_OUT3R_ENA_SHIFT:\r\npriv->out_down_pending++;\r\npriv->out_down_delay++;\r\nbreak;\r\ncase ARIZONA_OUT4L_ENA_SHIFT:\r\ncase ARIZONA_OUT4R_ENA_SHIFT:\r\npriv->out_down_pending++;\r\nswitch (arizona->type) {\r\ncase WM5102:\r\ncase WM8997:\r\nbreak;\r\ncase WM8998:\r\ncase WM1814:\r\npriv->out_down_delay += 5;\r\nbreak;\r\ndefault:\r\npriv->out_down_delay++;\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nswitch (w->shift) {\r\ncase ARIZONA_OUT1L_ENA_SHIFT:\r\ncase ARIZONA_OUT1R_ENA_SHIFT:\r\ncase ARIZONA_OUT2L_ENA_SHIFT:\r\ncase ARIZONA_OUT2R_ENA_SHIFT:\r\ncase ARIZONA_OUT3L_ENA_SHIFT:\r\ncase ARIZONA_OUT3R_ENA_SHIFT:\r\ncase ARIZONA_OUT4L_ENA_SHIFT:\r\ncase ARIZONA_OUT4R_ENA_SHIFT:\r\npriv->out_down_pending--;\r\nif (!priv->out_down_pending && priv->out_down_delay) {\r\ndev_dbg(codec->dev, "Power down delay: %d\n",\r\npriv->out_down_delay);\r\nmsleep(priv->out_down_delay);\r\npriv->out_down_delay = 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nint arizona_hp_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nunsigned int mask = 1 << w->shift;\r\nunsigned int val;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nval = mask;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nval = 0;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMU:\r\ncase SND_SOC_DAPM_POST_PMD:\r\nreturn arizona_out_ev(w, kcontrol, event);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npriv->arizona->hp_ena &= ~mask;\r\npriv->arizona->hp_ena |= val;\r\nif (priv->arizona->hpdet_clamp)\r\nval = 0;\r\nregmap_update_bits_async(arizona->regmap, ARIZONA_OUTPUT_ENABLES_1,\r\nmask, val);\r\nreturn arizona_out_ev(w, kcontrol, event);\r\n}\r\nstatic int arizona_dvfs_enable(struct snd_soc_codec *codec)\r\n{\r\nconst struct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint ret;\r\nret = regulator_set_voltage(arizona->dcvdd, 1800000, 1800000);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to boost DCVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_DYNAMIC_FREQUENCY_SCALING_1,\r\nARIZONA_SUBSYS_MAX_FREQ,\r\nARIZONA_SUBSYS_MAX_FREQ);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable subsys max: %d\n", ret);\r\nregulator_set_voltage(arizona->dcvdd, 1200000, 1800000);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int arizona_dvfs_disable(struct snd_soc_codec *codec)\r\n{\r\nconst struct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint ret;\r\nret = regmap_update_bits(arizona->regmap,\r\nARIZONA_DYNAMIC_FREQUENCY_SCALING_1,\r\nARIZONA_SUBSYS_MAX_FREQ, 0);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to disable subsys max: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regulator_set_voltage(arizona->dcvdd, 1200000, 1800000);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to unboost DCVDD: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint arizona_dvfs_up(struct snd_soc_codec *codec, unsigned int flags)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nmutex_lock(&priv->dvfs_lock);\r\nif (!priv->dvfs_cached && !priv->dvfs_reqs) {\r\nret = arizona_dvfs_enable(codec);\r\nif (ret)\r\ngoto err;\r\n}\r\npriv->dvfs_reqs |= flags;\r\nerr:\r\nmutex_unlock(&priv->dvfs_lock);\r\nreturn ret;\r\n}\r\nint arizona_dvfs_down(struct snd_soc_codec *codec, unsigned int flags)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int old_reqs;\r\nint ret = 0;\r\nmutex_lock(&priv->dvfs_lock);\r\nold_reqs = priv->dvfs_reqs;\r\npriv->dvfs_reqs &= ~flags;\r\nif (!priv->dvfs_cached && old_reqs && !priv->dvfs_reqs)\r\nret = arizona_dvfs_disable(codec);\r\nmutex_unlock(&priv->dvfs_lock);\r\nreturn ret;\r\n}\r\nint arizona_dvfs_sysclk_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nint ret = 0;\r\nmutex_lock(&priv->dvfs_lock);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nif (priv->dvfs_reqs)\r\nret = arizona_dvfs_enable(codec);\r\npriv->dvfs_cached = false;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\npriv->dvfs_cached = true;\r\nif (priv->dvfs_reqs)\r\nret = arizona_dvfs_disable(codec);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nmutex_unlock(&priv->dvfs_lock);\r\nreturn ret;\r\n}\r\nvoid arizona_init_dvfs(struct arizona_priv *priv)\r\n{\r\nmutex_init(&priv->dvfs_lock);\r\n}\r\nint arizona_anc_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol,\r\nint event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nunsigned int val;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nval = 1 << w->shift;\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nval = 1 << (w->shift + 1);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nsnd_soc_write(codec, ARIZONA_CLOCK_CONTROL, val);\r\nreturn 0;\r\n}\r\nstatic int arizona_set_opclk(struct snd_soc_codec *codec, unsigned int clk,\r\nunsigned int freq)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nunsigned int reg;\r\nunsigned int *rates;\r\nint ref, div, refclk;\r\nswitch (clk) {\r\ncase ARIZONA_CLK_OPCLK:\r\nreg = ARIZONA_OUTPUT_SYSTEM_CLOCK;\r\nrefclk = priv->sysclk;\r\nbreak;\r\ncase ARIZONA_CLK_ASYNC_OPCLK:\r\nreg = ARIZONA_OUTPUT_ASYNC_CLOCK;\r\nrefclk = priv->asyncclk;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (refclk % 8000)\r\nrates = arizona_opclk_ref_44k1_rates;\r\nelse\r\nrates = arizona_opclk_ref_48k_rates;\r\nfor (ref = 0; ref < ARRAY_SIZE(arizona_opclk_ref_48k_rates) &&\r\nrates[ref] <= refclk; ref++) {\r\ndiv = 1;\r\nwhile (rates[ref] / div >= freq && div < 32) {\r\nif (rates[ref] / div == freq) {\r\ndev_dbg(codec->dev, "Configured %dHz OPCLK\n",\r\nfreq);\r\nsnd_soc_update_bits(codec, reg,\r\nARIZONA_OPCLK_DIV_MASK |\r\nARIZONA_OPCLK_SEL_MASK,\r\n(div <<\r\nARIZONA_OPCLK_DIV_SHIFT) |\r\nref);\r\nreturn 0;\r\n}\r\ndiv++;\r\n}\r\n}\r\ndev_err(codec->dev, "Unable to generate %dHz OPCLK\n", freq);\r\nreturn -EINVAL;\r\n}\r\nint arizona_clk_ev(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nstruct arizona *arizona = dev_get_drvdata(codec->dev->parent);\r\nunsigned int val;\r\nint clk_idx;\r\nint ret;\r\nret = regmap_read(arizona->regmap, w->reg, &val);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to check clock source: %d\n", ret);\r\nreturn ret;\r\n}\r\nval = (val & ARIZONA_SYSCLK_SRC_MASK) >> ARIZONA_SYSCLK_SRC_SHIFT;\r\nswitch (val) {\r\ncase ARIZONA_CLK_SRC_MCLK1:\r\nclk_idx = ARIZONA_MCLK1;\r\nbreak;\r\ncase ARIZONA_CLK_SRC_MCLK2:\r\nclk_idx = ARIZONA_MCLK2;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nreturn clk_prepare_enable(arizona->mclk[clk_idx]);\r\ncase SND_SOC_DAPM_POST_PMD:\r\nclk_disable_unprepare(arizona->mclk[clk_idx]);\r\nreturn 0;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint arizona_set_sysclk(struct snd_soc_codec *codec, int clk_id,\r\nint source, unsigned int freq, int dir)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nchar *name;\r\nunsigned int reg;\r\nunsigned int mask = ARIZONA_SYSCLK_FREQ_MASK | ARIZONA_SYSCLK_SRC_MASK;\r\nunsigned int val = source << ARIZONA_SYSCLK_SRC_SHIFT;\r\nint *clk;\r\nswitch (clk_id) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nname = "SYSCLK";\r\nreg = ARIZONA_SYSTEM_CLOCK_1;\r\nclk = &priv->sysclk;\r\nmask |= ARIZONA_SYSCLK_FRAC;\r\nbreak;\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nname = "ASYNCCLK";\r\nreg = ARIZONA_ASYNC_CLOCK_1;\r\nclk = &priv->asyncclk;\r\nbreak;\r\ncase ARIZONA_CLK_OPCLK:\r\ncase ARIZONA_CLK_ASYNC_OPCLK:\r\nreturn arizona_set_opclk(codec, clk_id, freq);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (freq) {\r\ncase 5644800:\r\ncase 6144000:\r\nbreak;\r\ncase 11289600:\r\ncase 12288000:\r\nval |= ARIZONA_CLK_12MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 22579200:\r\ncase 24576000:\r\nval |= ARIZONA_CLK_24MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 45158400:\r\ncase 49152000:\r\nval |= ARIZONA_CLK_49MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 67737600:\r\ncase 73728000:\r\nval |= ARIZONA_CLK_73MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 90316800:\r\ncase 98304000:\r\nval |= ARIZONA_CLK_98MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 135475200:\r\ncase 147456000:\r\nval |= ARIZONA_CLK_147MHZ << ARIZONA_SYSCLK_FREQ_SHIFT;\r\nbreak;\r\ncase 0:\r\ndev_dbg(arizona->dev, "%s cleared\n", name);\r\n*clk = freq;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n*clk = freq;\r\nif (freq % 6144000)\r\nval |= ARIZONA_SYSCLK_FRAC;\r\ndev_dbg(arizona->dev, "%s set to %uHz", name, freq);\r\nreturn regmap_update_bits(arizona->regmap, reg, mask, val);\r\n}\r\nstatic int arizona_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint lrclk, bclk, mode, base;\r\nbase = dai->driver->base;\r\nlrclk = 0;\r\nbclk = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nmode = ARIZONA_FMT_DSP_MODE_A;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK)\r\n!= SND_SOC_DAIFMT_CBM_CFM) {\r\narizona_aif_err(dai, "DSP_B not valid in slave mode\n");\r\nreturn -EINVAL;\r\n}\r\nmode = ARIZONA_FMT_DSP_MODE_B;\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\nmode = ARIZONA_FMT_I2S_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nif ((fmt & SND_SOC_DAIFMT_MASTER_MASK)\r\n!= SND_SOC_DAIFMT_CBM_CFM) {\r\narizona_aif_err(dai, "LEFT_J not valid in slave mode\n");\r\nreturn -EINVAL;\r\n}\r\nmode = ARIZONA_FMT_LEFT_JUSTIFIED_MODE;\r\nbreak;\r\ndefault:\r\narizona_aif_err(dai, "Unsupported DAI format %d\n",\r\nfmt & SND_SOC_DAIFMT_FORMAT_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFM:\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFS:\r\nbclk |= ARIZONA_AIF1_BCLK_MSTR;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nbclk |= ARIZONA_AIF1_BCLK_MSTR;\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_MSTR;\r\nbreak;\r\ndefault:\r\narizona_aif_err(dai, "Unsupported master mode %d\n",\r\nfmt & SND_SOC_DAIFMT_MASTER_MASK);\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nbclk |= ARIZONA_AIF1_BCLK_INV;\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nbclk |= ARIZONA_AIF1_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nlrclk |= ARIZONA_AIF1TX_LRCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits_async(arizona->regmap, base + ARIZONA_AIF_BCLK_CTRL,\r\nARIZONA_AIF1_BCLK_INV |\r\nARIZONA_AIF1_BCLK_MSTR,\r\nbclk);\r\nregmap_update_bits_async(arizona->regmap, base + ARIZONA_AIF_TX_PIN_CTRL,\r\nARIZONA_AIF1TX_LRCLK_INV |\r\nARIZONA_AIF1TX_LRCLK_MSTR, lrclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_RX_PIN_CTRL,\r\nARIZONA_AIF1RX_LRCLK_INV |\r\nARIZONA_AIF1RX_LRCLK_MSTR, lrclk);\r\nregmap_update_bits(arizona->regmap, base + ARIZONA_AIF_FORMAT,\r\nARIZONA_AIF1_FMT_MASK, mode);\r\nreturn 0;\r\n}\r\nstatic int arizona_startup(struct snd_pcm_substream *substream,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[dai->id - 1];\r\nunsigned int base_rate;\r\nif (!substream->runtime)\r\nreturn 0;\r\nswitch (dai_priv->clk) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nbase_rate = priv->sysclk;\r\nbreak;\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nbase_rate = priv->asyncclk;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (base_rate == 0)\r\ndai_priv->constraint.mask = ARIZONA_RATE_MASK;\r\nelse if (base_rate % 8000)\r\ndai_priv->constraint.mask = ARIZONA_44K1_RATE_MASK;\r\nelse\r\ndai_priv->constraint.mask = ARIZONA_48K_RATE_MASK;\r\nreturn snd_pcm_hw_constraint_list(substream->runtime, 0,\r\nSNDRV_PCM_HW_PARAM_RATE,\r\n&dai_priv->constraint);\r\n}\r\nstatic void arizona_wm5102_set_dac_comp(struct snd_soc_codec *codec,\r\nunsigned int rate)\r\n{\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nstruct reg_sequence dac_comp[] = {\r\n{ 0x80, 0x3 },\r\n{ ARIZONA_DAC_COMP_1, 0 },\r\n{ ARIZONA_DAC_COMP_2, 0 },\r\n{ 0x80, 0x0 },\r\n};\r\nmutex_lock(&arizona->dac_comp_lock);\r\ndac_comp[1].def = arizona->dac_comp_coeff;\r\nif (rate >= 176400)\r\ndac_comp[2].def = arizona->dac_comp_enabled;\r\nmutex_unlock(&arizona->dac_comp_lock);\r\nregmap_multi_reg_write(arizona->regmap,\r\ndac_comp,\r\nARRAY_SIZE(dac_comp));\r\n}\r\nstatic int arizona_hw_params_rate(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[dai->id - 1];\r\nint base = dai->driver->base;\r\nint i, sr_val, ret;\r\nfor (i = 0; i < ARRAY_SIZE(arizona_sr_vals); i++)\r\nif (arizona_sr_vals[i] == params_rate(params))\r\nbreak;\r\nif (i == ARRAY_SIZE(arizona_sr_vals)) {\r\narizona_aif_err(dai, "Unsupported sample rate %dHz\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nsr_val = i;\r\nswitch (priv->arizona->type) {\r\ncase WM5102:\r\ncase WM8997:\r\nif (arizona_sr_vals[sr_val] >= 88200)\r\nret = arizona_dvfs_up(codec, ARIZONA_DVFS_SR1_RQ);\r\nelse\r\nret = arizona_dvfs_down(codec, ARIZONA_DVFS_SR1_RQ);\r\nif (ret) {\r\narizona_aif_err(dai, "Failed to change DVFS %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nswitch (dai_priv->clk) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nswitch (priv->arizona->type) {\r\ncase WM5102:\r\narizona_wm5102_set_dac_comp(codec,\r\nparams_rate(params));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nsnd_soc_update_bits(codec, ARIZONA_SAMPLE_RATE_1,\r\nARIZONA_SAMPLE_RATE_1_MASK, sr_val);\r\nif (base)\r\nsnd_soc_update_bits(codec, base + ARIZONA_AIF_RATE_CTRL,\r\nARIZONA_AIF1_RATE_MASK, 0);\r\nbreak;\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nsnd_soc_update_bits(codec, ARIZONA_ASYNC_SAMPLE_RATE_1,\r\nARIZONA_ASYNC_SAMPLE_RATE_1_MASK, sr_val);\r\nif (base)\r\nsnd_soc_update_bits(codec, base + ARIZONA_AIF_RATE_CTRL,\r\nARIZONA_AIF1_RATE_MASK,\r\n8 << ARIZONA_AIF1_RATE_SHIFT);\r\nbreak;\r\ndefault:\r\narizona_aif_err(dai, "Invalid clock %d\n", dai_priv->clk);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool arizona_aif_cfg_changed(struct snd_soc_codec *codec,\r\nint base, int bclk, int lrclk, int frame)\r\n{\r\nint val;\r\nval = snd_soc_read(codec, base + ARIZONA_AIF_BCLK_CTRL);\r\nif (bclk != (val & ARIZONA_AIF1_BCLK_FREQ_MASK))\r\nreturn true;\r\nval = snd_soc_read(codec, base + ARIZONA_AIF_TX_BCLK_RATE);\r\nif (lrclk != (val & ARIZONA_AIF1TX_BCPF_MASK))\r\nreturn true;\r\nval = snd_soc_read(codec, base + ARIZONA_AIF_FRAME_CTRL_1);\r\nif (frame != (val & (ARIZONA_AIF1TX_WL_MASK |\r\nARIZONA_AIF1TX_SLOT_LEN_MASK)))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int arizona_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint base = dai->driver->base;\r\nconst int *rates;\r\nint i, ret, val;\r\nint channels = params_channels(params);\r\nint chan_limit = arizona->pdata.max_channels_clocked[dai->id - 1];\r\nint tdm_width = arizona->tdm_width[dai->id - 1];\r\nint tdm_slots = arizona->tdm_slots[dai->id - 1];\r\nint bclk, lrclk, wl, frame, bclk_target;\r\nbool reconfig;\r\nunsigned int aif_tx_state, aif_rx_state;\r\nif (params_rate(params) % 4000)\r\nrates = &arizona_44k1_bclk_rates[0];\r\nelse\r\nrates = &arizona_48k_bclk_rates[0];\r\nwl = params_width(params);\r\nif (tdm_slots) {\r\narizona_aif_dbg(dai, "Configuring for %d %d bit TDM slots\n",\r\ntdm_slots, tdm_width);\r\nbclk_target = tdm_slots * tdm_width * params_rate(params);\r\nchannels = tdm_slots;\r\n} else {\r\nbclk_target = snd_soc_params_to_bclk(params);\r\ntdm_width = wl;\r\n}\r\nif (chan_limit && chan_limit < channels) {\r\narizona_aif_dbg(dai, "Limiting to %d channels\n", chan_limit);\r\nbclk_target /= channels;\r\nbclk_target *= chan_limit;\r\n}\r\nval = snd_soc_read(codec, base + ARIZONA_AIF_FORMAT);\r\nval &= ARIZONA_AIF1_FMT_MASK;\r\nif ((channels & 1) && (val == ARIZONA_FMT_I2S_MODE)) {\r\narizona_aif_dbg(dai, "Forcing stereo mode\n");\r\nbclk_target /= channels;\r\nbclk_target *= channels + 1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(arizona_44k1_bclk_rates); i++) {\r\nif (rates[i] >= bclk_target &&\r\nrates[i] % params_rate(params) == 0) {\r\nbclk = i;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(arizona_44k1_bclk_rates)) {\r\narizona_aif_err(dai, "Unsupported sample rate %dHz\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nlrclk = rates[bclk] / params_rate(params);\r\narizona_aif_dbg(dai, "BCLK %dHz LRCLK %dHz\n",\r\nrates[bclk], rates[bclk] / lrclk);\r\nframe = wl << ARIZONA_AIF1TX_WL_SHIFT | tdm_width;\r\nreconfig = arizona_aif_cfg_changed(codec, base, bclk, lrclk, frame);\r\nif (reconfig) {\r\naif_tx_state = snd_soc_read(codec,\r\nbase + ARIZONA_AIF_TX_ENABLES);\r\naif_rx_state = snd_soc_read(codec,\r\nbase + ARIZONA_AIF_RX_ENABLES);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_TX_ENABLES, 0xff, 0x0);\r\nregmap_update_bits(arizona->regmap,\r\nbase + ARIZONA_AIF_RX_ENABLES, 0xff, 0x0);\r\n}\r\nret = arizona_hw_params_rate(substream, params, dai);\r\nif (ret != 0)\r\ngoto restore_aif;\r\nif (reconfig) {\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_BCLK_CTRL,\r\nARIZONA_AIF1_BCLK_FREQ_MASK, bclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_TX_BCLK_RATE,\r\nARIZONA_AIF1TX_BCPF_MASK, lrclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_RX_BCLK_RATE,\r\nARIZONA_AIF1RX_BCPF_MASK, lrclk);\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_FRAME_CTRL_1,\r\nARIZONA_AIF1TX_WL_MASK |\r\nARIZONA_AIF1TX_SLOT_LEN_MASK, frame);\r\nregmap_update_bits(arizona->regmap,\r\nbase + ARIZONA_AIF_FRAME_CTRL_2,\r\nARIZONA_AIF1RX_WL_MASK |\r\nARIZONA_AIF1RX_SLOT_LEN_MASK, frame);\r\n}\r\nrestore_aif:\r\nif (reconfig) {\r\nregmap_update_bits_async(arizona->regmap,\r\nbase + ARIZONA_AIF_TX_ENABLES,\r\n0xff, aif_tx_state);\r\nregmap_update_bits(arizona->regmap,\r\nbase + ARIZONA_AIF_RX_ENABLES,\r\n0xff, aif_rx_state);\r\n}\r\nreturn ret;\r\n}\r\nstatic const char *arizona_dai_clk_str(int clk_id)\r\n{\r\nswitch (clk_id) {\r\ncase ARIZONA_CLK_SYSCLK:\r\nreturn "SYSCLK";\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nreturn "ASYNCCLK";\r\ndefault:\r\nreturn "Unknown clock";\r\n}\r\n}\r\nstatic int arizona_dai_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct snd_soc_dapm_context *dapm = snd_soc_codec_get_dapm(codec);\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[dai->id - 1];\r\nstruct snd_soc_dapm_route routes[2];\r\nswitch (clk_id) {\r\ncase ARIZONA_CLK_SYSCLK:\r\ncase ARIZONA_CLK_ASYNCCLK:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (clk_id == dai_priv->clk)\r\nreturn 0;\r\nif (dai->active) {\r\ndev_err(codec->dev, "Can't change clock on active DAI %d\n",\r\ndai->id);\r\nreturn -EBUSY;\r\n}\r\ndev_dbg(codec->dev, "Setting AIF%d to %s\n", dai->id + 1,\r\narizona_dai_clk_str(clk_id));\r\nmemset(&routes, 0, sizeof(routes));\r\nroutes[0].sink = dai->driver->capture.stream_name;\r\nroutes[1].sink = dai->driver->playback.stream_name;\r\nroutes[0].source = arizona_dai_clk_str(dai_priv->clk);\r\nroutes[1].source = arizona_dai_clk_str(dai_priv->clk);\r\nsnd_soc_dapm_del_routes(dapm, routes, ARRAY_SIZE(routes));\r\nroutes[0].source = arizona_dai_clk_str(clk_id);\r\nroutes[1].source = arizona_dai_clk_str(clk_id);\r\nsnd_soc_dapm_add_routes(dapm, routes, ARRAY_SIZE(routes));\r\ndai_priv->clk = clk_id;\r\nreturn snd_soc_dapm_sync(dapm);\r\n}\r\nstatic int arizona_set_tristate(struct snd_soc_dai *dai, int tristate)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nint base = dai->driver->base;\r\nunsigned int reg;\r\nif (tristate)\r\nreg = ARIZONA_AIF1_TRI;\r\nelse\r\nreg = 0;\r\nreturn snd_soc_update_bits(codec, base + ARIZONA_AIF_RATE_CTRL,\r\nARIZONA_AIF1_TRI, reg);\r\n}\r\nstatic void arizona_set_channels_to_mask(struct snd_soc_dai *dai,\r\nunsigned int base,\r\nint channels, unsigned int mask)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint slot, i;\r\nfor (i = 0; i < channels; ++i) {\r\nslot = ffs(mask) - 1;\r\nif (slot < 0)\r\nreturn;\r\nregmap_write(arizona->regmap, base + i, slot);\r\nmask &= ~(1 << slot);\r\n}\r\nif (mask)\r\narizona_aif_warn(dai, "Too many channels in TDM mask\n");\r\n}\r\nstatic int arizona_set_tdm_slot(struct snd_soc_dai *dai, unsigned int tx_mask,\r\nunsigned int rx_mask, int slots, int slot_width)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct arizona_priv *priv = snd_soc_codec_get_drvdata(codec);\r\nstruct arizona *arizona = priv->arizona;\r\nint base = dai->driver->base;\r\nint rx_max_chan = dai->driver->playback.channels_max;\r\nint tx_max_chan = dai->driver->capture.channels_max;\r\nif (dai->id > ARIZONA_MAX_AIF)\r\nreturn -ENOTSUPP;\r\nif (slots == 0) {\r\ntx_mask = (1 << tx_max_chan) - 1;\r\nrx_mask = (1 << rx_max_chan) - 1;\r\n}\r\narizona_set_channels_to_mask(dai, base + ARIZONA_AIF_FRAME_CTRL_3,\r\ntx_max_chan, tx_mask);\r\narizona_set_channels_to_mask(dai, base + ARIZONA_AIF_FRAME_CTRL_11,\r\nrx_max_chan, rx_mask);\r\narizona->tdm_width[dai->id - 1] = slot_width;\r\narizona->tdm_slots[dai->id - 1] = slots;\r\nreturn 0;\r\n}\r\nint arizona_init_dai(struct arizona_priv *priv, int id)\r\n{\r\nstruct arizona_dai_priv *dai_priv = &priv->dai[id];\r\ndai_priv->clk = ARIZONA_CLK_SYSCLK;\r\ndai_priv->constraint = arizona_constraint;\r\nreturn 0;\r\n}\r\nstatic int arizona_validate_fll(struct arizona_fll *fll,\r\nunsigned int Fref,\r\nunsigned int Fout)\r\n{\r\nunsigned int Fvco_min;\r\nif (fll->fout && Fout != fll->fout) {\r\narizona_fll_err(fll,\r\n"Can't change output on active FLL\n");\r\nreturn -EINVAL;\r\n}\r\nif (Fref / ARIZONA_FLL_MAX_REFDIV > ARIZONA_FLL_MAX_FREF) {\r\narizona_fll_err(fll,\r\n"Can't scale %dMHz in to <=13.5MHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\nFvco_min = ARIZONA_FLL_MIN_FVCO * fll->vco_mult;\r\nif (Fout * ARIZONA_FLL_MAX_OUTDIV < Fvco_min) {\r\narizona_fll_err(fll, "No FLL_OUTDIV for Fout=%uHz\n",\r\nFout);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int arizona_find_fratio(unsigned int Fref, int *fratio)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(fll_fratios); i++) {\r\nif (fll_fratios[i].min <= Fref && Fref <= fll_fratios[i].max) {\r\nif (fratio)\r\n*fratio = fll_fratios[i].fratio;\r\nreturn fll_fratios[i].ratio;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int arizona_calc_fratio(struct arizona_fll *fll,\r\nstruct arizona_fll_cfg *cfg,\r\nunsigned int target,\r\nunsigned int Fref, bool sync)\r\n{\r\nint init_ratio, ratio;\r\nint refdiv, div;\r\ndiv = 1;\r\ncfg->refdiv = 0;\r\nwhile (Fref > ARIZONA_FLL_MAX_FREF) {\r\ndiv *= 2;\r\nFref /= 2;\r\ncfg->refdiv++;\r\nif (div > ARIZONA_FLL_MAX_REFDIV)\r\nreturn -EINVAL;\r\n}\r\ninit_ratio = arizona_find_fratio(Fref, &cfg->fratio);\r\nif (init_ratio < 0) {\r\narizona_fll_err(fll, "Unable to find FRATIO for Fref=%uHz\n",\r\nFref);\r\nreturn init_ratio;\r\n}\r\nswitch (fll->arizona->type) {\r\ncase WM5102:\r\ncase WM8997:\r\nreturn init_ratio;\r\ncase WM5110:\r\ncase WM8280:\r\nif (fll->arizona->rev < 3 || sync)\r\nreturn init_ratio;\r\nbreak;\r\ndefault:\r\nif (sync)\r\nreturn init_ratio;\r\nbreak;\r\n}\r\ncfg->fratio = init_ratio - 1;\r\nrefdiv = cfg->refdiv;\r\narizona_fll_dbg(fll, "pseudo: initial ratio=%u fref=%u refdiv=%u\n",\r\ninit_ratio, Fref, refdiv);\r\nwhile (div <= ARIZONA_FLL_MAX_REFDIV) {\r\nfor (ratio = init_ratio; ratio > 0; ratio--) {\r\nif (target % (ratio * Fref)) {\r\ncfg->refdiv = refdiv;\r\ncfg->fratio = ratio - 1;\r\narizona_fll_dbg(fll,\r\n"pseudo: found fref=%u refdiv=%d(%d) ratio=%d\n",\r\nFref, refdiv, div, ratio);\r\nreturn ratio;\r\n}\r\n}\r\nfor (ratio = init_ratio + 1; ratio <= ARIZONA_FLL_MAX_FRATIO;\r\nratio++) {\r\nif ((ARIZONA_FLL_VCO_CORNER / 2) /\r\n(fll->vco_mult * ratio) < Fref) {\r\narizona_fll_dbg(fll, "pseudo: hit VCO corner\n");\r\nbreak;\r\n}\r\nif (Fref > pseudo_fref_max[ratio - 1]) {\r\narizona_fll_dbg(fll,\r\n"pseudo: exceeded max fref(%u) for ratio=%u\n",\r\npseudo_fref_max[ratio - 1],\r\nratio);\r\nbreak;\r\n}\r\nif (target % (ratio * Fref)) {\r\ncfg->refdiv = refdiv;\r\ncfg->fratio = ratio - 1;\r\narizona_fll_dbg(fll,\r\n"pseudo: found fref=%u refdiv=%d(%d) ratio=%d\n",\r\nFref, refdiv, div, ratio);\r\nreturn ratio;\r\n}\r\n}\r\ndiv *= 2;\r\nFref /= 2;\r\nrefdiv++;\r\ninit_ratio = arizona_find_fratio(Fref, NULL);\r\narizona_fll_dbg(fll,\r\n"pseudo: change fref=%u refdiv=%d(%d) ratio=%u\n",\r\nFref, refdiv, div, init_ratio);\r\n}\r\narizona_fll_warn(fll, "Falling back to integer mode operation\n");\r\nreturn cfg->fratio + 1;\r\n}\r\nstatic int arizona_calc_fll(struct arizona_fll *fll,\r\nstruct arizona_fll_cfg *cfg,\r\nunsigned int Fref, bool sync)\r\n{\r\nunsigned int target, div, gcd_fll;\r\nint i, ratio;\r\narizona_fll_dbg(fll, "Fref=%u Fout=%u\n", Fref, fll->fout);\r\ndiv = ARIZONA_FLL_MIN_OUTDIV;\r\nwhile (fll->fout * div < ARIZONA_FLL_MIN_FVCO * fll->vco_mult) {\r\ndiv++;\r\nif (div > ARIZONA_FLL_MAX_OUTDIV)\r\nreturn -EINVAL;\r\n}\r\ntarget = fll->fout * div / fll->vco_mult;\r\ncfg->outdiv = div;\r\narizona_fll_dbg(fll, "Fvco=%dHz\n", target);\r\nratio = arizona_calc_fratio(fll, cfg, target, Fref, sync);\r\nif (ratio < 0)\r\nreturn ratio;\r\nFref = Fref / (1 << cfg->refdiv);\r\ncfg->n = target / (ratio * Fref);\r\nif (target % (ratio * Fref)) {\r\ngcd_fll = gcd(target, ratio * Fref);\r\narizona_fll_dbg(fll, "GCD=%u\n", gcd_fll);\r\ncfg->theta = (target - (cfg->n * ratio * Fref))\r\n/ gcd_fll;\r\ncfg->lambda = (ratio * Fref) / gcd_fll;\r\n} else {\r\ncfg->theta = 0;\r\ncfg->lambda = 0;\r\n}\r\nwhile (cfg->lambda >= (1 << 16)) {\r\ncfg->theta >>= 1;\r\ncfg->lambda >>= 1;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(fll_gains); i++) {\r\nif (fll_gains[i].min <= Fref && Fref <= fll_gains[i].max) {\r\ncfg->gain = fll_gains[i].gain;\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(fll_gains)) {\r\narizona_fll_err(fll, "Unable to find gain for Fref=%uHz\n",\r\nFref);\r\nreturn -EINVAL;\r\n}\r\narizona_fll_dbg(fll, "N=%d THETA=%d LAMBDA=%d\n",\r\ncfg->n, cfg->theta, cfg->lambda);\r\narizona_fll_dbg(fll, "FRATIO=0x%x(%d) OUTDIV=%d REFCLK_DIV=0x%x(%d)\n",\r\ncfg->fratio, ratio, cfg->outdiv,\r\ncfg->refdiv, 1 << cfg->refdiv);\r\narizona_fll_dbg(fll, "GAIN=0x%x(%d)\n", cfg->gain, 1 << cfg->gain);\r\nreturn 0;\r\n}\r\nstatic void arizona_apply_fll(struct arizona *arizona, unsigned int base,\r\nstruct arizona_fll_cfg *cfg, int source,\r\nbool sync)\r\n{\r\nregmap_update_bits_async(arizona->regmap, base + 3,\r\nARIZONA_FLL1_THETA_MASK, cfg->theta);\r\nregmap_update_bits_async(arizona->regmap, base + 4,\r\nARIZONA_FLL1_LAMBDA_MASK, cfg->lambda);\r\nregmap_update_bits_async(arizona->regmap, base + 5,\r\nARIZONA_FLL1_FRATIO_MASK,\r\ncfg->fratio << ARIZONA_FLL1_FRATIO_SHIFT);\r\nregmap_update_bits_async(arizona->regmap, base + 6,\r\nARIZONA_FLL1_CLK_REF_DIV_MASK |\r\nARIZONA_FLL1_CLK_REF_SRC_MASK,\r\ncfg->refdiv << ARIZONA_FLL1_CLK_REF_DIV_SHIFT |\r\nsource << ARIZONA_FLL1_CLK_REF_SRC_SHIFT);\r\nif (sync) {\r\nregmap_update_bits(arizona->regmap, base + 0x7,\r\nARIZONA_FLL1_GAIN_MASK,\r\ncfg->gain << ARIZONA_FLL1_GAIN_SHIFT);\r\n} else {\r\nregmap_update_bits(arizona->regmap, base + 0x5,\r\nARIZONA_FLL1_OUTDIV_MASK,\r\ncfg->outdiv << ARIZONA_FLL1_OUTDIV_SHIFT);\r\nregmap_update_bits(arizona->regmap, base + 0x9,\r\nARIZONA_FLL1_GAIN_MASK,\r\ncfg->gain << ARIZONA_FLL1_GAIN_SHIFT);\r\n}\r\nregmap_update_bits_async(arizona->regmap, base + 2,\r\nARIZONA_FLL1_CTRL_UPD | ARIZONA_FLL1_N_MASK,\r\nARIZONA_FLL1_CTRL_UPD | cfg->n);\r\n}\r\nstatic int arizona_is_enabled_fll(struct arizona_fll *fll, int base)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nunsigned int reg;\r\nint ret;\r\nret = regmap_read(arizona->regmap, base + 1, &reg);\r\nif (ret != 0) {\r\narizona_fll_err(fll, "Failed to read current state: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nreturn reg & ARIZONA_FLL1_ENA;\r\n}\r\nstatic int arizona_set_fll_clks(struct arizona_fll *fll, int base, bool ena)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nunsigned int val;\r\nstruct clk *clk;\r\nint ret;\r\nret = regmap_read(arizona->regmap, base + 6, &val);\r\nif (ret != 0) {\r\narizona_fll_err(fll, "Failed to read current source: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nval &= ARIZONA_FLL1_CLK_REF_SRC_MASK;\r\nval >>= ARIZONA_FLL1_CLK_REF_SRC_SHIFT;\r\nswitch (val) {\r\ncase ARIZONA_FLL_SRC_MCLK1:\r\nclk = arizona->mclk[ARIZONA_MCLK1];\r\nbreak;\r\ncase ARIZONA_FLL_SRC_MCLK2:\r\nclk = arizona->mclk[ARIZONA_MCLK2];\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (ena) {\r\nreturn clk_prepare_enable(clk);\r\n} else {\r\nclk_disable_unprepare(clk);\r\nreturn 0;\r\n}\r\n}\r\nstatic int arizona_enable_fll(struct arizona_fll *fll)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nbool use_sync = false;\r\nint already_enabled = arizona_is_enabled_fll(fll, fll->base);\r\nint sync_enabled = arizona_is_enabled_fll(fll, fll->base + 0x10);\r\nstruct arizona_fll_cfg cfg;\r\nint i;\r\nunsigned int val;\r\nif (already_enabled < 0)\r\nreturn already_enabled;\r\nif (sync_enabled < 0)\r\nreturn sync_enabled;\r\nif (already_enabled) {\r\nregmap_update_bits(fll->arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, ARIZONA_FLL1_FREERUN);\r\nudelay(32);\r\nregmap_update_bits_async(fll->arizona->regmap, fll->base + 0x9,\r\nARIZONA_FLL1_GAIN_MASK, 0);\r\nif (arizona_is_enabled_fll(fll, fll->base + 0x10) > 0)\r\narizona_set_fll_clks(fll, fll->base + 0x10, false);\r\narizona_set_fll_clks(fll, fll->base, false);\r\n}\r\nif (fll->ref_src >= 0 && fll->ref_freq &&\r\nfll->ref_src != fll->sync_src) {\r\narizona_calc_fll(fll, &cfg, fll->ref_freq, false);\r\nif (fll->sync_src >= 0 && cfg.lambda)\r\ncfg.theta = (cfg.theta * (1 << 16)) / cfg.lambda;\r\narizona_apply_fll(arizona, fll->base, &cfg, fll->ref_src,\r\nfalse);\r\nif (fll->sync_src >= 0) {\r\narizona_calc_fll(fll, &cfg, fll->sync_freq, true);\r\narizona_apply_fll(arizona, fll->base + 0x10, &cfg,\r\nfll->sync_src, true);\r\nuse_sync = true;\r\n}\r\n} else if (fll->sync_src >= 0) {\r\narizona_calc_fll(fll, &cfg, fll->sync_freq, false);\r\narizona_apply_fll(arizona, fll->base, &cfg,\r\nfll->sync_src, false);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x11,\r\nARIZONA_FLL1_SYNC_ENA, 0);\r\n} else {\r\narizona_fll_err(fll, "No clocks provided\n");\r\nreturn -EINVAL;\r\n}\r\nif (already_enabled && !!sync_enabled != use_sync)\r\narizona_fll_warn(fll, "Synchroniser changed on active FLL\n");\r\nif (use_sync && fll->sync_freq > 100000)\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x17,\r\nARIZONA_FLL1_SYNC_BW, 0);\r\nelse\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x17,\r\nARIZONA_FLL1_SYNC_BW,\r\nARIZONA_FLL1_SYNC_BW);\r\nif (!already_enabled)\r\npm_runtime_get_sync(arizona->dev);\r\nif (use_sync) {\r\narizona_set_fll_clks(fll, fll->base + 0x10, true);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 0x11,\r\nARIZONA_FLL1_SYNC_ENA,\r\nARIZONA_FLL1_SYNC_ENA);\r\n}\r\narizona_set_fll_clks(fll, fll->base, true);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_ENA, ARIZONA_FLL1_ENA);\r\nif (already_enabled)\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, 0);\r\narizona_fll_dbg(fll, "Waiting for FLL lock...\n");\r\nval = 0;\r\nfor (i = 0; i < 15; i++) {\r\nif (i < 5)\r\nusleep_range(200, 400);\r\nelse\r\nmsleep(20);\r\nregmap_read(arizona->regmap,\r\nARIZONA_INTERRUPT_RAW_STATUS_5,\r\n&val);\r\nif (val & (ARIZONA_FLL1_CLOCK_OK_STS << (fll->id - 1)))\r\nbreak;\r\n}\r\nif (i == 15)\r\narizona_fll_warn(fll, "Timed out waiting for lock\n");\r\nelse\r\narizona_fll_dbg(fll, "FLL locked (%d polls)\n", i);\r\nreturn 0;\r\n}\r\nstatic void arizona_disable_fll(struct arizona_fll *fll)\r\n{\r\nstruct arizona *arizona = fll->arizona;\r\nbool ref_change, sync_change;\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, ARIZONA_FLL1_FREERUN);\r\nregmap_update_bits_check(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_ENA, 0, &ref_change);\r\nregmap_update_bits_check(arizona->regmap, fll->base + 0x11,\r\nARIZONA_FLL1_SYNC_ENA, 0, &sync_change);\r\nregmap_update_bits_async(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, 0);\r\nif (sync_change)\r\narizona_set_fll_clks(fll, fll->base + 0x10, false);\r\nif (ref_change) {\r\narizona_set_fll_clks(fll, fll->base, false);\r\npm_runtime_put_autosuspend(arizona->dev);\r\n}\r\n}\r\nint arizona_set_fll_refclk(struct arizona_fll *fll, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nint ret = 0;\r\nif (fll->ref_src == source && fll->ref_freq == Fref)\r\nreturn 0;\r\nif (fll->fout && Fref > 0) {\r\nret = arizona_validate_fll(fll, Fref, fll->fout);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nfll->ref_src = source;\r\nfll->ref_freq = Fref;\r\nif (fll->fout && Fref > 0) {\r\nret = arizona_enable_fll(fll);\r\n}\r\nreturn ret;\r\n}\r\nint arizona_set_fll(struct arizona_fll *fll, int source,\r\nunsigned int Fref, unsigned int Fout)\r\n{\r\nint ret = 0;\r\nif (fll->sync_src == source &&\r\nfll->sync_freq == Fref && fll->fout == Fout)\r\nreturn 0;\r\nif (Fout) {\r\nif (fll->ref_src >= 0) {\r\nret = arizona_validate_fll(fll, fll->ref_freq, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nret = arizona_validate_fll(fll, Fref, Fout);\r\nif (ret != 0)\r\nreturn ret;\r\n}\r\nfll->sync_src = source;\r\nfll->sync_freq = Fref;\r\nfll->fout = Fout;\r\nif (Fout)\r\nret = arizona_enable_fll(fll);\r\nelse\r\narizona_disable_fll(fll);\r\nreturn ret;\r\n}\r\nint arizona_init_fll(struct arizona *arizona, int id, int base, int lock_irq,\r\nint ok_irq, struct arizona_fll *fll)\r\n{\r\nunsigned int val;\r\nfll->id = id;\r\nfll->base = base;\r\nfll->arizona = arizona;\r\nfll->sync_src = ARIZONA_FLL_SRC_NONE;\r\nregmap_read(arizona->regmap, ARIZONA_CLOCK_32K_1, &val);\r\nswitch (val & ARIZONA_CLK_32K_SRC_MASK) {\r\ncase ARIZONA_CLK_SRC_MCLK1:\r\ncase ARIZONA_CLK_SRC_MCLK2:\r\nfll->ref_src = val & ARIZONA_CLK_32K_SRC_MASK;\r\nbreak;\r\ndefault:\r\nfll->ref_src = ARIZONA_FLL_SRC_NONE;\r\n}\r\nfll->ref_freq = 32768;\r\nsnprintf(fll->lock_name, sizeof(fll->lock_name), "FLL%d lock", id);\r\nsnprintf(fll->clock_ok_name, sizeof(fll->clock_ok_name),\r\n"FLL%d clock OK", id);\r\nregmap_update_bits(arizona->regmap, fll->base + 1,\r\nARIZONA_FLL1_FREERUN, 0);\r\nreturn 0;\r\n}\r\nint arizona_set_output_mode(struct snd_soc_codec *codec, int output, bool diff)\r\n{\r\nunsigned int reg, val;\r\nif (output < 1 || output > 6)\r\nreturn -EINVAL;\r\nreg = ARIZONA_OUTPUT_PATH_CONFIG_1L + (output - 1) * 8;\r\nif (diff)\r\nval = ARIZONA_OUT1_MONO;\r\nelse\r\nval = 0;\r\nreturn snd_soc_update_bits(codec, reg, ARIZONA_OUT1_MONO, val);\r\n}\r\nstatic bool arizona_eq_filter_unstable(bool mode, __be16 _a, __be16 _b)\r\n{\r\ns16 a = be16_to_cpu(_a);\r\ns16 b = be16_to_cpu(_b);\r\nif (!mode) {\r\nreturn abs(a) >= 4096;\r\n} else {\r\nif (abs(b) >= 4096)\r\nreturn true;\r\nreturn (abs((a << 16) / (4096 - b)) >= 4096 << 4);\r\n}\r\n}\r\nint arizona_eq_coeff_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct arizona *arizona = dev_get_drvdata(codec->dev->parent);\r\nstruct soc_bytes *params = (void *)kcontrol->private_value;\r\nunsigned int val;\r\n__be16 *data;\r\nint len;\r\nint ret;\r\nlen = params->num_regs * regmap_get_val_bytes(arizona->regmap);\r\ndata = kmemdup(ucontrol->value.bytes.data, len, GFP_KERNEL | GFP_DMA);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata[0] &= cpu_to_be16(ARIZONA_EQ1_B1_MODE);\r\nif (arizona_eq_filter_unstable(!!data[0], data[1], data[2]) ||\r\narizona_eq_filter_unstable(true, data[4], data[5]) ||\r\narizona_eq_filter_unstable(true, data[8], data[9]) ||\r\narizona_eq_filter_unstable(true, data[12], data[13]) ||\r\narizona_eq_filter_unstable(false, data[16], data[17])) {\r\ndev_err(arizona->dev, "Rejecting unstable EQ coefficients\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = regmap_read(arizona->regmap, params->base, &val);\r\nif (ret != 0)\r\ngoto out;\r\nval &= ~ARIZONA_EQ1_B1_MODE;\r\ndata[0] |= cpu_to_be16(val);\r\nret = regmap_raw_write(arizona->regmap, params->base, data, len);\r\nout:\r\nkfree(data);\r\nreturn ret;\r\n}\r\nint arizona_lhpf_coeff_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct arizona *arizona = dev_get_drvdata(codec->dev->parent);\r\n__be16 *data = (__be16 *)ucontrol->value.bytes.data;\r\ns16 val = be16_to_cpu(*data);\r\nif (abs(val) >= 4096) {\r\ndev_err(arizona->dev, "Rejecting unstable LHPF coefficients\n");\r\nreturn -EINVAL;\r\n}\r\nreturn snd_soc_bytes_put(kcontrol, ucontrol);\r\n}
