static void pata_icside_irqenable_arcin_v5 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct pata_icside_state *state = ec->irq_data;\r\nwriteb(0, state->irq_port + ICS_ARCIN_V5_INTROFFSET);\r\n}\r\nstatic void pata_icside_irqdisable_arcin_v5 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct pata_icside_state *state = ec->irq_data;\r\nreadb(state->irq_port + ICS_ARCIN_V5_INTROFFSET);\r\n}\r\nstatic void pata_icside_irqenable_arcin_v6 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct pata_icside_state *state = ec->irq_data;\r\nvoid __iomem *base = state->irq_port;\r\nif (!state->port[0].disabled)\r\nwriteb(0, base + ICS_ARCIN_V6_INTROFFSET_1);\r\nif (!state->port[1].disabled)\r\nwriteb(0, base + ICS_ARCIN_V6_INTROFFSET_2);\r\n}\r\nstatic void pata_icside_irqdisable_arcin_v6 (struct expansion_card *ec, int irqnr)\r\n{\r\nstruct pata_icside_state *state = ec->irq_data;\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_1);\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTROFFSET_2);\r\n}\r\nstatic int pata_icside_irqpending_arcin_v6(struct expansion_card *ec)\r\n{\r\nstruct pata_icside_state *state = ec->irq_data;\r\nreturn readb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_1) & 1 ||\r\nreadb(state->irq_port + ICS_ARCIN_V6_INTRSTAT_2) & 1;\r\n}\r\nstatic void pata_icside_set_dmamode(struct ata_port *ap, struct ata_device *adev)\r\n{\r\nstruct pata_icside_state *state = ap->host->private_data;\r\nstruct ata_timing t;\r\nunsigned int cycle;\r\nchar iomd_type;\r\nif (ata_timing_compute(adev, adev->dma_mode, &t, 1000, 1))\r\nreturn;\r\nif (t.active <= 50 && t.recover <= 375 && t.cycle <= 425)\r\niomd_type = 'D', cycle = 187;\r\nelse if (t.active <= 125 && t.recover <= 375 && t.cycle <= 500)\r\niomd_type = 'C', cycle = 250;\r\nelse if (t.active <= 200 && t.recover <= 550 && t.cycle <= 750)\r\niomd_type = 'B', cycle = 437;\r\nelse\r\niomd_type = 'A', cycle = 562;\r\nata_dev_info(adev, "timings: act %dns rec %dns cyc %dns (%c)\n",\r\nt.active, t.recover, t.cycle, iomd_type);\r\nstate->port[ap->port_no].speed[adev->devno] = cycle;\r\n}\r\nstatic void pata_icside_bmdma_setup(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_icside_state *state = ap->host->private_data;\r\nunsigned int write = qc->tf.flags & ATA_TFLAG_WRITE;\r\nBUG_ON(dma_channel_active(state->dma));\r\nwriteb(state->port[ap->port_no].port_sel, state->ioc_base);\r\nset_dma_speed(state->dma, state->port[ap->port_no].speed[qc->dev->devno]);\r\nset_dma_sg(state->dma, qc->sg, qc->n_elem);\r\nset_dma_mode(state->dma, write ? DMA_MODE_WRITE : DMA_MODE_READ);\r\nap->ops->sff_exec_command(ap, &qc->tf);\r\n}\r\nstatic void pata_icside_bmdma_start(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_icside_state *state = ap->host->private_data;\r\nBUG_ON(dma_channel_active(state->dma));\r\nenable_dma(state->dma);\r\n}\r\nstatic void pata_icside_bmdma_stop(struct ata_queued_cmd *qc)\r\n{\r\nstruct ata_port *ap = qc->ap;\r\nstruct pata_icside_state *state = ap->host->private_data;\r\ndisable_dma(state->dma);\r\nata_sff_dma_pause(ap);\r\n}\r\nstatic u8 pata_icside_bmdma_status(struct ata_port *ap)\r\n{\r\nstruct pata_icside_state *state = ap->host->private_data;\r\nvoid __iomem *irq_port;\r\nirq_port = state->irq_port + (ap->port_no ? ICS_ARCIN_V6_INTRSTAT_2 :\r\nICS_ARCIN_V6_INTRSTAT_1);\r\nreturn readb(irq_port) & 1 ? ATA_DMA_INTR : 0;\r\n}\r\nstatic int icside_dma_init(struct pata_icside_info *info)\r\n{\r\nstruct pata_icside_state *state = info->state;\r\nstruct expansion_card *ec = info->ec;\r\nint i;\r\nfor (i = 0; i < ATA_MAX_DEVICES; i++) {\r\nstate->port[0].speed[i] = 480;\r\nstate->port[1].speed[i] = 480;\r\n}\r\nif (ec->dma != NO_DMA && !request_dma(ec->dma, DRV_NAME)) {\r\nstate->dma = ec->dma;\r\ninfo->mwdma_mask = ATA_MWDMA2;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pata_icside_postreset(struct ata_link *link, unsigned int *classes)\r\n{\r\nstruct ata_port *ap = link->ap;\r\nstruct pata_icside_state *state = ap->host->private_data;\r\nif (classes[0] != ATA_DEV_NONE || classes[1] != ATA_DEV_NONE)\r\nreturn ata_sff_postreset(link, classes);\r\nstate->port[ap->port_no].disabled = 1;\r\nif (state->type == ICS_TYPE_V6) {\r\nvoid __iomem *irq_port = state->irq_port +\r\n(ap->port_no ? ICS_ARCIN_V6_INTROFFSET_2 : ICS_ARCIN_V6_INTROFFSET_1);\r\nreadb(irq_port);\r\n}\r\n}\r\nstatic void pata_icside_setup_ioaddr(struct ata_port *ap, void __iomem *base,\r\nstruct pata_icside_info *info,\r\nconst struct portinfo *port)\r\n{\r\nstruct ata_ioports *ioaddr = &ap->ioaddr;\r\nvoid __iomem *cmd = base + port->dataoffset;\r\nioaddr->cmd_addr = cmd;\r\nioaddr->data_addr = cmd + (ATA_REG_DATA << port->stepping);\r\nioaddr->error_addr = cmd + (ATA_REG_ERR << port->stepping);\r\nioaddr->feature_addr = cmd + (ATA_REG_FEATURE << port->stepping);\r\nioaddr->nsect_addr = cmd + (ATA_REG_NSECT << port->stepping);\r\nioaddr->lbal_addr = cmd + (ATA_REG_LBAL << port->stepping);\r\nioaddr->lbam_addr = cmd + (ATA_REG_LBAM << port->stepping);\r\nioaddr->lbah_addr = cmd + (ATA_REG_LBAH << port->stepping);\r\nioaddr->device_addr = cmd + (ATA_REG_DEVICE << port->stepping);\r\nioaddr->status_addr = cmd + (ATA_REG_STATUS << port->stepping);\r\nioaddr->command_addr = cmd + (ATA_REG_CMD << port->stepping);\r\nioaddr->ctl_addr = base + port->ctrloffset;\r\nioaddr->altstatus_addr = ioaddr->ctl_addr;\r\nata_port_desc(ap, "cmd 0x%lx ctl 0x%lx",\r\ninfo->raw_base + port->dataoffset,\r\ninfo->raw_base + port->ctrloffset);\r\nif (info->raw_ioc_base)\r\nata_port_desc(ap, "iocbase 0x%lx", info->raw_ioc_base);\r\n}\r\nstatic int pata_icside_register_v5(struct pata_icside_info *info)\r\n{\r\nstruct pata_icside_state *state = info->state;\r\nvoid __iomem *base;\r\nbase = ecardm_iomap(info->ec, ECARD_RES_MEMC, 0, 0);\r\nif (!base)\r\nreturn -ENOMEM;\r\nstate->irq_port = base;\r\ninfo->base = base;\r\ninfo->irqaddr = base + ICS_ARCIN_V5_INTRSTAT;\r\ninfo->irqmask = 1;\r\ninfo->irqops = &pata_icside_ops_arcin_v5;\r\ninfo->nr_ports = 1;\r\ninfo->port[0] = &pata_icside_portinfo_v5;\r\ninfo->raw_base = ecard_resource_start(info->ec, ECARD_RES_MEMC);\r\nreturn 0;\r\n}\r\nstatic int pata_icside_register_v6(struct pata_icside_info *info)\r\n{\r\nstruct pata_icside_state *state = info->state;\r\nstruct expansion_card *ec = info->ec;\r\nvoid __iomem *ioc_base, *easi_base;\r\nunsigned int sel = 0;\r\nioc_base = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (!ioc_base)\r\nreturn -ENOMEM;\r\neasi_base = ioc_base;\r\nif (ecard_resource_flags(ec, ECARD_RES_EASI)) {\r\neasi_base = ecardm_iomap(ec, ECARD_RES_EASI, 0, 0);\r\nif (!easi_base)\r\nreturn -ENOMEM;\r\nsel = 1 << 5;\r\n}\r\nwriteb(sel, ioc_base);\r\nstate->irq_port = easi_base;\r\nstate->ioc_base = ioc_base;\r\nstate->port[0].port_sel = sel;\r\nstate->port[1].port_sel = sel | 1;\r\ninfo->base = easi_base;\r\ninfo->irqops = &pata_icside_ops_arcin_v6;\r\ninfo->nr_ports = 2;\r\ninfo->port[0] = &pata_icside_portinfo_v6_1;\r\ninfo->port[1] = &pata_icside_portinfo_v6_2;\r\ninfo->raw_base = ecard_resource_start(ec, ECARD_RES_EASI);\r\ninfo->raw_ioc_base = ecard_resource_start(ec, ECARD_RES_IOCFAST);\r\nreturn icside_dma_init(info);\r\n}\r\nstatic int pata_icside_add_ports(struct pata_icside_info *info)\r\n{\r\nstruct expansion_card *ec = info->ec;\r\nstruct ata_host *host;\r\nint i;\r\nif (info->irqaddr) {\r\nec->irqaddr = info->irqaddr;\r\nec->irqmask = info->irqmask;\r\n}\r\nif (info->irqops)\r\necard_setirq(ec, info->irqops, info->state);\r\nec->ops->irqdisable(ec, ec->irq);\r\nhost = ata_host_alloc(&ec->dev, info->nr_ports);\r\nif (!host)\r\nreturn -ENOMEM;\r\nhost->private_data = info->state;\r\nhost->flags = ATA_HOST_SIMPLEX;\r\nfor (i = 0; i < info->nr_ports; i++) {\r\nstruct ata_port *ap = host->ports[i];\r\nap->pio_mask = ATA_PIO4;\r\nap->mwdma_mask = info->mwdma_mask;\r\nap->flags |= ATA_FLAG_SLAVE_POSS;\r\nap->ops = &pata_icside_port_ops;\r\npata_icside_setup_ioaddr(ap, info->base, info, info->port[i]);\r\n}\r\nreturn ata_host_activate(host, ec->irq, ata_bmdma_interrupt, 0,\r\n&pata_icside_sht);\r\n}\r\nstatic int pata_icside_probe(struct expansion_card *ec,\r\nconst struct ecard_id *id)\r\n{\r\nstruct pata_icside_state *state;\r\nstruct pata_icside_info info;\r\nvoid __iomem *idmem;\r\nint ret;\r\nret = ecard_request_resources(ec);\r\nif (ret)\r\ngoto out;\r\nstate = devm_kzalloc(&ec->dev, sizeof(*state), GFP_KERNEL);\r\nif (!state) {\r\nret = -ENOMEM;\r\ngoto release;\r\n}\r\nstate->type = ICS_TYPE_NOTYPE;\r\nstate->dma = NO_DMA;\r\nidmem = ecardm_iomap(ec, ECARD_RES_IOCFAST, 0, 0);\r\nif (idmem) {\r\nunsigned int type;\r\ntype = readb(idmem + ICS_IDENT_OFFSET) & 1;\r\ntype |= (readb(idmem + ICS_IDENT_OFFSET + 4) & 1) << 1;\r\ntype |= (readb(idmem + ICS_IDENT_OFFSET + 8) & 1) << 2;\r\ntype |= (readb(idmem + ICS_IDENT_OFFSET + 12) & 1) << 3;\r\necardm_iounmap(ec, idmem);\r\nstate->type = type;\r\n}\r\nmemset(&info, 0, sizeof(info));\r\ninfo.state = state;\r\ninfo.ec = ec;\r\nswitch (state->type) {\r\ncase ICS_TYPE_A3IN:\r\ndev_warn(&ec->dev, "A3IN unsupported\n");\r\nret = -ENODEV;\r\nbreak;\r\ncase ICS_TYPE_A3USER:\r\ndev_warn(&ec->dev, "A3USER unsupported\n");\r\nret = -ENODEV;\r\nbreak;\r\ncase ICS_TYPE_V5:\r\nret = pata_icside_register_v5(&info);\r\nbreak;\r\ncase ICS_TYPE_V6:\r\nret = pata_icside_register_v6(&info);\r\nbreak;\r\ndefault:\r\ndev_warn(&ec->dev, "unknown interface type\n");\r\nret = -ENODEV;\r\nbreak;\r\n}\r\nif (ret == 0)\r\nret = pata_icside_add_ports(&info);\r\nif (ret == 0)\r\ngoto out;\r\nrelease:\r\necard_release_resources(ec);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void pata_icside_shutdown(struct expansion_card *ec)\r\n{\r\nstruct ata_host *host = ecard_get_drvdata(ec);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nec->ops->irqdisable(ec, ec->irq);\r\nlocal_irq_restore(flags);\r\nif (host) {\r\nstruct pata_icside_state *state = host->private_data;\r\nif (state->ioc_base)\r\nwriteb(0, state->ioc_base);\r\n}\r\n}\r\nstatic void pata_icside_remove(struct expansion_card *ec)\r\n{\r\nstruct ata_host *host = ecard_get_drvdata(ec);\r\nstruct pata_icside_state *state = host->private_data;\r\nata_host_detach(host);\r\npata_icside_shutdown(ec);\r\nif (state->dma != NO_DMA)\r\nfree_dma(state->dma);\r\necard_release_resources(ec);\r\n}\r\nstatic int __init pata_icside_init(void)\r\n{\r\nreturn ecard_register_driver(&pata_icside_driver);\r\n}\r\nstatic void __exit pata_icside_exit(void)\r\n{\r\necard_remove_driver(&pata_icside_driver);\r\n}
