static inline struct fsl_pwm_chip *to_fsl_chip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct fsl_pwm_chip, chip);\r\n}\r\nstatic int fsl_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nreturn clk_prepare_enable(fpc->clk[FSL_PWM_CLK_SYS]);\r\n}\r\nstatic void fsl_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_SYS]);\r\n}\r\nstatic int fsl_pwm_calculate_default_ps(struct fsl_pwm_chip *fpc,\r\nenum fsl_pwm_clk index)\r\n{\r\nunsigned long sys_rate, cnt_rate;\r\nunsigned long long ratio;\r\nsys_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_SYS]);\r\nif (!sys_rate)\r\nreturn -EINVAL;\r\ncnt_rate = clk_get_rate(fpc->clk[fpc->cnt_select]);\r\nif (!cnt_rate)\r\nreturn -EINVAL;\r\nswitch (index) {\r\ncase FSL_PWM_CLK_SYS:\r\nfpc->clk_ps = 1;\r\nbreak;\r\ncase FSL_PWM_CLK_FIX:\r\nratio = 2 * cnt_rate - 1;\r\ndo_div(ratio, sys_rate);\r\nfpc->clk_ps = ratio;\r\nbreak;\r\ncase FSL_PWM_CLK_EXT:\r\nratio = 4 * cnt_rate - 1;\r\ndo_div(ratio, sys_rate);\r\nfpc->clk_ps = ratio;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned long fsl_pwm_calculate_cycles(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns)\r\n{\r\nunsigned long long c, c0;\r\nc = clk_get_rate(fpc->clk[fpc->cnt_select]);\r\nc = c * period_ns;\r\ndo_div(c, 1000000000UL);\r\ndo {\r\nc0 = c;\r\ndo_div(c0, (1 << fpc->clk_ps));\r\nif (c0 <= 0xFFFF)\r\nreturn (unsigned long)c0;\r\n} while (++fpc->clk_ps < 8);\r\nreturn 0;\r\n}\r\nstatic unsigned long fsl_pwm_calculate_period_cycles(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns,\r\nenum fsl_pwm_clk index)\r\n{\r\nint ret;\r\nret = fsl_pwm_calculate_default_ps(fpc, index);\r\nif (ret) {\r\ndev_err(fpc->chip.dev,\r\n"failed to calculate default prescaler: %d\n",\r\nret);\r\nreturn 0;\r\n}\r\nreturn fsl_pwm_calculate_cycles(fpc, period_ns);\r\n}\r\nstatic unsigned long fsl_pwm_calculate_period(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns)\r\n{\r\nenum fsl_pwm_clk m0, m1;\r\nunsigned long fix_rate, ext_rate, cycles;\r\ncycles = fsl_pwm_calculate_period_cycles(fpc, period_ns,\r\nFSL_PWM_CLK_SYS);\r\nif (cycles) {\r\nfpc->cnt_select = FSL_PWM_CLK_SYS;\r\nreturn cycles;\r\n}\r\nfix_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_FIX]);\r\next_rate = clk_get_rate(fpc->clk[FSL_PWM_CLK_EXT]);\r\nif (fix_rate > ext_rate) {\r\nm0 = FSL_PWM_CLK_FIX;\r\nm1 = FSL_PWM_CLK_EXT;\r\n} else {\r\nm0 = FSL_PWM_CLK_EXT;\r\nm1 = FSL_PWM_CLK_FIX;\r\n}\r\ncycles = fsl_pwm_calculate_period_cycles(fpc, period_ns, m0);\r\nif (cycles) {\r\nfpc->cnt_select = m0;\r\nreturn cycles;\r\n}\r\nfpc->cnt_select = m1;\r\nreturn fsl_pwm_calculate_period_cycles(fpc, period_ns, m1);\r\n}\r\nstatic unsigned long fsl_pwm_calculate_duty(struct fsl_pwm_chip *fpc,\r\nunsigned long period_ns,\r\nunsigned long duty_ns)\r\n{\r\nunsigned long long duty;\r\nu32 val;\r\nregmap_read(fpc->regmap, FTM_MOD, &val);\r\nduty = (unsigned long long)duty_ns * (val + 1);\r\ndo_div(duty, period_ns);\r\nreturn (unsigned long)duty;\r\n}\r\nstatic int fsl_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 period, duty;\r\nmutex_lock(&fpc->lock);\r\nif (fpc->period_ns && fpc->period_ns != period_ns) {\r\ndev_err(fpc->chip.dev,\r\n"conflicting period requested for PWM %u\n",\r\npwm->hwpwm);\r\nmutex_unlock(&fpc->lock);\r\nreturn -EBUSY;\r\n}\r\nif (!fpc->period_ns && duty_ns) {\r\nperiod = fsl_pwm_calculate_period(fpc, period_ns);\r\nif (!period) {\r\ndev_err(fpc->chip.dev, "failed to calculate period\n");\r\nmutex_unlock(&fpc->lock);\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_PS_MASK,\r\nfpc->clk_ps);\r\nregmap_write(fpc->regmap, FTM_MOD, period - 1);\r\nfpc->period_ns = period_ns;\r\n}\r\nmutex_unlock(&fpc->lock);\r\nduty = fsl_pwm_calculate_duty(fpc, period_ns, duty_ns);\r\nregmap_write(fpc->regmap, FTM_CSC(pwm->hwpwm),\r\nFTM_CSC_MSB | FTM_CSC_ELSB);\r\nregmap_write(fpc->regmap, FTM_CV(pwm->hwpwm), duty);\r\nreturn 0;\r\n}\r\nstatic int fsl_pwm_set_polarity(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 val;\r\nregmap_read(fpc->regmap, FTM_POL, &val);\r\nif (polarity == PWM_POLARITY_INVERSED)\r\nval |= BIT(pwm->hwpwm);\r\nelse\r\nval &= ~BIT(pwm->hwpwm);\r\nregmap_write(fpc->regmap, FTM_POL, val);\r\nreturn 0;\r\n}\r\nstatic int fsl_counter_clock_enable(struct fsl_pwm_chip *fpc)\r\n{\r\nint ret;\r\nregmap_update_bits(fpc->regmap, FTM_SC, FTM_SC_CLK_MASK,\r\nFTM_SC_CLK(fpc->cnt_select));\r\nret = clk_prepare_enable(fpc->clk[fpc->cnt_select]);\r\nif (ret)\r\nreturn ret;\r\nret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nif (ret) {\r\nclk_disable_unprepare(fpc->clk[fpc->cnt_select]);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nint ret;\r\nmutex_lock(&fpc->lock);\r\nregmap_update_bits(fpc->regmap, FTM_OUTMASK, BIT(pwm->hwpwm), 0);\r\nret = fsl_counter_clock_enable(fpc);\r\nmutex_unlock(&fpc->lock);\r\nreturn ret;\r\n}\r\nstatic void fsl_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct fsl_pwm_chip *fpc = to_fsl_chip(chip);\r\nu32 val;\r\nmutex_lock(&fpc->lock);\r\nregmap_update_bits(fpc->regmap, FTM_OUTMASK, BIT(pwm->hwpwm),\r\nBIT(pwm->hwpwm));\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nclk_disable_unprepare(fpc->clk[fpc->cnt_select]);\r\nregmap_read(fpc->regmap, FTM_OUTMASK, &val);\r\nif ((val & 0xFF) == 0xFF)\r\nfpc->period_ns = 0;\r\nmutex_unlock(&fpc->lock);\r\n}\r\nstatic int fsl_pwm_init(struct fsl_pwm_chip *fpc)\r\n{\r\nint ret;\r\nret = clk_prepare_enable(fpc->clk[FSL_PWM_CLK_SYS]);\r\nif (ret)\r\nreturn ret;\r\nregmap_write(fpc->regmap, FTM_CNTIN, 0x00);\r\nregmap_write(fpc->regmap, FTM_OUTINIT, 0x00);\r\nregmap_write(fpc->regmap, FTM_OUTMASK, 0xFF);\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_SYS]);\r\nreturn 0;\r\n}\r\nstatic bool fsl_pwm_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase FTM_CNT:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int fsl_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct fsl_pwm_chip *fpc;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret;\r\nfpc = devm_kzalloc(&pdev->dev, sizeof(*fpc), GFP_KERNEL);\r\nif (!fpc)\r\nreturn -ENOMEM;\r\nmutex_init(&fpc->lock);\r\nfpc->chip.dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nfpc->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "ftm_sys", base,\r\n&fsl_pwm_regmap_config);\r\nif (IS_ERR(fpc->regmap)) {\r\ndev_err(&pdev->dev, "regmap init failed\n");\r\nreturn PTR_ERR(fpc->regmap);\r\n}\r\nfpc->clk[FSL_PWM_CLK_SYS] = devm_clk_get(&pdev->dev, "ftm_sys");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_SYS])) {\r\ndev_err(&pdev->dev, "failed to get \"ftm_sys\" clock\n");\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_SYS]);\r\n}\r\nfpc->clk[FSL_PWM_CLK_FIX] = devm_clk_get(fpc->chip.dev, "ftm_fix");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_FIX]))\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_FIX]);\r\nfpc->clk[FSL_PWM_CLK_EXT] = devm_clk_get(fpc->chip.dev, "ftm_ext");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_EXT]))\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_EXT]);\r\nfpc->clk[FSL_PWM_CLK_CNTEN] =\r\ndevm_clk_get(fpc->chip.dev, "ftm_cnt_clk_en");\r\nif (IS_ERR(fpc->clk[FSL_PWM_CLK_CNTEN]))\r\nreturn PTR_ERR(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nfpc->chip.ops = &fsl_pwm_ops;\r\nfpc->chip.of_xlate = of_pwm_xlate_with_flags;\r\nfpc->chip.of_pwm_n_cells = 3;\r\nfpc->chip.base = -1;\r\nfpc->chip.npwm = 8;\r\nret = pwmchip_add(&fpc->chip);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to add PWM chip: %d\n", ret);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, fpc);\r\nreturn fsl_pwm_init(fpc);\r\n}\r\nstatic int fsl_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct fsl_pwm_chip *fpc = platform_get_drvdata(pdev);\r\nreturn pwmchip_remove(&fpc->chip);\r\n}\r\nstatic int fsl_pwm_suspend(struct device *dev)\r\n{\r\nstruct fsl_pwm_chip *fpc = dev_get_drvdata(dev);\r\nint i;\r\nregcache_cache_only(fpc->regmap, true);\r\nregcache_mark_dirty(fpc->regmap);\r\nfor (i = 0; i < fpc->chip.npwm; i++) {\r\nstruct pwm_device *pwm = &fpc->chip.pwms[i];\r\nif (!test_bit(PWMF_REQUESTED, &pwm->flags))\r\ncontinue;\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_SYS]);\r\nif (!pwm_is_enabled(pwm))\r\ncontinue;\r\nclk_disable_unprepare(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\nclk_disable_unprepare(fpc->clk[fpc->cnt_select]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int fsl_pwm_resume(struct device *dev)\r\n{\r\nstruct fsl_pwm_chip *fpc = dev_get_drvdata(dev);\r\nint i;\r\nfor (i = 0; i < fpc->chip.npwm; i++) {\r\nstruct pwm_device *pwm = &fpc->chip.pwms[i];\r\nif (!test_bit(PWMF_REQUESTED, &pwm->flags))\r\ncontinue;\r\nclk_prepare_enable(fpc->clk[FSL_PWM_CLK_SYS]);\r\nif (!pwm_is_enabled(pwm))\r\ncontinue;\r\nclk_prepare_enable(fpc->clk[fpc->cnt_select]);\r\nclk_prepare_enable(fpc->clk[FSL_PWM_CLK_CNTEN]);\r\n}\r\nregcache_cache_only(fpc->regmap, false);\r\nregcache_sync(fpc->regmap);\r\nreturn 0;\r\n}
