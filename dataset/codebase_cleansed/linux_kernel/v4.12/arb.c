static void\r\nnv04_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)\r\n{\r\nint pagemiss, cas, width, bpp;\r\nint nvclks, mclks, pclks, crtpagemiss;\r\nint found, mclk_extra, mclk_loop, cbs, m1, p1;\r\nint mclk_freq, pclk_freq, nvclk_freq;\r\nint us_m, us_n, us_p, crtc_drain_rate;\r\nint cpm_us, us_crt, clwm;\r\npclk_freq = arb->pclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\npagemiss = arb->mem_page_miss;\r\ncas = arb->mem_latency;\r\nwidth = arb->memory_width >> 6;\r\nbpp = arb->bpp;\r\ncbs = 128;\r\npclks = 2;\r\nnvclks = 10;\r\nmclks = 13 + cas;\r\nmclk_extra = 3;\r\nfound = 0;\r\nwhile (!found) {\r\nfound = 1;\r\nmclk_loop = mclks + mclk_extra;\r\nus_m = mclk_loop * 1000 * 1000 / mclk_freq;\r\nus_n = nvclks * 1000 * 1000 / nvclk_freq;\r\nus_p = nvclks * 1000 * 1000 / pclk_freq;\r\ncrtc_drain_rate = pclk_freq * bpp / 8;\r\ncrtpagemiss = 2;\r\ncrtpagemiss += 1;\r\ncpm_us = crtpagemiss * pagemiss * 1000 * 1000 / mclk_freq;\r\nus_crt = cpm_us + us_m + us_n + us_p;\r\nclwm = us_crt * crtc_drain_rate / (1000 * 1000);\r\nclwm++;\r\nm1 = clwm + cbs - 512;\r\np1 = m1 * pclk_freq / mclk_freq;\r\np1 = p1 * bpp / 8;\r\nif ((p1 < m1 && m1 > 0) || clwm > 519) {\r\nfound = !mclk_extra;\r\nmclk_extra--;\r\n}\r\nif (clwm < 384)\r\nclwm = 384;\r\nfifo->lwm = clwm;\r\nfifo->burst = cbs;\r\n}\r\n}\r\nstatic void\r\nnv10_calc_arb(struct nv_fifo_info *fifo, struct nv_sim_state *arb)\r\n{\r\nint fill_rate, drain_rate;\r\nint pclks, nvclks, mclks, xclks;\r\nint pclk_freq, nvclk_freq, mclk_freq;\r\nint fill_lat, extra_lat;\r\nint max_burst_o, max_burst_l;\r\nint fifo_len, min_lwm, max_lwm;\r\nconst int burst_lat = 80;\r\npclk_freq = arb->pclk_khz;\r\nnvclk_freq = arb->nvclk_khz;\r\nmclk_freq = arb->mclk_khz;\r\nfill_rate = mclk_freq * arb->memory_width / 8;\r\ndrain_rate = pclk_freq * arb->bpp / 8;\r\nfifo_len = arb->two_heads ? 1536 : 1024;\r\npclks = 4;\r\nnvclks = 3\r\n+ 2\r\n+ 1\r\n+ 1\r\n+ 1\r\n+ 1;\r\nmclks = 1\r\n+ 1\r\n+ 5\r\n+ 2\r\n+ 2\r\n+ 7;\r\nmclks += (arb->memory_type == 0 ? 2 : 1)\r\n* arb->memory_width / 32;\r\nfill_lat = mclks * 1000 * 1000 / mclk_freq\r\n+ nvclks * 1000 * 1000 / nvclk_freq\r\n+ pclks * 1000 * 1000 / pclk_freq;\r\nxclks = 2 * arb->mem_page_miss + mclks\r\n+ 2 * arb->mem_page_miss\r\n+ (arb->bpp == 32 ? 8 : 4);\r\nextra_lat = xclks * 1000 * 1000 / mclk_freq;\r\nif (arb->two_heads)\r\nextra_lat += fill_lat + extra_lat + burst_lat;\r\nmax_burst_o = (1 + fifo_len - extra_lat * drain_rate / (1000 * 1000))\r\n* (fill_rate / 1000) / ((fill_rate - drain_rate) / 1000);\r\nfifo->burst = min(max_burst_o, 1024);\r\nmax_burst_l = burst_lat * fill_rate / (1000 * 1000);\r\nfifo->burst = min(max_burst_l, fifo->burst);\r\nfifo->burst = rounddown_pow_of_two(fifo->burst);\r\nmin_lwm = (fill_lat + extra_lat) * drain_rate / (1000 * 1000) + 1;\r\nmax_lwm = fifo_len - fifo->burst\r\n+ fill_lat * drain_rate / (1000 * 1000)\r\n+ fifo->burst * drain_rate / fill_rate;\r\nfifo->lwm = min_lwm + 10 * (max_lwm - min_lwm) / 100;\r\n}\r\nstatic void\r\nnv04_update_arb(struct drm_device *dev, int VClk, int bpp,\r\nint *burst, int *lwm)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nstruct nvif_object *device = &nouveau_drm(dev)->client.device.object;\r\nstruct nv_fifo_info fifo_data;\r\nstruct nv_sim_state sim_data;\r\nint MClk = nouveau_hw_get_clock(dev, PLL_MEMORY);\r\nint NVClk = nouveau_hw_get_clock(dev, PLL_CORE);\r\nuint32_t cfg1 = nvif_rd32(device, NV04_PFB_CFG1);\r\nsim_data.pclk_khz = VClk;\r\nsim_data.mclk_khz = MClk;\r\nsim_data.nvclk_khz = NVClk;\r\nsim_data.bpp = bpp;\r\nsim_data.two_heads = nv_two_heads(dev);\r\nif ((dev->pdev->device & 0xffff) == 0x01a0 ||\r\n(dev->pdev->device & 0xffff) == 0x01f0 ) {\r\nuint32_t type;\r\npci_read_config_dword(pci_get_bus_and_slot(0, 1), 0x7c, &type);\r\nsim_data.memory_type = (type >> 12) & 1;\r\nsim_data.memory_width = 64;\r\nsim_data.mem_latency = 3;\r\nsim_data.mem_page_miss = 10;\r\n} else {\r\nsim_data.memory_type = nvif_rd32(device, NV04_PFB_CFG0) & 0x1;\r\nsim_data.memory_width = (nvif_rd32(device, NV_PEXTDEV_BOOT_0) & 0x10) ? 128 : 64;\r\nsim_data.mem_latency = cfg1 & 0xf;\r\nsim_data.mem_page_miss = ((cfg1 >> 4) & 0xf) + ((cfg1 >> 31) & 0x1);\r\n}\r\nif (drm->client.device.info.family == NV_DEVICE_INFO_V0_TNT)\r\nnv04_calc_arb(&fifo_data, &sim_data);\r\nelse\r\nnv10_calc_arb(&fifo_data, &sim_data);\r\n*burst = ilog2(fifo_data.burst >> 4);\r\n*lwm = fifo_data.lwm >> 3;\r\n}\r\nstatic void\r\nnv20_update_arb(int *burst, int *lwm)\r\n{\r\nunsigned int fifo_size, burst_size, graphics_lwm;\r\nfifo_size = 2048;\r\nburst_size = 512;\r\ngraphics_lwm = fifo_size - burst_size;\r\n*burst = ilog2(burst_size >> 5);\r\n*lwm = graphics_lwm >> 3;\r\n}\r\nvoid\r\nnouveau_calc_arb(struct drm_device *dev, int vclk, int bpp, int *burst, int *lwm)\r\n{\r\nstruct nouveau_drm *drm = nouveau_drm(dev);\r\nif (drm->client.device.info.family < NV_DEVICE_INFO_V0_KELVIN)\r\nnv04_update_arb(dev, vclk, bpp, burst, lwm);\r\nelse if ((dev->pdev->device & 0xfff0) == 0x0240 ||\r\n(dev->pdev->device & 0xfff0) == 0x03d0 ) {\r\n*burst = 128;\r\n*lwm = 0x0480;\r\n} else\r\nnv20_update_arb(burst, lwm);\r\n}
