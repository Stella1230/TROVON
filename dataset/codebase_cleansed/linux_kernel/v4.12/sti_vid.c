static void vid_dbg_ctl(struct seq_file *s, int val)\r\n{\r\nval = val >> 30;\r\nseq_puts(s, "\t");\r\nif (!(val & 1))\r\nseq_puts(s, "NOT ");\r\nseq_puts(s, "ignored on main mixer - ");\r\nif (!(val & 2))\r\nseq_puts(s, "NOT ");\r\nseq_puts(s, "ignored on aux mixer");\r\n}\r\nstatic void vid_dbg_vpo(struct seq_file *s, int val)\r\n{\r\nseq_printf(s, "\txdo:%4d\tydo:%4d", val & 0x0FFF, (val >> 16) & 0x0FFF);\r\n}\r\nstatic void vid_dbg_vps(struct seq_file *s, int val)\r\n{\r\nseq_printf(s, "\txds:%4d\tyds:%4d", val & 0x0FFF, (val >> 16) & 0x0FFF);\r\n}\r\nstatic void vid_dbg_mst(struct seq_file *s, int val)\r\n{\r\nif (val & 1)\r\nseq_puts(s, "\tBUFFER UNDERFLOW!");\r\n}\r\nstatic int vid_dbg_show(struct seq_file *s, void *arg)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct sti_vid *vid = (struct sti_vid *)node->info_ent->data;\r\nseq_printf(s, "VID: (vaddr= 0x%p)", vid->regs);\r\nDBGFS_DUMP(VID_CTL);\r\nvid_dbg_ctl(s, readl(vid->regs + VID_CTL));\r\nDBGFS_DUMP(VID_ALP);\r\nDBGFS_DUMP(VID_CLF);\r\nDBGFS_DUMP(VID_VPO);\r\nvid_dbg_vpo(s, readl(vid->regs + VID_VPO));\r\nDBGFS_DUMP(VID_VPS);\r\nvid_dbg_vps(s, readl(vid->regs + VID_VPS));\r\nDBGFS_DUMP(VID_KEY1);\r\nDBGFS_DUMP(VID_KEY2);\r\nDBGFS_DUMP(VID_MPR0);\r\nDBGFS_DUMP(VID_MPR1);\r\nDBGFS_DUMP(VID_MPR2);\r\nDBGFS_DUMP(VID_MPR3);\r\nDBGFS_DUMP(VID_MST);\r\nvid_dbg_mst(s, readl(vid->regs + VID_MST));\r\nDBGFS_DUMP(VID_BC);\r\nDBGFS_DUMP(VID_TINT);\r\nDBGFS_DUMP(VID_CSAT);\r\nseq_puts(s, "\n");\r\nreturn 0;\r\n}\r\nint vid_debugfs_init(struct sti_vid *vid, struct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(vid_debugfs_files); i++)\r\nvid_debugfs_files[i].data = vid;\r\nreturn drm_debugfs_create_files(vid_debugfs_files,\r\nARRAY_SIZE(vid_debugfs_files),\r\nminor->debugfs_root, minor);\r\n}\r\nvoid sti_vid_commit(struct sti_vid *vid,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_crtc *crtc = state->crtc;\r\nstruct drm_display_mode *mode = &crtc->mode;\r\nint dst_x = state->crtc_x;\r\nint dst_y = state->crtc_y;\r\nint dst_w = clamp_val(state->crtc_w, 0, mode->hdisplay - dst_x);\r\nint dst_h = clamp_val(state->crtc_h, 0, mode->vdisplay - dst_y);\r\nint src_h = state->src_h >> 16;\r\nu32 val, ydo, xdo, yds, xds;\r\ndst_w = ALIGN(dst_w, 2);\r\ndst_h = ALIGN(dst_h, 2);\r\nval = readl(vid->regs + VID_CTL);\r\nval &= ~VID_CTL_IGNORE;\r\nwritel(val, vid->regs + VID_CTL);\r\nydo = sti_vtg_get_line_number(*mode, dst_y);\r\nyds = sti_vtg_get_line_number(*mode, dst_y + dst_h - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, dst_x);\r\nxds = sti_vtg_get_pixel_number(*mode, dst_x + dst_w - 1);\r\nwritel((ydo << 16) | xdo, vid->regs + VID_VPO);\r\nwritel((yds << 16) | xds, vid->regs + VID_VPS);\r\nif (src_h >= VID_MIN_HD_HEIGHT) {\r\nwritel(VID_MPR0_BT709, vid->regs + VID_MPR0);\r\nwritel(VID_MPR1_BT709, vid->regs + VID_MPR1);\r\nwritel(VID_MPR2_BT709, vid->regs + VID_MPR2);\r\nwritel(VID_MPR3_BT709, vid->regs + VID_MPR3);\r\n} else {\r\nwritel(VID_MPR0_BT601, vid->regs + VID_MPR0);\r\nwritel(VID_MPR1_BT601, vid->regs + VID_MPR1);\r\nwritel(VID_MPR2_BT601, vid->regs + VID_MPR2);\r\nwritel(VID_MPR3_BT601, vid->regs + VID_MPR3);\r\n}\r\n}\r\nvoid sti_vid_disable(struct sti_vid *vid)\r\n{\r\nu32 val;\r\nval = readl(vid->regs + VID_CTL);\r\nval |= VID_CTL_IGNORE;\r\nwritel(val, vid->regs + VID_CTL);\r\n}\r\nstatic void sti_vid_init(struct sti_vid *vid)\r\n{\r\nwritel(VID_CTL_PSI_ENABLE | VID_CTL_IGNORE, vid->regs + VID_CTL);\r\nwritel(VID_ALP_OPAQUE, vid->regs + VID_ALP);\r\nwritel(VID_BC_DFLT, vid->regs + VID_BC);\r\nwritel(VID_TINT_DFLT, vid->regs + VID_TINT);\r\nwritel(VID_CSAT_DFLT, vid->regs + VID_CSAT);\r\n}\r\nstruct sti_vid *sti_vid_create(struct device *dev, struct drm_device *drm_dev,\r\nint id, void __iomem *baseaddr)\r\n{\r\nstruct sti_vid *vid;\r\nvid = devm_kzalloc(dev, sizeof(*vid), GFP_KERNEL);\r\nif (!vid) {\r\nDRM_ERROR("Failed to allocate memory for VID\n");\r\nreturn NULL;\r\n}\r\nvid->dev = dev;\r\nvid->regs = baseaddr;\r\nvid->id = id;\r\nsti_vid_init(vid);\r\nreturn vid;\r\n}
