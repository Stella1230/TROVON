static bool\r\ncsio_scsi_match_io(struct csio_ioreq *ioreq, struct csio_scsi_level_data *sld)\r\n{\r\nstruct scsi_cmnd *scmnd = csio_scsi_cmnd(ioreq);\r\nswitch (sld->level) {\r\ncase CSIO_LEV_LUN:\r\nif (scmnd == NULL)\r\nreturn false;\r\nreturn ((ioreq->lnode == sld->lnode) &&\r\n(ioreq->rnode == sld->rnode) &&\r\n((uint64_t)scmnd->device->lun == sld->oslun));\r\ncase CSIO_LEV_RNODE:\r\nreturn ((ioreq->lnode == sld->lnode) &&\r\n(ioreq->rnode == sld->rnode));\r\ncase CSIO_LEV_LNODE:\r\nreturn (ioreq->lnode == sld->lnode);\r\ncase CSIO_LEV_ALL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void\r\ncsio_scsi_gather_active_ios(struct csio_scsim *scm,\r\nstruct csio_scsi_level_data *sld,\r\nstruct list_head *dest)\r\n{\r\nstruct list_head *tmp, *next;\r\nif (list_empty(&scm->active_q))\r\nreturn;\r\nif (sld->level == CSIO_LEV_ALL) {\r\nlist_splice_tail_init(&scm->active_q, dest);\r\nreturn;\r\n}\r\nlist_for_each_safe(tmp, next, &scm->active_q) {\r\nif (csio_scsi_match_io((struct csio_ioreq *)tmp, sld)) {\r\nlist_del_init(tmp);\r\nlist_add_tail(tmp, dest);\r\n}\r\n}\r\n}\r\nstatic inline bool\r\ncsio_scsi_itnexus_loss_error(uint16_t error)\r\n{\r\nswitch (error) {\r\ncase FW_ERR_LINK_DOWN:\r\ncase FW_RDEV_NOT_READY:\r\ncase FW_ERR_RDEV_LOST:\r\ncase FW_ERR_RDEV_LOGO:\r\ncase FW_ERR_RDEV_IMPL_LOGO:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void\r\ncsio_scsi_fcp_cmnd(struct csio_ioreq *req, void *addr)\r\n{\r\nstruct fcp_cmnd *fcp_cmnd = (struct fcp_cmnd *)addr;\r\nstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\r\nif (likely(scmnd->SCp.Message == 0)) {\r\nint_to_scsilun(scmnd->device->lun, &fcp_cmnd->fc_lun);\r\nfcp_cmnd->fc_tm_flags = 0;\r\nfcp_cmnd->fc_cmdref = 0;\r\nmemcpy(fcp_cmnd->fc_cdb, scmnd->cmnd, 16);\r\nfcp_cmnd->fc_pri_ta = FCP_PTA_SIMPLE;\r\nfcp_cmnd->fc_dl = cpu_to_be32(scsi_bufflen(scmnd));\r\nif (req->nsge)\r\nif (req->datadir == DMA_TO_DEVICE)\r\nfcp_cmnd->fc_flags = FCP_CFL_WRDATA;\r\nelse\r\nfcp_cmnd->fc_flags = FCP_CFL_RDDATA;\r\nelse\r\nfcp_cmnd->fc_flags = 0;\r\n} else {\r\nmemset(fcp_cmnd, 0, sizeof(*fcp_cmnd));\r\nint_to_scsilun(scmnd->device->lun, &fcp_cmnd->fc_lun);\r\nfcp_cmnd->fc_tm_flags = (uint8_t)scmnd->SCp.Message;\r\n}\r\n}\r\nstatic inline void\r\ncsio_scsi_init_cmd_wr(struct csio_ioreq *req, void *addr, uint32_t size)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_rnode *rn = req->rnode;\r\nstruct fw_scsi_cmd_wr *wr = (struct fw_scsi_cmd_wr *)addr;\r\nstruct csio_dma_buf *dma_buf;\r\nuint8_t imm = csio_hw_to_scsim(hw)->proto_cmd_len;\r\nwr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_CMD_WR) |\r\nFW_SCSI_CMD_WR_IMMDLEN(imm));\r\nwr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\r\nFW_WR_LEN16_V(\r\nDIV_ROUND_UP(size, 16)));\r\nwr->cookie = (uintptr_t) req;\r\nwr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\r\nwr->tmo_val = (uint8_t) req->tmo;\r\nwr->r3 = 0;\r\nmemset(&wr->r5, 0, 8);\r\ndma_buf = &req->dma_buf;\r\nwr->rsp_dmalen = cpu_to_be32(dma_buf->len);\r\nwr->rsp_dmaaddr = cpu_to_be64(dma_buf->paddr);\r\nwr->r6 = 0;\r\nwr->u.fcoe.ctl_pri = 0;\r\nwr->u.fcoe.cp_en_class = 0;\r\nwr->u.fcoe.r4_lo[0] = 0;\r\nwr->u.fcoe.r4_lo[1] = 0;\r\ncsio_scsi_fcp_cmnd(req, (void *)((uintptr_t)addr +\r\nsizeof(struct fw_scsi_cmd_wr)));\r\n}\r\nstatic inline void\r\ncsio_scsi_cmd(struct csio_ioreq *req)\r\n{\r\nstruct csio_wr_pair wrp;\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nuint32_t size = CSIO_SCSI_CMD_WR_SZ_16(scsim->proto_cmd_len);\r\nreq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\r\nif (unlikely(req->drv_status != 0))\r\nreturn;\r\nif (wrp.size1 >= size) {\r\ncsio_scsi_init_cmd_wr(req, wrp.addr1, size);\r\n} else {\r\nuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\r\ncsio_scsi_init_cmd_wr(req, (void *)tmpwr, size);\r\nmemcpy(wrp.addr1, tmpwr, wrp.size1);\r\nmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\r\n}\r\n}\r\nstatic inline void\r\ncsio_scsi_init_ultptx_dsgl(struct csio_hw *hw, struct csio_ioreq *req,\r\nstruct ulptx_sgl *sgl)\r\n{\r\nstruct ulptx_sge_pair *sge_pair = NULL;\r\nstruct scatterlist *sgel;\r\nuint32_t i = 0;\r\nuint32_t xfer_len;\r\nstruct list_head *tmp;\r\nstruct csio_dma_buf *dma_buf;\r\nstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\r\nsgl->cmd_nsge = htonl(ULPTX_CMD_V(ULP_TX_SC_DSGL) | ULPTX_MORE_F |\r\nULPTX_NSGE_V(req->nsge));\r\nif (likely(!req->dcopy)) {\r\nscsi_for_each_sg(scmnd, sgel, req->nsge, i) {\r\nif (i == 0) {\r\nsgl->addr0 = cpu_to_be64(sg_dma_address(sgel));\r\nsgl->len0 = cpu_to_be32(sg_dma_len(sgel));\r\nsge_pair = (struct ulptx_sge_pair *)(sgl + 1);\r\ncontinue;\r\n}\r\nif ((i - 1) & 0x1) {\r\nsge_pair->addr[1] = cpu_to_be64(\r\nsg_dma_address(sgel));\r\nsge_pair->len[1] = cpu_to_be32(\r\nsg_dma_len(sgel));\r\nsge_pair++;\r\n} else {\r\nsge_pair->addr[0] = cpu_to_be64(\r\nsg_dma_address(sgel));\r\nsge_pair->len[0] = cpu_to_be32(\r\nsg_dma_len(sgel));\r\n}\r\n}\r\n} else {\r\nxfer_len = scsi_bufflen(scmnd);\r\nlist_for_each(tmp, &req->gen_list) {\r\ndma_buf = (struct csio_dma_buf *)tmp;\r\nif (i == 0) {\r\nsgl->addr0 = cpu_to_be64(dma_buf->paddr);\r\nsgl->len0 = cpu_to_be32(\r\nmin(xfer_len, dma_buf->len));\r\nsge_pair = (struct ulptx_sge_pair *)(sgl + 1);\r\n} else if ((i - 1) & 0x1) {\r\nsge_pair->addr[1] = cpu_to_be64(dma_buf->paddr);\r\nsge_pair->len[1] = cpu_to_be32(\r\nmin(xfer_len, dma_buf->len));\r\nsge_pair++;\r\n} else {\r\nsge_pair->addr[0] = cpu_to_be64(dma_buf->paddr);\r\nsge_pair->len[0] = cpu_to_be32(\r\nmin(xfer_len, dma_buf->len));\r\n}\r\nxfer_len -= min(xfer_len, dma_buf->len);\r\ni++;\r\n}\r\n}\r\n}\r\nstatic inline void\r\ncsio_scsi_init_read_wr(struct csio_ioreq *req, void *wrp, uint32_t size)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_rnode *rn = req->rnode;\r\nstruct fw_scsi_read_wr *wr = (struct fw_scsi_read_wr *)wrp;\r\nstruct ulptx_sgl *sgl;\r\nstruct csio_dma_buf *dma_buf;\r\nuint8_t imm = csio_hw_to_scsim(hw)->proto_cmd_len;\r\nstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\r\nwr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_READ_WR) |\r\nFW_SCSI_READ_WR_IMMDLEN(imm));\r\nwr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\r\nFW_WR_LEN16_V(DIV_ROUND_UP(size, 16)));\r\nwr->cookie = (uintptr_t)req;\r\nwr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\r\nwr->tmo_val = (uint8_t)(req->tmo);\r\nwr->use_xfer_cnt = 1;\r\nwr->xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\r\nwr->ini_xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\r\ndma_buf = &req->dma_buf;\r\nwr->rsp_dmalen = cpu_to_be32(dma_buf->len);\r\nwr->rsp_dmaaddr = cpu_to_be64(dma_buf->paddr);\r\nwr->r4 = 0;\r\nwr->u.fcoe.ctl_pri = 0;\r\nwr->u.fcoe.cp_en_class = 0;\r\nwr->u.fcoe.r3_lo[0] = 0;\r\nwr->u.fcoe.r3_lo[1] = 0;\r\ncsio_scsi_fcp_cmnd(req, (void *)((uintptr_t)wrp +\r\nsizeof(struct fw_scsi_read_wr)));\r\nsgl = (struct ulptx_sgl *)((uintptr_t)wrp +\r\nsizeof(struct fw_scsi_read_wr) + ALIGN(imm, 16));\r\ncsio_scsi_init_ultptx_dsgl(hw, req, sgl);\r\n}\r\nstatic inline void\r\ncsio_scsi_init_write_wr(struct csio_ioreq *req, void *wrp, uint32_t size)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_rnode *rn = req->rnode;\r\nstruct fw_scsi_write_wr *wr = (struct fw_scsi_write_wr *)wrp;\r\nstruct ulptx_sgl *sgl;\r\nstruct csio_dma_buf *dma_buf;\r\nuint8_t imm = csio_hw_to_scsim(hw)->proto_cmd_len;\r\nstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\r\nwr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_WRITE_WR) |\r\nFW_SCSI_WRITE_WR_IMMDLEN(imm));\r\nwr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\r\nFW_WR_LEN16_V(DIV_ROUND_UP(size, 16)));\r\nwr->cookie = (uintptr_t)req;\r\nwr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\r\nwr->tmo_val = (uint8_t)(req->tmo);\r\nwr->use_xfer_cnt = 1;\r\nwr->xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\r\nwr->ini_xfer_cnt = cpu_to_be32(scsi_bufflen(scmnd));\r\ndma_buf = &req->dma_buf;\r\nwr->rsp_dmalen = cpu_to_be32(dma_buf->len);\r\nwr->rsp_dmaaddr = cpu_to_be64(dma_buf->paddr);\r\nwr->r4 = 0;\r\nwr->u.fcoe.ctl_pri = 0;\r\nwr->u.fcoe.cp_en_class = 0;\r\nwr->u.fcoe.r3_lo[0] = 0;\r\nwr->u.fcoe.r3_lo[1] = 0;\r\ncsio_scsi_fcp_cmnd(req, (void *)((uintptr_t)wrp +\r\nsizeof(struct fw_scsi_write_wr)));\r\nsgl = (struct ulptx_sgl *)((uintptr_t)wrp +\r\nsizeof(struct fw_scsi_write_wr) + ALIGN(imm, 16));\r\ncsio_scsi_init_ultptx_dsgl(hw, req, sgl);\r\n}\r\nstatic inline void\r\ncsio_scsi_read(struct csio_ioreq *req)\r\n{\r\nstruct csio_wr_pair wrp;\r\nuint32_t size;\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nCSIO_SCSI_DATA_WRSZ(req, read, size, scsim->proto_cmd_len);\r\nsize = ALIGN(size, 16);\r\nreq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\r\nif (likely(req->drv_status == 0)) {\r\nif (likely(wrp.size1 >= size)) {\r\ncsio_scsi_init_read_wr(req, wrp.addr1, size);\r\n} else {\r\nuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\r\ncsio_scsi_init_read_wr(req, (void *)tmpwr, size);\r\nmemcpy(wrp.addr1, tmpwr, wrp.size1);\r\nmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\r\n}\r\n}\r\n}\r\nstatic inline void\r\ncsio_scsi_write(struct csio_ioreq *req)\r\n{\r\nstruct csio_wr_pair wrp;\r\nuint32_t size;\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nCSIO_SCSI_DATA_WRSZ(req, write, size, scsim->proto_cmd_len);\r\nsize = ALIGN(size, 16);\r\nreq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\r\nif (likely(req->drv_status == 0)) {\r\nif (likely(wrp.size1 >= size)) {\r\ncsio_scsi_init_write_wr(req, wrp.addr1, size);\r\n} else {\r\nuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\r\ncsio_scsi_init_write_wr(req, (void *)tmpwr, size);\r\nmemcpy(wrp.addr1, tmpwr, wrp.size1);\r\nmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\r\n}\r\n}\r\n}\r\nstatic inline void\r\ncsio_setup_ddp(struct csio_scsim *scsim, struct csio_ioreq *req)\r\n{\r\n#ifdef __CSIO_DEBUG__\r\nstruct csio_hw *hw = req->lnode->hwp;\r\n#endif\r\nstruct scatterlist *sgel = NULL;\r\nstruct scsi_cmnd *scmnd = csio_scsi_cmnd(req);\r\nuint64_t sg_addr = 0;\r\nuint32_t ddp_pagesz = 4096;\r\nuint32_t buf_off;\r\nstruct csio_dma_buf *dma_buf = NULL;\r\nuint32_t alloc_len = 0;\r\nuint32_t xfer_len = 0;\r\nuint32_t sg_len = 0;\r\nuint32_t i;\r\nscsi_for_each_sg(scmnd, sgel, req->nsge, i) {\r\nsg_addr = sg_dma_address(sgel);\r\nsg_len = sg_dma_len(sgel);\r\nbuf_off = sg_addr & (ddp_pagesz - 1);\r\nif (i != 0 && buf_off) {\r\ncsio_dbg(hw, "SGL addr not DDP aligned (%llx:%d)\n",\r\nsg_addr, sg_len);\r\ngoto unaligned;\r\n}\r\nif ((i != (req->nsge - 1)) &&\r\n((buf_off + sg_len) & (ddp_pagesz - 1))) {\r\ncsio_dbg(hw,\r\n"SGL addr not ending on page boundary"\r\n"(%llx:%d)\n", sg_addr, sg_len);\r\ngoto unaligned;\r\n}\r\n}\r\nreq->dcopy = 0;\r\ncsio_scsi_read(req);\r\nreturn;\r\nunaligned:\r\nCSIO_INC_STATS(scsim, n_unaligned);\r\nreq->dcopy = 1;\r\nINIT_LIST_HEAD(&req->gen_list);\r\nxfer_len = scsi_bufflen(scmnd);\r\ni = 0;\r\nwhile (alloc_len < xfer_len) {\r\ndma_buf = csio_get_scsi_ddp(scsim);\r\nif (dma_buf == NULL || i > scsim->max_sge) {\r\nreq->drv_status = -EBUSY;\r\nbreak;\r\n}\r\nalloc_len += dma_buf->len;\r\nlist_add_tail(&dma_buf->list, &req->gen_list);\r\ni++;\r\n}\r\nif (!req->drv_status) {\r\nreq->nsge = i;\r\ncsio_scsi_read(req);\r\nreturn;\r\n}\r\nif (i > 0)\r\ncsio_put_scsi_ddp_list(scsim, &req->gen_list, i);\r\n}\r\nstatic inline void\r\ncsio_scsi_init_abrt_cls_wr(struct csio_ioreq *req, void *addr, uint32_t size,\r\nbool abort)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_rnode *rn = req->rnode;\r\nstruct fw_scsi_abrt_cls_wr *wr = (struct fw_scsi_abrt_cls_wr *)addr;\r\nwr->op_immdlen = cpu_to_be32(FW_WR_OP_V(FW_SCSI_ABRT_CLS_WR));\r\nwr->flowid_len16 = cpu_to_be32(FW_WR_FLOWID_V(rn->flowid) |\r\nFW_WR_LEN16_V(\r\nDIV_ROUND_UP(size, 16)));\r\nwr->cookie = (uintptr_t) req;\r\nwr->iqid = cpu_to_be16(csio_q_physiqid(hw, req->iq_idx));\r\nwr->tmo_val = (uint8_t) req->tmo;\r\nwr->sub_opcode_to_chk_all_io =\r\n(FW_SCSI_ABRT_CLS_WR_SUB_OPCODE(abort) |\r\nFW_SCSI_ABRT_CLS_WR_CHK_ALL_IO(0));\r\nwr->r3[0] = 0;\r\nwr->r3[1] = 0;\r\nwr->r3[2] = 0;\r\nwr->r3[3] = 0;\r\nwr->t_cookie = (uintptr_t) req;\r\n}\r\nstatic inline void\r\ncsio_scsi_abrt_cls(struct csio_ioreq *req, bool abort)\r\n{\r\nstruct csio_wr_pair wrp;\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nuint32_t size = ALIGN(sizeof(struct fw_scsi_abrt_cls_wr), 16);\r\nreq->drv_status = csio_wr_get(hw, req->eq_idx, size, &wrp);\r\nif (req->drv_status != 0)\r\nreturn;\r\nif (wrp.size1 >= size) {\r\ncsio_scsi_init_abrt_cls_wr(req, wrp.addr1, size, abort);\r\n} else {\r\nuint8_t *tmpwr = csio_q_eq_wrap(hw, req->eq_idx);\r\ncsio_scsi_init_abrt_cls_wr(req, (void *)tmpwr, size, abort);\r\nmemcpy(wrp.addr1, tmpwr, wrp.size1);\r\nmemcpy(wrp.addr2, tmpwr + wrp.size1, size - wrp.size1);\r\n}\r\n}\r\nstatic void\r\ncsio_scsis_uninit(struct csio_ioreq *req, enum csio_scsi_ev evt)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nswitch (evt) {\r\ncase CSIO_SCSIE_START_IO:\r\nif (req->nsge) {\r\nif (req->datadir == DMA_TO_DEVICE) {\r\nreq->dcopy = 0;\r\ncsio_scsi_write(req);\r\n} else\r\ncsio_setup_ddp(scsim, req);\r\n} else {\r\ncsio_scsi_cmd(req);\r\n}\r\nif (likely(req->drv_status == 0)) {\r\ncsio_set_state(&req->sm, csio_scsis_io_active);\r\nlist_add_tail(&req->sm.sm_list, &scsim->active_q);\r\ncsio_wr_issue(hw, req->eq_idx, false);\r\nCSIO_INC_STATS(scsim, n_active);\r\nreturn;\r\n}\r\nbreak;\r\ncase CSIO_SCSIE_START_TM:\r\ncsio_scsi_cmd(req);\r\nif (req->drv_status == 0) {\r\ncsio_set_state(&req->sm, csio_scsis_tm_active);\r\nlist_add_tail(&req->sm.sm_list, &scsim->active_q);\r\ncsio_wr_issue(hw, req->eq_idx, false);\r\nCSIO_INC_STATS(scsim, n_tm_active);\r\n}\r\nreturn;\r\ncase CSIO_SCSIE_ABORT:\r\ncase CSIO_SCSIE_CLOSE:\r\nreq->drv_status = -EINVAL;\r\ncsio_warn(hw, "Trying to abort/close completed IO:%p!\n", req);\r\nbreak;\r\ndefault:\r\ncsio_dbg(hw, "Unhandled event:%d sent to req:%p\n", evt, req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\n}\r\nstatic void\r\ncsio_scsis_io_active(struct csio_ioreq *req, enum csio_scsi_ev evt)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scm = csio_hw_to_scsim(hw);\r\nstruct csio_rnode *rn;\r\nswitch (evt) {\r\ncase CSIO_SCSIE_COMPLETED:\r\nCSIO_DEC_STATS(scm, n_active);\r\nlist_del_init(&req->sm.sm_list);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nif (unlikely(req->wr_status != FW_SUCCESS)) {\r\nrn = req->rnode;\r\nif (csio_scsi_itnexus_loss_error(req->wr_status) &&\r\ncsio_is_rnode_ready(rn)) {\r\ncsio_set_state(&req->sm,\r\ncsio_scsis_shost_cmpl_await);\r\nlist_add_tail(&req->sm.sm_list,\r\n&rn->host_cmpl_q);\r\n}\r\n}\r\nbreak;\r\ncase CSIO_SCSIE_ABORT:\r\ncsio_scsi_abrt_cls(req, SCSI_ABORT);\r\nif (req->drv_status == 0) {\r\ncsio_wr_issue(hw, req->eq_idx, false);\r\ncsio_set_state(&req->sm, csio_scsis_aborting);\r\n}\r\nbreak;\r\ncase CSIO_SCSIE_CLOSE:\r\ncsio_scsi_abrt_cls(req, SCSI_CLOSE);\r\nif (req->drv_status == 0) {\r\ncsio_wr_issue(hw, req->eq_idx, false);\r\ncsio_set_state(&req->sm, csio_scsis_closing);\r\n}\r\nbreak;\r\ncase CSIO_SCSIE_DRVCLEANUP:\r\nreq->wr_status = FW_HOSTERROR;\r\nCSIO_DEC_STATS(scm, n_active);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ndefault:\r\ncsio_dbg(hw, "Unhandled event:%d sent to req:%p\n", evt, req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\n}\r\nstatic void\r\ncsio_scsis_tm_active(struct csio_ioreq *req, enum csio_scsi_ev evt)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scm = csio_hw_to_scsim(hw);\r\nswitch (evt) {\r\ncase CSIO_SCSIE_COMPLETED:\r\nCSIO_DEC_STATS(scm, n_tm_active);\r\nlist_del_init(&req->sm.sm_list);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ncase CSIO_SCSIE_ABORT:\r\ncsio_scsi_abrt_cls(req, SCSI_ABORT);\r\nif (req->drv_status == 0) {\r\ncsio_wr_issue(hw, req->eq_idx, false);\r\ncsio_set_state(&req->sm, csio_scsis_aborting);\r\n}\r\nbreak;\r\ncase CSIO_SCSIE_CLOSE:\r\ncsio_scsi_abrt_cls(req, SCSI_CLOSE);\r\nif (req->drv_status == 0) {\r\ncsio_wr_issue(hw, req->eq_idx, false);\r\ncsio_set_state(&req->sm, csio_scsis_closing);\r\n}\r\nbreak;\r\ncase CSIO_SCSIE_DRVCLEANUP:\r\nreq->wr_status = FW_HOSTERROR;\r\nCSIO_DEC_STATS(scm, n_tm_active);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ndefault:\r\ncsio_dbg(hw, "Unhandled event:%d sent to req:%p\n", evt, req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\n}\r\nstatic void\r\ncsio_scsis_aborting(struct csio_ioreq *req, enum csio_scsi_ev evt)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scm = csio_hw_to_scsim(hw);\r\nswitch (evt) {\r\ncase CSIO_SCSIE_COMPLETED:\r\ncsio_dbg(hw,\r\n"ioreq %p recvd cmpltd (wr_status:%d) "\r\n"in aborting st\n", req, req->wr_status);\r\nreq->drv_status = -ECANCELED;\r\nbreak;\r\ncase CSIO_SCSIE_ABORT:\r\nCSIO_INC_STATS(scm, n_abrt_dups);\r\nbreak;\r\ncase CSIO_SCSIE_ABORTED:\r\ncsio_dbg(hw, "abort of %p return status:0x%x drv_status:%x\n",\r\nreq, req->wr_status, req->drv_status);\r\nif (req->drv_status != -ECANCELED) {\r\ncsio_warn(hw,\r\n"Abort completed before original I/O,"\r\n" req:%p\n", req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\nif ((req->wr_status == FW_SUCCESS) ||\r\n(req->wr_status == FW_EINVAL) ||\r\ncsio_scsi_itnexus_loss_error(req->wr_status))\r\nreq->wr_status = FW_SCSI_ABORT_REQUESTED;\r\nCSIO_DEC_STATS(scm, n_active);\r\nlist_del_init(&req->sm.sm_list);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ncase CSIO_SCSIE_DRVCLEANUP:\r\nreq->wr_status = FW_HOSTERROR;\r\nCSIO_DEC_STATS(scm, n_active);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ncase CSIO_SCSIE_CLOSE:\r\nbreak;\r\ndefault:\r\ncsio_dbg(hw, "Unhandled event:%d sent to req:%p\n", evt, req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\n}\r\nstatic void\r\ncsio_scsis_closing(struct csio_ioreq *req, enum csio_scsi_ev evt)\r\n{\r\nstruct csio_hw *hw = req->lnode->hwp;\r\nstruct csio_scsim *scm = csio_hw_to_scsim(hw);\r\nswitch (evt) {\r\ncase CSIO_SCSIE_COMPLETED:\r\ncsio_dbg(hw,\r\n"ioreq %p recvd cmpltd (wr_status:%d) "\r\n"in closing st\n", req, req->wr_status);\r\nreq->drv_status = -ECANCELED;\r\nbreak;\r\ncase CSIO_SCSIE_CLOSED:\r\nif (req->drv_status != -ECANCELED) {\r\ncsio_fatal(hw,\r\n"Close completed before original I/O,"\r\n" req:%p\n", req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\nCSIO_DB_ASSERT((req->wr_status == FW_SUCCESS) ||\r\n(req->wr_status == FW_EINVAL));\r\nreq->wr_status = FW_SCSI_CLOSE_REQUESTED;\r\nCSIO_DEC_STATS(scm, n_active);\r\nlist_del_init(&req->sm.sm_list);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ncase CSIO_SCSIE_CLOSE:\r\nbreak;\r\ncase CSIO_SCSIE_DRVCLEANUP:\r\nreq->wr_status = FW_HOSTERROR;\r\nCSIO_DEC_STATS(scm, n_active);\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ndefault:\r\ncsio_dbg(hw, "Unhandled event:%d sent to req:%p\n", evt, req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\n}\r\nstatic void\r\ncsio_scsis_shost_cmpl_await(struct csio_ioreq *req, enum csio_scsi_ev evt)\r\n{\r\nswitch (evt) {\r\ncase CSIO_SCSIE_ABORT:\r\ncase CSIO_SCSIE_CLOSE:\r\nreq->drv_status = 0;\r\nbreak;\r\ncase CSIO_SCSIE_DRVCLEANUP:\r\ncsio_set_state(&req->sm, csio_scsis_uninit);\r\nbreak;\r\ndefault:\r\ncsio_dbg(req->lnode->hwp, "Unhandled event:%d sent to req:%p\n",\r\nevt, req);\r\nCSIO_DB_ASSERT(0);\r\n}\r\n}\r\nstruct csio_ioreq *\r\ncsio_scsi_cmpl_handler(struct csio_hw *hw, void *wr, uint32_t len,\r\nstruct csio_fl_dma_buf *flb, void *priv, uint8_t **scsiwr)\r\n{\r\nstruct csio_ioreq *ioreq = NULL;\r\nstruct cpl_fw6_msg *cpl;\r\nuint8_t *tempwr;\r\nuint8_t status;\r\nstruct csio_scsim *scm = csio_hw_to_scsim(hw);\r\ncpl = (struct cpl_fw6_msg *)((uintptr_t)wr + sizeof(__be64));\r\nif (unlikely(cpl->opcode != CPL_FW6_MSG)) {\r\ncsio_warn(hw, "Error: Invalid CPL msg %x recvd on SCSI q\n",\r\ncpl->opcode);\r\nCSIO_INC_STATS(scm, n_inval_cplop);\r\nreturn NULL;\r\n}\r\ntempwr = (uint8_t *)(cpl->data);\r\nstatus = csio_wr_status(tempwr);\r\n*scsiwr = tempwr;\r\nif (likely((*tempwr == FW_SCSI_READ_WR) ||\r\n(*tempwr == FW_SCSI_WRITE_WR) ||\r\n(*tempwr == FW_SCSI_CMD_WR))) {\r\nioreq = (struct csio_ioreq *)((uintptr_t)\r\n(((struct fw_scsi_read_wr *)tempwr)->cookie));\r\nCSIO_DB_ASSERT(virt_addr_valid(ioreq));\r\nioreq->wr_status = status;\r\nreturn ioreq;\r\n}\r\nif (*tempwr == FW_SCSI_ABRT_CLS_WR) {\r\nioreq = (struct csio_ioreq *)((uintptr_t)\r\n(((struct fw_scsi_abrt_cls_wr *)tempwr)->cookie));\r\nCSIO_DB_ASSERT(virt_addr_valid(ioreq));\r\nioreq->wr_status = status;\r\nreturn ioreq;\r\n}\r\ncsio_warn(hw, "WR with invalid opcode in SCSI IQ: %x\n", *tempwr);\r\nCSIO_INC_STATS(scm, n_inval_scsiop);\r\nreturn NULL;\r\n}\r\nvoid\r\ncsio_scsi_cleanup_io_q(struct csio_scsim *scm, struct list_head *q)\r\n{\r\nstruct csio_hw *hw = scm->hw;\r\nstruct csio_ioreq *ioreq;\r\nstruct list_head *tmp, *next;\r\nstruct scsi_cmnd *scmnd;\r\nlist_for_each_safe(tmp, next, q) {\r\nioreq = (struct csio_ioreq *)tmp;\r\ncsio_scsi_drvcleanup(ioreq);\r\nlist_del_init(&ioreq->sm.sm_list);\r\nscmnd = csio_scsi_cmnd(ioreq);\r\nspin_unlock_irq(&hw->lock);\r\nif (scmnd != NULL)\r\nioreq->io_cbfn(hw, ioreq);\r\nspin_lock_irq(&scm->freelist_lock);\r\ncsio_put_scsi_ioreq(scm, ioreq);\r\nspin_unlock_irq(&scm->freelist_lock);\r\nspin_lock_irq(&hw->lock);\r\n}\r\n}\r\nstatic void\r\ncsio_abrt_cls(struct csio_ioreq *ioreq, struct scsi_cmnd *scmnd)\r\n{\r\nstruct csio_lnode *ln = ioreq->lnode;\r\nstruct csio_hw *hw = ln->hwp;\r\nint ready = 0;\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nint rv;\r\nif (csio_scsi_cmnd(ioreq) != scmnd) {\r\nCSIO_INC_STATS(scsim, n_abrt_race_comp);\r\nreturn;\r\n}\r\nready = csio_is_lnode_ready(ln);\r\nrv = csio_do_abrt_cls(hw, ioreq, (ready ? SCSI_ABORT : SCSI_CLOSE));\r\nif (rv != 0) {\r\nif (ready)\r\nCSIO_INC_STATS(scsim, n_abrt_busy_error);\r\nelse\r\nCSIO_INC_STATS(scsim, n_cls_busy_error);\r\n}\r\n}\r\nstatic int\r\ncsio_scsi_abort_io_q(struct csio_scsim *scm, struct list_head *q, uint32_t tmo)\r\n{\r\nstruct csio_hw *hw = scm->hw;\r\nstruct list_head *tmp, *next;\r\nint count = DIV_ROUND_UP(tmo, CSIO_SCSI_ABORT_Q_POLL_MS);\r\nstruct scsi_cmnd *scmnd;\r\nif (list_empty(q))\r\nreturn 0;\r\ncsio_dbg(hw, "Aborting SCSI I/Os\n");\r\nlist_for_each_safe(tmp, next, q) {\r\nscmnd = csio_scsi_cmnd((struct csio_ioreq *)tmp);\r\ncsio_abrt_cls((struct csio_ioreq *)tmp, scmnd);\r\n}\r\nwhile (!list_empty(q) && count--) {\r\nspin_unlock_irq(&hw->lock);\r\nmsleep(CSIO_SCSI_ABORT_Q_POLL_MS);\r\nspin_lock_irq(&hw->lock);\r\n}\r\nif (list_empty(q))\r\nreturn 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nint\r\ncsio_scsim_cleanup_io(struct csio_scsim *scm, bool abort)\r\n{\r\nstruct csio_hw *hw = scm->hw;\r\nint rv = 0;\r\nint count = DIV_ROUND_UP(60 * 1000, CSIO_SCSI_ABORT_Q_POLL_MS);\r\nif (list_empty(&scm->active_q))\r\nreturn 0;\r\nwhile (!list_empty(&scm->active_q) && count--) {\r\nspin_unlock_irq(&hw->lock);\r\nmsleep(CSIO_SCSI_ABORT_Q_POLL_MS);\r\nspin_lock_irq(&hw->lock);\r\n}\r\nif (list_empty(&scm->active_q))\r\nreturn 0;\r\nif (abort) {\r\nrv = csio_scsi_abort_io_q(scm, &scm->active_q, 30000);\r\nif (rv == 0)\r\nreturn rv;\r\ncsio_dbg(hw, "Some I/O aborts timed out, cleaning up..\n");\r\n}\r\ncsio_scsi_cleanup_io_q(scm, &scm->active_q);\r\nCSIO_DB_ASSERT(list_empty(&scm->active_q));\r\nreturn rv;\r\n}\r\nint\r\ncsio_scsim_cleanup_io_lnode(struct csio_scsim *scm, struct csio_lnode *ln)\r\n{\r\nstruct csio_hw *hw = scm->hw;\r\nstruct csio_scsi_level_data sld;\r\nint rv;\r\nint count = DIV_ROUND_UP(60 * 1000, CSIO_SCSI_ABORT_Q_POLL_MS);\r\ncsio_dbg(hw, "Gathering all SCSI I/Os on lnode %p\n", ln);\r\nsld.level = CSIO_LEV_LNODE;\r\nsld.lnode = ln;\r\nINIT_LIST_HEAD(&ln->cmpl_q);\r\ncsio_scsi_gather_active_ios(scm, &sld, &ln->cmpl_q);\r\nif (list_empty(&ln->cmpl_q))\r\nreturn 0;\r\nwhile (!list_empty(&ln->cmpl_q) && count--) {\r\nspin_unlock_irq(&hw->lock);\r\nmsleep(CSIO_SCSI_ABORT_Q_POLL_MS);\r\nspin_lock_irq(&hw->lock);\r\n}\r\nif (list_empty(&ln->cmpl_q))\r\nreturn 0;\r\ncsio_dbg(hw, "Some I/Os pending on ln:%p, aborting them..\n", ln);\r\nrv = csio_scsi_abort_io_q(scm, &ln->cmpl_q, 30000);\r\nif (rv != 0) {\r\ncsio_dbg(hw, "Some I/O aborts timed out, cleaning up..\n");\r\ncsio_scsi_cleanup_io_q(scm, &ln->cmpl_q);\r\n}\r\nCSIO_DB_ASSERT(list_empty(&ln->cmpl_q));\r\nreturn rv;\r\n}\r\nstatic ssize_t\r\ncsio_show_hw_state(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nif (csio_is_hw_ready(hw))\r\nreturn snprintf(buf, PAGE_SIZE, "ready\n");\r\nelse\r\nreturn snprintf(buf, PAGE_SIZE, "not ready\n");\r\n}\r\nstatic ssize_t\r\ncsio_device_reset(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nif (*buf != '1')\r\nreturn -EINVAL;\r\ncsio_lnodes_exit(hw, 1);\r\ncsio_lnodes_block_request(hw);\r\nspin_lock_irq(&hw->lock);\r\ncsio_hw_reset(hw);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnodes_unblock_request(hw);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ncsio_disable_port(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nbool disable;\r\nif (*buf == '1' || *buf == '0')\r\ndisable = (*buf == '1') ? true : false;\r\nelse\r\nreturn -EINVAL;\r\ncsio_lnodes_block_by_port(hw, ln->portid);\r\nspin_lock_irq(&hw->lock);\r\ncsio_disable_lnodes(hw, ln->portid, disable);\r\nspin_unlock_irq(&hw->lock);\r\ncsio_lnodes_unblock_by_port(hw, ln->portid);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ncsio_show_dbg_level(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%x\n", ln->params.log_level);\r\n}\r\nstatic ssize_t\r\ncsio_store_dbg_level(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nuint32_t dbg_level = 0;\r\nif (!isdigit(buf[0]))\r\nreturn -EINVAL;\r\nif (sscanf(buf, "%i", &dbg_level))\r\nreturn -EINVAL;\r\nln->params.log_level = dbg_level;\r\nhw->params.log_level = dbg_level;\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\ncsio_show_num_reg_rnodes(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct csio_lnode *ln = shost_priv(class_to_shost(dev));\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", ln->num_reg_rnodes);\r\n}\r\nstatic inline uint32_t\r\ncsio_scsi_copy_to_sgl(struct csio_hw *hw, struct csio_ioreq *req)\r\n{\r\nstruct scsi_cmnd *scmnd = (struct scsi_cmnd *)csio_scsi_cmnd(req);\r\nstruct scatterlist *sg;\r\nuint32_t bytes_left;\r\nuint32_t bytes_copy;\r\nuint32_t buf_off = 0;\r\nuint32_t start_off = 0;\r\nuint32_t sg_off = 0;\r\nvoid *sg_addr;\r\nvoid *buf_addr;\r\nstruct csio_dma_buf *dma_buf;\r\nbytes_left = scsi_bufflen(scmnd);\r\nsg = scsi_sglist(scmnd);\r\ndma_buf = (struct csio_dma_buf *)csio_list_next(&req->gen_list);\r\nwhile (bytes_left > 0 && sg && dma_buf) {\r\nif (buf_off >= dma_buf->len) {\r\nbuf_off = 0;\r\ndma_buf = (struct csio_dma_buf *)\r\ncsio_list_next(dma_buf);\r\ncontinue;\r\n}\r\nif (start_off >= sg->length) {\r\nstart_off -= sg->length;\r\nsg = sg_next(sg);\r\ncontinue;\r\n}\r\nbuf_addr = dma_buf->vaddr + buf_off;\r\nsg_off = sg->offset + start_off;\r\nbytes_copy = min((dma_buf->len - buf_off),\r\nsg->length - start_off);\r\nbytes_copy = min((uint32_t)(PAGE_SIZE - (sg_off & ~PAGE_MASK)),\r\nbytes_copy);\r\nsg_addr = kmap_atomic(sg_page(sg) + (sg_off >> PAGE_SHIFT));\r\nif (!sg_addr) {\r\ncsio_err(hw, "failed to kmap sg:%p of ioreq:%p\n",\r\nsg, req);\r\nbreak;\r\n}\r\ncsio_dbg(hw, "copy_to_sgl:sg_addr %p sg_off %d buf %p len %d\n",\r\nsg_addr, sg_off, buf_addr, bytes_copy);\r\nmemcpy(sg_addr + (sg_off & ~PAGE_MASK), buf_addr, bytes_copy);\r\nkunmap_atomic(sg_addr);\r\nstart_off += bytes_copy;\r\nbuf_off += bytes_copy;\r\nbytes_left -= bytes_copy;\r\n}\r\nif (bytes_left > 0)\r\nreturn DID_ERROR;\r\nelse\r\nreturn DID_OK;\r\n}\r\nstatic inline void\r\ncsio_scsi_err_handler(struct csio_hw *hw, struct csio_ioreq *req)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)csio_scsi_cmnd(req);\r\nstruct csio_scsim *scm = csio_hw_to_scsim(hw);\r\nstruct fcp_resp_with_ext *fcp_resp;\r\nstruct fcp_resp_rsp_info *rsp_info;\r\nstruct csio_dma_buf *dma_buf;\r\nuint8_t flags, scsi_status = 0;\r\nuint32_t host_status = DID_OK;\r\nuint32_t rsp_len = 0, sns_len = 0;\r\nstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\r\nswitch (req->wr_status) {\r\ncase FW_HOSTERROR:\r\nif (unlikely(!csio_is_hw_ready(hw)))\r\nreturn;\r\nhost_status = DID_ERROR;\r\nCSIO_INC_STATS(scm, n_hosterror);\r\nbreak;\r\ncase FW_SCSI_RSP_ERR:\r\ndma_buf = &req->dma_buf;\r\nfcp_resp = (struct fcp_resp_with_ext *)dma_buf->vaddr;\r\nrsp_info = (struct fcp_resp_rsp_info *)(fcp_resp + 1);\r\nflags = fcp_resp->resp.fr_flags;\r\nscsi_status = fcp_resp->resp.fr_status;\r\nif (flags & FCP_RSP_LEN_VAL) {\r\nrsp_len = be32_to_cpu(fcp_resp->ext.fr_rsp_len);\r\nif ((rsp_len != 0 && rsp_len != 4 && rsp_len != 8) ||\r\n(rsp_info->rsp_code != FCP_TMF_CMPL)) {\r\nhost_status = DID_ERROR;\r\ngoto out;\r\n}\r\n}\r\nif ((flags & FCP_SNS_LEN_VAL) && fcp_resp->ext.fr_sns_len) {\r\nsns_len = be32_to_cpu(fcp_resp->ext.fr_sns_len);\r\nif (sns_len > SCSI_SENSE_BUFFERSIZE)\r\nsns_len = SCSI_SENSE_BUFFERSIZE;\r\nmemcpy(cmnd->sense_buffer,\r\n&rsp_info->_fr_resvd[0] + rsp_len, sns_len);\r\nCSIO_INC_STATS(scm, n_autosense);\r\n}\r\nscsi_set_resid(cmnd, 0);\r\nif (flags & FCP_RESID_UNDER) {\r\nscsi_set_resid(cmnd,\r\nbe32_to_cpu(fcp_resp->ext.fr_resid));\r\nif (!(flags & FCP_SNS_LEN_VAL) &&\r\n(scsi_status == SAM_STAT_GOOD) &&\r\n((scsi_bufflen(cmnd) - scsi_get_resid(cmnd))\r\n< cmnd->underflow))\r\nhost_status = DID_ERROR;\r\n} else if (flags & FCP_RESID_OVER)\r\nhost_status = DID_ERROR;\r\nCSIO_INC_STATS(scm, n_rsperror);\r\nbreak;\r\ncase FW_SCSI_OVER_FLOW_ERR:\r\ncsio_warn(hw,\r\n"Over-flow error,cmnd:0x%x expected len:0x%x"\r\n" resid:0x%x\n", cmnd->cmnd[0],\r\nscsi_bufflen(cmnd), scsi_get_resid(cmnd));\r\nhost_status = DID_ERROR;\r\nCSIO_INC_STATS(scm, n_ovflerror);\r\nbreak;\r\ncase FW_SCSI_UNDER_FLOW_ERR:\r\ncsio_warn(hw,\r\n"Under-flow error,cmnd:0x%x expected"\r\n" len:0x%x resid:0x%x lun:0x%llx ssn:0x%x\n",\r\ncmnd->cmnd[0], scsi_bufflen(cmnd),\r\nscsi_get_resid(cmnd), cmnd->device->lun,\r\nrn->flowid);\r\nhost_status = DID_ERROR;\r\nCSIO_INC_STATS(scm, n_unflerror);\r\nbreak;\r\ncase FW_SCSI_ABORT_REQUESTED:\r\ncase FW_SCSI_ABORTED:\r\ncase FW_SCSI_CLOSE_REQUESTED:\r\ncsio_dbg(hw, "Req %p cmd:%p op:%x %s\n", req, cmnd,\r\ncmnd->cmnd[0],\r\n(req->wr_status == FW_SCSI_CLOSE_REQUESTED) ?\r\n"closed" : "aborted");\r\nhost_status = DID_REQUEUE;\r\nif (req->wr_status == FW_SCSI_CLOSE_REQUESTED)\r\nCSIO_INC_STATS(scm, n_closed);\r\nelse\r\nCSIO_INC_STATS(scm, n_aborted);\r\nbreak;\r\ncase FW_SCSI_ABORT_TIMEDOUT:\r\ncsio_dbg(hw, "FW timed out abort req:%p cmnd:%p status:%x\n",\r\nreq, cmnd, req->wr_status);\r\nhost_status = DID_ERROR;\r\nCSIO_INC_STATS(scm, n_abrt_timedout);\r\nbreak;\r\ncase FW_RDEV_NOT_READY:\r\nCSIO_INC_STATS(scm, n_rdev_nr_error);\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase FW_ERR_RDEV_LOST:\r\nCSIO_INC_STATS(scm, n_rdev_lost_error);\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase FW_ERR_RDEV_LOGO:\r\nCSIO_INC_STATS(scm, n_rdev_logo_error);\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase FW_ERR_RDEV_IMPL_LOGO:\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase FW_ERR_LINK_DOWN:\r\nCSIO_INC_STATS(scm, n_link_down_error);\r\nhost_status = DID_ERROR;\r\nbreak;\r\ncase FW_FCOE_NO_XCHG:\r\nCSIO_INC_STATS(scm, n_no_xchg_error);\r\nhost_status = DID_ERROR;\r\nbreak;\r\ndefault:\r\ncsio_err(hw, "Unknown SCSI FW WR status:%d req:%p cmnd:%p\n",\r\nreq->wr_status, req, cmnd);\r\nCSIO_DB_ASSERT(0);\r\nCSIO_INC_STATS(scm, n_unknown_error);\r\nhost_status = DID_ERROR;\r\nbreak;\r\n}\r\nout:\r\nif (req->nsge > 0)\r\nscsi_dma_unmap(cmnd);\r\ncmnd->result = (((host_status) << 16) | scsi_status);\r\ncmnd->scsi_done(cmnd);\r\ncsio_scsi_cmnd(req) = NULL;\r\ncomplete(&req->cmplobj);\r\n}\r\nstatic void\r\ncsio_scsi_cbfn(struct csio_hw *hw, struct csio_ioreq *req)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)csio_scsi_cmnd(req);\r\nuint8_t scsi_status = SAM_STAT_GOOD;\r\nuint32_t host_status = DID_OK;\r\nif (likely(req->wr_status == FW_SUCCESS)) {\r\nif (req->nsge > 0) {\r\nscsi_dma_unmap(cmnd);\r\nif (req->dcopy)\r\nhost_status = csio_scsi_copy_to_sgl(hw, req);\r\n}\r\ncmnd->result = (((host_status) << 16) | scsi_status);\r\ncmnd->scsi_done(cmnd);\r\ncsio_scsi_cmnd(req) = NULL;\r\nCSIO_INC_STATS(csio_hw_to_scsim(hw), n_tot_success);\r\n} else {\r\ncsio_scsi_err_handler(hw, req);\r\n}\r\n}\r\nstatic int\r\ncsio_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *cmnd)\r\n{\r\nstruct csio_lnode *ln = shost_priv(host);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\r\nstruct csio_ioreq *ioreq = NULL;\r\nunsigned long flags;\r\nint nsge = 0;\r\nint rv = SCSI_MLQUEUE_HOST_BUSY, nr;\r\nint retval;\r\nint cpu;\r\nstruct csio_scsi_qset *sqset;\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(cmnd->device));\r\nif (!blk_rq_cpu_valid(cmnd->request))\r\ncpu = smp_processor_id();\r\nelse\r\ncpu = cmnd->request->cpu;\r\nsqset = &hw->sqset[ln->portid][cpu];\r\nnr = fc_remote_port_chkready(rport);\r\nif (nr) {\r\ncmnd->result = nr;\r\nCSIO_INC_STATS(scsim, n_rn_nr_error);\r\ngoto err_done;\r\n}\r\nif (unlikely(!csio_is_hw_ready(hw))) {\r\ncmnd->result = (DID_REQUEUE << 16);\r\nCSIO_INC_STATS(scsim, n_hw_nr_error);\r\ngoto err_done;\r\n}\r\nnsge = scsi_dma_map(cmnd);\r\nif (unlikely(nsge < 0)) {\r\nCSIO_INC_STATS(scsim, n_dmamap_error);\r\ngoto err;\r\n}\r\nif (unlikely(nsge > scsim->max_sge)) {\r\ncsio_warn(hw,\r\n"More SGEs than can be supported."\r\n" SGEs: %d, Max SGEs: %d\n", nsge, scsim->max_sge);\r\nCSIO_INC_STATS(scsim, n_unsupp_sge_error);\r\ngoto err_dma_unmap;\r\n}\r\nioreq = csio_get_scsi_ioreq_lock(hw, scsim);\r\nif (!ioreq) {\r\ncsio_err(hw, "Out of I/O request elements. Active #:%d\n",\r\nscsim->stats.n_active);\r\nCSIO_INC_STATS(scsim, n_no_req_error);\r\ngoto err_dma_unmap;\r\n}\r\nioreq->nsge = nsge;\r\nioreq->lnode = ln;\r\nioreq->rnode = rn;\r\nioreq->iq_idx = sqset->iq_idx;\r\nioreq->eq_idx = sqset->eq_idx;\r\nioreq->wr_status = 0;\r\nioreq->drv_status = 0;\r\ncsio_scsi_cmnd(ioreq) = (void *)cmnd;\r\nioreq->tmo = 0;\r\nioreq->datadir = cmnd->sc_data_direction;\r\nif (cmnd->sc_data_direction == DMA_TO_DEVICE) {\r\nCSIO_INC_STATS(ln, n_output_requests);\r\nln->stats.n_output_bytes += scsi_bufflen(cmnd);\r\n} else if (cmnd->sc_data_direction == DMA_FROM_DEVICE) {\r\nCSIO_INC_STATS(ln, n_input_requests);\r\nln->stats.n_input_bytes += scsi_bufflen(cmnd);\r\n} else\r\nCSIO_INC_STATS(ln, n_control_requests);\r\nioreq->io_cbfn = csio_scsi_cbfn;\r\ncmnd->host_scribble = (unsigned char *)ioreq;\r\ncmnd->SCp.Message = 0;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nretval = csio_scsi_start_io(ioreq);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nif (retval != 0) {\r\ncsio_err(hw, "ioreq: %p couldnt be started, status:%d\n",\r\nioreq, retval);\r\nCSIO_INC_STATS(scsim, n_busy_error);\r\ngoto err_put_req;\r\n}\r\nreturn 0;\r\nerr_put_req:\r\ncsio_put_scsi_ioreq_lock(hw, scsim, ioreq);\r\nerr_dma_unmap:\r\nif (nsge > 0)\r\nscsi_dma_unmap(cmnd);\r\nerr:\r\nreturn rv;\r\nerr_done:\r\ncmnd->scsi_done(cmnd);\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_do_abrt_cls(struct csio_hw *hw, struct csio_ioreq *ioreq, bool abort)\r\n{\r\nint rv;\r\nint cpu = smp_processor_id();\r\nstruct csio_lnode *ln = ioreq->lnode;\r\nstruct csio_scsi_qset *sqset = &hw->sqset[ln->portid][cpu];\r\nioreq->tmo = CSIO_SCSI_ABRT_TMO_MS;\r\nioreq->eq_idx = sqset->eq_idx;\r\nif (abort == SCSI_ABORT)\r\nrv = csio_scsi_abort(ioreq);\r\nelse\r\nrv = csio_scsi_close(ioreq);\r\nreturn rv;\r\n}\r\nstatic int\r\ncsio_eh_abort_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct csio_ioreq *ioreq;\r\nstruct csio_lnode *ln = shost_priv(cmnd->device->host);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nint ready = 0, ret;\r\nunsigned long tmo = 0;\r\nint rv;\r\nstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\r\nret = fc_block_scsi_eh(cmnd);\r\nif (ret)\r\nreturn ret;\r\nioreq = (struct csio_ioreq *)cmnd->host_scribble;\r\nif (!ioreq)\r\nreturn SUCCESS;\r\nif (!rn)\r\nreturn FAILED;\r\ncsio_dbg(hw,\r\n"Request to abort ioreq:%p cmd:%p cdb:%08llx"\r\n" ssni:0x%x lun:%llu iq:0x%x\n",\r\nioreq, cmnd, *((uint64_t *)cmnd->cmnd), rn->flowid,\r\ncmnd->device->lun, csio_q_physiqid(hw, ioreq->iq_idx));\r\nif (((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) != cmnd) {\r\nCSIO_INC_STATS(scsim, n_abrt_race_comp);\r\nreturn SUCCESS;\r\n}\r\nready = csio_is_lnode_ready(ln);\r\ntmo = CSIO_SCSI_ABRT_TMO_MS;\r\nreinit_completion(&ioreq->cmplobj);\r\nspin_lock_irq(&hw->lock);\r\nrv = csio_do_abrt_cls(hw, ioreq, (ready ? SCSI_ABORT : SCSI_CLOSE));\r\nspin_unlock_irq(&hw->lock);\r\nif (rv != 0) {\r\nif (rv == -EINVAL) {\r\nreturn SUCCESS;\r\n}\r\nif (ready)\r\nCSIO_INC_STATS(scsim, n_abrt_busy_error);\r\nelse\r\nCSIO_INC_STATS(scsim, n_cls_busy_error);\r\ngoto inval_scmnd;\r\n}\r\nwait_for_completion_timeout(&ioreq->cmplobj, msecs_to_jiffies(tmo));\r\nif (((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) == cmnd) {\r\ncsio_err(hw, "Abort timed out -- req: %p\n", ioreq);\r\nCSIO_INC_STATS(scsim, n_abrt_timedout);\r\ninval_scmnd:\r\nif (ioreq->nsge > 0)\r\nscsi_dma_unmap(cmnd);\r\nspin_lock_irq(&hw->lock);\r\ncsio_scsi_cmnd(ioreq) = NULL;\r\nspin_unlock_irq(&hw->lock);\r\ncmnd->result = (DID_ERROR << 16);\r\ncmnd->scsi_done(cmnd);\r\nreturn FAILED;\r\n}\r\nif (host_byte(cmnd->result) == DID_REQUEUE) {\r\ncsio_info(hw,\r\n"Aborted SCSI command to (%d:%llu) serial#:0x%lx\n",\r\ncmnd->device->id, cmnd->device->lun,\r\ncmnd->serial_number);\r\nreturn SUCCESS;\r\n} else {\r\ncsio_info(hw,\r\n"Failed to abort SCSI command, (%d:%llu) serial#:0x%lx\n",\r\ncmnd->device->id, cmnd->device->lun,\r\ncmnd->serial_number);\r\nreturn FAILED;\r\n}\r\n}\r\nstatic void\r\ncsio_tm_cbfn(struct csio_hw *hw, struct csio_ioreq *req)\r\n{\r\nstruct scsi_cmnd *cmnd = (struct scsi_cmnd *)csio_scsi_cmnd(req);\r\nstruct csio_dma_buf *dma_buf;\r\nuint8_t flags = 0;\r\nstruct fcp_resp_with_ext *fcp_resp;\r\nstruct fcp_resp_rsp_info *rsp_info;\r\ncsio_dbg(hw, "req: %p in csio_tm_cbfn status: %d\n",\r\nreq, req->wr_status);\r\ncmnd->SCp.Status = req->wr_status;\r\nif (req->wr_status == FW_SCSI_RSP_ERR) {\r\ndma_buf = &req->dma_buf;\r\nfcp_resp = (struct fcp_resp_with_ext *)dma_buf->vaddr;\r\nrsp_info = (struct fcp_resp_rsp_info *)(fcp_resp + 1);\r\nflags = fcp_resp->resp.fr_flags;\r\nif (flags & FCP_RSP_LEN_VAL)\r\nif (rsp_info->rsp_code == FCP_TMF_CMPL)\r\ncmnd->SCp.Status = FW_SUCCESS;\r\ncsio_dbg(hw, "TM FCP rsp code: %d\n", rsp_info->rsp_code);\r\n}\r\ncsio_scsi_cmnd(req) = NULL;\r\n}\r\nstatic int\r\ncsio_eh_lun_reset_handler(struct scsi_cmnd *cmnd)\r\n{\r\nstruct csio_lnode *ln = shost_priv(cmnd->device->host);\r\nstruct csio_hw *hw = csio_lnode_to_hw(ln);\r\nstruct csio_scsim *scsim = csio_hw_to_scsim(hw);\r\nstruct csio_rnode *rn = (struct csio_rnode *)(cmnd->device->hostdata);\r\nstruct csio_ioreq *ioreq = NULL;\r\nstruct csio_scsi_qset *sqset;\r\nunsigned long flags;\r\nint retval;\r\nint count, ret;\r\nLIST_HEAD(local_q);\r\nstruct csio_scsi_level_data sld;\r\nif (!rn)\r\ngoto fail;\r\ncsio_dbg(hw, "Request to reset LUN:%llu (ssni:0x%x tgtid:%d)\n",\r\ncmnd->device->lun, rn->flowid, rn->scsi_id);\r\nif (!csio_is_lnode_ready(ln)) {\r\ncsio_err(hw,\r\n"LUN reset cannot be issued on non-ready"\r\n" local node vnpi:0x%x (LUN:%llu)\n",\r\nln->vnp_flowid, cmnd->device->lun);\r\ngoto fail;\r\n}\r\nret = fc_block_scsi_eh(cmnd);\r\nif (ret)\r\nreturn ret;\r\nif (fc_remote_port_chkready(rn->rport)) {\r\ncsio_err(hw,\r\n"LUN reset cannot be issued on non-ready"\r\n" remote node ssni:0x%x (LUN:%llu)\n",\r\nrn->flowid, cmnd->device->lun);\r\ngoto fail;\r\n}\r\nioreq = csio_get_scsi_ioreq_lock(hw, scsim);\r\nif (!ioreq) {\r\ncsio_err(hw, "Out of IO request elements. Active # :%d\n",\r\nscsim->stats.n_active);\r\ngoto fail;\r\n}\r\nsqset = &hw->sqset[ln->portid][smp_processor_id()];\r\nioreq->nsge = 0;\r\nioreq->lnode = ln;\r\nioreq->rnode = rn;\r\nioreq->iq_idx = sqset->iq_idx;\r\nioreq->eq_idx = sqset->eq_idx;\r\ncsio_scsi_cmnd(ioreq) = cmnd;\r\ncmnd->host_scribble = (unsigned char *)ioreq;\r\ncmnd->SCp.Status = 0;\r\ncmnd->SCp.Message = FCP_TMF_LUN_RESET;\r\nioreq->tmo = CSIO_SCSI_LUNRST_TMO_MS / 1000;\r\ncount = DIV_ROUND_UP((ioreq->tmo + 10) * 1000, CSIO_SCSI_TM_POLL_MS);\r\nioreq->io_cbfn = csio_tm_cbfn;\r\nsld.level = CSIO_LEV_LUN;\r\nsld.lnode = ioreq->lnode;\r\nsld.rnode = ioreq->rnode;\r\nsld.oslun = cmnd->device->lun;\r\nspin_lock_irqsave(&hw->lock, flags);\r\nretval = csio_scsi_start_tm(ioreq);\r\nspin_unlock_irqrestore(&hw->lock, flags);\r\nif (retval != 0) {\r\ncsio_err(hw, "Failed to issue LUN reset, req:%p, status:%d\n",\r\nioreq, retval);\r\ngoto fail_ret_ioreq;\r\n}\r\ncsio_dbg(hw, "Waiting max %d secs for LUN reset completion\n",\r\ncount * (CSIO_SCSI_TM_POLL_MS / 1000));\r\nwhile ((((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) == cmnd)\r\n&& count--)\r\nmsleep(CSIO_SCSI_TM_POLL_MS);\r\nif (((struct scsi_cmnd *)csio_scsi_cmnd(ioreq)) == cmnd) {\r\ncsio_err(hw, "LUN reset (%d:%llu) timed out\n",\r\ncmnd->device->id, cmnd->device->lun);\r\nspin_lock_irq(&hw->lock);\r\ncsio_scsi_drvcleanup(ioreq);\r\nlist_del_init(&ioreq->sm.sm_list);\r\nspin_unlock_irq(&hw->lock);\r\ngoto fail_ret_ioreq;\r\n}\r\nif (cmnd->SCp.Status != FW_SUCCESS) {\r\ncsio_err(hw, "LUN reset failed (%d:%llu), status: %d\n",\r\ncmnd->device->id, cmnd->device->lun, cmnd->SCp.Status);\r\ngoto fail;\r\n}\r\nspin_lock_irq(&hw->lock);\r\ncsio_scsi_gather_active_ios(scsim, &sld, &local_q);\r\nretval = csio_scsi_abort_io_q(scsim, &local_q, 30000);\r\nspin_unlock_irq(&hw->lock);\r\nif (retval != 0) {\r\ncsio_err(hw,\r\n"Attempt to abort I/Os during LUN reset of %llu"\r\n" returned %d\n", cmnd->device->lun, retval);\r\nspin_lock_irq(&hw->lock);\r\nlist_splice_tail_init(&local_q, &scsim->active_q);\r\nspin_unlock_irq(&hw->lock);\r\ngoto fail;\r\n}\r\nCSIO_INC_STATS(rn, n_lun_rst);\r\ncsio_info(hw, "LUN reset occurred (%d:%llu)\n",\r\ncmnd->device->id, cmnd->device->lun);\r\nreturn SUCCESS;\r\nfail_ret_ioreq:\r\ncsio_put_scsi_ioreq_lock(hw, scsim, ioreq);\r\nfail:\r\nCSIO_INC_STATS(rn, n_lun_rst_fail);\r\nreturn FAILED;\r\n}\r\nstatic int\r\ncsio_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct fc_rport *rport = starget_to_rport(scsi_target(sdev));\r\nif (!rport || fc_remote_port_chkready(rport))\r\nreturn -ENXIO;\r\nsdev->hostdata = *((struct csio_lnode **)(rport->dd_data));\r\nreturn 0;\r\n}\r\nstatic int\r\ncsio_slave_configure(struct scsi_device *sdev)\r\n{\r\nscsi_change_queue_depth(sdev, csio_lun_qdepth);\r\nreturn 0;\r\n}\r\nstatic void\r\ncsio_slave_destroy(struct scsi_device *sdev)\r\n{\r\nsdev->hostdata = NULL;\r\n}\r\nstatic int\r\ncsio_scan_finished(struct Scsi_Host *shost, unsigned long time)\r\n{\r\nstruct csio_lnode *ln = shost_priv(shost);\r\nint rv = 1;\r\nspin_lock_irq(shost->host_lock);\r\nif (!ln->hwp || csio_list_deleted(&ln->sm.sm_list))\r\ngoto out;\r\nrv = csio_scan_done(ln, jiffies, time, csio_max_scan_tmo * HZ,\r\ncsio_delta_scan_tmo * HZ);\r\nout:\r\nspin_unlock_irq(shost->host_lock);\r\nreturn rv;\r\n}\r\nstatic int\r\ncsio_scsi_alloc_ddp_bufs(struct csio_scsim *scm, struct csio_hw *hw,\r\nint buf_size, int num_buf)\r\n{\r\nint n = 0;\r\nstruct list_head *tmp;\r\nstruct csio_dma_buf *ddp_desc = NULL;\r\nuint32_t unit_size = 0;\r\nif (!num_buf)\r\nreturn 0;\r\nif (!buf_size)\r\nreturn -EINVAL;\r\nINIT_LIST_HEAD(&scm->ddp_freelist);\r\nbuf_size = (buf_size + PAGE_SIZE - 1) & PAGE_MASK;\r\nfor (n = 0; n < num_buf; n++) {\r\nunit_size = buf_size;\r\nddp_desc = kzalloc(sizeof(struct csio_dma_buf), GFP_KERNEL);\r\nif (!ddp_desc) {\r\ncsio_err(hw,\r\n"Failed to allocate ddp descriptors,"\r\n" Num allocated = %d.\n",\r\nscm->stats.n_free_ddp);\r\ngoto no_mem;\r\n}\r\nddp_desc->vaddr = pci_alloc_consistent(hw->pdev, unit_size,\r\n&ddp_desc->paddr);\r\nif (!ddp_desc->vaddr) {\r\ncsio_err(hw,\r\n"SCSI response DMA buffer (ddp) allocation"\r\n" failed!\n");\r\nkfree(ddp_desc);\r\ngoto no_mem;\r\n}\r\nddp_desc->len = unit_size;\r\nlist_add_tail(&ddp_desc->list, &scm->ddp_freelist);\r\nCSIO_INC_STATS(scm, n_free_ddp);\r\n}\r\nreturn 0;\r\nno_mem:\r\nlist_for_each(tmp, &scm->ddp_freelist) {\r\nddp_desc = (struct csio_dma_buf *) tmp;\r\ntmp = csio_list_prev(tmp);\r\npci_free_consistent(hw->pdev, ddp_desc->len, ddp_desc->vaddr,\r\nddp_desc->paddr);\r\nlist_del_init(&ddp_desc->list);\r\nkfree(ddp_desc);\r\n}\r\nscm->stats.n_free_ddp = 0;\r\nreturn -ENOMEM;\r\n}\r\nstatic void\r\ncsio_scsi_free_ddp_bufs(struct csio_scsim *scm, struct csio_hw *hw)\r\n{\r\nstruct list_head *tmp;\r\nstruct csio_dma_buf *ddp_desc;\r\nlist_for_each(tmp, &scm->ddp_freelist) {\r\nddp_desc = (struct csio_dma_buf *) tmp;\r\ntmp = csio_list_prev(tmp);\r\npci_free_consistent(hw->pdev, ddp_desc->len, ddp_desc->vaddr,\r\nddp_desc->paddr);\r\nlist_del_init(&ddp_desc->list);\r\nkfree(ddp_desc);\r\n}\r\nscm->stats.n_free_ddp = 0;\r\n}\r\nint\r\ncsio_scsim_init(struct csio_scsim *scm, struct csio_hw *hw)\r\n{\r\nint i;\r\nstruct csio_ioreq *ioreq;\r\nstruct csio_dma_buf *dma_buf;\r\nINIT_LIST_HEAD(&scm->active_q);\r\nscm->hw = hw;\r\nscm->proto_cmd_len = sizeof(struct fcp_cmnd);\r\nscm->proto_rsp_len = CSIO_SCSI_RSP_LEN;\r\nscm->max_sge = CSIO_SCSI_MAX_SGE;\r\nspin_lock_init(&scm->freelist_lock);\r\nINIT_LIST_HEAD(&scm->ioreq_freelist);\r\nfor (i = 0; i < csio_scsi_ioreqs; i++) {\r\nioreq = kzalloc(sizeof(struct csio_ioreq), GFP_KERNEL);\r\nif (!ioreq) {\r\ncsio_err(hw,\r\n"I/O request element allocation failed, "\r\n" Num allocated = %d.\n",\r\nscm->stats.n_free_ioreq);\r\ngoto free_ioreq;\r\n}\r\ndma_buf = &ioreq->dma_buf;\r\ndma_buf->vaddr = pci_pool_alloc(hw->scsi_pci_pool, GFP_KERNEL,\r\n&dma_buf->paddr);\r\nif (!dma_buf->vaddr) {\r\ncsio_err(hw,\r\n"SCSI response DMA buffer allocation"\r\n" failed!\n");\r\nkfree(ioreq);\r\ngoto free_ioreq;\r\n}\r\ndma_buf->len = scm->proto_rsp_len;\r\ncsio_init_state(&ioreq->sm, csio_scsis_uninit);\r\nINIT_LIST_HEAD(&ioreq->gen_list);\r\ninit_completion(&ioreq->cmplobj);\r\nlist_add_tail(&ioreq->sm.sm_list, &scm->ioreq_freelist);\r\nCSIO_INC_STATS(scm, n_free_ioreq);\r\n}\r\nif (csio_scsi_alloc_ddp_bufs(scm, hw, PAGE_SIZE, csio_ddp_descs))\r\ngoto free_ioreq;\r\nreturn 0;\r\nfree_ioreq:\r\nwhile (!list_empty(&scm->ioreq_freelist)) {\r\nstruct csio_sm *tmp;\r\ntmp = list_first_entry(&scm->ioreq_freelist,\r\nstruct csio_sm, sm_list);\r\nlist_del_init(&tmp->sm_list);\r\nioreq = (struct csio_ioreq *)tmp;\r\ndma_buf = &ioreq->dma_buf;\r\npci_pool_free(hw->scsi_pci_pool, dma_buf->vaddr,\r\ndma_buf->paddr);\r\nkfree(ioreq);\r\n}\r\nscm->stats.n_free_ioreq = 0;\r\nreturn -ENOMEM;\r\n}\r\nvoid\r\ncsio_scsim_exit(struct csio_scsim *scm)\r\n{\r\nstruct csio_ioreq *ioreq;\r\nstruct csio_dma_buf *dma_buf;\r\nwhile (!list_empty(&scm->ioreq_freelist)) {\r\nstruct csio_sm *tmp;\r\ntmp = list_first_entry(&scm->ioreq_freelist,\r\nstruct csio_sm, sm_list);\r\nlist_del_init(&tmp->sm_list);\r\nioreq = (struct csio_ioreq *)tmp;\r\ndma_buf = &ioreq->dma_buf;\r\npci_pool_free(scm->hw->scsi_pci_pool, dma_buf->vaddr,\r\ndma_buf->paddr);\r\nkfree(ioreq);\r\n}\r\nscm->stats.n_free_ioreq = 0;\r\ncsio_scsi_free_ddp_bufs(scm, scm->hw);\r\n}
