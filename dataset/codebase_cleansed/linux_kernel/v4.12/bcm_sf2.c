static enum dsa_tag_protocol bcm_sf2_sw_get_tag_protocol(struct dsa_switch *ds)\r\n{\r\nreturn DSA_TAG_PROTO_BRCM;\r\n}\r\nstatic void bcm_sf2_imp_vlan_setup(struct dsa_switch *ds, int cpu_port)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nunsigned int i;\r\nu32 reg;\r\nfor (i = 0; i < priv->hw_params.num_ports; i++) {\r\nif (!((1 << i) & ds->enabled_port_mask))\r\ncontinue;\r\nreg = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(i));\r\nreg |= (1 << cpu_port);\r\ncore_writel(priv, reg, CORE_PORT_VLAN_CTL_PORT(i));\r\n}\r\n}\r\nstatic void bcm_sf2_brcm_hdr_setup(struct bcm_sf2_priv *priv, int port)\r\n{\r\nu32 reg, val;\r\nswitch (port) {\r\ncase 8:\r\nval = BRCM_HDR_EN_P8;\r\nbreak;\r\ncase 7:\r\nval = BRCM_HDR_EN_P7;\r\nbreak;\r\ncase 5:\r\nval = BRCM_HDR_EN_P5;\r\nbreak;\r\ndefault:\r\nval = 0;\r\nbreak;\r\n}\r\nreg = core_readl(priv, CORE_BRCM_HDR_CTRL);\r\nreg |= val;\r\ncore_writel(priv, reg, CORE_BRCM_HDR_CTRL);\r\nreg = core_readl(priv, CORE_BRCM_HDR_RX_DIS);\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_BRCM_HDR_RX_DIS);\r\nreg = core_readl(priv, CORE_BRCM_HDR_TX_DIS);\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_BRCM_HDR_TX_DIS);\r\n}\r\nstatic void bcm_sf2_imp_setup(struct dsa_switch *ds, int port)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nu32 reg, offset;\r\nif (priv->type == BCM7445_DEVICE_ID)\r\noffset = CORE_STS_OVERRIDE_IMP;\r\nelse\r\noffset = CORE_STS_OVERRIDE_IMP2;\r\nreg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\r\nreg &= ~P_TXQ_PSM_VDD(port);\r\ncore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\r\nreg = core_readl(priv, CORE_IMP_CTL);\r\nreg |= (RX_BCST_EN | RX_MCST_EN | RX_UCST_EN);\r\nreg &= ~(RX_DIS | TX_DIS);\r\ncore_writel(priv, reg, CORE_IMP_CTL);\r\ncore_writel(priv, SW_FWDG_EN, CORE_SWMODE);\r\nreg = core_readl(priv, CORE_SWITCH_CTRL);\r\nreg |= MII_DUMB_FWDG_EN;\r\ncore_writel(priv, reg, CORE_SWITCH_CTRL);\r\nbcm_sf2_brcm_hdr_setup(priv, port);\r\nreg = core_readl(priv, offset);\r\nreg |= (MII_SW_OR | LINK_STS);\r\ncore_writel(priv, reg, offset);\r\n}\r\nstatic void bcm_sf2_eee_enable_set(struct dsa_switch *ds, int port, bool enable)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nu32 reg;\r\nreg = core_readl(priv, CORE_EEE_EN_CTRL);\r\nif (enable)\r\nreg |= 1 << port;\r\nelse\r\nreg &= ~(1 << port);\r\ncore_writel(priv, reg, CORE_EEE_EN_CTRL);\r\n}\r\nstatic void bcm_sf2_gphy_enable_set(struct dsa_switch *ds, bool enable)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nu32 reg;\r\nreg = reg_readl(priv, REG_SPHY_CNTRL);\r\nif (enable) {\r\nreg |= PHY_RESET;\r\nreg &= ~(EXT_PWR_DOWN | IDDQ_BIAS | CK25_DIS);\r\nreg_writel(priv, reg, REG_SPHY_CNTRL);\r\nudelay(21);\r\nreg = reg_readl(priv, REG_SPHY_CNTRL);\r\nreg &= ~PHY_RESET;\r\n} else {\r\nreg |= EXT_PWR_DOWN | IDDQ_BIAS | PHY_RESET;\r\nreg_writel(priv, reg, REG_SPHY_CNTRL);\r\nmdelay(1);\r\nreg |= CK25_DIS;\r\n}\r\nreg_writel(priv, reg, REG_SPHY_CNTRL);\r\nif (!enable) {\r\nreg = reg_readl(priv, REG_LED_CNTRL(0));\r\nreg |= SPDLNK_SRC_SEL;\r\nreg_writel(priv, reg, REG_LED_CNTRL(0));\r\n}\r\n}\r\nstatic inline void bcm_sf2_port_intr_enable(struct bcm_sf2_priv *priv,\r\nint port)\r\n{\r\nunsigned int off;\r\nswitch (port) {\r\ncase 7:\r\noff = P7_IRQ_OFF;\r\nbreak;\r\ncase 0:\r\nintrl2_0_mask_clear(priv, P_IRQ_MASK(P0_IRQ_OFF));\r\nreturn;\r\ndefault:\r\noff = P_IRQ_OFF(port);\r\nbreak;\r\n}\r\nintrl2_1_mask_clear(priv, P_IRQ_MASK(off));\r\n}\r\nstatic inline void bcm_sf2_port_intr_disable(struct bcm_sf2_priv *priv,\r\nint port)\r\n{\r\nunsigned int off;\r\nswitch (port) {\r\ncase 7:\r\noff = P7_IRQ_OFF;\r\nbreak;\r\ncase 0:\r\nintrl2_0_mask_set(priv, P_IRQ_MASK(P0_IRQ_OFF));\r\nintrl2_0_writel(priv, P_IRQ_MASK(P0_IRQ_OFF), INTRL2_CPU_CLEAR);\r\nreturn;\r\ndefault:\r\noff = P_IRQ_OFF(port);\r\nbreak;\r\n}\r\nintrl2_1_mask_set(priv, P_IRQ_MASK(off));\r\nintrl2_1_writel(priv, P_IRQ_MASK(off), INTRL2_CPU_CLEAR);\r\n}\r\nstatic int bcm_sf2_port_setup(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\ns8 cpu_port = ds->dst[ds->index].cpu_port;\r\nunsigned int i;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\r\nreg &= ~P_TXQ_PSM_VDD(port);\r\ncore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\r\nif (priv->brcm_tag_mask & BIT(port))\r\nbcm_sf2_brcm_hdr_setup(priv, port);\r\nreg = core_readl(priv, CORE_PORT_TC2_QOS_MAP_PORT(port));\r\nfor (i = 0; i < 8; i++)\r\nreg |= i << (PRT_TO_QID_SHIFT * i);\r\ncore_writel(priv, reg, CORE_PORT_TC2_QOS_MAP_PORT(port));\r\ncore_writel(priv, 0, CORE_G_PCTL_PORT(port));\r\nif (priv->int_phy_mask & 1 << port && priv->hw_params.num_gphy == 1) {\r\nbcm_sf2_gphy_enable_set(ds, true);\r\nif (phy) {\r\nphy->state = PHY_READY;\r\nphy_init_hw(phy);\r\n}\r\n}\r\nif (port == priv->moca_port)\r\nbcm_sf2_port_intr_enable(priv, port);\r\nreg = core_readl(priv, CORE_PORT_VLAN_CTL_PORT(port));\r\nreg &= ~PORT_VLAN_CTRL_MASK;\r\nreg |= (1 << port);\r\nreg |= priv->dev->ports[port].vlan_ctl_mask;\r\ncore_writel(priv, reg, CORE_PORT_VLAN_CTL_PORT(port));\r\nbcm_sf2_imp_vlan_setup(ds, cpu_port);\r\nif (priv->port_sts[port].eee.eee_enabled)\r\nbcm_sf2_eee_enable_set(ds, port, true);\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_port_disable(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nu32 off, reg;\r\nif (priv->wol_ports_mask & (1 << port))\r\nreturn;\r\nif (port == priv->moca_port)\r\nbcm_sf2_port_intr_disable(priv, port);\r\nif (priv->int_phy_mask & 1 << port && priv->hw_params.num_gphy == 1)\r\nbcm_sf2_gphy_enable_set(ds, false);\r\nif (dsa_is_cpu_port(ds, port))\r\noff = CORE_IMP_CTL;\r\nelse\r\noff = CORE_G_PCTL_PORT(port);\r\nreg = core_readl(priv, off);\r\nreg |= RX_DIS | TX_DIS;\r\ncore_writel(priv, reg, off);\r\nreg = core_readl(priv, CORE_MEM_PSM_VDD_CTRL);\r\nreg |= P_TXQ_PSM_VDD(port);\r\ncore_writel(priv, reg, CORE_MEM_PSM_VDD_CTRL);\r\n}\r\nstatic int bcm_sf2_eee_init(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nint ret;\r\np->supported = (SUPPORTED_1000baseT_Full | SUPPORTED_100baseT_Full);\r\nret = phy_init_eee(phy, 0);\r\nif (ret)\r\nreturn 0;\r\nbcm_sf2_eee_enable_set(ds, port, true);\r\nreturn 1;\r\n}\r\nstatic int bcm_sf2_sw_get_eee(struct dsa_switch *ds, int port,\r\nstruct ethtool_eee *e)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_EEE_LPI_INDICATE);\r\ne->eee_enabled = p->eee_enabled;\r\ne->eee_active = !!(reg & (1 << port));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_set_eee(struct dsa_switch *ds, int port,\r\nstruct phy_device *phydev,\r\nstruct ethtool_eee *e)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\np->eee_enabled = e->eee_enabled;\r\nif (!p->eee_enabled) {\r\nbcm_sf2_eee_enable_set(ds, port, false);\r\n} else {\r\np->eee_enabled = bcm_sf2_eee_init(ds, port, phydev);\r\nif (!p->eee_enabled)\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_indir_rw(struct bcm_sf2_priv *priv, int op, int addr,\r\nint regnum, u16 val)\r\n{\r\nint ret = 0;\r\nu32 reg;\r\nreg = reg_readl(priv, REG_SWITCH_CNTRL);\r\nreg |= MDIO_MASTER_SEL;\r\nreg_writel(priv, reg, REG_SWITCH_CNTRL);\r\nreg = 0x70;\r\nreg <<= 2;\r\ncore_writel(priv, addr, reg);\r\nreg = 0x80 << 8 | regnum << 1;\r\nreg <<= 2;\r\nif (op)\r\nret = core_readl(priv, reg);\r\nelse\r\ncore_writel(priv, val, reg);\r\nreg = reg_readl(priv, REG_SWITCH_CNTRL);\r\nreg &= ~MDIO_MASTER_SEL;\r\nreg_writel(priv, reg, REG_SWITCH_CNTRL);\r\nreturn ret & 0xffff;\r\n}\r\nstatic int bcm_sf2_sw_mdio_read(struct mii_bus *bus, int addr, int regnum)\r\n{\r\nstruct bcm_sf2_priv *priv = bus->priv;\r\nif (addr == BRCM_PSEUDO_PHY_ADDR && priv->indir_phy_mask & BIT(addr))\r\nreturn bcm_sf2_sw_indir_rw(priv, 1, addr, regnum, 0);\r\nelse\r\nreturn mdiobus_read_nested(priv->master_mii_bus, addr, regnum);\r\n}\r\nstatic int bcm_sf2_sw_mdio_write(struct mii_bus *bus, int addr, int regnum,\r\nu16 val)\r\n{\r\nstruct bcm_sf2_priv *priv = bus->priv;\r\nif (addr == BRCM_PSEUDO_PHY_ADDR && priv->indir_phy_mask & BIT(addr))\r\nbcm_sf2_sw_indir_rw(priv, 0, addr, regnum, val);\r\nelse\r\nmdiobus_write_nested(priv->master_mii_bus, addr, regnum, val);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bcm_sf2_switch_0_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_sf2_priv *priv = dev_id;\r\npriv->irq0_stat = intrl2_0_readl(priv, INTRL2_CPU_STATUS) &\r\n~priv->irq0_mask;\r\nintrl2_0_writel(priv, priv->irq0_stat, INTRL2_CPU_CLEAR);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t bcm_sf2_switch_1_isr(int irq, void *dev_id)\r\n{\r\nstruct bcm_sf2_priv *priv = dev_id;\r\npriv->irq1_stat = intrl2_1_readl(priv, INTRL2_CPU_STATUS) &\r\n~priv->irq1_mask;\r\nintrl2_1_writel(priv, priv->irq1_stat, INTRL2_CPU_CLEAR);\r\nif (priv->irq1_stat & P_LINK_UP_IRQ(P7_IRQ_OFF))\r\npriv->port_sts[7].link = 1;\r\nif (priv->irq1_stat & P_LINK_DOWN_IRQ(P7_IRQ_OFF))\r\npriv->port_sts[7].link = 0;\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int bcm_sf2_sw_rst(struct bcm_sf2_priv *priv)\r\n{\r\nunsigned int timeout = 1000;\r\nu32 reg;\r\nreg = core_readl(priv, CORE_WATCHDOG_CTRL);\r\nreg |= SOFTWARE_RESET | EN_CHIP_RST | EN_SW_RESET;\r\ncore_writel(priv, reg, CORE_WATCHDOG_CTRL);\r\ndo {\r\nreg = core_readl(priv, CORE_WATCHDOG_CTRL);\r\nif (!(reg & SOFTWARE_RESET))\r\nbreak;\r\nusleep_range(1000, 2000);\r\n} while (timeout-- > 0);\r\nif (timeout == 0)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_intr_disable(struct bcm_sf2_priv *priv)\r\n{\r\nintrl2_0_mask_set(priv, 0xffffffff);\r\nintrl2_0_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\nintrl2_1_mask_set(priv, 0xffffffff);\r\nintrl2_1_writel(priv, 0xffffffff, INTRL2_CPU_CLEAR);\r\n}\r\nstatic void bcm_sf2_identify_ports(struct bcm_sf2_priv *priv,\r\nstruct device_node *dn)\r\n{\r\nstruct device_node *port;\r\nconst char *phy_mode_str;\r\nint mode;\r\nunsigned int port_num;\r\nint ret;\r\npriv->moca_port = -1;\r\nfor_each_available_child_of_node(dn, port) {\r\nif (of_property_read_u32(port, "reg", &port_num))\r\ncontinue;\r\nmode = of_get_phy_mode(port);\r\nif (mode < 0) {\r\nret = of_property_read_string(port, "phy-mode",\r\n&phy_mode_str);\r\nif (ret < 0)\r\ncontinue;\r\nif (!strcasecmp(phy_mode_str, "internal"))\r\npriv->int_phy_mask |= 1 << port_num;\r\n}\r\nif (mode == PHY_INTERFACE_MODE_MOCA)\r\npriv->moca_port = port_num;\r\nif (of_property_read_bool(port, "brcm,use-bcm-hdr"))\r\npriv->brcm_tag_mask |= 1 << port_num;\r\n}\r\n}\r\nstatic int bcm_sf2_mdio_register(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct device_node *dn;\r\nstatic int index;\r\nint err;\r\ndn = of_find_compatible_node(NULL, NULL, "brcm,unimac-mdio");\r\npriv->master_mii_bus = of_mdio_find_bus(dn);\r\nif (!priv->master_mii_bus)\r\nreturn -EPROBE_DEFER;\r\nget_device(&priv->master_mii_bus->dev);\r\npriv->master_mii_dn = dn;\r\npriv->slave_mii_bus = devm_mdiobus_alloc(ds->dev);\r\nif (!priv->slave_mii_bus)\r\nreturn -ENOMEM;\r\npriv->slave_mii_bus->priv = priv;\r\npriv->slave_mii_bus->name = "sf2 slave mii";\r\npriv->slave_mii_bus->read = bcm_sf2_sw_mdio_read;\r\npriv->slave_mii_bus->write = bcm_sf2_sw_mdio_write;\r\nsnprintf(priv->slave_mii_bus->id, MII_BUS_ID_SIZE, "sf2-%d",\r\nindex++);\r\npriv->slave_mii_bus->dev.of_node = dn;\r\nif (of_machine_is_compatible("brcm,bcm7445d0"))\r\npriv->indir_phy_mask |= (1 << BRCM_PSEUDO_PHY_ADDR);\r\nelse\r\npriv->indir_phy_mask = 0;\r\nds->phys_mii_mask = priv->indir_phy_mask;\r\nds->slave_mii_bus = priv->slave_mii_bus;\r\npriv->slave_mii_bus->parent = ds->dev->parent;\r\npriv->slave_mii_bus->phy_mask = ~priv->indir_phy_mask;\r\nif (dn)\r\nerr = of_mdiobus_register(priv->slave_mii_bus, dn);\r\nelse\r\nerr = mdiobus_register(priv->slave_mii_bus);\r\nif (err)\r\nof_node_put(dn);\r\nreturn err;\r\n}\r\nstatic void bcm_sf2_mdio_unregister(struct bcm_sf2_priv *priv)\r\n{\r\nmdiobus_unregister(priv->slave_mii_bus);\r\nif (priv->master_mii_dn)\r\nof_node_put(priv->master_mii_dn);\r\n}\r\nstatic u32 bcm_sf2_sw_get_phy_flags(struct dsa_switch *ds, int port)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nreturn priv->hw_params.gphy_rev;\r\n}\r\nstatic void bcm_sf2_sw_adjust_link(struct dsa_switch *ds, int port,\r\nstruct phy_device *phydev)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nu32 id_mode_dis = 0, port_mode;\r\nconst char *str = NULL;\r\nu32 reg, offset;\r\nif (priv->type == BCM7445_DEVICE_ID)\r\noffset = CORE_STS_OVERRIDE_GMIIP_PORT(port);\r\nelse\r\noffset = CORE_STS_OVERRIDE_GMIIP2_PORT(port);\r\nswitch (phydev->interface) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nstr = "RGMII (no delay)";\r\nid_mode_dis = 1;\r\ncase PHY_INTERFACE_MODE_RGMII_TXID:\r\nif (!str)\r\nstr = "RGMII (TX delay)";\r\nport_mode = EXT_GPHY;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_MII:\r\nstr = "MII";\r\nport_mode = EXT_EPHY;\r\nbreak;\r\ncase PHY_INTERFACE_MODE_REVMII:\r\nstr = "Reverse MII";\r\nport_mode = EXT_REVMII;\r\nbreak;\r\ndefault:\r\ngoto force_link;\r\n}\r\nif (!phydev->link) {\r\nreg = reg_readl(priv, REG_RGMII_CNTRL_P(port));\r\nreg &= ~RGMII_MODE_EN;\r\nreg_writel(priv, reg, REG_RGMII_CNTRL_P(port));\r\ngoto force_link;\r\n}\r\nreg = reg_readl(priv, REG_RGMII_CNTRL_P(port));\r\nreg &= ~ID_MODE_DIS;\r\nreg &= ~(PORT_MODE_MASK << PORT_MODE_SHIFT);\r\nreg &= ~(RX_PAUSE_EN | TX_PAUSE_EN);\r\nreg |= port_mode | RGMII_MODE_EN;\r\nif (id_mode_dis)\r\nreg |= ID_MODE_DIS;\r\nif (phydev->pause) {\r\nif (phydev->asym_pause)\r\nreg |= TX_PAUSE_EN;\r\nreg |= RX_PAUSE_EN;\r\n}\r\nreg_writel(priv, reg, REG_RGMII_CNTRL_P(port));\r\npr_info("Port %d configured for %s\n", port, str);\r\nforce_link:\r\nreg = SW_OVERRIDE;\r\nswitch (phydev->speed) {\r\ncase SPEED_1000:\r\nreg |= SPDSTS_1000 << SPEED_SHIFT;\r\nbreak;\r\ncase SPEED_100:\r\nreg |= SPDSTS_100 << SPEED_SHIFT;\r\nbreak;\r\n}\r\nif (phydev->link)\r\nreg |= LINK_STS;\r\nif (phydev->duplex == DUPLEX_FULL)\r\nreg |= DUPLX_MODE;\r\ncore_writel(priv, reg, offset);\r\nif (!phydev->is_pseudo_fixed_link)\r\np->eee_enabled = bcm_sf2_eee_init(ds, port, phydev);\r\n}\r\nstatic void bcm_sf2_sw_fixed_link_update(struct dsa_switch *ds, int port,\r\nstruct fixed_phy_status *status)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nu32 duplex, pause, offset;\r\nu32 reg;\r\nif (priv->type == BCM7445_DEVICE_ID)\r\noffset = CORE_STS_OVERRIDE_GMIIP_PORT(port);\r\nelse\r\noffset = CORE_STS_OVERRIDE_GMIIP2_PORT(port);\r\nduplex = core_readl(priv, CORE_DUPSTS);\r\npause = core_readl(priv, CORE_PAUSESTS);\r\nstatus->link = 0;\r\nif (port == priv->moca_port) {\r\nstatus->link = priv->port_sts[port].link;\r\nif (!status->link)\r\nnetif_carrier_off(ds->ports[port].netdev);\r\nstatus->duplex = 1;\r\n} else {\r\nstatus->link = 1;\r\nstatus->duplex = !!(duplex & (1 << port));\r\n}\r\nreg = core_readl(priv, offset);\r\nreg |= SW_OVERRIDE;\r\nif (status->link)\r\nreg |= LINK_STS;\r\nelse\r\nreg &= ~LINK_STS;\r\ncore_writel(priv, reg, offset);\r\nif ((pause & (1 << port)) &&\r\n(pause & (1 << (port + PAUSESTS_TX_PAUSE_SHIFT)))) {\r\nstatus->asym_pause = 1;\r\nstatus->pause = 1;\r\n}\r\nif (pause & (1 << port))\r\nstatus->pause = 1;\r\n}\r\nstatic int bcm_sf2_sw_suspend(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nunsigned int port;\r\nbcm_sf2_intr_disable(priv);\r\nfor (port = 0; port < DSA_MAX_PORTS; port++) {\r\nif ((1 << port) & ds->enabled_port_mask ||\r\ndsa_is_cpu_port(ds, port))\r\nbcm_sf2_port_disable(ds, port, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_resume(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nunsigned int port;\r\nint ret;\r\nret = bcm_sf2_sw_rst(priv);\r\nif (ret) {\r\npr_err("%s: failed to software reset switch\n", __func__);\r\nreturn ret;\r\n}\r\nif (priv->hw_params.num_gphy == 1)\r\nbcm_sf2_gphy_enable_set(ds, true);\r\nfor (port = 0; port < DSA_MAX_PORTS; port++) {\r\nif ((1 << port) & ds->enabled_port_mask)\r\nbcm_sf2_port_setup(ds, port, NULL);\r\nelse if (dsa_is_cpu_port(ds, port))\r\nbcm_sf2_imp_setup(ds, port);\r\n}\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_sw_get_wol(struct dsa_switch *ds, int port,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *p = ds->dst[ds->index].master_netdev;\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nstruct ethtool_wolinfo pwol;\r\np->ethtool_ops->get_wol(p, &pwol);\r\nwol->supported = pwol.supported;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\nif (pwol.wolopts & WAKE_MAGICSECURE)\r\nmemcpy(&wol->sopass, pwol.sopass, sizeof(wol->sopass));\r\nif (priv->wol_ports_mask & (1 << port))\r\nwol->wolopts = pwol.wolopts;\r\nelse\r\nwol->wolopts = 0;\r\n}\r\nstatic int bcm_sf2_sw_set_wol(struct dsa_switch *ds, int port,\r\nstruct ethtool_wolinfo *wol)\r\n{\r\nstruct net_device *p = ds->dst[ds->index].master_netdev;\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\ns8 cpu_port = ds->dst[ds->index].cpu_port;\r\nstruct ethtool_wolinfo pwol;\r\np->ethtool_ops->get_wol(p, &pwol);\r\nif (wol->wolopts & ~pwol.supported)\r\nreturn -EINVAL;\r\nif (wol->wolopts)\r\npriv->wol_ports_mask |= (1 << port);\r\nelse\r\npriv->wol_ports_mask &= ~(1 << port);\r\nif (priv->wol_ports_mask && priv->wol_ports_mask != (1 << cpu_port))\r\npriv->wol_ports_mask |= (1 << cpu_port);\r\nelse\r\npriv->wol_ports_mask &= ~(1 << cpu_port);\r\nreturn p->ethtool_ops->set_wol(p, wol);\r\n}\r\nstatic int bcm_sf2_vlan_op_wait(struct bcm_sf2_priv *priv)\r\n{\r\nunsigned int timeout = 10;\r\nu32 reg;\r\ndo {\r\nreg = core_readl(priv, CORE_ARLA_VTBL_RWCTRL);\r\nif (!(reg & ARLA_VTBL_STDN))\r\nreturn 0;\r\nusleep_range(1000, 2000);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int bcm_sf2_vlan_op(struct bcm_sf2_priv *priv, u8 op)\r\n{\r\ncore_writel(priv, ARLA_VTBL_STDN | op, CORE_ARLA_VTBL_RWCTRL);\r\nreturn bcm_sf2_vlan_op_wait(priv);\r\n}\r\nstatic void bcm_sf2_sw_configure_vlan(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nunsigned int port;\r\nbcm_sf2_vlan_op(priv, ARLA_VTBL_CMD_CLEAR);\r\nfor (port = 0; port < priv->hw_params.num_ports; port++) {\r\nif (!((1 << port) & ds->enabled_port_mask))\r\ncontinue;\r\ncore_writel(priv, 1, CORE_DEFAULT_1Q_TAG_P(port));\r\n}\r\n}\r\nstatic int bcm_sf2_sw_setup(struct dsa_switch *ds)\r\n{\r\nstruct bcm_sf2_priv *priv = bcm_sf2_to_priv(ds);\r\nunsigned int port;\r\nfor (port = 0; port < priv->hw_params.num_ports; port++) {\r\nif ((1 << port) & ds->enabled_port_mask)\r\nbcm_sf2_port_setup(ds, port, NULL);\r\nelse if (dsa_is_cpu_port(ds, port))\r\nbcm_sf2_imp_setup(ds, port);\r\nelse\r\nbcm_sf2_port_disable(ds, port, NULL);\r\n}\r\nbcm_sf2_sw_configure_vlan(ds);\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_read8(struct b53_device *dev, u8 page, u8 reg,\r\nu8 *val)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\n*val = core_readl(priv, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_read16(struct b53_device *dev, u8 page, u8 reg,\r\nu16 *val)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\n*val = core_readl(priv, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_read32(struct b53_device *dev, u8 page, u8 reg,\r\nu32 *val)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\n*val = core_readl(priv, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_read64(struct b53_device *dev, u8 page, u8 reg,\r\nu64 *val)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\n*val = core_readq(priv, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_write8(struct b53_device *dev, u8 page, u8 reg,\r\nu8 value)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\ncore_writel(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_write16(struct b53_device *dev, u8 page, u8 reg,\r\nu16 value)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\ncore_writel(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_write32(struct b53_device *dev, u8 page, u8 reg,\r\nu32 value)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\ncore_writel(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_core_write64(struct b53_device *dev, u8 page, u8 reg,\r\nu64 value)\r\n{\r\nstruct bcm_sf2_priv *priv = dev->priv;\r\ncore_writeq(priv, value, SF2_PAGE_REG_MKADDR(page, reg));\r\nreturn 0;\r\n}\r\nstatic int bcm_sf2_sw_probe(struct platform_device *pdev)\r\n{\r\nconst char *reg_names[BCM_SF2_REGS_NUM] = BCM_SF2_REGS_NAME;\r\nstruct device_node *dn = pdev->dev.of_node;\r\nconst struct of_device_id *of_id = NULL;\r\nconst struct bcm_sf2_of_data *data;\r\nstruct b53_platform_data *pdata;\r\nstruct dsa_switch_ops *ops;\r\nstruct bcm_sf2_priv *priv;\r\nstruct b53_device *dev;\r\nstruct dsa_switch *ds;\r\nvoid __iomem **base;\r\nstruct resource *r;\r\nunsigned int i;\r\nu32 reg, rev;\r\nint ret;\r\npriv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nops = devm_kzalloc(&pdev->dev, sizeof(*ops), GFP_KERNEL);\r\nif (!ops)\r\nreturn -ENOMEM;\r\ndev = b53_switch_alloc(&pdev->dev, &bcm_sf2_io_ops, priv);\r\nif (!dev)\r\nreturn -ENOMEM;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\nof_id = of_match_node(bcm_sf2_of_match, dn);\r\nif (!of_id || !of_id->data)\r\nreturn -EINVAL;\r\ndata = of_id->data;\r\npriv->type = data->type;\r\npriv->reg_offsets = data->reg_offsets;\r\npriv->core_reg_align = data->core_reg_align;\r\npdata->chip_id = priv->type;\r\ndev->pdata = pdata;\r\npriv->dev = dev;\r\nds = dev->ds;\r\nds->ops = &bcm_sf2_ops;\r\ndev_set_drvdata(&pdev->dev, priv);\r\nspin_lock_init(&priv->indir_lock);\r\nmutex_init(&priv->stats_mutex);\r\nmutex_init(&priv->cfp.lock);\r\nset_bit(0, priv->cfp.used);\r\nbcm_sf2_identify_ports(priv, dn->child);\r\npriv->irq0 = irq_of_parse_and_map(dn, 0);\r\npriv->irq1 = irq_of_parse_and_map(dn, 1);\r\nbase = &priv->core;\r\nfor (i = 0; i < BCM_SF2_REGS_NUM; i++) {\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, i);\r\n*base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(*base)) {\r\npr_err("unable to find register: %s\n", reg_names[i]);\r\nreturn PTR_ERR(*base);\r\n}\r\nbase++;\r\n}\r\nret = bcm_sf2_sw_rst(priv);\r\nif (ret) {\r\npr_err("unable to software reset switch: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = bcm_sf2_mdio_register(ds);\r\nif (ret) {\r\npr_err("failed to register MDIO bus\n");\r\nreturn ret;\r\n}\r\nret = bcm_sf2_cfp_rst(priv);\r\nif (ret) {\r\npr_err("failed to reset CFP\n");\r\ngoto out_mdio;\r\n}\r\nbcm_sf2_intr_disable(priv);\r\nret = devm_request_irq(&pdev->dev, priv->irq0, bcm_sf2_switch_0_isr, 0,\r\n"switch_0", priv);\r\nif (ret < 0) {\r\npr_err("failed to request switch_0 IRQ\n");\r\ngoto out_mdio;\r\n}\r\nret = devm_request_irq(&pdev->dev, priv->irq1, bcm_sf2_switch_1_isr, 0,\r\n"switch_1", priv);\r\nif (ret < 0) {\r\npr_err("failed to request switch_1 IRQ\n");\r\ngoto out_mdio;\r\n}\r\nreg = core_readl(priv, CORE_GMNCFGCFG);\r\nreg |= RST_MIB_CNT;\r\ncore_writel(priv, reg, CORE_GMNCFGCFG);\r\nreg &= ~RST_MIB_CNT;\r\ncore_writel(priv, reg, CORE_GMNCFGCFG);\r\npriv->hw_params.num_ports = core_readl(priv, CORE_IMP0_PRT_ID) + 1;\r\nif (priv->hw_params.num_ports > DSA_MAX_PORTS)\r\npriv->hw_params.num_ports = DSA_MAX_PORTS;\r\nif (of_property_read_u32(dn, "brcm,num-gphy",\r\n&priv->hw_params.num_gphy))\r\npriv->hw_params.num_gphy = 1;\r\nrev = reg_readl(priv, REG_SWITCH_REVISION);\r\npriv->hw_params.top_rev = (rev >> SWITCH_TOP_REV_SHIFT) &\r\nSWITCH_TOP_REV_MASK;\r\npriv->hw_params.core_rev = (rev & SF2_REV_MASK);\r\nrev = reg_readl(priv, REG_PHY_REVISION);\r\npriv->hw_params.gphy_rev = rev & PHY_REVISION_MASK;\r\nret = b53_switch_register(dev);\r\nif (ret)\r\ngoto out_mdio;\r\npr_info("Starfighter 2 top: %x.%02x, core: %x.%02x base: 0x%p, IRQs: %d, %d\n",\r\npriv->hw_params.top_rev >> 8, priv->hw_params.top_rev & 0xff,\r\npriv->hw_params.core_rev >> 8, priv->hw_params.core_rev & 0xff,\r\npriv->core, priv->irq0, priv->irq1);\r\nreturn 0;\r\nout_mdio:\r\nbcm_sf2_mdio_unregister(priv);\r\nreturn ret;\r\n}\r\nstatic int bcm_sf2_sw_remove(struct platform_device *pdev)\r\n{\r\nstruct bcm_sf2_priv *priv = platform_get_drvdata(pdev);\r\npriv->wol_ports_mask = 0;\r\nbcm_sf2_sw_suspend(priv->dev->ds);\r\ndsa_unregister_switch(priv->dev->ds);\r\nbcm_sf2_mdio_unregister(priv);\r\nreturn 0;\r\n}\r\nstatic void bcm_sf2_sw_shutdown(struct platform_device *pdev)\r\n{\r\nstruct bcm_sf2_priv *priv = platform_get_drvdata(pdev);\r\nif (priv->hw_params.num_gphy == 1)\r\nbcm_sf2_gphy_enable_set(priv->dev->ds, true);\r\n}\r\nstatic int bcm_sf2_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct bcm_sf2_priv *priv = platform_get_drvdata(pdev);\r\nreturn dsa_switch_suspend(priv->dev->ds);\r\n}\r\nstatic int bcm_sf2_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct bcm_sf2_priv *priv = platform_get_drvdata(pdev);\r\nreturn dsa_switch_resume(priv->dev->ds);\r\n}
