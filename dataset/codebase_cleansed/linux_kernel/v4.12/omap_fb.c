uint32_t omap_framebuffer_get_formats(uint32_t *pixel_formats,\r\nuint32_t max_formats, enum omap_color_mode supported_modes)\r\n{\r\nuint32_t nformats = 0;\r\nint i = 0;\r\nfor (i = 0; i < ARRAY_SIZE(formats) && nformats < max_formats; i++)\r\nif (formats[i].dss_format & supported_modes)\r\npixel_formats[nformats++] = formats[i].pixel_format;\r\nreturn nformats;\r\n}\r\nstatic int omap_framebuffer_create_handle(struct drm_framebuffer *fb,\r\nstruct drm_file *file_priv,\r\nunsigned int *handle)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nreturn drm_gem_handle_create(file_priv,\r\nomap_fb->planes[0].bo, handle);\r\n}\r\nstatic void omap_framebuffer_destroy(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = fb->format->num_planes;\r\nDBG("destroy: FB ID: %d (%p)", fb->base.id, fb);\r\ndrm_framebuffer_cleanup(fb);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\ndrm_gem_object_unreference_unlocked(plane->bo);\r\n}\r\nkfree(omap_fb);\r\n}\r\nstatic uint32_t get_linear_addr(struct plane *plane,\r\nconst struct drm_format_info *format, int n, int x, int y)\r\n{\r\nuint32_t offset;\r\noffset = plane->offset\r\n+ (x * format->cpp[n] / (n == 0 ? 1 : format->hsub))\r\n+ (y * plane->pitch / (n == 0 ? 1 : format->vsub));\r\nreturn plane->paddr + offset;\r\n}\r\nbool omap_framebuffer_supports_rotation(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nstruct plane *plane = &omap_fb->planes[0];\r\nreturn omap_gem_flags(plane->bo) & OMAP_BO_TILED;\r\n}\r\nvoid omap_framebuffer_update_scanout(struct drm_framebuffer *fb,\r\nstruct omap_drm_window *win, struct omap_overlay_info *info)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nconst struct drm_format_info *format = omap_fb->format;\r\nstruct plane *plane = &omap_fb->planes[0];\r\nuint32_t x, y, orient = 0;\r\ninfo->color_mode = omap_fb->dss_format;\r\ninfo->pos_x = win->crtc_x;\r\ninfo->pos_y = win->crtc_y;\r\ninfo->out_width = win->crtc_w;\r\ninfo->out_height = win->crtc_h;\r\ninfo->width = win->src_w;\r\ninfo->height = win->src_h;\r\nx = win->src_x;\r\ny = win->src_y;\r\nif (omap_gem_flags(plane->bo) & OMAP_BO_TILED) {\r\nuint32_t w = win->src_w;\r\nuint32_t h = win->src_h;\r\nswitch (win->rotation & DRM_ROTATE_MASK) {\r\ndefault:\r\ndev_err(fb->dev->dev, "invalid rotation: %02x",\r\n(uint32_t)win->rotation);\r\ncase 0:\r\ncase DRM_ROTATE_0:\r\norient = 0;\r\nbreak;\r\ncase DRM_ROTATE_90:\r\norient = MASK_XY_FLIP | MASK_X_INVERT;\r\nbreak;\r\ncase DRM_ROTATE_180:\r\norient = MASK_X_INVERT | MASK_Y_INVERT;\r\nbreak;\r\ncase DRM_ROTATE_270:\r\norient = MASK_XY_FLIP | MASK_Y_INVERT;\r\nbreak;\r\n}\r\nif (win->rotation & DRM_REFLECT_X)\r\norient ^= MASK_X_INVERT;\r\nif (win->rotation & DRM_REFLECT_Y)\r\norient ^= MASK_Y_INVERT;\r\nif (orient & MASK_XY_FLIP)\r\nswap(w, h);\r\nif (orient & MASK_Y_INVERT)\r\ny += h - 1;\r\nif (orient & MASK_X_INVERT)\r\nx += w - 1;\r\nomap_gem_rotated_paddr(plane->bo, orient, x, y, &info->paddr);\r\ninfo->rotation_type = OMAP_DSS_ROT_TILER;\r\ninfo->screen_width = omap_gem_tiled_stride(plane->bo, orient);\r\n} else {\r\nswitch (win->rotation & DRM_ROTATE_MASK) {\r\ncase 0:\r\ncase DRM_ROTATE_0:\r\nbreak;\r\ndefault:\r\ndev_warn(fb->dev->dev,\r\n"rotation '%d' ignored for non-tiled fb\n",\r\nwin->rotation);\r\nwin->rotation = 0;\r\nbreak;\r\n}\r\ninfo->paddr = get_linear_addr(plane, format, 0, x, y);\r\ninfo->rotation_type = OMAP_DSS_ROT_DMA;\r\ninfo->screen_width = plane->pitch;\r\n}\r\ninfo->screen_width /= format->cpp[0];\r\nif (omap_fb->dss_format == OMAP_DSS_COLOR_NV12) {\r\nplane = &omap_fb->planes[1];\r\nif (info->rotation_type == OMAP_DSS_ROT_TILER) {\r\nWARN_ON(!(omap_gem_flags(plane->bo) & OMAP_BO_TILED));\r\nomap_gem_rotated_paddr(plane->bo, orient,\r\nx/2, y/2, &info->p_uv_addr);\r\n} else {\r\ninfo->p_uv_addr = get_linear_addr(plane, format, 1, x, y);\r\n}\r\n} else {\r\ninfo->p_uv_addr = 0;\r\n}\r\n}\r\nint omap_framebuffer_pin(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint ret, i, n = fb->format->num_planes;\r\nmutex_lock(&omap_fb->lock);\r\nif (omap_fb->pin_count > 0) {\r\nomap_fb->pin_count++;\r\nmutex_unlock(&omap_fb->lock);\r\nreturn 0;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nret = omap_gem_get_paddr(plane->bo, &plane->paddr, true);\r\nif (ret)\r\ngoto fail;\r\nomap_gem_dma_sync(plane->bo, DMA_TO_DEVICE);\r\n}\r\nomap_fb->pin_count++;\r\nmutex_unlock(&omap_fb->lock);\r\nreturn 0;\r\nfail:\r\nfor (i--; i >= 0; i--) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nomap_gem_put_paddr(plane->bo);\r\nplane->paddr = 0;\r\n}\r\nmutex_unlock(&omap_fb->lock);\r\nreturn ret;\r\n}\r\nvoid omap_framebuffer_unpin(struct drm_framebuffer *fb)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = fb->format->num_planes;\r\nmutex_lock(&omap_fb->lock);\r\nomap_fb->pin_count--;\r\nif (omap_fb->pin_count > 0) {\r\nmutex_unlock(&omap_fb->lock);\r\nreturn;\r\n}\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nomap_gem_put_paddr(plane->bo);\r\nplane->paddr = 0;\r\n}\r\nmutex_unlock(&omap_fb->lock);\r\n}\r\nstruct drm_connector *omap_framebuffer_get_next_connector(\r\nstruct drm_framebuffer *fb, struct drm_connector *from)\r\n{\r\nstruct drm_device *dev = fb->dev;\r\nstruct list_head *connector_list = &dev->mode_config.connector_list;\r\nstruct drm_connector *connector = from;\r\nif (!from)\r\nreturn list_first_entry_or_null(connector_list, typeof(*from),\r\nhead);\r\nlist_for_each_entry_from(connector, connector_list, head) {\r\nif (connector != from) {\r\nstruct drm_encoder *encoder = connector->encoder;\r\nstruct drm_crtc *crtc = encoder ? encoder->crtc : NULL;\r\nif (crtc && crtc->primary->fb == fb)\r\nreturn connector;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nvoid omap_framebuffer_describe(struct drm_framebuffer *fb, struct seq_file *m)\r\n{\r\nstruct omap_framebuffer *omap_fb = to_omap_framebuffer(fb);\r\nint i, n = fb->format->num_planes;\r\nseq_printf(m, "fb: %dx%d@%4.4s\n", fb->width, fb->height,\r\n(char *)&fb->format->format);\r\nfor (i = 0; i < n; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nseq_printf(m, " %d: offset=%d pitch=%d, obj: ",\r\ni, plane->offset, plane->pitch);\r\nomap_gem_describe(plane->bo, m);\r\n}\r\n}\r\nstruct drm_framebuffer *omap_framebuffer_create(struct drm_device *dev,\r\nstruct drm_file *file, const struct drm_mode_fb_cmd2 *mode_cmd)\r\n{\r\nunsigned int num_planes = drm_format_num_planes(mode_cmd->pixel_format);\r\nstruct drm_gem_object *bos[4];\r\nstruct drm_framebuffer *fb;\r\nint i;\r\nfor (i = 0; i < num_planes; i++) {\r\nbos[i] = drm_gem_object_lookup(file, mode_cmd->handles[i]);\r\nif (!bos[i]) {\r\nfb = ERR_PTR(-ENOENT);\r\ngoto error;\r\n}\r\n}\r\nfb = omap_framebuffer_init(dev, mode_cmd, bos);\r\nif (IS_ERR(fb))\r\ngoto error;\r\nreturn fb;\r\nerror:\r\nwhile (--i > 0)\r\ndrm_gem_object_unreference_unlocked(bos[i]);\r\nreturn fb;\r\n}\r\nstruct drm_framebuffer *omap_framebuffer_init(struct drm_device *dev,\r\nconst struct drm_mode_fb_cmd2 *mode_cmd, struct drm_gem_object **bos)\r\n{\r\nconst struct drm_format_info *format = NULL;\r\nstruct omap_framebuffer *omap_fb = NULL;\r\nstruct drm_framebuffer *fb = NULL;\r\nenum omap_color_mode dss_format = 0;\r\nunsigned int pitch = mode_cmd->pitches[0];\r\nint ret, i;\r\nDBG("create framebuffer: dev=%p, mode_cmd=%p (%dx%d@%4.4s)",\r\ndev, mode_cmd, mode_cmd->width, mode_cmd->height,\r\n(char *)&mode_cmd->pixel_format);\r\nformat = drm_format_info(mode_cmd->pixel_format);\r\nfor (i = 0; i < ARRAY_SIZE(formats); i++) {\r\nif (formats[i].pixel_format == mode_cmd->pixel_format) {\r\ndss_format = formats[i].dss_format;\r\nbreak;\r\n}\r\n}\r\nif (!format || !dss_format) {\r\ndev_dbg(dev->dev, "unsupported pixel format: %4.4s\n",\r\n(char *)&mode_cmd->pixel_format);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nomap_fb = kzalloc(sizeof(*omap_fb), GFP_KERNEL);\r\nif (!omap_fb) {\r\nret = -ENOMEM;\r\ngoto fail;\r\n}\r\nfb = &omap_fb->base;\r\nomap_fb->format = format;\r\nomap_fb->dss_format = dss_format;\r\nmutex_init(&omap_fb->lock);\r\nif (format->num_planes == 2 && pitch != mode_cmd->pitches[1]) {\r\ndev_dbg(dev->dev, "pitches differ between planes 0 and 1\n");\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nif (pitch % format->cpp[0]) {\r\ndev_dbg(dev->dev,\r\n"buffer pitch (%u bytes) is not a multiple of pixel size (%u bytes)\n",\r\npitch, format->cpp[0]);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nfor (i = 0; i < format->num_planes; i++) {\r\nstruct plane *plane = &omap_fb->planes[i];\r\nunsigned int vsub = i == 0 ? 1 : format->vsub;\r\nunsigned int size;\r\nsize = pitch * mode_cmd->height / vsub;\r\nif (size > omap_gem_mmap_size(bos[i]) - mode_cmd->offsets[i]) {\r\ndev_dbg(dev->dev,\r\n"provided buffer object is too small! %d < %d\n",\r\nbos[i]->size - mode_cmd->offsets[i], size);\r\nret = -EINVAL;\r\ngoto fail;\r\n}\r\nplane->bo = bos[i];\r\nplane->offset = mode_cmd->offsets[i];\r\nplane->pitch = pitch;\r\nplane->paddr = 0;\r\n}\r\ndrm_helper_mode_fill_fb_struct(dev, fb, mode_cmd);\r\nret = drm_framebuffer_init(dev, fb, &omap_framebuffer_funcs);\r\nif (ret) {\r\ndev_err(dev->dev, "framebuffer init failed: %d\n", ret);\r\ngoto fail;\r\n}\r\nDBG("create: FB ID: %d (%p)", fb->base.id, fb);\r\nreturn fb;\r\nfail:\r\nkfree(omap_fb);\r\nreturn ERR_PTR(ret);\r\n}
