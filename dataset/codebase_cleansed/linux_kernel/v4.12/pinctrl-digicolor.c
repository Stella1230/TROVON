static int dc_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn PINS_COUNT;\r\n}\r\nstatic const char *dc_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pmap->desc->pins[selector].name;\r\n}\r\nstatic int dc_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = &pmap->desc->pins[selector].number;\r\n*num_pins = 1;\r\nreturn 0;\r\n}\r\nstatic int dc_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nreturn ARRAY_SIZE(dc_functions);\r\n}\r\nstatic const char *dc_get_fname(struct pinctrl_dev *pctldev, unsigned selector)\r\n{\r\nreturn dc_functions[selector];\r\n}\r\nstatic int dc_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pmap->pin_names;\r\n*num_groups = PINS_COUNT;\r\nreturn 0;\r\n}\r\nstatic void dc_client_sel(int pin_num, int *reg, int *bit)\r\n{\r\n*bit = (pin_num % PINS_PER_COLLECTION) * 2;\r\n*reg = GP_CLIENTSEL(pin_num/PINS_PER_COLLECTION);\r\nif (*bit >= PINS_PER_COLLECTION) {\r\n*bit -= PINS_PER_COLLECTION;\r\n*reg += 1;\r\n}\r\n}\r\nstatic int dc_set_mux(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pctldev);\r\nint bit_off, reg_off;\r\nu8 reg;\r\ndc_client_sel(group, &reg_off, &bit_off);\r\nreg = readb_relaxed(pmap->regs + reg_off);\r\nreg &= ~(3 << bit_off);\r\nreg |= (selector << bit_off);\r\nwriteb_relaxed(reg, pmap->regs + reg_off);\r\nreturn 0;\r\n}\r\nstatic int dc_pmx_request_gpio(struct pinctrl_dev *pcdev,\r\nstruct pinctrl_gpio_range *range,\r\nunsigned offset)\r\n{\r\nstruct dc_pinmap *pmap = pinctrl_dev_get_drvdata(pcdev);\r\nint bit_off, reg_off;\r\nu8 reg;\r\ndc_client_sel(offset, &reg_off, &bit_off);\r\nreg = readb_relaxed(pmap->regs + reg_off);\r\nif ((reg & (3 << bit_off)) != 0)\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int dc_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct dc_pinmap *pmap = gpiochip_get_data(chip);\r\nint reg_off = GP_DRIVE0(gpio/PINS_PER_COLLECTION);\r\nint bit_off = gpio % PINS_PER_COLLECTION;\r\nu8 drive;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pmap->lock, flags);\r\ndrive = readb_relaxed(pmap->regs + reg_off);\r\ndrive &= ~BIT(bit_off);\r\nwriteb_relaxed(drive, pmap->regs + reg_off);\r\nspin_unlock_irqrestore(&pmap->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dc_gpio_direction_output(struct gpio_chip *chip, unsigned gpio,\r\nint value)\r\n{\r\nstruct dc_pinmap *pmap = gpiochip_get_data(chip);\r\nint reg_off = GP_DRIVE0(gpio/PINS_PER_COLLECTION);\r\nint bit_off = gpio % PINS_PER_COLLECTION;\r\nu8 drive;\r\nunsigned long flags;\r\ndc_gpio_set(chip, gpio, value);\r\nspin_lock_irqsave(&pmap->lock, flags);\r\ndrive = readb_relaxed(pmap->regs + reg_off);\r\ndrive |= BIT(bit_off);\r\nwriteb_relaxed(drive, pmap->regs + reg_off);\r\nspin_unlock_irqrestore(&pmap->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dc_gpio_get(struct gpio_chip *chip, unsigned gpio)\r\n{\r\nstruct dc_pinmap *pmap = gpiochip_get_data(chip);\r\nint reg_off = GP_INPUT(gpio/PINS_PER_COLLECTION);\r\nint bit_off = gpio % PINS_PER_COLLECTION;\r\nu8 input;\r\ninput = readb_relaxed(pmap->regs + reg_off);\r\nreturn !!(input & BIT(bit_off));\r\n}\r\nstatic void dc_gpio_set(struct gpio_chip *chip, unsigned gpio, int value)\r\n{\r\nstruct dc_pinmap *pmap = gpiochip_get_data(chip);\r\nint reg_off = GP_OUTPUT0(gpio/PINS_PER_COLLECTION);\r\nint bit_off = gpio % PINS_PER_COLLECTION;\r\nu8 output;\r\nunsigned long flags;\r\nspin_lock_irqsave(&pmap->lock, flags);\r\noutput = readb_relaxed(pmap->regs + reg_off);\r\nif (value)\r\noutput |= BIT(bit_off);\r\nelse\r\noutput &= ~BIT(bit_off);\r\nwriteb_relaxed(output, pmap->regs + reg_off);\r\nspin_unlock_irqrestore(&pmap->lock, flags);\r\n}\r\nstatic int dc_gpiochip_add(struct dc_pinmap *pmap, struct device_node *np)\r\n{\r\nstruct gpio_chip *chip = &pmap->chip;\r\nint ret;\r\nchip->label = DRIVER_NAME;\r\nchip->parent = pmap->dev;\r\nchip->request = gpiochip_generic_request;\r\nchip->free = gpiochip_generic_free;\r\nchip->direction_input = dc_gpio_direction_input;\r\nchip->direction_output = dc_gpio_direction_output;\r\nchip->get = dc_gpio_get;\r\nchip->set = dc_gpio_set;\r\nchip->base = -1;\r\nchip->ngpio = PINS_COUNT;\r\nchip->of_node = np;\r\nchip->of_gpio_n_cells = 2;\r\nspin_lock_init(&pmap->lock);\r\nret = gpiochip_add_data(chip, pmap);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gpiochip_add_pin_range(chip, dev_name(pmap->dev), 0, 0,\r\nPINS_COUNT);\r\nif (ret < 0) {\r\ngpiochip_remove(chip);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dc_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct dc_pinmap *pmap;\r\nstruct resource *r;\r\nstruct pinctrl_pin_desc *pins;\r\nstruct pinctrl_desc *pctl_desc;\r\nchar *pin_names;\r\nint name_len = strlen("GP_xx") + 1;\r\nint i, j;\r\npmap = devm_kzalloc(&pdev->dev, sizeof(*pmap), GFP_KERNEL);\r\nif (!pmap)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npmap->regs = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(pmap->regs))\r\nreturn PTR_ERR(pmap->regs);\r\npins = devm_kzalloc(&pdev->dev, sizeof(*pins)*PINS_COUNT, GFP_KERNEL);\r\nif (!pins)\r\nreturn -ENOMEM;\r\npin_names = devm_kzalloc(&pdev->dev, name_len * PINS_COUNT,\r\nGFP_KERNEL);\r\nif (!pin_names)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < PIN_COLLECTIONS; i++) {\r\nfor (j = 0; j < PINS_PER_COLLECTION; j++) {\r\nint pin_id = i*PINS_PER_COLLECTION + j;\r\nchar *name = &pin_names[pin_id * name_len];\r\nsnprintf(name, name_len, "GP_%c%c", 'A'+i, '0'+j);\r\npins[pin_id].number = pin_id;\r\npins[pin_id].name = name;\r\npmap->pin_names[pin_id] = name;\r\n}\r\n}\r\npctl_desc = devm_kzalloc(&pdev->dev, sizeof(*pctl_desc), GFP_KERNEL);\r\nif (!pctl_desc)\r\nreturn -ENOMEM;\r\npctl_desc->name = DRIVER_NAME,\r\npctl_desc->owner = THIS_MODULE,\r\npctl_desc->pctlops = &dc_pinctrl_ops,\r\npctl_desc->pmxops = &dc_pmxops,\r\npctl_desc->npins = PINS_COUNT;\r\npctl_desc->pins = pins;\r\npmap->desc = pctl_desc;\r\npmap->dev = &pdev->dev;\r\npmap->pctl = devm_pinctrl_register(&pdev->dev, pctl_desc, pmap);\r\nif (IS_ERR(pmap->pctl)) {\r\ndev_err(&pdev->dev, "pinctrl driver registration failed\n");\r\nreturn PTR_ERR(pmap->pctl);\r\n}\r\nreturn dc_gpiochip_add(pmap, pdev->dev.of_node);\r\n}
