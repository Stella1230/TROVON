static int hisi_rng_init(struct hwrng *rng)\r\n{\r\nstruct hisi_rng *hrng = to_hisi_rng(rng);\r\nint val = RNG_EN;\r\nu32 seed;\r\nget_random_bytes(&seed, sizeof(seed));\r\nwritel_relaxed(seed, hrng->base + RNG_SEED);\r\nif (seed_sel == 1)\r\nval |= RNG_RING_EN | RNG_SEED_SEL;\r\nwritel_relaxed(val, hrng->base + RNG_CTRL);\r\nreturn 0;\r\n}\r\nstatic void hisi_rng_cleanup(struct hwrng *rng)\r\n{\r\nstruct hisi_rng *hrng = to_hisi_rng(rng);\r\nwritel_relaxed(0, hrng->base + RNG_CTRL);\r\n}\r\nstatic int hisi_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)\r\n{\r\nstruct hisi_rng *hrng = to_hisi_rng(rng);\r\nu32 *data = buf;\r\n*data = readl_relaxed(hrng->base + RNG_RAN_NUM);\r\nreturn 4;\r\n}\r\nstatic int hisi_rng_probe(struct platform_device *pdev)\r\n{\r\nstruct hisi_rng *rng;\r\nstruct resource *res;\r\nint ret;\r\nrng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);\r\nif (!rng)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, rng);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrng->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(rng->base))\r\nreturn PTR_ERR(rng->base);\r\nrng->rng.name = pdev->name;\r\nrng->rng.init = hisi_rng_init;\r\nrng->rng.cleanup = hisi_rng_cleanup;\r\nrng->rng.read = hisi_rng_read;\r\nret = devm_hwrng_register(&pdev->dev, &rng->rng);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to register hwrng\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
