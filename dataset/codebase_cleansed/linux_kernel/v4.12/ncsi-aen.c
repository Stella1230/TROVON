static int ncsi_validate_aen_pkt(struct ncsi_aen_pkt_hdr *h,\r\nconst unsigned short payload)\r\n{\r\nu32 checksum;\r\n__be32 *pchecksum;\r\nif (h->common.revision != NCSI_PKT_REVISION)\r\nreturn -EINVAL;\r\nif (ntohs(h->common.length) != payload)\r\nreturn -EINVAL;\r\npchecksum = (__be32 *)((void *)(h + 1) + payload - 4);\r\nif (ntohl(*pchecksum) == 0)\r\nreturn 0;\r\nchecksum = ncsi_calculate_checksum((unsigned char *)h,\r\nsizeof(*h) + payload - 4);\r\nif (*pchecksum != htonl(checksum))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int ncsi_aen_handler_lsc(struct ncsi_dev_priv *ndp,\r\nstruct ncsi_aen_pkt_hdr *h)\r\n{\r\nstruct ncsi_aen_lsc_pkt *lsc;\r\nstruct ncsi_channel *nc;\r\nstruct ncsi_channel_mode *ncm;\r\nbool chained;\r\nint state;\r\nunsigned long old_data, data;\r\nunsigned long flags;\r\nncsi_find_package_and_channel(ndp, h->common.channel, NULL, &nc);\r\nif (!nc)\r\nreturn -ENODEV;\r\nlsc = (struct ncsi_aen_lsc_pkt *)h;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nncm = &nc->modes[NCSI_MODE_LINK];\r\nold_data = ncm->data[2];\r\ndata = ntohl(lsc->status);\r\nncm->data[2] = data;\r\nncm->data[4] = ntohl(lsc->oem_status);\r\nchained = !list_empty(&nc->link);\r\nstate = nc->state;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nif (!((old_data ^ data) & 0x1) || chained)\r\nreturn 0;\r\nif (!(state == NCSI_CHANNEL_INACTIVE && (data & 0x1)) &&\r\n!(state == NCSI_CHANNEL_ACTIVE && !(data & 0x1)))\r\nreturn 0;\r\nif (!(ndp->flags & NCSI_DEV_HWA) &&\r\nstate == NCSI_CHANNEL_ACTIVE)\r\nndp->flags |= NCSI_DEV_RESHUFFLE;\r\nncsi_stop_channel_monitor(nc);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nreturn ncsi_process_next_channel(ndp);\r\n}\r\nstatic int ncsi_aen_handler_cr(struct ncsi_dev_priv *ndp,\r\nstruct ncsi_aen_pkt_hdr *h)\r\n{\r\nstruct ncsi_channel *nc;\r\nunsigned long flags;\r\nncsi_find_package_and_channel(ndp, h->common.channel, NULL, &nc);\r\nif (!nc)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nif (!list_empty(&nc->link) ||\r\nnc->state != NCSI_CHANNEL_ACTIVE) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nncsi_stop_channel_monitor(nc);\r\nspin_lock_irqsave(&nc->lock, flags);\r\nnc->state = NCSI_CHANNEL_INVISIBLE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nnc->state = NCSI_CHANNEL_INACTIVE;\r\nlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nreturn ncsi_process_next_channel(ndp);\r\n}\r\nstatic int ncsi_aen_handler_hncdsc(struct ncsi_dev_priv *ndp,\r\nstruct ncsi_aen_pkt_hdr *h)\r\n{\r\nstruct ncsi_channel *nc;\r\nstruct ncsi_channel_mode *ncm;\r\nstruct ncsi_aen_hncdsc_pkt *hncdsc;\r\nunsigned long flags;\r\nncsi_find_package_and_channel(ndp, h->common.channel, NULL, &nc);\r\nif (!nc)\r\nreturn -ENODEV;\r\nspin_lock_irqsave(&nc->lock, flags);\r\nncm = &nc->modes[NCSI_MODE_LINK];\r\nhncdsc = (struct ncsi_aen_hncdsc_pkt *)h;\r\nncm->data[3] = ntohl(hncdsc->status);\r\nif (!list_empty(&nc->link) ||\r\nnc->state != NCSI_CHANNEL_ACTIVE) {\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nreturn 0;\r\n}\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nif (!(ndp->flags & NCSI_DEV_HWA) && !(ncm->data[3] & 0x1))\r\nndp->flags |= NCSI_DEV_RESHUFFLE;\r\nncsi_stop_channel_monitor(nc);\r\nspin_lock_irqsave(&nc->lock, flags);\r\nnc->state = (ncm->data[3] & 0x1) ? NCSI_CHANNEL_INACTIVE :\r\nNCSI_CHANNEL_ACTIVE;\r\nspin_unlock_irqrestore(&nc->lock, flags);\r\nspin_lock_irqsave(&ndp->lock, flags);\r\nlist_add_tail_rcu(&nc->link, &ndp->channel_queue);\r\nspin_unlock_irqrestore(&ndp->lock, flags);\r\nncsi_process_next_channel(ndp);\r\nreturn 0;\r\n}\r\nint ncsi_aen_handler(struct ncsi_dev_priv *ndp, struct sk_buff *skb)\r\n{\r\nstruct ncsi_aen_pkt_hdr *h;\r\nstruct ncsi_aen_handler *nah = NULL;\r\nint i, ret;\r\nh = (struct ncsi_aen_pkt_hdr *)skb_network_header(skb);\r\nfor (i = 0; i < ARRAY_SIZE(ncsi_aen_handlers); i++) {\r\nif (ncsi_aen_handlers[i].type == h->type) {\r\nnah = &ncsi_aen_handlers[i];\r\nbreak;\r\n}\r\n}\r\nif (!nah) {\r\nnetdev_warn(ndp->ndev.dev, "Invalid AEN (0x%x) received\n",\r\nh->type);\r\nreturn -ENOENT;\r\n}\r\nret = ncsi_validate_aen_pkt(h, nah->payload);\r\nif (ret)\r\ngoto out;\r\nret = nah->handler(ndp, h);\r\nout:\r\nconsume_skb(skb);\r\nreturn ret;\r\n}
