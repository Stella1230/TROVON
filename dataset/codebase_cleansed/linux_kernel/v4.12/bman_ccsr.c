static inline u32 bm_ccsr_in(u32 offset)\r\n{\r\nreturn ioread32be(bm_ccsr_start + offset/4);\r\n}\r\nstatic inline void bm_ccsr_out(u32 offset, u32 val)\r\n{\r\niowrite32be(val, bm_ccsr_start + offset/4);\r\n}\r\nstatic void bm_get_version(u16 *id, u8 *major, u8 *minor)\r\n{\r\nu32 v = bm_ccsr_in(REG_IP_REV_1);\r\n*id = (v >> 16);\r\n*major = (v >> 8) & 0xff;\r\n*minor = v & 0xff;\r\n}\r\nstatic void bm_set_memory(u64 ba, u32 size)\r\n{\r\nu32 exp = ilog2(size);\r\nDPAA_ASSERT(size >= 4096 && size <= 1024*1024*1024 &&\r\nis_power_of_2(size));\r\nDPAA_ASSERT(!(ba & (size - 1)));\r\nbm_ccsr_out(REG_FBPR_BARE, upper_32_bits(ba));\r\nbm_ccsr_out(REG_FBPR_BAR, lower_32_bits(ba));\r\nbm_ccsr_out(REG_FBPR_AR, exp - 1);\r\n}\r\nstatic int bman_fbpr(struct reserved_mem *rmem)\r\n{\r\nfbpr_a = rmem->base;\r\nfbpr_sz = rmem->size;\r\nWARN_ON(!(fbpr_a && fbpr_sz));\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bman_isr(int irq, void *ptr)\r\n{\r\nu32 isr_val, ier_val, ecsr_val, isr_mask, i;\r\nstruct device *dev = ptr;\r\nier_val = bm_ccsr_in(REG_ERR_IER);\r\nisr_val = bm_ccsr_in(REG_ERR_ISR);\r\necsr_val = bm_ccsr_in(REG_ECSR);\r\nisr_mask = isr_val & ier_val;\r\nif (!isr_mask)\r\nreturn IRQ_NONE;\r\nfor (i = 0; i < ARRAY_SIZE(bman_hwerr_txts); i++) {\r\nif (bman_hwerr_txts[i].mask & isr_mask) {\r\ndev_err_ratelimited(dev, "ErrInt: %s\n",\r\nbman_hwerr_txts[i].txt);\r\nif (bman_hwerr_txts[i].mask & ecsr_val) {\r\nbm_ccsr_out(REG_ECSR, ecsr_val);\r\n}\r\nif (bman_hwerr_txts[i].mask & BMAN_ERRS_TO_DISABLE) {\r\ndev_dbg(dev, "Disabling error 0x%x\n",\r\nbman_hwerr_txts[i].mask);\r\nier_val &= ~bman_hwerr_txts[i].mask;\r\nbm_ccsr_out(REG_ERR_IER, ier_val);\r\n}\r\n}\r\n}\r\nbm_ccsr_out(REG_ERR_ISR, isr_val);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_bman_probe(struct platform_device *pdev)\r\n{\r\nint ret, err_irq;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource *res;\r\nu16 id, bm_pool_cnt;\r\nu8 major, minor;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "Can't get %s property 'IORESOURCE_MEM'\n",\r\nnode->full_name);\r\nreturn -ENXIO;\r\n}\r\nbm_ccsr_start = devm_ioremap(dev, res->start, resource_size(res));\r\nif (!bm_ccsr_start)\r\nreturn -ENXIO;\r\nbm_get_version(&id, &major, &minor);\r\nif (major == 1 && minor == 0) {\r\nbman_ip_rev = BMAN_REV10;\r\nbm_pool_cnt = BM_POOL_MAX;\r\n} else if (major == 2 && minor == 0) {\r\nbman_ip_rev = BMAN_REV20;\r\nbm_pool_cnt = 8;\r\n} else if (major == 2 && minor == 1) {\r\nbman_ip_rev = BMAN_REV21;\r\nbm_pool_cnt = BM_POOL_MAX;\r\n} else {\r\ndev_err(dev, "Unknown Bman version:%04x,%02x,%02x\n",\r\nid, major, minor);\r\nreturn -ENODEV;\r\n}\r\nbm_set_memory(fbpr_a, fbpr_sz);\r\nerr_irq = platform_get_irq(pdev, 0);\r\nif (err_irq <= 0) {\r\ndev_info(dev, "Can't get %s IRQ\n", node->full_name);\r\nreturn -ENODEV;\r\n}\r\nret = devm_request_irq(dev, err_irq, bman_isr, IRQF_SHARED, "bman-err",\r\ndev);\r\nif (ret) {\r\ndev_err(dev, "devm_request_irq() failed %d for '%s'\n",\r\nret, node->full_name);\r\nreturn ret;\r\n}\r\nbm_ccsr_out(REG_ERR_ISDR, BM_EIRQ_BSCN);\r\nbm_ccsr_out(REG_ERR_ISR, 0xffffffff);\r\nbm_ccsr_out(REG_ERR_IER, 0xffffffff);\r\nbm_bpalloc = devm_gen_pool_create(dev, 0, -1, "bman-bpalloc");\r\nif (IS_ERR(bm_bpalloc)) {\r\nret = PTR_ERR(bm_bpalloc);\r\ndev_err(dev, "bman-bpalloc pool init failed (%d)\n", ret);\r\nreturn ret;\r\n}\r\nret = gen_pool_add(bm_bpalloc, DPAA_GENALLOC_OFF, bm_pool_cnt, -1);\r\nif (ret) {\r\ndev_err(dev, "Failed to seed BPID range [%d..%d] (%d)\n",\r\n0, bm_pool_cnt - 1, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
