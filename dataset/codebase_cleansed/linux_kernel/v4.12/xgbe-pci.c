static int xgbe_config_multi_msi(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int vector_count;\r\nunsigned int i, j;\r\nint ret;\r\nvector_count = XGBE_MSI_BASE_COUNT;\r\nvector_count += max(pdata->rx_ring_count,\r\npdata->tx_ring_count);\r\nret = pci_alloc_irq_vectors(pdata->pcidev, XGBE_MSI_MIN_COUNT,\r\nvector_count, PCI_IRQ_MSI | PCI_IRQ_MSIX);\r\nif (ret < 0) {\r\ndev_info(pdata->dev, "multi MSI/MSI-X enablement failed\n");\r\nreturn ret;\r\n}\r\npdata->irq_count = ret;\r\npdata->dev_irq = pci_irq_vector(pdata->pcidev, 0);\r\npdata->ecc_irq = pci_irq_vector(pdata->pcidev, 1);\r\npdata->i2c_irq = pci_irq_vector(pdata->pcidev, 2);\r\npdata->an_irq = pci_irq_vector(pdata->pcidev, 3);\r\nfor (i = XGBE_MSI_BASE_COUNT, j = 0; i < ret; i++, j++)\r\npdata->channel_irq[j] = pci_irq_vector(pdata->pcidev, i);\r\npdata->channel_irq_count = j;\r\npdata->per_channel_irq = 1;\r\npdata->channel_irq_mode = XGBE_IRQ_MODE_LEVEL;\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(pdata->dev, "multi %s interrupts enabled\n",\r\npdata->pcidev->msix_enabled ? "MSI-X" : "MSI");\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_irqs(struct xgbe_prv_data *pdata)\r\n{\r\nint ret;\r\nret = xgbe_config_multi_msi(pdata);\r\nif (!ret)\r\ngoto out;\r\nret = pci_alloc_irq_vectors(pdata->pcidev, 1, 1,\r\nPCI_IRQ_LEGACY | PCI_IRQ_MSI);\r\nif (ret < 0) {\r\ndev_info(pdata->dev, "single IRQ enablement failed\n");\r\nreturn ret;\r\n}\r\npdata->irq_count = 1;\r\npdata->channel_irq_count = 1;\r\npdata->dev_irq = pci_irq_vector(pdata->pcidev, 0);\r\npdata->ecc_irq = pci_irq_vector(pdata->pcidev, 0);\r\npdata->i2c_irq = pci_irq_vector(pdata->pcidev, 0);\r\npdata->an_irq = pci_irq_vector(pdata->pcidev, 0);\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(pdata->dev, "single %s interrupt enabled\n",\r\npdata->pcidev->msi_enabled ? "MSI" : "legacy");\r\nout:\r\nif (netif_msg_probe(pdata)) {\r\nunsigned int i;\r\ndev_dbg(pdata->dev, " dev irq=%d\n", pdata->dev_irq);\r\ndev_dbg(pdata->dev, " ecc irq=%d\n", pdata->ecc_irq);\r\ndev_dbg(pdata->dev, " i2c irq=%d\n", pdata->i2c_irq);\r\ndev_dbg(pdata->dev, " an irq=%d\n", pdata->an_irq);\r\nfor (i = 0; i < pdata->channel_irq_count; i++)\r\ndev_dbg(pdata->dev, " dma%u irq=%d\n",\r\ni, pdata->channel_irq[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\r\n{\r\nstruct xgbe_prv_data *pdata;\r\nstruct device *dev = &pdev->dev;\r\nvoid __iomem * const *iomap_table;\r\nstruct pci_dev *rdev;\r\nunsigned int ma_lo, ma_hi;\r\nunsigned int reg;\r\nint bar_mask;\r\nint ret;\r\npdata = xgbe_alloc_pdata(dev);\r\nif (IS_ERR(pdata)) {\r\nret = PTR_ERR(pdata);\r\ngoto err_alloc;\r\n}\r\npdata->pcidev = pdev;\r\npci_set_drvdata(pdev, pdata);\r\npdata->vdata = (struct xgbe_version_data *)id->driver_data;\r\nret = pcim_enable_device(pdev);\r\nif (ret) {\r\ndev_err(dev, "pcim_enable_device failed\n");\r\ngoto err_pci_enable;\r\n}\r\nbar_mask = pci_select_bars(pdev, IORESOURCE_MEM);\r\nret = pcim_iomap_regions(pdev, bar_mask, XGBE_DRV_NAME);\r\nif (ret) {\r\ndev_err(dev, "pcim_iomap_regions failed\n");\r\ngoto err_pci_enable;\r\n}\r\niomap_table = pcim_iomap_table(pdev);\r\nif (!iomap_table) {\r\ndev_err(dev, "pcim_iomap_table failed\n");\r\nret = -ENOMEM;\r\ngoto err_pci_enable;\r\n}\r\npdata->xgmac_regs = iomap_table[XGBE_XGMAC_BAR];\r\nif (!pdata->xgmac_regs) {\r\ndev_err(dev, "xgmac ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_pci_enable;\r\n}\r\npdata->xprop_regs = pdata->xgmac_regs + XGBE_MAC_PROP_OFFSET;\r\npdata->xi2c_regs = pdata->xgmac_regs + XGBE_I2C_CTRL_OFFSET;\r\nif (netif_msg_probe(pdata)) {\r\ndev_dbg(dev, "xgmac_regs = %p\n", pdata->xgmac_regs);\r\ndev_dbg(dev, "xprop_regs = %p\n", pdata->xprop_regs);\r\ndev_dbg(dev, "xi2c_regs = %p\n", pdata->xi2c_regs);\r\n}\r\npdata->xpcs_regs = iomap_table[XGBE_XPCS_BAR];\r\nif (!pdata->xpcs_regs) {\r\ndev_err(dev, "xpcs ioremap failed\n");\r\nret = -ENOMEM;\r\ngoto err_pci_enable;\r\n}\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "xpcs_regs = %p\n", pdata->xpcs_regs);\r\nrdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(0, 0));\r\nif (rdev &&\r\n(rdev->vendor == PCI_VENDOR_ID_AMD) && (rdev->device == 0x15d0)) {\r\npdata->xpcs_window_def_reg = PCS_V2_RV_WINDOW_DEF;\r\npdata->xpcs_window_sel_reg = PCS_V2_RV_WINDOW_SELECT;\r\n} else {\r\npdata->xpcs_window_def_reg = PCS_V2_WINDOW_DEF;\r\npdata->xpcs_window_sel_reg = PCS_V2_WINDOW_SELECT;\r\n}\r\npci_dev_put(rdev);\r\nreg = XPCS32_IOREAD(pdata, pdata->xpcs_window_def_reg);\r\npdata->xpcs_window = XPCS_GET_BITS(reg, PCS_V2_WINDOW_DEF, OFFSET);\r\npdata->xpcs_window <<= 6;\r\npdata->xpcs_window_size = XPCS_GET_BITS(reg, PCS_V2_WINDOW_DEF, SIZE);\r\npdata->xpcs_window_size = 1 << (pdata->xpcs_window_size + 7);\r\npdata->xpcs_window_mask = pdata->xpcs_window_size - 1;\r\nif (netif_msg_probe(pdata)) {\r\ndev_dbg(dev, "xpcs window = %#010x\n",\r\npdata->xpcs_window);\r\ndev_dbg(dev, "xpcs window size = %#010x\n",\r\npdata->xpcs_window_size);\r\ndev_dbg(dev, "xpcs window mask = %#010x\n",\r\npdata->xpcs_window_mask);\r\n}\r\npci_set_master(pdev);\r\nXP_IOWRITE(pdata, XP_INT_EN, 0x1fffff);\r\nma_lo = XP_IOREAD(pdata, XP_MAC_ADDR_LO);\r\nma_hi = XP_IOREAD(pdata, XP_MAC_ADDR_HI);\r\npdata->mac_addr[0] = ma_lo & 0xff;\r\npdata->mac_addr[1] = (ma_lo >> 8) & 0xff;\r\npdata->mac_addr[2] = (ma_lo >> 16) & 0xff;\r\npdata->mac_addr[3] = (ma_lo >> 24) & 0xff;\r\npdata->mac_addr[4] = ma_hi & 0xff;\r\npdata->mac_addr[5] = (ma_hi >> 8) & 0xff;\r\nif (!XP_GET_BITS(ma_hi, XP_MAC_ADDR_HI, VALID) ||\r\n!is_valid_ether_addr(pdata->mac_addr)) {\r\ndev_err(dev, "invalid mac address\n");\r\nret = -EINVAL;\r\ngoto err_pci_enable;\r\n}\r\npdata->sysclk_rate = XGBE_V2_DMA_CLOCK_FREQ;\r\npdata->ptpclk_rate = XGBE_V2_PTP_CLOCK_FREQ;\r\npdata->coherent = 1;\r\npdata->axdomain = XGBE_DMA_OS_AXDOMAIN;\r\npdata->arcache = XGBE_DMA_OS_ARCACHE;\r\npdata->awcache = XGBE_DMA_OS_AWCACHE;\r\nreg = XP_IOREAD(pdata, XP_PROP_1);\r\npdata->tx_max_channel_count = XP_GET_BITS(reg, XP_PROP_1, MAX_TX_DMA);\r\npdata->rx_max_channel_count = XP_GET_BITS(reg, XP_PROP_1, MAX_RX_DMA);\r\npdata->tx_max_q_count = XP_GET_BITS(reg, XP_PROP_1, MAX_TX_QUEUES);\r\npdata->rx_max_q_count = XP_GET_BITS(reg, XP_PROP_1, MAX_RX_QUEUES);\r\nif (netif_msg_probe(pdata)) {\r\ndev_dbg(dev, "max tx/rx channel count = %u/%u\n",\r\npdata->tx_max_channel_count,\r\npdata->tx_max_channel_count);\r\ndev_dbg(dev, "max tx/rx hw queue count = %u/%u\n",\r\npdata->tx_max_q_count, pdata->rx_max_q_count);\r\n}\r\nxgbe_set_counts(pdata);\r\nreg = XP_IOREAD(pdata, XP_PROP_2);\r\npdata->tx_max_fifo_size = XP_GET_BITS(reg, XP_PROP_2, TX_FIFO_SIZE);\r\npdata->tx_max_fifo_size *= 16384;\r\npdata->tx_max_fifo_size = min(pdata->tx_max_fifo_size,\r\npdata->vdata->tx_max_fifo_size);\r\npdata->rx_max_fifo_size = XP_GET_BITS(reg, XP_PROP_2, RX_FIFO_SIZE);\r\npdata->rx_max_fifo_size *= 16384;\r\npdata->rx_max_fifo_size = min(pdata->rx_max_fifo_size,\r\npdata->vdata->rx_max_fifo_size);\r\nif (netif_msg_probe(pdata))\r\ndev_dbg(dev, "max tx/rx max fifo size = %u/%u\n",\r\npdata->tx_max_fifo_size, pdata->rx_max_fifo_size);\r\nret = xgbe_config_irqs(pdata);\r\nif (ret)\r\ngoto err_pci_enable;\r\nret = xgbe_config_netdev(pdata);\r\nif (ret)\r\ngoto err_irq_vectors;\r\nnetdev_notice(pdata->netdev, "net device enabled\n");\r\nreturn 0;\r\nerr_irq_vectors:\r\npci_free_irq_vectors(pdata->pcidev);\r\nerr_pci_enable:\r\nxgbe_free_pdata(pdata);\r\nerr_alloc:\r\ndev_notice(dev, "net device not enabled\n");\r\nreturn ret;\r\n}\r\nstatic void xgbe_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct xgbe_prv_data *pdata = pci_get_drvdata(pdev);\r\nxgbe_deconfig_netdev(pdata);\r\npci_free_irq_vectors(pdata->pcidev);\r\nxgbe_free_pdata(pdata);\r\n}\r\nstatic int xgbe_pci_suspend(struct pci_dev *pdev, pm_message_t state)\r\n{\r\nstruct xgbe_prv_data *pdata = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = pdata->netdev;\r\nint ret = 0;\r\nif (netif_running(netdev))\r\nret = xgbe_powerdown(netdev, XGMAC_DRIVER_CONTEXT);\r\npdata->lpm_ctrl = XMDIO_READ(pdata, MDIO_MMD_PCS, MDIO_CTRL1);\r\npdata->lpm_ctrl |= MDIO_CTRL1_LPOWER;\r\nXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\r\nreturn ret;\r\n}\r\nstatic int xgbe_pci_resume(struct pci_dev *pdev)\r\n{\r\nstruct xgbe_prv_data *pdata = pci_get_drvdata(pdev);\r\nstruct net_device *netdev = pdata->netdev;\r\nint ret = 0;\r\npdata->lpm_ctrl &= ~MDIO_CTRL1_LPOWER;\r\nXMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata->lpm_ctrl);\r\nif (netif_running(netdev)) {\r\nret = xgbe_powerup(netdev, XGMAC_DRIVER_CONTEXT);\r\nschedule_work(&pdata->restart_work);\r\n}\r\nreturn ret;\r\n}\r\nint xgbe_pci_init(void)\r\n{\r\nreturn pci_register_driver(&xgbe_driver);\r\n}\r\nvoid xgbe_pci_exit(void)\r\n{\r\npci_unregister_driver(&xgbe_driver);\r\n}
