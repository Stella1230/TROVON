static void rsa_io_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\ndma_unmap_sg(dev, req->dst, edesc->dst_nents, DMA_FROM_DEVICE);\r\ndma_unmap_sg(dev, req->src, edesc->src_nents, DMA_TO_DEVICE);\r\nif (edesc->sec4_sg_bytes)\r\ndma_unmap_single(dev, edesc->sec4_sg_dma, edesc->sec4_sg_bytes,\r\nDMA_TO_DEVICE);\r\n}\r\nstatic void rsa_pub_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct rsa_pub_pdb *pdb = &edesc->pdb.pub;\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->e_dma, key->e_sz, DMA_TO_DEVICE);\r\n}\r\nstatic void rsa_priv_f1_unmap(struct device *dev, struct rsa_edesc *edesc,\r\nstruct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct rsa_priv_f1_pdb *pdb = &edesc->pdb.priv_f1;\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\ndma_unmap_single(dev, pdb->d_dma, key->d_sz, DMA_TO_DEVICE);\r\n}\r\nstatic void rsa_pub_done(struct device *dev, u32 *desc, u32 err, void *context)\r\n{\r\nstruct akcipher_request *req = context;\r\nstruct rsa_edesc *edesc;\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nedesc = container_of(desc, struct rsa_edesc, hw_desc[0]);\r\nrsa_pub_unmap(dev, edesc, req);\r\nrsa_io_unmap(dev, edesc, req);\r\nkfree(edesc);\r\nakcipher_request_complete(req, err);\r\n}\r\nstatic void rsa_priv_f1_done(struct device *dev, u32 *desc, u32 err,\r\nvoid *context)\r\n{\r\nstruct akcipher_request *req = context;\r\nstruct rsa_edesc *edesc;\r\nif (err)\r\ncaam_jr_strstatus(dev, err);\r\nedesc = container_of(desc, struct rsa_edesc, hw_desc[0]);\r\nrsa_priv_f1_unmap(dev, edesc, req);\r\nrsa_io_unmap(dev, edesc, req);\r\nkfree(edesc);\r\nakcipher_request_complete(req, err);\r\n}\r\nstatic struct rsa_edesc *rsa_edesc_alloc(struct akcipher_request *req,\r\nsize_t desclen)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\ngfp_t flags = (req->base.flags & (CRYPTO_TFM_REQ_MAY_BACKLOG |\r\nCRYPTO_TFM_REQ_MAY_SLEEP)) ? GFP_KERNEL : GFP_ATOMIC;\r\nint sgc;\r\nint sec4_sg_index, sec4_sg_len = 0, sec4_sg_bytes;\r\nint src_nents, dst_nents;\r\nsrc_nents = sg_nents_for_len(req->src, req->src_len);\r\ndst_nents = sg_nents_for_len(req->dst, req->dst_len);\r\nif (src_nents > 1)\r\nsec4_sg_len = src_nents;\r\nif (dst_nents > 1)\r\nsec4_sg_len += dst_nents;\r\nsec4_sg_bytes = sec4_sg_len * sizeof(struct sec4_sg_entry);\r\nedesc = kzalloc(sizeof(*edesc) + desclen + sec4_sg_bytes,\r\nGFP_DMA | flags);\r\nif (!edesc)\r\nreturn ERR_PTR(-ENOMEM);\r\nsgc = dma_map_sg(dev, req->src, src_nents, DMA_TO_DEVICE);\r\nif (unlikely(!sgc)) {\r\ndev_err(dev, "unable to map source\n");\r\ngoto src_fail;\r\n}\r\nsgc = dma_map_sg(dev, req->dst, dst_nents, DMA_FROM_DEVICE);\r\nif (unlikely(!sgc)) {\r\ndev_err(dev, "unable to map destination\n");\r\ngoto dst_fail;\r\n}\r\nedesc->sec4_sg = (void *)edesc + sizeof(*edesc) + desclen;\r\nsec4_sg_index = 0;\r\nif (src_nents > 1) {\r\nsg_to_sec4_sg_last(req->src, src_nents, edesc->sec4_sg, 0);\r\nsec4_sg_index += src_nents;\r\n}\r\nif (dst_nents > 1)\r\nsg_to_sec4_sg_last(req->dst, dst_nents,\r\nedesc->sec4_sg + sec4_sg_index, 0);\r\nedesc->src_nents = src_nents;\r\nedesc->dst_nents = dst_nents;\r\nif (!sec4_sg_bytes)\r\nreturn edesc;\r\nedesc->sec4_sg_dma = dma_map_single(dev, edesc->sec4_sg,\r\nsec4_sg_bytes, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, edesc->sec4_sg_dma)) {\r\ndev_err(dev, "unable to map S/G table\n");\r\ngoto sec4_sg_fail;\r\n}\r\nedesc->sec4_sg_bytes = sec4_sg_bytes;\r\nreturn edesc;\r\nsec4_sg_fail:\r\ndma_unmap_sg(dev, req->dst, dst_nents, DMA_FROM_DEVICE);\r\ndst_fail:\r\ndma_unmap_sg(dev, req->src, src_nents, DMA_TO_DEVICE);\r\nsrc_fail:\r\nkfree(edesc);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nstatic int set_rsa_pub_pdb(struct akcipher_request *req,\r\nstruct rsa_edesc *edesc)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_pub_pdb *pdb = &edesc->pdb.pub;\r\nint sec4_sg_index = 0;\r\npdb->n_dma = dma_map_single(dev, key->n, key->n_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->n_dma)) {\r\ndev_err(dev, "Unable to map RSA modulus memory\n");\r\nreturn -ENOMEM;\r\n}\r\npdb->e_dma = dma_map_single(dev, key->e, key->e_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->e_dma)) {\r\ndev_err(dev, "Unable to map RSA public exponent memory\n");\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nif (edesc->src_nents > 1) {\r\npdb->sgf |= RSA_PDB_SGF_F;\r\npdb->f_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\n} else {\r\npdb->f_dma = sg_dma_address(req->src);\r\n}\r\nif (edesc->dst_nents > 1) {\r\npdb->sgf |= RSA_PDB_SGF_G;\r\npdb->g_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\n} else {\r\npdb->g_dma = sg_dma_address(req->dst);\r\n}\r\npdb->sgf |= (key->e_sz << RSA_PDB_E_SHIFT) | key->n_sz;\r\npdb->f_len = req->src_len;\r\nreturn 0;\r\n}\r\nstatic int set_rsa_priv_f1_pdb(struct akcipher_request *req,\r\nstruct rsa_edesc *edesc)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *dev = ctx->dev;\r\nstruct rsa_priv_f1_pdb *pdb = &edesc->pdb.priv_f1;\r\nint sec4_sg_index = 0;\r\npdb->n_dma = dma_map_single(dev, key->n, key->n_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->n_dma)) {\r\ndev_err(dev, "Unable to map modulus memory\n");\r\nreturn -ENOMEM;\r\n}\r\npdb->d_dma = dma_map_single(dev, key->d, key->d_sz, DMA_TO_DEVICE);\r\nif (dma_mapping_error(dev, pdb->d_dma)) {\r\ndev_err(dev, "Unable to map RSA private exponent memory\n");\r\ndma_unmap_single(dev, pdb->n_dma, key->n_sz, DMA_TO_DEVICE);\r\nreturn -ENOMEM;\r\n}\r\nif (edesc->src_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_G;\r\npdb->g_dma = edesc->sec4_sg_dma;\r\nsec4_sg_index += edesc->src_nents;\r\n} else {\r\npdb->g_dma = sg_dma_address(req->src);\r\n}\r\nif (edesc->dst_nents > 1) {\r\npdb->sgf |= RSA_PRIV_PDB_SGF_F;\r\npdb->f_dma = edesc->sec4_sg_dma +\r\nsec4_sg_index * sizeof(struct sec4_sg_entry);\r\n} else {\r\npdb->f_dma = sg_dma_address(req->dst);\r\n}\r\npdb->sgf |= (key->d_sz << RSA_PDB_D_SHIFT) | key->n_sz;\r\nreturn 0;\r\n}\r\nstatic int caam_rsa_enc(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *jrdev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\nint ret;\r\nif (unlikely(!key->n || !key->e))\r\nreturn -EINVAL;\r\nif (req->dst_len < key->n_sz) {\r\nreq->dst_len = key->n_sz;\r\ndev_err(jrdev, "Output buffer length less than parameter n\n");\r\nreturn -EOVERFLOW;\r\n}\r\nedesc = rsa_edesc_alloc(req, DESC_RSA_PUB_LEN);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\nret = set_rsa_pub_pdb(req, edesc);\r\nif (ret)\r\ngoto init_fail;\r\ninit_rsa_pub_desc(edesc->hw_desc, &edesc->pdb.pub);\r\nret = caam_jr_enqueue(jrdev, edesc->hw_desc, rsa_pub_done, req);\r\nif (!ret)\r\nreturn -EINPROGRESS;\r\nrsa_pub_unmap(jrdev, edesc, req);\r\ninit_fail:\r\nrsa_io_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nreturn ret;\r\n}\r\nstatic int caam_rsa_dec(struct akcipher_request *req)\r\n{\r\nstruct crypto_akcipher *tfm = crypto_akcipher_reqtfm(req);\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nstruct device *jrdev = ctx->dev;\r\nstruct rsa_edesc *edesc;\r\nint ret;\r\nif (unlikely(!key->n || !key->d))\r\nreturn -EINVAL;\r\nif (req->dst_len < key->n_sz) {\r\nreq->dst_len = key->n_sz;\r\ndev_err(jrdev, "Output buffer length less than parameter n\n");\r\nreturn -EOVERFLOW;\r\n}\r\nedesc = rsa_edesc_alloc(req, DESC_RSA_PRIV_F1_LEN);\r\nif (IS_ERR(edesc))\r\nreturn PTR_ERR(edesc);\r\nret = set_rsa_priv_f1_pdb(req, edesc);\r\nif (ret)\r\ngoto init_fail;\r\ninit_rsa_priv_f1_desc(edesc->hw_desc, &edesc->pdb.priv_f1);\r\nret = caam_jr_enqueue(jrdev, edesc->hw_desc, rsa_priv_f1_done, req);\r\nif (!ret)\r\nreturn -EINPROGRESS;\r\nrsa_priv_f1_unmap(jrdev, edesc, req);\r\ninit_fail:\r\nrsa_io_unmap(jrdev, edesc, req);\r\nkfree(edesc);\r\nreturn ret;\r\n}\r\nstatic void caam_rsa_free_key(struct caam_rsa_key *key)\r\n{\r\nkzfree(key->d);\r\nkfree(key->e);\r\nkfree(key->n);\r\nkey->d = NULL;\r\nkey->e = NULL;\r\nkey->n = NULL;\r\nkey->d_sz = 0;\r\nkey->e_sz = 0;\r\nkey->n_sz = 0;\r\n}\r\nstatic inline u8 *caam_read_raw_data(const u8 *buf, size_t *nbytes)\r\n{\r\nu8 *val;\r\nwhile (!*buf && *nbytes) {\r\nbuf++;\r\n(*nbytes)--;\r\n}\r\nval = kzalloc(*nbytes, GFP_DMA | GFP_KERNEL);\r\nif (!val)\r\nreturn NULL;\r\nmemcpy(val, buf, *nbytes);\r\nreturn val;\r\n}\r\nstatic int caam_rsa_check_key_length(unsigned int len)\r\n{\r\nif (len > 4096)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int caam_rsa_set_pub_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct rsa_key raw_key = {NULL};\r\nstruct caam_rsa_key *rsa_key = &ctx->key;\r\nint ret;\r\ncaam_rsa_free_key(rsa_key);\r\nret = rsa_parse_pub_key(&raw_key, key, keylen);\r\nif (ret)\r\nreturn ret;\r\nrsa_key->e = kzalloc(raw_key.e_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->e)\r\ngoto err;\r\nrsa_key->n = caam_read_raw_data(raw_key.n, &raw_key.n_sz);\r\nif (!rsa_key->n)\r\ngoto err;\r\nif (caam_rsa_check_key_length(raw_key.n_sz << 3)) {\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -EINVAL;\r\n}\r\nrsa_key->e_sz = raw_key.e_sz;\r\nrsa_key->n_sz = raw_key.n_sz;\r\nmemcpy(rsa_key->e, raw_key.e, raw_key.e_sz);\r\nreturn 0;\r\nerr:\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -ENOMEM;\r\n}\r\nstatic int caam_rsa_set_priv_key(struct crypto_akcipher *tfm, const void *key,\r\nunsigned int keylen)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct rsa_key raw_key = {NULL};\r\nstruct caam_rsa_key *rsa_key = &ctx->key;\r\nint ret;\r\ncaam_rsa_free_key(rsa_key);\r\nret = rsa_parse_priv_key(&raw_key, key, keylen);\r\nif (ret)\r\nreturn ret;\r\nrsa_key->d = kzalloc(raw_key.d_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->d)\r\ngoto err;\r\nrsa_key->e = kzalloc(raw_key.e_sz, GFP_DMA | GFP_KERNEL);\r\nif (!rsa_key->e)\r\ngoto err;\r\nrsa_key->n = caam_read_raw_data(raw_key.n, &raw_key.n_sz);\r\nif (!rsa_key->n)\r\ngoto err;\r\nif (caam_rsa_check_key_length(raw_key.n_sz << 3)) {\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -EINVAL;\r\n}\r\nrsa_key->d_sz = raw_key.d_sz;\r\nrsa_key->e_sz = raw_key.e_sz;\r\nrsa_key->n_sz = raw_key.n_sz;\r\nmemcpy(rsa_key->d, raw_key.d, raw_key.d_sz);\r\nmemcpy(rsa_key->e, raw_key.e, raw_key.e_sz);\r\nreturn 0;\r\nerr:\r\ncaam_rsa_free_key(rsa_key);\r\nreturn -ENOMEM;\r\n}\r\nstatic int caam_rsa_max_size(struct crypto_akcipher *tfm)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\nreturn (key->n) ? key->n_sz : -EINVAL;\r\n}\r\nstatic int caam_rsa_init_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nctx->dev = caam_jr_alloc();\r\nif (IS_ERR(ctx->dev)) {\r\npr_err("Job Ring Device allocation for transform failed\n");\r\nreturn PTR_ERR(ctx->dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void caam_rsa_exit_tfm(struct crypto_akcipher *tfm)\r\n{\r\nstruct caam_rsa_ctx *ctx = akcipher_tfm_ctx(tfm);\r\nstruct caam_rsa_key *key = &ctx->key;\r\ncaam_rsa_free_key(key);\r\ncaam_jr_free(ctx->dev);\r\n}\r\nstatic int __init caam_pkc_init(void)\r\n{\r\nstruct device_node *dev_node;\r\nstruct platform_device *pdev;\r\nstruct device *ctrldev;\r\nstruct caam_drv_private *priv;\r\nu32 cha_inst, pk_inst;\r\nint err;\r\ndev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");\r\nif (!dev_node) {\r\ndev_node = of_find_compatible_node(NULL, NULL, "fsl,sec4.0");\r\nif (!dev_node)\r\nreturn -ENODEV;\r\n}\r\npdev = of_find_device_by_node(dev_node);\r\nif (!pdev) {\r\nof_node_put(dev_node);\r\nreturn -ENODEV;\r\n}\r\nctrldev = &pdev->dev;\r\npriv = dev_get_drvdata(ctrldev);\r\nof_node_put(dev_node);\r\nif (!priv)\r\nreturn -ENODEV;\r\ncha_inst = rd_reg32(&priv->ctrl->perfmon.cha_num_ls);\r\npk_inst = (cha_inst & CHA_ID_LS_PK_MASK) >> CHA_ID_LS_PK_SHIFT;\r\nif (!pk_inst)\r\nreturn -ENODEV;\r\nerr = crypto_register_akcipher(&caam_rsa);\r\nif (err)\r\ndev_warn(ctrldev, "%s alg registration failed\n",\r\ncaam_rsa.base.cra_driver_name);\r\nelse\r\ndev_info(ctrldev, "caam pkc algorithms registered in /proc/crypto\n");\r\nreturn err;\r\n}\r\nstatic void __exit caam_pkc_exit(void)\r\n{\r\ncrypto_unregister_akcipher(&caam_rsa);\r\n}
