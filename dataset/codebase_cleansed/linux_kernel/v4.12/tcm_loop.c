static int tcm_loop_check_stop_free(struct se_cmd *se_cmd)\r\n{\r\nif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB)\r\nreturn 0;\r\ntransport_generic_free_cmd(se_cmd, 0);\r\nreturn 1;\r\n}\r\nstatic void tcm_loop_release_cmd(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\r\n}\r\nstatic int tcm_loop_show_info(struct seq_file *m, struct Scsi_Host *host)\r\n{\r\nseq_printf(m, "tcm_loop_proc_info()\n");\r\nreturn 0;\r\n}\r\nstatic int pseudo_lld_bus_match(struct device *dev,\r\nstruct device_driver *dev_driver)\r\n{\r\nreturn 1;\r\n}\r\nstatic void tcm_loop_submission_work(struct work_struct *work)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd =\r\ncontainer_of(work, struct tcm_loop_cmd, work);\r\nstruct se_cmd *se_cmd = &tl_cmd->tl_se_cmd;\r\nstruct scsi_cmnd *sc = tl_cmd->sc;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\nstruct scatterlist *sgl_bidi = NULL;\r\nu32 sgl_bidi_count = 0, transfer_length;\r\nint rc;\r\ntl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\r\ntl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\r\nif (!tl_tpg->tl_hba) {\r\nset_host_byte(sc, DID_NO_CONNECT);\r\ngoto out_done;\r\n}\r\nif (tl_tpg->tl_transport_status == TCM_TRANSPORT_OFFLINE) {\r\nset_host_byte(sc, DID_TRANSPORT_DISRUPTED);\r\ngoto out_done;\r\n}\r\ntl_nexus = tl_tpg->tl_nexus;\r\nif (!tl_nexus) {\r\nscmd_printk(KERN_ERR, sc, "TCM_Loop I_T Nexus"\r\n" does not exist\n");\r\nset_host_byte(sc, DID_ERROR);\r\ngoto out_done;\r\n}\r\nif (scsi_bidi_cmnd(sc)) {\r\nstruct scsi_data_buffer *sdb = scsi_in(sc);\r\nsgl_bidi = sdb->table.sgl;\r\nsgl_bidi_count = sdb->table.nents;\r\nse_cmd->se_cmd_flags |= SCF_BIDI;\r\n}\r\ntransfer_length = scsi_transfer_length(sc);\r\nif (!scsi_prot_sg_count(sc) &&\r\nscsi_get_prot_op(sc) != SCSI_PROT_NORMAL) {\r\nse_cmd->prot_pto = true;\r\ntransfer_length = scsi_bufflen(sc);\r\n}\r\nse_cmd->tag = tl_cmd->sc_cmd_tag;\r\nrc = target_submit_cmd_map_sgls(se_cmd, tl_nexus->se_sess, sc->cmnd,\r\n&tl_cmd->tl_sense_buf[0], tl_cmd->sc->device->lun,\r\ntransfer_length, TCM_SIMPLE_TAG,\r\nsc->sc_data_direction, 0,\r\nscsi_sglist(sc), scsi_sg_count(sc),\r\nsgl_bidi, sgl_bidi_count,\r\nscsi_prot_sglist(sc), scsi_prot_sg_count(sc));\r\nif (rc < 0) {\r\nset_host_byte(sc, DID_NO_CONNECT);\r\ngoto out_done;\r\n}\r\nreturn;\r\nout_done:\r\nkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\r\nsc->scsi_done(sc);\r\nreturn;\r\n}\r\nstatic int tcm_loop_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *sc)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd;\r\npr_debug("tcm_loop_queuecommand() %d:%d:%d:%llu got CDB: 0x%02x"\r\n" scsi_buf_len: %u\n", sc->device->host->host_no,\r\nsc->device->id, sc->device->channel, sc->device->lun,\r\nsc->cmnd[0], scsi_bufflen(sc));\r\ntl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_ATOMIC);\r\nif (!tl_cmd) {\r\npr_err("Unable to allocate struct tcm_loop_cmd\n");\r\nset_host_byte(sc, DID_ERROR);\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\ntl_cmd->sc = sc;\r\ntl_cmd->sc_cmd_tag = sc->request->tag;\r\nINIT_WORK(&tl_cmd->work, tcm_loop_submission_work);\r\nqueue_work(tcm_loop_workqueue, &tl_cmd->work);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_issue_tmr(struct tcm_loop_tpg *tl_tpg,\r\nu64 lun, int task, enum tcm_tmreq_table tmr)\r\n{\r\nstruct se_cmd *se_cmd = NULL;\r\nstruct se_session *se_sess;\r\nstruct se_portal_group *se_tpg;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nstruct tcm_loop_cmd *tl_cmd = NULL;\r\nstruct tcm_loop_tmr *tl_tmr = NULL;\r\nint ret = TMR_FUNCTION_FAILED, rc;\r\ntl_nexus = tl_tpg->tl_nexus;\r\nif (!tl_nexus) {\r\npr_err("Unable to perform device reset without"\r\n" active I_T Nexus\n");\r\nreturn ret;\r\n}\r\ntl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);\r\nif (!tl_cmd) {\r\npr_err("Unable to allocate memory for tl_cmd\n");\r\nreturn ret;\r\n}\r\ntl_tmr = kzalloc(sizeof(struct tcm_loop_tmr), GFP_KERNEL);\r\nif (!tl_tmr) {\r\npr_err("Unable to allocate memory for tl_tmr\n");\r\ngoto release;\r\n}\r\ninit_waitqueue_head(&tl_tmr->tl_tmr_wait);\r\nse_cmd = &tl_cmd->tl_se_cmd;\r\nse_tpg = &tl_tpg->tl_se_tpg;\r\nse_sess = tl_tpg->tl_nexus->se_sess;\r\ntransport_init_se_cmd(se_cmd, se_tpg->se_tpg_tfo, se_sess, 0,\r\nDMA_NONE, TCM_SIMPLE_TAG,\r\n&tl_cmd->tl_sense_buf[0]);\r\nrc = core_tmr_alloc_req(se_cmd, tl_tmr, tmr, GFP_KERNEL);\r\nif (rc < 0)\r\ngoto release;\r\nif (tmr == TMR_ABORT_TASK)\r\nse_cmd->se_tmr_req->ref_task_tag = task;\r\nif (transport_lookup_tmr_lun(se_cmd, lun) < 0) {\r\nret = TMR_LUN_DOES_NOT_EXIST;\r\ngoto release;\r\n}\r\ntransport_generic_handle_tmr(se_cmd);\r\nwait_event(tl_tmr->tl_tmr_wait, atomic_read(&tl_tmr->tmr_complete));\r\nret = se_cmd->se_tmr_req->response;\r\nrelease:\r\nif (se_cmd)\r\ntransport_generic_free_cmd(se_cmd, 1);\r\nelse\r\nkmem_cache_free(tcm_loop_cmd_cache, tl_cmd);\r\nkfree(tl_tmr);\r\nreturn ret;\r\n}\r\nstatic int tcm_loop_abort_task(struct scsi_cmnd *sc)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\nint ret = FAILED;\r\ntl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\r\ntl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\r\nret = tcm_loop_issue_tmr(tl_tpg, sc->device->lun,\r\nsc->request->tag, TMR_ABORT_TASK);\r\nreturn (ret == TMR_FUNCTION_COMPLETE) ? SUCCESS : FAILED;\r\n}\r\nstatic int tcm_loop_device_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\nint ret = FAILED;\r\ntl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\r\ntl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\r\nret = tcm_loop_issue_tmr(tl_tpg, sc->device->lun,\r\n0, TMR_LUN_RESET);\r\nreturn (ret == TMR_FUNCTION_COMPLETE) ? SUCCESS : FAILED;\r\n}\r\nstatic int tcm_loop_target_reset(struct scsi_cmnd *sc)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\ntl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);\r\nif (!tl_hba) {\r\npr_err("Unable to perform device reset without"\r\n" active I_T Nexus\n");\r\nreturn FAILED;\r\n}\r\ntl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];\r\nif (tl_tpg) {\r\ntl_tpg->tl_transport_status = TCM_TRANSPORT_ONLINE;\r\nreturn SUCCESS;\r\n}\r\nreturn FAILED;\r\n}\r\nstatic int tcm_loop_slave_alloc(struct scsi_device *sd)\r\n{\r\nset_bit(QUEUE_FLAG_BIDI, &sd->request_queue->queue_flags);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_driver_probe(struct device *dev)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct Scsi_Host *sh;\r\nint error, host_prot;\r\ntl_hba = to_tcm_loop_hba(dev);\r\nsh = scsi_host_alloc(&tcm_loop_driver_template,\r\nsizeof(struct tcm_loop_hba));\r\nif (!sh) {\r\npr_err("Unable to allocate struct scsi_host\n");\r\nreturn -ENODEV;\r\n}\r\ntl_hba->sh = sh;\r\n*((struct tcm_loop_hba **)sh->hostdata) = tl_hba;\r\nsh->max_id = 2;\r\nsh->max_lun = 0;\r\nsh->max_channel = 0;\r\nsh->max_cmd_len = SCSI_MAX_VARLEN_CDB_SIZE;\r\nhost_prot = SHOST_DIF_TYPE1_PROTECTION | SHOST_DIF_TYPE2_PROTECTION |\r\nSHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE1_PROTECTION |\r\nSHOST_DIX_TYPE2_PROTECTION | SHOST_DIX_TYPE3_PROTECTION;\r\nscsi_host_set_prot(sh, host_prot);\r\nscsi_host_set_guard(sh, SHOST_DIX_GUARD_CRC);\r\nerror = scsi_add_host(sh, &tl_hba->dev);\r\nif (error) {\r\npr_err("%s: scsi_add_host failed\n", __func__);\r\nscsi_host_put(sh);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_driver_remove(struct device *dev)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct Scsi_Host *sh;\r\ntl_hba = to_tcm_loop_hba(dev);\r\nsh = tl_hba->sh;\r\nscsi_remove_host(sh);\r\nscsi_host_put(sh);\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_release_adapter(struct device *dev)\r\n{\r\nstruct tcm_loop_hba *tl_hba = to_tcm_loop_hba(dev);\r\nkfree(tl_hba);\r\n}\r\nstatic int tcm_loop_setup_hba_bus(struct tcm_loop_hba *tl_hba, int tcm_loop_host_id)\r\n{\r\nint ret;\r\ntl_hba->dev.bus = &tcm_loop_lld_bus;\r\ntl_hba->dev.parent = tcm_loop_primary;\r\ntl_hba->dev.release = &tcm_loop_release_adapter;\r\ndev_set_name(&tl_hba->dev, "tcm_loop_adapter_%d", tcm_loop_host_id);\r\nret = device_register(&tl_hba->dev);\r\nif (ret) {\r\npr_err("device_register() failed for"\r\n" tl_hba->dev: %d\n", ret);\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_alloc_core_bus(void)\r\n{\r\nint ret;\r\ntcm_loop_primary = root_device_register("tcm_loop_0");\r\nif (IS_ERR(tcm_loop_primary)) {\r\npr_err("Unable to allocate tcm_loop_primary\n");\r\nreturn PTR_ERR(tcm_loop_primary);\r\n}\r\nret = bus_register(&tcm_loop_lld_bus);\r\nif (ret) {\r\npr_err("bus_register() failed for tcm_loop_lld_bus\n");\r\ngoto dev_unreg;\r\n}\r\nret = driver_register(&tcm_loop_driverfs);\r\nif (ret) {\r\npr_err("driver_register() failed for"\r\n"tcm_loop_driverfs\n");\r\ngoto bus_unreg;\r\n}\r\npr_debug("Initialized TCM Loop Core Bus\n");\r\nreturn ret;\r\nbus_unreg:\r\nbus_unregister(&tcm_loop_lld_bus);\r\ndev_unreg:\r\nroot_device_unregister(tcm_loop_primary);\r\nreturn ret;\r\n}\r\nstatic void tcm_loop_release_core_bus(void)\r\n{\r\ndriver_unregister(&tcm_loop_driverfs);\r\nbus_unregister(&tcm_loop_lld_bus);\r\nroot_device_unregister(tcm_loop_primary);\r\npr_debug("Releasing TCM Loop Core BUS\n");\r\n}\r\nstatic char *tcm_loop_get_fabric_name(void)\r\n{\r\nreturn "loopback";\r\n}\r\nstatic inline struct tcm_loop_tpg *tl_tpg(struct se_portal_group *se_tpg)\r\n{\r\nreturn container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\r\n}\r\nstatic char *tcm_loop_get_endpoint_wwn(struct se_portal_group *se_tpg)\r\n{\r\nreturn &tl_tpg(se_tpg)->tl_hba->tl_wwn_address[0];\r\n}\r\nstatic u16 tcm_loop_get_tag(struct se_portal_group *se_tpg)\r\n{\r\nreturn tl_tpg(se_tpg)->tl_tpgt;\r\n}\r\nstatic int tcm_loop_check_demo_mode(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic int tcm_loop_check_demo_mode_cache(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_check_demo_mode_write_protect(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_check_prod_mode_write_protect(struct se_portal_group *se_tpg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_check_prot_fabric_only(struct se_portal_group *se_tpg)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg, struct tcm_loop_tpg,\r\ntl_se_tpg);\r\nreturn tl_tpg->tl_fabric_prot_type;\r\n}\r\nstatic u32 tcm_loop_get_inst_index(struct se_portal_group *se_tpg)\r\n{\r\nreturn 1;\r\n}\r\nstatic u32 tcm_loop_sess_get_index(struct se_session *se_sess)\r\n{\r\nreturn 1;\r\n}\r\nstatic void tcm_loop_set_default_node_attributes(struct se_node_acl *se_acl)\r\n{\r\nreturn;\r\n}\r\nstatic int tcm_loop_get_cmd_state(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nreturn tl_cmd->sc_cmd_state;\r\n}\r\nstatic int tcm_loop_write_pending(struct se_cmd *se_cmd)\r\n{\r\ntarget_execute_cmd(se_cmd);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_write_pending_status(struct se_cmd *se_cmd)\r\n{\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_queue_data_in(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nstruct scsi_cmnd *sc = tl_cmd->sc;\r\npr_debug("tcm_loop_queue_data_in() called for scsi_cmnd: %p"\r\n" cdb: 0x%02x\n", sc, sc->cmnd[0]);\r\nsc->result = SAM_STAT_GOOD;\r\nset_host_byte(sc, DID_OK);\r\nif ((se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) ||\r\n(se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT))\r\nscsi_set_resid(sc, se_cmd->residual_count);\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_queue_status(struct se_cmd *se_cmd)\r\n{\r\nstruct tcm_loop_cmd *tl_cmd = container_of(se_cmd,\r\nstruct tcm_loop_cmd, tl_se_cmd);\r\nstruct scsi_cmnd *sc = tl_cmd->sc;\r\npr_debug("tcm_loop_queue_status() called for scsi_cmnd: %p"\r\n" cdb: 0x%02x\n", sc, sc->cmnd[0]);\r\nif (se_cmd->sense_buffer &&\r\n((se_cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) ||\r\n(se_cmd->se_cmd_flags & SCF_EMULATED_TASK_SENSE))) {\r\nmemcpy(sc->sense_buffer, se_cmd->sense_buffer,\r\nSCSI_SENSE_BUFFERSIZE);\r\nsc->result = SAM_STAT_CHECK_CONDITION;\r\nset_driver_byte(sc, DRIVER_SENSE);\r\n} else\r\nsc->result = se_cmd->scsi_status;\r\nset_host_byte(sc, DID_OK);\r\nif ((se_cmd->se_cmd_flags & SCF_OVERFLOW_BIT) ||\r\n(se_cmd->se_cmd_flags & SCF_UNDERFLOW_BIT))\r\nscsi_set_resid(sc, se_cmd->residual_count);\r\nsc->scsi_done(sc);\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)\r\n{\r\nstruct se_tmr_req *se_tmr = se_cmd->se_tmr_req;\r\nstruct tcm_loop_tmr *tl_tmr = se_tmr->fabric_tmr_ptr;\r\natomic_set(&tl_tmr->tmr_complete, 1);\r\nwake_up(&tl_tmr->tl_tmr_wait);\r\n}\r\nstatic void tcm_loop_aborted_task(struct se_cmd *se_cmd)\r\n{\r\nreturn;\r\n}\r\nstatic char *tcm_loop_dump_proto_id(struct tcm_loop_hba *tl_hba)\r\n{\r\nswitch (tl_hba->tl_proto_id) {\r\ncase SCSI_PROTOCOL_SAS:\r\nreturn "SAS";\r\ncase SCSI_PROTOCOL_FCP:\r\nreturn "FCP";\r\ncase SCSI_PROTOCOL_ISCSI:\r\nreturn "iSCSI";\r\ndefault:\r\nbreak;\r\n}\r\nreturn "Unknown";\r\n}\r\nstatic int tcm_loop_port_link(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_lun *lun)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\natomic_inc_mb(&tl_tpg->tl_tpg_port_count);\r\nscsi_add_device(tl_hba->sh, 0, tl_tpg->tl_tpgt, lun->unpacked_lun);\r\npr_debug("TCM_Loop_ConfigFS: Port Link Successful\n");\r\nreturn 0;\r\n}\r\nstatic void tcm_loop_port_unlink(\r\nstruct se_portal_group *se_tpg,\r\nstruct se_lun *se_lun)\r\n{\r\nstruct scsi_device *sd;\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct tcm_loop_tpg *tl_tpg;\r\ntl_tpg = container_of(se_tpg, struct tcm_loop_tpg, tl_se_tpg);\r\ntl_hba = tl_tpg->tl_hba;\r\nsd = scsi_device_lookup(tl_hba->sh, 0, tl_tpg->tl_tpgt,\r\nse_lun->unpacked_lun);\r\nif (!sd) {\r\npr_err("Unable to locate struct scsi_device for %d:%d:"\r\n"%llu\n", 0, tl_tpg->tl_tpgt, se_lun->unpacked_lun);\r\nreturn;\r\n}\r\nscsi_remove_device(sd);\r\nscsi_device_put(sd);\r\natomic_dec_mb(&tl_tpg->tl_tpg_port_count);\r\npr_debug("TCM_Loop_ConfigFS: Port Unlink Successful\n");\r\n}\r\nstatic ssize_t tcm_loop_tpg_attrib_fabric_prot_type_show(\r\nstruct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg, struct tcm_loop_tpg,\r\ntl_se_tpg);\r\nreturn sprintf(page, "%d\n", tl_tpg->tl_fabric_prot_type);\r\n}\r\nstatic ssize_t tcm_loop_tpg_attrib_fabric_prot_type_store(\r\nstruct config_item *item, const char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = attrib_to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg, struct tcm_loop_tpg,\r\ntl_se_tpg);\r\nunsigned long val;\r\nint ret = kstrtoul(page, 0, &val);\r\nif (ret) {\r\npr_err("kstrtoul() returned %d for fabric_prot_type\n", ret);\r\nreturn ret;\r\n}\r\nif (val != 0 && val != 1 && val != 3) {\r\npr_err("Invalid qla2xxx fabric_prot_type: %lu\n", val);\r\nreturn -EINVAL;\r\n}\r\ntl_tpg->tl_fabric_prot_type = val;\r\nreturn count;\r\n}\r\nstatic int tcm_loop_alloc_sess_cb(struct se_portal_group *se_tpg,\r\nstruct se_session *se_sess, void *p)\r\n{\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\ntl_tpg->tl_nexus = p;\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_make_nexus(\r\nstruct tcm_loop_tpg *tl_tpg,\r\nconst char *name)\r\n{\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nstruct tcm_loop_nexus *tl_nexus;\r\nint ret;\r\nif (tl_tpg->tl_nexus) {\r\npr_debug("tl_tpg->tl_nexus already exists\n");\r\nreturn -EEXIST;\r\n}\r\ntl_nexus = kzalloc(sizeof(struct tcm_loop_nexus), GFP_KERNEL);\r\nif (!tl_nexus) {\r\npr_err("Unable to allocate struct tcm_loop_nexus\n");\r\nreturn -ENOMEM;\r\n}\r\ntl_nexus->se_sess = target_alloc_session(&tl_tpg->tl_se_tpg, 0, 0,\r\nTARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS,\r\nname, tl_nexus, tcm_loop_alloc_sess_cb);\r\nif (IS_ERR(tl_nexus->se_sess)) {\r\nret = PTR_ERR(tl_nexus->se_sess);\r\nkfree(tl_nexus);\r\nreturn ret;\r\n}\r\npr_debug("TCM_Loop_ConfigFS: Established I_T Nexus to emulated"\r\n" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tl_hba),\r\nname);\r\nreturn 0;\r\n}\r\nstatic int tcm_loop_drop_nexus(\r\nstruct tcm_loop_tpg *tpg)\r\n{\r\nstruct se_session *se_sess;\r\nstruct tcm_loop_nexus *tl_nexus;\r\ntl_nexus = tpg->tl_nexus;\r\nif (!tl_nexus)\r\nreturn -ENODEV;\r\nse_sess = tl_nexus->se_sess;\r\nif (!se_sess)\r\nreturn -ENODEV;\r\nif (atomic_read(&tpg->tl_tpg_port_count)) {\r\npr_err("Unable to remove TCM_Loop I_T Nexus with"\r\n" active TPG port count: %d\n",\r\natomic_read(&tpg->tl_tpg_port_count));\r\nreturn -EPERM;\r\n}\r\npr_debug("TCM_Loop_ConfigFS: Removing I_T Nexus to emulated"\r\n" %s Initiator Port: %s\n", tcm_loop_dump_proto_id(tpg->tl_hba),\r\ntl_nexus->se_sess->se_node_acl->initiatorname);\r\ntransport_deregister_session(tl_nexus->se_sess);\r\ntpg->tl_nexus = NULL;\r\nkfree(tl_nexus);\r\nreturn 0;\r\n}\r\nstatic ssize_t tcm_loop_tpg_nexus_show(struct config_item *item, char *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_nexus *tl_nexus;\r\nssize_t ret;\r\ntl_nexus = tl_tpg->tl_nexus;\r\nif (!tl_nexus)\r\nreturn -ENODEV;\r\nret = snprintf(page, PAGE_SIZE, "%s\n",\r\ntl_nexus->se_sess->se_node_acl->initiatorname);\r\nreturn ret;\r\n}\r\nstatic ssize_t tcm_loop_tpg_nexus_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nunsigned char i_port[TL_WWN_ADDR_LEN], *ptr, *port_ptr;\r\nint ret;\r\nif (!strncmp(page, "NULL", 4)) {\r\nret = tcm_loop_drop_nexus(tl_tpg);\r\nreturn (!ret) ? count : ret;\r\n}\r\nif (strlen(page) >= TL_WWN_ADDR_LEN) {\r\npr_err("Emulated NAA Sas Address: %s, exceeds"\r\n" max: %d\n", page, TL_WWN_ADDR_LEN);\r\nreturn -EINVAL;\r\n}\r\nsnprintf(&i_port[0], TL_WWN_ADDR_LEN, "%s", page);\r\nptr = strstr(i_port, "naa.");\r\nif (ptr) {\r\nif (tl_hba->tl_proto_id != SCSI_PROTOCOL_SAS) {\r\npr_err("Passed SAS Initiator Port %s does not"\r\n" match target port protoid: %s\n", i_port,\r\ntcm_loop_dump_proto_id(tl_hba));\r\nreturn -EINVAL;\r\n}\r\nport_ptr = &i_port[0];\r\ngoto check_newline;\r\n}\r\nptr = strstr(i_port, "fc.");\r\nif (ptr) {\r\nif (tl_hba->tl_proto_id != SCSI_PROTOCOL_FCP) {\r\npr_err("Passed FCP Initiator Port %s does not"\r\n" match target port protoid: %s\n", i_port,\r\ntcm_loop_dump_proto_id(tl_hba));\r\nreturn -EINVAL;\r\n}\r\nport_ptr = &i_port[3];\r\ngoto check_newline;\r\n}\r\nptr = strstr(i_port, "iqn.");\r\nif (ptr) {\r\nif (tl_hba->tl_proto_id != SCSI_PROTOCOL_ISCSI) {\r\npr_err("Passed iSCSI Initiator Port %s does not"\r\n" match target port protoid: %s\n", i_port,\r\ntcm_loop_dump_proto_id(tl_hba));\r\nreturn -EINVAL;\r\n}\r\nport_ptr = &i_port[0];\r\ngoto check_newline;\r\n}\r\npr_err("Unable to locate prefix for emulated Initiator Port:"\r\n" %s\n", i_port);\r\nreturn -EINVAL;\r\ncheck_newline:\r\nif (i_port[strlen(i_port)-1] == '\n')\r\ni_port[strlen(i_port)-1] = '\0';\r\nret = tcm_loop_make_nexus(tl_tpg, port_ptr);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t tcm_loop_tpg_transport_status_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nconst char *status = NULL;\r\nssize_t ret = -EINVAL;\r\nswitch (tl_tpg->tl_transport_status) {\r\ncase TCM_TRANSPORT_ONLINE:\r\nstatus = "online";\r\nbreak;\r\ncase TCM_TRANSPORT_OFFLINE:\r\nstatus = "offline";\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (status)\r\nret = snprintf(page, PAGE_SIZE, "%s\n", status);\r\nreturn ret;\r\n}\r\nstatic ssize_t tcm_loop_tpg_transport_status_store(struct config_item *item,\r\nconst char *page, size_t count)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nif (!strncmp(page, "online", 6)) {\r\ntl_tpg->tl_transport_status = TCM_TRANSPORT_ONLINE;\r\nreturn count;\r\n}\r\nif (!strncmp(page, "offline", 7)) {\r\ntl_tpg->tl_transport_status = TCM_TRANSPORT_OFFLINE;\r\nif (tl_tpg->tl_nexus) {\r\nstruct se_session *tl_sess = tl_tpg->tl_nexus->se_sess;\r\ncore_allocate_nexus_loss_ua(tl_sess->se_node_acl);\r\n}\r\nreturn count;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic ssize_t tcm_loop_tpg_address_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct se_portal_group *se_tpg = to_tpg(item);\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba = tl_tpg->tl_hba;\r\nreturn snprintf(page, PAGE_SIZE, "%d:0:%d\n",\r\ntl_hba->sh->host_no, tl_tpg->tl_tpgt);\r\n}\r\nstatic struct se_portal_group *tcm_loop_make_naa_tpg(\r\nstruct se_wwn *wwn,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_loop_hba *tl_hba = container_of(wwn,\r\nstruct tcm_loop_hba, tl_hba_wwn);\r\nstruct tcm_loop_tpg *tl_tpg;\r\nint ret;\r\nunsigned long tpgt;\r\nif (strstr(name, "tpgt_") != name) {\r\npr_err("Unable to locate \"tpgt_#\" directory"\r\n" group\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nif (kstrtoul(name+5, 10, &tpgt))\r\nreturn ERR_PTR(-EINVAL);\r\nif (tpgt >= TL_TPGS_PER_HBA) {\r\npr_err("Passed tpgt: %lu exceeds TL_TPGS_PER_HBA:"\r\n" %u\n", tpgt, TL_TPGS_PER_HBA);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntl_tpg = &tl_hba->tl_hba_tpgs[tpgt];\r\ntl_tpg->tl_hba = tl_hba;\r\ntl_tpg->tl_tpgt = tpgt;\r\nret = core_tpg_register(wwn, &tl_tpg->tl_se_tpg, tl_hba->tl_proto_id);\r\nif (ret < 0)\r\nreturn ERR_PTR(-ENOMEM);\r\npr_debug("TCM_Loop_ConfigFS: Allocated Emulated %s"\r\n" Target Port %s,t,0x%04lx\n", tcm_loop_dump_proto_id(tl_hba),\r\nconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\r\nreturn &tl_tpg->tl_se_tpg;\r\n}\r\nstatic void tcm_loop_drop_naa_tpg(\r\nstruct se_portal_group *se_tpg)\r\n{\r\nstruct se_wwn *wwn = se_tpg->se_tpg_wwn;\r\nstruct tcm_loop_tpg *tl_tpg = container_of(se_tpg,\r\nstruct tcm_loop_tpg, tl_se_tpg);\r\nstruct tcm_loop_hba *tl_hba;\r\nunsigned short tpgt;\r\ntl_hba = tl_tpg->tl_hba;\r\ntpgt = tl_tpg->tl_tpgt;\r\ntcm_loop_drop_nexus(tl_tpg);\r\ncore_tpg_deregister(se_tpg);\r\ntl_tpg->tl_hba = NULL;\r\ntl_tpg->tl_tpgt = 0;\r\npr_debug("TCM_Loop_ConfigFS: Deallocated Emulated %s"\r\n" Target Port %s,t,0x%04x\n", tcm_loop_dump_proto_id(tl_hba),\r\nconfig_item_name(&wwn->wwn_group.cg_item), tpgt);\r\n}\r\nstatic struct se_wwn *tcm_loop_make_scsi_hba(\r\nstruct target_fabric_configfs *tf,\r\nstruct config_group *group,\r\nconst char *name)\r\n{\r\nstruct tcm_loop_hba *tl_hba;\r\nstruct Scsi_Host *sh;\r\nchar *ptr;\r\nint ret, off = 0;\r\ntl_hba = kzalloc(sizeof(struct tcm_loop_hba), GFP_KERNEL);\r\nif (!tl_hba) {\r\npr_err("Unable to allocate struct tcm_loop_hba\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nptr = strstr(name, "naa.");\r\nif (ptr) {\r\ntl_hba->tl_proto_id = SCSI_PROTOCOL_SAS;\r\ngoto check_len;\r\n}\r\nptr = strstr(name, "fc.");\r\nif (ptr) {\r\ntl_hba->tl_proto_id = SCSI_PROTOCOL_FCP;\r\noff = 3;\r\ngoto check_len;\r\n}\r\nptr = strstr(name, "iqn.");\r\nif (!ptr) {\r\npr_err("Unable to locate prefix for emulated Target "\r\n"Port: %s\n", name);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ntl_hba->tl_proto_id = SCSI_PROTOCOL_ISCSI;\r\ncheck_len:\r\nif (strlen(name) >= TL_WWN_ADDR_LEN) {\r\npr_err("Emulated NAA %s Address: %s, exceeds"\r\n" max: %d\n", name, tcm_loop_dump_proto_id(tl_hba),\r\nTL_WWN_ADDR_LEN);\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsnprintf(&tl_hba->tl_wwn_address[0], TL_WWN_ADDR_LEN, "%s", &name[off]);\r\nret = tcm_loop_setup_hba_bus(tl_hba, tcm_loop_hba_no_cnt);\r\nif (ret)\r\ngoto out;\r\nsh = tl_hba->sh;\r\ntcm_loop_hba_no_cnt++;\r\npr_debug("TCM_Loop_ConfigFS: Allocated emulated Target"\r\n" %s Address: %s at Linux/SCSI Host ID: %d\n",\r\ntcm_loop_dump_proto_id(tl_hba), name, sh->host_no);\r\nreturn &tl_hba->tl_hba_wwn;\r\nout:\r\nkfree(tl_hba);\r\nreturn ERR_PTR(ret);\r\n}\r\nstatic void tcm_loop_drop_scsi_hba(\r\nstruct se_wwn *wwn)\r\n{\r\nstruct tcm_loop_hba *tl_hba = container_of(wwn,\r\nstruct tcm_loop_hba, tl_hba_wwn);\r\npr_debug("TCM_Loop_ConfigFS: Deallocating emulated Target"\r\n" %s Address: %s at Linux/SCSI Host ID: %d\n",\r\ntcm_loop_dump_proto_id(tl_hba), tl_hba->tl_wwn_address,\r\ntl_hba->sh->host_no);\r\ndevice_unregister(&tl_hba->dev);\r\n}\r\nstatic ssize_t tcm_loop_wwn_version_show(struct config_item *item, char *page)\r\n{\r\nreturn sprintf(page, "TCM Loopback Fabric module %s\n", TCM_LOOP_VERSION);\r\n}\r\nstatic int __init tcm_loop_fabric_init(void)\r\n{\r\nint ret = -ENOMEM;\r\ntcm_loop_workqueue = alloc_workqueue("tcm_loop", 0, 0);\r\nif (!tcm_loop_workqueue)\r\ngoto out;\r\ntcm_loop_cmd_cache = kmem_cache_create("tcm_loop_cmd_cache",\r\nsizeof(struct tcm_loop_cmd),\r\n__alignof__(struct tcm_loop_cmd),\r\n0, NULL);\r\nif (!tcm_loop_cmd_cache) {\r\npr_debug("kmem_cache_create() for"\r\n" tcm_loop_cmd_cache failed\n");\r\ngoto out_destroy_workqueue;\r\n}\r\nret = tcm_loop_alloc_core_bus();\r\nif (ret)\r\ngoto out_destroy_cache;\r\nret = target_register_template(&loop_ops);\r\nif (ret)\r\ngoto out_release_core_bus;\r\nreturn 0;\r\nout_release_core_bus:\r\ntcm_loop_release_core_bus();\r\nout_destroy_cache:\r\nkmem_cache_destroy(tcm_loop_cmd_cache);\r\nout_destroy_workqueue:\r\ndestroy_workqueue(tcm_loop_workqueue);\r\nout:\r\nreturn ret;\r\n}\r\nstatic void __exit tcm_loop_fabric_exit(void)\r\n{\r\ntarget_unregister_template(&loop_ops);\r\ntcm_loop_release_core_bus();\r\nkmem_cache_destroy(tcm_loop_cmd_cache);\r\ndestroy_workqueue(tcm_loop_workqueue);\r\n}
