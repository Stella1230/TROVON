static void __init asm9260_acc_init(struct device_node *np)\r\n{\r\nstruct clk_hw *hw;\r\nstruct clk_hw **hws;\r\nconst char *ref_clk, *pll_clk = "pll";\r\nu32 rate;\r\nint n;\r\nu32 accuracy = 0;\r\nclk_data = kzalloc(sizeof(*clk_data) +\r\nsizeof(*clk_data->hws) * MAX_CLKS, GFP_KERNEL);\r\nif (!clk_data)\r\nreturn;\r\nclk_data->num = MAX_CLKS;\r\nhws = clk_data->hws;\r\nbase = of_io_request_and_map(np, 0, np->name);\r\nif (IS_ERR(base))\r\npanic("%s: unable to map resource", np->name);\r\nrate = (ioread32(base + HW_SYSPLLCTRL) & 0xffff) * 1000000;\r\nref_clk = of_clk_get_parent_name(np, 0);\r\naccuracy = clk_get_accuracy(__clk_lookup(ref_clk));\r\nhw = clk_hw_register_fixed_rate_with_accuracy(NULL, pll_clk,\r\nref_clk, 0, rate, accuracy);\r\nif (IS_ERR(hw))\r\npanic("%s: can't register REFCLK. Check DT!", np->name);\r\nfor (n = 0; n < ARRAY_SIZE(asm9260_mux_clks); n++) {\r\nconst struct asm9260_mux_clock *mc = &asm9260_mux_clks[n];\r\nmc->parent_names[0] = ref_clk;\r\nmc->parent_names[1] = pll_clk;\r\nhw = clk_hw_register_mux_table(NULL, mc->name, mc->parent_names,\r\nmc->num_parents, mc->flags, base + mc->offset,\r\n0, mc->mask, 0, mc->table, &asm9260_clk_lock);\r\n}\r\nfor (n = 0; n < ARRAY_SIZE(asm9260_mux_gates); n++) {\r\nconst struct asm9260_gate_data *gd = &asm9260_mux_gates[n];\r\nhw = clk_hw_register_gate(NULL, gd->name,\r\ngd->parent_name, gd->flags | CLK_SET_RATE_PARENT,\r\nbase + gd->reg, gd->bit_idx, 0, &asm9260_clk_lock);\r\n}\r\nfor (n = 0; n < ARRAY_SIZE(asm9260_div_clks); n++) {\r\nconst struct asm9260_div_clk *dc = &asm9260_div_clks[n];\r\nhws[dc->idx] = clk_hw_register_divider(NULL, dc->name,\r\ndc->parent_name, CLK_SET_RATE_PARENT,\r\nbase + dc->reg, 0, 8, CLK_DIVIDER_ONE_BASED,\r\n&asm9260_clk_lock);\r\n}\r\nfor (n = 0; n < ARRAY_SIZE(asm9260_ahb_gates); n++) {\r\nconst struct asm9260_gate_data *gd = &asm9260_ahb_gates[n];\r\nhws[gd->idx] = clk_hw_register_gate(NULL, gd->name,\r\ngd->parent_name, gd->flags, base + gd->reg,\r\ngd->bit_idx, 0, &asm9260_clk_lock);\r\n}\r\nfor (n = 0; n < MAX_CLKS; n++) {\r\nif (!IS_ERR(hws[n]))\r\ncontinue;\r\npr_err("%s: Unable to register leaf clock %d\n",\r\nnp->full_name, n);\r\ngoto fail;\r\n}\r\nof_clk_add_hw_provider(np, of_clk_hw_onecell_get, clk_data);\r\nreturn;\r\nfail:\r\niounmap(base);\r\n}
