static inline void pp_enable_irq(struct pp_struct *pp)\r\n{\r\nstruct parport *port = pp->pdev->port;\r\nport->ops->enable_irq(port);\r\n}\r\nstatic ssize_t pp_read(struct file *file, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nunsigned int minor = iminor(file_inode(file));\r\nstruct pp_struct *pp = file->private_data;\r\nchar *kbuffer;\r\nssize_t bytes_read = 0;\r\nstruct parport *pport;\r\nint mode;\r\nif (!(pp->flags & PP_CLAIMED)) {\r\npr_debug(CHRDEV "%x: claim the port first\n", minor);\r\nreturn -EINVAL;\r\n}\r\nif (count == 0)\r\nreturn 0;\r\nkbuffer = kmalloc(min_t(size_t, count, PP_BUFFER_SIZE), GFP_KERNEL);\r\nif (!kbuffer)\r\nreturn -ENOMEM;\r\npport = pp->pdev->port;\r\nmode = pport->ieee1284.mode & ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\r\nparport_set_timeout(pp->pdev,\r\n(file->f_flags & O_NONBLOCK) ?\r\nPARPORT_INACTIVITY_O_NONBLOCK :\r\npp->default_inactivity);\r\nwhile (bytes_read == 0) {\r\nssize_t need = min_t(unsigned long, count, PP_BUFFER_SIZE);\r\nif (mode == IEEE1284_MODE_EPP) {\r\nint flags = 0;\r\nsize_t (*fn)(struct parport *, void *, size_t, int);\r\nif (pp->flags & PP_W91284PIC)\r\nflags |= PARPORT_W91284PIC;\r\nif (pp->flags & PP_FASTREAD)\r\nflags |= PARPORT_EPP_FAST;\r\nif (pport->ieee1284.mode & IEEE1284_ADDR)\r\nfn = pport->ops->epp_read_addr;\r\nelse\r\nfn = pport->ops->epp_read_data;\r\nbytes_read = (*fn)(pport, kbuffer, need, flags);\r\n} else {\r\nbytes_read = parport_read(pport, kbuffer, need);\r\n}\r\nif (bytes_read != 0)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK) {\r\nbytes_read = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current)) {\r\nbytes_read = -ERESTARTSYS;\r\nbreak;\r\n}\r\ncond_resched();\r\n}\r\nparport_set_timeout(pp->pdev, pp->default_inactivity);\r\nif (bytes_read > 0 && copy_to_user(buf, kbuffer, bytes_read))\r\nbytes_read = -EFAULT;\r\nkfree(kbuffer);\r\npp_enable_irq(pp);\r\nreturn bytes_read;\r\n}\r\nstatic ssize_t pp_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nunsigned int minor = iminor(file_inode(file));\r\nstruct pp_struct *pp = file->private_data;\r\nchar *kbuffer;\r\nssize_t bytes_written = 0;\r\nssize_t wrote;\r\nint mode;\r\nstruct parport *pport;\r\nif (!(pp->flags & PP_CLAIMED)) {\r\npr_debug(CHRDEV "%x: claim the port first\n", minor);\r\nreturn -EINVAL;\r\n}\r\nkbuffer = kmalloc(min_t(size_t, count, PP_BUFFER_SIZE), GFP_KERNEL);\r\nif (!kbuffer)\r\nreturn -ENOMEM;\r\npport = pp->pdev->port;\r\nmode = pport->ieee1284.mode & ~(IEEE1284_DEVICEID | IEEE1284_ADDR);\r\nparport_set_timeout(pp->pdev,\r\n(file->f_flags & O_NONBLOCK) ?\r\nPARPORT_INACTIVITY_O_NONBLOCK :\r\npp->default_inactivity);\r\nwhile (bytes_written < count) {\r\nssize_t n = min_t(unsigned long, count - bytes_written, PP_BUFFER_SIZE);\r\nif (copy_from_user(kbuffer, buf + bytes_written, n)) {\r\nbytes_written = -EFAULT;\r\nbreak;\r\n}\r\nif ((pp->flags & PP_FASTWRITE) && (mode == IEEE1284_MODE_EPP)) {\r\nif (pport->ieee1284.mode & IEEE1284_ADDR) {\r\nwrote = pport->ops->epp_write_addr(pport,\r\nkbuffer, n, PARPORT_EPP_FAST);\r\n} else {\r\nwrote = pport->ops->epp_write_data(pport,\r\nkbuffer, n, PARPORT_EPP_FAST);\r\n}\r\n} else {\r\nwrote = parport_write(pp->pdev->port, kbuffer, n);\r\n}\r\nif (wrote <= 0) {\r\nif (!bytes_written)\r\nbytes_written = wrote;\r\nbreak;\r\n}\r\nbytes_written += wrote;\r\nif (file->f_flags & O_NONBLOCK) {\r\nif (!bytes_written)\r\nbytes_written = -EAGAIN;\r\nbreak;\r\n}\r\nif (signal_pending(current))\r\nbreak;\r\ncond_resched();\r\n}\r\nparport_set_timeout(pp->pdev, pp->default_inactivity);\r\nkfree(kbuffer);\r\npp_enable_irq(pp);\r\nreturn bytes_written;\r\n}\r\nstatic void pp_irq(void *private)\r\n{\r\nstruct pp_struct *pp = private;\r\nif (pp->irqresponse) {\r\nparport_write_control(pp->pdev->port, pp->irqctl);\r\npp->irqresponse = 0;\r\n}\r\natomic_inc(&pp->irqc);\r\nwake_up_interruptible(&pp->irq_wait);\r\n}\r\nstatic int register_device(int minor, struct pp_struct *pp)\r\n{\r\nstruct parport *port;\r\nstruct pardevice *pdev = NULL;\r\nchar *name;\r\nstruct pardev_cb ppdev_cb;\r\nint rc = 0, index;\r\nname = kasprintf(GFP_KERNEL, CHRDEV "%x", minor);\r\nif (name == NULL)\r\nreturn -ENOMEM;\r\nport = parport_find_number(minor);\r\nif (!port) {\r\npr_warn("%s: no associated port!\n", name);\r\nrc = -ENXIO;\r\ngoto err;\r\n}\r\nindex = ida_simple_get(&ida_index, 0, 0, GFP_KERNEL);\r\nmemset(&ppdev_cb, 0, sizeof(ppdev_cb));\r\nppdev_cb.irq_func = pp_irq;\r\nppdev_cb.flags = (pp->flags & PP_EXCL) ? PARPORT_FLAG_EXCL : 0;\r\nppdev_cb.private = pp;\r\npdev = parport_register_dev_model(port, name, &ppdev_cb, index);\r\nparport_put_port(port);\r\nif (!pdev) {\r\npr_warn("%s: failed to register device!\n", name);\r\nrc = -ENXIO;\r\nida_simple_remove(&ida_index, index);\r\ngoto err;\r\n}\r\npp->pdev = pdev;\r\npp->index = index;\r\ndev_dbg(&pdev->dev, "registered pardevice\n");\r\nerr:\r\nkfree(name);\r\nreturn rc;\r\n}\r\nstatic enum ieee1284_phase init_phase(int mode)\r\n{\r\nswitch (mode & ~(IEEE1284_DEVICEID\r\n| IEEE1284_ADDR)) {\r\ncase IEEE1284_MODE_NIBBLE:\r\ncase IEEE1284_MODE_BYTE:\r\nreturn IEEE1284_PH_REV_IDLE;\r\n}\r\nreturn IEEE1284_PH_FWD_IDLE;\r\n}\r\nstatic int pp_set_timeout(struct pardevice *pdev, long tv_sec, int tv_usec)\r\n{\r\nlong to_jiffies;\r\nif ((tv_sec < 0) || (tv_usec < 0))\r\nreturn -EINVAL;\r\nto_jiffies = usecs_to_jiffies(tv_usec);\r\nto_jiffies += tv_sec * HZ;\r\nif (to_jiffies <= 0)\r\nreturn -EINVAL;\r\npdev->timeout = to_jiffies;\r\nreturn 0;\r\n}\r\nstatic int pp_do_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nunsigned int minor = iminor(file_inode(file));\r\nstruct pp_struct *pp = file->private_data;\r\nstruct parport *port;\r\nvoid __user *argp = (void __user *)arg;\r\nswitch (cmd) {\r\ncase PPCLAIM:\r\n{\r\nstruct ieee1284_info *info;\r\nint ret;\r\nif (pp->flags & PP_CLAIMED) {\r\ndev_dbg(&pp->pdev->dev, "you've already got it!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pp->pdev) {\r\nint err = register_device(minor, pp);\r\nif (err)\r\nreturn err;\r\n}\r\nret = parport_claim_or_block(pp->pdev);\r\nif (ret < 0)\r\nreturn ret;\r\npp->flags |= PP_CLAIMED;\r\npp_enable_irq(pp);\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->saved_state.mode = info->mode;\r\npp->saved_state.phase = info->phase;\r\ninfo->mode = pp->state.mode;\r\ninfo->phase = pp->state.phase;\r\npp->default_inactivity = parport_set_timeout(pp->pdev, 0);\r\nparport_set_timeout(pp->pdev, pp->default_inactivity);\r\nreturn 0;\r\n}\r\ncase PPEXCL:\r\nif (pp->pdev) {\r\ndev_dbg(&pp->pdev->dev,\r\n"too late for PPEXCL; already registered\n");\r\nif (pp->flags & PP_EXCL)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\npp->flags |= PP_EXCL;\r\nreturn 0;\r\ncase PPSETMODE:\r\n{\r\nint mode;\r\nif (copy_from_user(&mode, argp, sizeof(mode)))\r\nreturn -EFAULT;\r\npp->state.mode = mode;\r\npp->state.phase = init_phase(mode);\r\nif (pp->flags & PP_CLAIMED) {\r\npp->pdev->port->ieee1284.mode = mode;\r\npp->pdev->port->ieee1284.phase = pp->state.phase;\r\n}\r\nreturn 0;\r\n}\r\ncase PPGETMODE:\r\n{\r\nint mode;\r\nif (pp->flags & PP_CLAIMED)\r\nmode = pp->pdev->port->ieee1284.mode;\r\nelse\r\nmode = pp->state.mode;\r\nif (copy_to_user(argp, &mode, sizeof(mode)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase PPSETPHASE:\r\n{\r\nint phase;\r\nif (copy_from_user(&phase, argp, sizeof(phase)))\r\nreturn -EFAULT;\r\npp->state.phase = phase;\r\nif (pp->flags & PP_CLAIMED)\r\npp->pdev->port->ieee1284.phase = phase;\r\nreturn 0;\r\n}\r\ncase PPGETPHASE:\r\n{\r\nint phase;\r\nif (pp->flags & PP_CLAIMED)\r\nphase = pp->pdev->port->ieee1284.phase;\r\nelse\r\nphase = pp->state.phase;\r\nif (copy_to_user(argp, &phase, sizeof(phase)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase PPGETMODES:\r\n{\r\nunsigned int modes;\r\nport = parport_find_number(minor);\r\nif (!port)\r\nreturn -ENODEV;\r\nmodes = port->modes;\r\nparport_put_port(port);\r\nif (copy_to_user(argp, &modes, sizeof(modes)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase PPSETFLAGS:\r\n{\r\nint uflags;\r\nif (copy_from_user(&uflags, argp, sizeof(uflags)))\r\nreturn -EFAULT;\r\npp->flags &= ~PP_FLAGMASK;\r\npp->flags |= (uflags & PP_FLAGMASK);\r\nreturn 0;\r\n}\r\ncase PPGETFLAGS:\r\n{\r\nint uflags;\r\nuflags = pp->flags & PP_FLAGMASK;\r\nif (copy_to_user(argp, &uflags, sizeof(uflags)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\n}\r\nif ((pp->flags & PP_CLAIMED) == 0) {\r\npr_debug(CHRDEV "%x: claim the port first\n", minor);\r\nreturn -EINVAL;\r\n}\r\nport = pp->pdev->port;\r\nswitch (cmd) {\r\nstruct ieee1284_info *info;\r\nunsigned char reg;\r\nunsigned char mask;\r\nint mode;\r\ns32 time32[2];\r\ns64 time64[2];\r\nstruct timespec64 ts;\r\nint ret;\r\ncase PPRSTATUS:\r\nreg = parport_read_status(port);\r\nif (copy_to_user(argp, &reg, sizeof(reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPRDATA:\r\nreg = parport_read_data(port);\r\nif (copy_to_user(argp, &reg, sizeof(reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPRCONTROL:\r\nreg = parport_read_control(port);\r\nif (copy_to_user(argp, &reg, sizeof(reg)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPYIELD:\r\nparport_yield_blocking(pp->pdev);\r\nreturn 0;\r\ncase PPRELEASE:\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->state.mode = info->mode;\r\npp->state.phase = info->phase;\r\ninfo->mode = pp->saved_state.mode;\r\ninfo->phase = pp->saved_state.phase;\r\nparport_release(pp->pdev);\r\npp->flags &= ~PP_CLAIMED;\r\nreturn 0;\r\ncase PPWCONTROL:\r\nif (copy_from_user(&reg, argp, sizeof(reg)))\r\nreturn -EFAULT;\r\nparport_write_control(port, reg);\r\nreturn 0;\r\ncase PPWDATA:\r\nif (copy_from_user(&reg, argp, sizeof(reg)))\r\nreturn -EFAULT;\r\nparport_write_data(port, reg);\r\nreturn 0;\r\ncase PPFCONTROL:\r\nif (copy_from_user(&mask, argp,\r\nsizeof(mask)))\r\nreturn -EFAULT;\r\nif (copy_from_user(&reg, 1 + (unsigned char __user *) arg,\r\nsizeof(reg)))\r\nreturn -EFAULT;\r\nparport_frob_control(port, mask, reg);\r\nreturn 0;\r\ncase PPDATADIR:\r\nif (copy_from_user(&mode, argp, sizeof(mode)))\r\nreturn -EFAULT;\r\nif (mode)\r\nport->ops->data_reverse(port);\r\nelse\r\nport->ops->data_forward(port);\r\nreturn 0;\r\ncase PPNEGOT:\r\nif (copy_from_user(&mode, argp, sizeof(mode)))\r\nreturn -EFAULT;\r\nswitch ((ret = parport_negotiate(port, mode))) {\r\ncase 0: break;\r\ncase -1:\r\nret = -EIO;\r\nbreak;\r\ncase 1:\r\nret = -ENXIO;\r\nbreak;\r\n}\r\npp_enable_irq(pp);\r\nreturn ret;\r\ncase PPWCTLONIRQ:\r\nif (copy_from_user(&reg, argp, sizeof(reg)))\r\nreturn -EFAULT;\r\npp->irqctl = reg;\r\npp->irqresponse = 1;\r\nreturn 0;\r\ncase PPCLRIRQ:\r\nret = atomic_read(&pp->irqc);\r\nif (copy_to_user(argp, &ret, sizeof(ret)))\r\nreturn -EFAULT;\r\natomic_sub(ret, &pp->irqc);\r\nreturn 0;\r\ncase PPSETTIME32:\r\nif (copy_from_user(time32, argp, sizeof(time32)))\r\nreturn -EFAULT;\r\nreturn pp_set_timeout(pp->pdev, time32[0], time32[1]);\r\ncase PPSETTIME64:\r\nif (copy_from_user(time64, argp, sizeof(time64)))\r\nreturn -EFAULT;\r\nreturn pp_set_timeout(pp->pdev, time64[0], time64[1]);\r\ncase PPGETTIME32:\r\njiffies_to_timespec64(pp->pdev->timeout, &ts);\r\ntime32[0] = ts.tv_sec;\r\ntime32[1] = ts.tv_nsec / NSEC_PER_USEC;\r\nif ((time32[0] < 0) || (time32[1] < 0))\r\nreturn -EINVAL;\r\nif (copy_to_user(argp, time32, sizeof(time32)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ncase PPGETTIME64:\r\njiffies_to_timespec64(pp->pdev->timeout, &ts);\r\ntime64[0] = ts.tv_sec;\r\ntime64[1] = ts.tv_nsec / NSEC_PER_USEC;\r\nif ((time64[0] < 0) || (time64[1] < 0))\r\nreturn -EINVAL;\r\nif (copy_to_user(argp, time64, sizeof(time64)))\r\nreturn -EFAULT;\r\nreturn 0;\r\ndefault:\r\ndev_dbg(&pp->pdev->dev, "What? (cmd=0x%x)\n", cmd);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic long pp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\r\n{\r\nlong ret;\r\nmutex_lock(&pp_do_mutex);\r\nret = pp_do_ioctl(file, cmd, arg);\r\nmutex_unlock(&pp_do_mutex);\r\nreturn ret;\r\n}\r\nstatic long pp_compat_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nreturn pp_ioctl(file, cmd, (unsigned long)compat_ptr(arg));\r\n}\r\nstatic int pp_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct pp_struct *pp;\r\nif (minor >= PARPORT_MAX)\r\nreturn -ENXIO;\r\npp = kmalloc(sizeof(struct pp_struct), GFP_KERNEL);\r\nif (!pp)\r\nreturn -ENOMEM;\r\npp->state.mode = IEEE1284_MODE_COMPAT;\r\npp->state.phase = init_phase(pp->state.mode);\r\npp->flags = 0;\r\npp->irqresponse = 0;\r\natomic_set(&pp->irqc, 0);\r\ninit_waitqueue_head(&pp->irq_wait);\r\npp->pdev = NULL;\r\nfile->private_data = pp;\r\nreturn 0;\r\n}\r\nstatic int pp_release(struct inode *inode, struct file *file)\r\n{\r\nunsigned int minor = iminor(inode);\r\nstruct pp_struct *pp = file->private_data;\r\nint compat_negot;\r\ncompat_negot = 0;\r\nif (!(pp->flags & PP_CLAIMED) && pp->pdev &&\r\n(pp->state.mode != IEEE1284_MODE_COMPAT)) {\r\nstruct ieee1284_info *info;\r\nparport_claim_or_block(pp->pdev);\r\npp->flags |= PP_CLAIMED;\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->saved_state.mode = info->mode;\r\npp->saved_state.phase = info->phase;\r\ninfo->mode = pp->state.mode;\r\ninfo->phase = pp->state.phase;\r\ncompat_negot = 1;\r\n} else if ((pp->flags & PP_CLAIMED) && pp->pdev &&\r\n(pp->pdev->port->ieee1284.mode != IEEE1284_MODE_COMPAT)) {\r\ncompat_negot = 2;\r\n}\r\nif (compat_negot) {\r\nparport_negotiate(pp->pdev->port, IEEE1284_MODE_COMPAT);\r\ndev_dbg(&pp->pdev->dev,\r\n"negotiated back to compatibility mode because user-space forgot\n");\r\n}\r\nif (pp->flags & PP_CLAIMED) {\r\nstruct ieee1284_info *info;\r\ninfo = &pp->pdev->port->ieee1284;\r\npp->state.mode = info->mode;\r\npp->state.phase = info->phase;\r\ninfo->mode = pp->saved_state.mode;\r\ninfo->phase = pp->saved_state.phase;\r\nparport_release(pp->pdev);\r\nif (compat_negot != 1) {\r\npr_debug(CHRDEV "%x: released pardevice "\r\n"because user-space forgot\n", minor);\r\n}\r\n}\r\nif (pp->pdev) {\r\nparport_unregister_device(pp->pdev);\r\nida_simple_remove(&ida_index, pp->index);\r\npp->pdev = NULL;\r\npr_debug(CHRDEV "%x: unregistered pardevice\n", minor);\r\n}\r\nkfree(pp);\r\nreturn 0;\r\n}\r\nstatic unsigned int pp_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct pp_struct *pp = file->private_data;\r\nunsigned int mask = 0;\r\npoll_wait(file, &pp->irq_wait, wait);\r\nif (atomic_read(&pp->irqc))\r\nmask |= POLLIN | POLLRDNORM;\r\nreturn mask;\r\n}\r\nstatic void pp_attach(struct parport *port)\r\n{\r\nstruct device *ret;\r\nif (devices[port->number])\r\nreturn;\r\nret = device_create(ppdev_class, port->dev,\r\nMKDEV(PP_MAJOR, port->number), NULL,\r\n"parport%d", port->number);\r\nif (IS_ERR(ret)) {\r\npr_err("Failed to create device parport%d\n",\r\nport->number);\r\nreturn;\r\n}\r\ndevices[port->number] = ret;\r\n}\r\nstatic void pp_detach(struct parport *port)\r\n{\r\nif (!devices[port->number])\r\nreturn;\r\ndevice_destroy(ppdev_class, MKDEV(PP_MAJOR, port->number));\r\ndevices[port->number] = NULL;\r\n}\r\nstatic int pp_probe(struct pardevice *par_dev)\r\n{\r\nstruct device_driver *drv = par_dev->dev.driver;\r\nint len = strlen(drv->name);\r\nif (strncmp(par_dev->name, drv->name, len))\r\nreturn -ENODEV;\r\nreturn 0;\r\n}\r\nstatic int __init ppdev_init(void)\r\n{\r\nint err = 0;\r\nif (register_chrdev(PP_MAJOR, CHRDEV, &pp_fops)) {\r\npr_warn(CHRDEV ": unable to get major %d\n", PP_MAJOR);\r\nreturn -EIO;\r\n}\r\nppdev_class = class_create(THIS_MODULE, CHRDEV);\r\nif (IS_ERR(ppdev_class)) {\r\nerr = PTR_ERR(ppdev_class);\r\ngoto out_chrdev;\r\n}\r\nerr = parport_register_driver(&pp_driver);\r\nif (err < 0) {\r\npr_warn(CHRDEV ": unable to register with parport\n");\r\ngoto out_class;\r\n}\r\npr_info(PP_VERSION "\n");\r\ngoto out;\r\nout_class:\r\nclass_destroy(ppdev_class);\r\nout_chrdev:\r\nunregister_chrdev(PP_MAJOR, CHRDEV);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit ppdev_cleanup(void)\r\n{\r\nparport_unregister_driver(&pp_driver);\r\nclass_destroy(ppdev_class);\r\nunregister_chrdev(PP_MAJOR, CHRDEV);\r\n}
