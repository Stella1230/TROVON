static int exynos_clkout_suspend(void)\r\n{\r\nclkout->pmu_debug_save = readl(clkout->reg + EXYNOS_PMU_DEBUG_REG);\r\nreturn 0;\r\n}\r\nstatic void exynos_clkout_resume(void)\r\n{\r\nwritel(clkout->pmu_debug_save, clkout->reg + EXYNOS_PMU_DEBUG_REG);\r\n}\r\nstatic void __init exynos_clkout_init(struct device_node *node, u32 mux_mask)\r\n{\r\nconst char *parent_names[EXYNOS_CLKOUT_PARENTS];\r\nstruct clk *parents[EXYNOS_CLKOUT_PARENTS];\r\nint parent_count;\r\nint ret;\r\nint i;\r\nclkout = kzalloc(sizeof(*clkout), GFP_KERNEL);\r\nif (!clkout)\r\nreturn;\r\nspin_lock_init(&clkout->slock);\r\nparent_count = 0;\r\nfor (i = 0; i < EXYNOS_CLKOUT_PARENTS; ++i) {\r\nchar name[] = "clkoutXX";\r\nsnprintf(name, sizeof(name), "clkout%d", i);\r\nparents[i] = of_clk_get_by_name(node, name);\r\nif (IS_ERR(parents[i])) {\r\nparent_names[i] = "none";\r\ncontinue;\r\n}\r\nparent_names[i] = __clk_get_name(parents[i]);\r\nparent_count = i + 1;\r\n}\r\nif (!parent_count)\r\ngoto free_clkout;\r\nclkout->reg = of_iomap(node, 0);\r\nif (!clkout->reg)\r\ngoto clks_put;\r\nclkout->gate.reg = clkout->reg + EXYNOS_PMU_DEBUG_REG;\r\nclkout->gate.bit_idx = EXYNOS_CLKOUT_DISABLE_SHIFT;\r\nclkout->gate.flags = CLK_GATE_SET_TO_DISABLE;\r\nclkout->gate.lock = &clkout->slock;\r\nclkout->mux.reg = clkout->reg + EXYNOS_PMU_DEBUG_REG;\r\nclkout->mux.mask = mux_mask;\r\nclkout->mux.shift = EXYNOS_CLKOUT_MUX_SHIFT;\r\nclkout->mux.lock = &clkout->slock;\r\nclkout->clk_table[0] = clk_register_composite(NULL, "clkout",\r\nparent_names, parent_count, &clkout->mux.hw,\r\n&clk_mux_ops, NULL, NULL, &clkout->gate.hw,\r\n&clk_gate_ops, CLK_SET_RATE_PARENT\r\n| CLK_SET_RATE_NO_REPARENT);\r\nif (IS_ERR(clkout->clk_table[0]))\r\ngoto err_unmap;\r\nclkout->data.clks = clkout->clk_table;\r\nclkout->data.clk_num = EXYNOS_CLKOUT_NR_CLKS;\r\nret = of_clk_add_provider(node, of_clk_src_onecell_get, &clkout->data);\r\nif (ret)\r\ngoto err_clk_unreg;\r\nregister_syscore_ops(&exynos_clkout_syscore_ops);\r\nreturn;\r\nerr_clk_unreg:\r\nclk_unregister(clkout->clk_table[0]);\r\nerr_unmap:\r\niounmap(clkout->reg);\r\nclks_put:\r\nfor (i = 0; i < EXYNOS_CLKOUT_PARENTS; ++i)\r\nif (!IS_ERR(parents[i]))\r\nclk_put(parents[i]);\r\nfree_clkout:\r\nkfree(clkout);\r\npr_err("%s: failed to register clkout clock\n", __func__);\r\n}\r\nstatic void __init exynos4_clkout_init(struct device_node *node)\r\n{\r\nexynos_clkout_init(node, EXYNOS4_CLKOUT_MUX_MASK);\r\n}\r\nstatic void __init exynos5_clkout_init(struct device_node *node)\r\n{\r\nexynos_clkout_init(node, EXYNOS5_CLKOUT_MUX_MASK);\r\n}
