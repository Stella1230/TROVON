static inline int frame_size(u32 w, u32 h, u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\nreturn (w * h * 3) / 2;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic inline int frame_stride(u32 w, u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\nreturn w;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void dump_au(struct delta_ctx *ctx, struct delta_au *au)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nu32 size = 10;\r\nu8 *data = (u8 *)(au->vaddr);\r\nif (au->size <= (size * 2))\r\ndev_dbg(delta->dev, "%s dump au[%d] dts=%lld size=%d data=%*ph\n",\r\nctx->name, au->vbuf.vb2_buf.index, au->dts, au->size,\r\nau->size, data);\r\nelse\r\ndev_dbg(delta->dev, "%s dump au[%d] dts=%lld size=%d data=%*ph..%*ph\n",\r\nctx->name, au->vbuf.vb2_buf.index, au->dts, au->size,\r\nsize, data, size, data + au->size - size);\r\n}\r\nstatic void dump_frame(struct delta_ctx *ctx, struct delta_frame *frame)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nu32 size = 10;\r\nu8 *data = (u8 *)(frame->vaddr);\r\ndev_dbg(delta->dev, "%s dump frame[%d] dts=%lld type=%s field=%s data=%*ph\n",\r\nctx->name, frame->index, frame->dts,\r\nframe_type_str(frame->flags),\r\nframe_field_str(frame->field),\r\nsize, data);\r\n}\r\nstatic void delta_au_done(struct delta_ctx *ctx, struct delta_au *au, int err)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf;\r\nvbuf = &au->vbuf;\r\nvbuf->sequence = ctx->au_num++;\r\nv4l2_m2m_buf_done(vbuf, err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\n}\r\nstatic void delta_frame_done(struct delta_ctx *ctx, struct delta_frame *frame,\r\nint err)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf;\r\ndump_frame(ctx, frame);\r\nframe->state |= DELTA_FRAME_OUT;\r\nvbuf = &frame->vbuf;\r\nvbuf->sequence = ctx->frame_num++;\r\nv4l2_m2m_buf_done(vbuf, err ? VB2_BUF_STATE_ERROR : VB2_BUF_STATE_DONE);\r\nif (frame->info.size)\r\nctx->output_frames++;\r\n}\r\nstatic void requeue_free_frames(struct delta_ctx *ctx)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf;\r\nstruct delta_frame *frame;\r\nunsigned int i;\r\nfor (i = 0; i < ctx->nb_of_frames; i++) {\r\nframe = ctx->frames[i];\r\nif (frame->state == DELTA_FRAME_FREE) {\r\nvbuf = &frame->vbuf;\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\nframe->state = DELTA_FRAME_M2M;\r\n}\r\n}\r\n}\r\nstatic int delta_recycle(struct delta_ctx *ctx, struct delta_frame *frame)\r\n{\r\nconst struct delta_dec *dec = ctx->dec;\r\ncall_dec_op(dec, recycle, ctx, frame);\r\nframe->state &= ~DELTA_FRAME_OUT;\r\nif (frame->state == DELTA_FRAME_FREE) {\r\nstruct vb2_v4l2_buffer *vbuf = &frame->vbuf;\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\nframe->state = DELTA_FRAME_M2M;\r\n}\r\nframe->flags = 0;\r\nframe->dts = 0;\r\nreturn 0;\r\n}\r\nstatic void delta_push_dts(struct delta_ctx *ctx, u64 val)\r\n{\r\nstruct delta_dts *dts;\r\ndts = kzalloc(sizeof(*dts), GFP_KERNEL);\r\nif (!dts)\r\nreturn;\r\nINIT_LIST_HEAD(&dts->list);\r\ndts->val = val;\r\nlist_add_tail(&dts->list, &ctx->dts);\r\n}\r\nstatic void delta_pop_dts(struct delta_ctx *ctx, u64 *val)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct delta_dts *dts;\r\nif (list_empty(&ctx->dts)) {\r\ndev_warn(delta->dev, "%s no dts to pop ... output dts = 0\n",\r\nctx->name);\r\n*val = 0;\r\nreturn;\r\n}\r\ndts = list_first_entry(&ctx->dts, struct delta_dts, list);\r\nlist_del(&dts->list);\r\n*val = dts->val;\r\nkfree(dts);\r\n}\r\nstatic void delta_flush_dts(struct delta_ctx *ctx)\r\n{\r\nstruct delta_dts *dts;\r\nstruct delta_dts *next;\r\nlist_for_each_entry_safe(dts, next, &ctx->dts, list)\r\nkfree(dts);\r\nINIT_LIST_HEAD(&ctx->dts);\r\n}\r\nstatic inline int frame_alignment(u32 fmt)\r\n{\r\nswitch (fmt) {\r\ncase V4L2_PIX_FMT_NV12:\r\ncase V4L2_PIX_FMT_NV21:\r\nreturn 2;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nstatic inline int estimated_au_size(u32 w, u32 h)\r\n{\r\nreturn (w * h);\r\n}\r\nstatic void set_default_params(struct delta_ctx *ctx)\r\n{\r\nstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\r\nstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\r\nmemset(frameinfo, 0, sizeof(*frameinfo));\r\nframeinfo->pixelformat = V4L2_PIX_FMT_NV12;\r\nframeinfo->width = DELTA_DEFAULT_WIDTH;\r\nframeinfo->height = DELTA_DEFAULT_HEIGHT;\r\nframeinfo->aligned_width = ALIGN(frameinfo->width,\r\nDELTA_WIDTH_ALIGNMENT);\r\nframeinfo->aligned_height = ALIGN(frameinfo->height,\r\nDELTA_HEIGHT_ALIGNMENT);\r\nframeinfo->size = frame_size(frameinfo->aligned_width,\r\nframeinfo->aligned_height,\r\nframeinfo->pixelformat);\r\nframeinfo->field = V4L2_FIELD_NONE;\r\nframeinfo->colorspace = V4L2_COLORSPACE_REC709;\r\nframeinfo->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\nframeinfo->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nframeinfo->quantization = V4L2_QUANTIZATION_DEFAULT;\r\nmemset(streaminfo, 0, sizeof(*streaminfo));\r\nstreaminfo->streamformat = DELTA_DEFAULT_STREAMFORMAT;\r\nstreaminfo->width = DELTA_DEFAULT_WIDTH;\r\nstreaminfo->height = DELTA_DEFAULT_HEIGHT;\r\nstreaminfo->field = V4L2_FIELD_NONE;\r\nstreaminfo->colorspace = V4L2_COLORSPACE_REC709;\r\nstreaminfo->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\nstreaminfo->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\nstreaminfo->quantization = V4L2_QUANTIZATION_DEFAULT;\r\nctx->max_au_size = estimated_au_size(streaminfo->width,\r\nstreaminfo->height);\r\n}\r\nstatic const struct delta_dec *delta_find_decoder(struct delta_ctx *ctx,\r\nu32 streamformat,\r\nu32 pixelformat)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec;\r\nunsigned int i;\r\nfor (i = 0; i < delta->nb_of_decoders; i++) {\r\ndec = delta->decoders[i];\r\nif ((dec->pixelformat == pixelformat) &&\r\n(dec->streamformat == streamformat))\r\nreturn dec;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void register_format(u32 format, u32 formats[], u32 *nb_of_formats)\r\n{\r\nu32 i;\r\nfor (i = 0; i < *nb_of_formats; i++) {\r\nif (format == formats[i])\r\nreturn;\r\n}\r\nformats[(*nb_of_formats)++] = format;\r\n}\r\nstatic void register_formats(struct delta_dev *delta)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < delta->nb_of_decoders; i++) {\r\nregister_format(delta->decoders[i]->pixelformat,\r\ndelta->pixelformats,\r\n&delta->nb_of_pixelformats);\r\nregister_format(delta->decoders[i]->streamformat,\r\ndelta->streamformats,\r\n&delta->nb_of_streamformats);\r\n}\r\n}\r\nstatic void register_decoders(struct delta_dev *delta)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(delta_decoders); i++) {\r\nif (delta->nb_of_decoders >= DELTA_MAX_DECODERS) {\r\ndev_dbg(delta->dev,\r\n"%s failed to register %s decoder (%d maximum reached)\n",\r\nDELTA_PREFIX, delta_decoders[i]->name,\r\nDELTA_MAX_DECODERS);\r\nreturn;\r\n}\r\ndelta->decoders[delta->nb_of_decoders++] = delta_decoders[i];\r\ndev_info(delta->dev, "%s %s decoder registered\n",\r\nDELTA_PREFIX, delta_decoders[i]->name);\r\n}\r\n}\r\nstatic void delta_lock(void *priv)\r\n{\r\nstruct delta_ctx *ctx = priv;\r\nstruct delta_dev *delta = ctx->dev;\r\nmutex_lock(&delta->lock);\r\n}\r\nstatic void delta_unlock(void *priv)\r\n{\r\nstruct delta_ctx *ctx = priv;\r\nstruct delta_dev *delta = ctx->dev;\r\nmutex_unlock(&delta->lock);\r\n}\r\nstatic int delta_open_decoder(struct delta_ctx *ctx, u32 streamformat,\r\nu32 pixelformat, const struct delta_dec **pdec)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec;\r\nint ret;\r\ndec = delta_find_decoder(ctx, streamformat, ctx->frameinfo.pixelformat);\r\nif (!dec) {\r\ndev_err(delta->dev, "%s no decoder found matching %4.4s => %4.4s\n",\r\nctx->name, (char *)&streamformat, (char *)&pixelformat);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(delta->dev, "%s one decoder matching %4.4s => %4.4s\n",\r\nctx->name, (char *)&streamformat, (char *)&pixelformat);\r\nsnprintf(ctx->name, sizeof(ctx->name), "[%3d:%4.4s]",\r\ndelta->instance_id, (char *)&streamformat);\r\nret = call_dec_op(dec, open, ctx);\r\nif (ret) {\r\ndev_err(delta->dev, "%s failed to open decoder instance (%d)\n",\r\nctx->name, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(delta->dev, "%s %s decoder opened\n", ctx->name, dec->name);\r\n*pdec = dec;\r\nreturn ret;\r\n}\r\nstatic int delta_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nstrlcpy(cap->driver, DELTA_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, delta->vdev->name, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",\r\ndelta->pdev->name);\r\nreturn 0;\r\n}\r\nstatic int delta_enum_fmt_stream(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nif (unlikely(f->index >= delta->nb_of_streamformats))\r\nreturn -EINVAL;\r\nf->pixelformat = delta->streamformats[f->index];\r\nreturn 0;\r\n}\r\nstatic int delta_enum_fmt_frame(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nif (unlikely(f->index >= delta->nb_of_pixelformats))\r\nreturn -EINVAL;\r\nf->pixelformat = delta->pixelformats[f->index];\r\nreturn 0;\r\n}\r\nstatic int delta_g_fmt_stream(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\r\nunsigned char str[100] = "";\r\nif (!(ctx->flags & DELTA_FLAG_STREAMINFO))\r\ndev_dbg(delta->dev,\r\n"%s V4L2 GET_FMT (OUTPUT): no stream information available, default to %s\n",\r\nctx->name,\r\ndelta_streaminfo_str(streaminfo, str, sizeof(str)));\r\npix->pixelformat = streaminfo->streamformat;\r\npix->width = streaminfo->width;\r\npix->height = streaminfo->height;\r\npix->field = streaminfo->field;\r\npix->bytesperline = 0;\r\npix->sizeimage = ctx->max_au_size;\r\npix->colorspace = streaminfo->colorspace;\r\npix->xfer_func = streaminfo->xfer_func;\r\npix->ycbcr_enc = streaminfo->ycbcr_enc;\r\npix->quantization = streaminfo->quantization;\r\nreturn 0;\r\n}\r\nstatic int delta_g_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\r\nstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\r\nunsigned char str[100] = "";\r\nif (!(ctx->flags & DELTA_FLAG_FRAMEINFO))\r\ndev_dbg(delta->dev,\r\n"%s V4L2 GET_FMT (CAPTURE): no frame information available, default to %s\n",\r\nctx->name,\r\ndelta_frameinfo_str(frameinfo, str, sizeof(str)));\r\npix->pixelformat = frameinfo->pixelformat;\r\npix->width = frameinfo->aligned_width;\r\npix->height = frameinfo->aligned_height;\r\npix->field = frameinfo->field;\r\npix->bytesperline = frame_stride(frameinfo->aligned_width,\r\nframeinfo->pixelformat);\r\npix->sizeimage = frameinfo->size;\r\nif (ctx->flags & DELTA_FLAG_STREAMINFO) {\r\nframeinfo->colorspace = streaminfo->colorspace;\r\nframeinfo->xfer_func = streaminfo->xfer_func;\r\nframeinfo->ycbcr_enc = streaminfo->ycbcr_enc;\r\nframeinfo->quantization = streaminfo->quantization;\r\n}\r\npix->colorspace = frameinfo->colorspace;\r\npix->xfer_func = frameinfo->xfer_func;\r\npix->ycbcr_enc = frameinfo->ycbcr_enc;\r\npix->quantization = frameinfo->quantization;\r\nreturn 0;\r\n}\r\nstatic int delta_try_fmt_stream(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nu32 streamformat = pix->pixelformat;\r\nconst struct delta_dec *dec;\r\nu32 width, height;\r\nu32 au_size;\r\ndec = delta_find_decoder(ctx, streamformat, ctx->frameinfo.pixelformat);\r\nif (!dec) {\r\ndev_dbg(delta->dev,\r\n"%s V4L2 TRY_FMT (OUTPUT): unsupported format %4.4s\n",\r\nctx->name, (char *)&pix->pixelformat);\r\nreturn -EINVAL;\r\n}\r\nwidth = pix->width;\r\nheight = pix->height;\r\nv4l_bound_align_image\r\n(&pix->width,\r\nDELTA_MIN_WIDTH,\r\ndec->max_width ? dec->max_width : DELTA_MAX_WIDTH,\r\n0,\r\n&pix->height,\r\nDELTA_MIN_HEIGHT,\r\ndec->max_height ? dec->max_height : DELTA_MAX_HEIGHT,\r\n0, 0);\r\nif ((pix->width != width) || (pix->height != height))\r\ndev_dbg(delta->dev,\r\n"%s V4L2 TRY_FMT (OUTPUT): resolution updated %dx%d -> %dx%d to fit min/max/alignment\n",\r\nctx->name, width, height,\r\npix->width, pix->height);\r\nau_size = estimated_au_size(pix->width, pix->height);\r\nif (pix->sizeimage < au_size) {\r\ndev_dbg(delta->dev,\r\n"%s V4L2 TRY_FMT (OUTPUT): size updated %d -> %d to fit estimated size\n",\r\nctx->name, pix->sizeimage, au_size);\r\npix->sizeimage = au_size;\r\n}\r\npix->bytesperline = 0;\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int delta_try_fmt_frame(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nu32 pixelformat = pix->pixelformat;\r\nconst struct delta_dec *dec;\r\nu32 width, height;\r\ndec = delta_find_decoder(ctx, ctx->streaminfo.streamformat,\r\npixelformat);\r\nif (!dec) {\r\ndev_dbg(delta->dev,\r\n"%s V4L2 TRY_FMT (CAPTURE): unsupported format %4.4s\n",\r\nctx->name, (char *)&pixelformat);\r\nreturn -EINVAL;\r\n}\r\nwidth = pix->width;\r\nheight = pix->height;\r\nv4l_bound_align_image(&pix->width,\r\nDELTA_MIN_WIDTH, DELTA_MAX_WIDTH,\r\nframe_alignment(pixelformat) - 1,\r\n&pix->height,\r\nDELTA_MIN_HEIGHT, DELTA_MAX_HEIGHT,\r\nframe_alignment(pixelformat) - 1, 0);\r\nif ((pix->width != width) || (pix->height != height))\r\ndev_dbg(delta->dev,\r\n"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit min/max/alignment\n",\r\nctx->name, width, height, pix->width, pix->height);\r\nwidth = ALIGN(pix->width, DELTA_WIDTH_ALIGNMENT);\r\nheight = ALIGN(pix->height, DELTA_HEIGHT_ALIGNMENT);\r\nif ((pix->width != width) || (pix->height != height))\r\ndev_dbg(delta->dev,\r\n"%s V4L2 TRY_FMT (CAPTURE): resolution updated %dx%d -> %dx%d to fit decoder alignment\n",\r\nctx->name, width, height, pix->width, pix->height);\r\nif (!pix->colorspace) {\r\npix->colorspace = V4L2_COLORSPACE_REC709;\r\npix->xfer_func = V4L2_XFER_FUNC_DEFAULT;\r\npix->ycbcr_enc = V4L2_YCBCR_ENC_DEFAULT;\r\npix->quantization = V4L2_QUANTIZATION_DEFAULT;\r\n}\r\npix->width = width;\r\npix->height = height;\r\npix->bytesperline = frame_stride(pix->width, pixelformat);\r\npix->sizeimage = frame_size(pix->width, pix->height, pixelformat);\r\nif (pix->field == V4L2_FIELD_ANY)\r\npix->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int delta_s_fmt_stream(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct vb2_queue *vq;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nint ret;\r\nret = delta_try_fmt_stream(file, fh, f);\r\nif (ret) {\r\ndev_dbg(delta->dev,\r\n"%s V4L2 S_FMT (OUTPUT): unsupported format %4.4s\n",\r\nctx->name, (char *)&pix->pixelformat);\r\nreturn ret;\r\n}\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\ndev_dbg(delta->dev, "%s V4L2 S_FMT (OUTPUT): queue busy\n",\r\nctx->name);\r\nreturn -EBUSY;\r\n}\r\nctx->max_au_size = pix->sizeimage;\r\nctx->streaminfo.width = pix->width;\r\nctx->streaminfo.height = pix->height;\r\nctx->streaminfo.streamformat = pix->pixelformat;\r\nctx->streaminfo.colorspace = pix->colorspace;\r\nctx->streaminfo.xfer_func = pix->xfer_func;\r\nctx->streaminfo.ycbcr_enc = pix->ycbcr_enc;\r\nctx->streaminfo.quantization = pix->quantization;\r\nctx->flags |= DELTA_FLAG_STREAMINFO;\r\nreturn 0;\r\n}\r\nstatic int delta_s_fmt_frame(struct file *file, void *fh, struct v4l2_format *f)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec = ctx->dec;\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nstruct delta_frameinfo frameinfo;\r\nunsigned char str[100] = "";\r\nstruct vb2_queue *vq;\r\nint ret;\r\nvq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\ndev_dbg(delta->dev, "%s V4L2 S_FMT (CAPTURE): queue busy\n",\r\nctx->name);\r\nreturn -EBUSY;\r\n}\r\nif (ctx->state < DELTA_STATE_READY) {\r\nret = delta_try_fmt_frame(file, fh, f);\r\nif (ret) {\r\ndev_dbg(delta->dev,\r\n"%s V4L2 S_FMT (CAPTURE): unsupported format %4.4s\n",\r\nctx->name, (char *)&pix->pixelformat);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nmemset(&frameinfo, 0, sizeof(frameinfo));\r\nframeinfo.pixelformat = pix->pixelformat;\r\nframeinfo.width = pix->width;\r\nframeinfo.height = pix->height;\r\nframeinfo.aligned_width = pix->width;\r\nframeinfo.aligned_height = pix->height;\r\nframeinfo.size = pix->sizeimage;\r\nframeinfo.field = pix->field;\r\nframeinfo.colorspace = pix->colorspace;\r\nframeinfo.xfer_func = pix->xfer_func;\r\nframeinfo.ycbcr_enc = pix->ycbcr_enc;\r\nframeinfo.quantization = pix->quantization;\r\nret = call_dec_op(dec, set_frameinfo, ctx, &frameinfo);\r\nif (ret)\r\nreturn ret;\r\nret = call_dec_op(dec, get_frameinfo, ctx, &frameinfo);\r\nif (ret)\r\nreturn ret;\r\nctx->flags |= DELTA_FLAG_FRAMEINFO;\r\nctx->frameinfo = frameinfo;\r\ndev_dbg(delta->dev,\r\n"%s V4L2 SET_FMT (CAPTURE): frameinfo updated to %s\n",\r\nctx->name,\r\ndelta_frameinfo_str(&frameinfo, str, sizeof(str)));\r\npix->pixelformat = frameinfo.pixelformat;\r\npix->width = frameinfo.aligned_width;\r\npix->height = frameinfo.aligned_height;\r\npix->bytesperline = frame_stride(pix->width, pix->pixelformat);\r\npix->sizeimage = frameinfo.size;\r\npix->field = frameinfo.field;\r\npix->colorspace = frameinfo.colorspace;\r\npix->xfer_func = frameinfo.xfer_func;\r\npix->ycbcr_enc = frameinfo.ycbcr_enc;\r\npix->quantization = frameinfo.quantization;\r\nreturn 0;\r\n}\r\nstatic int delta_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(fh);\r\nstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\r\nstruct v4l2_rect crop;\r\nif (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)\r\nreturn -EINVAL;\r\nif ((ctx->flags & DELTA_FLAG_FRAMEINFO) &&\r\n(frameinfo->flags & DELTA_FRAMEINFO_FLAG_CROP)) {\r\ncrop = frameinfo->crop;\r\n} else {\r\ncrop.left = 0;\r\ncrop.top = 0;\r\ncrop.width = frameinfo->width;\r\ncrop.height = frameinfo->height;\r\n}\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ns->r = crop;\r\nbreak;\r\ncase V4L2_SEL_TGT_COMPOSE_PADDED:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = frameinfo->aligned_width;\r\ns->r.height = frameinfo->aligned_height;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void delta_complete_eos(struct delta_ctx *ctx,\r\nstruct delta_frame *frame)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct v4l2_event ev = {.type = V4L2_EVENT_EOS};\r\nframe->info.size = 0;\r\nframe->flags |= V4L2_BUF_FLAG_LAST;\r\ndelta_frame_done(ctx, frame, 0);\r\nv4l2_event_queue_fh(&ctx->fh, &ev);\r\ndev_dbg(delta->dev, "%s EOS completed\n", ctx->name);\r\n}\r\nstatic int delta_try_decoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_decoder_cmd *cmd)\r\n{\r\nif (cmd->cmd != V4L2_DEC_CMD_STOP)\r\nreturn -EINVAL;\r\nif (cmd->flags & V4L2_DEC_CMD_STOP_TO_BLACK)\r\nreturn -EINVAL;\r\nif (!(cmd->flags & V4L2_DEC_CMD_STOP_IMMEDIATELY) &&\r\n(cmd->stop.pts != 0))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int delta_decoder_stop_cmd(struct delta_ctx *ctx, void *fh)\r\n{\r\nconst struct delta_dec *dec = ctx->dec;\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct delta_frame *frame = NULL;\r\nint ret = 0;\r\ndev_dbg(delta->dev, "%s EOS received\n", ctx->name);\r\nif (ctx->state != DELTA_STATE_READY)\r\nreturn 0;\r\ncall_dec_op(dec, drain, ctx);\r\nwhile (1) {\r\nframe = NULL;\r\nret = call_dec_op(dec, get_frame, ctx, &frame);\r\nif (ret == -ENODATA) {\r\nbreak;\r\n}\r\nif (frame) {\r\ndev_dbg(delta->dev, "%s drain frame[%d]\n",\r\nctx->name, frame->index);\r\ndelta_pop_dts(ctx, &frame->dts);\r\ndelta_frame_done(ctx, frame, 0);\r\n}\r\n}\r\nret = delta_get_free_frame(ctx, &frame);\r\nif (ret)\r\ngoto delay_eos;\r\ndelta_complete_eos(ctx, frame);\r\nctx->state = DELTA_STATE_EOS;\r\nreturn 0;\r\ndelay_eos:\r\nctx->state = DELTA_STATE_WF_EOS;\r\ndev_dbg(delta->dev, "%s EOS delayed\n", ctx->name);\r\nreturn 0;\r\n}\r\nstatic int delta_decoder_cmd(struct file *file, void *fh,\r\nstruct v4l2_decoder_cmd *cmd)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(fh);\r\nint ret = 0;\r\nret = delta_try_decoder_cmd(file, fh, cmd);\r\nif (ret)\r\nreturn ret;\r\nreturn delta_decoder_stop_cmd(ctx, fh);\r\n}\r\nstatic int delta_subscribe_event(struct v4l2_fh *fh,\r\nconst struct v4l2_event_subscription *sub)\r\n{\r\nswitch (sub->type) {\r\ncase V4L2_EVENT_EOS:\r\nreturn v4l2_event_subscribe(fh, sub, 2, NULL);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void delta_run_work(struct work_struct *work)\r\n{\r\nstruct delta_ctx *ctx = container_of(work, struct delta_ctx, run_work);\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec = ctx->dec;\r\nstruct delta_au *au;\r\nstruct delta_frame *frame = NULL;\r\nint ret = 0;\r\nbool discard = false;\r\nstruct vb2_v4l2_buffer *vbuf;\r\nif (!dec) {\r\ndev_err(delta->dev, "%s no decoder opened yet\n", ctx->name);\r\nreturn;\r\n}\r\nmutex_lock(&ctx->lock);\r\nvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nif (!vbuf) {\r\ndev_err(delta->dev, "%s no buffer to decode\n", ctx->name);\r\nmutex_unlock(&ctx->lock);\r\nreturn;\r\n}\r\nau = to_au(vbuf);\r\nau->size = vb2_get_plane_payload(&vbuf->vb2_buf, 0);\r\nau->dts = vbuf->vb2_buf.timestamp;\r\ndump_au(ctx, au);\r\nif (!dec->pm) {\r\nret = delta_get_sync(ctx);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = call_dec_op(dec, decode, ctx, au);\r\nif (ret == -ENODATA) {\r\ndiscard = true;\r\n} else if (ret) {\r\ndev_err(delta->dev, "%s decoding failed (%d)\n",\r\nctx->name, ret);\r\nif (!dec->pm)\r\ndelta_put_autosuspend(ctx);\r\ngoto err;\r\n}\r\nif (!dec->pm)\r\ndelta_put_autosuspend(ctx);\r\nif (!discard)\r\ndelta_push_dts(ctx, au->dts);\r\nwhile (1) {\r\nret = call_dec_op(dec, get_frame, ctx, &frame);\r\nif (ret == -ENODATA) {\r\ngoto out;\r\n}\r\nif (ret) {\r\ndev_err(delta->dev, "%s cannot get decoded frame (%d)\n",\r\nctx->name, ret);\r\ngoto out;\r\n}\r\nif (!frame) {\r\ndev_err(delta->dev,\r\n"%s NULL decoded frame\n",\r\nctx->name);\r\nret = -EIO;\r\ngoto out;\r\n}\r\ndelta_pop_dts(ctx, &frame->dts);\r\ndelta_frame_done(ctx, frame, 0);\r\n}\r\nout:\r\nrequeue_free_frames(ctx);\r\ndelta_au_done(ctx, au, (discard ? -ENODATA : 0));\r\nmutex_unlock(&ctx->lock);\r\nv4l2_m2m_job_finish(delta->m2m_dev, ctx->fh.m2m_ctx);\r\nreturn;\r\nerr:\r\nrequeue_free_frames(ctx);\r\ndelta_au_done(ctx, au, ret);\r\nmutex_unlock(&ctx->lock);\r\nv4l2_m2m_job_finish(delta->m2m_dev, ctx->fh.m2m_ctx);\r\n}\r\nstatic void delta_device_run(void *priv)\r\n{\r\nstruct delta_ctx *ctx = priv;\r\nstruct delta_dev *delta = ctx->dev;\r\nqueue_work(delta->work_queue, &ctx->run_work);\r\n}\r\nstatic void delta_job_abort(void *priv)\r\n{\r\nstruct delta_ctx *ctx = priv;\r\nstruct delta_dev *delta = ctx->dev;\r\ndev_dbg(delta->dev, "%s aborting job\n", ctx->name);\r\nctx->aborting = true;\r\n}\r\nstatic int delta_job_ready(void *priv)\r\n{\r\nstruct delta_ctx *ctx = priv;\r\nstruct delta_dev *delta = ctx->dev;\r\nint src_bufs = v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx);\r\nif (!src_bufs) {\r\ndev_dbg(delta->dev, "%s not ready: not enough video buffers.\n",\r\nctx->name);\r\nreturn 0;\r\n}\r\nif (!v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx)) {\r\ndev_dbg(delta->dev, "%s not ready: not enough video capture buffers.\n",\r\nctx->name);\r\nreturn 0;\r\n}\r\nif (ctx->aborting) {\r\ndev_dbg(delta->dev, "%s job not ready: aborting\n", ctx->name);\r\nreturn 0;\r\n}\r\ndev_dbg(delta->dev, "%s job ready\n", ctx->name);\r\nreturn 1;\r\n}\r\nstatic int delta_vb2_au_queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers,\r\nunsigned int *num_planes,\r\nunsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(vq);\r\nunsigned int size = ctx->max_au_size;\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nif (*num_buffers < 1)\r\n*num_buffers = 1;\r\nif (*num_buffers > DELTA_MAX_AUS)\r\n*num_buffers = DELTA_MAX_AUS;\r\nsizes[0] = size;\r\nreturn 0;\r\n}\r\nstatic int delta_vb2_au_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct delta_au *au = to_au(vbuf);\r\nif (!au->prepared) {\r\nau->vaddr = vb2_plane_vaddr(&au->vbuf.vb2_buf, 0);\r\nau->paddr = vb2_dma_contig_plane_dma_addr\r\n(&au->vbuf.vb2_buf, 0);\r\nau->prepared = true;\r\ndev_dbg(delta->dev, "%s au[%d] prepared; virt=0x%p, phy=0x%pad\n",\r\nctx->name, vb->index, au->vaddr, &au->paddr);\r\n}\r\nif (vbuf->field == V4L2_FIELD_ANY)\r\nvbuf->field = V4L2_FIELD_NONE;\r\nreturn 0;\r\n}\r\nstatic int delta_setup_frame(struct delta_ctx *ctx,\r\nstruct delta_frame *frame)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec = ctx->dec;\r\nif (frame->index >= DELTA_MAX_FRAMES) {\r\ndev_err(delta->dev,\r\n"%s frame index=%d exceeds output frame count (%d)\n",\r\nctx->name, frame->index, DELTA_MAX_FRAMES);\r\nreturn -EINVAL;\r\n}\r\nif (ctx->nb_of_frames >= DELTA_MAX_FRAMES) {\r\ndev_err(delta->dev,\r\n"%s number of frames exceeds output frame count (%d > %d)\n",\r\nctx->name, ctx->nb_of_frames, DELTA_MAX_FRAMES);\r\nreturn -EINVAL;\r\n}\r\nif (frame->index != ctx->nb_of_frames) {\r\ndev_warn(delta->dev,\r\n"%s frame index discontinuity detected, expected %d, got %d\n",\r\nctx->name, ctx->nb_of_frames, frame->index);\r\n}\r\nframe->state = DELTA_FRAME_FREE;\r\nctx->frames[ctx->nb_of_frames] = frame;\r\nctx->nb_of_frames++;\r\nreturn call_dec_op(dec, setup_frame, ctx, frame);\r\n}\r\nint delta_get_frameinfo_default(struct delta_ctx *ctx,\r\nstruct delta_frameinfo *frameinfo)\r\n{\r\nstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\r\nmemset(frameinfo, 0, sizeof(*frameinfo));\r\nframeinfo->pixelformat = V4L2_PIX_FMT_NV12;\r\nframeinfo->width = streaminfo->width;\r\nframeinfo->height = streaminfo->height;\r\nframeinfo->aligned_width = ALIGN(streaminfo->width,\r\nDELTA_WIDTH_ALIGNMENT);\r\nframeinfo->aligned_height = ALIGN(streaminfo->height,\r\nDELTA_HEIGHT_ALIGNMENT);\r\nframeinfo->size = frame_size(frameinfo->aligned_width,\r\nframeinfo->aligned_height,\r\nframeinfo->pixelformat);\r\nif (streaminfo->flags & DELTA_STREAMINFO_FLAG_CROP) {\r\nframeinfo->flags |= DELTA_FRAMEINFO_FLAG_CROP;\r\nframeinfo->crop = streaminfo->crop;\r\n}\r\nif (streaminfo->flags & DELTA_STREAMINFO_FLAG_PIXELASPECT) {\r\nframeinfo->flags |= DELTA_FRAMEINFO_FLAG_PIXELASPECT;\r\nframeinfo->pixelaspect = streaminfo->pixelaspect;\r\n}\r\nframeinfo->field = streaminfo->field;\r\nreturn 0;\r\n}\r\nint delta_recycle_default(struct delta_ctx *pctx,\r\nstruct delta_frame *frame)\r\n{\r\nframe->state &= ~DELTA_FRAME_DEC;\r\nreturn 0;\r\n}\r\nstatic void dump_frames_status(struct delta_ctx *ctx)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nunsigned int i;\r\nstruct delta_frame *frame;\r\nunsigned char str[100] = "";\r\ndev_info(delta->dev,\r\n"%s dumping frames status...\n", ctx->name);\r\nfor (i = 0; i < ctx->nb_of_frames; i++) {\r\nframe = ctx->frames[i];\r\ndev_info(delta->dev,\r\n"%s frame[%d] %s\n",\r\nctx->name, frame->index,\r\nframe_state_str(frame->state,\r\nstr, sizeof(str)));\r\n}\r\n}\r\nint delta_get_free_frame(struct delta_ctx *ctx,\r\nstruct delta_frame **pframe)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct vb2_v4l2_buffer *vbuf;\r\nstruct delta_frame *frame;\r\n*pframe = NULL;\r\nvbuf = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);\r\nif (!vbuf) {\r\ndev_err(delta->dev, "%s no frame available",\r\nctx->name);\r\nreturn -EIO;\r\n}\r\nframe = to_frame(vbuf);\r\nframe->state &= ~DELTA_FRAME_M2M;\r\nif (frame->state != DELTA_FRAME_FREE) {\r\ndev_err(delta->dev,\r\n"%s frame[%d] is not free\n",\r\nctx->name, frame->index);\r\ndump_frames_status(ctx);\r\nreturn -ENODATA;\r\n}\r\ndev_dbg(delta->dev,\r\n"%s get free frame[%d]\n", ctx->name, frame->index);\r\n*pframe = frame;\r\nreturn 0;\r\n}\r\nint delta_get_sync(struct delta_ctx *ctx)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\nint ret = 0;\r\nret = pm_runtime_get_sync(delta->dev);\r\nif (ret < 0) {\r\ndev_err(delta->dev, "%s pm_runtime_get_sync failed (%d)\n",\r\n__func__, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nvoid delta_put_autosuspend(struct delta_ctx *ctx)\r\n{\r\nstruct delta_dev *delta = ctx->dev;\r\npm_runtime_put_autosuspend(delta->dev);\r\n}\r\nstatic void delta_vb2_au_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nv4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);\r\n}\r\nstatic int delta_vb2_au_start_streaming(struct vb2_queue *q,\r\nunsigned int count)\r\n{\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec = ctx->dec;\r\nstruct delta_au *au;\r\nint ret = 0;\r\nstruct vb2_v4l2_buffer *vbuf = NULL;\r\nstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\r\nstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\r\nunsigned char str1[100] = "";\r\nunsigned char str2[100] = "";\r\nif ((ctx->state != DELTA_STATE_WF_FORMAT) &&\r\n(ctx->state != DELTA_STATE_WF_STREAMINFO))\r\nreturn 0;\r\nif (ctx->state == DELTA_STATE_WF_FORMAT) {\r\nret = delta_open_decoder(ctx,\r\nctx->streaminfo.streamformat,\r\nctx->frameinfo.pixelformat, &dec);\r\nif (ret)\r\ngoto err;\r\nctx->dec = dec;\r\nctx->state = DELTA_STATE_WF_STREAMINFO;\r\n}\r\nvbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);\r\nif (!vbuf) {\r\ndev_err(delta->dev, "%s failed to start streaming, no stream header buffer enqueued\n",\r\nctx->name);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nau = to_au(vbuf);\r\nau->size = vb2_get_plane_payload(&vbuf->vb2_buf, 0);\r\nau->dts = vbuf->vb2_buf.timestamp;\r\ndelta_push_dts(ctx, au->dts);\r\ndump_au(ctx, au);\r\nret = call_dec_op(dec, decode, ctx, au);\r\nif (ret) {\r\ndev_err(delta->dev, "%s failed to start streaming, header decoding failed (%d)\n",\r\nctx->name, ret);\r\ngoto err;\r\n}\r\nret = call_dec_op(dec, get_streaminfo, ctx, streaminfo);\r\nif (ret) {\r\ndev_dbg_ratelimited(delta->dev,\r\n"%s failed to start streaming, valid stream header not yet decoded\n",\r\nctx->name);\r\ngoto err;\r\n}\r\nctx->flags |= DELTA_FLAG_STREAMINFO;\r\nret = call_dec_op(dec, get_frameinfo, ctx, frameinfo);\r\nif (ret)\r\ngoto err;\r\nctx->flags |= DELTA_FLAG_FRAMEINFO;\r\nctx->state = DELTA_STATE_READY;\r\ndev_dbg(delta->dev, "%s %s => %s\n", ctx->name,\r\ndelta_streaminfo_str(streaminfo, str1, sizeof(str1)),\r\ndelta_frameinfo_str(frameinfo, str2, sizeof(str2)));\r\ndelta_au_done(ctx, au, ret);\r\nreturn 0;\r\nerr:\r\nif (vbuf)\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\r\nwhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_QUEUED);\r\nreturn ret;\r\n}\r\nstatic void delta_vb2_au_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_v4l2_buffer *vbuf;\r\ndelta_flush_dts(ctx);\r\nwhile ((vbuf = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx)))\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\r\nctx->au_num = 0;\r\nctx->aborting = false;\r\n}\r\nstatic int delta_vb2_frame_queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers,\r\nunsigned int *num_planes,\r\nunsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct delta_streaminfo *streaminfo = &ctx->streaminfo;\r\nstruct delta_frameinfo *frameinfo = &ctx->frameinfo;\r\nunsigned int size = frameinfo->size;\r\nif (*num_buffers < DELTA_MIN_FRAME_USER) {\r\ndev_dbg(delta->dev,\r\n"%s num_buffers too low (%d), increasing to %d\n",\r\nctx->name, *num_buffers, DELTA_MIN_FRAME_USER);\r\n*num_buffers = DELTA_MIN_FRAME_USER;\r\n}\r\n*num_buffers += streaminfo->dpb + DELTA_PEAK_FRAME_SMOOTHING;\r\nif (*num_buffers > DELTA_MAX_FRAMES) {\r\ndev_dbg(delta->dev,\r\n"%s output frame count too high (%d), cut to %d\n",\r\nctx->name, *num_buffers, DELTA_MAX_FRAMES);\r\n*num_buffers = DELTA_MAX_FRAMES;\r\n}\r\nif (*num_planes)\r\nreturn sizes[0] < size ? -EINVAL : 0;\r\n*num_planes = 1;\r\nsizes[0] = size;\r\nctx->nb_of_frames = 0;\r\nreturn 0;\r\n}\r\nstatic int delta_vb2_frame_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct delta_dev *delta = ctx->dev;\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct delta_frame *frame = to_frame(vbuf);\r\nint ret = 0;\r\nif (!frame->prepared) {\r\nframe->index = vbuf->vb2_buf.index;\r\nframe->vaddr = vb2_plane_vaddr(&vbuf->vb2_buf, 0);\r\nframe->paddr = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\r\nframe->info = ctx->frameinfo;\r\nret = delta_setup_frame(ctx, frame);\r\nif (ret) {\r\ndev_err(delta->dev,\r\n"%s setup_frame() failed (%d)\n",\r\nctx->name, ret);\r\nreturn ret;\r\n}\r\nframe->prepared = true;\r\ndev_dbg(delta->dev,\r\n"%s frame[%d] prepared; virt=0x%p, phy=0x%pad\n",\r\nctx->name, vb->index, frame->vaddr,\r\n&frame->paddr);\r\n}\r\nframe->flags = vbuf->flags;\r\nreturn 0;\r\n}\r\nstatic void delta_vb2_frame_finish(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct delta_frame *frame = to_frame(vbuf);\r\nvb2_set_plane_payload(&vbuf->vb2_buf, 0, frame->info.size);\r\nvb->timestamp = frame->dts;\r\nvbuf->field = frame->field;\r\nvbuf->flags = frame->flags;\r\n}\r\nstatic void delta_vb2_frame_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_queue *q = vb->vb2_queue;\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct delta_frame *frame = to_frame(vbuf);\r\nif (ctx->state == DELTA_STATE_WF_EOS) {\r\ndelta_complete_eos(ctx, frame);\r\nctx->state = DELTA_STATE_EOS;\r\nreturn;\r\n}\r\ndelta_recycle(ctx, frame);\r\n}\r\nstatic void delta_vb2_frame_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct delta_ctx *ctx = vb2_get_drv_priv(q);\r\nstruct vb2_v4l2_buffer *vbuf;\r\nstruct delta_frame *frame;\r\nconst struct delta_dec *dec = ctx->dec;\r\nunsigned int i;\r\ndelta_flush_dts(ctx);\r\ncall_dec_op(dec, flush, ctx);\r\nfor (i = 0; i < ctx->nb_of_frames; i++) {\r\nframe = ctx->frames[i];\r\nif (!(frame->state & DELTA_FRAME_OUT)) {\r\nvbuf = &frame->vbuf;\r\nv4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_ERROR);\r\n}\r\nframe->state = DELTA_FRAME_OUT;\r\n}\r\nctx->frame_num = 0;\r\nctx->aborting = false;\r\n}\r\nstatic int queue_init(void *priv,\r\nstruct vb2_queue *src_vq, struct vb2_queue *dst_vq)\r\n{\r\nstruct vb2_queue *q;\r\nstruct delta_ctx *ctx = priv;\r\nstruct delta_dev *delta = ctx->dev;\r\nint ret;\r\nq = src_vq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nq->drv_priv = ctx;\r\nq->buf_struct_size = sizeof(struct delta_au);\r\nq->ops = &delta_vb2_au_ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nq->lock = &delta->lock;\r\nq->dev = delta->dev;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\nreturn ret;\r\nq = dst_vq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nq->drv_priv = ctx;\r\nq->buf_struct_size = sizeof(struct delta_frame)\r\n+ DELTA_MAX_FRAME_PRIV_SIZE;\r\nq->ops = &delta_vb2_frame_ops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nq->lock = &delta->lock;\r\nq->dev = delta->dev;\r\nreturn vb2_queue_init(q);\r\n}\r\nstatic int delta_open(struct file *file)\r\n{\r\nstruct delta_dev *delta = video_drvdata(file);\r\nstruct delta_ctx *ctx = NULL;\r\nint ret = 0;\r\nmutex_lock(&delta->lock);\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nctx->dev = delta;\r\nv4l2_fh_init(&ctx->fh, video_devdata(file));\r\nfile->private_data = &ctx->fh;\r\nv4l2_fh_add(&ctx->fh);\r\nINIT_WORK(&ctx->run_work, delta_run_work);\r\nmutex_init(&ctx->lock);\r\nctx->fh.m2m_ctx = v4l2_m2m_ctx_init(delta->m2m_dev, ctx,\r\nqueue_init);\r\nif (IS_ERR(ctx->fh.m2m_ctx)) {\r\nret = PTR_ERR(ctx->fh.m2m_ctx);\r\ndev_err(delta->dev, "%s failed to initialize m2m context (%d)\n",\r\nDELTA_PREFIX, ret);\r\ngoto err_fh_del;\r\n}\r\nctx->state = DELTA_STATE_WF_FORMAT;\r\nINIT_LIST_HEAD(&ctx->dts);\r\ndelta->instance_id++;\r\nsnprintf(ctx->name, sizeof(ctx->name), "[%3d:----]",\r\ndelta->instance_id);\r\nset_default_params(ctx);\r\nif (delta->clk_st231)\r\nif (clk_prepare_enable(delta->clk_st231))\r\ndev_warn(delta->dev, "failed to enable st231 clk\n");\r\nif (delta->clk_flash_promip)\r\nif (clk_prepare_enable(delta->clk_flash_promip))\r\ndev_warn(delta->dev, "failed to enable delta promip clk\n");\r\nmutex_unlock(&delta->lock);\r\ndev_dbg(delta->dev, "%s decoder instance created\n", ctx->name);\r\nreturn 0;\r\nerr_fh_del:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nkfree(ctx);\r\nerr:\r\nmutex_unlock(&delta->lock);\r\nreturn ret;\r\n}\r\nstatic int delta_release(struct file *file)\r\n{\r\nstruct delta_ctx *ctx = to_ctx(file->private_data);\r\nstruct delta_dev *delta = ctx->dev;\r\nconst struct delta_dec *dec = ctx->dec;\r\nmutex_lock(&delta->lock);\r\ncall_dec_op(dec, close, ctx);\r\ndelta_trace_summary(ctx);\r\nv4l2_m2m_ctx_release(ctx->fh.m2m_ctx);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nif (delta->clk_st231)\r\nclk_disable_unprepare(delta->clk_st231);\r\nif (delta->clk_flash_promip)\r\nclk_disable_unprepare(delta->clk_flash_promip);\r\ndev_dbg(delta->dev, "%s decoder instance released\n", ctx->name);\r\nkfree(ctx);\r\nmutex_unlock(&delta->lock);\r\nreturn 0;\r\n}\r\nstatic int delta_register_device(struct delta_dev *delta)\r\n{\r\nint ret;\r\nstruct video_device *vdev;\r\nif (!delta)\r\nreturn -ENODEV;\r\ndelta->m2m_dev = v4l2_m2m_init(&delta_m2m_ops);\r\nif (IS_ERR(delta->m2m_dev)) {\r\ndev_err(delta->dev, "%s failed to initialize v4l2-m2m device\n",\r\nDELTA_PREFIX);\r\nret = PTR_ERR(delta->m2m_dev);\r\ngoto err;\r\n}\r\nvdev = video_device_alloc();\r\nif (!vdev) {\r\ndev_err(delta->dev, "%s failed to allocate video device\n",\r\nDELTA_PREFIX);\r\nret = -ENOMEM;\r\ngoto err_m2m_release;\r\n}\r\nvdev->fops = &delta_fops;\r\nvdev->ioctl_ops = &delta_ioctl_ops;\r\nvdev->release = video_device_release;\r\nvdev->lock = &delta->lock;\r\nvdev->vfl_dir = VFL_DIR_M2M;\r\nvdev->device_caps = V4L2_CAP_STREAMING | V4L2_CAP_VIDEO_M2M;\r\nvdev->v4l2_dev = &delta->v4l2_dev;\r\nsnprintf(vdev->name, sizeof(vdev->name), "%s-%s",\r\nDELTA_NAME, DELTA_FW_VERSION);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret) {\r\ndev_err(delta->dev, "%s failed to register video device\n",\r\nDELTA_PREFIX);\r\ngoto err_vdev_release;\r\n}\r\ndelta->vdev = vdev;\r\nvideo_set_drvdata(vdev, delta);\r\nreturn 0;\r\nerr_vdev_release:\r\nvideo_device_release(vdev);\r\nerr_m2m_release:\r\nv4l2_m2m_release(delta->m2m_dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic void delta_unregister_device(struct delta_dev *delta)\r\n{\r\nif (!delta)\r\nreturn;\r\nif (delta->m2m_dev)\r\nv4l2_m2m_release(delta->m2m_dev);\r\nvideo_unregister_device(delta->vdev);\r\n}\r\nstatic int delta_probe(struct platform_device *pdev)\r\n{\r\nstruct delta_dev *delta;\r\nstruct device *dev = &pdev->dev;\r\nint ret;\r\ndelta = devm_kzalloc(dev, sizeof(*delta), GFP_KERNEL);\r\nif (!delta) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndelta->dev = dev;\r\ndelta->pdev = pdev;\r\nplatform_set_drvdata(pdev, delta);\r\nmutex_init(&delta->lock);\r\ndelta->clk_delta = devm_clk_get(dev, "delta");\r\nif (IS_ERR(delta->clk_delta)) {\r\ndev_dbg(dev, "%s can't get delta clock\n", DELTA_PREFIX);\r\ndelta->clk_delta = NULL;\r\n}\r\ndelta->clk_st231 = devm_clk_get(dev, "delta-st231");\r\nif (IS_ERR(delta->clk_st231)) {\r\ndev_dbg(dev, "%s can't get delta-st231 clock\n", DELTA_PREFIX);\r\ndelta->clk_st231 = NULL;\r\n}\r\ndelta->clk_flash_promip = devm_clk_get(dev, "delta-flash-promip");\r\nif (IS_ERR(delta->clk_flash_promip)) {\r\ndev_dbg(dev, "%s can't get delta-flash-promip clock\n",\r\nDELTA_PREFIX);\r\ndelta->clk_flash_promip = NULL;\r\n}\r\npm_runtime_set_autosuspend_delay(dev, DELTA_HW_AUTOSUSPEND_DELAY_MS);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_enable(dev);\r\nret = delta_ipc_init(delta);\r\nif (ret) {\r\ndev_err(delta->dev, "%s failed to initialize firmware ipc channel\n",\r\nDELTA_PREFIX);\r\ngoto err;\r\n}\r\nregister_decoders(delta);\r\nregister_formats(delta);\r\nret = v4l2_device_register(dev, &delta->v4l2_dev);\r\nif (ret) {\r\ndev_err(delta->dev, "%s failed to register V4L2 device\n",\r\nDELTA_PREFIX);\r\ngoto err;\r\n}\r\ndelta->work_queue = create_workqueue(DELTA_NAME);\r\nif (!delta->work_queue) {\r\ndev_err(delta->dev, "%s failed to allocate work queue\n",\r\nDELTA_PREFIX);\r\nret = -ENOMEM;\r\ngoto err_v4l2;\r\n}\r\nret = delta_register_device(delta);\r\nif (ret)\r\ngoto err_work_queue;\r\ndev_info(dev, "%s %s registered as /dev/video%d\n",\r\nDELTA_PREFIX, delta->vdev->name, delta->vdev->num);\r\nreturn 0;\r\nerr_work_queue:\r\ndestroy_workqueue(delta->work_queue);\r\nerr_v4l2:\r\nv4l2_device_unregister(&delta->v4l2_dev);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int delta_remove(struct platform_device *pdev)\r\n{\r\nstruct delta_dev *delta = platform_get_drvdata(pdev);\r\ndelta_ipc_exit(delta);\r\ndelta_unregister_device(delta);\r\ndestroy_workqueue(delta->work_queue);\r\npm_runtime_put_autosuspend(delta->dev);\r\npm_runtime_disable(delta->dev);\r\nv4l2_device_unregister(&delta->v4l2_dev);\r\nreturn 0;\r\n}\r\nstatic int delta_runtime_suspend(struct device *dev)\r\n{\r\nstruct delta_dev *delta = dev_get_drvdata(dev);\r\nif (delta->clk_delta)\r\nclk_disable_unprepare(delta->clk_delta);\r\nreturn 0;\r\n}\r\nstatic int delta_runtime_resume(struct device *dev)\r\n{\r\nstruct delta_dev *delta = dev_get_drvdata(dev);\r\nif (delta->clk_delta)\r\nif (clk_prepare_enable(delta->clk_delta))\r\ndev_warn(dev, "failed to prepare/enable delta clk\n");\r\nreturn 0;\r\n}
