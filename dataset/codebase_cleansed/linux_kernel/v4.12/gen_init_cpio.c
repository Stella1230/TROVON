static void push_string(const char *name)\r\n{\r\nunsigned int name_len = strlen(name) + 1;\r\nfputs(name, stdout);\r\nputchar(0);\r\noffset += name_len;\r\n}\r\nstatic void push_pad (void)\r\n{\r\nwhile (offset & 3) {\r\nputchar(0);\r\noffset++;\r\n}\r\n}\r\nstatic void push_rest(const char *name)\r\n{\r\nunsigned int name_len = strlen(name) + 1;\r\nunsigned int tmp_ofs;\r\nfputs(name, stdout);\r\nputchar(0);\r\noffset += name_len;\r\ntmp_ofs = name_len + 110;\r\nwhile (tmp_ofs & 3) {\r\nputchar(0);\r\noffset++;\r\ntmp_ofs++;\r\n}\r\n}\r\nstatic void push_hdr(const char *s)\r\n{\r\nfputs(s, stdout);\r\noffset += 110;\r\n}\r\nstatic void cpio_trailer(void)\r\n{\r\nchar s[256];\r\nconst char name[] = "TRAILER!!!";\r\nsprintf(s, "%s%08X%08X%08lX%08lX%08X%08lX"\r\n"%08X%08X%08X%08X%08X%08X%08X",\r\n"070701",\r\n0,\r\n0,\r\n(long) 0,\r\n(long) 0,\r\n1,\r\n(long) 0,\r\n0,\r\n0,\r\n0,\r\n0,\r\n0,\r\n(unsigned)strlen(name)+1,\r\n0);\r\npush_hdr(s);\r\npush_rest(name);\r\nwhile (offset % 512) {\r\nputchar(0);\r\noffset++;\r\n}\r\n}\r\nstatic int cpio_mkslink(const char *name, const char *target,\r\nunsigned int mode, uid_t uid, gid_t gid)\r\n{\r\nchar s[256];\r\nif (name[0] == '/')\r\nname++;\r\nsprintf(s,"%s%08X%08X%08lX%08lX%08X%08lX"\r\n"%08X%08X%08X%08X%08X%08X%08X",\r\n"070701",\r\nino++,\r\nS_IFLNK | mode,\r\n(long) uid,\r\n(long) gid,\r\n1,\r\n(long) default_mtime,\r\n(unsigned)strlen(target)+1,\r\n3,\r\n1,\r\n0,\r\n0,\r\n(unsigned)strlen(name) + 1,\r\n0);\r\npush_hdr(s);\r\npush_string(name);\r\npush_pad();\r\npush_string(target);\r\npush_pad();\r\nreturn 0;\r\n}\r\nstatic int cpio_mkslink_line(const char *line)\r\n{\r\nchar name[PATH_MAX + 1];\r\nchar target[PATH_MAX + 1];\r\nunsigned int mode;\r\nint uid;\r\nint gid;\r\nint rc = -1;\r\nif (5 != sscanf(line, "%" str(PATH_MAX) "s %" str(PATH_MAX) "s %o %d %d", name, target, &mode, &uid, &gid)) {\r\nfprintf(stderr, "Unrecognized dir format '%s'", line);\r\ngoto fail;\r\n}\r\nrc = cpio_mkslink(name, target, mode, uid, gid);\r\nfail:\r\nreturn rc;\r\n}\r\nstatic int cpio_mkgeneric(const char *name, unsigned int mode,\r\nuid_t uid, gid_t gid)\r\n{\r\nchar s[256];\r\nif (name[0] == '/')\r\nname++;\r\nsprintf(s,"%s%08X%08X%08lX%08lX%08X%08lX"\r\n"%08X%08X%08X%08X%08X%08X%08X",\r\n"070701",\r\nino++,\r\nmode,\r\n(long) uid,\r\n(long) gid,\r\n2,\r\n(long) default_mtime,\r\n0,\r\n3,\r\n1,\r\n0,\r\n0,\r\n(unsigned)strlen(name) + 1,\r\n0);\r\npush_hdr(s);\r\npush_rest(name);\r\nreturn 0;\r\n}\r\nstatic int cpio_mkgeneric_line(const char *line, enum generic_types gt)\r\n{\r\nchar name[PATH_MAX + 1];\r\nunsigned int mode;\r\nint uid;\r\nint gid;\r\nint rc = -1;\r\nif (4 != sscanf(line, "%" str(PATH_MAX) "s %o %d %d", name, &mode, &uid, &gid)) {\r\nfprintf(stderr, "Unrecognized %s format '%s'",\r\nline, generic_type_table[gt].type);\r\ngoto fail;\r\n}\r\nmode |= generic_type_table[gt].mode;\r\nrc = cpio_mkgeneric(name, mode, uid, gid);\r\nfail:\r\nreturn rc;\r\n}\r\nstatic int cpio_mkdir_line(const char *line)\r\n{\r\nreturn cpio_mkgeneric_line(line, GT_DIR);\r\n}\r\nstatic int cpio_mkpipe_line(const char *line)\r\n{\r\nreturn cpio_mkgeneric_line(line, GT_PIPE);\r\n}\r\nstatic int cpio_mksock_line(const char *line)\r\n{\r\nreturn cpio_mkgeneric_line(line, GT_SOCK);\r\n}\r\nstatic int cpio_mknod(const char *name, unsigned int mode,\r\nuid_t uid, gid_t gid, char dev_type,\r\nunsigned int maj, unsigned int min)\r\n{\r\nchar s[256];\r\nif (dev_type == 'b')\r\nmode |= S_IFBLK;\r\nelse\r\nmode |= S_IFCHR;\r\nif (name[0] == '/')\r\nname++;\r\nsprintf(s,"%s%08X%08X%08lX%08lX%08X%08lX"\r\n"%08X%08X%08X%08X%08X%08X%08X",\r\n"070701",\r\nino++,\r\nmode,\r\n(long) uid,\r\n(long) gid,\r\n1,\r\n(long) default_mtime,\r\n0,\r\n3,\r\n1,\r\nmaj,\r\nmin,\r\n(unsigned)strlen(name) + 1,\r\n0);\r\npush_hdr(s);\r\npush_rest(name);\r\nreturn 0;\r\n}\r\nstatic int cpio_mknod_line(const char *line)\r\n{\r\nchar name[PATH_MAX + 1];\r\nunsigned int mode;\r\nint uid;\r\nint gid;\r\nchar dev_type;\r\nunsigned int maj;\r\nunsigned int min;\r\nint rc = -1;\r\nif (7 != sscanf(line, "%" str(PATH_MAX) "s %o %d %d %c %u %u",\r\nname, &mode, &uid, &gid, &dev_type, &maj, &min)) {\r\nfprintf(stderr, "Unrecognized nod format '%s'", line);\r\ngoto fail;\r\n}\r\nrc = cpio_mknod(name, mode, uid, gid, dev_type, maj, min);\r\nfail:\r\nreturn rc;\r\n}\r\nstatic int cpio_mkfile(const char *name, const char *location,\r\nunsigned int mode, uid_t uid, gid_t gid,\r\nunsigned int nlinks)\r\n{\r\nchar s[256];\r\nchar *filebuf = NULL;\r\nstruct stat buf;\r\nlong size;\r\nint file = -1;\r\nint retval;\r\nint rc = -1;\r\nint namesize;\r\nunsigned int i;\r\nmode |= S_IFREG;\r\nfile = open (location, O_RDONLY);\r\nif (file < 0) {\r\nfprintf (stderr, "File %s could not be opened for reading\n", location);\r\ngoto error;\r\n}\r\nretval = fstat(file, &buf);\r\nif (retval) {\r\nfprintf(stderr, "File %s could not be stat()'ed\n", location);\r\ngoto error;\r\n}\r\nfilebuf = malloc(buf.st_size);\r\nif (!filebuf) {\r\nfprintf (stderr, "out of memory\n");\r\ngoto error;\r\n}\r\nretval = read (file, filebuf, buf.st_size);\r\nif (retval < 0) {\r\nfprintf (stderr, "Can not read %s file\n", location);\r\ngoto error;\r\n}\r\nsize = 0;\r\nfor (i = 1; i <= nlinks; i++) {\r\nif (i == nlinks) size = buf.st_size;\r\nif (name[0] == '/')\r\nname++;\r\nnamesize = strlen(name) + 1;\r\nsprintf(s,"%s%08X%08X%08lX%08lX%08X%08lX"\r\n"%08lX%08X%08X%08X%08X%08X%08X",\r\n"070701",\r\nino,\r\nmode,\r\n(long) uid,\r\n(long) gid,\r\nnlinks,\r\n(long) buf.st_mtime,\r\nsize,\r\n3,\r\n1,\r\n0,\r\n0,\r\nnamesize,\r\n0);\r\npush_hdr(s);\r\npush_string(name);\r\npush_pad();\r\nif (size) {\r\nif (fwrite(filebuf, size, 1, stdout) != 1) {\r\nfprintf(stderr, "writing filebuf failed\n");\r\ngoto error;\r\n}\r\noffset += size;\r\npush_pad();\r\n}\r\nname += namesize;\r\n}\r\nino++;\r\nrc = 0;\r\nerror:\r\nif (filebuf) free(filebuf);\r\nif (file >= 0) close(file);\r\nreturn rc;\r\n}\r\nstatic char *cpio_replace_env(char *new_location)\r\n{\r\nchar expanded[PATH_MAX + 1];\r\nchar *start, *end, *var;\r\nwhile ((start = strstr(new_location, "${")) &&\r\n(end = strchr(start + 2, '}'))) {\r\n*start = *end = 0;\r\nvar = getenv(start + 2);\r\nsnprintf(expanded, sizeof expanded, "%s%s%s",\r\nnew_location, var ? var : "", end + 1);\r\nstrcpy(new_location, expanded);\r\n}\r\nreturn new_location;\r\n}\r\nstatic int cpio_mkfile_line(const char *line)\r\n{\r\nchar name[PATH_MAX + 1];\r\nchar *dname = NULL;\r\nchar location[PATH_MAX + 1];\r\nunsigned int mode;\r\nint uid;\r\nint gid;\r\nint nlinks = 1;\r\nint end = 0, dname_len = 0;\r\nint rc = -1;\r\nif (5 > sscanf(line, "%" str(PATH_MAX) "s %" str(PATH_MAX)\r\n"s %o %d %d %n",\r\nname, location, &mode, &uid, &gid, &end)) {\r\nfprintf(stderr, "Unrecognized file format '%s'", line);\r\ngoto fail;\r\n}\r\nif (end && isgraph(line[end])) {\r\nint len;\r\nint nend;\r\ndname = malloc(strlen(line));\r\nif (!dname) {\r\nfprintf (stderr, "out of memory (%d)\n", dname_len);\r\ngoto fail;\r\n}\r\ndname_len = strlen(name) + 1;\r\nmemcpy(dname, name, dname_len);\r\ndo {\r\nnend = 0;\r\nif (sscanf(line + end, "%" str(PATH_MAX) "s %n",\r\nname, &nend) < 1)\r\nbreak;\r\nlen = strlen(name) + 1;\r\nmemcpy(dname + dname_len, name, len);\r\ndname_len += len;\r\nnlinks++;\r\nend += nend;\r\n} while (isgraph(line[end]));\r\n} else {\r\ndname = name;\r\n}\r\nrc = cpio_mkfile(dname, cpio_replace_env(location),\r\nmode, uid, gid, nlinks);\r\nfail:\r\nif (dname_len) free(dname);\r\nreturn rc;\r\n}\r\nstatic void usage(const char *prog)\r\n{\r\nfprintf(stderr, "Usage:\n"\r\n"\t%s [-t <timestamp>] <cpio_list>\n"\r\n"\n"\r\n"<cpio_list> is a file containing newline separated entries that\n"\r\n"describe the files to be included in the initramfs archive:\n"\r\n"\n"\r\n"# a comment\n"\r\n"file <name> <location> <mode> <uid> <gid> [<hard links>]\n"\r\n"dir <name> <mode> <uid> <gid>\n"\r\n"nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>\n"\r\n"slink <name> <target> <mode> <uid> <gid>\n"\r\n"pipe <name> <mode> <uid> <gid>\n"\r\n"sock <name> <mode> <uid> <gid>\n"\r\n"\n"\r\n"<name> name of the file/dir/nod/etc in the archive\n"\r\n"<location> location of the file in the current filesystem\n"\r\n" expands shell variables quoted with ${}\n"\r\n"<target> link target\n"\r\n"<mode> mode/permissions of the file\n"\r\n"<uid> user id (0=root)\n"\r\n"<gid> group id (0=root)\n"\r\n"<dev_type> device type (b=block, c=character)\n"\r\n"<maj> major number of nod\n"\r\n"<min> minor number of nod\n"\r\n"<hard links> space separated list of other links to file\n"\r\n"\n"\r\n"example:\n"\r\n"# A simple initramfs\n"\r\n"dir /dev 0755 0 0\n"\r\n"nod /dev/console 0600 0 0 c 5 1\n"\r\n"dir /root 0700 0 0\n"\r\n"dir /sbin 0755 0 0\n"\r\n"file /sbin/kinit /usr/src/klibc/kinit/kinit 0755 0 0\n"\r\n"\n"\r\n"<timestamp> is time in seconds since Epoch that will be used\n"\r\n"as mtime for symlinks, special files and directories. The default\n"\r\n"is to use the current time for these entries.\n",\r\nprog);\r\n}\r\nint main (int argc, char *argv[])\r\n{\r\nFILE *cpio_list;\r\nchar line[LINE_SIZE];\r\nchar *args, *type;\r\nint ec = 0;\r\nint line_nr = 0;\r\nconst char *filename;\r\ndefault_mtime = time(NULL);\r\nwhile (1) {\r\nint opt = getopt(argc, argv, "t:h");\r\nchar *invalid;\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 't':\r\ndefault_mtime = strtol(optarg, &invalid, 10);\r\nif (!*optarg || *invalid) {\r\nfprintf(stderr, "Invalid timestamp: %s\n",\r\noptarg);\r\nusage(argv[0]);\r\nexit(1);\r\n}\r\nbreak;\r\ncase 'h':\r\ncase '?':\r\nusage(argv[0]);\r\nexit(opt == 'h' ? 0 : 1);\r\n}\r\n}\r\nif (argc - optind != 1) {\r\nusage(argv[0]);\r\nexit(1);\r\n}\r\nfilename = argv[optind];\r\nif (!strcmp(filename, "-"))\r\ncpio_list = stdin;\r\nelse if (!(cpio_list = fopen(filename, "r"))) {\r\nfprintf(stderr, "ERROR: unable to open '%s': %s\n\n",\r\nfilename, strerror(errno));\r\nusage(argv[0]);\r\nexit(1);\r\n}\r\nwhile (fgets(line, LINE_SIZE, cpio_list)) {\r\nint type_idx;\r\nsize_t slen = strlen(line);\r\nline_nr++;\r\nif ('#' == *line) {\r\ncontinue;\r\n}\r\nif (! (type = strtok(line, " \t"))) {\r\nfprintf(stderr,\r\n"ERROR: incorrect format, could not locate file type line %d: '%s'\n",\r\nline_nr, line);\r\nec = -1;\r\nbreak;\r\n}\r\nif ('\n' == *type) {\r\ncontinue;\r\n}\r\nif (slen == strlen(type)) {\r\ncontinue;\r\n}\r\nif (! (args = strtok(NULL, "\n"))) {\r\nfprintf(stderr,\r\n"ERROR: incorrect format, newline required line %d: '%s'\n",\r\nline_nr, line);\r\nec = -1;\r\n}\r\nfor (type_idx = 0; file_handler_table[type_idx].type; type_idx++) {\r\nint rc;\r\nif (! strcmp(line, file_handler_table[type_idx].type)) {\r\nif ((rc = file_handler_table[type_idx].handler(args))) {\r\nec = rc;\r\nfprintf(stderr, " line %d\n", line_nr);\r\n}\r\nbreak;\r\n}\r\n}\r\nif (NULL == file_handler_table[type_idx].type) {\r\nfprintf(stderr, "unknown file type line %d: '%s'\n",\r\nline_nr, line);\r\n}\r\n}\r\nif (ec == 0)\r\ncpio_trailer();\r\nexit(ec);\r\n}
