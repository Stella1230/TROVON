static bool ipv4_pkt_to_tuple(const struct sk_buff *skb, unsigned int nhoff,\r\nstruct nf_conntrack_tuple *tuple)\r\n{\r\nconst __be32 *ap;\r\n__be32 _addrs[2];\r\nap = skb_header_pointer(skb, nhoff + offsetof(struct iphdr, saddr),\r\nsizeof(u_int32_t) * 2, _addrs);\r\nif (ap == NULL)\r\nreturn false;\r\ntuple->src.u3.ip = ap[0];\r\ntuple->dst.u3.ip = ap[1];\r\nreturn true;\r\n}\r\nstatic bool ipv4_invert_tuple(struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_tuple *orig)\r\n{\r\ntuple->src.u3.ip = orig->dst.u3.ip;\r\ntuple->dst.u3.ip = orig->src.u3.ip;\r\nreturn true;\r\n}\r\nstatic void ipv4_print_tuple(struct seq_file *s,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nseq_printf(s, "src=%pI4 dst=%pI4 ",\r\n&tuple->src.u3.ip, &tuple->dst.u3.ip);\r\n}\r\nstatic int ipv4_get_l4proto(const struct sk_buff *skb, unsigned int nhoff,\r\nunsigned int *dataoff, u_int8_t *protonum)\r\n{\r\nconst struct iphdr *iph;\r\nstruct iphdr _iph;\r\niph = skb_header_pointer(skb, nhoff, sizeof(_iph), &_iph);\r\nif (iph == NULL)\r\nreturn -NF_ACCEPT;\r\nif (iph->frag_off & htons(IP_OFFSET))\r\nreturn -NF_ACCEPT;\r\n*dataoff = nhoff + (iph->ihl << 2);\r\n*protonum = iph->protocol;\r\nif (*dataoff > skb->len) {\r\npr_debug("nf_conntrack_ipv4: bogus IPv4 packet: "\r\n"nhoff %u, ihl %u, skblen %u\n",\r\nnhoff, iph->ihl << 2, skb->len);\r\nreturn -NF_ACCEPT;\r\n}\r\nreturn NF_ACCEPT;\r\n}\r\nstatic unsigned int ipv4_helper(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn_help *help;\r\nconst struct nf_conntrack_helper *helper;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct || ctinfo == IP_CT_RELATED_REPLY)\r\nreturn NF_ACCEPT;\r\nhelp = nfct_help(ct);\r\nif (!help)\r\nreturn NF_ACCEPT;\r\nhelper = rcu_dereference(help->helper);\r\nif (!helper)\r\nreturn NF_ACCEPT;\r\nreturn helper->help(skb, skb_network_offset(skb) + ip_hdrlen(skb),\r\nct, ctinfo);\r\n}\r\nstatic unsigned int ipv4_confirm(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nstruct nf_conn *ct;\r\nenum ip_conntrack_info ctinfo;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (!ct || ctinfo == IP_CT_RELATED_REPLY)\r\ngoto out;\r\nif (test_bit(IPS_SEQ_ADJUST_BIT, &ct->status) &&\r\n!nf_is_loopback_packet(skb)) {\r\nif (!nf_ct_seq_adjust(skb, ct, ctinfo, ip_hdrlen(skb))) {\r\nNF_CT_STAT_INC_ATOMIC(nf_ct_net(ct), drop);\r\nreturn NF_DROP;\r\n}\r\n}\r\nout:\r\nreturn nf_conntrack_confirm(skb);\r\n}\r\nstatic unsigned int ipv4_conntrack_in(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nreturn nf_conntrack_in(state->net, PF_INET, state->hook, skb);\r\n}\r\nstatic unsigned int ipv4_conntrack_local(void *priv,\r\nstruct sk_buff *skb,\r\nconst struct nf_hook_state *state)\r\n{\r\nif (skb->len < sizeof(struct iphdr) ||\r\nip_hdrlen(skb) < sizeof(struct iphdr))\r\nreturn NF_ACCEPT;\r\nif (ip_is_fragment(ip_hdr(skb)))\r\nreturn NF_ACCEPT;\r\nreturn nf_conntrack_in(state->net, PF_INET, state->hook, skb);\r\n}\r\nstatic int\r\ngetorigdst(struct sock *sk, int optval, void __user *user, int *len)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nconst struct nf_conntrack_tuple_hash *h;\r\nstruct nf_conntrack_tuple tuple;\r\nmemset(&tuple, 0, sizeof(tuple));\r\ntuple.src.u3.ip = inet->inet_rcv_saddr;\r\ntuple.src.u.tcp.port = inet->inet_sport;\r\ntuple.dst.u3.ip = inet->inet_daddr;\r\ntuple.dst.u.tcp.port = inet->inet_dport;\r\ntuple.src.l3num = PF_INET;\r\ntuple.dst.protonum = sk->sk_protocol;\r\nif (sk->sk_protocol != IPPROTO_TCP && sk->sk_protocol != IPPROTO_SCTP) {\r\npr_debug("SO_ORIGINAL_DST: Not a TCP/SCTP socket\n");\r\nreturn -ENOPROTOOPT;\r\n}\r\nif ((unsigned int) *len < sizeof(struct sockaddr_in)) {\r\npr_debug("SO_ORIGINAL_DST: len %d not %zu\n",\r\n*len, sizeof(struct sockaddr_in));\r\nreturn -EINVAL;\r\n}\r\nh = nf_conntrack_find_get(sock_net(sk), &nf_ct_zone_dflt, &tuple);\r\nif (h) {\r\nstruct sockaddr_in sin;\r\nstruct nf_conn *ct = nf_ct_tuplehash_to_ctrack(h);\r\nsin.sin_family = AF_INET;\r\nsin.sin_port = ct->tuplehash[IP_CT_DIR_ORIGINAL]\r\n.tuple.dst.u.tcp.port;\r\nsin.sin_addr.s_addr = ct->tuplehash[IP_CT_DIR_ORIGINAL]\r\n.tuple.dst.u3.ip;\r\nmemset(sin.sin_zero, 0, sizeof(sin.sin_zero));\r\npr_debug("SO_ORIGINAL_DST: %pI4 %u\n",\r\n&sin.sin_addr.s_addr, ntohs(sin.sin_port));\r\nnf_ct_put(ct);\r\nif (copy_to_user(user, &sin, sizeof(sin)) != 0)\r\nreturn -EFAULT;\r\nelse\r\nreturn 0;\r\n}\r\npr_debug("SO_ORIGINAL_DST: Can't find %pI4/%u-%pI4/%u.\n",\r\n&tuple.src.u3.ip, ntohs(tuple.src.u.tcp.port),\r\n&tuple.dst.u3.ip, ntohs(tuple.dst.u.tcp.port));\r\nreturn -ENOENT;\r\n}\r\nstatic int ipv4_tuple_to_nlattr(struct sk_buff *skb,\r\nconst struct nf_conntrack_tuple *tuple)\r\n{\r\nif (nla_put_in_addr(skb, CTA_IP_V4_SRC, tuple->src.u3.ip) ||\r\nnla_put_in_addr(skb, CTA_IP_V4_DST, tuple->dst.u3.ip))\r\ngoto nla_put_failure;\r\nreturn 0;\r\nnla_put_failure:\r\nreturn -1;\r\n}\r\nstatic int ipv4_nlattr_to_tuple(struct nlattr *tb[],\r\nstruct nf_conntrack_tuple *t)\r\n{\r\nif (!tb[CTA_IP_V4_SRC] || !tb[CTA_IP_V4_DST])\r\nreturn -EINVAL;\r\nt->src.u3.ip = nla_get_in_addr(tb[CTA_IP_V4_SRC]);\r\nt->dst.u3.ip = nla_get_in_addr(tb[CTA_IP_V4_DST]);\r\nreturn 0;\r\n}\r\nstatic int ipv4_nlattr_tuple_size(void)\r\n{\r\nreturn nla_policy_len(ipv4_nla_policy, CTA_IP_MAX + 1);\r\n}\r\nstatic int ipv4_hooks_register(struct net *net)\r\n{\r\nstruct conntrack4_net *cnet = net_generic(net, conntrack4_net_id);\r\nint err = 0;\r\nmutex_lock(&register_ipv4_hooks);\r\ncnet->users++;\r\nif (cnet->users > 1)\r\ngoto out_unlock;\r\nerr = nf_defrag_ipv4_enable(net);\r\nif (err) {\r\ncnet->users = 0;\r\ngoto out_unlock;\r\n}\r\nerr = nf_register_net_hooks(net, ipv4_conntrack_ops,\r\nARRAY_SIZE(ipv4_conntrack_ops));\r\nif (err)\r\ncnet->users = 0;\r\nout_unlock:\r\nmutex_unlock(&register_ipv4_hooks);\r\nreturn err;\r\n}\r\nstatic void ipv4_hooks_unregister(struct net *net)\r\n{\r\nstruct conntrack4_net *cnet = net_generic(net, conntrack4_net_id);\r\nmutex_lock(&register_ipv4_hooks);\r\nif (cnet->users && (--cnet->users == 0))\r\nnf_unregister_net_hooks(net, ipv4_conntrack_ops,\r\nARRAY_SIZE(ipv4_conntrack_ops));\r\nmutex_unlock(&register_ipv4_hooks);\r\n}\r\nstatic int ipv4_net_init(struct net *net)\r\n{\r\nint ret = 0;\r\nret = nf_ct_l4proto_pernet_register(net, builtin_l4proto4,\r\nARRAY_SIZE(builtin_l4proto4));\r\nif (ret < 0)\r\nreturn ret;\r\nret = nf_ct_l3proto_pernet_register(net, &nf_conntrack_l3proto_ipv4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: pernet registration failed\n");\r\nnf_ct_l4proto_pernet_unregister(net, builtin_l4proto4,\r\nARRAY_SIZE(builtin_l4proto4));\r\n}\r\nreturn ret;\r\n}\r\nstatic void ipv4_net_exit(struct net *net)\r\n{\r\nnf_ct_l3proto_pernet_unregister(net, &nf_conntrack_l3proto_ipv4);\r\nnf_ct_l4proto_pernet_unregister(net, builtin_l4proto4,\r\nARRAY_SIZE(builtin_l4proto4));\r\n}\r\nstatic int __init nf_conntrack_l3proto_ipv4_init(void)\r\n{\r\nint ret = 0;\r\nneed_conntrack();\r\nret = nf_register_sockopt(&so_getorigdst);\r\nif (ret < 0) {\r\npr_err("Unable to register netfilter socket option\n");\r\nreturn ret;\r\n}\r\nret = register_pernet_subsys(&ipv4_net_ops);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register pernet ops\n");\r\ngoto cleanup_sockopt;\r\n}\r\nret = nf_ct_l4proto_register(builtin_l4proto4,\r\nARRAY_SIZE(builtin_l4proto4));\r\nif (ret < 0)\r\ngoto cleanup_pernet;\r\nret = nf_ct_l3proto_register(&nf_conntrack_l3proto_ipv4);\r\nif (ret < 0) {\r\npr_err("nf_conntrack_ipv4: can't register ipv4 proto.\n");\r\ngoto cleanup_l4proto;\r\n}\r\nreturn ret;\r\ncleanup_l4proto:\r\nnf_ct_l4proto_unregister(builtin_l4proto4,\r\nARRAY_SIZE(builtin_l4proto4));\r\ncleanup_pernet:\r\nunregister_pernet_subsys(&ipv4_net_ops);\r\ncleanup_sockopt:\r\nnf_unregister_sockopt(&so_getorigdst);\r\nreturn ret;\r\n}\r\nstatic void __exit nf_conntrack_l3proto_ipv4_fini(void)\r\n{\r\nsynchronize_net();\r\nnf_ct_l3proto_unregister(&nf_conntrack_l3proto_ipv4);\r\nnf_ct_l4proto_unregister(builtin_l4proto4,\r\nARRAY_SIZE(builtin_l4proto4));\r\nunregister_pernet_subsys(&ipv4_net_ops);\r\nnf_unregister_sockopt(&so_getorigdst);\r\n}
