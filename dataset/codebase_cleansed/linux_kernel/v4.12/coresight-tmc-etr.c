static void tmc_etr_enable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nu32 axictl;\r\nmemset(drvdata->vaddr, 0, drvdata->size);\r\nCS_UNLOCK(drvdata->base);\r\ntmc_wait_for_tmcready(drvdata);\r\nwritel_relaxed(drvdata->size / 4, drvdata->base + TMC_RSZ);\r\nwritel_relaxed(TMC_MODE_CIRCULAR_BUFFER, drvdata->base + TMC_MODE);\r\naxictl = readl_relaxed(drvdata->base + TMC_AXICTL);\r\naxictl |= TMC_AXICTL_WR_BURST_16;\r\nwritel_relaxed(axictl, drvdata->base + TMC_AXICTL);\r\naxictl &= ~TMC_AXICTL_SCT_GAT_MODE;\r\nwritel_relaxed(axictl, drvdata->base + TMC_AXICTL);\r\naxictl = (axictl &\r\n~(TMC_AXICTL_PROT_CTL_B0 | TMC_AXICTL_PROT_CTL_B1)) |\r\nTMC_AXICTL_PROT_CTL_B1;\r\nwritel_relaxed(axictl, drvdata->base + TMC_AXICTL);\r\nwritel_relaxed(drvdata->paddr, drvdata->base + TMC_DBALO);\r\nwritel_relaxed(0x0, drvdata->base + TMC_DBAHI);\r\nwritel_relaxed(TMC_FFCR_EN_FMT | TMC_FFCR_EN_TI |\r\nTMC_FFCR_FON_FLIN | TMC_FFCR_FON_TRIG_EVT |\r\nTMC_FFCR_TRIGON_TRIGIN,\r\ndrvdata->base + TMC_FFCR);\r\nwritel_relaxed(drvdata->trigger_cntr, drvdata->base + TMC_TRG);\r\ntmc_enable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void tmc_etr_dump_hw(struct tmc_drvdata *drvdata)\r\n{\r\nu32 rwp, val;\r\nrwp = readl_relaxed(drvdata->base + TMC_RWP);\r\nval = readl_relaxed(drvdata->base + TMC_STS);\r\nif (val & TMC_STS_FULL) {\r\ndrvdata->buf = drvdata->vaddr + rwp - drvdata->paddr;\r\ndrvdata->len = drvdata->size;\r\n} else {\r\ndrvdata->buf = drvdata->vaddr;\r\ndrvdata->len = rwp - drvdata->paddr;\r\n}\r\n}\r\nstatic void tmc_etr_disable_hw(struct tmc_drvdata *drvdata)\r\n{\r\nCS_UNLOCK(drvdata->base);\r\ntmc_flush_and_stop(drvdata);\r\nif (drvdata->mode == CS_MODE_SYSFS)\r\ntmc_etr_dump_hw(drvdata);\r\ntmc_disable_hw(drvdata);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic int tmc_enable_etr_sink_sysfs(struct coresight_device *csdev)\r\n{\r\nint ret = 0;\r\nbool used = false;\r\nunsigned long flags;\r\nvoid __iomem *vaddr = NULL;\r\ndma_addr_t paddr;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (!drvdata->vaddr) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nvaddr = dma_alloc_coherent(drvdata->dev, drvdata->size,\r\n&paddr, GFP_KERNEL);\r\nif (!vaddr)\r\nreturn -ENOMEM;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\n}\r\nif (drvdata->reading) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (drvdata->mode == CS_MODE_SYSFS)\r\ngoto out;\r\nif (drvdata->buf == NULL) {\r\nused = true;\r\ndrvdata->vaddr = vaddr;\r\ndrvdata->paddr = paddr;\r\ndrvdata->buf = drvdata->vaddr;\r\n}\r\ndrvdata->mode = CS_MODE_SYSFS;\r\ntmc_etr_enable_hw(drvdata);\r\nout:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nif (!used && vaddr)\r\ndma_free_coherent(drvdata->dev, drvdata->size, vaddr, paddr);\r\nif (!ret)\r\ndev_info(drvdata->dev, "TMC-ETR enabled\n");\r\nreturn ret;\r\n}\r\nstatic int tmc_enable_etr_sink_perf(struct coresight_device *csdev)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->mode != CS_MODE_DISABLED) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ndrvdata->mode = CS_MODE_PERF;\r\ntmc_etr_enable_hw(drvdata);\r\nout:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int tmc_enable_etr_sink(struct coresight_device *csdev, u32 mode)\r\n{\r\nswitch (mode) {\r\ncase CS_MODE_SYSFS:\r\nreturn tmc_enable_etr_sink_sysfs(csdev);\r\ncase CS_MODE_PERF:\r\nreturn tmc_enable_etr_sink_perf(csdev);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void tmc_disable_etr_sink(struct coresight_device *csdev)\r\n{\r\nunsigned long flags;\r\nstruct tmc_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn;\r\n}\r\nif (drvdata->mode != CS_MODE_DISABLED) {\r\ntmc_etr_disable_hw(drvdata);\r\ndrvdata->mode = CS_MODE_DISABLED;\r\n}\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\ndev_info(drvdata->dev, "TMC-ETR disabled\n");\r\n}\r\nint tmc_read_prepare_etr(struct tmc_drvdata *drvdata)\r\n{\r\nint ret = 0;\r\nunsigned long flags;\r\nif (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETR))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->reading) {\r\nret = -EBUSY;\r\ngoto out;\r\n}\r\nif (drvdata->mode == CS_MODE_PERF) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->buf == NULL) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (drvdata->mode == CS_MODE_SYSFS)\r\ntmc_etr_disable_hw(drvdata);\r\ndrvdata->reading = true;\r\nout:\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nreturn ret;\r\n}\r\nint tmc_read_unprepare_etr(struct tmc_drvdata *drvdata)\r\n{\r\nunsigned long flags;\r\ndma_addr_t paddr;\r\nvoid __iomem *vaddr = NULL;\r\nif (WARN_ON_ONCE(drvdata->config_type != TMC_CONFIG_TYPE_ETR))\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&drvdata->spinlock, flags);\r\nif (drvdata->mode == CS_MODE_SYSFS) {\r\ntmc_etr_enable_hw(drvdata);\r\n} else {\r\nvaddr = drvdata->vaddr;\r\npaddr = drvdata->paddr;\r\ndrvdata->buf = drvdata->vaddr = NULL;\r\n}\r\ndrvdata->reading = false;\r\nspin_unlock_irqrestore(&drvdata->spinlock, flags);\r\nif (vaddr)\r\ndma_free_coherent(drvdata->dev, drvdata->size, vaddr, paddr);\r\nreturn 0;\r\n}
