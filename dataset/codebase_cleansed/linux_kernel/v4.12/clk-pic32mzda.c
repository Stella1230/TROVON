static int pic32_fscm_nmi(struct notifier_block *nb,\r\nunsigned long action, void *data)\r\n{\r\nstruct pic32mzda_clk_data *cd;\r\ncd = container_of(nb, struct pic32mzda_clk_data, failsafe_notifier);\r\nif (readl(cd->core.iobase) & BIT(2))\r\npr_alert("pic32-clk: FSCM detected clk failure.\n");\r\nreturn NOTIFY_OK;\r\n}\r\nstatic int pic32mzda_clk_probe(struct platform_device *pdev)\r\n{\r\nconst char *const pll_mux_parents[] = {"posc_clk", "frc_clk"};\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct pic32mzda_clk_data *cd;\r\nstruct pic32_clk_common *core;\r\nstruct clk *pll_mux_clk, *clk;\r\nstruct clk **clks;\r\nint nr_clks, i, ret;\r\ncd = devm_kzalloc(&pdev->dev, sizeof(*cd), GFP_KERNEL);\r\nif (!cd)\r\nreturn -ENOMEM;\r\ncore = &cd->core;\r\ncore->iobase = of_io_request_and_map(np, 0, of_node_full_name(np));\r\nif (IS_ERR(core->iobase)) {\r\ndev_err(&pdev->dev, "pic32-clk: failed to map registers\n");\r\nreturn PTR_ERR(core->iobase);\r\n}\r\nspin_lock_init(&core->reg_lock);\r\ncore->dev = &pdev->dev;\r\nclks = &cd->clks[0];\r\nclks[POSCCLK] = clk_register_fixed_rate(&pdev->dev, "posc_clk", NULL,\r\n0, 24000000);\r\nclks[FRCCLK] = clk_register_fixed_rate(&pdev->dev, "frc_clk", NULL,\r\n0, 8000000);\r\nclks[BFRCCLK] = clk_register_fixed_rate(&pdev->dev, "bfrc_clk", NULL,\r\n0, 8000000);\r\nclks[LPRCCLK] = clk_register_fixed_rate(&pdev->dev, "lprc_clk", NULL,\r\n0, 32000);\r\nclks[UPLLCLK] = clk_register_fixed_rate(&pdev->dev, "usbphy_clk", NULL,\r\n0, 24000000);\r\nif (of_find_property(np, "microchip,pic32mzda-sosc", NULL)) {\r\npr_info("pic32-clk: dt requests SOSC.\n");\r\nclks[SOSCCLK] = pic32_sosc_clk_register(&sosc_clk, core);\r\n}\r\nclks[FRCDIVCLK] = clk_register_divider(&pdev->dev, "frcdiv_clk",\r\n"frc_clk", 0,\r\ncore->iobase,\r\nOSC_FRCDIV_SHIFT,\r\nOSC_FRCDIV_MASK,\r\nCLK_DIVIDER_POWER_OF_TWO,\r\n&core->reg_lock);\r\npll_mux_clk = clk_register_mux(&pdev->dev, "spll_mux_clk",\r\npll_mux_parents, 2, 0,\r\ncore->iobase + 0x020,\r\nPLL_ICLK_SHIFT, 1, 0, &core->reg_lock);\r\nif (IS_ERR(pll_mux_clk))\r\npr_err("spll_mux_clk: clk register failed\n");\r\nclks[PLLCLK] = pic32_spll_clk_register(&sys_pll, core);\r\nclks[SCLK] = pic32_sys_clk_register(&sys_mux_clk, core);\r\nfor (nr_clks = PB1CLK, i = 0; nr_clks <= PB7CLK; i++, nr_clks++)\r\nclks[nr_clks] = pic32_periph_clk_register(&periph_clocks[i],\r\ncore);\r\nfor (nr_clks = REF1CLK, i = 0; nr_clks <= REF5CLK; i++, nr_clks++)\r\nclks[nr_clks] = pic32_refo_clk_register(&ref_clks[i], core);\r\nfor (i = 0; i < MAXCLKS; i++) {\r\nif (IS_ERR(clks[i]))\r\ncontinue;\r\nclk_register_clkdev(clks[i], NULL, __clk_get_name(clks[i]));\r\n}\r\ncd->onecell_data.clks = clks;\r\ncd->onecell_data.clk_num = MAXCLKS;\r\nret = of_clk_add_provider(np, of_clk_src_onecell_get,\r\n&cd->onecell_data);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < ARRAY_SIZE(pic32mzda_critical_clks); i++) {\r\nclk = clks[pic32mzda_critical_clks[i]];\r\nif (clk_prepare_enable(clk))\r\ndev_err(&pdev->dev, "clk_prepare_enable(%s) failed\n",\r\n__clk_get_name(clk));\r\n}\r\ncd->failsafe_notifier.notifier_call = pic32_fscm_nmi;\r\nreturn register_nmi_notifier(&cd->failsafe_notifier);\r\n}\r\nstatic int __init microchip_pic32mzda_clk_init(void)\r\n{\r\nreturn platform_driver_register(&pic32mzda_clk_driver);\r\n}
