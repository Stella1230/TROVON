static void sti_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nDRM_DEBUG_DRIVER("\n");\r\nmixer->status = STI_MIXER_READY;\r\ndrm_crtc_vblank_on(crtc);\r\n}\r\nstatic void sti_crtc_disabling(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nDRM_DEBUG_DRIVER("\n");\r\nmixer->status = STI_MIXER_DISABLING;\r\n}\r\nstatic int\r\nsti_crtc_mode_set(struct drm_crtc *crtc, struct drm_display_mode *mode)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nstruct clk *compo_clk, *pix_clk;\r\nint rate = mode->clock * 1000;\r\nDRM_DEBUG_KMS("CRTC:%d (%s) mode:%d (%s)\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer),\r\nmode->base.id, mode->name);\r\nDRM_DEBUG_KMS("%d %d %d %d %d %d %d %d %d %d 0x%x 0x%x\n",\r\nmode->vrefresh, mode->clock,\r\nmode->hdisplay,\r\nmode->hsync_start, mode->hsync_end,\r\nmode->htotal,\r\nmode->vdisplay,\r\nmode->vsync_start, mode->vsync_end,\r\nmode->vtotal, mode->type, mode->flags);\r\nif (mixer->id == STI_MIXER_MAIN) {\r\ncompo_clk = compo->clk_compo_main;\r\npix_clk = compo->clk_pix_main;\r\n} else {\r\ncompo_clk = compo->clk_compo_aux;\r\npix_clk = compo->clk_pix_aux;\r\n}\r\nif (clk_prepare_enable(compo_clk)) {\r\nDRM_INFO("Failed to prepare/enable compositor clk\n");\r\ngoto compo_error;\r\n}\r\nif (clk_set_rate(pix_clk, rate) < 0) {\r\nDRM_ERROR("Cannot set rate (%dHz) for pix clk\n", rate);\r\ngoto pix_error;\r\n}\r\nif (clk_prepare_enable(pix_clk)) {\r\nDRM_ERROR("Failed to prepare/enable pix clk\n");\r\ngoto pix_error;\r\n}\r\nsti_vtg_set_config(compo->vtg[mixer->id], &crtc->mode);\r\nif (sti_mixer_active_video_area(mixer, &crtc->mode)) {\r\nDRM_ERROR("Can't set active video area\n");\r\ngoto mixer_error;\r\n}\r\nreturn 0;\r\nmixer_error:\r\nclk_disable_unprepare(pix_clk);\r\npix_error:\r\nclk_disable_unprepare(compo_clk);\r\ncompo_error:\r\nreturn -EINVAL;\r\n}\r\nstatic void sti_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct device *dev = mixer->dev;\r\nstruct sti_compositor *compo = dev_get_drvdata(dev);\r\nDRM_DEBUG_KMS("CRTC:%d (%s)\n", crtc->base.id, sti_mixer_to_str(mixer));\r\nsti_mixer_set_background_status(mixer, false);\r\ndrm_crtc_vblank_off(crtc);\r\nif (mixer->id == STI_MIXER_MAIN) {\r\nclk_disable_unprepare(compo->clk_pix_main);\r\nclk_disable_unprepare(compo->clk_compo_main);\r\n} else {\r\nclk_disable_unprepare(compo->clk_pix_aux);\r\nclk_disable_unprepare(compo->clk_compo_aux);\r\n}\r\nmixer->status = STI_MIXER_DISABLED;\r\n}\r\nstatic void\r\nsti_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nsti_crtc_mode_set(crtc, &crtc->state->adjusted_mode);\r\n}\r\nstatic void sti_crtc_atomic_flush(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *old_crtc_state)\r\n{\r\nstruct drm_device *drm_dev = crtc->dev;\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct sti_compositor *compo = dev_get_drvdata(mixer->dev);\r\nstruct drm_plane *p;\r\nstruct drm_pending_vblank_event *event;\r\nunsigned long flags;\r\nDRM_DEBUG_DRIVER("\n");\r\nlist_for_each_entry(p, &drm_dev->mode_config.plane_list, head) {\r\nstruct sti_plane *plane = to_sti_plane(p);\r\nswitch (plane->status) {\r\ncase STI_PLANE_UPDATED:\r\nif (p->state->crtc != crtc)\r\ncontinue;\r\nDRM_DEBUG_DRIVER("update plane %s\n",\r\nsti_plane_to_str(plane));\r\nif (sti_mixer_set_plane_depth(mixer, plane)) {\r\nDRM_ERROR("Cannot set plane %s depth\n",\r\nsti_plane_to_str(plane));\r\nbreak;\r\n}\r\nif (sti_mixer_set_plane_status(mixer, plane, true)) {\r\nDRM_ERROR("Cannot enable plane %s at mixer\n",\r\nsti_plane_to_str(plane));\r\nbreak;\r\n}\r\nif (plane->desc == STI_HQVDP_0)\r\nsti_vid_commit(compo->vid[0], p->state);\r\nplane->status = STI_PLANE_READY;\r\nbreak;\r\ncase STI_PLANE_DISABLING:\r\nDRM_DEBUG_DRIVER("disable plane %s from mixer\n",\r\nsti_plane_to_str(plane));\r\nif (sti_mixer_set_plane_status(mixer, plane, false)) {\r\nDRM_ERROR("Cannot disable plane %s at mixer\n",\r\nsti_plane_to_str(plane));\r\ncontinue;\r\n}\r\nif (plane->desc == STI_CURSOR)\r\nplane->status = STI_PLANE_DISABLED;\r\nelse\r\nplane->status = STI_PLANE_FLUSHING;\r\nif (plane->desc == STI_HQVDP_0)\r\nsti_vid_disable(compo->vid[0]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nevent = crtc->state->event;\r\nif (event) {\r\ncrtc->state->event = NULL;\r\nspin_lock_irqsave(&crtc->dev->event_lock, flags);\r\nif (drm_crtc_vblank_get(crtc) == 0)\r\ndrm_crtc_arm_vblank_event(crtc, event);\r\nelse\r\ndrm_crtc_send_vblank_event(crtc, event);\r\nspin_unlock_irqrestore(&crtc->dev->event_lock, flags);\r\n}\r\n}\r\nstatic void sti_crtc_destroy(struct drm_crtc *crtc)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\ndrm_crtc_cleanup(crtc);\r\n}\r\nstatic int sti_crtc_set_property(struct drm_crtc *crtc,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nDRM_DEBUG_KMS("\n");\r\nreturn 0;\r\n}\r\nint sti_crtc_vblank_cb(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct sti_compositor *compo;\r\nstruct drm_crtc *crtc = data;\r\nstruct sti_mixer *mixer;\r\nstruct sti_private *priv;\r\nunsigned int pipe;\r\npriv = crtc->dev->dev_private;\r\npipe = drm_crtc_index(crtc);\r\ncompo = container_of(nb, struct sti_compositor, vtg_vblank_nb[pipe]);\r\nmixer = compo->mixer[pipe];\r\nif ((event != VTG_TOP_FIELD_EVENT) &&\r\n(event != VTG_BOTTOM_FIELD_EVENT)) {\r\nDRM_ERROR("unknown event: %lu\n", event);\r\nreturn -EINVAL;\r\n}\r\ndrm_crtc_handle_vblank(crtc);\r\nif (mixer->status == STI_MIXER_DISABLING) {\r\nstruct drm_plane *p;\r\nlist_for_each_entry(p, &crtc->dev->mode_config.plane_list,\r\nhead) {\r\nstruct sti_plane *plane = to_sti_plane(p);\r\nif ((plane->desc & STI_PLANE_TYPE_MASK) <= STI_VDP)\r\nif (plane->status != STI_PLANE_DISABLED)\r\nreturn 0;\r\n}\r\nsti_crtc_disable(crtc);\r\n}\r\nreturn 0;\r\n}\r\nint sti_crtc_enable_vblank(struct drm_device *dev, unsigned int pipe)\r\n{\r\nstruct sti_private *dev_priv = dev->dev_private;\r\nstruct sti_compositor *compo = dev_priv->compo;\r\nstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb[pipe];\r\nstruct drm_crtc *crtc = &compo->mixer[pipe]->drm_crtc;\r\nstruct sti_vtg *vtg = compo->vtg[pipe];\r\nDRM_DEBUG_DRIVER("\n");\r\nif (sti_vtg_register_client(vtg, vtg_vblank_nb, crtc)) {\r\nDRM_ERROR("Cannot register VTG notifier\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nvoid sti_crtc_disable_vblank(struct drm_device *drm_dev, unsigned int pipe)\r\n{\r\nstruct sti_private *priv = drm_dev->dev_private;\r\nstruct sti_compositor *compo = priv->compo;\r\nstruct notifier_block *vtg_vblank_nb = &compo->vtg_vblank_nb[pipe];\r\nstruct sti_vtg *vtg = compo->vtg[pipe];\r\nDRM_DEBUG_DRIVER("\n");\r\nif (sti_vtg_unregister_client(vtg, vtg_vblank_nb))\r\nDRM_DEBUG_DRIVER("Warning: cannot unregister VTG notifier\n");\r\n}\r\nstatic int sti_crtc_late_register(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nstruct sti_compositor *compo = dev_get_drvdata(mixer->dev);\r\nif (drm_crtc_index(crtc) == 0)\r\nreturn sti_compositor_debugfs_init(compo, crtc->dev->primary);\r\nreturn 0;\r\n}\r\nbool sti_crtc_is_main(struct drm_crtc *crtc)\r\n{\r\nstruct sti_mixer *mixer = to_sti_mixer(crtc);\r\nif (mixer->id == STI_MIXER_MAIN)\r\nreturn true;\r\nreturn false;\r\n}\r\nint sti_crtc_init(struct drm_device *drm_dev, struct sti_mixer *mixer,\r\nstruct drm_plane *primary, struct drm_plane *cursor)\r\n{\r\nstruct drm_crtc *crtc = &mixer->drm_crtc;\r\nint res;\r\nres = drm_crtc_init_with_planes(drm_dev, crtc, primary, cursor,\r\n&sti_crtc_funcs, NULL);\r\nif (res) {\r\nDRM_ERROR("Can't initialze CRTC\n");\r\nreturn -EINVAL;\r\n}\r\ndrm_crtc_helper_add(crtc, &sti_crtc_helper_funcs);\r\nDRM_DEBUG_DRIVER("drm CRTC:%d mapped to %s\n",\r\ncrtc->base.id, sti_mixer_to_str(mixer));\r\nreturn 0;\r\n}
