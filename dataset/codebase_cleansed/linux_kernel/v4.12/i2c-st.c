static inline void st_i2c_set_bits(void __iomem *reg, u32 mask)\r\n{\r\nwritel_relaxed(readl_relaxed(reg) | mask, reg);\r\n}\r\nstatic inline void st_i2c_clr_bits(void __iomem *reg, u32 mask)\r\n{\r\nwritel_relaxed(readl_relaxed(reg) & ~mask, reg);\r\n}\r\nstatic void st_i2c_flush_rx_fifo(struct st_i2c_dev *i2c_dev)\r\n{\r\nint count, i;\r\nif (readl_relaxed(i2c_dev->base + SSC_STA) & SSC_STA_RIR)\r\ncount = SSC_RXFIFO_SIZE;\r\nelse\r\ncount = readl_relaxed(i2c_dev->base + SSC_RX_FSTAT) &\r\nSSC_RX_FSTAT_STATUS;\r\nfor (i = 0; i < count; i++)\r\nreadl_relaxed(i2c_dev->base + SSC_RBUF);\r\n}\r\nstatic void st_i2c_soft_reset(struct st_i2c_dev *i2c_dev)\r\n{\r\nst_i2c_flush_rx_fifo(i2c_dev);\r\nst_i2c_set_bits(i2c_dev->base + SSC_CTL, SSC_CTL_SR);\r\nst_i2c_clr_bits(i2c_dev->base + SSC_CTL, SSC_CTL_SR);\r\n}\r\nstatic void st_i2c_hw_config(struct st_i2c_dev *i2c_dev)\r\n{\r\nunsigned long rate;\r\nu32 val, ns_per_clk;\r\nstruct st_i2c_timings *t = &i2c_timings[i2c_dev->mode];\r\nst_i2c_soft_reset(i2c_dev);\r\nval = SSC_CLR_REPSTRT | SSC_CLR_NACK | SSC_CLR_SSCARBL |\r\nSSC_CLR_SSCAAS | SSC_CLR_SSCSTOP;\r\nwritel_relaxed(val, i2c_dev->base + SSC_CLR);\r\nval = SSC_CTL_PO | SSC_CTL_PH | SSC_CTL_HB | SSC_CTL_DATA_WIDTH_9;\r\nwritel_relaxed(val, i2c_dev->base + SSC_CTL);\r\nrate = clk_get_rate(i2c_dev->clk);\r\nns_per_clk = 1000000000 / rate;\r\nval = rate / (2 * t->rate);\r\nwritel_relaxed(val, i2c_dev->base + SSC_BRG);\r\nwritel_relaxed(1, i2c_dev->base + SSC_PRE_SCALER_BRG);\r\nwritel_relaxed(SSC_I2C_I2CM, i2c_dev->base + SSC_I2C);\r\nval = t->rep_start_hold / ns_per_clk;\r\nwritel_relaxed(val, i2c_dev->base + SSC_REP_START_HOLD);\r\nval = t->rep_start_setup / ns_per_clk;\r\nwritel_relaxed(val, i2c_dev->base + SSC_REP_START_SETUP);\r\nval = t->start_hold / ns_per_clk;\r\nwritel_relaxed(val, i2c_dev->base + SSC_START_HOLD);\r\nval = t->data_setup_time / ns_per_clk;\r\nwritel_relaxed(val, i2c_dev->base + SSC_DATA_SETUP);\r\nval = t->stop_setup_time / ns_per_clk;\r\nwritel_relaxed(val, i2c_dev->base + SSC_STOP_SETUP);\r\nval = t->bus_free_time / ns_per_clk;\r\nwritel_relaxed(val, i2c_dev->base + SSC_BUS_FREE);\r\nval = rate / 10000000;\r\nwritel_relaxed(val, i2c_dev->base + SSC_PRSCALER);\r\nwritel_relaxed(val, i2c_dev->base + SSC_PRSCALER_DATAOUT);\r\nval = i2c_dev->scl_min_width_us * rate / 100000000;\r\nwritel_relaxed(val, i2c_dev->base + SSC_NOISE_SUPP_WIDTH);\r\nval = i2c_dev->sda_min_width_us * rate / 100000000;\r\nwritel_relaxed(val, i2c_dev->base + SSC_NOISE_SUPP_WIDTH_DATAOUT);\r\n}\r\nstatic int st_i2c_recover_bus(struct i2c_adapter *i2c_adap)\r\n{\r\nstruct st_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\r\nu32 ctl;\r\ndev_dbg(i2c_dev->dev, "Trying to recover bus\n");\r\nwritel_relaxed(0, i2c_dev->base + SSC_IEN);\r\nst_i2c_hw_config(i2c_dev);\r\nctl = SSC_CTL_EN | SSC_CTL_MS | SSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO;\r\nst_i2c_set_bits(i2c_dev->base + SSC_CTL, ctl);\r\nst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_I2CM);\r\nusleep_range(8000, 10000);\r\nwritel_relaxed(0, i2c_dev->base + SSC_TBUF);\r\nusleep_range(2000, 4000);\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_I2CM);\r\nreturn 0;\r\n}\r\nstatic int st_i2c_wait_free_bus(struct st_i2c_dev *i2c_dev)\r\n{\r\nu32 sta;\r\nint i, ret;\r\nfor (i = 0; i < 10; i++) {\r\nsta = readl_relaxed(i2c_dev->base + SSC_STA);\r\nif (!(sta & SSC_STA_BUSY))\r\nreturn 0;\r\nusleep_range(2000, 4000);\r\n}\r\ndev_err(i2c_dev->dev, "bus not free (status = 0x%08x)\n", sta);\r\nret = i2c_recover_bus(&i2c_dev->adap);\r\nif (ret) {\r\ndev_err(i2c_dev->dev, "Failed to recover the bus (%d)\n", ret);\r\nreturn ret;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic inline void st_i2c_write_tx_fifo(struct st_i2c_dev *i2c_dev, u8 byte)\r\n{\r\nu16 tbuf = byte << 1;\r\nwritel_relaxed(tbuf | 1, i2c_dev->base + SSC_TBUF);\r\n}\r\nstatic void st_i2c_wr_fill_tx_fifo(struct st_i2c_dev *i2c_dev)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nu32 tx_fstat, sta;\r\nint i;\r\nsta = readl_relaxed(i2c_dev->base + SSC_STA);\r\nif (sta & SSC_STA_TX_FIFO_FULL)\r\nreturn;\r\ntx_fstat = readl_relaxed(i2c_dev->base + SSC_TX_FSTAT);\r\ntx_fstat &= SSC_TX_FSTAT_STATUS;\r\nif (c->count < (SSC_TXFIFO_SIZE - tx_fstat))\r\ni = c->count;\r\nelse\r\ni = SSC_TXFIFO_SIZE - tx_fstat;\r\nfor (; i > 0; i--, c->count--, c->buf++)\r\nst_i2c_write_tx_fifo(i2c_dev, *c->buf);\r\n}\r\nstatic void st_i2c_rd_fill_tx_fifo(struct st_i2c_dev *i2c_dev, int max)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nu32 tx_fstat, sta;\r\nint i;\r\nsta = readl_relaxed(i2c_dev->base + SSC_STA);\r\nif (sta & SSC_STA_TX_FIFO_FULL)\r\nreturn;\r\ntx_fstat = readl_relaxed(i2c_dev->base + SSC_TX_FSTAT);\r\ntx_fstat &= SSC_TX_FSTAT_STATUS;\r\nif (max < (SSC_TXFIFO_SIZE - tx_fstat))\r\ni = max;\r\nelse\r\ni = SSC_TXFIFO_SIZE - tx_fstat;\r\nfor (; i > 0; i--, c->xfered++)\r\nst_i2c_write_tx_fifo(i2c_dev, 0xff);\r\n}\r\nstatic void st_i2c_read_rx_fifo(struct st_i2c_dev *i2c_dev)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nu32 i, sta;\r\nu16 rbuf;\r\nsta = readl_relaxed(i2c_dev->base + SSC_STA);\r\nif (sta & SSC_STA_RIR) {\r\ni = SSC_RXFIFO_SIZE;\r\n} else {\r\ni = readl_relaxed(i2c_dev->base + SSC_RX_FSTAT);\r\ni &= SSC_RX_FSTAT_STATUS;\r\n}\r\nfor (; (i > 0) && (c->count > 0); i--, c->count--) {\r\nrbuf = readl_relaxed(i2c_dev->base + SSC_RBUF) >> 1;\r\n*c->buf++ = (u8)rbuf & 0xff;\r\n}\r\nif (i) {\r\ndev_err(i2c_dev->dev, "Unexpected %d bytes in rx fifo\n", i);\r\nst_i2c_flush_rx_fifo(i2c_dev);\r\n}\r\n}\r\nstatic void st_i2c_terminate_xfer(struct st_i2c_dev *i2c_dev)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nst_i2c_clr_bits(i2c_dev->base + SSC_IEN, SSC_IEN_TEEN);\r\nst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STRTG);\r\nif (c->stop) {\r\nst_i2c_set_bits(i2c_dev->base + SSC_IEN, SSC_IEN_STOPEN);\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STOPG);\r\n} else {\r\nst_i2c_set_bits(i2c_dev->base + SSC_IEN, SSC_IEN_REPSTRTEN);\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_REPSTRTG);\r\n}\r\n}\r\nstatic void st_i2c_handle_write(struct st_i2c_dev *i2c_dev)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nst_i2c_flush_rx_fifo(i2c_dev);\r\nif (!c->count)\r\nst_i2c_terminate_xfer(i2c_dev);\r\nelse\r\nst_i2c_wr_fill_tx_fifo(i2c_dev);\r\n}\r\nstatic void st_i2c_handle_read(struct st_i2c_dev *i2c_dev)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nu32 ien;\r\nif (!c->xfered) {\r\nreadl_relaxed(i2c_dev->base + SSC_RBUF);\r\nst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_TXENB);\r\n} else {\r\nst_i2c_read_rx_fifo(i2c_dev);\r\n}\r\nif (!c->count) {\r\nst_i2c_terminate_xfer(i2c_dev);\r\n} else if (c->count == 1) {\r\nst_i2c_clr_bits(i2c_dev->base + SSC_I2C, SSC_I2C_ACKG);\r\nien = SSC_IEN_NACKEN | SSC_IEN_ARBLEN;\r\nwritel_relaxed(ien, i2c_dev->base + SSC_IEN);\r\nst_i2c_rd_fill_tx_fifo(i2c_dev, c->count);\r\n} else {\r\nst_i2c_rd_fill_tx_fifo(i2c_dev, c->count - 1);\r\n}\r\n}\r\nstatic irqreturn_t st_i2c_isr_thread(int irq, void *data)\r\n{\r\nstruct st_i2c_dev *i2c_dev = data;\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nu32 sta, ien;\r\nint it;\r\nien = readl_relaxed(i2c_dev->base + SSC_IEN);\r\nsta = readl_relaxed(i2c_dev->base + SSC_STA);\r\nit = __fls(sta & ien);\r\nif (it < 0) {\r\ndev_dbg(i2c_dev->dev, "spurious it (sta=0x%04x, ien=0x%04x)\n",\r\nsta, ien);\r\nreturn IRQ_NONE;\r\n}\r\nswitch (1 << it) {\r\ncase SSC_STA_TE:\r\nif (c->addr & I2C_M_RD)\r\nst_i2c_handle_read(i2c_dev);\r\nelse\r\nst_i2c_handle_write(i2c_dev);\r\nbreak;\r\ncase SSC_STA_STOP:\r\ncase SSC_STA_REPSTRT:\r\nwritel_relaxed(0, i2c_dev->base + SSC_IEN);\r\ncomplete(&i2c_dev->complete);\r\nbreak;\r\ncase SSC_STA_NACK:\r\nwritel_relaxed(SSC_CLR_NACK, i2c_dev->base + SSC_CLR);\r\nif ((c->addr & I2C_M_RD) && (c->count == 1) && (c->xfered)) {\r\nst_i2c_handle_read(i2c_dev);\r\nbreak;\r\n}\r\nit = SSC_IEN_STOPEN | SSC_IEN_ARBLEN;\r\nwritel_relaxed(it, i2c_dev->base + SSC_IEN);\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STOPG);\r\nc->result = -EIO;\r\nbreak;\r\ncase SSC_STA_ARBL:\r\nwritel_relaxed(SSC_CLR_SSCARBL, i2c_dev->base + SSC_CLR);\r\nit = SSC_IEN_STOPEN | SSC_IEN_ARBLEN;\r\nwritel_relaxed(it, i2c_dev->base + SSC_IEN);\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STOPG);\r\nc->result = -EAGAIN;\r\nbreak;\r\ndefault:\r\ndev_err(i2c_dev->dev,\r\n"it %d unhandled (sta=0x%04x)\n", it, sta);\r\n}\r\nreadl(i2c_dev->base + SSC_IEN);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int st_i2c_xfer_msg(struct st_i2c_dev *i2c_dev, struct i2c_msg *msg,\r\nbool is_first, bool is_last)\r\n{\r\nstruct st_i2c_client *c = &i2c_dev->client;\r\nu32 ctl, i2c, it;\r\nunsigned long timeout;\r\nint ret;\r\nc->addr = i2c_8bit_addr_from_msg(msg);\r\nc->buf = msg->buf;\r\nc->count = msg->len;\r\nc->xfered = 0;\r\nc->result = 0;\r\nc->stop = is_last;\r\nreinit_completion(&i2c_dev->complete);\r\nctl = SSC_CTL_EN | SSC_CTL_MS | SSC_CTL_EN_RX_FIFO | SSC_CTL_EN_TX_FIFO;\r\nst_i2c_set_bits(i2c_dev->base + SSC_CTL, ctl);\r\ni2c = SSC_I2C_TXENB;\r\nif (c->addr & I2C_M_RD)\r\ni2c |= SSC_I2C_ACKG;\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, i2c);\r\nst_i2c_write_tx_fifo(i2c_dev, c->addr);\r\nif (!(c->addr & I2C_M_RD))\r\nst_i2c_wr_fill_tx_fifo(i2c_dev);\r\nit = SSC_IEN_NACKEN | SSC_IEN_TEEN | SSC_IEN_ARBLEN;\r\nwritel_relaxed(it, i2c_dev->base + SSC_IEN);\r\nif (is_first) {\r\nret = st_i2c_wait_free_bus(i2c_dev);\r\nif (ret)\r\nreturn ret;\r\nst_i2c_set_bits(i2c_dev->base + SSC_I2C, SSC_I2C_STRTG);\r\n}\r\ntimeout = wait_for_completion_timeout(&i2c_dev->complete,\r\ni2c_dev->adap.timeout);\r\nret = c->result;\r\nif (!timeout) {\r\ndev_err(i2c_dev->dev, "Write to slave 0x%x timed out\n",\r\nc->addr);\r\nret = -ETIMEDOUT;\r\n}\r\ni2c = SSC_I2C_STOPG | SSC_I2C_REPSTRTG;\r\nst_i2c_clr_bits(i2c_dev->base + SSC_I2C, i2c);\r\nwritel_relaxed(SSC_CLR_SSCSTOP | SSC_CLR_REPSTRT,\r\ni2c_dev->base + SSC_CLR);\r\nreturn ret;\r\n}\r\nstatic int st_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct st_i2c_dev *i2c_dev = i2c_get_adapdata(i2c_adap);\r\nint ret, i;\r\ni2c_dev->busy = true;\r\nret = clk_prepare_enable(i2c_dev->clk);\r\nif (ret) {\r\ndev_err(i2c_dev->dev, "Failed to prepare_enable clock\n");\r\nreturn ret;\r\n}\r\npinctrl_pm_select_default_state(i2c_dev->dev);\r\nst_i2c_hw_config(i2c_dev);\r\nfor (i = 0; (i < num) && !ret; i++)\r\nret = st_i2c_xfer_msg(i2c_dev, &msgs[i], i == 0, i == num - 1);\r\npinctrl_pm_select_idle_state(i2c_dev->dev);\r\nclk_disable_unprepare(i2c_dev->clk);\r\ni2c_dev->busy = false;\r\nreturn (ret < 0) ? ret : i;\r\n}\r\nstatic int st_i2c_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct st_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\nif (i2c_dev->busy)\r\nreturn -EBUSY;\r\npinctrl_pm_select_sleep_state(dev);\r\nreturn 0;\r\n}\r\nstatic int st_i2c_resume(struct device *dev)\r\n{\r\npinctrl_pm_select_default_state(dev);\r\npinctrl_pm_select_idle_state(dev);\r\nreturn 0;\r\n}\r\nstatic u32 st_i2c_func(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;\r\n}\r\nstatic int st_i2c_of_get_deglitch(struct device_node *np,\r\nstruct st_i2c_dev *i2c_dev)\r\n{\r\nint ret;\r\nret = of_property_read_u32(np, "st,i2c-min-scl-pulse-width-us",\r\n&i2c_dev->scl_min_width_us);\r\nif ((ret == -ENODATA) || (ret == -EOVERFLOW)) {\r\ndev_err(i2c_dev->dev, "st,i2c-min-scl-pulse-width-us invalid\n");\r\nreturn ret;\r\n}\r\nret = of_property_read_u32(np, "st,i2c-min-sda-pulse-width-us",\r\n&i2c_dev->sda_min_width_us);\r\nif ((ret == -ENODATA) || (ret == -EOVERFLOW)) {\r\ndev_err(i2c_dev->dev, "st,i2c-min-sda-pulse-width-us invalid\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_i2c_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct st_i2c_dev *i2c_dev;\r\nstruct resource *res;\r\nu32 clk_rate;\r\nstruct i2c_adapter *adap;\r\nint ret;\r\ni2c_dev = devm_kzalloc(&pdev->dev, sizeof(*i2c_dev), GFP_KERNEL);\r\nif (!i2c_dev)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ni2c_dev->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(i2c_dev->base))\r\nreturn PTR_ERR(i2c_dev->base);\r\ni2c_dev->irq = irq_of_parse_and_map(np, 0);\r\nif (!i2c_dev->irq) {\r\ndev_err(&pdev->dev, "IRQ missing or invalid\n");\r\nreturn -EINVAL;\r\n}\r\ni2c_dev->clk = of_clk_get_by_name(np, "ssc");\r\nif (IS_ERR(i2c_dev->clk)) {\r\ndev_err(&pdev->dev, "Unable to request clock\n");\r\nreturn PTR_ERR(i2c_dev->clk);\r\n}\r\ni2c_dev->mode = I2C_MODE_STANDARD;\r\nret = of_property_read_u32(np, "clock-frequency", &clk_rate);\r\nif ((!ret) && (clk_rate == 400000))\r\ni2c_dev->mode = I2C_MODE_FAST;\r\ni2c_dev->dev = &pdev->dev;\r\nret = devm_request_threaded_irq(&pdev->dev, i2c_dev->irq,\r\nNULL, st_i2c_isr_thread,\r\nIRQF_ONESHOT, pdev->name, i2c_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq %i\n", i2c_dev->irq);\r\nreturn ret;\r\n}\r\npinctrl_pm_select_default_state(i2c_dev->dev);\r\npinctrl_pm_select_idle_state(i2c_dev->dev);\r\nret = st_i2c_of_get_deglitch(np, i2c_dev);\r\nif (ret)\r\nreturn ret;\r\nadap = &i2c_dev->adap;\r\ni2c_set_adapdata(adap, i2c_dev);\r\nsnprintf(adap->name, sizeof(adap->name), "ST I2C(%pa)", &res->start);\r\nadap->owner = THIS_MODULE;\r\nadap->timeout = 2 * HZ;\r\nadap->retries = 0;\r\nadap->algo = &st_i2c_algo;\r\nadap->bus_recovery_info = &st_i2c_recovery_info;\r\nadap->dev.parent = &pdev->dev;\r\nadap->dev.of_node = pdev->dev.of_node;\r\ninit_completion(&i2c_dev->complete);\r\nret = i2c_add_adapter(adap);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, i2c_dev);\r\ndev_info(i2c_dev->dev, "%s initialized\n", adap->name);\r\nreturn 0;\r\n}\r\nstatic int st_i2c_remove(struct platform_device *pdev)\r\n{\r\nstruct st_i2c_dev *i2c_dev = platform_get_drvdata(pdev);\r\ni2c_del_adapter(&i2c_dev->adap);\r\nreturn 0;\r\n}
