void task_mem(struct seq_file *m, struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct vm_region *region;\r\nstruct rb_node *p;\r\nunsigned long bytes = 0, sbytes = 0, slack = 0, size;\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\r\nvma = rb_entry(p, struct vm_area_struct, vm_rb);\r\nbytes += kobjsize(vma);\r\nregion = vma->vm_region;\r\nif (region) {\r\nsize = kobjsize(region);\r\nsize += region->vm_end - region->vm_start;\r\n} else {\r\nsize = vma->vm_end - vma->vm_start;\r\n}\r\nif (atomic_read(&mm->mm_count) > 1 ||\r\nvma->vm_flags & VM_MAYSHARE) {\r\nsbytes += size;\r\n} else {\r\nbytes += size;\r\nif (region)\r\nslack = region->vm_end - vma->vm_end;\r\n}\r\n}\r\nif (atomic_read(&mm->mm_count) > 1)\r\nsbytes += kobjsize(mm);\r\nelse\r\nbytes += kobjsize(mm);\r\nif (current->fs && current->fs->users > 1)\r\nsbytes += kobjsize(current->fs);\r\nelse\r\nbytes += kobjsize(current->fs);\r\nif (current->files && atomic_read(&current->files->count) > 1)\r\nsbytes += kobjsize(current->files);\r\nelse\r\nbytes += kobjsize(current->files);\r\nif (current->sighand && atomic_read(&current->sighand->count) > 1)\r\nsbytes += kobjsize(current->sighand);\r\nelse\r\nbytes += kobjsize(current->sighand);\r\nbytes += kobjsize(current);\r\nseq_printf(m,\r\n"Mem:\t%8lu bytes\n"\r\n"Slack:\t%8lu bytes\n"\r\n"Shared:\t%8lu bytes\n",\r\nbytes, slack, sbytes);\r\nup_read(&mm->mmap_sem);\r\n}\r\nunsigned long task_vsize(struct mm_struct *mm)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct rb_node *p;\r\nunsigned long vsize = 0;\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\r\nvma = rb_entry(p, struct vm_area_struct, vm_rb);\r\nvsize += vma->vm_end - vma->vm_start;\r\n}\r\nup_read(&mm->mmap_sem);\r\nreturn vsize;\r\n}\r\nunsigned long task_statm(struct mm_struct *mm,\r\nunsigned long *shared, unsigned long *text,\r\nunsigned long *data, unsigned long *resident)\r\n{\r\nstruct vm_area_struct *vma;\r\nstruct vm_region *region;\r\nstruct rb_node *p;\r\nunsigned long size = kobjsize(mm);\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p)) {\r\nvma = rb_entry(p, struct vm_area_struct, vm_rb);\r\nsize += kobjsize(vma);\r\nregion = vma->vm_region;\r\nif (region) {\r\nsize += kobjsize(region);\r\nsize += region->vm_end - region->vm_start;\r\n}\r\n}\r\n*text = (PAGE_ALIGN(mm->end_code) - (mm->start_code & PAGE_MASK))\r\n>> PAGE_SHIFT;\r\n*data = (PAGE_ALIGN(mm->start_stack) - (mm->start_data & PAGE_MASK))\r\n>> PAGE_SHIFT;\r\nup_read(&mm->mmap_sem);\r\nsize >>= PAGE_SHIFT;\r\nsize += *text + *data;\r\n*resident = size;\r\nreturn size;\r\n}\r\nstatic int is_stack(struct proc_maps_private *priv,\r\nstruct vm_area_struct *vma)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nreturn vma->vm_start <= mm->start_stack &&\r\nvma->vm_end >= mm->start_stack;\r\n}\r\nstatic int nommu_vma_show(struct seq_file *m, struct vm_area_struct *vma,\r\nint is_pid)\r\n{\r\nstruct mm_struct *mm = vma->vm_mm;\r\nstruct proc_maps_private *priv = m->private;\r\nunsigned long ino = 0;\r\nstruct file *file;\r\ndev_t dev = 0;\r\nint flags;\r\nunsigned long long pgoff = 0;\r\nflags = vma->vm_flags;\r\nfile = vma->vm_file;\r\nif (file) {\r\nstruct inode *inode = file_inode(vma->vm_file);\r\ndev = inode->i_sb->s_dev;\r\nino = inode->i_ino;\r\npgoff = (loff_t)vma->vm_pgoff << PAGE_SHIFT;\r\n}\r\nseq_setwidth(m, 25 + sizeof(void *) * 6 - 1);\r\nseq_printf(m,\r\n"%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu ",\r\nvma->vm_start,\r\nvma->vm_end,\r\nflags & VM_READ ? 'r' : '-',\r\nflags & VM_WRITE ? 'w' : '-',\r\nflags & VM_EXEC ? 'x' : '-',\r\nflags & VM_MAYSHARE ? flags & VM_SHARED ? 'S' : 's' : 'p',\r\npgoff,\r\nMAJOR(dev), MINOR(dev), ino);\r\nif (file) {\r\nseq_pad(m, ' ');\r\nseq_file_path(m, file, "");\r\n} else if (mm && is_stack(priv, vma)) {\r\nseq_pad(m, ' ');\r\nseq_printf(m, "[stack]");\r\n}\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int show_map(struct seq_file *m, void *_p, int is_pid)\r\n{\r\nstruct rb_node *p = _p;\r\nreturn nommu_vma_show(m, rb_entry(p, struct vm_area_struct, vm_rb),\r\nis_pid);\r\n}\r\nstatic int show_pid_map(struct seq_file *m, void *_p)\r\n{\r\nreturn show_map(m, _p, 1);\r\n}\r\nstatic int show_tid_map(struct seq_file *m, void *_p)\r\n{\r\nreturn show_map(m, _p, 0);\r\n}\r\nstatic void *m_start(struct seq_file *m, loff_t *pos)\r\n{\r\nstruct proc_maps_private *priv = m->private;\r\nstruct mm_struct *mm;\r\nstruct rb_node *p;\r\nloff_t n = *pos;\r\npriv->task = get_proc_task(priv->inode);\r\nif (!priv->task)\r\nreturn ERR_PTR(-ESRCH);\r\nmm = priv->mm;\r\nif (!mm || !mmget_not_zero(mm))\r\nreturn NULL;\r\ndown_read(&mm->mmap_sem);\r\nfor (p = rb_first(&mm->mm_rb); p; p = rb_next(p))\r\nif (n-- == 0)\r\nreturn p;\r\nup_read(&mm->mmap_sem);\r\nmmput(mm);\r\nreturn NULL;\r\n}\r\nstatic void m_stop(struct seq_file *m, void *_vml)\r\n{\r\nstruct proc_maps_private *priv = m->private;\r\nif (!IS_ERR_OR_NULL(_vml)) {\r\nup_read(&priv->mm->mmap_sem);\r\nmmput(priv->mm);\r\n}\r\nif (priv->task) {\r\nput_task_struct(priv->task);\r\npriv->task = NULL;\r\n}\r\n}\r\nstatic void *m_next(struct seq_file *m, void *_p, loff_t *pos)\r\n{\r\nstruct rb_node *p = _p;\r\n(*pos)++;\r\nreturn p ? rb_next(p) : NULL;\r\n}\r\nstatic int maps_open(struct inode *inode, struct file *file,\r\nconst struct seq_operations *ops)\r\n{\r\nstruct proc_maps_private *priv;\r\npriv = __seq_open_private(file, ops, sizeof(*priv));\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->inode = inode;\r\npriv->mm = proc_mem_open(inode, PTRACE_MODE_READ);\r\nif (IS_ERR(priv->mm)) {\r\nint err = PTR_ERR(priv->mm);\r\nseq_release_private(inode, file);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int map_release(struct inode *inode, struct file *file)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct proc_maps_private *priv = seq->private;\r\nif (priv->mm)\r\nmmdrop(priv->mm);\r\nreturn seq_release_private(inode, file);\r\n}\r\nstatic int pid_maps_open(struct inode *inode, struct file *file)\r\n{\r\nreturn maps_open(inode, file, &proc_pid_maps_ops);\r\n}\r\nstatic int tid_maps_open(struct inode *inode, struct file *file)\r\n{\r\nreturn maps_open(inode, file, &proc_tid_maps_ops);\r\n}
