static bool max98926_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98926_VBAT_DATA:\r\ncase MAX98926_VBST_DATA:\r\ncase MAX98926_LIVE_STATUS0:\r\ncase MAX98926_LIVE_STATUS1:\r\ncase MAX98926_LIVE_STATUS2:\r\ncase MAX98926_STATE0:\r\ncase MAX98926_STATE1:\r\ncase MAX98926_STATE2:\r\ncase MAX98926_FLAG0:\r\ncase MAX98926_FLAG1:\r\ncase MAX98926_FLAG2:\r\ncase MAX98926_VERSION:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool max98926_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX98926_IRQ_CLEAR0:\r\ncase MAX98926_IRQ_CLEAR1:\r\ncase MAX98926_IRQ_CLEAR2:\r\ncase MAX98926_ALC_HOLD_RLS:\r\nreturn false;\r\ndefault:\r\nreturn true;\r\n}\r\n}\r\nstatic void max98926_set_sense_data(struct max98926_priv *max98926)\r\n{\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DOUT_CFG_VMON,\r\nMAX98926_DAI_VMON_EN_MASK,\r\nMAX98926_DAI_VMON_EN_MASK);\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DOUT_CFG_IMON,\r\nMAX98926_DAI_IMON_EN_MASK,\r\nMAX98926_DAI_IMON_EN_MASK);\r\nif (!max98926->interleave_mode) {\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DOUT_CFG_VMON,\r\nMAX98926_DAI_VMON_SLOT_MASK,\r\nmax98926->v_slot);\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DOUT_CFG_IMON,\r\nMAX98926_DAI_IMON_SLOT_MASK,\r\nmax98926->i_slot);\r\n} else {\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_FORMAT,\r\nMAX98926_DAI_INTERLEAVE_MASK,\r\nMAX98926_DAI_INTERLEAVE_MASK);\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DOUT_CFG_VBAT,\r\nMAX98926_DAI_INTERLEAVE_SLOT_MASK,\r\nmax98926->v_slot);\r\n}\r\n}\r\nstatic int max98926_dai_set_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct max98926_priv *max98926 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int invert = 0;\r\ndev_dbg(codec->dev, "%s: fmt 0x%08X\n", __func__, fmt);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmax98926_set_sense_data(max98926);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI clock mode unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\ninvert = MAX98926_DAI_WCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\ninvert = MAX98926_DAI_BCI_MASK;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\ninvert = MAX98926_DAI_BCI_MASK | MAX98926_DAI_WCI_MASK;\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "DAI invert mode unsupported\n");\r\nreturn -EINVAL;\r\n}\r\nregmap_write(max98926->regmap,\r\nMAX98926_FORMAT, MAX98926_DAI_DLY_MASK);\r\nregmap_update_bits(max98926->regmap, MAX98926_FORMAT,\r\nMAX98926_DAI_BCI_MASK, invert);\r\nreturn 0;\r\n}\r\nstatic int max98926_dai_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nint dai_sr = -EINVAL;\r\nint rate = params_rate(params), i;\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max98926_priv *max98926 = snd_soc_codec_get_drvdata(codec);\r\nint blr_clk_ratio;\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_FORMAT,\r\nMAX98926_DAI_CHANSZ_MASK,\r\nMAX98926_DAI_CHANSZ_16);\r\nmax98926->ch_size = 16;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_FORMAT,\r\nMAX98926_DAI_CHANSZ_MASK,\r\nMAX98926_DAI_CHANSZ_24);\r\nmax98926->ch_size = 24;\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_FORMAT,\r\nMAX98926_DAI_CHANSZ_MASK,\r\nMAX98926_DAI_CHANSZ_32);\r\nmax98926->ch_size = 32;\r\nbreak;\r\ndefault:\r\ndev_dbg(codec->dev, "format unsupported %d\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nblr_clk_ratio = params_channels(params) * max98926->ch_size;\r\nswitch (blr_clk_ratio) {\r\ncase 32:\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DAI_CLK_MODE2,\r\nMAX98926_DAI_BSEL_MASK,\r\nMAX98926_DAI_BSEL_32);\r\nbreak;\r\ncase 48:\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DAI_CLK_MODE2,\r\nMAX98926_DAI_BSEL_MASK,\r\nMAX98926_DAI_BSEL_48);\r\nbreak;\r\ncase 64:\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DAI_CLK_MODE2,\r\nMAX98926_DAI_BSEL_MASK,\r\nMAX98926_DAI_BSEL_64);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(rate_table); i++) {\r\nif (rate_table[i].rate >= rate) {\r\ndai_sr = rate_table[i].sr;\r\nbreak;\r\n}\r\n}\r\nif (dai_sr < 0)\r\nreturn -EINVAL;\r\nregmap_update_bits(max98926->regmap,\r\nMAX98926_DAI_CLK_MODE2,\r\nMAX98926_DAI_SR_MASK, dai_sr << MAX98926_DAI_SR_SHIFT);\r\nreturn 0;\r\n}\r\nstatic int max98926_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct max98926_priv *max98926 = snd_soc_codec_get_drvdata(codec);\r\nmax98926->codec = codec;\r\ncodec->control_data = max98926->regmap;\r\nregmap_write(max98926->regmap, MAX98926_DOUT_HIZ_CFG4, 0xF0);\r\nreturn 0;\r\n}\r\nstatic int max98926_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nint ret, reg;\r\nu32 value;\r\nstruct max98926_priv *max98926;\r\nmax98926 = devm_kzalloc(&i2c->dev,\r\nsizeof(*max98926), GFP_KERNEL);\r\nif (!max98926)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, max98926);\r\nmax98926->regmap = devm_regmap_init_i2c(i2c, &max98926_regmap);\r\nif (IS_ERR(max98926->regmap)) {\r\nret = PTR_ERR(max98926->regmap);\r\ndev_err(&i2c->dev,\r\n"Failed to allocate regmap: %d\n", ret);\r\ngoto err_out;\r\n}\r\nif (of_property_read_bool(i2c->dev.of_node, "interleave-mode"))\r\nmax98926->interleave_mode = true;\r\nif (!of_property_read_u32(i2c->dev.of_node, "vmon-slot-no", &value)) {\r\nif (value > MAX98926_DAI_VMON_SLOT_1E_1F) {\r\ndev_err(&i2c->dev, "vmon slot number is wrong:\n");\r\nreturn -EINVAL;\r\n}\r\nmax98926->v_slot = value;\r\n}\r\nif (!of_property_read_u32(i2c->dev.of_node, "imon-slot-no", &value)) {\r\nif (value > MAX98926_DAI_IMON_SLOT_1E_1F) {\r\ndev_err(&i2c->dev, "imon slot number is wrong:\n");\r\nreturn -EINVAL;\r\n}\r\nmax98926->i_slot = value;\r\n}\r\nret = regmap_read(max98926->regmap,\r\nMAX98926_VERSION, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read: %x\n", reg);\r\nreturn ret;\r\n}\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_max98926,\r\nmax98926_dai, ARRAY_SIZE(max98926_dai));\r\nif (ret < 0)\r\ndev_err(&i2c->dev,\r\n"Failed to register codec: %d\n", ret);\r\ndev_info(&i2c->dev, "device version: %x\n", reg);\r\nerr_out:\r\nreturn ret;\r\n}\r\nstatic int max98926_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
