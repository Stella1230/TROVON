void __kprobes disasm_instr(unsigned long addr, struct disasm_state *state,\r\nint userspace, struct pt_regs *regs, struct callee_regs *cregs)\r\n{\r\nint fieldA = 0;\r\nint fieldC = 0, fieldCisReg = 0;\r\nuint16_t word1 = 0, word0 = 0;\r\nint subopcode, is_linked, op_format;\r\nuint16_t *ins_ptr;\r\nuint16_t ins_buf[4];\r\nint bytes_not_copied = 0;\r\nmemset(state, 0, sizeof(struct disasm_state));\r\nif (userspace) {\r\nbytes_not_copied = copy_from_user(ins_buf,\r\n(const void __user *) addr, 8);\r\nif (bytes_not_copied > 6)\r\ngoto fault;\r\nins_ptr = ins_buf;\r\n} else {\r\nins_ptr = (uint16_t *) addr;\r\n}\r\nword1 = *((uint16_t *)addr);\r\nstate->major_opcode = (word1 >> 11) & 0x1F;\r\nif (state->major_opcode < 0x0B) {\r\nif (bytes_not_copied > 4)\r\ngoto fault;\r\nstate->instr_len = 4;\r\nword0 = *((uint16_t *)(addr+2));\r\nstate->words[0] = (word1 << 16) | word0;\r\n} else {\r\nstate->instr_len = 2;\r\nstate->words[0] = word1;\r\n}\r\nword1 = *((uint16_t *)(addr + state->instr_len));\r\nword0 = *((uint16_t *)(addr + state->instr_len + 2));\r\nstate->words[1] = (word1 << 16) | word0;\r\nswitch (state->major_opcode) {\r\ncase op_Bcc:\r\nstate->is_branch = 1;\r\nfieldA = (IS_BIT(state->words[0], 16)) ?\r\nFIELD_s25(state->words[0]) :\r\nFIELD_s21(state->words[0]);\r\nstate->delay_slot = IS_BIT(state->words[0], 5);\r\nstate->target = fieldA + (addr & ~0x3);\r\nstate->flow = direct_jump;\r\nbreak;\r\ncase op_BLcc:\r\nif (IS_BIT(state->words[0], 16)) {\r\nfieldA = (IS_BIT(state->words[0], 17)) ?\r\n(FIELD_s25(state->words[0]) & ~0x3) :\r\nFIELD_s21(state->words[0]);\r\nstate->flow = direct_call;\r\n} else {\r\nfieldA = FIELD_s9(state->words[0]) & ~0x3;\r\nstate->flow = direct_jump;\r\n}\r\nstate->delay_slot = IS_BIT(state->words[0], 5);\r\nstate->target = fieldA + (addr & ~0x3);\r\nstate->is_branch = 1;\r\nbreak;\r\ncase op_LD:\r\nstate->write = 0;\r\nstate->di = BITS(state->words[0], 11, 11);\r\nif (state->di)\r\nbreak;\r\nstate->x = BITS(state->words[0], 6, 6);\r\nstate->zz = BITS(state->words[0], 7, 8);\r\nstate->aa = BITS(state->words[0], 9, 10);\r\nstate->wb_reg = FIELD_B(state->words[0]);\r\nif (state->wb_reg == REG_LIMM) {\r\nstate->instr_len += 4;\r\nstate->aa = 0;\r\nstate->src1 = state->words[1];\r\n} else {\r\nstate->src1 = get_reg(state->wb_reg, regs, cregs);\r\n}\r\nstate->src2 = FIELD_s9(state->words[0]);\r\nstate->dest = FIELD_A(state->words[0]);\r\nstate->pref = (state->dest == REG_LIMM);\r\nbreak;\r\ncase op_ST:\r\nstate->write = 1;\r\nstate->di = BITS(state->words[0], 5, 5);\r\nif (state->di)\r\nbreak;\r\nstate->aa = BITS(state->words[0], 3, 4);\r\nstate->zz = BITS(state->words[0], 1, 2);\r\nstate->src1 = FIELD_C(state->words[0]);\r\nif (state->src1 == REG_LIMM) {\r\nstate->instr_len += 4;\r\nstate->src1 = state->words[1];\r\n} else {\r\nstate->src1 = get_reg(state->src1, regs, cregs);\r\n}\r\nstate->wb_reg = FIELD_B(state->words[0]);\r\nif (state->wb_reg == REG_LIMM) {\r\nstate->aa = 0;\r\nstate->instr_len += 4;\r\nstate->src2 = state->words[1];\r\n} else {\r\nstate->src2 = get_reg(state->wb_reg, regs, cregs);\r\n}\r\nstate->src3 = FIELD_s9(state->words[0]);\r\nbreak;\r\ncase op_MAJOR_4:\r\nsubopcode = MINOR_OPCODE(state->words[0]);\r\nswitch (subopcode) {\r\ncase 32:\r\ncase 33:\r\ncase 34:\r\ncase 35:\r\nis_linked = 0;\r\nif (subopcode == 33 || subopcode == 35)\r\nstate->delay_slot = 1;\r\nif (subopcode == 34 || subopcode == 35)\r\nis_linked = 1;\r\nfieldCisReg = 0;\r\nop_format = BITS(state->words[0], 22, 23);\r\nif (op_format == 0 || ((op_format == 3) &&\r\n(!IS_BIT(state->words[0], 5)))) {\r\nfieldC = FIELD_C(state->words[0]);\r\nif (fieldC == REG_LIMM) {\r\nfieldC = state->words[1];\r\nstate->instr_len += 4;\r\n} else {\r\nfieldCisReg = 1;\r\n}\r\n} else if (op_format == 1 || ((op_format == 3)\r\n&& (IS_BIT(state->words[0], 5)))) {\r\nfieldC = FIELD_C(state->words[0]);\r\n} else {\r\nfieldC = FIELD_s12(state->words[0]);\r\n}\r\nif (!fieldCisReg) {\r\nstate->target = fieldC;\r\nstate->flow = is_linked ?\r\ndirect_call : direct_jump;\r\n} else {\r\nstate->target = get_reg(fieldC, regs, cregs);\r\nstate->flow = is_linked ?\r\nindirect_call : indirect_jump;\r\n}\r\nstate->is_branch = 1;\r\nbreak;\r\ncase 40:\r\nif (BITS(state->words[0], 22, 23) == 3) {\r\nfieldC = FIELD_C(state->words[0]);\r\nfieldC = fieldC << 1;\r\nfieldC += (addr & ~0x03);\r\nstate->is_branch = 1;\r\nstate->flow = direct_jump;\r\nstate->target = fieldC;\r\n}\r\nbreak;\r\ncase 48 ... 55:\r\nstate->di = BITS(state->words[0], 15, 15);\r\nif (state->di)\r\nbreak;\r\nstate->x = BITS(state->words[0], 16, 16);\r\nstate->zz = BITS(state->words[0], 17, 18);\r\nstate->aa = BITS(state->words[0], 22, 23);\r\nstate->wb_reg = FIELD_B(state->words[0]);\r\nif (state->wb_reg == REG_LIMM) {\r\nstate->instr_len += 4;\r\nstate->src1 = state->words[1];\r\n} else {\r\nstate->src1 = get_reg(state->wb_reg, regs,\r\ncregs);\r\n}\r\nstate->src2 = FIELD_C(state->words[0]);\r\nif (state->src2 == REG_LIMM) {\r\nstate->instr_len += 4;\r\nstate->src2 = state->words[1];\r\n} else {\r\nstate->src2 = get_reg(state->src2, regs,\r\ncregs);\r\n}\r\nstate->dest = FIELD_A(state->words[0]);\r\nif (state->dest == REG_LIMM)\r\nstate->pref = 1;\r\nbreak;\r\ncase 10:\r\nswitch (BITS(state->words[0], 22, 23)) {\r\ncase 0:\r\nif (FIELD_C(state->words[0]) == REG_LIMM)\r\nstate->instr_len += 4;\r\nbreak;\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 3:\r\nif ((!IS_BIT(state->words[0], 5)) &&\r\n(FIELD_C(state->words[0]) == REG_LIMM))\r\nstate->instr_len += 4;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\nswitch (BITS(state->words[0], 22, 23)) {\r\ncase 0:\r\nif ((FIELD_B(state->words[0]) == REG_LIMM) ||\r\n(FIELD_C(state->words[0]) == REG_LIMM))\r\nstate->instr_len += 4;\r\nbreak;\r\ncase 1:\r\nbreak;\r\ncase 2:\r\nbreak;\r\ncase 3:\r\nif ((!IS_BIT(state->words[0], 5)) &&\r\n((FIELD_B(state->words[0]) == REG_LIMM) ||\r\n(FIELD_C(state->words[0]) == REG_LIMM)))\r\nstate->instr_len += 4;\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nbreak;\r\ncase op_LD_ADD:\r\nstate->zz = BITS(state->words[0], 3, 4);\r\nstate->src1 = get_reg(FIELD_S_B(state->words[0]), regs, cregs);\r\nstate->src2 = get_reg(FIELD_S_C(state->words[0]), regs, cregs);\r\nstate->dest = FIELD_S_A(state->words[0]);\r\nbreak;\r\ncase op_ADD_MOV_CMP:\r\nif ((BITS(state->words[0], 3, 4) < 3) &&\r\n(FIELD_S_H(state->words[0]) == REG_LIMM))\r\nstate->instr_len += 4;\r\nbreak;\r\ncase op_S:\r\nsubopcode = BITS(state->words[0], 5, 7);\r\nswitch (subopcode) {\r\ncase 0:\r\ncase 1:\r\ncase 2:\r\ncase 3:\r\nstate->target = get_reg(FIELD_S_B(state->words[0]),\r\nregs, cregs);\r\nstate->delay_slot = subopcode & 1;\r\nstate->flow = (subopcode >= 2) ?\r\ndirect_call : indirect_jump;\r\nbreak;\r\ncase 7:\r\nswitch (BITS(state->words[0], 8, 10)) {\r\ncase 4:\r\ncase 5:\r\ncase 6:\r\ncase 7:\r\nstate->delay_slot = (subopcode == 7);\r\nstate->flow = indirect_jump;\r\nstate->target = get_reg(31, regs, cregs);\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nbreak;\r\ncase op_LD_S:\r\nstate->src1 = get_reg(FIELD_S_B(state->words[0]), regs, cregs);\r\nstate->src2 = FIELD_S_u7(state->words[0]);\r\nstate->dest = FIELD_S_C(state->words[0]);\r\nbreak;\r\ncase op_LDB_S:\r\ncase op_STB_S:\r\nstate->zz = 1;\r\nbreak;\r\ncase op_LDWX_S:\r\nstate->x = 1;\r\ncase op_LDW_S:\r\nstate->zz = 2;\r\nstate->src1 = get_reg(FIELD_S_B(state->words[0]), regs, cregs);\r\nstate->src2 = FIELD_S_u6(state->words[0]);\r\nstate->dest = FIELD_S_C(state->words[0]);\r\nbreak;\r\ncase op_ST_S:\r\nstate->write = 1;\r\nstate->src1 = get_reg(FIELD_S_C(state->words[0]), regs, cregs);\r\nstate->src2 = get_reg(FIELD_S_B(state->words[0]), regs, cregs);\r\nstate->src3 = FIELD_S_u7(state->words[0]);\r\nbreak;\r\ncase op_STW_S:\r\nstate->write = 1;\r\nstate->zz = 2;\r\nstate->src1 = get_reg(FIELD_S_C(state->words[0]), regs, cregs);\r\nstate->src2 = get_reg(FIELD_S_B(state->words[0]), regs, cregs);\r\nstate->src3 = FIELD_S_u6(state->words[0]);\r\nbreak;\r\ncase op_SP:\r\nstate->write = BITS(state->words[0], 6, 6);\r\nstate->zz = BITS(state->words[0], 5, 5);\r\nif (state->zz)\r\nbreak;\r\nif (!state->write) {\r\nstate->src1 = get_reg(28, regs, cregs);\r\nstate->src2 = FIELD_S_u7(state->words[0]);\r\nstate->dest = FIELD_S_B(state->words[0]);\r\n} else {\r\nstate->src1 = get_reg(FIELD_S_B(state->words[0]), regs,\r\ncregs);\r\nstate->src2 = get_reg(28, regs, cregs);\r\nstate->src3 = FIELD_S_u7(state->words[0]);\r\n}\r\nbreak;\r\ncase op_GP:\r\nstate->zz = BITS(state->words[0], 9, 10);\r\nstate->src1 = get_reg(26, regs, cregs);\r\nstate->src2 = state->zz ? FIELD_S_s10(state->words[0]) :\r\nFIELD_S_s11(state->words[0]);\r\nstate->dest = 0;\r\nbreak;\r\ncase op_Pcl:\r\nstate->src1 = regs->ret & ~3;\r\nstate->src2 = FIELD_S_u10(state->words[0]);\r\nstate->dest = FIELD_S_B(state->words[0]);\r\nbreak;\r\ncase op_BR_S:\r\nstate->target = FIELD_S_s8(state->words[0]) + (addr & ~0x03);\r\nstate->flow = direct_jump;\r\nstate->is_branch = 1;\r\nbreak;\r\ncase op_B_S:\r\nfieldA = (BITS(state->words[0], 9, 10) == 3) ?\r\nFIELD_S_s7(state->words[0]) :\r\nFIELD_S_s10(state->words[0]);\r\nstate->target = fieldA + (addr & ~0x03);\r\nstate->flow = direct_jump;\r\nstate->is_branch = 1;\r\nbreak;\r\ncase op_BL_S:\r\nstate->target = FIELD_S_s13(state->words[0]) + (addr & ~0x03);\r\nstate->flow = direct_call;\r\nstate->is_branch = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (bytes_not_copied <= (8 - state->instr_len))\r\nreturn;\r\nfault: state->fault = 1;\r\n}\r\nlong __kprobes get_reg(int reg, struct pt_regs *regs,\r\nstruct callee_regs *cregs)\r\n{\r\nlong *p;\r\nif (reg <= 12) {\r\np = &regs->r0;\r\nreturn p[-reg];\r\n}\r\nif (cregs && (reg <= 25)) {\r\np = &cregs->r13;\r\nreturn p[13-reg];\r\n}\r\nif (reg == 26)\r\nreturn regs->r26;\r\nif (reg == 27)\r\nreturn regs->fp;\r\nif (reg == 28)\r\nreturn regs->sp;\r\nif (reg == 31)\r\nreturn regs->blink;\r\nreturn 0;\r\n}\r\nvoid __kprobes set_reg(int reg, long val, struct pt_regs *regs,\r\nstruct callee_regs *cregs)\r\n{\r\nlong *p;\r\nswitch (reg) {\r\ncase 0 ... 12:\r\np = &regs->r0;\r\np[-reg] = val;\r\nbreak;\r\ncase 13 ... 25:\r\nif (cregs) {\r\np = &cregs->r13;\r\np[13-reg] = val;\r\n}\r\nbreak;\r\ncase 26:\r\nregs->r26 = val;\r\nbreak;\r\ncase 27:\r\nregs->fp = val;\r\nbreak;\r\ncase 28:\r\nregs->sp = val;\r\nbreak;\r\ncase 31:\r\nregs->blink = val;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nint __kprobes disasm_next_pc(unsigned long pc, struct pt_regs *regs,\r\nstruct callee_regs *cregs,\r\nunsigned long *next_pc, unsigned long *tgt_if_br)\r\n{\r\nstruct disasm_state instr;\r\nmemset(&instr, 0, sizeof(struct disasm_state));\r\ndisasm_instr(pc, &instr, 0, regs, cregs);\r\n*next_pc = pc + instr.instr_len;\r\nif (instr.is_branch)\r\n*tgt_if_br = instr.target;\r\nif (instr.delay_slot) {\r\nstruct disasm_state instr_d;\r\ndisasm_instr(*next_pc, &instr_d, 0, regs, cregs);\r\n*next_pc += instr_d.instr_len;\r\n}\r\nif (!(regs->status32 & STATUS32_L) && (*next_pc == regs->lp_end)\r\n&& (regs->lp_count > 1)) {\r\n*next_pc = regs->lp_start;\r\n}\r\nreturn instr.is_branch;\r\n}
