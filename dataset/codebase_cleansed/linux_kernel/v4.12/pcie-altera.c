static inline void cra_writel(struct altera_pcie *pcie, const u32 value,\r\nconst u32 reg)\r\n{\r\nwritel_relaxed(value, pcie->cra_base + reg);\r\n}\r\nstatic inline u32 cra_readl(struct altera_pcie *pcie, const u32 reg)\r\n{\r\nreturn readl_relaxed(pcie->cra_base + reg);\r\n}\r\nstatic bool altera_pcie_link_is_up(struct altera_pcie *pcie)\r\n{\r\nreturn !!((cra_readl(pcie, RP_LTSSM) & RP_LTSSM_MASK) == LTSSM_L0);\r\n}\r\nstatic bool altera_pcie_hide_rc_bar(struct pci_bus *bus, unsigned int devfn,\r\nint offset)\r\n{\r\nif (pci_is_root_bus(bus) && (devfn == 0) &&\r\n(offset == PCI_BASE_ADDRESS_0))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void tlp_write_tx(struct altera_pcie *pcie,\r\nstruct tlp_rp_regpair_t *tlp_rp_regdata)\r\n{\r\ncra_writel(pcie, tlp_rp_regdata->reg0, RP_TX_REG0);\r\ncra_writel(pcie, tlp_rp_regdata->reg1, RP_TX_REG1);\r\ncra_writel(pcie, tlp_rp_regdata->ctrl, RP_TX_CNTRL);\r\n}\r\nstatic bool altera_pcie_valid_device(struct altera_pcie *pcie,\r\nstruct pci_bus *bus, int dev)\r\n{\r\nif (bus->number != pcie->root_bus_nr) {\r\nif (!altera_pcie_link_is_up(pcie))\r\nreturn false;\r\n}\r\nif (bus->number == pcie->root_bus_nr && dev > 0)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int tlp_read_packet(struct altera_pcie *pcie, u32 *value)\r\n{\r\nint i;\r\nbool sop = 0;\r\nu32 ctrl;\r\nu32 reg0, reg1;\r\nu32 comp_status = 1;\r\nfor (i = 0; i < TLP_LOOP; i++) {\r\nctrl = cra_readl(pcie, RP_RXCPL_STATUS);\r\nif ((ctrl & RP_RXCPL_SOP) || (ctrl & RP_RXCPL_EOP) || sop) {\r\nreg0 = cra_readl(pcie, RP_RXCPL_REG0);\r\nreg1 = cra_readl(pcie, RP_RXCPL_REG1);\r\nif (ctrl & RP_RXCPL_SOP) {\r\nsop = true;\r\ncomp_status = TLP_COMP_STATUS(reg1);\r\n}\r\nif (ctrl & RP_RXCPL_EOP) {\r\nif (comp_status)\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nif (value)\r\n*value = reg0;\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\n}\r\nudelay(5);\r\n}\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nstatic void tlp_write_packet(struct altera_pcie *pcie, u32 *headers,\r\nu32 data, bool align)\r\n{\r\nstruct tlp_rp_regpair_t tlp_rp_regdata;\r\ntlp_rp_regdata.reg0 = headers[0];\r\ntlp_rp_regdata.reg1 = headers[1];\r\ntlp_rp_regdata.ctrl = RP_TX_SOP;\r\ntlp_write_tx(pcie, &tlp_rp_regdata);\r\nif (align) {\r\ntlp_rp_regdata.reg0 = headers[2];\r\ntlp_rp_regdata.reg1 = 0;\r\ntlp_rp_regdata.ctrl = 0;\r\ntlp_write_tx(pcie, &tlp_rp_regdata);\r\ntlp_rp_regdata.reg0 = data;\r\ntlp_rp_regdata.reg1 = 0;\r\n} else {\r\ntlp_rp_regdata.reg0 = headers[2];\r\ntlp_rp_regdata.reg1 = data;\r\n}\r\ntlp_rp_regdata.ctrl = RP_TX_EOP;\r\ntlp_write_tx(pcie, &tlp_rp_regdata);\r\n}\r\nstatic int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,\r\nint where, u8 byte_en, u32 *value)\r\n{\r\nu32 headers[TLP_HDR_SIZE];\r\nheaders[0] = TLP_CFGRD_DW0(pcie, bus);\r\nheaders[1] = TLP_CFG_DW1(pcie, TLP_READ_TAG, byte_en);\r\nheaders[2] = TLP_CFG_DW2(bus, devfn, where);\r\ntlp_write_packet(pcie, headers, 0, false);\r\nreturn tlp_read_packet(pcie, value);\r\n}\r\nstatic int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,\r\nint where, u8 byte_en, u32 value)\r\n{\r\nu32 headers[TLP_HDR_SIZE];\r\nint ret;\r\nheaders[0] = TLP_CFGWR_DW0(pcie, bus);\r\nheaders[1] = TLP_CFG_DW1(pcie, TLP_WRITE_TAG, byte_en);\r\nheaders[2] = TLP_CFG_DW2(bus, devfn, where);\r\nif ((where & 0x7) == 0)\r\ntlp_write_packet(pcie, headers, value, true);\r\nelse\r\ntlp_write_packet(pcie, headers, value, false);\r\nret = tlp_read_packet(pcie, NULL);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\nif ((bus == pcie->root_bus_nr) && (where == PCI_PRIMARY_BUS))\r\npcie->root_bus_nr = (u8)(value);\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int _altera_pcie_cfg_read(struct altera_pcie *pcie, u8 busno,\r\nunsigned int devfn, int where, int size,\r\nu32 *value)\r\n{\r\nint ret;\r\nu32 data;\r\nu8 byte_en;\r\nswitch (size) {\r\ncase 1:\r\nbyte_en = 1 << (where & 3);\r\nbreak;\r\ncase 2:\r\nbyte_en = 3 << (where & 3);\r\nbreak;\r\ndefault:\r\nbyte_en = 0xf;\r\nbreak;\r\n}\r\nret = tlp_cfg_dword_read(pcie, busno, devfn,\r\n(where & ~DWORD_MASK), byte_en, &data);\r\nif (ret != PCIBIOS_SUCCESSFUL)\r\nreturn ret;\r\nswitch (size) {\r\ncase 1:\r\n*value = (data >> (8 * (where & 0x3))) & 0xff;\r\nbreak;\r\ncase 2:\r\n*value = (data >> (8 * (where & 0x2))) & 0xffff;\r\nbreak;\r\ndefault:\r\n*value = data;\r\nbreak;\r\n}\r\nreturn PCIBIOS_SUCCESSFUL;\r\n}\r\nstatic int _altera_pcie_cfg_write(struct altera_pcie *pcie, u8 busno,\r\nunsigned int devfn, int where, int size,\r\nu32 value)\r\n{\r\nu32 data32;\r\nu32 shift = 8 * (where & 3);\r\nu8 byte_en;\r\nswitch (size) {\r\ncase 1:\r\ndata32 = (value & 0xff) << shift;\r\nbyte_en = 1 << (where & 3);\r\nbreak;\r\ncase 2:\r\ndata32 = (value & 0xffff) << shift;\r\nbyte_en = 3 << (where & 3);\r\nbreak;\r\ndefault:\r\ndata32 = value;\r\nbyte_en = 0xf;\r\nbreak;\r\n}\r\nreturn tlp_cfg_dword_write(pcie, busno, devfn, (where & ~DWORD_MASK),\r\nbyte_en, data32);\r\n}\r\nstatic int altera_pcie_cfg_read(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *value)\r\n{\r\nstruct altera_pcie *pcie = bus->sysdata;\r\nif (altera_pcie_hide_rc_bar(bus, devfn, where))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (!altera_pcie_valid_device(pcie, bus, PCI_SLOT(devfn))) {\r\n*value = 0xffffffff;\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\n}\r\nreturn _altera_pcie_cfg_read(pcie, bus->number, devfn, where, size,\r\nvalue);\r\n}\r\nstatic int altera_pcie_cfg_write(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 value)\r\n{\r\nstruct altera_pcie *pcie = bus->sysdata;\r\nif (altera_pcie_hide_rc_bar(bus, devfn, where))\r\nreturn PCIBIOS_BAD_REGISTER_NUMBER;\r\nif (!altera_pcie_valid_device(pcie, bus, PCI_SLOT(devfn)))\r\nreturn PCIBIOS_DEVICE_NOT_FOUND;\r\nreturn _altera_pcie_cfg_write(pcie, bus->number, devfn, where, size,\r\nvalue);\r\n}\r\nstatic int altera_read_cap_word(struct altera_pcie *pcie, u8 busno,\r\nunsigned int devfn, int offset, u16 *value)\r\n{\r\nu32 data;\r\nint ret;\r\nret = _altera_pcie_cfg_read(pcie, busno, devfn,\r\nPCIE_CAP_OFFSET + offset, sizeof(*value),\r\n&data);\r\n*value = data;\r\nreturn ret;\r\n}\r\nstatic int altera_write_cap_word(struct altera_pcie *pcie, u8 busno,\r\nunsigned int devfn, int offset, u16 value)\r\n{\r\nreturn _altera_pcie_cfg_write(pcie, busno, devfn,\r\nPCIE_CAP_OFFSET + offset, sizeof(value),\r\nvalue);\r\n}\r\nstatic void altera_wait_link_retrain(struct altera_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nu16 reg16;\r\nunsigned long start_jiffies;\r\nstart_jiffies = jiffies;\r\nfor (;;) {\r\naltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN,\r\nPCI_EXP_LNKSTA, &reg16);\r\nif (!(reg16 & PCI_EXP_LNKSTA_LT))\r\nbreak;\r\nif (time_after(jiffies, start_jiffies + LINK_RETRAIN_TIMEOUT)) {\r\ndev_err(dev, "link retrain timeout\n");\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\nstart_jiffies = jiffies;\r\nfor (;;) {\r\nif (altera_pcie_link_is_up(pcie))\r\nbreak;\r\nif (time_after(jiffies, start_jiffies + LINK_UP_TIMEOUT)) {\r\ndev_err(dev, "link up timeout\n");\r\nbreak;\r\n}\r\nudelay(100);\r\n}\r\n}\r\nstatic void altera_pcie_retrain(struct altera_pcie *pcie)\r\n{\r\nu16 linkcap, linkstat, linkctl;\r\nif (!altera_pcie_link_is_up(pcie))\r\nreturn;\r\naltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN, PCI_EXP_LNKCAP,\r\n&linkcap);\r\nif ((linkcap & PCI_EXP_LNKCAP_SLS) <= PCI_EXP_LNKCAP_SLS_2_5GB)\r\nreturn;\r\naltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN, PCI_EXP_LNKSTA,\r\n&linkstat);\r\nif ((linkstat & PCI_EXP_LNKSTA_CLS) == PCI_EXP_LNKSTA_CLS_2_5GB) {\r\naltera_read_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN,\r\nPCI_EXP_LNKCTL, &linkctl);\r\nlinkctl |= PCI_EXP_LNKCTL_RL;\r\naltera_write_cap_word(pcie, pcie->root_bus_nr, RP_DEVFN,\r\nPCI_EXP_LNKCTL, linkctl);\r\naltera_wait_link_retrain(pcie);\r\n}\r\n}\r\nstatic int altera_pcie_intx_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &dummy_irq_chip, handle_simple_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nreturn 0;\r\n}\r\nstatic void altera_pcie_isr(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct altera_pcie *pcie;\r\nstruct device *dev;\r\nunsigned long status;\r\nu32 bit;\r\nu32 virq;\r\nchained_irq_enter(chip, desc);\r\npcie = irq_desc_get_handler_data(desc);\r\ndev = &pcie->pdev->dev;\r\nwhile ((status = cra_readl(pcie, P2A_INT_STATUS)\r\n& P2A_INT_STS_ALL) != 0) {\r\nfor_each_set_bit(bit, &status, INTX_NUM) {\r\ncra_writel(pcie, 1 << bit, P2A_INT_STATUS);\r\nvirq = irq_find_mapping(pcie->irq_domain, bit + 1);\r\nif (virq)\r\ngeneric_handle_irq(virq);\r\nelse\r\ndev_err(dev, "unexpected IRQ, INT%d\n", bit);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int altera_pcie_parse_request_of_pci_ranges(struct altera_pcie *pcie)\r\n{\r\nint err, res_valid = 0;\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct resource_entry *win;\r\nerr = of_pci_get_host_bridge_resources(np, 0, 0xff, &pcie->resources,\r\nNULL);\r\nif (err)\r\nreturn err;\r\nerr = devm_request_pci_bus_resources(dev, &pcie->resources);\r\nif (err)\r\ngoto out_release_res;\r\nresource_list_for_each_entry(win, &pcie->resources) {\r\nstruct resource *res = win->res;\r\nif (resource_type(res) == IORESOURCE_MEM)\r\nres_valid |= !(res->flags & IORESOURCE_PREFETCH);\r\n}\r\nif (res_valid)\r\nreturn 0;\r\ndev_err(dev, "non-prefetchable memory resource required\n");\r\nerr = -EINVAL;\r\nout_release_res:\r\npci_free_resource_list(&pcie->resources);\r\nreturn err;\r\n}\r\nstatic int altera_pcie_init_irq_domain(struct altera_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\npcie->irq_domain = irq_domain_add_linear(node, INTX_NUM + 1,\r\n&intx_domain_ops, pcie);\r\nif (!pcie->irq_domain) {\r\ndev_err(dev, "Failed to get a INTx IRQ domain\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int altera_pcie_parse_dt(struct altera_pcie *pcie)\r\n{\r\nstruct device *dev = &pcie->pdev->dev;\r\nstruct platform_device *pdev = pcie->pdev;\r\nstruct resource *cra;\r\ncra = platform_get_resource_byname(pdev, IORESOURCE_MEM, "Cra");\r\npcie->cra_base = devm_ioremap_resource(dev, cra);\r\nif (IS_ERR(pcie->cra_base))\r\nreturn PTR_ERR(pcie->cra_base);\r\npcie->irq = platform_get_irq(pdev, 0);\r\nif (pcie->irq <= 0) {\r\ndev_err(dev, "failed to get IRQ: %d\n", pcie->irq);\r\nreturn -EINVAL;\r\n}\r\nirq_set_chained_handler_and_data(pcie->irq, altera_pcie_isr, pcie);\r\nreturn 0;\r\n}\r\nstatic void altera_pcie_host_init(struct altera_pcie *pcie)\r\n{\r\naltera_pcie_retrain(pcie);\r\n}\r\nstatic int altera_pcie_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct altera_pcie *pcie;\r\nstruct pci_bus *bus;\r\nstruct pci_bus *child;\r\nint ret;\r\npcie = devm_kzalloc(dev, sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->pdev = pdev;\r\nret = altera_pcie_parse_dt(pcie);\r\nif (ret) {\r\ndev_err(dev, "Parsing DT failed\n");\r\nreturn ret;\r\n}\r\nINIT_LIST_HEAD(&pcie->resources);\r\nret = altera_pcie_parse_request_of_pci_ranges(pcie);\r\nif (ret) {\r\ndev_err(dev, "Failed add resources\n");\r\nreturn ret;\r\n}\r\nret = altera_pcie_init_irq_domain(pcie);\r\nif (ret) {\r\ndev_err(dev, "Failed creating IRQ Domain\n");\r\nreturn ret;\r\n}\r\ncra_writel(pcie, P2A_INT_STS_ALL, P2A_INT_STATUS);\r\ncra_writel(pcie, P2A_INT_ENA_ALL, P2A_INT_ENABLE);\r\naltera_pcie_host_init(pcie);\r\nbus = pci_scan_root_bus(dev, pcie->root_bus_nr, &altera_pcie_ops,\r\npcie, &pcie->resources);\r\nif (!bus)\r\nreturn -ENOMEM;\r\npci_fixup_irqs(pci_common_swizzle, of_irq_parse_and_map_pci);\r\npci_assign_unassigned_bus_resources(bus);\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\npci_bus_add_devices(bus);\r\nreturn ret;\r\n}
