void irq_gc_noop(struct irq_data *d)\r\n{\r\n}\r\nvoid irq_gc_mask_disable_reg(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, mask, ct->regs.disable);\r\n*ct->mask_cache &= ~mask;\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_mask_set_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\n*ct->mask_cache |= mask;\r\nirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_mask_clr_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\n*ct->mask_cache &= ~mask;\r\nirq_reg_writel(gc, *ct->mask_cache, ct->regs.mask);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_unmask_enable_reg(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, mask, ct->regs.enable);\r\n*ct->mask_cache |= mask;\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_ack_set_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, mask, ct->regs.ack);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_ack_clr_bit(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = ~d->mask;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, mask, ct->regs.ack);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_mask_disable_reg_and_ack(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, mask, ct->regs.mask);\r\nirq_reg_writel(gc, mask, ct->regs.ack);\r\nirq_gc_unlock(gc);\r\n}\r\nvoid irq_gc_eoi(struct irq_data *d)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = irq_data_get_chip_type(d);\r\nu32 mask = d->mask;\r\nirq_gc_lock(gc);\r\nirq_reg_writel(gc, mask, ct->regs.eoi);\r\nirq_gc_unlock(gc);\r\n}\r\nint irq_gc_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nu32 mask = d->mask;\r\nif (!(mask & gc->wake_enabled))\r\nreturn -EINVAL;\r\nirq_gc_lock(gc);\r\nif (on)\r\ngc->wake_active |= mask;\r\nelse\r\ngc->wake_active &= ~mask;\r\nirq_gc_unlock(gc);\r\nreturn 0;\r\n}\r\nstatic u32 irq_readl_be(void __iomem *addr)\r\n{\r\nreturn ioread32be(addr);\r\n}\r\nstatic void irq_writel_be(u32 val, void __iomem *addr)\r\n{\r\niowrite32be(val, addr);\r\n}\r\nstatic void\r\nirq_init_generic_chip(struct irq_chip_generic *gc, const char *name,\r\nint num_ct, unsigned int irq_base,\r\nvoid __iomem *reg_base, irq_flow_handler_t handler)\r\n{\r\nraw_spin_lock_init(&gc->lock);\r\ngc->num_ct = num_ct;\r\ngc->irq_base = irq_base;\r\ngc->reg_base = reg_base;\r\ngc->chip_types->chip.name = name;\r\ngc->chip_types->handler = handler;\r\n}\r\nstruct irq_chip_generic *\r\nirq_alloc_generic_chip(const char *name, int num_ct, unsigned int irq_base,\r\nvoid __iomem *reg_base, irq_flow_handler_t handler)\r\n{\r\nstruct irq_chip_generic *gc;\r\nunsigned long sz = sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);\r\ngc = kzalloc(sz, GFP_KERNEL);\r\nif (gc) {\r\nirq_init_generic_chip(gc, name, num_ct, irq_base, reg_base,\r\nhandler);\r\n}\r\nreturn gc;\r\n}\r\nstatic void\r\nirq_gc_init_mask_cache(struct irq_chip_generic *gc, enum irq_gc_flags flags)\r\n{\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nu32 *mskptr = &gc->mask_cache, mskreg = ct->regs.mask;\r\nint i;\r\nfor (i = 0; i < gc->num_ct; i++) {\r\nif (flags & IRQ_GC_MASK_CACHE_PER_TYPE) {\r\nmskptr = &ct[i].mask_cache_priv;\r\nmskreg = ct[i].regs.mask;\r\n}\r\nct[i].mask_cache = mskptr;\r\nif (flags & IRQ_GC_INIT_MASK_CACHE)\r\n*mskptr = irq_reg_readl(gc, mskreg);\r\n}\r\n}\r\nint __irq_alloc_domain_generic_chips(struct irq_domain *d, int irqs_per_chip,\r\nint num_ct, const char *name,\r\nirq_flow_handler_t handler,\r\nunsigned int clr, unsigned int set,\r\nenum irq_gc_flags gcflags)\r\n{\r\nstruct irq_domain_chip_generic *dgc;\r\nstruct irq_chip_generic *gc;\r\nint numchips, sz, i;\r\nunsigned long flags;\r\nvoid *tmp;\r\nif (d->gc)\r\nreturn -EBUSY;\r\nnumchips = DIV_ROUND_UP(d->revmap_size, irqs_per_chip);\r\nif (!numchips)\r\nreturn -EINVAL;\r\nsz = sizeof(*dgc) + numchips * sizeof(gc);\r\nsz += numchips * (sizeof(*gc) + num_ct * sizeof(struct irq_chip_type));\r\ntmp = dgc = kzalloc(sz, GFP_KERNEL);\r\nif (!dgc)\r\nreturn -ENOMEM;\r\ndgc->irqs_per_chip = irqs_per_chip;\r\ndgc->num_chips = numchips;\r\ndgc->irq_flags_to_set = set;\r\ndgc->irq_flags_to_clear = clr;\r\ndgc->gc_flags = gcflags;\r\nd->gc = dgc;\r\ntmp += sizeof(*dgc) + numchips * sizeof(gc);\r\nfor (i = 0; i < numchips; i++) {\r\ndgc->gc[i] = gc = tmp;\r\nirq_init_generic_chip(gc, name, num_ct, i * irqs_per_chip,\r\nNULL, handler);\r\ngc->domain = d;\r\nif (gcflags & IRQ_GC_BE_IO) {\r\ngc->reg_readl = &irq_readl_be;\r\ngc->reg_writel = &irq_writel_be;\r\n}\r\nraw_spin_lock_irqsave(&gc_lock, flags);\r\nlist_add_tail(&gc->list, &gc_list);\r\nraw_spin_unlock_irqrestore(&gc_lock, flags);\r\ntmp += sizeof(*gc) + num_ct * sizeof(struct irq_chip_type);\r\n}\r\nd->name = name;\r\nreturn 0;\r\n}\r\nstatic struct irq_chip_generic *\r\n__irq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq)\r\n{\r\nstruct irq_domain_chip_generic *dgc = d->gc;\r\nint idx;\r\nif (!dgc)\r\nreturn ERR_PTR(-ENODEV);\r\nidx = hw_irq / dgc->irqs_per_chip;\r\nif (idx >= dgc->num_chips)\r\nreturn ERR_PTR(-EINVAL);\r\nreturn dgc->gc[idx];\r\n}\r\nstruct irq_chip_generic *\r\nirq_get_domain_generic_chip(struct irq_domain *d, unsigned int hw_irq)\r\n{\r\nstruct irq_chip_generic *gc = __irq_get_domain_generic_chip(d, hw_irq);\r\nreturn !IS_ERR(gc) ? gc : NULL;\r\n}\r\nint irq_map_generic_chip(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw_irq)\r\n{\r\nstruct irq_data *data = irq_domain_get_irq_data(d, virq);\r\nstruct irq_domain_chip_generic *dgc = d->gc;\r\nstruct irq_chip_generic *gc;\r\nstruct irq_chip_type *ct;\r\nstruct irq_chip *chip;\r\nunsigned long flags;\r\nint idx;\r\ngc = __irq_get_domain_generic_chip(d, hw_irq);\r\nif (IS_ERR(gc))\r\nreturn PTR_ERR(gc);\r\nidx = hw_irq % dgc->irqs_per_chip;\r\nif (test_bit(idx, &gc->unused))\r\nreturn -ENOTSUPP;\r\nif (test_bit(idx, &gc->installed))\r\nreturn -EBUSY;\r\nct = gc->chip_types;\r\nchip = &ct->chip;\r\nif (!gc->installed) {\r\nraw_spin_lock_irqsave(&gc->lock, flags);\r\nirq_gc_init_mask_cache(gc, dgc->gc_flags);\r\nraw_spin_unlock_irqrestore(&gc->lock, flags);\r\n}\r\nset_bit(idx, &gc->installed);\r\nif (dgc->gc_flags & IRQ_GC_INIT_NESTED_LOCK)\r\nirq_set_lockdep_class(virq, &irq_nested_lock_class);\r\nif (chip->irq_calc_mask)\r\nchip->irq_calc_mask(data);\r\nelse\r\ndata->mask = 1 << idx;\r\nirq_domain_set_info(d, virq, hw_irq, chip, gc, ct->handler, NULL, NULL);\r\nirq_modify_status(virq, dgc->irq_flags_to_clear, dgc->irq_flags_to_set);\r\nreturn 0;\r\n}\r\nstatic void irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)\r\n{\r\nstruct irq_data *data = irq_domain_get_irq_data(d, virq);\r\nstruct irq_domain_chip_generic *dgc = d->gc;\r\nunsigned int hw_irq = data->hwirq;\r\nstruct irq_chip_generic *gc;\r\nint irq_idx;\r\ngc = irq_get_domain_generic_chip(d, hw_irq);\r\nif (!gc)\r\nreturn;\r\nirq_idx = hw_irq % dgc->irqs_per_chip;\r\nclear_bit(irq_idx, &gc->installed);\r\nirq_domain_set_info(d, virq, hw_irq, &no_irq_chip, NULL, NULL, NULL,\r\nNULL);\r\n}\r\nvoid irq_setup_generic_chip(struct irq_chip_generic *gc, u32 msk,\r\nenum irq_gc_flags flags, unsigned int clr,\r\nunsigned int set)\r\n{\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nstruct irq_chip *chip = &ct->chip;\r\nunsigned int i;\r\nraw_spin_lock(&gc_lock);\r\nlist_add_tail(&gc->list, &gc_list);\r\nraw_spin_unlock(&gc_lock);\r\nirq_gc_init_mask_cache(gc, flags);\r\nfor (i = gc->irq_base; msk; msk >>= 1, i++) {\r\nif (!(msk & 0x01))\r\ncontinue;\r\nif (flags & IRQ_GC_INIT_NESTED_LOCK)\r\nirq_set_lockdep_class(i, &irq_nested_lock_class);\r\nif (!(flags & IRQ_GC_NO_MASK)) {\r\nstruct irq_data *d = irq_get_irq_data(i);\r\nif (chip->irq_calc_mask)\r\nchip->irq_calc_mask(d);\r\nelse\r\nd->mask = 1 << (i - gc->irq_base);\r\n}\r\nirq_set_chip_and_handler(i, chip, ct->handler);\r\nirq_set_chip_data(i, gc);\r\nirq_modify_status(i, clr, set);\r\n}\r\ngc->irq_cnt = i - gc->irq_base;\r\n}\r\nint irq_setup_alt_chip(struct irq_data *d, unsigned int type)\r\n{\r\nstruct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nunsigned int i;\r\nfor (i = 0; i < gc->num_ct; i++, ct++) {\r\nif (ct->type & type) {\r\nd->chip = &ct->chip;\r\nirq_data_to_desc(d)->handle_irq = ct->handler;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid irq_remove_generic_chip(struct irq_chip_generic *gc, u32 msk,\r\nunsigned int clr, unsigned int set)\r\n{\r\nunsigned int i = gc->irq_base;\r\nraw_spin_lock(&gc_lock);\r\nlist_del(&gc->list);\r\nraw_spin_unlock(&gc_lock);\r\nfor (; msk; msk >>= 1, i++) {\r\nif (!(msk & 0x01))\r\ncontinue;\r\nirq_set_handler(i, NULL);\r\nirq_set_chip(i, &no_irq_chip);\r\nirq_set_chip_data(i, NULL);\r\nirq_modify_status(i, clr, set);\r\n}\r\n}\r\nstatic struct irq_data *irq_gc_get_irq_data(struct irq_chip_generic *gc)\r\n{\r\nunsigned int virq;\r\nif (!gc->domain)\r\nreturn irq_get_irq_data(gc->irq_base);\r\nif (!gc->installed)\r\nreturn NULL;\r\nvirq = irq_find_mapping(gc->domain, gc->irq_base + __ffs(gc->installed));\r\nreturn virq ? irq_get_irq_data(virq) : NULL;\r\n}\r\nstatic int irq_gc_suspend(void)\r\n{\r\nstruct irq_chip_generic *gc;\r\nlist_for_each_entry(gc, &gc_list, list) {\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nif (ct->chip.irq_suspend) {\r\nstruct irq_data *data = irq_gc_get_irq_data(gc);\r\nif (data)\r\nct->chip.irq_suspend(data);\r\n}\r\nif (gc->suspend)\r\ngc->suspend(gc);\r\n}\r\nreturn 0;\r\n}\r\nstatic void irq_gc_resume(void)\r\n{\r\nstruct irq_chip_generic *gc;\r\nlist_for_each_entry(gc, &gc_list, list) {\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nif (gc->resume)\r\ngc->resume(gc);\r\nif (ct->chip.irq_resume) {\r\nstruct irq_data *data = irq_gc_get_irq_data(gc);\r\nif (data)\r\nct->chip.irq_resume(data);\r\n}\r\n}\r\n}\r\nstatic void irq_gc_shutdown(void)\r\n{\r\nstruct irq_chip_generic *gc;\r\nlist_for_each_entry(gc, &gc_list, list) {\r\nstruct irq_chip_type *ct = gc->chip_types;\r\nif (ct->chip.irq_pm_shutdown) {\r\nstruct irq_data *data = irq_gc_get_irq_data(gc);\r\nif (data)\r\nct->chip.irq_pm_shutdown(data);\r\n}\r\n}\r\n}\r\nstatic int __init irq_gc_init_ops(void)\r\n{\r\nregister_syscore_ops(&irq_gc_syscore_ops);\r\nreturn 0;\r\n}
