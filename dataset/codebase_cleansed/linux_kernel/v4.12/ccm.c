static inline struct crypto_ccm_req_priv_ctx *crypto_ccm_reqctx(\r\nstruct aead_request *req)\r\n{\r\nunsigned long align = crypto_aead_alignmask(crypto_aead_reqtfm(req));\r\nreturn (void *)PTR_ALIGN((u8 *)aead_request_ctx(req), align + 1);\r\n}\r\nstatic int set_msg_len(u8 *block, unsigned int msglen, int csize)\r\n{\r\n__be32 data;\r\nmemset(block, 0, csize);\r\nblock += csize;\r\nif (csize >= 4)\r\ncsize = 4;\r\nelse if (msglen > (1 << (8 * csize)))\r\nreturn -EOVERFLOW;\r\ndata = cpu_to_be32(msglen);\r\nmemcpy(block - csize, (u8 *)&data + 4 - csize, csize);\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_setkey(struct crypto_aead *aead, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_skcipher *ctr = ctx->ctr;\r\nstruct crypto_ahash *mac = ctx->mac;\r\nint err = 0;\r\ncrypto_skcipher_clear_flags(ctr, CRYPTO_TFM_REQ_MASK);\r\ncrypto_skcipher_set_flags(ctr, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_skcipher_setkey(ctr, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_skcipher_get_flags(ctr) &\r\nCRYPTO_TFM_RES_MASK);\r\nif (err)\r\ngoto out;\r\ncrypto_ahash_clear_flags(mac, CRYPTO_TFM_REQ_MASK);\r\ncrypto_ahash_set_flags(mac, crypto_aead_get_flags(aead) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_ahash_setkey(mac, key, keylen);\r\ncrypto_aead_set_flags(aead, crypto_ahash_get_flags(mac) &\r\nCRYPTO_TFM_RES_MASK);\r\nout:\r\nreturn err;\r\n}\r\nstatic int crypto_ccm_setauthsize(struct crypto_aead *tfm,\r\nunsigned int authsize)\r\n{\r\nswitch (authsize) {\r\ncase 4:\r\ncase 6:\r\ncase 8:\r\ncase 10:\r\ncase 12:\r\ncase 14:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int format_input(u8 *info, struct aead_request *req,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int lp = req->iv[0];\r\nunsigned int l = lp + 1;\r\nunsigned int m;\r\nm = crypto_aead_authsize(aead);\r\nmemcpy(info, req->iv, 16);\r\n*info |= (8 * ((m - 2) / 2));\r\nif (req->assoclen)\r\n*info |= 64;\r\nreturn set_msg_len(info + 16 - l, cryptlen, l);\r\n}\r\nstatic int format_adata(u8 *adata, unsigned int a)\r\n{\r\nint len = 0;\r\nif (a < 65280) {\r\n*(__be16 *)adata = cpu_to_be16(a);\r\nlen = 2;\r\n} else {\r\n*(__be16 *)adata = cpu_to_be16(0xfffe);\r\n*(__be32 *)&adata[2] = cpu_to_be32(a);\r\nlen = 6;\r\n}\r\nreturn len;\r\n}\r\nstatic int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,\r\nunsigned int cryptlen)\r\n{\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nAHASH_REQUEST_ON_STACK(ahreq, ctx->mac);\r\nunsigned int assoclen = req->assoclen;\r\nstruct scatterlist sg[3];\r\nu8 *odata = pctx->odata;\r\nu8 *idata = pctx->idata;\r\nint ilen, err;\r\nerr = format_input(odata, req, cryptlen);\r\nif (err)\r\ngoto out;\r\nsg_init_table(sg, 3);\r\nsg_set_buf(&sg[0], odata, 16);\r\nif (assoclen) {\r\nilen = format_adata(idata, assoclen);\r\nsg_set_buf(&sg[1], idata, ilen);\r\nsg_chain(sg, 3, req->src);\r\n} else {\r\nilen = 0;\r\nsg_chain(sg, 2, req->src);\r\n}\r\nahash_request_set_tfm(ahreq, ctx->mac);\r\nahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);\r\nahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);\r\nerr = crypto_ahash_init(ahreq);\r\nif (err)\r\ngoto out;\r\nerr = crypto_ahash_update(ahreq);\r\nif (err)\r\ngoto out;\r\nilen = 16 - (assoclen + ilen) % 16;\r\nif (ilen < 16) {\r\nmemset(idata, 0, ilen);\r\nsg_init_table(sg, 2);\r\nsg_set_buf(&sg[0], idata, ilen);\r\nif (plain)\r\nsg_chain(sg, 2, plain);\r\nplain = sg;\r\ncryptlen += ilen;\r\n}\r\nahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);\r\nerr = crypto_ahash_finup(ahreq);\r\nout:\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_encrypt_done(struct crypto_async_request *areq, int err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nu8 *odata = pctx->odata;\r\nif (!err)\r\nscatterwalk_map_and_copy(odata, req->dst,\r\nreq->assoclen + req->cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\naead_request_complete(req, err);\r\n}\r\nstatic inline int crypto_ccm_check_iv(const u8 *iv)\r\n{\r\nif (1 > iv[0] || iv[0] > 7)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_init_crypt(struct aead_request *req, u8 *tag)\r\n{\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct scatterlist *sg;\r\nu8 *iv = req->iv;\r\nint err;\r\nerr = crypto_ccm_check_iv(iv);\r\nif (err)\r\nreturn err;\r\npctx->flags = aead_request_flags(req);\r\nmemset(iv + 15 - iv[0], 0, iv[0] + 1);\r\nsg_init_table(pctx->src, 3);\r\nsg_set_buf(pctx->src, tag, 16);\r\nsg = scatterwalk_ffwd(pctx->src + 1, req->src, req->assoclen);\r\nif (sg != pctx->src + 1)\r\nsg_chain(pctx->src, 2, sg);\r\nif (req->src != req->dst) {\r\nsg_init_table(pctx->dst, 3);\r\nsg_set_buf(pctx->dst, tag, 16);\r\nsg = scatterwalk_ffwd(pctx->dst + 1, req->dst, req->assoclen);\r\nif (sg != pctx->dst + 1)\r\nsg_chain(pctx->dst, 2, sg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_ccm_encrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct skcipher_request *skreq = &pctx->skreq;\r\nstruct scatterlist *dst;\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *odata = pctx->odata;\r\nu8 *iv = req->iv;\r\nint err;\r\nerr = crypto_ccm_init_crypt(req, odata);\r\nif (err)\r\nreturn err;\r\nerr = crypto_ccm_auth(req, sg_next(pctx->src), cryptlen);\r\nif (err)\r\nreturn err;\r\ndst = pctx->src;\r\nif (req->src != req->dst)\r\ndst = pctx->dst;\r\nskcipher_request_set_tfm(skreq, ctx->ctr);\r\nskcipher_request_set_callback(skreq, pctx->flags,\r\ncrypto_ccm_encrypt_done, req);\r\nskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\r\nerr = crypto_skcipher_encrypt(skreq);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(odata, sg_next(dst), cryptlen,\r\ncrypto_aead_authsize(aead), 1);\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_decrypt_done(struct crypto_async_request *areq,\r\nint err)\r\n{\r\nstruct aead_request *req = areq->data;\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen - authsize;\r\nstruct scatterlist *dst;\r\npctx->flags = 0;\r\ndst = sg_next(req->src == req->dst ? pctx->src : pctx->dst);\r\nif (!err) {\r\nerr = crypto_ccm_auth(req, dst, cryptlen);\r\nif (!err && crypto_memneq(pctx->auth_tag, pctx->odata, authsize))\r\nerr = -EBADMSG;\r\n}\r\naead_request_complete(req, err);\r\n}\r\nstatic int crypto_ccm_decrypt(struct aead_request *req)\r\n{\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);\r\nstruct skcipher_request *skreq = &pctx->skreq;\r\nstruct scatterlist *dst;\r\nunsigned int authsize = crypto_aead_authsize(aead);\r\nunsigned int cryptlen = req->cryptlen;\r\nu8 *authtag = pctx->auth_tag;\r\nu8 *odata = pctx->odata;\r\nu8 *iv = req->iv;\r\nint err;\r\ncryptlen -= authsize;\r\nerr = crypto_ccm_init_crypt(req, authtag);\r\nif (err)\r\nreturn err;\r\nscatterwalk_map_and_copy(authtag, sg_next(pctx->src), cryptlen,\r\nauthsize, 0);\r\ndst = pctx->src;\r\nif (req->src != req->dst)\r\ndst = pctx->dst;\r\nskcipher_request_set_tfm(skreq, ctx->ctr);\r\nskcipher_request_set_callback(skreq, pctx->flags,\r\ncrypto_ccm_decrypt_done, req);\r\nskcipher_request_set_crypt(skreq, pctx->src, dst, cryptlen + 16, iv);\r\nerr = crypto_skcipher_decrypt(skreq);\r\nif (err)\r\nreturn err;\r\nerr = crypto_ccm_auth(req, sg_next(dst), cryptlen);\r\nif (err)\r\nreturn err;\r\nif (crypto_memneq(authtag, odata, authsize))\r\nreturn -EBADMSG;\r\nreturn err;\r\n}\r\nstatic int crypto_ccm_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct ccm_instance_ctx *ictx = aead_instance_ctx(inst);\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_ahash *mac;\r\nstruct crypto_skcipher *ctr;\r\nunsigned long align;\r\nint err;\r\nmac = crypto_spawn_ahash(&ictx->mac);\r\nif (IS_ERR(mac))\r\nreturn PTR_ERR(mac);\r\nctr = crypto_spawn_skcipher(&ictx->ctr);\r\nerr = PTR_ERR(ctr);\r\nif (IS_ERR(ctr))\r\ngoto err_free_mac;\r\nctx->mac = mac;\r\nctx->ctr = ctr;\r\nalign = crypto_aead_alignmask(tfm);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nalign + sizeof(struct crypto_ccm_req_priv_ctx) +\r\ncrypto_skcipher_reqsize(ctr));\r\nreturn 0;\r\nerr_free_mac:\r\ncrypto_free_ahash(mac);\r\nreturn err;\r\n}\r\nstatic void crypto_ccm_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_ccm_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_ahash(ctx->mac);\r\ncrypto_free_skcipher(ctx->ctr);\r\n}\r\nstatic void crypto_ccm_free(struct aead_instance *inst)\r\n{\r\nstruct ccm_instance_ctx *ctx = aead_instance_ctx(inst);\r\ncrypto_drop_ahash(&ctx->mac);\r\ncrypto_drop_skcipher(&ctx->ctr);\r\nkfree(inst);\r\n}\r\nstatic int crypto_ccm_create_common(struct crypto_template *tmpl,\r\nstruct rtattr **tb,\r\nconst char *full_name,\r\nconst char *ctr_name,\r\nconst char *mac_name)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct skcipher_alg *ctr;\r\nstruct crypto_alg *mac_alg;\r\nstruct hash_alg_common *mac;\r\nstruct ccm_instance_ctx *ictx;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nmac_alg = crypto_find_alg(mac_name, &crypto_ahash_type,\r\nCRYPTO_ALG_TYPE_HASH,\r\nCRYPTO_ALG_TYPE_AHASH_MASK |\r\nCRYPTO_ALG_ASYNC);\r\nif (IS_ERR(mac_alg))\r\nreturn PTR_ERR(mac_alg);\r\nmac = __crypto_hash_alg_common(mac_alg);\r\nerr = -EINVAL;\r\nif (mac->digestsize != 16)\r\ngoto out_put_mac;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*ictx), GFP_KERNEL);\r\nerr = -ENOMEM;\r\nif (!inst)\r\ngoto out_put_mac;\r\nictx = aead_instance_ctx(inst);\r\nerr = crypto_init_ahash_spawn(&ictx->mac, mac,\r\naead_crypto_instance(inst));\r\nif (err)\r\ngoto err_free_inst;\r\ncrypto_set_skcipher_spawn(&ictx->ctr, aead_crypto_instance(inst));\r\nerr = crypto_grab_skcipher(&ictx->ctr, ctr_name, 0,\r\ncrypto_requires_sync(algt->type,\r\nalgt->mask));\r\nif (err)\r\ngoto err_drop_mac;\r\nctr = crypto_spawn_skcipher_alg(&ictx->ctr);\r\nerr = -EINVAL;\r\nif (ctr->base.cra_blocksize != 1)\r\ngoto err_drop_ctr;\r\nif (crypto_skcipher_alg_ivsize(ctr) != 16)\r\ngoto err_drop_ctr;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"ccm_base(%s,%s)", ctr->base.cra_driver_name,\r\nmac->base.cra_driver_name) >= CRYPTO_MAX_ALG_NAME)\r\ngoto err_drop_ctr;\r\nmemcpy(inst->alg.base.cra_name, full_name, CRYPTO_MAX_ALG_NAME);\r\ninst->alg.base.cra_flags = ctr->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = (mac->base.cra_priority +\r\nctr->base.cra_priority) / 2;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = mac->base.cra_alignmask |\r\nctr->base.cra_alignmask;\r\ninst->alg.ivsize = 16;\r\ninst->alg.chunksize = crypto_skcipher_alg_chunksize(ctr);\r\ninst->alg.maxauthsize = 16;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_ccm_ctx);\r\ninst->alg.init = crypto_ccm_init_tfm;\r\ninst->alg.exit = crypto_ccm_exit_tfm;\r\ninst->alg.setkey = crypto_ccm_setkey;\r\ninst->alg.setauthsize = crypto_ccm_setauthsize;\r\ninst->alg.encrypt = crypto_ccm_encrypt;\r\ninst->alg.decrypt = crypto_ccm_decrypt;\r\ninst->free = crypto_ccm_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto err_drop_ctr;\r\nout_put_mac:\r\ncrypto_mod_put(mac_alg);\r\nreturn err;\r\nerr_drop_ctr:\r\ncrypto_drop_skcipher(&ictx->ctr);\r\nerr_drop_mac:\r\ncrypto_drop_ahash(&ictx->mac);\r\nerr_free_inst:\r\nkfree(inst);\r\ngoto out_put_mac;\r\n}\r\nstatic int crypto_ccm_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nconst char *cipher_name;\r\nchar ctr_name[CRYPTO_MAX_ALG_NAME];\r\nchar mac_name[CRYPTO_MAX_ALG_NAME];\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\ncipher_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(cipher_name))\r\nreturn PTR_ERR(cipher_name);\r\nif (snprintf(ctr_name, CRYPTO_MAX_ALG_NAME, "ctr(%s)",\r\ncipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nif (snprintf(mac_name, CRYPTO_MAX_ALG_NAME, "cbcmac(%s)",\r\ncipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "ccm(%s)", cipher_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\r\nmac_name);\r\n}\r\nstatic int crypto_ccm_base_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nconst char *ctr_name;\r\nconst char *cipher_name;\r\nchar full_name[CRYPTO_MAX_ALG_NAME];\r\nctr_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ctr_name))\r\nreturn PTR_ERR(ctr_name);\r\ncipher_name = crypto_attr_alg_name(tb[2]);\r\nif (IS_ERR(cipher_name))\r\nreturn PTR_ERR(cipher_name);\r\nif (snprintf(full_name, CRYPTO_MAX_ALG_NAME, "ccm_base(%s,%s)",\r\nctr_name, cipher_name) >= CRYPTO_MAX_ALG_NAME)\r\nreturn -ENAMETOOLONG;\r\nreturn crypto_ccm_create_common(tmpl, tb, full_name, ctr_name,\r\ncipher_name);\r\n}\r\nstatic int crypto_rfc4309_setkey(struct crypto_aead *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\r\nstruct crypto_aead *child = ctx->child;\r\nint err;\r\nif (keylen < 3)\r\nreturn -EINVAL;\r\nkeylen -= 3;\r\nmemcpy(ctx->nonce, key + keylen, 3);\r\ncrypto_aead_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_aead_set_flags(child, crypto_aead_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_aead_setkey(child, key, keylen);\r\ncrypto_aead_set_flags(parent, crypto_aead_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_rfc4309_setauthsize(struct crypto_aead *parent,\r\nunsigned int authsize)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(parent);\r\nswitch (authsize) {\r\ncase 8:\r\ncase 12:\r\ncase 16:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn crypto_aead_setauthsize(ctx->child, authsize);\r\n}\r\nstatic struct aead_request *crypto_rfc4309_crypt(struct aead_request *req)\r\n{\r\nstruct crypto_rfc4309_req_ctx *rctx = aead_request_ctx(req);\r\nstruct aead_request *subreq = &rctx->subreq;\r\nstruct crypto_aead *aead = crypto_aead_reqtfm(req);\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(aead);\r\nstruct crypto_aead *child = ctx->child;\r\nstruct scatterlist *sg;\r\nu8 *iv = PTR_ALIGN((u8 *)(subreq + 1) + crypto_aead_reqsize(child),\r\ncrypto_aead_alignmask(child) + 1);\r\niv[0] = 3;\r\nmemcpy(iv + 1, ctx->nonce, 3);\r\nmemcpy(iv + 4, req->iv, 8);\r\nscatterwalk_map_and_copy(iv + 16, req->src, 0, req->assoclen - 8, 0);\r\nsg_init_table(rctx->src, 3);\r\nsg_set_buf(rctx->src, iv + 16, req->assoclen - 8);\r\nsg = scatterwalk_ffwd(rctx->src + 1, req->src, req->assoclen);\r\nif (sg != rctx->src + 1)\r\nsg_chain(rctx->src, 2, sg);\r\nif (req->src != req->dst) {\r\nsg_init_table(rctx->dst, 3);\r\nsg_set_buf(rctx->dst, iv + 16, req->assoclen - 8);\r\nsg = scatterwalk_ffwd(rctx->dst + 1, req->dst, req->assoclen);\r\nif (sg != rctx->dst + 1)\r\nsg_chain(rctx->dst, 2, sg);\r\n}\r\naead_request_set_tfm(subreq, child);\r\naead_request_set_callback(subreq, req->base.flags, req->base.complete,\r\nreq->base.data);\r\naead_request_set_crypt(subreq, rctx->src,\r\nreq->src == req->dst ? rctx->src : rctx->dst,\r\nreq->cryptlen, iv);\r\naead_request_set_ad(subreq, req->assoclen - 8);\r\nreturn subreq;\r\n}\r\nstatic int crypto_rfc4309_encrypt(struct aead_request *req)\r\n{\r\nif (req->assoclen != 16 && req->assoclen != 20)\r\nreturn -EINVAL;\r\nreq = crypto_rfc4309_crypt(req);\r\nreturn crypto_aead_encrypt(req);\r\n}\r\nstatic int crypto_rfc4309_decrypt(struct aead_request *req)\r\n{\r\nif (req->assoclen != 16 && req->assoclen != 20)\r\nreturn -EINVAL;\r\nreq = crypto_rfc4309_crypt(req);\r\nreturn crypto_aead_decrypt(req);\r\n}\r\nstatic int crypto_rfc4309_init_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct aead_instance *inst = aead_alg_instance(tfm);\r\nstruct crypto_aead_spawn *spawn = aead_instance_ctx(inst);\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\r\nstruct crypto_aead *aead;\r\nunsigned long align;\r\naead = crypto_spawn_aead(spawn);\r\nif (IS_ERR(aead))\r\nreturn PTR_ERR(aead);\r\nctx->child = aead;\r\nalign = crypto_aead_alignmask(aead);\r\nalign &= ~(crypto_tfm_ctx_alignment() - 1);\r\ncrypto_aead_set_reqsize(\r\ntfm,\r\nsizeof(struct crypto_rfc4309_req_ctx) +\r\nALIGN(crypto_aead_reqsize(aead), crypto_tfm_ctx_alignment()) +\r\nalign + 32);\r\nreturn 0;\r\n}\r\nstatic void crypto_rfc4309_exit_tfm(struct crypto_aead *tfm)\r\n{\r\nstruct crypto_rfc4309_ctx *ctx = crypto_aead_ctx(tfm);\r\ncrypto_free_aead(ctx->child);\r\n}\r\nstatic void crypto_rfc4309_free(struct aead_instance *inst)\r\n{\r\ncrypto_drop_aead(aead_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_rfc4309_create(struct crypto_template *tmpl,\r\nstruct rtattr **tb)\r\n{\r\nstruct crypto_attr_type *algt;\r\nstruct aead_instance *inst;\r\nstruct crypto_aead_spawn *spawn;\r\nstruct aead_alg *alg;\r\nconst char *ccm_name;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif ((algt->type ^ CRYPTO_ALG_TYPE_AEAD) & algt->mask)\r\nreturn -EINVAL;\r\nccm_name = crypto_attr_alg_name(tb[1]);\r\nif (IS_ERR(ccm_name))\r\nreturn PTR_ERR(ccm_name);\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nspawn = aead_instance_ctx(inst);\r\ncrypto_set_aead_spawn(spawn, aead_crypto_instance(inst));\r\nerr = crypto_grab_aead(spawn, ccm_name, 0,\r\ncrypto_requires_sync(algt->type, algt->mask));\r\nif (err)\r\ngoto out_free_inst;\r\nalg = crypto_spawn_aead_alg(spawn);\r\nerr = -EINVAL;\r\nif (crypto_aead_alg_ivsize(alg) != 16)\r\ngoto out_drop_alg;\r\nif (alg->base.cra_blocksize != 1)\r\ngoto out_drop_alg;\r\nerr = -ENAMETOOLONG;\r\nif (snprintf(inst->alg.base.cra_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4309(%s)", alg->base.cra_name) >=\r\nCRYPTO_MAX_ALG_NAME ||\r\nsnprintf(inst->alg.base.cra_driver_name, CRYPTO_MAX_ALG_NAME,\r\n"rfc4309(%s)", alg->base.cra_driver_name) >=\r\nCRYPTO_MAX_ALG_NAME)\r\ngoto out_drop_alg;\r\ninst->alg.base.cra_flags = alg->base.cra_flags & CRYPTO_ALG_ASYNC;\r\ninst->alg.base.cra_priority = alg->base.cra_priority;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.base.cra_alignmask = alg->base.cra_alignmask;\r\ninst->alg.ivsize = 8;\r\ninst->alg.chunksize = crypto_aead_alg_chunksize(alg);\r\ninst->alg.maxauthsize = 16;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_rfc4309_ctx);\r\ninst->alg.init = crypto_rfc4309_init_tfm;\r\ninst->alg.exit = crypto_rfc4309_exit_tfm;\r\ninst->alg.setkey = crypto_rfc4309_setkey;\r\ninst->alg.setauthsize = crypto_rfc4309_setauthsize;\r\ninst->alg.encrypt = crypto_rfc4309_encrypt;\r\ninst->alg.decrypt = crypto_rfc4309_decrypt;\r\ninst->free = crypto_rfc4309_free;\r\nerr = aead_register_instance(tmpl, inst);\r\nif (err)\r\ngoto out_drop_alg;\r\nout:\r\nreturn err;\r\nout_drop_alg:\r\ncrypto_drop_aead(spawn);\r\nout_free_inst:\r\nkfree(inst);\r\ngoto out;\r\n}\r\nstatic int crypto_cbcmac_digest_setkey(struct crypto_shash *parent,\r\nconst u8 *inkey, unsigned int keylen)\r\n{\r\nstruct cbcmac_tfm_ctx *ctx = crypto_shash_ctx(parent);\r\nreturn crypto_cipher_setkey(ctx->child, inkey, keylen);\r\n}\r\nstatic int crypto_cbcmac_digest_init(struct shash_desc *pdesc)\r\n{\r\nstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nint bs = crypto_shash_digestsize(pdesc->tfm);\r\nu8 *dg = (u8 *)ctx + crypto_shash_descsize(pdesc->tfm) - bs;\r\nctx->len = 0;\r\nmemset(dg, 0, bs);\r\nreturn 0;\r\n}\r\nstatic int crypto_cbcmac_digest_update(struct shash_desc *pdesc, const u8 *p,\r\nunsigned int len)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\r\nstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nstruct crypto_cipher *tfm = tctx->child;\r\nint bs = crypto_shash_digestsize(parent);\r\nu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\r\nwhile (len > 0) {\r\nunsigned int l = min(len, bs - ctx->len);\r\ncrypto_xor(dg + ctx->len, p, l);\r\nctx->len +=l;\r\nlen -= l;\r\np += l;\r\nif (ctx->len == bs) {\r\ncrypto_cipher_encrypt_one(tfm, dg, dg);\r\nctx->len = 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int crypto_cbcmac_digest_final(struct shash_desc *pdesc, u8 *out)\r\n{\r\nstruct crypto_shash *parent = pdesc->tfm;\r\nstruct cbcmac_tfm_ctx *tctx = crypto_shash_ctx(parent);\r\nstruct cbcmac_desc_ctx *ctx = shash_desc_ctx(pdesc);\r\nstruct crypto_cipher *tfm = tctx->child;\r\nint bs = crypto_shash_digestsize(parent);\r\nu8 *dg = (u8 *)ctx + crypto_shash_descsize(parent) - bs;\r\nif (ctx->len)\r\ncrypto_cipher_encrypt_one(tfm, dg, dg);\r\nmemcpy(out, dg, bs);\r\nreturn 0;\r\n}\r\nstatic int cbcmac_init_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct crypto_cipher *cipher;\r\nstruct crypto_instance *inst = (void *)tfm->__crt_alg;\r\nstruct crypto_spawn *spawn = crypto_instance_ctx(inst);\r\nstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void cbcmac_exit_tfm(struct crypto_tfm *tfm)\r\n{\r\nstruct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic int cbcmac_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct shash_instance *inst;\r\nstruct crypto_alg *alg;\r\nint err;\r\nerr = crypto_check_attr_type(tb, CRYPTO_ALG_TYPE_SHASH);\r\nif (err)\r\nreturn err;\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER,\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (IS_ERR(alg))\r\nreturn PTR_ERR(alg);\r\ninst = shash_alloc_instance("cbcmac", alg);\r\nerr = PTR_ERR(inst);\r\nif (IS_ERR(inst))\r\ngoto out_put_alg;\r\nerr = crypto_init_spawn(shash_instance_ctx(inst), alg,\r\nshash_crypto_instance(inst),\r\nCRYPTO_ALG_TYPE_MASK);\r\nif (err)\r\ngoto out_free_inst;\r\ninst->alg.base.cra_priority = alg->cra_priority;\r\ninst->alg.base.cra_blocksize = 1;\r\ninst->alg.digestsize = alg->cra_blocksize;\r\ninst->alg.descsize = ALIGN(sizeof(struct cbcmac_desc_ctx),\r\nalg->cra_alignmask + 1) +\r\nalg->cra_blocksize;\r\ninst->alg.base.cra_ctxsize = sizeof(struct cbcmac_tfm_ctx);\r\ninst->alg.base.cra_init = cbcmac_init_tfm;\r\ninst->alg.base.cra_exit = cbcmac_exit_tfm;\r\ninst->alg.init = crypto_cbcmac_digest_init;\r\ninst->alg.update = crypto_cbcmac_digest_update;\r\ninst->alg.final = crypto_cbcmac_digest_final;\r\ninst->alg.setkey = crypto_cbcmac_digest_setkey;\r\nerr = shash_register_instance(tmpl, inst);\r\nout_free_inst:\r\nif (err)\r\nshash_free_instance(shash_crypto_instance(inst));\r\nout_put_alg:\r\ncrypto_mod_put(alg);\r\nreturn err;\r\n}\r\nstatic int __init crypto_ccm_module_init(void)\r\n{\r\nint err;\r\nerr = crypto_register_template(&crypto_cbcmac_tmpl);\r\nif (err)\r\ngoto out;\r\nerr = crypto_register_template(&crypto_ccm_base_tmpl);\r\nif (err)\r\ngoto out_undo_cbcmac;\r\nerr = crypto_register_template(&crypto_ccm_tmpl);\r\nif (err)\r\ngoto out_undo_base;\r\nerr = crypto_register_template(&crypto_rfc4309_tmpl);\r\nif (err)\r\ngoto out_undo_ccm;\r\nout:\r\nreturn err;\r\nout_undo_ccm:\r\ncrypto_unregister_template(&crypto_ccm_tmpl);\r\nout_undo_base:\r\ncrypto_unregister_template(&crypto_ccm_base_tmpl);\r\nout_undo_cbcmac:\r\ncrypto_register_template(&crypto_cbcmac_tmpl);\r\ngoto out;\r\n}\r\nstatic void __exit crypto_ccm_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_rfc4309_tmpl);\r\ncrypto_unregister_template(&crypto_ccm_tmpl);\r\ncrypto_unregister_template(&crypto_ccm_base_tmpl);\r\ncrypto_unregister_template(&crypto_cbcmac_tmpl);\r\n}
