void musb_host_finish_resume(struct work_struct *work)\r\n{\r\nstruct musb *musb;\r\nunsigned long flags;\r\nu8 power;\r\nmusb = container_of(work, struct musb, finish_resume_work.work);\r\nspin_lock_irqsave(&musb->lock, flags);\r\npower = musb_readb(musb->mregs, MUSB_POWER);\r\npower &= ~MUSB_POWER_RESUME;\r\nmusb_dbg(musb, "root port resume stopped, power %02x", power);\r\nmusb_writeb(musb->mregs, MUSB_POWER, power);\r\nmusb->is_active = 1;\r\nmusb->port1_status &= ~(USB_PORT_STAT_SUSPEND | MUSB_PORT_STAT_RESUME);\r\nmusb->port1_status |= USB_PORT_STAT_C_SUSPEND << 16;\r\nusb_hcd_poll_rh_status(musb->hcd);\r\nmusb->xceiv->otg->state = OTG_STATE_A_HOST;\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nvoid musb_port_suspend(struct musb *musb, bool do_suspend)\r\n{\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nu8 power;\r\nvoid __iomem *mbase = musb->mregs;\r\nif (!is_host_active(musb))\r\nreturn;\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (do_suspend) {\r\nint retries = 10000;\r\npower &= ~MUSB_POWER_RESUME;\r\npower |= MUSB_POWER_SUSPENDM;\r\nmusb_writeb(mbase, MUSB_POWER, power);\r\npower = musb_readb(mbase, MUSB_POWER);\r\nwhile (power & MUSB_POWER_SUSPENDM) {\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (retries-- < 1)\r\nbreak;\r\n}\r\nmusb_dbg(musb, "Root port suspended, power %02x", power);\r\nmusb->port1_status |= USB_PORT_STAT_SUSPEND;\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_HOST:\r\nmusb->xceiv->otg->state = OTG_STATE_A_SUSPEND;\r\nmusb->is_active = otg->host->b_hnp_enable;\r\nif (musb->is_active)\r\nmod_timer(&musb->otg_timer, jiffies\r\n+ msecs_to_jiffies(\r\nOTG_TIME_A_AIDL_BDIS));\r\nmusb_platform_try_idle(musb, 0);\r\nbreak;\r\ncase OTG_STATE_B_HOST:\r\nmusb->xceiv->otg->state = OTG_STATE_B_WAIT_ACON;\r\nmusb->is_active = otg->host->b_hnp_enable;\r\nmusb_platform_try_idle(musb, 0);\r\nbreak;\r\ndefault:\r\nmusb_dbg(musb, "bogus rh suspend? %s",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\n}\r\n} else if (power & MUSB_POWER_SUSPENDM) {\r\npower &= ~MUSB_POWER_SUSPENDM;\r\npower |= MUSB_POWER_RESUME;\r\nmusb_writeb(mbase, MUSB_POWER, power);\r\nmusb_dbg(musb, "Root port resuming, power %02x", power);\r\nmusb->port1_status |= MUSB_PORT_STAT_RESUME;\r\nschedule_delayed_work(&musb->finish_resume_work,\r\nmsecs_to_jiffies(USB_RESUME_TIMEOUT));\r\n}\r\n}\r\nvoid musb_port_reset(struct musb *musb, bool do_reset)\r\n{\r\nu8 power;\r\nvoid __iomem *mbase = musb->mregs;\r\nif (musb->xceiv->otg->state == OTG_STATE_B_IDLE) {\r\nmusb_dbg(musb, "HNP: Returning from HNP; no hub reset from b_idle");\r\nmusb->port1_status &= ~USB_PORT_STAT_RESET;\r\nreturn;\r\n}\r\nif (!is_host_active(musb))\r\nreturn;\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (do_reset) {\r\nif (power & MUSB_POWER_RESUME) {\r\nlong remain = (unsigned long) musb->rh_timer - jiffies;\r\nif (musb->rh_timer > 0 && remain > 0) {\r\nschedule_delayed_work(\r\n&musb->deassert_reset_work, remain);\r\nreturn;\r\n}\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower & ~MUSB_POWER_RESUME);\r\nschedule_delayed_work(&musb->deassert_reset_work,\r\nmsecs_to_jiffies(1));\r\nreturn;\r\n}\r\npower &= 0xf0;\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower | MUSB_POWER_RESET);\r\nmusb->port1_status |= USB_PORT_STAT_RESET;\r\nmusb->port1_status &= ~USB_PORT_STAT_ENABLE;\r\nschedule_delayed_work(&musb->deassert_reset_work,\r\nmsecs_to_jiffies(50));\r\n} else {\r\nmusb_dbg(musb, "root port reset stopped");\r\nmusb_platform_pre_root_reset_end(musb);\r\nmusb_writeb(mbase, MUSB_POWER,\r\npower & ~MUSB_POWER_RESET);\r\nmusb_platform_post_root_reset_end(musb);\r\npower = musb_readb(mbase, MUSB_POWER);\r\nif (power & MUSB_POWER_HSMODE) {\r\nmusb_dbg(musb, "high-speed device connected");\r\nmusb->port1_status |= USB_PORT_STAT_HIGH_SPEED;\r\n}\r\nmusb->port1_status &= ~USB_PORT_STAT_RESET;\r\nmusb->port1_status |= USB_PORT_STAT_ENABLE\r\n| (USB_PORT_STAT_C_RESET << 16)\r\n| (USB_PORT_STAT_C_ENABLE << 16);\r\nusb_hcd_poll_rh_status(musb->hcd);\r\nmusb->vbuserr_retry = VBUSERR_RETRY_COUNT;\r\n}\r\n}\r\nvoid musb_root_disconnect(struct musb *musb)\r\n{\r\nstruct usb_otg *otg = musb->xceiv->otg;\r\nmusb->port1_status = USB_PORT_STAT_POWER\r\n| (USB_PORT_STAT_C_CONNECTION << 16);\r\nusb_hcd_poll_rh_status(musb->hcd);\r\nmusb->is_active = 0;\r\nswitch (musb->xceiv->otg->state) {\r\ncase OTG_STATE_A_SUSPEND:\r\nif (otg->host->b_hnp_enable) {\r\nmusb->xceiv->otg->state = OTG_STATE_A_PERIPHERAL;\r\nmusb->g.is_a_peripheral = 1;\r\nbreak;\r\n}\r\ncase OTG_STATE_A_HOST:\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_BCON;\r\nmusb->is_active = 0;\r\nbreak;\r\ncase OTG_STATE_A_WAIT_VFALL:\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nbreak;\r\ndefault:\r\nmusb_dbg(musb, "host disconnect (%s)",\r\nusb_otg_state_string(musb->xceiv->otg->state));\r\n}\r\n}\r\nint musb_hub_status_data(struct usb_hcd *hcd, char *buf)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nint retval = 0;\r\nif (musb->port1_status & 0xffff0000) {\r\n*buf = 0x02;\r\nretval = 1;\r\n}\r\nreturn retval;\r\n}\r\nstatic int musb_has_gadget(struct musb *musb)\r\n{\r\n#ifdef CONFIG_USB_MUSB_HOST\r\nreturn 1;\r\n#else\r\nreturn musb->port_mode == MUSB_PORT_MODE_HOST;\r\n#endif\r\n}\r\nint musb_hub_control(\r\nstruct usb_hcd *hcd,\r\nu16 typeReq,\r\nu16 wValue,\r\nu16 wIndex,\r\nchar *buf,\r\nu16 wLength)\r\n{\r\nstruct musb *musb = hcd_to_musb(hcd);\r\nu32 temp;\r\nint retval = 0;\r\nunsigned long flags;\r\nbool start_musb = false;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nif (unlikely(!HCD_HW_ACCESSIBLE(hcd))) {\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn -ESHUTDOWN;\r\n}\r\nswitch (typeReq) {\r\ncase ClearHubFeature:\r\ncase SetHubFeature:\r\nswitch (wValue) {\r\ncase C_HUB_OVER_CURRENT:\r\ncase C_HUB_LOCAL_POWER:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nbreak;\r\ncase ClearPortFeature:\r\nif ((wIndex & 0xff) != 1)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_ENABLE:\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nmusb_port_suspend(musb, false);\r\nbreak;\r\ncase USB_PORT_FEAT_POWER:\r\nif (!hcd->self.is_b_host)\r\nmusb_platform_set_vbus(musb, 0);\r\nbreak;\r\ncase USB_PORT_FEAT_C_CONNECTION:\r\ncase USB_PORT_FEAT_C_ENABLE:\r\ncase USB_PORT_FEAT_C_OVER_CURRENT:\r\ncase USB_PORT_FEAT_C_RESET:\r\ncase USB_PORT_FEAT_C_SUSPEND:\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nmusb_dbg(musb, "clear feature %d", wValue);\r\nmusb->port1_status &= ~(1 << wValue);\r\nbreak;\r\ncase GetHubDescriptor:\r\n{\r\nstruct usb_hub_descriptor *desc = (void *)buf;\r\ndesc->bDescLength = 9;\r\ndesc->bDescriptorType = USB_DT_HUB;\r\ndesc->bNbrPorts = 1;\r\ndesc->wHubCharacteristics = cpu_to_le16(\r\nHUB_CHAR_INDV_PORT_LPSM\r\n| HUB_CHAR_NO_OCPM\r\n);\r\ndesc->bPwrOn2PwrGood = 5;\r\ndesc->bHubContrCurrent = 0;\r\ndesc->u.hs.DeviceRemovable[0] = 0x02;\r\ndesc->u.hs.DeviceRemovable[1] = 0xff;\r\n}\r\nbreak;\r\ncase GetHubStatus:\r\ntemp = 0;\r\n*(__le32 *) buf = cpu_to_le32(temp);\r\nbreak;\r\ncase GetPortStatus:\r\nif (wIndex != 1)\r\ngoto error;\r\nput_unaligned(cpu_to_le32(musb->port1_status\r\n& ~MUSB_PORT_STAT_RESUME),\r\n(__le32 *) buf);\r\nmusb_dbg(musb, "port status %08x", musb->port1_status);\r\nbreak;\r\ncase SetPortFeature:\r\nif ((wIndex & 0xff) != 1)\r\ngoto error;\r\nswitch (wValue) {\r\ncase USB_PORT_FEAT_POWER:\r\nif (!hcd->self.is_b_host && musb_has_gadget(musb))\r\nstart_musb = true;\r\nbreak;\r\ncase USB_PORT_FEAT_RESET:\r\nmusb_port_reset(musb, true);\r\nbreak;\r\ncase USB_PORT_FEAT_SUSPEND:\r\nmusb_port_suspend(musb, true);\r\nbreak;\r\ncase USB_PORT_FEAT_TEST:\r\nif (unlikely(is_host_active(musb)))\r\ngoto error;\r\nwIndex >>= 8;\r\nswitch (wIndex) {\r\ncase 1:\r\npr_debug("TEST_J\n");\r\ntemp = MUSB_TEST_J;\r\nbreak;\r\ncase 2:\r\npr_debug("TEST_K\n");\r\ntemp = MUSB_TEST_K;\r\nbreak;\r\ncase 3:\r\npr_debug("TEST_SE0_NAK\n");\r\ntemp = MUSB_TEST_SE0_NAK;\r\nbreak;\r\ncase 4:\r\npr_debug("TEST_PACKET\n");\r\ntemp = MUSB_TEST_PACKET;\r\nmusb_load_testpacket(musb);\r\nbreak;\r\ncase 5:\r\npr_debug("TEST_FORCE_ENABLE\n");\r\ntemp = MUSB_TEST_FORCE_HOST\r\n| MUSB_TEST_FORCE_HS;\r\nmusb_writeb(musb->mregs, MUSB_DEVCTL,\r\nMUSB_DEVCTL_SESSION);\r\nbreak;\r\ncase 6:\r\npr_debug("TEST_FIFO_ACCESS\n");\r\ntemp = MUSB_TEST_FIFO_ACCESS;\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nmusb_writeb(musb->mregs, MUSB_TESTMODE, temp);\r\nbreak;\r\ndefault:\r\ngoto error;\r\n}\r\nmusb_dbg(musb, "set feature %d", wValue);\r\nmusb->port1_status |= 1 << wValue;\r\nbreak;\r\ndefault:\r\nerror:\r\nretval = -EPIPE;\r\n}\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nif (start_musb)\r\nmusb_start(musb);\r\nreturn retval;\r\n}
