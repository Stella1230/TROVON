char *usbhs_pipe_name(struct usbhs_pipe *pipe)\r\n{\r\nreturn usbhsp_pipe_name[usbhs_pipe_type(pipe)];\r\n}\r\nstatic struct renesas_usbhs_driver_pipe_config\r\n*usbhsp_get_pipe_config(struct usbhs_priv *priv, int pipe_num)\r\n{\r\nstruct renesas_usbhs_driver_pipe_config *pipe_configs =\r\nusbhs_get_dparam(priv, pipe_configs);\r\nreturn &pipe_configs[pipe_num];\r\n}\r\nstatic void usbhsp_pipectrl_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nint offset = usbhsp_addr_offset(pipe);\r\nif (usbhs_pipe_is_dcp(pipe))\r\nusbhs_bset(priv, DCPCTR, mask, val);\r\nelse\r\nusbhs_bset(priv, PIPEnCTR + offset, mask, val);\r\n}\r\nstatic u16 usbhsp_pipectrl_get(struct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nint offset = usbhsp_addr_offset(pipe);\r\nif (usbhs_pipe_is_dcp(pipe))\r\nreturn usbhs_read(priv, DCPCTR);\r\nelse\r\nreturn usbhs_read(priv, PIPEnCTR + offset);\r\n}\r\nstatic void __usbhsp_pipe_xxx_set(struct usbhs_pipe *pipe,\r\nu16 dcp_reg, u16 pipe_reg,\r\nu16 mask, u16 val)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nif (usbhs_pipe_is_dcp(pipe))\r\nusbhs_bset(priv, dcp_reg, mask, val);\r\nelse\r\nusbhs_bset(priv, pipe_reg, mask, val);\r\n}\r\nstatic u16 __usbhsp_pipe_xxx_get(struct usbhs_pipe *pipe,\r\nu16 dcp_reg, u16 pipe_reg)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nif (usbhs_pipe_is_dcp(pipe))\r\nreturn usbhs_read(priv, dcp_reg);\r\nelse\r\nreturn usbhs_read(priv, pipe_reg);\r\n}\r\nstatic void usbhsp_pipe_cfg_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\r\n{\r\n__usbhsp_pipe_xxx_set(pipe, DCPCFG, PIPECFG, mask, val);\r\n}\r\nstatic u16 usbhsp_pipe_cfg_get(struct usbhs_pipe *pipe)\r\n{\r\nreturn __usbhsp_pipe_xxx_get(pipe, DCPCFG, PIPECFG);\r\n}\r\nstatic void usbhsp_pipe_trn_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint num = usbhs_pipe_number(pipe);\r\nu16 reg;\r\n#define CASE_PIPExTRN(a) \\r\ncase 0x ## a: \\r\nreg = PIPE ## a ## TRN; \\r\nbreak;\r\nswitch (num) {\r\nCASE_PIPExTRN(1);\r\nCASE_PIPExTRN(2);\r\nCASE_PIPExTRN(3);\r\nCASE_PIPExTRN(4);\r\nCASE_PIPExTRN(5);\r\nCASE_PIPExTRN(B);\r\nCASE_PIPExTRN(C);\r\nCASE_PIPExTRN(D);\r\nCASE_PIPExTRN(E);\r\nCASE_PIPExTRN(F);\r\nCASE_PIPExTRN(9);\r\nCASE_PIPExTRN(A);\r\ndefault:\r\ndev_err(dev, "unknown pipe (%d)\n", num);\r\nreturn;\r\n}\r\n__usbhsp_pipe_xxx_set(pipe, 0, reg, mask, val);\r\n}\r\nstatic void usbhsp_pipe_tre_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint num = usbhs_pipe_number(pipe);\r\nu16 reg;\r\n#define CASE_PIPExTRE(a) \\r\ncase 0x ## a: \\r\nreg = PIPE ## a ## TRE; \\r\nbreak;\r\nswitch (num) {\r\nCASE_PIPExTRE(1);\r\nCASE_PIPExTRE(2);\r\nCASE_PIPExTRE(3);\r\nCASE_PIPExTRE(4);\r\nCASE_PIPExTRE(5);\r\nCASE_PIPExTRE(B);\r\nCASE_PIPExTRE(C);\r\nCASE_PIPExTRE(D);\r\nCASE_PIPExTRE(E);\r\nCASE_PIPExTRE(F);\r\nCASE_PIPExTRE(9);\r\nCASE_PIPExTRE(A);\r\ndefault:\r\ndev_err(dev, "unknown pipe (%d)\n", num);\r\nreturn;\r\n}\r\n__usbhsp_pipe_xxx_set(pipe, 0, reg, mask, val);\r\n}\r\nstatic void usbhsp_pipe_buf_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\r\n{\r\nif (usbhs_pipe_is_dcp(pipe))\r\nreturn;\r\n__usbhsp_pipe_xxx_set(pipe, 0, PIPEBUF, mask, val);\r\n}\r\nstatic void usbhsp_pipe_maxp_set(struct usbhs_pipe *pipe, u16 mask, u16 val)\r\n{\r\n__usbhsp_pipe_xxx_set(pipe, DCPMAXP, PIPEMAXP, mask, val);\r\n}\r\nstatic void usbhsp_pipe_select(struct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nusbhs_write(priv, PIPESEL, 0xF & usbhs_pipe_number(pipe));\r\n}\r\nstatic int usbhsp_pipe_barrier(struct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nint timeout = 1024;\r\nu16 mask = usbhs_mod_is_host(priv) ? (CSSTS | PID_MASK) : PID_MASK;\r\nusbhs_write(priv, CFIFOSEL, 0);\r\nusbhs_pipe_disable(pipe);\r\ndo {\r\nif (!(usbhsp_pipectrl_get(pipe) & mask))\r\nreturn 0;\r\nudelay(10);\r\n} while (timeout--);\r\nreturn -EBUSY;\r\n}\r\nint usbhs_pipe_is_accessible(struct usbhs_pipe *pipe)\r\n{\r\nu16 val;\r\nval = usbhsp_pipectrl_get(pipe);\r\nif (val & BSTS)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic void __usbhsp_pid_try_nak_if_stall(struct usbhs_pipe *pipe)\r\n{\r\nu16 pid = usbhsp_pipectrl_get(pipe);\r\npid &= PID_MASK;\r\nswitch (pid) {\r\ncase PID_STALL11:\r\nusbhsp_pipectrl_set(pipe, PID_MASK, PID_STALL10);\r\ncase PID_STALL10:\r\nusbhsp_pipectrl_set(pipe, PID_MASK, PID_NAK);\r\n}\r\n}\r\nvoid usbhs_pipe_disable(struct usbhs_pipe *pipe)\r\n{\r\nint timeout = 1024;\r\nu16 val;\r\n__usbhsp_pid_try_nak_if_stall(pipe);\r\nusbhsp_pipectrl_set(pipe, PID_MASK, PID_NAK);\r\ndo {\r\nval = usbhsp_pipectrl_get(pipe);\r\nval &= PBUSY;\r\nif (!val)\r\nbreak;\r\nudelay(10);\r\n} while (timeout--);\r\n}\r\nvoid usbhs_pipe_enable(struct usbhs_pipe *pipe)\r\n{\r\n__usbhsp_pid_try_nak_if_stall(pipe);\r\nusbhsp_pipectrl_set(pipe, PID_MASK, PID_BUF);\r\n}\r\nvoid usbhs_pipe_stall(struct usbhs_pipe *pipe)\r\n{\r\nu16 pid = usbhsp_pipectrl_get(pipe);\r\npid &= PID_MASK;\r\nswitch (pid) {\r\ncase PID_NAK:\r\nusbhsp_pipectrl_set(pipe, PID_MASK, PID_STALL10);\r\nbreak;\r\ncase PID_BUF:\r\nusbhsp_pipectrl_set(pipe, PID_MASK, PID_STALL11);\r\nbreak;\r\n}\r\n}\r\nint usbhs_pipe_is_stall(struct usbhs_pipe *pipe)\r\n{\r\nu16 pid = usbhsp_pipectrl_get(pipe) & PID_MASK;\r\nreturn (int)(pid == PID_STALL10 || pid == PID_STALL11);\r\n}\r\nvoid usbhs_pipe_set_trans_count_if_bulk(struct usbhs_pipe *pipe, int len)\r\n{\r\nif (!usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK))\r\nreturn;\r\nusbhsp_pipe_tre_set(pipe, TRCLR | TRENB, TRCLR);\r\nif (usbhs_pipe_is_dir_in(pipe)) {\r\nint maxp = usbhs_pipe_get_maxpacket(pipe);\r\nusbhsp_pipe_trn_set(pipe, 0xffff, DIV_ROUND_UP(len, maxp));\r\nusbhsp_pipe_tre_set(pipe, TRENB, TRENB);\r\n}\r\n}\r\nstatic int usbhsp_setup_pipecfg(struct usbhs_pipe *pipe, int is_host,\r\nint dir_in, u16 *pipecfg)\r\n{\r\nu16 type = 0;\r\nu16 bfre = 0;\r\nu16 dblb = 0;\r\nu16 cntmd = 0;\r\nu16 dir = 0;\r\nu16 epnum = 0;\r\nu16 shtnak = 0;\r\nu16 type_array[] = {\r\n[USB_ENDPOINT_XFER_BULK] = TYPE_BULK,\r\n[USB_ENDPOINT_XFER_INT] = TYPE_INT,\r\n[USB_ENDPOINT_XFER_ISOC] = TYPE_ISO,\r\n};\r\nif (usbhs_pipe_is_dcp(pipe))\r\nreturn -EINVAL;\r\ntype = type_array[usbhs_pipe_type(pipe)];\r\nif (usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC) ||\r\nusbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK))\r\nbfre = 0;\r\nif (usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK))\r\ncntmd = 0;\r\nif (dir_in)\r\nusbhsp_flags_set(pipe, IS_DIR_HOST);\r\nif (!!is_host ^ !!dir_in)\r\ndir |= DIR_OUT;\r\nif (!dir)\r\nusbhsp_flags_set(pipe, IS_DIR_IN);\r\nif (usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_BULK) &&\r\n!dir)\r\nshtnak = SHTNAK;\r\nepnum = 0;\r\n*pipecfg = type |\r\nbfre |\r\ndblb |\r\ncntmd |\r\ndir |\r\nshtnak |\r\nepnum;\r\nreturn 0;\r\n}\r\nstatic u16 usbhsp_setup_pipebuff(struct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nint pipe_num = usbhs_pipe_number(pipe);\r\nu16 buff_size;\r\nu16 bufnmb;\r\nu16 bufnmb_cnt;\r\nstruct renesas_usbhs_driver_pipe_config *pipe_config =\r\nusbhsp_get_pipe_config(priv, pipe_num);\r\nbuff_size = pipe_config->bufsize;\r\nbufnmb = pipe_config->bufnum;\r\nbufnmb_cnt = (buff_size / 64) - 1;\r\ndev_dbg(dev, "pipe : %d : buff_size 0x%x: bufnmb 0x%x\n",\r\npipe_num, buff_size, bufnmb);\r\nreturn (0x1f & bufnmb_cnt) << 10 |\r\n(0xff & bufnmb) << 0;\r\n}\r\nvoid usbhs_pipe_config_update(struct usbhs_pipe *pipe, u16 devsel,\r\nu16 epnum, u16 maxp)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nint pipe_num = usbhs_pipe_number(pipe);\r\nstruct renesas_usbhs_driver_pipe_config *pipe_config =\r\nusbhsp_get_pipe_config(priv, pipe_num);\r\nu16 dblb = pipe_config->double_buf ? DBLB : 0;\r\nif (devsel > 0xA) {\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\ndev_err(dev, "devsel error %d\n", devsel);\r\ndevsel = 0;\r\n}\r\nusbhsp_pipe_barrier(pipe);\r\npipe->maxp = maxp;\r\nusbhsp_pipe_select(pipe);\r\nusbhsp_pipe_maxp_set(pipe, 0xFFFF,\r\n(devsel << 12) |\r\nmaxp);\r\nif (!usbhs_pipe_is_dcp(pipe))\r\nusbhsp_pipe_cfg_set(pipe, 0x000F | DBLB, epnum | dblb);\r\n}\r\nint usbhs_pipe_get_maxpacket(struct usbhs_pipe *pipe)\r\n{\r\nreturn pipe->maxp;\r\n}\r\nint usbhs_pipe_is_dir_in(struct usbhs_pipe *pipe)\r\n{\r\nreturn usbhsp_flags_has(pipe, IS_DIR_IN);\r\n}\r\nint usbhs_pipe_is_dir_host(struct usbhs_pipe *pipe)\r\n{\r\nreturn usbhsp_flags_has(pipe, IS_DIR_HOST);\r\n}\r\nint usbhs_pipe_is_running(struct usbhs_pipe *pipe)\r\n{\r\nreturn usbhsp_flags_has(pipe, IS_RUNNING);\r\n}\r\nvoid usbhs_pipe_running(struct usbhs_pipe *pipe, int running)\r\n{\r\nif (running)\r\nusbhsp_flags_set(pipe, IS_RUNNING);\r\nelse\r\nusbhsp_flags_clr(pipe, IS_RUNNING);\r\n}\r\nvoid usbhs_pipe_data_sequence(struct usbhs_pipe *pipe, int sequence)\r\n{\r\nu16 mask = (SQCLR | SQSET);\r\nu16 val;\r\nswitch (sequence) {\r\ncase 0:\r\nval = SQCLR;\r\nbreak;\r\ncase 1:\r\nval = SQSET;\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nusbhsp_pipectrl_set(pipe, mask, val);\r\n}\r\nstatic int usbhs_pipe_get_data_sequence(struct usbhs_pipe *pipe)\r\n{\r\nreturn !!(usbhsp_pipectrl_get(pipe) & SQMON);\r\n}\r\nvoid usbhs_pipe_clear(struct usbhs_pipe *pipe)\r\n{\r\nif (usbhs_pipe_is_dcp(pipe)) {\r\nusbhs_fifo_clear_dcp(pipe);\r\n} else {\r\nusbhsp_pipectrl_set(pipe, ACLRM, ACLRM);\r\nusbhsp_pipectrl_set(pipe, ACLRM, 0);\r\n}\r\n}\r\nvoid usbhs_pipe_config_change_bfre(struct usbhs_pipe *pipe, int enable)\r\n{\r\nint sequence;\r\nif (usbhs_pipe_is_dcp(pipe))\r\nreturn;\r\nusbhsp_pipe_select(pipe);\r\nif (!(enable ^ !!(usbhsp_pipe_cfg_get(pipe) & BFRE)))\r\nreturn;\r\nsequence = usbhs_pipe_get_data_sequence(pipe);\r\nusbhsp_pipe_cfg_set(pipe, BFRE, enable ? BFRE : 0);\r\nusbhs_pipe_clear(pipe);\r\nusbhs_pipe_data_sequence(pipe, sequence);\r\n}\r\nstatic struct usbhs_pipe *usbhsp_get_pipe(struct usbhs_priv *priv, u32 type)\r\n{\r\nstruct usbhs_pipe *pos, *pipe;\r\nint i;\r\npipe = NULL;\r\nusbhs_for_each_pipe_with_dcp(pos, priv, i) {\r\nif (!usbhs_pipe_type_is(pos, type))\r\ncontinue;\r\nif (usbhsp_flags_has(pos, IS_USED))\r\ncontinue;\r\npipe = pos;\r\nbreak;\r\n}\r\nif (!pipe)\r\nreturn NULL;\r\nusbhsp_flags_init(pipe);\r\nusbhsp_flags_set(pipe, IS_USED);\r\nreturn pipe;\r\n}\r\nstatic void usbhsp_put_pipe(struct usbhs_pipe *pipe)\r\n{\r\nusbhsp_flags_init(pipe);\r\n}\r\nvoid usbhs_pipe_init(struct usbhs_priv *priv,\r\nint (*dma_map_ctrl)(struct device *dma_dev,\r\nstruct usbhs_pkt *pkt, int map))\r\n{\r\nstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\r\nstruct usbhs_pipe *pipe;\r\nint i;\r\nusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\r\nusbhsp_flags_init(pipe);\r\npipe->fifo = NULL;\r\npipe->mod_private = NULL;\r\nINIT_LIST_HEAD(&pipe->list);\r\nusbhs_pipe_clear(pipe);\r\n}\r\ninfo->dma_map_ctrl = dma_map_ctrl;\r\n}\r\nstruct usbhs_pipe *usbhs_pipe_malloc(struct usbhs_priv *priv,\r\nint endpoint_type,\r\nint dir_in)\r\n{\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct usbhs_pipe *pipe;\r\nint is_host = usbhs_mod_is_host(priv);\r\nint ret;\r\nu16 pipecfg, pipebuf;\r\npipe = usbhsp_get_pipe(priv, endpoint_type);\r\nif (!pipe) {\r\ndev_err(dev, "can't get pipe (%s)\n",\r\nusbhsp_pipe_name[endpoint_type]);\r\nreturn NULL;\r\n}\r\nINIT_LIST_HEAD(&pipe->list);\r\nusbhs_pipe_disable(pipe);\r\nret = usbhsp_pipe_barrier(pipe);\r\nif (ret < 0) {\r\ndev_err(dev, "pipe setup failed %d\n", usbhs_pipe_number(pipe));\r\nreturn NULL;\r\n}\r\nif (usbhsp_setup_pipecfg(pipe, is_host, dir_in, &pipecfg)) {\r\ndev_err(dev, "can't setup pipe\n");\r\nreturn NULL;\r\n}\r\npipebuf = usbhsp_setup_pipebuff(pipe);\r\nusbhsp_pipe_select(pipe);\r\nusbhsp_pipe_cfg_set(pipe, 0xFFFF, pipecfg);\r\nusbhsp_pipe_buf_set(pipe, 0xFFFF, pipebuf);\r\nusbhs_pipe_clear(pipe);\r\nusbhs_pipe_sequence_data0(pipe);\r\ndev_dbg(dev, "enable pipe %d : %s (%s)\n",\r\nusbhs_pipe_number(pipe),\r\nusbhs_pipe_name(pipe),\r\nusbhs_pipe_is_dir_in(pipe) ? "in" : "out");\r\nreturn pipe;\r\n}\r\nvoid usbhs_pipe_free(struct usbhs_pipe *pipe)\r\n{\r\nusbhsp_put_pipe(pipe);\r\n}\r\nvoid usbhs_pipe_select_fifo(struct usbhs_pipe *pipe, struct usbhs_fifo *fifo)\r\n{\r\nif (pipe->fifo)\r\npipe->fifo->pipe = NULL;\r\npipe->fifo = fifo;\r\nif (fifo)\r\nfifo->pipe = pipe;\r\n}\r\nstruct usbhs_pipe *usbhs_dcp_malloc(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_pipe *pipe;\r\npipe = usbhsp_get_pipe(priv, USB_ENDPOINT_XFER_CONTROL);\r\nif (!pipe)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&pipe->list);\r\nreturn pipe;\r\n}\r\nvoid usbhs_dcp_control_transfer_done(struct usbhs_pipe *pipe)\r\n{\r\nstruct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);\r\nWARN_ON(!usbhs_pipe_is_dcp(pipe));\r\nusbhs_pipe_enable(pipe);\r\nif (!usbhs_mod_is_host(priv))\r\nusbhsp_pipectrl_set(pipe, CCPL, CCPL);\r\n}\r\nvoid usbhs_dcp_dir_for_host(struct usbhs_pipe *pipe, int dir_out)\r\n{\r\nusbhsp_pipe_cfg_set(pipe, DIR_OUT,\r\ndir_out ? DIR_OUT : 0);\r\n}\r\nint usbhs_pipe_probe(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\r\nstruct usbhs_pipe *pipe;\r\nstruct device *dev = usbhs_priv_to_dev(priv);\r\nstruct renesas_usbhs_driver_pipe_config *pipe_configs =\r\nusbhs_get_dparam(priv, pipe_configs);\r\nint pipe_size = usbhs_get_dparam(priv, pipe_size);\r\nint i;\r\nif (pipe_configs[0].type != USB_ENDPOINT_XFER_CONTROL) {\r\ndev_err(dev, "1st PIPE is not DCP\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->pipe = kzalloc(sizeof(struct usbhs_pipe) * pipe_size, GFP_KERNEL);\r\nif (!info->pipe)\r\nreturn -ENOMEM;\r\ninfo->size = pipe_size;\r\nusbhs_for_each_pipe_with_dcp(pipe, priv, i) {\r\npipe->priv = priv;\r\nusbhs_pipe_type(pipe) =\r\npipe_configs[i].type & USB_ENDPOINT_XFERTYPE_MASK;\r\ndev_dbg(dev, "pipe %x\t: %s\n",\r\ni, usbhsp_pipe_name[pipe_configs[i].type]);\r\n}\r\nreturn 0;\r\n}\r\nvoid usbhs_pipe_remove(struct usbhs_priv *priv)\r\n{\r\nstruct usbhs_pipe_info *info = usbhs_priv_to_pipeinfo(priv);\r\nkfree(info->pipe);\r\n}
