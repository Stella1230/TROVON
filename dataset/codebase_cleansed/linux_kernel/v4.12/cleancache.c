static void cleancache_register_ops_sb(struct super_block *sb, void *unused)\r\n{\r\nswitch (sb->cleancache_poolid) {\r\ncase CLEANCACHE_NO_BACKEND:\r\n__cleancache_init_fs(sb);\r\nbreak;\r\ncase CLEANCACHE_NO_BACKEND_SHARED:\r\n__cleancache_init_shared_fs(sb);\r\nbreak;\r\n}\r\n}\r\nint cleancache_register_ops(const struct cleancache_ops *ops)\r\n{\r\nif (cmpxchg(&cleancache_ops, NULL, ops))\r\nreturn -EBUSY;\r\niterate_supers(cleancache_register_ops_sb, NULL);\r\nreturn 0;\r\n}\r\nvoid __cleancache_init_fs(struct super_block *sb)\r\n{\r\nint pool_id = CLEANCACHE_NO_BACKEND;\r\nif (cleancache_ops) {\r\npool_id = cleancache_ops->init_fs(PAGE_SIZE);\r\nif (pool_id < 0)\r\npool_id = CLEANCACHE_NO_POOL;\r\n}\r\nsb->cleancache_poolid = pool_id;\r\n}\r\nvoid __cleancache_init_shared_fs(struct super_block *sb)\r\n{\r\nint pool_id = CLEANCACHE_NO_BACKEND_SHARED;\r\nif (cleancache_ops) {\r\npool_id = cleancache_ops->init_shared_fs(sb->s_uuid, PAGE_SIZE);\r\nif (pool_id < 0)\r\npool_id = CLEANCACHE_NO_POOL;\r\n}\r\nsb->cleancache_poolid = pool_id;\r\n}\r\nstatic int cleancache_get_key(struct inode *inode,\r\nstruct cleancache_filekey *key)\r\n{\r\nint (*fhfn)(struct inode *, __u32 *fh, int *, struct inode *);\r\nint len = 0, maxlen = CLEANCACHE_KEY_MAX;\r\nstruct super_block *sb = inode->i_sb;\r\nkey->u.ino = inode->i_ino;\r\nif (sb->s_export_op != NULL) {\r\nfhfn = sb->s_export_op->encode_fh;\r\nif (fhfn) {\r\nlen = (*fhfn)(inode, &key->u.fh[0], &maxlen, NULL);\r\nif (len <= FILEID_ROOT || len == FILEID_INVALID)\r\nreturn -1;\r\nif (maxlen > CLEANCACHE_KEY_MAX)\r\nreturn -1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint __cleancache_get_page(struct page *page)\r\n{\r\nint ret = -1;\r\nint pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops) {\r\ncleancache_failed_gets++;\r\ngoto out;\r\n}\r\nVM_BUG_ON_PAGE(!PageLocked(page), page);\r\npool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (pool_id < 0)\r\ngoto out;\r\nif (cleancache_get_key(page->mapping->host, &key) < 0)\r\ngoto out;\r\nret = cleancache_ops->get_page(pool_id, key, page->index, page);\r\nif (ret == 0)\r\ncleancache_succ_gets++;\r\nelse\r\ncleancache_failed_gets++;\r\nout:\r\nreturn ret;\r\n}\r\nvoid __cleancache_put_page(struct page *page)\r\n{\r\nint pool_id;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops) {\r\ncleancache_puts++;\r\nreturn;\r\n}\r\nVM_BUG_ON_PAGE(!PageLocked(page), page);\r\npool_id = page->mapping->host->i_sb->cleancache_poolid;\r\nif (pool_id >= 0 &&\r\ncleancache_get_key(page->mapping->host, &key) >= 0) {\r\ncleancache_ops->put_page(pool_id, key, page->index, page);\r\ncleancache_puts++;\r\n}\r\n}\r\nvoid __cleancache_invalidate_page(struct address_space *mapping,\r\nstruct page *page)\r\n{\r\nint pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops)\r\nreturn;\r\nif (pool_id >= 0) {\r\nVM_BUG_ON_PAGE(!PageLocked(page), page);\r\nif (cleancache_get_key(mapping->host, &key) >= 0) {\r\ncleancache_ops->invalidate_page(pool_id,\r\nkey, page->index);\r\ncleancache_invalidates++;\r\n}\r\n}\r\n}\r\nvoid __cleancache_invalidate_inode(struct address_space *mapping)\r\n{\r\nint pool_id = mapping->host->i_sb->cleancache_poolid;\r\nstruct cleancache_filekey key = { .u.key = { 0 } };\r\nif (!cleancache_ops)\r\nreturn;\r\nif (pool_id >= 0 && cleancache_get_key(mapping->host, &key) >= 0)\r\ncleancache_ops->invalidate_inode(pool_id, key);\r\n}\r\nvoid __cleancache_invalidate_fs(struct super_block *sb)\r\n{\r\nint pool_id;\r\npool_id = sb->cleancache_poolid;\r\nsb->cleancache_poolid = CLEANCACHE_NO_POOL;\r\nif (cleancache_ops && pool_id >= 0)\r\ncleancache_ops->invalidate_fs(pool_id);\r\n}\r\nstatic int __init init_cleancache(void)\r\n{\r\n#ifdef CONFIG_DEBUG_FS\r\nstruct dentry *root = debugfs_create_dir("cleancache", NULL);\r\nif (root == NULL)\r\nreturn -ENXIO;\r\ndebugfs_create_u64("succ_gets", S_IRUGO, root, &cleancache_succ_gets);\r\ndebugfs_create_u64("failed_gets", S_IRUGO,\r\nroot, &cleancache_failed_gets);\r\ndebugfs_create_u64("puts", S_IRUGO, root, &cleancache_puts);\r\ndebugfs_create_u64("invalidates", S_IRUGO,\r\nroot, &cleancache_invalidates);\r\n#endif\r\nreturn 0;\r\n}
