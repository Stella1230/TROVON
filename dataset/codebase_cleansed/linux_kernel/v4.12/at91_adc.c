static irqreturn_t at91_adc_trigger_handler(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *idev = pf->indio_dev;\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nint i, j = 0;\r\nfor (i = 0; i < idev->masklength; i++) {\r\nif (!test_bit(i, idev->active_scan_mask))\r\ncontinue;\r\nst->buffer[j] = at91_adc_readl(st, AT91_ADC_CHAN(st, i));\r\nj++;\r\n}\r\niio_push_to_buffers_with_timestamp(idev, st->buffer, pf->timestamp);\r\niio_trigger_notify_done(idev->trig);\r\nat91_adc_readl(st, AT91_ADC_LCDR);\r\nenable_irq(st->irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void handle_adc_eoc_trigger(int irq, struct iio_dev *idev)\r\n{\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nif (iio_buffer_enabled(idev)) {\r\ndisable_irq_nosync(irq);\r\niio_trigger_poll(idev->trig);\r\n} else {\r\nst->last_value = at91_adc_readl(st, AT91_ADC_CHAN(st, st->chnb));\r\nst->done = true;\r\nwake_up_interruptible(&st->wq_data_avail);\r\n}\r\n}\r\nstatic int at91_ts_sample(struct at91_adc_state *st)\r\n{\r\nunsigned int xscale, yscale, reg, z1, z2;\r\nunsigned int x, y, pres, xpos, ypos;\r\nunsigned int rxp = 1;\r\nunsigned int factor = 1000;\r\nstruct iio_dev *idev = iio_priv_to_dev(st);\r\nunsigned int xyz_mask_bits = st->res;\r\nunsigned int xyz_mask = (1 << xyz_mask_bits) - 1;\r\nreg = at91_adc_readl(st, AT91_ADC_TSXPOSR);\r\nxpos = reg & xyz_mask;\r\nx = (xpos << MAX_POS_BITS) - xpos;\r\nxscale = (reg >> 16) & xyz_mask;\r\nif (xscale == 0) {\r\ndev_err(&idev->dev, "Error: xscale == 0!\n");\r\nreturn -1;\r\n}\r\nx /= xscale;\r\nreg = at91_adc_readl(st, AT91_ADC_TSYPOSR);\r\nypos = reg & xyz_mask;\r\ny = (ypos << MAX_POS_BITS) - ypos;\r\nyscale = (reg >> 16) & xyz_mask;\r\nif (yscale == 0) {\r\ndev_err(&idev->dev, "Error: yscale == 0!\n");\r\nreturn -1;\r\n}\r\ny /= yscale;\r\nreg = at91_adc_readl(st, AT91_ADC_TSPRESSR);\r\nz1 = reg & xyz_mask;\r\nz2 = (reg >> 16) & xyz_mask;\r\nif (z1 != 0)\r\npres = rxp * (x * factor / 1024) * (z2 * factor / z1 - factor)\r\n/ factor;\r\nelse\r\npres = st->ts_pressure_threshold;\r\ndev_dbg(&idev->dev, "xpos = %d, xscale = %d, ypos = %d, yscale = %d, z1 = %d, z2 = %d, press = %d\n",\r\nxpos, xscale, ypos, yscale, z1, z2, pres);\r\nif (pres < st->ts_pressure_threshold) {\r\ndev_dbg(&idev->dev, "x = %d, y = %d, pressure = %d\n",\r\nx, y, pres / factor);\r\ninput_report_abs(st->ts_input, ABS_X, x);\r\ninput_report_abs(st->ts_input, ABS_Y, y);\r\ninput_report_abs(st->ts_input, ABS_PRESSURE, pres);\r\ninput_report_key(st->ts_input, BTN_TOUCH, 1);\r\ninput_sync(st->ts_input);\r\n} else {\r\ndev_dbg(&idev->dev, "pressure too low: not reporting\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t at91_adc_rl_interrupt(int irq, void *private)\r\n{\r\nstruct iio_dev *idev = private;\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nu32 status = at91_adc_readl(st, st->registers->status_register);\r\nunsigned int reg;\r\nstatus &= at91_adc_readl(st, AT91_ADC_IMR);\r\nif (status & GENMASK(st->num_channels - 1, 0))\r\nhandle_adc_eoc_trigger(irq, idev);\r\nif (status & AT91RL_ADC_IER_PEN) {\r\nreg = at91_adc_readl(st, AT91_ADC_MR);\r\nreg &= ~AT91_ADC_PENDBC;\r\nat91_adc_writel(st, AT91_ADC_MR, reg);\r\nat91_adc_writel(st, AT91_ADC_IDR, AT91RL_ADC_IER_PEN);\r\nat91_adc_writel(st, AT91_ADC_IER, AT91RL_ADC_IER_NOPEN\r\n| AT91_ADC_EOC(3));\r\nat91_adc_writel(st, st->registers->trigger_register,\r\nAT91_ADC_TRGR_MOD_PERIOD_TRIG |\r\nAT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val));\r\n} else if (status & AT91RL_ADC_IER_NOPEN) {\r\nreg = at91_adc_readl(st, AT91_ADC_MR);\r\nreg |= AT91_ADC_PENDBC_(st->ts_pendbc) & AT91_ADC_PENDBC;\r\nat91_adc_writel(st, AT91_ADC_MR, reg);\r\nat91_adc_writel(st, st->registers->trigger_register,\r\nAT91_ADC_TRGR_NONE);\r\nat91_adc_writel(st, AT91_ADC_IDR, AT91RL_ADC_IER_NOPEN\r\n| AT91_ADC_EOC(3));\r\nat91_adc_writel(st, AT91_ADC_IER, AT91RL_ADC_IER_PEN);\r\nst->ts_bufferedmeasure = false;\r\ninput_report_key(st->ts_input, BTN_TOUCH, 0);\r\ninput_sync(st->ts_input);\r\n} else if (status & AT91_ADC_EOC(3) && st->ts_input) {\r\nif (st->ts_bufferedmeasure) {\r\ninput_report_abs(st->ts_input, ABS_X, st->ts_prev_absx);\r\ninput_report_abs(st->ts_input, ABS_Y, st->ts_prev_absy);\r\ninput_report_key(st->ts_input, BTN_TOUCH, 1);\r\ninput_sync(st->ts_input);\r\n} else\r\nst->ts_bufferedmeasure = true;\r\nst->ts_prev_absx = at91_adc_readl(st, AT91_ADC_CHAN(st, 3))\r\n<< MAX_RLPOS_BITS;\r\nst->ts_prev_absx /= at91_adc_readl(st, AT91_ADC_CHAN(st, 2));\r\nst->ts_prev_absy = at91_adc_readl(st, AT91_ADC_CHAN(st, 1))\r\n<< MAX_RLPOS_BITS;\r\nst->ts_prev_absy /= at91_adc_readl(st, AT91_ADC_CHAN(st, 0));\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t at91_adc_9x5_interrupt(int irq, void *private)\r\n{\r\nstruct iio_dev *idev = private;\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nu32 status = at91_adc_readl(st, st->registers->status_register);\r\nconst uint32_t ts_data_irq_mask =\r\nAT91_ADC_IER_XRDY |\r\nAT91_ADC_IER_YRDY |\r\nAT91_ADC_IER_PRDY;\r\nif (status & GENMASK(st->num_channels - 1, 0))\r\nhandle_adc_eoc_trigger(irq, idev);\r\nif (status & AT91_ADC_IER_PEN) {\r\nat91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_PEN);\r\nat91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_NOPEN |\r\nts_data_irq_mask);\r\nat91_adc_writel(st, st->registers->trigger_register,\r\nAT91_ADC_TRGR_MOD_PERIOD_TRIG |\r\nAT91_ADC_TRGR_TRGPER_(st->ts_sample_period_val));\r\n} else if (status & AT91_ADC_IER_NOPEN) {\r\nat91_adc_writel(st, st->registers->trigger_register, 0);\r\nat91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_NOPEN |\r\nts_data_irq_mask);\r\nat91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);\r\ninput_report_key(st->ts_input, BTN_TOUCH, 0);\r\ninput_sync(st->ts_input);\r\n} else if ((status & ts_data_irq_mask) == ts_data_irq_mask) {\r\nif (status & AT91_ADC_ISR_PENS) {\r\nat91_ts_sample(st);\r\n} else {\r\nat91_adc_readl(st, AT91_ADC_TSXPOSR);\r\nat91_adc_readl(st, AT91_ADC_TSYPOSR);\r\nat91_adc_readl(st, AT91_ADC_TSPRESSR);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int at91_adc_channel_init(struct iio_dev *idev)\r\n{\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nstruct iio_chan_spec *chan_array, *timestamp;\r\nint bit, idx = 0;\r\nunsigned long rsvd_mask = 0;\r\nif (st->touchscreen_type == ATMEL_ADC_TOUCHSCREEN_4WIRE)\r\nrsvd_mask = CHAN_MASK_TOUCHSCREEN_4WIRE;\r\nelse if (st->touchscreen_type == ATMEL_ADC_TOUCHSCREEN_5WIRE)\r\nrsvd_mask = CHAN_MASK_TOUCHSCREEN_5WIRE;\r\nst->channels_mask &= ~rsvd_mask;\r\nidev->num_channels = bitmap_weight(&st->channels_mask,\r\nst->num_channels) + 1;\r\nchan_array = devm_kzalloc(&idev->dev,\r\n((idev->num_channels + 1) *\r\nsizeof(struct iio_chan_spec)),\r\nGFP_KERNEL);\r\nif (!chan_array)\r\nreturn -ENOMEM;\r\nfor_each_set_bit(bit, &st->channels_mask, st->num_channels) {\r\nstruct iio_chan_spec *chan = chan_array + idx;\r\nchan->type = IIO_VOLTAGE;\r\nchan->indexed = 1;\r\nchan->channel = bit;\r\nchan->scan_index = idx;\r\nchan->scan_type.sign = 'u';\r\nchan->scan_type.realbits = st->res;\r\nchan->scan_type.storagebits = 16;\r\nchan->info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE);\r\nchan->info_mask_separate = BIT(IIO_CHAN_INFO_RAW);\r\nidx++;\r\n}\r\ntimestamp = chan_array + idx;\r\ntimestamp->type = IIO_TIMESTAMP;\r\ntimestamp->channel = -1;\r\ntimestamp->scan_index = idx;\r\ntimestamp->scan_type.sign = 's';\r\ntimestamp->scan_type.realbits = 64;\r\ntimestamp->scan_type.storagebits = 64;\r\nidev->channels = chan_array;\r\nreturn idev->num_channels;\r\n}\r\nstatic int at91_adc_get_trigger_value_by_name(struct iio_dev *idev,\r\nstruct at91_adc_trigger *triggers,\r\nconst char *trigger_name)\r\n{\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nint i;\r\nfor (i = 0; i < st->trigger_number; i++) {\r\nchar *name = kasprintf(GFP_KERNEL,\r\n"%s-dev%d-%s",\r\nidev->name,\r\nidev->id,\r\ntriggers[i].name);\r\nif (!name)\r\nreturn -ENOMEM;\r\nif (strcmp(trigger_name, name) == 0) {\r\nkfree(name);\r\nif (triggers[i].value == 0)\r\nreturn -EINVAL;\r\nreturn triggers[i].value;\r\n}\r\nkfree(name);\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int at91_adc_configure_trigger(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_dev *idev = iio_trigger_get_drvdata(trig);\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nstruct at91_adc_reg_desc *reg = st->registers;\r\nu32 status = at91_adc_readl(st, reg->trigger_register);\r\nint value;\r\nu8 bit;\r\nvalue = at91_adc_get_trigger_value_by_name(idev,\r\nst->trigger_list,\r\nidev->trig->name);\r\nif (value < 0)\r\nreturn value;\r\nif (state) {\r\nst->buffer = kmalloc(idev->scan_bytes, GFP_KERNEL);\r\nif (st->buffer == NULL)\r\nreturn -ENOMEM;\r\nat91_adc_writel(st, reg->trigger_register,\r\nstatus | value);\r\nfor_each_set_bit(bit, idev->active_scan_mask,\r\nst->num_channels) {\r\nstruct iio_chan_spec const *chan = idev->channels + bit;\r\nat91_adc_writel(st, AT91_ADC_CHER,\r\nAT91_ADC_CH(chan->channel));\r\n}\r\nat91_adc_writel(st, AT91_ADC_IER, reg->drdy_mask);\r\n} else {\r\nat91_adc_writel(st, AT91_ADC_IDR, reg->drdy_mask);\r\nat91_adc_writel(st, reg->trigger_register,\r\nstatus & ~value);\r\nfor_each_set_bit(bit, idev->active_scan_mask,\r\nst->num_channels) {\r\nstruct iio_chan_spec const *chan = idev->channels + bit;\r\nat91_adc_writel(st, AT91_ADC_CHDR,\r\nAT91_ADC_CH(chan->channel));\r\n}\r\nkfree(st->buffer);\r\n}\r\nreturn 0;\r\n}\r\nstatic struct iio_trigger *at91_adc_allocate_trigger(struct iio_dev *idev,\r\nstruct at91_adc_trigger *trigger)\r\n{\r\nstruct iio_trigger *trig;\r\nint ret;\r\ntrig = iio_trigger_alloc("%s-dev%d-%s", idev->name,\r\nidev->id, trigger->name);\r\nif (trig == NULL)\r\nreturn NULL;\r\ntrig->dev.parent = idev->dev.parent;\r\niio_trigger_set_drvdata(trig, idev);\r\ntrig->ops = &at91_adc_trigger_ops;\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\nreturn NULL;\r\nreturn trig;\r\n}\r\nstatic int at91_adc_trigger_init(struct iio_dev *idev)\r\n{\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nint i, ret;\r\nst->trig = devm_kzalloc(&idev->dev,\r\nst->trigger_number * sizeof(*st->trig),\r\nGFP_KERNEL);\r\nif (st->trig == NULL) {\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nfor (i = 0; i < st->trigger_number; i++) {\r\nif (st->trigger_list[i].is_external && !(st->use_external))\r\ncontinue;\r\nst->trig[i] = at91_adc_allocate_trigger(idev,\r\nst->trigger_list + i);\r\nif (st->trig[i] == NULL) {\r\ndev_err(&idev->dev,\r\n"Could not allocate trigger %d\n", i);\r\nret = -ENOMEM;\r\ngoto error_trigger;\r\n}\r\n}\r\nreturn 0;\r\nerror_trigger:\r\nfor (i--; i >= 0; i--) {\r\niio_trigger_unregister(st->trig[i]);\r\niio_trigger_free(st->trig[i]);\r\n}\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic void at91_adc_trigger_remove(struct iio_dev *idev)\r\n{\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nint i;\r\nfor (i = 0; i < st->trigger_number; i++) {\r\niio_trigger_unregister(st->trig[i]);\r\niio_trigger_free(st->trig[i]);\r\n}\r\n}\r\nstatic int at91_adc_buffer_init(struct iio_dev *idev)\r\n{\r\nreturn iio_triggered_buffer_setup(idev, &iio_pollfunc_store_time,\r\n&at91_adc_trigger_handler, NULL);\r\n}\r\nstatic void at91_adc_buffer_remove(struct iio_dev *idev)\r\n{\r\niio_triggered_buffer_cleanup(idev);\r\n}\r\nstatic int at91_adc_read_raw(struct iio_dev *idev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nmutex_lock(&st->lock);\r\nst->chnb = chan->channel;\r\nat91_adc_writel(st, AT91_ADC_CHER,\r\nAT91_ADC_CH(chan->channel));\r\nat91_adc_writel(st, AT91_ADC_IER, BIT(chan->channel));\r\nat91_adc_writel(st, AT91_ADC_CR, AT91_ADC_START);\r\nret = wait_event_interruptible_timeout(st->wq_data_avail,\r\nst->done,\r\nmsecs_to_jiffies(1000));\r\nif (ret == 0)\r\nret = -ETIMEDOUT;\r\nif (ret < 0) {\r\nmutex_unlock(&st->lock);\r\nreturn ret;\r\n}\r\n*val = st->last_value;\r\nat91_adc_writel(st, AT91_ADC_CHDR,\r\nAT91_ADC_CH(chan->channel));\r\nat91_adc_writel(st, AT91_ADC_IDR, BIT(chan->channel));\r\nst->last_value = 0;\r\nst->done = false;\r\nmutex_unlock(&st->lock);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_SCALE:\r\n*val = st->vref_mv;\r\n*val2 = chan->scan_type.realbits;\r\nreturn IIO_VAL_FRACTIONAL_LOG2;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int at91_adc_of_get_resolution(struct at91_adc_state *st,\r\nstruct platform_device *pdev)\r\n{\r\nstruct iio_dev *idev = iio_priv_to_dev(st);\r\nstruct device_node *np = pdev->dev.of_node;\r\nint count, i, ret = 0;\r\nchar *res_name, *s;\r\nu32 *resolutions;\r\ncount = of_property_count_strings(np, "atmel,adc-res-names");\r\nif (count < 2) {\r\ndev_err(&idev->dev, "You must specified at least two resolution names for "\r\n"adc-res-names property in the DT\n");\r\nreturn count;\r\n}\r\nresolutions = kmalloc_array(count, sizeof(*resolutions), GFP_KERNEL);\r\nif (!resolutions)\r\nreturn -ENOMEM;\r\nif (of_property_read_u32_array(np, "atmel,adc-res", resolutions, count)) {\r\ndev_err(&idev->dev, "Missing adc-res property in the DT.\n");\r\nret = -ENODEV;\r\ngoto ret;\r\n}\r\nif (of_property_read_string(np, "atmel,adc-use-res", (const char **)&res_name))\r\nres_name = "highres";\r\nfor (i = 0; i < count; i++) {\r\nif (of_property_read_string_index(np, "atmel,adc-res-names", i, (const char **)&s))\r\ncontinue;\r\nif (strcmp(res_name, s))\r\ncontinue;\r\nst->res = resolutions[i];\r\nif (!strcmp(res_name, "lowres"))\r\nst->low_res = true;\r\nelse\r\nst->low_res = false;\r\ndev_info(&idev->dev, "Resolution used: %u bits\n", st->res);\r\ngoto ret;\r\n}\r\ndev_err(&idev->dev, "There is no resolution for %s\n", res_name);\r\nret:\r\nkfree(resolutions);\r\nreturn ret;\r\n}\r\nstatic u32 calc_startup_ticks_9260(u32 startup_time, u32 adc_clk_khz)\r\n{\r\nreturn round_up((startup_time * adc_clk_khz / 1000) - 1, 8) / 8;\r\n}\r\nstatic u32 calc_startup_ticks_9x5(u32 startup_time, u32 adc_clk_khz)\r\n{\r\nconst int startup_lookup[] = {\r\n0, 8, 16, 24,\r\n64, 80, 96, 112,\r\n512, 576, 640, 704,\r\n768, 832, 896, 960\r\n};\r\nint i, size = ARRAY_SIZE(startup_lookup);\r\nunsigned int ticks;\r\nticks = startup_time * adc_clk_khz / 1000;\r\nfor (i = 0; i < size; i++)\r\nif (ticks < startup_lookup[i])\r\nbreak;\r\nticks = i;\r\nif (ticks == size)\r\nticks = size - 1;\r\nreturn ticks;\r\n}\r\nstatic int at91_adc_probe_dt_ts(struct device_node *node,\r\nstruct at91_adc_state *st, struct device *dev)\r\n{\r\nint ret;\r\nu32 prop;\r\nret = of_property_read_u32(node, "atmel,adc-ts-wires", &prop);\r\nif (ret) {\r\ndev_info(dev, "ADC Touch screen is disabled.\n");\r\nreturn 0;\r\n}\r\nswitch (prop) {\r\ncase 4:\r\ncase 5:\r\nst->touchscreen_type = prop;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unsupported number of touchscreen wires (%d). Should be 4 or 5.\n", prop);\r\nreturn -EINVAL;\r\n}\r\nif (!st->caps->has_tsmr)\r\nreturn 0;\r\nprop = 0;\r\nof_property_read_u32(node, "atmel,adc-ts-pressure-threshold", &prop);\r\nst->ts_pressure_threshold = prop;\r\nif (st->ts_pressure_threshold) {\r\nreturn 0;\r\n} else {\r\ndev_err(dev, "Invalid pressure threshold for the touchscreen\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int at91_adc_probe_dt(struct at91_adc_state *st,\r\nstruct platform_device *pdev)\r\n{\r\nstruct iio_dev *idev = iio_priv_to_dev(st);\r\nstruct device_node *node = pdev->dev.of_node;\r\nstruct device_node *trig_node;\r\nint i = 0, ret;\r\nu32 prop;\r\nif (!node)\r\nreturn -EINVAL;\r\nst->caps = (struct at91_adc_caps *)\r\nof_match_device(at91_adc_dt_ids, &pdev->dev)->data;\r\nst->use_external = of_property_read_bool(node, "atmel,adc-use-external-triggers");\r\nif (of_property_read_u32(node, "atmel,adc-channels-used", &prop)) {\r\ndev_err(&idev->dev, "Missing adc-channels-used property in the DT.\n");\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\nst->channels_mask = prop;\r\nst->sleep_mode = of_property_read_bool(node, "atmel,adc-sleep-mode");\r\nif (of_property_read_u32(node, "atmel,adc-startup-time", &prop)) {\r\ndev_err(&idev->dev, "Missing adc-startup-time property in the DT.\n");\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\nst->startup_time = prop;\r\nprop = 0;\r\nof_property_read_u32(node, "atmel,adc-sample-hold-time", &prop);\r\nst->sample_hold_time = prop;\r\nif (of_property_read_u32(node, "atmel,adc-vref", &prop)) {\r\ndev_err(&idev->dev, "Missing adc-vref property in the DT.\n");\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\nst->vref_mv = prop;\r\nret = at91_adc_of_get_resolution(st, pdev);\r\nif (ret)\r\ngoto error_ret;\r\nst->registers = &st->caps->registers;\r\nst->num_channels = st->caps->num_channels;\r\nst->trigger_number = of_get_child_count(node);\r\nst->trigger_list = devm_kzalloc(&idev->dev, st->trigger_number *\r\nsizeof(struct at91_adc_trigger),\r\nGFP_KERNEL);\r\nif (!st->trigger_list) {\r\ndev_err(&idev->dev, "Could not allocate trigger list memory.\n");\r\nret = -ENOMEM;\r\ngoto error_ret;\r\n}\r\nfor_each_child_of_node(node, trig_node) {\r\nstruct at91_adc_trigger *trig = st->trigger_list + i;\r\nconst char *name;\r\nif (of_property_read_string(trig_node, "trigger-name", &name)) {\r\ndev_err(&idev->dev, "Missing trigger-name property in the DT.\n");\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\ntrig->name = name;\r\nif (of_property_read_u32(trig_node, "trigger-value", &prop)) {\r\ndev_err(&idev->dev, "Missing trigger-value property in the DT.\n");\r\nret = -EINVAL;\r\ngoto error_ret;\r\n}\r\ntrig->value = prop;\r\ntrig->is_external = of_property_read_bool(trig_node, "trigger-external");\r\ni++;\r\n}\r\nif (st->caps->has_ts)\r\nreturn at91_adc_probe_dt_ts(node, st, &idev->dev);\r\nelse\r\ndev_info(&idev->dev, "not support touchscreen in the adc compatible string.\n");\r\nreturn 0;\r\nerror_ret:\r\nreturn ret;\r\n}\r\nstatic int at91_adc_probe_pdata(struct at91_adc_state *st,\r\nstruct platform_device *pdev)\r\n{\r\nstruct at91_adc_data *pdata = pdev->dev.platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nst->caps = (struct at91_adc_caps *)\r\nplatform_get_device_id(pdev)->driver_data;\r\nst->use_external = pdata->use_external_triggers;\r\nst->vref_mv = pdata->vref;\r\nst->channels_mask = pdata->channels_used;\r\nst->num_channels = st->caps->num_channels;\r\nst->startup_time = pdata->startup_time;\r\nst->trigger_number = pdata->trigger_number;\r\nst->trigger_list = pdata->trigger_list;\r\nst->registers = &st->caps->registers;\r\nst->touchscreen_type = pdata->touchscreen_type;\r\nreturn 0;\r\n}\r\nstatic int atmel_ts_open(struct input_dev *dev)\r\n{\r\nstruct at91_adc_state *st = input_get_drvdata(dev);\r\nif (st->caps->has_tsmr)\r\nat91_adc_writel(st, AT91_ADC_IER, AT91_ADC_IER_PEN);\r\nelse\r\nat91_adc_writel(st, AT91_ADC_IER, AT91RL_ADC_IER_PEN);\r\nreturn 0;\r\n}\r\nstatic void atmel_ts_close(struct input_dev *dev)\r\n{\r\nstruct at91_adc_state *st = input_get_drvdata(dev);\r\nif (st->caps->has_tsmr)\r\nat91_adc_writel(st, AT91_ADC_IDR, AT91_ADC_IER_PEN);\r\nelse\r\nat91_adc_writel(st, AT91_ADC_IDR, AT91RL_ADC_IER_PEN);\r\n}\r\nstatic int at91_ts_hw_init(struct at91_adc_state *st, u32 adc_clk_khz)\r\n{\r\nstruct iio_dev *idev = iio_priv_to_dev(st);\r\nu32 reg = 0;\r\nu32 tssctim = 0;\r\nint i = 0;\r\nst->ts_pendbc = round_up(TOUCH_PEN_DETECT_DEBOUNCE_US * adc_clk_khz /\r\n1000, 1);\r\nwhile (st->ts_pendbc >> ++i)\r\n;\r\nif (abs(st->ts_pendbc - (1 << i)) < abs(st->ts_pendbc - (1 << (i - 1))))\r\nst->ts_pendbc = i;\r\nelse\r\nst->ts_pendbc = i - 1;\r\nif (!st->caps->has_tsmr) {\r\nreg = at91_adc_readl(st, AT91_ADC_MR);\r\nreg |= AT91_ADC_TSAMOD_TS_ONLY_MODE | AT91_ADC_PENDET;\r\nreg |= AT91_ADC_PENDBC_(st->ts_pendbc) & AT91_ADC_PENDBC;\r\nat91_adc_writel(st, AT91_ADC_MR, reg);\r\nreg = AT91_ADC_TSR_SHTIM_(TOUCH_SHTIM) & AT91_ADC_TSR_SHTIM;\r\nat91_adc_writel(st, AT91_ADC_TSR, reg);\r\nst->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US_RL *\r\nadc_clk_khz / 1000) - 1, 1);\r\nreturn 0;\r\n}\r\ntssctim = DIV_ROUND_UP(TOUCH_SCTIM_US * adc_clk_khz / 1000, 4);\r\ndev_dbg(&idev->dev, "adc_clk at: %d KHz, tssctim at: %d\n",\r\nadc_clk_khz, tssctim);\r\nif (st->touchscreen_type == ATMEL_ADC_TOUCHSCREEN_4WIRE)\r\nreg = AT91_ADC_TSMR_TSMODE_4WIRE_PRESS;\r\nelse\r\nreg = AT91_ADC_TSMR_TSMODE_5WIRE;\r\nreg |= AT91_ADC_TSMR_SCTIM_(tssctim) & AT91_ADC_TSMR_SCTIM;\r\nreg |= AT91_ADC_TSMR_TSAV_(st->caps->ts_filter_average)\r\n& AT91_ADC_TSMR_TSAV;\r\nreg |= AT91_ADC_TSMR_PENDBC_(st->ts_pendbc) & AT91_ADC_TSMR_PENDBC;\r\nreg |= AT91_ADC_TSMR_NOTSDMA;\r\nreg |= AT91_ADC_TSMR_PENDET_ENA;\r\nreg |= 0x03 << 8;\r\nat91_adc_writel(st, AT91_ADC_TSMR, reg);\r\nat91_adc_writel(st, AT91_ADC_ACR, st->caps->ts_pen_detect_sensitivity\r\n& AT91_ADC_ACR_PENDETSENS);\r\nst->ts_sample_period_val = round_up((TOUCH_SAMPLE_PERIOD_US *\r\nadc_clk_khz / 1000) - 1, 1);\r\nreturn 0;\r\n}\r\nstatic int at91_ts_register(struct at91_adc_state *st,\r\nstruct platform_device *pdev)\r\n{\r\nstruct input_dev *input;\r\nstruct iio_dev *idev = iio_priv_to_dev(st);\r\nint ret;\r\ninput = input_allocate_device();\r\nif (!input) {\r\ndev_err(&idev->dev, "Failed to allocate TS device!\n");\r\nreturn -ENOMEM;\r\n}\r\ninput->name = DRIVER_NAME;\r\ninput->id.bustype = BUS_HOST;\r\ninput->dev.parent = &pdev->dev;\r\ninput->open = atmel_ts_open;\r\ninput->close = atmel_ts_close;\r\n__set_bit(EV_ABS, input->evbit);\r\n__set_bit(EV_KEY, input->evbit);\r\n__set_bit(BTN_TOUCH, input->keybit);\r\nif (st->caps->has_tsmr) {\r\ninput_set_abs_params(input, ABS_X, 0, (1 << MAX_POS_BITS) - 1,\r\n0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, (1 << MAX_POS_BITS) - 1,\r\n0, 0);\r\ninput_set_abs_params(input, ABS_PRESSURE, 0, 0xffffff, 0, 0);\r\n} else {\r\nif (st->touchscreen_type != ATMEL_ADC_TOUCHSCREEN_4WIRE) {\r\ndev_err(&pdev->dev,\r\n"This touchscreen controller only support 4 wires\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ninput_set_abs_params(input, ABS_X, 0, (1 << MAX_RLPOS_BITS) - 1,\r\n0, 0);\r\ninput_set_abs_params(input, ABS_Y, 0, (1 << MAX_RLPOS_BITS) - 1,\r\n0, 0);\r\n}\r\nst->ts_input = input;\r\ninput_set_drvdata(input, st);\r\nret = input_register_device(input);\r\nif (ret)\r\ngoto err;\r\nreturn ret;\r\nerr:\r\ninput_free_device(st->ts_input);\r\nreturn ret;\r\n}\r\nstatic void at91_ts_unregister(struct at91_adc_state *st)\r\n{\r\ninput_unregister_device(st->ts_input);\r\n}\r\nstatic int at91_adc_probe(struct platform_device *pdev)\r\n{\r\nunsigned int prsc, mstrclk, ticks, adc_clk, adc_clk_khz, shtim;\r\nint ret;\r\nstruct iio_dev *idev;\r\nstruct at91_adc_state *st;\r\nstruct resource *res;\r\nu32 reg;\r\nidev = devm_iio_device_alloc(&pdev->dev, sizeof(struct at91_adc_state));\r\nif (!idev)\r\nreturn -ENOMEM;\r\nst = iio_priv(idev);\r\nif (pdev->dev.of_node)\r\nret = at91_adc_probe_dt(st, pdev);\r\nelse\r\nret = at91_adc_probe_pdata(st, pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No platform data available.\n");\r\nreturn -EINVAL;\r\n}\r\nplatform_set_drvdata(pdev, idev);\r\nidev->dev.parent = &pdev->dev;\r\nidev->name = dev_name(&pdev->dev);\r\nidev->modes = INDIO_DIRECT_MODE;\r\nidev->info = &at91_adc_info;\r\nst->irq = platform_get_irq(pdev, 0);\r\nif (st->irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ ID is designated\n");\r\nreturn -ENODEV;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nst->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(st->reg_base)) {\r\nreturn PTR_ERR(st->reg_base);\r\n}\r\nat91_adc_writel(st, AT91_ADC_CR, AT91_ADC_SWRST);\r\nat91_adc_writel(st, AT91_ADC_IDR, 0xFFFFFFFF);\r\nif (st->caps->has_tsmr)\r\nret = request_irq(st->irq, at91_adc_9x5_interrupt, 0,\r\npdev->dev.driver->name, idev);\r\nelse\r\nret = request_irq(st->irq, at91_adc_rl_interrupt, 0,\r\npdev->dev.driver->name, idev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to allocate IRQ.\n");\r\nreturn ret;\r\n}\r\nst->clk = devm_clk_get(&pdev->dev, "adc_clk");\r\nif (IS_ERR(st->clk)) {\r\ndev_err(&pdev->dev, "Failed to get the clock.\n");\r\nret = PTR_ERR(st->clk);\r\ngoto error_free_irq;\r\n}\r\nret = clk_prepare_enable(st->clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not prepare or enable the clock.\n");\r\ngoto error_free_irq;\r\n}\r\nst->adc_clk = devm_clk_get(&pdev->dev, "adc_op_clk");\r\nif (IS_ERR(st->adc_clk)) {\r\ndev_err(&pdev->dev, "Failed to get the ADC clock.\n");\r\nret = PTR_ERR(st->adc_clk);\r\ngoto error_disable_clk;\r\n}\r\nret = clk_prepare_enable(st->adc_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"Could not prepare or enable the ADC clock.\n");\r\ngoto error_disable_clk;\r\n}\r\nmstrclk = clk_get_rate(st->clk);\r\nadc_clk = clk_get_rate(st->adc_clk);\r\nadc_clk_khz = adc_clk / 1000;\r\ndev_dbg(&pdev->dev, "Master clock is set as: %d Hz, adc_clk should set as: %d Hz\n",\r\nmstrclk, adc_clk);\r\nprsc = (mstrclk / (2 * adc_clk)) - 1;\r\nif (!st->startup_time) {\r\ndev_err(&pdev->dev, "No startup time available.\n");\r\nret = -EINVAL;\r\ngoto error_disable_adc_clk;\r\n}\r\nticks = (*st->caps->calc_startup_ticks)(st->startup_time, adc_clk_khz);\r\nif (st->sample_hold_time > 0)\r\nshtim = round_up((st->sample_hold_time * adc_clk_khz / 1000)\r\n- 1, 1);\r\nelse\r\nshtim = 0;\r\nreg = AT91_ADC_PRESCAL_(prsc) & st->registers->mr_prescal_mask;\r\nreg |= AT91_ADC_STARTUP_(ticks) & st->registers->mr_startup_mask;\r\nif (st->low_res)\r\nreg |= AT91_ADC_LOWRES;\r\nif (st->sleep_mode)\r\nreg |= AT91_ADC_SLEEP;\r\nreg |= AT91_ADC_SHTIM_(shtim) & AT91_ADC_SHTIM;\r\nat91_adc_writel(st, AT91_ADC_MR, reg);\r\nret = at91_adc_channel_init(idev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't initialize the channels.\n");\r\ngoto error_disable_adc_clk;\r\n}\r\ninit_waitqueue_head(&st->wq_data_avail);\r\nmutex_init(&st->lock);\r\nif (!st->touchscreen_type) {\r\nret = at91_adc_buffer_init(idev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't initialize the buffer.\n");\r\ngoto error_disable_adc_clk;\r\n}\r\nret = at91_adc_trigger_init(idev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't setup the triggers.\n");\r\nat91_adc_buffer_remove(idev);\r\ngoto error_disable_adc_clk;\r\n}\r\n} else {\r\nret = at91_ts_register(st, pdev);\r\nif (ret)\r\ngoto error_disable_adc_clk;\r\nat91_ts_hw_init(st, adc_clk_khz);\r\n}\r\nret = iio_device_register(idev);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Couldn't register the device.\n");\r\ngoto error_iio_device_register;\r\n}\r\nreturn 0;\r\nerror_iio_device_register:\r\nif (!st->touchscreen_type) {\r\nat91_adc_trigger_remove(idev);\r\nat91_adc_buffer_remove(idev);\r\n} else {\r\nat91_ts_unregister(st);\r\n}\r\nerror_disable_adc_clk:\r\nclk_disable_unprepare(st->adc_clk);\r\nerror_disable_clk:\r\nclk_disable_unprepare(st->clk);\r\nerror_free_irq:\r\nfree_irq(st->irq, idev);\r\nreturn ret;\r\n}\r\nstatic int at91_adc_remove(struct platform_device *pdev)\r\n{\r\nstruct iio_dev *idev = platform_get_drvdata(pdev);\r\nstruct at91_adc_state *st = iio_priv(idev);\r\niio_device_unregister(idev);\r\nif (!st->touchscreen_type) {\r\nat91_adc_trigger_remove(idev);\r\nat91_adc_buffer_remove(idev);\r\n} else {\r\nat91_ts_unregister(st);\r\n}\r\nclk_disable_unprepare(st->adc_clk);\r\nclk_disable_unprepare(st->clk);\r\nfree_irq(st->irq, idev);\r\nreturn 0;\r\n}\r\nstatic int at91_adc_suspend(struct device *dev)\r\n{\r\nstruct iio_dev *idev = platform_get_drvdata(to_platform_device(dev));\r\nstruct at91_adc_state *st = iio_priv(idev);\r\npinctrl_pm_select_sleep_state(dev);\r\nclk_disable_unprepare(st->clk);\r\nreturn 0;\r\n}\r\nstatic int at91_adc_resume(struct device *dev)\r\n{\r\nstruct iio_dev *idev = platform_get_drvdata(to_platform_device(dev));\r\nstruct at91_adc_state *st = iio_priv(idev);\r\nclk_prepare_enable(st->clk);\r\npinctrl_pm_select_default_state(dev);\r\nreturn 0;\r\n}
