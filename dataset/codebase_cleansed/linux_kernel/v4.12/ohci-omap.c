static inline int tps65010_set_gpio_out_value(unsigned gpio, unsigned value)\r\n{\r\nreturn 0;\r\n}\r\nstatic void omap_ohci_clock_power(int on)\r\n{\r\nif (on) {\r\nclk_enable(usb_dc_ck);\r\nclk_enable(usb_host_ck);\r\nudelay(100);\r\n} else {\r\nclk_disable(usb_host_ck);\r\nclk_disable(usb_dc_ck);\r\n}\r\n}\r\nstatic int omap_ohci_transceiver_power(int on)\r\n{\r\nif (on) {\r\nif (machine_is_omap_innovator() && cpu_is_omap1510())\r\n__raw_writeb(__raw_readb(INNOVATOR_FPGA_CAM_USB_CONTROL)\r\n| ((1 << 5) | (1 << 3)),\r\nINNOVATOR_FPGA_CAM_USB_CONTROL);\r\nelse if (machine_is_omap_osk())\r\ntps65010_set_gpio_out_value(GPIO1, LOW);\r\n} else {\r\nif (machine_is_omap_innovator() && cpu_is_omap1510())\r\n__raw_writeb(__raw_readb(INNOVATOR_FPGA_CAM_USB_CONTROL)\r\n& ~((1 << 5) | (1 << 3)),\r\nINNOVATOR_FPGA_CAM_USB_CONTROL);\r\nelse if (machine_is_omap_osk())\r\ntps65010_set_gpio_out_value(GPIO1, HIGH);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_1510_local_bus_power(int on)\r\n{\r\nif (on) {\r\nomap_writel((1 << 1) | (1 << 0), OMAP1510_LB_MMU_CTL);\r\nudelay(200);\r\n} else {\r\nomap_writel(0, OMAP1510_LB_MMU_CTL);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_1510_local_bus_init(void)\r\n{\r\nunsigned int tlb;\r\nunsigned long lbaddr, physaddr;\r\nomap_writel((omap_readl(OMAP1510_LB_CLOCK_DIV) & 0xfffffff8) | 0x4,\r\nOMAP1510_LB_CLOCK_DIV);\r\nfor (tlb = 0; tlb < OMAP1510_LB_MEMSIZE; tlb++) {\r\nlbaddr = tlb * 0x00100000 + OMAP1510_LB_OFFSET;\r\nphysaddr = tlb * 0x00100000 + PHYS_OFFSET;\r\nomap_writel((lbaddr & 0x0fffffff) >> 22, OMAP1510_LB_MMU_CAM_H);\r\nomap_writel(((lbaddr & 0x003ffc00) >> 6) | 0xc,\r\nOMAP1510_LB_MMU_CAM_L);\r\nomap_writel(physaddr >> 16, OMAP1510_LB_MMU_RAM_H);\r\nomap_writel((physaddr & 0x0000fc00) | 0x300, OMAP1510_LB_MMU_RAM_L);\r\nomap_writel(tlb << 4, OMAP1510_LB_MMU_LCK);\r\nomap_writel(0x1, OMAP1510_LB_MMU_LD_TLB);\r\n}\r\nomap_writel(omap_readl(OMAP1510_LB_MMU_CTL) | (1 << 3), OMAP1510_LB_MMU_CTL);\r\nudelay(200);\r\nreturn 0;\r\n}\r\nstatic void start_hnp(struct ohci_hcd *ohci)\r\n{\r\nstruct usb_hcd *hcd = ohci_to_hcd(ohci);\r\nconst unsigned port = hcd->self.otg_port - 1;\r\nunsigned long flags;\r\nu32 l;\r\notg_start_hnp(hcd->usb_phy->otg);\r\nlocal_irq_save(flags);\r\nhcd->usb_phy->otg->state = OTG_STATE_A_SUSPEND;\r\nwritel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);\r\nl = omap_readl(OTG_CTRL);\r\nl &= ~OTG_A_BUSREQ;\r\nomap_writel(l, OTG_CTRL);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int ohci_omap_reset(struct usb_hcd *hcd)\r\n{\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nstruct omap_usb_config *config = dev_get_platdata(hcd->self.controller);\r\nint need_transceiver = (config->otg != 0);\r\nint ret;\r\ndev_dbg(hcd->self.controller, "starting USB Controller\n");\r\nif (config->otg) {\r\nhcd->self.otg_port = config->otg;\r\nhcd->power_budget = 8;\r\n}\r\nneed_transceiver = need_transceiver\r\n|| machine_is_omap_h2() || machine_is_omap_h3();\r\nif (config->ocpi_enable)\r\nconfig->ocpi_enable();\r\n#ifdef CONFIG_USB_OTG\r\nif (need_transceiver) {\r\nhcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);\r\nif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\r\nint status = otg_set_host(hcd->usb_phy->otg,\r\n&ohci_to_hcd(ohci)->self);\r\ndev_dbg(hcd->self.controller, "init %s phy, status %d\n",\r\nhcd->usb_phy->label, status);\r\nif (status) {\r\nusb_put_phy(hcd->usb_phy);\r\nreturn status;\r\n}\r\n} else {\r\nreturn -EPROBE_DEFER;\r\n}\r\nohci->start_hnp = start_hnp;\r\n}\r\n#endif\r\nomap_ohci_clock_power(1);\r\nif (cpu_is_omap15xx()) {\r\nomap_1510_local_bus_power(1);\r\nomap_1510_local_bus_init();\r\n}\r\nret = ohci_setup(hcd);\r\nif (ret < 0)\r\nreturn ret;\r\nif (config->otg || config->rwc) {\r\nohci->hc_control = OHCI_CTRL_RWC;\r\nwritel(OHCI_CTRL_RWC, &ohci->regs->control);\r\n}\r\nif (machine_is_omap_osk() || machine_is_omap_innovator()) {\r\nu32 rh = roothub_a (ohci);\r\nrh &= ~RH_A_NPS;\r\nif (machine_is_omap_osk()) {\r\nohci_to_hcd(ohci)->power_budget = 250;\r\nrh &= ~RH_A_NOCP;\r\nomap_cfg_reg(W8_1610_GPIO9);\r\ngpio_request(9, "OHCI overcurrent");\r\ngpio_direction_input(9);\r\nomap_cfg_reg(W4_USB_HIGHZ);\r\n}\r\nohci_writel(ohci, rh, &ohci->regs->roothub.a);\r\nohci->flags &= ~OHCI_QUIRK_HUB_POWER;\r\n} else if (machine_is_nokia770()) {\r\nohci_to_hcd(ohci)->power_budget = 0;\r\n}\r\nomap_ohci_transceiver_power(1);\r\nreturn 0;\r\n}\r\nstatic int ohci_hcd_omap_probe(struct platform_device *pdev)\r\n{\r\nint retval, irq;\r\nstruct usb_hcd *hcd = 0;\r\nif (pdev->num_resources != 2) {\r\ndev_err(&pdev->dev, "invalid num_resources: %i\n",\r\npdev->num_resources);\r\nreturn -ENODEV;\r\n}\r\nif (pdev->resource[0].flags != IORESOURCE_MEM\r\n|| pdev->resource[1].flags != IORESOURCE_IRQ) {\r\ndev_err(&pdev->dev, "invalid resource type\n");\r\nreturn -ENODEV;\r\n}\r\nusb_host_ck = clk_get(&pdev->dev, "usb_hhc_ck");\r\nif (IS_ERR(usb_host_ck))\r\nreturn PTR_ERR(usb_host_ck);\r\nif (!cpu_is_omap15xx())\r\nusb_dc_ck = clk_get(&pdev->dev, "usb_dc_ck");\r\nelse\r\nusb_dc_ck = clk_get(&pdev->dev, "lb_ck");\r\nif (IS_ERR(usb_dc_ck)) {\r\nclk_put(usb_host_ck);\r\nreturn PTR_ERR(usb_dc_ck);\r\n}\r\nhcd = usb_create_hcd(&ohci_omap_hc_driver, &pdev->dev,\r\ndev_name(&pdev->dev));\r\nif (!hcd) {\r\nretval = -ENOMEM;\r\ngoto err0;\r\n}\r\nhcd->rsrc_start = pdev->resource[0].start;\r\nhcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;\r\nif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\r\ndev_dbg(&pdev->dev, "request_mem_region failed\n");\r\nretval = -EBUSY;\r\ngoto err1;\r\n}\r\nhcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\r\nif (!hcd->regs) {\r\ndev_err(&pdev->dev, "can't ioremap OHCI HCD\n");\r\nretval = -ENOMEM;\r\ngoto err2;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\nretval = -ENXIO;\r\ngoto err3;\r\n}\r\nretval = usb_add_hcd(hcd, irq, 0);\r\nif (retval)\r\ngoto err3;\r\ndevice_wakeup_enable(hcd->self.controller);\r\nreturn 0;\r\nerr3:\r\niounmap(hcd->regs);\r\nerr2:\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nerr1:\r\nusb_put_hcd(hcd);\r\nerr0:\r\nclk_put(usb_dc_ck);\r\nclk_put(usb_host_ck);\r\nreturn retval;\r\n}\r\nstatic int ohci_hcd_omap_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\ndev_dbg(hcd->self.controller, "stopping USB Controller\n");\r\nusb_remove_hcd(hcd);\r\nomap_ohci_clock_power(0);\r\nif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\r\n(void) otg_set_host(hcd->usb_phy->otg, 0);\r\nusb_put_phy(hcd->usb_phy);\r\n}\r\nif (machine_is_omap_osk())\r\ngpio_free(9);\r\niounmap(hcd->regs);\r\nrelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\r\nusb_put_hcd(hcd);\r\nclk_put(usb_dc_ck);\r\nclk_put(usb_host_ck);\r\nreturn 0;\r\n}\r\nstatic int ohci_omap_suspend(struct platform_device *pdev, pm_message_t message)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(pdev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nbool do_wakeup = device_may_wakeup(&pdev->dev);\r\nint ret;\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nret = ohci_suspend(hcd, do_wakeup);\r\nif (ret)\r\nreturn ret;\r\nomap_ohci_clock_power(0);\r\nreturn ret;\r\n}\r\nstatic int ohci_omap_resume(struct platform_device *dev)\r\n{\r\nstruct usb_hcd *hcd = platform_get_drvdata(dev);\r\nstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\r\nif (time_before(jiffies, ohci->next_statechange))\r\nmsleep(5);\r\nohci->next_statechange = jiffies;\r\nomap_ohci_clock_power(1);\r\nohci_resume(hcd, false);\r\nreturn 0;\r\n}\r\nstatic int __init ohci_omap_init(void)\r\n{\r\nif (usb_disabled())\r\nreturn -ENODEV;\r\npr_info("%s: " DRIVER_DESC "\n", hcd_name);\r\nohci_init_driver(&ohci_omap_hc_driver, &omap_overrides);\r\nreturn platform_driver_register(&ohci_hcd_omap_driver);\r\n}\r\nstatic void __exit ohci_omap_cleanup(void)\r\n{\r\nplatform_driver_unregister(&ohci_hcd_omap_driver);\r\n}
