static void mtk_mdp_clock_on(struct mtk_mdp_dev *mdp)\r\n{\r\nstruct device *dev = &mdp->pdev->dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mdp->comp); i++)\r\nmtk_mdp_comp_clock_on(dev, mdp->comp[i]);\r\n}\r\nstatic void mtk_mdp_clock_off(struct mtk_mdp_dev *mdp)\r\n{\r\nstruct device *dev = &mdp->pdev->dev;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mdp->comp); i++)\r\nmtk_mdp_comp_clock_off(dev, mdp->comp[i]);\r\n}\r\nstatic void mtk_mdp_wdt_worker(struct work_struct *work)\r\n{\r\nstruct mtk_mdp_dev *mdp =\r\ncontainer_of(work, struct mtk_mdp_dev, wdt_work);\r\nstruct mtk_mdp_ctx *ctx;\r\nmtk_mdp_err("Watchdog timeout");\r\nlist_for_each_entry(ctx, &mdp->ctx_list, list) {\r\nmtk_mdp_dbg(0, "[%d] Change as state error", ctx->id);\r\nmtk_mdp_ctx_state_lock_set(ctx, MTK_MDP_CTX_ERROR);\r\n}\r\n}\r\nstatic void mtk_mdp_reset_handler(void *priv)\r\n{\r\nstruct mtk_mdp_dev *mdp = priv;\r\nqueue_work(mdp->wdt_wq, &mdp->wdt_work);\r\n}\r\nstatic int mtk_mdp_probe(struct platform_device *pdev)\r\n{\r\nstruct mtk_mdp_dev *mdp;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node;\r\nint i, ret = 0;\r\nmdp = devm_kzalloc(dev, sizeof(*mdp), GFP_KERNEL);\r\nif (!mdp)\r\nreturn -ENOMEM;\r\nmdp->id = pdev->id;\r\nmdp->pdev = pdev;\r\nINIT_LIST_HEAD(&mdp->ctx_list);\r\nmutex_init(&mdp->lock);\r\nmutex_init(&mdp->vpulock);\r\nfor_each_child_of_node(dev->of_node, node) {\r\nconst struct of_device_id *of_id;\r\nenum mtk_mdp_comp_type comp_type;\r\nint comp_id;\r\nstruct mtk_mdp_comp *comp;\r\nof_id = of_match_node(mtk_mdp_comp_dt_ids, node);\r\nif (!of_id)\r\ncontinue;\r\nif (!of_device_is_available(node)) {\r\ndev_err(dev, "Skipping disabled component %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\ncomp_type = (enum mtk_mdp_comp_type)of_id->data;\r\ncomp_id = mtk_mdp_comp_get_id(dev, node, comp_type);\r\nif (comp_id < 0) {\r\ndev_warn(dev, "Skipping unknown component %s\n",\r\nnode->full_name);\r\ncontinue;\r\n}\r\ncomp = devm_kzalloc(dev, sizeof(*comp), GFP_KERNEL);\r\nif (!comp) {\r\nret = -ENOMEM;\r\ngoto err_comp;\r\n}\r\nmdp->comp[comp_id] = comp;\r\nret = mtk_mdp_comp_init(dev, node, comp, comp_id);\r\nif (ret)\r\ngoto err_comp;\r\n}\r\nmdp->job_wq = create_singlethread_workqueue(MTK_MDP_MODULE_NAME);\r\nif (!mdp->job_wq) {\r\ndev_err(&pdev->dev, "unable to alloc job workqueue\n");\r\nret = -ENOMEM;\r\ngoto err_alloc_job_wq;\r\n}\r\nmdp->wdt_wq = create_singlethread_workqueue("mdp_wdt_wq");\r\nif (!mdp->wdt_wq) {\r\ndev_err(&pdev->dev, "unable to alloc wdt workqueue\n");\r\nret = -ENOMEM;\r\ngoto err_alloc_wdt_wq;\r\n}\r\nINIT_WORK(&mdp->wdt_work, mtk_mdp_wdt_worker);\r\nret = v4l2_device_register(dev, &mdp->v4l2_dev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register v4l2 device\n");\r\nret = -EINVAL;\r\ngoto err_dev_register;\r\n}\r\nret = mtk_mdp_register_m2m_device(mdp);\r\nif (ret) {\r\nv4l2_err(&mdp->v4l2_dev, "Failed to init mem2mem device\n");\r\ngoto err_m2m_register;\r\n}\r\nmdp->vpu_dev = vpu_get_plat_device(pdev);\r\nvpu_wdt_reg_handler(mdp->vpu_dev, mtk_mdp_reset_handler, mdp,\r\nVPU_RST_MDP);\r\nplatform_set_drvdata(pdev, mdp);\r\nvb2_dma_contig_set_max_seg_size(&pdev->dev, DMA_BIT_MASK(32));\r\npm_runtime_enable(dev);\r\ndev_dbg(dev, "mdp-%d registered successfully\n", mdp->id);\r\nreturn 0;\r\nerr_m2m_register:\r\nv4l2_device_unregister(&mdp->v4l2_dev);\r\nerr_dev_register:\r\ndestroy_workqueue(mdp->wdt_wq);\r\nerr_alloc_wdt_wq:\r\ndestroy_workqueue(mdp->job_wq);\r\nerr_alloc_job_wq:\r\nerr_comp:\r\nfor (i = 0; i < ARRAY_SIZE(mdp->comp); i++)\r\nmtk_mdp_comp_deinit(dev, mdp->comp[i]);\r\ndev_dbg(dev, "err %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int mtk_mdp_remove(struct platform_device *pdev)\r\n{\r\nstruct mtk_mdp_dev *mdp = platform_get_drvdata(pdev);\r\nint i;\r\npm_runtime_disable(&pdev->dev);\r\nvb2_dma_contig_clear_max_seg_size(&pdev->dev);\r\nmtk_mdp_unregister_m2m_device(mdp);\r\nv4l2_device_unregister(&mdp->v4l2_dev);\r\nflush_workqueue(mdp->job_wq);\r\ndestroy_workqueue(mdp->job_wq);\r\nfor (i = 0; i < ARRAY_SIZE(mdp->comp); i++)\r\nmtk_mdp_comp_deinit(&pdev->dev, mdp->comp[i]);\r\ndev_dbg(&pdev->dev, "%s driver unloaded\n", pdev->name);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mtk_mdp_pm_suspend(struct device *dev)\r\n{\r\nstruct mtk_mdp_dev *mdp = dev_get_drvdata(dev);\r\nmtk_mdp_clock_off(mdp);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mtk_mdp_pm_resume(struct device *dev)\r\n{\r\nstruct mtk_mdp_dev *mdp = dev_get_drvdata(dev);\r\nmtk_mdp_clock_on(mdp);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused mtk_mdp_suspend(struct device *dev)\r\n{\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nreturn mtk_mdp_pm_suspend(dev);\r\n}\r\nstatic int __maybe_unused mtk_mdp_resume(struct device *dev)\r\n{\r\nif (pm_runtime_suspended(dev))\r\nreturn 0;\r\nreturn mtk_mdp_pm_resume(dev);\r\n}
