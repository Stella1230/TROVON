static void __init at91_wakeup_status(struct platform_device *pdev)\r\n{\r\nstruct shdwc *shdw = platform_get_drvdata(pdev);\r\nu32 reg;\r\nchar *reason = "unknown";\r\nreg = readl(shdw->at91_shdwc_base + AT91_SHDW_SR);\r\ndev_dbg(&pdev->dev, "%s: status = %#x\n", __func__, reg);\r\nif (!reg)\r\nreturn;\r\nif (SHDW_WK_PIN(reg, shdw->cfg))\r\nreason = "WKUP pin";\r\nelse if (SHDW_RTCWK(reg, shdw->cfg))\r\nreason = "RTC";\r\npr_info("AT91: Wake-Up source: %s\n", reason);\r\n}\r\nstatic void at91_poweroff(void)\r\n{\r\nwritel(AT91_SHDW_KEY | AT91_SHDW_SHDW,\r\nat91_shdwc->at91_shdwc_base + AT91_SHDW_CR);\r\n}\r\nstatic void at91_lpddr_poweroff(void)\r\n{\r\nasm volatile(\r\n".balign 32\n\t"\r\n" ldr r6, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"\r\n" str %1, [%0, #" __stringify(AT91_DDRSDRC_LPR) "]\n\t"\r\n" str %3, [%2, #" __stringify(AT91_SHDW_CR) "]\n\t"\r\n" b .\n\t"\r\n:\r\n: "r" (mpddrc_base),\r\n"r" cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),\r\n"r" (at91_shdwc->at91_shdwc_base),\r\n"r" cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)\r\n: "r0");\r\n}\r\nstatic u32 at91_shdwc_debouncer_value(struct platform_device *pdev,\r\nu32 in_period_us)\r\n{\r\nint i;\r\nint max_idx = ARRAY_SIZE(sdwc_dbc_period) - 1;\r\nunsigned long long period_us;\r\nunsigned long long max_period_us = DBC_PERIOD_US(sdwc_dbc_period[max_idx]);\r\nif (in_period_us > max_period_us) {\r\ndev_warn(&pdev->dev,\r\n"debouncer period %u too big, reduced to %llu us\n",\r\nin_period_us, max_period_us);\r\nreturn max_idx;\r\n}\r\nfor (i = max_idx - 1; i > 0; i--) {\r\nperiod_us = DBC_PERIOD_US(sdwc_dbc_period[i]);\r\ndev_dbg(&pdev->dev, "%s: ref[%d] = %llu\n",\r\n__func__, i, period_us);\r\nif (in_period_us > period_us)\r\nbreak;\r\n}\r\nreturn i + 1;\r\n}\r\nstatic u32 at91_shdwc_get_wakeup_input(struct platform_device *pdev,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *cnp;\r\nu32 wk_input_mask;\r\nu32 wuir = 0;\r\nu32 wk_input;\r\nfor_each_child_of_node(np, cnp) {\r\nif (of_property_read_u32(cnp, "reg", &wk_input)) {\r\ndev_warn(&pdev->dev, "reg property is missing for %s\n",\r\ncnp->full_name);\r\ncontinue;\r\n}\r\nwk_input_mask = 1 << wk_input;\r\nif (!(wk_input_mask & AT91_SHDW_WKUPEN_MASK)) {\r\ndev_warn(&pdev->dev,\r\n"wake-up input %d out of bounds ignore\n",\r\nwk_input);\r\ncontinue;\r\n}\r\nwuir |= wk_input_mask;\r\nif (of_property_read_bool(cnp, "atmel,wakeup-active-high"))\r\nwuir |= AT91_SHDW_WKUPT(wk_input);\r\ndev_dbg(&pdev->dev, "%s: (child %d) wuir = %#x\n",\r\n__func__, wk_input, wuir);\r\n}\r\nreturn wuir;\r\n}\r\nstatic void at91_shdwc_dt_configure(struct platform_device *pdev)\r\n{\r\nstruct shdwc *shdw = platform_get_drvdata(pdev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nu32 mode = 0, tmp, input;\r\nif (!np) {\r\ndev_err(&pdev->dev, "device node not found\n");\r\nreturn;\r\n}\r\nif (!of_property_read_u32(np, "debounce-delay-us", &tmp))\r\nmode |= AT91_SHDW_WKUPDBC(at91_shdwc_debouncer_value(pdev, tmp));\r\nif (of_property_read_bool(np, "atmel,wakeup-rtc-timer"))\r\nmode |= SHDW_RTCWKEN(shdw->cfg);\r\ndev_dbg(&pdev->dev, "%s: mode = %#x\n", __func__, mode);\r\nwritel(mode, shdw->at91_shdwc_base + AT91_SHDW_MR);\r\ninput = at91_shdwc_get_wakeup_input(pdev, np);\r\nwritel(input, shdw->at91_shdwc_base + AT91_SHDW_WUIR);\r\n}\r\nstatic int __init at91_shdwc_probe(struct platform_device *pdev)\r\n{\r\nstruct resource *res;\r\nconst struct of_device_id *match;\r\nstruct device_node *np;\r\nu32 ddr_type;\r\nint ret;\r\nif (!pdev->dev.of_node)\r\nreturn -ENODEV;\r\nat91_shdwc = devm_kzalloc(&pdev->dev, sizeof(*at91_shdwc), GFP_KERNEL);\r\nif (!at91_shdwc)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, at91_shdwc);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nat91_shdwc->at91_shdwc_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(at91_shdwc->at91_shdwc_base)) {\r\ndev_err(&pdev->dev, "Could not map reset controller address\n");\r\nreturn PTR_ERR(at91_shdwc->at91_shdwc_base);\r\n}\r\nmatch = of_match_node(at91_shdwc_of_match, pdev->dev.of_node);\r\nat91_shdwc->cfg = (struct shdwc_config *)(match->data);\r\nsclk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(sclk))\r\nreturn PTR_ERR(sclk);\r\nret = clk_prepare_enable(sclk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not enable slow clock\n");\r\nreturn ret;\r\n}\r\nat91_wakeup_status(pdev);\r\nat91_shdwc_dt_configure(pdev);\r\npm_power_off = at91_poweroff;\r\nnp = of_find_compatible_node(NULL, NULL, "atmel,sama5d3-ddramc");\r\nif (!np)\r\nreturn 0;\r\nmpddrc_base = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!mpddrc_base)\r\nreturn 0;\r\nddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) & AT91_DDRSDRC_MD;\r\nif ((ddr_type == AT91_DDRSDRC_MD_LPDDR2) ||\r\n(ddr_type == AT91_DDRSDRC_MD_LPDDR3))\r\npm_power_off = at91_lpddr_poweroff;\r\nelse\r\niounmap(mpddrc_base);\r\nreturn 0;\r\n}\r\nstatic int __exit at91_shdwc_remove(struct platform_device *pdev)\r\n{\r\nstruct shdwc *shdw = platform_get_drvdata(pdev);\r\nif (pm_power_off == at91_poweroff ||\r\npm_power_off == at91_lpddr_poweroff)\r\npm_power_off = NULL;\r\nwritel(0, shdw->at91_shdwc_base + AT91_SHDW_MR);\r\nwritel(0, shdw->at91_shdwc_base + AT91_SHDW_WUIR);\r\nclk_disable_unprepare(sclk);\r\nreturn 0;\r\n}
