static int _softing_fct_cmd(struct softing *card, int16_t cmd, uint16_t vector,\r\nconst char *msg)\r\n{\r\nint ret;\r\nunsigned long stamp;\r\niowrite16(cmd, &card->dpram[DPRAM_FCT_PARAM]);\r\niowrite8(vector >> 8, &card->dpram[DPRAM_FCT_HOST + 1]);\r\niowrite8(vector, &card->dpram[DPRAM_FCT_HOST]);\r\nwmb();\r\nstamp = jiffies + 1 * HZ;\r\ndo {\r\nret = ioread8(&card->dpram[DPRAM_FCT_HOST]) +\r\n(ioread8(&card->dpram[DPRAM_FCT_HOST + 1]) << 8);\r\nrmb();\r\nif (ret == RES_OK)\r\nreturn ioread16(&card->dpram[DPRAM_FCT_RESULT]);\r\nif ((ret != vector) || time_after(jiffies, stamp))\r\nbreak;\r\nusleep_range(500, 10000);\r\n} while (1);\r\nret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;\r\ndev_alert(&card->pdev->dev, "firmware %s failed (%i)\n", msg, ret);\r\nreturn ret;\r\n}\r\nstatic int softing_fct_cmd(struct softing *card, int16_t cmd, const char *msg)\r\n{\r\nint ret;\r\nret = _softing_fct_cmd(card, cmd, 0, msg);\r\nif (ret > 0) {\r\ndev_alert(&card->pdev->dev, "%s returned %u\n", msg, ret);\r\nret = -EIO;\r\n}\r\nreturn ret;\r\n}\r\nint softing_bootloader_command(struct softing *card, int16_t cmd,\r\nconst char *msg)\r\n{\r\nint ret;\r\nunsigned long stamp;\r\niowrite16(RES_NONE, &card->dpram[DPRAM_RECEIPT]);\r\niowrite16(cmd, &card->dpram[DPRAM_COMMAND]);\r\nwmb();\r\nstamp = jiffies + 3 * HZ;\r\ndo {\r\nret = ioread16(&card->dpram[DPRAM_RECEIPT]);\r\nrmb();\r\nif (ret == RES_OK)\r\nreturn 0;\r\nif (time_after(jiffies, stamp))\r\nbreak;\r\nusleep_range(500, 10000);\r\n} while (!signal_pending(current));\r\nret = (ret == RES_NONE) ? -ETIMEDOUT : -ECANCELED;\r\ndev_alert(&card->pdev->dev, "bootloader %s failed (%i)\n", msg, ret);\r\nreturn ret;\r\n}\r\nstatic int fw_parse(const uint8_t **pmem, uint16_t *ptype, uint32_t *paddr,\r\nuint16_t *plen, const uint8_t **pdat)\r\n{\r\nuint16_t checksum[2];\r\nconst uint8_t *mem;\r\nconst uint8_t *end;\r\nmem = *pmem;\r\n*ptype = le16_to_cpup((void *)&mem[0]);\r\n*paddr = le32_to_cpup((void *)&mem[2]);\r\n*plen = le16_to_cpup((void *)&mem[6]);\r\n*pdat = &mem[8];\r\nend = &mem[8 + *plen];\r\nchecksum[0] = le16_to_cpup((void *)end);\r\nfor (checksum[1] = 0; mem < end; ++mem)\r\nchecksum[1] += *mem;\r\nif (checksum[0] != checksum[1])\r\nreturn -EINVAL;\r\n*pmem += 10 + *plen;\r\nreturn 0;\r\n}\r\nint softing_load_fw(const char *file, struct softing *card,\r\n__iomem uint8_t *dpram, unsigned int size, int offset)\r\n{\r\nconst struct firmware *fw;\r\nint ret;\r\nconst uint8_t *mem, *end, *dat;\r\nuint16_t type, len;\r\nuint32_t addr;\r\nuint8_t *buf = NULL, *new_buf;\r\nint buflen = 0;\r\nint8_t type_end = 0;\r\nret = request_firmware(&fw, file, &card->pdev->dev);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_dbg(&card->pdev->dev, "%s, firmware(%s) got %u bytes"\r\n", offset %c0x%04x\n",\r\ncard->pdat->name, file, (unsigned int)fw->size,\r\n(offset >= 0) ? '+' : '-', (unsigned int)abs(offset));\r\nmem = fw->data;\r\nend = &mem[fw->size];\r\nret = fw_parse(&mem, &type, &addr, &len, &dat);\r\nif (ret < 0)\r\ngoto failed;\r\nif (type != 0xffff)\r\ngoto failed;\r\nif (strncmp("Structured Binary Format, Softing GmbH" , dat, len)) {\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nwhile (mem < end) {\r\nret = fw_parse(&mem, &type, &addr, &len, &dat);\r\nif (ret < 0)\r\ngoto failed;\r\nif (type == 3) {\r\ncontinue;\r\n} else if (type == 1) {\r\ntype_end = 1;\r\nbreak;\r\n} else if (type != 0) {\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nif ((addr + len + offset) > size)\r\ngoto failed;\r\nmemcpy_toio(&dpram[addr + offset], dat, len);\r\nmb();\r\nif (len > buflen) {\r\nbuflen = (len + (1024-1)) & ~(1024-1);\r\nnew_buf = krealloc(buf, buflen, GFP_KERNEL);\r\nif (!new_buf) {\r\nret = -ENOMEM;\r\ngoto failed;\r\n}\r\nbuf = new_buf;\r\n}\r\nmemcpy_fromio(buf, &dpram[addr + offset], len);\r\nif (memcmp(buf, dat, len)) {\r\ndev_alert(&card->pdev->dev, "DPRAM readback failed\n");\r\nret = -EIO;\r\ngoto failed;\r\n}\r\n}\r\nif (!type_end)\r\ngoto failed;\r\nret = 0;\r\nfailed:\r\nkfree(buf);\r\nrelease_firmware(fw);\r\nif (ret < 0)\r\ndev_info(&card->pdev->dev, "firmware %s failed\n", file);\r\nreturn ret;\r\n}\r\nint softing_load_app_fw(const char *file, struct softing *card)\r\n{\r\nconst struct firmware *fw;\r\nconst uint8_t *mem, *end, *dat;\r\nint ret, j;\r\nuint16_t type, len;\r\nuint32_t addr, start_addr = 0;\r\nunsigned int sum, rx_sum;\r\nint8_t type_end = 0, type_entrypoint = 0;\r\nret = request_firmware(&fw, file, &card->pdev->dev);\r\nif (ret) {\r\ndev_alert(&card->pdev->dev, "request_firmware(%s) got %i\n",\r\nfile, ret);\r\nreturn ret;\r\n}\r\ndev_dbg(&card->pdev->dev, "firmware(%s) got %lu bytes\n",\r\nfile, (unsigned long)fw->size);\r\nmem = fw->data;\r\nend = &mem[fw->size];\r\nret = fw_parse(&mem, &type, &addr, &len, &dat);\r\nif (ret)\r\ngoto failed;\r\nret = -EINVAL;\r\nif (type != 0xffff) {\r\ndev_alert(&card->pdev->dev, "firmware starts with type 0x%x\n",\r\ntype);\r\ngoto failed;\r\n}\r\nif (strncmp("Structured Binary Format, Softing GmbH", dat, len)) {\r\ndev_alert(&card->pdev->dev, "firmware string '%.*s' fault\n",\r\nlen, dat);\r\ngoto failed;\r\n}\r\nwhile (mem < end) {\r\nret = fw_parse(&mem, &type, &addr, &len, &dat);\r\nif (ret)\r\ngoto failed;\r\nif (type == 3) {\r\nstart_addr = addr;\r\ntype_entrypoint = 1;\r\ncontinue;\r\n} else if (type == 1) {\r\ntype_end = 1;\r\nbreak;\r\n} else if (type != 0) {\r\ndev_alert(&card->pdev->dev,\r\n"unknown record type 0x%04x\n", type);\r\nret = -EINVAL;\r\ngoto failed;\r\n}\r\nfor (sum = 0, j = 0; j < len; ++j)\r\nsum += dat[j];\r\nsum &= 0xffff;\r\nmemcpy_toio(&card->dpram[card->pdat->app.offs], dat, len);\r\niowrite32(card->pdat->app.offs + card->pdat->app.addr,\r\n&card->dpram[DPRAM_COMMAND + 2]);\r\niowrite32(addr, &card->dpram[DPRAM_COMMAND + 6]);\r\niowrite16(len, &card->dpram[DPRAM_COMMAND + 10]);\r\niowrite8(1, &card->dpram[DPRAM_COMMAND + 12]);\r\nret = softing_bootloader_command(card, 1, "loading app.");\r\nif (ret < 0)\r\ngoto failed;\r\nrx_sum = ioread16(&card->dpram[DPRAM_RECEIPT + 2]);\r\nif (rx_sum != sum) {\r\ndev_alert(&card->pdev->dev, "SRAM seems to be damaged"\r\n", wanted 0x%04x, got 0x%04x\n", sum, rx_sum);\r\nret = -EIO;\r\ngoto failed;\r\n}\r\n}\r\nif (!type_end || !type_entrypoint)\r\ngoto failed;\r\niowrite32(start_addr, &card->dpram[DPRAM_COMMAND + 2]);\r\niowrite8(1, &card->dpram[DPRAM_COMMAND + 6]);\r\nret = softing_bootloader_command(card, 3, "start app.");\r\nif (ret < 0)\r\ngoto failed;\r\nret = 0;\r\nfailed:\r\nrelease_firmware(fw);\r\nif (ret < 0)\r\ndev_info(&card->pdev->dev, "firmware %s failed\n", file);\r\nreturn ret;\r\n}\r\nstatic int softing_reset_chip(struct softing *card)\r\n{\r\nint ret;\r\ndo {\r\niowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO]);\r\niowrite8(0, &card->dpram[DPRAM_RESET_RX_FIFO+1]);\r\niowrite8(1, &card->dpram[DPRAM_RESET]);\r\niowrite8(0, &card->dpram[DPRAM_RESET+1]);\r\nret = softing_fct_cmd(card, 0, "reset_can");\r\nif (!ret)\r\nbreak;\r\nif (signal_pending(current))\r\nbreak;\r\n} while (1);\r\ncard->tx.pending = 0;\r\nreturn ret;\r\n}\r\nint softing_chip_poweron(struct softing *card)\r\n{\r\nint ret;\r\nret = _softing_fct_cmd(card, 99, 0x55, "sync-a");\r\nif (ret < 0)\r\ngoto failed;\r\nret = _softing_fct_cmd(card, 99, 0xaa, "sync-b");\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_reset_chip(card);\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_fct_cmd(card, 43, "get_serial_number");\r\nif (ret < 0)\r\ngoto failed;\r\ncard->id.serial = ioread32(&card->dpram[DPRAM_FCT_PARAM]);\r\nret = softing_fct_cmd(card, 12, "get_version");\r\nif (ret < 0)\r\ngoto failed;\r\ncard->id.fw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 2]);\r\ncard->id.hw_version = ioread16(&card->dpram[DPRAM_FCT_PARAM + 4]);\r\ncard->id.license = ioread16(&card->dpram[DPRAM_FCT_PARAM + 6]);\r\ncard->id.chip[0] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 8]);\r\ncard->id.chip[1] = ioread16(&card->dpram[DPRAM_FCT_PARAM + 10]);\r\nreturn 0;\r\nfailed:\r\nreturn ret;\r\n}\r\nstatic void softing_initialize_timestamp(struct softing *card)\r\n{\r\nuint64_t ovf;\r\ncard->ts_ref = ktime_get();\r\novf = 0x100000000ULL * 16;\r\ndo_div(ovf, card->pdat->freq ?: 16);\r\ncard->ts_overflow = ktime_add_us(0, ovf);\r\n}\r\nktime_t softing_raw2ktime(struct softing *card, u32 raw)\r\n{\r\nuint64_t rawl;\r\nktime_t now, real_offset;\r\nktime_t target;\r\nktime_t tmp;\r\nnow = ktime_get();\r\nreal_offset = ktime_sub(ktime_get_real(), now);\r\nrawl = raw * 16;\r\ndo_div(rawl, card->pdat->freq ?: 16);\r\ntarget = ktime_add_us(card->ts_ref, rawl);\r\ntmp = ktime_add(target, card->ts_overflow);\r\nwhile (unlikely(ktime_to_ns(tmp) > ktime_to_ns(now))) {\r\ncard->ts_ref = ktime_add(card->ts_ref, card->ts_overflow);\r\ntarget = tmp;\r\ntmp = ktime_add(target, card->ts_overflow);\r\n}\r\nreturn ktime_add(target, real_offset);\r\n}\r\nstatic inline int softing_error_reporting(struct net_device *netdev)\r\n{\r\nstruct softing_priv *priv = netdev_priv(netdev);\r\nreturn (priv->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING)\r\n? 1 : 0;\r\n}\r\nint softing_startstop(struct net_device *dev, int up)\r\n{\r\nint ret;\r\nstruct softing *card;\r\nstruct softing_priv *priv;\r\nstruct net_device *netdev;\r\nint bus_bitmask_start;\r\nint j, error_reporting;\r\nstruct can_frame msg;\r\nconst struct can_bittiming *bt;\r\npriv = netdev_priv(dev);\r\ncard = priv->card;\r\nif (!card->fw.up)\r\nreturn -EIO;\r\nret = mutex_lock_interruptible(&card->fw.lock);\r\nif (ret)\r\nreturn ret;\r\nbus_bitmask_start = 0;\r\nif (dev && up)\r\nbus_bitmask_start |= (1 << priv->index);\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nnetdev = card->net[j];\r\nif (!netdev)\r\ncontinue;\r\npriv = netdev_priv(netdev);\r\nif (dev != netdev)\r\nnetif_stop_queue(netdev);\r\nif (netif_running(netdev)) {\r\nif (dev != netdev)\r\nbus_bitmask_start |= (1 << j);\r\npriv->tx.pending = 0;\r\npriv->tx.echo_put = 0;\r\npriv->tx.echo_get = 0;\r\nclose_candev(netdev);\r\n}\r\npriv->can.state = CAN_STATE_STOPPED;\r\n}\r\ncard->tx.pending = 0;\r\nsofting_enable_irq(card, 0);\r\nret = softing_reset_chip(card);\r\nif (ret)\r\ngoto failed;\r\nif (!bus_bitmask_start)\r\ngoto card_done;\r\nif ((bus_bitmask_start & 1) && (bus_bitmask_start & 2)\r\n&& (softing_error_reporting(card->net[0])\r\n!= softing_error_reporting(card->net[1]))) {\r\ndev_alert(&card->pdev->dev,\r\n"err_reporting flag differs for busses\n");\r\ngoto invalid;\r\n}\r\nerror_reporting = 0;\r\nif (bus_bitmask_start & 1) {\r\nnetdev = card->net[0];\r\npriv = netdev_priv(netdev);\r\nerror_reporting += softing_error_reporting(netdev);\r\nbt = &priv->can.bittiming;\r\niowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\niowrite16(bt->phase_seg1 + bt->prop_seg,\r\n&card->dpram[DPRAM_FCT_PARAM + 6]);\r\niowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);\r\niowrite16((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,\r\n&card->dpram[DPRAM_FCT_PARAM + 10]);\r\nret = softing_fct_cmd(card, 1, "initialize_chip[0]");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\nret = softing_fct_cmd(card, 3, "set_mode[0]");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\niowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);\r\niowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);\r\niowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);\r\niowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);\r\nret = softing_fct_cmd(card, 7, "set_filter[0]");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\nret = softing_fct_cmd(card, 5, "set_output[0]");\r\nif (ret < 0)\r\ngoto failed;\r\n}\r\nif (bus_bitmask_start & 2) {\r\nnetdev = card->net[1];\r\npriv = netdev_priv(netdev);\r\nerror_reporting += softing_error_reporting(netdev);\r\nbt = &priv->can.bittiming;\r\niowrite16(bt->brp, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(bt->sjw, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\niowrite16(bt->phase_seg1 + bt->prop_seg,\r\n&card->dpram[DPRAM_FCT_PARAM + 6]);\r\niowrite16(bt->phase_seg2, &card->dpram[DPRAM_FCT_PARAM + 8]);\r\niowrite16((priv->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES) ? 1 : 0,\r\n&card->dpram[DPRAM_FCT_PARAM + 10]);\r\nret = softing_fct_cmd(card, 2, "initialize_chip[1]");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(0, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\nret = softing_fct_cmd(card, 4, "set_mode[1]");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(0x07ff, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\niowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 6]);\r\niowrite16(0xffff, &card->dpram[DPRAM_FCT_PARAM + 8]);\r\niowrite16(0x0000, &card->dpram[DPRAM_FCT_PARAM + 10]);\r\niowrite16(0x1fff, &card->dpram[DPRAM_FCT_PARAM + 12]);\r\nret = softing_fct_cmd(card, 8, "set_filter[1]");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite16(priv->output, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\nret = softing_fct_cmd(card, 6, "set_output[1]");\r\nif (ret < 0)\r\ngoto failed;\r\n}\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 2]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 4]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 6]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 8]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 10]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 12]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 14]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 16]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 18]);\r\niowrite16(1, &card->dpram[DPRAM_FCT_PARAM + 20]);\r\nret = softing_fct_cmd(card, 17, "initialize_interface");\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_fct_cmd(card, 36, "enable_fifo");\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_fct_cmd(card, 13, "fifo_tx_ack[0]");\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_fct_cmd(card, 14, "fifo_tx_ack[1]");\r\nif (ret < 0)\r\ngoto failed;\r\nret = softing_fct_cmd(card, 11, "start_chip");\r\nif (ret < 0)\r\ngoto failed;\r\niowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE]);\r\niowrite8(0, &card->dpram[DPRAM_INFO_BUSSTATE2]);\r\nif (card->pdat->generation < 2) {\r\niowrite8(0, &card->dpram[DPRAM_V2_IRQ_TOHOST]);\r\nwmb();\r\n}\r\nsofting_initialize_timestamp(card);\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.can_id = CAN_ERR_FLAG | CAN_ERR_RESTARTED;\r\nmsg.can_dlc = CAN_ERR_DLC;\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nif (!(bus_bitmask_start & (1 << j)))\r\ncontinue;\r\nnetdev = card->net[j];\r\nif (!netdev)\r\ncontinue;\r\npriv = netdev_priv(netdev);\r\npriv->can.state = CAN_STATE_ERROR_ACTIVE;\r\nopen_candev(netdev);\r\nif (dev != netdev) {\r\nsofting_netdev_rx(netdev, &msg, 0);\r\n++priv->can.can_stats.restarts;\r\n}\r\nnetif_wake_queue(netdev);\r\n}\r\nret = softing_enable_irq(card, 1);\r\nif (ret)\r\ngoto failed;\r\ncard_done:\r\nmutex_unlock(&card->fw.lock);\r\nreturn 0;\r\ninvalid:\r\nret = -EINVAL;\r\nfailed:\r\nsofting_enable_irq(card, 0);\r\nsofting_reset_chip(card);\r\nmutex_unlock(&card->fw.lock);\r\nfor (j = 0; j < ARRAY_SIZE(card->net); ++j) {\r\nnetdev = card->net[j];\r\nif (!netdev)\r\ncontinue;\r\ndev_close(netdev);\r\n}\r\nreturn ret;\r\n}\r\nint softing_default_output(struct net_device *netdev)\r\n{\r\nstruct softing_priv *priv = netdev_priv(netdev);\r\nstruct softing *card = priv->card;\r\nswitch (priv->chip) {\r\ncase 1000:\r\nreturn (card->pdat->generation < 2) ? 0xfb : 0xfa;\r\ncase 5:\r\nreturn 0x60;\r\ndefault:\r\nreturn 0x40;\r\n}\r\n}
