int mthca_reset(struct mthca_dev *mdev)\r\n{\r\nint i;\r\nint err = 0;\r\nu32 *hca_header = NULL;\r\nu32 *bridge_header = NULL;\r\nstruct pci_dev *bridge = NULL;\r\nint bridge_pcix_cap = 0;\r\nint hca_pcie_cap = 0;\r\nint hca_pcix_cap = 0;\r\nu16 devctl;\r\nu16 linkctl;\r\n#define MTHCA_RESET_OFFSET 0xf0010\r\n#define MTHCA_RESET_VALUE swab32(1)\r\nif (!(mdev->mthca_flags & MTHCA_FLAG_PCIE)) {\r\nwhile ((bridge = pci_get_device(mdev->pdev->vendor,\r\nmdev->pdev->device + 2,\r\nbridge)) != NULL) {\r\nif (bridge->hdr_type == PCI_HEADER_TYPE_BRIDGE &&\r\nbridge->subordinate == mdev->pdev->bus) {\r\nmthca_dbg(mdev, "Found bridge: %s\n",\r\npci_name(bridge));\r\nbreak;\r\n}\r\n}\r\nif (!bridge) {\r\nmthca_warn(mdev, "No bridge found for %s\n",\r\npci_name(mdev->pdev));\r\n}\r\n}\r\nhca_header = kmalloc(256, GFP_KERNEL);\r\nif (!hca_header) {\r\nerr = -ENOMEM;\r\ngoto put_dev;\r\n}\r\nfor (i = 0; i < 64; ++i) {\r\nif (i == 22 || i == 23)\r\ncontinue;\r\nif (pci_read_config_dword(mdev->pdev, i * 4, hca_header + i)) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't save HCA "\r\n"PCI header, aborting.\n");\r\ngoto free_hca;\r\n}\r\n}\r\nhca_pcix_cap = pci_find_capability(mdev->pdev, PCI_CAP_ID_PCIX);\r\nhca_pcie_cap = pci_pcie_cap(mdev->pdev);\r\nif (bridge) {\r\nbridge_header = kmalloc(256, GFP_KERNEL);\r\nif (!bridge_header) {\r\nerr = -ENOMEM;\r\ngoto free_hca;\r\n}\r\nfor (i = 0; i < 64; ++i) {\r\nif (i == 22 || i == 23)\r\ncontinue;\r\nif (pci_read_config_dword(bridge, i * 4, bridge_header + i)) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't save HCA bridge "\r\n"PCI header, aborting.\n");\r\ngoto free_bh;\r\n}\r\n}\r\nbridge_pcix_cap = pci_find_capability(bridge, PCI_CAP_ID_PCIX);\r\nif (!bridge_pcix_cap) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't locate HCA bridge "\r\n"PCI-X capability, aborting.\n");\r\ngoto free_bh;\r\n}\r\n}\r\n{\r\nvoid __iomem *reset = ioremap(pci_resource_start(mdev->pdev, 0) +\r\nMTHCA_RESET_OFFSET, 4);\r\nif (!reset) {\r\nerr = -ENOMEM;\r\nmthca_err(mdev, "Couldn't map HCA reset register, "\r\n"aborting.\n");\r\ngoto free_bh;\r\n}\r\nwritel(MTHCA_RESET_VALUE, reset);\r\niounmap(reset);\r\n}\r\nmsleep(1000);\r\n{\r\nu32 v;\r\nint c = 0;\r\nfor (c = 0; c < 100; ++c) {\r\nif (pci_read_config_dword(bridge ? bridge : mdev->pdev, 0, &v)) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't access HCA after reset, "\r\n"aborting.\n");\r\ngoto free_bh;\r\n}\r\nif (v != 0xffffffff)\r\ngoto good;\r\nmsleep(100);\r\n}\r\nerr = -ENODEV;\r\nmthca_err(mdev, "PCI device did not come back after reset, "\r\n"aborting.\n");\r\ngoto free_bh;\r\n}\r\ngood:\r\nif (bridge) {\r\nif (pci_write_config_dword(bridge, bridge_pcix_cap + 0x8,\r\nbridge_header[(bridge_pcix_cap + 0x8) / 4])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA bridge Upstream "\r\n"split transaction control, aborting.\n");\r\ngoto free_bh;\r\n}\r\nif (pci_write_config_dword(bridge, bridge_pcix_cap + 0xc,\r\nbridge_header[(bridge_pcix_cap + 0xc) / 4])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA bridge Downstream "\r\n"split transaction control, aborting.\n");\r\ngoto free_bh;\r\n}\r\nfor (i = 0; i < 16; ++i) {\r\nif (i * 4 == PCI_COMMAND)\r\ncontinue;\r\nif (pci_write_config_dword(bridge, i * 4, bridge_header[i])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA bridge reg %x, "\r\n"aborting.\n", i);\r\ngoto free_bh;\r\n}\r\n}\r\nif (pci_write_config_dword(bridge, PCI_COMMAND,\r\nbridge_header[PCI_COMMAND / 4])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA bridge COMMAND, "\r\n"aborting.\n");\r\ngoto free_bh;\r\n}\r\n}\r\nif (hca_pcix_cap) {\r\nif (pci_write_config_dword(mdev->pdev, hca_pcix_cap,\r\nhca_header[hca_pcix_cap / 4])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA PCI-X "\r\n"command register, aborting.\n");\r\ngoto free_bh;\r\n}\r\n}\r\nif (hca_pcie_cap) {\r\ndevctl = hca_header[(hca_pcie_cap + PCI_EXP_DEVCTL) / 4];\r\nif (pcie_capability_write_word(mdev->pdev, PCI_EXP_DEVCTL,\r\ndevctl)) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA PCI Express "\r\n"Device Control register, aborting.\n");\r\ngoto free_bh;\r\n}\r\nlinkctl = hca_header[(hca_pcie_cap + PCI_EXP_LNKCTL) / 4];\r\nif (pcie_capability_write_word(mdev->pdev, PCI_EXP_LNKCTL,\r\nlinkctl)) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA PCI Express "\r\n"Link control register, aborting.\n");\r\ngoto free_bh;\r\n}\r\n}\r\nfor (i = 0; i < 16; ++i) {\r\nif (i * 4 == PCI_COMMAND)\r\ncontinue;\r\nif (pci_write_config_dword(mdev->pdev, i * 4, hca_header[i])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA reg %x, "\r\n"aborting.\n", i);\r\ngoto free_bh;\r\n}\r\n}\r\nif (pci_write_config_dword(mdev->pdev, PCI_COMMAND,\r\nhca_header[PCI_COMMAND / 4])) {\r\nerr = -ENODEV;\r\nmthca_err(mdev, "Couldn't restore HCA COMMAND, "\r\n"aborting.\n");\r\n}\r\nfree_bh:\r\nkfree(bridge_header);\r\nfree_hca:\r\nkfree(hca_header);\r\nput_dev:\r\npci_dev_put(bridge);\r\nreturn err;\r\n}
