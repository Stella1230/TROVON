void jffs2_add_fd_to_list(struct jffs2_sb_info *c, struct jffs2_full_dirent *new, struct jffs2_full_dirent **list)\r\n{\r\nstruct jffs2_full_dirent **prev = list;\r\ndbg_dentlist("add dirent \"%s\", ino #%u\n", new->name, new->ino);\r\nwhile ((*prev) && (*prev)->nhash <= new->nhash) {\r\nif ((*prev)->nhash == new->nhash && !strcmp((*prev)->name, new->name)) {\r\nif (new->version < (*prev)->version) {\r\ndbg_dentlist("Eep! Marking new dirent node obsolete, old is \"%s\", ino #%u\n",\r\n(*prev)->name, (*prev)->ino);\r\njffs2_mark_node_obsolete(c, new->raw);\r\njffs2_free_full_dirent(new);\r\n} else {\r\ndbg_dentlist("marking old dirent \"%s\", ino #%u obsolete\n",\r\n(*prev)->name, (*prev)->ino);\r\nnew->next = (*prev)->next;\r\nif ((*prev)->raw)\r\njffs2_mark_node_obsolete(c, ((*prev)->raw));\r\njffs2_free_full_dirent(*prev);\r\n*prev = new;\r\n}\r\nreturn;\r\n}\r\nprev = &((*prev)->next);\r\n}\r\nnew->next = *prev;\r\n*prev = new;\r\n}\r\nuint32_t jffs2_truncate_fragtree(struct jffs2_sb_info *c, struct rb_root *list, uint32_t size)\r\n{\r\nstruct jffs2_node_frag *frag = jffs2_lookup_node_frag(list, size);\r\ndbg_fragtree("truncating fragtree to 0x%08x bytes\n", size);\r\nif (frag && frag->ofs != size) {\r\nif (frag->ofs+frag->size > size) {\r\nfrag->size = size - frag->ofs;\r\n}\r\nfrag = frag_next(frag);\r\n}\r\nwhile (frag && frag->ofs >= size) {\r\nstruct jffs2_node_frag *next = frag_next(frag);\r\nfrag_erase(frag, list);\r\njffs2_obsolete_node_frag(c, frag);\r\nfrag = next;\r\n}\r\nif (size == 0)\r\nreturn 0;\r\nfrag = frag_last(list);\r\nif (!frag)\r\nreturn 0;\r\nif (frag->ofs + frag->size < size)\r\nreturn frag->ofs + frag->size;\r\nif (frag->node && (frag->ofs & (PAGE_SIZE - 1)) == 0) {\r\ndbg_fragtree2("marking the last fragment 0x%08x-0x%08x REF_PRISTINE.\n",\r\nfrag->ofs, frag->ofs + frag->size);\r\nfrag->node->raw->flash_offset = ref_offset(frag->node->raw) | REF_PRISTINE;\r\n}\r\nreturn size;\r\n}\r\nstatic void jffs2_obsolete_node_frag(struct jffs2_sb_info *c,\r\nstruct jffs2_node_frag *this)\r\n{\r\nif (this->node) {\r\nthis->node->frags--;\r\nif (!this->node->frags) {\r\ndbg_fragtree2("marking old node @0x%08x (0x%04x-0x%04x) obsolete\n",\r\nref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size);\r\njffs2_mark_node_obsolete(c, this->node->raw);\r\njffs2_free_full_dnode(this->node);\r\n} else {\r\ndbg_fragtree2("marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d\n",\r\nref_offset(this->node->raw), this->node->ofs, this->node->ofs+this->node->size, this->node->frags);\r\nmark_ref_normal(this->node->raw);\r\n}\r\n}\r\njffs2_free_node_frag(this);\r\n}\r\nstatic void jffs2_fragtree_insert(struct jffs2_node_frag *newfrag, struct jffs2_node_frag *base)\r\n{\r\nstruct rb_node *parent = &base->rb;\r\nstruct rb_node **link = &parent;\r\ndbg_fragtree2("insert frag (0x%04x-0x%04x)\n", newfrag->ofs, newfrag->ofs + newfrag->size);\r\nwhile (*link) {\r\nparent = *link;\r\nbase = rb_entry(parent, struct jffs2_node_frag, rb);\r\nif (newfrag->ofs > base->ofs)\r\nlink = &base->rb.rb_right;\r\nelse if (newfrag->ofs < base->ofs)\r\nlink = &base->rb.rb_left;\r\nelse {\r\nJFFS2_ERROR("duplicate frag at %08x (%p,%p)\n", newfrag->ofs, newfrag, base);\r\nBUG();\r\n}\r\n}\r\nrb_link_node(&newfrag->rb, &base->rb, link);\r\n}\r\nstatic struct jffs2_node_frag * new_fragment(struct jffs2_full_dnode *fn, uint32_t ofs, uint32_t size)\r\n{\r\nstruct jffs2_node_frag *newfrag;\r\nnewfrag = jffs2_alloc_node_frag();\r\nif (likely(newfrag)) {\r\nnewfrag->ofs = ofs;\r\nnewfrag->size = size;\r\nnewfrag->node = fn;\r\n} else {\r\nJFFS2_ERROR("cannot allocate a jffs2_node_frag object\n");\r\n}\r\nreturn newfrag;\r\n}\r\nstatic int no_overlapping_node(struct jffs2_sb_info *c, struct rb_root *root,\r\nstruct jffs2_node_frag *newfrag,\r\nstruct jffs2_node_frag *this, uint32_t lastend)\r\n{\r\nif (lastend < newfrag->node->ofs) {\r\nstruct jffs2_node_frag *holefrag;\r\nholefrag= new_fragment(NULL, lastend, newfrag->node->ofs - lastend);\r\nif (unlikely(!holefrag)) {\r\njffs2_free_node_frag(newfrag);\r\nreturn -ENOMEM;\r\n}\r\nif (this) {\r\ndbg_fragtree2("add hole frag %#04x-%#04x on the right of the new frag.\n",\r\nholefrag->ofs, holefrag->ofs + holefrag->size);\r\nrb_link_node(&holefrag->rb, &this->rb, &this->rb.rb_right);\r\n} else {\r\ndbg_fragtree2("Add hole frag %#04x-%#04x to the root of the tree.\n",\r\nholefrag->ofs, holefrag->ofs + holefrag->size);\r\nrb_link_node(&holefrag->rb, NULL, &root->rb_node);\r\n}\r\nrb_insert_color(&holefrag->rb, root);\r\nthis = holefrag;\r\n}\r\nif (this) {\r\ndbg_fragtree2("add the new node at the right\n");\r\nrb_link_node(&newfrag->rb, &this->rb, &this->rb.rb_right);\r\n} else {\r\ndbg_fragtree2("insert the new node at the root of the tree\n");\r\nrb_link_node(&newfrag->rb, NULL, &root->rb_node);\r\n}\r\nrb_insert_color(&newfrag->rb, root);\r\nreturn 0;\r\n}\r\nstatic int jffs2_add_frag_to_fragtree(struct jffs2_sb_info *c, struct rb_root *root, struct jffs2_node_frag *newfrag)\r\n{\r\nstruct jffs2_node_frag *this;\r\nuint32_t lastend;\r\nthis = jffs2_lookup_node_frag(root, newfrag->node->ofs);\r\nif (this) {\r\ndbg_fragtree2("lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)\n",\r\nthis->ofs, this->ofs+this->size, this->node?(ref_offset(this->node->raw)):0xffffffff, this);\r\nlastend = this->ofs + this->size;\r\n} else {\r\ndbg_fragtree2("lookup gave no frag\n");\r\nlastend = 0;\r\n}\r\nif (lastend <= newfrag->ofs) {\r\nif (lastend && (lastend-1) >> PAGE_SHIFT == newfrag->ofs >> PAGE_SHIFT) {\r\nif (this->node)\r\nmark_ref_normal(this->node->raw);\r\nmark_ref_normal(newfrag->node->raw);\r\n}\r\nreturn no_overlapping_node(c, root, newfrag, this, lastend);\r\n}\r\nif (this->node)\r\ndbg_fragtree2("dealing with frag %u-%u, phys %#08x(%d).\n",\r\nthis->ofs, this->ofs + this->size,\r\nref_offset(this->node->raw), ref_flags(this->node->raw));\r\nelse\r\ndbg_fragtree2("dealing with hole frag %u-%u.\n",\r\nthis->ofs, this->ofs + this->size);\r\nif (newfrag->ofs > this->ofs) {\r\nmark_ref_normal(newfrag->node->raw);\r\nif (this->node)\r\nmark_ref_normal(this->node->raw);\r\nif (this->ofs + this->size > newfrag->ofs + newfrag->size) {\r\nstruct jffs2_node_frag *newfrag2;\r\nif (this->node)\r\ndbg_fragtree2("split old frag 0x%04x-0x%04x, phys 0x%08x\n",\r\nthis->ofs, this->ofs+this->size, ref_offset(this->node->raw));\r\nelse\r\ndbg_fragtree2("split old hole frag 0x%04x-0x%04x\n",\r\nthis->ofs, this->ofs+this->size);\r\nnewfrag2 = new_fragment(this->node, newfrag->ofs + newfrag->size,\r\nthis->ofs + this->size - newfrag->ofs - newfrag->size);\r\nif (unlikely(!newfrag2))\r\nreturn -ENOMEM;\r\nif (this->node)\r\nthis->node->frags++;\r\nthis->size = newfrag->ofs - this->ofs;\r\njffs2_fragtree_insert(newfrag, this);\r\nrb_insert_color(&newfrag->rb, root);\r\njffs2_fragtree_insert(newfrag2, newfrag);\r\nrb_insert_color(&newfrag2->rb, root);\r\nreturn 0;\r\n}\r\nthis->size = newfrag->ofs - this->ofs;\r\njffs2_fragtree_insert(newfrag, this);\r\nrb_insert_color(&newfrag->rb, root);\r\n} else {\r\ndbg_fragtree2("inserting newfrag (*%p),%d-%d in before 'this' (*%p),%d-%d\n",\r\nnewfrag, newfrag->ofs, newfrag->ofs+newfrag->size, this, this->ofs, this->ofs+this->size);\r\nrb_replace_node(&this->rb, &newfrag->rb, root);\r\nif (newfrag->ofs + newfrag->size >= this->ofs+this->size) {\r\ndbg_fragtree2("obsoleting node frag %p (%x-%x)\n", this, this->ofs, this->ofs+this->size);\r\njffs2_obsolete_node_frag(c, this);\r\n} else {\r\nthis->ofs += newfrag->size;\r\nthis->size -= newfrag->size;\r\njffs2_fragtree_insert(this, newfrag);\r\nrb_insert_color(&this->rb, root);\r\nreturn 0;\r\n}\r\n}\r\nwhile ((this = frag_next(newfrag)) && newfrag->ofs + newfrag->size >= this->ofs + this->size) {\r\ndbg_fragtree2("obsoleting node frag %p (%x-%x) and removing from tree\n",\r\nthis, this->ofs, this->ofs+this->size);\r\nrb_erase(&this->rb, root);\r\njffs2_obsolete_node_frag(c, this);\r\n}\r\nif (!this || newfrag->ofs + newfrag->size == this->ofs)\r\nreturn 0;\r\nthis->size = (this->ofs + this->size) - (newfrag->ofs + newfrag->size);\r\nthis->ofs = newfrag->ofs + newfrag->size;\r\nif (this->node)\r\nmark_ref_normal(this->node->raw);\r\nmark_ref_normal(newfrag->node->raw);\r\nreturn 0;\r\n}\r\nint jffs2_add_full_dnode_to_inode(struct jffs2_sb_info *c, struct jffs2_inode_info *f, struct jffs2_full_dnode *fn)\r\n{\r\nint ret;\r\nstruct jffs2_node_frag *newfrag;\r\nif (unlikely(!fn->size))\r\nreturn 0;\r\nnewfrag = new_fragment(fn, fn->ofs, fn->size);\r\nif (unlikely(!newfrag))\r\nreturn -ENOMEM;\r\nnewfrag->node->frags = 1;\r\ndbg_fragtree("adding node %#04x-%#04x @0x%08x on flash, newfrag *%p\n",\r\nfn->ofs, fn->ofs+fn->size, ref_offset(fn->raw), newfrag);\r\nret = jffs2_add_frag_to_fragtree(c, &f->fragtree, newfrag);\r\nif (unlikely(ret))\r\nreturn ret;\r\nif (newfrag->ofs & (PAGE_SIZE-1)) {\r\nstruct jffs2_node_frag *prev = frag_prev(newfrag);\r\nmark_ref_normal(fn->raw);\r\nif (prev->node)\r\nmark_ref_normal(prev->node->raw);\r\n}\r\nif ((newfrag->ofs+newfrag->size) & (PAGE_SIZE-1)) {\r\nstruct jffs2_node_frag *next = frag_next(newfrag);\r\nif (next) {\r\nmark_ref_normal(fn->raw);\r\nif (next->node)\r\nmark_ref_normal(next->node->raw);\r\n}\r\n}\r\njffs2_dbg_fragtree_paranoia_check_nolock(f);\r\nreturn 0;\r\n}\r\nvoid jffs2_set_inocache_state(struct jffs2_sb_info *c, struct jffs2_inode_cache *ic, int state)\r\n{\r\nspin_lock(&c->inocache_lock);\r\nic->state = state;\r\nwake_up(&c->inocache_wq);\r\nspin_unlock(&c->inocache_lock);\r\n}\r\nstruct jffs2_inode_cache *jffs2_get_ino_cache(struct jffs2_sb_info *c, uint32_t ino)\r\n{\r\nstruct jffs2_inode_cache *ret;\r\nret = c->inocache_list[ino % c->inocache_hashsize];\r\nwhile (ret && ret->ino < ino) {\r\nret = ret->next;\r\n}\r\nif (ret && ret->ino != ino)\r\nret = NULL;\r\nreturn ret;\r\n}\r\nvoid jffs2_add_ino_cache (struct jffs2_sb_info *c, struct jffs2_inode_cache *new)\r\n{\r\nstruct jffs2_inode_cache **prev;\r\nspin_lock(&c->inocache_lock);\r\nif (!new->ino)\r\nnew->ino = ++c->highest_ino;\r\ndbg_inocache("add %p (ino #%u)\n", new, new->ino);\r\nprev = &c->inocache_list[new->ino % c->inocache_hashsize];\r\nwhile ((*prev) && (*prev)->ino < new->ino) {\r\nprev = &(*prev)->next;\r\n}\r\nnew->next = *prev;\r\n*prev = new;\r\nspin_unlock(&c->inocache_lock);\r\n}\r\nvoid jffs2_del_ino_cache(struct jffs2_sb_info *c, struct jffs2_inode_cache *old)\r\n{\r\nstruct jffs2_inode_cache **prev;\r\n#ifdef CONFIG_JFFS2_FS_XATTR\r\nBUG_ON(old->xref);\r\n#endif\r\ndbg_inocache("del %p (ino #%u)\n", old, old->ino);\r\nspin_lock(&c->inocache_lock);\r\nprev = &c->inocache_list[old->ino % c->inocache_hashsize];\r\nwhile ((*prev) && (*prev)->ino < old->ino) {\r\nprev = &(*prev)->next;\r\n}\r\nif ((*prev) == old) {\r\n*prev = old->next;\r\n}\r\nif (old->state != INO_STATE_READING && old->state != INO_STATE_CLEARING)\r\njffs2_free_inode_cache(old);\r\nspin_unlock(&c->inocache_lock);\r\n}\r\nvoid jffs2_free_ino_caches(struct jffs2_sb_info *c)\r\n{\r\nint i;\r\nstruct jffs2_inode_cache *this, *next;\r\nfor (i=0; i < c->inocache_hashsize; i++) {\r\nthis = c->inocache_list[i];\r\nwhile (this) {\r\nnext = this->next;\r\njffs2_xattr_free_inode(c, this);\r\njffs2_free_inode_cache(this);\r\nthis = next;\r\n}\r\nc->inocache_list[i] = NULL;\r\n}\r\n}\r\nvoid jffs2_free_raw_node_refs(struct jffs2_sb_info *c)\r\n{\r\nint i;\r\nstruct jffs2_raw_node_ref *this, *next;\r\nfor (i=0; i<c->nr_blocks; i++) {\r\nthis = c->blocks[i].first_node;\r\nwhile (this) {\r\nif (this[REFS_PER_BLOCK].flash_offset == REF_LINK_NODE)\r\nnext = this[REFS_PER_BLOCK].next_in_ino;\r\nelse\r\nnext = NULL;\r\njffs2_free_refblock(this);\r\nthis = next;\r\n}\r\nc->blocks[i].first_node = c->blocks[i].last_node = NULL;\r\n}\r\n}\r\nstruct jffs2_node_frag *jffs2_lookup_node_frag(struct rb_root *fragtree, uint32_t offset)\r\n{\r\nstruct rb_node *next;\r\nstruct jffs2_node_frag *prev = NULL;\r\nstruct jffs2_node_frag *frag = NULL;\r\ndbg_fragtree2("root %p, offset %d\n", fragtree, offset);\r\nnext = fragtree->rb_node;\r\nwhile(next) {\r\nfrag = rb_entry(next, struct jffs2_node_frag, rb);\r\nif (frag->ofs + frag->size <= offset) {\r\nif (!prev || frag->ofs > prev->ofs)\r\nprev = frag;\r\nnext = frag->rb.rb_right;\r\n} else if (frag->ofs > offset) {\r\nnext = frag->rb.rb_left;\r\n} else {\r\nreturn frag;\r\n}\r\n}\r\nif (prev)\r\ndbg_fragtree2("no match. Returning frag %#04x-%#04x, closest previous\n",\r\nprev->ofs, prev->ofs+prev->size);\r\nelse\r\ndbg_fragtree2("returning NULL, empty fragtree\n");\r\nreturn prev;\r\n}\r\nvoid jffs2_kill_fragtree(struct rb_root *root, struct jffs2_sb_info *c)\r\n{\r\nstruct jffs2_node_frag *frag, *next;\r\ndbg_fragtree("killing\n");\r\nrbtree_postorder_for_each_entry_safe(frag, next, root, rb) {\r\nif (frag->node && !(--frag->node->frags)) {\r\nif (c)\r\njffs2_mark_node_obsolete(c, frag->node->raw);\r\njffs2_free_full_dnode(frag->node);\r\n}\r\njffs2_free_node_frag(frag);\r\ncond_resched();\r\n}\r\n}\r\nstruct jffs2_raw_node_ref *jffs2_link_node_ref(struct jffs2_sb_info *c,\r\nstruct jffs2_eraseblock *jeb,\r\nuint32_t ofs, uint32_t len,\r\nstruct jffs2_inode_cache *ic)\r\n{\r\nstruct jffs2_raw_node_ref *ref;\r\nBUG_ON(!jeb->allocated_refs);\r\njeb->allocated_refs--;\r\nref = jeb->last_node;\r\ndbg_noderef("Last node at %p is (%08x,%p)\n", ref, ref->flash_offset,\r\nref->next_in_ino);\r\nwhile (ref->flash_offset != REF_EMPTY_NODE) {\r\nif (ref->flash_offset == REF_LINK_NODE)\r\nref = ref->next_in_ino;\r\nelse\r\nref++;\r\n}\r\ndbg_noderef("New ref is %p (%08x becomes %08x,%p) len 0x%x\n", ref,\r\nref->flash_offset, ofs, ref->next_in_ino, len);\r\nref->flash_offset = ofs;\r\nif (!jeb->first_node) {\r\njeb->first_node = ref;\r\nBUG_ON(ref_offset(ref) != jeb->offset);\r\n} else if (unlikely(ref_offset(ref) != jeb->offset + c->sector_size - jeb->free_size)) {\r\nuint32_t last_len = ref_totlen(c, jeb, jeb->last_node);\r\nJFFS2_ERROR("Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)\n",\r\nref, ref_offset(ref), ref_offset(ref)+len,\r\nref_offset(jeb->last_node),\r\nref_offset(jeb->last_node)+last_len);\r\nBUG();\r\n}\r\njeb->last_node = ref;\r\nif (ic) {\r\nref->next_in_ino = ic->nodes;\r\nic->nodes = ref;\r\n} else {\r\nref->next_in_ino = NULL;\r\n}\r\nswitch(ref_flags(ref)) {\r\ncase REF_UNCHECKED:\r\nc->unchecked_size += len;\r\njeb->unchecked_size += len;\r\nbreak;\r\ncase REF_NORMAL:\r\ncase REF_PRISTINE:\r\nc->used_size += len;\r\njeb->used_size += len;\r\nbreak;\r\ncase REF_OBSOLETE:\r\nc->dirty_size += len;\r\njeb->dirty_size += len;\r\nbreak;\r\n}\r\nc->free_size -= len;\r\njeb->free_size -= len;\r\n#ifdef TEST_TOTLEN\r\nref->__totlen = len;\r\nref_totlen(c, jeb, ref);\r\n#endif\r\nreturn ref;\r\n}\r\nint jffs2_scan_dirty_space(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nuint32_t size)\r\n{\r\nif (!size)\r\nreturn 0;\r\nif (unlikely(size > jeb->free_size)) {\r\npr_crit("Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)\n",\r\nsize, jeb->free_size, jeb->wasted_size);\r\nBUG();\r\n}\r\nif (jeb->last_node && ref_obsolete(jeb->last_node)) {\r\n#ifdef TEST_TOTLEN\r\njeb->last_node->__totlen += size;\r\n#endif\r\nc->dirty_size += size;\r\nc->free_size -= size;\r\njeb->dirty_size += size;\r\njeb->free_size -= size;\r\n} else {\r\nuint32_t ofs = jeb->offset + c->sector_size - jeb->free_size;\r\nofs |= REF_OBSOLETE;\r\njffs2_link_node_ref(c, jeb, ofs, size, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline uint32_t __ref_totlen(struct jffs2_sb_info *c,\r\nstruct jffs2_eraseblock *jeb,\r\nstruct jffs2_raw_node_ref *ref)\r\n{\r\nuint32_t ref_end;\r\nstruct jffs2_raw_node_ref *next_ref = ref_next(ref);\r\nif (next_ref)\r\nref_end = ref_offset(next_ref);\r\nelse {\r\nif (!jeb)\r\njeb = &c->blocks[ref->flash_offset / c->sector_size];\r\nif (unlikely(ref != jeb->last_node)) {\r\npr_crit("ref %p @0x%08x is not jeb->last_node (%p @0x%08x)\n",\r\nref, ref_offset(ref), jeb->last_node,\r\njeb->last_node ?\r\nref_offset(jeb->last_node) : 0);\r\nBUG();\r\n}\r\nref_end = jeb->offset + c->sector_size - jeb->free_size;\r\n}\r\nreturn ref_end - ref_offset(ref);\r\n}\r\nuint32_t __jffs2_ref_totlen(struct jffs2_sb_info *c, struct jffs2_eraseblock *jeb,\r\nstruct jffs2_raw_node_ref *ref)\r\n{\r\nuint32_t ret;\r\nret = __ref_totlen(c, jeb, ref);\r\n#ifdef TEST_TOTLEN\r\nif (unlikely(ret != ref->__totlen)) {\r\nif (!jeb)\r\njeb = &c->blocks[ref->flash_offset / c->sector_size];\r\npr_crit("Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x\n",\r\nref, ref_offset(ref), ref_offset(ref) + ref->__totlen,\r\nret, ref->__totlen);\r\nif (ref_next(ref)) {\r\npr_crit("next %p (0x%08x-0x%08x)\n",\r\nref_next(ref), ref_offset(ref_next(ref)),\r\nref_offset(ref_next(ref)) + ref->__totlen);\r\n} else\r\npr_crit("No next ref. jeb->last_node is %p\n",\r\njeb->last_node);\r\npr_crit("jeb->wasted_size %x, dirty_size %x, used_size %x, free_size %x\n",\r\njeb->wasted_size, jeb->dirty_size, jeb->used_size,\r\njeb->free_size);\r\n#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)\r\n__jffs2_dbg_dump_node_refs_nolock(c, jeb);\r\n#endif\r\nWARN_ON(1);\r\nret = ref->__totlen;\r\n}\r\n#endif\r\nreturn ret;\r\n}
