static char *fourcc_to_str(u32 fmt)\r\n{\r\nstatic char code[5];\r\ncode[0] = (unsigned char)(fmt & 0xff);\r\ncode[1] = (unsigned char)((fmt >> 8) & 0xff);\r\ncode[2] = (unsigned char)((fmt >> 16) & 0xff);\r\ncode[3] = (unsigned char)((fmt >> 24) & 0xff);\r\ncode[4] = '\0';\r\nreturn code;\r\n}\r\nstatic const struct cal_fmt *find_format_by_pix(struct cal_ctx *ctx,\r\nu32 pixelformat)\r\n{\r\nconst struct cal_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < ctx->num_active_fmt; k++) {\r\nfmt = ctx->active_fmt[k];\r\nif (fmt->fourcc == pixelformat)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct cal_fmt *find_format_by_code(struct cal_ctx *ctx,\r\nu32 code)\r\n{\r\nconst struct cal_fmt *fmt;\r\nunsigned int k;\r\nfor (k = 0; k < ctx->num_active_fmt; k++) {\r\nfmt = ctx->active_fmt[k];\r\nif (fmt->code == code)\r\nreturn fmt;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline struct cal_ctx *notifier_to_ctx(struct v4l2_async_notifier *n)\r\n{\r\nreturn container_of(n, struct cal_ctx, notifier);\r\n}\r\nstatic inline int get_field(u32 value, u32 mask)\r\n{\r\nreturn (value & mask) >> __ffs(mask);\r\n}\r\nstatic inline void set_field(u32 *valp, u32 field, u32 mask)\r\n{\r\nu32 val = *valp;\r\nval &= ~mask;\r\nval |= (field << __ffs(mask)) & mask;\r\n*valp = val;\r\n}\r\nstatic struct cm_data *cm_create(struct cal_dev *dev)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct cm_data *cm;\r\ncm = devm_kzalloc(&pdev->dev, sizeof(*cm), GFP_KERNEL);\r\nif (!cm)\r\nreturn ERR_PTR(-ENOMEM);\r\ncm->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"camerrx_control");\r\ncm->base = devm_ioremap_resource(&pdev->dev, cm->res);\r\nif (IS_ERR(cm->base)) {\r\ncal_err(dev, "failed to ioremap\n");\r\nreturn ERR_CAST(cm->base);\r\n}\r\ncal_dbg(1, dev, "ioresource %s at %pa - %pa\n",\r\ncm->res->name, &cm->res->start, &cm->res->end);\r\nreturn cm;\r\n}\r\nstatic void camerarx_phy_enable(struct cal_ctx *ctx)\r\n{\r\nu32 val;\r\nif (!ctx->dev->cm->base) {\r\nctx_err(ctx, "cm not mapped\n");\r\nreturn;\r\n}\r\nval = reg_read(ctx->dev->cm, CM_CTRL_CORE_CAMERRX_CONTROL);\r\nif (ctx->csi2_port == 1) {\r\nset_field(&val, 1, CM_CAMERRX_CTRL_CSI0_CTRLCLKEN_MASK);\r\nset_field(&val, 0, CM_CAMERRX_CTRL_CSI0_CAMMODE_MASK);\r\nset_field(&val, 0xf, CM_CAMERRX_CTRL_CSI0_LANEENABLE_MASK);\r\nset_field(&val, 1, CM_CAMERRX_CTRL_CSI0_MODE_MASK);\r\n} else if (ctx->csi2_port == 2) {\r\nset_field(&val, 1, CM_CAMERRX_CTRL_CSI1_CTRLCLKEN_MASK);\r\nset_field(&val, 0, CM_CAMERRX_CTRL_CSI1_CAMMODE_MASK);\r\nset_field(&val, 0x3, CM_CAMERRX_CTRL_CSI1_LANEENABLE_MASK);\r\nset_field(&val, 1, CM_CAMERRX_CTRL_CSI1_MODE_MASK);\r\n}\r\nreg_write(ctx->dev->cm, CM_CTRL_CORE_CAMERRX_CONTROL, val);\r\n}\r\nstatic void camerarx_phy_disable(struct cal_ctx *ctx)\r\n{\r\nu32 val;\r\nif (!ctx->dev->cm->base) {\r\nctx_err(ctx, "cm not mapped\n");\r\nreturn;\r\n}\r\nval = reg_read(ctx->dev->cm, CM_CTRL_CORE_CAMERRX_CONTROL);\r\nif (ctx->csi2_port == 1)\r\nset_field(&val, 0x0, CM_CAMERRX_CTRL_CSI0_CTRLCLKEN_MASK);\r\nelse if (ctx->csi2_port == 2)\r\nset_field(&val, 0x0, CM_CAMERRX_CTRL_CSI1_CTRLCLKEN_MASK);\r\nreg_write(ctx->dev->cm, CM_CTRL_CORE_CAMERRX_CONTROL, val);\r\n}\r\nstatic struct cc_data *cc_create(struct cal_dev *dev, unsigned int core)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct cc_data *cc;\r\ncc = devm_kzalloc(&pdev->dev, sizeof(*cc), GFP_KERNEL);\r\nif (!cc)\r\nreturn ERR_PTR(-ENOMEM);\r\ncc->res = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM,\r\n(core == 0) ?\r\n"cal_rx_core0" :\r\n"cal_rx_core1");\r\ncc->base = devm_ioremap_resource(&pdev->dev, cc->res);\r\nif (IS_ERR(cc->base)) {\r\ncal_err(dev, "failed to ioremap\n");\r\nreturn ERR_CAST(cc->base);\r\n}\r\ncal_dbg(1, dev, "ioresource %s at %pa - %pa\n",\r\ncc->res->name, &cc->res->start, &cc->res->end);\r\nreturn cc;\r\n}\r\nstatic void cal_get_hwinfo(struct cal_dev *dev)\r\n{\r\nu32 revision = 0;\r\nu32 hwinfo = 0;\r\nrevision = reg_read(dev, CAL_HL_REVISION);\r\ncal_dbg(3, dev, "CAL_HL_REVISION = 0x%08x (expecting 0x40000200)\n",\r\nrevision);\r\nhwinfo = reg_read(dev, CAL_HL_HWINFO);\r\ncal_dbg(3, dev, "CAL_HL_HWINFO = 0x%08x (expecting 0xA3C90469)\n",\r\nhwinfo);\r\n}\r\nstatic inline int cal_runtime_get(struct cal_dev *dev)\r\n{\r\nreturn pm_runtime_get_sync(&dev->pdev->dev);\r\n}\r\nstatic inline void cal_runtime_put(struct cal_dev *dev)\r\n{\r\npm_runtime_put_sync(&dev->pdev->dev);\r\n}\r\nstatic void cal_quickdump_regs(struct cal_dev *dev)\r\n{\r\ncal_info(dev, "CAL Registers @ 0x%pa:\n", &dev->res->start);\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 4,\r\n(__force const void *)dev->base,\r\nresource_size(dev->res), false);\r\nif (dev->ctx[0]) {\r\ncal_info(dev, "CSI2 Core 0 Registers @ %pa:\n",\r\n&dev->ctx[0]->cc->res->start);\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 4,\r\n(__force const void *)dev->ctx[0]->cc->base,\r\nresource_size(dev->ctx[0]->cc->res),\r\nfalse);\r\n}\r\nif (dev->ctx[1]) {\r\ncal_info(dev, "CSI2 Core 1 Registers @ %pa:\n",\r\n&dev->ctx[1]->cc->res->start);\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 4,\r\n(__force const void *)dev->ctx[1]->cc->base,\r\nresource_size(dev->ctx[1]->cc->res),\r\nfalse);\r\n}\r\ncal_info(dev, "CAMERRX_Control Registers @ %pa:\n",\r\n&dev->cm->res->start);\r\nprint_hex_dump(KERN_INFO, "", DUMP_PREFIX_OFFSET, 16, 4,\r\n(__force const void *)dev->cm->base,\r\nresource_size(dev->cm->res), false);\r\n}\r\nstatic void enable_irqs(struct cal_ctx *ctx)\r\n{\r\nreg_write_field(ctx->dev,\r\nCAL_HL_IRQENABLE_SET(2),\r\nCAL_HL_IRQ_ENABLE,\r\nCAL_HL_IRQ_MASK(ctx->csi2_port));\r\nreg_write_field(ctx->dev,\r\nCAL_HL_IRQENABLE_SET(3),\r\nCAL_HL_IRQ_ENABLE,\r\nCAL_HL_IRQ_MASK(ctx->csi2_port));\r\nreg_write(ctx->dev, CAL_CSI2_VC_IRQENABLE(1), 0xFF000000);\r\n}\r\nstatic void disable_irqs(struct cal_ctx *ctx)\r\n{\r\nreg_write_field(ctx->dev,\r\nCAL_HL_IRQENABLE_CLR(2),\r\nCAL_HL_IRQ_CLEAR,\r\nCAL_HL_IRQ_MASK(ctx->csi2_port));\r\nreg_write_field(ctx->dev,\r\nCAL_HL_IRQENABLE_CLR(3),\r\nCAL_HL_IRQ_CLEAR,\r\nCAL_HL_IRQ_MASK(ctx->csi2_port));\r\nreg_write(ctx->dev, CAL_CSI2_VC_IRQENABLE(1), 0);\r\n}\r\nstatic void csi2_init(struct cal_ctx *ctx)\r\n{\r\nint i;\r\nu32 val;\r\nval = reg_read(ctx->dev, CAL_CSI2_TIMING(ctx->csi2_port));\r\nset_field(&val, CAL_GEN_ENABLE,\r\nCAL_CSI2_TIMING_FORCE_RX_MODE_IO1_MASK);\r\nset_field(&val, CAL_GEN_ENABLE,\r\nCAL_CSI2_TIMING_STOP_STATE_X16_IO1_MASK);\r\nset_field(&val, CAL_GEN_DISABLE,\r\nCAL_CSI2_TIMING_STOP_STATE_X4_IO1_MASK);\r\nset_field(&val, 407, CAL_CSI2_TIMING_STOP_STATE_COUNTER_IO1_MASK);\r\nreg_write(ctx->dev, CAL_CSI2_TIMING(ctx->csi2_port), val);\r\nctx_dbg(3, ctx, "CAL_CSI2_TIMING(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_CSI2_TIMING(ctx->csi2_port)));\r\nval = reg_read(ctx->dev, CAL_CSI2_COMPLEXIO_CFG(ctx->csi2_port));\r\nset_field(&val, CAL_CSI2_COMPLEXIO_CFG_RESET_CTRL_OPERATIONAL,\r\nCAL_CSI2_COMPLEXIO_CFG_RESET_CTRL_MASK);\r\nset_field(&val, CAL_CSI2_COMPLEXIO_CFG_PWR_CMD_STATE_ON,\r\nCAL_CSI2_COMPLEXIO_CFG_PWR_CMD_MASK);\r\nreg_write(ctx->dev, CAL_CSI2_COMPLEXIO_CFG(ctx->csi2_port), val);\r\nfor (i = 0; i < 10; i++) {\r\nif (reg_read_field(ctx->dev,\r\nCAL_CSI2_COMPLEXIO_CFG(ctx->csi2_port),\r\nCAL_CSI2_COMPLEXIO_CFG_PWR_STATUS_MASK) ==\r\nCAL_CSI2_COMPLEXIO_CFG_PWR_STATUS_STATE_ON)\r\nbreak;\r\nusleep_range(1000, 1100);\r\n}\r\nctx_dbg(3, ctx, "CAL_CSI2_COMPLEXIO_CFG(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_CSI2_COMPLEXIO_CFG(ctx->csi2_port)));\r\nval = reg_read(ctx->dev, CAL_CTRL);\r\nset_field(&val, CAL_CTRL_BURSTSIZE_BURST128, CAL_CTRL_BURSTSIZE_MASK);\r\nset_field(&val, 0xF, CAL_CTRL_TAGCNT_MASK);\r\nset_field(&val, CAL_CTRL_POSTED_WRITES_NONPOSTED,\r\nCAL_CTRL_POSTED_WRITES_MASK);\r\nset_field(&val, 0xFF, CAL_CTRL_MFLAGL_MASK);\r\nset_field(&val, 0xFF, CAL_CTRL_MFLAGH_MASK);\r\nreg_write(ctx->dev, CAL_CTRL, val);\r\nctx_dbg(3, ctx, "CAL_CTRL = 0x%08x\n", reg_read(ctx->dev, CAL_CTRL));\r\n}\r\nstatic void csi2_lane_config(struct cal_ctx *ctx)\r\n{\r\nu32 val = reg_read(ctx->dev, CAL_CSI2_COMPLEXIO_CFG(ctx->csi2_port));\r\nu32 lane_mask = CAL_CSI2_COMPLEXIO_CFG_CLOCK_POSITION_MASK;\r\nu32 polarity_mask = CAL_CSI2_COMPLEXIO_CFG_CLOCK_POL_MASK;\r\nstruct v4l2_of_bus_mipi_csi2 *mipi_csi2 = &ctx->endpoint.bus.mipi_csi2;\r\nint lane;\r\nset_field(&val, mipi_csi2->clock_lane + 1, lane_mask);\r\nset_field(&val, mipi_csi2->lane_polarities[0], polarity_mask);\r\nfor (lane = 0; lane < mipi_csi2->num_data_lanes; lane++) {\r\nlane_mask <<= 4;\r\npolarity_mask <<= 4;\r\nset_field(&val, mipi_csi2->data_lanes[lane] + 1, lane_mask);\r\nset_field(&val, mipi_csi2->lane_polarities[lane + 1],\r\npolarity_mask);\r\n}\r\nreg_write(ctx->dev, CAL_CSI2_COMPLEXIO_CFG(ctx->csi2_port), val);\r\nctx_dbg(3, ctx, "CAL_CSI2_COMPLEXIO_CFG(%d) = 0x%08x\n",\r\nctx->csi2_port, val);\r\n}\r\nstatic void csi2_ppi_enable(struct cal_ctx *ctx)\r\n{\r\nreg_write_field(ctx->dev, CAL_CSI2_PPI_CTRL(ctx->csi2_port),\r\nCAL_GEN_ENABLE, CAL_CSI2_PPI_CTRL_IF_EN_MASK);\r\n}\r\nstatic void csi2_ppi_disable(struct cal_ctx *ctx)\r\n{\r\nreg_write_field(ctx->dev, CAL_CSI2_PPI_CTRL(ctx->csi2_port),\r\nCAL_GEN_DISABLE, CAL_CSI2_PPI_CTRL_IF_EN_MASK);\r\n}\r\nstatic void csi2_ctx_config(struct cal_ctx *ctx)\r\n{\r\nu32 val;\r\nval = reg_read(ctx->dev, CAL_CSI2_CTX0(ctx->csi2_port));\r\nset_field(&val, ctx->csi2_port, CAL_CSI2_CTX_CPORT_MASK);\r\nset_field(&val, 0x1, CAL_CSI2_CTX_DT_MASK);\r\nset_field(&val, ctx->virtual_channel, CAL_CSI2_CTX_VC_MASK);\r\nset_field(&val, 0, CAL_CSI2_CTX_LINES_MASK);\r\nset_field(&val, CAL_CSI2_CTX_ATT_PIX, CAL_CSI2_CTX_ATT_MASK);\r\nset_field(&val, CAL_CSI2_CTX_PACK_MODE_LINE,\r\nCAL_CSI2_CTX_PACK_MODE_MASK);\r\nreg_write(ctx->dev, CAL_CSI2_CTX0(ctx->csi2_port), val);\r\nctx_dbg(3, ctx, "CAL_CSI2_CTX0(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_CSI2_CTX0(ctx->csi2_port)));\r\n}\r\nstatic void pix_proc_config(struct cal_ctx *ctx)\r\n{\r\nu32 val;\r\nval = reg_read(ctx->dev, CAL_PIX_PROC(ctx->csi2_port));\r\nset_field(&val, CAL_PIX_PROC_EXTRACT_B8, CAL_PIX_PROC_EXTRACT_MASK);\r\nset_field(&val, CAL_PIX_PROC_DPCMD_BYPASS, CAL_PIX_PROC_DPCMD_MASK);\r\nset_field(&val, CAL_PIX_PROC_DPCME_BYPASS, CAL_PIX_PROC_DPCME_MASK);\r\nset_field(&val, CAL_PIX_PROC_PACK_B8, CAL_PIX_PROC_PACK_MASK);\r\nset_field(&val, ctx->csi2_port, CAL_PIX_PROC_CPORT_MASK);\r\nset_field(&val, CAL_GEN_ENABLE, CAL_PIX_PROC_EN_MASK);\r\nreg_write(ctx->dev, CAL_PIX_PROC(ctx->csi2_port), val);\r\nctx_dbg(3, ctx, "CAL_PIX_PROC(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_PIX_PROC(ctx->csi2_port)));\r\n}\r\nstatic void cal_wr_dma_config(struct cal_ctx *ctx,\r\nunsigned int width)\r\n{\r\nu32 val;\r\nval = reg_read(ctx->dev, CAL_WR_DMA_CTRL(ctx->csi2_port));\r\nset_field(&val, ctx->csi2_port, CAL_WR_DMA_CTRL_CPORT_MASK);\r\nset_field(&val, CAL_WR_DMA_CTRL_DTAG_PIX_DAT,\r\nCAL_WR_DMA_CTRL_DTAG_MASK);\r\nset_field(&val, CAL_WR_DMA_CTRL_MODE_CONST,\r\nCAL_WR_DMA_CTRL_MODE_MASK);\r\nset_field(&val, CAL_WR_DMA_CTRL_PATTERN_LINEAR,\r\nCAL_WR_DMA_CTRL_PATTERN_MASK);\r\nset_field(&val, CAL_GEN_ENABLE, CAL_WR_DMA_CTRL_STALL_RD_MASK);\r\nreg_write(ctx->dev, CAL_WR_DMA_CTRL(ctx->csi2_port), val);\r\nctx_dbg(3, ctx, "CAL_WR_DMA_CTRL(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_WR_DMA_CTRL(ctx->csi2_port)));\r\nreg_write_field(ctx->dev,\r\nCAL_WR_DMA_OFST(ctx->csi2_port),\r\n(width / 16),\r\nCAL_WR_DMA_OFST_MASK);\r\nctx_dbg(3, ctx, "CAL_WR_DMA_OFST(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_WR_DMA_OFST(ctx->csi2_port)));\r\nval = reg_read(ctx->dev, CAL_WR_DMA_XSIZE(ctx->csi2_port));\r\nset_field(&val, 0, CAL_WR_DMA_XSIZE_XSKIP_MASK);\r\nset_field(&val, (width / 8), CAL_WR_DMA_XSIZE_MASK);\r\nreg_write(ctx->dev, CAL_WR_DMA_XSIZE(ctx->csi2_port), val);\r\nctx_dbg(3, ctx, "CAL_WR_DMA_XSIZE(%d) = 0x%08x\n", ctx->csi2_port,\r\nreg_read(ctx->dev, CAL_WR_DMA_XSIZE(ctx->csi2_port)));\r\n}\r\nstatic void cal_wr_dma_addr(struct cal_ctx *ctx, unsigned int dmaaddr)\r\n{\r\nreg_write(ctx->dev, CAL_WR_DMA_ADDR(ctx->csi2_port), dmaaddr);\r\n}\r\nstatic void csi2_phy_config(struct cal_ctx *ctx)\r\n{\r\nunsigned int reg0, reg1;\r\nunsigned int ths_term, ths_settle;\r\nunsigned int ddrclkperiod_us;\r\nddrclkperiod_us = ctx->external_rate / 2000000;\r\nddrclkperiod_us = 1000000 / ddrclkperiod_us;\r\nctx_dbg(1, ctx, "ddrclkperiod_us: %d\n", ddrclkperiod_us);\r\nths_term = 20000 / ddrclkperiod_us;\r\nths_term = (ths_term >= 2) ? ths_term - 2 : ths_term;\r\nctx_dbg(1, ctx, "ths_term: %d (0x%02x)\n", ths_term, ths_term);\r\nths_settle = THS_SETTLE;\r\nctx_dbg(1, ctx, "ths_settle: %d (0x%02x)\n", ths_settle, ths_settle);\r\nreg0 = reg_read(ctx->cc, CAL_CSI2_PHY_REG0);\r\nset_field(&reg0, CAL_CSI2_PHY_REG0_HSCLOCKCONFIG_DISABLE,\r\nCAL_CSI2_PHY_REG0_HSCLOCKCONFIG_MASK);\r\nset_field(&reg0, ths_term, CAL_CSI2_PHY_REG0_THS_TERM_MASK);\r\nset_field(&reg0, ths_settle, CAL_CSI2_PHY_REG0_THS_SETTLE_MASK);\r\nctx_dbg(1, ctx, "CSI2_%d_REG0 = 0x%08x\n", (ctx->csi2_port - 1), reg0);\r\nreg_write(ctx->cc, CAL_CSI2_PHY_REG0, reg0);\r\nreg1 = reg_read(ctx->cc, CAL_CSI2_PHY_REG1);\r\nset_field(&reg1, TCLK_TERM, CAL_CSI2_PHY_REG1_TCLK_TERM_MASK);\r\nset_field(&reg1, 0xb8, CAL_CSI2_PHY_REG1_DPHY_HS_SYNC_PATTERN_MASK);\r\nset_field(&reg1, TCLK_MISS, CAL_CSI2_PHY_REG1_CTRLCLK_DIV_FACTOR_MASK);\r\nset_field(&reg1, TCLK_SETTLE, CAL_CSI2_PHY_REG1_TCLK_SETTLE_MASK);\r\nctx_dbg(1, ctx, "CSI2_%d_REG1 = 0x%08x\n", (ctx->csi2_port - 1), reg1);\r\nreg_write(ctx->cc, CAL_CSI2_PHY_REG1, reg1);\r\n}\r\nstatic int cal_get_external_info(struct cal_ctx *ctx)\r\n{\r\nstruct v4l2_ctrl *ctrl;\r\nif (!ctx->sensor)\r\nreturn -ENODEV;\r\nctrl = v4l2_ctrl_find(ctx->sensor->ctrl_handler, V4L2_CID_PIXEL_RATE);\r\nif (!ctrl) {\r\nctx_err(ctx, "no pixel rate control in subdev: %s\n",\r\nctx->sensor->name);\r\nreturn -EPIPE;\r\n}\r\nctx->external_rate = v4l2_ctrl_g_ctrl_int64(ctrl);\r\nctx_dbg(3, ctx, "sensor Pixel Rate: %d\n", ctx->external_rate);\r\nreturn 0;\r\n}\r\nstatic inline void cal_schedule_next_buffer(struct cal_ctx *ctx)\r\n{\r\nstruct cal_dmaqueue *dma_q = &ctx->vidq;\r\nstruct cal_buffer *buf;\r\nunsigned long addr;\r\nbuf = list_entry(dma_q->active.next, struct cal_buffer, list);\r\nctx->next_frm = buf;\r\nlist_del(&buf->list);\r\naddr = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);\r\ncal_wr_dma_addr(ctx, addr);\r\n}\r\nstatic inline void cal_process_buffer_complete(struct cal_ctx *ctx)\r\n{\r\nctx->cur_frm->vb.vb2_buf.timestamp = ktime_get_ns();\r\nctx->cur_frm->vb.field = ctx->m_fmt.field;\r\nctx->cur_frm->vb.sequence = ctx->sequence++;\r\nvb2_buffer_done(&ctx->cur_frm->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\nctx->cur_frm = ctx->next_frm;\r\n}\r\nstatic irqreturn_t cal_irq(int irq_cal, void *data)\r\n{\r\nstruct cal_dev *dev = (struct cal_dev *)data;\r\nstruct cal_ctx *ctx;\r\nstruct cal_dmaqueue *dma_q;\r\nu32 irqst2, irqst3;\r\nirqst2 = reg_read(dev, CAL_HL_IRQSTATUS(2));\r\nif (irqst2) {\r\nreg_write(dev, CAL_HL_IRQSTATUS(2), irqst2);\r\nif (isportirqset(irqst2, 1)) {\r\nctx = dev->ctx[0];\r\nif (ctx->cur_frm != ctx->next_frm)\r\ncal_process_buffer_complete(ctx);\r\n}\r\nif (isportirqset(irqst2, 2)) {\r\nctx = dev->ctx[1];\r\nif (ctx->cur_frm != ctx->next_frm)\r\ncal_process_buffer_complete(ctx);\r\n}\r\n}\r\nirqst3 = reg_read(dev, CAL_HL_IRQSTATUS(3));\r\nif (irqst3) {\r\nreg_write(dev, CAL_HL_IRQSTATUS(3), irqst3);\r\nif (isportirqset(irqst3, 1)) {\r\nctx = dev->ctx[0];\r\ndma_q = &ctx->vidq;\r\nspin_lock(&ctx->slock);\r\nif (!list_empty(&dma_q->active) &&\r\nctx->cur_frm == ctx->next_frm)\r\ncal_schedule_next_buffer(ctx);\r\nspin_unlock(&ctx->slock);\r\n}\r\nif (isportirqset(irqst3, 2)) {\r\nctx = dev->ctx[1];\r\ndma_q = &ctx->vidq;\r\nspin_lock(&ctx->slock);\r\nif (!list_empty(&dma_q->active) &&\r\nctx->cur_frm == ctx->next_frm)\r\ncal_schedule_next_buffer(ctx);\r\nspin_unlock(&ctx->slock);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int cal_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nstrlcpy(cap->driver, CAL_MODULE_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, CAL_MODULE_NAME, sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info),\r\n"platform:%s", ctx->v4l2_dev.name);\r\ncap->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_STREAMING |\r\nV4L2_CAP_READWRITE;\r\ncap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int cal_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nconst struct cal_fmt *fmt = NULL;\r\nif (f->index >= ctx->num_active_fmt)\r\nreturn -EINVAL;\r\nfmt = ctx->active_fmt[f->index];\r\nf->pixelformat = fmt->fourcc;\r\nf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nreturn 0;\r\n}\r\nstatic int __subdev_get_format(struct cal_ctx *ctx,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct v4l2_subdev_format sd_fmt;\r\nstruct v4l2_mbus_framefmt *mbus_fmt = &sd_fmt.format;\r\nint ret;\r\nsd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nsd_fmt.pad = 0;\r\nret = v4l2_subdev_call(ctx->sensor, pad, get_fmt, NULL, &sd_fmt);\r\nif (ret)\r\nreturn ret;\r\n*fmt = *mbus_fmt;\r\nctx_dbg(1, ctx, "%s %dx%d code:%04X\n", __func__,\r\nfmt->width, fmt->height, fmt->code);\r\nreturn 0;\r\n}\r\nstatic int __subdev_set_format(struct cal_ctx *ctx,\r\nstruct v4l2_mbus_framefmt *fmt)\r\n{\r\nstruct v4l2_subdev_format sd_fmt;\r\nstruct v4l2_mbus_framefmt *mbus_fmt = &sd_fmt.format;\r\nint ret;\r\nsd_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nsd_fmt.pad = 0;\r\n*mbus_fmt = *fmt;\r\nret = v4l2_subdev_call(ctx->sensor, pad, set_fmt, NULL, &sd_fmt);\r\nif (ret)\r\nreturn ret;\r\nctx_dbg(1, ctx, "%s %dx%d code:%04X\n", __func__,\r\nfmt->width, fmt->height, fmt->code);\r\nreturn 0;\r\n}\r\nstatic int cal_calc_format_size(struct cal_ctx *ctx,\r\nconst struct cal_fmt *fmt,\r\nstruct v4l2_format *f)\r\n{\r\nif (!fmt) {\r\nctx_dbg(3, ctx, "No cal_fmt provided!\n");\r\nreturn -EINVAL;\r\n}\r\nv4l_bound_align_image(&f->fmt.pix.width, 48, MAX_WIDTH, 2,\r\n&f->fmt.pix.height, 32, MAX_HEIGHT, 0, 0);\r\nf->fmt.pix.bytesperline = bytes_per_line(f->fmt.pix.width,\r\nfmt->depth >> 3);\r\nf->fmt.pix.sizeimage = f->fmt.pix.height *\r\nf->fmt.pix.bytesperline;\r\nctx_dbg(3, ctx, "%s: fourcc: %s size: %dx%d bpl:%d img_size:%d\n",\r\n__func__, fourcc_to_str(f->fmt.pix.pixelformat),\r\nf->fmt.pix.width, f->fmt.pix.height,\r\nf->fmt.pix.bytesperline, f->fmt.pix.sizeimage);\r\nreturn 0;\r\n}\r\nstatic int cal_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\n*f = ctx->v_fmt;\r\nreturn 0;\r\n}\r\nstatic int cal_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nconst struct cal_fmt *fmt;\r\nstruct v4l2_subdev_frame_size_enum fse;\r\nint ret, found;\r\nfmt = find_format_by_pix(ctx, f->fmt.pix.pixelformat);\r\nif (!fmt) {\r\nctx_dbg(3, ctx, "Fourcc format (0x%08x) not found.\n",\r\nf->fmt.pix.pixelformat);\r\nfmt = ctx->active_fmt[0];\r\nf->fmt.pix.pixelformat = fmt->fourcc;\r\n}\r\nf->fmt.pix.field = ctx->v_fmt.fmt.pix.field;\r\nret = 0;\r\nfound = false;\r\nfse.pad = 0;\r\nfse.code = fmt->code;\r\nfse.which = V4L2_SUBDEV_FORMAT_ACTIVE;\r\nfor (fse.index = 0; ; fse.index++) {\r\nret = v4l2_subdev_call(ctx->sensor, pad, enum_frame_size,\r\nNULL, &fse);\r\nif (ret)\r\nbreak;\r\nif ((f->fmt.pix.width == fse.max_width) &&\r\n(f->fmt.pix.height == fse.max_height)) {\r\nfound = true;\r\nbreak;\r\n} else if ((f->fmt.pix.width >= fse.min_width) &&\r\n(f->fmt.pix.width <= fse.max_width) &&\r\n(f->fmt.pix.height >= fse.min_height) &&\r\n(f->fmt.pix.height <= fse.max_height)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nf->fmt.pix.width = ctx->v_fmt.fmt.pix.width;\r\nf->fmt.pix.height = ctx->v_fmt.fmt.pix.height;\r\n}\r\nf->fmt.pix.colorspace = ctx->v_fmt.fmt.pix.colorspace;\r\nreturn cal_calc_format_size(ctx, fmt, f);\r\n}\r\nstatic int cal_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nstruct vb2_queue *q = &ctx->vb_vidq;\r\nconst struct cal_fmt *fmt;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nif (vb2_is_busy(q)) {\r\nctx_dbg(3, ctx, "%s device busy\n", __func__);\r\nreturn -EBUSY;\r\n}\r\nret = cal_try_fmt_vid_cap(file, priv, f);\r\nif (ret < 0)\r\nreturn ret;\r\nfmt = find_format_by_pix(ctx, f->fmt.pix.pixelformat);\r\nv4l2_fill_mbus_format(&mbus_fmt, &f->fmt.pix, fmt->code);\r\nret = __subdev_set_format(ctx, &mbus_fmt);\r\nif (ret)\r\nreturn ret;\r\nif (mbus_fmt.code != fmt->code) {\r\nctx_dbg(3, ctx,\r\n"%s subdev changed format on us, this should not happen\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nv4l2_fill_pix_format(&ctx->v_fmt.fmt.pix, &mbus_fmt);\r\nctx->v_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nctx->v_fmt.fmt.pix.pixelformat = fmt->fourcc;\r\ncal_calc_format_size(ctx, fmt, &ctx->v_fmt);\r\nctx->fmt = fmt;\r\nctx->m_fmt = mbus_fmt;\r\n*f = ctx->v_fmt;\r\nreturn 0;\r\n}\r\nstatic int cal_enum_framesizes(struct file *file, void *fh,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nconst struct cal_fmt *fmt;\r\nstruct v4l2_subdev_frame_size_enum fse;\r\nint ret;\r\nfmt = find_format_by_pix(ctx, fsize->pixel_format);\r\nif (!fmt) {\r\nctx_dbg(3, ctx, "Invalid pixel code: %x\n",\r\nfsize->pixel_format);\r\nreturn -EINVAL;\r\n}\r\nfse.index = fsize->index;\r\nfse.pad = 0;\r\nfse.code = fmt->code;\r\nret = v4l2_subdev_call(ctx->sensor, pad, enum_frame_size, NULL, &fse);\r\nif (ret)\r\nreturn ret;\r\nctx_dbg(1, ctx, "%s: index: %d code: %x W:[%d,%d] H:[%d,%d]\n",\r\n__func__, fse.index, fse.code, fse.min_width, fse.max_width,\r\nfse.min_height, fse.max_height);\r\nfsize->type = V4L2_FRMSIZE_TYPE_DISCRETE;\r\nfsize->discrete.width = fse.max_width;\r\nfsize->discrete.height = fse.max_height;\r\nreturn 0;\r\n}\r\nstatic int cal_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *inp)\r\n{\r\nif (inp->index >= CAL_NUM_INPUT)\r\nreturn -EINVAL;\r\ninp->type = V4L2_INPUT_TYPE_CAMERA;\r\nsprintf(inp->name, "Camera %u", inp->index);\r\nreturn 0;\r\n}\r\nstatic int cal_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\n*i = ctx->input;\r\nreturn 0;\r\n}\r\nstatic int cal_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nif (i >= CAL_NUM_INPUT)\r\nreturn -EINVAL;\r\nctx->input = i;\r\nreturn 0;\r\n}\r\nstatic int cal_enum_frameintervals(struct file *file, void *priv,\r\nstruct v4l2_frmivalenum *fival)\r\n{\r\nstruct cal_ctx *ctx = video_drvdata(file);\r\nconst struct cal_fmt *fmt;\r\nstruct v4l2_subdev_frame_interval_enum fie = {\r\n.index = fival->index,\r\n.width = fival->width,\r\n.height = fival->height,\r\n.which = V4L2_SUBDEV_FORMAT_ACTIVE,\r\n};\r\nint ret;\r\nfmt = find_format_by_pix(ctx, fival->pixel_format);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nfie.code = fmt->code;\r\nret = v4l2_subdev_call(ctx->sensor, pad, enum_frame_interval,\r\nNULL, &fie);\r\nif (ret)\r\nreturn ret;\r\nfival->type = V4L2_FRMIVAL_TYPE_DISCRETE;\r\nfival->discrete = fie.interval;\r\nreturn 0;\r\n}\r\nstatic int cal_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct cal_ctx *ctx = vb2_get_drv_priv(vq);\r\nunsigned size = ctx->v_fmt.fmt.pix.sizeimage;\r\nif (vq->num_buffers + *nbuffers < 3)\r\n*nbuffers = 3 - vq->num_buffers;\r\nif (*nplanes) {\r\nif (sizes[0] < size)\r\nreturn -EINVAL;\r\nsize = sizes[0];\r\n}\r\n*nplanes = 1;\r\nsizes[0] = size;\r\nctx_dbg(3, ctx, "nbuffers=%d, size=%d\n", *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic int cal_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct cal_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct cal_buffer *buf = container_of(vb, struct cal_buffer,\r\nvb.vb2_buf);\r\nunsigned long size;\r\nif (WARN_ON(!ctx->fmt))\r\nreturn -EINVAL;\r\nsize = ctx->v_fmt.fmt.pix.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\nctx_err(ctx,\r\n"data will not fit into plane (%lu < %lu)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(&buf->vb.vb2_buf, 0, size);\r\nreturn 0;\r\n}\r\nstatic void cal_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct cal_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct cal_buffer *buf = container_of(vb, struct cal_buffer,\r\nvb.vb2_buf);\r\nstruct cal_dmaqueue *vidq = &ctx->vidq;\r\nunsigned long flags = 0;\r\nspin_lock_irqsave(&ctx->slock, flags);\r\nlist_add_tail(&buf->list, &vidq->active);\r\nspin_unlock_irqrestore(&ctx->slock, flags);\r\n}\r\nstatic int cal_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct cal_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct cal_dmaqueue *dma_q = &ctx->vidq;\r\nstruct cal_buffer *buf, *tmp;\r\nunsigned long addr = 0;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&ctx->slock, flags);\r\nif (list_empty(&dma_q->active)) {\r\nspin_unlock_irqrestore(&ctx->slock, flags);\r\nctx_dbg(3, ctx, "buffer queue is empty\n");\r\nreturn -EIO;\r\n}\r\nbuf = list_entry(dma_q->active.next, struct cal_buffer, list);\r\nctx->cur_frm = buf;\r\nctx->next_frm = buf;\r\nlist_del(&buf->list);\r\nspin_unlock_irqrestore(&ctx->slock, flags);\r\naddr = vb2_dma_contig_plane_dma_addr(&ctx->cur_frm->vb.vb2_buf, 0);\r\nctx->sequence = 0;\r\nret = cal_get_external_info(ctx);\r\nif (ret < 0)\r\ngoto err;\r\ncal_runtime_get(ctx->dev);\r\nenable_irqs(ctx);\r\ncamerarx_phy_enable(ctx);\r\ncsi2_init(ctx);\r\ncsi2_phy_config(ctx);\r\ncsi2_lane_config(ctx);\r\ncsi2_ctx_config(ctx);\r\npix_proc_config(ctx);\r\ncal_wr_dma_config(ctx, ctx->v_fmt.fmt.pix.bytesperline);\r\ncal_wr_dma_addr(ctx, addr);\r\ncsi2_ppi_enable(ctx);\r\nret = v4l2_subdev_call(ctx->sensor, video, s_stream, 1);\r\nif (ret) {\r\nctx_err(ctx, "stream on failed in subdev\n");\r\ncal_runtime_put(ctx->dev);\r\ngoto err;\r\n}\r\nif (debug >= 4)\r\ncal_quickdump_regs(ctx->dev);\r\nreturn 0;\r\nerr:\r\nlist_for_each_entry_safe(buf, tmp, &dma_q->active, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void cal_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct cal_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct cal_dmaqueue *dma_q = &ctx->vidq;\r\nstruct cal_buffer *buf, *tmp;\r\nunsigned long flags;\r\nif (v4l2_subdev_call(ctx->sensor, video, s_stream, 0))\r\nctx_err(ctx, "stream off failed in subdev\n");\r\ncsi2_ppi_disable(ctx);\r\ndisable_irqs(ctx);\r\nspin_lock_irqsave(&ctx->slock, flags);\r\nlist_for_each_entry_safe(buf, tmp, &dma_q->active, list) {\r\nlist_del(&buf->list);\r\nvb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n}\r\nif (ctx->cur_frm == ctx->next_frm) {\r\nvb2_buffer_done(&ctx->cur_frm->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\n} else {\r\nvb2_buffer_done(&ctx->cur_frm->vb.vb2_buf, VB2_BUF_STATE_ERROR);\r\nvb2_buffer_done(&ctx->next_frm->vb.vb2_buf,\r\nVB2_BUF_STATE_ERROR);\r\n}\r\nctx->cur_frm = NULL;\r\nctx->next_frm = NULL;\r\nspin_unlock_irqrestore(&ctx->slock, flags);\r\ncal_runtime_put(ctx->dev);\r\n}\r\nstatic int cal_async_bound(struct v4l2_async_notifier *notifier,\r\nstruct v4l2_subdev *subdev,\r\nstruct v4l2_async_subdev *asd)\r\n{\r\nstruct cal_ctx *ctx = notifier_to_ctx(notifier);\r\nstruct v4l2_subdev_mbus_code_enum mbus_code;\r\nint ret = 0;\r\nint i, j, k;\r\nif (ctx->sensor) {\r\nctx_info(ctx, "Rejecting subdev %s (Already set!!)",\r\nsubdev->name);\r\nreturn 0;\r\n}\r\nctx->sensor = subdev;\r\nctx_dbg(1, ctx, "Using sensor %s for capture\n", subdev->name);\r\nctx->num_active_fmt = 0;\r\nfor (j = 0, i = 0; ret != -EINVAL; ++j) {\r\nstruct cal_fmt *fmt;\r\nmemset(&mbus_code, 0, sizeof(mbus_code));\r\nmbus_code.index = j;\r\nret = v4l2_subdev_call(subdev, pad, enum_mbus_code,\r\nNULL, &mbus_code);\r\nif (ret)\r\ncontinue;\r\nctx_dbg(2, ctx,\r\n"subdev %s: code: %04x idx: %d\n",\r\nsubdev->name, mbus_code.code, j);\r\nfor (k = 0; k < ARRAY_SIZE(cal_formats); k++) {\r\nfmt = &cal_formats[k];\r\nif (mbus_code.code == fmt->code) {\r\nctx->active_fmt[i] = fmt;\r\nctx_dbg(2, ctx,\r\n"matched fourcc: %s: code: %04x idx: %d\n",\r\nfourcc_to_str(fmt->fourcc),\r\nfmt->code, i);\r\nctx->num_active_fmt = ++i;\r\n}\r\n}\r\n}\r\nif (i == 0) {\r\nctx_err(ctx, "No suitable format reported by subdev %s\n",\r\nsubdev->name);\r\nreturn -EINVAL;\r\n}\r\ncal_complete_ctx(ctx);\r\nreturn 0;\r\n}\r\nstatic int cal_async_complete(struct v4l2_async_notifier *notifier)\r\n{\r\nstruct cal_ctx *ctx = notifier_to_ctx(notifier);\r\nconst struct cal_fmt *fmt;\r\nstruct v4l2_mbus_framefmt mbus_fmt;\r\nint ret;\r\nret = __subdev_get_format(ctx, &mbus_fmt);\r\nif (ret)\r\nreturn ret;\r\nfmt = find_format_by_code(ctx, mbus_fmt.code);\r\nif (!fmt) {\r\nctx_dbg(3, ctx, "mbus code format (0x%08x) not found.\n",\r\nmbus_fmt.code);\r\nreturn -EINVAL;\r\n}\r\nv4l2_fill_pix_format(&ctx->v_fmt.fmt.pix, &mbus_fmt);\r\nctx->v_fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nctx->v_fmt.fmt.pix.pixelformat = fmt->fourcc;\r\ncal_calc_format_size(ctx, fmt, &ctx->v_fmt);\r\nctx->fmt = fmt;\r\nctx->m_fmt = mbus_fmt;\r\nreturn 0;\r\n}\r\nstatic int cal_complete_ctx(struct cal_ctx *ctx)\r\n{\r\nstruct video_device *vfd;\r\nstruct vb2_queue *q;\r\nint ret;\r\nctx->timeperframe = tpf_default;\r\nctx->external_rate = 192000000;\r\nspin_lock_init(&ctx->slock);\r\nmutex_init(&ctx->mutex);\r\nq = &ctx->vb_vidq;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\r\nq->drv_priv = ctx;\r\nq->buf_struct_size = sizeof(struct cal_buffer);\r\nq->ops = &cal_video_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->lock = &ctx->mutex;\r\nq->min_buffers_needed = 3;\r\nq->dev = ctx->v4l2_dev.dev;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\nreturn ret;\r\nINIT_LIST_HEAD(&ctx->vidq.active);\r\nvfd = &ctx->vdev;\r\n*vfd = cal_videodev;\r\nvfd->v4l2_dev = &ctx->v4l2_dev;\r\nvfd->queue = q;\r\nvfd->lock = &ctx->mutex;\r\nvideo_set_drvdata(vfd, ctx);\r\nret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);\r\nif (ret < 0)\r\nreturn ret;\r\nv4l2_info(&ctx->v4l2_dev, "V4L2 device registered as %s\n",\r\nvideo_device_node_name(vfd));\r\nreturn 0;\r\n}\r\nstatic struct device_node *\r\nof_get_next_port(const struct device_node *parent,\r\nstruct device_node *prev)\r\n{\r\nstruct device_node *port = NULL;\r\nif (!parent)\r\nreturn NULL;\r\nif (!prev) {\r\nstruct device_node *ports;\r\nports = of_get_child_by_name(parent, "ports");\r\nif (ports)\r\nparent = ports;\r\nport = of_get_child_by_name(parent, "port");\r\nof_node_put(ports);\r\n} else {\r\nstruct device_node *ports;\r\nports = of_get_parent(prev);\r\nif (!ports)\r\nreturn NULL;\r\ndo {\r\nport = of_get_next_child(ports, prev);\r\nif (!port) {\r\nof_node_put(ports);\r\nreturn NULL;\r\n}\r\nprev = port;\r\n} while (of_node_cmp(port->name, "port") != 0);\r\n}\r\nreturn port;\r\n}\r\nstatic struct device_node *\r\nof_get_next_endpoint(const struct device_node *parent,\r\nstruct device_node *prev)\r\n{\r\nstruct device_node *ep = NULL;\r\nif (!parent)\r\nreturn NULL;\r\ndo {\r\nep = of_get_next_child(parent, prev);\r\nif (!ep)\r\nreturn NULL;\r\nprev = ep;\r\n} while (of_node_cmp(ep->name, "endpoint") != 0);\r\nreturn ep;\r\n}\r\nstatic int of_cal_create_instance(struct cal_ctx *ctx, int inst)\r\n{\r\nstruct platform_device *pdev = ctx->dev->pdev;\r\nstruct device_node *ep_node, *port, *remote_ep,\r\n*sensor_node, *parent;\r\nstruct v4l2_of_endpoint *endpoint;\r\nstruct v4l2_async_subdev *asd;\r\nu32 regval = 0;\r\nint ret, index, found_port = 0, lane;\r\nparent = pdev->dev.of_node;\r\nasd = &ctx->asd;\r\nendpoint = &ctx->endpoint;\r\nep_node = NULL;\r\nport = NULL;\r\nremote_ep = NULL;\r\nsensor_node = NULL;\r\nret = -EINVAL;\r\nctx_dbg(3, ctx, "Scanning Port node for csi2 port: %d\n", inst);\r\nfor (index = 0; index < CAL_NUM_CSI2_PORTS; index++) {\r\nport = of_get_next_port(parent, port);\r\nif (!port) {\r\nctx_dbg(1, ctx, "No port node found for csi2 port:%d\n",\r\nindex);\r\ngoto cleanup_exit;\r\n}\r\nof_property_read_u32(port, "reg", &regval);\r\nctx_dbg(3, ctx, "port:%d inst:%d <reg>:%d\n",\r\nindex, inst, regval);\r\nif ((regval == inst) && (index == inst)) {\r\nfound_port = 1;\r\nbreak;\r\n}\r\n}\r\nif (!found_port) {\r\nctx_dbg(1, ctx, "No port node matches csi2 port:%d\n",\r\ninst);\r\ngoto cleanup_exit;\r\n}\r\nctx_dbg(3, ctx, "Scanning sub-device for csi2 port: %d\n",\r\ninst);\r\nep_node = of_get_next_endpoint(port, ep_node);\r\nif (!ep_node) {\r\nctx_dbg(3, ctx, "can't get next endpoint\n");\r\ngoto cleanup_exit;\r\n}\r\nsensor_node = of_graph_get_remote_port_parent(ep_node);\r\nif (!sensor_node) {\r\nctx_dbg(3, ctx, "can't get remote parent\n");\r\ngoto cleanup_exit;\r\n}\r\nasd->match_type = V4L2_ASYNC_MATCH_OF;\r\nasd->match.of.node = sensor_node;\r\nremote_ep = of_parse_phandle(ep_node, "remote-endpoint", 0);\r\nif (!remote_ep) {\r\nctx_dbg(3, ctx, "can't get remote-endpoint\n");\r\ngoto cleanup_exit;\r\n}\r\nv4l2_of_parse_endpoint(remote_ep, endpoint);\r\nif (endpoint->bus_type != V4L2_MBUS_CSI2) {\r\nctx_err(ctx, "Port:%d sub-device %s is not a CSI2 device\n",\r\ninst, sensor_node->name);\r\ngoto cleanup_exit;\r\n}\r\nctx->virtual_channel = endpoint->base.id;\r\nctx_dbg(3, ctx, "Port:%d v4l2-endpoint: CSI2\n", inst);\r\nctx_dbg(3, ctx, "Virtual Channel=%d\n", ctx->virtual_channel);\r\nctx_dbg(3, ctx, "flags=0x%08x\n", endpoint->bus.mipi_csi2.flags);\r\nctx_dbg(3, ctx, "clock_lane=%d\n", endpoint->bus.mipi_csi2.clock_lane);\r\nctx_dbg(3, ctx, "num_data_lanes=%d\n",\r\nendpoint->bus.mipi_csi2.num_data_lanes);\r\nctx_dbg(3, ctx, "data_lanes= <\n");\r\nfor (lane = 0; lane < endpoint->bus.mipi_csi2.num_data_lanes; lane++)\r\nctx_dbg(3, ctx, "\t%d\n",\r\nendpoint->bus.mipi_csi2.data_lanes[lane]);\r\nctx_dbg(3, ctx, "\t>\n");\r\nctx_dbg(1, ctx, "Port: %d found sub-device %s\n",\r\ninst, sensor_node->name);\r\nctx->asd_list[0] = asd;\r\nctx->notifier.subdevs = ctx->asd_list;\r\nctx->notifier.num_subdevs = 1;\r\nctx->notifier.bound = cal_async_bound;\r\nctx->notifier.complete = cal_async_complete;\r\nret = v4l2_async_notifier_register(&ctx->v4l2_dev,\r\n&ctx->notifier);\r\nif (ret) {\r\nctx_err(ctx, "Error registering async notifier\n");\r\nret = -EINVAL;\r\n}\r\ncleanup_exit:\r\nif (remote_ep)\r\nof_node_put(remote_ep);\r\nif (sensor_node)\r\nof_node_put(sensor_node);\r\nif (ep_node)\r\nof_node_put(ep_node);\r\nif (port)\r\nof_node_put(port);\r\nreturn ret;\r\n}\r\nstatic struct cal_ctx *cal_create_instance(struct cal_dev *dev, int inst)\r\n{\r\nstruct cal_ctx *ctx;\r\nstruct v4l2_ctrl_handler *hdl;\r\nint ret;\r\nctx = devm_kzalloc(&dev->pdev->dev, sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn NULL;\r\nctx->dev = dev;\r\nsnprintf(ctx->v4l2_dev.name, sizeof(ctx->v4l2_dev.name),\r\n"%s-%03d", CAL_MODULE_NAME, inst);\r\nret = v4l2_device_register(&dev->pdev->dev, &ctx->v4l2_dev);\r\nif (ret)\r\ngoto err_exit;\r\nhdl = &ctx->ctrl_handler;\r\nret = v4l2_ctrl_handler_init(hdl, 11);\r\nif (ret) {\r\nctx_err(ctx, "Failed to init ctrl handler\n");\r\ngoto unreg_dev;\r\n}\r\nctx->v4l2_dev.ctrl_handler = hdl;\r\nctx->cc = dev->cc[inst];\r\nctx->csi2_port = inst + 1;\r\nret = of_cal_create_instance(ctx, inst);\r\nif (ret) {\r\nret = -EINVAL;\r\ngoto free_hdl;\r\n}\r\nreturn ctx;\r\nfree_hdl:\r\nv4l2_ctrl_handler_free(hdl);\r\nunreg_dev:\r\nv4l2_device_unregister(&ctx->v4l2_dev);\r\nerr_exit:\r\nreturn NULL;\r\n}\r\nstatic int cal_probe(struct platform_device *pdev)\r\n{\r\nstruct cal_dev *dev;\r\nint ret;\r\nint irq;\r\ndev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\nstrlcpy(dev->v4l2_dev.name, CAL_MODULE_NAME,\r\nsizeof(dev->v4l2_dev.name));\r\ndev->pdev = pdev;\r\ndev->res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"cal_top");\r\ndev->base = devm_ioremap_resource(&pdev->dev, dev->res);\r\nif (IS_ERR(dev->base))\r\nreturn PTR_ERR(dev->base);\r\ncal_dbg(1, dev, "ioresource %s at %pa - %pa\n",\r\ndev->res->name, &dev->res->start, &dev->res->end);\r\nirq = platform_get_irq(pdev, 0);\r\ncal_dbg(1, dev, "got irq# %d\n", irq);\r\nret = devm_request_irq(&pdev->dev, irq, cal_irq, 0, CAL_MODULE_NAME,\r\ndev);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, dev);\r\ndev->cm = cm_create(dev);\r\nif (IS_ERR(dev->cm))\r\nreturn PTR_ERR(dev->cm);\r\ndev->cc[0] = cc_create(dev, 0);\r\nif (IS_ERR(dev->cc[0]))\r\nreturn PTR_ERR(dev->cc[0]);\r\ndev->cc[1] = cc_create(dev, 1);\r\nif (IS_ERR(dev->cc[1]))\r\nreturn PTR_ERR(dev->cc[1]);\r\ndev->ctx[0] = NULL;\r\ndev->ctx[1] = NULL;\r\ndev->ctx[0] = cal_create_instance(dev, 0);\r\ndev->ctx[1] = cal_create_instance(dev, 1);\r\nif (!dev->ctx[0] && !dev->ctx[1]) {\r\ncal_err(dev, "Neither port is configured, no point in staying up\n");\r\nreturn -ENODEV;\r\n}\r\npm_runtime_enable(&pdev->dev);\r\nret = cal_runtime_get(dev);\r\nif (ret)\r\ngoto runtime_disable;\r\ncal_get_hwinfo(dev);\r\ncal_runtime_put(dev);\r\nreturn 0;\r\nruntime_disable:\r\npm_runtime_disable(&pdev->dev);\r\nreturn ret;\r\n}\r\nstatic int cal_remove(struct platform_device *pdev)\r\n{\r\nstruct cal_dev *dev =\r\n(struct cal_dev *)platform_get_drvdata(pdev);\r\nstruct cal_ctx *ctx;\r\nint i;\r\ncal_dbg(1, dev, "Removing %s\n", CAL_MODULE_NAME);\r\ncal_runtime_get(dev);\r\nfor (i = 0; i < CAL_NUM_CONTEXT; i++) {\r\nctx = dev->ctx[i];\r\nif (ctx) {\r\nctx_dbg(1, ctx, "unregistering %s\n",\r\nvideo_device_node_name(&ctx->vdev));\r\ncamerarx_phy_disable(ctx);\r\nv4l2_async_notifier_unregister(&ctx->notifier);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_device_unregister(&ctx->v4l2_dev);\r\nvideo_unregister_device(&ctx->vdev);\r\n}\r\n}\r\ncal_runtime_put(dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn 0;\r\n}
