static void batadv_v_iface_activate(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hard_iface *primary_if;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (primary_if) {\r\nbatadv_v_elp_iface_activate(primary_if, hard_iface);\r\nbatadv_hardif_put(primary_if);\r\n}\r\nif (hard_iface->if_status == BATADV_IF_TO_BE_ACTIVATED)\r\nhard_iface->if_status = BATADV_IF_ACTIVE;\r\n}\r\nstatic int batadv_v_iface_enable(struct batadv_hard_iface *hard_iface)\r\n{\r\nint ret;\r\nret = batadv_v_elp_iface_enable(hard_iface);\r\nif (ret < 0)\r\nreturn ret;\r\nret = batadv_v_ogm_iface_enable(hard_iface);\r\nif (ret < 0)\r\nbatadv_v_elp_iface_disable(hard_iface);\r\nreturn ret;\r\n}\r\nstatic void batadv_v_iface_disable(struct batadv_hard_iface *hard_iface)\r\n{\r\nbatadv_v_elp_iface_disable(hard_iface);\r\n}\r\nstatic void batadv_v_primary_iface_set(struct batadv_hard_iface *hard_iface)\r\n{\r\nbatadv_v_elp_primary_iface_set(hard_iface);\r\nbatadv_v_ogm_primary_iface_set(hard_iface);\r\n}\r\nstatic void batadv_v_iface_update_mac(struct batadv_hard_iface *hard_iface)\r\n{\r\nstruct batadv_priv *bat_priv = netdev_priv(hard_iface->soft_iface);\r\nstruct batadv_hard_iface *primary_if;\r\nprimary_if = batadv_primary_if_get_selected(bat_priv);\r\nif (primary_if != hard_iface)\r\ngoto out;\r\nbatadv_v_primary_iface_set(hard_iface);\r\nout:\r\nif (primary_if)\r\nbatadv_hardif_put(primary_if);\r\n}\r\nstatic void\r\nbatadv_v_hardif_neigh_init(struct batadv_hardif_neigh_node *hardif_neigh)\r\n{\r\newma_throughput_init(&hardif_neigh->bat_v.throughput);\r\nINIT_WORK(&hardif_neigh->bat_v.metric_work,\r\nbatadv_v_elp_throughput_metric_update);\r\n}\r\nstatic void\r\nbatadv_v_orig_print_neigh(struct batadv_orig_node *orig_node,\r\nstruct batadv_hard_iface *if_outgoing,\r\nstruct seq_file *seq)\r\n{\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_neigh_ifinfo *n_ifinfo;\r\nhlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\r\nn_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\r\nif (!n_ifinfo)\r\ncontinue;\r\nseq_printf(seq, " %pM (%9u.%1u)",\r\nneigh_node->addr,\r\nn_ifinfo->bat_v.throughput / 10,\r\nn_ifinfo->bat_v.throughput % 10);\r\nbatadv_neigh_ifinfo_put(n_ifinfo);\r\n}\r\n}\r\nstatic void\r\nbatadv_v_hardif_neigh_print(struct seq_file *seq,\r\nstruct batadv_hardif_neigh_node *hardif_neigh)\r\n{\r\nint last_secs, last_msecs;\r\nu32 throughput;\r\nlast_secs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen) / 1000;\r\nlast_msecs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen) % 1000;\r\nthroughput = ewma_throughput_read(&hardif_neigh->bat_v.throughput);\r\nseq_printf(seq, "%pM %4i.%03is (%9u.%1u) [%10s]\n",\r\nhardif_neigh->addr, last_secs, last_msecs, throughput / 10,\r\nthroughput % 10, hardif_neigh->if_incoming->net_dev->name);\r\n}\r\nstatic void batadv_v_neigh_print(struct batadv_priv *bat_priv,\r\nstruct seq_file *seq)\r\n{\r\nstruct net_device *net_dev = (struct net_device *)seq->private;\r\nstruct batadv_hardif_neigh_node *hardif_neigh;\r\nstruct batadv_hard_iface *hard_iface;\r\nint batman_count = 0;\r\nseq_puts(seq,\r\n" Neighbor last-seen ( throughput) [ IF]\n");\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface != net_dev)\r\ncontinue;\r\nhlist_for_each_entry_rcu(hardif_neigh,\r\n&hard_iface->neigh_list, list) {\r\nbatadv_v_hardif_neigh_print(seq, hardif_neigh);\r\nbatman_count++;\r\n}\r\n}\r\nrcu_read_unlock();\r\nif (batman_count == 0)\r\nseq_puts(seq, "No batman nodes in range ...\n");\r\n}\r\nstatic int\r\nbatadv_v_neigh_dump_neigh(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_hardif_neigh_node *hardif_neigh)\r\n{\r\nvoid *hdr;\r\nunsigned int last_seen_msecs;\r\nu32 throughput;\r\nlast_seen_msecs = jiffies_to_msecs(jiffies - hardif_neigh->last_seen);\r\nthroughput = ewma_throughput_read(&hardif_neigh->bat_v.throughput);\r\nthroughput = throughput * 100;\r\nhdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,\r\nBATADV_CMD_GET_NEIGHBORS);\r\nif (!hdr)\r\nreturn -ENOBUFS;\r\nif (nla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,\r\nhardif_neigh->addr) ||\r\nnla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\r\nhardif_neigh->if_incoming->net_dev->ifindex) ||\r\nnla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,\r\nlast_seen_msecs) ||\r\nnla_put_u32(msg, BATADV_ATTR_THROUGHPUT, throughput))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nbatadv_v_neigh_dump_hardif(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *hard_iface,\r\nint *idx_s)\r\n{\r\nstruct batadv_hardif_neigh_node *hardif_neigh;\r\nint idx = 0;\r\nhlist_for_each_entry_rcu(hardif_neigh,\r\n&hard_iface->neigh_list, list) {\r\nif (idx++ < *idx_s)\r\ncontinue;\r\nif (batadv_v_neigh_dump_neigh(msg, portid, seq, hardif_neigh)) {\r\n*idx_s = idx - 1;\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\n*idx_s = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nbatadv_v_neigh_dump(struct sk_buff *msg, struct netlink_callback *cb,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *single_hardif)\r\n{\r\nstruct batadv_hard_iface *hard_iface;\r\nint i_hardif = 0;\r\nint i_hardif_s = cb->args[0];\r\nint idx = cb->args[1];\r\nint portid = NETLINK_CB(cb->skb).portid;\r\nrcu_read_lock();\r\nif (single_hardif) {\r\nif (i_hardif_s == 0) {\r\nif (batadv_v_neigh_dump_hardif(msg, portid,\r\ncb->nlh->nlmsg_seq,\r\nbat_priv, single_hardif,\r\n&idx) == 0)\r\ni_hardif++;\r\n}\r\n} else {\r\nlist_for_each_entry_rcu(hard_iface, &batadv_hardif_list, list) {\r\nif (hard_iface->soft_iface != bat_priv->soft_iface)\r\ncontinue;\r\nif (i_hardif++ < i_hardif_s)\r\ncontinue;\r\nif (batadv_v_neigh_dump_hardif(msg, portid,\r\ncb->nlh->nlmsg_seq,\r\nbat_priv, hard_iface,\r\n&idx)) {\r\ni_hardif--;\r\nbreak;\r\n}\r\n}\r\n}\r\nrcu_read_unlock();\r\ncb->args[0] = i_hardif;\r\ncb->args[1] = idx;\r\n}\r\nstatic void batadv_v_orig_print(struct batadv_priv *bat_priv,\r\nstruct seq_file *seq,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_neigh_node *neigh_node;\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nint last_seen_msecs, last_seen_secs;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_neigh_ifinfo *n_ifinfo;\r\nunsigned long last_seen_jiffies;\r\nstruct hlist_head *head;\r\nint batman_count = 0;\r\nu32 i;\r\nseq_puts(seq,\r\n" Originator last-seen ( throughput) Nexthop [outgoingIF]: Potential nexthops ...\n");\r\nfor (i = 0; i < hash->size; i++) {\r\nhead = &hash->table[i];\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nneigh_node = batadv_orig_router_get(orig_node,\r\nif_outgoing);\r\nif (!neigh_node)\r\ncontinue;\r\nn_ifinfo = batadv_neigh_ifinfo_get(neigh_node,\r\nif_outgoing);\r\nif (!n_ifinfo)\r\ngoto next;\r\nlast_seen_jiffies = jiffies - orig_node->last_seen;\r\nlast_seen_msecs = jiffies_to_msecs(last_seen_jiffies);\r\nlast_seen_secs = last_seen_msecs / 1000;\r\nlast_seen_msecs = last_seen_msecs % 1000;\r\nseq_printf(seq, "%pM %4i.%03is (%9u.%1u) %pM [%10s]:",\r\norig_node->orig, last_seen_secs,\r\nlast_seen_msecs,\r\nn_ifinfo->bat_v.throughput / 10,\r\nn_ifinfo->bat_v.throughput % 10,\r\nneigh_node->addr,\r\nneigh_node->if_incoming->net_dev->name);\r\nbatadv_v_orig_print_neigh(orig_node, if_outgoing, seq);\r\nseq_puts(seq, "\n");\r\nbatman_count++;\r\nnext:\r\nbatadv_neigh_node_put(neigh_node);\r\nif (n_ifinfo)\r\nbatadv_neigh_ifinfo_put(n_ifinfo);\r\n}\r\nrcu_read_unlock();\r\n}\r\nif (batman_count == 0)\r\nseq_puts(seq, "No batman nodes in range ...\n");\r\n}\r\nstatic int\r\nbatadv_v_orig_dump_subentry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *if_outgoing,\r\nstruct batadv_orig_node *orig_node,\r\nstruct batadv_neigh_node *neigh_node,\r\nbool best)\r\n{\r\nstruct batadv_neigh_ifinfo *n_ifinfo;\r\nunsigned int last_seen_msecs;\r\nu32 throughput;\r\nvoid *hdr;\r\nn_ifinfo = batadv_neigh_ifinfo_get(neigh_node, if_outgoing);\r\nif (!n_ifinfo)\r\nreturn 0;\r\nthroughput = n_ifinfo->bat_v.throughput * 100;\r\nbatadv_neigh_ifinfo_put(n_ifinfo);\r\nlast_seen_msecs = jiffies_to_msecs(jiffies - orig_node->last_seen);\r\nif (if_outgoing != BATADV_IF_DEFAULT &&\r\nif_outgoing != neigh_node->if_incoming)\r\nreturn 0;\r\nhdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family, NLM_F_MULTI,\r\nBATADV_CMD_GET_ORIGINATORS);\r\nif (!hdr)\r\nreturn -ENOBUFS;\r\nif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN, orig_node->orig) ||\r\nnla_put(msg, BATADV_ATTR_NEIGH_ADDRESS, ETH_ALEN,\r\nneigh_node->addr) ||\r\nnla_put_u32(msg, BATADV_ATTR_HARD_IFINDEX,\r\nneigh_node->if_incoming->net_dev->ifindex) ||\r\nnla_put_u32(msg, BATADV_ATTR_THROUGHPUT, throughput) ||\r\nnla_put_u32(msg, BATADV_ATTR_LAST_SEEN_MSECS,\r\nlast_seen_msecs))\r\ngoto nla_put_failure;\r\nif (best && nla_put_flag(msg, BATADV_ATTR_FLAG_BEST))\r\ngoto nla_put_failure;\r\ngenlmsg_end(msg, hdr);\r\nreturn 0;\r\nnla_put_failure:\r\ngenlmsg_cancel(msg, hdr);\r\nreturn -EMSGSIZE;\r\n}\r\nstatic int\r\nbatadv_v_orig_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *if_outgoing,\r\nstruct batadv_orig_node *orig_node, int *sub_s)\r\n{\r\nstruct batadv_neigh_node *neigh_node_best;\r\nstruct batadv_neigh_node *neigh_node;\r\nint sub = 0;\r\nbool best;\r\nneigh_node_best = batadv_orig_router_get(orig_node, if_outgoing);\r\nif (!neigh_node_best)\r\ngoto out;\r\nhlist_for_each_entry_rcu(neigh_node, &orig_node->neigh_list, list) {\r\nif (sub++ < *sub_s)\r\ncontinue;\r\nbest = (neigh_node == neigh_node_best);\r\nif (batadv_v_orig_dump_subentry(msg, portid, seq, bat_priv,\r\nif_outgoing, orig_node,\r\nneigh_node, best)) {\r\nbatadv_neigh_node_put(neigh_node_best);\r\n*sub_s = sub - 1;\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\nout:\r\nif (neigh_node_best)\r\nbatadv_neigh_node_put(neigh_node_best);\r\n*sub_s = 0;\r\nreturn 0;\r\n}\r\nstatic int\r\nbatadv_v_orig_dump_bucket(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *if_outgoing,\r\nstruct hlist_head *head, int *idx_s, int *sub)\r\n{\r\nstruct batadv_orig_node *orig_node;\r\nint idx = 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(orig_node, head, hash_entry) {\r\nif (idx++ < *idx_s)\r\ncontinue;\r\nif (batadv_v_orig_dump_entry(msg, portid, seq, bat_priv,\r\nif_outgoing, orig_node, sub)) {\r\nrcu_read_unlock();\r\n*idx_s = idx - 1;\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\nrcu_read_unlock();\r\n*idx_s = 0;\r\n*sub = 0;\r\nreturn 0;\r\n}\r\nstatic void\r\nbatadv_v_orig_dump(struct sk_buff *msg, struct netlink_callback *cb,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_hard_iface *if_outgoing)\r\n{\r\nstruct batadv_hashtable *hash = bat_priv->orig_hash;\r\nstruct hlist_head *head;\r\nint bucket = cb->args[0];\r\nint idx = cb->args[1];\r\nint sub = cb->args[2];\r\nint portid = NETLINK_CB(cb->skb).portid;\r\nwhile (bucket < hash->size) {\r\nhead = &hash->table[bucket];\r\nif (batadv_v_orig_dump_bucket(msg, portid,\r\ncb->nlh->nlmsg_seq,\r\nbat_priv, if_outgoing, head, &idx,\r\n&sub))\r\nbreak;\r\nbucket++;\r\n}\r\ncb->args[0] = bucket;\r\ncb->args[1] = idx;\r\ncb->args[2] = sub;\r\n}\r\nstatic int batadv_v_neigh_cmp(struct batadv_neigh_node *neigh1,\r\nstruct batadv_hard_iface *if_outgoing1,\r\nstruct batadv_neigh_node *neigh2,\r\nstruct batadv_hard_iface *if_outgoing2)\r\n{\r\nstruct batadv_neigh_ifinfo *ifinfo1, *ifinfo2;\r\nint ret = 0;\r\nifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\r\nif (WARN_ON(!ifinfo1))\r\ngoto err_ifinfo1;\r\nifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\r\nif (WARN_ON(!ifinfo2))\r\ngoto err_ifinfo2;\r\nret = ifinfo1->bat_v.throughput - ifinfo2->bat_v.throughput;\r\nbatadv_neigh_ifinfo_put(ifinfo2);\r\nerr_ifinfo2:\r\nbatadv_neigh_ifinfo_put(ifinfo1);\r\nerr_ifinfo1:\r\nreturn ret;\r\n}\r\nstatic bool batadv_v_neigh_is_sob(struct batadv_neigh_node *neigh1,\r\nstruct batadv_hard_iface *if_outgoing1,\r\nstruct batadv_neigh_node *neigh2,\r\nstruct batadv_hard_iface *if_outgoing2)\r\n{\r\nstruct batadv_neigh_ifinfo *ifinfo1, *ifinfo2;\r\nu32 threshold;\r\nbool ret = false;\r\nifinfo1 = batadv_neigh_ifinfo_get(neigh1, if_outgoing1);\r\nif (WARN_ON(!ifinfo1))\r\ngoto err_ifinfo1;\r\nifinfo2 = batadv_neigh_ifinfo_get(neigh2, if_outgoing2);\r\nif (WARN_ON(!ifinfo2))\r\ngoto err_ifinfo2;\r\nthreshold = ifinfo1->bat_v.throughput / 4;\r\nthreshold = ifinfo1->bat_v.throughput - threshold;\r\nret = ifinfo2->bat_v.throughput > threshold;\r\nbatadv_neigh_ifinfo_put(ifinfo2);\r\nerr_ifinfo2:\r\nbatadv_neigh_ifinfo_put(ifinfo1);\r\nerr_ifinfo1:\r\nreturn ret;\r\n}\r\nstatic void batadv_v_init_sel_class(struct batadv_priv *bat_priv)\r\n{\r\natomic_set(&bat_priv->gw.sel_class, 50);\r\n}\r\nstatic ssize_t batadv_v_store_sel_class(struct batadv_priv *bat_priv,\r\nchar *buff, size_t count)\r\n{\r\nu32 old_class, class;\r\nif (!batadv_parse_throughput(bat_priv->soft_iface, buff,\r\n"B.A.T.M.A.N. V GW selection class",\r\n&class))\r\nreturn -EINVAL;\r\nold_class = atomic_read(&bat_priv->gw.sel_class);\r\natomic_set(&bat_priv->gw.sel_class, class);\r\nif (old_class != class)\r\nbatadv_gw_reselect(bat_priv);\r\nreturn count;\r\n}\r\nstatic ssize_t batadv_v_show_sel_class(struct batadv_priv *bat_priv, char *buff)\r\n{\r\nu32 class = atomic_read(&bat_priv->gw.sel_class);\r\nreturn sprintf(buff, "%u.%u MBit\n", class / 10, class % 10);\r\n}\r\nstatic int batadv_v_gw_throughput_get(struct batadv_gw_node *gw_node, u32 *bw)\r\n{\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nstruct batadv_orig_node *orig_node;\r\nstruct batadv_neigh_node *router;\r\nint ret = -1;\r\norig_node = gw_node->orig_node;\r\nrouter = batadv_orig_router_get(orig_node, BATADV_IF_DEFAULT);\r\nif (!router)\r\ngoto out;\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\r\nif (!router_ifinfo)\r\ngoto out;\r\n*bw = router_ifinfo->bat_v.throughput;\r\n*bw = min_t(u32, *bw, gw_node->bandwidth_down);\r\nret = 0;\r\nout:\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_ifinfo);\r\nreturn ret;\r\n}\r\nstatic struct batadv_gw_node *\r\nbatadv_v_gw_get_best_gw_node(struct batadv_priv *bat_priv)\r\n{\r\nstruct batadv_gw_node *gw_node, *curr_gw = NULL;\r\nu32 max_bw = 0, bw;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {\r\nif (!kref_get_unless_zero(&gw_node->refcount))\r\ncontinue;\r\nif (batadv_v_gw_throughput_get(gw_node, &bw) < 0)\r\ngoto next;\r\nif (curr_gw && (bw <= max_bw))\r\ngoto next;\r\nif (curr_gw)\r\nbatadv_gw_node_put(curr_gw);\r\ncurr_gw = gw_node;\r\nkref_get(&curr_gw->refcount);\r\nmax_bw = bw;\r\nnext:\r\nbatadv_gw_node_put(gw_node);\r\n}\r\nrcu_read_unlock();\r\nreturn curr_gw;\r\n}\r\nstatic bool batadv_v_gw_is_eligible(struct batadv_priv *bat_priv,\r\nstruct batadv_orig_node *curr_gw_orig,\r\nstruct batadv_orig_node *orig_node)\r\n{\r\nstruct batadv_gw_node *curr_gw, *orig_gw = NULL;\r\nu32 gw_throughput, orig_throughput, threshold;\r\nbool ret = false;\r\nthreshold = atomic_read(&bat_priv->gw.sel_class);\r\ncurr_gw = batadv_gw_node_get(bat_priv, curr_gw_orig);\r\nif (!curr_gw) {\r\nret = true;\r\ngoto out;\r\n}\r\nif (batadv_v_gw_throughput_get(curr_gw, &gw_throughput) < 0) {\r\nret = true;\r\ngoto out;\r\n}\r\norig_gw = batadv_gw_node_get(bat_priv, orig_node);\r\nif (!orig_node)\r\ngoto out;\r\nif (batadv_v_gw_throughput_get(orig_gw, &orig_throughput) < 0)\r\ngoto out;\r\nif (orig_throughput < gw_throughput)\r\ngoto out;\r\nif ((orig_throughput - gw_throughput) < threshold)\r\ngoto out;\r\nbatadv_dbg(BATADV_DBG_BATMAN, bat_priv,\r\n"Restarting gateway selection: better gateway found (throughput curr: %u, throughput new: %u)\n",\r\ngw_throughput, orig_throughput);\r\nret = true;\r\nout:\r\nif (curr_gw)\r\nbatadv_gw_node_put(curr_gw);\r\nif (orig_gw)\r\nbatadv_gw_node_put(orig_gw);\r\nreturn ret;\r\n}\r\nstatic int batadv_v_gw_write_buffer_text(struct batadv_priv *bat_priv,\r\nstruct seq_file *seq,\r\nconst struct batadv_gw_node *gw_node)\r\n{\r\nstruct batadv_gw_node *curr_gw;\r\nstruct batadv_neigh_node *router;\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nint ret = -1;\r\nrouter = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);\r\nif (!router)\r\ngoto out;\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\r\nif (!router_ifinfo)\r\ngoto out;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nseq_printf(seq, "%s %pM (%9u.%1u) %pM [%10s]: %u.%u/%u.%u MBit\n",\r\n(curr_gw == gw_node ? "=>" : " "),\r\ngw_node->orig_node->orig,\r\nrouter_ifinfo->bat_v.throughput / 10,\r\nrouter_ifinfo->bat_v.throughput % 10, router->addr,\r\nrouter->if_incoming->net_dev->name,\r\ngw_node->bandwidth_down / 10,\r\ngw_node->bandwidth_down % 10,\r\ngw_node->bandwidth_up / 10,\r\ngw_node->bandwidth_up % 10);\r\nret = seq_has_overflowed(seq) ? -1 : 0;\r\nif (curr_gw)\r\nbatadv_gw_node_put(curr_gw);\r\nout:\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_ifinfo);\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\nreturn ret;\r\n}\r\nstatic void batadv_v_gw_print(struct batadv_priv *bat_priv,\r\nstruct seq_file *seq)\r\n{\r\nstruct batadv_gw_node *gw_node;\r\nint gw_count = 0;\r\nseq_puts(seq,\r\n" Gateway ( throughput) Nexthop [outgoingIF]: advertised uplink bandwidth\n");\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {\r\nif (batadv_v_gw_write_buffer_text(bat_priv, seq, gw_node) < 0)\r\ncontinue;\r\ngw_count++;\r\n}\r\nrcu_read_unlock();\r\nif (gw_count == 0)\r\nseq_puts(seq, "No gateways in range ...\n");\r\n}\r\nstatic int batadv_v_gw_dump_entry(struct sk_buff *msg, u32 portid, u32 seq,\r\nstruct batadv_priv *bat_priv,\r\nstruct batadv_gw_node *gw_node)\r\n{\r\nstruct batadv_neigh_ifinfo *router_ifinfo = NULL;\r\nstruct batadv_neigh_node *router;\r\nstruct batadv_gw_node *curr_gw;\r\nint ret = -EINVAL;\r\nvoid *hdr;\r\nrouter = batadv_orig_router_get(gw_node->orig_node, BATADV_IF_DEFAULT);\r\nif (!router)\r\ngoto out;\r\nrouter_ifinfo = batadv_neigh_ifinfo_get(router, BATADV_IF_DEFAULT);\r\nif (!router_ifinfo)\r\ngoto out;\r\ncurr_gw = batadv_gw_get_selected_gw_node(bat_priv);\r\nhdr = genlmsg_put(msg, portid, seq, &batadv_netlink_family,\r\nNLM_F_MULTI, BATADV_CMD_GET_GATEWAYS);\r\nif (!hdr) {\r\nret = -ENOBUFS;\r\ngoto out;\r\n}\r\nret = -EMSGSIZE;\r\nif (curr_gw == gw_node) {\r\nif (nla_put_flag(msg, BATADV_ATTR_FLAG_BEST)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\n}\r\nif (nla_put(msg, BATADV_ATTR_ORIG_ADDRESS, ETH_ALEN,\r\ngw_node->orig_node->orig)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\nif (nla_put_u32(msg, BATADV_ATTR_THROUGHPUT,\r\nrouter_ifinfo->bat_v.throughput)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\nif (nla_put(msg, BATADV_ATTR_ROUTER, ETH_ALEN, router->addr)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\nif (nla_put_string(msg, BATADV_ATTR_HARD_IFNAME,\r\nrouter->if_incoming->net_dev->name)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\nif (nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_DOWN,\r\ngw_node->bandwidth_down)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\nif (nla_put_u32(msg, BATADV_ATTR_BANDWIDTH_UP, gw_node->bandwidth_up)) {\r\ngenlmsg_cancel(msg, hdr);\r\ngoto out;\r\n}\r\ngenlmsg_end(msg, hdr);\r\nret = 0;\r\nout:\r\nif (router_ifinfo)\r\nbatadv_neigh_ifinfo_put(router_ifinfo);\r\nif (router)\r\nbatadv_neigh_node_put(router);\r\nreturn ret;\r\n}\r\nstatic void batadv_v_gw_dump(struct sk_buff *msg, struct netlink_callback *cb,\r\nstruct batadv_priv *bat_priv)\r\n{\r\nint portid = NETLINK_CB(cb->skb).portid;\r\nstruct batadv_gw_node *gw_node;\r\nint idx_skip = cb->args[0];\r\nint idx = 0;\r\nrcu_read_lock();\r\nhlist_for_each_entry_rcu(gw_node, &bat_priv->gw.gateway_list, list) {\r\nif (idx++ < idx_skip)\r\ncontinue;\r\nif (batadv_v_gw_dump_entry(msg, portid, cb->nlh->nlmsg_seq,\r\nbat_priv, gw_node)) {\r\nidx_skip = idx - 1;\r\ngoto unlock;\r\n}\r\n}\r\nidx_skip = idx;\r\nunlock:\r\nrcu_read_unlock();\r\ncb->args[0] = idx_skip;\r\n}\r\nvoid batadv_v_hardif_init(struct batadv_hard_iface *hard_iface)\r\n{\r\natomic_set(&hard_iface->bat_v.throughput_override, 0);\r\natomic_set(&hard_iface->bat_v.elp_interval, 500);\r\n}\r\nint batadv_v_mesh_init(struct batadv_priv *bat_priv)\r\n{\r\nint ret = 0;\r\nret = batadv_v_ogm_init(bat_priv);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nvoid batadv_v_mesh_free(struct batadv_priv *bat_priv)\r\n{\r\nbatadv_v_ogm_free(bat_priv);\r\n}\r\nint __init batadv_v_init(void)\r\n{\r\nint ret;\r\nret = batadv_recv_handler_register(BATADV_ELP,\r\nbatadv_v_elp_packet_recv);\r\nif (ret < 0)\r\nreturn ret;\r\nret = batadv_recv_handler_register(BATADV_OGM2,\r\nbatadv_v_ogm_packet_recv);\r\nif (ret < 0)\r\ngoto elp_unregister;\r\nret = batadv_algo_register(&batadv_batman_v);\r\nif (ret < 0)\r\ngoto ogm_unregister;\r\nreturn ret;\r\nogm_unregister:\r\nbatadv_recv_handler_unregister(BATADV_OGM2);\r\nelp_unregister:\r\nbatadv_recv_handler_unregister(BATADV_ELP);\r\nreturn ret;\r\n}
