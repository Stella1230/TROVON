uint32_t vce_v1_0_get_rptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nif (ring->idx == TN_RING_TYPE_VCE1_INDEX)\r\nreturn RREG32(VCE_RB_RPTR);\r\nelse\r\nreturn RREG32(VCE_RB_RPTR2);\r\n}\r\nuint32_t vce_v1_0_get_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nif (ring->idx == TN_RING_TYPE_VCE1_INDEX)\r\nreturn RREG32(VCE_RB_WPTR);\r\nelse\r\nreturn RREG32(VCE_RB_WPTR2);\r\n}\r\nvoid vce_v1_0_set_wptr(struct radeon_device *rdev,\r\nstruct radeon_ring *ring)\r\n{\r\nif (ring->idx == TN_RING_TYPE_VCE1_INDEX)\r\nWREG32(VCE_RB_WPTR, ring->wptr);\r\nelse\r\nWREG32(VCE_RB_WPTR2, ring->wptr);\r\n}\r\nvoid vce_v1_0_enable_mgcg(struct radeon_device *rdev, bool enable)\r\n{\r\nu32 tmp;\r\nif (enable && (rdev->cg_flags & RADEON_CG_SUPPORT_VCE_MGCG)) {\r\ntmp = RREG32(VCE_CLOCK_GATING_A);\r\ntmp |= CGC_DYN_CLOCK_MODE;\r\nWREG32(VCE_CLOCK_GATING_A, tmp);\r\ntmp = RREG32(VCE_UENC_CLOCK_GATING);\r\ntmp &= ~0x1ff000;\r\ntmp |= 0xff800000;\r\nWREG32(VCE_UENC_CLOCK_GATING, tmp);\r\ntmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\r\ntmp &= ~0x3ff;\r\nWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\r\n} else {\r\ntmp = RREG32(VCE_CLOCK_GATING_A);\r\ntmp &= ~CGC_DYN_CLOCK_MODE;\r\nWREG32(VCE_CLOCK_GATING_A, tmp);\r\ntmp = RREG32(VCE_UENC_CLOCK_GATING);\r\ntmp |= 0x1ff000;\r\ntmp &= ~0xff800000;\r\nWREG32(VCE_UENC_CLOCK_GATING, tmp);\r\ntmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\r\ntmp |= 0x3ff;\r\nWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\r\n}\r\n}\r\nstatic void vce_v1_0_init_cg(struct radeon_device *rdev)\r\n{\r\nu32 tmp;\r\ntmp = RREG32(VCE_CLOCK_GATING_A);\r\ntmp |= CGC_DYN_CLOCK_MODE;\r\nWREG32(VCE_CLOCK_GATING_A, tmp);\r\ntmp = RREG32(VCE_CLOCK_GATING_B);\r\ntmp |= 0x1e;\r\ntmp &= ~0xe100e1;\r\nWREG32(VCE_CLOCK_GATING_B, tmp);\r\ntmp = RREG32(VCE_UENC_CLOCK_GATING);\r\ntmp &= ~0xff9ff000;\r\nWREG32(VCE_UENC_CLOCK_GATING, tmp);\r\ntmp = RREG32(VCE_UENC_REG_CLOCK_GATING);\r\ntmp &= ~0x3ff;\r\nWREG32(VCE_UENC_REG_CLOCK_GATING, tmp);\r\n}\r\nint vce_v1_0_load_fw(struct radeon_device *rdev, uint32_t *data)\r\n{\r\nstruct vce_v1_0_fw_signature *sign = (void*)rdev->vce_fw->data;\r\nuint32_t chip_id;\r\nint i;\r\nswitch (rdev->family) {\r\ncase CHIP_TAHITI:\r\nchip_id = 0x01000014;\r\nbreak;\r\ncase CHIP_VERDE:\r\nchip_id = 0x01000015;\r\nbreak;\r\ncase CHIP_PITCAIRN:\r\ncase CHIP_OLAND:\r\nchip_id = 0x01000016;\r\nbreak;\r\ncase CHIP_ARUBA:\r\nchip_id = 0x01000017;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < le32_to_cpu(sign->num); ++i) {\r\nif (le32_to_cpu(sign->val[i].chip_id) == chip_id)\r\nbreak;\r\n}\r\nif (i == le32_to_cpu(sign->num))\r\nreturn -EINVAL;\r\ndata += (256 - 64) / 4;\r\ndata[0] = sign->val[i].nonce[0];\r\ndata[1] = sign->val[i].nonce[1];\r\ndata[2] = sign->val[i].nonce[2];\r\ndata[3] = sign->val[i].nonce[3];\r\ndata[4] = cpu_to_le32(le32_to_cpu(sign->len) + 64);\r\nmemset(&data[5], 0, 44);\r\nmemcpy(&data[16], &sign[1], rdev->vce_fw->size - sizeof(*sign));\r\ndata += (le32_to_cpu(sign->len) + 64) / 4;\r\ndata[0] = sign->val[i].sigval[0];\r\ndata[1] = sign->val[i].sigval[1];\r\ndata[2] = sign->val[i].sigval[2];\r\ndata[3] = sign->val[i].sigval[3];\r\nrdev->vce.keyselect = le32_to_cpu(sign->val[i].keyselect);\r\nreturn 0;\r\n}\r\nunsigned vce_v1_0_bo_size(struct radeon_device *rdev)\r\n{\r\nWARN_ON(VCE_V1_0_FW_SIZE < rdev->vce_fw->size);\r\nreturn VCE_V1_0_FW_SIZE + VCE_V1_0_STACK_SIZE + VCE_V1_0_DATA_SIZE;\r\n}\r\nint vce_v1_0_resume(struct radeon_device *rdev)\r\n{\r\nuint64_t addr = rdev->vce.gpu_addr;\r\nuint32_t size;\r\nint i;\r\nWREG32_P(VCE_CLOCK_GATING_A, 0, ~(1 << 16));\r\nWREG32_P(VCE_UENC_CLOCK_GATING, 0x1FF000, ~0xFF9FF000);\r\nWREG32_P(VCE_UENC_REG_CLOCK_GATING, 0x3F, ~0x3F);\r\nWREG32(VCE_CLOCK_GATING_B, 0);\r\nWREG32_P(VCE_LMI_FW_PERIODIC_CTRL, 0x4, ~0x4);\r\nWREG32(VCE_LMI_CTRL, 0x00398000);\r\nWREG32_P(VCE_LMI_CACHE_CTRL, 0x0, ~0x1);\r\nWREG32(VCE_LMI_SWAP_CNTL, 0);\r\nWREG32(VCE_LMI_SWAP_CNTL1, 0);\r\nWREG32(VCE_LMI_VM_CTRL, 0);\r\nWREG32(VCE_VCPU_SCRATCH7, RADEON_MAX_VCE_HANDLES);\r\naddr += 256;\r\nsize = VCE_V1_0_FW_SIZE;\r\nWREG32(VCE_VCPU_CACHE_OFFSET0, addr & 0x7fffffff);\r\nWREG32(VCE_VCPU_CACHE_SIZE0, size);\r\naddr += size;\r\nsize = VCE_V1_0_STACK_SIZE;\r\nWREG32(VCE_VCPU_CACHE_OFFSET1, addr & 0x7fffffff);\r\nWREG32(VCE_VCPU_CACHE_SIZE1, size);\r\naddr += size;\r\nsize = VCE_V1_0_DATA_SIZE;\r\nWREG32(VCE_VCPU_CACHE_OFFSET2, addr & 0x7fffffff);\r\nWREG32(VCE_VCPU_CACHE_SIZE2, size);\r\nWREG32_P(VCE_LMI_CTRL2, 0x0, ~0x100);\r\nWREG32(VCE_LMI_FW_START_KEYSEL, rdev->vce.keyselect);\r\nfor (i = 0; i < 10; ++i) {\r\nmdelay(10);\r\nif (RREG32(VCE_FW_REG_STATUS) & VCE_FW_REG_STATUS_DONE)\r\nbreak;\r\n}\r\nif (i == 10)\r\nreturn -ETIMEDOUT;\r\nif (!(RREG32(VCE_FW_REG_STATUS) & VCE_FW_REG_STATUS_PASS))\r\nreturn -EINVAL;\r\nfor (i = 0; i < 10; ++i) {\r\nmdelay(10);\r\nif (!(RREG32(VCE_FW_REG_STATUS) & VCE_FW_REG_STATUS_BUSY))\r\nbreak;\r\n}\r\nif (i == 10)\r\nreturn -ETIMEDOUT;\r\nvce_v1_0_init_cg(rdev);\r\nreturn 0;\r\n}\r\nint vce_v1_0_start(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring;\r\nint i, j, r;\r\nWREG32_P(VCE_STATUS, 1, ~1);\r\nring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\r\nWREG32(VCE_RB_RPTR, ring->wptr);\r\nWREG32(VCE_RB_WPTR, ring->wptr);\r\nWREG32(VCE_RB_BASE_LO, ring->gpu_addr);\r\nWREG32(VCE_RB_BASE_HI, upper_32_bits(ring->gpu_addr));\r\nWREG32(VCE_RB_SIZE, ring->ring_size / 4);\r\nring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\r\nWREG32(VCE_RB_RPTR2, ring->wptr);\r\nWREG32(VCE_RB_WPTR2, ring->wptr);\r\nWREG32(VCE_RB_BASE_LO2, ring->gpu_addr);\r\nWREG32(VCE_RB_BASE_HI2, upper_32_bits(ring->gpu_addr));\r\nWREG32(VCE_RB_SIZE2, ring->ring_size / 4);\r\nWREG32_P(VCE_VCPU_CNTL, VCE_CLK_EN, ~VCE_CLK_EN);\r\nWREG32_P(VCE_SOFT_RESET,\r\nVCE_ECPU_SOFT_RESET |\r\nVCE_FME_SOFT_RESET, ~(\r\nVCE_ECPU_SOFT_RESET |\r\nVCE_FME_SOFT_RESET));\r\nmdelay(100);\r\nWREG32_P(VCE_SOFT_RESET, 0, ~(\r\nVCE_ECPU_SOFT_RESET |\r\nVCE_FME_SOFT_RESET));\r\nfor (i = 0; i < 10; ++i) {\r\nuint32_t status;\r\nfor (j = 0; j < 100; ++j) {\r\nstatus = RREG32(VCE_STATUS);\r\nif (status & 2)\r\nbreak;\r\nmdelay(10);\r\n}\r\nr = 0;\r\nif (status & 2)\r\nbreak;\r\nDRM_ERROR("VCE not responding, trying to reset the ECPU!!!\n");\r\nWREG32_P(VCE_SOFT_RESET, VCE_ECPU_SOFT_RESET, ~VCE_ECPU_SOFT_RESET);\r\nmdelay(10);\r\nWREG32_P(VCE_SOFT_RESET, 0, ~VCE_ECPU_SOFT_RESET);\r\nmdelay(10);\r\nr = -1;\r\n}\r\nWREG32_P(VCE_STATUS, 0, ~1);\r\nif (r) {\r\nDRM_ERROR("VCE not responding, giving up!!!\n");\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nint vce_v1_0_init(struct radeon_device *rdev)\r\n{\r\nstruct radeon_ring *ring;\r\nint r;\r\nr = vce_v1_0_start(rdev);\r\nif (r)\r\nreturn r;\r\nring = &rdev->ring[TN_RING_TYPE_VCE1_INDEX];\r\nring->ready = true;\r\nr = radeon_ring_test(rdev, TN_RING_TYPE_VCE1_INDEX, ring);\r\nif (r) {\r\nring->ready = false;\r\nreturn r;\r\n}\r\nring = &rdev->ring[TN_RING_TYPE_VCE2_INDEX];\r\nring->ready = true;\r\nr = radeon_ring_test(rdev, TN_RING_TYPE_VCE2_INDEX, ring);\r\nif (r) {\r\nring->ready = false;\r\nreturn r;\r\n}\r\nDRM_INFO("VCE initialized successfully.\n");\r\nreturn 0;\r\n}
