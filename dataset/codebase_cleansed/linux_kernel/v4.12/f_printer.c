static inline struct printer_dev *func_to_printer(struct usb_function *f)\r\n{\r\nreturn container_of(f, struct printer_dev, function);\r\n}\r\nstatic inline struct usb_endpoint_descriptor *ep_desc(struct usb_gadget *gadget,\r\nstruct usb_endpoint_descriptor *fs,\r\nstruct usb_endpoint_descriptor *hs,\r\nstruct usb_endpoint_descriptor *ss)\r\n{\r\nswitch (gadget->speed) {\r\ncase USB_SPEED_SUPER:\r\nreturn ss;\r\ncase USB_SPEED_HIGH:\r\nreturn hs;\r\ndefault:\r\nreturn fs;\r\n}\r\n}\r\nstatic struct usb_request *\r\nprinter_req_alloc(struct usb_ep *ep, unsigned len, gfp_t gfp_flags)\r\n{\r\nstruct usb_request *req;\r\nreq = usb_ep_alloc_request(ep, gfp_flags);\r\nif (req != NULL) {\r\nreq->length = len;\r\nreq->buf = kmalloc(len, gfp_flags);\r\nif (req->buf == NULL) {\r\nusb_ep_free_request(ep, req);\r\nreturn NULL;\r\n}\r\n}\r\nreturn req;\r\n}\r\nstatic void\r\nprinter_req_free(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nif (ep != NULL && req != NULL) {\r\nkfree(req->buf);\r\nusb_ep_free_request(ep, req);\r\n}\r\n}\r\nstatic void rx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct printer_dev *dev = ep->driver_data;\r\nint status = req->status;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nlist_del_init(&req->list);\r\nswitch (status) {\r\ncase 0:\r\nif (req->actual > 0) {\r\nlist_add_tail(&req->list, &dev->rx_buffers);\r\nDBG(dev, "G_Printer : rx length %d\n", req->actual);\r\n} else {\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nVDBG(dev, "rx shutdown, code %d\n", status);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\ncase -ECONNABORTED:\r\nDBG(dev, "rx %s reset\n", ep->name);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\ncase -EOVERFLOW:\r\ndefault:\r\nDBG(dev, "rx status %d\n", status);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\n}\r\nwake_up_interruptible(&dev->rx_wait);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic void tx_complete(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct printer_dev *dev = ep->driver_data;\r\nswitch (req->status) {\r\ndefault:\r\nVDBG(dev, "tx err %d\n", req->status);\r\ncase -ECONNRESET:\r\ncase -ESHUTDOWN:\r\nbreak;\r\ncase 0:\r\nbreak;\r\n}\r\nspin_lock(&dev->lock);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->tx_reqs);\r\nwake_up_interruptible(&dev->tx_wait);\r\nif (likely(list_empty(&dev->tx_reqs_active)))\r\nwake_up_interruptible(&dev->tx_flush_wait);\r\nspin_unlock(&dev->lock);\r\n}\r\nstatic int\r\nprinter_open(struct inode *inode, struct file *fd)\r\n{\r\nstruct printer_dev *dev;\r\nunsigned long flags;\r\nint ret = -EBUSY;\r\ndev = container_of(inode->i_cdev, struct printer_dev, printer_cdev);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (!dev->printer_cdev_open) {\r\ndev->printer_cdev_open = 1;\r\nfd->private_data = dev;\r\nret = 0;\r\ndev->printer_status |= PRINTER_SELECTED;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nDBG(dev, "printer_open returned %x\n", ret);\r\nreturn ret;\r\n}\r\nstatic int\r\nprinter_close(struct inode *inode, struct file *fd)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->printer_cdev_open = 0;\r\nfd->private_data = NULL;\r\ndev->printer_status &= ~PRINTER_SELECTED;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nDBG(dev, "printer_close\n");\r\nreturn 0;\r\n}\r\nstatic void\r\nsetup_rx_reqs(struct printer_dev *dev)\r\n{\r\nstruct usb_request *req;\r\nwhile (likely(!list_empty(&dev->rx_reqs))) {\r\nint error;\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nreq->length = USB_BUFSIZE;\r\nreq->complete = rx_complete;\r\nspin_unlock(&dev->lock);\r\nerror = usb_ep_queue(dev->out_ep, req, GFP_ATOMIC);\r\nspin_lock(&dev->lock);\r\nif (error) {\r\nDBG(dev, "rx submit --> %d\n", error);\r\nlist_add(&req->list, &dev->rx_reqs);\r\nbreak;\r\n}\r\nelse if (list_empty(&req->list))\r\nlist_add(&req->list, &dev->rx_reqs_active);\r\n}\r\n}\r\nstatic ssize_t\r\nprinter_read(struct file *fd, char __user *buf, size_t len, loff_t *ptr)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nsize_t size;\r\nsize_t bytes_copied;\r\nstruct usb_request *req;\r\nstruct usb_request *current_rx_req;\r\nsize_t current_rx_bytes;\r\nu8 *current_rx_buf;\r\nif (len == 0)\r\nreturn -EINVAL;\r\nDBG(dev, "printer_read trying to read %d bytes\n", (int)len);\r\nmutex_lock(&dev->lock_printer_io);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->reset_printer = 0;\r\nsetup_rx_reqs(dev);\r\nbytes_copied = 0;\r\ncurrent_rx_req = dev->current_rx_req;\r\ncurrent_rx_bytes = dev->current_rx_bytes;\r\ncurrent_rx_buf = dev->current_rx_buf;\r\ndev->current_rx_req = NULL;\r\ndev->current_rx_bytes = 0;\r\ndev->current_rx_buf = NULL;\r\nif ((current_rx_bytes == 0) &&\r\n(likely(list_empty(&dev->rx_buffers)))) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nwait_event_interruptible(dev->rx_wait,\r\n(likely(!list_empty(&dev->rx_buffers))));\r\nspin_lock_irqsave(&dev->lock, flags);\r\n}\r\nwhile ((current_rx_bytes || likely(!list_empty(&dev->rx_buffers)))\r\n&& len) {\r\nif (current_rx_bytes == 0) {\r\nreq = container_of(dev->rx_buffers.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nif (req->actual && req->buf) {\r\ncurrent_rx_req = req;\r\ncurrent_rx_bytes = req->actual;\r\ncurrent_rx_buf = req->buf;\r\n} else {\r\nlist_add(&req->list, &dev->rx_reqs);\r\ncontinue;\r\n}\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (len > current_rx_bytes)\r\nsize = current_rx_bytes;\r\nelse\r\nsize = len;\r\nsize -= copy_to_user(buf, current_rx_buf, size);\r\nbytes_copied += size;\r\nlen -= size;\r\nbuf += size;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->reset_printer) {\r\nlist_add(&current_rx_req->list, &dev->rx_reqs);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nif (size < current_rx_bytes) {\r\ncurrent_rx_bytes -= size;\r\ncurrent_rx_buf += size;\r\n} else {\r\nlist_add(&current_rx_req->list, &dev->rx_reqs);\r\ncurrent_rx_bytes = 0;\r\ncurrent_rx_buf = NULL;\r\ncurrent_rx_req = NULL;\r\n}\r\n}\r\ndev->current_rx_req = current_rx_req;\r\ndev->current_rx_bytes = current_rx_bytes;\r\ndev->current_rx_buf = current_rx_buf;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nDBG(dev, "printer_read returned %d bytes\n", (int)bytes_copied);\r\nif (bytes_copied)\r\nreturn bytes_copied;\r\nelse\r\nreturn -EAGAIN;\r\n}\r\nstatic ssize_t\r\nprinter_write(struct file *fd, const char __user *buf, size_t len, loff_t *ptr)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nsize_t size;\r\nsize_t bytes_copied = 0;\r\nstruct usb_request *req;\r\nDBG(dev, "printer_write trying to send %d bytes\n", (int)len);\r\nif (len == 0)\r\nreturn -EINVAL;\r\nmutex_lock(&dev->lock_printer_io);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->reset_printer = 0;\r\nif (likely(list_empty(&dev->tx_reqs))) {\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (fd->f_flags & (O_NONBLOCK|O_NDELAY)) {\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nwait_event_interruptible(dev->tx_wait,\r\n(likely(!list_empty(&dev->tx_reqs))));\r\nspin_lock_irqsave(&dev->lock, flags);\r\n}\r\nwhile (likely(!list_empty(&dev->tx_reqs)) && len) {\r\nif (len > USB_BUFSIZE)\r\nsize = USB_BUFSIZE;\r\nelse\r\nsize = len;\r\nreq = container_of(dev->tx_reqs.next, struct usb_request,\r\nlist);\r\nlist_del_init(&req->list);\r\nreq->complete = tx_complete;\r\nreq->length = size;\r\nif (len > size)\r\nreq->zero = 0;\r\nelse\r\nreq->zero = ((len % dev->in_ep->maxpacket) == 0);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (copy_from_user(req->buf, buf, size)) {\r\nlist_add(&req->list, &dev->tx_reqs);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn bytes_copied;\r\n}\r\nbytes_copied += size;\r\nlen -= size;\r\nbuf += size;\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (dev->reset_printer) {\r\nlist_add(&req->list, &dev->tx_reqs);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nif (usb_ep_queue(dev->in_ep, req, GFP_ATOMIC)) {\r\nlist_add(&req->list, &dev->tx_reqs);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nreturn -EAGAIN;\r\n}\r\nlist_add(&req->list, &dev->tx_reqs_active);\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\nDBG(dev, "printer_write sent %d bytes\n", (int)bytes_copied);\r\nif (bytes_copied)\r\nreturn bytes_copied;\r\nelse\r\nreturn -EAGAIN;\r\n}\r\nstatic int\r\nprinter_fsync(struct file *fd, loff_t start, loff_t end, int datasync)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nstruct inode *inode = file_inode(fd);\r\nunsigned long flags;\r\nint tx_list_empty;\r\ninode_lock(inode);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ntx_list_empty = (likely(list_empty(&dev->tx_reqs)));\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nif (!tx_list_empty) {\r\nwait_event_interruptible(dev->tx_flush_wait,\r\n(likely(list_empty(&dev->tx_reqs_active))));\r\n}\r\ninode_unlock(inode);\r\nreturn 0;\r\n}\r\nstatic unsigned int\r\nprinter_poll(struct file *fd, poll_table *wait)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nint status = 0;\r\nmutex_lock(&dev->lock_printer_io);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nsetup_rx_reqs(dev);\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nmutex_unlock(&dev->lock_printer_io);\r\npoll_wait(fd, &dev->rx_wait, wait);\r\npoll_wait(fd, &dev->tx_wait, wait);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nif (likely(!list_empty(&dev->tx_reqs)))\r\nstatus |= POLLOUT | POLLWRNORM;\r\nif (likely(dev->current_rx_bytes) ||\r\nlikely(!list_empty(&dev->rx_buffers)))\r\nstatus |= POLLIN | POLLRDNORM;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic long\r\nprinter_ioctl(struct file *fd, unsigned int code, unsigned long arg)\r\n{\r\nstruct printer_dev *dev = fd->private_data;\r\nunsigned long flags;\r\nint status = 0;\r\nDBG(dev, "printer_ioctl: cmd=0x%4.4x, arg=%lu\n", code, arg);\r\nspin_lock_irqsave(&dev->lock, flags);\r\nswitch (code) {\r\ncase GADGET_GET_PRINTER_STATUS:\r\nstatus = (int)dev->printer_status;\r\nbreak;\r\ncase GADGET_SET_PRINTER_STATUS:\r\ndev->printer_status = (u8)arg;\r\nbreak;\r\ndefault:\r\nDBG(dev, "printer_ioctl: ERROR cmd=0x%4.4xis not supported\n",\r\ncode);\r\nstatus = -ENOTTY;\r\n}\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\nreturn status;\r\n}\r\nstatic int\r\nset_printer_interface(struct printer_dev *dev)\r\n{\r\nint result = 0;\r\ndev->in_ep->desc = ep_desc(dev->gadget, &fs_ep_in_desc, &hs_ep_in_desc,\r\n&ss_ep_in_desc);\r\ndev->in_ep->driver_data = dev;\r\ndev->out_ep->desc = ep_desc(dev->gadget, &fs_ep_out_desc,\r\n&hs_ep_out_desc, &ss_ep_out_desc);\r\ndev->out_ep->driver_data = dev;\r\nresult = usb_ep_enable(dev->in_ep);\r\nif (result != 0) {\r\nDBG(dev, "enable %s --> %d\n", dev->in_ep->name, result);\r\ngoto done;\r\n}\r\nresult = usb_ep_enable(dev->out_ep);\r\nif (result != 0) {\r\nDBG(dev, "enable %s --> %d\n", dev->in_ep->name, result);\r\ngoto done;\r\n}\r\ndone:\r\nif (result != 0) {\r\n(void) usb_ep_disable(dev->in_ep);\r\n(void) usb_ep_disable(dev->out_ep);\r\ndev->in_ep->desc = NULL;\r\ndev->out_ep->desc = NULL;\r\n}\r\nreturn result;\r\n}\r\nstatic void printer_reset_interface(struct printer_dev *dev)\r\n{\r\nunsigned long flags;\r\nif (dev->interface < 0)\r\nreturn;\r\nDBG(dev, "%s\n", __func__);\r\nif (dev->in_ep->desc)\r\nusb_ep_disable(dev->in_ep);\r\nif (dev->out_ep->desc)\r\nusb_ep_disable(dev->out_ep);\r\nspin_lock_irqsave(&dev->lock, flags);\r\ndev->in_ep->desc = NULL;\r\ndev->out_ep->desc = NULL;\r\ndev->interface = -1;\r\nspin_unlock_irqrestore(&dev->lock, flags);\r\n}\r\nstatic int set_interface(struct printer_dev *dev, unsigned number)\r\n{\r\nint result = 0;\r\nprinter_reset_interface(dev);\r\nresult = set_printer_interface(dev);\r\nif (result)\r\nprinter_reset_interface(dev);\r\nelse\r\ndev->interface = number;\r\nif (!result)\r\nINFO(dev, "Using interface %x\n", number);\r\nreturn result;\r\n}\r\nstatic void printer_soft_reset(struct printer_dev *dev)\r\n{\r\nstruct usb_request *req;\r\nINFO(dev, "Received Printer Reset Request\n");\r\nif (usb_ep_disable(dev->in_ep))\r\nDBG(dev, "Failed to disable USB in_ep\n");\r\nif (usb_ep_disable(dev->out_ep))\r\nDBG(dev, "Failed to disable USB out_ep\n");\r\nif (dev->current_rx_req != NULL) {\r\nlist_add(&dev->current_rx_req->list, &dev->rx_reqs);\r\ndev->current_rx_req = NULL;\r\n}\r\ndev->current_rx_bytes = 0;\r\ndev->current_rx_buf = NULL;\r\ndev->reset_printer = 1;\r\nwhile (likely(!(list_empty(&dev->rx_buffers)))) {\r\nreq = container_of(dev->rx_buffers.next, struct usb_request,\r\nlist);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\nwhile (likely(!(list_empty(&dev->rx_reqs_active)))) {\r\nreq = container_of(dev->rx_buffers.next, struct usb_request,\r\nlist);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\nwhile (likely(!(list_empty(&dev->tx_reqs_active)))) {\r\nreq = container_of(dev->tx_reqs_active.next,\r\nstruct usb_request, list);\r\nlist_del_init(&req->list);\r\nlist_add(&req->list, &dev->tx_reqs);\r\n}\r\nif (usb_ep_enable(dev->in_ep))\r\nDBG(dev, "Failed to enable USB in_ep\n");\r\nif (usb_ep_enable(dev->out_ep))\r\nDBG(dev, "Failed to enable USB out_ep\n");\r\nwake_up_interruptible(&dev->rx_wait);\r\nwake_up_interruptible(&dev->tx_wait);\r\nwake_up_interruptible(&dev->tx_flush_wait);\r\n}\r\nstatic bool gprinter_req_match(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl,\r\nbool config0)\r\n{\r\nstruct printer_dev *dev = func_to_printer(f);\r\nu16 w_index = le16_to_cpu(ctrl->wIndex);\r\nu16 w_value = le16_to_cpu(ctrl->wValue);\r\nu16 w_length = le16_to_cpu(ctrl->wLength);\r\nif (config0)\r\nreturn false;\r\nif ((ctrl->bRequestType & USB_RECIP_MASK) != USB_RECIP_INTERFACE ||\r\n(ctrl->bRequestType & USB_TYPE_MASK) != USB_TYPE_CLASS)\r\nreturn false;\r\nswitch (ctrl->bRequest) {\r\ncase GET_DEVICE_ID:\r\nw_index >>= 8;\r\nif (USB_DIR_IN & ctrl->bRequestType)\r\nbreak;\r\nreturn false;\r\ncase GET_PORT_STATUS:\r\nif (!w_value && w_length == 1 &&\r\n(USB_DIR_IN & ctrl->bRequestType))\r\nbreak;\r\nreturn false;\r\ncase SOFT_RESET:\r\nif (!w_value && !w_length &&\r\n!(USB_DIR_IN & ctrl->bRequestType))\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn w_index == dev->interface;\r\n}\r\nstatic int printer_func_setup(struct usb_function *f,\r\nconst struct usb_ctrlrequest *ctrl)\r\n{\r\nstruct printer_dev *dev = func_to_printer(f);\r\nstruct usb_composite_dev *cdev = f->config->cdev;\r\nstruct usb_request *req = cdev->req;\r\nu8 *buf = req->buf;\r\nint value = -EOPNOTSUPP;\r\nu16 wIndex = le16_to_cpu(ctrl->wIndex);\r\nu16 wValue = le16_to_cpu(ctrl->wValue);\r\nu16 wLength = le16_to_cpu(ctrl->wLength);\r\nDBG(dev, "ctrl req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest, wValue, wIndex, wLength);\r\nswitch (ctrl->bRequestType&USB_TYPE_MASK) {\r\ncase USB_TYPE_CLASS:\r\nswitch (ctrl->bRequest) {\r\ncase GET_DEVICE_ID:\r\nif ((wIndex>>8) != dev->interface)\r\nbreak;\r\nif (!dev->pnp_string) {\r\nvalue = 0;\r\nbreak;\r\n}\r\nvalue = strlen(dev->pnp_string);\r\nbuf[0] = (value >> 8) & 0xFF;\r\nbuf[1] = value & 0xFF;\r\nmemcpy(buf + 2, dev->pnp_string, value);\r\nDBG(dev, "1284 PNP String: %x %s\n", value,\r\ndev->pnp_string);\r\nbreak;\r\ncase GET_PORT_STATUS:\r\nif (wIndex != dev->interface)\r\nbreak;\r\nbuf[0] = dev->printer_status;\r\nvalue = min_t(u16, wLength, 1);\r\nbreak;\r\ncase SOFT_RESET:\r\nif (wIndex != dev->interface)\r\nbreak;\r\nprinter_soft_reset(dev);\r\nvalue = 0;\r\nbreak;\r\ndefault:\r\ngoto unknown;\r\n}\r\nbreak;\r\ndefault:\r\nunknown:\r\nVDBG(dev,\r\n"unknown ctrl req%02x.%02x v%04x i%04x l%d\n",\r\nctrl->bRequestType, ctrl->bRequest,\r\nwValue, wIndex, wLength);\r\nbreak;\r\n}\r\nif (value >= 0) {\r\nreq->length = value;\r\nreq->zero = value < wLength;\r\nvalue = usb_ep_queue(cdev->gadget->ep0, req, GFP_ATOMIC);\r\nif (value < 0) {\r\nERROR(dev, "%s:%d Error!\n", __func__, __LINE__);\r\nreq->status = 0;\r\n}\r\n}\r\nreturn value;\r\n}\r\nstatic int printer_func_bind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct usb_gadget *gadget = c->cdev->gadget;\r\nstruct printer_dev *dev = func_to_printer(f);\r\nstruct device *pdev;\r\nstruct usb_composite_dev *cdev = c->cdev;\r\nstruct usb_ep *in_ep;\r\nstruct usb_ep *out_ep = NULL;\r\nstruct usb_request *req;\r\ndev_t devt;\r\nint id;\r\nint ret;\r\nu32 i;\r\nid = usb_interface_id(c, f);\r\nif (id < 0)\r\nreturn id;\r\nintf_desc.bInterfaceNumber = id;\r\ndev->gadget = gadget;\r\nin_ep = usb_ep_autoconfig(cdev->gadget, &fs_ep_in_desc);\r\nif (!in_ep) {\r\nautoconf_fail:\r\ndev_err(&cdev->gadget->dev, "can't autoconfigure on %s\n",\r\ncdev->gadget->name);\r\nreturn -ENODEV;\r\n}\r\nout_ep = usb_ep_autoconfig(cdev->gadget, &fs_ep_out_desc);\r\nif (!out_ep)\r\ngoto autoconf_fail;\r\nhs_ep_in_desc.bEndpointAddress = fs_ep_in_desc.bEndpointAddress;\r\nhs_ep_out_desc.bEndpointAddress = fs_ep_out_desc.bEndpointAddress;\r\nss_ep_in_desc.bEndpointAddress = fs_ep_in_desc.bEndpointAddress;\r\nss_ep_out_desc.bEndpointAddress = fs_ep_out_desc.bEndpointAddress;\r\nret = usb_assign_descriptors(f, fs_printer_function,\r\nhs_printer_function, ss_printer_function, NULL);\r\nif (ret)\r\nreturn ret;\r\ndev->in_ep = in_ep;\r\ndev->out_ep = out_ep;\r\nret = -ENOMEM;\r\nfor (i = 0; i < dev->q_len; i++) {\r\nreq = printer_req_alloc(dev->in_ep, USB_BUFSIZE, GFP_KERNEL);\r\nif (!req)\r\ngoto fail_tx_reqs;\r\nlist_add(&req->list, &dev->tx_reqs);\r\n}\r\nfor (i = 0; i < dev->q_len; i++) {\r\nreq = printer_req_alloc(dev->out_ep, USB_BUFSIZE, GFP_KERNEL);\r\nif (!req)\r\ngoto fail_rx_reqs;\r\nlist_add(&req->list, &dev->rx_reqs);\r\n}\r\ndevt = MKDEV(major, dev->minor);\r\npdev = device_create(usb_gadget_class, NULL, devt,\r\nNULL, "g_printer%d", dev->minor);\r\nif (IS_ERR(pdev)) {\r\nERROR(dev, "Failed to create device: g_printer\n");\r\nret = PTR_ERR(pdev);\r\ngoto fail_rx_reqs;\r\n}\r\ncdev_init(&dev->printer_cdev, &printer_io_operations);\r\ndev->printer_cdev.owner = THIS_MODULE;\r\nret = cdev_add(&dev->printer_cdev, devt, 1);\r\nif (ret) {\r\nERROR(dev, "Failed to open char device\n");\r\ngoto fail_cdev_add;\r\n}\r\nreturn 0;\r\nfail_cdev_add:\r\ndevice_destroy(usb_gadget_class, devt);\r\nfail_rx_reqs:\r\nwhile (!list_empty(&dev->rx_reqs)) {\r\nreq = container_of(dev->rx_reqs.next, struct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->out_ep, req);\r\n}\r\nfail_tx_reqs:\r\nwhile (!list_empty(&dev->tx_reqs)) {\r\nreq = container_of(dev->tx_reqs.next, struct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->in_ep, req);\r\n}\r\nreturn ret;\r\n}\r\nstatic int printer_func_set_alt(struct usb_function *f,\r\nunsigned intf, unsigned alt)\r\n{\r\nstruct printer_dev *dev = func_to_printer(f);\r\nint ret = -ENOTSUPP;\r\nif (!alt)\r\nret = set_interface(dev, intf);\r\nreturn ret;\r\n}\r\nstatic void printer_func_disable(struct usb_function *f)\r\n{\r\nstruct printer_dev *dev = func_to_printer(f);\r\nDBG(dev, "%s\n", __func__);\r\nprinter_reset_interface(dev);\r\n}\r\nstatic inline struct f_printer_opts\r\n*to_f_printer_opts(struct config_item *item)\r\n{\r\nreturn container_of(to_config_group(item), struct f_printer_opts,\r\nfunc_inst.group);\r\n}\r\nstatic void printer_attr_release(struct config_item *item)\r\n{\r\nstruct f_printer_opts *opts = to_f_printer_opts(item);\r\nusb_put_function_instance(&opts->func_inst);\r\n}\r\nstatic ssize_t f_printer_opts_pnp_string_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct f_printer_opts *opts = to_f_printer_opts(item);\r\nint result = 0;\r\nmutex_lock(&opts->lock);\r\nif (!opts->pnp_string)\r\ngoto unlock;\r\nresult = strlcpy(page, opts->pnp_string, PAGE_SIZE);\r\nif (result >= PAGE_SIZE) {\r\nresult = PAGE_SIZE;\r\n} else if (page[result - 1] != '\n' && result + 1 < PAGE_SIZE) {\r\npage[result++] = '\n';\r\npage[result] = '\0';\r\n}\r\nunlock:\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_printer_opts_pnp_string_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_printer_opts *opts = to_f_printer_opts(item);\r\nchar *new_pnp;\r\nint result;\r\nmutex_lock(&opts->lock);\r\nnew_pnp = kstrndup(page, len, GFP_KERNEL);\r\nif (!new_pnp) {\r\nresult = -ENOMEM;\r\ngoto unlock;\r\n}\r\nif (opts->pnp_string_allocated)\r\nkfree(opts->pnp_string);\r\nopts->pnp_string_allocated = true;\r\nopts->pnp_string = new_pnp;\r\nresult = len;\r\nunlock:\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_printer_opts_q_len_show(struct config_item *item,\r\nchar *page)\r\n{\r\nstruct f_printer_opts *opts = to_f_printer_opts(item);\r\nint result;\r\nmutex_lock(&opts->lock);\r\nresult = sprintf(page, "%d\n", opts->q_len);\r\nmutex_unlock(&opts->lock);\r\nreturn result;\r\n}\r\nstatic ssize_t f_printer_opts_q_len_store(struct config_item *item,\r\nconst char *page, size_t len)\r\n{\r\nstruct f_printer_opts *opts = to_f_printer_opts(item);\r\nint ret;\r\nu16 num;\r\nmutex_lock(&opts->lock);\r\nif (opts->refcnt) {\r\nret = -EBUSY;\r\ngoto end;\r\n}\r\nret = kstrtou16(page, 0, &num);\r\nif (ret)\r\ngoto end;\r\nopts->q_len = (unsigned)num;\r\nret = len;\r\nend:\r\nmutex_unlock(&opts->lock);\r\nreturn ret;\r\n}\r\nstatic inline int gprinter_get_minor(void)\r\n{\r\nint ret;\r\nret = ida_simple_get(&printer_ida, 0, 0, GFP_KERNEL);\r\nif (ret >= PRINTER_MINORS) {\r\nida_simple_remove(&printer_ida, ret);\r\nret = -ENODEV;\r\n}\r\nreturn ret;\r\n}\r\nstatic inline void gprinter_put_minor(int minor)\r\n{\r\nida_simple_remove(&printer_ida, minor);\r\n}\r\nstatic void gprinter_free_inst(struct usb_function_instance *f)\r\n{\r\nstruct f_printer_opts *opts;\r\nopts = container_of(f, struct f_printer_opts, func_inst);\r\nmutex_lock(&printer_ida_lock);\r\ngprinter_put_minor(opts->minor);\r\nif (ida_is_empty(&printer_ida))\r\ngprinter_cleanup();\r\nmutex_unlock(&printer_ida_lock);\r\nif (opts->pnp_string_allocated)\r\nkfree(opts->pnp_string);\r\nkfree(opts);\r\n}\r\nstatic struct usb_function_instance *gprinter_alloc_inst(void)\r\n{\r\nstruct f_printer_opts *opts;\r\nstruct usb_function_instance *ret;\r\nint status = 0;\r\nopts = kzalloc(sizeof(*opts), GFP_KERNEL);\r\nif (!opts)\r\nreturn ERR_PTR(-ENOMEM);\r\nmutex_init(&opts->lock);\r\nopts->func_inst.free_func_inst = gprinter_free_inst;\r\nret = &opts->func_inst;\r\nmutex_lock(&printer_ida_lock);\r\nif (ida_is_empty(&printer_ida)) {\r\nstatus = gprinter_setup(PRINTER_MINORS);\r\nif (status) {\r\nret = ERR_PTR(status);\r\nkfree(opts);\r\ngoto unlock;\r\n}\r\n}\r\nopts->minor = gprinter_get_minor();\r\nif (opts->minor < 0) {\r\nret = ERR_PTR(opts->minor);\r\nkfree(opts);\r\nif (ida_is_empty(&printer_ida))\r\ngprinter_cleanup();\r\ngoto unlock;\r\n}\r\nconfig_group_init_type_name(&opts->func_inst.group, "",\r\n&printer_func_type);\r\nunlock:\r\nmutex_unlock(&printer_ida_lock);\r\nreturn ret;\r\n}\r\nstatic void gprinter_free(struct usb_function *f)\r\n{\r\nstruct printer_dev *dev = func_to_printer(f);\r\nstruct f_printer_opts *opts;\r\nopts = container_of(f->fi, struct f_printer_opts, func_inst);\r\nkfree(dev);\r\nmutex_lock(&opts->lock);\r\n--opts->refcnt;\r\nmutex_unlock(&opts->lock);\r\n}\r\nstatic void printer_func_unbind(struct usb_configuration *c,\r\nstruct usb_function *f)\r\n{\r\nstruct printer_dev *dev;\r\nstruct usb_request *req;\r\ndev = func_to_printer(f);\r\ndevice_destroy(usb_gadget_class, MKDEV(major, dev->minor));\r\ncdev_del(&dev->printer_cdev);\r\nWARN_ON(!list_empty(&dev->tx_reqs_active));\r\nWARN_ON(!list_empty(&dev->rx_reqs_active));\r\nwhile (!list_empty(&dev->tx_reqs)) {\r\nreq = container_of(dev->tx_reqs.next, struct usb_request,\r\nlist);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->in_ep, req);\r\n}\r\nif (dev->current_rx_req != NULL)\r\nprinter_req_free(dev->out_ep, dev->current_rx_req);\r\nwhile (!list_empty(&dev->rx_reqs)) {\r\nreq = container_of(dev->rx_reqs.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->out_ep, req);\r\n}\r\nwhile (!list_empty(&dev->rx_buffers)) {\r\nreq = container_of(dev->rx_buffers.next,\r\nstruct usb_request, list);\r\nlist_del(&req->list);\r\nprinter_req_free(dev->out_ep, req);\r\n}\r\nusb_free_all_descriptors(f);\r\n}\r\nstatic struct usb_function *gprinter_alloc(struct usb_function_instance *fi)\r\n{\r\nstruct printer_dev *dev;\r\nstruct f_printer_opts *opts;\r\nopts = container_of(fi, struct f_printer_opts, func_inst);\r\nmutex_lock(&opts->lock);\r\nif (opts->minor >= minors) {\r\nmutex_unlock(&opts->lock);\r\nreturn ERR_PTR(-ENOENT);\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nmutex_unlock(&opts->lock);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n++opts->refcnt;\r\ndev->minor = opts->minor;\r\ndev->pnp_string = opts->pnp_string;\r\ndev->q_len = opts->q_len;\r\nmutex_unlock(&opts->lock);\r\ndev->function.name = "printer";\r\ndev->function.bind = printer_func_bind;\r\ndev->function.setup = printer_func_setup;\r\ndev->function.unbind = printer_func_unbind;\r\ndev->function.set_alt = printer_func_set_alt;\r\ndev->function.disable = printer_func_disable;\r\ndev->function.req_match = gprinter_req_match;\r\ndev->function.free_func = gprinter_free;\r\nINIT_LIST_HEAD(&dev->tx_reqs);\r\nINIT_LIST_HEAD(&dev->rx_reqs);\r\nINIT_LIST_HEAD(&dev->rx_buffers);\r\nINIT_LIST_HEAD(&dev->tx_reqs_active);\r\nINIT_LIST_HEAD(&dev->rx_reqs_active);\r\nspin_lock_init(&dev->lock);\r\nmutex_init(&dev->lock_printer_io);\r\ninit_waitqueue_head(&dev->rx_wait);\r\ninit_waitqueue_head(&dev->tx_wait);\r\ninit_waitqueue_head(&dev->tx_flush_wait);\r\ndev->interface = -1;\r\ndev->printer_cdev_open = 0;\r\ndev->printer_status = PRINTER_NOT_ERROR;\r\ndev->current_rx_req = NULL;\r\ndev->current_rx_bytes = 0;\r\ndev->current_rx_buf = NULL;\r\nreturn &dev->function;\r\n}\r\nstatic int gprinter_setup(int count)\r\n{\r\nint status;\r\ndev_t devt;\r\nusb_gadget_class = class_create(THIS_MODULE, "usb_printer_gadget");\r\nif (IS_ERR(usb_gadget_class)) {\r\nstatus = PTR_ERR(usb_gadget_class);\r\nusb_gadget_class = NULL;\r\npr_err("unable to create usb_gadget class %d\n", status);\r\nreturn status;\r\n}\r\nstatus = alloc_chrdev_region(&devt, 0, count, "USB printer gadget");\r\nif (status) {\r\npr_err("alloc_chrdev_region %d\n", status);\r\nclass_destroy(usb_gadget_class);\r\nusb_gadget_class = NULL;\r\nreturn status;\r\n}\r\nmajor = MAJOR(devt);\r\nminors = count;\r\nreturn status;\r\n}\r\nstatic void gprinter_cleanup(void)\r\n{\r\nif (major) {\r\nunregister_chrdev_region(MKDEV(major, 0), minors);\r\nmajor = minors = 0;\r\n}\r\nclass_destroy(usb_gadget_class);\r\nusb_gadget_class = NULL;\r\n}
