static void sunxi_musb_work(struct work_struct *work)\r\n{\r\nstruct sunxi_glue *glue = container_of(work, struct sunxi_glue, work);\r\nbool vbus_on, phy_on;\r\nif (!test_bit(SUNXI_MUSB_FL_ENABLED, &glue->flags))\r\nreturn;\r\nif (test_and_clear_bit(SUNXI_MUSB_FL_HOSTMODE_PEND, &glue->flags)) {\r\nstruct musb *musb = glue->musb;\r\nunsigned long flags;\r\nu8 devctl;\r\nspin_lock_irqsave(&musb->lock, flags);\r\ndevctl = readb(musb->mregs + SUNXI_MUSB_DEVCTL);\r\nif (test_bit(SUNXI_MUSB_FL_HOSTMODE, &glue->flags)) {\r\nset_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\r\nmusb->xceiv->otg->default_a = 1;\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\nMUSB_HST_MODE(musb);\r\ndevctl |= MUSB_DEVCTL_SESSION;\r\n} else {\r\nclear_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\r\nmusb->xceiv->otg->default_a = 0;\r\nmusb->xceiv->otg->state = OTG_STATE_B_IDLE;\r\nMUSB_DEV_MODE(musb);\r\ndevctl &= ~MUSB_DEVCTL_SESSION;\r\n}\r\nwriteb(devctl, musb->mregs + SUNXI_MUSB_DEVCTL);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\n}\r\nvbus_on = test_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\r\nphy_on = test_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags);\r\nif (phy_on != vbus_on) {\r\nif (vbus_on) {\r\nphy_power_on(glue->phy);\r\nset_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags);\r\n} else {\r\nphy_power_off(glue->phy);\r\nclear_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags);\r\n}\r\n}\r\nif (test_and_clear_bit(SUNXI_MUSB_FL_PHY_MODE_PEND, &glue->flags))\r\nphy_set_mode(glue->phy, glue->phy_mode);\r\n}\r\nstatic void sunxi_musb_set_vbus(struct musb *musb, int is_on)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nif (is_on) {\r\nset_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\r\nmusb->xceiv->otg->state = OTG_STATE_A_WAIT_VRISE;\r\n} else {\r\nclear_bit(SUNXI_MUSB_FL_VBUS_ON, &glue->flags);\r\n}\r\nschedule_work(&glue->work);\r\n}\r\nstatic void sunxi_musb_pre_root_reset_end(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nsun4i_usb_phy_set_squelch_detect(glue->phy, false);\r\n}\r\nstatic void sunxi_musb_post_root_reset_end(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nsun4i_usb_phy_set_squelch_detect(glue->phy, true);\r\n}\r\nstatic irqreturn_t sunxi_musb_interrupt(int irq, void *__hci)\r\n{\r\nstruct musb *musb = __hci;\r\nunsigned long flags;\r\nspin_lock_irqsave(&musb->lock, flags);\r\nmusb->int_usb = readb(musb->mregs + SUNXI_MUSB_INTRUSB);\r\nif (musb->int_usb)\r\nwriteb(musb->int_usb, musb->mregs + SUNXI_MUSB_INTRUSB);\r\nif ((musb->int_usb & MUSB_INTR_RESET) && !is_host_active(musb)) {\r\nmusb_ep_select(musb->mregs, 0);\r\nmusb_writeb(musb->mregs, MUSB_FADDR, 0);\r\n}\r\nmusb->int_tx = readw(musb->mregs + SUNXI_MUSB_INTRTX);\r\nif (musb->int_tx)\r\nwritew(musb->int_tx, musb->mregs + SUNXI_MUSB_INTRTX);\r\nmusb->int_rx = readw(musb->mregs + SUNXI_MUSB_INTRRX);\r\nif (musb->int_rx)\r\nwritew(musb->int_rx, musb->mregs + SUNXI_MUSB_INTRRX);\r\nmusb_interrupt(musb);\r\nspin_unlock_irqrestore(&musb->lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int sunxi_musb_host_notifier(struct notifier_block *nb,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct sunxi_glue *glue = container_of(nb, struct sunxi_glue, host_nb);\r\nif (event)\r\nset_bit(SUNXI_MUSB_FL_HOSTMODE, &glue->flags);\r\nelse\r\nclear_bit(SUNXI_MUSB_FL_HOSTMODE, &glue->flags);\r\nset_bit(SUNXI_MUSB_FL_HOSTMODE_PEND, &glue->flags);\r\nschedule_work(&glue->work);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int sunxi_musb_init(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nint ret;\r\nsunxi_musb = musb;\r\nmusb->phy = glue->phy;\r\nmusb->xceiv = glue->xceiv;\r\nif (test_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags)) {\r\nret = sunxi_sram_claim(musb->controller->parent);\r\nif (ret)\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(glue->clk);\r\nif (ret)\r\ngoto error_sram_release;\r\nif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags)) {\r\nret = reset_control_deassert(glue->rst);\r\nif (ret)\r\ngoto error_clk_disable;\r\n}\r\nwriteb(SUNXI_MUSB_VEND0_PIO_MODE, musb->mregs + SUNXI_MUSB_VEND0);\r\nret = devm_extcon_register_notifier(glue->dev, glue->extcon,\r\nEXTCON_USB_HOST, &glue->host_nb);\r\nif (ret)\r\ngoto error_reset_assert;\r\nret = phy_init(glue->phy);\r\nif (ret)\r\ngoto error_reset_assert;\r\nmusb->isr = sunxi_musb_interrupt;\r\npm_runtime_get(musb->controller);\r\nreturn 0;\r\nerror_reset_assert:\r\nif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags))\r\nreset_control_assert(glue->rst);\r\nerror_clk_disable:\r\nclk_disable_unprepare(glue->clk);\r\nerror_sram_release:\r\nif (test_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags))\r\nsunxi_sram_release(musb->controller->parent);\r\nreturn ret;\r\n}\r\nstatic int sunxi_musb_exit(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\npm_runtime_put(musb->controller);\r\ncancel_work_sync(&glue->work);\r\nif (test_bit(SUNXI_MUSB_FL_PHY_ON, &glue->flags))\r\nphy_power_off(glue->phy);\r\nphy_exit(glue->phy);\r\nif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags))\r\nreset_control_assert(glue->rst);\r\nclk_disable_unprepare(glue->clk);\r\nif (test_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags))\r\nsunxi_sram_release(musb->controller->parent);\r\nreturn 0;\r\n}\r\nstatic void sunxi_musb_enable(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nglue->musb = musb;\r\nif (test_and_set_bit(SUNXI_MUSB_FL_ENABLED, &glue->flags))\r\nreturn;\r\nschedule_work(&glue->work);\r\n}\r\nstatic void sunxi_musb_disable(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nclear_bit(SUNXI_MUSB_FL_ENABLED, &glue->flags);\r\n}\r\nstatic struct dma_controller *\r\nsunxi_musb_dma_controller_create(struct musb *musb, void __iomem *base)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void sunxi_musb_dma_controller_destroy(struct dma_controller *c)\r\n{\r\n}\r\nstatic int sunxi_musb_set_mode(struct musb *musb, u8 mode)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nenum phy_mode new_mode;\r\nswitch (mode) {\r\ncase MUSB_HOST:\r\nnew_mode = PHY_MODE_USB_HOST;\r\nbreak;\r\ncase MUSB_PERIPHERAL:\r\nnew_mode = PHY_MODE_USB_DEVICE;\r\nbreak;\r\ncase MUSB_OTG:\r\nnew_mode = PHY_MODE_USB_OTG;\r\nbreak;\r\ndefault:\r\ndev_err(musb->controller->parent,\r\n"Error requested mode not supported by this kernel\n");\r\nreturn -EINVAL;\r\n}\r\nif (glue->phy_mode == new_mode)\r\nreturn 0;\r\nif (musb->port_mode != MUSB_PORT_MODE_DUAL_ROLE) {\r\ndev_err(musb->controller->parent,\r\n"Error changing modes is only supported in dual role mode\n");\r\nreturn -EINVAL;\r\n}\r\nif (musb->port1_status & USB_PORT_STAT_ENABLE)\r\nmusb_root_disconnect(musb);\r\nglue->phy_mode = new_mode;\r\nset_bit(SUNXI_MUSB_FL_PHY_MODE_PEND, &glue->flags);\r\nschedule_work(&glue->work);\r\nreturn 0;\r\n}\r\nstatic int sunxi_musb_recover(struct musb *musb)\r\n{\r\nstruct sunxi_glue *glue = dev_get_drvdata(musb->controller->parent);\r\nset_bit(SUNXI_MUSB_FL_PHY_MODE_PEND, &glue->flags);\r\nschedule_work(&glue->work);\r\nreturn 0;\r\n}\r\nstatic u32 sunxi_musb_fifo_offset(u8 epnum)\r\n{\r\nreturn (epnum * 4);\r\n}\r\nstatic u32 sunxi_musb_ep_offset(u8 epnum, u16 offset)\r\n{\r\nWARN_ONCE(offset != 0,\r\n"sunxi_musb_ep_offset called with non 0 offset\n");\r\nreturn 0x80;\r\n}\r\nstatic u32 sunxi_musb_busctl_offset(u8 epnum, u16 offset)\r\n{\r\nreturn SUNXI_MUSB_TXFUNCADDR + offset;\r\n}\r\nstatic u8 sunxi_musb_readb(const void __iomem *addr, unsigned offset)\r\n{\r\nstruct sunxi_glue *glue;\r\nif (addr == sunxi_musb->mregs) {\r\nswitch (offset) {\r\ncase MUSB_FADDR:\r\nreturn readb(addr + SUNXI_MUSB_FADDR);\r\ncase MUSB_POWER:\r\nreturn readb(addr + SUNXI_MUSB_POWER);\r\ncase MUSB_INTRUSB:\r\nreturn readb(addr + SUNXI_MUSB_INTRUSB);\r\ncase MUSB_INTRUSBE:\r\nreturn readb(addr + SUNXI_MUSB_INTRUSBE);\r\ncase MUSB_INDEX:\r\nreturn readb(addr + SUNXI_MUSB_INDEX);\r\ncase MUSB_TESTMODE:\r\nreturn 0;\r\ncase MUSB_DEVCTL:\r\nreturn readb(addr + SUNXI_MUSB_DEVCTL);\r\ncase MUSB_TXFIFOSZ:\r\nreturn readb(addr + SUNXI_MUSB_TXFIFOSZ);\r\ncase MUSB_RXFIFOSZ:\r\nreturn readb(addr + SUNXI_MUSB_RXFIFOSZ);\r\ncase MUSB_CONFIGDATA + 0x10:\r\nglue = dev_get_drvdata(sunxi_musb->controller->parent);\r\nif (test_bit(SUNXI_MUSB_FL_NO_CONFIGDATA,\r\n&glue->flags))\r\nreturn 0xde;\r\nreturn readb(addr + SUNXI_MUSB_CONFIGDATA);\r\ncase SUNXI_MUSB_TXFUNCADDR:\r\ncase SUNXI_MUSB_TXHUBADDR:\r\ncase SUNXI_MUSB_TXHUBPORT:\r\ncase SUNXI_MUSB_RXFUNCADDR:\r\ncase SUNXI_MUSB_RXHUBADDR:\r\ncase SUNXI_MUSB_RXHUBPORT:\r\nreturn readb(addr + offset);\r\ndefault:\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown readb offset %u\n", offset);\r\nreturn 0;\r\n}\r\n} else if (addr == (sunxi_musb->mregs + 0x80)) {\r\nif (offset >= MUSB_TXTYPE)\r\noffset += 2;\r\nreturn readb(addr + offset);\r\n}\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown readb at 0x%x bytes offset\n",\r\n(int)(addr - sunxi_musb->mregs));\r\nreturn 0;\r\n}\r\nstatic void sunxi_musb_writeb(void __iomem *addr, unsigned offset, u8 data)\r\n{\r\nif (addr == sunxi_musb->mregs) {\r\nswitch (offset) {\r\ncase MUSB_FADDR:\r\nreturn writeb(data, addr + SUNXI_MUSB_FADDR);\r\ncase MUSB_POWER:\r\nreturn writeb(data, addr + SUNXI_MUSB_POWER);\r\ncase MUSB_INTRUSB:\r\nreturn writeb(data, addr + SUNXI_MUSB_INTRUSB);\r\ncase MUSB_INTRUSBE:\r\nreturn writeb(data, addr + SUNXI_MUSB_INTRUSBE);\r\ncase MUSB_INDEX:\r\nreturn writeb(data, addr + SUNXI_MUSB_INDEX);\r\ncase MUSB_TESTMODE:\r\nif (data)\r\ndev_warn(sunxi_musb->controller->parent,\r\n"sunxi-musb does not have testmode\n");\r\nreturn;\r\ncase MUSB_DEVCTL:\r\nreturn writeb(data, addr + SUNXI_MUSB_DEVCTL);\r\ncase MUSB_TXFIFOSZ:\r\nreturn writeb(data, addr + SUNXI_MUSB_TXFIFOSZ);\r\ncase MUSB_RXFIFOSZ:\r\nreturn writeb(data, addr + SUNXI_MUSB_RXFIFOSZ);\r\ncase SUNXI_MUSB_TXFUNCADDR:\r\ncase SUNXI_MUSB_TXHUBADDR:\r\ncase SUNXI_MUSB_TXHUBPORT:\r\ncase SUNXI_MUSB_RXFUNCADDR:\r\ncase SUNXI_MUSB_RXHUBADDR:\r\ncase SUNXI_MUSB_RXHUBPORT:\r\nreturn writeb(data, addr + offset);\r\ndefault:\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown writeb offset %u\n", offset);\r\nreturn;\r\n}\r\n} else if (addr == (sunxi_musb->mregs + 0x80)) {\r\nif (offset >= MUSB_TXTYPE)\r\noffset += 2;\r\nreturn writeb(data, addr + offset);\r\n}\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown writeb at 0x%x bytes offset\n",\r\n(int)(addr - sunxi_musb->mregs));\r\n}\r\nstatic u16 sunxi_musb_readw(const void __iomem *addr, unsigned offset)\r\n{\r\nif (addr == sunxi_musb->mregs) {\r\nswitch (offset) {\r\ncase MUSB_INTRTX:\r\nreturn readw(addr + SUNXI_MUSB_INTRTX);\r\ncase MUSB_INTRRX:\r\nreturn readw(addr + SUNXI_MUSB_INTRRX);\r\ncase MUSB_INTRTXE:\r\nreturn readw(addr + SUNXI_MUSB_INTRTXE);\r\ncase MUSB_INTRRXE:\r\nreturn readw(addr + SUNXI_MUSB_INTRRXE);\r\ncase MUSB_FRAME:\r\nreturn readw(addr + SUNXI_MUSB_FRAME);\r\ncase MUSB_TXFIFOADD:\r\nreturn readw(addr + SUNXI_MUSB_TXFIFOADD);\r\ncase MUSB_RXFIFOADD:\r\nreturn readw(addr + SUNXI_MUSB_RXFIFOADD);\r\ncase MUSB_HWVERS:\r\nreturn 0;\r\ndefault:\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown readw offset %u\n", offset);\r\nreturn 0;\r\n}\r\n} else if (addr == (sunxi_musb->mregs + 0x80)) {\r\nreturn readw(addr + offset);\r\n}\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown readw at 0x%x bytes offset\n",\r\n(int)(addr - sunxi_musb->mregs));\r\nreturn 0;\r\n}\r\nstatic void sunxi_musb_writew(void __iomem *addr, unsigned offset, u16 data)\r\n{\r\nif (addr == sunxi_musb->mregs) {\r\nswitch (offset) {\r\ncase MUSB_INTRTX:\r\nreturn writew(data, addr + SUNXI_MUSB_INTRTX);\r\ncase MUSB_INTRRX:\r\nreturn writew(data, addr + SUNXI_MUSB_INTRRX);\r\ncase MUSB_INTRTXE:\r\nreturn writew(data, addr + SUNXI_MUSB_INTRTXE);\r\ncase MUSB_INTRRXE:\r\nreturn writew(data, addr + SUNXI_MUSB_INTRRXE);\r\ncase MUSB_FRAME:\r\nreturn writew(data, addr + SUNXI_MUSB_FRAME);\r\ncase MUSB_TXFIFOADD:\r\nreturn writew(data, addr + SUNXI_MUSB_TXFIFOADD);\r\ncase MUSB_RXFIFOADD:\r\nreturn writew(data, addr + SUNXI_MUSB_RXFIFOADD);\r\ndefault:\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown writew offset %u\n", offset);\r\nreturn;\r\n}\r\n} else if (addr == (sunxi_musb->mregs + 0x80)) {\r\nreturn writew(data, addr + offset);\r\n}\r\ndev_err(sunxi_musb->controller->parent,\r\n"Error unknown writew at 0x%x bytes offset\n",\r\n(int)(addr - sunxi_musb->mregs));\r\n}\r\nstatic int sunxi_musb_probe(struct platform_device *pdev)\r\n{\r\nstruct musb_hdrc_platform_data pdata;\r\nstruct platform_device_info pinfo;\r\nstruct sunxi_glue *glue;\r\nstruct device_node *np = pdev->dev.of_node;\r\nint ret;\r\nif (!np) {\r\ndev_err(&pdev->dev, "Error no device tree node found\n");\r\nreturn -EINVAL;\r\n}\r\nglue = devm_kzalloc(&pdev->dev, sizeof(*glue), GFP_KERNEL);\r\nif (!glue)\r\nreturn -ENOMEM;\r\nmemset(&pdata, 0, sizeof(pdata));\r\nswitch (usb_get_dr_mode(&pdev->dev)) {\r\n#if defined CONFIG_USB_MUSB_DUAL_ROLE || defined CONFIG_USB_MUSB_HOST\r\ncase USB_DR_MODE_HOST:\r\npdata.mode = MUSB_PORT_MODE_HOST;\r\nglue->phy_mode = PHY_MODE_USB_HOST;\r\nbreak;\r\n#endif\r\n#if defined CONFIG_USB_MUSB_DUAL_ROLE || defined CONFIG_USB_MUSB_GADGET\r\ncase USB_DR_MODE_PERIPHERAL:\r\npdata.mode = MUSB_PORT_MODE_GADGET;\r\nglue->phy_mode = PHY_MODE_USB_DEVICE;\r\nbreak;\r\n#endif\r\n#ifdef CONFIG_USB_MUSB_DUAL_ROLE\r\ncase USB_DR_MODE_OTG:\r\npdata.mode = MUSB_PORT_MODE_DUAL_ROLE;\r\nglue->phy_mode = PHY_MODE_USB_OTG;\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(&pdev->dev, "Invalid or missing 'dr_mode' property\n");\r\nreturn -EINVAL;\r\n}\r\npdata.platform_ops = &sunxi_musb_ops;\r\nif (!of_device_is_compatible(np, "allwinner,sun8i-h3-musb"))\r\npdata.config = &sunxi_musb_hdrc_config;\r\nelse\r\npdata.config = &sunxi_musb_hdrc_config_h3;\r\nglue->dev = &pdev->dev;\r\nINIT_WORK(&glue->work, sunxi_musb_work);\r\nglue->host_nb.notifier_call = sunxi_musb_host_notifier;\r\nif (of_device_is_compatible(np, "allwinner,sun4i-a10-musb"))\r\nset_bit(SUNXI_MUSB_FL_HAS_SRAM, &glue->flags);\r\nif (of_device_is_compatible(np, "allwinner,sun6i-a31-musb"))\r\nset_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags);\r\nif (of_device_is_compatible(np, "allwinner,sun8i-a33-musb") ||\r\nof_device_is_compatible(np, "allwinner,sun8i-h3-musb")) {\r\nset_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags);\r\nset_bit(SUNXI_MUSB_FL_NO_CONFIGDATA, &glue->flags);\r\n}\r\nglue->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(glue->clk)) {\r\ndev_err(&pdev->dev, "Error getting clock: %ld\n",\r\nPTR_ERR(glue->clk));\r\nreturn PTR_ERR(glue->clk);\r\n}\r\nif (test_bit(SUNXI_MUSB_FL_HAS_RESET, &glue->flags)) {\r\nglue->rst = devm_reset_control_get(&pdev->dev, NULL);\r\nif (IS_ERR(glue->rst)) {\r\nif (PTR_ERR(glue->rst) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_err(&pdev->dev, "Error getting reset %ld\n",\r\nPTR_ERR(glue->rst));\r\nreturn PTR_ERR(glue->rst);\r\n}\r\n}\r\nglue->extcon = extcon_get_edev_by_phandle(&pdev->dev, 0);\r\nif (IS_ERR(glue->extcon)) {\r\nif (PTR_ERR(glue->extcon) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_err(&pdev->dev, "Invalid or missing extcon\n");\r\nreturn PTR_ERR(glue->extcon);\r\n}\r\nglue->phy = devm_phy_get(&pdev->dev, "usb");\r\nif (IS_ERR(glue->phy)) {\r\nif (PTR_ERR(glue->phy) == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\ndev_err(&pdev->dev, "Error getting phy %ld\n",\r\nPTR_ERR(glue->phy));\r\nreturn PTR_ERR(glue->phy);\r\n}\r\nglue->usb_phy = usb_phy_generic_register();\r\nif (IS_ERR(glue->usb_phy)) {\r\ndev_err(&pdev->dev, "Error registering usb-phy %ld\n",\r\nPTR_ERR(glue->usb_phy));\r\nreturn PTR_ERR(glue->usb_phy);\r\n}\r\nglue->xceiv = devm_usb_get_phy(&pdev->dev, USB_PHY_TYPE_USB2);\r\nif (IS_ERR(glue->xceiv)) {\r\nret = PTR_ERR(glue->xceiv);\r\ndev_err(&pdev->dev, "Error getting usb-phy %d\n", ret);\r\ngoto err_unregister_usb_phy;\r\n}\r\nplatform_set_drvdata(pdev, glue);\r\nmemset(&pinfo, 0, sizeof(pinfo));\r\npinfo.name = "musb-hdrc";\r\npinfo.id = PLATFORM_DEVID_AUTO;\r\npinfo.parent = &pdev->dev;\r\npinfo.res = pdev->resource;\r\npinfo.num_res = pdev->num_resources;\r\npinfo.data = &pdata;\r\npinfo.size_data = sizeof(pdata);\r\nglue->musb_pdev = platform_device_register_full(&pinfo);\r\nif (IS_ERR(glue->musb_pdev)) {\r\nret = PTR_ERR(glue->musb_pdev);\r\ndev_err(&pdev->dev, "Error registering musb dev: %d\n", ret);\r\ngoto err_unregister_usb_phy;\r\n}\r\nreturn 0;\r\nerr_unregister_usb_phy:\r\nusb_phy_generic_unregister(glue->usb_phy);\r\nreturn ret;\r\n}\r\nstatic int sunxi_musb_remove(struct platform_device *pdev)\r\n{\r\nstruct sunxi_glue *glue = platform_get_drvdata(pdev);\r\nstruct platform_device *usb_phy = glue->usb_phy;\r\nplatform_device_unregister(glue->musb_pdev);\r\nusb_phy_generic_unregister(usb_phy);\r\nreturn 0;\r\n}
