static inline int encode_cpu(int cpu_nr)\r\n{\r\nreturn cpu_nr + 1;\r\n}\r\nstatic inline int node_cpu(struct optimistic_spin_node *node)\r\n{\r\nreturn node->cpu - 1;\r\n}\r\nstatic inline struct optimistic_spin_node *decode_cpu(int encoded_cpu_val)\r\n{\r\nint cpu_nr = encoded_cpu_val - 1;\r\nreturn per_cpu_ptr(&osq_node, cpu_nr);\r\n}\r\nstatic inline struct optimistic_spin_node *\r\nosq_wait_next(struct optimistic_spin_queue *lock,\r\nstruct optimistic_spin_node *node,\r\nstruct optimistic_spin_node *prev)\r\n{\r\nstruct optimistic_spin_node *next = NULL;\r\nint curr = encode_cpu(smp_processor_id());\r\nint old;\r\nold = prev ? prev->cpu : OSQ_UNLOCKED_VAL;\r\nfor (;;) {\r\nif (atomic_read(&lock->tail) == curr &&\r\natomic_cmpxchg_acquire(&lock->tail, curr, old) == curr) {\r\nbreak;\r\n}\r\nif (node->next) {\r\nnext = xchg(&node->next, NULL);\r\nif (next)\r\nbreak;\r\n}\r\ncpu_relax();\r\n}\r\nreturn next;\r\n}\r\nbool osq_lock(struct optimistic_spin_queue *lock)\r\n{\r\nstruct optimistic_spin_node *node = this_cpu_ptr(&osq_node);\r\nstruct optimistic_spin_node *prev, *next;\r\nint curr = encode_cpu(smp_processor_id());\r\nint old;\r\nnode->locked = 0;\r\nnode->next = NULL;\r\nnode->cpu = curr;\r\nold = atomic_xchg(&lock->tail, curr);\r\nif (old == OSQ_UNLOCKED_VAL)\r\nreturn true;\r\nprev = decode_cpu(old);\r\nnode->prev = prev;\r\nWRITE_ONCE(prev->next, node);\r\nwhile (!READ_ONCE(node->locked)) {\r\nif (need_resched() || vcpu_is_preempted(node_cpu(node->prev)))\r\ngoto unqueue;\r\ncpu_relax();\r\n}\r\nreturn true;\r\nunqueue:\r\nfor (;;) {\r\nif (prev->next == node &&\r\ncmpxchg(&prev->next, node, NULL) == node)\r\nbreak;\r\nif (smp_load_acquire(&node->locked))\r\nreturn true;\r\ncpu_relax();\r\nprev = READ_ONCE(node->prev);\r\n}\r\nnext = osq_wait_next(lock, node, prev);\r\nif (!next)\r\nreturn false;\r\nWRITE_ONCE(next->prev, prev);\r\nWRITE_ONCE(prev->next, next);\r\nreturn false;\r\n}\r\nvoid osq_unlock(struct optimistic_spin_queue *lock)\r\n{\r\nstruct optimistic_spin_node *node, *next;\r\nint curr = encode_cpu(smp_processor_id());\r\nif (likely(atomic_cmpxchg_release(&lock->tail, curr,\r\nOSQ_UNLOCKED_VAL) == curr))\r\nreturn;\r\nnode = this_cpu_ptr(&osq_node);\r\nnext = xchg(&node->next, NULL);\r\nif (next) {\r\nWRITE_ONCE(next->locked, 1);\r\nreturn;\r\n}\r\nnext = osq_wait_next(lock, node, NULL);\r\nif (next)\r\nWRITE_ONCE(next->locked, 1);\r\n}
