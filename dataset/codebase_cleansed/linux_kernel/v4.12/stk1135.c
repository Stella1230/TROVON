static u8 reg_r(struct gspca_dev *gspca_dev, u16 index)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nint ret;\r\nif (gspca_dev->usb_err < 0)\r\nreturn 0;\r\nret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\r\n0x00,\r\nUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\n0x00,\r\nindex,\r\ngspca_dev->usb_buf, 1,\r\n500);\r\nPDEBUG(D_USBI, "reg_r 0x%x=0x%02x", index, gspca_dev->usb_buf[0]);\r\nif (ret < 0) {\r\npr_err("reg_r 0x%x err %d\n", index, ret);\r\ngspca_dev->usb_err = ret;\r\nreturn 0;\r\n}\r\nreturn gspca_dev->usb_buf[0];\r\n}\r\nstatic void reg_w(struct gspca_dev *gspca_dev, u16 index, u8 val)\r\n{\r\nint ret;\r\nstruct usb_device *dev = gspca_dev->dev;\r\nif (gspca_dev->usb_err < 0)\r\nreturn;\r\nret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\r\n0x01,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nval,\r\nindex,\r\nNULL,\r\n0,\r\n500);\r\nPDEBUG(D_USBO, "reg_w 0x%x:=0x%02x", index, val);\r\nif (ret < 0) {\r\npr_err("reg_w 0x%x err %d\n", index, ret);\r\ngspca_dev->usb_err = ret;\r\n}\r\n}\r\nstatic void reg_w_mask(struct gspca_dev *gspca_dev, u16 index, u8 val, u8 mask)\r\n{\r\nval = (reg_r(gspca_dev, index) & ~mask) | (val & mask);\r\nreg_w(gspca_dev, index, val);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\ngspca_dev->cam.cam_mode = stk1135_modes;\r\ngspca_dev->cam.nmodes = ARRAY_SIZE(stk1135_modes);\r\nreturn 0;\r\n}\r\nstatic int stk1135_serial_wait_ready(struct gspca_dev *gspca_dev)\r\n{\r\nint i = 0;\r\nu8 val;\r\ndo {\r\nval = reg_r(gspca_dev, STK1135_REG_SICTL + 1);\r\nif (i++ > 500) {\r\npr_err("serial bus timeout: status=0x%02x\n", val);\r\nreturn -1;\r\n}\r\n} while ((val & 0x10) || !(val & 0x05));\r\nreturn 0;\r\n}\r\nstatic u8 sensor_read_8(struct gspca_dev *gspca_dev, u8 addr)\r\n{\r\nreg_w(gspca_dev, STK1135_REG_SBUSR, addr);\r\nreg_w(gspca_dev, STK1135_REG_SICTL, 0x20);\r\nif (stk1135_serial_wait_ready(gspca_dev)) {\r\npr_err("Sensor read failed\n");\r\nreturn 0;\r\n}\r\nreturn reg_r(gspca_dev, STK1135_REG_SBUSR + 1);\r\n}\r\nstatic u16 sensor_read_16(struct gspca_dev *gspca_dev, u8 addr)\r\n{\r\nreturn (sensor_read_8(gspca_dev, addr) << 8) |\r\nsensor_read_8(gspca_dev, 0xf1);\r\n}\r\nstatic void sensor_write_8(struct gspca_dev *gspca_dev, u8 addr, u8 data)\r\n{\r\nreg_w(gspca_dev, STK1135_REG_SBUSW, addr);\r\nreg_w(gspca_dev, STK1135_REG_SBUSW + 1, data);\r\nreg_w(gspca_dev, STK1135_REG_SICTL, 0x01);\r\nif (stk1135_serial_wait_ready(gspca_dev)) {\r\npr_err("Sensor write failed\n");\r\nreturn;\r\n}\r\n}\r\nstatic void sensor_write_16(struct gspca_dev *gspca_dev, u8 addr, u16 data)\r\n{\r\nsensor_write_8(gspca_dev, addr, data >> 8);\r\nsensor_write_8(gspca_dev, 0xf1, data & 0xff);\r\n}\r\nstatic void sensor_set_page(struct gspca_dev *gspca_dev, u8 page)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (page != sd->sensor_page) {\r\nsensor_write_16(gspca_dev, 0xf0, page);\r\nsd->sensor_page = page;\r\n}\r\n}\r\nstatic u16 sensor_read(struct gspca_dev *gspca_dev, u16 reg)\r\n{\r\nsensor_set_page(gspca_dev, reg >> 8);\r\nreturn sensor_read_16(gspca_dev, reg & 0xff);\r\n}\r\nstatic void sensor_write(struct gspca_dev *gspca_dev, u16 reg, u16 val)\r\n{\r\nsensor_set_page(gspca_dev, reg >> 8);\r\nsensor_write_16(gspca_dev, reg & 0xff, val);\r\n}\r\nstatic void sensor_write_mask(struct gspca_dev *gspca_dev,\r\nu16 reg, u16 val, u16 mask)\r\n{\r\nval = (sensor_read(gspca_dev, reg) & ~mask) | (val & mask);\r\nsensor_write(gspca_dev, reg, val);\r\n}\r\nstatic void stk1135_configure_mt9m112(struct gspca_dev *gspca_dev)\r\n{\r\nstatic const struct sensor_val cfg[] = {\r\n{ 0x00d, 0x000b }, { 0x00d, 0x0008 }, { 0x035, 0x0022 },\r\n{ 0x106, 0x700e },\r\n{ 0x2dd, 0x18e0 },\r\n{ 0x21f, 0x0180 },\r\n{ 0x220, 0xc814 }, { 0x221, 0x8080 },\r\n{ 0x222, 0xa078 }, { 0x223, 0xa078 },\r\n{ 0x224, 0x5f20 }, { 0x228, 0xea02 },\r\n{ 0x229, 0x867a },\r\n{ 0x25e, 0x594c }, { 0x25f, 0x4d51 }, { 0x260, 0x0002 },\r\n{ 0x2ef, 0x0008 }, { 0x2f2, 0x0000 },\r\n{ 0x202, 0x00ee }, { 0x203, 0x3923 }, { 0x204, 0x0724 },\r\n{ 0x209, 0x00cd }, { 0x20a, 0x0093 }, { 0x20b, 0x0004 },\r\n{ 0x20c, 0x005c }, { 0x20d, 0x00d9 }, { 0x20e, 0x0053 },\r\n{ 0x20f, 0x0008 }, { 0x210, 0x0091 }, { 0x211, 0x00cf },\r\n{ 0x215, 0x0000 },\r\n{ 0x216, 0x0000 }, { 0x217, 0x0000 }, { 0x218, 0x0000 },\r\n{ 0x219, 0x0000 }, { 0x21a, 0x0000 }, { 0x21b, 0x0000 },\r\n{ 0x21c, 0x0000 }, { 0x21d, 0x0000 }, { 0x21e, 0x0000 },\r\n{ 0x106, 0xf00e }, { 0x106, 0x700e },\r\n{ 0x180, 0x0007 },\r\n{ 0x181, 0xde13 }, { 0x182, 0xebe2 }, { 0x183, 0x00f6 },\r\n{ 0x184, 0xe114 }, { 0x185, 0xeadd }, { 0x186, 0xfdf6 },\r\n{ 0x187, 0xe511 }, { 0x188, 0xede6 }, { 0x189, 0xfbf7 },\r\n{ 0x18a, 0xd613 }, { 0x18b, 0xedec },\r\n{ 0x18c, 0xf9f2 }, { 0x18d, 0x0000 },\r\n{ 0x18e, 0xd815 }, { 0x18f, 0xe9ea },\r\n{ 0x190, 0xf9f1 }, { 0x191, 0x0002 },\r\n{ 0x192, 0xde10 }, { 0x193, 0xefef },\r\n{ 0x194, 0xfbf4 }, { 0x195, 0x0002 },\r\n{ 0x1b6, 0x0e06 }, { 0x1b7, 0x2713 },\r\n{ 0x1b8, 0x1106 }, { 0x1b9, 0x2713 },\r\n{ 0x1ba, 0x0c03 }, { 0x1bb, 0x2a0f },\r\n{ 0x1bc, 0x1208 }, { 0x1bd, 0x1a16 }, { 0x1be, 0x0022 },\r\n{ 0x1bf, 0x150a }, { 0x1c0, 0x1c1a }, { 0x1c1, 0x002d },\r\n{ 0x1c2, 0x1109 }, { 0x1c3, 0x1414 }, { 0x1c4, 0x002a },\r\n{ 0x106, 0x740e },\r\n{ 0x153, 0x0b03 }, { 0x154, 0x4722 }, { 0x155, 0xac82 },\r\n{ 0x156, 0xdac7 }, { 0x157, 0xf5e9 }, { 0x158, 0xff00 },\r\n{ 0x1dc, 0x0b03 }, { 0x1dd, 0x4722 }, { 0x1de, 0xac82 },\r\n{ 0x1df, 0xdac7 }, { 0x1e0, 0xf5e9 }, { 0x1e1, 0xff00 },\r\n{ 0x13a, 0x4300 }, { 0x19b, 0x4300 },\r\n{ 0x108, 0x0180 },\r\n{ 0x22f, 0xd100 }, { 0x29c, 0xd100 },\r\n{ 0x2d2, 0x0000 }, { 0x2cc, 0x0004 }, { 0x2cb, 0x0001 },\r\n{ 0x22e, 0x0c3c }, { 0x267, 0x1010 },\r\n{ 0x065, 0xa000 },\r\n{ 0x066, 0x2003 }, { 0x067, 0x0501 },\r\n{ 0x065, 0x2000 },\r\n{ 0x005, 0x01b8 }, { 0x007, 0x00d8 },\r\n{ 0x239, 0x06c0 }, { 0x23b, 0x040e },\r\n{ 0x23a, 0x06c0 }, { 0x23c, 0x0564 },\r\n{ 0x257, 0x0208 }, { 0x258, 0x0271 },\r\n{ 0x259, 0x0209 }, { 0x25a, 0x0271 },\r\n{ 0x25c, 0x120d }, { 0x25d, 0x1712 },\r\n{ 0x264, 0x5e1c },\r\n{ 0x25b, 0x0003 }, { 0x236, 0x7810 }, { 0x237, 0x8304 },\r\n{ 0x008, 0x0021 },\r\n};\r\nint i;\r\nu16 width, height;\r\nfor (i = 0; i < ARRAY_SIZE(cfg); i++)\r\nsensor_write(gspca_dev, cfg[i].reg, cfg[i].val);\r\nwidth = gspca_dev->pixfmt.width;\r\nheight = gspca_dev->pixfmt.height;\r\nif (width <= 640 && height <= 512) {\r\nsensor_write(gspca_dev, 0x1a7, width);\r\nsensor_write(gspca_dev, 0x1aa, height);\r\nsensor_write(gspca_dev, 0x0c8, 0x0000);\r\nsensor_write(gspca_dev, 0x2c8, 0x0000);\r\n} else {\r\nsensor_write(gspca_dev, 0x1a1, width);\r\nsensor_write(gspca_dev, 0x1a4, height);\r\nsensor_write(gspca_dev, 0x0c8, 0x0008);\r\nsensor_write(gspca_dev, 0x2c8, 0x040b);\r\n}\r\n}\r\nstatic void stk1135_configure_clock(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, STK1135_REG_TMGEN, 0x12);\r\nreg_w(gspca_dev, STK1135_REG_TCP1 + 0, 0x41);\r\nreg_w(gspca_dev, STK1135_REG_TCP1 + 1, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_TCP1 + 2, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_TCP1 + 3, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_SENSO + 0, 0x10);\r\nreg_w(gspca_dev, STK1135_REG_SENSO + 1, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_SENSO + 3, 0x07);\r\nreg_w(gspca_dev, STK1135_REG_PLLFD, 0x06);\r\nreg_w(gspca_dev, STK1135_REG_TMGEN, 0x80);\r\nreg_w(gspca_dev, STK1135_REG_SENSO + 2, 0x04);\r\nreg_w(gspca_dev, STK1135_REG_SICTL + 2, 0x1f);\r\nudelay(1000);\r\n}\r\nstatic void stk1135_camera_disable(struct gspca_dev *gspca_dev)\r\n{\r\nreg_w(gspca_dev, STK1135_REG_CIEPO + 2, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_CIEPO + 3, 0x00);\r\nreg_w_mask(gspca_dev, STK1135_REG_SCTRL, 0x00, 0x80);\r\nsensor_write_mask(gspca_dev, 0x00d, 0x0004, 0x000c);\r\nreg_w_mask(gspca_dev, STK1135_REG_SENSO + 2, 0x00, 0x01);\r\nreg_w(gspca_dev, STK1135_REG_TMGEN, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_SENSO + 1, 0x20);\r\nreg_w(gspca_dev, STK1135_REG_SENSO, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_GCTRL, 0x49);\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nu16 sensor_id;\r\nchar *sensor_name;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nreg_w(gspca_dev, STK1135_REG_GCTRL + 2, 0x78);\r\nreg_w(gspca_dev, STK1135_REG_GCTRL, (1 << 5));\r\nreg_w(gspca_dev, STK1135_REG_GCTRL + 3, 0x80);\r\nreg_w(gspca_dev, STK1135_REG_ICTRL + 1, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_ICTRL + 3, 0x03);\r\nreg_w(gspca_dev, STK1135_REG_RMCTL + 1, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_RMCTL + 3, 0x02);\r\nreg_w(gspca_dev, STK1135_REG_SICTL, 0x80);\r\nreg_w(gspca_dev, STK1135_REG_SICTL, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_SICTL + 3, 0xba);\r\nreg_w(gspca_dev, STK1135_REG_ASIC + 3, 0x00);\r\nstk1135_configure_clock(gspca_dev);\r\nsd->sensor_page = 0xff;\r\nsensor_id = sensor_read(gspca_dev, 0x000);\r\nswitch (sensor_id) {\r\ncase 0x148c:\r\nsensor_name = "MT9M112";\r\nbreak;\r\ndefault:\r\nsensor_name = "unknown";\r\n}\r\npr_info("Detected sensor type %s (0x%x)\n", sensor_name, sensor_id);\r\nstk1135_camera_disable(gspca_dev);\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nu16 width, height;\r\nreg_w(gspca_dev, STK1135_REG_GCTRL, (1 << 5));\r\nstk1135_configure_clock(gspca_dev);\r\nreg_w(gspca_dev, STK1135_REG_CISPO + 0, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_CISPO + 1, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_CISPO + 2, 0x00);\r\nreg_w(gspca_dev, STK1135_REG_CISPO + 3, 0x00);\r\nwidth = gspca_dev->pixfmt.width;\r\nheight = gspca_dev->pixfmt.height;\r\nreg_w(gspca_dev, STK1135_REG_CIEPO + 0, width & 0xff);\r\nreg_w(gspca_dev, STK1135_REG_CIEPO + 1, width >> 8);\r\nreg_w(gspca_dev, STK1135_REG_CIEPO + 2, height & 0xff);\r\nreg_w(gspca_dev, STK1135_REG_CIEPO + 3, height >> 8);\r\nreg_w(gspca_dev, STK1135_REG_SCTRL, 0x20);\r\nstk1135_configure_mt9m112(gspca_dev);\r\nreg_w_mask(gspca_dev, STK1135_REG_SCTRL, 0x80, 0x80);\r\nif (gspca_dev->usb_err >= 0)\r\nPDEBUG(D_STREAM, "camera started alt: 0x%02x",\r\ngspca_dev->alt);\r\nsd->pkt_seq = 0;\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic void sd_stopN(struct gspca_dev *gspca_dev)\r\n{\r\nstruct usb_device *dev = gspca_dev->dev;\r\nusb_set_interface(dev, gspca_dev->iface, 0);\r\nstk1135_camera_disable(gspca_dev);\r\nPDEBUG(D_STREAM, "camera stopped");\r\n}\r\nstatic void sd_pkt_scan(struct gspca_dev *gspca_dev,\r\nu8 *data,\r\nint len)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint skip = sizeof(struct stk1135_pkt_header);\r\nbool flip;\r\nenum gspca_packet_type pkt_type = INTER_PACKET;\r\nstruct stk1135_pkt_header *hdr = (void *)data;\r\nu8 seq;\r\nif (len < 4) {\r\nPDEBUG(D_PACK, "received short packet (less than 4 bytes)");\r\nreturn;\r\n}\r\nflip = !(le16_to_cpu(hdr->gpio) & (1 << 8));\r\nif (sd->flip_status != flip)\r\nsd->flip_debounce++;\r\nelse\r\nsd->flip_debounce = 0;\r\nif (!(hdr->flags & STK1135_HDR_FRAME_START)) {\r\nseq = hdr->seq & STK1135_HDR_SEQ_MASK;\r\nif (seq != sd->pkt_seq) {\r\nPDEBUG(D_PACK, "received out-of-sequence packet");\r\nsd->pkt_seq = seq;\r\ngspca_dev->last_packet_type = DISCARD_PACKET;\r\nreturn;\r\n}\r\n}\r\nsd->pkt_seq++;\r\nif (sd->pkt_seq > STK1135_HDR_SEQ_MASK)\r\nsd->pkt_seq = 0;\r\nif (len == sizeof(struct stk1135_pkt_header))\r\nreturn;\r\nif (hdr->flags & STK1135_HDR_FRAME_START) {\r\nskip = 8;\r\ngspca_frame_add(gspca_dev, LAST_PACKET, data, 0);\r\npkt_type = FIRST_PACKET;\r\n}\r\ngspca_frame_add(gspca_dev, pkt_type, data + skip, len - skip);\r\n}\r\nstatic void sethflip(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->flip_status)\r\nval = !val;\r\nsensor_write_mask(gspca_dev, 0x020, val ? 0x0002 : 0x0000 , 0x0002);\r\n}\r\nstatic void setvflip(struct gspca_dev *gspca_dev, s32 val)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->flip_status)\r\nval = !val;\r\nsensor_write_mask(gspca_dev, 0x020, val ? 0x0001 : 0x0000 , 0x0001);\r\n}\r\nstatic void stk1135_dq_callback(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nif (sd->flip_debounce > 100) {\r\nsd->flip_status = !sd->flip_status;\r\nsethflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->hflip));\r\nsetvflip(gspca_dev, v4l2_ctrl_g_ctrl(sd->vflip));\r\n}\r\n}\r\nstatic int sd_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\ngspca_dev->usb_err = 0;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nsethflip(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nsetvflip(gspca_dev, ctrl->val);\r\nbreak;\r\n}\r\nreturn gspca_dev->usb_err;\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 2);\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_HFLIP, 0, 1, 1, 0);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &sd_ctrl_ops,\r\nV4L2_CID_VFLIP, 0, 1, 1, 0);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stk1135_try_fmt(struct gspca_dev *gspca_dev, struct v4l2_format *fmt)\r\n{\r\nfmt->fmt.pix.width = clamp(fmt->fmt.pix.width, 32U, 1280U);\r\nfmt->fmt.pix.height = clamp(fmt->fmt.pix.height, 32U, 1024U);\r\nfmt->fmt.pix.width += (fmt->fmt.pix.width & 1);\r\nfmt->fmt.pix.height += (fmt->fmt.pix.height & 1);\r\nfmt->fmt.pix.bytesperline = fmt->fmt.pix.width;\r\nfmt->fmt.pix.sizeimage = fmt->fmt.pix.width * fmt->fmt.pix.height;\r\n}\r\nstatic int stk1135_enum_framesizes(struct gspca_dev *gspca_dev,\r\nstruct v4l2_frmsizeenum *fsize)\r\n{\r\nif (fsize->index != 0 || fsize->pixel_format != V4L2_PIX_FMT_SBGGR8)\r\nreturn -EINVAL;\r\nfsize->type = V4L2_FRMSIZE_TYPE_STEPWISE;\r\nfsize->stepwise.min_width = 32;\r\nfsize->stepwise.min_height = 32;\r\nfsize->stepwise.max_width = 1280;\r\nfsize->stepwise.max_height = 1024;\r\nfsize->stepwise.step_width = 2;\r\nfsize->stepwise.step_height = 2;\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id, &sd_desc, sizeof(struct sd),\r\nTHIS_MODULE);\r\n}
