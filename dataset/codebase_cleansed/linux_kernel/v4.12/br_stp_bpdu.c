static int br_send_bpdu_finish(struct net *net, struct sock *sk,\r\nstruct sk_buff *skb)\r\n{\r\nreturn dev_queue_xmit(skb);\r\n}\r\nstatic void br_send_bpdu(struct net_bridge_port *p,\r\nconst unsigned char *data, int length)\r\n{\r\nstruct sk_buff *skb;\r\nskb = dev_alloc_skb(length+LLC_RESERVE);\r\nif (!skb)\r\nreturn;\r\nskb->dev = p->dev;\r\nskb->protocol = htons(ETH_P_802_2);\r\nskb->priority = TC_PRIO_CONTROL;\r\nskb_reserve(skb, LLC_RESERVE);\r\nmemcpy(__skb_put(skb, length), data, length);\r\nllc_pdu_header_init(skb, LLC_PDU_TYPE_U, LLC_SAP_BSPAN,\r\nLLC_SAP_BSPAN, LLC_PDU_CMD);\r\nllc_pdu_init_as_ui_cmd(skb);\r\nllc_mac_hdr_init(skb, p->dev->dev_addr, p->br->group_addr);\r\nskb_reset_mac_header(skb);\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,\r\ndev_net(p->dev), NULL, skb, NULL, skb->dev,\r\nbr_send_bpdu_finish);\r\n}\r\nstatic inline void br_set_ticks(unsigned char *dest, int j)\r\n{\r\nunsigned long ticks = (STP_HZ * j)/ HZ;\r\nput_unaligned_be16(ticks, dest);\r\n}\r\nstatic inline int br_get_ticks(const unsigned char *src)\r\n{\r\nunsigned long ticks = get_unaligned_be16(src);\r\nreturn DIV_ROUND_UP(ticks * HZ, STP_HZ);\r\n}\r\nvoid br_send_config_bpdu(struct net_bridge_port *p, struct br_config_bpdu *bpdu)\r\n{\r\nunsigned char buf[35];\r\nif (p->br->stp_enabled != BR_KERNEL_STP)\r\nreturn;\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nbuf[2] = 0;\r\nbuf[3] = BPDU_TYPE_CONFIG;\r\nbuf[4] = (bpdu->topology_change ? 0x01 : 0) |\r\n(bpdu->topology_change_ack ? 0x80 : 0);\r\nbuf[5] = bpdu->root.prio[0];\r\nbuf[6] = bpdu->root.prio[1];\r\nbuf[7] = bpdu->root.addr[0];\r\nbuf[8] = bpdu->root.addr[1];\r\nbuf[9] = bpdu->root.addr[2];\r\nbuf[10] = bpdu->root.addr[3];\r\nbuf[11] = bpdu->root.addr[4];\r\nbuf[12] = bpdu->root.addr[5];\r\nbuf[13] = (bpdu->root_path_cost >> 24) & 0xFF;\r\nbuf[14] = (bpdu->root_path_cost >> 16) & 0xFF;\r\nbuf[15] = (bpdu->root_path_cost >> 8) & 0xFF;\r\nbuf[16] = bpdu->root_path_cost & 0xFF;\r\nbuf[17] = bpdu->bridge_id.prio[0];\r\nbuf[18] = bpdu->bridge_id.prio[1];\r\nbuf[19] = bpdu->bridge_id.addr[0];\r\nbuf[20] = bpdu->bridge_id.addr[1];\r\nbuf[21] = bpdu->bridge_id.addr[2];\r\nbuf[22] = bpdu->bridge_id.addr[3];\r\nbuf[23] = bpdu->bridge_id.addr[4];\r\nbuf[24] = bpdu->bridge_id.addr[5];\r\nbuf[25] = (bpdu->port_id >> 8) & 0xFF;\r\nbuf[26] = bpdu->port_id & 0xFF;\r\nbr_set_ticks(buf+27, bpdu->message_age);\r\nbr_set_ticks(buf+29, bpdu->max_age);\r\nbr_set_ticks(buf+31, bpdu->hello_time);\r\nbr_set_ticks(buf+33, bpdu->forward_delay);\r\nbr_send_bpdu(p, buf, 35);\r\n}\r\nvoid br_send_tcn_bpdu(struct net_bridge_port *p)\r\n{\r\nunsigned char buf[4];\r\nif (p->br->stp_enabled != BR_KERNEL_STP)\r\nreturn;\r\nbuf[0] = 0;\r\nbuf[1] = 0;\r\nbuf[2] = 0;\r\nbuf[3] = BPDU_TYPE_TCN;\r\nbr_send_bpdu(p, buf, 4);\r\n}\r\nvoid br_stp_rcv(const struct stp_proto *proto, struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nstruct net_bridge_port *p;\r\nstruct net_bridge *br;\r\nconst unsigned char *buf;\r\nif (!pskb_may_pull(skb, 4))\r\ngoto err;\r\nbuf = skb->data;\r\nif (buf[0] != 0 || buf[1] != 0 || buf[2] != 0)\r\ngoto err;\r\np = br_port_get_check_rcu(dev);\r\nif (!p)\r\ngoto err;\r\nbr = p->br;\r\nspin_lock(&br->lock);\r\nif (br->stp_enabled != BR_KERNEL_STP)\r\ngoto out;\r\nif (!(br->dev->flags & IFF_UP))\r\ngoto out;\r\nif (p->state == BR_STATE_DISABLED)\r\ngoto out;\r\nif (!ether_addr_equal(dest, br->group_addr))\r\ngoto out;\r\nif (p->flags & BR_BPDU_GUARD) {\r\nbr_notice(br, "BPDU received on blocked port %u(%s)\n",\r\n(unsigned int) p->port_no, p->dev->name);\r\nbr_stp_disable_port(p);\r\ngoto out;\r\n}\r\nbuf = skb_pull(skb, 3);\r\nif (buf[0] == BPDU_TYPE_CONFIG) {\r\nstruct br_config_bpdu bpdu;\r\nif (!pskb_may_pull(skb, 32))\r\ngoto out;\r\nbuf = skb->data;\r\nbpdu.topology_change = (buf[1] & 0x01) ? 1 : 0;\r\nbpdu.topology_change_ack = (buf[1] & 0x80) ? 1 : 0;\r\nbpdu.root.prio[0] = buf[2];\r\nbpdu.root.prio[1] = buf[3];\r\nbpdu.root.addr[0] = buf[4];\r\nbpdu.root.addr[1] = buf[5];\r\nbpdu.root.addr[2] = buf[6];\r\nbpdu.root.addr[3] = buf[7];\r\nbpdu.root.addr[4] = buf[8];\r\nbpdu.root.addr[5] = buf[9];\r\nbpdu.root_path_cost =\r\n(buf[10] << 24) |\r\n(buf[11] << 16) |\r\n(buf[12] << 8) |\r\nbuf[13];\r\nbpdu.bridge_id.prio[0] = buf[14];\r\nbpdu.bridge_id.prio[1] = buf[15];\r\nbpdu.bridge_id.addr[0] = buf[16];\r\nbpdu.bridge_id.addr[1] = buf[17];\r\nbpdu.bridge_id.addr[2] = buf[18];\r\nbpdu.bridge_id.addr[3] = buf[19];\r\nbpdu.bridge_id.addr[4] = buf[20];\r\nbpdu.bridge_id.addr[5] = buf[21];\r\nbpdu.port_id = (buf[22] << 8) | buf[23];\r\nbpdu.message_age = br_get_ticks(buf+24);\r\nbpdu.max_age = br_get_ticks(buf+26);\r\nbpdu.hello_time = br_get_ticks(buf+28);\r\nbpdu.forward_delay = br_get_ticks(buf+30);\r\nif (bpdu.message_age > bpdu.max_age) {\r\nif (net_ratelimit())\r\nbr_notice(p->br,\r\n"port %u config from %pM"\r\n" (message_age %ul > max_age %ul)\n",\r\np->port_no,\r\neth_hdr(skb)->h_source,\r\nbpdu.message_age, bpdu.max_age);\r\ngoto out;\r\n}\r\nbr_received_config_bpdu(p, &bpdu);\r\n} else if (buf[0] == BPDU_TYPE_TCN) {\r\nbr_received_tcn_bpdu(p);\r\n}\r\nout:\r\nspin_unlock(&br->lock);\r\nerr:\r\nkfree_skb(skb);\r\n}
