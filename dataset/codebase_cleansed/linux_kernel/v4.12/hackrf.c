static int hackrf_ctrl_msg(struct hackrf_dev *dev, u8 request, u16 value,\r\nu16 index, u8 *data, u16 size)\r\n{\r\nint ret;\r\nunsigned int pipe;\r\nu8 requesttype;\r\nswitch (request) {\r\ncase CMD_SET_TRANSCEIVER_MODE:\r\ncase CMD_SET_FREQ:\r\ncase CMD_AMP_ENABLE:\r\ncase CMD_SAMPLE_RATE_SET:\r\ncase CMD_BASEBAND_FILTER_BANDWIDTH_SET:\r\npipe = usb_sndctrlpipe(dev->udev, 0);\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_OUT);\r\nbreak;\r\ncase CMD_BOARD_ID_READ:\r\ncase CMD_VERSION_STRING_READ:\r\ncase CMD_SET_LNA_GAIN:\r\ncase CMD_SET_VGA_GAIN:\r\ncase CMD_SET_TXVGA_GAIN:\r\npipe = usb_rcvctrlpipe(dev->udev, 0);\r\nrequesttype = (USB_TYPE_VENDOR | USB_DIR_IN);\r\nbreak;\r\ndefault:\r\ndev_err(dev->dev, "Unknown command %02x\n", request);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (!(requesttype & USB_DIR_IN))\r\nmemcpy(dev->buf, data, size);\r\nret = usb_control_msg(dev->udev, pipe, request, requesttype, value,\r\nindex, dev->buf, size, 1000);\r\nhackrf_dbg_usb_control_msg(dev->dev, request, requesttype, value,\r\nindex, dev->buf, size);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "usb_control_msg() failed %d request %02x\n",\r\nret, request);\r\ngoto err;\r\n}\r\nif (requesttype & USB_DIR_IN)\r\nmemcpy(data, dev->buf, size);\r\nreturn 0;\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int hackrf_set_params(struct hackrf_dev *dev)\r\n{\r\nstruct usb_interface *intf = dev->intf;\r\nint ret, i;\r\nu8 buf[8], u8tmp;\r\nunsigned int uitmp, uitmp1, uitmp2;\r\nconst bool rx = test_bit(RX_ON, &dev->flags);\r\nconst bool tx = test_bit(TX_ON, &dev->flags);\r\nstatic const struct {\r\nu32 freq;\r\n} bandwidth_lut[] = {\r\n{ 1750000},\r\n{ 2500000},\r\n{ 3500000},\r\n{ 5000000},\r\n{ 5500000},\r\n{ 6000000},\r\n{ 7000000},\r\n{ 8000000},\r\n{ 9000000},\r\n{10000000},\r\n{12000000},\r\n{14000000},\r\n{15000000},\r\n{20000000},\r\n{24000000},\r\n{28000000},\r\n};\r\nif (!rx && !tx) {\r\ndev_dbg(&intf->dev, "device is sleeping\n");\r\nreturn 0;\r\n}\r\nif (rx && test_and_clear_bit(RX_ADC_FREQUENCY, &dev->flags)) {\r\ndev_dbg(&intf->dev, "RX ADC frequency=%u Hz\n", dev->f_adc);\r\nuitmp1 = dev->f_adc;\r\nuitmp2 = 1;\r\nset_bit(TX_DAC_FREQUENCY, &dev->flags);\r\n} else if (tx && test_and_clear_bit(TX_DAC_FREQUENCY, &dev->flags)) {\r\ndev_dbg(&intf->dev, "TX DAC frequency=%u Hz\n", dev->f_dac);\r\nuitmp1 = dev->f_dac;\r\nuitmp2 = 1;\r\nset_bit(RX_ADC_FREQUENCY, &dev->flags);\r\n} else {\r\nuitmp1 = uitmp2 = 0;\r\n}\r\nif (uitmp1 || uitmp2) {\r\nbuf[0] = (uitmp1 >> 0) & 0xff;\r\nbuf[1] = (uitmp1 >> 8) & 0xff;\r\nbuf[2] = (uitmp1 >> 16) & 0xff;\r\nbuf[3] = (uitmp1 >> 24) & 0xff;\r\nbuf[4] = (uitmp2 >> 0) & 0xff;\r\nbuf[5] = (uitmp2 >> 8) & 0xff;\r\nbuf[6] = (uitmp2 >> 16) & 0xff;\r\nbuf[7] = (uitmp2 >> 24) & 0xff;\r\nret = hackrf_ctrl_msg(dev, CMD_SAMPLE_RATE_SET, 0, 0, buf, 8);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (rx && test_and_clear_bit(RX_BANDWIDTH, &dev->flags)) {\r\nif (dev->rx_bandwidth_auto->val == true)\r\nuitmp = dev->f_adc;\r\nelse\r\nuitmp = dev->rx_bandwidth->val;\r\nfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\r\nif (uitmp <= bandwidth_lut[i].freq) {\r\nuitmp = bandwidth_lut[i].freq;\r\nbreak;\r\n}\r\n}\r\ndev->rx_bandwidth->val = uitmp;\r\ndev->rx_bandwidth->cur.val = uitmp;\r\ndev_dbg(&intf->dev, "RX bandwidth selected=%u\n", uitmp);\r\nset_bit(TX_BANDWIDTH, &dev->flags);\r\n} else if (tx && test_and_clear_bit(TX_BANDWIDTH, &dev->flags)) {\r\nif (dev->tx_bandwidth_auto->val == true)\r\nuitmp = dev->f_dac;\r\nelse\r\nuitmp = dev->tx_bandwidth->val;\r\nfor (i = 0; i < ARRAY_SIZE(bandwidth_lut); i++) {\r\nif (uitmp <= bandwidth_lut[i].freq) {\r\nuitmp = bandwidth_lut[i].freq;\r\nbreak;\r\n}\r\n}\r\ndev->tx_bandwidth->val = uitmp;\r\ndev->tx_bandwidth->cur.val = uitmp;\r\ndev_dbg(&intf->dev, "TX bandwidth selected=%u\n", uitmp);\r\nset_bit(RX_BANDWIDTH, &dev->flags);\r\n} else {\r\nuitmp = 0;\r\n}\r\nif (uitmp) {\r\nuitmp1 = uitmp2 = 0;\r\nuitmp1 |= ((uitmp >> 0) & 0xff) << 0;\r\nuitmp1 |= ((uitmp >> 8) & 0xff) << 8;\r\nuitmp2 |= ((uitmp >> 16) & 0xff) << 0;\r\nuitmp2 |= ((uitmp >> 24) & 0xff) << 8;\r\nret = hackrf_ctrl_msg(dev, CMD_BASEBAND_FILTER_BANDWIDTH_SET,\r\nuitmp1, uitmp2, NULL, 0);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (rx && test_and_clear_bit(RX_RF_FREQUENCY, &dev->flags)) {\r\ndev_dbg(&intf->dev, "RX RF frequency=%u Hz\n", dev->f_rx);\r\nuitmp1 = dev->f_rx / 1000000;\r\nuitmp2 = dev->f_rx % 1000000;\r\nset_bit(TX_RF_FREQUENCY, &dev->flags);\r\n} else if (tx && test_and_clear_bit(TX_RF_FREQUENCY, &dev->flags)) {\r\ndev_dbg(&intf->dev, "TX RF frequency=%u Hz\n", dev->f_tx);\r\nuitmp1 = dev->f_tx / 1000000;\r\nuitmp2 = dev->f_tx % 1000000;\r\nset_bit(RX_RF_FREQUENCY, &dev->flags);\r\n} else {\r\nuitmp1 = uitmp2 = 0;\r\n}\r\nif (uitmp1 || uitmp2) {\r\nbuf[0] = (uitmp1 >> 0) & 0xff;\r\nbuf[1] = (uitmp1 >> 8) & 0xff;\r\nbuf[2] = (uitmp1 >> 16) & 0xff;\r\nbuf[3] = (uitmp1 >> 24) & 0xff;\r\nbuf[4] = (uitmp2 >> 0) & 0xff;\r\nbuf[5] = (uitmp2 >> 8) & 0xff;\r\nbuf[6] = (uitmp2 >> 16) & 0xff;\r\nbuf[7] = (uitmp2 >> 24) & 0xff;\r\nret = hackrf_ctrl_msg(dev, CMD_SET_FREQ, 0, 0, buf, 8);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (rx && test_and_clear_bit(RX_RF_GAIN, &dev->flags)) {\r\ndev_dbg(&intf->dev, "RX RF gain val=%d->%d\n",\r\ndev->rx_rf_gain->cur.val, dev->rx_rf_gain->val);\r\nu8tmp = (dev->rx_rf_gain->val) ? 1 : 0;\r\nret = hackrf_ctrl_msg(dev, CMD_AMP_ENABLE, u8tmp, 0, NULL, 0);\r\nif (ret)\r\ngoto err;\r\nset_bit(TX_RF_GAIN, &dev->flags);\r\n}\r\nif (tx && test_and_clear_bit(TX_RF_GAIN, &dev->flags)) {\r\ndev_dbg(&intf->dev, "TX RF gain val=%d->%d\n",\r\ndev->tx_rf_gain->cur.val, dev->tx_rf_gain->val);\r\nu8tmp = (dev->tx_rf_gain->val) ? 1 : 0;\r\nret = hackrf_ctrl_msg(dev, CMD_AMP_ENABLE, u8tmp, 0, NULL, 0);\r\nif (ret)\r\ngoto err;\r\nset_bit(RX_RF_GAIN, &dev->flags);\r\n}\r\nif (rx && test_and_clear_bit(RX_LNA_GAIN, &dev->flags)) {\r\ndev_dbg(dev->dev, "RX LNA gain val=%d->%d\n",\r\ndev->rx_lna_gain->cur.val, dev->rx_lna_gain->val);\r\nret = hackrf_ctrl_msg(dev, CMD_SET_LNA_GAIN, 0,\r\ndev->rx_lna_gain->val, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (rx && test_and_clear_bit(RX_IF_GAIN, &dev->flags)) {\r\ndev_dbg(&intf->dev, "IF gain val=%d->%d\n",\r\ndev->rx_if_gain->cur.val, dev->rx_if_gain->val);\r\nret = hackrf_ctrl_msg(dev, CMD_SET_VGA_GAIN, 0,\r\ndev->rx_if_gain->val, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (tx && test_and_clear_bit(TX_LNA_GAIN, &dev->flags)) {\r\ndev_dbg(&intf->dev, "TX LNA gain val=%d->%d\n",\r\ndev->tx_lna_gain->cur.val, dev->tx_lna_gain->val);\r\nret = hackrf_ctrl_msg(dev, CMD_SET_TXVGA_GAIN, 0,\r\ndev->tx_lna_gain->val, &u8tmp, 1);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic struct hackrf_buffer *hackrf_get_next_buffer(struct hackrf_dev *dev,\r\nstruct list_head *buffer_list)\r\n{\r\nunsigned long flags;\r\nstruct hackrf_buffer *buffer = NULL;\r\nspin_lock_irqsave(&dev->buffer_list_lock, flags);\r\nif (list_empty(buffer_list))\r\ngoto leave;\r\nbuffer = list_entry(buffer_list->next, struct hackrf_buffer, list);\r\nlist_del(&buffer->list);\r\nleave:\r\nspin_unlock_irqrestore(&dev->buffer_list_lock, flags);\r\nreturn buffer;\r\n}\r\nstatic void hackrf_copy_stream(struct hackrf_dev *dev, void *dst, void *src,\r\nunsigned int src_len)\r\n{\r\nmemcpy(dst, src, src_len);\r\nif (unlikely(time_is_before_jiffies(dev->jiffies_next))) {\r\n#define MSECS 10000UL\r\nunsigned int msecs = jiffies_to_msecs(jiffies -\r\ndev->jiffies_next + msecs_to_jiffies(MSECS));\r\nunsigned int samples = dev->sample - dev->sample_measured;\r\ndev->jiffies_next = jiffies + msecs_to_jiffies(MSECS);\r\ndev->sample_measured = dev->sample;\r\ndev_dbg(dev->dev, "slen=%u samples=%u msecs=%u sample rate=%lu\n",\r\nsrc_len, samples, msecs,\r\nsamples * 1000UL / msecs);\r\n}\r\ndev->sample += src_len / 2;\r\n}\r\nstatic void hackrf_urb_complete_in(struct urb *urb)\r\n{\r\nstruct hackrf_dev *dev = urb->context;\r\nstruct usb_interface *intf = dev->intf;\r\nstruct hackrf_buffer *buffer;\r\nunsigned int len;\r\ndev_dbg_ratelimited(&intf->dev, "status=%d length=%u/%u\n", urb->status,\r\nurb->actual_length, urb->transfer_buffer_length);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_err_ratelimited(&intf->dev, "URB failed %d\n", urb->status);\r\ngoto exit_usb_submit_urb;\r\n}\r\nbuffer = hackrf_get_next_buffer(dev, &dev->rx_buffer_list);\r\nif (unlikely(buffer == NULL)) {\r\ndev->vb_full++;\r\ndev_notice_ratelimited(&intf->dev,\r\n"buffer is full - %u packets dropped\n",\r\ndev->vb_full);\r\ngoto exit_usb_submit_urb;\r\n}\r\nlen = min_t(unsigned long, vb2_plane_size(&buffer->vb.vb2_buf, 0),\r\nurb->actual_length);\r\nhackrf_copy_stream(dev, vb2_plane_vaddr(&buffer->vb.vb2_buf, 0),\r\nurb->transfer_buffer, len);\r\nvb2_set_plane_payload(&buffer->vb.vb2_buf, 0, len);\r\nbuffer->vb.sequence = dev->sequence++;\r\nbuffer->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_buffer_done(&buffer->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\nexit_usb_submit_urb:\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic void hackrf_urb_complete_out(struct urb *urb)\r\n{\r\nstruct hackrf_dev *dev = urb->context;\r\nstruct usb_interface *intf = dev->intf;\r\nstruct hackrf_buffer *buffer;\r\nunsigned int len;\r\ndev_dbg_ratelimited(&intf->dev, "status=%d length=%u/%u\n", urb->status,\r\nurb->actual_length, urb->transfer_buffer_length);\r\nswitch (urb->status) {\r\ncase 0:\r\ncase -ETIMEDOUT:\r\nbreak;\r\ncase -ECONNRESET:\r\ncase -ENOENT:\r\ncase -ESHUTDOWN:\r\nreturn;\r\ndefault:\r\ndev_err_ratelimited(&intf->dev, "URB failed %d\n", urb->status);\r\n}\r\nbuffer = hackrf_get_next_buffer(dev, &dev->tx_buffer_list);\r\nif (unlikely(buffer == NULL)) {\r\ndev->vb_empty++;\r\ndev_notice_ratelimited(&intf->dev,\r\n"buffer is empty - %u packets dropped\n",\r\ndev->vb_empty);\r\nurb->actual_length = 0;\r\ngoto exit_usb_submit_urb;\r\n}\r\nlen = min_t(unsigned long, urb->transfer_buffer_length,\r\nvb2_get_plane_payload(&buffer->vb.vb2_buf, 0));\r\nhackrf_copy_stream(dev, urb->transfer_buffer,\r\nvb2_plane_vaddr(&buffer->vb.vb2_buf, 0), len);\r\nurb->actual_length = len;\r\nbuffer->vb.sequence = dev->sequence++;\r\nbuffer->vb.vb2_buf.timestamp = ktime_get_ns();\r\nvb2_buffer_done(&buffer->vb.vb2_buf, VB2_BUF_STATE_DONE);\r\nexit_usb_submit_urb:\r\nusb_submit_urb(urb, GFP_ATOMIC);\r\n}\r\nstatic int hackrf_kill_urbs(struct hackrf_dev *dev)\r\n{\r\nint i;\r\nfor (i = dev->urbs_submitted - 1; i >= 0; i--) {\r\ndev_dbg(dev->dev, "kill urb=%d\n", i);\r\nusb_kill_urb(dev->urb_list[i]);\r\n}\r\ndev->urbs_submitted = 0;\r\nreturn 0;\r\n}\r\nstatic int hackrf_submit_urbs(struct hackrf_dev *dev)\r\n{\r\nint i, ret;\r\nfor (i = 0; i < dev->urbs_initialized; i++) {\r\ndev_dbg(dev->dev, "submit urb=%d\n", i);\r\nret = usb_submit_urb(dev->urb_list[i], GFP_ATOMIC);\r\nif (ret) {\r\ndev_err(dev->dev, "Could not submit URB no. %d - get them all back\n",\r\ni);\r\nhackrf_kill_urbs(dev);\r\nreturn ret;\r\n}\r\ndev->urbs_submitted++;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hackrf_free_stream_bufs(struct hackrf_dev *dev)\r\n{\r\nif (dev->flags & USB_STATE_URB_BUF) {\r\nwhile (dev->buf_num) {\r\ndev->buf_num--;\r\ndev_dbg(dev->dev, "free buf=%d\n", dev->buf_num);\r\nusb_free_coherent(dev->udev, dev->buf_size,\r\ndev->buf_list[dev->buf_num],\r\ndev->dma_addr[dev->buf_num]);\r\n}\r\n}\r\ndev->flags &= ~USB_STATE_URB_BUF;\r\nreturn 0;\r\n}\r\nstatic int hackrf_alloc_stream_bufs(struct hackrf_dev *dev)\r\n{\r\ndev->buf_num = 0;\r\ndev->buf_size = BULK_BUFFER_SIZE;\r\ndev_dbg(dev->dev, "all in all I will use %u bytes for streaming\n",\r\nMAX_BULK_BUFS * BULK_BUFFER_SIZE);\r\nfor (dev->buf_num = 0; dev->buf_num < MAX_BULK_BUFS; dev->buf_num++) {\r\ndev->buf_list[dev->buf_num] = usb_alloc_coherent(dev->udev,\r\nBULK_BUFFER_SIZE, GFP_ATOMIC,\r\n&dev->dma_addr[dev->buf_num]);\r\nif (!dev->buf_list[dev->buf_num]) {\r\ndev_dbg(dev->dev, "alloc buf=%d failed\n",\r\ndev->buf_num);\r\nhackrf_free_stream_bufs(dev);\r\nreturn -ENOMEM;\r\n}\r\ndev_dbg(dev->dev, "alloc buf=%d %p (dma %llu)\n", dev->buf_num,\r\ndev->buf_list[dev->buf_num],\r\n(long long)dev->dma_addr[dev->buf_num]);\r\ndev->flags |= USB_STATE_URB_BUF;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hackrf_free_urbs(struct hackrf_dev *dev)\r\n{\r\nint i;\r\nhackrf_kill_urbs(dev);\r\nfor (i = dev->urbs_initialized - 1; i >= 0; i--) {\r\nif (dev->urb_list[i]) {\r\ndev_dbg(dev->dev, "free urb=%d\n", i);\r\nusb_free_urb(dev->urb_list[i]);\r\n}\r\n}\r\ndev->urbs_initialized = 0;\r\nreturn 0;\r\n}\r\nstatic int hackrf_alloc_urbs(struct hackrf_dev *dev, bool rcv)\r\n{\r\nint i, j;\r\nunsigned int pipe;\r\nusb_complete_t complete;\r\nif (rcv) {\r\npipe = usb_rcvbulkpipe(dev->udev, 0x81);\r\ncomplete = &hackrf_urb_complete_in;\r\n} else {\r\npipe = usb_sndbulkpipe(dev->udev, 0x02);\r\ncomplete = &hackrf_urb_complete_out;\r\n}\r\nfor (i = 0; i < MAX_BULK_BUFS; i++) {\r\ndev_dbg(dev->dev, "alloc urb=%d\n", i);\r\ndev->urb_list[i] = usb_alloc_urb(0, GFP_ATOMIC);\r\nif (!dev->urb_list[i]) {\r\nfor (j = 0; j < i; j++)\r\nusb_free_urb(dev->urb_list[j]);\r\nreturn -ENOMEM;\r\n}\r\nusb_fill_bulk_urb(dev->urb_list[i],\r\ndev->udev,\r\npipe,\r\ndev->buf_list[i],\r\nBULK_BUFFER_SIZE,\r\ncomplete, dev);\r\ndev->urb_list[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\r\ndev->urb_list[i]->transfer_dma = dev->dma_addr[i];\r\ndev->urbs_initialized++;\r\n}\r\nreturn 0;\r\n}\r\nstatic void hackrf_disconnect(struct usb_interface *intf)\r\n{\r\nstruct v4l2_device *v = usb_get_intfdata(intf);\r\nstruct hackrf_dev *dev = container_of(v, struct hackrf_dev, v4l2_dev);\r\ndev_dbg(dev->dev, "\n");\r\nmutex_lock(&dev->vb_queue_lock);\r\nmutex_lock(&dev->v4l2_lock);\r\ndev->udev = NULL;\r\nv4l2_device_disconnect(&dev->v4l2_dev);\r\nvideo_unregister_device(&dev->tx_vdev);\r\nvideo_unregister_device(&dev->rx_vdev);\r\nmutex_unlock(&dev->v4l2_lock);\r\nmutex_unlock(&dev->vb_queue_lock);\r\nv4l2_device_put(&dev->v4l2_dev);\r\n}\r\nstatic void hackrf_return_all_buffers(struct vb2_queue *vq,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\r\nstruct usb_interface *intf = dev->intf;\r\nstruct hackrf_buffer *buffer, *node;\r\nstruct list_head *buffer_list;\r\nunsigned long flags;\r\ndev_dbg(&intf->dev, "\n");\r\nif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE)\r\nbuffer_list = &dev->rx_buffer_list;\r\nelse\r\nbuffer_list = &dev->tx_buffer_list;\r\nspin_lock_irqsave(&dev->buffer_list_lock, flags);\r\nlist_for_each_entry_safe(buffer, node, buffer_list, list) {\r\ndev_dbg(&intf->dev, "list_for_each_entry_safe\n");\r\nvb2_buffer_done(&buffer->vb.vb2_buf, state);\r\nlist_del(&buffer->list);\r\n}\r\nspin_unlock_irqrestore(&dev->buffer_list_lock, flags);\r\n}\r\nstatic int hackrf_queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\r\ndev_dbg(dev->dev, "nbuffers=%d\n", *nbuffers);\r\nif (vq->num_buffers + *nbuffers < 8)\r\n*nbuffers = 8 - vq->num_buffers;\r\n*nplanes = 1;\r\nsizes[0] = PAGE_ALIGN(dev->buffersize);\r\ndev_dbg(dev->dev, "nbuffers=%d sizes[0]=%d\n", *nbuffers, sizes[0]);\r\nreturn 0;\r\n}\r\nstatic void hackrf_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct vb2_queue *vq = vb->vb2_queue;\r\nstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\r\nstruct hackrf_buffer *buffer = container_of(vbuf, struct hackrf_buffer, vb);\r\nstruct list_head *buffer_list;\r\nunsigned long flags;\r\ndev_dbg_ratelimited(&dev->intf->dev, "\n");\r\nif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE)\r\nbuffer_list = &dev->rx_buffer_list;\r\nelse\r\nbuffer_list = &dev->tx_buffer_list;\r\nspin_lock_irqsave(&dev->buffer_list_lock, flags);\r\nlist_add_tail(&buffer->list, buffer_list);\r\nspin_unlock_irqrestore(&dev->buffer_list_lock, flags);\r\n}\r\nstatic int hackrf_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\r\nstruct usb_interface *intf = dev->intf;\r\nint ret;\r\nunsigned int mode;\r\ndev_dbg(&intf->dev, "count=%i\n", count);\r\nmutex_lock(&dev->v4l2_lock);\r\nif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE) {\r\nif (test_bit(TX_ON, &dev->flags)) {\r\nret = -EBUSY;\r\ngoto err_hackrf_return_all_buffers;\r\n}\r\nmode = 1;\r\nset_bit(RX_ON, &dev->flags);\r\n} else {\r\nif (test_bit(RX_ON, &dev->flags)) {\r\nret = -EBUSY;\r\ngoto err_hackrf_return_all_buffers;\r\n}\r\nmode = 2;\r\nset_bit(TX_ON, &dev->flags);\r\n}\r\ndev->sequence = 0;\r\nret = hackrf_alloc_stream_bufs(dev);\r\nif (ret)\r\ngoto err;\r\nret = hackrf_alloc_urbs(dev, (mode == 1));\r\nif (ret)\r\ngoto err;\r\nret = hackrf_submit_urbs(dev);\r\nif (ret)\r\ngoto err;\r\nret = hackrf_set_params(dev);\r\nif (ret)\r\ngoto err;\r\nret = hackrf_ctrl_msg(dev, CMD_SET_TRANSCEIVER_MODE, mode, 0, NULL, 0);\r\nif (ret)\r\ngoto err;\r\nmutex_unlock(&dev->v4l2_lock);\r\nreturn 0;\r\nerr:\r\nhackrf_kill_urbs(dev);\r\nhackrf_free_urbs(dev);\r\nhackrf_free_stream_bufs(dev);\r\nclear_bit(RX_ON, &dev->flags);\r\nclear_bit(TX_ON, &dev->flags);\r\nerr_hackrf_return_all_buffers:\r\nhackrf_return_all_buffers(vq, VB2_BUF_STATE_QUEUED);\r\nmutex_unlock(&dev->v4l2_lock);\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void hackrf_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct hackrf_dev *dev = vb2_get_drv_priv(vq);\r\nstruct usb_interface *intf = dev->intf;\r\ndev_dbg(&intf->dev, "\n");\r\nmutex_lock(&dev->v4l2_lock);\r\nhackrf_ctrl_msg(dev, CMD_SET_TRANSCEIVER_MODE, 0, 0, NULL, 0);\r\nhackrf_kill_urbs(dev);\r\nhackrf_free_urbs(dev);\r\nhackrf_free_stream_bufs(dev);\r\nhackrf_return_all_buffers(vq, VB2_BUF_STATE_ERROR);\r\nif (vq->type == V4L2_BUF_TYPE_SDR_CAPTURE)\r\nclear_bit(RX_ON, &dev->flags);\r\nelse\r\nclear_bit(TX_ON, &dev->flags);\r\nmutex_unlock(&dev->v4l2_lock);\r\n}\r\nstatic int hackrf_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nstruct usb_interface *intf = dev->intf;\r\nstruct video_device *vdev = video_devdata(file);\r\ndev_dbg(&intf->dev, "\n");\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\ncap->device_caps = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER |\r\nV4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\nelse\r\ncap->device_caps = V4L2_CAP_SDR_OUTPUT | V4L2_CAP_MODULATOR |\r\nV4L2_CAP_STREAMING | V4L2_CAP_READWRITE;\r\ncap->capabilities = V4L2_CAP_SDR_CAPTURE | V4L2_CAP_TUNER |\r\nV4L2_CAP_SDR_OUTPUT | V4L2_CAP_MODULATOR |\r\nV4L2_CAP_STREAMING | V4L2_CAP_READWRITE |\r\nV4L2_CAP_DEVICE_CAPS;\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, dev->rx_vdev.name, sizeof(cap->card));\r\nusb_make_path(dev->udev, cap->bus_info, sizeof(cap->bus_info));\r\nreturn 0;\r\n}\r\nstatic int hackrf_s_fmt_sdr(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nstruct video_device *vdev = video_devdata(file);\r\nstruct vb2_queue *q;\r\nint i;\r\ndev_dbg(dev->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&f->fmt.sdr.pixelformat);\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nq = &dev->rx_vb2_queue;\r\nelse\r\nq = &dev->tx_vb2_queue;\r\nif (vb2_is_busy(q))\r\nreturn -EBUSY;\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (f->fmt.sdr.pixelformat == formats[i].pixelformat) {\r\ndev->pixelformat = formats[i].pixelformat;\r\ndev->buffersize = formats[i].buffersize;\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\ndev->pixelformat = formats[0].pixelformat;\r\ndev->buffersize = formats[0].buffersize;\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int hackrf_g_fmt_sdr(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\ndev_dbg(dev->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&dev->pixelformat);\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nf->fmt.sdr.pixelformat = dev->pixelformat;\r\nf->fmt.sdr.buffersize = dev->buffersize;\r\nreturn 0;\r\n}\r\nstatic int hackrf_try_fmt_sdr(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nint i;\r\ndev_dbg(dev->dev, "pixelformat fourcc %4.4s\n",\r\n(char *)&f->fmt.sdr.pixelformat);\r\nmemset(f->fmt.sdr.reserved, 0, sizeof(f->fmt.sdr.reserved));\r\nfor (i = 0; i < NUM_FORMATS; i++) {\r\nif (formats[i].pixelformat == f->fmt.sdr.pixelformat) {\r\nf->fmt.sdr.buffersize = formats[i].buffersize;\r\nreturn 0;\r\n}\r\n}\r\nf->fmt.sdr.pixelformat = formats[0].pixelformat;\r\nf->fmt.sdr.buffersize = formats[0].buffersize;\r\nreturn 0;\r\n}\r\nstatic int hackrf_enum_fmt_sdr(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\ndev_dbg(dev->dev, "index=%d\n", f->index);\r\nif (f->index >= NUM_FORMATS)\r\nreturn -EINVAL;\r\nf->pixelformat = formats[f->index].pixelformat;\r\nreturn 0;\r\n}\r\nstatic int hackrf_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nint ret;\r\ndev_dbg(dev->dev, "index=%d\n", v->index);\r\nif (v->index == 0)\r\nret = 0;\r\nelse if (v->index == 1)\r\nret = 0;\r\nelse\r\nret = -EINVAL;\r\nreturn ret;\r\n}\r\nstatic int hackrf_g_tuner(struct file *file, void *priv, struct v4l2_tuner *v)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nint ret;\r\ndev_dbg(dev->dev, "index=%d\n", v->index);\r\nif (v->index == 0) {\r\nstrlcpy(v->name, "HackRF ADC", sizeof(v->name));\r\nv->type = V4L2_TUNER_SDR;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = bands_adc_dac[0].rangelow;\r\nv->rangehigh = bands_adc_dac[0].rangehigh;\r\nret = 0;\r\n} else if (v->index == 1) {\r\nstrlcpy(v->name, "HackRF RF", sizeof(v->name));\r\nv->type = V4L2_TUNER_RF;\r\nv->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\nv->rangelow = bands_rx_tx[0].rangelow;\r\nv->rangehigh = bands_rx_tx[0].rangehigh;\r\nret = 0;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hackrf_s_modulator(struct file *file, void *fh,\r\nconst struct v4l2_modulator *a)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\ndev_dbg(dev->dev, "index=%d\n", a->index);\r\nreturn a->index > 1 ? -EINVAL : 0;\r\n}\r\nstatic int hackrf_g_modulator(struct file *file, void *fh,\r\nstruct v4l2_modulator *a)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nint ret;\r\ndev_dbg(dev->dev, "index=%d\n", a->index);\r\nif (a->index == 0) {\r\nstrlcpy(a->name, "HackRF DAC", sizeof(a->name));\r\na->type = V4L2_TUNER_SDR;\r\na->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\na->rangelow = bands_adc_dac[0].rangelow;\r\na->rangehigh = bands_adc_dac[0].rangehigh;\r\nret = 0;\r\n} else if (a->index == 1) {\r\nstrlcpy(a->name, "HackRF RF", sizeof(a->name));\r\na->type = V4L2_TUNER_RF;\r\na->capability = V4L2_TUNER_CAP_1HZ | V4L2_TUNER_CAP_FREQ_BANDS;\r\na->rangelow = bands_rx_tx[0].rangelow;\r\na->rangehigh = bands_rx_tx[0].rangehigh;\r\nret = 0;\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int hackrf_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nstruct usb_interface *intf = dev->intf;\r\nstruct video_device *vdev = video_devdata(file);\r\nint ret;\r\nunsigned int uitmp;\r\ndev_dbg(&intf->dev, "tuner=%d type=%d frequency=%u\n",\r\nf->tuner, f->type, f->frequency);\r\nif (f->tuner == 0) {\r\nuitmp = clamp(f->frequency, bands_adc_dac[0].rangelow,\r\nbands_adc_dac[0].rangehigh);\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\ndev->f_adc = uitmp;\r\nset_bit(RX_ADC_FREQUENCY, &dev->flags);\r\n} else {\r\ndev->f_dac = uitmp;\r\nset_bit(TX_DAC_FREQUENCY, &dev->flags);\r\n}\r\n} else if (f->tuner == 1) {\r\nuitmp = clamp(f->frequency, bands_rx_tx[0].rangelow,\r\nbands_rx_tx[0].rangehigh);\r\nif (vdev->vfl_dir == VFL_DIR_RX) {\r\ndev->f_rx = uitmp;\r\nset_bit(RX_RF_FREQUENCY, &dev->flags);\r\n} else {\r\ndev->f_tx = uitmp;\r\nset_bit(TX_RF_FREQUENCY, &dev->flags);\r\n}\r\n} else {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = hackrf_set_params(dev);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int hackrf_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nstruct usb_interface *intf = dev->intf;\r\nstruct video_device *vdev = video_devdata(file);\r\nint ret;\r\ndev_dbg(dev->dev, "tuner=%d type=%d\n", f->tuner, f->type);\r\nif (f->tuner == 0) {\r\nf->type = V4L2_TUNER_SDR;\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nf->frequency = dev->f_adc;\r\nelse\r\nf->frequency = dev->f_dac;\r\n} else if (f->tuner == 1) {\r\nf->type = V4L2_TUNER_RF;\r\nif (vdev->vfl_dir == VFL_DIR_RX)\r\nf->frequency = dev->f_rx;\r\nelse\r\nf->frequency = dev->f_tx;\r\n} else {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int hackrf_enum_freq_bands(struct file *file, void *priv,\r\nstruct v4l2_frequency_band *band)\r\n{\r\nstruct hackrf_dev *dev = video_drvdata(file);\r\nint ret;\r\ndev_dbg(dev->dev, "tuner=%d type=%d index=%d\n",\r\nband->tuner, band->type, band->index);\r\nif (band->tuner == 0) {\r\nif (band->index >= ARRAY_SIZE(bands_adc_dac)) {\r\nret = -EINVAL;\r\n} else {\r\n*band = bands_adc_dac[band->index];\r\nret = 0;\r\n}\r\n} else if (band->tuner == 1) {\r\nif (band->index >= ARRAY_SIZE(bands_rx_tx)) {\r\nret = -EINVAL;\r\n} else {\r\n*band = bands_rx_tx[band->index];\r\nret = 0;\r\n}\r\n} else {\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void hackrf_video_release(struct v4l2_device *v)\r\n{\r\nstruct hackrf_dev *dev = container_of(v, struct hackrf_dev, v4l2_dev);\r\ndev_dbg(dev->dev, "\n");\r\nv4l2_ctrl_handler_free(&dev->rx_ctrl_handler);\r\nv4l2_ctrl_handler_free(&dev->tx_ctrl_handler);\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nkfree(dev);\r\n}\r\nstatic int hackrf_s_ctrl_rx(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct hackrf_dev *dev = container_of(ctrl->handler,\r\nstruct hackrf_dev, rx_ctrl_handler);\r\nstruct usb_interface *intf = dev->intf;\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\nset_bit(RX_BANDWIDTH, &dev->flags);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_RF_GAIN:\r\nset_bit(RX_RF_GAIN, &dev->flags);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nset_bit(RX_LNA_GAIN, &dev->flags);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_IF_GAIN:\r\nset_bit(RX_IF_GAIN, &dev->flags);\r\nbreak;\r\ndefault:\r\ndev_dbg(&intf->dev, "unknown ctrl: id=%d name=%s\n",\r\nctrl->id, ctrl->name);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = hackrf_set_params(dev);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int hackrf_s_ctrl_tx(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct hackrf_dev *dev = container_of(ctrl->handler,\r\nstruct hackrf_dev, tx_ctrl_handler);\r\nstruct usb_interface *intf = dev->intf;\r\nint ret;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH_AUTO:\r\ncase V4L2_CID_RF_TUNER_BANDWIDTH:\r\nset_bit(TX_BANDWIDTH, &dev->flags);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_LNA_GAIN:\r\nset_bit(TX_LNA_GAIN, &dev->flags);\r\nbreak;\r\ncase V4L2_CID_RF_TUNER_RF_GAIN:\r\nset_bit(TX_RF_GAIN, &dev->flags);\r\nbreak;\r\ndefault:\r\ndev_dbg(&intf->dev, "unknown ctrl: id=%d name=%s\n",\r\nctrl->id, ctrl->name);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = hackrf_set_params(dev);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int hackrf_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct hackrf_dev *dev;\r\nint ret;\r\nu8 u8tmp, buf[BUF_SIZE];\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nmutex_init(&dev->v4l2_lock);\r\nmutex_init(&dev->vb_queue_lock);\r\nspin_lock_init(&dev->buffer_list_lock);\r\nINIT_LIST_HEAD(&dev->rx_buffer_list);\r\nINIT_LIST_HEAD(&dev->tx_buffer_list);\r\ndev->intf = intf;\r\ndev->dev = &intf->dev;\r\ndev->udev = interface_to_usbdev(intf);\r\ndev->pixelformat = formats[0].pixelformat;\r\ndev->buffersize = formats[0].buffersize;\r\ndev->f_adc = bands_adc_dac[0].rangelow;\r\ndev->f_dac = bands_adc_dac[0].rangelow;\r\ndev->f_rx = bands_rx_tx[0].rangelow;\r\ndev->f_tx = bands_rx_tx[0].rangelow;\r\nset_bit(RX_ADC_FREQUENCY, &dev->flags);\r\nset_bit(TX_DAC_FREQUENCY, &dev->flags);\r\nset_bit(RX_RF_FREQUENCY, &dev->flags);\r\nset_bit(TX_RF_FREQUENCY, &dev->flags);\r\nret = hackrf_ctrl_msg(dev, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\r\nif (ret == 0)\r\nret = hackrf_ctrl_msg(dev, CMD_VERSION_STRING_READ, 0, 0,\r\nbuf, BUF_SIZE);\r\nif (ret) {\r\ndev_err(dev->dev, "Could not detect board\n");\r\ngoto err_kfree;\r\n}\r\nbuf[BUF_SIZE - 1] = '\0';\r\ndev_info(dev->dev, "Board ID: %02x\n", u8tmp);\r\ndev_info(dev->dev, "Firmware version: %s\n", buf);\r\ndev->rx_vb2_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\r\ndev->rx_vb2_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF |\r\nVB2_READ;\r\ndev->rx_vb2_queue.ops = &hackrf_vb2_ops;\r\ndev->rx_vb2_queue.mem_ops = &vb2_vmalloc_memops;\r\ndev->rx_vb2_queue.drv_priv = dev;\r\ndev->rx_vb2_queue.buf_struct_size = sizeof(struct hackrf_buffer);\r\ndev->rx_vb2_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&dev->rx_vb2_queue);\r\nif (ret) {\r\ndev_err(dev->dev, "Could not initialize rx vb2 queue\n");\r\ngoto err_kfree;\r\n}\r\ndev->tx_vb2_queue.type = V4L2_BUF_TYPE_SDR_OUTPUT;\r\ndev->tx_vb2_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF |\r\nVB2_WRITE;\r\ndev->tx_vb2_queue.ops = &hackrf_vb2_ops;\r\ndev->tx_vb2_queue.mem_ops = &vb2_vmalloc_memops;\r\ndev->tx_vb2_queue.drv_priv = dev;\r\ndev->tx_vb2_queue.buf_struct_size = sizeof(struct hackrf_buffer);\r\ndev->tx_vb2_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nret = vb2_queue_init(&dev->tx_vb2_queue);\r\nif (ret) {\r\ndev_err(dev->dev, "Could not initialize tx vb2 queue\n");\r\ngoto err_kfree;\r\n}\r\nv4l2_ctrl_handler_init(&dev->rx_ctrl_handler, 5);\r\ndev->rx_bandwidth_auto = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\r\n&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\r\n0, 1, 0, 1);\r\ndev->rx_bandwidth = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\r\n&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_BANDWIDTH,\r\n1750000, 28000000, 50000, 1750000);\r\nv4l2_ctrl_auto_cluster(2, &dev->rx_bandwidth_auto, 0, false);\r\ndev->rx_rf_gain = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\r\n&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_RF_GAIN, 0, 12, 12, 0);\r\ndev->rx_lna_gain = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\r\n&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_LNA_GAIN, 0, 40, 8, 0);\r\ndev->rx_if_gain = v4l2_ctrl_new_std(&dev->rx_ctrl_handler,\r\n&hackrf_ctrl_ops_rx, V4L2_CID_RF_TUNER_IF_GAIN, 0, 62, 2, 0);\r\nif (dev->rx_ctrl_handler.error) {\r\nret = dev->rx_ctrl_handler.error;\r\ndev_err(dev->dev, "Could not initialize controls\n");\r\ngoto err_v4l2_ctrl_handler_free_rx;\r\n}\r\nv4l2_ctrl_grab(dev->rx_rf_gain, !hackrf_enable_rf_gain_ctrl);\r\nv4l2_ctrl_handler_setup(&dev->rx_ctrl_handler);\r\nv4l2_ctrl_handler_init(&dev->tx_ctrl_handler, 4);\r\ndev->tx_bandwidth_auto = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\r\n&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_BANDWIDTH_AUTO,\r\n0, 1, 0, 1);\r\ndev->tx_bandwidth = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\r\n&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_BANDWIDTH,\r\n1750000, 28000000, 50000, 1750000);\r\nv4l2_ctrl_auto_cluster(2, &dev->tx_bandwidth_auto, 0, false);\r\ndev->tx_lna_gain = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\r\n&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_LNA_GAIN, 0, 47, 1, 0);\r\ndev->tx_rf_gain = v4l2_ctrl_new_std(&dev->tx_ctrl_handler,\r\n&hackrf_ctrl_ops_tx, V4L2_CID_RF_TUNER_RF_GAIN, 0, 15, 15, 0);\r\nif (dev->tx_ctrl_handler.error) {\r\nret = dev->tx_ctrl_handler.error;\r\ndev_err(dev->dev, "Could not initialize controls\n");\r\ngoto err_v4l2_ctrl_handler_free_tx;\r\n}\r\nv4l2_ctrl_grab(dev->tx_rf_gain, !hackrf_enable_rf_gain_ctrl);\r\nv4l2_ctrl_handler_setup(&dev->tx_ctrl_handler);\r\ndev->v4l2_dev.release = hackrf_video_release;\r\nret = v4l2_device_register(&intf->dev, &dev->v4l2_dev);\r\nif (ret) {\r\ndev_err(dev->dev, "Failed to register v4l2-device (%d)\n", ret);\r\ngoto err_v4l2_ctrl_handler_free_tx;\r\n}\r\ndev->rx_vdev = hackrf_template;\r\ndev->rx_vdev.queue = &dev->rx_vb2_queue;\r\ndev->rx_vdev.queue->lock = &dev->vb_queue_lock;\r\ndev->rx_vdev.v4l2_dev = &dev->v4l2_dev;\r\ndev->rx_vdev.ctrl_handler = &dev->rx_ctrl_handler;\r\ndev->rx_vdev.lock = &dev->v4l2_lock;\r\ndev->rx_vdev.vfl_dir = VFL_DIR_RX;\r\nvideo_set_drvdata(&dev->rx_vdev, dev);\r\nret = video_register_device(&dev->rx_vdev, VFL_TYPE_SDR, -1);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"Failed to register as video device (%d)\n", ret);\r\ngoto err_v4l2_device_unregister;\r\n}\r\ndev_info(dev->dev, "Registered as %s\n",\r\nvideo_device_node_name(&dev->rx_vdev));\r\ndev->tx_vdev = hackrf_template;\r\ndev->tx_vdev.queue = &dev->tx_vb2_queue;\r\ndev->tx_vdev.queue->lock = &dev->vb_queue_lock;\r\ndev->tx_vdev.v4l2_dev = &dev->v4l2_dev;\r\ndev->tx_vdev.ctrl_handler = &dev->tx_ctrl_handler;\r\ndev->tx_vdev.lock = &dev->v4l2_lock;\r\ndev->tx_vdev.vfl_dir = VFL_DIR_TX;\r\nvideo_set_drvdata(&dev->tx_vdev, dev);\r\nret = video_register_device(&dev->tx_vdev, VFL_TYPE_SDR, -1);\r\nif (ret) {\r\ndev_err(dev->dev,\r\n"Failed to register as video device (%d)\n", ret);\r\ngoto err_video_unregister_device_rx;\r\n}\r\ndev_info(dev->dev, "Registered as %s\n",\r\nvideo_device_node_name(&dev->tx_vdev));\r\ndev_notice(dev->dev, "SDR API is still slightly experimental and functionality changes may follow\n");\r\nreturn 0;\r\nerr_video_unregister_device_rx:\r\nvideo_unregister_device(&dev->rx_vdev);\r\nerr_v4l2_device_unregister:\r\nv4l2_device_unregister(&dev->v4l2_dev);\r\nerr_v4l2_ctrl_handler_free_tx:\r\nv4l2_ctrl_handler_free(&dev->tx_ctrl_handler);\r\nerr_v4l2_ctrl_handler_free_rx:\r\nv4l2_ctrl_handler_free(&dev->rx_ctrl_handler);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}
