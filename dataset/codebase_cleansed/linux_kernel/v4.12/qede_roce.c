bool qede_roce_supported(struct qede_dev *dev)\r\n{\r\nreturn dev->dev_info.common.rdma_supported;\r\n}\r\nstatic void _qede_roce_dev_add(struct qede_dev *edev)\r\n{\r\nif (!qedr_drv)\r\nreturn;\r\nedev->rdma_info.qedr_dev = qedr_drv->add(edev->cdev, edev->pdev,\r\nedev->ndev);\r\n}\r\nstatic int qede_roce_create_wq(struct qede_dev *edev)\r\n{\r\nINIT_LIST_HEAD(&edev->rdma_info.roce_event_list);\r\nedev->rdma_info.roce_wq = create_singlethread_workqueue("roce_wq");\r\nif (!edev->rdma_info.roce_wq) {\r\nDP_NOTICE(edev, "qedr: Could not create workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void qede_roce_cleanup_event(struct qede_dev *edev)\r\n{\r\nstruct list_head *head = &edev->rdma_info.roce_event_list;\r\nstruct qede_roce_event_work *event_node;\r\nflush_workqueue(edev->rdma_info.roce_wq);\r\nwhile (!list_empty(head)) {\r\nevent_node = list_entry(head->next, struct qede_roce_event_work,\r\nlist);\r\ncancel_work_sync(&event_node->work);\r\nlist_del(&event_node->list);\r\nkfree(event_node);\r\n}\r\n}\r\nstatic void qede_roce_destroy_wq(struct qede_dev *edev)\r\n{\r\nqede_roce_cleanup_event(edev);\r\ndestroy_workqueue(edev->rdma_info.roce_wq);\r\n}\r\nint qede_roce_dev_add(struct qede_dev *edev)\r\n{\r\nint rc = 0;\r\nif (qede_roce_supported(edev)) {\r\nrc = qede_roce_create_wq(edev);\r\nif (rc)\r\nreturn rc;\r\nINIT_LIST_HEAD(&edev->rdma_info.entry);\r\nmutex_lock(&qedr_dev_list_lock);\r\nlist_add_tail(&edev->rdma_info.entry, &qedr_dev_list);\r\n_qede_roce_dev_add(edev);\r\nmutex_unlock(&qedr_dev_list_lock);\r\n}\r\nreturn rc;\r\n}\r\nstatic void _qede_roce_dev_remove(struct qede_dev *edev)\r\n{\r\nif (qedr_drv && qedr_drv->remove && edev->rdma_info.qedr_dev)\r\nqedr_drv->remove(edev->rdma_info.qedr_dev);\r\nedev->rdma_info.qedr_dev = NULL;\r\n}\r\nvoid qede_roce_dev_remove(struct qede_dev *edev)\r\n{\r\nif (!qede_roce_supported(edev))\r\nreturn;\r\nqede_roce_destroy_wq(edev);\r\nmutex_lock(&qedr_dev_list_lock);\r\n_qede_roce_dev_remove(edev);\r\nlist_del(&edev->rdma_info.entry);\r\nmutex_unlock(&qedr_dev_list_lock);\r\n}\r\nstatic void _qede_roce_dev_open(struct qede_dev *edev)\r\n{\r\nif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\r\nqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_UP);\r\n}\r\nstatic void qede_roce_dev_open(struct qede_dev *edev)\r\n{\r\nif (!qede_roce_supported(edev))\r\nreturn;\r\nmutex_lock(&qedr_dev_list_lock);\r\n_qede_roce_dev_open(edev);\r\nmutex_unlock(&qedr_dev_list_lock);\r\n}\r\nstatic void _qede_roce_dev_close(struct qede_dev *edev)\r\n{\r\nif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\r\nqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_DOWN);\r\n}\r\nstatic void qede_roce_dev_close(struct qede_dev *edev)\r\n{\r\nif (!qede_roce_supported(edev))\r\nreturn;\r\nmutex_lock(&qedr_dev_list_lock);\r\n_qede_roce_dev_close(edev);\r\nmutex_unlock(&qedr_dev_list_lock);\r\n}\r\nstatic void qede_roce_dev_shutdown(struct qede_dev *edev)\r\n{\r\nif (!qede_roce_supported(edev))\r\nreturn;\r\nmutex_lock(&qedr_dev_list_lock);\r\nif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\r\nqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_CLOSE);\r\nmutex_unlock(&qedr_dev_list_lock);\r\n}\r\nint qede_roce_register_driver(struct qedr_driver *drv)\r\n{\r\nstruct qede_dev *edev;\r\nu8 qedr_counter = 0;\r\nmutex_lock(&qedr_dev_list_lock);\r\nif (qedr_drv) {\r\nmutex_unlock(&qedr_dev_list_lock);\r\nreturn -EINVAL;\r\n}\r\nqedr_drv = drv;\r\nlist_for_each_entry(edev, &qedr_dev_list, rdma_info.entry) {\r\nstruct net_device *ndev;\r\nqedr_counter++;\r\n_qede_roce_dev_add(edev);\r\nndev = edev->ndev;\r\nif (netif_running(ndev) && netif_oper_up(ndev))\r\n_qede_roce_dev_open(edev);\r\n}\r\nmutex_unlock(&qedr_dev_list_lock);\r\npr_notice("qedr: discovered and registered %d RoCE funcs\n",\r\nqedr_counter);\r\nreturn 0;\r\n}\r\nvoid qede_roce_unregister_driver(struct qedr_driver *drv)\r\n{\r\nstruct qede_dev *edev;\r\nmutex_lock(&qedr_dev_list_lock);\r\nlist_for_each_entry(edev, &qedr_dev_list, rdma_info.entry) {\r\nif (edev->rdma_info.qedr_dev)\r\n_qede_roce_dev_remove(edev);\r\n}\r\nqedr_drv = NULL;\r\nmutex_unlock(&qedr_dev_list_lock);\r\n}\r\nstatic void qede_roce_changeaddr(struct qede_dev *edev)\r\n{\r\nif (!qede_roce_supported(edev))\r\nreturn;\r\nif (qedr_drv && edev->rdma_info.qedr_dev && qedr_drv->notify)\r\nqedr_drv->notify(edev->rdma_info.qedr_dev, QEDE_CHANGE_ADDR);\r\n}\r\nstruct qede_roce_event_work *qede_roce_get_free_event_node(struct qede_dev\r\n*edev)\r\n{\r\nstruct qede_roce_event_work *event_node = NULL;\r\nstruct list_head *list_node = NULL;\r\nbool found = false;\r\nlist_for_each(list_node, &edev->rdma_info.roce_event_list) {\r\nevent_node = list_entry(list_node, struct qede_roce_event_work,\r\nlist);\r\nif (!work_pending(&event_node->work)) {\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nif (!found) {\r\nevent_node = kzalloc(sizeof(*event_node), GFP_KERNEL);\r\nif (!event_node) {\r\nDP_NOTICE(edev,\r\n"qedr: Could not allocate memory for roce work\n");\r\nreturn NULL;\r\n}\r\nlist_add_tail(&event_node->list,\r\n&edev->rdma_info.roce_event_list);\r\n}\r\nreturn event_node;\r\n}\r\nstatic void qede_roce_handle_event(struct work_struct *work)\r\n{\r\nstruct qede_roce_event_work *event_node;\r\nenum qede_roce_event event;\r\nstruct qede_dev *edev;\r\nevent_node = container_of(work, struct qede_roce_event_work, work);\r\nevent = event_node->event;\r\nedev = event_node->ptr;\r\nswitch (event) {\r\ncase QEDE_UP:\r\nqede_roce_dev_open(edev);\r\nbreak;\r\ncase QEDE_DOWN:\r\nqede_roce_dev_close(edev);\r\nbreak;\r\ncase QEDE_CLOSE:\r\nqede_roce_dev_shutdown(edev);\r\nbreak;\r\ncase QEDE_CHANGE_ADDR:\r\nqede_roce_changeaddr(edev);\r\nbreak;\r\ndefault:\r\nDP_NOTICE(edev, "Invalid roce event %d", event);\r\n}\r\n}\r\nstatic void qede_roce_add_event(struct qede_dev *edev,\r\nenum qede_roce_event event)\r\n{\r\nstruct qede_roce_event_work *event_node;\r\nif (!edev->rdma_info.qedr_dev)\r\nreturn;\r\nevent_node = qede_roce_get_free_event_node(edev);\r\nif (!event_node)\r\nreturn;\r\nevent_node->event = event;\r\nevent_node->ptr = edev;\r\nINIT_WORK(&event_node->work, qede_roce_handle_event);\r\nqueue_work(edev->rdma_info.roce_wq, &event_node->work);\r\n}\r\nvoid qede_roce_dev_event_open(struct qede_dev *edev)\r\n{\r\nqede_roce_add_event(edev, QEDE_UP);\r\n}\r\nvoid qede_roce_dev_event_close(struct qede_dev *edev)\r\n{\r\nqede_roce_add_event(edev, QEDE_DOWN);\r\n}\r\nvoid qede_roce_event_changeaddr(struct qede_dev *edev)\r\n{\r\nqede_roce_add_event(edev, QEDE_CHANGE_ADDR);\r\n}
