static int acpi_pci_root_scan_dependent(struct acpi_device *adev)\r\n{\r\nacpiphp_check_host_bridge(adev);\r\nreturn 0;\r\n}\r\nint acpi_is_root_bridge(acpi_handle handle)\r\n{\r\nint ret;\r\nstruct acpi_device *device;\r\nret = acpi_bus_get_device(handle, &device);\r\nif (ret)\r\nreturn 0;\r\nret = acpi_match_device_ids(device, root_device_ids);\r\nif (ret)\r\nreturn 0;\r\nelse\r\nreturn 1;\r\n}\r\nstatic acpi_status\r\nget_root_bridge_busnr_callback(struct acpi_resource *resource, void *data)\r\n{\r\nstruct resource *res = data;\r\nstruct acpi_resource_address64 address;\r\nacpi_status status;\r\nstatus = acpi_resource_to_address64(resource, &address);\r\nif (ACPI_FAILURE(status))\r\nreturn AE_OK;\r\nif ((address.address.address_length > 0) &&\r\n(address.resource_type == ACPI_BUS_NUMBER_RANGE)) {\r\nres->start = address.address.minimum;\r\nres->end = address.address.minimum + address.address.address_length - 1;\r\n}\r\nreturn AE_OK;\r\n}\r\nstatic acpi_status try_get_root_bridge_busnr(acpi_handle handle,\r\nstruct resource *res)\r\n{\r\nacpi_status status;\r\nres->start = -1;\r\nstatus =\r\nacpi_walk_resources(handle, METHOD_NAME__CRS,\r\nget_root_bridge_busnr_callback, res);\r\nif (ACPI_FAILURE(status))\r\nreturn status;\r\nif (res->start == -1)\r\nreturn AE_ERROR;\r\nreturn AE_OK;\r\n}\r\nstatic void decode_osc_bits(struct acpi_pci_root *root, char *msg, u32 word,\r\nstruct pci_osc_bit_struct *table, int size)\r\n{\r\nchar buf[80];\r\nint i, len = 0;\r\nstruct pci_osc_bit_struct *entry;\r\nbuf[0] = '\0';\r\nfor (i = 0, entry = table; i < size; i++, entry++)\r\nif (word & entry->bit)\r\nlen += snprintf(buf + len, sizeof(buf) - len, "%s%s",\r\nlen ? " " : "", entry->desc);\r\ndev_info(&root->device->dev, "_OSC: %s [%s]\n", msg, buf);\r\n}\r\nstatic void decode_osc_support(struct acpi_pci_root *root, char *msg, u32 word)\r\n{\r\ndecode_osc_bits(root, msg, word, pci_osc_support_bit,\r\nARRAY_SIZE(pci_osc_support_bit));\r\n}\r\nstatic void decode_osc_control(struct acpi_pci_root *root, char *msg, u32 word)\r\n{\r\ndecode_osc_bits(root, msg, word, pci_osc_control_bit,\r\nARRAY_SIZE(pci_osc_control_bit));\r\n}\r\nstatic acpi_status acpi_pci_run_osc(acpi_handle handle,\r\nconst u32 *capbuf, u32 *retval)\r\n{\r\nstruct acpi_osc_context context = {\r\n.uuid_str = pci_osc_uuid_str,\r\n.rev = 1,\r\n.cap.length = 12,\r\n.cap.pointer = (void *)capbuf,\r\n};\r\nacpi_status status;\r\nstatus = acpi_run_osc(handle, &context);\r\nif (ACPI_SUCCESS(status)) {\r\n*retval = *((u32 *)(context.ret.pointer + 8));\r\nkfree(context.ret.pointer);\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_pci_query_osc(struct acpi_pci_root *root,\r\nu32 support,\r\nu32 *control)\r\n{\r\nacpi_status status;\r\nu32 result, capbuf[3];\r\nsupport &= OSC_PCI_SUPPORT_MASKS;\r\nsupport |= root->osc_support_set;\r\ncapbuf[OSC_QUERY_DWORD] = OSC_QUERY_ENABLE;\r\ncapbuf[OSC_SUPPORT_DWORD] = support;\r\nif (control) {\r\n*control &= OSC_PCI_CONTROL_MASKS;\r\ncapbuf[OSC_CONTROL_DWORD] = *control | root->osc_control_set;\r\n} else {\r\ncapbuf[OSC_CONTROL_DWORD] = root->osc_control_set;\r\n}\r\nstatus = acpi_pci_run_osc(root->device->handle, capbuf, &result);\r\nif (ACPI_SUCCESS(status)) {\r\nroot->osc_support_set = support;\r\nif (control)\r\n*control = result;\r\n}\r\nreturn status;\r\n}\r\nstatic acpi_status acpi_pci_osc_support(struct acpi_pci_root *root, u32 flags)\r\n{\r\nacpi_status status;\r\nmutex_lock(&osc_lock);\r\nstatus = acpi_pci_query_osc(root, flags, NULL);\r\nmutex_unlock(&osc_lock);\r\nreturn status;\r\n}\r\nstruct acpi_pci_root *acpi_pci_find_root(acpi_handle handle)\r\n{\r\nstruct acpi_pci_root *root;\r\nstruct acpi_device *device;\r\nif (acpi_bus_get_device(handle, &device) ||\r\nacpi_match_device_ids(device, root_device_ids))\r\nreturn NULL;\r\nroot = acpi_driver_data(device);\r\nreturn root;\r\n}\r\nstruct pci_dev *acpi_get_pci_dev(acpi_handle handle)\r\n{\r\nint dev, fn;\r\nunsigned long long adr;\r\nacpi_status status;\r\nacpi_handle phandle;\r\nstruct pci_bus *pbus;\r\nstruct pci_dev *pdev = NULL;\r\nstruct acpi_handle_node *node, *tmp;\r\nstruct acpi_pci_root *root;\r\nLIST_HEAD(device_list);\r\nphandle = handle;\r\nwhile (!acpi_is_root_bridge(phandle)) {\r\nnode = kzalloc(sizeof(struct acpi_handle_node), GFP_KERNEL);\r\nif (!node)\r\ngoto out;\r\nINIT_LIST_HEAD(&node->node);\r\nnode->handle = phandle;\r\nlist_add(&node->node, &device_list);\r\nstatus = acpi_get_parent(phandle, &phandle);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\n}\r\nroot = acpi_pci_find_root(phandle);\r\nif (!root)\r\ngoto out;\r\npbus = root->bus;\r\nlist_for_each_entry(node, &device_list, node) {\r\nacpi_handle hnd = node->handle;\r\nstatus = acpi_evaluate_integer(hnd, "_ADR", NULL, &adr);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\ndev = (adr >> 16) & 0xffff;\r\nfn = adr & 0xffff;\r\npdev = pci_get_slot(pbus, PCI_DEVFN(dev, fn));\r\nif (!pdev || hnd == handle)\r\nbreak;\r\npbus = pdev->subordinate;\r\npci_dev_put(pdev);\r\nif (!pbus) {\r\ndev_dbg(&pdev->dev, "Not a PCI-to-PCI bridge\n");\r\npdev = NULL;\r\nbreak;\r\n}\r\n}\r\nout:\r\nlist_for_each_entry_safe(node, tmp, &device_list, node)\r\nkfree(node);\r\nreturn pdev;\r\n}\r\nacpi_status acpi_pci_osc_control_set(acpi_handle handle, u32 *mask, u32 req)\r\n{\r\nstruct acpi_pci_root *root;\r\nacpi_status status = AE_OK;\r\nu32 ctrl, capbuf[3];\r\nif (!mask)\r\nreturn AE_BAD_PARAMETER;\r\nctrl = *mask & OSC_PCI_CONTROL_MASKS;\r\nif ((ctrl & req) != req)\r\nreturn AE_TYPE;\r\nroot = acpi_pci_find_root(handle);\r\nif (!root)\r\nreturn AE_NOT_EXIST;\r\nmutex_lock(&osc_lock);\r\n*mask = ctrl | root->osc_control_set;\r\nif ((root->osc_control_set & ctrl) == ctrl)\r\ngoto out;\r\nwhile (*mask) {\r\nstatus = acpi_pci_query_osc(root, root->osc_support_set, mask);\r\nif (ACPI_FAILURE(status))\r\ngoto out;\r\nif (ctrl == *mask)\r\nbreak;\r\ndecode_osc_control(root, "platform does not support",\r\nctrl & ~(*mask));\r\nctrl = *mask;\r\n}\r\nif ((ctrl & req) != req) {\r\ndecode_osc_control(root, "not requesting control; platform does not support",\r\nreq & ~(ctrl));\r\nstatus = AE_SUPPORT;\r\ngoto out;\r\n}\r\ncapbuf[OSC_QUERY_DWORD] = 0;\r\ncapbuf[OSC_SUPPORT_DWORD] = root->osc_support_set;\r\ncapbuf[OSC_CONTROL_DWORD] = ctrl;\r\nstatus = acpi_pci_run_osc(handle, capbuf, mask);\r\nif (ACPI_SUCCESS(status))\r\nroot->osc_control_set = *mask;\r\nout:\r\nmutex_unlock(&osc_lock);\r\nreturn status;\r\n}\r\nstatic void negotiate_os_control(struct acpi_pci_root *root, int *no_aspm)\r\n{\r\nu32 support, control, requested;\r\nacpi_status status;\r\nstruct acpi_device *device = root->device;\r\nacpi_handle handle = device->handle;\r\nif (dmi_match(DMI_SYS_VENDOR, "Apple Inc.")) {\r\nroot->osc_control_set = ~OSC_PCI_EXPRESS_PME_CONTROL;\r\ndecode_osc_control(root, "OS assumes control of",\r\nroot->osc_control_set);\r\nreturn;\r\n}\r\nsupport = OSC_PCI_SEGMENT_GROUPS_SUPPORT;\r\nif (pci_ext_cfg_avail())\r\nsupport |= OSC_PCI_EXT_CONFIG_SUPPORT;\r\nif (pcie_aspm_support_enabled())\r\nsupport |= OSC_PCI_ASPM_SUPPORT | OSC_PCI_CLOCK_PM_SUPPORT;\r\nif (pci_msi_enabled())\r\nsupport |= OSC_PCI_MSI_SUPPORT;\r\ndecode_osc_support(root, "OS supports", support);\r\nstatus = acpi_pci_osc_support(root, support);\r\nif (ACPI_FAILURE(status)) {\r\ndev_info(&device->dev, "_OSC failed (%s); disabling ASPM\n",\r\nacpi_format_exception(status));\r\n*no_aspm = 1;\r\nreturn;\r\n}\r\nif (pcie_ports_disabled) {\r\ndev_info(&device->dev, "PCIe port services disabled; not requesting _OSC control\n");\r\nreturn;\r\n}\r\nif ((support & ACPI_PCIE_REQ_SUPPORT) != ACPI_PCIE_REQ_SUPPORT) {\r\ndecode_osc_support(root, "not requesting OS control; OS requires",\r\nACPI_PCIE_REQ_SUPPORT);\r\nreturn;\r\n}\r\ncontrol = OSC_PCI_EXPRESS_CAPABILITY_CONTROL\r\n| OSC_PCI_EXPRESS_NATIVE_HP_CONTROL\r\n| OSC_PCI_EXPRESS_PME_CONTROL;\r\nif (pci_aer_available()) {\r\nif (aer_acpi_firmware_first())\r\ndev_info(&device->dev,\r\n"PCIe AER handled by firmware\n");\r\nelse\r\ncontrol |= OSC_PCI_EXPRESS_AER_CONTROL;\r\n}\r\nrequested = control;\r\nstatus = acpi_pci_osc_control_set(handle, &control,\r\nOSC_PCI_EXPRESS_CAPABILITY_CONTROL);\r\nif (ACPI_SUCCESS(status)) {\r\ndecode_osc_control(root, "OS now controls", control);\r\nif (acpi_gbl_FADT.boot_flags & ACPI_FADT_NO_ASPM) {\r\ndev_info(&device->dev, "FADT indicates ASPM is unsupported, using BIOS configuration\n");\r\n*no_aspm = 1;\r\n}\r\n} else {\r\ndecode_osc_control(root, "OS requested", requested);\r\ndecode_osc_control(root, "platform willing to grant", control);\r\ndev_info(&device->dev, "_OSC failed (%s); disabling ASPM\n",\r\nacpi_format_exception(status));\r\n*no_aspm = 1;\r\n}\r\n}\r\nstatic int acpi_pci_root_add(struct acpi_device *device,\r\nconst struct acpi_device_id *not_used)\r\n{\r\nunsigned long long segment, bus;\r\nacpi_status status;\r\nint result;\r\nstruct acpi_pci_root *root;\r\nacpi_handle handle = device->handle;\r\nint no_aspm = 0;\r\nbool hotadd = system_state != SYSTEM_BOOTING;\r\nroot = kzalloc(sizeof(struct acpi_pci_root), GFP_KERNEL);\r\nif (!root)\r\nreturn -ENOMEM;\r\nsegment = 0;\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__SEG, NULL,\r\n&segment);\r\nif (ACPI_FAILURE(status) && status != AE_NOT_FOUND) {\r\ndev_err(&device->dev, "can't evaluate _SEG\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\nroot->secondary.flags = IORESOURCE_BUS;\r\nstatus = try_get_root_bridge_busnr(handle, &root->secondary);\r\nif (ACPI_FAILURE(status)) {\r\nroot->secondary.end = 0xFF;\r\ndev_warn(&device->dev,\r\nFW_BUG "no secondary bus range in _CRS\n");\r\nstatus = acpi_evaluate_integer(handle, METHOD_NAME__BBN,\r\nNULL, &bus);\r\nif (ACPI_SUCCESS(status))\r\nroot->secondary.start = bus;\r\nelse if (status == AE_NOT_FOUND)\r\nroot->secondary.start = 0;\r\nelse {\r\ndev_err(&device->dev, "can't evaluate _BBN\n");\r\nresult = -ENODEV;\r\ngoto end;\r\n}\r\n}\r\nroot->device = device;\r\nroot->segment = segment & 0xFFFF;\r\nstrcpy(acpi_device_name(device), ACPI_PCI_ROOT_DEVICE_NAME);\r\nstrcpy(acpi_device_class(device), ACPI_PCI_ROOT_CLASS);\r\ndevice->driver_data = root;\r\nif (hotadd && dmar_device_add(handle)) {\r\nresult = -ENXIO;\r\ngoto end;\r\n}\r\npr_info(PREFIX "%s [%s] (domain %04x %pR)\n",\r\nacpi_device_name(device), acpi_device_bid(device),\r\nroot->segment, &root->secondary);\r\nroot->mcfg_addr = acpi_pci_root_get_mcfg_addr(handle);\r\nnegotiate_os_control(root, &no_aspm);\r\nroot->bus = pci_acpi_scan_root(root);\r\nif (!root->bus) {\r\ndev_err(&device->dev,\r\n"Bus %04x:%02x not present in PCI namespace\n",\r\nroot->segment, (unsigned int)root->secondary.start);\r\ndevice->driver_data = NULL;\r\nresult = -ENODEV;\r\ngoto remove_dmar;\r\n}\r\nif (no_aspm)\r\npcie_no_aspm();\r\npci_acpi_add_bus_pm_notifier(device);\r\nif (device->wakeup.flags.run_wake)\r\ndevice_set_run_wake(root->bus->bridge, true);\r\nif (hotadd) {\r\npcibios_resource_survey_bus(root->bus);\r\npci_assign_unassigned_root_bus_resources(root->bus);\r\nacpi_ioapic_add(root->device->handle);\r\n}\r\npci_lock_rescan_remove();\r\npci_bus_add_devices(root->bus);\r\npci_unlock_rescan_remove();\r\nreturn 1;\r\nremove_dmar:\r\nif (hotadd)\r\ndmar_device_remove(handle);\r\nend:\r\nkfree(root);\r\nreturn result;\r\n}\r\nstatic void acpi_pci_root_remove(struct acpi_device *device)\r\n{\r\nstruct acpi_pci_root *root = acpi_driver_data(device);\r\npci_lock_rescan_remove();\r\npci_stop_root_bus(root->bus);\r\npci_ioapic_remove(root);\r\ndevice_set_run_wake(root->bus->bridge, false);\r\npci_acpi_remove_bus_pm_notifier(device);\r\npci_remove_root_bus(root->bus);\r\nWARN_ON(acpi_ioapic_remove(root));\r\ndmar_device_remove(device->handle);\r\npci_unlock_rescan_remove();\r\nkfree(root);\r\n}\r\nstatic void acpi_pci_root_validate_resources(struct device *dev,\r\nstruct list_head *resources,\r\nunsigned long type)\r\n{\r\nLIST_HEAD(list);\r\nstruct resource *res1, *res2, *root = NULL;\r\nstruct resource_entry *tmp, *entry, *entry2;\r\nBUG_ON((type & (IORESOURCE_MEM | IORESOURCE_IO)) == 0);\r\nroot = (type & IORESOURCE_MEM) ? &iomem_resource : &ioport_resource;\r\nlist_splice_init(resources, &list);\r\nresource_list_for_each_entry_safe(entry, tmp, &list) {\r\nbool free = false;\r\nresource_size_t end;\r\nres1 = entry->res;\r\nif (!(res1->flags & type))\r\ngoto next;\r\nend = min(res1->end, root->end);\r\nif (end <= res1->start) {\r\ndev_info(dev, "host bridge window %pR (ignored, not CPU addressable)\n",\r\nres1);\r\nfree = true;\r\ngoto next;\r\n} else if (res1->end != end) {\r\ndev_info(dev, "host bridge window %pR ([%#llx-%#llx] ignored, not CPU addressable)\n",\r\nres1, (unsigned long long)end + 1,\r\n(unsigned long long)res1->end);\r\nres1->end = end;\r\n}\r\nresource_list_for_each_entry(entry2, resources) {\r\nres2 = entry2->res;\r\nif (!(res2->flags & type))\r\ncontinue;\r\nif (resource_overlaps(res1, res2)) {\r\nres2->start = min(res1->start, res2->start);\r\nres2->end = max(res1->end, res2->end);\r\ndev_info(dev, "host bridge window expanded to %pR; %pR ignored\n",\r\nres2, res1);\r\nfree = true;\r\ngoto next;\r\n}\r\n}\r\nnext:\r\nresource_list_del(entry);\r\nif (free)\r\nresource_list_free_entry(entry);\r\nelse\r\nresource_list_add_tail(entry, resources);\r\n}\r\n}\r\nstatic void acpi_pci_root_remap_iospace(struct resource_entry *entry)\r\n{\r\n#ifdef PCI_IOBASE\r\nstruct resource *res = entry->res;\r\nresource_size_t cpu_addr = res->start;\r\nresource_size_t pci_addr = cpu_addr - entry->offset;\r\nresource_size_t length = resource_size(res);\r\nunsigned long port;\r\nif (pci_register_io_range(cpu_addr, length))\r\ngoto err;\r\nport = pci_address_to_pio(cpu_addr);\r\nif (port == (unsigned long)-1)\r\ngoto err;\r\nres->start = port;\r\nres->end = port + length - 1;\r\nentry->offset = port - pci_addr;\r\nif (pci_remap_iospace(res, cpu_addr) < 0)\r\ngoto err;\r\npr_info("Remapped I/O %pa to %pR\n", &cpu_addr, res);\r\nreturn;\r\nerr:\r\nres->flags |= IORESOURCE_DISABLED;\r\n#endif\r\n}\r\nint acpi_pci_probe_root_resources(struct acpi_pci_root_info *info)\r\n{\r\nint ret;\r\nstruct list_head *list = &info->resources;\r\nstruct acpi_device *device = info->bridge;\r\nstruct resource_entry *entry, *tmp;\r\nunsigned long flags;\r\nflags = IORESOURCE_IO | IORESOURCE_MEM | IORESOURCE_MEM_8AND16BIT;\r\nret = acpi_dev_get_resources(device, list,\r\nacpi_dev_filter_resource_type_cb,\r\n(void *)flags);\r\nif (ret < 0)\r\ndev_warn(&device->dev,\r\n"failed to parse _CRS method, error code %d\n", ret);\r\nelse if (ret == 0)\r\ndev_dbg(&device->dev,\r\n"no IO and memory resources present in _CRS\n");\r\nelse {\r\nresource_list_for_each_entry_safe(entry, tmp, list) {\r\nif (entry->res->flags & IORESOURCE_IO)\r\nacpi_pci_root_remap_iospace(entry);\r\nif (entry->res->flags & IORESOURCE_DISABLED)\r\nresource_list_destroy_entry(entry);\r\nelse\r\nentry->res->name = info->name;\r\n}\r\nacpi_pci_root_validate_resources(&device->dev, list,\r\nIORESOURCE_MEM);\r\nacpi_pci_root_validate_resources(&device->dev, list,\r\nIORESOURCE_IO);\r\n}\r\nreturn ret;\r\n}\r\nstatic void pci_acpi_root_add_resources(struct acpi_pci_root_info *info)\r\n{\r\nstruct resource_entry *entry, *tmp;\r\nstruct resource *res, *conflict, *root = NULL;\r\nresource_list_for_each_entry_safe(entry, tmp, &info->resources) {\r\nres = entry->res;\r\nif (res->flags & IORESOURCE_MEM)\r\nroot = &iomem_resource;\r\nelse if (res->flags & IORESOURCE_IO)\r\nroot = &ioport_resource;\r\nelse\r\ncontinue;\r\nif (res == root)\r\ncontinue;\r\nconflict = insert_resource_conflict(root, res);\r\nif (conflict) {\r\ndev_info(&info->bridge->dev,\r\n"ignoring host bridge window %pR (conflicts with %s %pR)\n",\r\nres, conflict->name, conflict);\r\nresource_list_destroy_entry(entry);\r\n}\r\n}\r\n}\r\nstatic void __acpi_pci_root_release_info(struct acpi_pci_root_info *info)\r\n{\r\nstruct resource *res;\r\nstruct resource_entry *entry, *tmp;\r\nif (!info)\r\nreturn;\r\nresource_list_for_each_entry_safe(entry, tmp, &info->resources) {\r\nres = entry->res;\r\nif (res->parent &&\r\n(res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))\r\nrelease_resource(res);\r\nresource_list_destroy_entry(entry);\r\n}\r\ninfo->ops->release_info(info);\r\n}\r\nstatic void acpi_pci_root_release_info(struct pci_host_bridge *bridge)\r\n{\r\nstruct resource *res;\r\nstruct resource_entry *entry;\r\nresource_list_for_each_entry(entry, &bridge->windows) {\r\nres = entry->res;\r\nif (res->flags & IORESOURCE_IO)\r\npci_unmap_iospace(res);\r\nif (res->parent &&\r\n(res->flags & (IORESOURCE_MEM | IORESOURCE_IO)))\r\nrelease_resource(res);\r\n}\r\n__acpi_pci_root_release_info(bridge->release_data);\r\n}\r\nstruct pci_bus *acpi_pci_root_create(struct acpi_pci_root *root,\r\nstruct acpi_pci_root_ops *ops,\r\nstruct acpi_pci_root_info *info,\r\nvoid *sysdata)\r\n{\r\nint ret, busnum = root->secondary.start;\r\nstruct acpi_device *device = root->device;\r\nint node = acpi_get_node(device->handle);\r\nstruct pci_bus *bus;\r\ninfo->root = root;\r\ninfo->bridge = device;\r\ninfo->ops = ops;\r\nINIT_LIST_HEAD(&info->resources);\r\nsnprintf(info->name, sizeof(info->name), "PCI Bus %04x:%02x",\r\nroot->segment, busnum);\r\nif (ops->init_info && ops->init_info(info))\r\ngoto out_release_info;\r\nif (ops->prepare_resources)\r\nret = ops->prepare_resources(info);\r\nelse\r\nret = acpi_pci_probe_root_resources(info);\r\nif (ret < 0)\r\ngoto out_release_info;\r\npci_acpi_root_add_resources(info);\r\npci_add_resource(&info->resources, &root->secondary);\r\nbus = pci_create_root_bus(NULL, busnum, ops->pci_ops,\r\nsysdata, &info->resources);\r\nif (!bus)\r\ngoto out_release_info;\r\npci_scan_child_bus(bus);\r\npci_set_host_bridge_release(to_pci_host_bridge(bus->bridge),\r\nacpi_pci_root_release_info, info);\r\nif (node != NUMA_NO_NODE)\r\ndev_printk(KERN_DEBUG, &bus->dev, "on NUMA node %d\n", node);\r\nreturn bus;\r\nout_release_info:\r\n__acpi_pci_root_release_info(info);\r\nreturn NULL;\r\n}\r\nvoid __init acpi_pci_root_init(void)\r\n{\r\nacpi_hest_init();\r\nif (acpi_pci_disabled)\r\nreturn;\r\npci_acpi_crs_quirks();\r\nacpi_scan_add_handler_with_hotplug(&pci_root_handler, "pci_root");\r\n}
