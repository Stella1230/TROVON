static void hisi_femac_irq_enable(struct hisi_femac_priv *priv, int irqs)\r\n{\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_IRQ_ENA);\r\nwritel(val | irqs, priv->glb_base + GLB_IRQ_ENA);\r\n}\r\nstatic void hisi_femac_irq_disable(struct hisi_femac_priv *priv, int irqs)\r\n{\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_IRQ_ENA);\r\nwritel(val & (~irqs), priv->glb_base + GLB_IRQ_ENA);\r\n}\r\nstatic void hisi_femac_tx_dma_unmap(struct hisi_femac_priv *priv,\r\nstruct sk_buff *skb, unsigned int pos)\r\n{\r\ndma_addr_t dma_addr;\r\ndma_addr = priv->txq.dma_phys[pos];\r\ndma_unmap_single(priv->dev, dma_addr, skb->len, DMA_TO_DEVICE);\r\n}\r\nstatic void hisi_femac_xmit_reclaim(struct net_device *dev)\r\n{\r\nstruct sk_buff *skb;\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nstruct hisi_femac_queue *txq = &priv->txq;\r\nunsigned int bytes_compl = 0, pkts_compl = 0;\r\nu32 val;\r\nnetif_tx_lock(dev);\r\nval = readl(priv->port_base + ADDRQ_STAT) & TX_CNT_INUSE_MASK;\r\nwhile (val < priv->tx_fifo_used_cnt) {\r\nskb = txq->skb[txq->tail];\r\nif (unlikely(!skb)) {\r\nnetdev_err(dev, "xmitq_cnt_inuse=%d, tx_fifo_used=%d\n",\r\nval, priv->tx_fifo_used_cnt);\r\nbreak;\r\n}\r\nhisi_femac_tx_dma_unmap(priv, skb, txq->tail);\r\npkts_compl++;\r\nbytes_compl += skb->len;\r\ndev_kfree_skb_any(skb);\r\npriv->tx_fifo_used_cnt--;\r\nval = readl(priv->port_base + ADDRQ_STAT) & TX_CNT_INUSE_MASK;\r\ntxq->skb[txq->tail] = NULL;\r\ntxq->tail = (txq->tail + 1) % txq->num;\r\n}\r\nnetdev_completed_queue(dev, pkts_compl, bytes_compl);\r\nif (unlikely(netif_queue_stopped(dev)) && pkts_compl)\r\nnetif_wake_queue(dev);\r\nnetif_tx_unlock(dev);\r\n}\r\nstatic void hisi_femac_adjust_link(struct net_device *dev)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nstruct phy_device *phy = dev->phydev;\r\nu32 status = 0;\r\nif (phy->link)\r\nstatus |= MAC_PORTSET_LINKED;\r\nif (phy->duplex == DUPLEX_FULL)\r\nstatus |= MAC_PORTSET_DUPLEX_FULL;\r\nif (phy->speed == SPEED_100)\r\nstatus |= MAC_PORTSET_SPEED_100M;\r\nif ((status != priv->link_status) &&\r\n((status | priv->link_status) & MAC_PORTSET_LINKED)) {\r\nwritel(status, priv->port_base + MAC_PORTSET);\r\npriv->link_status = status;\r\nphy_print_status(phy);\r\n}\r\n}\r\nstatic void hisi_femac_rx_refill(struct hisi_femac_priv *priv)\r\n{\r\nstruct hisi_femac_queue *rxq = &priv->rxq;\r\nstruct sk_buff *skb;\r\nu32 pos;\r\nu32 len = MAX_FRAME_SIZE;\r\ndma_addr_t addr;\r\npos = rxq->head;\r\nwhile (readl(priv->port_base + ADDRQ_STAT) & BIT_RX_READY) {\r\nif (!CIRC_SPACE(pos, rxq->tail, rxq->num))\r\nbreak;\r\nif (unlikely(rxq->skb[pos])) {\r\nnetdev_err(priv->ndev, "err skb[%d]=%p\n",\r\npos, rxq->skb[pos]);\r\nbreak;\r\n}\r\nskb = netdev_alloc_skb_ip_align(priv->ndev, len);\r\nif (unlikely(!skb))\r\nbreak;\r\naddr = dma_map_single(priv->dev, skb->data, len,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(priv->dev, addr)) {\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\n}\r\nrxq->dma_phys[pos] = addr;\r\nrxq->skb[pos] = skb;\r\nwritel(addr, priv->port_base + IQ_ADDR);\r\npos = (pos + 1) % rxq->num;\r\n}\r\nrxq->head = pos;\r\n}\r\nstatic int hisi_femac_rx(struct net_device *dev, int limit)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nstruct hisi_femac_queue *rxq = &priv->rxq;\r\nstruct sk_buff *skb;\r\ndma_addr_t addr;\r\nu32 rx_pkt_info, pos, len, rx_pkts_num = 0;\r\npos = rxq->tail;\r\nwhile (readl(priv->glb_base + GLB_IRQ_RAW) & IRQ_INT_RX_RDY) {\r\nrx_pkt_info = readl(priv->port_base + IQFRM_DES);\r\nlen = rx_pkt_info & RX_FRAME_LEN_MASK;\r\nlen -= ETH_FCS_LEN;\r\nwritel(IRQ_INT_RX_RDY, priv->glb_base + GLB_IRQ_RAW);\r\nrx_pkts_num++;\r\nskb = rxq->skb[pos];\r\nif (unlikely(!skb)) {\r\nnetdev_err(dev, "rx skb NULL. pos=%d\n", pos);\r\nbreak;\r\n}\r\nrxq->skb[pos] = NULL;\r\naddr = rxq->dma_phys[pos];\r\ndma_unmap_single(priv->dev, addr, MAX_FRAME_SIZE,\r\nDMA_FROM_DEVICE);\r\nskb_put(skb, len);\r\nif (unlikely(skb->len > MAX_FRAME_SIZE)) {\r\nnetdev_err(dev, "rcv len err, len = %d\n", skb->len);\r\ndev->stats.rx_errors++;\r\ndev->stats.rx_length_errors++;\r\ndev_kfree_skb_any(skb);\r\ngoto next;\r\n}\r\nskb->protocol = eth_type_trans(skb, dev);\r\nnapi_gro_receive(&priv->napi, skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += skb->len;\r\nnext:\r\npos = (pos + 1) % rxq->num;\r\nif (rx_pkts_num >= limit)\r\nbreak;\r\n}\r\nrxq->tail = pos;\r\nhisi_femac_rx_refill(priv);\r\nreturn rx_pkts_num;\r\n}\r\nstatic int hisi_femac_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct hisi_femac_priv *priv = container_of(napi,\r\nstruct hisi_femac_priv, napi);\r\nstruct net_device *dev = priv->ndev;\r\nint work_done = 0, task = budget;\r\nint ints, num;\r\ndo {\r\nhisi_femac_xmit_reclaim(dev);\r\nnum = hisi_femac_rx(dev, task);\r\nwork_done += num;\r\ntask -= num;\r\nif (work_done >= budget)\r\nbreak;\r\nints = readl(priv->glb_base + GLB_IRQ_RAW);\r\nwritel(ints & DEF_INT_MASK,\r\npriv->glb_base + GLB_IRQ_RAW);\r\n} while (ints & DEF_INT_MASK);\r\nif (work_done < budget) {\r\nnapi_complete_done(napi, work_done);\r\nhisi_femac_irq_enable(priv, DEF_INT_MASK &\r\n(~IRQ_INT_TX_PER_PACKET));\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t hisi_femac_interrupt(int irq, void *dev_id)\r\n{\r\nint ints;\r\nstruct net_device *dev = (struct net_device *)dev_id;\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nints = readl(priv->glb_base + GLB_IRQ_RAW);\r\nif (likely(ints & DEF_INT_MASK)) {\r\nwritel(ints & DEF_INT_MASK,\r\npriv->glb_base + GLB_IRQ_RAW);\r\nhisi_femac_irq_disable(priv, DEF_INT_MASK);\r\nnapi_schedule(&priv->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int hisi_femac_init_queue(struct device *dev,\r\nstruct hisi_femac_queue *queue,\r\nunsigned int num)\r\n{\r\nqueue->skb = devm_kcalloc(dev, num, sizeof(struct sk_buff *),\r\nGFP_KERNEL);\r\nif (!queue->skb)\r\nreturn -ENOMEM;\r\nqueue->dma_phys = devm_kcalloc(dev, num, sizeof(dma_addr_t),\r\nGFP_KERNEL);\r\nif (!queue->dma_phys)\r\nreturn -ENOMEM;\r\nqueue->num = num;\r\nqueue->head = 0;\r\nqueue->tail = 0;\r\nreturn 0;\r\n}\r\nstatic int hisi_femac_init_tx_and_rx_queues(struct hisi_femac_priv *priv)\r\n{\r\nint ret;\r\nret = hisi_femac_init_queue(priv->dev, &priv->txq, TXQ_NUM);\r\nif (ret)\r\nreturn ret;\r\nret = hisi_femac_init_queue(priv->dev, &priv->rxq, RXQ_NUM);\r\nif (ret)\r\nreturn ret;\r\npriv->tx_fifo_used_cnt = 0;\r\nreturn 0;\r\n}\r\nstatic void hisi_femac_free_skb_rings(struct hisi_femac_priv *priv)\r\n{\r\nstruct hisi_femac_queue *txq = &priv->txq;\r\nstruct hisi_femac_queue *rxq = &priv->rxq;\r\nstruct sk_buff *skb;\r\ndma_addr_t dma_addr;\r\nu32 pos;\r\npos = rxq->tail;\r\nwhile (pos != rxq->head) {\r\nskb = rxq->skb[pos];\r\nif (unlikely(!skb)) {\r\nnetdev_err(priv->ndev, "NULL rx skb. pos=%d, head=%d\n",\r\npos, rxq->head);\r\ncontinue;\r\n}\r\ndma_addr = rxq->dma_phys[pos];\r\ndma_unmap_single(priv->dev, dma_addr, MAX_FRAME_SIZE,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nrxq->skb[pos] = NULL;\r\npos = (pos + 1) % rxq->num;\r\n}\r\nrxq->tail = pos;\r\npos = txq->tail;\r\nwhile (pos != txq->head) {\r\nskb = txq->skb[pos];\r\nif (unlikely(!skb)) {\r\nnetdev_err(priv->ndev, "NULL tx skb. pos=%d, head=%d\n",\r\npos, txq->head);\r\ncontinue;\r\n}\r\nhisi_femac_tx_dma_unmap(priv, skb, pos);\r\ndev_kfree_skb_any(skb);\r\ntxq->skb[pos] = NULL;\r\npos = (pos + 1) % txq->num;\r\n}\r\ntxq->tail = pos;\r\npriv->tx_fifo_used_cnt = 0;\r\n}\r\nstatic int hisi_femac_set_hw_mac_addr(struct hisi_femac_priv *priv,\r\nunsigned char *mac)\r\n{\r\nu32 reg;\r\nreg = mac[1] | (mac[0] << 8);\r\nwritel(reg, priv->glb_base + GLB_HOSTMAC_H16);\r\nreg = mac[5] | (mac[4] << 8) | (mac[3] << 16) | (mac[2] << 24);\r\nwritel(reg, priv->glb_base + GLB_HOSTMAC_L32);\r\nreturn 0;\r\n}\r\nstatic int hisi_femac_port_reset(struct hisi_femac_priv *priv)\r\n{\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_SOFT_RESET);\r\nval |= SOFT_RESET_ALL;\r\nwritel(val, priv->glb_base + GLB_SOFT_RESET);\r\nusleep_range(500, 800);\r\nval &= ~SOFT_RESET_ALL;\r\nwritel(val, priv->glb_base + GLB_SOFT_RESET);\r\nreturn 0;\r\n}\r\nstatic int hisi_femac_net_open(struct net_device *dev)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nhisi_femac_port_reset(priv);\r\nhisi_femac_set_hw_mac_addr(priv, dev->dev_addr);\r\nhisi_femac_rx_refill(priv);\r\nnetif_carrier_off(dev);\r\nnetdev_reset_queue(dev);\r\nnetif_start_queue(dev);\r\nnapi_enable(&priv->napi);\r\npriv->link_status = 0;\r\nif (dev->phydev)\r\nphy_start(dev->phydev);\r\nwritel(IRQ_ENA_PORT0_MASK, priv->glb_base + GLB_IRQ_RAW);\r\nhisi_femac_irq_enable(priv, IRQ_ENA_ALL | IRQ_ENA_PORT0 | DEF_INT_MASK);\r\nreturn 0;\r\n}\r\nstatic int hisi_femac_net_close(struct net_device *dev)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nhisi_femac_irq_disable(priv, IRQ_ENA_PORT0);\r\nif (dev->phydev)\r\nphy_stop(dev->phydev);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&priv->napi);\r\nhisi_femac_free_skb_rings(priv);\r\nreturn 0;\r\n}\r\nstatic netdev_tx_t hisi_femac_net_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nstruct hisi_femac_queue *txq = &priv->txq;\r\ndma_addr_t addr;\r\nu32 val;\r\nval = readl(priv->port_base + ADDRQ_STAT);\r\nval &= BIT_TX_READY;\r\nif (!val) {\r\nhisi_femac_irq_enable(priv, IRQ_INT_TX_PER_PACKET);\r\ndev->stats.tx_dropped++;\r\ndev->stats.tx_fifo_errors++;\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nif (unlikely(!CIRC_SPACE(txq->head, txq->tail,\r\ntxq->num))) {\r\nhisi_femac_irq_enable(priv, IRQ_INT_TX_PER_PACKET);\r\ndev->stats.tx_dropped++;\r\ndev->stats.tx_fifo_errors++;\r\nnetif_stop_queue(dev);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\naddr = dma_map_single(priv->dev, skb->data,\r\nskb->len, DMA_TO_DEVICE);\r\nif (unlikely(dma_mapping_error(priv->dev, addr))) {\r\ndev_kfree_skb_any(skb);\r\ndev->stats.tx_dropped++;\r\nreturn NETDEV_TX_OK;\r\n}\r\ntxq->dma_phys[txq->head] = addr;\r\ntxq->skb[txq->head] = skb;\r\ntxq->head = (txq->head + 1) % txq->num;\r\nwritel(addr, priv->port_base + EQ_ADDR);\r\nwritel(skb->len + ETH_FCS_LEN, priv->port_base + EQFRM_LEN);\r\npriv->tx_fifo_used_cnt++;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += skb->len;\r\nnetdev_sent_queue(dev, skb->len);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int hisi_femac_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nstruct sockaddr *skaddr = p;\r\nif (!is_valid_ether_addr(skaddr->sa_data))\r\nreturn -EADDRNOTAVAIL;\r\nmemcpy(dev->dev_addr, skaddr->sa_data, dev->addr_len);\r\ndev->addr_assign_type &= ~NET_ADDR_RANDOM;\r\nhisi_femac_set_hw_mac_addr(priv, dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic void hisi_femac_enable_hw_addr_filter(struct hisi_femac_priv *priv,\r\nunsigned int reg_n, bool enable)\r\n{\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_MAC_H16(reg_n));\r\nif (enable)\r\nval |= BIT_MACFLT_ENA;\r\nelse\r\nval &= ~BIT_MACFLT_ENA;\r\nwritel(val, priv->glb_base + GLB_MAC_H16(reg_n));\r\n}\r\nstatic void hisi_femac_set_hw_addr_filter(struct hisi_femac_priv *priv,\r\nunsigned char *addr,\r\nunsigned int reg_n)\r\n{\r\nunsigned int high, low;\r\nu32 val;\r\nhigh = GLB_MAC_H16(reg_n);\r\nlow = GLB_MAC_L32(reg_n);\r\nval = (addr[2] << 24) | (addr[3] << 16) | (addr[4] << 8) | addr[5];\r\nwritel(val, priv->glb_base + low);\r\nval = readl(priv->glb_base + high);\r\nval &= ~MACFLT_HI16_MASK;\r\nval |= ((addr[0] << 8) | addr[1]);\r\nval |= (BIT_MACFLT_ENA | BIT_MACFLT_FW2CPU);\r\nwritel(val, priv->glb_base + high);\r\n}\r\nstatic void hisi_femac_set_promisc_mode(struct hisi_femac_priv *priv,\r\nbool promisc_mode)\r\n{\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_FWCTRL);\r\nif (promisc_mode)\r\nval |= FWCTRL_FWALL2CPU;\r\nelse\r\nval &= ~FWCTRL_FWALL2CPU;\r\nwritel(val, priv->glb_base + GLB_FWCTRL);\r\n}\r\nstatic void hisi_femac_set_mc_addr_filter(struct hisi_femac_priv *priv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_MACTCTRL);\r\nif ((netdev_mc_count(dev) > MAX_MULTICAST_ADDRESSES) ||\r\n(dev->flags & IFF_ALLMULTI)) {\r\nval |= MACTCTRL_MULTI2CPU;\r\n} else {\r\nint reg = MAX_UNICAST_ADDRESSES;\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\nfor (i = reg; i < MAX_MAC_FILTER_NUM; i++)\r\nhisi_femac_enable_hw_addr_filter(priv, i, false);\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nhisi_femac_set_hw_addr_filter(priv, ha->addr, reg);\r\nreg++;\r\n}\r\nval &= ~MACTCTRL_MULTI2CPU;\r\n}\r\nwritel(val, priv->glb_base + GLB_MACTCTRL);\r\n}\r\nstatic void hisi_femac_set_uc_addr_filter(struct hisi_femac_priv *priv)\r\n{\r\nstruct net_device *dev = priv->ndev;\r\nu32 val;\r\nval = readl(priv->glb_base + GLB_MACTCTRL);\r\nif (netdev_uc_count(dev) > MAX_UNICAST_ADDRESSES) {\r\nval |= MACTCTRL_UNI2CPU;\r\n} else {\r\nint reg = 0;\r\nint i;\r\nstruct netdev_hw_addr *ha;\r\nfor (i = reg; i < MAX_UNICAST_ADDRESSES; i++)\r\nhisi_femac_enable_hw_addr_filter(priv, i, false);\r\nnetdev_for_each_uc_addr(ha, dev) {\r\nhisi_femac_set_hw_addr_filter(priv, ha->addr, reg);\r\nreg++;\r\n}\r\nval &= ~MACTCTRL_UNI2CPU;\r\n}\r\nwritel(val, priv->glb_base + GLB_MACTCTRL);\r\n}\r\nstatic void hisi_femac_net_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct hisi_femac_priv *priv = netdev_priv(dev);\r\nif (dev->flags & IFF_PROMISC) {\r\nhisi_femac_set_promisc_mode(priv, true);\r\n} else {\r\nhisi_femac_set_promisc_mode(priv, false);\r\nhisi_femac_set_mc_addr_filter(priv);\r\nhisi_femac_set_uc_addr_filter(priv);\r\n}\r\n}\r\nstatic int hisi_femac_net_ioctl(struct net_device *dev,\r\nstruct ifreq *ifreq, int cmd)\r\n{\r\nif (!netif_running(dev))\r\nreturn -EINVAL;\r\nif (!dev->phydev)\r\nreturn -EINVAL;\r\nreturn phy_mii_ioctl(dev->phydev, ifreq, cmd);\r\n}\r\nstatic void hisi_femac_core_reset(struct hisi_femac_priv *priv)\r\n{\r\nreset_control_assert(priv->mac_rst);\r\nreset_control_deassert(priv->mac_rst);\r\n}\r\nstatic void hisi_femac_sleep_us(u32 time_us)\r\n{\r\nu32 time_ms;\r\nif (!time_us)\r\nreturn;\r\ntime_ms = DIV_ROUND_UP(time_us, 1000);\r\nif (time_ms < 20)\r\nusleep_range(time_us, time_us + 500);\r\nelse\r\nmsleep(time_ms);\r\n}\r\nstatic void hisi_femac_phy_reset(struct hisi_femac_priv *priv)\r\n{\r\nreset_control_deassert(priv->phy_rst);\r\nhisi_femac_sleep_us(priv->phy_reset_delays[PRE_DELAY]);\r\nreset_control_assert(priv->phy_rst);\r\nhisi_femac_sleep_us(priv->phy_reset_delays[PULSE]);\r\nreset_control_deassert(priv->phy_rst);\r\nhisi_femac_sleep_us(priv->phy_reset_delays[POST_DELAY]);\r\n}\r\nstatic void hisi_femac_port_init(struct hisi_femac_priv *priv)\r\n{\r\nu32 val;\r\nval = MAC_PORTSEL_STAT_CPU;\r\nif (priv->ndev->phydev->interface == PHY_INTERFACE_MODE_RMII)\r\nval |= MAC_PORTSEL_RMII;\r\nwritel(val, priv->port_base + MAC_PORTSEL);\r\nwritel(IRQ_ENA_PORT0_MASK, priv->glb_base + GLB_IRQ_RAW);\r\nhisi_femac_irq_disable(priv, IRQ_ENA_PORT0_MASK | IRQ_ENA_PORT0);\r\nval = readl(priv->glb_base + GLB_FWCTRL);\r\nval &= ~(FWCTRL_VLAN_ENABLE | FWCTRL_FWALL2CPU);\r\nval |= FWCTRL_FW2CPU_ENA;\r\nwritel(val, priv->glb_base + GLB_FWCTRL);\r\nval = readl(priv->glb_base + GLB_MACTCTRL);\r\nval |= (MACTCTRL_BROAD2CPU | MACTCTRL_MACT_ENA);\r\nwritel(val, priv->glb_base + GLB_MACTCTRL);\r\nval = readl(priv->port_base + MAC_SET);\r\nval &= ~MAX_FRAME_SIZE_MASK;\r\nval |= MAX_FRAME_SIZE;\r\nwritel(val, priv->port_base + MAC_SET);\r\nval = RX_COALESCED_TIMER |\r\n(RX_COALESCED_FRAMES << RX_COALESCED_FRAME_OFFSET);\r\nwritel(val, priv->port_base + RX_COALESCE_SET);\r\nval = (HW_RX_FIFO_DEPTH << RX_DEPTH_OFFSET) | HW_TX_FIFO_DEPTH;\r\nwritel(val, priv->port_base + QLEN_SET);\r\n}\r\nstatic int hisi_femac_drv_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *node = dev->of_node;\r\nstruct resource *res;\r\nstruct net_device *ndev;\r\nstruct hisi_femac_priv *priv;\r\nstruct phy_device *phy;\r\nconst char *mac_addr;\r\nint ret;\r\nndev = alloc_etherdev(sizeof(*priv));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, ndev);\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\npriv = netdev_priv(ndev);\r\npriv->dev = dev;\r\npriv->ndev = ndev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->port_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->port_base)) {\r\nret = PTR_ERR(priv->port_base);\r\ngoto out_free_netdev;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npriv->glb_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->glb_base)) {\r\nret = PTR_ERR(priv->glb_base);\r\ngoto out_free_netdev;\r\n}\r\npriv->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "failed to get clk\n");\r\nret = -ENODEV;\r\ngoto out_free_netdev;\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret) {\r\ndev_err(dev, "failed to enable clk %d\n", ret);\r\ngoto out_free_netdev;\r\n}\r\npriv->mac_rst = devm_reset_control_get(dev, "mac");\r\nif (IS_ERR(priv->mac_rst)) {\r\nret = PTR_ERR(priv->mac_rst);\r\ngoto out_disable_clk;\r\n}\r\nhisi_femac_core_reset(priv);\r\npriv->phy_rst = devm_reset_control_get(dev, "phy");\r\nif (IS_ERR(priv->phy_rst)) {\r\npriv->phy_rst = NULL;\r\n} else {\r\nret = of_property_read_u32_array(node,\r\nPHY_RESET_DELAYS_PROPERTY,\r\npriv->phy_reset_delays,\r\nDELAYS_NUM);\r\nif (ret)\r\ngoto out_disable_clk;\r\nhisi_femac_phy_reset(priv);\r\n}\r\nphy = of_phy_get_and_connect(ndev, node, hisi_femac_adjust_link);\r\nif (!phy) {\r\ndev_err(dev, "connect to PHY failed!\n");\r\nret = -ENODEV;\r\ngoto out_disable_clk;\r\n}\r\nphy_attached_print(phy, "phy_id=0x%.8lx, phy_mode=%s\n",\r\n(unsigned long)phy->phy_id,\r\nphy_modes(phy->interface));\r\nmac_addr = of_get_mac_address(node);\r\nif (mac_addr)\r\nether_addr_copy(ndev->dev_addr, mac_addr);\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\neth_hw_addr_random(ndev);\r\ndev_warn(dev, "using random MAC address %pM\n",\r\nndev->dev_addr);\r\n}\r\nndev->watchdog_timeo = 6 * HZ;\r\nndev->priv_flags |= IFF_UNICAST_FLT;\r\nndev->netdev_ops = &hisi_femac_netdev_ops;\r\nndev->ethtool_ops = &hisi_femac_ethtools_ops;\r\nnetif_napi_add(ndev, &priv->napi, hisi_femac_poll, FEMAC_POLL_WEIGHT);\r\nhisi_femac_port_init(priv);\r\nret = hisi_femac_init_tx_and_rx_queues(priv);\r\nif (ret)\r\ngoto out_disconnect_phy;\r\nndev->irq = platform_get_irq(pdev, 0);\r\nif (ndev->irq <= 0) {\r\ndev_err(dev, "No irq resource\n");\r\nret = -ENODEV;\r\ngoto out_disconnect_phy;\r\n}\r\nret = devm_request_irq(dev, ndev->irq, hisi_femac_interrupt,\r\nIRQF_SHARED, pdev->name, ndev);\r\nif (ret) {\r\ndev_err(dev, "devm_request_irq %d failed!\n", ndev->irq);\r\ngoto out_disconnect_phy;\r\n}\r\nret = register_netdev(ndev);\r\nif (ret) {\r\ndev_err(dev, "register_netdev failed!\n");\r\ngoto out_disconnect_phy;\r\n}\r\nreturn ret;\r\nout_disconnect_phy:\r\nnetif_napi_del(&priv->napi);\r\nphy_disconnect(phy);\r\nout_disable_clk:\r\nclk_disable_unprepare(priv->clk);\r\nout_free_netdev:\r\nfree_netdev(ndev);\r\nreturn ret;\r\n}\r\nstatic int hisi_femac_drv_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct hisi_femac_priv *priv = netdev_priv(ndev);\r\nnetif_napi_del(&priv->napi);\r\nunregister_netdev(ndev);\r\nphy_disconnect(ndev->phydev);\r\nclk_disable_unprepare(priv->clk);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int hisi_femac_drv_suspend(struct platform_device *pdev,\r\npm_message_t state)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct hisi_femac_priv *priv = netdev_priv(ndev);\r\ndisable_irq(ndev->irq);\r\nif (netif_running(ndev)) {\r\nhisi_femac_net_close(ndev);\r\nnetif_device_detach(ndev);\r\n}\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}\r\nstatic int hisi_femac_drv_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct hisi_femac_priv *priv = netdev_priv(ndev);\r\nclk_prepare_enable(priv->clk);\r\nif (priv->phy_rst)\r\nhisi_femac_phy_reset(priv);\r\nif (netif_running(ndev)) {\r\nhisi_femac_port_init(priv);\r\nhisi_femac_net_open(ndev);\r\nnetif_device_attach(ndev);\r\n}\r\nenable_irq(ndev->irq);\r\nreturn 0;\r\n}
