static int ssb_pcmcia_cfg_write(struct ssb_bus *bus, u8 offset, u8 value)\r\n{\r\nint res;\r\nres = pcmcia_write_config_byte(bus->host_pcmcia, offset, value);\r\nif (unlikely(res != 0))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nstatic int ssb_pcmcia_cfg_read(struct ssb_bus *bus, u8 offset, u8 *value)\r\n{\r\nint res;\r\nres = pcmcia_read_config_byte(bus->host_pcmcia, offset, value);\r\nif (unlikely(res != 0))\r\nreturn -EBUSY;\r\nreturn 0;\r\n}\r\nint ssb_pcmcia_switch_coreidx(struct ssb_bus *bus,\r\nu8 coreidx)\r\n{\r\nint err;\r\nint attempts = 0;\r\nu32 cur_core;\r\nu32 addr;\r\nu32 read_addr;\r\nu8 val;\r\naddr = (coreidx * SSB_CORE_SIZE) + SSB_ENUM_BASE;\r\nwhile (1) {\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_ADDRESS0,\r\n(addr & 0x0000F000) >> 12);\r\nif (err)\r\ngoto error;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_ADDRESS1,\r\n(addr & 0x00FF0000) >> 16);\r\nif (err)\r\ngoto error;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_ADDRESS2,\r\n(addr & 0xFF000000) >> 24);\r\nif (err)\r\ngoto error;\r\nread_addr = 0;\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_ADDRESS0, &val);\r\nif (err)\r\ngoto error;\r\nread_addr |= ((u32)(val & 0x0F)) << 12;\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_ADDRESS1, &val);\r\nif (err)\r\ngoto error;\r\nread_addr |= ((u32)val) << 16;\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_ADDRESS2, &val);\r\nif (err)\r\ngoto error;\r\nread_addr |= ((u32)val) << 24;\r\ncur_core = (read_addr - SSB_ENUM_BASE) / SSB_CORE_SIZE;\r\nif (cur_core == coreidx)\r\nbreak;\r\nerr = -ETIMEDOUT;\r\nif (attempts++ > SSB_BAR0_MAX_RETRIES)\r\ngoto error;\r\nudelay(10);\r\n}\r\nreturn 0;\r\nerror:\r\nssb_err("Failed to switch to core %u\n", coreidx);\r\nreturn err;\r\n}\r\nstatic int ssb_pcmcia_switch_core(struct ssb_bus *bus, struct ssb_device *dev)\r\n{\r\nint err;\r\n#if SSB_VERBOSE_PCMCIACORESWITCH_DEBUG\r\nssb_info("Switching to %s core, index %d\n",\r\nssb_core_name(dev->id.coreid),\r\ndev->core_index);\r\n#endif\r\nerr = ssb_pcmcia_switch_coreidx(bus, dev->core_index);\r\nif (!err)\r\nbus->mapped_device = dev;\r\nreturn err;\r\n}\r\nint ssb_pcmcia_switch_segment(struct ssb_bus *bus, u8 seg)\r\n{\r\nint attempts = 0;\r\nint err;\r\nu8 val;\r\nSSB_WARN_ON((seg != 0) && (seg != 1));\r\nwhile (1) {\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_MEMSEG, seg);\r\nif (err)\r\ngoto error;\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_MEMSEG, &val);\r\nif (err)\r\ngoto error;\r\nif (val == seg)\r\nbreak;\r\nerr = -ETIMEDOUT;\r\nif (unlikely(attempts++ > SSB_BAR0_MAX_RETRIES))\r\ngoto error;\r\nudelay(10);\r\n}\r\nbus->mapped_pcmcia_seg = seg;\r\nreturn 0;\r\nerror:\r\nssb_err("Failed to switch pcmcia segment\n");\r\nreturn err;\r\n}\r\nstatic int select_core_and_segment(struct ssb_device *dev,\r\nu16 *offset)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nint err;\r\nu8 need_segment;\r\nif (*offset >= 0x800) {\r\n*offset -= 0x800;\r\nneed_segment = 1;\r\n} else\r\nneed_segment = 0;\r\nif (unlikely(dev != bus->mapped_device)) {\r\nerr = ssb_pcmcia_switch_core(bus, dev);\r\nif (unlikely(err))\r\nreturn err;\r\n}\r\nif (unlikely(need_segment != bus->mapped_pcmcia_seg)) {\r\nerr = ssb_pcmcia_switch_segment(bus, need_segment);\r\nif (unlikely(err))\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 ssb_pcmcia_read8(struct ssb_device *dev, u16 offset)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nint err;\r\nu8 value = 0xFF;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (likely(!err))\r\nvalue = readb(bus->mmio + offset);\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\nreturn value;\r\n}\r\nstatic u16 ssb_pcmcia_read16(struct ssb_device *dev, u16 offset)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nint err;\r\nu16 value = 0xFFFF;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (likely(!err))\r\nvalue = readw(bus->mmio + offset);\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\nreturn value;\r\n}\r\nstatic u32 ssb_pcmcia_read32(struct ssb_device *dev, u16 offset)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nint err;\r\nu32 lo = 0xFFFFFFFF, hi = 0xFFFFFFFF;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (likely(!err)) {\r\nlo = readw(bus->mmio + offset);\r\nhi = readw(bus->mmio + offset + 2);\r\n}\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\nreturn (lo | (hi << 16));\r\n}\r\nstatic void ssb_pcmcia_block_read(struct ssb_device *dev, void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nvoid __iomem *addr = bus->mmio + offset;\r\nint err;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (unlikely(err)) {\r\nmemset(buffer, 0xFF, count);\r\ngoto unlock;\r\n}\r\nswitch (reg_width) {\r\ncase sizeof(u8): {\r\nu8 *buf = buffer;\r\nwhile (count) {\r\n*buf = __raw_readb(addr);\r\nbuf++;\r\ncount--;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u16): {\r\n__le16 *buf = buffer;\r\nSSB_WARN_ON(count & 1);\r\nwhile (count) {\r\n*buf = (__force __le16)__raw_readw(addr);\r\nbuf++;\r\ncount -= 2;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u32): {\r\n__le16 *buf = buffer;\r\nSSB_WARN_ON(count & 3);\r\nwhile (count) {\r\n*buf = (__force __le16)__raw_readw(addr);\r\nbuf++;\r\n*buf = (__force __le16)__raw_readw(addr + 2);\r\nbuf++;\r\ncount -= 4;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nSSB_WARN_ON(1);\r\n}\r\nunlock:\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\n}\r\nstatic void ssb_pcmcia_write8(struct ssb_device *dev, u16 offset, u8 value)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (likely(!err))\r\nwriteb(value, bus->mmio + offset);\r\nmmiowb();\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\n}\r\nstatic void ssb_pcmcia_write16(struct ssb_device *dev, u16 offset, u16 value)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (likely(!err))\r\nwritew(value, bus->mmio + offset);\r\nmmiowb();\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\n}\r\nstatic void ssb_pcmcia_write32(struct ssb_device *dev, u16 offset, u32 value)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nint err;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (likely(!err)) {\r\nwritew((value & 0x0000FFFF), bus->mmio + offset);\r\nwritew(((value & 0xFFFF0000) >> 16), bus->mmio + offset + 2);\r\n}\r\nmmiowb();\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\n}\r\nstatic void ssb_pcmcia_block_write(struct ssb_device *dev, const void *buffer,\r\nsize_t count, u16 offset, u8 reg_width)\r\n{\r\nstruct ssb_bus *bus = dev->bus;\r\nunsigned long flags;\r\nvoid __iomem *addr = bus->mmio + offset;\r\nint err;\r\nspin_lock_irqsave(&bus->bar_lock, flags);\r\nerr = select_core_and_segment(dev, &offset);\r\nif (unlikely(err))\r\ngoto unlock;\r\nswitch (reg_width) {\r\ncase sizeof(u8): {\r\nconst u8 *buf = buffer;\r\nwhile (count) {\r\n__raw_writeb(*buf, addr);\r\nbuf++;\r\ncount--;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u16): {\r\nconst __le16 *buf = buffer;\r\nSSB_WARN_ON(count & 1);\r\nwhile (count) {\r\n__raw_writew((__force u16)(*buf), addr);\r\nbuf++;\r\ncount -= 2;\r\n}\r\nbreak;\r\n}\r\ncase sizeof(u32): {\r\nconst __le16 *buf = buffer;\r\nSSB_WARN_ON(count & 3);\r\nwhile (count) {\r\n__raw_writew((__force u16)(*buf), addr);\r\nbuf++;\r\n__raw_writew((__force u16)(*buf), addr + 2);\r\nbuf++;\r\ncount -= 4;\r\n}\r\nbreak;\r\n}\r\ndefault:\r\nSSB_WARN_ON(1);\r\n}\r\nunlock:\r\nmmiowb();\r\nspin_unlock_irqrestore(&bus->bar_lock, flags);\r\n}\r\nstatic int ssb_pcmcia_sprom_command(struct ssb_bus *bus, u8 command)\r\n{\r\nunsigned int i;\r\nint err;\r\nu8 value;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROMCTL, command);\r\nif (err)\r\nreturn err;\r\nfor (i = 0; i < 1000; i++) {\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROMCTL, &value);\r\nif (err)\r\nreturn err;\r\nif (value & SSB_PCMCIA_SPROMCTL_DONE)\r\nreturn 0;\r\nudelay(10);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ssb_pcmcia_sprom_read(struct ssb_bus *bus, u16 offset, u16 *value)\r\n{\r\nint err;\r\nu8 lo, hi;\r\noffset *= 2;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRLO,\r\n(offset & 0x00FF));\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRHI,\r\n(offset & 0xFF00) >> 8);\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_READ);\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROM_DATALO, &lo);\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cfg_read(bus, SSB_PCMCIA_SPROM_DATAHI, &hi);\r\nif (err)\r\nreturn err;\r\n*value = (lo | (((u16)hi) << 8));\r\nreturn 0;\r\n}\r\nstatic int ssb_pcmcia_sprom_write(struct ssb_bus *bus, u16 offset, u16 value)\r\n{\r\nint err;\r\noffset *= 2;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRLO,\r\n(offset & 0x00FF));\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_ADDRHI,\r\n(offset & 0xFF00) >> 8);\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_DATALO,\r\n(value & 0x00FF));\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cfg_write(bus, SSB_PCMCIA_SPROM_DATAHI,\r\n(value & 0xFF00) >> 8);\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_WRITE);\r\nif (err)\r\nreturn err;\r\nmsleep(20);\r\nreturn 0;\r\n}\r\nstatic int ssb_pcmcia_sprom_read_all(struct ssb_bus *bus, u16 *sprom)\r\n{\r\nint err, i;\r\nfor (i = 0; i < SSB_PCMCIA_SPROM_SIZE; i++) {\r\nerr = ssb_pcmcia_sprom_read(bus, i, &sprom[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ssb_pcmcia_sprom_write_all(struct ssb_bus *bus, const u16 *sprom)\r\n{\r\nint i, err;\r\nbool failed = 0;\r\nsize_t size = SSB_PCMCIA_SPROM_SIZE;\r\nssb_notice("Writing SPROM. Do NOT turn off the power! Please stand by...\n");\r\nerr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_WRITEEN);\r\nif (err) {\r\nssb_notice("Could not enable SPROM write access\n");\r\nreturn -EBUSY;\r\n}\r\nssb_notice("[ 0%%");\r\nmsleep(500);\r\nfor (i = 0; i < size; i++) {\r\nif (i == size / 4)\r\nssb_cont("25%%");\r\nelse if (i == size / 2)\r\nssb_cont("50%%");\r\nelse if (i == (size * 3) / 4)\r\nssb_cont("75%%");\r\nelse if (i % 2)\r\nssb_cont(".");\r\nerr = ssb_pcmcia_sprom_write(bus, i, sprom[i]);\r\nif (err) {\r\nssb_notice("Failed to write to SPROM\n");\r\nfailed = 1;\r\nbreak;\r\n}\r\n}\r\nerr = ssb_pcmcia_sprom_command(bus, SSB_PCMCIA_SPROMCTL_WRITEDIS);\r\nif (err) {\r\nssb_notice("Could not disable SPROM write access\n");\r\nfailed = 1;\r\n}\r\nmsleep(500);\r\nif (!failed) {\r\nssb_cont("100%% ]\n");\r\nssb_notice("SPROM written\n");\r\n}\r\nreturn failed ? -EBUSY : 0;\r\n}\r\nstatic int ssb_pcmcia_sprom_check_crc(const u16 *sprom, size_t size)\r\n{\r\nreturn 0;\r\n}\r\nstatic int ssb_pcmcia_get_mac(struct pcmcia_device *p_dev,\r\ntuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct ssb_sprom *sprom = priv;\r\nif (tuple->TupleData[0] != CISTPL_FUNCE_LAN_NODE_ID)\r\nreturn -EINVAL;\r\nif (tuple->TupleDataLen != ETH_ALEN + 2)\r\nreturn -EINVAL;\r\nif (tuple->TupleData[1] != ETH_ALEN)\r\nreturn -EINVAL;\r\nmemcpy(sprom->il0mac, &tuple->TupleData[2], ETH_ALEN);\r\nreturn 0;\r\n}\r\nstatic int ssb_pcmcia_do_get_invariants(struct pcmcia_device *p_dev,\r\ntuple_t *tuple,\r\nvoid *priv)\r\n{\r\nstruct ssb_init_invariants *iv = priv;\r\nstruct ssb_sprom *sprom = &iv->sprom;\r\nstruct ssb_boardinfo *bi = &iv->boardinfo;\r\nconst char *error_description;\r\nGOTO_ERROR_ON(tuple->TupleDataLen < 1, "VEN tpl < 1");\r\nswitch (tuple->TupleData[0]) {\r\ncase SSB_PCMCIA_CIS_ID:\r\nGOTO_ERROR_ON((tuple->TupleDataLen != 5) &&\r\n(tuple->TupleDataLen != 7),\r\n"id tpl size");\r\nbi->vendor = tuple->TupleData[1] |\r\n((u16)tuple->TupleData[2] << 8);\r\nbreak;\r\ncase SSB_PCMCIA_CIS_BOARDREV:\r\nGOTO_ERROR_ON(tuple->TupleDataLen != 2,\r\n"boardrev tpl size");\r\nsprom->board_rev = tuple->TupleData[1];\r\nbreak;\r\ncase SSB_PCMCIA_CIS_PA:\r\nGOTO_ERROR_ON((tuple->TupleDataLen != 9) &&\r\n(tuple->TupleDataLen != 10),\r\n"pa tpl size");\r\nsprom->pa0b0 = tuple->TupleData[1] |\r\n((u16)tuple->TupleData[2] << 8);\r\nsprom->pa0b1 = tuple->TupleData[3] |\r\n((u16)tuple->TupleData[4] << 8);\r\nsprom->pa0b2 = tuple->TupleData[5] |\r\n((u16)tuple->TupleData[6] << 8);\r\nsprom->itssi_a = tuple->TupleData[7];\r\nsprom->itssi_bg = tuple->TupleData[7];\r\nsprom->maxpwr_a = tuple->TupleData[8];\r\nsprom->maxpwr_bg = tuple->TupleData[8];\r\nbreak;\r\ncase SSB_PCMCIA_CIS_OEMNAME:\r\nbreak;\r\ncase SSB_PCMCIA_CIS_CCODE:\r\nGOTO_ERROR_ON(tuple->TupleDataLen != 2,\r\n"ccode tpl size");\r\nsprom->country_code = tuple->TupleData[1];\r\nbreak;\r\ncase SSB_PCMCIA_CIS_ANTENNA:\r\nGOTO_ERROR_ON(tuple->TupleDataLen != 2,\r\n"ant tpl size");\r\nsprom->ant_available_a = tuple->TupleData[1];\r\nsprom->ant_available_bg = tuple->TupleData[1];\r\nbreak;\r\ncase SSB_PCMCIA_CIS_ANTGAIN:\r\nGOTO_ERROR_ON(tuple->TupleDataLen != 2,\r\n"antg tpl size");\r\nsprom->antenna_gain.a0 = tuple->TupleData[1];\r\nsprom->antenna_gain.a1 = tuple->TupleData[1];\r\nsprom->antenna_gain.a2 = tuple->TupleData[1];\r\nsprom->antenna_gain.a3 = tuple->TupleData[1];\r\nbreak;\r\ncase SSB_PCMCIA_CIS_BFLAGS:\r\nGOTO_ERROR_ON((tuple->TupleDataLen != 3) &&\r\n(tuple->TupleDataLen != 5),\r\n"bfl tpl size");\r\nsprom->boardflags_lo = tuple->TupleData[1] |\r\n((u16)tuple->TupleData[2] << 8);\r\nbreak;\r\ncase SSB_PCMCIA_CIS_LEDS:\r\nGOTO_ERROR_ON(tuple->TupleDataLen != 5,\r\n"leds tpl size");\r\nsprom->gpio0 = tuple->TupleData[1];\r\nsprom->gpio1 = tuple->TupleData[2];\r\nsprom->gpio2 = tuple->TupleData[3];\r\nsprom->gpio3 = tuple->TupleData[4];\r\nbreak;\r\n}\r\nreturn -ENOSPC;\r\nerror:\r\nssb_err(\r\n"PCMCIA: Failed to fetch device invariants: %s\n",\r\nerror_description);\r\nreturn -ENODEV;\r\n}\r\nint ssb_pcmcia_get_invariants(struct ssb_bus *bus,\r\nstruct ssb_init_invariants *iv)\r\n{\r\nstruct ssb_sprom *sprom = &iv->sprom;\r\nint res;\r\nmemset(sprom, 0xFF, sizeof(*sprom));\r\nsprom->revision = 1;\r\nsprom->boardflags_lo = 0;\r\nsprom->boardflags_hi = 0;\r\nres = pcmcia_loop_tuple(bus->host_pcmcia, CISTPL_FUNCE,\r\nssb_pcmcia_get_mac, sprom);\r\nif (res != 0) {\r\nssb_err(\r\n"PCMCIA: Failed to fetch MAC address\n");\r\nreturn -ENODEV;\r\n}\r\nres = pcmcia_loop_tuple(bus->host_pcmcia, SSB_PCMCIA_CIS,\r\nssb_pcmcia_do_get_invariants, iv);\r\nif ((res == 0) || (res == -ENOSPC))\r\nreturn 0;\r\nssb_err(\r\n"PCMCIA: Failed to fetch device invariants\n");\r\nreturn -ENODEV;\r\n}\r\nstatic ssize_t ssb_pcmcia_attr_sprom_show(struct device *pcmciadev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pcmcia_device *pdev =\r\ncontainer_of(pcmciadev, struct pcmcia_device, dev);\r\nstruct ssb_bus *bus;\r\nbus = ssb_pcmcia_dev_to_bus(pdev);\r\nif (!bus)\r\nreturn -ENODEV;\r\nreturn ssb_attr_sprom_show(bus, buf,\r\nssb_pcmcia_sprom_read_all);\r\n}\r\nstatic ssize_t ssb_pcmcia_attr_sprom_store(struct device *pcmciadev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pcmcia_device *pdev =\r\ncontainer_of(pcmciadev, struct pcmcia_device, dev);\r\nstruct ssb_bus *bus;\r\nbus = ssb_pcmcia_dev_to_bus(pdev);\r\nif (!bus)\r\nreturn -ENODEV;\r\nreturn ssb_attr_sprom_store(bus, buf, count,\r\nssb_pcmcia_sprom_check_crc,\r\nssb_pcmcia_sprom_write_all);\r\n}\r\nstatic int ssb_pcmcia_cor_setup(struct ssb_bus *bus, u8 cor)\r\n{\r\nu8 val;\r\nint err;\r\nerr = ssb_pcmcia_cfg_read(bus, cor, &val);\r\nif (err)\r\nreturn err;\r\nval &= ~COR_SOFT_RESET;\r\nval |= COR_FUNC_ENA | COR_IREQ_ENA | COR_LEVEL_REQ;\r\nerr = ssb_pcmcia_cfg_write(bus, cor, val);\r\nif (err)\r\nreturn err;\r\nmsleep(40);\r\nreturn 0;\r\n}\r\nint ssb_pcmcia_hardware_setup(struct ssb_bus *bus)\r\n{\r\nint err;\r\nif (bus->bustype != SSB_BUSTYPE_PCMCIA)\r\nreturn 0;\r\nssb_pcmcia_switch_segment(bus, 0);\r\nerr = ssb_pcmcia_cor_setup(bus, CISREG_COR);\r\nif (err)\r\nreturn err;\r\nerr = ssb_pcmcia_cor_setup(bus, CISREG_COR + 0x80);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nvoid ssb_pcmcia_exit(struct ssb_bus *bus)\r\n{\r\nif (bus->bustype != SSB_BUSTYPE_PCMCIA)\r\nreturn;\r\ndevice_remove_file(&bus->host_pcmcia->dev, &dev_attr_ssb_sprom);\r\n}\r\nint ssb_pcmcia_init(struct ssb_bus *bus)\r\n{\r\nint err;\r\nif (bus->bustype != SSB_BUSTYPE_PCMCIA)\r\nreturn 0;\r\nerr = ssb_pcmcia_hardware_setup(bus);\r\nif (err)\r\ngoto error;\r\nbus->sprom_size = SSB_PCMCIA_SPROM_SIZE;\r\nmutex_init(&bus->sprom_mutex);\r\nerr = device_create_file(&bus->host_pcmcia->dev, &dev_attr_ssb_sprom);\r\nif (err)\r\ngoto error;\r\nreturn 0;\r\nerror:\r\nssb_err("Failed to initialize PCMCIA host device\n");\r\nreturn err;\r\n}
