static int mspro_block_bd_open(struct block_device *bdev, fmode_t mode)\r\n{\r\nstruct gendisk *disk = bdev->bd_disk;\r\nstruct mspro_block_data *msb = disk->private_data;\r\nint rc = -ENXIO;\r\nmutex_lock(&mspro_block_disk_lock);\r\nif (msb && msb->card) {\r\nmsb->usage_count++;\r\nif ((mode & FMODE_WRITE) && msb->read_only)\r\nrc = -EROFS;\r\nelse\r\nrc = 0;\r\n}\r\nmutex_unlock(&mspro_block_disk_lock);\r\nreturn rc;\r\n}\r\nstatic void mspro_block_disk_release(struct gendisk *disk)\r\n{\r\nstruct mspro_block_data *msb = disk->private_data;\r\nint disk_id = MINOR(disk_devt(disk)) >> MSPRO_BLOCK_PART_SHIFT;\r\nmutex_lock(&mspro_block_disk_lock);\r\nif (msb) {\r\nif (msb->usage_count)\r\nmsb->usage_count--;\r\nif (!msb->usage_count) {\r\nkfree(msb);\r\ndisk->private_data = NULL;\r\nidr_remove(&mspro_block_disk_idr, disk_id);\r\nput_disk(disk);\r\n}\r\n}\r\nmutex_unlock(&mspro_block_disk_lock);\r\n}\r\nstatic void mspro_block_bd_release(struct gendisk *disk, fmode_t mode)\r\n{\r\nmspro_block_disk_release(disk);\r\n}\r\nstatic int mspro_block_bd_getgeo(struct block_device *bdev,\r\nstruct hd_geometry *geo)\r\n{\r\nstruct mspro_block_data *msb = bdev->bd_disk->private_data;\r\ngeo->heads = msb->heads;\r\ngeo->sectors = msb->sectors_per_track;\r\ngeo->cylinders = msb->cylinders;\r\nreturn 0;\r\n}\r\nstatic struct mspro_sys_attr *mspro_from_sysfs_attr(struct attribute *attr)\r\n{\r\nstruct device_attribute *dev_attr\r\n= container_of(attr, struct device_attribute, attr);\r\nreturn container_of(dev_attr, struct mspro_sys_attr, dev_attr);\r\n}\r\nstatic const char *mspro_block_attr_name(unsigned char tag)\r\n{\r\nswitch (tag) {\r\ncase MSPRO_BLOCK_ID_SYSINFO:\r\nreturn "attr_sysinfo";\r\ncase MSPRO_BLOCK_ID_MODELNAME:\r\nreturn "attr_modelname";\r\ncase MSPRO_BLOCK_ID_MBR:\r\nreturn "attr_mbr";\r\ncase MSPRO_BLOCK_ID_PBR16:\r\nreturn "attr_pbr16";\r\ncase MSPRO_BLOCK_ID_PBR32:\r\nreturn "attr_pbr32";\r\ncase MSPRO_BLOCK_ID_SPECFILEVALUES1:\r\nreturn "attr_specfilevalues1";\r\ncase MSPRO_BLOCK_ID_SPECFILEVALUES2:\r\nreturn "attr_specfilevalues2";\r\ncase MSPRO_BLOCK_ID_DEVINFO:\r\nreturn "attr_devinfo";\r\ndefault:\r\nreturn NULL;\r\n};\r\n}\r\nstatic ssize_t mspro_block_attr_show_default(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mspro_sys_attr *s_attr = container_of(attr,\r\nstruct mspro_sys_attr,\r\ndev_attr);\r\nssize_t cnt, rc = 0;\r\nfor (cnt = 0; cnt < s_attr->size; cnt++) {\r\nif (cnt && !(cnt % 16)) {\r\nif (PAGE_SIZE - rc)\r\nbuffer[rc++] = '\n';\r\n}\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "%02x ",\r\n((unsigned char *)s_attr->data)[cnt]);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t mspro_block_attr_show_sysinfo(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mspro_sys_attr *x_attr = container_of(attr,\r\nstruct mspro_sys_attr,\r\ndev_attr);\r\nstruct mspro_sys_info *x_sys = x_attr->data;\r\nssize_t rc = 0;\r\nint date_tz = 0, date_tz_f = 0;\r\nif (x_sys->assembly_date[0] > 0x80U) {\r\ndate_tz = (~x_sys->assembly_date[0]) + 1;\r\ndate_tz_f = date_tz & 3;\r\ndate_tz >>= 2;\r\ndate_tz = -date_tz;\r\ndate_tz_f *= 15;\r\n} else if (x_sys->assembly_date[0] < 0x80U) {\r\ndate_tz = x_sys->assembly_date[0];\r\ndate_tz_f = date_tz & 3;\r\ndate_tz >>= 2;\r\ndate_tz_f *= 15;\r\n}\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "class: %x\n",\r\nx_sys->class);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "block size: %x\n",\r\nbe16_to_cpu(x_sys->block_size));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "block count: %x\n",\r\nbe16_to_cpu(x_sys->block_count));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "user block count: %x\n",\r\nbe16_to_cpu(x_sys->user_block_count));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "page size: %x\n",\r\nbe16_to_cpu(x_sys->page_size));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "assembly date: "\r\n"GMT%+d:%d %04u-%02u-%02u %02u:%02u:%02u\n",\r\ndate_tz, date_tz_f,\r\nbe16_to_cpup((__be16 *)&x_sys->assembly_date[1]),\r\nx_sys->assembly_date[3], x_sys->assembly_date[4],\r\nx_sys->assembly_date[5], x_sys->assembly_date[6],\r\nx_sys->assembly_date[7]);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "serial number: %x\n",\r\nbe32_to_cpu(x_sys->serial_number));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc,\r\n"assembly maker code: %x\n",\r\nx_sys->assembly_maker_code);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "assembly model code: "\r\n"%02x%02x%02x\n", x_sys->assembly_model_code[0],\r\nx_sys->assembly_model_code[1],\r\nx_sys->assembly_model_code[2]);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "memory maker code: %x\n",\r\nbe16_to_cpu(x_sys->memory_maker_code));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "memory model code: %x\n",\r\nbe16_to_cpu(x_sys->memory_model_code));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "vcc: %x\n",\r\nx_sys->vcc);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "vpp: %x\n",\r\nx_sys->vpp);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "controller number: %x\n",\r\nbe16_to_cpu(x_sys->controller_number));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc,\r\n"controller function: %x\n",\r\nbe16_to_cpu(x_sys->controller_function));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "start sector: %x\n",\r\nbe16_to_cpu(x_sys->start_sector));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "unit size: %x\n",\r\nbe16_to_cpu(x_sys->unit_size));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "sub class: %x\n",\r\nx_sys->ms_sub_class);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "interface type: %x\n",\r\nx_sys->interface_type);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "controller code: %x\n",\r\nbe16_to_cpu(x_sys->controller_code));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "format type: %x\n",\r\nx_sys->format_type);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "device type: %x\n",\r\nx_sys->device_type);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "mspro id: %s\n",\r\nx_sys->mspro_id);\r\nreturn rc;\r\n}\r\nstatic ssize_t mspro_block_attr_show_modelname(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mspro_sys_attr *s_attr = container_of(attr,\r\nstruct mspro_sys_attr,\r\ndev_attr);\r\nreturn scnprintf(buffer, PAGE_SIZE, "%s", (char *)s_attr->data);\r\n}\r\nstatic ssize_t mspro_block_attr_show_mbr(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mspro_sys_attr *x_attr = container_of(attr,\r\nstruct mspro_sys_attr,\r\ndev_attr);\r\nstruct mspro_mbr *x_mbr = x_attr->data;\r\nssize_t rc = 0;\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "boot partition: %x\n",\r\nx_mbr->boot_partition);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "start head: %x\n",\r\nx_mbr->start_head);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "start sector: %x\n",\r\nx_mbr->start_sector);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "start cylinder: %x\n",\r\nx_mbr->start_cylinder);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "partition type: %x\n",\r\nx_mbr->partition_type);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "end head: %x\n",\r\nx_mbr->end_head);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "end sector: %x\n",\r\nx_mbr->end_sector);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "end cylinder: %x\n",\r\nx_mbr->end_cylinder);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "start sectors: %x\n",\r\nx_mbr->start_sectors);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc,\r\n"sectors per partition: %x\n",\r\nx_mbr->sectors_per_partition);\r\nreturn rc;\r\n}\r\nstatic ssize_t mspro_block_attr_show_specfile(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mspro_sys_attr *x_attr = container_of(attr,\r\nstruct mspro_sys_attr,\r\ndev_attr);\r\nstruct mspro_specfile *x_spfile = x_attr->data;\r\nchar name[9], ext[4];\r\nssize_t rc = 0;\r\nmemcpy(name, x_spfile->name, 8);\r\nname[8] = 0;\r\nmemcpy(ext, x_spfile->ext, 3);\r\next[3] = 0;\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "name: %s\n", name);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "ext: %s\n", ext);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "attribute: %x\n",\r\nx_spfile->attr);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "time: %d:%d:%d\n",\r\nx_spfile->time >> 11,\r\n(x_spfile->time >> 5) & 0x3f,\r\n(x_spfile->time & 0x1f) * 2);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "date: %d-%d-%d\n",\r\n(x_spfile->date >> 9) + 1980,\r\n(x_spfile->date >> 5) & 0xf,\r\nx_spfile->date & 0x1f);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "start cluster: %x\n",\r\nx_spfile->cluster);\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "size: %x\n",\r\nx_spfile->size);\r\nreturn rc;\r\n}\r\nstatic ssize_t mspro_block_attr_show_devinfo(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buffer)\r\n{\r\nstruct mspro_sys_attr *x_attr = container_of(attr,\r\nstruct mspro_sys_attr,\r\ndev_attr);\r\nstruct mspro_devinfo *x_devinfo = x_attr->data;\r\nssize_t rc = 0;\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "cylinders: %x\n",\r\nbe16_to_cpu(x_devinfo->cylinders));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "heads: %x\n",\r\nbe16_to_cpu(x_devinfo->heads));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "bytes per track: %x\n",\r\nbe16_to_cpu(x_devinfo->bytes_per_track));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "bytes per sector: %x\n",\r\nbe16_to_cpu(x_devinfo->bytes_per_sector));\r\nrc += scnprintf(buffer + rc, PAGE_SIZE - rc, "sectors per track: %x\n",\r\nbe16_to_cpu(x_devinfo->sectors_per_track));\r\nreturn rc;\r\n}\r\nstatic sysfs_show_t mspro_block_attr_show(unsigned char tag)\r\n{\r\nswitch (tag) {\r\ncase MSPRO_BLOCK_ID_SYSINFO:\r\nreturn mspro_block_attr_show_sysinfo;\r\ncase MSPRO_BLOCK_ID_MODELNAME:\r\nreturn mspro_block_attr_show_modelname;\r\ncase MSPRO_BLOCK_ID_MBR:\r\nreturn mspro_block_attr_show_mbr;\r\ncase MSPRO_BLOCK_ID_SPECFILEVALUES1:\r\ncase MSPRO_BLOCK_ID_SPECFILEVALUES2:\r\nreturn mspro_block_attr_show_specfile;\r\ncase MSPRO_BLOCK_ID_DEVINFO:\r\nreturn mspro_block_attr_show_devinfo;\r\ndefault:\r\nreturn mspro_block_attr_show_default;\r\n}\r\n}\r\nstatic int h_mspro_block_req_init(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\n*mrq = &card->current_mrq;\r\ncard->next_request = msb->mrq_handler;\r\nreturn 0;\r\n}\r\nstatic int h_mspro_block_default(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nreturn mspro_block_complete_req(card, (*mrq)->error);\r\n}\r\nstatic int h_mspro_block_default_bad(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nreturn -ENXIO;\r\n}\r\nstatic int h_mspro_block_get_ro(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nif (!(*mrq)->error) {\r\nif ((*mrq)->data[offsetof(struct ms_status_register, status0)]\r\n& MEMSTICK_STATUS0_WP)\r\nmsb->read_only = 1;\r\nelse\r\nmsb->read_only = 0;\r\n}\r\nreturn mspro_block_complete_req(card, (*mrq)->error);\r\n}\r\nstatic int h_mspro_block_wait_for_ced(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\ndev_dbg(&card->dev, "wait for ced: value %x\n", (*mrq)->data[0]);\r\nif (!(*mrq)->error) {\r\nif ((*mrq)->data[0] & (MEMSTICK_INT_CMDNAK | MEMSTICK_INT_ERR))\r\n(*mrq)->error = -EFAULT;\r\nelse if (!((*mrq)->data[0] & MEMSTICK_INT_CED))\r\nreturn 0;\r\n}\r\nreturn mspro_block_complete_req(card, (*mrq)->error);\r\n}\r\nstatic int h_mspro_block_transfer_data(struct memstick_dev *card,\r\nstruct memstick_request **mrq)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nunsigned char t_val = 0;\r\nstruct scatterlist t_sg = { 0 };\r\nsize_t t_offset;\r\nif ((*mrq)->error)\r\nreturn mspro_block_complete_req(card, (*mrq)->error);\r\nswitch ((*mrq)->tpc) {\r\ncase MS_TPC_WRITE_REG:\r\nmemstick_init_req(*mrq, MS_TPC_SET_CMD, &msb->transfer_cmd, 1);\r\n(*mrq)->need_card_int = 1;\r\nreturn 0;\r\ncase MS_TPC_SET_CMD:\r\nt_val = (*mrq)->int_reg;\r\nmemstick_init_req(*mrq, MS_TPC_GET_INT, NULL, 1);\r\nif (msb->caps & MEMSTICK_CAP_AUTO_GET_INT)\r\ngoto has_int_reg;\r\nreturn 0;\r\ncase MS_TPC_GET_INT:\r\nt_val = (*mrq)->data[0];\r\nhas_int_reg:\r\nif (t_val & (MEMSTICK_INT_CMDNAK | MEMSTICK_INT_ERR)) {\r\nt_val = MSPRO_CMD_STOP;\r\nmemstick_init_req(*mrq, MS_TPC_SET_CMD, &t_val, 1);\r\ncard->next_request = h_mspro_block_default;\r\nreturn 0;\r\n}\r\nif (msb->current_page\r\n== (msb->req_sg[msb->current_seg].length\r\n/ msb->page_size)) {\r\nmsb->current_page = 0;\r\nmsb->current_seg++;\r\nif (msb->current_seg == msb->seg_count) {\r\nif (t_val & MEMSTICK_INT_CED) {\r\nreturn mspro_block_complete_req(card,\r\n0);\r\n} else {\r\ncard->next_request\r\n= h_mspro_block_wait_for_ced;\r\nmemstick_init_req(*mrq, MS_TPC_GET_INT,\r\nNULL, 1);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nif (!(t_val & MEMSTICK_INT_BREQ)) {\r\nmemstick_init_req(*mrq, MS_TPC_GET_INT, NULL, 1);\r\nreturn 0;\r\n}\r\nt_offset = msb->req_sg[msb->current_seg].offset;\r\nt_offset += msb->current_page * msb->page_size;\r\nsg_set_page(&t_sg,\r\nnth_page(sg_page(&(msb->req_sg[msb->current_seg])),\r\nt_offset >> PAGE_SHIFT),\r\nmsb->page_size, offset_in_page(t_offset));\r\nmemstick_init_req_sg(*mrq, msb->data_dir == READ\r\n? MS_TPC_READ_LONG_DATA\r\n: MS_TPC_WRITE_LONG_DATA,\r\n&t_sg);\r\n(*mrq)->need_card_int = 1;\r\nreturn 0;\r\ncase MS_TPC_READ_LONG_DATA:\r\ncase MS_TPC_WRITE_LONG_DATA:\r\nmsb->current_page++;\r\nif (msb->caps & MEMSTICK_CAP_AUTO_GET_INT) {\r\nt_val = (*mrq)->int_reg;\r\ngoto has_int_reg;\r\n} else {\r\nmemstick_init_req(*mrq, MS_TPC_GET_INT, NULL, 1);\r\nreturn 0;\r\n}\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic void h_mspro_block_setup_cmd(struct memstick_dev *card, u64 offset,\r\nsize_t length)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nstruct mspro_param_register param = {\r\n.system = msb->system,\r\n.data_count = cpu_to_be16((uint16_t)(length / msb->page_size)),\r\n.data_address = 0,\r\n.tpc_param = 0\r\n};\r\ndo_div(offset, msb->page_size);\r\nparam.data_address = cpu_to_be32((uint32_t)offset);\r\ncard->next_request = h_mspro_block_req_init;\r\nmsb->mrq_handler = h_mspro_block_transfer_data;\r\nmemstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG,\r\n&param, sizeof(param));\r\n}\r\nstatic int mspro_block_issue_req(struct memstick_dev *card, int chunk)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nu64 t_off;\r\nunsigned int count;\r\ntry_again:\r\nwhile (chunk) {\r\nmsb->current_page = 0;\r\nmsb->current_seg = 0;\r\nmsb->seg_count = blk_rq_map_sg(msb->block_req->q,\r\nmsb->block_req,\r\nmsb->req_sg);\r\nif (!msb->seg_count) {\r\nchunk = __blk_end_request_cur(msb->block_req, -ENOMEM);\r\ncontinue;\r\n}\r\nt_off = blk_rq_pos(msb->block_req);\r\nt_off <<= 9;\r\ncount = blk_rq_bytes(msb->block_req);\r\nmsb->setup_transfer(card, t_off, count);\r\nmsb->data_dir = rq_data_dir(msb->block_req);\r\nmsb->transfer_cmd = msb->data_dir == READ\r\n? MSPRO_CMD_READ_DATA\r\n: MSPRO_CMD_WRITE_DATA;\r\nmemstick_new_req(card->host);\r\nreturn 0;\r\n}\r\ndev_dbg(&card->dev, "blk_fetch\n");\r\nmsb->block_req = blk_fetch_request(msb->queue);\r\nif (!msb->block_req) {\r\ndev_dbg(&card->dev, "issue end\n");\r\nreturn -EAGAIN;\r\n}\r\ndev_dbg(&card->dev, "trying again\n");\r\nchunk = 1;\r\ngoto try_again;\r\n}\r\nstatic int mspro_block_complete_req(struct memstick_dev *card, int error)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nint chunk, cnt;\r\nunsigned int t_len = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&msb->q_lock, flags);\r\ndev_dbg(&card->dev, "complete %d, %d\n", msb->has_request ? 1 : 0,\r\nerror);\r\nif (msb->has_request) {\r\nif (error == -EAGAIN)\r\nerror = 0;\r\nif (error || (card->current_mrq.tpc == MSPRO_CMD_STOP)) {\r\nif (msb->data_dir == READ) {\r\nfor (cnt = 0; cnt < msb->current_seg; cnt++) {\r\nt_len += msb->req_sg[cnt].length\r\n/ msb->page_size;\r\nif (msb->current_page)\r\nt_len += msb->current_page - 1;\r\nt_len *= msb->page_size;\r\n}\r\n}\r\n} else\r\nt_len = blk_rq_bytes(msb->block_req);\r\ndev_dbg(&card->dev, "transferred %x (%d)\n", t_len, error);\r\nif (error && !t_len)\r\nt_len = blk_rq_cur_bytes(msb->block_req);\r\nchunk = __blk_end_request(msb->block_req, error, t_len);\r\nerror = mspro_block_issue_req(card, chunk);\r\nif (!error)\r\ngoto out;\r\nelse\r\nmsb->has_request = 0;\r\n} else {\r\nif (!error)\r\nerror = -EAGAIN;\r\n}\r\ncard->next_request = h_mspro_block_default_bad;\r\ncomplete_all(&card->mrq_complete);\r\nout:\r\nspin_unlock_irqrestore(&msb->q_lock, flags);\r\nreturn error;\r\n}\r\nstatic void mspro_block_stop(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nint rc = 0;\r\nunsigned long flags;\r\nwhile (1) {\r\nspin_lock_irqsave(&msb->q_lock, flags);\r\nif (!msb->has_request) {\r\nblk_stop_queue(msb->queue);\r\nrc = 1;\r\n}\r\nspin_unlock_irqrestore(&msb->q_lock, flags);\r\nif (rc)\r\nbreak;\r\nwait_for_completion(&card->mrq_complete);\r\n}\r\n}\r\nstatic void mspro_block_start(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nunsigned long flags;\r\nspin_lock_irqsave(&msb->q_lock, flags);\r\nblk_start_queue(msb->queue);\r\nspin_unlock_irqrestore(&msb->q_lock, flags);\r\n}\r\nstatic void mspro_block_submit_req(struct request_queue *q)\r\n{\r\nstruct memstick_dev *card = q->queuedata;\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nstruct request *req = NULL;\r\nif (msb->has_request)\r\nreturn;\r\nif (msb->eject) {\r\nwhile ((req = blk_fetch_request(q)) != NULL)\r\n__blk_end_request_all(req, -ENODEV);\r\nreturn;\r\n}\r\nmsb->has_request = 1;\r\nif (mspro_block_issue_req(card, 0))\r\nmsb->has_request = 0;\r\n}\r\nstatic int mspro_block_wait_for_ced(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\ncard->next_request = h_mspro_block_req_init;\r\nmsb->mrq_handler = h_mspro_block_wait_for_ced;\r\nmemstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);\r\nmemstick_new_req(card->host);\r\nwait_for_completion(&card->mrq_complete);\r\nreturn card->current_mrq.error;\r\n}\r\nstatic int mspro_block_set_interface(struct memstick_dev *card,\r\nunsigned char sys_reg)\r\n{\r\nstruct memstick_host *host = card->host;\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nstruct mspro_param_register param = {\r\n.system = sys_reg,\r\n.data_count = 0,\r\n.data_address = 0,\r\n.tpc_param = 0\r\n};\r\ncard->next_request = h_mspro_block_req_init;\r\nmsb->mrq_handler = h_mspro_block_default;\r\nmemstick_init_req(&card->current_mrq, MS_TPC_WRITE_REG, &param,\r\nsizeof(param));\r\nmemstick_new_req(host);\r\nwait_for_completion(&card->mrq_complete);\r\nreturn card->current_mrq.error;\r\n}\r\nstatic int mspro_block_switch_interface(struct memstick_dev *card)\r\n{\r\nstruct memstick_host *host = card->host;\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nint rc = 0;\r\ntry_again:\r\nif (msb->caps & MEMSTICK_CAP_PAR4)\r\nrc = mspro_block_set_interface(card, MEMSTICK_SYS_PAR4);\r\nelse\r\nreturn 0;\r\nif (rc) {\r\nprintk(KERN_WARNING\r\n"%s: could not switch to 4-bit mode, error %d\n",\r\ndev_name(&card->dev), rc);\r\nreturn 0;\r\n}\r\nmsb->system = MEMSTICK_SYS_PAR4;\r\nhost->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_PAR4);\r\nprintk(KERN_INFO "%s: switching to 4-bit parallel mode\n",\r\ndev_name(&card->dev));\r\nif (msb->caps & MEMSTICK_CAP_PAR8) {\r\nrc = mspro_block_set_interface(card, MEMSTICK_SYS_PAR8);\r\nif (!rc) {\r\nmsb->system = MEMSTICK_SYS_PAR8;\r\nhost->set_param(host, MEMSTICK_INTERFACE,\r\nMEMSTICK_PAR8);\r\nprintk(KERN_INFO\r\n"%s: switching to 8-bit parallel mode\n",\r\ndev_name(&card->dev));\r\n} else\r\nprintk(KERN_WARNING\r\n"%s: could not switch to 8-bit mode, error %d\n",\r\ndev_name(&card->dev), rc);\r\n}\r\ncard->next_request = h_mspro_block_req_init;\r\nmsb->mrq_handler = h_mspro_block_default;\r\nmemstick_init_req(&card->current_mrq, MS_TPC_GET_INT, NULL, 1);\r\nmemstick_new_req(card->host);\r\nwait_for_completion(&card->mrq_complete);\r\nrc = card->current_mrq.error;\r\nif (rc) {\r\nprintk(KERN_WARNING\r\n"%s: interface error, trying to fall back to serial\n",\r\ndev_name(&card->dev));\r\nmsb->system = MEMSTICK_SYS_SERIAL;\r\nhost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_OFF);\r\nmsleep(10);\r\nhost->set_param(host, MEMSTICK_POWER, MEMSTICK_POWER_ON);\r\nhost->set_param(host, MEMSTICK_INTERFACE, MEMSTICK_SERIAL);\r\nrc = memstick_set_rw_addr(card);\r\nif (!rc)\r\nrc = mspro_block_set_interface(card, msb->system);\r\nif (!rc) {\r\nmsleep(150);\r\nrc = mspro_block_wait_for_ced(card);\r\nif (rc)\r\nreturn rc;\r\nif (msb->caps & MEMSTICK_CAP_PAR8) {\r\nmsb->caps &= ~MEMSTICK_CAP_PAR8;\r\ngoto try_again;\r\n}\r\n}\r\n}\r\nreturn rc;\r\n}\r\nstatic int mspro_block_read_attributes(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nstruct mspro_attribute *attr = NULL;\r\nstruct mspro_sys_attr *s_attr = NULL;\r\nunsigned char *buffer = NULL;\r\nint cnt, rc, attr_count;\r\nunsigned int addr, attr_offset = 0, attr_len = msb->page_size;\r\nattr = kmalloc(msb->page_size, GFP_KERNEL);\r\nif (!attr)\r\nreturn -ENOMEM;\r\nsg_init_one(&msb->req_sg[0], attr, msb->page_size);\r\nmsb->seg_count = 1;\r\nmsb->current_seg = 0;\r\nmsb->current_page = 0;\r\nmsb->data_dir = READ;\r\nmsb->transfer_cmd = MSPRO_CMD_READ_ATRB;\r\nmsb->setup_transfer(card, attr_offset, attr_len);\r\nmemstick_new_req(card->host);\r\nwait_for_completion(&card->mrq_complete);\r\nif (card->current_mrq.error) {\r\nrc = card->current_mrq.error;\r\ngoto out_free_attr;\r\n}\r\nif (be16_to_cpu(attr->signature) != MSPRO_BLOCK_SIGNATURE) {\r\nprintk(KERN_ERR "%s: unrecognized device signature %x\n",\r\ndev_name(&card->dev), be16_to_cpu(attr->signature));\r\nrc = -ENODEV;\r\ngoto out_free_attr;\r\n}\r\nif (attr->count > MSPRO_BLOCK_MAX_ATTRIBUTES) {\r\nprintk(KERN_WARNING "%s: way too many attribute entries\n",\r\ndev_name(&card->dev));\r\nattr_count = MSPRO_BLOCK_MAX_ATTRIBUTES;\r\n} else\r\nattr_count = attr->count;\r\nmsb->attr_group.attrs = kcalloc(attr_count + 1,\r\nsizeof(*msb->attr_group.attrs),\r\nGFP_KERNEL);\r\nif (!msb->attr_group.attrs) {\r\nrc = -ENOMEM;\r\ngoto out_free_attr;\r\n}\r\nmsb->attr_group.name = "media_attributes";\r\nbuffer = kmemdup(attr, attr_len, GFP_KERNEL);\r\nif (!buffer) {\r\nrc = -ENOMEM;\r\ngoto out_free_attr;\r\n}\r\nfor (cnt = 0; cnt < attr_count; ++cnt) {\r\ns_attr = kzalloc(sizeof(struct mspro_sys_attr), GFP_KERNEL);\r\nif (!s_attr) {\r\nrc = -ENOMEM;\r\ngoto out_free_buffer;\r\n}\r\nmsb->attr_group.attrs[cnt] = &s_attr->dev_attr.attr;\r\naddr = be32_to_cpu(attr->entries[cnt].address);\r\ns_attr->size = be32_to_cpu(attr->entries[cnt].size);\r\ndev_dbg(&card->dev, "adding attribute %d: id %x, address %x, "\r\n"size %zx\n", cnt, attr->entries[cnt].id, addr,\r\ns_attr->size);\r\ns_attr->id = attr->entries[cnt].id;\r\nif (mspro_block_attr_name(s_attr->id))\r\nsnprintf(s_attr->name, sizeof(s_attr->name), "%s",\r\nmspro_block_attr_name(attr->entries[cnt].id));\r\nelse\r\nsnprintf(s_attr->name, sizeof(s_attr->name),\r\n"attr_x%02x", attr->entries[cnt].id);\r\nsysfs_attr_init(&s_attr->dev_attr.attr);\r\ns_attr->dev_attr.attr.name = s_attr->name;\r\ns_attr->dev_attr.attr.mode = S_IRUGO;\r\ns_attr->dev_attr.show = mspro_block_attr_show(s_attr->id);\r\nif (!s_attr->size)\r\ncontinue;\r\ns_attr->data = kmalloc(s_attr->size, GFP_KERNEL);\r\nif (!s_attr->data) {\r\nrc = -ENOMEM;\r\ngoto out_free_buffer;\r\n}\r\nif (((addr / msb->page_size) == (attr_offset / msb->page_size))\r\n&& (((addr + s_attr->size - 1) / msb->page_size)\r\n== (attr_offset / msb->page_size))) {\r\nmemcpy(s_attr->data, buffer + addr % msb->page_size,\r\ns_attr->size);\r\ncontinue;\r\n}\r\nattr_offset = (addr / msb->page_size) * msb->page_size;\r\nif ((attr_offset + attr_len) < (addr + s_attr->size)) {\r\nkfree(buffer);\r\nattr_len = (((addr + s_attr->size) / msb->page_size)\r\n+ 1 ) * msb->page_size - attr_offset;\r\nbuffer = kmalloc(attr_len, GFP_KERNEL);\r\nif (!buffer) {\r\nrc = -ENOMEM;\r\ngoto out_free_attr;\r\n}\r\n}\r\nsg_init_one(&msb->req_sg[0], buffer, attr_len);\r\nmsb->seg_count = 1;\r\nmsb->current_seg = 0;\r\nmsb->current_page = 0;\r\nmsb->data_dir = READ;\r\nmsb->transfer_cmd = MSPRO_CMD_READ_ATRB;\r\ndev_dbg(&card->dev, "reading attribute range %x, %x\n",\r\nattr_offset, attr_len);\r\nmsb->setup_transfer(card, attr_offset, attr_len);\r\nmemstick_new_req(card->host);\r\nwait_for_completion(&card->mrq_complete);\r\nif (card->current_mrq.error) {\r\nrc = card->current_mrq.error;\r\ngoto out_free_buffer;\r\n}\r\nmemcpy(s_attr->data, buffer + addr % msb->page_size,\r\ns_attr->size);\r\n}\r\nrc = 0;\r\nout_free_buffer:\r\nkfree(buffer);\r\nout_free_attr:\r\nkfree(attr);\r\nreturn rc;\r\n}\r\nstatic int mspro_block_init_card(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nstruct memstick_host *host = card->host;\r\nint rc = 0;\r\nmsb->system = MEMSTICK_SYS_SERIAL;\r\nmsb->setup_transfer = h_mspro_block_setup_cmd;\r\ncard->reg_addr.r_offset = offsetof(struct mspro_register, status);\r\ncard->reg_addr.r_length = sizeof(struct ms_status_register);\r\ncard->reg_addr.w_offset = offsetof(struct mspro_register, param);\r\ncard->reg_addr.w_length = sizeof(struct mspro_param_register);\r\nif (memstick_set_rw_addr(card))\r\nreturn -EIO;\r\nmsb->caps = host->caps;\r\nmsleep(150);\r\nrc = mspro_block_wait_for_ced(card);\r\nif (rc)\r\nreturn rc;\r\nrc = mspro_block_switch_interface(card);\r\nif (rc)\r\nreturn rc;\r\ndev_dbg(&card->dev, "card activated\n");\r\nif (msb->system != MEMSTICK_SYS_SERIAL)\r\nmsb->caps |= MEMSTICK_CAP_AUTO_GET_INT;\r\ncard->next_request = h_mspro_block_req_init;\r\nmsb->mrq_handler = h_mspro_block_get_ro;\r\nmemstick_init_req(&card->current_mrq, MS_TPC_READ_REG, NULL,\r\nsizeof(struct ms_status_register));\r\nmemstick_new_req(card->host);\r\nwait_for_completion(&card->mrq_complete);\r\nif (card->current_mrq.error)\r\nreturn card->current_mrq.error;\r\ndev_dbg(&card->dev, "card r/w status %d\n", msb->read_only ? 0 : 1);\r\nmsb->page_size = 512;\r\nrc = mspro_block_read_attributes(card);\r\nif (rc)\r\nreturn rc;\r\ndev_dbg(&card->dev, "attributes loaded\n");\r\nreturn 0;\r\n}\r\nstatic int mspro_block_init_disk(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nstruct memstick_host *host = card->host;\r\nstruct mspro_devinfo *dev_info = NULL;\r\nstruct mspro_sys_info *sys_info = NULL;\r\nstruct mspro_sys_attr *s_attr = NULL;\r\nint rc, disk_id;\r\nu64 limit = BLK_BOUNCE_HIGH;\r\nunsigned long capacity;\r\nif (host->dev.dma_mask && *(host->dev.dma_mask))\r\nlimit = *(host->dev.dma_mask);\r\nfor (rc = 0; msb->attr_group.attrs[rc]; ++rc) {\r\ns_attr = mspro_from_sysfs_attr(msb->attr_group.attrs[rc]);\r\nif (s_attr->id == MSPRO_BLOCK_ID_DEVINFO)\r\ndev_info = s_attr->data;\r\nelse if (s_attr->id == MSPRO_BLOCK_ID_SYSINFO)\r\nsys_info = s_attr->data;\r\n}\r\nif (!dev_info || !sys_info)\r\nreturn -ENODEV;\r\nmsb->cylinders = be16_to_cpu(dev_info->cylinders);\r\nmsb->heads = be16_to_cpu(dev_info->heads);\r\nmsb->sectors_per_track = be16_to_cpu(dev_info->sectors_per_track);\r\nmsb->page_size = be16_to_cpu(sys_info->unit_size);\r\nmutex_lock(&mspro_block_disk_lock);\r\ndisk_id = idr_alloc(&mspro_block_disk_idr, card, 0, 256, GFP_KERNEL);\r\nmutex_unlock(&mspro_block_disk_lock);\r\nif (disk_id < 0)\r\nreturn disk_id;\r\nmsb->disk = alloc_disk(1 << MSPRO_BLOCK_PART_SHIFT);\r\nif (!msb->disk) {\r\nrc = -ENOMEM;\r\ngoto out_release_id;\r\n}\r\nmsb->queue = blk_init_queue(mspro_block_submit_req, &msb->q_lock);\r\nif (!msb->queue) {\r\nrc = -ENOMEM;\r\ngoto out_put_disk;\r\n}\r\nmsb->queue->queuedata = card;\r\nblk_queue_bounce_limit(msb->queue, limit);\r\nblk_queue_max_hw_sectors(msb->queue, MSPRO_BLOCK_MAX_PAGES);\r\nblk_queue_max_segments(msb->queue, MSPRO_BLOCK_MAX_SEGS);\r\nblk_queue_max_segment_size(msb->queue,\r\nMSPRO_BLOCK_MAX_PAGES * msb->page_size);\r\nmsb->disk->major = major;\r\nmsb->disk->first_minor = disk_id << MSPRO_BLOCK_PART_SHIFT;\r\nmsb->disk->fops = &ms_block_bdops;\r\nmsb->usage_count = 1;\r\nmsb->disk->private_data = msb;\r\nmsb->disk->queue = msb->queue;\r\nsprintf(msb->disk->disk_name, "mspblk%d", disk_id);\r\nblk_queue_logical_block_size(msb->queue, msb->page_size);\r\ncapacity = be16_to_cpu(sys_info->user_block_count);\r\ncapacity *= be16_to_cpu(sys_info->block_size);\r\ncapacity *= msb->page_size >> 9;\r\nset_capacity(msb->disk, capacity);\r\ndev_dbg(&card->dev, "capacity set %ld\n", capacity);\r\ndevice_add_disk(&card->dev, msb->disk);\r\nmsb->active = 1;\r\nreturn 0;\r\nout_put_disk:\r\nput_disk(msb->disk);\r\nout_release_id:\r\nmutex_lock(&mspro_block_disk_lock);\r\nidr_remove(&mspro_block_disk_idr, disk_id);\r\nmutex_unlock(&mspro_block_disk_lock);\r\nreturn rc;\r\n}\r\nstatic void mspro_block_data_clear(struct mspro_block_data *msb)\r\n{\r\nint cnt;\r\nstruct mspro_sys_attr *s_attr;\r\nif (msb->attr_group.attrs) {\r\nfor (cnt = 0; msb->attr_group.attrs[cnt]; ++cnt) {\r\ns_attr = mspro_from_sysfs_attr(msb->attr_group\r\n.attrs[cnt]);\r\nkfree(s_attr->data);\r\nkfree(s_attr);\r\n}\r\nkfree(msb->attr_group.attrs);\r\n}\r\nmsb->card = NULL;\r\n}\r\nstatic int mspro_block_check_card(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nreturn (msb->active == 1);\r\n}\r\nstatic int mspro_block_probe(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb;\r\nint rc = 0;\r\nmsb = kzalloc(sizeof(struct mspro_block_data), GFP_KERNEL);\r\nif (!msb)\r\nreturn -ENOMEM;\r\nmemstick_set_drvdata(card, msb);\r\nmsb->card = card;\r\nspin_lock_init(&msb->q_lock);\r\nrc = mspro_block_init_card(card);\r\nif (rc)\r\ngoto out_free;\r\nrc = sysfs_create_group(&card->dev.kobj, &msb->attr_group);\r\nif (rc)\r\ngoto out_free;\r\nrc = mspro_block_init_disk(card);\r\nif (!rc) {\r\ncard->check = mspro_block_check_card;\r\ncard->stop = mspro_block_stop;\r\ncard->start = mspro_block_start;\r\nreturn 0;\r\n}\r\nsysfs_remove_group(&card->dev.kobj, &msb->attr_group);\r\nout_free:\r\nmemstick_set_drvdata(card, NULL);\r\nmspro_block_data_clear(msb);\r\nkfree(msb);\r\nreturn rc;\r\n}\r\nstatic void mspro_block_remove(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nunsigned long flags;\r\nspin_lock_irqsave(&msb->q_lock, flags);\r\nmsb->eject = 1;\r\nblk_start_queue(msb->queue);\r\nspin_unlock_irqrestore(&msb->q_lock, flags);\r\ndel_gendisk(msb->disk);\r\ndev_dbg(&card->dev, "mspro block remove\n");\r\nblk_cleanup_queue(msb->queue);\r\nmsb->queue = NULL;\r\nsysfs_remove_group(&card->dev.kobj, &msb->attr_group);\r\nmutex_lock(&mspro_block_disk_lock);\r\nmspro_block_data_clear(msb);\r\nmutex_unlock(&mspro_block_disk_lock);\r\nmspro_block_disk_release(msb->disk);\r\nmemstick_set_drvdata(card, NULL);\r\n}\r\nstatic int mspro_block_suspend(struct memstick_dev *card, pm_message_t state)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nunsigned long flags;\r\nspin_lock_irqsave(&msb->q_lock, flags);\r\nblk_stop_queue(msb->queue);\r\nmsb->active = 0;\r\nspin_unlock_irqrestore(&msb->q_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int mspro_block_resume(struct memstick_dev *card)\r\n{\r\nstruct mspro_block_data *msb = memstick_get_drvdata(card);\r\nunsigned long flags;\r\nint rc = 0;\r\n#ifdef CONFIG_MEMSTICK_UNSAFE_RESUME\r\nstruct mspro_block_data *new_msb;\r\nstruct memstick_host *host = card->host;\r\nstruct mspro_sys_attr *s_attr, *r_attr;\r\nunsigned char cnt;\r\nmutex_lock(&host->lock);\r\nnew_msb = kzalloc(sizeof(struct mspro_block_data), GFP_KERNEL);\r\nif (!new_msb) {\r\nrc = -ENOMEM;\r\ngoto out_unlock;\r\n}\r\nnew_msb->card = card;\r\nmemstick_set_drvdata(card, new_msb);\r\nif (mspro_block_init_card(card))\r\ngoto out_free;\r\nfor (cnt = 0; new_msb->attr_group.attrs[cnt]\r\n&& msb->attr_group.attrs[cnt]; ++cnt) {\r\ns_attr = mspro_from_sysfs_attr(new_msb->attr_group.attrs[cnt]);\r\nr_attr = mspro_from_sysfs_attr(msb->attr_group.attrs[cnt]);\r\nif (s_attr->id == MSPRO_BLOCK_ID_SYSINFO\r\n&& r_attr->id == s_attr->id) {\r\nif (memcmp(s_attr->data, r_attr->data, s_attr->size))\r\nbreak;\r\nmsb->active = 1;\r\nbreak;\r\n}\r\n}\r\nout_free:\r\nmemstick_set_drvdata(card, msb);\r\nmspro_block_data_clear(new_msb);\r\nkfree(new_msb);\r\nout_unlock:\r\nmutex_unlock(&host->lock);\r\n#endif\r\nspin_lock_irqsave(&msb->q_lock, flags);\r\nblk_start_queue(msb->queue);\r\nspin_unlock_irqrestore(&msb->q_lock, flags);\r\nreturn rc;\r\n}\r\nstatic int __init mspro_block_init(void)\r\n{\r\nint rc = -ENOMEM;\r\nrc = register_blkdev(major, DRIVER_NAME);\r\nif (rc < 0) {\r\nprintk(KERN_ERR DRIVER_NAME ": failed to register "\r\n"major %d, error %d\n", major, rc);\r\nreturn rc;\r\n}\r\nif (!major)\r\nmajor = rc;\r\nrc = memstick_register_driver(&mspro_block_driver);\r\nif (rc)\r\nunregister_blkdev(major, DRIVER_NAME);\r\nreturn rc;\r\n}\r\nstatic void __exit mspro_block_exit(void)\r\n{\r\nmemstick_unregister_driver(&mspro_block_driver);\r\nunregister_blkdev(major, DRIVER_NAME);\r\nidr_destroy(&mspro_block_disk_idr);\r\n}
