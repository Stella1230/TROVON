static int policy_to_aspm_state(struct pcie_link_state *link)\r\n{\r\nswitch (aspm_policy) {\r\ncase POLICY_PERFORMANCE:\r\nreturn 0;\r\ncase POLICY_POWERSAVE:\r\nreturn (ASPM_STATE_L0S | ASPM_STATE_L1);\r\ncase POLICY_POWER_SUPERSAVE:\r\nreturn ASPM_STATE_ALL;\r\ncase POLICY_DEFAULT:\r\nreturn link->aspm_default;\r\n}\r\nreturn 0;\r\n}\r\nstatic int policy_to_clkpm_state(struct pcie_link_state *link)\r\n{\r\nswitch (aspm_policy) {\r\ncase POLICY_PERFORMANCE:\r\nreturn 0;\r\ncase POLICY_POWERSAVE:\r\ncase POLICY_POWER_SUPERSAVE:\r\nreturn 1;\r\ncase POLICY_DEFAULT:\r\nreturn link->clkpm_default;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_set_clkpm_nocheck(struct pcie_link_state *link, int enable)\r\n{\r\nstruct pci_dev *child;\r\nstruct pci_bus *linkbus = link->pdev->subordinate;\r\nu32 val = enable ? PCI_EXP_LNKCTL_CLKREQ_EN : 0;\r\nlist_for_each_entry(child, &linkbus->devices, bus_list)\r\npcie_capability_clear_and_set_word(child, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_CLKREQ_EN,\r\nval);\r\nlink->clkpm_enabled = !!enable;\r\n}\r\nstatic void pcie_set_clkpm(struct pcie_link_state *link, int enable)\r\n{\r\nif (!link->clkpm_capable)\r\nenable = 0;\r\nif (link->clkpm_enabled == enable)\r\nreturn;\r\npcie_set_clkpm_nocheck(link, enable);\r\n}\r\nstatic void pcie_clkpm_cap_init(struct pcie_link_state *link, int blacklist)\r\n{\r\nint capable = 1, enabled = 1;\r\nu32 reg32;\r\nu16 reg16;\r\nstruct pci_dev *child;\r\nstruct pci_bus *linkbus = link->pdev->subordinate;\r\nlist_for_each_entry(child, &linkbus->devices, bus_list) {\r\npcie_capability_read_dword(child, PCI_EXP_LNKCAP, &reg32);\r\nif (!(reg32 & PCI_EXP_LNKCAP_CLKPM)) {\r\ncapable = 0;\r\nenabled = 0;\r\nbreak;\r\n}\r\npcie_capability_read_word(child, PCI_EXP_LNKCTL, &reg16);\r\nif (!(reg16 & PCI_EXP_LNKCTL_CLKREQ_EN))\r\nenabled = 0;\r\n}\r\nlink->clkpm_enabled = enabled;\r\nlink->clkpm_default = enabled;\r\nlink->clkpm_capable = (blacklist) ? 0 : capable;\r\n}\r\nstatic void pcie_aspm_configure_common_clock(struct pcie_link_state *link)\r\n{\r\nint same_clock = 1;\r\nu16 reg16, parent_reg, child_reg[8];\r\nunsigned long start_jiffies;\r\nstruct pci_dev *child, *parent = link->pdev;\r\nstruct pci_bus *linkbus = parent->subordinate;\r\nchild = list_entry(linkbus->devices.next, struct pci_dev, bus_list);\r\nBUG_ON(!pci_is_pcie(child));\r\npcie_capability_read_word(child, PCI_EXP_LNKSTA, &reg16);\r\nif (!(reg16 & PCI_EXP_LNKSTA_SLC))\r\nsame_clock = 0;\r\npcie_capability_read_word(parent, PCI_EXP_LNKSTA, &reg16);\r\nif (!(reg16 & PCI_EXP_LNKSTA_SLC))\r\nsame_clock = 0;\r\nlist_for_each_entry(child, &linkbus->devices, bus_list) {\r\npcie_capability_read_word(child, PCI_EXP_LNKCTL, &reg16);\r\nchild_reg[PCI_FUNC(child->devfn)] = reg16;\r\nif (same_clock)\r\nreg16 |= PCI_EXP_LNKCTL_CCC;\r\nelse\r\nreg16 &= ~PCI_EXP_LNKCTL_CCC;\r\npcie_capability_write_word(child, PCI_EXP_LNKCTL, reg16);\r\n}\r\npcie_capability_read_word(parent, PCI_EXP_LNKCTL, &reg16);\r\nparent_reg = reg16;\r\nif (same_clock)\r\nreg16 |= PCI_EXP_LNKCTL_CCC;\r\nelse\r\nreg16 &= ~PCI_EXP_LNKCTL_CCC;\r\npcie_capability_write_word(parent, PCI_EXP_LNKCTL, reg16);\r\nreg16 |= PCI_EXP_LNKCTL_RL;\r\npcie_capability_write_word(parent, PCI_EXP_LNKCTL, reg16);\r\nstart_jiffies = jiffies;\r\nfor (;;) {\r\npcie_capability_read_word(parent, PCI_EXP_LNKSTA, &reg16);\r\nif (!(reg16 & PCI_EXP_LNKSTA_LT))\r\nbreak;\r\nif (time_after(jiffies, start_jiffies + LINK_RETRAIN_TIMEOUT))\r\nbreak;\r\nmsleep(1);\r\n}\r\nif (!(reg16 & PCI_EXP_LNKSTA_LT))\r\nreturn;\r\ndev_err(&parent->dev, "ASPM: Could not configure common clock\n");\r\nlist_for_each_entry(child, &linkbus->devices, bus_list)\r\npcie_capability_write_word(child, PCI_EXP_LNKCTL,\r\nchild_reg[PCI_FUNC(child->devfn)]);\r\npcie_capability_write_word(parent, PCI_EXP_LNKCTL, parent_reg);\r\n}\r\nstatic u32 calc_l0s_latency(u32 encoding)\r\n{\r\nif (encoding == 0x7)\r\nreturn (5 * 1000);\r\nreturn (64 << encoding);\r\n}\r\nstatic u32 calc_l0s_acceptable(u32 encoding)\r\n{\r\nif (encoding == 0x7)\r\nreturn -1U;\r\nreturn (64 << encoding);\r\n}\r\nstatic u32 calc_l1_latency(u32 encoding)\r\n{\r\nif (encoding == 0x7)\r\nreturn (65 * 1000);\r\nreturn (1000 << encoding);\r\n}\r\nstatic u32 calc_l1_acceptable(u32 encoding)\r\n{\r\nif (encoding == 0x7)\r\nreturn -1U;\r\nreturn (1000 << encoding);\r\n}\r\nstatic u32 calc_l1ss_pwron(struct pci_dev *pdev, u32 scale, u32 val)\r\n{\r\nswitch (scale) {\r\ncase 0:\r\nreturn val * 2;\r\ncase 1:\r\nreturn val * 10;\r\ncase 2:\r\nreturn val * 100;\r\n}\r\ndev_err(&pdev->dev, "%s: Invalid T_PwrOn scale: %u\n",\r\n__func__, scale);\r\nreturn 0;\r\n}\r\nstatic void pcie_get_aspm_reg(struct pci_dev *pdev,\r\nstruct aspm_register_info *info)\r\n{\r\nu16 reg16;\r\nu32 reg32;\r\npcie_capability_read_dword(pdev, PCI_EXP_LNKCAP, &reg32);\r\ninfo->support = (reg32 & PCI_EXP_LNKCAP_ASPMS) >> 10;\r\ninfo->latency_encoding_l0s = (reg32 & PCI_EXP_LNKCAP_L0SEL) >> 12;\r\ninfo->latency_encoding_l1 = (reg32 & PCI_EXP_LNKCAP_L1EL) >> 15;\r\npcie_capability_read_word(pdev, PCI_EXP_LNKCTL, &reg16);\r\ninfo->enabled = reg16 & PCI_EXP_LNKCTL_ASPMC;\r\ninfo->l1ss_cap = info->l1ss_ctl1 = info->l1ss_ctl2 = 0;\r\ninfo->l1ss_cap_ptr = pci_find_ext_capability(pdev, PCI_EXT_CAP_ID_L1SS);\r\nif (!info->l1ss_cap_ptr)\r\nreturn;\r\npci_read_config_dword(pdev, info->l1ss_cap_ptr + PCI_L1SS_CAP,\r\n&info->l1ss_cap);\r\nif (!(info->l1ss_cap & PCI_L1SS_CAP_L1_PM_SS)) {\r\ninfo->l1ss_cap = 0;\r\nreturn;\r\n}\r\npci_read_config_dword(pdev, info->l1ss_cap_ptr + PCI_L1SS_CTL1,\r\n&info->l1ss_ctl1);\r\npci_read_config_dword(pdev, info->l1ss_cap_ptr + PCI_L1SS_CTL2,\r\n&info->l1ss_ctl2);\r\n}\r\nstatic void pcie_aspm_check_latency(struct pci_dev *endpoint)\r\n{\r\nu32 latency, l1_switch_latency = 0;\r\nstruct aspm_latency *acceptable;\r\nstruct pcie_link_state *link;\r\nif ((endpoint->current_state != PCI_D0) &&\r\n(endpoint->current_state != PCI_UNKNOWN))\r\nreturn;\r\nlink = endpoint->bus->self->link_state;\r\nacceptable = &link->acceptable[PCI_FUNC(endpoint->devfn)];\r\nwhile (link) {\r\nif ((link->aspm_capable & ASPM_STATE_L0S_UP) &&\r\n(link->latency_up.l0s > acceptable->l0s))\r\nlink->aspm_capable &= ~ASPM_STATE_L0S_UP;\r\nif ((link->aspm_capable & ASPM_STATE_L0S_DW) &&\r\n(link->latency_dw.l0s > acceptable->l0s))\r\nlink->aspm_capable &= ~ASPM_STATE_L0S_DW;\r\nlatency = max_t(u32, link->latency_up.l1, link->latency_dw.l1);\r\nif ((link->aspm_capable & ASPM_STATE_L1) &&\r\n(latency + l1_switch_latency > acceptable->l1))\r\nlink->aspm_capable &= ~ASPM_STATE_L1;\r\nl1_switch_latency += 1000;\r\nlink = link->parent;\r\n}\r\n}\r\nstatic struct pci_dev *pci_function_0(struct pci_bus *linkbus)\r\n{\r\nstruct pci_dev *child;\r\nlist_for_each_entry(child, &linkbus->devices, bus_list)\r\nif (PCI_FUNC(child->devfn) == 0)\r\nreturn child;\r\nreturn NULL;\r\n}\r\nstatic void aspm_calc_l1ss_info(struct pcie_link_state *link,\r\nstruct aspm_register_info *upreg,\r\nstruct aspm_register_info *dwreg)\r\n{\r\nu32 val1, val2, scale1, scale2;\r\nlink->l1ss.up_cap_ptr = upreg->l1ss_cap_ptr;\r\nlink->l1ss.dw_cap_ptr = dwreg->l1ss_cap_ptr;\r\nlink->l1ss.ctl1 = link->l1ss.ctl2 = 0;\r\nif (!(link->aspm_support & ASPM_STATE_L1_2_MASK))\r\nreturn;\r\nval1 = (upreg->l1ss_cap >> 8) & 0xFF;\r\nval2 = (upreg->l1ss_cap >> 8) & 0xFF;\r\nif (val1 > val2)\r\nlink->l1ss.ctl1 |= val1 << 8;\r\nelse\r\nlink->l1ss.ctl1 |= val2 << 8;\r\nlink->l1ss.ctl1 |= LTR_L1_2_THRESHOLD_BITS;\r\nval1 = (upreg->l1ss_cap >> 19) & 0x1F;\r\nscale1 = (upreg->l1ss_cap >> 16) & 0x03;\r\nval2 = (dwreg->l1ss_cap >> 19) & 0x1F;\r\nscale2 = (dwreg->l1ss_cap >> 16) & 0x03;\r\nif (calc_l1ss_pwron(link->pdev, scale1, val1) >\r\ncalc_l1ss_pwron(link->downstream, scale2, val2))\r\nlink->l1ss.ctl2 |= scale1 | (val1 << 3);\r\nelse\r\nlink->l1ss.ctl2 |= scale2 | (val2 << 3);\r\n}\r\nstatic void pcie_aspm_cap_init(struct pcie_link_state *link, int blacklist)\r\n{\r\nstruct pci_dev *child = link->downstream, *parent = link->pdev;\r\nstruct pci_bus *linkbus = parent->subordinate;\r\nstruct aspm_register_info upreg, dwreg;\r\nif (blacklist) {\r\nlink->aspm_enabled = ASPM_STATE_ALL;\r\nlink->aspm_disable = ASPM_STATE_ALL;\r\nreturn;\r\n}\r\npcie_get_aspm_reg(parent, &upreg);\r\npcie_get_aspm_reg(child, &dwreg);\r\nif (!(upreg.support & dwreg.support))\r\nreturn;\r\npcie_aspm_configure_common_clock(link);\r\npcie_get_aspm_reg(parent, &upreg);\r\npcie_get_aspm_reg(child, &dwreg);\r\nif (dwreg.support & upreg.support & PCIE_LINK_STATE_L0S)\r\nlink->aspm_support |= ASPM_STATE_L0S;\r\nif (dwreg.enabled & PCIE_LINK_STATE_L0S)\r\nlink->aspm_enabled |= ASPM_STATE_L0S_UP;\r\nif (upreg.enabled & PCIE_LINK_STATE_L0S)\r\nlink->aspm_enabled |= ASPM_STATE_L0S_DW;\r\nlink->latency_up.l0s = calc_l0s_latency(upreg.latency_encoding_l0s);\r\nlink->latency_dw.l0s = calc_l0s_latency(dwreg.latency_encoding_l0s);\r\nif (upreg.support & dwreg.support & PCIE_LINK_STATE_L1)\r\nlink->aspm_support |= ASPM_STATE_L1;\r\nif (upreg.enabled & dwreg.enabled & PCIE_LINK_STATE_L1)\r\nlink->aspm_enabled |= ASPM_STATE_L1;\r\nlink->latency_up.l1 = calc_l1_latency(upreg.latency_encoding_l1);\r\nlink->latency_dw.l1 = calc_l1_latency(dwreg.latency_encoding_l1);\r\nif (upreg.l1ss_cap & dwreg.l1ss_cap & PCI_L1SS_CAP_ASPM_L1_1)\r\nlink->aspm_support |= ASPM_STATE_L1_1;\r\nif (upreg.l1ss_cap & dwreg.l1ss_cap & PCI_L1SS_CAP_ASPM_L1_2)\r\nlink->aspm_support |= ASPM_STATE_L1_2;\r\nif (upreg.l1ss_cap & dwreg.l1ss_cap & PCI_L1SS_CAP_PCIPM_L1_1)\r\nlink->aspm_support |= ASPM_STATE_L1_1_PCIPM;\r\nif (upreg.l1ss_cap & dwreg.l1ss_cap & PCI_L1SS_CAP_PCIPM_L1_2)\r\nlink->aspm_support |= ASPM_STATE_L1_2_PCIPM;\r\nif (upreg.l1ss_ctl1 & dwreg.l1ss_ctl1 & PCI_L1SS_CTL1_ASPM_L1_1)\r\nlink->aspm_enabled |= ASPM_STATE_L1_1;\r\nif (upreg.l1ss_ctl1 & dwreg.l1ss_ctl1 & PCI_L1SS_CTL1_ASPM_L1_2)\r\nlink->aspm_enabled |= ASPM_STATE_L1_2;\r\nif (upreg.l1ss_ctl1 & dwreg.l1ss_ctl1 & PCI_L1SS_CTL1_PCIPM_L1_1)\r\nlink->aspm_enabled |= ASPM_STATE_L1_1_PCIPM;\r\nif (upreg.l1ss_ctl1 & dwreg.l1ss_ctl1 & PCI_L1SS_CTL1_PCIPM_L1_2)\r\nlink->aspm_enabled |= ASPM_STATE_L1_2_PCIPM;\r\nif (link->aspm_support & ASPM_STATE_L1SS)\r\naspm_calc_l1ss_info(link, &upreg, &dwreg);\r\nlink->aspm_default = link->aspm_enabled;\r\nlink->aspm_capable = link->aspm_support;\r\nlist_for_each_entry(child, &linkbus->devices, bus_list) {\r\nif (pci_pcie_type(child) == PCI_EXP_TYPE_PCI_BRIDGE) {\r\nlink->aspm_disable = ASPM_STATE_ALL;\r\nbreak;\r\n}\r\n}\r\nlist_for_each_entry(child, &linkbus->devices, bus_list) {\r\nu32 reg32, encoding;\r\nstruct aspm_latency *acceptable =\r\n&link->acceptable[PCI_FUNC(child->devfn)];\r\nif (pci_pcie_type(child) != PCI_EXP_TYPE_ENDPOINT &&\r\npci_pcie_type(child) != PCI_EXP_TYPE_LEG_END)\r\ncontinue;\r\npcie_capability_read_dword(child, PCI_EXP_DEVCAP, &reg32);\r\nencoding = (reg32 & PCI_EXP_DEVCAP_L0S) >> 6;\r\nacceptable->l0s = calc_l0s_acceptable(encoding);\r\nencoding = (reg32 & PCI_EXP_DEVCAP_L1) >> 9;\r\nacceptable->l1 = calc_l1_acceptable(encoding);\r\npcie_aspm_check_latency(child);\r\n}\r\n}\r\nstatic void pci_clear_and_set_dword(struct pci_dev *pdev, int pos,\r\nu32 clear, u32 set)\r\n{\r\nu32 val;\r\npci_read_config_dword(pdev, pos, &val);\r\nval &= ~clear;\r\nval |= set;\r\npci_write_config_dword(pdev, pos, val);\r\n}\r\nstatic void pcie_config_aspm_l1ss(struct pcie_link_state *link, u32 state)\r\n{\r\nu32 val, enable_req;\r\nstruct pci_dev *child = link->downstream, *parent = link->pdev;\r\nu32 up_cap_ptr = link->l1ss.up_cap_ptr;\r\nu32 dw_cap_ptr = link->l1ss.dw_cap_ptr;\r\nenable_req = (link->aspm_enabled ^ state) & state;\r\npci_clear_and_set_dword(child, dw_cap_ptr + PCI_L1SS_CTL1,\r\nPCI_L1SS_CTL1_L1SS_MASK, 0);\r\npci_clear_and_set_dword(parent, up_cap_ptr + PCI_L1SS_CTL1,\r\nPCI_L1SS_CTL1_L1SS_MASK, 0);\r\nif (enable_req & (ASPM_STATE_L1_1 | ASPM_STATE_L1_2)) {\r\npcie_capability_clear_and_set_word(child, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_ASPM_L1, 0);\r\npcie_capability_clear_and_set_word(parent, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_ASPM_L1, 0);\r\n}\r\nif (enable_req & ASPM_STATE_L1_2_MASK) {\r\npci_write_config_dword(parent, up_cap_ptr + PCI_L1SS_CTL2,\r\nlink->l1ss.ctl2);\r\npci_write_config_dword(child, dw_cap_ptr + PCI_L1SS_CTL2,\r\nlink->l1ss.ctl2);\r\npci_clear_and_set_dword(parent, up_cap_ptr + PCI_L1SS_CTL1,\r\n0xFF00, link->l1ss.ctl1);\r\npci_clear_and_set_dword(parent, dw_cap_ptr + PCI_L1SS_CTL1,\r\n0xE3FF0000, link->l1ss.ctl1);\r\npci_clear_and_set_dword(child, dw_cap_ptr + PCI_L1SS_CTL1,\r\n0xE3FF0000, link->l1ss.ctl1);\r\n}\r\nval = 0;\r\nif (state & ASPM_STATE_L1_1)\r\nval |= PCI_L1SS_CTL1_ASPM_L1_1;\r\nif (state & ASPM_STATE_L1_2)\r\nval |= PCI_L1SS_CTL1_ASPM_L1_2;\r\nif (state & ASPM_STATE_L1_1_PCIPM)\r\nval |= PCI_L1SS_CTL1_PCIPM_L1_1;\r\nif (state & ASPM_STATE_L1_2_PCIPM)\r\nval |= PCI_L1SS_CTL1_PCIPM_L1_2;\r\npci_clear_and_set_dword(parent, up_cap_ptr + PCI_L1SS_CTL1,\r\nPCI_L1SS_CAP_L1_PM_SS, val);\r\npci_clear_and_set_dword(child, dw_cap_ptr + PCI_L1SS_CTL1,\r\nPCI_L1SS_CAP_L1_PM_SS, val);\r\n}\r\nstatic void pcie_config_aspm_dev(struct pci_dev *pdev, u32 val)\r\n{\r\npcie_capability_clear_and_set_word(pdev, PCI_EXP_LNKCTL,\r\nPCI_EXP_LNKCTL_ASPMC, val);\r\n}\r\nstatic void pcie_config_aspm_link(struct pcie_link_state *link, u32 state)\r\n{\r\nu32 upstream = 0, dwstream = 0;\r\nstruct pci_dev *child = link->downstream, *parent = link->pdev;\r\nstruct pci_bus *linkbus = parent->subordinate;\r\nstate &= (link->aspm_capable & ~link->aspm_disable);\r\nif (!(state & ASPM_STATE_L1))\r\nstate &= ~ASPM_STATE_L1SS;\r\nif (parent->current_state != PCI_D0 || child->current_state != PCI_D0) {\r\nstate &= ~ASPM_STATE_L1_SS_PCIPM;\r\nstate |= (link->aspm_enabled & ASPM_STATE_L1_SS_PCIPM);\r\n}\r\nif (link->aspm_enabled == state)\r\nreturn;\r\nif (state & ASPM_STATE_L0S_UP)\r\ndwstream |= PCI_EXP_LNKCTL_ASPM_L0S;\r\nif (state & ASPM_STATE_L0S_DW)\r\nupstream |= PCI_EXP_LNKCTL_ASPM_L0S;\r\nif (state & ASPM_STATE_L1) {\r\nupstream |= PCI_EXP_LNKCTL_ASPM_L1;\r\ndwstream |= PCI_EXP_LNKCTL_ASPM_L1;\r\n}\r\nif (link->aspm_capable & ASPM_STATE_L1SS)\r\npcie_config_aspm_l1ss(link, state);\r\nif (state & ASPM_STATE_L1)\r\npcie_config_aspm_dev(parent, upstream);\r\nlist_for_each_entry(child, &linkbus->devices, bus_list)\r\npcie_config_aspm_dev(child, dwstream);\r\nif (!(state & ASPM_STATE_L1))\r\npcie_config_aspm_dev(parent, upstream);\r\nlink->aspm_enabled = state;\r\n}\r\nstatic void pcie_config_aspm_path(struct pcie_link_state *link)\r\n{\r\nwhile (link) {\r\npcie_config_aspm_link(link, policy_to_aspm_state(link));\r\nlink = link->parent;\r\n}\r\n}\r\nstatic void free_link_state(struct pcie_link_state *link)\r\n{\r\nlink->pdev->link_state = NULL;\r\nkfree(link);\r\n}\r\nstatic int pcie_aspm_sanity_check(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *child;\r\nu32 reg32;\r\nlist_for_each_entry(child, &pdev->subordinate->devices, bus_list) {\r\nif (!pci_is_pcie(child))\r\nreturn -EINVAL;\r\nif (aspm_disabled)\r\ncontinue;\r\npcie_capability_read_dword(child, PCI_EXP_DEVCAP, &reg32);\r\nif (!(reg32 & PCI_EXP_DEVCAP_RBER) && !aspm_force) {\r\ndev_info(&child->dev, "disabling ASPM on pre-1.1 PCIe device. You can enable it with 'pcie_aspm=force'\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic struct pcie_link_state *alloc_pcie_link_state(struct pci_dev *pdev)\r\n{\r\nstruct pcie_link_state *link;\r\nlink = kzalloc(sizeof(*link), GFP_KERNEL);\r\nif (!link)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&link->sibling);\r\nINIT_LIST_HEAD(&link->children);\r\nINIT_LIST_HEAD(&link->link);\r\nlink->pdev = pdev;\r\nlink->downstream = pci_function_0(pdev->subordinate);\r\nif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT ||\r\npci_pcie_type(pdev) == PCI_EXP_TYPE_PCIE_BRIDGE) {\r\nlink->root = link;\r\n} else {\r\nstruct pcie_link_state *parent;\r\nparent = pdev->bus->parent->self->link_state;\r\nif (!parent) {\r\nkfree(link);\r\nreturn NULL;\r\n}\r\nlink->parent = parent;\r\nlink->root = link->parent->root;\r\nlist_add(&link->link, &parent->children);\r\n}\r\nlist_add(&link->sibling, &link_list);\r\npdev->link_state = link;\r\nreturn link;\r\n}\r\nvoid pcie_aspm_init_link_state(struct pci_dev *pdev)\r\n{\r\nstruct pcie_link_state *link;\r\nint blacklist = !!pcie_aspm_sanity_check(pdev);\r\nif (!aspm_support_enabled)\r\nreturn;\r\nif (pdev->link_state)\r\nreturn;\r\nif (!pdev->has_secondary_link)\r\nreturn;\r\nif (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT &&\r\npdev->bus->self)\r\nreturn;\r\ndown_read(&pci_bus_sem);\r\nif (list_empty(&pdev->subordinate->devices))\r\ngoto out;\r\nmutex_lock(&aspm_lock);\r\nlink = alloc_pcie_link_state(pdev);\r\nif (!link)\r\ngoto unlock;\r\npcie_aspm_cap_init(link, blacklist);\r\npcie_clkpm_cap_init(link, blacklist);\r\nif (aspm_policy != POLICY_POWERSAVE &&\r\naspm_policy != POLICY_POWER_SUPERSAVE) {\r\npcie_config_aspm_path(link);\r\npcie_set_clkpm(link, policy_to_clkpm_state(link));\r\n}\r\nunlock:\r\nmutex_unlock(&aspm_lock);\r\nout:\r\nup_read(&pci_bus_sem);\r\n}\r\nstatic void pcie_update_aspm_capable(struct pcie_link_state *root)\r\n{\r\nstruct pcie_link_state *link;\r\nBUG_ON(root->parent);\r\nlist_for_each_entry(link, &link_list, sibling) {\r\nif (link->root != root)\r\ncontinue;\r\nlink->aspm_capable = link->aspm_support;\r\n}\r\nlist_for_each_entry(link, &link_list, sibling) {\r\nstruct pci_dev *child;\r\nstruct pci_bus *linkbus = link->pdev->subordinate;\r\nif (link->root != root)\r\ncontinue;\r\nlist_for_each_entry(child, &linkbus->devices, bus_list) {\r\nif ((pci_pcie_type(child) != PCI_EXP_TYPE_ENDPOINT) &&\r\n(pci_pcie_type(child) != PCI_EXP_TYPE_LEG_END))\r\ncontinue;\r\npcie_aspm_check_latency(child);\r\n}\r\n}\r\n}\r\nvoid pcie_aspm_exit_link_state(struct pci_dev *pdev)\r\n{\r\nstruct pci_dev *parent = pdev->bus->self;\r\nstruct pcie_link_state *link, *root, *parent_link;\r\nif (!parent || !parent->link_state)\r\nreturn;\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\nif (!list_is_last(&pdev->bus_list, &parent->subordinate->devices))\r\ngoto out;\r\nlink = parent->link_state;\r\nroot = link->root;\r\nparent_link = link->parent;\r\npcie_config_aspm_link(link, 0);\r\nlist_del(&link->sibling);\r\nlist_del(&link->link);\r\nfree_link_state(link);\r\nif (parent_link) {\r\npcie_update_aspm_capable(root);\r\npcie_config_aspm_path(parent_link);\r\n}\r\nout:\r\nmutex_unlock(&aspm_lock);\r\nup_read(&pci_bus_sem);\r\n}\r\nvoid pcie_aspm_pm_state_change(struct pci_dev *pdev)\r\n{\r\nstruct pcie_link_state *link = pdev->link_state;\r\nif (aspm_disabled || !link)\r\nreturn;\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\npcie_update_aspm_capable(link->root);\r\npcie_config_aspm_path(link);\r\nmutex_unlock(&aspm_lock);\r\nup_read(&pci_bus_sem);\r\n}\r\nvoid pcie_aspm_powersave_config_link(struct pci_dev *pdev)\r\n{\r\nstruct pcie_link_state *link = pdev->link_state;\r\nif (aspm_disabled || !link)\r\nreturn;\r\nif (aspm_policy != POLICY_POWERSAVE &&\r\naspm_policy != POLICY_POWER_SUPERSAVE)\r\nreturn;\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\npcie_config_aspm_path(link);\r\npcie_set_clkpm(link, policy_to_clkpm_state(link));\r\nmutex_unlock(&aspm_lock);\r\nup_read(&pci_bus_sem);\r\n}\r\nstatic void __pci_disable_link_state(struct pci_dev *pdev, int state, bool sem)\r\n{\r\nstruct pci_dev *parent = pdev->bus->self;\r\nstruct pcie_link_state *link;\r\nif (!pci_is_pcie(pdev))\r\nreturn;\r\nif (pdev->has_secondary_link)\r\nparent = pdev;\r\nif (!parent || !parent->link_state)\r\nreturn;\r\nif (aspm_disabled) {\r\ndev_warn(&pdev->dev, "can't disable ASPM; OS doesn't have ASPM control\n");\r\nreturn;\r\n}\r\nif (sem)\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\nlink = parent->link_state;\r\nif (state & PCIE_LINK_STATE_L0S)\r\nlink->aspm_disable |= ASPM_STATE_L0S;\r\nif (state & PCIE_LINK_STATE_L1)\r\nlink->aspm_disable |= ASPM_STATE_L1;\r\npcie_config_aspm_link(link, policy_to_aspm_state(link));\r\nif (state & PCIE_LINK_STATE_CLKPM) {\r\nlink->clkpm_capable = 0;\r\npcie_set_clkpm(link, 0);\r\n}\r\nmutex_unlock(&aspm_lock);\r\nif (sem)\r\nup_read(&pci_bus_sem);\r\n}\r\nvoid pci_disable_link_state_locked(struct pci_dev *pdev, int state)\r\n{\r\n__pci_disable_link_state(pdev, state, false);\r\n}\r\nvoid pci_disable_link_state(struct pci_dev *pdev, int state)\r\n{\r\n__pci_disable_link_state(pdev, state, true);\r\n}\r\nstatic int pcie_aspm_set_policy(const char *val, struct kernel_param *kp)\r\n{\r\nint i;\r\nstruct pcie_link_state *link;\r\nif (aspm_disabled)\r\nreturn -EPERM;\r\nfor (i = 0; i < ARRAY_SIZE(policy_str); i++)\r\nif (!strncmp(val, policy_str[i], strlen(policy_str[i])))\r\nbreak;\r\nif (i >= ARRAY_SIZE(policy_str))\r\nreturn -EINVAL;\r\nif (i == aspm_policy)\r\nreturn 0;\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\naspm_policy = i;\r\nlist_for_each_entry(link, &link_list, sibling) {\r\npcie_config_aspm_link(link, policy_to_aspm_state(link));\r\npcie_set_clkpm(link, policy_to_clkpm_state(link));\r\n}\r\nmutex_unlock(&aspm_lock);\r\nup_read(&pci_bus_sem);\r\nreturn 0;\r\n}\r\nstatic int pcie_aspm_get_policy(char *buffer, struct kernel_param *kp)\r\n{\r\nint i, cnt = 0;\r\nfor (i = 0; i < ARRAY_SIZE(policy_str); i++)\r\nif (i == aspm_policy)\r\ncnt += sprintf(buffer + cnt, "[%s] ", policy_str[i]);\r\nelse\r\ncnt += sprintf(buffer + cnt, "%s ", policy_str[i]);\r\nreturn cnt;\r\n}\r\nstatic ssize_t link_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pci_dev *pci_device = to_pci_dev(dev);\r\nstruct pcie_link_state *link_state = pci_device->link_state;\r\nreturn sprintf(buf, "%d\n", link_state->aspm_enabled);\r\n}\r\nstatic ssize_t link_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t n)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct pcie_link_state *link, *root = pdev->link_state->root;\r\nu32 state;\r\nif (aspm_disabled)\r\nreturn -EPERM;\r\nif (kstrtouint(buf, 10, &state))\r\nreturn -EINVAL;\r\nif ((state & ~ASPM_STATE_ALL) != 0)\r\nreturn -EINVAL;\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\nlist_for_each_entry(link, &link_list, sibling) {\r\nif (link->root != root)\r\ncontinue;\r\npcie_config_aspm_link(link, state);\r\n}\r\nmutex_unlock(&aspm_lock);\r\nup_read(&pci_bus_sem);\r\nreturn n;\r\n}\r\nstatic ssize_t clk_ctl_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pci_dev *pci_device = to_pci_dev(dev);\r\nstruct pcie_link_state *link_state = pci_device->link_state;\r\nreturn sprintf(buf, "%d\n", link_state->clkpm_enabled);\r\n}\r\nstatic ssize_t clk_ctl_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf,\r\nsize_t n)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nbool state;\r\nif (strtobool(buf, &state))\r\nreturn -EINVAL;\r\ndown_read(&pci_bus_sem);\r\nmutex_lock(&aspm_lock);\r\npcie_set_clkpm_nocheck(pdev->link_state, state);\r\nmutex_unlock(&aspm_lock);\r\nup_read(&pci_bus_sem);\r\nreturn n;\r\n}\r\nvoid pcie_aspm_create_sysfs_dev_files(struct pci_dev *pdev)\r\n{\r\nstruct pcie_link_state *link_state = pdev->link_state;\r\nif (!link_state)\r\nreturn;\r\nif (link_state->aspm_support)\r\nsysfs_add_file_to_group(&pdev->dev.kobj,\r\n&dev_attr_link_state.attr, power_group);\r\nif (link_state->clkpm_capable)\r\nsysfs_add_file_to_group(&pdev->dev.kobj,\r\n&dev_attr_clk_ctl.attr, power_group);\r\n}\r\nvoid pcie_aspm_remove_sysfs_dev_files(struct pci_dev *pdev)\r\n{\r\nstruct pcie_link_state *link_state = pdev->link_state;\r\nif (!link_state)\r\nreturn;\r\nif (link_state->aspm_support)\r\nsysfs_remove_file_from_group(&pdev->dev.kobj,\r\n&dev_attr_link_state.attr, power_group);\r\nif (link_state->clkpm_capable)\r\nsysfs_remove_file_from_group(&pdev->dev.kobj,\r\n&dev_attr_clk_ctl.attr, power_group);\r\n}\r\nstatic int __init pcie_aspm_disable(char *str)\r\n{\r\nif (!strcmp(str, "off")) {\r\naspm_policy = POLICY_DEFAULT;\r\naspm_disabled = 1;\r\naspm_support_enabled = false;\r\nprintk(KERN_INFO "PCIe ASPM is disabled\n");\r\n} else if (!strcmp(str, "force")) {\r\naspm_force = 1;\r\nprintk(KERN_INFO "PCIe ASPM is forcibly enabled\n");\r\n}\r\nreturn 1;\r\n}\r\nvoid pcie_no_aspm(void)\r\n{\r\nif (!aspm_force) {\r\naspm_policy = POLICY_DEFAULT;\r\naspm_disabled = 1;\r\n}\r\n}\r\nbool pcie_aspm_support_enabled(void)\r\n{\r\nreturn aspm_support_enabled;\r\n}
