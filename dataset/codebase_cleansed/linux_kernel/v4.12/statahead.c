static inline int sa_ready(struct sa_entry *entry)\r\n{\r\nsmp_rmb();\r\nreturn (entry->se_state != SA_ENTRY_INIT);\r\n}\r\nstatic inline int sa_hash(int val)\r\n{\r\nreturn val & LL_SA_CACHE_MASK;\r\n}\r\nstatic inline void\r\nsa_rehash(struct ll_statahead_info *sai, struct sa_entry *entry)\r\n{\r\nint i = sa_hash(entry->se_qstr.hash);\r\nspin_lock(&sai->sai_cache_lock[i]);\r\nlist_add_tail(&entry->se_hash, &sai->sai_cache[i]);\r\nspin_unlock(&sai->sai_cache_lock[i]);\r\n}\r\nstatic inline void\r\nsa_unhash(struct ll_statahead_info *sai, struct sa_entry *entry)\r\n{\r\nint i = sa_hash(entry->se_qstr.hash);\r\nspin_lock(&sai->sai_cache_lock[i]);\r\nlist_del_init(&entry->se_hash);\r\nspin_unlock(&sai->sai_cache_lock[i]);\r\n}\r\nstatic inline int agl_should_run(struct ll_statahead_info *sai,\r\nstruct inode *inode)\r\n{\r\nreturn (inode && S_ISREG(inode->i_mode) && sai->sai_agl_valid);\r\n}\r\nstatic inline int sa_sent_full(struct ll_statahead_info *sai)\r\n{\r\nreturn atomic_read(&sai->sai_cache_count) >= sai->sai_max;\r\n}\r\nstatic inline int sa_has_callback(struct ll_statahead_info *sai)\r\n{\r\nreturn !list_empty(&sai->sai_interim_entries);\r\n}\r\nstatic inline int agl_list_empty(struct ll_statahead_info *sai)\r\n{\r\nreturn list_empty(&sai->sai_agls);\r\n}\r\nstatic inline int sa_low_hit(struct ll_statahead_info *sai)\r\n{\r\nreturn ((sai->sai_hit > 7 && sai->sai_hit < 4 * sai->sai_miss) ||\r\n(sai->sai_consecutive_miss > 8));\r\n}\r\nstatic inline int is_omitted_entry(struct ll_statahead_info *sai, __u64 index)\r\n{\r\nreturn ((__u64)sai->sai_max + index + SA_OMITTED_ENTRY_MAX <\r\nsai->sai_index);\r\n}\r\nstatic struct sa_entry *\r\nsa_alloc(struct dentry *parent, struct ll_statahead_info *sai, __u64 index,\r\nconst char *name, int len, const struct lu_fid *fid)\r\n{\r\nstruct ll_inode_info *lli;\r\nstruct sa_entry *entry;\r\nint entry_size;\r\nchar *dname;\r\nentry_size = sizeof(struct sa_entry) + (len & ~3) + 4;\r\nentry = kzalloc(entry_size, GFP_NOFS);\r\nif (unlikely(!entry))\r\nreturn ERR_PTR(-ENOMEM);\r\nCDEBUG(D_READA, "alloc sa entry %.*s(%p) index %llu\n",\r\nlen, name, entry, index);\r\nentry->se_index = index;\r\nentry->se_state = SA_ENTRY_INIT;\r\nentry->se_size = entry_size;\r\ndname = (char *)entry + sizeof(struct sa_entry);\r\nmemcpy(dname, name, len);\r\ndname[len] = 0;\r\nentry->se_qstr.hash = full_name_hash(parent, name, len);\r\nentry->se_qstr.len = len;\r\nentry->se_qstr.name = dname;\r\nentry->se_fid = *fid;\r\nlli = ll_i2info(sai->sai_dentry->d_inode);\r\nspin_lock(&lli->lli_sa_lock);\r\nINIT_LIST_HEAD(&entry->se_list);\r\nsa_rehash(sai, entry);\r\nspin_unlock(&lli->lli_sa_lock);\r\natomic_inc(&sai->sai_cache_count);\r\nreturn entry;\r\n}\r\nstatic void sa_free(struct ll_statahead_info *sai, struct sa_entry *entry)\r\n{\r\nCDEBUG(D_READA, "free sa entry %.*s(%p) index %llu\n",\r\nentry->se_qstr.len, entry->se_qstr.name, entry,\r\nentry->se_index);\r\nLASSERT(list_empty(&entry->se_list));\r\nLASSERT(list_empty(&entry->se_hash));\r\nkfree(entry);\r\natomic_dec(&sai->sai_cache_count);\r\n}\r\nstatic struct sa_entry *\r\nsa_get(struct ll_statahead_info *sai, const struct qstr *qstr)\r\n{\r\nstruct sa_entry *entry;\r\nint i = sa_hash(qstr->hash);\r\nlist_for_each_entry(entry, &sai->sai_cache[i], se_hash) {\r\nif (entry->se_qstr.hash == qstr->hash &&\r\nentry->se_qstr.len == qstr->len &&\r\nmemcmp(entry->se_qstr.name, qstr->name, qstr->len) == 0)\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void\r\nsa_kill(struct ll_statahead_info *sai, struct sa_entry *entry)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(sai->sai_dentry->d_inode);\r\nLASSERT(!list_empty(&entry->se_hash));\r\nLASSERT(!list_empty(&entry->se_list));\r\nLASSERT(sa_ready(entry));\r\nsa_unhash(sai, entry);\r\nspin_lock(&lli->lli_sa_lock);\r\nlist_del_init(&entry->se_list);\r\nspin_unlock(&lli->lli_sa_lock);\r\nif (entry->se_inode)\r\niput(entry->se_inode);\r\nsa_free(sai, entry);\r\n}\r\nstatic void\r\nsa_put(struct ll_statahead_info *sai, struct sa_entry *entry)\r\n{\r\nstruct sa_entry *tmp, *next;\r\nif (entry && entry->se_state == SA_ENTRY_SUCC) {\r\nstruct ll_sb_info *sbi = ll_i2sbi(sai->sai_dentry->d_inode);\r\nsai->sai_hit++;\r\nsai->sai_consecutive_miss = 0;\r\nsai->sai_max = min(2 * sai->sai_max, sbi->ll_sa_max);\r\n} else {\r\nsai->sai_miss++;\r\nsai->sai_consecutive_miss++;\r\n}\r\nif (entry)\r\nsa_kill(sai, entry);\r\nlist_for_each_entry_safe(tmp, next, &sai->sai_entries, se_list) {\r\nif (!is_omitted_entry(sai, tmp->se_index))\r\nbreak;\r\nsa_kill(sai, tmp);\r\n}\r\nwake_up(&sai->sai_thread.t_ctl_waitq);\r\n}\r\nstatic bool\r\n__sa_make_ready(struct ll_statahead_info *sai, struct sa_entry *entry, int ret)\r\n{\r\nstruct list_head *pos = &sai->sai_entries;\r\n__u64 index = entry->se_index;\r\nstruct sa_entry *se;\r\nLASSERT(!sa_ready(entry));\r\nLASSERT(list_empty(&entry->se_list));\r\nlist_for_each_entry_reverse(se, &sai->sai_entries, se_list) {\r\nif (se->se_index < entry->se_index) {\r\npos = &se->se_list;\r\nbreak;\r\n}\r\n}\r\nlist_add(&entry->se_list, pos);\r\nentry->se_state = ret < 0 ? SA_ENTRY_INVA : SA_ENTRY_SUCC;\r\nreturn (index == sai->sai_index_wait);\r\n}\r\nstatic void\r\nsa_make_ready(struct ll_statahead_info *sai, struct sa_entry *entry, int ret)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(sai->sai_dentry->d_inode);\r\nstruct md_enqueue_info *minfo = entry->se_minfo;\r\nstruct ptlrpc_request *req = entry->se_req;\r\nbool wakeup;\r\nif (minfo) {\r\nentry->se_minfo = NULL;\r\nll_intent_release(&minfo->mi_it);\r\niput(minfo->mi_dir);\r\nkfree(minfo);\r\n}\r\nif (req) {\r\nentry->se_req = NULL;\r\nptlrpc_req_finished(req);\r\n}\r\nspin_lock(&lli->lli_sa_lock);\r\nwakeup = __sa_make_ready(sai, entry, ret);\r\nspin_unlock(&lli->lli_sa_lock);\r\nif (wakeup)\r\nwake_up(&sai->sai_waitq);\r\n}\r\nstatic void ll_agl_add(struct ll_statahead_info *sai,\r\nstruct inode *inode, int index)\r\n{\r\nstruct ll_inode_info *child = ll_i2info(inode);\r\nstruct ll_inode_info *parent = ll_i2info(sai->sai_dentry->d_inode);\r\nint added = 0;\r\nspin_lock(&child->lli_agl_lock);\r\nif (child->lli_agl_index == 0) {\r\nchild->lli_agl_index = index;\r\nspin_unlock(&child->lli_agl_lock);\r\nLASSERT(list_empty(&child->lli_agl_list));\r\nigrab(inode);\r\nspin_lock(&parent->lli_agl_lock);\r\nif (list_empty(&sai->sai_agls))\r\nadded = 1;\r\nlist_add_tail(&child->lli_agl_list, &sai->sai_agls);\r\nspin_unlock(&parent->lli_agl_lock);\r\n} else {\r\nspin_unlock(&child->lli_agl_lock);\r\n}\r\nif (added > 0)\r\nwake_up(&sai->sai_agl_thread.t_ctl_waitq);\r\n}\r\nstatic struct ll_statahead_info *ll_sai_alloc(struct dentry *dentry)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dentry->d_inode);\r\nstruct ll_statahead_info *sai;\r\nint i;\r\nsai = kzalloc(sizeof(*sai), GFP_NOFS);\r\nif (!sai)\r\nreturn NULL;\r\nsai->sai_dentry = dget(dentry);\r\natomic_set(&sai->sai_refcount, 1);\r\nsai->sai_max = LL_SA_RPC_MIN;\r\nsai->sai_index = 1;\r\ninit_waitqueue_head(&sai->sai_waitq);\r\ninit_waitqueue_head(&sai->sai_thread.t_ctl_waitq);\r\ninit_waitqueue_head(&sai->sai_agl_thread.t_ctl_waitq);\r\nINIT_LIST_HEAD(&sai->sai_interim_entries);\r\nINIT_LIST_HEAD(&sai->sai_entries);\r\nINIT_LIST_HEAD(&sai->sai_agls);\r\nfor (i = 0; i < LL_SA_CACHE_SIZE; i++) {\r\nINIT_LIST_HEAD(&sai->sai_cache[i]);\r\nspin_lock_init(&sai->sai_cache_lock[i]);\r\n}\r\natomic_set(&sai->sai_cache_count, 0);\r\nspin_lock(&sai_generation_lock);\r\nlli->lli_sa_generation = ++sai_generation;\r\nif (unlikely(!sai_generation))\r\nlli->lli_sa_generation = ++sai_generation;\r\nspin_unlock(&sai_generation_lock);\r\nreturn sai;\r\n}\r\nstatic inline void ll_sai_free(struct ll_statahead_info *sai)\r\n{\r\nLASSERT(sai->sai_dentry);\r\ndput(sai->sai_dentry);\r\nkfree(sai);\r\n}\r\nstatic inline struct ll_statahead_info *ll_sai_get(struct inode *dir)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = NULL;\r\nspin_lock(&lli->lli_sa_lock);\r\nsai = lli->lli_sai;\r\nif (sai)\r\natomic_inc(&sai->sai_refcount);\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn sai;\r\n}\r\nstatic void ll_sai_put(struct ll_statahead_info *sai)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(sai->sai_dentry->d_inode);\r\nif (atomic_dec_and_lock(&sai->sai_refcount, &lli->lli_sa_lock)) {\r\nstruct ll_sb_info *sbi = ll_i2sbi(sai->sai_dentry->d_inode);\r\nstruct sa_entry *entry, *next;\r\nlli->lli_sai = NULL;\r\nspin_unlock(&lli->lli_sa_lock);\r\nLASSERT(thread_is_stopped(&sai->sai_thread));\r\nLASSERT(thread_is_stopped(&sai->sai_agl_thread));\r\nLASSERT(sai->sai_sent == sai->sai_replied);\r\nLASSERT(!sa_has_callback(sai));\r\nlist_for_each_entry_safe(entry, next, &sai->sai_entries,\r\nse_list)\r\nsa_kill(sai, entry);\r\nLASSERT(atomic_read(&sai->sai_cache_count) == 0);\r\nLASSERT(list_empty(&sai->sai_agls));\r\nll_sai_free(sai);\r\natomic_dec(&sbi->ll_sa_running);\r\n}\r\n}\r\nstatic void ll_agl_trigger(struct inode *inode, struct ll_statahead_info *sai)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\n__u64 index = lli->lli_agl_index;\r\nint rc;\r\nLASSERT(list_empty(&lli->lli_agl_list));\r\nif (is_omitted_entry(sai, index + 1)) {\r\nlli->lli_agl_index = 0;\r\niput(inode);\r\nreturn;\r\n}\r\nrc = down_write_trylock(&lli->lli_glimpse_sem);\r\nif (rc == 0) {\r\nlli->lli_agl_index = 0;\r\niput(inode);\r\nreturn;\r\n}\r\nif (lli->lli_glimpse_time != 0 &&\r\ntime_before(cfs_time_shift(-1), lli->lli_glimpse_time)) {\r\nup_write(&lli->lli_glimpse_sem);\r\nlli->lli_agl_index = 0;\r\niput(inode);\r\nreturn;\r\n}\r\nCDEBUG(D_READA, "Handling (init) async glimpse: inode = "\r\nDFID", idx = %llu\n", PFID(&lli->lli_fid), index);\r\ncl_agl(inode);\r\nlli->lli_agl_index = 0;\r\nlli->lli_glimpse_time = cfs_time_current();\r\nup_write(&lli->lli_glimpse_sem);\r\nCDEBUG(D_READA, "Handled (init) async glimpse: inode= "\r\nDFID", idx = %llu, rc = %d\n",\r\nPFID(&lli->lli_fid), index, rc);\r\niput(inode);\r\n}\r\nstatic void sa_instantiate(struct ll_statahead_info *sai,\r\nstruct sa_entry *entry)\r\n{\r\nstruct inode *dir = sai->sai_dentry->d_inode;\r\nstruct inode *child;\r\nstruct md_enqueue_info *minfo;\r\nstruct lookup_intent *it;\r\nstruct ptlrpc_request *req;\r\nstruct mdt_body *body;\r\nint rc = 0;\r\nLASSERT(entry->se_handle != 0);\r\nminfo = entry->se_minfo;\r\nit = &minfo->mi_it;\r\nreq = entry->se_req;\r\nbody = req_capsule_server_get(&req->rq_pill, &RMF_MDT_BODY);\r\nif (!body) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nchild = entry->se_inode;\r\nif (child) {\r\nif (unlikely(!lu_fid_eq(&minfo->mi_data.op_fid2, &body->mbo_fid1))) {\r\nentry->se_inode = NULL;\r\niput(child);\r\nchild = NULL;\r\n}\r\n}\r\nit->it_lock_handle = entry->se_handle;\r\nrc = md_revalidate_lock(ll_i2mdexp(dir), it, ll_inode2fid(dir), NULL);\r\nif (rc != 1) {\r\nrc = -EAGAIN;\r\ngoto out;\r\n}\r\nrc = ll_prep_inode(&child, req, dir->i_sb, it);\r\nif (rc)\r\ngoto out;\r\nCDEBUG(D_READA, "%s: setting %.*s" DFID " l_data to inode %p\n",\r\nll_get_fsname(child->i_sb, NULL, 0),\r\nentry->se_qstr.len, entry->se_qstr.name,\r\nPFID(ll_inode2fid(child)), child);\r\nll_set_lock_data(ll_i2sbi(dir)->ll_md_exp, child, it, NULL);\r\nentry->se_inode = child;\r\nif (agl_should_run(sai, child))\r\nll_agl_add(sai, child, entry->se_index);\r\nout:\r\nsa_make_ready(sai, entry, rc);\r\n}\r\nstatic void sa_handle_callback(struct ll_statahead_info *sai)\r\n{\r\nstruct ll_inode_info *lli;\r\nlli = ll_i2info(sai->sai_dentry->d_inode);\r\nwhile (sa_has_callback(sai)) {\r\nstruct sa_entry *entry;\r\nspin_lock(&lli->lli_sa_lock);\r\nif (unlikely(!sa_has_callback(sai))) {\r\nspin_unlock(&lli->lli_sa_lock);\r\nbreak;\r\n}\r\nentry = list_entry(sai->sai_interim_entries.next,\r\nstruct sa_entry, se_list);\r\nlist_del_init(&entry->se_list);\r\nspin_unlock(&lli->lli_sa_lock);\r\nsa_instantiate(sai, entry);\r\n}\r\n}\r\nstatic int ll_statahead_interpret(struct ptlrpc_request *req,\r\nstruct md_enqueue_info *minfo, int rc)\r\n{\r\nstruct lookup_intent *it = &minfo->mi_it;\r\nstruct inode *dir = minfo->mi_dir;\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = lli->lli_sai;\r\nstruct sa_entry *entry = (struct sa_entry *)minfo->mi_cbdata;\r\nwait_queue_head_t *waitq = NULL;\r\n__u64 handle = 0;\r\nif (it_disposition(it, DISP_LOOKUP_NEG))\r\nrc = -ENOENT;\r\nLASSERT(sai);\r\nLASSERT(!thread_is_stopped(&sai->sai_thread));\r\nLASSERT(entry);\r\nCDEBUG(D_READA, "sa_entry %.*s rc %d\n",\r\nentry->se_qstr.len, entry->se_qstr.name, rc);\r\nif (rc) {\r\nll_intent_release(it);\r\niput(dir);\r\nkfree(minfo);\r\n} else {\r\nhandle = it->it_lock_handle;\r\nll_intent_drop_lock(it);\r\n}\r\nspin_lock(&lli->lli_sa_lock);\r\nif (rc) {\r\nif (__sa_make_ready(sai, entry, rc))\r\nwaitq = &sai->sai_waitq;\r\n} else {\r\nentry->se_minfo = minfo;\r\nentry->se_req = ptlrpc_request_addref(req);\r\nentry->se_handle = handle;\r\nif (!sa_has_callback(sai))\r\nwaitq = &sai->sai_thread.t_ctl_waitq;\r\nlist_add_tail(&entry->se_list, &sai->sai_interim_entries);\r\n}\r\nsai->sai_replied++;\r\nif (waitq)\r\nwake_up(waitq);\r\nspin_unlock(&lli->lli_sa_lock);\r\nreturn rc;\r\n}\r\nstatic void sa_fini_data(struct md_enqueue_info *minfo)\r\n{\r\niput(minfo->mi_dir);\r\nkfree(minfo);\r\n}\r\nstatic struct md_enqueue_info *\r\nsa_prep_data(struct inode *dir, struct inode *child, struct sa_entry *entry)\r\n{\r\nstruct md_enqueue_info *minfo;\r\nstruct ldlm_enqueue_info *einfo;\r\nstruct md_op_data *op_data;\r\nminfo = kzalloc(sizeof(*minfo), GFP_NOFS);\r\nif (!minfo)\r\nreturn ERR_PTR(-ENOMEM);\r\nop_data = ll_prep_md_op_data(&minfo->mi_data, dir, child, NULL, 0, 0,\r\nLUSTRE_OPC_ANY, NULL);\r\nif (IS_ERR(op_data)) {\r\nkfree(minfo);\r\nreturn (struct md_enqueue_info *)op_data;\r\n}\r\nif (!child)\r\nop_data->op_fid2 = entry->se_fid;\r\nminfo->mi_it.it_op = IT_GETATTR;\r\nminfo->mi_dir = igrab(dir);\r\nminfo->mi_cb = ll_statahead_interpret;\r\nminfo->mi_cbdata = entry;\r\neinfo = &minfo->mi_einfo;\r\neinfo->ei_type = LDLM_IBITS;\r\neinfo->ei_mode = it_to_lock_mode(&minfo->mi_it);\r\neinfo->ei_cb_bl = ll_md_blocking_ast;\r\neinfo->ei_cb_cp = ldlm_completion_ast;\r\neinfo->ei_cb_gl = NULL;\r\neinfo->ei_cbdata = NULL;\r\nreturn minfo;\r\n}\r\nstatic int sa_lookup(struct inode *dir, struct sa_entry *entry)\r\n{\r\nstruct md_enqueue_info *minfo;\r\nint rc;\r\nminfo = sa_prep_data(dir, NULL, entry);\r\nif (IS_ERR(minfo))\r\nreturn PTR_ERR(minfo);\r\nrc = md_intent_getattr_async(ll_i2mdexp(dir), minfo);\r\nif (rc)\r\nsa_fini_data(minfo);\r\nreturn rc;\r\n}\r\nstatic int sa_revalidate(struct inode *dir, struct sa_entry *entry,\r\nstruct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(dentry);\r\nstruct lookup_intent it = { .it_op = IT_GETATTR,\r\n.it_lock_handle = 0 };\r\nstruct md_enqueue_info *minfo;\r\nint rc;\r\nif (unlikely(!inode))\r\nreturn 1;\r\nif (d_mountpoint(dentry))\r\nreturn 1;\r\nentry->se_inode = igrab(inode);\r\nrc = md_revalidate_lock(ll_i2mdexp(dir), &it, ll_inode2fid(inode),\r\nNULL);\r\nif (rc == 1) {\r\nentry->se_handle = it.it_lock_handle;\r\nll_intent_release(&it);\r\nreturn 1;\r\n}\r\nminfo = sa_prep_data(dir, inode, entry);\r\nif (IS_ERR(minfo)) {\r\nentry->se_inode = NULL;\r\niput(inode);\r\nreturn PTR_ERR(minfo);\r\n}\r\nrc = md_intent_getattr_async(ll_i2mdexp(dir), minfo);\r\nif (rc) {\r\nentry->se_inode = NULL;\r\niput(inode);\r\nsa_fini_data(minfo);\r\n}\r\nreturn rc;\r\n}\r\nstatic void sa_statahead(struct dentry *parent, const char *name, int len,\r\nconst struct lu_fid *fid)\r\n{\r\nstruct inode *dir = d_inode(parent);\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = lli->lli_sai;\r\nstruct dentry *dentry = NULL;\r\nstruct sa_entry *entry;\r\nint rc;\r\nentry = sa_alloc(parent, sai, sai->sai_index, name, len, fid);\r\nif (IS_ERR(entry))\r\nreturn;\r\ndentry = d_lookup(parent, &entry->se_qstr);\r\nif (!dentry) {\r\nrc = sa_lookup(dir, entry);\r\n} else {\r\nrc = sa_revalidate(dir, entry, dentry);\r\nif (rc == 1 && agl_should_run(sai, d_inode(dentry)))\r\nll_agl_add(sai, d_inode(dentry), entry->se_index);\r\n}\r\nif (dentry)\r\ndput(dentry);\r\nif (rc)\r\nsa_make_ready(sai, entry, rc);\r\nelse\r\nsai->sai_sent++;\r\nsai->sai_index++;\r\n}\r\nstatic int ll_agl_thread(void *arg)\r\n{\r\nstruct dentry *parent = arg;\r\nstruct inode *dir = d_inode(parent);\r\nstruct ll_inode_info *plli = ll_i2info(dir);\r\nstruct ll_inode_info *clli;\r\nstruct ll_sb_info *sbi = ll_i2sbi(dir);\r\nstruct ll_statahead_info *sai;\r\nstruct ptlrpc_thread *thread;\r\nstruct l_wait_info lwi = { 0 };\r\nsai = ll_sai_get(dir);\r\nthread = &sai->sai_agl_thread;\r\nthread->t_pid = current_pid();\r\nCDEBUG(D_READA, "agl thread started: sai %p, parent %pd\n",\r\nsai, parent);\r\natomic_inc(&sbi->ll_agl_total);\r\nspin_lock(&plli->lli_agl_lock);\r\nsai->sai_agl_valid = 1;\r\nif (thread_is_init(thread))\r\nthread_set_flags(thread, SVC_RUNNING);\r\nspin_unlock(&plli->lli_agl_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nwhile (1) {\r\nl_wait_event(thread->t_ctl_waitq,\r\n!list_empty(&sai->sai_agls) ||\r\n!thread_is_running(thread),\r\n&lwi);\r\nif (!thread_is_running(thread))\r\nbreak;\r\nspin_lock(&plli->lli_agl_lock);\r\nif (!list_empty(&sai->sai_agls)) {\r\nclli = list_entry(sai->sai_agls.next,\r\nstruct ll_inode_info, lli_agl_list);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&plli->lli_agl_lock);\r\nll_agl_trigger(&clli->lli_vfs_inode, sai);\r\n} else {\r\nspin_unlock(&plli->lli_agl_lock);\r\n}\r\n}\r\nspin_lock(&plli->lli_agl_lock);\r\nsai->sai_agl_valid = 0;\r\nwhile (!list_empty(&sai->sai_agls)) {\r\nclli = list_entry(sai->sai_agls.next,\r\nstruct ll_inode_info, lli_agl_list);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&plli->lli_agl_lock);\r\nclli->lli_agl_index = 0;\r\niput(&clli->lli_vfs_inode);\r\nspin_lock(&plli->lli_agl_lock);\r\n}\r\nthread_set_flags(thread, SVC_STOPPED);\r\nspin_unlock(&plli->lli_agl_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nll_sai_put(sai);\r\nCDEBUG(D_READA, "agl thread stopped: sai %p, parent %pd\n",\r\nsai, parent);\r\nreturn 0;\r\n}\r\nstatic void ll_start_agl(struct dentry *parent, struct ll_statahead_info *sai)\r\n{\r\nstruct ptlrpc_thread *thread = &sai->sai_agl_thread;\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ll_inode_info *plli;\r\nstruct task_struct *task;\r\nCDEBUG(D_READA, "start agl thread: sai %p, parent %pd\n",\r\nsai, parent);\r\nplli = ll_i2info(d_inode(parent));\r\ntask = kthread_run(ll_agl_thread, parent, "ll_agl_%u",\r\nplli->lli_opendir_pid);\r\nif (IS_ERR(task)) {\r\nCERROR("can't start ll_agl thread, rc: %ld\n", PTR_ERR(task));\r\nthread_set_flags(thread, SVC_STOPPED);\r\nreturn;\r\n}\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_running(thread) || thread_is_stopped(thread),\r\n&lwi);\r\n}\r\nstatic int ll_statahead_thread(void *arg)\r\n{\r\nstruct dentry *parent = arg;\r\nstruct inode *dir = d_inode(parent);\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_sb_info *sbi = ll_i2sbi(dir);\r\nstruct ll_statahead_info *sai;\r\nstruct ptlrpc_thread *sa_thread;\r\nstruct ptlrpc_thread *agl_thread;\r\nstruct page *page = NULL;\r\n__u64 pos = 0;\r\nint first = 0;\r\nint rc = 0;\r\nstruct md_op_data *op_data;\r\nstruct l_wait_info lwi = { 0 };\r\nsai = ll_sai_get(dir);\r\nsa_thread = &sai->sai_thread;\r\nagl_thread = &sai->sai_agl_thread;\r\nsa_thread->t_pid = current_pid();\r\nCDEBUG(D_READA, "statahead thread starting: sai %p, parent %pd\n",\r\nsai, parent);\r\nop_data = ll_prep_md_op_data(NULL, dir, dir, NULL, 0, 0,\r\nLUSTRE_OPC_ANY, dir);\r\nif (IS_ERR(op_data)) {\r\nrc = PTR_ERR(op_data);\r\ngoto out;\r\n}\r\nop_data->op_max_pages = ll_i2sbi(dir)->ll_md_brw_pages;\r\nif (sbi->ll_flags & LL_SBI_AGL_ENABLED)\r\nll_start_agl(parent, sai);\r\natomic_inc(&sbi->ll_sa_total);\r\nspin_lock(&lli->lli_sa_lock);\r\nif (thread_is_init(sa_thread))\r\nthread_set_flags(sa_thread, SVC_RUNNING);\r\nspin_unlock(&lli->lli_sa_lock);\r\nwake_up(&sa_thread->t_ctl_waitq);\r\nwhile (pos != MDS_DIR_END_OFF && thread_is_running(sa_thread)) {\r\nstruct lu_dirpage *dp;\r\nstruct lu_dirent *ent;\r\nsai->sai_in_readpage = 1;\r\npage = ll_get_dir_page(dir, op_data, pos);\r\nsai->sai_in_readpage = 0;\r\nif (IS_ERR(page)) {\r\nrc = PTR_ERR(page);\r\nCDEBUG(D_READA, "error reading dir "DFID" at %llu/%llu: opendir_pid = %u: rc = %d\n",\r\nPFID(ll_inode2fid(dir)), pos, sai->sai_index,\r\nlli->lli_opendir_pid, rc);\r\nbreak;\r\n}\r\ndp = page_address(page);\r\nfor (ent = lu_dirent_start(dp);\r\nent && thread_is_running(sa_thread) && !sa_low_hit(sai);\r\nent = lu_dirent_next(ent)) {\r\nstruct lu_fid fid;\r\n__u64 hash;\r\nint namelen;\r\nchar *name;\r\nhash = le64_to_cpu(ent->lde_hash);\r\nif (unlikely(hash < pos))\r\ncontinue;\r\nnamelen = le16_to_cpu(ent->lde_namelen);\r\nif (unlikely(namelen == 0))\r\ncontinue;\r\nname = ent->lde_name;\r\nif (name[0] == '.') {\r\nif (namelen == 1) {\r\ncontinue;\r\n} else if (name[1] == '.' && namelen == 2) {\r\ncontinue;\r\n} else if (!sai->sai_ls_all) {\r\nsai->sai_skip_hidden++;\r\ncontinue;\r\n}\r\n}\r\nif (unlikely(++first == 1))\r\ncontinue;\r\nfid_le_to_cpu(&fid, &ent->lde_fid);\r\ndo {\r\nl_wait_event(sa_thread->t_ctl_waitq,\r\n!sa_sent_full(sai) ||\r\nsa_has_callback(sai) ||\r\n!list_empty(&sai->sai_agls) ||\r\n!thread_is_running(sa_thread),\r\n&lwi);\r\nsa_handle_callback(sai);\r\nspin_lock(&lli->lli_agl_lock);\r\nwhile (sa_sent_full(sai) &&\r\n!agl_list_empty(sai)) {\r\nstruct ll_inode_info *clli;\r\nclli = list_entry(sai->sai_agls.next,\r\nstruct ll_inode_info, lli_agl_list);\r\nlist_del_init(&clli->lli_agl_list);\r\nspin_unlock(&lli->lli_agl_lock);\r\nll_agl_trigger(&clli->lli_vfs_inode,\r\nsai);\r\nspin_lock(&lli->lli_agl_lock);\r\n}\r\nspin_unlock(&lli->lli_agl_lock);\r\n} while (sa_sent_full(sai) &&\r\nthread_is_running(sa_thread));\r\nsa_statahead(parent, name, namelen, &fid);\r\n}\r\npos = le64_to_cpu(dp->ldp_hash_end);\r\nll_release_page(dir, page,\r\nle32_to_cpu(dp->ldp_flags) & LDF_COLLIDE);\r\nif (sa_low_hit(sai)) {\r\nrc = -EFAULT;\r\natomic_inc(&sbi->ll_sa_wrong);\r\nCDEBUG(D_READA, "Statahead for dir "DFID" hit ratio too low: hit/miss %llu/%llu, sent/replied %llu/%llu, stopping statahead thread: pid %d\n",\r\nPFID(&lli->lli_fid), sai->sai_hit,\r\nsai->sai_miss, sai->sai_sent,\r\nsai->sai_replied, current_pid());\r\nbreak;\r\n}\r\n}\r\nll_finish_md_op_data(op_data);\r\nif (rc < 0) {\r\nspin_lock(&lli->lli_sa_lock);\r\nthread_set_flags(sa_thread, SVC_STOPPING);\r\nlli->lli_sa_enabled = 0;\r\nspin_unlock(&lli->lli_sa_lock);\r\n}\r\nwhile (thread_is_running(sa_thread)) {\r\nl_wait_event(sa_thread->t_ctl_waitq,\r\nsa_has_callback(sai) ||\r\n!agl_list_empty(sai) ||\r\n!thread_is_running(sa_thread),\r\n&lwi);\r\nsa_handle_callback(sai);\r\n}\r\nout:\r\nif (sai->sai_agl_valid) {\r\nspin_lock(&lli->lli_agl_lock);\r\nthread_set_flags(agl_thread, SVC_STOPPING);\r\nspin_unlock(&lli->lli_agl_lock);\r\nwake_up(&agl_thread->t_ctl_waitq);\r\nCDEBUG(D_READA, "stop agl thread: sai %p pid %u\n",\r\nsai, (unsigned int)agl_thread->t_pid);\r\nl_wait_event(agl_thread->t_ctl_waitq,\r\nthread_is_stopped(agl_thread),\r\n&lwi);\r\n} else {\r\nthread_set_flags(agl_thread, SVC_STOPPED);\r\n}\r\nwhile (sai->sai_sent != sai->sai_replied) {\r\nlwi = LWI_TIMEOUT(msecs_to_jiffies(MSEC_PER_SEC >> 3),\r\nNULL, NULL);\r\nl_wait_event(sa_thread->t_ctl_waitq,\r\nsai->sai_sent == sai->sai_replied, &lwi);\r\n}\r\nsa_handle_callback(sai);\r\nspin_lock(&lli->lli_sa_lock);\r\nthread_set_flags(sa_thread, SVC_STOPPED);\r\nspin_unlock(&lli->lli_sa_lock);\r\nCDEBUG(D_READA, "statahead thread stopped: sai %p, parent %pd\n",\r\nsai, parent);\r\nwake_up(&sai->sai_waitq);\r\nwake_up(&sa_thread->t_ctl_waitq);\r\nll_sai_put(sai);\r\nreturn rc;\r\n}\r\nvoid ll_authorize_statahead(struct inode *dir, void *key)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nspin_lock(&lli->lli_sa_lock);\r\nif (!lli->lli_opendir_key && !lli->lli_sai) {\r\nLASSERT(!lli->lli_opendir_pid);\r\nlli->lli_opendir_key = key;\r\nlli->lli_opendir_pid = current_pid();\r\nlli->lli_sa_enabled = 1;\r\n}\r\nspin_unlock(&lli->lli_sa_lock);\r\n}\r\nvoid ll_deauthorize_statahead(struct inode *dir, void *key)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai;\r\nLASSERT(lli->lli_opendir_key == key);\r\nLASSERT(lli->lli_opendir_pid);\r\nCDEBUG(D_READA, "deauthorize statahead for "DFID"\n",\r\nPFID(&lli->lli_fid));\r\nspin_lock(&lli->lli_sa_lock);\r\nlli->lli_opendir_key = NULL;\r\nlli->lli_opendir_pid = 0;\r\nlli->lli_sa_enabled = 0;\r\nsai = lli->lli_sai;\r\nif (sai && thread_is_running(&sai->sai_thread)) {\r\nthread_set_flags(&sai->sai_thread, SVC_STOPPING);\r\nwake_up(&sai->sai_thread.t_ctl_waitq);\r\n}\r\nspin_unlock(&lli->lli_sa_lock);\r\n}\r\nstatic int is_first_dirent(struct inode *dir, struct dentry *dentry)\r\n{\r\nconst struct qstr *target = &dentry->d_name;\r\nstruct md_op_data *op_data;\r\nstruct page *page;\r\n__u64 pos = 0;\r\nint dot_de;\r\nint rc = LS_NOT_FIRST_DE;\r\nop_data = ll_prep_md_op_data(NULL, dir, dir, NULL, 0, 0,\r\nLUSTRE_OPC_ANY, dir);\r\nif (IS_ERR(op_data))\r\nreturn PTR_ERR(op_data);\r\nop_data->op_max_pages = ll_i2sbi(dir)->ll_md_brw_pages;\r\npage = ll_get_dir_page(dir, op_data, pos);\r\nwhile (1) {\r\nstruct lu_dirpage *dp;\r\nstruct lu_dirent *ent;\r\nif (IS_ERR(page)) {\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nrc = PTR_ERR(page);\r\nCERROR("%s: error reading dir "DFID" at %llu: opendir_pid = %u : rc = %d\n",\r\nll_get_fsname(dir->i_sb, NULL, 0),\r\nPFID(ll_inode2fid(dir)), pos,\r\nlli->lli_opendir_pid, rc);\r\nbreak;\r\n}\r\ndp = page_address(page);\r\nfor (ent = lu_dirent_start(dp); ent;\r\nent = lu_dirent_next(ent)) {\r\n__u64 hash;\r\nint namelen;\r\nchar *name;\r\nhash = le64_to_cpu(ent->lde_hash);\r\nif (unlikely(hash < pos))\r\ncontinue;\r\nnamelen = le16_to_cpu(ent->lde_namelen);\r\nif (unlikely(namelen == 0))\r\ncontinue;\r\nname = ent->lde_name;\r\nif (name[0] == '.') {\r\nif (namelen == 1)\r\ncontinue;\r\nelse if (name[1] == '.' && namelen == 2)\r\ncontinue;\r\nelse\r\ndot_de = 1;\r\n} else {\r\ndot_de = 0;\r\n}\r\nif (dot_de && target->name[0] != '.') {\r\nCDEBUG(D_READA, "%.*s skip hidden file %.*s\n",\r\ntarget->len, target->name,\r\nnamelen, name);\r\ncontinue;\r\n}\r\nif (target->len != namelen ||\r\nmemcmp(target->name, name, namelen) != 0)\r\nrc = LS_NOT_FIRST_DE;\r\nelse if (!dot_de)\r\nrc = LS_FIRST_DE;\r\nelse\r\nrc = LS_FIRST_DOT_DE;\r\nll_release_page(dir, page, false);\r\ngoto out;\r\n}\r\npos = le64_to_cpu(dp->ldp_hash_end);\r\nif (pos == MDS_DIR_END_OFF) {\r\nll_release_page(dir, page, false);\r\ngoto out;\r\n} else {\r\nll_release_page(dir, page,\r\nle32_to_cpu(dp->ldp_flags) &\r\nLDF_COLLIDE);\r\npage = ll_get_dir_page(dir, op_data, pos);\r\n}\r\n}\r\nout:\r\nll_finish_md_op_data(op_data);\r\nreturn rc;\r\n}\r\nstatic int revalidate_statahead_dentry(struct inode *dir,\r\nstruct ll_statahead_info *sai,\r\nstruct dentry **dentryp,\r\nbool unplug)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct sa_entry *entry = NULL;\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ll_dentry_data *ldd;\r\nint rc = 0;\r\nif ((*dentryp)->d_name.name[0] == '.') {\r\nif (sai->sai_ls_all ||\r\nsai->sai_miss_hidden >= sai->sai_skip_hidden) {\r\n} else {\r\nif (!sai->sai_ls_all)\r\nsai->sai_ls_all = 1;\r\nsai->sai_miss_hidden++;\r\nreturn -EAGAIN;\r\n}\r\n}\r\nif (unplug) {\r\nrc = 1;\r\ngoto out_unplug;\r\n}\r\nentry = sa_get(sai, &(*dentryp)->d_name);\r\nif (!entry) {\r\nrc = -EAGAIN;\r\ngoto out_unplug;\r\n}\r\nif (!sa_ready(entry) && sai->sai_in_readpage)\r\nsa_handle_callback(sai);\r\nif (!sa_ready(entry)) {\r\nspin_lock(&lli->lli_sa_lock);\r\nsai->sai_index_wait = entry->se_index;\r\nspin_unlock(&lli->lli_sa_lock);\r\nlwi = LWI_TIMEOUT_INTR(cfs_time_seconds(30), NULL,\r\nLWI_ON_SIGNAL_NOOP, NULL);\r\nrc = l_wait_event(sai->sai_waitq, sa_ready(entry), &lwi);\r\nif (rc < 0) {\r\nentry = NULL;\r\nrc = -EAGAIN;\r\ngoto out_unplug;\r\n}\r\n}\r\nif (entry->se_state == SA_ENTRY_SUCC && entry->se_inode) {\r\nstruct inode *inode = entry->se_inode;\r\nstruct lookup_intent it = { .it_op = IT_GETATTR,\r\n.it_lock_handle = entry->se_handle };\r\n__u64 bits;\r\nrc = md_revalidate_lock(ll_i2mdexp(dir), &it,\r\nll_inode2fid(inode), &bits);\r\nif (rc == 1) {\r\nif (!(*dentryp)->d_inode) {\r\nstruct dentry *alias;\r\nalias = ll_splice_alias(inode, *dentryp);\r\nif (IS_ERR(alias)) {\r\nll_intent_release(&it);\r\nrc = PTR_ERR(alias);\r\ngoto out_unplug;\r\n}\r\n*dentryp = alias;\r\nentry->se_inode = NULL;\r\n} else if ((*dentryp)->d_inode != inode) {\r\nCDEBUG(D_READA,\r\n"%s: stale dentry %pd inode "DFID", statahead inode "DFID"\n",\r\nll_get_fsname((*dentryp)->d_inode->i_sb,\r\nNULL, 0),\r\n*dentryp,\r\nPFID(ll_inode2fid((*dentryp)->d_inode)),\r\nPFID(ll_inode2fid(inode)));\r\nll_intent_release(&it);\r\nrc = -ESTALE;\r\ngoto out_unplug;\r\n}\r\nif ((bits & MDS_INODELOCK_LOOKUP) &&\r\nd_lustre_invalid(*dentryp))\r\nd_lustre_revalidate(*dentryp);\r\nll_intent_release(&it);\r\n}\r\n}\r\nout_unplug:\r\nldd = ll_d2d(*dentryp);\r\nldd->lld_sa_generation = lli->lli_sa_generation;\r\nsa_put(sai, entry);\r\nreturn rc;\r\n}\r\nstatic int start_statahead_thread(struct inode *dir, struct dentry *dentry)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(dir);\r\nstruct ll_statahead_info *sai = NULL;\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ptlrpc_thread *thread;\r\nstruct task_struct *task;\r\nstruct dentry *parent = dentry->d_parent;\r\nint rc;\r\nrc = is_first_dirent(dir, dentry);\r\nif (rc == LS_NOT_FIRST_DE) {\r\nrc = -EFAULT;\r\ngoto out;\r\n}\r\nsai = ll_sai_alloc(parent);\r\nif (!sai) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nsai->sai_ls_all = (rc == LS_FIRST_DOT_DE);\r\nspin_lock(&lli->lli_sa_lock);\r\nif (unlikely(lli->lli_sai || lli->lli_opendir_key ||\r\nlli->lli_opendir_pid != current->pid)) {\r\nspin_unlock(&lli->lli_sa_lock);\r\nrc = -EPERM;\r\ngoto out;\r\n}\r\nlli->lli_sai = sai;\r\nspin_unlock(&lli->lli_sa_lock);\r\natomic_inc(&ll_i2sbi(parent->d_inode)->ll_sa_running);\r\nCDEBUG(D_READA, "start statahead thread: [pid %d] [parent %pd]\n",\r\ncurrent_pid(), parent);\r\ntask = kthread_run(ll_statahead_thread, parent, "ll_sa_%u",\r\nlli->lli_opendir_pid);\r\nthread = &sai->sai_thread;\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nCERROR("can't start ll_sa thread, rc : %d\n", rc);\r\ngoto out;\r\n}\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_running(thread) || thread_is_stopped(thread),\r\n&lwi);\r\nll_sai_put(sai);\r\nreturn -EAGAIN;\r\nout:\r\nspin_lock(&lli->lli_sa_lock);\r\nlli->lli_sa_enabled = 0;\r\nlli->lli_sai = NULL;\r\nspin_unlock(&lli->lli_sa_lock);\r\nif (sai)\r\nll_sai_free(sai);\r\nreturn rc;\r\n}\r\nint ll_statahead(struct inode *dir, struct dentry **dentryp, bool unplug)\r\n{\r\nstruct ll_statahead_info *sai;\r\nsai = ll_sai_get(dir);\r\nif (sai) {\r\nint rc;\r\nrc = revalidate_statahead_dentry(dir, sai, dentryp, unplug);\r\nCDEBUG(D_READA, "revalidate statahead %pd: %d.\n",\r\n*dentryp, rc);\r\nll_sai_put(sai);\r\nreturn rc;\r\n}\r\nreturn start_statahead_thread(dir, *dentryp);\r\n}
