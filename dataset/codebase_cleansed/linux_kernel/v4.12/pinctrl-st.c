static struct st_pio_control *st_get_pio_control(\r\nstruct pinctrl_dev *pctldev, int pin)\r\n{\r\nstruct pinctrl_gpio_range *range =\r\npinctrl_find_gpio_range_from_pin(pctldev, pin);\r\nstruct st_gpio_bank *bank = gpio_range_to_bank(range);\r\nreturn &bank->pc;\r\n}\r\nstatic inline int st_gpio_bank(int gpio)\r\n{\r\nreturn gpio/ST_GPIO_PINS_PER_BANK;\r\n}\r\nstatic inline int st_gpio_pin(int gpio)\r\n{\r\nreturn gpio%ST_GPIO_PINS_PER_BANK;\r\n}\r\nstatic void st_pinconf_set_config(struct st_pio_control *pc,\r\nint pin, unsigned long config)\r\n{\r\nstruct regmap_field *output_enable = pc->oe;\r\nstruct regmap_field *pull_up = pc->pu;\r\nstruct regmap_field *open_drain = pc->od;\r\nunsigned int oe_value, pu_value, od_value;\r\nunsigned long mask = BIT(pin);\r\nif (output_enable) {\r\nregmap_field_read(output_enable, &oe_value);\r\noe_value &= ~mask;\r\nif (config & ST_PINCONF_OE)\r\noe_value |= mask;\r\nregmap_field_write(output_enable, oe_value);\r\n}\r\nif (pull_up) {\r\nregmap_field_read(pull_up, &pu_value);\r\npu_value &= ~mask;\r\nif (config & ST_PINCONF_PU)\r\npu_value |= mask;\r\nregmap_field_write(pull_up, pu_value);\r\n}\r\nif (open_drain) {\r\nregmap_field_read(open_drain, &od_value);\r\nod_value &= ~mask;\r\nif (config & ST_PINCONF_OD)\r\nod_value |= mask;\r\nregmap_field_write(open_drain, od_value);\r\n}\r\n}\r\nstatic void st_pctl_set_function(struct st_pio_control *pc,\r\nint pin_id, int function)\r\n{\r\nstruct regmap_field *alt = pc->alt;\r\nunsigned int val;\r\nint pin = st_gpio_pin(pin_id);\r\nint offset = pin * 4;\r\nif (!alt)\r\nreturn;\r\nregmap_field_read(alt, &val);\r\nval &= ~(0xf << offset);\r\nval |= function << offset;\r\nregmap_field_write(alt, val);\r\n}\r\nstatic unsigned int st_pctl_get_pin_function(struct st_pio_control *pc, int pin)\r\n{\r\nstruct regmap_field *alt = pc->alt;\r\nunsigned int val;\r\nint offset = pin * 4;\r\nif (!alt)\r\nreturn 0;\r\nregmap_field_read(alt, &val);\r\nreturn (val >> offset) & 0xf;\r\n}\r\nstatic unsigned long st_pinconf_delay_to_bit(unsigned int delay,\r\nconst struct st_pctl_data *data, unsigned long config)\r\n{\r\nconst unsigned int *delay_times;\r\nint num_delay_times, i, closest_index = -1;\r\nunsigned int closest_divergence = UINT_MAX;\r\nif (ST_PINCONF_UNPACK_OE(config)) {\r\ndelay_times = data->output_delays;\r\nnum_delay_times = data->noutput_delays;\r\n} else {\r\ndelay_times = data->input_delays;\r\nnum_delay_times = data->ninput_delays;\r\n}\r\nfor (i = 0; i < num_delay_times; i++) {\r\nunsigned int divergence = abs(delay - delay_times[i]);\r\nif (divergence == 0)\r\nreturn i;\r\nif (divergence < closest_divergence) {\r\nclosest_divergence = divergence;\r\nclosest_index = i;\r\n}\r\n}\r\npr_warn("Attempt to set delay %d, closest available %d\n",\r\ndelay, delay_times[closest_index]);\r\nreturn closest_index;\r\n}\r\nstatic unsigned long st_pinconf_bit_to_delay(unsigned int index,\r\nconst struct st_pctl_data *data, unsigned long output)\r\n{\r\nconst unsigned int *delay_times;\r\nint num_delay_times;\r\nif (output) {\r\ndelay_times = data->output_delays;\r\nnum_delay_times = data->noutput_delays;\r\n} else {\r\ndelay_times = data->input_delays;\r\nnum_delay_times = data->ninput_delays;\r\n}\r\nif (index < num_delay_times) {\r\nreturn delay_times[index];\r\n} else {\r\npr_warn("Delay not found in/out delay list\n");\r\nreturn 0;\r\n}\r\n}\r\nstatic void st_regmap_field_bit_set_clear_pin(struct regmap_field *field,\r\nint enable, int pin)\r\n{\r\nunsigned int val = 0;\r\nregmap_field_read(field, &val);\r\nif (enable)\r\nval |= BIT(pin);\r\nelse\r\nval &= ~BIT(pin);\r\nregmap_field_write(field, val);\r\n}\r\nstatic void st_pinconf_set_retime_packed(struct st_pinctrl *info,\r\nstruct st_pio_control *pc, unsigned long config, int pin)\r\n{\r\nconst struct st_pctl_data *data = info->data;\r\nstruct st_retime_packed *rt_p = &pc->rt.rt_p;\r\nunsigned int delay;\r\nst_regmap_field_bit_set_clear_pin(rt_p->clk1notclk0,\r\nST_PINCONF_UNPACK_RT_CLK(config), pin);\r\nst_regmap_field_bit_set_clear_pin(rt_p->clknotdata,\r\nST_PINCONF_UNPACK_RT_CLKNOTDATA(config), pin);\r\nst_regmap_field_bit_set_clear_pin(rt_p->double_edge,\r\nST_PINCONF_UNPACK_RT_DOUBLE_EDGE(config), pin);\r\nst_regmap_field_bit_set_clear_pin(rt_p->invertclk,\r\nST_PINCONF_UNPACK_RT_INVERTCLK(config), pin);\r\nst_regmap_field_bit_set_clear_pin(rt_p->retime,\r\nST_PINCONF_UNPACK_RT(config), pin);\r\ndelay = st_pinconf_delay_to_bit(ST_PINCONF_UNPACK_RT_DELAY(config),\r\ndata, config);\r\nst_regmap_field_bit_set_clear_pin(rt_p->delay_0, delay & 0x1, pin);\r\nst_regmap_field_bit_set_clear_pin(rt_p->delay_1, delay & 0x2, pin);\r\n}\r\nstatic void st_pinconf_set_retime_dedicated(struct st_pinctrl *info,\r\nstruct st_pio_control *pc, unsigned long config, int pin)\r\n{\r\nint input = ST_PINCONF_UNPACK_OE(config) ? 0 : 1;\r\nint clk = ST_PINCONF_UNPACK_RT_CLK(config);\r\nint clknotdata = ST_PINCONF_UNPACK_RT_CLKNOTDATA(config);\r\nint double_edge = ST_PINCONF_UNPACK_RT_DOUBLE_EDGE(config);\r\nint invertclk = ST_PINCONF_UNPACK_RT_INVERTCLK(config);\r\nint retime = ST_PINCONF_UNPACK_RT(config);\r\nunsigned long delay = st_pinconf_delay_to_bit(\r\nST_PINCONF_UNPACK_RT_DELAY(config),\r\ninfo->data, config);\r\nstruct st_retime_dedicated *rt_d = &pc->rt.rt_d;\r\nunsigned long retime_config =\r\n((clk) << RT_D_CFG_CLK_SHIFT) |\r\n((delay) << RT_D_CFG_DELAY_SHIFT) |\r\n((input) << RT_D_CFG_DELAY_INNOTOUT_SHIFT) |\r\n((retime) << RT_D_CFG_RETIME_SHIFT) |\r\n((clknotdata) << RT_D_CFG_CLKNOTDATA_SHIFT) |\r\n((invertclk) << RT_D_CFG_INVERTCLK_SHIFT) |\r\n((double_edge) << RT_D_CFG_DOUBLE_EDGE_SHIFT);\r\nregmap_field_write(rt_d->rt[pin], retime_config);\r\n}\r\nstatic void st_pinconf_get_direction(struct st_pio_control *pc,\r\nint pin, unsigned long *config)\r\n{\r\nunsigned int oe_value, pu_value, od_value;\r\nif (pc->oe) {\r\nregmap_field_read(pc->oe, &oe_value);\r\nif (oe_value & BIT(pin))\r\nST_PINCONF_PACK_OE(*config);\r\n}\r\nif (pc->pu) {\r\nregmap_field_read(pc->pu, &pu_value);\r\nif (pu_value & BIT(pin))\r\nST_PINCONF_PACK_PU(*config);\r\n}\r\nif (pc->od) {\r\nregmap_field_read(pc->od, &od_value);\r\nif (od_value & BIT(pin))\r\nST_PINCONF_PACK_OD(*config);\r\n}\r\n}\r\nstatic int st_pinconf_get_retime_packed(struct st_pinctrl *info,\r\nstruct st_pio_control *pc, int pin, unsigned long *config)\r\n{\r\nconst struct st_pctl_data *data = info->data;\r\nstruct st_retime_packed *rt_p = &pc->rt.rt_p;\r\nunsigned int delay_bits, delay, delay0, delay1, val;\r\nint output = ST_PINCONF_UNPACK_OE(*config);\r\nif (!regmap_field_read(rt_p->retime, &val) && (val & BIT(pin)))\r\nST_PINCONF_PACK_RT(*config);\r\nif (!regmap_field_read(rt_p->clk1notclk0, &val) && (val & BIT(pin)))\r\nST_PINCONF_PACK_RT_CLK(*config, 1);\r\nif (!regmap_field_read(rt_p->clknotdata, &val) && (val & BIT(pin)))\r\nST_PINCONF_PACK_RT_CLKNOTDATA(*config);\r\nif (!regmap_field_read(rt_p->double_edge, &val) && (val & BIT(pin)))\r\nST_PINCONF_PACK_RT_DOUBLE_EDGE(*config);\r\nif (!regmap_field_read(rt_p->invertclk, &val) && (val & BIT(pin)))\r\nST_PINCONF_PACK_RT_INVERTCLK(*config);\r\nregmap_field_read(rt_p->delay_0, &delay0);\r\nregmap_field_read(rt_p->delay_1, &delay1);\r\ndelay_bits = (((delay1 & BIT(pin)) ? 1 : 0) << 1) |\r\n(((delay0 & BIT(pin)) ? 1 : 0));\r\ndelay = st_pinconf_bit_to_delay(delay_bits, data, output);\r\nST_PINCONF_PACK_RT_DELAY(*config, delay);\r\nreturn 0;\r\n}\r\nstatic int st_pinconf_get_retime_dedicated(struct st_pinctrl *info,\r\nstruct st_pio_control *pc, int pin, unsigned long *config)\r\n{\r\nunsigned int value;\r\nunsigned long delay_bits, delay, rt_clk;\r\nint output = ST_PINCONF_UNPACK_OE(*config);\r\nstruct st_retime_dedicated *rt_d = &pc->rt.rt_d;\r\nregmap_field_read(rt_d->rt[pin], &value);\r\nrt_clk = (value & RT_D_CFG_CLK_MASK) >> RT_D_CFG_CLK_SHIFT;\r\nST_PINCONF_PACK_RT_CLK(*config, rt_clk);\r\ndelay_bits = (value & RT_D_CFG_DELAY_MASK) >> RT_D_CFG_DELAY_SHIFT;\r\ndelay = st_pinconf_bit_to_delay(delay_bits, info->data, output);\r\nST_PINCONF_PACK_RT_DELAY(*config, delay);\r\nif (value & RT_D_CFG_CLKNOTDATA_MASK)\r\nST_PINCONF_PACK_RT_CLKNOTDATA(*config);\r\nif (value & RT_D_CFG_DOUBLE_EDGE_MASK)\r\nST_PINCONF_PACK_RT_DOUBLE_EDGE(*config);\r\nif (value & RT_D_CFG_INVERTCLK_MASK)\r\nST_PINCONF_PACK_RT_INVERTCLK(*config);\r\nif (value & RT_D_CFG_RETIME_MASK)\r\nST_PINCONF_PACK_RT(*config);\r\nreturn 0;\r\n}\r\nstatic inline void __st_gpio_set(struct st_gpio_bank *bank,\r\nunsigned offset, int value)\r\n{\r\nif (value)\r\nwritel(BIT(offset), bank->base + REG_PIO_SET_POUT);\r\nelse\r\nwritel(BIT(offset), bank->base + REG_PIO_CLR_POUT);\r\n}\r\nstatic void st_gpio_direction(struct st_gpio_bank *bank,\r\nunsigned int gpio, unsigned int direction)\r\n{\r\nint offset = st_gpio_pin(gpio);\r\nint i = 0;\r\nfor (i = 0; i <= 2; i++) {\r\nif (direction & BIT(i))\r\nwritel(BIT(offset), bank->base + REG_PIO_SET_PC(i));\r\nelse\r\nwritel(BIT(offset), bank->base + REG_PIO_CLR_PC(i));\r\n}\r\n}\r\nstatic int st_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct st_gpio_bank *bank = gpiochip_get_data(chip);\r\nreturn !!(readl(bank->base + REG_PIO_PIN) & BIT(offset));\r\n}\r\nstatic void st_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct st_gpio_bank *bank = gpiochip_get_data(chip);\r\n__st_gpio_set(bank, offset, value);\r\n}\r\nstatic int st_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\npinctrl_gpio_direction_input(chip->base + offset);\r\nreturn 0;\r\n}\r\nstatic int st_gpio_direction_output(struct gpio_chip *chip,\r\nunsigned offset, int value)\r\n{\r\nstruct st_gpio_bank *bank = gpiochip_get_data(chip);\r\n__st_gpio_set(bank, offset, value);\r\npinctrl_gpio_direction_output(chip->base + offset);\r\nreturn 0;\r\n}\r\nstatic int st_gpio_get_direction(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct st_gpio_bank *bank = gpiochip_get_data(chip);\r\nstruct st_pio_control pc = bank->pc;\r\nunsigned long config;\r\nunsigned int direction = 0;\r\nunsigned int function;\r\nunsigned int value;\r\nint i = 0;\r\nfunction = st_pctl_get_pin_function(&pc, offset);\r\nif (function) {\r\nst_pinconf_get_direction(&pc, offset, &config);\r\nreturn !ST_PINCONF_UNPACK_OE(config);\r\n}\r\nfor (i = 0; i <= 2; i++) {\r\nvalue = readl(bank->base + REG_PIO_PC(i));\r\ndirection |= ((value >> offset) & 0x1) << i;\r\n}\r\nreturn (direction == ST_GPIO_DIRECTION_IN);\r\n}\r\nstatic int st_pctl_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->ngroups;\r\n}\r\nstatic const char *st_pctl_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->groups[selector].name;\r\n}\r\nstatic int st_pctl_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned selector, const unsigned **pins, unsigned *npins)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nif (selector >= info->ngroups)\r\nreturn -EINVAL;\r\n*pins = info->groups[selector].pins;\r\n*npins = info->groups[selector].npins;\r\nreturn 0;\r\n}\r\nstatic inline const struct st_pctl_group *st_pctl_find_group_by_name(\r\nconst struct st_pinctrl *info, const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < info->ngroups; i++) {\r\nif (!strcmp(info->groups[i].name, name))\r\nreturn &info->groups[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int st_pctl_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np, struct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct st_pctl_group *grp;\r\nstruct pinctrl_map *new_map;\r\nstruct device_node *parent;\r\nint map_num, i;\r\ngrp = st_pctl_find_group_by_name(info, np->name);\r\nif (!grp) {\r\ndev_err(info->dev, "unable to find group for node %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nmap_num = grp->npins + 1;\r\nnew_map = devm_kzalloc(pctldev->dev,\r\nsizeof(*new_map) * map_num, GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\ndevm_kfree(pctldev->dev, new_map);\r\nreturn -EINVAL;\r\n}\r\n*map = new_map;\r\n*num_maps = map_num;\r\nnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[0].data.mux.function = parent->name;\r\nnew_map[0].data.mux.group = np->name;\r\nof_node_put(parent);\r\nnew_map++;\r\nfor (i = 0; i < grp->npins; i++) {\r\nnew_map[i].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nnew_map[i].data.configs.group_or_pin =\r\npin_get_name(pctldev, grp->pins[i]);\r\nnew_map[i].data.configs.configs = &grp->pin_conf[i].config;\r\nnew_map[i].data.configs.num_configs = 1;\r\n}\r\ndev_info(pctldev->dev, "maps: function %s group %s num %d\n",\r\n(*map)->data.mux.function, grp->name, map_num);\r\nreturn 0;\r\n}\r\nstatic void st_pctl_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\n}\r\nstatic int st_pmx_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->nfunctions;\r\n}\r\nstatic const char *st_pmx_get_fname(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nreturn info->functions[selector].name;\r\n}\r\nstatic int st_pmx_get_groups(struct pinctrl_dev *pctldev,\r\nunsigned selector, const char * const **grps, unsigned * const ngrps)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\n*grps = info->functions[selector].groups;\r\n*ngrps = info->functions[selector].ngroups;\r\nreturn 0;\r\n}\r\nstatic int st_pmx_set_mux(struct pinctrl_dev *pctldev, unsigned fselector,\r\nunsigned group)\r\n{\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nstruct st_pinconf *conf = info->groups[group].pin_conf;\r\nstruct st_pio_control *pc;\r\nint i;\r\nfor (i = 0; i < info->groups[group].npins; i++) {\r\npc = st_get_pio_control(pctldev, conf[i].pin);\r\nst_pctl_set_function(pc, conf[i].pin, conf[i].altfunc);\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_pmx_set_gpio_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned gpio,\r\nbool input)\r\n{\r\nstruct st_gpio_bank *bank = gpio_range_to_bank(range);\r\nst_pctl_set_function(&bank->pc, gpio, 0);\r\nst_gpio_direction(bank, gpio, input ?\r\nST_GPIO_DIRECTION_IN : ST_GPIO_DIRECTION_OUT);\r\nreturn 0;\r\n}\r\nstatic void st_pinconf_get_retime(struct st_pinctrl *info,\r\nstruct st_pio_control *pc, int pin, unsigned long *config)\r\n{\r\nif (info->data->rt_style == st_retime_style_packed)\r\nst_pinconf_get_retime_packed(info, pc, pin, config);\r\nelse if (info->data->rt_style == st_retime_style_dedicated)\r\nif ((BIT(pin) & pc->rt_pin_mask))\r\nst_pinconf_get_retime_dedicated(info, pc,\r\npin, config);\r\n}\r\nstatic void st_pinconf_set_retime(struct st_pinctrl *info,\r\nstruct st_pio_control *pc, int pin, unsigned long config)\r\n{\r\nif (info->data->rt_style == st_retime_style_packed)\r\nst_pinconf_set_retime_packed(info, pc, config, pin);\r\nelse if (info->data->rt_style == st_retime_style_dedicated)\r\nif ((BIT(pin) & pc->rt_pin_mask))\r\nst_pinconf_set_retime_dedicated(info, pc,\r\nconfig, pin);\r\n}\r\nstatic int st_pinconf_set(struct pinctrl_dev *pctldev, unsigned pin_id,\r\nunsigned long *configs, unsigned num_configs)\r\n{\r\nint pin = st_gpio_pin(pin_id);\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nstruct st_pio_control *pc = st_get_pio_control(pctldev, pin_id);\r\nint i;\r\nfor (i = 0; i < num_configs; i++) {\r\nst_pinconf_set_config(pc, pin, configs[i]);\r\nst_pinconf_set_retime(info, pc, pin, configs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *config)\r\n{\r\nint pin = st_gpio_pin(pin_id);\r\nstruct st_pinctrl *info = pinctrl_dev_get_drvdata(pctldev);\r\nstruct st_pio_control *pc = st_get_pio_control(pctldev, pin_id);\r\n*config = 0;\r\nst_pinconf_get_direction(pc, pin, config);\r\nst_pinconf_get_retime(info, pc, pin, config);\r\nreturn 0;\r\n}\r\nstatic void st_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin_id)\r\n{\r\nstruct st_pio_control *pc;\r\nunsigned long config;\r\nunsigned int function;\r\nint offset = st_gpio_pin(pin_id);\r\nchar f[16];\r\nmutex_unlock(&pctldev->mutex);\r\npc = st_get_pio_control(pctldev, pin_id);\r\nst_pinconf_get(pctldev, pin_id, &config);\r\nmutex_lock(&pctldev->mutex);\r\nfunction = st_pctl_get_pin_function(pc, offset);\r\nif (function)\r\nsnprintf(f, 10, "Alt Fn %u", function);\r\nelse\r\nsnprintf(f, 5, "GPIO");\r\nseq_printf(s, "[OE:%d,PU:%ld,OD:%ld]\t%s\n"\r\n"\t\t[retime:%ld,invclk:%ld,clknotdat:%ld,"\r\n"de:%ld,rt-clk:%ld,rt-delay:%ld]",\r\n!st_gpio_get_direction(&pc_to_bank(pc)->gpio_chip, offset),\r\nST_PINCONF_UNPACK_PU(config),\r\nST_PINCONF_UNPACK_OD(config),\r\nf,\r\nST_PINCONF_UNPACK_RT(config),\r\nST_PINCONF_UNPACK_RT_INVERTCLK(config),\r\nST_PINCONF_UNPACK_RT_CLKNOTDATA(config),\r\nST_PINCONF_UNPACK_RT_DOUBLE_EDGE(config),\r\nST_PINCONF_UNPACK_RT_CLK(config),\r\nST_PINCONF_UNPACK_RT_DELAY(config));\r\n}\r\nstatic void st_pctl_dt_child_count(struct st_pinctrl *info,\r\nstruct device_node *np)\r\n{\r\nstruct device_node *child;\r\nfor_each_child_of_node(np, child) {\r\nif (of_property_read_bool(child, "gpio-controller")) {\r\ninfo->nbanks++;\r\n} else {\r\ninfo->nfunctions++;\r\ninfo->ngroups += of_get_child_count(child);\r\n}\r\n}\r\n}\r\nstatic int st_pctl_dt_setup_retime_packed(struct st_pinctrl *info,\r\nint bank, struct st_pio_control *pc)\r\n{\r\nstruct device *dev = info->dev;\r\nstruct regmap *rm = info->regmap;\r\nconst struct st_pctl_data *data = info->data;\r\nint reg = (data->rt + bank * RT_P_CFGS_PER_BANK) * 4;\r\nstruct st_retime_packed *rt_p = &pc->rt.rt_p;\r\nstruct reg_field clk1notclk0 = RT_P_CFG0_CLK1NOTCLK0_FIELD(reg);\r\nstruct reg_field delay_0 = RT_P_CFG0_DELAY_0_FIELD(reg);\r\nstruct reg_field delay_1 = RT_P_CFG0_DELAY_1_FIELD(reg);\r\nstruct reg_field invertclk = RT_P_CFG1_INVERTCLK_FIELD(reg + 4);\r\nstruct reg_field retime = RT_P_CFG1_RETIME_FIELD(reg + 4);\r\nstruct reg_field clknotdata = RT_P_CFG1_CLKNOTDATA_FIELD(reg + 4);\r\nstruct reg_field double_edge = RT_P_CFG1_DOUBLE_EDGE_FIELD(reg + 4);\r\nrt_p->clk1notclk0 = devm_regmap_field_alloc(dev, rm, clk1notclk0);\r\nrt_p->delay_0 = devm_regmap_field_alloc(dev, rm, delay_0);\r\nrt_p->delay_1 = devm_regmap_field_alloc(dev, rm, delay_1);\r\nrt_p->invertclk = devm_regmap_field_alloc(dev, rm, invertclk);\r\nrt_p->retime = devm_regmap_field_alloc(dev, rm, retime);\r\nrt_p->clknotdata = devm_regmap_field_alloc(dev, rm, clknotdata);\r\nrt_p->double_edge = devm_regmap_field_alloc(dev, rm, double_edge);\r\nif (IS_ERR(rt_p->clk1notclk0) || IS_ERR(rt_p->delay_0) ||\r\nIS_ERR(rt_p->delay_1) || IS_ERR(rt_p->invertclk) ||\r\nIS_ERR(rt_p->retime) || IS_ERR(rt_p->clknotdata) ||\r\nIS_ERR(rt_p->double_edge))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int st_pctl_dt_setup_retime_dedicated(struct st_pinctrl *info,\r\nint bank, struct st_pio_control *pc)\r\n{\r\nstruct device *dev = info->dev;\r\nstruct regmap *rm = info->regmap;\r\nconst struct st_pctl_data *data = info->data;\r\nint reg_offset = (data->rt + bank * RT_D_CFGS_PER_BANK) * 4;\r\nstruct st_retime_dedicated *rt_d = &pc->rt.rt_d;\r\nunsigned int j;\r\nu32 pin_mask = pc->rt_pin_mask;\r\nfor (j = 0; j < RT_D_CFGS_PER_BANK; j++) {\r\nif (BIT(j) & pin_mask) {\r\nstruct reg_field reg = REG_FIELD(reg_offset, 0, 31);\r\nrt_d->rt[j] = devm_regmap_field_alloc(dev, rm, reg);\r\nif (IS_ERR(rt_d->rt[j]))\r\nreturn -EINVAL;\r\nreg_offset += 4;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_pctl_dt_setup_retime(struct st_pinctrl *info,\r\nint bank, struct st_pio_control *pc)\r\n{\r\nconst struct st_pctl_data *data = info->data;\r\nif (data->rt_style == st_retime_style_packed)\r\nreturn st_pctl_dt_setup_retime_packed(info, bank, pc);\r\nelse if (data->rt_style == st_retime_style_dedicated)\r\nreturn st_pctl_dt_setup_retime_dedicated(info, bank, pc);\r\nreturn -EINVAL;\r\n}\r\nstatic struct regmap_field *st_pc_get_value(struct device *dev,\r\nstruct regmap *regmap, int bank,\r\nint data, int lsb, int msb)\r\n{\r\nstruct reg_field reg = REG_FIELD((data + bank) * 4, lsb, msb);\r\nif (data < 0)\r\nreturn NULL;\r\nreturn devm_regmap_field_alloc(dev, regmap, reg);\r\n}\r\nstatic void st_parse_syscfgs(struct st_pinctrl *info, int bank,\r\nstruct device_node *np)\r\n{\r\nconst struct st_pctl_data *data = info->data;\r\nint lsb = (bank%4) * ST_GPIO_PINS_PER_BANK;\r\nint msb = lsb + ST_GPIO_PINS_PER_BANK - 1;\r\nstruct st_pio_control *pc = &info->banks[bank].pc;\r\nstruct device *dev = info->dev;\r\nstruct regmap *regmap = info->regmap;\r\npc->alt = st_pc_get_value(dev, regmap, bank, data->alt, 0, 31);\r\npc->oe = st_pc_get_value(dev, regmap, bank/4, data->oe, lsb, msb);\r\npc->pu = st_pc_get_value(dev, regmap, bank/4, data->pu, lsb, msb);\r\npc->od = st_pc_get_value(dev, regmap, bank/4, data->od, lsb, msb);\r\npc->rt_pin_mask = 0xff;\r\nof_property_read_u32(np, "st,retime-pin-mask", &pc->rt_pin_mask);\r\nst_pctl_dt_setup_retime(info, bank, pc);\r\nreturn;\r\n}\r\nstatic int st_pctl_dt_parse_groups(struct device_node *np,\r\nstruct st_pctl_group *grp, struct st_pinctrl *info, int idx)\r\n{\r\nconst __be32 *list;\r\nstruct property *pp;\r\nstruct st_pinconf *conf;\r\nstruct device_node *pins;\r\nint i = 0, npins = 0, nr_props;\r\npins = of_get_child_by_name(np, "st,pins");\r\nif (!pins)\r\nreturn -ENODATA;\r\nfor_each_property_of_node(pins, pp) {\r\nif (!strcmp(pp->name, "name"))\r\ncontinue;\r\nif (pp->length / sizeof(__be32) >= OF_GPIO_ARGS_MIN) {\r\nnpins++;\r\n} else {\r\npr_warn("Invalid st,pins in %s node\n", np->name);\r\nreturn -EINVAL;\r\n}\r\n}\r\ngrp->npins = npins;\r\ngrp->name = np->name;\r\ngrp->pins = devm_kzalloc(info->dev, npins * sizeof(u32), GFP_KERNEL);\r\ngrp->pin_conf = devm_kzalloc(info->dev,\r\nnpins * sizeof(*conf), GFP_KERNEL);\r\nif (!grp->pins || !grp->pin_conf)\r\nreturn -ENOMEM;\r\nfor_each_property_of_node(pins, pp) {\r\nif (!strcmp(pp->name, "name"))\r\ncontinue;\r\nnr_props = pp->length/sizeof(u32);\r\nlist = pp->value;\r\nconf = &grp->pin_conf[i];\r\nbe32_to_cpup(list++);\r\nbe32_to_cpup(list++);\r\nconf->pin = of_get_named_gpio(pins, pp->name, 0);\r\nconf->name = pp->name;\r\ngrp->pins[i] = conf->pin;\r\nconf->altfunc = be32_to_cpup(list++);\r\nconf->config = 0;\r\nconf->config |= be32_to_cpup(list++);\r\nif (nr_props >= OF_GPIO_ARGS_MIN + OF_RT_ARGS_MIN) {\r\nconf->config |= be32_to_cpup(list++);\r\nconf->config |= be32_to_cpup(list++);\r\nif (nr_props > OF_GPIO_ARGS_MIN + OF_RT_ARGS_MIN)\r\nconf->config |= be32_to_cpup(list++);\r\n}\r\ni++;\r\n}\r\nof_node_put(pins);\r\nreturn 0;\r\n}\r\nstatic int st_pctl_parse_functions(struct device_node *np,\r\nstruct st_pinctrl *info, u32 index, int *grp_index)\r\n{\r\nstruct device_node *child;\r\nstruct st_pmx_func *func;\r\nstruct st_pctl_group *grp;\r\nint ret, i;\r\nfunc = &info->functions[index];\r\nfunc->name = np->name;\r\nfunc->ngroups = of_get_child_count(np);\r\nif (func->ngroups == 0) {\r\ndev_err(info->dev, "No groups defined\n");\r\nreturn -EINVAL;\r\n}\r\nfunc->groups = devm_kzalloc(info->dev,\r\nfunc->ngroups * sizeof(char *), GFP_KERNEL);\r\nif (!func->groups)\r\nreturn -ENOMEM;\r\ni = 0;\r\nfor_each_child_of_node(np, child) {\r\nfunc->groups[i] = child->name;\r\ngrp = &info->groups[*grp_index];\r\n*grp_index += 1;\r\nret = st_pctl_dt_parse_groups(child, grp, info, i++);\r\nif (ret)\r\nreturn ret;\r\n}\r\ndev_info(info->dev, "Function[%d\t name:%s,\tgroups:%d]\n",\r\nindex, func->name, func->ngroups);\r\nreturn 0;\r\n}\r\nstatic void st_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct st_gpio_bank *bank = gpiochip_get_data(gc);\r\nwritel(BIT(d->hwirq), bank->base + REG_PIO_CLR_PMASK);\r\n}\r\nstatic void st_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct st_gpio_bank *bank = gpiochip_get_data(gc);\r\nwritel(BIT(d->hwirq), bank->base + REG_PIO_SET_PMASK);\r\n}\r\nstatic int st_gpio_irq_request_resources(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nst_gpio_direction_input(gc, d->hwirq);\r\nreturn gpiochip_lock_as_irq(gc, d->hwirq);\r\n}\r\nstatic void st_gpio_irq_release_resources(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\ngpiochip_unlock_as_irq(gc, d->hwirq);\r\n}\r\nstatic int st_gpio_irq_set_type(struct irq_data *d, unsigned type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct st_gpio_bank *bank = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nint comp, pin = d->hwirq;\r\nu32 val;\r\nu32 pin_edge_conf = 0;\r\nswitch (type) {\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\ncomp = 0;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\ncomp = 0;\r\npin_edge_conf = ST_IRQ_FALLING_EDGE_CONF(pin);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\ncomp = 1;\r\nbreak;\r\ncase IRQ_TYPE_EDGE_RISING:\r\ncomp = 1;\r\npin_edge_conf = ST_IRQ_RISING_EDGE_CONF(pin);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\ncomp = st_gpio_get(&bank->gpio_chip, pin);\r\npin_edge_conf = ST_IRQ_BOTH_EDGE_CONF(pin);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank->irq_edge_conf &= ~(ST_IRQ_EDGE_MASK << (\r\npin * ST_IRQ_EDGE_CONF_BITS_PER_PIN));\r\nbank->irq_edge_conf |= pin_edge_conf;\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nval = readl(bank->base + REG_PIO_PCOMP);\r\nval &= ~BIT(pin);\r\nval |= (comp << pin);\r\nwritel(val, bank->base + REG_PIO_PCOMP);\r\nreturn 0;\r\n}\r\nstatic void __gpio_irq_handler(struct st_gpio_bank *bank)\r\n{\r\nunsigned long port_in, port_mask, port_comp, active_irqs;\r\nunsigned long bank_edge_mask, flags;\r\nint n, val, ecfg;\r\nspin_lock_irqsave(&bank->lock, flags);\r\nbank_edge_mask = bank->irq_edge_conf;\r\nspin_unlock_irqrestore(&bank->lock, flags);\r\nfor (;;) {\r\nport_in = readl(bank->base + REG_PIO_PIN);\r\nport_comp = readl(bank->base + REG_PIO_PCOMP);\r\nport_mask = readl(bank->base + REG_PIO_PMASK);\r\nactive_irqs = (port_in ^ port_comp) & port_mask;\r\nif (active_irqs == 0)\r\nbreak;\r\nfor_each_set_bit(n, &active_irqs, BITS_PER_LONG) {\r\necfg = ST_IRQ_EDGE_CONF(bank_edge_mask, n);\r\nif (ecfg) {\r\nval = st_gpio_get(&bank->gpio_chip, n);\r\nwritel(BIT(n),\r\nval ? bank->base + REG_PIO_SET_PCOMP :\r\nbank->base + REG_PIO_CLR_PCOMP);\r\nif (ecfg != ST_IRQ_EDGE_BOTH &&\r\n!((ecfg & ST_IRQ_EDGE_FALLING) ^ val))\r\ncontinue;\r\n}\r\ngeneric_handle_irq(irq_find_mapping(bank->gpio_chip.irqdomain, n));\r\n}\r\n}\r\n}\r\nstatic void st_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nstruct st_gpio_bank *bank = gpiochip_get_data(gc);\r\nchained_irq_enter(chip, desc);\r\n__gpio_irq_handler(bank);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void st_gpio_irqmux_handler(struct irq_desc *desc)\r\n{\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct st_pinctrl *info = irq_desc_get_handler_data(desc);\r\nunsigned long status;\r\nint n;\r\nchained_irq_enter(chip, desc);\r\nstatus = readl(info->irqmux_base);\r\nfor_each_set_bit(n, &status, info->nbanks)\r\n__gpio_irq_handler(&info->banks[n]);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int st_gpiolib_register_bank(struct st_pinctrl *info,\r\nint bank_nr, struct device_node *np)\r\n{\r\nstruct st_gpio_bank *bank = &info->banks[bank_nr];\r\nstruct pinctrl_gpio_range *range = &bank->range;\r\nstruct device *dev = info->dev;\r\nint bank_num = of_alias_get_id(np, "gpio");\r\nstruct resource res, irq_res;\r\nint gpio_irq = 0, err;\r\nif (of_address_to_resource(np, 0, &res))\r\nreturn -ENODEV;\r\nbank->base = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(bank->base))\r\nreturn PTR_ERR(bank->base);\r\nbank->gpio_chip = st_gpio_template;\r\nbank->gpio_chip.base = bank_num * ST_GPIO_PINS_PER_BANK;\r\nbank->gpio_chip.ngpio = ST_GPIO_PINS_PER_BANK;\r\nbank->gpio_chip.of_node = np;\r\nbank->gpio_chip.parent = dev;\r\nspin_lock_init(&bank->lock);\r\nof_property_read_string(np, "st,bank-name", &range->name);\r\nbank->gpio_chip.label = range->name;\r\nrange->id = bank_num;\r\nrange->pin_base = range->base = range->id * ST_GPIO_PINS_PER_BANK;\r\nrange->npins = bank->gpio_chip.ngpio;\r\nrange->gc = &bank->gpio_chip;\r\nerr = gpiochip_add_data(&bank->gpio_chip, bank);\r\nif (err) {\r\ndev_err(dev, "Failed to add gpiochip(%d)!\n", bank_num);\r\nreturn err;\r\n}\r\ndev_info(dev, "%s bank added.\n", range->name);\r\nif (of_irq_to_resource(np, 0, &irq_res)) {\r\ngpio_irq = irq_res.start;\r\ngpiochip_set_chained_irqchip(&bank->gpio_chip, &st_gpio_irqchip,\r\ngpio_irq, st_gpio_irq_handler);\r\n}\r\nif (info->irqmux_base || gpio_irq > 0) {\r\nerr = gpiochip_irqchip_add(&bank->gpio_chip, &st_gpio_irqchip,\r\n0, handle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (err) {\r\ngpiochip_remove(&bank->gpio_chip);\r\ndev_info(dev, "could not add irqchip\n");\r\nreturn err;\r\n}\r\n} else {\r\ndev_info(dev, "No IRQ support for %s bank\n", np->full_name);\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_pctl_probe_dt(struct platform_device *pdev,\r\nstruct pinctrl_desc *pctl_desc, struct st_pinctrl *info)\r\n{\r\nint ret = 0;\r\nint i = 0, j = 0, k = 0, bank;\r\nstruct pinctrl_pin_desc *pdesc;\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nint grp_index = 0;\r\nint irq = 0;\r\nstruct resource *res;\r\nst_pctl_dt_child_count(info, np);\r\nif (!info->nbanks) {\r\ndev_err(&pdev->dev, "you need atleast one gpio bank\n");\r\nreturn -EINVAL;\r\n}\r\ndev_info(&pdev->dev, "nbanks = %d\n", info->nbanks);\r\ndev_info(&pdev->dev, "nfunctions = %d\n", info->nfunctions);\r\ndev_info(&pdev->dev, "ngroups = %d\n", info->ngroups);\r\ninfo->functions = devm_kzalloc(&pdev->dev,\r\ninfo->nfunctions * sizeof(*info->functions), GFP_KERNEL);\r\ninfo->groups = devm_kzalloc(&pdev->dev,\r\ninfo->ngroups * sizeof(*info->groups) , GFP_KERNEL);\r\ninfo->banks = devm_kzalloc(&pdev->dev,\r\ninfo->nbanks * sizeof(*info->banks), GFP_KERNEL);\r\nif (!info->functions || !info->groups || !info->banks)\r\nreturn -ENOMEM;\r\ninfo->regmap = syscon_regmap_lookup_by_phandle(np, "st,syscfg");\r\nif (IS_ERR(info->regmap)) {\r\ndev_err(info->dev, "No syscfg phandle specified\n");\r\nreturn PTR_ERR(info->regmap);\r\n}\r\ninfo->data = of_match_node(st_pctl_of_match, np)->data;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq > 0) {\r\nres = platform_get_resource_byname(pdev,\r\nIORESOURCE_MEM, "irqmux");\r\ninfo->irqmux_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(info->irqmux_base))\r\nreturn PTR_ERR(info->irqmux_base);\r\nirq_set_chained_handler_and_data(irq, st_gpio_irqmux_handler,\r\ninfo);\r\n}\r\npctl_desc->npins = info->nbanks * ST_GPIO_PINS_PER_BANK;\r\npdesc = devm_kzalloc(&pdev->dev,\r\nsizeof(*pdesc) * pctl_desc->npins, GFP_KERNEL);\r\nif (!pdesc)\r\nreturn -ENOMEM;\r\npctl_desc->pins = pdesc;\r\nbank = 0;\r\nfor_each_child_of_node(np, child) {\r\nif (of_property_read_bool(child, "gpio-controller")) {\r\nconst char *bank_name = NULL;\r\nret = st_gpiolib_register_bank(info, bank, child);\r\nif (ret)\r\nreturn ret;\r\nk = info->banks[bank].range.pin_base;\r\nbank_name = info->banks[bank].range.name;\r\nfor (j = 0; j < ST_GPIO_PINS_PER_BANK; j++, k++) {\r\npdesc->number = k;\r\npdesc->name = kasprintf(GFP_KERNEL, "%s[%d]",\r\nbank_name, j);\r\npdesc++;\r\n}\r\nst_parse_syscfgs(info, bank, child);\r\nbank++;\r\n} else {\r\nret = st_pctl_parse_functions(child, info,\r\ni++, &grp_index);\r\nif (ret) {\r\ndev_err(&pdev->dev, "No functions found.\n");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int st_pctl_probe(struct platform_device *pdev)\r\n{\r\nstruct st_pinctrl *info;\r\nstruct pinctrl_desc *pctl_desc;\r\nint ret, i;\r\nif (!pdev->dev.of_node) {\r\ndev_err(&pdev->dev, "device node not found.\n");\r\nreturn -EINVAL;\r\n}\r\npctl_desc = devm_kzalloc(&pdev->dev, sizeof(*pctl_desc), GFP_KERNEL);\r\nif (!pctl_desc)\r\nreturn -ENOMEM;\r\ninfo = devm_kzalloc(&pdev->dev, sizeof(*info), GFP_KERNEL);\r\nif (!info)\r\nreturn -ENOMEM;\r\ninfo->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, info);\r\nret = st_pctl_probe_dt(pdev, pctl_desc, info);\r\nif (ret)\r\nreturn ret;\r\npctl_desc->owner = THIS_MODULE;\r\npctl_desc->pctlops = &st_pctlops;\r\npctl_desc->pmxops = &st_pmxops;\r\npctl_desc->confops = &st_confops;\r\npctl_desc->name = dev_name(&pdev->dev);\r\ninfo->pctl = devm_pinctrl_register(&pdev->dev, pctl_desc, info);\r\nif (IS_ERR(info->pctl)) {\r\ndev_err(&pdev->dev, "Failed pinctrl registration\n");\r\nreturn PTR_ERR(info->pctl);\r\n}\r\nfor (i = 0; i < info->nbanks; i++)\r\npinctrl_add_gpio_range(info->pctl, &info->banks[i].range);\r\nreturn 0;\r\n}\r\nstatic int __init st_pctl_init(void)\r\n{\r\nreturn platform_driver_register(&st_pctl_driver);\r\n}
