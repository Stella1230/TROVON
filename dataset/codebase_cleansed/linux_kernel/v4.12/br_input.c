static int\r\nbr_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nbr_drop_fake_rtable(skb);\r\nreturn netif_receive_skb(skb);\r\n}\r\nstatic int br_pass_frame_up(struct sk_buff *skb)\r\n{\r\nstruct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;\r\nstruct net_bridge *br = netdev_priv(brdev);\r\nstruct net_bridge_vlan_group *vg;\r\nstruct pcpu_sw_netstats *brstats = this_cpu_ptr(br->stats);\r\nu64_stats_update_begin(&brstats->syncp);\r\nbrstats->rx_packets++;\r\nbrstats->rx_bytes += skb->len;\r\nu64_stats_update_end(&brstats->syncp);\r\nvg = br_vlan_group_rcu(br);\r\nif (!(brdev->flags & IFF_PROMISC) &&\r\n!br_allowed_egress(vg, skb)) {\r\nkfree_skb(skb);\r\nreturn NET_RX_DROP;\r\n}\r\nindev = skb->dev;\r\nskb->dev = brdev;\r\nskb = br_handle_vlan(br, NULL, vg, skb);\r\nif (!skb)\r\nreturn NET_RX_DROP;\r\nbr_multicast_count(br, NULL, skb, br_multicast_igmp_type(skb),\r\nBR_MCAST_DIR_TX);\r\nreturn NF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN,\r\ndev_net(indev), NULL, skb, indev, NULL,\r\nbr_netif_receive_skb);\r\n}\r\nstatic void br_do_proxy_arp(struct sk_buff *skb, struct net_bridge *br,\r\nu16 vid, struct net_bridge_port *p)\r\n{\r\nstruct net_device *dev = br->dev;\r\nstruct neighbour *n;\r\nstruct arphdr *parp;\r\nu8 *arpptr, *sha;\r\n__be32 sip, tip;\r\nBR_INPUT_SKB_CB(skb)->proxyarp_replied = false;\r\nif ((dev->flags & IFF_NOARP) ||\r\n!pskb_may_pull(skb, arp_hdr_len(dev)))\r\nreturn;\r\nparp = arp_hdr(skb);\r\nif (parp->ar_pro != htons(ETH_P_IP) ||\r\nparp->ar_op != htons(ARPOP_REQUEST) ||\r\nparp->ar_hln != dev->addr_len ||\r\nparp->ar_pln != 4)\r\nreturn;\r\narpptr = (u8 *)parp + sizeof(struct arphdr);\r\nsha = arpptr;\r\narpptr += dev->addr_len;\r\nmemcpy(&sip, arpptr, sizeof(sip));\r\narpptr += sizeof(sip);\r\narpptr += dev->addr_len;\r\nmemcpy(&tip, arpptr, sizeof(tip));\r\nif (ipv4_is_loopback(tip) ||\r\nipv4_is_multicast(tip))\r\nreturn;\r\nn = neigh_lookup(&arp_tbl, &tip, dev);\r\nif (n) {\r\nstruct net_bridge_fdb_entry *f;\r\nif (!(n->nud_state & NUD_VALID)) {\r\nneigh_release(n);\r\nreturn;\r\n}\r\nf = br_fdb_find_rcu(br, n->ha, vid);\r\nif (f && ((p->flags & BR_PROXYARP) ||\r\n(f->dst && (f->dst->flags & BR_PROXYARP_WIFI)))) {\r\narp_send(ARPOP_REPLY, ETH_P_ARP, sip, skb->dev, tip,\r\nsha, n->ha, sha);\r\nBR_INPUT_SKB_CB(skb)->proxyarp_replied = true;\r\n}\r\nneigh_release(n);\r\n}\r\n}\r\nint br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nenum br_pkt_type pkt_type = BR_PKT_UNICAST;\r\nstruct net_bridge_fdb_entry *dst = NULL;\r\nstruct net_bridge_mdb_entry *mdst;\r\nbool local_rcv, mcast_hit = false;\r\nstruct net_bridge *br;\r\nu16 vid = 0;\r\nif (!p || p->state == BR_STATE_DISABLED)\r\ngoto drop;\r\nif (!br_allowed_ingress(p->br, nbp_vlan_group_rcu(p), skb, &vid))\r\ngoto out;\r\nnbp_switchdev_frame_mark(p, skb);\r\nbr = p->br;\r\nif (p->flags & BR_LEARNING)\r\nbr_fdb_update(br, p, eth_hdr(skb)->h_source, vid, false);\r\nlocal_rcv = !!(br->dev->flags & IFF_PROMISC);\r\nif (is_multicast_ether_addr(dest)) {\r\nif (is_broadcast_ether_addr(dest)) {\r\npkt_type = BR_PKT_BROADCAST;\r\nlocal_rcv = true;\r\n} else {\r\npkt_type = BR_PKT_MULTICAST;\r\nif (br_multicast_rcv(br, p, skb, vid))\r\ngoto drop;\r\n}\r\n}\r\nif (p->state == BR_STATE_LEARNING)\r\ngoto drop;\r\nBR_INPUT_SKB_CB(skb)->brdev = br->dev;\r\nif (IS_ENABLED(CONFIG_INET) && skb->protocol == htons(ETH_P_ARP))\r\nbr_do_proxy_arp(skb, br, vid, p);\r\nswitch (pkt_type) {\r\ncase BR_PKT_MULTICAST:\r\nmdst = br_mdb_get(br, skb, vid);\r\nif ((mdst || BR_INPUT_SKB_CB_MROUTERS_ONLY(skb)) &&\r\nbr_multicast_querier_exists(br, eth_hdr(skb))) {\r\nif ((mdst && mdst->mglist) ||\r\nbr_multicast_is_router(br)) {\r\nlocal_rcv = true;\r\nbr->dev->stats.multicast++;\r\n}\r\nmcast_hit = true;\r\n} else {\r\nlocal_rcv = true;\r\nbr->dev->stats.multicast++;\r\n}\r\nbreak;\r\ncase BR_PKT_UNICAST:\r\ndst = br_fdb_find_rcu(br, dest, vid);\r\ndefault:\r\nbreak;\r\n}\r\nif (dst) {\r\nunsigned long now = jiffies;\r\nif (dst->is_local)\r\nreturn br_pass_frame_up(skb);\r\nif (now != dst->used)\r\ndst->used = now;\r\nbr_forward(dst->dst, skb, local_rcv, false);\r\n} else {\r\nif (!mcast_hit)\r\nbr_flood(br, skb, pkt_type, local_rcv, false);\r\nelse\r\nbr_multicast_flood(mdst, skb, local_rcv, false);\r\n}\r\nif (local_rcv)\r\nreturn br_pass_frame_up(skb);\r\nout:\r\nreturn 0;\r\ndrop:\r\nkfree_skb(skb);\r\ngoto out;\r\n}\r\nstatic void __br_handle_local_finish(struct sk_buff *skb)\r\n{\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\nu16 vid = 0;\r\nif (p->flags & BR_LEARNING && br_should_learn(p, skb, &vid))\r\nbr_fdb_update(p->br, p, eth_hdr(skb)->h_source, vid, false);\r\n}\r\nstatic int br_handle_local_finish(struct net *net, struct sock *sk, struct sk_buff *skb)\r\n{\r\nstruct net_bridge_port *p = br_port_get_rcu(skb->dev);\r\n__br_handle_local_finish(skb);\r\nBR_INPUT_SKB_CB(skb)->brdev = p->br->dev;\r\nbr_pass_frame_up(skb);\r\nreturn 0;\r\n}\r\nrx_handler_result_t br_handle_frame(struct sk_buff **pskb)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct sk_buff *skb = *pskb;\r\nconst unsigned char *dest = eth_hdr(skb)->h_dest;\r\nbr_should_route_hook_t *rhook;\r\nif (unlikely(skb->pkt_type == PACKET_LOOPBACK))\r\nreturn RX_HANDLER_PASS;\r\nif (!is_valid_ether_addr(eth_hdr(skb)->h_source))\r\ngoto drop;\r\nskb = skb_share_check(skb, GFP_ATOMIC);\r\nif (!skb)\r\nreturn RX_HANDLER_CONSUMED;\r\np = br_port_get_rcu(skb->dev);\r\nif (p->flags & BR_VLAN_TUNNEL) {\r\nif (br_handle_ingress_vlan_tunnel(skb, p,\r\nnbp_vlan_group_rcu(p)))\r\ngoto drop;\r\n}\r\nif (unlikely(is_link_local_ether_addr(dest))) {\r\nu16 fwd_mask = p->br->group_fwd_mask_required;\r\nswitch (dest[5]) {\r\ncase 0x00:\r\nif (p->br->stp_enabled == BR_NO_STP ||\r\nfwd_mask & (1u << dest[5]))\r\ngoto forward;\r\n*pskb = skb;\r\n__br_handle_local_finish(skb);\r\nreturn RX_HANDLER_PASS;\r\ncase 0x01:\r\ngoto drop;\r\ncase 0x0E:\r\nfwd_mask |= p->br->group_fwd_mask;\r\nif (fwd_mask & (1u << dest[5]))\r\ngoto forward;\r\n*pskb = skb;\r\n__br_handle_local_finish(skb);\r\nreturn RX_HANDLER_PASS;\r\ndefault:\r\nfwd_mask |= p->br->group_fwd_mask;\r\nif (fwd_mask & (1u << dest[5]))\r\ngoto forward;\r\n}\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_IN, dev_net(skb->dev),\r\nNULL, skb, skb->dev, NULL, br_handle_local_finish);\r\nreturn RX_HANDLER_CONSUMED;\r\n}\r\nforward:\r\nswitch (p->state) {\r\ncase BR_STATE_FORWARDING:\r\nrhook = rcu_dereference(br_should_route_hook);\r\nif (rhook) {\r\nif ((*rhook)(skb)) {\r\n*pskb = skb;\r\nreturn RX_HANDLER_PASS;\r\n}\r\ndest = eth_hdr(skb)->h_dest;\r\n}\r\ncase BR_STATE_LEARNING:\r\nif (ether_addr_equal(p->br->dev->dev_addr, dest))\r\nskb->pkt_type = PACKET_HOST;\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_PRE_ROUTING,\r\ndev_net(skb->dev), NULL, skb, skb->dev, NULL,\r\nbr_handle_frame_finish);\r\nbreak;\r\ndefault:\r\ndrop:\r\nkfree_skb(skb);\r\n}\r\nreturn RX_HANDLER_CONSUMED;\r\n}
