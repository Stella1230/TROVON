static u16 af9035_checksum(const u8 *buf, size_t len)\r\n{\r\nsize_t i;\r\nu16 checksum = 0;\r\nfor (i = 1; i < len; i++) {\r\nif (i % 2)\r\nchecksum += buf[i] << 8;\r\nelse\r\nchecksum += buf[i];\r\n}\r\nchecksum = ~checksum;\r\nreturn checksum;\r\n}\r\nstatic int af9035_ctrl_msg(struct dvb_usb_device *d, struct usb_req *req)\r\n{\r\n#define REQ_HDR_LEN 4\r\n#define ACK_HDR_LEN 3\r\n#define CHECKSUM_LEN 2\r\n#define USB_TIMEOUT 2000\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\nint ret, wlen, rlen;\r\nu16 checksum, tmp_checksum;\r\nmutex_lock(&d->usb_mutex);\r\nif (req->wlen > (BUF_LEN - REQ_HDR_LEN - CHECKSUM_LEN) ||\r\nreq->rlen > (BUF_LEN - ACK_HDR_LEN - CHECKSUM_LEN)) {\r\ndev_err(&intf->dev, "too much data wlen=%d rlen=%d\n",\r\nreq->wlen, req->rlen);\r\nret = -EINVAL;\r\ngoto exit;\r\n}\r\nstate->buf[0] = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN - 1;\r\nstate->buf[1] = req->mbox;\r\nstate->buf[2] = req->cmd;\r\nstate->buf[3] = state->seq++;\r\nmemcpy(&state->buf[REQ_HDR_LEN], req->wbuf, req->wlen);\r\nwlen = REQ_HDR_LEN + req->wlen + CHECKSUM_LEN;\r\nrlen = ACK_HDR_LEN + req->rlen + CHECKSUM_LEN;\r\nchecksum = af9035_checksum(state->buf, state->buf[0] - 1);\r\nstate->buf[state->buf[0] - 1] = (checksum >> 8);\r\nstate->buf[state->buf[0] - 0] = (checksum & 0xff);\r\nif (req->cmd == CMD_FW_DL)\r\nrlen = 0;\r\nret = dvb_usbv2_generic_rw_locked(d,\r\nstate->buf, wlen, state->buf, rlen);\r\nif (ret)\r\ngoto exit;\r\nif (req->cmd == CMD_FW_DL)\r\ngoto exit;\r\nchecksum = af9035_checksum(state->buf, rlen - 2);\r\ntmp_checksum = (state->buf[rlen - 2] << 8) | state->buf[rlen - 1];\r\nif (tmp_checksum != checksum) {\r\ndev_err(&intf->dev, "command=%02x checksum mismatch (%04x != %04x)\n",\r\nreq->cmd, tmp_checksum, checksum);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nif (state->buf[2]) {\r\nif (req->cmd == CMD_IR_GET || state->buf[2] == 1) {\r\nret = 1;\r\ngoto exit;\r\n}\r\ndev_dbg(&intf->dev, "command=%02x failed fw error=%d\n",\r\nreq->cmd, state->buf[2]);\r\nret = -EIO;\r\ngoto exit;\r\n}\r\nif (req->rlen)\r\nmemcpy(req->rbuf, &state->buf[ACK_HDR_LEN], req->rlen);\r\nexit:\r\nmutex_unlock(&d->usb_mutex);\r\nif (ret < 0)\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_wr_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nu8 wbuf[MAX_XFER_SIZE];\r\nu8 mbox = (reg >> 16) & 0xff;\r\nstruct usb_req req = { CMD_MEM_WR, mbox, 6 + len, wbuf, 0, NULL };\r\nif (6 + len > sizeof(wbuf)) {\r\ndev_warn(&intf->dev, "i2c wr: len=%d is too big!\n", len);\r\nreturn -EOPNOTSUPP;\r\n}\r\nwbuf[0] = len;\r\nwbuf[1] = 2;\r\nwbuf[2] = 0;\r\nwbuf[3] = 0;\r\nwbuf[4] = (reg >> 8) & 0xff;\r\nwbuf[5] = (reg >> 0) & 0xff;\r\nmemcpy(&wbuf[6], val, len);\r\nreturn af9035_ctrl_msg(d, &req);\r\n}\r\nstatic int af9035_rd_regs(struct dvb_usb_device *d, u32 reg, u8 *val, int len)\r\n{\r\nu8 wbuf[] = { len, 2, 0, 0, (reg >> 8) & 0xff, reg & 0xff };\r\nu8 mbox = (reg >> 16) & 0xff;\r\nstruct usb_req req = { CMD_MEM_RD, mbox, sizeof(wbuf), wbuf, len, val };\r\nreturn af9035_ctrl_msg(d, &req);\r\n}\r\nstatic int af9035_wr_reg(struct dvb_usb_device *d, u32 reg, u8 val)\r\n{\r\nreturn af9035_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int af9035_rd_reg(struct dvb_usb_device *d, u32 reg, u8 *val)\r\n{\r\nreturn af9035_rd_regs(d, reg, val, 1);\r\n}\r\nstatic int af9035_wr_reg_mask(struct dvb_usb_device *d, u32 reg, u8 val,\r\nu8 mask)\r\n{\r\nint ret;\r\nu8 tmp;\r\nif (mask != 0xff) {\r\nret = af9035_rd_regs(d, reg, &tmp, 1);\r\nif (ret)\r\nreturn ret;\r\nval &= mask;\r\ntmp &= ~mask;\r\nval |= tmp;\r\n}\r\nreturn af9035_wr_regs(d, reg, &val, 1);\r\n}\r\nstatic int af9035_add_i2c_dev(struct dvb_usb_device *d, const char *type,\r\nu8 addr, void *platform_data, struct i2c_adapter *adapter)\r\n{\r\nint ret, num;\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info board_info = {\r\n.addr = addr,\r\n.platform_data = platform_data,\r\n};\r\nstrlcpy(board_info.type, type, I2C_NAME_SIZE);\r\nfor (num = 0; num < AF9035_I2C_CLIENT_MAX; num++) {\r\nif (state->i2c_client[num] == NULL)\r\nbreak;\r\n}\r\ndev_dbg(&intf->dev, "num=%d\n", num);\r\nif (num == AF9035_I2C_CLIENT_MAX) {\r\ndev_err(&intf->dev, "I2C client out of index\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nrequest_module("%s", board_info.type);\r\nclient = i2c_new_device(adapter, &board_info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nstate->i2c_client[num] = client;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void af9035_del_i2c_dev(struct dvb_usb_device *d)\r\n{\r\nint num;\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\nstruct i2c_client *client;\r\nnum = AF9035_I2C_CLIENT_MAX;\r\nwhile (num--) {\r\nif (state->i2c_client[num] != NULL)\r\nbreak;\r\n}\r\ndev_dbg(&intf->dev, "num=%d\n", num);\r\nif (num == -1) {\r\ndev_err(&intf->dev, "I2C client out of index\n");\r\ngoto err;\r\n}\r\nclient = state->i2c_client[num];\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\nstate->i2c_client[num] = NULL;\r\nreturn;\r\nerr:\r\ndev_dbg(&intf->dev, "failed\n");\r\n}\r\nstatic int af9035_i2c_master_xfer(struct i2c_adapter *adap,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct state *state = d_to_priv(d);\r\nint ret;\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\n#define AF9035_IS_I2C_XFER_WRITE_READ(_msg, _num) \\r\n(_num == 2 && !(_msg[0].flags & I2C_M_RD) && (_msg[1].flags & I2C_M_RD))\r\n#define AF9035_IS_I2C_XFER_WRITE(_msg, _num) \\r\n(_num == 1 && !(_msg[0].flags & I2C_M_RD))\r\n#define AF9035_IS_I2C_XFER_READ(_msg, _num) \\r\n(_num == 1 && (_msg[0].flags & I2C_M_RD))\r\nif (AF9035_IS_I2C_XFER_WRITE_READ(msg, num)) {\r\nif (msg[0].len > 40 || msg[1].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\r\n(msg[0].addr == state->af9033_i2c_addr[1])) {\r\nu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\r\nmsg[0].buf[2];\r\nif (msg[0].addr == state->af9033_i2c_addr[1])\r\nreg |= 0x100000;\r\nret = af9035_rd_regs(d, reg, &msg[1].buf[0],\r\nmsg[1].len);\r\n} else if (state->no_read) {\r\nmemset(msg[1].buf, 0, msg[1].len);\r\nret = 0;\r\n} else {\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct usb_req req = { CMD_I2C_RD, 0, 5 + msg[0].len,\r\nbuf, msg[1].len, msg[1].buf };\r\nif (state->chip_type == 0x9306) {\r\nreq.cmd = CMD_GENERIC_I2C_RD;\r\nreq.wlen = 3 + msg[0].len;\r\n}\r\nreq.mbox |= ((msg[0].addr & 0x80) >> 3);\r\nbuf[0] = msg[1].len;\r\nif (state->chip_type == 0x9306) {\r\nbuf[1] = 0x03;\r\nbuf[2] = msg[0].addr << 1;\r\nmemcpy(&buf[3], msg[0].buf, msg[0].len);\r\n} else {\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nif (msg[0].len > 2) {\r\nbuf[2] = 0x00;\r\nmemcpy(&buf[5], msg[0].buf, msg[0].len);\r\n} else {\r\nreq.wlen = 5;\r\nbuf[2] = msg[0].len;\r\nif (msg[0].len == 2) {\r\nbuf[3] = msg[0].buf[0];\r\nbuf[4] = msg[0].buf[1];\r\n} else if (msg[0].len == 1) {\r\nbuf[4] = msg[0].buf[0];\r\n}\r\n}\r\n}\r\nret = af9035_ctrl_msg(d, &req);\r\n}\r\n} else if (AF9035_IS_I2C_XFER_WRITE(msg, num)) {\r\nif (msg[0].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if ((msg[0].addr == state->af9033_i2c_addr[0]) ||\r\n(msg[0].addr == state->af9033_i2c_addr[1])) {\r\nu32 reg = msg[0].buf[0] << 16 | msg[0].buf[1] << 8 |\r\nmsg[0].buf[2];\r\nif (msg[0].addr == state->af9033_i2c_addr[1])\r\nreg |= 0x100000;\r\nret = af9035_wr_regs(d, reg, &msg[0].buf[3],\r\nmsg[0].len - 3);\r\n} else {\r\nu8 buf[MAX_XFER_SIZE];\r\nstruct usb_req req = { CMD_I2C_WR, 0, 5 + msg[0].len,\r\nbuf, 0, NULL };\r\nif (state->chip_type == 0x9306) {\r\nreq.cmd = CMD_GENERIC_I2C_WR;\r\nreq.wlen = 3 + msg[0].len;\r\n}\r\nreq.mbox |= ((msg[0].addr & 0x80) >> 3);\r\nbuf[0] = msg[0].len;\r\nif (state->chip_type == 0x9306) {\r\nbuf[1] = 0x03;\r\nbuf[2] = msg[0].addr << 1;\r\nmemcpy(&buf[3], msg[0].buf, msg[0].len);\r\n} else {\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\nmemcpy(&buf[5], msg[0].buf, msg[0].len);\r\n}\r\nret = af9035_ctrl_msg(d, &req);\r\n}\r\n} else if (AF9035_IS_I2C_XFER_READ(msg, num)) {\r\nif (msg[0].len > 40) {\r\nret = -EOPNOTSUPP;\r\n} else if (state->no_read) {\r\nmemset(msg[0].buf, 0, msg[0].len);\r\nret = 0;\r\n} else {\r\nu8 buf[5];\r\nstruct usb_req req = { CMD_I2C_RD, 0, sizeof(buf),\r\nbuf, msg[0].len, msg[0].buf };\r\nif (state->chip_type == 0x9306) {\r\nreq.cmd = CMD_GENERIC_I2C_RD;\r\nreq.wlen = 3;\r\n}\r\nreq.mbox |= ((msg[0].addr & 0x80) >> 3);\r\nbuf[0] = msg[0].len;\r\nif (state->chip_type == 0x9306) {\r\nbuf[1] = 0x03;\r\nbuf[2] = msg[0].addr << 1;\r\n} else {\r\nbuf[1] = msg[0].addr << 1;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nbuf[4] = 0x00;\r\n}\r\nret = af9035_ctrl_msg(d, &req);\r\n}\r\n} else {\r\nret = -EOPNOTSUPP;\r\n}\r\nmutex_unlock(&d->i2c_mutex);\r\nif (ret < 0)\r\nreturn ret;\r\nelse\r\nreturn num;\r\n}\r\nstatic u32 af9035_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int af9035_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\nint ret, i, ts_mode_invalid;\r\nunsigned int utmp, eeprom_addr;\r\nu8 tmp;\r\nu8 wbuf[1] = { 1 };\r\nu8 rbuf[4];\r\nstruct usb_req req = { CMD_FW_QUERYINFO, 0, sizeof(wbuf), wbuf,\r\nsizeof(rbuf), rbuf };\r\nret = af9035_rd_regs(d, 0x1222, rbuf, 3);\r\nif (ret < 0)\r\ngoto err;\r\nstate->chip_version = rbuf[0];\r\nstate->chip_type = rbuf[2] << 8 | rbuf[1] << 0;\r\nret = af9035_rd_reg(d, 0x384f, &state->prechip_version);\r\nif (ret < 0)\r\ngoto err;\r\ndev_info(&intf->dev, "prechip_version=%02x chip_version=%02x chip_type=%04x\n",\r\nstate->prechip_version, state->chip_version, state->chip_type);\r\nif (state->chip_type == 0x9135) {\r\nif (state->chip_version == 0x02) {\r\n*name = AF9035_FIRMWARE_IT9135_V2;\r\nutmp = 0x00461d;\r\n} else {\r\n*name = AF9035_FIRMWARE_IT9135_V1;\r\nutmp = 0x00461b;\r\n}\r\nret = af9035_rd_reg(d, utmp, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\nif (tmp == 0x00) {\r\ndev_dbg(&intf->dev, "no eeprom\n");\r\nstate->no_eeprom = true;\r\ngoto check_firmware_status;\r\n}\r\neeprom_addr = EEPROM_BASE_IT9135;\r\n} else if (state->chip_type == 0x9306) {\r\n*name = AF9035_FIRMWARE_IT9303;\r\nstate->no_eeprom = true;\r\ngoto check_firmware_status;\r\n} else {\r\n*name = AF9035_FIRMWARE_AF9035;\r\neeprom_addr = EEPROM_BASE_AF9035;\r\n}\r\nfor (i = 0; i < 256; i += 32) {\r\nret = af9035_rd_regs(d, eeprom_addr + i, &state->eeprom[i], 32);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\ndev_dbg(&intf->dev, "eeprom dump:\n");\r\nfor (i = 0; i < 256; i += 16)\r\ndev_dbg(&intf->dev, "%*ph\n", 16, &state->eeprom[i]);\r\ntmp = state->eeprom[EEPROM_TS_MODE];\r\nts_mode_invalid = 0;\r\nswitch (tmp) {\r\ncase 0:\r\nbreak;\r\ncase 1:\r\ncase 3:\r\nstate->dual_mode = true;\r\nbreak;\r\ncase 5:\r\nif (state->chip_type != 0x9135 && state->chip_type != 0x9306)\r\nstate->dual_mode = true;\r\nelse\r\nts_mode_invalid = 1;\r\nbreak;\r\ndefault:\r\nts_mode_invalid = 1;\r\n}\r\ndev_dbg(&intf->dev, "ts mode=%d dual mode=%d\n", tmp, state->dual_mode);\r\nif (ts_mode_invalid)\r\ndev_info(&intf->dev, "ts mode=%d not supported, defaulting to single tuner mode!", tmp);\r\ncheck_firmware_status:\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&intf->dev, "reply=%*ph\n", 4, rbuf);\r\nif (rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])\r\nret = WARM;\r\nelse\r\nret = COLD;\r\nreturn ret;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware_old(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nint ret, i, j, len;\r\nu8 wbuf[1];\r\nstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_dl = { CMD_FW_DL, 0, 0, wbuf, 0, NULL };\r\nu8 hdr_core;\r\nu16 hdr_addr, hdr_data_len, hdr_checksum;\r\n#define MAX_DATA 58\r\n#define HDR_SIZE 7\r\nfor (i = fw->size; i > HDR_SIZE;) {\r\nhdr_core = fw->data[fw->size - i + 0];\r\nhdr_addr = fw->data[fw->size - i + 1] << 8;\r\nhdr_addr |= fw->data[fw->size - i + 2] << 0;\r\nhdr_data_len = fw->data[fw->size - i + 3] << 8;\r\nhdr_data_len |= fw->data[fw->size - i + 4] << 0;\r\nhdr_checksum = fw->data[fw->size - i + 5] << 8;\r\nhdr_checksum |= fw->data[fw->size - i + 6] << 0;\r\ndev_dbg(&intf->dev, "core=%d addr=%04x data_len=%d checksum=%04x\n",\r\nhdr_core, hdr_addr, hdr_data_len, hdr_checksum);\r\nif (((hdr_core != 1) && (hdr_core != 2)) ||\r\n(hdr_data_len > i)) {\r\ndev_dbg(&intf->dev, "bad firmware\n");\r\nbreak;\r\n}\r\nreq.cmd = CMD_FW_DL_BEGIN;\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\nfor (j = HDR_SIZE + hdr_data_len; j > 0; j -= MAX_DATA) {\r\nlen = j;\r\nif (len > MAX_DATA)\r\nlen = MAX_DATA;\r\nreq_fw_dl.wlen = len;\r\nreq_fw_dl.wbuf = (u8 *) &fw->data[fw->size - i +\r\nHDR_SIZE + hdr_data_len - j];\r\nret = af9035_ctrl_msg(d, &req_fw_dl);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreq.cmd = CMD_FW_DL_END;\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\ni -= hdr_data_len + HDR_SIZE;\r\ndev_dbg(&intf->dev, "data uploaded=%zu\n", fw->size - i);\r\n}\r\nif (i)\r\ndev_warn(&intf->dev, "bad firmware\n");\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware_new(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nint ret, i, i_prev;\r\nstruct usb_req req_fw_dl = { CMD_FW_SCATTER_WR, 0, 0, NULL, 0, NULL };\r\n#define HDR_SIZE 7\r\nfor (i = HDR_SIZE, i_prev = 0; i <= fw->size; i++) {\r\nif (i == fw->size ||\r\n(fw->data[i + 0] == 0x03 &&\r\n(fw->data[i + 1] == 0x00 ||\r\nfw->data[i + 1] == 0x01) &&\r\nfw->data[i + 2] == 0x00)) {\r\nreq_fw_dl.wlen = i - i_prev;\r\nreq_fw_dl.wbuf = (u8 *) &fw->data[i_prev];\r\ni_prev = i;\r\nret = af9035_ctrl_msg(d, &req_fw_dl);\r\nif (ret < 0)\r\ngoto err;\r\ndev_dbg(&intf->dev, "data uploaded=%d\n", i);\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_download_firmware(struct dvb_usb_device *d,\r\nconst struct firmware *fw)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nstruct state *state = d_to_priv(d);\r\nint ret;\r\nu8 wbuf[1];\r\nu8 rbuf[4];\r\nu8 tmp;\r\nstruct usb_req req = { 0, 0, 0, NULL, 0, NULL };\r\nstruct usb_req req_fw_ver = { CMD_FW_QUERYINFO, 0, 1, wbuf, 4, rbuf };\r\ndev_dbg(&intf->dev, "\n");\r\nif (state->dual_mode) {\r\nret = af9035_wr_reg_mask(d, 0x00d8b0, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8b1, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8af, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nret = af9035_wr_reg_mask(d, 0x00d8af, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\ntmp = state->eeprom[EEPROM_2ND_DEMOD_ADDR];\r\nif (!tmp)\r\ntmp = 0x1d << 1;\r\nif ((state->chip_type == 0x9135) ||\r\n(state->chip_type == 0x9306)) {\r\nret = af9035_wr_reg(d, 0x004bfb, tmp);\r\nif (ret < 0)\r\ngoto err;\r\n} else {\r\nret = af9035_wr_reg(d, 0x00417f, tmp);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d81a, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\n}\r\nif (fw->data[0] == 0x01)\r\nret = af9035_download_firmware_old(d, fw);\r\nelse\r\nret = af9035_download_firmware_new(d, fw);\r\nif (ret < 0)\r\ngoto err;\r\nreq.cmd = CMD_FW_BOOT;\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret < 0)\r\ngoto err;\r\nwbuf[0] = 1;\r\nret = af9035_ctrl_msg(d, &req_fw_ver);\r\nif (ret < 0)\r\ngoto err;\r\nif (!(rbuf[0] || rbuf[1] || rbuf[2] || rbuf[3])) {\r\ndev_err(&intf->dev, "firmware did not run\n");\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\ndev_info(&intf->dev, "firmware version=%d.%d.%d.%d",\r\nrbuf[0], rbuf[1], rbuf[2], rbuf[3]);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_read_config(struct dvb_usb_device *d)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nstruct state *state = d_to_priv(d);\r\nint ret, i;\r\nu8 tmp;\r\nu16 tmp16;\r\nstate->af9033_i2c_addr[0] = 0x1c;\r\nstate->af9033_i2c_addr[1] = 0x1d;\r\nstate->af9033_config[0].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;\r\nstate->af9033_config[1].adc_multiplier = AF9033_ADC_MULTIPLIER_2X;\r\nstate->af9033_config[0].ts_mode = AF9033_TS_MODE_USB;\r\nstate->af9033_config[1].ts_mode = AF9033_TS_MODE_SERIAL;\r\nif (state->chip_type == 0x9135) {\r\nstate->af9033_config[0].dyn0_clk = true;\r\nstate->af9033_config[1].dyn0_clk = true;\r\nif (state->chip_version == 0x02) {\r\nstate->af9033_config[0].tuner = AF9033_TUNER_IT9135_60;\r\nstate->af9033_config[1].tuner = AF9033_TUNER_IT9135_60;\r\n} else {\r\nstate->af9033_config[0].tuner = AF9033_TUNER_IT9135_38;\r\nstate->af9033_config[1].tuner = AF9033_TUNER_IT9135_38;\r\n}\r\nif (state->no_eeprom) {\r\nstate->ir_mode = 0x05;\r\nstate->ir_type = 0x00;\r\ngoto skip_eeprom;\r\n}\r\n} else if (state->chip_type == 0x9306) {\r\nreturn 0;\r\n}\r\nstate->ir_mode = state->eeprom[EEPROM_IR_MODE];\r\nstate->ir_type = state->eeprom[EEPROM_IR_TYPE];\r\nif (state->dual_mode) {\r\ntmp = state->eeprom[EEPROM_2ND_DEMOD_ADDR];\r\nif (tmp)\r\nstate->af9033_i2c_addr[1] = tmp >> 1;\r\ndev_dbg(&intf->dev, "2nd demod I2C addr=%02x\n",\r\nstate->af9033_i2c_addr[1]);\r\n}\r\nfor (i = 0; i < state->dual_mode + 1; i++) {\r\nunsigned int eeprom_offset = 0;\r\ntmp = state->eeprom[EEPROM_1_TUNER_ID + eeprom_offset];\r\ndev_dbg(&intf->dev, "[%d]tuner=%02x\n", i, tmp);\r\nif (state->chip_type == 0x9135) {\r\nif (state->chip_version == 0x02) {\r\nswitch (tmp) {\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nstate->af9033_config[i].tuner = tmp;\r\nbreak;\r\n}\r\n} else {\r\nswitch (tmp) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\nstate->af9033_config[i].tuner = tmp;\r\nbreak;\r\n}\r\n}\r\n} else {\r\nstate->af9033_config[i].tuner = tmp;\r\n}\r\nif (state->af9033_config[i].tuner != tmp) {\r\ndev_info(&intf->dev, "[%d] overriding tuner from %02x to %02x\n",\r\ni, tmp, state->af9033_config[i].tuner);\r\n}\r\nswitch (state->af9033_config[i].tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\ncase AF9033_TUNER_FC0011:\r\ncase AF9033_TUNER_MXL5007T:\r\ncase AF9033_TUNER_TDA18218:\r\ncase AF9033_TUNER_FC2580:\r\ncase AF9033_TUNER_FC0012:\r\nstate->af9033_config[i].spec_inv = 1;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nbreak;\r\ndefault:\r\ndev_warn(&intf->dev, "tuner id=%02x not supported, please report!",\r\ntmp);\r\n}\r\nif (i == 1)\r\nswitch (state->af9033_config[i].tuner) {\r\ncase AF9033_TUNER_FC0012:\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\ncase AF9033_TUNER_MXL5007T:\r\nbreak;\r\ndefault:\r\nstate->dual_mode = false;\r\ndev_info(&intf->dev, "driver does not support 2nd tuner and will disable it");\r\n}\r\ntmp = state->eeprom[EEPROM_1_IF_L + eeprom_offset];\r\ntmp16 = tmp << 0;\r\ntmp = state->eeprom[EEPROM_1_IF_H + eeprom_offset];\r\ntmp16 |= tmp << 8;\r\ndev_dbg(&intf->dev, "[%d]IF=%d\n", i, tmp16);\r\neeprom_offset += 0x10;\r\n}\r\nskip_eeprom:\r\nret = af9035_rd_reg(d, 0x00d800, &tmp);\r\nif (ret < 0)\r\ngoto err;\r\ntmp = (tmp >> 0) & 0x0f;\r\nfor (i = 0; i < ARRAY_SIZE(state->af9033_config); i++) {\r\nif (state->chip_type == 0x9135)\r\nstate->af9033_config[i].clock = clock_lut_it9135[tmp];\r\nelse\r\nstate->af9033_config[i].clock = clock_lut_af9035[tmp];\r\n}\r\nstate->no_read = false;\r\nif (state->af9033_config[0].tuner == AF9033_TUNER_MXL5007T &&\r\nle16_to_cpu(d->udev->descriptor.idVendor) == USB_VID_AVERMEDIA)\r\nswitch (le16_to_cpu(d->udev->descriptor.idProduct)) {\r\ncase USB_PID_AVERMEDIA_A867:\r\ncase USB_PID_AVERMEDIA_TWINSTAR:\r\ndev_info(&intf->dev,\r\n"Device may have issues with I2C read operations. Enabling fix.\n");\r\nstate->no_read = true;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tua9001_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\nu8 val;\r\ndev_dbg(&intf->dev, "cmd=%d arg=%d\n", cmd, arg);\r\nswitch (cmd) {\r\ncase TUA9001_CMD_RESETN:\r\nif (arg)\r\nval = 0x00;\r\nelse\r\nval = 0x01;\r\nret = af9035_wr_reg_mask(d, 0x00d8e7, val, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\ncase TUA9001_CMD_RXEN:\r\nif (arg)\r\nval = 0x01;\r\nelse\r\nval = 0x00;\r\nret = af9035_wr_reg_mask(d, 0x00d8eb, val, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_fc0011_tuner_callback(struct dvb_usb_device *d,\r\nint cmd, int arg)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\nswitch (cmd) {\r\ncase FC0011_FE_CALLBACK_POWER:\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d0, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d1, 1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nbreak;\r\ncase FC0011_FE_CALLBACK_RESET:\r\nret = af9035_wr_reg(d, 0xd8e9, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0xd8e8, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0xd8e7, 1);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nret = af9035_wr_reg(d, 0xd8e7, 0);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 20000);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_tuner_callback(struct dvb_usb_device *d, int cmd, int arg)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nswitch (state->af9033_config[0].tuner) {\r\ncase AF9033_TUNER_FC0011:\r\nreturn af9035_fc0011_tuner_callback(d, cmd, arg);\r\ncase AF9033_TUNER_TUA9001:\r\nreturn af9035_tua9001_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_frontend_callback(void *adapter_priv, int component,\r\nint cmd, int arg)\r\n{\r\nstruct i2c_adapter *adap = adapter_priv;\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nstruct usb_interface *intf = d->intf;\r\ndev_dbg(&intf->dev, "component=%d cmd=%d arg=%d\n",\r\ncomponent, cmd, arg);\r\nswitch (component) {\r\ncase DVB_FRONTEND_COMPONENT_TUNER:\r\nreturn af9035_tuner_callback(d, cmd, arg);\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_get_adapter_count(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nreturn state->dual_mode + 1;\r\n}\r\nstatic int af9035_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nif (!state->af9033_config[adap->id].tuner) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nstate->af9033_config[adap->id].fe = &adap->fe[0];\r\nstate->af9033_config[adap->id].ops = &state->ops;\r\nret = af9035_add_i2c_dev(d, "af9033", state->af9033_i2c_addr[adap->id],\r\n&state->af9033_config[adap->id], &d->i2c_adap);\r\nif (ret)\r\ngoto err;\r\nif (adap->fe[0] == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nadap->fe[0]->ops.i2c_gate_ctrl = NULL;\r\nadap->fe[0]->callback = af9035_frontend_callback;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int it930x_frontend_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\nstruct si2168_config si2168_config;\r\nstruct i2c_adapter *adapter;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &adapter;\r\nsi2168_config.fe = &adap->fe[0];\r\nsi2168_config.ts_mode = SI2168_TS_SERIAL;\r\nstate->af9033_config[adap->id].fe = &adap->fe[0];\r\nstate->af9033_config[adap->id].ops = &state->ops;\r\nret = af9035_add_i2c_dev(d, "si2168", 0x67, &si2168_config,\r\n&d->i2c_adap);\r\nif (ret)\r\ngoto err;\r\nif (adap->fe[0] == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nstate->i2c_adapter_demod = adapter;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_frontend_detach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nif (adap->id == 1) {\r\nif (state->i2c_client[1])\r\naf9035_del_i2c_dev(d);\r\n} else if (adap->id == 0) {\r\nif (state->i2c_client[0])\r\naf9035_del_i2c_dev(d);\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\nstruct dvb_frontend *fe;\r\nstruct i2c_msg msg[1];\r\nu8 tuner_addr;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nswitch (state->af9033_config[adap->id].tuner) {\r\ncase AF9033_TUNER_TUA9001: {\r\nstruct tua9001_platform_data tua9001_pdata = {\r\n.dvb_frontend = adap->fe[0],\r\n};\r\nret = af9035_wr_reg_mask(d, 0x00d8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8e8, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0x00d8e9, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_add_i2c_dev(d, "tua9001", 0x60, &tua9001_pdata,\r\n&d->i2c_adap);\r\nif (ret)\r\ngoto err;\r\nfe = adap->fe[0];\r\nbreak;\r\n}\r\ncase AF9033_TUNER_FC0011:\r\nfe = dvb_attach(fc0011_attach, adap->fe[0],\r\n&d->i2c_adap, &af9035_fc0011_config);\r\nbreak;\r\ncase AF9033_TUNER_MXL5007T:\r\nif (adap->id == 0) {\r\nret = af9035_wr_reg(d, 0x00d8e0, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8e1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8df, 0);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(30);\r\nret = af9035_wr_reg(d, 0x00d8df, 1);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(300);\r\nret = af9035_wr_reg(d, 0x00d8c0, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8c1, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8bf, 0);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8b4, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8b5, 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00d8b3, 1);\r\nif (ret < 0)\r\ngoto err;\r\ntuner_addr = 0x60;\r\n} else {\r\ntuner_addr = 0x60 | 0x80;\r\n}\r\nfe = dvb_attach(mxl5007t_attach, adap->fe[0], &d->i2c_adap,\r\ntuner_addr, &af9035_mxl5007t_config[adap->id]);\r\nbreak;\r\ncase AF9033_TUNER_TDA18218:\r\nfe = dvb_attach(tda18218_attach, adap->fe[0],\r\n&d->i2c_adap, &af9035_tda18218_config);\r\nbreak;\r\ncase AF9033_TUNER_FC2580: {\r\nstruct fc2580_platform_data fc2580_pdata = {\r\n.dvb_frontend = adap->fe[0],\r\n};\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nret = af9035_add_i2c_dev(d, "fc2580", 0x56, &fc2580_pdata,\r\n&d->i2c_adap);\r\nif (ret)\r\ngoto err;\r\nfe = adap->fe[0];\r\nbreak;\r\n}\r\ncase AF9033_TUNER_FC0012:\r\nif (adap->id == 0) {\r\nret = af9035_wr_reg_mask(d, 0xd8eb, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ec, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8ed, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\n} else {\r\nmsg[0].addr = 0x63;\r\nmsg[0].flags = 0;\r\nmsg[0].len = 2;\r\nmsg[0].buf = "\x0d\x02";\r\nret = i2c_transfer(&d->i2c_adap, msg, 1);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nusleep_range(10000, 50000);\r\nfe = dvb_attach(fc0012_attach, adap->fe[0], &d->i2c_adap,\r\n&af9035_fc0012_config[adap->id]);\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\n{\r\nstruct platform_device *pdev;\r\nconst char *name;\r\nstruct it913x_platform_data it913x_pdata = {\r\n.regmap = state->af9033_config[adap->id].regmap,\r\n.fe = adap->fe[0],\r\n};\r\nswitch (state->af9033_config[adap->id].tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\nname = "it9133ax-tuner";\r\nbreak;\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nname = "it9133bx-tuner";\r\nbreak;\r\ndefault:\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (state->dual_mode) {\r\nif (adap->id == 0)\r\nit913x_pdata.role = IT913X_ROLE_DUAL_MASTER;\r\nelse\r\nit913x_pdata.role = IT913X_ROLE_DUAL_SLAVE;\r\n} else {\r\nit913x_pdata.role = IT913X_ROLE_SINGLE;\r\n}\r\nrequest_module("%s", "it913x");\r\npdev = platform_device_register_data(&d->intf->dev, name,\r\nPLATFORM_DEVID_AUTO,\r\n&it913x_pdata,\r\nsizeof(it913x_pdata));\r\nif (IS_ERR(pdev) || !pdev->dev.driver) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nif (!try_module_get(pdev->dev.driver->owner)) {\r\nplatform_device_unregister(pdev);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nstate->platform_device_tuner[adap->id] = pdev;\r\nfe = adap->fe[0];\r\nbreak;\r\n}\r\ndefault:\r\nfe = NULL;\r\n}\r\nif (fe == NULL) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int it930x_tuner_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\nstruct si2157_config si2157_config;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nret = af9035_wr_reg(d, 0x00f6a7, 0x07);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg(d, 0x00f103, 0x07);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d4, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d5, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8d3, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8b8, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8b9, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nret = af9035_wr_reg_mask(d, 0xd8b7, 0x00, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nmsleep(200);\r\nret = af9035_wr_reg_mask(d, 0xd8b7, 0x01, 0x01);\r\nif (ret < 0)\r\ngoto err;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = adap->fe[0];\r\nsi2157_config.if_port = 1;\r\nret = af9035_add_i2c_dev(d, "si2157", 0x63,\r\n&si2157_config, state->i2c_adapter_demod);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int it930x_tuner_detach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nif (adap->id == 1) {\r\nif (state->i2c_client[3])\r\naf9035_del_i2c_dev(d);\r\n} else if (adap->id == 0) {\r\nif (state->i2c_client[1])\r\naf9035_del_i2c_dev(d);\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_tuner_detach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nstruct usb_interface *intf = d->intf;\r\ndev_dbg(&intf->dev, "adap->id=%d\n", adap->id);\r\nswitch (state->af9033_config[adap->id].tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\ncase AF9033_TUNER_FC2580:\r\nif (adap->id == 1) {\r\nif (state->i2c_client[3])\r\naf9035_del_i2c_dev(d);\r\n} else if (adap->id == 0) {\r\nif (state->i2c_client[1])\r\naf9035_del_i2c_dev(d);\r\n}\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\n{\r\nstruct platform_device *pdev;\r\npdev = state->platform_device_tuner[adap->id];\r\nif (pdev) {\r\nmodule_put(pdev->dev.driver->owner);\r\nplatform_device_unregister(pdev);\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_init(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\nint ret, i;\r\nu16 frame_size = (d->udev->speed == USB_SPEED_FULL ? 5 : 87) * 188 / 4;\r\nu8 packet_size = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x80f99d, 0x01, 0x01 },\r\n{ 0x80f9a4, 0x01, 0x01 },\r\n{ 0x00dd11, 0x00, 0x20 },\r\n{ 0x00dd11, 0x00, 0x40 },\r\n{ 0x00dd13, 0x00, 0x20 },\r\n{ 0x00dd13, 0x00, 0x40 },\r\n{ 0x00dd11, 0x20, 0x20 },\r\n{ 0x00dd88, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd89, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0c, packet_size, 0xff},\r\n{ 0x00dd11, state->dual_mode << 6, 0x40 },\r\n{ 0x00dd8a, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd8b, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0d, packet_size, 0xff },\r\n{ 0x80f9a3, state->dual_mode, 0x01 },\r\n{ 0x80f9cd, state->dual_mode, 0x01 },\r\n{ 0x80f99d, 0x00, 0x01 },\r\n{ 0x80f9a4, 0x00, 0x01 },\r\n};\r\ndev_dbg(&intf->dev, "USB speed=%d frame_size=%04x packet_size=%02x\n",\r\nd->udev->speed, frame_size, packet_size);\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = af9035_wr_reg_mask(d, tab[i].reg, tab[i].val,\r\ntab[i].mask);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int it930x_init(struct dvb_usb_device *d)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\nint ret, i;\r\nu16 frame_size = (d->udev->speed == USB_SPEED_FULL ? 5 : 816) * 188 / 4;\r\nu8 packet_size = (d->udev->speed == USB_SPEED_FULL ? 64 : 512) / 4;\r\nstruct reg_val_mask tab[] = {\r\n{ 0x00da1a, 0x00, 0x01 },\r\n{ 0x00f41f, 0x04, 0x04 },\r\n{ 0x00da10, 0x00, 0x01 },\r\n{ 0x00f41a, 0x01, 0x01 },\r\n{ 0x00da1d, 0x01, 0x01 },\r\n{ 0x00dd11, 0x00, 0x20 },\r\n{ 0x00dd13, 0x00, 0x20 },\r\n{ 0x00dd11, 0x20, 0x20 },\r\n{ 0x00dd11, 0x00, 0x40 },\r\n{ 0x00dd13, 0x00, 0x40 },\r\n{ 0x00dd11, state->dual_mode << 6, 0x40 },\r\n{ 0x00dd88, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd89, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0c, packet_size, 0xff},\r\n{ 0x00dd8a, (frame_size >> 0) & 0xff, 0xff},\r\n{ 0x00dd8b, (frame_size >> 8) & 0xff, 0xff},\r\n{ 0x00dd0d, packet_size, 0xff },\r\n{ 0x00da1d, 0x00, 0x01 },\r\n{ 0x00d833, 0x01, 0xff },\r\n{ 0x00d830, 0x00, 0xff },\r\n{ 0x00d831, 0x01, 0xff },\r\n{ 0x00d832, 0x00, 0xff },\r\n{ 0x00d8b0, 0x01, 0xff },\r\n{ 0x00d8b1, 0x01, 0xff },\r\n{ 0x00d8af, 0x00, 0xff },\r\n{ 0x00d8c4, 0x01, 0xff },\r\n{ 0x00d8c5, 0x01, 0xff },\r\n{ 0x00d8c3, 0x00, 0xff },\r\n{ 0x00d8dc, 0x01, 0xff },\r\n{ 0x00d8dd, 0x01, 0xff },\r\n{ 0x00d8db, 0x00, 0xff },\r\n{ 0x00d8e4, 0x01, 0xff },\r\n{ 0x00d8e5, 0x01, 0xff },\r\n{ 0x00d8e3, 0x00, 0xff },\r\n{ 0x00d8e8, 0x01, 0xff },\r\n{ 0x00d8e9, 0x01, 0xff },\r\n{ 0x00d8e7, 0x00, 0xff },\r\n{ 0x00da58, 0x00, 0x01 },\r\n{ 0x00da73, 0x01, 0xff },\r\n{ 0x00da78, 0x47, 0xff },\r\n{ 0x00da4c, 0x01, 0xff },\r\n{ 0x00da5a, 0x1f, 0xff },\r\n};\r\ndev_dbg(&intf->dev, "USB speed=%d frame_size=%04x packet_size=%02x\n",\r\nd->udev->speed, frame_size, packet_size);\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = af9035_wr_reg_mask(d, tab[i].reg,\r\ntab[i].val, tab[i].mask);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_rc_query(struct dvb_usb_device *d)\r\n{\r\nstruct usb_interface *intf = d->intf;\r\nint ret;\r\nenum rc_type proto;\r\nu32 key;\r\nu8 buf[4];\r\nstruct usb_req req = { CMD_IR_GET, 0, 0, NULL, 4, buf };\r\nret = af9035_ctrl_msg(d, &req);\r\nif (ret == 1)\r\nreturn 0;\r\nelse if (ret < 0)\r\ngoto err;\r\nif ((buf[2] + buf[3]) == 0xff) {\r\nif ((buf[0] + buf[1]) == 0xff) {\r\nkey = RC_SCANCODE_NEC(buf[0], buf[2]);\r\nproto = RC_TYPE_NEC;\r\n} else {\r\nkey = RC_SCANCODE_NECX(buf[0] << 8 | buf[1], buf[2]);\r\nproto = RC_TYPE_NECX;\r\n}\r\n} else {\r\nkey = RC_SCANCODE_NEC32(buf[0] << 24 | buf[1] << 16 |\r\nbuf[2] << 8 | buf[3]);\r\nproto = RC_TYPE_NEC32;\r\n}\r\ndev_dbg(&intf->dev, "%*ph\n", 4, buf);\r\nrc_keydown(d->rc_dev, proto, key, 0);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&intf->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9035_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\nstruct state *state = d_to_priv(d);\r\nstruct usb_interface *intf = d->intf;\r\ndev_dbg(&intf->dev, "ir_mode=%02x ir_type=%02x\n",\r\nstate->ir_mode, state->ir_type);\r\nif (state->ir_mode == 0x05) {\r\nswitch (state->ir_type) {\r\ncase 0:\r\ndefault:\r\nrc->allowed_protos = RC_BIT_NEC | RC_BIT_NECX |\r\nRC_BIT_NEC32;\r\nbreak;\r\ncase 1:\r\nrc->allowed_protos = RC_BIT_RC6_MCE;\r\nbreak;\r\n}\r\nrc->query = af9035_rc_query;\r\nrc->interval = 500;\r\nif (!rc->map_name)\r\nrc->map_name = RC_MAP_EMPTY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int af9035_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,\r\nstruct usb_data_stream_properties *stream)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct usb_interface *intf = d->intf;\r\ndev_dbg(&intf->dev, "adap=%d\n", fe_to_adap(fe)->id);\r\nif (d->udev->speed == USB_SPEED_FULL)\r\nstream->u.bulk.buffersize = 5 * 188;\r\nreturn 0;\r\n}\r\nstatic int af9035_pid_filter_ctrl(struct dvb_usb_adapter *adap, int onoff)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nreturn state->ops.pid_filter_ctrl(adap->fe[0], onoff);\r\n}\r\nstatic int af9035_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,\r\nint onoff)\r\n{\r\nstruct state *state = adap_to_priv(adap);\r\nreturn state->ops.pid_filter(adap->fe[0], index, pid, onoff);\r\n}\r\nstatic int af9035_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct usb_device *udev = interface_to_usbdev(intf);\r\nchar manufacturer[sizeof("Afatech")];\r\nmemset(manufacturer, 0, sizeof(manufacturer));\r\nusb_string(udev, udev->descriptor.iManufacturer,\r\nmanufacturer, sizeof(manufacturer));\r\nif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VID_TERRATEC) &&\r\n(le16_to_cpu(udev->descriptor.idProduct) == 0x0099)) {\r\nif (!strcmp("Afatech", manufacturer)) {\r\ndev_dbg(&udev->dev, "rejecting device\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nreturn dvb_usbv2_probe(intf, id);\r\n}
