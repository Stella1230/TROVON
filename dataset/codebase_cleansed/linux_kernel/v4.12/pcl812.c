static void pcl812_ai_setup_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int unread_samples)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nunsigned int bytes;\r\nunsigned int max_samples;\r\nunsigned int nsamples;\r\ncomedi_isadma_disable(dma->chan);\r\nbytes = devpriv->ai_eos ? comedi_bytes_per_scan(s) : desc->maxsize;\r\nmax_samples = comedi_bytes_to_samples(s, bytes);\r\nnsamples = comedi_nsamples_left(s, max_samples + unread_samples);\r\nif (nsamples > unread_samples) {\r\nnsamples -= unread_samples;\r\ndesc->size = comedi_samples_to_bytes(s, nsamples);\r\ncomedi_isadma_program(desc);\r\n}\r\n}\r\nstatic void pcl812_ai_set_chan_range(struct comedi_device *dev,\r\nunsigned int chanspec, char wait)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nunsigned int chan = CR_CHAN(chanspec);\r\nunsigned int range = CR_RANGE(chanspec);\r\nunsigned int mux = 0;\r\nif (chanspec == devpriv->last_ai_chanspec)\r\nreturn;\r\ndevpriv->last_ai_chanspec = chanspec;\r\nif (devpriv->use_mpc508) {\r\nif (devpriv->use_diff) {\r\nmux |= PCL812_MUX_CS0 | PCL812_MUX_CS1;\r\n} else {\r\nif (chan < 8)\r\nmux |= PCL812_MUX_CS0;\r\nelse\r\nmux |= PCL812_MUX_CS1;\r\n}\r\n}\r\noutb(mux | PCL812_MUX_CHAN(chan), dev->iobase + PCL812_MUX_REG);\r\noutb(range + devpriv->range_correction, dev->iobase + PCL812_RANGE_REG);\r\nif (wait)\r\nudelay(devpriv->max_812_ai_mode0_rangewait);\r\n}\r\nstatic void pcl812_ai_clear_eoc(struct comedi_device *dev)\r\n{\r\noutb(0, dev->iobase + PCL812_STATUS_REG);\r\n}\r\nstatic void pcl812_ai_soft_trig(struct comedi_device *dev)\r\n{\r\noutb(255, dev->iobase + PCL812_SOFTTRIG_REG);\r\n}\r\nstatic unsigned int pcl812_ai_get_sample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nunsigned int val;\r\nval = inb(dev->iobase + PCL812_AI_MSB_REG) << 8;\r\nval |= inb(dev->iobase + PCL812_AI_LSB_REG);\r\nreturn val & s->maxdata;\r\n}\r\nstatic int pcl812_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nif (s->maxdata > 0x0fff) {\r\nstatus = inb(dev->iobase + PCL812_STATUS_REG);\r\nif ((status & PCL812_STATUS_DRDY) == 0)\r\nreturn 0;\r\n} else {\r\nstatus = inb(dev->iobase + PCL812_AI_MSB_REG);\r\nif ((status & PCL812_AI_MSB_DRDY) == 0)\r\nreturn 0;\r\n}\r\nreturn -EBUSY;\r\n}\r\nstatic int pcl812_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, struct comedi_cmd *cmd)\r\n{\r\nconst struct pcl812_board *board = dev->board_ptr;\r\nstruct pcl812_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int flags;\r\nerr |= comedi_check_trigger_src(&cmd->start_src, TRIG_NOW);\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, TRIG_FOLLOW);\r\nif (devpriv->use_ext_trg)\r\nflags = TRIG_EXT;\r\nelse\r\nflags = TRIG_TIMER;\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, flags);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src, TRIG_COUNT | TRIG_NONE);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (err)\r\nreturn 2;\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\nboard->ai_ns_min);\r\n} else {\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\n}\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nif (err)\r\nreturn 3;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\nunsigned int arg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\n}\r\nif (err)\r\nreturn 4;\r\nreturn 0;\r\n}\r\nstatic int pcl812_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int ctrl = 0;\r\nunsigned int i;\r\npcl812_ai_set_chan_range(dev, cmd->chanlist[0], 1);\r\nif (dma) {\r\ndevpriv->ai_dma = 1;\r\nfor (i = 1; i < cmd->chanlist_len; i++)\r\nif (cmd->chanlist[0] != cmd->chanlist[i]) {\r\ndevpriv->ai_dma = 0;\r\nbreak;\r\n}\r\n} else {\r\ndevpriv->ai_dma = 0;\r\n}\r\ndevpriv->ai_poll_ptr = 0;\r\nif (cmd->flags & CMDF_WAKE_EOS) {\r\ndevpriv->ai_eos = 1;\r\nif (cmd->chanlist_len == 1)\r\ndevpriv->ai_dma = 0;\r\n}\r\nif (devpriv->ai_dma) {\r\ndma->cur_dma = 0;\r\npcl812_ai_setup_dma(dev, s, 0);\r\n}\r\nswitch (cmd->convert_src) {\r\ncase TRIG_TIMER:\r\ncomedi_8254_update_divisors(dev->pacer);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\nbreak;\r\n}\r\nif (devpriv->ai_dma)\r\nctrl |= PCL812_CTRL_PACER_DMA_TRIG;\r\nelse\r\nctrl |= PCL812_CTRL_PACER_EOC_TRIG;\r\noutb(devpriv->mode_reg_int | ctrl, dev->iobase + PCL812_CTRL_REG);\r\nreturn 0;\r\n}\r\nstatic bool pcl812_ai_next_chan(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (cmd->stop_src == TRIG_COUNT &&\r\ns->async->scans_done >= cmd->stop_arg) {\r\ns->async->events |= COMEDI_CB_EOA;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic void pcl812_handle_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int chan = s->async->cur_chan;\r\nunsigned int next_chan;\r\nunsigned short val;\r\nif (pcl812_ai_eoc(dev, s, NULL, 0)) {\r\ndev_dbg(dev->class_dev, "A/D cmd IRQ without DRDY!\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\nreturn;\r\n}\r\nval = pcl812_ai_get_sample(dev, s);\r\ncomedi_buf_write_samples(s, &val, 1);\r\nnext_chan = s->async->cur_chan;\r\nif (cmd->chanlist[chan] != cmd->chanlist[next_chan])\r\npcl812_ai_set_chan_range(dev, cmd->chanlist[next_chan], 0);\r\npcl812_ai_next_chan(dev, s);\r\n}\r\nstatic void transfer_from_dma_buf(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short *ptr,\r\nunsigned int bufptr, unsigned int len)\r\n{\r\nunsigned int i;\r\nunsigned short val;\r\nfor (i = len; i; i--) {\r\nval = ptr[bufptr++];\r\ncomedi_buf_write_samples(s, &val, 1);\r\nif (!pcl812_ai_next_chan(dev, s))\r\nbreak;\r\n}\r\n}\r\nstatic void pcl812_handle_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc = &dma->desc[dma->cur_dma];\r\nunsigned int nsamples;\r\nint bufptr;\r\nnsamples = comedi_bytes_to_samples(s, desc->size) -\r\ndevpriv->ai_poll_ptr;\r\nbufptr = devpriv->ai_poll_ptr;\r\ndevpriv->ai_poll_ptr = 0;\r\ndma->cur_dma = 1 - dma->cur_dma;\r\npcl812_ai_setup_dma(dev, s, nsamples);\r\ntransfer_from_dma_buf(dev, s, desc->virt_addr, bufptr, nsamples);\r\n}\r\nstatic irqreturn_t pcl812_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (!dev->attached) {\r\npcl812_ai_clear_eoc(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (devpriv->ai_dma)\r\npcl812_handle_dma(dev, s);\r\nelse\r\npcl812_handle_eoc(dev, s);\r\npcl812_ai_clear_eoc(dev);\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int pcl812_ai_poll(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nstruct comedi_isadma *dma = devpriv->dma;\r\nstruct comedi_isadma_desc *desc;\r\nunsigned long flags;\r\nunsigned int poll;\r\nint ret;\r\nif (!devpriv->ai_dma)\r\nreturn 0;\r\nspin_lock_irqsave(&dev->spinlock, flags);\r\npoll = comedi_isadma_poll(dma);\r\npoll = comedi_bytes_to_samples(s, poll);\r\nif (poll > devpriv->ai_poll_ptr) {\r\ndesc = &dma->desc[dma->cur_dma];\r\ntransfer_from_dma_buf(dev, s, desc->virt_addr,\r\ndevpriv->ai_poll_ptr,\r\npoll - devpriv->ai_poll_ptr);\r\ndevpriv->ai_poll_ptr = poll;\r\nret = comedi_buf_n_bytes_ready(s);\r\n} else {\r\nret = 0;\r\n}\r\nspin_unlock_irqrestore(&dev->spinlock, flags);\r\nreturn ret;\r\n}\r\nstatic int pcl812_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (devpriv->ai_dma)\r\ncomedi_isadma_disable(devpriv->dma->chan);\r\noutb(devpriv->mode_reg_int | PCL812_CTRL_DISABLE_TRIG,\r\ndev->iobase + PCL812_CTRL_REG);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\r\npcl812_ai_clear_eoc(dev);\r\nreturn 0;\r\n}\r\nstatic int pcl812_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nint ret = 0;\r\nint i;\r\noutb(devpriv->mode_reg_int | PCL812_CTRL_SOFT_TRIG,\r\ndev->iobase + PCL812_CTRL_REG);\r\npcl812_ai_set_chan_range(dev, insn->chanspec, 1);\r\nfor (i = 0; i < insn->n; i++) {\r\npcl812_ai_clear_eoc(dev);\r\npcl812_ai_soft_trig(dev);\r\nret = comedi_timeout(dev, s, insn, pcl812_ai_eoc, 0);\r\nif (ret)\r\nbreak;\r\ndata[i] = pcl812_ai_get_sample(dev, s);\r\n}\r\noutb(devpriv->mode_reg_int | PCL812_CTRL_DISABLE_TRIG,\r\ndev->iobase + PCL812_CTRL_REG);\r\npcl812_ai_clear_eoc(dev);\r\nreturn ret ? ret : insn->n;\r\n}\r\nstatic int pcl812_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\noutb(val & 0xff, dev->iobase + PCL812_AO_LSB_REG(chan));\r\noutb((val >> 8) & 0x0f, dev->iobase + PCL812_AO_MSB_REG(chan));\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int pcl812_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inb(dev->iobase + PCL812_DI_LSB_REG) |\r\n(inb(dev->iobase + PCL812_DI_MSB_REG) << 8);\r\nreturn insn->n;\r\n}\r\nstatic int pcl812_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data)) {\r\noutb(s->state & 0xff, dev->iobase + PCL812_DO_LSB_REG);\r\noutb((s->state >> 8), dev->iobase + PCL812_DO_MSB_REG);\r\n}\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void pcl812_reset(struct comedi_device *dev)\r\n{\r\nconst struct pcl812_board *board = dev->board_ptr;\r\nstruct pcl812_private *devpriv = dev->private;\r\nunsigned int chan;\r\noutb(devpriv->mode_reg_int | PCL812_CTRL_DISABLE_TRIG,\r\ndev->iobase + PCL812_CTRL_REG);\r\npcl812_ai_clear_eoc(dev);\r\ndevpriv->last_ai_chanspec = CR_PACK(16, 0, 0);\r\npcl812_ai_set_chan_range(dev, CR_PACK(0, 0, 0), 0);\r\nfor (chan = 0; chan < board->n_aochan; chan++) {\r\noutb(0, dev->iobase + PCL812_AO_LSB_REG(chan));\r\noutb(0, dev->iobase + PCL812_AO_MSB_REG(chan));\r\n}\r\nif (board->has_dio) {\r\noutb(0, dev->iobase + PCL812_DO_MSB_REG);\r\noutb(0, dev->iobase + PCL812_DO_LSB_REG);\r\n}\r\n}\r\nstatic void pcl812_set_ai_range_table(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_devconfig *it)\r\n{\r\nconst struct pcl812_board *board = dev->board_ptr;\r\nstruct pcl812_private *devpriv = dev->private;\r\nswitch (board->board_type) {\r\ncase BOARD_PCL812PG:\r\nif (it->options[4] == 1)\r\ns->range_table = &range_pcl812pg2_ai;\r\nelse\r\ns->range_table = board->rangelist_ai;\r\nbreak;\r\ncase BOARD_PCL812:\r\nswitch (it->options[4]) {\r\ncase 0:\r\ns->range_table = &range_bipolar10;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_bipolar5;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_bipolar2_5;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range812_bipolar1_25;\r\nbreak;\r\ncase 4:\r\ns->range_table = &range812_bipolar0_625;\r\nbreak;\r\ncase 5:\r\ns->range_table = &range812_bipolar0_3125;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_bipolar10;\r\nbreak;\r\n}\r\nbreak;\r\ncase BOARD_PCL813B:\r\nif (it->options[1] == 1)\r\ns->range_table = &range_pcl813b2_ai;\r\nelse\r\ns->range_table = board->rangelist_ai;\r\nbreak;\r\ncase BOARD_ISO813:\r\nswitch (it->options[1]) {\r\ncase 0:\r\ns->range_table = &range_iso813_1_ai;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_iso813_1_2_ai;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_iso813_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range_iso813_2_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_iso813_1_ai;\r\nbreak;\r\n}\r\nbreak;\r\ncase BOARD_ACL8113:\r\nswitch (it->options[1]) {\r\ncase 0:\r\ns->range_table = &range_acl8113_1_ai;\r\nbreak;\r\ncase 1:\r\ns->range_table = &range_acl8113_1_2_ai;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_acl8113_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ncase 3:\r\ns->range_table = &range_acl8113_2_2_ai;\r\ndevpriv->range_correction = 1;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_acl8113_1_ai;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ns->range_table = board->rangelist_ai;\r\nbreak;\r\n}\r\n}\r\nstatic void pcl812_alloc_dma(struct comedi_device *dev, unsigned int dma_chan)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (!(dma_chan == 3 || dma_chan == 1))\r\nreturn;\r\ndevpriv->dma = comedi_isadma_alloc(dev, 2, dma_chan, dma_chan,\r\nPAGE_SIZE * 2, COMEDI_ISADMA_READ);\r\n}\r\nstatic void pcl812_free_dma(struct comedi_device *dev)\r\n{\r\nstruct pcl812_private *devpriv = dev->private;\r\nif (devpriv)\r\ncomedi_isadma_free(devpriv->dma);\r\n}\r\nstatic int pcl812_attach(struct comedi_device *dev, struct comedi_devconfig *it)\r\n{\r\nconst struct pcl812_board *board = dev->board_ptr;\r\nstruct pcl812_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint n_subdevices;\r\nint subdev;\r\nint ret;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_request_region(dev, it->options[0], 0x10);\r\nif (ret)\r\nreturn ret;\r\nif (board->irq_bits) {\r\ndev->pacer = comedi_8254_init(dev->iobase + PCL812_TIMER_BASE,\r\nI8254_OSC_BASE_2MHZ,\r\nI8254_IO8, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\nif ((1 << it->options[1]) & board->irq_bits) {\r\nret = request_irq(it->options[1], pcl812_interrupt, 0,\r\ndev->board_name, dev);\r\nif (ret == 0)\r\ndev->irq = it->options[1];\r\n}\r\n}\r\nif (dev->irq && board->has_dma)\r\npcl812_alloc_dma(dev, it->options[2]);\r\nswitch (board->board_type) {\r\ncase BOARD_A821:\r\nif (it->options[2] == 1)\r\ndevpriv->use_diff = 1;\r\nbreak;\r\ncase BOARD_ACL8112:\r\ncase BOARD_ACL8216:\r\nif (it->options[4] == 1)\r\ndevpriv->use_diff = 1;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nn_subdevices = 1;\r\nif (board->n_aochan > 0)\r\nn_subdevices++;\r\nif (board->has_dio)\r\nn_subdevices += 2;\r\nret = comedi_alloc_subdevices(dev, n_subdevices);\r\nif (ret)\r\nreturn ret;\r\nsubdev = 0;\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE;\r\nif (devpriv->use_diff) {\r\ns->subdev_flags |= SDF_DIFF;\r\ns->n_chan = board->n_aichan / 2;\r\n} else {\r\ns->subdev_flags |= SDF_GROUND;\r\ns->n_chan = board->n_aichan;\r\n}\r\ns->maxdata = board->has_16bit_ai ? 0xffff : 0x0fff;\r\npcl812_set_ai_range_table(dev, s, it);\r\ns->insn_read = pcl812_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = MAX_CHANLIST_LEN;\r\ns->do_cmdtest = pcl812_ai_cmdtest;\r\ns->do_cmd = pcl812_ai_cmd;\r\ns->poll = pcl812_ai_poll;\r\ns->cancel = pcl812_ai_cancel;\r\n}\r\ndevpriv->use_mpc508 = board->has_mpc508_mux;\r\nsubdev++;\r\nif (board->n_aochan > 0) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND;\r\ns->n_chan = board->n_aochan;\r\ns->maxdata = 0xfff;\r\nswitch (board->board_type) {\r\ncase BOARD_A821:\r\nif (it->options[3] == 1)\r\ns->range_table = &range_unipolar10;\r\nelse\r\ns->range_table = &range_unipolar5;\r\nbreak;\r\ncase BOARD_PCL812:\r\ncase BOARD_ACL8112:\r\ncase BOARD_PCL812PG:\r\ncase BOARD_ACL8216:\r\nswitch (it->options[5]) {\r\ncase 1:\r\ns->range_table = &range_unipolar10;\r\nbreak;\r\ncase 2:\r\ns->range_table = &range_unknown;\r\nbreak;\r\ndefault:\r\ns->range_table = &range_unipolar5;\r\nbreak;\r\n}\r\nbreak;\r\ndefault:\r\ns->range_table = &range_unipolar5;\r\nbreak;\r\n}\r\ns->insn_write = pcl812_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nsubdev++;\r\n}\r\nif (board->has_dio) {\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl812_di_insn_bits;\r\nsubdev++;\r\ns = &dev->subdevices[subdev];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 16;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pcl812_do_insn_bits;\r\nsubdev++;\r\n}\r\nswitch (board->board_type) {\r\ncase BOARD_ACL8216:\r\ncase BOARD_PCL812PG:\r\ncase BOARD_PCL812:\r\ncase BOARD_ACL8112:\r\ndevpriv->max_812_ai_mode0_rangewait = 1;\r\nif (it->options[3] > 0)\r\ndevpriv->use_ext_trg = 1;\r\nbreak;\r\ncase BOARD_A821:\r\ndevpriv->max_812_ai_mode0_rangewait = 1;\r\ndevpriv->mode_reg_int = (dev->irq << 4) & 0xf0;\r\nbreak;\r\ncase BOARD_PCL813B:\r\ncase BOARD_PCL813:\r\ncase BOARD_ISO813:\r\ncase BOARD_ACL8113:\r\ndevpriv->max_812_ai_mode0_rangewait = 5;\r\nbreak;\r\n}\r\npcl812_reset(dev);\r\nreturn 0;\r\n}\r\nstatic void pcl812_detach(struct comedi_device *dev)\r\n{\r\npcl812_free_dma(dev);\r\ncomedi_legacy_detach(dev);\r\n}
