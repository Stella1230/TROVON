static int\r\ng84_fifo_chan_ntfy(struct nvkm_fifo_chan *chan, u32 type,\r\nstruct nvkm_event **pevent)\r\n{\r\nswitch (type) {\r\ncase NV826E_V0_NTFY_NON_STALL_INTERRUPT:\r\n*pevent = &chan->fifo->uevent;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int\r\ng84_fifo_chan_engine(struct nvkm_engine *engine)\r\n{\r\nswitch (engine->subdev.index) {\r\ncase NVKM_ENGINE_GR : return 0;\r\ncase NVKM_ENGINE_MPEG :\r\ncase NVKM_ENGINE_MSPPP : return 1;\r\ncase NVKM_ENGINE_CE0 : return 2;\r\ncase NVKM_ENGINE_VP :\r\ncase NVKM_ENGINE_MSPDEC: return 3;\r\ncase NVKM_ENGINE_CIPHER:\r\ncase NVKM_ENGINE_SEC : return 4;\r\ncase NVKM_ENGINE_BSP :\r\ncase NVKM_ENGINE_MSVLD : return 5;\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\ng84_fifo_chan_engine_addr(struct nvkm_engine *engine)\r\n{\r\nswitch (engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW : return -1;\r\ncase NVKM_ENGINE_GR : return 0x0020;\r\ncase NVKM_ENGINE_VP :\r\ncase NVKM_ENGINE_MSPDEC: return 0x0040;\r\ncase NVKM_ENGINE_MPEG :\r\ncase NVKM_ENGINE_MSPPP : return 0x0060;\r\ncase NVKM_ENGINE_BSP :\r\ncase NVKM_ENGINE_MSVLD : return 0x0080;\r\ncase NVKM_ENGINE_CIPHER:\r\ncase NVKM_ENGINE_SEC : return 0x00a0;\r\ncase NVKM_ENGINE_CE0 : return 0x00c0;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -1;\r\n}\r\n}\r\nstatic int\r\ng84_fifo_chan_engine_fini(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine, bool suspend)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nv50_fifo *fifo = chan->fifo;\r\nstruct nvkm_subdev *subdev = &fifo->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nu32 engn, save;\r\nint offset;\r\nbool done;\r\noffset = g84_fifo_chan_engine_addr(engine);\r\nif (offset < 0)\r\nreturn 0;\r\nengn = g84_fifo_chan_engine(engine);\r\nsave = nvkm_mask(device, 0x002520, 0x0000003f, 1 << engn);\r\nnvkm_wr32(device, 0x0032fc, chan->base.inst->addr >> 12);\r\ndone = nvkm_msec(device, 2000,\r\nif (nvkm_rd32(device, 0x0032fc) != 0xffffffff)\r\nbreak;\r\n) >= 0;\r\nnvkm_wr32(device, 0x002520, save);\r\nif (!done) {\r\nnvkm_error(subdev, "channel %d [%s] unload timeout\n",\r\nchan->base.chid, chan->base.object.client->name);\r\nif (suspend)\r\nreturn -EBUSY;\r\n}\r\nnvkm_kmap(chan->eng);\r\nnvkm_wo32(chan->eng, offset + 0x00, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x04, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x08, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x0c, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x10, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x14, 0x00000000);\r\nnvkm_done(chan->eng);\r\nreturn 0;\r\n}\r\nstatic int\r\ng84_fifo_chan_engine_init(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nvkm_gpuobj *engn = chan->engn[engine->subdev.index];\r\nu64 limit, start;\r\nint offset;\r\noffset = g84_fifo_chan_engine_addr(engine);\r\nif (offset < 0)\r\nreturn 0;\r\nlimit = engn->addr + engn->size - 1;\r\nstart = engn->addr;\r\nnvkm_kmap(chan->eng);\r\nnvkm_wo32(chan->eng, offset + 0x00, 0x00190000);\r\nnvkm_wo32(chan->eng, offset + 0x04, lower_32_bits(limit));\r\nnvkm_wo32(chan->eng, offset + 0x08, lower_32_bits(start));\r\nnvkm_wo32(chan->eng, offset + 0x0c, upper_32_bits(limit) << 24 |\r\nupper_32_bits(start));\r\nnvkm_wo32(chan->eng, offset + 0x10, 0x00000000);\r\nnvkm_wo32(chan->eng, offset + 0x14, 0x00000000);\r\nnvkm_done(chan->eng);\r\nreturn 0;\r\n}\r\nstatic int\r\ng84_fifo_chan_engine_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nint engn = engine->subdev.index;\r\nif (g84_fifo_chan_engine_addr(engine) < 0)\r\nreturn 0;\r\nreturn nvkm_object_bind(object, NULL, 0, &chan->engn[engn]);\r\n}\r\nstatic int\r\ng84_fifo_chan_object_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_object *object)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nu32 handle = object->handle;\r\nu32 context;\r\nswitch (object->engine->subdev.index) {\r\ncase NVKM_ENGINE_DMAOBJ:\r\ncase NVKM_ENGINE_SW : context = 0x00000000; break;\r\ncase NVKM_ENGINE_GR : context = 0x00100000; break;\r\ncase NVKM_ENGINE_MPEG :\r\ncase NVKM_ENGINE_MSPPP : context = 0x00200000; break;\r\ncase NVKM_ENGINE_ME :\r\ncase NVKM_ENGINE_CE0 : context = 0x00300000; break;\r\ncase NVKM_ENGINE_VP :\r\ncase NVKM_ENGINE_MSPDEC: context = 0x00400000; break;\r\ncase NVKM_ENGINE_CIPHER:\r\ncase NVKM_ENGINE_SEC :\r\ncase NVKM_ENGINE_VIC : context = 0x00500000; break;\r\ncase NVKM_ENGINE_BSP :\r\ncase NVKM_ENGINE_MSVLD : context = 0x00600000; break;\r\ndefault:\r\nWARN_ON(1);\r\nreturn -EINVAL;\r\n}\r\nreturn nvkm_ramht_insert(chan->ramht, object, 0, 4, handle, context);\r\n}\r\nstatic void\r\ng84_fifo_chan_init(struct nvkm_fifo_chan *base)\r\n{\r\nstruct nv50_fifo_chan *chan = nv50_fifo_chan(base);\r\nstruct nv50_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nu64 addr = chan->ramfc->addr >> 8;\r\nu32 chid = chan->base.chid;\r\nnvkm_wr32(device, 0x002600 + (chid * 4), 0x80000000 | addr);\r\nnv50_fifo_runlist_update(fifo);\r\n}\r\nint\r\ng84_fifo_chan_ctor(struct nv50_fifo *fifo, u64 vm, u64 push,\r\nconst struct nvkm_oclass *oclass,\r\nstruct nv50_fifo_chan *chan)\r\n{\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nint ret;\r\nret = nvkm_fifo_chan_ctor(&g84_fifo_chan_func, &fifo->base,\r\n0x10000, 0x1000, false, vm, push,\r\n(1ULL << NVKM_ENGINE_BSP) |\r\n(1ULL << NVKM_ENGINE_CE0) |\r\n(1ULL << NVKM_ENGINE_CIPHER) |\r\n(1ULL << NVKM_ENGINE_DMAOBJ) |\r\n(1ULL << NVKM_ENGINE_GR) |\r\n(1ULL << NVKM_ENGINE_ME) |\r\n(1ULL << NVKM_ENGINE_MPEG) |\r\n(1ULL << NVKM_ENGINE_MSPDEC) |\r\n(1ULL << NVKM_ENGINE_MSPPP) |\r\n(1ULL << NVKM_ENGINE_MSVLD) |\r\n(1ULL << NVKM_ENGINE_SEC) |\r\n(1ULL << NVKM_ENGINE_SW) |\r\n(1ULL << NVKM_ENGINE_VIC) |\r\n(1ULL << NVKM_ENGINE_VP),\r\n0, 0xc00000, 0x2000, oclass, &chan->base);\r\nchan->fifo = fifo;\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x0200, 0, true, chan->base.inst,\r\n&chan->eng);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x4000, 0, false, chan->base.inst,\r\n&chan->pgd);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x1000, 0x400, true, chan->base.inst,\r\n&chan->cache);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_gpuobj_new(device, 0x100, 0x100, true, chan->base.inst,\r\n&chan->ramfc);\r\nif (ret)\r\nreturn ret;\r\nret = nvkm_ramht_new(device, 0x8000, 16, chan->base.inst, &chan->ramht);\r\nif (ret)\r\nreturn ret;\r\nreturn nvkm_vm_ref(chan->base.vm, &chan->vm, chan->pgd);\r\n}
