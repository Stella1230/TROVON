static bool tproxy_sk_is_transparent(struct sock *sk)\r\n{\r\nswitch (sk->sk_state) {\r\ncase TCP_TIME_WAIT:\r\nif (inet_twsk(sk)->tw_transparent)\r\nreturn true;\r\nbreak;\r\ncase TCP_NEW_SYN_RECV:\r\nif (inet_rsk(inet_reqsk(sk))->no_srccheck)\r\nreturn true;\r\nbreak;\r\ndefault:\r\nif (inet_sk(sk)->transparent)\r\nreturn true;\r\n}\r\nsock_gen_put(sk);\r\nreturn false;\r\n}\r\nstatic inline __be32\r\ntproxy_laddr4(struct sk_buff *skb, __be32 user_laddr, __be32 daddr)\r\n{\r\nstruct in_device *indev;\r\n__be32 laddr;\r\nif (user_laddr)\r\nreturn user_laddr;\r\nladdr = 0;\r\nrcu_read_lock();\r\nindev = __in_dev_get_rcu(skb->dev);\r\nfor_primary_ifa(indev) {\r\nladdr = ifa->ifa_local;\r\nbreak;\r\n} endfor_ifa(indev);\r\nrcu_read_unlock();\r\nreturn laddr ? laddr : daddr;\r\n}\r\nstatic inline struct sock *\r\nnf_tproxy_get_sock_v4(struct net *net, struct sk_buff *skb, void *hp,\r\nconst u8 protocol,\r\nconst __be32 saddr, const __be32 daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in,\r\nconst enum nf_tproxy_lookup_t lookup_type)\r\n{\r\nstruct sock *sk;\r\nstruct tcphdr *tcph;\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nswitch (lookup_type) {\r\ncase NFT_LOOKUP_LISTENER:\r\ntcph = hp;\r\nsk = inet_lookup_listener(net, &tcp_hashinfo, skb,\r\nip_hdrlen(skb) +\r\n__tcp_hdrlen(tcph),\r\nsaddr, sport,\r\ndaddr, dport,\r\nin->ifindex);\r\nif (sk && !atomic_inc_not_zero(&sk->sk_refcnt))\r\nsk = NULL;\r\nbreak;\r\ncase NFT_LOOKUP_ESTABLISHED:\r\nsk = inet_lookup_established(net, &tcp_hashinfo,\r\nsaddr, sport, daddr, dport,\r\nin->ifindex);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase IPPROTO_UDP:\r\nsk = udp4_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\nif (sk) {\r\nint connected = (sk->sk_state == TCP_ESTABLISHED);\r\nint wildcard = (inet_sk(sk)->inet_rcv_saddr == 0);\r\nif ((lookup_type == NFT_LOOKUP_ESTABLISHED && (!connected || wildcard)) ||\r\n(lookup_type == NFT_LOOKUP_LISTENER && connected)) {\r\nsock_put(sk);\r\nsk = NULL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nsk = NULL;\r\n}\r\npr_debug("tproxy socket lookup: proto %u %08x:%u -> %08x:%u, lookup type: %d, sock %p\n",\r\nprotocol, ntohl(saddr), ntohs(sport), ntohl(daddr), ntohs(dport), lookup_type, sk);\r\nreturn sk;\r\n}\r\nstatic inline struct sock *\r\nnf_tproxy_get_sock_v6(struct net *net, struct sk_buff *skb, int thoff, void *hp,\r\nconst u8 protocol,\r\nconst struct in6_addr *saddr, const struct in6_addr *daddr,\r\nconst __be16 sport, const __be16 dport,\r\nconst struct net_device *in,\r\nconst enum nf_tproxy_lookup_t lookup_type)\r\n{\r\nstruct sock *sk;\r\nstruct tcphdr *tcph;\r\nswitch (protocol) {\r\ncase IPPROTO_TCP:\r\nswitch (lookup_type) {\r\ncase NFT_LOOKUP_LISTENER:\r\ntcph = hp;\r\nsk = inet6_lookup_listener(net, &tcp_hashinfo, skb,\r\nthoff + __tcp_hdrlen(tcph),\r\nsaddr, sport,\r\ndaddr, ntohs(dport),\r\nin->ifindex);\r\nif (sk && !atomic_inc_not_zero(&sk->sk_refcnt))\r\nsk = NULL;\r\nbreak;\r\ncase NFT_LOOKUP_ESTABLISHED:\r\nsk = __inet6_lookup_established(net, &tcp_hashinfo,\r\nsaddr, sport, daddr, ntohs(dport),\r\nin->ifindex);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\nbreak;\r\ncase IPPROTO_UDP:\r\nsk = udp6_lib_lookup(net, saddr, sport, daddr, dport,\r\nin->ifindex);\r\nif (sk) {\r\nint connected = (sk->sk_state == TCP_ESTABLISHED);\r\nint wildcard = ipv6_addr_any(&sk->sk_v6_rcv_saddr);\r\nif ((lookup_type == NFT_LOOKUP_ESTABLISHED && (!connected || wildcard)) ||\r\n(lookup_type == NFT_LOOKUP_LISTENER && connected)) {\r\nsock_put(sk);\r\nsk = NULL;\r\n}\r\n}\r\nbreak;\r\ndefault:\r\nWARN_ON(1);\r\nsk = NULL;\r\n}\r\npr_debug("tproxy socket lookup: proto %u %pI6:%u -> %pI6:%u, lookup type: %d, sock %p\n",\r\nprotocol, saddr, ntohs(sport), daddr, ntohs(dport), lookup_type, sk);\r\nreturn sk;\r\n}\r\nstatic struct sock *\r\ntproxy_handle_time_wait4(struct net *net, struct sk_buff *skb,\r\n__be32 laddr, __be16 lport, struct sock *sk)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct tcphdr _hdr, *hp;\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\ninet_twsk_put(inet_twsk(sk));\r\nreturn NULL;\r\n}\r\nif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\r\nstruct sock *sk2;\r\nsk2 = nf_tproxy_get_sock_v4(net, skb, hp, iph->protocol,\r\niph->saddr, laddr ? laddr : iph->daddr,\r\nhp->source, lport ? lport : hp->dest,\r\nskb->dev, NFT_LOOKUP_LISTENER);\r\nif (sk2) {\r\ninet_twsk_deschedule_put(inet_twsk(sk));\r\nsk = sk2;\r\n}\r\n}\r\nreturn sk;\r\n}\r\nstatic void\r\nnf_tproxy_assign_sock(struct sk_buff *skb, struct sock *sk)\r\n{\r\nskb_orphan(skb);\r\nskb->sk = sk;\r\nskb->destructor = sock_edemux;\r\n}\r\nstatic unsigned int\r\ntproxy_tg4(struct net *net, struct sk_buff *skb, __be32 laddr, __be16 lport,\r\nu_int32_t mark_mask, u_int32_t mark_value)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct udphdr _hdr, *hp;\r\nstruct sock *sk;\r\nhp = skb_header_pointer(skb, ip_hdrlen(skb), sizeof(_hdr), &_hdr);\r\nif (hp == NULL)\r\nreturn NF_DROP;\r\nsk = nf_tproxy_get_sock_v4(net, skb, hp, iph->protocol,\r\niph->saddr, iph->daddr,\r\nhp->source, hp->dest,\r\nskb->dev, NFT_LOOKUP_ESTABLISHED);\r\nladdr = tproxy_laddr4(skb, laddr, iph->daddr);\r\nif (!lport)\r\nlport = hp->dest;\r\nif (sk && sk->sk_state == TCP_TIME_WAIT)\r\nsk = tproxy_handle_time_wait4(net, skb, laddr, lport, sk);\r\nelse if (!sk)\r\nsk = nf_tproxy_get_sock_v4(net, skb, hp, iph->protocol,\r\niph->saddr, laddr,\r\nhp->source, lport,\r\nskb->dev, NFT_LOOKUP_LISTENER);\r\nif (sk && tproxy_sk_is_transparent(sk)) {\r\nskb->mark = (skb->mark & ~mark_mask) ^ mark_value;\r\npr_debug("redirecting: proto %hhu %pI4:%hu -> %pI4:%hu, mark: %x\n",\r\niph->protocol, &iph->daddr, ntohs(hp->dest),\r\n&laddr, ntohs(lport), skb->mark);\r\nnf_tproxy_assign_sock(skb, sk);\r\nreturn NF_ACCEPT;\r\n}\r\npr_debug("no socket, dropping: proto %hhu %pI4:%hu -> %pI4:%hu, mark: %x\n",\r\niph->protocol, &iph->saddr, ntohs(hp->source),\r\n&iph->daddr, ntohs(hp->dest), skb->mark);\r\nreturn NF_DROP;\r\n}\r\nstatic unsigned int\r\ntproxy_tg4_v0(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_tproxy_target_info *tgi = par->targinfo;\r\nreturn tproxy_tg4(xt_net(par), skb, tgi->laddr, tgi->lport,\r\ntgi->mark_mask, tgi->mark_value);\r\n}\r\nstatic unsigned int\r\ntproxy_tg4_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\r\nreturn tproxy_tg4(xt_net(par), skb, tgi->laddr.ip, tgi->lport,\r\ntgi->mark_mask, tgi->mark_value);\r\n}\r\nstatic inline const struct in6_addr *\r\ntproxy_laddr6(struct sk_buff *skb, const struct in6_addr *user_laddr,\r\nconst struct in6_addr *daddr)\r\n{\r\nstruct inet6_dev *indev;\r\nstruct inet6_ifaddr *ifa;\r\nstruct in6_addr *laddr;\r\nif (!ipv6_addr_any(user_laddr))\r\nreturn user_laddr;\r\nladdr = NULL;\r\nrcu_read_lock();\r\nindev = __in6_dev_get(skb->dev);\r\nif (indev) {\r\nread_lock_bh(&indev->lock);\r\nlist_for_each_entry(ifa, &indev->addr_list, if_list) {\r\nif (ifa->flags & (IFA_F_TENTATIVE | IFA_F_DEPRECATED))\r\ncontinue;\r\nladdr = &ifa->addr;\r\nbreak;\r\n}\r\nread_unlock_bh(&indev->lock);\r\n}\r\nrcu_read_unlock();\r\nreturn laddr ? laddr : daddr;\r\n}\r\nstatic struct sock *\r\ntproxy_handle_time_wait6(struct sk_buff *skb, int tproto, int thoff,\r\nconst struct xt_action_param *par,\r\nstruct sock *sk)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nstruct tcphdr _hdr, *hp;\r\nconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\r\nhp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\ninet_twsk_put(inet_twsk(sk));\r\nreturn NULL;\r\n}\r\nif (hp->syn && !hp->rst && !hp->ack && !hp->fin) {\r\nstruct sock *sk2;\r\nsk2 = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, hp, tproto,\r\n&iph->saddr,\r\ntproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr),\r\nhp->source,\r\ntgi->lport ? tgi->lport : hp->dest,\r\nskb->dev, NFT_LOOKUP_LISTENER);\r\nif (sk2) {\r\ninet_twsk_deschedule_put(inet_twsk(sk));\r\nsk = sk2;\r\n}\r\n}\r\nreturn sk;\r\n}\r\nstatic unsigned int\r\ntproxy_tg6_v1(struct sk_buff *skb, const struct xt_action_param *par)\r\n{\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nconst struct xt_tproxy_target_info_v1 *tgi = par->targinfo;\r\nstruct udphdr _hdr, *hp;\r\nstruct sock *sk;\r\nconst struct in6_addr *laddr;\r\n__be16 lport;\r\nint thoff = 0;\r\nint tproto;\r\ntproto = ipv6_find_hdr(skb, &thoff, -1, NULL, NULL);\r\nif (tproto < 0) {\r\npr_debug("unable to find transport header in IPv6 packet, dropping\n");\r\nreturn NF_DROP;\r\n}\r\nhp = skb_header_pointer(skb, thoff, sizeof(_hdr), &_hdr);\r\nif (hp == NULL) {\r\npr_debug("unable to grab transport header contents in IPv6 packet, dropping\n");\r\nreturn NF_DROP;\r\n}\r\nsk = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, hp, tproto,\r\n&iph->saddr, &iph->daddr,\r\nhp->source, hp->dest,\r\nxt_in(par), NFT_LOOKUP_ESTABLISHED);\r\nladdr = tproxy_laddr6(skb, &tgi->laddr.in6, &iph->daddr);\r\nlport = tgi->lport ? tgi->lport : hp->dest;\r\nif (sk && sk->sk_state == TCP_TIME_WAIT)\r\nsk = tproxy_handle_time_wait6(skb, tproto, thoff, par, sk);\r\nelse if (!sk)\r\nsk = nf_tproxy_get_sock_v6(xt_net(par), skb, thoff, hp,\r\ntproto, &iph->saddr, laddr,\r\nhp->source, lport,\r\nxt_in(par), NFT_LOOKUP_LISTENER);\r\nif (sk && tproxy_sk_is_transparent(sk)) {\r\nskb->mark = (skb->mark & ~tgi->mark_mask) ^ tgi->mark_value;\r\npr_debug("redirecting: proto %hhu %pI6:%hu -> %pI6:%hu, mark: %x\n",\r\ntproto, &iph->saddr, ntohs(hp->source),\r\nladdr, ntohs(lport), skb->mark);\r\nnf_tproxy_assign_sock(skb, sk);\r\nreturn NF_ACCEPT;\r\n}\r\npr_debug("no socket, dropping: proto %hhu %pI6:%hu -> %pI6:%hu, mark: %x\n",\r\ntproto, &iph->saddr, ntohs(hp->source),\r\n&iph->daddr, ntohs(hp->dest), skb->mark);\r\nreturn NF_DROP;\r\n}\r\nstatic int tproxy_tg6_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ip6t_ip6 *i = par->entryinfo;\r\nint err;\r\nerr = nf_defrag_ipv6_enable(par->net);\r\nif (err)\r\nreturn err;\r\nif ((i->proto == IPPROTO_TCP || i->proto == IPPROTO_UDP) &&\r\n!(i->invflags & IP6T_INV_PROTO))\r\nreturn 0;\r\npr_info("Can be used only in combination with "\r\n"either -p tcp or -p udp\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int tproxy_tg4_check(const struct xt_tgchk_param *par)\r\n{\r\nconst struct ipt_ip *i = par->entryinfo;\r\nint err;\r\nerr = nf_defrag_ipv4_enable(par->net);\r\nif (err)\r\nreturn err;\r\nif ((i->proto == IPPROTO_TCP || i->proto == IPPROTO_UDP)\r\n&& !(i->invflags & IPT_INV_PROTO))\r\nreturn 0;\r\npr_info("Can be used only in combination with "\r\n"either -p tcp or -p udp\n");\r\nreturn -EINVAL;\r\n}\r\nstatic int __init tproxy_tg_init(void)\r\n{\r\nreturn xt_register_targets(tproxy_tg_reg, ARRAY_SIZE(tproxy_tg_reg));\r\n}\r\nstatic void __exit tproxy_tg_exit(void)\r\n{\r\nxt_unregister_targets(tproxy_tg_reg, ARRAY_SIZE(tproxy_tg_reg));\r\n}
