static int frontend_bus_id(char bus_id[XEN_BUS_ID_SIZE], const char *nodename)\r\n{\r\nnodename = strchr(nodename, '/');\r\nif (!nodename || strlen(nodename + 1) >= XEN_BUS_ID_SIZE) {\r\npr_warn("bad frontend %s\n", nodename);\r\nreturn -EINVAL;\r\n}\r\nstrlcpy(bus_id, nodename + 1, XEN_BUS_ID_SIZE);\r\nif (!strchr(bus_id, '/')) {\r\npr_warn("bus_id %s no slash\n", bus_id);\r\nreturn -EINVAL;\r\n}\r\n*strchr(bus_id, '/') = '-';\r\nreturn 0;\r\n}\r\nstatic int xenbus_probe_frontend(struct xen_bus_type *bus, const char *type,\r\nconst char *name)\r\n{\r\nchar *nodename;\r\nint err;\r\nif (!strncmp(type, "console", 7) && !strncmp(name, "0", 1)) {\r\nDPRINTK("Ignoring buggy device entry console/0");\r\nreturn 0;\r\n}\r\nnodename = kasprintf(GFP_KERNEL, "%s/%s/%s", bus->root, type, name);\r\nif (!nodename)\r\nreturn -ENOMEM;\r\nDPRINTK("%s", nodename);\r\nerr = xenbus_probe_node(bus, type, nodename);\r\nkfree(nodename);\r\nreturn err;\r\n}\r\nstatic int xenbus_uevent_frontend(struct device *_dev,\r\nstruct kobj_uevent_env *env)\r\n{\r\nstruct xenbus_device *dev = to_xenbus_device(_dev);\r\nif (add_uevent_var(env, "MODALIAS=xen:%s", dev->devicetype))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void backend_changed(struct xenbus_watch *watch,\r\nconst char *path, const char *token)\r\n{\r\nxenbus_otherend_changed(watch, path, token, 1);\r\n}\r\nstatic void xenbus_frontend_delayed_resume(struct work_struct *w)\r\n{\r\nstruct xenbus_device *xdev = container_of(w, struct xenbus_device, work);\r\nxenbus_dev_resume(&xdev->dev);\r\n}\r\nstatic int xenbus_frontend_dev_resume(struct device *dev)\r\n{\r\nif (xen_store_domain_type == XS_LOCAL) {\r\nstruct xenbus_device *xdev = to_xenbus_device(dev);\r\nschedule_work(&xdev->work);\r\nreturn 0;\r\n}\r\nreturn xenbus_dev_resume(dev);\r\n}\r\nstatic int xenbus_frontend_dev_probe(struct device *dev)\r\n{\r\nif (xen_store_domain_type == XS_LOCAL) {\r\nstruct xenbus_device *xdev = to_xenbus_device(dev);\r\nINIT_WORK(&xdev->work, xenbus_frontend_delayed_resume);\r\n}\r\nreturn xenbus_dev_probe(dev);\r\n}\r\nstatic void frontend_changed(struct xenbus_watch *watch,\r\nconst char *path, const char *token)\r\n{\r\nDPRINTK("");\r\nxenbus_dev_changed(path, &xenbus_frontend);\r\n}\r\nstatic int read_backend_details(struct xenbus_device *xendev)\r\n{\r\nreturn xenbus_read_otherend_details(xendev, "backend-id", "backend");\r\n}\r\nstatic int is_device_connecting(struct device *dev, void *data, bool ignore_nonessential)\r\n{\r\nstruct xenbus_device *xendev = to_xenbus_device(dev);\r\nstruct device_driver *drv = data;\r\nstruct xenbus_driver *xendrv;\r\nif (!dev->driver)\r\nreturn 0;\r\nif (drv && (dev->driver != drv))\r\nreturn 0;\r\nif (ignore_nonessential) {\r\nif ((strncmp(xendev->nodename, "device/vkbd", 11) == 0))\r\nreturn 0;\r\nif ((strncmp(xendev->nodename, "device/vfb", 10) == 0))\r\nreturn 0;\r\n}\r\nxendrv = to_xenbus_driver(dev->driver);\r\nreturn (xendev->state < XenbusStateConnected ||\r\n(xendev->state == XenbusStateConnected &&\r\nxendrv->is_ready && !xendrv->is_ready(xendev)));\r\n}\r\nstatic int essential_device_connecting(struct device *dev, void *data)\r\n{\r\nreturn is_device_connecting(dev, data, true );\r\n}\r\nstatic int non_essential_device_connecting(struct device *dev, void *data)\r\n{\r\nreturn is_device_connecting(dev, data, false);\r\n}\r\nstatic int exists_essential_connecting_device(struct device_driver *drv)\r\n{\r\nreturn bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,\r\nessential_device_connecting);\r\n}\r\nstatic int exists_non_essential_connecting_device(struct device_driver *drv)\r\n{\r\nreturn bus_for_each_dev(&xenbus_frontend.bus, NULL, drv,\r\nnon_essential_device_connecting);\r\n}\r\nstatic int print_device_status(struct device *dev, void *data)\r\n{\r\nstruct xenbus_device *xendev = to_xenbus_device(dev);\r\nstruct device_driver *drv = data;\r\nif (drv && (dev->driver != drv))\r\nreturn 0;\r\nif (!dev->driver) {\r\npr_info("Device with no driver: %s\n", xendev->nodename);\r\n} else if (xendev->state < XenbusStateConnected) {\r\nenum xenbus_state rstate = XenbusStateUnknown;\r\nif (xendev->otherend)\r\nrstate = xenbus_read_driver_state(xendev->otherend);\r\npr_warn("Timeout connecting to device: %s (local state %d, remote state %d)\n",\r\nxendev->nodename, xendev->state, rstate);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool wait_loop(unsigned long start, unsigned int max_delay,\r\nunsigned int *seconds_waited)\r\n{\r\nif (time_after(jiffies, start + (*seconds_waited+5)*HZ)) {\r\nif (!*seconds_waited)\r\npr_warn("Waiting for devices to initialise: ");\r\n*seconds_waited += 5;\r\npr_cont("%us...", max_delay - *seconds_waited);\r\nif (*seconds_waited == max_delay) {\r\npr_cont("\n");\r\nreturn true;\r\n}\r\n}\r\nschedule_timeout_interruptible(HZ/10);\r\nreturn false;\r\n}\r\nstatic void wait_for_devices(struct xenbus_driver *xendrv)\r\n{\r\nunsigned long start = jiffies;\r\nstruct device_driver *drv = xendrv ? &xendrv->driver : NULL;\r\nunsigned int seconds_waited = 0;\r\nif (!ready_to_wait_for_devices || !xen_domain())\r\nreturn;\r\nwhile (exists_non_essential_connecting_device(drv))\r\nif (wait_loop(start, 30, &seconds_waited))\r\nbreak;\r\nwhile (exists_essential_connecting_device(drv))\r\nif (wait_loop(start, 270, &seconds_waited))\r\nbreak;\r\nif (seconds_waited)\r\nprintk("\n");\r\nbus_for_each_dev(&xenbus_frontend.bus, NULL, drv,\r\nprint_device_status);\r\n}\r\nint __xenbus_register_frontend(struct xenbus_driver *drv, struct module *owner,\r\nconst char *mod_name)\r\n{\r\nint ret;\r\ndrv->read_otherend_details = read_backend_details;\r\nret = xenbus_register_driver_common(drv, &xenbus_frontend,\r\nowner, mod_name);\r\nif (ret)\r\nreturn ret;\r\nwait_for_devices(drv);\r\nreturn 0;\r\n}\r\nstatic void xenbus_reset_backend_state_changed(struct xenbus_watch *w,\r\nconst char *path, const char *token)\r\n{\r\nif (xenbus_scanf(XBT_NIL, path, "", "%i",\r\n&backend_state) != 1)\r\nbackend_state = XenbusStateUnknown;\r\nprintk(KERN_DEBUG "XENBUS: backend %s %s\n",\r\npath, xenbus_strstate(backend_state));\r\nwake_up(&backend_state_wq);\r\n}\r\nstatic void xenbus_reset_wait_for_backend(char *be, int expected)\r\n{\r\nlong timeout;\r\ntimeout = wait_event_interruptible_timeout(backend_state_wq,\r\nbackend_state == expected, 5 * HZ);\r\nif (timeout <= 0)\r\npr_info("backend %s timed out\n", be);\r\n}\r\nstatic void xenbus_reset_frontend(char *fe, char *be, int be_state)\r\n{\r\nstruct xenbus_watch be_watch;\r\nprintk(KERN_DEBUG "XENBUS: backend %s %s\n",\r\nbe, xenbus_strstate(be_state));\r\nmemset(&be_watch, 0, sizeof(be_watch));\r\nbe_watch.node = kasprintf(GFP_NOIO | __GFP_HIGH, "%s/state", be);\r\nif (!be_watch.node)\r\nreturn;\r\nbe_watch.callback = xenbus_reset_backend_state_changed;\r\nbackend_state = XenbusStateUnknown;\r\npr_info("triggering reconnect on %s\n", be);\r\nregister_xenbus_watch(&be_watch);\r\nswitch (be_state) {\r\ncase XenbusStateConnected:\r\nxenbus_printf(XBT_NIL, fe, "state", "%d", XenbusStateClosing);\r\nxenbus_reset_wait_for_backend(be, XenbusStateClosing);\r\ncase XenbusStateClosing:\r\nxenbus_printf(XBT_NIL, fe, "state", "%d", XenbusStateClosed);\r\nxenbus_reset_wait_for_backend(be, XenbusStateClosed);\r\ncase XenbusStateClosed:\r\nxenbus_printf(XBT_NIL, fe, "state", "%d", XenbusStateInitialising);\r\nxenbus_reset_wait_for_backend(be, XenbusStateInitWait);\r\n}\r\nunregister_xenbus_watch(&be_watch);\r\npr_info("reconnect done on %s\n", be);\r\nkfree(be_watch.node);\r\n}\r\nstatic void xenbus_check_frontend(char *class, char *dev)\r\n{\r\nint be_state, fe_state, err;\r\nchar *backend, *frontend;\r\nfrontend = kasprintf(GFP_NOIO | __GFP_HIGH, "device/%s/%s", class, dev);\r\nif (!frontend)\r\nreturn;\r\nerr = xenbus_scanf(XBT_NIL, frontend, "state", "%i", &fe_state);\r\nif (err != 1)\r\ngoto out;\r\nswitch (fe_state) {\r\ncase XenbusStateConnected:\r\ncase XenbusStateClosed:\r\nprintk(KERN_DEBUG "XENBUS: frontend %s %s\n",\r\nfrontend, xenbus_strstate(fe_state));\r\nbackend = xenbus_read(XBT_NIL, frontend, "backend", NULL);\r\nif (!backend || IS_ERR(backend))\r\ngoto out;\r\nerr = xenbus_scanf(XBT_NIL, backend, "state", "%i", &be_state);\r\nif (err == 1)\r\nxenbus_reset_frontend(frontend, backend, be_state);\r\nkfree(backend);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nout:\r\nkfree(frontend);\r\n}\r\nstatic void xenbus_reset_state(void)\r\n{\r\nchar **devclass, **dev;\r\nint devclass_n, dev_n;\r\nint i, j;\r\ndevclass = xenbus_directory(XBT_NIL, "device", "", &devclass_n);\r\nif (IS_ERR(devclass))\r\nreturn;\r\nfor (i = 0; i < devclass_n; i++) {\r\ndev = xenbus_directory(XBT_NIL, "device", devclass[i], &dev_n);\r\nif (IS_ERR(dev))\r\ncontinue;\r\nfor (j = 0; j < dev_n; j++)\r\nxenbus_check_frontend(devclass[i], dev[j]);\r\nkfree(dev);\r\n}\r\nkfree(devclass);\r\n}\r\nstatic int frontend_probe_and_watch(struct notifier_block *notifier,\r\nunsigned long event,\r\nvoid *data)\r\n{\r\nif (xen_hvm_domain())\r\nxenbus_reset_state();\r\nxenbus_probe_devices(&xenbus_frontend);\r\nregister_xenbus_watch(&fe_watch);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int __init xenbus_probe_frontend_init(void)\r\n{\r\nstatic struct notifier_block xenstore_notifier = {\r\n.notifier_call = frontend_probe_and_watch\r\n};\r\nint err;\r\nDPRINTK("");\r\nerr = bus_register(&xenbus_frontend.bus);\r\nif (err)\r\nreturn err;\r\nregister_xenstore_notifier(&xenstore_notifier);\r\nreturn 0;\r\n}\r\nstatic int __init boot_wait_for_devices(void)\r\n{\r\nif (!xen_has_pv_devices())\r\nreturn -ENODEV;\r\nready_to_wait_for_devices = 1;\r\nwait_for_devices(NULL);\r\nreturn 0;\r\n}
