static int ltc_wait_ready(struct i2c_client *client)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(LTC_POLL_TIMEOUT);\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint status;\r\nu8 mask;\r\nif (!needs_polling(data))\r\nreturn 0;\r\nmask = LTC_NOT_BUSY;\r\nif (data->id != ltc3883)\r\nmask |= LTC_NOT_PENDING;\r\ndo {\r\nstatus = pmbus_read_byte_data(client, 0, LTC2978_MFR_COMMON);\r\nif (status == -EBADMSG || status == -ENXIO) {\r\nusleep_range(50, 100);\r\ncontinue;\r\n}\r\nif (status < 0)\r\nreturn status;\r\nif ((status & mask) == mask)\r\nreturn 0;\r\nusleep_range(50, 100);\r\n} while (time_before(jiffies, timeout));\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int ltc_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nint ret;\r\nret = ltc_wait_ready(client);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn pmbus_read_word_data(client, page, reg);\r\n}\r\nstatic int ltc_read_byte_data(struct i2c_client *client, int page, int reg)\r\n{\r\nint ret;\r\nret = ltc_wait_ready(client);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn pmbus_read_byte_data(client, page, reg);\r\n}\r\nstatic int ltc_write_byte(struct i2c_client *client, int page, u8 byte)\r\n{\r\nint ret;\r\nret = ltc_wait_ready(client);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn pmbus_write_byte(client, page, byte);\r\n}\r\nstatic inline int lin11_to_val(int data)\r\n{\r\ns16 e = ((s16)data) >> 11;\r\ns32 m = (((s16)(data << 5)) >> 5);\r\ne += 6;\r\nreturn (e < 0 ? m >> -e : m << e);\r\n}\r\nstatic int ltc_get_max(struct ltc2978_data *data, struct i2c_client *client,\r\nint page, int reg, u16 *pmax)\r\n{\r\nint ret;\r\nret = ltc_read_word_data(client, page, reg);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret) > lin11_to_val(*pmax))\r\n*pmax = ret;\r\nret = *pmax;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc_get_min(struct ltc2978_data *data, struct i2c_client *client,\r\nint page, int reg, u16 *pmin)\r\n{\r\nint ret;\r\nret = ltc_read_word_data(client, page, reg);\r\nif (ret >= 0) {\r\nif (lin11_to_val(ret) < lin11_to_val(*pmin))\r\n*pmin = ret;\r\nret = *pmin;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_read_word_data_common(struct i2c_client *client, int page,\r\nint reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_VIN_MAX:\r\nret = ltc_get_max(data, client, page, LTC2978_MFR_VIN_PEAK,\r\n&data->vin_max);\r\nbreak;\r\ncase PMBUS_VIRT_READ_VOUT_MAX:\r\nret = ltc_read_word_data(client, page, LTC2978_MFR_VOUT_PEAK);\r\nif (ret >= 0) {\r\nif (ret > data->vout_max[page])\r\ndata->vout_max[page] = ret;\r\nret = data->vout_max[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_TEMP_MAX:\r\nret = ltc_get_max(data, client, page,\r\nLTC2978_MFR_TEMPERATURE_PEAK,\r\n&data->temp_max[page]);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_VOUT_HISTORY:\r\ncase PMBUS_VIRT_RESET_VIN_HISTORY:\r\ncase PMBUS_VIRT_RESET_TEMP_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc_wait_ready(client);\r\nif (ret < 0)\r\nreturn ret;\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_VIN_MIN:\r\nret = ltc_get_min(data, client, page, LTC2978_MFR_VIN_MIN,\r\n&data->vin_min);\r\nbreak;\r\ncase PMBUS_VIRT_READ_VOUT_MIN:\r\nret = ltc_read_word_data(client, page, LTC2978_MFR_VOUT_MIN);\r\nif (ret >= 0) {\r\nif (data->vout_max[page] && ret > data->vout_max[page])\r\nret = data->vout_max[page];\r\nif (ret < data->vout_min[page])\r\ndata->vout_min[page] = ret;\r\nret = data->vout_min[page];\r\n}\r\nbreak;\r\ncase PMBUS_VIRT_READ_TEMP_MIN:\r\nret = ltc_get_min(data, client, page,\r\nLTC2978_MFR_TEMPERATURE_MIN,\r\n&data->temp_min[page]);\r\nbreak;\r\ncase PMBUS_VIRT_READ_IOUT_MAX:\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\ncase PMBUS_VIRT_READ_TEMP2_MAX:\r\ncase PMBUS_VIRT_RESET_TEMP2_HISTORY:\r\nret = -ENXIO;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data_common(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2974_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IOUT_MAX:\r\nret = ltc_get_max(data, client, page, LTC2974_MFR_IOUT_PEAK,\r\n&data->iout_max[page]);\r\nbreak;\r\ncase PMBUS_VIRT_READ_IOUT_MIN:\r\nret = ltc_get_min(data, client, page, LTC2974_MFR_IOUT_MIN,\r\n&data->iout_min[page]);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2975_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IIN_MAX:\r\nret = ltc_get_max(data, client, page, LTC2975_MFR_IIN_PEAK,\r\n&data->iin_max);\r\nbreak;\r\ncase PMBUS_VIRT_READ_IIN_MIN:\r\nret = ltc_get_min(data, client, page, LTC2975_MFR_IIN_MIN,\r\n&data->iin_min);\r\nbreak;\r\ncase PMBUS_VIRT_READ_PIN_MAX:\r\nret = ltc_get_max(data, client, page, LTC2975_MFR_PIN_PEAK,\r\n&data->pin_max);\r\nbreak;\r\ncase PMBUS_VIRT_READ_PIN_MIN:\r\nret = ltc_get_min(data, client, page, LTC2975_MFR_PIN_MIN,\r\n&data->pin_min);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IIN_HISTORY:\r\ncase PMBUS_VIRT_RESET_PIN_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc3880_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IOUT_MAX:\r\nret = ltc_get_max(data, client, page, LTC3880_MFR_IOUT_PEAK,\r\n&data->iout_max[page]);\r\nbreak;\r\ncase PMBUS_VIRT_READ_TEMP2_MAX:\r\nret = ltc_get_max(data, client, page,\r\nLTC3880_MFR_TEMPERATURE2_PEAK,\r\n&data->temp2_max);\r\nbreak;\r\ncase PMBUS_VIRT_READ_VIN_MIN:\r\ncase PMBUS_VIRT_READ_VOUT_MIN:\r\ncase PMBUS_VIRT_READ_TEMP_MIN:\r\nret = -ENXIO;\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\ncase PMBUS_VIRT_RESET_TEMP2_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc2978_read_word_data_common(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc3883_read_word_data(struct i2c_client *client, int page, int reg)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_READ_IIN_MAX:\r\nret = ltc_get_max(data, client, page, LTC3883_MFR_IIN_PEAK,\r\n&data->iin_max);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IIN_HISTORY:\r\nret = 0;\r\nbreak;\r\ndefault:\r\nret = ltc3880_read_word_data(client, page, reg);\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_clear_peaks(struct ltc2978_data *data,\r\nstruct i2c_client *client, int page)\r\n{\r\nint ret;\r\nif (has_clear_peaks(data))\r\nret = ltc_write_byte(client, 0, LTC3880_MFR_CLEAR_PEAKS);\r\nelse\r\nret = ltc_write_byte(client, page, PMBUS_CLEAR_FAULTS);\r\nreturn ret;\r\n}\r\nstatic int ltc2978_write_word_data(struct i2c_client *client, int page,\r\nint reg, u16 word)\r\n{\r\nconst struct pmbus_driver_info *info = pmbus_get_driver_info(client);\r\nstruct ltc2978_data *data = to_ltc2978_data(info);\r\nint ret;\r\nswitch (reg) {\r\ncase PMBUS_VIRT_RESET_IIN_HISTORY:\r\ndata->iin_max = 0x7c00;\r\ndata->iin_min = 0x7bff;\r\nret = ltc2978_clear_peaks(data, client, 0);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_PIN_HISTORY:\r\ndata->pin_max = 0x7c00;\r\ndata->pin_min = 0x7bff;\r\nret = ltc2978_clear_peaks(data, client, 0);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_IOUT_HISTORY:\r\ndata->iout_max[page] = 0x7c00;\r\ndata->iout_min[page] = 0xfbff;\r\nret = ltc2978_clear_peaks(data, client, page);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_TEMP2_HISTORY:\r\ndata->temp2_max = 0x7c00;\r\nret = ltc2978_clear_peaks(data, client, page);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_VOUT_HISTORY:\r\ndata->vout_min[page] = 0xffff;\r\ndata->vout_max[page] = 0;\r\nret = ltc2978_clear_peaks(data, client, page);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_VIN_HISTORY:\r\ndata->vin_min = 0x7bff;\r\ndata->vin_max = 0x7c00;\r\nret = ltc2978_clear_peaks(data, client, page);\r\nbreak;\r\ncase PMBUS_VIRT_RESET_TEMP_HISTORY:\r\ndata->temp_min[page] = 0x7bff;\r\ndata->temp_max[page] = 0x7c00;\r\nret = ltc2978_clear_peaks(data, client, page);\r\nbreak;\r\ndefault:\r\nret = ltc_wait_ready(client);\r\nif (ret < 0)\r\nreturn ret;\r\nret = -ENODATA;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int ltc2978_get_id(struct i2c_client *client)\r\n{\r\nint chip_id;\r\nchip_id = i2c_smbus_read_word_data(client, LTC2978_MFR_SPECIAL_ID);\r\nif (chip_id < 0) {\r\nconst struct i2c_device_id *id;\r\nu8 buf[I2C_SMBUS_BLOCK_MAX];\r\nint ret;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_BLOCK_DATA))\r\nreturn -ENODEV;\r\nret = i2c_smbus_read_block_data(client, PMBUS_MFR_ID, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret < 3 || strncmp(buf, "LTC", 3))\r\nreturn -ENODEV;\r\nret = i2c_smbus_read_block_data(client, PMBUS_MFR_MODEL, buf);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (id = &ltc2978_id[0]; strlen(id->name); id++) {\r\nif (!strncasecmp(id->name, buf, strlen(id->name)))\r\nreturn (int)id->driver_data;\r\n}\r\nreturn -ENODEV;\r\n}\r\nchip_id &= LTC2978_ID_MASK;\r\nif (chip_id == LTC2974_ID)\r\nreturn ltc2974;\r\nelse if (chip_id == LTC2975_ID)\r\nreturn ltc2975;\r\nelse if (chip_id == LTC2977_ID)\r\nreturn ltc2977;\r\nelse if (chip_id == LTC2978_ID_REV1 || chip_id == LTC2978_ID_REV2)\r\nreturn ltc2978;\r\nelse if (chip_id == LTC2980_ID_A || chip_id == LTC2980_ID_B)\r\nreturn ltc2980;\r\nelse if (chip_id == LTC3880_ID)\r\nreturn ltc3880;\r\nelse if (chip_id == LTC3882_ID || chip_id == LTC3882_ID_D1)\r\nreturn ltc3882;\r\nelse if (chip_id == LTC3883_ID)\r\nreturn ltc3883;\r\nelse if (chip_id == LTC3886_ID)\r\nreturn ltc3886;\r\nelse if (chip_id == LTC3887_ID)\r\nreturn ltc3887;\r\nelse if (chip_id == LTM2987_ID_A || chip_id == LTM2987_ID_B)\r\nreturn ltm2987;\r\nelse if (chip_id == LTM4675_ID)\r\nreturn ltm4675;\r\nelse if (chip_id == LTM4676_ID_REV1 || chip_id == LTM4676_ID_REV2 ||\r\nchip_id == LTM4676A_ID)\r\nreturn ltm4676;\r\ndev_err(&client->dev, "Unsupported chip ID 0x%x\n", chip_id);\r\nreturn -ENODEV;\r\n}\r\nstatic int ltc2978_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nint i, chip_id;\r\nstruct ltc2978_data *data;\r\nstruct pmbus_driver_info *info;\r\nif (!i2c_check_functionality(client->adapter,\r\nI2C_FUNC_SMBUS_READ_WORD_DATA))\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&client->dev, sizeof(struct ltc2978_data),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nchip_id = ltc2978_get_id(client);\r\nif (chip_id < 0)\r\nreturn chip_id;\r\ndata->id = chip_id;\r\nif (data->id != id->driver_data)\r\ndev_warn(&client->dev,\r\n"Device mismatch: Configured %s, detected %s\n",\r\nid->name,\r\nltc2978_id[data->id].name);\r\ninfo = &data->info;\r\ninfo->write_word_data = ltc2978_write_word_data;\r\ninfo->write_byte = ltc_write_byte;\r\ninfo->read_word_data = ltc_read_word_data;\r\ninfo->read_byte_data = ltc_read_byte_data;\r\ndata->vin_min = 0x7bff;\r\ndata->vin_max = 0x7c00;\r\nfor (i = 0; i < ARRAY_SIZE(data->vout_min); i++)\r\ndata->vout_min[i] = 0xffff;\r\nfor (i = 0; i < ARRAY_SIZE(data->iout_min); i++)\r\ndata->iout_min[i] = 0xfbff;\r\nfor (i = 0; i < ARRAY_SIZE(data->iout_max); i++)\r\ndata->iout_max[i] = 0x7c00;\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_min); i++)\r\ndata->temp_min[i] = 0x7bff;\r\nfor (i = 0; i < ARRAY_SIZE(data->temp_max); i++)\r\ndata->temp_max[i] = 0x7c00;\r\ndata->temp2_max = 0x7c00;\r\nswitch (data->id) {\r\ncase ltc2974:\r\ninfo->read_word_data = ltc2974_read_word_data;\r\ninfo->pages = LTC2974_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_TEMP2;\r\nfor (i = 0; i < info->pages; i++) {\r\ninfo->func[i] |= PMBUS_HAVE_VOUT\r\n| PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\r\n}\r\nbreak;\r\ncase ltc2975:\r\ninfo->read_word_data = ltc2975_read_word_data;\r\ninfo->pages = LTC2974_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_IIN | PMBUS_HAVE_PIN\r\n| PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_TEMP2;\r\nfor (i = 0; i < info->pages; i++) {\r\ninfo->func[i] |= PMBUS_HAVE_VOUT\r\n| PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT;\r\n}\r\nbreak;\r\ncase ltc2977:\r\ncase ltc2978:\r\ncase ltc2980:\r\ncase ltm2987:\r\ninfo->read_word_data = ltc2978_read_word_data;\r\ninfo->pages = LTC2978_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nfor (i = 1; i < LTC2978_NUM_PAGES; i++) {\r\ninfo->func[i] = PMBUS_HAVE_VOUT\r\n| PMBUS_HAVE_STATUS_VOUT;\r\n}\r\nbreak;\r\ncase ltc3880:\r\ncase ltc3887:\r\ncase ltm4675:\r\ncase ltm4676:\r\ndata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\r\ninfo->read_word_data = ltc3880_read_word_data;\r\ninfo->pages = LTC3880_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\r\n| PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\r\n| PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\ninfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ncase ltc3882:\r\ndata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\r\ninfo->read_word_data = ltc3880_read_word_data;\r\ninfo->pages = LTC3880_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN\r\n| PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\r\n| PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\ninfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ncase ltc3883:\r\ndata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\r\ninfo->read_word_data = ltc3883_read_word_data;\r\ninfo->pages = LTC3883_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\r\n| PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_PIN | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\r\n| PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ncase ltc3886:\r\ndata->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;\r\ninfo->read_word_data = ltc3883_read_word_data;\r\ninfo->pages = LTC3880_NUM_PAGES;\r\ninfo->func[0] = PMBUS_HAVE_VIN | PMBUS_HAVE_IIN\r\n| PMBUS_HAVE_STATUS_INPUT\r\n| PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_PIN | PMBUS_HAVE_POUT | PMBUS_HAVE_TEMP\r\n| PMBUS_HAVE_TEMP2 | PMBUS_HAVE_STATUS_TEMP;\r\ninfo->func[1] = PMBUS_HAVE_VOUT | PMBUS_HAVE_STATUS_VOUT\r\n| PMBUS_HAVE_IOUT | PMBUS_HAVE_STATUS_IOUT\r\n| PMBUS_HAVE_POUT\r\n| PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n#if IS_ENABLED(CONFIG_SENSORS_LTC2978_REGULATOR)\r\ninfo->num_regulators = info->pages;\r\ninfo->reg_desc = ltc2978_reg_desc;\r\nif (info->num_regulators > ARRAY_SIZE(ltc2978_reg_desc)) {\r\ndev_err(&client->dev, "num_regulators too large!");\r\ninfo->num_regulators = ARRAY_SIZE(ltc2978_reg_desc);\r\n}\r\n#endif\r\nreturn pmbus_do_probe(client, id, info);\r\n}
