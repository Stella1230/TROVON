static int gpio_regulator_get_value(struct regulator_dev *dev)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].gpios == data->state)\r\nreturn data->states[ptr].value;\r\nreturn -EINVAL;\r\n}\r\nstatic int gpio_regulator_set_voltage(struct regulator_dev *dev,\r\nint min_uV, int max_uV,\r\nunsigned *selector)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr, target = 0, state, best_val = INT_MAX;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].value < best_val &&\r\ndata->states[ptr].value >= min_uV &&\r\ndata->states[ptr].value <= max_uV) {\r\ntarget = data->states[ptr].gpios;\r\nbest_val = data->states[ptr].value;\r\nif (selector)\r\n*selector = ptr;\r\n}\r\nif (best_val == INT_MAX)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\r\nstate = (target & (1 << ptr)) >> ptr;\r\ngpio_set_value_cansleep(data->gpios[ptr].gpio, state);\r\n}\r\ndata->state = target;\r\nreturn 0;\r\n}\r\nstatic int gpio_regulator_list_voltage(struct regulator_dev *dev,\r\nunsigned selector)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nif (selector >= data->nr_states)\r\nreturn -EINVAL;\r\nreturn data->states[selector].value;\r\n}\r\nstatic int gpio_regulator_set_current_limit(struct regulator_dev *dev,\r\nint min_uA, int max_uA)\r\n{\r\nstruct gpio_regulator_data *data = rdev_get_drvdata(dev);\r\nint ptr, target = 0, state, best_val = 0;\r\nfor (ptr = 0; ptr < data->nr_states; ptr++)\r\nif (data->states[ptr].value > best_val &&\r\ndata->states[ptr].value >= min_uA &&\r\ndata->states[ptr].value <= max_uA) {\r\ntarget = data->states[ptr].gpios;\r\nbest_val = data->states[ptr].value;\r\n}\r\nif (best_val == 0)\r\nreturn -EINVAL;\r\nfor (ptr = 0; ptr < data->nr_gpios; ptr++) {\r\nstate = (target & (1 << ptr)) >> ptr;\r\ngpio_set_value_cansleep(data->gpios[ptr].gpio, state);\r\n}\r\ndata->state = target;\r\nreturn 0;\r\n}\r\nstatic struct gpio_regulator_config *\r\nof_get_gpio_regulator_config(struct device *dev, struct device_node *np,\r\nconst struct regulator_desc *desc)\r\n{\r\nstruct gpio_regulator_config *config;\r\nconst char *regtype;\r\nint proplen, gpio, i;\r\nint ret;\r\nconfig = devm_kzalloc(dev,\r\nsizeof(struct gpio_regulator_config),\r\nGFP_KERNEL);\r\nif (!config)\r\nreturn ERR_PTR(-ENOMEM);\r\nconfig->init_data = of_get_regulator_init_data(dev, np, desc);\r\nif (!config->init_data)\r\nreturn ERR_PTR(-EINVAL);\r\nconfig->supply_name = config->init_data->constraints.name;\r\nif (of_property_read_bool(np, "enable-active-high"))\r\nconfig->enable_high = true;\r\nif (of_property_read_bool(np, "enable-at-boot"))\r\nconfig->enabled_at_boot = true;\r\nof_property_read_u32(np, "startup-delay-us", &config->startup_delay);\r\nconfig->enable_gpio = of_get_named_gpio(np, "enable-gpio", 0);\r\nif (config->enable_gpio < 0 && config->enable_gpio != -ENOENT)\r\nreturn ERR_PTR(config->enable_gpio);\r\nret = of_gpio_count(np);\r\nif ((ret < 0) && (ret != -ENOENT))\r\nreturn ERR_PTR(ret);\r\nif (ret > 0) {\r\nconfig->nr_gpios = ret;\r\nconfig->gpios = devm_kzalloc(dev,\r\nsizeof(struct gpio) * config->nr_gpios,\r\nGFP_KERNEL);\r\nif (!config->gpios)\r\nreturn ERR_PTR(-ENOMEM);\r\nproplen = of_property_count_u32_elems(np, "gpios-states");\r\nif (proplen < 0)\r\nproplen = 0;\r\nif (proplen > 0 && proplen != config->nr_gpios) {\r\ndev_warn(dev, "gpios <-> gpios-states mismatch\n");\r\nproplen = 0;\r\n}\r\nfor (i = 0; i < config->nr_gpios; i++) {\r\ngpio = of_get_named_gpio(np, "gpios", i);\r\nif (gpio < 0) {\r\nif (gpio != -ENOENT)\r\nreturn ERR_PTR(gpio);\r\nbreak;\r\n}\r\nconfig->gpios[i].gpio = gpio;\r\nif (proplen > 0) {\r\nof_property_read_u32_index(np, "gpios-states",\r\ni, &ret);\r\nif (ret)\r\nconfig->gpios[i].flags =\r\nGPIOF_OUT_INIT_HIGH;\r\n}\r\n}\r\n}\r\nproplen = of_property_count_u32_elems(np, "states");\r\nif (proplen < 0) {\r\ndev_err(dev, "No 'states' property found\n");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nconfig->states = devm_kzalloc(dev,\r\nsizeof(struct gpio_regulator_state)\r\n* (proplen / 2),\r\nGFP_KERNEL);\r\nif (!config->states)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < proplen / 2; i++) {\r\nof_property_read_u32_index(np, "states", i * 2,\r\n&config->states[i].value);\r\nof_property_read_u32_index(np, "states", i * 2 + 1,\r\n&config->states[i].gpios);\r\n}\r\nconfig->nr_states = i;\r\nconfig->type = REGULATOR_VOLTAGE;\r\nret = of_property_read_string(np, "regulator-type", &regtype);\r\nif (ret >= 0) {\r\nif (!strncmp("voltage", regtype, 7))\r\nconfig->type = REGULATOR_VOLTAGE;\r\nelse if (!strncmp("current", regtype, 7))\r\nconfig->type = REGULATOR_CURRENT;\r\nelse\r\ndev_warn(dev, "Unknown regulator-type '%s'\n",\r\nregtype);\r\n}\r\nreturn config;\r\n}\r\nstatic int gpio_regulator_probe(struct platform_device *pdev)\r\n{\r\nstruct gpio_regulator_config *config = dev_get_platdata(&pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct gpio_regulator_data *drvdata;\r\nstruct regulator_config cfg = { };\r\nint ptr, ret, state;\r\ndrvdata = devm_kzalloc(&pdev->dev, sizeof(struct gpio_regulator_data),\r\nGFP_KERNEL);\r\nif (drvdata == NULL)\r\nreturn -ENOMEM;\r\nif (np) {\r\nconfig = of_get_gpio_regulator_config(&pdev->dev, np,\r\n&drvdata->desc);\r\nif (IS_ERR(config))\r\nreturn PTR_ERR(config);\r\n}\r\ndrvdata->desc.name = kstrdup(config->supply_name, GFP_KERNEL);\r\nif (drvdata->desc.name == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate supply name\n");\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\nif (config->nr_gpios != 0) {\r\ndrvdata->gpios = kmemdup(config->gpios,\r\nconfig->nr_gpios * sizeof(struct gpio),\r\nGFP_KERNEL);\r\nif (drvdata->gpios == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate gpio data\n");\r\nret = -ENOMEM;\r\ngoto err_name;\r\n}\r\ndrvdata->nr_gpios = config->nr_gpios;\r\nret = gpio_request_array(drvdata->gpios, drvdata->nr_gpios);\r\nif (ret) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"Could not obtain regulator setting GPIOs: %d\n",\r\nret);\r\ngoto err_memstate;\r\n}\r\n}\r\ndrvdata->states = kmemdup(config->states,\r\nconfig->nr_states *\r\nsizeof(struct gpio_regulator_state),\r\nGFP_KERNEL);\r\nif (drvdata->states == NULL) {\r\ndev_err(&pdev->dev, "Failed to allocate state data\n");\r\nret = -ENOMEM;\r\ngoto err_memgpio;\r\n}\r\ndrvdata->nr_states = config->nr_states;\r\ndrvdata->desc.owner = THIS_MODULE;\r\ndrvdata->desc.enable_time = config->startup_delay;\r\nswitch (config->type) {\r\ncase REGULATOR_VOLTAGE:\r\ndrvdata->desc.type = REGULATOR_VOLTAGE;\r\ndrvdata->desc.ops = &gpio_regulator_voltage_ops;\r\ndrvdata->desc.n_voltages = config->nr_states;\r\nbreak;\r\ncase REGULATOR_CURRENT:\r\ndrvdata->desc.type = REGULATOR_CURRENT;\r\ndrvdata->desc.ops = &gpio_regulator_current_ops;\r\nbreak;\r\ndefault:\r\ndev_err(&pdev->dev, "No regulator type set\n");\r\nret = -EINVAL;\r\ngoto err_memgpio;\r\n}\r\nstate = 0;\r\nfor (ptr = 0; ptr < drvdata->nr_gpios; ptr++) {\r\nif (config->gpios[ptr].flags & GPIOF_OUT_INIT_HIGH)\r\nstate |= (1 << ptr);\r\n}\r\ndrvdata->state = state;\r\ncfg.dev = &pdev->dev;\r\ncfg.init_data = config->init_data;\r\ncfg.driver_data = drvdata;\r\ncfg.of_node = np;\r\nif (gpio_is_valid(config->enable_gpio)) {\r\ncfg.ena_gpio = config->enable_gpio;\r\ncfg.ena_gpio_initialized = true;\r\n}\r\ncfg.ena_gpio_invert = !config->enable_high;\r\nif (config->enabled_at_boot) {\r\nif (config->enable_high)\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_HIGH;\r\nelse\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_LOW;\r\n} else {\r\nif (config->enable_high)\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_LOW;\r\nelse\r\ncfg.ena_gpio_flags |= GPIOF_OUT_INIT_HIGH;\r\n}\r\ndrvdata->dev = regulator_register(&drvdata->desc, &cfg);\r\nif (IS_ERR(drvdata->dev)) {\r\nret = PTR_ERR(drvdata->dev);\r\ndev_err(&pdev->dev, "Failed to register regulator: %d\n", ret);\r\ngoto err_stategpio;\r\n}\r\nplatform_set_drvdata(pdev, drvdata);\r\nreturn 0;\r\nerr_stategpio:\r\ngpio_free_array(drvdata->gpios, drvdata->nr_gpios);\r\nerr_memstate:\r\nkfree(drvdata->states);\r\nerr_memgpio:\r\nkfree(drvdata->gpios);\r\nerr_name:\r\nkfree(drvdata->desc.name);\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int gpio_regulator_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_regulator_data *drvdata = platform_get_drvdata(pdev);\r\nregulator_unregister(drvdata->dev);\r\ngpio_free_array(drvdata->gpios, drvdata->nr_gpios);\r\nkfree(drvdata->states);\r\nkfree(drvdata->gpios);\r\nkfree(drvdata->desc.name);\r\nreturn 0;\r\n}\r\nstatic int __init gpio_regulator_init(void)\r\n{\r\nreturn platform_driver_register(&gpio_regulator_driver);\r\n}\r\nstatic void __exit gpio_regulator_exit(void)\r\n{\r\nplatform_driver_unregister(&gpio_regulator_driver);\r\n}
