static unsigned long pll_calc_rate(struct pll_rate_tbl *rtbl,\r\nunsigned long prate, int index, unsigned long *pll_rate)\r\n{\r\nunsigned long rate = prate;\r\nunsigned int mode;\r\nmode = rtbl[index].mode ? 256 : 1;\r\nrate = (((2 * rate / 10000) * rtbl[index].m) / (mode * rtbl[index].n));\r\nif (pll_rate)\r\n*pll_rate = (rate / (1 << rtbl[index].p)) * 10000;\r\nreturn rate * 10000;\r\n}\r\nstatic long clk_pll_round_rate_index(struct clk_hw *hw, unsigned long drate,\r\nunsigned long *prate, int *index)\r\n{\r\nstruct clk_pll *pll = to_clk_pll(hw);\r\nunsigned long prev_rate, vco_prev_rate, rate = 0;\r\nunsigned long vco_parent_rate =\r\nclk_hw_get_rate(clk_hw_get_parent(clk_hw_get_parent(hw)));\r\nif (!prate) {\r\npr_err("%s: prate is must for pll clk\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nfor (*index = 0; *index < pll->vco->rtbl_cnt; (*index)++) {\r\nprev_rate = rate;\r\nvco_prev_rate = *prate;\r\n*prate = pll_calc_rate(pll->vco->rtbl, vco_parent_rate, *index,\r\n&rate);\r\nif (drate < rate) {\r\nif (*index) {\r\nrate = prev_rate;\r\n*prate = vco_prev_rate;\r\n(*index)--;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn rate;\r\n}\r\nstatic long clk_pll_round_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long *prate)\r\n{\r\nint unused;\r\nreturn clk_pll_round_rate_index(hw, drate, prate, &unused);\r\n}\r\nstatic unsigned long clk_pll_recalc_rate(struct clk_hw *hw, unsigned long\r\nparent_rate)\r\n{\r\nstruct clk_pll *pll = to_clk_pll(hw);\r\nunsigned long flags = 0;\r\nunsigned int p;\r\nif (pll->vco->lock)\r\nspin_lock_irqsave(pll->vco->lock, flags);\r\np = readl_relaxed(pll->vco->cfg_reg);\r\nif (pll->vco->lock)\r\nspin_unlock_irqrestore(pll->vco->lock, flags);\r\np = (p >> PLL_DIV_P_SHIFT) & PLL_DIV_P_MASK;\r\nreturn parent_rate / (1 << p);\r\n}\r\nstatic int clk_pll_set_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate)\r\n{\r\nstruct clk_pll *pll = to_clk_pll(hw);\r\nstruct pll_rate_tbl *rtbl = pll->vco->rtbl;\r\nunsigned long flags = 0, val;\r\nint uninitialized_var(i);\r\nclk_pll_round_rate_index(hw, drate, NULL, &i);\r\nif (pll->vco->lock)\r\nspin_lock_irqsave(pll->vco->lock, flags);\r\nval = readl_relaxed(pll->vco->cfg_reg);\r\nval &= ~(PLL_DIV_P_MASK << PLL_DIV_P_SHIFT);\r\nval |= (rtbl[i].p & PLL_DIV_P_MASK) << PLL_DIV_P_SHIFT;\r\nwritel_relaxed(val, pll->vco->cfg_reg);\r\nif (pll->vco->lock)\r\nspin_unlock_irqrestore(pll->vco->lock, flags);\r\nreturn 0;\r\n}\r\nstatic inline unsigned long vco_calc_rate(struct clk_hw *hw,\r\nunsigned long prate, int index)\r\n{\r\nstruct clk_vco *vco = to_clk_vco(hw);\r\nreturn pll_calc_rate(vco->rtbl, prate, index, NULL);\r\n}\r\nstatic long clk_vco_round_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_vco *vco = to_clk_vco(hw);\r\nint unused;\r\nreturn clk_round_rate_index(hw, drate, *prate, vco_calc_rate,\r\nvco->rtbl_cnt, &unused);\r\n}\r\nstatic unsigned long clk_vco_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_vco *vco = to_clk_vco(hw);\r\nunsigned long flags = 0;\r\nunsigned int num = 2, den = 0, val, mode = 0;\r\nif (vco->lock)\r\nspin_lock_irqsave(vco->lock, flags);\r\nmode = (readl_relaxed(vco->mode_reg) >> PLL_MODE_SHIFT) & PLL_MODE_MASK;\r\nval = readl_relaxed(vco->cfg_reg);\r\nif (vco->lock)\r\nspin_unlock_irqrestore(vco->lock, flags);\r\nden = (val >> PLL_DIV_N_SHIFT) & PLL_DIV_N_MASK;\r\nif (!mode) {\r\nnum *= (val >> PLL_NORM_FDBK_M_SHIFT) & PLL_NORM_FDBK_M_MASK;\r\n} else {\r\nnum *= (val >> PLL_DITH_FDBK_M_SHIFT) & PLL_DITH_FDBK_M_MASK;\r\nden *= 256;\r\n}\r\nif (!den) {\r\nWARN(1, "%s: denominator can't be zero\n", __func__);\r\nreturn 0;\r\n}\r\nreturn (((parent_rate / 10000) * num) / den) * 10000;\r\n}\r\nstatic int clk_vco_set_rate(struct clk_hw *hw, unsigned long drate,\r\nunsigned long prate)\r\n{\r\nstruct clk_vco *vco = to_clk_vco(hw);\r\nstruct pll_rate_tbl *rtbl = vco->rtbl;\r\nunsigned long flags = 0, val;\r\nint i;\r\nclk_round_rate_index(hw, drate, prate, vco_calc_rate, vco->rtbl_cnt,\r\n&i);\r\nif (vco->lock)\r\nspin_lock_irqsave(vco->lock, flags);\r\nval = readl_relaxed(vco->mode_reg);\r\nval &= ~(PLL_MODE_MASK << PLL_MODE_SHIFT);\r\nval |= (rtbl[i].mode & PLL_MODE_MASK) << PLL_MODE_SHIFT;\r\nwritel_relaxed(val, vco->mode_reg);\r\nval = readl_relaxed(vco->cfg_reg);\r\nval &= ~(PLL_DIV_N_MASK << PLL_DIV_N_SHIFT);\r\nval |= (rtbl[i].n & PLL_DIV_N_MASK) << PLL_DIV_N_SHIFT;\r\nval &= ~(PLL_DITH_FDBK_M_MASK << PLL_DITH_FDBK_M_SHIFT);\r\nif (rtbl[i].mode)\r\nval |= (rtbl[i].m & PLL_DITH_FDBK_M_MASK) <<\r\nPLL_DITH_FDBK_M_SHIFT;\r\nelse\r\nval |= (rtbl[i].m & PLL_NORM_FDBK_M_MASK) <<\r\nPLL_NORM_FDBK_M_SHIFT;\r\nwritel_relaxed(val, vco->cfg_reg);\r\nif (vco->lock)\r\nspin_unlock_irqrestore(vco->lock, flags);\r\nreturn 0;\r\n}\r\nstruct clk *clk_register_vco_pll(const char *vco_name, const char *pll_name,\r\nconst char *vco_gate_name, const char *parent_name,\r\nunsigned long flags, void __iomem *mode_reg, void __iomem\r\n*cfg_reg, struct pll_rate_tbl *rtbl, u8 rtbl_cnt,\r\nspinlock_t *lock, struct clk **pll_clk,\r\nstruct clk **vco_gate_clk)\r\n{\r\nstruct clk_vco *vco;\r\nstruct clk_pll *pll;\r\nstruct clk *vco_clk, *tpll_clk, *tvco_gate_clk;\r\nstruct clk_init_data vco_init, pll_init;\r\nconst char **vco_parent_name;\r\nif (!vco_name || !pll_name || !parent_name || !mode_reg || !cfg_reg ||\r\n!rtbl || !rtbl_cnt) {\r\npr_err("Invalid arguments passed");\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nvco = kzalloc(sizeof(*vco), GFP_KERNEL);\r\nif (!vco) {\r\npr_err("could not allocate vco clk\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll) {\r\npr_err("could not allocate pll clk\n");\r\ngoto free_vco;\r\n}\r\nvco->mode_reg = mode_reg;\r\nvco->cfg_reg = cfg_reg;\r\nvco->rtbl = rtbl;\r\nvco->rtbl_cnt = rtbl_cnt;\r\nvco->lock = lock;\r\nvco->hw.init = &vco_init;\r\npll->vco = vco;\r\npll->hw.init = &pll_init;\r\nif (vco_gate_name) {\r\ntvco_gate_clk = clk_register_gate(NULL, vco_gate_name,\r\nparent_name, 0, mode_reg, PLL_ENABLE, 0, lock);\r\nif (IS_ERR_OR_NULL(tvco_gate_clk))\r\ngoto free_pll;\r\nif (vco_gate_clk)\r\n*vco_gate_clk = tvco_gate_clk;\r\nvco_parent_name = &vco_gate_name;\r\n} else {\r\nvco_parent_name = &parent_name;\r\n}\r\nvco_init.name = vco_name;\r\nvco_init.ops = &clk_vco_ops;\r\nvco_init.flags = flags;\r\nvco_init.parent_names = vco_parent_name;\r\nvco_init.num_parents = 1;\r\npll_init.name = pll_name;\r\npll_init.ops = &clk_pll_ops;\r\npll_init.flags = CLK_SET_RATE_PARENT;\r\npll_init.parent_names = &vco_name;\r\npll_init.num_parents = 1;\r\nvco_clk = clk_register(NULL, &vco->hw);\r\nif (IS_ERR_OR_NULL(vco_clk))\r\ngoto free_pll;\r\ntpll_clk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR_OR_NULL(tpll_clk))\r\ngoto free_pll;\r\nif (pll_clk)\r\n*pll_clk = tpll_clk;\r\nreturn vco_clk;\r\nfree_pll:\r\nkfree(pll);\r\nfree_vco:\r\nkfree(vco);\r\npr_err("Failed to register vco pll clock\n");\r\nreturn ERR_PTR(-ENOMEM);\r\n}
