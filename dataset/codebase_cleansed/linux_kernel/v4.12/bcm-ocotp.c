static inline void set_command(void __iomem *base, u32 command)\r\n{\r\nwritel(command & OTPC_CMD_MASK, base + OTPC_COMMAND_OFFSET);\r\n}\r\nstatic inline void set_cpu_address(void __iomem *base, u32 addr)\r\n{\r\nwritel(addr & OTPC_ADDR_MASK, base + OTPC_CPUADDR_REG_OFFSET);\r\n}\r\nstatic inline void set_start_bit(void __iomem *base)\r\n{\r\nwritel(1 << OTPC_CMD_START_START, base + OTPC_CMD_START_OFFSET);\r\n}\r\nstatic inline void reset_start_bit(void __iomem *base)\r\n{\r\nwritel(0, base + OTPC_CMD_START_OFFSET);\r\n}\r\nstatic inline void write_cpu_data(void __iomem *base, u32 value)\r\n{\r\nwritel(value, base + OTPC_CPU_WRITE_REG_OFFSET);\r\n}\r\nstatic int poll_cpu_status(void __iomem *base, u32 value)\r\n{\r\nu32 status;\r\nu32 retries;\r\nfor (retries = 0; retries < OTPC_RETRIES; retries++) {\r\nstatus = readl(base + OTPC_CPU_STATUS_OFFSET);\r\nif (status & value)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (retries == OTPC_RETRIES)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nstatic int enable_ocotp_program(void __iomem *base)\r\n{\r\nstatic const u32 vals[] = OTPC_PROG_EN_SEQ;\r\nint i;\r\nint ret;\r\nset_command(base, OTPC_CMD_OTP_PROG_ENABLE);\r\nfor (i = 0; i < ARRAY_SIZE(vals); i++) {\r\nwrite_cpu_data(base, vals[i]);\r\nset_start_bit(base);\r\nret = poll_cpu_status(base, OTPC_STAT_CMD_DONE);\r\nreset_start_bit(base);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn poll_cpu_status(base, OTPC_STAT_PROG_OK);\r\n}\r\nstatic int disable_ocotp_program(void __iomem *base)\r\n{\r\nint ret;\r\nset_command(base, OTPC_CMD_OTP_PROG_DISABLE);\r\nset_start_bit(base);\r\nret = poll_cpu_status(base, OTPC_STAT_PROG_OK);\r\nreset_start_bit(base);\r\nreturn ret;\r\n}\r\nstatic int bcm_otpc_read(void *context, unsigned int offset, void *val,\r\nsize_t bytes)\r\n{\r\nstruct otpc_priv *priv = context;\r\nu32 *buf = val;\r\nu32 bytes_read;\r\nu32 address = offset / priv->config->word_size;\r\nint i, ret;\r\nfor (bytes_read = 0; bytes_read < bytes;) {\r\nset_command(priv->base, OTPC_CMD_READ);\r\nset_cpu_address(priv->base, address++);\r\nset_start_bit(priv->base);\r\nret = poll_cpu_status(priv->base, OTPC_STAT_CMD_DONE);\r\nif (ret) {\r\ndev_err(priv->dev, "otp read error: 0x%x", ret);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < priv->map->otpc_row_size; i++) {\r\n*buf++ = readl(priv->base +\r\npriv->map->data_r_offset[i]);\r\nbytes_read += sizeof(*buf);\r\n}\r\nreset_start_bit(priv->base);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bcm_otpc_write(void *context, unsigned int offset, void *val,\r\nsize_t bytes)\r\n{\r\nstruct otpc_priv *priv = context;\r\nu32 *buf = val;\r\nu32 bytes_written;\r\nu32 address = offset / priv->config->word_size;\r\nint i, ret;\r\nif (offset % priv->config->word_size)\r\nreturn -EINVAL;\r\nret = enable_ocotp_program(priv->base);\r\nif (ret)\r\nreturn -EIO;\r\nfor (bytes_written = 0; bytes_written < bytes;) {\r\nset_command(priv->base, OTPC_CMD_PROGRAM);\r\nset_cpu_address(priv->base, address++);\r\nfor (i = 0; i < priv->map->otpc_row_size; i++) {\r\nwritel(*buf, priv->base + priv->map->data_r_offset[i]);\r\nbuf++;\r\nbytes_written += sizeof(*buf);\r\n}\r\nset_start_bit(priv->base);\r\nret = poll_cpu_status(priv->base, OTPC_STAT_CMD_DONE);\r\nreset_start_bit(priv->base);\r\nif (ret) {\r\ndev_err(priv->dev, "otp write error: 0x%x", ret);\r\nreturn -EIO;\r\n}\r\n}\r\ndisable_ocotp_program(priv->base);\r\nreturn 0;\r\n}\r\nstatic int bcm_otpc_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *dn = dev->of_node;\r\nstruct resource *res;\r\nstruct otpc_priv *priv;\r\nstruct nvmem_device *nvmem;\r\nint err;\r\nu32 num_words;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nif (of_device_is_compatible(dev->of_node, "brcm,ocotp"))\r\npriv->map = &otp_map;\r\nelse if (of_device_is_compatible(dev->of_node, "brcm,ocotp-v2"))\r\npriv->map = &otp_map_v2;\r\nelse {\r\ndev_err(&pdev->dev,\r\n"%s otpc config map not defined\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->base)) {\r\ndev_err(dev, "unable to map I/O memory\n");\r\nreturn PTR_ERR(priv->base);\r\n}\r\nwritel(readl(priv->base + OTPC_MODE_REG_OFFSET) |\r\nBIT(OTPC_MODE_REG_OTPC_MODE),\r\npriv->base + OTPC_MODE_REG_OFFSET);\r\nreset_start_bit(priv->base);\r\nerr = of_property_read_u32(dn, "brcm,ocotp-size", &num_words);\r\nif (err) {\r\ndev_err(dev, "size parameter not specified\n");\r\nreturn -EINVAL;\r\n} else if (num_words == 0) {\r\ndev_err(dev, "size must be > 0\n");\r\nreturn -EINVAL;\r\n}\r\nbcm_otpc_nvmem_config.size = 4 * num_words;\r\nbcm_otpc_nvmem_config.dev = dev;\r\nbcm_otpc_nvmem_config.priv = priv;\r\nif (of_device_is_compatible(dev->of_node, "brcm,ocotp-v2")) {\r\nbcm_otpc_nvmem_config.word_size = 8;\r\nbcm_otpc_nvmem_config.stride = 8;\r\n}\r\npriv->config = &bcm_otpc_nvmem_config;\r\nnvmem = nvmem_register(&bcm_otpc_nvmem_config);\r\nif (IS_ERR(nvmem)) {\r\ndev_err(dev, "error registering nvmem config\n");\r\nreturn PTR_ERR(nvmem);\r\n}\r\nplatform_set_drvdata(pdev, nvmem);\r\nreturn 0;\r\n}\r\nstatic int bcm_otpc_remove(struct platform_device *pdev)\r\n{\r\nstruct nvmem_device *nvmem = platform_get_drvdata(pdev);\r\nreturn nvmem_unregister(nvmem);\r\n}
