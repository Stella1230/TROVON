static void block_range__debug(void)\r\n{\r\n#if 1\r\nstruct rb_node *rb;\r\nu64 old = 0;\r\nfor (rb = rb_first(&block_ranges.root); rb; rb = rb_next(rb)) {\r\nstruct block_range *entry = rb_entry(rb, struct block_range, node);\r\nassert(old < entry->start);\r\nassert(entry->start <= entry->end);\r\nold = entry->end;\r\n}\r\n#endif\r\n}\r\nstruct block_range *block_range__find(u64 addr)\r\n{\r\nstruct rb_node **p = &block_ranges.root.rb_node;\r\nstruct rb_node *parent = NULL;\r\nstruct block_range *entry;\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nentry = rb_entry(parent, struct block_range, node);\r\nif (addr < entry->start)\r\np = &parent->rb_left;\r\nelse if (addr > entry->end)\r\np = &parent->rb_right;\r\nelse\r\nreturn entry;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void rb_link_left_of_node(struct rb_node *left, struct rb_node *node)\r\n{\r\nstruct rb_node **p = &node->rb_left;\r\nwhile (*p) {\r\nnode = *p;\r\np = &node->rb_right;\r\n}\r\nrb_link_node(left, node, p);\r\n}\r\nstatic inline void rb_link_right_of_node(struct rb_node *right, struct rb_node *node)\r\n{\r\nstruct rb_node **p = &node->rb_right;\r\nwhile (*p) {\r\nnode = *p;\r\np = &node->rb_left;\r\n}\r\nrb_link_node(right, node, p);\r\n}\r\nstruct block_range_iter block_range__create(u64 start, u64 end)\r\n{\r\nstruct rb_node **p = &block_ranges.root.rb_node;\r\nstruct rb_node *n, *parent = NULL;\r\nstruct block_range *next, *entry = NULL;\r\nstruct block_range_iter iter = { NULL, NULL };\r\nwhile (*p != NULL) {\r\nparent = *p;\r\nentry = rb_entry(parent, struct block_range, node);\r\nif (start < entry->start)\r\np = &parent->rb_left;\r\nelse if (start > entry->end)\r\np = &parent->rb_right;\r\nelse\r\nbreak;\r\n}\r\nif (!*p) {\r\nif (!entry)\r\ngoto do_whole;\r\nn = parent;\r\nif (entry->end < start) {\r\nn = rb_next(n);\r\nif (!n)\r\ngoto do_whole;\r\n}\r\nnext = rb_entry(n, struct block_range, node);\r\nif (next->start <= end) {\r\nstruct block_range *head = malloc(sizeof(struct block_range));\r\nif (!head)\r\nreturn iter;\r\n*head = (struct block_range){\r\n.start = start,\r\n.end = next->start - 1,\r\n.is_target = 1,\r\n.is_branch = 0,\r\n};\r\nrb_link_left_of_node(&head->node, &next->node);\r\nrb_insert_color(&head->node, &block_ranges.root);\r\nblock_range__debug();\r\niter.start = head;\r\ngoto do_tail;\r\n}\r\ndo_whole:\r\nentry = malloc(sizeof(struct block_range));\r\nif (!entry)\r\nreturn iter;\r\n*entry = (struct block_range){\r\n.start = start,\r\n.end = end,\r\n.is_target = 1,\r\n.is_branch = 1,\r\n};\r\nrb_link_node(&entry->node, parent, p);\r\nrb_insert_color(&entry->node, &block_ranges.root);\r\nblock_range__debug();\r\niter.start = entry;\r\niter.end = entry;\r\ngoto done;\r\n}\r\nif (entry->start < start) {\r\nstruct block_range *head = malloc(sizeof(struct block_range));\r\nif (!head)\r\nreturn iter;\r\n*head = (struct block_range){\r\n.start = entry->start,\r\n.end = start - 1,\r\n.is_target = entry->is_target,\r\n.is_branch = 0,\r\n.coverage = entry->coverage,\r\n.entry = entry->entry,\r\n};\r\nentry->start = start;\r\nentry->is_target = 1;\r\nentry->entry = 0;\r\nrb_link_left_of_node(&head->node, &entry->node);\r\nrb_insert_color(&head->node, &block_ranges.root);\r\nblock_range__debug();\r\n} else if (entry->start == start)\r\nentry->is_target = 1;\r\niter.start = entry;\r\ndo_tail:\r\nentry = iter.start;\r\nfor (;;) {\r\nif (end < entry->end) {\r\nstruct block_range *tail = malloc(sizeof(struct block_range));\r\nif (!tail)\r\nreturn iter;\r\n*tail = (struct block_range){\r\n.start = end + 1,\r\n.end = entry->end,\r\n.is_target = 0,\r\n.is_branch = entry->is_branch,\r\n.coverage = entry->coverage,\r\n.taken = entry->taken,\r\n.pred = entry->pred,\r\n};\r\nentry->end = end;\r\nentry->is_branch = 1;\r\nentry->taken = 0;\r\nentry->pred = 0;\r\nrb_link_right_of_node(&tail->node, &entry->node);\r\nrb_insert_color(&tail->node, &block_ranges.root);\r\nblock_range__debug();\r\niter.end = entry;\r\ngoto done;\r\n}\r\nif (end == entry->end) {\r\nentry->is_branch = 1;\r\niter.end = entry;\r\ngoto done;\r\n}\r\nnext = block_range__next(entry);\r\nif (!next)\r\ngoto add_tail;\r\nif (end < next->start) {\r\nstruct block_range *tail;\r\nadd_tail:\r\ntail = malloc(sizeof(struct block_range));\r\nif (!tail)\r\nreturn iter;\r\n*tail = (struct block_range){\r\n.start = entry->end + 1,\r\n.end = end,\r\n.is_target = 0,\r\n.is_branch = 1,\r\n};\r\nrb_link_right_of_node(&tail->node, &entry->node);\r\nrb_insert_color(&tail->node, &block_ranges.root);\r\nblock_range__debug();\r\niter.end = tail;\r\ngoto done;\r\n}\r\nif (entry->end + 1 != next->start) {\r\nstruct block_range *hole = malloc(sizeof(struct block_range));\r\nif (!hole)\r\nreturn iter;\r\n*hole = (struct block_range){\r\n.start = entry->end + 1,\r\n.end = next->start - 1,\r\n.is_target = 0,\r\n.is_branch = 0,\r\n};\r\nrb_link_left_of_node(&hole->node, &next->node);\r\nrb_insert_color(&hole->node, &block_ranges.root);\r\nblock_range__debug();\r\n}\r\nentry = next;\r\n}\r\ndone:\r\nassert(iter.start->start == start && iter.start->is_target);\r\nassert(iter.end->end == end && iter.end->is_branch);\r\nblock_ranges.blocks++;\r\nreturn iter;\r\n}\r\ndouble block_range__coverage(struct block_range *br)\r\n{\r\nstruct symbol *sym;\r\nif (!br) {\r\nif (block_ranges.blocks)\r\nreturn 0;\r\nreturn -1;\r\n}\r\nsym = br->sym;\r\nif (!sym)\r\nreturn -1;\r\nreturn (double)br->coverage / symbol__annotation(sym)->max_coverage;\r\n}
