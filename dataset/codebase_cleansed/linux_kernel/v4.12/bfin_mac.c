static void desc_list_free(void)\r\n{\r\nstruct net_dma_desc_rx *r;\r\nstruct net_dma_desc_tx *t;\r\nint i;\r\n#if !defined(CONFIG_BFIN_MAC_USE_L1)\r\ndma_addr_t dma_handle = 0;\r\n#endif\r\nif (tx_desc) {\r\nt = tx_list_head;\r\nfor (i = 0; i < CONFIG_BFIN_TX_DESC_NUM; i++) {\r\nif (t) {\r\nif (t->skb) {\r\ndev_kfree_skb(t->skb);\r\nt->skb = NULL;\r\n}\r\nt = t->next;\r\n}\r\n}\r\nbfin_mac_free(dma_handle, tx_desc, CONFIG_BFIN_TX_DESC_NUM);\r\n}\r\nif (rx_desc) {\r\nr = rx_list_head;\r\nfor (i = 0; i < CONFIG_BFIN_RX_DESC_NUM; i++) {\r\nif (r) {\r\nif (r->skb) {\r\ndev_kfree_skb(r->skb);\r\nr->skb = NULL;\r\n}\r\nr = r->next;\r\n}\r\n}\r\nbfin_mac_free(dma_handle, rx_desc, CONFIG_BFIN_RX_DESC_NUM);\r\n}\r\n}\r\nstatic int desc_list_init(struct net_device *dev)\r\n{\r\nint i;\r\nstruct sk_buff *new_skb;\r\n#if !defined(CONFIG_BFIN_MAC_USE_L1)\r\ndma_addr_t dma_handle;\r\n#endif\r\ntx_desc = bfin_mac_alloc(&dma_handle,\r\nsizeof(struct net_dma_desc_tx),\r\nCONFIG_BFIN_TX_DESC_NUM);\r\nif (tx_desc == NULL)\r\ngoto init_error;\r\nrx_desc = bfin_mac_alloc(&dma_handle,\r\nsizeof(struct net_dma_desc_rx),\r\nCONFIG_BFIN_RX_DESC_NUM);\r\nif (rx_desc == NULL)\r\ngoto init_error;\r\ntx_list_head = tx_list_tail = tx_desc;\r\nfor (i = 0; i < CONFIG_BFIN_TX_DESC_NUM; i++) {\r\nstruct net_dma_desc_tx *t = tx_desc + i;\r\nstruct dma_descriptor *a = &(t->desc_a);\r\nstruct dma_descriptor *b = &(t->desc_b);\r\na->config = WDSIZE_32 | NDSIZE_6 | DMAFLOW_LARGE;\r\na->start_addr = (unsigned long)t->packet;\r\na->x_count = 0;\r\na->next_dma_desc = b;\r\nb->config = DMAEN | WNR | WDSIZE_32 | NDSIZE_6 | DMAFLOW_LARGE;\r\nb->start_addr = (unsigned long)(&(t->status));\r\nb->x_count = 0;\r\nt->skb = NULL;\r\ntx_list_tail->desc_b.next_dma_desc = a;\r\ntx_list_tail->next = t;\r\ntx_list_tail = t;\r\n}\r\ntx_list_tail->next = tx_list_head;\r\ntx_list_tail->desc_b.next_dma_desc = &(tx_list_head->desc_a);\r\ncurrent_tx_ptr = tx_list_head;\r\nrx_list_head = rx_list_tail = rx_desc;\r\nfor (i = 0; i < CONFIG_BFIN_RX_DESC_NUM; i++) {\r\nstruct net_dma_desc_rx *r = rx_desc + i;\r\nstruct dma_descriptor *a = &(r->desc_a);\r\nstruct dma_descriptor *b = &(r->desc_b);\r\nnew_skb = netdev_alloc_skb(dev, PKT_BUF_SZ + NET_IP_ALIGN);\r\nif (!new_skb)\r\ngoto init_error;\r\nskb_reserve(new_skb, NET_IP_ALIGN);\r\nblackfin_dcache_invalidate_range((unsigned long)new_skb->head,\r\n(unsigned long)new_skb->end);\r\nr->skb = new_skb;\r\na->config = DMAEN | WNR | WDSIZE_32 | NDSIZE_6 | DMAFLOW_LARGE;\r\na->start_addr = (unsigned long)new_skb->data - 2;\r\na->x_count = 0;\r\na->next_dma_desc = b;\r\nb->config = DMAEN | WNR | WDSIZE_32 | DI_EN |\r\nNDSIZE_6 | DMAFLOW_LARGE;\r\nb->start_addr = (unsigned long)(&(r->status));\r\nb->x_count = 0;\r\nrx_list_tail->desc_b.next_dma_desc = a;\r\nrx_list_tail->next = r;\r\nrx_list_tail = r;\r\n}\r\nrx_list_tail->next = rx_list_head;\r\nrx_list_tail->desc_b.next_dma_desc = &(rx_list_head->desc_a);\r\ncurrent_rx_ptr = rx_list_head;\r\nreturn 0;\r\ninit_error:\r\ndesc_list_free();\r\npr_err("kmalloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nstatic int bfin_mdio_poll(void)\r\n{\r\nint timeout_cnt = MAX_TIMEOUT_CNT;\r\nwhile ((bfin_read_EMAC_STAADD()) & STABUSY) {\r\nudelay(1);\r\nif (timeout_cnt-- < 0) {\r\npr_err("wait MDC/MDIO transaction to complete timeout\n");\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_mdiobus_read(struct mii_bus *bus, int phy_addr, int regnum)\r\n{\r\nint ret;\r\nret = bfin_mdio_poll();\r\nif (ret)\r\nreturn ret;\r\nbfin_write_EMAC_STAADD(SET_PHYAD((u16) phy_addr) |\r\nSET_REGAD((u16) regnum) |\r\nSTABUSY);\r\nret = bfin_mdio_poll();\r\nif (ret)\r\nreturn ret;\r\nreturn (int) bfin_read_EMAC_STADAT();\r\n}\r\nstatic int bfin_mdiobus_write(struct mii_bus *bus, int phy_addr, int regnum,\r\nu16 value)\r\n{\r\nint ret;\r\nret = bfin_mdio_poll();\r\nif (ret)\r\nreturn ret;\r\nbfin_write_EMAC_STADAT((u32) value);\r\nbfin_write_EMAC_STAADD(SET_PHYAD((u16) phy_addr) |\r\nSET_REGAD((u16) regnum) |\r\nSTAOP |\r\nSTABUSY);\r\nreturn bfin_mdio_poll();\r\n}\r\nstatic void bfin_mac_adjust_link(struct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nstruct phy_device *phydev = dev->phydev;\r\nunsigned long flags;\r\nint new_state = 0;\r\nspin_lock_irqsave(&lp->lock, flags);\r\nif (phydev->link) {\r\nif (phydev->duplex != lp->old_duplex) {\r\nu32 opmode = bfin_read_EMAC_OPMODE();\r\nnew_state = 1;\r\nif (phydev->duplex)\r\nopmode |= FDMODE;\r\nelse\r\nopmode &= ~(FDMODE);\r\nbfin_write_EMAC_OPMODE(opmode);\r\nlp->old_duplex = phydev->duplex;\r\n}\r\nif (phydev->speed != lp->old_speed) {\r\nif (phydev->interface == PHY_INTERFACE_MODE_RMII) {\r\nu32 opmode = bfin_read_EMAC_OPMODE();\r\nswitch (phydev->speed) {\r\ncase 10:\r\nopmode |= RMII_10;\r\nbreak;\r\ncase 100:\r\nopmode &= ~RMII_10;\r\nbreak;\r\ndefault:\r\nnetdev_warn(dev,\r\n"Ack! Speed (%d) is not 10/100!\n",\r\nphydev->speed);\r\nbreak;\r\n}\r\nbfin_write_EMAC_OPMODE(opmode);\r\n}\r\nnew_state = 1;\r\nlp->old_speed = phydev->speed;\r\n}\r\nif (!lp->old_link) {\r\nnew_state = 1;\r\nlp->old_link = 1;\r\n}\r\n} else if (lp->old_link) {\r\nnew_state = 1;\r\nlp->old_link = 0;\r\nlp->old_speed = 0;\r\nlp->old_duplex = -1;\r\n}\r\nif (new_state) {\r\nu32 opmode = bfin_read_EMAC_OPMODE();\r\nphy_print_status(phydev);\r\npr_debug("EMAC_OPMODE = 0x%08x\n", opmode);\r\n}\r\nspin_unlock_irqrestore(&lp->lock, flags);\r\n}\r\nstatic int mii_probe(struct net_device *dev, int phy_mode)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nstruct phy_device *phydev;\r\nunsigned short sysctl;\r\nu32 sclk, mdc_div;\r\nif (!(bfin_read_VR_CTL() & CLKBUFOE))\r\nbfin_write_VR_CTL(bfin_read_VR_CTL() | CLKBUFOE);\r\nsclk = get_sclk();\r\nmdc_div = ((sclk / MDC_CLK) / 2) - 1;\r\nsysctl = bfin_read_EMAC_SYSCTL();\r\nsysctl = (sysctl & ~MDCDIV) | SET_MDCDIV(mdc_div);\r\nbfin_write_EMAC_SYSCTL(sysctl);\r\nphydev = phy_find_first(lp->mii_bus);\r\nif (!phydev) {\r\nnetdev_err(dev, "no phy device found\n");\r\nreturn -ENODEV;\r\n}\r\nif (phy_mode != PHY_INTERFACE_MODE_RMII &&\r\nphy_mode != PHY_INTERFACE_MODE_MII) {\r\nnetdev_err(dev, "invalid phy interface mode\n");\r\nreturn -EINVAL;\r\n}\r\nphydev = phy_connect(dev, phydev_name(phydev),\r\n&bfin_mac_adjust_link, phy_mode);\r\nif (IS_ERR(phydev)) {\r\nnetdev_err(dev, "could not attach PHY\n");\r\nreturn PTR_ERR(phydev);\r\n}\r\nphydev->supported &= (SUPPORTED_10baseT_Half\r\n| SUPPORTED_10baseT_Full\r\n| SUPPORTED_100baseT_Half\r\n| SUPPORTED_100baseT_Full\r\n| SUPPORTED_Autoneg\r\n| SUPPORTED_Pause | SUPPORTED_Asym_Pause\r\n| SUPPORTED_MII\r\n| SUPPORTED_TP);\r\nphydev->advertising = phydev->supported;\r\nlp->old_link = 0;\r\nlp->old_speed = 0;\r\nlp->old_duplex = -1;\r\nphy_attached_print(phydev, "mdc_clk=%dHz(mdc_div=%d)@sclk=%dMHz)\n",\r\nMDC_CLK, mdc_div, sclk / 1000000);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t bfin_mac_wake_interrupt(int irq, void *dev_id)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bfin_mac_ethtool_getdrvinfo(struct net_device *dev,\r\nstruct ethtool_drvinfo *info)\r\n{\r\nstrlcpy(info->driver, KBUILD_MODNAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_VERSION, sizeof(info->version));\r\nstrlcpy(info->fw_version, "N/A", sizeof(info->fw_version));\r\nstrlcpy(info->bus_info, dev_name(&dev->dev), sizeof(info->bus_info));\r\n}\r\nstatic void bfin_mac_ethtool_getwol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nwolinfo->supported = WAKE_MAGIC;\r\nwolinfo->wolopts = lp->wol;\r\n}\r\nstatic int bfin_mac_ethtool_setwol(struct net_device *dev,\r\nstruct ethtool_wolinfo *wolinfo)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nint rc;\r\nif (wolinfo->wolopts & (WAKE_MAGICSECURE |\r\nWAKE_UCAST |\r\nWAKE_MCAST |\r\nWAKE_BCAST |\r\nWAKE_ARP))\r\nreturn -EOPNOTSUPP;\r\nlp->wol = wolinfo->wolopts;\r\nif (lp->wol && !lp->irq_wake_requested) {\r\nrc = request_irq(IRQ_MAC_WAKEDET, bfin_mac_wake_interrupt,\r\n0, "EMAC_WAKE", dev);\r\nif (rc)\r\nreturn rc;\r\nlp->irq_wake_requested = true;\r\n}\r\nif (!lp->wol && lp->irq_wake_requested) {\r\nfree_irq(IRQ_MAC_WAKEDET, dev);\r\nlp->irq_wake_requested = false;\r\n}\r\ndevice_init_wakeup(&dev->dev, lp->wol);\r\nreturn 0;\r\n}\r\nstatic int bfin_mac_ethtool_get_ts_info(struct net_device *dev,\r\nstruct ethtool_ts_info *info)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\ninfo->so_timestamping =\r\nSOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE;\r\ninfo->phc_index = lp->phc_index;\r\ninfo->tx_types =\r\n(1 << HWTSTAMP_TX_OFF) |\r\n(1 << HWTSTAMP_TX_ON);\r\ninfo->rx_filters =\r\n(1 << HWTSTAMP_FILTER_NONE) |\r\n(1 << HWTSTAMP_FILTER_PTP_V1_L4_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L2_EVENT) |\r\n(1 << HWTSTAMP_FILTER_PTP_V2_L4_EVENT);\r\nreturn 0;\r\n}\r\nstatic void setup_system_regs(struct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nint i;\r\nunsigned short sysctl;\r\nsysctl = bfin_read_EMAC_SYSCTL();\r\nfor (i = 0; i < PHY_MAX_ADDR; ++i)\r\nif (lp->mii_bus->irq[i] != PHY_POLL)\r\nbreak;\r\nif (i < PHY_MAX_ADDR)\r\nsysctl |= PHYIE;\r\nsysctl |= RXDWA;\r\n#if defined(BFIN_MAC_CSUM_OFFLOAD)\r\nsysctl |= RXCKS;\r\n#else\r\nsysctl &= ~RXCKS;\r\n#endif\r\nbfin_write_EMAC_SYSCTL(sysctl);\r\nbfin_write_EMAC_MMC_CTL(RSTC | CROLL);\r\nbfin_write_EMAC_VLAN1(lp->vlan1_mask);\r\nbfin_write_EMAC_VLAN2(lp->vlan2_mask);\r\nbfin_write_DMA2_X_COUNT(0);\r\nbfin_write_DMA2_X_MODIFY(4);\r\nbfin_write_DMA2_Y_COUNT(0);\r\nbfin_write_DMA2_Y_MODIFY(0);\r\nbfin_write_DMA1_X_COUNT(0);\r\nbfin_write_DMA1_X_MODIFY(4);\r\nbfin_write_DMA1_Y_COUNT(0);\r\nbfin_write_DMA1_Y_MODIFY(0);\r\n}\r\nstatic void setup_mac_addr(u8 *mac_addr)\r\n{\r\nu32 addr_low = le32_to_cpu(*(__le32 *) & mac_addr[0]);\r\nu16 addr_hi = le16_to_cpu(*(__le16 *) & mac_addr[4]);\r\nbfin_write_EMAC_ADDRLO(addr_low);\r\nbfin_write_EMAC_ADDRHI(addr_hi);\r\n}\r\nstatic int bfin_mac_set_mac_address(struct net_device *dev, void *p)\r\n{\r\nstruct sockaddr *addr = p;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nsetup_mac_addr(dev->dev_addr);\r\nreturn 0;\r\n}\r\nstatic u32 bfin_select_phc_clock(u32 input_clk, unsigned int *shift_result)\r\n{\r\nu32 ipn = 1000000000UL / input_clk;\r\nu32 ppn = 1;\r\nunsigned int shift = 0;\r\nwhile (ppn <= ipn) {\r\nppn <<= 1;\r\nshift++;\r\n}\r\n*shift_result = shift;\r\nreturn 1000000000UL / ppn;\r\n}\r\nstatic int bfin_mac_hwtstamp_set(struct net_device *netdev,\r\nstruct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nstruct bfin_mac_local *lp = netdev_priv(netdev);\r\nu16 ptpctl;\r\nu32 ptpfv1, ptpfv2, ptpfv3, ptpfoff;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\npr_debug("%s config flag:0x%x, tx_type:0x%x, rx_filter:0x%x\n",\r\n__func__, config.flags, config.tx_type, config.rx_filter);\r\nif (config.flags)\r\nreturn -EINVAL;\r\nif ((config.tx_type != HWTSTAMP_TX_OFF) &&\r\n(config.tx_type != HWTSTAMP_TX_ON))\r\nreturn -ERANGE;\r\nptpctl = bfin_read_EMAC_PTP_CTL();\r\nswitch (config.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nptpfv3 = 0xFFFFFFFF;\r\nbfin_write_EMAC_PTP_FV3(ptpfv3);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\nptpctl &= ~0x1F00;\r\nbfin_write_EMAC_PTP_CTL(ptpctl);\r\nptpfoff = 0x4A24170C;\r\nbfin_write_EMAC_PTP_FOFF(ptpfoff);\r\nptpfv1 = 0x11040800;\r\nbfin_write_EMAC_PTP_FV1(ptpfv1);\r\nptpfv2 = 0x0140013F;\r\nbfin_write_EMAC_PTP_FV2(ptpfv2);\r\nptpfv3 = 0xFFFFFFFC;\r\nbfin_write_EMAC_PTP_FV3(ptpfv3);\r\nconfig.rx_filter = HWTSTAMP_FILTER_PTP_V1_L4_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_DELAY_REQ:\r\nptpctl &= ~0x1F00;\r\nbfin_write_EMAC_PTP_CTL(ptpctl);\r\nptpfoff = 0x2A24170C;\r\nbfin_write_EMAC_PTP_FOFF(ptpfoff);\r\nptpfv1 = 0x11040800;\r\nbfin_write_EMAC_PTP_FV1(ptpfv1);\r\nptpfv2 = 0x0140013F;\r\nbfin_write_EMAC_PTP_FV2(ptpfv2);\r\nptpfv3 = 0xFFFFFFF0;\r\nbfin_write_EMAC_PTP_FV3(ptpfv3);\r\nconfig.rx_filter = HWTSTAMP_FILTER_PTP_V2_L4_EVENT;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_SYNC:\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ:\r\nptpctl &= ~0x1100;\r\nbfin_write_EMAC_PTP_CTL(ptpctl);\r\nptpfoff = 0x0E24170C;\r\nbfin_write_EMAC_PTP_FOFF(ptpfoff);\r\nptpfv1 = 0x110488F7;\r\nbfin_write_EMAC_PTP_FV1(ptpfv1);\r\nptpfv2 = 0x0140013F;\r\nbfin_write_EMAC_PTP_FV2(ptpfv2);\r\nptpfv3 = 0xFFFFFFF0;\r\nbfin_write_EMAC_PTP_FV3(ptpfv3);\r\nconfig.rx_filter = HWTSTAMP_FILTER_PTP_V2_L2_EVENT;\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nif (config.tx_type == HWTSTAMP_TX_OFF &&\r\nbfin_mac_hwtstamp_is_none(config.rx_filter)) {\r\nptpctl &= ~PTP_EN;\r\nbfin_write_EMAC_PTP_CTL(ptpctl);\r\nSSYNC();\r\n} else {\r\nptpctl |= PTP_EN;\r\nbfin_write_EMAC_PTP_CTL(ptpctl);\r\nbfin_read_EMAC_PTP_RXSNAPLO();\r\nbfin_read_EMAC_PTP_RXSNAPHI();\r\nbfin_read_EMAC_PTP_TXSNAPLO();\r\nbfin_read_EMAC_PTP_TXSNAPHI();\r\nSSYNC();\r\n}\r\nlp->stamp_cfg = config;\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic int bfin_mac_hwtstamp_get(struct net_device *netdev,\r\nstruct ifreq *ifr)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(netdev);\r\nreturn copy_to_user(ifr->ifr_data, &lp->stamp_cfg,\r\nsizeof(lp->stamp_cfg)) ?\r\n-EFAULT : 0;\r\n}\r\nstatic void bfin_tx_hwtstamp(struct net_device *netdev, struct sk_buff *skb)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(netdev);\r\nif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {\r\nint timeout_cnt = MAX_TIMEOUT_CNT;\r\nskb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;\r\nwhile ((!(bfin_read_EMAC_PTP_ISTAT() & TXTL)) && (--timeout_cnt))\r\nudelay(1);\r\nif (timeout_cnt == 0)\r\nnetdev_err(netdev, "timestamp the TX packet failed\n");\r\nelse {\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nu64 ns;\r\nu64 regval;\r\nregval = bfin_read_EMAC_PTP_TXSNAPLO();\r\nregval |= (u64)bfin_read_EMAC_PTP_TXSNAPHI() << 32;\r\nmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\r\nns = regval << lp->shift;\r\nshhwtstamps.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(skb, &shhwtstamps);\r\n}\r\n}\r\n}\r\nstatic void bfin_rx_hwtstamp(struct net_device *netdev, struct sk_buff *skb)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(netdev);\r\nu32 valid;\r\nu64 regval, ns;\r\nstruct skb_shared_hwtstamps *shhwtstamps;\r\nif (bfin_mac_hwtstamp_is_none(lp->stamp_cfg.rx_filter))\r\nreturn;\r\nvalid = bfin_read_EMAC_PTP_ISTAT() & RXEL;\r\nif (!valid)\r\nreturn;\r\nshhwtstamps = skb_hwtstamps(skb);\r\nregval = bfin_read_EMAC_PTP_RXSNAPLO();\r\nregval |= (u64)bfin_read_EMAC_PTP_RXSNAPHI() << 32;\r\nns = regval << lp->shift;\r\nmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\r\nshhwtstamps->hwtstamp = ns_to_ktime(ns);\r\n}\r\nstatic void bfin_mac_hwtstamp_init(struct net_device *netdev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(netdev);\r\nu64 addend, ppb;\r\nu32 input_clk, phc_clk;\r\ninput_clk = get_sclk();\r\nphc_clk = bfin_select_phc_clock(input_clk, &lp->shift);\r\naddend = phc_clk * (1ULL << 32);\r\ndo_div(addend, input_clk);\r\nbfin_write_EMAC_PTP_ADDEND((u32)addend);\r\nlp->addend = addend;\r\nppb = 1000000000ULL * input_clk;\r\ndo_div(ppb, phc_clk);\r\nlp->max_ppb = ppb - 1000000000ULL - 1ULL;\r\nlp->stamp_cfg.rx_filter = HWTSTAMP_FILTER_NONE;\r\nlp->stamp_cfg.tx_type = HWTSTAMP_TX_OFF;\r\n}\r\nstatic u64 bfin_ptp_time_read(struct bfin_mac_local *lp)\r\n{\r\nu64 ns;\r\nu32 lo, hi;\r\nlo = bfin_read_EMAC_PTP_TIMELO();\r\nhi = bfin_read_EMAC_PTP_TIMEHI();\r\nns = ((u64) hi) << 32;\r\nns |= lo;\r\nns <<= lp->shift;\r\nreturn ns;\r\n}\r\nstatic void bfin_ptp_time_write(struct bfin_mac_local *lp, u64 ns)\r\n{\r\nu32 hi, lo;\r\nns >>= lp->shift;\r\nhi = ns >> 32;\r\nlo = ns & 0xffffffff;\r\nbfin_write_EMAC_PTP_TIMELO(lo);\r\nbfin_write_EMAC_PTP_TIMEHI(hi);\r\n}\r\nstatic int bfin_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nu64 adj;\r\nu32 diff, addend;\r\nint neg_adj = 0;\r\nstruct bfin_mac_local *lp =\r\ncontainer_of(ptp, struct bfin_mac_local, caps);\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\naddend = lp->addend;\r\nadj = addend;\r\nadj *= ppb;\r\ndiff = div_u64(adj, 1000000000ULL);\r\naddend = neg_adj ? addend - diff : addend + diff;\r\nbfin_write_EMAC_PTP_ADDEND(addend);\r\nreturn 0;\r\n}\r\nstatic int bfin_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\ns64 now;\r\nunsigned long flags;\r\nstruct bfin_mac_local *lp =\r\ncontainer_of(ptp, struct bfin_mac_local, caps);\r\nspin_lock_irqsave(&lp->phc_lock, flags);\r\nnow = bfin_ptp_time_read(lp);\r\nnow += delta;\r\nbfin_ptp_time_write(lp, now);\r\nspin_unlock_irqrestore(&lp->phc_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bfin_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct bfin_mac_local *lp =\r\ncontainer_of(ptp, struct bfin_mac_local, caps);\r\nspin_lock_irqsave(&lp->phc_lock, flags);\r\nns = bfin_ptp_time_read(lp);\r\nspin_unlock_irqrestore(&lp->phc_lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int bfin_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct bfin_mac_local *lp =\r\ncontainer_of(ptp, struct bfin_mac_local, caps);\r\nns = timespec64_to_ns(ts);\r\nspin_lock_irqsave(&lp->phc_lock, flags);\r\nbfin_ptp_time_write(lp, ns);\r\nspin_unlock_irqrestore(&lp->phc_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int bfin_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int bfin_phc_init(struct net_device *netdev, struct device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(netdev);\r\nlp->caps = bfin_ptp_caps;\r\nlp->caps.max_adj = lp->max_ppb;\r\nlp->clock = ptp_clock_register(&lp->caps, dev);\r\nif (IS_ERR(lp->clock))\r\nreturn PTR_ERR(lp->clock);\r\nlp->phc_index = ptp_clock_index(lp->clock);\r\nspin_lock_init(&lp->phc_lock);\r\nreturn 0;\r\n}\r\nstatic void bfin_phc_release(struct bfin_mac_local *lp)\r\n{\r\nptp_clock_unregister(lp->clock);\r\n}\r\nstatic inline void _tx_reclaim_skb(void)\r\n{\r\ndo {\r\ntx_list_head->desc_a.config &= ~DMAEN;\r\ntx_list_head->status.status_word = 0;\r\nif (tx_list_head->skb) {\r\ndev_consume_skb_any(tx_list_head->skb);\r\ntx_list_head->skb = NULL;\r\n}\r\ntx_list_head = tx_list_head->next;\r\n} while (tx_list_head->status.status_word != 0);\r\n}\r\nstatic void tx_reclaim_skb(struct bfin_mac_local *lp)\r\n{\r\nint timeout_cnt = MAX_TIMEOUT_CNT;\r\nif (tx_list_head->status.status_word != 0)\r\n_tx_reclaim_skb();\r\nif (current_tx_ptr->next == tx_list_head) {\r\nwhile (tx_list_head->status.status_word == 0) {\r\nudelay(10);\r\nif (!(bfin_read_DMA2_IRQ_STATUS() & DMA_RUN))\r\nbreak;\r\nif (timeout_cnt-- < 0)\r\nbreak;\r\n}\r\nif (timeout_cnt >= 0)\r\n_tx_reclaim_skb();\r\nelse\r\nnetif_stop_queue(lp->ndev);\r\n}\r\nif (current_tx_ptr->next != tx_list_head &&\r\nnetif_queue_stopped(lp->ndev))\r\nnetif_wake_queue(lp->ndev);\r\nif (tx_list_head != current_tx_ptr) {\r\nif (netif_queue_stopped(lp->ndev))\r\nlp->tx_reclaim_timer.expires =\r\njiffies + (TX_RECLAIM_JIFFIES >> 4);\r\nelse\r\nlp->tx_reclaim_timer.expires =\r\njiffies + TX_RECLAIM_JIFFIES;\r\nmod_timer(&lp->tx_reclaim_timer,\r\nlp->tx_reclaim_timer.expires);\r\n}\r\nreturn;\r\n}\r\nstatic void tx_reclaim_skb_timeout(unsigned long lp)\r\n{\r\ntx_reclaim_skb((struct bfin_mac_local *)lp);\r\n}\r\nstatic int bfin_mac_hard_start_xmit(struct sk_buff *skb,\r\nstruct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nu16 *data;\r\nu32 data_align = (unsigned long)(skb->data) & 0x3;\r\ncurrent_tx_ptr->skb = skb;\r\nif (data_align == 0x2) {\r\ndata = (u16 *)(skb->data) - 1;\r\n*data = (u16)(skb->len);\r\nif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)\r\n*data |= 0x1000;\r\ncurrent_tx_ptr->desc_a.start_addr = (u32)data;\r\nblackfin_dcache_flush_range((u32)data,\r\n(u32)((u8 *)data + skb->len + 4));\r\n} else {\r\n*((u16 *)(current_tx_ptr->packet)) = (u16)(skb->len);\r\nif (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)\r\n*((u16 *)(current_tx_ptr->packet)) |= 0x1000;\r\nmemcpy((u8 *)(current_tx_ptr->packet + 2), skb->data,\r\nskb->len);\r\ncurrent_tx_ptr->desc_a.start_addr =\r\n(u32)current_tx_ptr->packet;\r\nblackfin_dcache_flush_range(\r\n(u32)current_tx_ptr->packet,\r\n(u32)(current_tx_ptr->packet + skb->len + 2));\r\n}\r\nSSYNC();\r\ncurrent_tx_ptr->status.status_word = 0;\r\ncurrent_tx_ptr->desc_a.config |= DMAEN;\r\nif (bfin_read_DMA2_IRQ_STATUS() & DMA_RUN)\r\ngoto out;\r\nbfin_write_DMA2_NEXT_DESC_PTR(&(current_tx_ptr->desc_a));\r\nbfin_write_DMA2_CONFIG(current_tx_ptr->desc_a.config);\r\nbfin_write_EMAC_OPMODE(bfin_read_EMAC_OPMODE() | TE);\r\nout:\r\nbfin_tx_hwtstamp(dev, skb);\r\ncurrent_tx_ptr = current_tx_ptr->next;\r\ndev->stats.tx_packets++;\r\ndev->stats.tx_bytes += (skb->len);\r\ntx_reclaim_skb(lp);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void bfin_mac_rx(struct bfin_mac_local *lp)\r\n{\r\nstruct net_device *dev = lp->ndev;\r\nstruct sk_buff *skb, *new_skb;\r\nunsigned short len;\r\n#if defined(BFIN_MAC_CSUM_OFFLOAD)\r\nunsigned int i;\r\nunsigned char fcs[ETH_FCS_LEN + 1];\r\n#endif\r\nif (current_rx_ptr->status.status_word & RX_ERROR_MASK) {\r\nnetdev_notice(dev, "rx: receive error - packet dropped\n");\r\ndev->stats.rx_dropped++;\r\ngoto out;\r\n}\r\nskb = current_rx_ptr->skb;\r\nnew_skb = netdev_alloc_skb(dev, PKT_BUF_SZ + NET_IP_ALIGN);\r\nif (!new_skb) {\r\ndev->stats.rx_dropped++;\r\ngoto out;\r\n}\r\nskb_reserve(new_skb, NET_IP_ALIGN);\r\nblackfin_dcache_invalidate_range((unsigned long)new_skb->head,\r\n(unsigned long)new_skb->end);\r\ncurrent_rx_ptr->skb = new_skb;\r\ncurrent_rx_ptr->desc_a.start_addr = (unsigned long)new_skb->data - 2;\r\nlen = (unsigned short)(current_rx_ptr->status.status_word & RX_FRLEN);\r\nlen -= ETH_FCS_LEN;\r\nskb_put(skb, len);\r\nskb->protocol = eth_type_trans(skb, dev);\r\nbfin_rx_hwtstamp(dev, skb);\r\n#if defined(BFIN_MAC_CSUM_OFFLOAD)\r\nif (skb->data[IP_HEADER_OFF] == 0x45) {\r\nskb->csum = current_rx_ptr->status.ip_payload_csum;\r\nif (skb->len % 2) {\r\nfcs[0] = 0;\r\nfor (i = 0; i < ETH_FCS_LEN; i++)\r\nfcs[i + 1] = ~skb->data[skb->len + i];\r\nskb->csum = csum_partial(fcs, ETH_FCS_LEN + 1, skb->csum);\r\n} else {\r\nfor (i = 0; i < ETH_FCS_LEN; i++)\r\nfcs[i] = ~skb->data[skb->len + i];\r\nskb->csum = csum_partial(fcs, ETH_FCS_LEN, skb->csum);\r\n}\r\nskb->ip_summed = CHECKSUM_COMPLETE;\r\n}\r\n#endif\r\nnapi_gro_receive(&lp->napi, skb);\r\ndev->stats.rx_packets++;\r\ndev->stats.rx_bytes += len;\r\nout:\r\ncurrent_rx_ptr->status.status_word = 0x00000000;\r\ncurrent_rx_ptr = current_rx_ptr->next;\r\n}\r\nstatic int bfin_mac_poll(struct napi_struct *napi, int budget)\r\n{\r\nint i = 0;\r\nstruct bfin_mac_local *lp = container_of(napi,\r\nstruct bfin_mac_local,\r\nnapi);\r\nwhile (current_rx_ptr->status.status_word != 0 && i < budget) {\r\nbfin_mac_rx(lp);\r\ni++;\r\n}\r\nif (i < budget) {\r\nnapi_complete_done(napi, i);\r\nif (test_and_clear_bit(BFIN_MAC_RX_IRQ_DISABLED, &lp->flags))\r\nenable_irq(IRQ_MAC_RX);\r\n}\r\nreturn i;\r\n}\r\nstatic irqreturn_t bfin_mac_interrupt(int irq, void *dev_id)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev_id);\r\nu32 status;\r\nstatus = bfin_read_DMA1_IRQ_STATUS();\r\nbfin_write_DMA1_IRQ_STATUS(status | DMA_DONE | DMA_ERR);\r\nif (status & DMA_DONE) {\r\ndisable_irq_nosync(IRQ_MAC_RX);\r\nset_bit(BFIN_MAC_RX_IRQ_DISABLED, &lp->flags);\r\nnapi_schedule(&lp->napi);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void bfin_mac_poll_controller(struct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nbfin_mac_interrupt(IRQ_MAC_RX, dev);\r\ntx_reclaim_skb(lp);\r\n}\r\nstatic void bfin_mac_disable(void)\r\n{\r\nunsigned int opmode;\r\nopmode = bfin_read_EMAC_OPMODE();\r\nopmode &= (~RE);\r\nopmode &= (~TE);\r\nbfin_write_EMAC_OPMODE(opmode);\r\n}\r\nstatic int bfin_mac_enable(struct phy_device *phydev)\r\n{\r\nint ret;\r\nu32 opmode;\r\npr_debug("%s\n", __func__);\r\nbfin_write_DMA1_NEXT_DESC_PTR(&(rx_list_head->desc_a));\r\nbfin_write_DMA1_CONFIG(rx_list_head->desc_a.config);\r\nret = bfin_mdio_poll();\r\nif (ret)\r\nreturn ret;\r\nopmode = bfin_read_EMAC_OPMODE();\r\nif (opmode & FDMODE)\r\nopmode |= PSF;\r\nelse\r\nopmode |= DRO | DC | PSF;\r\nopmode |= RE;\r\nif (phydev->interface == PHY_INTERFACE_MODE_RMII) {\r\nopmode |= RMII;\r\n#if defined(CONFIG_BF537) || defined(CONFIG_BF536)\r\nif (__SILICON_REVISION__ < 3) {\r\nopmode |= TE;\r\n}\r\n#endif\r\n}\r\nbfin_write_EMAC_OPMODE(opmode);\r\nreturn 0;\r\n}\r\nstatic void bfin_mac_timeout(struct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\npr_debug("%s: %s\n", dev->name, __func__);\r\nbfin_mac_disable();\r\ndel_timer(&lp->tx_reclaim_timer);\r\nwhile (tx_list_head != current_tx_ptr) {\r\ntx_list_head->desc_a.config &= ~DMAEN;\r\ntx_list_head->status.status_word = 0;\r\nif (tx_list_head->skb) {\r\ndev_kfree_skb(tx_list_head->skb);\r\ntx_list_head->skb = NULL;\r\n}\r\ntx_list_head = tx_list_head->next;\r\n}\r\nif (netif_queue_stopped(dev))\r\nnetif_wake_queue(dev);\r\nbfin_mac_enable(dev->phydev);\r\nnetif_trans_update(dev);\r\n}\r\nstatic void bfin_mac_multicast_hash(struct net_device *dev)\r\n{\r\nu32 emac_hashhi, emac_hashlo;\r\nstruct netdev_hw_addr *ha;\r\nu32 crc;\r\nemac_hashhi = emac_hashlo = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\ncrc = ether_crc(ETH_ALEN, ha->addr);\r\ncrc >>= 26;\r\nif (crc & 0x20)\r\nemac_hashhi |= 1 << (crc & 0x1f);\r\nelse\r\nemac_hashlo |= 1 << (crc & 0x1f);\r\n}\r\nbfin_write_EMAC_HASHHI(emac_hashhi);\r\nbfin_write_EMAC_HASHLO(emac_hashlo);\r\n}\r\nstatic void bfin_mac_set_multicast_list(struct net_device *dev)\r\n{\r\nu32 sysctl;\r\nif (dev->flags & IFF_PROMISC) {\r\nnetdev_info(dev, "set promisc mode\n");\r\nsysctl = bfin_read_EMAC_OPMODE();\r\nsysctl |= PR;\r\nbfin_write_EMAC_OPMODE(sysctl);\r\n} else if (dev->flags & IFF_ALLMULTI) {\r\nsysctl = bfin_read_EMAC_OPMODE();\r\nsysctl |= PAM;\r\nbfin_write_EMAC_OPMODE(sysctl);\r\n} else if (!netdev_mc_empty(dev)) {\r\nsysctl = bfin_read_EMAC_OPMODE();\r\nsysctl |= HM;\r\nbfin_write_EMAC_OPMODE(sysctl);\r\nbfin_mac_multicast_hash(dev);\r\n} else {\r\nsysctl = bfin_read_EMAC_OPMODE();\r\nsysctl &= ~(RAF | PAM);\r\nbfin_write_EMAC_OPMODE(sysctl);\r\n}\r\n}\r\nstatic int bfin_mac_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nif (!netif_running(netdev))\r\nreturn -EINVAL;\r\nswitch (cmd) {\r\ncase SIOCSHWTSTAMP:\r\nreturn bfin_mac_hwtstamp_set(netdev, ifr);\r\ncase SIOCGHWTSTAMP:\r\nreturn bfin_mac_hwtstamp_get(netdev, ifr);\r\ndefault:\r\nif (netdev->phydev)\r\nreturn phy_mii_ioctl(netdev->phydev, ifr, cmd);\r\nelse\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void bfin_mac_shutdown(struct net_device *dev)\r\n{\r\nbfin_write_EMAC_OPMODE(0x00000000);\r\nbfin_write_DMA1_CONFIG(0x0000);\r\nbfin_write_DMA2_CONFIG(0x0000);\r\n}\r\nstatic int bfin_mac_open(struct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\nint ret;\r\npr_debug("%s: %s\n", dev->name, __func__);\r\nif (!is_valid_ether_addr(dev->dev_addr)) {\r\nnetdev_warn(dev, "no valid ethernet hw addr\n");\r\nreturn -EINVAL;\r\n}\r\nret = desc_list_init(dev);\r\nif (ret)\r\nreturn ret;\r\nphy_start(dev->phydev);\r\nsetup_system_regs(dev);\r\nsetup_mac_addr(dev->dev_addr);\r\nbfin_mac_disable();\r\nret = bfin_mac_enable(dev->phydev);\r\nif (ret)\r\nreturn ret;\r\npr_debug("hardware init finished\n");\r\nnapi_enable(&lp->napi);\r\nnetif_start_queue(dev);\r\nnetif_carrier_on(dev);\r\nreturn 0;\r\n}\r\nstatic int bfin_mac_close(struct net_device *dev)\r\n{\r\nstruct bfin_mac_local *lp = netdev_priv(dev);\r\npr_debug("%s: %s\n", dev->name, __func__);\r\nnetif_stop_queue(dev);\r\nnapi_disable(&lp->napi);\r\nnetif_carrier_off(dev);\r\nphy_stop(dev->phydev);\r\nphy_write(dev->phydev, MII_BMCR, BMCR_PDOWN);\r\nbfin_mac_shutdown(dev);\r\ndesc_list_free();\r\nreturn 0;\r\n}\r\nstatic int bfin_mac_probe(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev;\r\nstruct bfin_mac_local *lp;\r\nstruct platform_device *pd;\r\nstruct bfin_mii_bus_platform_data *mii_bus_data;\r\nint rc;\r\nndev = alloc_etherdev(sizeof(struct bfin_mac_local));\r\nif (!ndev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nplatform_set_drvdata(pdev, ndev);\r\nlp = netdev_priv(ndev);\r\nlp->ndev = ndev;\r\n*(__le32 *) (&(ndev->dev_addr[0])) = cpu_to_le32(bfin_read_EMAC_ADDRLO());\r\n*(__le16 *) (&(ndev->dev_addr[4])) = cpu_to_le16((u16) bfin_read_EMAC_ADDRHI());\r\nbfin_write_EMAC_ADDRLO(0x12345678);\r\nif (bfin_read_EMAC_ADDRLO() != 0x12345678) {\r\ndev_err(&pdev->dev, "Cannot detect Blackfin on-chip ethernet MAC controller!\n");\r\nrc = -ENODEV;\r\ngoto out_err_probe_mac;\r\n}\r\nif (!is_valid_ether_addr(ndev->dev_addr)) {\r\nif (bfin_get_ether_addr(ndev->dev_addr) ||\r\n!is_valid_ether_addr(ndev->dev_addr)) {\r\nnetdev_warn(ndev, "Setting Ethernet MAC to a random one\n");\r\neth_hw_addr_random(ndev);\r\n}\r\n}\r\nsetup_mac_addr(ndev->dev_addr);\r\nif (!dev_get_platdata(&pdev->dev)) {\r\ndev_err(&pdev->dev, "Cannot get platform device bfin_mii_bus!\n");\r\nrc = -ENODEV;\r\ngoto out_err_probe_mac;\r\n}\r\npd = dev_get_platdata(&pdev->dev);\r\nlp->mii_bus = platform_get_drvdata(pd);\r\nif (!lp->mii_bus) {\r\ndev_err(&pdev->dev, "Cannot get mii_bus!\n");\r\nrc = -ENODEV;\r\ngoto out_err_probe_mac;\r\n}\r\nlp->mii_bus->priv = ndev;\r\nmii_bus_data = dev_get_platdata(&pd->dev);\r\nrc = mii_probe(ndev, mii_bus_data->phy_mode);\r\nif (rc) {\r\ndev_err(&pdev->dev, "MII Probe failed!\n");\r\ngoto out_err_mii_probe;\r\n}\r\nlp->vlan1_mask = ETH_P_8021Q | mii_bus_data->vlan1_mask;\r\nlp->vlan2_mask = ETH_P_8021Q | mii_bus_data->vlan2_mask;\r\nndev->netdev_ops = &bfin_mac_netdev_ops;\r\nndev->ethtool_ops = &bfin_mac_ethtool_ops;\r\ninit_timer(&lp->tx_reclaim_timer);\r\nlp->tx_reclaim_timer.data = (unsigned long)lp;\r\nlp->tx_reclaim_timer.function = tx_reclaim_skb_timeout;\r\nlp->flags = 0;\r\nnetif_napi_add(ndev, &lp->napi, bfin_mac_poll, CONFIG_BFIN_RX_DESC_NUM);\r\nspin_lock_init(&lp->lock);\r\nrc = request_irq(IRQ_MAC_RX, bfin_mac_interrupt,\r\n0, "EMAC_RX", ndev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot request Blackfin MAC RX IRQ!\n");\r\nrc = -EBUSY;\r\ngoto out_err_request_irq;\r\n}\r\nrc = register_netdev(ndev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot register net device!\n");\r\ngoto out_err_reg_ndev;\r\n}\r\nbfin_mac_hwtstamp_init(ndev);\r\nrc = bfin_phc_init(ndev, &pdev->dev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot register PHC device!\n");\r\ngoto out_err_phc;\r\n}\r\nnetdev_info(ndev, "%s, Version %s\n", DRV_DESC, DRV_VERSION);\r\nreturn 0;\r\nout_err_phc:\r\nout_err_reg_ndev:\r\nfree_irq(IRQ_MAC_RX, ndev);\r\nout_err_request_irq:\r\nnetif_napi_del(&lp->napi);\r\nout_err_mii_probe:\r\nmdiobus_unregister(lp->mii_bus);\r\nmdiobus_free(lp->mii_bus);\r\nout_err_probe_mac:\r\nfree_netdev(ndev);\r\nreturn rc;\r\n}\r\nstatic int bfin_mac_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct bfin_mac_local *lp = netdev_priv(ndev);\r\nbfin_phc_release(lp);\r\nlp->mii_bus->priv = NULL;\r\nunregister_netdev(ndev);\r\nnetif_napi_del(&lp->napi);\r\nfree_irq(IRQ_MAC_RX, ndev);\r\nfree_netdev(ndev);\r\nreturn 0;\r\n}\r\nstatic int bfin_mac_suspend(struct platform_device *pdev, pm_message_t mesg)\r\n{\r\nstruct net_device *net_dev = platform_get_drvdata(pdev);\r\nstruct bfin_mac_local *lp = netdev_priv(net_dev);\r\nif (lp->wol) {\r\nbfin_write_EMAC_OPMODE((bfin_read_EMAC_OPMODE() & ~TE) | RE);\r\nbfin_write_EMAC_WKUP_CTL(MPKE);\r\nenable_irq_wake(IRQ_MAC_WAKEDET);\r\n} else {\r\nif (netif_running(net_dev))\r\nbfin_mac_close(net_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_mac_resume(struct platform_device *pdev)\r\n{\r\nstruct net_device *net_dev = platform_get_drvdata(pdev);\r\nstruct bfin_mac_local *lp = netdev_priv(net_dev);\r\nif (lp->wol) {\r\nbfin_write_EMAC_OPMODE(bfin_read_EMAC_OPMODE() | TE);\r\nbfin_write_EMAC_WKUP_CTL(0);\r\ndisable_irq_wake(IRQ_MAC_WAKEDET);\r\n} else {\r\nif (netif_running(net_dev))\r\nbfin_mac_open(net_dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic int bfin_mii_bus_probe(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *miibus;\r\nstruct bfin_mii_bus_platform_data *mii_bus_pd;\r\nconst unsigned short *pin_req;\r\nint rc, i;\r\nmii_bus_pd = dev_get_platdata(&pdev->dev);\r\nif (!mii_bus_pd) {\r\ndev_err(&pdev->dev, "No peripherals in platform data!\n");\r\nreturn -EINVAL;\r\n}\r\npin_req = mii_bus_pd->mac_peripherals;\r\nrc = peripheral_request_list(pin_req, KBUILD_MODNAME);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Requesting peripherals failed!\n");\r\nreturn rc;\r\n}\r\nrc = -ENOMEM;\r\nmiibus = mdiobus_alloc();\r\nif (miibus == NULL)\r\ngoto out_err_alloc;\r\nmiibus->read = bfin_mdiobus_read;\r\nmiibus->write = bfin_mdiobus_write;\r\nmiibus->parent = &pdev->dev;\r\nmiibus->name = "bfin_mii_bus";\r\nmiibus->phy_mask = mii_bus_pd->phy_mask;\r\nsnprintf(miibus->id, MII_BUS_ID_SIZE, "%s-%x",\r\npdev->name, pdev->id);\r\nrc = clamp(mii_bus_pd->phydev_number, 0, PHY_MAX_ADDR);\r\nif (rc != mii_bus_pd->phydev_number)\r\ndev_err(&pdev->dev, "Invalid number (%i) of phydevs\n",\r\nmii_bus_pd->phydev_number);\r\nfor (i = 0; i < rc; ++i) {\r\nunsigned short phyaddr = mii_bus_pd->phydev_data[i].addr;\r\nif (phyaddr < PHY_MAX_ADDR)\r\nmiibus->irq[phyaddr] = mii_bus_pd->phydev_data[i].irq;\r\nelse\r\ndev_err(&pdev->dev,\r\n"Invalid PHY address %i for phydev %i\n",\r\nphyaddr, i);\r\n}\r\nrc = mdiobus_register(miibus);\r\nif (rc) {\r\ndev_err(&pdev->dev, "Cannot register MDIO bus!\n");\r\ngoto out_err_irq_alloc;\r\n}\r\nplatform_set_drvdata(pdev, miibus);\r\nreturn 0;\r\nout_err_irq_alloc:\r\nmdiobus_free(miibus);\r\nout_err_alloc:\r\nperipheral_free_list(pin_req);\r\nreturn rc;\r\n}\r\nstatic int bfin_mii_bus_remove(struct platform_device *pdev)\r\n{\r\nstruct mii_bus *miibus = platform_get_drvdata(pdev);\r\nstruct bfin_mii_bus_platform_data *mii_bus_pd =\r\ndev_get_platdata(&pdev->dev);\r\nmdiobus_unregister(miibus);\r\nmdiobus_free(miibus);\r\nperipheral_free_list(mii_bus_pd->mac_peripherals);\r\nreturn 0;\r\n}\r\nstatic int __init bfin_mac_init(void)\r\n{\r\nreturn platform_register_drivers(drivers, ARRAY_SIZE(drivers));\r\n}\r\nstatic void __exit bfin_mac_cleanup(void)\r\n{\r\nplatform_unregister_drivers(drivers, ARRAY_SIZE(drivers));\r\n}
