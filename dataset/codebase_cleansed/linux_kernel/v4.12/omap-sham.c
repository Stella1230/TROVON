static inline u32 omap_sham_read(struct omap_sham_dev *dd, u32 offset)\r\n{\r\nreturn __raw_readl(dd->io_base + offset);\r\n}\r\nstatic inline void omap_sham_write(struct omap_sham_dev *dd,\r\nu32 offset, u32 value)\r\n{\r\n__raw_writel(value, dd->io_base + offset);\r\n}\r\nstatic inline void omap_sham_write_mask(struct omap_sham_dev *dd, u32 address,\r\nu32 value, u32 mask)\r\n{\r\nu32 val;\r\nval = omap_sham_read(dd, address);\r\nval &= ~mask;\r\nval |= value;\r\nomap_sham_write(dd, address, val);\r\n}\r\nstatic inline int omap_sham_wait(struct omap_sham_dev *dd, u32 offset, u32 bit)\r\n{\r\nunsigned long timeout = jiffies + DEFAULT_TIMEOUT_INTERVAL;\r\nwhile (!(omap_sham_read(dd, offset) & bit)) {\r\nif (time_is_before_jiffies(timeout))\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_sham_copy_hash_omap2(struct ahash_request *req, int out)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nu32 *hash = (u32 *)ctx->digest;\r\nint i;\r\nfor (i = 0; i < dd->pdata->digest_size / sizeof(u32); i++) {\r\nif (out)\r\nhash[i] = omap_sham_read(dd, SHA_REG_IDIGEST(dd, i));\r\nelse\r\nomap_sham_write(dd, SHA_REG_IDIGEST(dd, i), hash[i]);\r\n}\r\n}\r\nstatic void omap_sham_copy_hash_omap4(struct ahash_request *req, int out)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nint i;\r\nif (ctx->flags & BIT(FLAGS_HMAC)) {\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(dd->req);\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nu32 *opad = (u32 *)bctx->opad;\r\nfor (i = 0; i < dd->pdata->digest_size / sizeof(u32); i++) {\r\nif (out)\r\nopad[i] = omap_sham_read(dd,\r\nSHA_REG_ODIGEST(dd, i));\r\nelse\r\nomap_sham_write(dd, SHA_REG_ODIGEST(dd, i),\r\nopad[i]);\r\n}\r\n}\r\nomap_sham_copy_hash_omap2(req, out);\r\n}\r\nstatic void omap_sham_copy_ready_hash(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nu32 *in = (u32 *)ctx->digest;\r\nu32 *hash = (u32 *)req->result;\r\nint i, d, big_endian = 0;\r\nif (!hash)\r\nreturn;\r\nswitch (ctx->flags & FLAGS_MODE_MASK) {\r\ncase FLAGS_MODE_MD5:\r\nd = MD5_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA1:\r\nif (test_bit(FLAGS_BE32_SHA1, &ctx->dd->flags))\r\nbig_endian = 1;\r\nd = SHA1_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA224:\r\nd = SHA224_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA256:\r\nd = SHA256_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA384:\r\nd = SHA384_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ncase FLAGS_MODE_SHA512:\r\nd = SHA512_DIGEST_SIZE / sizeof(u32);\r\nbreak;\r\ndefault:\r\nd = 0;\r\n}\r\nif (big_endian)\r\nfor (i = 0; i < d; i++)\r\nhash[i] = be32_to_cpu(in[i]);\r\nelse\r\nfor (i = 0; i < d; i++)\r\nhash[i] = le32_to_cpu(in[i]);\r\n}\r\nstatic int omap_sham_hw_init(struct omap_sham_dev *dd)\r\n{\r\nint err;\r\nerr = pm_runtime_get_sync(dd->dev);\r\nif (err < 0) {\r\ndev_err(dd->dev, "failed to get sync: %d\n", err);\r\nreturn err;\r\n}\r\nif (!test_bit(FLAGS_INIT, &dd->flags)) {\r\nset_bit(FLAGS_INIT, &dd->flags);\r\ndd->err = 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic void omap_sham_write_ctrl_omap2(struct omap_sham_dev *dd, size_t length,\r\nint final, int dma)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nu32 val = length << 5, mask;\r\nif (likely(ctx->digcnt))\r\nomap_sham_write(dd, SHA_REG_DIGCNT(dd), ctx->digcnt);\r\nomap_sham_write_mask(dd, SHA_REG_MASK(dd),\r\nSHA_REG_MASK_IT_EN | (dma ? SHA_REG_MASK_DMA_EN : 0),\r\nSHA_REG_MASK_IT_EN | SHA_REG_MASK_DMA_EN);\r\nif ((ctx->flags & FLAGS_MODE_MASK) == FLAGS_MODE_SHA1)\r\nval |= SHA_REG_CTRL_ALGO;\r\nif (!ctx->digcnt)\r\nval |= SHA_REG_CTRL_ALGO_CONST;\r\nif (final)\r\nval |= SHA_REG_CTRL_CLOSE_HASH;\r\nmask = SHA_REG_CTRL_ALGO_CONST | SHA_REG_CTRL_CLOSE_HASH |\r\nSHA_REG_CTRL_ALGO | SHA_REG_CTRL_LENGTH;\r\nomap_sham_write_mask(dd, SHA_REG_CTRL, val, mask);\r\n}\r\nstatic void omap_sham_trigger_omap2(struct omap_sham_dev *dd, size_t length)\r\n{\r\n}\r\nstatic int omap_sham_poll_irq_omap2(struct omap_sham_dev *dd)\r\n{\r\nreturn omap_sham_wait(dd, SHA_REG_CTRL, SHA_REG_CTRL_INPUT_READY);\r\n}\r\nstatic int get_block_size(struct omap_sham_reqctx *ctx)\r\n{\r\nint d;\r\nswitch (ctx->flags & FLAGS_MODE_MASK) {\r\ncase FLAGS_MODE_MD5:\r\ncase FLAGS_MODE_SHA1:\r\nd = SHA1_BLOCK_SIZE;\r\nbreak;\r\ncase FLAGS_MODE_SHA224:\r\ncase FLAGS_MODE_SHA256:\r\nd = SHA256_BLOCK_SIZE;\r\nbreak;\r\ncase FLAGS_MODE_SHA384:\r\ncase FLAGS_MODE_SHA512:\r\nd = SHA512_BLOCK_SIZE;\r\nbreak;\r\ndefault:\r\nd = 0;\r\n}\r\nreturn d;\r\n}\r\nstatic void omap_sham_write_n(struct omap_sham_dev *dd, u32 offset,\r\nu32 *value, int count)\r\n{\r\nfor (; count--; value++, offset += 4)\r\nomap_sham_write(dd, offset, *value);\r\n}\r\nstatic void omap_sham_write_ctrl_omap4(struct omap_sham_dev *dd, size_t length,\r\nint final, int dma)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nu32 val, mask;\r\nval = (ctx->flags & FLAGS_MODE_MASK) >> (FLAGS_MODE_SHIFT);\r\nif (!ctx->digcnt) {\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(dd->req);\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nint bs, nr_dr;\r\nval |= SHA_REG_MODE_ALGO_CONSTANT;\r\nif (ctx->flags & BIT(FLAGS_HMAC)) {\r\nbs = get_block_size(ctx);\r\nnr_dr = bs / (2 * sizeof(u32));\r\nval |= SHA_REG_MODE_HMAC_KEY_PROC;\r\nomap_sham_write_n(dd, SHA_REG_ODIGEST(dd, 0),\r\n(u32 *)bctx->ipad, nr_dr);\r\nomap_sham_write_n(dd, SHA_REG_IDIGEST(dd, 0),\r\n(u32 *)bctx->ipad + nr_dr, nr_dr);\r\nctx->digcnt += bs;\r\n}\r\n}\r\nif (final) {\r\nval |= SHA_REG_MODE_CLOSE_HASH;\r\nif (ctx->flags & BIT(FLAGS_HMAC))\r\nval |= SHA_REG_MODE_HMAC_OUTER_HASH;\r\n}\r\nmask = SHA_REG_MODE_ALGO_CONSTANT | SHA_REG_MODE_CLOSE_HASH |\r\nSHA_REG_MODE_ALGO_MASK | SHA_REG_MODE_HMAC_OUTER_HASH |\r\nSHA_REG_MODE_HMAC_KEY_PROC;\r\ndev_dbg(dd->dev, "ctrl: %08x, flags: %08lx\n", val, ctx->flags);\r\nomap_sham_write_mask(dd, SHA_REG_MODE(dd), val, mask);\r\nomap_sham_write(dd, SHA_REG_IRQENA, SHA_REG_IRQENA_OUTPUT_RDY);\r\nomap_sham_write_mask(dd, SHA_REG_MASK(dd),\r\nSHA_REG_MASK_IT_EN |\r\n(dma ? SHA_REG_MASK_DMA_EN : 0),\r\nSHA_REG_MASK_IT_EN | SHA_REG_MASK_DMA_EN);\r\n}\r\nstatic void omap_sham_trigger_omap4(struct omap_sham_dev *dd, size_t length)\r\n{\r\nomap_sham_write(dd, SHA_REG_LENGTH(dd), length);\r\n}\r\nstatic int omap_sham_poll_irq_omap4(struct omap_sham_dev *dd)\r\n{\r\nreturn omap_sham_wait(dd, SHA_REG_IRQSTATUS,\r\nSHA_REG_IRQSTATUS_INPUT_RDY);\r\n}\r\nstatic int omap_sham_xmit_cpu(struct omap_sham_dev *dd, size_t length,\r\nint final)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nint count, len32, bs32, offset = 0;\r\nconst u32 *buffer;\r\nint mlen;\r\nstruct sg_mapping_iter mi;\r\ndev_dbg(dd->dev, "xmit_cpu: digcnt: %d, length: %d, final: %d\n",\r\nctx->digcnt, length, final);\r\ndd->pdata->write_ctrl(dd, length, final, 0);\r\ndd->pdata->trigger(dd, length);\r\nctx->digcnt += length;\r\nctx->total -= length;\r\nif (final)\r\nset_bit(FLAGS_FINAL, &dd->flags);\r\nset_bit(FLAGS_CPU, &dd->flags);\r\nlen32 = DIV_ROUND_UP(length, sizeof(u32));\r\nbs32 = get_block_size(ctx) / sizeof(u32);\r\nsg_miter_start(&mi, ctx->sg, ctx->sg_len,\r\nSG_MITER_FROM_SG | SG_MITER_ATOMIC);\r\nmlen = 0;\r\nwhile (len32) {\r\nif (dd->pdata->poll_irq(dd))\r\nreturn -ETIMEDOUT;\r\nfor (count = 0; count < min(len32, bs32); count++, offset++) {\r\nif (!mlen) {\r\nsg_miter_next(&mi);\r\nmlen = mi.length;\r\nif (!mlen) {\r\npr_err("sg miter failure.\n");\r\nreturn -EINVAL;\r\n}\r\noffset = 0;\r\nbuffer = mi.addr;\r\n}\r\nomap_sham_write(dd, SHA_REG_DIN(dd, count),\r\nbuffer[offset]);\r\nmlen -= 4;\r\n}\r\nlen32 -= min(len32, bs32);\r\n}\r\nsg_miter_stop(&mi);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic void omap_sham_dma_callback(void *param)\r\n{\r\nstruct omap_sham_dev *dd = param;\r\nset_bit(FLAGS_DMA_READY, &dd->flags);\r\ntasklet_schedule(&dd->done_task);\r\n}\r\nstatic int omap_sham_xmit_dma(struct omap_sham_dev *dd, size_t length,\r\nint final)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\nstruct dma_async_tx_descriptor *tx;\r\nstruct dma_slave_config cfg;\r\nint ret;\r\ndev_dbg(dd->dev, "xmit_dma: digcnt: %d, length: %d, final: %d\n",\r\nctx->digcnt, length, final);\r\nif (!dma_map_sg(dd->dev, ctx->sg, ctx->sg_len, DMA_TO_DEVICE)) {\r\ndev_err(dd->dev, "dma_map_sg error\n");\r\nreturn -EINVAL;\r\n}\r\nmemset(&cfg, 0, sizeof(cfg));\r\ncfg.dst_addr = dd->phys_base + SHA_REG_DIN(dd, 0);\r\ncfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\ncfg.dst_maxburst = get_block_size(ctx) / DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nret = dmaengine_slave_config(dd->dma_lch, &cfg);\r\nif (ret) {\r\npr_err("omap-sham: can't configure dmaengine slave: %d\n", ret);\r\nreturn ret;\r\n}\r\ntx = dmaengine_prep_slave_sg(dd->dma_lch, ctx->sg, ctx->sg_len,\r\nDMA_MEM_TO_DEV,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!tx) {\r\ndev_err(dd->dev, "prep_slave_sg failed\n");\r\nreturn -EINVAL;\r\n}\r\ntx->callback = omap_sham_dma_callback;\r\ntx->callback_param = dd;\r\ndd->pdata->write_ctrl(dd, length, final, 1);\r\nctx->digcnt += length;\r\nctx->total -= length;\r\nif (final)\r\nset_bit(FLAGS_FINAL, &dd->flags);\r\nset_bit(FLAGS_DMA_ACTIVE, &dd->flags);\r\ndmaengine_submit(tx);\r\ndma_async_issue_pending(dd->dma_lch);\r\ndd->pdata->trigger(dd, length);\r\nreturn -EINPROGRESS;\r\n}\r\nstatic int omap_sham_copy_sg_lists(struct omap_sham_reqctx *ctx,\r\nstruct scatterlist *sg, int bs, int new_len)\r\n{\r\nint n = sg_nents(sg);\r\nstruct scatterlist *tmp;\r\nint offset = ctx->offset;\r\nif (ctx->bufcnt)\r\nn++;\r\nctx->sg = kmalloc_array(n, sizeof(*sg), GFP_KERNEL);\r\nif (!ctx->sg)\r\nreturn -ENOMEM;\r\nsg_init_table(ctx->sg, n);\r\ntmp = ctx->sg;\r\nctx->sg_len = 0;\r\nif (ctx->bufcnt) {\r\nsg_set_buf(tmp, ctx->dd->xmit_buf, ctx->bufcnt);\r\ntmp = sg_next(tmp);\r\nctx->sg_len++;\r\n}\r\nwhile (sg && new_len) {\r\nint len = sg->length - offset;\r\nif (offset) {\r\noffset -= sg->length;\r\nif (offset < 0)\r\noffset = 0;\r\n}\r\nif (new_len < len)\r\nlen = new_len;\r\nif (len > 0) {\r\nnew_len -= len;\r\nsg_set_page(tmp, sg_page(sg), len, sg->offset);\r\nif (new_len <= 0)\r\nsg_mark_end(tmp);\r\ntmp = sg_next(tmp);\r\nctx->sg_len++;\r\n}\r\nsg = sg_next(sg);\r\n}\r\nset_bit(FLAGS_SGS_ALLOCED, &ctx->dd->flags);\r\nctx->bufcnt = 0;\r\nreturn 0;\r\n}\r\nstatic int omap_sham_copy_sgs(struct omap_sham_reqctx *ctx,\r\nstruct scatterlist *sg, int bs, int new_len)\r\n{\r\nint pages;\r\nvoid *buf;\r\nint len;\r\nlen = new_len + ctx->bufcnt;\r\npages = get_order(ctx->total);\r\nbuf = (void *)__get_free_pages(GFP_ATOMIC, pages);\r\nif (!buf) {\r\npr_err("Couldn't allocate pages for unaligned cases.\n");\r\nreturn -ENOMEM;\r\n}\r\nif (ctx->bufcnt)\r\nmemcpy(buf, ctx->dd->xmit_buf, ctx->bufcnt);\r\nscatterwalk_map_and_copy(buf + ctx->bufcnt, sg, ctx->offset,\r\nctx->total - ctx->bufcnt, 0);\r\nsg_init_table(ctx->sgl, 1);\r\nsg_set_buf(ctx->sgl, buf, len);\r\nctx->sg = ctx->sgl;\r\nset_bit(FLAGS_SGS_COPIED, &ctx->dd->flags);\r\nctx->sg_len = 1;\r\nctx->bufcnt = 0;\r\nctx->offset = 0;\r\nreturn 0;\r\n}\r\nstatic int omap_sham_align_sgs(struct scatterlist *sg,\r\nint nbytes, int bs, bool final,\r\nstruct omap_sham_reqctx *rctx)\r\n{\r\nint n = 0;\r\nbool aligned = true;\r\nbool list_ok = true;\r\nstruct scatterlist *sg_tmp = sg;\r\nint new_len;\r\nint offset = rctx->offset;\r\nif (!sg || !sg->length || !nbytes)\r\nreturn 0;\r\nnew_len = nbytes;\r\nif (offset)\r\nlist_ok = false;\r\nif (final)\r\nnew_len = DIV_ROUND_UP(new_len, bs) * bs;\r\nelse\r\nnew_len = new_len / bs * bs;\r\nwhile (nbytes > 0 && sg_tmp) {\r\nn++;\r\nif (offset < sg_tmp->length) {\r\nif (!IS_ALIGNED(offset + sg_tmp->offset, 4)) {\r\naligned = false;\r\nbreak;\r\n}\r\nif (!IS_ALIGNED(sg_tmp->length - offset, bs)) {\r\naligned = false;\r\nbreak;\r\n}\r\n}\r\nif (offset) {\r\noffset -= sg_tmp->length;\r\nif (offset < 0) {\r\nnbytes += offset;\r\noffset = 0;\r\n}\r\n} else {\r\nnbytes -= sg_tmp->length;\r\n}\r\nsg_tmp = sg_next(sg_tmp);\r\nif (nbytes < 0) {\r\nlist_ok = false;\r\nbreak;\r\n}\r\n}\r\nif (!aligned)\r\nreturn omap_sham_copy_sgs(rctx, sg, bs, new_len);\r\nelse if (!list_ok)\r\nreturn omap_sham_copy_sg_lists(rctx, sg, bs, new_len);\r\nrctx->sg_len = n;\r\nrctx->sg = sg;\r\nreturn 0;\r\n}\r\nstatic int omap_sham_prepare_request(struct ahash_request *req, bool update)\r\n{\r\nstruct omap_sham_reqctx *rctx = ahash_request_ctx(req);\r\nint bs;\r\nint ret;\r\nint nbytes;\r\nbool final = rctx->flags & BIT(FLAGS_FINUP);\r\nint xmit_len, hash_later;\r\nif (!req)\r\nreturn 0;\r\nbs = get_block_size(rctx);\r\nif (update)\r\nnbytes = req->nbytes;\r\nelse\r\nnbytes = 0;\r\nrctx->total = nbytes + rctx->bufcnt;\r\nif (!rctx->total)\r\nreturn 0;\r\nif (nbytes && (!IS_ALIGNED(rctx->bufcnt, bs))) {\r\nint len = bs - rctx->bufcnt % bs;\r\nif (len > nbytes)\r\nlen = nbytes;\r\nscatterwalk_map_and_copy(rctx->buffer + rctx->bufcnt, req->src,\r\n0, len, 0);\r\nrctx->bufcnt += len;\r\nnbytes -= len;\r\nrctx->offset = len;\r\n}\r\nif (rctx->bufcnt)\r\nmemcpy(rctx->dd->xmit_buf, rctx->buffer, rctx->bufcnt);\r\nret = omap_sham_align_sgs(req->src, nbytes, bs, final, rctx);\r\nif (ret)\r\nreturn ret;\r\nxmit_len = rctx->total;\r\nif (!IS_ALIGNED(xmit_len, bs)) {\r\nif (final)\r\nxmit_len = DIV_ROUND_UP(xmit_len, bs) * bs;\r\nelse\r\nxmit_len = xmit_len / bs * bs;\r\n}\r\nhash_later = rctx->total - xmit_len;\r\nif (hash_later < 0)\r\nhash_later = 0;\r\nif (rctx->bufcnt && nbytes) {\r\nsg_init_table(rctx->sgl, 2);\r\nsg_set_buf(rctx->sgl, rctx->dd->xmit_buf, rctx->bufcnt);\r\nsg_chain(rctx->sgl, 2, req->src);\r\nrctx->sg = rctx->sgl;\r\nrctx->sg_len++;\r\n} else if (rctx->bufcnt) {\r\nsg_init_table(rctx->sgl, 1);\r\nsg_set_buf(rctx->sgl, rctx->dd->xmit_buf, xmit_len);\r\nrctx->sg = rctx->sgl;\r\nrctx->sg_len = 1;\r\n}\r\nif (hash_later) {\r\nif (req->nbytes) {\r\nscatterwalk_map_and_copy(rctx->buffer, req->src,\r\nreq->nbytes - hash_later,\r\nhash_later, 0);\r\n} else {\r\nmemcpy(rctx->buffer, rctx->buffer + xmit_len,\r\nhash_later);\r\n}\r\nrctx->bufcnt = hash_later;\r\n} else {\r\nrctx->bufcnt = 0;\r\n}\r\nif (!final)\r\nrctx->total = xmit_len;\r\nreturn 0;\r\n}\r\nstatic int omap_sham_update_dma_stop(struct omap_sham_dev *dd)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(dd->req);\r\ndma_unmap_sg(dd->dev, ctx->sg, ctx->sg_len, DMA_TO_DEVICE);\r\nclear_bit(FLAGS_DMA_ACTIVE, &dd->flags);\r\nreturn 0;\r\n}\r\nstatic int omap_sham_init(struct ahash_request *req)\r\n{\r\nstruct crypto_ahash *tfm = crypto_ahash_reqtfm(req);\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = NULL, *tmp;\r\nint bs = 0;\r\nspin_lock_bh(&sham.lock);\r\nif (!tctx->dd) {\r\nlist_for_each_entry(tmp, &sham.dev_list, list) {\r\ndd = tmp;\r\nbreak;\r\n}\r\ntctx->dd = dd;\r\n} else {\r\ndd = tctx->dd;\r\n}\r\nspin_unlock_bh(&sham.lock);\r\nctx->dd = dd;\r\nctx->flags = 0;\r\ndev_dbg(dd->dev, "init: digest size: %d\n",\r\ncrypto_ahash_digestsize(tfm));\r\nswitch (crypto_ahash_digestsize(tfm)) {\r\ncase MD5_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_MD5;\r\nbs = SHA1_BLOCK_SIZE;\r\nbreak;\r\ncase SHA1_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA1;\r\nbs = SHA1_BLOCK_SIZE;\r\nbreak;\r\ncase SHA224_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA224;\r\nbs = SHA224_BLOCK_SIZE;\r\nbreak;\r\ncase SHA256_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA256;\r\nbs = SHA256_BLOCK_SIZE;\r\nbreak;\r\ncase SHA384_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA384;\r\nbs = SHA384_BLOCK_SIZE;\r\nbreak;\r\ncase SHA512_DIGEST_SIZE:\r\nctx->flags |= FLAGS_MODE_SHA512;\r\nbs = SHA512_BLOCK_SIZE;\r\nbreak;\r\n}\r\nctx->bufcnt = 0;\r\nctx->digcnt = 0;\r\nctx->total = 0;\r\nctx->offset = 0;\r\nctx->buflen = BUFLEN;\r\nif (tctx->flags & BIT(FLAGS_HMAC)) {\r\nif (!test_bit(FLAGS_AUTO_XOR, &dd->flags)) {\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nmemcpy(ctx->buffer, bctx->ipad, bs);\r\nctx->bufcnt = bs;\r\n}\r\nctx->flags |= BIT(FLAGS_HMAC);\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_update_req(struct omap_sham_dev *dd)\r\n{\r\nstruct ahash_request *req = dd->req;\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint err;\r\nbool final = ctx->flags & BIT(FLAGS_FINUP);\r\ndev_dbg(dd->dev, "update_req: total: %u, digcnt: %d, finup: %d\n",\r\nctx->total, ctx->digcnt, (ctx->flags & BIT(FLAGS_FINUP)) != 0);\r\nif (ctx->total < get_block_size(ctx) ||\r\nctx->total < OMAP_SHA_DMA_THRESHOLD)\r\nctx->flags |= BIT(FLAGS_CPU);\r\nif (ctx->flags & BIT(FLAGS_CPU))\r\nerr = omap_sham_xmit_cpu(dd, ctx->total, final);\r\nelse\r\nerr = omap_sham_xmit_dma(dd, ctx->total, final);\r\ndev_dbg(dd->dev, "update: err: %d, digcnt: %d\n", err, ctx->digcnt);\r\nreturn err;\r\n}\r\nstatic int omap_sham_final_req(struct omap_sham_dev *dd)\r\n{\r\nstruct ahash_request *req = dd->req;\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint err = 0, use_dma = 1;\r\nif ((ctx->total <= get_block_size(ctx)) || dd->polling_mode)\r\nuse_dma = 0;\r\nif (use_dma)\r\nerr = omap_sham_xmit_dma(dd, ctx->total, 1);\r\nelse\r\nerr = omap_sham_xmit_cpu(dd, ctx->total, 1);\r\nctx->bufcnt = 0;\r\ndev_dbg(dd->dev, "final_req: err: %d\n", err);\r\nreturn err;\r\n}\r\nstatic int omap_sham_finish_hmac(struct ahash_request *req)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nint bs = crypto_shash_blocksize(bctx->shash);\r\nint ds = crypto_shash_digestsize(bctx->shash);\r\nSHASH_DESC_ON_STACK(shash, bctx->shash);\r\nshash->tfm = bctx->shash;\r\nshash->flags = 0;\r\nreturn crypto_shash_init(shash) ?:\r\ncrypto_shash_update(shash, bctx->opad, bs) ?:\r\ncrypto_shash_finup(shash, req->result, ds, req->result);\r\n}\r\nstatic int omap_sham_finish(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nint err = 0;\r\nif (ctx->digcnt) {\r\nomap_sham_copy_ready_hash(req);\r\nif ((ctx->flags & BIT(FLAGS_HMAC)) &&\r\n!test_bit(FLAGS_AUTO_XOR, &dd->flags))\r\nerr = omap_sham_finish_hmac(req);\r\n}\r\ndev_dbg(dd->dev, "digcnt: %d, bufcnt: %d\n", ctx->digcnt, ctx->bufcnt);\r\nreturn err;\r\n}\r\nstatic void omap_sham_finish_req(struct ahash_request *req, int err)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nif (test_bit(FLAGS_SGS_COPIED, &dd->flags))\r\nfree_pages((unsigned long)sg_virt(ctx->sg),\r\nget_order(ctx->sg->length));\r\nif (test_bit(FLAGS_SGS_ALLOCED, &dd->flags))\r\nkfree(ctx->sg);\r\nctx->sg = NULL;\r\ndd->flags &= ~(BIT(FLAGS_SGS_ALLOCED) | BIT(FLAGS_SGS_COPIED));\r\nif (!err) {\r\ndd->pdata->copy_hash(req, 1);\r\nif (test_bit(FLAGS_FINAL, &dd->flags))\r\nerr = omap_sham_finish(req);\r\n} else {\r\nctx->flags |= BIT(FLAGS_ERROR);\r\n}\r\ndd->flags &= ~(BIT(FLAGS_BUSY) | BIT(FLAGS_FINAL) | BIT(FLAGS_CPU) |\r\nBIT(FLAGS_DMA_READY) | BIT(FLAGS_OUTPUT_READY));\r\npm_runtime_mark_last_busy(dd->dev);\r\npm_runtime_put_autosuspend(dd->dev);\r\nif (req->base.complete)\r\nreq->base.complete(&req->base, err);\r\n}\r\nstatic int omap_sham_handle_queue(struct omap_sham_dev *dd,\r\nstruct ahash_request *req)\r\n{\r\nstruct crypto_async_request *async_req, *backlog;\r\nstruct omap_sham_reqctx *ctx;\r\nunsigned long flags;\r\nint err = 0, ret = 0;\r\nretry:\r\nspin_lock_irqsave(&dd->lock, flags);\r\nif (req)\r\nret = ahash_enqueue_request(&dd->queue, req);\r\nif (test_bit(FLAGS_BUSY, &dd->flags)) {\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nreturn ret;\r\n}\r\nbacklog = crypto_get_backlog(&dd->queue);\r\nasync_req = crypto_dequeue_request(&dd->queue);\r\nif (async_req)\r\nset_bit(FLAGS_BUSY, &dd->flags);\r\nspin_unlock_irqrestore(&dd->lock, flags);\r\nif (!async_req)\r\nreturn ret;\r\nif (backlog)\r\nbacklog->complete(backlog, -EINPROGRESS);\r\nreq = ahash_request_cast(async_req);\r\ndd->req = req;\r\nctx = ahash_request_ctx(req);\r\nerr = omap_sham_prepare_request(req, ctx->op == OP_UPDATE);\r\nif (err)\r\ngoto err1;\r\ndev_dbg(dd->dev, "handling new req, op: %lu, nbytes: %d\n",\r\nctx->op, req->nbytes);\r\nerr = omap_sham_hw_init(dd);\r\nif (err)\r\ngoto err1;\r\nif (ctx->digcnt)\r\ndd->pdata->copy_hash(req, 0);\r\nif (ctx->op == OP_UPDATE) {\r\nerr = omap_sham_update_req(dd);\r\nif (err != -EINPROGRESS && (ctx->flags & BIT(FLAGS_FINUP)))\r\nerr = omap_sham_final_req(dd);\r\n} else if (ctx->op == OP_FINAL) {\r\nerr = omap_sham_final_req(dd);\r\n}\r\nerr1:\r\ndev_dbg(dd->dev, "exit, err: %d\n", err);\r\nif (err != -EINPROGRESS) {\r\nomap_sham_finish_req(req, err);\r\nreq = NULL;\r\ngoto retry;\r\n}\r\nreturn ret;\r\n}\r\nstatic int omap_sham_enqueue(struct ahash_request *req, unsigned int op)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct omap_sham_dev *dd = tctx->dd;\r\nctx->op = op;\r\nreturn omap_sham_handle_queue(dd, req);\r\n}\r\nstatic int omap_sham_update(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nstruct omap_sham_dev *dd = ctx->dd;\r\nif (!req->nbytes)\r\nreturn 0;\r\nif (ctx->total + req->nbytes < ctx->buflen) {\r\nscatterwalk_map_and_copy(ctx->buffer + ctx->bufcnt, req->src,\r\n0, req->nbytes, 0);\r\nctx->bufcnt += req->nbytes;\r\nctx->total += req->nbytes;\r\nreturn 0;\r\n}\r\nif (dd->polling_mode)\r\nctx->flags |= BIT(FLAGS_CPU);\r\nreturn omap_sham_enqueue(req, OP_UPDATE);\r\n}\r\nstatic int omap_sham_shash_digest(struct crypto_shash *tfm, u32 flags,\r\nconst u8 *data, unsigned int len, u8 *out)\r\n{\r\nSHASH_DESC_ON_STACK(shash, tfm);\r\nshash->tfm = tfm;\r\nshash->flags = flags & CRYPTO_TFM_REQ_MAY_SLEEP;\r\nreturn crypto_shash_digest(shash, data, len, out);\r\n}\r\nstatic int omap_sham_final_shash(struct ahash_request *req)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(req->base.tfm);\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint offset = 0;\r\nif (test_bit(FLAGS_HMAC, &ctx->flags) &&\r\n!test_bit(FLAGS_AUTO_XOR, &ctx->dd->flags))\r\noffset = get_block_size(ctx);\r\nreturn omap_sham_shash_digest(tctx->fallback, req->base.flags,\r\nctx->buffer + offset,\r\nctx->bufcnt - offset, req->result);\r\n}\r\nstatic int omap_sham_final(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nctx->flags |= BIT(FLAGS_FINUP);\r\nif (ctx->flags & BIT(FLAGS_ERROR))\r\nreturn 0;\r\nif (!ctx->digcnt && ctx->bufcnt < OMAP_SHA_DMA_THRESHOLD)\r\nreturn omap_sham_final_shash(req);\r\nelse if (ctx->bufcnt)\r\nreturn omap_sham_enqueue(req, OP_FINAL);\r\nreturn omap_sham_finish(req);\r\n}\r\nstatic int omap_sham_finup(struct ahash_request *req)\r\n{\r\nstruct omap_sham_reqctx *ctx = ahash_request_ctx(req);\r\nint err1, err2;\r\nctx->flags |= BIT(FLAGS_FINUP);\r\nerr1 = omap_sham_update(req);\r\nif (err1 == -EINPROGRESS || err1 == -EBUSY)\r\nreturn err1;\r\nerr2 = omap_sham_final(req);\r\nreturn err1 ?: err2;\r\n}\r\nstatic int omap_sham_digest(struct ahash_request *req)\r\n{\r\nreturn omap_sham_init(req) ?: omap_sham_finup(req);\r\n}\r\nstatic int omap_sham_setkey(struct crypto_ahash *tfm, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_ahash_ctx(tfm);\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\nint bs = crypto_shash_blocksize(bctx->shash);\r\nint ds = crypto_shash_digestsize(bctx->shash);\r\nstruct omap_sham_dev *dd = NULL, *tmp;\r\nint err, i;\r\nspin_lock_bh(&sham.lock);\r\nif (!tctx->dd) {\r\nlist_for_each_entry(tmp, &sham.dev_list, list) {\r\ndd = tmp;\r\nbreak;\r\n}\r\ntctx->dd = dd;\r\n} else {\r\ndd = tctx->dd;\r\n}\r\nspin_unlock_bh(&sham.lock);\r\nerr = crypto_shash_setkey(tctx->fallback, key, keylen);\r\nif (err)\r\nreturn err;\r\nif (keylen > bs) {\r\nerr = omap_sham_shash_digest(bctx->shash,\r\ncrypto_shash_get_flags(bctx->shash),\r\nkey, keylen, bctx->ipad);\r\nif (err)\r\nreturn err;\r\nkeylen = ds;\r\n} else {\r\nmemcpy(bctx->ipad, key, keylen);\r\n}\r\nmemset(bctx->ipad + keylen, 0, bs - keylen);\r\nif (!test_bit(FLAGS_AUTO_XOR, &dd->flags)) {\r\nmemcpy(bctx->opad, bctx->ipad, bs);\r\nfor (i = 0; i < bs; i++) {\r\nbctx->ipad[i] ^= 0x36;\r\nbctx->opad[i] ^= 0x5c;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int omap_sham_cra_init_alg(struct crypto_tfm *tfm, const char *alg_base)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(tfm);\r\nconst char *alg_name = crypto_tfm_alg_name(tfm);\r\ntctx->fallback = crypto_alloc_shash(alg_name, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(tctx->fallback)) {\r\npr_err("omap-sham: fallback driver '%s' "\r\n"could not be loaded.\n", alg_name);\r\nreturn PTR_ERR(tctx->fallback);\r\n}\r\ncrypto_ahash_set_reqsize(__crypto_ahash_cast(tfm),\r\nsizeof(struct omap_sham_reqctx) + BUFLEN);\r\nif (alg_base) {\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\ntctx->flags |= BIT(FLAGS_HMAC);\r\nbctx->shash = crypto_alloc_shash(alg_base, 0,\r\nCRYPTO_ALG_NEED_FALLBACK);\r\nif (IS_ERR(bctx->shash)) {\r\npr_err("omap-sham: base driver '%s' "\r\n"could not be loaded.\n", alg_base);\r\ncrypto_free_shash(tctx->fallback);\r\nreturn PTR_ERR(bctx->shash);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int omap_sham_cra_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, NULL);\r\n}\r\nstatic int omap_sham_cra_sha1_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha1");\r\n}\r\nstatic int omap_sham_cra_sha224_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha224");\r\n}\r\nstatic int omap_sham_cra_sha256_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha256");\r\n}\r\nstatic int omap_sham_cra_md5_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "md5");\r\n}\r\nstatic int omap_sham_cra_sha384_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha384");\r\n}\r\nstatic int omap_sham_cra_sha512_init(struct crypto_tfm *tfm)\r\n{\r\nreturn omap_sham_cra_init_alg(tfm, "sha512");\r\n}\r\nstatic void omap_sham_cra_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct omap_sham_ctx *tctx = crypto_tfm_ctx(tfm);\r\ncrypto_free_shash(tctx->fallback);\r\ntctx->fallback = NULL;\r\nif (tctx->flags & BIT(FLAGS_HMAC)) {\r\nstruct omap_sham_hmac_ctx *bctx = tctx->base;\r\ncrypto_free_shash(bctx->shash);\r\n}\r\n}\r\nstatic int omap_sham_export(struct ahash_request *req, void *out)\r\n{\r\nstruct omap_sham_reqctx *rctx = ahash_request_ctx(req);\r\nmemcpy(out, rctx, sizeof(*rctx) + rctx->bufcnt);\r\nreturn 0;\r\n}\r\nstatic int omap_sham_import(struct ahash_request *req, const void *in)\r\n{\r\nstruct omap_sham_reqctx *rctx = ahash_request_ctx(req);\r\nconst struct omap_sham_reqctx *ctx_in = in;\r\nmemcpy(rctx, in, sizeof(*rctx) + ctx_in->bufcnt);\r\nreturn 0;\r\n}\r\nstatic void omap_sham_done_task(unsigned long data)\r\n{\r\nstruct omap_sham_dev *dd = (struct omap_sham_dev *)data;\r\nint err = 0;\r\nif (!test_bit(FLAGS_BUSY, &dd->flags)) {\r\nomap_sham_handle_queue(dd, NULL);\r\nreturn;\r\n}\r\nif (test_bit(FLAGS_CPU, &dd->flags)) {\r\nif (test_and_clear_bit(FLAGS_OUTPUT_READY, &dd->flags))\r\ngoto finish;\r\n} else if (test_bit(FLAGS_DMA_READY, &dd->flags)) {\r\nif (test_and_clear_bit(FLAGS_DMA_ACTIVE, &dd->flags)) {\r\nomap_sham_update_dma_stop(dd);\r\nif (dd->err) {\r\nerr = dd->err;\r\ngoto finish;\r\n}\r\n}\r\nif (test_and_clear_bit(FLAGS_OUTPUT_READY, &dd->flags)) {\r\nclear_bit(FLAGS_DMA_READY, &dd->flags);\r\ngoto finish;\r\n}\r\n}\r\nreturn;\r\nfinish:\r\ndev_dbg(dd->dev, "update done: err: %d\n", err);\r\nomap_sham_finish_req(dd->req, err);\r\nif (!test_bit(FLAGS_BUSY, &dd->flags))\r\nomap_sham_handle_queue(dd, NULL);\r\n}\r\nstatic irqreturn_t omap_sham_irq_common(struct omap_sham_dev *dd)\r\n{\r\nif (!test_bit(FLAGS_BUSY, &dd->flags)) {\r\ndev_warn(dd->dev, "Interrupt when no active requests.\n");\r\n} else {\r\nset_bit(FLAGS_OUTPUT_READY, &dd->flags);\r\ntasklet_schedule(&dd->done_task);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t omap_sham_irq_omap2(int irq, void *dev_id)\r\n{\r\nstruct omap_sham_dev *dd = dev_id;\r\nif (unlikely(test_bit(FLAGS_FINAL, &dd->flags)))\r\nomap_sham_write_mask(dd, SHA_REG_CTRL, 0, SHA_REG_CTRL_LENGTH);\r\nomap_sham_write_mask(dd, SHA_REG_CTRL, SHA_REG_CTRL_OUTPUT_READY,\r\nSHA_REG_CTRL_OUTPUT_READY);\r\nomap_sham_read(dd, SHA_REG_CTRL);\r\nreturn omap_sham_irq_common(dd);\r\n}\r\nstatic irqreturn_t omap_sham_irq_omap4(int irq, void *dev_id)\r\n{\r\nstruct omap_sham_dev *dd = dev_id;\r\nomap_sham_write_mask(dd, SHA_REG_MASK(dd), 0, SHA_REG_MASK_IT_EN);\r\nreturn omap_sham_irq_common(dd);\r\n}\r\nstatic int omap_sham_get_res_of(struct omap_sham_dev *dd,\r\nstruct device *dev, struct resource *res)\r\n{\r\nstruct device_node *node = dev->of_node;\r\nconst struct of_device_id *match;\r\nint err = 0;\r\nmatch = of_match_device(of_match_ptr(omap_sham_of_match), dev);\r\nif (!match) {\r\ndev_err(dev, "no compatible OF match\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\nerr = of_address_to_resource(node, 0, res);\r\nif (err < 0) {\r\ndev_err(dev, "can't translate OF node address\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\ndd->irq = irq_of_parse_and_map(node, 0);\r\nif (!dd->irq) {\r\ndev_err(dev, "can't translate OF irq value\n");\r\nerr = -EINVAL;\r\ngoto err;\r\n}\r\ndd->pdata = match->data;\r\nerr:\r\nreturn err;\r\n}\r\nstatic int omap_sham_get_res_of(struct omap_sham_dev *dd,\r\nstruct device *dev, struct resource *res)\r\n{\r\nreturn -EINVAL;\r\n}\r\nstatic int omap_sham_get_res_pdev(struct omap_sham_dev *dd,\r\nstruct platform_device *pdev, struct resource *res)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *r;\r\nint err = 0;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r) {\r\ndev_err(dev, "no MEM resource info\n");\r\nerr = -ENODEV;\r\ngoto err;\r\n}\r\nmemcpy(res, r, sizeof(*res));\r\ndd->irq = platform_get_irq(pdev, 0);\r\nif (dd->irq < 0) {\r\ndev_err(dev, "no IRQ resource info\n");\r\nerr = dd->irq;\r\ngoto err;\r\n}\r\ndd->pdata = &omap_sham_pdata_omap2;\r\nerr:\r\nreturn err;\r\n}\r\nstatic int omap_sham_probe(struct platform_device *pdev)\r\n{\r\nstruct omap_sham_dev *dd;\r\nstruct device *dev = &pdev->dev;\r\nstruct resource res;\r\ndma_cap_mask_t mask;\r\nint err, i, j;\r\nu32 rev;\r\ndd = devm_kzalloc(dev, sizeof(struct omap_sham_dev), GFP_KERNEL);\r\nif (dd == NULL) {\r\ndev_err(dev, "unable to alloc data struct.\n");\r\nerr = -ENOMEM;\r\ngoto data_err;\r\n}\r\ndd->dev = dev;\r\nplatform_set_drvdata(pdev, dd);\r\nINIT_LIST_HEAD(&dd->list);\r\nspin_lock_init(&dd->lock);\r\ntasklet_init(&dd->done_task, omap_sham_done_task, (unsigned long)dd);\r\ncrypto_init_queue(&dd->queue, OMAP_SHAM_QUEUE_LENGTH);\r\nerr = (dev->of_node) ? omap_sham_get_res_of(dd, dev, &res) :\r\nomap_sham_get_res_pdev(dd, pdev, &res);\r\nif (err)\r\ngoto data_err;\r\ndd->io_base = devm_ioremap_resource(dev, &res);\r\nif (IS_ERR(dd->io_base)) {\r\nerr = PTR_ERR(dd->io_base);\r\ngoto data_err;\r\n}\r\ndd->phys_base = res.start;\r\nerr = devm_request_irq(dev, dd->irq, dd->pdata->intr_hdlr,\r\nIRQF_TRIGGER_NONE, dev_name(dev), dd);\r\nif (err) {\r\ndev_err(dev, "unable to request irq %d, err = %d\n",\r\ndd->irq, err);\r\ngoto data_err;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\ndd->dma_lch = dma_request_chan(dev, "rx");\r\nif (IS_ERR(dd->dma_lch)) {\r\nerr = PTR_ERR(dd->dma_lch);\r\nif (err == -EPROBE_DEFER)\r\ngoto data_err;\r\ndd->polling_mode = 1;\r\ndev_dbg(dev, "using polling mode instead of dma\n");\r\n}\r\ndd->flags |= dd->pdata->flags;\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_autosuspend_delay(dev, DEFAULT_AUTOSUSPEND_DELAY);\r\npm_runtime_enable(dev);\r\npm_runtime_irq_safe(dev);\r\nerr = pm_runtime_get_sync(dev);\r\nif (err < 0) {\r\ndev_err(dev, "failed to get sync: %d\n", err);\r\ngoto err_pm;\r\n}\r\nrev = omap_sham_read(dd, SHA_REG_REV(dd));\r\npm_runtime_put_sync(&pdev->dev);\r\ndev_info(dev, "hw accel on OMAP rev %u.%u\n",\r\n(rev & dd->pdata->major_mask) >> dd->pdata->major_shift,\r\n(rev & dd->pdata->minor_mask) >> dd->pdata->minor_shift);\r\nspin_lock(&sham.lock);\r\nlist_add_tail(&dd->list, &sham.dev_list);\r\nspin_unlock(&sham.lock);\r\nfor (i = 0; i < dd->pdata->algs_info_size; i++) {\r\nfor (j = 0; j < dd->pdata->algs_info[i].size; j++) {\r\nstruct ahash_alg *alg;\r\nalg = &dd->pdata->algs_info[i].algs_list[j];\r\nalg->export = omap_sham_export;\r\nalg->import = omap_sham_import;\r\nalg->halg.statesize = sizeof(struct omap_sham_reqctx) +\r\nBUFLEN;\r\nerr = crypto_register_ahash(alg);\r\nif (err)\r\ngoto err_algs;\r\ndd->pdata->algs_info[i].registered++;\r\n}\r\n}\r\nreturn 0;\r\nerr_algs:\r\nfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\r\nfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\r\ncrypto_unregister_ahash(\r\n&dd->pdata->algs_info[i].algs_list[j]);\r\nerr_pm:\r\npm_runtime_disable(dev);\r\nif (!dd->polling_mode)\r\ndma_release_channel(dd->dma_lch);\r\ndata_err:\r\ndev_err(dev, "initialization failed.\n");\r\nreturn err;\r\n}\r\nstatic int omap_sham_remove(struct platform_device *pdev)\r\n{\r\nstatic struct omap_sham_dev *dd;\r\nint i, j;\r\ndd = platform_get_drvdata(pdev);\r\nif (!dd)\r\nreturn -ENODEV;\r\nspin_lock(&sham.lock);\r\nlist_del(&dd->list);\r\nspin_unlock(&sham.lock);\r\nfor (i = dd->pdata->algs_info_size - 1; i >= 0; i--)\r\nfor (j = dd->pdata->algs_info[i].registered - 1; j >= 0; j--)\r\ncrypto_unregister_ahash(\r\n&dd->pdata->algs_info[i].algs_list[j]);\r\ntasklet_kill(&dd->done_task);\r\npm_runtime_disable(&pdev->dev);\r\nif (!dd->polling_mode)\r\ndma_release_channel(dd->dma_lch);\r\nreturn 0;\r\n}\r\nstatic int omap_sham_suspend(struct device *dev)\r\n{\r\npm_runtime_put_sync(dev);\r\nreturn 0;\r\n}\r\nstatic int omap_sham_resume(struct device *dev)\r\n{\r\nint err = pm_runtime_get_sync(dev);\r\nif (err < 0) {\r\ndev_err(dev, "failed to get sync: %d\n", err);\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
