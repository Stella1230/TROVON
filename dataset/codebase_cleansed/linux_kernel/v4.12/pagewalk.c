static int walk_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\npte_t *pte;\r\nint err = 0;\r\npte = pte_offset_map(pmd, addr);\r\nfor (;;) {\r\nerr = walk->pte_entry(pte, addr, addr + PAGE_SIZE, walk);\r\nif (err)\r\nbreak;\r\naddr += PAGE_SIZE;\r\nif (addr == end)\r\nbreak;\r\npte++;\r\n}\r\npte_unmap(pte);\r\nreturn err;\r\n}\r\nstatic int walk_pmd_range(pud_t *pud, unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\npmd_t *pmd;\r\nunsigned long next;\r\nint err = 0;\r\npmd = pmd_offset(pud, addr);\r\ndo {\r\nagain:\r\nnext = pmd_addr_end(addr, end);\r\nif (pmd_none(*pmd) || !walk->vma) {\r\nif (walk->pte_hole)\r\nerr = walk->pte_hole(addr, next, walk);\r\nif (err)\r\nbreak;\r\ncontinue;\r\n}\r\nif (walk->pmd_entry)\r\nerr = walk->pmd_entry(pmd, addr, next, walk);\r\nif (err)\r\nbreak;\r\nif (!walk->pte_entry)\r\ncontinue;\r\nsplit_huge_pmd(walk->vma, pmd, addr);\r\nif (pmd_trans_unstable(pmd))\r\ngoto again;\r\nerr = walk_pte_range(pmd, addr, next, walk);\r\nif (err)\r\nbreak;\r\n} while (pmd++, addr = next, addr != end);\r\nreturn err;\r\n}\r\nstatic int walk_pud_range(p4d_t *p4d, unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\npud_t *pud;\r\nunsigned long next;\r\nint err = 0;\r\npud = pud_offset(p4d, addr);\r\ndo {\r\nagain:\r\nnext = pud_addr_end(addr, end);\r\nif (pud_none(*pud) || !walk->vma) {\r\nif (walk->pte_hole)\r\nerr = walk->pte_hole(addr, next, walk);\r\nif (err)\r\nbreak;\r\ncontinue;\r\n}\r\nif (walk->pud_entry) {\r\nspinlock_t *ptl = pud_trans_huge_lock(pud, walk->vma);\r\nif (ptl) {\r\nerr = walk->pud_entry(pud, addr, next, walk);\r\nspin_unlock(ptl);\r\nif (err)\r\nbreak;\r\ncontinue;\r\n}\r\n}\r\nsplit_huge_pud(walk->vma, pud, addr);\r\nif (pud_none(*pud))\r\ngoto again;\r\nif (walk->pmd_entry || walk->pte_entry)\r\nerr = walk_pmd_range(pud, addr, next, walk);\r\nif (err)\r\nbreak;\r\n} while (pud++, addr = next, addr != end);\r\nreturn err;\r\n}\r\nstatic int walk_p4d_range(pgd_t *pgd, unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\np4d_t *p4d;\r\nunsigned long next;\r\nint err = 0;\r\np4d = p4d_offset(pgd, addr);\r\ndo {\r\nnext = p4d_addr_end(addr, end);\r\nif (p4d_none_or_clear_bad(p4d)) {\r\nif (walk->pte_hole)\r\nerr = walk->pte_hole(addr, next, walk);\r\nif (err)\r\nbreak;\r\ncontinue;\r\n}\r\nif (walk->pmd_entry || walk->pte_entry)\r\nerr = walk_pud_range(p4d, addr, next, walk);\r\nif (err)\r\nbreak;\r\n} while (p4d++, addr = next, addr != end);\r\nreturn err;\r\n}\r\nstatic int walk_pgd_range(unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\npgd_t *pgd;\r\nunsigned long next;\r\nint err = 0;\r\npgd = pgd_offset(walk->mm, addr);\r\ndo {\r\nnext = pgd_addr_end(addr, end);\r\nif (pgd_none_or_clear_bad(pgd)) {\r\nif (walk->pte_hole)\r\nerr = walk->pte_hole(addr, next, walk);\r\nif (err)\r\nbreak;\r\ncontinue;\r\n}\r\nif (walk->pmd_entry || walk->pte_entry)\r\nerr = walk_p4d_range(pgd, addr, next, walk);\r\nif (err)\r\nbreak;\r\n} while (pgd++, addr = next, addr != end);\r\nreturn err;\r\n}\r\nstatic unsigned long hugetlb_entry_end(struct hstate *h, unsigned long addr,\r\nunsigned long end)\r\n{\r\nunsigned long boundary = (addr & huge_page_mask(h)) + huge_page_size(h);\r\nreturn boundary < end ? boundary : end;\r\n}\r\nstatic int walk_hugetlb_range(unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\nstruct vm_area_struct *vma = walk->vma;\r\nstruct hstate *h = hstate_vma(vma);\r\nunsigned long next;\r\nunsigned long hmask = huge_page_mask(h);\r\npte_t *pte;\r\nint err = 0;\r\ndo {\r\nnext = hugetlb_entry_end(h, addr, end);\r\npte = huge_pte_offset(walk->mm, addr & hmask);\r\nif (pte && walk->hugetlb_entry)\r\nerr = walk->hugetlb_entry(pte, hmask, addr, next, walk);\r\nif (err)\r\nbreak;\r\n} while (addr = next, addr != end);\r\nreturn err;\r\n}\r\nstatic int walk_hugetlb_range(unsigned long addr, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\nreturn 0;\r\n}\r\nstatic int walk_page_test(unsigned long start, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\nstruct vm_area_struct *vma = walk->vma;\r\nif (walk->test_walk)\r\nreturn walk->test_walk(start, end, walk);\r\nif (vma->vm_flags & VM_PFNMAP) {\r\nint err = 1;\r\nif (walk->pte_hole)\r\nerr = walk->pte_hole(start, end, walk);\r\nreturn err ? err : 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int __walk_page_range(unsigned long start, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\nint err = 0;\r\nstruct vm_area_struct *vma = walk->vma;\r\nif (vma && is_vm_hugetlb_page(vma)) {\r\nif (walk->hugetlb_entry)\r\nerr = walk_hugetlb_range(start, end, walk);\r\n} else\r\nerr = walk_pgd_range(start, end, walk);\r\nreturn err;\r\n}\r\nint walk_page_range(unsigned long start, unsigned long end,\r\nstruct mm_walk *walk)\r\n{\r\nint err = 0;\r\nunsigned long next;\r\nstruct vm_area_struct *vma;\r\nif (start >= end)\r\nreturn -EINVAL;\r\nif (!walk->mm)\r\nreturn -EINVAL;\r\nVM_BUG_ON_MM(!rwsem_is_locked(&walk->mm->mmap_sem), walk->mm);\r\nvma = find_vma(walk->mm, start);\r\ndo {\r\nif (!vma) {\r\nwalk->vma = NULL;\r\nnext = end;\r\n} else if (start < vma->vm_start) {\r\nwalk->vma = NULL;\r\nnext = min(end, vma->vm_start);\r\n} else {\r\nwalk->vma = vma;\r\nnext = min(end, vma->vm_end);\r\nvma = vma->vm_next;\r\nerr = walk_page_test(start, next, walk);\r\nif (err > 0) {\r\nerr = 0;\r\ncontinue;\r\n}\r\nif (err < 0)\r\nbreak;\r\n}\r\nif (walk->vma || walk->pte_hole)\r\nerr = __walk_page_range(start, next, walk);\r\nif (err)\r\nbreak;\r\n} while (start = next, start < end);\r\nreturn err;\r\n}\r\nint walk_page_vma(struct vm_area_struct *vma, struct mm_walk *walk)\r\n{\r\nint err;\r\nif (!walk->mm)\r\nreturn -EINVAL;\r\nVM_BUG_ON(!rwsem_is_locked(&walk->mm->mmap_sem));\r\nVM_BUG_ON(!vma);\r\nwalk->vma = vma;\r\nerr = walk_page_test(vma->vm_start, vma->vm_end, walk);\r\nif (err > 0)\r\nreturn 0;\r\nif (err < 0)\r\nreturn err;\r\nreturn __walk_page_range(vma->vm_start, vma->vm_end, walk);\r\n}
