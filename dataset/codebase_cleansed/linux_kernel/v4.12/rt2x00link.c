static inline int rt2x00link_get_avg_rssi(struct ewma_rssi *ewma)\r\n{\r\nunsigned long avg;\r\navg = ewma_rssi_read(ewma);\r\nif (avg)\r\nreturn -avg;\r\nreturn DEFAULT_RSSI;\r\n}\r\nstatic int rt2x00link_antenna_get_link_rssi(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nif (rt2x00dev->link.qual.rx_success)\r\nreturn rt2x00link_get_avg_rssi(&ant->rssi_ant);\r\nreturn DEFAULT_RSSI;\r\n}\r\nstatic int rt2x00link_antenna_get_rssi_history(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nif (ant->rssi_history)\r\nreturn ant->rssi_history;\r\nreturn DEFAULT_RSSI;\r\n}\r\nstatic void rt2x00link_antenna_update_rssi_history(struct rt2x00_dev *rt2x00dev,\r\nint rssi)\r\n{\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nant->rssi_history = rssi;\r\n}\r\nstatic void rt2x00link_antenna_reset(struct rt2x00_dev *rt2x00dev)\r\n{\r\newma_rssi_init(&rt2x00dev->link.ant.rssi_ant);\r\n}\r\nstatic void rt2x00lib_antenna_diversity_sample(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nstruct antenna_setup new_ant;\r\nint other_antenna;\r\nint sample_current = rt2x00link_antenna_get_link_rssi(rt2x00dev);\r\nint sample_other = rt2x00link_antenna_get_rssi_history(rt2x00dev);\r\nmemcpy(&new_ant, &ant->active, sizeof(new_ant));\r\nant->flags &= ~ANTENNA_MODE_SAMPLE;\r\nif (sample_current >= sample_other) {\r\nrt2x00link_antenna_update_rssi_history(rt2x00dev,\r\nsample_current);\r\nreturn;\r\n}\r\nother_antenna = (ant->active.rx == ANTENNA_A) ? ANTENNA_B : ANTENNA_A;\r\nif (ant->flags & ANTENNA_RX_DIVERSITY)\r\nnew_ant.rx = other_antenna;\r\nif (ant->flags & ANTENNA_TX_DIVERSITY)\r\nnew_ant.tx = other_antenna;\r\nrt2x00lib_config_antenna(rt2x00dev, new_ant);\r\n}\r\nstatic void rt2x00lib_antenna_diversity_eval(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nstruct antenna_setup new_ant;\r\nint rssi_curr;\r\nint rssi_old;\r\nmemcpy(&new_ant, &ant->active, sizeof(new_ant));\r\nrssi_curr = rt2x00link_antenna_get_link_rssi(rt2x00dev);\r\nrssi_old = rt2x00link_antenna_get_rssi_history(rt2x00dev);\r\nrt2x00link_antenna_update_rssi_history(rt2x00dev, rssi_curr);\r\nif (abs(rssi_curr - rssi_old) < 5)\r\nreturn;\r\nant->flags |= ANTENNA_MODE_SAMPLE;\r\nif (ant->flags & ANTENNA_RX_DIVERSITY)\r\nnew_ant.rx = (new_ant.rx == ANTENNA_A) ? ANTENNA_B : ANTENNA_A;\r\nif (ant->flags & ANTENNA_TX_DIVERSITY)\r\nnew_ant.tx = (new_ant.tx == ANTENNA_A) ? ANTENNA_B : ANTENNA_A;\r\nrt2x00lib_config_antenna(rt2x00dev, new_ant);\r\n}\r\nstatic bool rt2x00lib_antenna_diversity(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nif (!(ant->flags & ANTENNA_RX_DIVERSITY) &&\r\n!(ant->flags & ANTENNA_TX_DIVERSITY)) {\r\nant->flags = 0;\r\nreturn true;\r\n}\r\nif (ant->flags & ANTENNA_MODE_SAMPLE) {\r\nrt2x00lib_antenna_diversity_sample(rt2x00dev);\r\nreturn true;\r\n} else if (rt2x00dev->link.count & 1) {\r\nrt2x00lib_antenna_diversity_eval(rt2x00dev);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid rt2x00link_update_stats(struct rt2x00_dev *rt2x00dev,\r\nstruct sk_buff *skb,\r\nstruct rxdone_entry_desc *rxdesc)\r\n{\r\nstruct link *link = &rt2x00dev->link;\r\nstruct link_qual *qual = &rt2x00dev->link.qual;\r\nstruct link_ant *ant = &rt2x00dev->link.ant;\r\nstruct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;\r\nif (!rt2x00dev->intf_sta_count)\r\nreturn;\r\nqual->rx_success++;\r\nif (!ieee80211_is_beacon(hdr->frame_control) ||\r\n!(rxdesc->dev_flags & RXDONE_MY_BSS))\r\nreturn;\r\newma_rssi_add(&link->avg_rssi, -rxdesc->rssi);\r\newma_rssi_add(&ant->rssi_ant, -rxdesc->rssi);\r\n}\r\nvoid rt2x00link_start_tuner(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link *link = &rt2x00dev->link;\r\nif (!rt2x00dev->intf_ap_count && !rt2x00dev->intf_sta_count)\r\nreturn;\r\nif (test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))\r\nreturn;\r\nrt2x00link_reset_tuner(rt2x00dev, false);\r\nif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nieee80211_queue_delayed_work(rt2x00dev->hw,\r\n&link->work, LINK_TUNE_INTERVAL);\r\n}\r\nvoid rt2x00link_stop_tuner(struct rt2x00_dev *rt2x00dev)\r\n{\r\ncancel_delayed_work_sync(&rt2x00dev->link.work);\r\n}\r\nvoid rt2x00link_reset_tuner(struct rt2x00_dev *rt2x00dev, bool antenna)\r\n{\r\nstruct link_qual *qual = &rt2x00dev->link.qual;\r\nu8 vgc_level = qual->vgc_level_reg;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn;\r\nrt2x00dev->link.count = 0;\r\nmemset(qual, 0, sizeof(*qual));\r\newma_rssi_init(&rt2x00dev->link.avg_rssi);\r\nqual->vgc_level_reg = vgc_level;\r\nrt2x00dev->ops->lib->reset_tuner(rt2x00dev, qual);\r\nif (antenna)\r\nrt2x00link_antenna_reset(rt2x00dev);\r\n}\r\nstatic void rt2x00link_reset_qual(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link_qual *qual = &rt2x00dev->link.qual;\r\nqual->rx_success = 0;\r\nqual->rx_failed = 0;\r\nqual->tx_success = 0;\r\nqual->tx_failed = 0;\r\n}\r\nstatic void rt2x00link_tuner_sta(struct rt2x00_dev *rt2x00dev, struct link *link)\r\n{\r\nstruct link_qual *qual = &rt2x00dev->link.qual;\r\nrt2x00dev->ops->lib->link_stats(rt2x00dev, qual);\r\nrt2x00dev->low_level_stats.dot11FCSErrorCount += qual->rx_failed;\r\nif (!qual->rx_success)\r\nqual->rssi = DEFAULT_RSSI;\r\nelse\r\nqual->rssi = rt2x00link_get_avg_rssi(&link->avg_rssi);\r\nif (rt2x00_has_cap_link_tuning(rt2x00dev))\r\nrt2x00dev->ops->lib->link_tuner(rt2x00dev, qual, link->count);\r\nrt2x00leds_led_quality(rt2x00dev, qual->rssi);\r\nif (rt2x00lib_antenna_diversity(rt2x00dev))\r\nrt2x00link_reset_qual(rt2x00dev);\r\n}\r\nstatic void rt2x00link_tuner(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, link.work.work);\r\nstruct link *link = &rt2x00dev->link;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags) ||\r\ntest_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))\r\nreturn;\r\nmutex_lock(&rt2x00dev->conf_mutex);\r\nif (rt2x00dev->intf_sta_count)\r\nrt2x00link_tuner_sta(rt2x00dev, link);\r\nif (rt2x00dev->ops->lib->gain_calibration &&\r\n(link->count % (AGC_SECONDS / LINK_TUNE_SECONDS)) == 0)\r\nrt2x00dev->ops->lib->gain_calibration(rt2x00dev);\r\nif (rt2x00dev->ops->lib->vco_calibration &&\r\nrt2x00_has_cap_vco_recalibration(rt2x00dev) &&\r\n(link->count % (VCO_SECONDS / LINK_TUNE_SECONDS)) == 0)\r\nrt2x00dev->ops->lib->vco_calibration(rt2x00dev);\r\nmutex_unlock(&rt2x00dev->conf_mutex);\r\nlink->count++;\r\nif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nieee80211_queue_delayed_work(rt2x00dev->hw,\r\n&link->work, LINK_TUNE_INTERVAL);\r\n}\r\nvoid rt2x00link_start_watchdog(struct rt2x00_dev *rt2x00dev)\r\n{\r\nstruct link *link = &rt2x00dev->link;\r\nif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags) &&\r\nrt2x00dev->ops->lib->watchdog)\r\nieee80211_queue_delayed_work(rt2x00dev->hw,\r\n&link->watchdog_work,\r\nWATCHDOG_INTERVAL);\r\n}\r\nvoid rt2x00link_stop_watchdog(struct rt2x00_dev *rt2x00dev)\r\n{\r\ncancel_delayed_work_sync(&rt2x00dev->link.watchdog_work);\r\n}\r\nstatic void rt2x00link_watchdog(struct work_struct *work)\r\n{\r\nstruct rt2x00_dev *rt2x00dev =\r\ncontainer_of(work, struct rt2x00_dev, link.watchdog_work.work);\r\nstruct link *link = &rt2x00dev->link;\r\nif (!test_bit(DEVICE_STATE_ENABLED_RADIO, &rt2x00dev->flags))\r\nreturn;\r\nrt2x00dev->ops->lib->watchdog(rt2x00dev);\r\nif (test_bit(DEVICE_STATE_PRESENT, &rt2x00dev->flags))\r\nieee80211_queue_delayed_work(rt2x00dev->hw,\r\n&link->watchdog_work,\r\nWATCHDOG_INTERVAL);\r\n}\r\nvoid rt2x00link_register(struct rt2x00_dev *rt2x00dev)\r\n{\r\nINIT_DELAYED_WORK(&rt2x00dev->link.watchdog_work, rt2x00link_watchdog);\r\nINIT_DELAYED_WORK(&rt2x00dev->link.work, rt2x00link_tuner);\r\n}
