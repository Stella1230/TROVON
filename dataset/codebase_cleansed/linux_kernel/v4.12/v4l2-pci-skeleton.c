static inline struct skel_buffer *to_skel_buffer(struct vb2_buffer *vb2)\r\n{\r\nreturn container_of(vb2, struct skel_buffer, vb);\r\n}\r\nstatic irqreturn_t skeleton_irq(int irq, void *dev_id)\r\n{\r\n#ifdef TODO\r\nstruct skeleton *skel = dev_id;\r\nif (captured_new_frame) {\r\n...\r\nspin_lock(&skel->qlock);\r\nlist_del(&new_buf->list);\r\nspin_unlock(&skel->qlock);\r\nv4l2_get_timestamp(&new_buf->vb.v4l2_buf.timestamp);\r\nnew_buf->vb.v4l2_buf.sequence = skel->sequence++;\r\nnew_buf->vb.v4l2_buf.field = skel->field;\r\nif (skel->format.field == V4L2_FIELD_ALTERNATE) {\r\nif (skel->field == V4L2_FIELD_BOTTOM)\r\nskel->field = V4L2_FIELD_TOP;\r\nelse if (skel->field == V4L2_FIELD_TOP)\r\nskel->field = V4L2_FIELD_BOTTOM;\r\n}\r\nvb2_buffer_done(&new_buf->vb, VB2_BUF_STATE_DONE);\r\n}\r\n#endif\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int queue_setup(struct vb2_queue *vq,\r\nunsigned int *nbuffers, unsigned int *nplanes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct skeleton *skel = vb2_get_drv_priv(vq);\r\nskel->field = skel->format.field;\r\nif (skel->field == V4L2_FIELD_ALTERNATE) {\r\nif (vb2_fileio_is_active(vq))\r\nreturn -EINVAL;\r\nskel->field = V4L2_FIELD_TOP;\r\n}\r\nif (vq->num_buffers + *nbuffers < 3)\r\n*nbuffers = 3 - vq->num_buffers;\r\nif (*nplanes)\r\nreturn sizes[0] < skel->format.sizeimage ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = skel->format.sizeimage;\r\nreturn 0;\r\n}\r\nstatic int buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct skeleton *skel = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size = skel->format.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\ndev_err(&skel->pdev->dev, "buffer too small (%lu < %lu)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic void buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct skeleton *skel = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct skel_buffer *buf = to_skel_buffer(vb);\r\nunsigned long flags;\r\nspin_lock_irqsave(&skel->qlock, flags);\r\nlist_add_tail(&buf->list, &skel->buf_list);\r\nspin_unlock_irqrestore(&skel->qlock, flags);\r\n}\r\nstatic void return_all_buffers(struct skeleton *skel,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct skel_buffer *buf, *node;\r\nunsigned long flags;\r\nspin_lock_irqsave(&skel->qlock, flags);\r\nlist_for_each_entry_safe(buf, node, &skel->buf_list, list) {\r\nvb2_buffer_done(&buf->vb, state);\r\nlist_del(&buf->list);\r\n}\r\nspin_unlock_irqrestore(&skel->qlock, flags);\r\n}\r\nstatic int start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct skeleton *skel = vb2_get_drv_priv(vq);\r\nint ret = 0;\r\nskel->sequence = 0;\r\nif (ret) {\r\nreturn_all_buffers(skel, VB2_BUF_STATE_QUEUED);\r\n}\r\nreturn ret;\r\n}\r\nstatic void stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct skeleton *skel = vb2_get_drv_priv(vq);\r\nreturn_all_buffers(skel, VB2_BUF_STATE_ERROR);\r\n}\r\nstatic int skeleton_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nstrlcpy(cap->driver, KBUILD_MODNAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, "V4L2 PCI Skeleton", sizeof(cap->card));\r\nsnprintf(cap->bus_info, sizeof(cap->bus_info), "PCI:%s",\r\npci_name(skel->pdev));\r\nreturn 0;\r\n}\r\nstatic void skeleton_fill_pix_format(struct skeleton *skel,\r\nstruct v4l2_pix_format *pix)\r\n{\r\npix->pixelformat = V4L2_PIX_FMT_YUYV;\r\nif (skel->input == 0) {\r\npix->width = 720;\r\npix->height = (skel->std & V4L2_STD_525_60) ? 480 : 576;\r\npix->field = V4L2_FIELD_INTERLACED;\r\npix->colorspace = V4L2_COLORSPACE_SMPTE170M;\r\n} else {\r\npix->width = skel->timings.bt.width;\r\npix->height = skel->timings.bt.height;\r\nif (skel->timings.bt.interlaced) {\r\npix->field = V4L2_FIELD_ALTERNATE;\r\npix->height /= 2;\r\n} else {\r\npix->field = V4L2_FIELD_NONE;\r\n}\r\npix->colorspace = V4L2_COLORSPACE_REC709;\r\n}\r\npix->bytesperline = pix->width * 2;\r\npix->sizeimage = pix->bytesperline * pix->height;\r\npix->priv = 0;\r\n}\r\nstatic int skeleton_try_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nstruct v4l2_pix_format *pix = &f->fmt.pix;\r\nif (pix->pixelformat != V4L2_PIX_FMT_YUYV)\r\nreturn -EINVAL;\r\nskeleton_fill_pix_format(skel, pix);\r\nreturn 0;\r\n}\r\nstatic int skeleton_s_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nint ret;\r\nret = skeleton_try_fmt_vid_cap(file, priv, f);\r\nif (ret)\r\nreturn ret;\r\nif (vb2_is_busy(&skel->queue))\r\nreturn -EBUSY;\r\nskel->format = f->fmt.pix;\r\nreturn 0;\r\n}\r\nstatic int skeleton_g_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_format *f)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nf->fmt.pix = skel->format;\r\nreturn 0;\r\n}\r\nstatic int skeleton_enum_fmt_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nif (f->index != 0)\r\nreturn -EINVAL;\r\nf->pixelformat = V4L2_PIX_FMT_YUYV;\r\nreturn 0;\r\n}\r\nstatic int skeleton_s_std(struct file *file, void *priv, v4l2_std_id std)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input)\r\nreturn -ENODATA;\r\nif (std == skel->std)\r\nreturn 0;\r\nif (vb2_is_busy(&skel->queue))\r\nreturn -EBUSY;\r\nskel->std = std;\r\nskeleton_fill_pix_format(skel, &skel->format);\r\nreturn 0;\r\n}\r\nstatic int skeleton_g_std(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input)\r\nreturn -ENODATA;\r\n*std = skel->std;\r\nreturn 0;\r\n}\r\nstatic int skeleton_querystd(struct file *file, void *priv, v4l2_std_id *std)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input)\r\nreturn -ENODATA;\r\n#ifdef TODO\r\nget_signal_info();\r\nif (no_signal) {\r\n*std = 0;\r\nreturn 0;\r\n}\r\nif (signal_has_525_lines)\r\n*std &= V4L2_STD_525_60;\r\nelse\r\n*std &= V4L2_STD_625_50;\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int skeleton_s_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input == 0)\r\nreturn -ENODATA;\r\nif (!v4l2_valid_dv_timings(timings, &skel_timings_cap, NULL, NULL))\r\nreturn -EINVAL;\r\nif (!v4l2_find_dv_timings_cap(timings, &skel_timings_cap,\r\n0, NULL, NULL))\r\nreturn -EINVAL;\r\nif (v4l2_match_dv_timings(timings, &skel->timings, 0, false))\r\nreturn 0;\r\nif (vb2_is_busy(&skel->queue))\r\nreturn -EBUSY;\r\nskel->timings = *timings;\r\nskeleton_fill_pix_format(skel, &skel->format);\r\nreturn 0;\r\n}\r\nstatic int skeleton_g_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input == 0)\r\nreturn -ENODATA;\r\n*timings = skel->timings;\r\nreturn 0;\r\n}\r\nstatic int skeleton_enum_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_enum_dv_timings *timings)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input == 0)\r\nreturn -ENODATA;\r\nreturn v4l2_enum_dv_timings_cap(timings, &skel_timings_cap,\r\nNULL, NULL);\r\n}\r\nstatic int skeleton_query_dv_timings(struct file *file, void *_fh,\r\nstruct v4l2_dv_timings *timings)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input == 0)\r\nreturn -ENODATA;\r\n#ifdef TODO\r\ndetect_timings();\r\nif (no_signal)\r\nreturn -ENOLINK;\r\nif (cannot_lock_to_signal)\r\nreturn -ENOLCK;\r\nif (signal_out_of_range_of_capabilities)\r\nreturn -ERANGE;\r\nv4l2_print_dv_timings(skel->v4l2_dev.name, "query_dv_timings:",\r\ntimings, true);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int skeleton_dv_timings_cap(struct file *file, void *fh,\r\nstruct v4l2_dv_timings_cap *cap)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (skel->input == 0)\r\nreturn -ENODATA;\r\n*cap = skel_timings_cap;\r\nreturn 0;\r\n}\r\nstatic int skeleton_enum_input(struct file *file, void *priv,\r\nstruct v4l2_input *i)\r\n{\r\nif (i->index > 1)\r\nreturn -EINVAL;\r\ni->type = V4L2_INPUT_TYPE_CAMERA;\r\nif (i->index == 0) {\r\ni->std = SKEL_TVNORMS;\r\nstrlcpy(i->name, "S-Video", sizeof(i->name));\r\ni->capabilities = V4L2_IN_CAP_STD;\r\n} else {\r\ni->std = 0;\r\nstrlcpy(i->name, "HDMI", sizeof(i->name));\r\ni->capabilities = V4L2_IN_CAP_DV_TIMINGS;\r\n}\r\nreturn 0;\r\n}\r\nstatic int skeleton_s_input(struct file *file, void *priv, unsigned int i)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\nif (i > 1)\r\nreturn -EINVAL;\r\nif (vb2_is_busy(&skel->queue))\r\nreturn -EBUSY;\r\nskel->input = i;\r\nskel->vdev.tvnorms = i ? 0 : SKEL_TVNORMS;\r\nskeleton_fill_pix_format(skel, &skel->format);\r\nreturn 0;\r\n}\r\nstatic int skeleton_g_input(struct file *file, void *priv, unsigned int *i)\r\n{\r\nstruct skeleton *skel = video_drvdata(file);\r\n*i = skel->input;\r\nreturn 0;\r\n}\r\nstatic int skeleton_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nbreak;\r\ncase V4L2_CID_CONTRAST:\r\nbreak;\r\ncase V4L2_CID_SATURATION:\r\nbreak;\r\ncase V4L2_CID_HUE:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int skeleton_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\r\n{\r\nstatic const struct v4l2_dv_timings timings_def =\r\nV4L2_DV_BT_CEA_1280X720P60;\r\nstruct skeleton *skel;\r\nstruct video_device *vdev;\r\nstruct v4l2_ctrl_handler *hdl;\r\nstruct vb2_queue *q;\r\nint ret;\r\nret = pci_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(&pdev->dev, "no suitable DMA available.\n");\r\ngoto disable_pci;\r\n}\r\nskel = devm_kzalloc(&pdev->dev, sizeof(struct skeleton), GFP_KERNEL);\r\nif (!skel)\r\nreturn -ENOMEM;\r\nret = devm_request_irq(&pdev->dev, pdev->irq,\r\nskeleton_irq, 0, KBUILD_MODNAME, skel);\r\nif (ret) {\r\ndev_err(&pdev->dev, "request_irq failed\n");\r\ngoto disable_pci;\r\n}\r\nskel->pdev = pdev;\r\nskel->timings = timings_def;\r\nskel->std = V4L2_STD_625_50;\r\nskeleton_fill_pix_format(skel, &skel->format);\r\nret = v4l2_device_register(&pdev->dev, &skel->v4l2_dev);\r\nif (ret)\r\ngoto disable_pci;\r\nmutex_init(&skel->lock);\r\nhdl = &skel->ctrl_handler;\r\nv4l2_ctrl_handler_init(hdl, 4);\r\nv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\r\nV4L2_CID_BRIGHTNESS, 0, 255, 1, 127);\r\nv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\r\nV4L2_CID_CONTRAST, 0, 255, 1, 16);\r\nv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\r\nV4L2_CID_SATURATION, 0, 255, 1, 127);\r\nv4l2_ctrl_new_std(hdl, &skel_ctrl_ops,\r\nV4L2_CID_HUE, -128, 127, 1, 0);\r\nif (hdl->error) {\r\nret = hdl->error;\r\ngoto free_hdl;\r\n}\r\nskel->v4l2_dev.ctrl_handler = hdl;\r\nq = &skel->queue;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_DMABUF | VB2_READ;\r\nq->dev = &pdev->dev;\r\nq->drv_priv = skel;\r\nq->buf_struct_size = sizeof(struct skel_buffer);\r\nq->ops = &skel_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->lock = &skel->lock;\r\nq->gfp_flags = GFP_DMA32;\r\nret = vb2_queue_init(q);\r\nif (ret)\r\ngoto free_hdl;\r\nINIT_LIST_HEAD(&skel->buf_list);\r\nspin_lock_init(&skel->qlock);\r\nvdev = &skel->vdev;\r\nstrlcpy(vdev->name, KBUILD_MODNAME, sizeof(vdev->name));\r\nvdev->release = video_device_release_empty;\r\nvdev->fops = &skel_fops,\r\nvdev->ioctl_ops = &skel_ioctl_ops,\r\nvdev->device_caps = V4L2_CAP_VIDEO_CAPTURE | V4L2_CAP_READWRITE |\r\nV4L2_CAP_STREAMING;\r\nvdev->lock = &skel->lock;\r\nvdev->queue = q;\r\nvdev->v4l2_dev = &skel->v4l2_dev;\r\nvdev->tvnorms = SKEL_TVNORMS;\r\nvideo_set_drvdata(vdev, skel);\r\nret = video_register_device(vdev, VFL_TYPE_GRABBER, -1);\r\nif (ret)\r\ngoto free_hdl;\r\ndev_info(&pdev->dev, "V4L2 PCI Skeleton Driver loaded\n");\r\nreturn 0;\r\nfree_hdl:\r\nv4l2_ctrl_handler_free(&skel->ctrl_handler);\r\nv4l2_device_unregister(&skel->v4l2_dev);\r\ndisable_pci:\r\npci_disable_device(pdev);\r\nreturn ret;\r\n}\r\nstatic void skeleton_remove(struct pci_dev *pdev)\r\n{\r\nstruct v4l2_device *v4l2_dev = pci_get_drvdata(pdev);\r\nstruct skeleton *skel = container_of(v4l2_dev, struct skeleton, v4l2_dev);\r\nvideo_unregister_device(&skel->vdev);\r\nv4l2_ctrl_handler_free(&skel->ctrl_handler);\r\nv4l2_device_unregister(&skel->v4l2_dev);\r\npci_disable_device(skel->pdev);\r\n}
