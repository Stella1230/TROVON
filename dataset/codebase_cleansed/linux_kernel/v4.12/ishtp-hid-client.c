static void report_bad_packet(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\r\nsize_t cur_pos, size_t payload_len)\r\n{\r\nstruct hostif_msg *recv_msg = recv_buf;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\ndev_err(&client_data->cl_device->dev, "[hid-ish]: BAD packet %02X\n"\r\n"total_bad=%u cur_pos=%u\n"\r\n"[%02X %02X %02X %02X]\n"\r\n"payload_len=%u\n"\r\n"multi_packet_cnt=%u\n"\r\n"is_response=%02X\n",\r\nrecv_msg->hdr.command, client_data->bad_recv_cnt,\r\n(unsigned int)cur_pos,\r\n((unsigned char *)recv_msg)[0], ((unsigned char *)recv_msg)[1],\r\n((unsigned char *)recv_msg)[2], ((unsigned char *)recv_msg)[3],\r\n(unsigned int)payload_len, client_data->multi_packet_cnt,\r\nrecv_msg->hdr.command & ~CMD_MASK);\r\n}\r\nstatic void process_recv(struct ishtp_cl *hid_ishtp_cl, void *recv_buf,\r\nsize_t data_len)\r\n{\r\nstruct hostif_msg *recv_msg;\r\nunsigned char *payload;\r\nstruct device_info *dev_info;\r\nint i, j;\r\nsize_t payload_len, total_len, cur_pos;\r\nint report_type;\r\nstruct report_list *reports_list;\r\nchar *reports;\r\nsize_t report_len;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nint curr_hid_dev = client_data->cur_hid_dev;\r\nif (data_len < sizeof(struct hostif_msg_hdr)) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: error, received %u which is less than data header %u\n",\r\n(unsigned int)data_len,\r\n(unsigned int)sizeof(struct hostif_msg_hdr));\r\n++client_data->bad_recv_cnt;\r\nish_hw_reset(hid_ishtp_cl->dev);\r\nreturn;\r\n}\r\npayload = recv_buf + sizeof(struct hostif_msg_hdr);\r\ntotal_len = data_len;\r\ncur_pos = 0;\r\ndo {\r\nrecv_msg = (struct hostif_msg *)(recv_buf + cur_pos);\r\npayload_len = recv_msg->hdr.size;\r\nif (cur_pos + payload_len + sizeof(struct hostif_msg) >\r\ntotal_len) {\r\n++client_data->bad_recv_cnt;\r\nreport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\r\npayload_len);\r\nish_hw_reset(hid_ishtp_cl->dev);\r\nbreak;\r\n}\r\nhid_ishtp_trace(client_data, "%s %d\n",\r\n__func__, recv_msg->hdr.command & CMD_MASK);\r\nswitch (recv_msg->hdr.command & CMD_MASK) {\r\ncase HOSTIF_DM_ENUM_DEVICES:\r\nif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\r\nclient_data->init_done)) {\r\n++client_data->bad_recv_cnt;\r\nreport_bad_packet(hid_ishtp_cl, recv_msg,\r\ncur_pos,\r\npayload_len);\r\nish_hw_reset(hid_ishtp_cl->dev);\r\nbreak;\r\n}\r\nclient_data->hid_dev_count = (unsigned int)*payload;\r\nif (!client_data->hid_devices)\r\nclient_data->hid_devices = devm_kzalloc(\r\n&client_data->cl_device->dev,\r\nclient_data->hid_dev_count *\r\nsizeof(struct device_info),\r\nGFP_KERNEL);\r\nif (!client_data->hid_devices) {\r\ndev_err(&client_data->cl_device->dev,\r\n"Mem alloc failed for hid device info\n");\r\nwake_up_interruptible(&client_data->init_wait);\r\nbreak;\r\n}\r\nfor (i = 0; i < client_data->hid_dev_count; ++i) {\r\nif (1 + sizeof(struct device_info) * i >=\r\npayload_len) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: [ENUM_DEVICES]: content size %lu is bigger than payload_len %u\n",\r\n1 + sizeof(struct device_info)\r\n* i,\r\n(unsigned int)payload_len);\r\n}\r\nif (1 + sizeof(struct device_info) * i >=\r\ndata_len)\r\nbreak;\r\ndev_info = (struct device_info *)(payload + 1 +\r\nsizeof(struct device_info) * i);\r\nif (client_data->hid_devices)\r\nmemcpy(client_data->hid_devices + i,\r\ndev_info,\r\nsizeof(struct device_info));\r\n}\r\nclient_data->enum_devices_done = true;\r\nwake_up_interruptible(&client_data->init_wait);\r\nbreak;\r\ncase HOSTIF_GET_HID_DESCRIPTOR:\r\nif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\r\nclient_data->init_done)) {\r\n++client_data->bad_recv_cnt;\r\nreport_bad_packet(hid_ishtp_cl, recv_msg,\r\ncur_pos,\r\npayload_len);\r\nish_hw_reset(hid_ishtp_cl->dev);\r\nbreak;\r\n}\r\nif (!client_data->hid_descr[curr_hid_dev])\r\nclient_data->hid_descr[curr_hid_dev] =\r\ndevm_kmalloc(&client_data->cl_device->dev,\r\npayload_len, GFP_KERNEL);\r\nif (client_data->hid_descr[curr_hid_dev]) {\r\nmemcpy(client_data->hid_descr[curr_hid_dev],\r\npayload, payload_len);\r\nclient_data->hid_descr_size[curr_hid_dev] =\r\npayload_len;\r\nclient_data->hid_descr_done = true;\r\n}\r\nwake_up_interruptible(&client_data->init_wait);\r\nbreak;\r\ncase HOSTIF_GET_REPORT_DESCRIPTOR:\r\nif ((!(recv_msg->hdr.command & ~CMD_MASK) ||\r\nclient_data->init_done)) {\r\n++client_data->bad_recv_cnt;\r\nreport_bad_packet(hid_ishtp_cl, recv_msg,\r\ncur_pos,\r\npayload_len);\r\nish_hw_reset(hid_ishtp_cl->dev);\r\nbreak;\r\n}\r\nif (!client_data->report_descr[curr_hid_dev])\r\nclient_data->report_descr[curr_hid_dev] =\r\ndevm_kmalloc(&client_data->cl_device->dev,\r\npayload_len, GFP_KERNEL);\r\nif (client_data->report_descr[curr_hid_dev]) {\r\nmemcpy(client_data->report_descr[curr_hid_dev],\r\npayload,\r\npayload_len);\r\nclient_data->report_descr_size[curr_hid_dev] =\r\npayload_len;\r\nclient_data->report_descr_done = true;\r\n}\r\nwake_up_interruptible(&client_data->init_wait);\r\nbreak;\r\ncase HOSTIF_GET_FEATURE_REPORT:\r\nreport_type = HID_FEATURE_REPORT;\r\ngoto do_get_report;\r\ncase HOSTIF_GET_INPUT_REPORT:\r\nreport_type = HID_INPUT_REPORT;\r\ndo_get_report:\r\nfor (i = 0; i < client_data->num_hid_devices; ++i) {\r\nif (recv_msg->hdr.device_id ==\r\nclient_data->hid_devices[i].dev_id)\r\nif (client_data->hid_sensor_hubs[i]) {\r\nhid_input_report(\r\nclient_data->hid_sensor_hubs[\r\ni],\r\nreport_type, payload,\r\npayload_len, 0);\r\nishtp_hid_wakeup(\r\nclient_data->hid_sensor_hubs[\r\ni]);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase HOSTIF_SET_FEATURE_REPORT:\r\nfor (i = 0; i < client_data->num_hid_devices; ++i) {\r\nif (recv_msg->hdr.device_id ==\r\nclient_data->hid_devices[i].dev_id)\r\nif (client_data->hid_sensor_hubs[i]) {\r\nishtp_hid_wakeup(\r\nclient_data->hid_sensor_hubs[\r\ni]);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase HOSTIF_PUBLISH_INPUT_REPORT:\r\nreport_type = HID_INPUT_REPORT;\r\nfor (i = 0; i < client_data->num_hid_devices; ++i)\r\nif (recv_msg->hdr.device_id ==\r\nclient_data->hid_devices[i].dev_id)\r\nif (client_data->hid_sensor_hubs[i])\r\nhid_input_report(\r\nclient_data->hid_sensor_hubs[\r\ni],\r\nreport_type, payload,\r\npayload_len, 0);\r\nbreak;\r\ncase HOSTIF_PUBLISH_INPUT_REPORT_LIST:\r\nreport_type = HID_INPUT_REPORT;\r\nreports_list = (struct report_list *)payload;\r\nreports = (char *)reports_list->reports;\r\nfor (j = 0; j < reports_list->num_of_reports; j++) {\r\nrecv_msg = (struct hostif_msg *)(reports +\r\nsizeof(uint16_t));\r\nreport_len = *(uint16_t *)reports;\r\npayload = reports + sizeof(uint16_t) +\r\nsizeof(struct hostif_msg_hdr);\r\npayload_len = report_len -\r\nsizeof(struct hostif_msg_hdr);\r\nfor (i = 0; i < client_data->num_hid_devices;\r\n++i)\r\nif (recv_msg->hdr.device_id ==\r\nclient_data->hid_devices[i].dev_id &&\r\nclient_data->hid_sensor_hubs[i]) {\r\nhid_input_report(\r\nclient_data->hid_sensor_hubs[\r\ni],\r\nreport_type,\r\npayload, payload_len,\r\n0);\r\n}\r\nreports += sizeof(uint16_t) + report_len;\r\n}\r\nbreak;\r\ndefault:\r\n++client_data->bad_recv_cnt;\r\nreport_bad_packet(hid_ishtp_cl, recv_msg, cur_pos,\r\npayload_len);\r\nish_hw_reset(hid_ishtp_cl->dev);\r\nbreak;\r\n}\r\nif (!cur_pos && cur_pos + payload_len +\r\nsizeof(struct hostif_msg) < total_len)\r\n++client_data->multi_packet_cnt;\r\ncur_pos += payload_len + sizeof(struct hostif_msg);\r\npayload += payload_len + sizeof(struct hostif_msg);\r\n} while (cur_pos < total_len);\r\n}\r\nstatic void ish_cl_event_cb(struct ishtp_cl_device *device)\r\n{\r\nstruct ishtp_cl *hid_ishtp_cl = device->driver_data;\r\nstruct ishtp_cl_rb *rb_in_proc;\r\nsize_t r_length;\r\nunsigned long flags;\r\nif (!hid_ishtp_cl)\r\nreturn;\r\nspin_lock_irqsave(&hid_ishtp_cl->in_process_spinlock, flags);\r\nwhile (!list_empty(&hid_ishtp_cl->in_process_list.list)) {\r\nrb_in_proc = list_entry(\r\nhid_ishtp_cl->in_process_list.list.next,\r\nstruct ishtp_cl_rb, list);\r\nlist_del_init(&rb_in_proc->list);\r\nspin_unlock_irqrestore(&hid_ishtp_cl->in_process_spinlock,\r\nflags);\r\nif (!rb_in_proc->buffer.data)\r\nreturn;\r\nr_length = rb_in_proc->buf_idx;\r\nprocess_recv(hid_ishtp_cl, rb_in_proc->buffer.data, r_length);\r\nishtp_cl_io_rb_recycle(rb_in_proc);\r\nspin_lock_irqsave(&hid_ishtp_cl->in_process_spinlock, flags);\r\n}\r\nspin_unlock_irqrestore(&hid_ishtp_cl->in_process_spinlock, flags);\r\n}\r\nvoid hid_ishtp_set_feature(struct hid_device *hid, char *buf, unsigned int len,\r\nint report_id)\r\n{\r\nstruct ishtp_hid_data *hid_data = hid->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_data->client_data;\r\nstruct hostif_msg *msg = (struct hostif_msg *)buf;\r\nint rv;\r\nint i;\r\nhid_ishtp_trace(client_data, "%s hid %p\n", __func__, hid);\r\nrv = ishtp_hid_link_ready_wait(client_data);\r\nif (rv) {\r\nhid_ishtp_trace(client_data, "%s hid %p link not ready\n",\r\n__func__, hid);\r\nreturn;\r\n}\r\nmemset(msg, 0, sizeof(struct hostif_msg));\r\nmsg->hdr.command = HOSTIF_SET_FEATURE_REPORT;\r\nfor (i = 0; i < client_data->num_hid_devices; ++i) {\r\nif (hid == client_data->hid_sensor_hubs[i]) {\r\nmsg->hdr.device_id =\r\nclient_data->hid_devices[i].dev_id;\r\nbreak;\r\n}\r\n}\r\nif (i == client_data->num_hid_devices)\r\nreturn;\r\nrv = ishtp_cl_send(client_data->hid_ishtp_cl, buf, len);\r\nif (rv)\r\nhid_ishtp_trace(client_data, "%s hid %p send failed\n",\r\n__func__, hid);\r\n}\r\nvoid hid_ishtp_get_report(struct hid_device *hid, int report_id,\r\nint report_type)\r\n{\r\nstruct ishtp_hid_data *hid_data = hid->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_data->client_data;\r\nstatic unsigned char buf[10];\r\nunsigned int len;\r\nstruct hostif_msg_to_sensor *msg = (struct hostif_msg_to_sensor *)buf;\r\nint rv;\r\nint i;\r\nhid_ishtp_trace(client_data, "%s hid %p\n", __func__, hid);\r\nrv = ishtp_hid_link_ready_wait(client_data);\r\nif (rv) {\r\nhid_ishtp_trace(client_data, "%s hid %p link not ready\n",\r\n__func__, hid);\r\nreturn;\r\n}\r\nlen = sizeof(struct hostif_msg_to_sensor);\r\nmemset(msg, 0, sizeof(struct hostif_msg_to_sensor));\r\nmsg->hdr.command = (report_type == HID_FEATURE_REPORT) ?\r\nHOSTIF_GET_FEATURE_REPORT : HOSTIF_GET_INPUT_REPORT;\r\nfor (i = 0; i < client_data->num_hid_devices; ++i) {\r\nif (hid == client_data->hid_sensor_hubs[i]) {\r\nmsg->hdr.device_id =\r\nclient_data->hid_devices[i].dev_id;\r\nbreak;\r\n}\r\n}\r\nif (i == client_data->num_hid_devices)\r\nreturn;\r\nmsg->report_id = report_id;\r\nrv = ishtp_cl_send(client_data->hid_ishtp_cl, buf, len);\r\nif (rv)\r\nhid_ishtp_trace(client_data, "%s hid %p send failed\n",\r\n__func__, hid);\r\n}\r\nint ishtp_hid_link_ready_wait(struct ishtp_cl_data *client_data)\r\n{\r\nint rc;\r\nif (client_data->suspended) {\r\nhid_ishtp_trace(client_data, "wait for link ready\n");\r\nrc = wait_event_interruptible_timeout(\r\nclient_data->ishtp_resume_wait,\r\n!client_data->suspended,\r\n5 * HZ);\r\nif (rc == 0) {\r\nhid_ishtp_trace(client_data, "link not ready\n");\r\nreturn -EIO;\r\n}\r\nhid_ishtp_trace(client_data, "link ready\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int ishtp_enum_enum_devices(struct ishtp_cl *hid_ishtp_cl)\r\n{\r\nstruct hostif_msg msg;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nint retry_count;\r\nint rv;\r\nmemset(&msg, 0, sizeof(struct hostif_msg));\r\nmsg.hdr.command = HOSTIF_DM_ENUM_DEVICES;\r\nrv = ishtp_cl_send(hid_ishtp_cl, (unsigned char *)&msg,\r\nsizeof(struct hostif_msg));\r\nif (rv)\r\nreturn rv;\r\nretry_count = 0;\r\nwhile (!client_data->enum_devices_done &&\r\nretry_count < 10) {\r\nwait_event_interruptible_timeout(client_data->init_wait,\r\nclient_data->enum_devices_done,\r\n3 * HZ);\r\n++retry_count;\r\nif (!client_data->enum_devices_done)\r\nrv = ishtp_cl_send(hid_ishtp_cl,\r\n(unsigned char *) &msg,\r\nsizeof(struct hostif_msg));\r\n}\r\nif (!client_data->enum_devices_done) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: timed out waiting for enum_devices\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!client_data->hid_devices) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: failed to allocate HID dev structures\n");\r\nreturn -ENOMEM;\r\n}\r\nclient_data->num_hid_devices = client_data->hid_dev_count;\r\ndev_info(&hid_ishtp_cl->device->dev,\r\n"[hid-ish]: enum_devices_done OK, num_hid_devices=%d\n",\r\nclient_data->num_hid_devices);\r\nreturn 0;\r\n}\r\nstatic int ishtp_get_hid_descriptor(struct ishtp_cl *hid_ishtp_cl, int index)\r\n{\r\nstruct hostif_msg msg;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nint rv;\r\nclient_data->hid_descr_done = false;\r\nmemset(&msg, 0, sizeof(struct hostif_msg));\r\nmsg.hdr.command = HOSTIF_GET_HID_DESCRIPTOR;\r\nmsg.hdr.device_id = client_data->hid_devices[index].dev_id;\r\nrv = ishtp_cl_send(hid_ishtp_cl, (unsigned char *) &msg,\r\nsizeof(struct hostif_msg));\r\nif (rv)\r\nreturn rv;\r\nif (!client_data->hid_descr_done) {\r\nwait_event_interruptible_timeout(client_data->init_wait,\r\nclient_data->hid_descr_done,\r\n3 * HZ);\r\nif (!client_data->hid_descr_done) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: timed out for hid_descr_done\n");\r\nreturn -EIO;\r\n}\r\nif (!client_data->hid_descr[index]) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: allocation HID desc fail\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int ishtp_get_report_descriptor(struct ishtp_cl *hid_ishtp_cl,\r\nint index)\r\n{\r\nstruct hostif_msg msg;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nint rv;\r\nclient_data->report_descr_done = false;\r\nmemset(&msg, 0, sizeof(struct hostif_msg));\r\nmsg.hdr.command = HOSTIF_GET_REPORT_DESCRIPTOR;\r\nmsg.hdr.device_id = client_data->hid_devices[index].dev_id;\r\nrv = ishtp_cl_send(hid_ishtp_cl, (unsigned char *) &msg,\r\nsizeof(struct hostif_msg));\r\nif (rv)\r\nreturn rv;\r\nif (!client_data->report_descr_done)\r\nwait_event_interruptible_timeout(client_data->init_wait,\r\nclient_data->report_descr_done,\r\n3 * HZ);\r\nif (!client_data->report_descr_done) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: timed out for report descr\n");\r\nreturn -EIO;\r\n}\r\nif (!client_data->report_descr[index]) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: failed to alloc report descr\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hid_ishtp_cl_init(struct ishtp_cl *hid_ishtp_cl, int reset)\r\n{\r\nstruct ishtp_device *dev;\r\nunsigned long flags;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nint i;\r\nint rv;\r\ndev_dbg(&client_data->cl_device->dev, "%s\n", __func__);\r\nhid_ishtp_trace(client_data, "%s reset flag: %d\n", __func__, reset);\r\nrv = ishtp_cl_link(hid_ishtp_cl, ISHTP_HOST_CLIENT_ID_ANY);\r\nif (rv) {\r\ndev_err(&client_data->cl_device->dev,\r\n"ishtp_cl_link failed\n");\r\nreturn -ENOMEM;\r\n}\r\nclient_data->init_done = 0;\r\ndev = hid_ishtp_cl->dev;\r\nhid_ishtp_cl->rx_ring_size = HID_CL_RX_RING_SIZE;\r\nhid_ishtp_cl->tx_ring_size = HID_CL_TX_RING_SIZE;\r\nspin_lock_irqsave(&dev->fw_clients_lock, flags);\r\ni = ishtp_fw_cl_by_uuid(dev, &hid_ishtp_guid);\r\nif (i < 0) {\r\nspin_unlock_irqrestore(&dev->fw_clients_lock, flags);\r\ndev_err(&client_data->cl_device->dev,\r\n"ish client uuid not found\n");\r\nreturn i;\r\n}\r\nhid_ishtp_cl->fw_client_id = dev->fw_clients[i].client_id;\r\nspin_unlock_irqrestore(&dev->fw_clients_lock, flags);\r\nhid_ishtp_cl->state = ISHTP_CL_CONNECTING;\r\nrv = ishtp_cl_connect(hid_ishtp_cl);\r\nif (rv) {\r\ndev_err(&client_data->cl_device->dev,\r\n"client connect fail\n");\r\ngoto err_cl_unlink;\r\n}\r\nhid_ishtp_trace(client_data, "%s client connected\n", __func__);\r\nishtp_register_event_cb(hid_ishtp_cl->device, ish_cl_event_cb);\r\nrv = ishtp_enum_enum_devices(hid_ishtp_cl);\r\nif (rv)\r\ngoto err_cl_disconnect;\r\nhid_ishtp_trace(client_data, "%s enumerated device count %d\n",\r\n__func__, client_data->num_hid_devices);\r\nfor (i = 0; i < client_data->num_hid_devices; ++i) {\r\nclient_data->cur_hid_dev = i;\r\nrv = ishtp_get_hid_descriptor(hid_ishtp_cl, i);\r\nif (rv)\r\ngoto err_cl_disconnect;\r\nrv = ishtp_get_report_descriptor(hid_ishtp_cl, i);\r\nif (rv)\r\ngoto err_cl_disconnect;\r\nif (!reset) {\r\nrv = ishtp_hid_probe(i, client_data);\r\nif (rv) {\r\ndev_err(&client_data->cl_device->dev,\r\n"[hid-ish]: HID probe for #%u failed: %d\n",\r\ni, rv);\r\ngoto err_cl_disconnect;\r\n}\r\n}\r\n}\r\nclient_data->init_done = 1;\r\nclient_data->suspended = false;\r\nwake_up_interruptible(&client_data->ishtp_resume_wait);\r\nhid_ishtp_trace(client_data, "%s successful init\n", __func__);\r\nreturn 0;\r\nerr_cl_disconnect:\r\nhid_ishtp_cl->state = ISHTP_CL_DISCONNECTING;\r\nishtp_cl_disconnect(hid_ishtp_cl);\r\nerr_cl_unlink:\r\nishtp_cl_unlink(hid_ishtp_cl);\r\nreturn rv;\r\n}\r\nstatic void hid_ishtp_cl_deinit(struct ishtp_cl *hid_ishtp_cl)\r\n{\r\nishtp_cl_unlink(hid_ishtp_cl);\r\nishtp_cl_flush_queues(hid_ishtp_cl);\r\nishtp_cl_free(hid_ishtp_cl);\r\n}\r\nstatic void hid_ishtp_cl_reset_handler(struct work_struct *work)\r\n{\r\nstruct ishtp_cl_data *client_data;\r\nstruct ishtp_cl *hid_ishtp_cl;\r\nstruct ishtp_cl_device *cl_device;\r\nint retry;\r\nint rv;\r\nclient_data = container_of(work, struct ishtp_cl_data, work);\r\nhid_ishtp_cl = client_data->hid_ishtp_cl;\r\ncl_device = client_data->cl_device;\r\nhid_ishtp_trace(client_data, "%s hid_ishtp_cl %p\n", __func__,\r\nhid_ishtp_cl);\r\ndev_dbg(&cl_device->dev, "%s\n", __func__);\r\nhid_ishtp_cl_deinit(hid_ishtp_cl);\r\nhid_ishtp_cl = ishtp_cl_allocate(cl_device->ishtp_dev);\r\nif (!hid_ishtp_cl)\r\nreturn;\r\ncl_device->driver_data = hid_ishtp_cl;\r\nhid_ishtp_cl->client_data = client_data;\r\nclient_data->hid_ishtp_cl = hid_ishtp_cl;\r\nclient_data->num_hid_devices = 0;\r\nfor (retry = 0; retry < 3; ++retry) {\r\nrv = hid_ishtp_cl_init(hid_ishtp_cl, 1);\r\nif (!rv)\r\nbreak;\r\ndev_err(&client_data->cl_device->dev, "Retry reset init\n");\r\n}\r\nif (rv) {\r\ndev_err(&client_data->cl_device->dev, "Reset Failed\n");\r\nhid_ishtp_trace(client_data, "%s Failed hid_ishtp_cl %p\n",\r\n__func__, hid_ishtp_cl);\r\n}\r\n}\r\nstatic int hid_ishtp_cl_probe(struct ishtp_cl_device *cl_device)\r\n{\r\nstruct ishtp_cl *hid_ishtp_cl;\r\nstruct ishtp_cl_data *client_data;\r\nint rv;\r\nif (!cl_device)\r\nreturn -ENODEV;\r\nif (uuid_le_cmp(hid_ishtp_guid,\r\ncl_device->fw_client->props.protocol_name) != 0)\r\nreturn -ENODEV;\r\nclient_data = devm_kzalloc(&cl_device->dev, sizeof(*client_data),\r\nGFP_KERNEL);\r\nif (!client_data)\r\nreturn -ENOMEM;\r\nhid_ishtp_cl = ishtp_cl_allocate(cl_device->ishtp_dev);\r\nif (!hid_ishtp_cl)\r\nreturn -ENOMEM;\r\ncl_device->driver_data = hid_ishtp_cl;\r\nhid_ishtp_cl->client_data = client_data;\r\nclient_data->hid_ishtp_cl = hid_ishtp_cl;\r\nclient_data->cl_device = cl_device;\r\ninit_waitqueue_head(&client_data->init_wait);\r\ninit_waitqueue_head(&client_data->ishtp_resume_wait);\r\nINIT_WORK(&client_data->work, hid_ishtp_cl_reset_handler);\r\nrv = hid_ishtp_cl_init(hid_ishtp_cl, 0);\r\nif (rv) {\r\nishtp_cl_free(hid_ishtp_cl);\r\nreturn rv;\r\n}\r\nishtp_get_device(cl_device);\r\nreturn 0;\r\n}\r\nstatic int hid_ishtp_cl_remove(struct ishtp_cl_device *cl_device)\r\n{\r\nstruct ishtp_cl *hid_ishtp_cl = cl_device->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nhid_ishtp_trace(client_data, "%s hid_ishtp_cl %p\n", __func__,\r\nhid_ishtp_cl);\r\ndev_dbg(&cl_device->dev, "%s\n", __func__);\r\nhid_ishtp_cl->state = ISHTP_CL_DISCONNECTING;\r\nishtp_cl_disconnect(hid_ishtp_cl);\r\nishtp_put_device(cl_device);\r\nishtp_hid_remove(client_data);\r\nhid_ishtp_cl_deinit(hid_ishtp_cl);\r\nhid_ishtp_cl = NULL;\r\nclient_data->num_hid_devices = 0;\r\nreturn 0;\r\n}\r\nstatic int hid_ishtp_cl_reset(struct ishtp_cl_device *cl_device)\r\n{\r\nstruct ishtp_cl *hid_ishtp_cl = cl_device->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nhid_ishtp_trace(client_data, "%s hid_ishtp_cl %p\n", __func__,\r\nhid_ishtp_cl);\r\nschedule_work(&client_data->work);\r\nreturn 0;\r\n}\r\nstatic int hid_ishtp_cl_suspend(struct device *device)\r\n{\r\nstruct ishtp_cl_device *cl_device = to_ishtp_cl_device(device);\r\nstruct ishtp_cl *hid_ishtp_cl = cl_device->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nhid_ishtp_trace(client_data, "%s hid_ishtp_cl %p\n", __func__,\r\nhid_ishtp_cl);\r\nclient_data->suspended = true;\r\nreturn 0;\r\n}\r\nstatic int hid_ishtp_cl_resume(struct device *device)\r\n{\r\nstruct ishtp_cl_device *cl_device = to_ishtp_cl_device(device);\r\nstruct ishtp_cl *hid_ishtp_cl = cl_device->driver_data;\r\nstruct ishtp_cl_data *client_data = hid_ishtp_cl->client_data;\r\nhid_ishtp_trace(client_data, "%s hid_ishtp_cl %p\n", __func__,\r\nhid_ishtp_cl);\r\nclient_data->suspended = false;\r\nreturn 0;\r\n}\r\nstatic int __init ish_hid_init(void)\r\n{\r\nint rv;\r\nrv = ishtp_cl_driver_register(&hid_ishtp_cl_driver);\r\nreturn rv;\r\n}\r\nstatic void __exit ish_hid_exit(void)\r\n{\r\nishtp_cl_driver_unregister(&hid_ishtp_cl_driver);\r\n}
