static const struct gb_camera_fmt_info *gb_camera_get_format_info(u16 gb_fmt)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {\r\nif (gb_fmt_info[i].gb_format == gb_fmt)\r\nreturn &gb_fmt_info[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic int gb_camera_operation_sync_flags(struct gb_connection *connection,\r\nint type, unsigned int flags,\r\nvoid *request, size_t request_size,\r\nvoid *response, size_t *response_size)\r\n{\r\nstruct gb_operation *operation;\r\nint ret;\r\noperation = gb_operation_create_flags(connection, type, request_size,\r\n*response_size, flags,\r\nGFP_KERNEL);\r\nif (!operation)\r\nreturn -ENOMEM;\r\nif (request_size)\r\nmemcpy(operation->request->payload, request, request_size);\r\nret = gb_operation_request_send_sync(operation);\r\nif (ret) {\r\ndev_err(&connection->hd->dev,\r\n"%s: synchronous operation of type 0x%02x failed: %d\n",\r\nconnection->name, type, ret);\r\n} else {\r\n*response_size = operation->response->payload_size;\r\nif (operation->response->payload_size)\r\nmemcpy(response, operation->response->payload,\r\noperation->response->payload_size);\r\n}\r\ngb_operation_put(operation);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_get_max_pkt_size(struct gb_camera *gcam,\r\nstruct gb_camera_configure_streams_response *resp)\r\n{\r\nunsigned int max_pkt_size = 0;\r\nunsigned int i;\r\nfor (i = 0; i < resp->num_streams; i++) {\r\nstruct gb_camera_stream_config_response *cfg = &resp->config[i];\r\nconst struct gb_camera_fmt_info *fmt_info;\r\nunsigned int pkt_size;\r\nfmt_info = gb_camera_get_format_info(cfg->format);\r\nif (!fmt_info) {\r\ngcam_err(gcam, "unsupported greybus image format: %d\n",\r\ncfg->format);\r\nreturn -EIO;\r\n}\r\nif (fmt_info->bpp == 0) {\r\npkt_size = le32_to_cpu(cfg->max_pkt_size);\r\nif (pkt_size == 0) {\r\ngcam_err(gcam,\r\n"Stream %u: invalid zero maximum packet size\n",\r\ni);\r\nreturn -EIO;\r\n}\r\n} else {\r\npkt_size = le16_to_cpu(cfg->width) * fmt_info->bpp / 8;\r\nif (pkt_size != le32_to_cpu(cfg->max_pkt_size)) {\r\ngcam_err(gcam,\r\n"Stream %u: maximum packet size mismatch (%u/%u)\n",\r\ni, pkt_size, cfg->max_pkt_size);\r\nreturn -EIO;\r\n}\r\n}\r\nmax_pkt_size = max(pkt_size, max_pkt_size);\r\n}\r\nreturn max_pkt_size;\r\n}\r\nstatic const int gb_camera_configure_streams_validate_response(\r\nstruct gb_camera *gcam,\r\nstruct gb_camera_configure_streams_response *resp,\r\nunsigned int nstreams)\r\n{\r\nunsigned int i;\r\nif (resp->padding[0] || resp->padding[1]) {\r\ngcam_err(gcam, "response padding != 0\n");\r\nreturn -EIO;\r\n}\r\nif (resp->num_streams > nstreams) {\r\ngcam_err(gcam, "got #streams %u > request %u\n",\r\nresp->num_streams, nstreams);\r\nreturn -EIO;\r\n}\r\nfor (i = 0; i < resp->num_streams; i++) {\r\nstruct gb_camera_stream_config_response *cfg = &resp->config[i];\r\nif (cfg->padding) {\r\ngcam_err(gcam, "stream #%u padding != 0\n", i);\r\nreturn -EIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_camera_set_intf_power_mode(struct gb_camera *gcam, u8 intf_id,\r\nbool hs)\r\n{\r\nstruct gb_svc *svc = gcam->connection->hd->svc;\r\nint ret;\r\nif (hs)\r\nret = gb_svc_intf_set_power_mode(svc, intf_id,\r\nGB_SVC_UNIPRO_HS_SERIES_A,\r\nGB_SVC_UNIPRO_FAST_MODE, 2, 2,\r\nGB_SVC_SMALL_AMPLITUDE,\r\nGB_SVC_NO_DE_EMPHASIS,\r\nGB_SVC_UNIPRO_FAST_MODE, 2, 2,\r\nGB_SVC_PWRM_RXTERMINATION |\r\nGB_SVC_PWRM_TXTERMINATION, 0,\r\nNULL, NULL);\r\nelse\r\nret = gb_svc_intf_set_power_mode(svc, intf_id,\r\nGB_SVC_UNIPRO_HS_SERIES_A,\r\nGB_SVC_UNIPRO_SLOW_AUTO_MODE,\r\n2, 1,\r\nGB_SVC_SMALL_AMPLITUDE,\r\nGB_SVC_NO_DE_EMPHASIS,\r\nGB_SVC_UNIPRO_SLOW_AUTO_MODE,\r\n2, 1,\r\n0, 0,\r\nNULL, NULL);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_set_power_mode(struct gb_camera *gcam, bool hs)\r\n{\r\nstruct gb_interface *intf = gcam->connection->intf;\r\nstruct gb_svc *svc = gcam->connection->hd->svc;\r\nint ret;\r\nret = gb_camera_set_intf_power_mode(gcam, intf->interface_id, hs);\r\nif (ret < 0) {\r\ngcam_err(gcam, "failed to set module interface to %s (%d)\n",\r\nhs ? "HS" : "PWM", ret);\r\nreturn ret;\r\n}\r\nret = gb_camera_set_intf_power_mode(gcam, svc->ap_intf_id, hs);\r\nif (ret < 0) {\r\ngb_camera_set_intf_power_mode(gcam, intf->interface_id, !hs);\r\ngcam_err(gcam, "failed to set AP interface to %s (%d)\n",\r\nhs ? "HS" : "PWM", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_camera_setup_data_connection(struct gb_camera *gcam,\r\nstruct gb_camera_configure_streams_response *resp,\r\nstruct gb_camera_csi_params *csi_params)\r\n{\r\nstruct ap_csi_config_request csi_cfg;\r\nstruct gb_connection *conn;\r\nunsigned int clk_freq;\r\nint ret;\r\nconn = gb_connection_create_offloaded(gcam->bundle, gcam->data_cport_id,\r\nGB_CONNECTION_FLAG_NO_FLOWCTRL |\r\nGB_CONNECTION_FLAG_CDSI1);\r\nif (IS_ERR(conn))\r\nreturn PTR_ERR(conn);\r\ngcam->data_connection = conn;\r\ngb_connection_set_data(conn, gcam);\r\nret = gb_connection_enable(conn);\r\nif (ret)\r\ngoto error_conn_destroy;\r\nret = gb_camera_set_power_mode(gcam, true);\r\nif (ret < 0)\r\ngoto error_conn_disable;\r\nmemset(&csi_cfg, 0, sizeof(csi_cfg));\r\ncsi_cfg.csi_id = 1;\r\ncsi_cfg.flags = 0;\r\ncsi_cfg.num_lanes = GB_CAMERA_CSI_NUM_DATA_LANES;\r\nclk_freq = resp->data_rate / 2 / GB_CAMERA_CSI_NUM_DATA_LANES;\r\nclk_freq = clamp(clk_freq + GB_CAMERA_CSI_CLK_FREQ_MARGIN,\r\nGB_CAMERA_CSI_CLK_FREQ_MIN,\r\nGB_CAMERA_CSI_CLK_FREQ_MAX);\r\ncsi_cfg.csi_clk_freq = clk_freq;\r\nret = gb_camera_get_max_pkt_size(gcam, resp);\r\nif (ret < 0) {\r\nret = -EIO;\r\ngoto error_power;\r\n}\r\ncsi_cfg.max_pkt_size = ret;\r\nret = gb_hd_output(gcam->connection->hd, &csi_cfg,\r\nsizeof(csi_cfg),\r\nGB_APB_REQUEST_CSI_TX_CONTROL, false);\r\nif (ret < 0) {\r\ngcam_err(gcam, "failed to start the CSI transmitter\n");\r\ngoto error_power;\r\n}\r\nif (csi_params) {\r\ncsi_params->clk_freq = csi_cfg.csi_clk_freq;\r\ncsi_params->num_lanes = csi_cfg.num_lanes;\r\n}\r\nreturn 0;\r\nerror_power:\r\ngb_camera_set_power_mode(gcam, false);\r\nerror_conn_disable:\r\ngb_connection_disable(gcam->data_connection);\r\nerror_conn_destroy:\r\ngb_connection_destroy(gcam->data_connection);\r\ngcam->data_connection = NULL;\r\nreturn ret;\r\n}\r\nstatic void gb_camera_teardown_data_connection(struct gb_camera *gcam)\r\n{\r\nstruct ap_csi_config_request csi_cfg;\r\nint ret;\r\nmemset(&csi_cfg, 0, sizeof(csi_cfg));\r\ncsi_cfg.csi_id = 1;\r\nret = gb_hd_output(gcam->connection->hd, &csi_cfg,\r\nsizeof(csi_cfg),\r\nGB_APB_REQUEST_CSI_TX_CONTROL, false);\r\nif (ret < 0)\r\ngcam_err(gcam, "failed to stop the CSI transmitter\n");\r\ngb_camera_set_power_mode(gcam, false);\r\ngb_connection_disable(gcam->data_connection);\r\ngb_connection_destroy(gcam->data_connection);\r\ngcam->data_connection = NULL;\r\n}\r\nstatic int gb_camera_capabilities(struct gb_camera *gcam,\r\nu8 *capabilities, size_t *size)\r\n{\r\nint ret;\r\nret = gb_pm_runtime_get_sync(gcam->bundle);\r\nif (ret)\r\nreturn ret;\r\nmutex_lock(&gcam->mutex);\r\nif (!gcam->connection) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = gb_camera_operation_sync_flags(gcam->connection,\r\nGB_CAMERA_TYPE_CAPABILITIES,\r\nGB_OPERATION_FLAG_SHORT_RESPONSE,\r\nNULL, 0,\r\n(void *)capabilities, size);\r\nif (ret)\r\ngcam_err(gcam, "failed to retrieve capabilities: %d\n", ret);\r\ndone:\r\nmutex_unlock(&gcam->mutex);\r\ngb_pm_runtime_put_autosuspend(gcam->bundle);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_configure_streams(struct gb_camera *gcam,\r\nunsigned int *num_streams,\r\nunsigned int *flags,\r\nstruct gb_camera_stream_config *streams,\r\nstruct gb_camera_csi_params *csi_params)\r\n{\r\nstruct gb_camera_configure_streams_request *req;\r\nstruct gb_camera_configure_streams_response *resp;\r\nunsigned int nstreams = *num_streams;\r\nunsigned int i;\r\nsize_t req_size;\r\nsize_t resp_size;\r\nint ret;\r\nif (nstreams > GB_CAMERA_MAX_STREAMS)\r\nreturn -EINVAL;\r\nreq_size = sizeof(*req) + nstreams * sizeof(req->config[0]);\r\nresp_size = sizeof(*resp) + nstreams * sizeof(resp->config[0]);\r\nreq = kmalloc(req_size, GFP_KERNEL);\r\nresp = kmalloc(resp_size, GFP_KERNEL);\r\nif (!req || !resp) {\r\nkfree(req);\r\nkfree(resp);\r\nreturn -ENOMEM;\r\n}\r\nreq->num_streams = nstreams;\r\nreq->flags = *flags;\r\nreq->padding = 0;\r\nfor (i = 0; i < nstreams; ++i) {\r\nstruct gb_camera_stream_config_request *cfg = &req->config[i];\r\ncfg->width = cpu_to_le16(streams[i].width);\r\ncfg->height = cpu_to_le16(streams[i].height);\r\ncfg->format = cpu_to_le16(streams[i].format);\r\ncfg->padding = 0;\r\n}\r\nmutex_lock(&gcam->mutex);\r\nret = gb_pm_runtime_get_sync(gcam->bundle);\r\nif (ret)\r\ngoto done_skip_pm_put;\r\nif (!gcam->connection) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = gb_camera_operation_sync_flags(gcam->connection,\r\nGB_CAMERA_TYPE_CONFIGURE_STREAMS,\r\nGB_OPERATION_FLAG_SHORT_RESPONSE,\r\nreq, req_size,\r\nresp, &resp_size);\r\nif (ret < 0)\r\ngoto done;\r\nret = gb_camera_configure_streams_validate_response(gcam, resp,\r\nnstreams);\r\nif (ret < 0)\r\ngoto done;\r\n*flags = resp->flags;\r\n*num_streams = resp->num_streams;\r\nfor (i = 0; i < resp->num_streams; ++i) {\r\nstruct gb_camera_stream_config_response *cfg = &resp->config[i];\r\nstreams[i].width = le16_to_cpu(cfg->width);\r\nstreams[i].height = le16_to_cpu(cfg->height);\r\nstreams[i].format = le16_to_cpu(cfg->format);\r\nstreams[i].vc = cfg->virtual_channel;\r\nstreams[i].dt[0] = cfg->data_type[0];\r\nstreams[i].dt[1] = cfg->data_type[1];\r\nstreams[i].max_size = le32_to_cpu(cfg->max_size);\r\n}\r\nif ((resp->flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED) ||\r\n(req->flags & GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY))\r\ngoto done;\r\nif (gcam->state == GB_CAMERA_STATE_CONFIGURED) {\r\ngb_camera_teardown_data_connection(gcam);\r\ngcam->state = GB_CAMERA_STATE_UNCONFIGURED;\r\ngb_pm_runtime_put_noidle(gcam->bundle);\r\n}\r\nif (resp->num_streams == 0)\r\ngoto done;\r\ngb_pm_runtime_get_noresume(gcam->bundle);\r\nret = gb_camera_setup_data_connection(gcam, resp, csi_params);\r\nif (ret < 0) {\r\nmemset(req, 0, sizeof(*req));\r\ngb_operation_sync(gcam->connection,\r\nGB_CAMERA_TYPE_CONFIGURE_STREAMS,\r\nreq, sizeof(*req),\r\nresp, sizeof(*resp));\r\n*flags = 0;\r\n*num_streams = 0;\r\ngb_pm_runtime_put_noidle(gcam->bundle);\r\ngoto done;\r\n}\r\ngcam->state = GB_CAMERA_STATE_CONFIGURED;\r\ndone:\r\ngb_pm_runtime_put_autosuspend(gcam->bundle);\r\ndone_skip_pm_put:\r\nmutex_unlock(&gcam->mutex);\r\nkfree(req);\r\nkfree(resp);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_capture(struct gb_camera *gcam, u32 request_id,\r\nunsigned int streams, unsigned int num_frames,\r\nsize_t settings_size, const void *settings)\r\n{\r\nstruct gb_camera_capture_request *req;\r\nsize_t req_size;\r\nint ret;\r\nif (settings_size > GB_CAMERA_MAX_SETTINGS_SIZE)\r\nreturn -EINVAL;\r\nreq_size = sizeof(*req) + settings_size;\r\nreq = kmalloc(req_size, GFP_KERNEL);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq->request_id = cpu_to_le32(request_id);\r\nreq->streams = streams;\r\nreq->padding = 0;\r\nreq->num_frames = cpu_to_le16(num_frames);\r\nmemcpy(req->settings, settings, settings_size);\r\nmutex_lock(&gcam->mutex);\r\nif (!gcam->connection) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_CAPTURE,\r\nreq, req_size, NULL, 0);\r\ndone:\r\nmutex_unlock(&gcam->mutex);\r\nkfree(req);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_flush(struct gb_camera *gcam, u32 *request_id)\r\n{\r\nstruct gb_camera_flush_response resp;\r\nint ret;\r\nmutex_lock(&gcam->mutex);\r\nif (!gcam->connection) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = gb_operation_sync(gcam->connection, GB_CAMERA_TYPE_FLUSH, NULL, 0,\r\n&resp, sizeof(resp));\r\nif (ret < 0)\r\ngoto done;\r\nif (request_id)\r\n*request_id = le32_to_cpu(resp.request_id);\r\ndone:\r\nmutex_unlock(&gcam->mutex);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_request_handler(struct gb_operation *op)\r\n{\r\nstruct gb_camera *gcam = gb_connection_get_data(op->connection);\r\nstruct gb_camera_metadata_request *payload;\r\nstruct gb_message *request;\r\nif (op->type != GB_CAMERA_TYPE_METADATA) {\r\ngcam_err(gcam, "Unsupported unsolicited event: %u\n", op->type);\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request;\r\nif (request->payload_size < sizeof(*payload)) {\r\ngcam_err(gcam, "Wrong event size received (%zu < %zu)\n",\r\nrequest->payload_size, sizeof(*payload));\r\nreturn -EINVAL;\r\n}\r\npayload = request->payload;\r\ngcam_dbg(gcam, "received metadata for request %u, frame %u, stream %u\n",\r\npayload->request_id, payload->frame_number, payload->stream);\r\nreturn 0;\r\n}\r\nstatic unsigned int gb_camera_mbus_to_gb(enum v4l2_mbus_pixelcode mbus_code)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {\r\nif (gb_fmt_info[i].mbus_code == mbus_code)\r\nreturn gb_fmt_info[i].gb_format;\r\n}\r\nreturn gb_fmt_info[0].gb_format;\r\n}\r\nstatic enum v4l2_mbus_pixelcode gb_camera_gb_to_mbus(u16 gb_fmt)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gb_fmt_info); i++) {\r\nif (gb_fmt_info[i].gb_format == gb_fmt)\r\nreturn gb_fmt_info[i].mbus_code;\r\n}\r\nreturn gb_fmt_info[0].mbus_code;\r\n}\r\nstatic ssize_t gb_camera_op_capabilities(void *priv, char *data, size_t len)\r\n{\r\nstruct gb_camera *gcam = priv;\r\nsize_t capabilities_len = len;\r\nint ret;\r\nret = gb_camera_capabilities(gcam, data, &capabilities_len);\r\nif (ret)\r\nreturn ret;\r\nreturn capabilities_len;\r\n}\r\nstatic int gb_camera_op_configure_streams(void *priv, unsigned int *nstreams,\r\nunsigned int *flags, struct gb_camera_stream *streams,\r\nstruct gb_camera_csi_params *csi_params)\r\n{\r\nstruct gb_camera *gcam = priv;\r\nstruct gb_camera_stream_config *gb_streams;\r\nunsigned int gb_flags = 0;\r\nunsigned int gb_nstreams = *nstreams;\r\nunsigned int i;\r\nint ret;\r\nif (gb_nstreams > GB_CAMERA_MAX_STREAMS)\r\nreturn -EINVAL;\r\ngb_streams = kcalloc(gb_nstreams, sizeof(*gb_streams), GFP_KERNEL);\r\nif (!gb_streams)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < gb_nstreams; i++) {\r\ngb_streams[i].width = streams[i].width;\r\ngb_streams[i].height = streams[i].height;\r\ngb_streams[i].format =\r\ngb_camera_mbus_to_gb(streams[i].pixel_code);\r\n}\r\nif (*flags & GB_CAMERA_IN_FLAG_TEST)\r\ngb_flags |= GB_CAMERA_CONFIGURE_STREAMS_TEST_ONLY;\r\nret = gb_camera_configure_streams(gcam, &gb_nstreams,\r\n&gb_flags, gb_streams, csi_params);\r\nif (ret < 0)\r\ngoto done;\r\nif (gb_nstreams > *nstreams) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\n*flags = 0;\r\nif (gb_flags & GB_CAMERA_CONFIGURE_STREAMS_ADJUSTED)\r\n*flags |= GB_CAMERA_OUT_FLAG_ADJUSTED;\r\nfor (i = 0; i < gb_nstreams; i++) {\r\nstreams[i].width = gb_streams[i].width;\r\nstreams[i].height = gb_streams[i].height;\r\nstreams[i].vc = gb_streams[i].vc;\r\nstreams[i].dt[0] = gb_streams[i].dt[0];\r\nstreams[i].dt[1] = gb_streams[i].dt[1];\r\nstreams[i].max_size = gb_streams[i].max_size;\r\nstreams[i].pixel_code =\r\ngb_camera_gb_to_mbus(gb_streams[i].format);\r\n}\r\n*nstreams = gb_nstreams;\r\ndone:\r\nkfree(gb_streams);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_op_capture(void *priv, u32 request_id,\r\nunsigned int streams, unsigned int num_frames,\r\nsize_t settings_size, const void *settings)\r\n{\r\nstruct gb_camera *gcam = priv;\r\nreturn gb_camera_capture(gcam, request_id, streams, num_frames,\r\nsettings_size, settings);\r\n}\r\nstatic int gb_camera_op_flush(void *priv, u32 *request_id)\r\n{\r\nstruct gb_camera *gcam = priv;\r\nreturn gb_camera_flush(gcam, request_id);\r\n}\r\nstatic ssize_t gb_camera_debugfs_capabilities(struct gb_camera *gcam,\r\nchar *buf, size_t len)\r\n{\r\nstruct gb_camera_debugfs_buffer *buffer =\r\n&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_CAPABILITIES];\r\nsize_t size = 1024;\r\nunsigned int i;\r\nu8 *caps;\r\nint ret;\r\ncaps = kmalloc(size, GFP_KERNEL);\r\nif (!caps)\r\nreturn -ENOMEM;\r\nret = gb_camera_capabilities(gcam, caps, &size);\r\nif (ret < 0)\r\ngoto done;\r\nbuffer->length = 0;\r\nfor (i = 0; i < size; i += 16) {\r\nunsigned int nbytes = min_t(unsigned int, size - i, 16);\r\nbuffer->length += sprintf(buffer->data + buffer->length,\r\n"%*ph\n", nbytes, caps + i);\r\n}\r\ndone:\r\nkfree(caps);\r\nreturn ret;\r\n}\r\nstatic ssize_t gb_camera_debugfs_configure_streams(struct gb_camera *gcam,\r\nchar *buf, size_t len)\r\n{\r\nstruct gb_camera_debugfs_buffer *buffer =\r\n&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_STREAMS];\r\nstruct gb_camera_stream_config *streams;\r\nunsigned int nstreams;\r\nunsigned int flags;\r\nunsigned int i;\r\nchar *token;\r\nint ret;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\nreturn -EINVAL;\r\nret = kstrtouint(token, 10, &nstreams);\r\nif (ret < 0)\r\nreturn ret;\r\nif (nstreams > GB_CAMERA_MAX_STREAMS)\r\nreturn -EINVAL;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\nreturn -EINVAL;\r\nret = kstrtouint(token, 10, &flags);\r\nif (ret < 0)\r\nreturn ret;\r\nstreams = kcalloc(nstreams, sizeof(*streams), GFP_KERNEL);\r\nif (!streams)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < nstreams; ++i) {\r\nstruct gb_camera_stream_config *stream = &streams[i];\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nret = kstrtouint(token, 10, &stream->width);\r\nif (ret < 0)\r\ngoto done;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\ngoto done;\r\nret = kstrtouint(token, 10, &stream->height);\r\nif (ret < 0)\r\ngoto done;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\ngoto done;\r\nret = kstrtouint(token, 16, &stream->format);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\nret = gb_camera_configure_streams(gcam, &nstreams, &flags, streams,\r\nNULL);\r\nif (ret < 0)\r\ngoto done;\r\nbuffer->length = sprintf(buffer->data, "%u;%u;", nstreams, flags);\r\nfor (i = 0; i < nstreams; ++i) {\r\nstruct gb_camera_stream_config *stream = &streams[i];\r\nbuffer->length += sprintf(buffer->data + buffer->length,\r\n"%u;%u;%u;%u;%u;%u;%u;",\r\nstream->width, stream->height,\r\nstream->format, stream->vc,\r\nstream->dt[0], stream->dt[1],\r\nstream->max_size);\r\n}\r\nret = len;\r\ndone:\r\nkfree(streams);\r\nreturn ret;\r\n}\r\nstatic ssize_t gb_camera_debugfs_capture(struct gb_camera *gcam,\r\nchar *buf, size_t len)\r\n{\r\nunsigned int request_id;\r\nunsigned int streams_mask;\r\nunsigned int num_frames;\r\nchar *token;\r\nint ret;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\nreturn -EINVAL;\r\nret = kstrtouint(token, 10, &request_id);\r\nif (ret < 0)\r\nreturn ret;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\nreturn -EINVAL;\r\nret = kstrtouint(token, 16, &streams_mask);\r\nif (ret < 0)\r\nreturn ret;\r\ntoken = strsep(&buf, ";");\r\nif (token == NULL)\r\nreturn -EINVAL;\r\nret = kstrtouint(token, 10, &num_frames);\r\nif (ret < 0)\r\nreturn ret;\r\nret = gb_camera_capture(gcam, request_id, streams_mask, num_frames, 0,\r\nNULL);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn len;\r\n}\r\nstatic ssize_t gb_camera_debugfs_flush(struct gb_camera *gcam,\r\nchar *buf, size_t len)\r\n{\r\nstruct gb_camera_debugfs_buffer *buffer =\r\n&gcam->debugfs.buffers[GB_CAMERA_DEBUGFS_BUFFER_FLUSH];\r\nunsigned int req_id;\r\nint ret;\r\nret = gb_camera_flush(gcam, &req_id);\r\nif (ret < 0)\r\nreturn ret;\r\nbuffer->length = sprintf(buffer->data, "%u", req_id);\r\nreturn len;\r\n}\r\nstatic ssize_t gb_camera_debugfs_read(struct file *file, char __user *buf,\r\nsize_t len, loff_t *offset)\r\n{\r\nconst struct gb_camera_debugfs_entry *op = file->private_data;\r\nstruct gb_camera *gcam = file_inode(file)->i_private;\r\nstruct gb_camera_debugfs_buffer *buffer;\r\nssize_t ret;\r\nif (!(op->mask & 0222)) {\r\nret = op->execute(gcam, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nbuffer = &gcam->debugfs.buffers[op->buffer];\r\nreturn simple_read_from_buffer(buf, len, offset, buffer->data,\r\nbuffer->length);\r\n}\r\nstatic ssize_t gb_camera_debugfs_write(struct file *file,\r\nconst char __user *buf, size_t len,\r\nloff_t *offset)\r\n{\r\nconst struct gb_camera_debugfs_entry *op = file->private_data;\r\nstruct gb_camera *gcam = file_inode(file)->i_private;\r\nssize_t ret;\r\nchar *kbuf;\r\nif (len > 1024)\r\nreturn -EINVAL;\r\nkbuf = kmalloc(len + 1, GFP_KERNEL);\r\nif (!kbuf)\r\nreturn -ENOMEM;\r\nif (copy_from_user(kbuf, buf, len)) {\r\nret = -EFAULT;\r\ngoto done;\r\n}\r\nkbuf[len] = '\0';\r\nret = op->execute(gcam, kbuf, len);\r\ndone:\r\nkfree(kbuf);\r\nreturn ret;\r\n}\r\nstatic int gb_camera_debugfs_open(struct inode *inode, struct file *file)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {\r\nconst struct gb_camera_debugfs_entry *entry =\r\n&gb_camera_debugfs_entries[i];\r\nif (!strcmp(file->f_path.dentry->d_iname, entry->name)) {\r\nfile->private_data = (void *)entry;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int gb_camera_debugfs_init(struct gb_camera *gcam)\r\n{\r\nstruct gb_connection *connection = gcam->connection;\r\nchar dirname[27];\r\nunsigned int i;\r\nsnprintf(dirname, 27, "camera-%u.%u", connection->intf->interface_id,\r\ngcam->bundle->id);\r\ngcam->debugfs.root = debugfs_create_dir(dirname, gb_debugfs_get());\r\nif (IS_ERR(gcam->debugfs.root)) {\r\ngcam_err(gcam, "debugfs root create failed (%ld)\n",\r\nPTR_ERR(gcam->debugfs.root));\r\nreturn PTR_ERR(gcam->debugfs.root);\r\n}\r\ngcam->debugfs.buffers = vmalloc(sizeof(*gcam->debugfs.buffers) *\r\nGB_CAMERA_DEBUGFS_BUFFER_MAX);\r\nif (!gcam->debugfs.buffers)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ARRAY_SIZE(gb_camera_debugfs_entries); ++i) {\r\nconst struct gb_camera_debugfs_entry *entry =\r\n&gb_camera_debugfs_entries[i];\r\nstruct dentry *dentry;\r\ngcam->debugfs.buffers[i].length = 0;\r\ndentry = debugfs_create_file(entry->name, entry->mask,\r\ngcam->debugfs.root, gcam,\r\n&gb_camera_debugfs_ops);\r\nif (IS_ERR(dentry)) {\r\ngcam_err(gcam,\r\n"debugfs operation %s create failed (%ld)\n",\r\nentry->name, PTR_ERR(dentry));\r\nreturn PTR_ERR(dentry);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void gb_camera_debugfs_cleanup(struct gb_camera *gcam)\r\n{\r\ndebugfs_remove_recursive(gcam->debugfs.root);\r\nvfree(gcam->debugfs.buffers);\r\n}\r\nstatic void gb_camera_cleanup(struct gb_camera *gcam)\r\n{\r\ngb_camera_debugfs_cleanup(gcam);\r\nmutex_lock(&gcam->mutex);\r\nif (gcam->data_connection) {\r\ngb_connection_disable(gcam->data_connection);\r\ngb_connection_destroy(gcam->data_connection);\r\ngcam->data_connection = NULL;\r\n}\r\nif (gcam->connection) {\r\ngb_connection_disable(gcam->connection);\r\ngb_connection_destroy(gcam->connection);\r\ngcam->connection = NULL;\r\n}\r\nmutex_unlock(&gcam->mutex);\r\n}\r\nstatic void gb_camera_release_module(struct kref *ref)\r\n{\r\nstruct gb_camera_module *cam_mod =\r\ncontainer_of(ref, struct gb_camera_module, refcount);\r\nkfree(cam_mod->priv);\r\n}\r\nstatic int gb_camera_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct gb_connection *conn;\r\nstruct gb_camera *gcam;\r\nu16 mgmt_cport_id = 0;\r\nu16 data_cport_id = 0;\r\nunsigned int i;\r\nint ret;\r\nif (bundle->num_cports != 2)\r\nreturn -ENODEV;\r\nfor (i = 0; i < bundle->num_cports; ++i) {\r\nstruct greybus_descriptor_cport *desc = &bundle->cport_desc[i];\r\nswitch (desc->protocol_id) {\r\ncase GREYBUS_PROTOCOL_CAMERA_MGMT:\r\nmgmt_cport_id = le16_to_cpu(desc->id);\r\nbreak;\r\ncase GREYBUS_PROTOCOL_CAMERA_DATA:\r\ndata_cport_id = le16_to_cpu(desc->id);\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (!mgmt_cport_id || !data_cport_id)\r\nreturn -ENODEV;\r\ngcam = kzalloc(sizeof(*gcam), GFP_KERNEL);\r\nif (!gcam)\r\nreturn -ENOMEM;\r\nmutex_init(&gcam->mutex);\r\ngcam->bundle = bundle;\r\ngcam->state = GB_CAMERA_STATE_UNCONFIGURED;\r\ngcam->data_cport_id = data_cport_id;\r\nconn = gb_connection_create(bundle, mgmt_cport_id,\r\ngb_camera_request_handler);\r\nif (IS_ERR(conn)) {\r\nret = PTR_ERR(conn);\r\ngoto error;\r\n}\r\ngcam->connection = conn;\r\ngb_connection_set_data(conn, gcam);\r\nret = gb_connection_enable(conn);\r\nif (ret)\r\ngoto error;\r\nret = gb_camera_debugfs_init(gcam);\r\nif (ret < 0)\r\ngoto error;\r\ngcam->module.priv = gcam;\r\ngcam->module.ops = &gb_cam_ops;\r\ngcam->module.interface_id = gcam->connection->intf->interface_id;\r\ngcam->module.release = gb_camera_release_module;\r\nret = gb_camera_register(&gcam->module);\r\nif (ret < 0)\r\ngoto error;\r\ngreybus_set_drvdata(bundle, gcam);\r\ngb_pm_runtime_put_autosuspend(gcam->bundle);\r\nreturn 0;\r\nerror:\r\ngb_camera_cleanup(gcam);\r\nkfree(gcam);\r\nreturn ret;\r\n}\r\nstatic void gb_camera_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_camera *gcam = greybus_get_drvdata(bundle);\r\nint ret;\r\nret = gb_pm_runtime_get_sync(bundle);\r\nif (ret)\r\ngb_pm_runtime_get_noresume(bundle);\r\ngb_camera_cleanup(gcam);\r\ngb_camera_unregister(&gcam->module);\r\n}\r\nstatic int gb_camera_suspend(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nstruct gb_camera *gcam = greybus_get_drvdata(bundle);\r\nif (gcam->data_connection)\r\ngb_connection_disable(gcam->data_connection);\r\ngb_connection_disable(gcam->connection);\r\nreturn 0;\r\n}\r\nstatic int gb_camera_resume(struct device *dev)\r\n{\r\nstruct gb_bundle *bundle = to_gb_bundle(dev);\r\nstruct gb_camera *gcam = greybus_get_drvdata(bundle);\r\nint ret;\r\nret = gb_connection_enable(gcam->connection);\r\nif (ret) {\r\ngcam_err(gcam, "failed to enable connection: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (gcam->data_connection) {\r\nret = gb_connection_enable(gcam->data_connection);\r\nif (ret) {\r\ngcam_err(gcam,\r\n"failed to enable data connection: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}
