static int aspeed_smc_read_from_ahb(void *buf, void __iomem *src, size_t len)\r\n{\r\nsize_t offset = 0;\r\nif (IS_ALIGNED((uintptr_t)src, sizeof(uintptr_t)) &&\r\nIS_ALIGNED((uintptr_t)buf, sizeof(uintptr_t))) {\r\nioread32_rep(src, buf, len >> 2);\r\noffset = len & ~0x3;\r\nlen -= offset;\r\n}\r\nioread8_rep(src, (u8 *)buf + offset, len);\r\nreturn 0;\r\n}\r\nstatic int aspeed_smc_write_to_ahb(void __iomem *dst, const void *buf,\r\nsize_t len)\r\n{\r\nsize_t offset = 0;\r\nif (IS_ALIGNED((uintptr_t)dst, sizeof(uintptr_t)) &&\r\nIS_ALIGNED((uintptr_t)buf, sizeof(uintptr_t))) {\r\niowrite32_rep(dst, buf, len >> 2);\r\noffset = len & ~0x3;\r\nlen -= offset;\r\n}\r\niowrite8_rep(dst, (const u8 *)buf + offset, len);\r\nreturn 0;\r\n}\r\nstatic inline u32 aspeed_smc_chip_write_bit(struct aspeed_smc_chip *chip)\r\n{\r\nreturn BIT(chip->controller->info->we0 + chip->cs);\r\n}\r\nstatic void aspeed_smc_chip_check_config(struct aspeed_smc_chip *chip)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nu32 reg;\r\nreg = readl(controller->regs + CONFIG_REG);\r\nif (reg & aspeed_smc_chip_write_bit(chip))\r\nreturn;\r\ndev_dbg(controller->dev, "config write is not set ! @%p: 0x%08x\n",\r\ncontroller->regs + CONFIG_REG, reg);\r\nreg |= aspeed_smc_chip_write_bit(chip);\r\nwritel(reg, controller->regs + CONFIG_REG);\r\n}\r\nstatic void aspeed_smc_start_user(struct spi_nor *nor)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\nu32 ctl = chip->ctl_val[smc_base];\r\naspeed_smc_chip_check_config(chip);\r\nctl |= CONTROL_COMMAND_MODE_USER |\r\nCONTROL_CE_STOP_ACTIVE_CONTROL;\r\nwritel(ctl, chip->ctl);\r\nctl &= ~CONTROL_CE_STOP_ACTIVE_CONTROL;\r\nwritel(ctl, chip->ctl);\r\n}\r\nstatic void aspeed_smc_stop_user(struct spi_nor *nor)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\nu32 ctl = chip->ctl_val[smc_read];\r\nu32 ctl2 = ctl | CONTROL_COMMAND_MODE_USER |\r\nCONTROL_CE_STOP_ACTIVE_CONTROL;\r\nwritel(ctl2, chip->ctl);\r\nwritel(ctl, chip->ctl);\r\n}\r\nstatic int aspeed_smc_prep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\nmutex_lock(&chip->controller->mutex);\r\nreturn 0;\r\n}\r\nstatic void aspeed_smc_unprep(struct spi_nor *nor, enum spi_nor_ops ops)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\nmutex_unlock(&chip->controller->mutex);\r\n}\r\nstatic int aspeed_smc_read_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\naspeed_smc_start_user(nor);\r\naspeed_smc_write_to_ahb(chip->ahb_base, &opcode, 1);\r\naspeed_smc_read_from_ahb(buf, chip->ahb_base, len);\r\naspeed_smc_stop_user(nor);\r\nreturn 0;\r\n}\r\nstatic int aspeed_smc_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf,\r\nint len)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\naspeed_smc_start_user(nor);\r\naspeed_smc_write_to_ahb(chip->ahb_base, &opcode, 1);\r\naspeed_smc_write_to_ahb(chip->ahb_base, buf, len);\r\naspeed_smc_stop_user(nor);\r\nreturn 0;\r\n}\r\nstatic void aspeed_smc_send_cmd_addr(struct spi_nor *nor, u8 cmd, u32 addr)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\n__be32 temp;\r\nu32 cmdaddr;\r\nswitch (nor->addr_width) {\r\ndefault:\r\nWARN_ONCE(1, "Unexpected address width %u, defaulting to 3\n",\r\nnor->addr_width);\r\ncase 3:\r\ncmdaddr = addr & 0xFFFFFF;\r\ncmdaddr |= cmd << 24;\r\ntemp = cpu_to_be32(cmdaddr);\r\naspeed_smc_write_to_ahb(chip->ahb_base, &temp, 4);\r\nbreak;\r\ncase 4:\r\ntemp = cpu_to_be32(addr);\r\naspeed_smc_write_to_ahb(chip->ahb_base, &cmd, 1);\r\naspeed_smc_write_to_ahb(chip->ahb_base, &temp, 4);\r\nbreak;\r\n}\r\n}\r\nstatic ssize_t aspeed_smc_read_user(struct spi_nor *nor, loff_t from,\r\nsize_t len, u_char *read_buf)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\nint i;\r\nu8 dummy = 0xFF;\r\naspeed_smc_start_user(nor);\r\naspeed_smc_send_cmd_addr(nor, nor->read_opcode, from);\r\nfor (i = 0; i < chip->nor.read_dummy / 8; i++)\r\naspeed_smc_write_to_ahb(chip->ahb_base, &dummy, sizeof(dummy));\r\naspeed_smc_read_from_ahb(read_buf, chip->ahb_base, len);\r\naspeed_smc_stop_user(nor);\r\nreturn len;\r\n}\r\nstatic ssize_t aspeed_smc_write_user(struct spi_nor *nor, loff_t to,\r\nsize_t len, const u_char *write_buf)\r\n{\r\nstruct aspeed_smc_chip *chip = nor->priv;\r\naspeed_smc_start_user(nor);\r\naspeed_smc_send_cmd_addr(nor, nor->program_opcode, to);\r\naspeed_smc_write_to_ahb(chip->ahb_base, write_buf, len);\r\naspeed_smc_stop_user(nor);\r\nreturn len;\r\n}\r\nstatic int aspeed_smc_unregister(struct aspeed_smc_controller *controller)\r\n{\r\nstruct aspeed_smc_chip *chip;\r\nint n;\r\nfor (n = 0; n < controller->info->nce; n++) {\r\nchip = controller->chips[n];\r\nif (chip)\r\nmtd_device_unregister(&chip->nor.mtd);\r\n}\r\nreturn 0;\r\n}\r\nstatic int aspeed_smc_remove(struct platform_device *dev)\r\n{\r\nreturn aspeed_smc_unregister(platform_get_drvdata(dev));\r\n}\r\nstatic void __iomem *aspeed_smc_chip_base(struct aspeed_smc_chip *chip,\r\nstruct resource *res)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nu32 offset = 0;\r\nu32 reg;\r\nif (controller->info->nce > 1) {\r\nreg = readl(controller->regs + SEGMENT_ADDR_REG0 +\r\nchip->cs * 4);\r\nif (SEGMENT_ADDR_START(reg) >= SEGMENT_ADDR_END(reg))\r\nreturn NULL;\r\noffset = SEGMENT_ADDR_START(reg) - res->start;\r\n}\r\nreturn controller->ahb_base + offset;\r\n}\r\nstatic void aspeed_smc_chip_enable_write(struct aspeed_smc_chip *chip)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nu32 reg;\r\nreg = readl(controller->regs + CONFIG_REG);\r\nreg |= aspeed_smc_chip_write_bit(chip);\r\nwritel(reg, controller->regs + CONFIG_REG);\r\n}\r\nstatic void aspeed_smc_chip_set_type(struct aspeed_smc_chip *chip, int type)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nu32 reg;\r\nchip->type = type;\r\nreg = readl(controller->regs + CONFIG_REG);\r\nreg &= ~(3 << (chip->cs * 2));\r\nreg |= chip->type << (chip->cs * 2);\r\nwritel(reg, controller->regs + CONFIG_REG);\r\n}\r\nstatic void aspeed_smc_chip_set_4b(struct aspeed_smc_chip *chip)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nu32 reg;\r\nif (chip->controller->info == &spi_2500_info) {\r\nreg = readl(controller->regs + CE_CONTROL_REG);\r\nreg |= 1 << chip->cs;\r\nwritel(reg, controller->regs + CE_CONTROL_REG);\r\n}\r\n}\r\nstatic void aspeed_smc_chip_set_4b_spi_2400(struct aspeed_smc_chip *chip)\r\n{\r\nchip->ctl_val[smc_base] |= CONTROL_IO_ADDRESS_4B;\r\nchip->ctl_val[smc_read] |= CONTROL_IO_ADDRESS_4B;\r\n}\r\nstatic int aspeed_smc_chip_setup_init(struct aspeed_smc_chip *chip,\r\nstruct resource *res)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nconst struct aspeed_smc_info *info = controller->info;\r\nu32 reg, base_reg;\r\naspeed_smc_chip_enable_write(chip);\r\nif (info->hastype)\r\naspeed_smc_chip_set_type(chip, smc_type_spi);\r\nchip->ahb_base = aspeed_smc_chip_base(chip, res);\r\nif (!chip->ahb_base) {\r\ndev_warn(chip->nor.dev, "CE segment window closed.\n");\r\nreturn -EINVAL;\r\n}\r\nreg = readl(chip->ctl);\r\ndev_dbg(controller->dev, "control register: %08x\n", reg);\r\nbase_reg = reg & CONTROL_KEEP_MASK;\r\nif (base_reg != reg) {\r\ndev_dbg(controller->dev,\r\n"control register changed to: %08x\n",\r\nbase_reg);\r\n}\r\nchip->ctl_val[smc_base] = base_reg;\r\nif ((reg & CONTROL_COMMAND_MODE_MASK) ==\r\nCONTROL_COMMAND_MODE_NORMAL)\r\nchip->ctl_val[smc_read] = reg;\r\nelse\r\nchip->ctl_val[smc_read] = chip->ctl_val[smc_base] |\r\nCONTROL_COMMAND_MODE_NORMAL;\r\ndev_dbg(controller->dev, "default control register: %08x\n",\r\nchip->ctl_val[smc_read]);\r\nreturn 0;\r\n}\r\nstatic int aspeed_smc_chip_setup_finish(struct aspeed_smc_chip *chip)\r\n{\r\nstruct aspeed_smc_controller *controller = chip->controller;\r\nconst struct aspeed_smc_info *info = controller->info;\r\nu32 cmd;\r\nif (chip->nor.addr_width == 4 && info->set_4b)\r\ninfo->set_4b(chip);\r\nchip->ctl_val[smc_write] = chip->ctl_val[smc_base] |\r\nchip->nor.program_opcode << CONTROL_COMMAND_SHIFT |\r\nCONTROL_COMMAND_MODE_WRITE;\r\ndev_dbg(controller->dev, "write control register: %08x\n",\r\nchip->ctl_val[smc_write]);\r\nswitch (chip->nor.flash_read) {\r\ncase SPI_NOR_NORMAL:\r\ncmd = CONTROL_COMMAND_MODE_NORMAL;\r\nbreak;\r\ncase SPI_NOR_FAST:\r\ncmd = CONTROL_COMMAND_MODE_FREAD;\r\nbreak;\r\ndefault:\r\ndev_err(chip->nor.dev, "unsupported SPI read mode\n");\r\nreturn -EINVAL;\r\n}\r\nchip->ctl_val[smc_read] |= cmd |\r\nCONTROL_IO_DUMMY_SET(chip->nor.read_dummy / 8);\r\ndev_dbg(controller->dev, "base control register: %08x\n",\r\nchip->ctl_val[smc_read]);\r\nreturn 0;\r\n}\r\nstatic int aspeed_smc_setup_flash(struct aspeed_smc_controller *controller,\r\nstruct device_node *np, struct resource *r)\r\n{\r\nconst struct aspeed_smc_info *info = controller->info;\r\nstruct device *dev = controller->dev;\r\nstruct device_node *child;\r\nunsigned int cs;\r\nint ret = -ENODEV;\r\nfor_each_available_child_of_node(np, child) {\r\nstruct aspeed_smc_chip *chip;\r\nstruct spi_nor *nor;\r\nstruct mtd_info *mtd;\r\nif (!of_device_is_compatible(child, "jedec,spi-nor"))\r\ncontinue;\r\nret = of_property_read_u32(child, "reg", &cs);\r\nif (ret) {\r\ndev_err(dev, "Couldn't not read chip select.\n");\r\nbreak;\r\n}\r\nif (cs >= info->nce) {\r\ndev_err(dev, "Chip select %d out of range.\n",\r\ncs);\r\nret = -ERANGE;\r\nbreak;\r\n}\r\nif (controller->chips[cs]) {\r\ndev_err(dev, "Chip select %d already in use by %s\n",\r\ncs, dev_name(controller->chips[cs]->nor.dev));\r\nret = -EBUSY;\r\nbreak;\r\n}\r\nchip = devm_kzalloc(controller->dev, sizeof(*chip), GFP_KERNEL);\r\nif (!chip) {\r\nret = -ENOMEM;\r\nbreak;\r\n}\r\nchip->controller = controller;\r\nchip->ctl = controller->regs + info->ctl0 + cs * 4;\r\nchip->cs = cs;\r\nnor = &chip->nor;\r\nmtd = &nor->mtd;\r\nnor->dev = dev;\r\nnor->priv = chip;\r\nspi_nor_set_flash_node(nor, child);\r\nnor->read = aspeed_smc_read_user;\r\nnor->write = aspeed_smc_write_user;\r\nnor->read_reg = aspeed_smc_read_reg;\r\nnor->write_reg = aspeed_smc_write_reg;\r\nnor->prepare = aspeed_smc_prep;\r\nnor->unprepare = aspeed_smc_unprep;\r\nret = aspeed_smc_chip_setup_init(chip, r);\r\nif (ret)\r\nbreak;\r\nret = spi_nor_scan(nor, NULL, SPI_NOR_NORMAL);\r\nif (ret)\r\nbreak;\r\nret = aspeed_smc_chip_setup_finish(chip);\r\nif (ret)\r\nbreak;\r\nret = mtd_device_register(mtd, NULL, 0);\r\nif (ret)\r\nbreak;\r\ncontroller->chips[cs] = chip;\r\n}\r\nif (ret)\r\naspeed_smc_unregister(controller);\r\nreturn ret;\r\n}\r\nstatic int aspeed_smc_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device *dev = &pdev->dev;\r\nstruct aspeed_smc_controller *controller;\r\nconst struct of_device_id *match;\r\nconst struct aspeed_smc_info *info;\r\nstruct resource *res;\r\nint ret;\r\nmatch = of_match_device(aspeed_smc_matches, &pdev->dev);\r\nif (!match || !match->data)\r\nreturn -ENODEV;\r\ninfo = match->data;\r\ncontroller = devm_kzalloc(&pdev->dev, sizeof(*controller) +\r\ninfo->nce * sizeof(controller->chips[0]), GFP_KERNEL);\r\nif (!controller)\r\nreturn -ENOMEM;\r\ncontroller->info = info;\r\ncontroller->dev = dev;\r\nmutex_init(&controller->mutex);\r\nplatform_set_drvdata(pdev, controller);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\ncontroller->regs = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(controller->regs))\r\nreturn PTR_ERR(controller->regs);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\ncontroller->ahb_base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(controller->ahb_base))\r\nreturn PTR_ERR(controller->ahb_base);\r\nret = aspeed_smc_setup_flash(controller, np, res);\r\nif (ret)\r\ndev_err(dev, "Aspeed SMC probe failed %d\n", ret);\r\nreturn ret;\r\n}
