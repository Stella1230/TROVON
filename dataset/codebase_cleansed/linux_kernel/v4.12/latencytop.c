void clear_all_latency_tracing(struct task_struct *p)\r\n{\r\nunsigned long flags;\r\nif (!latencytop_enabled)\r\nreturn;\r\nraw_spin_lock_irqsave(&latency_lock, flags);\r\nmemset(&p->latency_record, 0, sizeof(p->latency_record));\r\np->latency_record_count = 0;\r\nraw_spin_unlock_irqrestore(&latency_lock, flags);\r\n}\r\nstatic void clear_global_latency_tracing(void)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&latency_lock, flags);\r\nmemset(&latency_record, 0, sizeof(latency_record));\r\nraw_spin_unlock_irqrestore(&latency_lock, flags);\r\n}\r\nstatic void __sched\r\naccount_global_scheduler_latency(struct task_struct *tsk,\r\nstruct latency_record *lat)\r\n{\r\nint firstnonnull = MAXLR + 1;\r\nint i;\r\nif (!latencytop_enabled)\r\nreturn;\r\nif (!tsk->mm)\r\nreturn;\r\nfor (i = 0; i < MAXLR; i++) {\r\nint q, same = 1;\r\nif (!latency_record[i].backtrace[0]) {\r\nif (firstnonnull > i)\r\nfirstnonnull = i;\r\ncontinue;\r\n}\r\nfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\r\nunsigned long record = lat->backtrace[q];\r\nif (latency_record[i].backtrace[q] != record) {\r\nsame = 0;\r\nbreak;\r\n}\r\nif (record == 0 || record == ULONG_MAX)\r\nbreak;\r\n}\r\nif (same) {\r\nlatency_record[i].count++;\r\nlatency_record[i].time += lat->time;\r\nif (lat->time > latency_record[i].max)\r\nlatency_record[i].max = lat->time;\r\nreturn;\r\n}\r\n}\r\ni = firstnonnull;\r\nif (i >= MAXLR - 1)\r\nreturn;\r\nmemcpy(&latency_record[i], lat, sizeof(struct latency_record));\r\n}\r\nstatic inline void store_stacktrace(struct task_struct *tsk,\r\nstruct latency_record *lat)\r\n{\r\nstruct stack_trace trace;\r\nmemset(&trace, 0, sizeof(trace));\r\ntrace.max_entries = LT_BACKTRACEDEPTH;\r\ntrace.entries = &lat->backtrace[0];\r\nsave_stack_trace_tsk(tsk, &trace);\r\n}\r\nvoid __sched\r\n__account_scheduler_latency(struct task_struct *tsk, int usecs, int inter)\r\n{\r\nunsigned long flags;\r\nint i, q;\r\nstruct latency_record lat;\r\nif (inter && usecs > 5000)\r\nreturn;\r\nif (usecs <= 0)\r\nreturn;\r\nmemset(&lat, 0, sizeof(lat));\r\nlat.count = 1;\r\nlat.time = usecs;\r\nlat.max = usecs;\r\nstore_stacktrace(tsk, &lat);\r\nraw_spin_lock_irqsave(&latency_lock, flags);\r\naccount_global_scheduler_latency(tsk, &lat);\r\nfor (i = 0; i < tsk->latency_record_count; i++) {\r\nstruct latency_record *mylat;\r\nint same = 1;\r\nmylat = &tsk->latency_record[i];\r\nfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\r\nunsigned long record = lat.backtrace[q];\r\nif (mylat->backtrace[q] != record) {\r\nsame = 0;\r\nbreak;\r\n}\r\nif (record == 0 || record == ULONG_MAX)\r\nbreak;\r\n}\r\nif (same) {\r\nmylat->count++;\r\nmylat->time += lat.time;\r\nif (lat.time > mylat->max)\r\nmylat->max = lat.time;\r\ngoto out_unlock;\r\n}\r\n}\r\nif (tsk->latency_record_count >= LT_SAVECOUNT)\r\ngoto out_unlock;\r\ni = tsk->latency_record_count++;\r\nmemcpy(&tsk->latency_record[i], &lat, sizeof(struct latency_record));\r\nout_unlock:\r\nraw_spin_unlock_irqrestore(&latency_lock, flags);\r\n}\r\nstatic int lstats_show(struct seq_file *m, void *v)\r\n{\r\nint i;\r\nseq_puts(m, "Latency Top version : v0.1\n");\r\nfor (i = 0; i < MAXLR; i++) {\r\nstruct latency_record *lr = &latency_record[i];\r\nif (lr->backtrace[0]) {\r\nint q;\r\nseq_printf(m, "%i %lu %lu",\r\nlr->count, lr->time, lr->max);\r\nfor (q = 0; q < LT_BACKTRACEDEPTH; q++) {\r\nunsigned long bt = lr->backtrace[q];\r\nif (!bt)\r\nbreak;\r\nif (bt == ULONG_MAX)\r\nbreak;\r\nseq_printf(m, " %ps", (void *)bt);\r\n}\r\nseq_puts(m, "\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nlstats_write(struct file *file, const char __user *buf, size_t count,\r\nloff_t *offs)\r\n{\r\nclear_global_latency_tracing();\r\nreturn count;\r\n}\r\nstatic int lstats_open(struct inode *inode, struct file *filp)\r\n{\r\nreturn single_open(filp, lstats_show, NULL);\r\n}\r\nstatic int __init init_lstats_procfs(void)\r\n{\r\nproc_create("latency_stats", 0644, NULL, &lstats_fops);\r\nreturn 0;\r\n}\r\nint sysctl_latencytop(struct ctl_table *table, int write,\r\nvoid __user *buffer, size_t *lenp, loff_t *ppos)\r\n{\r\nint err;\r\nerr = proc_dointvec(table, write, buffer, lenp, ppos);\r\nif (latencytop_enabled)\r\nforce_schedstat_enabled();\r\nreturn err;\r\n}
