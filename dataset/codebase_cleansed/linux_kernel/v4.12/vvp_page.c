static void vvp_page_fini_common(struct vvp_page *vpg)\r\n{\r\nstruct page *vmpage = vpg->vpg_page;\r\nLASSERT(vmpage);\r\nput_page(vmpage);\r\n}\r\nstatic void vvp_page_fini(const struct lu_env *env,\r\nstruct cl_page_slice *slice)\r\n{\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nstruct page *vmpage = vpg->vpg_page;\r\nLASSERT((struct cl_page *)vmpage->private != slice->cpl_page);\r\nvvp_page_fini_common(vpg);\r\n}\r\nstatic int vvp_page_own(const struct lu_env *env,\r\nconst struct cl_page_slice *slice, struct cl_io *io,\r\nint nonblock)\r\n{\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nstruct page *vmpage = vpg->vpg_page;\r\nLASSERT(vmpage);\r\nif (nonblock) {\r\nif (!trylock_page(vmpage))\r\nreturn -EAGAIN;\r\nif (unlikely(PageWriteback(vmpage))) {\r\nunlock_page(vmpage);\r\nreturn -EAGAIN;\r\n}\r\nreturn 0;\r\n}\r\nlock_page(vmpage);\r\nwait_on_page_writeback(vmpage);\r\nreturn 0;\r\n}\r\nstatic void vvp_page_assume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage);\r\nLASSERT(PageLocked(vmpage));\r\nwait_on_page_writeback(vmpage);\r\n}\r\nstatic void vvp_page_unassume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage);\r\nLASSERT(PageLocked(vmpage));\r\n}\r\nstatic void vvp_page_disown(const struct lu_env *env,\r\nconst struct cl_page_slice *slice, struct cl_io *io)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage);\r\nLASSERT(PageLocked(vmpage));\r\nunlock_page(cl2vm_page(slice));\r\n}\r\nstatic void vvp_page_discard(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nLASSERT(vmpage);\r\nLASSERT(PageLocked(vmpage));\r\nif (vpg->vpg_defer_uptodate && !vpg->vpg_ra_used)\r\nll_ra_stats_inc(vmpage->mapping->host, RA_STAT_DISCARDED);\r\nll_invalidate_page(vmpage);\r\n}\r\nstatic void vvp_page_delete(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct inode *inode = vmpage->mapping->host;\r\nstruct cl_object *obj = slice->cpl_obj;\r\nstruct cl_page *page = slice->cpl_page;\r\nint refc;\r\nLASSERT(PageLocked(vmpage));\r\nLASSERT((struct cl_page *)vmpage->private == page);\r\nLASSERT(inode == vvp_object_inode(obj));\r\nrefc = atomic_dec_return(&page->cp_ref);\r\nLASSERTF(refc >= 1, "page = %p, refc = %d\n", page, refc);\r\nClearPagePrivate(vmpage);\r\nvmpage->private = 0;\r\n}\r\nstatic void vvp_page_export(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint uptodate)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nLASSERT(vmpage);\r\nLASSERT(PageLocked(vmpage));\r\nif (uptodate)\r\nSetPageUptodate(vmpage);\r\nelse\r\nClearPageUptodate(vmpage);\r\n}\r\nstatic int vvp_page_is_vmlocked(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nreturn PageLocked(cl2vm_page(slice)) ? -EBUSY : -ENODATA;\r\n}\r\nstatic int vvp_page_prep_read(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nreturn PageUptodate(cl2vm_page(slice)) ? -EALREADY : 0;\r\n}\r\nstatic int vvp_page_prep_write(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nLASSERT(PageLocked(vmpage));\r\nLASSERT(!PageDirty(vmpage));\r\nif (!pg->cp_sync_io)\r\nset_page_writeback(vmpage);\r\nreturn 0;\r\n}\r\nstatic void vvp_vmpage_error(struct inode *inode, struct page *vmpage,\r\nint ioret)\r\n{\r\nstruct vvp_object *obj = cl_inode2vvp(inode);\r\nif (ioret == 0) {\r\nClearPageError(vmpage);\r\nobj->vob_discard_page_warned = 0;\r\n} else {\r\nSetPageError(vmpage);\r\nmapping_set_error(inode->i_mapping, ioret);\r\nif ((ioret == -ESHUTDOWN || ioret == -EINTR) &&\r\nobj->vob_discard_page_warned == 0) {\r\nobj->vob_discard_page_warned = 1;\r\nll_dirty_page_discard_warn(vmpage, ioret);\r\n}\r\n}\r\n}\r\nstatic void vvp_page_completion_read(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nstruct page *vmpage = vpg->vpg_page;\r\nstruct cl_page *page = slice->cpl_page;\r\nstruct inode *inode = vvp_object_inode(page->cp_obj);\r\nLASSERT(PageLocked(vmpage));\r\nCL_PAGE_HEADER(D_PAGE, env, page, "completing READ with %d\n", ioret);\r\nif (vpg->vpg_defer_uptodate)\r\nll_ra_count_put(ll_i2sbi(inode), 1);\r\nif (ioret == 0) {\r\nif (!vpg->vpg_defer_uptodate)\r\ncl_page_export(env, page, 1);\r\n} else {\r\nvpg->vpg_defer_uptodate = 0;\r\n}\r\nif (!page->cp_sync_io)\r\nunlock_page(vmpage);\r\n}\r\nstatic void vvp_page_completion_write(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nstruct page *vmpage = vpg->vpg_page;\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "completing WRITE with %d\n", ioret);\r\nif (pg->cp_sync_io) {\r\nLASSERT(PageLocked(vmpage));\r\nLASSERT(!PageWriteback(vmpage));\r\n} else {\r\nLASSERT(PageWriteback(vmpage));\r\nvvp_vmpage_error(vvp_object_inode(pg->cp_obj), vmpage, ioret);\r\nend_page_writeback(vmpage);\r\n}\r\n}\r\nstatic int vvp_page_make_ready(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct page *vmpage = cl2vm_page(slice);\r\nstruct cl_page *pg = slice->cpl_page;\r\nint result = 0;\r\nlock_page(vmpage);\r\nif (clear_page_dirty_for_io(vmpage)) {\r\nLASSERT(pg->cp_state == CPS_CACHED);\r\nset_page_writeback(vmpage);\r\nCL_PAGE_HEADER(D_PAGE, env, pg, "readied\n");\r\n} else if (pg->cp_state == CPS_PAGEOUT) {\r\nresult = -EALREADY;\r\n} else {\r\nCL_PAGE_DEBUG(D_ERROR, env, pg, "Unexpecting page state %d.\n",\r\npg->cp_state);\r\nLBUG();\r\n}\r\nunlock_page(vmpage);\r\nreturn result;\r\n}\r\nstatic int vvp_page_print(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nvoid *cookie, lu_printer_t printer)\r\n{\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nstruct page *vmpage = vpg->vpg_page;\r\n(*printer)(env, cookie, LUSTRE_VVP_NAME "-page@%p(%d:%d) vm@%p ",\r\nvpg, vpg->vpg_defer_uptodate, vpg->vpg_ra_used, vmpage);\r\nif (vmpage) {\r\n(*printer)(env, cookie, "%lx %d:%d %lx %lu %slru",\r\n(long)vmpage->flags, page_count(vmpage),\r\npage_mapcount(vmpage), vmpage->private,\r\nvmpage->index,\r\nlist_empty(&vmpage->lru) ? "not-" : "");\r\n}\r\n(*printer)(env, cookie, "\n");\r\nreturn 0;\r\n}\r\nstatic int vvp_page_fail(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nLBUG();\r\nreturn 0;\r\n}\r\nstatic int vvp_transient_page_prep(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nreturn 0;\r\n}\r\nstatic int vvp_transient_page_own(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused, int nonblock)\r\n{\r\nreturn 0;\r\n}\r\nstatic void vvp_transient_page_assume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\n}\r\nstatic void vvp_transient_page_unassume(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\n}\r\nstatic void vvp_transient_page_disown(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\n}\r\nstatic void vvp_transient_page_discard(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nstruct cl_io *unused)\r\n{\r\nstruct cl_page *page = slice->cpl_page;\r\ncl_page_delete(env, page);\r\n}\r\nstatic int vvp_transient_page_is_vmlocked(const struct lu_env *env,\r\nconst struct cl_page_slice *slice)\r\n{\r\nstruct inode *inode = vvp_object_inode(slice->cpl_obj);\r\nint locked;\r\nlocked = !inode_trylock(inode);\r\nif (!locked)\r\ninode_unlock(inode);\r\nreturn locked ? -EBUSY : -ENODATA;\r\n}\r\nstatic void\r\nvvp_transient_page_completion(const struct lu_env *env,\r\nconst struct cl_page_slice *slice,\r\nint ioret)\r\n{\r\n}\r\nstatic void vvp_transient_page_fini(const struct lu_env *env,\r\nstruct cl_page_slice *slice)\r\n{\r\nstruct vvp_page *vpg = cl2vvp_page(slice);\r\nstruct cl_page *clp = slice->cpl_page;\r\nstruct vvp_object *clobj = cl2vvp(clp->cp_obj);\r\nvvp_page_fini_common(vpg);\r\natomic_dec(&clobj->vob_transient_pages);\r\n}\r\nint vvp_page_init(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_page *page, pgoff_t index)\r\n{\r\nstruct vvp_page *vpg = cl_object_page_slice(obj, page);\r\nstruct page *vmpage = page->cp_vmpage;\r\nCLOBINVRNT(env, obj, vvp_object_invariant(obj));\r\nvpg->vpg_page = vmpage;\r\nget_page(vmpage);\r\nif (page->cp_type == CPT_CACHEABLE) {\r\natomic_inc(&page->cp_ref);\r\nSetPagePrivate(vmpage);\r\nvmpage->private = (unsigned long)page;\r\ncl_page_slice_add(page, &vpg->vpg_cl, obj, index,\r\n&vvp_page_ops);\r\n} else {\r\nstruct vvp_object *clobj = cl2vvp(obj);\r\ncl_page_slice_add(page, &vpg->vpg_cl, obj, index,\r\n&vvp_transient_page_ops);\r\natomic_inc(&clobj->vob_transient_pages);\r\n}\r\nreturn 0;\r\n}
