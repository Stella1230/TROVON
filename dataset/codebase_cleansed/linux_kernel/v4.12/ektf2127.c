static void ektf2127_parse_coordinates(const u8* buf, unsigned int touch_count,\r\nstruct input_mt_pos *touches)\r\n{\r\nint index = 0;\r\nint i;\r\nfor (i = 0; i < touch_count; i++) {\r\nindex = 2 + i * 3;\r\ntouches[i].x = (buf[index] & 0x0f);\r\ntouches[i].x <<= 8;\r\ntouches[i].x |= buf[index + 2];\r\ntouches[i].y = (buf[index] & 0xf0);\r\ntouches[i].y <<= 4;\r\ntouches[i].y |= buf[index + 1];\r\n}\r\n}\r\nstatic void ektf2127_report_event(struct ektf2127_ts *ts, const u8 *buf)\r\n{\r\nstruct input_mt_pos touches[EKTF2127_MAX_TOUCHES];\r\nint slots[EKTF2127_MAX_TOUCHES];\r\nunsigned int touch_count, i;\r\ntouch_count = buf[1] & 0x07;\r\nif (touch_count > EKTF2127_MAX_TOUCHES) {\r\ndev_err(&ts->client->dev,\r\n"Too many touches %d > %d\n",\r\ntouch_count, EKTF2127_MAX_TOUCHES);\r\ntouch_count = EKTF2127_MAX_TOUCHES;\r\n}\r\nektf2127_parse_coordinates(buf, touch_count, touches);\r\ninput_mt_assign_slots(ts->input, slots, touches,\r\ntouch_count, 0);\r\nfor (i = 0; i < touch_count; i++) {\r\ninput_mt_slot(ts->input, slots[i]);\r\ninput_mt_report_slot_state(ts->input, MT_TOOL_FINGER, true);\r\ntouchscreen_report_pos(ts->input, &ts->prop,\r\ntouches[i].x, touches[i].y, true);\r\n}\r\ninput_mt_sync_frame(ts->input);\r\ninput_sync(ts->input);\r\n}\r\nstatic irqreturn_t ektf2127_irq(int irq, void *dev_id)\r\n{\r\nstruct ektf2127_ts *ts = dev_id;\r\nstruct device *dev = &ts->client->dev;\r\nchar buf[EKTF2127_TOUCH_REPORT_SIZE];\r\nint ret;\r\nret = i2c_master_recv(ts->client, buf, EKTF2127_TOUCH_REPORT_SIZE);\r\nif (ret != EKTF2127_TOUCH_REPORT_SIZE) {\r\ndev_err(dev, "Error reading touch data: %d\n", ret);\r\ngoto out;\r\n}\r\nswitch (buf[0]) {\r\ncase EKTF2127_REPORT:\r\nektf2127_report_event(ts, buf);\r\nbreak;\r\ncase EKTF2127_NOISE:\r\nif (buf[1] == EKTF2127_ENV_NOISY)\r\ndev_dbg(dev, "Environment is electrically noisy\n");\r\nbreak;\r\ncase EKTF2127_HELLO:\r\ncase EKTF2127_CALIB_DONE:\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Unexpected packet header byte %#02x\n", buf[0]);\r\nbreak;\r\n}\r\nout:\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ektf2127_start(struct input_dev *dev)\r\n{\r\nstruct ektf2127_ts *ts = input_get_drvdata(dev);\r\nenable_irq(ts->client->irq);\r\ngpiod_set_value_cansleep(ts->power_gpios, 1);\r\nreturn 0;\r\n}\r\nstatic void ektf2127_stop(struct input_dev *dev)\r\n{\r\nstruct ektf2127_ts *ts = input_get_drvdata(dev);\r\ndisable_irq(ts->client->irq);\r\ngpiod_set_value_cansleep(ts->power_gpios, 0);\r\n}\r\nstatic int __maybe_unused ektf2127_suspend(struct device *dev)\r\n{\r\nstruct ektf2127_ts *ts = i2c_get_clientdata(to_i2c_client(dev));\r\nmutex_lock(&ts->input->mutex);\r\nif (ts->input->users)\r\nektf2127_stop(ts->input);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused ektf2127_resume(struct device *dev)\r\n{\r\nstruct ektf2127_ts *ts = i2c_get_clientdata(to_i2c_client(dev));\r\nmutex_lock(&ts->input->mutex);\r\nif (ts->input->users)\r\nektf2127_start(ts->input);\r\nmutex_unlock(&ts->input->mutex);\r\nreturn 0;\r\n}\r\nstatic int ektf2127_query_dimension(struct i2c_client *client, bool width)\r\n{\r\nstruct device *dev = &client->dev;\r\nconst char *what = width ? "width" : "height";\r\nu8 what_code = width ? EKTF2127_WIDTH : EKTF2127_HEIGHT;\r\nu8 buf[4];\r\nint ret;\r\nint error;\r\nbuf[0] = EKTF2127_REQUEST;\r\nbuf[1] = width ? EKTF2127_WIDTH : EKTF2127_HEIGHT;\r\nbuf[2] = 0x00;\r\nbuf[3] = 0x00;\r\nret = i2c_master_send(client, buf, sizeof(buf));\r\nif (ret != sizeof(buf)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(dev, "Failed to request %s: %d\n", what, error);\r\nreturn error;\r\n}\r\nmsleep(20);\r\nret = i2c_master_recv(client, buf, sizeof(buf));\r\nif (ret != sizeof(buf)) {\r\nerror = ret < 0 ? ret : -EIO;\r\ndev_err(dev, "Failed to receive %s data: %d\n", what, error);\r\nreturn error;\r\n}\r\nif (buf[0] != EKTF2127_RESPONSE || buf[1] != what_code) {\r\ndev_err(dev, "Unexpected %s data: %#02x %#02x\n",\r\nwhat, buf[0], buf[1]);\r\nreturn -EIO;\r\n}\r\nreturn (((buf[3] & 0xf0) << 4) | buf[2]) - 1;\r\n}\r\nstatic int ektf2127_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct ektf2127_ts *ts;\r\nstruct input_dev *input;\r\nu8 buf[4];\r\nint max_x, max_y;\r\nint error;\r\nif (!client->irq) {\r\ndev_err(dev, "Error no irq specified\n");\r\nreturn -EINVAL;\r\n}\r\nts = devm_kzalloc(dev, sizeof(*ts), GFP_KERNEL);\r\nif (!ts)\r\nreturn -ENOMEM;\r\nts->power_gpios = devm_gpiod_get(dev, "power", GPIOD_OUT_HIGH);\r\nif (IS_ERR(ts->power_gpios)) {\r\nerror = PTR_ERR(ts->power_gpios);\r\nif (error != -EPROBE_DEFER)\r\ndev_err(dev, "Error getting power gpio: %d\n", error);\r\nreturn error;\r\n}\r\ninput = devm_input_allocate_device(dev);\r\nif (!input)\r\nreturn -ENOMEM;\r\ninput->name = client->name;\r\ninput->id.bustype = BUS_I2C;\r\ninput->open = ektf2127_start;\r\ninput->close = ektf2127_stop;\r\nts->client = client;\r\nmsleep(20);\r\ni2c_master_recv(ts->client, buf, sizeof(buf));\r\nmax_x = ektf2127_query_dimension(client, true);\r\nif (max_x < 0)\r\nreturn max_x;\r\nmax_y = ektf2127_query_dimension(client, false);\r\nif (max_y < 0)\r\nreturn max_y;\r\ninput_set_abs_params(input, ABS_MT_POSITION_X, 0, max_x, 0, 0);\r\ninput_set_abs_params(input, ABS_MT_POSITION_Y, 0, max_y, 0, 0);\r\ntouchscreen_parse_properties(input, true, &ts->prop);\r\nerror = input_mt_init_slots(input, EKTF2127_MAX_TOUCHES,\r\nINPUT_MT_DIRECT |\r\nINPUT_MT_DROP_UNUSED |\r\nINPUT_MT_TRACK);\r\nif (error)\r\nreturn error;\r\nts->input = input;\r\ninput_set_drvdata(input, ts);\r\nerror = devm_request_threaded_irq(dev, client->irq,\r\nNULL, ektf2127_irq,\r\nIRQF_ONESHOT, client->name, ts);\r\nif (error) {\r\ndev_err(dev, "Error requesting irq: %d\n", error);\r\nreturn error;\r\n}\r\nektf2127_stop(ts->input);\r\nerror = input_register_device(input);\r\nif (error)\r\nreturn error;\r\ni2c_set_clientdata(client, ts);\r\nreturn 0;\r\n}
