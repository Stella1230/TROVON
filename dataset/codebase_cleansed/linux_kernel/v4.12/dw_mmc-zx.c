static int dw_mci_zx_emmc_set_delay(struct dw_mci *host, unsigned int delay,\r\nenum delay_type dflag)\r\n{\r\nstruct dw_mci_zx_priv_data *priv = host->priv;\r\nstruct regmap *sysc_base = priv->sysc_base;\r\nunsigned int clksel;\r\nunsigned int loop = 1000;\r\nint ret;\r\nif (!sysc_base)\r\nreturn -EINVAL;\r\nret = regmap_update_bits(sysc_base, LB_AON_EMMC_CFG_REG0,\r\nPARA_HALF_CLK_MODE | PARA_DLL_BYPASS_MODE |\r\nPARA_PHASE_DET_SEL_MASK |\r\nPARA_DLL_LOCK_NUM_MASK |\r\nDLL_REG_SET | PARA_DLL_START_MASK,\r\nPARA_DLL_START(4) | PARA_DLL_LOCK_NUM(4));\r\nif (ret)\r\nreturn ret;\r\nret = regmap_read(sysc_base, LB_AON_EMMC_CFG_REG1, &clksel);\r\nif (ret)\r\nreturn ret;\r\nif (dflag == DELAY_TYPE_CLK) {\r\nclksel &= ~CLK_SAMP_DELAY_MASK;\r\nclksel |= CLK_SAMP_DELAY(delay);\r\n} else {\r\nclksel &= ~READ_DQS_DELAY_MASK;\r\nclksel |= READ_DQS_DELAY(delay);\r\n}\r\nregmap_write(sysc_base, LB_AON_EMMC_CFG_REG1, clksel);\r\nregmap_update_bits(sysc_base, LB_AON_EMMC_CFG_REG0,\r\nPARA_DLL_START_MASK | PARA_DLL_LOCK_NUM_MASK |\r\nDLL_REG_SET,\r\nPARA_DLL_START(4) | PARA_DLL_LOCK_NUM(4) |\r\nDLL_REG_SET);\r\ndo {\r\nret = regmap_read(sysc_base, LB_AON_EMMC_CFG_REG2, &clksel);\r\nif (ret)\r\nreturn ret;\r\n} while (--loop && !(clksel & ZX_DLL_LOCKED));\r\nif (!loop) {\r\ndev_err(host->dev, "Error: %s dll lock fail\n", __func__);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dw_mci_zx_emmc_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\r\n{\r\nstruct dw_mci *host = slot->host;\r\nstruct mmc_host *mmc = slot->mmc;\r\nint ret, len = 0, start = 0, end = 0, delay, best = 0;\r\nfor (delay = 1; delay < 128; delay++) {\r\nret = dw_mci_zx_emmc_set_delay(host, delay, DELAY_TYPE_CLK);\r\nif (!ret && mmc_send_tuning(mmc, opcode, NULL)) {\r\nif (start >= 0) {\r\nend = delay - 1;\r\nif ((end - start) > len) {\r\nbest = (start + end) >> 1;\r\nlen = end - start;\r\n}\r\n}\r\nstart = -1;\r\nend = 0;\r\ncontinue;\r\n}\r\nif (start < 0)\r\nstart = delay;\r\n}\r\nif (start >= 0) {\r\nend = delay - 1;\r\nif ((end - start) > len) {\r\nbest = (start + end) >> 1;\r\nlen = end - start;\r\n}\r\n}\r\nif (best < 0)\r\nreturn -EIO;\r\ndev_info(host->dev, "%s best range: start %d end %d\n", __func__,\r\nstart, end);\r\nreturn dw_mci_zx_emmc_set_delay(host, best, DELAY_TYPE_CLK);\r\n}\r\nstatic int dw_mci_zx_prepare_hs400_tuning(struct dw_mci *host,\r\nstruct mmc_ios *ios)\r\n{\r\nint ret;\r\nret = dw_mci_zx_emmc_set_delay(host, 32, DELAY_TYPE_READ);\r\nif (ret < 0)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nstatic int dw_mci_zx_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\r\n{\r\nstruct dw_mci *host = slot->host;\r\nif (host->verid == 0x290a)\r\nreturn dw_mci_zx_emmc_execute_tuning(slot, opcode);\r\nreturn 0;\r\n}\r\nstatic int dw_mci_zx_parse_dt(struct dw_mci *host)\r\n{\r\nstruct device_node *np = host->dev->of_node;\r\nstruct device_node *node;\r\nstruct dw_mci_zx_priv_data *priv;\r\nstruct regmap *sysc_base;\r\nint ret;\r\nnode = of_parse_phandle(np, "zte,aon-syscon", 0);\r\nif (node) {\r\nsysc_base = syscon_node_to_regmap(node);\r\nof_node_put(node);\r\nif (IS_ERR(sysc_base)) {\r\nret = PTR_ERR(sysc_base);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(host->dev, "Can't get syscon: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n} else {\r\nreturn 0;\r\n}\r\npriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->sysc_base = sysc_base;\r\nhost->priv = priv;\r\nreturn 0;\r\n}\r\nstatic int dw_mci_zx_probe(struct platform_device *pdev)\r\n{\r\nconst struct dw_mci_drv_data *drv_data;\r\nconst struct of_device_id *match;\r\nmatch = of_match_node(dw_mci_zx_match, pdev->dev.of_node);\r\ndrv_data = match->data;\r\nreturn dw_mci_pltfm_register(pdev, drv_data);\r\n}
