static int m88rs6000t_set_demod_mclk(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nu8 reg11, reg15, reg16, reg1D, reg1E, reg1F;\r\nu8 N, f0 = 0, f1 = 0, f2 = 0, f3 = 0;\r\nu16 pll_div_fb;\r\nu32 div, ts_mclk;\r\nunsigned int utmp;\r\nint ret;\r\nret = regmap_read(dev->regmap, 0x15, &utmp);\r\nif (ret)\r\ngoto err;\r\nreg15 = utmp;\r\nif (c->symbol_rate > 45010000) {\r\nreg11 = 0x0E;\r\nreg15 |= 0x02;\r\nreg16 = 115;\r\n} else {\r\nreg11 = 0x0A;\r\nreg15 &= ~0x02;\r\nreg16 = 96;\r\n}\r\nif (c->delivery_system == SYS_DVBS)\r\nts_mclk = 96000;\r\nelse\r\nts_mclk = 144000;\r\npll_div_fb = (reg15 & 0x01) << 8;\r\npll_div_fb += reg16;\r\npll_div_fb += 32;\r\ndiv = 36000 * pll_div_fb;\r\ndiv /= ts_mclk;\r\nif (div <= 32) {\r\nN = 2;\r\nf0 = 0;\r\nf1 = div / 2;\r\nf2 = div - f1;\r\nf3 = 0;\r\n} else if (div <= 48) {\r\nN = 3;\r\nf0 = div / 3;\r\nf1 = (div - f0) / 2;\r\nf2 = div - f0 - f1;\r\nf3 = 0;\r\n} else if (div <= 64) {\r\nN = 4;\r\nf0 = div / 4;\r\nf1 = (div - f0) / 3;\r\nf2 = (div - f0 - f1) / 2;\r\nf3 = div - f0 - f1 - f2;\r\n} else {\r\nN = 4;\r\nf0 = 16;\r\nf1 = 16;\r\nf2 = 16;\r\nf3 = 16;\r\n}\r\nif (f0 == 16)\r\nf0 = 0;\r\nif (f1 == 16)\r\nf1 = 0;\r\nif (f2 == 16)\r\nf2 = 0;\r\nif (f3 == 16)\r\nf3 = 0;\r\nret = regmap_read(dev->regmap, 0x1D, &utmp);\r\nif (ret)\r\ngoto err;\r\nreg1D = utmp;\r\nreg1D &= ~0x03;\r\nreg1D |= N - 1;\r\nreg1E = ((f3 << 4) + f2) & 0xFF;\r\nreg1F = ((f1 << 4) + f0) & 0xFF;\r\nret = regmap_write(dev->regmap, 0x05, 0x40);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x11, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x15, reg15);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x16, reg16);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1D, reg1D);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1E, reg1E);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x1F, reg1F);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x17, 0xc1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x17, 0x81);\r\nif (ret)\r\ngoto err;\r\nusleep_range(5000, 50000);\r\nret = regmap_write(dev->regmap, 0x05, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x11, reg11);\r\nif (ret)\r\ngoto err;\r\nusleep_range(5000, 50000);\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88rs6000t_set_pll_freq(struct m88rs6000t_dev *dev,\r\nu32 tuner_freq_MHz)\r\n{\r\nu32 fcry_KHz, ulNDiv1, ulNDiv2, ulNDiv;\r\nu8 refDiv, ucLoDiv1, ucLomod1, ucLoDiv2, ucLomod2, ucLoDiv, ucLomod;\r\nu8 reg27, reg29, reg42, reg42buf;\r\nunsigned int utmp;\r\nint ret;\r\nfcry_KHz = 27000;\r\nrefDiv = 27;\r\nret = regmap_write(dev->regmap, 0x36, (refDiv - 8));\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x31, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x2c, 0x02);\r\nif (ret)\r\ngoto err;\r\nif (tuner_freq_MHz >= 1550) {\r\nucLoDiv1 = 2;\r\nucLomod1 = 0;\r\nucLoDiv2 = 2;\r\nucLomod2 = 0;\r\n} else if (tuner_freq_MHz >= 1380) {\r\nucLoDiv1 = 3;\r\nucLomod1 = 16;\r\nucLoDiv2 = 2;\r\nucLomod2 = 0;\r\n} else if (tuner_freq_MHz >= 1070) {\r\nucLoDiv1 = 3;\r\nucLomod1 = 16;\r\nucLoDiv2 = 3;\r\nucLomod2 = 16;\r\n} else if (tuner_freq_MHz >= 1000) {\r\nucLoDiv1 = 3;\r\nucLomod1 = 16;\r\nucLoDiv2 = 4;\r\nucLomod2 = 64;\r\n} else if (tuner_freq_MHz >= 775) {\r\nucLoDiv1 = 4;\r\nucLomod1 = 64;\r\nucLoDiv2 = 4;\r\nucLomod2 = 64;\r\n} else if (tuner_freq_MHz >= 700) {\r\nucLoDiv1 = 6;\r\nucLomod1 = 48;\r\nucLoDiv2 = 4;\r\nucLomod2 = 64;\r\n} else if (tuner_freq_MHz >= 520) {\r\nucLoDiv1 = 6;\r\nucLomod1 = 48;\r\nucLoDiv2 = 6;\r\nucLomod2 = 48;\r\n} else {\r\nucLoDiv1 = 8;\r\nucLomod1 = 96;\r\nucLoDiv2 = 8;\r\nucLomod2 = 96;\r\n}\r\nulNDiv1 = ((tuner_freq_MHz * ucLoDiv1 * 1000) * refDiv\r\n/ fcry_KHz - 1024) / 2;\r\nulNDiv2 = ((tuner_freq_MHz * ucLoDiv2 * 1000) * refDiv\r\n/ fcry_KHz - 1024) / 2;\r\nreg27 = (((ulNDiv1 >> 8) & 0x0F) + ucLomod1) & 0x7F;\r\nret = regmap_write(dev->regmap, 0x27, reg27);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x28, (u8)(ulNDiv1 & 0xFF));\r\nif (ret)\r\ngoto err;\r\nreg29 = (((ulNDiv2 >> 8) & 0x0F) + ucLomod2) & 0x7f;\r\nret = regmap_write(dev->regmap, 0x29, reg29);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x2a, (u8)(ulNDiv2 & 0xFF));\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x2F, 0xf5);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x30, 0x05);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x1f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x3f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x09, 0x20);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x09, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x3e, 0x11);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x2f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x3f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x09, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x09, 0x00);\r\nif (ret)\r\ngoto err;\r\nusleep_range(2000, 50000);\r\nret = regmap_read(dev->regmap, 0x42, &utmp);\r\nif (ret)\r\ngoto err;\r\nreg42 = utmp;\r\nret = regmap_write(dev->regmap, 0x3e, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x2f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x08, 0x3f);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x09, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x09, 0x00);\r\nif (ret)\r\ngoto err;\r\nusleep_range(2000, 50000);\r\nret = regmap_read(dev->regmap, 0x42, &utmp);\r\nif (ret)\r\ngoto err;\r\nreg42buf = utmp;\r\nif (reg42buf < reg42) {\r\nret = regmap_write(dev->regmap, 0x3e, 0x11);\r\nif (ret)\r\ngoto err;\r\n}\r\nusleep_range(5000, 50000);\r\nret = regmap_read(dev->regmap, 0x2d, &utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x2d, utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0x2e, &utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x2e, utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0x27, &utmp);\r\nif (ret)\r\ngoto err;\r\nreg27 = utmp & 0x70;\r\nret = regmap_read(dev->regmap, 0x83, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (reg27 == (utmp & 0x70)) {\r\nucLoDiv = ucLoDiv1;\r\nulNDiv = ulNDiv1;\r\nucLomod = ucLomod1 / 16;\r\n} else {\r\nucLoDiv = ucLoDiv2;\r\nulNDiv = ulNDiv2;\r\nucLomod = ucLomod2 / 16;\r\n}\r\nif ((ucLoDiv == 3) || (ucLoDiv == 6)) {\r\nrefDiv = 18;\r\nret = regmap_write(dev->regmap, 0x36, (refDiv - 8));\r\nif (ret)\r\ngoto err;\r\nulNDiv = ((tuner_freq_MHz * ucLoDiv * 1000) * refDiv\r\n/ fcry_KHz - 1024) / 2;\r\n}\r\nreg27 = (0x80 + ((ucLomod << 4) & 0x70)\r\n+ ((ulNDiv >> 8) & 0x0F)) & 0xFF;\r\nret = regmap_write(dev->regmap, 0x27, reg27);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x28, (u8)(ulNDiv & 0xFF));\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x29, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x31, 0x03);\r\nif (ret)\r\ngoto err;\r\nif (ucLoDiv == 3)\r\nutmp = 0xCE;\r\nelse\r\nutmp = 0x8A;\r\nret = regmap_write(dev->regmap, 0x3b, utmp);\r\nif (ret)\r\ngoto err;\r\ndev->frequency_khz = fcry_KHz * (ulNDiv * 2 + 1024) / refDiv / ucLoDiv;\r\ndev_dbg(&dev->client->dev,\r\n"actual tune frequency=%d\n", dev->frequency_khz);\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88rs6000t_set_bb(struct m88rs6000t_dev *dev,\r\nu32 symbol_rate_KSs, s32 lpf_offset_KHz)\r\n{\r\nu32 f3dB;\r\nu8 reg40;\r\nf3dB = symbol_rate_KSs * 9 / 14 + 2000;\r\nf3dB += lpf_offset_KHz;\r\nf3dB = clamp_val(f3dB, 6000U, 43000U);\r\nreg40 = f3dB / 1000;\r\nreturn regmap_write(dev->regmap, 0x40, reg40);\r\n}\r\nstatic int m88rs6000t_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\ns32 lpf_offset_KHz;\r\nu32 realFreq, freq_MHz;\r\ndev_dbg(&dev->client->dev,\r\n"frequency=%d symbol_rate=%d\n",\r\nc->frequency, c->symbol_rate);\r\nif (c->symbol_rate < 5000000)\r\nlpf_offset_KHz = 3000;\r\nelse\r\nlpf_offset_KHz = 0;\r\nrealFreq = c->frequency + lpf_offset_KHz;\r\nfreq_MHz = (realFreq + 500) / 1000;\r\nret = m88rs6000t_set_pll_freq(dev, freq_MHz);\r\nif (ret)\r\ngoto err;\r\nret = m88rs6000t_set_bb(dev, c->symbol_rate / 1000, lpf_offset_KHz);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x00, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x00, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = m88rs6000t_set_demod_mclk(fe);\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88rs6000t_init(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&dev->client->dev, "%s:\n", __func__);\r\nret = regmap_update_bits(dev->regmap, 0x11, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nusleep_range(5000, 50000);\r\nret = regmap_update_bits(dev->regmap, 0x10, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nret = regmap_write(dev->regmap, 0x07, 0x7d);\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88rs6000t_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\nint ret;\r\ndev_dbg(&dev->client->dev, "%s:\n", __func__);\r\nret = regmap_write(dev->regmap, 0x07, 0x6d);\r\nif (ret) {\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nusleep_range(5000, 10000);\r\nreturn 0;\r\n}\r\nstatic int m88rs6000t_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\ndev_dbg(&dev->client->dev, "\n");\r\n*frequency = dev->frequency_khz;\r\nreturn 0;\r\n}\r\nstatic int m88rs6000t_get_if_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\ndev_dbg(&dev->client->dev, "\n");\r\n*frequency = 0;\r\nreturn 0;\r\n}\r\nstatic int m88rs6000t_get_rf_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct m88rs6000t_dev *dev = fe->tuner_priv;\r\nunsigned int val, i;\r\nint ret;\r\nu16 gain;\r\nu32 PGA2_cri_GS = 46, PGA2_crf_GS = 290, TIA_GS = 290;\r\nu32 RF_GC = 1200, IF_GC = 1100, BB_GC = 300;\r\nu32 PGA2_GC = 300, TIA_GC = 300, PGA2_cri = 0, PGA2_crf = 0;\r\nu32 RFG = 0, IFG = 0, BBG = 0, PGA2G = 0, TIAG = 0;\r\nu32 RFGS[13] = {0, 245, 266, 268, 270, 285,\r\n298, 295, 283, 285, 285, 300, 300};\r\nu32 IFGS[12] = {0, 300, 230, 270, 270, 285,\r\n295, 285, 290, 295, 295, 310};\r\nu32 BBGS[14] = {0, 286, 275, 290, 294, 300, 290,\r\n290, 285, 283, 260, 295, 290, 260};\r\nret = regmap_read(dev->regmap, 0x5A, &val);\r\nif (ret)\r\ngoto err;\r\nRF_GC = val & 0x0f;\r\nret = regmap_read(dev->regmap, 0x5F, &val);\r\nif (ret)\r\ngoto err;\r\nIF_GC = val & 0x0f;\r\nret = regmap_read(dev->regmap, 0x3F, &val);\r\nif (ret)\r\ngoto err;\r\nTIA_GC = (val >> 4) & 0x07;\r\nret = regmap_read(dev->regmap, 0x77, &val);\r\nif (ret)\r\ngoto err;\r\nBB_GC = (val >> 4) & 0x0f;\r\nret = regmap_read(dev->regmap, 0x76, &val);\r\nif (ret)\r\ngoto err;\r\nPGA2_GC = val & 0x3f;\r\nPGA2_cri = PGA2_GC >> 2;\r\nPGA2_crf = PGA2_GC & 0x03;\r\nfor (i = 0; i <= RF_GC; i++)\r\nRFG += RFGS[i];\r\nif (RF_GC == 0)\r\nRFG += 400;\r\nif (RF_GC == 1)\r\nRFG += 300;\r\nif (RF_GC == 2)\r\nRFG += 200;\r\nif (RF_GC == 3)\r\nRFG += 100;\r\nfor (i = 0; i <= IF_GC; i++)\r\nIFG += IFGS[i];\r\nTIAG = TIA_GC * TIA_GS;\r\nfor (i = 0; i <= BB_GC; i++)\r\nBBG += BBGS[i];\r\nPGA2G = PGA2_cri * PGA2_cri_GS + PGA2_crf * PGA2_crf_GS;\r\ngain = RFG + IFG - TIAG + BBG + PGA2G;\r\ngain = clamp_val(gain, 1000U, 10500U);\r\n*strength = (10500 - gain) * 0xffff / (10500 - 1000);\r\nerr:\r\nif (ret)\r\ndev_dbg(&dev->client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int m88rs6000t_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct m88rs6000t_config *cfg = client->dev.platform_data;\r\nstruct dvb_frontend *fe = cfg->fe;\r\nstruct m88rs6000t_dev *dev;\r\nint ret, i;\r\nunsigned int utmp;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 8,\r\n.val_bits = 8,\r\n};\r\nstatic const struct m88rs6000t_reg_val reg_vals[] = {\r\n{0x10, 0xfb},\r\n{0x24, 0x38},\r\n{0x11, 0x0a},\r\n{0x12, 0x00},\r\n{0x2b, 0x1c},\r\n{0x44, 0x48},\r\n{0x54, 0x24},\r\n{0x55, 0x06},\r\n{0x59, 0x00},\r\n{0x5b, 0x4c},\r\n{0x60, 0x8b},\r\n{0x61, 0xf4},\r\n{0x65, 0x07},\r\n{0x6d, 0x6f},\r\n{0x6e, 0x31},\r\n{0x3c, 0xf3},\r\n{0x37, 0x0f},\r\n{0x48, 0x28},\r\n{0x49, 0xd8},\r\n{0x70, 0x66},\r\n{0x71, 0xCF},\r\n{0x72, 0x81},\r\n{0x73, 0xA7},\r\n{0x74, 0x4F},\r\n{0x75, 0xFC},\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ndev_err(&client->dev, "kzalloc() failed\n");\r\ngoto err;\r\n}\r\nmemcpy(&dev->cfg, cfg, sizeof(struct m88rs6000t_config));\r\ndev->client = client;\r\ndev->regmap = devm_regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err;\r\n}\r\nret = regmap_update_bits(dev->regmap, 0x11, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nusleep_range(5000, 50000);\r\nret = regmap_update_bits(dev->regmap, 0x10, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nret = regmap_write(dev->regmap, 0x07, 0x7d);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x04, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read(dev->regmap, 0x01, &utmp);\r\nif (ret)\r\ngoto err;\r\ndev_info(&dev->client->dev, "chip_id=%02x\n", utmp);\r\nif (utmp != 0x64) {\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = regmap_write(dev->regmap, 0x05, 0x40);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x11, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x15, 0x6c);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x17, 0xc1);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x17, 0x81);\r\nif (ret)\r\ngoto err;\r\nusleep_range(10000, 50000);\r\nret = regmap_write(dev->regmap, 0x05, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x11, 0x0a);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < ARRAY_SIZE(reg_vals); i++) {\r\nret = regmap_write(dev->regmap,\r\nreg_vals[i].reg, reg_vals[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_info(&dev->client->dev, "Montage M88RS6000 internal tuner successfully identified\n");\r\nfe->tuner_priv = dev;\r\nmemcpy(&fe->ops.tuner_ops, &m88rs6000t_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\ni2c_set_clientdata(client, dev);\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nkfree(dev);\r\nreturn ret;\r\n}\r\nstatic int m88rs6000t_remove(struct i2c_client *client)\r\n{\r\nstruct m88rs6000t_dev *dev = i2c_get_clientdata(client);\r\nstruct dvb_frontend *fe = dev->cfg.fe;\r\ndev_dbg(&client->dev, "\n");\r\nmemset(&fe->ops.tuner_ops, 0, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = NULL;\r\nkfree(dev);\r\nreturn 0;\r\n}
