void\r\niscsi_iser_recv(struct iscsi_conn *conn, struct iscsi_hdr *hdr,\r\nchar *rx_data, int rx_data_len)\r\n{\r\nint rc = 0;\r\nint datalen;\r\ndatalen = ntoh24(hdr->dlength);\r\nif (datalen > rx_data_len || (datalen + 4) < rx_data_len) {\r\niser_err("wrong datalen %d (hdr), %d (IB)\n",\r\ndatalen, rx_data_len);\r\nrc = ISCSI_ERR_DATALEN;\r\ngoto error;\r\n}\r\nif (datalen != rx_data_len)\r\niser_dbg("aligned datalen (%d) hdr, %d (IB)\n",\r\ndatalen, rx_data_len);\r\nrc = iscsi_complete_pdu(conn, hdr, rx_data, rx_data_len);\r\nif (rc && rc != ISCSI_ERR_NO_SCSI_CMD)\r\ngoto error;\r\nreturn;\r\nerror:\r\niscsi_conn_failure(conn, rc);\r\n}\r\nstatic int\r\niscsi_iser_pdu_alloc(struct iscsi_task *task, uint8_t opcode)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\ntask->hdr = (struct iscsi_hdr *)&iser_task->desc.iscsi_header;\r\ntask->hdr_max = sizeof(iser_task->desc.iscsi_header);\r\nreturn 0;\r\n}\r\nint\r\niser_initialize_task_headers(struct iscsi_task *task,\r\nstruct iser_tx_desc *tx_desc)\r\n{\r\nstruct iser_conn *iser_conn = task->conn->dd_data;\r\nstruct iser_device *device = iser_conn->ib_conn.device;\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nu64 dma_addr;\r\nconst bool mgmt_task = !task->sc && !in_interrupt();\r\nint ret = 0;\r\nif (unlikely(mgmt_task))\r\nmutex_lock(&iser_conn->state_mutex);\r\nif (unlikely(iser_conn->state != ISER_CONN_UP)) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\ndma_addr = ib_dma_map_single(device->ib_device, (void *)tx_desc,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\nif (ib_dma_mapping_error(device->ib_device, dma_addr)) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ntx_desc->wr_idx = 0;\r\ntx_desc->mapped = true;\r\ntx_desc->dma_addr = dma_addr;\r\ntx_desc->tx_sg[0].addr = tx_desc->dma_addr;\r\ntx_desc->tx_sg[0].length = ISER_HEADERS_LEN;\r\ntx_desc->tx_sg[0].lkey = device->pd->local_dma_lkey;\r\niser_task->iser_conn = iser_conn;\r\nout:\r\nif (unlikely(mgmt_task))\r\nmutex_unlock(&iser_conn->state_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\niscsi_iser_task_init(struct iscsi_task *task)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nint ret;\r\nret = iser_initialize_task_headers(task, &iser_task->desc);\r\nif (ret) {\r\niser_err("Failed to init task %p, err = %d\n",\r\niser_task, ret);\r\nreturn ret;\r\n}\r\nif (!task->sc)\r\nreturn 0;\r\niser_task->command_sent = 0;\r\niser_task_rdma_init(iser_task);\r\niser_task->sc = task->sc;\r\nreturn 0;\r\n}\r\nstatic int\r\niscsi_iser_mtask_xmit(struct iscsi_conn *conn, struct iscsi_task *task)\r\n{\r\nint error = 0;\r\niser_dbg("mtask xmit [cid %d itt 0x%x]\n", conn->id, task->itt);\r\nerror = iser_send_control(conn, task);\r\nreturn error;\r\n}\r\nstatic int\r\niscsi_iser_task_xmit_unsol_data(struct iscsi_conn *conn,\r\nstruct iscsi_task *task)\r\n{\r\nstruct iscsi_r2t_info *r2t = &task->unsol_r2t;\r\nstruct iscsi_data hdr;\r\nint error = 0;\r\nwhile (iscsi_task_has_unsol_data(task)) {\r\niscsi_prep_data_out_pdu(task, r2t, &hdr);\r\niser_dbg("Sending data-out: itt 0x%x, data count %d\n",\r\nhdr.itt, r2t->data_count);\r\nerror = iser_send_data_out(conn, task, &hdr);\r\nif (error) {\r\nr2t->datasn--;\r\ngoto iscsi_iser_task_xmit_unsol_data_exit;\r\n}\r\nr2t->sent += r2t->data_count;\r\niser_dbg("Need to send %d more as data-out PDUs\n",\r\nr2t->data_length - r2t->sent);\r\n}\r\niscsi_iser_task_xmit_unsol_data_exit:\r\nreturn error;\r\n}\r\nstatic int\r\niscsi_iser_task_xmit(struct iscsi_task *task)\r\n{\r\nstruct iscsi_conn *conn = task->conn;\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nint error = 0;\r\nif (!task->sc)\r\nreturn iscsi_iser_mtask_xmit(conn, task);\r\nif (task->sc->sc_data_direction == DMA_TO_DEVICE) {\r\nBUG_ON(scsi_bufflen(task->sc) == 0);\r\niser_dbg("cmd [itt %x total %d imm %d unsol_data %d\n",\r\ntask->itt, scsi_bufflen(task->sc),\r\ntask->imm_count, task->unsol_r2t.data_length);\r\n}\r\niser_dbg("ctask xmit [cid %d itt 0x%x]\n",\r\nconn->id, task->itt);\r\nif (!iser_task->command_sent) {\r\nerror = iser_send_command(conn, task);\r\nif (error)\r\ngoto iscsi_iser_task_xmit_exit;\r\niser_task->command_sent = 1;\r\n}\r\nif (iscsi_task_has_unsol_data(task))\r\nerror = iscsi_iser_task_xmit_unsol_data(conn, task);\r\niscsi_iser_task_xmit_exit:\r\nreturn error;\r\n}\r\nstatic void iscsi_iser_cleanup_task(struct iscsi_task *task)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nstruct iser_tx_desc *tx_desc = &iser_task->desc;\r\nstruct iser_conn *iser_conn = task->conn->dd_data;\r\nstruct iser_device *device = iser_conn->ib_conn.device;\r\nif (!device)\r\nreturn;\r\nif (likely(tx_desc->mapped)) {\r\nib_dma_unmap_single(device->ib_device, tx_desc->dma_addr,\r\nISER_HEADERS_LEN, DMA_TO_DEVICE);\r\ntx_desc->mapped = false;\r\n}\r\nif (!task->sc)\r\nreturn;\r\nif (iser_task->status == ISER_TASK_STATUS_STARTED) {\r\niser_task->status = ISER_TASK_STATUS_COMPLETED;\r\niser_task_rdma_finalize(iser_task);\r\n}\r\n}\r\nstatic u8\r\niscsi_iser_check_protection(struct iscsi_task *task, sector_t *sector)\r\n{\r\nstruct iscsi_iser_task *iser_task = task->dd_data;\r\nif (iser_task->dir[ISER_DIR_IN])\r\nreturn iser_check_task_pi_status(iser_task, ISER_DIR_IN,\r\nsector);\r\nelse\r\nreturn iser_check_task_pi_status(iser_task, ISER_DIR_OUT,\r\nsector);\r\n}\r\nstatic struct iscsi_cls_conn *\r\niscsi_iser_conn_create(struct iscsi_cls_session *cls_session,\r\nuint32_t conn_idx)\r\n{\r\nstruct iscsi_conn *conn;\r\nstruct iscsi_cls_conn *cls_conn;\r\ncls_conn = iscsi_conn_setup(cls_session, 0, conn_idx);\r\nif (!cls_conn)\r\nreturn NULL;\r\nconn = cls_conn->dd_data;\r\nconn->max_recv_dlength = ISER_RECV_DATA_SEG_LEN;\r\nreturn cls_conn;\r\n}\r\nstatic int\r\niscsi_iser_conn_bind(struct iscsi_cls_session *cls_session,\r\nstruct iscsi_cls_conn *cls_conn,\r\nuint64_t transport_eph,\r\nint is_leading)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iser_conn *iser_conn;\r\nstruct iscsi_endpoint *ep;\r\nint error;\r\nerror = iscsi_conn_bind(cls_session, cls_conn, is_leading);\r\nif (error)\r\nreturn error;\r\nep = iscsi_lookup_endpoint(transport_eph);\r\nif (!ep) {\r\niser_err("can't bind eph %llx\n",\r\n(unsigned long long)transport_eph);\r\nreturn -EINVAL;\r\n}\r\niser_conn = ep->dd_data;\r\nmutex_lock(&iser_conn->state_mutex);\r\nif (iser_conn->state != ISER_CONN_UP) {\r\nerror = -EINVAL;\r\niser_err("iser_conn %p state is %d, teardown started\n",\r\niser_conn, iser_conn->state);\r\ngoto out;\r\n}\r\nerror = iser_alloc_rx_descriptors(iser_conn, conn->session);\r\nif (error)\r\ngoto out;\r\niser_info("binding iscsi conn %p to iser_conn %p\n", conn, iser_conn);\r\nconn->dd_data = iser_conn;\r\niser_conn->iscsi_conn = conn;\r\nout:\r\nmutex_unlock(&iser_conn->state_mutex);\r\nreturn error;\r\n}\r\nstatic int\r\niscsi_iser_conn_start(struct iscsi_cls_conn *cls_conn)\r\n{\r\nstruct iscsi_conn *iscsi_conn;\r\nstruct iser_conn *iser_conn;\r\niscsi_conn = cls_conn->dd_data;\r\niser_conn = iscsi_conn->dd_data;\r\nreinit_completion(&iser_conn->stop_completion);\r\nreturn iscsi_conn_start(cls_conn);\r\n}\r\nstatic void\r\niscsi_iser_conn_stop(struct iscsi_cls_conn *cls_conn, int flag)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstruct iser_conn *iser_conn = conn->dd_data;\r\niser_info("stopping iscsi_conn: %p, iser_conn: %p\n", conn, iser_conn);\r\nif (iser_conn) {\r\nmutex_lock(&iser_conn->state_mutex);\r\niser_conn_terminate(iser_conn);\r\niscsi_conn_stop(cls_conn, flag);\r\niser_conn->iscsi_conn = NULL;\r\nconn->dd_data = NULL;\r\ncomplete(&iser_conn->stop_completion);\r\nmutex_unlock(&iser_conn->state_mutex);\r\n} else {\r\niscsi_conn_stop(cls_conn, flag);\r\n}\r\n}\r\nstatic void\r\niscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)\r\n{\r\nstruct Scsi_Host *shost = iscsi_session_to_shost(cls_session);\r\niscsi_session_teardown(cls_session);\r\niscsi_host_remove(shost);\r\niscsi_host_free(shost);\r\n}\r\nstatic inline unsigned int\r\niser_dif_prot_caps(int prot_caps)\r\n{\r\nreturn ((prot_caps & IB_PROT_T10DIF_TYPE_1) ?\r\nSHOST_DIF_TYPE1_PROTECTION | SHOST_DIX_TYPE0_PROTECTION |\r\nSHOST_DIX_TYPE1_PROTECTION : 0) |\r\n((prot_caps & IB_PROT_T10DIF_TYPE_2) ?\r\nSHOST_DIF_TYPE2_PROTECTION | SHOST_DIX_TYPE2_PROTECTION : 0) |\r\n((prot_caps & IB_PROT_T10DIF_TYPE_3) ?\r\nSHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE3_PROTECTION : 0);\r\n}\r\nstatic struct iscsi_cls_session *\r\niscsi_iser_session_create(struct iscsi_endpoint *ep,\r\nuint16_t cmds_max, uint16_t qdepth,\r\nuint32_t initial_cmdsn)\r\n{\r\nstruct iscsi_cls_session *cls_session;\r\nstruct iscsi_session *session;\r\nstruct Scsi_Host *shost;\r\nstruct iser_conn *iser_conn = NULL;\r\nstruct ib_conn *ib_conn;\r\nu32 max_fr_sectors;\r\nu16 max_cmds;\r\nshost = iscsi_host_alloc(&iscsi_iser_sht, 0, 0);\r\nif (!shost)\r\nreturn NULL;\r\nshost->transportt = iscsi_iser_scsi_transport;\r\nshost->cmd_per_lun = qdepth;\r\nshost->max_lun = iscsi_max_lun;\r\nshost->max_id = 0;\r\nshost->max_channel = 0;\r\nshost->max_cmd_len = 16;\r\nif (ep) {\r\niser_conn = ep->dd_data;\r\nmax_cmds = iser_conn->max_cmds;\r\nshost->sg_tablesize = iser_conn->scsi_sg_tablesize;\r\nmutex_lock(&iser_conn->state_mutex);\r\nif (iser_conn->state != ISER_CONN_UP) {\r\niser_err("iser conn %p already started teardown\n",\r\niser_conn);\r\nmutex_unlock(&iser_conn->state_mutex);\r\ngoto free_host;\r\n}\r\nib_conn = &iser_conn->ib_conn;\r\nif (ib_conn->pi_support) {\r\nu32 sig_caps = ib_conn->device->ib_device->attrs.sig_prot_cap;\r\nscsi_host_set_prot(shost, iser_dif_prot_caps(sig_caps));\r\nscsi_host_set_guard(shost, SHOST_DIX_GUARD_IP |\r\nSHOST_DIX_GUARD_CRC);\r\n}\r\nif (iscsi_host_add(shost,\r\nib_conn->device->ib_device->dev.parent)) {\r\nmutex_unlock(&iser_conn->state_mutex);\r\ngoto free_host;\r\n}\r\nmutex_unlock(&iser_conn->state_mutex);\r\n} else {\r\nmax_cmds = ISER_DEF_XMIT_CMDS_MAX;\r\nif (iscsi_host_add(shost, NULL))\r\ngoto free_host;\r\n}\r\nmax_fr_sectors = ((shost->sg_tablesize - 1) * PAGE_SIZE) >> 9;\r\nshost->max_sectors = min(iser_max_sectors, max_fr_sectors);\r\niser_dbg("iser_conn %p, sg_tablesize %u, max_sectors %u\n",\r\niser_conn, shost->sg_tablesize,\r\nshost->max_sectors);\r\nif (cmds_max > max_cmds) {\r\niser_info("cmds_max changed from %u to %u\n",\r\ncmds_max, max_cmds);\r\ncmds_max = max_cmds;\r\n}\r\ncls_session = iscsi_session_setup(&iscsi_iser_transport, shost,\r\ncmds_max, 0,\r\nsizeof(struct iscsi_iser_task),\r\ninitial_cmdsn, 0);\r\nif (!cls_session)\r\ngoto remove_host;\r\nsession = cls_session->dd_data;\r\nshost->can_queue = session->scsi_cmds_max;\r\nreturn cls_session;\r\nremove_host:\r\niscsi_host_remove(shost);\r\nfree_host:\r\niscsi_host_free(shost);\r\nreturn NULL;\r\n}\r\nstatic int\r\niscsi_iser_set_param(struct iscsi_cls_conn *cls_conn,\r\nenum iscsi_param param, char *buf, int buflen)\r\n{\r\nint value;\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\nbreak;\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("DataDigest wasn't negotiated to None\n");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase ISCSI_PARAM_DATADGST_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("DataDigest wasn't negotiated to None\n");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase ISCSI_PARAM_IFMARKER_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("IFMarker wasn't negotiated to No\n");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ncase ISCSI_PARAM_OFMARKER_EN:\r\nsscanf(buf, "%d", &value);\r\nif (value) {\r\niser_err("OFMarker wasn't negotiated to No\n");\r\nreturn -EPROTO;\r\n}\r\nbreak;\r\ndefault:\r\nreturn iscsi_set_param(cls_conn, param, buf, buflen);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\niscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *stats)\r\n{\r\nstruct iscsi_conn *conn = cls_conn->dd_data;\r\nstats->txdata_octets = conn->txdata_octets;\r\nstats->rxdata_octets = conn->rxdata_octets;\r\nstats->scsicmd_pdus = conn->scsicmd_pdus_cnt;\r\nstats->dataout_pdus = conn->dataout_pdus_cnt;\r\nstats->scsirsp_pdus = conn->scsirsp_pdus_cnt;\r\nstats->datain_pdus = conn->datain_pdus_cnt;\r\nstats->r2t_pdus = conn->r2t_pdus_cnt;\r\nstats->tmfcmd_pdus = conn->tmfcmd_pdus_cnt;\r\nstats->tmfrsp_pdus = conn->tmfrsp_pdus_cnt;\r\nstats->custom_length = 0;\r\n}\r\nstatic int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,\r\nenum iscsi_param param, char *buf)\r\n{\r\nstruct iser_conn *iser_conn = ep->dd_data;\r\nint len;\r\nswitch (param) {\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\nif (!iser_conn || !iser_conn->ib_conn.cma_id)\r\nreturn -ENOTCONN;\r\nreturn iscsi_conn_get_addr_param((struct sockaddr_storage *)\r\n&iser_conn->ib_conn.cma_id->route.addr.dst_addr,\r\nparam, buf);\r\nbreak;\r\ndefault:\r\nreturn -ENOSYS;\r\n}\r\nreturn len;\r\n}\r\nstatic struct iscsi_endpoint *\r\niscsi_iser_ep_connect(struct Scsi_Host *shost, struct sockaddr *dst_addr,\r\nint non_blocking)\r\n{\r\nint err;\r\nstruct iser_conn *iser_conn;\r\nstruct iscsi_endpoint *ep;\r\nep = iscsi_create_endpoint(0);\r\nif (!ep)\r\nreturn ERR_PTR(-ENOMEM);\r\niser_conn = kzalloc(sizeof(*iser_conn), GFP_KERNEL);\r\nif (!iser_conn) {\r\nerr = -ENOMEM;\r\ngoto failure;\r\n}\r\nep->dd_data = iser_conn;\r\niser_conn->ep = ep;\r\niser_conn_init(iser_conn);\r\nerr = iser_connect(iser_conn, NULL, dst_addr, non_blocking);\r\nif (err)\r\ngoto failure;\r\nreturn ep;\r\nfailure:\r\niscsi_destroy_endpoint(ep);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic int\r\niscsi_iser_ep_poll(struct iscsi_endpoint *ep, int timeout_ms)\r\n{\r\nstruct iser_conn *iser_conn = ep->dd_data;\r\nint rc;\r\nrc = wait_for_completion_interruptible_timeout(&iser_conn->up_completion,\r\nmsecs_to_jiffies(timeout_ms));\r\nif (rc == 0) {\r\nmutex_lock(&iser_conn->state_mutex);\r\nif (iser_conn->state == ISER_CONN_TERMINATING ||\r\niser_conn->state == ISER_CONN_DOWN)\r\nrc = -1;\r\nmutex_unlock(&iser_conn->state_mutex);\r\n}\r\niser_info("iser conn %p rc = %d\n", iser_conn, rc);\r\nif (rc > 0)\r\nreturn 1;\r\nelse if (!rc)\r\nreturn 0;\r\nelse\r\nreturn rc;\r\n}\r\nstatic void\r\niscsi_iser_ep_disconnect(struct iscsi_endpoint *ep)\r\n{\r\nstruct iser_conn *iser_conn = ep->dd_data;\r\niser_info("ep %p iser conn %p\n", ep, iser_conn);\r\nmutex_lock(&iser_conn->state_mutex);\r\niser_conn_terminate(iser_conn);\r\nif (iser_conn->iscsi_conn) {\r\nINIT_WORK(&iser_conn->release_work, iser_release_work);\r\nqueue_work(release_wq, &iser_conn->release_work);\r\nmutex_unlock(&iser_conn->state_mutex);\r\n} else {\r\niser_conn->state = ISER_CONN_DOWN;\r\nmutex_unlock(&iser_conn->state_mutex);\r\niser_conn_release(iser_conn);\r\n}\r\niscsi_destroy_endpoint(ep);\r\n}\r\nstatic umode_t iser_attr_is_visible(int param_type, int param)\r\n{\r\nswitch (param_type) {\r\ncase ISCSI_HOST_PARAM:\r\nswitch (param) {\r\ncase ISCSI_HOST_PARAM_NETDEV_NAME:\r\ncase ISCSI_HOST_PARAM_HWADDRESS:\r\ncase ISCSI_HOST_PARAM_INITIATOR_NAME:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\ncase ISCSI_PARAM:\r\nswitch (param) {\r\ncase ISCSI_PARAM_MAX_RECV_DLENGTH:\r\ncase ISCSI_PARAM_MAX_XMIT_DLENGTH:\r\ncase ISCSI_PARAM_HDRDGST_EN:\r\ncase ISCSI_PARAM_DATADGST_EN:\r\ncase ISCSI_PARAM_CONN_ADDRESS:\r\ncase ISCSI_PARAM_CONN_PORT:\r\ncase ISCSI_PARAM_EXP_STATSN:\r\ncase ISCSI_PARAM_PERSISTENT_ADDRESS:\r\ncase ISCSI_PARAM_PERSISTENT_PORT:\r\ncase ISCSI_PARAM_PING_TMO:\r\ncase ISCSI_PARAM_RECV_TMO:\r\ncase ISCSI_PARAM_INITIAL_R2T_EN:\r\ncase ISCSI_PARAM_MAX_R2T:\r\ncase ISCSI_PARAM_IMM_DATA_EN:\r\ncase ISCSI_PARAM_FIRST_BURST:\r\ncase ISCSI_PARAM_MAX_BURST:\r\ncase ISCSI_PARAM_PDU_INORDER_EN:\r\ncase ISCSI_PARAM_DATASEQ_INORDER_EN:\r\ncase ISCSI_PARAM_TARGET_NAME:\r\ncase ISCSI_PARAM_TPGT:\r\ncase ISCSI_PARAM_USERNAME:\r\ncase ISCSI_PARAM_PASSWORD:\r\ncase ISCSI_PARAM_USERNAME_IN:\r\ncase ISCSI_PARAM_PASSWORD_IN:\r\ncase ISCSI_PARAM_FAST_ABORT:\r\ncase ISCSI_PARAM_ABORT_TMO:\r\ncase ISCSI_PARAM_LU_RESET_TMO:\r\ncase ISCSI_PARAM_TGT_RESET_TMO:\r\ncase ISCSI_PARAM_IFACE_NAME:\r\ncase ISCSI_PARAM_INITIATOR_NAME:\r\ncase ISCSI_PARAM_DISCOVERY_SESS:\r\nreturn S_IRUGO;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int iscsi_iser_slave_alloc(struct scsi_device *sdev)\r\n{\r\nstruct iscsi_session *session;\r\nstruct iser_conn *iser_conn;\r\nstruct ib_device *ib_dev;\r\nsession = starget_to_session(scsi_target(sdev))->dd_data;\r\niser_conn = session->leadconn->dd_data;\r\nib_dev = iser_conn->ib_conn.device->ib_device;\r\nif (!(ib_dev->attrs.device_cap_flags & IB_DEVICE_SG_GAPS_REG))\r\nblk_queue_virt_boundary(sdev->request_queue, ~MASK_4K);\r\nreturn 0;\r\n}\r\nstatic int __init iser_init(void)\r\n{\r\nint err;\r\niser_dbg("Starting iSER datamover...\n");\r\nif (iscsi_max_lun < 1) {\r\niser_err("Invalid max_lun value of %u\n", iscsi_max_lun);\r\nreturn -EINVAL;\r\n}\r\nmemset(&ig, 0, sizeof(struct iser_global));\r\nig.desc_cache = kmem_cache_create("iser_descriptors",\r\nsizeof(struct iser_tx_desc),\r\n0, SLAB_HWCACHE_ALIGN,\r\nNULL);\r\nif (ig.desc_cache == NULL)\r\nreturn -ENOMEM;\r\nmutex_init(&ig.device_list_mutex);\r\nINIT_LIST_HEAD(&ig.device_list);\r\nmutex_init(&ig.connlist_mutex);\r\nINIT_LIST_HEAD(&ig.connlist);\r\nrelease_wq = alloc_workqueue("release workqueue", 0, 0);\r\nif (!release_wq) {\r\niser_err("failed to allocate release workqueue\n");\r\nerr = -ENOMEM;\r\ngoto err_alloc_wq;\r\n}\r\niscsi_iser_scsi_transport = iscsi_register_transport(\r\n&iscsi_iser_transport);\r\nif (!iscsi_iser_scsi_transport) {\r\niser_err("iscsi_register_transport failed\n");\r\nerr = -EINVAL;\r\ngoto err_reg;\r\n}\r\nreturn 0;\r\nerr_reg:\r\ndestroy_workqueue(release_wq);\r\nerr_alloc_wq:\r\nkmem_cache_destroy(ig.desc_cache);\r\nreturn err;\r\n}\r\nstatic void __exit iser_exit(void)\r\n{\r\nstruct iser_conn *iser_conn, *n;\r\nint connlist_empty;\r\niser_dbg("Removing iSER datamover...\n");\r\ndestroy_workqueue(release_wq);\r\nmutex_lock(&ig.connlist_mutex);\r\nconnlist_empty = list_empty(&ig.connlist);\r\nmutex_unlock(&ig.connlist_mutex);\r\nif (!connlist_empty) {\r\niser_err("Error cleanup stage completed but we still have iser "\r\n"connections, destroying them anyway\n");\r\nlist_for_each_entry_safe(iser_conn, n, &ig.connlist,\r\nconn_list) {\r\niser_conn_release(iser_conn);\r\n}\r\n}\r\niscsi_unregister_transport(&iscsi_iser_transport);\r\nkmem_cache_destroy(ig.desc_cache);\r\n}
