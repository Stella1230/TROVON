const char *dev_state_name(enum sci_remote_device_states state)\r\n{\r\nstatic const char * const strings[] = REMOTE_DEV_STATES;\r\nreturn strings[state];\r\n}\r\nenum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,\r\nenum sci_remote_node_suspension_reasons reason)\r\n{\r\nreturn sci_remote_node_context_suspend(&idev->rnc, reason,\r\nSCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);\r\n}\r\nstatic void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev = %p\n", __func__, idev);\r\nclear_bit(IDEV_IO_NCQERROR, &idev->flags);\r\nset_bit(IDEV_IO_READY, &idev->flags);\r\nif (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))\r\nwake_up(&ihost->eventq);\r\n}\r\nstatic enum sci_status sci_remote_device_terminate_req(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nint check_abort,\r\nstruct isci_request *ireq)\r\n{\r\nif (!test_bit(IREQ_ACTIVE, &ireq->flags) ||\r\n(ireq->target_device != idev) ||\r\n(check_abort && !test_bit(IREQ_PENDING_ABORT, &ireq->flags)))\r\nreturn SCI_SUCCESS;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev=%p; flags=%lx; req=%p; req target=%p\n",\r\n__func__, idev, idev->flags, ireq, ireq->target_device);\r\nset_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);\r\nreturn sci_controller_terminate_request(ihost, idev, ireq);\r\n}\r\nstatic enum sci_status sci_remote_device_terminate_reqs_checkabort(\r\nstruct isci_remote_device *idev,\r\nint chk)\r\n{\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nenum sci_status status = SCI_SUCCESS;\r\nu32 i;\r\nfor (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {\r\nstruct isci_request *ireq = ihost->reqs[i];\r\nenum sci_status s;\r\ns = sci_remote_device_terminate_req(ihost, idev, chk, ireq);\r\nif (s != SCI_SUCCESS)\r\nstatus = s;\r\n}\r\nreturn status;\r\n}\r\nstatic bool isci_compare_suspendcount(\r\nstruct isci_remote_device *idev,\r\nu32 localcount)\r\n{\r\nsmp_rmb();\r\nreturn (localcount != idev->rnc.suspend_count)\r\n|| sci_remote_node_context_is_being_destroyed(&idev->rnc);\r\n}\r\nstatic bool isci_check_reqterm(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq,\r\nu32 localcount)\r\n{\r\nunsigned long flags;\r\nbool res;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nres = isci_compare_suspendcount(idev, localcount)\r\n&& !test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nreturn res;\r\n}\r\nstatic bool isci_check_devempty(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nu32 localcount)\r\n{\r\nunsigned long flags;\r\nbool res;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nres = isci_compare_suspendcount(idev, localcount)\r\n&& idev->started_request_count == 0;\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nreturn res;\r\n}\r\nenum sci_status isci_remote_device_terminate_requests(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nenum sci_status status = SCI_SUCCESS;\r\nunsigned long flags;\r\nu32 rnc_suspend_count;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nif (isci_get_device(idev) == NULL) {\r\ndev_dbg(&ihost->pdev->dev, "%s: failed isci_get_device(idev=%p)\n",\r\n__func__, idev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nstatus = SCI_FAILURE;\r\n} else {\r\nsmp_rmb();\r\nrnc_suspend_count\r\n= sci_remote_node_context_is_suspended(&idev->rnc)\r\n? 0 : idev->rnc.suspend_count;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: idev=%p, ireq=%p; started_request_count=%d, "\r\n"rnc_suspend_count=%d, rnc.suspend_count=%d"\r\n"about to wait\n",\r\n__func__, idev, ireq, idev->started_request_count,\r\nrnc_suspend_count, idev->rnc.suspend_count);\r\n#define MAX_SUSPEND_MSECS 10000\r\nif (ireq) {\r\nset_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);\r\nsci_remote_device_terminate_req(ihost, idev, 0, ireq);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (!wait_event_timeout(ihost->eventq,\r\nisci_check_reqterm(ihost, idev, ireq,\r\nrnc_suspend_count),\r\nmsecs_to_jiffies(MAX_SUSPEND_MSECS))) {\r\ndev_warn(&ihost->pdev->dev, "%s host%d timeout single\n",\r\n__func__, ihost->id);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: ******* Timeout waiting for "\r\n"suspend; idev=%p, current state %s; "\r\n"started_request_count=%d, flags=%lx\n\t"\r\n"rnc_suspend_count=%d, rnc.suspend_count=%d "\r\n"RNC: current state %s, current "\r\n"suspend_type %x dest state %d;\n"\r\n"ireq=%p, ireq->flags = %lx\n",\r\n__func__, idev,\r\ndev_state_name(idev->sm.current_state_id),\r\nidev->started_request_count, idev->flags,\r\nrnc_suspend_count, idev->rnc.suspend_count,\r\nrnc_state_name(idev->rnc.sm.current_state_id),\r\nidev->rnc.suspend_type,\r\nidev->rnc.destination_state,\r\nireq, ireq->flags);\r\n}\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nclear_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);\r\nif (!test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))\r\nisci_free_tag(ihost, ireq->io_tag);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\n} else {\r\nsci_remote_device_terminate_requests(idev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (!wait_event_timeout(ihost->eventq,\r\nisci_check_devempty(ihost, idev,\r\nrnc_suspend_count),\r\nmsecs_to_jiffies(MAX_SUSPEND_MSECS))) {\r\ndev_warn(&ihost->pdev->dev, "%s host%d timeout all\n",\r\n__func__, ihost->id);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: ******* Timeout waiting for "\r\n"suspend; idev=%p, current state %s; "\r\n"started_request_count=%d, flags=%lx\n\t"\r\n"rnc_suspend_count=%d, "\r\n"RNC: current state %s, "\r\n"rnc.suspend_count=%d, current "\r\n"suspend_type %x dest state %d\n",\r\n__func__, idev,\r\ndev_state_name(idev->sm.current_state_id),\r\nidev->started_request_count, idev->flags,\r\nrnc_suspend_count,\r\nrnc_state_name(idev->rnc.sm.current_state_id),\r\nidev->rnc.suspend_count,\r\nidev->rnc.suspend_type,\r\nidev->rnc.destination_state);\r\n}\r\n}\r\ndev_dbg(&ihost->pdev->dev, "%s: idev=%p, wait done\n",\r\n__func__, idev);\r\nisci_put_device(idev);\r\n}\r\nreturn status;\r\n}\r\nstatic void isci_remote_device_not_ready(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nu32 reason)\r\n{\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p; reason = %d\n", __func__, idev, reason);\r\nswitch (reason) {\r\ncase SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:\r\nset_bit(IDEV_IO_NCQERROR, &idev->flags);\r\nsci_remote_device_suspend(idev, SCI_SW_SUSPEND_NORMAL);\r\nsci_remote_device_terminate_requests(idev);\r\ndefault:\r\nclear_bit(IDEV_IO_READY, &idev->flags);\r\nbreak;\r\n}\r\n}\r\nstatic void rnc_destruct_done(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nBUG_ON(idev->started_request_count != 0);\r\nsci_change_state(&idev->sm, SCI_DEV_STOPPED);\r\n}\r\nenum sci_status sci_remote_device_terminate_requests(\r\nstruct isci_remote_device *idev)\r\n{\r\nreturn sci_remote_device_terminate_reqs_checkabort(idev, 0);\r\n}\r\nenum sci_status sci_remote_device_stop(struct isci_remote_device *idev,\r\nu32 timeout)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_STOPPED:\r\nreturn SCI_SUCCESS;\r\ncase SCI_DEV_STARTING:\r\nBUG_ON(idev->started_request_count != 0);\r\nsci_remote_node_context_destruct(&idev->rnc,\r\nrnc_destruct_done, idev);\r\nsci_change_state(sm, SCI_DEV_STOPPING);\r\nreturn SCI_SUCCESS;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\nsci_change_state(sm, SCI_DEV_STOPPING);\r\nif (idev->started_request_count == 0)\r\nsci_remote_node_context_destruct(&idev->rnc,\r\nrnc_destruct_done,\r\nidev);\r\nelse {\r\nsci_remote_device_suspend(\r\nidev, SCI_SW_SUSPEND_LINKHANG_DETECT);\r\nsci_remote_device_terminate_requests(idev);\r\n}\r\nreturn SCI_SUCCESS;\r\ncase SCI_DEV_STOPPING:\r\nreturn sci_remote_device_terminate_requests(idev);\r\ncase SCI_DEV_RESETTING:\r\nsci_change_state(sm, SCI_DEV_STOPPING);\r\nreturn SCI_SUCCESS;\r\n}\r\n}\r\nenum sci_status sci_remote_device_reset(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\nsci_change_state(sm, SCI_DEV_RESETTING);\r\nreturn SCI_SUCCESS;\r\n}\r\n}\r\nenum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nif (state != SCI_DEV_RESETTING) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_change_state(sm, SCI_DEV_READY);\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,\r\nu32 frame_index)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nsci_controller_release_frame(ihost, frame_index);\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING: {\r\nstruct isci_request *ireq;\r\nstruct ssp_frame_hdr hdr;\r\nvoid *frame_header;\r\nssize_t word_cnt;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n&frame_header);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nword_cnt = sizeof(hdr) / sizeof(u32);\r\nsci_swab32_cpy(&hdr, frame_header, word_cnt);\r\nireq = sci_request_by_tag(ihost, be16_to_cpu(hdr.tag));\r\nif (ireq && ireq->target_device == idev) {\r\nstatus = sci_io_request_frame_handler(ireq, frame_index);\r\n} else {\r\nsci_controller_release_frame(ihost, frame_index);\r\n}\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_NCQ: {\r\nstruct dev_to_host_fis *hdr;\r\nstatus = sci_unsolicited_frame_control_get_header(&ihost->uf_control,\r\nframe_index,\r\n(void **)&hdr);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (hdr->fis_type == FIS_SETDEVBITS &&\r\n(hdr->status & ATA_ERR)) {\r\nidev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;\r\nsci_change_state(sm, SCI_STP_DEV_NCQ_ERROR);\r\n} else if (hdr->fis_type == FIS_REGD2H &&\r\n(hdr->status & ATA_ERR)) {\r\nidev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;\r\nsci_change_state(&idev->sm, SCI_STP_DEV_NCQ_ERROR);\r\n} else\r\nstatus = SCI_FAILURE;\r\nsci_controller_release_frame(ihost, frame_index);\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_SMP_DEV_CMD:\r\nstatus = sci_io_request_frame_handler(idev->working_request, frame_index);\r\nbreak;\r\n}\r\nreturn status;\r\n}\r\nstatic bool is_remote_device_ready(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (state) {\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void atapi_remote_device_resume_done(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nstruct isci_request *ireq = idev->working_request;\r\nsci_change_state(&ireq->sm, SCI_REQ_COMPLETED);\r\n}\r\nenum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,\r\nu32 event_code)\r\n{\r\nenum sci_status status;\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nswitch (scu_get_event_type(event_code)) {\r\ncase SCU_EVENT_TYPE_RNC_OPS_MISC:\r\ncase SCU_EVENT_TYPE_RNC_SUSPEND_TX:\r\ncase SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:\r\nstatus = sci_remote_node_context_event_handler(&idev->rnc, event_code);\r\nbreak;\r\ncase SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:\r\nif (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {\r\nstatus = SCI_SUCCESS;\r\nsci_remote_device_suspend(idev, SCI_SW_SUSPEND_NORMAL);\r\ndev_dbg(scirdev_to_dev(idev),\r\n"%s: device: %p event code: %x: %s\n",\r\n__func__, idev, event_code,\r\nis_remote_device_ready(idev)\r\n? "I_T_Nexus_Timeout event"\r\n: "I_T_Nexus_Timeout event in wrong state");\r\nbreak;\r\n}\r\ndefault:\r\ndev_dbg(scirdev_to_dev(idev),\r\n"%s: device: %p event code: %x: %s\n",\r\n__func__, idev, event_code,\r\nis_remote_device_ready(idev)\r\n? "unexpected event"\r\n: "unexpected event in wrong state");\r\nstatus = SCI_FAILURE_INVALID_STATE;\r\nbreak;\r\n}\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nif (state == SCI_STP_DEV_ATAPI_ERROR) {\r\nif (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||\r\nscu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {\r\nreturn sci_remote_node_context_resume(&idev->rnc,\r\natapi_remote_device_resume_done,\r\nidev);\r\n}\r\n}\r\nif (state == SCI_STP_DEV_IDLE) {\r\nif (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||\r\nscu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)\r\nstatus = sci_remote_node_context_resume(&idev->rnc, NULL, NULL);\r\n}\r\nreturn status;\r\n}\r\nstatic void sci_remote_device_start_request(struct isci_remote_device *idev,\r\nstruct isci_request *ireq,\r\nenum sci_status status)\r\n{\r\nstruct isci_port *iport = idev->owning_port;\r\nif (status != SCI_SUCCESS)\r\nsci_port_complete_io(iport, idev, ireq);\r\nelse {\r\nkref_get(&idev->kref);\r\nidev->started_request_count++;\r\n}\r\n}\r\nenum sci_status sci_remote_device_start_io(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_port *iport = idev->owning_port;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nbreak;\r\ncase SCI_STP_DEV_IDLE: {\r\nenum sci_remote_device_states new_state;\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nif (task->ata_task.use_ncq)\r\nnew_state = SCI_STP_DEV_NCQ;\r\nelse {\r\nidev->working_request = ireq;\r\nnew_state = SCI_STP_DEV_CMD;\r\n}\r\nsci_change_state(sm, new_state);\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_NCQ: {\r\nstruct sas_task *task = isci_request_access_task(ireq);\r\nif (task->ata_task.use_ncq) {\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\n} else\r\nreturn SCI_FAILURE_INVALID_STATE;\r\nbreak;\r\n}\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\nreturn SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;\r\ncase SCI_SMP_DEV_IDLE:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_io(&idev->rnc, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nidev->working_request = ireq;\r\nsci_change_state(&idev->sm, SCI_SMP_DEV_CMD);\r\nbreak;\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_SMP_DEV_CMD:\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nsci_remote_device_start_request(idev, ireq, status);\r\nreturn status;\r\n}\r\nstatic enum sci_status common_complete_io(struct isci_port *iport,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nenum sci_status status;\r\nstatus = sci_request_complete(ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_port_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nsci_remote_device_decrement_request_count(idev);\r\nreturn status;\r\n}\r\nenum sci_status sci_remote_device_complete_io(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_port *iport = idev->owning_port;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_DEV_READY:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\ncase SCI_DEV_RESETTING:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nbreak;\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_ATAPI_ERROR:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nif (ireq->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {\r\nsci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);\r\n} else if (idev->started_request_count == 0)\r\nsci_change_state(sm, SCI_STP_DEV_IDLE);\r\nbreak;\r\ncase SCI_SMP_DEV_CMD:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nsci_change_state(sm, SCI_SMP_DEV_IDLE);\r\nbreak;\r\ncase SCI_DEV_STOPPING:\r\nstatus = common_complete_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nif (idev->started_request_count == 0)\r\nsci_remote_node_context_destruct(&idev->rnc,\r\nrnc_destruct_done,\r\nidev);\r\nbreak;\r\n}\r\nif (status != SCI_SUCCESS)\r\ndev_err(scirdev_to_dev(idev),\r\n"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "\r\n"could not complete\n", __func__, iport,\r\nidev, ireq, status);\r\nelse\r\nisci_put_device(idev);\r\nreturn status;\r\n}\r\nstatic void sci_remote_device_continue_request(void *dev)\r\n{\r\nstruct isci_remote_device *idev = dev;\r\nif (idev->working_request)\r\nsci_controller_continue_io(idev->working_request);\r\n}\r\nenum sci_status sci_remote_device_start_task(struct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_port *iport = idev->owning_port;\r\nenum sci_status status;\r\nswitch (state) {\r\ncase SCI_DEV_INITIAL:\r\ncase SCI_DEV_STOPPED:\r\ncase SCI_DEV_STARTING:\r\ncase SCI_SMP_DEV_IDLE:\r\ncase SCI_SMP_DEV_CMD:\r\ncase SCI_DEV_STOPPING:\r\ncase SCI_DEV_FAILED:\r\ncase SCI_DEV_RESETTING:\r\ncase SCI_DEV_FINAL:\r\ndefault:\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\ncase SCI_STP_DEV_IDLE:\r\ncase SCI_STP_DEV_CMD:\r\ncase SCI_STP_DEV_NCQ:\r\ncase SCI_STP_DEV_NCQ_ERROR:\r\ncase SCI_STP_DEV_AWAIT_RESET:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_request_start(ireq);\r\nif (status != SCI_SUCCESS)\r\ngoto out;\r\nidev->working_request = ireq;\r\nsci_change_state(sm, SCI_STP_DEV_CMD);\r\nsci_remote_device_suspend(idev,\r\nSCI_SW_SUSPEND_LINKHANG_DETECT);\r\nstatus = sci_remote_node_context_start_task(&idev->rnc, ireq,\r\nsci_remote_device_continue_request, idev);\r\nout:\r\nsci_remote_device_start_request(idev, ireq, status);\r\nreturn SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;\r\ncase SCI_DEV_READY:\r\nstatus = sci_port_start_io(iport, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nstatus = sci_remote_node_context_start_task(&idev->rnc, ireq,\r\nNULL, NULL);\r\nif (status != SCI_SUCCESS)\r\nbreak;\r\nstatus = sci_request_start(ireq);\r\nbreak;\r\n}\r\nsci_remote_device_start_request(idev, ireq, status);\r\nreturn status;\r\n}\r\nvoid sci_remote_device_post_request(struct isci_remote_device *idev, u32 request)\r\n{\r\nstruct isci_port *iport = idev->owning_port;\r\nu32 context;\r\ncontext = request |\r\n(ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |\r\n(iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |\r\nidev->rnc.remote_node_index;\r\nsci_controller_post_request(iport->owning_controller, context);\r\n}\r\nstatic void remote_device_resume_done(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nif (is_remote_device_ready(idev))\r\nreturn;\r\nsci_change_state(&idev->sm, SCI_DEV_READY);\r\n}\r\nstatic void sci_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)\r\n{\r\nstruct isci_remote_device *idev = _dev;\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nif (idev->sm.previous_state_id != SCI_STP_DEV_NCQ)\r\nisci_remote_device_ready(ihost, idev);\r\n}\r\nstatic void sci_remote_device_initial_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nsci_change_state(&idev->sm, SCI_DEV_STOPPED);\r\n}\r\nstatic enum sci_status sci_remote_device_destruct(struct isci_remote_device *idev)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nstruct isci_host *ihost;\r\nif (state != SCI_DEV_STOPPED) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nihost = idev->owning_port->owning_controller;\r\nsci_controller_free_remote_node_context(ihost, idev,\r\nidev->rnc.remote_node_index);\r\nidev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;\r\nsci_change_state(sm, SCI_DEV_FINAL);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nBUG_ON(idev->started_request_count > 0);\r\nsci_remote_device_destruct(idev);\r\nlist_del_init(&idev->node);\r\nisci_put_device(idev);\r\n}\r\nstatic void sci_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nu32 prev_state;\r\nprev_state = idev->sm.previous_state_id;\r\nif (prev_state == SCI_DEV_STOPPING)\r\nisci_remote_device_deconstruct(ihost, idev);\r\nsci_controller_remote_device_stopped(ihost, idev);\r\n}\r\nstatic void sci_remote_device_starting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);\r\n}\r\nstatic void sci_remote_device_ready_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nstruct domain_device *dev = idev->domain_dev;\r\nif (dev->dev_type == SAS_SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {\r\nsci_change_state(&idev->sm, SCI_STP_DEV_IDLE);\r\n} else if (dev_is_expander(dev)) {\r\nsci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);\r\n} else\r\nisci_remote_device_ready(ihost, idev);\r\n}\r\nstatic void sci_remote_device_ready_state_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct domain_device *dev = idev->domain_dev;\r\nif (dev->dev_type == SAS_END_DEVICE) {\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);\r\n}\r\n}\r\nstatic void sci_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nsci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);\r\n}\r\nstatic void sci_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nsci_remote_node_context_resume(&idev->rnc, NULL, NULL);\r\n}\r\nstatic void sci_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nidev->working_request = NULL;\r\nif (sci_remote_node_context_is_ready(&idev->rnc)) {\r\nsci_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);\r\n} else {\r\nsci_remote_node_context_resume(&idev->rnc,\r\nsci_stp_remote_device_ready_idle_substate_resume_complete_handler,\r\nidev);\r\n}\r\n}\r\nstatic void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nBUG_ON(idev->working_request == NULL);\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);\r\n}\r\nstatic void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nif (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)\r\nisci_remote_device_not_ready(ihost, idev,\r\nidev->not_ready_reason);\r\n}\r\nstatic void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nisci_remote_device_ready(ihost, idev);\r\n}\r\nstatic void sci_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nBUG_ON(idev->working_request == NULL);\r\nisci_remote_device_not_ready(ihost, idev,\r\nSCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);\r\n}\r\nstatic void sci_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)\r\n{\r\nstruct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);\r\nidev->working_request = NULL;\r\n}\r\nstatic void sci_remote_device_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nidev->owning_port = iport;\r\nidev->started_request_count = 0;\r\nsci_init_sm(&idev->sm, sci_remote_device_state_table, SCI_DEV_INITIAL);\r\nsci_remote_node_context_construct(&idev->rnc,\r\nSCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);\r\n}\r\nstatic enum sci_status sci_remote_device_da_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nenum sci_status status;\r\nstruct sci_port_properties properties;\r\nsci_remote_device_construct(iport, idev);\r\nsci_port_get_properties(iport, &properties);\r\nidev->device_port_width = hweight32(properties.phy_mask);\r\nstatus = sci_controller_allocate_remote_node_context(iport->owning_controller,\r\nidev,\r\n&idev->rnc.remote_node_index);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nidev->connection_rate = sci_port_get_max_allowed_speed(iport);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nstruct domain_device *dev = idev->domain_dev;\r\nenum sci_status status;\r\nsci_remote_device_construct(iport, idev);\r\nstatus = sci_controller_allocate_remote_node_context(iport->owning_controller,\r\nidev,\r\n&idev->rnc.remote_node_index);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nidev->connection_rate = min_t(u16, sci_port_get_max_allowed_speed(iport),\r\ndev->linkrate);\r\nidev->device_port_width = 1;\r\nreturn SCI_SUCCESS;\r\n}\r\nenum sci_status sci_remote_device_resume(\r\nstruct isci_remote_device *idev,\r\nscics_sds_remote_node_context_callback cb_fn,\r\nvoid *cb_p)\r\n{\r\nenum sci_status status;\r\nstatus = sci_remote_node_context_resume(&idev->rnc, cb_fn, cb_p);\r\nif (status != SCI_SUCCESS)\r\ndev_dbg(scirdev_to_dev(idev), "%s: failed to resume: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatic void isci_remote_device_resume_from_abort_complete(void *cbparam)\r\n{\r\nstruct isci_remote_device *idev = cbparam;\r\nstruct isci_host *ihost = idev->owning_port->owning_controller;\r\nscics_sds_remote_node_context_callback abort_resume_cb =\r\nidev->abort_resume_cb;\r\ndev_dbg(scirdev_to_dev(idev), "%s: passing-along resume: %p\n",\r\n__func__, abort_resume_cb);\r\nif (abort_resume_cb != NULL) {\r\nidev->abort_resume_cb = NULL;\r\nabort_resume_cb(idev->abort_resume_cbparam);\r\n}\r\nclear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\r\nwake_up(&ihost->eventq);\r\n}\r\nstatic bool isci_remote_device_test_resume_done(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev)\r\n{\r\nunsigned long flags;\r\nbool done;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\ndone = !test_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags)\r\n|| test_bit(IDEV_STOP_PENDING, &idev->flags)\r\n|| sci_remote_node_context_is_being_destroyed(&idev->rnc);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nreturn done;\r\n}\r\nvoid isci_remote_device_wait_for_resume_from_abort(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev)\r\n{\r\ndev_dbg(&ihost->pdev->dev, "%s: starting resume wait: %p\n",\r\n__func__, idev);\r\n#define MAX_RESUME_MSECS 10000\r\nif (!wait_event_timeout(ihost->eventq,\r\nisci_remote_device_test_resume_done(ihost, idev),\r\nmsecs_to_jiffies(MAX_RESUME_MSECS))) {\r\ndev_warn(&ihost->pdev->dev, "%s: #### Timeout waiting for "\r\n"resume: %p\n", __func__, idev);\r\n}\r\nclear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\r\ndev_dbg(&ihost->pdev->dev, "%s: resume wait done: %p\n",\r\n__func__, idev);\r\n}\r\nenum sci_status isci_remote_device_resume_from_abort(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev)\r\n{\r\nunsigned long flags;\r\nenum sci_status status = SCI_SUCCESS;\r\nint destroyed;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nidev->abort_resume_cb = idev->rnc.user_callback;\r\nidev->abort_resume_cbparam = idev->rnc.user_cookie;\r\nset_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\r\nclear_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);\r\ndestroyed = sci_remote_node_context_is_being_destroyed(&idev->rnc);\r\nif (!destroyed)\r\nstatus = sci_remote_device_resume(\r\nidev, isci_remote_device_resume_from_abort_complete,\r\nidev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (!destroyed && (status == SCI_SUCCESS))\r\nisci_remote_device_wait_for_resume_from_abort(ihost, idev);\r\nelse\r\nclear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);\r\nreturn status;\r\n}\r\nstatic enum sci_status sci_remote_device_start(struct isci_remote_device *idev,\r\nu32 timeout)\r\n{\r\nstruct sci_base_state_machine *sm = &idev->sm;\r\nenum sci_remote_device_states state = sm->current_state_id;\r\nenum sci_status status;\r\nif (state != SCI_DEV_STOPPED) {\r\ndev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",\r\n__func__, dev_state_name(state));\r\nreturn SCI_FAILURE_INVALID_STATE;\r\n}\r\nstatus = sci_remote_device_resume(idev, remote_device_resume_done,\r\nidev);\r\nif (status != SCI_SUCCESS)\r\nreturn status;\r\nsci_change_state(sm, SCI_DEV_STARTING);\r\nreturn SCI_SUCCESS;\r\n}\r\nstatic enum sci_status isci_remote_device_construct(struct isci_port *iport,\r\nstruct isci_remote_device *idev)\r\n{\r\nstruct isci_host *ihost = iport->isci_host;\r\nstruct domain_device *dev = idev->domain_dev;\r\nenum sci_status status;\r\nif (dev->parent && dev_is_expander(dev->parent))\r\nstatus = sci_remote_device_ea_construct(iport, idev);\r\nelse\r\nstatus = sci_remote_device_da_construct(iport, idev);\r\nif (status != SCI_SUCCESS) {\r\ndev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",\r\n__func__, status);\r\nreturn status;\r\n}\r\nstatus = sci_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);\r\nif (status != SCI_SUCCESS)\r\ndev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nstatic struct isci_remote_device *\r\nisci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)\r\n{\r\nstruct isci_remote_device *idev;\r\nint i;\r\nfor (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {\r\nidev = &ihost->devices[i];\r\nif (!test_and_set_bit(IDEV_ALLOCATED, &idev->flags))\r\nbreak;\r\n}\r\nif (i >= SCI_MAX_REMOTE_DEVICES) {\r\ndev_warn(&ihost->pdev->dev, "%s: failed\n", __func__);\r\nreturn NULL;\r\n}\r\nif (WARN_ONCE(!list_empty(&idev->node), "found non-idle remote device\n"))\r\nreturn NULL;\r\nreturn idev;\r\n}\r\nvoid isci_remote_device_release(struct kref *kref)\r\n{\r\nstruct isci_remote_device *idev = container_of(kref, typeof(*idev), kref);\r\nstruct isci_host *ihost = idev->isci_port->isci_host;\r\nidev->domain_dev = NULL;\r\nidev->isci_port = NULL;\r\nclear_bit(IDEV_START_PENDING, &idev->flags);\r\nclear_bit(IDEV_STOP_PENDING, &idev->flags);\r\nclear_bit(IDEV_IO_READY, &idev->flags);\r\nclear_bit(IDEV_GONE, &idev->flags);\r\nsmp_mb__before_atomic();\r\nclear_bit(IDEV_ALLOCATED, &idev->flags);\r\nwake_up(&ihost->eventq);\r\n}\r\nenum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)\r\n{\r\nenum sci_status status;\r\nunsigned long flags;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p\n", __func__, idev);\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nidev->domain_dev->lldd_dev = NULL;\r\nset_bit(IDEV_GONE, &idev->flags);\r\nset_bit(IDEV_STOP_PENDING, &idev->flags);\r\nstatus = sci_remote_device_stop(idev, 50);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nif (WARN_ONCE(status != SCI_SUCCESS, "failed to stop device\n"))\r\n;\r\nelse\r\nwait_for_device_stop(ihost, idev);\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_device = %p, waiting done.\n", __func__, idev);\r\nreturn status;\r\n}\r\nvoid isci_remote_device_gone(struct domain_device *dev)\r\n{\r\nstruct isci_host *ihost = dev_to_ihost(dev);\r\nstruct isci_remote_device *idev = dev->lldd_dev;\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: domain_device = %p, isci_device = %p, isci_port = %p\n",\r\n__func__, dev, idev, idev->isci_port);\r\nisci_remote_device_stop(ihost, idev);\r\n}\r\nint isci_remote_device_found(struct domain_device *dev)\r\n{\r\nstruct isci_host *isci_host = dev_to_ihost(dev);\r\nstruct isci_port *isci_port = dev->port->lldd_port;\r\nstruct isci_remote_device *isci_device;\r\nenum sci_status status;\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: domain_device = %p\n", __func__, dev);\r\nif (!isci_port)\r\nreturn -ENODEV;\r\nisci_device = isci_remote_device_alloc(isci_host, isci_port);\r\nif (!isci_device)\r\nreturn -ENODEV;\r\nkref_init(&isci_device->kref);\r\nINIT_LIST_HEAD(&isci_device->node);\r\nspin_lock_irq(&isci_host->scic_lock);\r\nisci_device->domain_dev = dev;\r\nisci_device->isci_port = isci_port;\r\nlist_add_tail(&isci_device->node, &isci_port->remote_dev_list);\r\nset_bit(IDEV_START_PENDING, &isci_device->flags);\r\nstatus = isci_remote_device_construct(isci_port, isci_device);\r\ndev_dbg(&isci_host->pdev->dev,\r\n"%s: isci_device = %p\n",\r\n__func__, isci_device);\r\nif (status == SCI_SUCCESS) {\r\ndev->lldd_dev = isci_device;\r\n} else\r\nisci_put_device(isci_device);\r\nspin_unlock_irq(&isci_host->scic_lock);\r\nwait_for_device_start(isci_host, isci_device);\r\nreturn status == SCI_SUCCESS ? 0 : -ENODEV;\r\n}\r\nenum sci_status isci_remote_device_suspend_terminate(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev,\r\nstruct isci_request *ireq)\r\n{\r\nunsigned long flags;\r\nenum sci_status status;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nset_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);\r\nsci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nstatus = isci_remote_device_terminate_requests(ihost, idev, ireq);\r\nif (status != SCI_SUCCESS)\r\ndev_dbg(&ihost->pdev->dev,\r\n"%s: isci_remote_device_terminate_requests(%p) "\r\n"returned %d!\n",\r\n__func__, idev, status);\r\nreturn status;\r\n}\r\nint isci_remote_device_is_safe_to_abort(\r\nstruct isci_remote_device *idev)\r\n{\r\nreturn sci_remote_node_context_is_safe_to_abort(&idev->rnc);\r\n}\r\nenum sci_status sci_remote_device_abort_requests_pending_abort(\r\nstruct isci_remote_device *idev)\r\n{\r\nreturn sci_remote_device_terminate_reqs_checkabort(idev, 1);\r\n}\r\nenum sci_status isci_remote_device_reset_complete(\r\nstruct isci_host *ihost,\r\nstruct isci_remote_device *idev)\r\n{\r\nunsigned long flags;\r\nenum sci_status status;\r\nspin_lock_irqsave(&ihost->scic_lock, flags);\r\nstatus = sci_remote_device_reset_complete(idev);\r\nspin_unlock_irqrestore(&ihost->scic_lock, flags);\r\nreturn status;\r\n}\r\nvoid isci_dev_set_hang_detection_timeout(\r\nstruct isci_remote_device *idev,\r\nu32 timeout)\r\n{\r\nif (dev_is_sata(idev->domain_dev)) {\r\nif (timeout) {\r\nif (test_and_set_bit(IDEV_RNC_LLHANG_ENABLED,\r\n&idev->flags))\r\nreturn;\r\n} else if (!test_and_clear_bit(IDEV_RNC_LLHANG_ENABLED,\r\n&idev->flags))\r\nreturn;\r\nsci_port_set_hang_detection_timeout(idev->owning_port,\r\ntimeout);\r\n}\r\n}
