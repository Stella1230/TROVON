static int go7007_usb_vendor_request(struct go7007 *go, int request,\r\nint value, int index, void *transfer_buffer, int length, int in)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint timeout = 5000;\r\nif (in) {\r\nreturn usb_control_msg(usb->usbdev,\r\nusb_rcvctrlpipe(usb->usbdev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\nvalue, index, transfer_buffer, length, timeout);\r\n} else {\r\nreturn usb_control_msg(usb->usbdev,\r\nusb_sndctrlpipe(usb->usbdev, 0), request,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, transfer_buffer, length, timeout);\r\n}\r\n}\r\nstatic int go7007_usb_interface_reset(struct go7007 *go)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nu16 intr_val, intr_data;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -1;\r\nif (go7007_write_interrupt(go, 0x0001, 0x0001) < 0)\r\nreturn -1;\r\nmsleep(100);\r\nif (usb->board->flags & GO7007_USB_EZUSB) {\r\npr_debug("resetting EZ-USB buffers\n");\r\nif (go7007_usb_vendor_request(go, 0x10, 0, 0, NULL, 0, 0) < 0 ||\r\ngo7007_usb_vendor_request(go, 0x10, 0, 0, NULL, 0, 0) < 0)\r\nreturn -1;\r\nif (go7007_write_interrupt(go, 0x0001, 0x0001) < 0)\r\nreturn -1;\r\nmsleep(100);\r\n}\r\nif (go7007_read_interrupt(go, &intr_val, &intr_data) < 0 ||\r\n(intr_val & ~0x1) != 0x55aa) {\r\ndev_err(go->dev, "unable to reset the USB interface\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int go7007_usb_ezusb_write_interrupt(struct go7007 *go,\r\nint addr, int data)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint i, r;\r\nu16 status_reg = 0;\r\nint timeout = 500;\r\npr_debug("WriteInterrupt: %04x %04x\n", addr, data);\r\nfor (i = 0; i < 100; ++i) {\r\nr = usb_control_msg(usb->usbdev,\r\nusb_rcvctrlpipe(usb->usbdev, 0), 0x14,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\r\n0, HPI_STATUS_ADDR, go->usb_buf,\r\nsizeof(status_reg), timeout);\r\nif (r < 0)\r\nbreak;\r\nstatus_reg = le16_to_cpu(*((__le16 *)go->usb_buf));\r\nif (!(status_reg & 0x0010))\r\nbreak;\r\nmsleep(10);\r\n}\r\nif (r < 0)\r\ngoto write_int_error;\r\nif (i == 100) {\r\ndev_err(go->dev, "device is hung, status reg = 0x%04x\n", status_reg);\r\nreturn -1;\r\n}\r\nr = usb_control_msg(usb->usbdev, usb_sndctrlpipe(usb->usbdev, 0), 0x12,\r\nUSB_TYPE_VENDOR | USB_RECIP_DEVICE, data,\r\nINT_PARAM_ADDR, NULL, 0, timeout);\r\nif (r < 0)\r\ngoto write_int_error;\r\nr = usb_control_msg(usb->usbdev, usb_sndctrlpipe(usb->usbdev, 0),\r\n0x12, USB_TYPE_VENDOR | USB_RECIP_DEVICE, addr,\r\nINT_INDEX_ADDR, NULL, 0, timeout);\r\nif (r < 0)\r\ngoto write_int_error;\r\nreturn 0;\r\nwrite_int_error:\r\ndev_err(go->dev, "error in WriteInterrupt: %d\n", r);\r\nreturn r;\r\n}\r\nstatic int go7007_usb_onboard_write_interrupt(struct go7007 *go,\r\nint addr, int data)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint r;\r\nint timeout = 500;\r\npr_debug("WriteInterrupt: %04x %04x\n", addr, data);\r\ngo->usb_buf[0] = data & 0xff;\r\ngo->usb_buf[1] = data >> 8;\r\ngo->usb_buf[2] = addr & 0xff;\r\ngo->usb_buf[3] = addr >> 8;\r\ngo->usb_buf[4] = go->usb_buf[5] = go->usb_buf[6] = go->usb_buf[7] = 0;\r\nr = usb_control_msg(usb->usbdev, usb_sndctrlpipe(usb->usbdev, 2), 0x00,\r\nUSB_TYPE_VENDOR | USB_RECIP_ENDPOINT, 0x55aa,\r\n0xf0f0, go->usb_buf, 8, timeout);\r\nif (r < 0) {\r\ndev_err(go->dev, "error in WriteInterrupt: %d\n", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void go7007_usb_readinterrupt_complete(struct urb *urb)\r\n{\r\nstruct go7007 *go = (struct go7007 *)urb->context;\r\n__le16 *regs = (__le16 *)urb->transfer_buffer;\r\nint status = urb->status;\r\nif (status) {\r\nif (status != -ESHUTDOWN &&\r\ngo->status != STATUS_SHUTDOWN) {\r\ndev_err(go->dev, "error in read interrupt: %d\n", urb->status);\r\n} else {\r\nwake_up(&go->interrupt_waitq);\r\nreturn;\r\n}\r\n} else if (urb->actual_length != urb->transfer_buffer_length) {\r\ndev_err(go->dev, "short read in interrupt pipe!\n");\r\n} else {\r\ngo->interrupt_available = 1;\r\ngo->interrupt_data = __le16_to_cpu(regs[0]);\r\ngo->interrupt_value = __le16_to_cpu(regs[1]);\r\npr_debug("ReadInterrupt: %04x %04x\n",\r\ngo->interrupt_value, go->interrupt_data);\r\n}\r\nwake_up(&go->interrupt_waitq);\r\n}\r\nstatic int go7007_usb_read_interrupt(struct go7007 *go)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint r;\r\nr = usb_submit_urb(usb->intr_urb, GFP_KERNEL);\r\nif (r < 0) {\r\ndev_err(go->dev, "unable to submit interrupt urb: %d\n", r);\r\nreturn r;\r\n}\r\nreturn 0;\r\n}\r\nstatic void go7007_usb_read_video_pipe_complete(struct urb *urb)\r\n{\r\nstruct go7007 *go = (struct go7007 *)urb->context;\r\nint r, status = urb->status;\r\nif (!vb2_is_streaming(&go->vidq)) {\r\nwake_up_interruptible(&go->frame_waitq);\r\nreturn;\r\n}\r\nif (status) {\r\ndev_err(go->dev, "error in video pipe: %d\n", status);\r\nreturn;\r\n}\r\nif (urb->actual_length != urb->transfer_buffer_length) {\r\ndev_err(go->dev, "short read in video pipe!\n");\r\nreturn;\r\n}\r\ngo7007_parse_video_stream(go, urb->transfer_buffer, urb->actual_length);\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (r < 0)\r\ndev_err(go->dev, "error in video pipe: %d\n", r);\r\n}\r\nstatic void go7007_usb_read_audio_pipe_complete(struct urb *urb)\r\n{\r\nstruct go7007 *go = (struct go7007 *)urb->context;\r\nint r, status = urb->status;\r\nif (!vb2_is_streaming(&go->vidq))\r\nreturn;\r\nif (status) {\r\ndev_err(go->dev, "error in audio pipe: %d\n",\r\nstatus);\r\nreturn;\r\n}\r\nif (urb->actual_length != urb->transfer_buffer_length) {\r\ndev_err(go->dev, "short read in audio pipe!\n");\r\nreturn;\r\n}\r\nif (go->audio_deliver != NULL)\r\ngo->audio_deliver(go, urb->transfer_buffer, urb->actual_length);\r\nr = usb_submit_urb(urb, GFP_ATOMIC);\r\nif (r < 0)\r\ndev_err(go->dev, "error in audio pipe: %d\n", r);\r\n}\r\nstatic int go7007_usb_stream_start(struct go7007 *go)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint i, r;\r\nfor (i = 0; i < 8; ++i) {\r\nr = usb_submit_urb(usb->video_urbs[i], GFP_KERNEL);\r\nif (r < 0) {\r\ndev_err(go->dev, "error submitting video urb %d: %d\n", i, r);\r\ngoto video_submit_failed;\r\n}\r\n}\r\nif (!go->audio_enabled)\r\nreturn 0;\r\nfor (i = 0; i < 8; ++i) {\r\nr = usb_submit_urb(usb->audio_urbs[i], GFP_KERNEL);\r\nif (r < 0) {\r\ndev_err(go->dev, "error submitting audio urb %d: %d\n", i, r);\r\ngoto audio_submit_failed;\r\n}\r\n}\r\nreturn 0;\r\naudio_submit_failed:\r\nfor (i = 0; i < 7; ++i)\r\nusb_kill_urb(usb->audio_urbs[i]);\r\nvideo_submit_failed:\r\nfor (i = 0; i < 8; ++i)\r\nusb_kill_urb(usb->video_urbs[i]);\r\nreturn -1;\r\n}\r\nstatic int go7007_usb_stream_stop(struct go7007 *go)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint i;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn 0;\r\nfor (i = 0; i < 8; ++i)\r\nusb_kill_urb(usb->video_urbs[i]);\r\nif (go->audio_enabled)\r\nfor (i = 0; i < 8; ++i)\r\nusb_kill_urb(usb->audio_urbs[i]);\r\nreturn 0;\r\n}\r\nstatic int go7007_usb_send_firmware(struct go7007 *go, u8 *data, int len)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nint transferred, pipe;\r\nint timeout = 500;\r\npr_debug("DownloadBuffer sending %d bytes\n", len);\r\nif (usb->board->flags & GO7007_USB_EZUSB)\r\npipe = usb_sndbulkpipe(usb->usbdev, 2);\r\nelse\r\npipe = usb_sndbulkpipe(usb->usbdev, 3);\r\nreturn usb_bulk_msg(usb->usbdev, pipe, data, len,\r\n&transferred, timeout);\r\n}\r\nstatic void go7007_usb_release(struct go7007 *go)\r\n{\r\nstruct go7007_usb *usb = go->hpi_context;\r\nstruct urb *vurb, *aurb;\r\nint i;\r\nif (usb->intr_urb) {\r\nusb_kill_urb(usb->intr_urb);\r\nkfree(usb->intr_urb->transfer_buffer);\r\nusb_free_urb(usb->intr_urb);\r\n}\r\nfor (i = 0; i < 8; ++i) {\r\nvurb = usb->video_urbs[i];\r\nif (vurb) {\r\nusb_kill_urb(vurb);\r\nkfree(vurb->transfer_buffer);\r\nusb_free_urb(vurb);\r\n}\r\naurb = usb->audio_urbs[i];\r\nif (aurb) {\r\nusb_kill_urb(aurb);\r\nkfree(aurb->transfer_buffer);\r\nusb_free_urb(aurb);\r\n}\r\n}\r\nkfree(go->hpi_context);\r\n}\r\nstatic int go7007_usb_i2c_master_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg msgs[], int num)\r\n{\r\nstruct go7007 *go = i2c_get_adapdata(adapter);\r\nstruct go7007_usb *usb = go->hpi_context;\r\nu8 *buf = go->usb_buf;\r\nint buf_len, i;\r\nint ret = -EIO;\r\nif (go->status == STATUS_SHUTDOWN)\r\nreturn -ENODEV;\r\nmutex_lock(&usb->i2c_lock);\r\nfor (i = 0; i < num; ++i) {\r\nif (i + 1 < num && msgs[i].addr == msgs[i + 1].addr &&\r\n!(msgs[i].flags & I2C_M_RD) &&\r\n(msgs[i + 1].flags & I2C_M_RD)) {\r\n#ifdef GO7007_I2C_DEBUG\r\npr_debug("i2c write/read %d/%d bytes on %02x\n",\r\nmsgs[i].len, msgs[i + 1].len, msgs[i].addr);\r\n#endif\r\nbuf[0] = 0x01;\r\nbuf[1] = msgs[i].len + 1;\r\nbuf[2] = msgs[i].addr << 1;\r\nmemcpy(&buf[3], msgs[i].buf, msgs[i].len);\r\nbuf_len = msgs[i].len + 3;\r\nbuf[buf_len++] = msgs[++i].len;\r\n} else if (msgs[i].flags & I2C_M_RD) {\r\n#ifdef GO7007_I2C_DEBUG\r\npr_debug("i2c read %d bytes on %02x\n",\r\nmsgs[i].len, msgs[i].addr);\r\n#endif\r\nbuf[0] = 0x01;\r\nbuf[1] = 1;\r\nbuf[2] = msgs[i].addr << 1;\r\nbuf[3] = msgs[i].len;\r\nbuf_len = 4;\r\n} else {\r\n#ifdef GO7007_I2C_DEBUG\r\npr_debug("i2c write %d bytes on %02x\n",\r\nmsgs[i].len, msgs[i].addr);\r\n#endif\r\nbuf[0] = 0x00;\r\nbuf[1] = msgs[i].len + 1;\r\nbuf[2] = msgs[i].addr << 1;\r\nmemcpy(&buf[3], msgs[i].buf, msgs[i].len);\r\nbuf_len = msgs[i].len + 3;\r\nbuf[buf_len++] = 0;\r\n}\r\nif (go7007_usb_vendor_request(go, 0x24, 0, 0,\r\nbuf, buf_len, 0) < 0)\r\ngoto i2c_done;\r\nif (msgs[i].flags & I2C_M_RD) {\r\nmemset(buf, 0, msgs[i].len + 1);\r\nif (go7007_usb_vendor_request(go, 0x25, 0, 0, buf,\r\nmsgs[i].len + 1, 1) < 0)\r\ngoto i2c_done;\r\nmemcpy(msgs[i].buf, buf + 1, msgs[i].len);\r\n}\r\n}\r\nret = num;\r\ni2c_done:\r\nmutex_unlock(&usb->i2c_lock);\r\nreturn ret;\r\n}\r\nstatic u32 go7007_usb_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn (I2C_FUNC_SMBUS_EMUL) & ~I2C_FUNC_SMBUS_QUICK;\r\n}\r\nstatic int go7007_usb_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct go7007 *go;\r\nstruct go7007_usb *usb;\r\nconst struct go7007_usb_board *board;\r\nstruct usb_device *usbdev = interface_to_usbdev(intf);\r\nunsigned num_i2c_devs;\r\nchar *name;\r\nint video_pipe, i, v_urb_len;\r\npr_debug("probing new GO7007 USB board\n");\r\nswitch (id->driver_info) {\r\ncase GO7007_BOARDID_MATRIX_II:\r\nname = "WIS Matrix II or compatible";\r\nboard = &board_matrix_ii;\r\nbreak;\r\ncase GO7007_BOARDID_MATRIX_RELOAD:\r\nname = "WIS Matrix Reloaded or compatible";\r\nboard = &board_matrix_reload;\r\nbreak;\r\ncase GO7007_BOARDID_MATRIX_REV:\r\nname = "WIS Matrix Revolution or compatible";\r\nboard = &board_matrix_revolution;\r\nbreak;\r\ncase GO7007_BOARDID_STAR_TREK:\r\nname = "WIS Star Trek or compatible";\r\nboard = &board_star_trek;\r\nbreak;\r\ncase GO7007_BOARDID_XMEN:\r\nname = "WIS XMen or compatible";\r\nboard = &board_xmen;\r\nbreak;\r\ncase GO7007_BOARDID_XMEN_II:\r\nname = "WIS XMen II or compatible";\r\nboard = &board_xmen;\r\nbreak;\r\ncase GO7007_BOARDID_XMEN_III:\r\nname = "WIS XMen III or compatible";\r\nboard = &board_xmen;\r\nbreak;\r\ncase GO7007_BOARDID_PX_M402U:\r\nname = "Plextor PX-M402U";\r\nboard = &board_matrix_ii;\r\nbreak;\r\ncase GO7007_BOARDID_PX_TV402U:\r\nname = "Plextor PX-TV402U (unknown tuner)";\r\nboard = &board_px_tv402u;\r\nbreak;\r\ncase GO7007_BOARDID_LIFEVIEW_LR192:\r\ndev_err(&intf->dev, "The Lifeview TV Walker Ultra is not supported. Sorry!\n");\r\nreturn -ENODEV;\r\n#if 0\r\nname = "Lifeview TV Walker Ultra";\r\nboard = &board_lifeview_lr192;\r\n#endif\r\nbreak;\r\ncase GO7007_BOARDID_SENSORAY_2250:\r\ndev_info(&intf->dev, "Sensoray 2250 found\n");\r\nname = "Sensoray 2250/2251";\r\nboard = &board_sensoray_2250;\r\nbreak;\r\ncase GO7007_BOARDID_ADS_USBAV_709:\r\nname = "ADS Tech DVD Xpress DX2";\r\nboard = &board_ads_usbav_709;\r\nbreak;\r\ndefault:\r\ndev_err(&intf->dev, "unknown board ID %d!\n",\r\n(unsigned int)id->driver_info);\r\nreturn -ENODEV;\r\n}\r\ngo = go7007_alloc(&board->main_info, &intf->dev);\r\nif (go == NULL)\r\nreturn -ENOMEM;\r\nusb = kzalloc(sizeof(struct go7007_usb), GFP_KERNEL);\r\nif (usb == NULL) {\r\nkfree(go);\r\nreturn -ENOMEM;\r\n}\r\nusb->board = board;\r\nusb->usbdev = usbdev;\r\nusb_make_path(usbdev, go->bus_info, sizeof(go->bus_info));\r\ngo->board_id = id->driver_info;\r\nstrncpy(go->name, name, sizeof(go->name));\r\nif (board->flags & GO7007_USB_EZUSB)\r\ngo->hpi_ops = &go7007_usb_ezusb_hpi_ops;\r\nelse\r\ngo->hpi_ops = &go7007_usb_onboard_hpi_ops;\r\ngo->hpi_context = usb;\r\nusb->intr_urb = usb_alloc_urb(0, GFP_KERNEL);\r\nif (usb->intr_urb == NULL)\r\ngoto allocfail;\r\nusb->intr_urb->transfer_buffer = kmalloc(2*sizeof(u16), GFP_KERNEL);\r\nif (usb->intr_urb->transfer_buffer == NULL)\r\ngoto allocfail;\r\nif (go->board_id == GO7007_BOARDID_SENSORAY_2250)\r\nusb_fill_bulk_urb(usb->intr_urb, usb->usbdev,\r\nusb_rcvbulkpipe(usb->usbdev, 4),\r\nusb->intr_urb->transfer_buffer, 2*sizeof(u16),\r\ngo7007_usb_readinterrupt_complete, go);\r\nelse\r\nusb_fill_int_urb(usb->intr_urb, usb->usbdev,\r\nusb_rcvintpipe(usb->usbdev, 4),\r\nusb->intr_urb->transfer_buffer, 2*sizeof(u16),\r\ngo7007_usb_readinterrupt_complete, go, 8);\r\nusb_set_intfdata(intf, &go->v4l2_dev);\r\nif (go7007_boot_encoder(go, go->board_info->flags &\r\nGO7007_BOARD_USE_ONBOARD_I2C) < 0)\r\ngoto allocfail;\r\nif (board->flags & GO7007_USB_EZUSB_I2C) {\r\nmemcpy(&go->i2c_adapter, &go7007_usb_adap_templ,\r\nsizeof(go7007_usb_adap_templ));\r\nmutex_init(&usb->i2c_lock);\r\ngo->i2c_adapter.dev.parent = go->dev;\r\ni2c_set_adapdata(&go->i2c_adapter, go);\r\nif (i2c_add_adapter(&go->i2c_adapter) < 0) {\r\ndev_err(go->dev, "error: i2c_add_adapter failed\n");\r\ngoto allocfail;\r\n}\r\ngo->i2c_adapter_online = 1;\r\n}\r\nif ((go->board_id == GO7007_BOARDID_XMEN ||\r\ngo->board_id == GO7007_BOARDID_XMEN_III) &&\r\ngo->i2c_adapter_online) {\r\nunion i2c_smbus_data data;\r\ni2c_smbus_xfer(&go->i2c_adapter, 0x21, I2C_CLIENT_SCCB,\r\nI2C_SMBUS_READ, 0x0A, I2C_SMBUS_BYTE_DATA, &data);\r\nif (data.byte != 0x76) {\r\nif (assume_endura) {\r\ngo->board_id = GO7007_BOARDID_ENDURA;\r\nusb->board = board = &board_endura;\r\ngo->board_info = &board->main_info;\r\nstrncpy(go->name, "Pelco Endura",\r\nsizeof(go->name));\r\n} else {\r\nu16 channel;\r\ngo7007_read_addr(go, 0x3c81, &channel);\r\nchannel &= 0x3;\r\ngo->board_id = GO7007_BOARDID_ADLINK_MPG24;\r\nusb->board = board = &board_adlink_mpg24;\r\ngo->board_info = &board->main_info;\r\ngo->channel_number = channel;\r\nsnprintf(go->name, sizeof(go->name),\r\n"Adlink PCI-MPG24, channel #%d",\r\nchannel);\r\n}\r\ngo7007_update_board(go);\r\n}\r\n}\r\nnum_i2c_devs = go->board_info->num_i2c_devs;\r\nif (go->board_id == GO7007_BOARDID_PX_TV402U) {\r\nif (go7007_usb_vendor_request(go, 0x41, 0, 0, go->usb_buf, 3,\r\n1) < 0) {\r\ndev_err(go->dev, "GPIO read failed!\n");\r\ngoto allocfail;\r\n}\r\nswitch (go->usb_buf[0] >> 6) {\r\ncase 1:\r\ngo->tuner_type = TUNER_SONY_BTF_PG472Z;\r\ngo->std = V4L2_STD_PAL;\r\nstrncpy(go->name, "Plextor PX-TV402U-EU",\r\nsizeof(go->name));\r\nbreak;\r\ncase 2:\r\ngo->tuner_type = TUNER_SONY_BTF_PK467Z;\r\ngo->std = V4L2_STD_NTSC_M_JP;\r\nnum_i2c_devs -= 2;\r\nstrncpy(go->name, "Plextor PX-TV402U-JP",\r\nsizeof(go->name));\r\nbreak;\r\ncase 3:\r\ngo->tuner_type = TUNER_SONY_BTF_PB463Z;\r\nnum_i2c_devs -= 2;\r\nstrncpy(go->name, "Plextor PX-TV402U-NA",\r\nsizeof(go->name));\r\nbreak;\r\ndefault:\r\npr_debug("unable to detect tuner type!\n");\r\nbreak;\r\n}\r\nif (go7007_usb_vendor_request(go, 0x40, 0x7f02, 0,\r\nNULL, 0, 0) < 0) {\r\ndev_err(go->dev, "GPIO write failed!\n");\r\ngoto allocfail;\r\n}\r\n}\r\nif ((board->flags & GO7007_USB_EZUSB) &&\r\nusbdev->speed != USB_SPEED_HIGH)\r\ndev_err(go->dev, "*** WARNING *** This device must be connected to a USB 2.0 port! Attempting to capture video through a USB 1.1 port will result in stream corruption, even at low bitrates!\n");\r\nif (board->flags & GO7007_USB_EZUSB) {\r\nv_urb_len = 1024;\r\nvideo_pipe = usb_rcvbulkpipe(usb->usbdev, 6);\r\n} else {\r\nv_urb_len = 512;\r\nvideo_pipe = usb_rcvbulkpipe(usb->usbdev, 1);\r\n}\r\nfor (i = 0; i < 8; ++i) {\r\nusb->video_urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (usb->video_urbs[i] == NULL)\r\ngoto allocfail;\r\nusb->video_urbs[i]->transfer_buffer =\r\nkmalloc(v_urb_len, GFP_KERNEL);\r\nif (usb->video_urbs[i]->transfer_buffer == NULL)\r\ngoto allocfail;\r\nusb_fill_bulk_urb(usb->video_urbs[i], usb->usbdev, video_pipe,\r\nusb->video_urbs[i]->transfer_buffer, v_urb_len,\r\ngo7007_usb_read_video_pipe_complete, go);\r\n}\r\nif ((board->flags & GO7007_USB_EZUSB) &&\r\n(board->main_info.flags & GO7007_BOARD_HAS_AUDIO)) {\r\nfor (i = 0; i < 8; ++i) {\r\nusb->audio_urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\r\nif (usb->audio_urbs[i] == NULL)\r\ngoto allocfail;\r\nusb->audio_urbs[i]->transfer_buffer = kmalloc(4096,\r\nGFP_KERNEL);\r\nif (usb->audio_urbs[i]->transfer_buffer == NULL)\r\ngoto allocfail;\r\nusb_fill_bulk_urb(usb->audio_urbs[i], usb->usbdev,\r\nusb_rcvbulkpipe(usb->usbdev, 8),\r\nusb->audio_urbs[i]->transfer_buffer, 4096,\r\ngo7007_usb_read_audio_pipe_complete, go);\r\n}\r\n}\r\nif (go7007_register_encoder(go, num_i2c_devs) < 0)\r\ngoto allocfail;\r\ngo->status = STATUS_ONLINE;\r\nreturn 0;\r\nallocfail:\r\ngo7007_usb_release(go);\r\nkfree(go);\r\nreturn -ENOMEM;\r\n}\r\nstatic void go7007_usb_disconnect(struct usb_interface *intf)\r\n{\r\nstruct go7007 *go = to_go7007(usb_get_intfdata(intf));\r\nmutex_lock(&go->queue_lock);\r\nmutex_lock(&go->serialize_lock);\r\nif (go->audio_enabled)\r\ngo7007_snd_remove(go);\r\ngo->status = STATUS_SHUTDOWN;\r\nv4l2_device_disconnect(&go->v4l2_dev);\r\nvideo_unregister_device(&go->vdev);\r\nmutex_unlock(&go->serialize_lock);\r\nmutex_unlock(&go->queue_lock);\r\nv4l2_device_put(&go->v4l2_dev);\r\n}
