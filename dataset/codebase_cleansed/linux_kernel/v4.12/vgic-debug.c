static void iter_next(struct vgic_state_iter *iter)\r\n{\r\nif (iter->dist_id == 0) {\r\niter->dist_id++;\r\nreturn;\r\n}\r\niter->intid++;\r\nif (iter->intid == VGIC_NR_PRIVATE_IRQS &&\r\n++iter->vcpu_id < iter->nr_cpus)\r\niter->intid = 0;\r\n}\r\nstatic void iter_init(struct kvm *kvm, struct vgic_state_iter *iter,\r\nloff_t pos)\r\n{\r\nint nr_cpus = atomic_read(&kvm->online_vcpus);\r\nmemset(iter, 0, sizeof(*iter));\r\niter->nr_cpus = nr_cpus;\r\niter->nr_spis = kvm->arch.vgic.nr_spis;\r\nwhile (pos--)\r\niter_next(iter);\r\n}\r\nstatic bool end_of_vgic(struct vgic_state_iter *iter)\r\n{\r\nreturn iter->dist_id > 0 &&\r\niter->vcpu_id == iter->nr_cpus &&\r\n(iter->intid - VGIC_NR_PRIVATE_IRQS) == iter->nr_spis;\r\n}\r\nstatic void *vgic_debug_start(struct seq_file *s, loff_t *pos)\r\n{\r\nstruct kvm *kvm = (struct kvm *)s->private;\r\nstruct vgic_state_iter *iter;\r\nmutex_lock(&kvm->lock);\r\niter = kvm->arch.vgic.iter;\r\nif (iter) {\r\niter = ERR_PTR(-EBUSY);\r\ngoto out;\r\n}\r\niter = kmalloc(sizeof(*iter), GFP_KERNEL);\r\nif (!iter) {\r\niter = ERR_PTR(-ENOMEM);\r\ngoto out;\r\n}\r\niter_init(kvm, iter, *pos);\r\nkvm->arch.vgic.iter = iter;\r\nif (end_of_vgic(iter))\r\niter = NULL;\r\nout:\r\nmutex_unlock(&kvm->lock);\r\nreturn iter;\r\n}\r\nstatic void *vgic_debug_next(struct seq_file *s, void *v, loff_t *pos)\r\n{\r\nstruct kvm *kvm = (struct kvm *)s->private;\r\nstruct vgic_state_iter *iter = kvm->arch.vgic.iter;\r\n++*pos;\r\niter_next(iter);\r\nif (end_of_vgic(iter))\r\niter = NULL;\r\nreturn iter;\r\n}\r\nstatic void vgic_debug_stop(struct seq_file *s, void *v)\r\n{\r\nstruct kvm *kvm = (struct kvm *)s->private;\r\nstruct vgic_state_iter *iter;\r\nif (IS_ERR(v))\r\nreturn;\r\nmutex_lock(&kvm->lock);\r\niter = kvm->arch.vgic.iter;\r\nkfree(iter);\r\nkvm->arch.vgic.iter = NULL;\r\nmutex_unlock(&kvm->lock);\r\n}\r\nstatic void print_dist_state(struct seq_file *s, struct vgic_dist *dist)\r\n{\r\nseq_printf(s, "Distributor\n");\r\nseq_printf(s, "===========\n");\r\nseq_printf(s, "vgic_model:\t%s\n",\r\n(dist->vgic_model == KVM_DEV_TYPE_ARM_VGIC_V3) ?\r\n"GICv3" : "GICv2");\r\nseq_printf(s, "nr_spis:\t%d\n", dist->nr_spis);\r\nseq_printf(s, "enabled:\t%d\n", dist->enabled);\r\nseq_printf(s, "\n");\r\nseq_printf(s, "P=pending_latch, L=line_level, A=active\n");\r\nseq_printf(s, "E=enabled, H=hw, C=config (level=1, edge=0)\n");\r\n}\r\nstatic void print_header(struct seq_file *s, struct vgic_irq *irq,\r\nstruct kvm_vcpu *vcpu)\r\n{\r\nint id = 0;\r\nchar *hdr = "SPI ";\r\nif (vcpu) {\r\nhdr = "VCPU";\r\nid = vcpu->vcpu_id;\r\n}\r\nseq_printf(s, "\n");\r\nseq_printf(s, "%s%2d TYP ID TGT_ID PLAEHC HWID TARGET SRC PRI VCPU_ID\n", hdr, id);\r\nseq_printf(s, "---------------------------------------------------------------\n");\r\n}\r\nstatic void print_irq_state(struct seq_file *s, struct vgic_irq *irq,\r\nstruct kvm_vcpu *vcpu)\r\n{\r\nchar *type;\r\nif (irq->intid < VGIC_NR_SGIS)\r\ntype = "SGI";\r\nelse if (irq->intid < VGIC_NR_PRIVATE_IRQS)\r\ntype = "PPI";\r\nelse\r\ntype = "SPI";\r\nif (irq->intid ==0 || irq->intid == VGIC_NR_PRIVATE_IRQS)\r\nprint_header(s, irq, vcpu);\r\nseq_printf(s, " %s %4d "\r\n" %2d "\r\n"%d%d%d%d%d%d "\r\n"%8d "\r\n"%8x "\r\n" %2x "\r\n"%3d "\r\n" %2d "\r\n"\n",\r\ntype, irq->intid,\r\n(irq->target_vcpu) ? irq->target_vcpu->vcpu_id : -1,\r\nirq->pending_latch,\r\nirq->line_level,\r\nirq->active,\r\nirq->enabled,\r\nirq->hw,\r\nirq->config == VGIC_CONFIG_LEVEL,\r\nirq->hwintid,\r\nirq->mpidr,\r\nirq->source,\r\nirq->priority,\r\n(irq->vcpu) ? irq->vcpu->vcpu_id : -1);\r\n}\r\nstatic int vgic_debug_show(struct seq_file *s, void *v)\r\n{\r\nstruct kvm *kvm = (struct kvm *)s->private;\r\nstruct vgic_state_iter *iter = (struct vgic_state_iter *)v;\r\nstruct vgic_irq *irq;\r\nstruct kvm_vcpu *vcpu = NULL;\r\nif (iter->dist_id == 0) {\r\nprint_dist_state(s, &kvm->arch.vgic);\r\nreturn 0;\r\n}\r\nif (!kvm->arch.vgic.initialized)\r\nreturn 0;\r\nif (iter->vcpu_id < iter->nr_cpus) {\r\nvcpu = kvm_get_vcpu(kvm, iter->vcpu_id);\r\nirq = &vcpu->arch.vgic_cpu.private_irqs[iter->intid];\r\n} else {\r\nirq = &kvm->arch.vgic.spis[iter->intid - VGIC_NR_PRIVATE_IRQS];\r\n}\r\nspin_lock(&irq->irq_lock);\r\nprint_irq_state(s, irq, vcpu);\r\nspin_unlock(&irq->irq_lock);\r\nreturn 0;\r\n}\r\nstatic int debug_open(struct inode *inode, struct file *file)\r\n{\r\nint ret;\r\nret = seq_open(file, &vgic_debug_seq_ops);\r\nif (!ret) {\r\nstruct seq_file *seq;\r\nseq = file->private_data;\r\nseq->private = inode->i_private;\r\n}\r\nreturn ret;\r\n}\r\nint vgic_debug_init(struct kvm *kvm)\r\n{\r\nif (!kvm->debugfs_dentry)\r\nreturn -ENOENT;\r\nif (!debugfs_create_file("vgic-state", 0444,\r\nkvm->debugfs_dentry,\r\nkvm,\r\n&vgic_debug_fops))\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nint vgic_debug_destroy(struct kvm *kvm)\r\n{\r\nreturn 0;\r\n}
