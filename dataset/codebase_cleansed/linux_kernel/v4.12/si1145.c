static int __si1145_command_reset(struct si1145_data *data)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nunsigned long stop_jiffies;\r\nint ret;\r\nret = i2c_smbus_write_byte_data(data->client, SI1145_REG_COMMAND,\r\nSI1145_CMD_NOP);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(SI1145_COMMAND_MINSLEEP_MS);\r\nstop_jiffies = jiffies + SI1145_COMMAND_TIMEOUT_MS * HZ / 1000;\r\nwhile (true) {\r\nret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_REG_RESPONSE);\r\nif (ret <= 0)\r\nreturn ret;\r\nif (time_after(jiffies, stop_jiffies)) {\r\ndev_warn(dev, "timeout on reset\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nmsleep(SI1145_COMMAND_MINSLEEP_MS);\r\ncontinue;\r\n}\r\n}\r\nstatic int si1145_command(struct si1145_data *data, u8 cmd)\r\n{\r\nstruct device *dev = &data->client->dev;\r\nunsigned long stop_jiffies;\r\nint ret;\r\nmutex_lock(&data->cmdlock);\r\nif (data->rsp_seq < 0) {\r\nret = __si1145_command_reset(data);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to reset command counter, ret=%d\n",\r\nret);\r\ngoto out;\r\n}\r\ndata->rsp_seq = 0;\r\n}\r\nret = i2c_smbus_write_byte_data(data->client, SI1145_REG_COMMAND, cmd);\r\nif (ret) {\r\ndev_warn(dev, "failed to write command, ret=%d\n", ret);\r\ngoto out;\r\n}\r\nmsleep(SI1145_COMMAND_MINSLEEP_MS);\r\nstop_jiffies = jiffies + SI1145_COMMAND_TIMEOUT_MS * HZ / 1000;\r\nwhile (true) {\r\nret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_REG_RESPONSE);\r\nif (ret < 0) {\r\ndev_warn(dev, "failed to read response, ret=%d\n", ret);\r\nbreak;\r\n}\r\nif ((ret & ~SI1145_RSP_COUNTER_MASK) == 0) {\r\nif (ret == data->rsp_seq) {\r\nif (time_after(jiffies, stop_jiffies)) {\r\ndev_warn(dev, "timeout on command %#02hhx\n",\r\ncmd);\r\nret = -ETIMEDOUT;\r\nbreak;\r\n}\r\nmsleep(SI1145_COMMAND_MINSLEEP_MS);\r\ncontinue;\r\n}\r\nif (ret == ((data->rsp_seq + 1) &\r\nSI1145_RSP_COUNTER_MASK)) {\r\ndata->rsp_seq = ret;\r\nret = 0;\r\nbreak;\r\n}\r\ndev_warn(dev, "unexpected response counter %d instead of %d\n",\r\nret, (data->rsp_seq + 1) &\r\nSI1145_RSP_COUNTER_MASK);\r\nret = -EIO;\r\n} else {\r\nif (ret == SI1145_RSP_INVALID_SETTING) {\r\ndev_warn(dev, "INVALID_SETTING error on command %#02hhx\n",\r\ncmd);\r\nret = -EINVAL;\r\n} else {\r\ndev_dbg(dev, "overflow, ret=%d, cmd=%#02hhx\n",\r\nret, cmd);\r\nret = -EOVERFLOW;\r\n}\r\n}\r\ndata->rsp_seq = -1;\r\nbreak;\r\n}\r\nout:\r\nmutex_unlock(&data->cmdlock);\r\nreturn ret;\r\n}\r\nstatic int si1145_param_update(struct si1145_data *data, u8 op, u8 param,\r\nu8 value)\r\n{\r\nint ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_PARAM_WR, value);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn si1145_command(data, op | (param & 0x1F));\r\n}\r\nstatic int si1145_param_set(struct si1145_data *data, u8 param, u8 value)\r\n{\r\nreturn si1145_param_update(data, SI1145_CMD_PARAM_SET, param, value);\r\n}\r\nstatic int si1145_param_query(struct si1145_data *data, u8 param)\r\n{\r\nint ret;\r\nret = si1145_command(data, SI1145_CMD_PARAM_QUERY | (param & 0x1F));\r\nif (ret < 0)\r\nreturn ret;\r\nreturn i2c_smbus_read_byte_data(data->client, SI1145_REG_PARAM_RD);\r\n}\r\nstatic u16 si1145_uncompress(u8 x)\r\n{\r\nu16 result = 0;\r\nu8 exponent = 0;\r\nif (x < 8)\r\nreturn 0;\r\nexponent = (x & 0xf0) >> 4;\r\nresult = 0x10 | (x & 0x0f);\r\nif (exponent >= 4)\r\nreturn result << (exponent - 4);\r\nreturn result >> (4 - exponent);\r\n}\r\nstatic u8 si1145_compress(u16 x)\r\n{\r\nu32 exponent = 0;\r\nu32 significand = 0;\r\nu32 tmp = x;\r\nif (x == 0x0000)\r\nreturn 0x00;\r\nif (x == 0x0001)\r\nreturn 0x08;\r\nwhile (1) {\r\ntmp >>= 1;\r\nexponent += 1;\r\nif (tmp == 1)\r\nbreak;\r\n}\r\nif (exponent < 5) {\r\nsignificand = x << (4 - exponent);\r\nreturn (exponent << 4) | (significand & 0xF);\r\n}\r\nsignificand = x >> (exponent - 5);\r\nif (significand & 1) {\r\nsignificand += 2;\r\nif (significand & 0x0040) {\r\nexponent += 1;\r\nsignificand >>= 1;\r\n}\r\n}\r\nreturn (exponent << 4) | ((significand >> 1) & 0xF);\r\n}\r\nstatic int si1145_set_meas_rate(struct si1145_data *data, int interval)\r\n{\r\nif (data->part_info->uncompressed_meas_rate)\r\nreturn i2c_smbus_write_word_data(data->client,\r\nSI1145_REG_MEAS_RATE, interval);\r\nelse\r\nreturn i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_MEAS_RATE, interval);\r\n}\r\nstatic int si1145_read_samp_freq(struct si1145_data *data, int *val, int *val2)\r\n{\r\n*val = 32000;\r\nif (data->part_info->uncompressed_meas_rate)\r\n*val2 = data->meas_rate;\r\nelse\r\n*val2 = si1145_uncompress(data->meas_rate);\r\nreturn IIO_VAL_FRACTIONAL;\r\n}\r\nstatic int si1145_store_samp_freq(struct si1145_data *data, int val)\r\n{\r\nint ret = 0;\r\nint meas_rate;\r\nif (val <= 0 || val > 32000)\r\nreturn -ERANGE;\r\nmeas_rate = 32000 / val;\r\nmutex_lock(&data->lock);\r\nif (data->autonomous) {\r\nret = si1145_set_meas_rate(data, meas_rate);\r\nif (ret)\r\ngoto out;\r\n}\r\nif (data->part_info->uncompressed_meas_rate)\r\ndata->meas_rate = meas_rate;\r\nelse\r\ndata->meas_rate = si1145_compress(meas_rate);\r\nout:\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t si1145_trigger_handler(int irq, void *private)\r\n{\r\nstruct iio_poll_func *pf = private;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nu8 buffer[24];\r\nint i, j = 0;\r\nint ret;\r\nu8 irq_status = 0;\r\nif (!data->autonomous) {\r\nret = si1145_command(data, SI1145_CMD_PSALS_FORCE);\r\nif (ret < 0 && ret != -EOVERFLOW)\r\ngoto done;\r\n} else {\r\nirq_status = ret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_REG_IRQ_STATUS);\r\nif (ret < 0)\r\ngoto done;\r\nif (!(irq_status & SI1145_MASK_ALL_IE))\r\ngoto done;\r\n}\r\nfor_each_set_bit(i, indio_dev->active_scan_mask,\r\nindio_dev->masklength) {\r\nint run = 1;\r\nwhile (i + run < indio_dev->masklength) {\r\nif (!test_bit(i + run, indio_dev->active_scan_mask))\r\nbreak;\r\nif (indio_dev->channels[i + run].address !=\r\nindio_dev->channels[i].address + 2 * run)\r\nbreak;\r\nrun++;\r\n}\r\nret = i2c_smbus_read_i2c_block_data_or_emulated(\r\ndata->client, indio_dev->channels[i].address,\r\nsizeof(u16) * run, &buffer[j]);\r\nif (ret < 0)\r\ngoto done;\r\nj += run * sizeof(u16);\r\ni += run - 1;\r\n}\r\nif (data->autonomous) {\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_IRQ_STATUS,\r\nirq_status & SI1145_MASK_ALL_IE);\r\nif (ret < 0)\r\ngoto done;\r\n}\r\niio_push_to_buffers_with_timestamp(indio_dev, buffer,\r\niio_get_time_ns(indio_dev));\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int si1145_set_chlist(struct iio_dev *indio_dev, unsigned long scan_mask)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nu8 reg = 0, mux;\r\nint ret;\r\nint i;\r\nif (data->scan_mask == scan_mask)\r\nreturn 0;\r\nfor_each_set_bit(i, &scan_mask, indio_dev->masklength) {\r\nswitch (indio_dev->channels[i].address) {\r\ncase SI1145_REG_ALSVIS_DATA:\r\nreg |= SI1145_CHLIST_EN_ALSVIS;\r\nbreak;\r\ncase SI1145_REG_ALSIR_DATA:\r\nreg |= SI1145_CHLIST_EN_ALSIR;\r\nbreak;\r\ncase SI1145_REG_PS1_DATA:\r\nreg |= SI1145_CHLIST_EN_PS1;\r\nbreak;\r\ncase SI1145_REG_PS2_DATA:\r\nreg |= SI1145_CHLIST_EN_PS2;\r\nbreak;\r\ncase SI1145_REG_PS3_DATA:\r\nreg |= SI1145_CHLIST_EN_PS3;\r\nbreak;\r\ncase SI1145_REG_AUX_DATA:\r\nswitch (indio_dev->channels[i].type) {\r\ncase IIO_UVINDEX:\r\nreg |= SI1145_CHLIST_EN_UV;\r\nbreak;\r\ndefault:\r\nreg |= SI1145_CHLIST_EN_AUX;\r\nif (indio_dev->channels[i].type == IIO_TEMP)\r\nmux = SI1145_MUX_TEMP;\r\nelse\r\nmux = SI1145_MUX_VDD;\r\nret = si1145_param_set(data,\r\nSI1145_PARAM_AUX_ADC_MUX, mux);\r\nif (ret < 0)\r\nreturn ret;\r\nbreak;\r\n}\r\n}\r\n}\r\ndata->scan_mask = scan_mask;\r\nret = si1145_param_set(data, SI1145_PARAM_CHLIST, reg);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int si1145_measure(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nu8 cmd;\r\nint ret;\r\nret = si1145_set_chlist(indio_dev, BIT(chan->scan_index));\r\nif (ret < 0)\r\nreturn ret;\r\ncmd = (chan->type == IIO_PROXIMITY) ? SI1145_CMD_PS_FORCE :\r\nSI1145_CMD_ALS_FORCE;\r\nret = si1145_command(data, cmd);\r\nif (ret < 0 && ret != -EOVERFLOW)\r\nreturn ret;\r\nreturn i2c_smbus_read_word_data(data->client, chan->address);\r\n}\r\nstatic int si1145_scale_from_adcgain(int regval)\r\n{\r\nreturn 128 >> regval;\r\n}\r\nstatic int si1145_proximity_adcgain_from_scale(int val, int val2)\r\n{\r\nval = find_closest_descending(val, si1145_proximity_scale_available,\r\nARRAY_SIZE(si1145_proximity_scale_available));\r\nif (val < 0 || val > 5 || val2 != 0)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nstatic int si1145_intensity_adcgain_from_scale(int val, int val2)\r\n{\r\nval = find_closest_descending(val, si1145_intensity_scale_available,\r\nARRAY_SIZE(si1145_intensity_scale_available));\r\nif (val < 0 || val > 7 || val2 != 0)\r\nreturn -EINVAL;\r\nreturn val;\r\n}\r\nstatic int si1145_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nint ret;\r\nu8 reg;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\nswitch (chan->type) {\r\ncase IIO_INTENSITY:\r\ncase IIO_PROXIMITY:\r\ncase IIO_VOLTAGE:\r\ncase IIO_TEMP:\r\ncase IIO_UVINDEX:\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nret = si1145_measure(indio_dev, chan);\r\niio_device_release_direct_mode(indio_dev);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret;\r\nreturn IIO_VAL_INT;\r\ncase IIO_CURRENT:\r\nret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_PS_LED_REG(chan->channel));\r\nif (ret < 0)\r\nreturn ret;\r\n*val = (ret >> SI1145_PS_LED_SHIFT(chan->channel))\r\n& 0x0f;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_PROXIMITY:\r\nreg = SI1145_PARAM_PS_ADC_GAIN;\r\nbreak;\r\ncase IIO_INTENSITY:\r\nif (chan->channel2 == IIO_MOD_LIGHT_IR)\r\nreg = SI1145_PARAM_ALSIR_ADC_GAIN;\r\nelse\r\nreg = SI1145_PARAM_ALSVIS_ADC_GAIN;\r\nbreak;\r\ncase IIO_TEMP:\r\n*val = 28;\r\n*val2 = 571429;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ncase IIO_UVINDEX:\r\n*val = 0;\r\n*val2 = 10000;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = si1145_param_query(data, reg);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = si1145_scale_from_adcgain(ret & 0x07);\r\nreturn IIO_VAL_INT;\r\ncase IIO_CHAN_INFO_OFFSET:\r\nswitch (chan->type) {\r\ncase IIO_TEMP:\r\n*val = -256 - 11136 + 25 * 35;\r\nreturn IIO_VAL_INT;\r\ndefault:\r\nret = si1145_param_query(data, SI1145_PARAM_ADC_OFFSET);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = -si1145_uncompress(ret);\r\nreturn IIO_VAL_INT;\r\n}\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nreturn si1145_read_samp_freq(data, val, val2);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int si1145_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nu8 reg1, reg2, shift;\r\nint ret;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SCALE:\r\nswitch (chan->type) {\r\ncase IIO_PROXIMITY:\r\nval = si1145_proximity_adcgain_from_scale(val, val2);\r\nif (val < 0)\r\nreturn val;\r\nreg1 = SI1145_PARAM_PS_ADC_GAIN;\r\nreg2 = SI1145_PARAM_PS_ADC_COUNTER;\r\nbreak;\r\ncase IIO_INTENSITY:\r\nval = si1145_intensity_adcgain_from_scale(val, val2);\r\nif (val < 0)\r\nreturn val;\r\nif (chan->channel2 == IIO_MOD_LIGHT_IR) {\r\nreg1 = SI1145_PARAM_ALSIR_ADC_GAIN;\r\nreg2 = SI1145_PARAM_ALSIR_ADC_COUNTER;\r\n} else {\r\nreg1 = SI1145_PARAM_ALSVIS_ADC_GAIN;\r\nreg2 = SI1145_PARAM_ALSVIS_ADC_COUNTER;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nret = si1145_param_set(data, reg1, val);\r\nif (ret < 0) {\r\niio_device_release_direct_mode(indio_dev);\r\nreturn ret;\r\n}\r\nret = si1145_param_set(data, reg2, (~val & 0x07) << 4);\r\niio_device_release_direct_mode(indio_dev);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_RAW:\r\nif (chan->type != IIO_CURRENT)\r\nreturn -EINVAL;\r\nif (val < 0 || val > 15 || val2 != 0)\r\nreturn -EINVAL;\r\nreg1 = SI1145_PS_LED_REG(chan->channel);\r\nshift = SI1145_PS_LED_SHIFT(chan->channel);\r\nret = iio_device_claim_direct_mode(indio_dev);\r\nif (ret)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, reg1);\r\nif (ret < 0) {\r\niio_device_release_direct_mode(indio_dev);\r\nreturn ret;\r\n}\r\nret = i2c_smbus_write_byte_data(data->client, reg1,\r\n(ret & ~(0x0f << shift)) |\r\n((val & 0x0f) << shift));\r\niio_device_release_direct_mode(indio_dev);\r\nreturn ret;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nreturn si1145_store_samp_freq(data, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int si1145_initialize(struct si1145_data *data)\r\n{\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = i2c_smbus_write_byte_data(client, SI1145_REG_COMMAND,\r\nSI1145_CMD_RESET);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(SI1145_COMMAND_TIMEOUT_MS);\r\nret = i2c_smbus_write_byte_data(client, SI1145_REG_HW_KEY, 0x17);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(SI1145_COMMAND_TIMEOUT_MS);\r\nret = si1145_set_meas_rate(data, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_store_samp_freq(data, 10);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (data->part_info->num_leds) {\r\ncase 3:\r\nret = i2c_smbus_write_byte_data(client,\r\nSI1145_REG_PS_LED3,\r\nSI1145_LED_CURRENT_45mA);\r\nif (ret < 0)\r\nreturn ret;\r\ncase 2:\r\nret = i2c_smbus_write_byte_data(client,\r\nSI1145_REG_PS_LED21,\r\n(SI1145_LED_CURRENT_45mA << 4) |\r\nSI1145_LED_CURRENT_45mA);\r\nbreak;\r\ncase 1:\r\nret = i2c_smbus_write_byte_data(client,\r\nSI1145_REG_PS_LED21,\r\nSI1145_LED_CURRENT_45mA);\r\nbreak;\r\ndefault:\r\nret = 0;\r\nbreak;\r\n}\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_PS_ADC_MISC,\r\nSI1145_PS_ADC_MODE_NORMAL);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_PS_ADC_GAIN, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_PS_ADC_COUNTER, 0x06 << 4);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_ALSVIS_ADC_MISC,\r\nSI1145_ADC_MISC_RANGE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_ALSVIS_ADC_GAIN, 0x03);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_ALSVIS_ADC_COUNTER,\r\n0x04 << 4);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_ALSIR_ADC_MISC,\r\nSI1145_ADC_MISC_RANGE);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_ALSIR_ADC_GAIN, 0x01);\r\nif (ret < 0)\r\nreturn ret;\r\nret = si1145_param_set(data, SI1145_PARAM_ALSIR_ADC_COUNTER,\r\n0x06 << 4);\r\nif (ret < 0)\r\nreturn ret;\r\nif (data->part_info == &si1145_part_info[SI1132] ||\r\ndata->part_info == &si1145_part_info[SI1145] ||\r\ndata->part_info == &si1145_part_info[SI1146] ||\r\ndata->part_info == &si1145_part_info[SI1147]) {\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_UCOEF1,\r\nSI1145_UCOEF1_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_UCOEF2, SI1145_UCOEF2_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_UCOEF3, SI1145_UCOEF3_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_UCOEF4, SI1145_UCOEF4_DEFAULT);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int si1145_buffer_preenable(struct iio_dev *indio_dev)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&data->lock);\r\nret = si1145_set_chlist(indio_dev, *indio_dev->active_scan_mask);\r\nmutex_unlock(&data->lock);\r\nreturn ret;\r\n}\r\nstatic bool si1145_validate_scan_mask(struct iio_dev *indio_dev,\r\nconst unsigned long *scan_mask)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nunsigned int count = 0;\r\nint i;\r\nfor_each_set_bit(i, scan_mask, data->part_info->num_channels) {\r\nif (indio_dev->channels[i].address == SI1145_REG_AUX_DATA)\r\ncount++;\r\n}\r\nreturn count <= 1;\r\n}\r\nstatic int si1145_trigger_set_state(struct iio_trigger *trig, bool state)\r\n{\r\nstruct iio_dev *indio_dev = iio_trigger_get_drvdata(trig);\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nint err = 0, ret;\r\nmutex_lock(&data->lock);\r\nif (state) {\r\ndata->autonomous = true;\r\nerr = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_INT_CFG, SI1145_INT_CFG_OE);\r\nif (err < 0)\r\ngoto disable;\r\nerr = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_IRQ_ENABLE, SI1145_MASK_ALL_IE);\r\nif (err < 0)\r\ngoto disable;\r\nerr = si1145_set_meas_rate(data, data->meas_rate);\r\nif (err < 0)\r\ngoto disable;\r\nerr = si1145_command(data, SI1145_CMD_PSALS_AUTO);\r\nif (err < 0)\r\ngoto disable;\r\n} else {\r\ndisable:\r\nret = si1145_command(data, SI1145_CMD_PSALS_PAUSE);\r\nif (ret < 0 && !err)\r\nerr = ret;\r\nret = si1145_set_meas_rate(data, 0);\r\nif (ret < 0 && !err)\r\nerr = ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_IRQ_ENABLE, 0);\r\nif (ret < 0 && !err)\r\nerr = ret;\r\nret = i2c_smbus_write_byte_data(data->client,\r\nSI1145_REG_INT_CFG, 0);\r\nif (ret < 0 && !err)\r\nerr = ret;\r\ndata->autonomous = false;\r\n}\r\nmutex_unlock(&data->lock);\r\nreturn err;\r\n}\r\nstatic int si1145_probe_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nstruct i2c_client *client = data->client;\r\nstruct iio_trigger *trig;\r\nint ret;\r\ntrig = devm_iio_trigger_alloc(&client->dev,\r\n"%s-dev%d", indio_dev->name, indio_dev->id);\r\nif (!trig)\r\nreturn -ENOMEM;\r\ntrig->dev.parent = &client->dev;\r\ntrig->ops = &si1145_trigger_ops;\r\niio_trigger_set_drvdata(trig, indio_dev);\r\nret = devm_request_irq(&client->dev, client->irq,\r\niio_trigger_generic_data_rdy_poll,\r\nIRQF_TRIGGER_FALLING,\r\n"si1145_irq",\r\ntrig);\r\nif (ret < 0) {\r\ndev_err(&client->dev, "irq request failed\n");\r\nreturn ret;\r\n}\r\nret = iio_trigger_register(trig);\r\nif (ret)\r\nreturn ret;\r\ndata->trig = trig;\r\nindio_dev->trig = iio_trigger_get(data->trig);\r\nreturn 0;\r\n}\r\nstatic void si1145_remove_trigger(struct iio_dev *indio_dev)\r\n{\r\nstruct si1145_data *data = iio_priv(indio_dev);\r\nif (data->trig) {\r\niio_trigger_unregister(data->trig);\r\ndata->trig = NULL;\r\n}\r\n}\r\nstatic int si1145_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct si1145_data *data;\r\nstruct iio_dev *indio_dev;\r\nu8 part_id, rev_id, seq_id;\r\nint ret;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\ndata = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\ndata->client = client;\r\ndata->part_info = &si1145_part_info[id->driver_data];\r\npart_id = ret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_REG_PART_ID);\r\nif (ret < 0)\r\nreturn ret;\r\nrev_id = ret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_REG_REV_ID);\r\nif (ret < 0)\r\nreturn ret;\r\nseq_id = ret = i2c_smbus_read_byte_data(data->client,\r\nSI1145_REG_SEQ_ID);\r\nif (ret < 0)\r\nreturn ret;\r\ndev_info(&client->dev, "device ID part %#02hhx rev %#02hhx seq %#02hhx\n",\r\npart_id, rev_id, seq_id);\r\nif (part_id != data->part_info->part) {\r\ndev_err(&client->dev, "part ID mismatch got %#02hhx, expected %#02x\n",\r\npart_id, data->part_info->part);\r\nreturn -ENODEV;\r\n}\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->name = id->name;\r\nindio_dev->channels = data->part_info->channels;\r\nindio_dev->num_channels = data->part_info->num_channels;\r\nindio_dev->info = data->part_info->iio_info;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nmutex_init(&data->lock);\r\nmutex_init(&data->cmdlock);\r\nret = si1145_initialize(data);\r\nif (ret < 0)\r\nreturn ret;\r\nret = iio_triggered_buffer_setup(indio_dev, NULL,\r\nsi1145_trigger_handler, &si1145_buffer_setup_ops);\r\nif (ret < 0)\r\nreturn ret;\r\nif (client->irq) {\r\nret = si1145_probe_trigger(indio_dev);\r\nif (ret < 0)\r\ngoto error_free_buffer;\r\n} else {\r\ndev_info(&client->dev, "no irq, using polling\n");\r\n}\r\nret = iio_device_register(indio_dev);\r\nif (ret < 0)\r\ngoto error_free_trigger;\r\nreturn 0;\r\nerror_free_trigger:\r\nsi1145_remove_trigger(indio_dev);\r\nerror_free_buffer:\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn ret;\r\n}\r\nstatic int si1145_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *indio_dev = i2c_get_clientdata(client);\r\niio_device_unregister(indio_dev);\r\nsi1145_remove_trigger(indio_dev);\r\niio_triggered_buffer_cleanup(indio_dev);\r\nreturn 0;\r\n}
