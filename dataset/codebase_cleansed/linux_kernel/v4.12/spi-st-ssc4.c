static void ssc_write_tx_fifo(struct spi_st *spi_st)\r\n{\r\nunsigned int count, i;\r\nuint32_t word = 0;\r\nif (spi_st->words_remaining > FIFO_SIZE)\r\ncount = FIFO_SIZE;\r\nelse\r\ncount = spi_st->words_remaining;\r\nfor (i = 0; i < count; i++) {\r\nif (spi_st->tx_ptr) {\r\nif (spi_st->bytes_per_word == 1) {\r\nword = *spi_st->tx_ptr++;\r\n} else {\r\nword = *spi_st->tx_ptr++;\r\nword = *spi_st->tx_ptr++ | (word << 8);\r\n}\r\n}\r\nwritel_relaxed(word, spi_st->base + SSC_TBUF);\r\n}\r\n}\r\nstatic void ssc_read_rx_fifo(struct spi_st *spi_st)\r\n{\r\nunsigned int count, i;\r\nuint32_t word = 0;\r\nif (spi_st->words_remaining > FIFO_SIZE)\r\ncount = FIFO_SIZE;\r\nelse\r\ncount = spi_st->words_remaining;\r\nfor (i = 0; i < count; i++) {\r\nword = readl_relaxed(spi_st->base + SSC_RBUF);\r\nif (spi_st->rx_ptr) {\r\nif (spi_st->bytes_per_word == 1) {\r\n*spi_st->rx_ptr++ = (uint8_t)word;\r\n} else {\r\n*spi_st->rx_ptr++ = (word >> 8);\r\n*spi_st->rx_ptr++ = word & 0xff;\r\n}\r\n}\r\n}\r\nspi_st->words_remaining -= count;\r\n}\r\nstatic int spi_st_transfer_one(struct spi_master *master,\r\nstruct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct spi_st *spi_st = spi_master_get_devdata(master);\r\nuint32_t ctl = 0;\r\nspi_st->tx_ptr = t->tx_buf;\r\nspi_st->rx_ptr = t->rx_buf;\r\nif (spi->bits_per_word > 8) {\r\nspi_st->bytes_per_word = 2;\r\nspi_st->words_remaining = t->len / 2;\r\n} else if (spi->bits_per_word == 8 && !(t->len & 0x1)) {\r\nspi_st->bytes_per_word = 2;\r\nspi_st->words_remaining = t->len / 2;\r\nctl = readl_relaxed(spi_st->base + SSC_CTL);\r\nwritel_relaxed((ctl | 0xf), spi_st->base + SSC_CTL);\r\nreadl_relaxed(spi_st->base + SSC_RBUF);\r\n} else {\r\nspi_st->bytes_per_word = 1;\r\nspi_st->words_remaining = t->len;\r\n}\r\nreinit_completion(&spi_st->done);\r\nssc_write_tx_fifo(spi_st);\r\nwritel_relaxed(SSC_IEN_TEEN, spi_st->base + SSC_IEN);\r\nwait_for_completion(&spi_st->done);\r\nif (ctl)\r\nwritel_relaxed(ctl, spi_st->base + SSC_CTL);\r\nspi_finalize_current_transfer(spi->master);\r\nreturn t->len;\r\n}\r\nstatic void spi_st_cleanup(struct spi_device *spi)\r\n{\r\ngpio_free(spi->cs_gpio);\r\n}\r\nstatic int spi_st_setup(struct spi_device *spi)\r\n{\r\nstruct spi_st *spi_st = spi_master_get_devdata(spi->master);\r\nu32 spi_st_clk, sscbrg, var;\r\nu32 hz = spi->max_speed_hz;\r\nint cs = spi->cs_gpio;\r\nint ret;\r\nif (!hz) {\r\ndev_err(&spi->dev, "max_speed_hz unspecified\n");\r\nreturn -EINVAL;\r\n}\r\nif (!gpio_is_valid(cs)) {\r\ndev_err(&spi->dev, "%d is not a valid gpio\n", cs);\r\nreturn -EINVAL;\r\n}\r\nret = gpio_request(cs, dev_name(&spi->dev));\r\nif (ret) {\r\ndev_err(&spi->dev, "could not request gpio:%d\n", cs);\r\nreturn ret;\r\n}\r\nret = gpio_direction_output(cs, spi->mode & SPI_CS_HIGH);\r\nif (ret)\r\ngoto out_free_gpio;\r\nspi_st_clk = clk_get_rate(spi_st->clk);\r\nsscbrg = spi_st_clk / (2 * hz);\r\nif (sscbrg < 0x07 || sscbrg > BIT(16)) {\r\ndev_err(&spi->dev,\r\n"baudrate %d outside valid range %d\n", sscbrg, hz);\r\nret = -EINVAL;\r\ngoto out_free_gpio;\r\n}\r\nspi_st->baud = spi_st_clk / (2 * sscbrg);\r\nif (sscbrg == BIT(16))\r\nsscbrg = 0x0;\r\nwritel_relaxed(sscbrg, spi_st->base + SSC_BRG);\r\ndev_dbg(&spi->dev,\r\n"setting baudrate:target= %u hz, actual= %u hz, sscbrg= %u\n",\r\nhz, spi_st->baud, sscbrg);\r\nvar = readl_relaxed(spi_st->base + SSC_CTL);\r\nvar |= SSC_CTL_MS;\r\nif (spi->mode & SPI_CPOL)\r\nvar |= SSC_CTL_PO;\r\nelse\r\nvar &= ~SSC_CTL_PO;\r\nif (spi->mode & SPI_CPHA)\r\nvar |= SSC_CTL_PH;\r\nelse\r\nvar &= ~SSC_CTL_PH;\r\nif ((spi->mode & SPI_LSB_FIRST) == 0)\r\nvar |= SSC_CTL_HB;\r\nelse\r\nvar &= ~SSC_CTL_HB;\r\nif (spi->mode & SPI_LOOP)\r\nvar |= SSC_CTL_LPB;\r\nelse\r\nvar &= ~SSC_CTL_LPB;\r\nvar &= ~SSC_CTL_DATA_WIDTH_MSK;\r\nvar |= (spi->bits_per_word - 1);\r\nvar |= SSC_CTL_EN_TX_FIFO | SSC_CTL_EN_RX_FIFO;\r\nvar |= SSC_CTL_EN;\r\nwritel_relaxed(var, spi_st->base + SSC_CTL);\r\nreadl_relaxed(spi_st->base + SSC_RBUF);\r\nreturn 0;\r\nout_free_gpio:\r\ngpio_free(cs);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t spi_st_irq(int irq, void *dev_id)\r\n{\r\nstruct spi_st *spi_st = (struct spi_st *)dev_id;\r\nssc_read_rx_fifo(spi_st);\r\nif (spi_st->words_remaining) {\r\nssc_write_tx_fifo(spi_st);\r\n} else {\r\nwritel_relaxed(0x0, spi_st->base + SSC_IEN);\r\nreadl(spi_st->base + SSC_IEN);\r\ncomplete(&spi_st->done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int spi_st_probe(struct platform_device *pdev)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct spi_master *master;\r\nstruct resource *res;\r\nstruct spi_st *spi_st;\r\nint irq, ret = 0;\r\nu32 var;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*spi_st));\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->dev.of_node = np;\r\nmaster->mode_bits = MODEBITS;\r\nmaster->setup = spi_st_setup;\r\nmaster->cleanup = spi_st_cleanup;\r\nmaster->transfer_one = spi_st_transfer_one;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16);\r\nmaster->auto_runtime_pm = true;\r\nmaster->bus_num = pdev->id;\r\nspi_st = spi_master_get_devdata(master);\r\nspi_st->clk = devm_clk_get(&pdev->dev, "ssc");\r\nif (IS_ERR(spi_st->clk)) {\r\ndev_err(&pdev->dev, "Unable to request clock\n");\r\nret = PTR_ERR(spi_st->clk);\r\ngoto put_master;\r\n}\r\nret = clk_prepare_enable(spi_st->clk);\r\nif (ret)\r\ngoto put_master;\r\ninit_completion(&spi_st->done);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nspi_st->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(spi_st->base)) {\r\nret = PTR_ERR(spi_st->base);\r\ngoto clk_disable;\r\n}\r\nwritel_relaxed(0x0, spi_st->base + SSC_I2C);\r\nvar = readw_relaxed(spi_st->base + SSC_CTL);\r\nvar |= SSC_CTL_SR;\r\nwritel_relaxed(var, spi_st->base + SSC_CTL);\r\nudelay(1);\r\nvar = readl_relaxed(spi_st->base + SSC_CTL);\r\nvar &= ~SSC_CTL_SR;\r\nwritel_relaxed(var, spi_st->base + SSC_CTL);\r\nvar = readl_relaxed(spi_st->base + SSC_CTL);\r\nvar &= ~SSC_CTL_MS;\r\nwritel_relaxed(var, spi_st->base + SSC_CTL);\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\ndev_err(&pdev->dev, "IRQ missing or invalid\n");\r\nret = -EINVAL;\r\ngoto clk_disable;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, spi_st_irq, 0,\r\npdev->name, spi_st);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request irq %d\n", irq);\r\ngoto clk_disable;\r\n}\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nplatform_set_drvdata(pdev, master);\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to register master\n");\r\ngoto clk_disable;\r\n}\r\nreturn 0;\r\nclk_disable:\r\nclk_disable_unprepare(spi_st->clk);\r\nput_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int spi_st_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct spi_st *spi_st = spi_master_get_devdata(master);\r\nclk_disable_unprepare(spi_st->clk);\r\npinctrl_pm_select_sleep_state(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int spi_st_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct spi_st *spi_st = spi_master_get_devdata(master);\r\nwritel_relaxed(0, spi_st->base + SSC_IEN);\r\npinctrl_pm_select_sleep_state(dev);\r\nclk_disable_unprepare(spi_st->clk);\r\nreturn 0;\r\n}\r\nstatic int spi_st_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct spi_st *spi_st = spi_master_get_devdata(master);\r\nint ret;\r\nret = clk_prepare_enable(spi_st->clk);\r\npinctrl_pm_select_default_state(dev);\r\nreturn ret;\r\n}\r\nstatic int spi_st_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret)\r\nreturn ret;\r\nreturn pm_runtime_force_suspend(dev);\r\n}\r\nstatic int spi_st_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nint ret;\r\nret = spi_master_resume(master);\r\nif (ret)\r\nreturn ret;\r\nreturn pm_runtime_force_resume(dev);\r\n}
