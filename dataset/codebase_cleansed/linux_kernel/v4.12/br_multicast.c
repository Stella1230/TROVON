static inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)\r\n{\r\nif (a->proto != b->proto)\r\nreturn 0;\r\nif (a->vid != b->vid)\r\nreturn 0;\r\nswitch (a->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn a->u.ip4 == b->u.ip4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn ipv6_addr_equal(&a->u.ip6, &b->u.ip6);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int __br_ip4_hash(struct net_bridge_mdb_htable *mdb, __be32 ip,\r\n__u16 vid)\r\n{\r\nreturn jhash_2words((__force u32)ip, vid, mdb->secret) & (mdb->max - 1);\r\n}\r\nstatic inline int __br_ip6_hash(struct net_bridge_mdb_htable *mdb,\r\nconst struct in6_addr *ip,\r\n__u16 vid)\r\n{\r\nreturn jhash_2words(ipv6_addr_hash(ip), vid,\r\nmdb->secret) & (mdb->max - 1);\r\n}\r\nstatic inline int br_ip_hash(struct net_bridge_mdb_htable *mdb,\r\nstruct br_ip *ip)\r\n{\r\nswitch (ip->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn __br_ip4_hash(mdb, ip->u.ip4, ip->vid);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn __br_ip6_hash(mdb, &ip->u.ip6, ip->vid);\r\n#endif\r\n}\r\nreturn 0;\r\n}\r\nstatic struct net_bridge_mdb_entry *__br_mdb_ip_get(\r\nstruct net_bridge_mdb_htable *mdb, struct br_ip *dst, int hash)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nhlist_for_each_entry_rcu(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\r\nif (br_ip_equal(&mp->addr, dst))\r\nreturn mp;\r\n}\r\nreturn NULL;\r\n}\r\nstruct net_bridge_mdb_entry *br_mdb_ip_get(struct net_bridge_mdb_htable *mdb,\r\nstruct br_ip *dst)\r\n{\r\nif (!mdb)\r\nreturn NULL;\r\nreturn __br_mdb_ip_get(mdb, dst, br_ip_hash(mdb, dst));\r\n}\r\nstatic struct net_bridge_mdb_entry *br_mdb_ip4_get(\r\nstruct net_bridge_mdb_htable *mdb, __be32 dst, __u16 vid)\r\n{\r\nstruct br_ip br_dst;\r\nbr_dst.u.ip4 = dst;\r\nbr_dst.proto = htons(ETH_P_IP);\r\nbr_dst.vid = vid;\r\nreturn br_mdb_ip_get(mdb, &br_dst);\r\n}\r\nstatic struct net_bridge_mdb_entry *br_mdb_ip6_get(\r\nstruct net_bridge_mdb_htable *mdb, const struct in6_addr *dst,\r\n__u16 vid)\r\n{\r\nstruct br_ip br_dst;\r\nbr_dst.u.ip6 = *dst;\r\nbr_dst.proto = htons(ETH_P_IPV6);\r\nbr_dst.vid = vid;\r\nreturn br_mdb_ip_get(mdb, &br_dst);\r\n}\r\nstruct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,\r\nstruct sk_buff *skb, u16 vid)\r\n{\r\nstruct net_bridge_mdb_htable *mdb = rcu_dereference(br->mdb);\r\nstruct br_ip ip;\r\nif (br->multicast_disabled)\r\nreturn NULL;\r\nif (BR_INPUT_SKB_CB(skb)->igmp)\r\nreturn NULL;\r\nip.proto = skb->protocol;\r\nip.vid = vid;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nip.u.ip4 = ip_hdr(skb)->daddr;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nip.u.ip6 = ipv6_hdr(skb)->daddr;\r\nbreak;\r\n#endif\r\ndefault:\r\nreturn NULL;\r\n}\r\nreturn br_mdb_ip_get(mdb, &ip);\r\n}\r\nstatic void br_mdb_free(struct rcu_head *head)\r\n{\r\nstruct net_bridge_mdb_htable *mdb =\r\ncontainer_of(head, struct net_bridge_mdb_htable, rcu);\r\nstruct net_bridge_mdb_htable *old = mdb->old;\r\nmdb->old = NULL;\r\nkfree(old->mhash);\r\nkfree(old);\r\n}\r\nstatic int br_mdb_copy(struct net_bridge_mdb_htable *new,\r\nstruct net_bridge_mdb_htable *old,\r\nint elasticity)\r\n{\r\nstruct net_bridge_mdb_entry *mp;\r\nint maxlen;\r\nint len;\r\nint i;\r\nfor (i = 0; i < old->max; i++)\r\nhlist_for_each_entry(mp, &old->mhash[i], hlist[old->ver])\r\nhlist_add_head(&mp->hlist[new->ver],\r\n&new->mhash[br_ip_hash(new, &mp->addr)]);\r\nif (!elasticity)\r\nreturn 0;\r\nmaxlen = 0;\r\nfor (i = 0; i < new->max; i++) {\r\nlen = 0;\r\nhlist_for_each_entry(mp, &new->mhash[i], hlist[new->ver])\r\nlen++;\r\nif (len > maxlen)\r\nmaxlen = len;\r\n}\r\nreturn maxlen > elasticity ? -EINVAL : 0;\r\n}\r\nvoid br_multicast_free_pg(struct rcu_head *head)\r\n{\r\nstruct net_bridge_port_group *p =\r\ncontainer_of(head, struct net_bridge_port_group, rcu);\r\nkfree(p);\r\n}\r\nstatic void br_multicast_free_group(struct rcu_head *head)\r\n{\r\nstruct net_bridge_mdb_entry *mp =\r\ncontainer_of(head, struct net_bridge_mdb_entry, rcu);\r\nkfree(mp);\r\n}\r\nstatic void br_multicast_group_expired(unsigned long data)\r\n{\r\nstruct net_bridge_mdb_entry *mp = (void *)data;\r\nstruct net_bridge *br = mp->br;\r\nstruct net_bridge_mdb_htable *mdb;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || timer_pending(&mp->timer))\r\ngoto out;\r\nmp->mglist = false;\r\nif (mp->ports)\r\ngoto out;\r\nmdb = mlock_dereference(br->mdb, br);\r\nhlist_del_rcu(&mp->hlist[mdb->ver]);\r\nmdb->size--;\r\ncall_rcu_bh(&mp->rcu, br_multicast_free_group);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_multicast_del_pg(struct net_bridge *br,\r\nstruct net_bridge_port_group *pg)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, &pg->addr);\r\nif (WARN_ON(!mp))\r\nreturn;\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (p != pg)\r\ncontinue;\r\nrcu_assign_pointer(*pp, p->next);\r\nhlist_del_init(&p->mglist);\r\ndel_timer(&p->timer);\r\nbr_mdb_notify(br->dev, p->port, &pg->addr, RTM_DELMDB,\r\np->flags);\r\ncall_rcu_bh(&p->rcu, br_multicast_free_pg);\r\nif (!mp->ports && !mp->mglist &&\r\nnetif_running(br->dev))\r\nmod_timer(&mp->timer, jiffies);\r\nreturn;\r\n}\r\nWARN_ON(1);\r\n}\r\nstatic void br_multicast_port_group_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port_group *pg = (void *)data;\r\nstruct net_bridge *br = pg->port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || timer_pending(&pg->timer) ||\r\nhlist_unhashed(&pg->mglist) || pg->flags & MDB_PG_FLAGS_PERMANENT)\r\ngoto out;\r\nbr_multicast_del_pg(br, pg);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic int br_mdb_rehash(struct net_bridge_mdb_htable __rcu **mdbp, int max,\r\nint elasticity)\r\n{\r\nstruct net_bridge_mdb_htable *old = rcu_dereference_protected(*mdbp, 1);\r\nstruct net_bridge_mdb_htable *mdb;\r\nint err;\r\nmdb = kmalloc(sizeof(*mdb), GFP_ATOMIC);\r\nif (!mdb)\r\nreturn -ENOMEM;\r\nmdb->max = max;\r\nmdb->old = old;\r\nmdb->mhash = kzalloc(max * sizeof(*mdb->mhash), GFP_ATOMIC);\r\nif (!mdb->mhash) {\r\nkfree(mdb);\r\nreturn -ENOMEM;\r\n}\r\nmdb->size = old ? old->size : 0;\r\nmdb->ver = old ? old->ver ^ 1 : 0;\r\nif (!old || elasticity)\r\nget_random_bytes(&mdb->secret, sizeof(mdb->secret));\r\nelse\r\nmdb->secret = old->secret;\r\nif (!old)\r\ngoto out;\r\nerr = br_mdb_copy(mdb, old, elasticity);\r\nif (err) {\r\nkfree(mdb->mhash);\r\nkfree(mdb);\r\nreturn err;\r\n}\r\nbr_mdb_rehash_seq++;\r\ncall_rcu_bh(&mdb->rcu, br_mdb_free);\r\nout:\r\nrcu_assign_pointer(*mdbp, mdb);\r\nreturn 0;\r\n}\r\nstatic struct sk_buff *br_ip4_multicast_alloc_query(struct net_bridge *br,\r\n__be32 group,\r\nu8 *igmp_type)\r\n{\r\nstruct igmpv3_query *ihv3;\r\nsize_t igmp_hdr_size;\r\nstruct sk_buff *skb;\r\nstruct igmphdr *ih;\r\nstruct ethhdr *eth;\r\nstruct iphdr *iph;\r\nigmp_hdr_size = sizeof(*ih);\r\nif (br->multicast_igmp_version == 3)\r\nigmp_hdr_size = sizeof(*ihv3);\r\nskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*iph) +\r\nigmp_hdr_size + 4);\r\nif (!skb)\r\ngoto out;\r\nskb->protocol = htons(ETH_P_IP);\r\nskb_reset_mac_header(skb);\r\neth = eth_hdr(skb);\r\nether_addr_copy(eth->h_source, br->dev->dev_addr);\r\neth->h_dest[0] = 1;\r\neth->h_dest[1] = 0;\r\neth->h_dest[2] = 0x5e;\r\neth->h_dest[3] = 0;\r\neth->h_dest[4] = 0;\r\neth->h_dest[5] = 1;\r\neth->h_proto = htons(ETH_P_IP);\r\nskb_put(skb, sizeof(*eth));\r\nskb_set_network_header(skb, skb->len);\r\niph = ip_hdr(skb);\r\niph->version = 4;\r\niph->ihl = 6;\r\niph->tos = 0xc0;\r\niph->tot_len = htons(sizeof(*iph) + igmp_hdr_size + 4);\r\niph->id = 0;\r\niph->frag_off = htons(IP_DF);\r\niph->ttl = 1;\r\niph->protocol = IPPROTO_IGMP;\r\niph->saddr = br->multicast_query_use_ifaddr ?\r\ninet_select_addr(br->dev, 0, RT_SCOPE_LINK) : 0;\r\niph->daddr = htonl(INADDR_ALLHOSTS_GROUP);\r\n((u8 *)&iph[1])[0] = IPOPT_RA;\r\n((u8 *)&iph[1])[1] = 4;\r\n((u8 *)&iph[1])[2] = 0;\r\n((u8 *)&iph[1])[3] = 0;\r\nip_send_check(iph);\r\nskb_put(skb, 24);\r\nskb_set_transport_header(skb, skb->len);\r\n*igmp_type = IGMP_HOST_MEMBERSHIP_QUERY;\r\nswitch (br->multicast_igmp_version) {\r\ncase 2:\r\nih = igmp_hdr(skb);\r\nih->type = IGMP_HOST_MEMBERSHIP_QUERY;\r\nih->code = (group ? br->multicast_last_member_interval :\r\nbr->multicast_query_response_interval) /\r\n(HZ / IGMP_TIMER_SCALE);\r\nih->group = group;\r\nih->csum = 0;\r\nih->csum = ip_compute_csum((void *)ih, sizeof(*ih));\r\nbreak;\r\ncase 3:\r\nihv3 = igmpv3_query_hdr(skb);\r\nihv3->type = IGMP_HOST_MEMBERSHIP_QUERY;\r\nihv3->code = (group ? br->multicast_last_member_interval :\r\nbr->multicast_query_response_interval) /\r\n(HZ / IGMP_TIMER_SCALE);\r\nihv3->group = group;\r\nihv3->qqic = br->multicast_query_interval / HZ;\r\nihv3->nsrcs = 0;\r\nihv3->resv = 0;\r\nihv3->suppress = 0;\r\nihv3->qrv = 2;\r\nihv3->csum = 0;\r\nihv3->csum = ip_compute_csum((void *)ihv3, sizeof(*ihv3));\r\nbreak;\r\n}\r\nskb_put(skb, igmp_hdr_size);\r\n__skb_pull(skb, sizeof(*eth));\r\nout:\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *br_ip6_multicast_alloc_query(struct net_bridge *br,\r\nconst struct in6_addr *grp,\r\nu8 *igmp_type)\r\n{\r\nstruct mld2_query *mld2q;\r\nunsigned long interval;\r\nstruct ipv6hdr *ip6h;\r\nstruct mld_msg *mldq;\r\nsize_t mld_hdr_size;\r\nstruct sk_buff *skb;\r\nstruct ethhdr *eth;\r\nu8 *hopopt;\r\nmld_hdr_size = sizeof(*mldq);\r\nif (br->multicast_mld_version == 2)\r\nmld_hdr_size = sizeof(*mld2q);\r\nskb = netdev_alloc_skb_ip_align(br->dev, sizeof(*eth) + sizeof(*ip6h) +\r\n8 + mld_hdr_size);\r\nif (!skb)\r\ngoto out;\r\nskb->protocol = htons(ETH_P_IPV6);\r\nskb_reset_mac_header(skb);\r\neth = eth_hdr(skb);\r\nether_addr_copy(eth->h_source, br->dev->dev_addr);\r\neth->h_proto = htons(ETH_P_IPV6);\r\nskb_put(skb, sizeof(*eth));\r\nskb_set_network_header(skb, skb->len);\r\nip6h = ipv6_hdr(skb);\r\n*(__force __be32 *)ip6h = htonl(0x60000000);\r\nip6h->payload_len = htons(8 + mld_hdr_size);\r\nip6h->nexthdr = IPPROTO_HOPOPTS;\r\nip6h->hop_limit = 1;\r\nipv6_addr_set(&ip6h->daddr, htonl(0xff020000), 0, 0, htonl(1));\r\nif (ipv6_dev_get_saddr(dev_net(br->dev), br->dev, &ip6h->daddr, 0,\r\n&ip6h->saddr)) {\r\nkfree_skb(skb);\r\nbr->has_ipv6_addr = 0;\r\nreturn NULL;\r\n}\r\nbr->has_ipv6_addr = 1;\r\nipv6_eth_mc_map(&ip6h->daddr, eth->h_dest);\r\nhopopt = (u8 *)(ip6h + 1);\r\nhopopt[0] = IPPROTO_ICMPV6;\r\nhopopt[1] = 0;\r\nhopopt[2] = IPV6_TLV_ROUTERALERT;\r\nhopopt[3] = 2;\r\nhopopt[4] = 0;\r\nhopopt[5] = 0;\r\nhopopt[6] = IPV6_TLV_PAD1;\r\nhopopt[7] = IPV6_TLV_PAD1;\r\nskb_put(skb, sizeof(*ip6h) + 8);\r\nskb_set_transport_header(skb, skb->len);\r\ninterval = ipv6_addr_any(grp) ?\r\nbr->multicast_query_response_interval :\r\nbr->multicast_last_member_interval;\r\n*igmp_type = ICMPV6_MGM_QUERY;\r\nswitch (br->multicast_mld_version) {\r\ncase 1:\r\nmldq = (struct mld_msg *)icmp6_hdr(skb);\r\nmldq->mld_type = ICMPV6_MGM_QUERY;\r\nmldq->mld_code = 0;\r\nmldq->mld_cksum = 0;\r\nmldq->mld_maxdelay = htons((u16)jiffies_to_msecs(interval));\r\nmldq->mld_reserved = 0;\r\nmldq->mld_mca = *grp;\r\nmldq->mld_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\r\nsizeof(*mldq), IPPROTO_ICMPV6,\r\ncsum_partial(mldq,\r\nsizeof(*mldq),\r\n0));\r\nbreak;\r\ncase 2:\r\nmld2q = (struct mld2_query *)icmp6_hdr(skb);\r\nmld2q->mld2q_mrc = htons((u16)jiffies_to_msecs(interval));\r\nmld2q->mld2q_type = ICMPV6_MGM_QUERY;\r\nmld2q->mld2q_code = 0;\r\nmld2q->mld2q_cksum = 0;\r\nmld2q->mld2q_resv1 = 0;\r\nmld2q->mld2q_resv2 = 0;\r\nmld2q->mld2q_suppress = 0;\r\nmld2q->mld2q_qrv = 2;\r\nmld2q->mld2q_nsrcs = 0;\r\nmld2q->mld2q_qqic = br->multicast_query_interval / HZ;\r\nmld2q->mld2q_mca = *grp;\r\nmld2q->mld2q_cksum = csum_ipv6_magic(&ip6h->saddr, &ip6h->daddr,\r\nsizeof(*mld2q),\r\nIPPROTO_ICMPV6,\r\ncsum_partial(mld2q,\r\nsizeof(*mld2q),\r\n0));\r\nbreak;\r\n}\r\nskb_put(skb, mld_hdr_size);\r\n__skb_pull(skb, sizeof(*eth));\r\nout:\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *br_multicast_alloc_query(struct net_bridge *br,\r\nstruct br_ip *addr,\r\nu8 *igmp_type)\r\n{\r\nswitch (addr->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn br_ip4_multicast_alloc_query(br, addr->u.ip4, igmp_type);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn br_ip6_multicast_alloc_query(br, &addr->u.ip6,\r\nigmp_type);\r\n#endif\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct net_bridge_mdb_entry *br_multicast_get_group(\r\nstruct net_bridge *br, struct net_bridge_port *port,\r\nstruct br_ip *group, int hash)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nunsigned int count = 0;\r\nunsigned int max;\r\nint elasticity;\r\nint err;\r\nmdb = rcu_dereference_protected(br->mdb, 1);\r\nhlist_for_each_entry(mp, &mdb->mhash[hash], hlist[mdb->ver]) {\r\ncount++;\r\nif (unlikely(br_ip_equal(group, &mp->addr)))\r\nreturn mp;\r\n}\r\nelasticity = 0;\r\nmax = mdb->max;\r\nif (unlikely(count > br->hash_elasticity && count)) {\r\nif (net_ratelimit())\r\nbr_info(br, "Multicast hash table "\r\n"chain limit reached: %s\n",\r\nport ? port->dev->name : br->dev->name);\r\nelasticity = br->hash_elasticity;\r\n}\r\nif (mdb->size >= max) {\r\nmax *= 2;\r\nif (unlikely(max > br->hash_max)) {\r\nbr_warn(br, "Multicast hash table maximum of %d "\r\n"reached, disabling snooping: %s\n",\r\nbr->hash_max,\r\nport ? port->dev->name : br->dev->name);\r\nerr = -E2BIG;\r\ndisable:\r\nbr->multicast_disabled = 1;\r\ngoto err;\r\n}\r\n}\r\nif (max > mdb->max || elasticity) {\r\nif (mdb->old) {\r\nif (net_ratelimit())\r\nbr_info(br, "Multicast hash table "\r\n"on fire: %s\n",\r\nport ? port->dev->name : br->dev->name);\r\nerr = -EEXIST;\r\ngoto err;\r\n}\r\nerr = br_mdb_rehash(&br->mdb, max, elasticity);\r\nif (err) {\r\nbr_warn(br, "Cannot rehash multicast "\r\n"hash table, disabling snooping: %s, %d, %d\n",\r\nport ? port->dev->name : br->dev->name,\r\nmdb->size, err);\r\ngoto disable;\r\n}\r\nerr = -EAGAIN;\r\ngoto err;\r\n}\r\nreturn NULL;\r\nerr:\r\nmp = ERR_PTR(err);\r\nreturn mp;\r\n}\r\nstruct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,\r\nstruct net_bridge_port *p,\r\nstruct br_ip *group)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nint hash;\r\nint err;\r\nmdb = rcu_dereference_protected(br->mdb, 1);\r\nif (!mdb) {\r\nerr = br_mdb_rehash(&br->mdb, BR_HASH_SIZE, 0);\r\nif (err)\r\nreturn ERR_PTR(err);\r\ngoto rehash;\r\n}\r\nhash = br_ip_hash(mdb, group);\r\nmp = br_multicast_get_group(br, p, group, hash);\r\nswitch (PTR_ERR(mp)) {\r\ncase 0:\r\nbreak;\r\ncase -EAGAIN:\r\nrehash:\r\nmdb = rcu_dereference_protected(br->mdb, 1);\r\nhash = br_ip_hash(mdb, group);\r\nbreak;\r\ndefault:\r\ngoto out;\r\n}\r\nmp = kzalloc(sizeof(*mp), GFP_ATOMIC);\r\nif (unlikely(!mp))\r\nreturn ERR_PTR(-ENOMEM);\r\nmp->br = br;\r\nmp->addr = *group;\r\nsetup_timer(&mp->timer, br_multicast_group_expired,\r\n(unsigned long)mp);\r\nhlist_add_head_rcu(&mp->hlist[mdb->ver], &mdb->mhash[hash]);\r\nmdb->size++;\r\nout:\r\nreturn mp;\r\n}\r\nstruct net_bridge_port_group *br_multicast_new_port_group(\r\nstruct net_bridge_port *port,\r\nstruct br_ip *group,\r\nstruct net_bridge_port_group __rcu *next,\r\nunsigned char flags,\r\nconst unsigned char *src)\r\n{\r\nstruct net_bridge_port_group *p;\r\np = kzalloc(sizeof(*p), GFP_ATOMIC);\r\nif (unlikely(!p))\r\nreturn NULL;\r\np->addr = *group;\r\np->port = port;\r\np->flags = flags;\r\nrcu_assign_pointer(p->next, next);\r\nhlist_add_head(&p->mglist, &port->mglist);\r\nsetup_timer(&p->timer, br_multicast_port_group_expired,\r\n(unsigned long)p);\r\nif (src)\r\nmemcpy(p->eth_addr, src, ETH_ALEN);\r\nelse\r\nmemset(p->eth_addr, 0xff, ETH_ALEN);\r\nreturn p;\r\n}\r\nstatic bool br_port_group_equal(struct net_bridge_port_group *p,\r\nstruct net_bridge_port *port,\r\nconst unsigned char *src)\r\n{\r\nif (p->port != port)\r\nreturn false;\r\nif (!(port->flags & BR_MULTICAST_TO_UNICAST))\r\nreturn true;\r\nreturn ether_addr_equal(src, p->eth_addr);\r\n}\r\nstatic int br_multicast_add_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *group,\r\nconst unsigned char *src)\r\n{\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_mdb_entry *mp;\r\nunsigned long now = jiffies;\r\nint err;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\nmp = br_multicast_new_group(br, port, group);\r\nerr = PTR_ERR(mp);\r\nif (IS_ERR(mp))\r\ngoto err;\r\nif (!port) {\r\nmp->mglist = true;\r\nmod_timer(&mp->timer, now + br->multicast_membership_interval);\r\ngoto out;\r\n}\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (br_port_group_equal(p, port, src))\r\ngoto found;\r\nif ((unsigned long)p->port < (unsigned long)port)\r\nbreak;\r\n}\r\np = br_multicast_new_port_group(port, group, *pp, 0, src);\r\nif (unlikely(!p))\r\ngoto err;\r\nrcu_assign_pointer(*pp, p);\r\nbr_mdb_notify(br->dev, port, group, RTM_NEWMDB, 0);\r\nfound:\r\nmod_timer(&p->timer, now + br->multicast_membership_interval);\r\nout:\r\nerr = 0;\r\nerr:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic int br_ip4_multicast_add_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\n__be32 group,\r\n__u16 vid,\r\nconst unsigned char *src)\r\n{\r\nstruct br_ip br_group;\r\nif (ipv4_is_local_multicast(group))\r\nreturn 0;\r\nbr_group.u.ip4 = group;\r\nbr_group.proto = htons(ETH_P_IP);\r\nbr_group.vid = vid;\r\nreturn br_multicast_add_group(br, port, &br_group, src);\r\n}\r\nstatic int br_ip6_multicast_add_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nconst struct in6_addr *group,\r\n__u16 vid,\r\nconst unsigned char *src)\r\n{\r\nstruct br_ip br_group;\r\nif (ipv6_addr_is_ll_all_nodes(group))\r\nreturn 0;\r\nbr_group.u.ip6 = *group;\r\nbr_group.proto = htons(ETH_P_IPV6);\r\nbr_group.vid = vid;\r\nreturn br_multicast_add_group(br, port, &br_group, src);\r\n}\r\nstatic void br_multicast_router_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port *port = (void *)data;\r\nstruct net_bridge *br = port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (port->multicast_router == MDB_RTR_TYPE_DISABLED ||\r\nport->multicast_router == MDB_RTR_TYPE_PERM ||\r\ntimer_pending(&port->multicast_router_timer))\r\ngoto out;\r\n__del_port_router(port);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_multicast_local_router_expired(unsigned long data)\r\n{\r\n}\r\nstatic void br_multicast_querier_expired(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) || br->multicast_disabled)\r\ngoto out;\r\nbr_multicast_start_querier(br, query);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_querier_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_querier_expired(br, &br->ip4_own_query);\r\n}\r\nstatic void br_ip6_multicast_querier_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_querier_expired(br, &br->ip6_own_query);\r\n}\r\nstatic void br_multicast_select_own_querier(struct net_bridge *br,\r\nstruct br_ip *ip,\r\nstruct sk_buff *skb)\r\n{\r\nif (ip->proto == htons(ETH_P_IP))\r\nbr->ip4_querier.addr.u.ip4 = ip_hdr(skb)->saddr;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nbr->ip6_querier.addr.u.ip6 = ipv6_hdr(skb)->saddr;\r\n#endif\r\n}\r\nstatic void __br_multicast_send_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *ip)\r\n{\r\nstruct sk_buff *skb;\r\nu8 igmp_type;\r\nskb = br_multicast_alloc_query(br, ip, &igmp_type);\r\nif (!skb)\r\nreturn;\r\nif (port) {\r\nskb->dev = port->dev;\r\nbr_multicast_count(br, port, skb, igmp_type,\r\nBR_MCAST_DIR_TX);\r\nNF_HOOK(NFPROTO_BRIDGE, NF_BR_LOCAL_OUT,\r\ndev_net(port->dev), NULL, skb, NULL, skb->dev,\r\nbr_dev_queue_push_xmit);\r\n} else {\r\nbr_multicast_select_own_querier(br, ip, skb);\r\nbr_multicast_count(br, port, skb, igmp_type,\r\nBR_MCAST_DIR_RX);\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic void br_multicast_send_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct bridge_mcast_own_query *own_query)\r\n{\r\nstruct bridge_mcast_other_query *other_query = NULL;\r\nstruct br_ip br_group;\r\nunsigned long time;\r\nif (!netif_running(br->dev) || br->multicast_disabled ||\r\n!br->multicast_querier)\r\nreturn;\r\nmemset(&br_group.u, 0, sizeof(br_group.u));\r\nif (port ? (own_query == &port->ip4_own_query) :\r\n(own_query == &br->ip4_own_query)) {\r\nother_query = &br->ip4_other_query;\r\nbr_group.proto = htons(ETH_P_IP);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else {\r\nother_query = &br->ip6_other_query;\r\nbr_group.proto = htons(ETH_P_IPV6);\r\n#endif\r\n}\r\nif (!other_query || timer_pending(&other_query->timer))\r\nreturn;\r\n__br_multicast_send_query(br, port, &br_group);\r\ntime = jiffies;\r\ntime += own_query->startup_sent < br->multicast_startup_query_count ?\r\nbr->multicast_startup_query_interval :\r\nbr->multicast_query_interval;\r\nmod_timer(&own_query->timer, time);\r\n}\r\nstatic void\r\nbr_multicast_port_query_expired(struct net_bridge_port *port,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nstruct net_bridge *br = port->br;\r\nspin_lock(&br->multicast_lock);\r\nif (port->state == BR_STATE_DISABLED ||\r\nport->state == BR_STATE_BLOCKING)\r\ngoto out;\r\nif (query->startup_sent < br->multicast_startup_query_count)\r\nquery->startup_sent++;\r\nbr_multicast_send_query(port->br, port, query);\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_port_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port *port = (void *)data;\r\nbr_multicast_port_query_expired(port, &port->ip4_own_query);\r\n}\r\nstatic void br_ip6_multicast_port_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge_port *port = (void *)data;\r\nbr_multicast_port_query_expired(port, &port->ip6_own_query);\r\n}\r\nstatic void br_mc_disabled_update(struct net_device *dev, bool value)\r\n{\r\nstruct switchdev_attr attr = {\r\n.orig_dev = dev,\r\n.id = SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED,\r\n.flags = SWITCHDEV_F_DEFER,\r\n.u.mc_disabled = value,\r\n};\r\nswitchdev_port_attr_set(dev, &attr);\r\n}\r\nint br_multicast_add_port(struct net_bridge_port *port)\r\n{\r\nport->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\r\nsetup_timer(&port->multicast_router_timer, br_multicast_router_expired,\r\n(unsigned long)port);\r\nsetup_timer(&port->ip4_own_query.timer,\r\nbr_ip4_multicast_port_query_expired, (unsigned long)port);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nsetup_timer(&port->ip6_own_query.timer,\r\nbr_ip6_multicast_port_query_expired, (unsigned long)port);\r\n#endif\r\nbr_mc_disabled_update(port->dev, port->br->multicast_disabled);\r\nport->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);\r\nif (!port->mcast_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid br_multicast_del_port(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge *br = port->br;\r\nstruct net_bridge_port_group *pg;\r\nstruct hlist_node *n;\r\nspin_lock_bh(&br->multicast_lock);\r\nhlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\r\nbr_multicast_del_pg(br, pg);\r\nspin_unlock_bh(&br->multicast_lock);\r\ndel_timer_sync(&port->multicast_router_timer);\r\nfree_percpu(port->mcast_stats);\r\n}\r\nstatic void br_multicast_enable(struct bridge_mcast_own_query *query)\r\n{\r\nquery->startup_sent = 0;\r\nif (try_to_del_timer_sync(&query->timer) >= 0 ||\r\ndel_timer(&query->timer))\r\nmod_timer(&query->timer, jiffies);\r\n}\r\nstatic void __br_multicast_enable_port(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge *br = port->br;\r\nif (br->multicast_disabled || !netif_running(br->dev))\r\nreturn;\r\nbr_multicast_enable(&port->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbr_multicast_enable(&port->ip6_own_query);\r\n#endif\r\nif (port->multicast_router == MDB_RTR_TYPE_PERM &&\r\nhlist_unhashed(&port->rlist))\r\nbr_multicast_add_router(br, port);\r\n}\r\nvoid br_multicast_enable_port(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge *br = port->br;\r\nspin_lock(&br->multicast_lock);\r\n__br_multicast_enable_port(port);\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nvoid br_multicast_disable_port(struct net_bridge_port *port)\r\n{\r\nstruct net_bridge *br = port->br;\r\nstruct net_bridge_port_group *pg;\r\nstruct hlist_node *n;\r\nspin_lock(&br->multicast_lock);\r\nhlist_for_each_entry_safe(pg, n, &port->mglist, mglist)\r\nif (!(pg->flags & MDB_PG_FLAGS_PERMANENT))\r\nbr_multicast_del_pg(br, pg);\r\n__del_port_router(port);\r\ndel_timer(&port->multicast_router_timer);\r\ndel_timer(&port->ip4_own_query.timer);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ndel_timer(&port->ip6_own_query.timer);\r\n#endif\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic int br_ip4_multicast_igmp3_report(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nconst unsigned char *src;\r\nstruct igmpv3_report *ih;\r\nstruct igmpv3_grec *grec;\r\nint i;\r\nint len;\r\nint num;\r\nint type;\r\nint err = 0;\r\n__be32 group;\r\nih = igmpv3_report_hdr(skb);\r\nnum = ntohs(ih->ngrec);\r\nlen = skb_transport_offset(skb) + sizeof(*ih);\r\nfor (i = 0; i < num; i++) {\r\nlen += sizeof(*grec);\r\nif (!pskb_may_pull(skb, len))\r\nreturn -EINVAL;\r\ngrec = (void *)(skb->data + len - sizeof(*grec));\r\ngroup = grec->grec_mca;\r\ntype = grec->grec_type;\r\nlen += ntohs(grec->grec_nsrcs) * 4;\r\nif (!pskb_may_pull(skb, len))\r\nreturn -EINVAL;\r\nswitch (type) {\r\ncase IGMPV3_MODE_IS_INCLUDE:\r\ncase IGMPV3_MODE_IS_EXCLUDE:\r\ncase IGMPV3_CHANGE_TO_INCLUDE:\r\ncase IGMPV3_CHANGE_TO_EXCLUDE:\r\ncase IGMPV3_ALLOW_NEW_SOURCES:\r\ncase IGMPV3_BLOCK_OLD_SOURCES:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nsrc = eth_hdr(skb)->h_source;\r\nif ((type == IGMPV3_CHANGE_TO_INCLUDE ||\r\ntype == IGMPV3_MODE_IS_INCLUDE) &&\r\nntohs(grec->grec_nsrcs) == 0) {\r\nbr_ip4_multicast_leave_group(br, port, group, vid, src);\r\n} else {\r\nerr = br_ip4_multicast_add_group(br, port, group, vid,\r\nsrc);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic int br_ip6_multicast_mld2_report(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nconst unsigned char *src;\r\nstruct icmp6hdr *icmp6h;\r\nstruct mld2_grec *grec;\r\nint i;\r\nint len;\r\nint num;\r\nint err = 0;\r\nif (!pskb_may_pull(skb, sizeof(*icmp6h)))\r\nreturn -EINVAL;\r\nicmp6h = icmp6_hdr(skb);\r\nnum = ntohs(icmp6h->icmp6_dataun.un_data16[1]);\r\nlen = skb_transport_offset(skb) + sizeof(*icmp6h);\r\nfor (i = 0; i < num; i++) {\r\n__be16 *nsrcs, _nsrcs;\r\nnsrcs = skb_header_pointer(skb,\r\nlen + offsetof(struct mld2_grec,\r\ngrec_nsrcs),\r\nsizeof(_nsrcs), &_nsrcs);\r\nif (!nsrcs)\r\nreturn -EINVAL;\r\nif (!pskb_may_pull(skb,\r\nlen + sizeof(*grec) +\r\nsizeof(struct in6_addr) * ntohs(*nsrcs)))\r\nreturn -EINVAL;\r\ngrec = (struct mld2_grec *)(skb->data + len);\r\nlen += sizeof(*grec) +\r\nsizeof(struct in6_addr) * ntohs(*nsrcs);\r\nswitch (grec->grec_type) {\r\ncase MLD2_MODE_IS_INCLUDE:\r\ncase MLD2_MODE_IS_EXCLUDE:\r\ncase MLD2_CHANGE_TO_INCLUDE:\r\ncase MLD2_CHANGE_TO_EXCLUDE:\r\ncase MLD2_ALLOW_NEW_SOURCES:\r\ncase MLD2_BLOCK_OLD_SOURCES:\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nsrc = eth_hdr(skb)->h_source;\r\nif ((grec->grec_type == MLD2_CHANGE_TO_INCLUDE ||\r\ngrec->grec_type == MLD2_MODE_IS_INCLUDE) &&\r\nntohs(*nsrcs) == 0) {\r\nbr_ip6_multicast_leave_group(br, port, &grec->grec_mca,\r\nvid, src);\r\n} else {\r\nerr = br_ip6_multicast_add_group(br, port,\r\n&grec->grec_mca, vid,\r\nsrc);\r\nif (err)\r\nbreak;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic bool br_ip4_multicast_select_querier(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\n__be32 saddr)\r\n{\r\nif (!timer_pending(&br->ip4_own_query.timer) &&\r\n!timer_pending(&br->ip4_other_query.timer))\r\ngoto update;\r\nif (!br->ip4_querier.addr.u.ip4)\r\ngoto update;\r\nif (ntohl(saddr) <= ntohl(br->ip4_querier.addr.u.ip4))\r\ngoto update;\r\nreturn false;\r\nupdate:\r\nbr->ip4_querier.addr.u.ip4 = saddr;\r\nrcu_assign_pointer(br->ip4_querier.port, port);\r\nreturn true;\r\n}\r\nstatic bool br_ip6_multicast_select_querier(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct in6_addr *saddr)\r\n{\r\nif (!timer_pending(&br->ip6_own_query.timer) &&\r\n!timer_pending(&br->ip6_other_query.timer))\r\ngoto update;\r\nif (ipv6_addr_cmp(saddr, &br->ip6_querier.addr.u.ip6) <= 0)\r\ngoto update;\r\nreturn false;\r\nupdate:\r\nbr->ip6_querier.addr.u.ip6 = *saddr;\r\nrcu_assign_pointer(br->ip6_querier.port, port);\r\nreturn true;\r\n}\r\nstatic bool br_multicast_select_querier(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *saddr)\r\n{\r\nswitch (saddr->proto) {\r\ncase htons(ETH_P_IP):\r\nreturn br_ip4_multicast_select_querier(br, port, saddr->u.ip4);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nreturn br_ip6_multicast_select_querier(br, port, &saddr->u.ip6);\r\n#endif\r\n}\r\nreturn false;\r\n}\r\nstatic void\r\nbr_multicast_update_query_timer(struct net_bridge *br,\r\nstruct bridge_mcast_other_query *query,\r\nunsigned long max_delay)\r\n{\r\nif (!timer_pending(&query->timer))\r\nquery->delay_time = jiffies + max_delay;\r\nmod_timer(&query->timer, jiffies + br->multicast_querier_interval);\r\n}\r\nstatic void br_port_mc_router_state_change(struct net_bridge_port *p,\r\nbool is_mc_router)\r\n{\r\nstruct switchdev_attr attr = {\r\n.orig_dev = p->dev,\r\n.id = SWITCHDEV_ATTR_ID_PORT_MROUTER,\r\n.flags = SWITCHDEV_F_DEFER,\r\n.u.mrouter = is_mc_router,\r\n};\r\nswitchdev_port_attr_set(p->dev, &attr);\r\n}\r\nstatic void br_multicast_add_router(struct net_bridge *br,\r\nstruct net_bridge_port *port)\r\n{\r\nstruct net_bridge_port *p;\r\nstruct hlist_node *slot = NULL;\r\nif (!hlist_unhashed(&port->rlist))\r\nreturn;\r\nhlist_for_each_entry(p, &br->router_list, rlist) {\r\nif ((unsigned long) port >= (unsigned long) p)\r\nbreak;\r\nslot = &p->rlist;\r\n}\r\nif (slot)\r\nhlist_add_behind_rcu(&port->rlist, slot);\r\nelse\r\nhlist_add_head_rcu(&port->rlist, &br->router_list);\r\nbr_rtr_notify(br->dev, port, RTM_NEWMDB);\r\nbr_port_mc_router_state_change(port, true);\r\n}\r\nstatic void br_multicast_mark_router(struct net_bridge *br,\r\nstruct net_bridge_port *port)\r\n{\r\nunsigned long now = jiffies;\r\nif (!port) {\r\nif (br->multicast_router == MDB_RTR_TYPE_TEMP_QUERY)\r\nmod_timer(&br->multicast_router_timer,\r\nnow + br->multicast_querier_interval);\r\nreturn;\r\n}\r\nif (port->multicast_router == MDB_RTR_TYPE_DISABLED ||\r\nport->multicast_router == MDB_RTR_TYPE_PERM)\r\nreturn;\r\nbr_multicast_add_router(br, port);\r\nmod_timer(&port->multicast_router_timer,\r\nnow + br->multicast_querier_interval);\r\n}\r\nstatic void br_multicast_query_received(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct bridge_mcast_other_query *query,\r\nstruct br_ip *saddr,\r\nunsigned long max_delay)\r\n{\r\nif (!br_multicast_select_querier(br, port, saddr))\r\nreturn;\r\nbr_multicast_update_query_timer(br, query, max_delay);\r\nbr_multicast_mark_router(br, port);\r\n}\r\nstatic int br_ip4_multicast_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nconst struct iphdr *iph = ip_hdr(skb);\r\nstruct igmphdr *ih = igmp_hdr(skb);\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct igmpv3_query *ih3;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct br_ip saddr;\r\nunsigned long max_delay;\r\nunsigned long now = jiffies;\r\nunsigned int offset = skb_transport_offset(skb);\r\n__be32 group;\r\nint err = 0;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\ngroup = ih->group;\r\nif (skb->len == offset + sizeof(*ih)) {\r\nmax_delay = ih->code * (HZ / IGMP_TIMER_SCALE);\r\nif (!max_delay) {\r\nmax_delay = 10 * HZ;\r\ngroup = 0;\r\n}\r\n} else if (skb->len >= offset + sizeof(*ih3)) {\r\nih3 = igmpv3_query_hdr(skb);\r\nif (ih3->nsrcs)\r\ngoto out;\r\nmax_delay = ih3->code ?\r\nIGMPV3_MRC(ih3->code) * (HZ / IGMP_TIMER_SCALE) : 1;\r\n} else {\r\ngoto out;\r\n}\r\nif (!group) {\r\nsaddr.proto = htons(ETH_P_IP);\r\nsaddr.u.ip4 = iph->saddr;\r\nbr_multicast_query_received(br, port, &br->ip4_other_query,\r\n&saddr, max_delay);\r\ngoto out;\r\n}\r\nmp = br_mdb_ip4_get(mlock_dereference(br->mdb, br), group, vid);\r\nif (!mp)\r\ngoto out;\r\nmax_delay *= br->multicast_last_member_count;\r\nif (mp->mglist &&\r\n(timer_pending(&mp->timer) ?\r\ntime_after(mp->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&mp->timer) >= 0))\r\nmod_timer(&mp->timer, now + max_delay);\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)\r\nmod_timer(&p->timer, now + max_delay);\r\n}\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic int br_ip6_multicast_query(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nconst struct ipv6hdr *ip6h = ipv6_hdr(skb);\r\nstruct mld_msg *mld;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct mld2_query *mld2q;\r\nstruct net_bridge_port_group *p;\r\nstruct net_bridge_port_group __rcu **pp;\r\nstruct br_ip saddr;\r\nunsigned long max_delay;\r\nunsigned long now = jiffies;\r\nunsigned int offset = skb_transport_offset(skb);\r\nconst struct in6_addr *group = NULL;\r\nbool is_general_query;\r\nint err = 0;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\nif (skb->len == offset + sizeof(*mld)) {\r\nif (!pskb_may_pull(skb, offset + sizeof(*mld))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmld = (struct mld_msg *) icmp6_hdr(skb);\r\nmax_delay = msecs_to_jiffies(ntohs(mld->mld_maxdelay));\r\nif (max_delay)\r\ngroup = &mld->mld_mca;\r\n} else {\r\nif (!pskb_may_pull(skb, offset + sizeof(*mld2q))) {\r\nerr = -EINVAL;\r\ngoto out;\r\n}\r\nmld2q = (struct mld2_query *)icmp6_hdr(skb);\r\nif (!mld2q->mld2q_nsrcs)\r\ngroup = &mld2q->mld2q_mca;\r\nmax_delay = max(msecs_to_jiffies(mldv2_mrc(mld2q)), 1UL);\r\n}\r\nis_general_query = group && ipv6_addr_any(group);\r\nif (is_general_query) {\r\nsaddr.proto = htons(ETH_P_IPV6);\r\nsaddr.u.ip6 = ip6h->saddr;\r\nbr_multicast_query_received(br, port, &br->ip6_other_query,\r\n&saddr, max_delay);\r\ngoto out;\r\n} else if (!group) {\r\ngoto out;\r\n}\r\nmp = br_mdb_ip6_get(mlock_dereference(br->mdb, br), group, vid);\r\nif (!mp)\r\ngoto out;\r\nmax_delay *= br->multicast_last_member_count;\r\nif (mp->mglist &&\r\n(timer_pending(&mp->timer) ?\r\ntime_after(mp->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&mp->timer) >= 0))\r\nmod_timer(&mp->timer, now + max_delay);\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, now + max_delay) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)\r\nmod_timer(&p->timer, now + max_delay);\r\n}\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic void\r\nbr_multicast_leave_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct br_ip *group,\r\nstruct bridge_mcast_other_query *other_query,\r\nstruct bridge_mcast_own_query *own_query,\r\nconst unsigned char *src)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct net_bridge_port_group *p;\r\nunsigned long now;\r\nunsigned long time;\r\nspin_lock(&br->multicast_lock);\r\nif (!netif_running(br->dev) ||\r\n(port && port->state == BR_STATE_DISABLED))\r\ngoto out;\r\nmdb = mlock_dereference(br->mdb, br);\r\nmp = br_mdb_ip_get(mdb, group);\r\nif (!mp)\r\ngoto out;\r\nif (port && (port->flags & BR_MULTICAST_FAST_LEAVE)) {\r\nstruct net_bridge_port_group __rcu **pp;\r\nfor (pp = &mp->ports;\r\n(p = mlock_dereference(*pp, br)) != NULL;\r\npp = &p->next) {\r\nif (!br_port_group_equal(p, port, src))\r\ncontinue;\r\nrcu_assign_pointer(*pp, p->next);\r\nhlist_del_init(&p->mglist);\r\ndel_timer(&p->timer);\r\ncall_rcu_bh(&p->rcu, br_multicast_free_pg);\r\nbr_mdb_notify(br->dev, port, group, RTM_DELMDB,\r\np->flags);\r\nif (!mp->ports && !mp->mglist &&\r\nnetif_running(br->dev))\r\nmod_timer(&mp->timer, jiffies);\r\n}\r\ngoto out;\r\n}\r\nif (timer_pending(&other_query->timer))\r\ngoto out;\r\nif (br->multicast_querier) {\r\n__br_multicast_send_query(br, port, &mp->addr);\r\ntime = jiffies + br->multicast_last_member_count *\r\nbr->multicast_last_member_interval;\r\nmod_timer(&own_query->timer, time);\r\nfor (p = mlock_dereference(mp->ports, br);\r\np != NULL;\r\np = mlock_dereference(p->next, br)) {\r\nif (!br_port_group_equal(p, port, src))\r\ncontinue;\r\nif (!hlist_unhashed(&p->mglist) &&\r\n(timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, time) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)) {\r\nmod_timer(&p->timer, time);\r\n}\r\nbreak;\r\n}\r\n}\r\nnow = jiffies;\r\ntime = now + br->multicast_last_member_count *\r\nbr->multicast_last_member_interval;\r\nif (!port) {\r\nif (mp->mglist &&\r\n(timer_pending(&mp->timer) ?\r\ntime_after(mp->timer.expires, time) :\r\ntry_to_del_timer_sync(&mp->timer) >= 0)) {\r\nmod_timer(&mp->timer, time);\r\n}\r\ngoto out;\r\n}\r\nfor (p = mlock_dereference(mp->ports, br);\r\np != NULL;\r\np = mlock_dereference(p->next, br)) {\r\nif (p->port != port)\r\ncontinue;\r\nif (!hlist_unhashed(&p->mglist) &&\r\n(timer_pending(&p->timer) ?\r\ntime_after(p->timer.expires, time) :\r\ntry_to_del_timer_sync(&p->timer) >= 0)) {\r\nmod_timer(&p->timer, time);\r\n}\r\nbreak;\r\n}\r\nout:\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_leave_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\n__be32 group,\r\n__u16 vid,\r\nconst unsigned char *src)\r\n{\r\nstruct br_ip br_group;\r\nstruct bridge_mcast_own_query *own_query;\r\nif (ipv4_is_local_multicast(group))\r\nreturn;\r\nown_query = port ? &port->ip4_own_query : &br->ip4_own_query;\r\nbr_group.u.ip4 = group;\r\nbr_group.proto = htons(ETH_P_IP);\r\nbr_group.vid = vid;\r\nbr_multicast_leave_group(br, port, &br_group, &br->ip4_other_query,\r\nown_query, src);\r\n}\r\nstatic void br_ip6_multicast_leave_group(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nconst struct in6_addr *group,\r\n__u16 vid,\r\nconst unsigned char *src)\r\n{\r\nstruct br_ip br_group;\r\nstruct bridge_mcast_own_query *own_query;\r\nif (ipv6_addr_is_ll_all_nodes(group))\r\nreturn;\r\nown_query = port ? &port->ip6_own_query : &br->ip6_own_query;\r\nbr_group.u.ip6 = *group;\r\nbr_group.proto = htons(ETH_P_IPV6);\r\nbr_group.vid = vid;\r\nbr_multicast_leave_group(br, port, &br_group, &br->ip6_other_query,\r\nown_query, src);\r\n}\r\nstatic void br_multicast_err_count(const struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\n__be16 proto)\r\n{\r\nstruct bridge_mcast_stats __percpu *stats;\r\nstruct bridge_mcast_stats *pstats;\r\nif (!br->multicast_stats_enabled)\r\nreturn;\r\nif (p)\r\nstats = p->mcast_stats;\r\nelse\r\nstats = br->mcast_stats;\r\nif (WARN_ON(!stats))\r\nreturn;\r\npstats = this_cpu_ptr(stats);\r\nu64_stats_update_begin(&pstats->syncp);\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\npstats->mstats.igmp_parse_errors++;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\npstats->mstats.mld_parse_errors++;\r\nbreak;\r\n#endif\r\n}\r\nu64_stats_update_end(&pstats->syncp);\r\n}\r\nstatic void br_multicast_pim(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nconst struct sk_buff *skb)\r\n{\r\nunsigned int offset = skb_transport_offset(skb);\r\nstruct pimhdr *pimhdr, _pimhdr;\r\npimhdr = skb_header_pointer(skb, offset, sizeof(_pimhdr), &_pimhdr);\r\nif (!pimhdr || pim_hdr_version(pimhdr) != PIM_VERSION ||\r\npim_hdr_type(pimhdr) != PIM_TYPE_HELLO)\r\nreturn;\r\nbr_multicast_mark_router(br, port);\r\n}\r\nstatic int br_multicast_ipv4_rcv(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nstruct sk_buff *skb_trimmed = NULL;\r\nconst unsigned char *src;\r\nstruct igmphdr *ih;\r\nint err;\r\nerr = ip_mc_check_igmp(skb, &skb_trimmed);\r\nif (err == -ENOMSG) {\r\nif (!ipv4_is_local_multicast(ip_hdr(skb)->daddr)) {\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\n} else if (pim_ipv4_all_pim_routers(ip_hdr(skb)->daddr)) {\r\nif (ip_hdr(skb)->protocol == IPPROTO_PIM)\r\nbr_multicast_pim(br, port, skb);\r\n}\r\nreturn 0;\r\n} else if (err < 0) {\r\nbr_multicast_err_count(br, port, skb->protocol);\r\nreturn err;\r\n}\r\nih = igmp_hdr(skb);\r\nsrc = eth_hdr(skb)->h_source;\r\nBR_INPUT_SKB_CB(skb)->igmp = ih->type;\r\nswitch (ih->type) {\r\ncase IGMP_HOST_MEMBERSHIP_REPORT:\r\ncase IGMPV2_HOST_MEMBERSHIP_REPORT:\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nerr = br_ip4_multicast_add_group(br, port, ih->group, vid, src);\r\nbreak;\r\ncase IGMPV3_HOST_MEMBERSHIP_REPORT:\r\nerr = br_ip4_multicast_igmp3_report(br, port, skb_trimmed, vid);\r\nbreak;\r\ncase IGMP_HOST_MEMBERSHIP_QUERY:\r\nerr = br_ip4_multicast_query(br, port, skb_trimmed, vid);\r\nbreak;\r\ncase IGMP_HOST_LEAVE_MESSAGE:\r\nbr_ip4_multicast_leave_group(br, port, ih->group, vid, src);\r\nbreak;\r\n}\r\nif (skb_trimmed && skb_trimmed != skb)\r\nkfree_skb(skb_trimmed);\r\nbr_multicast_count(br, port, skb, BR_INPUT_SKB_CB(skb)->igmp,\r\nBR_MCAST_DIR_RX);\r\nreturn err;\r\n}\r\nstatic int br_multicast_ipv6_rcv(struct net_bridge *br,\r\nstruct net_bridge_port *port,\r\nstruct sk_buff *skb,\r\nu16 vid)\r\n{\r\nstruct sk_buff *skb_trimmed = NULL;\r\nconst unsigned char *src;\r\nstruct mld_msg *mld;\r\nint err;\r\nerr = ipv6_mc_check_mld(skb, &skb_trimmed);\r\nif (err == -ENOMSG) {\r\nif (!ipv6_addr_is_ll_all_nodes(&ipv6_hdr(skb)->daddr))\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nreturn 0;\r\n} else if (err < 0) {\r\nbr_multicast_err_count(br, port, skb->protocol);\r\nreturn err;\r\n}\r\nmld = (struct mld_msg *)skb_transport_header(skb);\r\nBR_INPUT_SKB_CB(skb)->igmp = mld->mld_type;\r\nswitch (mld->mld_type) {\r\ncase ICMPV6_MGM_REPORT:\r\nsrc = eth_hdr(skb)->h_source;\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 1;\r\nerr = br_ip6_multicast_add_group(br, port, &mld->mld_mca, vid,\r\nsrc);\r\nbreak;\r\ncase ICMPV6_MLD2_REPORT:\r\nerr = br_ip6_multicast_mld2_report(br, port, skb_trimmed, vid);\r\nbreak;\r\ncase ICMPV6_MGM_QUERY:\r\nerr = br_ip6_multicast_query(br, port, skb_trimmed, vid);\r\nbreak;\r\ncase ICMPV6_MGM_REDUCTION:\r\nsrc = eth_hdr(skb)->h_source;\r\nbr_ip6_multicast_leave_group(br, port, &mld->mld_mca, vid, src);\r\nbreak;\r\n}\r\nif (skb_trimmed && skb_trimmed != skb)\r\nkfree_skb(skb_trimmed);\r\nbr_multicast_count(br, port, skb, BR_INPUT_SKB_CB(skb)->igmp,\r\nBR_MCAST_DIR_RX);\r\nreturn err;\r\n}\r\nint br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,\r\nstruct sk_buff *skb, u16 vid)\r\n{\r\nint ret = 0;\r\nBR_INPUT_SKB_CB(skb)->igmp = 0;\r\nBR_INPUT_SKB_CB(skb)->mrouters_only = 0;\r\nif (br->multicast_disabled)\r\nreturn 0;\r\nswitch (skb->protocol) {\r\ncase htons(ETH_P_IP):\r\nret = br_multicast_ipv4_rcv(br, port, skb, vid);\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nret = br_multicast_ipv6_rcv(br, port, skb, vid);\r\nbreak;\r\n#endif\r\n}\r\nreturn ret;\r\n}\r\nstatic void br_multicast_query_expired(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query,\r\nstruct bridge_mcast_querier *querier)\r\n{\r\nspin_lock(&br->multicast_lock);\r\nif (query->startup_sent < br->multicast_startup_query_count)\r\nquery->startup_sent++;\r\nRCU_INIT_POINTER(querier->port, NULL);\r\nbr_multicast_send_query(br, NULL, query);\r\nspin_unlock(&br->multicast_lock);\r\n}\r\nstatic void br_ip4_multicast_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_query_expired(br, &br->ip4_own_query, &br->ip4_querier);\r\n}\r\nstatic void br_ip6_multicast_query_expired(unsigned long data)\r\n{\r\nstruct net_bridge *br = (void *)data;\r\nbr_multicast_query_expired(br, &br->ip6_own_query, &br->ip6_querier);\r\n}\r\nvoid br_multicast_init(struct net_bridge *br)\r\n{\r\nbr->hash_elasticity = 4;\r\nbr->hash_max = 512;\r\nbr->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\r\nbr->multicast_querier = 0;\r\nbr->multicast_query_use_ifaddr = 0;\r\nbr->multicast_last_member_count = 2;\r\nbr->multicast_startup_query_count = 2;\r\nbr->multicast_last_member_interval = HZ;\r\nbr->multicast_query_response_interval = 10 * HZ;\r\nbr->multicast_startup_query_interval = 125 * HZ / 4;\r\nbr->multicast_query_interval = 125 * HZ;\r\nbr->multicast_querier_interval = 255 * HZ;\r\nbr->multicast_membership_interval = 260 * HZ;\r\nbr->ip4_other_query.delay_time = 0;\r\nbr->ip4_querier.port = NULL;\r\nbr->multicast_igmp_version = 2;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nbr->multicast_mld_version = 1;\r\nbr->ip6_other_query.delay_time = 0;\r\nbr->ip6_querier.port = NULL;\r\n#endif\r\nbr->has_ipv6_addr = 1;\r\nspin_lock_init(&br->multicast_lock);\r\nsetup_timer(&br->multicast_router_timer,\r\nbr_multicast_local_router_expired, 0);\r\nsetup_timer(&br->ip4_other_query.timer,\r\nbr_ip4_multicast_querier_expired, (unsigned long)br);\r\nsetup_timer(&br->ip4_own_query.timer, br_ip4_multicast_query_expired,\r\n(unsigned long)br);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nsetup_timer(&br->ip6_other_query.timer,\r\nbr_ip6_multicast_querier_expired, (unsigned long)br);\r\nsetup_timer(&br->ip6_own_query.timer, br_ip6_multicast_query_expired,\r\n(unsigned long)br);\r\n#endif\r\n}\r\nstatic void __br_multicast_open(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nquery->startup_sent = 0;\r\nif (br->multicast_disabled)\r\nreturn;\r\nmod_timer(&query->timer, jiffies);\r\n}\r\nvoid br_multicast_open(struct net_bridge *br)\r\n{\r\n__br_multicast_open(br, &br->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n__br_multicast_open(br, &br->ip6_own_query);\r\n#endif\r\n}\r\nvoid br_multicast_stop(struct net_bridge *br)\r\n{\r\ndel_timer_sync(&br->multicast_router_timer);\r\ndel_timer_sync(&br->ip4_other_query.timer);\r\ndel_timer_sync(&br->ip4_own_query.timer);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ndel_timer_sync(&br->ip6_other_query.timer);\r\ndel_timer_sync(&br->ip6_own_query.timer);\r\n#endif\r\n}\r\nvoid br_multicast_dev_del(struct net_bridge *br)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_mdb_entry *mp;\r\nstruct hlist_node *n;\r\nu32 ver;\r\nint i;\r\nspin_lock_bh(&br->multicast_lock);\r\nmdb = mlock_dereference(br->mdb, br);\r\nif (!mdb)\r\ngoto out;\r\nbr->mdb = NULL;\r\nver = mdb->ver;\r\nfor (i = 0; i < mdb->max; i++) {\r\nhlist_for_each_entry_safe(mp, n, &mdb->mhash[i],\r\nhlist[ver]) {\r\ndel_timer(&mp->timer);\r\ncall_rcu_bh(&mp->rcu, br_multicast_free_group);\r\n}\r\n}\r\nif (mdb->old) {\r\nspin_unlock_bh(&br->multicast_lock);\r\nrcu_barrier_bh();\r\nspin_lock_bh(&br->multicast_lock);\r\nWARN_ON(mdb->old);\r\n}\r\nmdb->old = mdb;\r\ncall_rcu_bh(&mdb->rcu, br_mdb_free);\r\nout:\r\nspin_unlock_bh(&br->multicast_lock);\r\n}\r\nint br_multicast_set_router(struct net_bridge *br, unsigned long val)\r\n{\r\nint err = -EINVAL;\r\nspin_lock_bh(&br->multicast_lock);\r\nswitch (val) {\r\ncase MDB_RTR_TYPE_DISABLED:\r\ncase MDB_RTR_TYPE_PERM:\r\ndel_timer(&br->multicast_router_timer);\r\ncase MDB_RTR_TYPE_TEMP_QUERY:\r\nbr->multicast_router = val;\r\nerr = 0;\r\nbreak;\r\n}\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic void __del_port_router(struct net_bridge_port *p)\r\n{\r\nif (hlist_unhashed(&p->rlist))\r\nreturn;\r\nhlist_del_init_rcu(&p->rlist);\r\nbr_rtr_notify(p->br->dev, p, RTM_DELMDB);\r\nbr_port_mc_router_state_change(p, false);\r\nif (p->multicast_router == MDB_RTR_TYPE_TEMP)\r\np->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\r\n}\r\nint br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val)\r\n{\r\nstruct net_bridge *br = p->br;\r\nunsigned long now = jiffies;\r\nint err = -EINVAL;\r\nspin_lock(&br->multicast_lock);\r\nif (p->multicast_router == val) {\r\nif (p->multicast_router == MDB_RTR_TYPE_TEMP)\r\nmod_timer(&p->multicast_router_timer,\r\nnow + br->multicast_querier_interval);\r\nerr = 0;\r\ngoto unlock;\r\n}\r\nswitch (val) {\r\ncase MDB_RTR_TYPE_DISABLED:\r\np->multicast_router = MDB_RTR_TYPE_DISABLED;\r\n__del_port_router(p);\r\ndel_timer(&p->multicast_router_timer);\r\nbreak;\r\ncase MDB_RTR_TYPE_TEMP_QUERY:\r\np->multicast_router = MDB_RTR_TYPE_TEMP_QUERY;\r\n__del_port_router(p);\r\nbreak;\r\ncase MDB_RTR_TYPE_PERM:\r\np->multicast_router = MDB_RTR_TYPE_PERM;\r\ndel_timer(&p->multicast_router_timer);\r\nbr_multicast_add_router(br, p);\r\nbreak;\r\ncase MDB_RTR_TYPE_TEMP:\r\np->multicast_router = MDB_RTR_TYPE_TEMP;\r\nbr_multicast_mark_router(br, p);\r\nbreak;\r\ndefault:\r\ngoto unlock;\r\n}\r\nerr = 0;\r\nunlock:\r\nspin_unlock(&br->multicast_lock);\r\nreturn err;\r\n}\r\nstatic void br_multicast_start_querier(struct net_bridge *br,\r\nstruct bridge_mcast_own_query *query)\r\n{\r\nstruct net_bridge_port *port;\r\n__br_multicast_open(br, query);\r\nlist_for_each_entry(port, &br->port_list, list) {\r\nif (port->state == BR_STATE_DISABLED ||\r\nport->state == BR_STATE_BLOCKING)\r\ncontinue;\r\nif (query == &br->ip4_own_query)\r\nbr_multicast_enable(&port->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nbr_multicast_enable(&port->ip6_own_query);\r\n#endif\r\n}\r\n}\r\nint br_multicast_toggle(struct net_bridge *br, unsigned long val)\r\n{\r\nstruct net_bridge_mdb_htable *mdb;\r\nstruct net_bridge_port *port;\r\nint err = 0;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (br->multicast_disabled == !val)\r\ngoto unlock;\r\nbr_mc_disabled_update(br->dev, !val);\r\nbr->multicast_disabled = !val;\r\nif (br->multicast_disabled)\r\ngoto unlock;\r\nif (!netif_running(br->dev))\r\ngoto unlock;\r\nmdb = mlock_dereference(br->mdb, br);\r\nif (mdb) {\r\nif (mdb->old) {\r\nerr = -EEXIST;\r\nrollback:\r\nbr->multicast_disabled = !!val;\r\ngoto unlock;\r\n}\r\nerr = br_mdb_rehash(&br->mdb, mdb->max,\r\nbr->hash_elasticity);\r\nif (err)\r\ngoto rollback;\r\n}\r\nbr_multicast_open(br);\r\nlist_for_each_entry(port, &br->port_list, list)\r\n__br_multicast_enable_port(port);\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nint br_multicast_set_querier(struct net_bridge *br, unsigned long val)\r\n{\r\nunsigned long max_delay;\r\nval = !!val;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (br->multicast_querier == val)\r\ngoto unlock;\r\nbr->multicast_querier = val;\r\nif (!val)\r\ngoto unlock;\r\nmax_delay = br->multicast_query_response_interval;\r\nif (!timer_pending(&br->ip4_other_query.timer))\r\nbr->ip4_other_query.delay_time = jiffies + max_delay;\r\nbr_multicast_start_querier(br, &br->ip4_own_query);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (!timer_pending(&br->ip6_other_query.timer))\r\nbr->ip6_other_query.delay_time = jiffies + max_delay;\r\nbr_multicast_start_querier(br, &br->ip6_own_query);\r\n#endif\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn 0;\r\n}\r\nint br_multicast_set_hash_max(struct net_bridge *br, unsigned long val)\r\n{\r\nint err = -EINVAL;\r\nu32 old;\r\nstruct net_bridge_mdb_htable *mdb;\r\nspin_lock_bh(&br->multicast_lock);\r\nif (!is_power_of_2(val))\r\ngoto unlock;\r\nmdb = mlock_dereference(br->mdb, br);\r\nif (mdb && val < mdb->size)\r\ngoto unlock;\r\nerr = 0;\r\nold = br->hash_max;\r\nbr->hash_max = val;\r\nif (mdb) {\r\nif (mdb->old) {\r\nerr = -EEXIST;\r\nrollback:\r\nbr->hash_max = old;\r\ngoto unlock;\r\n}\r\nerr = br_mdb_rehash(&br->mdb, br->hash_max,\r\nbr->hash_elasticity);\r\nif (err)\r\ngoto rollback;\r\n}\r\nunlock:\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn err;\r\n}\r\nint br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val)\r\n{\r\nswitch (val) {\r\ncase 2:\r\ncase 3:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&br->multicast_lock);\r\nbr->multicast_igmp_version = val;\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn 0;\r\n}\r\nint br_multicast_set_mld_version(struct net_bridge *br, unsigned long val)\r\n{\r\nswitch (val) {\r\ncase 1:\r\ncase 2:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_bh(&br->multicast_lock);\r\nbr->multicast_mld_version = val;\r\nspin_unlock_bh(&br->multicast_lock);\r\nreturn 0;\r\n}\r\nint br_multicast_list_adjacent(struct net_device *dev,\r\nstruct list_head *br_ip_list)\r\n{\r\nstruct net_bridge *br;\r\nstruct net_bridge_port *port;\r\nstruct net_bridge_port_group *group;\r\nstruct br_ip_list *entry;\r\nint count = 0;\r\nrcu_read_lock();\r\nif (!br_ip_list || !br_port_exists(dev))\r\ngoto unlock;\r\nport = br_port_get_rcu(dev);\r\nif (!port || !port->br)\r\ngoto unlock;\r\nbr = port->br;\r\nlist_for_each_entry_rcu(port, &br->port_list, list) {\r\nif (!port->dev || port->dev == dev)\r\ncontinue;\r\nhlist_for_each_entry_rcu(group, &port->mglist, mglist) {\r\nentry = kmalloc(sizeof(*entry), GFP_ATOMIC);\r\nif (!entry)\r\ngoto unlock;\r\nentry->addr = group->addr;\r\nlist_add(&entry->list, br_ip_list);\r\ncount++;\r\n}\r\n}\r\nunlock:\r\nrcu_read_unlock();\r\nreturn count;\r\n}\r\nbool br_multicast_has_querier_anywhere(struct net_device *dev, int proto)\r\n{\r\nstruct net_bridge *br;\r\nstruct net_bridge_port *port;\r\nstruct ethhdr eth;\r\nbool ret = false;\r\nrcu_read_lock();\r\nif (!br_port_exists(dev))\r\ngoto unlock;\r\nport = br_port_get_rcu(dev);\r\nif (!port || !port->br)\r\ngoto unlock;\r\nbr = port->br;\r\nmemset(&eth, 0, sizeof(eth));\r\neth.h_proto = htons(proto);\r\nret = br_multicast_querier_exists(br, &eth);\r\nunlock:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nbool br_multicast_has_querier_adjacent(struct net_device *dev, int proto)\r\n{\r\nstruct net_bridge *br;\r\nstruct net_bridge_port *port;\r\nbool ret = false;\r\nrcu_read_lock();\r\nif (!br_port_exists(dev))\r\ngoto unlock;\r\nport = br_port_get_rcu(dev);\r\nif (!port || !port->br)\r\ngoto unlock;\r\nbr = port->br;\r\nswitch (proto) {\r\ncase ETH_P_IP:\r\nif (!timer_pending(&br->ip4_other_query.timer) ||\r\nrcu_dereference(br->ip4_querier.port) == port)\r\ngoto unlock;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase ETH_P_IPV6:\r\nif (!timer_pending(&br->ip6_other_query.timer) ||\r\nrcu_dereference(br->ip6_querier.port) == port)\r\ngoto unlock;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto unlock;\r\n}\r\nret = true;\r\nunlock:\r\nrcu_read_unlock();\r\nreturn ret;\r\n}\r\nstatic void br_mcast_stats_add(struct bridge_mcast_stats __percpu *stats,\r\nconst struct sk_buff *skb, u8 type, u8 dir)\r\n{\r\nstruct bridge_mcast_stats *pstats = this_cpu_ptr(stats);\r\n__be16 proto = skb->protocol;\r\nunsigned int t_len;\r\nu64_stats_update_begin(&pstats->syncp);\r\nswitch (proto) {\r\ncase htons(ETH_P_IP):\r\nt_len = ntohs(ip_hdr(skb)->tot_len) - ip_hdrlen(skb);\r\nswitch (type) {\r\ncase IGMP_HOST_MEMBERSHIP_REPORT:\r\npstats->mstats.igmp_v1reports[dir]++;\r\nbreak;\r\ncase IGMPV2_HOST_MEMBERSHIP_REPORT:\r\npstats->mstats.igmp_v2reports[dir]++;\r\nbreak;\r\ncase IGMPV3_HOST_MEMBERSHIP_REPORT:\r\npstats->mstats.igmp_v3reports[dir]++;\r\nbreak;\r\ncase IGMP_HOST_MEMBERSHIP_QUERY:\r\nif (t_len != sizeof(struct igmphdr)) {\r\npstats->mstats.igmp_v3queries[dir]++;\r\n} else {\r\nunsigned int offset = skb_transport_offset(skb);\r\nstruct igmphdr *ih, _ihdr;\r\nih = skb_header_pointer(skb, offset,\r\nsizeof(_ihdr), &_ihdr);\r\nif (!ih)\r\nbreak;\r\nif (!ih->code)\r\npstats->mstats.igmp_v1queries[dir]++;\r\nelse\r\npstats->mstats.igmp_v2queries[dir]++;\r\n}\r\nbreak;\r\ncase IGMP_HOST_LEAVE_MESSAGE:\r\npstats->mstats.igmp_leaves[dir]++;\r\nbreak;\r\n}\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase htons(ETH_P_IPV6):\r\nt_len = ntohs(ipv6_hdr(skb)->payload_len) +\r\nsizeof(struct ipv6hdr);\r\nt_len -= skb_network_header_len(skb);\r\nswitch (type) {\r\ncase ICMPV6_MGM_REPORT:\r\npstats->mstats.mld_v1reports[dir]++;\r\nbreak;\r\ncase ICMPV6_MLD2_REPORT:\r\npstats->mstats.mld_v2reports[dir]++;\r\nbreak;\r\ncase ICMPV6_MGM_QUERY:\r\nif (t_len != sizeof(struct mld_msg))\r\npstats->mstats.mld_v2queries[dir]++;\r\nelse\r\npstats->mstats.mld_v1queries[dir]++;\r\nbreak;\r\ncase ICMPV6_MGM_REDUCTION:\r\npstats->mstats.mld_leaves[dir]++;\r\nbreak;\r\n}\r\nbreak;\r\n#endif\r\n}\r\nu64_stats_update_end(&pstats->syncp);\r\n}\r\nvoid br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,\r\nconst struct sk_buff *skb, u8 type, u8 dir)\r\n{\r\nstruct bridge_mcast_stats __percpu *stats;\r\nif (!type || !br->multicast_stats_enabled)\r\nreturn;\r\nif (p)\r\nstats = p->mcast_stats;\r\nelse\r\nstats = br->mcast_stats;\r\nif (WARN_ON(!stats))\r\nreturn;\r\nbr_mcast_stats_add(stats, skb, type, dir);\r\n}\r\nint br_multicast_init_stats(struct net_bridge *br)\r\n{\r\nbr->mcast_stats = netdev_alloc_pcpu_stats(struct bridge_mcast_stats);\r\nif (!br->mcast_stats)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid br_multicast_uninit_stats(struct net_bridge *br)\r\n{\r\nfree_percpu(br->mcast_stats);\r\n}\r\nstatic void mcast_stats_add_dir(u64 *dst, u64 *src)\r\n{\r\ndst[BR_MCAST_DIR_RX] += src[BR_MCAST_DIR_RX];\r\ndst[BR_MCAST_DIR_TX] += src[BR_MCAST_DIR_TX];\r\n}\r\nvoid br_multicast_get_stats(const struct net_bridge *br,\r\nconst struct net_bridge_port *p,\r\nstruct br_mcast_stats *dest)\r\n{\r\nstruct bridge_mcast_stats __percpu *stats;\r\nstruct br_mcast_stats tdst;\r\nint i;\r\nmemset(dest, 0, sizeof(*dest));\r\nif (p)\r\nstats = p->mcast_stats;\r\nelse\r\nstats = br->mcast_stats;\r\nif (WARN_ON(!stats))\r\nreturn;\r\nmemset(&tdst, 0, sizeof(tdst));\r\nfor_each_possible_cpu(i) {\r\nstruct bridge_mcast_stats *cpu_stats = per_cpu_ptr(stats, i);\r\nstruct br_mcast_stats temp;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\r\nmemcpy(&temp, &cpu_stats->mstats, sizeof(temp));\r\n} while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, start));\r\nmcast_stats_add_dir(tdst.igmp_v1queries, temp.igmp_v1queries);\r\nmcast_stats_add_dir(tdst.igmp_v2queries, temp.igmp_v2queries);\r\nmcast_stats_add_dir(tdst.igmp_v3queries, temp.igmp_v3queries);\r\nmcast_stats_add_dir(tdst.igmp_leaves, temp.igmp_leaves);\r\nmcast_stats_add_dir(tdst.igmp_v1reports, temp.igmp_v1reports);\r\nmcast_stats_add_dir(tdst.igmp_v2reports, temp.igmp_v2reports);\r\nmcast_stats_add_dir(tdst.igmp_v3reports, temp.igmp_v3reports);\r\ntdst.igmp_parse_errors += temp.igmp_parse_errors;\r\nmcast_stats_add_dir(tdst.mld_v1queries, temp.mld_v1queries);\r\nmcast_stats_add_dir(tdst.mld_v2queries, temp.mld_v2queries);\r\nmcast_stats_add_dir(tdst.mld_leaves, temp.mld_leaves);\r\nmcast_stats_add_dir(tdst.mld_v1reports, temp.mld_v1reports);\r\nmcast_stats_add_dir(tdst.mld_v2reports, temp.mld_v2reports);\r\ntdst.mld_parse_errors += temp.mld_parse_errors;\r\n}\r\nmemcpy(dest, &tdst, sizeof(*dest));\r\n}
