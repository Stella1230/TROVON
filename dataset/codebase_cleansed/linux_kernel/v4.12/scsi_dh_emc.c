static int trespass_endio(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sshdr)\r\n{\r\nint err = SCSI_DH_IO;\r\nsdev_printk(KERN_ERR, sdev, "%s: Found valid sense data 0x%2x, "\r\n"0x%2x, 0x%2x while sending CLARiiON trespass "\r\n"command.\n", CLARIION_NAME, sshdr->sense_key,\r\nsshdr->asc, sshdr->ascq);\r\nif (sshdr->sense_key == 0x05 && sshdr->asc == 0x04 &&\r\nsshdr->ascq == 0x00) {\r\nsdev_printk(KERN_INFO, sdev, "%s: Array Based Copy in "\r\n"progress while sending CLARiiON trespass "\r\n"command.\n", CLARIION_NAME);\r\nerr = SCSI_DH_DEV_TEMP_BUSY;\r\n} else if (sshdr->sense_key == 0x02 && sshdr->asc == 0x04 &&\r\nsshdr->ascq == 0x03) {\r\nsdev_printk(KERN_INFO, sdev, "%s: Detected in-progress "\r\n"ucode upgrade NDU operation while sending "\r\n"CLARiiON trespass command.\n", CLARIION_NAME);\r\nerr = SCSI_DH_DEV_TEMP_BUSY;\r\n} else\r\nerr = SCSI_DH_DEV_FAILED;\r\nreturn err;\r\n}\r\nstatic int parse_sp_info_reply(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nint err = SCSI_DH_OK;\r\nif (csdev->buffer[48] != 0) {\r\nsdev_printk(KERN_NOTICE, sdev, "%s: Detected in-progress "\r\n"ucode upgrade NDU operation while finding "\r\n"current active SP.", CLARIION_NAME);\r\nerr = SCSI_DH_DEV_TEMP_BUSY;\r\ngoto out;\r\n}\r\nif (csdev->buffer[4] > 2) {\r\nsdev_printk(KERN_NOTICE, sdev,\r\n"%s: invalid VPD page 0xC0 format\n",\r\nCLARIION_NAME);\r\nerr = SCSI_DH_NOSYS;\r\ngoto out;\r\n}\r\nswitch (csdev->buffer[28] & 0x0f) {\r\ncase 6:\r\nsdev_printk(KERN_NOTICE, sdev,\r\n"%s: ALUA failover mode detected\n",\r\nCLARIION_NAME);\r\nbreak;\r\ncase 4:\r\nbreak;\r\ndefault:\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid failover mode %d\n",\r\nCLARIION_NAME, csdev->buffer[28] & 0x0f);\r\nerr = SCSI_DH_NOSYS;\r\ngoto out;\r\n}\r\ncsdev->default_sp = csdev->buffer[5];\r\ncsdev->lun_state = csdev->buffer[4];\r\ncsdev->current_sp = csdev->buffer[8];\r\ncsdev->port = csdev->buffer[7];\r\nif (csdev->lun_state == CLARIION_LUN_OWNED)\r\nsdev->access_state = SCSI_ACCESS_STATE_OPTIMAL;\r\nelse\r\nsdev->access_state = SCSI_ACCESS_STATE_STANDBY;\r\nif (csdev->default_sp == csdev->current_sp)\r\nsdev->access_state |= SCSI_ACCESS_STATE_PREFERRED;\r\nout:\r\nreturn err;\r\n}\r\nstatic char * parse_sp_model(struct scsi_device *sdev, unsigned char *buffer)\r\n{\r\nunsigned char len = buffer[4] + 5;\r\nchar *sp_model = NULL;\r\nunsigned char sp_len, serial_len;\r\nif (len < 160) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid information section length %d\n",\r\nCLARIION_NAME, len);\r\nif (!strncmp(buffer + 8, "DGC", 3)) {\r\nsp_model = emc_default_str;\r\n}\r\ngoto out;\r\n}\r\nserial_len = buffer[160];\r\nif (serial_len == 0 || serial_len + 161 > len) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid array serial number length %d\n",\r\nCLARIION_NAME, serial_len);\r\ngoto out;\r\n}\r\nsp_len = buffer[99];\r\nif (sp_len == 0 || serial_len + sp_len + 161 > len) {\r\nsdev_printk(KERN_WARNING, sdev,\r\n"%s: Invalid model number length %d\n",\r\nCLARIION_NAME, sp_len);\r\ngoto out;\r\n}\r\nsp_model = &buffer[serial_len + 161];\r\nwhile (sp_len > 1 && sp_model[sp_len - 1] == ' ')\r\nsp_len--;\r\nsp_model[sp_len] = '\0';\r\nout:\r\nreturn sp_model;\r\n}\r\nstatic int send_trespass_cmd(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nunsigned char *page22;\r\nunsigned char cdb[COMMAND_SIZE(MODE_SELECT)];\r\nint err, res = SCSI_DH_OK, len;\r\nstruct scsi_sense_hdr sshdr;\r\nu64 req_flags = REQ_FAILFAST_DEV | REQ_FAILFAST_TRANSPORT |\r\nREQ_FAILFAST_DRIVER;\r\nif (csdev->flags & CLARIION_SHORT_TRESPASS) {\r\npage22 = short_trespass;\r\nif (!(csdev->flags & CLARIION_HONOR_RESERVATIONS))\r\npage22[6] |= 0x80;\r\nlen = sizeof(short_trespass);\r\ncdb[0] = MODE_SELECT;\r\ncdb[1] = 0x10;\r\ncdb[4] = len;\r\n} else {\r\npage22 = long_trespass;\r\nif (!(csdev->flags & CLARIION_HONOR_RESERVATIONS))\r\npage22[10] |= 0x80;\r\nlen = sizeof(long_trespass);\r\ncdb[0] = MODE_SELECT_10;\r\ncdb[8] = len;\r\n}\r\nBUG_ON((len > CLARIION_BUFFER_SIZE));\r\nmemcpy(csdev->buffer, page22, len);\r\nerr = scsi_execute(sdev, cdb, DMA_TO_DEVICE, csdev->buffer, len, NULL,\r\n&sshdr, CLARIION_TIMEOUT * HZ, CLARIION_RETRIES,\r\nreq_flags, 0, NULL);\r\nif (err) {\r\nif (scsi_sense_valid(&sshdr))\r\nres = trespass_endio(sdev, &sshdr);\r\nelse {\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: failed to send MODE SELECT: %x\n",\r\nCLARIION_NAME, err);\r\nres = SCSI_DH_IO;\r\n}\r\n}\r\nreturn res;\r\n}\r\nstatic int clariion_check_sense(struct scsi_device *sdev,\r\nstruct scsi_sense_hdr *sense_hdr)\r\n{\r\nswitch (sense_hdr->sense_key) {\r\ncase NOT_READY:\r\nif (sense_hdr->asc == 0x04 && sense_hdr->ascq == 0x03)\r\nreturn SUCCESS;\r\nbreak;\r\ncase ILLEGAL_REQUEST:\r\nif (sense_hdr->asc == 0x25 && sense_hdr->ascq == 0x01)\r\nreturn SUCCESS;\r\nbreak;\r\ncase UNIT_ATTENTION:\r\nif (sense_hdr->asc == 0x29 && sense_hdr->ascq == 0x00)\r\nreturn ADD_TO_MLQUEUE;\r\nbreak;\r\n}\r\nreturn SCSI_RETURN_NOT_HANDLED;\r\n}\r\nstatic int clariion_prep_fn(struct scsi_device *sdev, struct request *req)\r\n{\r\nstruct clariion_dh_data *h = sdev->handler_data;\r\nint ret = BLKPREP_OK;\r\nif (h->lun_state != CLARIION_LUN_OWNED) {\r\nret = BLKPREP_KILL;\r\nreq->rq_flags |= RQF_QUIET;\r\n}\r\nreturn ret;\r\n}\r\nstatic int clariion_std_inquiry(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nint err = SCSI_DH_OK;\r\nchar *sp_model;\r\nsp_model = parse_sp_model(sdev, sdev->inquiry);\r\nif (!sp_model) {\r\nerr = SCSI_DH_DEV_UNSUPP;\r\ngoto out;\r\n}\r\nif (!strlen(sp_model) || !strncmp(sp_model, "FC",2))\r\ncsdev->flags |= CLARIION_SHORT_TRESPASS;\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: detected Clariion %s, flags %x\n",\r\nCLARIION_NAME, sp_model, csdev->flags);\r\nout:\r\nreturn err;\r\n}\r\nstatic int clariion_send_inquiry(struct scsi_device *sdev,\r\nstruct clariion_dh_data *csdev)\r\n{\r\nint err = SCSI_DH_IO;\r\nif (!scsi_get_vpd_page(sdev, 0xC0, csdev->buffer,\r\nCLARIION_BUFFER_SIZE))\r\nerr = parse_sp_info_reply(sdev, csdev);\r\nreturn err;\r\n}\r\nstatic int clariion_activate(struct scsi_device *sdev,\r\nactivate_complete fn, void *data)\r\n{\r\nstruct clariion_dh_data *csdev = sdev->handler_data;\r\nint result;\r\nresult = clariion_send_inquiry(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\nif (csdev->lun_state == CLARIION_LUN_OWNED)\r\ngoto done;\r\nresult = send_trespass_cmd(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\nsdev_printk(KERN_INFO, sdev,"%s: %s trespass command sent\n",\r\nCLARIION_NAME,\r\ncsdev->flags&CLARIION_SHORT_TRESPASS?"short":"long" );\r\nresult = clariion_send_inquiry(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\ndone:\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: at SP %c Port %d (%s, default SP %c)\n",\r\nCLARIION_NAME, csdev->current_sp + 'A',\r\ncsdev->port, lun_state[csdev->lun_state],\r\ncsdev->default_sp + 'A');\r\nif (fn)\r\nfn(data, result);\r\nreturn 0;\r\n}\r\nstatic int clariion_set_params(struct scsi_device *sdev, const char *params)\r\n{\r\nstruct clariion_dh_data *csdev = sdev->handler_data;\r\nunsigned int hr = 0, st = 0, argc;\r\nconst char *p = params;\r\nint result = SCSI_DH_OK;\r\nif ((sscanf(params, "%u", &argc) != 1) || (argc != 2))\r\nreturn -EINVAL;\r\nwhile (*p++)\r\n;\r\nif ((sscanf(p, "%u", &st) != 1) || (st > 1))\r\nreturn -EINVAL;\r\nwhile (*p++)\r\n;\r\nif ((sscanf(p, "%u", &hr) != 1) || (hr > 1))\r\nreturn -EINVAL;\r\nif (st)\r\ncsdev->flags |= CLARIION_SHORT_TRESPASS;\r\nelse\r\ncsdev->flags &= ~CLARIION_SHORT_TRESPASS;\r\nif (hr)\r\ncsdev->flags |= CLARIION_HONOR_RESERVATIONS;\r\nelse\r\ncsdev->flags &= ~CLARIION_HONOR_RESERVATIONS;\r\nif (csdev->lun_state != CLARIION_LUN_OWNED)\r\ngoto done;\r\ncsdev->lun_state = CLARIION_LUN_UNINITIALIZED;\r\nresult = send_trespass_cmd(sdev, csdev);\r\nif (result != SCSI_DH_OK)\r\ngoto done;\r\nresult = clariion_send_inquiry(sdev, csdev);\r\ndone:\r\nreturn result;\r\n}\r\nstatic int clariion_bus_attach(struct scsi_device *sdev)\r\n{\r\nstruct clariion_dh_data *h;\r\nint err;\r\nh = kzalloc(sizeof(*h) , GFP_KERNEL);\r\nif (!h)\r\nreturn -ENOMEM;\r\nh->lun_state = CLARIION_LUN_UNINITIALIZED;\r\nh->default_sp = CLARIION_UNBOUND_LU;\r\nh->current_sp = CLARIION_UNBOUND_LU;\r\nerr = clariion_std_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto failed;\r\nerr = clariion_send_inquiry(sdev, h);\r\nif (err != SCSI_DH_OK)\r\ngoto failed;\r\nsdev_printk(KERN_INFO, sdev,\r\n"%s: connected to SP %c Port %d (%s, default SP %c)\n",\r\nCLARIION_NAME, h->current_sp + 'A',\r\nh->port, lun_state[h->lun_state],\r\nh->default_sp + 'A');\r\nsdev->handler_data = h;\r\nreturn 0;\r\nfailed:\r\nkfree(h);\r\nreturn -EINVAL;\r\n}\r\nstatic void clariion_bus_detach(struct scsi_device *sdev)\r\n{\r\nkfree(sdev->handler_data);\r\nsdev->handler_data = NULL;\r\n}\r\nstatic int __init clariion_init(void)\r\n{\r\nint r;\r\nr = scsi_register_device_handler(&clariion_dh);\r\nif (r != 0)\r\nprintk(KERN_ERR "%s: Failed to register scsi device handler.",\r\nCLARIION_NAME);\r\nreturn r;\r\n}\r\nstatic void __exit clariion_exit(void)\r\n{\r\nscsi_unregister_device_handler(&clariion_dh);\r\n}
