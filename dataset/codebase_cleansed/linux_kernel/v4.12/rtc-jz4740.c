static inline uint32_t jz4740_rtc_reg_read(struct jz4740_rtc *rtc, size_t reg)\r\n{\r\nreturn readl(rtc->base + reg);\r\n}\r\nstatic int jz4740_rtc_wait_write_ready(struct jz4740_rtc *rtc)\r\n{\r\nuint32_t ctrl;\r\nint timeout = 1000;\r\ndo {\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\n} while (!(ctrl & JZ_RTC_CTRL_WRDY) && --timeout);\r\nreturn timeout ? 0 : -EIO;\r\n}\r\nstatic inline int jz4780_rtc_enable_write(struct jz4740_rtc *rtc)\r\n{\r\nuint32_t ctrl;\r\nint ret, timeout = 1000;\r\nret = jz4740_rtc_wait_write_ready(rtc);\r\nif (ret != 0)\r\nreturn ret;\r\nwritel(JZ_RTC_WENR_MAGIC, rtc->base + JZ_REG_RTC_WENR);\r\ndo {\r\nctrl = readl(rtc->base + JZ_REG_RTC_WENR);\r\n} while (!(ctrl & JZ_RTC_WENR_WEN) && --timeout);\r\nreturn timeout ? 0 : -EIO;\r\n}\r\nstatic inline int jz4740_rtc_reg_write(struct jz4740_rtc *rtc, size_t reg,\r\nuint32_t val)\r\n{\r\nint ret = 0;\r\nif (rtc->type >= ID_JZ4780)\r\nret = jz4780_rtc_enable_write(rtc);\r\nif (ret == 0)\r\nret = jz4740_rtc_wait_write_ready(rtc);\r\nif (ret == 0)\r\nwritel(val, rtc->base + reg);\r\nreturn ret;\r\n}\r\nstatic int jz4740_rtc_ctrl_set_bits(struct jz4740_rtc *rtc, uint32_t mask,\r\nbool set)\r\n{\r\nint ret;\r\nunsigned long flags;\r\nuint32_t ctrl;\r\nspin_lock_irqsave(&rtc->lock, flags);\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\nctrl |= JZ_RTC_CTRL_1HZ | JZ_RTC_CTRL_AF;\r\nif (set)\r\nctrl |= mask;\r\nelse\r\nctrl &= ~mask;\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_CTRL, ctrl);\r\nspin_unlock_irqrestore(&rtc->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int jz4740_rtc_read_time(struct device *dev, struct rtc_time *time)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nuint32_t secs, secs2;\r\nint timeout = 5;\r\nsecs = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\r\nsecs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\r\nwhile (secs != secs2 && --timeout) {\r\nsecs = secs2;\r\nsecs2 = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC);\r\n}\r\nif (timeout == 0)\r\nreturn -EIO;\r\nrtc_time_to_tm(secs, time);\r\nreturn rtc_valid_tm(time);\r\n}\r\nstatic int jz4740_rtc_set_mmss(struct device *dev, unsigned long secs)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nreturn jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC, secs);\r\n}\r\nstatic int jz4740_rtc_read_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nuint32_t secs;\r\nuint32_t ctrl;\r\nsecs = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SEC_ALARM);\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\nalrm->enabled = !!(ctrl & JZ_RTC_CTRL_AE);\r\nalrm->pending = !!(ctrl & JZ_RTC_CTRL_AF);\r\nrtc_time_to_tm(secs, &alrm->time);\r\nreturn rtc_valid_tm(&alrm->time);\r\n}\r\nstatic int jz4740_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alrm)\r\n{\r\nint ret;\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nunsigned long secs;\r\nrtc_tm_to_time(&alrm->time, &secs);\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC_ALARM, secs);\r\nif (!ret)\r\nret = jz4740_rtc_ctrl_set_bits(rtc,\r\nJZ_RTC_CTRL_AE | JZ_RTC_CTRL_AF_IRQ, alrm->enabled);\r\nreturn ret;\r\n}\r\nstatic int jz4740_rtc_alarm_irq_enable(struct device *dev, unsigned int enable)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nreturn jz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_AF_IRQ, enable);\r\n}\r\nstatic irqreturn_t jz4740_rtc_irq(int irq, void *data)\r\n{\r\nstruct jz4740_rtc *rtc = data;\r\nuint32_t ctrl;\r\nunsigned long events = 0;\r\nctrl = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_CTRL);\r\nif (ctrl & JZ_RTC_CTRL_1HZ)\r\nevents |= (RTC_UF | RTC_IRQF);\r\nif (ctrl & JZ_RTC_CTRL_AF)\r\nevents |= (RTC_AF | RTC_IRQF);\r\nrtc_update_irq(rtc->rtc, 1, events);\r\njz4740_rtc_ctrl_set_bits(rtc, JZ_RTC_CTRL_1HZ | JZ_RTC_CTRL_AF, false);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void jz4740_rtc_poweroff(struct device *dev)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\njz4740_rtc_reg_write(rtc, JZ_REG_RTC_HIBERNATE, 1);\r\n}\r\nstatic void jz4740_rtc_power_off(void)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev_for_power_off);\r\nunsigned long rtc_rate;\r\nunsigned long wakeup_filter_ticks;\r\nunsigned long reset_counter_ticks;\r\nclk_prepare_enable(rtc->clk);\r\nrtc_rate = clk_get_rate(rtc->clk);\r\nwakeup_filter_ticks =\r\n(rtc->min_wakeup_pin_assert_time * rtc_rate) / 1000;\r\nif (wakeup_filter_ticks < JZ_RTC_WAKEUP_FILTER_MASK)\r\nwakeup_filter_ticks &= JZ_RTC_WAKEUP_FILTER_MASK;\r\nelse\r\nwakeup_filter_ticks = JZ_RTC_WAKEUP_FILTER_MASK;\r\njz4740_rtc_reg_write(rtc,\r\nJZ_REG_RTC_WAKEUP_FILTER, wakeup_filter_ticks);\r\nreset_counter_ticks = (rtc->reset_pin_assert_time * rtc_rate) / 1000;\r\nif (reset_counter_ticks < JZ_RTC_RESET_COUNTER_MASK)\r\nreset_counter_ticks &= JZ_RTC_RESET_COUNTER_MASK;\r\nelse\r\nreset_counter_ticks = JZ_RTC_RESET_COUNTER_MASK;\r\njz4740_rtc_reg_write(rtc,\r\nJZ_REG_RTC_RESET_COUNTER, reset_counter_ticks);\r\njz4740_rtc_poweroff(dev_for_power_off);\r\nkernel_halt();\r\n}\r\nstatic int jz4740_rtc_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct jz4740_rtc *rtc;\r\nuint32_t scratchpad;\r\nstruct resource *mem;\r\nconst struct platform_device_id *id = platform_get_device_id(pdev);\r\nconst struct of_device_id *of_id = of_match_device(\r\njz4740_rtc_of_match, &pdev->dev);\r\nstruct device_node *np = pdev->dev.of_node;\r\nrtc = devm_kzalloc(&pdev->dev, sizeof(*rtc), GFP_KERNEL);\r\nif (!rtc)\r\nreturn -ENOMEM;\r\nif (of_id)\r\nrtc->type = (enum jz4740_rtc_type)of_id->data;\r\nelse\r\nrtc->type = id->driver_data;\r\nrtc->irq = platform_get_irq(pdev, 0);\r\nif (rtc->irq < 0) {\r\ndev_err(&pdev->dev, "Failed to get platform irq\n");\r\nreturn -ENOENT;\r\n}\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nrtc->base = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(rtc->base))\r\nreturn PTR_ERR(rtc->base);\r\nrtc->clk = devm_clk_get(&pdev->dev, "rtc");\r\nif (IS_ERR(rtc->clk)) {\r\ndev_err(&pdev->dev, "Failed to get RTC clock\n");\r\nreturn PTR_ERR(rtc->clk);\r\n}\r\nspin_lock_init(&rtc->lock);\r\nplatform_set_drvdata(pdev, rtc);\r\ndevice_init_wakeup(&pdev->dev, 1);\r\nrtc->rtc = devm_rtc_device_register(&pdev->dev, pdev->name,\r\n&jz4740_rtc_ops, THIS_MODULE);\r\nif (IS_ERR(rtc->rtc)) {\r\nret = PTR_ERR(rtc->rtc);\r\ndev_err(&pdev->dev, "Failed to register rtc device: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = devm_request_irq(&pdev->dev, rtc->irq, jz4740_rtc_irq, 0,\r\npdev->name, rtc);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Failed to request rtc irq: %d\n", ret);\r\nreturn ret;\r\n}\r\nscratchpad = jz4740_rtc_reg_read(rtc, JZ_REG_RTC_SCRATCHPAD);\r\nif (scratchpad != 0x12345678) {\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SCRATCHPAD, 0x12345678);\r\nret = jz4740_rtc_reg_write(rtc, JZ_REG_RTC_SEC, 0);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Could not write write to RTC registers\n");\r\nreturn ret;\r\n}\r\n}\r\nif (np && of_device_is_system_power_controller(np)) {\r\nif (!pm_power_off) {\r\nrtc->reset_pin_assert_time = 60;\r\nof_property_read_u32(np, "reset-pin-assert-time-ms",\r\n&rtc->reset_pin_assert_time);\r\nrtc->min_wakeup_pin_assert_time = 100;\r\nof_property_read_u32(np,\r\n"min-wakeup-pin-assert-time-ms",\r\n&rtc->min_wakeup_pin_assert_time);\r\ndev_for_power_off = &pdev->dev;\r\npm_power_off = jz4740_rtc_power_off;\r\n} else {\r\ndev_warn(&pdev->dev,\r\n"Poweroff handler already present!\n");\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int jz4740_rtc_suspend(struct device *dev)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\nenable_irq_wake(rtc->irq);\r\nreturn 0;\r\n}\r\nstatic int jz4740_rtc_resume(struct device *dev)\r\n{\r\nstruct jz4740_rtc *rtc = dev_get_drvdata(dev);\r\nif (device_may_wakeup(dev))\r\ndisable_irq_wake(rtc->irq);\r\nreturn 0;\r\n}
