static sint _init_mlme_priv(struct _adapter *padapter)\r\n{\r\nsint i;\r\nu8 *pbuf;\r\nstruct wlan_network *pnetwork;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nmemset((u8 *)pmlmepriv, 0, sizeof(struct mlme_priv));\r\npmlmepriv->nic_hdl = (u8 *)padapter;\r\npmlmepriv->pscanned = NULL;\r\npmlmepriv->fw_state = 0;\r\npmlmepriv->cur_network.network.InfrastructureMode =\r\nNdis802_11AutoUnknown;\r\npmlmepriv->passive_mode = 1;\r\nspin_lock_init(&(pmlmepriv->lock));\r\nspin_lock_init(&(pmlmepriv->lock2));\r\n_init_queue(&(pmlmepriv->free_bss_pool));\r\n_init_queue(&(pmlmepriv->scanned_queue));\r\nset_scanned_network_val(pmlmepriv, 0);\r\nmemset(&pmlmepriv->assoc_ssid, 0, sizeof(struct ndis_802_11_ssid));\r\npbuf = kmalloc_array(MAX_BSS_CNT, sizeof(struct wlan_network),\r\nGFP_ATOMIC);\r\nif (!pbuf)\r\nreturn _FAIL;\r\npmlmepriv->free_bss_buf = pbuf;\r\npnetwork = (struct wlan_network *)pbuf;\r\nfor (i = 0; i < MAX_BSS_CNT; i++) {\r\nINIT_LIST_HEAD(&(pnetwork->list));\r\nlist_add_tail(&(pnetwork->list),\r\n&(pmlmepriv->free_bss_pool.queue));\r\npnetwork++;\r\n}\r\npmlmepriv->sitesurveyctrl.last_rx_pkts = 0;\r\npmlmepriv->sitesurveyctrl.last_tx_pkts = 0;\r\npmlmepriv->sitesurveyctrl.traffic_busy = false;\r\nr8712_init_mlme_timer(padapter);\r\nreturn _SUCCESS;\r\n}\r\nstruct wlan_network *_r8712_alloc_network(struct mlme_priv *pmlmepriv)\r\n{\r\nunsigned long irqL;\r\nstruct wlan_network *pnetwork;\r\nstruct __queue *free_queue = &pmlmepriv->free_bss_pool;\r\nspin_lock_irqsave(&free_queue->lock, irqL);\r\npnetwork = list_first_entry_or_null(&free_queue->queue,\r\nstruct wlan_network, list);\r\nif (pnetwork) {\r\nlist_del_init(&pnetwork->list);\r\npnetwork->last_scanned = jiffies;\r\npmlmepriv->num_of_scanned++;\r\n}\r\nspin_unlock_irqrestore(&free_queue->lock, irqL);\r\nreturn pnetwork;\r\n}\r\nstatic void _free_network(struct mlme_priv *pmlmepriv,\r\nstruct wlan_network *pnetwork)\r\n{\r\nu32 curr_time, delta_time;\r\nunsigned long irqL;\r\nstruct __queue *free_queue = &(pmlmepriv->free_bss_pool);\r\nif (pnetwork == NULL)\r\nreturn;\r\nif (pnetwork->fixed)\r\nreturn;\r\ncurr_time = jiffies;\r\ndelta_time = (curr_time - (u32)pnetwork->last_scanned) / HZ;\r\nif (delta_time < SCANQUEUE_LIFETIME)\r\nreturn;\r\nspin_lock_irqsave(&free_queue->lock, irqL);\r\nlist_del_init(&pnetwork->list);\r\nlist_add_tail(&pnetwork->list, &free_queue->queue);\r\npmlmepriv->num_of_scanned--;\r\nspin_unlock_irqrestore(&free_queue->lock, irqL);\r\n}\r\nstatic void free_network_nolock(struct mlme_priv *pmlmepriv,\r\nstruct wlan_network *pnetwork)\r\n{\r\nstruct __queue *free_queue = &pmlmepriv->free_bss_pool;\r\nif (pnetwork == NULL)\r\nreturn;\r\nif (pnetwork->fixed)\r\nreturn;\r\nlist_del_init(&pnetwork->list);\r\nlist_add_tail(&pnetwork->list, &free_queue->queue);\r\npmlmepriv->num_of_scanned--;\r\n}\r\nstatic struct wlan_network *_r8712_find_network(struct __queue *scanned_queue,\r\nu8 *addr)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *phead, *plist;\r\nstruct wlan_network *pnetwork = NULL;\r\nif (is_zero_ether_addr(addr))\r\nreturn NULL;\r\nspin_lock_irqsave(&scanned_queue->lock, irqL);\r\nphead = &scanned_queue->queue;\r\nplist = phead->next;\r\nwhile (plist != phead) {\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nplist = plist->next;\r\nif (!memcmp(addr, pnetwork->network.MacAddress, ETH_ALEN))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&scanned_queue->lock, irqL);\r\nreturn pnetwork;\r\n}\r\nstatic void _free_network_queue(struct _adapter *padapter)\r\n{\r\nunsigned long irqL;\r\nstruct list_head *phead, *plist;\r\nstruct wlan_network *pnetwork;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct __queue *scanned_queue = &pmlmepriv->scanned_queue;\r\nspin_lock_irqsave(&scanned_queue->lock, irqL);\r\nphead = &scanned_queue->queue;\r\nplist = phead->next;\r\nwhile (!end_of_queue_search(phead, plist)) {\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nplist = plist->next;\r\n_free_network(pmlmepriv, pnetwork);\r\n}\r\nspin_unlock_irqrestore(&scanned_queue->lock, irqL);\r\n}\r\nsint r8712_if_up(struct _adapter *padapter)\r\n{\r\nsint res;\r\nif (padapter->bDriverStopped || padapter->bSurpriseRemoved ||\r\n!check_fwstate(&padapter->mlmepriv, _FW_LINKED)) {\r\nres = false;\r\n} else {\r\nres = true;\r\n}\r\nreturn res;\r\n}\r\nvoid r8712_generate_random_ibss(u8 *pibss)\r\n{\r\nu32 curtime = jiffies;\r\npibss[0] = 0x02;\r\npibss[1] = 0x11;\r\npibss[2] = 0x87;\r\npibss[3] = (u8)(curtime & 0xff);\r\npibss[4] = (u8)((curtime >> 8) & 0xff);\r\npibss[5] = (u8)((curtime >> 16) & 0xff);\r\n}\r\nuint r8712_get_wlan_bssid_ex_sz(struct wlan_bssid_ex *bss)\r\n{\r\nreturn sizeof(*bss) + bss->IELength - MAX_IE_SZ;\r\n}\r\nu8 *r8712_get_capability_from_ie(u8 *ie)\r\n{\r\nreturn ie + 8 + 2;\r\n}\r\nint r8712_init_mlme_priv(struct _adapter *padapter)\r\n{\r\nreturn _init_mlme_priv(padapter);\r\n}\r\nvoid r8712_free_mlme_priv(struct mlme_priv *pmlmepriv)\r\n{\r\nkfree(pmlmepriv->free_bss_buf);\r\n}\r\nstatic struct wlan_network *alloc_network(struct mlme_priv *pmlmepriv)\r\n{\r\nreturn _r8712_alloc_network(pmlmepriv);\r\n}\r\nvoid r8712_free_network_queue(struct _adapter *dev)\r\n{\r\n_free_network_queue(dev);\r\n}\r\nstatic struct wlan_network *r8712_find_network(struct __queue *scanned_queue,\r\nu8 *addr)\r\n{\r\nstruct wlan_network *pnetwork = _r8712_find_network(scanned_queue,\r\naddr);\r\nreturn pnetwork;\r\n}\r\nint r8712_is_same_ibss(struct _adapter *adapter, struct wlan_network *pnetwork)\r\n{\r\nint ret = true;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nif ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&\r\n(pnetwork->network.Privacy == cpu_to_le32(0)))\r\nret = false;\r\nelse if ((psecuritypriv->PrivacyAlgrthm == _NO_PRIVACY_) &&\r\n(pnetwork->network.Privacy == cpu_to_le32(1)))\r\nret = false;\r\nelse\r\nret = true;\r\nreturn ret;\r\n}\r\nstatic int is_same_network(struct wlan_bssid_ex *src,\r\nstruct wlan_bssid_ex *dst)\r\n{\r\nu16 s_cap, d_cap;\r\nmemcpy((u8 *)&s_cap, r8712_get_capability_from_ie(src->IEs), 2);\r\nmemcpy((u8 *)&d_cap, r8712_get_capability_from_ie(dst->IEs), 2);\r\nreturn (src->Ssid.SsidLength == dst->Ssid.SsidLength) &&\r\n(src->Configuration.DSConfig ==\r\ndst->Configuration.DSConfig) &&\r\n((!memcmp(src->MacAddress, dst->MacAddress,\r\nETH_ALEN))) &&\r\n((!memcmp(src->Ssid.Ssid,\r\ndst->Ssid.Ssid,\r\nsrc->Ssid.SsidLength))) &&\r\n((s_cap & WLAN_CAPABILITY_IBSS) ==\r\n(d_cap & WLAN_CAPABILITY_IBSS)) &&\r\n((s_cap & WLAN_CAPABILITY_BSS) ==\r\n(d_cap & WLAN_CAPABILITY_BSS));\r\n}\r\nstruct wlan_network *r8712_get_oldest_wlan_network(\r\nstruct __queue *scanned_queue)\r\n{\r\nstruct list_head *plist, *phead;\r\nstruct wlan_network *pwlan = NULL;\r\nstruct wlan_network *oldest = NULL;\r\nphead = &scanned_queue->queue;\r\nplist = phead->next;\r\nwhile (1) {\r\nif (end_of_queue_search(phead, plist) == true)\r\nbreak;\r\npwlan = container_of(plist, struct wlan_network, list);\r\nif (pwlan->fixed != true) {\r\nif (oldest == NULL ||\r\ntime_after((unsigned long)oldest->last_scanned,\r\n(unsigned long)pwlan->last_scanned))\r\noldest = pwlan;\r\n}\r\nplist = plist->next;\r\n}\r\nreturn oldest;\r\n}\r\nstatic void update_network(struct wlan_bssid_ex *dst,\r\nstruct wlan_bssid_ex *src,\r\nstruct _adapter *padapter)\r\n{\r\nu32 last_evm = 0, tmpVal;\r\nif (check_fwstate(&padapter->mlmepriv, _FW_LINKED) &&\r\nis_same_network(&(padapter->mlmepriv.cur_network.network), src)) {\r\nif (padapter->recvpriv.signal_qual_data.total_num++ >=\r\nPHY_LINKQUALITY_SLID_WIN_MAX) {\r\npadapter->recvpriv.signal_qual_data.total_num =\r\nPHY_LINKQUALITY_SLID_WIN_MAX;\r\nlast_evm = padapter->recvpriv.signal_qual_data.\r\nelements[padapter->recvpriv.\r\nsignal_qual_data.index];\r\npadapter->recvpriv.signal_qual_data.total_val -=\r\nlast_evm;\r\n}\r\npadapter->recvpriv.signal_qual_data.total_val += src->Rssi;\r\npadapter->recvpriv.signal_qual_data.\r\nelements[padapter->recvpriv.signal_qual_data.\r\nindex++] = src->Rssi;\r\nif (padapter->recvpriv.signal_qual_data.index >=\r\nPHY_LINKQUALITY_SLID_WIN_MAX)\r\npadapter->recvpriv.signal_qual_data.index = 0;\r\ntmpVal = padapter->recvpriv.signal_qual_data.total_val /\r\npadapter->recvpriv.signal_qual_data.total_num;\r\npadapter->recvpriv.signal = (u8)tmpVal;\r\nsrc->Rssi = padapter->recvpriv.signal;\r\n} else {\r\nsrc->Rssi = (src->Rssi + dst->Rssi) / 2;\r\n}\r\nmemcpy((u8 *)dst, (u8 *)src, r8712_get_wlan_bssid_ex_sz(src));\r\n}\r\nstatic void update_current_network(struct _adapter *adapter,\r\nstruct wlan_bssid_ex *pnetwork)\r\n{\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nif (is_same_network(&(pmlmepriv->cur_network.network), pnetwork)) {\r\nupdate_network(&(pmlmepriv->cur_network.network),\r\npnetwork, adapter);\r\nr8712_update_protection(adapter,\r\n(pmlmepriv->cur_network.network.IEs) +\r\nsizeof(struct NDIS_802_11_FIXED_IEs),\r\npmlmepriv->cur_network.network.IELength);\r\n}\r\n}\r\nstatic void update_scanned_network(struct _adapter *adapter,\r\nstruct wlan_bssid_ex *target)\r\n{\r\nstruct list_head *plist, *phead;\r\nu32 bssid_ex_sz;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nstruct wlan_network *pnetwork = NULL;\r\nstruct wlan_network *oldest = NULL;\r\nphead = &queue->queue;\r\nplist = phead->next;\r\nwhile (1) {\r\nif (end_of_queue_search(phead, plist))\r\nbreak;\r\npnetwork = container_of(plist, struct wlan_network, list);\r\nif (is_same_network(&pnetwork->network, target))\r\nbreak;\r\nif ((oldest == ((struct wlan_network *)0)) ||\r\ntime_after((unsigned long)oldest->last_scanned,\r\n(unsigned long)pnetwork->last_scanned))\r\noldest = pnetwork;\r\nplist = plist->next;\r\n}\r\nif (end_of_queue_search(phead, plist)) {\r\nif (list_empty(&pmlmepriv->free_bss_pool.queue)) {\r\npnetwork = oldest;\r\ntarget->Rssi = (pnetwork->network.Rssi +\r\ntarget->Rssi) / 2;\r\nmemcpy(&pnetwork->network, target,\r\nr8712_get_wlan_bssid_ex_sz(target));\r\npnetwork->last_scanned = jiffies;\r\n} else {\r\npnetwork = alloc_network(pmlmepriv);\r\nif (pnetwork == NULL)\r\nreturn;\r\nbssid_ex_sz = r8712_get_wlan_bssid_ex_sz(target);\r\ntarget->Length = bssid_ex_sz;\r\nmemcpy(&pnetwork->network, target, bssid_ex_sz);\r\nlist_add_tail(&pnetwork->list, &queue->queue);\r\n}\r\n} else {\r\nupdate_network(&pnetwork->network, target, adapter);\r\npnetwork->last_scanned = jiffies;\r\n}\r\n}\r\nstatic void rtl8711_add_network(struct _adapter *adapter,\r\nstruct wlan_bssid_ex *pnetwork)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &(((struct _adapter *)adapter)->mlmepriv);\r\nstruct __queue *queue = &pmlmepriv->scanned_queue;\r\nspin_lock_irqsave(&queue->lock, irqL);\r\nupdate_current_network(adapter, pnetwork);\r\nupdate_scanned_network(adapter, pnetwork);\r\nspin_unlock_irqrestore(&queue->lock, irqL);\r\n}\r\nstatic int is_desired_network(struct _adapter *adapter,\r\nstruct wlan_network *pnetwork)\r\n{\r\nu8 wps_ie[512];\r\nuint wps_ielen;\r\nint bselected = true;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nif (psecuritypriv->wps_phase) {\r\nif (r8712_get_wps_ie(pnetwork->network.IEs,\r\npnetwork->network.IELength, wps_ie,\r\n&wps_ielen))\r\nreturn true;\r\nreturn false;\r\n}\r\nif ((psecuritypriv->PrivacyAlgrthm != _NO_PRIVACY_) &&\r\n(pnetwork->network.Privacy == 0))\r\nbselected = false;\r\nif (check_fwstate(&adapter->mlmepriv, WIFI_ADHOC_STATE)) {\r\nif (pnetwork->network.InfrastructureMode !=\r\nadapter->mlmepriv.cur_network.network.\r\nInfrastructureMode)\r\nbselected = false;\r\n}\r\nreturn bselected;\r\n}\r\nvoid r8712_atimdone_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\n}\r\nvoid r8712_survey_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nunsigned long flags;\r\nu32 len;\r\nstruct wlan_bssid_ex *pnetwork;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\npnetwork = (struct wlan_bssid_ex *)pbuf;\r\n#ifdef __BIG_ENDIAN\r\npnetwork->Length = le32_to_cpu(pnetwork->Length);\r\npnetwork->Ssid.SsidLength = le32_to_cpu(pnetwork->Ssid.SsidLength);\r\npnetwork->Privacy = le32_to_cpu(pnetwork->Privacy);\r\npnetwork->Rssi = le32_to_cpu(pnetwork->Rssi);\r\npnetwork->NetworkTypeInUse = le32_to_cpu(pnetwork->NetworkTypeInUse);\r\npnetwork->Configuration.ATIMWindow =\r\nle32_to_cpu(pnetwork->Configuration.ATIMWindow);\r\npnetwork->Configuration.BeaconPeriod =\r\nle32_to_cpu(pnetwork->Configuration.BeaconPeriod);\r\npnetwork->Configuration.DSConfig =\r\nle32_to_cpu(pnetwork->Configuration.DSConfig);\r\npnetwork->Configuration.FHConfig.DwellTime =\r\nle32_to_cpu(pnetwork->Configuration.FHConfig.DwellTime);\r\npnetwork->Configuration.FHConfig.HopPattern =\r\nle32_to_cpu(pnetwork->Configuration.FHConfig.HopPattern);\r\npnetwork->Configuration.FHConfig.HopSet =\r\nle32_to_cpu(pnetwork->Configuration.FHConfig.HopSet);\r\npnetwork->Configuration.FHConfig.Length =\r\nle32_to_cpu(pnetwork->Configuration.FHConfig.Length);\r\npnetwork->Configuration.Length =\r\nle32_to_cpu(pnetwork->Configuration.Length);\r\npnetwork->InfrastructureMode =\r\nle32_to_cpu(pnetwork->InfrastructureMode);\r\npnetwork->IELength = le32_to_cpu(pnetwork->IELength);\r\n#endif\r\nlen = r8712_get_wlan_bssid_ex_sz(pnetwork);\r\nif (len > sizeof(struct wlan_bssid_ex))\r\nreturn;\r\nspin_lock_irqsave(&pmlmepriv->lock2, flags);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) {\r\nif (!memcmp(&(pmlmepriv->cur_network.network.MacAddress),\r\npnetwork->MacAddress, ETH_ALEN)) {\r\nstruct wlan_network *ibss_wlan = NULL;\r\nmemcpy(pmlmepriv->cur_network.network.IEs,\r\npnetwork->IEs, 8);\r\nibss_wlan = r8712_find_network(\r\n&pmlmepriv->scanned_queue,\r\npnetwork->MacAddress);\r\nif (ibss_wlan) {\r\nmemcpy(ibss_wlan->network.IEs,\r\npnetwork->IEs, 8);\r\ngoto exit;\r\n}\r\n}\r\n}\r\nif (!check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\r\nif (pnetwork->Ssid.Ssid[0] != 0) {\r\nrtl8711_add_network(adapter, pnetwork);\r\n} else {\r\npnetwork->Ssid.SsidLength = 8;\r\nmemcpy(pnetwork->Ssid.Ssid, "<hidden>", 8);\r\nrtl8711_add_network(adapter, pnetwork);\r\n}\r\n}\r\nexit:\r\nspin_unlock_irqrestore(&pmlmepriv->lock2, flags);\r\n}\r\nvoid r8712_surveydone_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL);\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_SURVEY)) {\r\ndel_timer(&pmlmepriv->scan_to_timer);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\r\n}\r\nif (pmlmepriv->to_join) {\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\r\nif (!check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\nif (r8712_select_and_join_from_scan(pmlmepriv)\r\n== _SUCCESS)\r\nmod_timer(&pmlmepriv->assoc_timer, jiffies +\r\nmsecs_to_jiffies(MAX_JOIN_TIMEOUT));\r\nelse {\r\nstruct wlan_bssid_ex *pdev_network =\r\n&(adapter->registrypriv.dev_network);\r\nu8 *pibss =\r\nadapter->registrypriv.\r\ndev_network.MacAddress;\r\npmlmepriv->fw_state ^= _FW_UNDER_SURVEY;\r\nmemcpy(&pdev_network->Ssid,\r\n&pmlmepriv->assoc_ssid,\r\nsizeof(struct\r\nndis_802_11_ssid));\r\nr8712_update_registrypriv_dev_network\r\n(adapter);\r\nr8712_generate_random_ibss(pibss);\r\npmlmepriv->fw_state =\r\nWIFI_ADHOC_MASTER_STATE;\r\npmlmepriv->to_join = false;\r\n}\r\n}\r\n} else {\r\npmlmepriv->to_join = false;\r\nset_fwstate(pmlmepriv, _FW_UNDER_LINKING);\r\nif (r8712_select_and_join_from_scan(pmlmepriv) ==\r\n_SUCCESS)\r\nmod_timer(&pmlmepriv->assoc_timer, jiffies +\r\nmsecs_to_jiffies(MAX_JOIN_TIMEOUT));\r\nelse\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\r\n}\r\nvoid r8712_free_assoc_resources(struct _adapter *adapter)\r\n{\r\nunsigned long irqL;\r\nstruct wlan_network *pwlan = NULL;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\r\npwlan = r8712_find_network(&pmlmepriv->scanned_queue,\r\ntgt_network->network.MacAddress);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE | WIFI_AP_STATE)) {\r\nstruct sta_info *psta;\r\npsta = r8712_get_stainfo(&adapter->stapriv,\r\ntgt_network->network.MacAddress);\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nr8712_free_stainfo(adapter, psta);\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\n}\r\nif (check_fwstate(pmlmepriv,\r\nWIFI_ADHOC_STATE | WIFI_ADHOC_MASTER_STATE | WIFI_AP_STATE))\r\nr8712_free_all_stainfo(adapter);\r\nif (pwlan)\r\npwlan->fixed = false;\r\nif (((check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE)) &&\r\n(adapter->stapriv.asoc_sta_count == 1)))\r\nfree_network_nolock(pmlmepriv, pwlan);\r\n}\r\nvoid r8712_indicate_connect(struct _adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\npmlmepriv->to_join = false;\r\nset_fwstate(pmlmepriv, _FW_LINKED);\r\npadapter->ledpriv.LedControlHandler(padapter, LED_CTL_LINK);\r\nr8712_os_indicate_connect(padapter);\r\nif (padapter->registrypriv.power_mgnt > PS_MODE_ACTIVE)\r\nmod_timer(&pmlmepriv->dhcp_timer,\r\njiffies + msecs_to_jiffies(60000));\r\n}\r\nvoid r8712_ind_disconnect(struct _adapter *padapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\n_clr_fwstate_(pmlmepriv, _FW_LINKED);\r\npadapter->ledpriv.LedControlHandler(padapter, LED_CTL_NO_LINK);\r\nr8712_os_indicate_disconnect(padapter);\r\n}\r\nif (padapter->pwrctrlpriv.pwr_mode !=\r\npadapter->registrypriv.power_mgnt) {\r\ndel_timer(&pmlmepriv->dhcp_timer);\r\nr8712_set_ps_mode(padapter, padapter->registrypriv.power_mgnt,\r\npadapter->registrypriv.smart_ps);\r\n}\r\n}\r\nvoid r8712_joinbss_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nunsigned long irqL = 0, irqL2;\r\nstruct sta_info *ptarget_sta = NULL, *pcur_sta = NULL;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct wlan_network *cur_network = &pmlmepriv->cur_network;\r\nstruct wlan_network *pcur_wlan = NULL, *ptarget_wlan = NULL;\r\nunsigned int the_same_macaddr = false;\r\nstruct wlan_network *pnetwork;\r\nif (sizeof(struct list_head) == 4 * sizeof(u32)) {\r\npnetwork = kmalloc(sizeof(struct wlan_network), GFP_ATOMIC);\r\nif (!pnetwork)\r\nreturn;\r\nmemcpy((u8 *)pnetwork + 16, (u8 *)pbuf + 8,\r\nsizeof(struct wlan_network) - 16);\r\n} else {\r\npnetwork = (struct wlan_network *)pbuf;\r\n}\r\n#ifdef __BIG_ENDIAN\r\npnetwork->join_res = le32_to_cpu(pnetwork->join_res);\r\npnetwork->network_type = le32_to_cpu(pnetwork->network_type);\r\npnetwork->network.Length = le32_to_cpu(pnetwork->network.Length);\r\npnetwork->network.Ssid.SsidLength =\r\nle32_to_cpu(pnetwork->network.Ssid.SsidLength);\r\npnetwork->network.Privacy = le32_to_cpu(pnetwork->network.Privacy);\r\npnetwork->network.Rssi = le32_to_cpu(pnetwork->network.Rssi);\r\npnetwork->network.NetworkTypeInUse =\r\nle32_to_cpu(pnetwork->network.NetworkTypeInUse);\r\npnetwork->network.Configuration.ATIMWindow =\r\nle32_to_cpu(pnetwork->network.Configuration.ATIMWindow);\r\npnetwork->network.Configuration.BeaconPeriod =\r\nle32_to_cpu(pnetwork->network.Configuration.BeaconPeriod);\r\npnetwork->network.Configuration.DSConfig =\r\nle32_to_cpu(pnetwork->network.Configuration.DSConfig);\r\npnetwork->network.Configuration.FHConfig.DwellTime =\r\nle32_to_cpu(pnetwork->network.Configuration.FHConfig.\r\nDwellTime);\r\npnetwork->network.Configuration.FHConfig.HopPattern =\r\nle32_to_cpu(pnetwork->network.Configuration.\r\nFHConfig.HopPattern);\r\npnetwork->network.Configuration.FHConfig.HopSet =\r\nle32_to_cpu(pnetwork->network.Configuration.FHConfig.HopSet);\r\npnetwork->network.Configuration.FHConfig.Length =\r\nle32_to_cpu(pnetwork->network.Configuration.FHConfig.Length);\r\npnetwork->network.Configuration.Length =\r\nle32_to_cpu(pnetwork->network.Configuration.Length);\r\npnetwork->network.InfrastructureMode =\r\nle32_to_cpu(pnetwork->network.InfrastructureMode);\r\npnetwork->network.IELength = le32_to_cpu(pnetwork->network.IELength);\r\n#endif\r\nthe_same_macaddr = !memcmp(pnetwork->network.MacAddress,\r\ncur_network->network.MacAddress, ETH_ALEN);\r\npnetwork->network.Length =\r\nr8712_get_wlan_bssid_ex_sz(&pnetwork->network);\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL);\r\nif (pnetwork->network.Length > sizeof(struct wlan_bssid_ex))\r\ngoto ignore_joinbss_callback;\r\nif (pnetwork->join_res > 0) {\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nif (the_same_macaddr) {\r\nptarget_wlan =\r\nr8712_find_network(&pmlmepriv->\r\nscanned_queue,\r\ncur_network->network.MacAddress);\r\n} else {\r\npcur_wlan =\r\nr8712_find_network(&pmlmepriv->\r\nscanned_queue,\r\ncur_network->network.MacAddress);\r\npcur_wlan->fixed = false;\r\npcur_sta = r8712_get_stainfo(pstapriv,\r\ncur_network->network.MacAddress);\r\nspin_lock_irqsave(&pstapriv->\r\nsta_hash_lock, irqL2);\r\nr8712_free_stainfo(adapter, pcur_sta);\r\nspin_unlock_irqrestore(&(pstapriv->\r\nsta_hash_lock), irqL2);\r\nptarget_wlan =\r\nr8712_find_network(&pmlmepriv->\r\nscanned_queue,\r\npnetwork->network.\r\nMacAddress);\r\nif (ptarget_wlan)\r\nptarget_wlan->fixed = true;\r\n}\r\n} else {\r\nptarget_wlan = r8712_find_network(&pmlmepriv->\r\nscanned_queue,\r\npnetwork->network.MacAddress);\r\nif (ptarget_wlan)\r\nptarget_wlan->fixed = true;\r\n}\r\nif (ptarget_wlan == NULL) {\r\nif (check_fwstate(pmlmepriv,\r\n_FW_UNDER_LINKING))\r\npmlmepriv->fw_state ^=\r\n_FW_UNDER_LINKING;\r\ngoto ignore_joinbss_callback;\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nif (the_same_macaddr) {\r\nptarget_sta =\r\nr8712_get_stainfo(pstapriv,\r\npnetwork->network.MacAddress);\r\nif (ptarget_sta == NULL)\r\nptarget_sta =\r\nr8712_alloc_stainfo(pstapriv,\r\npnetwork->network.MacAddress);\r\n} else {\r\nptarget_sta =\r\nr8712_alloc_stainfo(pstapriv,\r\npnetwork->network.MacAddress);\r\n}\r\nif (ptarget_sta) {\r\nptarget_sta->aid = pnetwork->join_res;\r\nptarget_sta->qos_option = 1;\r\nptarget_sta->mac_id = 5;\r\nif (adapter->securitypriv.\r\nAuthAlgrthm == 2) {\r\nadapter->securitypriv.\r\nbinstallGrpkey =\r\nfalse;\r\nadapter->securitypriv.\r\nbusetkipkey =\r\nfalse;\r\nadapter->securitypriv.\r\nbgrpkey_handshake =\r\nfalse;\r\nptarget_sta->ieee8021x_blocked\r\n= true;\r\nptarget_sta->XPrivacy =\r\nadapter->securitypriv.\r\nPrivacyAlgrthm;\r\nmemset((u8 *)&ptarget_sta->\r\nx_UncstKey,\r\n0,\r\nsizeof(union Keytype));\r\nmemset((u8 *)&ptarget_sta->\r\ntkiprxmickey,\r\n0,\r\nsizeof(union Keytype));\r\nmemset((u8 *)&ptarget_sta->\r\ntkiptxmickey,\r\n0,\r\nsizeof(union Keytype));\r\nmemset((u8 *)&ptarget_sta->\r\ntxpn, 0,\r\nsizeof(union pn48));\r\nmemset((u8 *)&ptarget_sta->\r\nrxpn, 0,\r\nsizeof(union pn48));\r\n}\r\n} else {\r\nif (check_fwstate(pmlmepriv,\r\n_FW_UNDER_LINKING))\r\npmlmepriv->fw_state ^=\r\n_FW_UNDER_LINKING;\r\ngoto ignore_joinbss_callback;\r\n}\r\n}\r\nmemcpy(&cur_network->network, &pnetwork->network,\r\npnetwork->network.Length);\r\ncur_network->aid = pnetwork->join_res;\r\nswitch (pnetwork->network.InfrastructureMode) {\r\ncase Ndis802_11Infrastructure:\r\npmlmepriv->fw_state = WIFI_STATION_STATE;\r\nbreak;\r\ncase Ndis802_11IBSS:\r\npmlmepriv->fw_state = WIFI_ADHOC_STATE;\r\nbreak;\r\ndefault:\r\npmlmepriv->fw_state = WIFI_NULL_STATE;\r\nbreak;\r\n}\r\nr8712_update_protection(adapter,\r\n(cur_network->network.IEs) +\r\nsizeof(struct NDIS_802_11_FIXED_IEs),\r\n(cur_network->network.IELength));\r\nupdate_ht_cap(adapter, cur_network->network.IEs,\r\ncur_network->network.IELength);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE))\r\nr8712_indicate_connect(adapter);\r\ndel_timer(&pmlmepriv->assoc_timer);\r\n} else {\r\ngoto ignore_joinbss_callback;\r\n}\r\n} else {\r\nif (check_fwstate(pmlmepriv, _FW_UNDER_LINKING)) {\r\nmod_timer(&pmlmepriv->assoc_timer,\r\njiffies + msecs_to_jiffies(1));\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\n}\r\n}\r\nignore_joinbss_callback:\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\r\nif (sizeof(struct list_head) == 4 * sizeof(u32))\r\nkfree(pnetwork);\r\n}\r\nvoid r8712_stassoc_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nunsigned long irqL;\r\nstruct sta_info *psta;\r\nstruct mlme_priv *pmlmepriv = &(adapter->mlmepriv);\r\nstruct stassoc_event *pstassoc = (struct stassoc_event *)pbuf;\r\nif (!r8712_access_ctrl(&adapter->acl_list, pstassoc->macaddr))\r\nreturn;\r\npsta = r8712_get_stainfo(&adapter->stapriv, pstassoc->macaddr);\r\nif (psta != NULL) {\r\nreturn;\r\n}\r\npsta = r8712_alloc_stainfo(&adapter->stapriv, pstassoc->macaddr);\r\nif (psta == NULL)\r\nreturn;\r\npsta->qos_option = 0;\r\npsta->mac_id = le32_to_cpu(pstassoc->cam_id);\r\nif (adapter->securitypriv.AuthAlgrthm == 2)\r\npsta->XPrivacy = adapter->securitypriv.PrivacyAlgrthm;\r\npsta->ieee8021x_blocked = false;\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE) ||\r\ncheck_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\r\nif (adapter->stapriv.asoc_sta_count == 2) {\r\nr8712_indicate_connect(adapter);\r\n}\r\n}\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\r\n}\r\nvoid r8712_stadel_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nunsigned long irqL, irqL2;\r\nstruct sta_info *psta;\r\nstruct wlan_network *pwlan = NULL;\r\nstruct wlan_bssid_ex *pdev_network = NULL;\r\nu8 *pibss = NULL;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct stadel_event *pstadel = (struct stadel_event *)pbuf;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct wlan_network *tgt_network = &pmlmepriv->cur_network;\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL2);\r\nif (check_fwstate(pmlmepriv, WIFI_STATION_STATE)) {\r\nr8712_ind_disconnect(adapter);\r\nr8712_free_assoc_resources(adapter);\r\n}\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE |\r\nWIFI_ADHOC_STATE)) {\r\npsta = r8712_get_stainfo(&adapter->stapriv, pstadel->macaddr);\r\nspin_lock_irqsave(&pstapriv->sta_hash_lock, irqL);\r\nr8712_free_stainfo(adapter, psta);\r\nspin_unlock_irqrestore(&pstapriv->sta_hash_lock, irqL);\r\nif (adapter->stapriv.asoc_sta_count == 1) {\r\npwlan = r8712_find_network(&pmlmepriv->scanned_queue,\r\ntgt_network->network.MacAddress);\r\nif (pwlan) {\r\npwlan->fixed = false;\r\nfree_network_nolock(pmlmepriv, pwlan);\r\n}\r\npdev_network = &(adapter->registrypriv.dev_network);\r\npibss = adapter->registrypriv.dev_network.MacAddress;\r\nmemcpy(pdev_network, &tgt_network->network,\r\nr8712_get_wlan_bssid_ex_sz(&tgt_network->\r\nnetwork));\r\nmemcpy(&pdev_network->Ssid,\r\n&pmlmepriv->assoc_ssid,\r\nsizeof(struct ndis_802_11_ssid));\r\nr8712_update_registrypriv_dev_network(adapter);\r\nr8712_generate_random_ibss(pibss);\r\nif (check_fwstate(pmlmepriv, WIFI_ADHOC_STATE)) {\r\n_clr_fwstate_(pmlmepriv, WIFI_ADHOC_STATE);\r\nset_fwstate(pmlmepriv, WIFI_ADHOC_MASTER_STATE);\r\n}\r\n}\r\n}\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL2);\r\n}\r\nvoid r8712_cpwm_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nstruct reportpwrstate_parm *preportpwrstate =\r\n(struct reportpwrstate_parm *)pbuf;\r\npreportpwrstate->state |= (u8)(adapter->pwrctrlpriv.cpwm_tog + 0x80);\r\nr8712_cpwm_int_hdl(adapter, preportpwrstate);\r\n}\r\nvoid r8712_got_addbareq_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nstruct ADDBA_Req_Report_parm *pAddbareq_pram =\r\n(struct ADDBA_Req_Report_parm *)pbuf;\r\nstruct sta_info *psta;\r\nstruct sta_priv *pstapriv = &adapter->stapriv;\r\nstruct recv_reorder_ctrl *precvreorder_ctrl = NULL;\r\npsta = r8712_get_stainfo(pstapriv, pAddbareq_pram->MacAddress);\r\nif (psta) {\r\nprecvreorder_ctrl =\r\n&psta->recvreorder_ctrl[pAddbareq_pram->tid];\r\nprecvreorder_ctrl->indicate_seq = 0xffff;\r\n}\r\n}\r\nvoid r8712_wpspbc_event_callback(struct _adapter *adapter, u8 *pbuf)\r\n{\r\nif (!adapter->securitypriv.wps_hw_pbc_pressed)\r\nadapter->securitypriv.wps_hw_pbc_pressed = true;\r\n}\r\nvoid _r8712_sitesurvey_ctrl_handler(struct _adapter *adapter)\r\n{\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct sitesurvey_ctrl *psitesurveyctrl = &pmlmepriv->sitesurveyctrl;\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nu64 current_tx_pkts;\r\nuint current_rx_pkts;\r\ncurrent_tx_pkts = (adapter->xmitpriv.tx_pkts) -\r\n(psitesurveyctrl->last_tx_pkts);\r\ncurrent_rx_pkts = (adapter->recvpriv.rx_pkts) -\r\n(psitesurveyctrl->last_rx_pkts);\r\npsitesurveyctrl->last_tx_pkts = adapter->xmitpriv.tx_pkts;\r\npsitesurveyctrl->last_rx_pkts = adapter->recvpriv.rx_pkts;\r\nif ((current_tx_pkts > pregistrypriv->busy_thresh) ||\r\n(current_rx_pkts > pregistrypriv->busy_thresh))\r\npsitesurveyctrl->traffic_busy = true;\r\nelse\r\npsitesurveyctrl->traffic_busy = false;\r\n}\r\nvoid _r8712_join_timeout_handler(struct _adapter *adapter)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\r\nreturn;\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_LINKING);\r\npmlmepriv->to_join = false;\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nr8712_os_indicate_disconnect(adapter);\r\n_clr_fwstate_(pmlmepriv, _FW_LINKED);\r\n}\r\nif (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt) {\r\nr8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,\r\nadapter->registrypriv.smart_ps);\r\n}\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\r\n}\r\nvoid r8712_scan_timeout_handler (struct _adapter *adapter)\r\n{\r\nunsigned long irqL;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nspin_lock_irqsave(&pmlmepriv->lock, irqL);\r\n_clr_fwstate_(pmlmepriv, _FW_UNDER_SURVEY);\r\npmlmepriv->to_join = false;\r\nspin_unlock_irqrestore(&pmlmepriv->lock, irqL);\r\n}\r\nvoid _r8712_dhcp_timeout_handler (struct _adapter *adapter)\r\n{\r\nif (adapter->bDriverStopped || adapter->bSurpriseRemoved)\r\nreturn;\r\nif (adapter->pwrctrlpriv.pwr_mode != adapter->registrypriv.power_mgnt)\r\nr8712_set_ps_mode(adapter, adapter->registrypriv.power_mgnt,\r\nadapter->registrypriv.smart_ps);\r\n}\r\nvoid _r8712_wdg_timeout_handler(struct _adapter *adapter)\r\n{\r\nr8712_wdg_wk_cmd(adapter);\r\n}\r\nint r8712_select_and_join_from_scan(struct mlme_priv *pmlmepriv)\r\n{\r\nstruct list_head *phead;\r\nunsigned char *dst_ssid, *src_ssid;\r\nstruct _adapter *adapter;\r\nstruct __queue *queue = NULL;\r\nstruct wlan_network *pnetwork = NULL;\r\nstruct wlan_network *pnetwork_max_rssi = NULL;\r\nadapter = (struct _adapter *)pmlmepriv->nic_hdl;\r\nqueue = &pmlmepriv->scanned_queue;\r\nphead = &queue->queue;\r\npmlmepriv->pscanned = phead->next;\r\nwhile (1) {\r\nif (end_of_queue_search(phead, pmlmepriv->pscanned)) {\r\nif ((pmlmepriv->assoc_by_rssi) &&\r\n(pnetwork_max_rssi != NULL)) {\r\npnetwork = pnetwork_max_rssi;\r\ngoto ask_for_joinbss;\r\n}\r\nreturn _FAIL;\r\n}\r\npnetwork = container_of(pmlmepriv->pscanned,\r\nstruct wlan_network, list);\r\nif (pnetwork == NULL)\r\nreturn _FAIL;\r\npmlmepriv->pscanned = pmlmepriv->pscanned->next;\r\nif (pmlmepriv->assoc_by_bssid) {\r\ndst_ssid = pnetwork->network.MacAddress;\r\nsrc_ssid = pmlmepriv->assoc_bssid;\r\nif (!memcmp(dst_ssid, src_ssid, ETH_ALEN)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nif (is_same_network(&pmlmepriv->\r\ncur_network.network,\r\n&pnetwork->network)) {\r\n_clr_fwstate_(pmlmepriv,\r\n_FW_UNDER_LINKING);\r\nr8712_indicate_connect(adapter);\r\nreturn 2;\r\n}\r\nr8712_disassoc_cmd(adapter);\r\nr8712_ind_disconnect(adapter);\r\nr8712_free_assoc_resources(adapter);\r\n}\r\ngoto ask_for_joinbss;\r\n}\r\n} else if (pmlmepriv->assoc_ssid.SsidLength == 0) {\r\ngoto ask_for_joinbss;\r\n}\r\ndst_ssid = pnetwork->network.Ssid.Ssid;\r\nsrc_ssid = pmlmepriv->assoc_ssid.Ssid;\r\nif ((pnetwork->network.Ssid.SsidLength ==\r\npmlmepriv->assoc_ssid.SsidLength) &&\r\n(!memcmp(dst_ssid, src_ssid,\r\npmlmepriv->assoc_ssid.SsidLength))) {\r\nif (pmlmepriv->assoc_by_rssi) {\r\nif (pnetwork_max_rssi) {\r\nif (pnetwork->network.Rssi >\r\npnetwork_max_rssi->network.Rssi)\r\npnetwork_max_rssi = pnetwork;\r\n} else {\r\npnetwork_max_rssi = pnetwork;\r\n}\r\n} else if (is_desired_network(adapter, pnetwork)) {\r\nif (check_fwstate(pmlmepriv, _FW_LINKED)) {\r\nr8712_disassoc_cmd(adapter);\r\nr8712_free_assoc_resources(adapter);\r\n}\r\ngoto ask_for_joinbss;\r\n}\r\n}\r\n}\r\nask_for_joinbss:\r\nreturn r8712_joinbss_cmd(adapter, pnetwork);\r\n}\r\nsint r8712_set_auth(struct _adapter *adapter,\r\nstruct security_priv *psecuritypriv)\r\n{\r\nstruct cmd_priv *pcmdpriv = &adapter->cmdpriv;\r\nstruct cmd_obj *pcmd;\r\nstruct setauth_parm *psetauthparm;\r\npcmd = kmalloc(sizeof(*pcmd), GFP_ATOMIC);\r\nif (!pcmd)\r\nreturn _FAIL;\r\npsetauthparm = kzalloc(sizeof(*psetauthparm), GFP_ATOMIC);\r\nif (!psetauthparm) {\r\nkfree(pcmd);\r\nreturn _FAIL;\r\n}\r\npsetauthparm->mode = (u8)psecuritypriv->AuthAlgrthm;\r\npcmd->cmdcode = _SetAuth_CMD_;\r\npcmd->parmbuf = (unsigned char *)psetauthparm;\r\npcmd->cmdsz = sizeof(struct setauth_parm);\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nr8712_enqueue_cmd(pcmdpriv, pcmd);\r\nreturn _SUCCESS;\r\n}\r\nsint r8712_set_key(struct _adapter *adapter,\r\nstruct security_priv *psecuritypriv,\r\nsint keyid)\r\n{\r\nstruct cmd_priv *pcmdpriv = &adapter->cmdpriv;\r\nstruct cmd_obj *pcmd;\r\nstruct setkey_parm *psetkeyparm;\r\nu8 keylen;\r\nsint ret = _SUCCESS;\r\npcmd = kmalloc(sizeof(*pcmd), GFP_ATOMIC);\r\nif (!pcmd)\r\nreturn _FAIL;\r\npsetkeyparm = kzalloc(sizeof(*psetkeyparm), GFP_ATOMIC);\r\nif (!psetkeyparm) {\r\nret = _FAIL;\r\ngoto err_free_cmd;\r\n}\r\nif (psecuritypriv->AuthAlgrthm == 2) {\r\npsetkeyparm->algorithm =\r\n(u8)psecuritypriv->XGrpPrivacy;\r\n} else {\r\npsetkeyparm->algorithm =\r\n(u8)psecuritypriv->PrivacyAlgrthm;\r\n}\r\npsetkeyparm->keyid = (u8)keyid;\r\nswitch (psetkeyparm->algorithm) {\r\ncase _WEP40_:\r\nkeylen = 5;\r\nmemcpy(psetkeyparm->key,\r\npsecuritypriv->DefKey[keyid].skey, keylen);\r\nbreak;\r\ncase _WEP104_:\r\nkeylen = 13;\r\nmemcpy(psetkeyparm->key,\r\npsecuritypriv->DefKey[keyid].skey, keylen);\r\nbreak;\r\ncase _TKIP_:\r\nif (keyid < 1 || keyid > 2) {\r\nret = _FAIL;\r\ngoto err_free_parm;\r\n}\r\nkeylen = 16;\r\nmemcpy(psetkeyparm->key,\r\n&psecuritypriv->XGrpKey[keyid - 1], keylen);\r\npsetkeyparm->grpkey = 1;\r\nbreak;\r\ncase _AES_:\r\nif (keyid < 1 || keyid > 2) {\r\nret = _FAIL;\r\ngoto err_free_parm;\r\n}\r\nkeylen = 16;\r\nmemcpy(psetkeyparm->key,\r\n&psecuritypriv->XGrpKey[keyid - 1], keylen);\r\npsetkeyparm->grpkey = 1;\r\nbreak;\r\ndefault:\r\nret = _FAIL;\r\ngoto err_free_parm;\r\n}\r\npcmd->cmdcode = _SetKey_CMD_;\r\npcmd->parmbuf = (u8 *)psetkeyparm;\r\npcmd->cmdsz = (sizeof(struct setkey_parm));\r\npcmd->rsp = NULL;\r\npcmd->rspsz = 0;\r\nINIT_LIST_HEAD(&pcmd->list);\r\nr8712_enqueue_cmd(pcmdpriv, pcmd);\r\nreturn ret;\r\nerr_free_parm:\r\nkfree(psetkeyparm);\r\nerr_free_cmd:\r\nkfree(pcmd);\r\nreturn ret;\r\n}\r\nint r8712_restruct_wmm_ie(struct _adapter *adapter, u8 *in_ie, u8 *out_ie,\r\nuint in_len, uint initial_out_len)\r\n{\r\nunsigned int ielength = 0;\r\nunsigned int i, j;\r\ni = 12;\r\nwhile (i < in_len) {\r\nielength = initial_out_len;\r\nif (in_ie[i] == 0xDD && in_ie[i + 2] == 0x00 &&\r\nin_ie[i + 3] == 0x50 && in_ie[i + 4] == 0xF2 &&\r\nin_ie[i + 5] == 0x02 && i + 5 < in_len) {\r\nfor (j = i; j < i + 9; j++) {\r\nout_ie[ielength] = in_ie[j];\r\nielength++;\r\n}\r\nout_ie[initial_out_len + 1] = 0x07;\r\nout_ie[initial_out_len + 6] = 0x00;\r\nout_ie[initial_out_len + 8] = 0x00;\r\nbreak;\r\n}\r\ni += (in_ie[i + 1] + 2);\r\n}\r\nreturn ielength;\r\n}\r\nstatic int SecIsInPMKIDList(struct _adapter *Adapter, u8 *bssid)\r\n{\r\nstruct security_priv *psecuritypriv = &Adapter->securitypriv;\r\nint i = 0;\r\ndo {\r\nif (psecuritypriv->PMKIDList[i].bUsed &&\r\n(!memcmp(psecuritypriv->PMKIDList[i].Bssid,\r\nbssid, ETH_ALEN)))\r\nbreak;\r\ni++;\r\n} while (i < NUM_PMKID_CACHE);\r\nif (i == NUM_PMKID_CACHE) {\r\ni = -1;\r\n} else {\r\n;\r\n}\r\nreturn i;\r\n}\r\nsint r8712_restruct_sec_ie(struct _adapter *adapter, u8 *in_ie,\r\nu8 *out_ie, uint in_len)\r\n{\r\nu8 authmode = 0, match;\r\nu8 sec_ie[255], uncst_oui[4], bkup_ie[255];\r\nu8 wpa_oui[4] = {0x0, 0x50, 0xf2, 0x01};\r\nuint ielength, cnt, remove_cnt;\r\nint iEntry;\r\nstruct mlme_priv *pmlmepriv = &adapter->mlmepriv;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nuint ndisauthmode = psecuritypriv->ndisauthtype;\r\nuint ndissecuritytype = psecuritypriv->ndisencryptstatus;\r\nif ((ndisauthmode == Ndis802_11AuthModeWPA) ||\r\n(ndisauthmode == Ndis802_11AuthModeWPAPSK)) {\r\nauthmode = _WPA_IE_ID_;\r\nuncst_oui[0] = 0x0;\r\nuncst_oui[1] = 0x50;\r\nuncst_oui[2] = 0xf2;\r\n}\r\nif ((ndisauthmode == Ndis802_11AuthModeWPA2) ||\r\n(ndisauthmode == Ndis802_11AuthModeWPA2PSK)) {\r\nauthmode = _WPA2_IE_ID_;\r\nuncst_oui[0] = 0x0;\r\nuncst_oui[1] = 0x0f;\r\nuncst_oui[2] = 0xac;\r\n}\r\nswitch (ndissecuritytype) {\r\ncase Ndis802_11Encryption1Enabled:\r\ncase Ndis802_11Encryption1KeyAbsent:\r\nuncst_oui[3] = 0x1;\r\nbreak;\r\ncase Ndis802_11Encryption2Enabled:\r\ncase Ndis802_11Encryption2KeyAbsent:\r\nuncst_oui[3] = 0x2;\r\nbreak;\r\ncase Ndis802_11Encryption3Enabled:\r\ncase Ndis802_11Encryption3KeyAbsent:\r\nuncst_oui[3] = 0x4;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ncnt = 12;\r\nmatch = false;\r\nwhile (cnt < in_len) {\r\nif (in_ie[cnt] == authmode) {\r\nif ((authmode == _WPA_IE_ID_) &&\r\n(!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) {\r\nmemcpy(&sec_ie[0], &in_ie[cnt],\r\nin_ie[cnt + 1] + 2);\r\nmatch = true;\r\nbreak;\r\n}\r\nif (authmode == _WPA2_IE_ID_) {\r\nmemcpy(&sec_ie[0], &in_ie[cnt],\r\nin_ie[cnt + 1] + 2);\r\nmatch = true;\r\nbreak;\r\n}\r\nif (((authmode == _WPA_IE_ID_) &&\r\n(!memcmp(&in_ie[cnt + 2], &wpa_oui[0], 4))) ||\r\n(authmode == _WPA2_IE_ID_))\r\nmemcpy(&bkup_ie[0], &in_ie[cnt],\r\nin_ie[cnt + 1] + 2);\r\n}\r\ncnt += in_ie[cnt + 1] + 2;\r\n}\r\nif (match) {\r\nif (sec_ie[0] == _WPA_IE_ID_) {\r\nwhile (true) {\r\nif (memcmp(&sec_ie[2], &wpa_oui[0], 4)) {\r\nmatch = false;\r\nbreak;\r\n}\r\nif ((sec_ie[6] != 0x01) || (sec_ie[7] != 0x0)) {\r\nmatch = false;\r\nbreak;\r\n}\r\nif (!memcmp(&sec_ie[8], &wpa_oui[0], 3)) {\r\nswitch (sec_ie[11]) {\r\ncase 0x0:\r\npsecuritypriv->XGrpPrivacy =\r\n_NO_PRIVACY_;\r\nbreak;\r\ncase 0x1:\r\npsecuritypriv->XGrpPrivacy =\r\n_WEP40_;\r\nbreak;\r\ncase 0x2:\r\npsecuritypriv->XGrpPrivacy =\r\n_TKIP_;\r\nbreak;\r\ncase 0x3:\r\ncase 0x4:\r\npsecuritypriv->XGrpPrivacy =\r\n_AES_;\r\nbreak;\r\ncase 0x5:\r\npsecuritypriv->XGrpPrivacy =\r\n_WEP104_;\r\nbreak;\r\n}\r\n} else {\r\nmatch = false;\r\nbreak;\r\n}\r\nif (sec_ie[12] == 0x01) {\r\nif (memcmp(&sec_ie[14],\r\n&uncst_oui[0], 4)) {\r\nmatch = false;\r\nbreak;\r\n}\r\n} else {\r\ncnt = sec_ie[12];\r\nremove_cnt = (cnt - 1) * 4;\r\nsec_ie[12] = 0x01;\r\nmemcpy(&sec_ie[14], &uncst_oui[0], 4);\r\nmemcpy(&sec_ie[18],\r\n&sec_ie[18 + remove_cnt],\r\nsec_ie[1] - 18 + 2 -\r\nremove_cnt);\r\nsec_ie[1] = sec_ie[1] - remove_cnt;\r\n}\r\nbreak;\r\n}\r\n}\r\nif (authmode == _WPA2_IE_ID_) {\r\nwhile (true) {\r\nif ((sec_ie[2] != 0x01) || (sec_ie[3] != 0x0)) {\r\nmatch = false;\r\nbreak;\r\n}\r\nif (!memcmp(&sec_ie[4], &uncst_oui[0], 3)) {\r\nswitch (sec_ie[7]) {\r\ncase 0x1:\r\npsecuritypriv->XGrpPrivacy =\r\n_WEP40_;\r\nbreak;\r\ncase 0x2:\r\npsecuritypriv->XGrpPrivacy =\r\n_TKIP_;\r\nbreak;\r\ncase 0x4:\r\npsecuritypriv->XGrpPrivacy =\r\n_AES_;\r\nbreak;\r\ncase 0x5:\r\npsecuritypriv->XGrpPrivacy =\r\n_WEP104_;\r\nbreak;\r\ndefault:\r\npsecuritypriv->XGrpPrivacy =\r\n_NO_PRIVACY_;\r\nbreak;\r\n}\r\n} else {\r\nmatch = false;\r\nbreak;\r\n}\r\nif (sec_ie[8] == 0x01) {\r\nif (memcmp(&sec_ie[10],\r\n&uncst_oui[0], 4)) {\r\nmatch = false;\r\nbreak;\r\n}\r\n} else {\r\ncnt = sec_ie[8];\r\nremove_cnt = (cnt - 1) * 4;\r\nsec_ie[8] = 0x01;\r\nmemcpy(&sec_ie[10], &uncst_oui[0], 4);\r\nmemcpy(&sec_ie[14],\r\n&sec_ie[14 + remove_cnt],\r\n(sec_ie[1] - 14 + 2 -\r\nremove_cnt));\r\nsec_ie[1] = sec_ie[1] - remove_cnt;\r\n}\r\nbreak;\r\n}\r\n}\r\n}\r\nif ((authmode == _WPA_IE_ID_) || (authmode == _WPA2_IE_ID_)) {\r\nmemcpy(out_ie, in_ie, 12);\r\nielength = 12;\r\nif (match) {\r\nmemcpy(&out_ie[ielength], &sec_ie[0], sec_ie[1] + 2);\r\nielength += sec_ie[1] + 2;\r\nif (authmode == _WPA2_IE_ID_) {\r\nout_ie[ielength - 1] = 0;\r\nout_ie[ielength - 2] = 0;\r\n}\r\nr8712_report_sec_ie(adapter, authmode, sec_ie);\r\n}\r\n} else {\r\nmemcpy(out_ie, in_ie, 12);\r\nielength = 12;\r\nif (psecuritypriv->wps_phase) {\r\nmemcpy(out_ie + ielength, psecuritypriv->wps_ie,\r\npsecuritypriv->wps_ie_len);\r\nielength += psecuritypriv->wps_ie_len;\r\n}\r\n}\r\niEntry = SecIsInPMKIDList(adapter, pmlmepriv->assoc_bssid);\r\nif (iEntry < 0)\r\nreturn ielength;\r\nif (authmode == _WPA2_IE_ID_) {\r\nout_ie[ielength] = 1;\r\nielength++;\r\nout_ie[ielength] = 0;\r\nielength++;\r\nmemcpy(&out_ie[ielength],\r\n&psecuritypriv->PMKIDList[iEntry].PMKID, 16);\r\nielength += 16;\r\nout_ie[13] += 18;\r\n}\r\nreturn ielength;\r\n}\r\nvoid r8712_init_registrypriv_dev_network(struct _adapter *adapter)\r\n{\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct eeprom_priv *peepriv = &adapter->eeprompriv;\r\nstruct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;\r\nu8 *myhwaddr = myid(peepriv);\r\nmemcpy(pdev_network->MacAddress, myhwaddr, ETH_ALEN);\r\nmemcpy(&pdev_network->Ssid, &pregistrypriv->ssid,\r\nsizeof(struct ndis_802_11_ssid));\r\npdev_network->Configuration.Length =\r\nsizeof(struct NDIS_802_11_CONFIGURATION);\r\npdev_network->Configuration.BeaconPeriod = 100;\r\npdev_network->Configuration.FHConfig.Length = 0;\r\npdev_network->Configuration.FHConfig.HopPattern = 0;\r\npdev_network->Configuration.FHConfig.HopSet = 0;\r\npdev_network->Configuration.FHConfig.DwellTime = 0;\r\n}\r\nvoid r8712_update_registrypriv_dev_network(struct _adapter *adapter)\r\n{\r\nint sz = 0;\r\nstruct registry_priv *pregistrypriv = &adapter->registrypriv;\r\nstruct wlan_bssid_ex *pdev_network = &pregistrypriv->dev_network;\r\nstruct security_priv *psecuritypriv = &adapter->securitypriv;\r\nstruct wlan_network *cur_network = &adapter->mlmepriv.cur_network;\r\npdev_network->Privacy = cpu_to_le32(psecuritypriv->PrivacyAlgrthm\r\n> 0 ? 1 : 0);\r\npdev_network->Rssi = 0;\r\nswitch (pregistrypriv->wireless_mode) {\r\ncase WIRELESS_11B:\r\npdev_network->NetworkTypeInUse = Ndis802_11DS;\r\nbreak;\r\ncase WIRELESS_11G:\r\ncase WIRELESS_11BG:\r\npdev_network->NetworkTypeInUse = Ndis802_11OFDM24;\r\nbreak;\r\ncase WIRELESS_11A:\r\npdev_network->NetworkTypeInUse = Ndis802_11OFDM5;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\npdev_network->Configuration.DSConfig = pregistrypriv->channel;\r\nif (cur_network->network.InfrastructureMode == Ndis802_11IBSS)\r\npdev_network->Configuration.ATIMWindow = 3;\r\npdev_network->InfrastructureMode = cur_network->network.InfrastructureMode;\r\nsz = r8712_generate_ie(pregistrypriv);\r\npdev_network->IELength = sz;\r\npdev_network->Length = r8712_get_wlan_bssid_ex_sz(pdev_network);\r\n}\r\nvoid r8712_joinbss_reset(struct _adapter *padapter)\r\n{\r\nint i;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nphtpriv->ampdu_enable = false;\r\nfor (i = 0; i < 16; i++)\r\nphtpriv->baddbareq_issued[i] = false;\r\nif (phtpriv->ht_option) {\r\nr8712_write8(padapter, 0x102500D9, 48);\r\n} else {\r\nr8712_write8(padapter, 0x102500D9, 1);\r\n}\r\n}\r\nunsigned int r8712_restructure_ht_ie(struct _adapter *padapter, u8 *in_ie,\r\nu8 *out_ie, uint in_len, uint *pout_len)\r\n{\r\nu32 ielen, out_len;\r\nunsigned char *p;\r\nstruct ieee80211_ht_cap ht_capie;\r\nunsigned char WMM_IE[] = {0x00, 0x50, 0xf2, 0x02, 0x00, 0x01, 0x00};\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct qos_priv *pqospriv = &pmlmepriv->qospriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nphtpriv->ht_option = 0;\r\np = r8712_get_ie(in_ie + 12, _HT_CAPABILITY_IE_, &ielen, in_len - 12);\r\nif (p && (ielen > 0)) {\r\nif (pqospriv->qos_option == 0) {\r\nout_len = *pout_len;\r\nr8712_set_ie(out_ie + out_len, _VENDOR_SPECIFIC_IE_,\r\n_WMM_IE_Length_, WMM_IE, pout_len);\r\npqospriv->qos_option = 1;\r\n}\r\nout_len = *pout_len;\r\nmemset(&ht_capie, 0, sizeof(struct ieee80211_ht_cap));\r\nht_capie.cap_info = cpu_to_le16(IEEE80211_HT_CAP_SUP_WIDTH |\r\nIEEE80211_HT_CAP_SGI_20 |\r\nIEEE80211_HT_CAP_SGI_40 |\r\nIEEE80211_HT_CAP_TX_STBC |\r\nIEEE80211_HT_CAP_MAX_AMSDU |\r\nIEEE80211_HT_CAP_DSSSCCK40);\r\nht_capie.ampdu_params_info = (IEEE80211_HT_CAP_AMPDU_FACTOR &\r\n0x03) | (IEEE80211_HT_CAP_AMPDU_DENSITY & 0x00);\r\nr8712_set_ie(out_ie + out_len, _HT_CAPABILITY_IE_,\r\nsizeof(struct ieee80211_ht_cap),\r\n(unsigned char *)&ht_capie, pout_len);\r\nphtpriv->ht_option = 1;\r\n}\r\nreturn phtpriv->ht_option;\r\n}\r\nstatic void update_ht_cap(struct _adapter *padapter, u8 *pie, uint ie_len)\r\n{\r\nu8 *p, max_ampdu_sz;\r\nint i, len;\r\nstruct sta_info *bmc_sta, *psta;\r\nstruct ieee80211_ht_cap *pht_capie;\r\nstruct recv_reorder_ctrl *preorder_ctrl;\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nstruct registry_priv *pregistrypriv = &padapter->registrypriv;\r\nstruct wlan_network *pcur_network = &(pmlmepriv->cur_network);\r\nif (!phtpriv->ht_option)\r\nreturn;\r\nif (!phtpriv->ampdu_enable &&\r\n(pregistrypriv->ampdu_enable == 1))\r\nphtpriv->ampdu_enable = true;\r\nlen = 0;\r\np = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),\r\n_HT_CAPABILITY_IE_,\r\n&len, ie_len -\r\nsizeof(struct NDIS_802_11_FIXED_IEs));\r\nif (p && len > 0) {\r\npht_capie = (struct ieee80211_ht_cap *)(p + 2);\r\nmax_ampdu_sz = (pht_capie->ampdu_params_info &\r\nIEEE80211_HT_CAP_AMPDU_FACTOR);\r\nmax_ampdu_sz = 1 << (max_ampdu_sz + 3);\r\nphtpriv->rx_ampdu_maxlen = max_ampdu_sz;\r\n}\r\nbmc_sta = r8712_get_bcmc_stainfo(padapter);\r\nif (bmc_sta) {\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &bmc_sta->recvreorder_ctrl[i];\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\n}\r\n}\r\npsta = r8712_get_stainfo(&padapter->stapriv,\r\npcur_network->network.MacAddress);\r\nif (psta) {\r\nfor (i = 0; i < 16; i++) {\r\npreorder_ctrl = &psta->recvreorder_ctrl[i];\r\npreorder_ctrl->indicate_seq = 0xffff;\r\npreorder_ctrl->wend_b = 0xffff;\r\n}\r\n}\r\nlen = 0;\r\np = r8712_get_ie(pie + sizeof(struct NDIS_802_11_FIXED_IEs),\r\n_HT_ADD_INFO_IE_, &len,\r\nie_len - sizeof(struct NDIS_802_11_FIXED_IEs));\r\n}\r\nvoid r8712_issue_addbareq_cmd(struct _adapter *padapter, int priority)\r\n{\r\nstruct mlme_priv *pmlmepriv = &padapter->mlmepriv;\r\nstruct ht_priv *phtpriv = &pmlmepriv->htpriv;\r\nif ((phtpriv->ht_option == 1) && (phtpriv->ampdu_enable)) {\r\nif (!phtpriv->baddbareq_issued[priority]) {\r\nr8712_addbareq_cmd(padapter, (u8)priority);\r\nphtpriv->baddbareq_issued[priority] = true;\r\n}\r\n}\r\n}
