static void\r\nqca8k_split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)\r\n{\r\nregaddr >>= 1;\r\n*r1 = regaddr & 0x1e;\r\nregaddr >>= 5;\r\n*r2 = regaddr & 0x7;\r\nregaddr >>= 3;\r\n*page = regaddr & 0x3ff;\r\n}\r\nstatic u32\r\nqca8k_mii_read32(struct mii_bus *bus, int phy_id, u32 regnum)\r\n{\r\nu32 val;\r\nint ret;\r\nret = bus->read(bus, phy_id, regnum);\r\nif (ret >= 0) {\r\nval = ret;\r\nret = bus->read(bus, phy_id, regnum + 1);\r\nval |= ret << 16;\r\n}\r\nif (ret < 0) {\r\ndev_err_ratelimited(&bus->dev,\r\n"failed to read qca8k 32bit register\n");\r\nreturn ret;\r\n}\r\nreturn val;\r\n}\r\nstatic void\r\nqca8k_mii_write32(struct mii_bus *bus, int phy_id, u32 regnum, u32 val)\r\n{\r\nu16 lo, hi;\r\nint ret;\r\nlo = val & 0xffff;\r\nhi = (u16)(val >> 16);\r\nret = bus->write(bus, phy_id, regnum, lo);\r\nif (ret >= 0)\r\nret = bus->write(bus, phy_id, regnum + 1, hi);\r\nif (ret < 0)\r\ndev_err_ratelimited(&bus->dev,\r\n"failed to write qca8k 32bit register\n");\r\n}\r\nstatic void\r\nqca8k_set_page(struct mii_bus *bus, u16 page)\r\n{\r\nif (page == qca8k_current_page)\r\nreturn;\r\nif (bus->write(bus, 0x18, 0, page) < 0)\r\ndev_err_ratelimited(&bus->dev,\r\n"failed to set qca8k page\n");\r\nqca8k_current_page = page;\r\n}\r\nstatic u32\r\nqca8k_read(struct qca8k_priv *priv, u32 reg)\r\n{\r\nu16 r1, r2, page;\r\nu32 val;\r\nqca8k_split_addr(reg, &r1, &r2, &page);\r\nmutex_lock_nested(&priv->bus->mdio_lock, MDIO_MUTEX_NESTED);\r\nqca8k_set_page(priv->bus, page);\r\nval = qca8k_mii_read32(priv->bus, 0x10 | r2, r1);\r\nmutex_unlock(&priv->bus->mdio_lock);\r\nreturn val;\r\n}\r\nstatic void\r\nqca8k_write(struct qca8k_priv *priv, u32 reg, u32 val)\r\n{\r\nu16 r1, r2, page;\r\nqca8k_split_addr(reg, &r1, &r2, &page);\r\nmutex_lock_nested(&priv->bus->mdio_lock, MDIO_MUTEX_NESTED);\r\nqca8k_set_page(priv->bus, page);\r\nqca8k_mii_write32(priv->bus, 0x10 | r2, r1, val);\r\nmutex_unlock(&priv->bus->mdio_lock);\r\n}\r\nstatic u32\r\nqca8k_rmw(struct qca8k_priv *priv, u32 reg, u32 mask, u32 val)\r\n{\r\nu16 r1, r2, page;\r\nu32 ret;\r\nqca8k_split_addr(reg, &r1, &r2, &page);\r\nmutex_lock_nested(&priv->bus->mdio_lock, MDIO_MUTEX_NESTED);\r\nqca8k_set_page(priv->bus, page);\r\nret = qca8k_mii_read32(priv->bus, 0x10 | r2, r1);\r\nret &= ~mask;\r\nret |= val;\r\nqca8k_mii_write32(priv->bus, 0x10 | r2, r1, ret);\r\nmutex_unlock(&priv->bus->mdio_lock);\r\nreturn ret;\r\n}\r\nstatic void\r\nqca8k_reg_set(struct qca8k_priv *priv, u32 reg, u32 val)\r\n{\r\nqca8k_rmw(priv, reg, 0, val);\r\n}\r\nstatic void\r\nqca8k_reg_clear(struct qca8k_priv *priv, u32 reg, u32 val)\r\n{\r\nqca8k_rmw(priv, reg, val, 0);\r\n}\r\nstatic int\r\nqca8k_regmap_read(void *ctx, uint32_t reg, uint32_t *val)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ctx;\r\n*val = qca8k_read(priv, reg);\r\nreturn 0;\r\n}\r\nstatic int\r\nqca8k_regmap_write(void *ctx, uint32_t reg, uint32_t val)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ctx;\r\nqca8k_write(priv, reg, val);\r\nreturn 0;\r\n}\r\nstatic int\r\nqca8k_busy_wait(struct qca8k_priv *priv, u32 reg, u32 mask)\r\n{\r\nunsigned long timeout;\r\ntimeout = jiffies + msecs_to_jiffies(20);\r\ndo {\r\nu32 val = qca8k_read(priv, reg);\r\nint busy = val & mask;\r\nif (!busy)\r\nbreak;\r\ncond_resched();\r\n} while (!time_after_eq(jiffies, timeout));\r\nreturn time_after_eq(jiffies, timeout);\r\n}\r\nstatic void\r\nqca8k_fdb_read(struct qca8k_priv *priv, struct qca8k_fdb *fdb)\r\n{\r\nu32 reg[4];\r\nint i;\r\nfor (i = 0; i < 4; i++)\r\nreg[i] = qca8k_read(priv, QCA8K_REG_ATU_DATA0 + (i * 4));\r\nfdb->vid = (reg[2] >> QCA8K_ATU_VID_S) & QCA8K_ATU_VID_M;\r\nfdb->aging = reg[2] & QCA8K_ATU_STATUS_M;\r\nfdb->port_mask = (reg[1] >> QCA8K_ATU_PORT_S) & QCA8K_ATU_PORT_M;\r\nfdb->mac[0] = (reg[1] >> QCA8K_ATU_ADDR0_S) & 0xff;\r\nfdb->mac[1] = reg[1] & 0xff;\r\nfdb->mac[2] = (reg[0] >> QCA8K_ATU_ADDR2_S) & 0xff;\r\nfdb->mac[3] = (reg[0] >> QCA8K_ATU_ADDR3_S) & 0xff;\r\nfdb->mac[4] = (reg[0] >> QCA8K_ATU_ADDR4_S) & 0xff;\r\nfdb->mac[5] = reg[0] & 0xff;\r\n}\r\nstatic void\r\nqca8k_fdb_write(struct qca8k_priv *priv, u16 vid, u8 port_mask, const u8 *mac,\r\nu8 aging)\r\n{\r\nu32 reg[3] = { 0 };\r\nint i;\r\nreg[2] = (vid & QCA8K_ATU_VID_M) << QCA8K_ATU_VID_S;\r\nreg[2] |= aging & QCA8K_ATU_STATUS_M;\r\nreg[1] = (port_mask & QCA8K_ATU_PORT_M) << QCA8K_ATU_PORT_S;\r\nreg[1] |= mac[0] << QCA8K_ATU_ADDR0_S;\r\nreg[1] |= mac[1];\r\nreg[0] |= mac[2] << QCA8K_ATU_ADDR2_S;\r\nreg[0] |= mac[3] << QCA8K_ATU_ADDR3_S;\r\nreg[0] |= mac[4] << QCA8K_ATU_ADDR4_S;\r\nreg[0] |= mac[5];\r\nfor (i = 0; i < 3; i++)\r\nqca8k_write(priv, QCA8K_REG_ATU_DATA0 + (i * 4), reg[i]);\r\n}\r\nstatic int\r\nqca8k_fdb_access(struct qca8k_priv *priv, enum qca8k_fdb_cmd cmd, int port)\r\n{\r\nu32 reg;\r\nreg = QCA8K_ATU_FUNC_BUSY;\r\nreg |= cmd;\r\nif (port >= 0) {\r\nreg |= QCA8K_ATU_FUNC_PORT_EN;\r\nreg |= (port & QCA8K_ATU_FUNC_PORT_M) << QCA8K_ATU_FUNC_PORT_S;\r\n}\r\nqca8k_write(priv, QCA8K_REG_ATU_FUNC, reg);\r\nif (qca8k_busy_wait(priv, QCA8K_REG_ATU_FUNC, QCA8K_ATU_FUNC_BUSY))\r\nreturn -1;\r\nif (cmd == QCA8K_FDB_LOAD) {\r\nreg = qca8k_read(priv, QCA8K_REG_ATU_FUNC);\r\nif (reg & QCA8K_ATU_FUNC_FULL)\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nqca8k_fdb_next(struct qca8k_priv *priv, struct qca8k_fdb *fdb, int port)\r\n{\r\nint ret;\r\nqca8k_fdb_write(priv, fdb->vid, fdb->port_mask, fdb->mac, fdb->aging);\r\nret = qca8k_fdb_access(priv, QCA8K_FDB_NEXT, port);\r\nif (ret >= 0)\r\nqca8k_fdb_read(priv, fdb);\r\nreturn ret;\r\n}\r\nstatic int\r\nqca8k_fdb_add(struct qca8k_priv *priv, const u8 *mac, u16 port_mask,\r\nu16 vid, u8 aging)\r\n{\r\nint ret;\r\nmutex_lock(&priv->reg_mutex);\r\nqca8k_fdb_write(priv, vid, port_mask, mac, aging);\r\nret = qca8k_fdb_access(priv, QCA8K_FDB_LOAD, -1);\r\nmutex_unlock(&priv->reg_mutex);\r\nreturn ret;\r\n}\r\nstatic int\r\nqca8k_fdb_del(struct qca8k_priv *priv, const u8 *mac, u16 port_mask, u16 vid)\r\n{\r\nint ret;\r\nmutex_lock(&priv->reg_mutex);\r\nqca8k_fdb_write(priv, vid, port_mask, mac, 0);\r\nret = qca8k_fdb_access(priv, QCA8K_FDB_PURGE, -1);\r\nmutex_unlock(&priv->reg_mutex);\r\nreturn ret;\r\n}\r\nstatic void\r\nqca8k_fdb_flush(struct qca8k_priv *priv)\r\n{\r\nmutex_lock(&priv->reg_mutex);\r\nqca8k_fdb_access(priv, QCA8K_FDB_FLUSH, -1);\r\nmutex_unlock(&priv->reg_mutex);\r\n}\r\nstatic void\r\nqca8k_mib_init(struct qca8k_priv *priv)\r\n{\r\nmutex_lock(&priv->reg_mutex);\r\nqca8k_reg_set(priv, QCA8K_REG_MIB, QCA8K_MIB_FLUSH | QCA8K_MIB_BUSY);\r\nqca8k_busy_wait(priv, QCA8K_REG_MIB, QCA8K_MIB_BUSY);\r\nqca8k_reg_set(priv, QCA8K_REG_MIB, QCA8K_MIB_CPU_KEEP);\r\nqca8k_write(priv, QCA8K_REG_MODULE_EN, QCA8K_MODULE_EN_MIB);\r\nmutex_unlock(&priv->reg_mutex);\r\n}\r\nstatic int\r\nqca8k_set_pad_ctrl(struct qca8k_priv *priv, int port, int mode)\r\n{\r\nu32 reg;\r\nswitch (port) {\r\ncase 0:\r\nreg = QCA8K_REG_PORT0_PAD_CTRL;\r\nbreak;\r\ncase 6:\r\nreg = QCA8K_REG_PORT6_PAD_CTRL;\r\nbreak;\r\ndefault:\r\npr_err("Can't set PAD_CTRL on port %d\n", port);\r\nreturn -EINVAL;\r\n}\r\nswitch (mode) {\r\ncase PHY_INTERFACE_MODE_RGMII:\r\nqca8k_write(priv, reg,\r\nQCA8K_PORT_PAD_RGMII_EN |\r\nQCA8K_PORT_PAD_RGMII_TX_DELAY(3) |\r\nQCA8K_PORT_PAD_RGMII_RX_DELAY(3));\r\nqca8k_write(priv, QCA8K_REG_PORT5_PAD_CTRL,\r\nQCA8K_PORT_PAD_RGMII_RX_DELAY_EN);\r\nbreak;\r\ncase PHY_INTERFACE_MODE_SGMII:\r\nqca8k_write(priv, reg, QCA8K_PORT_PAD_SGMII_EN);\r\nbreak;\r\ndefault:\r\npr_err("xMII mode %d not supported\n", mode);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nqca8k_port_set_status(struct qca8k_priv *priv, int port, int enable)\r\n{\r\nu32 mask = QCA8K_PORT_STATUS_TXMAC;\r\nif ((port > 0) && (port < 6))\r\nmask |= QCA8K_PORT_STATUS_LINK_AUTO;\r\nif (enable)\r\nqca8k_reg_set(priv, QCA8K_REG_PORT_STATUS(port), mask);\r\nelse\r\nqca8k_reg_clear(priv, QCA8K_REG_PORT_STATUS(port), mask);\r\n}\r\nstatic int\r\nqca8k_setup(struct dsa_switch *ds)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nint ret, i, phy_mode = -1;\r\nif (!dsa_is_cpu_port(ds, 0)) {\r\npr_err("port 0 is not the CPU port\n");\r\nreturn -EINVAL;\r\n}\r\nmutex_init(&priv->reg_mutex);\r\npriv->regmap = devm_regmap_init(ds->dev, NULL, priv,\r\n&qca8k_regmap_config);\r\nif (IS_ERR(priv->regmap))\r\npr_warn("regmap initialization failed");\r\nphy_mode = of_get_phy_mode(ds->ports[ds->dst->cpu_port].dn);\r\nif (phy_mode < 0) {\r\npr_err("Can't find phy-mode for master device\n");\r\nreturn phy_mode;\r\n}\r\nret = qca8k_set_pad_ctrl(priv, QCA8K_CPU_PORT, phy_mode);\r\nif (ret < 0)\r\nreturn ret;\r\nqca8k_reg_set(priv, QCA8K_REG_GLOBAL_FW_CTRL0,\r\nQCA8K_GLOBAL_FW_CTRL0_CPU_PORT_EN);\r\nqca8k_port_set_status(priv, QCA8K_CPU_PORT, 1);\r\npriv->port_sts[QCA8K_CPU_PORT].enabled = 1;\r\nqca8k_mib_init(priv);\r\nqca8k_write(priv, QCA8K_REG_PORT_HDR_CTRL(QCA8K_CPU_PORT),\r\nQCA8K_PORT_HDR_CTRL_ALL << QCA8K_PORT_HDR_CTRL_TX_S |\r\nQCA8K_PORT_HDR_CTRL_ALL << QCA8K_PORT_HDR_CTRL_RX_S);\r\nfor (i = 0; i < QCA8K_NUM_PORTS; i++)\r\nqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(i),\r\nQCA8K_PORT_LOOKUP_MEMBER, 0);\r\nfor (i = 1; i < QCA8K_NUM_PORTS; i++)\r\nif (ds->enabled_port_mask & BIT(i))\r\nqca8k_port_set_status(priv, i, 0);\r\nqca8k_write(priv, QCA8K_REG_GLOBAL_FW_CTRL1,\r\nBIT(0) << QCA8K_GLOBAL_FW_CTRL1_IGMP_DP_S |\r\nBIT(0) << QCA8K_GLOBAL_FW_CTRL1_BC_DP_S |\r\nBIT(0) << QCA8K_GLOBAL_FW_CTRL1_MC_DP_S |\r\nBIT(0) << QCA8K_GLOBAL_FW_CTRL1_UC_DP_S);\r\nfor (i = 0; i < DSA_MAX_PORTS; i++) {\r\nif (dsa_is_cpu_port(ds, i)) {\r\nqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(QCA8K_CPU_PORT),\r\nQCA8K_PORT_LOOKUP_MEMBER,\r\nds->enabled_port_mask);\r\n}\r\nif (ds->enabled_port_mask & BIT(i)) {\r\nint shift = 16 * (i % 2);\r\nqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(i),\r\nQCA8K_PORT_LOOKUP_MEMBER,\r\nBIT(QCA8K_CPU_PORT));\r\nqca8k_reg_set(priv, QCA8K_PORT_LOOKUP_CTRL(i),\r\nQCA8K_PORT_LOOKUP_LEARN);\r\nqca8k_rmw(priv, QCA8K_EGRESS_VLAN(i),\r\n0xffff << shift, 1 << shift);\r\nqca8k_write(priv, QCA8K_REG_PORT_VLAN_CTRL0(i),\r\nQCA8K_PORT_VLAN_CVID(1) |\r\nQCA8K_PORT_VLAN_SVID(1));\r\n}\r\n}\r\nqca8k_fdb_flush(priv);\r\nreturn 0;\r\n}\r\nstatic int\r\nqca8k_phy_read(struct dsa_switch *ds, int phy, int regnum)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nreturn mdiobus_read(priv->bus, phy, regnum);\r\n}\r\nstatic int\r\nqca8k_phy_write(struct dsa_switch *ds, int phy, int regnum, u16 val)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nreturn mdiobus_write(priv->bus, phy, regnum, val);\r\n}\r\nstatic void\r\nqca8k_get_strings(struct dsa_switch *ds, int port, uint8_t *data)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(ar8327_mib); i++)\r\nstrncpy(data + i * ETH_GSTRING_LEN, ar8327_mib[i].name,\r\nETH_GSTRING_LEN);\r\n}\r\nstatic void\r\nqca8k_get_ethtool_stats(struct dsa_switch *ds, int port,\r\nuint64_t *data)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nconst struct qca8k_mib_desc *mib;\r\nu32 reg, i;\r\nu64 hi;\r\nfor (i = 0; i < ARRAY_SIZE(ar8327_mib); i++) {\r\nmib = &ar8327_mib[i];\r\nreg = QCA8K_PORT_MIB_COUNTER(port) + mib->offset;\r\ndata[i] = qca8k_read(priv, reg);\r\nif (mib->size == 2) {\r\nhi = qca8k_read(priv, reg + 4);\r\ndata[i] |= hi << 32;\r\n}\r\n}\r\n}\r\nstatic int\r\nqca8k_get_sset_count(struct dsa_switch *ds)\r\n{\r\nreturn ARRAY_SIZE(ar8327_mib);\r\n}\r\nstatic void\r\nqca8k_eee_enable_set(struct dsa_switch *ds, int port, bool enable)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nu32 lpi_en = QCA8K_REG_EEE_CTRL_LPI_EN(port);\r\nu32 reg;\r\nmutex_lock(&priv->reg_mutex);\r\nreg = qca8k_read(priv, QCA8K_REG_EEE_CTRL);\r\nif (enable)\r\nreg |= lpi_en;\r\nelse\r\nreg &= ~lpi_en;\r\nqca8k_write(priv, QCA8K_REG_EEE_CTRL, reg);\r\nmutex_unlock(&priv->reg_mutex);\r\n}\r\nstatic int\r\nqca8k_eee_init(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nint ret;\r\np->supported = (SUPPORTED_1000baseT_Full | SUPPORTED_100baseT_Full);\r\nret = phy_init_eee(phy, 0);\r\nif (ret)\r\nreturn ret;\r\nqca8k_eee_enable_set(ds, port, true);\r\nreturn 0;\r\n}\r\nstatic int\r\nqca8k_set_eee(struct dsa_switch *ds, int port,\r\nstruct phy_device *phydev,\r\nstruct ethtool_eee *e)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nint ret = 0;\r\np->eee_enabled = e->eee_enabled;\r\nif (e->eee_enabled) {\r\np->eee_enabled = qca8k_eee_init(ds, port, phydev);\r\nif (!p->eee_enabled)\r\nret = -EOPNOTSUPP;\r\n}\r\nqca8k_eee_enable_set(ds, port, p->eee_enabled);\r\nreturn ret;\r\n}\r\nstatic int\r\nqca8k_get_eee(struct dsa_switch *ds, int port,\r\nstruct ethtool_eee *e)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nstruct ethtool_eee *p = &priv->port_sts[port].eee;\r\nstruct net_device *netdev = ds->ports[port].netdev;\r\nint ret;\r\nret = phy_ethtool_get_eee(netdev->phydev, p);\r\nif (!ret)\r\ne->eee_active =\r\n!!(p->supported & p->advertised & p->lp_advertised);\r\nelse\r\ne->eee_active = 0;\r\ne->eee_enabled = p->eee_enabled;\r\nreturn ret;\r\n}\r\nstatic void\r\nqca8k_port_stp_state_set(struct dsa_switch *ds, int port, u8 state)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nu32 stp_state;\r\nswitch (state) {\r\ncase BR_STATE_DISABLED:\r\nstp_state = QCA8K_PORT_LOOKUP_STATE_DISABLED;\r\nbreak;\r\ncase BR_STATE_BLOCKING:\r\nstp_state = QCA8K_PORT_LOOKUP_STATE_BLOCKING;\r\nbreak;\r\ncase BR_STATE_LISTENING:\r\nstp_state = QCA8K_PORT_LOOKUP_STATE_LISTENING;\r\nbreak;\r\ncase BR_STATE_LEARNING:\r\nstp_state = QCA8K_PORT_LOOKUP_STATE_LEARNING;\r\nbreak;\r\ncase BR_STATE_FORWARDING:\r\ndefault:\r\nstp_state = QCA8K_PORT_LOOKUP_STATE_FORWARD;\r\nbreak;\r\n}\r\nqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\r\nQCA8K_PORT_LOOKUP_STATE_MASK, stp_state);\r\n}\r\nstatic int\r\nqca8k_port_bridge_join(struct dsa_switch *ds, int port, struct net_device *br)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nint port_mask = BIT(QCA8K_CPU_PORT);\r\nint i;\r\nfor (i = 1; i < QCA8K_NUM_PORTS; i++) {\r\nif (ds->ports[i].bridge_dev != br)\r\ncontinue;\r\nqca8k_reg_set(priv,\r\nQCA8K_PORT_LOOKUP_CTRL(i),\r\nBIT(port));\r\nif (i != port)\r\nport_mask |= BIT(i);\r\n}\r\nqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\r\nQCA8K_PORT_LOOKUP_MEMBER, port_mask);\r\nreturn 0;\r\n}\r\nstatic void\r\nqca8k_port_bridge_leave(struct dsa_switch *ds, int port, struct net_device *br)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nint i;\r\nfor (i = 1; i < QCA8K_NUM_PORTS; i++) {\r\nif (ds->ports[i].bridge_dev != br)\r\ncontinue;\r\nqca8k_reg_clear(priv,\r\nQCA8K_PORT_LOOKUP_CTRL(i),\r\nBIT(port));\r\n}\r\nqca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),\r\nQCA8K_PORT_LOOKUP_MEMBER, BIT(QCA8K_CPU_PORT));\r\n}\r\nstatic int\r\nqca8k_port_enable(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nqca8k_port_set_status(priv, port, 1);\r\npriv->port_sts[port].enabled = 1;\r\nreturn 0;\r\n}\r\nstatic void\r\nqca8k_port_disable(struct dsa_switch *ds, int port,\r\nstruct phy_device *phy)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nqca8k_port_set_status(priv, port, 0);\r\npriv->port_sts[port].enabled = 0;\r\n}\r\nstatic int\r\nqca8k_port_fdb_insert(struct qca8k_priv *priv, const u8 *addr,\r\nu16 port_mask, u16 vid)\r\n{\r\nif (!vid)\r\nvid = 1;\r\nreturn qca8k_fdb_add(priv, addr, port_mask, vid,\r\nQCA8K_ATU_STATUS_STATIC);\r\n}\r\nstatic int\r\nqca8k_port_fdb_prepare(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nreturn qca8k_port_fdb_insert(priv, fdb->addr, 0, fdb->vid);\r\n}\r\nstatic void\r\nqca8k_port_fdb_add(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb,\r\nstruct switchdev_trans *trans)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nu16 port_mask = BIT(port);\r\nqca8k_port_fdb_insert(priv, fdb->addr, port_mask, fdb->vid);\r\n}\r\nstatic int\r\nqca8k_port_fdb_del(struct dsa_switch *ds, int port,\r\nconst struct switchdev_obj_port_fdb *fdb)\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nu16 port_mask = BIT(port);\r\nu16 vid = fdb->vid;\r\nif (!vid)\r\nvid = 1;\r\nreturn qca8k_fdb_del(priv, fdb->addr, port_mask, vid);\r\n}\r\nstatic int\r\nqca8k_port_fdb_dump(struct dsa_switch *ds, int port,\r\nstruct switchdev_obj_port_fdb *fdb,\r\nint (*cb)(struct switchdev_obj *obj))\r\n{\r\nstruct qca8k_priv *priv = (struct qca8k_priv *)ds->priv;\r\nstruct qca8k_fdb _fdb = { 0 };\r\nint cnt = QCA8K_NUM_FDB_RECORDS;\r\nint ret = 0;\r\nmutex_lock(&priv->reg_mutex);\r\nwhile (cnt-- && !qca8k_fdb_next(priv, &_fdb, port)) {\r\nif (!_fdb.aging)\r\nbreak;\r\nether_addr_copy(fdb->addr, _fdb.mac);\r\nfdb->vid = _fdb.vid;\r\nif (_fdb.aging == QCA8K_ATU_STATUS_STATIC)\r\nfdb->ndm_state = NUD_NOARP;\r\nelse\r\nfdb->ndm_state = NUD_REACHABLE;\r\nret = cb(&fdb->obj);\r\nif (ret)\r\nbreak;\r\n}\r\nmutex_unlock(&priv->reg_mutex);\r\nreturn 0;\r\n}\r\nstatic enum dsa_tag_protocol\r\nqca8k_get_tag_protocol(struct dsa_switch *ds)\r\n{\r\nreturn DSA_TAG_PROTO_QCA;\r\n}\r\nstatic int\r\nqca8k_sw_probe(struct mdio_device *mdiodev)\r\n{\r\nstruct qca8k_priv *priv;\r\nu32 id;\r\npriv = devm_kzalloc(&mdiodev->dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->bus = mdiodev->bus;\r\nid = qca8k_read(priv, QCA8K_REG_MASK_CTRL);\r\nid >>= QCA8K_MASK_CTRL_ID_S;\r\nid &= QCA8K_MASK_CTRL_ID_M;\r\nif (id != QCA8K_ID_QCA8337)\r\nreturn -ENODEV;\r\npriv->ds = dsa_switch_alloc(&mdiodev->dev, DSA_MAX_PORTS);\r\nif (!priv->ds)\r\nreturn -ENOMEM;\r\npriv->ds->priv = priv;\r\npriv->ds->ops = &qca8k_switch_ops;\r\nmutex_init(&priv->reg_mutex);\r\ndev_set_drvdata(&mdiodev->dev, priv);\r\nreturn dsa_register_switch(priv->ds, &mdiodev->dev);\r\n}\r\nstatic void\r\nqca8k_sw_remove(struct mdio_device *mdiodev)\r\n{\r\nstruct qca8k_priv *priv = dev_get_drvdata(&mdiodev->dev);\r\nint i;\r\nfor (i = 0; i < QCA8K_NUM_PORTS; i++)\r\nqca8k_port_set_status(priv, i, 0);\r\ndsa_unregister_switch(priv->ds);\r\n}\r\nstatic void\r\nqca8k_set_pm(struct qca8k_priv *priv, int enable)\r\n{\r\nint i;\r\nfor (i = 0; i < QCA8K_NUM_PORTS; i++) {\r\nif (!priv->port_sts[i].enabled)\r\ncontinue;\r\nqca8k_port_set_status(priv, i, enable);\r\n}\r\n}\r\nstatic int qca8k_suspend(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct qca8k_priv *priv = platform_get_drvdata(pdev);\r\nqca8k_set_pm(priv, 0);\r\nreturn dsa_switch_suspend(priv->ds);\r\n}\r\nstatic int qca8k_resume(struct device *dev)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct qca8k_priv *priv = platform_get_drvdata(pdev);\r\nqca8k_set_pm(priv, 1);\r\nreturn dsa_switch_resume(priv->ds);\r\n}
