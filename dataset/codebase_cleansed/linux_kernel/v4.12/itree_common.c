static inline void add_chain(Indirect *p, struct buffer_head *bh, block_t *v)\r\n{\r\np->key = *(p->p = v);\r\np->bh = bh;\r\n}\r\nstatic inline int verify_chain(Indirect *from, Indirect *to)\r\n{\r\nwhile (from <= to && from->key == *from->p)\r\nfrom++;\r\nreturn (from > to);\r\n}\r\nstatic inline block_t *block_end(struct buffer_head *bh)\r\n{\r\nreturn (block_t *)((char*)bh->b_data + bh->b_size);\r\n}\r\nstatic inline Indirect *get_branch(struct inode *inode,\r\nint depth,\r\nint *offsets,\r\nIndirect chain[DEPTH],\r\nint *err)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nIndirect *p = chain;\r\nstruct buffer_head *bh;\r\n*err = 0;\r\nadd_chain (chain, NULL, i_data(inode) + *offsets);\r\nif (!p->key)\r\ngoto no_block;\r\nwhile (--depth) {\r\nbh = sb_bread(sb, block_to_cpu(p->key));\r\nif (!bh)\r\ngoto failure;\r\nread_lock(&pointers_lock);\r\nif (!verify_chain(chain, p))\r\ngoto changed;\r\nadd_chain(++p, bh, (block_t *)bh->b_data + *++offsets);\r\nread_unlock(&pointers_lock);\r\nif (!p->key)\r\ngoto no_block;\r\n}\r\nreturn NULL;\r\nchanged:\r\nread_unlock(&pointers_lock);\r\nbrelse(bh);\r\n*err = -EAGAIN;\r\ngoto no_block;\r\nfailure:\r\n*err = -EIO;\r\nno_block:\r\nreturn p;\r\n}\r\nstatic int alloc_branch(struct inode *inode,\r\nint num,\r\nint *offsets,\r\nIndirect *branch)\r\n{\r\nint n = 0;\r\nint i;\r\nint parent = minix_new_block(inode);\r\nbranch[0].key = cpu_to_block(parent);\r\nif (parent) for (n = 1; n < num; n++) {\r\nstruct buffer_head *bh;\r\nint nr = minix_new_block(inode);\r\nif (!nr)\r\nbreak;\r\nbranch[n].key = cpu_to_block(nr);\r\nbh = sb_getblk(inode->i_sb, parent);\r\nlock_buffer(bh);\r\nmemset(bh->b_data, 0, bh->b_size);\r\nbranch[n].bh = bh;\r\nbranch[n].p = (block_t*) bh->b_data + offsets[n];\r\n*branch[n].p = branch[n].key;\r\nset_buffer_uptodate(bh);\r\nunlock_buffer(bh);\r\nmark_buffer_dirty_inode(bh, inode);\r\nparent = nr;\r\n}\r\nif (n == num)\r\nreturn 0;\r\nfor (i = 1; i < n; i++)\r\nbforget(branch[i].bh);\r\nfor (i = 0; i < n; i++)\r\nminix_free_block(inode, block_to_cpu(branch[i].key));\r\nreturn -ENOSPC;\r\n}\r\nstatic inline int splice_branch(struct inode *inode,\r\nIndirect chain[DEPTH],\r\nIndirect *where,\r\nint num)\r\n{\r\nint i;\r\nwrite_lock(&pointers_lock);\r\nif (!verify_chain(chain, where-1) || *where->p)\r\ngoto changed;\r\n*where->p = where->key;\r\nwrite_unlock(&pointers_lock);\r\ninode->i_ctime = current_time(inode);\r\nif (where->bh)\r\nmark_buffer_dirty_inode(where->bh, inode);\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\nchanged:\r\nwrite_unlock(&pointers_lock);\r\nfor (i = 1; i < num; i++)\r\nbforget(where[i].bh);\r\nfor (i = 0; i < num; i++)\r\nminix_free_block(inode, block_to_cpu(where[i].key));\r\nreturn -EAGAIN;\r\n}\r\nstatic inline int get_block(struct inode * inode, sector_t block,\r\nstruct buffer_head *bh, int create)\r\n{\r\nint err = -EIO;\r\nint offsets[DEPTH];\r\nIndirect chain[DEPTH];\r\nIndirect *partial;\r\nint left;\r\nint depth = block_to_path(inode, block, offsets);\r\nif (depth == 0)\r\ngoto out;\r\nreread:\r\npartial = get_branch(inode, depth, offsets, chain, &err);\r\nif (!partial) {\r\ngot_it:\r\nmap_bh(bh, inode->i_sb, block_to_cpu(chain[depth-1].key));\r\npartial = chain+depth-1;\r\ngoto cleanup;\r\n}\r\nif (!create || err == -EIO) {\r\ncleanup:\r\nwhile (partial > chain) {\r\nbrelse(partial->bh);\r\npartial--;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nif (err == -EAGAIN)\r\ngoto changed;\r\nleft = (chain + depth) - partial;\r\nerr = alloc_branch(inode, left, offsets+(partial-chain), partial);\r\nif (err)\r\ngoto cleanup;\r\nif (splice_branch(inode, chain, partial, left) < 0)\r\ngoto changed;\r\nset_buffer_new(bh);\r\ngoto got_it;\r\nchanged:\r\nwhile (partial > chain) {\r\nbrelse(partial->bh);\r\npartial--;\r\n}\r\ngoto reread;\r\n}\r\nstatic inline int all_zeroes(block_t *p, block_t *q)\r\n{\r\nwhile (p < q)\r\nif (*p++)\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic Indirect *find_shared(struct inode *inode,\r\nint depth,\r\nint offsets[DEPTH],\r\nIndirect chain[DEPTH],\r\nblock_t *top)\r\n{\r\nIndirect *partial, *p;\r\nint k, err;\r\n*top = 0;\r\nfor (k = depth; k > 1 && !offsets[k-1]; k--)\r\n;\r\npartial = get_branch(inode, k, offsets, chain, &err);\r\nwrite_lock(&pointers_lock);\r\nif (!partial)\r\npartial = chain + k-1;\r\nif (!partial->key && *partial->p) {\r\nwrite_unlock(&pointers_lock);\r\ngoto no_top;\r\n}\r\nfor (p=partial;p>chain && all_zeroes((block_t*)p->bh->b_data,p->p);p--)\r\n;\r\nif (p == chain + k - 1 && p > chain) {\r\np->p--;\r\n} else {\r\n*top = *p->p;\r\n*p->p = 0;\r\n}\r\nwrite_unlock(&pointers_lock);\r\nwhile(partial > p)\r\n{\r\nbrelse(partial->bh);\r\npartial--;\r\n}\r\nno_top:\r\nreturn partial;\r\n}\r\nstatic inline void free_data(struct inode *inode, block_t *p, block_t *q)\r\n{\r\nunsigned long nr;\r\nfor ( ; p < q ; p++) {\r\nnr = block_to_cpu(*p);\r\nif (nr) {\r\n*p = 0;\r\nminix_free_block(inode, nr);\r\n}\r\n}\r\n}\r\nstatic void free_branches(struct inode *inode, block_t *p, block_t *q, int depth)\r\n{\r\nstruct buffer_head * bh;\r\nunsigned long nr;\r\nif (depth--) {\r\nfor ( ; p < q ; p++) {\r\nnr = block_to_cpu(*p);\r\nif (!nr)\r\ncontinue;\r\n*p = 0;\r\nbh = sb_bread(inode->i_sb, nr);\r\nif (!bh)\r\ncontinue;\r\nfree_branches(inode, (block_t*)bh->b_data,\r\nblock_end(bh), depth);\r\nbforget(bh);\r\nminix_free_block(inode, nr);\r\nmark_inode_dirty(inode);\r\n}\r\n} else\r\nfree_data(inode, p, q);\r\n}\r\nstatic inline void truncate (struct inode * inode)\r\n{\r\nstruct super_block *sb = inode->i_sb;\r\nblock_t *idata = i_data(inode);\r\nint offsets[DEPTH];\r\nIndirect chain[DEPTH];\r\nIndirect *partial;\r\nblock_t nr = 0;\r\nint n;\r\nint first_whole;\r\nlong iblock;\r\niblock = (inode->i_size + sb->s_blocksize -1) >> sb->s_blocksize_bits;\r\nblock_truncate_page(inode->i_mapping, inode->i_size, get_block);\r\nn = block_to_path(inode, iblock, offsets);\r\nif (!n)\r\nreturn;\r\nif (n == 1) {\r\nfree_data(inode, idata+offsets[0], idata + DIRECT);\r\nfirst_whole = 0;\r\ngoto do_indirects;\r\n}\r\nfirst_whole = offsets[0] + 1 - DIRECT;\r\npartial = find_shared(inode, n, offsets, chain, &nr);\r\nif (nr) {\r\nif (partial == chain)\r\nmark_inode_dirty(inode);\r\nelse\r\nmark_buffer_dirty_inode(partial->bh, inode);\r\nfree_branches(inode, &nr, &nr+1, (chain+n-1) - partial);\r\n}\r\nwhile (partial > chain) {\r\nfree_branches(inode, partial->p + 1, block_end(partial->bh),\r\n(chain+n-1) - partial);\r\nmark_buffer_dirty_inode(partial->bh, inode);\r\nbrelse (partial->bh);\r\npartial--;\r\n}\r\ndo_indirects:\r\nwhile (first_whole < DEPTH-1) {\r\nnr = idata[DIRECT+first_whole];\r\nif (nr) {\r\nidata[DIRECT+first_whole] = 0;\r\nmark_inode_dirty(inode);\r\nfree_branches(inode, &nr, &nr+1, first_whole+1);\r\n}\r\nfirst_whole++;\r\n}\r\ninode->i_mtime = inode->i_ctime = current_time(inode);\r\nmark_inode_dirty(inode);\r\n}\r\nstatic inline unsigned nblocks(loff_t size, struct super_block *sb)\r\n{\r\nint k = sb->s_blocksize_bits - 10;\r\nunsigned blocks, res, direct = DIRECT, i = DEPTH;\r\nblocks = (size + sb->s_blocksize - 1) >> (BLOCK_SIZE_BITS + k);\r\nres = blocks;\r\nwhile (--i && blocks > direct) {\r\nblocks -= direct;\r\nblocks += sb->s_blocksize/sizeof(block_t) - 1;\r\nblocks /= sb->s_blocksize/sizeof(block_t);\r\nres += blocks;\r\ndirect = 1;\r\n}\r\nreturn res;\r\n}
