int ndlc_open(struct llt_ndlc *ndlc)\r\n{\r\nndlc->ops->enable(ndlc->phy_id);\r\nndlc->powered = 1;\r\nreturn 0;\r\n}\r\nvoid ndlc_close(struct llt_ndlc *ndlc)\r\n{\r\nstruct nci_mode_set_cmd cmd;\r\ncmd.cmd_type = ST_NCI_SET_NFC_MODE;\r\ncmd.mode = 0;\r\nndlc->ops->enable(ndlc->phy_id);\r\nnci_prop_cmd(ndlc->ndev, ST_NCI_CORE_PROP,\r\nsizeof(struct nci_mode_set_cmd), (__u8 *)&cmd);\r\nndlc->powered = 0;\r\nndlc->ops->disable(ndlc->phy_id);\r\n}\r\nint ndlc_send(struct llt_ndlc *ndlc, struct sk_buff *skb)\r\n{\r\nu8 pcb = PCB_TYPE_DATAFRAME | PCB_DATAFRAME_RETRANSMIT_NO |\r\nPCB_FRAME_CRC_INFO_NOTPRESENT;\r\n*skb_push(skb, 1) = pcb;\r\nskb_queue_tail(&ndlc->send_q, skb);\r\nschedule_work(&ndlc->sm_work);\r\nreturn 0;\r\n}\r\nstatic void llt_ndlc_send_queue(struct llt_ndlc *ndlc)\r\n{\r\nstruct sk_buff *skb;\r\nint r;\r\nunsigned long time_sent;\r\nif (ndlc->send_q.qlen)\r\npr_debug("sendQlen=%d unackQlen=%d\n",\r\nndlc->send_q.qlen, ndlc->ack_pending_q.qlen);\r\nwhile (ndlc->send_q.qlen) {\r\nskb = skb_dequeue(&ndlc->send_q);\r\nNDLC_DUMP_SKB("ndlc frame written", skb);\r\nr = ndlc->ops->write(ndlc->phy_id, skb);\r\nif (r < 0) {\r\nndlc->hard_fault = r;\r\nbreak;\r\n}\r\ntime_sent = jiffies;\r\n*(unsigned long *)skb->cb = time_sent;\r\nskb_queue_tail(&ndlc->ack_pending_q, skb);\r\nndlc->t1_active = true;\r\nmod_timer(&ndlc->t1_timer, time_sent +\r\nmsecs_to_jiffies(NDLC_TIMER_T1));\r\nndlc->t2_active = true;\r\nmod_timer(&ndlc->t2_timer, time_sent +\r\nmsecs_to_jiffies(NDLC_TIMER_T2));\r\n}\r\n}\r\nstatic void llt_ndlc_requeue_data_pending(struct llt_ndlc *ndlc)\r\n{\r\nstruct sk_buff *skb;\r\nu8 pcb;\r\nwhile ((skb = skb_dequeue_tail(&ndlc->ack_pending_q))) {\r\npcb = skb->data[0];\r\nswitch (pcb & PCB_TYPE_MASK) {\r\ncase PCB_TYPE_SUPERVISOR:\r\nskb->data[0] = (pcb & ~PCB_SUPERVISOR_RETRANSMIT_MASK) |\r\nPCB_SUPERVISOR_RETRANSMIT_YES;\r\nbreak;\r\ncase PCB_TYPE_DATAFRAME:\r\nskb->data[0] = (pcb & ~PCB_DATAFRAME_RETRANSMIT_MASK) |\r\nPCB_DATAFRAME_RETRANSMIT_YES;\r\nbreak;\r\ndefault:\r\npr_err("UNKNOWN Packet Control Byte=%d\n", pcb);\r\nkfree_skb(skb);\r\ncontinue;\r\n}\r\nskb_queue_head(&ndlc->send_q, skb);\r\n}\r\n}\r\nstatic void llt_ndlc_rcv_queue(struct llt_ndlc *ndlc)\r\n{\r\nstruct sk_buff *skb;\r\nu8 pcb;\r\nunsigned long time_sent;\r\nif (ndlc->rcv_q.qlen)\r\npr_debug("rcvQlen=%d\n", ndlc->rcv_q.qlen);\r\nwhile ((skb = skb_dequeue(&ndlc->rcv_q)) != NULL) {\r\npcb = skb->data[0];\r\nskb_pull(skb, 1);\r\nif ((pcb & PCB_TYPE_MASK) == PCB_TYPE_SUPERVISOR) {\r\nswitch (pcb & PCB_SYNC_MASK) {\r\ncase PCB_SYNC_ACK:\r\nskb = skb_dequeue(&ndlc->ack_pending_q);\r\nkfree_skb(skb);\r\ndel_timer_sync(&ndlc->t1_timer);\r\ndel_timer_sync(&ndlc->t2_timer);\r\nndlc->t2_active = false;\r\nndlc->t1_active = false;\r\nbreak;\r\ncase PCB_SYNC_NACK:\r\nllt_ndlc_requeue_data_pending(ndlc);\r\nllt_ndlc_send_queue(ndlc);\r\ntime_sent = jiffies;\r\nndlc->t1_active = true;\r\nmod_timer(&ndlc->t1_timer, time_sent +\r\nmsecs_to_jiffies(NDLC_TIMER_T1));\r\nbreak;\r\ncase PCB_SYNC_WAIT:\r\ntime_sent = jiffies;\r\nndlc->t1_active = true;\r\nmod_timer(&ndlc->t1_timer, time_sent +\r\nmsecs_to_jiffies(NDLC_TIMER_T1_WAIT));\r\nbreak;\r\ndefault:\r\nkfree_skb(skb);\r\nbreak;\r\n}\r\n} else if ((pcb & PCB_TYPE_MASK) == PCB_TYPE_DATAFRAME) {\r\nnci_recv_frame(ndlc->ndev, skb);\r\n} else {\r\nkfree_skb(skb);\r\n}\r\n}\r\n}\r\nstatic void llt_ndlc_sm_work(struct work_struct *work)\r\n{\r\nstruct llt_ndlc *ndlc = container_of(work, struct llt_ndlc, sm_work);\r\nllt_ndlc_send_queue(ndlc);\r\nllt_ndlc_rcv_queue(ndlc);\r\nif (ndlc->t1_active && timer_pending(&ndlc->t1_timer) == 0) {\r\npr_debug\r\n("Handle T1(recv SUPERVISOR) elapsed (T1 now inactive)\n");\r\nndlc->t1_active = false;\r\nllt_ndlc_requeue_data_pending(ndlc);\r\nllt_ndlc_send_queue(ndlc);\r\n}\r\nif (ndlc->t2_active && timer_pending(&ndlc->t2_timer) == 0) {\r\npr_debug("Handle T2(recv DATA) elapsed (T2 now inactive)\n");\r\nndlc->t2_active = false;\r\nndlc->t1_active = false;\r\ndel_timer_sync(&ndlc->t1_timer);\r\ndel_timer_sync(&ndlc->t2_timer);\r\nndlc_close(ndlc);\r\nndlc->hard_fault = -EREMOTEIO;\r\n}\r\n}\r\nvoid ndlc_recv(struct llt_ndlc *ndlc, struct sk_buff *skb)\r\n{\r\nif (skb == NULL) {\r\npr_err("NULL Frame -> link is dead\n");\r\nndlc->hard_fault = -EREMOTEIO;\r\nndlc_close(ndlc);\r\n} else {\r\nNDLC_DUMP_SKB("incoming frame", skb);\r\nskb_queue_tail(&ndlc->rcv_q, skb);\r\n}\r\nschedule_work(&ndlc->sm_work);\r\n}\r\nstatic void ndlc_t1_timeout(unsigned long data)\r\n{\r\nstruct llt_ndlc *ndlc = (struct llt_ndlc *)data;\r\npr_debug("\n");\r\nschedule_work(&ndlc->sm_work);\r\n}\r\nstatic void ndlc_t2_timeout(unsigned long data)\r\n{\r\nstruct llt_ndlc *ndlc = (struct llt_ndlc *)data;\r\npr_debug("\n");\r\nschedule_work(&ndlc->sm_work);\r\n}\r\nint ndlc_probe(void *phy_id, struct nfc_phy_ops *phy_ops, struct device *dev,\r\nint phy_headroom, int phy_tailroom, struct llt_ndlc **ndlc_id,\r\nstruct st_nci_se_status *se_status)\r\n{\r\nstruct llt_ndlc *ndlc;\r\nndlc = devm_kzalloc(dev, sizeof(struct llt_ndlc), GFP_KERNEL);\r\nif (!ndlc)\r\nreturn -ENOMEM;\r\nndlc->ops = phy_ops;\r\nndlc->phy_id = phy_id;\r\nndlc->dev = dev;\r\nndlc->powered = 0;\r\n*ndlc_id = ndlc;\r\ninit_timer(&ndlc->t1_timer);\r\nndlc->t1_timer.data = (unsigned long)ndlc;\r\nndlc->t1_timer.function = ndlc_t1_timeout;\r\ninit_timer(&ndlc->t2_timer);\r\nndlc->t2_timer.data = (unsigned long)ndlc;\r\nndlc->t2_timer.function = ndlc_t2_timeout;\r\nskb_queue_head_init(&ndlc->rcv_q);\r\nskb_queue_head_init(&ndlc->send_q);\r\nskb_queue_head_init(&ndlc->ack_pending_q);\r\nINIT_WORK(&ndlc->sm_work, llt_ndlc_sm_work);\r\nreturn st_nci_probe(ndlc, phy_headroom, phy_tailroom, se_status);\r\n}\r\nvoid ndlc_remove(struct llt_ndlc *ndlc)\r\n{\r\nst_nci_remove(ndlc->ndev);\r\ndel_timer_sync(&ndlc->t1_timer);\r\ndel_timer_sync(&ndlc->t2_timer);\r\nndlc->t2_active = false;\r\nndlc->t1_active = false;\r\nskb_queue_purge(&ndlc->rcv_q);\r\nskb_queue_purge(&ndlc->send_q);\r\n}
