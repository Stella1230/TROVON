static inline void initialize_SCp(struct scsi_cmnd *cmd)\r\n{\r\nif (scsi_bufflen(cmd)) {\r\ncmd->SCp.buffer = scsi_sglist(cmd);\r\ncmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;\r\ncmd->SCp.ptr = sg_virt(cmd->SCp.buffer);\r\ncmd->SCp.this_residual = cmd->SCp.buffer->length;\r\n} else {\r\ncmd->SCp.buffer = NULL;\r\ncmd->SCp.buffers_residual = 0;\r\ncmd->SCp.ptr = NULL;\r\ncmd->SCp.this_residual = 0;\r\n}\r\ncmd->SCp.Status = 0;\r\ncmd->SCp.Message = 0;\r\n}\r\nstatic int NCR5380_poll_politely2(struct NCR5380_hostdata *hostdata,\r\nunsigned int reg1, u8 bit1, u8 val1,\r\nunsigned int reg2, u8 bit2, u8 val2,\r\nunsigned long wait)\r\n{\r\nunsigned long n = hostdata->poll_loops;\r\nunsigned long deadline = jiffies + wait;\r\ndo {\r\nif ((NCR5380_read(reg1) & bit1) == val1)\r\nreturn 0;\r\nif ((NCR5380_read(reg2) & bit2) == val2)\r\nreturn 0;\r\ncpu_relax();\r\n} while (n--);\r\nif (irqs_disabled() || in_interrupt())\r\nreturn -ETIMEDOUT;\r\nwhile (time_is_after_jiffies(deadline)) {\r\nschedule_timeout_uninterruptible(1);\r\nif ((NCR5380_read(reg1) & bit1) == val1)\r\nreturn 0;\r\nif ((NCR5380_read(reg2) & bit2) == val2)\r\nreturn 0;\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void NCR5380_print(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char status, data, basr, mr, icr, i;\r\ndata = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\nstatus = NCR5380_read(STATUS_REG);\r\nmr = NCR5380_read(MODE_REG);\r\nicr = NCR5380_read(INITIATOR_COMMAND_REG);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nprintk(KERN_DEBUG "SR = 0x%02x : ", status);\r\nfor (i = 0; signals[i].mask; ++i)\r\nif (status & signals[i].mask)\r\nprintk(KERN_CONT "%s, ", signals[i].name);\r\nprintk(KERN_CONT "\nBASR = 0x%02x : ", basr);\r\nfor (i = 0; basrs[i].mask; ++i)\r\nif (basr & basrs[i].mask)\r\nprintk(KERN_CONT "%s, ", basrs[i].name);\r\nprintk(KERN_CONT "\nICR = 0x%02x : ", icr);\r\nfor (i = 0; icrs[i].mask; ++i)\r\nif (icr & icrs[i].mask)\r\nprintk(KERN_CONT "%s, ", icrs[i].name);\r\nprintk(KERN_CONT "\nMR = 0x%02x : ", mr);\r\nfor (i = 0; mrs[i].mask; ++i)\r\nif (mr & mrs[i].mask)\r\nprintk(KERN_CONT "%s, ", mrs[i].name);\r\nprintk(KERN_CONT "\n");\r\n}\r\nstatic void NCR5380_print_phase(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char status;\r\nint i;\r\nstatus = NCR5380_read(STATUS_REG);\r\nif (!(status & SR_REQ))\r\nshost_printk(KERN_DEBUG, instance, "REQ not asserted, phase unknown.\n");\r\nelse {\r\nfor (i = 0; (phases[i].value != PHASE_UNKNOWN) &&\r\n(phases[i].value != (status & PHASE_MASK)); ++i)\r\n;\r\nshost_printk(KERN_DEBUG, instance, "phase %s\n", phases[i].name);\r\n}\r\n}\r\nstatic const char *NCR5380_info(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nreturn hostdata->info;\r\n}\r\nstatic int NCR5380_init(struct Scsi_Host *instance, int flags)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint i;\r\nunsigned long deadline;\r\nunsigned long accesses_per_ms;\r\ninstance->max_lun = 7;\r\nhostdata->host = instance;\r\nhostdata->id_mask = 1 << instance->this_id;\r\nhostdata->id_higher_mask = 0;\r\nfor (i = hostdata->id_mask; i <= 0x80; i <<= 1)\r\nif (i > hostdata->id_mask)\r\nhostdata->id_higher_mask |= i;\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\nhostdata->dma_len = 0;\r\nspin_lock_init(&hostdata->lock);\r\nhostdata->connected = NULL;\r\nhostdata->sensing = NULL;\r\nINIT_LIST_HEAD(&hostdata->autosense);\r\nINIT_LIST_HEAD(&hostdata->unissued);\r\nINIT_LIST_HEAD(&hostdata->disconnected);\r\nhostdata->flags = flags;\r\nINIT_WORK(&hostdata->main_task, NCR5380_main);\r\nhostdata->work_q = alloc_workqueue("ncr5380_%d",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM,\r\n1, instance->host_no);\r\nif (!hostdata->work_q)\r\nreturn -ENOMEM;\r\nsnprintf(hostdata->info, sizeof(hostdata->info),\r\n"%s, irq %d, io_port 0x%lx, base 0x%lx, can_queue %d, cmd_per_lun %d, sg_tablesize %d, this_id %d, flags { %s%s%s}",\r\ninstance->hostt->name, instance->irq, hostdata->io_port,\r\nhostdata->base, instance->can_queue, instance->cmd_per_lun,\r\ninstance->sg_tablesize, instance->this_id,\r\nhostdata->flags & FLAG_DMA_FIXUP ? "DMA_FIXUP " : "",\r\nhostdata->flags & FLAG_NO_PSEUDO_DMA ? "NO_PSEUDO_DMA " : "",\r\nhostdata->flags & FLAG_TOSHIBA_DELAY ? "TOSHIBA_DELAY " : "");\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\ni = 0;\r\ndeadline = jiffies + 1;\r\ndo {\r\ncpu_relax();\r\n} while (time_is_after_jiffies(deadline));\r\ndeadline += msecs_to_jiffies(256);\r\ndo {\r\nNCR5380_read(STATUS_REG);\r\n++i;\r\ncpu_relax();\r\n} while (time_is_after_jiffies(deadline));\r\naccesses_per_ms = i / 256;\r\nhostdata->poll_loops = NCR5380_REG_POLL_TIME * accesses_per_ms / 2;\r\nreturn 0;\r\n}\r\nstatic int NCR5380_maybe_reset_bus(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint pass;\r\nfor (pass = 1; (NCR5380_read(STATUS_REG) & SR_BSY) && pass <= 6; ++pass) {\r\nswitch (pass) {\r\ncase 1:\r\ncase 3:\r\ncase 5:\r\nshost_printk(KERN_ERR, instance, "SCSI bus busy, waiting up to five seconds\n");\r\nNCR5380_poll_politely(hostdata,\r\nSTATUS_REG, SR_BSY, 0, 5 * HZ);\r\nbreak;\r\ncase 2:\r\nshost_printk(KERN_ERR, instance, "bus busy, attempting abort\n");\r\ndo_abort(instance);\r\nbreak;\r\ncase 4:\r\nshost_printk(KERN_ERR, instance, "bus busy, attempting reset\n");\r\ndo_reset(instance);\r\nif (hostdata->flags & FLAG_TOSHIBA_DELAY)\r\nmsleep(2500);\r\nelse\r\nmsleep(500);\r\nbreak;\r\ncase 6:\r\nshost_printk(KERN_ERR, instance, "bus locked solid\n");\r\nreturn -ENXIO;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void NCR5380_exit(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\ncancel_work_sync(&hostdata->main_task);\r\ndestroy_workqueue(hostdata->work_q);\r\n}\r\nstatic void complete_cmd(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\ndsprintk(NDEBUG_QUEUES, instance, "complete_cmd: cmd %p\n", cmd);\r\nif (hostdata->sensing == cmd) {\r\nif ((cmd->result & 0xff) != SAM_STAT_GOOD) {\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nset_host_byte(cmd, DID_ERROR);\r\n} else\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nhostdata->sensing = NULL;\r\n}\r\nhostdata->busy[scmd_id(cmd)] &= ~(1 << cmd->device->lun);\r\ncmd->scsi_done(cmd);\r\n}\r\nstatic int NCR5380_queue_command(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(cmd);\r\nunsigned long flags;\r\n#if (NDEBUG & NDEBUG_NO_WRITE)\r\nswitch (cmd->cmnd[0]) {\r\ncase WRITE_6:\r\ncase WRITE_10:\r\nshost_printk(KERN_DEBUG, instance, "WRITE attempted with NDEBUG_NO_WRITE set\n");\r\ncmd->result = (DID_ERROR << 16);\r\ncmd->scsi_done(cmd);\r\nreturn 0;\r\n}\r\n#endif\r\ncmd->result = 0;\r\nif (!NCR5380_acquire_dma_irq(instance))\r\nreturn SCSI_MLQUEUE_HOST_BUSY;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\nif (cmd->cmnd[0] == REQUEST_SENSE)\r\nlist_add(&ncmd->list, &hostdata->unissued);\r\nelse\r\nlist_add_tail(&ncmd->list, &hostdata->unissued);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\ndsprintk(NDEBUG_QUEUES, instance, "command %p added to %s of queue\n",\r\ncmd, (cmd->cmnd[0] == REQUEST_SENSE) ? "head" : "tail");\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\nreturn 0;\r\n}\r\nstatic inline void maybe_release_dma_irq(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nif (list_empty(&hostdata->disconnected) &&\r\nlist_empty(&hostdata->unissued) &&\r\nlist_empty(&hostdata->autosense) &&\r\n!hostdata->connected &&\r\n!hostdata->selecting) {\r\nNCR5380_release_dma_irq(instance);\r\n}\r\n}\r\nstatic struct scsi_cmnd *dequeue_next_cmd(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct NCR5380_cmd *ncmd;\r\nstruct scsi_cmnd *cmd;\r\nif (hostdata->sensing || list_empty(&hostdata->autosense)) {\r\nlist_for_each_entry(ncmd, &hostdata->unissued, list) {\r\ncmd = NCR5380_to_scmd(ncmd);\r\ndsprintk(NDEBUG_QUEUES, instance, "dequeue: cmd=%p target=%d busy=0x%02x lun=%llu\n",\r\ncmd, scmd_id(cmd), hostdata->busy[scmd_id(cmd)], cmd->device->lun);\r\nif (!(hostdata->busy[scmd_id(cmd)] & (1 << cmd->device->lun))) {\r\nlist_del(&ncmd->list);\r\ndsprintk(NDEBUG_QUEUES, instance,\r\n"dequeue: removed %p from issue queue\n", cmd);\r\nreturn cmd;\r\n}\r\n}\r\n} else {\r\nncmd = list_first_entry(&hostdata->autosense,\r\nstruct NCR5380_cmd, list);\r\nlist_del(&ncmd->list);\r\ncmd = NCR5380_to_scmd(ncmd);\r\ndsprintk(NDEBUG_QUEUES, instance,\r\n"dequeue: removed %p from autosense queue\n", cmd);\r\nscsi_eh_prep_cmnd(cmd, &hostdata->ses, NULL, 0, ~0);\r\nhostdata->sensing = cmd;\r\nreturn cmd;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void requeue_cmd(struct Scsi_Host *instance, struct scsi_cmnd *cmd)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(cmd);\r\nif (hostdata->sensing == cmd) {\r\nscsi_eh_restore_cmnd(cmd, &hostdata->ses);\r\nlist_add(&ncmd->list, &hostdata->autosense);\r\nhostdata->sensing = NULL;\r\n} else\r\nlist_add(&ncmd->list, &hostdata->unissued);\r\n}\r\nstatic void NCR5380_main(struct work_struct *work)\r\n{\r\nstruct NCR5380_hostdata *hostdata =\r\ncontainer_of(work, struct NCR5380_hostdata, main_task);\r\nstruct Scsi_Host *instance = hostdata->host;\r\nint done;\r\ndo {\r\ndone = 1;\r\nspin_lock_irq(&hostdata->lock);\r\nwhile (!hostdata->connected && !hostdata->selecting) {\r\nstruct scsi_cmnd *cmd = dequeue_next_cmd(instance);\r\nif (!cmd)\r\nbreak;\r\ndsprintk(NDEBUG_MAIN, instance, "main: dequeued %p\n", cmd);\r\nif (!NCR5380_select(instance, cmd)) {\r\ndsprintk(NDEBUG_MAIN, instance, "main: select complete\n");\r\nmaybe_release_dma_irq(instance);\r\n} else {\r\ndsprintk(NDEBUG_MAIN | NDEBUG_QUEUES, instance,\r\n"main: select failed, returning %p to queue\n", cmd);\r\nrequeue_cmd(instance, cmd);\r\n}\r\n}\r\nif (hostdata->connected && !hostdata->dma_len) {\r\ndsprintk(NDEBUG_MAIN, instance, "main: performing information transfer\n");\r\nNCR5380_information_transfer(instance);\r\ndone = 0;\r\n}\r\nspin_unlock_irq(&hostdata->lock);\r\nif (!done)\r\ncond_resched();\r\n} while (!done);\r\n}\r\nstatic void NCR5380_dma_complete(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint transferred;\r\nunsigned char **data;\r\nint *count;\r\nint saved_data = 0, overrun = 0;\r\nunsigned char p;\r\nif (hostdata->read_overruns) {\r\np = hostdata->connected->SCp.phase;\r\nif (p & SR_IO) {\r\nudelay(10);\r\nif ((NCR5380_read(BUS_AND_STATUS_REG) &\r\n(BASR_PHASE_MATCH | BASR_ACK)) ==\r\n(BASR_PHASE_MATCH | BASR_ACK)) {\r\nsaved_data = NCR5380_read(INPUT_DATA_REG);\r\noverrun = 1;\r\ndsprintk(NDEBUG_DMA, instance, "read overrun handled\n");\r\n}\r\n}\r\n}\r\n#ifdef CONFIG_SUN3\r\nif ((sun3scsi_dma_finish(rq_data_dir(hostdata->connected->request)))) {\r\npr_err("scsi%d: overrun in UDC counter -- not prepared to deal with this!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\nif ((NCR5380_read(BUS_AND_STATUS_REG) & (BASR_PHASE_MATCH | BASR_ACK)) ==\r\n(BASR_PHASE_MATCH | BASR_ACK)) {\r\npr_err("scsi%d: BASR %02x\n", instance->host_no,\r\nNCR5380_read(BUS_AND_STATUS_REG));\r\npr_err("scsi%d: bus stuck in data phase -- probably a single byte overrun!\n",\r\ninstance->host_no);\r\nBUG();\r\n}\r\n#endif\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\ntransferred = hostdata->dma_len - NCR5380_dma_residual(hostdata);\r\nhostdata->dma_len = 0;\r\ndata = (unsigned char **)&hostdata->connected->SCp.ptr;\r\ncount = &hostdata->connected->SCp.this_residual;\r\n*data += transferred;\r\n*count -= transferred;\r\nif (hostdata->read_overruns) {\r\nint cnt, toPIO;\r\nif ((NCR5380_read(STATUS_REG) & PHASE_MASK) == p && (p & SR_IO)) {\r\ncnt = toPIO = hostdata->read_overruns;\r\nif (overrun) {\r\ndsprintk(NDEBUG_DMA, instance,\r\n"Got an input overrun, using saved byte\n");\r\n*(*data)++ = saved_data;\r\n(*count)--;\r\ncnt--;\r\ntoPIO--;\r\n}\r\nif (toPIO > 0) {\r\ndsprintk(NDEBUG_DMA, instance,\r\n"Doing %d byte PIO to 0x%p\n", cnt, *data);\r\nNCR5380_transfer_pio(instance, &p, &cnt, data);\r\n*count -= toPIO - cnt;\r\n}\r\n}\r\n}\r\n}\r\nstatic irqreturn_t __maybe_unused NCR5380_intr(int irq, void *dev_id)\r\n{\r\nstruct Scsi_Host *instance = dev_id;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint handled = 0;\r\nunsigned char basr;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\nbasr = NCR5380_read(BUS_AND_STATUS_REG);\r\nif (basr & BASR_IRQ) {\r\nunsigned char mr = NCR5380_read(MODE_REG);\r\nunsigned char sr = NCR5380_read(STATUS_REG);\r\ndsprintk(NDEBUG_INTR, instance, "IRQ %d, BASR 0x%02x, SR 0x%02x, MR 0x%02x\n",\r\nirq, basr, sr, mr);\r\nif ((mr & MR_DMA_MODE) || (mr & MR_MONITOR_BSY)) {\r\ndsprintk(NDEBUG_INTR, instance, "interrupt in DMA mode\n");\r\nif (hostdata->connected) {\r\nNCR5380_dma_complete(instance);\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\n} else {\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\n}\r\n} else if ((NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_mask) &&\r\n(sr & (SR_SEL | SR_IO | SR_BSY | SR_RST)) == (SR_SEL | SR_IO)) {\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\ndsprintk(NDEBUG_INTR, instance, "interrupt with SEL and IO\n");\r\nif (!hostdata->connected) {\r\nNCR5380_reselect(instance);\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\n}\r\nif (!hostdata->connected)\r\nNCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);\r\n} else {\r\nNCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\ndsprintk(NDEBUG_INTR, instance, "unknown interrupt\n");\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\n}\r\nhandled = 1;\r\n} else {\r\ndsprintk(NDEBUG_INTR, instance, "interrupt without IRQ bit\n");\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\n}\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic struct scsi_cmnd *NCR5380_select(struct Scsi_Host *instance,\r\nstruct scsi_cmnd *cmd)\r\n__releases(&hostdata->lock\r\nstatic int NCR5380_transfer_pio(struct Scsi_Host *instance,\r\nunsigned char *phase, int *count,\r\nunsigned char **data)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char p = *phase, tmp;\r\nint c = *count;\r\nunsigned char *d = *data;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\ndo {\r\nif (NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, SR_REQ, HZ) < 0)\r\nbreak;\r\ndsprintk(NDEBUG_HANDSHAKE, instance, "REQ asserted\n");\r\nif ((NCR5380_read(STATUS_REG) & PHASE_MASK) != p) {\r\ndsprintk(NDEBUG_PIO, instance, "phase mismatch\n");\r\nNCR5380_dprint_phase(NDEBUG_PIO, instance);\r\nbreak;\r\n}\r\nif (!(p & SR_IO))\r\nNCR5380_write(OUTPUT_DATA_REG, *d);\r\nelse\r\n*d = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n++d;\r\nif (!(p & SR_IO)) {\r\nif (!((p & SR_MSG) && c > 1)) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ACK);\r\n} else {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN);\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |\r\nICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\n}\r\n} else {\r\nNCR5380_dprint(NDEBUG_PIO, instance);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n}\r\nif (NCR5380_poll_politely(hostdata,\r\nSTATUS_REG, SR_REQ, 0, 5 * HZ) < 0)\r\nbreak;\r\ndsprintk(NDEBUG_HANDSHAKE, instance, "REQ negated, handshake complete\n");\r\nif (!(p == PHASE_MSGIN && c == 1)) {\r\nif (p == PHASE_MSGOUT && c > 1)\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nelse\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n}\r\n} while (--c);\r\ndsprintk(NDEBUG_PIO, instance, "residual %d\n", c);\r\n*count = c;\r\n*data = d;\r\ntmp = NCR5380_read(STATUS_REG);\r\nif ((tmp & SR_REQ) || ((tmp & SR_IO) && c == 0))\r\n*phase = tmp & PHASE_MASK;\r\nelse\r\n*phase = PHASE_UNKNOWN;\r\nif (!c || (*phase == p))\r\nreturn 0;\r\nelse\r\nreturn -1;\r\n}\r\nstatic void do_reset(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata __maybe_unused *hostdata = shost_priv(instance);\r\nunsigned long flags;\r\nlocal_irq_save(flags);\r\nNCR5380_write(TARGET_COMMAND_REG,\r\nPHASE_SR_TO_TCR(NCR5380_read(STATUS_REG) & PHASE_MASK));\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);\r\nudelay(50);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\n(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic int do_abort(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char *msgptr, phase, tmp;\r\nint len;\r\nint rc;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\nrc = NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, SR_REQ, 10 * HZ);\r\nif (rc < 0)\r\ngoto timeout;\r\ntmp = NCR5380_read(STATUS_REG) & PHASE_MASK;\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));\r\nif (tmp != PHASE_MSGOUT) {\r\nNCR5380_write(INITIATOR_COMMAND_REG,\r\nICR_BASE | ICR_ASSERT_ATN | ICR_ASSERT_ACK);\r\nrc = NCR5380_poll_politely(hostdata, STATUS_REG, SR_REQ, 0, 3 * HZ);\r\nif (rc < 0)\r\ngoto timeout;\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);\r\n}\r\ntmp = ABORT;\r\nmsgptr = &tmp;\r\nlen = 1;\r\nphase = PHASE_MSGOUT;\r\nNCR5380_transfer_pio(instance, &phase, &len, &msgptr);\r\nreturn len ? -1 : 0;\r\ntimeout:\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nreturn -1;\r\n}\r\nstatic int NCR5380_transfer_dma(struct Scsi_Host *instance,\r\nunsigned char *phase, int *count,\r\nunsigned char **data)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint c = *count;\r\nunsigned char p = *phase;\r\nunsigned char *d = *data;\r\nunsigned char tmp;\r\nint result = 0;\r\nif ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {\r\n*phase = tmp;\r\nreturn -1;\r\n}\r\nhostdata->connected->SCp.phase = p;\r\nif (p & SR_IO) {\r\nif (hostdata->read_overruns)\r\nc -= hostdata->read_overruns;\r\nelse if (hostdata->flags & FLAG_DMA_FIXUP)\r\n--c;\r\n}\r\ndsprintk(NDEBUG_DMA, instance, "initializing DMA %s: length %d, address %p\n",\r\n(p & SR_IO) ? "receive" : "send", c, d);\r\n#ifdef CONFIG_SUN3\r\nsun3scsi_dma_start(c, *data);\r\n#endif\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));\r\nNCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_MONITOR_BSY |\r\nMR_ENABLE_EOP_INTR);\r\nif (!(hostdata->flags & FLAG_LATE_DMA_SETUP)) {\r\nif (p & SR_IO)\r\nresult = NCR5380_dma_recv_setup(hostdata, d, c);\r\nelse\r\nresult = NCR5380_dma_send_setup(hostdata, d, c);\r\n}\r\nif (p & SR_IO) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nNCR5380_io_delay(1);\r\nNCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);\r\n} else {\r\nNCR5380_io_delay(1);\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);\r\nNCR5380_io_delay(1);\r\nNCR5380_write(START_DMA_SEND_REG, 0);\r\nNCR5380_io_delay(1);\r\n}\r\n#ifdef CONFIG_SUN3\r\n#ifdef SUN3_SCSI_VME\r\ndregs->csr |= CSR_DMA_ENABLE;\r\n#endif\r\nsun3_dma_active = 1;\r\n#endif\r\nif (hostdata->flags & FLAG_LATE_DMA_SETUP) {\r\nif (p & SR_IO)\r\nresult = NCR5380_dma_recv_setup(hostdata, d, c);\r\nelse\r\nresult = NCR5380_dma_send_setup(hostdata, d, c);\r\n}\r\nif (result < 0)\r\nreturn result;\r\nif (result > 0) {\r\nhostdata->dma_len = result;\r\nreturn 0;\r\n}\r\nhostdata->dma_len = c;\r\nif (hostdata->flags & FLAG_DMA_FIXUP) {\r\nif (p & SR_IO) {\r\nif (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\r\nBASR_DRQ, BASR_DRQ, HZ) < 0) {\r\nresult = -1;\r\nshost_printk(KERN_ERR, instance, "PDMA read: DRQ timeout\n");\r\n}\r\nif (NCR5380_poll_politely(hostdata, STATUS_REG,\r\nSR_REQ, 0, HZ) < 0) {\r\nresult = -1;\r\nshost_printk(KERN_ERR, instance, "PDMA read: !REQ timeout\n");\r\n}\r\nd[*count - 1] = NCR5380_read(INPUT_DATA_REG);\r\n} else {\r\nif (NCR5380_poll_politely2(hostdata,\r\nBUS_AND_STATUS_REG, BASR_DRQ, BASR_DRQ,\r\nBUS_AND_STATUS_REG, BASR_PHASE_MATCH, 0, HZ) < 0) {\r\nresult = -1;\r\nshost_printk(KERN_ERR, instance, "PDMA write: DRQ and phase timeout\n");\r\n}\r\n}\r\n}\r\nNCR5380_dma_complete(instance);\r\nreturn result;\r\n}\r\nstatic void NCR5380_information_transfer(struct Scsi_Host *instance)\r\n__releases(&hostdata->lock\r\nstatic void NCR5380_reselect(struct Scsi_Host *instance)\r\n{\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned char target_mask;\r\nunsigned char lun;\r\nunsigned char msg[3];\r\nstruct NCR5380_cmd *ncmd;\r\nstruct scsi_cmnd *tmp;\r\nNCR5380_write(MODE_REG, MR_BASE);\r\ntarget_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);\r\ndsprintk(NDEBUG_RESELECTION, instance, "reselect\n");\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);\r\nif (NCR5380_poll_politely(hostdata,\r\nSTATUS_REG, SR_SEL, 0, 2 * HZ) < 0) {\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nreturn;\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nif (NCR5380_poll_politely(hostdata,\r\nSTATUS_REG, SR_REQ, SR_REQ, 2 * HZ) < 0) {\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n#ifdef CONFIG_SUN3\r\nNCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(PHASE_MSGIN));\r\nmsg[0] = NCR5380_read(CURRENT_SCSI_DATA_REG);\r\n#else\r\n{\r\nint len = 1;\r\nunsigned char *data = msg;\r\nunsigned char phase = PHASE_MSGIN;\r\nNCR5380_transfer_pio(instance, &phase, &len, &data);\r\nif (len) {\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nif (!(msg[0] & 0x80)) {\r\nshost_printk(KERN_ERR, instance, "expecting IDENTIFY message, got ");\r\nspi_print_msg(msg);\r\nprintk("\n");\r\ndo_abort(instance);\r\nreturn;\r\n}\r\nlun = msg[0] & 0x07;\r\ntmp = NULL;\r\nlist_for_each_entry(ncmd, &hostdata->disconnected, list) {\r\nstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\r\nif (target_mask == (1 << scmd_id(cmd)) &&\r\nlun == (u8)cmd->device->lun) {\r\nlist_del(&ncmd->list);\r\ntmp = cmd;\r\nbreak;\r\n}\r\n}\r\nif (tmp) {\r\ndsprintk(NDEBUG_RESELECTION | NDEBUG_QUEUES, instance,\r\n"reselect: removed %p from disconnected queue\n", tmp);\r\n} else {\r\nshost_printk(KERN_ERR, instance, "target bitmask 0x%02x lun %d not in disconnected queue.\n",\r\ntarget_mask, lun);\r\ndo_abort(instance);\r\nreturn;\r\n}\r\n#ifdef CONFIG_SUN3\r\nif (sun3_dma_setup_done != tmp) {\r\nint count;\r\nif (!tmp->SCp.this_residual && tmp->SCp.buffers_residual) {\r\n++tmp->SCp.buffer;\r\n--tmp->SCp.buffers_residual;\r\ntmp->SCp.this_residual = tmp->SCp.buffer->length;\r\ntmp->SCp.ptr = sg_virt(tmp->SCp.buffer);\r\n}\r\ncount = sun3scsi_dma_xfer_len(hostdata, tmp);\r\nif (count > 0) {\r\nif (rq_data_dir(tmp->request))\r\nsun3scsi_dma_send_setup(hostdata,\r\ntmp->SCp.ptr, count);\r\nelse\r\nsun3scsi_dma_recv_setup(hostdata,\r\ntmp->SCp.ptr, count);\r\nsun3_dma_setup_done = tmp;\r\n}\r\n}\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);\r\n#endif\r\nNCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);\r\nhostdata->connected = tmp;\r\ndsprintk(NDEBUG_RESELECTION, instance, "nexus established, target %d, lun %llu\n",\r\nscmd_id(tmp), tmp->device->lun);\r\n}\r\nstatic bool list_find_cmd(struct list_head *haystack,\r\nstruct scsi_cmnd *needle)\r\n{\r\nstruct NCR5380_cmd *ncmd;\r\nlist_for_each_entry(ncmd, haystack, list)\r\nif (NCR5380_to_scmd(ncmd) == needle)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic bool list_del_cmd(struct list_head *haystack,\r\nstruct scsi_cmnd *needle)\r\n{\r\nif (list_find_cmd(haystack, needle)) {\r\nstruct NCR5380_cmd *ncmd = scsi_cmd_priv(needle);\r\nlist_del(&ncmd->list);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int NCR5380_abort(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nunsigned long flags;\r\nint result = SUCCESS;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\n#if (NDEBUG & NDEBUG_ANY)\r\nscmd_printk(KERN_INFO, cmd, __func__);\r\n#endif\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_dprint_phase(NDEBUG_ANY, instance);\r\nif (list_del_cmd(&hostdata->unissued, cmd)) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: removed %p from issue queue\n", cmd);\r\ncmd->result = DID_ABORT << 16;\r\ncmd->scsi_done(cmd);\r\ngoto out;\r\n}\r\nif (hostdata->selecting == cmd) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: cmd %p == selecting\n", cmd);\r\nhostdata->selecting = NULL;\r\ncmd->result = DID_ABORT << 16;\r\ncomplete_cmd(instance, cmd);\r\ngoto out;\r\n}\r\nif (list_del_cmd(&hostdata->disconnected, cmd)) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: removed %p from disconnected list\n", cmd);\r\nset_host_byte(cmd, DID_ERROR);\r\ncomplete_cmd(instance, cmd);\r\nresult = FAILED;\r\ngoto out;\r\n}\r\nif (hostdata->connected == cmd) {\r\ndsprintk(NDEBUG_ABORT, instance, "abort: cmd %p is connected\n", cmd);\r\nhostdata->connected = NULL;\r\nhostdata->dma_len = 0;\r\nif (do_abort(instance)) {\r\nset_host_byte(cmd, DID_ERROR);\r\ncomplete_cmd(instance, cmd);\r\nresult = FAILED;\r\ngoto out;\r\n}\r\nset_host_byte(cmd, DID_ABORT);\r\ncomplete_cmd(instance, cmd);\r\ngoto out;\r\n}\r\nif (list_del_cmd(&hostdata->autosense, cmd)) {\r\ndsprintk(NDEBUG_ABORT, instance,\r\n"abort: removed %p from sense queue\n", cmd);\r\nset_host_byte(cmd, DID_ERROR);\r\ncomplete_cmd(instance, cmd);\r\n}\r\nout:\r\nif (result == FAILED)\r\ndsprintk(NDEBUG_ABORT, instance, "abort: failed to abort %p\n", cmd);\r\nelse\r\ndsprintk(NDEBUG_ABORT, instance, "abort: successfully aborted %p\n", cmd);\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\nmaybe_release_dma_irq(instance);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn result;\r\n}\r\nstatic int NCR5380_bus_reset(struct scsi_cmnd *cmd)\r\n{\r\nstruct Scsi_Host *instance = cmd->device->host;\r\nstruct NCR5380_hostdata *hostdata = shost_priv(instance);\r\nint i;\r\nunsigned long flags;\r\nstruct NCR5380_cmd *ncmd;\r\nspin_lock_irqsave(&hostdata->lock, flags);\r\n#if (NDEBUG & NDEBUG_ANY)\r\nscmd_printk(KERN_INFO, cmd, __func__);\r\n#endif\r\nNCR5380_dprint(NDEBUG_ANY, instance);\r\nNCR5380_dprint_phase(NDEBUG_ANY, instance);\r\ndo_reset(instance);\r\nNCR5380_write(MODE_REG, MR_BASE);\r\nNCR5380_write(TARGET_COMMAND_REG, 0);\r\nNCR5380_write(SELECT_ENABLE_REG, 0);\r\nif (list_del_cmd(&hostdata->unissued, cmd)) {\r\ncmd->result = DID_RESET << 16;\r\ncmd->scsi_done(cmd);\r\n}\r\nif (hostdata->selecting) {\r\nhostdata->selecting->result = DID_RESET << 16;\r\ncomplete_cmd(instance, hostdata->selecting);\r\nhostdata->selecting = NULL;\r\n}\r\nlist_for_each_entry(ncmd, &hostdata->disconnected, list) {\r\nstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\r\nset_host_byte(cmd, DID_RESET);\r\ncomplete_cmd(instance, cmd);\r\n}\r\nINIT_LIST_HEAD(&hostdata->disconnected);\r\nlist_for_each_entry(ncmd, &hostdata->autosense, list) {\r\nstruct scsi_cmnd *cmd = NCR5380_to_scmd(ncmd);\r\nset_host_byte(cmd, DID_RESET);\r\ncmd->scsi_done(cmd);\r\n}\r\nINIT_LIST_HEAD(&hostdata->autosense);\r\nif (hostdata->connected) {\r\nset_host_byte(hostdata->connected, DID_RESET);\r\ncomplete_cmd(instance, hostdata->connected);\r\nhostdata->connected = NULL;\r\n}\r\nfor (i = 0; i < 8; ++i)\r\nhostdata->busy[i] = 0;\r\nhostdata->dma_len = 0;\r\nqueue_work(hostdata->work_q, &hostdata->main_task);\r\nmaybe_release_dma_irq(instance);\r\nspin_unlock_irqrestore(&hostdata->lock, flags);\r\nreturn SUCCESS;\r\n}
