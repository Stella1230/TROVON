static int pvr2_i2c_write(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,\r\nu8 *data,\r\nu16 length)\r\n{\r\nint ret;\r\nif (!data) length = 0;\r\nif (length > (sizeof(hdw->cmd_buffer) - 3)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Killing an I2C write to %u that is too large (desired=%u limit=%u)",\r\ni2c_addr,\r\nlength,(unsigned int)(sizeof(hdw->cmd_buffer) - 3));\r\nreturn -ENOTSUPP;\r\n}\r\nLOCK_TAKE(hdw->ctl_lock);\r\nmemset(hdw->cmd_buffer, 0, sizeof(hdw->cmd_buffer));\r\nhdw->cmd_buffer[0] = FX2CMD_I2C_WRITE;\r\nhdw->cmd_buffer[1] = i2c_addr;\r\nhdw->cmd_buffer[2] = length;\r\nif (length) memcpy(hdw->cmd_buffer + 3, data, length);\r\nret = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,\r\nlength + 3,\r\nhdw->cmd_buffer,\r\n1);\r\nif (!ret) {\r\nif (hdw->cmd_buffer[0] != 8) {\r\nret = -EIO;\r\nif (hdw->cmd_buffer[0] != 7) {\r\ntrace_i2c("unexpected status from i2_write[%d]: %d",\r\ni2c_addr,hdw->cmd_buffer[0]);\r\n}\r\n}\r\n}\r\nLOCK_GIVE(hdw->ctl_lock);\r\nreturn ret;\r\n}\r\nstatic int pvr2_i2c_read(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,\r\nu8 *data,\r\nu16 dlen,\r\nu8 *res,\r\nu16 rlen)\r\n{\r\nint ret;\r\nif (!data) dlen = 0;\r\nif (dlen > (sizeof(hdw->cmd_buffer) - 4)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Killing an I2C read to %u that has wlen too large (desired=%u limit=%u)",\r\ni2c_addr,\r\ndlen,(unsigned int)(sizeof(hdw->cmd_buffer) - 4));\r\nreturn -ENOTSUPP;\r\n}\r\nif (res && (rlen > (sizeof(hdw->cmd_buffer) - 1))) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"Killing an I2C read to %u that has rlen too large (desired=%u limit=%u)",\r\ni2c_addr,\r\nrlen,(unsigned int)(sizeof(hdw->cmd_buffer) - 1));\r\nreturn -ENOTSUPP;\r\n}\r\nLOCK_TAKE(hdw->ctl_lock);\r\nmemset(hdw->cmd_buffer, 0, sizeof(hdw->cmd_buffer));\r\nhdw->cmd_buffer[0] = FX2CMD_I2C_READ;\r\nhdw->cmd_buffer[1] = dlen;\r\nhdw->cmd_buffer[2] = rlen;\r\nhdw->cmd_buffer[3] = i2c_addr;\r\nif (dlen) memcpy(hdw->cmd_buffer + 4, data, dlen);\r\nret = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,\r\n4 + dlen,\r\nhdw->cmd_buffer,\r\nrlen + 1);\r\nif (!ret) {\r\nif (hdw->cmd_buffer[0] != 8) {\r\nret = -EIO;\r\nif (hdw->cmd_buffer[0] != 7) {\r\ntrace_i2c("unexpected status from i2_read[%d]: %d",\r\ni2c_addr,hdw->cmd_buffer[0]);\r\n}\r\n}\r\n}\r\nif (res && rlen) {\r\nif (ret) {\r\nmemset(res, 0, rlen);\r\n} else {\r\nmemcpy(res, hdw->cmd_buffer + 1, rlen);\r\n}\r\n}\r\nLOCK_GIVE(hdw->ctl_lock);\r\nreturn ret;\r\n}\r\nstatic int pvr2_i2c_basic_op(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,\r\nu8 *wdata,\r\nu16 wlen,\r\nu8 *rdata,\r\nu16 rlen)\r\n{\r\nif (!rdata) rlen = 0;\r\nif (!wdata) wlen = 0;\r\nif (rlen || !wlen) {\r\nreturn pvr2_i2c_read(hdw,i2c_addr,wdata,wlen,rdata,rlen);\r\n} else {\r\nreturn pvr2_i2c_write(hdw,i2c_addr,wdata,wlen);\r\n}\r\n}\r\nstatic int i2c_24xxx_ir(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\r\n{\r\nu8 dat[4];\r\nunsigned int stat;\r\nif (!(rlen || wlen)) {\r\nreturn 0;\r\n}\r\nif ((wlen != 0) || (rlen == 0)) return -EIO;\r\nif (rlen < 3) {\r\nif (rlen > 0) rdata[0] = 0;\r\nif (rlen > 1) rdata[1] = 0;\r\nreturn 0;\r\n}\r\nLOCK_TAKE(hdw->ctl_lock); do {\r\nhdw->cmd_buffer[0] = FX2CMD_GET_IR_CODE;\r\nstat = pvr2_send_request(hdw,\r\nhdw->cmd_buffer,1,\r\nhdw->cmd_buffer,4);\r\ndat[0] = hdw->cmd_buffer[0];\r\ndat[1] = hdw->cmd_buffer[1];\r\ndat[2] = hdw->cmd_buffer[2];\r\ndat[3] = hdw->cmd_buffer[3];\r\n} while (0); LOCK_GIVE(hdw->ctl_lock);\r\nif (stat != 0) return stat;\r\nrdata[2] = 0xc1;\r\nif (dat[0] != 1) {\r\nrdata[0] = 0;\r\nrdata[1] = 0;\r\n} else {\r\nu16 val;\r\nval = dat[1];\r\nval <<= 8;\r\nval |= dat[2];\r\nval >>= 1;\r\nval &= ~0x0003;\r\nval |= 0x8000;\r\nrdata[0] = (val >> 8) & 0xffu;\r\nrdata[1] = val & 0xffu;\r\n}\r\nreturn 0;\r\n}\r\nstatic int i2c_hack_wm8775(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\r\n{\r\nif (!(rlen || wlen)) {\r\nreturn 0;\r\n}\r\nreturn pvr2_i2c_basic_op(hdw,i2c_addr,wdata,wlen,rdata,rlen);\r\n}\r\nstatic int i2c_black_hole(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\r\n{\r\nreturn -EIO;\r\n}\r\nstatic int i2c_hack_cx25840(struct pvr2_hdw *hdw,\r\nu8 i2c_addr,u8 *wdata,u16 wlen,u8 *rdata,u16 rlen)\r\n{\r\nint ret;\r\nunsigned int subaddr;\r\nu8 wbuf[2];\r\nint state = hdw->i2c_cx25840_hack_state;\r\nif (!(rlen || wlen)) {\r\nreturn 0;\r\n}\r\nif (state == 3) {\r\nreturn pvr2_i2c_basic_op(hdw,i2c_addr,wdata,wlen,rdata,rlen);\r\n}\r\nif (wlen == 0) {\r\nswitch (state) {\r\ncase 1: subaddr = 0x0100; break;\r\ncase 2: subaddr = 0x0101; break;\r\ndefault: goto fail;\r\n}\r\n} else if (wlen == 2) {\r\nsubaddr = (wdata[0] << 8) | wdata[1];\r\nswitch (subaddr) {\r\ncase 0x0100: state = 1; break;\r\ncase 0x0101: state = 2; break;\r\ndefault: goto fail;\r\n}\r\n} else {\r\ngoto fail;\r\n}\r\nif (!rlen) goto success;\r\nstate = 0;\r\nif (rlen != 1) goto fail;\r\nwbuf[0] = subaddr >> 8;\r\nwbuf[1] = subaddr;\r\nret = pvr2_i2c_basic_op(hdw,i2c_addr,wbuf,2,rdata,rlen);\r\nif ((ret != 0) || (*rdata == 0x04) || (*rdata == 0x0a)) {\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"WARNING: Detected a wedged cx25840 chip; the device will not work.");\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"WARNING: Try power cycling the pvrusb2 device.");\r\npvr2_trace(PVR2_TRACE_ERROR_LEGS,\r\n"WARNING: Disabling further access to the device to prevent other foul-ups.");\r\nhdw->i2c_func[0x44] = NULL;\r\npvr2_hdw_render_useless(hdw);\r\ngoto fail;\r\n}\r\npvr2_trace(PVR2_TRACE_CHIPS,"cx25840 appears to be OK.");\r\nstate = 3;\r\nsuccess:\r\nhdw->i2c_cx25840_hack_state = state;\r\nreturn 0;\r\nfail:\r\nhdw->i2c_cx25840_hack_state = state;\r\nreturn -EIO;\r\n}\r\nstatic int pvr2_i2c_xfer(struct i2c_adapter *i2c_adap,\r\nstruct i2c_msg msgs[],\r\nint num)\r\n{\r\nint ret = -ENOTSUPP;\r\npvr2_i2c_func funcp = NULL;\r\nstruct pvr2_hdw *hdw = (struct pvr2_hdw *)(i2c_adap->algo_data);\r\nif (!num) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (msgs[0].addr < PVR2_I2C_FUNC_CNT) {\r\nfuncp = hdw->i2c_func[msgs[0].addr];\r\n}\r\nif (!funcp) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\nif (num == 1) {\r\nif (msgs[0].flags & I2C_M_RD) {\r\nu16 tcnt,bcnt,offs;\r\nif (!msgs[0].len) {\r\nif (funcp(hdw,msgs[0].addr,NULL,0,NULL,0)) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\nret = 1;\r\ngoto done;\r\n}\r\ntcnt = msgs[0].len;\r\noffs = 0;\r\nwhile (tcnt) {\r\nbcnt = tcnt;\r\nif (bcnt > sizeof(hdw->cmd_buffer)-1) {\r\nbcnt = sizeof(hdw->cmd_buffer)-1;\r\n}\r\nif (funcp(hdw,msgs[0].addr,NULL,0,\r\nmsgs[0].buf+offs,bcnt)) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\noffs += bcnt;\r\ntcnt -= bcnt;\r\n}\r\nret = 1;\r\ngoto done;\r\n} else {\r\nret = 1;\r\nif (funcp(hdw,msgs[0].addr,\r\nmsgs[0].buf,msgs[0].len,NULL,0)) {\r\nret = -EIO;\r\n}\r\ngoto done;\r\n}\r\n} else if (num == 2) {\r\nif (msgs[0].addr != msgs[1].addr) {\r\ntrace_i2c("i2c refusing 2 phase transfer with conflicting target addresses");\r\nret = -ENOTSUPP;\r\ngoto done;\r\n}\r\nif ((!((msgs[0].flags & I2C_M_RD))) &&\r\n(msgs[1].flags & I2C_M_RD)) {\r\nu16 tcnt,bcnt,wcnt,offs;\r\ntcnt = msgs[1].len;\r\nwcnt = msgs[0].len;\r\noffs = 0;\r\nwhile (tcnt || wcnt) {\r\nbcnt = tcnt;\r\nif (bcnt > sizeof(hdw->cmd_buffer)-1) {\r\nbcnt = sizeof(hdw->cmd_buffer)-1;\r\n}\r\nif (funcp(hdw,msgs[0].addr,\r\nmsgs[0].buf,wcnt,\r\nmsgs[1].buf+offs,bcnt)) {\r\nret = -EIO;\r\ngoto done;\r\n}\r\noffs += bcnt;\r\ntcnt -= bcnt;\r\nwcnt = 0;\r\n}\r\nret = 2;\r\ngoto done;\r\n} else {\r\ntrace_i2c("i2c refusing complex transfer read0=%d read1=%d",\r\n(msgs[0].flags & I2C_M_RD),\r\n(msgs[1].flags & I2C_M_RD));\r\n}\r\n} else {\r\ntrace_i2c("i2c refusing %d phase transfer",num);\r\n}\r\ndone:\r\nif (pvrusb2_debug & PVR2_TRACE_I2C_TRAF) {\r\nunsigned int idx,offs,cnt;\r\nfor (idx = 0; idx < num; idx++) {\r\ncnt = msgs[idx].len;\r\nprintk(KERN_INFO\r\n"pvrusb2 i2c xfer %u/%u: addr=0x%x len=%d %s",\r\nidx+1,num,\r\nmsgs[idx].addr,\r\ncnt,\r\n(msgs[idx].flags & I2C_M_RD ?\r\n"read" : "write"));\r\nif ((ret > 0) || !(msgs[idx].flags & I2C_M_RD)) {\r\nif (cnt > 8) cnt = 8;\r\nprintk(KERN_CONT " [");\r\nfor (offs = 0; offs < (cnt>8?8:cnt); offs++) {\r\nif (offs) printk(KERN_CONT " ");\r\nprintk(KERN_CONT "%02x",msgs[idx].buf[offs]);\r\n}\r\nif (offs < cnt) printk(KERN_CONT " ...");\r\nprintk(KERN_CONT "]");\r\n}\r\nif (idx+1 == num) {\r\nprintk(KERN_CONT " result=%d",ret);\r\n}\r\nprintk(KERN_CONT "\n");\r\n}\r\nif (!num) {\r\nprintk(KERN_INFO\r\n"pvrusb2 i2c xfer null transfer result=%d\n",\r\nret);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic u32 pvr2_i2c_functionality(struct i2c_adapter *adap)\r\n{\r\nreturn I2C_FUNC_SMBUS_EMUL | I2C_FUNC_I2C;\r\n}\r\nstatic int do_i2c_probe(struct pvr2_hdw *hdw, int addr)\r\n{\r\nstruct i2c_msg msg[1];\r\nint rc;\r\nmsg[0].addr = 0;\r\nmsg[0].flags = I2C_M_RD;\r\nmsg[0].len = 0;\r\nmsg[0].buf = NULL;\r\nmsg[0].addr = addr;\r\nrc = i2c_transfer(&hdw->i2c_adap, msg, ARRAY_SIZE(msg));\r\nreturn rc == 1;\r\n}\r\nstatic void do_i2c_scan(struct pvr2_hdw *hdw)\r\n{\r\nint i;\r\nprintk(KERN_INFO "%s: i2c scan beginning\n", hdw->name);\r\nfor (i = 0; i < 128; i++) {\r\nif (do_i2c_probe(hdw, i)) {\r\nprintk(KERN_INFO "%s: i2c scan: found device @ 0x%x\n",\r\nhdw->name, i);\r\n}\r\n}\r\nprintk(KERN_INFO "%s: i2c scan done.\n", hdw->name);\r\n}\r\nstatic void pvr2_i2c_register_ir(struct pvr2_hdw *hdw)\r\n{\r\nstruct i2c_board_info info;\r\nstruct IR_i2c_init_data *init_data = &hdw->ir_init_data;\r\nif (pvr2_disable_ir_video) {\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"Automatic binding of ir_video has been disabled.");\r\nreturn;\r\n}\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nswitch (hdw->ir_scheme_active) {\r\ncase PVR2_IR_SCHEME_24XXX:\r\ncase PVR2_IR_SCHEME_29XXX:\r\ninit_data->ir_codes = RC_MAP_HAUPPAUGE;\r\ninit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP;\r\ninit_data->type = RC_BIT_RC5;\r\ninit_data->name = hdw->hdw_desc->description;\r\ninit_data->polling_interval = 100;\r\ninfo.addr = 0x18;\r\ninfo.platform_data = init_data;\r\nstrlcpy(info.type, "ir_video", I2C_NAME_SIZE);\r\npvr2_trace(PVR2_TRACE_INFO, "Binding %s to i2c address 0x%02x.",\r\ninfo.type, info.addr);\r\ni2c_new_device(&hdw->i2c_adap, &info);\r\nbreak;\r\ncase PVR2_IR_SCHEME_ZILOG:\r\ncase PVR2_IR_SCHEME_24XXX_MCE:\r\ninit_data->ir_codes = RC_MAP_HAUPPAUGE;\r\ninit_data->internal_get_key_func = IR_KBD_GET_KEY_HAUP_XVR;\r\ninit_data->type = RC_BIT_RC5 | RC_BIT_RC6_MCE |\r\nRC_BIT_RC6_6A_32;\r\ninit_data->name = hdw->hdw_desc->description;\r\ninfo.addr = 0x71;\r\ninfo.platform_data = init_data;\r\nstrlcpy(info.type, "ir_rx_z8f0811_haup", I2C_NAME_SIZE);\r\npvr2_trace(PVR2_TRACE_INFO, "Binding %s to i2c address 0x%02x.",\r\ninfo.type, info.addr);\r\ni2c_new_device(&hdw->i2c_adap, &info);\r\ninfo.addr = 0x70;\r\ninfo.platform_data = init_data;\r\nstrlcpy(info.type, "ir_tx_z8f0811_haup", I2C_NAME_SIZE);\r\npvr2_trace(PVR2_TRACE_INFO, "Binding %s to i2c address 0x%02x.",\r\ninfo.type, info.addr);\r\ni2c_new_device(&hdw->i2c_adap, &info);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid pvr2_i2c_core_init(struct pvr2_hdw *hdw)\r\n{\r\nunsigned int idx;\r\nfor (idx = 0; idx < PVR2_I2C_FUNC_CNT; idx++) {\r\nhdw->i2c_func[idx] = pvr2_i2c_basic_op;\r\n}\r\nif (ir_mode[hdw->unit_number] == 0) {\r\nprintk(KERN_INFO "%s: IR disabled\n",hdw->name);\r\nhdw->i2c_func[0x18] = i2c_black_hole;\r\n} else if (ir_mode[hdw->unit_number] == 1) {\r\nif (hdw->ir_scheme_active == PVR2_IR_SCHEME_24XXX) {\r\nhdw->i2c_func[0x18] = i2c_24xxx_ir;\r\n}\r\n}\r\nif (hdw->hdw_desc->flag_has_cx25840) {\r\nhdw->i2c_func[0x44] = i2c_hack_cx25840;\r\n}\r\nif (hdw->hdw_desc->flag_has_wm8775) {\r\nhdw->i2c_func[0x1b] = i2c_hack_wm8775;\r\n}\r\nhdw->i2c_adap = pvr2_i2c_adap_template;\r\nhdw->i2c_algo = pvr2_i2c_algo_template;\r\nstrlcpy(hdw->i2c_adap.name,hdw->name,sizeof(hdw->i2c_adap.name));\r\nhdw->i2c_adap.dev.parent = &hdw->usb_dev->dev;\r\nhdw->i2c_adap.algo = &hdw->i2c_algo;\r\nhdw->i2c_adap.algo_data = hdw;\r\nhdw->i2c_linked = !0;\r\ni2c_set_adapdata(&hdw->i2c_adap, &hdw->v4l2_dev);\r\ni2c_add_adapter(&hdw->i2c_adap);\r\nif (hdw->i2c_func[0x18] == i2c_24xxx_ir) {\r\nif (do_i2c_probe(hdw, 0x71)) {\r\npvr2_trace(PVR2_TRACE_INFO,\r\n"Device has newer IR hardware; disabling unneeded virtual IR device");\r\nhdw->i2c_func[0x18] = NULL;\r\nhdw->ir_scheme_active = PVR2_IR_SCHEME_24XXX_MCE;\r\n}\r\n}\r\nif (i2c_scan) do_i2c_scan(hdw);\r\npvr2_i2c_register_ir(hdw);\r\n}\r\nvoid pvr2_i2c_core_done(struct pvr2_hdw *hdw)\r\n{\r\nif (hdw->i2c_linked) {\r\ni2c_del_adapter(&hdw->i2c_adap);\r\nhdw->i2c_linked = 0;\r\n}\r\n}
