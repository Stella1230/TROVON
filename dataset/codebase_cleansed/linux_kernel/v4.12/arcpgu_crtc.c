static void arc_pgu_set_pxl_fmt(struct drm_crtc *crtc)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = crtc_to_arcpgu_priv(crtc);\r\nconst struct drm_framebuffer *fb = crtc->primary->state->fb;\r\nuint32_t pixel_format = fb->format->format;\r\nstruct simplefb_format *format = NULL;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(supported_formats); i++) {\r\nif (supported_formats[i].fourcc == pixel_format)\r\nformat = &supported_formats[i];\r\n}\r\nif (WARN_ON(!format))\r\nreturn;\r\nif (format->fourcc == DRM_FORMAT_RGB888)\r\narc_pgu_write(arcpgu, ARCPGU_REG_CTRL,\r\narc_pgu_read(arcpgu, ARCPGU_REG_CTRL) |\r\nARCPGU_MODE_RGB888_MASK);\r\n}\r\nstatic void arc_pgu_crtc_mode_set_nofb(struct drm_crtc *crtc)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = crtc_to_arcpgu_priv(crtc);\r\nstruct drm_display_mode *m = &crtc->state->adjusted_mode;\r\nu32 val;\r\narc_pgu_write(arcpgu, ARCPGU_REG_FMT,\r\nENCODE_PGU_XY(m->crtc_htotal, m->crtc_vtotal));\r\narc_pgu_write(arcpgu, ARCPGU_REG_HSYNC,\r\nENCODE_PGU_XY(m->crtc_hsync_start - m->crtc_hdisplay,\r\nm->crtc_hsync_end - m->crtc_hdisplay));\r\narc_pgu_write(arcpgu, ARCPGU_REG_VSYNC,\r\nENCODE_PGU_XY(m->crtc_vsync_start - m->crtc_vdisplay,\r\nm->crtc_vsync_end - m->crtc_vdisplay));\r\narc_pgu_write(arcpgu, ARCPGU_REG_ACTIVE,\r\nENCODE_PGU_XY(m->crtc_hblank_end - m->crtc_hblank_start,\r\nm->crtc_vblank_end - m->crtc_vblank_start));\r\nval = arc_pgu_read(arcpgu, ARCPGU_REG_CTRL);\r\nif (m->flags & DRM_MODE_FLAG_PVSYNC)\r\nval |= ARCPGU_CTRL_VS_POL_MASK << ARCPGU_CTRL_VS_POL_OFST;\r\nelse\r\nval &= ~(ARCPGU_CTRL_VS_POL_MASK << ARCPGU_CTRL_VS_POL_OFST);\r\nif (m->flags & DRM_MODE_FLAG_PHSYNC)\r\nval |= ARCPGU_CTRL_HS_POL_MASK << ARCPGU_CTRL_HS_POL_OFST;\r\nelse\r\nval &= ~(ARCPGU_CTRL_HS_POL_MASK << ARCPGU_CTRL_HS_POL_OFST);\r\narc_pgu_write(arcpgu, ARCPGU_REG_CTRL, val);\r\narc_pgu_write(arcpgu, ARCPGU_REG_STRIDE, 0);\r\narc_pgu_write(arcpgu, ARCPGU_REG_START_SET, 1);\r\narc_pgu_set_pxl_fmt(crtc);\r\nclk_set_rate(arcpgu->clk, m->crtc_clock * 1000);\r\n}\r\nstatic void arc_pgu_crtc_enable(struct drm_crtc *crtc)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = crtc_to_arcpgu_priv(crtc);\r\nclk_prepare_enable(arcpgu->clk);\r\narc_pgu_write(arcpgu, ARCPGU_REG_CTRL,\r\narc_pgu_read(arcpgu, ARCPGU_REG_CTRL) |\r\nARCPGU_CTRL_ENABLE_MASK);\r\n}\r\nstatic void arc_pgu_crtc_disable(struct drm_crtc *crtc)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = crtc_to_arcpgu_priv(crtc);\r\nif (!crtc->primary->fb)\r\nreturn;\r\nclk_disable_unprepare(arcpgu->clk);\r\narc_pgu_write(arcpgu, ARCPGU_REG_CTRL,\r\narc_pgu_read(arcpgu, ARCPGU_REG_CTRL) &\r\n~ARCPGU_CTRL_ENABLE_MASK);\r\n}\r\nstatic int arc_pgu_crtc_atomic_check(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = crtc_to_arcpgu_priv(crtc);\r\nstruct drm_display_mode *mode = &state->adjusted_mode;\r\nlong rate, clk_rate = mode->clock * 1000;\r\nrate = clk_round_rate(arcpgu->clk, clk_rate);\r\nif (rate != clk_rate)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void arc_pgu_crtc_atomic_begin(struct drm_crtc *crtc,\r\nstruct drm_crtc_state *state)\r\n{\r\nstruct drm_pending_vblank_event *event = crtc->state->event;\r\nif (event) {\r\ncrtc->state->event = NULL;\r\nspin_lock_irq(&crtc->dev->event_lock);\r\ndrm_crtc_send_vblank_event(crtc, event);\r\nspin_unlock_irq(&crtc->dev->event_lock);\r\n}\r\n}\r\nstatic void arc_pgu_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct arcpgu_drm_private *arcpgu;\r\nstruct drm_gem_cma_object *gem;\r\nif (!plane->state->crtc || !plane->state->fb)\r\nreturn;\r\narcpgu = crtc_to_arcpgu_priv(plane->state->crtc);\r\ngem = drm_fb_cma_get_gem_obj(plane->state->fb, 0);\r\narc_pgu_write(arcpgu, ARCPGU_REG_BUF0_ADDR, gem->paddr);\r\n}\r\nstatic void arc_pgu_plane_destroy(struct drm_plane *plane)\r\n{\r\ndrm_plane_helper_disable(plane);\r\ndrm_plane_cleanup(plane);\r\n}\r\nstatic struct drm_plane *arc_pgu_plane_init(struct drm_device *drm)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = drm->dev_private;\r\nstruct drm_plane *plane = NULL;\r\nu32 formats[ARRAY_SIZE(supported_formats)], i;\r\nint ret;\r\nplane = devm_kzalloc(drm->dev, sizeof(*plane), GFP_KERNEL);\r\nif (!plane)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < ARRAY_SIZE(supported_formats); i++)\r\nformats[i] = supported_formats[i].fourcc;\r\nret = drm_universal_plane_init(drm, plane, 0xff, &arc_pgu_plane_funcs,\r\nformats, ARRAY_SIZE(formats),\r\nDRM_PLANE_TYPE_PRIMARY, NULL);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ndrm_plane_helper_add(plane, &arc_pgu_plane_helper_funcs);\r\narcpgu->plane = plane;\r\nreturn plane;\r\n}\r\nint arc_pgu_setup_crtc(struct drm_device *drm)\r\n{\r\nstruct arcpgu_drm_private *arcpgu = drm->dev_private;\r\nstruct drm_plane *primary;\r\nint ret;\r\nprimary = arc_pgu_plane_init(drm);\r\nif (IS_ERR(primary))\r\nreturn PTR_ERR(primary);\r\nret = drm_crtc_init_with_planes(drm, &arcpgu->crtc, primary, NULL,\r\n&arc_pgu_crtc_funcs, NULL);\r\nif (ret) {\r\narc_pgu_plane_destroy(primary);\r\nreturn ret;\r\n}\r\ndrm_crtc_helper_add(&arcpgu->crtc, &arc_pgu_crtc_helper_funcs);\r\nreturn 0;\r\n}
