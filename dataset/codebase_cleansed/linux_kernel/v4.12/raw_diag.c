static struct raw_hashinfo *\r\nraw_get_hashinfo(const struct inet_diag_req_v2 *r)\r\n{\r\nif (r->sdiag_family == AF_INET) {\r\nreturn &raw_v4_hashinfo;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (r->sdiag_family == AF_INET6) {\r\nreturn &raw_v6_hashinfo;\r\n#endif\r\n} else {\r\npr_warn_once("Unexpected inet family %d\n",\r\nr->sdiag_family);\r\nWARN_ON_ONCE(1);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\n}\r\nstatic struct sock *raw_lookup(struct net *net, struct sock *from,\r\nconst struct inet_diag_req_v2 *req)\r\n{\r\nstruct inet_diag_req_raw *r = (void *)req;\r\nstruct sock *sk = NULL;\r\nif (r->sdiag_family == AF_INET)\r\nsk = __raw_v4_lookup(net, from, r->sdiag_raw_protocol,\r\nr->id.idiag_dst[0],\r\nr->id.idiag_src[0],\r\nr->id.idiag_if);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nelse\r\nsk = __raw_v6_lookup(net, from, r->sdiag_raw_protocol,\r\n(const struct in6_addr *)r->id.idiag_src,\r\n(const struct in6_addr *)r->id.idiag_dst,\r\nr->id.idiag_if);\r\n#endif\r\nreturn sk;\r\n}\r\nstatic struct sock *raw_sock_get(struct net *net, const struct inet_diag_req_v2 *r)\r\n{\r\nstruct raw_hashinfo *hashinfo = raw_get_hashinfo(r);\r\nstruct sock *sk = NULL, *s;\r\nint slot;\r\nif (IS_ERR(hashinfo))\r\nreturn ERR_CAST(hashinfo);\r\nread_lock(&hashinfo->lock);\r\nfor (slot = 0; slot < RAW_HTABLE_SIZE; slot++) {\r\nsk_for_each(s, &hashinfo->ht[slot]) {\r\nsk = raw_lookup(net, s, r);\r\nif (sk) {\r\nsock_hold(sk);\r\ngoto out_unlock;\r\n}\r\n}\r\n}\r\nout_unlock:\r\nread_unlock(&hashinfo->lock);\r\nreturn sk ? sk : ERR_PTR(-ENOENT);\r\n}\r\nstatic int raw_diag_dump_one(struct sk_buff *in_skb,\r\nconst struct nlmsghdr *nlh,\r\nconst struct inet_diag_req_v2 *r)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct sk_buff *rep;\r\nstruct sock *sk;\r\nint err;\r\nsk = raw_sock_get(net, r);\r\nif (IS_ERR(sk))\r\nreturn PTR_ERR(sk);\r\nrep = nlmsg_new(sizeof(struct inet_diag_msg) +\r\nsizeof(struct inet_diag_meminfo) + 64,\r\nGFP_KERNEL);\r\nif (!rep) {\r\nsock_put(sk);\r\nreturn -ENOMEM;\r\n}\r\nerr = inet_sk_diag_fill(sk, NULL, rep, r,\r\nsk_user_ns(NETLINK_CB(in_skb).sk),\r\nNETLINK_CB(in_skb).portid,\r\nnlh->nlmsg_seq, 0, nlh,\r\nnetlink_net_capable(in_skb, CAP_NET_ADMIN));\r\nsock_put(sk);\r\nif (err < 0) {\r\nkfree_skb(rep);\r\nreturn err;\r\n}\r\nerr = netlink_unicast(net->diag_nlsk, rep,\r\nNETLINK_CB(in_skb).portid,\r\nMSG_DONTWAIT);\r\nif (err > 0)\r\nerr = 0;\r\nreturn err;\r\n}\r\nstatic int sk_diag_dump(struct sock *sk, struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r,\r\nstruct nlattr *bc, bool net_admin)\r\n{\r\nif (!inet_diag_bc_sk(bc, sk))\r\nreturn 0;\r\nreturn inet_sk_diag_fill(sk, NULL, skb, r,\r\nsk_user_ns(NETLINK_CB(cb->skb).sk),\r\nNETLINK_CB(cb->skb).portid,\r\ncb->nlh->nlmsg_seq, NLM_F_MULTI,\r\ncb->nlh, net_admin);\r\n}\r\nstatic void raw_diag_dump(struct sk_buff *skb, struct netlink_callback *cb,\r\nconst struct inet_diag_req_v2 *r, struct nlattr *bc)\r\n{\r\nbool net_admin = netlink_net_capable(cb->skb, CAP_NET_ADMIN);\r\nstruct raw_hashinfo *hashinfo = raw_get_hashinfo(r);\r\nstruct net *net = sock_net(skb->sk);\r\nint num, s_num, slot, s_slot;\r\nstruct sock *sk = NULL;\r\nif (IS_ERR(hashinfo))\r\nreturn;\r\ns_slot = cb->args[0];\r\nnum = s_num = cb->args[1];\r\nread_lock(&hashinfo->lock);\r\nfor (slot = s_slot; slot < RAW_HTABLE_SIZE; s_num = 0, slot++) {\r\nnum = 0;\r\nsk_for_each(sk, &hashinfo->ht[slot]) {\r\nstruct inet_sock *inet = inet_sk(sk);\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (num < s_num)\r\ngoto next;\r\nif (sk->sk_family != r->sdiag_family)\r\ngoto next;\r\nif (r->id.idiag_sport != inet->inet_sport &&\r\nr->id.idiag_sport)\r\ngoto next;\r\nif (r->id.idiag_dport != inet->inet_dport &&\r\nr->id.idiag_dport)\r\ngoto next;\r\nif (sk_diag_dump(sk, skb, cb, r, bc, net_admin) < 0)\r\ngoto out_unlock;\r\nnext:\r\nnum++;\r\n}\r\n}\r\nout_unlock:\r\nread_unlock(&hashinfo->lock);\r\ncb->args[0] = slot;\r\ncb->args[1] = num;\r\n}\r\nstatic void raw_diag_get_info(struct sock *sk, struct inet_diag_msg *r,\r\nvoid *info)\r\n{\r\nr->idiag_rqueue = sk_rmem_alloc_get(sk);\r\nr->idiag_wqueue = sk_wmem_alloc_get(sk);\r\n}\r\nstatic int raw_diag_destroy(struct sk_buff *in_skb,\r\nconst struct inet_diag_req_v2 *r)\r\n{\r\nstruct net *net = sock_net(in_skb->sk);\r\nstruct sock *sk;\r\nint err;\r\nsk = raw_sock_get(net, r);\r\nif (IS_ERR(sk))\r\nreturn PTR_ERR(sk);\r\nerr = sock_diag_destroy(sk, ECONNABORTED);\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic void __always_unused __check_inet_diag_req_raw(void)\r\n{\r\n#define __offset_mismatch(m1, m2) \\r\n(offsetof(struct inet_diag_req_v2, m1) != \\r\noffsetof(struct inet_diag_req_raw, m2))\r\nBUILD_BUG_ON(sizeof(struct inet_diag_req_v2) !=\r\nsizeof(struct inet_diag_req_raw));\r\nBUILD_BUG_ON(__offset_mismatch(sdiag_family, sdiag_family));\r\nBUILD_BUG_ON(__offset_mismatch(sdiag_protocol, sdiag_protocol));\r\nBUILD_BUG_ON(__offset_mismatch(idiag_ext, idiag_ext));\r\nBUILD_BUG_ON(__offset_mismatch(pad, sdiag_raw_protocol));\r\nBUILD_BUG_ON(__offset_mismatch(idiag_states, idiag_states));\r\nBUILD_BUG_ON(__offset_mismatch(id, id));\r\n#undef __offset_mismatch\r\n}\r\nstatic int __init raw_diag_init(void)\r\n{\r\nreturn inet_diag_register(&raw_diag_handler);\r\n}\r\nstatic void __exit raw_diag_exit(void)\r\n{\r\ninet_diag_unregister(&raw_diag_handler);\r\n}
