static int clk_pllv3_wait_lock(struct clk_pllv3 *pll)\r\n{\r\nunsigned long timeout = jiffies + msecs_to_jiffies(10);\r\nu32 val = readl_relaxed(pll->base) & pll->power_bit;\r\nif ((pll->powerup_set && !val) || (!pll->powerup_set && val))\r\nreturn 0;\r\ndo {\r\nif (readl_relaxed(pll->base) & BM_PLL_LOCK)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nbreak;\r\nusleep_range(50, 500);\r\n} while (1);\r\nreturn readl_relaxed(pll->base) & BM_PLL_LOCK ? 0 : -ETIMEDOUT;\r\n}\r\nstatic int clk_pllv3_prepare(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 val;\r\nval = readl_relaxed(pll->base);\r\nif (pll->powerup_set)\r\nval |= pll->power_bit;\r\nelse\r\nval &= ~pll->power_bit;\r\nwritel_relaxed(val, pll->base);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic void clk_pllv3_unprepare(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 val;\r\nval = readl_relaxed(pll->base);\r\nif (pll->powerup_set)\r\nval &= ~pll->power_bit;\r\nelse\r\nval |= pll->power_bit;\r\nwritel_relaxed(val, pll->base);\r\n}\r\nstatic int clk_pllv3_is_prepared(struct clk_hw *hw)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nif (readl_relaxed(pll->base) & BM_PLL_LOCK)\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic unsigned long clk_pllv3_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 div = (readl_relaxed(pll->base) >> pll->div_shift) & pll->div_mask;\r\nreturn (div == 1) ? parent_rate * 22 : parent_rate * 20;\r\n}\r\nstatic long clk_pllv3_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nreturn (rate >= parent_rate * 22) ? parent_rate * 22 :\r\nparent_rate * 20;\r\n}\r\nstatic int clk_pllv3_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 val, div;\r\nif (rate == parent_rate * 22)\r\ndiv = 1;\r\nelse if (rate == parent_rate * 20)\r\ndiv = 0;\r\nelse\r\nreturn -EINVAL;\r\nval = readl_relaxed(pll->base);\r\nval &= ~(pll->div_mask << pll->div_shift);\r\nval |= (div << pll->div_shift);\r\nwritel_relaxed(val, pll->base);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_sys_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 div = readl_relaxed(pll->base) & pll->div_mask;\r\nreturn parent_rate * div / 2;\r\n}\r\nstatic long clk_pllv3_sys_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nunsigned long min_rate = parent_rate * 54 / 2;\r\nunsigned long max_rate = parent_rate * 108 / 2;\r\nu32 div;\r\nif (rate > max_rate)\r\nrate = max_rate;\r\nelse if (rate < min_rate)\r\nrate = min_rate;\r\ndiv = rate * 2 / parent_rate;\r\nreturn parent_rate * div / 2;\r\n}\r\nstatic int clk_pllv3_sys_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nunsigned long min_rate = parent_rate * 54 / 2;\r\nunsigned long max_rate = parent_rate * 108 / 2;\r\nu32 val, div;\r\nif (rate < min_rate || rate > max_rate)\r\nreturn -EINVAL;\r\ndiv = rate * 2 / parent_rate;\r\nval = readl_relaxed(pll->base);\r\nval &= ~pll->div_mask;\r\nval |= div;\r\nwritel_relaxed(val, pll->base);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_av_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nu32 mfn = readl_relaxed(pll->base + PLL_NUM_OFFSET);\r\nu32 mfd = readl_relaxed(pll->base + PLL_DENOM_OFFSET);\r\nu32 div = readl_relaxed(pll->base) & pll->div_mask;\r\nu64 temp64 = (u64)parent_rate;\r\ntemp64 *= mfn;\r\ndo_div(temp64, mfd);\r\nreturn parent_rate * div + (unsigned long)temp64;\r\n}\r\nstatic long clk_pllv3_av_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nunsigned long parent_rate = *prate;\r\nunsigned long min_rate = parent_rate * 27;\r\nunsigned long max_rate = parent_rate * 54;\r\nu32 div;\r\nu32 mfn, mfd = 1000000;\r\nu32 max_mfd = 0x3FFFFFFF;\r\nu64 temp64;\r\nif (rate > max_rate)\r\nrate = max_rate;\r\nelse if (rate < min_rate)\r\nrate = min_rate;\r\nif (parent_rate <= max_mfd)\r\nmfd = parent_rate;\r\ndiv = rate / parent_rate;\r\ntemp64 = (u64) (rate - div * parent_rate);\r\ntemp64 *= mfd;\r\ndo_div(temp64, parent_rate);\r\nmfn = temp64;\r\ntemp64 = (u64)parent_rate;\r\ntemp64 *= mfn;\r\ndo_div(temp64, mfd);\r\nreturn parent_rate * div + (unsigned long)temp64;\r\n}\r\nstatic int clk_pllv3_av_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nunsigned long min_rate = parent_rate * 27;\r\nunsigned long max_rate = parent_rate * 54;\r\nu32 val, div;\r\nu32 mfn, mfd = 1000000;\r\nu32 max_mfd = 0x3FFFFFFF;\r\nu64 temp64;\r\nif (rate < min_rate || rate > max_rate)\r\nreturn -EINVAL;\r\nif (parent_rate <= max_mfd)\r\nmfd = parent_rate;\r\ndiv = rate / parent_rate;\r\ntemp64 = (u64) (rate - div * parent_rate);\r\ntemp64 *= mfd;\r\ndo_div(temp64, parent_rate);\r\nmfn = temp64;\r\nval = readl_relaxed(pll->base);\r\nval &= ~pll->div_mask;\r\nval |= div;\r\nwritel_relaxed(val, pll->base);\r\nwritel_relaxed(mfn, pll->base + PLL_NUM_OFFSET);\r\nwritel_relaxed(mfd, pll->base + PLL_DENOM_OFFSET);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_vf610_mf_to_rate(unsigned long parent_rate,\r\nstruct clk_pllv3_vf610_mf mf)\r\n{\r\nu64 temp64;\r\ntemp64 = parent_rate;\r\ntemp64 *= mf.mfn;\r\ndo_div(temp64, mf.mfd);\r\nreturn (parent_rate * mf.mfi) + temp64;\r\n}\r\nstatic struct clk_pllv3_vf610_mf clk_pllv3_vf610_rate_to_mf(\r\nunsigned long parent_rate, unsigned long rate)\r\n{\r\nstruct clk_pllv3_vf610_mf mf;\r\nu64 temp64;\r\nmf.mfi = (rate >= 22 * parent_rate) ? 22 : 20;\r\nmf.mfd = 0x3fffffff;\r\nif (rate <= parent_rate * mf.mfi)\r\nmf.mfn = 0;\r\nelse if (rate >= parent_rate * (mf.mfi + 1))\r\nmf.mfn = mf.mfd - 1;\r\nelse {\r\ntemp64 = rate - parent_rate * mf.mfi;\r\ntemp64 *= mf.mfd;\r\ndo_div(temp64, parent_rate);\r\nmf.mfn = temp64;\r\n}\r\nreturn mf;\r\n}\r\nstatic unsigned long clk_pllv3_vf610_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nstruct clk_pllv3_vf610_mf mf;\r\nmf.mfn = readl_relaxed(pll->base + PLL_VF610_NUM_OFFSET);\r\nmf.mfd = readl_relaxed(pll->base + PLL_VF610_DENOM_OFFSET);\r\nmf.mfi = (readl_relaxed(pll->base) & pll->div_mask) ? 22 : 20;\r\nreturn clk_pllv3_vf610_mf_to_rate(parent_rate, mf);\r\n}\r\nstatic long clk_pllv3_vf610_round_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *prate)\r\n{\r\nstruct clk_pllv3_vf610_mf mf = clk_pllv3_vf610_rate_to_mf(*prate, rate);\r\nreturn clk_pllv3_vf610_mf_to_rate(*prate, mf);\r\n}\r\nstatic int clk_pllv3_vf610_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nstruct clk_pllv3_vf610_mf mf =\r\nclk_pllv3_vf610_rate_to_mf(parent_rate, rate);\r\nu32 val;\r\nval = readl_relaxed(pll->base);\r\nif (mf.mfi == 20)\r\nval &= ~pll->div_mask;\r\nelse\r\nval |= pll->div_mask;\r\nwritel_relaxed(val, pll->base);\r\nwritel_relaxed(mf.mfn, pll->base + PLL_VF610_NUM_OFFSET);\r\nwritel_relaxed(mf.mfd, pll->base + PLL_VF610_DENOM_OFFSET);\r\nreturn clk_pllv3_wait_lock(pll);\r\n}\r\nstatic unsigned long clk_pllv3_enet_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct clk_pllv3 *pll = to_clk_pllv3(hw);\r\nreturn pll->ref_clock;\r\n}\r\nstruct clk *imx_clk_pllv3(enum imx_pllv3_type type, const char *name,\r\nconst char *parent_name, void __iomem *base,\r\nu32 div_mask)\r\n{\r\nstruct clk_pllv3 *pll;\r\nconst struct clk_ops *ops;\r\nstruct clk *clk;\r\nstruct clk_init_data init;\r\npll = kzalloc(sizeof(*pll), GFP_KERNEL);\r\nif (!pll)\r\nreturn ERR_PTR(-ENOMEM);\r\npll->power_bit = BM_PLL_POWER;\r\nswitch (type) {\r\ncase IMX_PLLV3_SYS:\r\nops = &clk_pllv3_sys_ops;\r\nbreak;\r\ncase IMX_PLLV3_SYS_VF610:\r\nops = &clk_pllv3_vf610_ops;\r\nbreak;\r\ncase IMX_PLLV3_USB_VF610:\r\npll->div_shift = 1;\r\ncase IMX_PLLV3_USB:\r\nops = &clk_pllv3_ops;\r\npll->powerup_set = true;\r\nbreak;\r\ncase IMX_PLLV3_AV:\r\nops = &clk_pllv3_av_ops;\r\nbreak;\r\ncase IMX_PLLV3_ENET_IMX7:\r\npll->power_bit = IMX7_ENET_PLL_POWER;\r\npll->ref_clock = 1000000000;\r\nops = &clk_pllv3_enet_ops;\r\nbreak;\r\ncase IMX_PLLV3_ENET:\r\npll->ref_clock = 500000000;\r\nops = &clk_pllv3_enet_ops;\r\nbreak;\r\ndefault:\r\nops = &clk_pllv3_ops;\r\n}\r\npll->base = base;\r\npll->div_mask = div_mask;\r\ninit.name = name;\r\ninit.ops = ops;\r\ninit.flags = 0;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\npll->hw.init = &init;\r\nclk = clk_register(NULL, &pll->hw);\r\nif (IS_ERR(clk))\r\nkfree(pll);\r\nreturn clk;\r\n}
