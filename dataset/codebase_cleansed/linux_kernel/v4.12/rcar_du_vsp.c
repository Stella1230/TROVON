void rcar_du_vsp_enable(struct rcar_du_crtc *crtc)\r\n{\r\nconst struct drm_display_mode *mode = &crtc->crtc.state->adjusted_mode;\r\nstruct rcar_du_device *rcdu = crtc->group->dev;\r\nstruct vsp1_du_lif_config cfg = {\r\n.width = mode->hdisplay,\r\n.height = mode->vdisplay,\r\n};\r\nstruct rcar_du_plane_state state = {\r\n.state = {\r\n.crtc = &crtc->crtc,\r\n.crtc_x = 0,\r\n.crtc_y = 0,\r\n.crtc_w = mode->hdisplay,\r\n.crtc_h = mode->vdisplay,\r\n.src_x = 0,\r\n.src_y = 0,\r\n.src_w = mode->hdisplay << 16,\r\n.src_h = mode->vdisplay << 16,\r\n.zpos = 0,\r\n},\r\n.format = rcar_du_format_info(DRM_FORMAT_ARGB8888),\r\n.source = RCAR_DU_PLANE_VSPD1,\r\n.alpha = 255,\r\n.colorkey = 0,\r\n};\r\nif (rcdu->info->gen >= 3)\r\nstate.hwindex = (crtc->index % 2) ? 2 : 0;\r\nelse\r\nstate.hwindex = crtc->index % 2;\r\n__rcar_du_plane_setup(crtc->group, &state);\r\ncrtc->group->need_restart = true;\r\nvsp1_du_setup_lif(crtc->vsp->vsp, &cfg);\r\n}\r\nvoid rcar_du_vsp_disable(struct rcar_du_crtc *crtc)\r\n{\r\nvsp1_du_setup_lif(crtc->vsp->vsp, NULL);\r\n}\r\nvoid rcar_du_vsp_atomic_begin(struct rcar_du_crtc *crtc)\r\n{\r\nvsp1_du_atomic_begin(crtc->vsp->vsp);\r\n}\r\nvoid rcar_du_vsp_atomic_flush(struct rcar_du_crtc *crtc)\r\n{\r\nvsp1_du_atomic_flush(crtc->vsp->vsp);\r\n}\r\nstatic void rcar_du_vsp_plane_setup(struct rcar_du_vsp_plane *plane)\r\n{\r\nstruct rcar_du_vsp_plane_state *state =\r\nto_rcar_vsp_plane_state(plane->plane.state);\r\nstruct drm_framebuffer *fb = plane->plane.state->fb;\r\nstruct vsp1_du_atomic_config cfg = {\r\n.pixelformat = 0,\r\n.pitch = fb->pitches[0],\r\n.alpha = state->alpha,\r\n.zpos = state->state.zpos,\r\n};\r\nunsigned int i;\r\ncfg.src.left = state->state.src_x >> 16;\r\ncfg.src.top = state->state.src_y >> 16;\r\ncfg.src.width = state->state.src_w >> 16;\r\ncfg.src.height = state->state.src_h >> 16;\r\ncfg.dst.left = state->state.crtc_x;\r\ncfg.dst.top = state->state.crtc_y;\r\ncfg.dst.width = state->state.crtc_w;\r\ncfg.dst.height = state->state.crtc_h;\r\nfor (i = 0; i < state->format->planes; ++i) {\r\nstruct drm_gem_cma_object *gem;\r\ngem = drm_fb_cma_get_gem_obj(fb, i);\r\ncfg.mem[i] = gem->paddr + fb->offsets[i];\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(formats_kms); ++i) {\r\nif (formats_kms[i] == state->format->fourcc) {\r\ncfg.pixelformat = formats_v4l2[i];\r\nbreak;\r\n}\r\n}\r\nvsp1_du_atomic_update(plane->vsp->vsp, plane->index, &cfg);\r\n}\r\nstatic int rcar_du_vsp_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(state);\r\nstruct rcar_du_vsp_plane *rplane = to_rcar_vsp_plane(plane);\r\nstruct rcar_du_device *rcdu = rplane->vsp->dev;\r\nif (!state->fb || !state->crtc) {\r\nrstate->format = NULL;\r\nreturn 0;\r\n}\r\nif (state->src_w >> 16 != state->crtc_w ||\r\nstate->src_h >> 16 != state->crtc_h) {\r\ndev_dbg(rcdu->dev, "%s: scaling not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nrstate->format = rcar_du_format_info(state->fb->format->format);\r\nif (rstate->format == NULL) {\r\ndev_dbg(rcdu->dev, "%s: unsupported format %08x\n", __func__,\r\nstate->fb->format->format);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_du_vsp_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct rcar_du_vsp_plane *rplane = to_rcar_vsp_plane(plane);\r\nif (plane->state->crtc)\r\nrcar_du_vsp_plane_setup(rplane);\r\nelse\r\nvsp1_du_atomic_update(rplane->vsp->vsp, rplane->index, NULL);\r\n}\r\nstatic struct drm_plane_state *\r\nrcar_du_vsp_plane_atomic_duplicate_state(struct drm_plane *plane)\r\n{\r\nstruct rcar_du_vsp_plane_state *state;\r\nstruct rcar_du_vsp_plane_state *copy;\r\nif (WARN_ON(!plane->state))\r\nreturn NULL;\r\nstate = to_rcar_vsp_plane_state(plane->state);\r\ncopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\r\nif (copy == NULL)\r\nreturn NULL;\r\n__drm_atomic_helper_plane_duplicate_state(plane, &copy->state);\r\nreturn &copy->state;\r\n}\r\nstatic void rcar_du_vsp_plane_atomic_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\n__drm_atomic_helper_plane_destroy_state(state);\r\nkfree(to_rcar_vsp_plane_state(state));\r\n}\r\nstatic void rcar_du_vsp_plane_reset(struct drm_plane *plane)\r\n{\r\nstruct rcar_du_vsp_plane_state *state;\r\nif (plane->state) {\r\nrcar_du_vsp_plane_atomic_destroy_state(plane, plane->state);\r\nplane->state = NULL;\r\n}\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn;\r\nstate->alpha = 255;\r\nstate->state.zpos = plane->type == DRM_PLANE_TYPE_PRIMARY ? 0 : 1;\r\nplane->state = &state->state;\r\nplane->state->plane = plane;\r\n}\r\nstatic int rcar_du_vsp_plane_atomic_set_property(struct drm_plane *plane,\r\nstruct drm_plane_state *state, struct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct rcar_du_vsp_plane_state *rstate = to_rcar_vsp_plane_state(state);\r\nstruct rcar_du_device *rcdu = to_rcar_vsp_plane(plane)->vsp->dev;\r\nif (property == rcdu->props.alpha)\r\nrstate->alpha = val;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rcar_du_vsp_plane_atomic_get_property(struct drm_plane *plane,\r\nconst struct drm_plane_state *state, struct drm_property *property,\r\nuint64_t *val)\r\n{\r\nconst struct rcar_du_vsp_plane_state *rstate =\r\ncontainer_of(state, const struct rcar_du_vsp_plane_state, state);\r\nstruct rcar_du_device *rcdu = to_rcar_vsp_plane(plane)->vsp->dev;\r\nif (property == rcdu->props.alpha)\r\n*val = rstate->alpha;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint rcar_du_vsp_init(struct rcar_du_vsp *vsp)\r\n{\r\nstruct rcar_du_device *rcdu = vsp->dev;\r\nstruct platform_device *pdev;\r\nstruct device_node *np;\r\nunsigned int i;\r\nint ret;\r\nnp = of_parse_phandle(rcdu->dev->of_node, "vsps", vsp->index);\r\nif (!np) {\r\ndev_err(rcdu->dev, "vsps node not found\n");\r\nreturn -ENXIO;\r\n}\r\npdev = of_find_device_by_node(np);\r\nof_node_put(np);\r\nif (!pdev)\r\nreturn -ENXIO;\r\nvsp->vsp = &pdev->dev;\r\nret = vsp1_du_init(vsp->vsp);\r\nif (ret < 0)\r\nreturn ret;\r\nvsp->num_planes = rcdu->info->gen >= 3 ? 5 : 4;\r\nvsp->planes = devm_kcalloc(rcdu->dev, vsp->num_planes,\r\nsizeof(*vsp->planes), GFP_KERNEL);\r\nif (!vsp->planes)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < vsp->num_planes; ++i) {\r\nenum drm_plane_type type = i ? DRM_PLANE_TYPE_OVERLAY\r\n: DRM_PLANE_TYPE_PRIMARY;\r\nstruct rcar_du_vsp_plane *plane = &vsp->planes[i];\r\nplane->vsp = vsp;\r\nplane->index = i;\r\nret = drm_universal_plane_init(rcdu->ddev, &plane->plane,\r\n1 << vsp->index,\r\n&rcar_du_vsp_plane_funcs,\r\nformats_kms,\r\nARRAY_SIZE(formats_kms), type,\r\nNULL);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_plane_helper_add(&plane->plane,\r\n&rcar_du_vsp_plane_helper_funcs);\r\nif (type == DRM_PLANE_TYPE_PRIMARY)\r\ncontinue;\r\ndrm_object_attach_property(&plane->plane.base,\r\nrcdu->props.alpha, 255);\r\ndrm_plane_create_zpos_property(&plane->plane, 1, 1,\r\nvsp->num_planes - 1);\r\n}\r\nreturn 0;\r\n}
