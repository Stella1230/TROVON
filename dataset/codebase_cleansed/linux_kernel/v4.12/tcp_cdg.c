static u32 __pure nexp_u32(u32 ux)\r\n{\r\nstatic const u16 v[] = {\r\n65535,\r\n65518, 65501, 65468, 65401, 65267, 65001, 64470, 63422,\r\n61378, 57484, 50423, 38795, 22965, 8047, 987, 14,\r\n};\r\nu32 msb = ux >> 8;\r\nu32 res;\r\nint i;\r\nif (msb > U16_MAX)\r\nreturn 0;\r\nres = U32_MAX - (ux & 0xff) * (U32_MAX / 1000000);\r\nfor (i = 1; msb; i++, msb >>= 1) {\r\nu32 y = v[i & -(msb & 1)] + U32_C(1);\r\nres = ((u64)res * y) >> 16;\r\n}\r\nreturn res;\r\n}\r\nstatic void tcp_cdg_hystart_update(struct sock *sk)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nca->delay_min = min_not_zero(ca->delay_min, ca->rtt.min);\r\nif (ca->delay_min == 0)\r\nreturn;\r\nif (hystart_detect & HYSTART_ACK_TRAIN) {\r\nu32 now_us = div_u64(local_clock(), NSEC_PER_USEC);\r\nif (ca->last_ack == 0 || !tcp_is_cwnd_limited(sk)) {\r\nca->last_ack = now_us;\r\nca->round_start = now_us;\r\n} else if (before(now_us, ca->last_ack + 3000)) {\r\nu32 base_owd = max(ca->delay_min / 2U, 125U);\r\nca->last_ack = now_us;\r\nif (after(now_us, ca->round_start + base_owd)) {\r\nNET_INC_STATS(sock_net(sk),\r\nLINUX_MIB_TCPHYSTARTTRAINDETECT);\r\nNET_ADD_STATS(sock_net(sk),\r\nLINUX_MIB_TCPHYSTARTTRAINCWND,\r\ntp->snd_cwnd);\r\ntp->snd_ssthresh = tp->snd_cwnd;\r\nreturn;\r\n}\r\n}\r\n}\r\nif (hystart_detect & HYSTART_DELAY) {\r\nif (ca->sample_cnt < 8) {\r\nca->sample_cnt++;\r\n} else {\r\ns32 thresh = max(ca->delay_min + ca->delay_min / 8U,\r\n125U);\r\nif (ca->rtt.min > thresh) {\r\nNET_INC_STATS(sock_net(sk),\r\nLINUX_MIB_TCPHYSTARTDELAYDETECT);\r\nNET_ADD_STATS(sock_net(sk),\r\nLINUX_MIB_TCPHYSTARTDELAYCWND,\r\ntp->snd_cwnd);\r\ntp->snd_ssthresh = tp->snd_cwnd;\r\n}\r\n}\r\n}\r\n}\r\nstatic s32 tcp_cdg_grad(struct cdg *ca)\r\n{\r\ns32 gmin = ca->rtt.min - ca->rtt_prev.min;\r\ns32 gmax = ca->rtt.max - ca->rtt_prev.max;\r\ns32 grad;\r\nif (ca->gradients) {\r\nca->gsum.min += gmin - ca->gradients[ca->tail].min;\r\nca->gsum.max += gmax - ca->gradients[ca->tail].max;\r\nca->gradients[ca->tail].min = gmin;\r\nca->gradients[ca->tail].max = gmax;\r\nca->tail = (ca->tail + 1) & (window - 1);\r\ngmin = ca->gsum.min;\r\ngmax = ca->gsum.max;\r\n}\r\ngrad = gmin > 0 ? gmin : gmax;\r\nif (!ca->gfilled) {\r\nif (!ca->gradients && window > 1)\r\ngrad *= window;\r\nelse if (ca->tail == 0)\r\nca->gfilled = true;\r\nelse\r\ngrad = (grad * window) / (int)ca->tail;\r\n}\r\nif (gmin <= -32 || gmax <= -32)\r\nca->backoff_cnt = 0;\r\nif (use_tolerance) {\r\ngmin = DIV_ROUND_CLOSEST(gmin, 64);\r\ngmax = DIV_ROUND_CLOSEST(gmax, 64);\r\nif (gmin > 0 && gmax <= 0)\r\nca->state = CDG_FULL;\r\nelse if ((gmin > 0 && gmax > 0) || gmax < 0)\r\nca->state = CDG_NONFULL;\r\n}\r\nreturn grad;\r\n}\r\nstatic bool tcp_cdg_backoff(struct sock *sk, u32 grad)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nif (prandom_u32() <= nexp_u32(grad * backoff_factor))\r\nreturn false;\r\nif (use_ineff) {\r\nca->backoff_cnt++;\r\nif (ca->backoff_cnt > use_ineff)\r\nreturn false;\r\n}\r\nca->shadow_wnd = max(ca->shadow_wnd, tp->snd_cwnd);\r\nca->state = CDG_BACKOFF;\r\ntcp_enter_cwr(sk);\r\nreturn true;\r\n}\r\nstatic void tcp_cdg_cong_avoid(struct sock *sk, u32 ack, u32 acked)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nu32 prior_snd_cwnd;\r\nu32 incr;\r\nif (tcp_in_slow_start(tp) && hystart_detect)\r\ntcp_cdg_hystart_update(sk);\r\nif (after(ack, ca->rtt_seq) && ca->rtt.v64) {\r\ns32 grad = 0;\r\nif (ca->rtt_prev.v64)\r\ngrad = tcp_cdg_grad(ca);\r\nca->rtt_seq = tp->snd_nxt;\r\nca->rtt_prev = ca->rtt;\r\nca->rtt.v64 = 0;\r\nca->last_ack = 0;\r\nca->sample_cnt = 0;\r\nif (grad > 0 && tcp_cdg_backoff(sk, grad))\r\nreturn;\r\n}\r\nif (!tcp_is_cwnd_limited(sk)) {\r\nca->shadow_wnd = min(ca->shadow_wnd, tp->snd_cwnd);\r\nreturn;\r\n}\r\nprior_snd_cwnd = tp->snd_cwnd;\r\ntcp_reno_cong_avoid(sk, ack, acked);\r\nincr = tp->snd_cwnd - prior_snd_cwnd;\r\nca->shadow_wnd = max(ca->shadow_wnd, ca->shadow_wnd + incr);\r\n}\r\nstatic void tcp_cdg_acked(struct sock *sk, const struct ack_sample *sample)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nif (sample->rtt_us <= 0)\r\nreturn;\r\nif (tp->sacked_out == 0) {\r\nif (sample->pkts_acked == 1 && ca->delack) {\r\nca->rtt.min = min(ca->rtt.min, sample->rtt_us);\r\nca->delack--;\r\nreturn;\r\n} else if (sample->pkts_acked > 1 && ca->delack < 5) {\r\nca->delack++;\r\n}\r\n}\r\nca->rtt.min = min_not_zero(ca->rtt.min, sample->rtt_us);\r\nca->rtt.max = max(ca->rtt.max, sample->rtt_us);\r\n}\r\nstatic u32 tcp_cdg_ssthresh(struct sock *sk)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nca->undo_cwnd = tp->snd_cwnd;\r\nif (ca->state == CDG_BACKOFF)\r\nreturn max(2U, (tp->snd_cwnd * min(1024U, backoff_beta)) >> 10);\r\nif (ca->state == CDG_NONFULL && use_tolerance)\r\nreturn tp->snd_cwnd;\r\nca->shadow_wnd = min(ca->shadow_wnd >> 1, tp->snd_cwnd);\r\nif (use_shadow)\r\nreturn max3(2U, ca->shadow_wnd, tp->snd_cwnd >> 1);\r\nreturn max(2U, tp->snd_cwnd >> 1);\r\n}\r\nstatic u32 tcp_cdg_undo_cwnd(struct sock *sk)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nreturn max(tcp_sk(sk)->snd_cwnd, ca->undo_cwnd);\r\n}\r\nstatic void tcp_cdg_cwnd_event(struct sock *sk, const enum tcp_ca_event ev)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nstruct cdg_minmax *gradients;\r\nswitch (ev) {\r\ncase CA_EVENT_CWND_RESTART:\r\ngradients = ca->gradients;\r\nif (gradients)\r\nmemset(gradients, 0, window * sizeof(gradients[0]));\r\nmemset(ca, 0, sizeof(*ca));\r\nca->gradients = gradients;\r\nca->rtt_seq = tp->snd_nxt;\r\nca->shadow_wnd = tp->snd_cwnd;\r\nbreak;\r\ncase CA_EVENT_COMPLETE_CWR:\r\nca->state = CDG_UNKNOWN;\r\nca->rtt_seq = tp->snd_nxt;\r\nca->rtt_prev = ca->rtt;\r\nca->rtt.v64 = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic void tcp_cdg_init(struct sock *sk)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nstruct tcp_sock *tp = tcp_sk(sk);\r\nif (window > 1)\r\nca->gradients = kcalloc(window, sizeof(ca->gradients[0]),\r\nGFP_NOWAIT | __GFP_NOWARN);\r\nca->rtt_seq = tp->snd_nxt;\r\nca->shadow_wnd = tp->snd_cwnd;\r\n}\r\nstatic void tcp_cdg_release(struct sock *sk)\r\n{\r\nstruct cdg *ca = inet_csk_ca(sk);\r\nkfree(ca->gradients);\r\n}\r\nstatic int __init tcp_cdg_register(void)\r\n{\r\nif (backoff_beta > 1024 || window < 1 || window > 256)\r\nreturn -ERANGE;\r\nif (!is_power_of_2(window))\r\nreturn -EINVAL;\r\nBUILD_BUG_ON(sizeof(struct cdg) > ICSK_CA_PRIV_SIZE);\r\ntcp_register_congestion_control(&tcp_cdg);\r\nreturn 0;\r\n}\r\nstatic void __exit tcp_cdg_unregister(void)\r\n{\r\ntcp_unregister_congestion_control(&tcp_cdg);\r\n}
