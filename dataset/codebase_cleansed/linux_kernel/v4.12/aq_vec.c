static int aq_vec_poll(struct napi_struct *napi, int budget)\r\n__releases(&self->lock\r\nstruct aq_vec_s *aq_vec_alloc(struct aq_nic_s *aq_nic, unsigned int idx,\r\nstruct aq_nic_cfg_s *aq_nic_cfg)\r\n{\r\nstruct aq_vec_s *self = NULL;\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int i = 0U;\r\nint err = 0;\r\nself = kzalloc(sizeof(*self), GFP_KERNEL);\r\nif (!self) {\r\nerr = -ENOMEM;\r\ngoto err_exit;\r\n}\r\nself->aq_nic = aq_nic;\r\nself->aq_ring_param.vec_idx = idx;\r\nself->aq_ring_param.cpu =\r\nidx + aq_nic_cfg->aq_rss.base_cpu_number;\r\ncpumask_set_cpu(self->aq_ring_param.cpu,\r\n&self->aq_ring_param.affinity_mask);\r\nself->tx_rings = 0;\r\nself->rx_rings = 0;\r\nnetif_napi_add(aq_nic_get_ndev(aq_nic), &self->napi,\r\naq_vec_poll, AQ_CFG_NAPI_WEIGHT);\r\nfor (i = 0; i < aq_nic_cfg->tcs; ++i) {\r\nunsigned int idx_ring = AQ_NIC_TCVEC2RING(self->nic,\r\nself->tx_rings,\r\nself->aq_ring_param.vec_idx);\r\nring = aq_ring_tx_alloc(&self->ring[i][AQ_VEC_TX_ID], aq_nic,\r\nidx_ring, aq_nic_cfg);\r\nif (!ring) {\r\nerr = -ENOMEM;\r\ngoto err_exit;\r\n}\r\n++self->tx_rings;\r\naq_nic_set_tx_ring(aq_nic, idx_ring, ring);\r\nring = aq_ring_rx_alloc(&self->ring[i][AQ_VEC_RX_ID], aq_nic,\r\nidx_ring, aq_nic_cfg);\r\nif (!ring) {\r\nerr = -ENOMEM;\r\ngoto err_exit;\r\n}\r\n++self->rx_rings;\r\n}\r\nerr_exit:\r\nif (err < 0) {\r\naq_vec_free(self);\r\nself = NULL;\r\n}\r\nreturn self;\r\n}\r\nint aq_vec_init(struct aq_vec_s *self, struct aq_hw_ops *aq_hw_ops,\r\nstruct aq_hw_s *aq_hw)\r\n{\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int i = 0U;\r\nint err = 0;\r\nself->aq_hw_ops = aq_hw_ops;\r\nself->aq_hw = aq_hw;\r\nspin_lock_init(&self->header.lock);\r\nfor (i = 0U, ring = self->ring[0];\r\nself->tx_rings > i; ++i, ring = self->ring[i]) {\r\nerr = aq_ring_init(&ring[AQ_VEC_TX_ID]);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = self->aq_hw_ops->hw_ring_tx_init(self->aq_hw,\r\n&ring[AQ_VEC_TX_ID],\r\n&self->aq_ring_param);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = aq_ring_init(&ring[AQ_VEC_RX_ID]);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = self->aq_hw_ops->hw_ring_rx_init(self->aq_hw,\r\n&ring[AQ_VEC_RX_ID],\r\n&self->aq_ring_param);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = aq_ring_rx_fill(&ring[AQ_VEC_RX_ID]);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = self->aq_hw_ops->hw_ring_rx_fill(self->aq_hw,\r\n&ring[AQ_VEC_RX_ID], 0U);\r\nif (err < 0)\r\ngoto err_exit;\r\n}\r\nerr_exit:\r\nreturn err;\r\n}\r\nint aq_vec_start(struct aq_vec_s *self)\r\n{\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int i = 0U;\r\nint err = 0;\r\nfor (i = 0U, ring = self->ring[0];\r\nself->tx_rings > i; ++i, ring = self->ring[i]) {\r\nerr = self->aq_hw_ops->hw_ring_tx_start(self->aq_hw,\r\n&ring[AQ_VEC_TX_ID]);\r\nif (err < 0)\r\ngoto err_exit;\r\nerr = self->aq_hw_ops->hw_ring_rx_start(self->aq_hw,\r\n&ring[AQ_VEC_RX_ID]);\r\nif (err < 0)\r\ngoto err_exit;\r\n}\r\nnapi_enable(&self->napi);\r\nerr_exit:\r\nreturn err;\r\n}\r\nvoid aq_vec_stop(struct aq_vec_s *self)\r\n{\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int i = 0U;\r\nfor (i = 0U, ring = self->ring[0];\r\nself->tx_rings > i; ++i, ring = self->ring[i]) {\r\nself->aq_hw_ops->hw_ring_tx_stop(self->aq_hw,\r\n&ring[AQ_VEC_TX_ID]);\r\nself->aq_hw_ops->hw_ring_rx_stop(self->aq_hw,\r\n&ring[AQ_VEC_RX_ID]);\r\n}\r\nnapi_disable(&self->napi);\r\n}\r\nvoid aq_vec_deinit(struct aq_vec_s *self)\r\n{\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int i = 0U;\r\nif (!self)\r\ngoto err_exit;\r\nfor (i = 0U, ring = self->ring[0];\r\nself->tx_rings > i; ++i, ring = self->ring[i]) {\r\naq_ring_tx_clean(&ring[AQ_VEC_TX_ID]);\r\naq_ring_rx_deinit(&ring[AQ_VEC_RX_ID]);\r\n}\r\nerr_exit:;\r\n}\r\nvoid aq_vec_free(struct aq_vec_s *self)\r\n{\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int i = 0U;\r\nif (!self)\r\ngoto err_exit;\r\nfor (i = 0U, ring = self->ring[0];\r\nself->tx_rings > i; ++i, ring = self->ring[i]) {\r\naq_ring_free(&ring[AQ_VEC_TX_ID]);\r\naq_ring_free(&ring[AQ_VEC_RX_ID]);\r\n}\r\nnetif_napi_del(&self->napi);\r\nkfree(self);\r\nerr_exit:;\r\n}\r\nirqreturn_t aq_vec_isr(int irq, void *private)\r\n{\r\nstruct aq_vec_s *self = private;\r\nint err = 0;\r\nif (!self) {\r\nerr = -EINVAL;\r\ngoto err_exit;\r\n}\r\nnapi_schedule(&self->napi);\r\nerr_exit:\r\nreturn err >= 0 ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\nirqreturn_t aq_vec_isr_legacy(int irq, void *private)\r\n{\r\nstruct aq_vec_s *self = private;\r\nu64 irq_mask = 0U;\r\nirqreturn_t err = 0;\r\nif (!self) {\r\nerr = -EINVAL;\r\ngoto err_exit;\r\n}\r\nerr = self->aq_hw_ops->hw_irq_read(self->aq_hw, &irq_mask);\r\nif (err < 0)\r\ngoto err_exit;\r\nif (irq_mask) {\r\nself->aq_hw_ops->hw_irq_disable(self->aq_hw,\r\n1U << self->aq_ring_param.vec_idx);\r\nnapi_schedule(&self->napi);\r\n} else {\r\nself->aq_hw_ops->hw_irq_enable(self->aq_hw, 1U);\r\nerr = IRQ_NONE;\r\n}\r\nerr_exit:\r\nreturn err >= 0 ? IRQ_HANDLED : IRQ_NONE;\r\n}\r\ncpumask_t *aq_vec_get_affinity_mask(struct aq_vec_s *self)\r\n{\r\nreturn &self->aq_ring_param.affinity_mask;\r\n}\r\nvoid aq_vec_add_stats(struct aq_vec_s *self,\r\nstruct aq_ring_stats_rx_s *stats_rx,\r\nstruct aq_ring_stats_tx_s *stats_tx)\r\n{\r\nstruct aq_ring_s *ring = NULL;\r\nunsigned int r = 0U;\r\nfor (r = 0U, ring = self->ring[0];\r\nself->tx_rings > r; ++r, ring = self->ring[r]) {\r\nstruct aq_ring_stats_tx_s *tx = &ring[AQ_VEC_TX_ID].stats.tx;\r\nstruct aq_ring_stats_rx_s *rx = &ring[AQ_VEC_RX_ID].stats.rx;\r\nstats_rx->packets += rx->packets;\r\nstats_rx->bytes += rx->bytes;\r\nstats_rx->errors += rx->errors;\r\nstats_rx->jumbo_packets += rx->jumbo_packets;\r\nstats_rx->lro_packets += rx->lro_packets;\r\nstats_tx->packets += tx->packets;\r\nstats_tx->bytes += tx->bytes;\r\nstats_tx->errors += tx->errors;\r\n}\r\n}\r\nint aq_vec_get_sw_stats(struct aq_vec_s *self, u64 *data, unsigned int *p_count)\r\n{\r\nunsigned int count = 0U;\r\nstruct aq_ring_stats_rx_s stats_rx;\r\nstruct aq_ring_stats_tx_s stats_tx;\r\nmemset(&stats_rx, 0U, sizeof(struct aq_ring_stats_rx_s));\r\nmemset(&stats_tx, 0U, sizeof(struct aq_ring_stats_tx_s));\r\naq_vec_add_stats(self, &stats_rx, &stats_tx);\r\ndata[count] += stats_rx.packets;\r\ndata[++count] += stats_tx.packets;\r\ndata[++count] += stats_rx.jumbo_packets;\r\ndata[++count] += stats_rx.lro_packets;\r\ndata[++count] += stats_rx.errors;\r\nif (p_count)\r\n*p_count = ++count;\r\nreturn 0;\r\n}
