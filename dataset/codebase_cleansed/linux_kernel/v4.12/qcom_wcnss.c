void qcom_wcnss_assign_iris(struct qcom_wcnss *wcnss,\r\nstruct qcom_iris *iris,\r\nbool use_48mhz_xo)\r\n{\r\nmutex_lock(&wcnss->iris_lock);\r\nwcnss->iris = iris;\r\nwcnss->use_48mhz_xo = use_48mhz_xo;\r\nmutex_unlock(&wcnss->iris_lock);\r\n}\r\nstatic int wcnss_load(struct rproc *rproc, const struct firmware *fw)\r\n{\r\nstruct qcom_wcnss *wcnss = (struct qcom_wcnss *)rproc->priv;\r\nreturn qcom_mdt_load(wcnss->dev, fw, rproc->firmware, WCNSS_PAS_ID,\r\nwcnss->mem_region, wcnss->mem_phys, wcnss->mem_size);\r\n}\r\nstatic void wcnss_indicate_nv_download(struct qcom_wcnss *wcnss)\r\n{\r\nu32 val;\r\nval = readl(wcnss->spare_out);\r\nval |= WCNSS_SPARE_NVBIN_DLND;\r\nwritel(val, wcnss->spare_out);\r\n}\r\nstatic void wcnss_configure_iris(struct qcom_wcnss *wcnss)\r\n{\r\nu32 val;\r\nwritel(0, wcnss->pmu_cfg);\r\nval = WCNSS_PMU_GC_BUS_MUX_SEL_TOP | WCNSS_PMU_IRIS_XO_EN;\r\nwritel(val, wcnss->pmu_cfg);\r\nval &= ~WCNSS_PMU_XO_MODE_MASK;\r\nif (wcnss->use_48mhz_xo)\r\nval |= WCNSS_PMU_XO_MODE_48 << 1;\r\nelse\r\nval |= WCNSS_PMU_XO_MODE_19p2 << 1;\r\nwritel(val, wcnss->pmu_cfg);\r\nval |= WCNSS_PMU_IRIS_RESET;\r\nwritel(val, wcnss->pmu_cfg);\r\nwhile (readl(wcnss->pmu_cfg) & WCNSS_PMU_IRIS_RESET_STS)\r\ncpu_relax();\r\nval &= ~WCNSS_PMU_IRIS_RESET;\r\nwritel(val, wcnss->pmu_cfg);\r\nval |= WCNSS_PMU_IRIS_XO_CFG;\r\nwritel(val, wcnss->pmu_cfg);\r\nwhile (readl(wcnss->pmu_cfg) & WCNSS_PMU_IRIS_XO_CFG_STS)\r\ncpu_relax();\r\nval &= ~WCNSS_PMU_GC_BUS_MUX_SEL_TOP;\r\nval &= ~WCNSS_PMU_IRIS_XO_CFG;\r\nwritel(val, wcnss->pmu_cfg);\r\nmsleep(20);\r\n}\r\nstatic int wcnss_start(struct rproc *rproc)\r\n{\r\nstruct qcom_wcnss *wcnss = (struct qcom_wcnss *)rproc->priv;\r\nint ret;\r\nmutex_lock(&wcnss->iris_lock);\r\nif (!wcnss->iris) {\r\ndev_err(wcnss->dev, "no iris registered\n");\r\nret = -EINVAL;\r\ngoto release_iris_lock;\r\n}\r\nret = regulator_bulk_enable(wcnss->num_vregs, wcnss->vregs);\r\nif (ret)\r\ngoto release_iris_lock;\r\nret = qcom_iris_enable(wcnss->iris);\r\nif (ret)\r\ngoto disable_regulators;\r\nwcnss_indicate_nv_download(wcnss);\r\nwcnss_configure_iris(wcnss);\r\nret = qcom_scm_pas_auth_and_reset(WCNSS_PAS_ID);\r\nif (ret) {\r\ndev_err(wcnss->dev,\r\n"failed to authenticate image and release reset\n");\r\ngoto disable_iris;\r\n}\r\nret = wait_for_completion_timeout(&wcnss->start_done,\r\nmsecs_to_jiffies(5000));\r\nif (wcnss->ready_irq > 0 && ret == 0) {\r\ndev_err(wcnss->dev, "start timed out\n");\r\nqcom_scm_pas_shutdown(WCNSS_PAS_ID);\r\nret = -ETIMEDOUT;\r\ngoto disable_iris;\r\n}\r\nret = 0;\r\ndisable_iris:\r\nqcom_iris_disable(wcnss->iris);\r\ndisable_regulators:\r\nregulator_bulk_disable(wcnss->num_vregs, wcnss->vregs);\r\nrelease_iris_lock:\r\nmutex_unlock(&wcnss->iris_lock);\r\nreturn ret;\r\n}\r\nstatic int wcnss_stop(struct rproc *rproc)\r\n{\r\nstruct qcom_wcnss *wcnss = (struct qcom_wcnss *)rproc->priv;\r\nint ret;\r\nif (wcnss->state) {\r\nqcom_smem_state_update_bits(wcnss->state,\r\nBIT(wcnss->stop_bit),\r\nBIT(wcnss->stop_bit));\r\nret = wait_for_completion_timeout(&wcnss->stop_done,\r\nmsecs_to_jiffies(5000));\r\nif (ret == 0)\r\ndev_err(wcnss->dev, "timed out on wait\n");\r\nqcom_smem_state_update_bits(wcnss->state,\r\nBIT(wcnss->stop_bit),\r\n0);\r\n}\r\nret = qcom_scm_pas_shutdown(WCNSS_PAS_ID);\r\nif (ret)\r\ndev_err(wcnss->dev, "failed to shutdown: %d\n", ret);\r\nreturn ret;\r\n}\r\nstatic void *wcnss_da_to_va(struct rproc *rproc, u64 da, int len)\r\n{\r\nstruct qcom_wcnss *wcnss = (struct qcom_wcnss *)rproc->priv;\r\nint offset;\r\noffset = da - wcnss->mem_reloc;\r\nif (offset < 0 || offset + len > wcnss->mem_size)\r\nreturn NULL;\r\nreturn wcnss->mem_region + offset;\r\n}\r\nstatic irqreturn_t wcnss_wdog_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_wcnss *wcnss = dev;\r\nrproc_report_crash(wcnss->rproc, RPROC_WATCHDOG);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wcnss_fatal_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_wcnss *wcnss = dev;\r\nsize_t len;\r\nchar *msg;\r\nmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, WCNSS_CRASH_REASON_SMEM, &len);\r\nif (!IS_ERR(msg) && len > 0 && msg[0])\r\ndev_err(wcnss->dev, "fatal error received: %s\n", msg);\r\nrproc_report_crash(wcnss->rproc, RPROC_FATAL_ERROR);\r\nif (!IS_ERR(msg))\r\nmsg[0] = '\0';\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wcnss_ready_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_wcnss *wcnss = dev;\r\ncomplete(&wcnss->start_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wcnss_handover_interrupt(int irq, void *dev)\r\n{\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t wcnss_stop_ack_interrupt(int irq, void *dev)\r\n{\r\nstruct qcom_wcnss *wcnss = dev;\r\ncomplete(&wcnss->stop_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int wcnss_init_regulators(struct qcom_wcnss *wcnss,\r\nconst struct wcnss_vreg_info *info,\r\nint num_vregs)\r\n{\r\nstruct regulator_bulk_data *bulk;\r\nint ret;\r\nint i;\r\nbulk = devm_kcalloc(wcnss->dev,\r\nnum_vregs, sizeof(struct regulator_bulk_data),\r\nGFP_KERNEL);\r\nif (!bulk)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_vregs; i++)\r\nbulk[i].supply = info[i].name;\r\nret = devm_regulator_bulk_get(wcnss->dev, num_vregs, bulk);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < num_vregs; i++) {\r\nif (info[i].max_voltage)\r\nregulator_set_voltage(bulk[i].consumer,\r\ninfo[i].min_voltage,\r\ninfo[i].max_voltage);\r\nif (info[i].load_uA)\r\nregulator_set_load(bulk[i].consumer, info[i].load_uA);\r\n}\r\nwcnss->vregs = bulk;\r\nwcnss->num_vregs = num_vregs;\r\nreturn 0;\r\n}\r\nstatic int wcnss_request_irq(struct qcom_wcnss *wcnss,\r\nstruct platform_device *pdev,\r\nconst char *name,\r\nbool optional,\r\nirq_handler_t thread_fn)\r\n{\r\nint ret;\r\nret = platform_get_irq_byname(pdev, name);\r\nif (ret < 0 && optional) {\r\ndev_dbg(&pdev->dev, "no %s IRQ defined, ignoring\n", name);\r\nreturn 0;\r\n} else if (ret < 0) {\r\ndev_err(&pdev->dev, "no %s IRQ defined\n", name);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, ret,\r\nNULL, thread_fn,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"wcnss", wcnss);\r\nif (ret)\r\ndev_err(&pdev->dev, "request %s IRQ failed\n", name);\r\nreturn ret;\r\n}\r\nstatic int wcnss_alloc_memory_region(struct qcom_wcnss *wcnss)\r\n{\r\nstruct device_node *node;\r\nstruct resource r;\r\nint ret;\r\nnode = of_parse_phandle(wcnss->dev->of_node, "memory-region", 0);\r\nif (!node) {\r\ndev_err(wcnss->dev, "no memory-region specified\n");\r\nreturn -EINVAL;\r\n}\r\nret = of_address_to_resource(node, 0, &r);\r\nif (ret)\r\nreturn ret;\r\nwcnss->mem_phys = wcnss->mem_reloc = r.start;\r\nwcnss->mem_size = resource_size(&r);\r\nwcnss->mem_region = devm_ioremap_wc(wcnss->dev, wcnss->mem_phys, wcnss->mem_size);\r\nif (!wcnss->mem_region) {\r\ndev_err(wcnss->dev, "unable to map memory region: %pa+%zx\n",\r\n&r.start, wcnss->mem_size);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int wcnss_probe(struct platform_device *pdev)\r\n{\r\nconst struct wcnss_data *data;\r\nstruct qcom_wcnss *wcnss;\r\nstruct resource *res;\r\nstruct rproc *rproc;\r\nvoid __iomem *mmio;\r\nint ret;\r\ndata = of_device_get_match_data(&pdev->dev);\r\nif (!qcom_scm_is_available())\r\nreturn -EPROBE_DEFER;\r\nif (!qcom_scm_pas_supported(WCNSS_PAS_ID)) {\r\ndev_err(&pdev->dev, "PAS is not available for WCNSS\n");\r\nreturn -ENXIO;\r\n}\r\nrproc = rproc_alloc(&pdev->dev, pdev->name, &wcnss_ops,\r\nWCNSS_FIRMWARE_NAME, sizeof(*wcnss));\r\nif (!rproc) {\r\ndev_err(&pdev->dev, "unable to allocate remoteproc\n");\r\nreturn -ENOMEM;\r\n}\r\nrproc->fw_ops = &wcnss_fw_ops;\r\nwcnss = (struct qcom_wcnss *)rproc->priv;\r\nwcnss->dev = &pdev->dev;\r\nwcnss->rproc = rproc;\r\nplatform_set_drvdata(pdev, wcnss);\r\ninit_completion(&wcnss->start_done);\r\ninit_completion(&wcnss->stop_done);\r\nmutex_init(&wcnss->iris_lock);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pmu");\r\nmmio = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(mmio)) {\r\nret = PTR_ERR(mmio);\r\ngoto free_rproc;\r\n};\r\nret = wcnss_alloc_memory_region(wcnss);\r\nif (ret)\r\ngoto free_rproc;\r\nwcnss->pmu_cfg = mmio + data->pmu_offset;\r\nwcnss->spare_out = mmio + data->spare_offset;\r\nret = wcnss_init_regulators(wcnss, data->vregs, data->num_vregs);\r\nif (ret)\r\ngoto free_rproc;\r\nret = wcnss_request_irq(wcnss, pdev, "wdog", false, wcnss_wdog_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nwcnss->wdog_irq = ret;\r\nret = wcnss_request_irq(wcnss, pdev, "fatal", false, wcnss_fatal_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nwcnss->fatal_irq = ret;\r\nret = wcnss_request_irq(wcnss, pdev, "ready", true, wcnss_ready_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nwcnss->ready_irq = ret;\r\nret = wcnss_request_irq(wcnss, pdev, "handover", true, wcnss_handover_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nwcnss->handover_irq = ret;\r\nret = wcnss_request_irq(wcnss, pdev, "stop-ack", true, wcnss_stop_ack_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nwcnss->stop_ack_irq = ret;\r\nif (wcnss->stop_ack_irq) {\r\nwcnss->state = qcom_smem_state_get(&pdev->dev, "stop",\r\n&wcnss->stop_bit);\r\nif (IS_ERR(wcnss->state)) {\r\nret = PTR_ERR(wcnss->state);\r\ngoto free_rproc;\r\n}\r\n}\r\nqcom_add_smd_subdev(rproc, &wcnss->smd_subdev);\r\nret = rproc_add(rproc);\r\nif (ret)\r\ngoto free_rproc;\r\nreturn of_platform_populate(pdev->dev.of_node, NULL, NULL, &pdev->dev);\r\nfree_rproc:\r\nrproc_free(rproc);\r\nreturn ret;\r\n}\r\nstatic int wcnss_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_wcnss *wcnss = platform_get_drvdata(pdev);\r\nof_platform_depopulate(&pdev->dev);\r\nqcom_smem_state_put(wcnss->state);\r\nrproc_del(wcnss->rproc);\r\nqcom_remove_smd_subdev(wcnss->rproc, &wcnss->smd_subdev);\r\nrproc_free(wcnss->rproc);\r\nreturn 0;\r\n}\r\nstatic int __init wcnss_init(void)\r\n{\r\nint ret;\r\nret = platform_driver_register(&wcnss_driver);\r\nif (ret)\r\nreturn ret;\r\nret = platform_driver_register(&qcom_iris_driver);\r\nif (ret)\r\nplatform_driver_unregister(&wcnss_driver);\r\nreturn ret;\r\n}\r\nstatic void __exit wcnss_exit(void)\r\n{\r\nplatform_driver_unregister(&qcom_iris_driver);\r\nplatform_driver_unregister(&wcnss_driver);\r\n}
