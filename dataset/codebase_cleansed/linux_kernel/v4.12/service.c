static struct ptlrpc_request_buffer_desc *\r\nptlrpc_alloc_rqbd(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nstruct ptlrpc_request_buffer_desc *rqbd;\r\nrqbd = kzalloc_node(sizeof(*rqbd), GFP_NOFS,\r\ncfs_cpt_spread_node(svc->srv_cptable,\r\nsvcpt->scp_cpt));\r\nif (!rqbd)\r\nreturn NULL;\r\nrqbd->rqbd_svcpt = svcpt;\r\nrqbd->rqbd_refcount = 0;\r\nrqbd->rqbd_cbid.cbid_fn = request_in_callback;\r\nrqbd->rqbd_cbid.cbid_arg = rqbd;\r\nINIT_LIST_HEAD(&rqbd->rqbd_reqs);\r\nrqbd->rqbd_buffer = libcfs_kvzalloc_cpt(svc->srv_cptable,\r\nsvcpt->scp_cpt,\r\nsvc->srv_buf_size,\r\nGFP_KERNEL);\r\nif (!rqbd->rqbd_buffer) {\r\nkfree(rqbd);\r\nreturn NULL;\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nlist_add(&rqbd->rqbd_list, &svcpt->scp_rqbd_idle);\r\nsvcpt->scp_nrqbds_total++;\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn rqbd;\r\n}\r\nstatic void\r\nptlrpc_free_rqbd(struct ptlrpc_request_buffer_desc *rqbd)\r\n{\r\nstruct ptlrpc_service_part *svcpt = rqbd->rqbd_svcpt;\r\nLASSERT(rqbd->rqbd_refcount == 0);\r\nLASSERT(list_empty(&rqbd->rqbd_reqs));\r\nspin_lock(&svcpt->scp_lock);\r\nlist_del(&rqbd->rqbd_list);\r\nsvcpt->scp_nrqbds_total--;\r\nspin_unlock(&svcpt->scp_lock);\r\nkvfree(rqbd->rqbd_buffer);\r\nkfree(rqbd);\r\n}\r\nstatic int\r\nptlrpc_grow_req_bufs(struct ptlrpc_service_part *svcpt, int post)\r\n{\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nstruct ptlrpc_request_buffer_desc *rqbd;\r\nint rc = 0;\r\nint i;\r\nif (svcpt->scp_rqbd_allocating)\r\ngoto try_post;\r\nspin_lock(&svcpt->scp_lock);\r\nif (svcpt->scp_rqbd_allocating) {\r\nLASSERT(svcpt->scp_rqbd_allocating == 1);\r\nspin_unlock(&svcpt->scp_lock);\r\ngoto try_post;\r\n}\r\nsvcpt->scp_rqbd_allocating++;\r\nspin_unlock(&svcpt->scp_lock);\r\nfor (i = 0; i < svc->srv_nbuf_per_group; i++) {\r\nif (svcpt->scp_nrqbds_posted >= svc->srv_nbuf_per_group)\r\nbreak;\r\nrqbd = ptlrpc_alloc_rqbd(svcpt);\r\nif (!rqbd) {\r\nCERROR("%s: Can't allocate request buffer\n",\r\nsvc->srv_name);\r\nrc = -ENOMEM;\r\nbreak;\r\n}\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nLASSERT(svcpt->scp_rqbd_allocating == 1);\r\nsvcpt->scp_rqbd_allocating--;\r\nspin_unlock(&svcpt->scp_lock);\r\nCDEBUG(D_RPCTRACE,\r\n"%s: allocate %d new %d-byte reqbufs (%d/%d left), rc = %d\n",\r\nsvc->srv_name, i, svc->srv_buf_size, svcpt->scp_nrqbds_posted,\r\nsvcpt->scp_nrqbds_total, rc);\r\ntry_post:\r\nif (post && rc == 0)\r\nrc = ptlrpc_server_post_idle_rqbds(svcpt);\r\nreturn rc;\r\n}\r\nstatic struct ptlrpc_hr_thread *\r\nptlrpc_hr_select(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_hr_partition *hrp;\r\nunsigned int rotor;\r\nif (svcpt->scp_cpt >= 0 &&\r\nsvcpt->scp_service->srv_cptable == ptlrpc_hr.hr_cpt_table) {\r\nhrp = ptlrpc_hr.hr_partitions[svcpt->scp_cpt];\r\n} else {\r\nrotor = ptlrpc_hr.hr_rotor++;\r\nrotor %= cfs_cpt_number(ptlrpc_hr.hr_cpt_table);\r\nhrp = ptlrpc_hr.hr_partitions[rotor];\r\n}\r\nrotor = hrp->hrp_rotor++;\r\nreturn &hrp->hrp_thrs[rotor % hrp->hrp_nthrs];\r\n}\r\nvoid ptlrpc_dispatch_difficult_reply(struct ptlrpc_reply_state *rs)\r\n{\r\nstruct ptlrpc_hr_thread *hrt;\r\nLASSERT(list_empty(&rs->rs_list));\r\nhrt = ptlrpc_hr_select(rs->rs_svcpt);\r\nspin_lock(&hrt->hrt_lock);\r\nlist_add_tail(&rs->rs_list, &hrt->hrt_queue);\r\nspin_unlock(&hrt->hrt_lock);\r\nwake_up(&hrt->hrt_waitq);\r\n}\r\nvoid\r\nptlrpc_schedule_difficult_reply(struct ptlrpc_reply_state *rs)\r\n{\r\nassert_spin_locked(&rs->rs_svcpt->scp_rep_lock);\r\nassert_spin_locked(&rs->rs_lock);\r\nLASSERT(rs->rs_difficult);\r\nrs->rs_scheduled_ever = 1;\r\nif (rs->rs_scheduled) {\r\nreturn;\r\n}\r\nrs->rs_scheduled = 1;\r\nlist_del_init(&rs->rs_list);\r\nptlrpc_dispatch_difficult_reply(rs);\r\n}\r\nstatic int\r\nptlrpc_server_post_idle_rqbds(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_request_buffer_desc *rqbd;\r\nint rc;\r\nint posted = 0;\r\nfor (;;) {\r\nspin_lock(&svcpt->scp_lock);\r\nif (list_empty(&svcpt->scp_rqbd_idle)) {\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn posted;\r\n}\r\nrqbd = list_entry(svcpt->scp_rqbd_idle.next,\r\nstruct ptlrpc_request_buffer_desc,\r\nrqbd_list);\r\nlist_del(&rqbd->rqbd_list);\r\nsvcpt->scp_nrqbds_posted++;\r\nlist_add(&rqbd->rqbd_list, &svcpt->scp_rqbd_posted);\r\nspin_unlock(&svcpt->scp_lock);\r\nrc = ptlrpc_register_rqbd(rqbd);\r\nif (rc != 0)\r\nbreak;\r\nposted = 1;\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nsvcpt->scp_nrqbds_posted--;\r\nlist_del(&rqbd->rqbd_list);\r\nlist_add_tail(&rqbd->rqbd_list, &svcpt->scp_rqbd_idle);\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn -1;\r\n}\r\nstatic void ptlrpc_at_timer(unsigned long castmeharder)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nsvcpt = (struct ptlrpc_service_part *)castmeharder;\r\nsvcpt->scp_at_check = 1;\r\nsvcpt->scp_at_checktime = cfs_time_current();\r\nwake_up(&svcpt->scp_waitq);\r\n}\r\nstatic void\r\nptlrpc_server_nthreads_check(struct ptlrpc_service *svc,\r\nstruct ptlrpc_service_conf *conf)\r\n{\r\nstruct ptlrpc_service_thr_conf *tc = &conf->psc_thr;\r\nunsigned int init;\r\nunsigned int total;\r\nunsigned int nthrs;\r\nint weight;\r\ninit = PTLRPC_NTHRS_INIT + (svc->srv_ops.so_hpreq_handler != NULL);\r\ninit = max_t(int, init, tc->tc_nthrs_init);\r\nLASSERT(tc->tc_nthrs_max != 0);\r\nif (tc->tc_nthrs_user != 0) {\r\ntotal = min(tc->tc_nthrs_max * 8, tc->tc_nthrs_user);\r\nnthrs = total / svc->srv_ncpts;\r\ninit = max(init, nthrs);\r\ngoto out;\r\n}\r\ntotal = tc->tc_nthrs_max;\r\nif (tc->tc_nthrs_base == 0) {\r\nnthrs = total / svc->srv_ncpts;\r\ngoto out;\r\n}\r\nnthrs = tc->tc_nthrs_base;\r\nif (svc->srv_ncpts == 1) {\r\nint i;\r\nweight = cfs_cpt_weight(svc->srv_cptable, CFS_CPT_ANY);\r\nfor (i = 1; (weight >> (i + 1)) != 0 &&\r\n(tc->tc_nthrs_base >> i) != 0; i++)\r\nnthrs += tc->tc_nthrs_base >> i;\r\n}\r\nif (tc->tc_thr_factor != 0) {\r\nint factor = tc->tc_thr_factor;\r\nconst int fade = 4;\r\nif (cpumask_weight(topology_sibling_cpumask(0)) > 1) {\r\nfactor = factor - (factor >> 1) + (factor >> 3);\r\n}\r\nweight = cfs_cpt_weight(svc->srv_cptable, 0);\r\nLASSERT(weight > 0);\r\nfor (; factor > 0 && weight > 0; factor--, weight -= fade)\r\nnthrs += min(weight, fade) * factor;\r\n}\r\nif (nthrs * svc->srv_ncpts > tc->tc_nthrs_max) {\r\nnthrs = max(tc->tc_nthrs_base,\r\ntc->tc_nthrs_max / svc->srv_ncpts);\r\n}\r\nout:\r\nnthrs = max(nthrs, tc->tc_nthrs_init);\r\nsvc->srv_nthrs_cpt_limit = nthrs;\r\nsvc->srv_nthrs_cpt_init = init;\r\nif (nthrs * svc->srv_ncpts > tc->tc_nthrs_max) {\r\nCDEBUG(D_OTHER, "%s: This service may have more threads (%d) than the given soft limit (%d)\n",\r\nsvc->srv_name, nthrs * svc->srv_ncpts,\r\ntc->tc_nthrs_max);\r\n}\r\n}\r\nstatic int\r\nptlrpc_service_part_init(struct ptlrpc_service *svc,\r\nstruct ptlrpc_service_part *svcpt, int cpt)\r\n{\r\nstruct ptlrpc_at_array *array;\r\nint size;\r\nint index;\r\nint rc;\r\nsvcpt->scp_cpt = cpt;\r\nINIT_LIST_HEAD(&svcpt->scp_threads);\r\nspin_lock_init(&svcpt->scp_lock);\r\nINIT_LIST_HEAD(&svcpt->scp_rqbd_idle);\r\nINIT_LIST_HEAD(&svcpt->scp_rqbd_posted);\r\nINIT_LIST_HEAD(&svcpt->scp_req_incoming);\r\ninit_waitqueue_head(&svcpt->scp_waitq);\r\nINIT_LIST_HEAD(&svcpt->scp_hist_reqs);\r\nINIT_LIST_HEAD(&svcpt->scp_hist_rqbds);\r\nspin_lock_init(&svcpt->scp_req_lock);\r\nspin_lock_init(&svcpt->scp_rep_lock);\r\nINIT_LIST_HEAD(&svcpt->scp_rep_active);\r\nINIT_LIST_HEAD(&svcpt->scp_rep_idle);\r\ninit_waitqueue_head(&svcpt->scp_rep_waitq);\r\natomic_set(&svcpt->scp_nreps_difficult, 0);\r\nspin_lock_init(&svcpt->scp_at_lock);\r\narray = &svcpt->scp_at_array;\r\nsize = at_est2timeout(at_max);\r\narray->paa_size = size;\r\narray->paa_count = 0;\r\narray->paa_deadline = -1;\r\narray->paa_reqs_array =\r\nkzalloc_node(sizeof(struct list_head) * size, GFP_NOFS,\r\ncfs_cpt_spread_node(svc->srv_cptable, cpt));\r\nif (!array->paa_reqs_array)\r\nreturn -ENOMEM;\r\nfor (index = 0; index < size; index++)\r\nINIT_LIST_HEAD(&array->paa_reqs_array[index]);\r\narray->paa_reqs_count =\r\nkzalloc_node(sizeof(__u32) * size, GFP_NOFS,\r\ncfs_cpt_spread_node(svc->srv_cptable, cpt));\r\nif (!array->paa_reqs_count)\r\ngoto free_reqs_array;\r\nsetup_timer(&svcpt->scp_at_timer, ptlrpc_at_timer,\r\n(unsigned long)svcpt);\r\nat_init(&svcpt->scp_at_estimate, 10, 0);\r\nsvcpt->scp_service = svc;\r\nrc = ptlrpc_grow_req_bufs(svcpt, 0);\r\nif (rc != 0)\r\ngoto free_reqs_count;\r\nreturn 0;\r\nfree_reqs_count:\r\nkfree(array->paa_reqs_count);\r\narray->paa_reqs_count = NULL;\r\nfree_reqs_array:\r\nkfree(array->paa_reqs_array);\r\narray->paa_reqs_array = NULL;\r\nreturn -ENOMEM;\r\n}\r\nstruct ptlrpc_service *\r\nptlrpc_register_service(struct ptlrpc_service_conf *conf,\r\nstruct kset *parent,\r\nstruct dentry *debugfs_entry)\r\n{\r\nstruct ptlrpc_service_cpt_conf *cconf = &conf->psc_cpt;\r\nstruct ptlrpc_service *service;\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct cfs_cpt_table *cptable;\r\n__u32 *cpts = NULL;\r\nint ncpts;\r\nint cpt;\r\nint rc;\r\nint i;\r\nLASSERT(conf->psc_buf.bc_nbufs > 0);\r\nLASSERT(conf->psc_buf.bc_buf_size >=\r\nconf->psc_buf.bc_req_max_size + SPTLRPC_MAX_PAYLOAD);\r\nLASSERT(conf->psc_thr.tc_ctx_tags != 0);\r\ncptable = cconf->cc_cptable;\r\nif (!cptable)\r\ncptable = cfs_cpt_table;\r\nif (!conf->psc_thr.tc_cpu_affinity) {\r\nncpts = 1;\r\n} else {\r\nncpts = cfs_cpt_number(cptable);\r\nif (cconf->cc_pattern) {\r\nstruct cfs_expr_list *el;\r\nrc = cfs_expr_list_parse(cconf->cc_pattern,\r\nstrlen(cconf->cc_pattern),\r\n0, ncpts - 1, &el);\r\nif (rc != 0) {\r\nCERROR("%s: invalid CPT pattern string: %s",\r\nconf->psc_name, cconf->cc_pattern);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nrc = cfs_expr_list_values(el, ncpts, &cpts);\r\ncfs_expr_list_free(el);\r\nif (rc <= 0) {\r\nCERROR("%s: failed to parse CPT array %s: %d\n",\r\nconf->psc_name, cconf->cc_pattern, rc);\r\nkfree(cpts);\r\nreturn ERR_PTR(rc < 0 ? rc : -EINVAL);\r\n}\r\nncpts = rc;\r\n}\r\n}\r\nservice = kzalloc(offsetof(struct ptlrpc_service, srv_parts[ncpts]),\r\nGFP_NOFS);\r\nif (!service) {\r\nkfree(cpts);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nservice->srv_cptable = cptable;\r\nservice->srv_cpts = cpts;\r\nservice->srv_ncpts = ncpts;\r\nservice->srv_cpt_bits = 0;\r\nwhile ((1 << service->srv_cpt_bits) < cfs_cpt_number(cptable))\r\nservice->srv_cpt_bits++;\r\nspin_lock_init(&service->srv_lock);\r\nservice->srv_name = conf->psc_name;\r\nservice->srv_watchdog_factor = conf->psc_watchdog_factor;\r\nINIT_LIST_HEAD(&service->srv_list);\r\nservice->srv_nbuf_per_group = test_req_buffer_pressure ?\r\n1 : conf->psc_buf.bc_nbufs;\r\nservice->srv_max_req_size = conf->psc_buf.bc_req_max_size +\r\nSPTLRPC_MAX_PAYLOAD;\r\nservice->srv_buf_size = conf->psc_buf.bc_buf_size;\r\nservice->srv_rep_portal = conf->psc_buf.bc_rep_portal;\r\nservice->srv_req_portal = conf->psc_buf.bc_req_portal;\r\nservice->srv_max_reply_size = 1;\r\nwhile (service->srv_max_reply_size <\r\nconf->psc_buf.bc_rep_max_size + SPTLRPC_MAX_PAYLOAD)\r\nservice->srv_max_reply_size <<= 1;\r\nservice->srv_thread_name = conf->psc_thr.tc_thr_name;\r\nservice->srv_ctx_tags = conf->psc_thr.tc_ctx_tags;\r\nservice->srv_hpreq_ratio = PTLRPC_SVC_HP_RATIO;\r\nservice->srv_ops = conf->psc_ops;\r\nfor (i = 0; i < ncpts; i++) {\r\nif (!conf->psc_thr.tc_cpu_affinity)\r\ncpt = CFS_CPT_ANY;\r\nelse\r\ncpt = cpts ? cpts[i] : i;\r\nsvcpt = kzalloc_node(sizeof(*svcpt), GFP_NOFS,\r\ncfs_cpt_spread_node(cptable, cpt));\r\nif (!svcpt) {\r\nrc = -ENOMEM;\r\ngoto failed;\r\n}\r\nservice->srv_parts[i] = svcpt;\r\nrc = ptlrpc_service_part_init(service, svcpt, cpt);\r\nif (rc != 0)\r\ngoto failed;\r\n}\r\nptlrpc_server_nthreads_check(service, conf);\r\nrc = LNetSetLazyPortal(service->srv_req_portal);\r\nLASSERT(rc == 0);\r\nmutex_lock(&ptlrpc_all_services_mutex);\r\nlist_add(&service->srv_list, &ptlrpc_all_services);\r\nmutex_unlock(&ptlrpc_all_services_mutex);\r\nif (parent) {\r\nrc = ptlrpc_sysfs_register_service(parent, service);\r\nif (rc)\r\ngoto failed;\r\n}\r\nif (!IS_ERR_OR_NULL(debugfs_entry))\r\nptlrpc_ldebugfs_register_service(debugfs_entry, service);\r\nrc = ptlrpc_service_nrs_setup(service);\r\nif (rc != 0)\r\ngoto failed;\r\nCDEBUG(D_NET, "%s: Started, listening on portal %d\n",\r\nservice->srv_name, service->srv_req_portal);\r\nrc = ptlrpc_start_threads(service);\r\nif (rc != 0) {\r\nCERROR("Failed to start threads for service %s: %d\n",\r\nservice->srv_name, rc);\r\ngoto failed;\r\n}\r\nreturn service;\r\nfailed:\r\nptlrpc_unregister_service(service);\r\nreturn ERR_PTR(rc);\r\n}\r\nstatic void ptlrpc_server_free_request(struct ptlrpc_request *req)\r\n{\r\nLASSERT(atomic_read(&req->rq_refcount) == 0);\r\nLASSERT(list_empty(&req->rq_timed_list));\r\nptlrpc_req_drop_rs(req);\r\nsptlrpc_svc_ctx_decref(req);\r\nif (req != &req->rq_rqbd->rqbd_req) {\r\nptlrpc_request_cache_free(req);\r\n}\r\n}\r\nstatic void ptlrpc_server_drop_request(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_request_buffer_desc *rqbd = req->rq_rqbd;\r\nstruct ptlrpc_service_part *svcpt = rqbd->rqbd_svcpt;\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nint refcount;\r\nstruct list_head *tmp;\r\nstruct list_head *nxt;\r\nif (!atomic_dec_and_test(&req->rq_refcount))\r\nreturn;\r\nif (req->rq_at_linked) {\r\nspin_lock(&svcpt->scp_at_lock);\r\nif (likely(req->rq_at_linked))\r\nptlrpc_at_remove_timed(req);\r\nspin_unlock(&svcpt->scp_at_lock);\r\n}\r\nLASSERT(list_empty(&req->rq_timed_list));\r\nif (req->rq_export) {\r\nclass_export_put(req->rq_export);\r\nreq->rq_export = NULL;\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nlist_add(&req->rq_list, &rqbd->rqbd_reqs);\r\nrefcount = --(rqbd->rqbd_refcount);\r\nif (refcount == 0) {\r\nlist_del(&rqbd->rqbd_list);\r\nlist_add_tail(&rqbd->rqbd_list, &svcpt->scp_hist_rqbds);\r\nsvcpt->scp_hist_nrqbds++;\r\nwhile (svcpt->scp_hist_nrqbds > svc->srv_hist_nrqbds_cpt_max) {\r\nrqbd = list_entry(svcpt->scp_hist_rqbds.next,\r\nstruct ptlrpc_request_buffer_desc,\r\nrqbd_list);\r\nlist_del(&rqbd->rqbd_list);\r\nsvcpt->scp_hist_nrqbds--;\r\nlist_for_each(tmp, &rqbd->rqbd_reqs) {\r\nreq = list_entry(tmp, struct ptlrpc_request,\r\nrq_list);\r\nif (req->rq_history_seq >\r\nsvcpt->scp_hist_seq_culled) {\r\nsvcpt->scp_hist_seq_culled =\r\nreq->rq_history_seq;\r\n}\r\nlist_del(&req->rq_history_list);\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\nlist_for_each_safe(tmp, nxt, &rqbd->rqbd_reqs) {\r\nreq = list_entry(rqbd->rqbd_reqs.next,\r\nstruct ptlrpc_request,\r\nrq_list);\r\nlist_del(&req->rq_list);\r\nptlrpc_server_free_request(req);\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nLASSERT(atomic_read(&rqbd->rqbd_req.rq_refcount) ==\r\n0);\r\nlist_add_tail(&rqbd->rqbd_list, &svcpt->scp_rqbd_idle);\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\n} else if (req->rq_reply_state && req->rq_reply_state->rs_prealloc) {\r\nlist_del(&req->rq_list);\r\nlist_del_init(&req->rq_history_list);\r\nif (req->rq_history_seq > svcpt->scp_hist_seq_culled)\r\nsvcpt->scp_hist_seq_culled = req->rq_history_seq;\r\nspin_unlock(&svcpt->scp_lock);\r\nptlrpc_server_free_request(req);\r\n} else {\r\nspin_unlock(&svcpt->scp_lock);\r\n}\r\n}\r\nstatic void ptlrpc_server_finish_request(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req)\r\n{\r\nptlrpc_server_hpreq_fini(req);\r\nif (req->rq_session.lc_thread) {\r\nlu_context_exit(&req->rq_session);\r\nlu_context_fini(&req->rq_session);\r\n}\r\nptlrpc_server_drop_request(req);\r\n}\r\nstatic void ptlrpc_server_finish_active_request(\r\nstruct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req)\r\n{\r\nspin_lock(&svcpt->scp_req_lock);\r\nptlrpc_nrs_req_stop_nolock(req);\r\nsvcpt->scp_nreqs_active--;\r\nif (req->rq_hp)\r\nsvcpt->scp_nhreqs_active--;\r\nspin_unlock(&svcpt->scp_req_lock);\r\nptlrpc_nrs_req_finalize(req);\r\nif (req->rq_export)\r\nclass_export_rpc_dec(req->rq_export);\r\nptlrpc_server_finish_request(svcpt, req);\r\n}\r\nstatic int ptlrpc_check_req(struct ptlrpc_request *req)\r\n{\r\nstruct obd_device *obd = req->rq_export->exp_obd;\r\nint rc = 0;\r\nif (unlikely(lustre_msg_get_conn_cnt(req->rq_reqmsg) <\r\nreq->rq_export->exp_conn_cnt)) {\r\nDEBUG_REQ(D_RPCTRACE, req,\r\n"DROPPING req from old connection %d < %d",\r\nlustre_msg_get_conn_cnt(req->rq_reqmsg),\r\nreq->rq_export->exp_conn_cnt);\r\nreturn -EEXIST;\r\n}\r\nif (unlikely(!obd || obd->obd_fail)) {\r\nCDEBUG(D_RPCTRACE, "Dropping req %p for failed obd %s\n",\r\nreq, obd ? obd->obd_name : "unknown");\r\nrc = -ENODEV;\r\n} else if (lustre_msg_get_flags(req->rq_reqmsg) &\r\n(MSG_REPLAY | MSG_REQ_REPLAY_DONE)) {\r\nDEBUG_REQ(D_ERROR, req, "Invalid replay without recovery");\r\nclass_fail_export(req->rq_export);\r\nrc = -ENODEV;\r\n} else if (lustre_msg_get_transno(req->rq_reqmsg) != 0) {\r\nDEBUG_REQ(D_ERROR, req,\r\n"Invalid req with transno %llu without recovery",\r\nlustre_msg_get_transno(req->rq_reqmsg));\r\nclass_fail_export(req->rq_export);\r\nrc = -ENODEV;\r\n}\r\nif (unlikely(rc < 0)) {\r\nreq->rq_status = rc;\r\nptlrpc_error(req);\r\n}\r\nreturn rc;\r\n}\r\nstatic void ptlrpc_at_set_timer(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_at_array *array = &svcpt->scp_at_array;\r\n__s32 next;\r\nif (array->paa_count == 0) {\r\ndel_timer(&svcpt->scp_at_timer);\r\nreturn;\r\n}\r\nnext = (__s32)(array->paa_deadline - ktime_get_real_seconds() -\r\nat_early_margin);\r\nif (next <= 0) {\r\nptlrpc_at_timer((unsigned long)svcpt);\r\n} else {\r\nmod_timer(&svcpt->scp_at_timer, cfs_time_shift(next));\r\nCDEBUG(D_INFO, "armed %s at %+ds\n",\r\nsvcpt->scp_service->srv_name, next);\r\n}\r\n}\r\nstatic int ptlrpc_at_add_timed(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_service_part *svcpt = req->rq_rqbd->rqbd_svcpt;\r\nstruct ptlrpc_at_array *array = &svcpt->scp_at_array;\r\nstruct ptlrpc_request *rq = NULL;\r\n__u32 index;\r\nif (AT_OFF)\r\nreturn 0;\r\nif (req->rq_no_reply)\r\nreturn 0;\r\nif ((lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT) == 0)\r\nreturn -ENOSYS;\r\nspin_lock(&svcpt->scp_at_lock);\r\nLASSERT(list_empty(&req->rq_timed_list));\r\ndiv_u64_rem(req->rq_deadline, array->paa_size, &index);\r\nif (array->paa_reqs_count[index] > 0) {\r\nlist_for_each_entry_reverse(rq, &array->paa_reqs_array[index],\r\nrq_timed_list) {\r\nif (req->rq_deadline >= rq->rq_deadline) {\r\nlist_add(&req->rq_timed_list,\r\n&rq->rq_timed_list);\r\nbreak;\r\n}\r\n}\r\n}\r\nif (list_empty(&req->rq_timed_list))\r\nlist_add(&req->rq_timed_list, &array->paa_reqs_array[index]);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_at_linked = 1;\r\nspin_unlock(&req->rq_lock);\r\nreq->rq_at_index = index;\r\narray->paa_reqs_count[index]++;\r\narray->paa_count++;\r\nif (array->paa_count == 1 || array->paa_deadline > req->rq_deadline) {\r\narray->paa_deadline = req->rq_deadline;\r\nptlrpc_at_set_timer(svcpt);\r\n}\r\nspin_unlock(&svcpt->scp_at_lock);\r\nreturn 0;\r\n}\r\nstatic void\r\nptlrpc_at_remove_timed(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_at_array *array;\r\narray = &req->rq_rqbd->rqbd_svcpt->scp_at_array;\r\nLASSERT(!list_empty(&req->rq_timed_list));\r\nlist_del_init(&req->rq_timed_list);\r\nspin_lock(&req->rq_lock);\r\nreq->rq_at_linked = 0;\r\nspin_unlock(&req->rq_lock);\r\narray->paa_reqs_count[req->rq_at_index]--;\r\narray->paa_count--;\r\n}\r\nstatic int ptlrpc_at_send_early_reply(struct ptlrpc_request *req)\r\n{\r\nstruct ptlrpc_service_part *svcpt = req->rq_rqbd->rqbd_svcpt;\r\nstruct ptlrpc_request *reqcopy;\r\nstruct lustre_msg *reqmsg;\r\nlong olddl = req->rq_deadline - ktime_get_real_seconds();\r\ntime64_t newdl;\r\nint rc;\r\nDEBUG_REQ(D_ADAPTTO, req,\r\n"%ssending early reply (deadline %+lds, margin %+lds) for %d+%d",\r\nAT_OFF ? "AT off - not " : "",\r\nolddl, olddl - at_get(&svcpt->scp_at_estimate),\r\nat_get(&svcpt->scp_at_estimate), at_extra);\r\nif (AT_OFF)\r\nreturn 0;\r\nif (olddl < 0) {\r\nDEBUG_REQ(D_WARNING, req, "Already past deadline (%+lds), not sending early reply. Consider increasing at_early_margin (%d)?",\r\nolddl, at_early_margin);\r\nreturn -ETIMEDOUT;\r\n}\r\nif (!(lustre_msghdr_get_flags(req->rq_reqmsg) & MSGHDR_AT_SUPPORT)) {\r\nDEBUG_REQ(D_INFO, req, "Wanted to ask client for more time, but no AT support");\r\nreturn -ENOSYS;\r\n}\r\nat_measured(&svcpt->scp_at_estimate, at_extra +\r\nktime_get_real_seconds() - req->rq_arrival_time.tv_sec);\r\nnewdl = req->rq_arrival_time.tv_sec + at_get(&svcpt->scp_at_estimate);\r\nif (req->rq_deadline >= newdl) {\r\nDEBUG_REQ(D_WARNING, req, "Couldn't add any time (%ld/%lld), not sending early reply\n",\r\nolddl, newdl - ktime_get_real_seconds());\r\nreturn -ETIMEDOUT;\r\n}\r\nreqcopy = ptlrpc_request_cache_alloc(GFP_NOFS);\r\nif (!reqcopy)\r\nreturn -ENOMEM;\r\nreqmsg = libcfs_kvzalloc(req->rq_reqlen, GFP_NOFS);\r\nif (!reqmsg) {\r\nrc = -ENOMEM;\r\ngoto out_free;\r\n}\r\n*reqcopy = *req;\r\nreqcopy->rq_reply_state = NULL;\r\nreqcopy->rq_rep_swab_mask = 0;\r\nreqcopy->rq_pack_bulk = 0;\r\nreqcopy->rq_pack_udesc = 0;\r\nreqcopy->rq_packed_final = 0;\r\nsptlrpc_svc_ctx_addref(reqcopy);\r\nreqcopy->rq_reqmsg = reqmsg;\r\nmemcpy(reqmsg, req->rq_reqmsg, req->rq_reqlen);\r\nLASSERT(atomic_read(&req->rq_refcount));\r\nif (atomic_read(&req->rq_refcount) == 1) {\r\nDEBUG_REQ(D_ADAPTTO, reqcopy, "Normal reply already sent out, abort sending early reply\n");\r\nrc = -EINVAL;\r\ngoto out;\r\n}\r\nreqcopy->rq_export = class_conn2export(\r\nlustre_msg_get_handle(reqcopy->rq_reqmsg));\r\nif (!reqcopy->rq_export) {\r\nrc = -ENODEV;\r\ngoto out;\r\n}\r\nclass_export_rpc_inc(reqcopy->rq_export);\r\nif (reqcopy->rq_export->exp_obd &&\r\nreqcopy->rq_export->exp_obd->obd_fail) {\r\nrc = -ENODEV;\r\ngoto out_put;\r\n}\r\nrc = lustre_pack_reply_flags(reqcopy, 1, NULL, NULL, LPRFL_EARLY_REPLY);\r\nif (rc)\r\ngoto out_put;\r\nrc = ptlrpc_send_reply(reqcopy, PTLRPC_REPLY_EARLY);\r\nif (!rc) {\r\nreq->rq_deadline = newdl;\r\nreq->rq_early_count++;\r\n} else {\r\nDEBUG_REQ(D_ERROR, req, "Early reply send failed %d", rc);\r\n}\r\nptlrpc_req_drop_rs(reqcopy);\r\nout_put:\r\nclass_export_rpc_dec(reqcopy->rq_export);\r\nclass_export_put(reqcopy->rq_export);\r\nout:\r\nsptlrpc_svc_ctx_decref(reqcopy);\r\nkvfree(reqmsg);\r\nout_free:\r\nptlrpc_request_cache_free(reqcopy);\r\nreturn rc;\r\n}\r\nstatic void ptlrpc_at_check_timed(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_at_array *array = &svcpt->scp_at_array;\r\nstruct ptlrpc_request *rq, *n;\r\nstruct list_head work_list;\r\n__u32 index, count;\r\ntime64_t deadline;\r\ntime64_t now = ktime_get_real_seconds();\r\nlong delay;\r\nint first, counter = 0;\r\nspin_lock(&svcpt->scp_at_lock);\r\nif (svcpt->scp_at_check == 0) {\r\nspin_unlock(&svcpt->scp_at_lock);\r\nreturn;\r\n}\r\ndelay = cfs_time_sub(cfs_time_current(), svcpt->scp_at_checktime);\r\nsvcpt->scp_at_check = 0;\r\nif (array->paa_count == 0) {\r\nspin_unlock(&svcpt->scp_at_lock);\r\nreturn;\r\n}\r\nfirst = array->paa_deadline - now;\r\nif (first > at_early_margin) {\r\nptlrpc_at_set_timer(svcpt);\r\nspin_unlock(&svcpt->scp_at_lock);\r\nreturn;\r\n}\r\nINIT_LIST_HEAD(&work_list);\r\ndeadline = -1;\r\ndiv_u64_rem(array->paa_deadline, array->paa_size, &index);\r\ncount = array->paa_count;\r\nwhile (count > 0) {\r\ncount -= array->paa_reqs_count[index];\r\nlist_for_each_entry_safe(rq, n, &array->paa_reqs_array[index],\r\nrq_timed_list) {\r\nif (rq->rq_deadline > now + at_early_margin) {\r\nif (deadline == -1 ||\r\nrq->rq_deadline < deadline)\r\ndeadline = rq->rq_deadline;\r\nbreak;\r\n}\r\nptlrpc_at_remove_timed(rq);\r\nif (likely(atomic_inc_not_zero(&rq->rq_refcount)))\r\nlist_add(&rq->rq_timed_list, &work_list);\r\ncounter++;\r\n}\r\nif (++index >= array->paa_size)\r\nindex = 0;\r\n}\r\narray->paa_deadline = deadline;\r\nptlrpc_at_set_timer(svcpt);\r\nspin_unlock(&svcpt->scp_at_lock);\r\nCDEBUG(D_ADAPTTO, "timeout in %+ds, asking for %d secs on %d early replies\n",\r\nfirst, at_extra, counter);\r\nif (first < 0) {\r\nLCONSOLE_WARN("%s: This server is not able to keep up with request traffic (cpu-bound).\n",\r\nsvcpt->scp_service->srv_name);\r\nCWARN("earlyQ=%d reqQ=%d recA=%d, svcEst=%d, delay=%ld(jiff)\n",\r\ncounter, svcpt->scp_nreqs_incoming,\r\nsvcpt->scp_nreqs_active,\r\nat_get(&svcpt->scp_at_estimate), delay);\r\n}\r\nwhile (!list_empty(&work_list)) {\r\nrq = list_entry(work_list.next, struct ptlrpc_request,\r\nrq_timed_list);\r\nlist_del_init(&rq->rq_timed_list);\r\nif (ptlrpc_at_send_early_reply(rq) == 0)\r\nptlrpc_at_add_timed(rq);\r\nptlrpc_server_drop_request(rq);\r\n}\r\n}\r\nstatic int ptlrpc_server_hpreq_init(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req)\r\n{\r\nint rc = 0;\r\nif (svcpt->scp_service->srv_ops.so_hpreq_handler) {\r\nrc = svcpt->scp_service->srv_ops.so_hpreq_handler(req);\r\nif (rc < 0)\r\nreturn rc;\r\nLASSERT(rc == 0);\r\n}\r\nif (req->rq_export && req->rq_ops) {\r\nif (req->rq_ops->hpreq_check) {\r\nrc = req->rq_ops->hpreq_check(req);\r\nif (rc == -ESTALE) {\r\nreq->rq_status = rc;\r\nptlrpc_error(req);\r\n}\r\nLASSERT(rc <= 1);\r\n}\r\nspin_lock_bh(&req->rq_export->exp_rpc_lock);\r\nlist_add(&req->rq_exp_list, &req->rq_export->exp_hp_rpcs);\r\nspin_unlock_bh(&req->rq_export->exp_rpc_lock);\r\n}\r\nptlrpc_nrs_req_initialize(svcpt, req, rc);\r\nreturn rc;\r\n}\r\nstatic void ptlrpc_server_hpreq_fini(struct ptlrpc_request *req)\r\n{\r\nif (req->rq_export && req->rq_ops) {\r\nif (req->rq_ops->hpreq_fini)\r\nreq->rq_ops->hpreq_fini(req);\r\nspin_lock_bh(&req->rq_export->exp_rpc_lock);\r\nlist_del_init(&req->rq_exp_list);\r\nspin_unlock_bh(&req->rq_export->exp_rpc_lock);\r\n}\r\n}\r\nstatic int ptlrpc_server_request_add(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_request *req)\r\n{\r\nint rc;\r\nrc = ptlrpc_server_hpreq_init(svcpt, req);\r\nif (rc < 0)\r\nreturn rc;\r\nptlrpc_nrs_req_add(svcpt, req, !!rc);\r\nreturn 0;\r\n}\r\nstatic bool ptlrpc_server_allow_high(struct ptlrpc_service_part *svcpt,\r\nbool force)\r\n{\r\nint running = svcpt->scp_nthrs_running;\r\nif (!nrs_svcpt_has_hp(svcpt))\r\nreturn false;\r\nif (force)\r\nreturn true;\r\nif (unlikely(svcpt->scp_service->srv_req_portal == MDS_REQUEST_PORTAL &&\r\nCFS_FAIL_PRECHECK(OBD_FAIL_PTLRPC_CANCEL_RESEND))) {\r\nrunning = PTLRPC_NTHRS_INIT;\r\nif (svcpt->scp_service->srv_ops.so_hpreq_handler)\r\nrunning += 1;\r\n}\r\nif (svcpt->scp_nreqs_active >= running - 1)\r\nreturn false;\r\nif (svcpt->scp_nhreqs_active == 0)\r\nreturn true;\r\nreturn !ptlrpc_nrs_req_pending_nolock(svcpt, false) ||\r\nsvcpt->scp_hreq_count < svcpt->scp_service->srv_hpreq_ratio;\r\n}\r\nstatic bool ptlrpc_server_high_pending(struct ptlrpc_service_part *svcpt,\r\nbool force)\r\n{\r\nreturn ptlrpc_server_allow_high(svcpt, force) &&\r\nptlrpc_nrs_req_pending_nolock(svcpt, true);\r\n}\r\nstatic bool ptlrpc_server_allow_normal(struct ptlrpc_service_part *svcpt,\r\nbool force)\r\n{\r\nint running = svcpt->scp_nthrs_running;\r\nif (unlikely(svcpt->scp_service->srv_req_portal == MDS_REQUEST_PORTAL &&\r\nCFS_FAIL_PRECHECK(OBD_FAIL_PTLRPC_CANCEL_RESEND))) {\r\nrunning = PTLRPC_NTHRS_INIT;\r\nif (svcpt->scp_service->srv_ops.so_hpreq_handler)\r\nrunning += 1;\r\n}\r\nif (force ||\r\nsvcpt->scp_nreqs_active < running - 2)\r\nreturn true;\r\nif (svcpt->scp_nreqs_active >= running - 1)\r\nreturn false;\r\nreturn svcpt->scp_nhreqs_active > 0 || !nrs_svcpt_has_hp(svcpt);\r\n}\r\nstatic bool ptlrpc_server_normal_pending(struct ptlrpc_service_part *svcpt,\r\nbool force)\r\n{\r\nreturn ptlrpc_server_allow_normal(svcpt, force) &&\r\nptlrpc_nrs_req_pending_nolock(svcpt, false);\r\n}\r\nstatic inline bool\r\nptlrpc_server_request_pending(struct ptlrpc_service_part *svcpt, bool force)\r\n{\r\nreturn ptlrpc_server_high_pending(svcpt, force) ||\r\nptlrpc_server_normal_pending(svcpt, force);\r\n}\r\nstatic struct ptlrpc_request *\r\nptlrpc_server_request_get(struct ptlrpc_service_part *svcpt, bool force)\r\n{\r\nstruct ptlrpc_request *req = NULL;\r\nspin_lock(&svcpt->scp_req_lock);\r\nif (ptlrpc_server_high_pending(svcpt, force)) {\r\nreq = ptlrpc_nrs_req_get_nolock(svcpt, true, force);\r\nif (req) {\r\nsvcpt->scp_hreq_count++;\r\ngoto got_request;\r\n}\r\n}\r\nif (ptlrpc_server_normal_pending(svcpt, force)) {\r\nreq = ptlrpc_nrs_req_get_nolock(svcpt, false, force);\r\nif (req) {\r\nsvcpt->scp_hreq_count = 0;\r\ngoto got_request;\r\n}\r\n}\r\nspin_unlock(&svcpt->scp_req_lock);\r\nreturn NULL;\r\ngot_request:\r\nsvcpt->scp_nreqs_active++;\r\nif (req->rq_hp)\r\nsvcpt->scp_nhreqs_active++;\r\nspin_unlock(&svcpt->scp_req_lock);\r\nif (likely(req->rq_export))\r\nclass_export_rpc_inc(req->rq_export);\r\nreturn req;\r\n}\r\nstatic int\r\nptlrpc_server_handle_req_in(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_thread *thread)\r\n{\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nstruct ptlrpc_request *req;\r\n__u32 deadline;\r\nint rc;\r\nspin_lock(&svcpt->scp_lock);\r\nif (list_empty(&svcpt->scp_req_incoming)) {\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn 0;\r\n}\r\nreq = list_entry(svcpt->scp_req_incoming.next,\r\nstruct ptlrpc_request, rq_list);\r\nlist_del_init(&req->rq_list);\r\nsvcpt->scp_nreqs_incoming--;\r\nspin_unlock(&svcpt->scp_lock);\r\nrc = sptlrpc_svc_unwrap_request(req);\r\nswitch (rc) {\r\ncase SECSVC_OK:\r\nbreak;\r\ncase SECSVC_COMPLETE:\r\ntarget_send_reply(req, 0, OBD_FAIL_MDS_ALL_REPLY_NET);\r\ngoto err_req;\r\ncase SECSVC_DROP:\r\ngoto err_req;\r\ndefault:\r\nLBUG();\r\n}\r\nif (SPTLRPC_FLVR_POLICY(req->rq_flvr.sf_rpc) != SPTLRPC_POLICY_NULL) {\r\nrc = ptlrpc_unpack_req_msg(req, req->rq_reqlen);\r\nif (rc != 0) {\r\nCERROR("error unpacking request: ptl %d from %s x%llu\n",\r\nsvc->srv_req_portal, libcfs_id2str(req->rq_peer),\r\nreq->rq_xid);\r\ngoto err_req;\r\n}\r\n}\r\nrc = lustre_unpack_req_ptlrpc_body(req, MSG_PTLRPC_BODY_OFF);\r\nif (rc) {\r\nCERROR("error unpacking ptlrpc body: ptl %d from %s x%llu\n",\r\nsvc->srv_req_portal, libcfs_id2str(req->rq_peer),\r\nreq->rq_xid);\r\ngoto err_req;\r\n}\r\nif (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_DROP_REQ_OPC) &&\r\nlustre_msg_get_opc(req->rq_reqmsg) == cfs_fail_val) {\r\nCERROR("drop incoming rpc opc %u, x%llu\n",\r\ncfs_fail_val, req->rq_xid);\r\ngoto err_req;\r\n}\r\nrc = -EINVAL;\r\nif (lustre_msg_get_type(req->rq_reqmsg) != PTL_RPC_MSG_REQUEST) {\r\nCERROR("wrong packet type received (type=%u) from %s\n",\r\nlustre_msg_get_type(req->rq_reqmsg),\r\nlibcfs_id2str(req->rq_peer));\r\ngoto err_req;\r\n}\r\nswitch (lustre_msg_get_opc(req->rq_reqmsg)) {\r\ncase MDS_WRITEPAGE:\r\ncase OST_WRITE:\r\nreq->rq_bulk_write = 1;\r\nbreak;\r\ncase MDS_READPAGE:\r\ncase OST_READ:\r\ncase MGS_CONFIG_READ:\r\nreq->rq_bulk_read = 1;\r\nbreak;\r\n}\r\nCDEBUG(D_RPCTRACE, "got req x%llu\n", req->rq_xid);\r\nreq->rq_export = class_conn2export(\r\nlustre_msg_get_handle(req->rq_reqmsg));\r\nif (req->rq_export) {\r\nrc = ptlrpc_check_req(req);\r\nif (rc == 0) {\r\nrc = sptlrpc_target_export_check(req->rq_export, req);\r\nif (rc)\r\nDEBUG_REQ(D_ERROR, req, "DROPPING req with illegal security flavor,");\r\n}\r\nif (rc)\r\ngoto err_req;\r\n}\r\nif (ktime_get_real_seconds() - req->rq_arrival_time.tv_sec > 5)\r\nDEBUG_REQ(D_WARNING, req, "Slow req_in handling "CFS_DURATION_T"s",\r\n(long)(ktime_get_real_seconds() -\r\nreq->rq_arrival_time.tv_sec));\r\ndeadline = (lustre_msghdr_get_flags(req->rq_reqmsg) &\r\nMSGHDR_AT_SUPPORT) ?\r\nlustre_msg_get_timeout(req->rq_reqmsg) : obd_timeout;\r\nreq->rq_deadline = req->rq_arrival_time.tv_sec + deadline;\r\nif (unlikely(deadline == 0)) {\r\nDEBUG_REQ(D_ERROR, req, "Dropping request with 0 timeout");\r\ngoto err_req;\r\n}\r\nreq->rq_svc_thread = thread;\r\nif (thread) {\r\nrc = lu_context_init(&req->rq_session,\r\nLCT_SERVER_SESSION | LCT_NOREF);\r\nif (rc) {\r\nCERROR("%s: failure to initialize session: rc = %d\n",\r\nthread->t_name, rc);\r\ngoto err_req;\r\n}\r\nreq->rq_session.lc_thread = thread;\r\nlu_context_enter(&req->rq_session);\r\nreq->rq_svc_thread->t_env->le_ses = &req->rq_session;\r\n}\r\nptlrpc_at_add_timed(req);\r\nrc = ptlrpc_server_request_add(svcpt, req);\r\nif (rc)\r\ngoto err_req;\r\nwake_up(&svcpt->scp_waitq);\r\nreturn 1;\r\nerr_req:\r\nptlrpc_server_finish_request(svcpt, req);\r\nreturn 1;\r\n}\r\nstatic int\r\nptlrpc_server_handle_request(struct ptlrpc_service_part *svcpt,\r\nstruct ptlrpc_thread *thread)\r\n{\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nstruct ptlrpc_request *request;\r\nstruct timespec64 work_start;\r\nstruct timespec64 work_end;\r\nstruct timespec64 timediff;\r\nstruct timespec64 arrived;\r\nunsigned long timediff_usecs;\r\nunsigned long arrived_usecs;\r\nint fail_opc = 0;\r\nrequest = ptlrpc_server_request_get(svcpt, false);\r\nif (!request)\r\nreturn 0;\r\nif (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_HPREQ_NOTIMEOUT))\r\nfail_opc = OBD_FAIL_PTLRPC_HPREQ_NOTIMEOUT;\r\nelse if (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_HPREQ_TIMEOUT))\r\nfail_opc = OBD_FAIL_PTLRPC_HPREQ_TIMEOUT;\r\nif (unlikely(fail_opc)) {\r\nif (request->rq_export && request->rq_ops)\r\nOBD_FAIL_TIMEOUT(fail_opc, 4);\r\n}\r\nptlrpc_rqphase_move(request, RQ_PHASE_INTERPRET);\r\nif (OBD_FAIL_CHECK(OBD_FAIL_PTLRPC_DUMP_LOG))\r\nlibcfs_debug_dumplog();\r\nktime_get_real_ts64(&work_start);\r\ntimediff = timespec64_sub(work_start, request->rq_arrival_time);\r\ntimediff_usecs = timediff.tv_sec * USEC_PER_SEC +\r\ntimediff.tv_nsec / NSEC_PER_USEC;\r\nif (likely(svc->srv_stats)) {\r\nlprocfs_counter_add(svc->srv_stats, PTLRPC_REQWAIT_CNTR,\r\ntimediff_usecs);\r\nlprocfs_counter_add(svc->srv_stats, PTLRPC_REQQDEPTH_CNTR,\r\nsvcpt->scp_nreqs_incoming);\r\nlprocfs_counter_add(svc->srv_stats, PTLRPC_REQACTIVE_CNTR,\r\nsvcpt->scp_nreqs_active);\r\nlprocfs_counter_add(svc->srv_stats, PTLRPC_TIMEOUT,\r\nat_get(&svcpt->scp_at_estimate));\r\n}\r\nif (likely(request->rq_export)) {\r\nif (unlikely(ptlrpc_check_req(request)))\r\ngoto put_conn;\r\n}\r\nif (ktime_get_real_seconds() > request->rq_deadline) {\r\nDEBUG_REQ(D_ERROR, request, "Dropping timed-out request from %s: deadline " CFS_DURATION_T ":" CFS_DURATION_T "s ago\n",\r\nlibcfs_id2str(request->rq_peer),\r\n(long)(request->rq_deadline -\r\nrequest->rq_arrival_time.tv_sec),\r\n(long)(ktime_get_real_seconds() -\r\nrequest->rq_deadline));\r\ngoto put_conn;\r\n}\r\nCDEBUG(D_RPCTRACE, "Handling RPC pname:cluuid+ref:pid:xid:nid:opc %s:%s+%d:%d:x%llu:%s:%d\n",\r\ncurrent_comm(),\r\n(request->rq_export ?\r\n(char *)request->rq_export->exp_client_uuid.uuid : "0"),\r\n(request->rq_export ?\r\natomic_read(&request->rq_export->exp_refcount) : -99),\r\nlustre_msg_get_status(request->rq_reqmsg), request->rq_xid,\r\nlibcfs_id2str(request->rq_peer),\r\nlustre_msg_get_opc(request->rq_reqmsg));\r\nif (lustre_msg_get_opc(request->rq_reqmsg) != OBD_PING)\r\nCFS_FAIL_TIMEOUT_MS(OBD_FAIL_PTLRPC_PAUSE_REQ, cfs_fail_val);\r\nCDEBUG(D_NET, "got req %llu\n", request->rq_xid);\r\nrequest->rq_svc_thread = thread;\r\nif (thread) {\r\nLASSERT(request->rq_session.lc_thread);\r\nrequest->rq_session.lc_thread = thread;\r\nrequest->rq_session.lc_cookie = 0x55;\r\nthread->t_env->le_ses = &request->rq_session;\r\n}\r\nsvc->srv_ops.so_req_handler(request);\r\nptlrpc_rqphase_move(request, RQ_PHASE_COMPLETE);\r\nput_conn:\r\nif (unlikely(ktime_get_real_seconds() > request->rq_deadline)) {\r\nDEBUG_REQ(D_WARNING, request,\r\n"Request took longer than estimated (%lld:%llds); "\r\n"client may timeout.",\r\n(s64)request->rq_deadline -\r\nrequest->rq_arrival_time.tv_sec,\r\n(s64)ktime_get_real_seconds() - request->rq_deadline);\r\n}\r\nktime_get_real_ts64(&work_end);\r\ntimediff = timespec64_sub(work_end, work_start);\r\ntimediff_usecs = timediff.tv_sec * USEC_PER_SEC +\r\ntimediff.tv_nsec / NSEC_PER_USEC;\r\narrived = timespec64_sub(work_end, request->rq_arrival_time);\r\narrived_usecs = arrived.tv_sec * USEC_PER_SEC +\r\narrived.tv_nsec / NSEC_PER_USEC;\r\nCDEBUG(D_RPCTRACE, "Handled RPC pname:cluuid+ref:pid:xid:nid:opc %s:%s+%d:%d:x%llu:%s:%d Request processed in %ldus (%ldus total) trans %llu rc %d/%d\n",\r\ncurrent_comm(),\r\n(request->rq_export ?\r\n(char *)request->rq_export->exp_client_uuid.uuid : "0"),\r\n(request->rq_export ?\r\natomic_read(&request->rq_export->exp_refcount) : -99),\r\nlustre_msg_get_status(request->rq_reqmsg),\r\nrequest->rq_xid,\r\nlibcfs_id2str(request->rq_peer),\r\nlustre_msg_get_opc(request->rq_reqmsg),\r\ntimediff_usecs,\r\narrived_usecs,\r\n(request->rq_repmsg ?\r\nlustre_msg_get_transno(request->rq_repmsg) :\r\nrequest->rq_transno),\r\nrequest->rq_status,\r\n(request->rq_repmsg ?\r\nlustre_msg_get_status(request->rq_repmsg) : -999));\r\nif (likely(svc->srv_stats && request->rq_reqmsg)) {\r\n__u32 op = lustre_msg_get_opc(request->rq_reqmsg);\r\nint opc = opcode_offset(op);\r\nif (opc > 0 && !(op == LDLM_ENQUEUE || op == MDS_REINT)) {\r\nLASSERT(opc < LUSTRE_MAX_OPCODES);\r\nlprocfs_counter_add(svc->srv_stats,\r\nopc + EXTRA_MAX_OPCODES,\r\ntimediff_usecs);\r\n}\r\n}\r\nif (unlikely(request->rq_early_count)) {\r\nDEBUG_REQ(D_ADAPTTO, request,\r\n"sent %d early replies before finishing in %llds",\r\nrequest->rq_early_count,\r\n(s64)work_end.tv_sec -\r\nrequest->rq_arrival_time.tv_sec);\r\n}\r\nptlrpc_server_finish_active_request(svcpt, request);\r\nreturn 1;\r\n}\r\nstatic int\r\nptlrpc_handle_rs(struct ptlrpc_reply_state *rs)\r\n{\r\nstruct ptlrpc_service_part *svcpt = rs->rs_svcpt;\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nstruct obd_export *exp;\r\nint nlocks;\r\nint been_handled;\r\nexp = rs->rs_export;\r\nLASSERT(rs->rs_difficult);\r\nLASSERT(rs->rs_scheduled);\r\nLASSERT(list_empty(&rs->rs_list));\r\nspin_lock(&exp->exp_lock);\r\nlist_del_init(&rs->rs_exp_list);\r\nspin_unlock(&exp->exp_lock);\r\nif (!rs->rs_committed) {\r\nspin_lock(&exp->exp_uncommitted_replies_lock);\r\nlist_del_init(&rs->rs_obd_list);\r\nspin_unlock(&exp->exp_uncommitted_replies_lock);\r\n}\r\nspin_lock(&rs->rs_lock);\r\nbeen_handled = rs->rs_handled;\r\nrs->rs_handled = 1;\r\nnlocks = rs->rs_nlocks;\r\nrs->rs_nlocks = 0;\r\nif (nlocks == 0 && !been_handled) {\r\nCDEBUG(D_HA, "All locks stolen from rs %p x%lld.t%lld o%d NID %s\n",\r\nrs,\r\nrs->rs_xid, rs->rs_transno, rs->rs_opc,\r\nlibcfs_nid2str(exp->exp_connection->c_peer.nid));\r\n}\r\nif ((!been_handled && rs->rs_on_net) || nlocks > 0) {\r\nspin_unlock(&rs->rs_lock);\r\nif (!been_handled && rs->rs_on_net) {\r\nLNetMDUnlink(rs->rs_md_h);\r\n}\r\nwhile (nlocks-- > 0)\r\nldlm_lock_decref(&rs->rs_locks[nlocks],\r\nrs->rs_modes[nlocks]);\r\nspin_lock(&rs->rs_lock);\r\n}\r\nrs->rs_scheduled = 0;\r\nif (!rs->rs_on_net) {\r\nspin_unlock(&rs->rs_lock);\r\nclass_export_put(exp);\r\nrs->rs_export = NULL;\r\nptlrpc_rs_decref(rs);\r\nif (atomic_dec_and_test(&svcpt->scp_nreps_difficult) &&\r\nsvc->srv_is_stopping)\r\nwake_up_all(&svcpt->scp_waitq);\r\nreturn 1;\r\n}\r\nspin_unlock(&rs->rs_lock);\r\nreturn 1;\r\n}\r\nstatic void\r\nptlrpc_check_rqbd_pool(struct ptlrpc_service_part *svcpt)\r\n{\r\nint avail = svcpt->scp_nrqbds_posted;\r\nint low_water = test_req_buffer_pressure ? 0 :\r\nsvcpt->scp_service->srv_nbuf_per_group / 2;\r\nif (avail <= low_water)\r\nptlrpc_grow_req_bufs(svcpt, 1);\r\nif (svcpt->scp_service->srv_stats) {\r\nlprocfs_counter_add(svcpt->scp_service->srv_stats,\r\nPTLRPC_REQBUF_AVAIL_CNTR, avail);\r\n}\r\n}\r\nstatic int\r\nptlrpc_retry_rqbds(void *arg)\r\n{\r\nstruct ptlrpc_service_part *svcpt = arg;\r\nsvcpt->scp_rqbd_timeout = 0;\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic inline int\r\nptlrpc_threads_enough(struct ptlrpc_service_part *svcpt)\r\n{\r\nreturn svcpt->scp_nreqs_active <\r\nsvcpt->scp_nthrs_running - 1 -\r\n(svcpt->scp_service->srv_ops.so_hpreq_handler != NULL);\r\n}\r\nstatic inline int\r\nptlrpc_threads_increasable(struct ptlrpc_service_part *svcpt)\r\n{\r\nreturn svcpt->scp_nthrs_running +\r\nsvcpt->scp_nthrs_starting <\r\nsvcpt->scp_service->srv_nthrs_cpt_limit;\r\n}\r\nstatic inline int\r\nptlrpc_threads_need_create(struct ptlrpc_service_part *svcpt)\r\n{\r\nreturn !ptlrpc_threads_enough(svcpt) &&\r\nptlrpc_threads_increasable(svcpt);\r\n}\r\nstatic inline int\r\nptlrpc_thread_stopping(struct ptlrpc_thread *thread)\r\n{\r\nreturn thread_is_stopping(thread) ||\r\nthread->t_svcpt->scp_service->srv_is_stopping;\r\n}\r\nstatic inline int\r\nptlrpc_rqbd_pending(struct ptlrpc_service_part *svcpt)\r\n{\r\nreturn !list_empty(&svcpt->scp_rqbd_idle) &&\r\nsvcpt->scp_rqbd_timeout == 0;\r\n}\r\nstatic inline int\r\nptlrpc_at_check(struct ptlrpc_service_part *svcpt)\r\n{\r\nreturn svcpt->scp_at_check;\r\n}\r\nstatic inline int\r\nptlrpc_server_request_incoming(struct ptlrpc_service_part *svcpt)\r\n{\r\nreturn !list_empty(&svcpt->scp_req_incoming);\r\n}\r\nint ptlrpc_main(void *arg)\r\n{\r\nstruct ptlrpc_thread *thread = arg;\r\nstruct ptlrpc_service_part *svcpt = thread->t_svcpt;\r\nstruct ptlrpc_service *svc = svcpt->scp_service;\r\nstruct ptlrpc_reply_state *rs;\r\nstruct group_info *ginfo = NULL;\r\nstruct lu_env *env;\r\nint counter = 0, rc = 0;\r\nthread->t_pid = current_pid();\r\nunshare_fs_struct();\r\nrc = cfs_cpt_bind(svc->srv_cptable, svcpt->scp_cpt);\r\nif (rc != 0) {\r\nCWARN("%s: failed to bind %s on CPT %d\n",\r\nsvc->srv_name, thread->t_name, svcpt->scp_cpt);\r\n}\r\nginfo = groups_alloc(0);\r\nif (!ginfo) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nset_current_groups(ginfo);\r\nput_group_info(ginfo);\r\nif (svc->srv_ops.so_thr_init) {\r\nrc = svc->srv_ops.so_thr_init(thread);\r\nif (rc)\r\ngoto out;\r\n}\r\nenv = kzalloc(sizeof(*env), GFP_NOFS);\r\nif (!env) {\r\nrc = -ENOMEM;\r\ngoto out_srv_fini;\r\n}\r\nrc = lu_context_init(&env->le_ctx,\r\nsvc->srv_ctx_tags | LCT_REMEMBER | LCT_NOREF);\r\nif (rc)\r\ngoto out_srv_fini;\r\nthread->t_env = env;\r\nenv->le_ctx.lc_thread = thread;\r\nenv->le_ctx.lc_cookie = 0x6;\r\nwhile (!list_empty(&svcpt->scp_rqbd_idle)) {\r\nrc = ptlrpc_server_post_idle_rqbds(svcpt);\r\nif (rc >= 0)\r\ncontinue;\r\nCERROR("Failed to post rqbd for %s on CPT %d: %d\n",\r\nsvc->srv_name, svcpt->scp_cpt, rc);\r\ngoto out_srv_fini;\r\n}\r\nrs = libcfs_kvzalloc(svc->srv_max_reply_size, GFP_NOFS);\r\nif (!rs) {\r\nrc = -ENOMEM;\r\ngoto out_srv_fini;\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\nLASSERT(thread_is_starting(thread));\r\nthread_clear_flags(thread, SVC_STARTING);\r\nLASSERT(svcpt->scp_nthrs_starting == 1);\r\nsvcpt->scp_nthrs_starting--;\r\nthread_add_flags(thread, SVC_RUNNING);\r\nsvcpt->scp_nthrs_running++;\r\nspin_unlock(&svcpt->scp_lock);\r\nwake_up(&thread->t_ctl_waitq);\r\nspin_lock(&svcpt->scp_rep_lock);\r\nlist_add(&rs->rs_list, &svcpt->scp_rep_idle);\r\nwake_up(&svcpt->scp_rep_waitq);\r\nspin_unlock(&svcpt->scp_rep_lock);\r\nCDEBUG(D_NET, "service thread %d (#%d) started\n", thread->t_id,\r\nsvcpt->scp_nthrs_running);\r\nwhile (!ptlrpc_thread_stopping(thread)) {\r\nif (ptlrpc_wait_event(svcpt, thread))\r\nbreak;\r\nptlrpc_check_rqbd_pool(svcpt);\r\nif (ptlrpc_threads_need_create(svcpt)) {\r\nptlrpc_start_thread(svcpt, 0);\r\n}\r\nif (ptlrpc_server_request_incoming(svcpt)) {\r\nlu_context_enter(&env->le_ctx);\r\nenv->le_ses = NULL;\r\nptlrpc_server_handle_req_in(svcpt, thread);\r\nlu_context_exit(&env->le_ctx);\r\nif (counter++ < 100)\r\ncontinue;\r\ncounter = 0;\r\n}\r\nif (ptlrpc_at_check(svcpt))\r\nptlrpc_at_check_timed(svcpt);\r\nif (ptlrpc_server_request_pending(svcpt, false)) {\r\nlu_context_enter(&env->le_ctx);\r\nptlrpc_server_handle_request(svcpt, thread);\r\nlu_context_exit(&env->le_ctx);\r\n}\r\nif (ptlrpc_rqbd_pending(svcpt) &&\r\nptlrpc_server_post_idle_rqbds(svcpt) < 0) {\r\nsvcpt->scp_rqbd_timeout = cfs_time_seconds(1) / 10;\r\nCDEBUG(D_RPCTRACE, "Posted buffers: %d\n",\r\nsvcpt->scp_nrqbds_posted);\r\n}\r\n}\r\nout_srv_fini:\r\nif (svc->srv_ops.so_thr_done)\r\nsvc->srv_ops.so_thr_done(thread);\r\nif (env) {\r\nlu_context_fini(&env->le_ctx);\r\nkfree(env);\r\n}\r\nout:\r\nCDEBUG(D_RPCTRACE, "service thread [ %p : %u ] %d exiting: rc %d\n",\r\nthread, thread->t_pid, thread->t_id, rc);\r\nspin_lock(&svcpt->scp_lock);\r\nif (thread_test_and_clear_flags(thread, SVC_STARTING))\r\nsvcpt->scp_nthrs_starting--;\r\nif (thread_test_and_clear_flags(thread, SVC_RUNNING)) {\r\nsvcpt->scp_nthrs_running--;\r\n}\r\nthread->t_id = rc;\r\nthread_add_flags(thread, SVC_STOPPED);\r\nwake_up(&thread->t_ctl_waitq);\r\nspin_unlock(&svcpt->scp_lock);\r\nreturn rc;\r\n}\r\nstatic int hrt_dont_sleep(struct ptlrpc_hr_thread *hrt,\r\nstruct list_head *replies)\r\n{\r\nint result;\r\nspin_lock(&hrt->hrt_lock);\r\nlist_splice_init(&hrt->hrt_queue, replies);\r\nresult = ptlrpc_hr.hr_stopping || !list_empty(replies);\r\nspin_unlock(&hrt->hrt_lock);\r\nreturn result;\r\n}\r\nstatic int ptlrpc_hr_main(void *arg)\r\n{\r\nstruct ptlrpc_hr_thread *hrt = arg;\r\nstruct ptlrpc_hr_partition *hrp = hrt->hrt_partition;\r\nLIST_HEAD(replies);\r\nchar threadname[20];\r\nint rc;\r\nsnprintf(threadname, sizeof(threadname), "ptlrpc_hr%02d_%03d",\r\nhrp->hrp_cpt, hrt->hrt_id);\r\nunshare_fs_struct();\r\nrc = cfs_cpt_bind(ptlrpc_hr.hr_cpt_table, hrp->hrp_cpt);\r\nif (rc != 0) {\r\nCWARN("Failed to bind %s on CPT %d of CPT table %p: rc = %d\n",\r\nthreadname, hrp->hrp_cpt, ptlrpc_hr.hr_cpt_table, rc);\r\n}\r\natomic_inc(&hrp->hrp_nstarted);\r\nwake_up(&ptlrpc_hr.hr_waitq);\r\nwhile (!ptlrpc_hr.hr_stopping) {\r\nl_wait_condition(hrt->hrt_waitq, hrt_dont_sleep(hrt, &replies));\r\nwhile (!list_empty(&replies)) {\r\nstruct ptlrpc_reply_state *rs;\r\nrs = list_entry(replies.prev, struct ptlrpc_reply_state,\r\nrs_list);\r\nlist_del_init(&rs->rs_list);\r\nptlrpc_handle_rs(rs);\r\n}\r\n}\r\natomic_inc(&hrp->hrp_nstopped);\r\nwake_up(&ptlrpc_hr.hr_waitq);\r\nreturn 0;\r\n}\r\nstatic void ptlrpc_stop_hr_threads(void)\r\n{\r\nstruct ptlrpc_hr_partition *hrp;\r\nint i;\r\nint j;\r\nptlrpc_hr.hr_stopping = 1;\r\ncfs_percpt_for_each(hrp, i, ptlrpc_hr.hr_partitions) {\r\nif (!hrp->hrp_thrs)\r\ncontinue;\r\nfor (j = 0; j < hrp->hrp_nthrs; j++)\r\nwake_up_all(&hrp->hrp_thrs[j].hrt_waitq);\r\n}\r\ncfs_percpt_for_each(hrp, i, ptlrpc_hr.hr_partitions) {\r\nif (!hrp->hrp_thrs)\r\ncontinue;\r\nwait_event(ptlrpc_hr.hr_waitq,\r\natomic_read(&hrp->hrp_nstopped) ==\r\natomic_read(&hrp->hrp_nstarted));\r\n}\r\n}\r\nstatic int ptlrpc_start_hr_threads(void)\r\n{\r\nstruct ptlrpc_hr_partition *hrp;\r\nint i;\r\nint j;\r\ncfs_percpt_for_each(hrp, i, ptlrpc_hr.hr_partitions) {\r\nint rc = 0;\r\nfor (j = 0; j < hrp->hrp_nthrs; j++) {\r\nstruct ptlrpc_hr_thread *hrt = &hrp->hrp_thrs[j];\r\nstruct task_struct *task;\r\ntask = kthread_run(ptlrpc_hr_main,\r\n&hrp->hrp_thrs[j],\r\n"ptlrpc_hr%02d_%03d",\r\nhrp->hrp_cpt, hrt->hrt_id);\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nbreak;\r\n}\r\n}\r\nwait_event(ptlrpc_hr.hr_waitq,\r\natomic_read(&hrp->hrp_nstarted) == j);\r\nif (rc < 0) {\r\nCERROR("cannot start reply handler thread %d:%d: rc = %d\n",\r\ni, j, rc);\r\nptlrpc_stop_hr_threads();\r\nreturn rc;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void ptlrpc_svcpt_stop_threads(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ptlrpc_thread *thread;\r\nLIST_HEAD(zombie);\r\nCDEBUG(D_INFO, "Stopping threads for service %s\n",\r\nsvcpt->scp_service->srv_name);\r\nspin_lock(&svcpt->scp_lock);\r\nlist_for_each_entry(thread, &svcpt->scp_threads, t_link) {\r\nCDEBUG(D_INFO, "Stopping thread %s #%u\n",\r\nsvcpt->scp_service->srv_thread_name, thread->t_id);\r\nthread_add_flags(thread, SVC_STOPPING);\r\n}\r\nwake_up_all(&svcpt->scp_waitq);\r\nwhile (!list_empty(&svcpt->scp_threads)) {\r\nthread = list_entry(svcpt->scp_threads.next,\r\nstruct ptlrpc_thread, t_link);\r\nif (thread_is_stopped(thread)) {\r\nlist_del(&thread->t_link);\r\nlist_add(&thread->t_link, &zombie);\r\ncontinue;\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\nCDEBUG(D_INFO, "waiting for stopping-thread %s #%u\n",\r\nsvcpt->scp_service->srv_thread_name, thread->t_id);\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_stopped(thread), &lwi);\r\nspin_lock(&svcpt->scp_lock);\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\nwhile (!list_empty(&zombie)) {\r\nthread = list_entry(zombie.next,\r\nstruct ptlrpc_thread, t_link);\r\nlist_del(&thread->t_link);\r\nkfree(thread);\r\n}\r\n}\r\nstatic void ptlrpc_stop_all_threads(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (svcpt->scp_service)\r\nptlrpc_svcpt_stop_threads(svcpt);\r\n}\r\n}\r\nint ptlrpc_start_threads(struct ptlrpc_service *svc)\r\n{\r\nint rc = 0;\r\nint i;\r\nint j;\r\nLASSERT(svc->srv_nthrs_cpt_init >= PTLRPC_NTHRS_INIT);\r\nfor (i = 0; i < svc->srv_ncpts; i++) {\r\nfor (j = 0; j < svc->srv_nthrs_cpt_init; j++) {\r\nrc = ptlrpc_start_thread(svc->srv_parts[i], 1);\r\nif (rc == 0)\r\ncontinue;\r\nif (rc != -EMFILE)\r\ngoto failed;\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\nfailed:\r\nCERROR("cannot start %s thread #%d_%d: rc %d\n",\r\nsvc->srv_thread_name, i, j, rc);\r\nptlrpc_stop_all_threads(svc);\r\nreturn rc;\r\n}\r\nint ptlrpc_start_thread(struct ptlrpc_service_part *svcpt, int wait)\r\n{\r\nstruct l_wait_info lwi = { 0 };\r\nstruct ptlrpc_thread *thread;\r\nstruct ptlrpc_service *svc;\r\nstruct task_struct *task;\r\nint rc;\r\nsvc = svcpt->scp_service;\r\nCDEBUG(D_RPCTRACE, "%s[%d] started %d min %d max %d\n",\r\nsvc->srv_name, svcpt->scp_cpt, svcpt->scp_nthrs_running,\r\nsvc->srv_nthrs_cpt_init, svc->srv_nthrs_cpt_limit);\r\nagain:\r\nif (unlikely(svc->srv_is_stopping))\r\nreturn -ESRCH;\r\nif (!ptlrpc_threads_increasable(svcpt) ||\r\n(OBD_FAIL_CHECK(OBD_FAIL_TGT_TOOMANY_THREADS) &&\r\nsvcpt->scp_nthrs_running == svc->srv_nthrs_cpt_init - 1))\r\nreturn -EMFILE;\r\nthread = kzalloc_node(sizeof(*thread), GFP_NOFS,\r\ncfs_cpt_spread_node(svc->srv_cptable,\r\nsvcpt->scp_cpt));\r\nif (!thread)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&thread->t_ctl_waitq);\r\nspin_lock(&svcpt->scp_lock);\r\nif (!ptlrpc_threads_increasable(svcpt)) {\r\nspin_unlock(&svcpt->scp_lock);\r\nkfree(thread);\r\nreturn -EMFILE;\r\n}\r\nif (svcpt->scp_nthrs_starting != 0) {\r\nLASSERT(svcpt->scp_nthrs_starting == 1);\r\nspin_unlock(&svcpt->scp_lock);\r\nkfree(thread);\r\nif (wait) {\r\nCDEBUG(D_INFO, "Waiting for creating thread %s #%d\n",\r\nsvc->srv_thread_name, svcpt->scp_thr_nextid);\r\nschedule();\r\ngoto again;\r\n}\r\nCDEBUG(D_INFO, "Creating thread %s #%d race, retry later\n",\r\nsvc->srv_thread_name, svcpt->scp_thr_nextid);\r\nreturn -EAGAIN;\r\n}\r\nsvcpt->scp_nthrs_starting++;\r\nthread->t_id = svcpt->scp_thr_nextid++;\r\nthread_add_flags(thread, SVC_STARTING);\r\nthread->t_svcpt = svcpt;\r\nlist_add(&thread->t_link, &svcpt->scp_threads);\r\nspin_unlock(&svcpt->scp_lock);\r\nif (svcpt->scp_cpt >= 0) {\r\nsnprintf(thread->t_name, sizeof(thread->t_name), "%s%02d_%03d",\r\nsvc->srv_thread_name, svcpt->scp_cpt, thread->t_id);\r\n} else {\r\nsnprintf(thread->t_name, sizeof(thread->t_name), "%s_%04d",\r\nsvc->srv_thread_name, thread->t_id);\r\n}\r\nCDEBUG(D_RPCTRACE, "starting thread '%s'\n", thread->t_name);\r\ntask = kthread_run(ptlrpc_main, thread, "%s", thread->t_name);\r\nif (IS_ERR(task)) {\r\nrc = PTR_ERR(task);\r\nCERROR("cannot start thread '%s': rc = %d\n",\r\nthread->t_name, rc);\r\nspin_lock(&svcpt->scp_lock);\r\n--svcpt->scp_nthrs_starting;\r\nif (thread_is_stopping(thread)) {\r\nthread_add_flags(thread, SVC_STOPPED);\r\nwake_up(&thread->t_ctl_waitq);\r\nspin_unlock(&svcpt->scp_lock);\r\n} else {\r\nlist_del(&thread->t_link);\r\nspin_unlock(&svcpt->scp_lock);\r\nkfree(thread);\r\n}\r\nreturn rc;\r\n}\r\nif (!wait)\r\nreturn 0;\r\nl_wait_event(thread->t_ctl_waitq,\r\nthread_is_running(thread) || thread_is_stopped(thread),\r\n&lwi);\r\nrc = thread_is_stopped(thread) ? thread->t_id : 0;\r\nreturn rc;\r\n}\r\nint ptlrpc_hr_init(void)\r\n{\r\nstruct ptlrpc_hr_partition *hrp;\r\nstruct ptlrpc_hr_thread *hrt;\r\nint rc;\r\nint i;\r\nint j;\r\nint weight;\r\nmemset(&ptlrpc_hr, 0, sizeof(ptlrpc_hr));\r\nptlrpc_hr.hr_cpt_table = cfs_cpt_table;\r\nptlrpc_hr.hr_partitions = cfs_percpt_alloc(ptlrpc_hr.hr_cpt_table,\r\nsizeof(*hrp));\r\nif (!ptlrpc_hr.hr_partitions)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&ptlrpc_hr.hr_waitq);\r\nweight = cpumask_weight(topology_sibling_cpumask(0));\r\ncfs_percpt_for_each(hrp, i, ptlrpc_hr.hr_partitions) {\r\nhrp->hrp_cpt = i;\r\natomic_set(&hrp->hrp_nstarted, 0);\r\natomic_set(&hrp->hrp_nstopped, 0);\r\nhrp->hrp_nthrs = cfs_cpt_weight(ptlrpc_hr.hr_cpt_table, i);\r\nhrp->hrp_nthrs /= weight;\r\nif (hrp->hrp_nthrs == 0)\r\nhrp->hrp_nthrs = 1;\r\nhrp->hrp_thrs =\r\nkzalloc_node(hrp->hrp_nthrs * sizeof(*hrt), GFP_NOFS,\r\ncfs_cpt_spread_node(ptlrpc_hr.hr_cpt_table,\r\ni));\r\nif (!hrp->hrp_thrs) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (j = 0; j < hrp->hrp_nthrs; j++) {\r\nhrt = &hrp->hrp_thrs[j];\r\nhrt->hrt_id = j;\r\nhrt->hrt_partition = hrp;\r\ninit_waitqueue_head(&hrt->hrt_waitq);\r\nspin_lock_init(&hrt->hrt_lock);\r\nINIT_LIST_HEAD(&hrt->hrt_queue);\r\n}\r\n}\r\nrc = ptlrpc_start_hr_threads();\r\nout:\r\nif (rc != 0)\r\nptlrpc_hr_fini();\r\nreturn rc;\r\n}\r\nvoid ptlrpc_hr_fini(void)\r\n{\r\nstruct ptlrpc_hr_partition *hrp;\r\nint i;\r\nif (!ptlrpc_hr.hr_partitions)\r\nreturn;\r\nptlrpc_stop_hr_threads();\r\ncfs_percpt_for_each(hrp, i, ptlrpc_hr.hr_partitions) {\r\nkfree(hrp->hrp_thrs);\r\n}\r\ncfs_percpt_free(ptlrpc_hr.hr_partitions);\r\nptlrpc_hr.hr_partitions = NULL;\r\n}\r\nstatic void ptlrpc_wait_replies(struct ptlrpc_service_part *svcpt)\r\n{\r\nwhile (1) {\r\nint rc;\r\nstruct l_wait_info lwi = LWI_TIMEOUT(cfs_time_seconds(10),\r\nNULL, NULL);\r\nrc = l_wait_event(svcpt->scp_waitq,\r\natomic_read(&svcpt->scp_nreps_difficult) == 0,\r\n&lwi);\r\nif (rc == 0)\r\nbreak;\r\nCWARN("Unexpectedly long timeout %s %p\n",\r\nsvcpt->scp_service->srv_name, svcpt->scp_service);\r\n}\r\n}\r\nstatic void\r\nptlrpc_service_del_atimer(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (svcpt->scp_service)\r\ndel_timer(&svcpt->scp_at_timer);\r\n}\r\n}\r\nstatic void\r\nptlrpc_service_unlink_rqbd(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_request_buffer_desc *rqbd;\r\nstruct l_wait_info lwi;\r\nint rc;\r\nint i;\r\nsvc->srv_hist_nrqbds_cpt_max = 0;\r\nrc = LNetClearLazyPortal(svc->srv_req_portal);\r\nLASSERT(rc == 0);\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (!svcpt->scp_service)\r\nbreak;\r\nlist_for_each_entry(rqbd, &svcpt->scp_rqbd_posted,\r\nrqbd_list) {\r\nrc = LNetMDUnlink(rqbd->rqbd_md_h);\r\nLASSERT(rc == 0 || rc == -ENOENT);\r\n}\r\n}\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (!svcpt->scp_service)\r\nbreak;\r\nspin_lock(&svcpt->scp_lock);\r\nwhile (svcpt->scp_nrqbds_posted != 0) {\r\nspin_unlock(&svcpt->scp_lock);\r\nlwi = LWI_TIMEOUT_INTERVAL(\r\ncfs_time_seconds(LONG_UNLINK),\r\ncfs_time_seconds(1), NULL, NULL);\r\nrc = l_wait_event(svcpt->scp_waitq,\r\nsvcpt->scp_nrqbds_posted == 0, &lwi);\r\nif (rc == -ETIMEDOUT) {\r\nCWARN("Service %s waiting for request buffers\n",\r\nsvcpt->scp_service->srv_name);\r\n}\r\nspin_lock(&svcpt->scp_lock);\r\n}\r\nspin_unlock(&svcpt->scp_lock);\r\n}\r\n}\r\nstatic void\r\nptlrpc_service_purge_all(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_request_buffer_desc *rqbd;\r\nstruct ptlrpc_request *req;\r\nstruct ptlrpc_reply_state *rs;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (!svcpt->scp_service)\r\nbreak;\r\nspin_lock(&svcpt->scp_rep_lock);\r\nwhile (!list_empty(&svcpt->scp_rep_active)) {\r\nrs = list_entry(svcpt->scp_rep_active.next,\r\nstruct ptlrpc_reply_state, rs_list);\r\nspin_lock(&rs->rs_lock);\r\nptlrpc_schedule_difficult_reply(rs);\r\nspin_unlock(&rs->rs_lock);\r\n}\r\nspin_unlock(&svcpt->scp_rep_lock);\r\nwhile (!list_empty(&svcpt->scp_req_incoming)) {\r\nreq = list_entry(svcpt->scp_req_incoming.next,\r\nstruct ptlrpc_request, rq_list);\r\nlist_del(&req->rq_list);\r\nsvcpt->scp_nreqs_incoming--;\r\nptlrpc_server_finish_request(svcpt, req);\r\n}\r\nwhile (ptlrpc_server_request_pending(svcpt, true)) {\r\nreq = ptlrpc_server_request_get(svcpt, true);\r\nptlrpc_server_finish_active_request(svcpt, req);\r\n}\r\nLASSERT(list_empty(&svcpt->scp_rqbd_posted));\r\nLASSERT(svcpt->scp_nreqs_incoming == 0);\r\nLASSERT(svcpt->scp_nreqs_active == 0);\r\nLASSERT(svcpt->scp_hist_nrqbds == 0);\r\nwhile (!list_empty(&svcpt->scp_rqbd_idle)) {\r\nrqbd = list_entry(svcpt->scp_rqbd_idle.next,\r\nstruct ptlrpc_request_buffer_desc,\r\nrqbd_list);\r\nptlrpc_free_rqbd(rqbd);\r\n}\r\nptlrpc_wait_replies(svcpt);\r\nwhile (!list_empty(&svcpt->scp_rep_idle)) {\r\nrs = list_entry(svcpt->scp_rep_idle.next,\r\nstruct ptlrpc_reply_state,\r\nrs_list);\r\nlist_del(&rs->rs_list);\r\nkvfree(rs);\r\n}\r\n}\r\n}\r\nstatic void\r\nptlrpc_service_free(struct ptlrpc_service *svc)\r\n{\r\nstruct ptlrpc_service_part *svcpt;\r\nstruct ptlrpc_at_array *array;\r\nint i;\r\nptlrpc_service_for_each_part(svcpt, i, svc) {\r\nif (!svcpt->scp_service)\r\nbreak;\r\ndel_timer(&svcpt->scp_at_timer);\r\narray = &svcpt->scp_at_array;\r\nkfree(array->paa_reqs_array);\r\narray->paa_reqs_array = NULL;\r\nkfree(array->paa_reqs_count);\r\narray->paa_reqs_count = NULL;\r\n}\r\nptlrpc_service_for_each_part(svcpt, i, svc)\r\nkfree(svcpt);\r\nif (svc->srv_cpts)\r\ncfs_expr_list_values_free(svc->srv_cpts, svc->srv_ncpts);\r\nkfree(svc);\r\n}\r\nint ptlrpc_unregister_service(struct ptlrpc_service *service)\r\n{\r\nCDEBUG(D_NET, "%s: tearing down\n", service->srv_name);\r\nservice->srv_is_stopping = 1;\r\nmutex_lock(&ptlrpc_all_services_mutex);\r\nlist_del_init(&service->srv_list);\r\nmutex_unlock(&ptlrpc_all_services_mutex);\r\nptlrpc_service_del_atimer(service);\r\nptlrpc_stop_all_threads(service);\r\nptlrpc_service_unlink_rqbd(service);\r\nptlrpc_service_purge_all(service);\r\nptlrpc_service_nrs_cleanup(service);\r\nptlrpc_lprocfs_unregister_service(service);\r\nptlrpc_sysfs_unregister_service(service);\r\nptlrpc_service_free(service);\r\nreturn 0;\r\n}
