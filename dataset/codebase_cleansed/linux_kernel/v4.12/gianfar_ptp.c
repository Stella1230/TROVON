static u64 tmr_cnt_read(struct etsects *etsects)\r\n{\r\nu64 ns;\r\nu32 lo, hi;\r\nlo = gfar_read(&etsects->regs->tmr_cnt_l);\r\nhi = gfar_read(&etsects->regs->tmr_cnt_h);\r\nns = ((u64) hi) << 32;\r\nns |= lo;\r\nreturn ns;\r\n}\r\nstatic void tmr_cnt_write(struct etsects *etsects, u64 ns)\r\n{\r\nu32 hi = ns >> 32;\r\nu32 lo = ns & 0xffffffff;\r\ngfar_write(&etsects->regs->tmr_cnt_l, lo);\r\ngfar_write(&etsects->regs->tmr_cnt_h, hi);\r\n}\r\nstatic void set_alarm(struct etsects *etsects)\r\n{\r\nu64 ns;\r\nu32 lo, hi;\r\nns = tmr_cnt_read(etsects) + 1500000000ULL;\r\nns = div_u64(ns, 1000000000UL) * 1000000000ULL;\r\nns -= etsects->tclk_period;\r\nhi = ns >> 32;\r\nlo = ns & 0xffffffff;\r\ngfar_write(&etsects->regs->tmr_alarm1_l, lo);\r\ngfar_write(&etsects->regs->tmr_alarm1_h, hi);\r\n}\r\nstatic void set_fipers(struct etsects *etsects)\r\n{\r\nset_alarm(etsects);\r\ngfar_write(&etsects->regs->tmr_fiper1, etsects->tmr_fiper1);\r\ngfar_write(&etsects->regs->tmr_fiper2, etsects->tmr_fiper2);\r\n}\r\nstatic irqreturn_t isr(int irq, void *priv)\r\n{\r\nstruct etsects *etsects = priv;\r\nstruct ptp_clock_event event;\r\nu64 ns;\r\nu32 ack = 0, lo, hi, mask, val;\r\nval = gfar_read(&etsects->regs->tmr_tevent);\r\nif (val & ETS1) {\r\nack |= ETS1;\r\nhi = gfar_read(&etsects->regs->tmr_etts1_h);\r\nlo = gfar_read(&etsects->regs->tmr_etts1_l);\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 0;\r\nevent.timestamp = ((u64) hi) << 32;\r\nevent.timestamp |= lo;\r\nptp_clock_event(etsects->clock, &event);\r\n}\r\nif (val & ETS2) {\r\nack |= ETS2;\r\nhi = gfar_read(&etsects->regs->tmr_etts2_h);\r\nlo = gfar_read(&etsects->regs->tmr_etts2_l);\r\nevent.type = PTP_CLOCK_EXTTS;\r\nevent.index = 1;\r\nevent.timestamp = ((u64) hi) << 32;\r\nevent.timestamp |= lo;\r\nptp_clock_event(etsects->clock, &event);\r\n}\r\nif (val & ALM2) {\r\nack |= ALM2;\r\nif (etsects->alarm_value) {\r\nevent.type = PTP_CLOCK_ALARM;\r\nevent.index = 0;\r\nevent.timestamp = etsects->alarm_value;\r\nptp_clock_event(etsects->clock, &event);\r\n}\r\nif (etsects->alarm_interval) {\r\nns = etsects->alarm_value + etsects->alarm_interval;\r\nhi = ns >> 32;\r\nlo = ns & 0xffffffff;\r\nspin_lock(&etsects->lock);\r\ngfar_write(&etsects->regs->tmr_alarm2_l, lo);\r\ngfar_write(&etsects->regs->tmr_alarm2_h, hi);\r\nspin_unlock(&etsects->lock);\r\netsects->alarm_value = ns;\r\n} else {\r\ngfar_write(&etsects->regs->tmr_tevent, ALM2);\r\nspin_lock(&etsects->lock);\r\nmask = gfar_read(&etsects->regs->tmr_temask);\r\nmask &= ~ALM2EN;\r\ngfar_write(&etsects->regs->tmr_temask, mask);\r\nspin_unlock(&etsects->lock);\r\netsects->alarm_value = 0;\r\netsects->alarm_interval = 0;\r\n}\r\n}\r\nif (val & PP1) {\r\nack |= PP1;\r\nevent.type = PTP_CLOCK_PPS;\r\nptp_clock_event(etsects->clock, &event);\r\n}\r\nif (ack) {\r\ngfar_write(&etsects->regs->tmr_tevent, ack);\r\nreturn IRQ_HANDLED;\r\n} else\r\nreturn IRQ_NONE;\r\n}\r\nstatic int ptp_gianfar_adjfine(struct ptp_clock_info *ptp, long scaled_ppm)\r\n{\r\nu64 adj, diff;\r\nu32 tmr_add;\r\nint neg_adj = 0;\r\nstruct etsects *etsects = container_of(ptp, struct etsects, caps);\r\nif (scaled_ppm < 0) {\r\nneg_adj = 1;\r\nscaled_ppm = -scaled_ppm;\r\n}\r\ntmr_add = etsects->tmr_add;\r\nadj = tmr_add;\r\nadj *= scaled_ppm;\r\ndiff = div_u64(adj, 8000000);\r\ndiff = (diff >> 13) + ((diff >> 12) & 1);\r\ntmr_add = neg_adj ? tmr_add - diff : tmr_add + diff;\r\ngfar_write(&etsects->regs->tmr_add, tmr_add);\r\nreturn 0;\r\n}\r\nstatic int ptp_gianfar_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\ns64 now;\r\nunsigned long flags;\r\nstruct etsects *etsects = container_of(ptp, struct etsects, caps);\r\nspin_lock_irqsave(&etsects->lock, flags);\r\nnow = tmr_cnt_read(etsects);\r\nnow += delta;\r\ntmr_cnt_write(etsects, now);\r\nspin_unlock_irqrestore(&etsects->lock, flags);\r\nset_fipers(etsects);\r\nreturn 0;\r\n}\r\nstatic int ptp_gianfar_gettime(struct ptp_clock_info *ptp,\r\nstruct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct etsects *etsects = container_of(ptp, struct etsects, caps);\r\nspin_lock_irqsave(&etsects->lock, flags);\r\nns = tmr_cnt_read(etsects);\r\nspin_unlock_irqrestore(&etsects->lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int ptp_gianfar_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct etsects *etsects = container_of(ptp, struct etsects, caps);\r\nns = timespec64_to_ns(ts);\r\nspin_lock_irqsave(&etsects->lock, flags);\r\ntmr_cnt_write(etsects, ns);\r\nset_fipers(etsects);\r\nspin_unlock_irqrestore(&etsects->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ptp_gianfar_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nstruct etsects *etsects = container_of(ptp, struct etsects, caps);\r\nunsigned long flags;\r\nu32 bit, mask;\r\nswitch (rq->type) {\r\ncase PTP_CLK_REQ_EXTTS:\r\nswitch (rq->extts.index) {\r\ncase 0:\r\nbit = ETS1EN;\r\nbreak;\r\ncase 1:\r\nbit = ETS2EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&etsects->lock, flags);\r\nmask = gfar_read(&etsects->regs->tmr_temask);\r\nif (on)\r\nmask |= bit;\r\nelse\r\nmask &= ~bit;\r\ngfar_write(&etsects->regs->tmr_temask, mask);\r\nspin_unlock_irqrestore(&etsects->lock, flags);\r\nreturn 0;\r\ncase PTP_CLK_REQ_PPS:\r\nspin_lock_irqsave(&etsects->lock, flags);\r\nmask = gfar_read(&etsects->regs->tmr_temask);\r\nif (on)\r\nmask |= PP1EN;\r\nelse\r\nmask &= ~PP1EN;\r\ngfar_write(&etsects->regs->tmr_temask, mask);\r\nspin_unlock_irqrestore(&etsects->lock, flags);\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int gianfar_ptp_probe(struct platform_device *dev)\r\n{\r\nstruct device_node *node = dev->dev.of_node;\r\nstruct etsects *etsects;\r\nstruct timespec64 now;\r\nint err = -ENOMEM;\r\nu32 tmr_ctrl;\r\nunsigned long flags;\r\netsects = kzalloc(sizeof(*etsects), GFP_KERNEL);\r\nif (!etsects)\r\ngoto no_memory;\r\nerr = -ENODEV;\r\netsects->caps = ptp_gianfar_caps;\r\nif (of_property_read_u32(node, "fsl,cksel", &etsects->cksel))\r\netsects->cksel = DEFAULT_CKSEL;\r\nif (of_property_read_u32(node,\r\n"fsl,tclk-period", &etsects->tclk_period) ||\r\nof_property_read_u32(node,\r\n"fsl,tmr-prsc", &etsects->tmr_prsc) ||\r\nof_property_read_u32(node,\r\n"fsl,tmr-add", &etsects->tmr_add) ||\r\nof_property_read_u32(node,\r\n"fsl,tmr-fiper1", &etsects->tmr_fiper1) ||\r\nof_property_read_u32(node,\r\n"fsl,tmr-fiper2", &etsects->tmr_fiper2) ||\r\nof_property_read_u32(node,\r\n"fsl,max-adj", &etsects->caps.max_adj)) {\r\npr_err("device tree node missing required elements\n");\r\ngoto no_node;\r\n}\r\netsects->irq = platform_get_irq(dev, 0);\r\nif (etsects->irq < 0) {\r\npr_err("irq not in device tree\n");\r\ngoto no_node;\r\n}\r\nif (request_irq(etsects->irq, isr, 0, DRIVER, etsects)) {\r\npr_err("request_irq failed\n");\r\ngoto no_node;\r\n}\r\netsects->rsrc = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!etsects->rsrc) {\r\npr_err("no resource\n");\r\ngoto no_resource;\r\n}\r\nif (request_resource(&iomem_resource, etsects->rsrc)) {\r\npr_err("resource busy\n");\r\ngoto no_resource;\r\n}\r\nspin_lock_init(&etsects->lock);\r\netsects->regs = ioremap(etsects->rsrc->start,\r\nresource_size(etsects->rsrc));\r\nif (!etsects->regs) {\r\npr_err("ioremap ptp registers failed\n");\r\ngoto no_ioremap;\r\n}\r\ngetnstimeofday64(&now);\r\nptp_gianfar_settime(&etsects->caps, &now);\r\ntmr_ctrl =\r\n(etsects->tclk_period & TCLK_PERIOD_MASK) << TCLK_PERIOD_SHIFT |\r\n(etsects->cksel & CKSEL_MASK) << CKSEL_SHIFT;\r\nspin_lock_irqsave(&etsects->lock, flags);\r\ngfar_write(&etsects->regs->tmr_ctrl, tmr_ctrl);\r\ngfar_write(&etsects->regs->tmr_add, etsects->tmr_add);\r\ngfar_write(&etsects->regs->tmr_prsc, etsects->tmr_prsc);\r\ngfar_write(&etsects->regs->tmr_fiper1, etsects->tmr_fiper1);\r\ngfar_write(&etsects->regs->tmr_fiper2, etsects->tmr_fiper2);\r\nset_alarm(etsects);\r\ngfar_write(&etsects->regs->tmr_ctrl, tmr_ctrl|FIPERST|RTPE|TE|FRD);\r\nspin_unlock_irqrestore(&etsects->lock, flags);\r\netsects->clock = ptp_clock_register(&etsects->caps, &dev->dev);\r\nif (IS_ERR(etsects->clock)) {\r\nerr = PTR_ERR(etsects->clock);\r\ngoto no_clock;\r\n}\r\ngfar_phc_index = ptp_clock_index(etsects->clock);\r\nplatform_set_drvdata(dev, etsects);\r\nreturn 0;\r\nno_clock:\r\niounmap(etsects->regs);\r\nno_ioremap:\r\nrelease_resource(etsects->rsrc);\r\nno_resource:\r\nfree_irq(etsects->irq, etsects);\r\nno_node:\r\nkfree(etsects);\r\nno_memory:\r\nreturn err;\r\n}\r\nstatic int gianfar_ptp_remove(struct platform_device *dev)\r\n{\r\nstruct etsects *etsects = platform_get_drvdata(dev);\r\ngfar_write(&etsects->regs->tmr_temask, 0);\r\ngfar_write(&etsects->regs->tmr_ctrl, 0);\r\ngfar_phc_index = -1;\r\nptp_clock_unregister(etsects->clock);\r\niounmap(etsects->regs);\r\nrelease_resource(etsects->rsrc);\r\nfree_irq(etsects->irq, etsects);\r\nkfree(etsects);\r\nreturn 0;\r\n}
