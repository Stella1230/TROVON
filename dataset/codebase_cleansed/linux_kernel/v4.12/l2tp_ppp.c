static inline struct l2tp_session *pppol2tp_sock_to_session(struct sock *sk)\r\n{\r\nstruct l2tp_session *session;\r\nif (sk == NULL)\r\nreturn NULL;\r\nsock_hold(sk);\r\nsession = (struct l2tp_session *)(sk->sk_user_data);\r\nif (session == NULL) {\r\nsock_put(sk);\r\ngoto out;\r\n}\r\nBUG_ON(session->magic != L2TP_SESSION_MAGIC);\r\nout:\r\nreturn session;\r\n}\r\nstatic int pppol2tp_recv_payload_hook(struct sk_buff *skb)\r\n{\r\nif (!pskb_may_pull(skb, 2))\r\nreturn 1;\r\nif ((skb->data[0] == PPP_ALLSTATIONS) && (skb->data[1] == PPP_UI))\r\nskb_pull(skb, 2);\r\nreturn 0;\r\n}\r\nstatic int pppol2tp_recvmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t len, int flags)\r\n{\r\nint err;\r\nstruct sk_buff *skb;\r\nstruct sock *sk = sock->sk;\r\nerr = -EIO;\r\nif (sk->sk_state & PPPOX_BOUND)\r\ngoto end;\r\nerr = 0;\r\nskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\r\nflags & MSG_DONTWAIT, &err);\r\nif (!skb)\r\ngoto end;\r\nif (len > skb->len)\r\nlen = skb->len;\r\nelse if (len < skb->len)\r\nmsg->msg_flags |= MSG_TRUNC;\r\nerr = skb_copy_datagram_msg(skb, 0, msg, len);\r\nif (likely(err == 0))\r\nerr = len;\r\nkfree_skb(skb);\r\nend:\r\nreturn err;\r\n}\r\nstatic void pppol2tp_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\r\n{\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nstruct sock *sk = NULL;\r\nsk = ps->sock;\r\nif (sk == NULL)\r\ngoto no_sock;\r\nif (sk->sk_state & PPPOX_BOUND) {\r\nstruct pppox_sock *po;\r\nl2tp_dbg(session, L2TP_MSG_DATA,\r\n"%s: recv %d byte data frame, passing to ppp\n",\r\nsession->name, data_len);\r\npo = pppox_sk(sk);\r\nppp_input(&po->chan, skb);\r\n} else {\r\nl2tp_dbg(session, L2TP_MSG_DATA,\r\n"%s: recv %d byte data frame, passing to L2TP socket\n",\r\nsession->name, data_len);\r\nif (sock_queue_rcv_skb(sk, skb) < 0) {\r\natomic_long_inc(&session->stats.rx_errors);\r\nkfree_skb(skb);\r\n}\r\n}\r\nreturn;\r\nno_sock:\r\nl2tp_info(session, L2TP_MSG_DATA, "%s: no socket\n", session->name);\r\nkfree_skb(skb);\r\n}\r\nstatic void pppol2tp_session_sock_hold(struct l2tp_session *session)\r\n{\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nif (ps->sock)\r\nsock_hold(ps->sock);\r\n}\r\nstatic void pppol2tp_session_sock_put(struct l2tp_session *session)\r\n{\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nif (ps->sock)\r\nsock_put(ps->sock);\r\n}\r\nstatic int pppol2tp_sendmsg(struct socket *sock, struct msghdr *m,\r\nsize_t total_len)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sk_buff *skb;\r\nint error;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct pppol2tp_session *ps;\r\nint uhlen;\r\nerror = -ENOTCONN;\r\nif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\r\ngoto error;\r\nerror = -EBADF;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session == NULL)\r\ngoto error;\r\nps = l2tp_session_priv(session);\r\ntunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\r\nif (tunnel == NULL)\r\ngoto error_put_sess;\r\nuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\r\nerror = -ENOMEM;\r\nskb = sock_wmalloc(sk, NET_SKB_PAD + sizeof(struct iphdr) +\r\nuhlen + session->hdr_len +\r\n2 + total_len,\r\n0, GFP_KERNEL);\r\nif (!skb)\r\ngoto error_put_sess_tun;\r\nskb_reserve(skb, NET_SKB_PAD);\r\nskb_reset_network_header(skb);\r\nskb_reserve(skb, sizeof(struct iphdr));\r\nskb_reset_transport_header(skb);\r\nskb_reserve(skb, uhlen);\r\nskb->data[0] = PPP_ALLSTATIONS;\r\nskb->data[1] = PPP_UI;\r\nskb_put(skb, 2);\r\nerror = memcpy_from_msg(skb_put(skb, total_len), m, total_len);\r\nif (error < 0) {\r\nkfree_skb(skb);\r\ngoto error_put_sess_tun;\r\n}\r\nlocal_bh_disable();\r\nl2tp_xmit_skb(session, skb, session->hdr_len);\r\nlocal_bh_enable();\r\nsock_put(ps->tunnel_sock);\r\nsock_put(sk);\r\nreturn total_len;\r\nerror_put_sess_tun:\r\nsock_put(ps->tunnel_sock);\r\nerror_put_sess:\r\nsock_put(sk);\r\nerror:\r\nreturn error;\r\n}\r\nstatic int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)\r\n{\r\nstruct sock *sk = (struct sock *) chan->private;\r\nstruct sock *sk_tun;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct pppol2tp_session *ps;\r\nint uhlen, headroom;\r\nif (sock_flag(sk, SOCK_DEAD) || !(sk->sk_state & PPPOX_CONNECTED))\r\ngoto abort;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session == NULL)\r\ngoto abort;\r\nps = l2tp_session_priv(session);\r\nsk_tun = ps->tunnel_sock;\r\nif (sk_tun == NULL)\r\ngoto abort_put_sess;\r\ntunnel = l2tp_sock_to_tunnel(sk_tun);\r\nif (tunnel == NULL)\r\ngoto abort_put_sess;\r\nuhlen = (tunnel->encap == L2TP_ENCAPTYPE_UDP) ? sizeof(struct udphdr) : 0;\r\nheadroom = NET_SKB_PAD +\r\nsizeof(struct iphdr) +\r\nuhlen +\r\nsession->hdr_len +\r\n2;\r\nif (skb_cow_head(skb, headroom))\r\ngoto abort_put_sess_tun;\r\n__skb_push(skb, 2);\r\nskb->data[0] = PPP_ALLSTATIONS;\r\nskb->data[1] = PPP_UI;\r\nlocal_bh_disable();\r\nl2tp_xmit_skb(session, skb, session->hdr_len);\r\nlocal_bh_enable();\r\nsock_put(sk_tun);\r\nsock_put(sk);\r\nreturn 1;\r\nabort_put_sess_tun:\r\nsock_put(sk_tun);\r\nabort_put_sess:\r\nsock_put(sk);\r\nabort:\r\nkfree_skb(skb);\r\nreturn 1;\r\n}\r\nstatic void pppol2tp_session_close(struct l2tp_session *session)\r\n{\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nstruct sock *sk = ps->sock;\r\nstruct socket *sock = sk->sk_socket;\r\nBUG_ON(session->magic != L2TP_SESSION_MAGIC);\r\nif (sock) {\r\ninet_shutdown(sock, SEND_SHUTDOWN);\r\nl2tp_session_inc_refcount(session);\r\n}\r\n}\r\nstatic void pppol2tp_session_destruct(struct sock *sk)\r\n{\r\nstruct l2tp_session *session = sk->sk_user_data;\r\nskb_queue_purge(&sk->sk_receive_queue);\r\nskb_queue_purge(&sk->sk_write_queue);\r\nif (session) {\r\nsk->sk_user_data = NULL;\r\nBUG_ON(session->magic != L2TP_SESSION_MAGIC);\r\nl2tp_session_dec_refcount(session);\r\n}\r\n}\r\nstatic int pppol2tp_release(struct socket *sock)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2tp_session *session;\r\nint error;\r\nif (!sk)\r\nreturn 0;\r\nerror = -EBADF;\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_DEAD) != 0)\r\ngoto error;\r\npppox_unbind_sock(sk);\r\nsk->sk_state = PPPOX_DEAD;\r\nsock_orphan(sk);\r\nsock->sk = NULL;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session != NULL) {\r\n__l2tp_session_unhash(session);\r\nl2tp_session_queue_purge(session);\r\nsock_put(sk);\r\n}\r\nrelease_sock(sk);\r\nsock_put(sk);\r\nreturn 0;\r\nerror:\r\nrelease_sock(sk);\r\nreturn error;\r\n}\r\nstatic int pppol2tp_backlog_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint rc;\r\nrc = l2tp_udp_encap_recv(sk, skb);\r\nif (rc)\r\nkfree_skb(skb);\r\nreturn NET_RX_SUCCESS;\r\n}\r\nstatic int pppol2tp_create(struct net *net, struct socket *sock, int kern)\r\n{\r\nint error = -ENOMEM;\r\nstruct sock *sk;\r\nsk = sk_alloc(net, PF_PPPOX, GFP_KERNEL, &pppol2tp_sk_proto, kern);\r\nif (!sk)\r\ngoto out;\r\nsock_init_data(sock, sk);\r\nsock->state = SS_UNCONNECTED;\r\nsock->ops = &pppol2tp_ops;\r\nsk->sk_backlog_rcv = pppol2tp_backlog_recv;\r\nsk->sk_protocol = PX_PROTO_OL2TP;\r\nsk->sk_family = PF_PPPOX;\r\nsk->sk_state = PPPOX_NONE;\r\nsk->sk_type = SOCK_STREAM;\r\nsk->sk_destruct = pppol2tp_session_destruct;\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic void pppol2tp_show(struct seq_file *m, void *arg)\r\n{\r\nstruct l2tp_session *session = arg;\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nif (ps) {\r\nstruct pppox_sock *po = pppox_sk(ps->sock);\r\nif (po)\r\nseq_printf(m, " interface %s\n", ppp_dev_name(&po->chan));\r\n}\r\n}\r\nstatic int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,\r\nint sockaddr_len, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct sockaddr_pppol2tp *sp = (struct sockaddr_pppol2tp *) uservaddr;\r\nstruct pppox_sock *po = pppox_sk(sk);\r\nstruct l2tp_session *session = NULL;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct pppol2tp_session *ps;\r\nstruct dst_entry *dst;\r\nstruct l2tp_session_cfg cfg = { 0, };\r\nint error = 0;\r\nu32 tunnel_id, peer_tunnel_id;\r\nu32 session_id, peer_session_id;\r\nbool drop_refcnt = false;\r\nint ver = 2;\r\nint fd;\r\nlock_sock(sk);\r\nerror = -EINVAL;\r\nif (sp->sa_protocol != PX_PROTO_OL2TP)\r\ngoto end;\r\nerror = -EBUSY;\r\nif (sk->sk_state & PPPOX_CONNECTED)\r\ngoto end;\r\nerror = -EALREADY;\r\nif (sk->sk_user_data)\r\ngoto end;\r\npeer_tunnel_id = 0;\r\nif (sockaddr_len == sizeof(struct sockaddr_pppol2tp)) {\r\nfd = sp->pppol2tp.fd;\r\ntunnel_id = sp->pppol2tp.s_tunnel;\r\npeer_tunnel_id = sp->pppol2tp.d_tunnel;\r\nsession_id = sp->pppol2tp.s_session;\r\npeer_session_id = sp->pppol2tp.d_session;\r\n} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpv3)) {\r\nstruct sockaddr_pppol2tpv3 *sp3 =\r\n(struct sockaddr_pppol2tpv3 *) sp;\r\nver = 3;\r\nfd = sp3->pppol2tp.fd;\r\ntunnel_id = sp3->pppol2tp.s_tunnel;\r\npeer_tunnel_id = sp3->pppol2tp.d_tunnel;\r\nsession_id = sp3->pppol2tp.s_session;\r\npeer_session_id = sp3->pppol2tp.d_session;\r\n} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpin6)) {\r\nstruct sockaddr_pppol2tpin6 *sp6 =\r\n(struct sockaddr_pppol2tpin6 *) sp;\r\nfd = sp6->pppol2tp.fd;\r\ntunnel_id = sp6->pppol2tp.s_tunnel;\r\npeer_tunnel_id = sp6->pppol2tp.d_tunnel;\r\nsession_id = sp6->pppol2tp.s_session;\r\npeer_session_id = sp6->pppol2tp.d_session;\r\n} else if (sockaddr_len == sizeof(struct sockaddr_pppol2tpv3in6)) {\r\nstruct sockaddr_pppol2tpv3in6 *sp6 =\r\n(struct sockaddr_pppol2tpv3in6 *) sp;\r\nver = 3;\r\nfd = sp6->pppol2tp.fd;\r\ntunnel_id = sp6->pppol2tp.s_tunnel;\r\npeer_tunnel_id = sp6->pppol2tp.d_tunnel;\r\nsession_id = sp6->pppol2tp.s_session;\r\npeer_session_id = sp6->pppol2tp.d_session;\r\n} else {\r\nerror = -EINVAL;\r\ngoto end;\r\n}\r\nerror = -EINVAL;\r\nif (tunnel_id == 0)\r\ngoto end;\r\ntunnel = l2tp_tunnel_find(sock_net(sk), tunnel_id);\r\nif ((session_id == 0) && (peer_session_id == 0)) {\r\nif (tunnel == NULL) {\r\nstruct l2tp_tunnel_cfg tcfg = {\r\n.encap = L2TP_ENCAPTYPE_UDP,\r\n.debug = 0,\r\n};\r\nerror = l2tp_tunnel_create(sock_net(sk), fd, ver, tunnel_id, peer_tunnel_id, &tcfg, &tunnel);\r\nif (error < 0)\r\ngoto end;\r\n}\r\n} else {\r\nerror = -ENOENT;\r\nif (tunnel == NULL)\r\ngoto end;\r\nif (tunnel->sock == NULL)\r\ngoto end;\r\n}\r\nif (tunnel->recv_payload_hook == NULL)\r\ntunnel->recv_payload_hook = pppol2tp_recv_payload_hook;\r\nif (tunnel->peer_tunnel_id == 0)\r\ntunnel->peer_tunnel_id = peer_tunnel_id;\r\nsession = l2tp_session_get(sock_net(sk), tunnel, session_id, false);\r\nif (session) {\r\ndrop_refcnt = true;\r\nps = l2tp_session_priv(session);\r\nif (ps->sock) {\r\nerror = -EEXIST;\r\ngoto end;\r\n}\r\nif (ps->tunnel_sock != tunnel->sock) {\r\nerror = -EEXIST;\r\ngoto end;\r\n}\r\n} else {\r\ncfg.mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;\r\ncfg.mru = cfg.mtu;\r\nsession = l2tp_session_create(sizeof(struct pppol2tp_session),\r\ntunnel, session_id,\r\npeer_session_id, &cfg);\r\nif (IS_ERR(session)) {\r\nerror = PTR_ERR(session);\r\ngoto end;\r\n}\r\n}\r\nps = l2tp_session_priv(session);\r\nps->owner = current->pid;\r\nps->sock = sk;\r\nps->tunnel_sock = tunnel->sock;\r\nsession->recv_skb = pppol2tp_recv;\r\nsession->session_close = pppol2tp_session_close;\r\n#if IS_ENABLED(CONFIG_L2TP_DEBUGFS)\r\nsession->show = pppol2tp_show;\r\n#endif\r\nsession->ref = pppol2tp_session_sock_hold;\r\nsession->deref = pppol2tp_session_sock_put;\r\ndst = sk_dst_get(tunnel->sock);\r\nif (dst != NULL) {\r\nu32 pmtu = dst_mtu(dst);\r\nif (pmtu != 0)\r\nsession->mtu = session->mru = pmtu -\r\nPPPOL2TP_HEADER_OVERHEAD;\r\ndst_release(dst);\r\n}\r\nif ((session->session_id == 0) &&\r\n(session->peer_session_id == 0)) {\r\nerror = 0;\r\ngoto out_no_ppp;\r\n}\r\npo->chan.hdrlen = PPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\r\npo->chan.private = sk;\r\npo->chan.ops = &pppol2tp_chan_ops;\r\npo->chan.mtu = session->mtu;\r\nerror = ppp_register_net_channel(sock_net(sk), &po->chan);\r\nif (error)\r\ngoto end;\r\nout_no_ppp:\r\nsk->sk_user_data = session;\r\nsk->sk_state = PPPOX_CONNECTED;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: created\n",\r\nsession->name);\r\nend:\r\nif (drop_refcnt)\r\nl2tp_session_dec_refcount(session);\r\nrelease_sock(sk);\r\nreturn error;\r\n}\r\nstatic int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\r\n{\r\nint error;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct l2tp_session *session;\r\nstruct pppol2tp_session *ps;\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nerror = -ENOENT;\r\nif (tunnel == NULL)\r\ngoto out;\r\nif (tunnel->sock == NULL)\r\ngoto out;\r\nif (cfg->mtu == 0)\r\ncfg->mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;\r\nif (cfg->mru == 0)\r\ncfg->mru = cfg->mtu;\r\nsession = l2tp_session_create(sizeof(struct pppol2tp_session),\r\ntunnel, session_id,\r\npeer_session_id, cfg);\r\nif (IS_ERR(session)) {\r\nerror = PTR_ERR(session);\r\ngoto out;\r\n}\r\nps = l2tp_session_priv(session);\r\nps->tunnel_sock = tunnel->sock;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: created\n",\r\nsession->name);\r\nerror = 0;\r\nout:\r\nreturn error;\r\n}\r\nstatic int pppol2tp_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *usockaddr_len, int peer)\r\n{\r\nint len = 0;\r\nint error = 0;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct sock *sk = sock->sk;\r\nstruct inet_sock *inet;\r\nstruct pppol2tp_session *pls;\r\nerror = -ENOTCONN;\r\nif (sk == NULL)\r\ngoto end;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\ngoto end;\r\nerror = -EBADF;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session == NULL)\r\ngoto end;\r\npls = l2tp_session_priv(session);\r\ntunnel = l2tp_sock_to_tunnel(pls->tunnel_sock);\r\nif (tunnel == NULL)\r\ngoto end_put_sess;\r\ninet = inet_sk(tunnel->sock);\r\nif ((tunnel->version == 2) && (tunnel->sock->sk_family == AF_INET)) {\r\nstruct sockaddr_pppol2tp sp;\r\nlen = sizeof(sp);\r\nmemset(&sp, 0, len);\r\nsp.sa_family = AF_PPPOX;\r\nsp.sa_protocol = PX_PROTO_OL2TP;\r\nsp.pppol2tp.fd = tunnel->fd;\r\nsp.pppol2tp.pid = pls->owner;\r\nsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\r\nsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\r\nsp.pppol2tp.s_session = session->session_id;\r\nsp.pppol2tp.d_session = session->peer_session_id;\r\nsp.pppol2tp.addr.sin_family = AF_INET;\r\nsp.pppol2tp.addr.sin_port = inet->inet_dport;\r\nsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\r\nmemcpy(uaddr, &sp, len);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if ((tunnel->version == 2) &&\r\n(tunnel->sock->sk_family == AF_INET6)) {\r\nstruct sockaddr_pppol2tpin6 sp;\r\nlen = sizeof(sp);\r\nmemset(&sp, 0, len);\r\nsp.sa_family = AF_PPPOX;\r\nsp.sa_protocol = PX_PROTO_OL2TP;\r\nsp.pppol2tp.fd = tunnel->fd;\r\nsp.pppol2tp.pid = pls->owner;\r\nsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\r\nsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\r\nsp.pppol2tp.s_session = session->session_id;\r\nsp.pppol2tp.d_session = session->peer_session_id;\r\nsp.pppol2tp.addr.sin6_family = AF_INET6;\r\nsp.pppol2tp.addr.sin6_port = inet->inet_dport;\r\nmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\r\nsizeof(tunnel->sock->sk_v6_daddr));\r\nmemcpy(uaddr, &sp, len);\r\n} else if ((tunnel->version == 3) &&\r\n(tunnel->sock->sk_family == AF_INET6)) {\r\nstruct sockaddr_pppol2tpv3in6 sp;\r\nlen = sizeof(sp);\r\nmemset(&sp, 0, len);\r\nsp.sa_family = AF_PPPOX;\r\nsp.sa_protocol = PX_PROTO_OL2TP;\r\nsp.pppol2tp.fd = tunnel->fd;\r\nsp.pppol2tp.pid = pls->owner;\r\nsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\r\nsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\r\nsp.pppol2tp.s_session = session->session_id;\r\nsp.pppol2tp.d_session = session->peer_session_id;\r\nsp.pppol2tp.addr.sin6_family = AF_INET6;\r\nsp.pppol2tp.addr.sin6_port = inet->inet_dport;\r\nmemcpy(&sp.pppol2tp.addr.sin6_addr, &tunnel->sock->sk_v6_daddr,\r\nsizeof(tunnel->sock->sk_v6_daddr));\r\nmemcpy(uaddr, &sp, len);\r\n#endif\r\n} else if (tunnel->version == 3) {\r\nstruct sockaddr_pppol2tpv3 sp;\r\nlen = sizeof(sp);\r\nmemset(&sp, 0, len);\r\nsp.sa_family = AF_PPPOX;\r\nsp.sa_protocol = PX_PROTO_OL2TP;\r\nsp.pppol2tp.fd = tunnel->fd;\r\nsp.pppol2tp.pid = pls->owner;\r\nsp.pppol2tp.s_tunnel = tunnel->tunnel_id;\r\nsp.pppol2tp.d_tunnel = tunnel->peer_tunnel_id;\r\nsp.pppol2tp.s_session = session->session_id;\r\nsp.pppol2tp.d_session = session->peer_session_id;\r\nsp.pppol2tp.addr.sin_family = AF_INET;\r\nsp.pppol2tp.addr.sin_port = inet->inet_dport;\r\nsp.pppol2tp.addr.sin_addr.s_addr = inet->inet_daddr;\r\nmemcpy(uaddr, &sp, len);\r\n}\r\n*usockaddr_len = len;\r\nerror = 0;\r\nsock_put(pls->tunnel_sock);\r\nend_put_sess:\r\nsock_put(sk);\r\nend:\r\nreturn error;\r\n}\r\nstatic void pppol2tp_copy_stats(struct pppol2tp_ioc_stats *dest,\r\nstruct l2tp_stats *stats)\r\n{\r\ndest->tx_packets = atomic_long_read(&stats->tx_packets);\r\ndest->tx_bytes = atomic_long_read(&stats->tx_bytes);\r\ndest->tx_errors = atomic_long_read(&stats->tx_errors);\r\ndest->rx_packets = atomic_long_read(&stats->rx_packets);\r\ndest->rx_bytes = atomic_long_read(&stats->rx_bytes);\r\ndest->rx_seq_discards = atomic_long_read(&stats->rx_seq_discards);\r\ndest->rx_oos_packets = atomic_long_read(&stats->rx_oos_packets);\r\ndest->rx_errors = atomic_long_read(&stats->rx_errors);\r\n}\r\nstatic int pppol2tp_session_ioctl(struct l2tp_session *session,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nstruct ifreq ifr;\r\nint err = 0;\r\nstruct sock *sk;\r\nint val = (int) arg;\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nstruct pppol2tp_ioc_stats stats;\r\nl2tp_dbg(session, L2TP_MSG_CONTROL,\r\n"%s: pppol2tp_session_ioctl(cmd=%#x, arg=%#lx)\n",\r\nsession->name, cmd, arg);\r\nsk = ps->sock;\r\nsock_hold(sk);\r\nswitch (cmd) {\r\ncase SIOCGIFMTU:\r\nerr = -ENXIO;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\nbreak;\r\nerr = -EFAULT;\r\nif (copy_from_user(&ifr, (void __user *) arg, sizeof(struct ifreq)))\r\nbreak;\r\nifr.ifr_mtu = session->mtu;\r\nif (copy_to_user((void __user *) arg, &ifr, sizeof(struct ifreq)))\r\nbreak;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: get mtu=%d\n",\r\nsession->name, session->mtu);\r\nerr = 0;\r\nbreak;\r\ncase SIOCSIFMTU:\r\nerr = -ENXIO;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\nbreak;\r\nerr = -EFAULT;\r\nif (copy_from_user(&ifr, (void __user *) arg, sizeof(struct ifreq)))\r\nbreak;\r\nsession->mtu = ifr.ifr_mtu;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: set mtu=%d\n",\r\nsession->name, session->mtu);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGMRU:\r\nerr = -ENXIO;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\nbreak;\r\nerr = -EFAULT;\r\nif (put_user(session->mru, (int __user *) arg))\r\nbreak;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: get mru=%d\n",\r\nsession->name, session->mru);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSMRU:\r\nerr = -ENXIO;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\nbreak;\r\nerr = -EFAULT;\r\nif (get_user(val, (int __user *) arg))\r\nbreak;\r\nsession->mru = val;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: set mru=%d\n",\r\nsession->name, session->mru);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGFLAGS:\r\nerr = -EFAULT;\r\nif (put_user(ps->flags, (int __user *) arg))\r\nbreak;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: get flags=%d\n",\r\nsession->name, ps->flags);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCSFLAGS:\r\nerr = -EFAULT;\r\nif (get_user(val, (int __user *) arg))\r\nbreak;\r\nps->flags = val;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: set flags=%d\n",\r\nsession->name, ps->flags);\r\nerr = 0;\r\nbreak;\r\ncase PPPIOCGL2TPSTATS:\r\nerr = -ENXIO;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\nbreak;\r\nmemset(&stats, 0, sizeof(stats));\r\nstats.tunnel_id = tunnel->tunnel_id;\r\nstats.session_id = session->session_id;\r\npppol2tp_copy_stats(&stats, &session->stats);\r\nif (copy_to_user((void __user *) arg, &stats,\r\nsizeof(stats)))\r\nbreak;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: get L2TP stats\n",\r\nsession->name);\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -ENOSYS;\r\nbreak;\r\n}\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic int pppol2tp_tunnel_ioctl(struct l2tp_tunnel *tunnel,\r\nunsigned int cmd, unsigned long arg)\r\n{\r\nint err = 0;\r\nstruct sock *sk;\r\nstruct pppol2tp_ioc_stats stats;\r\nl2tp_dbg(tunnel, L2TP_MSG_CONTROL,\r\n"%s: pppol2tp_tunnel_ioctl(cmd=%#x, arg=%#lx)\n",\r\ntunnel->name, cmd, arg);\r\nsk = tunnel->sock;\r\nsock_hold(sk);\r\nswitch (cmd) {\r\ncase PPPIOCGL2TPSTATS:\r\nerr = -ENXIO;\r\nif (!(sk->sk_state & PPPOX_CONNECTED))\r\nbreak;\r\nif (copy_from_user(&stats, (void __user *) arg,\r\nsizeof(stats))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nif (stats.session_id != 0) {\r\nstruct l2tp_session *session =\r\nl2tp_session_get(sock_net(sk), tunnel,\r\nstats.session_id, true);\r\nif (session) {\r\nerr = pppol2tp_session_ioctl(session, cmd,\r\narg);\r\nif (session->deref)\r\nsession->deref(session);\r\nl2tp_session_dec_refcount(session);\r\n} else {\r\nerr = -EBADR;\r\n}\r\nbreak;\r\n}\r\n#ifdef CONFIG_XFRM\r\nstats.using_ipsec = (sk->sk_policy[0] || sk->sk_policy[1]) ? 1 : 0;\r\n#endif\r\npppol2tp_copy_stats(&stats, &tunnel->stats);\r\nif (copy_to_user((void __user *) arg, &stats, sizeof(stats))) {\r\nerr = -EFAULT;\r\nbreak;\r\n}\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: get L2TP stats\n",\r\ntunnel->name);\r\nerr = 0;\r\nbreak;\r\ndefault:\r\nerr = -ENOSYS;\r\nbreak;\r\n}\r\nsock_put(sk);\r\nreturn err;\r\n}\r\nstatic int pppol2tp_ioctl(struct socket *sock, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct pppol2tp_session *ps;\r\nint err;\r\nif (!sk)\r\nreturn 0;\r\nerr = -EBADF;\r\nif (sock_flag(sk, SOCK_DEAD) != 0)\r\ngoto end;\r\nerr = -ENOTCONN;\r\nif ((sk->sk_user_data == NULL) ||\r\n(!(sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND))))\r\ngoto end;\r\nerr = -EBADF;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session == NULL)\r\ngoto end;\r\nps = l2tp_session_priv(session);\r\nif ((session->session_id == 0) &&\r\n(session->peer_session_id == 0)) {\r\nerr = -EBADF;\r\ntunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\r\nif (tunnel == NULL)\r\ngoto end_put_sess;\r\nerr = pppol2tp_tunnel_ioctl(tunnel, cmd, arg);\r\nsock_put(ps->tunnel_sock);\r\ngoto end_put_sess;\r\n}\r\nerr = pppol2tp_session_ioctl(session, cmd, arg);\r\nend_put_sess:\r\nsock_put(sk);\r\nend:\r\nreturn err;\r\n}\r\nstatic int pppol2tp_tunnel_setsockopt(struct sock *sk,\r\nstruct l2tp_tunnel *tunnel,\r\nint optname, int val)\r\n{\r\nint err = 0;\r\nswitch (optname) {\r\ncase PPPOL2TP_SO_DEBUG:\r\ntunnel->debug = val;\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: set debug=%x\n",\r\ntunnel->name, tunnel->debug);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int pppol2tp_session_setsockopt(struct sock *sk,\r\nstruct l2tp_session *session,\r\nint optname, int val)\r\n{\r\nint err = 0;\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nswitch (optname) {\r\ncase PPPOL2TP_SO_RECVSEQ:\r\nif ((val != 0) && (val != 1)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nsession->recv_seq = !!val;\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: set recv_seq=%d\n",\r\nsession->name, session->recv_seq);\r\nbreak;\r\ncase PPPOL2TP_SO_SENDSEQ:\r\nif ((val != 0) && (val != 1)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nsession->send_seq = !!val;\r\n{\r\nstruct sock *ssk = ps->sock;\r\nstruct pppox_sock *po = pppox_sk(ssk);\r\npo->chan.hdrlen = val ? PPPOL2TP_L2TP_HDR_SIZE_SEQ :\r\nPPPOL2TP_L2TP_HDR_SIZE_NOSEQ;\r\n}\r\nl2tp_session_set_header_len(session, session->tunnel->version);\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: set send_seq=%d\n",\r\nsession->name, session->send_seq);\r\nbreak;\r\ncase PPPOL2TP_SO_LNSMODE:\r\nif ((val != 0) && (val != 1)) {\r\nerr = -EINVAL;\r\nbreak;\r\n}\r\nsession->lns_mode = !!val;\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: set lns_mode=%d\n",\r\nsession->name, session->lns_mode);\r\nbreak;\r\ncase PPPOL2TP_SO_DEBUG:\r\nsession->debug = val;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: set debug=%x\n",\r\nsession->name, session->debug);\r\nbreak;\r\ncase PPPOL2TP_SO_REORDERTO:\r\nsession->reorder_timeout = msecs_to_jiffies(val);\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: set reorder_timeout=%d\n",\r\nsession->name, session->reorder_timeout);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, unsigned int optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel;\r\nstruct pppol2tp_session *ps;\r\nint val;\r\nint err;\r\nif (level != SOL_PPPOL2TP)\r\nreturn -EINVAL;\r\nif (optlen < sizeof(int))\r\nreturn -EINVAL;\r\nif (get_user(val, (int __user *)optval))\r\nreturn -EFAULT;\r\nerr = -ENOTCONN;\r\nif (sk->sk_user_data == NULL)\r\ngoto end;\r\nerr = -EBADF;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session == NULL)\r\ngoto end;\r\nps = l2tp_session_priv(session);\r\nif ((session->session_id == 0) &&\r\n(session->peer_session_id == 0)) {\r\nerr = -EBADF;\r\ntunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\r\nif (tunnel == NULL)\r\ngoto end_put_sess;\r\nerr = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\r\nsock_put(ps->tunnel_sock);\r\n} else\r\nerr = pppol2tp_session_setsockopt(sk, session, optname, val);\r\nend_put_sess:\r\nsock_put(sk);\r\nend:\r\nreturn err;\r\n}\r\nstatic int pppol2tp_tunnel_getsockopt(struct sock *sk,\r\nstruct l2tp_tunnel *tunnel,\r\nint optname, int *val)\r\n{\r\nint err = 0;\r\nswitch (optname) {\r\ncase PPPOL2TP_SO_DEBUG:\r\n*val = tunnel->debug;\r\nl2tp_info(tunnel, L2TP_MSG_CONTROL, "%s: get debug=%x\n",\r\ntunnel->name, tunnel->debug);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\nbreak;\r\n}\r\nreturn err;\r\n}\r\nstatic int pppol2tp_session_getsockopt(struct sock *sk,\r\nstruct l2tp_session *session,\r\nint optname, int *val)\r\n{\r\nint err = 0;\r\nswitch (optname) {\r\ncase PPPOL2TP_SO_RECVSEQ:\r\n*val = session->recv_seq;\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: get recv_seq=%d\n", session->name, *val);\r\nbreak;\r\ncase PPPOL2TP_SO_SENDSEQ:\r\n*val = session->send_seq;\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: get send_seq=%d\n", session->name, *val);\r\nbreak;\r\ncase PPPOL2TP_SO_LNSMODE:\r\n*val = session->lns_mode;\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: get lns_mode=%d\n", session->name, *val);\r\nbreak;\r\ncase PPPOL2TP_SO_DEBUG:\r\n*val = session->debug;\r\nl2tp_info(session, L2TP_MSG_CONTROL, "%s: get debug=%d\n",\r\nsession->name, *val);\r\nbreak;\r\ncase PPPOL2TP_SO_REORDERTO:\r\n*val = (int) jiffies_to_msecs(session->reorder_timeout);\r\nl2tp_info(session, L2TP_MSG_CONTROL,\r\n"%s: get reorder_timeout=%d\n", session->name, *val);\r\nbreak;\r\ndefault:\r\nerr = -ENOPROTOOPT;\r\n}\r\nreturn err;\r\n}\r\nstatic int pppol2tp_getsockopt(struct socket *sock, int level, int optname,\r\nchar __user *optval, int __user *optlen)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel;\r\nint val, len;\r\nint err;\r\nstruct pppol2tp_session *ps;\r\nif (level != SOL_PPPOL2TP)\r\nreturn -EINVAL;\r\nif (get_user(len, optlen))\r\nreturn -EFAULT;\r\nlen = min_t(unsigned int, len, sizeof(int));\r\nif (len < 0)\r\nreturn -EINVAL;\r\nerr = -ENOTCONN;\r\nif (sk->sk_user_data == NULL)\r\ngoto end;\r\nerr = -EBADF;\r\nsession = pppol2tp_sock_to_session(sk);\r\nif (session == NULL)\r\ngoto end;\r\nps = l2tp_session_priv(session);\r\nif ((session->session_id == 0) &&\r\n(session->peer_session_id == 0)) {\r\nerr = -EBADF;\r\ntunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\r\nif (tunnel == NULL)\r\ngoto end_put_sess;\r\nerr = pppol2tp_tunnel_getsockopt(sk, tunnel, optname, &val);\r\nsock_put(ps->tunnel_sock);\r\nif (err)\r\ngoto end_put_sess;\r\n} else {\r\nerr = pppol2tp_session_getsockopt(sk, session, optname, &val);\r\nif (err)\r\ngoto end_put_sess;\r\n}\r\nerr = -EFAULT;\r\nif (put_user(len, optlen))\r\ngoto end_put_sess;\r\nif (copy_to_user((void __user *) optval, &val, len))\r\ngoto end_put_sess;\r\nerr = 0;\r\nend_put_sess:\r\nsock_put(sk);\r\nend:\r\nreturn err;\r\n}\r\nstatic void pppol2tp_next_tunnel(struct net *net, struct pppol2tp_seq_data *pd)\r\n{\r\nfor (;;) {\r\npd->tunnel = l2tp_tunnel_find_nth(net, pd->tunnel_idx);\r\npd->tunnel_idx++;\r\nif (pd->tunnel == NULL)\r\nbreak;\r\nif (pd->tunnel->version < 3)\r\nbreak;\r\n}\r\n}\r\nstatic void pppol2tp_next_session(struct net *net, struct pppol2tp_seq_data *pd)\r\n{\r\npd->session = l2tp_session_get_nth(pd->tunnel, pd->session_idx, true);\r\npd->session_idx++;\r\nif (pd->session == NULL) {\r\npd->session_idx = 0;\r\npppol2tp_next_tunnel(net, pd);\r\n}\r\n}\r\nstatic void *pppol2tp_seq_start(struct seq_file *m, loff_t *offs)\r\n{\r\nstruct pppol2tp_seq_data *pd = SEQ_START_TOKEN;\r\nloff_t pos = *offs;\r\nstruct net *net;\r\nif (!pos)\r\ngoto out;\r\nBUG_ON(m->private == NULL);\r\npd = m->private;\r\nnet = seq_file_net(m);\r\nif (pd->tunnel == NULL)\r\npppol2tp_next_tunnel(net, pd);\r\nelse\r\npppol2tp_next_session(net, pd);\r\nif ((pd->tunnel == NULL) && (pd->session == NULL))\r\npd = NULL;\r\nout:\r\nreturn pd;\r\n}\r\nstatic void *pppol2tp_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn NULL;\r\n}\r\nstatic void pppol2tp_seq_stop(struct seq_file *p, void *v)\r\n{\r\n}\r\nstatic void pppol2tp_seq_tunnel_show(struct seq_file *m, void *v)\r\n{\r\nstruct l2tp_tunnel *tunnel = v;\r\nseq_printf(m, "\nTUNNEL '%s', %c %d\n",\r\ntunnel->name,\r\n(tunnel == tunnel->sock->sk_user_data) ? 'Y' : 'N',\r\natomic_read(&tunnel->ref_count) - 1);\r\nseq_printf(m, " %08x %ld/%ld/%ld %ld/%ld/%ld\n",\r\ntunnel->debug,\r\natomic_long_read(&tunnel->stats.tx_packets),\r\natomic_long_read(&tunnel->stats.tx_bytes),\r\natomic_long_read(&tunnel->stats.tx_errors),\r\natomic_long_read(&tunnel->stats.rx_packets),\r\natomic_long_read(&tunnel->stats.rx_bytes),\r\natomic_long_read(&tunnel->stats.rx_errors));\r\n}\r\nstatic void pppol2tp_seq_session_show(struct seq_file *m, void *v)\r\n{\r\nstruct l2tp_session *session = v;\r\nstruct l2tp_tunnel *tunnel = session->tunnel;\r\nstruct pppol2tp_session *ps = l2tp_session_priv(session);\r\nstruct pppox_sock *po = pppox_sk(ps->sock);\r\nu32 ip = 0;\r\nu16 port = 0;\r\nif (tunnel->sock) {\r\nstruct inet_sock *inet = inet_sk(tunnel->sock);\r\nip = ntohl(inet->inet_saddr);\r\nport = ntohs(inet->inet_sport);\r\n}\r\nseq_printf(m, " SESSION '%s' %08X/%d %04X/%04X -> "\r\n"%04X/%04X %d %c\n",\r\nsession->name, ip, port,\r\ntunnel->tunnel_id,\r\nsession->session_id,\r\ntunnel->peer_tunnel_id,\r\nsession->peer_session_id,\r\nps->sock->sk_state,\r\n(session == ps->sock->sk_user_data) ?\r\n'Y' : 'N');\r\nseq_printf(m, " %d/%d/%c/%c/%s %08x %u\n",\r\nsession->mtu, session->mru,\r\nsession->recv_seq ? 'R' : '-',\r\nsession->send_seq ? 'S' : '-',\r\nsession->lns_mode ? "LNS" : "LAC",\r\nsession->debug,\r\njiffies_to_msecs(session->reorder_timeout));\r\nseq_printf(m, " %hu/%hu %ld/%ld/%ld %ld/%ld/%ld\n",\r\nsession->nr, session->ns,\r\natomic_long_read(&session->stats.tx_packets),\r\natomic_long_read(&session->stats.tx_bytes),\r\natomic_long_read(&session->stats.tx_errors),\r\natomic_long_read(&session->stats.rx_packets),\r\natomic_long_read(&session->stats.rx_bytes),\r\natomic_long_read(&session->stats.rx_errors));\r\nif (po)\r\nseq_printf(m, " interface %s\n", ppp_dev_name(&po->chan));\r\n}\r\nstatic int pppol2tp_seq_show(struct seq_file *m, void *v)\r\n{\r\nstruct pppol2tp_seq_data *pd = v;\r\nif (v == SEQ_START_TOKEN) {\r\nseq_puts(m, "PPPoL2TP driver info, " PPPOL2TP_DRV_VERSION "\n");\r\nseq_puts(m, "TUNNEL name, user-data-ok session-count\n");\r\nseq_puts(m, " debug tx-pkts/bytes/errs rx-pkts/bytes/errs\n");\r\nseq_puts(m, " SESSION name, addr/port src-tid/sid "\r\n"dest-tid/sid state user-data-ok\n");\r\nseq_puts(m, " mtu/mru/rcvseq/sendseq/lns debug reorderto\n");\r\nseq_puts(m, " nr/ns tx-pkts/bytes/errs rx-pkts/bytes/errs\n");\r\ngoto out;\r\n}\r\nif (!pd->session) {\r\npppol2tp_seq_tunnel_show(m, pd->tunnel);\r\n} else {\r\npppol2tp_seq_session_show(m, pd->session);\r\nif (pd->session->deref)\r\npd->session->deref(pd->session);\r\nl2tp_session_dec_refcount(pd->session);\r\n}\r\nout:\r\nreturn 0;\r\n}\r\nstatic int pppol2tp_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open_net(inode, file, &pppol2tp_seq_ops,\r\nsizeof(struct pppol2tp_seq_data));\r\n}\r\nstatic __net_init int pppol2tp_init_net(struct net *net)\r\n{\r\nstruct proc_dir_entry *pde;\r\nint err = 0;\r\npde = proc_create("pppol2tp", S_IRUGO, net->proc_net,\r\n&pppol2tp_proc_fops);\r\nif (!pde) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic __net_exit void pppol2tp_exit_net(struct net *net)\r\n{\r\nremove_proc_entry("pppol2tp", net->proc_net);\r\n}\r\nstatic int __init pppol2tp_init(void)\r\n{\r\nint err;\r\nerr = register_pernet_device(&pppol2tp_net_ops);\r\nif (err)\r\ngoto out;\r\nerr = proto_register(&pppol2tp_sk_proto, 0);\r\nif (err)\r\ngoto out_unregister_pppol2tp_pernet;\r\nerr = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);\r\nif (err)\r\ngoto out_unregister_pppol2tp_proto;\r\n#ifdef CONFIG_L2TP_V3\r\nerr = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);\r\nif (err)\r\ngoto out_unregister_pppox;\r\n#endif\r\npr_info("PPPoL2TP kernel driver, %s\n", PPPOL2TP_DRV_VERSION);\r\nout:\r\nreturn err;\r\n#ifdef CONFIG_L2TP_V3\r\nout_unregister_pppox:\r\nunregister_pppox_proto(PX_PROTO_OL2TP);\r\n#endif\r\nout_unregister_pppol2tp_proto:\r\nproto_unregister(&pppol2tp_sk_proto);\r\nout_unregister_pppol2tp_pernet:\r\nunregister_pernet_device(&pppol2tp_net_ops);\r\ngoto out;\r\n}\r\nstatic void __exit pppol2tp_exit(void)\r\n{\r\n#ifdef CONFIG_L2TP_V3\r\nl2tp_nl_unregister_ops(L2TP_PWTYPE_PPP);\r\n#endif\r\nunregister_pppox_proto(PX_PROTO_OL2TP);\r\nproto_unregister(&pppol2tp_sk_proto);\r\nunregister_pernet_device(&pppol2tp_net_ops);\r\n}
