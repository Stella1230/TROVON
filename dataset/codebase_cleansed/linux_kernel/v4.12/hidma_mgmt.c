int hidma_mgmt_setup(struct hidma_mgmt_dev *mgmtdev)\r\n{\r\nunsigned int i;\r\nu32 val;\r\nif (!is_power_of_2(mgmtdev->max_write_request) ||\r\n(mgmtdev->max_write_request < 128) ||\r\n(mgmtdev->max_write_request > 1024)) {\r\ndev_err(&mgmtdev->pdev->dev, "invalid write request %d\n",\r\nmgmtdev->max_write_request);\r\nreturn -EINVAL;\r\n}\r\nif (!is_power_of_2(mgmtdev->max_read_request) ||\r\n(mgmtdev->max_read_request < 128) ||\r\n(mgmtdev->max_read_request > 1024)) {\r\ndev_err(&mgmtdev->pdev->dev, "invalid read request %d\n",\r\nmgmtdev->max_read_request);\r\nreturn -EINVAL;\r\n}\r\nif (mgmtdev->max_wr_xactions > HIDMA_MAX_WR_XACTIONS_MASK) {\r\ndev_err(&mgmtdev->pdev->dev,\r\n"max_wr_xactions cannot be bigger than %ld\n",\r\nHIDMA_MAX_WR_XACTIONS_MASK);\r\nreturn -EINVAL;\r\n}\r\nif (mgmtdev->max_rd_xactions > HIDMA_MAX_RD_XACTIONS_MASK) {\r\ndev_err(&mgmtdev->pdev->dev,\r\n"max_rd_xactions cannot be bigger than %ld\n",\r\nHIDMA_MAX_RD_XACTIONS_MASK);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < mgmtdev->dma_channels; i++) {\r\nif (mgmtdev->priority[i] > 1) {\r\ndev_err(&mgmtdev->pdev->dev,\r\n"priority can be 0 or 1\n");\r\nreturn -EINVAL;\r\n}\r\nif (mgmtdev->weight[i] > HIDMA_MAX_CHANNEL_WEIGHT) {\r\ndev_err(&mgmtdev->pdev->dev,\r\n"max value of weight can be %d.\n",\r\nHIDMA_MAX_CHANNEL_WEIGHT);\r\nreturn -EINVAL;\r\n}\r\nif (mgmtdev->weight[i] == 0)\r\nmgmtdev->weight[i] = 1;\r\n}\r\npm_runtime_get_sync(&mgmtdev->pdev->dev);\r\nval = readl(mgmtdev->virtaddr + HIDMA_MAX_BUS_REQ_LEN_OFFSET);\r\nval &= ~(HIDMA_MAX_BUS_REQ_LEN_MASK << HIDMA_MAX_BUS_WR_REQ_BIT_POS);\r\nval |= mgmtdev->max_write_request << HIDMA_MAX_BUS_WR_REQ_BIT_POS;\r\nval &= ~HIDMA_MAX_BUS_REQ_LEN_MASK;\r\nval |= mgmtdev->max_read_request;\r\nwritel(val, mgmtdev->virtaddr + HIDMA_MAX_BUS_REQ_LEN_OFFSET);\r\nval = readl(mgmtdev->virtaddr + HIDMA_MAX_XACTIONS_OFFSET);\r\nval &= ~(HIDMA_MAX_WR_XACTIONS_MASK << HIDMA_MAX_WR_XACTIONS_BIT_POS);\r\nval |= mgmtdev->max_wr_xactions << HIDMA_MAX_WR_XACTIONS_BIT_POS;\r\nval &= ~HIDMA_MAX_RD_XACTIONS_MASK;\r\nval |= mgmtdev->max_rd_xactions;\r\nwritel(val, mgmtdev->virtaddr + HIDMA_MAX_XACTIONS_OFFSET);\r\nmgmtdev->hw_version =\r\nreadl(mgmtdev->virtaddr + HIDMA_HW_VERSION_OFFSET);\r\nmgmtdev->hw_version_major = (mgmtdev->hw_version >> 28) & 0xF;\r\nmgmtdev->hw_version_minor = (mgmtdev->hw_version >> 16) & 0xF;\r\nfor (i = 0; i < mgmtdev->dma_channels; i++) {\r\nu32 weight = mgmtdev->weight[i];\r\nu32 priority = mgmtdev->priority[i];\r\nval = readl(mgmtdev->virtaddr + HIDMA_QOS_N_OFFSET + (4 * i));\r\nval &= ~(1 << HIDMA_PRIORITY_BIT_POS);\r\nval |= (priority & 0x1) << HIDMA_PRIORITY_BIT_POS;\r\nval &= ~(HIDMA_WEIGHT_MASK << HIDMA_WRR_BIT_POS);\r\nval |= (weight & HIDMA_WEIGHT_MASK) << HIDMA_WRR_BIT_POS;\r\nwritel(val, mgmtdev->virtaddr + HIDMA_QOS_N_OFFSET + (4 * i));\r\n}\r\nval = readl(mgmtdev->virtaddr + HIDMA_CHRESET_TIMEOUT_OFFSET);\r\nval &= ~HIDMA_CHRESET_TIMEOUT_MASK;\r\nval |= mgmtdev->chreset_timeout_cycles & HIDMA_CHRESET_TIMEOUT_MASK;\r\nwritel(val, mgmtdev->virtaddr + HIDMA_CHRESET_TIMEOUT_OFFSET);\r\npm_runtime_mark_last_busy(&mgmtdev->pdev->dev);\r\npm_runtime_put_autosuspend(&mgmtdev->pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int hidma_mgmt_probe(struct platform_device *pdev)\r\n{\r\nstruct hidma_mgmt_dev *mgmtdev;\r\nstruct resource *res;\r\nvoid __iomem *virtaddr;\r\nint irq;\r\nint rc;\r\nu32 val;\r\npm_runtime_set_autosuspend_delay(&pdev->dev, HIDMA_AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\npm_runtime_get_sync(&pdev->dev);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nvirtaddr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(virtaddr)) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "irq resources not found\n");\r\nrc = irq;\r\ngoto out;\r\n}\r\nmgmtdev = devm_kzalloc(&pdev->dev, sizeof(*mgmtdev), GFP_KERNEL);\r\nif (!mgmtdev) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmgmtdev->pdev = pdev;\r\nmgmtdev->addrsize = resource_size(res);\r\nmgmtdev->virtaddr = virtaddr;\r\nrc = device_property_read_u32(&pdev->dev, "dma-channels",\r\n&mgmtdev->dma_channels);\r\nif (rc) {\r\ndev_err(&pdev->dev, "number of channels missing\n");\r\ngoto out;\r\n}\r\nrc = device_property_read_u32(&pdev->dev,\r\n"channel-reset-timeout-cycles",\r\n&mgmtdev->chreset_timeout_cycles);\r\nif (rc) {\r\ndev_err(&pdev->dev, "channel reset timeout missing\n");\r\ngoto out;\r\n}\r\nrc = device_property_read_u32(&pdev->dev, "max-write-burst-bytes",\r\n&mgmtdev->max_write_request);\r\nif (rc) {\r\ndev_err(&pdev->dev, "max-write-burst-bytes missing\n");\r\ngoto out;\r\n}\r\nrc = device_property_read_u32(&pdev->dev, "max-read-burst-bytes",\r\n&mgmtdev->max_read_request);\r\nif (rc) {\r\ndev_err(&pdev->dev, "max-read-burst-bytes missing\n");\r\ngoto out;\r\n}\r\nrc = device_property_read_u32(&pdev->dev, "max-write-transactions",\r\n&mgmtdev->max_wr_xactions);\r\nif (rc) {\r\ndev_err(&pdev->dev, "max-write-transactions missing\n");\r\ngoto out;\r\n}\r\nrc = device_property_read_u32(&pdev->dev, "max-read-transactions",\r\n&mgmtdev->max_rd_xactions);\r\nif (rc) {\r\ndev_err(&pdev->dev, "max-read-transactions missing\n");\r\ngoto out;\r\n}\r\nmgmtdev->priority = devm_kcalloc(&pdev->dev,\r\nmgmtdev->dma_channels,\r\nsizeof(*mgmtdev->priority),\r\nGFP_KERNEL);\r\nif (!mgmtdev->priority) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nmgmtdev->weight = devm_kcalloc(&pdev->dev,\r\nmgmtdev->dma_channels,\r\nsizeof(*mgmtdev->weight), GFP_KERNEL);\r\nif (!mgmtdev->weight) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nrc = hidma_mgmt_setup(mgmtdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "setup failed\n");\r\ngoto out;\r\n}\r\nval = readl(mgmtdev->virtaddr + HIDMA_CFG_OFFSET);\r\nval |= 1;\r\nwritel(val, mgmtdev->virtaddr + HIDMA_CFG_OFFSET);\r\nrc = hidma_mgmt_init_sys(mgmtdev);\r\nif (rc) {\r\ndev_err(&pdev->dev, "sysfs setup failed\n");\r\ngoto out;\r\n}\r\ndev_info(&pdev->dev,\r\n"HW rev: %d.%d @ %pa with %d physical channels\n",\r\nmgmtdev->hw_version_major, mgmtdev->hw_version_minor,\r\n&res->start, mgmtdev->dma_channels);\r\nplatform_set_drvdata(pdev, mgmtdev);\r\npm_runtime_mark_last_busy(&pdev->dev);\r\npm_runtime_put_autosuspend(&pdev->dev);\r\nreturn 0;\r\nout:\r\npm_runtime_put_sync_suspend(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nreturn rc;\r\n}\r\nstatic int __init hidma_mgmt_of_populate_channels(struct device_node *np)\r\n{\r\nstruct platform_device *pdev_parent = of_find_device_by_node(np);\r\nstruct platform_device_info pdevinfo;\r\nstruct of_phandle_args out_irq;\r\nstruct device_node *child;\r\nstruct resource *res;\r\nconst __be32 *cell;\r\nint ret = 0, size, i, num;\r\nu64 addr, addr_size;\r\nfor_each_available_child_of_node(np, child) {\r\nstruct resource *res_iter;\r\nstruct platform_device *new_pdev;\r\ncell = of_get_property(child, "reg", &size);\r\nif (!cell) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nsize /= sizeof(*cell);\r\nnum = size /\r\n(of_n_addr_cells(child) + of_n_size_cells(child)) + 1;\r\nres = kcalloc(num, sizeof(*res), GFP_KERNEL);\r\nif (!res) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\ni = 0;\r\nres_iter = res;\r\nwhile (i < size) {\r\naddr = of_read_number(&cell[i],\r\nof_n_addr_cells(child));\r\ni += of_n_addr_cells(child);\r\naddr_size = of_read_number(&cell[i],\r\nof_n_size_cells(child));\r\ni += of_n_size_cells(child);\r\nres_iter->start = addr;\r\nres_iter->end = res_iter->start + addr_size - 1;\r\nres_iter->flags = IORESOURCE_MEM;\r\nres_iter++;\r\n}\r\nret = of_irq_parse_one(child, 0, &out_irq);\r\nif (ret)\r\ngoto out;\r\nres_iter->start = irq_create_of_mapping(&out_irq);\r\nres_iter->name = "hidma event irq";\r\nres_iter->flags = IORESOURCE_IRQ;\r\nmemset(&pdevinfo, 0, sizeof(pdevinfo));\r\npdevinfo.fwnode = &child->fwnode;\r\npdevinfo.parent = pdev_parent ? &pdev_parent->dev : NULL;\r\npdevinfo.name = child->name;\r\npdevinfo.id = object_counter++;\r\npdevinfo.res = res;\r\npdevinfo.num_res = num;\r\npdevinfo.data = NULL;\r\npdevinfo.size_data = 0;\r\npdevinfo.dma_mask = DMA_BIT_MASK(64);\r\nnew_pdev = platform_device_register_full(&pdevinfo);\r\nif (IS_ERR(new_pdev)) {\r\nret = PTR_ERR(new_pdev);\r\ngoto out;\r\n}\r\nof_node_get(child);\r\nnew_pdev->dev.of_node = child;\r\nof_dma_configure(&new_pdev->dev, child);\r\nof_msi_configure(&new_pdev->dev, child);\r\nof_node_put(child);\r\nkfree(res);\r\nres = NULL;\r\n}\r\nout:\r\nkfree(res);\r\nreturn ret;\r\n}\r\nstatic int __init hidma_mgmt_init(void)\r\n{\r\n#if defined(CONFIG_OF) && defined(CONFIG_OF_IRQ)\r\nstruct device_node *child;\r\nfor_each_matching_node(child, hidma_mgmt_match) {\r\nhidma_mgmt_of_populate_channels(child);\r\n}\r\n#endif\r\nplatform_driver_register(&hidma_mgmt_driver);\r\nreturn 0;\r\n}
