static inline unsigned int xgbe_get_max_frame(struct xgbe_prv_data *pdata)\r\n{\r\nreturn pdata->netdev->mtu + ETH_HLEN + ETH_FCS_LEN + VLAN_HLEN;\r\n}\r\nstatic unsigned int xgbe_usec_to_riwt(struct xgbe_prv_data *pdata,\r\nunsigned int usec)\r\n{\r\nunsigned long rate;\r\nunsigned int ret;\r\nDBGPR("-->xgbe_usec_to_riwt\n");\r\nrate = pdata->sysclk_rate;\r\nret = (usec * (rate / 1000000)) / 256;\r\nDBGPR("<--xgbe_usec_to_riwt\n");\r\nreturn ret;\r\n}\r\nstatic unsigned int xgbe_riwt_to_usec(struct xgbe_prv_data *pdata,\r\nunsigned int riwt)\r\n{\r\nunsigned long rate;\r\nunsigned int ret;\r\nDBGPR("-->xgbe_riwt_to_usec\n");\r\nrate = pdata->sysclk_rate;\r\nret = (riwt * 256) / (rate / 1000000);\r\nDBGPR("<--xgbe_riwt_to_usec\n");\r\nreturn ret;\r\n}\r\nstatic int xgbe_config_pblx8(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++)\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_CR, PBLX8,\r\npdata->pblx8);\r\nreturn 0;\r\n}\r\nstatic int xgbe_get_tx_pbl_val(struct xgbe_prv_data *pdata)\r\n{\r\nreturn XGMAC_DMA_IOREAD_BITS(pdata->channel, DMA_CH_TCR, PBL);\r\n}\r\nstatic int xgbe_config_tx_pbl_val(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, PBL,\r\npdata->tx_pbl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_get_rx_pbl_val(struct xgbe_prv_data *pdata)\r\n{\r\nreturn XGMAC_DMA_IOREAD_BITS(pdata->channel, DMA_CH_RCR, PBL);\r\n}\r\nstatic int xgbe_config_rx_pbl_val(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, PBL,\r\npdata->rx_pbl);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_osp_mode(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, OSP,\r\npdata->tx_osp_mode);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_rsf_mode(struct xgbe_prv_data *pdata, unsigned int val)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RSF, val);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_tsf_mode(struct xgbe_prv_data *pdata, unsigned int val)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TSF, val);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_rx_threshold(struct xgbe_prv_data *pdata,\r\nunsigned int val)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RTC, val);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_tx_threshold(struct xgbe_prv_data *pdata,\r\nunsigned int val)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TTC, val);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_rx_coalesce(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RIWT, RWT,\r\npdata->rx_riwt);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_tx_coalesce(struct xgbe_prv_data *pdata)\r\n{\r\nreturn 0;\r\n}\r\nstatic void xgbe_config_rx_buffer_size(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, RBSZ,\r\npdata->rx_buf_size);\r\n}\r\n}\r\nstatic void xgbe_config_tso_mode(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, TSE, 1);\r\n}\r\n}\r\nstatic void xgbe_config_sph_mode(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_CR, SPH, 1);\r\n}\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, HDSMS, XGBE_SPH_HDSMS_SIZE);\r\n}\r\nstatic int xgbe_write_rss_reg(struct xgbe_prv_data *pdata, unsigned int type,\r\nunsigned int index, unsigned int val)\r\n{\r\nunsigned int wait;\r\nint ret = 0;\r\nmutex_lock(&pdata->rss_mutex);\r\nif (XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB)) {\r\nret = -EBUSY;\r\ngoto unlock;\r\n}\r\nXGMAC_IOWRITE(pdata, MAC_RSSDR, val);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, RSSIA, index);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, ADDRT, type);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, CT, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RSSAR, OB, 1);\r\nwait = 1000;\r\nwhile (wait--) {\r\nif (!XGMAC_IOREAD_BITS(pdata, MAC_RSSAR, OB))\r\ngoto unlock;\r\nusleep_range(1000, 1500);\r\n}\r\nret = -EBUSY;\r\nunlock:\r\nmutex_unlock(&pdata->rss_mutex);\r\nreturn ret;\r\n}\r\nstatic int xgbe_write_rss_hash_key(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int key_regs = sizeof(pdata->rss_key) / sizeof(u32);\r\nunsigned int *key = (unsigned int *)&pdata->rss_key;\r\nint ret;\r\nwhile (key_regs--) {\r\nret = xgbe_write_rss_reg(pdata, XGBE_RSS_HASH_KEY_TYPE,\r\nkey_regs, *key++);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_write_rss_lookup_table(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int i;\r\nint ret;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++) {\r\nret = xgbe_write_rss_reg(pdata,\r\nXGBE_RSS_LOOKUP_TABLE_TYPE, i,\r\npdata->rss_table[i]);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_rss_hash_key(struct xgbe_prv_data *pdata, const u8 *key)\r\n{\r\nmemcpy(pdata->rss_key, key, sizeof(pdata->rss_key));\r\nreturn xgbe_write_rss_hash_key(pdata);\r\n}\r\nstatic int xgbe_set_rss_lookup_table(struct xgbe_prv_data *pdata,\r\nconst u32 *table)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(pdata->rss_table); i++)\r\nXGMAC_SET_BITS(pdata->rss_table[i], MAC_RSSDR, DMCH, table[i]);\r\nreturn xgbe_write_rss_lookup_table(pdata);\r\n}\r\nstatic int xgbe_enable_rss(struct xgbe_prv_data *pdata)\r\n{\r\nint ret;\r\nif (!pdata->hw_feat.rss)\r\nreturn -EOPNOTSUPP;\r\nret = xgbe_write_rss_hash_key(pdata);\r\nif (ret)\r\nreturn ret;\r\nret = xgbe_write_rss_lookup_table(pdata);\r\nif (ret)\r\nreturn ret;\r\nXGMAC_IOWRITE(pdata, MAC_RSSCR, pdata->rss_options);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 1);\r\nreturn 0;\r\n}\r\nstatic int xgbe_disable_rss(struct xgbe_prv_data *pdata)\r\n{\r\nif (!pdata->hw_feat.rss)\r\nreturn -EOPNOTSUPP;\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RSSCR, RSSE, 0);\r\nreturn 0;\r\n}\r\nstatic void xgbe_config_rss(struct xgbe_prv_data *pdata)\r\n{\r\nint ret;\r\nif (!pdata->hw_feat.rss)\r\nreturn;\r\nif (pdata->netdev->features & NETIF_F_RXHASH)\r\nret = xgbe_enable_rss(pdata);\r\nelse\r\nret = xgbe_disable_rss(pdata);\r\nif (ret)\r\nnetdev_err(pdata->netdev,\r\n"error configuring RSS, RSS disabled\n");\r\n}\r\nstatic bool xgbe_is_pfc_queue(struct xgbe_prv_data *pdata,\r\nunsigned int queue)\r\n{\r\nunsigned int prio, tc;\r\nfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {\r\nif (pdata->prio2q_map[prio] != queue)\r\ncontinue;\r\ntc = pdata->ets->prio_tc[prio];\r\nif (pdata->pfc->pfc_en & (1 << tc))\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int xgbe_disable_tx_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int max_q_count, q_count;\r\nunsigned int reg, reg_val;\r\nunsigned int i;\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, EHFC, 0);\r\nmax_q_count = XGMAC_MAX_FLOW_CONTROL_QUEUES;\r\nq_count = min_t(unsigned int, pdata->tx_q_count, max_q_count);\r\nreg = MAC_Q0TFCR;\r\nfor (i = 0; i < q_count; i++) {\r\nreg_val = XGMAC_IOREAD(pdata, reg);\r\nXGMAC_SET_BITS(reg_val, MAC_Q0TFCR, TFE, 0);\r\nXGMAC_IOWRITE(pdata, reg, reg_val);\r\nreg += MAC_QTFCR_INC;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_enable_tx_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nstruct ieee_pfc *pfc = pdata->pfc;\r\nstruct ieee_ets *ets = pdata->ets;\r\nunsigned int max_q_count, q_count;\r\nunsigned int reg, reg_val;\r\nunsigned int i;\r\nfor (i = 0; i < pdata->rx_q_count; i++) {\r\nunsigned int ehfc = 0;\r\nif (pdata->rx_rfd[i]) {\r\nif (pfc && ets) {\r\nif (xgbe_is_pfc_queue(pdata, i))\r\nehfc = 1;\r\n} else {\r\nehfc = 1;\r\n}\r\n}\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, EHFC, ehfc);\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"flow control %s for RXq%u\n",\r\nehfc ? "enabled" : "disabled", i);\r\n}\r\nmax_q_count = XGMAC_MAX_FLOW_CONTROL_QUEUES;\r\nq_count = min_t(unsigned int, pdata->tx_q_count, max_q_count);\r\nreg = MAC_Q0TFCR;\r\nfor (i = 0; i < q_count; i++) {\r\nreg_val = XGMAC_IOREAD(pdata, reg);\r\nXGMAC_SET_BITS(reg_val, MAC_Q0TFCR, TFE, 1);\r\nXGMAC_SET_BITS(reg_val, MAC_Q0TFCR, PT, 0xffff);\r\nXGMAC_IOWRITE(pdata, reg, reg_val);\r\nreg += MAC_QTFCR_INC;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_disable_rx_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RFCR, RFE, 0);\r\nreturn 0;\r\n}\r\nstatic int xgbe_enable_rx_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RFCR, RFE, 1);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_tx_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nstruct ieee_pfc *pfc = pdata->pfc;\r\nif (pdata->tx_pause || (pfc && pfc->pfc_en))\r\nxgbe_enable_tx_flow_control(pdata);\r\nelse\r\nxgbe_disable_tx_flow_control(pdata);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_rx_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nstruct ieee_pfc *pfc = pdata->pfc;\r\nif (pdata->rx_pause || (pfc && pfc->pfc_en))\r\nxgbe_enable_rx_flow_control(pdata);\r\nelse\r\nxgbe_disable_rx_flow_control(pdata);\r\nreturn 0;\r\n}\r\nstatic void xgbe_config_flow_control(struct xgbe_prv_data *pdata)\r\n{\r\nstruct ieee_pfc *pfc = pdata->pfc;\r\nxgbe_config_tx_flow_control(pdata);\r\nxgbe_config_rx_flow_control(pdata);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RFCR, PFCE,\r\n(pfc && pfc->pfc_en) ? 1 : 0);\r\n}\r\nstatic void xgbe_enable_dma_interrupts(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int dma_ch_isr, dma_ch_ier;\r\nunsigned int i;\r\nif (pdata->channel_irq_mode)\r\nXGMAC_IOWRITE_BITS(pdata, DMA_MR, INTM,\r\npdata->channel_irq_mode);\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\ndma_ch_isr = XGMAC_DMA_IOREAD(channel, DMA_CH_SR);\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_SR, dma_ch_isr);\r\ndma_ch_ier = 0;\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, NIE, 1);\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, AIE, 1);\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, FBEE, 1);\r\nif (channel->tx_ring) {\r\nif (!pdata->per_channel_irq || pdata->channel_irq_mode)\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);\r\n}\r\nif (channel->rx_ring) {\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 1);\r\nif (!pdata->per_channel_irq || pdata->channel_irq_mode)\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);\r\n}\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);\r\n}\r\n}\r\nstatic void xgbe_enable_mtl_interrupts(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int mtl_q_isr;\r\nunsigned int q_count, i;\r\nq_count = max(pdata->hw_feat.tx_q_cnt, pdata->hw_feat.rx_q_cnt);\r\nfor (i = 0; i < q_count; i++) {\r\nmtl_q_isr = XGMAC_MTL_IOREAD(pdata, i, MTL_Q_ISR);\r\nXGMAC_MTL_IOWRITE(pdata, i, MTL_Q_ISR, mtl_q_isr);\r\nXGMAC_MTL_IOWRITE(pdata, i, MTL_Q_IER, 0);\r\n}\r\n}\r\nstatic void xgbe_enable_mac_interrupts(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int mac_ier = 0;\r\nXGMAC_SET_BITS(mac_ier, MAC_IER, TSIE, 1);\r\nXGMAC_IOWRITE(pdata, MAC_IER, mac_ier);\r\nXGMAC_IOWRITE_BITS(pdata, MMC_RIER, ALL_INTERRUPTS, 0xffffffff);\r\nXGMAC_IOWRITE_BITS(pdata, MMC_TIER, ALL_INTERRUPTS, 0xffffffff);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_MDIOIER, SNGLCOMPIE, 1);\r\n}\r\nstatic void xgbe_enable_ecc_interrupts(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int ecc_isr, ecc_ier = 0;\r\nif (!pdata->vdata->ecc_support)\r\nreturn;\r\necc_isr = XP_IOREAD(pdata, XP_ECC_ISR);\r\nXP_IOWRITE(pdata, XP_ECC_ISR, ecc_isr);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_DED, 1);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_SEC, 1);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_DED, 1);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_SEC, 1);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_DED, 1);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_SEC, 1);\r\nXP_IOWRITE(pdata, XP_ECC_IER, ecc_ier);\r\n}\r\nstatic void xgbe_disable_ecc_ded(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int ecc_ier;\r\necc_ier = XP_IOREAD(pdata, XP_ECC_IER);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_DED, 0);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_DED, 0);\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_DED, 0);\r\nXP_IOWRITE(pdata, XP_ECC_IER, ecc_ier);\r\n}\r\nstatic void xgbe_disable_ecc_sec(struct xgbe_prv_data *pdata,\r\nenum xgbe_ecc_sec sec)\r\n{\r\nunsigned int ecc_ier;\r\necc_ier = XP_IOREAD(pdata, XP_ECC_IER);\r\nswitch (sec) {\r\ncase XGBE_ECC_SEC_TX:\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, TX_SEC, 0);\r\nbreak;\r\ncase XGBE_ECC_SEC_RX:\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, RX_SEC, 0);\r\nbreak;\r\ncase XGBE_ECC_SEC_DESC:\r\nXP_SET_BITS(ecc_ier, XP_ECC_IER, DESC_SEC, 0);\r\nbreak;\r\n}\r\nXP_IOWRITE(pdata, XP_ECC_IER, ecc_ier);\r\n}\r\nstatic int xgbe_set_speed(struct xgbe_prv_data *pdata, int speed)\r\n{\r\nunsigned int ss;\r\nswitch (speed) {\r\ncase SPEED_1000:\r\nss = 0x03;\r\nbreak;\r\ncase SPEED_2500:\r\nss = 0x02;\r\nbreak;\r\ncase SPEED_10000:\r\nss = 0x00;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nif (XGMAC_IOREAD_BITS(pdata, MAC_TCR, SS) != ss)\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TCR, SS, ss);\r\nreturn 0;\r\n}\r\nstatic int xgbe_enable_rx_vlan_stripping(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLRXS, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, DOVLTC, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ERSVLM, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ESVL, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLS, 0x3);\r\nreturn 0;\r\n}\r\nstatic int xgbe_disable_rx_vlan_stripping(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, EVLS, 0);\r\nreturn 0;\r\n}\r\nstatic int xgbe_enable_rx_vlan_filtering(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, VTFE, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VTHM, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VTIM, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, ETV, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANTR, VL, 1);\r\nreturn 0;\r\n}\r\nstatic int xgbe_disable_rx_vlan_filtering(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, VTFE, 0);\r\nreturn 0;\r\n}\r\nstatic u32 xgbe_vid_crc32_le(__le16 vid_le)\r\n{\r\nu32 poly = 0xedb88320;\r\nu32 crc = ~0;\r\nu32 temp = 0;\r\nunsigned char *data = (unsigned char *)&vid_le;\r\nunsigned char data_byte = 0;\r\nint i, bits;\r\nbits = get_bitmask_order(VLAN_VID_MASK);\r\nfor (i = 0; i < bits; i++) {\r\nif ((i % 8) == 0)\r\ndata_byte = data[i / 8];\r\ntemp = ((crc & 1) ^ data_byte) & 1;\r\ncrc >>= 1;\r\ndata_byte >>= 1;\r\nif (temp)\r\ncrc ^= poly;\r\n}\r\nreturn crc;\r\n}\r\nstatic int xgbe_update_vlan_hash_table(struct xgbe_prv_data *pdata)\r\n{\r\nu32 crc;\r\nu16 vid;\r\n__le16 vid_le;\r\nu16 vlan_hash_table = 0;\r\nfor_each_set_bit(vid, pdata->active_vlans, VLAN_N_VID) {\r\nvid_le = cpu_to_le16(vid);\r\ncrc = bitrev32(~xgbe_vid_crc32_le(vid_le)) >> 28;\r\nvlan_hash_table |= (1 << crc);\r\n}\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANHTR, VLHT, vlan_hash_table);\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_promiscuous_mode(struct xgbe_prv_data *pdata,\r\nunsigned int enable)\r\n{\r\nunsigned int val = enable ? 1 : 0;\r\nif (XGMAC_IOREAD_BITS(pdata, MAC_PFR, PR) == val)\r\nreturn 0;\r\nnetif_dbg(pdata, drv, pdata->netdev, "%s promiscuous mode\n",\r\nenable ? "entering" : "leaving");\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, PR, val);\r\nif (enable) {\r\nxgbe_disable_rx_vlan_filtering(pdata);\r\n} else {\r\nif (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\r\nxgbe_enable_rx_vlan_filtering(pdata);\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_all_multicast_mode(struct xgbe_prv_data *pdata,\r\nunsigned int enable)\r\n{\r\nunsigned int val = enable ? 1 : 0;\r\nif (XGMAC_IOREAD_BITS(pdata, MAC_PFR, PM) == val)\r\nreturn 0;\r\nnetif_dbg(pdata, drv, pdata->netdev, "%s allmulti mode\n",\r\nenable ? "entering" : "leaving");\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, PM, val);\r\nreturn 0;\r\n}\r\nstatic void xgbe_set_mac_reg(struct xgbe_prv_data *pdata,\r\nstruct netdev_hw_addr *ha, unsigned int *mac_reg)\r\n{\r\nunsigned int mac_addr_hi, mac_addr_lo;\r\nu8 *mac_addr;\r\nmac_addr_lo = 0;\r\nmac_addr_hi = 0;\r\nif (ha) {\r\nmac_addr = (u8 *)&mac_addr_lo;\r\nmac_addr[0] = ha->addr[0];\r\nmac_addr[1] = ha->addr[1];\r\nmac_addr[2] = ha->addr[2];\r\nmac_addr[3] = ha->addr[3];\r\nmac_addr = (u8 *)&mac_addr_hi;\r\nmac_addr[0] = ha->addr[4];\r\nmac_addr[1] = ha->addr[5];\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"adding mac address %pM at %#x\n",\r\nha->addr, *mac_reg);\r\nXGMAC_SET_BITS(mac_addr_hi, MAC_MACA1HR, AE, 1);\r\n}\r\nXGMAC_IOWRITE(pdata, *mac_reg, mac_addr_hi);\r\n*mac_reg += MAC_MACA_INC;\r\nXGMAC_IOWRITE(pdata, *mac_reg, mac_addr_lo);\r\n*mac_reg += MAC_MACA_INC;\r\n}\r\nstatic void xgbe_set_mac_addn_addrs(struct xgbe_prv_data *pdata)\r\n{\r\nstruct net_device *netdev = pdata->netdev;\r\nstruct netdev_hw_addr *ha;\r\nunsigned int mac_reg;\r\nunsigned int addn_macs;\r\nmac_reg = MAC_MACA1HR;\r\naddn_macs = pdata->hw_feat.addn_mac;\r\nif (netdev_uc_count(netdev) > addn_macs) {\r\nxgbe_set_promiscuous_mode(pdata, 1);\r\n} else {\r\nnetdev_for_each_uc_addr(ha, netdev) {\r\nxgbe_set_mac_reg(pdata, ha, &mac_reg);\r\naddn_macs--;\r\n}\r\nif (netdev_mc_count(netdev) > addn_macs) {\r\nxgbe_set_all_multicast_mode(pdata, 1);\r\n} else {\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nxgbe_set_mac_reg(pdata, ha, &mac_reg);\r\naddn_macs--;\r\n}\r\n}\r\n}\r\nwhile (addn_macs--)\r\nxgbe_set_mac_reg(pdata, NULL, &mac_reg);\r\n}\r\nstatic void xgbe_set_mac_hash_table(struct xgbe_prv_data *pdata)\r\n{\r\nstruct net_device *netdev = pdata->netdev;\r\nstruct netdev_hw_addr *ha;\r\nunsigned int hash_reg;\r\nunsigned int hash_table_shift, hash_table_count;\r\nu32 hash_table[XGBE_MAC_HASH_TABLE_SIZE];\r\nu32 crc;\r\nunsigned int i;\r\nhash_table_shift = 26 - (pdata->hw_feat.hash_table_size >> 7);\r\nhash_table_count = pdata->hw_feat.hash_table_size / 32;\r\nmemset(hash_table, 0, sizeof(hash_table));\r\nnetdev_for_each_uc_addr(ha, netdev) {\r\ncrc = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN));\r\ncrc >>= hash_table_shift;\r\nhash_table[crc >> 5] |= (1 << (crc & 0x1f));\r\n}\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\ncrc = bitrev32(~crc32_le(~0, ha->addr, ETH_ALEN));\r\ncrc >>= hash_table_shift;\r\nhash_table[crc >> 5] |= (1 << (crc & 0x1f));\r\n}\r\nhash_reg = MAC_HTR0;\r\nfor (i = 0; i < hash_table_count; i++) {\r\nXGMAC_IOWRITE(pdata, hash_reg, hash_table[i]);\r\nhash_reg += MAC_HTR_INC;\r\n}\r\n}\r\nstatic int xgbe_add_mac_addresses(struct xgbe_prv_data *pdata)\r\n{\r\nif (pdata->hw_feat.hash_table_size)\r\nxgbe_set_mac_hash_table(pdata);\r\nelse\r\nxgbe_set_mac_addn_addrs(pdata);\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_mac_address(struct xgbe_prv_data *pdata, u8 *addr)\r\n{\r\nunsigned int mac_addr_hi, mac_addr_lo;\r\nmac_addr_hi = (addr[5] << 8) | (addr[4] << 0);\r\nmac_addr_lo = (addr[3] << 24) | (addr[2] << 16) |\r\n(addr[1] << 8) | (addr[0] << 0);\r\nXGMAC_IOWRITE(pdata, MAC_MACA0HR, mac_addr_hi);\r\nXGMAC_IOWRITE(pdata, MAC_MACA0LR, mac_addr_lo);\r\nreturn 0;\r\n}\r\nstatic int xgbe_config_rx_mode(struct xgbe_prv_data *pdata)\r\n{\r\nstruct net_device *netdev = pdata->netdev;\r\nunsigned int pr_mode, am_mode;\r\npr_mode = ((netdev->flags & IFF_PROMISC) != 0);\r\nam_mode = ((netdev->flags & IFF_ALLMULTI) != 0);\r\nxgbe_set_promiscuous_mode(pdata, pr_mode);\r\nxgbe_set_all_multicast_mode(pdata, am_mode);\r\nxgbe_add_mac_addresses(pdata);\r\nreturn 0;\r\n}\r\nstatic int xgbe_clr_gpio(struct xgbe_prv_data *pdata, unsigned int gpio)\r\n{\r\nunsigned int reg;\r\nif (gpio > 15)\r\nreturn -EINVAL;\r\nreg = XGMAC_IOREAD(pdata, MAC_GPIOSR);\r\nreg &= ~(1 << (gpio + 16));\r\nXGMAC_IOWRITE(pdata, MAC_GPIOSR, reg);\r\nreturn 0;\r\n}\r\nstatic int xgbe_set_gpio(struct xgbe_prv_data *pdata, unsigned int gpio)\r\n{\r\nunsigned int reg;\r\nif (gpio > 15)\r\nreturn -EINVAL;\r\nreg = XGMAC_IOREAD(pdata, MAC_GPIOSR);\r\nreg |= (1 << (gpio + 16));\r\nXGMAC_IOWRITE(pdata, MAC_GPIOSR, reg);\r\nreturn 0;\r\n}\r\nstatic int xgbe_read_mmd_regs_v2(struct xgbe_prv_data *pdata, int prtad,\r\nint mmd_reg)\r\n{\r\nunsigned long flags;\r\nunsigned int mmd_address, index, offset;\r\nint mmd_data;\r\nif (mmd_reg & MII_ADDR_C45)\r\nmmd_address = mmd_reg & ~MII_ADDR_C45;\r\nelse\r\nmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\r\nmmd_address <<= 1;\r\nindex = mmd_address & ~pdata->xpcs_window_mask;\r\noffset = pdata->xpcs_window + (mmd_address & pdata->xpcs_window_mask);\r\nspin_lock_irqsave(&pdata->xpcs_lock, flags);\r\nXPCS32_IOWRITE(pdata, pdata->xpcs_window_sel_reg, index);\r\nmmd_data = XPCS16_IOREAD(pdata, offset);\r\nspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\r\nreturn mmd_data;\r\n}\r\nstatic void xgbe_write_mmd_regs_v2(struct xgbe_prv_data *pdata, int prtad,\r\nint mmd_reg, int mmd_data)\r\n{\r\nunsigned long flags;\r\nunsigned int mmd_address, index, offset;\r\nif (mmd_reg & MII_ADDR_C45)\r\nmmd_address = mmd_reg & ~MII_ADDR_C45;\r\nelse\r\nmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\r\nmmd_address <<= 1;\r\nindex = mmd_address & ~pdata->xpcs_window_mask;\r\noffset = pdata->xpcs_window + (mmd_address & pdata->xpcs_window_mask);\r\nspin_lock_irqsave(&pdata->xpcs_lock, flags);\r\nXPCS32_IOWRITE(pdata, pdata->xpcs_window_sel_reg, index);\r\nXPCS16_IOWRITE(pdata, offset, mmd_data);\r\nspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\r\n}\r\nstatic int xgbe_read_mmd_regs_v1(struct xgbe_prv_data *pdata, int prtad,\r\nint mmd_reg)\r\n{\r\nunsigned long flags;\r\nunsigned int mmd_address;\r\nint mmd_data;\r\nif (mmd_reg & MII_ADDR_C45)\r\nmmd_address = mmd_reg & ~MII_ADDR_C45;\r\nelse\r\nmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\r\nspin_lock_irqsave(&pdata->xpcs_lock, flags);\r\nXPCS32_IOWRITE(pdata, PCS_V1_WINDOW_SELECT, mmd_address >> 8);\r\nmmd_data = XPCS32_IOREAD(pdata, (mmd_address & 0xff) << 2);\r\nspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\r\nreturn mmd_data;\r\n}\r\nstatic void xgbe_write_mmd_regs_v1(struct xgbe_prv_data *pdata, int prtad,\r\nint mmd_reg, int mmd_data)\r\n{\r\nunsigned int mmd_address;\r\nunsigned long flags;\r\nif (mmd_reg & MII_ADDR_C45)\r\nmmd_address = mmd_reg & ~MII_ADDR_C45;\r\nelse\r\nmmd_address = (pdata->mdio_mmd << 16) | (mmd_reg & 0xffff);\r\nspin_lock_irqsave(&pdata->xpcs_lock, flags);\r\nXPCS32_IOWRITE(pdata, PCS_V1_WINDOW_SELECT, mmd_address >> 8);\r\nXPCS32_IOWRITE(pdata, (mmd_address & 0xff) << 2, mmd_data);\r\nspin_unlock_irqrestore(&pdata->xpcs_lock, flags);\r\n}\r\nstatic int xgbe_read_mmd_regs(struct xgbe_prv_data *pdata, int prtad,\r\nint mmd_reg)\r\n{\r\nswitch (pdata->vdata->xpcs_access) {\r\ncase XGBE_XPCS_ACCESS_V1:\r\nreturn xgbe_read_mmd_regs_v1(pdata, prtad, mmd_reg);\r\ncase XGBE_XPCS_ACCESS_V2:\r\ndefault:\r\nreturn xgbe_read_mmd_regs_v2(pdata, prtad, mmd_reg);\r\n}\r\n}\r\nstatic void xgbe_write_mmd_regs(struct xgbe_prv_data *pdata, int prtad,\r\nint mmd_reg, int mmd_data)\r\n{\r\nswitch (pdata->vdata->xpcs_access) {\r\ncase XGBE_XPCS_ACCESS_V1:\r\nreturn xgbe_write_mmd_regs_v1(pdata, prtad, mmd_reg, mmd_data);\r\ncase XGBE_XPCS_ACCESS_V2:\r\ndefault:\r\nreturn xgbe_write_mmd_regs_v2(pdata, prtad, mmd_reg, mmd_data);\r\n}\r\n}\r\nstatic int xgbe_write_ext_mii_regs(struct xgbe_prv_data *pdata, int addr,\r\nint reg, u16 val)\r\n{\r\nunsigned int mdio_sca, mdio_sccd;\r\nreinit_completion(&pdata->mdio_complete);\r\nmdio_sca = 0;\r\nXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, REG, reg);\r\nXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, DA, addr);\r\nXGMAC_IOWRITE(pdata, MAC_MDIOSCAR, mdio_sca);\r\nmdio_sccd = 0;\r\nXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, DATA, val);\r\nXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, CMD, 1);\r\nXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, BUSY, 1);\r\nXGMAC_IOWRITE(pdata, MAC_MDIOSCCDR, mdio_sccd);\r\nif (!wait_for_completion_timeout(&pdata->mdio_complete, HZ)) {\r\nnetdev_err(pdata->netdev, "mdio write operation timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int xgbe_read_ext_mii_regs(struct xgbe_prv_data *pdata, int addr,\r\nint reg)\r\n{\r\nunsigned int mdio_sca, mdio_sccd;\r\nreinit_completion(&pdata->mdio_complete);\r\nmdio_sca = 0;\r\nXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, REG, reg);\r\nXGMAC_SET_BITS(mdio_sca, MAC_MDIOSCAR, DA, addr);\r\nXGMAC_IOWRITE(pdata, MAC_MDIOSCAR, mdio_sca);\r\nmdio_sccd = 0;\r\nXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, CMD, 3);\r\nXGMAC_SET_BITS(mdio_sccd, MAC_MDIOSCCDR, BUSY, 1);\r\nXGMAC_IOWRITE(pdata, MAC_MDIOSCCDR, mdio_sccd);\r\nif (!wait_for_completion_timeout(&pdata->mdio_complete, HZ)) {\r\nnetdev_err(pdata->netdev, "mdio read operation timed out\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn XGMAC_IOREAD_BITS(pdata, MAC_MDIOSCCDR, DATA);\r\n}\r\nstatic int xgbe_set_ext_mii_mode(struct xgbe_prv_data *pdata, unsigned int port,\r\nenum xgbe_mdio_mode mode)\r\n{\r\nunsigned int reg_val = XGMAC_IOREAD(pdata, MAC_MDIOCL22R);\r\nswitch (mode) {\r\ncase XGBE_MDIO_MODE_CL22:\r\nif (port > XGMAC_MAX_C22_PORT)\r\nreturn -EINVAL;\r\nreg_val |= (1 << port);\r\nbreak;\r\ncase XGBE_MDIO_MODE_CL45:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nXGMAC_IOWRITE(pdata, MAC_MDIOCL22R, reg_val);\r\nreturn 0;\r\n}\r\nstatic int xgbe_tx_complete(struct xgbe_ring_desc *rdesc)\r\n{\r\nreturn !XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN);\r\n}\r\nstatic int xgbe_disable_rx_csum(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, IPC, 0);\r\nreturn 0;\r\n}\r\nstatic int xgbe_enable_rx_csum(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, IPC, 1);\r\nreturn 0;\r\n}\r\nstatic void xgbe_tx_desc_reset(struct xgbe_ring_data *rdata)\r\n{\r\nstruct xgbe_ring_desc *rdesc = rdata->rdesc;\r\nrdesc->desc0 = 0;\r\nrdesc->desc1 = 0;\r\nrdesc->desc2 = 0;\r\nrdesc->desc3 = 0;\r\ndma_wmb();\r\n}\r\nstatic void xgbe_tx_desc_init(struct xgbe_channel *channel)\r\n{\r\nstruct xgbe_ring *ring = channel->tx_ring;\r\nstruct xgbe_ring_data *rdata;\r\nint i;\r\nint start_index = ring->cur;\r\nDBGPR("-->tx_desc_init\n");\r\nfor (i = 0; i < ring->rdesc_count; i++) {\r\nrdata = XGBE_GET_DESC_DATA(ring, i);\r\nxgbe_tx_desc_reset(rdata);\r\n}\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_TDRLR, ring->rdesc_count - 1);\r\nrdata = XGBE_GET_DESC_DATA(ring, start_index);\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_TDLR_HI,\r\nupper_32_bits(rdata->rdesc_dma));\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_TDLR_LO,\r\nlower_32_bits(rdata->rdesc_dma));\r\nDBGPR("<--tx_desc_init\n");\r\n}\r\nstatic void xgbe_rx_desc_reset(struct xgbe_prv_data *pdata,\r\nstruct xgbe_ring_data *rdata, unsigned int index)\r\n{\r\nstruct xgbe_ring_desc *rdesc = rdata->rdesc;\r\nunsigned int rx_usecs = pdata->rx_usecs;\r\nunsigned int rx_frames = pdata->rx_frames;\r\nunsigned int inte;\r\ndma_addr_t hdr_dma, buf_dma;\r\nif (!rx_usecs && !rx_frames) {\r\ninte = 1;\r\n} else {\r\nif (rx_frames && !((index + 1) % rx_frames))\r\ninte = 1;\r\nelse\r\ninte = 0;\r\n}\r\nhdr_dma = rdata->rx.hdr.dma_base + rdata->rx.hdr.dma_off;\r\nbuf_dma = rdata->rx.buf.dma_base + rdata->rx.buf.dma_off;\r\nrdesc->desc0 = cpu_to_le32(lower_32_bits(hdr_dma));\r\nrdesc->desc1 = cpu_to_le32(upper_32_bits(hdr_dma));\r\nrdesc->desc2 = cpu_to_le32(lower_32_bits(buf_dma));\r\nrdesc->desc3 = cpu_to_le32(upper_32_bits(buf_dma));\r\nXGMAC_SET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, INTE, inte);\r\ndma_wmb();\r\nXGMAC_SET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, OWN, 1);\r\ndma_wmb();\r\n}\r\nstatic void xgbe_rx_desc_init(struct xgbe_channel *channel)\r\n{\r\nstruct xgbe_prv_data *pdata = channel->pdata;\r\nstruct xgbe_ring *ring = channel->rx_ring;\r\nstruct xgbe_ring_data *rdata;\r\nunsigned int start_index = ring->cur;\r\nunsigned int i;\r\nDBGPR("-->rx_desc_init\n");\r\nfor (i = 0; i < ring->rdesc_count; i++) {\r\nrdata = XGBE_GET_DESC_DATA(ring, i);\r\nxgbe_rx_desc_reset(pdata, rdata, i);\r\n}\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_RDRLR, ring->rdesc_count - 1);\r\nrdata = XGBE_GET_DESC_DATA(ring, start_index);\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_RDLR_HI,\r\nupper_32_bits(rdata->rdesc_dma));\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_RDLR_LO,\r\nlower_32_bits(rdata->rdesc_dma));\r\nrdata = XGBE_GET_DESC_DATA(ring, start_index + ring->rdesc_count - 1);\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_RDTR_LO,\r\nlower_32_bits(rdata->rdesc_dma));\r\nDBGPR("<--rx_desc_init\n");\r\n}\r\nstatic void xgbe_update_tstamp_addend(struct xgbe_prv_data *pdata,\r\nunsigned int addend)\r\n{\r\nXGMAC_IOWRITE(pdata, MAC_TSAR, addend);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TSCR, TSADDREG, 1);\r\nwhile (XGMAC_IOREAD_BITS(pdata, MAC_TSCR, TSADDREG))\r\nudelay(5);\r\n}\r\nstatic void xgbe_set_tstamp_time(struct xgbe_prv_data *pdata, unsigned int sec,\r\nunsigned int nsec)\r\n{\r\nXGMAC_IOWRITE(pdata, MAC_STSUR, sec);\r\nXGMAC_IOWRITE(pdata, MAC_STNUR, nsec);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TSCR, TSINIT, 1);\r\nwhile (XGMAC_IOREAD_BITS(pdata, MAC_TSCR, TSINIT))\r\nudelay(5);\r\n}\r\nstatic u64 xgbe_get_tstamp_time(struct xgbe_prv_data *pdata)\r\n{\r\nu64 nsec;\r\nnsec = XGMAC_IOREAD(pdata, MAC_STSR);\r\nnsec *= NSEC_PER_SEC;\r\nnsec += XGMAC_IOREAD(pdata, MAC_STNR);\r\nreturn nsec;\r\n}\r\nstatic u64 xgbe_get_tx_tstamp(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int tx_snr, tx_ssr;\r\nu64 nsec;\r\nif (pdata->vdata->tx_tstamp_workaround) {\r\ntx_snr = XGMAC_IOREAD(pdata, MAC_TXSNR);\r\ntx_ssr = XGMAC_IOREAD(pdata, MAC_TXSSR);\r\n} else {\r\ntx_ssr = XGMAC_IOREAD(pdata, MAC_TXSSR);\r\ntx_snr = XGMAC_IOREAD(pdata, MAC_TXSNR);\r\n}\r\nif (XGMAC_GET_BITS(tx_snr, MAC_TXSNR, TXTSSTSMIS))\r\nreturn 0;\r\nnsec = tx_ssr;\r\nnsec *= NSEC_PER_SEC;\r\nnsec += tx_snr;\r\nreturn nsec;\r\n}\r\nstatic void xgbe_get_rx_tstamp(struct xgbe_packet_data *packet,\r\nstruct xgbe_ring_desc *rdesc)\r\n{\r\nu64 nsec;\r\nif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_CONTEXT_DESC3, TSA) &&\r\n!XGMAC_GET_BITS_LE(rdesc->desc3, RX_CONTEXT_DESC3, TSD)) {\r\nnsec = le32_to_cpu(rdesc->desc1);\r\nnsec <<= 32;\r\nnsec |= le32_to_cpu(rdesc->desc0);\r\nif (nsec != 0xffffffffffffffffULL) {\r\npacket->rx_tstamp = nsec;\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nRX_TSTAMP, 1);\r\n}\r\n}\r\n}\r\nstatic int xgbe_config_tstamp(struct xgbe_prv_data *pdata,\r\nunsigned int mac_tscr)\r\n{\r\nXGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSCTRLSSR, 1);\r\nXGMAC_SET_BITS(mac_tscr, MAC_TSCR, TSCFUPDT, 1);\r\nXGMAC_SET_BITS(mac_tscr, MAC_TSCR, TXTSSTSM, 1);\r\nXGMAC_IOWRITE(pdata, MAC_TSCR, mac_tscr);\r\nif (!XGMAC_GET_BITS(mac_tscr, MAC_TSCR, TSENA))\r\nreturn 0;\r\nXGMAC_IOWRITE_BITS(pdata, MAC_SSIR, SSINC, XGBE_TSTAMP_SSINC);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_SSIR, SNSINC, XGBE_TSTAMP_SNSINC);\r\nxgbe_update_tstamp_addend(pdata, pdata->tstamp_addend);\r\nxgbe_set_tstamp_time(pdata, 0, 0);\r\ntimecounter_init(&pdata->tstamp_tc, &pdata->tstamp_cc,\r\nktime_to_ns(ktime_get_real()));\r\nreturn 0;\r\n}\r\nstatic void xgbe_tx_start_xmit(struct xgbe_channel *channel,\r\nstruct xgbe_ring *ring)\r\n{\r\nstruct xgbe_prv_data *pdata = channel->pdata;\r\nstruct xgbe_ring_data *rdata;\r\nwmb();\r\nrdata = XGBE_GET_DESC_DATA(ring, ring->cur);\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_TDTR_LO,\r\nlower_32_bits(rdata->rdesc_dma));\r\nif (pdata->tx_usecs && !channel->tx_timer_active) {\r\nchannel->tx_timer_active = 1;\r\nmod_timer(&channel->tx_timer,\r\njiffies + usecs_to_jiffies(pdata->tx_usecs));\r\n}\r\nring->tx.xmit_more = 0;\r\n}\r\nstatic void xgbe_dev_xmit(struct xgbe_channel *channel)\r\n{\r\nstruct xgbe_prv_data *pdata = channel->pdata;\r\nstruct xgbe_ring *ring = channel->tx_ring;\r\nstruct xgbe_ring_data *rdata;\r\nstruct xgbe_ring_desc *rdesc;\r\nstruct xgbe_packet_data *packet = &ring->packet_data;\r\nunsigned int csum, tso, vlan;\r\nunsigned int tso_context, vlan_context;\r\nunsigned int tx_set_ic;\r\nint start_index = ring->cur;\r\nint cur_index = ring->cur;\r\nint i;\r\nDBGPR("-->xgbe_dev_xmit\n");\r\ncsum = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\r\nCSUM_ENABLE);\r\ntso = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\r\nTSO_ENABLE);\r\nvlan = XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES,\r\nVLAN_CTAG);\r\nif (tso && (packet->mss != ring->tx.cur_mss))\r\ntso_context = 1;\r\nelse\r\ntso_context = 0;\r\nif (vlan && (packet->vlan_ctag != ring->tx.cur_vlan_ctag))\r\nvlan_context = 1;\r\nelse\r\nvlan_context = 0;\r\nring->coalesce_count += packet->tx_packets;\r\nif (!pdata->tx_frames)\r\ntx_set_ic = 0;\r\nelse if (packet->tx_packets > pdata->tx_frames)\r\ntx_set_ic = 1;\r\nelse if ((ring->coalesce_count % pdata->tx_frames) <\r\npacket->tx_packets)\r\ntx_set_ic = 1;\r\nelse\r\ntx_set_ic = 0;\r\nrdata = XGBE_GET_DESC_DATA(ring, cur_index);\r\nrdesc = rdata->rdesc;\r\nif (tso_context || vlan_context) {\r\nif (tso_context) {\r\nnetif_dbg(pdata, tx_queued, pdata->netdev,\r\n"TSO context descriptor, mss=%u\n",\r\npacket->mss);\r\nXGMAC_SET_BITS_LE(rdesc->desc2, TX_CONTEXT_DESC2,\r\nMSS, packet->mss);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\r\nCTXT, 1);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\r\nTCMSSV, 1);\r\nring->tx.cur_mss = packet->mss;\r\n}\r\nif (vlan_context) {\r\nnetif_dbg(pdata, tx_queued, pdata->netdev,\r\n"VLAN context descriptor, ctag=%u\n",\r\npacket->vlan_ctag);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\r\nCTXT, 1);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\r\nVT, packet->vlan_ctag);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_CONTEXT_DESC3,\r\nVLTV, 1);\r\nring->tx.cur_vlan_ctag = packet->vlan_ctag;\r\n}\r\ncur_index++;\r\nrdata = XGBE_GET_DESC_DATA(ring, cur_index);\r\nrdesc = rdata->rdesc;\r\n}\r\nrdesc->desc0 = cpu_to_le32(lower_32_bits(rdata->skb_dma));\r\nrdesc->desc1 = cpu_to_le32(upper_32_bits(rdata->skb_dma));\r\nXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, HL_B1L,\r\nrdata->skb_dma_len);\r\nif (vlan)\r\nXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, VTIR,\r\nTX_NORMAL_DESC2_VLAN_INSERT);\r\nif (XGMAC_GET_BITS(packet->attributes, TX_PACKET_ATTRIBUTES, PTP))\r\nXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, TTSE, 1);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, FD, 1);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT, 0);\r\nif (cur_index != start_index)\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);\r\nif (tso) {\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TSE, 1);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TCPPL,\r\npacket->tcp_payload_len);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, TCPHDRLEN,\r\npacket->tcp_header_len / 4);\r\npdata->ext_stats.tx_tso_packets++;\r\n} else {\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CPC, 0);\r\nif (csum)\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3,\r\nCIC, 0x3);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, FL,\r\npacket->length);\r\n}\r\nfor (i = cur_index - start_index + 1; i < packet->rdesc_count; i++) {\r\ncur_index++;\r\nrdata = XGBE_GET_DESC_DATA(ring, cur_index);\r\nrdesc = rdata->rdesc;\r\nrdesc->desc0 = cpu_to_le32(lower_32_bits(rdata->skb_dma));\r\nrdesc->desc1 = cpu_to_le32(upper_32_bits(rdata->skb_dma));\r\nXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, HL_B1L,\r\nrdata->skb_dma_len);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT, 0);\r\nif (csum)\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3,\r\nCIC, 0x3);\r\n}\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, LD, 1);\r\nif (tx_set_ic)\r\nXGMAC_SET_BITS_LE(rdesc->desc2, TX_NORMAL_DESC2, IC, 1);\r\nrdata->tx.packets = packet->tx_packets;\r\nrdata->tx.bytes = packet->tx_bytes;\r\ndma_wmb();\r\nrdata = XGBE_GET_DESC_DATA(ring, start_index);\r\nrdesc = rdata->rdesc;\r\nXGMAC_SET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, OWN, 1);\r\nif (netif_msg_tx_queued(pdata))\r\nxgbe_dump_tx_desc(pdata, ring, start_index,\r\npacket->rdesc_count, 1);\r\nsmp_wmb();\r\nring->cur = cur_index + 1;\r\nif (!packet->skb->xmit_more ||\r\nnetif_xmit_stopped(netdev_get_tx_queue(pdata->netdev,\r\nchannel->queue_index)))\r\nxgbe_tx_start_xmit(channel, ring);\r\nelse\r\nring->tx.xmit_more = 1;\r\nDBGPR(" %s: descriptors %u to %u written\n",\r\nchannel->name, start_index & (ring->rdesc_count - 1),\r\n(ring->cur - 1) & (ring->rdesc_count - 1));\r\nDBGPR("<--xgbe_dev_xmit\n");\r\n}\r\nstatic int xgbe_dev_read(struct xgbe_channel *channel)\r\n{\r\nstruct xgbe_prv_data *pdata = channel->pdata;\r\nstruct xgbe_ring *ring = channel->rx_ring;\r\nstruct xgbe_ring_data *rdata;\r\nstruct xgbe_ring_desc *rdesc;\r\nstruct xgbe_packet_data *packet = &ring->packet_data;\r\nstruct net_device *netdev = pdata->netdev;\r\nunsigned int err, etlt, l34t;\r\nDBGPR("-->xgbe_dev_read: cur = %d\n", ring->cur);\r\nrdata = XGBE_GET_DESC_DATA(ring, ring->cur);\r\nrdesc = rdata->rdesc;\r\nif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, OWN))\r\nreturn 1;\r\ndma_rmb();\r\nif (netif_msg_rx_status(pdata))\r\nxgbe_dump_rx_desc(pdata, ring, ring->cur);\r\nif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CTXT)) {\r\nxgbe_get_rx_tstamp(packet, rdesc);\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nCONTEXT, 1);\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nCONTEXT_NEXT, 0);\r\nreturn 0;\r\n}\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES, CONTEXT, 0);\r\nif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, CDA))\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nCONTEXT_NEXT, 1);\r\nif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, FD)) {\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nFIRST, 1);\r\nrdata->rx.hdr_len = XGMAC_GET_BITS_LE(rdesc->desc2,\r\nRX_NORMAL_DESC2, HL);\r\nif (rdata->rx.hdr_len)\r\npdata->ext_stats.rx_split_header_packets++;\r\n} else {\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nFIRST, 0);\r\n}\r\nif (XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, RSV)) {\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nRSS_HASH, 1);\r\npacket->rss_hash = le32_to_cpu(rdesc->desc1);\r\nl34t = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, L34T);\r\nswitch (l34t) {\r\ncase RX_DESC3_L34T_IPV4_TCP:\r\ncase RX_DESC3_L34T_IPV4_UDP:\r\ncase RX_DESC3_L34T_IPV6_TCP:\r\ncase RX_DESC3_L34T_IPV6_UDP:\r\npacket->rss_hash_type = PKT_HASH_TYPE_L4;\r\nbreak;\r\ndefault:\r\npacket->rss_hash_type = PKT_HASH_TYPE_L3;\r\n}\r\n}\r\nif (!XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, LD))\r\nreturn 0;\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nLAST, 1);\r\nrdata->rx.len = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, PL);\r\nif (netdev->features & NETIF_F_RXCSUM)\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nCSUM_DONE, 1);\r\nerr = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, ES);\r\netlt = XGMAC_GET_BITS_LE(rdesc->desc3, RX_NORMAL_DESC3, ETLT);\r\nnetif_dbg(pdata, rx_status, netdev, "err=%u, etlt=%#x\n", err, etlt);\r\nif (!err || !etlt) {\r\nif ((etlt == 0x09) &&\r\n(netdev->features & NETIF_F_HW_VLAN_CTAG_RX)) {\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nVLAN_CTAG, 1);\r\npacket->vlan_ctag = XGMAC_GET_BITS_LE(rdesc->desc0,\r\nRX_NORMAL_DESC0,\r\nOVT);\r\nnetif_dbg(pdata, rx_status, netdev, "vlan-ctag=%#06x\n",\r\npacket->vlan_ctag);\r\n}\r\n} else {\r\nif ((etlt == 0x05) || (etlt == 0x06))\r\nXGMAC_SET_BITS(packet->attributes, RX_PACKET_ATTRIBUTES,\r\nCSUM_DONE, 0);\r\nelse\r\nXGMAC_SET_BITS(packet->errors, RX_PACKET_ERRORS,\r\nFRAME, 1);\r\n}\r\nDBGPR("<--xgbe_dev_read: %s - descriptor=%u (cur=%d)\n", channel->name,\r\nring->cur & (ring->rdesc_count - 1), ring->cur);\r\nreturn 0;\r\n}\r\nstatic int xgbe_is_context_desc(struct xgbe_ring_desc *rdesc)\r\n{\r\nreturn XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, CTXT);\r\n}\r\nstatic int xgbe_is_last_desc(struct xgbe_ring_desc *rdesc)\r\n{\r\nreturn XGMAC_GET_BITS_LE(rdesc->desc3, TX_NORMAL_DESC3, LD);\r\n}\r\nstatic int xgbe_enable_int(struct xgbe_channel *channel,\r\nenum xgbe_int int_id)\r\n{\r\nunsigned int dma_ch_ier;\r\ndma_ch_ier = XGMAC_DMA_IOREAD(channel, DMA_CH_IER);\r\nswitch (int_id) {\r\ncase XGMAC_INT_DMA_CH_SR_TI:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_TPS:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TXSE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_TBU:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TBUE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_RI:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_RBU:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_RPS:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RSE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_TI_RI:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 1);\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_FBE:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, FBEE, 1);\r\nbreak;\r\ncase XGMAC_INT_DMA_ALL:\r\ndma_ch_ier |= channel->saved_ier;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);\r\nreturn 0;\r\n}\r\nstatic int xgbe_disable_int(struct xgbe_channel *channel,\r\nenum xgbe_int int_id)\r\n{\r\nunsigned int dma_ch_ier;\r\ndma_ch_ier = XGMAC_DMA_IOREAD(channel, DMA_CH_IER);\r\nswitch (int_id) {\r\ncase XGMAC_INT_DMA_CH_SR_TI:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_TPS:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TXSE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_TBU:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TBUE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_RI:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_RBU:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RBUE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_RPS:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RSE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_TI_RI:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, TIE, 0);\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, RIE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_CH_SR_FBE:\r\nXGMAC_SET_BITS(dma_ch_ier, DMA_CH_IER, FBEE, 0);\r\nbreak;\r\ncase XGMAC_INT_DMA_ALL:\r\nchannel->saved_ier = dma_ch_ier & XGBE_DMA_INTERRUPT_MASK;\r\ndma_ch_ier &= ~XGBE_DMA_INTERRUPT_MASK;\r\nbreak;\r\ndefault:\r\nreturn -1;\r\n}\r\nXGMAC_DMA_IOWRITE(channel, DMA_CH_IER, dma_ch_ier);\r\nreturn 0;\r\n}\r\nstatic int __xgbe_exit(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int count = 2000;\r\nDBGPR("-->xgbe_exit\n");\r\nXGMAC_IOWRITE_BITS(pdata, DMA_MR, SWR, 1);\r\nusleep_range(10, 15);\r\nwhile (--count && XGMAC_IOREAD_BITS(pdata, DMA_MR, SWR))\r\nusleep_range(500, 600);\r\nif (!count)\r\nreturn -EBUSY;\r\nDBGPR("<--xgbe_exit\n");\r\nreturn 0;\r\n}\r\nstatic int xgbe_exit(struct xgbe_prv_data *pdata)\r\n{\r\nint ret;\r\nret = __xgbe_exit(pdata);\r\nif (ret)\r\nreturn ret;\r\nreturn __xgbe_exit(pdata);\r\n}\r\nstatic int xgbe_flush_tx_queues(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int i, count;\r\nif (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) < 0x21)\r\nreturn 0;\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, FTQ, 1);\r\nfor (i = 0; i < pdata->tx_q_count; i++) {\r\ncount = 2000;\r\nwhile (--count && XGMAC_MTL_IOREAD_BITS(pdata, i,\r\nMTL_Q_TQOMR, FTQ))\r\nusleep_range(500, 600);\r\nif (!count)\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic void xgbe_config_dma_bus(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, DMA_SBMR, EAME, 1);\r\nXGMAC_IOWRITE_BITS(pdata, DMA_SBMR, UNDEF, 1);\r\nXGMAC_IOWRITE_BITS(pdata, DMA_SBMR, BLEN_256, 1);\r\n}\r\nstatic void xgbe_config_dma_cache(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int arcache, awcache;\r\narcache = 0;\r\nXGMAC_SET_BITS(arcache, DMA_AXIARCR, DRC, pdata->arcache);\r\nXGMAC_SET_BITS(arcache, DMA_AXIARCR, DRD, pdata->axdomain);\r\nXGMAC_SET_BITS(arcache, DMA_AXIARCR, TEC, pdata->arcache);\r\nXGMAC_SET_BITS(arcache, DMA_AXIARCR, TED, pdata->axdomain);\r\nXGMAC_SET_BITS(arcache, DMA_AXIARCR, THC, pdata->arcache);\r\nXGMAC_SET_BITS(arcache, DMA_AXIARCR, THD, pdata->axdomain);\r\nXGMAC_IOWRITE(pdata, DMA_AXIARCR, arcache);\r\nawcache = 0;\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, DWC, pdata->awcache);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, DWD, pdata->axdomain);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, RPC, pdata->awcache);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, RPD, pdata->axdomain);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, RHC, pdata->awcache);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, RHD, pdata->axdomain);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, TDC, pdata->awcache);\r\nXGMAC_SET_BITS(awcache, DMA_AXIAWCR, TDD, pdata->axdomain);\r\nXGMAC_IOWRITE(pdata, DMA_AXIAWCR, awcache);\r\n}\r\nstatic void xgbe_config_mtl_mode(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int i;\r\nXGMAC_IOWRITE_BITS(pdata, MTL_OMR, ETSALG, MTL_ETSALG_WRR);\r\nfor (i = 0; i < pdata->hw_feat.tc_cnt; i++) {\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,\r\nMTL_TSA_ETS);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_QWR, QW, 1);\r\n}\r\nXGMAC_IOWRITE_BITS(pdata, MTL_OMR, RAA, MTL_RAA_SP);\r\n}\r\nstatic void xgbe_queue_flow_control_threshold(struct xgbe_prv_data *pdata,\r\nunsigned int queue,\r\nunsigned int q_fifo_size)\r\n{\r\nunsigned int frame_fifo_size;\r\nunsigned int rfa, rfd;\r\nframe_fifo_size = XGMAC_FLOW_CONTROL_ALIGN(xgbe_get_max_frame(pdata));\r\nif (pdata->pfcq[queue] && (q_fifo_size > pdata->pfc_rfa)) {\r\nrfa = pdata->pfc_rfa;\r\nrfd = rfa + frame_fifo_size;\r\nif (rfd > XGMAC_FLOW_CONTROL_MAX)\r\nrfd = XGMAC_FLOW_CONTROL_MAX;\r\nif (rfa >= XGMAC_FLOW_CONTROL_MAX)\r\nrfa = XGMAC_FLOW_CONTROL_MAX - XGMAC_FLOW_CONTROL_UNIT;\r\n} else {\r\nif (q_fifo_size <= 2048) {\r\npdata->rx_rfa[queue] = 0;\r\npdata->rx_rfd[queue] = 0;\r\nreturn;\r\n}\r\nif (q_fifo_size <= 4096) {\r\npdata->rx_rfa[queue] = 0;\r\npdata->rx_rfd[queue] = 1;\r\nreturn;\r\n}\r\nif (q_fifo_size <= frame_fifo_size) {\r\npdata->rx_rfa[queue] = 2;\r\npdata->rx_rfd[queue] = 5;\r\nreturn;\r\n}\r\nif (q_fifo_size <= (frame_fifo_size * 3)) {\r\nrfa = q_fifo_size - frame_fifo_size;\r\nrfd = rfa + (frame_fifo_size / 2);\r\n} else {\r\nrfa = frame_fifo_size * 2;\r\nrfa += XGMAC_FLOW_CONTROL_UNIT;\r\nrfd = rfa + frame_fifo_size;\r\n}\r\n}\r\npdata->rx_rfa[queue] = XGMAC_FLOW_CONTROL_VALUE(rfa);\r\npdata->rx_rfd[queue] = XGMAC_FLOW_CONTROL_VALUE(rfd);\r\n}\r\nstatic void xgbe_calculate_flow_control_threshold(struct xgbe_prv_data *pdata,\r\nunsigned int *fifo)\r\n{\r\nunsigned int q_fifo_size;\r\nunsigned int i;\r\nfor (i = 0; i < pdata->rx_q_count; i++) {\r\nq_fifo_size = (fifo[i] + 1) * XGMAC_FIFO_UNIT;\r\nxgbe_queue_flow_control_threshold(pdata, i, q_fifo_size);\r\n}\r\n}\r\nstatic void xgbe_config_flow_control_threshold(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pdata->rx_q_count; i++) {\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQFCR, RFA,\r\npdata->rx_rfa[i]);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQFCR, RFD,\r\npdata->rx_rfd[i]);\r\n}\r\n}\r\nstatic unsigned int xgbe_get_tx_fifo_size(struct xgbe_prv_data *pdata)\r\n{\r\nreturn min_t(unsigned int, pdata->tx_max_fifo_size,\r\npdata->hw_feat.tx_fifo_size);\r\n}\r\nstatic unsigned int xgbe_get_rx_fifo_size(struct xgbe_prv_data *pdata)\r\n{\r\nreturn min_t(unsigned int, pdata->rx_max_fifo_size,\r\npdata->hw_feat.rx_fifo_size);\r\n}\r\nstatic void xgbe_calculate_equal_fifo(unsigned int fifo_size,\r\nunsigned int queue_count,\r\nunsigned int *fifo)\r\n{\r\nunsigned int q_fifo_size;\r\nunsigned int p_fifo;\r\nunsigned int i;\r\nq_fifo_size = fifo_size / queue_count;\r\np_fifo = q_fifo_size / XGMAC_FIFO_UNIT;\r\nif (p_fifo)\r\np_fifo--;\r\nfor (i = 0; i < queue_count; i++)\r\nfifo[i] = p_fifo;\r\n}\r\nstatic unsigned int xgbe_set_nonprio_fifos(unsigned int fifo_size,\r\nunsigned int queue_count,\r\nunsigned int *fifo)\r\n{\r\nunsigned int i;\r\nBUILD_BUG_ON_NOT_POWER_OF_2(XGMAC_FIFO_MIN_ALLOC);\r\nif (queue_count <= IEEE_8021QAZ_MAX_TCS)\r\nreturn fifo_size;\r\nfor (i = IEEE_8021QAZ_MAX_TCS; i < queue_count; i++) {\r\nfifo[i] = (XGMAC_FIFO_MIN_ALLOC / XGMAC_FIFO_UNIT) - 1;\r\nfifo_size -= XGMAC_FIFO_MIN_ALLOC;\r\n}\r\nreturn fifo_size;\r\n}\r\nstatic unsigned int xgbe_get_pfc_delay(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int delay;\r\nif (pdata->pfc->delay)\r\nreturn pdata->pfc->delay / 8;\r\ndelay = xgbe_get_max_frame(pdata);\r\ndelay += XGMAC_ETH_PREAMBLE;\r\ndelay *= 2;\r\ndelay += XGMAC_PFC_DATA_LEN;\r\ndelay += ETH_HLEN + ETH_FCS_LEN;\r\ndelay += XGMAC_ETH_PREAMBLE;\r\ndelay += XGMAC_PFC_DELAYS;\r\nreturn delay;\r\n}\r\nstatic unsigned int xgbe_get_pfc_queues(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int count, prio_queues;\r\nunsigned int i;\r\nif (!pdata->pfc->pfc_en)\r\nreturn 0;\r\ncount = 0;\r\nprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\r\nfor (i = 0; i < prio_queues; i++) {\r\nif (!xgbe_is_pfc_queue(pdata, i))\r\ncontinue;\r\npdata->pfcq[i] = 1;\r\ncount++;\r\n}\r\nreturn count;\r\n}\r\nstatic void xgbe_calculate_dcb_fifo(struct xgbe_prv_data *pdata,\r\nunsigned int fifo_size,\r\nunsigned int *fifo)\r\n{\r\nunsigned int q_fifo_size, rem_fifo, addn_fifo;\r\nunsigned int prio_queues;\r\nunsigned int pfc_count;\r\nunsigned int i;\r\nq_fifo_size = XGMAC_FIFO_ALIGN(xgbe_get_max_frame(pdata));\r\nprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\r\npfc_count = xgbe_get_pfc_queues(pdata);\r\nif (!pfc_count || ((q_fifo_size * prio_queues) > fifo_size)) {\r\nxgbe_calculate_equal_fifo(fifo_size, prio_queues, fifo);\r\nreturn;\r\n}\r\nrem_fifo = fifo_size - (q_fifo_size * prio_queues);\r\npdata->pfc_rfa = xgbe_get_pfc_delay(pdata);\r\npdata->pfc_rfa = XGMAC_FLOW_CONTROL_ALIGN(pdata->pfc_rfa);\r\nif (pdata->pfc_rfa > q_fifo_size) {\r\naddn_fifo = pdata->pfc_rfa - q_fifo_size;\r\naddn_fifo = XGMAC_FIFO_ALIGN(addn_fifo);\r\n} else {\r\naddn_fifo = 0;\r\n}\r\ni = prio_queues;\r\nwhile (i > 0) {\r\ni--;\r\nfifo[i] = (q_fifo_size / XGMAC_FIFO_UNIT) - 1;\r\nif (!pdata->pfcq[i] || !addn_fifo)\r\ncontinue;\r\nif (addn_fifo > rem_fifo) {\r\nnetdev_warn(pdata->netdev,\r\n"RXq%u cannot set needed fifo size\n", i);\r\nif (!rem_fifo)\r\ncontinue;\r\naddn_fifo = rem_fifo;\r\n}\r\nfifo[i] += (addn_fifo / XGMAC_FIFO_UNIT);\r\nrem_fifo -= addn_fifo;\r\n}\r\nif (rem_fifo) {\r\nunsigned int inc_fifo = rem_fifo / prio_queues;\r\nfor (i = 0; i < prio_queues; i++)\r\nfifo[i] += (inc_fifo / XGMAC_FIFO_UNIT);\r\n}\r\n}\r\nstatic void xgbe_config_tx_fifo_size(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int fifo_size;\r\nunsigned int fifo[XGBE_MAX_QUEUES];\r\nunsigned int i;\r\nfifo_size = xgbe_get_tx_fifo_size(pdata);\r\nxgbe_calculate_equal_fifo(fifo_size, pdata->tx_q_count, fifo);\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TQS, fifo[i]);\r\nnetif_info(pdata, drv, pdata->netdev,\r\n"%d Tx hardware queues, %d byte fifo per queue\n",\r\npdata->tx_q_count, ((fifo[0] + 1) * XGMAC_FIFO_UNIT));\r\n}\r\nstatic void xgbe_config_rx_fifo_size(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int fifo_size;\r\nunsigned int fifo[XGBE_MAX_QUEUES];\r\nunsigned int prio_queues;\r\nunsigned int i;\r\nmemset(pdata->pfcq, 0, sizeof(pdata->pfcq));\r\npdata->pfc_rfa = 0;\r\nfifo_size = xgbe_get_rx_fifo_size(pdata);\r\nprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\r\nfifo_size = xgbe_set_nonprio_fifos(fifo_size, pdata->rx_q_count, fifo);\r\nif (pdata->pfc && pdata->ets)\r\nxgbe_calculate_dcb_fifo(pdata, fifo_size, fifo);\r\nelse\r\nxgbe_calculate_equal_fifo(fifo_size, prio_queues, fifo);\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_RQOMR, RQS, fifo[i]);\r\nxgbe_calculate_flow_control_threshold(pdata, fifo);\r\nxgbe_config_flow_control_threshold(pdata);\r\nif (pdata->pfc && pdata->ets && pdata->pfc->pfc_en) {\r\nnetif_info(pdata, drv, pdata->netdev,\r\n"%u Rx hardware queues\n", pdata->rx_q_count);\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nnetif_info(pdata, drv, pdata->netdev,\r\n"RxQ%u, %u byte fifo queue\n", i,\r\n((fifo[i] + 1) * XGMAC_FIFO_UNIT));\r\n} else {\r\nnetif_info(pdata, drv, pdata->netdev,\r\n"%u Rx hardware queues, %u byte fifo per queue\n",\r\npdata->rx_q_count,\r\n((fifo[0] + 1) * XGMAC_FIFO_UNIT));\r\n}\r\n}\r\nstatic void xgbe_config_queue_mapping(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int qptc, qptc_extra, queue;\r\nunsigned int prio_queues;\r\nunsigned int ppq, ppq_extra, prio;\r\nunsigned int mask;\r\nunsigned int i, j, reg, reg_val;\r\nqptc = pdata->tx_q_count / pdata->hw_feat.tc_cnt;\r\nqptc_extra = pdata->tx_q_count % pdata->hw_feat.tc_cnt;\r\nfor (i = 0, queue = 0; i < pdata->hw_feat.tc_cnt; i++) {\r\nfor (j = 0; j < qptc; j++) {\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"TXq%u mapped to TC%u\n", queue, i);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, queue, MTL_Q_TQOMR,\r\nQ2TCMAP, i);\r\npdata->q2tc_map[queue++] = i;\r\n}\r\nif (i < qptc_extra) {\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"TXq%u mapped to TC%u\n", queue, i);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, queue, MTL_Q_TQOMR,\r\nQ2TCMAP, i);\r\npdata->q2tc_map[queue++] = i;\r\n}\r\n}\r\nprio_queues = XGMAC_PRIO_QUEUES(pdata->rx_q_count);\r\nppq = IEEE_8021QAZ_MAX_TCS / prio_queues;\r\nppq_extra = IEEE_8021QAZ_MAX_TCS % prio_queues;\r\nreg = MAC_RQC2R;\r\nreg_val = 0;\r\nfor (i = 0, prio = 0; i < prio_queues;) {\r\nmask = 0;\r\nfor (j = 0; j < ppq; j++) {\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"PRIO%u mapped to RXq%u\n", prio, i);\r\nmask |= (1 << prio);\r\npdata->prio2q_map[prio++] = i;\r\n}\r\nif (i < ppq_extra) {\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"PRIO%u mapped to RXq%u\n", prio, i);\r\nmask |= (1 << prio);\r\npdata->prio2q_map[prio++] = i;\r\n}\r\nreg_val |= (mask << ((i++ % MAC_RQC2_Q_PER_REG) << 3));\r\nif ((i % MAC_RQC2_Q_PER_REG) && (i != prio_queues))\r\ncontinue;\r\nXGMAC_IOWRITE(pdata, reg, reg_val);\r\nreg += MAC_RQC2_INC;\r\nreg_val = 0;\r\n}\r\nreg = MTL_RQDCM0R;\r\nreg_val = 0;\r\nfor (i = 0; i < pdata->rx_q_count;) {\r\nreg_val |= (0x80 << ((i++ % MTL_RQDCM_Q_PER_REG) << 3));\r\nif ((i % MTL_RQDCM_Q_PER_REG) && (i != pdata->rx_q_count))\r\ncontinue;\r\nXGMAC_IOWRITE(pdata, reg, reg_val);\r\nreg += MTL_RQDCM_INC;\r\nreg_val = 0;\r\n}\r\n}\r\nstatic void xgbe_config_tc(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int offset, queue, prio;\r\nu8 i;\r\nnetdev_reset_tc(pdata->netdev);\r\nif (!pdata->num_tcs)\r\nreturn;\r\nnetdev_set_num_tc(pdata->netdev, pdata->num_tcs);\r\nfor (i = 0, queue = 0, offset = 0; i < pdata->num_tcs; i++) {\r\nwhile ((queue < pdata->tx_q_count) &&\r\n(pdata->q2tc_map[queue] == i))\r\nqueue++;\r\nnetif_dbg(pdata, drv, pdata->netdev, "TC%u using TXq%u-%u\n",\r\ni, offset, queue - 1);\r\nnetdev_set_tc_queue(pdata->netdev, i, queue - offset, offset);\r\noffset = queue;\r\n}\r\nif (!pdata->ets)\r\nreturn;\r\nfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++)\r\nnetdev_set_prio_tc_map(pdata->netdev, prio,\r\npdata->ets->prio_tc[prio]);\r\n}\r\nstatic void xgbe_config_dcb_tc(struct xgbe_prv_data *pdata)\r\n{\r\nstruct ieee_ets *ets = pdata->ets;\r\nunsigned int total_weight, min_weight, weight;\r\nunsigned int mask, reg, reg_val;\r\nunsigned int i, prio;\r\nif (!ets)\r\nreturn;\r\nXGMAC_IOWRITE_BITS(pdata, MTL_OMR, ETSALG, MTL_ETSALG_DWRR);\r\ntotal_weight = pdata->netdev->mtu * pdata->hw_feat.tc_cnt;\r\nmin_weight = total_weight / 100;\r\nif (!min_weight)\r\nmin_weight = 1;\r\nfor (i = 0; i < pdata->hw_feat.tc_cnt; i++) {\r\nmask = 0;\r\nfor (prio = 0; prio < IEEE_8021QAZ_MAX_TCS; prio++) {\r\nif (ets->prio_tc[prio] == i)\r\nmask |= (1 << prio);\r\n}\r\nmask &= 0xff;\r\nnetif_dbg(pdata, drv, pdata->netdev, "TC%u PRIO mask=%#x\n",\r\ni, mask);\r\nreg = MTL_TCPM0R + (MTL_TCPM_INC * (i / MTL_TCPM_TC_PER_REG));\r\nreg_val = XGMAC_IOREAD(pdata, reg);\r\nreg_val &= ~(0xff << ((i % MTL_TCPM_TC_PER_REG) << 3));\r\nreg_val |= (mask << ((i % MTL_TCPM_TC_PER_REG) << 3));\r\nXGMAC_IOWRITE(pdata, reg, reg_val);\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"TC%u using SP\n", i);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,\r\nMTL_TSA_SP);\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\nweight = total_weight * ets->tc_tx_bw[i] / 100;\r\nweight = clamp(weight, min_weight, total_weight);\r\nnetif_dbg(pdata, drv, pdata->netdev,\r\n"TC%u using DWRR (weight %u)\n", i, weight);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_ETSCR, TSA,\r\nMTL_TSA_ETS);\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_TC_QWR, QW,\r\nweight);\r\nbreak;\r\n}\r\n}\r\nxgbe_config_tc(pdata);\r\n}\r\nstatic void xgbe_config_dcb_pfc(struct xgbe_prv_data *pdata)\r\n{\r\nif (!test_bit(XGBE_DOWN, &pdata->dev_state)) {\r\nnetif_tx_stop_all_queues(pdata->netdev);\r\npdata->hw_if.disable_rx(pdata);\r\n}\r\nxgbe_config_rx_fifo_size(pdata);\r\nxgbe_config_flow_control(pdata);\r\nif (!test_bit(XGBE_DOWN, &pdata->dev_state)) {\r\npdata->hw_if.enable_rx(pdata);\r\nnetif_tx_start_all_queues(pdata->netdev);\r\n}\r\n}\r\nstatic void xgbe_config_mac_address(struct xgbe_prv_data *pdata)\r\n{\r\nxgbe_set_mac_address(pdata, pdata->netdev->dev_addr);\r\nif (pdata->hw_feat.hash_table_size) {\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, HPF, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, HUC, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_PFR, HMC, 1);\r\n}\r\n}\r\nstatic void xgbe_config_jumbo_enable(struct xgbe_prv_data *pdata)\r\n{\r\nunsigned int val;\r\nval = (pdata->netdev->mtu > XGMAC_STD_PACKET_MTU) ? 1 : 0;\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, JE, val);\r\n}\r\nstatic void xgbe_config_mac_speed(struct xgbe_prv_data *pdata)\r\n{\r\nxgbe_set_speed(pdata, pdata->phy_speed);\r\n}\r\nstatic void xgbe_config_checksum_offload(struct xgbe_prv_data *pdata)\r\n{\r\nif (pdata->netdev->features & NETIF_F_RXCSUM)\r\nxgbe_enable_rx_csum(pdata);\r\nelse\r\nxgbe_disable_rx_csum(pdata);\r\n}\r\nstatic void xgbe_config_vlan_support(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANIR, CSVL, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_VLANIR, VLTI, 1);\r\nxgbe_update_vlan_hash_table(pdata);\r\nif (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_FILTER)\r\nxgbe_enable_rx_vlan_filtering(pdata);\r\nelse\r\nxgbe_disable_rx_vlan_filtering(pdata);\r\nif (pdata->netdev->features & NETIF_F_HW_VLAN_CTAG_RX)\r\nxgbe_enable_rx_vlan_stripping(pdata);\r\nelse\r\nxgbe_disable_rx_vlan_stripping(pdata);\r\n}\r\nstatic u64 xgbe_mmc_read(struct xgbe_prv_data *pdata, unsigned int reg_lo)\r\n{\r\nbool read_hi;\r\nu64 val;\r\nif (pdata->vdata->mmc_64bit) {\r\nswitch (reg_lo) {\r\ncase MMC_RXRUNTERROR:\r\ncase MMC_RXJABBERERROR:\r\ncase MMC_RXUNDERSIZE_G:\r\ncase MMC_RXOVERSIZE_G:\r\ncase MMC_RXWATCHDOGERROR:\r\nread_hi = false;\r\nbreak;\r\ndefault:\r\nread_hi = true;\r\n}\r\n} else {\r\nswitch (reg_lo) {\r\ncase MMC_TXOCTETCOUNT_GB_LO:\r\ncase MMC_TXOCTETCOUNT_G_LO:\r\ncase MMC_RXOCTETCOUNT_GB_LO:\r\ncase MMC_RXOCTETCOUNT_G_LO:\r\nread_hi = true;\r\nbreak;\r\ndefault:\r\nread_hi = false;\r\n}\r\n}\r\nval = XGMAC_IOREAD(pdata, reg_lo);\r\nif (read_hi)\r\nval |= ((u64)XGMAC_IOREAD(pdata, reg_lo + 4) << 32);\r\nreturn val;\r\n}\r\nstatic void xgbe_tx_mmc_int(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_mmc_stats *stats = &pdata->mmc_stats;\r\nunsigned int mmc_isr = XGMAC_IOREAD(pdata, MMC_TISR);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXOCTETCOUNT_GB))\r\nstats->txoctetcount_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXFRAMECOUNT_GB))\r\nstats->txframecount_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXBROADCASTFRAMES_G))\r\nstats->txbroadcastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXMULTICASTFRAMES_G))\r\nstats->txmulticastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX64OCTETS_GB))\r\nstats->tx64octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX64OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX65TO127OCTETS_GB))\r\nstats->tx65to127octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX65TO127OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX128TO255OCTETS_GB))\r\nstats->tx128to255octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX128TO255OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX256TO511OCTETS_GB))\r\nstats->tx256to511octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX256TO511OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX512TO1023OCTETS_GB))\r\nstats->tx512to1023octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX512TO1023OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TX1024TOMAXOCTETS_GB))\r\nstats->tx1024tomaxoctets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX1024TOMAXOCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXUNICASTFRAMES_GB))\r\nstats->txunicastframes_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXUNICASTFRAMES_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXMULTICASTFRAMES_GB))\r\nstats->txmulticastframes_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXBROADCASTFRAMES_GB))\r\nstats->txbroadcastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXUNDERFLOWERROR))\r\nstats->txunderflowerror +=\r\nxgbe_mmc_read(pdata, MMC_TXUNDERFLOWERROR_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXOCTETCOUNT_G))\r\nstats->txoctetcount_g +=\r\nxgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXFRAMECOUNT_G))\r\nstats->txframecount_g +=\r\nxgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXPAUSEFRAMES))\r\nstats->txpauseframes +=\r\nxgbe_mmc_read(pdata, MMC_TXPAUSEFRAMES_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_TISR, TXVLANFRAMES_G))\r\nstats->txvlanframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXVLANFRAMES_G_LO);\r\n}\r\nstatic void xgbe_rx_mmc_int(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_mmc_stats *stats = &pdata->mmc_stats;\r\nunsigned int mmc_isr = XGMAC_IOREAD(pdata, MMC_RISR);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXFRAMECOUNT_GB))\r\nstats->rxframecount_gb +=\r\nxgbe_mmc_read(pdata, MMC_RXFRAMECOUNT_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOCTETCOUNT_GB))\r\nstats->rxoctetcount_gb +=\r\nxgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOCTETCOUNT_G))\r\nstats->rxoctetcount_g +=\r\nxgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXBROADCASTFRAMES_G))\r\nstats->rxbroadcastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_RXBROADCASTFRAMES_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXMULTICASTFRAMES_G))\r\nstats->rxmulticastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_RXMULTICASTFRAMES_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXCRCERROR))\r\nstats->rxcrcerror +=\r\nxgbe_mmc_read(pdata, MMC_RXCRCERROR_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXRUNTERROR))\r\nstats->rxrunterror +=\r\nxgbe_mmc_read(pdata, MMC_RXRUNTERROR);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXJABBERERROR))\r\nstats->rxjabbererror +=\r\nxgbe_mmc_read(pdata, MMC_RXJABBERERROR);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXUNDERSIZE_G))\r\nstats->rxundersize_g +=\r\nxgbe_mmc_read(pdata, MMC_RXUNDERSIZE_G);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOVERSIZE_G))\r\nstats->rxoversize_g +=\r\nxgbe_mmc_read(pdata, MMC_RXOVERSIZE_G);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX64OCTETS_GB))\r\nstats->rx64octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX64OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX65TO127OCTETS_GB))\r\nstats->rx65to127octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX65TO127OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX128TO255OCTETS_GB))\r\nstats->rx128to255octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX128TO255OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX256TO511OCTETS_GB))\r\nstats->rx256to511octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX256TO511OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX512TO1023OCTETS_GB))\r\nstats->rx512to1023octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX512TO1023OCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RX1024TOMAXOCTETS_GB))\r\nstats->rx1024tomaxoctets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX1024TOMAXOCTETS_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXUNICASTFRAMES_G))\r\nstats->rxunicastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_RXUNICASTFRAMES_G_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXLENGTHERROR))\r\nstats->rxlengtherror +=\r\nxgbe_mmc_read(pdata, MMC_RXLENGTHERROR_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXOUTOFRANGETYPE))\r\nstats->rxoutofrangetype +=\r\nxgbe_mmc_read(pdata, MMC_RXOUTOFRANGETYPE_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXPAUSEFRAMES))\r\nstats->rxpauseframes +=\r\nxgbe_mmc_read(pdata, MMC_RXPAUSEFRAMES_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXFIFOOVERFLOW))\r\nstats->rxfifooverflow +=\r\nxgbe_mmc_read(pdata, MMC_RXFIFOOVERFLOW_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXVLANFRAMES_GB))\r\nstats->rxvlanframes_gb +=\r\nxgbe_mmc_read(pdata, MMC_RXVLANFRAMES_GB_LO);\r\nif (XGMAC_GET_BITS(mmc_isr, MMC_RISR, RXWATCHDOGERROR))\r\nstats->rxwatchdogerror +=\r\nxgbe_mmc_read(pdata, MMC_RXWATCHDOGERROR);\r\n}\r\nstatic void xgbe_read_mmc_stats(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_mmc_stats *stats = &pdata->mmc_stats;\r\nXGMAC_IOWRITE_BITS(pdata, MMC_CR, MCF, 1);\r\nstats->txoctetcount_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_GB_LO);\r\nstats->txframecount_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_GB_LO);\r\nstats->txbroadcastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_G_LO);\r\nstats->txmulticastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_G_LO);\r\nstats->tx64octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX64OCTETS_GB_LO);\r\nstats->tx65to127octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX65TO127OCTETS_GB_LO);\r\nstats->tx128to255octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX128TO255OCTETS_GB_LO);\r\nstats->tx256to511octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX256TO511OCTETS_GB_LO);\r\nstats->tx512to1023octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX512TO1023OCTETS_GB_LO);\r\nstats->tx1024tomaxoctets_gb +=\r\nxgbe_mmc_read(pdata, MMC_TX1024TOMAXOCTETS_GB_LO);\r\nstats->txunicastframes_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXUNICASTFRAMES_GB_LO);\r\nstats->txmulticastframes_gb +=\r\nxgbe_mmc_read(pdata, MMC_TXMULTICASTFRAMES_GB_LO);\r\nstats->txbroadcastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXBROADCASTFRAMES_GB_LO);\r\nstats->txunderflowerror +=\r\nxgbe_mmc_read(pdata, MMC_TXUNDERFLOWERROR_LO);\r\nstats->txoctetcount_g +=\r\nxgbe_mmc_read(pdata, MMC_TXOCTETCOUNT_G_LO);\r\nstats->txframecount_g +=\r\nxgbe_mmc_read(pdata, MMC_TXFRAMECOUNT_G_LO);\r\nstats->txpauseframes +=\r\nxgbe_mmc_read(pdata, MMC_TXPAUSEFRAMES_LO);\r\nstats->txvlanframes_g +=\r\nxgbe_mmc_read(pdata, MMC_TXVLANFRAMES_G_LO);\r\nstats->rxframecount_gb +=\r\nxgbe_mmc_read(pdata, MMC_RXFRAMECOUNT_GB_LO);\r\nstats->rxoctetcount_gb +=\r\nxgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_GB_LO);\r\nstats->rxoctetcount_g +=\r\nxgbe_mmc_read(pdata, MMC_RXOCTETCOUNT_G_LO);\r\nstats->rxbroadcastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_RXBROADCASTFRAMES_G_LO);\r\nstats->rxmulticastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_RXMULTICASTFRAMES_G_LO);\r\nstats->rxcrcerror +=\r\nxgbe_mmc_read(pdata, MMC_RXCRCERROR_LO);\r\nstats->rxrunterror +=\r\nxgbe_mmc_read(pdata, MMC_RXRUNTERROR);\r\nstats->rxjabbererror +=\r\nxgbe_mmc_read(pdata, MMC_RXJABBERERROR);\r\nstats->rxundersize_g +=\r\nxgbe_mmc_read(pdata, MMC_RXUNDERSIZE_G);\r\nstats->rxoversize_g +=\r\nxgbe_mmc_read(pdata, MMC_RXOVERSIZE_G);\r\nstats->rx64octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX64OCTETS_GB_LO);\r\nstats->rx65to127octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX65TO127OCTETS_GB_LO);\r\nstats->rx128to255octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX128TO255OCTETS_GB_LO);\r\nstats->rx256to511octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX256TO511OCTETS_GB_LO);\r\nstats->rx512to1023octets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX512TO1023OCTETS_GB_LO);\r\nstats->rx1024tomaxoctets_gb +=\r\nxgbe_mmc_read(pdata, MMC_RX1024TOMAXOCTETS_GB_LO);\r\nstats->rxunicastframes_g +=\r\nxgbe_mmc_read(pdata, MMC_RXUNICASTFRAMES_G_LO);\r\nstats->rxlengtherror +=\r\nxgbe_mmc_read(pdata, MMC_RXLENGTHERROR_LO);\r\nstats->rxoutofrangetype +=\r\nxgbe_mmc_read(pdata, MMC_RXOUTOFRANGETYPE_LO);\r\nstats->rxpauseframes +=\r\nxgbe_mmc_read(pdata, MMC_RXPAUSEFRAMES_LO);\r\nstats->rxfifooverflow +=\r\nxgbe_mmc_read(pdata, MMC_RXFIFOOVERFLOW_LO);\r\nstats->rxvlanframes_gb +=\r\nxgbe_mmc_read(pdata, MMC_RXVLANFRAMES_GB_LO);\r\nstats->rxwatchdogerror +=\r\nxgbe_mmc_read(pdata, MMC_RXWATCHDOGERROR);\r\nXGMAC_IOWRITE_BITS(pdata, MMC_CR, MCF, 0);\r\n}\r\nstatic void xgbe_config_mmc(struct xgbe_prv_data *pdata)\r\n{\r\nXGMAC_IOWRITE_BITS(pdata, MMC_CR, ROR, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MMC_CR, CR, 1);\r\n}\r\nstatic void xgbe_txq_prepare_tx_stop(struct xgbe_prv_data *pdata,\r\nunsigned int queue)\r\n{\r\nunsigned int tx_status;\r\nunsigned long tx_timeout;\r\ntx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);\r\nwhile (time_before(jiffies, tx_timeout)) {\r\ntx_status = XGMAC_MTL_IOREAD(pdata, queue, MTL_Q_TQDR);\r\nif ((XGMAC_GET_BITS(tx_status, MTL_Q_TQDR, TRCSTS) != 1) &&\r\n(XGMAC_GET_BITS(tx_status, MTL_Q_TQDR, TXQSTS) == 0))\r\nbreak;\r\nusleep_range(500, 1000);\r\n}\r\nif (!time_before(jiffies, tx_timeout))\r\nnetdev_info(pdata->netdev,\r\n"timed out waiting for Tx queue %u to empty\n",\r\nqueue);\r\n}\r\nstatic void xgbe_prepare_tx_stop(struct xgbe_prv_data *pdata,\r\nunsigned int queue)\r\n{\r\nunsigned int tx_dsr, tx_pos, tx_qidx;\r\nunsigned int tx_status;\r\nunsigned long tx_timeout;\r\nif (XGMAC_GET_BITS(pdata->hw_feat.version, MAC_VR, SNPSVER) > 0x20)\r\nreturn xgbe_txq_prepare_tx_stop(pdata, queue);\r\nif (queue < DMA_DSRX_FIRST_QUEUE) {\r\ntx_dsr = DMA_DSR0;\r\ntx_pos = (queue * DMA_DSR_Q_WIDTH) + DMA_DSR0_TPS_START;\r\n} else {\r\ntx_qidx = queue - DMA_DSRX_FIRST_QUEUE;\r\ntx_dsr = DMA_DSR1 + ((tx_qidx / DMA_DSRX_QPR) * DMA_DSRX_INC);\r\ntx_pos = ((tx_qidx % DMA_DSRX_QPR) * DMA_DSR_Q_WIDTH) +\r\nDMA_DSRX_TPS_START;\r\n}\r\ntx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);\r\nwhile (time_before(jiffies, tx_timeout)) {\r\ntx_status = XGMAC_IOREAD(pdata, tx_dsr);\r\ntx_status = GET_BITS(tx_status, tx_pos, DMA_DSR_TPS_WIDTH);\r\nif ((tx_status == DMA_TPS_STOPPED) ||\r\n(tx_status == DMA_TPS_SUSPENDED))\r\nbreak;\r\nusleep_range(500, 1000);\r\n}\r\nif (!time_before(jiffies, tx_timeout))\r\nnetdev_info(pdata->netdev,\r\n"timed out waiting for Tx DMA channel %u to stop\n",\r\nqueue);\r\n}\r\nstatic void xgbe_enable_tx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 1);\r\n}\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TXQEN,\r\nMTL_Q_ENABLED);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 1);\r\n}\r\nstatic void xgbe_disable_tx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nxgbe_prepare_tx_stop(pdata, i);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nXGMAC_MTL_IOWRITE_BITS(pdata, i, MTL_Q_TQOMR, TXQEN, 0);\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 0);\r\n}\r\n}\r\nstatic void xgbe_prepare_rx_stop(struct xgbe_prv_data *pdata,\r\nunsigned int queue)\r\n{\r\nunsigned int rx_status;\r\nunsigned long rx_timeout;\r\nrx_timeout = jiffies + (XGBE_DMA_STOP_TIMEOUT * HZ);\r\nwhile (time_before(jiffies, rx_timeout)) {\r\nrx_status = XGMAC_MTL_IOREAD(pdata, queue, MTL_Q_RQDR);\r\nif ((XGMAC_GET_BITS(rx_status, MTL_Q_RQDR, PRXQ) == 0) &&\r\n(XGMAC_GET_BITS(rx_status, MTL_Q_RQDR, RXQSTS) == 0))\r\nbreak;\r\nusleep_range(500, 1000);\r\n}\r\nif (!time_before(jiffies, rx_timeout))\r\nnetdev_info(pdata->netdev,\r\n"timed out waiting for Rx queue %u to empty\n",\r\nqueue);\r\n}\r\nstatic void xgbe_enable_rx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int reg_val, i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 1);\r\n}\r\nreg_val = 0;\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nreg_val |= (0x02 << (i << 1));\r\nXGMAC_IOWRITE(pdata, MAC_RQC0R, reg_val);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, DCRCC, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, CST, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 1);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 1);\r\n}\r\nstatic void xgbe_disable_rx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, DCRCC, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, CST, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, ACS, 0);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_RCR, RE, 0);\r\nfor (i = 0; i < pdata->rx_q_count; i++)\r\nxgbe_prepare_rx_stop(pdata, i);\r\nXGMAC_IOWRITE(pdata, MAC_RQC0R, 0);\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 0);\r\n}\r\n}\r\nstatic void xgbe_powerup_tx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 1);\r\n}\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 1);\r\n}\r\nstatic void xgbe_powerdown_tx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nfor (i = 0; i < pdata->tx_q_count; i++)\r\nxgbe_prepare_tx_stop(pdata, i);\r\nXGMAC_IOWRITE_BITS(pdata, MAC_TCR, TE, 0);\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->tx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_TCR, ST, 0);\r\n}\r\n}\r\nstatic void xgbe_powerup_rx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 1);\r\n}\r\n}\r\nstatic void xgbe_powerdown_rx(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_channel *channel;\r\nunsigned int i;\r\nchannel = pdata->channel;\r\nfor (i = 0; i < pdata->channel_count; i++, channel++) {\r\nif (!channel->rx_ring)\r\nbreak;\r\nXGMAC_DMA_IOWRITE_BITS(channel, DMA_CH_RCR, SR, 0);\r\n}\r\n}\r\nstatic int xgbe_init(struct xgbe_prv_data *pdata)\r\n{\r\nstruct xgbe_desc_if *desc_if = &pdata->desc_if;\r\nint ret;\r\nDBGPR("-->xgbe_init\n");\r\nret = xgbe_flush_tx_queues(pdata);\r\nif (ret) {\r\nnetdev_err(pdata->netdev, "error flushing TX queues\n");\r\nreturn ret;\r\n}\r\nxgbe_config_dma_bus(pdata);\r\nxgbe_config_dma_cache(pdata);\r\nxgbe_config_osp_mode(pdata);\r\nxgbe_config_pblx8(pdata);\r\nxgbe_config_tx_pbl_val(pdata);\r\nxgbe_config_rx_pbl_val(pdata);\r\nxgbe_config_rx_coalesce(pdata);\r\nxgbe_config_tx_coalesce(pdata);\r\nxgbe_config_rx_buffer_size(pdata);\r\nxgbe_config_tso_mode(pdata);\r\nxgbe_config_sph_mode(pdata);\r\nxgbe_config_rss(pdata);\r\ndesc_if->wrapper_tx_desc_init(pdata);\r\ndesc_if->wrapper_rx_desc_init(pdata);\r\nxgbe_enable_dma_interrupts(pdata);\r\nxgbe_config_mtl_mode(pdata);\r\nxgbe_config_queue_mapping(pdata);\r\nxgbe_config_tsf_mode(pdata, pdata->tx_sf_mode);\r\nxgbe_config_rsf_mode(pdata, pdata->rx_sf_mode);\r\nxgbe_config_tx_threshold(pdata, pdata->tx_threshold);\r\nxgbe_config_rx_threshold(pdata, pdata->rx_threshold);\r\nxgbe_config_tx_fifo_size(pdata);\r\nxgbe_config_rx_fifo_size(pdata);\r\nxgbe_config_dcb_tc(pdata);\r\nxgbe_enable_mtl_interrupts(pdata);\r\nxgbe_config_mac_address(pdata);\r\nxgbe_config_rx_mode(pdata);\r\nxgbe_config_jumbo_enable(pdata);\r\nxgbe_config_flow_control(pdata);\r\nxgbe_config_mac_speed(pdata);\r\nxgbe_config_checksum_offload(pdata);\r\nxgbe_config_vlan_support(pdata);\r\nxgbe_config_mmc(pdata);\r\nxgbe_enable_mac_interrupts(pdata);\r\nxgbe_enable_ecc_interrupts(pdata);\r\nDBGPR("<--xgbe_init\n");\r\nreturn 0;\r\n}\r\nvoid xgbe_init_function_ptrs_dev(struct xgbe_hw_if *hw_if)\r\n{\r\nDBGPR("-->xgbe_init_function_ptrs\n");\r\nhw_if->tx_complete = xgbe_tx_complete;\r\nhw_if->set_mac_address = xgbe_set_mac_address;\r\nhw_if->config_rx_mode = xgbe_config_rx_mode;\r\nhw_if->enable_rx_csum = xgbe_enable_rx_csum;\r\nhw_if->disable_rx_csum = xgbe_disable_rx_csum;\r\nhw_if->enable_rx_vlan_stripping = xgbe_enable_rx_vlan_stripping;\r\nhw_if->disable_rx_vlan_stripping = xgbe_disable_rx_vlan_stripping;\r\nhw_if->enable_rx_vlan_filtering = xgbe_enable_rx_vlan_filtering;\r\nhw_if->disable_rx_vlan_filtering = xgbe_disable_rx_vlan_filtering;\r\nhw_if->update_vlan_hash_table = xgbe_update_vlan_hash_table;\r\nhw_if->read_mmd_regs = xgbe_read_mmd_regs;\r\nhw_if->write_mmd_regs = xgbe_write_mmd_regs;\r\nhw_if->set_speed = xgbe_set_speed;\r\nhw_if->set_ext_mii_mode = xgbe_set_ext_mii_mode;\r\nhw_if->read_ext_mii_regs = xgbe_read_ext_mii_regs;\r\nhw_if->write_ext_mii_regs = xgbe_write_ext_mii_regs;\r\nhw_if->set_gpio = xgbe_set_gpio;\r\nhw_if->clr_gpio = xgbe_clr_gpio;\r\nhw_if->enable_tx = xgbe_enable_tx;\r\nhw_if->disable_tx = xgbe_disable_tx;\r\nhw_if->enable_rx = xgbe_enable_rx;\r\nhw_if->disable_rx = xgbe_disable_rx;\r\nhw_if->powerup_tx = xgbe_powerup_tx;\r\nhw_if->powerdown_tx = xgbe_powerdown_tx;\r\nhw_if->powerup_rx = xgbe_powerup_rx;\r\nhw_if->powerdown_rx = xgbe_powerdown_rx;\r\nhw_if->dev_xmit = xgbe_dev_xmit;\r\nhw_if->dev_read = xgbe_dev_read;\r\nhw_if->enable_int = xgbe_enable_int;\r\nhw_if->disable_int = xgbe_disable_int;\r\nhw_if->init = xgbe_init;\r\nhw_if->exit = xgbe_exit;\r\nhw_if->tx_desc_init = xgbe_tx_desc_init;\r\nhw_if->rx_desc_init = xgbe_rx_desc_init;\r\nhw_if->tx_desc_reset = xgbe_tx_desc_reset;\r\nhw_if->rx_desc_reset = xgbe_rx_desc_reset;\r\nhw_if->is_last_desc = xgbe_is_last_desc;\r\nhw_if->is_context_desc = xgbe_is_context_desc;\r\nhw_if->tx_start_xmit = xgbe_tx_start_xmit;\r\nhw_if->config_tx_flow_control = xgbe_config_tx_flow_control;\r\nhw_if->config_rx_flow_control = xgbe_config_rx_flow_control;\r\nhw_if->config_rx_coalesce = xgbe_config_rx_coalesce;\r\nhw_if->config_tx_coalesce = xgbe_config_tx_coalesce;\r\nhw_if->usec_to_riwt = xgbe_usec_to_riwt;\r\nhw_if->riwt_to_usec = xgbe_riwt_to_usec;\r\nhw_if->config_rx_threshold = xgbe_config_rx_threshold;\r\nhw_if->config_tx_threshold = xgbe_config_tx_threshold;\r\nhw_if->config_rsf_mode = xgbe_config_rsf_mode;\r\nhw_if->config_tsf_mode = xgbe_config_tsf_mode;\r\nhw_if->config_osp_mode = xgbe_config_osp_mode;\r\nhw_if->config_rx_pbl_val = xgbe_config_rx_pbl_val;\r\nhw_if->get_rx_pbl_val = xgbe_get_rx_pbl_val;\r\nhw_if->config_tx_pbl_val = xgbe_config_tx_pbl_val;\r\nhw_if->get_tx_pbl_val = xgbe_get_tx_pbl_val;\r\nhw_if->config_pblx8 = xgbe_config_pblx8;\r\nhw_if->tx_mmc_int = xgbe_tx_mmc_int;\r\nhw_if->rx_mmc_int = xgbe_rx_mmc_int;\r\nhw_if->read_mmc_stats = xgbe_read_mmc_stats;\r\nhw_if->config_tstamp = xgbe_config_tstamp;\r\nhw_if->update_tstamp_addend = xgbe_update_tstamp_addend;\r\nhw_if->set_tstamp_time = xgbe_set_tstamp_time;\r\nhw_if->get_tstamp_time = xgbe_get_tstamp_time;\r\nhw_if->get_tx_tstamp = xgbe_get_tx_tstamp;\r\nhw_if->config_tc = xgbe_config_tc;\r\nhw_if->config_dcb_tc = xgbe_config_dcb_tc;\r\nhw_if->config_dcb_pfc = xgbe_config_dcb_pfc;\r\nhw_if->enable_rss = xgbe_enable_rss;\r\nhw_if->disable_rss = xgbe_disable_rss;\r\nhw_if->set_rss_hash_key = xgbe_set_rss_hash_key;\r\nhw_if->set_rss_lookup_table = xgbe_set_rss_lookup_table;\r\nhw_if->disable_ecc_ded = xgbe_disable_ecc_ded;\r\nhw_if->disable_ecc_sec = xgbe_disable_ecc_sec;\r\nDBGPR("<--xgbe_init_function_ptrs\n");\r\n}
