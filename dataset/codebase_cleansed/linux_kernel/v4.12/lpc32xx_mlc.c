static int lpc32xx_ooblayout_ecc(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nif (section >= nand_chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = ((section + 1) * 16) - nand_chip->ecc.bytes;\r\noobregion->length = nand_chip->ecc.bytes;\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_ooblayout_free(struct mtd_info *mtd, int section,\r\nstruct mtd_oob_region *oobregion)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nif (section >= nand_chip->ecc.steps)\r\nreturn -ERANGE;\r\noobregion->offset = 16 * section;\r\noobregion->length = 16 - nand_chip->ecc.bytes;\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_nand_setup(struct lpc32xx_nand_host *host)\r\n{\r\nuint32_t clkrate, tmp;\r\nwritel(MLCCMD_RESET, MLC_CMD(host->io_base));\r\nudelay(1000);\r\nclkrate = clk_get_rate(host->clk);\r\nif (clkrate == 0)\r\nclkrate = 104000000;\r\nwritew(MLCLOCKPR_MAGIC, MLC_LOCK_PR(host->io_base));\r\ntmp = MLCICR_LARGEBLOCK | MLCICR_LONGADDR;\r\nwritel(tmp, MLC_ICR(host->io_base));\r\nwritew(MLCLOCKPR_MAGIC, MLC_LOCK_PR(host->io_base));\r\ntmp = 0;\r\ntmp |= MLCTIMEREG_TCEA_DELAY(clkrate / host->ncfg->tcea_delay + 1);\r\ntmp |= MLCTIMEREG_BUSY_DELAY(clkrate / host->ncfg->busy_delay + 1);\r\ntmp |= MLCTIMEREG_NAND_TA(clkrate / host->ncfg->nand_ta + 1);\r\ntmp |= MLCTIMEREG_RD_HIGH(clkrate / host->ncfg->rd_high + 1);\r\ntmp |= MLCTIMEREG_RD_LOW(clkrate / host->ncfg->rd_low);\r\ntmp |= MLCTIMEREG_WR_HIGH(clkrate / host->ncfg->wr_high + 1);\r\ntmp |= MLCTIMEREG_WR_LOW(clkrate / host->ncfg->wr_low);\r\nwritel(tmp, MLC_TIME_REG(host->io_base));\r\nwriteb(MLCIRQ_CONTROLLER_READY | MLCIRQ_NAND_READY,\r\nMLC_IRQ_MR(host->io_base));\r\nwritel(MLCCEH_NORMAL, MLC_CEH(host->io_base));\r\n}\r\nstatic void lpc32xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,\r\nunsigned int ctrl)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(nand_chip);\r\nif (cmd != NAND_CMD_NONE) {\r\nif (ctrl & NAND_CLE)\r\nwritel(cmd, MLC_CMD(host->io_base));\r\nelse\r\nwritel(cmd, MLC_ADDR(host->io_base));\r\n}\r\n}\r\nstatic int lpc32xx_nand_device_ready(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *nand_chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(nand_chip);\r\nif ((readb(MLC_ISR(host->io_base)) &\r\n(MLCISR_CONTROLLER_READY | MLCISR_NAND_READY)) ==\r\n(MLCISR_CONTROLLER_READY | MLCISR_NAND_READY))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic irqreturn_t lpc3xxx_nand_irq(int irq, struct lpc32xx_nand_host *host)\r\n{\r\nuint8_t sr;\r\nsr = readb(MLC_IRQ_SR(host->io_base));\r\nif (sr & MLCIRQ_NAND_READY)\r\ncomplete(&host->comp_nand);\r\nif (sr & MLCIRQ_CONTROLLER_READY)\r\ncomplete(&host->comp_controller);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int lpc32xx_waitfunc_nand(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nif (readb(MLC_ISR(host->io_base)) & MLCISR_NAND_READY)\r\ngoto exit;\r\nwait_for_completion(&host->comp_nand);\r\nwhile (!(readb(MLC_ISR(host->io_base)) & MLCISR_NAND_READY)) {\r\ndev_dbg(&mtd->dev, "Warning: NAND not ready.\n");\r\ncpu_relax();\r\n}\r\nexit:\r\nreturn NAND_STATUS_READY;\r\n}\r\nstatic int lpc32xx_waitfunc_controller(struct mtd_info *mtd,\r\nstruct nand_chip *chip)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nif (readb(MLC_ISR(host->io_base)) & MLCISR_CONTROLLER_READY)\r\ngoto exit;\r\nwait_for_completion(&host->comp_controller);\r\nwhile (!(readb(MLC_ISR(host->io_base)) &\r\nMLCISR_CONTROLLER_READY)) {\r\ndev_dbg(&mtd->dev, "Warning: Controller not ready.\n");\r\ncpu_relax();\r\n}\r\nexit:\r\nreturn NAND_STATUS_READY;\r\n}\r\nstatic int lpc32xx_waitfunc(struct mtd_info *mtd, struct nand_chip *chip)\r\n{\r\nlpc32xx_waitfunc_nand(mtd, chip);\r\nlpc32xx_waitfunc_controller(mtd, chip);\r\nreturn NAND_STATUS_READY;\r\n}\r\nstatic void lpc32xx_wp_enable(struct lpc32xx_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->ncfg->wp_gpio))\r\ngpio_set_value(host->ncfg->wp_gpio, 0);\r\n}\r\nstatic void lpc32xx_wp_disable(struct lpc32xx_nand_host *host)\r\n{\r\nif (gpio_is_valid(host->ncfg->wp_gpio))\r\ngpio_set_value(host->ncfg->wp_gpio, 1);\r\n}\r\nstatic void lpc32xx_dma_complete_func(void *completion)\r\n{\r\ncomplete(completion);\r\n}\r\nstatic int lpc32xx_xmit_dma(struct mtd_info *mtd, void *mem, int len,\r\nenum dma_transfer_direction dir)\r\n{\r\nstruct nand_chip *chip = mtd_to_nand(mtd);\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nstruct dma_async_tx_descriptor *desc;\r\nint flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT;\r\nint res;\r\nsg_init_one(&host->sgl, mem, len);\r\nres = dma_map_sg(host->dma_chan->device->dev, &host->sgl, 1,\r\nDMA_BIDIRECTIONAL);\r\nif (res != 1) {\r\ndev_err(mtd->dev.parent, "Failed to map sg list\n");\r\nreturn -ENXIO;\r\n}\r\ndesc = dmaengine_prep_slave_sg(host->dma_chan, &host->sgl, 1, dir,\r\nflags);\r\nif (!desc) {\r\ndev_err(mtd->dev.parent, "Failed to prepare slave sg\n");\r\ngoto out1;\r\n}\r\ninit_completion(&host->comp_dma);\r\ndesc->callback = lpc32xx_dma_complete_func;\r\ndesc->callback_param = &host->comp_dma;\r\ndmaengine_submit(desc);\r\ndma_async_issue_pending(host->dma_chan);\r\nwait_for_completion_timeout(&host->comp_dma, msecs_to_jiffies(1000));\r\ndma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\r\nDMA_BIDIRECTIONAL);\r\nreturn 0;\r\nout1:\r\ndma_unmap_sg(host->dma_chan->device->dev, &host->sgl, 1,\r\nDMA_BIDIRECTIONAL);\r\nreturn -ENXIO;\r\n}\r\nstatic int lpc32xx_read_page(struct mtd_info *mtd, struct nand_chip *chip,\r\nuint8_t *buf, int oob_required, int page)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nint i, j;\r\nuint8_t *oobbuf = chip->oob_poi;\r\nuint32_t mlc_isr;\r\nint res;\r\nuint8_t *dma_buf;\r\nbool dma_mapped;\r\nif ((void *)buf <= high_memory) {\r\ndma_buf = buf;\r\ndma_mapped = true;\r\n} else {\r\ndma_buf = host->dma_buf;\r\ndma_mapped = false;\r\n}\r\nchip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);\r\nfor (i = 0; i < host->mlcsubpages; i++) {\r\nwriteb(0x00, MLC_ECC_AUTO_DEC_REG(host->io_base));\r\nlpc32xx_waitfunc_controller(mtd, chip);\r\nmlc_isr = readl(MLC_ISR(host->io_base));\r\nif (mlc_isr & MLCISR_DECODER_FAILURE) {\r\nmtd->ecc_stats.failed++;\r\ndev_warn(&mtd->dev, "%s: DECODER_FAILURE\n", __func__);\r\n} else if (mlc_isr & MLCISR_ERRORS_DETECTED) {\r\nmtd->ecc_stats.corrected += ((mlc_isr >> 4) & 0x3) + 1;\r\n}\r\nif (use_dma) {\r\nres = lpc32xx_xmit_dma(mtd, dma_buf + i * 512, 512,\r\nDMA_DEV_TO_MEM);\r\nif (res)\r\nreturn res;\r\n} else {\r\nfor (j = 0; j < (512 >> 2); j++) {\r\n*((uint32_t *)(buf)) =\r\nreadl(MLC_BUFF(host->io_base));\r\nbuf += 4;\r\n}\r\n}\r\nfor (j = 0; j < (16 >> 2); j++) {\r\n*((uint32_t *)(oobbuf)) =\r\nreadl(MLC_BUFF(host->io_base));\r\noobbuf += 4;\r\n}\r\n}\r\nif (use_dma && !dma_mapped)\r\nmemcpy(buf, dma_buf, mtd->writesize);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_write_page_lowlevel(struct mtd_info *mtd,\r\nstruct nand_chip *chip,\r\nconst uint8_t *buf, int oob_required,\r\nint page)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nconst uint8_t *oobbuf = chip->oob_poi;\r\nuint8_t *dma_buf = (uint8_t *)buf;\r\nint res;\r\nint i, j;\r\nif (use_dma && (void *)buf >= high_memory) {\r\ndma_buf = host->dma_buf;\r\nmemcpy(dma_buf, buf, mtd->writesize);\r\n}\r\nfor (i = 0; i < host->mlcsubpages; i++) {\r\nwriteb(0x00, MLC_ECC_ENC_REG(host->io_base));\r\nif (use_dma) {\r\nres = lpc32xx_xmit_dma(mtd, dma_buf + i * 512, 512,\r\nDMA_MEM_TO_DEV);\r\nif (res)\r\nreturn res;\r\n} else {\r\nfor (j = 0; j < (512 >> 2); j++) {\r\nwritel(*((uint32_t *)(buf)),\r\nMLC_BUFF(host->io_base));\r\nbuf += 4;\r\n}\r\n}\r\nwritel(*((uint32_t *)(oobbuf)), MLC_BUFF(host->io_base));\r\noobbuf += 4;\r\nwritew(*((uint16_t *)(oobbuf)), MLC_BUFF(host->io_base));\r\noobbuf += 12;\r\nwriteb(0x00, MLC_ECC_AUTO_ENC_REG(host->io_base));\r\nlpc32xx_waitfunc_controller(mtd, chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_read_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nstruct lpc32xx_nand_host *host = nand_get_controller_data(chip);\r\nlpc32xx_read_page(mtd, chip, host->dummy_buf, 1, page);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_write_oob(struct mtd_info *mtd, struct nand_chip *chip,\r\nint page)\r\n{\r\nreturn 0;\r\n}\r\nstatic void lpc32xx_ecc_enable(struct mtd_info *mtd, int mode)\r\n{\r\n}\r\nstatic int lpc32xx_dma_setup(struct lpc32xx_nand_host *host)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\r\ndma_cap_mask_t mask;\r\nif (!host->pdata || !host->pdata->dma_filter) {\r\ndev_err(mtd->dev.parent, "no DMA platform data\n");\r\nreturn -ENOENT;\r\n}\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nhost->dma_chan = dma_request_channel(mask, host->pdata->dma_filter,\r\n"nand-mlc");\r\nif (!host->dma_chan) {\r\ndev_err(mtd->dev.parent, "Failed to request DMA channel\n");\r\nreturn -EBUSY;\r\n}\r\nhost->dma_slave_config.direction = DMA_DEV_TO_MEM;\r\nhost->dma_slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nhost->dma_slave_config.src_maxburst = 128;\r\nhost->dma_slave_config.dst_maxburst = 128;\r\nhost->dma_slave_config.device_fc = false;\r\nhost->dma_slave_config.src_addr = MLC_BUFF(host->io_base_phy);\r\nhost->dma_slave_config.dst_addr = MLC_BUFF(host->io_base_phy);\r\nif (dmaengine_slave_config(host->dma_chan, &host->dma_slave_config)) {\r\ndev_err(mtd->dev.parent, "Failed to setup DMA slave\n");\r\ngoto out1;\r\n}\r\nreturn 0;\r\nout1:\r\ndma_release_channel(host->dma_chan);\r\nreturn -ENXIO;\r\n}\r\nstatic struct lpc32xx_nand_cfg_mlc *lpc32xx_parse_dt(struct device *dev)\r\n{\r\nstruct lpc32xx_nand_cfg_mlc *ncfg;\r\nstruct device_node *np = dev->of_node;\r\nncfg = devm_kzalloc(dev, sizeof(*ncfg), GFP_KERNEL);\r\nif (!ncfg)\r\nreturn NULL;\r\nof_property_read_u32(np, "nxp,tcea-delay", &ncfg->tcea_delay);\r\nof_property_read_u32(np, "nxp,busy-delay", &ncfg->busy_delay);\r\nof_property_read_u32(np, "nxp,nand-ta", &ncfg->nand_ta);\r\nof_property_read_u32(np, "nxp,rd-high", &ncfg->rd_high);\r\nof_property_read_u32(np, "nxp,rd-low", &ncfg->rd_low);\r\nof_property_read_u32(np, "nxp,wr-high", &ncfg->wr_high);\r\nof_property_read_u32(np, "nxp,wr-low", &ncfg->wr_low);\r\nif (!ncfg->tcea_delay || !ncfg->busy_delay || !ncfg->nand_ta ||\r\n!ncfg->rd_high || !ncfg->rd_low || !ncfg->wr_high ||\r\n!ncfg->wr_low) {\r\ndev_err(dev, "chip parameters not specified correctly\n");\r\nreturn NULL;\r\n}\r\nncfg->wp_gpio = of_get_named_gpio(np, "gpios", 0);\r\nreturn ncfg;\r\n}\r\nstatic int lpc32xx_nand_probe(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_nand_host *host;\r\nstruct mtd_info *mtd;\r\nstruct nand_chip *nand_chip;\r\nstruct resource *rc;\r\nint res;\r\nhost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\r\nif (!host)\r\nreturn -ENOMEM;\r\nrc = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhost->io_base = devm_ioremap_resource(&pdev->dev, rc);\r\nif (IS_ERR(host->io_base))\r\nreturn PTR_ERR(host->io_base);\r\nhost->io_base_phy = rc->start;\r\nnand_chip = &host->nand_chip;\r\nmtd = nand_to_mtd(nand_chip);\r\nif (pdev->dev.of_node)\r\nhost->ncfg = lpc32xx_parse_dt(&pdev->dev);\r\nif (!host->ncfg) {\r\ndev_err(&pdev->dev,\r\n"Missing or bad NAND config from device tree\n");\r\nreturn -ENOENT;\r\n}\r\nif (host->ncfg->wp_gpio == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (gpio_is_valid(host->ncfg->wp_gpio) &&\r\ngpio_request(host->ncfg->wp_gpio, "NAND WP")) {\r\ndev_err(&pdev->dev, "GPIO not available\n");\r\nreturn -EBUSY;\r\n}\r\nlpc32xx_wp_disable(host);\r\nhost->pdata = dev_get_platdata(&pdev->dev);\r\nnand_set_controller_data(nand_chip, host);\r\nnand_set_flash_node(nand_chip, pdev->dev.of_node);\r\nmtd->dev.parent = &pdev->dev;\r\nhost->clk = clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(host->clk)) {\r\ndev_err(&pdev->dev, "Clock initialization failure\n");\r\nres = -ENOENT;\r\ngoto err_exit1;\r\n}\r\nclk_prepare_enable(host->clk);\r\nnand_chip->cmd_ctrl = lpc32xx_nand_cmd_ctrl;\r\nnand_chip->dev_ready = lpc32xx_nand_device_ready;\r\nnand_chip->chip_delay = 25;\r\nnand_chip->IO_ADDR_R = MLC_DATA(host->io_base);\r\nnand_chip->IO_ADDR_W = MLC_DATA(host->io_base);\r\nlpc32xx_nand_setup(host);\r\nplatform_set_drvdata(pdev, host);\r\nnand_chip->ecc.hwctl = lpc32xx_ecc_enable;\r\nnand_chip->ecc.read_page_raw = lpc32xx_read_page;\r\nnand_chip->ecc.read_page = lpc32xx_read_page;\r\nnand_chip->ecc.write_page_raw = lpc32xx_write_page_lowlevel;\r\nnand_chip->ecc.write_page = lpc32xx_write_page_lowlevel;\r\nnand_chip->ecc.write_oob = lpc32xx_write_oob;\r\nnand_chip->ecc.read_oob = lpc32xx_read_oob;\r\nnand_chip->ecc.strength = 4;\r\nnand_chip->ecc.bytes = 10;\r\nnand_chip->waitfunc = lpc32xx_waitfunc;\r\nnand_chip->options = NAND_NO_SUBPAGE_WRITE;\r\nnand_chip->bbt_options = NAND_BBT_USE_FLASH | NAND_BBT_NO_OOB;\r\nnand_chip->bbt_td = &lpc32xx_nand_bbt;\r\nnand_chip->bbt_md = &lpc32xx_nand_bbt_mirror;\r\nif (use_dma) {\r\nres = lpc32xx_dma_setup(host);\r\nif (res) {\r\nres = -EIO;\r\ngoto err_exit2;\r\n}\r\n}\r\nres = nand_scan_ident(mtd, 1, NULL);\r\nif (res)\r\ngoto err_exit3;\r\nhost->dma_buf = devm_kzalloc(&pdev->dev, mtd->writesize, GFP_KERNEL);\r\nif (!host->dma_buf) {\r\nres = -ENOMEM;\r\ngoto err_exit3;\r\n}\r\nhost->dummy_buf = devm_kzalloc(&pdev->dev, mtd->writesize, GFP_KERNEL);\r\nif (!host->dummy_buf) {\r\nres = -ENOMEM;\r\ngoto err_exit3;\r\n}\r\nnand_chip->ecc.mode = NAND_ECC_HW;\r\nnand_chip->ecc.size = 512;\r\nmtd_set_ooblayout(mtd, &lpc32xx_ooblayout_ops);\r\nhost->mlcsubpages = mtd->writesize / 512;\r\nreadb(MLC_IRQ_SR(host->io_base));\r\ninit_completion(&host->comp_nand);\r\ninit_completion(&host->comp_controller);\r\nhost->irq = platform_get_irq(pdev, 0);\r\nif (host->irq < 0) {\r\ndev_err(&pdev->dev, "failed to get platform irq\n");\r\nres = -EINVAL;\r\ngoto err_exit3;\r\n}\r\nif (request_irq(host->irq, (irq_handler_t)&lpc3xxx_nand_irq,\r\nIRQF_TRIGGER_HIGH, DRV_NAME, host)) {\r\ndev_err(&pdev->dev, "Error requesting NAND IRQ\n");\r\nres = -ENXIO;\r\ngoto err_exit3;\r\n}\r\nres = nand_scan_tail(mtd);\r\nif (res)\r\ngoto err_exit4;\r\nmtd->name = DRV_NAME;\r\nres = mtd_device_register(mtd, host->ncfg->parts,\r\nhost->ncfg->num_parts);\r\nif (!res)\r\nreturn res;\r\nnand_release(mtd);\r\nerr_exit4:\r\nfree_irq(host->irq, host);\r\nerr_exit3:\r\nif (use_dma)\r\ndma_release_channel(host->dma_chan);\r\nerr_exit2:\r\nclk_disable_unprepare(host->clk);\r\nclk_put(host->clk);\r\nerr_exit1:\r\nlpc32xx_wp_enable(host);\r\ngpio_free(host->ncfg->wp_gpio);\r\nreturn res;\r\n}\r\nstatic int lpc32xx_nand_remove(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\r\nstruct mtd_info *mtd = nand_to_mtd(&host->nand_chip);\r\nnand_release(mtd);\r\nfree_irq(host->irq, host);\r\nif (use_dma)\r\ndma_release_channel(host->dma_chan);\r\nclk_disable_unprepare(host->clk);\r\nclk_put(host->clk);\r\nlpc32xx_wp_enable(host);\r\ngpio_free(host->ncfg->wp_gpio);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_resume(struct platform_device *pdev)\r\n{\r\nstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\r\nclk_prepare_enable(host->clk);\r\nlpc32xx_nand_setup(host);\r\nlpc32xx_wp_disable(host);\r\nreturn 0;\r\n}\r\nstatic int lpc32xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)\r\n{\r\nstruct lpc32xx_nand_host *host = platform_get_drvdata(pdev);\r\nlpc32xx_wp_enable(host);\r\nclk_disable_unprepare(host->clk);\r\nreturn 0;\r\n}
