static inline u8 pin_to_offset(struct pinctrl_gpio_range *range, unsigned pin)\r\n{\r\nreturn pin - range->pin_base;\r\n}\r\nstatic inline u32 hwirq_to_pintbit(struct gpio_port *port, int hwirq)\r\n{\r\nreturn port->pint_assign ? BIT(hwirq) << PINT_HI_OFFSET : BIT(hwirq);\r\n}\r\nstatic struct gpio_pint *find_gpio_pint(unsigned id)\r\n{\r\nstruct gpio_pint *pint;\r\nint i = 0;\r\nlist_for_each_entry(pint, &adi_pint_list, node) {\r\nif (id == i)\r\nreturn pint;\r\ni++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic inline void port_setup(struct gpio_port *port, unsigned offset,\r\nbool use_for_gpio)\r\n{\r\nstruct gpio_port_t *regs = port->regs;\r\nif (use_for_gpio)\r\nwritew(readw(&regs->port_fer) & ~BIT(offset),\r\n&regs->port_fer);\r\nelse\r\nwritew(readw(&regs->port_fer) | BIT(offset), &regs->port_fer);\r\n}\r\nstatic inline void portmux_setup(struct gpio_port *port, unsigned offset,\r\nunsigned short function)\r\n{\r\nstruct gpio_port_t *regs = port->regs;\r\nu32 pmux;\r\npmux = readl(&regs->port_mux);\r\npmux &= ~(0x3 << (2 * offset));\r\npmux |= (function & 0x3) << (2 * offset);\r\nwritel(pmux, &regs->port_mux);\r\n}\r\nstatic inline u16 get_portmux(struct gpio_port *port, unsigned offset)\r\n{\r\nstruct gpio_port_t *regs = port->regs;\r\nu32 pmux = readl(&regs->port_mux);\r\nreturn pmux >> (2 * offset) & 0x3;\r\n}\r\nstatic void adi_gpio_ack_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *regs = port->pint->regs;\r\nunsigned pintbit = hwirq_to_pintbit(port, d->hwirq);\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\r\nif (readl(&regs->invert_set) & pintbit)\r\nwritel(pintbit, &regs->invert_clear);\r\nelse\r\nwritel(pintbit, &regs->invert_set);\r\n}\r\nwritel(pintbit, &regs->request);\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void adi_gpio_mask_ack_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *regs = port->pint->regs;\r\nunsigned pintbit = hwirq_to_pintbit(port, d->hwirq);\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nif (irqd_get_trigger_type(d) == IRQ_TYPE_EDGE_BOTH) {\r\nif (readl(&regs->invert_set) & pintbit)\r\nwritel(pintbit, &regs->invert_clear);\r\nelse\r\nwritel(pintbit, &regs->invert_set);\r\n}\r\nwritel(pintbit, &regs->request);\r\nwritel(pintbit, &regs->mask_clear);\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void adi_gpio_mask_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *regs = port->pint->regs;\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nwritel(hwirq_to_pintbit(port, d->hwirq), &regs->mask_clear);\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic void adi_gpio_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *regs = port->pint->regs;\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nwritel(hwirq_to_pintbit(port, d->hwirq), &regs->mask_set);\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic unsigned int adi_gpio_irq_startup(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *regs;\r\nif (!port) {\r\npr_err("GPIO IRQ %d :Not exist\n", d->irq);\r\nreturn -ENODEV;\r\n}\r\nregs = port->pint->regs;\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nport_setup(port, d->hwirq, true);\r\nwritew(BIT(d->hwirq), &port->regs->dir_clear);\r\nwritew(readw(&port->regs->inen) | BIT(d->hwirq), &port->regs->inen);\r\nwritel(hwirq_to_pintbit(port, d->hwirq), &regs->mask_set);\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void adi_gpio_irq_shutdown(struct irq_data *d)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *regs = port->pint->regs;\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nwritel(hwirq_to_pintbit(port, d->hwirq), &regs->mask_clear);\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int adi_gpio_irq_type(struct irq_data *d, unsigned int type)\r\n{\r\nunsigned long flags;\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nstruct gpio_pint_regs *pint_regs;\r\nunsigned pintmask;\r\nunsigned int irq = d->irq;\r\nint ret = 0;\r\nchar buf[16];\r\nif (!port) {\r\npr_err("GPIO IRQ %d :Not exist\n", d->irq);\r\nreturn -ENODEV;\r\n}\r\npint_regs = port->pint->regs;\r\npintmask = hwirq_to_pintbit(port, d->hwirq);\r\nspin_lock_irqsave(&port->lock, flags);\r\nspin_lock(&port->pint->lock);\r\nif (type == IRQ_TYPE_PROBE)\r\ntype = IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING;\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING |\r\nIRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW)) {\r\nsnprintf(buf, 16, "gpio-irq%u", irq);\r\nport_setup(port, d->hwirq, true);\r\n} else\r\ngoto out;\r\nif ((type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_LEVEL_LOW)))\r\nwritel(pintmask, &pint_regs->invert_set);\r\nelse\r\nwritel(pintmask, &pint_regs->invert_clear);\r\nif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\nif (gpio_get_value(port->chip.base + d->hwirq))\r\nwritel(pintmask, &pint_regs->invert_set);\r\nelse\r\nwritel(pintmask, &pint_regs->invert_clear);\r\n}\r\nif (type & (IRQ_TYPE_EDGE_RISING | IRQ_TYPE_EDGE_FALLING)) {\r\nwritel(pintmask, &pint_regs->edge_set);\r\nirq_set_handler_locked(d, handle_edge_irq);\r\n} else {\r\nwritel(pintmask, &pint_regs->edge_clear);\r\nirq_set_handler_locked(d, handle_level_irq);\r\n}\r\nout:\r\nspin_unlock(&port->pint->lock);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int adi_gpio_set_wake(struct irq_data *d, unsigned int state)\r\n{\r\nstruct gpio_port *port = irq_data_get_irq_chip_data(d);\r\nif (!port || !port->pint || port->pint->irq != d->irq)\r\nreturn -EINVAL;\r\n#ifndef SEC_GCTL\r\nadi_internal_set_wake(port->pint->irq, state);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int adi_pint_suspend(void)\r\n{\r\nstruct gpio_pint *pint;\r\nlist_for_each_entry(pint, &adi_pint_list, node) {\r\nwritel(0xffffffff, &pint->regs->mask_clear);\r\npint->saved_data.assign = readl(&pint->regs->assign);\r\npint->saved_data.edge_set = readl(&pint->regs->edge_set);\r\npint->saved_data.invert_set = readl(&pint->regs->invert_set);\r\n}\r\nreturn 0;\r\n}\r\nstatic void adi_pint_resume(void)\r\n{\r\nstruct gpio_pint *pint;\r\nlist_for_each_entry(pint, &adi_pint_list, node) {\r\nwritel(pint->saved_data.assign, &pint->regs->assign);\r\nwritel(pint->saved_data.edge_set, &pint->regs->edge_set);\r\nwritel(pint->saved_data.invert_set, &pint->regs->invert_set);\r\n}\r\n}\r\nstatic int adi_gpio_suspend(void)\r\n{\r\nstruct gpio_port *port;\r\nlist_for_each_entry(port, &adi_gpio_port_list, node) {\r\nport->saved_data.fer = readw(&port->regs->port_fer);\r\nport->saved_data.mux = readl(&port->regs->port_mux);\r\nport->saved_data.data = readw(&port->regs->data);\r\nport->saved_data.inen = readw(&port->regs->inen);\r\nport->saved_data.dir = readw(&port->regs->dir_set);\r\n}\r\nreturn adi_pint_suspend();\r\n}\r\nstatic void adi_gpio_resume(void)\r\n{\r\nstruct gpio_port *port;\r\nadi_pint_resume();\r\nlist_for_each_entry(port, &adi_gpio_port_list, node) {\r\nwritel(port->saved_data.mux, &port->regs->port_mux);\r\nwritew(port->saved_data.fer, &port->regs->port_fer);\r\nwritew(port->saved_data.inen, &port->regs->inen);\r\nwritew(port->saved_data.data & port->saved_data.dir,\r\n&port->regs->data_set);\r\nwritew(port->saved_data.dir, &port->regs->dir_set);\r\n}\r\n}\r\nstatic inline void preflow_handler(struct irq_desc *desc)\r\n{\r\nif (desc->preflow_handler)\r\ndesc->preflow_handler(&desc->irq_data);\r\n}\r\nstatic inline void preflow_handler(struct irq_desc *desc) { }\r\nstatic void adi_gpio_handle_pint_irq(struct irq_desc *desc)\r\n{\r\nu32 request;\r\nu32 level_mask, hwirq;\r\nbool umask = false;\r\nstruct gpio_pint *pint = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nstruct gpio_pint_regs *regs = pint->regs;\r\nstruct irq_domain *domain;\r\npreflow_handler(desc);\r\nchained_irq_enter(chip, desc);\r\nrequest = readl(&regs->request);\r\nlevel_mask = readl(&regs->edge_set) & request;\r\nhwirq = 0;\r\ndomain = pint->domain[0];\r\nwhile (request) {\r\nif (hwirq == PINT_HI_OFFSET)\r\ndomain = pint->domain[1];\r\nif (request & 1) {\r\nif (level_mask & BIT(hwirq)) {\r\numask = true;\r\nchained_irq_exit(chip, desc);\r\n}\r\ngeneric_handle_irq(irq_find_mapping(domain,\r\nhwirq % PINT_HI_OFFSET));\r\n}\r\nhwirq++;\r\nrequest >>= 1;\r\n}\r\nif (!umask)\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int adi_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pinctrl->soc->ngroups;\r\n}\r\nstatic const char *adi_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pinctrl->soc->groups[selector].name;\r\n}\r\nstatic int adi_get_group_pins(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pinctrl->soc->groups[selector].pins;\r\n*num_pins = pinctrl->soc->groups[selector].num;\r\nreturn 0;\r\n}\r\nstatic int adi_pinmux_set(struct pinctrl_dev *pctldev, unsigned func_id,\r\nunsigned group_id)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct gpio_port *port;\r\nstruct pinctrl_gpio_range *range;\r\nunsigned long flags;\r\nunsigned short *mux, pin;\r\nmux = (unsigned short *)pinctrl->soc->groups[group_id].mux;\r\nwhile (*mux) {\r\npin = P_IDENT(*mux);\r\nrange = pinctrl_find_gpio_range_from_pin(pctldev, pin);\r\nif (range == NULL)\r\nreturn -ENODEV;\r\nport = gpiochip_get_data(range->gc);\r\nspin_lock_irqsave(&port->lock, flags);\r\nportmux_setup(port, pin_to_offset(range, pin),\r\nP_FUNCT2MUX(*mux));\r\nport_setup(port, pin_to_offset(range, pin), false);\r\nmux++;\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adi_pinmux_get_funcs_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pinctrl->soc->nfunctions;\r\n}\r\nstatic const char *adi_pinmux_get_func_name(struct pinctrl_dev *pctldev,\r\nunsigned selector)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pinctrl->soc->functions[selector].name;\r\n}\r\nstatic int adi_pinmux_get_groups(struct pinctrl_dev *pctldev, unsigned selector,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct adi_pinctrl *pinctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pinctrl->soc->functions[selector].groups;\r\n*num_groups = pinctrl->soc->functions[selector].num_groups;\r\nreturn 0;\r\n}\r\nstatic int adi_pinmux_request_gpio(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned pin)\r\n{\r\nstruct gpio_port *port;\r\nunsigned long flags;\r\nu8 offset;\r\nport = gpiochip_get_data(range->gc);\r\noffset = pin_to_offset(range, pin);\r\nspin_lock_irqsave(&port->lock, flags);\r\nport_setup(port, offset, true);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_port *port;\r\nunsigned long flags;\r\nport = gpiochip_get_data(chip);\r\nspin_lock_irqsave(&port->lock, flags);\r\nwritew(BIT(offset), &port->regs->dir_clear);\r\nwritew(readw(&port->regs->inen) | BIT(offset), &port->regs->inen);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void adi_gpio_set_value(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct gpio_port *port = gpiochip_get_data(chip);\r\nstruct gpio_port_t *regs = port->regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nif (value)\r\nwritew(BIT(offset), &regs->data_set);\r\nelse\r\nwritew(BIT(offset), &regs->data_clear);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\n}\r\nstatic int adi_gpio_direction_output(struct gpio_chip *chip, unsigned offset,\r\nint value)\r\n{\r\nstruct gpio_port *port = gpiochip_get_data(chip);\r\nstruct gpio_port_t *regs = port->regs;\r\nunsigned long flags;\r\nspin_lock_irqsave(&port->lock, flags);\r\nwritew(readw(&regs->inen) & ~BIT(offset), &regs->inen);\r\nif (value)\r\nwritew(BIT(offset), &regs->data_set);\r\nelse\r\nwritew(BIT(offset), &regs->data_clear);\r\nwritew(BIT(offset), &regs->dir_set);\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_get_value(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_port *port = gpiochip_get_data(chip);\r\nstruct gpio_port_t *regs = port->regs;\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&port->lock, flags);\r\nret = !!(readw(&regs->data) & BIT(offset));\r\nspin_unlock_irqrestore(&port->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int adi_gpio_to_irq(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct gpio_port *port = gpiochip_get_data(chip);\r\nif (port->irq_base >= 0)\r\nreturn irq_find_mapping(port->domain, offset);\r\nelse\r\nreturn irq_create_mapping(port->domain, offset);\r\n}\r\nstatic int adi_pint_map_port(struct gpio_pint *pint, bool assign, u8 map,\r\nstruct irq_domain *domain)\r\n{\r\nstruct gpio_pint_regs *regs = pint->regs;\r\nu32 map_mask;\r\nif (pint->map_count > 1)\r\nreturn -EINVAL;\r\npint->map_count++;\r\nmap_mask = (map << 8) | map;\r\nif (assign) {\r\nmap_mask <<= PINT_HI_OFFSET;\r\nwritel((readl(&regs->assign) & 0xFFFF) | map_mask,\r\n&regs->assign);\r\n} else\r\nwritel((readl(&regs->assign) & 0xFFFF0000) | map_mask,\r\n&regs->assign);\r\npint->domain[assign] = domain;\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_pint_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *res;\r\nstruct gpio_pint *pint;\r\npint = devm_kzalloc(dev, sizeof(struct gpio_pint), GFP_KERNEL);\r\nif (!pint) {\r\ndev_err(dev, "Memory alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npint->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pint->base))\r\nreturn PTR_ERR(pint->base);\r\npint->regs = (struct gpio_pint_regs *)pint->base;\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res) {\r\ndev_err(dev, "Invalid IRQ resource\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_init(&pint->lock);\r\npint->irq = res->start;\r\npint->pint_map_port = adi_pint_map_port;\r\nplatform_set_drvdata(pdev, pint);\r\nirq_set_chained_handler_and_data(pint->irq, adi_gpio_handle_pint_irq,\r\npint);\r\nlist_add_tail(&pint->node, &adi_pint_list);\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_pint_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_pint *pint = platform_get_drvdata(pdev);\r\nlist_del(&pint->node);\r\nirq_set_handler(pint->irq, handle_simple_irq);\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_irq_map(struct irq_domain *d, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct gpio_port *port = d->host_data;\r\nif (!port)\r\nreturn -EINVAL;\r\nirq_set_chip_data(irq, port);\r\nirq_set_chip_and_handler(irq, &adi_gpio_irqchip,\r\nhandle_level_irq);\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_init_int(struct gpio_port *port)\r\n{\r\nstruct device_node *node = port->dev->of_node;\r\nstruct gpio_pint *pint = port->pint;\r\nint ret;\r\nport->domain = irq_domain_add_linear(node, port->width,\r\n&adi_gpio_irq_domain_ops, port);\r\nif (!port->domain) {\r\ndev_err(port->dev, "Failed to create irqdomain\n");\r\nreturn -ENOSYS;\r\n}\r\nret = pint->pint_map_port(port->pint, port->pint_assign,\r\nport->pint_map, port->domain);\r\nif (ret)\r\nreturn ret;\r\nif (port->irq_base >= 0) {\r\nret = irq_create_strict_mappings(port->domain, port->irq_base,\r\n0, port->width);\r\nif (ret) {\r\ndev_err(port->dev, "Couldn't associate to domain\n");\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int adi_gpio_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nconst struct adi_pinctrl_gpio_platform_data *pdata;\r\nstruct resource *res;\r\nstruct gpio_port *port;\r\nchar pinctrl_devname[DEVNAME_SIZE];\r\nstatic int gpio;\r\nint ret = 0;\r\npdata = dev->platform_data;\r\nif (!pdata)\r\nreturn -EINVAL;\r\nport = devm_kzalloc(dev, sizeof(struct gpio_port), GFP_KERNEL);\r\nif (!port) {\r\ndev_err(dev, "Memory alloc failed\n");\r\nreturn -ENOMEM;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nport->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(port->base))\r\nreturn PTR_ERR(port->base);\r\nres = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!res)\r\nport->irq_base = -1;\r\nelse\r\nport->irq_base = res->start;\r\nport->width = pdata->port_width;\r\nport->dev = dev;\r\nport->regs = (struct gpio_port_t *)port->base;\r\nport->pint_assign = pdata->pint_assign;\r\nport->pint_map = pdata->pint_map;\r\nport->pint = find_gpio_pint(pdata->pint_id);\r\nif (port->pint) {\r\nret = adi_gpio_init_int(port);\r\nif (ret)\r\nreturn ret;\r\n}\r\nspin_lock_init(&port->lock);\r\nplatform_set_drvdata(pdev, port);\r\nport->chip.label = "adi-gpio";\r\nport->chip.direction_input = adi_gpio_direction_input;\r\nport->chip.get = adi_gpio_get_value;\r\nport->chip.direction_output = adi_gpio_direction_output;\r\nport->chip.set = adi_gpio_set_value;\r\nport->chip.request = gpiochip_generic_request,\r\nport->chip.free = gpiochip_generic_free,\r\nport->chip.to_irq = adi_gpio_to_irq;\r\nif (pdata->port_gpio_base > 0)\r\nport->chip.base = pdata->port_gpio_base;\r\nelse\r\nport->chip.base = gpio;\r\nport->chip.ngpio = port->width;\r\ngpio = port->chip.base + port->width;\r\nret = gpiochip_add_data(&port->chip, port);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Fail to add GPIO chip.\n");\r\ngoto out_remove_domain;\r\n}\r\nsnprintf(pinctrl_devname, DEVNAME_SIZE, "pinctrl-adi2.%d",\r\npdata->pinctrl_id);\r\npinctrl_devname[DEVNAME_SIZE - 1] = 0;\r\nret = gpiochip_add_pin_range(&port->chip, pinctrl_devname,\r\n0, pdata->port_pin_base, port->width);\r\nif (ret) {\r\ndev_err(&pdev->dev, "Fail to add pin range to %s.\n",\r\npinctrl_devname);\r\ngoto out_remove_gpiochip;\r\n}\r\nlist_add_tail(&port->node, &adi_gpio_port_list);\r\nreturn 0;\r\nout_remove_gpiochip:\r\ngpiochip_remove(&port->chip);\r\nout_remove_domain:\r\nif (port->pint)\r\nirq_domain_remove(port->domain);\r\nreturn ret;\r\n}\r\nstatic int adi_gpio_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_port *port = platform_get_drvdata(pdev);\r\nu8 offset;\r\nlist_del(&port->node);\r\ngpiochip_remove(&port->chip);\r\nif (port->pint) {\r\nfor (offset = 0; offset < port->width; offset++)\r\nirq_dispose_mapping(irq_find_mapping(port->domain,\r\noffset));\r\nirq_domain_remove(port->domain);\r\n}\r\nreturn 0;\r\n}\r\nstatic int adi_pinctrl_probe(struct platform_device *pdev)\r\n{\r\nstruct adi_pinctrl *pinctrl;\r\npinctrl = devm_kzalloc(&pdev->dev, sizeof(*pinctrl), GFP_KERNEL);\r\nif (!pinctrl)\r\nreturn -ENOMEM;\r\npinctrl->dev = &pdev->dev;\r\nadi_pinctrl_soc_init(&pinctrl->soc);\r\nadi_pinmux_desc.pins = pinctrl->soc->pins;\r\nadi_pinmux_desc.npins = pinctrl->soc->npins;\r\npinctrl->pctl = devm_pinctrl_register(&pdev->dev, &adi_pinmux_desc,\r\npinctrl);\r\nif (IS_ERR(pinctrl->pctl)) {\r\ndev_err(&pdev->dev, "could not register pinctrl ADI2 driver\n");\r\nreturn PTR_ERR(pinctrl->pctl);\r\n}\r\nplatform_set_drvdata(pdev, pinctrl);\r\nreturn 0;\r\n}\r\nstatic int __init adi_pinctrl_setup(void)\r\n{\r\nint ret;\r\nret = platform_register_drivers(drivers, ARRAY_SIZE(drivers));\r\nif (ret)\r\nreturn ret;\r\n#ifdef CONFIG_PM\r\nregister_syscore_ops(&gpio_pm_syscore_ops);\r\n#endif\r\nreturn 0;\r\n}
