u32 inet6_ehashfn(const struct net *net,\r\nconst struct in6_addr *laddr, const u16 lport,\r\nconst struct in6_addr *faddr, const __be16 fport)\r\n{\r\nstatic u32 inet6_ehash_secret __read_mostly;\r\nstatic u32 ipv6_hash_secret __read_mostly;\r\nu32 lhash, fhash;\r\nnet_get_random_once(&inet6_ehash_secret, sizeof(inet6_ehash_secret));\r\nnet_get_random_once(&ipv6_hash_secret, sizeof(ipv6_hash_secret));\r\nlhash = (__force u32)laddr->s6_addr32[3];\r\nfhash = __ipv6_addr_jhash(faddr, ipv6_hash_secret);\r\nreturn __inet6_ehashfn(lhash, lport, fhash, fport,\r\ninet6_ehash_secret + net_hash_mix(net));\r\n}\r\nstruct sock *__inet6_lookup_established(struct net *net,\r\nstruct inet_hashinfo *hashinfo,\r\nconst struct in6_addr *saddr,\r\nconst __be16 sport,\r\nconst struct in6_addr *daddr,\r\nconst u16 hnum,\r\nconst int dif)\r\n{\r\nstruct sock *sk;\r\nconst struct hlist_nulls_node *node;\r\nconst __portpair ports = INET_COMBINED_PORTS(sport, hnum);\r\nunsigned int hash = inet6_ehashfn(net, daddr, hnum, saddr, sport);\r\nunsigned int slot = hash & hashinfo->ehash_mask;\r\nstruct inet_ehash_bucket *head = &hashinfo->ehash[slot];\r\nbegin:\r\nsk_nulls_for_each_rcu(sk, node, &head->chain) {\r\nif (sk->sk_hash != hash)\r\ncontinue;\r\nif (!INET6_MATCH(sk, net, saddr, daddr, ports, dif))\r\ncontinue;\r\nif (unlikely(!atomic_inc_not_zero(&sk->sk_refcnt)))\r\ngoto out;\r\nif (unlikely(!INET6_MATCH(sk, net, saddr, daddr, ports, dif))) {\r\nsock_gen_put(sk);\r\ngoto begin;\r\n}\r\ngoto found;\r\n}\r\nif (get_nulls_value(node) != slot)\r\ngoto begin;\r\nout:\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic inline int compute_score(struct sock *sk, struct net *net,\r\nconst unsigned short hnum,\r\nconst struct in6_addr *daddr,\r\nconst int dif, bool exact_dif)\r\n{\r\nint score = -1;\r\nif (net_eq(sock_net(sk), net) && inet_sk(sk)->inet_num == hnum &&\r\nsk->sk_family == PF_INET6) {\r\nscore = 1;\r\nif (!ipv6_addr_any(&sk->sk_v6_rcv_saddr)) {\r\nif (!ipv6_addr_equal(&sk->sk_v6_rcv_saddr, daddr))\r\nreturn -1;\r\nscore++;\r\n}\r\nif (sk->sk_bound_dev_if || exact_dif) {\r\nif (sk->sk_bound_dev_if != dif)\r\nreturn -1;\r\nscore++;\r\n}\r\nif (sk->sk_incoming_cpu == raw_smp_processor_id())\r\nscore++;\r\n}\r\nreturn score;\r\n}\r\nstruct sock *inet6_lookup_listener(struct net *net,\r\nstruct inet_hashinfo *hashinfo,\r\nstruct sk_buff *skb, int doff,\r\nconst struct in6_addr *saddr,\r\nconst __be16 sport, const struct in6_addr *daddr,\r\nconst unsigned short hnum, const int dif)\r\n{\r\nunsigned int hash = inet_lhashfn(net, hnum);\r\nstruct inet_listen_hashbucket *ilb = &hashinfo->listening_hash[hash];\r\nint score, hiscore = 0, matches = 0, reuseport = 0;\r\nbool exact_dif = inet6_exact_dif_match(net, skb);\r\nstruct sock *sk, *result = NULL;\r\nu32 phash = 0;\r\nsk_for_each(sk, &ilb->head) {\r\nscore = compute_score(sk, net, hnum, daddr, dif, exact_dif);\r\nif (score > hiscore) {\r\nreuseport = sk->sk_reuseport;\r\nif (reuseport) {\r\nphash = inet6_ehashfn(net, daddr, hnum,\r\nsaddr, sport);\r\nresult = reuseport_select_sock(sk, phash,\r\nskb, doff);\r\nif (result)\r\nreturn result;\r\nmatches = 1;\r\n}\r\nresult = sk;\r\nhiscore = score;\r\n} else if (score == hiscore && reuseport) {\r\nmatches++;\r\nif (reciprocal_scale(phash, matches) == 0)\r\nresult = sk;\r\nphash = next_pseudo_random32(phash);\r\n}\r\n}\r\nreturn result;\r\n}\r\nstruct sock *inet6_lookup(struct net *net, struct inet_hashinfo *hashinfo,\r\nstruct sk_buff *skb, int doff,\r\nconst struct in6_addr *saddr, const __be16 sport,\r\nconst struct in6_addr *daddr, const __be16 dport,\r\nconst int dif)\r\n{\r\nstruct sock *sk;\r\nbool refcounted;\r\nsk = __inet6_lookup(net, hashinfo, skb, doff, saddr, sport, daddr,\r\nntohs(dport), dif, &refcounted);\r\nif (sk && !refcounted && !atomic_inc_not_zero(&sk->sk_refcnt))\r\nsk = NULL;\r\nreturn sk;\r\n}\r\nstatic int __inet6_check_established(struct inet_timewait_death_row *death_row,\r\nstruct sock *sk, const __u16 lport,\r\nstruct inet_timewait_sock **twp)\r\n{\r\nstruct inet_hashinfo *hinfo = death_row->hashinfo;\r\nstruct inet_sock *inet = inet_sk(sk);\r\nconst struct in6_addr *daddr = &sk->sk_v6_rcv_saddr;\r\nconst struct in6_addr *saddr = &sk->sk_v6_daddr;\r\nconst int dif = sk->sk_bound_dev_if;\r\nconst __portpair ports = INET_COMBINED_PORTS(inet->inet_dport, lport);\r\nstruct net *net = sock_net(sk);\r\nconst unsigned int hash = inet6_ehashfn(net, daddr, lport, saddr,\r\ninet->inet_dport);\r\nstruct inet_ehash_bucket *head = inet_ehash_bucket(hinfo, hash);\r\nspinlock_t *lock = inet_ehash_lockp(hinfo, hash);\r\nstruct sock *sk2;\r\nconst struct hlist_nulls_node *node;\r\nstruct inet_timewait_sock *tw = NULL;\r\nspin_lock(lock);\r\nsk_nulls_for_each(sk2, node, &head->chain) {\r\nif (sk2->sk_hash != hash)\r\ncontinue;\r\nif (likely(INET6_MATCH(sk2, net, saddr, daddr, ports, dif))) {\r\nif (sk2->sk_state == TCP_TIME_WAIT) {\r\ntw = inet_twsk(sk2);\r\nif (twsk_unique(sk, sk2, twp))\r\nbreak;\r\n}\r\ngoto not_unique;\r\n}\r\n}\r\ninet->inet_num = lport;\r\ninet->inet_sport = htons(lport);\r\nsk->sk_hash = hash;\r\nWARN_ON(!sk_unhashed(sk));\r\n__sk_nulls_add_node_rcu(sk, &head->chain);\r\nif (tw) {\r\nsk_nulls_del_node_init_rcu((struct sock *)tw);\r\n__NET_INC_STATS(net, LINUX_MIB_TIMEWAITRECYCLED);\r\n}\r\nspin_unlock(lock);\r\nsock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);\r\nif (twp) {\r\n*twp = tw;\r\n} else if (tw) {\r\ninet_twsk_deschedule_put(tw);\r\n}\r\nreturn 0;\r\nnot_unique:\r\nspin_unlock(lock);\r\nreturn -EADDRNOTAVAIL;\r\n}\r\nstatic u32 inet6_sk_port_offset(const struct sock *sk)\r\n{\r\nconst struct inet_sock *inet = inet_sk(sk);\r\nreturn secure_ipv6_port_ephemeral(sk->sk_v6_rcv_saddr.s6_addr32,\r\nsk->sk_v6_daddr.s6_addr32,\r\ninet->inet_dport);\r\n}\r\nint inet6_hash_connect(struct inet_timewait_death_row *death_row,\r\nstruct sock *sk)\r\n{\r\nu32 port_offset = 0;\r\nif (!inet_sk(sk)->inet_num)\r\nport_offset = inet6_sk_port_offset(sk);\r\nreturn __inet_hash_connect(death_row, sk, port_offset,\r\n__inet6_check_established);\r\n}\r\nint inet6_hash(struct sock *sk)\r\n{\r\nint err = 0;\r\nif (sk->sk_state != TCP_CLOSE) {\r\nlocal_bh_disable();\r\nerr = __inet_hash(sk, NULL);\r\nlocal_bh_enable();\r\n}\r\nreturn err;\r\n}
