static inline void lcd_write_control(struct fb_info *info, u8 control)\r\n{\r\nwritel((u32)control << 24, info->screen_base);\r\n}\r\nstatic inline u8 lcd_read_control(struct fb_info *info)\r\n{\r\nreturn readl(info->screen_base) >> 24;\r\n}\r\nstatic inline void lcd_write_data(struct fb_info *info, u8 data)\r\n{\r\nwritel((u32)data << 24, info->screen_base + LCD_DATA_REG_OFFSET);\r\n}\r\nstatic inline u8 lcd_read_data(struct fb_info *info)\r\n{\r\nreturn readl(info->screen_base + LCD_DATA_REG_OFFSET) >> 24;\r\n}\r\nstatic int lcd_busy_wait(struct fb_info *info)\r\n{\r\nu8 val = 0;\r\nint timeout = 10, retval = 0;\r\ndo {\r\nval = lcd_read_control(info);\r\nval &= LCD_BUSY;\r\nif (val != LCD_BUSY)\r\nbreak;\r\nif (msleep_interruptible(1))\r\nreturn -EINTR;\r\ntimeout--;\r\n} while (timeout);\r\nif (val == LCD_BUSY)\r\nretval = -EBUSY;\r\nreturn retval;\r\n}\r\nstatic void lcd_clear(struct fb_info *info)\r\n{\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\nudelay(150);\r\nlcd_write_control(info, LCD_PRERESET);\r\n}\r\nudelay(150);\r\nlcd_write_control(info, LCD_CLEAR);\r\nudelay(150);\r\nlcd_write_control(info, LCD_RESET);\r\n}\r\nstatic ssize_t cobalt_lcdfb_read(struct fb_info *info, char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar src[LCD_CHARS_MAX];\r\nunsigned long pos;\r\nint len, retval = 0;\r\npos = *ppos;\r\nif (pos >= LCD_CHARS_MAX || count == 0)\r\nreturn 0;\r\nif (count > LCD_CHARS_MAX)\r\ncount = LCD_CHARS_MAX;\r\nif (pos + count > LCD_CHARS_MAX)\r\ncount = LCD_CHARS_MAX - pos;\r\nfor (len = 0; len < count; len++) {\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nbreak;\r\nlcd_write_control(info, LCD_TEXT_POS(pos));\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nbreak;\r\nsrc[len] = lcd_read_data(info);\r\nif (pos == 0x0f)\r\npos = 0x40;\r\nelse\r\npos++;\r\n}\r\nif (retval < 0 && signal_pending(current))\r\nreturn -ERESTARTSYS;\r\nif (copy_to_user(buf, src, len))\r\nreturn -EFAULT;\r\n*ppos += len;\r\nreturn len;\r\n}\r\nstatic ssize_t cobalt_lcdfb_write(struct fb_info *info, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar dst[LCD_CHARS_MAX];\r\nunsigned long pos;\r\nint len, retval = 0;\r\npos = *ppos;\r\nif (pos >= LCD_CHARS_MAX || count == 0)\r\nreturn 0;\r\nif (count > LCD_CHARS_MAX)\r\ncount = LCD_CHARS_MAX;\r\nif (pos + count > LCD_CHARS_MAX)\r\ncount = LCD_CHARS_MAX - pos;\r\nif (copy_from_user(dst, buf, count))\r\nreturn -EFAULT;\r\nfor (len = 0; len < count; len++) {\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nbreak;\r\nlcd_write_control(info, LCD_TEXT_POS(pos));\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nbreak;\r\nlcd_write_data(info, dst[len]);\r\nif (pos == 0x0f)\r\npos = 0x40;\r\nelse\r\npos++;\r\n}\r\nif (retval < 0 && signal_pending(current))\r\nreturn -ERESTARTSYS;\r\n*ppos += len;\r\nreturn len;\r\n}\r\nstatic int cobalt_lcdfb_blank(int blank_mode, struct fb_info *info)\r\n{\r\nint retval;\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nreturn retval;\r\nswitch (blank_mode) {\r\ncase FB_BLANK_UNBLANK:\r\nlcd_write_control(info, LCD_ON);\r\nbreak;\r\ndefault:\r\nlcd_write_control(info, LCD_OFF);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cobalt_lcdfb_cursor(struct fb_info *info, struct fb_cursor *cursor)\r\n{\r\nu32 x, y;\r\nint retval;\r\nswitch (cursor->set) {\r\ncase FB_CUR_SETPOS:\r\nx = cursor->image.dx;\r\ny = cursor->image.dy;\r\nif (x >= LCD_XRES_MAX || y >= LCD_YRES_MAX)\r\nreturn -EINVAL;\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nreturn retval;\r\nlcd_write_control(info,\r\nLCD_TEXT_POS(info->fix.line_length * y + x));\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nretval = lcd_busy_wait(info);\r\nif (retval < 0)\r\nreturn retval;\r\nif (cursor->enable)\r\nlcd_write_control(info, LCD_CURSOR_ON);\r\nelse\r\nlcd_write_control(info, LCD_CURSOR_OFF);\r\nreturn 0;\r\n}\r\nstatic int cobalt_lcdfb_probe(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\nstruct resource *res;\r\nint retval;\r\ninfo = framebuffer_alloc(0, &dev->dev);\r\nif (!info)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(dev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\nframebuffer_release(info);\r\nreturn -EBUSY;\r\n}\r\ninfo->screen_size = resource_size(res);\r\ninfo->screen_base = devm_ioremap(&dev->dev, res->start,\r\ninfo->screen_size);\r\nif (!info->screen_base) {\r\nframebuffer_release(info);\r\nreturn -ENOMEM;\r\n}\r\ninfo->fbops = &cobalt_lcd_fbops;\r\ninfo->fix = cobalt_lcdfb_fix;\r\ninfo->fix.smem_start = res->start;\r\ninfo->fix.smem_len = info->screen_size;\r\ninfo->pseudo_palette = NULL;\r\ninfo->par = NULL;\r\ninfo->flags = FBINFO_DEFAULT;\r\nretval = register_framebuffer(info);\r\nif (retval < 0) {\r\nframebuffer_release(info);\r\nreturn retval;\r\n}\r\nplatform_set_drvdata(dev, info);\r\nlcd_clear(info);\r\nfb_info(info, "Cobalt server LCD frame buffer device\n");\r\nreturn 0;\r\n}\r\nstatic int cobalt_lcdfb_remove(struct platform_device *dev)\r\n{\r\nstruct fb_info *info;\r\ninfo = platform_get_drvdata(dev);\r\nif (info) {\r\nunregister_framebuffer(info);\r\nframebuffer_release(info);\r\n}\r\nreturn 0;\r\n}
