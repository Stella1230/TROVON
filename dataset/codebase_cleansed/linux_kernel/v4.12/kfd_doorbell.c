static inline size_t doorbell_process_allocation(void)\r\n{\r\nreturn roundup(KFD_SIZE_OF_DOORBELL_IN_BYTES *\r\nKFD_MAX_NUM_OF_QUEUES_PER_PROCESS,\r\nPAGE_SIZE);\r\n}\r\nvoid kfd_doorbell_init(struct kfd_dev *kfd)\r\n{\r\nsize_t doorbell_start_offset;\r\nsize_t doorbell_aperture_size;\r\nsize_t doorbell_process_limit;\r\ndoorbell_start_offset =\r\nroundup(kfd->shared_resources.doorbell_start_offset,\r\ndoorbell_process_allocation());\r\ndoorbell_aperture_size =\r\nrounddown(kfd->shared_resources.doorbell_aperture_size,\r\ndoorbell_process_allocation());\r\nif (doorbell_aperture_size > doorbell_start_offset)\r\ndoorbell_process_limit =\r\n(doorbell_aperture_size - doorbell_start_offset) /\r\ndoorbell_process_allocation();\r\nelse\r\ndoorbell_process_limit = 0;\r\nkfd->doorbell_base = kfd->shared_resources.doorbell_physical_address +\r\ndoorbell_start_offset;\r\nkfd->doorbell_id_offset = doorbell_start_offset / sizeof(u32);\r\nkfd->doorbell_process_limit = doorbell_process_limit - 1;\r\nkfd->doorbell_kernel_ptr = ioremap(kfd->doorbell_base,\r\ndoorbell_process_allocation());\r\nBUG_ON(!kfd->doorbell_kernel_ptr);\r\npr_debug("kfd: doorbell initialization:\n");\r\npr_debug("kfd: doorbell base == 0x%08lX\n",\r\n(uintptr_t)kfd->doorbell_base);\r\npr_debug("kfd: doorbell_id_offset == 0x%08lX\n",\r\nkfd->doorbell_id_offset);\r\npr_debug("kfd: doorbell_process_limit == 0x%08lX\n",\r\ndoorbell_process_limit);\r\npr_debug("kfd: doorbell_kernel_offset == 0x%08lX\n",\r\n(uintptr_t)kfd->doorbell_base);\r\npr_debug("kfd: doorbell aperture size == 0x%08lX\n",\r\nkfd->shared_resources.doorbell_aperture_size);\r\npr_debug("kfd: doorbell kernel address == 0x%08lX\n",\r\n(uintptr_t)kfd->doorbell_kernel_ptr);\r\n}\r\nint kfd_doorbell_mmap(struct kfd_process *process, struct vm_area_struct *vma)\r\n{\r\nphys_addr_t address;\r\nstruct kfd_dev *dev;\r\nif (vma->vm_end - vma->vm_start != doorbell_process_allocation())\r\nreturn -EINVAL;\r\ndev = kfd_device_by_id(vma->vm_pgoff);\r\nif (dev == NULL)\r\nreturn -EINVAL;\r\naddress = kfd_get_process_doorbells(dev, process);\r\nvma->vm_flags |= VM_IO | VM_DONTCOPY | VM_DONTEXPAND | VM_NORESERVE |\r\nVM_DONTDUMP | VM_PFNMAP;\r\nvma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\r\npr_debug("kfd: mapping doorbell page in %s\n"\r\n" target user address == 0x%08llX\n"\r\n" physical address == 0x%08llX\n"\r\n" vm_flags == 0x%04lX\n"\r\n" size == 0x%04lX\n",\r\n__func__,\r\n(unsigned long long) vma->vm_start, address, vma->vm_flags,\r\ndoorbell_process_allocation());\r\nreturn io_remap_pfn_range(vma,\r\nvma->vm_start,\r\naddress >> PAGE_SHIFT,\r\ndoorbell_process_allocation(),\r\nvma->vm_page_prot);\r\n}\r\nu32 __iomem *kfd_get_kernel_doorbell(struct kfd_dev *kfd,\r\nunsigned int *doorbell_off)\r\n{\r\nu32 inx;\r\nBUG_ON(!kfd || !doorbell_off);\r\nmutex_lock(&kfd->doorbell_mutex);\r\ninx = find_first_zero_bit(kfd->doorbell_available_index,\r\nKFD_MAX_NUM_OF_QUEUES_PER_PROCESS);\r\n__set_bit(inx, kfd->doorbell_available_index);\r\nmutex_unlock(&kfd->doorbell_mutex);\r\nif (inx >= KFD_MAX_NUM_OF_QUEUES_PER_PROCESS)\r\nreturn NULL;\r\n*doorbell_off = KERNEL_DOORBELL_PASID * (doorbell_process_allocation() /\r\nsizeof(u32)) + inx;\r\npr_debug("kfd: get kernel queue doorbell\n"\r\n" doorbell offset == 0x%08X\n"\r\n" kernel address == 0x%08lX\n",\r\n*doorbell_off, (uintptr_t)(kfd->doorbell_kernel_ptr + inx));\r\nreturn kfd->doorbell_kernel_ptr + inx;\r\n}\r\nvoid kfd_release_kernel_doorbell(struct kfd_dev *kfd, u32 __iomem *db_addr)\r\n{\r\nunsigned int inx;\r\nBUG_ON(!kfd || !db_addr);\r\ninx = (unsigned int)(db_addr - kfd->doorbell_kernel_ptr);\r\nmutex_lock(&kfd->doorbell_mutex);\r\n__clear_bit(inx, kfd->doorbell_available_index);\r\nmutex_unlock(&kfd->doorbell_mutex);\r\n}\r\ninline void write_kernel_doorbell(u32 __iomem *db, u32 value)\r\n{\r\nif (db) {\r\nwritel(value, db);\r\npr_debug("writing %d to doorbell address 0x%p\n", value, db);\r\n}\r\n}\r\nunsigned int kfd_queue_id_to_doorbell(struct kfd_dev *kfd,\r\nstruct kfd_process *process,\r\nunsigned int queue_id)\r\n{\r\nreturn kfd->doorbell_id_offset +\r\nprocess->pasid * (doorbell_process_allocation()/sizeof(u32)) +\r\nqueue_id;\r\n}\r\nuint64_t kfd_get_number_elems(struct kfd_dev *kfd)\r\n{\r\nuint64_t num_of_elems = (kfd->shared_resources.doorbell_aperture_size -\r\nkfd->shared_resources.doorbell_start_offset) /\r\ndoorbell_process_allocation() + 1;\r\nreturn num_of_elems;\r\n}\r\nphys_addr_t kfd_get_process_doorbells(struct kfd_dev *dev,\r\nstruct kfd_process *process)\r\n{\r\nreturn dev->doorbell_base +\r\nprocess->pasid * doorbell_process_allocation();\r\n}
