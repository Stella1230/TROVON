static int w1_ds2405_select(struct w1_slave *sl, bool only_active)\r\n{\r\nstruct w1_master *dev = sl->master;\r\nu64 dev_addr = le64_to_cpu(*(u64 *)&sl->reg_num);\r\nunsigned int bit_ctr;\r\nif (w1_reset_bus(dev) != 0)\r\nreturn 0;\r\nw1_write_8(dev, only_active ? W1_ALARM_SEARCH : W1_SEARCH);\r\nfor (bit_ctr = 0; bit_ctr < 64; bit_ctr++) {\r\nint bit2send = !!(dev_addr & BIT(bit_ctr));\r\nu8 ret;\r\nret = w1_triplet(dev, bit2send);\r\nif ((ret & (BIT(0) | BIT(1))) ==\r\n(BIT(0) | BIT(1)))\r\nreturn 0;\r\nif (!!(ret & BIT(2)) != bit2send)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int w1_ds2405_read_pio(struct w1_slave *sl)\r\n{\r\nif (w1_ds2405_select(sl, true))\r\nreturn 0;\r\nif (w1_ds2405_select(sl, false))\r\nreturn 1;\r\nreturn -ENODEV;\r\n}\r\nstatic ssize_t state_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(device);\r\nstruct w1_master *dev = sl->master;\r\nint ret;\r\nssize_t f_retval;\r\nu8 state;\r\nret = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (ret)\r\nreturn ret;\r\nif (!w1_ds2405_select(sl, false)) {\r\nf_retval = -ENODEV;\r\ngoto out_unlock;\r\n}\r\nstate = w1_read_8(dev);\r\nif (state != 0 &&\r\nstate != 0xff) {\r\ndev_err(device, "non-consistent state %x\n", state);\r\nf_retval = -EIO;\r\ngoto out_unlock;\r\n}\r\n*buf = state ? '1' : '0';\r\nf_retval = 1;\r\nout_unlock:\r\nw1_reset_bus(dev);\r\nmutex_unlock(&dev->bus_mutex);\r\nreturn f_retval;\r\n}\r\nstatic ssize_t output_show(struct device *device,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(device);\r\nstruct w1_master *dev = sl->master;\r\nint ret;\r\nssize_t f_retval;\r\nret = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (ret)\r\nreturn ret;\r\nret = w1_ds2405_read_pio(sl);\r\nif (ret < 0) {\r\nf_retval = ret;\r\ngoto out_unlock;\r\n}\r\n*buf = ret ? '1' : '0';\r\nf_retval = 1;\r\nout_unlock:\r\nw1_reset_bus(dev);\r\nmutex_unlock(&dev->bus_mutex);\r\nreturn f_retval;\r\n}\r\nstatic ssize_t output_store(struct device *device,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct w1_slave *sl = dev_to_w1_slave(device);\r\nstruct w1_master *dev = sl->master;\r\nint ret, current_pio;\r\nunsigned int val;\r\nssize_t f_retval;\r\nif (count < 1)\r\nreturn -EINVAL;\r\nif (sscanf(buf, " %u%n", &val, &ret) < 1)\r\nreturn -EINVAL;\r\nif (val != 0 && val != 1)\r\nreturn -EINVAL;\r\nf_retval = ret;\r\nret = mutex_lock_interruptible(&dev->bus_mutex);\r\nif (ret)\r\nreturn ret;\r\ncurrent_pio = w1_ds2405_read_pio(sl);\r\nif (current_pio < 0) {\r\nf_retval = current_pio;\r\ngoto out_unlock;\r\n}\r\nif (current_pio == val)\r\ngoto out_unlock;\r\nif (w1_reset_bus(dev) != 0) {\r\nf_retval = -ENODEV;\r\ngoto out_unlock;\r\n}\r\ndo {\r\nu64 dev_addr = le64_to_cpu(*(u64 *)&sl->reg_num);\r\nu8 cmd[9];\r\ncmd[0] = W1_MATCH_ROM;\r\nmemcpy(&cmd[1], &dev_addr, sizeof(dev_addr));\r\nw1_write_block(dev, cmd, sizeof(cmd));\r\n} while (0);\r\nout_unlock:\r\nw1_reset_bus(dev);\r\nmutex_unlock(&dev->bus_mutex);\r\nreturn f_retval;\r\n}
