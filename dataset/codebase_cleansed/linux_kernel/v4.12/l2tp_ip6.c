static inline struct l2tp_ip6_sock *l2tp_ip6_sk(const struct sock *sk)\r\n{\r\nreturn (struct l2tp_ip6_sock *)sk;\r\n}\r\nstatic struct sock *__l2tp_ip6_bind_lookup(const struct net *net,\r\nconst struct in6_addr *laddr,\r\nconst struct in6_addr *raddr,\r\nint dif, u32 tunnel_id)\r\n{\r\nstruct sock *sk;\r\nsk_for_each_bound(sk, &l2tp_ip6_bind_table) {\r\nconst struct in6_addr *sk_laddr = inet6_rcv_saddr(sk);\r\nconst struct in6_addr *sk_raddr = &sk->sk_v6_daddr;\r\nconst struct l2tp_ip6_sock *l2tp = l2tp_ip6_sk(sk);\r\nif (!net_eq(sock_net(sk), net))\r\ncontinue;\r\nif (sk->sk_bound_dev_if && dif && sk->sk_bound_dev_if != dif)\r\ncontinue;\r\nif (sk_laddr && !ipv6_addr_any(sk_laddr) &&\r\n!ipv6_addr_any(laddr) && !ipv6_addr_equal(sk_laddr, laddr))\r\ncontinue;\r\nif (!ipv6_addr_any(sk_raddr) && raddr &&\r\n!ipv6_addr_any(raddr) && !ipv6_addr_equal(sk_raddr, raddr))\r\ncontinue;\r\nif (l2tp->conn_id != tunnel_id)\r\ncontinue;\r\ngoto found;\r\n}\r\nsk = NULL;\r\nfound:\r\nreturn sk;\r\n}\r\nstatic int l2tp_ip6_recv(struct sk_buff *skb)\r\n{\r\nstruct net *net = dev_net(skb->dev);\r\nstruct sock *sk;\r\nu32 session_id;\r\nu32 tunnel_id;\r\nunsigned char *ptr, *optr;\r\nstruct l2tp_session *session;\r\nstruct l2tp_tunnel *tunnel = NULL;\r\nint length;\r\nif (!pskb_may_pull(skb, 4))\r\ngoto discard;\r\noptr = ptr = skb->data;\r\nsession_id = ntohl(*((__be32 *) ptr));\r\nptr += 4;\r\nif (session_id == 0) {\r\n__skb_pull(skb, 4);\r\ngoto pass_up;\r\n}\r\nsession = l2tp_session_get(net, NULL, session_id, true);\r\nif (!session)\r\ngoto discard;\r\ntunnel = session->tunnel;\r\nif (!tunnel)\r\ngoto discard_sess;\r\nif (tunnel->debug & L2TP_MSG_DATA) {\r\nlength = min(32u, skb->len);\r\nif (!pskb_may_pull(skb, length))\r\ngoto discard_sess;\r\noptr = ptr = skb->data;\r\nptr += 4;\r\npr_debug("%s: ip recv\n", tunnel->name);\r\nprint_hex_dump_bytes("", DUMP_PREFIX_OFFSET, ptr, length);\r\n}\r\nl2tp_recv_common(session, skb, ptr, optr, 0, skb->len,\r\ntunnel->recv_payload_hook);\r\nl2tp_session_dec_refcount(session);\r\nreturn 0;\r\npass_up:\r\nif (!pskb_may_pull(skb, 12))\r\ngoto discard;\r\nif ((skb->data[0] & 0xc0) != 0xc0)\r\ngoto discard;\r\ntunnel_id = ntohl(*(__be32 *) &skb->data[4]);\r\ntunnel = l2tp_tunnel_find(net, tunnel_id);\r\nif (tunnel) {\r\nsk = tunnel->sock;\r\nsock_hold(sk);\r\n} else {\r\nstruct ipv6hdr *iph = ipv6_hdr(skb);\r\nread_lock_bh(&l2tp_ip6_lock);\r\nsk = __l2tp_ip6_bind_lookup(net, &iph->daddr, &iph->saddr,\r\ninet6_iif(skb), tunnel_id);\r\nif (!sk) {\r\nread_unlock_bh(&l2tp_ip6_lock);\r\ngoto discard;\r\n}\r\nsock_hold(sk);\r\nread_unlock_bh(&l2tp_ip6_lock);\r\n}\r\nif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\r\ngoto discard_put;\r\nnf_reset(skb);\r\nreturn sk_receive_skb(sk, skb, 1);\r\ndiscard_sess:\r\nif (session->deref)\r\nsession->deref(session);\r\nl2tp_session_dec_refcount(session);\r\ngoto discard;\r\ndiscard_put:\r\nsock_put(sk);\r\ndiscard:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic int l2tp_ip6_open(struct sock *sk)\r\n{\r\ninet_sk(sk)->inet_num = IPPROTO_L2TP;\r\nwrite_lock_bh(&l2tp_ip6_lock);\r\nsk_add_node(sk, &l2tp_ip6_table);\r\nwrite_unlock_bh(&l2tp_ip6_lock);\r\nreturn 0;\r\n}\r\nstatic void l2tp_ip6_close(struct sock *sk, long timeout)\r\n{\r\nwrite_lock_bh(&l2tp_ip6_lock);\r\nhlist_del_init(&sk->sk_bind_node);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&l2tp_ip6_lock);\r\nsk_common_release(sk);\r\n}\r\nstatic void l2tp_ip6_destroy_sock(struct sock *sk)\r\n{\r\nstruct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);\r\nlock_sock(sk);\r\nip6_flush_pending_frames(sk);\r\nrelease_sock(sk);\r\nif (tunnel) {\r\nl2tp_tunnel_closeall(tunnel);\r\nsock_put(sk);\r\n}\r\ninet6_destroy_sock(sk);\r\n}\r\nstatic int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)\r\n{\r\nstruct inet_sock *inet = inet_sk(sk);\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr;\r\nstruct net *net = sock_net(sk);\r\n__be32 v4addr = 0;\r\nint bound_dev_if;\r\nint addr_type;\r\nint err;\r\nif (addr->l2tp_family != AF_INET6)\r\nreturn -EINVAL;\r\nif (addr_len < sizeof(*addr))\r\nreturn -EINVAL;\r\naddr_type = ipv6_addr_type(&addr->l2tp_addr);\r\nif (addr_type == IPV6_ADDR_MAPPED)\r\nreturn -EADDRNOTAVAIL;\r\nif (addr_type & IPV6_ADDR_MULTICAST)\r\nreturn -EADDRNOTAVAIL;\r\nlock_sock(sk);\r\nerr = -EINVAL;\r\nif (!sock_flag(sk, SOCK_ZAPPED))\r\ngoto out_unlock;\r\nif (sk->sk_state != TCP_CLOSE)\r\ngoto out_unlock;\r\nbound_dev_if = sk->sk_bound_dev_if;\r\nrcu_read_lock();\r\nif (addr_type != IPV6_ADDR_ANY) {\r\nstruct net_device *dev = NULL;\r\nif (addr_type & IPV6_ADDR_LINKLOCAL) {\r\nif (addr->l2tp_scope_id)\r\nbound_dev_if = addr->l2tp_scope_id;\r\nif (!bound_dev_if)\r\ngoto out_unlock_rcu;\r\nerr = -ENODEV;\r\ndev = dev_get_by_index_rcu(sock_net(sk), bound_dev_if);\r\nif (!dev)\r\ngoto out_unlock_rcu;\r\n}\r\nv4addr = LOOPBACK4_IPV6;\r\nerr = -EADDRNOTAVAIL;\r\nif (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0))\r\ngoto out_unlock_rcu;\r\n}\r\nrcu_read_unlock();\r\nwrite_lock_bh(&l2tp_ip6_lock);\r\nif (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr, NULL, bound_dev_if,\r\naddr->l2tp_conn_id)) {\r\nwrite_unlock_bh(&l2tp_ip6_lock);\r\nerr = -EADDRINUSE;\r\ngoto out_unlock;\r\n}\r\ninet->inet_saddr = v4addr;\r\ninet->inet_rcv_saddr = v4addr;\r\nsk->sk_bound_dev_if = bound_dev_if;\r\nsk->sk_v6_rcv_saddr = addr->l2tp_addr;\r\nnp->saddr = addr->l2tp_addr;\r\nl2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id;\r\nsk_add_bind_node(sk, &l2tp_ip6_bind_table);\r\nsk_del_node_init(sk);\r\nwrite_unlock_bh(&l2tp_ip6_lock);\r\nsock_reset_flag(sk, SOCK_ZAPPED);\r\nrelease_sock(sk);\r\nreturn 0;\r\nout_unlock_rcu:\r\nrcu_read_unlock();\r\nout_unlock:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int l2tp_ip6_connect(struct sock *sk, struct sockaddr *uaddr,\r\nint addr_len)\r\n{\r\nstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *) uaddr;\r\nstruct sockaddr_in6 *usin = (struct sockaddr_in6 *) uaddr;\r\nstruct in6_addr *daddr;\r\nint addr_type;\r\nint rc;\r\nif (addr_len < sizeof(*lsa))\r\nreturn -EINVAL;\r\nif (usin->sin6_family != AF_INET6)\r\nreturn -EINVAL;\r\naddr_type = ipv6_addr_type(&usin->sin6_addr);\r\nif (addr_type & IPV6_ADDR_MULTICAST)\r\nreturn -EINVAL;\r\nif (addr_type & IPV6_ADDR_MAPPED) {\r\ndaddr = &usin->sin6_addr;\r\nif (ipv4_is_multicast(daddr->s6_addr32[3]))\r\nreturn -EINVAL;\r\n}\r\nlock_sock(sk);\r\nif (sock_flag(sk, SOCK_ZAPPED)) {\r\nrc = -EINVAL;\r\ngoto out_sk;\r\n}\r\nrc = __ip6_datagram_connect(sk, uaddr, addr_len);\r\nif (rc < 0)\r\ngoto out_sk;\r\nl2tp_ip6_sk(sk)->peer_conn_id = lsa->l2tp_conn_id;\r\nwrite_lock_bh(&l2tp_ip6_lock);\r\nhlist_del_init(&sk->sk_bind_node);\r\nsk_add_bind_node(sk, &l2tp_ip6_bind_table);\r\nwrite_unlock_bh(&l2tp_ip6_lock);\r\nout_sk:\r\nrelease_sock(sk);\r\nreturn rc;\r\n}\r\nstatic int l2tp_ip6_disconnect(struct sock *sk, int flags)\r\n{\r\nif (sock_flag(sk, SOCK_ZAPPED))\r\nreturn 0;\r\nreturn __udp_disconnect(sk, flags);\r\n}\r\nstatic int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,\r\nint *uaddr_len, int peer)\r\n{\r\nstruct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;\r\nstruct sock *sk = sock->sk;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);\r\nlsa->l2tp_family = AF_INET6;\r\nlsa->l2tp_flowinfo = 0;\r\nlsa->l2tp_scope_id = 0;\r\nlsa->l2tp_unused = 0;\r\nif (peer) {\r\nif (!lsk->peer_conn_id)\r\nreturn -ENOTCONN;\r\nlsa->l2tp_conn_id = lsk->peer_conn_id;\r\nlsa->l2tp_addr = sk->sk_v6_daddr;\r\nif (np->sndflow)\r\nlsa->l2tp_flowinfo = np->flow_label;\r\n} else {\r\nif (ipv6_addr_any(&sk->sk_v6_rcv_saddr))\r\nlsa->l2tp_addr = np->saddr;\r\nelse\r\nlsa->l2tp_addr = sk->sk_v6_rcv_saddr;\r\nlsa->l2tp_conn_id = lsk->conn_id;\r\n}\r\nif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\r\nlsa->l2tp_scope_id = sk->sk_bound_dev_if;\r\n*uaddr_len = sizeof(*lsa);\r\nreturn 0;\r\n}\r\nstatic int l2tp_ip6_backlog_recv(struct sock *sk, struct sk_buff *skb)\r\n{\r\nint rc;\r\nrc = sock_queue_rcv_skb(sk, skb);\r\nif (rc < 0)\r\ngoto drop;\r\nreturn 0;\r\ndrop:\r\nIP_INC_STATS(sock_net(sk), IPSTATS_MIB_INDISCARDS);\r\nkfree_skb(skb);\r\nreturn -1;\r\n}\r\nstatic int l2tp_ip6_push_pending_frames(struct sock *sk)\r\n{\r\nstruct sk_buff *skb;\r\n__be32 *transhdr = NULL;\r\nint err = 0;\r\nskb = skb_peek(&sk->sk_write_queue);\r\nif (skb == NULL)\r\ngoto out;\r\ntranshdr = (__be32 *)skb_transport_header(skb);\r\n*transhdr = 0;\r\nerr = ip6_push_pending_frames(sk);\r\nout:\r\nreturn err;\r\n}\r\nstatic int l2tp_ip6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)\r\n{\r\nstruct ipv6_txoptions opt_space;\r\nDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\r\nstruct in6_addr *daddr, *final_p, final;\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nstruct ipv6_txoptions *opt_to_free = NULL;\r\nstruct ipv6_txoptions *opt = NULL;\r\nstruct ip6_flowlabel *flowlabel = NULL;\r\nstruct dst_entry *dst = NULL;\r\nstruct flowi6 fl6;\r\nstruct sockcm_cookie sockc_unused = {0};\r\nstruct ipcm6_cookie ipc6;\r\nint addr_len = msg->msg_namelen;\r\nint transhdrlen = 4;\r\nint ulen = len + transhdrlen;\r\nint err;\r\nif (len > INT_MAX)\r\nreturn -EMSGSIZE;\r\nif (msg->msg_flags & MSG_OOB)\r\nreturn -EOPNOTSUPP;\r\nmemset(&fl6, 0, sizeof(fl6));\r\nfl6.flowi6_mark = sk->sk_mark;\r\nfl6.flowi6_uid = sk->sk_uid;\r\nipc6.hlimit = -1;\r\nipc6.tclass = -1;\r\nipc6.dontfrag = -1;\r\nif (lsa) {\r\nif (addr_len < SIN6_LEN_RFC2133)\r\nreturn -EINVAL;\r\nif (lsa->l2tp_family && lsa->l2tp_family != AF_INET6)\r\nreturn -EAFNOSUPPORT;\r\ndaddr = &lsa->l2tp_addr;\r\nif (np->sndflow) {\r\nfl6.flowlabel = lsa->l2tp_flowinfo & IPV6_FLOWINFO_MASK;\r\nif (fl6.flowlabel&IPV6_FLOWLABEL_MASK) {\r\nflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\r\nif (flowlabel == NULL)\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (sk->sk_state == TCP_ESTABLISHED &&\r\nipv6_addr_equal(daddr, &sk->sk_v6_daddr))\r\ndaddr = &sk->sk_v6_daddr;\r\nif (addr_len >= sizeof(struct sockaddr_in6) &&\r\nlsa->l2tp_scope_id &&\r\nipv6_addr_type(daddr) & IPV6_ADDR_LINKLOCAL)\r\nfl6.flowi6_oif = lsa->l2tp_scope_id;\r\n} else {\r\nif (sk->sk_state != TCP_ESTABLISHED)\r\nreturn -EDESTADDRREQ;\r\ndaddr = &sk->sk_v6_daddr;\r\nfl6.flowlabel = np->flow_label;\r\n}\r\nif (fl6.flowi6_oif == 0)\r\nfl6.flowi6_oif = sk->sk_bound_dev_if;\r\nif (msg->msg_controllen) {\r\nopt = &opt_space;\r\nmemset(opt, 0, sizeof(struct ipv6_txoptions));\r\nopt->tot_len = sizeof(struct ipv6_txoptions);\r\nipc6.opt = opt;\r\nerr = ip6_datagram_send_ctl(sock_net(sk), sk, msg, &fl6, &ipc6,\r\n&sockc_unused);\r\nif (err < 0) {\r\nfl6_sock_release(flowlabel);\r\nreturn err;\r\n}\r\nif ((fl6.flowlabel & IPV6_FLOWLABEL_MASK) && !flowlabel) {\r\nflowlabel = fl6_sock_lookup(sk, fl6.flowlabel);\r\nif (flowlabel == NULL)\r\nreturn -EINVAL;\r\n}\r\nif (!(opt->opt_nflen|opt->opt_flen))\r\nopt = NULL;\r\n}\r\nif (!opt) {\r\nopt = txopt_get(np);\r\nopt_to_free = opt;\r\n}\r\nif (flowlabel)\r\nopt = fl6_merge_options(&opt_space, flowlabel, opt);\r\nopt = ipv6_fixup_options(&opt_space, opt);\r\nipc6.opt = opt;\r\nfl6.flowi6_proto = sk->sk_protocol;\r\nif (!ipv6_addr_any(daddr))\r\nfl6.daddr = *daddr;\r\nelse\r\nfl6.daddr.s6_addr[15] = 0x1;\r\nif (ipv6_addr_any(&fl6.saddr) && !ipv6_addr_any(&np->saddr))\r\nfl6.saddr = np->saddr;\r\nfinal_p = fl6_update_dst(&fl6, opt, &final);\r\nif (!fl6.flowi6_oif && ipv6_addr_is_multicast(&fl6.daddr))\r\nfl6.flowi6_oif = np->mcast_oif;\r\nelse if (!fl6.flowi6_oif)\r\nfl6.flowi6_oif = np->ucast_oif;\r\nsecurity_sk_classify_flow(sk, flowi6_to_flowi(&fl6));\r\nif (ipc6.tclass < 0)\r\nipc6.tclass = np->tclass;\r\nfl6.flowlabel = ip6_make_flowinfo(ipc6.tclass, fl6.flowlabel);\r\ndst = ip6_dst_lookup_flow(sk, &fl6, final_p);\r\nif (IS_ERR(dst)) {\r\nerr = PTR_ERR(dst);\r\ngoto out;\r\n}\r\nif (ipc6.hlimit < 0)\r\nipc6.hlimit = ip6_sk_dst_hoplimit(np, &fl6, dst);\r\nif (ipc6.dontfrag < 0)\r\nipc6.dontfrag = np->dontfrag;\r\nif (msg->msg_flags & MSG_CONFIRM)\r\ngoto do_confirm;\r\nback_from_confirm:\r\nlock_sock(sk);\r\nerr = ip6_append_data(sk, ip_generic_getfrag, msg,\r\nulen, transhdrlen, &ipc6,\r\n&fl6, (struct rt6_info *)dst,\r\nmsg->msg_flags, &sockc_unused);\r\nif (err)\r\nip6_flush_pending_frames(sk);\r\nelse if (!(msg->msg_flags & MSG_MORE))\r\nerr = l2tp_ip6_push_pending_frames(sk);\r\nrelease_sock(sk);\r\ndone:\r\ndst_release(dst);\r\nout:\r\nfl6_sock_release(flowlabel);\r\ntxopt_put(opt_to_free);\r\nreturn err < 0 ? err : len;\r\ndo_confirm:\r\nif (msg->msg_flags & MSG_PROBE)\r\ndst_confirm_neigh(dst, &fl6.daddr);\r\nif (!(msg->msg_flags & MSG_PROBE) || len)\r\ngoto back_from_confirm;\r\nerr = 0;\r\ngoto done;\r\n}\r\nstatic int l2tp_ip6_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,\r\nint noblock, int flags, int *addr_len)\r\n{\r\nstruct ipv6_pinfo *np = inet6_sk(sk);\r\nDECLARE_SOCKADDR(struct sockaddr_l2tpip6 *, lsa, msg->msg_name);\r\nsize_t copied = 0;\r\nint err = -EOPNOTSUPP;\r\nstruct sk_buff *skb;\r\nif (flags & MSG_OOB)\r\ngoto out;\r\nif (addr_len)\r\n*addr_len = sizeof(*lsa);\r\nif (flags & MSG_ERRQUEUE)\r\nreturn ipv6_recv_error(sk, msg, len, addr_len);\r\nskb = skb_recv_datagram(sk, flags, noblock, &err);\r\nif (!skb)\r\ngoto out;\r\ncopied = skb->len;\r\nif (len < copied) {\r\nmsg->msg_flags |= MSG_TRUNC;\r\ncopied = len;\r\n}\r\nerr = skb_copy_datagram_msg(skb, 0, msg, copied);\r\nif (err)\r\ngoto done;\r\nsock_recv_timestamp(msg, sk, skb);\r\nif (lsa) {\r\nlsa->l2tp_family = AF_INET6;\r\nlsa->l2tp_unused = 0;\r\nlsa->l2tp_addr = ipv6_hdr(skb)->saddr;\r\nlsa->l2tp_flowinfo = 0;\r\nlsa->l2tp_scope_id = 0;\r\nlsa->l2tp_conn_id = 0;\r\nif (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)\r\nlsa->l2tp_scope_id = inet6_iif(skb);\r\n}\r\nif (np->rxopt.all)\r\nip6_datagram_recv_ctl(sk, msg, skb);\r\nif (flags & MSG_TRUNC)\r\ncopied = skb->len;\r\ndone:\r\nskb_free_datagram(sk, skb);\r\nout:\r\nreturn err ? err : copied;\r\n}\r\nstatic int __init l2tp_ip6_init(void)\r\n{\r\nint err;\r\npr_info("L2TP IP encapsulation support for IPv6 (L2TPv3)\n");\r\nerr = proto_register(&l2tp_ip6_prot, 1);\r\nif (err != 0)\r\ngoto out;\r\nerr = inet6_add_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\r\nif (err)\r\ngoto out1;\r\ninet6_register_protosw(&l2tp_ip6_protosw);\r\nreturn 0;\r\nout1:\r\nproto_unregister(&l2tp_ip6_prot);\r\nout:\r\nreturn err;\r\n}\r\nstatic void __exit l2tp_ip6_exit(void)\r\n{\r\ninet6_unregister_protosw(&l2tp_ip6_protosw);\r\ninet6_del_protocol(&l2tp_ip6_protocol, IPPROTO_L2TP);\r\nproto_unregister(&l2tp_ip6_prot);\r\n}
