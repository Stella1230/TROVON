static void pci9118_amcc_setup_dma(struct comedi_device *dev, unsigned int buf)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[buf];\r\noutl(dmabuf->hw, devpriv->iobase_a + AMCC_OP_REG_MWAR);\r\noutl(dmabuf->use_size, devpriv->iobase_a + AMCC_OP_REG_MWTC);\r\n}\r\nstatic void pci9118_amcc_dma_ena(struct comedi_device *dev, bool enable)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned int mcsr;\r\nmcsr = inl(devpriv->iobase_a + AMCC_OP_REG_MCSR);\r\nif (enable)\r\nmcsr |= RESET_A2P_FLAGS | A2P_HI_PRIORITY | EN_A2P_TRANSFERS;\r\nelse\r\nmcsr &= ~EN_A2P_TRANSFERS;\r\noutl(mcsr, devpriv->iobase_a + AMCC_OP_REG_MCSR);\r\n}\r\nstatic void pci9118_amcc_int_ena(struct comedi_device *dev, bool enable)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned int intcsr;\r\nintcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nif (enable)\r\nintcsr |= 0x1f00;\r\nelse\r\nintcsr &= ~0x1f00;\r\noutl(intcsr, devpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\n}\r\nstatic void pci9118_ai_reset_fifo(struct comedi_device *dev)\r\n{\r\noutl(0, dev->iobase + PCI9118_FIFO_RESET_REG);\r\n}\r\nstatic int pci9118_ai_check_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned int range0 = CR_RANGE(cmd->chanlist[0]);\r\nunsigned int aref0 = CR_AREF(cmd->chanlist[0]);\r\nint i;\r\nif (cmd->chanlist_len == 1)\r\nreturn 0;\r\nfor (i = 1; i < cmd->chanlist_len; i++) {\r\nunsigned int chan = CR_CHAN(cmd->chanlist[i]);\r\nunsigned int range = CR_RANGE(cmd->chanlist[i]);\r\nunsigned int aref = CR_AREF(cmd->chanlist[i]);\r\nif (aref != aref0) {\r\ndev_err(dev->class_dev,\r\n"Differential and single ended inputs can't be mixed!\n");\r\nreturn -EINVAL;\r\n}\r\nif (comedi_range_is_bipolar(s, range) !=\r\ncomedi_range_is_bipolar(s, range0)) {\r\ndev_err(dev->class_dev,\r\n"Bipolar and unipolar ranges can't be mixed!\n");\r\nreturn -EINVAL;\r\n}\r\nif (!devpriv->usemux && aref == AREF_DIFF &&\r\n(chan >= (s->n_chan / 2))) {\r\ndev_err(dev->class_dev,\r\n"AREF_DIFF is only available for the first 8 channels!\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void pci9118_set_chanlist(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nint n_chan, unsigned int *chanlist,\r\nint frontadd, int backadd)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned int chan0 = CR_CHAN(chanlist[0]);\r\nunsigned int range0 = CR_RANGE(chanlist[0]);\r\nunsigned int aref0 = CR_AREF(chanlist[0]);\r\nunsigned int ssh = 0x00;\r\nunsigned int val;\r\nint i;\r\ndevpriv->ai_ctrl = 0;\r\nif (comedi_range_is_unipolar(s, range0))\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_UNIP;\r\nif (aref0 == AREF_DIFF)\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_DIFF;\r\noutl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);\r\noutl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\noutl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\noutl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\nif (frontadd) {\r\nval = PCI9118_AI_CHANLIST_CHAN(chan0) |\r\nPCI9118_AI_CHANLIST_RANGE(range0);\r\nssh = devpriv->softsshsample;\r\nfor (i = 0; i < frontadd; i++) {\r\noutl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);\r\nssh = devpriv->softsshhold;\r\n}\r\n}\r\nfor (i = 0; i < n_chan; i++) {\r\nunsigned int chan = CR_CHAN(chanlist[i]);\r\nunsigned int range = CR_RANGE(chanlist[i]);\r\nval = PCI9118_AI_CHANLIST_CHAN(chan) |\r\nPCI9118_AI_CHANLIST_RANGE(range);\r\noutl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);\r\n}\r\nif (backadd) {\r\nval = PCI9118_AI_CHANLIST_CHAN(chan0) |\r\nPCI9118_AI_CHANLIST_RANGE(range0);\r\nfor (i = 0; i < backadd; i++)\r\noutl(val | ssh, dev->iobase + PCI9118_AI_CHANLIST_REG);\r\n}\r\noutl(0, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\n}\r\nstatic void pci9118_ai_mode4_switch(struct comedi_device *dev,\r\nunsigned int next_buf)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[next_buf];\r\ndevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG |\r\nPCI9118_AI_CFG_AM;\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\ncomedi_8254_load(dev->pacer, 0, dmabuf->hw >> 1,\r\nI8254_MODE0 | I8254_BINARY);\r\ndevpriv->ai_cfg |= PCI9118_AI_CFG_START;\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\n}\r\nstatic unsigned int pci9118_ai_samples_ready(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int n_raw_samples)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int start_pos = devpriv->ai_add_front;\r\nunsigned int stop_pos = start_pos + cmd->chanlist_len;\r\nunsigned int span_len = stop_pos + devpriv->ai_add_back;\r\nunsigned int dma_pos = devpriv->ai_act_dmapos;\r\nunsigned int whole_spans, n_samples, x;\r\nif (span_len == cmd->chanlist_len)\r\nreturn n_raw_samples;\r\nwhole_spans = n_raw_samples / span_len;\r\nn_samples = whole_spans * cmd->chanlist_len;\r\nn_raw_samples -= whole_spans * span_len;\r\nwhile (n_raw_samples) {\r\nif (dma_pos < start_pos) {\r\nx = start_pos - dma_pos;\r\nif (x > n_raw_samples)\r\nx = n_raw_samples;\r\ndma_pos += x;\r\nn_raw_samples -= x;\r\nif (!n_raw_samples)\r\nbreak;\r\n}\r\nif (dma_pos < stop_pos) {\r\nx = stop_pos - dma_pos;\r\nif (x > n_raw_samples)\r\nx = n_raw_samples;\r\nn_samples += x;\r\ndma_pos += x;\r\nn_raw_samples -= x;\r\n}\r\nstart_pos += span_len;\r\nstop_pos += span_len;\r\n}\r\nreturn n_samples;\r\n}\r\nstatic void pci9118_ai_dma_xfer(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned short *dma_buffer,\r\nunsigned int n_raw_samples)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int start_pos = devpriv->ai_add_front;\r\nunsigned int stop_pos = start_pos + cmd->chanlist_len;\r\nunsigned int span_len = stop_pos + devpriv->ai_add_back;\r\nunsigned int dma_pos = devpriv->ai_act_dmapos;\r\nunsigned int x;\r\nif (span_len == cmd->chanlist_len) {\r\ncomedi_buf_write_samples(s, dma_buffer, n_raw_samples);\r\ndma_pos += n_raw_samples;\r\n} else {\r\nwhile (n_raw_samples) {\r\nif (dma_pos < start_pos) {\r\nx = start_pos - dma_pos;\r\nif (x > n_raw_samples)\r\nx = n_raw_samples;\r\ndma_pos += x;\r\nn_raw_samples -= x;\r\nif (!n_raw_samples)\r\nbreak;\r\n}\r\nif (dma_pos < stop_pos) {\r\nx = stop_pos - dma_pos;\r\nif (x > n_raw_samples)\r\nx = n_raw_samples;\r\ncomedi_buf_write_samples(s, dma_buffer, x);\r\ndma_pos += x;\r\nn_raw_samples -= x;\r\n}\r\nstart_pos += span_len;\r\nstop_pos += span_len;\r\n}\r\n}\r\ndevpriv->ai_act_dmapos = dma_pos % span_len;\r\n}\r\nstatic void pci9118_exttrg_enable(struct comedi_device *dev, bool enable)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nif (enable)\r\ndevpriv->int_ctrl |= PCI9118_INT_CTRL_DTRG;\r\nelse\r\ndevpriv->int_ctrl &= ~PCI9118_INT_CTRL_DTRG;\r\noutl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);\r\nif (devpriv->int_ctrl)\r\npci9118_amcc_int_ena(dev, true);\r\nelse\r\npci9118_amcc_int_ena(dev, false);\r\n}\r\nstatic void pci9118_calc_divisors(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int *tim1, unsigned int *tim2,\r\nunsigned int flags, int chans,\r\nunsigned int *div1, unsigned int *div2,\r\nunsigned int chnsshfront)\r\n{\r\nstruct comedi_8254 *pacer = dev->pacer;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\n*div1 = *tim2 / pacer->osc_base;\r\n*div2 = *tim1 / pacer->osc_base;\r\n*div2 = *div2 / *div1;\r\nif (*div2 < chans)\r\n*div2 = chans;\r\n*tim2 = *div1 * pacer->osc_base;\r\nif (cmd->convert_src == TRIG_NOW && !chnsshfront) {\r\nif (*div2 < (chans + 2))\r\n*div2 = chans + 2;\r\n}\r\n*tim1 = *div1 * *div2 * pacer->osc_base;\r\n}\r\nstatic void pci9118_start_pacer(struct comedi_device *dev, int mode)\r\n{\r\nif (mode == 1 || mode == 2 || mode == 4)\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, true);\r\n}\r\nstatic int pci9118_ai_cancel(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nif (devpriv->usedma)\r\npci9118_amcc_dma_ena(dev, false);\r\npci9118_exttrg_enable(dev, false);\r\ncomedi_8254_pacer_enable(dev->pacer, 1, 2, false);\r\ndevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\ndevpriv->ai_ctrl = 0;\r\noutl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);\r\noutl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);\r\noutl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\noutl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\npci9118_ai_reset_fifo(dev);\r\ndevpriv->int_ctrl = 0;\r\noutl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);\r\npci9118_amcc_int_ena(dev, false);\r\ndevpriv->ai_do = 0;\r\ndevpriv->usedma = 0;\r\ndevpriv->ai_act_dmapos = 0;\r\ns->async->inttrig = NULL;\r\ndevpriv->ai_neverending = 0;\r\ndevpriv->dma_actbuf = 0;\r\nreturn 0;\r\n}\r\nstatic void pci9118_ai_munge(struct comedi_device *dev,\r\nstruct comedi_subdevice *s, void *data,\r\nunsigned int num_bytes,\r\nunsigned int start_chan_index)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned short *array = data;\r\nunsigned int num_samples = comedi_bytes_to_samples(s, num_bytes);\r\nunsigned int i;\r\n__be16 *barray = data;\r\nfor (i = 0; i < num_samples; i++) {\r\nif (devpriv->usedma)\r\narray[i] = be16_to_cpu(barray[i]);\r\nif (s->maxdata == 0xffff)\r\narray[i] ^= 0x8000;\r\nelse\r\narray[i] = (array[i] >> 4) & 0x0fff;\r\n}\r\n}\r\nstatic void pci9118_ai_get_onesample(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned short sampl;\r\nsampl = inl(dev->iobase + PCI9118_AI_FIFO_REG);\r\ncomedi_buf_write_samples(s, &sampl, 1);\r\nif (!devpriv->ai_neverending) {\r\nif (s->async->scans_done >= cmd->stop_arg)\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\n}\r\nstatic void pci9118_ai_get_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[devpriv->dma_actbuf];\r\nunsigned int n_all = comedi_bytes_to_samples(s, dmabuf->use_size);\r\nunsigned int n_valid;\r\nbool more_dma;\r\nn_valid = pci9118_ai_samples_ready(dev, s, n_all);\r\nmore_dma = n_valid < comedi_nsamples_left(s, n_valid + 1);\r\nif (more_dma && devpriv->dma_doublebuf) {\r\ndevpriv->dma_actbuf = 1 - devpriv->dma_actbuf;\r\npci9118_amcc_setup_dma(dev, devpriv->dma_actbuf);\r\nif (devpriv->ai_do == 4)\r\npci9118_ai_mode4_switch(dev, devpriv->dma_actbuf);\r\n}\r\nif (n_all)\r\npci9118_ai_dma_xfer(dev, s, dmabuf->virt, n_all);\r\nif (!devpriv->ai_neverending) {\r\nif (s->async->scans_done >= cmd->stop_arg)\r\ns->async->events |= COMEDI_CB_EOA;\r\n}\r\nif (s->async->events & COMEDI_CB_CANCEL_MASK)\r\nmore_dma = false;\r\nif (more_dma && !devpriv->dma_doublebuf) {\r\npci9118_amcc_setup_dma(dev, 0);\r\nif (devpriv->ai_do == 4)\r\npci9118_ai_mode4_switch(dev, 0);\r\n}\r\n}\r\nstatic irqreturn_t pci9118_interrupt(int irq, void *d)\r\n{\r\nstruct comedi_device *dev = d;\r\nstruct comedi_subdevice *s = dev->read_subdev;\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned int intsrc;\r\nunsigned int intcsr;\r\nunsigned int adstat;\r\nif (!dev->attached)\r\nreturn IRQ_NONE;\r\nintsrc = inl(dev->iobase + PCI9118_INT_CTRL_REG) & 0xf;\r\nintcsr = inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nif (!intsrc && !(intcsr & ANY_S593X_INT))\r\nreturn IRQ_NONE;\r\noutl(intcsr | 0x00ff0000, devpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nif (intcsr & MASTER_ABORT_INT) {\r\ndev_err(dev->class_dev, "AMCC IRQ - MASTER DMA ABORT!\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\ngoto interrupt_exit;\r\n}\r\nif (intcsr & TARGET_ABORT_INT) {\r\ndev_err(dev->class_dev, "AMCC IRQ - TARGET DMA ABORT!\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\ngoto interrupt_exit;\r\n}\r\nadstat = inl(dev->iobase + PCI9118_AI_STATUS_REG);\r\nif ((adstat & PCI9118_AI_STATUS_NFULL) == 0) {\r\ndev_err(dev->class_dev,\r\n"A/D FIFO Full status (Fatal Error!)\n");\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\r\ngoto interrupt_exit;\r\n}\r\nif (adstat & PCI9118_AI_STATUS_BOVER) {\r\ndev_err(dev->class_dev,\r\n"A/D Burst Mode Overrun Status (Fatal Error!)\n");\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\r\ngoto interrupt_exit;\r\n}\r\nif (adstat & PCI9118_AI_STATUS_ADOS) {\r\ndev_err(dev->class_dev, "A/D Over Speed Status (Warning!)\n");\r\ns->async->events |= COMEDI_CB_ERROR;\r\ngoto interrupt_exit;\r\n}\r\nif (adstat & PCI9118_AI_STATUS_ADOR) {\r\ndev_err(dev->class_dev, "A/D Overrun Status (Fatal Error!)\n");\r\ns->async->events |= COMEDI_CB_ERROR | COMEDI_CB_OVERFLOW;\r\ngoto interrupt_exit;\r\n}\r\nif (!devpriv->ai_do)\r\nreturn IRQ_HANDLED;\r\nif (devpriv->ai12_startstop) {\r\nif ((adstat & PCI9118_AI_STATUS_DTH) &&\r\n(intsrc & PCI9118_INT_CTRL_DTRG)) {\r\nif (devpriv->ai12_startstop & START_AI_EXT) {\r\ndevpriv->ai12_startstop &= ~START_AI_EXT;\r\nif (!(devpriv->ai12_startstop & STOP_AI_EXT))\r\npci9118_exttrg_enable(dev, false);\r\npci9118_start_pacer(dev, devpriv->ai_do);\r\noutl(devpriv->ai_ctrl,\r\ndev->iobase + PCI9118_AI_CTRL_REG);\r\n} else if (devpriv->ai12_startstop & STOP_AI_EXT) {\r\ndevpriv->ai12_startstop &= ~STOP_AI_EXT;\r\npci9118_exttrg_enable(dev, false);\r\ndevpriv->ai_neverending = 0;\r\n}\r\n}\r\n}\r\nif (devpriv->usedma)\r\npci9118_ai_get_dma(dev, s);\r\nelse\r\npci9118_ai_get_onesample(dev, s);\r\ninterrupt_exit:\r\ncomedi_handle_events(dev, s);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pci9118_ai_cmd_start(struct comedi_device *dev)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\noutl(devpriv->int_ctrl, dev->iobase + PCI9118_INT_CTRL_REG);\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\nif (devpriv->ai_do != 3) {\r\npci9118_start_pacer(dev, devpriv->ai_do);\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_SOFTG;\r\n}\r\noutl(devpriv->ai_ctrl, dev->iobase + PCI9118_AI_CTRL_REG);\r\n}\r\nstatic int pci9118_ai_inttrig(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nunsigned int trig_num)\r\n{\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nif (trig_num != cmd->start_arg)\r\nreturn -EINVAL;\r\ns->async->inttrig = NULL;\r\npci9118_ai_cmd_start(dev);\r\nreturn 1;\r\n}\r\nstatic int pci9118_ai_setup_dma(struct comedi_device *dev,\r\nstruct comedi_subdevice *s)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nstruct pci9118_dmabuf *dmabuf0 = &devpriv->dmabuf[0];\r\nstruct pci9118_dmabuf *dmabuf1 = &devpriv->dmabuf[1];\r\nunsigned int dmalen0 = dmabuf0->size;\r\nunsigned int dmalen1 = dmabuf1->size;\r\nunsigned int scan_bytes = devpriv->ai_n_realscanlen *\r\ncomedi_bytes_per_sample(s);\r\nif (dmalen0 > s->async->prealloc_bufsz) {\r\ndmalen0 = s->async->prealloc_bufsz & ~3L;\r\n}\r\nif (dmalen1 > s->async->prealloc_bufsz) {\r\ndmalen1 = s->async->prealloc_bufsz & ~3L;\r\n}\r\nif (devpriv->ai_flags & CMDF_WAKE_EOS) {\r\nif (dmalen0 < scan_bytes) {\r\ndevpriv->ai_flags &= (~CMDF_WAKE_EOS);\r\ndev_info(dev->class_dev,\r\n"WAR: DMA0 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\n",\r\ndmalen0, scan_bytes);\r\n} else {\r\ndmalen0 = scan_bytes;\r\nif (dmalen0 < 4) {\r\ndev_info(dev->class_dev,\r\n"ERR: DMA0 buf len bug? (%d<4)\n",\r\ndmalen0);\r\ndmalen0 = 4;\r\n}\r\n}\r\n}\r\nif (devpriv->ai_flags & CMDF_WAKE_EOS) {\r\nif (dmalen1 < scan_bytes) {\r\ndevpriv->ai_flags &= (~CMDF_WAKE_EOS);\r\ndev_info(dev->class_dev,\r\n"WAR: DMA1 buf too short, can't support CMDF_WAKE_EOS (%d<%d)\n",\r\ndmalen1, scan_bytes);\r\n} else {\r\ndmalen1 = scan_bytes;\r\nif (dmalen1 < 4) {\r\ndev_info(dev->class_dev,\r\n"ERR: DMA1 buf len bug? (%d<4)\n",\r\ndmalen1);\r\ndmalen1 = 4;\r\n}\r\n}\r\n}\r\nif (!(devpriv->ai_flags & CMDF_WAKE_EOS)) {\r\nunsigned int tmp;\r\ntmp = dmalen0;\r\ndmalen0 = (dmalen0 / scan_bytes) * scan_bytes;\r\ndmalen0 &= ~3L;\r\nif (!dmalen0)\r\ndmalen0 = tmp;\r\ntmp = dmalen1;\r\ndmalen1 = (dmalen1 / scan_bytes) * scan_bytes;\r\ndmalen1 &= ~3L;\r\nif (!dmalen1)\r\ndmalen1 = tmp;\r\nif (!devpriv->ai_neverending) {\r\nunsigned long long scanlen;\r\nscanlen = (unsigned long long)scan_bytes *\r\ncmd->stop_arg;\r\nif (dmalen0 > scanlen) {\r\ndmalen0 = scanlen;\r\ndmalen0 &= ~3L;\r\n} else {\r\nif (dmalen1 > (scanlen - dmalen0)) {\r\ndmalen1 = scanlen - dmalen0;\r\ndmalen1 &= ~3L;\r\n}\r\n}\r\n}\r\n}\r\ndevpriv->dma_actbuf = 0;\r\ndmabuf0->use_size = dmalen0;\r\ndmabuf1->use_size = dmalen1;\r\npci9118_amcc_dma_ena(dev, false);\r\npci9118_amcc_setup_dma(dev, 0);\r\noutl(0x00000000 | AINT_WRITE_COMPL,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\npci9118_amcc_dma_ena(dev, true);\r\noutl(inl(devpriv->iobase_a + AMCC_OP_REG_INTCSR) | EN_A2P_TRANSFERS,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_cmd(struct comedi_device *dev, struct comedi_subdevice *s)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct comedi_8254 *pacer = dev->pacer;\r\nstruct comedi_cmd *cmd = &s->async->cmd;\r\nunsigned int addchans = 0;\r\nunsigned int scanlen;\r\ndevpriv->ai12_startstop = 0;\r\ndevpriv->ai_flags = cmd->flags;\r\ndevpriv->ai_add_front = 0;\r\ndevpriv->ai_add_back = 0;\r\nif (cmd->start_src == TRIG_EXT)\r\ndevpriv->ai12_startstop |= START_AI_EXT;\r\nif (cmd->stop_src == TRIG_EXT) {\r\ndevpriv->ai_neverending = 1;\r\ndevpriv->ai12_startstop |= STOP_AI_EXT;\r\n}\r\nif (cmd->stop_src == TRIG_NONE)\r\ndevpriv->ai_neverending = 1;\r\nif (cmd->stop_src == TRIG_COUNT)\r\ndevpriv->ai_neverending = 0;\r\ndevpriv->ai_add_front = 0;\r\ndevpriv->ai_add_back = 0;\r\nif (devpriv->master) {\r\ndevpriv->usedma = 1;\r\nif ((cmd->flags & CMDF_WAKE_EOS) &&\r\n(cmd->scan_end_arg == 1)) {\r\nif (cmd->convert_src == TRIG_NOW)\r\ndevpriv->ai_add_back = 1;\r\nif (cmd->convert_src == TRIG_TIMER) {\r\ndevpriv->usedma = 0;\r\n}\r\n}\r\nif ((cmd->flags & CMDF_WAKE_EOS) &&\r\n(cmd->scan_end_arg & 1) &&\r\n(cmd->scan_end_arg > 1)) {\r\nif (cmd->scan_begin_src == TRIG_FOLLOW) {\r\ndevpriv->usedma = 0;\r\n} else {\r\ndevpriv->ai_add_back = 1;\r\n}\r\n}\r\n} else {\r\ndevpriv->usedma = 0;\r\n}\r\nif (cmd->convert_src == TRIG_NOW && devpriv->softsshdelay) {\r\ndevpriv->ai_add_front = 2;\r\nif ((devpriv->usedma == 1) && (devpriv->ai_add_back == 1)) {\r\ndevpriv->ai_add_front++;\r\ndevpriv->ai_add_back = 0;\r\n}\r\nif (cmd->convert_arg < devpriv->ai_ns_min)\r\ncmd->convert_arg = devpriv->ai_ns_min;\r\naddchans = devpriv->softsshdelay / cmd->convert_arg;\r\nif (devpriv->softsshdelay % cmd->convert_arg)\r\naddchans++;\r\nif (addchans > (devpriv->ai_add_front - 1)) {\r\ndevpriv->ai_add_front = addchans + 1;\r\nif (devpriv->usedma == 1)\r\nif ((devpriv->ai_add_front +\r\ncmd->chanlist_len +\r\ndevpriv->ai_add_back) & 1)\r\ndevpriv->ai_add_front++;\r\n}\r\n}\r\nscanlen = devpriv->ai_add_front + cmd->chanlist_len +\r\ndevpriv->ai_add_back;\r\ndevpriv->ai_n_realscanlen = scanlen *\r\n(cmd->scan_end_arg / cmd->chanlist_len);\r\nif (scanlen > s->len_chanlist) {\r\ndev_err(dev->class_dev,\r\n"range/channel list is too long for actual configuration!\n");\r\nreturn -EINVAL;\r\n}\r\npci9118_set_chanlist(dev, s, cmd->chanlist_len, cmd->chanlist,\r\ndevpriv->ai_add_front, devpriv->ai_add_back);\r\ndevpriv->ai_do = 0;\r\nif (cmd->scan_begin_src != TRIG_TIMER &&\r\ncmd->convert_src == TRIG_TIMER) {\r\nif (cmd->scan_begin_src == TRIG_EXT)\r\ndevpriv->ai_do = 4;\r\nelse\r\ndevpriv->ai_do = 1;\r\ncomedi_8254_cascade_ns_to_timer(pacer, &cmd->convert_arg,\r\ndevpriv->ai_flags &\r\nCMDF_ROUND_NEAREST);\r\ncomedi_8254_update_divisors(pacer);\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;\r\nif (!devpriv->usedma) {\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_INT;\r\ndevpriv->int_ctrl |= PCI9118_INT_CTRL_TIMER;\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nstruct pci9118_dmabuf *dmabuf = &devpriv->dmabuf[0];\r\ndevpriv->ai_cfg |= PCI9118_AI_CFG_AM;\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\ncomedi_8254_load(pacer, 0, dmabuf->hw >> 1,\r\nI8254_MODE0 | I8254_BINARY);\r\ndevpriv->ai_cfg |= PCI9118_AI_CFG_START;\r\n}\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->convert_src != TRIG_EXT) {\r\nif (!devpriv->usedma) {\r\ndev_err(dev->class_dev,\r\n"cmd->scan_begin_src=TRIG_TIMER works only with bus mastering!\n");\r\nreturn -EIO;\r\n}\r\ndevpriv->ai_do = 2;\r\npci9118_calc_divisors(dev, s,\r\n&cmd->scan_begin_arg, &cmd->convert_arg,\r\ndevpriv->ai_flags,\r\ndevpriv->ai_n_realscanlen,\r\n&pacer->divisor1,\r\n&pacer->divisor2,\r\ndevpriv->ai_add_front);\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_TMRTR;\r\ndevpriv->ai_cfg |= PCI9118_AI_CFG_BM | PCI9118_AI_CFG_BS;\r\nif (cmd->convert_src == TRIG_NOW && !devpriv->softsshdelay)\r\ndevpriv->ai_cfg |= PCI9118_AI_CFG_BSSH;\r\noutl(devpriv->ai_n_realscanlen,\r\ndev->iobase + PCI9118_AI_BURST_NUM_REG);\r\n}\r\nif (cmd->scan_begin_src == TRIG_FOLLOW &&\r\ncmd->convert_src == TRIG_EXT) {\r\ndevpriv->ai_do = 3;\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_EXTM;\r\n}\r\nif (devpriv->ai_do == 0) {\r\ndev_err(dev->class_dev,\r\n"Unable to determine acquisition mode! BUG in (*do_cmdtest)?\n");\r\nreturn -EINVAL;\r\n}\r\nif (devpriv->usedma)\r\ndevpriv->ai_ctrl |= PCI9118_AI_CTRL_DMA;\r\ndevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\nudelay(1);\r\npci9118_ai_reset_fifo(dev);\r\ninl(dev->iobase + PCI9118_AI_STATUS_REG);\r\ninl(dev->iobase + PCI9118_INT_CTRL_REG);\r\ndevpriv->ai_act_dmapos = 0;\r\nif (devpriv->usedma) {\r\npci9118_ai_setup_dma(dev, s);\r\noutl(0x02000000 | AINT_WRITE_COMPL,\r\ndevpriv->iobase_a + AMCC_OP_REG_INTCSR);\r\n} else {\r\npci9118_amcc_int_ena(dev, true);\r\n}\r\nif (cmd->start_src == TRIG_NOW)\r\npci9118_ai_cmd_start(dev);\r\nelse if (cmd->start_src == TRIG_INT)\r\ns->async->inttrig = pci9118_ai_inttrig;\r\nif (cmd->start_src == TRIG_EXT || cmd->stop_src == TRIG_EXT)\r\npci9118_exttrg_enable(dev, true);\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_cmdtest(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_cmd *cmd)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nint err = 0;\r\nunsigned int flags;\r\nunsigned int arg;\r\nerr |= comedi_check_trigger_src(&cmd->start_src,\r\nTRIG_NOW | TRIG_EXT | TRIG_INT);\r\nflags = TRIG_FOLLOW;\r\nif (devpriv->master)\r\nflags |= TRIG_TIMER | TRIG_EXT;\r\nerr |= comedi_check_trigger_src(&cmd->scan_begin_src, flags);\r\nflags = TRIG_TIMER | TRIG_EXT;\r\nif (devpriv->master)\r\nflags |= TRIG_NOW;\r\nerr |= comedi_check_trigger_src(&cmd->convert_src, flags);\r\nerr |= comedi_check_trigger_src(&cmd->scan_end_src, TRIG_COUNT);\r\nerr |= comedi_check_trigger_src(&cmd->stop_src,\r\nTRIG_COUNT | TRIG_NONE | TRIG_EXT);\r\nif (err)\r\nreturn 1;\r\nerr |= comedi_check_trigger_is_unique(cmd->start_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->scan_begin_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->convert_src);\r\nerr |= comedi_check_trigger_is_unique(cmd->stop_src);\r\nif (cmd->start_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)\r\nerr |= -EINVAL;\r\nif ((cmd->scan_begin_src & (TRIG_TIMER | TRIG_EXT)) &&\r\n(!(cmd->convert_src & (TRIG_TIMER | TRIG_NOW))))\r\nerr |= -EINVAL;\r\nif ((cmd->scan_begin_src == TRIG_FOLLOW) &&\r\n(!(cmd->convert_src & (TRIG_TIMER | TRIG_EXT))))\r\nerr |= -EINVAL;\r\nif (cmd->stop_src == TRIG_EXT && cmd->scan_begin_src == TRIG_EXT)\r\nerr |= -EINVAL;\r\nif (err)\r\nreturn 2;\r\nswitch (cmd->start_src) {\r\ncase TRIG_NOW:\r\ncase TRIG_EXT:\r\nerr |= comedi_check_trigger_arg_is(&cmd->start_arg, 0);\r\nbreak;\r\ncase TRIG_INT:\r\nbreak;\r\n}\r\nif (cmd->scan_begin_src & (TRIG_FOLLOW | TRIG_EXT))\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, 0);\r\nif ((cmd->scan_begin_src == TRIG_TIMER) &&\r\n(cmd->convert_src == TRIG_TIMER) && (cmd->scan_end_arg == 1)) {\r\ncmd->scan_begin_src = TRIG_FOLLOW;\r\ncmd->convert_arg = cmd->scan_begin_arg;\r\ncmd->scan_begin_arg = 0;\r\n}\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_begin_arg,\r\ndevpriv->ai_ns_min);\r\n}\r\nif (cmd->scan_begin_src == TRIG_EXT) {\r\nif (cmd->scan_begin_arg) {\r\ncmd->scan_begin_arg = 0;\r\nerr |= -EINVAL;\r\nerr |= comedi_check_trigger_arg_max(&cmd->scan_end_arg,\r\n65535);\r\n}\r\n}\r\nif (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {\r\nerr |= comedi_check_trigger_arg_min(&cmd->convert_arg,\r\ndevpriv->ai_ns_min);\r\n}\r\nif (cmd->convert_src == TRIG_EXT)\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, 0);\r\nif (cmd->stop_src == TRIG_COUNT)\r\nerr |= comedi_check_trigger_arg_min(&cmd->stop_arg, 1);\r\nelse\r\nerr |= comedi_check_trigger_arg_is(&cmd->stop_arg, 0);\r\nerr |= comedi_check_trigger_arg_min(&cmd->chanlist_len, 1);\r\nerr |= comedi_check_trigger_arg_min(&cmd->scan_end_arg,\r\ncmd->chanlist_len);\r\nif ((cmd->scan_end_arg % cmd->chanlist_len)) {\r\ncmd->scan_end_arg =\r\ncmd->chanlist_len * (cmd->scan_end_arg / cmd->chanlist_len);\r\nerr |= -EINVAL;\r\n}\r\nif (err)\r\nreturn 3;\r\nif (cmd->scan_begin_src == TRIG_TIMER) {\r\narg = cmd->scan_begin_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->scan_begin_arg, arg);\r\n}\r\nif (cmd->convert_src & (TRIG_TIMER | TRIG_NOW)) {\r\narg = cmd->convert_arg;\r\ncomedi_8254_cascade_ns_to_timer(dev->pacer, &arg, cmd->flags);\r\nerr |= comedi_check_trigger_arg_is(&cmd->convert_arg, arg);\r\nif (cmd->scan_begin_src == TRIG_TIMER &&\r\ncmd->convert_src == TRIG_NOW) {\r\nif (cmd->convert_arg == 0) {\r\narg = devpriv->ai_ns_min *\r\n(cmd->scan_end_arg + 2);\r\n} else {\r\narg = cmd->convert_arg * cmd->chanlist_len;\r\n}\r\nerr |= comedi_check_trigger_arg_min(\r\n&cmd->scan_begin_arg, arg);\r\n}\r\n}\r\nif (err)\r\nreturn 4;\r\nif (cmd->chanlist)\r\nerr |= pci9118_ai_check_chanlist(dev, s, cmd);\r\nif (err)\r\nreturn 5;\r\nreturn 0;\r\n}\r\nstatic int pci9118_ai_eoc(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned long context)\r\n{\r\nunsigned int status;\r\nstatus = inl(dev->iobase + PCI9118_AI_STATUS_REG);\r\nif (status & PCI9118_AI_STATUS_ADRDY)\r\nreturn 0;\r\nreturn -EBUSY;\r\n}\r\nstatic void pci9118_ai_start_conv(struct comedi_device *dev)\r\n{\r\noutl(0, dev->iobase + PCI9118_SOFTTRG_REG);\r\n}\r\nstatic int pci9118_ai_insn_read(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nunsigned int val;\r\nint ret;\r\nint i;\r\npci9118_set_chanlist(dev, s, 1, &insn->chanspec, 0, 0);\r\ndevpriv->ai_cfg = PCI9118_AI_CFG_PDTRG | PCI9118_AI_CFG_PETRG;\r\noutl(devpriv->ai_cfg, dev->iobase + PCI9118_AI_CFG_REG);\r\npci9118_ai_reset_fifo(dev);\r\nfor (i = 0; i < insn->n; i++) {\r\npci9118_ai_start_conv(dev);\r\nret = comedi_timeout(dev, s, insn, pci9118_ai_eoc, 0);\r\nif (ret)\r\nreturn ret;\r\nval = inl(dev->iobase + PCI9118_AI_FIFO_REG);\r\nif (s->maxdata == 0xffff)\r\ndata[i] = (val & 0xffff) ^ 0x8000;\r\nelse\r\ndata[i] = (val >> 4) & 0xfff;\r\n}\r\nreturn insn->n;\r\n}\r\nstatic int pci9118_ao_insn_write(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nunsigned int chan = CR_CHAN(insn->chanspec);\r\nunsigned int val = s->readback[chan];\r\nint i;\r\nfor (i = 0; i < insn->n; i++) {\r\nval = data[i];\r\noutl(val, dev->iobase + PCI9118_AO_REG(chan));\r\n}\r\ns->readback[chan] = val;\r\nreturn insn->n;\r\n}\r\nstatic int pci9118_di_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\ndata[1] = inl(dev->iobase + PCI9118_DIO_REG) & 0xf;\r\nreturn insn->n;\r\n}\r\nstatic int pci9118_do_insn_bits(struct comedi_device *dev,\r\nstruct comedi_subdevice *s,\r\nstruct comedi_insn *insn,\r\nunsigned int *data)\r\n{\r\nif (comedi_dio_update_state(s, data))\r\noutl(s->state, dev->iobase + PCI9118_DIO_REG);\r\ndata[1] = s->state;\r\nreturn insn->n;\r\n}\r\nstatic void pci9118_reset(struct comedi_device *dev)\r\n{\r\noutl(0, dev->iobase + PCI9118_INT_CTRL_REG);\r\noutl(0, dev->iobase + PCI9118_AI_CTRL_REG);\r\noutl(0, dev->iobase + PCI9118_AI_CFG_REG);\r\npci9118_ai_reset_fifo(dev);\r\ninl(dev->iobase + PCI9118_INT_CTRL_REG);\r\ninl(dev->iobase + PCI9118_AI_STATUS_REG);\r\noutl(0, dev->iobase + PCI9118_AI_BURST_NUM_REG);\r\noutl(1, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\noutl(2, dev->iobase + PCI9118_AI_AUTOSCAN_MODE_REG);\r\noutl(2047, dev->iobase + PCI9118_AO_REG(0));\r\noutl(2047, dev->iobase + PCI9118_AO_REG(1));\r\n}\r\nstatic struct pci_dev *pci9118_find_pci(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct pci_dev *pcidev = NULL;\r\nint bus = it->options[0];\r\nint slot = it->options[1];\r\nfor_each_pci_dev(pcidev) {\r\nif (pcidev->vendor != PCI_VENDOR_ID_AMCC)\r\ncontinue;\r\nif (pcidev->device != 0x80d9)\r\ncontinue;\r\nif (bus || slot) {\r\nif (pcidev->bus->number != bus ||\r\nPCI_SLOT(pcidev->devfn) != slot)\r\ncontinue;\r\n}\r\nreturn pcidev;\r\n}\r\ndev_err(dev->class_dev,\r\n"no supported board found! (req. bus/slot : %d/%d)\n",\r\nbus, slot);\r\nreturn NULL;\r\n}\r\nstatic void pci9118_alloc_dma(struct comedi_device *dev)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct pci9118_dmabuf *dmabuf;\r\nint order;\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\ndmabuf = &devpriv->dmabuf[i];\r\nfor (order = 2; order >= 0; order--) {\r\ndmabuf->virt =\r\ndma_alloc_coherent(dev->hw_dev, PAGE_SIZE << order,\r\n&dmabuf->hw, GFP_KERNEL);\r\nif (dmabuf->virt)\r\nbreak;\r\n}\r\nif (!dmabuf->virt)\r\nbreak;\r\ndmabuf->size = PAGE_SIZE << order;\r\nif (i == 0)\r\ndevpriv->master = 1;\r\nif (i == 1)\r\ndevpriv->dma_doublebuf = 1;\r\n}\r\n}\r\nstatic void pci9118_free_dma(struct comedi_device *dev)\r\n{\r\nstruct pci9118_private *devpriv = dev->private;\r\nstruct pci9118_dmabuf *dmabuf;\r\nint i;\r\nif (!devpriv)\r\nreturn;\r\nfor (i = 0; i < 2; i++) {\r\ndmabuf = &devpriv->dmabuf[i];\r\nif (dmabuf->virt) {\r\ndma_free_coherent(dev->hw_dev, dmabuf->size,\r\ndmabuf->virt, dmabuf->hw);\r\n}\r\n}\r\n}\r\nstatic int pci9118_common_attach(struct comedi_device *dev,\r\nint ext_mux, int softsshdelay)\r\n{\r\nconst struct pci9118_boardinfo *board = dev->board_ptr;\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nstruct pci9118_private *devpriv;\r\nstruct comedi_subdevice *s;\r\nint ret;\r\nint i;\r\nu16 u16w;\r\ndevpriv = comedi_alloc_devpriv(dev, sizeof(*devpriv));\r\nif (!devpriv)\r\nreturn -ENOMEM;\r\nret = comedi_pci_enable(dev);\r\nif (ret)\r\nreturn ret;\r\npci_set_master(pcidev);\r\ndevpriv->iobase_a = pci_resource_start(pcidev, 0);\r\ndev->iobase = pci_resource_start(pcidev, 2);\r\ndev->pacer = comedi_8254_init(dev->iobase + PCI9118_TIMER_BASE,\r\nI8254_OSC_BASE_4MHZ, I8254_IO32, 0);\r\nif (!dev->pacer)\r\nreturn -ENOMEM;\r\npci9118_reset(dev);\r\nif (pcidev->irq) {\r\nret = request_irq(pcidev->irq, pci9118_interrupt, IRQF_SHARED,\r\ndev->board_name, dev);\r\nif (ret == 0) {\r\ndev->irq = pcidev->irq;\r\npci9118_alloc_dma(dev);\r\n}\r\n}\r\nif (ext_mux > 0) {\r\nif (ext_mux > 256)\r\next_mux = 256;\r\nif (softsshdelay > 0)\r\nif (ext_mux > 128)\r\next_mux = 128;\r\ndevpriv->usemux = 1;\r\n} else {\r\ndevpriv->usemux = 0;\r\n}\r\nif (softsshdelay < 0) {\r\ndevpriv->softsshdelay = -softsshdelay;\r\ndevpriv->softsshsample = 0x80;\r\ndevpriv->softsshhold = 0x00;\r\n} else {\r\ndevpriv->softsshdelay = softsshdelay;\r\ndevpriv->softsshsample = 0x00;\r\ndevpriv->softsshhold = 0x80;\r\n}\r\npci_read_config_word(pcidev, PCI_COMMAND, &u16w);\r\npci_write_config_word(pcidev, PCI_COMMAND, u16w | 64);\r\nret = comedi_alloc_subdevices(dev, 4);\r\nif (ret)\r\nreturn ret;\r\ns = &dev->subdevices[0];\r\ns->type = COMEDI_SUBD_AI;\r\ns->subdev_flags = SDF_READABLE | SDF_COMMON | SDF_GROUND | SDF_DIFF;\r\ns->n_chan = (devpriv->usemux) ? ext_mux : 16;\r\ns->maxdata = board->ai_is_16bit ? 0xffff : 0x0fff;\r\ns->range_table = board->is_hg ? &pci9118hg_ai_range\r\n: &pci9118_ai_range;\r\ns->insn_read = pci9118_ai_insn_read;\r\nif (dev->irq) {\r\ndev->read_subdev = s;\r\ns->subdev_flags |= SDF_CMD_READ;\r\ns->len_chanlist = 255;\r\ns->do_cmdtest = pci9118_ai_cmdtest;\r\ns->do_cmd = pci9118_ai_cmd;\r\ns->cancel = pci9118_ai_cancel;\r\ns->munge = pci9118_ai_munge;\r\n}\r\nif (s->maxdata == 0xffff) {\r\ndevpriv->ai_ns_min = 10000;\r\n} else {\r\ndevpriv->ai_ns_min = 3000;\r\n}\r\ns = &dev->subdevices[1];\r\ns->type = COMEDI_SUBD_AO;\r\ns->subdev_flags = SDF_WRITABLE | SDF_GROUND | SDF_COMMON;\r\ns->n_chan = 2;\r\ns->maxdata = 0x0fff;\r\ns->range_table = &range_bipolar10;\r\ns->insn_write = pci9118_ao_insn_write;\r\nret = comedi_alloc_subdev_readback(s);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < s->n_chan; i++)\r\ns->readback[i] = 2047;\r\ns = &dev->subdevices[2];\r\ns->type = COMEDI_SUBD_DI;\r\ns->subdev_flags = SDF_READABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pci9118_di_insn_bits;\r\ns = &dev->subdevices[3];\r\ns->type = COMEDI_SUBD_DO;\r\ns->subdev_flags = SDF_WRITABLE;\r\ns->n_chan = 4;\r\ns->maxdata = 1;\r\ns->range_table = &range_digital;\r\ns->insn_bits = pci9118_do_insn_bits;\r\ns->state = inl(dev->iobase + PCI9118_DIO_REG) >> 4;\r\nreturn 0;\r\n}\r\nstatic int pci9118_attach(struct comedi_device *dev,\r\nstruct comedi_devconfig *it)\r\n{\r\nstruct pci_dev *pcidev;\r\nint ext_mux, softsshdelay;\r\next_mux = it->options[2];\r\nsoftsshdelay = it->options[4];\r\npcidev = pci9118_find_pci(dev, it);\r\nif (!pcidev)\r\nreturn -EIO;\r\ncomedi_set_hw_dev(dev, &pcidev->dev);\r\nreturn pci9118_common_attach(dev, ext_mux, softsshdelay);\r\n}\r\nstatic int pci9118_auto_attach(struct comedi_device *dev,\r\nunsigned long context)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nconst struct pci9118_boardinfo *board = NULL;\r\nif (context < ARRAY_SIZE(pci9118_boards))\r\nboard = &pci9118_boards[context];\r\nif (!board)\r\nreturn -ENODEV;\r\ndev->board_ptr = board;\r\ndev->board_name = board->name;\r\npci_dev_get(pcidev);\r\nreturn pci9118_common_attach(dev, 0, 0);\r\n}\r\nstatic void pci9118_detach(struct comedi_device *dev)\r\n{\r\nstruct pci_dev *pcidev = comedi_to_pci_dev(dev);\r\nif (dev->iobase)\r\npci9118_reset(dev);\r\ncomedi_pci_detach(dev);\r\npci9118_free_dma(dev);\r\npci_dev_put(pcidev);\r\n}\r\nstatic int adl_pci9118_pci_probe(struct pci_dev *dev,\r\nconst struct pci_device_id *id)\r\n{\r\nreturn comedi_pci_auto_config(dev, &adl_pci9118_driver,\r\nid->driver_data);\r\n}
