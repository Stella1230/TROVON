static int tps65910_irq_init(struct tps65910 *tps65910, int irq,\r\nstruct tps65910_platform_data *pdata)\r\n{\r\nint ret = 0;\r\nstatic struct regmap_irq_chip *tps6591x_irqs_chip;\r\nif (!irq) {\r\ndev_warn(tps65910->dev, "No interrupt support, no core IRQ\n");\r\nreturn -EINVAL;\r\n}\r\nif (!pdata) {\r\ndev_warn(tps65910->dev, "No interrupt support, no pdata\n");\r\nreturn -EINVAL;\r\n}\r\nswitch (tps65910_chip_id(tps65910)) {\r\ncase TPS65910:\r\ntps6591x_irqs_chip = &tps65910_irq_chip;\r\nbreak;\r\ncase TPS65911:\r\ntps6591x_irqs_chip = &tps65911_irq_chip;\r\nbreak;\r\n}\r\ntps65910->chip_irq = irq;\r\nret = devm_regmap_add_irq_chip(tps65910->dev, tps65910->regmap,\r\ntps65910->chip_irq,\r\nIRQF_ONESHOT, pdata->irq_base,\r\ntps6591x_irqs_chip, &tps65910->irq_data);\r\nif (ret < 0) {\r\ndev_warn(tps65910->dev, "Failed to add irq_chip %d\n", ret);\r\ntps65910->chip_irq = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic bool is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nstruct tps65910 *tps65910 = dev_get_drvdata(dev);\r\nif ((reg >= TPS65910_VIO) && (reg <= TPS65910_VDAC)) {\r\nif (tps65910_chip_id(tps65910) == TPS65910)\r\nif ((reg == TPS65911_VDDCTRL_OP) ||\r\n(reg == TPS65911_VDDCTRL_SR))\r\nreturn true;\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int tps65910_ck32k_init(struct tps65910 *tps65910,\r\nstruct tps65910_board *pmic_pdata)\r\n{\r\nint ret;\r\nif (!pmic_pdata->en_ck32k_xtal)\r\nreturn 0;\r\nret = tps65910_reg_clear_bits(tps65910, TPS65910_DEVCTRL,\r\nDEVCTRL_CK32K_CTRL_MASK);\r\nif (ret < 0) {\r\ndev_err(tps65910->dev, "clear ck32k_ctrl failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int tps65910_sleepinit(struct tps65910 *tps65910,\r\nstruct tps65910_board *pmic_pdata)\r\n{\r\nstruct device *dev = NULL;\r\nint ret = 0;\r\ndev = tps65910->dev;\r\nif (!pmic_pdata->en_dev_slp)\r\nreturn 0;\r\nret = tps65910_reg_set_bits(tps65910, TPS65910_DEVCTRL,\r\nDEVCTRL_DEV_SLP_MASK);\r\nif (ret < 0) {\r\ndev_err(dev, "set dev_slp failed: %d\n", ret);\r\ngoto err_sleep_init;\r\n}\r\nif (!pmic_pdata->slp_keepon)\r\nreturn 0;\r\nif (pmic_pdata->slp_keepon->therm_keepon) {\r\nret = tps65910_reg_set_bits(tps65910,\r\nTPS65910_SLEEP_KEEP_RES_ON,\r\nSLEEP_KEEP_RES_ON_THERM_KEEPON_MASK);\r\nif (ret < 0) {\r\ndev_err(dev, "set therm_keepon failed: %d\n", ret);\r\ngoto disable_dev_slp;\r\n}\r\n}\r\nif (pmic_pdata->slp_keepon->clkout32k_keepon) {\r\nret = tps65910_reg_set_bits(tps65910,\r\nTPS65910_SLEEP_KEEP_RES_ON,\r\nSLEEP_KEEP_RES_ON_CLKOUT32K_KEEPON_MASK);\r\nif (ret < 0) {\r\ndev_err(dev, "set clkout32k_keepon failed: %d\n", ret);\r\ngoto disable_dev_slp;\r\n}\r\n}\r\nif (pmic_pdata->slp_keepon->i2chs_keepon) {\r\nret = tps65910_reg_set_bits(tps65910,\r\nTPS65910_SLEEP_KEEP_RES_ON,\r\nSLEEP_KEEP_RES_ON_I2CHS_KEEPON_MASK);\r\nif (ret < 0) {\r\ndev_err(dev, "set i2chs_keepon failed: %d\n", ret);\r\ngoto disable_dev_slp;\r\n}\r\n}\r\nreturn 0;\r\ndisable_dev_slp:\r\ntps65910_reg_clear_bits(tps65910, TPS65910_DEVCTRL,\r\nDEVCTRL_DEV_SLP_MASK);\r\nerr_sleep_init:\r\nreturn ret;\r\n}\r\nstatic struct tps65910_board *tps65910_parse_dt(struct i2c_client *client,\r\nunsigned long *chip_id)\r\n{\r\nstruct device_node *np = client->dev.of_node;\r\nstruct tps65910_board *board_info;\r\nunsigned int prop;\r\nconst struct of_device_id *match;\r\nint ret = 0;\r\nmatch = of_match_device(tps65910_of_match, &client->dev);\r\nif (!match) {\r\ndev_err(&client->dev, "Failed to find matching dt id\n");\r\nreturn NULL;\r\n}\r\n*chip_id = (unsigned long)match->data;\r\nboard_info = devm_kzalloc(&client->dev, sizeof(*board_info),\r\nGFP_KERNEL);\r\nif (!board_info) {\r\ndev_err(&client->dev, "Failed to allocate pdata\n");\r\nreturn NULL;\r\n}\r\nret = of_property_read_u32(np, "ti,vmbch-threshold", &prop);\r\nif (!ret)\r\nboard_info->vmbch_threshold = prop;\r\nret = of_property_read_u32(np, "ti,vmbch2-threshold", &prop);\r\nif (!ret)\r\nboard_info->vmbch2_threshold = prop;\r\nprop = of_property_read_bool(np, "ti,en-ck32k-xtal");\r\nboard_info->en_ck32k_xtal = prop;\r\nboard_info->irq = client->irq;\r\nboard_info->irq_base = -1;\r\nboard_info->pm_off = of_property_read_bool(np,\r\n"ti,system-power-controller");\r\nreturn board_info;\r\n}\r\nstatic inline\r\nstruct tps65910_board *tps65910_parse_dt(struct i2c_client *client,\r\nunsigned long *chip_id)\r\n{\r\nreturn NULL;\r\n}\r\nstatic void tps65910_power_off(void)\r\n{\r\nstruct tps65910 *tps65910;\r\ntps65910 = dev_get_drvdata(&tps65910_i2c_client->dev);\r\nif (tps65910_reg_set_bits(tps65910, TPS65910_DEVCTRL,\r\nDEVCTRL_PWR_OFF_MASK) < 0)\r\nreturn;\r\ntps65910_reg_clear_bits(tps65910, TPS65910_DEVCTRL,\r\nDEVCTRL_DEV_ON_MASK);\r\n}\r\nstatic int tps65910_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct tps65910 *tps65910;\r\nstruct tps65910_board *pmic_plat_data;\r\nstruct tps65910_board *of_pmic_plat_data = NULL;\r\nstruct tps65910_platform_data *init_data;\r\nunsigned long chip_id = id->driver_data;\r\nint ret = 0;\r\npmic_plat_data = dev_get_platdata(&i2c->dev);\r\nif (!pmic_plat_data && i2c->dev.of_node) {\r\npmic_plat_data = tps65910_parse_dt(i2c, &chip_id);\r\nof_pmic_plat_data = pmic_plat_data;\r\n}\r\nif (!pmic_plat_data)\r\nreturn -EINVAL;\r\ninit_data = devm_kzalloc(&i2c->dev, sizeof(*init_data), GFP_KERNEL);\r\nif (init_data == NULL)\r\nreturn -ENOMEM;\r\ntps65910 = devm_kzalloc(&i2c->dev, sizeof(*tps65910), GFP_KERNEL);\r\nif (tps65910 == NULL)\r\nreturn -ENOMEM;\r\ntps65910->of_plat_data = of_pmic_plat_data;\r\ni2c_set_clientdata(i2c, tps65910);\r\ntps65910->dev = &i2c->dev;\r\ntps65910->i2c_client = i2c;\r\ntps65910->id = chip_id;\r\ni2c_master_send(i2c, "", 1);\r\ntps65910->regmap = devm_regmap_init_i2c(i2c, &tps65910_regmap_config);\r\nif (IS_ERR(tps65910->regmap)) {\r\nret = PTR_ERR(tps65910->regmap);\r\ndev_err(&i2c->dev, "regmap initialization failed: %d\n", ret);\r\nreturn ret;\r\n}\r\ninit_data->irq = pmic_plat_data->irq;\r\ninit_data->irq_base = pmic_plat_data->irq_base;\r\ntps65910_irq_init(tps65910, init_data->irq, init_data);\r\ntps65910_ck32k_init(tps65910, pmic_plat_data);\r\ntps65910_sleepinit(tps65910, pmic_plat_data);\r\nif (pmic_plat_data->pm_off && !pm_power_off) {\r\ntps65910_i2c_client = i2c;\r\npm_power_off = tps65910_power_off;\r\n}\r\nret = devm_mfd_add_devices(tps65910->dev, -1,\r\ntps65910s, ARRAY_SIZE(tps65910s),\r\nNULL, 0,\r\nregmap_irq_get_domain(tps65910->irq_data));\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "mfd_add_devices failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn ret;\r\n}\r\nstatic int __init tps65910_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&tps65910_i2c_driver);\r\n}\r\nstatic void __exit tps65910_i2c_exit(void)\r\n{\r\ni2c_del_driver(&tps65910_i2c_driver);\r\n}
