int v4l2_mc_create_media_graph(struct media_device *mdev)\r\n{\r\nstruct media_entity *entity;\r\nstruct media_entity *if_vid = NULL, *if_aud = NULL;\r\nstruct media_entity *tuner = NULL, *decoder = NULL;\r\nstruct media_entity *io_v4l = NULL, *io_vbi = NULL, *io_swradio = NULL;\r\nbool is_webcam = false;\r\nu32 flags;\r\nint ret;\r\nif (!mdev)\r\nreturn 0;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nswitch (entity->function) {\r\ncase MEDIA_ENT_F_IF_VID_DECODER:\r\nif_vid = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_IF_AUD_DECODER:\r\nif_aud = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_TUNER:\r\ntuner = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_ATV_DECODER:\r\ndecoder = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_IO_V4L:\r\nio_v4l = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_IO_VBI:\r\nio_vbi = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_IO_SWRADIO:\r\nio_swradio = entity;\r\nbreak;\r\ncase MEDIA_ENT_F_CAM_SENSOR:\r\nis_webcam = true;\r\nbreak;\r\n}\r\n}\r\nif (!io_v4l && !io_vbi && !io_swradio)\r\nreturn -EINVAL;\r\nif (is_webcam) {\r\nif (!io_v4l)\r\nreturn -EINVAL;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif (entity->function != MEDIA_ENT_F_CAM_SENSOR)\r\ncontinue;\r\nret = media_create_pad_link(entity, 0,\r\nio_v4l, 0,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (!decoder)\r\nreturn 0;\r\n}\r\nif (!decoder)\r\nreturn -EINVAL;\r\nif (tuner) {\r\nif (if_vid) {\r\nret = media_create_pad_link(tuner, TUNER_PAD_OUTPUT,\r\nif_vid,\r\nIF_VID_DEC_PAD_IF_INPUT,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\nret = media_create_pad_link(if_vid, IF_VID_DEC_PAD_OUT,\r\ndecoder, DEMOD_PAD_IF_INPUT,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nret = media_create_pad_link(tuner, TUNER_PAD_OUTPUT,\r\ndecoder, DEMOD_PAD_IF_INPUT,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (if_aud) {\r\nret = media_create_pad_link(tuner, TUNER_PAD_AUD_OUT,\r\nif_aud,\r\nIF_AUD_DEC_PAD_IF_INPUT,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n} else {\r\nif_aud = tuner;\r\n}\r\n}\r\nif (io_v4l) {\r\nret = media_create_pad_link(decoder, DEMOD_PAD_VID_OUT,\r\nio_v4l, 0,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (io_swradio) {\r\nret = media_create_pad_link(decoder, DEMOD_PAD_VID_OUT,\r\nio_swradio, 0,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (io_vbi) {\r\nret = media_create_pad_link(decoder, DEMOD_PAD_VBI_OUT,\r\nio_vbi, 0,\r\nMEDIA_LNK_FL_ENABLED);\r\nif (ret)\r\nreturn ret;\r\n}\r\nflags = MEDIA_LNK_FL_ENABLED;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nswitch (entity->function) {\r\ncase MEDIA_ENT_F_CONN_RF:\r\nif (!tuner)\r\ncontinue;\r\nret = media_create_pad_link(entity, 0, tuner,\r\nTUNER_PAD_RF_INPUT,\r\nflags);\r\nbreak;\r\ncase MEDIA_ENT_F_CONN_SVIDEO:\r\ncase MEDIA_ENT_F_CONN_COMPOSITE:\r\nret = media_create_pad_link(entity, 0, decoder,\r\nDEMOD_PAD_IF_INPUT,\r\nflags);\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nif (ret)\r\nreturn ret;\r\nflags = 0;\r\n}\r\nreturn 0;\r\n}\r\nint v4l_enable_media_source(struct video_device *vdev)\r\n{\r\nstruct media_device *mdev = vdev->entity.graph_obj.mdev;\r\nint ret = 0, err;\r\nif (!mdev)\r\nreturn 0;\r\nmutex_lock(&mdev->graph_mutex);\r\nif (!mdev->enable_source)\r\ngoto end;\r\nerr = mdev->enable_source(&vdev->entity, &vdev->pipe);\r\nif (err)\r\nret = -EBUSY;\r\nend:\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nvoid v4l_disable_media_source(struct video_device *vdev)\r\n{\r\nstruct media_device *mdev = vdev->entity.graph_obj.mdev;\r\nif (mdev) {\r\nmutex_lock(&mdev->graph_mutex);\r\nif (mdev->disable_source)\r\nmdev->disable_source(&vdev->entity);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\n}\r\nint v4l_vb2q_enable_media_source(struct vb2_queue *q)\r\n{\r\nstruct v4l2_fh *fh = q->owner;\r\nif (fh && fh->vdev)\r\nreturn v4l_enable_media_source(fh->vdev);\r\nreturn 0;\r\n}\r\nstatic int pipeline_pm_use_count(struct media_entity *entity,\r\nstruct media_graph *graph)\r\n{\r\nint use = 0;\r\nmedia_graph_walk_start(graph, entity);\r\nwhile ((entity = media_graph_walk_next(graph))) {\r\nif (is_media_entity_v4l2_video_device(entity))\r\nuse += entity->use_count;\r\n}\r\nreturn use;\r\n}\r\nstatic int pipeline_pm_power_one(struct media_entity *entity, int change)\r\n{\r\nstruct v4l2_subdev *subdev;\r\nint ret;\r\nsubdev = is_media_entity_v4l2_subdev(entity)\r\n? media_entity_to_v4l2_subdev(entity) : NULL;\r\nif (entity->use_count == 0 && change > 0 && subdev != NULL) {\r\nret = v4l2_subdev_call(subdev, core, s_power, 1);\r\nif (ret < 0 && ret != -ENOIOCTLCMD)\r\nreturn ret;\r\n}\r\nentity->use_count += change;\r\nWARN_ON(entity->use_count < 0);\r\nif (entity->use_count == 0 && change < 0 && subdev != NULL)\r\nv4l2_subdev_call(subdev, core, s_power, 0);\r\nreturn 0;\r\n}\r\nstatic int pipeline_pm_power(struct media_entity *entity, int change,\r\nstruct media_graph *graph)\r\n{\r\nstruct media_entity *first = entity;\r\nint ret = 0;\r\nif (!change)\r\nreturn 0;\r\nmedia_graph_walk_start(graph, entity);\r\nwhile (!ret && (entity = media_graph_walk_next(graph)))\r\nif (is_media_entity_v4l2_subdev(entity))\r\nret = pipeline_pm_power_one(entity, change);\r\nif (!ret)\r\nreturn ret;\r\nmedia_graph_walk_start(graph, first);\r\nwhile ((first = media_graph_walk_next(graph))\r\n&& first != entity)\r\nif (is_media_entity_v4l2_subdev(first))\r\npipeline_pm_power_one(first, -change);\r\nreturn ret;\r\n}\r\nint v4l2_pipeline_pm_use(struct media_entity *entity, int use)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nint change = use ? 1 : -1;\r\nint ret;\r\nmutex_lock(&mdev->graph_mutex);\r\nentity->use_count += change;\r\nWARN_ON(entity->use_count < 0);\r\nret = pipeline_pm_power(entity, change, &mdev->pm_count_walk);\r\nif (ret < 0)\r\nentity->use_count -= change;\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nint v4l2_pipeline_link_notify(struct media_link *link, u32 flags,\r\nunsigned int notification)\r\n{\r\nstruct media_graph *graph = &link->graph_obj.mdev->pm_count_walk;\r\nstruct media_entity *source = link->source->entity;\r\nstruct media_entity *sink = link->sink->entity;\r\nint source_use;\r\nint sink_use;\r\nint ret = 0;\r\nsource_use = pipeline_pm_use_count(source, graph);\r\nsink_use = pipeline_pm_use_count(sink, graph);\r\nif (notification == MEDIA_DEV_NOTIFY_POST_LINK_CH &&\r\n!(flags & MEDIA_LNK_FL_ENABLED)) {\r\npipeline_pm_power(source, -sink_use, graph);\r\npipeline_pm_power(sink, -source_use, graph);\r\nreturn 0;\r\n}\r\nif (notification == MEDIA_DEV_NOTIFY_PRE_LINK_CH &&\r\n(flags & MEDIA_LNK_FL_ENABLED)) {\r\nret = pipeline_pm_power(source, sink_use, graph);\r\nif (ret < 0)\r\nreturn ret;\r\nret = pipeline_pm_power(sink, source_use, graph);\r\nif (ret < 0)\r\npipeline_pm_power(source, -sink_use, graph);\r\n}\r\nreturn ret;\r\n}
