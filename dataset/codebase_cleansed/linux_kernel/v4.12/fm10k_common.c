s32 fm10k_get_bus_info_generic(struct fm10k_hw *hw)\r\n{\r\nu16 link_cap, link_status, device_cap, device_control;\r\nlink_cap = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_LINK_CAP);\r\nswitch (link_cap & FM10K_PCIE_LINK_WIDTH) {\r\ncase FM10K_PCIE_LINK_WIDTH_1:\r\nhw->bus_caps.width = fm10k_bus_width_pcie_x1;\r\nbreak;\r\ncase FM10K_PCIE_LINK_WIDTH_2:\r\nhw->bus_caps.width = fm10k_bus_width_pcie_x2;\r\nbreak;\r\ncase FM10K_PCIE_LINK_WIDTH_4:\r\nhw->bus_caps.width = fm10k_bus_width_pcie_x4;\r\nbreak;\r\ncase FM10K_PCIE_LINK_WIDTH_8:\r\nhw->bus_caps.width = fm10k_bus_width_pcie_x8;\r\nbreak;\r\ndefault:\r\nhw->bus_caps.width = fm10k_bus_width_unknown;\r\nbreak;\r\n}\r\nswitch (link_cap & FM10K_PCIE_LINK_SPEED) {\r\ncase FM10K_PCIE_LINK_SPEED_2500:\r\nhw->bus_caps.speed = fm10k_bus_speed_2500;\r\nbreak;\r\ncase FM10K_PCIE_LINK_SPEED_5000:\r\nhw->bus_caps.speed = fm10k_bus_speed_5000;\r\nbreak;\r\ncase FM10K_PCIE_LINK_SPEED_8000:\r\nhw->bus_caps.speed = fm10k_bus_speed_8000;\r\nbreak;\r\ndefault:\r\nhw->bus_caps.speed = fm10k_bus_speed_unknown;\r\nbreak;\r\n}\r\ndevice_cap = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_DEV_CAP);\r\nswitch (device_cap & FM10K_PCIE_DEV_CAP_PAYLOAD) {\r\ncase FM10K_PCIE_DEV_CAP_PAYLOAD_128:\r\nhw->bus_caps.payload = fm10k_bus_payload_128;\r\nbreak;\r\ncase FM10K_PCIE_DEV_CAP_PAYLOAD_256:\r\nhw->bus_caps.payload = fm10k_bus_payload_256;\r\nbreak;\r\ncase FM10K_PCIE_DEV_CAP_PAYLOAD_512:\r\nhw->bus_caps.payload = fm10k_bus_payload_512;\r\nbreak;\r\ndefault:\r\nhw->bus_caps.payload = fm10k_bus_payload_unknown;\r\nbreak;\r\n}\r\nlink_status = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_LINK_STATUS);\r\nswitch (link_status & FM10K_PCIE_LINK_WIDTH) {\r\ncase FM10K_PCIE_LINK_WIDTH_1:\r\nhw->bus.width = fm10k_bus_width_pcie_x1;\r\nbreak;\r\ncase FM10K_PCIE_LINK_WIDTH_2:\r\nhw->bus.width = fm10k_bus_width_pcie_x2;\r\nbreak;\r\ncase FM10K_PCIE_LINK_WIDTH_4:\r\nhw->bus.width = fm10k_bus_width_pcie_x4;\r\nbreak;\r\ncase FM10K_PCIE_LINK_WIDTH_8:\r\nhw->bus.width = fm10k_bus_width_pcie_x8;\r\nbreak;\r\ndefault:\r\nhw->bus.width = fm10k_bus_width_unknown;\r\nbreak;\r\n}\r\nswitch (link_status & FM10K_PCIE_LINK_SPEED) {\r\ncase FM10K_PCIE_LINK_SPEED_2500:\r\nhw->bus.speed = fm10k_bus_speed_2500;\r\nbreak;\r\ncase FM10K_PCIE_LINK_SPEED_5000:\r\nhw->bus.speed = fm10k_bus_speed_5000;\r\nbreak;\r\ncase FM10K_PCIE_LINK_SPEED_8000:\r\nhw->bus.speed = fm10k_bus_speed_8000;\r\nbreak;\r\ndefault:\r\nhw->bus.speed = fm10k_bus_speed_unknown;\r\nbreak;\r\n}\r\ndevice_control = fm10k_read_pci_cfg_word(hw, FM10K_PCIE_DEV_CTRL);\r\nswitch (device_control & FM10K_PCIE_DEV_CTRL_PAYLOAD) {\r\ncase FM10K_PCIE_DEV_CTRL_PAYLOAD_128:\r\nhw->bus.payload = fm10k_bus_payload_128;\r\nbreak;\r\ncase FM10K_PCIE_DEV_CTRL_PAYLOAD_256:\r\nhw->bus.payload = fm10k_bus_payload_256;\r\nbreak;\r\ncase FM10K_PCIE_DEV_CTRL_PAYLOAD_512:\r\nhw->bus.payload = fm10k_bus_payload_512;\r\nbreak;\r\ndefault:\r\nhw->bus.payload = fm10k_bus_payload_unknown;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u16 fm10k_get_pcie_msix_count_generic(struct fm10k_hw *hw)\r\n{\r\nu16 msix_count;\r\nmsix_count = fm10k_read_pci_cfg_word(hw, FM10K_PCI_MSIX_MSG_CTRL);\r\nmsix_count &= FM10K_PCI_MSIX_MSG_CTRL_TBL_SZ_MASK;\r\nmsix_count++;\r\nif (msix_count > FM10K_MAX_MSIX_VECTORS)\r\nmsix_count = FM10K_MAX_MSIX_VECTORS;\r\nreturn msix_count;\r\n}\r\ns32 fm10k_get_invariants_generic(struct fm10k_hw *hw)\r\n{\r\nstruct fm10k_mac_info *mac = &hw->mac;\r\nmac->dglort_map = FM10K_DGLORTMAP_NONE;\r\nmac->max_msix_vectors = fm10k_get_pcie_msix_count_generic(hw);\r\nreturn 0;\r\n}\r\ns32 fm10k_start_hw_generic(struct fm10k_hw *hw)\r\n{\r\nhw->mac.tx_ready = true;\r\nreturn 0;\r\n}\r\ns32 fm10k_disable_queues_generic(struct fm10k_hw *hw, u16 q_cnt)\r\n{\r\nu32 reg;\r\nu16 i, time;\r\nhw->mac.tx_ready = false;\r\nif (FM10K_REMOVED(hw->hw_addr))\r\nreturn 0;\r\nfor (i = 0; i < q_cnt; i++) {\r\nreg = fm10k_read_reg(hw, FM10K_TXDCTL(i));\r\nfm10k_write_reg(hw, FM10K_TXDCTL(i),\r\nreg & ~FM10K_TXDCTL_ENABLE);\r\nreg = fm10k_read_reg(hw, FM10K_RXQCTL(i));\r\nfm10k_write_reg(hw, FM10K_RXQCTL(i),\r\nreg & ~FM10K_RXQCTL_ENABLE);\r\n}\r\nfm10k_write_flush(hw);\r\nudelay(1);\r\nfor (i = 0, time = FM10K_QUEUE_DISABLE_TIMEOUT; time;) {\r\nif (i == q_cnt)\r\nreturn 0;\r\nreg = fm10k_read_reg(hw, FM10K_TXDCTL(i));\r\nif (!~reg || !(reg & FM10K_TXDCTL_ENABLE)) {\r\nreg = fm10k_read_reg(hw, FM10K_RXQCTL(i));\r\nif (!~reg || !(reg & FM10K_RXQCTL_ENABLE)) {\r\ni++;\r\ncontinue;\r\n}\r\n}\r\ntime--;\r\nif (time)\r\nudelay(1);\r\n}\r\nreturn FM10K_ERR_REQUESTS_PENDING;\r\n}\r\ns32 fm10k_stop_hw_generic(struct fm10k_hw *hw)\r\n{\r\nreturn fm10k_disable_queues_generic(hw, hw->mac.max_queues);\r\n}\r\nu32 fm10k_read_hw_stats_32b(struct fm10k_hw *hw, u32 addr,\r\nstruct fm10k_hw_stat *stat)\r\n{\r\nu32 delta = fm10k_read_reg(hw, addr) - stat->base_l;\r\nif (FM10K_REMOVED(hw->hw_addr))\r\nstat->base_h = 0;\r\nreturn delta;\r\n}\r\nstatic u64 fm10k_read_hw_stats_48b(struct fm10k_hw *hw, u32 addr,\r\nstruct fm10k_hw_stat *stat)\r\n{\r\nu32 count_l;\r\nu32 count_h;\r\nu32 count_tmp;\r\nu64 delta;\r\ncount_h = fm10k_read_reg(hw, addr + 1);\r\ndo {\r\ncount_tmp = count_h;\r\ncount_l = fm10k_read_reg(hw, addr);\r\ncount_h = fm10k_read_reg(hw, addr + 1);\r\n} while (count_h != count_tmp);\r\ndelta = ((u64)(count_h - stat->base_h) << 32) + count_l;\r\ndelta -= stat->base_l;\r\nreturn delta & FM10K_48_BIT_MASK;\r\n}\r\nstatic void fm10k_update_hw_base_48b(struct fm10k_hw_stat *stat, u64 delta)\r\n{\r\nif (!delta)\r\nreturn;\r\ndelta += stat->base_l;\r\nstat->base_l = (u32)delta;\r\nstat->base_h += (u32)(delta >> 32);\r\n}\r\nstatic void fm10k_update_hw_stats_tx_q(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats_q *q,\r\nu32 idx)\r\n{\r\nu32 id_tx, id_tx_prev, tx_packets;\r\nu64 tx_bytes = 0;\r\nid_tx = fm10k_read_reg(hw, FM10K_TXQCTL(idx));\r\ndo {\r\ntx_packets = fm10k_read_hw_stats_32b(hw, FM10K_QPTC(idx),\r\n&q->tx_packets);\r\nif (tx_packets)\r\ntx_bytes = fm10k_read_hw_stats_48b(hw,\r\nFM10K_QBTC_L(idx),\r\n&q->tx_bytes);\r\nid_tx_prev = id_tx;\r\nid_tx = fm10k_read_reg(hw, FM10K_TXQCTL(idx));\r\n} while ((id_tx ^ id_tx_prev) & FM10K_TXQCTL_ID_MASK);\r\nid_tx &= FM10K_TXQCTL_ID_MASK;\r\nid_tx |= FM10K_STAT_VALID;\r\nif (q->tx_stats_idx == id_tx) {\r\nq->tx_packets.count += tx_packets;\r\nq->tx_bytes.count += tx_bytes;\r\n}\r\nfm10k_update_hw_base_32b(&q->tx_packets, tx_packets);\r\nfm10k_update_hw_base_48b(&q->tx_bytes, tx_bytes);\r\nq->tx_stats_idx = id_tx;\r\n}\r\nstatic void fm10k_update_hw_stats_rx_q(struct fm10k_hw *hw,\r\nstruct fm10k_hw_stats_q *q,\r\nu32 idx)\r\n{\r\nu32 id_rx, id_rx_prev, rx_packets, rx_drops;\r\nu64 rx_bytes = 0;\r\nid_rx = fm10k_read_reg(hw, FM10K_RXQCTL(idx));\r\ndo {\r\nrx_drops = fm10k_read_hw_stats_32b(hw, FM10K_QPRDC(idx),\r\n&q->rx_drops);\r\nrx_packets = fm10k_read_hw_stats_32b(hw, FM10K_QPRC(idx),\r\n&q->rx_packets);\r\nif (rx_packets)\r\nrx_bytes = fm10k_read_hw_stats_48b(hw,\r\nFM10K_QBRC_L(idx),\r\n&q->rx_bytes);\r\nid_rx_prev = id_rx;\r\nid_rx = fm10k_read_reg(hw, FM10K_RXQCTL(idx));\r\n} while ((id_rx ^ id_rx_prev) & FM10K_RXQCTL_ID_MASK);\r\nid_rx &= FM10K_RXQCTL_ID_MASK;\r\nid_rx |= FM10K_STAT_VALID;\r\nif (q->rx_stats_idx == id_rx) {\r\nq->rx_drops.count += rx_drops;\r\nq->rx_packets.count += rx_packets;\r\nq->rx_bytes.count += rx_bytes;\r\n}\r\nfm10k_update_hw_base_32b(&q->rx_drops, rx_drops);\r\nfm10k_update_hw_base_32b(&q->rx_packets, rx_packets);\r\nfm10k_update_hw_base_48b(&q->rx_bytes, rx_bytes);\r\nq->rx_stats_idx = id_rx;\r\n}\r\nvoid fm10k_update_hw_stats_q(struct fm10k_hw *hw, struct fm10k_hw_stats_q *q,\r\nu32 idx, u32 count)\r\n{\r\nu32 i;\r\nfor (i = 0; i < count; i++, idx++, q++) {\r\nfm10k_update_hw_stats_tx_q(hw, q, idx);\r\nfm10k_update_hw_stats_rx_q(hw, q, idx);\r\n}\r\n}\r\nvoid fm10k_unbind_hw_stats_q(struct fm10k_hw_stats_q *q, u32 idx, u32 count)\r\n{\r\nu32 i;\r\nfor (i = 0; i < count; i++, idx++, q++) {\r\nq->rx_stats_idx = 0;\r\nq->tx_stats_idx = 0;\r\n}\r\n}\r\ns32 fm10k_get_host_state_generic(struct fm10k_hw *hw, bool *host_ready)\r\n{\r\nstruct fm10k_mbx_info *mbx = &hw->mbx;\r\nstruct fm10k_mac_info *mac = &hw->mac;\r\ns32 ret_val = 0;\r\nu32 txdctl = fm10k_read_reg(hw, FM10K_TXDCTL(0));\r\nmbx->ops.process(hw, mbx);\r\nif (!(~txdctl) || !(txdctl & FM10K_TXDCTL_ENABLE))\r\nmac->get_host_state = true;\r\nif (!mac->get_host_state || !(~txdctl))\r\ngoto out;\r\nif (mac->tx_ready && !(txdctl & FM10K_TXDCTL_ENABLE)) {\r\nret_val = FM10K_ERR_RESET_REQUESTED;\r\ngoto out;\r\n}\r\nif (!mbx->timeout) {\r\nret_val = FM10K_ERR_RESET_REQUESTED;\r\ngoto out;\r\n}\r\nif (!mbx->ops.tx_ready(mbx, FM10K_VFMBX_MSG_MTU))\r\ngoto out;\r\nif (mac->dglort_map == FM10K_DGLORTMAP_NONE) {\r\nif (mac->ops.request_lport_map)\r\nret_val = mac->ops.request_lport_map(hw);\r\ngoto out;\r\n}\r\nmac->get_host_state = false;\r\nout:\r\n*host_ready = !mac->get_host_state;\r\nreturn ret_val;\r\n}
