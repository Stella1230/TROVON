u32 fsnotify_get_cookie(void)\r\n{\r\nreturn atomic_inc_return(&fsnotify_sync_cookie);\r\n}\r\nbool fsnotify_notify_queue_is_empty(struct fsnotify_group *group)\r\n{\r\nassert_spin_locked(&group->notification_lock);\r\nreturn list_empty(&group->notification_list) ? true : false;\r\n}\r\nvoid fsnotify_destroy_event(struct fsnotify_group *group,\r\nstruct fsnotify_event *event)\r\n{\r\nif (!event || event->mask == FS_Q_OVERFLOW)\r\nreturn;\r\nif (!list_empty(&event->list)) {\r\nspin_lock(&group->notification_lock);\r\nWARN_ON(!list_empty(&event->list));\r\nspin_unlock(&group->notification_lock);\r\n}\r\ngroup->ops->free_event(event);\r\n}\r\nint fsnotify_add_event(struct fsnotify_group *group,\r\nstruct fsnotify_event *event,\r\nint (*merge)(struct list_head *,\r\nstruct fsnotify_event *))\r\n{\r\nint ret = 0;\r\nstruct list_head *list = &group->notification_list;\r\npr_debug("%s: group=%p event=%p\n", __func__, group, event);\r\nspin_lock(&group->notification_lock);\r\nif (group->shutdown) {\r\nspin_unlock(&group->notification_lock);\r\nreturn 2;\r\n}\r\nif (group->q_len >= group->max_events) {\r\nret = 2;\r\nif (!list_empty(&group->overflow_event->list)) {\r\nspin_unlock(&group->notification_lock);\r\nreturn ret;\r\n}\r\nevent = group->overflow_event;\r\ngoto queue;\r\n}\r\nif (!list_empty(list) && merge) {\r\nret = merge(list, event);\r\nif (ret) {\r\nspin_unlock(&group->notification_lock);\r\nreturn ret;\r\n}\r\n}\r\nqueue:\r\ngroup->q_len++;\r\nlist_add_tail(&event->list, list);\r\nspin_unlock(&group->notification_lock);\r\nwake_up(&group->notification_waitq);\r\nkill_fasync(&group->fsn_fa, SIGIO, POLL_IN);\r\nreturn ret;\r\n}\r\nstruct fsnotify_event *fsnotify_remove_first_event(struct fsnotify_group *group)\r\n{\r\nstruct fsnotify_event *event;\r\nassert_spin_locked(&group->notification_lock);\r\npr_debug("%s: group=%p\n", __func__, group);\r\nevent = list_first_entry(&group->notification_list,\r\nstruct fsnotify_event, list);\r\nlist_del_init(&event->list);\r\ngroup->q_len--;\r\nreturn event;\r\n}\r\nstruct fsnotify_event *fsnotify_peek_first_event(struct fsnotify_group *group)\r\n{\r\nassert_spin_locked(&group->notification_lock);\r\nreturn list_first_entry(&group->notification_list,\r\nstruct fsnotify_event, list);\r\n}\r\nvoid fsnotify_flush_notify(struct fsnotify_group *group)\r\n{\r\nstruct fsnotify_event *event;\r\nspin_lock(&group->notification_lock);\r\nwhile (!fsnotify_notify_queue_is_empty(group)) {\r\nevent = fsnotify_remove_first_event(group);\r\nspin_unlock(&group->notification_lock);\r\nfsnotify_destroy_event(group, event);\r\nspin_lock(&group->notification_lock);\r\n}\r\nspin_unlock(&group->notification_lock);\r\n}\r\nvoid fsnotify_init_event(struct fsnotify_event *event, struct inode *inode,\r\nu32 mask)\r\n{\r\nINIT_LIST_HEAD(&event->list);\r\nevent->inode = inode;\r\nevent->mask = mask;\r\n}
