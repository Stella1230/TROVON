static void usage(void)\r\n{\r\nfprintf(stderr, "Usage: fixdep [-e] <depfile> <target> <cmdline>\n");\r\nfprintf(stderr, " -e insert extra dependencies given on stdin\n");\r\nexit(1);\r\n}\r\nstatic void print_cmdline(void)\r\n{\r\nprintf("cmd_%s := %s\n\n", target, cmdline);\r\n}\r\nstatic void print_config(const char *m, int slen)\r\n{\r\nint c, i;\r\nprintf(" $(wildcard include/config/");\r\nfor (i = 0; i < slen; i++) {\r\nc = m[i];\r\nif (c == '_')\r\nc = '/';\r\nelse\r\nc = tolower(c);\r\nputchar(c);\r\n}\r\nprintf(".h) \\\n");\r\n}\r\nstatic void do_extra_deps(void)\r\n{\r\nif (insert_extra_deps) {\r\nchar buf[80];\r\nwhile(fgets(buf, sizeof(buf), stdin)) {\r\nint len = strlen(buf);\r\nif (len < 2 || buf[len-1] != '\n') {\r\nfprintf(stderr, "fixdep: bad data on stdin\n");\r\nexit(1);\r\n}\r\nprint_config(buf, len-1);\r\n}\r\n}\r\n}\r\nstatic unsigned int strhash(const char *str, unsigned int sz)\r\n{\r\nunsigned int i, hash = 2166136261U;\r\nfor (i = 0; i < sz; i++)\r\nhash = (hash ^ str[i]) * 0x01000193;\r\nreturn hash;\r\n}\r\nstatic int is_defined_config(const char *name, int len, unsigned int hash)\r\n{\r\nstruct item *aux;\r\nfor (aux = hashtab[hash % HASHSZ]; aux; aux = aux->next) {\r\nif (aux->hash == hash && aux->len == len &&\r\nmemcmp(aux->name, name, len) == 0)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void define_config(const char *name, int len, unsigned int hash)\r\n{\r\nstruct item *aux = malloc(sizeof(*aux) + len);\r\nif (!aux) {\r\nperror("fixdep:malloc");\r\nexit(1);\r\n}\r\nmemcpy(aux->name, name, len);\r\naux->len = len;\r\naux->hash = hash;\r\naux->next = hashtab[hash % HASHSZ];\r\nhashtab[hash % HASHSZ] = aux;\r\n}\r\nstatic void use_config(const char *m, int slen)\r\n{\r\nunsigned int hash = strhash(m, slen);\r\nif (is_defined_config(m, slen, hash))\r\nreturn;\r\ndefine_config(m, slen, hash);\r\nprint_config(m, slen);\r\n}\r\nstatic void parse_config_file(const char *p)\r\n{\r\nconst char *q, *r;\r\nwhile ((p = strstr(p, "CONFIG_"))) {\r\np += 7;\r\nq = p;\r\nwhile (*q && (isalnum(*q) || *q == '_'))\r\nq++;\r\nif (memcmp(q - 7, "_MODULE", 7) == 0)\r\nr = q - 7;\r\nelse\r\nr = q;\r\nif (r > p)\r\nuse_config(p, r - p);\r\np = q;\r\n}\r\n}\r\nstatic int strrcmp(const char *s, const char *sub)\r\n{\r\nint slen = strlen(s);\r\nint sublen = strlen(sub);\r\nif (sublen > slen)\r\nreturn 1;\r\nreturn memcmp(s + slen - sublen, sub, sublen);\r\n}\r\nstatic void do_config_file(const char *filename)\r\n{\r\nstruct stat st;\r\nint fd;\r\nchar *map;\r\nfd = open(filename, O_RDONLY);\r\nif (fd < 0) {\r\nfprintf(stderr, "fixdep: error opening config file: ");\r\nperror(filename);\r\nexit(2);\r\n}\r\nif (fstat(fd, &st) < 0) {\r\nfprintf(stderr, "fixdep: error fstat'ing config file: ");\r\nperror(filename);\r\nexit(2);\r\n}\r\nif (st.st_size == 0) {\r\nclose(fd);\r\nreturn;\r\n}\r\nmap = malloc(st.st_size + 1);\r\nif (!map) {\r\nperror("fixdep: malloc");\r\nclose(fd);\r\nreturn;\r\n}\r\nif (read(fd, map, st.st_size) != st.st_size) {\r\nperror("fixdep: read");\r\nclose(fd);\r\nreturn;\r\n}\r\nmap[st.st_size] = '\0';\r\nclose(fd);\r\nparse_config_file(map);\r\nfree(map);\r\n}\r\nstatic void parse_dep_file(void *map, size_t len)\r\n{\r\nchar *m = map;\r\nchar *end = m + len;\r\nchar *p;\r\nchar s[PATH_MAX];\r\nint is_target;\r\nint saw_any_target = 0;\r\nint is_first_dep = 0;\r\nwhile (m < end) {\r\nwhile (m < end && (*m == ' ' || *m == '\\' || *m == '\n'))\r\nm++;\r\np = m;\r\nwhile (p < end && *p != ' ' && *p != '\\' && *p != '\n')\r\np++;\r\nis_target = (*(p-1) == ':');\r\nif (is_target) {\r\nis_first_dep = 1;\r\n} else {\r\nmemcpy(s, m, p-m);\r\ns[p - m] = 0;\r\nif (strrcmp(s, "include/generated/autoconf.h") &&\r\nstrrcmp(s, "include/generated/autoksyms.h") &&\r\nstrrcmp(s, "arch/um/include/uml-config.h") &&\r\nstrrcmp(s, "include/linux/kconfig.h") &&\r\nstrrcmp(s, ".ver")) {\r\nif (is_first_dep) {\r\nif (!saw_any_target) {\r\nsaw_any_target = 1;\r\nprintf("source_%s := %s\n\n",\r\ntarget, s);\r\nprintf("deps_%s := \\\n",\r\ntarget);\r\n}\r\nis_first_dep = 0;\r\n} else\r\nprintf(" %s \\\n", s);\r\ndo_config_file(s);\r\n}\r\n}\r\nm = p + 1;\r\n}\r\nif (!saw_any_target) {\r\nfprintf(stderr, "fixdep: parse error; no targets found\n");\r\nexit(1);\r\n}\r\ndo_extra_deps();\r\nprintf("\n%s: $(deps_%s)\n\n", target, target);\r\nprintf("$(deps_%s):\n", target);\r\n}\r\nstatic void print_deps(void)\r\n{\r\nstruct stat st;\r\nint fd;\r\nvoid *map;\r\nfd = open(depfile, O_RDONLY);\r\nif (fd < 0) {\r\nfprintf(stderr, "fixdep: error opening depfile: ");\r\nperror(depfile);\r\nexit(2);\r\n}\r\nif (fstat(fd, &st) < 0) {\r\nfprintf(stderr, "fixdep: error fstat'ing depfile: ");\r\nperror(depfile);\r\nexit(2);\r\n}\r\nif (st.st_size == 0) {\r\nfprintf(stderr,"fixdep: %s is empty\n",depfile);\r\nclose(fd);\r\nreturn;\r\n}\r\nmap = mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\r\nif ((long) map == -1) {\r\nperror("fixdep: mmap");\r\nclose(fd);\r\nreturn;\r\n}\r\nparse_dep_file(map, st.st_size);\r\nmunmap(map, st.st_size);\r\nclose(fd);\r\n}\r\nint main(int argc, char *argv[])\r\n{\r\nif (argc == 5 && !strcmp(argv[1], "-e")) {\r\ninsert_extra_deps = 1;\r\nargv++;\r\n} else if (argc != 4)\r\nusage();\r\ndepfile = argv[1];\r\ntarget = argv[2];\r\ncmdline = argv[3];\r\nprint_cmdline();\r\nprint_deps();\r\nreturn 0;\r\n}
