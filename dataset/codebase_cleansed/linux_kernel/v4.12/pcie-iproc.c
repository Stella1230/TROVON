static inline struct iproc_pcie *iproc_data(struct pci_bus *bus)\r\n{\r\nstruct iproc_pcie *pcie;\r\n#ifdef CONFIG_ARM\r\nstruct pci_sys_data *sys = bus->sysdata;\r\npcie = sys->private_data;\r\n#else\r\npcie = bus->sysdata;\r\n#endif\r\nreturn pcie;\r\n}\r\nstatic inline bool iproc_pcie_reg_is_invalid(u16 reg_offset)\r\n{\r\nreturn !!(reg_offset == IPROC_PCIE_REG_INVALID);\r\n}\r\nstatic inline u16 iproc_pcie_reg_offset(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg)\r\n{\r\nreturn pcie->reg_offsets[reg];\r\n}\r\nstatic inline u32 iproc_pcie_read_reg(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg)\r\n{\r\nu16 offset = iproc_pcie_reg_offset(pcie, reg);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn 0;\r\nreturn readl(pcie->base + offset);\r\n}\r\nstatic inline void iproc_pcie_write_reg(struct iproc_pcie *pcie,\r\nenum iproc_pcie_reg reg, u32 val)\r\n{\r\nu16 offset = iproc_pcie_reg_offset(pcie, reg);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn;\r\nwritel(val, pcie->base + offset);\r\n}\r\nstatic inline void iproc_pcie_apb_err_disable(struct pci_bus *bus,\r\nbool disable)\r\n{\r\nstruct iproc_pcie *pcie = iproc_data(bus);\r\nu32 val;\r\nif (bus->number && pcie->has_apb_err_disable) {\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_APB_ERR_EN);\r\nif (disable)\r\nval &= ~APB_ERR_EN;\r\nelse\r\nval |= APB_ERR_EN;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_APB_ERR_EN, val);\r\n}\r\n}\r\nstatic void __iomem *iproc_pcie_map_cfg_bus(struct pci_bus *bus,\r\nunsigned int devfn,\r\nint where)\r\n{\r\nstruct iproc_pcie *pcie = iproc_data(bus);\r\nunsigned slot = PCI_SLOT(devfn);\r\nunsigned fn = PCI_FUNC(devfn);\r\nunsigned busno = bus->number;\r\nu32 val;\r\nu16 offset;\r\nif (busno == 0) {\r\nif (slot > 0 || fn > 0)\r\nreturn NULL;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CFG_IND_ADDR,\r\nwhere & CFG_IND_ADDR_MASK);\r\noffset = iproc_pcie_reg_offset(pcie, IPROC_PCIE_CFG_IND_DATA);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn NULL;\r\nelse\r\nreturn (pcie->base + offset);\r\n}\r\nif (pcie->ep_is_internal)\r\nif (slot > 0)\r\nreturn NULL;\r\nval = (busno << CFG_ADDR_BUS_NUM_SHIFT) |\r\n(slot << CFG_ADDR_DEV_NUM_SHIFT) |\r\n(fn << CFG_ADDR_FUNC_NUM_SHIFT) |\r\n(where & CFG_ADDR_REG_NUM_MASK) |\r\n(1 & CFG_ADDR_CFG_TYPE_MASK);\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CFG_ADDR, val);\r\noffset = iproc_pcie_reg_offset(pcie, IPROC_PCIE_CFG_DATA);\r\nif (iproc_pcie_reg_is_invalid(offset))\r\nreturn NULL;\r\nelse\r\nreturn (pcie->base + offset);\r\n}\r\nstatic int iproc_pcie_config_read32(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 *val)\r\n{\r\nint ret;\r\niproc_pcie_apb_err_disable(bus, true);\r\nret = pci_generic_config_read32(bus, devfn, where, size, val);\r\niproc_pcie_apb_err_disable(bus, false);\r\nreturn ret;\r\n}\r\nstatic int iproc_pcie_config_write32(struct pci_bus *bus, unsigned int devfn,\r\nint where, int size, u32 val)\r\n{\r\nint ret;\r\niproc_pcie_apb_err_disable(bus, true);\r\nret = pci_generic_config_write32(bus, devfn, where, size, val);\r\niproc_pcie_apb_err_disable(bus, false);\r\nreturn ret;\r\n}\r\nstatic void iproc_pcie_reset(struct iproc_pcie *pcie)\r\n{\r\nu32 val;\r\nif (pcie->ep_is_internal)\r\nreturn;\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_CLK_CTRL);\r\nval &= ~EP_PERST_SOURCE_SELECT & ~EP_MODE_SURVIVE_PERST &\r\n~RC_PCIE_RST_OUTPUT;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\r\nudelay(250);\r\nval |= RC_PCIE_RST_OUTPUT;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_CLK_CTRL, val);\r\nmsleep(100);\r\n}\r\nstatic int iproc_pcie_check_link(struct iproc_pcie *pcie, struct pci_bus *bus)\r\n{\r\nstruct device *dev = pcie->dev;\r\nu8 hdr_type;\r\nu32 link_ctrl, class, val;\r\nu16 pos = PCI_EXP_CAP, link_status;\r\nbool link_is_active = false;\r\nif (pcie->ep_is_internal)\r\nreturn 0;\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_LINK_STATUS);\r\nif (!(val & PCIE_PHYLINKUP) || !(val & PCIE_DL_ACTIVE)) {\r\ndev_err(dev, "PHY or data link is INACTIVE!\n");\r\nreturn -ENODEV;\r\n}\r\npci_bus_read_config_byte(bus, 0, PCI_HEADER_TYPE, &hdr_type);\r\nif ((hdr_type & 0x7f) != PCI_HEADER_TYPE_BRIDGE) {\r\ndev_err(dev, "in EP mode, hdr=%#02x\n", hdr_type);\r\nreturn -EFAULT;\r\n}\r\n#define PCI_BRIDGE_CTRL_REG_OFFSET 0x43c\r\n#define PCI_CLASS_BRIDGE_MASK 0xffff00\r\n#define PCI_CLASS_BRIDGE_SHIFT 8\r\npci_bus_read_config_dword(bus, 0, PCI_BRIDGE_CTRL_REG_OFFSET, &class);\r\nclass &= ~PCI_CLASS_BRIDGE_MASK;\r\nclass |= (PCI_CLASS_BRIDGE_PCI << PCI_CLASS_BRIDGE_SHIFT);\r\npci_bus_write_config_dword(bus, 0, PCI_BRIDGE_CTRL_REG_OFFSET, class);\r\npci_bus_read_config_word(bus, 0, pos + PCI_EXP_LNKSTA, &link_status);\r\nif (link_status & PCI_EXP_LNKSTA_NLW)\r\nlink_is_active = true;\r\nif (!link_is_active) {\r\n#define PCI_TARGET_LINK_SPEED_MASK 0xf\r\n#define PCI_TARGET_LINK_SPEED_GEN2 0x2\r\n#define PCI_TARGET_LINK_SPEED_GEN1 0x1\r\npci_bus_read_config_dword(bus, 0,\r\npos + PCI_EXP_LNKCTL2,\r\n&link_ctrl);\r\nif ((link_ctrl & PCI_TARGET_LINK_SPEED_MASK) ==\r\nPCI_TARGET_LINK_SPEED_GEN2) {\r\nlink_ctrl &= ~PCI_TARGET_LINK_SPEED_MASK;\r\nlink_ctrl |= PCI_TARGET_LINK_SPEED_GEN1;\r\npci_bus_write_config_dword(bus, 0,\r\npos + PCI_EXP_LNKCTL2,\r\nlink_ctrl);\r\nmsleep(100);\r\npci_bus_read_config_word(bus, 0, pos + PCI_EXP_LNKSTA,\r\n&link_status);\r\nif (link_status & PCI_EXP_LNKSTA_NLW)\r\nlink_is_active = true;\r\n}\r\n}\r\ndev_info(dev, "link: %s\n", link_is_active ? "UP" : "DOWN");\r\nreturn link_is_active ? 0 : -ENODEV;\r\n}\r\nstatic void iproc_pcie_enable(struct iproc_pcie *pcie)\r\n{\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_INTX_EN, SYS_RC_INTX_MASK);\r\n}\r\nstatic inline bool iproc_pcie_ob_is_valid(struct iproc_pcie *pcie,\r\nint window_idx)\r\n{\r\nu32 val;\r\nval = iproc_pcie_read_reg(pcie, MAP_REG(IPROC_PCIE_OARR0, window_idx));\r\nreturn !!(val & OARR_VALID);\r\n}\r\nstatic inline int iproc_pcie_ob_write(struct iproc_pcie *pcie, int window_idx,\r\nint size_idx, u64 axi_addr, u64 pci_addr)\r\n{\r\nstruct device *dev = pcie->dev;\r\nu16 oarr_offset, omap_offset;\r\noarr_offset = iproc_pcie_reg_offset(pcie, MAP_REG(IPROC_PCIE_OARR0,\r\nwindow_idx));\r\nomap_offset = iproc_pcie_reg_offset(pcie, MAP_REG(IPROC_PCIE_OMAP0,\r\nwindow_idx));\r\nif (iproc_pcie_reg_is_invalid(oarr_offset) ||\r\niproc_pcie_reg_is_invalid(omap_offset))\r\nreturn -EINVAL;\r\nwritel(lower_32_bits(axi_addr) | (size_idx << OARR_SIZE_CFG_SHIFT) |\r\nOARR_VALID, pcie->base + oarr_offset);\r\nwritel(upper_32_bits(axi_addr), pcie->base + oarr_offset + 4);\r\nwritel(lower_32_bits(pci_addr), pcie->base + omap_offset);\r\nwritel(upper_32_bits(pci_addr), pcie->base + omap_offset + 4);\r\ndev_info(dev, "ob window [%d]: offset 0x%x axi %pap pci %pap\n",\r\nwindow_idx, oarr_offset, &axi_addr, &pci_addr);\r\ndev_info(dev, "oarr lo 0x%x oarr hi 0x%x\n",\r\nreadl(pcie->base + oarr_offset),\r\nreadl(pcie->base + oarr_offset + 4));\r\ndev_info(dev, "omap lo 0x%x omap hi 0x%x\n",\r\nreadl(pcie->base + omap_offset),\r\nreadl(pcie->base + omap_offset + 4));\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_setup_ob(struct iproc_pcie *pcie, u64 axi_addr,\r\nu64 pci_addr, resource_size_t size)\r\n{\r\nstruct iproc_pcie_ob *ob = &pcie->ob;\r\nstruct device *dev = pcie->dev;\r\nint ret = -EINVAL, window_idx, size_idx;\r\nif (axi_addr < ob->axi_offset) {\r\ndev_err(dev, "axi address %pap less than offset %pap\n",\r\n&axi_addr, &ob->axi_offset);\r\nreturn -EINVAL;\r\n}\r\naxi_addr -= ob->axi_offset;\r\nfor (window_idx = ob->nr_windows - 1; window_idx >= 0; window_idx--) {\r\nconst struct iproc_pcie_ob_map *ob_map =\r\n&pcie->ob_map[window_idx];\r\nif (iproc_pcie_ob_is_valid(pcie, window_idx))\r\ncontinue;\r\nfor (size_idx = ob_map->nr_sizes - 1; size_idx >= 0;\r\nsize_idx--) {\r\nresource_size_t window_size =\r\nob_map->window_sizes[size_idx] * SZ_1M;\r\nif (size < window_size)\r\ncontinue;\r\nif (!IS_ALIGNED(axi_addr, window_size) ||\r\n!IS_ALIGNED(pci_addr, window_size)) {\r\ndev_err(dev,\r\n"axi %pap or pci %pap not aligned\n",\r\n&axi_addr, &pci_addr);\r\nreturn -EINVAL;\r\n}\r\nret = iproc_pcie_ob_write(pcie, window_idx, size_idx,\r\naxi_addr, pci_addr);\r\nif (ret)\r\ngoto err_ob;\r\nsize -= window_size;\r\nif (size == 0)\r\nreturn 0;\r\naxi_addr += window_size;\r\npci_addr += window_size;\r\nbreak;\r\n}\r\n}\r\nerr_ob:\r\ndev_err(dev, "unable to configure outbound mapping\n");\r\ndev_err(dev,\r\n"axi %pap, axi offset %pap, pci %pap, res size %pap\n",\r\n&axi_addr, &ob->axi_offset, &pci_addr, &size);\r\nreturn ret;\r\n}\r\nstatic int iproc_pcie_map_ranges(struct iproc_pcie *pcie,\r\nstruct list_head *resources)\r\n{\r\nstruct device *dev = pcie->dev;\r\nstruct resource_entry *window;\r\nint ret;\r\nresource_list_for_each_entry(window, resources) {\r\nstruct resource *res = window->res;\r\nu64 res_type = resource_type(res);\r\nswitch (res_type) {\r\ncase IORESOURCE_IO:\r\ncase IORESOURCE_BUS:\r\nbreak;\r\ncase IORESOURCE_MEM:\r\nret = iproc_pcie_setup_ob(pcie, res->start,\r\nres->start - window->offset,\r\nresource_size(res));\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "invalid resource %pR\n", res);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline bool iproc_pcie_ib_is_in_use(struct iproc_pcie *pcie,\r\nint region_idx)\r\n{\r\nconst struct iproc_pcie_ib_map *ib_map = &pcie->ib_map[region_idx];\r\nu32 val;\r\nval = iproc_pcie_read_reg(pcie, MAP_REG(IPROC_PCIE_IARR0, region_idx));\r\nreturn !!(val & (BIT(ib_map->nr_sizes) - 1));\r\n}\r\nstatic inline bool iproc_pcie_ib_check_type(const struct iproc_pcie_ib_map *ib_map,\r\nenum iproc_pcie_ib_map_type type)\r\n{\r\nreturn !!(ib_map->type == type);\r\n}\r\nstatic int iproc_pcie_ib_write(struct iproc_pcie *pcie, int region_idx,\r\nint size_idx, int nr_windows, u64 axi_addr,\r\nu64 pci_addr, resource_size_t size)\r\n{\r\nstruct device *dev = pcie->dev;\r\nconst struct iproc_pcie_ib_map *ib_map = &pcie->ib_map[region_idx];\r\nu16 iarr_offset, imap_offset;\r\nu32 val;\r\nint window_idx;\r\niarr_offset = iproc_pcie_reg_offset(pcie,\r\nMAP_REG(IPROC_PCIE_IARR0, region_idx));\r\nimap_offset = iproc_pcie_reg_offset(pcie,\r\nMAP_REG(IPROC_PCIE_IMAP0, region_idx));\r\nif (iproc_pcie_reg_is_invalid(iarr_offset) ||\r\niproc_pcie_reg_is_invalid(imap_offset))\r\nreturn -EINVAL;\r\ndev_info(dev, "ib region [%d]: offset 0x%x axi %pap pci %pap\n",\r\nregion_idx, iarr_offset, &axi_addr, &pci_addr);\r\nwritel(lower_32_bits(pci_addr) | BIT(size_idx),\r\npcie->base + iarr_offset);\r\nwritel(upper_32_bits(pci_addr), pcie->base + iarr_offset + 4);\r\ndev_info(dev, "iarr lo 0x%x iarr hi 0x%x\n",\r\nreadl(pcie->base + iarr_offset),\r\nreadl(pcie->base + iarr_offset + 4));\r\nsize >>= ilog2(nr_windows);\r\nfor (window_idx = 0; window_idx < nr_windows; window_idx++) {\r\nval = readl(pcie->base + imap_offset);\r\nval |= lower_32_bits(axi_addr) | IMAP_VALID;\r\nwritel(val, pcie->base + imap_offset);\r\nwritel(upper_32_bits(axi_addr),\r\npcie->base + imap_offset + ib_map->imap_addr_offset);\r\ndev_info(dev, "imap window [%d] lo 0x%x hi 0x%x\n",\r\nwindow_idx, readl(pcie->base + imap_offset),\r\nreadl(pcie->base + imap_offset +\r\nib_map->imap_addr_offset));\r\nimap_offset += ib_map->imap_window_offset;\r\naxi_addr += size;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_setup_ib(struct iproc_pcie *pcie,\r\nstruct of_pci_range *range,\r\nenum iproc_pcie_ib_map_type type)\r\n{\r\nstruct device *dev = pcie->dev;\r\nstruct iproc_pcie_ib *ib = &pcie->ib;\r\nint ret;\r\nunsigned int region_idx, size_idx;\r\nu64 axi_addr = range->cpu_addr, pci_addr = range->pci_addr;\r\nresource_size_t size = range->size;\r\nfor (region_idx = 0; region_idx < ib->nr_regions; region_idx++) {\r\nconst struct iproc_pcie_ib_map *ib_map =\r\n&pcie->ib_map[region_idx];\r\nif (iproc_pcie_ib_is_in_use(pcie, region_idx) ||\r\n!iproc_pcie_ib_check_type(ib_map, type))\r\ncontinue;\r\nfor (size_idx = 0; size_idx < ib_map->nr_sizes; size_idx++) {\r\nresource_size_t region_size =\r\nib_map->region_sizes[size_idx] * ib_map->size_unit;\r\nif (size != region_size)\r\ncontinue;\r\nif (!IS_ALIGNED(axi_addr, region_size) ||\r\n!IS_ALIGNED(pci_addr, region_size)) {\r\ndev_err(dev,\r\n"axi %pap or pci %pap not aligned\n",\r\n&axi_addr, &pci_addr);\r\nreturn -EINVAL;\r\n}\r\nret = iproc_pcie_ib_write(pcie, region_idx, size_idx,\r\nib_map->nr_windows, axi_addr,\r\npci_addr, size);\r\nif (ret)\r\ngoto err_ib;\r\nelse\r\nreturn 0;\r\n}\r\n}\r\nret = -EINVAL;\r\nerr_ib:\r\ndev_err(dev, "unable to configure inbound mapping\n");\r\ndev_err(dev, "axi %pap, pci %pap, res size %pap\n",\r\n&axi_addr, &pci_addr, &size);\r\nreturn ret;\r\n}\r\nstatic int pci_dma_range_parser_init(struct of_pci_range_parser *parser,\r\nstruct device_node *node)\r\n{\r\nconst int na = 3, ns = 2;\r\nint rlen;\r\nparser->node = node;\r\nparser->pna = of_n_addr_cells(node);\r\nparser->np = parser->pna + na + ns;\r\nparser->range = of_get_property(node, "dma-ranges", &rlen);\r\nif (!parser->range)\r\nreturn -ENOENT;\r\nparser->end = parser->range + rlen / sizeof(__be32);\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_map_dma_ranges(struct iproc_pcie *pcie)\r\n{\r\nstruct of_pci_range range;\r\nstruct of_pci_range_parser parser;\r\nint ret;\r\nret = pci_dma_range_parser_init(&parser, pcie->dev->of_node);\r\nif (ret)\r\nreturn ret;\r\nfor_each_of_pci_range(&parser, &range) {\r\nret = iproc_pcie_setup_ib(pcie, &range, IPROC_PCIE_IB_MAP_MEM);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproce_pcie_get_msi(struct iproc_pcie *pcie,\r\nstruct device_node *msi_node,\r\nu64 *msi_addr)\r\n{\r\nstruct device *dev = pcie->dev;\r\nint ret;\r\nstruct resource res;\r\nif (!of_device_is_compatible(msi_node, "arm,gic-v3-its")) {\r\ndev_err(dev, "unable to find compatible MSI controller\n");\r\nreturn -ENODEV;\r\n}\r\nret = of_address_to_resource(msi_node, 0, &res);\r\nif (ret < 0) {\r\ndev_err(dev, "unable to obtain MSI controller resources\n");\r\nreturn ret;\r\n}\r\n*msi_addr = res.start + GITS_TRANSLATER;\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_paxb_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr)\r\n{\r\nint ret;\r\nstruct of_pci_range range;\r\nmemset(&range, 0, sizeof(range));\r\nrange.size = SZ_32K;\r\nrange.pci_addr = range.cpu_addr = msi_addr & ~(range.size - 1);\r\nret = iproc_pcie_setup_ib(pcie, &range, IPROC_PCIE_IB_MAP_IO);\r\nreturn ret;\r\n}\r\nstatic void iproc_pcie_paxc_v2_msi_steer(struct iproc_pcie *pcie, u64 msi_addr)\r\n{\r\nu32 val;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_BASE_ADDR,\r\n(u32)(msi_addr >> 13));\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_WINDOW_SIZE, 0);\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_MSI_GIC_MODE);\r\nval |= GIC_V3_CFG;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_GIC_MODE, val);\r\nmsi_addr >>= 2;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_ADDR_HI,\r\nupper_32_bits(msi_addr));\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_ADDR_LO,\r\nlower_32_bits(msi_addr));\r\nval = iproc_pcie_read_reg(pcie, IPROC_PCIE_MSI_EN_CFG);\r\nval |= MSI_ENABLE_CFG;\r\niproc_pcie_write_reg(pcie, IPROC_PCIE_MSI_EN_CFG, val);\r\n}\r\nstatic int iproc_pcie_msi_steer(struct iproc_pcie *pcie,\r\nstruct device_node *msi_node)\r\n{\r\nstruct device *dev = pcie->dev;\r\nint ret;\r\nu64 msi_addr;\r\nret = iproce_pcie_get_msi(pcie, msi_node, &msi_addr);\r\nif (ret < 0) {\r\ndev_err(dev, "msi steering failed\n");\r\nreturn ret;\r\n}\r\nswitch (pcie->type) {\r\ncase IPROC_PCIE_PAXB_V2:\r\nret = iproc_pcie_paxb_v2_msi_steer(pcie, msi_addr);\r\nif (ret)\r\nreturn ret;\r\nbreak;\r\ncase IPROC_PCIE_PAXC_V2:\r\niproc_pcie_paxc_v2_msi_steer(pcie, msi_addr);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int iproc_pcie_msi_enable(struct iproc_pcie *pcie)\r\n{\r\nstruct device_node *msi_node;\r\nint ret;\r\nmsi_node = of_parse_phandle(pcie->dev->of_node, "msi-parent", 0);\r\nif (!msi_node) {\r\nconst __be32 *msi_map = NULL;\r\nint len;\r\nu32 phandle;\r\nmsi_map = of_get_property(pcie->dev->of_node, "msi-map", &len);\r\nif (!msi_map)\r\nreturn -ENODEV;\r\nphandle = be32_to_cpup(msi_map + 1);\r\nmsi_node = of_find_node_by_phandle(phandle);\r\nif (!msi_node)\r\nreturn -ENODEV;\r\n}\r\nif (pcie->need_msi_steer) {\r\nret = iproc_pcie_msi_steer(pcie, msi_node);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn iproc_msi_init(pcie, msi_node);\r\n}\r\nstatic void iproc_pcie_msi_disable(struct iproc_pcie *pcie)\r\n{\r\niproc_msi_exit(pcie);\r\n}\r\nstatic int iproc_pcie_rev_init(struct iproc_pcie *pcie)\r\n{\r\nstruct device *dev = pcie->dev;\r\nunsigned int reg_idx;\r\nconst u16 *regs;\r\nswitch (pcie->type) {\r\ncase IPROC_PCIE_PAXB_BCMA:\r\nregs = iproc_pcie_reg_paxb_bcma;\r\nbreak;\r\ncase IPROC_PCIE_PAXB:\r\nregs = iproc_pcie_reg_paxb;\r\npcie->has_apb_err_disable = true;\r\nif (pcie->need_ob_cfg) {\r\npcie->ob_map = paxb_ob_map;\r\npcie->ob.nr_windows = ARRAY_SIZE(paxb_ob_map);\r\n}\r\nbreak;\r\ncase IPROC_PCIE_PAXB_V2:\r\nregs = iproc_pcie_reg_paxb_v2;\r\npcie->has_apb_err_disable = true;\r\nif (pcie->need_ob_cfg) {\r\npcie->ob_map = paxb_v2_ob_map;\r\npcie->ob.nr_windows = ARRAY_SIZE(paxb_v2_ob_map);\r\n}\r\npcie->ib.nr_regions = ARRAY_SIZE(paxb_v2_ib_map);\r\npcie->ib_map = paxb_v2_ib_map;\r\npcie->need_msi_steer = true;\r\nbreak;\r\ncase IPROC_PCIE_PAXC:\r\nregs = iproc_pcie_reg_paxc;\r\npcie->ep_is_internal = true;\r\nbreak;\r\ncase IPROC_PCIE_PAXC_V2:\r\nregs = iproc_pcie_reg_paxc_v2;\r\npcie->ep_is_internal = true;\r\npcie->need_msi_steer = true;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "incompatible iProc PCIe interface\n");\r\nreturn -EINVAL;\r\n}\r\npcie->reg_offsets = devm_kcalloc(dev, IPROC_PCIE_MAX_NUM_REG,\r\nsizeof(*pcie->reg_offsets),\r\nGFP_KERNEL);\r\nif (!pcie->reg_offsets)\r\nreturn -ENOMEM;\r\npcie->reg_offsets[0] = (pcie->type == IPROC_PCIE_PAXC_V2) ?\r\nIPROC_PCIE_REG_INVALID : regs[0];\r\nfor (reg_idx = 1; reg_idx < IPROC_PCIE_MAX_NUM_REG; reg_idx++)\r\npcie->reg_offsets[reg_idx] = regs[reg_idx] ?\r\nregs[reg_idx] : IPROC_PCIE_REG_INVALID;\r\nreturn 0;\r\n}\r\nint iproc_pcie_setup(struct iproc_pcie *pcie, struct list_head *res)\r\n{\r\nstruct device *dev;\r\nint ret;\r\nvoid *sysdata;\r\nstruct pci_bus *bus, *child;\r\ndev = pcie->dev;\r\nret = iproc_pcie_rev_init(pcie);\r\nif (ret) {\r\ndev_err(dev, "unable to initialize controller parameters\n");\r\nreturn ret;\r\n}\r\nret = devm_request_pci_bus_resources(dev, res);\r\nif (ret)\r\nreturn ret;\r\nret = phy_init(pcie->phy);\r\nif (ret) {\r\ndev_err(dev, "unable to initialize PCIe PHY\n");\r\nreturn ret;\r\n}\r\nret = phy_power_on(pcie->phy);\r\nif (ret) {\r\ndev_err(dev, "unable to power on PCIe PHY\n");\r\ngoto err_exit_phy;\r\n}\r\niproc_pcie_reset(pcie);\r\nif (pcie->need_ob_cfg) {\r\nret = iproc_pcie_map_ranges(pcie, res);\r\nif (ret) {\r\ndev_err(dev, "map failed\n");\r\ngoto err_power_off_phy;\r\n}\r\n}\r\nret = iproc_pcie_map_dma_ranges(pcie);\r\nif (ret && ret != -ENOENT)\r\ngoto err_power_off_phy;\r\n#ifdef CONFIG_ARM\r\npcie->sysdata.private_data = pcie;\r\nsysdata = &pcie->sysdata;\r\n#else\r\nsysdata = pcie;\r\n#endif\r\nbus = pci_create_root_bus(dev, 0, &iproc_pcie_ops, sysdata, res);\r\nif (!bus) {\r\ndev_err(dev, "unable to create PCI root bus\n");\r\nret = -ENOMEM;\r\ngoto err_power_off_phy;\r\n}\r\npcie->root_bus = bus;\r\nret = iproc_pcie_check_link(pcie, bus);\r\nif (ret) {\r\ndev_err(dev, "no PCIe EP device detected\n");\r\ngoto err_rm_root_bus;\r\n}\r\niproc_pcie_enable(pcie);\r\nif (IS_ENABLED(CONFIG_PCI_MSI))\r\nif (iproc_pcie_msi_enable(pcie))\r\ndev_info(dev, "not using iProc MSI\n");\r\npci_scan_child_bus(bus);\r\npci_assign_unassigned_bus_resources(bus);\r\nif (pcie->map_irq)\r\npci_fixup_irqs(pci_common_swizzle, pcie->map_irq);\r\nlist_for_each_entry(child, &bus->children, node)\r\npcie_bus_configure_settings(child);\r\npci_bus_add_devices(bus);\r\nreturn 0;\r\nerr_rm_root_bus:\r\npci_stop_root_bus(bus);\r\npci_remove_root_bus(bus);\r\nerr_power_off_phy:\r\nphy_power_off(pcie->phy);\r\nerr_exit_phy:\r\nphy_exit(pcie->phy);\r\nreturn ret;\r\n}\r\nint iproc_pcie_remove(struct iproc_pcie *pcie)\r\n{\r\npci_stop_root_bus(pcie->root_bus);\r\npci_remove_root_bus(pcie->root_bus);\r\niproc_pcie_msi_disable(pcie);\r\nphy_power_off(pcie->phy);\r\nphy_exit(pcie->phy);\r\nreturn 0;\r\n}
