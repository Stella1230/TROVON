static int __init uniphier_early_console_setup(struct earlycon_device *device,\r\nconst char *options)\r\n{\r\nif (!device->port.membase)\r\nreturn -ENODEV;\r\ndevice->port.iotype = UPIO_MEM32;\r\ndevice->port.regshift = UNIPHIER_UART_REGSHIFT;\r\ndevice->baud = 0;\r\nreturn early_serial8250_setup(device, options);\r\n}\r\nstatic unsigned int uniphier_serial_in(struct uart_port *p, int offset)\r\n{\r\nunsigned int valshift = 0;\r\nswitch (offset) {\r\ncase UART_LCR:\r\nvalshift = 8;\r\ncase UART_MCR:\r\noffset = UNIPHIER_UART_LCR_MCR;\r\nbreak;\r\ndefault:\r\noffset <<= UNIPHIER_UART_REGSHIFT;\r\nbreak;\r\n}\r\nreturn (readl(p->membase + offset) >> valshift) & 0xff;\r\n}\r\nstatic void uniphier_serial_out(struct uart_port *p, int offset, int value)\r\n{\r\nunsigned int valshift = 0;\r\nbool normal = true;\r\nswitch (offset) {\r\ncase UART_FCR:\r\noffset = UNIPHIER_UART_CHAR_FCR;\r\nbreak;\r\ncase UART_LCR:\r\nvalshift = 8;\r\nvalue &= ~UART_LCR_DLAB;\r\ncase UART_MCR:\r\noffset = UNIPHIER_UART_LCR_MCR;\r\nnormal = false;\r\nbreak;\r\ndefault:\r\noffset <<= UNIPHIER_UART_REGSHIFT;\r\nbreak;\r\n}\r\nif (normal) {\r\nwritel(value, p->membase + offset);\r\n} else {\r\nstruct uniphier8250_priv *priv = p->private_data;\r\nunsigned long flags;\r\nu32 tmp;\r\nspin_lock_irqsave(&priv->atomic_write_lock, flags);\r\ntmp = readl(p->membase + offset);\r\ntmp &= ~(0xff << valshift);\r\ntmp |= value << valshift;\r\nwritel(tmp, p->membase + offset);\r\nspin_unlock_irqrestore(&priv->atomic_write_lock, flags);\r\n}\r\n}\r\nstatic int uniphier_serial_dl_read(struct uart_8250_port *up)\r\n{\r\nreturn readl(up->port.membase + UNIPHIER_UART_DLR);\r\n}\r\nstatic void uniphier_serial_dl_write(struct uart_8250_port *up, int value)\r\n{\r\nwritel(value, up->port.membase + UNIPHIER_UART_DLR);\r\n}\r\nstatic int uniphier_of_serial_setup(struct device *dev, struct uart_port *port,\r\nstruct uniphier8250_priv *priv)\r\n{\r\nint ret;\r\nu32 prop;\r\nstruct device_node *np = dev->of_node;\r\nret = of_alias_get_id(np, "serial");\r\nif (ret < 0) {\r\ndev_err(dev, "failed to get alias id\n");\r\nreturn ret;\r\n}\r\nport->line = priv->line = ret;\r\npriv->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(priv->clk)) {\r\ndev_err(dev, "failed to get clock\n");\r\nreturn PTR_ERR(priv->clk);\r\n}\r\nret = clk_prepare_enable(priv->clk);\r\nif (ret < 0)\r\nreturn ret;\r\nport->uartclk = clk_get_rate(priv->clk);\r\nif (of_property_read_u32(np, "fifo-size", &prop) == 0)\r\nport->fifosize = prop;\r\nelse\r\nport->fifosize = UNIPHIER_UART_DEFAULT_FIFO_SIZE;\r\nreturn 0;\r\n}\r\nstatic int uniphier_uart_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct uart_8250_port up;\r\nstruct uniphier8250_priv *priv;\r\nstruct resource *regs;\r\nvoid __iomem *membase;\r\nint irq;\r\nint ret;\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!regs) {\r\ndev_err(dev, "failed to get memory resource\n");\r\nreturn -EINVAL;\r\n}\r\nmembase = devm_ioremap(dev, regs->start, resource_size(regs));\r\nif (!membase)\r\nreturn -ENOMEM;\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(dev, "failed to get IRQ number\n");\r\nreturn irq;\r\n}\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nmemset(&up, 0, sizeof(up));\r\nret = uniphier_of_serial_setup(dev, &up.port, priv);\r\nif (ret < 0)\r\nreturn ret;\r\nspin_lock_init(&priv->atomic_write_lock);\r\nup.port.dev = dev;\r\nup.port.private_data = priv;\r\nup.port.mapbase = regs->start;\r\nup.port.mapsize = resource_size(regs);\r\nup.port.membase = membase;\r\nup.port.irq = irq;\r\nup.port.type = PORT_16550A;\r\nup.port.iotype = UPIO_MEM32;\r\nup.port.regshift = UNIPHIER_UART_REGSHIFT;\r\nup.port.flags = UPF_FIXED_PORT | UPF_FIXED_TYPE;\r\nup.capabilities = UART_CAP_FIFO;\r\nup.port.serial_in = uniphier_serial_in;\r\nup.port.serial_out = uniphier_serial_out;\r\nup.dl_read = uniphier_serial_dl_read;\r\nup.dl_write = uniphier_serial_dl_write;\r\nret = serial8250_register_8250_port(&up);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to register 8250 port\n");\r\nclk_disable_unprepare(priv->clk);\r\nreturn ret;\r\n}\r\nplatform_set_drvdata(pdev, priv);\r\nreturn 0;\r\n}\r\nstatic int uniphier_uart_remove(struct platform_device *pdev)\r\n{\r\nstruct uniphier8250_priv *priv = platform_get_drvdata(pdev);\r\nserial8250_unregister_port(priv->line);\r\nclk_disable_unprepare(priv->clk);\r\nreturn 0;\r\n}
