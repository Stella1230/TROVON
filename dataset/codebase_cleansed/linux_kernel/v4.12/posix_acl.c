static struct posix_acl **acl_by_type(struct inode *inode, int type)\r\n{\r\nswitch (type) {\r\ncase ACL_TYPE_ACCESS:\r\nreturn &inode->i_acl;\r\ncase ACL_TYPE_DEFAULT:\r\nreturn &inode->i_default_acl;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstruct posix_acl *get_cached_acl(struct inode *inode, int type)\r\n{\r\nstruct posix_acl **p = acl_by_type(inode, type);\r\nstruct posix_acl *acl;\r\nfor (;;) {\r\nrcu_read_lock();\r\nacl = rcu_dereference(*p);\r\nif (!acl || is_uncached_acl(acl) ||\r\natomic_inc_not_zero(&acl->a_refcount))\r\nbreak;\r\nrcu_read_unlock();\r\ncpu_relax();\r\n}\r\nrcu_read_unlock();\r\nreturn acl;\r\n}\r\nstruct posix_acl *get_cached_acl_rcu(struct inode *inode, int type)\r\n{\r\nreturn rcu_dereference(*acl_by_type(inode, type));\r\n}\r\nvoid set_cached_acl(struct inode *inode, int type, struct posix_acl *acl)\r\n{\r\nstruct posix_acl **p = acl_by_type(inode, type);\r\nstruct posix_acl *old;\r\nold = xchg(p, posix_acl_dup(acl));\r\nif (!is_uncached_acl(old))\r\nposix_acl_release(old);\r\n}\r\nstatic void __forget_cached_acl(struct posix_acl **p)\r\n{\r\nstruct posix_acl *old;\r\nold = xchg(p, ACL_NOT_CACHED);\r\nif (!is_uncached_acl(old))\r\nposix_acl_release(old);\r\n}\r\nvoid forget_cached_acl(struct inode *inode, int type)\r\n{\r\n__forget_cached_acl(acl_by_type(inode, type));\r\n}\r\nvoid forget_all_cached_acls(struct inode *inode)\r\n{\r\n__forget_cached_acl(&inode->i_acl);\r\n__forget_cached_acl(&inode->i_default_acl);\r\n}\r\nstruct posix_acl *get_acl(struct inode *inode, int type)\r\n{\r\nvoid *sentinel;\r\nstruct posix_acl **p;\r\nstruct posix_acl *acl;\r\nacl = get_cached_acl(inode, type);\r\nif (!is_uncached_acl(acl))\r\nreturn acl;\r\nif (!IS_POSIXACL(inode))\r\nreturn NULL;\r\nsentinel = uncached_acl_sentinel(current);\r\np = acl_by_type(inode, type);\r\nif (cmpxchg(p, ACL_NOT_CACHED, sentinel) != ACL_NOT_CACHED)\r\n;\r\nif (!inode->i_op->get_acl) {\r\nset_cached_acl(inode, type, NULL);\r\nreturn NULL;\r\n}\r\nacl = inode->i_op->get_acl(inode, type);\r\nif (IS_ERR(acl)) {\r\ncmpxchg(p, sentinel, ACL_NOT_CACHED);\r\nreturn acl;\r\n}\r\nposix_acl_dup(acl);\r\nif (unlikely(cmpxchg(p, sentinel, acl) != sentinel))\r\nposix_acl_release(acl);\r\nreturn acl;\r\n}\r\nvoid\r\nposix_acl_init(struct posix_acl *acl, int count)\r\n{\r\natomic_set(&acl->a_refcount, 1);\r\nacl->a_count = count;\r\n}\r\nstruct posix_acl *\r\nposix_acl_alloc(int count, gfp_t flags)\r\n{\r\nconst size_t size = sizeof(struct posix_acl) +\r\ncount * sizeof(struct posix_acl_entry);\r\nstruct posix_acl *acl = kmalloc(size, flags);\r\nif (acl)\r\nposix_acl_init(acl, count);\r\nreturn acl;\r\n}\r\nstatic struct posix_acl *\r\nposix_acl_clone(const struct posix_acl *acl, gfp_t flags)\r\n{\r\nstruct posix_acl *clone = NULL;\r\nif (acl) {\r\nint size = sizeof(struct posix_acl) + acl->a_count *\r\nsizeof(struct posix_acl_entry);\r\nclone = kmemdup(acl, size, flags);\r\nif (clone)\r\natomic_set(&clone->a_refcount, 1);\r\n}\r\nreturn clone;\r\n}\r\nint\r\nposix_acl_valid(struct user_namespace *user_ns, const struct posix_acl *acl)\r\n{\r\nconst struct posix_acl_entry *pa, *pe;\r\nint state = ACL_USER_OBJ;\r\nint needs_mask = 0;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nif (pa->e_perm & ~(ACL_READ|ACL_WRITE|ACL_EXECUTE))\r\nreturn -EINVAL;\r\nswitch (pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nif (state == ACL_USER_OBJ) {\r\nstate = ACL_USER;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\ncase ACL_USER:\r\nif (state != ACL_USER)\r\nreturn -EINVAL;\r\nif (!kuid_has_mapping(user_ns, pa->e_uid))\r\nreturn -EINVAL;\r\nneeds_mask = 1;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nif (state == ACL_USER) {\r\nstate = ACL_GROUP;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\ncase ACL_GROUP:\r\nif (state != ACL_GROUP)\r\nreturn -EINVAL;\r\nif (!kgid_has_mapping(user_ns, pa->e_gid))\r\nreturn -EINVAL;\r\nneeds_mask = 1;\r\nbreak;\r\ncase ACL_MASK:\r\nif (state != ACL_GROUP)\r\nreturn -EINVAL;\r\nstate = ACL_OTHER;\r\nbreak;\r\ncase ACL_OTHER:\r\nif (state == ACL_OTHER ||\r\n(state == ACL_GROUP && !needs_mask)) {\r\nstate = 0;\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (state == 0)\r\nreturn 0;\r\nreturn -EINVAL;\r\n}\r\nint\r\nposix_acl_equiv_mode(const struct posix_acl *acl, umode_t *mode_p)\r\n{\r\nconst struct posix_acl_entry *pa, *pe;\r\numode_t mode = 0;\r\nint not_equiv = 0;\r\nif (!acl)\r\nreturn 0;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch (pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nmode |= (pa->e_perm & S_IRWXO) << 6;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nmode |= (pa->e_perm & S_IRWXO) << 3;\r\nbreak;\r\ncase ACL_OTHER:\r\nmode |= pa->e_perm & S_IRWXO;\r\nbreak;\r\ncase ACL_MASK:\r\nmode = (mode & ~S_IRWXG) |\r\n((pa->e_perm & S_IRWXO) << 3);\r\nnot_equiv = 1;\r\nbreak;\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nnot_equiv = 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (mode_p)\r\n*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\r\nreturn not_equiv;\r\n}\r\nstruct posix_acl *\r\nposix_acl_from_mode(umode_t mode, gfp_t flags)\r\n{\r\nstruct posix_acl *acl = posix_acl_alloc(3, flags);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nacl->a_entries[0].e_tag = ACL_USER_OBJ;\r\nacl->a_entries[0].e_perm = (mode & S_IRWXU) >> 6;\r\nacl->a_entries[1].e_tag = ACL_GROUP_OBJ;\r\nacl->a_entries[1].e_perm = (mode & S_IRWXG) >> 3;\r\nacl->a_entries[2].e_tag = ACL_OTHER;\r\nacl->a_entries[2].e_perm = (mode & S_IRWXO);\r\nreturn acl;\r\n}\r\nint\r\nposix_acl_permission(struct inode *inode, const struct posix_acl *acl, int want)\r\n{\r\nconst struct posix_acl_entry *pa, *pe, *mask_obj;\r\nint found = 0;\r\nwant &= MAY_READ | MAY_WRITE | MAY_EXEC | MAY_NOT_BLOCK;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\nif (uid_eq(inode->i_uid, current_fsuid()))\r\ngoto check_perm;\r\nbreak;\r\ncase ACL_USER:\r\nif (uid_eq(pa->e_uid, current_fsuid()))\r\ngoto mask;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\nif (in_group_p(inode->i_gid)) {\r\nfound = 1;\r\nif ((pa->e_perm & want) == want)\r\ngoto mask;\r\n}\r\nbreak;\r\ncase ACL_GROUP:\r\nif (in_group_p(pa->e_gid)) {\r\nfound = 1;\r\nif ((pa->e_perm & want) == want)\r\ngoto mask;\r\n}\r\nbreak;\r\ncase ACL_MASK:\r\nbreak;\r\ncase ACL_OTHER:\r\nif (found)\r\nreturn -EACCES;\r\nelse\r\ngoto check_perm;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nreturn -EIO;\r\nmask:\r\nfor (mask_obj = pa+1; mask_obj != pe; mask_obj++) {\r\nif (mask_obj->e_tag == ACL_MASK) {\r\nif ((pa->e_perm & mask_obj->e_perm & want) == want)\r\nreturn 0;\r\nreturn -EACCES;\r\n}\r\n}\r\ncheck_perm:\r\nif ((pa->e_perm & want) == want)\r\nreturn 0;\r\nreturn -EACCES;\r\n}\r\nstatic int posix_acl_create_masq(struct posix_acl *acl, umode_t *mode_p)\r\n{\r\nstruct posix_acl_entry *pa, *pe;\r\nstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\r\numode_t mode = *mode_p;\r\nint not_equiv = 0;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\npa->e_perm &= (mode >> 6) | ~S_IRWXO;\r\nmode &= (pa->e_perm << 6) | ~S_IRWXU;\r\nbreak;\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nnot_equiv = 1;\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\ngroup_obj = pa;\r\nbreak;\r\ncase ACL_OTHER:\r\npa->e_perm &= mode | ~S_IRWXO;\r\nmode &= pa->e_perm | ~S_IRWXO;\r\nbreak;\r\ncase ACL_MASK:\r\nmask_obj = pa;\r\nnot_equiv = 1;\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nif (mask_obj) {\r\nmask_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\r\nmode &= (mask_obj->e_perm << 3) | ~S_IRWXG;\r\n} else {\r\nif (!group_obj)\r\nreturn -EIO;\r\ngroup_obj->e_perm &= (mode >> 3) | ~S_IRWXO;\r\nmode &= (group_obj->e_perm << 3) | ~S_IRWXG;\r\n}\r\n*mode_p = (*mode_p & ~S_IRWXUGO) | mode;\r\nreturn not_equiv;\r\n}\r\nstatic int __posix_acl_chmod_masq(struct posix_acl *acl, umode_t mode)\r\n{\r\nstruct posix_acl_entry *group_obj = NULL, *mask_obj = NULL;\r\nstruct posix_acl_entry *pa, *pe;\r\nFOREACH_ACL_ENTRY(pa, acl, pe) {\r\nswitch(pa->e_tag) {\r\ncase ACL_USER_OBJ:\r\npa->e_perm = (mode & S_IRWXU) >> 6;\r\nbreak;\r\ncase ACL_USER:\r\ncase ACL_GROUP:\r\nbreak;\r\ncase ACL_GROUP_OBJ:\r\ngroup_obj = pa;\r\nbreak;\r\ncase ACL_MASK:\r\nmask_obj = pa;\r\nbreak;\r\ncase ACL_OTHER:\r\npa->e_perm = (mode & S_IRWXO);\r\nbreak;\r\ndefault:\r\nreturn -EIO;\r\n}\r\n}\r\nif (mask_obj) {\r\nmask_obj->e_perm = (mode & S_IRWXG) >> 3;\r\n} else {\r\nif (!group_obj)\r\nreturn -EIO;\r\ngroup_obj->e_perm = (mode & S_IRWXG) >> 3;\r\n}\r\nreturn 0;\r\n}\r\nint\r\n__posix_acl_create(struct posix_acl **acl, gfp_t gfp, umode_t *mode_p)\r\n{\r\nstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\r\nint err = -ENOMEM;\r\nif (clone) {\r\nerr = posix_acl_create_masq(clone, mode_p);\r\nif (err < 0) {\r\nposix_acl_release(clone);\r\nclone = NULL;\r\n}\r\n}\r\nposix_acl_release(*acl);\r\n*acl = clone;\r\nreturn err;\r\n}\r\nint\r\n__posix_acl_chmod(struct posix_acl **acl, gfp_t gfp, umode_t mode)\r\n{\r\nstruct posix_acl *clone = posix_acl_clone(*acl, gfp);\r\nint err = -ENOMEM;\r\nif (clone) {\r\nerr = __posix_acl_chmod_masq(clone, mode);\r\nif (err) {\r\nposix_acl_release(clone);\r\nclone = NULL;\r\n}\r\n}\r\nposix_acl_release(*acl);\r\n*acl = clone;\r\nreturn err;\r\n}\r\nint\r\nposix_acl_chmod(struct inode *inode, umode_t mode)\r\n{\r\nstruct posix_acl *acl;\r\nint ret = 0;\r\nif (!IS_POSIXACL(inode))\r\nreturn 0;\r\nif (!inode->i_op->set_acl)\r\nreturn -EOPNOTSUPP;\r\nacl = get_acl(inode, ACL_TYPE_ACCESS);\r\nif (IS_ERR_OR_NULL(acl)) {\r\nif (acl == ERR_PTR(-EOPNOTSUPP))\r\nreturn 0;\r\nreturn PTR_ERR(acl);\r\n}\r\nret = __posix_acl_chmod(&acl, GFP_KERNEL, mode);\r\nif (ret)\r\nreturn ret;\r\nret = inode->i_op->set_acl(inode, acl, ACL_TYPE_ACCESS);\r\nposix_acl_release(acl);\r\nreturn ret;\r\n}\r\nint\r\nposix_acl_create(struct inode *dir, umode_t *mode,\r\nstruct posix_acl **default_acl, struct posix_acl **acl)\r\n{\r\nstruct posix_acl *p;\r\nstruct posix_acl *clone;\r\nint ret;\r\n*acl = NULL;\r\n*default_acl = NULL;\r\nif (S_ISLNK(*mode) || !IS_POSIXACL(dir))\r\nreturn 0;\r\np = get_acl(dir, ACL_TYPE_DEFAULT);\r\nif (!p || p == ERR_PTR(-EOPNOTSUPP)) {\r\n*mode &= ~current_umask();\r\nreturn 0;\r\n}\r\nif (IS_ERR(p))\r\nreturn PTR_ERR(p);\r\nret = -ENOMEM;\r\nclone = posix_acl_clone(p, GFP_NOFS);\r\nif (!clone)\r\ngoto err_release;\r\nret = posix_acl_create_masq(clone, mode);\r\nif (ret < 0)\r\ngoto err_release_clone;\r\nif (ret == 0)\r\nposix_acl_release(clone);\r\nelse\r\n*acl = clone;\r\nif (!S_ISDIR(*mode))\r\nposix_acl_release(p);\r\nelse\r\n*default_acl = p;\r\nreturn 0;\r\nerr_release_clone:\r\nposix_acl_release(clone);\r\nerr_release:\r\nposix_acl_release(p);\r\nreturn ret;\r\n}\r\nint posix_acl_update_mode(struct inode *inode, umode_t *mode_p,\r\nstruct posix_acl **acl)\r\n{\r\numode_t mode = inode->i_mode;\r\nint error;\r\nerror = posix_acl_equiv_mode(*acl, &mode);\r\nif (error < 0)\r\nreturn error;\r\nif (error == 0)\r\n*acl = NULL;\r\nif (!in_group_p(inode->i_gid) &&\r\n!capable_wrt_inode_uidgid(inode, CAP_FSETID))\r\nmode &= ~S_ISGID;\r\n*mode_p = mode;\r\nreturn 0;\r\n}\r\nstatic void posix_acl_fix_xattr_userns(\r\nstruct user_namespace *to, struct user_namespace *from,\r\nvoid *value, size_t size)\r\n{\r\nstruct posix_acl_xattr_header *header = value;\r\nstruct posix_acl_xattr_entry *entry = (void *)(header + 1), *end;\r\nint count;\r\nkuid_t uid;\r\nkgid_t gid;\r\nif (!value)\r\nreturn;\r\nif (size < sizeof(struct posix_acl_xattr_header))\r\nreturn;\r\nif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\r\nreturn;\r\ncount = posix_acl_xattr_count(size);\r\nif (count < 0)\r\nreturn;\r\nif (count == 0)\r\nreturn;\r\nfor (end = entry + count; entry != end; entry++) {\r\nswitch(le16_to_cpu(entry->e_tag)) {\r\ncase ACL_USER:\r\nuid = make_kuid(from, le32_to_cpu(entry->e_id));\r\nentry->e_id = cpu_to_le32(from_kuid(to, uid));\r\nbreak;\r\ncase ACL_GROUP:\r\ngid = make_kgid(from, le32_to_cpu(entry->e_id));\r\nentry->e_id = cpu_to_le32(from_kgid(to, gid));\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\n}\r\nvoid posix_acl_fix_xattr_from_user(void *value, size_t size)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nif (user_ns == &init_user_ns)\r\nreturn;\r\nposix_acl_fix_xattr_userns(&init_user_ns, user_ns, value, size);\r\n}\r\nvoid posix_acl_fix_xattr_to_user(void *value, size_t size)\r\n{\r\nstruct user_namespace *user_ns = current_user_ns();\r\nif (user_ns == &init_user_ns)\r\nreturn;\r\nposix_acl_fix_xattr_userns(user_ns, &init_user_ns, value, size);\r\n}\r\nstruct posix_acl *\r\nposix_acl_from_xattr(struct user_namespace *user_ns,\r\nconst void *value, size_t size)\r\n{\r\nconst struct posix_acl_xattr_header *header = value;\r\nconst struct posix_acl_xattr_entry *entry = (const void *)(header + 1), *end;\r\nint count;\r\nstruct posix_acl *acl;\r\nstruct posix_acl_entry *acl_e;\r\nif (!value)\r\nreturn NULL;\r\nif (size < sizeof(struct posix_acl_xattr_header))\r\nreturn ERR_PTR(-EINVAL);\r\nif (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\r\nreturn ERR_PTR(-EOPNOTSUPP);\r\ncount = posix_acl_xattr_count(size);\r\nif (count < 0)\r\nreturn ERR_PTR(-EINVAL);\r\nif (count == 0)\r\nreturn NULL;\r\nacl = posix_acl_alloc(count, GFP_NOFS);\r\nif (!acl)\r\nreturn ERR_PTR(-ENOMEM);\r\nacl_e = acl->a_entries;\r\nfor (end = entry + count; entry != end; acl_e++, entry++) {\r\nacl_e->e_tag = le16_to_cpu(entry->e_tag);\r\nacl_e->e_perm = le16_to_cpu(entry->e_perm);\r\nswitch(acl_e->e_tag) {\r\ncase ACL_USER_OBJ:\r\ncase ACL_GROUP_OBJ:\r\ncase ACL_MASK:\r\ncase ACL_OTHER:\r\nbreak;\r\ncase ACL_USER:\r\nacl_e->e_uid =\r\nmake_kuid(user_ns,\r\nle32_to_cpu(entry->e_id));\r\nif (!uid_valid(acl_e->e_uid))\r\ngoto fail;\r\nbreak;\r\ncase ACL_GROUP:\r\nacl_e->e_gid =\r\nmake_kgid(user_ns,\r\nle32_to_cpu(entry->e_id));\r\nif (!gid_valid(acl_e->e_gid))\r\ngoto fail;\r\nbreak;\r\ndefault:\r\ngoto fail;\r\n}\r\n}\r\nreturn acl;\r\nfail:\r\nposix_acl_release(acl);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nint\r\nposix_acl_to_xattr(struct user_namespace *user_ns, const struct posix_acl *acl,\r\nvoid *buffer, size_t size)\r\n{\r\nstruct posix_acl_xattr_header *ext_acl = buffer;\r\nstruct posix_acl_xattr_entry *ext_entry;\r\nint real_size, n;\r\nreal_size = posix_acl_xattr_size(acl->a_count);\r\nif (!buffer)\r\nreturn real_size;\r\nif (real_size > size)\r\nreturn -ERANGE;\r\next_entry = (void *)(ext_acl + 1);\r\next_acl->a_version = cpu_to_le32(POSIX_ACL_XATTR_VERSION);\r\nfor (n=0; n < acl->a_count; n++, ext_entry++) {\r\nconst struct posix_acl_entry *acl_e = &acl->a_entries[n];\r\next_entry->e_tag = cpu_to_le16(acl_e->e_tag);\r\next_entry->e_perm = cpu_to_le16(acl_e->e_perm);\r\nswitch(acl_e->e_tag) {\r\ncase ACL_USER:\r\next_entry->e_id =\r\ncpu_to_le32(from_kuid(user_ns, acl_e->e_uid));\r\nbreak;\r\ncase ACL_GROUP:\r\next_entry->e_id =\r\ncpu_to_le32(from_kgid(user_ns, acl_e->e_gid));\r\nbreak;\r\ndefault:\r\next_entry->e_id = cpu_to_le32(ACL_UNDEFINED_ID);\r\nbreak;\r\n}\r\n}\r\nreturn real_size;\r\n}\r\nstatic int\r\nposix_acl_xattr_get(const struct xattr_handler *handler,\r\nstruct dentry *unused, struct inode *inode,\r\nconst char *name, void *value, size_t size)\r\n{\r\nstruct posix_acl *acl;\r\nint error;\r\nif (!IS_POSIXACL(inode))\r\nreturn -EOPNOTSUPP;\r\nif (S_ISLNK(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nacl = get_acl(inode, handler->flags);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\nif (acl == NULL)\r\nreturn -ENODATA;\r\nerror = posix_acl_to_xattr(&init_user_ns, acl, value, size);\r\nposix_acl_release(acl);\r\nreturn error;\r\n}\r\nint\r\nset_posix_acl(struct inode *inode, int type, struct posix_acl *acl)\r\n{\r\nif (!IS_POSIXACL(inode))\r\nreturn -EOPNOTSUPP;\r\nif (!inode->i_op->set_acl)\r\nreturn -EOPNOTSUPP;\r\nif (type == ACL_TYPE_DEFAULT && !S_ISDIR(inode->i_mode))\r\nreturn acl ? -EACCES : 0;\r\nif (!inode_owner_or_capable(inode))\r\nreturn -EPERM;\r\nif (acl) {\r\nint ret = posix_acl_valid(inode->i_sb->s_user_ns, acl);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn inode->i_op->set_acl(inode, acl, type);\r\n}\r\nstatic int\r\nposix_acl_xattr_set(const struct xattr_handler *handler,\r\nstruct dentry *unused, struct inode *inode,\r\nconst char *name, const void *value,\r\nsize_t size, int flags)\r\n{\r\nstruct posix_acl *acl = NULL;\r\nint ret;\r\nif (value) {\r\nacl = posix_acl_from_xattr(&init_user_ns, value, size);\r\nif (IS_ERR(acl))\r\nreturn PTR_ERR(acl);\r\n}\r\nret = set_posix_acl(inode, handler->flags, acl);\r\nposix_acl_release(acl);\r\nreturn ret;\r\n}\r\nstatic bool\r\nposix_acl_xattr_list(struct dentry *dentry)\r\n{\r\nreturn IS_POSIXACL(d_backing_inode(dentry));\r\n}\r\nint simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\r\n{\r\nint error;\r\nif (type == ACL_TYPE_ACCESS) {\r\nerror = posix_acl_update_mode(inode,\r\n&inode->i_mode, &acl);\r\nif (error)\r\nreturn error;\r\n}\r\ninode->i_ctime = current_time(inode);\r\nset_cached_acl(inode, type, acl);\r\nreturn 0;\r\n}\r\nint simple_acl_create(struct inode *dir, struct inode *inode)\r\n{\r\nstruct posix_acl *default_acl, *acl;\r\nint error;\r\nerror = posix_acl_create(dir, &inode->i_mode, &default_acl, &acl);\r\nif (error)\r\nreturn error;\r\nset_cached_acl(inode, ACL_TYPE_DEFAULT, default_acl);\r\nset_cached_acl(inode, ACL_TYPE_ACCESS, acl);\r\nif (default_acl)\r\nposix_acl_release(default_acl);\r\nif (acl)\r\nposix_acl_release(acl);\r\nreturn 0;\r\n}
