static int mconsole_reply_v0(struct mc_request *req, char *reply)\r\n{\r\nstruct iovec iov;\r\nstruct msghdr msg;\r\niov.iov_base = reply;\r\niov.iov_len = strlen(reply);\r\nmsg.msg_name = &(req->origin);\r\nmsg.msg_namelen = req->originlen;\r\nmsg.msg_iov = &iov;\r\nmsg.msg_iovlen = 1;\r\nmsg.msg_control = NULL;\r\nmsg.msg_controllen = 0;\r\nmsg.msg_flags = 0;\r\nreturn sendmsg(req->originating_fd, &msg, 0);\r\n}\r\nstatic struct mconsole_command *mconsole_parse(struct mc_request *req)\r\n{\r\nstruct mconsole_command *cmd;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(commands); i++) {\r\ncmd = &commands[i];\r\nif (!strncmp(req->request.data, cmd->command,\r\nstrlen(cmd->command))) {\r\nreturn cmd;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nint mconsole_get_request(int fd, struct mc_request *req)\r\n{\r\nint len;\r\nreq->originlen = sizeof(req->origin);\r\nreq->len = recvfrom(fd, &req->request, sizeof(req->request), 0,\r\n(struct sockaddr *) req->origin, &req->originlen);\r\nif (req->len < 0)\r\nreturn 0;\r\nreq->originating_fd = fd;\r\nif (req->request.magic != MCONSOLE_MAGIC) {\r\nlen = MIN(sizeof(req->request.data) - 1,\r\nstrlen((char *) &req->request));\r\nmemmove(req->request.data, &req->request, len);\r\nreq->request.data[len] = '\0';\r\nreq->request.magic = MCONSOLE_MAGIC;\r\nreq->request.version = 0;\r\nreq->request.len = len;\r\nmconsole_reply_v0(req, "ERR Version 0 mconsole clients are "\r\n"not supported by this driver");\r\nreturn 0;\r\n}\r\nif (req->request.len >= MCONSOLE_MAX_DATA) {\r\nmconsole_reply(req, "Request too large", 1, 0);\r\nreturn 0;\r\n}\r\nif (req->request.version != MCONSOLE_VERSION) {\r\nmconsole_reply(req, "This driver only supports version "\r\nSTRING(MCONSOLE_VERSION) " clients", 1, 0);\r\n}\r\nreq->request.data[req->request.len] = '\0';\r\nreq->cmd = mconsole_parse(req);\r\nif (req->cmd == NULL) {\r\nmconsole_reply(req, "Unknown command", 1, 0);\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint mconsole_reply_len(struct mc_request *req, const char *str, int total,\r\nint err, int more)\r\n{\r\nstruct mconsole_reply reply;\r\nint len, n;\r\ndo {\r\nreply.err = err;\r\nerr = 0;\r\nlen = MIN(total, MCONSOLE_MAX_DATA - 1);\r\nif (len == total) reply.more = more;\r\nelse reply.more = 1;\r\nmemcpy(reply.data, str, len);\r\nreply.data[len] = '\0';\r\ntotal -= len;\r\nstr += len;\r\nreply.len = len + 1;\r\nlen = sizeof(reply) + reply.len - sizeof(reply.data);\r\nn = sendto(req->originating_fd, &reply, len, 0,\r\n(struct sockaddr *) req->origin, req->originlen);\r\nif (n < 0)\r\nreturn -errno;\r\n} while (total > 0);\r\nreturn 0;\r\n}\r\nint mconsole_reply(struct mc_request *req, const char *str, int err, int more)\r\n{\r\nreturn mconsole_reply_len(req, str, strlen(str), err, more);\r\n}\r\nint mconsole_unlink_socket(void)\r\n{\r\nunlink(mconsole_socket_name);\r\nreturn 0;\r\n}\r\nint mconsole_notify(char *sock_name, int type, const void *data, int len)\r\n{\r\nstruct sockaddr_un target;\r\nstruct mconsole_notify packet;\r\nint n, err = 0;\r\nlock_notify();\r\nif (notify_sock < 0) {\r\nnotify_sock = socket(PF_UNIX, SOCK_DGRAM, 0);\r\nif (notify_sock < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "mconsole_notify - socket failed, "\r\n"errno = %d\n", errno);\r\n}\r\n}\r\nunlock_notify();\r\nif (err)\r\nreturn err;\r\ntarget.sun_family = AF_UNIX;\r\nstrcpy(target.sun_path, sock_name);\r\npacket.magic = MCONSOLE_MAGIC;\r\npacket.version = MCONSOLE_VERSION;\r\npacket.type = type;\r\nlen = (len > sizeof(packet.data)) ? sizeof(packet.data) : len;\r\npacket.len = len;\r\nmemcpy(packet.data, data, len);\r\nerr = 0;\r\nlen = sizeof(packet) + packet.len - sizeof(packet.data);\r\nn = sendto(notify_sock, &packet, len, 0, (struct sockaddr *) &target,\r\nsizeof(target));\r\nif (n < 0) {\r\nerr = -errno;\r\nprintk(UM_KERN_ERR "mconsole_notify - sendto failed, "\r\n"errno = %d\n", errno);\r\n}\r\nreturn err;\r\n}
