static bool rcar_du_plane_needs_realloc(struct rcar_du_plane *plane,\r\nstruct rcar_du_plane_state *new_state)\r\n{\r\nstruct rcar_du_plane_state *cur_state;\r\ncur_state = to_rcar_plane_state(plane->plane.state);\r\nif (!cur_state->format ||\r\ncur_state->format->planes != new_state->format->planes)\r\nreturn true;\r\nif (cur_state->source != new_state->source)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic unsigned int rcar_du_plane_hwmask(struct rcar_du_plane_state *state)\r\n{\r\nunsigned int mask;\r\nif (state->hwindex == -1)\r\nreturn 0;\r\nmask = 1 << state->hwindex;\r\nif (state->format->planes == 2)\r\nmask |= 1 << ((state->hwindex + 1) % 8);\r\nreturn mask;\r\n}\r\nstatic int rcar_du_plane_hwalloc(struct rcar_du_plane *plane,\r\nstruct rcar_du_plane_state *state,\r\nunsigned int free)\r\n{\r\nunsigned int num_planes = state->format->planes;\r\nint fixed = -1;\r\nint i;\r\nif (state->source == RCAR_DU_PLANE_VSPD0) {\r\nif (plane->group->index != 0)\r\nreturn -EINVAL;\r\nfixed = 0;\r\n} else if (state->source == RCAR_DU_PLANE_VSPD1) {\r\nfixed = plane->group->index == 0 ? 1 : 0;\r\n}\r\nif (fixed >= 0)\r\nreturn free & (1 << fixed) ? fixed : -EBUSY;\r\nfor (i = RCAR_DU_NUM_HW_PLANES - 1; i >= 0; --i) {\r\nif (!(free & (1 << i)))\r\ncontinue;\r\nif (num_planes == 1 || free & (1 << ((i + 1) % 8)))\r\nbreak;\r\n}\r\nreturn i < 0 ? -EBUSY : i;\r\n}\r\nint rcar_du_atomic_check_planes(struct drm_device *dev,\r\nstruct drm_atomic_state *state)\r\n{\r\nstruct rcar_du_device *rcdu = dev->dev_private;\r\nunsigned int group_freed_planes[RCAR_DU_MAX_GROUPS] = { 0, };\r\nunsigned int group_free_planes[RCAR_DU_MAX_GROUPS] = { 0, };\r\nbool needs_realloc = false;\r\nunsigned int groups = 0;\r\nunsigned int i;\r\nstruct drm_plane *drm_plane;\r\nstruct drm_plane_state *drm_plane_state;\r\nfor_each_plane_in_state(state, drm_plane, drm_plane_state, i) {\r\nstruct rcar_du_plane_state *plane_state;\r\nstruct rcar_du_plane *plane;\r\nunsigned int index;\r\nplane = to_rcar_plane(drm_plane);\r\nplane_state = to_rcar_plane_state(drm_plane_state);\r\ndev_dbg(rcdu->dev, "%s: checking plane (%u,%tu)\n", __func__,\r\nplane->group->index, plane - plane->group->planes);\r\nif (!plane_state->format) {\r\ndev_dbg(rcdu->dev, "%s: plane is being disabled\n",\r\n__func__);\r\nindex = plane - plane->group->planes;\r\ngroup_freed_planes[plane->group->index] |= 1 << index;\r\nplane_state->hwindex = -1;\r\ncontinue;\r\n}\r\nif (rcar_du_plane_needs_realloc(plane, plane_state)) {\r\ndev_dbg(rcdu->dev, "%s: plane needs reallocation\n",\r\n__func__);\r\ngroups |= 1 << plane->group->index;\r\nneeds_realloc = true;\r\nindex = plane - plane->group->planes;\r\ngroup_freed_planes[plane->group->index] |= 1 << index;\r\nplane_state->hwindex = -1;\r\n}\r\n}\r\nif (!needs_realloc)\r\nreturn 0;\r\nwhile (groups) {\r\nunsigned int index = ffs(groups) - 1;\r\nstruct rcar_du_group *group = &rcdu->groups[index];\r\nunsigned int used_planes = 0;\r\ndev_dbg(rcdu->dev, "%s: finding free planes for group %u\n",\r\n__func__, index);\r\nfor (i = 0; i < group->num_planes; ++i) {\r\nstruct rcar_du_plane *plane = &group->planes[i];\r\nstruct rcar_du_plane_state *plane_state;\r\nstruct drm_plane_state *s;\r\ns = drm_atomic_get_plane_state(state, &plane->plane);\r\nif (IS_ERR(s))\r\nreturn PTR_ERR(s);\r\nif (group_freed_planes[index] & (1 << i)) {\r\ndev_dbg(rcdu->dev,\r\n"%s: plane (%u,%tu) has been freed, skipping\n",\r\n__func__, plane->group->index,\r\nplane - plane->group->planes);\r\ncontinue;\r\n}\r\nplane_state = to_rcar_plane_state(plane->plane.state);\r\nused_planes |= rcar_du_plane_hwmask(plane_state);\r\ndev_dbg(rcdu->dev,\r\n"%s: plane (%u,%tu) uses %u hwplanes (index %d)\n",\r\n__func__, plane->group->index,\r\nplane - plane->group->planes,\r\nplane_state->format ?\r\nplane_state->format->planes : 0,\r\nplane_state->hwindex);\r\n}\r\ngroup_free_planes[index] = 0xff & ~used_planes;\r\ngroups &= ~(1 << index);\r\ndev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",\r\n__func__, index, group_free_planes[index]);\r\n}\r\nfor_each_plane_in_state(state, drm_plane, drm_plane_state, i) {\r\nstruct rcar_du_plane_state *plane_state;\r\nstruct rcar_du_plane *plane;\r\nunsigned int crtc_planes;\r\nunsigned int free;\r\nint idx;\r\nplane = to_rcar_plane(drm_plane);\r\nplane_state = to_rcar_plane_state(drm_plane_state);\r\ndev_dbg(rcdu->dev, "%s: allocating plane (%u,%tu)\n", __func__,\r\nplane->group->index, plane - plane->group->planes);\r\nif (!plane_state->format ||\r\n!rcar_du_plane_needs_realloc(plane, plane_state))\r\ncontinue;\r\ncrtc_planes = to_rcar_crtc(plane_state->state.crtc)->index % 2\r\n? plane->group->dptsr_planes\r\n: ~plane->group->dptsr_planes;\r\nfree = group_free_planes[plane->group->index];\r\nidx = rcar_du_plane_hwalloc(plane, plane_state,\r\nfree & crtc_planes);\r\nif (idx < 0)\r\nidx = rcar_du_plane_hwalloc(plane, plane_state,\r\nfree);\r\nif (idx < 0) {\r\ndev_dbg(rcdu->dev, "%s: no available hardware plane\n",\r\n__func__);\r\nreturn idx;\r\n}\r\ndev_dbg(rcdu->dev, "%s: allocated %u hwplanes (index %u)\n",\r\n__func__, plane_state->format->planes, idx);\r\nplane_state->hwindex = idx;\r\ngroup_free_planes[plane->group->index] &=\r\n~rcar_du_plane_hwmask(plane_state);\r\ndev_dbg(rcdu->dev, "%s: group %u free planes mask 0x%02x\n",\r\n__func__, plane->group->index,\r\ngroup_free_planes[plane->group->index]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_du_plane_write(struct rcar_du_group *rgrp,\r\nunsigned int index, u32 reg, u32 data)\r\n{\r\nrcar_du_write(rgrp->dev, rgrp->mmio_offset + index * PLANE_OFF + reg,\r\ndata);\r\n}\r\nstatic void rcar_du_plane_setup_scanout(struct rcar_du_group *rgrp,\r\nconst struct rcar_du_plane_state *state)\r\n{\r\nunsigned int src_x = state->state.src_x >> 16;\r\nunsigned int src_y = state->state.src_y >> 16;\r\nunsigned int index = state->hwindex;\r\nunsigned int pitch;\r\nbool interlaced;\r\nu32 dma[2];\r\ninterlaced = state->state.crtc->state->adjusted_mode.flags\r\n& DRM_MODE_FLAG_INTERLACE;\r\nif (state->source == RCAR_DU_PLANE_MEMORY) {\r\nstruct drm_framebuffer *fb = state->state.fb;\r\nstruct drm_gem_cma_object *gem;\r\nunsigned int i;\r\nif (state->format->planes == 2)\r\npitch = fb->pitches[0];\r\nelse\r\npitch = fb->pitches[0] * 8 / state->format->bpp;\r\nfor (i = 0; i < state->format->planes; ++i) {\r\ngem = drm_fb_cma_get_gem_obj(fb, i);\r\ndma[i] = gem->paddr + fb->offsets[i];\r\n}\r\n} else {\r\npitch = state->state.src_w >> 16;\r\ndma[0] = 0;\r\ndma[1] = 0;\r\n}\r\nrcar_du_plane_write(rgrp, index, PnMWR,\r\n(interlaced && state->format->bpp == 32) ?\r\npitch * 2 : pitch);\r\nrcar_du_plane_write(rgrp, index, PnSPXR, src_x);\r\nrcar_du_plane_write(rgrp, index, PnSPYR, src_y *\r\n(!interlaced && state->format->bpp == 32 ? 2 : 1));\r\nrcar_du_plane_write(rgrp, index, PnDSA0R, dma[0]);\r\nif (state->format->planes == 2) {\r\nindex = (index + 1) % 8;\r\nrcar_du_plane_write(rgrp, index, PnMWR, pitch);\r\nrcar_du_plane_write(rgrp, index, PnSPXR, src_x);\r\nrcar_du_plane_write(rgrp, index, PnSPYR, src_y *\r\n(state->format->bpp == 16 ? 2 : 1) / 2);\r\nrcar_du_plane_write(rgrp, index, PnDSA0R, dma[1]);\r\n}\r\n}\r\nstatic void rcar_du_plane_setup_mode(struct rcar_du_group *rgrp,\r\nunsigned int index,\r\nconst struct rcar_du_plane_state *state)\r\n{\r\nu32 colorkey;\r\nu32 pnmr;\r\nif (state->format->fourcc != DRM_FORMAT_XRGB1555)\r\nrcar_du_plane_write(rgrp, index, PnALPHAR, PnALPHAR_ABIT_0);\r\nelse\r\nrcar_du_plane_write(rgrp, index, PnALPHAR,\r\nPnALPHAR_ABIT_X | state->alpha);\r\npnmr = PnMR_BM_MD | state->format->pnmr;\r\nif ((state->colorkey & RCAR_DU_COLORKEY_MASK) == RCAR_DU_COLORKEY_NONE)\r\npnmr |= PnMR_SPIM_TP_OFF;\r\nif (state->format->fourcc == DRM_FORMAT_YUYV)\r\npnmr |= PnMR_YCDF_YUYV;\r\nrcar_du_plane_write(rgrp, index, PnMR, pnmr);\r\nswitch (state->format->fourcc) {\r\ncase DRM_FORMAT_RGB565:\r\ncolorkey = ((state->colorkey & 0xf80000) >> 8)\r\n| ((state->colorkey & 0x00fc00) >> 5)\r\n| ((state->colorkey & 0x0000f8) >> 3);\r\nrcar_du_plane_write(rgrp, index, PnTC2R, colorkey);\r\nbreak;\r\ncase DRM_FORMAT_ARGB1555:\r\ncase DRM_FORMAT_XRGB1555:\r\ncolorkey = ((state->colorkey & 0xf80000) >> 9)\r\n| ((state->colorkey & 0x00f800) >> 6)\r\n| ((state->colorkey & 0x0000f8) >> 3);\r\nrcar_du_plane_write(rgrp, index, PnTC2R, colorkey);\r\nbreak;\r\ncase DRM_FORMAT_XRGB8888:\r\ncase DRM_FORMAT_ARGB8888:\r\nrcar_du_plane_write(rgrp, index, PnTC3R,\r\nPnTC3R_CODE | (state->colorkey & 0xffffff));\r\nbreak;\r\n}\r\n}\r\nstatic void rcar_du_plane_setup_format_gen2(struct rcar_du_group *rgrp,\r\nunsigned int index,\r\nconst struct rcar_du_plane_state *state)\r\n{\r\nu32 ddcr2 = PnDDCR2_CODE;\r\nu32 ddcr4;\r\nrcar_du_plane_setup_mode(rgrp, index, state);\r\nif (state->format->planes == 2) {\r\nif (state->hwindex != index) {\r\nif (state->format->fourcc == DRM_FORMAT_NV12 ||\r\nstate->format->fourcc == DRM_FORMAT_NV21)\r\nddcr2 |= PnDDCR2_Y420;\r\nif (state->format->fourcc == DRM_FORMAT_NV21)\r\nddcr2 |= PnDDCR2_NV21;\r\nddcr2 |= PnDDCR2_DIVU;\r\n} else {\r\nddcr2 |= PnDDCR2_DIVY;\r\n}\r\n}\r\nrcar_du_plane_write(rgrp, index, PnDDCR2, ddcr2);\r\nddcr4 = state->format->edf | PnDDCR4_CODE;\r\nif (state->source != RCAR_DU_PLANE_MEMORY)\r\nddcr4 |= PnDDCR4_VSPS;\r\nrcar_du_plane_write(rgrp, index, PnDDCR4, ddcr4);\r\n}\r\nstatic void rcar_du_plane_setup_format_gen3(struct rcar_du_group *rgrp,\r\nunsigned int index,\r\nconst struct rcar_du_plane_state *state)\r\n{\r\nrcar_du_plane_write(rgrp, index, PnMR,\r\nPnMR_SPIM_TP_OFF | state->format->pnmr);\r\nrcar_du_plane_write(rgrp, index, PnDDCR4,\r\nstate->format->edf | PnDDCR4_CODE);\r\n}\r\nstatic void rcar_du_plane_setup_format(struct rcar_du_group *rgrp,\r\nunsigned int index,\r\nconst struct rcar_du_plane_state *state)\r\n{\r\nstruct rcar_du_device *rcdu = rgrp->dev;\r\nif (rcdu->info->gen < 3)\r\nrcar_du_plane_setup_format_gen2(rgrp, index, state);\r\nelse\r\nrcar_du_plane_setup_format_gen3(rgrp, index, state);\r\nrcar_du_plane_write(rgrp, index, PnDSXR, state->state.crtc_w);\r\nrcar_du_plane_write(rgrp, index, PnDSYR, state->state.crtc_h);\r\nrcar_du_plane_write(rgrp, index, PnDPXR, state->state.crtc_x);\r\nrcar_du_plane_write(rgrp, index, PnDPYR, state->state.crtc_y);\r\nif (rcdu->info->gen < 3) {\r\nrcar_du_plane_write(rgrp, index, PnWASPR, 0);\r\nrcar_du_plane_write(rgrp, index, PnWAMWR, 4095);\r\nrcar_du_plane_write(rgrp, index, PnBTR, 0);\r\nrcar_du_plane_write(rgrp, index, PnMLR, 0);\r\n}\r\n}\r\nvoid __rcar_du_plane_setup(struct rcar_du_group *rgrp,\r\nconst struct rcar_du_plane_state *state)\r\n{\r\nstruct rcar_du_device *rcdu = rgrp->dev;\r\nrcar_du_plane_setup_format(rgrp, state->hwindex, state);\r\nif (state->format->planes == 2)\r\nrcar_du_plane_setup_format(rgrp, (state->hwindex + 1) % 8,\r\nstate);\r\nif (rcdu->info->gen < 3)\r\nrcar_du_plane_setup_scanout(rgrp, state);\r\nif (state->source == RCAR_DU_PLANE_VSPD1) {\r\nunsigned int vspd1_sink = rgrp->index ? 2 : 0;\r\nif (rcdu->vspd1_sink != vspd1_sink) {\r\nrcdu->vspd1_sink = vspd1_sink;\r\nrcar_du_set_dpad0_vsp1_routing(rcdu);\r\n}\r\n}\r\n}\r\nstatic int rcar_du_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct rcar_du_plane_state *rstate = to_rcar_plane_state(state);\r\nstruct rcar_du_plane *rplane = to_rcar_plane(plane);\r\nstruct rcar_du_device *rcdu = rplane->group->dev;\r\nif (!state->fb || !state->crtc) {\r\nrstate->format = NULL;\r\nreturn 0;\r\n}\r\nif (state->src_w >> 16 != state->crtc_w ||\r\nstate->src_h >> 16 != state->crtc_h) {\r\ndev_dbg(rcdu->dev, "%s: scaling not supported\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nrstate->format = rcar_du_format_info(state->fb->format->format);\r\nif (rstate->format == NULL) {\r\ndev_dbg(rcdu->dev, "%s: unsupported format %08x\n", __func__,\r\nstate->fb->format->format);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic void rcar_du_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct rcar_du_plane *rplane = to_rcar_plane(plane);\r\nstruct rcar_du_plane_state *old_rstate;\r\nstruct rcar_du_plane_state *new_rstate;\r\nif (!plane->state->crtc)\r\nreturn;\r\nrcar_du_plane_setup(rplane);\r\nold_rstate = to_rcar_plane_state(old_state);\r\nnew_rstate = to_rcar_plane_state(plane->state);\r\nif ((old_rstate->source == RCAR_DU_PLANE_MEMORY) !=\r\n(new_rstate->source == RCAR_DU_PLANE_MEMORY))\r\nrplane->group->need_restart = true;\r\n}\r\nstatic struct drm_plane_state *\r\nrcar_du_plane_atomic_duplicate_state(struct drm_plane *plane)\r\n{\r\nstruct rcar_du_plane_state *state;\r\nstruct rcar_du_plane_state *copy;\r\nif (WARN_ON(!plane->state))\r\nreturn NULL;\r\nstate = to_rcar_plane_state(plane->state);\r\ncopy = kmemdup(state, sizeof(*state), GFP_KERNEL);\r\nif (copy == NULL)\r\nreturn NULL;\r\n__drm_atomic_helper_plane_duplicate_state(plane, &copy->state);\r\nreturn &copy->state;\r\n}\r\nstatic void rcar_du_plane_atomic_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\n__drm_atomic_helper_plane_destroy_state(state);\r\nkfree(to_rcar_plane_state(state));\r\n}\r\nstatic void rcar_du_plane_reset(struct drm_plane *plane)\r\n{\r\nstruct rcar_du_plane_state *state;\r\nif (plane->state) {\r\nrcar_du_plane_atomic_destroy_state(plane, plane->state);\r\nplane->state = NULL;\r\n}\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn;\r\nstate->hwindex = -1;\r\nstate->source = RCAR_DU_PLANE_MEMORY;\r\nstate->alpha = 255;\r\nstate->colorkey = RCAR_DU_COLORKEY_NONE;\r\nstate->state.zpos = plane->type == DRM_PLANE_TYPE_PRIMARY ? 0 : 1;\r\nplane->state = &state->state;\r\nplane->state->plane = plane;\r\n}\r\nstatic int rcar_du_plane_atomic_set_property(struct drm_plane *plane,\r\nstruct drm_plane_state *state,\r\nstruct drm_property *property,\r\nuint64_t val)\r\n{\r\nstruct rcar_du_plane_state *rstate = to_rcar_plane_state(state);\r\nstruct rcar_du_device *rcdu = to_rcar_plane(plane)->group->dev;\r\nif (property == rcdu->props.alpha)\r\nrstate->alpha = val;\r\nelse if (property == rcdu->props.colorkey)\r\nrstate->colorkey = val;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int rcar_du_plane_atomic_get_property(struct drm_plane *plane,\r\nconst struct drm_plane_state *state, struct drm_property *property,\r\nuint64_t *val)\r\n{\r\nconst struct rcar_du_plane_state *rstate =\r\ncontainer_of(state, const struct rcar_du_plane_state, state);\r\nstruct rcar_du_device *rcdu = to_rcar_plane(plane)->group->dev;\r\nif (property == rcdu->props.alpha)\r\n*val = rstate->alpha;\r\nelse if (property == rcdu->props.colorkey)\r\n*val = rstate->colorkey;\r\nelse\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint rcar_du_planes_init(struct rcar_du_group *rgrp)\r\n{\r\nstruct rcar_du_device *rcdu = rgrp->dev;\r\nunsigned int crtcs;\r\nunsigned int i;\r\nint ret;\r\nrgrp->num_planes = rgrp->num_crtcs + 7;\r\ncrtcs = ((1 << rcdu->num_crtcs) - 1) & (3 << (2 * rgrp->index));\r\nfor (i = 0; i < rgrp->num_planes; ++i) {\r\nenum drm_plane_type type = i < rgrp->num_crtcs\r\n? DRM_PLANE_TYPE_PRIMARY\r\n: DRM_PLANE_TYPE_OVERLAY;\r\nstruct rcar_du_plane *plane = &rgrp->planes[i];\r\nplane->group = rgrp;\r\nret = drm_universal_plane_init(rcdu->ddev, &plane->plane, crtcs,\r\n&rcar_du_plane_funcs, formats,\r\nARRAY_SIZE(formats), type,\r\nNULL);\r\nif (ret < 0)\r\nreturn ret;\r\ndrm_plane_helper_add(&plane->plane,\r\n&rcar_du_plane_helper_funcs);\r\nif (type == DRM_PLANE_TYPE_PRIMARY)\r\ncontinue;\r\ndrm_object_attach_property(&plane->plane.base,\r\nrcdu->props.alpha, 255);\r\ndrm_object_attach_property(&plane->plane.base,\r\nrcdu->props.colorkey,\r\nRCAR_DU_COLORKEY_NONE);\r\ndrm_plane_create_zpos_property(&plane->plane, 1, 1, 7);\r\n}\r\nreturn 0;\r\n}
