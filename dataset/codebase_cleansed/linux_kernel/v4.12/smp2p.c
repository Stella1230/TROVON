static void qcom_smp2p_kick(struct qcom_smp2p *smp2p)\r\n{\r\nwmb();\r\nregmap_write(smp2p->ipc_regmap, smp2p->ipc_offset, BIT(smp2p->ipc_bit));\r\n}\r\nstatic irqreturn_t qcom_smp2p_intr(int irq, void *data)\r\n{\r\nstruct smp2p_smem_item *in;\r\nstruct smp2p_entry *entry;\r\nstruct qcom_smp2p *smp2p = data;\r\nunsigned smem_id = smp2p->smem_items[SMP2P_INBOUND];\r\nunsigned pid = smp2p->remote_pid;\r\nsize_t size;\r\nint irq_pin;\r\nu32 status;\r\nchar buf[SMP2P_MAX_ENTRY_NAME];\r\nu32 val;\r\nint i;\r\nin = smp2p->in;\r\nif (!in) {\r\nin = qcom_smem_get(pid, smem_id, &size);\r\nif (IS_ERR(in)) {\r\ndev_err(smp2p->dev,\r\n"Unable to acquire remote smp2p item\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nsmp2p->in = in;\r\n}\r\nfor (i = smp2p->valid_entries; i < in->valid_entries; i++) {\r\nlist_for_each_entry(entry, &smp2p->inbound, node) {\r\nmemcpy(buf, in->entries[i].name, sizeof(buf));\r\nif (!strcmp(buf, entry->name)) {\r\nentry->value = &in->entries[i].value;\r\nbreak;\r\n}\r\n}\r\n}\r\nsmp2p->valid_entries = i;\r\nlist_for_each_entry(entry, &smp2p->inbound, node) {\r\nif (!entry->value)\r\ncontinue;\r\nval = readl(entry->value);\r\nstatus = val ^ entry->last_value;\r\nentry->last_value = val;\r\nif (!status)\r\ncontinue;\r\nfor_each_set_bit(i, entry->irq_enabled, 32) {\r\nif (!(status & BIT(i)))\r\ncontinue;\r\nif ((val & BIT(i) && test_bit(i, entry->irq_rising)) ||\r\n(!(val & BIT(i)) && test_bit(i, entry->irq_falling))) {\r\nirq_pin = irq_find_mapping(entry->domain, i);\r\nhandle_nested_irq(irq_pin);\r\n}\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void smp2p_mask_irq(struct irq_data *irqd)\r\n{\r\nstruct smp2p_entry *entry = irq_data_get_irq_chip_data(irqd);\r\nirq_hw_number_t irq = irqd_to_hwirq(irqd);\r\nclear_bit(irq, entry->irq_enabled);\r\n}\r\nstatic void smp2p_unmask_irq(struct irq_data *irqd)\r\n{\r\nstruct smp2p_entry *entry = irq_data_get_irq_chip_data(irqd);\r\nirq_hw_number_t irq = irqd_to_hwirq(irqd);\r\nset_bit(irq, entry->irq_enabled);\r\n}\r\nstatic int smp2p_set_irq_type(struct irq_data *irqd, unsigned int type)\r\n{\r\nstruct smp2p_entry *entry = irq_data_get_irq_chip_data(irqd);\r\nirq_hw_number_t irq = irqd_to_hwirq(irqd);\r\nif (!(type & IRQ_TYPE_EDGE_BOTH))\r\nreturn -EINVAL;\r\nif (type & IRQ_TYPE_EDGE_RISING)\r\nset_bit(irq, entry->irq_rising);\r\nelse\r\nclear_bit(irq, entry->irq_rising);\r\nif (type & IRQ_TYPE_EDGE_FALLING)\r\nset_bit(irq, entry->irq_falling);\r\nelse\r\nclear_bit(irq, entry->irq_falling);\r\nreturn 0;\r\n}\r\nstatic int smp2p_irq_map(struct irq_domain *d,\r\nunsigned int irq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct smp2p_entry *entry = d->host_data;\r\nirq_set_chip_and_handler(irq, &smp2p_irq_chip, handle_level_irq);\r\nirq_set_chip_data(irq, entry);\r\nirq_set_nested_thread(irq, 1);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic int qcom_smp2p_inbound_entry(struct qcom_smp2p *smp2p,\r\nstruct smp2p_entry *entry,\r\nstruct device_node *node)\r\n{\r\nentry->domain = irq_domain_add_linear(node, 32, &smp2p_irq_ops, entry);\r\nif (!entry->domain) {\r\ndev_err(smp2p->dev, "failed to add irq_domain\n");\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic int smp2p_update_bits(void *data, u32 mask, u32 value)\r\n{\r\nstruct smp2p_entry *entry = data;\r\nu32 orig;\r\nu32 val;\r\nspin_lock(&entry->lock);\r\nval = orig = readl(entry->value);\r\nval &= ~mask;\r\nval |= value;\r\nwritel(val, entry->value);\r\nspin_unlock(&entry->lock);\r\nif (val != orig)\r\nqcom_smp2p_kick(entry->smp2p);\r\nreturn 0;\r\n}\r\nstatic int qcom_smp2p_outbound_entry(struct qcom_smp2p *smp2p,\r\nstruct smp2p_entry *entry,\r\nstruct device_node *node)\r\n{\r\nstruct smp2p_smem_item *out = smp2p->out;\r\nchar buf[SMP2P_MAX_ENTRY_NAME] = {};\r\nstrlcpy(buf, entry->name, SMP2P_MAX_ENTRY_NAME);\r\nmemcpy(out->entries[out->valid_entries].name, buf, SMP2P_MAX_ENTRY_NAME);\r\nentry->value = &out->entries[out->valid_entries].value;\r\nout->valid_entries++;\r\nentry->state = qcom_smem_state_register(node, &smp2p_state_ops, entry);\r\nif (IS_ERR(entry->state)) {\r\ndev_err(smp2p->dev, "failed to register qcom_smem_state\n");\r\nreturn PTR_ERR(entry->state);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qcom_smp2p_alloc_outbound_item(struct qcom_smp2p *smp2p)\r\n{\r\nstruct smp2p_smem_item *out;\r\nunsigned smem_id = smp2p->smem_items[SMP2P_OUTBOUND];\r\nunsigned pid = smp2p->remote_pid;\r\nint ret;\r\nret = qcom_smem_alloc(pid, smem_id, sizeof(*out));\r\nif (ret < 0 && ret != -EEXIST) {\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(smp2p->dev,\r\n"unable to allocate local smp2p item\n");\r\nreturn ret;\r\n}\r\nout = qcom_smem_get(pid, smem_id, NULL);\r\nif (IS_ERR(out)) {\r\ndev_err(smp2p->dev, "Unable to acquire local smp2p item\n");\r\nreturn PTR_ERR(out);\r\n}\r\nmemset(out, 0, sizeof(*out));\r\nout->magic = SMP2P_MAGIC;\r\nout->local_pid = smp2p->local_pid;\r\nout->remote_pid = smp2p->remote_pid;\r\nout->total_entries = SMP2P_MAX_ENTRY;\r\nout->valid_entries = 0;\r\nwmb();\r\nout->version = 1;\r\nqcom_smp2p_kick(smp2p);\r\nsmp2p->out = out;\r\nreturn 0;\r\n}\r\nstatic int smp2p_parse_ipc(struct qcom_smp2p *smp2p)\r\n{\r\nstruct device_node *syscon;\r\nstruct device *dev = smp2p->dev;\r\nconst char *key;\r\nint ret;\r\nsyscon = of_parse_phandle(dev->of_node, "qcom,ipc", 0);\r\nif (!syscon) {\r\ndev_err(dev, "no qcom,ipc node\n");\r\nreturn -ENODEV;\r\n}\r\nsmp2p->ipc_regmap = syscon_node_to_regmap(syscon);\r\nif (IS_ERR(smp2p->ipc_regmap))\r\nreturn PTR_ERR(smp2p->ipc_regmap);\r\nkey = "qcom,ipc";\r\nret = of_property_read_u32_index(dev->of_node, key, 1, &smp2p->ipc_offset);\r\nif (ret < 0) {\r\ndev_err(dev, "no offset in %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nret = of_property_read_u32_index(dev->of_node, key, 2, &smp2p->ipc_bit);\r\nif (ret < 0) {\r\ndev_err(dev, "no bit in %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qcom_smp2p_probe(struct platform_device *pdev)\r\n{\r\nstruct smp2p_entry *entry;\r\nstruct device_node *node;\r\nstruct qcom_smp2p *smp2p;\r\nconst char *key;\r\nint irq;\r\nint ret;\r\nsmp2p = devm_kzalloc(&pdev->dev, sizeof(*smp2p), GFP_KERNEL);\r\nif (!smp2p)\r\nreturn -ENOMEM;\r\nsmp2p->dev = &pdev->dev;\r\nINIT_LIST_HEAD(&smp2p->inbound);\r\nINIT_LIST_HEAD(&smp2p->outbound);\r\nplatform_set_drvdata(pdev, smp2p);\r\nret = smp2p_parse_ipc(smp2p);\r\nif (ret)\r\nreturn ret;\r\nkey = "qcom,smem";\r\nret = of_property_read_u32_array(pdev->dev.of_node, key,\r\nsmp2p->smem_items, 2);\r\nif (ret)\r\nreturn ret;\r\nkey = "qcom,local-pid";\r\nret = of_property_read_u32(pdev->dev.of_node, key, &smp2p->local_pid);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to read %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nkey = "qcom,remote-pid";\r\nret = of_property_read_u32(pdev->dev.of_node, key, &smp2p->remote_pid);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to read %s\n", key);\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "unable to acquire smp2p interrupt\n");\r\nreturn irq;\r\n}\r\nret = qcom_smp2p_alloc_outbound_item(smp2p);\r\nif (ret < 0)\r\nreturn ret;\r\nfor_each_available_child_of_node(pdev->dev.of_node, node) {\r\nentry = devm_kzalloc(&pdev->dev, sizeof(*entry), GFP_KERNEL);\r\nif (!entry) {\r\nret = -ENOMEM;\r\ngoto unwind_interfaces;\r\n}\r\nentry->smp2p = smp2p;\r\nspin_lock_init(&entry->lock);\r\nret = of_property_read_string(node, "qcom,entry-name", &entry->name);\r\nif (ret < 0)\r\ngoto unwind_interfaces;\r\nif (of_property_read_bool(node, "interrupt-controller")) {\r\nret = qcom_smp2p_inbound_entry(smp2p, entry, node);\r\nif (ret < 0)\r\ngoto unwind_interfaces;\r\nlist_add(&entry->node, &smp2p->inbound);\r\n} else {\r\nret = qcom_smp2p_outbound_entry(smp2p, entry, node);\r\nif (ret < 0)\r\ngoto unwind_interfaces;\r\nlist_add(&entry->node, &smp2p->outbound);\r\n}\r\n}\r\nqcom_smp2p_kick(smp2p);\r\nret = devm_request_threaded_irq(&pdev->dev, irq,\r\nNULL, qcom_smp2p_intr,\r\nIRQF_ONESHOT,\r\n"smp2p", (void *)smp2p);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to request interrupt\n");\r\ngoto unwind_interfaces;\r\n}\r\nreturn 0;\r\nunwind_interfaces:\r\nlist_for_each_entry(entry, &smp2p->inbound, node)\r\nirq_domain_remove(entry->domain);\r\nlist_for_each_entry(entry, &smp2p->outbound, node)\r\nqcom_smem_state_unregister(entry->state);\r\nsmp2p->out->valid_entries = 0;\r\nreturn ret;\r\n}\r\nstatic int qcom_smp2p_remove(struct platform_device *pdev)\r\n{\r\nstruct qcom_smp2p *smp2p = platform_get_drvdata(pdev);\r\nstruct smp2p_entry *entry;\r\nlist_for_each_entry(entry, &smp2p->inbound, node)\r\nirq_domain_remove(entry->domain);\r\nlist_for_each_entry(entry, &smp2p->outbound, node)\r\nqcom_smem_state_unregister(entry->state);\r\nsmp2p->out->valid_entries = 0;\r\nreturn 0;\r\n}
