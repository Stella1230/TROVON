int speed_idx_cca(int req_type)\r\n{\r\nswitch (req_type) {\r\ncase 0x4142:\r\ncase 0x4149:\r\ncase 0x414D:\r\ncase 0x4341:\r\ncase 0x4344:\r\ncase 0x4354:\r\ncase 0x4358:\r\ncase 0x444B:\r\ncase 0x4558:\r\ncase 0x4643:\r\ncase 0x4651:\r\ncase 0x4C47:\r\ncase 0x4C4B:\r\ncase 0x4C51:\r\ncase 0x4F48:\r\ncase 0x504F:\r\ncase 0x5053:\r\ncase 0x5058:\r\ncase 0x5343:\r\ncase 0x5344:\r\ncase 0x5345:\r\ncase 0x5350:\r\nreturn LOW;\r\ncase 0x414B:\r\ncase 0x4345:\r\ncase 0x4349:\r\ncase 0x434D:\r\ncase 0x4847:\r\ncase 0x4849:\r\ncase 0x484D:\r\ncase 0x4850:\r\ncase 0x4851:\r\ncase 0x4954:\r\ncase 0x4958:\r\ncase 0x4B43:\r\ncase 0x4B44:\r\ncase 0x4B45:\r\ncase 0x4B47:\r\ncase 0x4B48:\r\ncase 0x4B49:\r\ncase 0x4B4E:\r\ncase 0x4B50:\r\ncase 0x4B52:\r\ncase 0x4B54:\r\ncase 0x4B58:\r\ncase 0x4D50:\r\ncase 0x4D53:\r\ncase 0x4D56:\r\ncase 0x4D58:\r\ncase 0x5044:\r\ncase 0x5045:\r\ncase 0x5046:\r\ncase 0x5047:\r\ncase 0x5049:\r\ncase 0x504B:\r\ncase 0x504D:\r\ncase 0x5254:\r\ncase 0x5347:\r\ncase 0x5349:\r\ncase 0x534B:\r\ncase 0x534D:\r\ncase 0x5356:\r\ncase 0x5358:\r\ncase 0x5443:\r\ncase 0x544B:\r\ncase 0x5647:\r\nreturn HIGH;\r\ndefault:\r\nreturn MEDIUM;\r\n}\r\n}\r\nint speed_idx_ep11(int req_type)\r\n{\r\nswitch (req_type) {\r\ncase 1:\r\ncase 2:\r\ncase 36:\r\ncase 37:\r\ncase 38:\r\ncase 39:\r\ncase 40:\r\nreturn LOW;\r\ncase 17:\r\ncase 18:\r\ncase 19:\r\ncase 20:\r\ncase 21:\r\ncase 22:\r\ncase 26:\r\ncase 30:\r\ncase 31:\r\ncase 32:\r\ncase 33:\r\ncase 34:\r\ncase 35:\r\nreturn HIGH;\r\ndefault:\r\nreturn MEDIUM;\r\n}\r\n}\r\nstatic int ICAMEX_msg_to_type6MEX_msgX(struct zcrypt_queue *zq,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C', 'A',},\r\n.function_code = {'P', 'K'},\r\n};\r\nstatic struct function_and_rules_block static_pke_fnr = {\r\n.function_code = {'P', 'K'},\r\n.ulen = 10,\r\n.only_rule = {'M', 'R', 'P', ' ', ' ', ' ', ' ', ' '}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __packed * msg = ap_msg->message;\r\nint size;\r\nmsg->length = mex->inputdatalength + 2;\r\nif (copy_from_user(msg->text, mex->inputdata, mex->inputdatalength))\r\nreturn -EFAULT;\r\nsize = zcrypt_type6_mex_key_en(mex, msg->text+mex->inputdatalength, 1);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + mex->inputdatalength;\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.ToCardLen1 = size - sizeof(msg->hdr);\r\nmsg->hdr.FromCardLen1 = PCIXCC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprbx = static_cprbx;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);\r\nmsg->cprbx.rpl_msgbl = msg->hdr.FromCardLen1;\r\nmsg->fr = static_pke_fnr;\r\nmsg->cprbx.req_parml = size - sizeof(msg->hdr) - sizeof(msg->cprbx);\r\nap_msg->length = size;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type6CRT_msgX(struct zcrypt_queue *zq,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n.agent_id = {'C', 'A',},\r\n.function_code = {'P', 'D'},\r\n};\r\nstatic struct function_and_rules_block static_pkd_fnr = {\r\n.function_code = {'P', 'D'},\r\n.ulen = 10,\r\n.only_rule = {'Z', 'E', 'R', 'O', '-', 'P', 'A', 'D'}\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nstruct function_and_rules_block fr;\r\nunsigned short length;\r\nchar text[0];\r\n} __packed * msg = ap_msg->message;\r\nint size;\r\nmsg->length = crt->inputdatalength + 2;\r\nif (copy_from_user(msg->text, crt->inputdata, crt->inputdatalength))\r\nreturn -EFAULT;\r\nsize = zcrypt_type6_crt_key(crt, msg->text + crt->inputdatalength, 1);\r\nif (size < 0)\r\nreturn size;\r\nsize += sizeof(*msg) + crt->inputdatalength;\r\nmsg->hdr = static_type6_hdrX;\r\nmsg->hdr.ToCardLen1 = size - sizeof(msg->hdr);\r\nmsg->hdr.FromCardLen1 = PCIXCC_MAX_ICA_RESPONSE_SIZE - sizeof(msg->hdr);\r\nmsg->cprbx = static_cprbx;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);\r\nmsg->cprbx.req_parml = msg->cprbx.rpl_msgbl =\r\nsize - sizeof(msg->hdr) - sizeof(msg->cprbx);\r\nmsg->fr = static_pkd_fnr;\r\nap_msg->length = size;\r\nreturn 0;\r\n}\r\nstatic int XCRB_msg_to_type6CPRB_msgX(struct ap_message *ap_msg,\r\nstruct ica_xcRB *xcRB,\r\nunsigned int *fcode,\r\nunsigned short **dom)\r\n{\r\nstatic struct type6_hdr static_type6_hdrX = {\r\n.type = 0x06,\r\n.offset1 = 0x00000058,\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\n} __packed * msg = ap_msg->message;\r\nint rcblen = CEIL4(xcRB->request_control_blk_length);\r\nint replylen, req_sumlen, resp_sumlen;\r\nchar *req_data = ap_msg->message + sizeof(struct type6_hdr) + rcblen;\r\nchar *function_code;\r\nif (CEIL4(xcRB->request_control_blk_length) <\r\nxcRB->request_control_blk_length)\r\nreturn -EINVAL;\r\nap_msg->length = sizeof(struct type6_hdr) +\r\nCEIL4(xcRB->request_control_blk_length) +\r\nxcRB->request_data_length;\r\nif (ap_msg->length > MSGTYPE06_MAX_MSG_SIZE)\r\nreturn -EINVAL;\r\nreq_sumlen = CEIL4(xcRB->request_control_blk_length) +\r\nxcRB->request_data_length;\r\nif ((CEIL4(xcRB->request_control_blk_length) <=\r\nxcRB->request_data_length) ?\r\n(req_sumlen < xcRB->request_data_length) :\r\n(req_sumlen < CEIL4(xcRB->request_control_blk_length))) {\r\nreturn -EINVAL;\r\n}\r\nif (CEIL4(xcRB->reply_control_blk_length) <\r\nxcRB->reply_control_blk_length)\r\nreturn -EINVAL;\r\nreplylen = sizeof(struct type86_fmt2_msg) +\r\nCEIL4(xcRB->reply_control_blk_length) +\r\nxcRB->reply_data_length;\r\nif (replylen > MSGTYPE06_MAX_MSG_SIZE)\r\nreturn -EINVAL;\r\nresp_sumlen = CEIL4(xcRB->reply_control_blk_length) +\r\nxcRB->reply_data_length;\r\nif ((CEIL4(xcRB->reply_control_blk_length) <= xcRB->reply_data_length) ?\r\n(resp_sumlen < xcRB->reply_data_length) :\r\n(resp_sumlen < CEIL4(xcRB->reply_control_blk_length))) {\r\nreturn -EINVAL;\r\n}\r\nmsg->hdr = static_type6_hdrX;\r\nmemcpy(msg->hdr.agent_id , &(xcRB->agent_ID), sizeof(xcRB->agent_ID));\r\nmsg->hdr.ToCardLen1 = xcRB->request_control_blk_length;\r\nif (xcRB->request_data_length) {\r\nmsg->hdr.offset2 = msg->hdr.offset1 + rcblen;\r\nmsg->hdr.ToCardLen2 = xcRB->request_data_length;\r\n}\r\nmsg->hdr.FromCardLen1 = xcRB->reply_control_blk_length;\r\nmsg->hdr.FromCardLen2 = xcRB->reply_data_length;\r\nif (copy_from_user(&(msg->cprbx), xcRB->request_control_blk_addr,\r\nxcRB->request_control_blk_length))\r\nreturn -EFAULT;\r\nif (msg->cprbx.cprb_len + sizeof(msg->hdr.function_code) >\r\nxcRB->request_control_blk_length)\r\nreturn -EINVAL;\r\nfunction_code = ((unsigned char *)&msg->cprbx) + msg->cprbx.cprb_len;\r\nmemcpy(msg->hdr.function_code, function_code,\r\nsizeof(msg->hdr.function_code));\r\n*fcode = (msg->hdr.function_code[0] << 8) | msg->hdr.function_code[1];\r\n*dom = (unsigned short *)&msg->cprbx.domain;\r\nif (memcmp(function_code, "US", 2) == 0)\r\nap_msg->special = 1;\r\nelse\r\nap_msg->special = 0;\r\nif (xcRB->request_data_length &&\r\ncopy_from_user(req_data, xcRB->request_data_address,\r\nxcRB->request_data_length))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int xcrb_msg_to_type6_ep11cprb_msgx(struct ap_message *ap_msg,\r\nstruct ep11_urb *xcRB,\r\nunsigned int *fcode)\r\n{\r\nunsigned int lfmt;\r\nstatic struct type6_hdr static_type6_ep11_hdr = {\r\n.type = 0x06,\r\n.rqid = {0x00, 0x01},\r\n.function_code = {0x00, 0x00},\r\n.agent_id[0] = 0x58,\r\n.agent_id[1] = 0x43,\r\n.offset1 = 0x00000058,\r\n};\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct ep11_cprb cprbx;\r\nunsigned char pld_tag;\r\nunsigned char pld_lenfmt;\r\n} __packed * msg = ap_msg->message;\r\nstruct pld_hdr {\r\nunsigned char func_tag;\r\nunsigned char func_len;\r\nunsigned int func_val;\r\nunsigned char dom_tag;\r\nunsigned char dom_len;\r\nunsigned int dom_val;\r\n} __packed * payload_hdr = NULL;\r\nif (CEIL4(xcRB->req_len) < xcRB->req_len)\r\nreturn -EINVAL;\r\nap_msg->length = sizeof(struct type6_hdr) + xcRB->req_len;\r\nif (CEIL4(xcRB->req_len) > MSGTYPE06_MAX_MSG_SIZE -\r\n(sizeof(struct type6_hdr)))\r\nreturn -EINVAL;\r\nif (CEIL4(xcRB->resp_len) < xcRB->resp_len)\r\nreturn -EINVAL;\r\nif (CEIL4(xcRB->resp_len) > MSGTYPE06_MAX_MSG_SIZE -\r\n(sizeof(struct type86_fmt2_msg)))\r\nreturn -EINVAL;\r\nmsg->hdr = static_type6_ep11_hdr;\r\nmsg->hdr.ToCardLen1 = xcRB->req_len;\r\nmsg->hdr.FromCardLen1 = xcRB->resp_len;\r\nif (copy_from_user(&(msg->cprbx.cprb_len),\r\n(char __force __user *)xcRB->req, xcRB->req_len)) {\r\nreturn -EFAULT;\r\n}\r\nif ((msg->pld_lenfmt & 0x80) == 0x80) {\r\nswitch (msg->pld_lenfmt & 0x03) {\r\ncase 1:\r\nlfmt = 2;\r\nbreak;\r\ncase 2:\r\nlfmt = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nlfmt = 1;\r\n}\r\npayload_hdr = (struct pld_hdr *)((&(msg->pld_lenfmt))+lfmt);\r\n*fcode = payload_hdr->func_val & 0xFFFF;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_ica(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstatic unsigned char static_pad[] = {\r\n0x00, 0x02,\r\n0x1B, 0x7B, 0x5D, 0xB5, 0x75, 0x01, 0x3D, 0xFD,\r\n0x8D, 0xD1, 0xC7, 0x03, 0x2D, 0x09, 0x23, 0x57,\r\n0x89, 0x49, 0xB9, 0x3F, 0xBB, 0x99, 0x41, 0x5B,\r\n0x75, 0x21, 0x7B, 0x9D, 0x3B, 0x6B, 0x51, 0x39,\r\n0xBB, 0x0D, 0x35, 0xB9, 0x89, 0x0F, 0x93, 0xA5,\r\n0x0B, 0x47, 0xF1, 0xD3, 0xBB, 0xCB, 0xF1, 0x9D,\r\n0x23, 0x73, 0x71, 0xFF, 0xF3, 0xF5, 0x45, 0xFB,\r\n0x61, 0x29, 0x23, 0xFD, 0xF1, 0x29, 0x3F, 0x7F,\r\n0x17, 0xB7, 0x1B, 0xA9, 0x19, 0xBD, 0x57, 0xA9,\r\n0xD7, 0x95, 0xA3, 0xCB, 0xED, 0x1D, 0xDB, 0x45,\r\n0x7D, 0x11, 0xD1, 0x51, 0x1B, 0xED, 0x71, 0xE9,\r\n0xB1, 0xD1, 0xAB, 0xAB, 0x21, 0x2B, 0x1B, 0x9F,\r\n0x3B, 0x9F, 0xF7, 0xF7, 0xBD, 0x63, 0xEB, 0xAD,\r\n0xDF, 0xB3, 0x6F, 0x5B, 0xDB, 0x8D, 0xA9, 0x5D,\r\n0xE3, 0x7D, 0x77, 0x49, 0x47, 0xF5, 0xA7, 0xFD,\r\n0xAB, 0x2F, 0x27, 0x35, 0x77, 0xD3, 0x49, 0xC9,\r\n0x09, 0xEB, 0xB1, 0xF9, 0xBF, 0x4B, 0xCB, 0x2B,\r\n0xEB, 0xEB, 0x05, 0xFF, 0x7D, 0xC7, 0x91, 0x8B,\r\n0x09, 0x83, 0xB9, 0xB9, 0x69, 0x33, 0x39, 0x6B,\r\n0x79, 0x75, 0x19, 0xBF, 0xBB, 0x07, 0x1D, 0xBD,\r\n0x29, 0xBF, 0x39, 0x95, 0x93, 0x1D, 0x35, 0xC7,\r\n0xC9, 0x4D, 0xE5, 0x97, 0x0B, 0x43, 0x9B, 0xF1,\r\n0x16, 0x93, 0x03, 0x1F, 0xA5, 0xFB, 0xDB, 0xF3,\r\n0x27, 0x4F, 0x27, 0x61, 0x05, 0x1F, 0xB9, 0x23,\r\n0x2F, 0xC3, 0x81, 0xA9, 0x23, 0x71, 0x55, 0x55,\r\n0xEB, 0xED, 0x41, 0xE5, 0xF3, 0x11, 0xF1, 0x43,\r\n0x69, 0x03, 0xBD, 0x0B, 0x37, 0x0F, 0x51, 0x8F,\r\n0x0B, 0xB5, 0x89, 0x5B, 0x67, 0xA9, 0xD9, 0x4F,\r\n0x01, 0xF9, 0x21, 0x77, 0x37, 0x73, 0x79, 0xC5,\r\n0x7F, 0x51, 0xC1, 0xCF, 0x97, 0xA1, 0x75, 0xAD,\r\n0x35, 0x9D, 0xD3, 0xD3, 0xA7, 0x9D, 0x5D, 0x41,\r\n0x6F, 0x65, 0x1B, 0xCF, 0xA9, 0x87, 0x91, 0x09\r\n};\r\nstruct type86x_reply *msg = reply->message;\r\nunsigned short service_rc, service_rs;\r\nunsigned int reply_len, pad_len;\r\nchar *data;\r\nservice_rc = msg->cprbx.ccp_rtcode;\r\nif (unlikely(service_rc != 0)) {\r\nservice_rs = msg->cprbx.ccp_rscode;\r\nif ((service_rc == 8 && service_rs == 66) ||\r\n(service_rc == 8 && service_rs == 65) ||\r\n(service_rc == 8 && service_rs == 72) ||\r\n(service_rc == 8 && service_rs == 770) ||\r\n(service_rc == 12 && service_rs == 769)) {\r\nZCRYPT_DBF(DBF_DEBUG,\r\n"device=%02x.%04x rc/rs=%d/%d => rc=EINVAL\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) service_rc, (int) service_rs);\r\nreturn -EINVAL;\r\n}\r\nif (service_rc == 8 && service_rs == 783) {\r\nzq->zcard->min_mod_size =\r\nPCIXCC_MIN_MOD_SIZE_OLD;\r\nZCRYPT_DBF(DBF_DEBUG,\r\n"device=%02x.%04x rc/rs=%d/%d => rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) service_rc, (int) service_rs);\r\nreturn -EAGAIN;\r\n}\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x rc/rs=%d/%d => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) service_rc, (int) service_rs);\r\nreturn -EAGAIN;\r\n}\r\ndata = msg->text;\r\nreply_len = msg->length - 2;\r\nif (reply_len > outputdatalength)\r\nreturn -EINVAL;\r\npad_len = outputdatalength - reply_len;\r\nif (pad_len > 0) {\r\nif (pad_len < 10)\r\nreturn -EINVAL;\r\nif (copy_to_user(outputdata, static_pad, pad_len - 1))\r\nreturn -EFAULT;\r\nif (put_user(0, outputdata + pad_len - 1))\r\nreturn -EFAULT;\r\n}\r\nif (copy_to_user(outputdata + pad_len, data, reply_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_xcrb(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct type86_fmt2_msg *msg = reply->message;\r\nchar *data = reply->message;\r\nif (copy_to_user(xcRB->reply_control_blk_addr,\r\ndata + msg->fmt2.offset1, msg->fmt2.count1))\r\nreturn -EFAULT;\r\nxcRB->reply_control_blk_length = msg->fmt2.count1;\r\nif (msg->fmt2.count2)\r\nif (copy_to_user(xcRB->reply_data_addr,\r\ndata + msg->fmt2.offset2, msg->fmt2.count2))\r\nreturn -EFAULT;\r\nxcRB->reply_data_length = msg->fmt2.count2;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_ep11_xcrb(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nstruct ep11_urb *xcRB)\r\n{\r\nstruct type86_fmt2_msg *msg = reply->message;\r\nchar *data = reply->message;\r\nif (xcRB->resp_len < msg->fmt2.count1)\r\nreturn -EINVAL;\r\nif (copy_to_user((char __force __user *)xcRB->resp,\r\ndata + msg->fmt2.offset1, msg->fmt2.count1))\r\nreturn -EFAULT;\r\nxcRB->resp_len = msg->fmt2.count1;\r\nreturn 0;\r\n}\r\nstatic int convert_type86_rng(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nchar *buffer)\r\n{\r\nstruct {\r\nstruct type86_hdr hdr;\r\nstruct type86_fmt2_ext fmt2;\r\nstruct CPRBX cprbx;\r\n} __packed * msg = reply->message;\r\nchar *data = reply->message;\r\nif (msg->cprbx.ccp_rtcode != 0 || msg->cprbx.ccp_rscode != 0)\r\nreturn -EINVAL;\r\nmemcpy(buffer, data + msg->fmt2.offset2, msg->fmt2.count2);\r\nreturn msg->fmt2.count2;\r\n}\r\nstatic int convert_response_ica(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zq, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->cprbx.ccp_rtcode &&\r\n(msg->cprbx.ccp_rscode == 0x14f) &&\r\n(outputdatalength > 256)) {\r\nif (zq->zcard->max_exp_bit_length <= 17) {\r\nzq->zcard->max_exp_bit_length = 17;\r\nreturn -EAGAIN;\r\n} else\r\nreturn -EINVAL;\r\n}\r\nif (msg->hdr.reply_code)\r\nreturn convert_error(zq, reply);\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_ica(zq, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) msg->hdr.type);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_xcrb(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nstruct ica_xcRB *xcRB)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nxcRB->status = 0x0008044DL;\r\nreturn convert_error(zq, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code) {\r\nmemcpy(&(xcRB->status), msg->fmt2.apfs, sizeof(u32));\r\nreturn convert_error(zq, reply);\r\n}\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_xcrb(zq, reply, xcRB);\r\ndefault:\r\nxcRB->status = 0x0008044DL;\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) msg->hdr.type);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_ep11_xcrb(struct zcrypt_queue *zq,\r\nstruct ap_message *reply, struct ep11_urb *xcRB)\r\n{\r\nstruct type86_ep11_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE87_RSP_CODE:\r\nreturn convert_error(zq, reply);\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code)\r\nreturn convert_error(zq, reply);\r\nif (msg->cprbx.cprb_ver_id == 0x04)\r\nreturn convert_type86_ep11_xcrb(zq, reply, xcRB);\r\ndefault:\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) msg->hdr.type);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic int convert_response_rng(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nchar *data)\r\n{\r\nstruct type86x_reply *msg = reply->message;\r\nswitch (msg->hdr.type) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn -EINVAL;\r\ncase TYPE86_RSP_CODE:\r\nif (msg->hdr.reply_code)\r\nreturn -EINVAL;\r\nif (msg->cprbx.cprb_ver_id == 0x02)\r\nreturn convert_type86_rng(zq, reply, data);\r\ndefault:\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(int) msg->hdr.type);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_msgtype6_receive(struct ap_queue *aq,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct response_type *resp_type =\r\n(struct response_type *) msg->private;\r\nstruct type86x_reply *t86r;\r\nint length;\r\nif (!reply)\r\ngoto out;\r\nt86r = reply->message;\r\nif (t86r->hdr.type == TYPE86_RSP_CODE &&\r\nt86r->cprbx.cprb_ver_id == 0x02) {\r\nswitch (resp_type->type) {\r\ncase PCIXCC_RESPONSE_TYPE_ICA:\r\nlength = sizeof(struct type86x_reply)\r\n+ t86r->length - 2;\r\nlength = min(PCIXCC_MAX_ICA_RESPONSE_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ncase PCIXCC_RESPONSE_TYPE_XCRB:\r\nlength = t86r->fmt2.offset2 + t86r->fmt2.count2;\r\nlength = min(MSGTYPE06_MAX_MSG_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ndefault:\r\nmemcpy(msg->message, &error_reply,\r\nsizeof(error_reply));\r\n}\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof(error_reply));\r\nout:\r\ncomplete(&(resp_type->work));\r\n}\r\nstatic void zcrypt_msgtype6_receive_ep11(struct ap_queue *aq,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct response_type *resp_type =\r\n(struct response_type *)msg->private;\r\nstruct type86_ep11_reply *t86r;\r\nint length;\r\nif (!reply)\r\ngoto out;\r\nt86r = reply->message;\r\nif (t86r->hdr.type == TYPE86_RSP_CODE &&\r\nt86r->cprbx.cprb_ver_id == 0x04) {\r\nswitch (resp_type->type) {\r\ncase PCIXCC_RESPONSE_TYPE_EP11:\r\nlength = t86r->fmt2.offset1 + t86r->fmt2.count1;\r\nlength = min(MSGTYPE06_MAX_MSG_SIZE, length);\r\nmemcpy(msg->message, reply->message, length);\r\nbreak;\r\ndefault:\r\nmemcpy(msg->message, &error_reply, sizeof(error_reply));\r\n}\r\n} else {\r\nmemcpy(msg->message, reply->message, sizeof(error_reply));\r\n}\r\nout:\r\ncomplete(&(resp_type->work));\r\n}\r\nstatic long zcrypt_msgtype6_modexpo(struct zcrypt_queue *zq,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_ICA,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_msgtype6_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = ICAMEX_msg_to_type6MEX_msgX(zq, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zq->queue, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0) {\r\nrc = ap_msg.rc;\r\nif (rc == 0)\r\nrc = convert_response_ica(zq, &ap_msg,\r\nmex->outputdata,\r\nmex->outputdatalength);\r\n} else\r\nap_cancel_message(zq->queue, &ap_msg);\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_msgtype6_modexpo_crt(struct zcrypt_queue *zq,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_ICA,\r\n};\r\nint rc;\r\nap_init_message(&ap_msg);\r\nap_msg.message = (void *) get_zeroed_page(GFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_msgtype6_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &resp_type;\r\nrc = ICACRT_msg_to_type6CRT_msgX(zq, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&resp_type.work);\r\nap_queue_message(zq->queue, &ap_msg);\r\nrc = wait_for_completion_interruptible(&resp_type.work);\r\nif (rc == 0) {\r\nrc = ap_msg.rc;\r\nif (rc == 0)\r\nrc = convert_response_ica(zq, &ap_msg,\r\ncrt->outputdata,\r\ncrt->outputdatalength);\r\n} else {\r\nap_cancel_message(zq->queue, &ap_msg);\r\n}\r\nout_free:\r\nfree_page((unsigned long) ap_msg.message);\r\nreturn rc;\r\n}\r\nunsigned int get_cprb_fc(struct ica_xcRB *xcRB,\r\nstruct ap_message *ap_msg,\r\nunsigned int *func_code, unsigned short **dom)\r\n{\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_XCRB,\r\n};\r\nint rc;\r\nap_init_message(ap_msg);\r\nap_msg->message = kmalloc(MSGTYPE06_MAX_MSG_SIZE, GFP_KERNEL);\r\nif (!ap_msg->message)\r\nreturn -ENOMEM;\r\nap_msg->receive = zcrypt_msgtype6_receive;\r\nap_msg->psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg->private = kmalloc(sizeof(resp_type), GFP_KERNEL);\r\nif (!ap_msg->private) {\r\nkzfree(ap_msg->message);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(ap_msg->private, &resp_type, sizeof(resp_type));\r\nrc = XCRB_msg_to_type6CPRB_msgX(ap_msg, xcRB, func_code, dom);\r\nif (rc) {\r\nkzfree(ap_msg->message);\r\nkzfree(ap_msg->private);\r\n}\r\nreturn rc;\r\n}\r\nstatic long zcrypt_msgtype6_send_cprb(struct zcrypt_queue *zq,\r\nstruct ica_xcRB *xcRB,\r\nstruct ap_message *ap_msg)\r\n{\r\nint rc;\r\nstruct response_type *rtype = (struct response_type *)(ap_msg->private);\r\ninit_completion(&rtype->work);\r\nap_queue_message(zq->queue, ap_msg);\r\nrc = wait_for_completion_interruptible(&rtype->work);\r\nif (rc == 0) {\r\nrc = ap_msg->rc;\r\nif (rc == 0)\r\nrc = convert_response_xcrb(zq, ap_msg, xcRB);\r\n} else\r\nap_cancel_message(zq->queue, ap_msg);\r\nkzfree(ap_msg->message);\r\nkzfree(ap_msg->private);\r\nreturn rc;\r\n}\r\nunsigned int get_ep11cprb_fc(struct ep11_urb *xcrb,\r\nstruct ap_message *ap_msg,\r\nunsigned int *func_code)\r\n{\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_EP11,\r\n};\r\nint rc;\r\nap_init_message(ap_msg);\r\nap_msg->message = kmalloc(MSGTYPE06_MAX_MSG_SIZE, GFP_KERNEL);\r\nif (!ap_msg->message)\r\nreturn -ENOMEM;\r\nap_msg->receive = zcrypt_msgtype6_receive_ep11;\r\nap_msg->psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg->private = kmalloc(sizeof(resp_type), GFP_KERNEL);\r\nif (!ap_msg->private) {\r\nkzfree(ap_msg->message);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(ap_msg->private, &resp_type, sizeof(resp_type));\r\nrc = xcrb_msg_to_type6_ep11cprb_msgx(ap_msg, xcrb, func_code);\r\nif (rc) {\r\nkzfree(ap_msg->message);\r\nkzfree(ap_msg->private);\r\n}\r\nreturn rc;\r\n}\r\nstatic long zcrypt_msgtype6_send_ep11_cprb(struct zcrypt_queue *zq,\r\nstruct ep11_urb *xcrb,\r\nstruct ap_message *ap_msg)\r\n{\r\nint rc;\r\nunsigned int lfmt;\r\nstruct response_type *rtype = (struct response_type *)(ap_msg->private);\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct ep11_cprb cprbx;\r\nunsigned char pld_tag;\r\nunsigned char pld_lenfmt;\r\n} __packed * msg = ap_msg->message;\r\nstruct pld_hdr {\r\nunsigned char func_tag;\r\nunsigned char func_len;\r\nunsigned int func_val;\r\nunsigned char dom_tag;\r\nunsigned char dom_len;\r\nunsigned int dom_val;\r\n} __packed * payload_hdr = NULL;\r\nif (!((msg->cprbx.flags & 0x80) == 0x80)) {\r\nmsg->cprbx.target_id = (unsigned int)\r\nAP_QID_QUEUE(zq->queue->qid);\r\nif ((msg->pld_lenfmt & 0x80) == 0x80) {\r\nswitch (msg->pld_lenfmt & 0x03) {\r\ncase 1:\r\nlfmt = 2;\r\nbreak;\r\ncase 2:\r\nlfmt = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nlfmt = 1;\r\n}\r\npayload_hdr = (struct pld_hdr *)((&(msg->pld_lenfmt))+lfmt);\r\npayload_hdr->dom_val = (unsigned int)\r\nAP_QID_QUEUE(zq->queue->qid);\r\n}\r\ninit_completion(&rtype->work);\r\nap_queue_message(zq->queue, ap_msg);\r\nrc = wait_for_completion_interruptible(&rtype->work);\r\nif (rc == 0) {\r\nrc = ap_msg->rc;\r\nif (rc == 0)\r\nrc = convert_response_ep11_xcrb(zq, ap_msg, xcrb);\r\n} else\r\nap_cancel_message(zq->queue, ap_msg);\r\nkzfree(ap_msg->message);\r\nkzfree(ap_msg->private);\r\nreturn rc;\r\n}\r\nunsigned int get_rng_fc(struct ap_message *ap_msg, int *func_code,\r\nunsigned int *domain)\r\n{\r\nstruct response_type resp_type = {\r\n.type = PCIXCC_RESPONSE_TYPE_XCRB,\r\n};\r\nap_init_message(ap_msg);\r\nap_msg->message = kmalloc(MSGTYPE06_MAX_MSG_SIZE, GFP_KERNEL);\r\nif (!ap_msg->message)\r\nreturn -ENOMEM;\r\nap_msg->receive = zcrypt_msgtype6_receive;\r\nap_msg->psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg->private = kmalloc(sizeof(resp_type), GFP_KERNEL);\r\nif (!ap_msg->private) {\r\nkzfree(ap_msg->message);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(ap_msg->private, &resp_type, sizeof(resp_type));\r\nrng_type6CPRB_msgX(ap_msg, ZCRYPT_RNG_BUFFER_SIZE, domain);\r\n*func_code = HWRNG;\r\nreturn 0;\r\n}\r\nstatic long zcrypt_msgtype6_rng(struct zcrypt_queue *zq,\r\nchar *buffer, struct ap_message *ap_msg)\r\n{\r\nstruct {\r\nstruct type6_hdr hdr;\r\nstruct CPRBX cprbx;\r\nchar function_code[2];\r\nshort int rule_length;\r\nchar rule[8];\r\nshort int verb_length;\r\nshort int key_length;\r\n} __packed * msg = ap_msg->message;\r\nstruct response_type *rtype = (struct response_type *)(ap_msg->private);\r\nint rc;\r\nmsg->cprbx.domain = AP_QID_QUEUE(zq->queue->qid);\r\ninit_completion(&rtype->work);\r\nap_queue_message(zq->queue, ap_msg);\r\nrc = wait_for_completion_interruptible(&rtype->work);\r\nif (rc == 0) {\r\nrc = ap_msg->rc;\r\nif (rc == 0)\r\nrc = convert_response_rng(zq, ap_msg, buffer);\r\n} else\r\nap_cancel_message(zq->queue, ap_msg);\r\nkzfree(ap_msg->message);\r\nkzfree(ap_msg->private);\r\nreturn rc;\r\n}\r\nvoid __init zcrypt_msgtype6_init(void)\r\n{\r\nzcrypt_msgtype_register(&zcrypt_msgtype6_norng_ops);\r\nzcrypt_msgtype_register(&zcrypt_msgtype6_ops);\r\nzcrypt_msgtype_register(&zcrypt_msgtype6_ep11_ops);\r\n}\r\nvoid __exit zcrypt_msgtype6_exit(void)\r\n{\r\nzcrypt_msgtype_unregister(&zcrypt_msgtype6_norng_ops);\r\nzcrypt_msgtype_unregister(&zcrypt_msgtype6_ops);\r\nzcrypt_msgtype_unregister(&zcrypt_msgtype6_ep11_ops);\r\n}
