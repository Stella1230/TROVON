static inline void __init show_version (void) {\r\nprintk ("%s version %s\n", description_string, version_string);\r\n}\r\nstatic inline void wr_regl (const hrz_dev * dev, unsigned char reg, u32 data) {\r\noutl (cpu_to_le32 (data), dev->iobase + reg);\r\n}\r\nstatic inline u32 rd_regl (const hrz_dev * dev, unsigned char reg) {\r\nreturn le32_to_cpu (inl (dev->iobase + reg));\r\n}\r\nstatic inline void wr_regw (const hrz_dev * dev, unsigned char reg, u16 data) {\r\noutw (cpu_to_le16 (data), dev->iobase + reg);\r\n}\r\nstatic inline u16 rd_regw (const hrz_dev * dev, unsigned char reg) {\r\nreturn le16_to_cpu (inw (dev->iobase + reg));\r\n}\r\nstatic inline void wrs_regb (const hrz_dev * dev, unsigned char reg, void * addr, u32 len) {\r\noutsb (dev->iobase + reg, addr, len);\r\n}\r\nstatic inline void rds_regb (const hrz_dev * dev, unsigned char reg, void * addr, u32 len) {\r\ninsb (dev->iobase + reg, addr, len);\r\n}\r\nstatic inline void wr_mem (const hrz_dev * dev, HDW * addr, u32 data) {\r\nwr_regl (dev, MEM_WR_ADDR_REG_OFF, (addr - (HDW *) 0) * sizeof(HDW));\r\nwr_regl (dev, MEMORY_PORT_OFF, data);\r\n}\r\nstatic inline u32 rd_mem (const hrz_dev * dev, HDW * addr) {\r\nwr_regl (dev, MEM_RD_ADDR_REG_OFF, (addr - (HDW *) 0) * sizeof(HDW));\r\nreturn rd_regl (dev, MEMORY_PORT_OFF);\r\n}\r\nstatic inline void wr_framer (const hrz_dev * dev, u32 addr, u32 data) {\r\nwr_regl (dev, MEM_WR_ADDR_REG_OFF, (u32) addr | 0x80000000);\r\nwr_regl (dev, MEMORY_PORT_OFF, data);\r\n}\r\nstatic inline u32 rd_framer (const hrz_dev * dev, u32 addr) {\r\nwr_regl (dev, MEM_RD_ADDR_REG_OFF, (u32) addr | 0x80000000);\r\nreturn rd_regl (dev, MEMORY_PORT_OFF);\r\n}\r\nstatic inline void FLUSH_RX_CHANNEL (hrz_dev * dev, u16 channel) {\r\nwr_regw (dev, RX_CHANNEL_PORT_OFF, FLUSH_CHANNEL | channel);\r\nreturn;\r\n}\r\nstatic void WAIT_FLUSH_RX_COMPLETE (hrz_dev * dev) {\r\nwhile (rd_regw (dev, RX_CHANNEL_PORT_OFF) & FLUSH_CHANNEL)\r\n;\r\nreturn;\r\n}\r\nstatic inline void SELECT_RX_CHANNEL (hrz_dev * dev, u16 channel) {\r\nwr_regw (dev, RX_CHANNEL_PORT_OFF, channel);\r\nreturn;\r\n}\r\nstatic void WAIT_UPDATE_COMPLETE (hrz_dev * dev) {\r\nwhile (rd_regw (dev, RX_CHANNEL_PORT_OFF) & RX_CHANNEL_UPDATE_IN_PROGRESS)\r\n;\r\nreturn;\r\n}\r\nstatic inline void SELECT_TX_CHANNEL (hrz_dev * dev, u16 tx_channel) {\r\nwr_regl (dev, TX_CHANNEL_PORT_OFF, tx_channel);\r\nreturn;\r\n}\r\nstatic inline void update_tx_channel_config (hrz_dev * dev, short chan, u8 mode, u16 value) {\r\nwr_regw (dev, TX_CHANNEL_CONFIG_COMMAND_OFF,\r\nchan * TX_CHANNEL_CONFIG_MULT | mode);\r\nwr_regw (dev, TX_CHANNEL_CONFIG_DATA_OFF, value);\r\nreturn;\r\n}\r\nstatic inline void dump_skb (char * prefix, unsigned int vc, struct sk_buff * skb) {\r\n#ifdef DEBUG_HORIZON\r\nunsigned int i;\r\nunsigned char * data = skb->data;\r\nPRINTDB (DBG_DATA, "%s(%u) ", prefix, vc);\r\nfor (i=0; i<skb->len && i < 256;i++)\r\nPRINTDM (DBG_DATA, "%02x ", data[i]);\r\nPRINTDE (DBG_DATA,"");\r\n#else\r\n(void) prefix;\r\n(void) vc;\r\n(void) skb;\r\n#endif\r\nreturn;\r\n}\r\nstatic inline void dump_regs (hrz_dev * dev) {\r\n#ifdef DEBUG_HORIZON\r\nPRINTD (DBG_REGS, "CONTROL 0: %#x", rd_regl (dev, CONTROL_0_REG));\r\nPRINTD (DBG_REGS, "RX CONFIG: %#x", rd_regw (dev, RX_CONFIG_OFF));\r\nPRINTD (DBG_REGS, "TX CONFIG: %#x", rd_regw (dev, TX_CONFIG_OFF));\r\nPRINTD (DBG_REGS, "TX STATUS: %#x", rd_regw (dev, TX_STATUS_OFF));\r\nPRINTD (DBG_REGS, "IRQ ENBLE: %#x", rd_regl (dev, INT_ENABLE_REG_OFF));\r\nPRINTD (DBG_REGS, "IRQ SORCE: %#x", rd_regl (dev, INT_SOURCE_REG_OFF));\r\n#else\r\n(void) dev;\r\n#endif\r\nreturn;\r\n}\r\nstatic inline void dump_framer (hrz_dev * dev) {\r\n#ifdef DEBUG_HORIZON\r\nunsigned int i;\r\nPRINTDB (DBG_REGS, "framer registers:");\r\nfor (i = 0; i < 0x10; ++i)\r\nPRINTDM (DBG_REGS, " %02x", rd_framer (dev, i));\r\nPRINTDE (DBG_REGS,"");\r\n#else\r\n(void) dev;\r\n#endif\r\nreturn;\r\n}\r\nstatic inline int vpivci_to_channel (u16 * channel, const short vpi, const int vci) {\r\nunsigned short vci_bits = 10 - vpi_bits;\r\nif (0 <= vpi && vpi < 1<<vpi_bits && 0 <= vci && vci < 1<<vci_bits) {\r\n*channel = vpi<<vci_bits | vci;\r\nreturn *channel ? 0 : -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic inline u16 rx_q_entry_to_length (u32 x) {\r\nreturn x & RX_Q_ENTRY_LENGTH_MASK;\r\n}\r\nstatic inline u16 rx_q_entry_to_rx_channel (u32 x) {\r\nreturn (x>>RX_Q_ENTRY_CHANNEL_SHIFT) & RX_CHANNEL_MASK;\r\n}\r\nstatic int make_rate (const hrz_dev * dev, u32 c, rounding r,\r\nu16 * bits, unsigned int * actual)\r\n{\r\nconst unsigned long br = test_bit(ultra, &dev->flags) ? BR_ULT : BR_HRZ;\r\nu32 div = CR_MIND;\r\nu32 pre;\r\nunsigned long br_man = br;\r\nunsigned int br_exp = 0;\r\nPRINTD (DBG_QOS|DBG_FLOW, "make_rate b=%lu, c=%u, %s", br, c,\r\nr == round_up ? "up" : r == round_down ? "down" : "nearest");\r\nif (!c) {\r\nPRINTD (DBG_QOS|DBG_ERR, "zero rate is not allowed!");\r\nreturn -EINVAL;\r\n}\r\nwhile (br_exp < CR_MAXPEXP + CR_MIND && (br_man % 2 == 0)) {\r\nbr_man = br_man >> 1;\r\n++br_exp;\r\n}\r\nif (br_man <= (c << (CR_MAXPEXP+CR_MIND-br_exp))) {\r\nswitch (r) {\r\ncase round_down:\r\npre = DIV_ROUND_UP(br, c<<div);\r\nif (!pre)\r\npre = 1;\r\nbreak;\r\ncase round_nearest:\r\npre = DIV_ROUND_CLOSEST(br, c<<div);\r\nif (!pre)\r\npre = 1;\r\nbreak;\r\ndefault:\r\npre = br/(c<<div);\r\nif (!pre)\r\nreturn -EINVAL;\r\n}\r\nPRINTD (DBG_QOS, "A: p=%u, d=%u", pre, div);\r\ngoto got_it;\r\n}\r\nwhile (div < CR_MAXD) {\r\ndiv++;\r\nif (br_man <= (c << (CR_MAXPEXP+div-br_exp))) {\r\nswitch (r) {\r\ncase round_down:\r\npre = DIV_ROUND_UP(br, c<<div);\r\nbreak;\r\ncase round_nearest:\r\npre = DIV_ROUND_CLOSEST(br, c<<div);\r\nbreak;\r\ndefault:\r\npre = br/(c<<div);\r\n}\r\nPRINTD (DBG_QOS, "B: p=%u, d=%u", pre, div);\r\ngoto got_it;\r\n}\r\n}\r\nif (r == round_down)\r\nreturn -EINVAL;\r\npre = 1 << CR_MAXPEXP;\r\nPRINTD (DBG_QOS, "C: p=%u, d=%u", pre, div);\r\ngot_it:\r\nif (div > CR_MAXD || (!pre) || pre > 1<<CR_MAXPEXP) {\r\nPRINTD (DBG_QOS, "set_cr internal failure: d=%u p=%u",\r\ndiv, pre);\r\nreturn -EINVAL;\r\n} else {\r\nif (bits)\r\n*bits = (div<<CLOCK_SELECT_SHIFT) | (pre-1);\r\nif (actual) {\r\n*actual = DIV_ROUND_UP(br, pre<<div);\r\nPRINTD (DBG_QOS, "actual rate: %u", *actual);\r\n}\r\nreturn 0;\r\n}\r\n}\r\nstatic int make_rate_with_tolerance (const hrz_dev * dev, u32 c, rounding r, unsigned int tol,\r\nu16 * bit_pattern, unsigned int * actual) {\r\nunsigned int my_actual;\r\nPRINTD (DBG_QOS|DBG_FLOW, "make_rate_with_tolerance c=%u, %s, tol=%u",\r\nc, (r == round_up) ? "up" : (r == round_down) ? "down" : "nearest", tol);\r\nif (!actual)\r\nactual = &my_actual;\r\nif (make_rate (dev, c, round_nearest, bit_pattern, actual))\r\nreturn -1;\r\nif (c - tol <= *actual && *actual <= c + tol)\r\nreturn 0;\r\nelse\r\nreturn make_rate (dev, c, r, bit_pattern, actual);\r\n}\r\nstatic int hrz_open_rx (hrz_dev * dev, u16 channel) {\r\nunsigned long flags;\r\nu32 channel_type;\r\nu16 buf_ptr = RX_CHANNEL_IDLE;\r\nrx_ch_desc * rx_desc = &memmap->rx_descs[channel];\r\nPRINTD (DBG_FLOW, "hrz_open_rx %x", channel);\r\nspin_lock_irqsave (&dev->mem_lock, flags);\r\nchannel_type = rd_mem (dev, &rx_desc->wr_buf_type) & BUFFER_PTR_MASK;\r\nspin_unlock_irqrestore (&dev->mem_lock, flags);\r\nif (channel_type != RX_CHANNEL_DISABLED) {\r\nPRINTD (DBG_ERR|DBG_VCC, "RX channel for VC already open");\r\nreturn -EBUSY;\r\n}\r\nif (dev->noof_spare_buffers) {\r\nbuf_ptr = dev->spare_buffers[--dev->noof_spare_buffers];\r\nPRINTD (DBG_VCC, "using a spare buffer: %u", buf_ptr);\r\nif (buf_ptr == RX_CHANNEL_DISABLED || buf_ptr == RX_CHANNEL_IDLE) {\r\nPRINTD (DBG_ERR|DBG_VCC, "bad spare buffer pointer, using IDLE");\r\nbuf_ptr = RX_CHANNEL_IDLE;\r\n}\r\n} else {\r\nPRINTD (DBG_VCC, "using IDLE buffer pointer");\r\n}\r\nspin_lock_irqsave (&dev->mem_lock, flags);\r\nwr_mem (dev, &rx_desc->wr_buf_type,\r\nbuf_ptr | CHANNEL_TYPE_AAL5 | FIRST_CELL_OF_AAL5_FRAME);\r\nif (buf_ptr != RX_CHANNEL_IDLE)\r\nwr_mem (dev, &rx_desc->rd_buf_type, buf_ptr);\r\nspin_unlock_irqrestore (&dev->mem_lock, flags);\r\nPRINTD (DBG_FLOW, "hrz_open_rx ok");\r\nreturn 0;\r\n}\r\nstatic void hrz_kfree_skb (struct sk_buff * skb) {\r\nif (ATM_SKB(skb)->vcc->pop) {\r\nATM_SKB(skb)->vcc->pop (ATM_SKB(skb)->vcc, skb);\r\n} else {\r\ndev_kfree_skb_any (skb);\r\n}\r\n}\r\nstatic void hrz_close_rx (hrz_dev * dev, u16 vc) {\r\nunsigned long flags;\r\nu32 value;\r\nu32 r1, r2;\r\nrx_ch_desc * rx_desc = &memmap->rx_descs[vc];\r\nint was_idle = 0;\r\nspin_lock_irqsave (&dev->mem_lock, flags);\r\nvalue = rd_mem (dev, &rx_desc->wr_buf_type) & BUFFER_PTR_MASK;\r\nspin_unlock_irqrestore (&dev->mem_lock, flags);\r\nif (value == RX_CHANNEL_DISABLED) {\r\nPRINTD (DBG_VCC, "closing VC: RX channel %u already disabled", vc);\r\nreturn;\r\n}\r\nif (value == RX_CHANNEL_IDLE)\r\nwas_idle = 1;\r\nspin_lock_irqsave (&dev->mem_lock, flags);\r\nfor (;;) {\r\nwr_mem (dev, &rx_desc->wr_buf_type, RX_CHANNEL_DISABLED);\r\nif ((rd_mem (dev, &rx_desc->wr_buf_type) & BUFFER_PTR_MASK) == RX_CHANNEL_DISABLED)\r\nbreak;\r\nwas_idle = 0;\r\n}\r\nif (was_idle) {\r\nspin_unlock_irqrestore (&dev->mem_lock, flags);\r\nreturn;\r\n}\r\nWAIT_FLUSH_RX_COMPLETE(dev);\r\nfor (;;) {\r\nu16 other = vc^(RX_CHANS/2);\r\nSELECT_RX_CHANNEL (dev, other);\r\nWAIT_UPDATE_COMPLETE (dev);\r\nr1 = rd_mem (dev, &rx_desc->rd_buf_type);\r\nSELECT_RX_CHANNEL (dev, vc);\r\nWAIT_UPDATE_COMPLETE (dev);\r\nFLUSH_RX_CHANNEL (dev, vc);\r\nWAIT_FLUSH_RX_COMPLETE (dev);\r\nSELECT_RX_CHANNEL (dev, other);\r\nWAIT_UPDATE_COMPLETE (dev);\r\nr2 = rd_mem (dev, &rx_desc->rd_buf_type);\r\nPRINTD (DBG_VCC|DBG_RX, "r1 = %u, r2 = %u", r1, r2);\r\nif (r1 == r2) {\r\ndev->spare_buffers[dev->noof_spare_buffers++] = (u16)r1;\r\nbreak;\r\n}\r\n}\r\n#if 0\r\n{\r\nrx_q_entry * wr_ptr = &memmap->rx_q_entries[rd_regw (dev, RX_QUEUE_WR_PTR_OFF)];\r\nrx_q_entry * rd_ptr = dev->rx_q_entry;\r\nPRINTD (DBG_VCC|DBG_RX, "rd_ptr = %u, wr_ptr = %u", rd_ptr, wr_ptr);\r\nwhile (rd_ptr != wr_ptr) {\r\nu32 x = rd_mem (dev, (HDW *) rd_ptr);\r\nif (vc == rx_q_entry_to_rx_channel (x)) {\r\nx |= SIMONS_DODGEY_MARKER;\r\nPRINTD (DBG_RX|DBG_VCC|DBG_WARN, "marking a frame as dodgey");\r\nwr_mem (dev, (HDW *) rd_ptr, x);\r\n}\r\nif (rd_ptr == dev->rx_q_wrap)\r\nrd_ptr = dev->rx_q_reset;\r\nelse\r\nrd_ptr++;\r\n}\r\n}\r\n#endif\r\nspin_unlock_irqrestore (&dev->mem_lock, flags);\r\nreturn;\r\n}\r\nstatic void rx_schedule (hrz_dev * dev, int irq) {\r\nunsigned int rx_bytes;\r\nint pio_instead = 0;\r\n#ifndef TAILRECURSIONWORKS\r\npio_instead = 1;\r\nwhile (pio_instead) {\r\n#endif\r\nrx_bytes = dev->rx_bytes;\r\n#if 0\r\nspin_count = 0;\r\nwhile (rd_regl (dev, MASTER_RX_COUNT_REG_OFF)) {\r\nPRINTD (DBG_RX|DBG_WARN, "RX error: other PCI Bus Master RX still in progress!");\r\nif (++spin_count > 10) {\r\nPRINTD (DBG_RX|DBG_ERR, "spun out waiting PCI Bus Master RX completion");\r\nwr_regl (dev, MASTER_RX_COUNT_REG_OFF, 0);\r\nclear_bit (rx_busy, &dev->flags);\r\nhrz_kfree_skb (dev->rx_skb);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nif (rx_bytes) {\r\nif (rx_bytes <= MAX_PIO_COUNT) {\r\nPRINTD (DBG_RX|DBG_BUS, "(pio)");\r\npio_instead = 1;\r\n}\r\nif (rx_bytes <= MAX_TRANSFER_COUNT) {\r\nPRINTD (DBG_RX|DBG_BUS, "(simple or last multi)");\r\ndev->rx_bytes = 0;\r\n} else {\r\nPRINTD (DBG_RX|DBG_BUS, "(continuing multi)");\r\ndev->rx_bytes = rx_bytes - MAX_TRANSFER_COUNT;\r\nrx_bytes = MAX_TRANSFER_COUNT;\r\n}\r\n} else {\r\n#if 0\r\nunsigned int rx_regions = dev->rx_regions;\r\n#else\r\nunsigned int rx_regions = 0;\r\n#endif\r\nif (rx_regions) {\r\n#if 0\r\ndev->rx_addr = dev->rx_iovec->iov_base;\r\nrx_bytes = dev->rx_iovec->iov_len;\r\n++dev->rx_iovec;\r\ndev->rx_regions = rx_regions - 1;\r\nif (rx_bytes <= MAX_PIO_COUNT) {\r\nPRINTD (DBG_RX|DBG_BUS, "(pio)");\r\npio_instead = 1;\r\n}\r\nif (rx_bytes <= MAX_TRANSFER_COUNT) {\r\nPRINTD (DBG_RX|DBG_BUS, "(full region)");\r\ndev->rx_bytes = 0;\r\n} else {\r\nPRINTD (DBG_RX|DBG_BUS, "(start multi region)");\r\ndev->rx_bytes = rx_bytes - MAX_TRANSFER_COUNT;\r\nrx_bytes = MAX_TRANSFER_COUNT;\r\n}\r\n#endif\r\n} else {\r\nstruct sk_buff * skb = dev->rx_skb;\r\nFLUSH_RX_CHANNEL (dev, dev->rx_channel);\r\ndump_skb ("<<<", dev->rx_channel, skb);\r\nPRINTD (DBG_RX|DBG_SKB, "push %p %u", skb->data, skb->len);\r\n{\r\nstruct atm_vcc * vcc = ATM_SKB(skb)->vcc;\r\natomic_inc(&vcc->stats->rx);\r\n__net_timestamp(skb);\r\nvcc->push (vcc, skb);\r\n}\r\n}\r\n}\r\nif (rx_bytes) {\r\nif (pio_instead) {\r\nif (irq)\r\nwr_regl (dev, MASTER_RX_COUNT_REG_OFF, 0);\r\nrds_regb (dev, DATA_PORT_OFF, dev->rx_addr, rx_bytes);\r\n} else {\r\nwr_regl (dev, MASTER_RX_ADDR_REG_OFF, virt_to_bus (dev->rx_addr));\r\nwr_regl (dev, MASTER_RX_COUNT_REG_OFF, rx_bytes);\r\n}\r\ndev->rx_addr += rx_bytes;\r\n} else {\r\nif (irq)\r\nwr_regl (dev, MASTER_RX_COUNT_REG_OFF, 0);\r\nYELLOW_LED_ON(dev);\r\nclear_bit (rx_busy, &dev->flags);\r\nPRINTD (DBG_RX, "cleared rx_busy for dev %p", dev);\r\n}\r\n#ifdef TAILRECURSIONWORKS\r\nif (pio_instead)\r\nreturn rx_schedule (dev, 0);\r\nreturn;\r\n#else\r\nirq = 0;\r\n}\r\nreturn;\r\n#endif\r\n}\r\nstatic void rx_bus_master_complete_handler (hrz_dev * dev) {\r\nif (test_bit (rx_busy, &dev->flags)) {\r\nrx_schedule (dev, 1);\r\n} else {\r\nPRINTD (DBG_RX|DBG_ERR, "unexpected RX bus master completion");\r\nwr_regl (dev, MASTER_RX_COUNT_REG_OFF, 0);\r\n}\r\nreturn;\r\n}\r\nstatic int tx_hold (hrz_dev * dev) {\r\nPRINTD (DBG_TX, "sleeping at tx lock %p %lu", dev, dev->flags);\r\nwait_event_interruptible(dev->tx_queue, (!test_and_set_bit(tx_busy, &dev->flags)));\r\nPRINTD (DBG_TX, "woken at tx lock %p %lu", dev, dev->flags);\r\nif (signal_pending (current))\r\nreturn -1;\r\nPRINTD (DBG_TX, "set tx_busy for dev %p", dev);\r\nreturn 0;\r\n}\r\nstatic inline void tx_release (hrz_dev * dev) {\r\nclear_bit (tx_busy, &dev->flags);\r\nPRINTD (DBG_TX, "cleared tx_busy for dev %p", dev);\r\nwake_up_interruptible (&dev->tx_queue);\r\n}\r\nstatic void tx_schedule (hrz_dev * const dev, int irq) {\r\nunsigned int tx_bytes;\r\nint append_desc = 0;\r\nint pio_instead = 0;\r\n#ifndef TAILRECURSIONWORKS\r\npio_instead = 1;\r\nwhile (pio_instead) {\r\n#endif\r\ntx_bytes = dev->tx_bytes;\r\n#if 0\r\nspin_count = 0;\r\nwhile (rd_regl (dev, MASTER_TX_COUNT_REG_OFF)) {\r\nPRINTD (DBG_TX|DBG_WARN, "TX error: other PCI Bus Master TX still in progress!");\r\nif (++spin_count > 10) {\r\nPRINTD (DBG_TX|DBG_ERR, "spun out waiting PCI Bus Master TX completion");\r\nwr_regl (dev, MASTER_TX_COUNT_REG_OFF, 0);\r\ntx_release (dev);\r\nhrz_kfree_skb (dev->tx_skb);\r\nreturn;\r\n}\r\n}\r\n#endif\r\nif (tx_bytes) {\r\nif (!test_bit (ultra, &dev->flags) || tx_bytes <= MAX_PIO_COUNT) {\r\nPRINTD (DBG_TX|DBG_BUS, "(pio)");\r\npio_instead = 1;\r\n}\r\nif (tx_bytes <= MAX_TRANSFER_COUNT) {\r\nPRINTD (DBG_TX|DBG_BUS, "(simple or last multi)");\r\nif (!dev->tx_iovec) {\r\nappend_desc = 1;\r\n}\r\ndev->tx_bytes = 0;\r\n} else {\r\nPRINTD (DBG_TX|DBG_BUS, "(continuing multi)");\r\ndev->tx_bytes = tx_bytes - MAX_TRANSFER_COUNT;\r\ntx_bytes = MAX_TRANSFER_COUNT;\r\n}\r\n} else {\r\nunsigned int tx_regions = dev->tx_regions;\r\nif (tx_regions) {\r\ndev->tx_addr = dev->tx_iovec->iov_base;\r\ntx_bytes = dev->tx_iovec->iov_len;\r\n++dev->tx_iovec;\r\ndev->tx_regions = tx_regions - 1;\r\nif (!test_bit (ultra, &dev->flags) || tx_bytes <= MAX_PIO_COUNT) {\r\nPRINTD (DBG_TX|DBG_BUS, "(pio)");\r\npio_instead = 1;\r\n}\r\nif (tx_bytes <= MAX_TRANSFER_COUNT) {\r\nPRINTD (DBG_TX|DBG_BUS, "(full region)");\r\ndev->tx_bytes = 0;\r\n} else {\r\nPRINTD (DBG_TX|DBG_BUS, "(start multi region)");\r\ndev->tx_bytes = tx_bytes - MAX_TRANSFER_COUNT;\r\ntx_bytes = MAX_TRANSFER_COUNT;\r\n}\r\n} else {\r\nstruct sk_buff * skb = dev->tx_skb;\r\ndev->tx_iovec = NULL;\r\natomic_inc(&ATM_SKB(skb)->vcc->stats->tx);\r\nhrz_kfree_skb (skb);\r\n}\r\n}\r\nif (tx_bytes) {\r\nif (pio_instead) {\r\nif (irq)\r\nwr_regl (dev, MASTER_TX_COUNT_REG_OFF, 0);\r\nwrs_regb (dev, DATA_PORT_OFF, dev->tx_addr, tx_bytes);\r\nif (append_desc)\r\nwr_regl (dev, TX_DESCRIPTOR_PORT_OFF, cpu_to_be32 (dev->tx_skb->len));\r\n} else {\r\nwr_regl (dev, MASTER_TX_ADDR_REG_OFF, virt_to_bus (dev->tx_addr));\r\nif (append_desc)\r\nwr_regl (dev, TX_DESCRIPTOR_REG_OFF, cpu_to_be32 (dev->tx_skb->len));\r\nwr_regl (dev, MASTER_TX_COUNT_REG_OFF,\r\nappend_desc\r\n? tx_bytes | MASTER_TX_AUTO_APPEND_DESC\r\n: tx_bytes);\r\n}\r\ndev->tx_addr += tx_bytes;\r\n} else {\r\nif (irq)\r\nwr_regl (dev, MASTER_TX_COUNT_REG_OFF, 0);\r\nYELLOW_LED_ON(dev);\r\ntx_release (dev);\r\n}\r\n#ifdef TAILRECURSIONWORKS\r\nif (pio_instead)\r\nreturn tx_schedule (dev, 0);\r\nreturn;\r\n#else\r\nirq = 0;\r\n}\r\nreturn;\r\n#endif\r\n}\r\nstatic void tx_bus_master_complete_handler (hrz_dev * dev) {\r\nif (test_bit (tx_busy, &dev->flags)) {\r\ntx_schedule (dev, 1);\r\n} else {\r\nPRINTD (DBG_TX|DBG_ERR, "unexpected TX bus master completion");\r\nwr_regl (dev, MASTER_TX_COUNT_REG_OFF, 0);\r\n}\r\nreturn;\r\n}\r\nstatic u32 rx_queue_entry_next (hrz_dev * dev) {\r\nu32 rx_queue_entry;\r\nspin_lock (&dev->mem_lock);\r\nrx_queue_entry = rd_mem (dev, &dev->rx_q_entry->entry);\r\nif (dev->rx_q_entry == dev->rx_q_wrap)\r\ndev->rx_q_entry = dev->rx_q_reset;\r\nelse\r\ndev->rx_q_entry++;\r\nwr_regw (dev, RX_QUEUE_RD_PTR_OFF, dev->rx_q_entry - dev->rx_q_reset);\r\nspin_unlock (&dev->mem_lock);\r\nreturn rx_queue_entry;\r\n}\r\nstatic void rx_data_av_handler (hrz_dev * dev) {\r\nu32 rx_queue_entry;\r\nu32 rx_queue_entry_flags;\r\nu16 rx_len;\r\nu16 rx_channel;\r\nPRINTD (DBG_FLOW, "hrz_data_av_handler");\r\nif (test_and_set_bit (rx_busy, &dev->flags)) {\r\nPRINTD (DBG_RX, "locked out of rx lock");\r\nreturn;\r\n}\r\nPRINTD (DBG_RX, "set rx_busy for dev %p", dev);\r\nYELLOW_LED_OFF(dev);\r\nrx_queue_entry = rx_queue_entry_next (dev);\r\nrx_len = rx_q_entry_to_length (rx_queue_entry);\r\nrx_channel = rx_q_entry_to_rx_channel (rx_queue_entry);\r\nWAIT_FLUSH_RX_COMPLETE (dev);\r\nSELECT_RX_CHANNEL (dev, rx_channel);\r\nPRINTD (DBG_RX, "rx_queue_entry is: %#x", rx_queue_entry);\r\nrx_queue_entry_flags = rx_queue_entry & (RX_CRC_32_OK|RX_COMPLETE_FRAME|SIMONS_DODGEY_MARKER);\r\nif (!rx_len) {\r\nPRINTK (KERN_ERR, "zero-length frame!");\r\nrx_queue_entry_flags &= ~RX_COMPLETE_FRAME;\r\n}\r\nif (rx_queue_entry_flags & SIMONS_DODGEY_MARKER) {\r\nPRINTD (DBG_RX|DBG_ERR, "Simon's marker detected!");\r\n}\r\nif (rx_queue_entry_flags == (RX_CRC_32_OK | RX_COMPLETE_FRAME)) {\r\nstruct atm_vcc * atm_vcc;\r\nPRINTD (DBG_RX, "got a frame on rx_channel %x len %u", rx_channel, rx_len);\r\natm_vcc = dev->rxer[rx_channel];\r\nif (atm_vcc) {\r\nif (atm_vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nif (rx_len <= atm_vcc->qos.rxtp.max_sdu) {\r\nstruct sk_buff * skb = atm_alloc_charge (atm_vcc, rx_len, GFP_ATOMIC);\r\nif (skb) {\r\ndev->rx_skb = skb;\r\ndev->rx_channel = rx_channel;\r\nskb_put (skb, rx_len);\r\nATM_SKB(skb)->vcc = atm_vcc;\r\ndev->rx_bytes = rx_len;\r\ndev->rx_addr = skb->data;\r\nPRINTD (DBG_RX, "RX start simple transfer (addr %p, len %d)",\r\nskb->data, rx_len);\r\nrx_schedule (dev, 0);\r\nreturn;\r\n} else {\r\nPRINTD (DBG_SKB|DBG_WARN, "failed to get skb");\r\n}\r\n} else {\r\nPRINTK (KERN_INFO, "frame received on TX-only VC %x", rx_channel);\r\n}\r\n} else {\r\nPRINTK (KERN_WARNING, "dropped over-size frame");\r\n}\r\n} else {\r\nPRINTD (DBG_WARN|DBG_VCC|DBG_RX, "no VCC for this frame (VC closed)");\r\n}\r\n} else {\r\n}\r\nYELLOW_LED_ON(dev);\r\nFLUSH_RX_CHANNEL (dev,rx_channel);\r\nclear_bit (rx_busy, &dev->flags);\r\nreturn;\r\n}\r\nstatic irqreturn_t interrupt_handler(int irq, void *dev_id)\r\n{\r\nhrz_dev *dev = dev_id;\r\nu32 int_source;\r\nunsigned int irq_ok;\r\nPRINTD (DBG_FLOW, "interrupt_handler: %p", dev_id);\r\nirq_ok = 0;\r\nwhile ((int_source = rd_regl (dev, INT_SOURCE_REG_OFF)\r\n& INTERESTING_INTERRUPTS)) {\r\nif (int_source & RX_BUS_MASTER_COMPLETE) {\r\n++irq_ok;\r\nPRINTD (DBG_IRQ|DBG_BUS|DBG_RX, "rx_bus_master_complete asserted");\r\nrx_bus_master_complete_handler (dev);\r\n}\r\nif (int_source & TX_BUS_MASTER_COMPLETE) {\r\n++irq_ok;\r\nPRINTD (DBG_IRQ|DBG_BUS|DBG_TX, "tx_bus_master_complete asserted");\r\ntx_bus_master_complete_handler (dev);\r\n}\r\nif (int_source & RX_DATA_AV) {\r\n++irq_ok;\r\nPRINTD (DBG_IRQ|DBG_RX, "rx_data_av asserted");\r\nrx_data_av_handler (dev);\r\n}\r\n}\r\nif (irq_ok) {\r\nPRINTD (DBG_IRQ, "work done: %u", irq_ok);\r\n} else {\r\nPRINTD (DBG_IRQ|DBG_WARN, "spurious interrupt source: %#x", int_source);\r\n}\r\nPRINTD (DBG_IRQ|DBG_FLOW, "interrupt_handler done: %p", dev_id);\r\nif (irq_ok)\r\nreturn IRQ_HANDLED;\r\nreturn IRQ_NONE;\r\n}\r\nstatic void do_housekeeping (unsigned long arg) {\r\nhrz_dev * dev = (hrz_dev *) arg;\r\ndev->tx_cell_count += rd_regw (dev, TX_CELL_COUNT_OFF);\r\ndev->rx_cell_count += rd_regw (dev, RX_CELL_COUNT_OFF);\r\ndev->hec_error_count += rd_regw (dev, HEC_ERROR_COUNT_OFF);\r\ndev->unassigned_cell_count += rd_regw (dev, UNASSIGNED_CELL_COUNT_OFF);\r\nmod_timer (&dev->housekeeping, jiffies + HZ/10);\r\nreturn;\r\n}\r\nstatic short setup_idle_tx_channel (hrz_dev * dev, hrz_vcc * vcc) {\r\nunsigned short idle_channels;\r\nshort tx_channel = -1;\r\nunsigned int spin_count;\r\nPRINTD (DBG_FLOW|DBG_TX, "setup_idle_tx_channel %p", dev);\r\nspin_count = 0;\r\nwhile (!(idle_channels = rd_regw (dev, TX_STATUS_OFF) & IDLE_CHANNELS_MASK)) {\r\nPRINTD (DBG_TX|DBG_WARN, "waiting for idle TX channel");\r\nif (++spin_count > 100) {\r\nPRINTD (DBG_TX|DBG_ERR, "spun out waiting for idle TX channel");\r\nreturn -EBUSY;\r\n}\r\n}\r\n{\r\nint chan = dev->tx_idle;\r\nint keep_going = 1;\r\nwhile (keep_going) {\r\nif (idle_channels & (1<<chan)) {\r\ntx_channel = chan;\r\nkeep_going = 0;\r\n}\r\n++chan;\r\nif (chan == TX_CHANS)\r\nchan = 0;\r\n}\r\ndev->tx_idle = chan;\r\n}\r\n{\r\ntx_ch_desc * tx_desc = &memmap->tx_descs[tx_channel];\r\nu32 rd_ptr;\r\nu32 wr_ptr;\r\nu16 channel = vcc->channel;\r\nunsigned long flags;\r\nspin_lock_irqsave (&dev->mem_lock, flags);\r\ndev->tx_channel_record[tx_channel] = channel;\r\nupdate_tx_channel_config (dev, tx_channel, RATE_TYPE_ACCESS,\r\nvcc->tx_xbr_bits);\r\nupdate_tx_channel_config (dev, tx_channel, PCR_TIMER_ACCESS,\r\nvcc->tx_pcr_bits);\r\n#if 0\r\nif (vcc->tx_xbr_bits == VBR_RATE_TYPE) {\r\nupdate_tx_channel_config (dev, tx_channel, SCR_TIMER_ACCESS,\r\nvcc->tx_scr_bits);\r\nupdate_tx_channel_config (dev, tx_channel, BUCKET_CAPACITY_ACCESS,\r\nvcc->tx_bucket_bits);\r\nupdate_tx_channel_config (dev, tx_channel, BUCKET_FULLNESS_ACCESS,\r\nvcc->tx_bucket_bits);\r\n}\r\n#endif\r\nrd_ptr = rd_mem (dev, &tx_desc->rd_buf_type) & BUFFER_PTR_MASK;\r\nwr_ptr = rd_mem (dev, &tx_desc->wr_buf_type) & BUFFER_PTR_MASK;\r\nif (rd_ptr != wr_ptr) {\r\nPRINTD (DBG_TX|DBG_ERR, "TX buffer pointers are broken!");\r\n}\r\nPRINTD (DBG_TX, "TX buffer pointers are: rd %x, wr %x.",\r\nrd_ptr, wr_ptr);\r\nswitch (vcc->aal) {\r\ncase aal0:\r\nPRINTD (DBG_QOS|DBG_TX, "tx_channel: aal0");\r\nrd_ptr |= CHANNEL_TYPE_RAW_CELLS;\r\nwr_ptr |= CHANNEL_TYPE_RAW_CELLS;\r\nbreak;\r\ncase aal34:\r\nPRINTD (DBG_QOS|DBG_TX, "tx_channel: aal34");\r\nrd_ptr |= CHANNEL_TYPE_AAL3_4;\r\nwr_ptr |= CHANNEL_TYPE_AAL3_4;\r\nbreak;\r\ncase aal5:\r\nrd_ptr |= CHANNEL_TYPE_AAL5;\r\nwr_ptr |= CHANNEL_TYPE_AAL5;\r\nwr_mem (dev, &tx_desc->partial_crc, INITIAL_CRC);\r\nbreak;\r\n}\r\nwr_mem (dev, &tx_desc->rd_buf_type, rd_ptr);\r\nwr_mem (dev, &tx_desc->wr_buf_type, wr_ptr);\r\nwr_mem (dev, &tx_desc->cell_header, channel);\r\nspin_unlock_irqrestore (&dev->mem_lock, flags);\r\n}\r\nreturn tx_channel;\r\n}\r\nstatic int hrz_send (struct atm_vcc * atm_vcc, struct sk_buff * skb) {\r\nunsigned int spin_count;\r\nint free_buffers;\r\nhrz_dev * dev = HRZ_DEV(atm_vcc->dev);\r\nhrz_vcc * vcc = HRZ_VCC(atm_vcc);\r\nu16 channel = vcc->channel;\r\nu32 buffers_required;\r\nshort tx_channel;\r\nPRINTD (DBG_FLOW|DBG_TX, "hrz_send vc %x data %p len %u",\r\nchannel, skb->data, skb->len);\r\ndump_skb (">>>", channel, skb);\r\nif (atm_vcc->qos.txtp.traffic_class == ATM_NONE) {\r\nPRINTK (KERN_ERR, "attempt to send on RX-only VC %x", channel);\r\nhrz_kfree_skb (skb);\r\nreturn -EIO;\r\n}\r\nATM_SKB(skb)->vcc = atm_vcc;\r\nif (skb->len > atm_vcc->qos.txtp.max_sdu) {\r\nPRINTK (KERN_ERR, "sk_buff length greater than agreed max_sdu, dropping...");\r\nhrz_kfree_skb (skb);\r\nreturn -EIO;\r\n}\r\nif (!channel) {\r\nPRINTD (DBG_ERR|DBG_TX, "attempt to transmit on zero (rx_)channel");\r\nhrz_kfree_skb (skb);\r\nreturn -EIO;\r\n}\r\n#if 0\r\n{\r\nu16 status;\r\npci_read_config_word (dev->pci_dev, PCI_STATUS, &status);\r\nif (status & PCI_STATUS_REC_MASTER_ABORT) {\r\nPRINTD (DBG_BUS|DBG_ERR, "Clearing PCI Master Abort (and cleaning up)");\r\nstatus &= ~PCI_STATUS_REC_MASTER_ABORT;\r\npci_write_config_word (dev->pci_dev, PCI_STATUS, status);\r\nif (test_bit (tx_busy, &dev->flags)) {\r\nhrz_kfree_skb (dev->tx_skb);\r\ntx_release (dev);\r\n}\r\n}\r\n}\r\n#endif\r\n#ifdef DEBUG_HORIZON\r\nif (channel == 1023) {\r\nunsigned int i;\r\nunsigned short d = 0;\r\nchar * s = skb->data;\r\nif (*s++ == 'D') {\r\nfor (i = 0; i < 4; ++i)\r\nd = (d << 4) | hex_to_bin(*s++);\r\nPRINTK (KERN_INFO, "debug bitmap is now %hx", debug = d);\r\n}\r\n}\r\n#endif\r\nif (tx_hold (dev)) {\r\nhrz_kfree_skb (skb);\r\nreturn -ERESTARTSYS;\r\n}\r\nbuffers_required = (skb->len+(ATM_AAL5_TRAILER-1)) / ATM_CELL_PAYLOAD + 3;\r\nspin_count = 0;\r\nwhile ((free_buffers = rd_regw (dev, TX_FREE_BUFFER_COUNT_OFF)) < buffers_required) {\r\nPRINTD (DBG_TX, "waiting for free TX buffers, got %d of %d",\r\nfree_buffers, buffers_required);\r\nschedule();\r\nif (++spin_count > 1000) {\r\nPRINTD (DBG_TX|DBG_ERR, "spun out waiting for tx buffers, got %d of %d",\r\nfree_buffers, buffers_required);\r\ntx_release (dev);\r\nhrz_kfree_skb (skb);\r\nreturn -ERESTARTSYS;\r\n}\r\n}\r\nif (channel == dev->last_vc) {\r\nPRINTD (DBG_TX, "last vc hack: hit");\r\ntx_channel = dev->tx_last;\r\n} else {\r\nPRINTD (DBG_TX, "last vc hack: miss");\r\nfor (tx_channel = 0; tx_channel < TX_CHANS; ++tx_channel)\r\nif (dev->tx_channel_record[tx_channel] == channel) {\r\nPRINTD (DBG_TX, "vc already on channel: hit");\r\nbreak;\r\n}\r\nif (tx_channel == TX_CHANS) {\r\nPRINTD (DBG_TX, "vc already on channel: miss");\r\ntx_channel = setup_idle_tx_channel (dev, vcc);\r\nif (tx_channel < 0) {\r\nPRINTD (DBG_TX|DBG_ERR, "failed to get channel");\r\ntx_release (dev);\r\nreturn tx_channel;\r\n}\r\n}\r\nPRINTD (DBG_TX, "got channel");\r\nSELECT_TX_CHANNEL(dev, tx_channel);\r\ndev->last_vc = channel;\r\ndev->tx_last = tx_channel;\r\n}\r\nPRINTD (DBG_TX, "using channel %u", tx_channel);\r\nYELLOW_LED_OFF(dev);\r\n{\r\nunsigned int tx_len = skb->len;\r\nunsigned int tx_iovcnt = skb_shinfo(skb)->nr_frags;\r\ndev->tx_skb = skb;\r\nif (tx_iovcnt) {\r\ndev->tx_regions = tx_iovcnt;\r\ndev->tx_iovec = NULL;\r\ndev->tx_bytes = 0;\r\nPRINTD (DBG_TX|DBG_BUS, "TX start scatter-gather transfer (iovec %p, len %d)",\r\nskb->data, tx_len);\r\ntx_release (dev);\r\nhrz_kfree_skb (skb);\r\nreturn -EIO;\r\n} else {\r\ndev->tx_regions = 0;\r\ndev->tx_iovec = NULL;\r\ndev->tx_bytes = tx_len;\r\ndev->tx_addr = skb->data;\r\nPRINTD (DBG_TX|DBG_BUS, "TX start simple transfer (addr %p, len %d)",\r\nskb->data, tx_len);\r\n}\r\ntx_schedule (dev, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic void hrz_reset (const hrz_dev * dev) {\r\nu32 control_0_reg = rd_regl (dev, CONTROL_0_REG);\r\ncontrol_0_reg = control_0_reg & RESET_HORIZON;\r\nwr_regl (dev, CONTROL_0_REG, control_0_reg);\r\nwhile (control_0_reg & RESET_HORIZON)\r\ncontrol_0_reg = rd_regl (dev, CONTROL_0_REG);\r\nwr_regl (dev, CONTROL_0_REG, control_0_reg |\r\nRESET_ATM | RESET_RX | RESET_TX | RESET_HOST);\r\nudelay (1000);\r\nwr_regl (dev, CONTROL_0_REG, control_0_reg);\r\n}\r\nstatic void WRITE_IT_WAIT (const hrz_dev *dev, u32 ctrl)\r\n{\r\nwr_regl (dev, CONTROL_0_REG, ctrl);\r\nudelay (5);\r\n}\r\nstatic void CLOCK_IT (const hrz_dev *dev, u32 ctrl)\r\n{\r\nWRITE_IT_WAIT(dev, ctrl & ~SEEPROM_SK);\r\nWRITE_IT_WAIT(dev, ctrl | SEEPROM_SK);\r\n}\r\nstatic u16 read_bia(const hrz_dev *dev, u16 addr)\r\n{\r\nu32 ctrl = rd_regl (dev, CONTROL_0_REG);\r\nconst unsigned int addr_bits = 6;\r\nconst unsigned int data_bits = 16;\r\nunsigned int i;\r\nu16 res;\r\nctrl &= ~(SEEPROM_CS | SEEPROM_SK | SEEPROM_DI);\r\nWRITE_IT_WAIT(dev, ctrl);\r\nctrl |= (SEEPROM_CS | SEEPROM_DI);\r\nCLOCK_IT(dev, ctrl);\r\nctrl |= SEEPROM_DI;\r\nCLOCK_IT(dev, ctrl);\r\nctrl &= ~SEEPROM_DI;\r\nCLOCK_IT(dev, ctrl);\r\nfor (i=0; i<addr_bits; i++) {\r\nif (addr & (1 << (addr_bits-1)))\r\nctrl |= SEEPROM_DI;\r\nelse\r\nctrl &= ~SEEPROM_DI;\r\nCLOCK_IT(dev, ctrl);\r\naddr = addr << 1;\r\n}\r\nctrl &= ~SEEPROM_DI;\r\nres = 0;\r\nfor (i=0;i<data_bits;i++) {\r\nres = res >> 1;\r\nCLOCK_IT(dev, ctrl);\r\nif (rd_regl (dev, CONTROL_0_REG) & SEEPROM_DO)\r\nres |= (1 << (data_bits-1));\r\n}\r\nctrl &= ~(SEEPROM_SK | SEEPROM_CS);\r\nWRITE_IT_WAIT(dev, ctrl);\r\nreturn res;\r\n}\r\nstatic int hrz_init(hrz_dev *dev)\r\n{\r\nint onefivefive;\r\nu16 chan;\r\nint buff_count;\r\nHDW * mem;\r\ncell_buf * tx_desc;\r\ncell_buf * rx_desc;\r\nu32 ctrl;\r\nctrl = rd_regl (dev, CONTROL_0_REG);\r\nPRINTD (DBG_INFO, "ctrl0reg is %#x", ctrl);\r\nonefivefive = ctrl & ATM_LAYER_STATUS;\r\nif (onefivefive)\r\nprintk (DEV_LABEL ": Horizon Ultra (at 155.52 MBps)");\r\nelse\r\nprintk (DEV_LABEL ": Horizon (at 25 MBps)");\r\nprintk (":");\r\nprintk (" reset");\r\nhrz_reset (dev);\r\nprintk (" clearing memory");\r\nfor (mem = (HDW *) memmap; mem < (HDW *) (memmap + 1); ++mem)\r\nwr_mem (dev, mem, 0);\r\nprintk (" tx channels");\r\nfor (chan = 0; chan < TX_CHANS; ++chan) {\r\ntx_ch_desc * tx_desc = &memmap->tx_descs[chan];\r\ncell_buf * buf = &memmap->inittxbufs[chan];\r\nwr_mem (dev, &tx_desc->rd_buf_type, BUF_PTR(buf));\r\nwr_mem (dev, &tx_desc->wr_buf_type, BUF_PTR(buf));\r\nwr_mem (dev, &buf->next, BUFF_STATUS_EMPTY);\r\n}\r\nprintk (" tx buffers");\r\ntx_desc = memmap->bufn3;\r\nwr_mem (dev, &memmap->txfreebufstart.next, BUF_PTR(tx_desc) | BUFF_STATUS_EMPTY);\r\nfor (buff_count = 0; buff_count < BUFN3_SIZE-1; buff_count++) {\r\nwr_mem (dev, &tx_desc->next, BUF_PTR(tx_desc+1) | BUFF_STATUS_EMPTY);\r\ntx_desc++;\r\n}\r\nwr_mem (dev, &tx_desc->next, BUF_PTR(&memmap->txfreebufend) | BUFF_STATUS_EMPTY);\r\nwr_regw (dev, TX_FREE_BUFFER_COUNT_OFF, BUFN3_SIZE);\r\nprintk (" rx channels");\r\nfor (chan = 0; chan < RX_CHANS; ++chan) {\r\nrx_ch_desc * rx_desc = &memmap->rx_descs[chan];\r\nwr_mem (dev, &rx_desc->wr_buf_type, CHANNEL_TYPE_AAL5 | RX_CHANNEL_DISABLED);\r\n}\r\nprintk (" rx buffers");\r\nrx_desc = memmap->bufn4;\r\nwr_mem (dev, &memmap->rxfreebufstart.next, BUF_PTR(rx_desc) | BUFF_STATUS_EMPTY);\r\nfor (buff_count = 0; buff_count < BUFN4_SIZE-1; buff_count++) {\r\nwr_mem (dev, &rx_desc->next, BUF_PTR(rx_desc+1) | BUFF_STATUS_EMPTY);\r\nrx_desc++;\r\n}\r\nwr_mem (dev, &rx_desc->next, BUF_PTR(&memmap->rxfreebufend) | BUFF_STATUS_EMPTY);\r\nwr_regw (dev, RX_FREE_BUFFER_COUNT_OFF, BUFN4_SIZE);\r\nwr_regw (dev, TX_CONFIG_OFF,\r\nABR_ROUND_ROBIN | TX_NORMAL_OPERATION | DRVR_DRVRBAR_ENABLE);\r\nwr_regw (dev, RX_CONFIG_OFF,\r\nDISCARD_UNUSED_VPI_VCI_BITS_SET | NON_USER_CELLS_IN_ONE_CHANNEL | vpi_bits);\r\nwr_regw (dev, RX_LINE_CONFIG_OFF,\r\nLOCK_DETECT_ENABLE | FREQUENCY_DETECT_ENABLE | GXTALOUT_SELECT_DIV4);\r\nwr_regw (dev, MAX_AAL5_CELL_COUNT_OFF,\r\nDIV_ROUND_UP(max_rx_size + ATM_AAL5_TRAILER, ATM_CELL_PAYLOAD));\r\nwr_regw (dev, RX_CONFIG_OFF, rd_regw (dev, RX_CONFIG_OFF) | RX_ENABLE);\r\nprintk (" control");\r\nctrl |= GREEN_LED_OE | YELLOW_LED_OE | GREEN_LED | YELLOW_LED;\r\nwr_regl (dev, CONTROL_0_REG, ctrl);\r\nif (onefivefive) {\r\nctrl |= ATM_LAYER_SELECT;\r\nwr_regl (dev, CONTROL_0_REG, ctrl);\r\nif (rd_framer (dev, 0) & 0x00f0) {\r\nprintk (" SUNI");\r\nwr_framer (dev, 0x00, 0x0080);\r\nwr_framer (dev, 0x00, 0x0000);\r\nwr_framer (dev, 0x63, rd_framer (dev, 0x63) | 0x0002);\r\nwr_framer (dev, 0x05, rd_framer (dev, 0x05) | 0x0001);\r\n} else {\r\nprintk (" SAMBA");\r\nwr_framer (dev, 0, rd_framer (dev, 0) | 0x0001);\r\nwr_framer (dev, 0, rd_framer (dev, 0) &~ 0x0001);\r\nwr_framer (dev, 0, 0x0002);\r\nwr_framer (dev, 2, 0x0B80);\r\n}\r\n} else {\r\nctrl &= ~ATM_LAYER_SELECT;\r\n}\r\nprintk (" LEDs");\r\nGREEN_LED_ON(dev);\r\nYELLOW_LED_ON(dev);\r\nprintk (" ESI=");\r\n{\r\nu16 b = 0;\r\nint i;\r\nu8 * esi = dev->atm_dev->esi;\r\nfor (i=0; i < ESI_LEN; ++i) {\r\nif (i % 2 == 0)\r\nb = read_bia (dev, i/2 + 2);\r\nelse\r\nb = b >> 8;\r\nesi[i] = b & 0xFF;\r\nprintk ("%02x", esi[i]);\r\n}\r\n}\r\nwr_regl (dev, INT_ENABLE_REG_OFF, INTERESTING_INTERRUPTS);\r\nprintk (" IRQ on");\r\nprintk (".\n");\r\nreturn onefivefive;\r\n}\r\nstatic int check_max_sdu (hrz_aal aal, struct atm_trafprm * tp, unsigned int max_frame_size) {\r\nPRINTD (DBG_FLOW|DBG_QOS, "check_max_sdu");\r\nswitch (aal) {\r\ncase aal0:\r\nif (!(tp->max_sdu)) {\r\nPRINTD (DBG_QOS, "defaulting max_sdu");\r\ntp->max_sdu = ATM_AAL0_SDU;\r\n} else if (tp->max_sdu != ATM_AAL0_SDU) {\r\nPRINTD (DBG_QOS|DBG_ERR, "rejecting max_sdu");\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase aal34:\r\nif (tp->max_sdu == 0 || tp->max_sdu > ATM_MAX_AAL34_PDU) {\r\nPRINTD (DBG_QOS, "%sing max_sdu", tp->max_sdu ? "capp" : "default");\r\ntp->max_sdu = ATM_MAX_AAL34_PDU;\r\n}\r\nbreak;\r\ncase aal5:\r\nif (tp->max_sdu == 0 || tp->max_sdu > max_frame_size) {\r\nPRINTD (DBG_QOS, "%sing max_sdu", tp->max_sdu ? "capp" : "default");\r\ntp->max_sdu = max_frame_size;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int atm_pcr_check (struct atm_trafprm * tp, unsigned int pcr) {\r\nif (tp->min_pcr == ATM_MAX_PCR)\r\nPRINTD (DBG_QOS, "luser gave min_pcr = ATM_MAX_PCR");\r\nelse if (tp->min_pcr < 0)\r\nPRINTD (DBG_QOS, "luser gave negative min_pcr");\r\nelse if (tp->min_pcr && tp->min_pcr > pcr)\r\nPRINTD (DBG_QOS, "pcr less than min_pcr");\r\nelse\r\nif ((0) && tp->max_pcr == ATM_MAX_PCR)\r\nPRINTD (DBG_QOS, "luser gave max_pcr = ATM_MAX_PCR");\r\nelse if ((tp->max_pcr != ATM_MAX_PCR) && tp->max_pcr < 0)\r\nPRINTD (DBG_QOS, "luser gave negative max_pcr");\r\nelse if (tp->max_pcr && tp->max_pcr != ATM_MAX_PCR && tp->max_pcr < pcr)\r\nPRINTD (DBG_QOS, "pcr greater than max_pcr");\r\nelse {\r\nPRINTD (DBG_QOS, "xBR(pcr) OK");\r\nreturn 0;\r\n}\r\nPRINTD (DBG_QOS, "pcr=%u, tp: min_pcr=%d, pcr=%d, max_pcr=%d",\r\npcr, tp->min_pcr, tp->pcr, tp->max_pcr);\r\nreturn -EINVAL;\r\n}\r\nstatic int hrz_open (struct atm_vcc *atm_vcc)\r\n{\r\nint error;\r\nu16 channel;\r\nstruct atm_qos * qos;\r\nstruct atm_trafprm * txtp;\r\nstruct atm_trafprm * rxtp;\r\nhrz_dev * dev = HRZ_DEV(atm_vcc->dev);\r\nhrz_vcc vcc;\r\nhrz_vcc * vccp;\r\nshort vpi = atm_vcc->vpi;\r\nint vci = atm_vcc->vci;\r\nPRINTD (DBG_FLOW|DBG_VCC, "hrz_open %x %x", vpi, vci);\r\n#ifdef ATM_VPI_UNSPEC\r\nif (vpi == ATM_VPI_UNSPEC || vci == ATM_VCI_UNSPEC) {\r\nPRINTK (KERN_WARNING, "rejecting open with unspecified VPI/VCI (deprecated)");\r\nreturn -EINVAL;\r\n}\r\n#endif\r\nerror = vpivci_to_channel (&channel, vpi, vci);\r\nif (error) {\r\nPRINTD (DBG_WARN|DBG_VCC, "VPI/VCI out of range: %hd/%d", vpi, vci);\r\nreturn error;\r\n}\r\nvcc.channel = channel;\r\nvcc.tx_rate = 0x0;\r\nqos = &atm_vcc->qos;\r\nswitch (qos->aal) {\r\ncase ATM_AAL0:\r\nPRINTD (DBG_QOS|DBG_VCC, "AAL0");\r\nvcc.aal = aal0;\r\nbreak;\r\ncase ATM_AAL34:\r\nPRINTD (DBG_QOS|DBG_VCC, "AAL3/4");\r\nvcc.aal = aal34;\r\nbreak;\r\ncase ATM_AAL5:\r\nPRINTD (DBG_QOS|DBG_VCC, "AAL5");\r\nvcc.aal = aal5;\r\nbreak;\r\ndefault:\r\nPRINTD (DBG_QOS|DBG_VCC, "Bad AAL!");\r\nreturn -EINVAL;\r\n}\r\nPRINTD (DBG_QOS, "TX:");\r\ntxtp = &qos->txtp;\r\nvcc.tx_rate = 0;\r\nvcc.tx_xbr_bits = IDLE_RATE_TYPE;\r\nvcc.tx_pcr_bits = CLOCK_DISABLE;\r\n#if 0\r\nvcc.tx_scr_bits = CLOCK_DISABLE;\r\nvcc.tx_bucket_bits = 0;\r\n#endif\r\nif (txtp->traffic_class != ATM_NONE) {\r\nerror = check_max_sdu (vcc.aal, txtp, max_tx_size);\r\nif (error) {\r\nPRINTD (DBG_QOS, "TX max_sdu check failed");\r\nreturn error;\r\n}\r\nswitch (txtp->traffic_class) {\r\ncase ATM_UBR: {\r\nvcc.tx_rate = 0;\r\nmake_rate (dev, 1<<30, round_nearest, &vcc.tx_pcr_bits, NULL);\r\nvcc.tx_xbr_bits = ABR_RATE_TYPE;\r\nbreak;\r\n}\r\n#if 0\r\ncase ATM_ABR: {\r\nvcc.tx_rate = 0;\r\nmake_rate (dev, 1<<30, round_nearest, &vcc.tx_pcr_bits, 0);\r\nvcc.tx_xbr_bits = ABR_RATE_TYPE;\r\nbreak;\r\n}\r\n#endif\r\ncase ATM_CBR: {\r\nint pcr = atm_pcr_goal (txtp);\r\nrounding r;\r\nif (!pcr) {\r\nr = round_down;\r\nPRINTD (DBG_QOS, "snatching all remaining TX bandwidth");\r\npcr = dev->tx_avail;\r\n} else if (pcr < 0) {\r\nr = round_down;\r\npcr = -pcr;\r\n} else {\r\nr = round_up;\r\n}\r\nerror = make_rate_with_tolerance (dev, pcr, r, 10,\r\n&vcc.tx_pcr_bits, &vcc.tx_rate);\r\nif (error) {\r\nPRINTD (DBG_QOS, "could not make rate from TX PCR");\r\nreturn error;\r\n}\r\nerror = atm_pcr_check (txtp, vcc.tx_rate);\r\nif (error) {\r\nPRINTD (DBG_QOS, "TX PCR failed consistency check");\r\nreturn error;\r\n}\r\nvcc.tx_xbr_bits = CBR_RATE_TYPE;\r\nbreak;\r\n}\r\n#if 0\r\ncase ATM_VBR: {\r\nint pcr = atm_pcr_goal (txtp);\r\nint scr = pcr/2;\r\nunsigned int mbs = 60;\r\nrounding pr;\r\nrounding sr;\r\nunsigned int bucket;\r\nif (!pcr) {\r\npr = round_nearest;\r\npcr = 1<<30;\r\n} else if (pcr < 0) {\r\npr = round_down;\r\npcr = -pcr;\r\n} else {\r\npr = round_up;\r\n}\r\nerror = make_rate_with_tolerance (dev, pcr, pr, 10,\r\n&vcc.tx_pcr_bits, 0);\r\nif (!scr) {\r\nsr = round_down;\r\nPRINTD (DBG_QOS, "snatching all remaining TX bandwidth");\r\nscr = dev->tx_avail;\r\n} else if (scr < 0) {\r\nsr = round_down;\r\nscr = -scr;\r\n} else {\r\nsr = round_up;\r\n}\r\nerror = make_rate_with_tolerance (dev, scr, sr, 10,\r\n&vcc.tx_scr_bits, &vcc.tx_rate);\r\nif (error) {\r\nPRINTD (DBG_QOS, "could not make rate from TX SCR");\r\nreturn error;\r\n}\r\nif (error) {\r\nPRINTD (DBG_QOS, "TX SCR failed consistency check");\r\nreturn error;\r\n}\r\nbucket = mbs*(pcr-scr)/pcr;\r\nif (bucket*pcr != mbs*(pcr-scr))\r\nbucket += 1;\r\nif (bucket > BUCKET_MAX_SIZE) {\r\nPRINTD (DBG_QOS, "shrinking bucket from %u to %u",\r\nbucket, BUCKET_MAX_SIZE);\r\nbucket = BUCKET_MAX_SIZE;\r\n}\r\nvcc.tx_xbr_bits = VBR_RATE_TYPE;\r\nvcc.tx_bucket_bits = bucket;\r\nbreak;\r\n}\r\n#endif\r\ndefault: {\r\nPRINTD (DBG_QOS, "unsupported TX traffic class");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nPRINTD (DBG_QOS, "RX:");\r\nrxtp = &qos->rxtp;\r\nvcc.rx_rate = 0;\r\nif (rxtp->traffic_class != ATM_NONE) {\r\nerror = check_max_sdu (vcc.aal, rxtp, max_rx_size);\r\nif (error) {\r\nPRINTD (DBG_QOS, "RX max_sdu check failed");\r\nreturn error;\r\n}\r\nswitch (rxtp->traffic_class) {\r\ncase ATM_UBR: {\r\nbreak;\r\n}\r\n#if 0\r\ncase ATM_ABR: {\r\nvcc.rx_rate = 0;\r\nbreak;\r\n}\r\n#endif\r\ncase ATM_CBR: {\r\nint pcr = atm_pcr_goal (rxtp);\r\nif (!pcr) {\r\nPRINTD (DBG_QOS, "snatching all remaining RX bandwidth");\r\npcr = dev->rx_avail;\r\n} else if (pcr < 0) {\r\npcr = -pcr;\r\n}\r\nvcc.rx_rate = pcr;\r\nerror = atm_pcr_check (rxtp, vcc.rx_rate);\r\nif (error) {\r\nPRINTD (DBG_QOS, "RX PCR failed consistency check");\r\nreturn error;\r\n}\r\nbreak;\r\n}\r\n#if 0\r\ncase ATM_VBR: {\r\nint scr = 1<<16;\r\nif (!scr) {\r\nPRINTD (DBG_QOS, "snatching all remaining RX bandwidth");\r\nscr = dev->rx_avail;\r\n} else if (scr < 0) {\r\nscr = -scr;\r\n}\r\nvcc.rx_rate = scr;\r\nif (error) {\r\nPRINTD (DBG_QOS, "RX SCR failed consistency check");\r\nreturn error;\r\n}\r\nbreak;\r\n}\r\n#endif\r\ndefault: {\r\nPRINTD (DBG_QOS, "unsupported RX traffic class");\r\nreturn -EINVAL;\r\n}\r\n}\r\n}\r\nif (vcc.aal != aal5) {\r\nPRINTD (DBG_QOS, "AAL not supported");\r\nreturn -EINVAL;\r\n}\r\nvccp = kmalloc (sizeof(hrz_vcc), GFP_KERNEL);\r\nif (!vccp) {\r\nPRINTK (KERN_ERR, "out of memory!");\r\nreturn -ENOMEM;\r\n}\r\n*vccp = vcc;\r\nerror = 0;\r\nspin_lock (&dev->rate_lock);\r\nif (vcc.tx_rate > dev->tx_avail) {\r\nPRINTD (DBG_QOS, "not enough TX PCR left");\r\nerror = -EAGAIN;\r\n}\r\nif (vcc.rx_rate > dev->rx_avail) {\r\nPRINTD (DBG_QOS, "not enough RX PCR left");\r\nerror = -EAGAIN;\r\n}\r\nif (!error) {\r\ndev->tx_avail -= vcc.tx_rate;\r\ndev->rx_avail -= vcc.rx_rate;\r\nPRINTD (DBG_QOS|DBG_VCC, "reserving %u TX PCR and %u RX PCR",\r\nvcc.tx_rate, vcc.rx_rate);\r\n}\r\nspin_unlock (&dev->rate_lock);\r\nif (error) {\r\nPRINTD (DBG_QOS|DBG_VCC, "insufficient cell rate resources");\r\nkfree (vccp);\r\nreturn error;\r\n}\r\nset_bit(ATM_VF_ADDR,&atm_vcc->flags);\r\nif (rxtp->traffic_class != ATM_NONE) {\r\nif (dev->rxer[channel]) {\r\nPRINTD (DBG_ERR|DBG_VCC, "VC already open for RX");\r\nerror = -EBUSY;\r\n}\r\nif (!error)\r\nerror = hrz_open_rx (dev, channel);\r\nif (error) {\r\nkfree (vccp);\r\nreturn error;\r\n}\r\ndev->rxer[channel] = atm_vcc;\r\n}\r\natm_vcc->dev_data = (void *) vccp;\r\nset_bit(ATM_VF_READY,&atm_vcc->flags);\r\nreturn 0;\r\n}\r\nstatic void hrz_close (struct atm_vcc * atm_vcc) {\r\nhrz_dev * dev = HRZ_DEV(atm_vcc->dev);\r\nhrz_vcc * vcc = HRZ_VCC(atm_vcc);\r\nu16 channel = vcc->channel;\r\nPRINTD (DBG_VCC|DBG_FLOW, "hrz_close");\r\nclear_bit(ATM_VF_READY,&atm_vcc->flags);\r\nif (atm_vcc->qos.txtp.traffic_class != ATM_NONE) {\r\nunsigned int i;\r\nwhile (tx_hold (dev))\r\n;\r\nfor (i = 0; i < TX_CHANS; ++i)\r\nif (dev->tx_channel_record[i] == channel) {\r\ndev->tx_channel_record[i] = -1;\r\nbreak;\r\n}\r\nif (dev->last_vc == channel)\r\ndev->tx_last = -1;\r\ntx_release (dev);\r\n}\r\nif (atm_vcc->qos.rxtp.traffic_class != ATM_NONE) {\r\nhrz_close_rx (dev, channel);\r\nif (atm_vcc != dev->rxer[channel])\r\nPRINTK (KERN_ERR, "%s atm_vcc=%p rxer[channel]=%p",\r\n"arghhh! we're going to die!",\r\natm_vcc, dev->rxer[channel]);\r\ndev->rxer[channel] = NULL;\r\n}\r\nspin_lock (&dev->rate_lock);\r\nPRINTD (DBG_QOS|DBG_VCC, "releasing %u TX PCR and %u RX PCR",\r\nvcc->tx_rate, vcc->rx_rate);\r\ndev->tx_avail += vcc->tx_rate;\r\ndev->rx_avail += vcc->rx_rate;\r\nspin_unlock (&dev->rate_lock);\r\nkfree (vcc);\r\nclear_bit(ATM_VF_ADDR,&atm_vcc->flags);\r\n}\r\nstatic int hrz_proc_read (struct atm_dev * atm_dev, loff_t * pos, char * page) {\r\nhrz_dev * dev = HRZ_DEV(atm_dev);\r\nint left = *pos;\r\nPRINTD (DBG_FLOW, "hrz_proc_read");\r\n#if 0\r\nif (!left--) {\r\nunsigned int count = sprintf (page, "vbr buckets:");\r\nunsigned int i;\r\nfor (i = 0; i < TX_CHANS; ++i)\r\ncount += sprintf (page, " %u/%u",\r\nquery_tx_channel_config (dev, i, BUCKET_FULLNESS_ACCESS),\r\nquery_tx_channel_config (dev, i, BUCKET_CAPACITY_ACCESS));\r\ncount += sprintf (page+count, ".\n");\r\nreturn count;\r\n}\r\n#endif\r\nif (!left--)\r\nreturn sprintf (page,\r\n"cells: TX %lu, RX %lu, HEC errors %lu, unassigned %lu.\n",\r\ndev->tx_cell_count, dev->rx_cell_count,\r\ndev->hec_error_count, dev->unassigned_cell_count);\r\nif (!left--)\r\nreturn sprintf (page,\r\n"free cell buffers: TX %hu, RX %hu+%hu.\n",\r\nrd_regw (dev, TX_FREE_BUFFER_COUNT_OFF),\r\nrd_regw (dev, RX_FREE_BUFFER_COUNT_OFF),\r\ndev->noof_spare_buffers);\r\nif (!left--)\r\nreturn sprintf (page,\r\n"cps remaining: TX %u, RX %u\n",\r\ndev->tx_avail, dev->rx_avail);\r\nreturn 0;\r\n}\r\nstatic int hrz_probe(struct pci_dev *pci_dev,\r\nconst struct pci_device_id *pci_ent)\r\n{\r\nhrz_dev * dev;\r\nint err = 0;\r\nu32 iobase = pci_resource_start (pci_dev, 0);\r\nu32 * membase = bus_to_virt (pci_resource_start (pci_dev, 1));\r\nunsigned int irq;\r\nunsigned char lat;\r\nPRINTD (DBG_FLOW, "hrz_probe");\r\nif (pci_enable_device(pci_dev))\r\nreturn -EINVAL;\r\nif (!request_region(iobase, HRZ_IO_EXTENT, DEV_LABEL)) {\r\nerr = -EINVAL;\r\ngoto out_disable;\r\n}\r\ndev = kzalloc(sizeof(hrz_dev), GFP_KERNEL);\r\nif (!dev) {\r\nPRINTD(DBG_ERR, "out of memory");\r\nerr = -ENOMEM;\r\ngoto out_release;\r\n}\r\npci_set_drvdata(pci_dev, dev);\r\nirq = pci_dev->irq;\r\nif (request_irq(irq,\r\ninterrupt_handler,\r\nIRQF_SHARED,\r\nDEV_LABEL,\r\ndev)) {\r\nPRINTD(DBG_WARN, "request IRQ failed!");\r\nerr = -EINVAL;\r\ngoto out_free;\r\n}\r\nPRINTD(DBG_INFO, "found Madge ATM adapter (hrz) at: IO %x, IRQ %u, MEM %p",\r\niobase, irq, membase);\r\ndev->atm_dev = atm_dev_register(DEV_LABEL, &pci_dev->dev, &hrz_ops, -1,\r\nNULL);\r\nif (!(dev->atm_dev)) {\r\nPRINTD(DBG_ERR, "failed to register Madge ATM adapter");\r\nerr = -EINVAL;\r\ngoto out_free_irq;\r\n}\r\nPRINTD(DBG_INFO, "registered Madge ATM adapter (no. %d) (%p) at %p",\r\ndev->atm_dev->number, dev, dev->atm_dev);\r\ndev->atm_dev->dev_data = (void *) dev;\r\ndev->pci_dev = pci_dev;\r\npci_set_master(pci_dev);\r\npci_read_config_byte(pci_dev, PCI_LATENCY_TIMER, &lat);\r\nif (pci_lat) {\r\nPRINTD(DBG_INFO, "%s PCI latency timer from %hu to %hu",\r\n"changing", lat, pci_lat);\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, pci_lat);\r\n} else if (lat < MIN_PCI_LATENCY) {\r\nPRINTK(KERN_INFO, "%s PCI latency timer from %hu to %hu",\r\n"increasing", lat, MIN_PCI_LATENCY);\r\npci_write_config_byte(pci_dev, PCI_LATENCY_TIMER, MIN_PCI_LATENCY);\r\n}\r\ndev->iobase = iobase;\r\ndev->irq = irq;\r\ndev->membase = membase;\r\ndev->rx_q_entry = dev->rx_q_reset = &memmap->rx_q_entries[0];\r\ndev->rx_q_wrap = &memmap->rx_q_entries[RX_CHANS-1];\r\ndev->last_vc = -1;\r\ndev->tx_last = -1;\r\ndev->tx_idle = 0;\r\ndev->tx_regions = 0;\r\ndev->tx_bytes = 0;\r\ndev->tx_skb = NULL;\r\ndev->tx_iovec = NULL;\r\ndev->tx_cell_count = 0;\r\ndev->rx_cell_count = 0;\r\ndev->hec_error_count = 0;\r\ndev->unassigned_cell_count = 0;\r\ndev->noof_spare_buffers = 0;\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < TX_CHANS; ++i)\r\ndev->tx_channel_record[i] = -1;\r\n}\r\ndev->flags = 0;\r\nif (hrz_init(dev)) {\r\ndev->tx_avail = ATM_OC3_PCR;\r\ndev->rx_avail = ATM_OC3_PCR;\r\nset_bit(ultra, &dev->flags);\r\n} else {\r\ndev->tx_avail = ((25600000/8)*26)/(27*53);\r\ndev->rx_avail = ((25600000/8)*26)/(27*53);\r\nPRINTD(DBG_WARN, "Buggy ASIC: no TX bus-mastering.");\r\n}\r\nspin_lock_init(&dev->rate_lock);\r\nspin_lock_init(&dev->mem_lock);\r\ninit_waitqueue_head(&dev->tx_queue);\r\ndev->atm_dev->ci_range.vpi_bits = vpi_bits;\r\ndev->atm_dev->ci_range.vci_bits = 10-vpi_bits;\r\nsetup_timer(&dev->housekeeping, do_housekeeping, (unsigned long) dev);\r\nmod_timer(&dev->housekeeping, jiffies);\r\nout:\r\nreturn err;\r\nout_free_irq:\r\nfree_irq(dev->irq, dev);\r\nout_free:\r\nkfree(dev);\r\nout_release:\r\nrelease_region(iobase, HRZ_IO_EXTENT);\r\nout_disable:\r\npci_disable_device(pci_dev);\r\ngoto out;\r\n}\r\nstatic void hrz_remove_one(struct pci_dev *pci_dev)\r\n{\r\nhrz_dev *dev;\r\ndev = pci_get_drvdata(pci_dev);\r\nPRINTD(DBG_INFO, "closing %p (atm_dev = %p)", dev, dev->atm_dev);\r\ndel_timer_sync(&dev->housekeeping);\r\nhrz_reset(dev);\r\natm_dev_deregister(dev->atm_dev);\r\nfree_irq(dev->irq, dev);\r\nrelease_region(dev->iobase, HRZ_IO_EXTENT);\r\nkfree(dev);\r\npci_disable_device(pci_dev);\r\n}\r\nstatic void __init hrz_check_args (void) {\r\n#ifdef DEBUG_HORIZON\r\nPRINTK (KERN_NOTICE, "debug bitmap is %hx", debug &= DBG_MASK);\r\n#else\r\nif (debug)\r\nPRINTK (KERN_NOTICE, "no debug support in this image");\r\n#endif\r\nif (vpi_bits > HRZ_MAX_VPI)\r\nPRINTK (KERN_ERR, "vpi_bits has been limited to %hu",\r\nvpi_bits = HRZ_MAX_VPI);\r\nif (max_tx_size < 0 || max_tx_size > TX_AAL5_LIMIT)\r\nPRINTK (KERN_NOTICE, "max_tx_size has been limited to %hu",\r\nmax_tx_size = TX_AAL5_LIMIT);\r\nif (max_rx_size < 0 || max_rx_size > RX_AAL5_LIMIT)\r\nPRINTK (KERN_NOTICE, "max_rx_size has been limited to %hu",\r\nmax_rx_size = RX_AAL5_LIMIT);\r\nreturn;\r\n}\r\nstatic int __init hrz_module_init (void) {\r\nBUILD_BUG_ON(sizeof(struct MEMMAP) != 128*1024/4);\r\nshow_version();\r\nhrz_check_args();\r\nreturn pci_register_driver(&hrz_driver);\r\n}\r\nstatic void __exit hrz_module_exit (void) {\r\nPRINTD (DBG_FLOW, "cleanup_module");\r\npci_unregister_driver(&hrz_driver);\r\n}
