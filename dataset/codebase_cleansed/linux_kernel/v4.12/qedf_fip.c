void qedf_fcoe_send_vlan_req(struct qedf_ctx *qedf)\r\n{\r\nstruct sk_buff *skb;\r\nchar *eth_fr;\r\nint fr_len;\r\nstruct fip_vlan *vlan;\r\n#define MY_FIP_ALL_FCF_MACS ((__u8[6]) { 1, 0x10, 0x18, 1, 0, 2 })\r\nstatic u8 my_fcoe_all_fcfs[ETH_ALEN] = MY_FIP_ALL_FCF_MACS;\r\nskb = dev_alloc_skb(sizeof(struct fip_vlan));\r\nif (!skb)\r\nreturn;\r\nfr_len = sizeof(*vlan);\r\neth_fr = (char *)skb->data;\r\nvlan = (struct fip_vlan *)eth_fr;\r\nmemset(vlan, 0, sizeof(*vlan));\r\nether_addr_copy(vlan->eth.h_source, qedf->mac);\r\nether_addr_copy(vlan->eth.h_dest, my_fcoe_all_fcfs);\r\nvlan->eth.h_proto = htons(ETH_P_FIP);\r\nvlan->fip.fip_ver = FIP_VER_ENCAPS(FIP_VER);\r\nvlan->fip.fip_op = htons(FIP_OP_VLAN);\r\nvlan->fip.fip_subcode = FIP_SC_VL_REQ;\r\nvlan->fip.fip_dl_len = htons(sizeof(vlan->desc) / FIP_BPW);\r\nvlan->desc.mac.fd_desc.fip_dtype = FIP_DT_MAC;\r\nvlan->desc.mac.fd_desc.fip_dlen = sizeof(vlan->desc.mac) / FIP_BPW;\r\nether_addr_copy(vlan->desc.mac.fd_mac, qedf->mac);\r\nvlan->desc.wwnn.fd_desc.fip_dtype = FIP_DT_NAME;\r\nvlan->desc.wwnn.fd_desc.fip_dlen = sizeof(vlan->desc.wwnn) / FIP_BPW;\r\nput_unaligned_be64(qedf->lport->wwnn, &vlan->desc.wwnn.fd_wwn);\r\nskb_put(skb, sizeof(*vlan));\r\nskb->protocol = htons(ETH_P_FIP);\r\nskb_reset_mac_header(skb);\r\nskb_reset_network_header(skb);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC, "Sending FIP VLAN "\r\n"request.");\r\nif (atomic_read(&qedf->link_state) != QEDF_LINK_UP) {\r\nQEDF_WARN(&(qedf->dbg_ctx), "Cannot send vlan request "\r\n"because link is not up.\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nqed_ops->ll2->start_xmit(qedf->cdev, skb);\r\n}\r\nstatic void qedf_fcoe_process_vlan_resp(struct qedf_ctx *qedf,\r\nstruct sk_buff *skb)\r\n{\r\nstruct fip_header *fiph;\r\nstruct fip_desc *desc;\r\nu16 vid = 0;\r\nssize_t rlen;\r\nsize_t dlen;\r\nfiph = (struct fip_header *)(((void *)skb->data) + 2 * ETH_ALEN + 2);\r\nrlen = ntohs(fiph->fip_dl_len) * 4;\r\ndesc = (struct fip_desc *)(fiph + 1);\r\nwhile (rlen > 0) {\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nswitch (desc->fip_dtype) {\r\ncase FIP_DT_VLAN:\r\nvid = ntohs(((struct fip_vlan_desc *)desc)->fd_vlan);\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC, "VLAN response, "\r\n"vid=0x%x.\n", vid);\r\nif (vid > 0 && qedf->vlan_id != vid) {\r\nqedf_set_vlan_id(qedf, vid);\r\nif (!completion_done(&qedf->fipvlan_compl))\r\ncomplete(&qedf->fipvlan_compl);\r\n}\r\n}\r\nvoid qedf_fip_send(struct fcoe_ctlr *fip, struct sk_buff *skb)\r\n{\r\nstruct qedf_ctx *qedf = container_of(fip, struct qedf_ctx, ctlr);\r\nstruct ethhdr *eth_hdr;\r\nstruct vlan_ethhdr *vlan_hdr;\r\nstruct fip_header *fiph;\r\nu16 op, vlan_tci = 0;\r\nu8 sub;\r\nif (!test_bit(QEDF_LL2_STARTED, &qedf->flags)) {\r\nQEDF_WARN(&(qedf->dbg_ctx), "LL2 not started\n");\r\nkfree_skb(skb);\r\nreturn;\r\n}\r\nfiph = (struct fip_header *) ((void *)skb->data + 2 * ETH_ALEN + 2);\r\neth_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nop = ntohs(fiph->fip_op);\r\nsub = fiph->fip_subcode;\r\nif (!qedf->vlan_hw_insert) {\r\nvlan_hdr = (struct vlan_ethhdr *)skb_push(skb, sizeof(*vlan_hdr)\r\n- sizeof(*eth_hdr));\r\nmemcpy(vlan_hdr, eth_hdr, 2 * ETH_ALEN);\r\nvlan_hdr->h_vlan_proto = htons(ETH_P_8021Q);\r\nvlan_hdr->h_vlan_encapsulated_proto = eth_hdr->h_proto;\r\nvlan_hdr->h_vlan_TCI = vlan_tci = htons(qedf->vlan_id);\r\n}\r\neth_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2, "FIP frame send: "\r\n"dest=%pM op=%x sub=%x vlan=%04x.", eth_hdr->h_dest, op, sub,\r\nntohs(vlan_tci));\r\nif (qedf_dump_frames)\r\nprint_hex_dump(KERN_WARNING, "fip ", DUMP_PREFIX_OFFSET, 16, 1,\r\nskb->data, skb->len, false);\r\nqed_ops->ll2->start_xmit(qedf->cdev, skb);\r\n}\r\nvoid qedf_fip_recv(struct qedf_ctx *qedf, struct sk_buff *skb)\r\n{\r\nstruct ethhdr *eth_hdr;\r\nstruct fip_header *fiph;\r\nstruct fip_desc *desc;\r\nstruct fip_mac_desc *mp;\r\nstruct fip_wwn_desc *wp;\r\nstruct fip_vn_desc *vp;\r\nsize_t rlen, dlen;\r\nuint32_t cvl_port_id;\r\n__u8 cvl_mac[ETH_ALEN];\r\nu16 op;\r\nu8 sub;\r\neth_hdr = (struct ethhdr *)skb_mac_header(skb);\r\nfiph = (struct fip_header *) ((void *)skb->data + 2 * ETH_ALEN + 2);\r\nop = ntohs(fiph->fip_op);\r\nsub = fiph->fip_subcode;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2, "FIP frame received: "\r\n"skb=%p fiph=%p source=%pM op=%x sub=%x", skb, fiph,\r\neth_hdr->h_source, op, sub);\r\nif (qedf_dump_frames)\r\nprint_hex_dump(KERN_WARNING, "fip ", DUMP_PREFIX_OFFSET, 16, 1,\r\nskb->data, skb->len, false);\r\nif (op == FIP_OP_VLAN && sub == FIP_SC_VL_NOTE) {\r\nqedf_fcoe_process_vlan_resp(qedf, skb);\r\nqedf->vlan_hw_insert = 0;\r\nkfree_skb(skb);\r\n} else if (op == FIP_OP_CTRL && sub == FIP_SC_CLR_VLINK) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC, "Clear virtual "\r\n"link received.\n");\r\nif (qedf->ctlr.sel_fcf == NULL) {\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC,\r\n"Dropping CVL since FCF has not been selected "\r\n"yet.");\r\nreturn;\r\n}\r\ncvl_port_id = 0;\r\nmemset(cvl_mac, 0, ETH_ALEN);\r\nrlen = ntohs(fiph->fip_dl_len) * FIP_BPW;\r\ndesc = (struct fip_desc *)(fiph + 1);\r\nwhile (rlen >= sizeof(*desc)) {\r\ndlen = desc->fip_dlen * FIP_BPW;\r\nswitch (desc->fip_dtype) {\r\ncase FIP_DT_MAC:\r\nmp = (struct fip_mac_desc *)desc;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2,\r\n"fd_mac=%pM\n", mp->fd_mac);\r\nether_addr_copy(cvl_mac, mp->fd_mac);\r\nbreak;\r\ncase FIP_DT_NAME:\r\nwp = (struct fip_wwn_desc *)desc;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2,\r\n"fc_wwpn=%016llx.\n",\r\nget_unaligned_be64(&wp->fd_wwn));\r\nbreak;\r\ncase FIP_DT_VN_ID:\r\nvp = (struct fip_vn_desc *)desc;\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2,\r\n"fd_fc_id=%x.\n", ntoh24(vp->fd_fc_id));\r\ncvl_port_id = ntoh24(vp->fd_fc_id);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndesc = (struct fip_desc *)((char *)desc + dlen);\r\nrlen -= dlen;\r\n}\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_LL2,\r\n"cvl_port_id=%06x cvl_mac=%pM.\n", cvl_port_id,\r\ncvl_mac);\r\nif (cvl_port_id == qedf->lport->port_id &&\r\nether_addr_equal(cvl_mac,\r\nqedf->ctlr.sel_fcf->fcf_mac)) {\r\nfcoe_ctlr_link_down(&qedf->ctlr);\r\nqedf_wait_for_upload(qedf);\r\nfcoe_ctlr_link_up(&qedf->ctlr);\r\n}\r\nkfree_skb(skb);\r\n} else {\r\n__skb_pull(skb, ETH_HLEN);\r\nfcoe_ctlr_recv(&qedf->ctlr, skb);\r\n}\r\n}\r\nvoid qedf_update_src_mac(struct fc_lport *lport, u8 *addr)\r\n{\r\nstruct qedf_ctx *qedf = lport_priv(lport);\r\nQEDF_INFO(&(qedf->dbg_ctx), QEDF_LOG_DISC,\r\n"Setting data_src_addr=%pM.\n", addr);\r\nether_addr_copy(qedf->data_src_addr, addr);\r\n}\r\nu8 *qedf_get_src_mac(struct fc_lport *lport)\r\n{\r\nu8 mac[ETH_ALEN];\r\nu8 port_id[3];\r\nstruct qedf_ctx *qedf = lport_priv(lport);\r\nif (is_zero_ether_addr(qedf->data_src_addr)) {\r\nhton24(port_id, lport->port_id);\r\nfc_fcoe_set_mac(mac, port_id);\r\nqedf->ctlr.update_mac(lport, mac);\r\n}\r\nreturn qedf->data_src_addr;\r\n}
