static int msm_get_groups_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->ngroups;\r\n}\r\nstatic const char *msm_get_group_name(struct pinctrl_dev *pctldev,\r\nunsigned group)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->groups[group].name;\r\n}\r\nstatic int msm_get_group_pins(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nconst unsigned **pins,\r\nunsigned *num_pins)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*pins = pctrl->soc->groups[group].pins;\r\n*num_pins = pctrl->soc->groups[group].npins;\r\nreturn 0;\r\n}\r\nstatic int msm_get_functions_count(struct pinctrl_dev *pctldev)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->nfunctions;\r\n}\r\nstatic const char *msm_get_function_name(struct pinctrl_dev *pctldev,\r\nunsigned function)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nreturn pctrl->soc->functions[function].name;\r\n}\r\nstatic int msm_get_function_groups(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nconst char * const **groups,\r\nunsigned * const num_groups)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\n*groups = pctrl->soc->functions[function].groups;\r\n*num_groups = pctrl->soc->functions[function].ngroups;\r\nreturn 0;\r\n}\r\nstatic int msm_pinmux_set_mux(struct pinctrl_dev *pctldev,\r\nunsigned function,\r\nunsigned group)\r\n{\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nconst struct msm_pingroup *g;\r\nunsigned long flags;\r\nu32 val, mask;\r\nint i;\r\ng = &pctrl->soc->groups[group];\r\nmask = GENMASK(g->mux_bit + order_base_2(g->nfuncs) - 1, g->mux_bit);\r\nfor (i = 0; i < g->nfuncs; i++) {\r\nif (g->funcs[i] == function)\r\nbreak;\r\n}\r\nif (WARN_ON(i == g->nfuncs))\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->ctl_reg);\r\nval &= ~mask;\r\nval |= i << g->mux_bit;\r\nwritel(val, pctrl->regs + g->ctl_reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int msm_config_reg(struct msm_pinctrl *pctrl,\r\nconst struct msm_pingroup *g,\r\nunsigned param,\r\nunsigned *mask,\r\nunsigned *bit)\r\n{\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\n*bit = g->pull_bit;\r\n*mask = 3;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\n*bit = g->drv_bit;\r\n*mask = 7;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\n*bit = g->oe_bit;\r\n*mask = 1;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned msm_regval_to_drive(u32 val)\r\n{\r\nreturn (val + 1) * 2;\r\n}\r\nstatic int msm_config_group_get(struct pinctrl_dev *pctldev,\r\nunsigned int group,\r\nunsigned long *config)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned param = pinconf_to_config_param(*config);\r\nunsigned mask;\r\nunsigned arg;\r\nunsigned bit;\r\nint ret;\r\nu32 val;\r\ng = &pctrl->soc->groups[group];\r\nret = msm_config_reg(pctrl, g, param, &mask, &bit);\r\nif (ret < 0)\r\nreturn ret;\r\nval = readl(pctrl->regs + g->ctl_reg);\r\narg = (val >> bit) & mask;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\narg = arg == MSM_NO_PULL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\narg = arg == MSM_PULL_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\narg = arg == MSM_KEEPER;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = arg == MSM_PULL_UP;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\narg = msm_regval_to_drive(arg);\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nif (!arg)\r\nreturn -EINVAL;\r\nval = readl(pctrl->regs + g->io_reg);\r\narg = !!(val & BIT(g->in_bit));\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\nif (arg)\r\nreturn -EINVAL;\r\narg = 1;\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\n*config = pinconf_to_config_packed(param, arg);\r\nreturn 0;\r\n}\r\nstatic int msm_config_group_set(struct pinctrl_dev *pctldev,\r\nunsigned group,\r\nunsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);\r\nunsigned long flags;\r\nunsigned param;\r\nunsigned mask;\r\nunsigned arg;\r\nunsigned bit;\r\nint ret;\r\nu32 val;\r\nint i;\r\ng = &pctrl->soc->groups[group];\r\nfor (i = 0; i < num_configs; i++) {\r\nparam = pinconf_to_config_param(configs[i]);\r\narg = pinconf_to_config_argument(configs[i]);\r\nret = msm_config_reg(pctrl, g, param, &mask, &bit);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (param) {\r\ncase PIN_CONFIG_BIAS_DISABLE:\r\narg = MSM_NO_PULL;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_DOWN:\r\narg = MSM_PULL_DOWN;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_BUS_HOLD:\r\narg = MSM_KEEPER;\r\nbreak;\r\ncase PIN_CONFIG_BIAS_PULL_UP:\r\narg = MSM_PULL_UP;\r\nbreak;\r\ncase PIN_CONFIG_DRIVE_STRENGTH:\r\nif (arg > 16 || arg < 2 || (arg % 2) != 0)\r\narg = -1;\r\nelse\r\narg = (arg / 2) - 1;\r\nbreak;\r\ncase PIN_CONFIG_OUTPUT:\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->io_reg);\r\nif (arg)\r\nval |= BIT(g->out_bit);\r\nelse\r\nval &= ~BIT(g->out_bit);\r\nwritel(val, pctrl->regs + g->io_reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\narg = 1;\r\nbreak;\r\ncase PIN_CONFIG_INPUT_ENABLE:\r\narg = 0;\r\nbreak;\r\ndefault:\r\ndev_err(pctrl->dev, "Unsupported config parameter: %x\n",\r\nparam);\r\nreturn -EINVAL;\r\n}\r\nif (arg & ~mask) {\r\ndev_err(pctrl->dev, "config %x: %x is invalid\n", param, arg);\r\nreturn -EINVAL;\r\n}\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->ctl_reg);\r\nval &= ~(mask << bit);\r\nval |= arg << bit;\r\nwritel(val, pctrl->regs + g->ctl_reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[offset];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->ctl_reg);\r\nval &= ~BIT(g->oe_bit);\r\nwritel(val, pctrl->regs + g->ctl_reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_direction_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[offset];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->io_reg);\r\nif (value)\r\nval |= BIT(g->out_bit);\r\nelse\r\nval &= ~BIT(g->out_bit);\r\nwritel(val, pctrl->regs + g->io_reg);\r\nval = readl(pctrl->regs + g->ctl_reg);\r\nval |= BIT(g->oe_bit);\r\nwritel(val, pctrl->regs + g->ctl_reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_get_direction(struct gpio_chip *chip, unsigned int offset)\r\n{\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\r\nconst struct msm_pingroup *g;\r\nu32 val;\r\ng = &pctrl->soc->groups[offset];\r\nval = readl(pctrl->regs + g->ctl_reg);\r\nreturn val & BIT(g->oe_bit) ? 0 : 1;\r\n}\r\nstatic int msm_gpio_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\r\nu32 val;\r\ng = &pctrl->soc->groups[offset];\r\nval = readl(pctrl->regs + g->io_reg);\r\nreturn !!(val & BIT(g->in_bit));\r\n}\r\nstatic void msm_gpio_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[offset];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->io_reg);\r\nif (value)\r\nval |= BIT(g->out_bit);\r\nelse\r\nval &= ~BIT(g->out_bit);\r\nwritel(val, pctrl->regs + g->io_reg);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic void msm_gpio_dbg_show_one(struct seq_file *s,\r\nstruct pinctrl_dev *pctldev,\r\nstruct gpio_chip *chip,\r\nunsigned offset,\r\nunsigned gpio)\r\n{\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(chip);\r\nunsigned func;\r\nint is_out;\r\nint drive;\r\nint pull;\r\nu32 ctl_reg;\r\nstatic const char * const pulls[] = {\r\n"no pull",\r\n"pull down",\r\n"keeper",\r\n"pull up"\r\n};\r\ng = &pctrl->soc->groups[offset];\r\nctl_reg = readl(pctrl->regs + g->ctl_reg);\r\nis_out = !!(ctl_reg & BIT(g->oe_bit));\r\nfunc = (ctl_reg >> g->mux_bit) & 7;\r\ndrive = (ctl_reg >> g->drv_bit) & 7;\r\npull = (ctl_reg >> g->pull_bit) & 3;\r\nseq_printf(s, " %-8s: %-3s %d", g->name, is_out ? "out" : "in", func);\r\nseq_printf(s, " %dmA", msm_regval_to_drive(drive));\r\nseq_printf(s, " %s", pulls[pull]);\r\n}\r\nstatic void msm_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nunsigned gpio = chip->base;\r\nunsigned i;\r\nfor (i = 0; i < chip->ngpio; i++, gpio++) {\r\nmsm_gpio_dbg_show_one(s, NULL, chip, i, gpio);\r\nseq_puts(s, "\n");\r\n}\r\n}\r\nstatic void msm_gpio_update_dual_edge_pos(struct msm_pinctrl *pctrl,\r\nconst struct msm_pingroup *g,\r\nstruct irq_data *d)\r\n{\r\nint loop_limit = 100;\r\nunsigned val, val2, intstat;\r\nunsigned pol;\r\ndo {\r\nval = readl(pctrl->regs + g->io_reg) & BIT(g->in_bit);\r\npol = readl(pctrl->regs + g->intr_cfg_reg);\r\npol ^= BIT(g->intr_polarity_bit);\r\nwritel(pol, pctrl->regs + g->intr_cfg_reg);\r\nval2 = readl(pctrl->regs + g->io_reg) & BIT(g->in_bit);\r\nintstat = readl(pctrl->regs + g->intr_status_reg);\r\nif (intstat || (val == val2))\r\nreturn;\r\n} while (loop_limit-- > 0);\r\ndev_err(pctrl->dev, "dual-edge irq failed to stabilize, %#08x != %#08x\n",\r\nval, val2);\r\n}\r\nstatic void msm_gpio_irq_mask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct msm_pingroup *g;\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[d->hwirq];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->intr_cfg_reg);\r\nval &= ~BIT(g->intr_enable_bit);\r\nwritel(val, pctrl->regs + g->intr_cfg_reg);\r\nclear_bit(d->hwirq, pctrl->enabled_irqs);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic void msm_gpio_irq_unmask(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct msm_pingroup *g;\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[d->hwirq];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->intr_cfg_reg);\r\nval |= BIT(g->intr_enable_bit);\r\nwritel(val, pctrl->regs + g->intr_cfg_reg);\r\nset_bit(d->hwirq, pctrl->enabled_irqs);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic void msm_gpio_irq_ack(struct irq_data *d)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct msm_pingroup *g;\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[d->hwirq];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nval = readl(pctrl->regs + g->intr_status_reg);\r\nif (g->intr_ack_high)\r\nval |= BIT(g->intr_status_bit);\r\nelse\r\nval &= ~BIT(g->intr_status_bit);\r\nwritel(val, pctrl->regs + g->intr_status_reg);\r\nif (test_bit(d->hwirq, pctrl->dual_edge_irqs))\r\nmsm_gpio_update_dual_edge_pos(pctrl, g, d);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\n}\r\nstatic int msm_gpio_irq_set_type(struct irq_data *d, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\r\nconst struct msm_pingroup *g;\r\nunsigned long flags;\r\nu32 val;\r\ng = &pctrl->soc->groups[d->hwirq];\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nif (g->intr_detection_width == 1 && type == IRQ_TYPE_EDGE_BOTH)\r\nset_bit(d->hwirq, pctrl->dual_edge_irqs);\r\nelse\r\nclear_bit(d->hwirq, pctrl->dual_edge_irqs);\r\nval = readl(pctrl->regs + g->intr_target_reg);\r\nval &= ~(7 << g->intr_target_bit);\r\nval |= g->intr_target_kpss_val << g->intr_target_bit;\r\nwritel(val, pctrl->regs + g->intr_target_reg);\r\nval = readl(pctrl->regs + g->intr_cfg_reg);\r\nval |= BIT(g->intr_raw_status_bit);\r\nif (g->intr_detection_width == 2) {\r\nval &= ~(3 << g->intr_detection_bit);\r\nval &= ~(1 << g->intr_polarity_bit);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nval |= 1 << g->intr_detection_bit;\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nval |= 2 << g->intr_detection_bit;\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval |= 3 << g->intr_detection_bit;\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\n}\r\n} else if (g->intr_detection_width == 1) {\r\nval &= ~(1 << g->intr_detection_bit);\r\nval &= ~(1 << g->intr_polarity_bit);\r\nswitch (type) {\r\ncase IRQ_TYPE_EDGE_RISING:\r\nval |= BIT(g->intr_detection_bit);\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_FALLING:\r\nval |= BIT(g->intr_detection_bit);\r\nbreak;\r\ncase IRQ_TYPE_EDGE_BOTH:\r\nval |= BIT(g->intr_detection_bit);\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_LOW:\r\nbreak;\r\ncase IRQ_TYPE_LEVEL_HIGH:\r\nval |= BIT(g->intr_polarity_bit);\r\nbreak;\r\n}\r\n} else {\r\nBUG();\r\n}\r\nwritel(val, pctrl->regs + g->intr_cfg_reg);\r\nif (test_bit(d->hwirq, pctrl->dual_edge_irqs))\r\nmsm_gpio_update_dual_edge_pos(pctrl, g, d);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nif (type & (IRQ_TYPE_LEVEL_LOW | IRQ_TYPE_LEVEL_HIGH))\r\nirq_set_handler_locked(d, handle_level_irq);\r\nelse if (type & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING))\r\nirq_set_handler_locked(d, handle_edge_irq);\r\nreturn 0;\r\n}\r\nstatic int msm_gpio_irq_set_wake(struct irq_data *d, unsigned int on)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(d);\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&pctrl->lock, flags);\r\nirq_set_irq_wake(pctrl->irq, on);\r\nraw_spin_unlock_irqrestore(&pctrl->lock, flags);\r\nreturn 0;\r\n}\r\nstatic void msm_gpio_irq_handler(struct irq_desc *desc)\r\n{\r\nstruct gpio_chip *gc = irq_desc_get_handler_data(desc);\r\nconst struct msm_pingroup *g;\r\nstruct msm_pinctrl *pctrl = gpiochip_get_data(gc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nint irq_pin;\r\nint handled = 0;\r\nu32 val;\r\nint i;\r\nchained_irq_enter(chip, desc);\r\nfor_each_set_bit(i, pctrl->enabled_irqs, pctrl->chip.ngpio) {\r\ng = &pctrl->soc->groups[i];\r\nval = readl(pctrl->regs + g->intr_status_reg);\r\nif (val & BIT(g->intr_status_bit)) {\r\nirq_pin = irq_find_mapping(gc->irqdomain, i);\r\ngeneric_handle_irq(irq_pin);\r\nhandled++;\r\n}\r\n}\r\nif (handled == 0)\r\nhandle_bad_irq(desc);\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic int msm_gpio_init(struct msm_pinctrl *pctrl)\r\n{\r\nstruct gpio_chip *chip;\r\nint ret;\r\nunsigned ngpio = pctrl->soc->ngpios;\r\nif (WARN_ON(ngpio > MAX_NR_GPIO))\r\nreturn -EINVAL;\r\nchip = &pctrl->chip;\r\nchip->base = 0;\r\nchip->ngpio = ngpio;\r\nchip->label = dev_name(pctrl->dev);\r\nchip->parent = pctrl->dev;\r\nchip->owner = THIS_MODULE;\r\nchip->of_node = pctrl->dev->of_node;\r\nret = gpiochip_add_data(&pctrl->chip, pctrl);\r\nif (ret) {\r\ndev_err(pctrl->dev, "Failed register gpiochip\n");\r\nreturn ret;\r\n}\r\nret = gpiochip_add_pin_range(&pctrl->chip, dev_name(pctrl->dev), 0, 0, chip->ngpio);\r\nif (ret) {\r\ndev_err(pctrl->dev, "Failed to add pin range\n");\r\ngpiochip_remove(&pctrl->chip);\r\nreturn ret;\r\n}\r\nret = gpiochip_irqchip_add(chip,\r\n&msm_gpio_irq_chip,\r\n0,\r\nhandle_edge_irq,\r\nIRQ_TYPE_NONE);\r\nif (ret) {\r\ndev_err(pctrl->dev, "Failed to add irqchip to gpiochip\n");\r\ngpiochip_remove(&pctrl->chip);\r\nreturn -ENOSYS;\r\n}\r\ngpiochip_set_chained_irqchip(chip, &msm_gpio_irq_chip, pctrl->irq,\r\nmsm_gpio_irq_handler);\r\nreturn 0;\r\n}\r\nstatic int msm_ps_hold_restart(struct notifier_block *nb, unsigned long action,\r\nvoid *data)\r\n{\r\nstruct msm_pinctrl *pctrl = container_of(nb, struct msm_pinctrl, restart_nb);\r\nwritel(0, pctrl->regs + PS_HOLD_OFFSET);\r\nmdelay(1000);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic void msm_ps_hold_poweroff(void)\r\n{\r\nmsm_ps_hold_restart(&poweroff_pctrl->restart_nb, 0, NULL);\r\n}\r\nstatic void msm_pinctrl_setup_pm_reset(struct msm_pinctrl *pctrl)\r\n{\r\nint i;\r\nconst struct msm_function *func = pctrl->soc->functions;\r\nfor (i = 0; i < pctrl->soc->nfunctions; i++)\r\nif (!strcmp(func[i].name, "ps_hold")) {\r\npctrl->restart_nb.notifier_call = msm_ps_hold_restart;\r\npctrl->restart_nb.priority = 128;\r\nif (register_restart_handler(&pctrl->restart_nb))\r\ndev_err(pctrl->dev,\r\n"failed to setup restart handler.\n");\r\npoweroff_pctrl = pctrl;\r\npm_power_off = msm_ps_hold_poweroff;\r\nbreak;\r\n}\r\n}\r\nint msm_pinctrl_probe(struct platform_device *pdev,\r\nconst struct msm_pinctrl_soc_data *soc_data)\r\n{\r\nstruct msm_pinctrl *pctrl;\r\nstruct resource *res;\r\nint ret;\r\npctrl = devm_kzalloc(&pdev->dev, sizeof(*pctrl), GFP_KERNEL);\r\nif (!pctrl) {\r\ndev_err(&pdev->dev, "Can't allocate msm_pinctrl\n");\r\nreturn -ENOMEM;\r\n}\r\npctrl->dev = &pdev->dev;\r\npctrl->soc = soc_data;\r\npctrl->chip = msm_gpio_template;\r\nraw_spin_lock_init(&pctrl->lock);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npctrl->regs = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(pctrl->regs))\r\nreturn PTR_ERR(pctrl->regs);\r\nmsm_pinctrl_setup_pm_reset(pctrl);\r\npctrl->irq = platform_get_irq(pdev, 0);\r\nif (pctrl->irq < 0) {\r\ndev_err(&pdev->dev, "No interrupt defined for msmgpio\n");\r\nreturn pctrl->irq;\r\n}\r\nmsm_pinctrl_desc.name = dev_name(&pdev->dev);\r\nmsm_pinctrl_desc.pins = pctrl->soc->pins;\r\nmsm_pinctrl_desc.npins = pctrl->soc->npins;\r\npctrl->pctrl = devm_pinctrl_register(&pdev->dev, &msm_pinctrl_desc,\r\npctrl);\r\nif (IS_ERR(pctrl->pctrl)) {\r\ndev_err(&pdev->dev, "Couldn't register pinctrl driver\n");\r\nreturn PTR_ERR(pctrl->pctrl);\r\n}\r\nret = msm_gpio_init(pctrl);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, pctrl);\r\ndev_dbg(&pdev->dev, "Probed Qualcomm pinctrl driver\n");\r\nreturn 0;\r\n}\r\nint msm_pinctrl_remove(struct platform_device *pdev)\r\n{\r\nstruct msm_pinctrl *pctrl = platform_get_drvdata(pdev);\r\ngpiochip_remove(&pctrl->chip);\r\nunregister_restart_handler(&pctrl->restart_nb);\r\nreturn 0;\r\n}
