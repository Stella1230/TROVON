static void vc4_output_poll_changed(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\ndrm_fbdev_cma_hotplug_event(vc4->fbdev);\r\n}\r\nstatic void\r\nvc4_atomic_complete_commit(struct vc4_commit *c)\r\n{\r\nstruct drm_atomic_state *state = c->state;\r\nstruct drm_device *dev = state->dev;\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\ndrm_atomic_helper_commit_modeset_disables(dev, state);\r\ndrm_atomic_helper_commit_planes(dev, state, 0);\r\ndrm_atomic_helper_commit_modeset_enables(dev, state);\r\nstate->legacy_cursor_update = false;\r\ndrm_atomic_helper_wait_for_vblanks(dev, state);\r\ndrm_atomic_helper_cleanup_planes(dev, state);\r\ndrm_atomic_state_put(state);\r\nup(&vc4->async_modeset);\r\nkfree(c);\r\n}\r\nstatic void\r\nvc4_atomic_complete_commit_seqno_cb(struct vc4_seqno_cb *cb)\r\n{\r\nstruct vc4_commit *c = container_of(cb, struct vc4_commit, cb);\r\nvc4_atomic_complete_commit(c);\r\n}\r\nstatic struct vc4_commit *commit_init(struct drm_atomic_state *state)\r\n{\r\nstruct vc4_commit *c = kzalloc(sizeof(*c), GFP_KERNEL);\r\nif (!c)\r\nreturn NULL;\r\nc->dev = state->dev;\r\nc->state = state;\r\nreturn c;\r\n}\r\nstatic int vc4_atomic_commit(struct drm_device *dev,\r\nstruct drm_atomic_state *state,\r\nbool nonblock)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nint ret;\r\nint i;\r\nuint64_t wait_seqno = 0;\r\nstruct vc4_commit *c;\r\nstruct drm_plane *plane;\r\nstruct drm_plane_state *new_state;\r\nc = commit_init(state);\r\nif (!c)\r\nreturn -ENOMEM;\r\nif (nonblock) {\r\nstruct drm_crtc *crtc;\r\nstruct drm_crtc_state *crtc_state;\r\nunsigned long flags;\r\nbool busy = false;\r\nspin_lock_irqsave(&dev->event_lock, flags);\r\nfor_each_crtc_in_state(state, crtc, crtc_state, i)\r\nbusy |= vc4_event_pending(crtc);\r\nspin_unlock_irqrestore(&dev->event_lock, flags);\r\nif (busy) {\r\nkfree(c);\r\nreturn -EBUSY;\r\n}\r\n}\r\nret = down_interruptible(&vc4->async_modeset);\r\nif (ret) {\r\nkfree(c);\r\nreturn ret;\r\n}\r\nret = drm_atomic_helper_prepare_planes(dev, state);\r\nif (ret) {\r\nkfree(c);\r\nup(&vc4->async_modeset);\r\nreturn ret;\r\n}\r\nfor_each_plane_in_state(state, plane, new_state, i) {\r\nif ((plane->state->fb != new_state->fb) && new_state->fb) {\r\nstruct drm_gem_cma_object *cma_bo =\r\ndrm_fb_cma_get_gem_obj(new_state->fb, 0);\r\nstruct vc4_bo *bo = to_vc4_bo(&cma_bo->base);\r\nwait_seqno = max(bo->seqno, wait_seqno);\r\n}\r\n}\r\ndrm_atomic_helper_swap_state(state, true);\r\ndrm_atomic_state_get(state);\r\nif (nonblock) {\r\nvc4_queue_seqno_cb(dev, &c->cb, wait_seqno,\r\nvc4_atomic_complete_commit_seqno_cb);\r\n} else {\r\nvc4_wait_for_seqno(dev, wait_seqno, ~0ull, false);\r\nvc4_atomic_complete_commit(c);\r\n}\r\nreturn 0;\r\n}\r\nint vc4_kms_load(struct drm_device *dev)\r\n{\r\nstruct vc4_dev *vc4 = to_vc4_dev(dev);\r\nint ret;\r\nsema_init(&vc4->async_modeset, 1);\r\nret = drm_vblank_init(dev, dev->mode_config.num_crtc);\r\nif (ret < 0) {\r\ndev_err(dev->dev, "failed to initialize vblank\n");\r\nreturn ret;\r\n}\r\ndev->mode_config.max_width = 2048;\r\ndev->mode_config.max_height = 2048;\r\ndev->mode_config.funcs = &vc4_mode_funcs;\r\ndev->mode_config.preferred_depth = 24;\r\ndev->mode_config.async_page_flip = true;\r\ndrm_mode_config_reset(dev);\r\nvc4->fbdev = drm_fbdev_cma_init(dev, 32,\r\ndev->mode_config.num_connector);\r\nif (IS_ERR(vc4->fbdev))\r\nvc4->fbdev = NULL;\r\ndrm_kms_helper_poll_init(dev);\r\nreturn 0;\r\n}
