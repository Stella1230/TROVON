void efi_call_virt_check_flags(unsigned long flags, const char *call)\r\n{\r\nunsigned long cur_flags, mismatch;\r\nlocal_save_flags(cur_flags);\r\nmismatch = flags ^ cur_flags;\r\nif (!WARN_ON_ONCE(mismatch & ARCH_EFI_IRQ_FLAGS_MASK))\r\nreturn;\r\nadd_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_NOW_UNRELIABLE);\r\npr_err_ratelimited(FW_BUG "IRQ flags corrupted (0x%08lx=>0x%08lx) by EFI %s\n",\r\nflags, cur_flags, call);\r\nlocal_irq_restore(flags);\r\n}\r\nstatic efi_status_t virt_efi_get_time(efi_time_t *tm, efi_time_cap_t *tc)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(get_time, tm, tc);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_set_time(efi_time_t *tm)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(set_time, tm);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_get_wakeup_time(efi_bool_t *enabled,\r\nefi_bool_t *pending,\r\nefi_time_t *tm)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(get_wakeup_time, enabled, pending, tm);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_set_wakeup_time(efi_bool_t enabled, efi_time_t *tm)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(set_wakeup_time, enabled, tm);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_get_variable(efi_char16_t *name,\r\nefi_guid_t *vendor,\r\nu32 *attr,\r\nunsigned long *data_size,\r\nvoid *data)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(get_variable, name, vendor, attr, data_size,\r\ndata);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_get_next_variable(unsigned long *name_size,\r\nefi_char16_t *name,\r\nefi_guid_t *vendor)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(get_next_variable, name_size, name, vendor);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_set_variable(efi_char16_t *name,\r\nefi_guid_t *vendor,\r\nu32 attr,\r\nunsigned long data_size,\r\nvoid *data)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(set_variable, name, vendor, attr, data_size,\r\ndata);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nvirt_efi_set_variable_nonblocking(efi_char16_t *name, efi_guid_t *vendor,\r\nu32 attr, unsigned long data_size,\r\nvoid *data)\r\n{\r\nefi_status_t status;\r\nif (down_trylock(&efi_runtime_lock))\r\nreturn EFI_NOT_READY;\r\nstatus = efi_call_virt(set_variable, name, vendor, attr, data_size,\r\ndata);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_query_variable_info(u32 attr,\r\nu64 *storage_space,\r\nu64 *remaining_space,\r\nu64 *max_variable_size)\r\n{\r\nefi_status_t status;\r\nif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\r\nreturn EFI_UNSUPPORTED;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(query_variable_info, attr, storage_space,\r\nremaining_space, max_variable_size);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t\r\nvirt_efi_query_variable_info_nonblocking(u32 attr,\r\nu64 *storage_space,\r\nu64 *remaining_space,\r\nu64 *max_variable_size)\r\n{\r\nefi_status_t status;\r\nif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\r\nreturn EFI_UNSUPPORTED;\r\nif (down_trylock(&efi_runtime_lock))\r\nreturn EFI_NOT_READY;\r\nstatus = efi_call_virt(query_variable_info, attr, storage_space,\r\nremaining_space, max_variable_size);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_get_next_high_mono_count(u32 *count)\r\n{\r\nefi_status_t status;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(get_next_high_mono_count, count);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic void virt_efi_reset_system(int reset_type,\r\nefi_status_t status,\r\nunsigned long data_size,\r\nefi_char16_t *data)\r\n{\r\nif (down_interruptible(&efi_runtime_lock)) {\r\npr_warn("failed to invoke the reset_system() runtime service:\n"\r\n"could not get exclusive access to the firmware\n");\r\nreturn;\r\n}\r\n__efi_call_virt(reset_system, reset_type, status, data_size, data);\r\nup(&efi_runtime_lock);\r\n}\r\nstatic efi_status_t virt_efi_update_capsule(efi_capsule_header_t **capsules,\r\nunsigned long count,\r\nunsigned long sg_list)\r\n{\r\nefi_status_t status;\r\nif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\r\nreturn EFI_UNSUPPORTED;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(update_capsule, capsules, count, sg_list);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nstatic efi_status_t virt_efi_query_capsule_caps(efi_capsule_header_t **capsules,\r\nunsigned long count,\r\nu64 *max_size,\r\nint *reset_type)\r\n{\r\nefi_status_t status;\r\nif (efi.runtime_version < EFI_2_00_SYSTEM_TABLE_REVISION)\r\nreturn EFI_UNSUPPORTED;\r\nif (down_interruptible(&efi_runtime_lock))\r\nreturn EFI_ABORTED;\r\nstatus = efi_call_virt(query_capsule_caps, capsules, count, max_size,\r\nreset_type);\r\nup(&efi_runtime_lock);\r\nreturn status;\r\n}\r\nvoid efi_native_runtime_setup(void)\r\n{\r\nefi.get_time = virt_efi_get_time;\r\nefi.set_time = virt_efi_set_time;\r\nefi.get_wakeup_time = virt_efi_get_wakeup_time;\r\nefi.set_wakeup_time = virt_efi_set_wakeup_time;\r\nefi.get_variable = virt_efi_get_variable;\r\nefi.get_next_variable = virt_efi_get_next_variable;\r\nefi.set_variable = virt_efi_set_variable;\r\nefi.set_variable_nonblocking = virt_efi_set_variable_nonblocking;\r\nefi.get_next_high_mono_count = virt_efi_get_next_high_mono_count;\r\nefi.reset_system = virt_efi_reset_system;\r\nefi.query_variable_info = virt_efi_query_variable_info;\r\nefi.query_variable_info_nonblocking = virt_efi_query_variable_info_nonblocking;\r\nefi.update_capsule = virt_efi_update_capsule;\r\nefi.query_capsule_caps = virt_efi_query_capsule_caps;\r\n}
