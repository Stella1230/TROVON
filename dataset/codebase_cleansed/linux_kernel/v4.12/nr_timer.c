void nr_init_timers(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nsetup_timer(&nr->t1timer, nr_t1timer_expiry, (unsigned long)sk);\r\nsetup_timer(&nr->t2timer, nr_t2timer_expiry, (unsigned long)sk);\r\nsetup_timer(&nr->t4timer, nr_t4timer_expiry, (unsigned long)sk);\r\nsetup_timer(&nr->idletimer, nr_idletimer_expiry, (unsigned long)sk);\r\nsk->sk_timer.data = (unsigned long)sk;\r\nsk->sk_timer.function = &nr_heartbeat_expiry;\r\n}\r\nvoid nr_start_t1timer(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nmod_timer(&nr->t1timer, jiffies + nr->t1);\r\n}\r\nvoid nr_start_t2timer(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nmod_timer(&nr->t2timer, jiffies + nr->t2);\r\n}\r\nvoid nr_start_t4timer(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nmod_timer(&nr->t4timer, jiffies + nr->t4);\r\n}\r\nvoid nr_start_idletimer(struct sock *sk)\r\n{\r\nstruct nr_sock *nr = nr_sk(sk);\r\nif (nr->idle > 0)\r\nmod_timer(&nr->idletimer, jiffies + nr->idle);\r\n}\r\nvoid nr_start_heartbeat(struct sock *sk)\r\n{\r\nmod_timer(&sk->sk_timer, jiffies + 5 * HZ);\r\n}\r\nvoid nr_stop_t1timer(struct sock *sk)\r\n{\r\ndel_timer(&nr_sk(sk)->t1timer);\r\n}\r\nvoid nr_stop_t2timer(struct sock *sk)\r\n{\r\ndel_timer(&nr_sk(sk)->t2timer);\r\n}\r\nvoid nr_stop_t4timer(struct sock *sk)\r\n{\r\ndel_timer(&nr_sk(sk)->t4timer);\r\n}\r\nvoid nr_stop_idletimer(struct sock *sk)\r\n{\r\ndel_timer(&nr_sk(sk)->idletimer);\r\n}\r\nvoid nr_stop_heartbeat(struct sock *sk)\r\n{\r\ndel_timer(&sk->sk_timer);\r\n}\r\nint nr_t1timer_running(struct sock *sk)\r\n{\r\nreturn timer_pending(&nr_sk(sk)->t1timer);\r\n}\r\nstatic void nr_heartbeat_expiry(unsigned long param)\r\n{\r\nstruct sock *sk = (struct sock *)param;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nbh_lock_sock(sk);\r\nswitch (nr->state) {\r\ncase NR_STATE_0:\r\nif (sock_flag(sk, SOCK_DESTROY) ||\r\n(sk->sk_state == TCP_LISTEN && sock_flag(sk, SOCK_DEAD))) {\r\nsock_hold(sk);\r\nbh_unlock_sock(sk);\r\nnr_destroy_socket(sk);\r\nsock_put(sk);\r\nreturn;\r\n}\r\nbreak;\r\ncase NR_STATE_3:\r\nif (atomic_read(&sk->sk_rmem_alloc) < (sk->sk_rcvbuf / 2) &&\r\n(nr->condition & NR_COND_OWN_RX_BUSY)) {\r\nnr->condition &= ~NR_COND_OWN_RX_BUSY;\r\nnr->condition &= ~NR_COND_ACK_PENDING;\r\nnr->vl = nr->vr;\r\nnr_write_internal(sk, NR_INFOACK);\r\nbreak;\r\n}\r\nbreak;\r\n}\r\nnr_start_heartbeat(sk);\r\nbh_unlock_sock(sk);\r\n}\r\nstatic void nr_t2timer_expiry(unsigned long param)\r\n{\r\nstruct sock *sk = (struct sock *)param;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nbh_lock_sock(sk);\r\nif (nr->condition & NR_COND_ACK_PENDING) {\r\nnr->condition &= ~NR_COND_ACK_PENDING;\r\nnr_enquiry_response(sk);\r\n}\r\nbh_unlock_sock(sk);\r\n}\r\nstatic void nr_t4timer_expiry(unsigned long param)\r\n{\r\nstruct sock *sk = (struct sock *)param;\r\nbh_lock_sock(sk);\r\nnr_sk(sk)->condition &= ~NR_COND_PEER_RX_BUSY;\r\nbh_unlock_sock(sk);\r\n}\r\nstatic void nr_idletimer_expiry(unsigned long param)\r\n{\r\nstruct sock *sk = (struct sock *)param;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nbh_lock_sock(sk);\r\nnr_clear_queues(sk);\r\nnr->n2count = 0;\r\nnr_write_internal(sk, NR_DISCREQ);\r\nnr->state = NR_STATE_2;\r\nnr_start_t1timer(sk);\r\nnr_stop_t2timer(sk);\r\nnr_stop_t4timer(sk);\r\nsk->sk_state = TCP_CLOSE;\r\nsk->sk_err = 0;\r\nsk->sk_shutdown |= SEND_SHUTDOWN;\r\nif (!sock_flag(sk, SOCK_DEAD)) {\r\nsk->sk_state_change(sk);\r\nsock_set_flag(sk, SOCK_DEAD);\r\n}\r\nbh_unlock_sock(sk);\r\n}\r\nstatic void nr_t1timer_expiry(unsigned long param)\r\n{\r\nstruct sock *sk = (struct sock *)param;\r\nstruct nr_sock *nr = nr_sk(sk);\r\nbh_lock_sock(sk);\r\nswitch (nr->state) {\r\ncase NR_STATE_1:\r\nif (nr->n2count == nr->n2) {\r\nnr_disconnect(sk, ETIMEDOUT);\r\nbh_unlock_sock(sk);\r\nreturn;\r\n} else {\r\nnr->n2count++;\r\nnr_write_internal(sk, NR_CONNREQ);\r\n}\r\nbreak;\r\ncase NR_STATE_2:\r\nif (nr->n2count == nr->n2) {\r\nnr_disconnect(sk, ETIMEDOUT);\r\nbh_unlock_sock(sk);\r\nreturn;\r\n} else {\r\nnr->n2count++;\r\nnr_write_internal(sk, NR_DISCREQ);\r\n}\r\nbreak;\r\ncase NR_STATE_3:\r\nif (nr->n2count == nr->n2) {\r\nnr_disconnect(sk, ETIMEDOUT);\r\nbh_unlock_sock(sk);\r\nreturn;\r\n} else {\r\nnr->n2count++;\r\nnr_requeue_frames(sk);\r\n}\r\nbreak;\r\n}\r\nnr_start_t1timer(sk);\r\nbh_unlock_sock(sk);\r\n}
