static void imx_set_panic_temp(struct imx_thermal_data *data,\r\nint panic_temp)\r\n{\r\nstruct regmap *map = data->tempmon;\r\nint critical_value;\r\ncritical_value = (data->c2 - panic_temp) / data->c1;\r\nregmap_write(map, TEMPSENSE2 + REG_CLR, TEMPSENSE2_PANIC_VALUE_MASK);\r\nregmap_write(map, TEMPSENSE2 + REG_SET, critical_value <<\r\nTEMPSENSE2_PANIC_VALUE_SHIFT);\r\n}\r\nstatic void imx_set_alarm_temp(struct imx_thermal_data *data,\r\nint alarm_temp)\r\n{\r\nstruct regmap *map = data->tempmon;\r\nint alarm_value;\r\ndata->alarm_temp = alarm_temp;\r\nalarm_value = (data->c2 - alarm_temp) / data->c1;\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_ALARM_VALUE_MASK);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, alarm_value <<\r\nTEMPSENSE0_ALARM_VALUE_SHIFT);\r\n}\r\nstatic int imx_get_temp(struct thermal_zone_device *tz, int *temp)\r\n{\r\nstruct imx_thermal_data *data = tz->devdata;\r\nstruct regmap *map = data->tempmon;\r\nunsigned int n_meas;\r\nbool wait;\r\nu32 val;\r\nif (data->mode == THERMAL_DEVICE_ENABLED) {\r\nregmap_read(map, TEMPSENSE0, &val);\r\nwait = !(val & TEMPSENSE0_FINISHED);\r\n} else {\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_POWER_DOWN);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_MEASURE_TEMP);\r\nwait = true;\r\n}\r\nif (wait)\r\nusleep_range(20, 50);\r\nregmap_read(map, TEMPSENSE0, &val);\r\nif (data->mode != THERMAL_DEVICE_ENABLED) {\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_MEASURE_TEMP);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_POWER_DOWN);\r\n}\r\nif ((val & TEMPSENSE0_FINISHED) == 0) {\r\ndev_dbg(&tz->device, "temp measurement never finished\n");\r\nreturn -EAGAIN;\r\n}\r\nn_meas = (val & TEMPSENSE0_TEMP_CNT_MASK) >> TEMPSENSE0_TEMP_CNT_SHIFT;\r\n*temp = data->c2 - n_meas * data->c1;\r\nif (data->socdata->version == TEMPMON_IMX6Q) {\r\nif (data->alarm_temp == data->temp_passive &&\r\n*temp >= data->temp_passive)\r\nimx_set_alarm_temp(data, data->temp_critical);\r\nif (data->alarm_temp == data->temp_critical &&\r\n*temp < data->temp_passive) {\r\nimx_set_alarm_temp(data, data->temp_passive);\r\ndev_dbg(&tz->device, "thermal alarm off: T < %d\n",\r\ndata->alarm_temp / 1000);\r\n}\r\n}\r\nif (*temp != data->last_temp) {\r\ndev_dbg(&tz->device, "millicelsius: %d\n", *temp);\r\ndata->last_temp = *temp;\r\n}\r\nif (!data->irq_enabled && *temp < data->alarm_temp) {\r\ndata->irq_enabled = true;\r\nenable_irq(data->irq);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_get_mode(struct thermal_zone_device *tz,\r\nenum thermal_device_mode *mode)\r\n{\r\nstruct imx_thermal_data *data = tz->devdata;\r\n*mode = data->mode;\r\nreturn 0;\r\n}\r\nstatic int imx_set_mode(struct thermal_zone_device *tz,\r\nenum thermal_device_mode mode)\r\n{\r\nstruct imx_thermal_data *data = tz->devdata;\r\nstruct regmap *map = data->tempmon;\r\nif (mode == THERMAL_DEVICE_ENABLED) {\r\ntz->polling_delay = IMX_POLLING_DELAY;\r\ntz->passive_delay = IMX_PASSIVE_DELAY;\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_POWER_DOWN);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_MEASURE_TEMP);\r\nif (!data->irq_enabled) {\r\ndata->irq_enabled = true;\r\nenable_irq(data->irq);\r\n}\r\n} else {\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_MEASURE_TEMP);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_POWER_DOWN);\r\ntz->polling_delay = 0;\r\ntz->passive_delay = 0;\r\nif (data->irq_enabled) {\r\ndisable_irq(data->irq);\r\ndata->irq_enabled = false;\r\n}\r\n}\r\ndata->mode = mode;\r\nthermal_zone_device_update(tz, THERMAL_EVENT_UNSPECIFIED);\r\nreturn 0;\r\n}\r\nstatic int imx_get_trip_type(struct thermal_zone_device *tz, int trip,\r\nenum thermal_trip_type *type)\r\n{\r\n*type = (trip == IMX_TRIP_PASSIVE) ? THERMAL_TRIP_PASSIVE :\r\nTHERMAL_TRIP_CRITICAL;\r\nreturn 0;\r\n}\r\nstatic int imx_get_crit_temp(struct thermal_zone_device *tz, int *temp)\r\n{\r\nstruct imx_thermal_data *data = tz->devdata;\r\n*temp = data->temp_critical;\r\nreturn 0;\r\n}\r\nstatic int imx_get_trip_temp(struct thermal_zone_device *tz, int trip,\r\nint *temp)\r\n{\r\nstruct imx_thermal_data *data = tz->devdata;\r\n*temp = (trip == IMX_TRIP_PASSIVE) ? data->temp_passive :\r\ndata->temp_critical;\r\nreturn 0;\r\n}\r\nstatic int imx_set_trip_temp(struct thermal_zone_device *tz, int trip,\r\nint temp)\r\n{\r\nstruct imx_thermal_data *data = tz->devdata;\r\nif (trip == IMX_TRIP_CRITICAL)\r\nreturn -EPERM;\r\nif (temp < 0 || temp > data->temp_critical)\r\nreturn -EINVAL;\r\ndata->temp_passive = temp;\r\nimx_set_alarm_temp(data, temp);\r\nreturn 0;\r\n}\r\nstatic int imx_bind(struct thermal_zone_device *tz,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nint ret;\r\nret = thermal_zone_bind_cooling_device(tz, IMX_TRIP_PASSIVE, cdev,\r\nTHERMAL_NO_LIMIT,\r\nTHERMAL_NO_LIMIT,\r\nTHERMAL_WEIGHT_DEFAULT);\r\nif (ret) {\r\ndev_err(&tz->device,\r\n"binding zone %s with cdev %s failed:%d\n",\r\ntz->type, cdev->type, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_unbind(struct thermal_zone_device *tz,\r\nstruct thermal_cooling_device *cdev)\r\n{\r\nint ret;\r\nret = thermal_zone_unbind_cooling_device(tz, IMX_TRIP_PASSIVE, cdev);\r\nif (ret) {\r\ndev_err(&tz->device,\r\n"unbinding zone %s with cdev %s failed:%d\n",\r\ntz->type, cdev->type, ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_get_sensor_data(struct platform_device *pdev)\r\n{\r\nstruct imx_thermal_data *data = platform_get_drvdata(pdev);\r\nstruct regmap *map;\r\nint t1, n1;\r\nint ret;\r\nu32 val;\r\nu64 temp64;\r\nmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"fsl,tempmon-data");\r\nif (IS_ERR(map)) {\r\nret = PTR_ERR(map);\r\ndev_err(&pdev->dev, "failed to get sensor regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_read(map, OCOTP_ANA1, &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to read sensor data: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (val == 0 || val == ~0) {\r\ndev_err(&pdev->dev, "invalid sensor calibration data\n");\r\nreturn -EINVAL;\r\n}\r\nn1 = val >> 20;\r\nt1 = 25;\r\ntemp64 = FACTOR0;\r\ntemp64 *= 1000;\r\ndo_div(temp64, FACTOR1 * n1 - FACTOR2);\r\ndata->c1 = temp64;\r\ndata->c2 = n1 * data->c1 + 1000 * t1;\r\nret = regmap_read(map, OCOTP_MEM0, &val);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to read temp grade: %d\n", ret);\r\nreturn ret;\r\n}\r\nswitch ((val >> 6) & 0x3) {\r\ncase 0:\r\ndata->temp_grade = "Commercial";\r\ndata->temp_max = 95000;\r\nbreak;\r\ncase 1:\r\ndata->temp_grade = "Extended Commercial";\r\ndata->temp_max = 105000;\r\nbreak;\r\ncase 2:\r\ndata->temp_grade = "Industrial";\r\ndata->temp_max = 105000;\r\nbreak;\r\ncase 3:\r\ndata->temp_grade = "Automotive";\r\ndata->temp_max = 125000;\r\nbreak;\r\n}\r\ndata->temp_critical = data->temp_max - (1000 * 5);\r\ndata->temp_passive = data->temp_max - (1000 * 10);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t imx_thermal_alarm_irq(int irq, void *dev)\r\n{\r\nstruct imx_thermal_data *data = dev;\r\ndisable_irq_nosync(irq);\r\ndata->irq_enabled = false;\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t imx_thermal_alarm_irq_thread(int irq, void *dev)\r\n{\r\nstruct imx_thermal_data *data = dev;\r\ndev_dbg(&data->tz->device, "THERMAL ALARM: T > %d\n",\r\ndata->alarm_temp / 1000);\r\nthermal_zone_device_update(data->tz, THERMAL_EVENT_UNSPECIFIED);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int imx_thermal_probe(struct platform_device *pdev)\r\n{\r\nstruct imx_thermal_data *data;\r\nstruct regmap *map;\r\nint measure_freq;\r\nint ret;\r\ndata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nmap = syscon_regmap_lookup_by_phandle(pdev->dev.of_node, "fsl,tempmon");\r\nif (IS_ERR(map)) {\r\nret = PTR_ERR(map);\r\ndev_err(&pdev->dev, "failed to get tempmon regmap: %d\n", ret);\r\nreturn ret;\r\n}\r\ndata->tempmon = map;\r\ndata->socdata = of_device_get_match_data(&pdev->dev);\r\nif (!data->socdata) {\r\ndev_err(&pdev->dev, "no device match found\n");\r\nreturn -ENODEV;\r\n}\r\nif (data->socdata->version == TEMPMON_IMX6SX) {\r\nregmap_write(map, MISC1 + REG_CLR, MISC1_IRQ_TEMPHIGH |\r\nMISC1_IRQ_TEMPLOW | MISC1_IRQ_TEMPPANIC);\r\nregmap_write(map, TEMPSENSE2 + REG_SET,\r\nTEMPSENSE2_LOW_VALUE_MASK);\r\n}\r\ndata->irq = platform_get_irq(pdev, 0);\r\nif (data->irq < 0)\r\nreturn data->irq;\r\nplatform_set_drvdata(pdev, data);\r\nret = imx_get_sensor_data(pdev);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to get sensor data\n");\r\nreturn ret;\r\n}\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_POWER_DOWN);\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_MEASURE_TEMP);\r\nregmap_write(map, TEMPSENSE1 + REG_CLR, TEMPSENSE1_MEASURE_FREQ);\r\nregmap_write(map, MISC0 + REG_SET, MISC0_REFTOP_SELBIASOFF);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_POWER_DOWN);\r\ndata->cdev = cpufreq_cooling_register(cpu_present_mask);\r\nif (IS_ERR(data->cdev)) {\r\nret = PTR_ERR(data->cdev);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"failed to register cpufreq cooling device: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ndata->thermal_clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(data->thermal_clk)) {\r\nret = PTR_ERR(data->thermal_clk);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(&pdev->dev,\r\n"failed to get thermal clk: %d\n", ret);\r\ncpufreq_cooling_unregister(data->cdev);\r\nreturn ret;\r\n}\r\nret = clk_prepare_enable(data->thermal_clk);\r\nif (ret) {\r\ndev_err(&pdev->dev, "failed to enable thermal clk: %d\n", ret);\r\ncpufreq_cooling_unregister(data->cdev);\r\nreturn ret;\r\n}\r\ndata->tz = thermal_zone_device_register("imx_thermal_zone",\r\nIMX_TRIP_NUM,\r\nBIT(IMX_TRIP_PASSIVE), data,\r\n&imx_tz_ops, NULL,\r\nIMX_PASSIVE_DELAY,\r\nIMX_POLLING_DELAY);\r\nif (IS_ERR(data->tz)) {\r\nret = PTR_ERR(data->tz);\r\ndev_err(&pdev->dev,\r\n"failed to register thermal zone device %d\n", ret);\r\nclk_disable_unprepare(data->thermal_clk);\r\ncpufreq_cooling_unregister(data->cdev);\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "%s CPU temperature grade - max:%dC"\r\n" critical:%dC passive:%dC\n", data->temp_grade,\r\ndata->temp_max / 1000, data->temp_critical / 1000,\r\ndata->temp_passive / 1000);\r\nregmap_write(map, TEMPSENSE1 + REG_CLR, TEMPSENSE1_MEASURE_FREQ);\r\nmeasure_freq = DIV_ROUND_UP(32768, 10);\r\nregmap_write(map, TEMPSENSE1 + REG_SET, measure_freq);\r\nimx_set_alarm_temp(data, data->temp_passive);\r\nif (data->socdata->version == TEMPMON_IMX6SX)\r\nimx_set_panic_temp(data, data->temp_critical);\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_POWER_DOWN);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_MEASURE_TEMP);\r\nret = devm_request_threaded_irq(&pdev->dev, data->irq,\r\nimx_thermal_alarm_irq, imx_thermal_alarm_irq_thread,\r\n0, "imx_thermal", data);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to request alarm irq: %d\n", ret);\r\nclk_disable_unprepare(data->thermal_clk);\r\nthermal_zone_device_unregister(data->tz);\r\ncpufreq_cooling_unregister(data->cdev);\r\nreturn ret;\r\n}\r\ndata->irq_enabled = true;\r\ndata->mode = THERMAL_DEVICE_ENABLED;\r\nreturn 0;\r\n}\r\nstatic int imx_thermal_remove(struct platform_device *pdev)\r\n{\r\nstruct imx_thermal_data *data = platform_get_drvdata(pdev);\r\nstruct regmap *map = data->tempmon;\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_POWER_DOWN);\r\nif (!IS_ERR(data->thermal_clk))\r\nclk_disable_unprepare(data->thermal_clk);\r\nthermal_zone_device_unregister(data->tz);\r\ncpufreq_cooling_unregister(data->cdev);\r\nreturn 0;\r\n}\r\nstatic int imx_thermal_suspend(struct device *dev)\r\n{\r\nstruct imx_thermal_data *data = dev_get_drvdata(dev);\r\nstruct regmap *map = data->tempmon;\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_MEASURE_TEMP);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_POWER_DOWN);\r\ndata->mode = THERMAL_DEVICE_DISABLED;\r\nclk_disable_unprepare(data->thermal_clk);\r\nreturn 0;\r\n}\r\nstatic int imx_thermal_resume(struct device *dev)\r\n{\r\nstruct imx_thermal_data *data = dev_get_drvdata(dev);\r\nstruct regmap *map = data->tempmon;\r\nclk_prepare_enable(data->thermal_clk);\r\nregmap_write(map, TEMPSENSE0 + REG_CLR, TEMPSENSE0_POWER_DOWN);\r\nregmap_write(map, TEMPSENSE0 + REG_SET, TEMPSENSE0_MEASURE_TEMP);\r\ndata->mode = THERMAL_DEVICE_ENABLED;\r\nreturn 0;\r\n}
