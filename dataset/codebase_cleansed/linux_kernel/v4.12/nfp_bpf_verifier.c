static struct nfp_insn_meta *\r\nnfp_bpf_goto_meta(struct nfp_prog *nfp_prog, struct nfp_insn_meta *meta,\r\nunsigned int insn_idx, unsigned int n_insns)\r\n{\r\nunsigned int forward, backward, i;\r\nbackward = meta->n - insn_idx;\r\nforward = insn_idx - meta->n;\r\nif (min(forward, backward) > n_insns - insn_idx - 1) {\r\nbackward = n_insns - insn_idx - 1;\r\nmeta = nfp_prog_last_meta(nfp_prog);\r\n}\r\nif (min(forward, backward) > insn_idx && backward > insn_idx) {\r\nforward = insn_idx;\r\nmeta = nfp_prog_first_meta(nfp_prog);\r\n}\r\nif (forward < backward)\r\nfor (i = 0; i < forward; i++)\r\nmeta = nfp_meta_next(meta);\r\nelse\r\nfor (i = 0; i < backward; i++)\r\nmeta = nfp_meta_prev(meta);\r\nreturn meta;\r\n}\r\nstatic int\r\nnfp_bpf_check_exit(struct nfp_prog *nfp_prog,\r\nconst struct bpf_verifier_env *env)\r\n{\r\nconst struct bpf_reg_state *reg0 = &env->cur_state.regs[0];\r\nif (nfp_prog->act == NN_ACT_XDP)\r\nreturn 0;\r\nif (reg0->type != CONST_IMM) {\r\npr_info("unsupported exit state: %d, imm: %llx\n",\r\nreg0->type, reg0->imm);\r\nreturn -EINVAL;\r\n}\r\nif (nfp_prog->act != NN_ACT_DIRECT &&\r\nreg0->imm != 0 && (reg0->imm & ~0U) != ~0U) {\r\npr_info("unsupported exit state: %d, imm: %llx\n",\r\nreg0->type, reg0->imm);\r\nreturn -EINVAL;\r\n}\r\nif (nfp_prog->act == NN_ACT_DIRECT && reg0->imm <= TC_ACT_REDIRECT &&\r\nreg0->imm != TC_ACT_SHOT && reg0->imm != TC_ACT_STOLEN &&\r\nreg0->imm != TC_ACT_QUEUED) {\r\npr_info("unsupported exit state: %d, imm: %llx\n",\r\nreg0->type, reg0->imm);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnfp_bpf_check_ctx_ptr(struct nfp_prog *nfp_prog,\r\nconst struct bpf_verifier_env *env, u8 reg)\r\n{\r\nif (env->cur_state.regs[reg].type != PTR_TO_CTX)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int\r\nnfp_verify_insn(struct bpf_verifier_env *env, int insn_idx, int prev_insn_idx)\r\n{\r\nstruct nfp_bpf_analyzer_priv *priv = env->analyzer_priv;\r\nstruct nfp_insn_meta *meta = priv->meta;\r\nmeta = nfp_bpf_goto_meta(priv->prog, meta, insn_idx, env->prog->len);\r\npriv->meta = meta;\r\nif (meta->insn.src_reg == BPF_REG_10 ||\r\nmeta->insn.dst_reg == BPF_REG_10) {\r\npr_err("stack not yet supported\n");\r\nreturn -EINVAL;\r\n}\r\nif (meta->insn.src_reg >= MAX_BPF_REG ||\r\nmeta->insn.dst_reg >= MAX_BPF_REG) {\r\npr_err("program uses extended registers - jit hardening?\n");\r\nreturn -EINVAL;\r\n}\r\nif (meta->insn.code == (BPF_JMP | BPF_EXIT))\r\nreturn nfp_bpf_check_exit(priv->prog, env);\r\nif ((meta->insn.code & ~BPF_SIZE_MASK) == (BPF_LDX | BPF_MEM))\r\nreturn nfp_bpf_check_ctx_ptr(priv->prog, env,\r\nmeta->insn.src_reg);\r\nif ((meta->insn.code & ~BPF_SIZE_MASK) == (BPF_STX | BPF_MEM))\r\nreturn nfp_bpf_check_ctx_ptr(priv->prog, env,\r\nmeta->insn.dst_reg);\r\nreturn 0;\r\n}\r\nint nfp_prog_verify(struct nfp_prog *nfp_prog, struct bpf_prog *prog)\r\n{\r\nstruct nfp_bpf_analyzer_priv *priv;\r\nint ret;\r\npriv = kzalloc(sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\npriv->prog = nfp_prog;\r\npriv->meta = nfp_prog_first_meta(nfp_prog);\r\nret = bpf_analyzer(prog, &nfp_bpf_analyzer_ops, priv);\r\nkfree(priv);\r\nreturn ret;\r\n}
