static u32 nffw_res_info_version_get(const struct nfp_nffw_info_data *res)\r\n{\r\nreturn (le32_to_cpu(res->flags[0]) >> 16) & 0xfff;\r\n}\r\nstatic u32 nffw_res_flg_init_get(const struct nfp_nffw_info_data *res)\r\n{\r\nreturn (le32_to_cpu(res->flags[0]) >> 0) & 1;\r\n}\r\nstatic u32 nffw_fwinfo_loaded_get(const struct nffw_fwinfo *fi)\r\n{\r\nreturn (le32_to_cpu(fi->loaded__mu_da__mip_off_hi) >> 31) & 1;\r\n}\r\nstatic u32 nffw_fwinfo_mip_cppid_get(const struct nffw_fwinfo *fi)\r\n{\r\nreturn le32_to_cpu(fi->mip_cppid);\r\n}\r\nstatic u32 nffw_fwinfo_mip_mu_da_get(const struct nffw_fwinfo *fi)\r\n{\r\nreturn (le32_to_cpu(fi->loaded__mu_da__mip_off_hi) >> 8) & 1;\r\n}\r\nstatic u64 nffw_fwinfo_mip_offset_get(const struct nffw_fwinfo *fi)\r\n{\r\nu64 mip_off_hi = le32_to_cpu(fi->loaded__mu_da__mip_off_hi);\r\nreturn (mip_off_hi & 0xFF) << 32 | le32_to_cpu(fi->mip_offset_lo);\r\n}\r\nstatic int nfp_mip_mu_locality_lsb(struct nfp_cpp *cpp)\r\n{\r\nunsigned int mode, addr40;\r\nu32 xpbaddr, imbcppat;\r\nint err;\r\nxpbaddr = 0x000a0000 + NFP_CPP_TARGET_MU * 4;\r\nerr = nfp_xpb_readl(cpp, xpbaddr, &imbcppat);\r\nif (err < 0)\r\nreturn err;\r\nmode = NFP_IMB_TGTADDRESSMODECFG_MODE_of(imbcppat);\r\naddr40 = !!(imbcppat & NFP_IMB_TGTADDRESSMODECFG_ADDRMODE);\r\nreturn nfp_cppat_mu_locality_lsb(mode, addr40);\r\n}\r\nstatic unsigned int\r\nnffw_res_fwinfos(struct nfp_nffw_info_data *fwinf, struct nffw_fwinfo **arr)\r\n{\r\nswitch (nffw_res_info_version_get(fwinf)) {\r\ncase 0:\r\ncase 1:\r\n*arr = &fwinf->info.v1.fwinfo[0];\r\nreturn NFFW_FWINFO_CNT_V1;\r\ncase 2:\r\n*arr = &fwinf->info.v2.fwinfo[0];\r\nreturn NFFW_FWINFO_CNT_V2;\r\ndefault:\r\n*arr = NULL;\r\nreturn 0;\r\n}\r\n}\r\nstruct nfp_nffw_info *nfp_nffw_info_open(struct nfp_cpp *cpp)\r\n{\r\nstruct nfp_nffw_info_data *fwinf;\r\nstruct nfp_nffw_info *state;\r\nu32 info_ver;\r\nint err;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn ERR_PTR(-ENOMEM);\r\nstate->res = nfp_resource_acquire(cpp, NFP_RESOURCE_NFP_NFFW);\r\nif (IS_ERR(state->res))\r\ngoto err_free;\r\nfwinf = &state->fwinf;\r\nif (sizeof(*fwinf) > nfp_resource_size(state->res))\r\ngoto err_release;\r\nerr = nfp_cpp_read(cpp, nfp_resource_cpp_id(state->res),\r\nnfp_resource_address(state->res),\r\nfwinf, sizeof(*fwinf));\r\nif (err < sizeof(*fwinf))\r\ngoto err_release;\r\nif (!nffw_res_flg_init_get(fwinf))\r\ngoto err_release;\r\ninfo_ver = nffw_res_info_version_get(fwinf);\r\nif (info_ver > NFFW_INFO_VERSION_CURRENT)\r\ngoto err_release;\r\nstate->cpp = cpp;\r\nreturn state;\r\nerr_release:\r\nnfp_resource_release(state->res);\r\nerr_free:\r\nkfree(state);\r\nreturn ERR_PTR(-EIO);\r\n}\r\nvoid nfp_nffw_info_close(struct nfp_nffw_info *state)\r\n{\r\nnfp_resource_release(state->res);\r\nkfree(state);\r\n}\r\nstatic struct nffw_fwinfo *nfp_nffw_info_fwid_first(struct nfp_nffw_info *state)\r\n{\r\nstruct nffw_fwinfo *fwinfo;\r\nunsigned int cnt, i;\r\ncnt = nffw_res_fwinfos(&state->fwinf, &fwinfo);\r\nif (!cnt)\r\nreturn NULL;\r\nfor (i = 0; i < cnt; i++)\r\nif (nffw_fwinfo_loaded_get(&fwinfo[i]))\r\nreturn &fwinfo[i];\r\nreturn NULL;\r\n}\r\nint nfp_nffw_info_mip_first(struct nfp_nffw_info *state, u32 *cpp_id, u64 *off)\r\n{\r\nstruct nffw_fwinfo *fwinfo;\r\nfwinfo = nfp_nffw_info_fwid_first(state);\r\nif (!fwinfo)\r\nreturn -EINVAL;\r\n*cpp_id = nffw_fwinfo_mip_cppid_get(fwinfo);\r\n*off = nffw_fwinfo_mip_offset_get(fwinfo);\r\nif (nffw_fwinfo_mip_mu_da_get(fwinfo)) {\r\nint locality_off;\r\nif (NFP_CPP_ID_TARGET_of(*cpp_id) != NFP_CPP_TARGET_MU)\r\nreturn 0;\r\nlocality_off = nfp_mip_mu_locality_lsb(state->cpp);\r\nif (locality_off < 0)\r\nreturn locality_off;\r\n*off &= ~(NFP_MU_ADDR_ACCESS_TYPE_MASK << locality_off);\r\n*off |= NFP_MU_ADDR_ACCESS_TYPE_DIRECT << locality_off;\r\n}\r\nreturn 0;\r\n}
