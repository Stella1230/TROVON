static inline void xd_set_err_code(struct rtsx_chip *chip, u8 err_code)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nxd_card->err_code = err_code;\r\n}\r\nstatic inline int xd_check_err_code(struct rtsx_chip *chip, u8 err_code)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nreturn (xd_card->err_code == err_code);\r\n}\r\nstatic int xd_set_init_para(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval;\r\nif (chip->asic_code)\r\nxd_card->xd_clock = 47;\r\nelse\r\nxd_card->xd_clock = CLK_50;\r\nretval = switch_clock(chip, xd_card->xd_clock);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_switch_clock(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval;\r\nretval = select_card(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = switch_clock(chip, xd_card->xd_clock);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_id(struct rtsx_chip *chip, u8 id_cmd, u8 *id_buf, u8 buf_len)\r\n{\r\nint retval, i;\r\nu8 *ptr;\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_DAT, 0xFF, id_cmd);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_ID);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nfor (i = 0; i < 4; i++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, (u16)(XD_ADDRESS1 + i), 0, 0);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 20);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nptr = rtsx_get_cmd_data(chip) + 1;\r\nif (id_buf && buf_len) {\r\nif (buf_len > 4)\r\nbuf_len = 4;\r\nmemcpy(id_buf, ptr, buf_len);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void xd_assign_phy_addr(struct rtsx_chip *chip, u32 addr, u8 mode)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nswitch (mode) {\r\ncase XD_RW_ADDR:\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS0, 0xFF, 0);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS1, 0xFF, (u8)addr);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS2,\r\n0xFF, (u8)(addr >> 8));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS3,\r\n0xFF, (u8)(addr >> 16));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, 0xFF,\r\nxd_card->addr_cycle |\r\nXD_CALC_ECC |\r\nXD_BA_NO_TRANSFORM);\r\nbreak;\r\ncase XD_ERASE_ADDR:\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS0, 0xFF, (u8)addr);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS1,\r\n0xFF, (u8)(addr >> 8));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_ADDRESS2,\r\n0xFF, (u8)(addr >> 16));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, 0xFF,\r\n(xd_card->addr_cycle - 1) | XD_CALC_ECC |\r\nXD_BA_NO_TRANSFORM);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nstatic int xd_read_redundant(struct rtsx_chip *chip, u32 page_addr,\r\nu8 *buf, int buf_len)\r\n{\r\nint retval, i;\r\nrtsx_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\r\n0xFF, XD_TRANSFER_START | XD_READ_REDUNDANT);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nfor (i = 0; i < 6; i++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, (u16)(XD_PAGE_STATUS + i),\r\n0, 0);\r\nfor (i = 0; i < 4; i++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, (u16)(XD_RESERVED0 + i),\r\n0, 0);\r\nrtsx_add_cmd(chip, READ_REG_CMD, XD_PARITY, 0, 0);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 500);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (buf && buf_len) {\r\nu8 *ptr = rtsx_get_cmd_data(chip) + 1;\r\nif (buf_len > 11)\r\nbuf_len = 11;\r\nmemcpy(buf, ptr, buf_len);\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_data_from_ppb(struct rtsx_chip *chip, int offset,\r\nu8 *buf, int buf_len)\r\n{\r\nint retval, i;\r\nif (!buf || (buf_len < 0)) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nrtsx_init_cmd(chip);\r\nfor (i = 0; i < buf_len; i++)\r\nrtsx_add_cmd(chip, READ_REG_CMD, PPBUF_BASE2 + offset + i,\r\n0, 0);\r\nretval = rtsx_send_cmd(chip, 0, 250);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nmemcpy(buf, rtsx_get_cmd_data(chip), buf_len);\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_cis(struct rtsx_chip *chip, u32 page_addr, u8 *buf,\r\nint buf_len)\r\n{\r\nint retval;\r\nu8 reg;\r\nif (!buf || (buf_len < 10)) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nrtsx_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE,\r\n0x01, PINGPONG_BUFFER);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\r\nXD_AUTO_CHK_DATA_STATUS, XD_AUTO_CHK_DATA_STATUS);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_PAGES);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER, XD_TRANSFER_END,\r\nXD_TRANSFER_END);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 250);\r\nif (retval == -ETIMEDOUT) {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = rtsx_read_register(chip, XD_PAGE_STATUS, &reg);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (reg != XD_GPG) {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = rtsx_read_register(chip, XD_CTL, &reg);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (!(reg & XD_ECC1_ERROR) || !(reg & XD_ECC1_UNCORRECTABLE)) {\r\nretval = xd_read_data_from_ppb(chip, 0, buf, buf_len);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (reg & XD_ECC1_ERROR) {\r\nu8 ecc_bit, ecc_byte;\r\nretval = rtsx_read_register(chip, XD_ECC_BIT1,\r\n&ecc_bit);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_read_register(chip, XD_ECC_BYTE1,\r\n&ecc_byte);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndev_dbg(rtsx_dev(chip), "ECC_BIT1 = 0x%x, ECC_BYTE1 = 0x%x\n",\r\necc_bit, ecc_byte);\r\nif (ecc_byte < buf_len) {\r\ndev_dbg(rtsx_dev(chip), "Before correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\nbuf[ecc_byte] ^= (1 << ecc_bit);\r\ndev_dbg(rtsx_dev(chip), "After correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\n}\r\n}\r\n} else if (!(reg & XD_ECC2_ERROR) || !(reg & XD_ECC2_UNCORRECTABLE)) {\r\nrtsx_clear_xd_error(chip);\r\nretval = xd_read_data_from_ppb(chip, 256, buf, buf_len);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (reg & XD_ECC2_ERROR) {\r\nu8 ecc_bit, ecc_byte;\r\nretval = rtsx_read_register(chip, XD_ECC_BIT2,\r\n&ecc_bit);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_read_register(chip, XD_ECC_BYTE2,\r\n&ecc_byte);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\ndev_dbg(rtsx_dev(chip), "ECC_BIT2 = 0x%x, ECC_BYTE2 = 0x%x\n",\r\necc_bit, ecc_byte);\r\nif (ecc_byte < buf_len) {\r\ndev_dbg(rtsx_dev(chip), "Before correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\nbuf[ecc_byte] ^= (1 << ecc_bit);\r\ndev_dbg(rtsx_dev(chip), "After correct: 0x%x\n",\r\nbuf[ecc_byte]);\r\n}\r\n}\r\n} else {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic void xd_fill_pull_ctl_disable(struct rtsx_chip *chip)\r\n{\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF,\r\nXD_D3_PD | XD_D2_PD | XD_D1_PD | XD_D0_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF,\r\nXD_D7_PD | XD_D6_PD | XD_D5_PD | XD_D4_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF,\r\nXD_WP_PD | XD_CE_PD | XD_CLE_PD | XD_CD_PU);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF,\r\nXD_RDY_PD | XD_WE_PD | XD_RE_PD | XD_ALE_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF,\r\nMS_INS_PU | SD_WP_PD | SD_CD_PU | SD_CMD_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF,\r\nMS_D5_PD | MS_D4_PD);\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nif (CHECK_BARO_PKG(chip, QFN)) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1,\r\n0xFF, 0x55);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2,\r\n0xFF, 0x55);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3,\r\n0xFF, 0x4B);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4,\r\n0xFF, 0x69);\r\n}\r\n}\r\n}\r\nstatic void xd_fill_pull_ctl_stage1_barossa(struct rtsx_chip *chip)\r\n{\r\nif (CHECK_BARO_PKG(chip, QFN)) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x4B);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\r\n}\r\n}\r\nstatic void xd_fill_pull_ctl_enable(struct rtsx_chip *chip)\r\n{\r\nif (CHECK_PID(chip, 0x5208)) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF,\r\nXD_D3_PD | XD_D2_PD | XD_D1_PD | XD_D0_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF,\r\nXD_D7_PD | XD_D6_PD | XD_D5_PD | XD_D4_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF,\r\nXD_WP_PD | XD_CE_PU | XD_CLE_PD | XD_CD_PU);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF,\r\nXD_RDY_PU | XD_WE_PU | XD_RE_PU | XD_ALE_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF,\r\nMS_INS_PU | SD_WP_PD | SD_CD_PU | SD_CMD_PD);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF,\r\nMS_D5_PD | MS_D4_PD);\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nif (CHECK_BARO_PKG(chip, QFN)) {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL1,\r\n0xFF, 0x55);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL2,\r\n0xFF, 0x55);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL3,\r\n0xFF, 0x53);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_PULL_CTL4,\r\n0xFF, 0xA9);\r\n}\r\n}\r\n}\r\nstatic int xd_pull_ctl_disable(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nif (CHECK_PID(chip, 0x5208)) {\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL1, 0xFF,\r\nXD_D3_PD |\r\nXD_D2_PD |\r\nXD_D1_PD |\r\nXD_D0_PD);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL2, 0xFF,\r\nXD_D7_PD |\r\nXD_D6_PD |\r\nXD_D5_PD |\r\nXD_D4_PD);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL3, 0xFF,\r\nXD_WP_PD |\r\nXD_CE_PD |\r\nXD_CLE_PD |\r\nXD_CD_PU);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL4, 0xFF,\r\nXD_RDY_PD |\r\nXD_WE_PD |\r\nXD_RE_PD |\r\nXD_ALE_PD);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL5, 0xFF,\r\nMS_INS_PU |\r\nSD_WP_PD |\r\nSD_CD_PU |\r\nSD_CMD_PD);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL6, 0xFF,\r\nMS_D5_PD | MS_D4_PD);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n} else if (CHECK_PID(chip, 0x5288)) {\r\nif (CHECK_BARO_PKG(chip, QFN)) {\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL1,\r\n0xFF, 0x55);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL2,\r\n0xFF, 0x55);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL3,\r\n0xFF, 0x4B);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nretval = rtsx_write_register(chip, CARD_PULL_CTL4,\r\n0xFF, 0x69);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int reset_xd(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval, i, j;\r\nu8 *ptr, id_buf[4], redunt[11];\r\nretval = select_card(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS, 0xFF,\r\nXD_PGSTS_NOT_FF);\r\nif (chip->asic_code) {\r\nif (!CHECK_PID(chip, 0x5288))\r\nxd_fill_pull_ctl_disable(chip);\r\nelse\r\nxd_fill_pull_ctl_stage1_barossa(chip);\r\n} else {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\r\n(FPGA_XD_PULL_CTL_EN1 & FPGA_XD_PULL_CTL_EN3) |\r\n0x20);\r\n}\r\nif (!chip->ft2_fast_mode)\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_INIT,\r\nXD_NO_AUTO_PWR_OFF, 0);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, 0);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 100);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (!chip->ft2_fast_mode) {\r\nretval = card_power_off(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nwait_timeout(250);\r\nrtsx_init_cmd(chip);\r\nif (chip->asic_code) {\r\nxd_fill_pull_ctl_enable(chip);\r\n} else {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\r\n(FPGA_XD_PULL_CTL_EN1 &\r\nFPGA_XD_PULL_CTL_EN2) |\r\n0x20);\r\n}\r\nretval = rtsx_send_cmd(chip, XD_CARD, 100);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = card_power_on(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n#ifdef SUPPORT_OCP\r\nwait_timeout(50);\r\nif (chip->ocp_stat & (SD_OC_NOW | SD_OC_EVER)) {\r\ndev_dbg(rtsx_dev(chip), "Over current, OCPSTAT is 0x%x\n",\r\nchip->ocp_stat);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n#endif\r\n}\r\nrtsx_init_cmd(chip);\r\nif (chip->ft2_fast_mode) {\r\nif (chip->asic_code) {\r\nxd_fill_pull_ctl_enable(chip);\r\n} else {\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, FPGA_PULL_CTL, 0xFF,\r\n(FPGA_XD_PULL_CTL_EN1 &\r\nFPGA_XD_PULL_CTL_EN2) |\r\n0x20);\r\n}\r\n}\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_OE, XD_OUTPUT_EN, XD_OUTPUT_EN);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CTL, XD_CE_DISEN, XD_CE_DISEN);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 100);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (!chip->ft2_fast_mode)\r\nwait_timeout(200);\r\nretval = xd_set_init_para(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nfor (i = 0; i < 4; i++) {\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_DTCTL, 0xFF,\r\nXD_TIME_SETUP_STEP * 3 +\r\nXD_TIME_RW_STEP * (2 + i) + XD_TIME_RWN_STEP * i);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CATCTL, 0xFF,\r\nXD_TIME_SETUP_STEP * 3 +\r\nXD_TIME_RW_STEP * (4 + i) +\r\nXD_TIME_RWN_STEP * (3 + i));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_RESET);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nrtsx_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\r\nrtsx_add_cmd(chip, READ_REG_CMD, XD_CTL, 0, 0);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 100);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nptr = rtsx_get_cmd_data(chip) + 1;\r\ndev_dbg(rtsx_dev(chip), "XD_DAT: 0x%x, XD_CTL: 0x%x\n",\r\nptr[0], ptr[1]);\r\nif (((ptr[0] & READY_FLAG) != READY_STATE) ||\r\n!(ptr[1] & XD_RDY))\r\ncontinue;\r\nretval = xd_read_id(chip, READ_ID, id_buf, 4);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\ndev_dbg(rtsx_dev(chip), "READ_ID: 0x%x 0x%x 0x%x 0x%x\n",\r\nid_buf[0], id_buf[1], id_buf[2], id_buf[3]);\r\nxd_card->device_code = id_buf[1];\r\nswitch (xd_card->device_code) {\r\ncase XD_4M_X8_512_1:\r\ncase XD_4M_X8_512_2:\r\nxd_card->block_shift = 4;\r\nxd_card->page_off = 0x0F;\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 1;\r\nxd_card->capacity = 8000;\r\nXD_SET_4MB(xd_card);\r\nbreak;\r\ncase XD_8M_X8_512:\r\nxd_card->block_shift = 4;\r\nxd_card->page_off = 0x0F;\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 1;\r\nxd_card->capacity = 16000;\r\nbreak;\r\ncase XD_16M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 1;\r\nxd_card->capacity = 32000;\r\nbreak;\r\ncase XD_32M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 3;\r\nxd_card->zone_cnt = 2;\r\nxd_card->capacity = 64000;\r\nbreak;\r\ncase XD_64M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 4;\r\nxd_card->capacity = 128000;\r\nbreak;\r\ncase XD_128M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 8;\r\nxd_card->capacity = 256000;\r\nbreak;\r\ncase XD_256M_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 16;\r\nxd_card->capacity = 512000;\r\nbreak;\r\ncase XD_512M_X8:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 32;\r\nxd_card->capacity = 1024000;\r\nbreak;\r\ncase xD_1G_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 64;\r\nxd_card->capacity = 2048000;\r\nbreak;\r\ncase xD_2G_X8_512:\r\nXD_PAGE_512(xd_card);\r\nxd_card->addr_cycle = 4;\r\nxd_card->zone_cnt = 128;\r\nxd_card->capacity = 4096000;\r\nbreak;\r\ndefault:\r\ncontinue;\r\n}\r\nfor (j = 0; j < 10; j++) {\r\nretval = xd_read_id(chip, READ_ID, id_buf, 4);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (id_buf[1] != xd_card->device_code)\r\nbreak;\r\n}\r\nif (j == 10)\r\nbreak;\r\n}\r\nif (i == 4) {\r\nxd_card->block_shift = 0;\r\nxd_card->page_off = 0;\r\nxd_card->addr_cycle = 0;\r\nxd_card->capacity = 0;\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = xd_read_id(chip, READ_xD_ID, id_buf, 4);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\ndev_dbg(rtsx_dev(chip), "READ_xD_ID: 0x%x 0x%x 0x%x 0x%x\n",\r\nid_buf[0], id_buf[1], id_buf[2], id_buf[3]);\r\nif (id_buf[2] != XD_ID_CODE) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nfor (i = 0; i < 24; i++) {\r\nu32 page_addr;\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\npage_addr = (u32)i << xd_card->block_shift;\r\nfor (j = 0; j < 3; j++) {\r\nretval = xd_read_redundant(chip, page_addr, redunt, 11);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\n}\r\nif (j == 3)\r\ncontinue;\r\nif (redunt[BLOCK_STATUS] != XD_GBLK)\r\ncontinue;\r\nj = 0;\r\nif (redunt[PAGE_STATUS] != XD_GPG) {\r\nfor (j = 1; j <= 8; j++) {\r\nretval = xd_read_redundant(chip, page_addr + j,\r\nredunt, 11);\r\nif (retval == STATUS_SUCCESS) {\r\nif (redunt[PAGE_STATUS] == XD_GPG)\r\nbreak;\r\n}\r\n}\r\nif (j == 9)\r\nbreak;\r\n}\r\nif ((redunt[BLOCK_STATUS] == XD_GBLK) &&\r\n(redunt[PARITY] & XD_BA1_ALL0)) {\r\nu8 buf[10];\r\npage_addr += j;\r\nretval = xd_read_cis(chip, page_addr, buf, 10);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif ((buf[0] == 0x01) && (buf[1] == 0x03) &&\r\n(buf[2] == 0xD9) &&\r\n(buf[3] == 0x01) && (buf[4] == 0xFF) &&\r\n(buf[5] == 0x18) && (buf[6] == 0x02) &&\r\n(buf[7] == 0xDF) && (buf[8] == 0x01) &&\r\n(buf[9] == 0x20)) {\r\nxd_card->cis_block = (u16)i;\r\n}\r\n}\r\nbreak;\r\n}\r\ndev_dbg(rtsx_dev(chip), "CIS block: 0x%x\n", xd_card->cis_block);\r\nif (xd_card->cis_block == 0xFFFF) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nchip->capacity[chip->card2lun[XD_CARD]] = xd_card->capacity;\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_check_data_blank(u8 *redunt)\r\n{\r\nint i;\r\nfor (i = 0; i < 6; i++) {\r\nif (redunt[PAGE_STATUS + i] != 0xFF)\r\nreturn 0;\r\n}\r\nif ((redunt[PARITY] & (XD_ECC1_ALL1 | XD_ECC2_ALL1))\r\n!= (XD_ECC1_ALL1 | XD_ECC2_ALL1))\r\nreturn 0;\r\nfor (i = 0; i < 4; i++) {\r\nif (redunt[RESERVED0 + i] != 0xFF)\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic u16 xd_load_log_block_addr(u8 *redunt)\r\n{\r\nu16 addr = 0xFFFF;\r\nif (redunt[PARITY] & XD_BA1_BA2_EQL)\r\naddr = ((u16)redunt[BLOCK_ADDR1_H] << 8) |\r\nredunt[BLOCK_ADDR1_L];\r\nelse if (redunt[PARITY] & XD_BA1_VALID)\r\naddr = ((u16)redunt[BLOCK_ADDR1_H] << 8) |\r\nredunt[BLOCK_ADDR1_L];\r\nelse if (redunt[PARITY] & XD_BA2_VALID)\r\naddr = ((u16)redunt[BLOCK_ADDR2_H] << 8) |\r\nredunt[BLOCK_ADDR2_L];\r\nreturn addr;\r\n}\r\nstatic int xd_init_l2p_tbl(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint size, i;\r\ndev_dbg(rtsx_dev(chip), "xd_init_l2p_tbl: zone_cnt = %d\n",\r\nxd_card->zone_cnt);\r\nif (xd_card->zone_cnt < 1) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nsize = xd_card->zone_cnt * sizeof(struct zone_entry);\r\ndev_dbg(rtsx_dev(chip), "Buffer size for l2p table is %d\n", size);\r\nxd_card->zone = vmalloc(size);\r\nif (!xd_card->zone) {\r\nrtsx_trace(chip);\r\nreturn STATUS_ERROR;\r\n}\r\nfor (i = 0; i < xd_card->zone_cnt; i++) {\r\nxd_card->zone[i].build_flag = 0;\r\nxd_card->zone[i].l2p_table = NULL;\r\nxd_card->zone[i].free_table = NULL;\r\nxd_card->zone[i].get_index = 0;\r\nxd_card->zone[i].set_index = 0;\r\nxd_card->zone[i].unused_blk_cnt = 0;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic inline void free_zone(struct zone_entry *zone)\r\n{\r\nif (!zone)\r\nreturn;\r\nzone->build_flag = 0;\r\nzone->set_index = 0;\r\nzone->get_index = 0;\r\nzone->unused_blk_cnt = 0;\r\nvfree(zone->l2p_table);\r\nzone->l2p_table = NULL;\r\nvfree(zone->free_table);\r\nzone->free_table = NULL;\r\n}\r\nstatic void xd_set_unused_block(struct rtsx_chip *chip, u32 phy_blk)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct zone_entry *zone;\r\nint zone_no;\r\nzone_no = (int)phy_blk >> 10;\r\nif (zone_no >= xd_card->zone_cnt) {\r\ndev_dbg(rtsx_dev(chip), "Set unused block to invalid zone (zone_no = %d, zone_cnt = %d)\n",\r\nzone_no, xd_card->zone_cnt);\r\nreturn;\r\n}\r\nzone = &xd_card->zone[zone_no];\r\nif (!zone->free_table) {\r\nif (xd_build_l2p_tbl(chip, zone_no) != STATUS_SUCCESS)\r\nreturn;\r\n}\r\nif ((zone->set_index >= XD_FREE_TABLE_CNT) ||\r\n(zone->set_index < 0)) {\r\nfree_zone(zone);\r\ndev_dbg(rtsx_dev(chip), "Set unused block fail, invalid set_index\n");\r\nreturn;\r\n}\r\ndev_dbg(rtsx_dev(chip), "Set unused block to index %d\n",\r\nzone->set_index);\r\nzone->free_table[zone->set_index++] = (u16)(phy_blk & 0x3ff);\r\nif (zone->set_index >= XD_FREE_TABLE_CNT)\r\nzone->set_index = 0;\r\nzone->unused_blk_cnt++;\r\n}\r\nstatic u32 xd_get_unused_block(struct rtsx_chip *chip, int zone_no)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct zone_entry *zone;\r\nu32 phy_blk;\r\nif (zone_no >= xd_card->zone_cnt) {\r\ndev_dbg(rtsx_dev(chip), "Get unused block from invalid zone (zone_no = %d, zone_cnt = %d)\n",\r\nzone_no, xd_card->zone_cnt);\r\nreturn BLK_NOT_FOUND;\r\n}\r\nzone = &xd_card->zone[zone_no];\r\nif ((zone->unused_blk_cnt == 0) ||\r\n(zone->set_index == zone->get_index)) {\r\nfree_zone(zone);\r\ndev_dbg(rtsx_dev(chip), "Get unused block fail, no unused block available\n");\r\nreturn BLK_NOT_FOUND;\r\n}\r\nif ((zone->get_index >= XD_FREE_TABLE_CNT) || (zone->get_index < 0)) {\r\nfree_zone(zone);\r\ndev_dbg(rtsx_dev(chip), "Get unused block fail, invalid get_index\n");\r\nreturn BLK_NOT_FOUND;\r\n}\r\ndev_dbg(rtsx_dev(chip), "Get unused block from index %d\n",\r\nzone->get_index);\r\nphy_blk = zone->free_table[zone->get_index];\r\nzone->free_table[zone->get_index++] = 0xFFFF;\r\nif (zone->get_index >= XD_FREE_TABLE_CNT)\r\nzone->get_index = 0;\r\nzone->unused_blk_cnt--;\r\nphy_blk += ((u32)(zone_no) << 10);\r\nreturn phy_blk;\r\n}\r\nstatic void xd_set_l2p_tbl(struct rtsx_chip *chip,\r\nint zone_no, u16 log_off, u16 phy_off)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct zone_entry *zone;\r\nzone = &xd_card->zone[zone_no];\r\nzone->l2p_table[log_off] = phy_off;\r\n}\r\nstatic u32 xd_get_l2p_tbl(struct rtsx_chip *chip, int zone_no, u16 log_off)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct zone_entry *zone;\r\nint retval;\r\nzone = &xd_card->zone[zone_no];\r\nif (zone->l2p_table[log_off] == 0xFFFF) {\r\nu32 phy_blk = 0;\r\nint i;\r\n#ifdef XD_DELAY_WRITE\r\nretval = xd_delay_write(chip);\r\nif (retval != STATUS_SUCCESS) {\r\ndev_dbg(rtsx_dev(chip), "In xd_get_l2p_tbl, delay write fail!\n");\r\nreturn BLK_NOT_FOUND;\r\n}\r\n#endif\r\nif (zone->unused_blk_cnt <= 0) {\r\ndev_dbg(rtsx_dev(chip), "No unused block!\n");\r\nreturn BLK_NOT_FOUND;\r\n}\r\nfor (i = 0; i < zone->unused_blk_cnt; i++) {\r\nphy_blk = xd_get_unused_block(chip, zone_no);\r\nif (phy_blk == BLK_NOT_FOUND) {\r\ndev_dbg(rtsx_dev(chip), "No unused block available!\n");\r\nreturn BLK_NOT_FOUND;\r\n}\r\nretval = xd_init_page(chip, phy_blk, log_off,\r\n0, xd_card->page_off + 1);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\n}\r\nif (i >= zone->unused_blk_cnt) {\r\ndev_dbg(rtsx_dev(chip), "No good unused block available!\n");\r\nreturn BLK_NOT_FOUND;\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16)(phy_blk & 0x3FF));\r\nreturn phy_blk;\r\n}\r\nreturn (u32)zone->l2p_table[log_off] + ((u32)(zone_no) << 10);\r\n}\r\nint reset_xd_card(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval;\r\nmemset(xd_card, 0, sizeof(struct xd_info));\r\nxd_card->block_shift = 0;\r\nxd_card->page_off = 0;\r\nxd_card->addr_cycle = 0;\r\nxd_card->capacity = 0;\r\nxd_card->zone_cnt = 0;\r\nxd_card->cis_block = 0xFFFF;\r\nxd_card->delay_write.delay_write_flag = 0;\r\nretval = enable_card_clock(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = reset_xd(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = xd_init_l2p_tbl(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_mark_bad_block(struct rtsx_chip *chip, u32 phy_blk)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval;\r\nu32 page_addr;\r\nu8 reg = 0;\r\ndev_dbg(rtsx_dev(chip), "mark block 0x%x as bad block\n", phy_blk);\r\nif (phy_blk == BLK_NOT_FOUND) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, XD_GPG);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, XD_LATER_BBLK);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR2_H, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR2_L, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED0, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED1, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED2, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_RESERVED3, 0xFF, 0xFF);\r\npage_addr = phy_blk << xd_card->block_shift;\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF,\r\nxd_card->page_off + 1);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_WRITE_REDUNDANT);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 500);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR)\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nelse\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_init_page(struct rtsx_chip *chip, u32 phy_blk,\r\nu16 logoff, u8 start_page, u8 end_page)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval;\r\nu32 page_addr;\r\nu8 reg = 0;\r\ndev_dbg(rtsx_dev(chip), "Init block 0x%x\n", phy_blk);\r\nif (start_page > end_page) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (phy_blk == BLK_NOT_FOUND) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, 0xFF);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H,\r\n0xFF, (u8)(logoff >> 8));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, (u8)logoff);\r\npage_addr = (phy_blk << xd_card->block_shift) + start_page;\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG,\r\nXD_BA_TRANSFORM, XD_BA_TRANSFORM);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT,\r\n0xFF, (end_page - start_page));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\r\n0xFF, XD_TRANSFER_START | XD_WRITE_REDUNDANT);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 500);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\n} else {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\n}\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_copy_page(struct rtsx_chip *chip, u32 old_blk, u32 new_blk,\r\nu8 start_page, u8 end_page)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nu32 old_page, new_page;\r\nu8 i, reg = 0;\r\nint retval;\r\ndev_dbg(rtsx_dev(chip), "Copy page from block 0x%x to block 0x%x\n",\r\nold_blk, new_blk);\r\nif (start_page > end_page) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif ((old_blk == BLK_NOT_FOUND) || (new_blk == BLK_NOT_FOUND)) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nold_page = (old_blk << xd_card->block_shift) + start_page;\r\nnew_page = (new_blk << xd_card->block_shift) + start_page;\r\nXD_CLR_BAD_NEWBLK(xd_card);\r\nretval = rtsx_write_register(chip, CARD_DATA_SOURCE, 0x01,\r\nPINGPONG_BUFFER);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nfor (i = start_page; i < end_page; i++) {\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nrtsx_clear_xd_error(chip);\r\nxd_set_err_code(chip, XD_NO_CARD);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nrtsx_init_cmd(chip);\r\nxd_assign_phy_addr(chip, old_page, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\r\nXD_AUTO_CHK_DATA_STATUS, 0);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_PAGES);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 500);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nreg = 0;\r\nrtsx_read_register(chip, XD_CTL, &reg);\r\nif (reg & (XD_ECC1_ERROR | XD_ECC2_ERROR)) {\r\nwait_timeout(100);\r\nif (detect_card_cd(chip,\r\nXD_CARD) != STATUS_SUCCESS) {\r\nxd_set_err_code(chip, XD_NO_CARD);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (((reg & (XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE)) ==\r\n(XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE)) ||\r\n((reg & (XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE)) ==\r\n(XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE))) {\r\nrtsx_write_register(chip,\r\nXD_PAGE_STATUS,\r\n0xFF,\r\nXD_BPG);\r\nrtsx_write_register(chip,\r\nXD_BLOCK_STATUS,\r\n0xFF,\r\nXD_GBLK);\r\nXD_SET_BAD_OLDBLK(xd_card);\r\ndev_dbg(rtsx_dev(chip), "old block 0x%x ecc error\n",\r\nold_blk);\r\n}\r\n} else {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (XD_CHK_BAD_OLDBLK(xd_card))\r\nrtsx_clear_xd_error(chip);\r\nrtsx_init_cmd(chip);\r\nxd_assign_phy_addr(chip, new_page, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, 1);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_WRITE_PAGES);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 300);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nreg = 0;\r\nrtsx_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, new_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nXD_SET_BAD_NEWBLK(xd_card);\r\n} else {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\n}\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nold_page++;\r\nnew_page++;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_reset_cmd(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nu8 *ptr;\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\r\n0xFF, XD_TRANSFER_START | XD_RESET);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nrtsx_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\r\nrtsx_add_cmd(chip, READ_REG_CMD, XD_CTL, 0, 0);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 100);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nptr = rtsx_get_cmd_data(chip) + 1;\r\nif (((ptr[0] & READY_FLAG) == READY_STATE) && (ptr[1] & XD_RDY))\r\nreturn STATUS_SUCCESS;\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nstatic int xd_erase_block(struct rtsx_chip *chip, u32 phy_blk)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nu32 page_addr;\r\nu8 reg = 0, *ptr;\r\nint i, retval;\r\nif (phy_blk == BLK_NOT_FOUND) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\npage_addr = phy_blk << xd_card->block_shift;\r\nfor (i = 0; i < 3; i++) {\r\nrtsx_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_ERASE_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_ERASE);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nrtsx_add_cmd(chip, READ_REG_CMD, XD_DAT, 0, 0);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 250);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nrtsx_read_register(chip, XD_DAT, &reg);\r\nif (reg & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nxd_set_err_code(chip, XD_ERASE_FAIL);\r\nretval = xd_reset_cmd(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\ncontinue;\r\n}\r\nptr = rtsx_get_cmd_data(chip) + 1;\r\nif (*ptr & PROGRAM_ERROR) {\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nxd_mark_bad_block(chip, phy_blk);\r\nxd_set_err_code(chip, XD_ERASE_FAIL);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nstatic int xd_build_l2p_tbl(struct rtsx_chip *chip, int zone_no)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct zone_entry *zone;\r\nint retval;\r\nu32 start, end, i;\r\nu16 max_logoff, cur_fst_page_logoff;\r\nu16 cur_lst_page_logoff, ent_lst_page_logoff;\r\nu8 redunt[11];\r\ndev_dbg(rtsx_dev(chip), "xd_build_l2p_tbl: %d\n", zone_no);\r\nif (!xd_card->zone) {\r\nretval = xd_init_l2p_tbl(chip);\r\nif (retval != STATUS_SUCCESS)\r\nreturn retval;\r\n}\r\nif (xd_card->zone[zone_no].build_flag) {\r\ndev_dbg(rtsx_dev(chip), "l2p table of zone %d has been built\n",\r\nzone_no);\r\nreturn STATUS_SUCCESS;\r\n}\r\nzone = &xd_card->zone[zone_no];\r\nif (!zone->l2p_table) {\r\nzone->l2p_table = vmalloc(2000);\r\nif (!zone->l2p_table) {\r\nrtsx_trace(chip);\r\ngoto build_fail;\r\n}\r\n}\r\nmemset((u8 *)(zone->l2p_table), 0xff, 2000);\r\nif (!zone->free_table) {\r\nzone->free_table = vmalloc(XD_FREE_TABLE_CNT * 2);\r\nif (!zone->free_table) {\r\nrtsx_trace(chip);\r\ngoto build_fail;\r\n}\r\n}\r\nmemset((u8 *)(zone->free_table), 0xff, XD_FREE_TABLE_CNT * 2);\r\nif (zone_no == 0) {\r\nif (xd_card->cis_block == 0xFFFF)\r\nstart = 0;\r\nelse\r\nstart = xd_card->cis_block + 1;\r\nif (XD_CHK_4MB(xd_card)) {\r\nend = 0x200;\r\nmax_logoff = 499;\r\n} else {\r\nend = 0x400;\r\nmax_logoff = 999;\r\n}\r\n} else {\r\nstart = (u32)(zone_no) << 10;\r\nend = (u32)(zone_no + 1) << 10;\r\nmax_logoff = 999;\r\n}\r\ndev_dbg(rtsx_dev(chip), "start block 0x%x, end block 0x%x\n",\r\nstart, end);\r\nzone->set_index = 0;\r\nzone->get_index = 0;\r\nzone->unused_blk_cnt = 0;\r\nfor (i = start; i < end; i++) {\r\nu32 page_addr = i << xd_card->block_shift;\r\nu32 phy_block;\r\nretval = xd_read_redundant(chip, page_addr, redunt, 11);\r\nif (retval != STATUS_SUCCESS)\r\ncontinue;\r\nif (redunt[BLOCK_STATUS] != 0xFF) {\r\ndev_dbg(rtsx_dev(chip), "bad block\n");\r\ncontinue;\r\n}\r\nif (xd_check_data_blank(redunt)) {\r\ndev_dbg(rtsx_dev(chip), "blank block\n");\r\nxd_set_unused_block(chip, i);\r\ncontinue;\r\n}\r\ncur_fst_page_logoff = xd_load_log_block_addr(redunt);\r\nif ((cur_fst_page_logoff == 0xFFFF) ||\r\n(cur_fst_page_logoff > max_logoff)) {\r\nretval = xd_erase_block(chip, i);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, i);\r\ncontinue;\r\n}\r\nif ((zone_no == 0) && (cur_fst_page_logoff == 0) &&\r\n(redunt[PAGE_STATUS] != XD_GPG))\r\nXD_SET_MBR_FAIL(xd_card);\r\nif (zone->l2p_table[cur_fst_page_logoff] == 0xFFFF) {\r\nzone->l2p_table[cur_fst_page_logoff] = (u16)(i & 0x3FF);\r\ncontinue;\r\n}\r\nphy_block = zone->l2p_table[cur_fst_page_logoff] +\r\n((u32)((zone_no) << 10));\r\npage_addr = ((i + 1) << xd_card->block_shift) - 1;\r\nretval = xd_read_redundant(chip, page_addr, redunt, 11);\r\nif (retval != STATUS_SUCCESS)\r\ncontinue;\r\ncur_lst_page_logoff = xd_load_log_block_addr(redunt);\r\nif (cur_lst_page_logoff == cur_fst_page_logoff) {\r\nint m;\r\npage_addr = ((phy_block + 1) <<\r\nxd_card->block_shift) - 1;\r\nfor (m = 0; m < 3; m++) {\r\nretval = xd_read_redundant(chip, page_addr,\r\nredunt, 11);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\n}\r\nif (m == 3) {\r\nzone->l2p_table[cur_fst_page_logoff] =\r\n(u16)(i & 0x3FF);\r\nretval = xd_erase_block(chip, phy_block);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, phy_block);\r\ncontinue;\r\n}\r\nent_lst_page_logoff = xd_load_log_block_addr(redunt);\r\nif (ent_lst_page_logoff != cur_fst_page_logoff) {\r\nzone->l2p_table[cur_fst_page_logoff] =\r\n(u16)(i & 0x3FF);\r\nretval = xd_erase_block(chip, phy_block);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, phy_block);\r\ncontinue;\r\n} else {\r\nretval = xd_erase_block(chip, i);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, i);\r\n}\r\n} else {\r\nretval = xd_erase_block(chip, i);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, i);\r\n}\r\n}\r\nif (XD_CHK_4MB(xd_card))\r\nend = 500;\r\nelse\r\nend = 1000;\r\ni = 0;\r\nfor (start = 0; start < end; start++) {\r\nif (zone->l2p_table[start] == 0xFFFF)\r\ni++;\r\n}\r\ndev_dbg(rtsx_dev(chip), "Block count %d, invalid L2P entry %d\n",\r\nend, i);\r\ndev_dbg(rtsx_dev(chip), "Total unused block: %d\n",\r\nzone->unused_blk_cnt);\r\nif ((zone->unused_blk_cnt - i) < 1)\r\nchip->card_wp |= XD_CARD;\r\nzone->build_flag = 1;\r\nreturn STATUS_SUCCESS;\r\nbuild_fail:\r\nvfree(zone->l2p_table);\r\nzone->l2p_table = NULL;\r\nvfree(zone->free_table);\r\nzone->free_table = NULL;\r\nreturn STATUS_FAIL;\r\n}\r\nstatic int xd_send_cmd(struct rtsx_chip *chip, u8 cmd)\r\n{\r\nint retval;\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_DAT, 0xFF, cmd);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_SET_CMD);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nretval = rtsx_send_cmd(chip, XD_CARD, 200);\r\nif (retval < 0) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_read_multiple_pages(struct rtsx_chip *chip, u32 phy_blk,\r\nu32 log_blk, u8 start_page, u8 end_page,\r\nu8 *buf, unsigned int *index,\r\nunsigned int *offset)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nu32 page_addr, new_blk;\r\nu16 log_off;\r\nu8 reg_val, page_cnt;\r\nint zone_no, retval, i;\r\nif (start_page > end_page)\r\ngoto status_fail;\r\npage_cnt = end_page - start_page;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16)(log_blk % 1000);\r\nif ((phy_blk & 0x3FF) == 0x3FF) {\r\nfor (i = 0; i < 256; i++) {\r\npage_addr = ((u32)i) << xd_card->block_shift;\r\nretval = xd_read_redundant(chip, page_addr, NULL, 0);\r\nif (retval == STATUS_SUCCESS)\r\nbreak;\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nxd_set_err_code(chip, XD_NO_CARD);\r\ngoto status_fail;\r\n}\r\n}\r\n}\r\npage_addr = (phy_blk << xd_card->block_shift) + start_page;\r\nrtsx_init_cmd(chip);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_PPB_TO_SIE, XD_PPB_TO_SIE);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, page_cnt);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CHK_DATA_STATUS,\r\nXD_AUTO_CHK_DATA_STATUS, XD_AUTO_CHK_DATA_STATUS);\r\ntrans_dma_enable(chip->srb->sc_data_direction, chip,\r\npage_cnt * 512, DMA_512);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER, 0xFF,\r\nXD_TRANSFER_START | XD_READ_PAGES);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END | XD_PPB_EMPTY,\r\nXD_TRANSFER_END | XD_PPB_EMPTY);\r\nrtsx_send_cmd_no_wait(chip);\r\nretval = rtsx_transfer_data_partial(chip, XD_CARD, buf, page_cnt * 512,\r\nscsi_sg_count(chip->srb),\r\nindex, offset, DMA_FROM_DEVICE,\r\nchip->xd_timeout);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nif (retval == -ETIMEDOUT) {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\ngoto status_fail;\r\n} else {\r\nrtsx_trace(chip);\r\ngoto fail;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\nfail:\r\nretval = rtsx_read_register(chip, XD_PAGE_STATUS, &reg_val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (reg_val != XD_GPG)\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nretval = rtsx_read_register(chip, XD_CTL, &reg_val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (((reg_val & (XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE)) ==\r\n(XD_ECC1_ERROR | XD_ECC1_UNCORRECTABLE)) ||\r\n((reg_val & (XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE)) ==\r\n(XD_ECC2_ERROR | XD_ECC2_UNCORRECTABLE))) {\r\nwait_timeout(100);\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nxd_set_err_code(chip, XD_NO_CARD);\r\ngoto status_fail;\r\n}\r\nxd_set_err_code(chip, XD_ECC_ERROR);\r\nnew_blk = xd_get_unused_block(chip, zone_no);\r\nif (new_blk == NO_NEW_BLK) {\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\ngoto status_fail;\r\n}\r\nretval = xd_copy_page(chip, phy_blk, new_blk, 0,\r\nxd_card->page_off + 1);\r\nif (retval != STATUS_SUCCESS) {\r\nif (!XD_CHK_BAD_NEWBLK(xd_card)) {\r\nretval = xd_erase_block(chip, new_blk);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, new_blk);\r\n} else {\r\nXD_CLR_BAD_NEWBLK(xd_card);\r\n}\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\ngoto status_fail;\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16)(new_blk & 0x3FF));\r\nxd_erase_block(chip, phy_blk);\r\nxd_mark_bad_block(chip, phy_blk);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n}\r\nstatus_fail:\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nstatic int xd_finish_write(struct rtsx_chip *chip,\r\nu32 old_blk, u32 new_blk, u32 log_blk, u8 page_off)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval, zone_no;\r\nu16 log_off;\r\ndev_dbg(rtsx_dev(chip), "xd_finish_write, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\n",\r\nold_blk, new_blk, log_blk);\r\nif (page_off > xd_card->page_off) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16)(log_blk % 1000);\r\nif (old_blk == BLK_NOT_FOUND) {\r\nretval = xd_init_page(chip, new_blk, log_off,\r\npage_off, xd_card->page_off + 1);\r\nif (retval != STATUS_SUCCESS) {\r\nretval = xd_erase_block(chip, new_blk);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, new_blk);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else {\r\nretval = xd_copy_page(chip, old_blk, new_blk,\r\npage_off, xd_card->page_off + 1);\r\nif (retval != STATUS_SUCCESS) {\r\nif (!XD_CHK_BAD_NEWBLK(xd_card)) {\r\nretval = xd_erase_block(chip, new_blk);\r\nif (retval == STATUS_SUCCESS)\r\nxd_set_unused_block(chip, new_blk);\r\n}\r\nXD_CLR_BAD_NEWBLK(xd_card);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = xd_erase_block(chip, old_blk);\r\nif (retval == STATUS_SUCCESS) {\r\nif (XD_CHK_BAD_OLDBLK(xd_card)) {\r\nxd_mark_bad_block(chip, old_blk);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n} else {\r\nxd_set_unused_block(chip, old_blk);\r\n}\r\n} else {\r\nxd_set_err_code(chip, XD_NO_ERROR);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n}\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16)(new_blk & 0x3FF));\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_prepare_write(struct rtsx_chip *chip,\r\nu32 old_blk, u32 new_blk, u32 log_blk, u8 page_off)\r\n{\r\nint retval;\r\ndev_dbg(rtsx_dev(chip), "%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x, page_off = %d\n",\r\n__func__, old_blk, new_blk, log_blk, (int)page_off);\r\nif (page_off) {\r\nretval = xd_copy_page(chip, old_blk, new_blk, 0, page_off);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nstatic int xd_write_multiple_pages(struct rtsx_chip *chip, u32 old_blk,\r\nu32 new_blk, u32 log_blk, u8 start_page,\r\nu8 end_page, u8 *buf, unsigned int *index,\r\nunsigned int *offset)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nu32 page_addr;\r\nint zone_no, retval;\r\nu16 log_off;\r\nu8 page_cnt, reg_val;\r\ndev_dbg(rtsx_dev(chip), "%s, old_blk = 0x%x, new_blk = 0x%x, log_blk = 0x%x\n",\r\n__func__, old_blk, new_blk, log_blk);\r\nif (start_page > end_page)\r\ngoto status_fail;\r\npage_cnt = end_page - start_page;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16)(log_blk % 1000);\r\npage_addr = (new_blk << xd_card->block_shift) + start_page;\r\nretval = xd_send_cmd(chip, READ1_1);\r\nif (retval != STATUS_SUCCESS)\r\ngoto status_fail;\r\nrtsx_init_cmd(chip);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_H,\r\n0xFF, (u8)(log_off >> 8));\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_ADDR1_L, 0xFF, (u8)log_off);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_BLOCK_STATUS, 0xFF, XD_GBLK);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_STATUS, 0xFF, XD_GPG);\r\nxd_assign_phy_addr(chip, page_addr, XD_RW_ADDR);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_CFG, XD_BA_TRANSFORM,\r\nXD_BA_TRANSFORM);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_PAGE_CNT, 0xFF, page_cnt);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, CARD_DATA_SOURCE, 0x01, RING_BUFFER);\r\ntrans_dma_enable(chip->srb->sc_data_direction, chip,\r\npage_cnt * 512, DMA_512);\r\nrtsx_add_cmd(chip, WRITE_REG_CMD, XD_TRANSFER,\r\n0xFF, XD_TRANSFER_START | XD_WRITE_PAGES);\r\nrtsx_add_cmd(chip, CHECK_REG_CMD, XD_TRANSFER,\r\nXD_TRANSFER_END, XD_TRANSFER_END);\r\nrtsx_send_cmd_no_wait(chip);\r\nretval = rtsx_transfer_data_partial(chip, XD_CARD, buf, page_cnt * 512,\r\nscsi_sg_count(chip->srb),\r\nindex, offset, DMA_TO_DEVICE, chip->xd_timeout);\r\nif (retval < 0) {\r\nrtsx_clear_xd_error(chip);\r\nif (retval == -ETIMEDOUT) {\r\nxd_set_err_code(chip, XD_TO_ERROR);\r\ngoto status_fail;\r\n} else {\r\nrtsx_trace(chip);\r\ngoto fail;\r\n}\r\n}\r\nif (end_page == (xd_card->page_off + 1)) {\r\nxd_card->delay_write.delay_write_flag = 0;\r\nif (old_blk != BLK_NOT_FOUND) {\r\nretval = xd_erase_block(chip, old_blk);\r\nif (retval == STATUS_SUCCESS) {\r\nif (XD_CHK_BAD_OLDBLK(xd_card)) {\r\nxd_mark_bad_block(chip, old_blk);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n} else {\r\nxd_set_unused_block(chip, old_blk);\r\n}\r\n} else {\r\nxd_set_err_code(chip, XD_NO_ERROR);\r\nXD_CLR_BAD_OLDBLK(xd_card);\r\n}\r\n}\r\nxd_set_l2p_tbl(chip, zone_no, log_off, (u16)(new_blk & 0x3FF));\r\n}\r\nreturn STATUS_SUCCESS;\r\nfail:\r\nretval = rtsx_read_register(chip, XD_DAT, &reg_val);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (reg_val & PROGRAM_ERROR) {\r\nxd_set_err_code(chip, XD_PRG_ERROR);\r\nxd_mark_bad_block(chip, new_blk);\r\n}\r\nstatus_fail:\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nint xd_delay_write(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nstruct xd_delay_write_tag *delay_write = &xd_card->delay_write;\r\nint retval;\r\nif (delay_write->delay_write_flag) {\r\ndev_dbg(rtsx_dev(chip), "xd_delay_write\n");\r\nretval = xd_switch_clock(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\ndelay_write->delay_write_flag = 0;\r\nretval = xd_finish_write(chip,\r\ndelay_write->old_phyblock,\r\ndelay_write->new_phyblock,\r\ndelay_write->logblock,\r\ndelay_write->pageoff);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint xd_rw(struct scsi_cmnd *srb, struct rtsx_chip *chip,\r\nu32 start_sector, u16 sector_cnt)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nunsigned int lun = SCSI_LUN(srb);\r\n#ifdef XD_DELAY_WRITE\r\nstruct xd_delay_write_tag *delay_write = &xd_card->delay_write;\r\n#endif\r\nint retval, zone_no;\r\nunsigned int index = 0, offset = 0;\r\nu32 log_blk, old_blk = 0, new_blk = 0;\r\nu16 log_off, total_sec_cnt = sector_cnt;\r\nu8 start_page, end_page = 0, page_cnt;\r\nu8 *ptr;\r\nxd_set_err_code(chip, XD_NO_ERROR);\r\nxd_card->cleanup_counter = 0;\r\ndev_dbg(rtsx_dev(chip), "xd_rw: scsi_sg_count = %d\n",\r\nscsi_sg_count(srb));\r\nptr = (u8 *)scsi_sglist(srb);\r\nretval = xd_switch_clock(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nlog_blk = start_sector >> xd_card->block_shift;\r\nstart_page = (u8)start_sector & xd_card->page_off;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16)(log_blk % 1000);\r\nif (xd_card->zone[zone_no].build_flag == 0) {\r\nretval = xd_build_l2p_tbl(chip, zone_no);\r\nif (retval != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nif (srb->sc_data_direction == DMA_TO_DEVICE) {\r\n#ifdef XD_DELAY_WRITE\r\nif (delay_write->delay_write_flag &&\r\n(delay_write->logblock == log_blk) &&\r\n(start_page > delay_write->pageoff)) {\r\ndelay_write->delay_write_flag = 0;\r\nif (delay_write->old_phyblock != BLK_NOT_FOUND) {\r\nretval = xd_copy_page(chip,\r\ndelay_write->old_phyblock,\r\ndelay_write->new_phyblock,\r\ndelay_write->pageoff,\r\nstart_page);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nold_blk = delay_write->old_phyblock;\r\nnew_blk = delay_write->new_phyblock;\r\n} else if (delay_write->delay_write_flag &&\r\n(delay_write->logblock == log_blk) &&\r\n(start_page == delay_write->pageoff)) {\r\ndelay_write->delay_write_flag = 0;\r\nold_blk = delay_write->old_phyblock;\r\nnew_blk = delay_write->new_phyblock;\r\n} else {\r\nretval = xd_delay_write(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n#endif\r\nold_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\r\nnew_blk = xd_get_unused_block(chip, zone_no);\r\nif ((old_blk == BLK_NOT_FOUND) ||\r\n(new_blk == BLK_NOT_FOUND)) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = xd_prepare_write(chip, old_blk, new_blk,\r\nlog_blk, start_page);\r\nif (retval != STATUS_SUCCESS) {\r\nif (detect_card_cd(chip, XD_CARD) !=\r\nSTATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n#ifdef XD_DELAY_WRITE\r\n}\r\n#endif\r\n} else {\r\n#ifdef XD_DELAY_WRITE\r\nretval = xd_delay_write(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n#endif\r\nold_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\r\nif (old_blk == BLK_NOT_FOUND) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\ndev_dbg(rtsx_dev(chip), "old_blk = 0x%x\n", old_blk);\r\nwhile (total_sec_cnt) {\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif ((start_page + total_sec_cnt) > (xd_card->page_off + 1))\r\nend_page = xd_card->page_off + 1;\r\nelse\r\nend_page = start_page + (u8)total_sec_cnt;\r\npage_cnt = end_page - start_page;\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE) {\r\nretval = xd_read_multiple_pages(chip, old_blk, log_blk,\r\nstart_page, end_page,\r\nptr, &index, &offset);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else {\r\nretval = xd_write_multiple_pages(chip, old_blk,\r\nnew_blk, log_blk,\r\nstart_page, end_page,\r\nptr, &index, &offset);\r\nif (retval != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\ntotal_sec_cnt -= page_cnt;\r\nif (scsi_sg_count(srb) == 0)\r\nptr += page_cnt * 512;\r\nif (total_sec_cnt == 0)\r\nbreak;\r\nlog_blk++;\r\nzone_no = (int)(log_blk / 1000);\r\nlog_off = (u16)(log_blk % 1000);\r\nif (xd_card->zone[zone_no].build_flag == 0) {\r\nretval = xd_build_l2p_tbl(chip, zone_no);\r\nif (retval != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nold_blk = xd_get_l2p_tbl(chip, zone_no, log_off);\r\nif (old_blk == BLK_NOT_FOUND) {\r\nif (srb->sc_data_direction == DMA_FROM_DEVICE)\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_UNRECOVER_READ_ERR);\r\nelse\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nif (srb->sc_data_direction == DMA_TO_DEVICE) {\r\nnew_blk = xd_get_unused_block(chip, zone_no);\r\nif (new_blk == BLK_NOT_FOUND) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n}\r\nstart_page = 0;\r\n}\r\nif ((srb->sc_data_direction == DMA_TO_DEVICE) &&\r\n(end_page != (xd_card->page_off + 1))) {\r\n#ifdef XD_DELAY_WRITE\r\ndelay_write->delay_write_flag = 1;\r\ndelay_write->old_phyblock = old_blk;\r\ndelay_write->new_phyblock = new_blk;\r\ndelay_write->logblock = log_blk;\r\ndelay_write->pageoff = end_page;\r\n#else\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nchip->card_fail |= XD_CARD;\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = xd_finish_write(chip, old_blk, new_blk,\r\nlog_blk, end_page);\r\nif (retval != STATUS_SUCCESS) {\r\nif (detect_card_cd(chip, XD_CARD) != STATUS_SUCCESS) {\r\nset_sense_type(chip, lun,\r\nSENSE_TYPE_MEDIA_NOT_PRESENT);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nset_sense_type(chip, lun, SENSE_TYPE_MEDIA_WRITE_ERR);\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n#endif\r\n}\r\nscsi_set_resid(srb, 0);\r\nreturn STATUS_SUCCESS;\r\n}\r\nvoid xd_free_l2p_tbl(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint i = 0;\r\nif (xd_card->zone) {\r\nfor (i = 0; i < xd_card->zone_cnt; i++) {\r\nvfree(xd_card->zone[i].l2p_table);\r\nxd_card->zone[i].l2p_table = NULL;\r\nvfree(xd_card->zone[i].free_table);\r\nxd_card->zone[i].free_table = NULL;\r\n}\r\nvfree(xd_card->zone);\r\nxd_card->zone = NULL;\r\n}\r\n}\r\nvoid xd_cleanup_work(struct rtsx_chip *chip)\r\n{\r\n#ifdef XD_DELAY_WRITE\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nif (xd_card->delay_write.delay_write_flag) {\r\ndev_dbg(rtsx_dev(chip), "xD: delay write\n");\r\nxd_delay_write(chip);\r\nxd_card->cleanup_counter = 0;\r\n}\r\n#endif\r\n}\r\nint xd_power_off_card3v3(struct rtsx_chip *chip)\r\n{\r\nint retval;\r\nretval = disable_card_clock(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nretval = rtsx_write_register(chip, CARD_OE, XD_OUTPUT_EN, 0);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\nif (!chip->ft2_fast_mode) {\r\nretval = card_power_off(chip, XD_CARD);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nwait_timeout(50);\r\n}\r\nif (chip->asic_code) {\r\nretval = xd_pull_ctl_disable(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\n} else {\r\nretval = rtsx_write_register(chip, FPGA_PULL_CTL, 0xFF, 0xDF);\r\nif (retval) {\r\nrtsx_trace(chip);\r\nreturn retval;\r\n}\r\n}\r\nreturn STATUS_SUCCESS;\r\n}\r\nint release_xd_card(struct rtsx_chip *chip)\r\n{\r\nstruct xd_info *xd_card = &chip->xd_card;\r\nint retval;\r\nchip->card_ready &= ~XD_CARD;\r\nchip->card_fail &= ~XD_CARD;\r\nchip->card_wp &= ~XD_CARD;\r\nxd_card->delay_write.delay_write_flag = 0;\r\nxd_free_l2p_tbl(chip);\r\nretval = xd_power_off_card3v3(chip);\r\nif (retval != STATUS_SUCCESS) {\r\nrtsx_trace(chip);\r\nreturn STATUS_FAIL;\r\n}\r\nreturn STATUS_SUCCESS;\r\n}
