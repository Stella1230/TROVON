static void xgene_edac_pcp_rd(struct xgene_edac *edac, u32 reg, u32 *val)\r\n{\r\n*val = readl(edac->pcp_csr + reg);\r\n}\r\nstatic void xgene_edac_pcp_clrbits(struct xgene_edac *edac, u32 reg,\r\nu32 bits_mask)\r\n{\r\nu32 val;\r\nspin_lock(&edac->lock);\r\nval = readl(edac->pcp_csr + reg);\r\nval &= ~bits_mask;\r\nwritel(val, edac->pcp_csr + reg);\r\nspin_unlock(&edac->lock);\r\n}\r\nstatic void xgene_edac_pcp_setbits(struct xgene_edac *edac, u32 reg,\r\nu32 bits_mask)\r\n{\r\nu32 val;\r\nspin_lock(&edac->lock);\r\nval = readl(edac->pcp_csr + reg);\r\nval |= bits_mask;\r\nwritel(val, edac->pcp_csr + reg);\r\nspin_unlock(&edac->lock);\r\n}\r\nstatic ssize_t xgene_edac_mc_err_inject_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct mem_ctl_info *mci = file->private_data;\r\nstruct xgene_edac_mc_ctx *ctx = mci->pvt_info;\r\nint i;\r\nfor (i = 0; i < MCU_MAX_RANK; i++) {\r\nwritel(MCU_ESRR_MULTUCERR_MASK | MCU_ESRR_BACKUCERR_MASK |\r\nMCU_ESRR_DEMANDUCERR_MASK | MCU_ESRR_CERR_MASK,\r\nctx->mcu_csr + MCUESRRA0 + i * MCU_RANK_STRIDE);\r\n}\r\nreturn count;\r\n}\r\nstatic void xgene_edac_mc_create_debugfs_node(struct mem_ctl_info *mci)\r\n{\r\nif (!IS_ENABLED(CONFIG_EDAC_DEBUG))\r\nreturn;\r\nif (!mci->debugfs)\r\nreturn;\r\nedac_debugfs_create_file("inject_ctrl", S_IWUSR, mci->debugfs, mci,\r\n&xgene_edac_mc_debug_inject_fops);\r\n}\r\nstatic void xgene_edac_mc_check(struct mem_ctl_info *mci)\r\n{\r\nstruct xgene_edac_mc_ctx *ctx = mci->pvt_info;\r\nunsigned int pcp_hp_stat;\r\nunsigned int pcp_lp_stat;\r\nu32 reg;\r\nu32 rank;\r\nu32 bank;\r\nu32 count;\r\nu32 col_row;\r\nxgene_edac_pcp_rd(ctx->edac, PCPHPERRINTSTS, &pcp_hp_stat);\r\nxgene_edac_pcp_rd(ctx->edac, PCPLPERRINTSTS, &pcp_lp_stat);\r\nif (!((MCU_UNCORR_ERR_MASK & pcp_hp_stat) ||\r\n(MCU_CTL_ERR_MASK & pcp_hp_stat) ||\r\n(MCU_CORR_ERR_MASK & pcp_lp_stat)))\r\nreturn;\r\nfor (rank = 0; rank < MCU_MAX_RANK; rank++) {\r\nreg = readl(ctx->mcu_csr + MCUESRR0 + rank * MCU_RANK_STRIDE);\r\nif (reg & (MCU_ESRR_DEMANDUCERR_MASK |\r\nMCU_ESRR_BACKUCERR_MASK)) {\r\nedac_mc_chipset_printk(mci, KERN_ERR, "X-Gene",\r\n"MCU uncorrectable error at rank %d\n", rank);\r\nedac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci,\r\n1, 0, 0, 0, 0, 0, -1, mci->ctl_name, "");\r\n}\r\nif (reg & MCU_ESRR_CERR_MASK) {\r\nbank = readl(ctx->mcu_csr + MCUEBLRR0 +\r\nrank * MCU_RANK_STRIDE);\r\ncol_row = readl(ctx->mcu_csr + MCUERCRR0 +\r\nrank * MCU_RANK_STRIDE);\r\ncount = readl(ctx->mcu_csr + MCUSBECNT0 +\r\nrank * MCU_RANK_STRIDE);\r\nedac_mc_chipset_printk(mci, KERN_WARNING, "X-Gene",\r\n"MCU correctable error at rank %d bank %d column %d row %d count %d\n",\r\nrank, MCU_EBLRR_ERRBANK_RD(bank),\r\nMCU_ERCRR_ERRCOL_RD(col_row),\r\nMCU_ERCRR_ERRROW_RD(col_row),\r\nMCU_SBECNT_COUNT(count));\r\nedac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci,\r\n1, 0, 0, 0, 0, 0, -1, mci->ctl_name, "");\r\n}\r\nwritel(0x0, ctx->mcu_csr + MCUEBLRR0 + rank * MCU_RANK_STRIDE);\r\nwritel(0x0, ctx->mcu_csr + MCUERCRR0 + rank * MCU_RANK_STRIDE);\r\nwritel(0x0, ctx->mcu_csr + MCUSBECNT0 +\r\nrank * MCU_RANK_STRIDE);\r\nwritel(reg, ctx->mcu_csr + MCUESRR0 + rank * MCU_RANK_STRIDE);\r\n}\r\nreg = readl(ctx->mcu_csr + MCUGESR);\r\nif (reg) {\r\nif (reg & MCU_GESR_ADDRNOMATCH_ERR_MASK)\r\nedac_mc_chipset_printk(mci, KERN_WARNING, "X-Gene",\r\n"MCU address miss-match error\n");\r\nif (reg & MCU_GESR_ADDRMULTIMATCH_ERR_MASK)\r\nedac_mc_chipset_printk(mci, KERN_WARNING, "X-Gene",\r\n"MCU address multi-match error\n");\r\nwritel(reg, ctx->mcu_csr + MCUGESR);\r\n}\r\n}\r\nstatic void xgene_edac_mc_irq_ctl(struct mem_ctl_info *mci, bool enable)\r\n{\r\nstruct xgene_edac_mc_ctx *ctx = mci->pvt_info;\r\nunsigned int val;\r\nif (edac_op_state != EDAC_OPSTATE_INT)\r\nreturn;\r\nmutex_lock(&ctx->edac->mc_lock);\r\nif (enable) {\r\nctx->edac->mc_registered_mask |= 1 << ctx->mcu_id;\r\nif (ctx->edac->mc_registered_mask ==\r\nctx->edac->mc_active_mask) {\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\r\nMCU_UNCORR_ERR_MASK |\r\nMCU_CTL_ERR_MASK);\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPLPERRINTMSK,\r\nMCU_CORR_ERR_MASK);\r\n}\r\nval = readl(ctx->mcu_csr + MCUGECR);\r\nval |= MCU_GECR_DEMANDUCINTREN_MASK |\r\nMCU_GECR_BACKUCINTREN_MASK |\r\nMCU_GECR_CINTREN_MASK |\r\nMUC_GECR_MCUADDRERREN_MASK;\r\nwritel(val, ctx->mcu_csr + MCUGECR);\r\n} else {\r\nval = readl(ctx->mcu_csr + MCUGECR);\r\nval &= ~(MCU_GECR_DEMANDUCINTREN_MASK |\r\nMCU_GECR_BACKUCINTREN_MASK |\r\nMCU_GECR_CINTREN_MASK |\r\nMUC_GECR_MCUADDRERREN_MASK);\r\nwritel(val, ctx->mcu_csr + MCUGECR);\r\nxgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\r\nMCU_UNCORR_ERR_MASK | MCU_CTL_ERR_MASK);\r\nxgene_edac_pcp_setbits(ctx->edac, PCPLPERRINTMSK,\r\nMCU_CORR_ERR_MASK);\r\nctx->edac->mc_registered_mask &= ~(1 << ctx->mcu_id);\r\n}\r\nmutex_unlock(&ctx->edac->mc_lock);\r\n}\r\nstatic int xgene_edac_mc_is_active(struct xgene_edac_mc_ctx *ctx, int mc_idx)\r\n{\r\nunsigned int reg;\r\nu32 mcu_mask;\r\nif (regmap_read(ctx->edac->csw_map, CSW_CSWCR, &reg))\r\nreturn 0;\r\nif (reg & CSW_CSWCR_DUALMCB_MASK) {\r\nif (regmap_read(ctx->edac->mcbb_map, MCBADDRMR, &reg))\r\nreturn 0;\r\nmcu_mask = (reg & MCBADDRMR_DUALMCU_MODE_MASK) ? 0xF : 0x5;\r\n} else {\r\nif (regmap_read(ctx->edac->mcba_map, MCBADDRMR, &reg))\r\nreturn 0;\r\nmcu_mask = (reg & MCBADDRMR_DUALMCU_MODE_MASK) ? 0x3 : 0x1;\r\n}\r\nif (!ctx->edac->mc_active_mask)\r\nctx->edac->mc_active_mask = mcu_mask;\r\nreturn (mcu_mask & (1 << mc_idx)) ? 1 : 0;\r\n}\r\nstatic int xgene_edac_mc_add(struct xgene_edac *edac, struct device_node *np)\r\n{\r\nstruct mem_ctl_info *mci;\r\nstruct edac_mc_layer layers[2];\r\nstruct xgene_edac_mc_ctx tmp_ctx;\r\nstruct xgene_edac_mc_ctx *ctx;\r\nstruct resource res;\r\nint rc;\r\nmemset(&tmp_ctx, 0, sizeof(tmp_ctx));\r\ntmp_ctx.edac = edac;\r\nif (!devres_open_group(edac->dev, xgene_edac_mc_add, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nrc = of_address_to_resource(np, 0, &res);\r\nif (rc < 0) {\r\ndev_err(edac->dev, "no MCU resource address\n");\r\ngoto err_group;\r\n}\r\ntmp_ctx.mcu_csr = devm_ioremap_resource(edac->dev, &res);\r\nif (IS_ERR(tmp_ctx.mcu_csr)) {\r\ndev_err(edac->dev, "unable to map MCU resource\n");\r\nrc = PTR_ERR(tmp_ctx.mcu_csr);\r\ngoto err_group;\r\n}\r\nif (of_property_read_u32(np, "memory-controller", &tmp_ctx.mcu_id)) {\r\ndev_err(edac->dev, "no memory-controller property\n");\r\nrc = -ENODEV;\r\ngoto err_group;\r\n}\r\nif (!xgene_edac_mc_is_active(&tmp_ctx, tmp_ctx.mcu_id)) {\r\nrc = -ENODEV;\r\ngoto err_group;\r\n}\r\nlayers[0].type = EDAC_MC_LAYER_CHIP_SELECT;\r\nlayers[0].size = 4;\r\nlayers[0].is_virt_csrow = true;\r\nlayers[1].type = EDAC_MC_LAYER_CHANNEL;\r\nlayers[1].size = 2;\r\nlayers[1].is_virt_csrow = false;\r\nmci = edac_mc_alloc(tmp_ctx.mcu_id, ARRAY_SIZE(layers), layers,\r\nsizeof(*ctx));\r\nif (!mci) {\r\nrc = -ENOMEM;\r\ngoto err_group;\r\n}\r\nctx = mci->pvt_info;\r\n*ctx = tmp_ctx;\r\nctx->name = "xgene_edac_mc_err";\r\nctx->mci = mci;\r\nmci->pdev = &mci->dev;\r\nmci->ctl_name = ctx->name;\r\nmci->dev_name = ctx->name;\r\nmci->mtype_cap = MEM_FLAG_RDDR | MEM_FLAG_RDDR2 | MEM_FLAG_RDDR3 |\r\nMEM_FLAG_DDR | MEM_FLAG_DDR2 | MEM_FLAG_DDR3;\r\nmci->edac_ctl_cap = EDAC_FLAG_SECDED;\r\nmci->edac_cap = EDAC_FLAG_SECDED;\r\nmci->mod_name = EDAC_MOD_STR;\r\nmci->mod_ver = "0.1";\r\nmci->ctl_page_to_phys = NULL;\r\nmci->scrub_cap = SCRUB_FLAG_HW_SRC;\r\nmci->scrub_mode = SCRUB_HW_SRC;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nmci->edac_check = xgene_edac_mc_check;\r\nif (edac_mc_add_mc(mci)) {\r\ndev_err(edac->dev, "edac_mc_add_mc failed\n");\r\nrc = -EINVAL;\r\ngoto err_free;\r\n}\r\nxgene_edac_mc_create_debugfs_node(mci);\r\nlist_add(&ctx->next, &edac->mcus);\r\nxgene_edac_mc_irq_ctl(mci, true);\r\ndevres_remove_group(edac->dev, xgene_edac_mc_add);\r\ndev_info(edac->dev, "X-Gene EDAC MC registered\n");\r\nreturn 0;\r\nerr_free:\r\nedac_mc_free(mci);\r\nerr_group:\r\ndevres_release_group(edac->dev, xgene_edac_mc_add);\r\nreturn rc;\r\n}\r\nstatic int xgene_edac_mc_remove(struct xgene_edac_mc_ctx *mcu)\r\n{\r\nxgene_edac_mc_irq_ctl(mcu->mci, false);\r\nedac_mc_del_mc(&mcu->mci->dev);\r\nedac_mc_free(mcu->mci);\r\nreturn 0;\r\n}\r\nstatic void xgene_edac_pmd_l1_check(struct edac_device_ctl_info *edac_dev,\r\nint cpu_idx)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nvoid __iomem *pg_f;\r\nu32 val;\r\npg_f = ctx->pmd_csr + cpu_idx * CPU_CSR_STRIDE + CPU_MEMERR_CPU_PAGE;\r\nval = readl(pg_f + MEMERR_CPU_ICFESR_PAGE_OFFSET);\r\nif (!val)\r\ngoto chk_lsu;\r\ndev_err(edac_dev->dev,\r\n"CPU%d L1 memory error ICF 0x%08X Way 0x%02X Index 0x%02X Info 0x%02X\n",\r\nctx->pmd * MAX_CPU_PER_PMD + cpu_idx, val,\r\nMEMERR_CPU_ICFESR_ERRWAY_RD(val),\r\nMEMERR_CPU_ICFESR_ERRINDEX_RD(val),\r\nMEMERR_CPU_ICFESR_ERRINFO_RD(val));\r\nif (val & MEMERR_CPU_ICFESR_CERR_MASK)\r\ndev_err(edac_dev->dev, "One or more correctable error\n");\r\nif (val & MEMERR_CPU_ICFESR_MULTCERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple correctable error\n");\r\nswitch (MEMERR_CPU_ICFESR_ERRTYPE_RD(val)) {\r\ncase 1:\r\ndev_err(edac_dev->dev, "L1 TLB multiple hit\n");\r\nbreak;\r\ncase 2:\r\ndev_err(edac_dev->dev, "Way select multiple hit\n");\r\nbreak;\r\ncase 3:\r\ndev_err(edac_dev->dev, "Physical tag parity error\n");\r\nbreak;\r\ncase 4:\r\ncase 5:\r\ndev_err(edac_dev->dev, "L1 data parity error\n");\r\nbreak;\r\ncase 6:\r\ndev_err(edac_dev->dev, "L1 pre-decode parity error\n");\r\nbreak;\r\n}\r\nwritel(val, pg_f + MEMERR_CPU_ICFESR_PAGE_OFFSET);\r\nif (val & (MEMERR_CPU_ICFESR_CERR_MASK |\r\nMEMERR_CPU_ICFESR_MULTCERR_MASK))\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nchk_lsu:\r\nval = readl(pg_f + MEMERR_CPU_LSUESR_PAGE_OFFSET);\r\nif (!val)\r\ngoto chk_mmu;\r\ndev_err(edac_dev->dev,\r\n"CPU%d memory error LSU 0x%08X Way 0x%02X Index 0x%02X Info 0x%02X\n",\r\nctx->pmd * MAX_CPU_PER_PMD + cpu_idx, val,\r\nMEMERR_CPU_LSUESR_ERRWAY_RD(val),\r\nMEMERR_CPU_LSUESR_ERRINDEX_RD(val),\r\nMEMERR_CPU_LSUESR_ERRINFO_RD(val));\r\nif (val & MEMERR_CPU_LSUESR_CERR_MASK)\r\ndev_err(edac_dev->dev, "One or more correctable error\n");\r\nif (val & MEMERR_CPU_LSUESR_MULTCERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple correctable error\n");\r\nswitch (MEMERR_CPU_LSUESR_ERRTYPE_RD(val)) {\r\ncase 0:\r\ndev_err(edac_dev->dev, "Load tag error\n");\r\nbreak;\r\ncase 1:\r\ndev_err(edac_dev->dev, "Load data error\n");\r\nbreak;\r\ncase 2:\r\ndev_err(edac_dev->dev, "WSL multihit error\n");\r\nbreak;\r\ncase 3:\r\ndev_err(edac_dev->dev, "Store tag error\n");\r\nbreak;\r\ncase 4:\r\ndev_err(edac_dev->dev,\r\n"DTB multihit from load pipeline error\n");\r\nbreak;\r\ncase 5:\r\ndev_err(edac_dev->dev,\r\n"DTB multihit from store pipeline error\n");\r\nbreak;\r\n}\r\nwritel(val, pg_f + MEMERR_CPU_LSUESR_PAGE_OFFSET);\r\nif (val & (MEMERR_CPU_LSUESR_CERR_MASK |\r\nMEMERR_CPU_LSUESR_MULTCERR_MASK))\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nchk_mmu:\r\nval = readl(pg_f + MEMERR_CPU_MMUESR_PAGE_OFFSET);\r\nif (!val)\r\nreturn;\r\ndev_err(edac_dev->dev,\r\n"CPU%d memory error MMU 0x%08X Way 0x%02X Index 0x%02X Info 0x%02X %s\n",\r\nctx->pmd * MAX_CPU_PER_PMD + cpu_idx, val,\r\nMEMERR_CPU_MMUESR_ERRWAY_RD(val),\r\nMEMERR_CPU_MMUESR_ERRINDEX_RD(val),\r\nMEMERR_CPU_MMUESR_ERRINFO_RD(val),\r\nval & MEMERR_CPU_MMUESR_ERRREQSTR_LSU_MASK ? "LSU" : "ICF");\r\nif (val & MEMERR_CPU_MMUESR_CERR_MASK)\r\ndev_err(edac_dev->dev, "One or more correctable error\n");\r\nif (val & MEMERR_CPU_MMUESR_MULTCERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple correctable error\n");\r\nswitch (MEMERR_CPU_MMUESR_ERRTYPE_RD(val)) {\r\ncase 0:\r\ndev_err(edac_dev->dev, "Stage 1 UTB hit error\n");\r\nbreak;\r\ncase 1:\r\ndev_err(edac_dev->dev, "Stage 1 UTB miss error\n");\r\nbreak;\r\ncase 2:\r\ndev_err(edac_dev->dev, "Stage 1 UTB allocate error\n");\r\nbreak;\r\ncase 3:\r\ndev_err(edac_dev->dev, "TMO operation single bank error\n");\r\nbreak;\r\ncase 4:\r\ndev_err(edac_dev->dev, "Stage 2 UTB error\n");\r\nbreak;\r\ncase 5:\r\ndev_err(edac_dev->dev, "Stage 2 UTB miss error\n");\r\nbreak;\r\ncase 6:\r\ndev_err(edac_dev->dev, "Stage 2 UTB allocate error\n");\r\nbreak;\r\ncase 7:\r\ndev_err(edac_dev->dev, "TMO operation multiple bank error\n");\r\nbreak;\r\n}\r\nwritel(val, pg_f + MEMERR_CPU_MMUESR_PAGE_OFFSET);\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic void xgene_edac_pmd_l2_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nvoid __iomem *pg_d;\r\nvoid __iomem *pg_e;\r\nu32 val_hi;\r\nu32 val_lo;\r\nu32 val;\r\npg_e = ctx->pmd_csr + CPU_MEMERR_L2C_PAGE;\r\nval = readl(pg_e + MEMERR_L2C_L2ESR_PAGE_OFFSET);\r\nif (!val)\r\ngoto chk_l2c;\r\nval_lo = readl(pg_e + MEMERR_L2C_L2EALR_PAGE_OFFSET);\r\nval_hi = readl(pg_e + MEMERR_L2C_L2EAHR_PAGE_OFFSET);\r\ndev_err(edac_dev->dev,\r\n"PMD%d memory error L2C L2ESR 0x%08X @ 0x%08X.%08X\n",\r\nctx->pmd, val, val_hi, val_lo);\r\ndev_err(edac_dev->dev,\r\n"ErrSyndrome 0x%02X ErrWay 0x%02X ErrCpu %d ErrGroup 0x%02X ErrAction 0x%02X\n",\r\nMEMERR_L2C_L2ESR_ERRSYN_RD(val),\r\nMEMERR_L2C_L2ESR_ERRWAY_RD(val),\r\nMEMERR_L2C_L2ESR_ERRCPU_RD(val),\r\nMEMERR_L2C_L2ESR_ERRGROUP_RD(val),\r\nMEMERR_L2C_L2ESR_ERRACTION_RD(val));\r\nif (val & MEMERR_L2C_L2ESR_ERR_MASK)\r\ndev_err(edac_dev->dev, "One or more correctable error\n");\r\nif (val & MEMERR_L2C_L2ESR_MULTICERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple correctable error\n");\r\nif (val & MEMERR_L2C_L2ESR_UCERR_MASK)\r\ndev_err(edac_dev->dev, "One or more uncorrectable error\n");\r\nif (val & MEMERR_L2C_L2ESR_MULTUCERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple uncorrectable error\n");\r\nswitch (MEMERR_L2C_L2ESR_ERRTYPE_RD(val)) {\r\ncase 0:\r\ndev_err(edac_dev->dev, "Outbound SDB parity error\n");\r\nbreak;\r\ncase 1:\r\ndev_err(edac_dev->dev, "Inbound SDB parity error\n");\r\nbreak;\r\ncase 2:\r\ndev_err(edac_dev->dev, "Tag ECC error\n");\r\nbreak;\r\ncase 3:\r\ndev_err(edac_dev->dev, "Data ECC error\n");\r\nbreak;\r\n}\r\nwritel(val, pg_e + MEMERR_L2C_L2ESR_PAGE_OFFSET);\r\nif (val & (MEMERR_L2C_L2ESR_ERR_MASK |\r\nMEMERR_L2C_L2ESR_MULTICERR_MASK))\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nif (val & (MEMERR_L2C_L2ESR_UCERR_MASK |\r\nMEMERR_L2C_L2ESR_MULTUCERR_MASK))\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\nchk_l2c:\r\npg_d = ctx->pmd_csr + CPU_L2C_PAGE;\r\nval = readl(pg_d + CPUX_L2C_L2RTOSR_PAGE_OFFSET);\r\nif (val) {\r\nval_lo = readl(pg_d + CPUX_L2C_L2RTOALR_PAGE_OFFSET);\r\nval_hi = readl(pg_d + CPUX_L2C_L2RTOAHR_PAGE_OFFSET);\r\ndev_err(edac_dev->dev,\r\n"PMD%d L2C error L2C RTOSR 0x%08X @ 0x%08X.%08X\n",\r\nctx->pmd, val, val_hi, val_lo);\r\nwritel(val, pg_d + CPUX_L2C_L2RTOSR_PAGE_OFFSET);\r\n}\r\n}\r\nstatic void xgene_edac_pmd_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nunsigned int pcp_hp_stat;\r\nint i;\r\nxgene_edac_pcp_rd(ctx->edac, PCPHPERRINTSTS, &pcp_hp_stat);\r\nif (!((PMD0_MERR_MASK << ctx->pmd) & pcp_hp_stat))\r\nreturn;\r\nfor (i = 0; i < MAX_CPU_PER_PMD; i++)\r\nxgene_edac_pmd_l1_check(edac_dev, i);\r\nxgene_edac_pmd_l2_check(edac_dev);\r\n}\r\nstatic void xgene_edac_pmd_cpu_hw_cfg(struct edac_device_ctl_info *edac_dev,\r\nint cpu)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nvoid __iomem *pg_f = ctx->pmd_csr + cpu * CPU_CSR_STRIDE +\r\nCPU_MEMERR_CPU_PAGE;\r\nwritel(0x00000301, pg_f + MEMERR_CPU_ICFECR_PAGE_OFFSET);\r\nwritel(0x00000301, pg_f + MEMERR_CPU_LSUECR_PAGE_OFFSET);\r\nwritel(0x00000101, pg_f + MEMERR_CPU_MMUECR_PAGE_OFFSET);\r\n}\r\nstatic void xgene_edac_pmd_hw_cfg(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nvoid __iomem *pg_d = ctx->pmd_csr + CPU_L2C_PAGE;\r\nvoid __iomem *pg_e = ctx->pmd_csr + CPU_MEMERR_L2C_PAGE;\r\nwritel(0x00000703, pg_e + MEMERR_L2C_L2ECR_PAGE_OFFSET);\r\nif (ctx->version > 1)\r\nwritel(0x00000119, pg_d + CPUX_L2C_L2RTOCR_PAGE_OFFSET);\r\n}\r\nstatic void xgene_edac_pmd_hw_ctl(struct edac_device_ctl_info *edac_dev,\r\nbool enable)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nint i;\r\nif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\r\nif (enable)\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\r\nPMD0_MERR_MASK << ctx->pmd);\r\nelse\r\nxgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\r\nPMD0_MERR_MASK << ctx->pmd);\r\n}\r\nif (enable) {\r\nxgene_edac_pmd_hw_cfg(edac_dev);\r\nfor (i = 0; i < MAX_CPU_PER_PMD; i++)\r\nxgene_edac_pmd_cpu_hw_cfg(edac_dev, i);\r\n}\r\n}\r\nstatic ssize_t xgene_edac_pmd_l1_inject_ctrl_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = file->private_data;\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nvoid __iomem *cpux_pg_f;\r\nint i;\r\nfor (i = 0; i < MAX_CPU_PER_PMD; i++) {\r\ncpux_pg_f = ctx->pmd_csr + i * CPU_CSR_STRIDE +\r\nCPU_MEMERR_CPU_PAGE;\r\nwritel(MEMERR_CPU_ICFESR_MULTCERR_MASK |\r\nMEMERR_CPU_ICFESR_CERR_MASK,\r\ncpux_pg_f + MEMERR_CPU_ICFESRA_PAGE_OFFSET);\r\nwritel(MEMERR_CPU_LSUESR_MULTCERR_MASK |\r\nMEMERR_CPU_LSUESR_CERR_MASK,\r\ncpux_pg_f + MEMERR_CPU_LSUESRA_PAGE_OFFSET);\r\nwritel(MEMERR_CPU_MMUESR_MULTCERR_MASK |\r\nMEMERR_CPU_MMUESR_CERR_MASK,\r\ncpux_pg_f + MEMERR_CPU_MMUESRA_PAGE_OFFSET);\r\n}\r\nreturn count;\r\n}\r\nstatic ssize_t xgene_edac_pmd_l2_inject_ctrl_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = file->private_data;\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nvoid __iomem *pg_e = ctx->pmd_csr + CPU_MEMERR_L2C_PAGE;\r\nwritel(MEMERR_L2C_L2ESR_MULTUCERR_MASK |\r\nMEMERR_L2C_L2ESR_MULTICERR_MASK |\r\nMEMERR_L2C_L2ESR_UCERR_MASK |\r\nMEMERR_L2C_L2ESR_ERR_MASK,\r\npg_e + MEMERR_L2C_L2ESRA_PAGE_OFFSET);\r\nreturn count;\r\n}\r\nstatic void\r\nxgene_edac_pmd_create_debugfs_nodes(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_pmd_ctx *ctx = edac_dev->pvt_info;\r\nstruct dentry *dbgfs_dir;\r\nchar name[10];\r\nif (!IS_ENABLED(CONFIG_EDAC_DEBUG) || !ctx->edac->dfs)\r\nreturn;\r\nsnprintf(name, sizeof(name), "PMD%d", ctx->pmd);\r\ndbgfs_dir = edac_debugfs_create_dir_at(name, ctx->edac->dfs);\r\nif (!dbgfs_dir)\r\nreturn;\r\nedac_debugfs_create_file("l1_inject_ctrl", S_IWUSR, dbgfs_dir, edac_dev,\r\n&xgene_edac_pmd_debug_inject_fops[0]);\r\nedac_debugfs_create_file("l2_inject_ctrl", S_IWUSR, dbgfs_dir, edac_dev,\r\n&xgene_edac_pmd_debug_inject_fops[1]);\r\n}\r\nstatic int xgene_edac_pmd_available(u32 efuse, int pmd)\r\n{\r\nreturn (efuse & (1 << pmd)) ? 0 : 1;\r\n}\r\nstatic int xgene_edac_pmd_add(struct xgene_edac *edac, struct device_node *np,\r\nint version)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct xgene_edac_pmd_ctx *ctx;\r\nstruct resource res;\r\nchar edac_name[10];\r\nu32 pmd;\r\nint rc;\r\nu32 val;\r\nif (!devres_open_group(edac->dev, xgene_edac_pmd_add, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nif (of_property_read_u32(np, "pmd-controller", &pmd)) {\r\ndev_err(edac->dev, "no pmd-controller property\n");\r\nrc = -ENODEV;\r\ngoto err_group;\r\n}\r\nrc = regmap_read(edac->efuse_map, 0, &val);\r\nif (rc)\r\ngoto err_group;\r\nif (!xgene_edac_pmd_available(val, pmd)) {\r\nrc = -ENODEV;\r\ngoto err_group;\r\n}\r\nsnprintf(edac_name, sizeof(edac_name), "l2c%d", pmd);\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*ctx),\r\nedac_name, 1, "l2c", 1, 2, NULL,\r\n0, edac_device_alloc_index());\r\nif (!edac_dev) {\r\nrc = -ENOMEM;\r\ngoto err_group;\r\n}\r\nctx = edac_dev->pvt_info;\r\nctx->name = "xgene_pmd_err";\r\nctx->pmd = pmd;\r\nctx->edac = edac;\r\nctx->edac_dev = edac_dev;\r\nctx->ddev = *edac->dev;\r\nctx->version = version;\r\nedac_dev->dev = &ctx->ddev;\r\nedac_dev->ctl_name = ctx->name;\r\nedac_dev->dev_name = ctx->name;\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nrc = of_address_to_resource(np, 0, &res);\r\nif (rc < 0) {\r\ndev_err(edac->dev, "no PMD resource address\n");\r\ngoto err_free;\r\n}\r\nctx->pmd_csr = devm_ioremap_resource(edac->dev, &res);\r\nif (IS_ERR(ctx->pmd_csr)) {\r\ndev_err(edac->dev,\r\n"devm_ioremap_resource failed for PMD resource address\n");\r\nrc = PTR_ERR(ctx->pmd_csr);\r\ngoto err_free;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = xgene_edac_pmd_check;\r\nxgene_edac_pmd_create_debugfs_nodes(edac_dev);\r\nrc = edac_device_add_device(edac_dev);\r\nif (rc > 0) {\r\ndev_err(edac->dev, "edac_device_add_device failed\n");\r\nrc = -ENOMEM;\r\ngoto err_free;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT)\r\nedac_dev->op_state = OP_RUNNING_INTERRUPT;\r\nlist_add(&ctx->next, &edac->pmds);\r\nxgene_edac_pmd_hw_ctl(edac_dev, 1);\r\ndevres_remove_group(edac->dev, xgene_edac_pmd_add);\r\ndev_info(edac->dev, "X-Gene EDAC PMD%d registered\n", ctx->pmd);\r\nreturn 0;\r\nerr_free:\r\nedac_device_free_ctl_info(edac_dev);\r\nerr_group:\r\ndevres_release_group(edac->dev, xgene_edac_pmd_add);\r\nreturn rc;\r\n}\r\nstatic int xgene_edac_pmd_remove(struct xgene_edac_pmd_ctx *pmd)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = pmd->edac_dev;\r\nxgene_edac_pmd_hw_ctl(edac_dev, 0);\r\nedac_device_del_device(edac_dev->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic bool xgene_edac_l3_promote_to_uc_err(u32 l3cesr, u32 l3celr)\r\n{\r\nif (l3cesr & L3C_ESR_DATATAG_MASK) {\r\nswitch (L3C_ELR_ERRSYN(l3celr)) {\r\ncase 0x13C:\r\ncase 0x0B4:\r\ncase 0x007:\r\ncase 0x00D:\r\ncase 0x00E:\r\ncase 0x019:\r\ncase 0x01A:\r\ncase 0x01C:\r\ncase 0x04E:\r\ncase 0x041:\r\nreturn true;\r\n}\r\n} else if (L3C_ELR_ERRWAY(l3celr) == 9)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic void xgene_edac_l3_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nu32 l3cesr;\r\nu32 l3celr;\r\nu32 l3caelr;\r\nu32 l3cbelr;\r\nl3cesr = readl(ctx->dev_csr + L3C_ESR);\r\nif (!(l3cesr & (L3C_ESR_UCERR_MASK | L3C_ESR_CERR_MASK)))\r\nreturn;\r\nif (l3cesr & L3C_ESR_UCERR_MASK)\r\ndev_err(edac_dev->dev, "L3C uncorrectable error\n");\r\nif (l3cesr & L3C_ESR_CERR_MASK)\r\ndev_warn(edac_dev->dev, "L3C correctable error\n");\r\nl3celr = readl(ctx->dev_csr + L3C_ELR);\r\nl3caelr = readl(ctx->dev_csr + L3C_AELR);\r\nl3cbelr = readl(ctx->dev_csr + L3C_BELR);\r\nif (l3cesr & L3C_ESR_MULTIHIT_MASK)\r\ndev_err(edac_dev->dev, "L3C multiple hit error\n");\r\nif (l3cesr & L3C_ESR_UCEVICT_MASK)\r\ndev_err(edac_dev->dev,\r\n"L3C dropped eviction of line with error\n");\r\nif (l3cesr & L3C_ESR_MULTIUCERR_MASK)\r\ndev_err(edac_dev->dev, "L3C multiple uncorrectable error\n");\r\nif (l3cesr & L3C_ESR_DATATAG_MASK)\r\ndev_err(edac_dev->dev,\r\n"L3C data error syndrome 0x%X group 0x%X\n",\r\nL3C_ELR_ERRSYN(l3celr), L3C_ELR_ERRGRP(l3celr));\r\nelse\r\ndev_err(edac_dev->dev,\r\n"L3C tag error syndrome 0x%X Way of Tag 0x%X Agent ID 0x%X Operation type 0x%X\n",\r\nL3C_ELR_ERRSYN(l3celr), L3C_ELR_ERRWAY(l3celr),\r\nL3C_ELR_AGENTID(l3celr), L3C_ELR_OPTYPE(l3celr));\r\ndev_err(edac_dev->dev, "L3C error address 0x%08X.%08X bank %d\n",\r\nL3C_ELR_PADDRHIGH(l3celr) << 6 | (l3caelr >> 26),\r\n(l3caelr & 0x3FFFFFFF) << 6, L3C_BELR_BANK(l3cbelr));\r\ndev_err(edac_dev->dev,\r\n"L3C error status register value 0x%X\n", l3cesr);\r\nwritel(0, ctx->dev_csr + L3C_ESR);\r\nif (ctx->version <= 1 &&\r\nxgene_edac_l3_promote_to_uc_err(l3cesr, l3celr)) {\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\nreturn;\r\n}\r\nif (l3cesr & L3C_ESR_CERR_MASK)\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nif (l3cesr & L3C_ESR_UCERR_MASK)\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic void xgene_edac_l3_hw_init(struct edac_device_ctl_info *edac_dev,\r\nbool enable)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nu32 val;\r\nval = readl(ctx->dev_csr + L3C_ECR);\r\nval |= L3C_UCERREN | L3C_CERREN;\r\nif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\r\nif (enable)\r\nval |= L3C_ECR_UCINTREN | L3C_ECR_CINTREN;\r\nelse\r\nval &= ~(L3C_ECR_UCINTREN | L3C_ECR_CINTREN);\r\n}\r\nwritel(val, ctx->dev_csr + L3C_ECR);\r\nif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\r\nif (enable) {\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\r\nL3C_UNCORR_ERR_MASK);\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPLPERRINTMSK,\r\nL3C_CORR_ERR_MASK);\r\n} else {\r\nxgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\r\nL3C_UNCORR_ERR_MASK);\r\nxgene_edac_pcp_setbits(ctx->edac, PCPLPERRINTMSK,\r\nL3C_CORR_ERR_MASK);\r\n}\r\n}\r\n}\r\nstatic ssize_t xgene_edac_l3_inject_ctrl_write(struct file *file,\r\nconst char __user *data,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = file->private_data;\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nwritel(0xFFFFFFFF, ctx->dev_csr + L3C_ESR);\r\nreturn count;\r\n}\r\nstatic void\r\nxgene_edac_l3_create_debugfs_nodes(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nstruct dentry *dbgfs_dir;\r\nchar name[10];\r\nif (!IS_ENABLED(CONFIG_EDAC_DEBUG) || !ctx->edac->dfs)\r\nreturn;\r\nsnprintf(name, sizeof(name), "l3c%d", ctx->edac_idx);\r\ndbgfs_dir = edac_debugfs_create_dir_at(name, ctx->edac->dfs);\r\nif (!dbgfs_dir)\r\nreturn;\r\ndebugfs_create_file("l3_inject_ctrl", S_IWUSR, dbgfs_dir, edac_dev,\r\n&xgene_edac_l3_debug_inject_fops);\r\n}\r\nstatic int xgene_edac_l3_add(struct xgene_edac *edac, struct device_node *np,\r\nint version)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct xgene_edac_dev_ctx *ctx;\r\nstruct resource res;\r\nvoid __iomem *dev_csr;\r\nint edac_idx;\r\nint rc = 0;\r\nif (!devres_open_group(edac->dev, xgene_edac_l3_add, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nrc = of_address_to_resource(np, 0, &res);\r\nif (rc < 0) {\r\ndev_err(edac->dev, "no L3 resource address\n");\r\ngoto err_release_group;\r\n}\r\ndev_csr = devm_ioremap_resource(edac->dev, &res);\r\nif (IS_ERR(dev_csr)) {\r\ndev_err(edac->dev,\r\n"devm_ioremap_resource failed for L3 resource address\n");\r\nrc = PTR_ERR(dev_csr);\r\ngoto err_release_group;\r\n}\r\nedac_idx = edac_device_alloc_index();\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*ctx),\r\n"l3c", 1, "l3c", 1, 0, NULL, 0,\r\nedac_idx);\r\nif (!edac_dev) {\r\nrc = -ENOMEM;\r\ngoto err_release_group;\r\n}\r\nctx = edac_dev->pvt_info;\r\nctx->dev_csr = dev_csr;\r\nctx->name = "xgene_l3_err";\r\nctx->edac_idx = edac_idx;\r\nctx->edac = edac;\r\nctx->edac_dev = edac_dev;\r\nctx->ddev = *edac->dev;\r\nctx->version = version;\r\nedac_dev->dev = &ctx->ddev;\r\nedac_dev->ctl_name = ctx->name;\r\nedac_dev->dev_name = ctx->name;\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = xgene_edac_l3_check;\r\nxgene_edac_l3_create_debugfs_nodes(edac_dev);\r\nrc = edac_device_add_device(edac_dev);\r\nif (rc > 0) {\r\ndev_err(edac->dev, "failed edac_device_add_device()\n");\r\nrc = -ENOMEM;\r\ngoto err_ctl_free;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT)\r\nedac_dev->op_state = OP_RUNNING_INTERRUPT;\r\nlist_add(&ctx->next, &edac->l3s);\r\nxgene_edac_l3_hw_init(edac_dev, 1);\r\ndevres_remove_group(edac->dev, xgene_edac_l3_add);\r\ndev_info(edac->dev, "X-Gene EDAC L3 registered\n");\r\nreturn 0;\r\nerr_ctl_free:\r\nedac_device_free_ctl_info(edac_dev);\r\nerr_release_group:\r\ndevres_release_group(edac->dev, xgene_edac_l3_add);\r\nreturn rc;\r\n}\r\nstatic int xgene_edac_l3_remove(struct xgene_edac_dev_ctx *l3)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = l3->edac_dev;\r\nxgene_edac_l3_hw_init(edac_dev, 0);\r\nedac_device_del_device(l3->edac->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic void xgene_edac_iob_gic_report(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nu32 err_addr_lo;\r\nu32 err_addr_hi;\r\nu32 reg;\r\nu32 info;\r\nreg = readl(ctx->dev_csr + XGICTRANSERRINTSTS);\r\nif (!reg)\r\ngoto chk_iob_err;\r\ndev_err(edac_dev->dev, "XGIC transaction error\n");\r\nif (reg & RD_ACCESS_ERR_MASK)\r\ndev_err(edac_dev->dev, "XGIC read size error\n");\r\nif (reg & M_RD_ACCESS_ERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple XGIC read size error\n");\r\nif (reg & WR_ACCESS_ERR_MASK)\r\ndev_err(edac_dev->dev, "XGIC write size error\n");\r\nif (reg & M_WR_ACCESS_ERR_MASK)\r\ndev_err(edac_dev->dev, "Multiple XGIC write size error\n");\r\ninfo = readl(ctx->dev_csr + XGICTRANSERRREQINFO);\r\ndev_err(edac_dev->dev, "XGIC %s access @ 0x%08X (0x%08X)\n",\r\ninfo & REQTYPE_MASK ? "read" : "write", ERRADDR_RD(info),\r\ninfo);\r\nwritel(reg, ctx->dev_csr + XGICTRANSERRINTSTS);\r\nchk_iob_err:\r\nreg = readl(ctx->dev_csr + GLBL_ERR_STS);\r\nif (!reg)\r\nreturn;\r\nif (reg & SEC_ERR_MASK) {\r\nerr_addr_lo = readl(ctx->dev_csr + GLBL_SEC_ERRL);\r\nerr_addr_hi = readl(ctx->dev_csr + GLBL_SEC_ERRH);\r\ndev_err(edac_dev->dev,\r\n"IOB single-bit correctable memory at 0x%08X.%08X error\n",\r\nerr_addr_lo, err_addr_hi);\r\nwritel(err_addr_lo, ctx->dev_csr + GLBL_SEC_ERRL);\r\nwritel(err_addr_hi, ctx->dev_csr + GLBL_SEC_ERRH);\r\n}\r\nif (reg & MSEC_ERR_MASK) {\r\nerr_addr_lo = readl(ctx->dev_csr + GLBL_MSEC_ERRL);\r\nerr_addr_hi = readl(ctx->dev_csr + GLBL_MSEC_ERRH);\r\ndev_err(edac_dev->dev,\r\n"IOB multiple single-bit correctable memory at 0x%08X.%08X error\n",\r\nerr_addr_lo, err_addr_hi);\r\nwritel(err_addr_lo, ctx->dev_csr + GLBL_MSEC_ERRL);\r\nwritel(err_addr_hi, ctx->dev_csr + GLBL_MSEC_ERRH);\r\n}\r\nif (reg & (SEC_ERR_MASK | MSEC_ERR_MASK))\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\nif (reg & DED_ERR_MASK) {\r\nerr_addr_lo = readl(ctx->dev_csr + GLBL_DED_ERRL);\r\nerr_addr_hi = readl(ctx->dev_csr + GLBL_DED_ERRH);\r\ndev_err(edac_dev->dev,\r\n"IOB double-bit uncorrectable memory at 0x%08X.%08X error\n",\r\nerr_addr_lo, err_addr_hi);\r\nwritel(err_addr_lo, ctx->dev_csr + GLBL_DED_ERRL);\r\nwritel(err_addr_hi, ctx->dev_csr + GLBL_DED_ERRH);\r\n}\r\nif (reg & MDED_ERR_MASK) {\r\nerr_addr_lo = readl(ctx->dev_csr + GLBL_MDED_ERRL);\r\nerr_addr_hi = readl(ctx->dev_csr + GLBL_MDED_ERRH);\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB double-bit uncorrectable memory at 0x%08X.%08X error\n",\r\nerr_addr_lo, err_addr_hi);\r\nwritel(err_addr_lo, ctx->dev_csr + GLBL_MDED_ERRL);\r\nwritel(err_addr_hi, ctx->dev_csr + GLBL_MDED_ERRH);\r\n}\r\nif (reg & (DED_ERR_MASK | MDED_ERR_MASK))\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nstatic void xgene_edac_rb_report(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nu32 err_addr_lo;\r\nu32 err_addr_hi;\r\nu32 reg;\r\nif (!ctx->edac->rb_map)\r\ngoto rb_skip;\r\nif (regmap_read(ctx->edac->rb_map, RBCSR, &reg))\r\nreturn;\r\nif (reg & STICKYERR_MASK) {\r\nbool write;\r\nu32 address;\r\ndev_err(edac_dev->dev, "IOB bus access error(s)\n");\r\nif (regmap_read(ctx->edac->rb_map, RBEIR, &reg))\r\nreturn;\r\nwrite = reg & WRITE_ACCESS_MASK ? 1 : 0;\r\naddress = RBERRADDR_RD(reg);\r\nif (reg & AGENT_OFFLINE_ERR_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB bus %s access to offline agent error\n",\r\nwrite ? "write" : "read");\r\nif (reg & UNIMPL_RBPAGE_ERR_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB bus %s access to unimplemented page error\n",\r\nwrite ? "write" : "read");\r\nif (reg & WORD_ALIGNED_ERR_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB bus %s word aligned access error\n",\r\nwrite ? "write" : "read");\r\nif (reg & PAGE_ACCESS_ERR_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB bus %s to page out of range access error\n",\r\nwrite ? "write" : "read");\r\nif (regmap_write(ctx->edac->rb_map, RBEIR, 0))\r\nreturn;\r\nif (regmap_write(ctx->edac->rb_map, RBCSR, 0))\r\nreturn;\r\n}\r\nrb_skip:\r\nreg = readl(ctx->dev_csr + IOBBATRANSERRINTSTS);\r\nif (!reg)\r\nreturn;\r\ndev_err(edac_dev->dev, "IOB bridge agent (BA) transaction error\n");\r\nif (reg & WRERR_RESP_MASK)\r\ndev_err(edac_dev->dev, "IOB BA write response error\n");\r\nif (reg & M_WRERR_RESP_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB BA write response error\n");\r\nif (reg & XGIC_POISONED_REQ_MASK)\r\ndev_err(edac_dev->dev, "IOB BA XGIC poisoned write error\n");\r\nif (reg & M_XGIC_POISONED_REQ_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB BA XGIC poisoned write error\n");\r\nif (reg & RBM_POISONED_REQ_MASK)\r\ndev_err(edac_dev->dev, "IOB BA RBM poisoned write error\n");\r\nif (reg & M_RBM_POISONED_REQ_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB BA RBM poisoned write error\n");\r\nif (reg & WDATA_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "IOB BA write error\n");\r\nif (reg & M_WDATA_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "Multiple IOB BA write error\n");\r\nif (reg & TRANS_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "IOB BA transaction error\n");\r\nif (reg & M_TRANS_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "Multiple IOB BA transaction error\n");\r\nif (reg & RIDRAM_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB BA RDIDRAM read transaction ID error\n");\r\nif (reg & M_RIDRAM_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB BA RDIDRAM read transaction ID error\n");\r\nif (reg & WIDRAM_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB BA RDIDRAM write transaction ID error\n");\r\nif (reg & M_WIDRAM_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB BA RDIDRAM write transaction ID error\n");\r\nif (reg & ILLEGAL_ACCESS_MASK)\r\ndev_err(edac_dev->dev,\r\n"IOB BA XGIC/RB illegal access error\n");\r\nif (reg & M_ILLEGAL_ACCESS_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB BA XGIC/RB illegal access error\n");\r\nerr_addr_lo = readl(ctx->dev_csr + IOBBATRANSERRREQINFOL);\r\nerr_addr_hi = readl(ctx->dev_csr + IOBBATRANSERRREQINFOH);\r\ndev_err(edac_dev->dev, "IOB BA %s access at 0x%02X.%08X (0x%08X)\n",\r\nREQTYPE_F2_RD(err_addr_hi) ? "read" : "write",\r\nERRADDRH_F2_RD(err_addr_hi), err_addr_lo, err_addr_hi);\r\nif (reg & WRERR_RESP_MASK)\r\ndev_err(edac_dev->dev, "IOB BA requestor ID 0x%08X\n",\r\nreadl(ctx->dev_csr + IOBBATRANSERRCSWREQID));\r\nwritel(reg, ctx->dev_csr + IOBBATRANSERRINTSTS);\r\n}\r\nstatic void xgene_edac_pa_report(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nu32 err_addr_lo;\r\nu32 err_addr_hi;\r\nu32 reg;\r\nreg = readl(ctx->dev_csr + IOBPATRANSERRINTSTS);\r\nif (!reg)\r\ngoto chk_iob_axi0;\r\ndev_err(edac_dev->dev, "IOB processing agent (PA) transaction error\n");\r\nif (reg & IOBPA_RDATA_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "IOB PA read data RAM error\n");\r\nif (reg & IOBPA_M_RDATA_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB PA read data RAM error\n");\r\nif (reg & IOBPA_WDATA_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "IOB PA write data RAM error\n");\r\nif (reg & IOBPA_M_WDATA_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB PA write data RAM error\n");\r\nif (reg & IOBPA_TRANS_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "IOB PA transaction error\n");\r\nif (reg & IOBPA_M_TRANS_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "Multiple IOB PA transaction error\n");\r\nif (reg & IOBPA_REQIDRAM_CORRUPT_MASK)\r\ndev_err(edac_dev->dev, "IOB PA transaction ID RAM error\n");\r\nif (reg & IOBPA_M_REQIDRAM_CORRUPT_MASK)\r\ndev_err(edac_dev->dev,\r\n"Multiple IOB PA transaction ID RAM error\n");\r\nwritel(reg, ctx->dev_csr + IOBPATRANSERRINTSTS);\r\nchk_iob_axi0:\r\nreg = readl(ctx->dev_csr + IOBAXIS0TRANSERRINTSTS);\r\nif (!reg)\r\ngoto chk_iob_axi1;\r\nerr_addr_lo = readl(ctx->dev_csr + IOBAXIS0TRANSERRREQINFOL);\r\nerr_addr_hi = readl(ctx->dev_csr + IOBAXIS0TRANSERRREQINFOH);\r\ndev_err(edac_dev->dev,\r\n"%sAXI slave 0 illegal %s access @ 0x%02X.%08X (0x%08X)\n",\r\nreg & IOBAXIS0_M_ILLEGAL_ACCESS_MASK ? "Multiple " : "",\r\nREQTYPE_RD(err_addr_hi) ? "read" : "write",\r\nERRADDRH_RD(err_addr_hi), err_addr_lo, err_addr_hi);\r\nwritel(reg, ctx->dev_csr + IOBAXIS0TRANSERRINTSTS);\r\nchk_iob_axi1:\r\nreg = readl(ctx->dev_csr + IOBAXIS1TRANSERRINTSTS);\r\nif (!reg)\r\nreturn;\r\nerr_addr_lo = readl(ctx->dev_csr + IOBAXIS1TRANSERRREQINFOL);\r\nerr_addr_hi = readl(ctx->dev_csr + IOBAXIS1TRANSERRREQINFOH);\r\ndev_err(edac_dev->dev,\r\n"%sAXI slave 1 illegal %s access @ 0x%02X.%08X (0x%08X)\n",\r\nreg & IOBAXIS0_M_ILLEGAL_ACCESS_MASK ? "Multiple " : "",\r\nREQTYPE_RD(err_addr_hi) ? "read" : "write",\r\nERRADDRH_RD(err_addr_hi), err_addr_lo, err_addr_hi);\r\nwritel(reg, ctx->dev_csr + IOBAXIS1TRANSERRINTSTS);\r\n}\r\nstatic void xgene_edac_soc_check(struct edac_device_ctl_info *edac_dev)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nconst char * const *soc_mem_err = NULL;\r\nu32 pcp_hp_stat;\r\nu32 pcp_lp_stat;\r\nu32 reg;\r\nint i;\r\nxgene_edac_pcp_rd(ctx->edac, PCPHPERRINTSTS, &pcp_hp_stat);\r\nxgene_edac_pcp_rd(ctx->edac, PCPLPERRINTSTS, &pcp_lp_stat);\r\nxgene_edac_pcp_rd(ctx->edac, MEMERRINTSTS, &reg);\r\nif (!((pcp_hp_stat & (IOB_PA_ERR_MASK | IOB_BA_ERR_MASK |\r\nIOB_XGIC_ERR_MASK | IOB_RB_ERR_MASK)) ||\r\n(pcp_lp_stat & CSW_SWITCH_TRACE_ERR_MASK) || reg))\r\nreturn;\r\nif (pcp_hp_stat & IOB_XGIC_ERR_MASK)\r\nxgene_edac_iob_gic_report(edac_dev);\r\nif (pcp_hp_stat & (IOB_RB_ERR_MASK | IOB_BA_ERR_MASK))\r\nxgene_edac_rb_report(edac_dev);\r\nif (pcp_hp_stat & IOB_PA_ERR_MASK)\r\nxgene_edac_pa_report(edac_dev);\r\nif (pcp_lp_stat & CSW_SWITCH_TRACE_ERR_MASK) {\r\ndev_info(edac_dev->dev,\r\n"CSW switch trace correctable memory parity error\n");\r\nedac_device_handle_ce(edac_dev, 0, 0, edac_dev->ctl_name);\r\n}\r\nif (!reg)\r\nreturn;\r\nif (ctx->version == 1)\r\nsoc_mem_err = soc_mem_err_v1;\r\nif (!soc_mem_err) {\r\ndev_err(edac_dev->dev, "SoC memory parity error 0x%08X\n",\r\nreg);\r\nedac_device_handle_ue(edac_dev, 0, 0, edac_dev->ctl_name);\r\nreturn;\r\n}\r\nfor (i = 0; i < 31; i++) {\r\nif (reg & (1 << i)) {\r\ndev_err(edac_dev->dev, "%s memory parity error\n",\r\nsoc_mem_err[i]);\r\nedac_device_handle_ue(edac_dev, 0, 0,\r\nedac_dev->ctl_name);\r\n}\r\n}\r\n}\r\nstatic void xgene_edac_soc_hw_init(struct edac_device_ctl_info *edac_dev,\r\nbool enable)\r\n{\r\nstruct xgene_edac_dev_ctx *ctx = edac_dev->pvt_info;\r\nif (edac_dev->op_state == OP_RUNNING_INTERRUPT) {\r\nif (enable) {\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPHPERRINTMSK,\r\nIOB_PA_ERR_MASK |\r\nIOB_BA_ERR_MASK |\r\nIOB_XGIC_ERR_MASK |\r\nIOB_RB_ERR_MASK);\r\nxgene_edac_pcp_clrbits(ctx->edac, PCPLPERRINTMSK,\r\nCSW_SWITCH_TRACE_ERR_MASK);\r\n} else {\r\nxgene_edac_pcp_setbits(ctx->edac, PCPHPERRINTMSK,\r\nIOB_PA_ERR_MASK |\r\nIOB_BA_ERR_MASK |\r\nIOB_XGIC_ERR_MASK |\r\nIOB_RB_ERR_MASK);\r\nxgene_edac_pcp_setbits(ctx->edac, PCPLPERRINTMSK,\r\nCSW_SWITCH_TRACE_ERR_MASK);\r\n}\r\nwritel(enable ? 0x0 : 0xFFFFFFFF,\r\nctx->dev_csr + IOBAXIS0TRANSERRINTMSK);\r\nwritel(enable ? 0x0 : 0xFFFFFFFF,\r\nctx->dev_csr + IOBAXIS1TRANSERRINTMSK);\r\nwritel(enable ? 0x0 : 0xFFFFFFFF,\r\nctx->dev_csr + XGICTRANSERRINTMSK);\r\nxgene_edac_pcp_setbits(ctx->edac, MEMERRINTMSK,\r\nenable ? 0x0 : 0xFFFFFFFF);\r\n}\r\n}\r\nstatic int xgene_edac_soc_add(struct xgene_edac *edac, struct device_node *np,\r\nint version)\r\n{\r\nstruct edac_device_ctl_info *edac_dev;\r\nstruct xgene_edac_dev_ctx *ctx;\r\nvoid __iomem *dev_csr;\r\nstruct resource res;\r\nint edac_idx;\r\nint rc;\r\nif (!devres_open_group(edac->dev, xgene_edac_soc_add, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nrc = of_address_to_resource(np, 0, &res);\r\nif (rc < 0) {\r\ndev_err(edac->dev, "no SoC resource address\n");\r\ngoto err_release_group;\r\n}\r\ndev_csr = devm_ioremap_resource(edac->dev, &res);\r\nif (IS_ERR(dev_csr)) {\r\ndev_err(edac->dev,\r\n"devm_ioremap_resource failed for soc resource address\n");\r\nrc = PTR_ERR(dev_csr);\r\ngoto err_release_group;\r\n}\r\nedac_idx = edac_device_alloc_index();\r\nedac_dev = edac_device_alloc_ctl_info(sizeof(*ctx),\r\n"SOC", 1, "SOC", 1, 2, NULL, 0,\r\nedac_idx);\r\nif (!edac_dev) {\r\nrc = -ENOMEM;\r\ngoto err_release_group;\r\n}\r\nctx = edac_dev->pvt_info;\r\nctx->dev_csr = dev_csr;\r\nctx->name = "xgene_soc_err";\r\nctx->edac_idx = edac_idx;\r\nctx->edac = edac;\r\nctx->edac_dev = edac_dev;\r\nctx->ddev = *edac->dev;\r\nctx->version = version;\r\nedac_dev->dev = &ctx->ddev;\r\nedac_dev->ctl_name = ctx->name;\r\nedac_dev->dev_name = ctx->name;\r\nedac_dev->mod_name = EDAC_MOD_STR;\r\nif (edac_op_state == EDAC_OPSTATE_POLL)\r\nedac_dev->edac_check = xgene_edac_soc_check;\r\nrc = edac_device_add_device(edac_dev);\r\nif (rc > 0) {\r\ndev_err(edac->dev, "failed edac_device_add_device()\n");\r\nrc = -ENOMEM;\r\ngoto err_ctl_free;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT)\r\nedac_dev->op_state = OP_RUNNING_INTERRUPT;\r\nlist_add(&ctx->next, &edac->socs);\r\nxgene_edac_soc_hw_init(edac_dev, 1);\r\ndevres_remove_group(edac->dev, xgene_edac_soc_add);\r\ndev_info(edac->dev, "X-Gene EDAC SoC registered\n");\r\nreturn 0;\r\nerr_ctl_free:\r\nedac_device_free_ctl_info(edac_dev);\r\nerr_release_group:\r\ndevres_release_group(edac->dev, xgene_edac_soc_add);\r\nreturn rc;\r\n}\r\nstatic int xgene_edac_soc_remove(struct xgene_edac_dev_ctx *soc)\r\n{\r\nstruct edac_device_ctl_info *edac_dev = soc->edac_dev;\r\nxgene_edac_soc_hw_init(edac_dev, 0);\r\nedac_device_del_device(soc->edac->dev);\r\nedac_device_free_ctl_info(edac_dev);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t xgene_edac_isr(int irq, void *dev_id)\r\n{\r\nstruct xgene_edac *ctx = dev_id;\r\nstruct xgene_edac_pmd_ctx *pmd;\r\nstruct xgene_edac_dev_ctx *node;\r\nunsigned int pcp_hp_stat;\r\nunsigned int pcp_lp_stat;\r\nxgene_edac_pcp_rd(ctx, PCPHPERRINTSTS, &pcp_hp_stat);\r\nxgene_edac_pcp_rd(ctx, PCPLPERRINTSTS, &pcp_lp_stat);\r\nif ((MCU_UNCORR_ERR_MASK & pcp_hp_stat) ||\r\n(MCU_CTL_ERR_MASK & pcp_hp_stat) ||\r\n(MCU_CORR_ERR_MASK & pcp_lp_stat)) {\r\nstruct xgene_edac_mc_ctx *mcu;\r\nlist_for_each_entry(mcu, &ctx->mcus, next)\r\nxgene_edac_mc_check(mcu->mci);\r\n}\r\nlist_for_each_entry(pmd, &ctx->pmds, next) {\r\nif ((PMD0_MERR_MASK << pmd->pmd) & pcp_hp_stat)\r\nxgene_edac_pmd_check(pmd->edac_dev);\r\n}\r\nlist_for_each_entry(node, &ctx->l3s, next)\r\nxgene_edac_l3_check(node->edac_dev);\r\nlist_for_each_entry(node, &ctx->socs, next)\r\nxgene_edac_soc_check(node->edac_dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int xgene_edac_probe(struct platform_device *pdev)\r\n{\r\nstruct xgene_edac *edac;\r\nstruct device_node *child;\r\nstruct resource *res;\r\nint rc;\r\nedac = devm_kzalloc(&pdev->dev, sizeof(*edac), GFP_KERNEL);\r\nif (!edac)\r\nreturn -ENOMEM;\r\nedac->dev = &pdev->dev;\r\nplatform_set_drvdata(pdev, edac);\r\nINIT_LIST_HEAD(&edac->mcus);\r\nINIT_LIST_HEAD(&edac->pmds);\r\nINIT_LIST_HEAD(&edac->l3s);\r\nINIT_LIST_HEAD(&edac->socs);\r\nspin_lock_init(&edac->lock);\r\nmutex_init(&edac->mc_lock);\r\nedac->csw_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"regmap-csw");\r\nif (IS_ERR(edac->csw_map)) {\r\ndev_err(edac->dev, "unable to get syscon regmap csw\n");\r\nrc = PTR_ERR(edac->csw_map);\r\ngoto out_err;\r\n}\r\nedac->mcba_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"regmap-mcba");\r\nif (IS_ERR(edac->mcba_map)) {\r\ndev_err(edac->dev, "unable to get syscon regmap mcba\n");\r\nrc = PTR_ERR(edac->mcba_map);\r\ngoto out_err;\r\n}\r\nedac->mcbb_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"regmap-mcbb");\r\nif (IS_ERR(edac->mcbb_map)) {\r\ndev_err(edac->dev, "unable to get syscon regmap mcbb\n");\r\nrc = PTR_ERR(edac->mcbb_map);\r\ngoto out_err;\r\n}\r\nedac->efuse_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"regmap-efuse");\r\nif (IS_ERR(edac->efuse_map)) {\r\ndev_err(edac->dev, "unable to get syscon regmap efuse\n");\r\nrc = PTR_ERR(edac->efuse_map);\r\ngoto out_err;\r\n}\r\nedac->rb_map = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,\r\n"regmap-rb");\r\nif (IS_ERR(edac->rb_map)) {\r\ndev_warn(edac->dev, "missing syscon regmap rb\n");\r\nedac->rb_map = NULL;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nedac->pcp_csr = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(edac->pcp_csr)) {\r\ndev_err(&pdev->dev, "no PCP resource address\n");\r\nrc = PTR_ERR(edac->pcp_csr);\r\ngoto out_err;\r\n}\r\nif (edac_op_state == EDAC_OPSTATE_INT) {\r\nint irq;\r\nint i;\r\nfor (i = 0; i < 3; i++) {\r\nirq = platform_get_irq(pdev, i);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "No IRQ resource\n");\r\nrc = -EINVAL;\r\ngoto out_err;\r\n}\r\nrc = devm_request_irq(&pdev->dev, irq,\r\nxgene_edac_isr, IRQF_SHARED,\r\ndev_name(&pdev->dev), edac);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"Could not request IRQ %d\n", irq);\r\ngoto out_err;\r\n}\r\n}\r\n}\r\nedac->dfs = edac_debugfs_create_dir(pdev->dev.kobj.name);\r\nfor_each_child_of_node(pdev->dev.of_node, child) {\r\nif (!of_device_is_available(child))\r\ncontinue;\r\nif (of_device_is_compatible(child, "apm,xgene-edac-mc"))\r\nxgene_edac_mc_add(edac, child);\r\nif (of_device_is_compatible(child, "apm,xgene-edac-pmd"))\r\nxgene_edac_pmd_add(edac, child, 1);\r\nif (of_device_is_compatible(child, "apm,xgene-edac-pmd-v2"))\r\nxgene_edac_pmd_add(edac, child, 2);\r\nif (of_device_is_compatible(child, "apm,xgene-edac-l3"))\r\nxgene_edac_l3_add(edac, child, 1);\r\nif (of_device_is_compatible(child, "apm,xgene-edac-l3-v2"))\r\nxgene_edac_l3_add(edac, child, 2);\r\nif (of_device_is_compatible(child, "apm,xgene-edac-soc"))\r\nxgene_edac_soc_add(edac, child, 0);\r\nif (of_device_is_compatible(child, "apm,xgene-edac-soc-v1"))\r\nxgene_edac_soc_add(edac, child, 1);\r\n}\r\nreturn 0;\r\nout_err:\r\nreturn rc;\r\n}\r\nstatic int xgene_edac_remove(struct platform_device *pdev)\r\n{\r\nstruct xgene_edac *edac = dev_get_drvdata(&pdev->dev);\r\nstruct xgene_edac_mc_ctx *mcu;\r\nstruct xgene_edac_mc_ctx *temp_mcu;\r\nstruct xgene_edac_pmd_ctx *pmd;\r\nstruct xgene_edac_pmd_ctx *temp_pmd;\r\nstruct xgene_edac_dev_ctx *node;\r\nstruct xgene_edac_dev_ctx *temp_node;\r\nlist_for_each_entry_safe(mcu, temp_mcu, &edac->mcus, next)\r\nxgene_edac_mc_remove(mcu);\r\nlist_for_each_entry_safe(pmd, temp_pmd, &edac->pmds, next)\r\nxgene_edac_pmd_remove(pmd);\r\nlist_for_each_entry_safe(node, temp_node, &edac->l3s, next)\r\nxgene_edac_l3_remove(node);\r\nlist_for_each_entry_safe(node, temp_node, &edac->socs, next)\r\nxgene_edac_soc_remove(node);\r\nreturn 0;\r\n}\r\nstatic int __init xgene_edac_init(void)\r\n{\r\nint rc;\r\nswitch (edac_op_state) {\r\ncase EDAC_OPSTATE_POLL:\r\ncase EDAC_OPSTATE_INT:\r\nbreak;\r\ndefault:\r\nedac_op_state = EDAC_OPSTATE_INT;\r\nbreak;\r\n}\r\nrc = platform_driver_register(&xgene_edac_driver);\r\nif (rc) {\r\nedac_printk(KERN_ERR, EDAC_MOD_STR,\r\n"EDAC fails to register\n");\r\ngoto reg_failed;\r\n}\r\nreturn 0;\r\nreg_failed:\r\nreturn rc;\r\n}\r\nstatic void __exit xgene_edac_exit(void)\r\n{\r\nplatform_driver_unregister(&xgene_edac_driver);\r\n}
