int vvp_object_invariant(const struct cl_object *obj)\r\n{\r\nstruct inode *inode = vvp_object_inode(obj);\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nreturn (S_ISREG(inode->i_mode) || inode->i_mode == 0) &&\r\nlli->lli_clob == obj;\r\n}\r\nstatic int vvp_object_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t p, const struct lu_object *o)\r\n{\r\nstruct vvp_object *obj = lu2vvp(o);\r\nstruct inode *inode = obj->vob_inode;\r\nstruct ll_inode_info *lli;\r\n(*p)(env, cookie, "(%d %d) inode: %p ",\r\natomic_read(&obj->vob_transient_pages),\r\natomic_read(&obj->vob_mmap_cnt), inode);\r\nif (inode) {\r\nlli = ll_i2info(inode);\r\n(*p)(env, cookie, "%lu/%u %o %u %d %p "DFID,\r\ninode->i_ino, inode->i_generation, inode->i_mode,\r\ninode->i_nlink, atomic_read(&inode->i_count),\r\nlli->lli_clob, PFID(&lli->lli_fid));\r\n}\r\nreturn 0;\r\n}\r\nstatic int vvp_attr_get(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_attr *attr)\r\n{\r\nstruct inode *inode = vvp_object_inode(obj);\r\nattr->cat_size = i_size_read(inode);\r\nattr->cat_mtime = inode->i_mtime.tv_sec;\r\nattr->cat_atime = inode->i_atime.tv_sec;\r\nattr->cat_ctime = inode->i_ctime.tv_sec;\r\nattr->cat_blocks = inode->i_blocks;\r\nattr->cat_uid = from_kuid(&init_user_ns, inode->i_uid);\r\nattr->cat_gid = from_kgid(&init_user_ns, inode->i_gid);\r\nreturn 0;\r\n}\r\nstatic int vvp_attr_update(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_attr *attr, unsigned int valid)\r\n{\r\nstruct inode *inode = vvp_object_inode(obj);\r\nif (valid & CAT_UID)\r\ninode->i_uid = make_kuid(&init_user_ns, attr->cat_uid);\r\nif (valid & CAT_GID)\r\ninode->i_gid = make_kgid(&init_user_ns, attr->cat_gid);\r\nif (valid & CAT_ATIME)\r\ninode->i_atime.tv_sec = attr->cat_atime;\r\nif (valid & CAT_MTIME)\r\ninode->i_mtime.tv_sec = attr->cat_mtime;\r\nif (valid & CAT_CTIME)\r\ninode->i_ctime.tv_sec = attr->cat_ctime;\r\nif (0 && valid & CAT_SIZE)\r\ni_size_write(inode, attr->cat_size);\r\nif (0 && valid & (CAT_UID | CAT_GID | CAT_SIZE))\r\nmark_inode_dirty(inode);\r\nreturn 0;\r\n}\r\nstatic int vvp_conf_set(const struct lu_env *env, struct cl_object *obj,\r\nconst struct cl_object_conf *conf)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(conf->coc_inode);\r\nif (conf->coc_opc == OBJECT_CONF_INVALIDATE) {\r\nCDEBUG(D_VFSTRACE, DFID ": losing layout lock\n",\r\nPFID(&lli->lli_fid));\r\nll_layout_version_set(lli, CL_LAYOUT_GEN_NONE);\r\nunmap_mapping_range(conf->coc_inode->i_mapping,\r\n0, OBD_OBJECT_EOF, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int vvp_prune(const struct lu_env *env, struct cl_object *obj)\r\n{\r\nstruct inode *inode = vvp_object_inode(obj);\r\nint rc;\r\nrc = cl_sync_file_range(inode, 0, OBD_OBJECT_EOF, CL_FSYNC_LOCAL, 1);\r\nif (rc < 0) {\r\nCDEBUG(D_VFSTRACE, DFID ": writeback failed: %d\n",\r\nPFID(lu_object_fid(&obj->co_lu)), rc);\r\nreturn rc;\r\n}\r\ntruncate_inode_pages(inode->i_mapping, 0);\r\nreturn 0;\r\n}\r\nstatic int vvp_object_glimpse(const struct lu_env *env,\r\nconst struct cl_object *obj, struct ost_lvb *lvb)\r\n{\r\nstruct inode *inode = vvp_object_inode(obj);\r\nlvb->lvb_mtime = LTIME_S(inode->i_mtime);\r\nlvb->lvb_atime = LTIME_S(inode->i_atime);\r\nlvb->lvb_ctime = LTIME_S(inode->i_ctime);\r\nif (lvb->lvb_size > 0 && lvb->lvb_blocks == 0)\r\nlvb->lvb_blocks = dirty_cnt(inode);\r\nreturn 0;\r\n}\r\nstatic void vvp_req_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_req_attr *attr)\r\n{\r\nu64 valid_flags = OBD_MD_FLTYPE;\r\nstruct inode *inode;\r\nstruct obdo *oa;\r\noa = attr->cra_oa;\r\ninode = vvp_object_inode(obj);\r\nif (attr->cra_type == CRT_WRITE)\r\nvalid_flags |= OBD_MD_FLMTIME | OBD_MD_FLCTIME |\r\nOBD_MD_FLUID | OBD_MD_FLGID;\r\nobdo_from_inode(oa, inode, valid_flags & attr->cra_flags);\r\nobdo_set_parent_fid(oa, &ll_i2info(inode)->lli_fid);\r\nif (OBD_FAIL_CHECK(OBD_FAIL_LFSCK_INVALID_PFID))\r\noa->o_parent_oid++;\r\nmemcpy(attr->cra_jobid, ll_i2info(inode)->lli_jobid, LUSTRE_JOBID_SIZE);\r\n}\r\nstatic int vvp_object_init0(const struct lu_env *env,\r\nstruct vvp_object *vob,\r\nconst struct cl_object_conf *conf)\r\n{\r\nvob->vob_inode = conf->coc_inode;\r\natomic_set(&vob->vob_transient_pages, 0);\r\ncl_object_page_init(&vob->vob_cl, sizeof(struct vvp_page));\r\nreturn 0;\r\n}\r\nstatic int vvp_object_init(const struct lu_env *env, struct lu_object *obj,\r\nconst struct lu_object_conf *conf)\r\n{\r\nstruct vvp_device *dev = lu2vvp_dev(obj->lo_dev);\r\nstruct vvp_object *vob = lu2vvp(obj);\r\nstruct lu_object *below;\r\nstruct lu_device *under;\r\nint result;\r\nunder = &dev->vdv_next->cd_lu_dev;\r\nbelow = under->ld_ops->ldo_object_alloc(env, obj->lo_header, under);\r\nif (below) {\r\nconst struct cl_object_conf *cconf;\r\ncconf = lu2cl_conf(conf);\r\nlu_object_add(obj, below);\r\nresult = vvp_object_init0(env, vob, cconf);\r\n} else {\r\nresult = -ENOMEM;\r\n}\r\nreturn result;\r\n}\r\nstatic void vvp_object_free(const struct lu_env *env, struct lu_object *obj)\r\n{\r\nstruct vvp_object *vob = lu2vvp(obj);\r\nlu_object_fini(obj);\r\nlu_object_header_fini(obj->lo_header);\r\nkmem_cache_free(vvp_object_kmem, vob);\r\n}\r\nstruct vvp_object *cl_inode2vvp(struct inode *inode)\r\n{\r\nstruct ll_inode_info *lli = ll_i2info(inode);\r\nstruct cl_object *obj = lli->lli_clob;\r\nstruct lu_object *lu;\r\nlu = lu_object_locate(obj->co_lu.lo_header, &vvp_device_type);\r\nLASSERT(lu);\r\nreturn lu2vvp(lu);\r\n}\r\nstruct lu_object *vvp_object_alloc(const struct lu_env *env,\r\nconst struct lu_object_header *unused,\r\nstruct lu_device *dev)\r\n{\r\nstruct vvp_object *vob;\r\nstruct lu_object *obj;\r\nvob = kmem_cache_zalloc(vvp_object_kmem, GFP_NOFS);\r\nif (vob) {\r\nstruct cl_object_header *hdr;\r\nobj = &vob->vob_cl.co_lu;\r\nhdr = &vob->vob_header;\r\ncl_object_header_init(hdr);\r\nhdr->coh_page_bufsize = cfs_size_round(sizeof(struct cl_page));\r\nlu_object_init(obj, &hdr->coh_lu, dev);\r\nlu_object_add_top(&hdr->coh_lu, obj);\r\nvob->vob_cl.co_ops = &vvp_ops;\r\nobj->lo_ops = &vvp_lu_obj_ops;\r\n} else {\r\nobj = NULL;\r\n}\r\nreturn obj;\r\n}
