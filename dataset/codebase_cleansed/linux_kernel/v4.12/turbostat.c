int cpu_is_not_present(int cpu)\r\n{\r\nreturn !CPU_ISSET_S(cpu, cpu_present_setsize, cpu_present_set);\r\n}\r\nint for_all_cpus(int (func)(struct thread_data *, struct core_data *, struct pkg_data *),\r\nstruct thread_data *thread_base, struct core_data *core_base, struct pkg_data *pkg_base)\r\n{\r\nint retval, pkg_no, core_no, thread_no;\r\nfor (pkg_no = 0; pkg_no < topo.num_packages; ++pkg_no) {\r\nfor (core_no = 0; core_no < topo.num_cores_per_pkg; ++core_no) {\r\nfor (thread_no = 0; thread_no <\r\ntopo.num_threads_per_core; ++thread_no) {\r\nstruct thread_data *t;\r\nstruct core_data *c;\r\nstruct pkg_data *p;\r\nt = GET_THREAD(thread_base, thread_no, core_no, pkg_no);\r\nif (cpu_is_not_present(t->cpu_id))\r\ncontinue;\r\nc = GET_CORE(core_base, core_no, pkg_no);\r\np = GET_PKG(pkg_base, pkg_no);\r\nretval = func(t, c, p);\r\nif (retval)\r\nreturn retval;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint cpu_migrate(int cpu)\r\n{\r\nCPU_ZERO_S(cpu_affinity_setsize, cpu_affinity_set);\r\nCPU_SET_S(cpu, cpu_affinity_setsize, cpu_affinity_set);\r\nif (sched_setaffinity(0, cpu_affinity_setsize, cpu_affinity_set) == -1)\r\nreturn -1;\r\nelse\r\nreturn 0;\r\n}\r\nint get_msr_fd(int cpu)\r\n{\r\nchar pathname[32];\r\nint fd;\r\nfd = fd_percpu[cpu];\r\nif (fd)\r\nreturn fd;\r\nsprintf(pathname, "/dev/cpu/%d/msr", cpu);\r\nfd = open(pathname, O_RDONLY);\r\nif (fd < 0)\r\nerr(-1, "%s open failed, try chown or chmod +r /dev/cpu/*/msr, or run as root", pathname);\r\nfd_percpu[cpu] = fd;\r\nreturn fd;\r\n}\r\nint get_msr(int cpu, off_t offset, unsigned long long *msr)\r\n{\r\nssize_t retval;\r\nretval = pread(get_msr_fd(cpu), msr, sizeof(*msr), offset);\r\nif (retval != sizeof *msr)\r\nerr(-1, "cpu%d: msr offset 0x%llx read failed", cpu, (unsigned long long)offset);\r\nreturn 0;\r\n}\r\nvoid help(void)\r\n{\r\nfprintf(outf,\r\n"Usage: turbostat [OPTIONS][(--interval seconds) | COMMAND ...]\n"\r\n"\n"\r\n"Turbostat forks the specified COMMAND and prints statistics\n"\r\n"when COMMAND completes.\n"\r\n"If no COMMAND is specified, turbostat wakes every 5-seconds\n"\r\n"to print statistics, until interrupted.\n"\r\n"--add add a counter\n"\r\n" eg. --add msr0x10,u64,cpu,delta,MY_TSC\n"\r\n"--cpu cpu-set limit output to summary plus cpu-set:\n"\r\n" {core | package | j,k,l..m,n-p }\n"\r\n"--quiet skip decoding system configuration header\n"\r\n"--interval sec Override default 5-second measurement interval\n"\r\n"--help print this help message\n"\r\n"--list list column headers only\n"\r\n"--out file create or truncate \"file\" for all output\n"\r\n"--version print version information\n"\r\n"\n"\r\n"For more help, run \"man turbostat\"\n");\r\n}\r\nunsigned long long bic_lookup(char *name_list, enum show_hide_mode mode)\r\n{\r\nint i;\r\nunsigned long long retval = 0;\r\nwhile (name_list) {\r\nchar *comma;\r\ncomma = strchr(name_list, ',');\r\nif (comma)\r\n*comma = '\0';\r\nfor (i = 0; i < MAX_BIC; ++i) {\r\nif (!strcmp(name_list, bic[i].name)) {\r\nretval |= (1ULL << i);\r\nbreak;\r\n}\r\n}\r\nif (i == MAX_BIC) {\r\nif (mode == SHOW_LIST) {\r\nfprintf(stderr, "Invalid counter name: %s\n", name_list);\r\nexit(-1);\r\n}\r\ndeferred_skip_names[deferred_skip_index++] = name_list;\r\nif (debug)\r\nfprintf(stderr, "deferred \"%s\"\n", name_list);\r\nif (deferred_skip_index >= MAX_DEFERRED) {\r\nfprintf(stderr, "More than max %d un-recognized --skip options '%s'\n",\r\nMAX_DEFERRED, name_list);\r\nhelp();\r\nexit(1);\r\n}\r\n}\r\nname_list = comma;\r\nif (name_list)\r\nname_list++;\r\n}\r\nreturn retval;\r\n}\r\nvoid print_header(char *delim)\r\n{\r\nstruct msr_counter *mp;\r\nint printed = 0;\r\nif (DO_BIC(BIC_Package))\r\noutp += sprintf(outp, "%sPackage", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Core))\r\noutp += sprintf(outp, "%sCore", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CPU))\r\noutp += sprintf(outp, "%sCPU", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Avg_MHz))\r\noutp += sprintf(outp, "%sAvg_MHz", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Busy))\r\noutp += sprintf(outp, "%sBusy%%", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Bzy_MHz))\r\noutp += sprintf(outp, "%sBzy_MHz", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_TSC_MHz))\r\noutp += sprintf(outp, "%sTSC_MHz", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_IRQ)) {\r\nif (sums_need_wide_columns)\r\noutp += sprintf(outp, "%s IRQ", (printed++ ? delim : ""));\r\nelse\r\noutp += sprintf(outp, "%sIRQ", (printed++ ? delim : ""));\r\n}\r\nif (DO_BIC(BIC_SMI))\r\noutp += sprintf(outp, "%sSMI", (printed++ ? delim : ""));\r\nfor (mp = sys.tp; mp; mp = mp->next) {\r\nif (mp->format == FORMAT_RAW) {\r\nif (mp->width == 64)\r\noutp += sprintf(outp, "%s%18.18s", (printed++ ? delim : ""), mp->name);\r\nelse\r\noutp += sprintf(outp, "%s%10.10s", (printed++ ? delim : ""), mp->name);\r\n} else {\r\nif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8s", (printed++ ? delim : ""), mp->name);\r\nelse\r\noutp += sprintf(outp, "%s%s", (printed++ ? delim : ""), mp->name);\r\n}\r\n}\r\nif (DO_BIC(BIC_CPU_c1))\r\noutp += sprintf(outp, "%sCPU%%c1", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CPU_c3) && !do_slm_cstates && !do_knl_cstates)\r\noutp += sprintf(outp, "%sCPU%%c3", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CPU_c6))\r\noutp += sprintf(outp, "%sCPU%%c6", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CPU_c7))\r\noutp += sprintf(outp, "%sCPU%%c7", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Mod_c6))\r\noutp += sprintf(outp, "%sMod%%c6", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CoreTmp))\r\noutp += sprintf(outp, "%sCoreTmp", (printed++ ? delim : ""));\r\nfor (mp = sys.cp; mp; mp = mp->next) {\r\nif (mp->format == FORMAT_RAW) {\r\nif (mp->width == 64)\r\noutp += sprintf(outp, "%s%18.18s", delim, mp->name);\r\nelse\r\noutp += sprintf(outp, "%s%10.10s", delim, mp->name);\r\n} else {\r\nif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8s", delim, mp->name);\r\nelse\r\noutp += sprintf(outp, "%s%s", delim, mp->name);\r\n}\r\n}\r\nif (DO_BIC(BIC_PkgTmp))\r\noutp += sprintf(outp, "%sPkgTmp", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_GFX_rc6))\r\noutp += sprintf(outp, "%sGFX%%rc6", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_GFXMHz))\r\noutp += sprintf(outp, "%sGFXMHz", (printed++ ? delim : ""));\r\nif (do_skl_residency) {\r\noutp += sprintf(outp, "%sTotl%%C0", (printed++ ? delim : ""));\r\noutp += sprintf(outp, "%sAny%%C0", (printed++ ? delim : ""));\r\noutp += sprintf(outp, "%sGFX%%C0", (printed++ ? delim : ""));\r\noutp += sprintf(outp, "%sCPUGFX%%", (printed++ ? delim : ""));\r\n}\r\nif (DO_BIC(BIC_Pkgpc2))\r\noutp += sprintf(outp, "%sPkg%%pc2", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Pkgpc3))\r\noutp += sprintf(outp, "%sPkg%%pc3", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Pkgpc6))\r\noutp += sprintf(outp, "%sPkg%%pc6", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Pkgpc7))\r\noutp += sprintf(outp, "%sPkg%%pc7", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Pkgpc8))\r\noutp += sprintf(outp, "%sPkg%%pc8", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Pkgpc9))\r\noutp += sprintf(outp, "%sPkg%%pc9", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Pkgpc10))\r\noutp += sprintf(outp, "%sPk%%pc10", (printed++ ? delim : ""));\r\nif (do_rapl && !rapl_joules) {\r\nif (DO_BIC(BIC_PkgWatt))\r\noutp += sprintf(outp, "%sPkgWatt", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CorWatt))\r\noutp += sprintf(outp, "%sCorWatt", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_GFXWatt))\r\noutp += sprintf(outp, "%sGFXWatt", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_RAMWatt))\r\noutp += sprintf(outp, "%sRAMWatt", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_PKG__))\r\noutp += sprintf(outp, "%sPKG_%%", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_RAM__))\r\noutp += sprintf(outp, "%sRAM_%%", (printed++ ? delim : ""));\r\n} else if (do_rapl && rapl_joules) {\r\nif (DO_BIC(BIC_Pkg_J))\r\noutp += sprintf(outp, "%sPkg_J", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Cor_J))\r\noutp += sprintf(outp, "%sCor_J", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_GFX_J))\r\noutp += sprintf(outp, "%sGFX_J", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_RAM_J))\r\noutp += sprintf(outp, "%sRAM_J", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_PKG__))\r\noutp += sprintf(outp, "%sPKG_%%", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_RAM__))\r\noutp += sprintf(outp, "%sRAM_%%", (printed++ ? delim : ""));\r\n}\r\nfor (mp = sys.pp; mp; mp = mp->next) {\r\nif (mp->format == FORMAT_RAW) {\r\nif (mp->width == 64)\r\noutp += sprintf(outp, "%s%18.18s", delim, mp->name);\r\nelse\r\noutp += sprintf(outp, "%s%10.10s", delim, mp->name);\r\n} else {\r\nif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8s", delim, mp->name);\r\nelse\r\noutp += sprintf(outp, "%s%s", delim, mp->name);\r\n}\r\n}\r\noutp += sprintf(outp, "\n");\r\n}\r\nint dump_counters(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\noutp += sprintf(outp, "t %p, c %p, p %p\n", t, c, p);\r\nif (t) {\r\noutp += sprintf(outp, "CPU: %d flags 0x%x\n",\r\nt->cpu_id, t->flags);\r\noutp += sprintf(outp, "TSC: %016llX\n", t->tsc);\r\noutp += sprintf(outp, "aperf: %016llX\n", t->aperf);\r\noutp += sprintf(outp, "mperf: %016llX\n", t->mperf);\r\noutp += sprintf(outp, "c1: %016llX\n", t->c1);\r\nif (DO_BIC(BIC_IRQ))\r\noutp += sprintf(outp, "IRQ: %lld\n", t->irq_count);\r\nif (DO_BIC(BIC_SMI))\r\noutp += sprintf(outp, "SMI: %d\n", t->smi_count);\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\r\noutp += sprintf(outp, "tADDED [%d] msr0x%x: %08llX\n",\r\ni, mp->msr_num, t->counter[i]);\r\n}\r\n}\r\nif (c) {\r\noutp += sprintf(outp, "core: %d\n", c->core_id);\r\noutp += sprintf(outp, "c3: %016llX\n", c->c3);\r\noutp += sprintf(outp, "c6: %016llX\n", c->c6);\r\noutp += sprintf(outp, "c7: %016llX\n", c->c7);\r\noutp += sprintf(outp, "DTS: %dC\n", c->core_temp_c);\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\r\noutp += sprintf(outp, "cADDED [%d] msr0x%x: %08llX\n",\r\ni, mp->msr_num, c->counter[i]);\r\n}\r\noutp += sprintf(outp, "mc6_us: %016llX\n", c->mc6_us);\r\n}\r\nif (p) {\r\noutp += sprintf(outp, "package: %d\n", p->package_id);\r\noutp += sprintf(outp, "Weighted cores: %016llX\n", p->pkg_wtd_core_c0);\r\noutp += sprintf(outp, "Any cores: %016llX\n", p->pkg_any_core_c0);\r\noutp += sprintf(outp, "Any GFX: %016llX\n", p->pkg_any_gfxe_c0);\r\noutp += sprintf(outp, "CPU + GFX: %016llX\n", p->pkg_both_core_gfxe_c0);\r\noutp += sprintf(outp, "pc2: %016llX\n", p->pc2);\r\nif (DO_BIC(BIC_Pkgpc3))\r\noutp += sprintf(outp, "pc3: %016llX\n", p->pc3);\r\nif (DO_BIC(BIC_Pkgpc6))\r\noutp += sprintf(outp, "pc6: %016llX\n", p->pc6);\r\nif (DO_BIC(BIC_Pkgpc7))\r\noutp += sprintf(outp, "pc7: %016llX\n", p->pc7);\r\noutp += sprintf(outp, "pc8: %016llX\n", p->pc8);\r\noutp += sprintf(outp, "pc9: %016llX\n", p->pc9);\r\noutp += sprintf(outp, "pc10: %016llX\n", p->pc10);\r\noutp += sprintf(outp, "Joules PKG: %0X\n", p->energy_pkg);\r\noutp += sprintf(outp, "Joules COR: %0X\n", p->energy_cores);\r\noutp += sprintf(outp, "Joules GFX: %0X\n", p->energy_gfx);\r\noutp += sprintf(outp, "Joules RAM: %0X\n", p->energy_dram);\r\noutp += sprintf(outp, "Throttle PKG: %0X\n",\r\np->rapl_pkg_perf_status);\r\noutp += sprintf(outp, "Throttle RAM: %0X\n",\r\np->rapl_dram_perf_status);\r\noutp += sprintf(outp, "PTM: %dC\n", p->pkg_temp_c);\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\r\noutp += sprintf(outp, "pADDED [%d] msr0x%x: %08llX\n",\r\ni, mp->msr_num, p->counter[i]);\r\n}\r\n}\r\noutp += sprintf(outp, "\n");\r\nreturn 0;\r\n}\r\nint format_counters(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\ndouble interval_float, tsc;\r\nchar *fmt8;\r\nint i;\r\nstruct msr_counter *mp;\r\nchar *delim = "\t";\r\nint printed = 0;\r\nif (show_core_only && !(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\nif (show_pkg_only && !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif ((t != &average.threads) &&\r\n(cpu_subset && !CPU_ISSET_S(t->cpu_id, cpu_subset_size, cpu_subset)))\r\nreturn 0;\r\ninterval_float = tv_delta.tv_sec + tv_delta.tv_usec/1000000.0;\r\ntsc = t->tsc * tsc_tweak;\r\nif (t == &average.threads) {\r\nif (DO_BIC(BIC_Package))\r\noutp += sprintf(outp, "%s-", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_Core))\r\noutp += sprintf(outp, "%s-", (printed++ ? delim : ""));\r\nif (DO_BIC(BIC_CPU))\r\noutp += sprintf(outp, "%s-", (printed++ ? delim : ""));\r\n} else {\r\nif (DO_BIC(BIC_Package)) {\r\nif (p)\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), p->package_id);\r\nelse\r\noutp += sprintf(outp, "%s-", (printed++ ? delim : ""));\r\n}\r\nif (DO_BIC(BIC_Core)) {\r\nif (c)\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), c->core_id);\r\nelse\r\noutp += sprintf(outp, "%s-", (printed++ ? delim : ""));\r\n}\r\nif (DO_BIC(BIC_CPU))\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), t->cpu_id);\r\n}\r\nif (DO_BIC(BIC_Avg_MHz))\r\noutp += sprintf(outp, "%s%.0f", (printed++ ? delim : ""),\r\n1.0 / units * t->aperf / interval_float);\r\nif (DO_BIC(BIC_Busy))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * t->mperf/tsc);\r\nif (DO_BIC(BIC_Bzy_MHz)) {\r\nif (has_base_hz)\r\noutp += sprintf(outp, "%s%.0f", (printed++ ? delim : ""), base_hz / units * t->aperf / t->mperf);\r\nelse\r\noutp += sprintf(outp, "%s%.0f", (printed++ ? delim : ""),\r\ntsc / units * t->aperf / t->mperf / interval_float);\r\n}\r\nif (DO_BIC(BIC_TSC_MHz))\r\noutp += sprintf(outp, "%s%.0f", (printed++ ? delim : ""), 1.0 * t->tsc/units/interval_float);\r\nif (DO_BIC(BIC_IRQ)) {\r\nif (sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8lld", (printed++ ? delim : ""), t->irq_count);\r\nelse\r\noutp += sprintf(outp, "%s%lld", (printed++ ? delim : ""), t->irq_count);\r\n}\r\nif (DO_BIC(BIC_SMI))\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), t->smi_count);\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW) {\r\nif (mp->width == 32)\r\noutp += sprintf(outp, "%s0x%08x", (printed++ ? delim : ""), (unsigned int) t->counter[i]);\r\nelse\r\noutp += sprintf(outp, "%s0x%016llx", (printed++ ? delim : ""), t->counter[i]);\r\n} else if (mp->format == FORMAT_DELTA) {\r\nif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8lld", (printed++ ? delim : ""), t->counter[i]);\r\nelse\r\noutp += sprintf(outp, "%s%lld", (printed++ ? delim : ""), t->counter[i]);\r\n} else if (mp->format == FORMAT_PERCENT) {\r\nif (mp->type == COUNTER_USEC)\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), t->counter[i]/interval_float/10000);\r\nelse\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * t->counter[i]/tsc);\r\n}\r\n}\r\nif (DO_BIC(BIC_CPU_c1))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * t->c1/tsc);\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\ngoto done;\r\nif (DO_BIC(BIC_CPU_c3) && !do_slm_cstates && !do_knl_cstates)\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * c->c3/tsc);\r\nif (DO_BIC(BIC_CPU_c6))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * c->c6/tsc);\r\nif (DO_BIC(BIC_CPU_c7))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * c->c7/tsc);\r\nif (DO_BIC(BIC_Mod_c6))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * c->mc6_us / tsc);\r\nif (DO_BIC(BIC_CoreTmp))\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), c->core_temp_c);\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW) {\r\nif (mp->width == 32)\r\noutp += sprintf(outp, "%s0x%08x", (printed++ ? delim : ""), (unsigned int) c->counter[i]);\r\nelse\r\noutp += sprintf(outp, "%s0x%016llx", (printed++ ? delim : ""), c->counter[i]);\r\n} else if (mp->format == FORMAT_DELTA) {\r\nif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8lld", (printed++ ? delim : ""), c->counter[i]);\r\nelse\r\noutp += sprintf(outp, "%s%lld", (printed++ ? delim : ""), c->counter[i]);\r\n} else if (mp->format == FORMAT_PERCENT) {\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * c->counter[i]/tsc);\r\n}\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\ngoto done;\r\nif (DO_BIC(BIC_PkgTmp))\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), p->pkg_temp_c);\r\nif (DO_BIC(BIC_GFX_rc6)) {\r\nif (p->gfx_rc6_ms == -1) {\r\noutp += sprintf(outp, "%s**.**", (printed++ ? delim : ""));\r\n} else {\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""),\r\np->gfx_rc6_ms / 10.0 / interval_float);\r\n}\r\n}\r\nif (DO_BIC(BIC_GFXMHz))\r\noutp += sprintf(outp, "%s%d", (printed++ ? delim : ""), p->gfx_mhz);\r\nif (do_skl_residency) {\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pkg_wtd_core_c0/tsc);\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pkg_any_core_c0/tsc);\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pkg_any_gfxe_c0/tsc);\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pkg_both_core_gfxe_c0/tsc);\r\n}\r\nif (DO_BIC(BIC_Pkgpc2))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc2/tsc);\r\nif (DO_BIC(BIC_Pkgpc3))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc3/tsc);\r\nif (DO_BIC(BIC_Pkgpc6))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc6/tsc);\r\nif (DO_BIC(BIC_Pkgpc7))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc7/tsc);\r\nif (DO_BIC(BIC_Pkgpc8))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc8/tsc);\r\nif (DO_BIC(BIC_Pkgpc9))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc9/tsc);\r\nif (DO_BIC(BIC_Pkgpc10))\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->pc10/tsc);\r\nif (interval_float < rapl_joule_counter_range)\r\nfmt8 = "%s%.2f";\r\nelse\r\nfmt8 = "%6.0f**";\r\nif (DO_BIC(BIC_PkgWatt))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_pkg * rapl_energy_units / interval_float);\r\nif (DO_BIC(BIC_CorWatt))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_cores * rapl_energy_units / interval_float);\r\nif (DO_BIC(BIC_GFXWatt))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_gfx * rapl_energy_units / interval_float);\r\nif (DO_BIC(BIC_RAMWatt))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_dram * rapl_dram_energy_units / interval_float);\r\nif (DO_BIC(BIC_Pkg_J))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_pkg * rapl_energy_units);\r\nif (DO_BIC(BIC_Cor_J))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_cores * rapl_energy_units);\r\nif (DO_BIC(BIC_GFX_J))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_gfx * rapl_energy_units);\r\nif (DO_BIC(BIC_RAM_J))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), p->energy_dram * rapl_dram_energy_units);\r\nif (DO_BIC(BIC_PKG__))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), 100.0 * p->rapl_pkg_perf_status * rapl_time_units / interval_float);\r\nif (DO_BIC(BIC_RAM__))\r\noutp += sprintf(outp, fmt8, (printed++ ? delim : ""), 100.0 * p->rapl_dram_perf_status * rapl_time_units / interval_float);\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW) {\r\nif (mp->width == 32)\r\noutp += sprintf(outp, "%s0x%08x", (printed++ ? delim : ""), (unsigned int) p->counter[i]);\r\nelse\r\noutp += sprintf(outp, "%s0x%016llx", (printed++ ? delim : ""), p->counter[i]);\r\n} else if (mp->format == FORMAT_DELTA) {\r\nif ((mp->type == COUNTER_ITEMS) && sums_need_wide_columns)\r\noutp += sprintf(outp, "%s%8lld", (printed++ ? delim : ""), p->counter[i]);\r\nelse\r\noutp += sprintf(outp, "%s%lld", (printed++ ? delim : ""), p->counter[i]);\r\n} else if (mp->format == FORMAT_PERCENT) {\r\noutp += sprintf(outp, "%s%.2f", (printed++ ? delim : ""), 100.0 * p->counter[i]/tsc);\r\n}\r\n}\r\ndone:\r\noutp += sprintf(outp, "\n");\r\nreturn 0;\r\n}\r\nvoid flush_output_stdout(void)\r\n{\r\nFILE *filep;\r\nif (outf == stderr)\r\nfilep = stdout;\r\nelse\r\nfilep = outf;\r\nfputs(output_buffer, filep);\r\nfflush(filep);\r\noutp = output_buffer;\r\n}\r\nvoid flush_output_stderr(void)\r\n{\r\nfputs(output_buffer, outf);\r\nfflush(outf);\r\noutp = output_buffer;\r\n}\r\nvoid format_all_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nstatic int printed;\r\nif (!printed || !summary_only)\r\nprint_header("\t");\r\nif (topo.num_cpus > 1)\r\nformat_counters(&average.threads, &average.cores,\r\n&average.packages);\r\nprinted = 1;\r\nif (summary_only)\r\nreturn;\r\nfor_all_cpus(format_counters, t, c, p);\r\n}\r\nint\r\ndelta_package(struct pkg_data *new, struct pkg_data *old)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\nif (do_skl_residency) {\r\nold->pkg_wtd_core_c0 = new->pkg_wtd_core_c0 - old->pkg_wtd_core_c0;\r\nold->pkg_any_core_c0 = new->pkg_any_core_c0 - old->pkg_any_core_c0;\r\nold->pkg_any_gfxe_c0 = new->pkg_any_gfxe_c0 - old->pkg_any_gfxe_c0;\r\nold->pkg_both_core_gfxe_c0 = new->pkg_both_core_gfxe_c0 - old->pkg_both_core_gfxe_c0;\r\n}\r\nold->pc2 = new->pc2 - old->pc2;\r\nif (DO_BIC(BIC_Pkgpc3))\r\nold->pc3 = new->pc3 - old->pc3;\r\nif (DO_BIC(BIC_Pkgpc6))\r\nold->pc6 = new->pc6 - old->pc6;\r\nif (DO_BIC(BIC_Pkgpc7))\r\nold->pc7 = new->pc7 - old->pc7;\r\nold->pc8 = new->pc8 - old->pc8;\r\nold->pc9 = new->pc9 - old->pc9;\r\nold->pc10 = new->pc10 - old->pc10;\r\nold->pkg_temp_c = new->pkg_temp_c;\r\nif (old->gfx_rc6_ms > new->gfx_rc6_ms)\r\nold->gfx_rc6_ms = -1;\r\nelse\r\nold->gfx_rc6_ms = new->gfx_rc6_ms - old->gfx_rc6_ms;\r\nold->gfx_mhz = new->gfx_mhz;\r\nDELTA_WRAP32(new->energy_pkg, old->energy_pkg);\r\nDELTA_WRAP32(new->energy_cores, old->energy_cores);\r\nDELTA_WRAP32(new->energy_gfx, old->energy_gfx);\r\nDELTA_WRAP32(new->energy_dram, old->energy_dram);\r\nDELTA_WRAP32(new->rapl_pkg_perf_status, old->rapl_pkg_perf_status);\r\nDELTA_WRAP32(new->rapl_dram_perf_status, old->rapl_dram_perf_status);\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\nold->counter[i] = new->counter[i];\r\nelse\r\nold->counter[i] = new->counter[i] - old->counter[i];\r\n}\r\nreturn 0;\r\n}\r\nvoid\r\ndelta_core(struct core_data *new, struct core_data *old)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\nold->c3 = new->c3 - old->c3;\r\nold->c6 = new->c6 - old->c6;\r\nold->c7 = new->c7 - old->c7;\r\nold->core_temp_c = new->core_temp_c;\r\nold->mc6_us = new->mc6_us - old->mc6_us;\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\nold->counter[i] = new->counter[i];\r\nelse\r\nold->counter[i] = new->counter[i] - old->counter[i];\r\n}\r\n}\r\nint\r\ndelta_thread(struct thread_data *new, struct thread_data *old,\r\nstruct core_data *core_delta)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\nold->tsc = new->tsc - old->tsc;\r\nif (old->tsc < (1000 * 1000))\r\nerrx(-3, "Insanely slow TSC rate, TSC stops in idle?\n"\r\n"You can disable all c-states by booting with \"idle=poll\"\n"\r\n"or just the deep ones with \"processor.max_cstate=1\"");\r\nold->c1 = new->c1 - old->c1;\r\nif (DO_BIC(BIC_Avg_MHz) || DO_BIC(BIC_Busy) || DO_BIC(BIC_Bzy_MHz)) {\r\nif ((new->aperf > old->aperf) && (new->mperf > old->mperf)) {\r\nold->aperf = new->aperf - old->aperf;\r\nold->mperf = new->mperf - old->mperf;\r\n} else {\r\nreturn -1;\r\n}\r\n}\r\nif (use_c1_residency_msr) {\r\n} else {\r\nif ((old->mperf + core_delta->c3 + core_delta->c6 + core_delta->c7) > (old->tsc * tsc_tweak))\r\nold->c1 = 0;\r\nelse {\r\nold->c1 = (old->tsc * tsc_tweak) - old->mperf - core_delta->c3\r\n- core_delta->c6 - core_delta->c7;\r\n}\r\n}\r\nif (old->mperf == 0) {\r\nif (debug > 1)\r\nfprintf(outf, "cpu%d MPERF 0!\n", old->cpu_id);\r\nold->mperf = 1;\r\n}\r\nif (DO_BIC(BIC_IRQ))\r\nold->irq_count = new->irq_count - old->irq_count;\r\nif (DO_BIC(BIC_SMI))\r\nold->smi_count = new->smi_count - old->smi_count;\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\nold->counter[i] = new->counter[i];\r\nelse\r\nold->counter[i] = new->counter[i] - old->counter[i];\r\n}\r\nreturn 0;\r\n}\r\nint delta_cpu(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p, struct thread_data *t2,\r\nstruct core_data *c2, struct pkg_data *p2)\r\n{\r\nint retval = 0;\r\nif (t->flags & CPU_IS_FIRST_THREAD_IN_CORE)\r\ndelta_core(c, c2);\r\nretval = delta_thread(t, t2, c2);\r\nif (retval)\r\nreturn retval;\r\nif (t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE)\r\nretval = delta_package(p, p2);\r\nreturn retval;\r\n}\r\nvoid clear_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\nt->tsc = 0;\r\nt->aperf = 0;\r\nt->mperf = 0;\r\nt->c1 = 0;\r\nt->irq_count = 0;\r\nt->smi_count = 0;\r\nt->flags = CPU_IS_FIRST_THREAD_IN_CORE | CPU_IS_FIRST_CORE_IN_PACKAGE;\r\nc->c3 = 0;\r\nc->c6 = 0;\r\nc->c7 = 0;\r\nc->mc6_us = 0;\r\nc->core_temp_c = 0;\r\np->pkg_wtd_core_c0 = 0;\r\np->pkg_any_core_c0 = 0;\r\np->pkg_any_gfxe_c0 = 0;\r\np->pkg_both_core_gfxe_c0 = 0;\r\np->pc2 = 0;\r\nif (DO_BIC(BIC_Pkgpc3))\r\np->pc3 = 0;\r\nif (DO_BIC(BIC_Pkgpc6))\r\np->pc6 = 0;\r\nif (DO_BIC(BIC_Pkgpc7))\r\np->pc7 = 0;\r\np->pc8 = 0;\r\np->pc9 = 0;\r\np->pc10 = 0;\r\np->energy_pkg = 0;\r\np->energy_dram = 0;\r\np->energy_cores = 0;\r\np->energy_gfx = 0;\r\np->rapl_pkg_perf_status = 0;\r\np->rapl_dram_perf_status = 0;\r\np->pkg_temp_c = 0;\r\np->gfx_rc6_ms = 0;\r\np->gfx_mhz = 0;\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next)\r\nt->counter[i] = 0;\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next)\r\nc->counter[i] = 0;\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next)\r\np->counter[i] = 0;\r\n}\r\nint sum_counters(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\naverage.threads.tsc += t->tsc;\r\naverage.threads.aperf += t->aperf;\r\naverage.threads.mperf += t->mperf;\r\naverage.threads.c1 += t->c1;\r\naverage.threads.irq_count += t->irq_count;\r\naverage.threads.smi_count += t->smi_count;\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\ncontinue;\r\naverage.threads.counter[i] += t->counter[i];\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\naverage.cores.c3 += c->c3;\r\naverage.cores.c6 += c->c6;\r\naverage.cores.c7 += c->c7;\r\naverage.cores.mc6_us += c->mc6_us;\r\naverage.cores.core_temp_c = MAX(average.cores.core_temp_c, c->core_temp_c);\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\ncontinue;\r\naverage.cores.counter[i] += c->counter[i];\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (do_skl_residency) {\r\naverage.packages.pkg_wtd_core_c0 += p->pkg_wtd_core_c0;\r\naverage.packages.pkg_any_core_c0 += p->pkg_any_core_c0;\r\naverage.packages.pkg_any_gfxe_c0 += p->pkg_any_gfxe_c0;\r\naverage.packages.pkg_both_core_gfxe_c0 += p->pkg_both_core_gfxe_c0;\r\n}\r\naverage.packages.pc2 += p->pc2;\r\nif (DO_BIC(BIC_Pkgpc3))\r\naverage.packages.pc3 += p->pc3;\r\nif (DO_BIC(BIC_Pkgpc6))\r\naverage.packages.pc6 += p->pc6;\r\nif (DO_BIC(BIC_Pkgpc7))\r\naverage.packages.pc7 += p->pc7;\r\naverage.packages.pc8 += p->pc8;\r\naverage.packages.pc9 += p->pc9;\r\naverage.packages.pc10 += p->pc10;\r\naverage.packages.energy_pkg += p->energy_pkg;\r\naverage.packages.energy_dram += p->energy_dram;\r\naverage.packages.energy_cores += p->energy_cores;\r\naverage.packages.energy_gfx += p->energy_gfx;\r\naverage.packages.gfx_rc6_ms = p->gfx_rc6_ms;\r\naverage.packages.gfx_mhz = p->gfx_mhz;\r\naverage.packages.pkg_temp_c = MAX(average.packages.pkg_temp_c, p->pkg_temp_c);\r\naverage.packages.rapl_pkg_perf_status += p->rapl_pkg_perf_status;\r\naverage.packages.rapl_dram_perf_status += p->rapl_dram_perf_status;\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\ncontinue;\r\naverage.packages.counter[i] += p->counter[i];\r\n}\r\nreturn 0;\r\n}\r\nvoid compute_average(struct thread_data *t, struct core_data *c,\r\nstruct pkg_data *p)\r\n{\r\nint i;\r\nstruct msr_counter *mp;\r\nclear_counters(&average.threads, &average.cores, &average.packages);\r\nfor_all_cpus(sum_counters, t, c, p);\r\naverage.threads.tsc /= topo.num_cpus;\r\naverage.threads.aperf /= topo.num_cpus;\r\naverage.threads.mperf /= topo.num_cpus;\r\naverage.threads.c1 /= topo.num_cpus;\r\nif (average.threads.irq_count > 9999999)\r\nsums_need_wide_columns = 1;\r\naverage.cores.c3 /= topo.num_cores;\r\naverage.cores.c6 /= topo.num_cores;\r\naverage.cores.c7 /= topo.num_cores;\r\naverage.cores.mc6_us /= topo.num_cores;\r\nif (do_skl_residency) {\r\naverage.packages.pkg_wtd_core_c0 /= topo.num_packages;\r\naverage.packages.pkg_any_core_c0 /= topo.num_packages;\r\naverage.packages.pkg_any_gfxe_c0 /= topo.num_packages;\r\naverage.packages.pkg_both_core_gfxe_c0 /= topo.num_packages;\r\n}\r\naverage.packages.pc2 /= topo.num_packages;\r\nif (DO_BIC(BIC_Pkgpc3))\r\naverage.packages.pc3 /= topo.num_packages;\r\nif (DO_BIC(BIC_Pkgpc6))\r\naverage.packages.pc6 /= topo.num_packages;\r\nif (DO_BIC(BIC_Pkgpc7))\r\naverage.packages.pc7 /= topo.num_packages;\r\naverage.packages.pc8 /= topo.num_packages;\r\naverage.packages.pc9 /= topo.num_packages;\r\naverage.packages.pc10 /= topo.num_packages;\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\ncontinue;\r\nif (mp->type == COUNTER_ITEMS) {\r\nif (average.threads.counter[i] > 9999999)\r\nsums_need_wide_columns = 1;\r\ncontinue;\r\n}\r\naverage.threads.counter[i] /= topo.num_cpus;\r\n}\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\ncontinue;\r\nif (mp->type == COUNTER_ITEMS) {\r\nif (average.cores.counter[i] > 9999999)\r\nsums_need_wide_columns = 1;\r\n}\r\naverage.cores.counter[i] /= topo.num_cores;\r\n}\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\r\nif (mp->format == FORMAT_RAW)\r\ncontinue;\r\nif (mp->type == COUNTER_ITEMS) {\r\nif (average.packages.counter[i] > 9999999)\r\nsums_need_wide_columns = 1;\r\n}\r\naverage.packages.counter[i] /= topo.num_packages;\r\n}\r\n}\r\nstatic unsigned long long rdtsc(void)\r\n{\r\nunsigned int low, high;\r\nasm volatile("rdtsc" : "=a" (low), "=d" (high));\r\nreturn low | ((unsigned long long)high) << 32;\r\n}\r\nFILE *fopen_or_die(const char *path, const char *mode)\r\n{\r\nFILE *filep = fopen(path, mode);\r\nif (!filep)\r\nerr(1, "%s: open failed", path);\r\nreturn filep;\r\n}\r\nunsigned long long snapshot_sysfs_counter(char *path)\r\n{\r\nFILE *fp;\r\nint retval;\r\nunsigned long long counter;\r\nfp = fopen_or_die(path, "r");\r\nretval = fscanf(fp, "%lld", &counter);\r\nif (retval != 1)\r\nerr(1, "snapshot_sysfs_counter(%s)", path);\r\nfclose(fp);\r\nreturn counter;\r\n}\r\nint get_mp(int cpu, struct msr_counter *mp, unsigned long long *counterp)\r\n{\r\nif (mp->msr_num != 0) {\r\nif (get_msr(cpu, mp->msr_num, counterp))\r\nreturn -1;\r\n} else {\r\nchar path[128];\r\nif (mp->flags & SYSFS_PERCPU) {\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/%s",\r\ncpu, mp->path);\r\n*counterp = snapshot_sysfs_counter(path);\r\n} else {\r\n*counterp = snapshot_sysfs_counter(mp->path);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint get_counters(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nint cpu = t->cpu_id;\r\nunsigned long long msr;\r\nint aperf_mperf_retry_count = 0;\r\nstruct msr_counter *mp;\r\nint i;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nretry:\r\nt->tsc = rdtsc();\r\nif (DO_BIC(BIC_Avg_MHz) || DO_BIC(BIC_Busy) || DO_BIC(BIC_Bzy_MHz)) {\r\nunsigned long long tsc_before, tsc_between, tsc_after, aperf_time, mperf_time;\r\nif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\r\nreturn -3;\r\nt->tsc = rdtsc();\r\ntsc_before = t->tsc;\r\nif (get_msr(cpu, MSR_IA32_APERF, &t->aperf))\r\nreturn -3;\r\ntsc_between = rdtsc();\r\nif (get_msr(cpu, MSR_IA32_MPERF, &t->mperf))\r\nreturn -4;\r\ntsc_after = rdtsc();\r\naperf_time = tsc_between - tsc_before;\r\nmperf_time = tsc_after - tsc_between;\r\nif ((aperf_time > (2 * mperf_time)) || (mperf_time > (2 * aperf_time))) {\r\naperf_mperf_retry_count++;\r\nif (aperf_mperf_retry_count < 5)\r\ngoto retry;\r\nelse\r\nwarnx("cpu%d jitter %lld %lld",\r\ncpu, aperf_time, mperf_time);\r\n}\r\naperf_mperf_retry_count = 0;\r\nt->aperf = t->aperf * aperf_mperf_multiplier;\r\nt->mperf = t->mperf * aperf_mperf_multiplier;\r\n}\r\nif (DO_BIC(BIC_IRQ))\r\nt->irq_count = irqs_per_cpu[cpu];\r\nif (DO_BIC(BIC_SMI)) {\r\nif (get_msr(cpu, MSR_SMI_COUNT, &msr))\r\nreturn -5;\r\nt->smi_count = msr & 0xFFFFFFFF;\r\n}\r\nif (DO_BIC(BIC_CPU_c1) && use_c1_residency_msr) {\r\nif (get_msr(cpu, MSR_CORE_C1_RES, &t->c1))\r\nreturn -6;\r\n}\r\nfor (i = 0, mp = sys.tp; mp; i++, mp = mp->next) {\r\nif (get_mp(cpu, mp, &t->counter[i]))\r\nreturn -10;\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\nif (DO_BIC(BIC_CPU_c3) && !do_slm_cstates && !do_knl_cstates) {\r\nif (get_msr(cpu, MSR_CORE_C3_RESIDENCY, &c->c3))\r\nreturn -6;\r\n}\r\nif (DO_BIC(BIC_CPU_c6) && !do_knl_cstates) {\r\nif (get_msr(cpu, MSR_CORE_C6_RESIDENCY, &c->c6))\r\nreturn -7;\r\n} else if (do_knl_cstates) {\r\nif (get_msr(cpu, MSR_KNL_CORE_C6_RESIDENCY, &c->c6))\r\nreturn -7;\r\n}\r\nif (DO_BIC(BIC_CPU_c7))\r\nif (get_msr(cpu, MSR_CORE_C7_RESIDENCY, &c->c7))\r\nreturn -8;\r\nif (DO_BIC(BIC_Mod_c6))\r\nif (get_msr(cpu, MSR_MODULE_C6_RES_MS, &c->mc6_us))\r\nreturn -8;\r\nif (DO_BIC(BIC_CoreTmp)) {\r\nif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\r\nreturn -9;\r\nc->core_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\r\n}\r\nfor (i = 0, mp = sys.cp; mp; i++, mp = mp->next) {\r\nif (get_mp(cpu, mp, &c->counter[i]))\r\nreturn -10;\r\n}\r\nif (!(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (do_skl_residency) {\r\nif (get_msr(cpu, MSR_PKG_WEIGHTED_CORE_C0_RES, &p->pkg_wtd_core_c0))\r\nreturn -10;\r\nif (get_msr(cpu, MSR_PKG_ANY_CORE_C0_RES, &p->pkg_any_core_c0))\r\nreturn -11;\r\nif (get_msr(cpu, MSR_PKG_ANY_GFXE_C0_RES, &p->pkg_any_gfxe_c0))\r\nreturn -12;\r\nif (get_msr(cpu, MSR_PKG_BOTH_CORE_GFXE_C0_RES, &p->pkg_both_core_gfxe_c0))\r\nreturn -13;\r\n}\r\nif (DO_BIC(BIC_Pkgpc3))\r\nif (get_msr(cpu, MSR_PKG_C3_RESIDENCY, &p->pc3))\r\nreturn -9;\r\nif (DO_BIC(BIC_Pkgpc6)) {\r\nif (do_slm_cstates) {\r\nif (get_msr(cpu, MSR_ATOM_PKG_C6_RESIDENCY, &p->pc6))\r\nreturn -10;\r\n} else {\r\nif (get_msr(cpu, MSR_PKG_C6_RESIDENCY, &p->pc6))\r\nreturn -10;\r\n}\r\n}\r\nif (DO_BIC(BIC_Pkgpc2))\r\nif (get_msr(cpu, MSR_PKG_C2_RESIDENCY, &p->pc2))\r\nreturn -11;\r\nif (DO_BIC(BIC_Pkgpc7))\r\nif (get_msr(cpu, MSR_PKG_C7_RESIDENCY, &p->pc7))\r\nreturn -12;\r\nif (DO_BIC(BIC_Pkgpc8))\r\nif (get_msr(cpu, MSR_PKG_C8_RESIDENCY, &p->pc8))\r\nreturn -13;\r\nif (DO_BIC(BIC_Pkgpc9))\r\nif (get_msr(cpu, MSR_PKG_C9_RESIDENCY, &p->pc9))\r\nreturn -13;\r\nif (DO_BIC(BIC_Pkgpc10))\r\nif (get_msr(cpu, MSR_PKG_C10_RESIDENCY, &p->pc10))\r\nreturn -13;\r\nif (do_rapl & RAPL_PKG) {\r\nif (get_msr(cpu, MSR_PKG_ENERGY_STATUS, &msr))\r\nreturn -13;\r\np->energy_pkg = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_CORES_ENERGY_STATUS) {\r\nif (get_msr(cpu, MSR_PP0_ENERGY_STATUS, &msr))\r\nreturn -14;\r\np->energy_cores = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_DRAM) {\r\nif (get_msr(cpu, MSR_DRAM_ENERGY_STATUS, &msr))\r\nreturn -15;\r\np->energy_dram = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_GFX) {\r\nif (get_msr(cpu, MSR_PP1_ENERGY_STATUS, &msr))\r\nreturn -16;\r\np->energy_gfx = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_PKG_PERF_STATUS) {\r\nif (get_msr(cpu, MSR_PKG_PERF_STATUS, &msr))\r\nreturn -16;\r\np->rapl_pkg_perf_status = msr & 0xFFFFFFFF;\r\n}\r\nif (do_rapl & RAPL_DRAM_PERF_STATUS) {\r\nif (get_msr(cpu, MSR_DRAM_PERF_STATUS, &msr))\r\nreturn -16;\r\np->rapl_dram_perf_status = msr & 0xFFFFFFFF;\r\n}\r\nif (DO_BIC(BIC_PkgTmp)) {\r\nif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\r\nreturn -17;\r\np->pkg_temp_c = tcc_activation_temp - ((msr >> 16) & 0x7F);\r\n}\r\nif (DO_BIC(BIC_GFX_rc6))\r\np->gfx_rc6_ms = gfx_cur_rc6_ms;\r\nif (DO_BIC(BIC_GFXMHz))\r\np->gfx_mhz = gfx_cur_mhz;\r\nfor (i = 0, mp = sys.pp; mp; i++, mp = mp->next) {\r\nif (get_mp(cpu, mp, &p->counter[i]))\r\nreturn -10;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ncalculate_tsc_tweak()\r\n{\r\ntsc_tweak = base_hz / tsc_hz;\r\n}\r\nstatic void\r\ndump_nhm_platform_info(void)\r\n{\r\nunsigned long long msr;\r\nunsigned int ratio;\r\nget_msr(base_cpu, MSR_PLATFORM_INFO, &msr);\r\nfprintf(outf, "cpu%d: MSR_PLATFORM_INFO: 0x%08llx\n", base_cpu, msr);\r\nratio = (msr >> 40) & 0xFF;\r\nfprintf(outf, "%d * %.1f = %.1f MHz max efficiency frequency\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0xFF;\r\nfprintf(outf, "%d * %.1f = %.1f MHz base frequency\n",\r\nratio, bclk, ratio * bclk);\r\nget_msr(base_cpu, MSR_IA32_POWER_CTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_IA32_POWER_CTL: 0x%08llx (C1E auto-promotion: %sabled)\n",\r\nbase_cpu, msr, msr & 0x2 ? "EN" : "DIS");\r\nreturn;\r\n}\r\nstatic void\r\ndump_hsw_turbo_ratio_limits(void)\r\n{\r\nunsigned long long msr;\r\nunsigned int ratio;\r\nget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT2, &msr);\r\nfprintf(outf, "cpu%d: MSR_TURBO_RATIO_LIMIT2: 0x%08llx\n", base_cpu, msr);\r\nratio = (msr >> 8) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 18 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 0) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 17 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nreturn;\r\n}\r\nstatic void\r\ndump_ivt_turbo_ratio_limits(void)\r\n{\r\nunsigned long long msr;\r\nunsigned int ratio;\r\nget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT1, &msr);\r\nfprintf(outf, "cpu%d: MSR_TURBO_RATIO_LIMIT1: 0x%08llx\n", base_cpu, msr);\r\nratio = (msr >> 56) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 16 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 48) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 15 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 40) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 14 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 32) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 13 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 24) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 12 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 16) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 11 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 10 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 0) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 9 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nreturn;\r\n}\r\nint has_turbo_ratio_group_limits(int family, int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_SKYLAKE_X:\r\ncase INTEL_FAM6_ATOM_DENVERTON:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ndump_turbo_ratio_limits(int family, int model)\r\n{\r\nunsigned long long msr, core_counts;\r\nunsigned int ratio, group_size;\r\nget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT, &msr);\r\nfprintf(outf, "cpu%d: MSR_TURBO_RATIO_LIMIT: 0x%08llx\n", base_cpu, msr);\r\nif (has_turbo_ratio_group_limits(family, model)) {\r\nget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT1, &core_counts);\r\nfprintf(outf, "cpu%d: MSR_TURBO_RATIO_LIMIT1: 0x%08llx\n", base_cpu, core_counts);\r\n} else {\r\ncore_counts = 0x0807060504030201;\r\n}\r\nratio = (msr >> 56) & 0xFF;\r\ngroup_size = (core_counts >> 56) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 48) & 0xFF;\r\ngroup_size = (core_counts >> 48) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 40) & 0xFF;\r\ngroup_size = (core_counts >> 40) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 32) & 0xFF;\r\ngroup_size = (core_counts >> 32) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 24) & 0xFF;\r\ngroup_size = (core_counts >> 24) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 16) & 0xFF;\r\ngroup_size = (core_counts >> 16) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 8) & 0xFF;\r\ngroup_size = (core_counts >> 8) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nratio = (msr >> 0) & 0xFF;\r\ngroup_size = (core_counts >> 0) & 0xFF;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio, bclk, ratio * bclk, group_size);\r\nreturn;\r\n}\r\nstatic void\r\ndump_atom_turbo_ratio_limits(void)\r\n{\r\nunsigned long long msr;\r\nunsigned int ratio;\r\nget_msr(base_cpu, MSR_ATOM_CORE_RATIOS, &msr);\r\nfprintf(outf, "cpu%d: MSR_ATOM_CORE_RATIOS: 0x%08llx\n", base_cpu, msr & 0xFFFFFFFF);\r\nratio = (msr >> 0) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz minimum operating frequency\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz low frequency mode (LFM)\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 16) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz base frequency\n",\r\nratio, bclk, ratio * bclk);\r\nget_msr(base_cpu, MSR_ATOM_CORE_TURBO_RATIOS, &msr);\r\nfprintf(outf, "cpu%d: MSR_ATOM_CORE_TURBO_RATIOS: 0x%08llx\n", base_cpu, msr & 0xFFFFFFFF);\r\nratio = (msr >> 24) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 4 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 16) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 3 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 8) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 2 active cores\n",\r\nratio, bclk, ratio * bclk);\r\nratio = (msr >> 0) & 0x3F;\r\nif (ratio)\r\nfprintf(outf, "%d * %.1f = %.1f MHz max turbo 1 active core\n",\r\nratio, bclk, ratio * bclk);\r\n}\r\nstatic void\r\ndump_knl_turbo_ratio_limits(void)\r\n{\r\nconst unsigned int buckets_no = 7;\r\nunsigned long long msr;\r\nint delta_cores, delta_ratio;\r\nint i, b_nr;\r\nunsigned int cores[buckets_no];\r\nunsigned int ratio[buckets_no];\r\nget_msr(base_cpu, MSR_TURBO_RATIO_LIMIT, &msr);\r\nfprintf(outf, "cpu%d: MSR_TURBO_RATIO_LIMIT: 0x%08llx\n",\r\nbase_cpu, msr);\r\nb_nr = 0;\r\ncores[b_nr] = (msr & 0xFF) >> 1;\r\nratio[b_nr] = (msr >> 8) & 0xFF;\r\nfor (i = 16; i < 64; i += 8) {\r\ndelta_cores = (msr >> i) & 0x1F;\r\ndelta_ratio = (msr >> (i + 5)) & 0x7;\r\ncores[b_nr + 1] = cores[b_nr] + delta_cores;\r\nratio[b_nr + 1] = ratio[b_nr] - delta_ratio;\r\nb_nr++;\r\n}\r\nfor (i = buckets_no - 1; i >= 0; i--)\r\nif (i > 0 ? ratio[i] != ratio[i - 1] : 1)\r\nfprintf(outf,\r\n"%d * %.1f = %.1f MHz max turbo %d active cores\n",\r\nratio[i], bclk, ratio[i] * bclk, cores[i]);\r\n}\r\nstatic void\r\ndump_nhm_cst_cfg(void)\r\n{\r\nunsigned long long msr;\r\nget_msr(base_cpu, MSR_PKG_CST_CONFIG_CONTROL, &msr);\r\n#define SNB_C1_AUTO_UNDEMOTE (1UL << 27)\r\n#define SNB_C3_AUTO_UNDEMOTE (1UL << 28)\r\nfprintf(outf, "cpu%d: MSR_PKG_CST_CONFIG_CONTROL: 0x%08llx", base_cpu, msr);\r\nfprintf(outf, " (%s%s%s%s%slocked: pkg-cstate-limit=%d: %s)\n",\r\n(msr & SNB_C3_AUTO_UNDEMOTE) ? "UNdemote-C3, " : "",\r\n(msr & SNB_C1_AUTO_UNDEMOTE) ? "UNdemote-C1, " : "",\r\n(msr & NHM_C3_AUTO_DEMOTE) ? "demote-C3, " : "",\r\n(msr & NHM_C1_AUTO_DEMOTE) ? "demote-C1, " : "",\r\n(msr & (1 << 15)) ? "" : "UN",\r\n(unsigned int)msr & 0xF,\r\npkg_cstate_limit_strings[pkg_cstate_limit]);\r\nreturn;\r\n}\r\nstatic void\r\ndump_config_tdp(void)\r\n{\r\nunsigned long long msr;\r\nget_msr(base_cpu, MSR_CONFIG_TDP_NOMINAL, &msr);\r\nfprintf(outf, "cpu%d: MSR_CONFIG_TDP_NOMINAL: 0x%08llx", base_cpu, msr);\r\nfprintf(outf, " (base_ratio=%d)\n", (unsigned int)msr & 0xFF);\r\nget_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_1, &msr);\r\nfprintf(outf, "cpu%d: MSR_CONFIG_TDP_LEVEL_1: 0x%08llx (", base_cpu, msr);\r\nif (msr) {\r\nfprintf(outf, "PKG_MIN_PWR_LVL1=%d ", (unsigned int)(msr >> 48) & 0x7FFF);\r\nfprintf(outf, "PKG_MAX_PWR_LVL1=%d ", (unsigned int)(msr >> 32) & 0x7FFF);\r\nfprintf(outf, "LVL1_RATIO=%d ", (unsigned int)(msr >> 16) & 0xFF);\r\nfprintf(outf, "PKG_TDP_LVL1=%d", (unsigned int)(msr) & 0x7FFF);\r\n}\r\nfprintf(outf, ")\n");\r\nget_msr(base_cpu, MSR_CONFIG_TDP_LEVEL_2, &msr);\r\nfprintf(outf, "cpu%d: MSR_CONFIG_TDP_LEVEL_2: 0x%08llx (", base_cpu, msr);\r\nif (msr) {\r\nfprintf(outf, "PKG_MIN_PWR_LVL2=%d ", (unsigned int)(msr >> 48) & 0x7FFF);\r\nfprintf(outf, "PKG_MAX_PWR_LVL2=%d ", (unsigned int)(msr >> 32) & 0x7FFF);\r\nfprintf(outf, "LVL2_RATIO=%d ", (unsigned int)(msr >> 16) & 0xFF);\r\nfprintf(outf, "PKG_TDP_LVL2=%d", (unsigned int)(msr) & 0x7FFF);\r\n}\r\nfprintf(outf, ")\n");\r\nget_msr(base_cpu, MSR_CONFIG_TDP_CONTROL, &msr);\r\nfprintf(outf, "cpu%d: MSR_CONFIG_TDP_CONTROL: 0x%08llx (", base_cpu, msr);\r\nif ((msr) & 0x3)\r\nfprintf(outf, "TDP_LEVEL=%d ", (unsigned int)(msr) & 0x3);\r\nfprintf(outf, " lock=%d", (unsigned int)(msr >> 31) & 1);\r\nfprintf(outf, ")\n");\r\nget_msr(base_cpu, MSR_TURBO_ACTIVATION_RATIO, &msr);\r\nfprintf(outf, "cpu%d: MSR_TURBO_ACTIVATION_RATIO: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "MAX_NON_TURBO_RATIO=%d", (unsigned int)(msr) & 0xFF);\r\nfprintf(outf, " lock=%d", (unsigned int)(msr >> 31) & 1);\r\nfprintf(outf, ")\n");\r\n}\r\nvoid print_irtl(void)\r\n{\r\nunsigned long long msr;\r\nget_msr(base_cpu, MSR_PKGC3_IRTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_PKGC3_IRTL: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",\r\n(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\r\nget_msr(base_cpu, MSR_PKGC6_IRTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_PKGC6_IRTL: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",\r\n(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\r\nget_msr(base_cpu, MSR_PKGC7_IRTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_PKGC7_IRTL: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",\r\n(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\r\nif (!do_irtl_hsw)\r\nreturn;\r\nget_msr(base_cpu, MSR_PKGC8_IRTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_PKGC8_IRTL: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",\r\n(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\r\nget_msr(base_cpu, MSR_PKGC9_IRTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_PKGC9_IRTL: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",\r\n(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\r\nget_msr(base_cpu, MSR_PKGC10_IRTL, &msr);\r\nfprintf(outf, "cpu%d: MSR_PKGC10_IRTL: 0x%08llx (", base_cpu, msr);\r\nfprintf(outf, "%svalid, %lld ns)\n", msr & (1 << 15) ? "" : "NOT",\r\n(msr & 0x3FF) * irtl_time_units[(msr >> 10) & 0x3]);\r\n}\r\nvoid free_fd_percpu(void)\r\n{\r\nint i;\r\nfor (i = 0; i < topo.max_cpu_num + 1; ++i) {\r\nif (fd_percpu[i] != 0)\r\nclose(fd_percpu[i]);\r\n}\r\nfree(fd_percpu);\r\n}\r\nvoid free_all_buffers(void)\r\n{\r\nCPU_FREE(cpu_present_set);\r\ncpu_present_set = NULL;\r\ncpu_present_setsize = 0;\r\nCPU_FREE(cpu_affinity_set);\r\ncpu_affinity_set = NULL;\r\ncpu_affinity_setsize = 0;\r\nfree(thread_even);\r\nfree(core_even);\r\nfree(package_even);\r\nthread_even = NULL;\r\ncore_even = NULL;\r\npackage_even = NULL;\r\nfree(thread_odd);\r\nfree(core_odd);\r\nfree(package_odd);\r\nthread_odd = NULL;\r\ncore_odd = NULL;\r\npackage_odd = NULL;\r\nfree(output_buffer);\r\noutput_buffer = NULL;\r\noutp = NULL;\r\nfree_fd_percpu();\r\nfree(irq_column_2_cpu);\r\nfree(irqs_per_cpu);\r\n}\r\nint parse_int_file(const char *fmt, ...)\r\n{\r\nva_list args;\r\nchar path[PATH_MAX];\r\nFILE *filep;\r\nint value;\r\nva_start(args, fmt);\r\nvsnprintf(path, sizeof(path), fmt, args);\r\nva_end(args);\r\nfilep = fopen_or_die(path, "r");\r\nif (fscanf(filep, "%d", &value) != 1)\r\nerr(1, "%s: failed to parse number from file", path);\r\nfclose(filep);\r\nreturn value;\r\n}\r\nint get_cpu_position_in_core(int cpu)\r\n{\r\nchar path[64];\r\nFILE *filep;\r\nint this_cpu;\r\nchar character;\r\nint i;\r\nsprintf(path,\r\n"/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list",\r\ncpu);\r\nfilep = fopen(path, "r");\r\nif (filep == NULL) {\r\nperror(path);\r\nexit(1);\r\n}\r\nfor (i = 0; i < topo.num_threads_per_core; i++) {\r\nfscanf(filep, "%d", &this_cpu);\r\nif (this_cpu == cpu) {\r\nfclose(filep);\r\nreturn i;\r\n}\r\nif (i != (topo.num_threads_per_core - 1))\r\nfscanf(filep, "%c", &character);\r\n}\r\nfclose(filep);\r\nreturn -1;\r\n}\r\nint cpu_is_first_core_in_package(int cpu)\r\n{\r\nreturn cpu == parse_int_file("/sys/devices/system/cpu/cpu%d/topology/core_siblings_list", cpu);\r\n}\r\nint get_physical_package_id(int cpu)\r\n{\r\nreturn parse_int_file("/sys/devices/system/cpu/cpu%d/topology/physical_package_id", cpu);\r\n}\r\nint get_core_id(int cpu)\r\n{\r\nreturn parse_int_file("/sys/devices/system/cpu/cpu%d/topology/core_id", cpu);\r\n}\r\nint get_num_ht_siblings(int cpu)\r\n{\r\nchar path[80];\r\nFILE *filep;\r\nint sib1;\r\nint matches = 0;\r\nchar character;\r\nchar str[100];\r\nchar *ch;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/topology/thread_siblings_list", cpu);\r\nfilep = fopen_or_die(path, "r");\r\nfscanf(filep, "%d%c\n", &sib1, &character);\r\nfseek(filep, 0, SEEK_SET);\r\nfgets(str, 100, filep);\r\nch = strchr(str, character);\r\nwhile (ch != NULL) {\r\nmatches++;\r\nch = strchr(ch+1, character);\r\n}\r\nfclose(filep);\r\nreturn matches+1;\r\n}\r\nint for_all_cpus_2(int (func)(struct thread_data *, struct core_data *,\r\nstruct pkg_data *, struct thread_data *, struct core_data *,\r\nstruct pkg_data *), struct thread_data *thread_base,\r\nstruct core_data *core_base, struct pkg_data *pkg_base,\r\nstruct thread_data *thread_base2, struct core_data *core_base2,\r\nstruct pkg_data *pkg_base2)\r\n{\r\nint retval, pkg_no, core_no, thread_no;\r\nfor (pkg_no = 0; pkg_no < topo.num_packages; ++pkg_no) {\r\nfor (core_no = 0; core_no < topo.num_cores_per_pkg; ++core_no) {\r\nfor (thread_no = 0; thread_no <\r\ntopo.num_threads_per_core; ++thread_no) {\r\nstruct thread_data *t, *t2;\r\nstruct core_data *c, *c2;\r\nstruct pkg_data *p, *p2;\r\nt = GET_THREAD(thread_base, thread_no, core_no, pkg_no);\r\nif (cpu_is_not_present(t->cpu_id))\r\ncontinue;\r\nt2 = GET_THREAD(thread_base2, thread_no, core_no, pkg_no);\r\nc = GET_CORE(core_base, core_no, pkg_no);\r\nc2 = GET_CORE(core_base2, core_no, pkg_no);\r\np = GET_PKG(pkg_base, pkg_no);\r\np2 = GET_PKG(pkg_base2, pkg_no);\r\nretval = func(t, c, p, t2, c2, p2);\r\nif (retval)\r\nreturn retval;\r\n}\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint for_all_proc_cpus(int (func)(int))\r\n{\r\nFILE *fp;\r\nint cpu_num;\r\nint retval;\r\nfp = fopen_or_die(proc_stat, "r");\r\nretval = fscanf(fp, "cpu %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\n");\r\nif (retval != 0)\r\nerr(1, "%s: failed to parse format", proc_stat);\r\nwhile (1) {\r\nretval = fscanf(fp, "cpu%u %*d %*d %*d %*d %*d %*d %*d %*d %*d %*d\n", &cpu_num);\r\nif (retval != 1)\r\nbreak;\r\nretval = func(cpu_num);\r\nif (retval) {\r\nfclose(fp);\r\nreturn(retval);\r\n}\r\n}\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nvoid re_initialize(void)\r\n{\r\nfree_all_buffers();\r\nsetup_all_buffers();\r\nprintf("turbostat: re-initialized with num_cpus %d\n", topo.num_cpus);\r\n}\r\nint count_cpus(int cpu)\r\n{\r\nif (topo.max_cpu_num < cpu)\r\ntopo.max_cpu_num = cpu;\r\ntopo.num_cpus += 1;\r\nreturn 0;\r\n}\r\nint mark_cpu_present(int cpu)\r\n{\r\nCPU_SET_S(cpu, cpu_present_setsize, cpu_present_set);\r\nreturn 0;\r\n}\r\nint snapshot_proc_interrupts(void)\r\n{\r\nstatic FILE *fp;\r\nint column, retval;\r\nif (fp == NULL)\r\nfp = fopen_or_die("/proc/interrupts", "r");\r\nelse\r\nrewind(fp);\r\nfor (column = 0; column < topo.num_cpus; ++column) {\r\nint cpu_number;\r\nretval = fscanf(fp, " CPU%d", &cpu_number);\r\nif (retval != 1)\r\nbreak;\r\nif (cpu_number > topo.max_cpu_num) {\r\nwarn("/proc/interrupts: cpu%d: > %d", cpu_number, topo.max_cpu_num);\r\nreturn 1;\r\n}\r\nirq_column_2_cpu[column] = cpu_number;\r\nirqs_per_cpu[cpu_number] = 0;\r\n}\r\nwhile (1) {\r\nint column;\r\nchar buf[64];\r\nretval = fscanf(fp, " %s:", buf);\r\nif (retval != 1)\r\nbreak;\r\nfor (column = 0; column < topo.num_cpus; ++column) {\r\nint cpu_number, irq_count;\r\nretval = fscanf(fp, " %d", &irq_count);\r\nif (retval != 1)\r\nbreak;\r\ncpu_number = irq_column_2_cpu[column];\r\nirqs_per_cpu[cpu_number] += irq_count;\r\n}\r\nwhile (getc(fp) != '\n')\r\n;\r\n}\r\nreturn 0;\r\n}\r\nint snapshot_gfx_rc6_ms(void)\r\n{\r\nFILE *fp;\r\nint retval;\r\nfp = fopen_or_die("/sys/class/drm/card0/power/rc6_residency_ms", "r");\r\nretval = fscanf(fp, "%lld", &gfx_cur_rc6_ms);\r\nif (retval != 1)\r\nerr(1, "GFX rc6");\r\nfclose(fp);\r\nreturn 0;\r\n}\r\nint snapshot_gfx_mhz(void)\r\n{\r\nstatic FILE *fp;\r\nint retval;\r\nif (fp == NULL)\r\nfp = fopen_or_die("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", "r");\r\nelse {\r\nrewind(fp);\r\nfflush(fp);\r\n}\r\nretval = fscanf(fp, "%d", &gfx_cur_mhz);\r\nif (retval != 1)\r\nerr(1, "GFX MHz");\r\nreturn 0;\r\n}\r\nint snapshot_proc_sysfs_files(void)\r\n{\r\nif (DO_BIC(BIC_IRQ))\r\nif (snapshot_proc_interrupts())\r\nreturn 1;\r\nif (DO_BIC(BIC_GFX_rc6))\r\nsnapshot_gfx_rc6_ms();\r\nif (DO_BIC(BIC_GFXMHz))\r\nsnapshot_gfx_mhz();\r\nreturn 0;\r\n}\r\nvoid turbostat_loop()\r\n{\r\nint retval;\r\nint restarted = 0;\r\nrestart:\r\nrestarted++;\r\nsnapshot_proc_sysfs_files();\r\nretval = for_all_cpus(get_counters, EVEN_COUNTERS);\r\nif (retval < -1) {\r\nexit(retval);\r\n} else if (retval == -1) {\r\nif (restarted > 1) {\r\nexit(retval);\r\n}\r\nre_initialize();\r\ngoto restart;\r\n}\r\nrestarted = 0;\r\ngettimeofday(&tv_even, (struct timezone *)NULL);\r\nwhile (1) {\r\nif (for_all_proc_cpus(cpu_is_not_present)) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\nnanosleep(&interval_ts, NULL);\r\nif (snapshot_proc_sysfs_files())\r\ngoto restart;\r\nretval = for_all_cpus(get_counters, ODD_COUNTERS);\r\nif (retval < -1) {\r\nexit(retval);\r\n} else if (retval == -1) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\ngettimeofday(&tv_odd, (struct timezone *)NULL);\r\ntimersub(&tv_odd, &tv_even, &tv_delta);\r\nif (for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS)) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\ncompute_average(EVEN_COUNTERS);\r\nformat_all_counters(EVEN_COUNTERS);\r\nflush_output_stdout();\r\nnanosleep(&interval_ts, NULL);\r\nif (snapshot_proc_sysfs_files())\r\ngoto restart;\r\nretval = for_all_cpus(get_counters, EVEN_COUNTERS);\r\nif (retval < -1) {\r\nexit(retval);\r\n} else if (retval == -1) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\ngettimeofday(&tv_even, (struct timezone *)NULL);\r\ntimersub(&tv_even, &tv_odd, &tv_delta);\r\nif (for_all_cpus_2(delta_cpu, EVEN_COUNTERS, ODD_COUNTERS)) {\r\nre_initialize();\r\ngoto restart;\r\n}\r\ncompute_average(ODD_COUNTERS);\r\nformat_all_counters(ODD_COUNTERS);\r\nflush_output_stdout();\r\n}\r\n}\r\nvoid check_dev_msr()\r\n{\r\nstruct stat sb;\r\nchar pathname[32];\r\nsprintf(pathname, "/dev/cpu/%d/msr", base_cpu);\r\nif (stat(pathname, &sb))\r\nif (system("/sbin/modprobe msr > /dev/null 2>&1"))\r\nerr(-5, "no /dev/cpu/0/msr, Try \"# modprobe msr\" ");\r\n}\r\nvoid check_permissions()\r\n{\r\nstruct __user_cap_header_struct cap_header_data;\r\ncap_user_header_t cap_header = &cap_header_data;\r\nstruct __user_cap_data_struct cap_data_data;\r\ncap_user_data_t cap_data = &cap_data_data;\r\nextern int capget(cap_user_header_t hdrp, cap_user_data_t datap);\r\nint do_exit = 0;\r\nchar pathname[32];\r\ncap_header->pid = getpid();\r\ncap_header->version = _LINUX_CAPABILITY_VERSION;\r\nif (capget(cap_header, cap_data) < 0)\r\nerr(-6, "capget(2) failed");\r\nif ((cap_data->effective & (1 << CAP_SYS_RAWIO)) == 0) {\r\ndo_exit++;\r\nwarnx("capget(CAP_SYS_RAWIO) failed,"\r\n" try \"# setcap cap_sys_rawio=ep %s\"", progname);\r\n}\r\nsprintf(pathname, "/dev/cpu/%d/msr", base_cpu);\r\nif (euidaccess(pathname, R_OK)) {\r\ndo_exit++;\r\nwarn("/dev/cpu/0/msr open failed, try chown or chmod +r /dev/cpu/*/msr");\r\n}\r\nif (do_exit)\r\nif (getuid() != 0)\r\nwarnx("... or simply run as root");\r\nif (do_exit)\r\nexit(-6);\r\n}\r\nint probe_nhm_msrs(unsigned int family, unsigned int model)\r\n{\r\nunsigned long long msr;\r\nunsigned int base_ratio;\r\nint *pkg_cstate_limits;\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nbclk = discover_bclk(family, model);\r\nswitch (model) {\r\ncase INTEL_FAM6_NEHALEM_EP:\r\ncase INTEL_FAM6_NEHALEM:\r\ncase 0x1F:\r\ncase INTEL_FAM6_WESTMERE:\r\ncase INTEL_FAM6_WESTMERE_EP:\r\ncase INTEL_FAM6_NEHALEM_EX:\r\ncase INTEL_FAM6_WESTMERE_EX:\r\npkg_cstate_limits = nhm_pkg_cstate_limits;\r\nbreak;\r\ncase INTEL_FAM6_SANDYBRIDGE:\r\ncase INTEL_FAM6_SANDYBRIDGE_X:\r\ncase INTEL_FAM6_IVYBRIDGE:\r\ncase INTEL_FAM6_IVYBRIDGE_X:\r\npkg_cstate_limits = snb_pkg_cstate_limits;\r\nhas_misc_feature_control = 1;\r\nbreak;\r\ncase INTEL_FAM6_HASWELL_CORE:\r\ncase INTEL_FAM6_HASWELL_X:\r\ncase INTEL_FAM6_HASWELL_ULT:\r\ncase INTEL_FAM6_HASWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_CORE:\r\ncase INTEL_FAM6_BROADWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_X:\r\ncase INTEL_FAM6_BROADWELL_XEON_D:\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\npkg_cstate_limits = hsw_pkg_cstate_limits;\r\nhas_misc_feature_control = 1;\r\nbreak;\r\ncase INTEL_FAM6_SKYLAKE_X:\r\npkg_cstate_limits = skx_pkg_cstate_limits;\r\nhas_misc_feature_control = 1;\r\nbreak;\r\ncase INTEL_FAM6_ATOM_SILVERMONT1:\r\nno_MSR_MISC_PWR_MGMT = 1;\r\ncase INTEL_FAM6_ATOM_SILVERMONT2:\r\npkg_cstate_limits = slv_pkg_cstate_limits;\r\nbreak;\r\ncase INTEL_FAM6_ATOM_AIRMONT:\r\npkg_cstate_limits = amt_pkg_cstate_limits;\r\nno_MSR_MISC_PWR_MGMT = 1;\r\nbreak;\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\npkg_cstate_limits = phi_pkg_cstate_limits;\r\nbreak;\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_ATOM_GEMINI_LAKE:\r\ncase INTEL_FAM6_ATOM_DENVERTON:\r\npkg_cstate_limits = bxt_pkg_cstate_limits;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nget_msr(base_cpu, MSR_PKG_CST_CONFIG_CONTROL, &msr);\r\npkg_cstate_limit = pkg_cstate_limits[msr & 0xF];\r\nget_msr(base_cpu, MSR_PLATFORM_INFO, &msr);\r\nbase_ratio = (msr >> 8) & 0xFF;\r\nbase_hz = base_ratio * bclk * 1000000;\r\nhas_base_hz = 1;\r\nreturn 1;\r\n}\r\nint has_slv_msrs(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_ATOM_SILVERMONT1:\r\ncase INTEL_FAM6_ATOM_MERRIFIELD:\r\ncase INTEL_FAM6_ATOM_MOOREFIELD:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint is_dnv(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_ATOM_DENVERTON:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint is_bdx(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_BROADWELL_X:\r\ncase INTEL_FAM6_BROADWELL_XEON_D:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint is_skx(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_SKYLAKE_X:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint has_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (has_slv_msrs(family, model))\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_NEHALEM_EX:\r\ncase INTEL_FAM6_WESTMERE_EX:\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\nreturn 0;\r\ndefault:\r\nreturn 1;\r\n}\r\n}\r\nint has_atom_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (has_slv_msrs(family, model))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nint has_ivt_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_IVYBRIDGE_X:\r\ncase INTEL_FAM6_HASWELL_X:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint has_hsw_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_HASWELL_X:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint has_knl_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint has_glm_turbo_ratio_limit(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_SKYLAKE_X:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint has_config_tdp(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nif (family != 6)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_IVYBRIDGE:\r\ncase INTEL_FAM6_HASWELL_CORE:\r\ncase INTEL_FAM6_HASWELL_X:\r\ncase INTEL_FAM6_HASWELL_ULT:\r\ncase INTEL_FAM6_HASWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_CORE:\r\ncase INTEL_FAM6_BROADWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_X:\r\ncase INTEL_FAM6_BROADWELL_XEON_D:\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\ncase INTEL_FAM6_SKYLAKE_X:\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic void\r\ndump_cstate_pstate_config_info(unsigned int family, unsigned int model)\r\n{\r\nif (!do_nhm_platform_info)\r\nreturn;\r\ndump_nhm_platform_info();\r\nif (has_hsw_turbo_ratio_limit(family, model))\r\ndump_hsw_turbo_ratio_limits();\r\nif (has_ivt_turbo_ratio_limit(family, model))\r\ndump_ivt_turbo_ratio_limits();\r\nif (has_turbo_ratio_limit(family, model))\r\ndump_turbo_ratio_limits(family, model);\r\nif (has_atom_turbo_ratio_limit(family, model))\r\ndump_atom_turbo_ratio_limits();\r\nif (has_knl_turbo_ratio_limit(family, model))\r\ndump_knl_turbo_ratio_limits();\r\nif (has_config_tdp(family, model))\r\ndump_config_tdp();\r\ndump_nhm_cst_cfg();\r\n}\r\nstatic void\r\ndump_sysfs_cstate_config(void)\r\n{\r\nchar path[64];\r\nchar name_buf[16];\r\nchar desc[64];\r\nFILE *input;\r\nint state;\r\nchar *sp;\r\nif (!DO_BIC(BIC_sysfs))\r\nreturn;\r\nfor (state = 0; state < 10; ++state) {\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/cpuidle/state%d/name",\r\nbase_cpu, state);\r\ninput = fopen(path, "r");\r\nif (input == NULL)\r\ncontinue;\r\nfgets(name_buf, sizeof(name_buf), input);\r\nsp = strchr(name_buf, '-');\r\nif (!sp)\r\nsp = strchrnul(name_buf, '\n');\r\n*sp = '\0';\r\nfclose(input);\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/cpuidle/state%d/desc",\r\nbase_cpu, state);\r\ninput = fopen(path, "r");\r\nif (input == NULL)\r\ncontinue;\r\nfgets(desc, sizeof(desc), input);\r\nfprintf(outf, "cpu%d: %s: %s", base_cpu, name_buf, desc);\r\nfclose(input);\r\n}\r\n}\r\nstatic void\r\ndump_sysfs_pstate_config(void)\r\n{\r\nchar path[64];\r\nchar driver_buf[64];\r\nchar governor_buf[64];\r\nFILE *input;\r\nint turbo;\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_driver",\r\nbase_cpu);\r\ninput = fopen(path, "r");\r\nif (input == NULL) {\r\nfprintf(stderr, "NSFOD %s\n", path);\r\nreturn;\r\n}\r\nfgets(driver_buf, sizeof(driver_buf), input);\r\nfclose(input);\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/cpufreq/scaling_governor",\r\nbase_cpu);\r\ninput = fopen(path, "r");\r\nif (input == NULL) {\r\nfprintf(stderr, "NSFOD %s\n", path);\r\nreturn;\r\n}\r\nfgets(governor_buf, sizeof(governor_buf), input);\r\nfclose(input);\r\nfprintf(outf, "cpu%d: cpufreq driver: %s", base_cpu, driver_buf);\r\nfprintf(outf, "cpu%d: cpufreq governor: %s", base_cpu, governor_buf);\r\nsprintf(path, "/sys/devices/system/cpu/cpufreq/boost");\r\ninput = fopen(path, "r");\r\nif (input != NULL) {\r\nfscanf(input, "%d", &turbo);\r\nfprintf(outf, "cpufreq boost: %d\n", turbo);\r\nfclose(input);\r\n}\r\nsprintf(path, "/sys/devices/system/cpu/intel_pstate/no_turbo");\r\ninput = fopen(path, "r");\r\nif (input != NULL) {\r\nfscanf(input, "%d", &turbo);\r\nfprintf(outf, "cpufreq intel_pstate no_turbo: %d\n", turbo);\r\nfclose(input);\r\n}\r\n}\r\nint print_epb(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nchar *epb_string;\r\nint cpu;\r\nif (!has_epb)\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (get_msr(cpu, MSR_IA32_ENERGY_PERF_BIAS, &msr))\r\nreturn 0;\r\nswitch (msr & 0xF) {\r\ncase ENERGY_PERF_BIAS_PERFORMANCE:\r\nepb_string = "performance";\r\nbreak;\r\ncase ENERGY_PERF_BIAS_NORMAL:\r\nepb_string = "balanced";\r\nbreak;\r\ncase ENERGY_PERF_BIAS_POWERSAVE:\r\nepb_string = "powersave";\r\nbreak;\r\ndefault:\r\nepb_string = "custom";\r\nbreak;\r\n}\r\nfprintf(outf, "cpu%d: MSR_IA32_ENERGY_PERF_BIAS: 0x%08llx (%s)\n", cpu, msr, epb_string);\r\nreturn 0;\r\n}\r\nint print_hwp(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nint cpu;\r\nif (!has_hwp)\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (get_msr(cpu, MSR_PM_ENABLE, &msr))\r\nreturn 0;\r\nfprintf(outf, "cpu%d: MSR_PM_ENABLE: 0x%08llx (%sHWP)\n",\r\ncpu, msr, (msr & (1 << 0)) ? "" : "No-");\r\nif ((msr & (1 << 0)) == 0)\r\nreturn 0;\r\nif (get_msr(cpu, MSR_HWP_CAPABILITIES, &msr))\r\nreturn 0;\r\nfprintf(outf, "cpu%d: MSR_HWP_CAPABILITIES: 0x%08llx "\r\n"(high %d guar %d eff %d low %d)\n",\r\ncpu, msr,\r\n(unsigned int)HWP_HIGHEST_PERF(msr),\r\n(unsigned int)HWP_GUARANTEED_PERF(msr),\r\n(unsigned int)HWP_MOSTEFFICIENT_PERF(msr),\r\n(unsigned int)HWP_LOWEST_PERF(msr));\r\nif (get_msr(cpu, MSR_HWP_REQUEST, &msr))\r\nreturn 0;\r\nfprintf(outf, "cpu%d: MSR_HWP_REQUEST: 0x%08llx "\r\n"(min %d max %d des %d epp 0x%x window 0x%x pkg 0x%x)\n",\r\ncpu, msr,\r\n(unsigned int)(((msr) >> 0) & 0xff),\r\n(unsigned int)(((msr) >> 8) & 0xff),\r\n(unsigned int)(((msr) >> 16) & 0xff),\r\n(unsigned int)(((msr) >> 24) & 0xff),\r\n(unsigned int)(((msr) >> 32) & 0xff3),\r\n(unsigned int)(((msr) >> 42) & 0x1));\r\nif (has_hwp_pkg) {\r\nif (get_msr(cpu, MSR_HWP_REQUEST_PKG, &msr))\r\nreturn 0;\r\nfprintf(outf, "cpu%d: MSR_HWP_REQUEST_PKG: 0x%08llx "\r\n"(min %d max %d des %d epp 0x%x window 0x%x)\n",\r\ncpu, msr,\r\n(unsigned int)(((msr) >> 0) & 0xff),\r\n(unsigned int)(((msr) >> 8) & 0xff),\r\n(unsigned int)(((msr) >> 16) & 0xff),\r\n(unsigned int)(((msr) >> 24) & 0xff),\r\n(unsigned int)(((msr) >> 32) & 0xff3));\r\n}\r\nif (has_hwp_notify) {\r\nif (get_msr(cpu, MSR_HWP_INTERRUPT, &msr))\r\nreturn 0;\r\nfprintf(outf, "cpu%d: MSR_HWP_INTERRUPT: 0x%08llx "\r\n"(%s_Guaranteed_Perf_Change, %s_Excursion_Min)\n",\r\ncpu, msr,\r\n((msr) & 0x1) ? "EN" : "Dis",\r\n((msr) & 0x2) ? "EN" : "Dis");\r\n}\r\nif (get_msr(cpu, MSR_HWP_STATUS, &msr))\r\nreturn 0;\r\nfprintf(outf, "cpu%d: MSR_HWP_STATUS: 0x%08llx "\r\n"(%sGuaranteed_Perf_Change, %sExcursion_Min)\n",\r\ncpu, msr,\r\n((msr) & 0x1) ? "" : "No-",\r\n((msr) & 0x2) ? "" : "No-");\r\nreturn 0;\r\n}\r\nint print_perf_limit(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nint cpu;\r\ncpu = t->cpu_id;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (do_core_perf_limit_reasons) {\r\nget_msr(cpu, MSR_CORE_PERF_LIMIT_REASONS, &msr);\r\nfprintf(outf, "cpu%d: MSR_CORE_PERF_LIMIT_REASONS, 0x%08llx", cpu, msr);\r\nfprintf(outf, " (Active: %s%s%s%s%s%s%s%s%s%s%s%s%s%s)",\r\n(msr & 1 << 15) ? "bit15, " : "",\r\n(msr & 1 << 14) ? "bit14, " : "",\r\n(msr & 1 << 13) ? "Transitions, " : "",\r\n(msr & 1 << 12) ? "MultiCoreTurbo, " : "",\r\n(msr & 1 << 11) ? "PkgPwrL2, " : "",\r\n(msr & 1 << 10) ? "PkgPwrL1, " : "",\r\n(msr & 1 << 9) ? "CorePwr, " : "",\r\n(msr & 1 << 8) ? "Amps, " : "",\r\n(msr & 1 << 6) ? "VR-Therm, " : "",\r\n(msr & 1 << 5) ? "Auto-HWP, " : "",\r\n(msr & 1 << 4) ? "Graphics, " : "",\r\n(msr & 1 << 2) ? "bit2, " : "",\r\n(msr & 1 << 1) ? "ThermStatus, " : "",\r\n(msr & 1 << 0) ? "PROCHOT, " : "");\r\nfprintf(outf, " (Logged: %s%s%s%s%s%s%s%s%s%s%s%s%s%s)\n",\r\n(msr & 1 << 31) ? "bit31, " : "",\r\n(msr & 1 << 30) ? "bit30, " : "",\r\n(msr & 1 << 29) ? "Transitions, " : "",\r\n(msr & 1 << 28) ? "MultiCoreTurbo, " : "",\r\n(msr & 1 << 27) ? "PkgPwrL2, " : "",\r\n(msr & 1 << 26) ? "PkgPwrL1, " : "",\r\n(msr & 1 << 25) ? "CorePwr, " : "",\r\n(msr & 1 << 24) ? "Amps, " : "",\r\n(msr & 1 << 22) ? "VR-Therm, " : "",\r\n(msr & 1 << 21) ? "Auto-HWP, " : "",\r\n(msr & 1 << 20) ? "Graphics, " : "",\r\n(msr & 1 << 18) ? "bit18, " : "",\r\n(msr & 1 << 17) ? "ThermStatus, " : "",\r\n(msr & 1 << 16) ? "PROCHOT, " : "");\r\n}\r\nif (do_gfx_perf_limit_reasons) {\r\nget_msr(cpu, MSR_GFX_PERF_LIMIT_REASONS, &msr);\r\nfprintf(outf, "cpu%d: MSR_GFX_PERF_LIMIT_REASONS, 0x%08llx", cpu, msr);\r\nfprintf(outf, " (Active: %s%s%s%s%s%s%s%s)",\r\n(msr & 1 << 0) ? "PROCHOT, " : "",\r\n(msr & 1 << 1) ? "ThermStatus, " : "",\r\n(msr & 1 << 4) ? "Graphics, " : "",\r\n(msr & 1 << 6) ? "VR-Therm, " : "",\r\n(msr & 1 << 8) ? "Amps, " : "",\r\n(msr & 1 << 9) ? "GFXPwr, " : "",\r\n(msr & 1 << 10) ? "PkgPwrL1, " : "",\r\n(msr & 1 << 11) ? "PkgPwrL2, " : "");\r\nfprintf(outf, " (Logged: %s%s%s%s%s%s%s%s)\n",\r\n(msr & 1 << 16) ? "PROCHOT, " : "",\r\n(msr & 1 << 17) ? "ThermStatus, " : "",\r\n(msr & 1 << 20) ? "Graphics, " : "",\r\n(msr & 1 << 22) ? "VR-Therm, " : "",\r\n(msr & 1 << 24) ? "Amps, " : "",\r\n(msr & 1 << 25) ? "GFXPwr, " : "",\r\n(msr & 1 << 26) ? "PkgPwrL1, " : "",\r\n(msr & 1 << 27) ? "PkgPwrL2, " : "");\r\n}\r\nif (do_ring_perf_limit_reasons) {\r\nget_msr(cpu, MSR_RING_PERF_LIMIT_REASONS, &msr);\r\nfprintf(outf, "cpu%d: MSR_RING_PERF_LIMIT_REASONS, 0x%08llx", cpu, msr);\r\nfprintf(outf, " (Active: %s%s%s%s%s%s)",\r\n(msr & 1 << 0) ? "PROCHOT, " : "",\r\n(msr & 1 << 1) ? "ThermStatus, " : "",\r\n(msr & 1 << 6) ? "VR-Therm, " : "",\r\n(msr & 1 << 8) ? "Amps, " : "",\r\n(msr & 1 << 10) ? "PkgPwrL1, " : "",\r\n(msr & 1 << 11) ? "PkgPwrL2, " : "");\r\nfprintf(outf, " (Logged: %s%s%s%s%s%s)\n",\r\n(msr & 1 << 16) ? "PROCHOT, " : "",\r\n(msr & 1 << 17) ? "ThermStatus, " : "",\r\n(msr & 1 << 22) ? "VR-Therm, " : "",\r\n(msr & 1 << 24) ? "Amps, " : "",\r\n(msr & 1 << 26) ? "PkgPwrL1, " : "",\r\n(msr & 1 << 27) ? "PkgPwrL2, " : "");\r\n}\r\nreturn 0;\r\n}\r\ndouble get_tdp(unsigned int model)\r\n{\r\nunsigned long long msr;\r\nif (do_rapl & RAPL_PKG_POWER_INFO)\r\nif (!get_msr(base_cpu, MSR_PKG_POWER_INFO, &msr))\r\nreturn ((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units;\r\nswitch (model) {\r\ncase INTEL_FAM6_ATOM_SILVERMONT1:\r\ncase INTEL_FAM6_ATOM_SILVERMONT2:\r\nreturn 30.0;\r\ndefault:\r\nreturn 135.0;\r\n}\r\n}\r\nstatic double\r\nrapl_dram_energy_units_probe(int model, double rapl_energy_units)\r\n{\r\nswitch (model) {\r\ncase INTEL_FAM6_HASWELL_X:\r\ncase INTEL_FAM6_BROADWELL_X:\r\ncase INTEL_FAM6_BROADWELL_XEON_D:\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\nreturn (rapl_dram_energy_units = 15.3 / 1000000);\r\ndefault:\r\nreturn (rapl_energy_units);\r\n}\r\n}\r\nvoid rapl_probe(unsigned int family, unsigned int model)\r\n{\r\nunsigned long long msr;\r\nunsigned int time_unit;\r\ndouble tdp;\r\nif (!genuine_intel)\r\nreturn;\r\nif (family != 6)\r\nreturn;\r\nswitch (model) {\r\ncase INTEL_FAM6_SANDYBRIDGE:\r\ncase INTEL_FAM6_IVYBRIDGE:\r\ncase INTEL_FAM6_HASWELL_CORE:\r\ncase INTEL_FAM6_HASWELL_ULT:\r\ncase INTEL_FAM6_HASWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_CORE:\r\ncase INTEL_FAM6_BROADWELL_GT3E:\r\ndo_rapl = RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_GFX | RAPL_PKG_POWER_INFO;\r\nif (rapl_joules) {\r\nBIC_PRESENT(BIC_Pkg_J);\r\nBIC_PRESENT(BIC_Cor_J);\r\nBIC_PRESENT(BIC_GFX_J);\r\n} else {\r\nBIC_PRESENT(BIC_PkgWatt);\r\nBIC_PRESENT(BIC_CorWatt);\r\nBIC_PRESENT(BIC_GFXWatt);\r\n}\r\nbreak;\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_ATOM_GEMINI_LAKE:\r\ndo_rapl = RAPL_PKG | RAPL_PKG_POWER_INFO;\r\nif (rapl_joules)\r\nBIC_PRESENT(BIC_Pkg_J);\r\nelse\r\nBIC_PRESENT(BIC_PkgWatt);\r\nbreak;\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\ndo_rapl = RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_DRAM | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_GFX | RAPL_PKG_POWER_INFO;\r\nBIC_PRESENT(BIC_PKG__);\r\nBIC_PRESENT(BIC_RAM__);\r\nif (rapl_joules) {\r\nBIC_PRESENT(BIC_Pkg_J);\r\nBIC_PRESENT(BIC_Cor_J);\r\nBIC_PRESENT(BIC_RAM_J);\r\nBIC_PRESENT(BIC_GFX_J);\r\n} else {\r\nBIC_PRESENT(BIC_PkgWatt);\r\nBIC_PRESENT(BIC_CorWatt);\r\nBIC_PRESENT(BIC_RAMWatt);\r\nBIC_PRESENT(BIC_GFXWatt);\r\n}\r\nbreak;\r\ncase INTEL_FAM6_HASWELL_X:\r\ncase INTEL_FAM6_BROADWELL_X:\r\ncase INTEL_FAM6_BROADWELL_XEON_D:\r\ncase INTEL_FAM6_SKYLAKE_X:\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\ndo_rapl = RAPL_PKG | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO;\r\nBIC_PRESENT(BIC_PKG__);\r\nBIC_PRESENT(BIC_RAM__);\r\nif (rapl_joules) {\r\nBIC_PRESENT(BIC_Pkg_J);\r\nBIC_PRESENT(BIC_RAM_J);\r\n} else {\r\nBIC_PRESENT(BIC_PkgWatt);\r\nBIC_PRESENT(BIC_RAMWatt);\r\n}\r\nbreak;\r\ncase INTEL_FAM6_SANDYBRIDGE_X:\r\ncase INTEL_FAM6_IVYBRIDGE_X:\r\ndo_rapl = RAPL_PKG | RAPL_CORES | RAPL_CORE_POLICY | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_PKG_PERF_STATUS | RAPL_DRAM_PERF_STATUS | RAPL_PKG_POWER_INFO;\r\nBIC_PRESENT(BIC_PKG__);\r\nBIC_PRESENT(BIC_RAM__);\r\nif (rapl_joules) {\r\nBIC_PRESENT(BIC_Pkg_J);\r\nBIC_PRESENT(BIC_Cor_J);\r\nBIC_PRESENT(BIC_RAM_J);\r\n} else {\r\nBIC_PRESENT(BIC_PkgWatt);\r\nBIC_PRESENT(BIC_CorWatt);\r\nBIC_PRESENT(BIC_RAMWatt);\r\n}\r\nbreak;\r\ncase INTEL_FAM6_ATOM_SILVERMONT1:\r\ncase INTEL_FAM6_ATOM_SILVERMONT2:\r\ndo_rapl = RAPL_PKG | RAPL_CORES;\r\nif (rapl_joules) {\r\nBIC_PRESENT(BIC_Pkg_J);\r\nBIC_PRESENT(BIC_Cor_J);\r\n} else {\r\nBIC_PRESENT(BIC_PkgWatt);\r\nBIC_PRESENT(BIC_CorWatt);\r\n}\r\nbreak;\r\ncase INTEL_FAM6_ATOM_DENVERTON:\r\ndo_rapl = RAPL_PKG | RAPL_DRAM | RAPL_DRAM_POWER_INFO | RAPL_DRAM_PERF_STATUS | RAPL_PKG_PERF_STATUS | RAPL_PKG_POWER_INFO | RAPL_CORES_ENERGY_STATUS;\r\nBIC_PRESENT(BIC_PKG__);\r\nBIC_PRESENT(BIC_RAM__);\r\nif (rapl_joules) {\r\nBIC_PRESENT(BIC_Pkg_J);\r\nBIC_PRESENT(BIC_Cor_J);\r\nBIC_PRESENT(BIC_RAM_J);\r\n} else {\r\nBIC_PRESENT(BIC_PkgWatt);\r\nBIC_PRESENT(BIC_CorWatt);\r\nBIC_PRESENT(BIC_RAMWatt);\r\n}\r\nbreak;\r\ndefault:\r\nreturn;\r\n}\r\nif (get_msr(base_cpu, MSR_RAPL_POWER_UNIT, &msr))\r\nreturn;\r\nrapl_power_units = 1.0 / (1 << (msr & 0xF));\r\nif (model == INTEL_FAM6_ATOM_SILVERMONT1)\r\nrapl_energy_units = 1.0 * (1 << (msr >> 8 & 0x1F)) / 1000000;\r\nelse\r\nrapl_energy_units = 1.0 / (1 << (msr >> 8 & 0x1F));\r\nrapl_dram_energy_units = rapl_dram_energy_units_probe(model, rapl_energy_units);\r\ntime_unit = msr >> 16 & 0xF;\r\nif (time_unit == 0)\r\ntime_unit = 0xA;\r\nrapl_time_units = 1.0 / (1 << (time_unit));\r\ntdp = get_tdp(model);\r\nrapl_joule_counter_range = 0xFFFFFFFF * rapl_energy_units / tdp;\r\nif (!quiet)\r\nfprintf(outf, "RAPL: %.0f sec. Joule Counter Range, at %.0f Watts\n", rapl_joule_counter_range, tdp);\r\nreturn;\r\n}\r\nvoid perf_limit_reasons_probe(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn;\r\nif (family != 6)\r\nreturn;\r\nswitch (model) {\r\ncase INTEL_FAM6_HASWELL_CORE:\r\ncase INTEL_FAM6_HASWELL_ULT:\r\ncase INTEL_FAM6_HASWELL_GT3E:\r\ndo_gfx_perf_limit_reasons = 1;\r\ncase INTEL_FAM6_HASWELL_X:\r\ndo_core_perf_limit_reasons = 1;\r\ndo_ring_perf_limit_reasons = 1;\r\ndefault:\r\nreturn;\r\n}\r\n}\r\nint print_thermal(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nunsigned int dts, dts2;\r\nint cpu;\r\nif (!(do_dts || do_ptm))\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE))\r\nreturn 0;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (do_ptm && (t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE)) {\r\nif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_STATUS, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\nfprintf(outf, "cpu%d: MSR_IA32_PACKAGE_THERM_STATUS: 0x%08llx (%d C)\n",\r\ncpu, msr, tcc_activation_temp - dts);\r\nif (get_msr(cpu, MSR_IA32_PACKAGE_THERM_INTERRUPT, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\ndts2 = (msr >> 8) & 0x7F;\r\nfprintf(outf, "cpu%d: MSR_IA32_PACKAGE_THERM_INTERRUPT: 0x%08llx (%d C, %d C)\n",\r\ncpu, msr, tcc_activation_temp - dts, tcc_activation_temp - dts2);\r\n}\r\nif (do_dts && debug) {\r\nunsigned int resolution;\r\nif (get_msr(cpu, MSR_IA32_THERM_STATUS, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\nresolution = (msr >> 27) & 0xF;\r\nfprintf(outf, "cpu%d: MSR_IA32_THERM_STATUS: 0x%08llx (%d C +/- %d)\n",\r\ncpu, msr, tcc_activation_temp - dts, resolution);\r\nif (get_msr(cpu, MSR_IA32_THERM_INTERRUPT, &msr))\r\nreturn 0;\r\ndts = (msr >> 16) & 0x7F;\r\ndts2 = (msr >> 8) & 0x7F;\r\nfprintf(outf, "cpu%d: MSR_IA32_THERM_INTERRUPT: 0x%08llx (%d C, %d C)\n",\r\ncpu, msr, tcc_activation_temp - dts, tcc_activation_temp - dts2);\r\n}\r\nreturn 0;\r\n}\r\nvoid print_power_limit_msr(int cpu, unsigned long long msr, char *label)\r\n{\r\nfprintf(outf, "cpu%d: %s: %sabled (%f Watts, %f sec, clamp %sabled)\n",\r\ncpu, label,\r\n((msr >> 15) & 1) ? "EN" : "DIS",\r\n((msr >> 0) & 0x7FFF) * rapl_power_units,\r\n(1.0 + (((msr >> 22) & 0x3)/4.0)) * (1 << ((msr >> 17) & 0x1F)) * rapl_time_units,\r\n(((msr >> 16) & 1) ? "EN" : "DIS"));\r\nreturn;\r\n}\r\nint print_rapl(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nint cpu;\r\nif (!do_rapl)\r\nreturn 0;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (get_msr(cpu, MSR_RAPL_POWER_UNIT, &msr))\r\nreturn -1;\r\nfprintf(outf, "cpu%d: MSR_RAPL_POWER_UNIT: 0x%08llx (%f Watts, %f Joules, %f sec.)\n", cpu, msr,\r\nrapl_power_units, rapl_energy_units, rapl_time_units);\r\nif (do_rapl & RAPL_PKG_POWER_INFO) {\r\nif (get_msr(cpu, MSR_PKG_POWER_INFO, &msr))\r\nreturn -5;\r\nfprintf(outf, "cpu%d: MSR_PKG_POWER_INFO: 0x%08llx (%.0f W TDP, RAPL %.0f - %.0f W, %f sec.)\n",\r\ncpu, msr,\r\n((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 16) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 32) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 48) & RAPL_TIME_GRANULARITY) * rapl_time_units);\r\n}\r\nif (do_rapl & RAPL_PKG) {\r\nif (get_msr(cpu, MSR_PKG_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(outf, "cpu%d: MSR_PKG_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 63) & 1 ? "" : "UN");\r\nprint_power_limit_msr(cpu, msr, "PKG Limit #1");\r\nfprintf(outf, "cpu%d: PKG Limit #2: %sabled (%f Watts, %f* sec, clamp %sabled)\n",\r\ncpu,\r\n((msr >> 47) & 1) ? "EN" : "DIS",\r\n((msr >> 32) & 0x7FFF) * rapl_power_units,\r\n(1.0 + (((msr >> 54) & 0x3)/4.0)) * (1 << ((msr >> 49) & 0x1F)) * rapl_time_units,\r\n((msr >> 48) & 1) ? "EN" : "DIS");\r\n}\r\nif (do_rapl & RAPL_DRAM_POWER_INFO) {\r\nif (get_msr(cpu, MSR_DRAM_POWER_INFO, &msr))\r\nreturn -6;\r\nfprintf(outf, "cpu%d: MSR_DRAM_POWER_INFO,: 0x%08llx (%.0f W TDP, RAPL %.0f - %.0f W, %f sec.)\n",\r\ncpu, msr,\r\n((msr >> 0) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 16) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 32) & RAPL_POWER_GRANULARITY) * rapl_power_units,\r\n((msr >> 48) & RAPL_TIME_GRANULARITY) * rapl_time_units);\r\n}\r\nif (do_rapl & RAPL_DRAM) {\r\nif (get_msr(cpu, MSR_DRAM_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(outf, "cpu%d: MSR_DRAM_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 31) & 1 ? "" : "UN");\r\nprint_power_limit_msr(cpu, msr, "DRAM Limit");\r\n}\r\nif (do_rapl & RAPL_CORE_POLICY) {\r\nif (get_msr(cpu, MSR_PP0_POLICY, &msr))\r\nreturn -7;\r\nfprintf(outf, "cpu%d: MSR_PP0_POLICY: %lld\n", cpu, msr & 0xF);\r\n}\r\nif (do_rapl & RAPL_CORES_POWER_LIMIT) {\r\nif (get_msr(cpu, MSR_PP0_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(outf, "cpu%d: MSR_PP0_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 31) & 1 ? "" : "UN");\r\nprint_power_limit_msr(cpu, msr, "Cores Limit");\r\n}\r\nif (do_rapl & RAPL_GFX) {\r\nif (get_msr(cpu, MSR_PP1_POLICY, &msr))\r\nreturn -8;\r\nfprintf(outf, "cpu%d: MSR_PP1_POLICY: %lld\n", cpu, msr & 0xF);\r\nif (get_msr(cpu, MSR_PP1_POWER_LIMIT, &msr))\r\nreturn -9;\r\nfprintf(outf, "cpu%d: MSR_PP1_POWER_LIMIT: 0x%08llx (%slocked)\n",\r\ncpu, msr, (msr >> 31) & 1 ? "" : "UN");\r\nprint_power_limit_msr(cpu, msr, "GFX Limit");\r\n}\r\nreturn 0;\r\n}\r\nint has_snb_msrs(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_SANDYBRIDGE:\r\ncase INTEL_FAM6_SANDYBRIDGE_X:\r\ncase INTEL_FAM6_IVYBRIDGE:\r\ncase INTEL_FAM6_IVYBRIDGE_X:\r\ncase INTEL_FAM6_HASWELL_CORE:\r\ncase INTEL_FAM6_HASWELL_X:\r\ncase INTEL_FAM6_HASWELL_ULT:\r\ncase INTEL_FAM6_HASWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_CORE:\r\ncase INTEL_FAM6_BROADWELL_GT3E:\r\ncase INTEL_FAM6_BROADWELL_X:\r\ncase INTEL_FAM6_BROADWELL_XEON_D:\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\ncase INTEL_FAM6_SKYLAKE_X:\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_ATOM_GEMINI_LAKE:\r\ncase INTEL_FAM6_ATOM_DENVERTON:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint has_hsw_msrs(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_HASWELL_ULT:\r\ncase INTEL_FAM6_BROADWELL_CORE:\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_ATOM_GEMINI_LAKE:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint has_skl_msrs(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint is_slm(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_ATOM_SILVERMONT1:\r\ncase INTEL_FAM6_ATOM_SILVERMONT2:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nint is_knl(unsigned int family, unsigned int model)\r\n{\r\nif (!genuine_intel)\r\nreturn 0;\r\nswitch (model) {\r\ncase INTEL_FAM6_XEON_PHI_KNL:\r\ncase INTEL_FAM6_XEON_PHI_KNM:\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nunsigned int get_aperf_mperf_multiplier(unsigned int family, unsigned int model)\r\n{\r\nif (is_knl(family, model))\r\nreturn 1024;\r\nreturn 1;\r\n}\r\ndouble slm_bclk(void)\r\n{\r\nunsigned long long msr = 3;\r\nunsigned int i;\r\ndouble freq;\r\nif (get_msr(base_cpu, MSR_FSB_FREQ, &msr))\r\nfprintf(outf, "SLM BCLK: unknown\n");\r\ni = msr & 0xf;\r\nif (i >= SLM_BCLK_FREQS) {\r\nfprintf(outf, "SLM BCLK[%d] invalid\n", i);\r\ni = 3;\r\n}\r\nfreq = slm_freq_table[i];\r\nif (!quiet)\r\nfprintf(outf, "SLM BCLK: %.1f Mhz\n", freq);\r\nreturn freq;\r\n}\r\ndouble discover_bclk(unsigned int family, unsigned int model)\r\n{\r\nif (has_snb_msrs(family, model) || is_knl(family, model))\r\nreturn 100.00;\r\nelse if (is_slm(family, model))\r\nreturn slm_bclk();\r\nelse\r\nreturn 133.33;\r\n}\r\nint set_temperature_target(struct thread_data *t, struct core_data *c, struct pkg_data *p)\r\n{\r\nunsigned long long msr;\r\nunsigned int target_c_local;\r\nint cpu;\r\nif (!(do_dts || do_ptm))\r\nreturn 0;\r\nif (!(t->flags & CPU_IS_FIRST_THREAD_IN_CORE) || !(t->flags & CPU_IS_FIRST_CORE_IN_PACKAGE))\r\nreturn 0;\r\ncpu = t->cpu_id;\r\nif (cpu_migrate(cpu)) {\r\nfprintf(outf, "Could not migrate to CPU %d\n", cpu);\r\nreturn -1;\r\n}\r\nif (tcc_activation_temp_override != 0) {\r\ntcc_activation_temp = tcc_activation_temp_override;\r\nfprintf(outf, "cpu%d: Using cmdline TCC Target (%d C)\n",\r\ncpu, tcc_activation_temp);\r\nreturn 0;\r\n}\r\nif (!do_nhm_platform_info)\r\ngoto guess;\r\nif (get_msr(base_cpu, MSR_IA32_TEMPERATURE_TARGET, &msr))\r\ngoto guess;\r\ntarget_c_local = (msr >> 16) & 0xFF;\r\nif (!quiet)\r\nfprintf(outf, "cpu%d: MSR_IA32_TEMPERATURE_TARGET: 0x%08llx (%d C)\n",\r\ncpu, msr, target_c_local);\r\nif (!target_c_local)\r\ngoto guess;\r\ntcc_activation_temp = target_c_local;\r\nreturn 0;\r\nguess:\r\ntcc_activation_temp = TJMAX_DEFAULT;\r\nfprintf(outf, "cpu%d: Guessing tjMax %d C, Please use -T to specify\n",\r\ncpu, tcc_activation_temp);\r\nreturn 0;\r\n}\r\nvoid decode_feature_control_msr(void)\r\n{\r\nunsigned long long msr;\r\nif (!get_msr(base_cpu, MSR_IA32_FEATURE_CONTROL, &msr))\r\nfprintf(outf, "cpu%d: MSR_IA32_FEATURE_CONTROL: 0x%08llx (%sLocked %s)\n",\r\nbase_cpu, msr,\r\nmsr & FEATURE_CONTROL_LOCKED ? "" : "UN-",\r\nmsr & (1 << 18) ? "SGX" : "");\r\n}\r\nvoid decode_misc_enable_msr(void)\r\n{\r\nunsigned long long msr;\r\nif (!get_msr(base_cpu, MSR_IA32_MISC_ENABLE, &msr))\r\nfprintf(outf, "cpu%d: MSR_IA32_MISC_ENABLE: 0x%08llx (%sTCC %sEIST %sMWAIT %sPREFETCH %sTURBO)\n",\r\nbase_cpu, msr,\r\nmsr & MSR_IA32_MISC_ENABLE_TM1 ? "" : "No-",\r\nmsr & MSR_IA32_MISC_ENABLE_ENHANCED_SPEEDSTEP ? "" : "No-",\r\nmsr & MSR_IA32_MISC_ENABLE_MWAIT ? "No-" : "",\r\nmsr & MSR_IA32_MISC_ENABLE_PREFETCH_DISABLE ? "No-" : "",\r\nmsr & MSR_IA32_MISC_ENABLE_TURBO_DISABLE ? "No-" : "");\r\n}\r\nvoid decode_misc_feature_control(void)\r\n{\r\nunsigned long long msr;\r\nif (!has_misc_feature_control)\r\nreturn;\r\nif (!get_msr(base_cpu, MSR_MISC_FEATURE_CONTROL, &msr))\r\nfprintf(outf, "cpu%d: MSR_MISC_FEATURE_CONTROL: 0x%08llx (%sL2-Prefetch %sL2-Prefetch-pair %sL1-Prefetch %sL1-IP-Prefetch)\n",\r\nbase_cpu, msr,\r\nmsr & (0 << 0) ? "No-" : "",\r\nmsr & (1 << 0) ? "No-" : "",\r\nmsr & (2 << 0) ? "No-" : "",\r\nmsr & (3 << 0) ? "No-" : "");\r\n}\r\nvoid decode_misc_pwr_mgmt_msr(void)\r\n{\r\nunsigned long long msr;\r\nif (!do_nhm_platform_info)\r\nreturn;\r\nif (no_MSR_MISC_PWR_MGMT)\r\nreturn;\r\nif (!get_msr(base_cpu, MSR_MISC_PWR_MGMT, &msr))\r\nfprintf(outf, "cpu%d: MSR_MISC_PWR_MGMT: 0x%08llx (%sable-EIST_Coordination %sable-EPB %sable-OOB)\n",\r\nbase_cpu, msr,\r\nmsr & (1 << 0) ? "DIS" : "EN",\r\nmsr & (1 << 1) ? "EN" : "DIS",\r\nmsr & (1 << 8) ? "EN" : "DIS");\r\n}\r\nvoid decode_c6_demotion_policy_msr(void)\r\n{\r\nunsigned long long msr;\r\nif (!get_msr(base_cpu, MSR_CC6_DEMOTION_POLICY_CONFIG, &msr))\r\nfprintf(outf, "cpu%d: MSR_CC6_DEMOTION_POLICY_CONFIG: 0x%08llx (%sable-CC6-Demotion)\n",\r\nbase_cpu, msr, msr & (1 << 0) ? "EN" : "DIS");\r\nif (!get_msr(base_cpu, MSR_MC6_DEMOTION_POLICY_CONFIG, &msr))\r\nfprintf(outf, "cpu%d: MSR_MC6_DEMOTION_POLICY_CONFIG: 0x%08llx (%sable-MC6-Demotion)\n",\r\nbase_cpu, msr, msr & (1 << 0) ? "EN" : "DIS");\r\n}\r\nvoid process_cpuid()\r\n{\r\nunsigned int eax, ebx, ecx, edx, max_level, max_extended_level;\r\nunsigned int fms, family, model, stepping;\r\nunsigned int has_turbo;\r\neax = ebx = ecx = edx = 0;\r\n__cpuid(0, max_level, ebx, ecx, edx);\r\nif (ebx == 0x756e6547 && edx == 0x49656e69 && ecx == 0x6c65746e)\r\ngenuine_intel = 1;\r\nif (!quiet)\r\nfprintf(outf, "CPUID(0): %.4s%.4s%.4s ",\r\n(char *)&ebx, (char *)&edx, (char *)&ecx);\r\n__cpuid(1, fms, ebx, ecx, edx);\r\nfamily = (fms >> 8) & 0xf;\r\nmodel = (fms >> 4) & 0xf;\r\nstepping = fms & 0xf;\r\nif (family == 6 || family == 0xf)\r\nmodel += ((fms >> 16) & 0xf) << 4;\r\nif (!quiet) {\r\nfprintf(outf, "%d CPUID levels; family:model:stepping 0x%x:%x:%x (%d:%d:%d)\n",\r\nmax_level, family, model, stepping, family, model, stepping);\r\nfprintf(outf, "CPUID(1): %s %s %s %s %s %s %s %s %s\n",\r\necx & (1 << 0) ? "SSE3" : "-",\r\necx & (1 << 3) ? "MONITOR" : "-",\r\necx & (1 << 6) ? "SMX" : "-",\r\necx & (1 << 7) ? "EIST" : "-",\r\necx & (1 << 8) ? "TM2" : "-",\r\nedx & (1 << 4) ? "TSC" : "-",\r\nedx & (1 << 5) ? "MSR" : "-",\r\nedx & (1 << 22) ? "ACPI-TM" : "-",\r\nedx & (1 << 29) ? "TM" : "-");\r\n}\r\nif (!(edx & (1 << 5)))\r\nerrx(1, "CPUID: no MSR");\r\nebx = ecx = edx = 0;\r\n__cpuid(0x80000000, max_extended_level, ebx, ecx, edx);\r\nif (max_extended_level >= 0x80000007) {\r\n__cpuid(0x80000007, eax, ebx, ecx, edx);\r\nhas_invariant_tsc = edx & (1 << 8);\r\n}\r\n__cpuid(0x6, eax, ebx, ecx, edx);\r\nhas_aperf = ecx & (1 << 0);\r\nif (has_aperf) {\r\nBIC_PRESENT(BIC_Avg_MHz);\r\nBIC_PRESENT(BIC_Busy);\r\nBIC_PRESENT(BIC_Bzy_MHz);\r\n}\r\ndo_dts = eax & (1 << 0);\r\nif (do_dts)\r\nBIC_PRESENT(BIC_CoreTmp);\r\nhas_turbo = eax & (1 << 1);\r\ndo_ptm = eax & (1 << 6);\r\nif (do_ptm)\r\nBIC_PRESENT(BIC_PkgTmp);\r\nhas_hwp = eax & (1 << 7);\r\nhas_hwp_notify = eax & (1 << 8);\r\nhas_hwp_activity_window = eax & (1 << 9);\r\nhas_hwp_epp = eax & (1 << 10);\r\nhas_hwp_pkg = eax & (1 << 11);\r\nhas_epb = ecx & (1 << 3);\r\nif (!quiet)\r\nfprintf(outf, "CPUID(6): %sAPERF, %sTURBO, %sDTS, %sPTM, %sHWP, "\r\n"%sHWPnotify, %sHWPwindow, %sHWPepp, %sHWPpkg, %sEPB\n",\r\nhas_aperf ? "" : "No-",\r\nhas_turbo ? "" : "No-",\r\ndo_dts ? "" : "No-",\r\ndo_ptm ? "" : "No-",\r\nhas_hwp ? "" : "No-",\r\nhas_hwp_notify ? "" : "No-",\r\nhas_hwp_activity_window ? "" : "No-",\r\nhas_hwp_epp ? "" : "No-",\r\nhas_hwp_pkg ? "" : "No-",\r\nhas_epb ? "" : "No-");\r\nif (!quiet)\r\ndecode_misc_enable_msr();\r\nif (max_level >= 0x7 && !quiet) {\r\nint has_sgx;\r\necx = 0;\r\n__cpuid_count(0x7, 0, eax, ebx, ecx, edx);\r\nhas_sgx = ebx & (1 << 2);\r\nfprintf(outf, "CPUID(7): %sSGX\n", has_sgx ? "" : "No-");\r\nif (has_sgx)\r\ndecode_feature_control_msr();\r\n}\r\nif (max_level >= 0x15) {\r\nunsigned int eax_crystal;\r\nunsigned int ebx_tsc;\r\neax_crystal = ebx_tsc = crystal_hz = edx = 0;\r\n__cpuid(0x15, eax_crystal, ebx_tsc, crystal_hz, edx);\r\nif (ebx_tsc != 0) {\r\nif (!quiet && (ebx != 0))\r\nfprintf(outf, "CPUID(0x15): eax_crystal: %d ebx_tsc: %d ecx_crystal_hz: %d\n",\r\neax_crystal, ebx_tsc, crystal_hz);\r\nif (crystal_hz == 0)\r\nswitch(model) {\r\ncase INTEL_FAM6_SKYLAKE_MOBILE:\r\ncase INTEL_FAM6_SKYLAKE_DESKTOP:\r\ncase INTEL_FAM6_KABYLAKE_MOBILE:\r\ncase INTEL_FAM6_KABYLAKE_DESKTOP:\r\ncrystal_hz = 24000000;\r\nbreak;\r\ncase INTEL_FAM6_SKYLAKE_X:\r\ncase INTEL_FAM6_ATOM_DENVERTON:\r\ncrystal_hz = 25000000;\r\nbreak;\r\ncase INTEL_FAM6_ATOM_GOLDMONT:\r\ncase INTEL_FAM6_ATOM_GEMINI_LAKE:\r\ncrystal_hz = 19200000;\r\nbreak;\r\ndefault:\r\ncrystal_hz = 0;\r\n}\r\nif (crystal_hz) {\r\ntsc_hz = (unsigned long long) crystal_hz * ebx_tsc / eax_crystal;\r\nif (!quiet)\r\nfprintf(outf, "TSC: %lld MHz (%d Hz * %d / %d / 1000000)\n",\r\ntsc_hz / 1000000, crystal_hz, ebx_tsc, eax_crystal);\r\n}\r\n}\r\n}\r\nif (max_level >= 0x16) {\r\nunsigned int base_mhz, max_mhz, bus_mhz, edx;\r\nbase_mhz = max_mhz = bus_mhz = edx = 0;\r\n__cpuid(0x16, base_mhz, max_mhz, bus_mhz, edx);\r\nif (!quiet)\r\nfprintf(outf, "CPUID(0x16): base_mhz: %d max_mhz: %d bus_mhz: %d\n",\r\nbase_mhz, max_mhz, bus_mhz);\r\n}\r\nif (has_aperf)\r\naperf_mperf_multiplier = get_aperf_mperf_multiplier(family, model);\r\nBIC_PRESENT(BIC_IRQ);\r\nBIC_PRESENT(BIC_TSC_MHz);\r\nif (probe_nhm_msrs(family, model)) {\r\ndo_nhm_platform_info = 1;\r\nBIC_PRESENT(BIC_CPU_c1);\r\nBIC_PRESENT(BIC_CPU_c3);\r\nBIC_PRESENT(BIC_CPU_c6);\r\nBIC_PRESENT(BIC_SMI);\r\n}\r\ndo_snb_cstates = has_snb_msrs(family, model);\r\nif (do_snb_cstates)\r\nBIC_PRESENT(BIC_CPU_c7);\r\ndo_irtl_snb = has_snb_msrs(family, model);\r\nif (do_snb_cstates && (pkg_cstate_limit >= PCL__2))\r\nBIC_PRESENT(BIC_Pkgpc2);\r\nif (pkg_cstate_limit >= PCL__3)\r\nBIC_PRESENT(BIC_Pkgpc3);\r\nif (pkg_cstate_limit >= PCL__6)\r\nBIC_PRESENT(BIC_Pkgpc6);\r\nif (do_snb_cstates && (pkg_cstate_limit >= PCL__7))\r\nBIC_PRESENT(BIC_Pkgpc7);\r\nif (has_slv_msrs(family, model)) {\r\nBIC_NOT_PRESENT(BIC_Pkgpc2);\r\nBIC_NOT_PRESENT(BIC_Pkgpc3);\r\nBIC_PRESENT(BIC_Pkgpc6);\r\nBIC_NOT_PRESENT(BIC_Pkgpc7);\r\nBIC_PRESENT(BIC_Mod_c6);\r\nuse_c1_residency_msr = 1;\r\n}\r\nif (is_dnv(family, model)) {\r\nBIC_PRESENT(BIC_CPU_c1);\r\nBIC_NOT_PRESENT(BIC_CPU_c3);\r\nBIC_NOT_PRESENT(BIC_Pkgpc3);\r\nBIC_NOT_PRESENT(BIC_CPU_c7);\r\nBIC_NOT_PRESENT(BIC_Pkgpc7);\r\nuse_c1_residency_msr = 1;\r\n}\r\nif (is_skx(family, model)) {\r\nBIC_NOT_PRESENT(BIC_CPU_c3);\r\nBIC_NOT_PRESENT(BIC_Pkgpc3);\r\nBIC_NOT_PRESENT(BIC_CPU_c7);\r\nBIC_NOT_PRESENT(BIC_Pkgpc7);\r\n}\r\nif (is_bdx(family, model)) {\r\nBIC_NOT_PRESENT(BIC_CPU_c7);\r\nBIC_NOT_PRESENT(BIC_Pkgpc7);\r\n}\r\nif (has_hsw_msrs(family, model)) {\r\nBIC_PRESENT(BIC_Pkgpc8);\r\nBIC_PRESENT(BIC_Pkgpc9);\r\nBIC_PRESENT(BIC_Pkgpc10);\r\n}\r\ndo_irtl_hsw = has_hsw_msrs(family, model);\r\ndo_skl_residency = has_skl_msrs(family, model);\r\ndo_slm_cstates = is_slm(family, model);\r\ndo_knl_cstates = is_knl(family, model);\r\nif (!quiet)\r\ndecode_misc_pwr_mgmt_msr();\r\nif (!quiet && has_slv_msrs(family, model))\r\ndecode_c6_demotion_policy_msr();\r\nrapl_probe(family, model);\r\nperf_limit_reasons_probe(family, model);\r\nif (!quiet)\r\ndump_cstate_pstate_config_info(family, model);\r\nif (!quiet)\r\ndump_sysfs_cstate_config();\r\nif (!quiet)\r\ndump_sysfs_pstate_config();\r\nif (has_skl_msrs(family, model))\r\ncalculate_tsc_tweak();\r\nif (!access("/sys/class/drm/card0/power/rc6_residency_ms", R_OK))\r\nBIC_PRESENT(BIC_GFX_rc6);\r\nif (!access("/sys/class/graphics/fb0/device/drm/card0/gt_cur_freq_mhz", R_OK))\r\nBIC_PRESENT(BIC_GFXMHz);\r\nif (!quiet)\r\ndecode_misc_feature_control();\r\nreturn;\r\n}\r\nint dir_filter(const struct dirent *dirp)\r\n{\r\nif (isdigit(dirp->d_name[0]))\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nint open_dev_cpu_msr(int dummy1)\r\n{\r\nreturn 0;\r\n}\r\nvoid topology_probe()\r\n{\r\nint i;\r\nint max_core_id = 0;\r\nint max_package_id = 0;\r\nint max_siblings = 0;\r\nstruct cpu_topology {\r\nint core_id;\r\nint physical_package_id;\r\n} *cpus;\r\ntopo.num_cpus = 0;\r\ntopo.max_cpu_num = 0;\r\nfor_all_proc_cpus(count_cpus);\r\nif (!summary_only && topo.num_cpus > 1)\r\nBIC_PRESENT(BIC_CPU);\r\nif (debug > 1)\r\nfprintf(outf, "num_cpus %d max_cpu_num %d\n", topo.num_cpus, topo.max_cpu_num);\r\ncpus = calloc(1, (topo.max_cpu_num + 1) * sizeof(struct cpu_topology));\r\nif (cpus == NULL)\r\nerr(1, "calloc cpus");\r\ncpu_present_set = CPU_ALLOC((topo.max_cpu_num + 1));\r\nif (cpu_present_set == NULL)\r\nerr(3, "CPU_ALLOC");\r\ncpu_present_setsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\r\nCPU_ZERO_S(cpu_present_setsize, cpu_present_set);\r\nfor_all_proc_cpus(mark_cpu_present);\r\nfor (i = 0; i < CPU_SUBSET_MAXCPUS; ++i) {\r\nif (CPU_ISSET_S(i, cpu_subset_size, cpu_subset))\r\nif (!CPU_ISSET_S(i, cpu_present_setsize, cpu_present_set))\r\nerr(1, "cpu%d not present", i);\r\n}\r\ncpu_affinity_set = CPU_ALLOC((topo.max_cpu_num + 1));\r\nif (cpu_affinity_set == NULL)\r\nerr(3, "CPU_ALLOC");\r\ncpu_affinity_setsize = CPU_ALLOC_SIZE((topo.max_cpu_num + 1));\r\nCPU_ZERO_S(cpu_affinity_setsize, cpu_affinity_set);\r\nfor (i = 0; i <= topo.max_cpu_num; ++i) {\r\nint siblings;\r\nif (cpu_is_not_present(i)) {\r\nif (debug > 1)\r\nfprintf(outf, "cpu%d NOT PRESENT\n", i);\r\ncontinue;\r\n}\r\ncpus[i].core_id = get_core_id(i);\r\nif (cpus[i].core_id > max_core_id)\r\nmax_core_id = cpus[i].core_id;\r\ncpus[i].physical_package_id = get_physical_package_id(i);\r\nif (cpus[i].physical_package_id > max_package_id)\r\nmax_package_id = cpus[i].physical_package_id;\r\nsiblings = get_num_ht_siblings(i);\r\nif (siblings > max_siblings)\r\nmax_siblings = siblings;\r\nif (debug > 1)\r\nfprintf(outf, "cpu %d pkg %d core %d\n",\r\ni, cpus[i].physical_package_id, cpus[i].core_id);\r\n}\r\ntopo.num_cores_per_pkg = max_core_id + 1;\r\nif (debug > 1)\r\nfprintf(outf, "max_core_id %d, sizing for %d cores per package\n",\r\nmax_core_id, topo.num_cores_per_pkg);\r\nif (!summary_only && topo.num_cores_per_pkg > 1)\r\nBIC_PRESENT(BIC_Core);\r\ntopo.num_packages = max_package_id + 1;\r\nif (debug > 1)\r\nfprintf(outf, "max_package_id %d, sizing for %d packages\n",\r\nmax_package_id, topo.num_packages);\r\nif (!summary_only && topo.num_packages > 1)\r\nBIC_PRESENT(BIC_Package);\r\ntopo.num_threads_per_core = max_siblings;\r\nif (debug > 1)\r\nfprintf(outf, "max_siblings %d\n", max_siblings);\r\nfree(cpus);\r\n}\r\nvoid\r\nallocate_counters(struct thread_data **t, struct core_data **c, struct pkg_data **p)\r\n{\r\nint i;\r\n*t = calloc(topo.num_threads_per_core * topo.num_cores_per_pkg *\r\ntopo.num_packages, sizeof(struct thread_data));\r\nif (*t == NULL)\r\ngoto error;\r\nfor (i = 0; i < topo.num_threads_per_core *\r\ntopo.num_cores_per_pkg * topo.num_packages; i++)\r\n(*t)[i].cpu_id = -1;\r\n*c = calloc(topo.num_cores_per_pkg * topo.num_packages,\r\nsizeof(struct core_data));\r\nif (*c == NULL)\r\ngoto error;\r\nfor (i = 0; i < topo.num_cores_per_pkg * topo.num_packages; i++)\r\n(*c)[i].core_id = -1;\r\n*p = calloc(topo.num_packages, sizeof(struct pkg_data));\r\nif (*p == NULL)\r\ngoto error;\r\nfor (i = 0; i < topo.num_packages; i++)\r\n(*p)[i].package_id = i;\r\nreturn;\r\nerror:\r\nerr(1, "calloc counters");\r\n}\r\nvoid init_counter(struct thread_data *thread_base, struct core_data *core_base,\r\nstruct pkg_data *pkg_base, int thread_num, int core_num,\r\nint pkg_num, int cpu_id)\r\n{\r\nstruct thread_data *t;\r\nstruct core_data *c;\r\nstruct pkg_data *p;\r\nt = GET_THREAD(thread_base, thread_num, core_num, pkg_num);\r\nc = GET_CORE(core_base, core_num, pkg_num);\r\np = GET_PKG(pkg_base, pkg_num);\r\nt->cpu_id = cpu_id;\r\nif (thread_num == 0) {\r\nt->flags |= CPU_IS_FIRST_THREAD_IN_CORE;\r\nif (cpu_is_first_core_in_package(cpu_id))\r\nt->flags |= CPU_IS_FIRST_CORE_IN_PACKAGE;\r\n}\r\nc->core_id = core_num;\r\np->package_id = pkg_num;\r\n}\r\nint initialize_counters(int cpu_id)\r\n{\r\nint my_thread_id, my_core_id, my_package_id;\r\nmy_package_id = get_physical_package_id(cpu_id);\r\nmy_core_id = get_core_id(cpu_id);\r\nmy_thread_id = get_cpu_position_in_core(cpu_id);\r\nif (!my_thread_id)\r\ntopo.num_cores++;\r\ninit_counter(EVEN_COUNTERS, my_thread_id, my_core_id, my_package_id, cpu_id);\r\ninit_counter(ODD_COUNTERS, my_thread_id, my_core_id, my_package_id, cpu_id);\r\nreturn 0;\r\n}\r\nvoid allocate_output_buffer()\r\n{\r\noutput_buffer = calloc(1, (1 + topo.num_cpus) * 1024);\r\noutp = output_buffer;\r\nif (outp == NULL)\r\nerr(-1, "calloc output buffer");\r\n}\r\nvoid allocate_fd_percpu(void)\r\n{\r\nfd_percpu = calloc(topo.max_cpu_num + 1, sizeof(int));\r\nif (fd_percpu == NULL)\r\nerr(-1, "calloc fd_percpu");\r\n}\r\nvoid allocate_irq_buffers(void)\r\n{\r\nirq_column_2_cpu = calloc(topo.num_cpus, sizeof(int));\r\nif (irq_column_2_cpu == NULL)\r\nerr(-1, "calloc %d", topo.num_cpus);\r\nirqs_per_cpu = calloc(topo.max_cpu_num + 1, sizeof(int));\r\nif (irqs_per_cpu == NULL)\r\nerr(-1, "calloc %d", topo.max_cpu_num + 1);\r\n}\r\nvoid setup_all_buffers(void)\r\n{\r\ntopology_probe();\r\nallocate_irq_buffers();\r\nallocate_fd_percpu();\r\nallocate_counters(&thread_even, &core_even, &package_even);\r\nallocate_counters(&thread_odd, &core_odd, &package_odd);\r\nallocate_output_buffer();\r\nfor_all_proc_cpus(initialize_counters);\r\n}\r\nvoid set_base_cpu(void)\r\n{\r\nbase_cpu = sched_getcpu();\r\nif (base_cpu < 0)\r\nerr(-ENODEV, "No valid cpus found");\r\nif (debug > 1)\r\nfprintf(outf, "base_cpu = %d\n", base_cpu);\r\n}\r\nvoid turbostat_init()\r\n{\r\nsetup_all_buffers();\r\nset_base_cpu();\r\ncheck_dev_msr();\r\ncheck_permissions();\r\nprocess_cpuid();\r\nif (!quiet)\r\nfor_all_cpus(print_hwp, ODD_COUNTERS);\r\nif (!quiet)\r\nfor_all_cpus(print_epb, ODD_COUNTERS);\r\nif (!quiet)\r\nfor_all_cpus(print_perf_limit, ODD_COUNTERS);\r\nif (!quiet)\r\nfor_all_cpus(print_rapl, ODD_COUNTERS);\r\nfor_all_cpus(set_temperature_target, ODD_COUNTERS);\r\nif (!quiet)\r\nfor_all_cpus(print_thermal, ODD_COUNTERS);\r\nif (!quiet && do_irtl_snb)\r\nprint_irtl();\r\n}\r\nint fork_it(char **argv)\r\n{\r\npid_t child_pid;\r\nint status;\r\nsnapshot_proc_sysfs_files();\r\nstatus = for_all_cpus(get_counters, EVEN_COUNTERS);\r\nif (status)\r\nexit(status);\r\nsched_setaffinity(0, cpu_present_setsize, cpu_present_set);\r\ngettimeofday(&tv_even, (struct timezone *)NULL);\r\nchild_pid = fork();\r\nif (!child_pid) {\r\nexecvp(argv[0], argv);\r\nerr(errno, "exec %s", argv[0]);\r\n} else {\r\nif (child_pid == -1)\r\nerr(1, "fork");\r\nsignal(SIGINT, SIG_IGN);\r\nsignal(SIGQUIT, SIG_IGN);\r\nif (waitpid(child_pid, &status, 0) == -1)\r\nerr(status, "waitpid");\r\n}\r\nsnapshot_proc_sysfs_files();\r\nfor_all_cpus(get_counters, ODD_COUNTERS);\r\ngettimeofday(&tv_odd, (struct timezone *)NULL);\r\ntimersub(&tv_odd, &tv_even, &tv_delta);\r\nif (for_all_cpus_2(delta_cpu, ODD_COUNTERS, EVEN_COUNTERS))\r\nfprintf(outf, "%s: Counter reset detected\n", progname);\r\nelse {\r\ncompute_average(EVEN_COUNTERS);\r\nformat_all_counters(EVEN_COUNTERS);\r\n}\r\nfprintf(outf, "%.6f sec\n", tv_delta.tv_sec + tv_delta.tv_usec/1000000.0);\r\nflush_output_stderr();\r\nreturn status;\r\n}\r\nint get_and_dump_counters(void)\r\n{\r\nint status;\r\nsnapshot_proc_sysfs_files();\r\nstatus = for_all_cpus(get_counters, ODD_COUNTERS);\r\nif (status)\r\nreturn status;\r\nstatus = for_all_cpus(dump_counters, ODD_COUNTERS);\r\nif (status)\r\nreturn status;\r\nflush_output_stdout();\r\nreturn status;\r\n}\r\nvoid print_version() {\r\nfprintf(outf, "turbostat version 17.04.12"\r\n" - Len Brown <lenb@kernel.org>\n");\r\n}\r\nint add_counter(unsigned int msr_num, char *path, char *name,\r\nunsigned int width, enum counter_scope scope,\r\nenum counter_type type, enum counter_format format, int flags)\r\n{\r\nstruct msr_counter *msrp;\r\nmsrp = calloc(1, sizeof(struct msr_counter));\r\nif (msrp == NULL) {\r\nperror("calloc");\r\nexit(1);\r\n}\r\nmsrp->msr_num = msr_num;\r\nstrncpy(msrp->name, name, NAME_BYTES);\r\nif (path)\r\nstrncpy(msrp->path, path, PATH_BYTES);\r\nmsrp->width = width;\r\nmsrp->type = type;\r\nmsrp->format = format;\r\nmsrp->flags = flags;\r\nswitch (scope) {\r\ncase SCOPE_CPU:\r\nmsrp->next = sys.tp;\r\nsys.tp = msrp;\r\nsys.added_thread_counters++;\r\nif (sys.added_thread_counters > MAX_ADDED_COUNTERS) {\r\nfprintf(stderr, "exceeded max %d added thread counters\n",\r\nMAX_ADDED_COUNTERS);\r\nexit(-1);\r\n}\r\nbreak;\r\ncase SCOPE_CORE:\r\nmsrp->next = sys.cp;\r\nsys.cp = msrp;\r\nsys.added_core_counters++;\r\nif (sys.added_core_counters > MAX_ADDED_COUNTERS) {\r\nfprintf(stderr, "exceeded max %d added core counters\n",\r\nMAX_ADDED_COUNTERS);\r\nexit(-1);\r\n}\r\nbreak;\r\ncase SCOPE_PACKAGE:\r\nmsrp->next = sys.pp;\r\nsys.pp = msrp;\r\nsys.added_package_counters++;\r\nif (sys.added_package_counters > MAX_ADDED_COUNTERS) {\r\nfprintf(stderr, "exceeded max %d added package counters\n",\r\nMAX_ADDED_COUNTERS);\r\nexit(-1);\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nvoid parse_add_command(char *add_command)\r\n{\r\nint msr_num = 0;\r\nchar *path = NULL;\r\nchar name_buffer[NAME_BYTES] = "";\r\nint width = 64;\r\nint fail = 0;\r\nenum counter_scope scope = SCOPE_CPU;\r\nenum counter_type type = COUNTER_CYCLES;\r\nenum counter_format format = FORMAT_DELTA;\r\nwhile (add_command) {\r\nif (sscanf(add_command, "msr0x%x", &msr_num) == 1)\r\ngoto next;\r\nif (sscanf(add_command, "msr%d", &msr_num) == 1)\r\ngoto next;\r\nif (*add_command == '/') {\r\npath = add_command;\r\ngoto next;\r\n}\r\nif (sscanf(add_command, "u%d", &width) == 1) {\r\nif ((width == 32) || (width == 64))\r\ngoto next;\r\nwidth = 64;\r\n}\r\nif (!strncmp(add_command, "cpu", strlen("cpu"))) {\r\nscope = SCOPE_CPU;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "core", strlen("core"))) {\r\nscope = SCOPE_CORE;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "package", strlen("package"))) {\r\nscope = SCOPE_PACKAGE;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "cycles", strlen("cycles"))) {\r\ntype = COUNTER_CYCLES;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "seconds", strlen("seconds"))) {\r\ntype = COUNTER_SECONDS;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "usec", strlen("usec"))) {\r\ntype = COUNTER_USEC;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "raw", strlen("raw"))) {\r\nformat = FORMAT_RAW;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "delta", strlen("delta"))) {\r\nformat = FORMAT_DELTA;\r\ngoto next;\r\n}\r\nif (!strncmp(add_command, "percent", strlen("percent"))) {\r\nformat = FORMAT_PERCENT;\r\ngoto next;\r\n}\r\nif (sscanf(add_command, "%18s,%*s", name_buffer) == 1) {\r\nchar *eos;\r\neos = strchr(name_buffer, ',');\r\nif (eos)\r\n*eos = '\0';\r\ngoto next;\r\n}\r\nnext:\r\nadd_command = strchr(add_command, ',');\r\nif (add_command) {\r\n*add_command = '\0';\r\nadd_command++;\r\n}\r\n}\r\nif ((msr_num == 0) && (path == NULL)) {\r\nfprintf(stderr, "--add: (msrDDD | msr0xXXX | /path_to_counter ) required\n");\r\nfail++;\r\n}\r\nif (*name_buffer == '\0') {\r\nif (width == 32)\r\nsprintf(name_buffer, "M0x%x%s", msr_num, format == FORMAT_PERCENT ? "%" : "");\r\nelse\r\nsprintf(name_buffer, "M0X%x%s", msr_num, format == FORMAT_PERCENT ? "%" : "");\r\n}\r\nif (add_counter(msr_num, path, name_buffer, width, scope, type, format, 0))\r\nfail++;\r\nif (fail) {\r\nhelp();\r\nexit(1);\r\n}\r\n}\r\nint is_deferred_skip(char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < deferred_skip_index; ++i)\r\nif (!strcmp(name, deferred_skip_names[i]))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nvoid probe_sysfs(void)\r\n{\r\nchar path[64];\r\nchar name_buf[16];\r\nFILE *input;\r\nint state;\r\nchar *sp;\r\nif (!DO_BIC(BIC_sysfs))\r\nreturn;\r\nfor (state = 10; state > 0; --state) {\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/cpuidle/state%d/name",\r\nbase_cpu, state);\r\ninput = fopen(path, "r");\r\nif (input == NULL)\r\ncontinue;\r\nfgets(name_buf, sizeof(name_buf), input);\r\nsp = strchr(name_buf, '-');\r\nif (!sp)\r\nsp = strchrnul(name_buf, '\n');\r\n*sp = '%';\r\n*(sp + 1) = '\0';\r\nfclose(input);\r\nsprintf(path, "cpuidle/state%d/time", state);\r\nif (is_deferred_skip(name_buf))\r\ncontinue;\r\nadd_counter(0, path, name_buf, 64, SCOPE_CPU, COUNTER_USEC,\r\nFORMAT_PERCENT, SYSFS_PERCPU);\r\n}\r\nfor (state = 10; state > 0; --state) {\r\nsprintf(path, "/sys/devices/system/cpu/cpu%d/cpuidle/state%d/name",\r\nbase_cpu, state);\r\ninput = fopen(path, "r");\r\nif (input == NULL)\r\ncontinue;\r\nfgets(name_buf, sizeof(name_buf), input);\r\nsp = strchr(name_buf, '-');\r\nif (!sp)\r\nsp = strchrnul(name_buf, '\n');\r\n*sp = '\0';\r\nfclose(input);\r\nsprintf(path, "cpuidle/state%d/usage", state);\r\nif (is_deferred_skip(name_buf))\r\ncontinue;\r\nadd_counter(0, path, name_buf, 64, SCOPE_CPU, COUNTER_ITEMS,\r\nFORMAT_DELTA, SYSFS_PERCPU);\r\n}\r\n}\r\nvoid parse_cpu_command(char *optarg)\r\n{\r\nunsigned int start, end;\r\nchar *next;\r\nif (!strcmp(optarg, "core")) {\r\nif (cpu_subset)\r\ngoto error;\r\nshow_core_only++;\r\nreturn;\r\n}\r\nif (!strcmp(optarg, "package")) {\r\nif (cpu_subset)\r\ngoto error;\r\nshow_pkg_only++;\r\nreturn;\r\n}\r\nif (show_core_only || show_pkg_only)\r\ngoto error;\r\ncpu_subset = CPU_ALLOC(CPU_SUBSET_MAXCPUS);\r\nif (cpu_subset == NULL)\r\nerr(3, "CPU_ALLOC");\r\ncpu_subset_size = CPU_ALLOC_SIZE(CPU_SUBSET_MAXCPUS);\r\nCPU_ZERO_S(cpu_subset_size, cpu_subset);\r\nnext = optarg;\r\nwhile (next && *next) {\r\nif (*next == '-')\r\ngoto error;\r\nstart = strtoul(next, &next, 10);\r\nif (start >= CPU_SUBSET_MAXCPUS)\r\ngoto error;\r\nCPU_SET_S(start, cpu_subset_size, cpu_subset);\r\nif (*next == '\0')\r\nbreak;\r\nif (*next == ',') {\r\nnext += 1;\r\ncontinue;\r\n}\r\nif (*next == '-') {\r\nnext += 1;\r\n} else if (*next == '.') {\r\nnext += 1;\r\nif (*next == '.')\r\nnext += 1;\r\nelse\r\ngoto error;\r\n}\r\nend = strtoul(next, &next, 10);\r\nif (end <= start)\r\ngoto error;\r\nwhile (++start <= end) {\r\nif (start >= CPU_SUBSET_MAXCPUS)\r\ngoto error;\r\nCPU_SET_S(start, cpu_subset_size, cpu_subset);\r\n}\r\nif (*next == ',')\r\nnext += 1;\r\nelse if (*next != '\0')\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\nfprintf(stderr, "\"--cpu %s\" malformed\n", optarg);\r\nhelp();\r\nexit(-1);\r\n}\r\nvoid parse_show_hide(char *optarg, enum show_hide_mode new_mode)\r\n{\r\nif (new_mode == SHOW_LIST) {\r\nif (shown == 0)\r\nbic_enabled = bic_lookup(optarg, new_mode);\r\nelse\r\nbic_enabled |= bic_lookup(optarg, new_mode);\r\nshown = 1;\r\nreturn;\r\n}\r\nbic_enabled &= ~bic_lookup(optarg, new_mode);\r\n}\r\nvoid cmdline(int argc, char **argv)\r\n{\r\nint opt;\r\nint option_index = 0;\r\nstatic struct option long_options[] = {\r\n{"add", required_argument, 0, 'a'},\r\n{"cpu", required_argument, 0, 'c'},\r\n{"Dump", no_argument, 0, 'D'},\r\n{"debug", no_argument, 0, 'd'},\r\n{"interval", required_argument, 0, 'i'},\r\n{"help", no_argument, 0, 'h'},\r\n{"hide", required_argument, 0, 'H'},\r\n{"Joules", no_argument, 0, 'J'},\r\n{"list", no_argument, 0, 'l'},\r\n{"out", required_argument, 0, 'o'},\r\n{"quiet", no_argument, 0, 'q'},\r\n{"show", required_argument, 0, 's'},\r\n{"Summary", no_argument, 0, 'S'},\r\n{"TCC", required_argument, 0, 'T'},\r\n{"version", no_argument, 0, 'v' },\r\n{0, 0, 0, 0 }\r\n};\r\nprogname = argv[0];\r\nwhile ((opt = getopt_long_only(argc, argv, "+C:c:Ddhi:JM:m:o:qST:v",\r\nlong_options, &option_index)) != -1) {\r\nswitch (opt) {\r\ncase 'a':\r\nparse_add_command(optarg);\r\nbreak;\r\ncase 'c':\r\nparse_cpu_command(optarg);\r\nbreak;\r\ncase 'D':\r\ndump_only++;\r\nbreak;\r\ncase 'd':\r\ndebug++;\r\nbreak;\r\ncase 'H':\r\nparse_show_hide(optarg, HIDE_LIST);\r\nbreak;\r\ncase 'h':\r\ndefault:\r\nhelp();\r\nexit(1);\r\ncase 'i':\r\n{\r\ndouble interval = strtod(optarg, NULL);\r\nif (interval < 0.001) {\r\nfprintf(outf, "interval %f seconds is too small\n",\r\ninterval);\r\nexit(2);\r\n}\r\ninterval_ts.tv_sec = interval;\r\ninterval_ts.tv_nsec = (interval - interval_ts.tv_sec) * 1000000000;\r\n}\r\nbreak;\r\ncase 'J':\r\nrapl_joules++;\r\nbreak;\r\ncase 'l':\r\nlist_header_only++;\r\nquiet++;\r\nbreak;\r\ncase 'o':\r\noutf = fopen_or_die(optarg, "w");\r\nbreak;\r\ncase 'q':\r\nquiet = 1;\r\nbreak;\r\ncase 's':\r\nparse_show_hide(optarg, SHOW_LIST);\r\nbreak;\r\ncase 'S':\r\nsummary_only++;\r\nbreak;\r\ncase 'T':\r\ntcc_activation_temp_override = atoi(optarg);\r\nbreak;\r\ncase 'v':\r\nprint_version();\r\nexit(0);\r\nbreak;\r\n}\r\n}\r\n}\r\nint main(int argc, char **argv)\r\n{\r\noutf = stderr;\r\ncmdline(argc, argv);\r\nif (!quiet)\r\nprint_version();\r\nprobe_sysfs();\r\nturbostat_init();\r\nif (dump_only)\r\nreturn get_and_dump_counters();\r\nif (list_header_only) {\r\nprint_header(",");\r\nflush_output_stdout();\r\nreturn 0;\r\n}\r\nif (argc - optind)\r\nreturn fork_it(argv + optind);\r\nelse\r\nturbostat_loop();\r\nreturn 0;\r\n}
