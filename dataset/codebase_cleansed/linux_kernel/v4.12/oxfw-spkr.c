static int avc_audio_feature_mute(struct fw_unit *unit, u8 fb_id, bool *value,\r\nenum control_action action)\r\n{\r\nu8 *buf;\r\nu8 response_ok;\r\nint err;\r\nbuf = kmalloc(11, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (action == CTL_READ) {\r\nbuf[0] = 0x01;\r\nresponse_ok = 0x0c;\r\n} else {\r\nbuf[0] = 0x00;\r\nresponse_ok = 0x09;\r\n}\r\nbuf[1] = 0x08;\r\nbuf[2] = 0xb8;\r\nbuf[3] = 0x81;\r\nbuf[4] = fb_id;\r\nbuf[5] = 0x10;\r\nbuf[6] = 0x02;\r\nbuf[7] = 0x00;\r\nbuf[8] = 0x01;\r\nbuf[9] = 0x01;\r\nif (action == CTL_READ)\r\nbuf[10] = 0xff;\r\nelse\r\nbuf[10] = *value ? 0x70 : 0x60;\r\nerr = fcp_avc_transaction(unit, buf, 11, buf, 11, 0x3fe);\r\nif (err < 0)\r\ngoto error;\r\nif (err < 11) {\r\ndev_err(&unit->device, "short FCP response\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (buf[0] != response_ok) {\r\ndev_err(&unit->device, "mute command failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (action == CTL_READ)\r\n*value = buf[10] == 0x70;\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int avc_audio_feature_volume(struct fw_unit *unit, u8 fb_id, s16 *value,\r\nunsigned int channel,\r\nenum control_attribute attribute,\r\nenum control_action action)\r\n{\r\nu8 *buf;\r\nu8 response_ok;\r\nint err;\r\nbuf = kmalloc(12, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (action == CTL_READ) {\r\nbuf[0] = 0x01;\r\nresponse_ok = 0x0c;\r\n} else {\r\nbuf[0] = 0x00;\r\nresponse_ok = 0x09;\r\n}\r\nbuf[1] = 0x08;\r\nbuf[2] = 0xb8;\r\nbuf[3] = 0x81;\r\nbuf[4] = fb_id;\r\nbuf[5] = attribute;\r\nbuf[6] = 0x02;\r\nbuf[7] = channel;\r\nbuf[8] = 0x02;\r\nbuf[9] = 0x02;\r\nif (action == CTL_READ) {\r\nbuf[10] = 0xff;\r\nbuf[11] = 0xff;\r\n} else {\r\nbuf[10] = *value >> 8;\r\nbuf[11] = *value;\r\n}\r\nerr = fcp_avc_transaction(unit, buf, 12, buf, 12, 0x3fe);\r\nif (err < 0)\r\ngoto error;\r\nif (err < 12) {\r\ndev_err(&unit->device, "short FCP response\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (buf[0] != response_ok) {\r\ndev_err(&unit->device, "volume command failed\n");\r\nerr = -EIO;\r\ngoto error;\r\n}\r\nif (action == CTL_READ)\r\n*value = (buf[10] << 8) | buf[11];\r\nerr = 0;\r\nerror:\r\nkfree(buf);\r\nreturn err;\r\n}\r\nstatic int spkr_mute_get(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nstruct fw_spkr *spkr = oxfw->spec;\r\nvalue->value.integer.value[0] = !spkr->mute;\r\nreturn 0;\r\n}\r\nstatic int spkr_mute_put(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nstruct fw_spkr *spkr = oxfw->spec;\r\nbool mute;\r\nint err;\r\nmute = !value->value.integer.value[0];\r\nif (mute == spkr->mute)\r\nreturn 0;\r\nerr = avc_audio_feature_mute(oxfw->unit, spkr->mute_fb_id, &mute,\r\nCTL_WRITE);\r\nif (err < 0)\r\nreturn err;\r\nspkr->mute = mute;\r\nreturn 1;\r\n}\r\nstatic int spkr_volume_info(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_info *info)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nstruct fw_spkr *spkr = oxfw->spec;\r\ninfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;\r\ninfo->count = spkr->mixer_channels;\r\ninfo->value.integer.min = spkr->volume_min;\r\ninfo->value.integer.max = spkr->volume_max;\r\nreturn 0;\r\n}\r\nstatic int spkr_volume_get(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nstruct fw_spkr *spkr = oxfw->spec;\r\nunsigned int i;\r\nfor (i = 0; i < spkr->mixer_channels; ++i)\r\nvalue->value.integer.value[channel_map[i]] = spkr->volume[i];\r\nreturn 0;\r\n}\r\nstatic int spkr_volume_put(struct snd_kcontrol *control,\r\nstruct snd_ctl_elem_value *value)\r\n{\r\nstruct snd_oxfw *oxfw = control->private_data;\r\nstruct fw_spkr *spkr = oxfw->spec;\r\nunsigned int i, changed_channels;\r\nbool equal_values = true;\r\ns16 volume;\r\nint err;\r\nfor (i = 0; i < spkr->mixer_channels; ++i) {\r\nif (value->value.integer.value[i] < spkr->volume_min ||\r\nvalue->value.integer.value[i] > spkr->volume_max)\r\nreturn -EINVAL;\r\nif (value->value.integer.value[i] !=\r\nvalue->value.integer.value[0])\r\nequal_values = false;\r\n}\r\nchanged_channels = 0;\r\nfor (i = 0; i < spkr->mixer_channels; ++i)\r\nif (value->value.integer.value[channel_map[i]] !=\r\nspkr->volume[i])\r\nchanged_channels |= 1 << (i + 1);\r\nif (equal_values && changed_channels != 0)\r\nchanged_channels = 1 << 0;\r\nfor (i = 0; i <= spkr->mixer_channels; ++i) {\r\nvolume = value->value.integer.value[channel_map[i ? i - 1 : 0]];\r\nif (changed_channels & (1 << i)) {\r\nerr = avc_audio_feature_volume(oxfw->unit,\r\nspkr->volume_fb_id, &volume,\r\ni, CTL_CURRENT, CTL_WRITE);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nif (i > 0)\r\nspkr->volume[i - 1] = volume;\r\n}\r\nreturn changed_channels != 0;\r\n}\r\nint snd_oxfw_add_spkr(struct snd_oxfw *oxfw, bool is_lacie)\r\n{\r\nstatic const struct snd_kcontrol_new controls[] = {\r\n{\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "PCM Playback Switch",\r\n.info = snd_ctl_boolean_mono_info,\r\n.get = spkr_mute_get,\r\n.put = spkr_mute_put,\r\n},\r\n{\r\n.iface = SNDRV_CTL_ELEM_IFACE_MIXER,\r\n.name = "PCM Playback Volume",\r\n.info = spkr_volume_info,\r\n.get = spkr_volume_get,\r\n.put = spkr_volume_put,\r\n},\r\n};\r\nstruct fw_spkr *spkr;\r\nunsigned int i, first_ch;\r\nint err;\r\nspkr = kzalloc(sizeof(struct fw_spkr), GFP_KERNEL);\r\nif (spkr == NULL)\r\nreturn -ENOMEM;\r\noxfw->spec = spkr;\r\nif (is_lacie) {\r\nspkr->mixer_channels = 1;\r\nspkr->mute_fb_id = 0x01;\r\nspkr->volume_fb_id = 0x01;\r\n} else {\r\nspkr->mixer_channels = 6;\r\nspkr->mute_fb_id = 0x01;\r\nspkr->volume_fb_id = 0x02;\r\n}\r\nerr = avc_audio_feature_volume(oxfw->unit, spkr->volume_fb_id,\r\n&spkr->volume_min, 0, CTL_MIN, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nerr = avc_audio_feature_volume(oxfw->unit, spkr->volume_fb_id,\r\n&spkr->volume_max, 0, CTL_MAX, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nerr = avc_audio_feature_mute(oxfw->unit, spkr->mute_fb_id, &spkr->mute,\r\nCTL_READ);\r\nif (err < 0)\r\nreturn err;\r\nfirst_ch = spkr->mixer_channels == 1 ? 0 : 1;\r\nfor (i = 0; i < spkr->mixer_channels; ++i) {\r\nerr = avc_audio_feature_volume(oxfw->unit, spkr->volume_fb_id,\r\n&spkr->volume[i], first_ch + i,\r\nCTL_CURRENT, CTL_READ);\r\nif (err < 0)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(controls); ++i) {\r\nerr = snd_ctl_add(oxfw->card,\r\nsnd_ctl_new1(&controls[i], oxfw));\r\nif (err < 0)\r\nreturn err;\r\n}\r\nreturn 0;\r\n}
