static inline int OK_id(char *s)\r\n{\r\nreturn memcmp (s, "GEM", 3) == 0 || memcmp (s, "BGM", 3) == 0 ||\r\nmemcmp (s, "LNX", 3) == 0 || memcmp (s, "SWP", 3) == 0 ||\r\nmemcmp (s, "RAW", 3) == 0 ;\r\n}\r\nint atari_partition(struct parsed_partitions *state)\r\n{\r\nSector sect;\r\nstruct rootsector *rs;\r\nstruct partition_info *pi;\r\nu32 extensect;\r\nu32 hd_size;\r\nint slot;\r\n#ifdef ICD_PARTS\r\nint part_fmt = 0;\r\n#endif\r\nif (bdev_logical_block_size(state->bdev) != 512)\r\nreturn 0;\r\nrs = read_part_sector(state, 0, &sect);\r\nif (!rs)\r\nreturn -1;\r\nhd_size = state->bdev->bd_inode->i_size >> 9;\r\nif (!VALID_PARTITION(&rs->part[0], hd_size) &&\r\n!VALID_PARTITION(&rs->part[1], hd_size) &&\r\n!VALID_PARTITION(&rs->part[2], hd_size) &&\r\n!VALID_PARTITION(&rs->part[3], hd_size)) {\r\nput_dev_sector(sect);\r\nreturn 0;\r\n}\r\npi = &rs->part[0];\r\nstrlcat(state->pp_buf, " AHDI", PAGE_SIZE);\r\nfor (slot = 1; pi < &rs->part[4] && slot < state->limit; slot++, pi++) {\r\nstruct rootsector *xrs;\r\nSector sect2;\r\nulong partsect;\r\nif ( !(pi->flg & 1) )\r\ncontinue;\r\nif (memcmp (pi->id, "XGM", 3) != 0) {\r\nput_partition (state, slot, be32_to_cpu(pi->st),\r\nbe32_to_cpu(pi->siz));\r\ncontinue;\r\n}\r\n#ifdef ICD_PARTS\r\npart_fmt = 1;\r\n#endif\r\nstrlcat(state->pp_buf, " XGM<", PAGE_SIZE);\r\npartsect = extensect = be32_to_cpu(pi->st);\r\nwhile (1) {\r\nxrs = read_part_sector(state, partsect, &sect2);\r\nif (!xrs) {\r\nprintk (" block %ld read failed\n", partsect);\r\nput_dev_sector(sect);\r\nreturn -1;\r\n}\r\nif (!(xrs->part[0].flg & 1)) {\r\nprintk( "\nFirst sub-partition in extended partition is not valid!\n" );\r\nput_dev_sector(sect2);\r\nbreak;\r\n}\r\nput_partition(state, slot,\r\npartsect + be32_to_cpu(xrs->part[0].st),\r\nbe32_to_cpu(xrs->part[0].siz));\r\nif (!(xrs->part[1].flg & 1)) {\r\nput_dev_sector(sect2);\r\nbreak;\r\n}\r\nif (memcmp( xrs->part[1].id, "XGM", 3 ) != 0) {\r\nprintk("\nID of extended partition is not XGM!\n");\r\nput_dev_sector(sect2);\r\nbreak;\r\n}\r\npartsect = be32_to_cpu(xrs->part[1].st) + extensect;\r\nput_dev_sector(sect2);\r\nif (++slot == state->limit) {\r\nprintk( "\nMaximum number of partitions reached!\n" );\r\nbreak;\r\n}\r\n}\r\nstrlcat(state->pp_buf, " >", PAGE_SIZE);\r\n}\r\n#ifdef ICD_PARTS\r\nif ( part_fmt!=1 ) {\r\npi = &rs->icdpart[0];\r\nif (OK_id(pi->id)) {\r\nstrlcat(state->pp_buf, " ICD<", PAGE_SIZE);\r\nfor (; pi < &rs->icdpart[8] && slot < state->limit; slot++, pi++) {\r\nif (!((pi->flg & 1) && OK_id(pi->id)))\r\ncontinue;\r\npart_fmt = 2;\r\nput_partition (state, slot,\r\nbe32_to_cpu(pi->st),\r\nbe32_to_cpu(pi->siz));\r\n}\r\nstrlcat(state->pp_buf, " >", PAGE_SIZE);\r\n}\r\n}\r\n#endif\r\nput_dev_sector(sect);\r\nstrlcat(state->pp_buf, "\n", PAGE_SIZE);\r\nreturn 1;\r\n}
