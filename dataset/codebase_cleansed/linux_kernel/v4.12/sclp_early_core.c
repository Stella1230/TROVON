void sclp_early_wait_irq(void)\r\n{\r\nunsigned long psw_mask, addr;\r\npsw_t psw_ext_save, psw_wait;\r\nunion ctlreg0 cr0, cr0_new;\r\n__ctl_store(cr0.val, 0, 0);\r\ncr0_new.val = cr0.val & ~CR0_IRQ_SUBCLASS_MASK;\r\ncr0_new.lap = 0;\r\ncr0_new.sssm = 1;\r\n__ctl_load(cr0_new.val, 0, 0);\r\npsw_ext_save = S390_lowcore.external_new_psw;\r\npsw_mask = __extract_psw();\r\nS390_lowcore.external_new_psw.mask = psw_mask;\r\npsw_wait.mask = psw_mask | PSW_MASK_EXT | PSW_MASK_WAIT;\r\nS390_lowcore.ext_int_code = 0;\r\ndo {\r\nasm volatile(\r\n" larl %[addr],0f\n"\r\n" stg %[addr],%[psw_wait_addr]\n"\r\n" stg %[addr],%[psw_ext_addr]\n"\r\n" lpswe %[psw_wait]\n"\r\n"0:\n"\r\n: [addr] "=&d" (addr),\r\n[psw_wait_addr] "=Q" (psw_wait.addr),\r\n[psw_ext_addr] "=Q" (S390_lowcore.external_new_psw.addr)\r\n: [psw_wait] "Q" (psw_wait)\r\n: "cc", "memory");\r\n} while (S390_lowcore.ext_int_code != EXT_IRQ_SERVICE_SIG);\r\nS390_lowcore.external_new_psw = psw_ext_save;\r\n__ctl_load(cr0.val, 0, 0);\r\n}\r\nint sclp_early_cmd(sclp_cmdw_t cmd, void *sccb)\r\n{\r\nunsigned long flags;\r\nint rc;\r\nraw_local_irq_save(flags);\r\nrc = sclp_service_call(cmd, sccb);\r\nif (rc)\r\ngoto out;\r\nsclp_early_wait_irq();\r\nout:\r\nraw_local_irq_restore(flags);\r\nreturn rc;\r\n}\r\nstatic void sclp_early_print_lm(const char *str, unsigned int len)\r\n{\r\nunsigned char *ptr, *end, ch;\r\nunsigned int count, offset;\r\nstruct write_sccb *sccb;\r\nstruct msg_buf *msg;\r\nstruct mdb *mdb;\r\nstruct mto *mto;\r\nstruct go *go;\r\nsccb = (struct write_sccb *) &sclp_early_sccb;\r\nend = (unsigned char *) sccb + sizeof(sclp_early_sccb) - 1;\r\nmemset(sccb, 0, sizeof(*sccb));\r\nptr = (unsigned char *) &sccb->msg.mdb.mto;\r\noffset = 0;\r\ndo {\r\nfor (count = sizeof(*mto); offset < len; count++) {\r\nch = str[offset++];\r\nif ((ch == 0x0a) || (ptr + count > end))\r\nbreak;\r\nptr[count] = _ascebc[ch];\r\n}\r\nmto = (struct mto *) ptr;\r\nmemset(mto, 0, sizeof(*mto));\r\nmto->length = count;\r\nmto->type = 4;\r\nmto->line_type_flags = LNTPFLGS_ENDTEXT;\r\nptr += count;\r\n} while ((offset < len) && (ptr + sizeof(*mto) <= end));\r\nlen = ptr - (unsigned char *) sccb;\r\nsccb->header.length = len - offsetof(struct write_sccb, header);\r\nmsg = &sccb->msg;\r\nmsg->header.type = EVTYP_MSG;\r\nmsg->header.length = len - offsetof(struct write_sccb, msg.header);\r\nmdb = &msg->mdb;\r\nmdb->header.type = 1;\r\nmdb->header.tag = 0xD4C4C240;\r\nmdb->header.revision_code = 1;\r\nmdb->header.length = len - offsetof(struct write_sccb, msg.mdb.header);\r\ngo = &mdb->go;\r\ngo->length = sizeof(*go);\r\ngo->type = 1;\r\nsclp_early_cmd(SCLP_CMDW_WRITE_EVENT_DATA, sccb);\r\n}\r\nstatic void sclp_early_print_vt220(const char *str, unsigned int len)\r\n{\r\nstruct vt220_sccb *sccb;\r\nsccb = (struct vt220_sccb *) &sclp_early_sccb;\r\nif (sizeof(*sccb) + len >= sizeof(sclp_early_sccb))\r\nlen = sizeof(sclp_early_sccb) - sizeof(*sccb);\r\nmemset(sccb, 0, sizeof(*sccb));\r\nmemcpy(&sccb->msg.data, str, len);\r\nsccb->header.length = sizeof(*sccb) + len;\r\nsccb->msg.header.length = sizeof(sccb->msg) + len;\r\nsccb->msg.header.type = EVTYP_VT220MSG;\r\nsclp_early_cmd(SCLP_CMDW_WRITE_EVENT_DATA, sccb);\r\n}\r\nint sclp_early_set_event_mask(struct init_sccb *sccb,\r\nunsigned long receive_mask,\r\nunsigned long send_mask)\r\n{\r\nmemset(sccb, 0, sizeof(*sccb));\r\nsccb->header.length = sizeof(*sccb);\r\nsccb->mask_length = sizeof(sccb_mask_t);\r\nsccb->receive_mask = receive_mask;\r\nsccb->send_mask = send_mask;\r\nif (sclp_early_cmd(SCLP_CMDW_WRITE_EVENT_MASK, sccb))\r\nreturn -EIO;\r\nif (sccb->header.response_code != 0x20)\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nunsigned int sclp_early_con_check_linemode(struct init_sccb *sccb)\r\n{\r\nif (!(sccb->sclp_send_mask & EVTYP_OPCMD_MASK))\r\nreturn 0;\r\nif (!(sccb->sclp_receive_mask & (EVTYP_MSG_MASK | EVTYP_PMSGCMD_MASK)))\r\nreturn 0;\r\nreturn 1;\r\n}\r\nstatic int sclp_early_setup(int disable, int *have_linemode, int *have_vt220)\r\n{\r\nunsigned long receive_mask, send_mask;\r\nstruct init_sccb *sccb;\r\nint rc;\r\n*have_linemode = *have_vt220 = 0;\r\nsccb = (struct init_sccb *) &sclp_early_sccb;\r\nreceive_mask = disable ? 0 : EVTYP_OPCMD_MASK;\r\nsend_mask = disable ? 0 : EVTYP_VT220MSG_MASK | EVTYP_MSG_MASK;\r\nrc = sclp_early_set_event_mask(sccb, receive_mask, send_mask);\r\nif (rc)\r\nreturn rc;\r\n*have_linemode = sclp_early_con_check_linemode(sccb);\r\n*have_vt220 = sccb->send_mask & EVTYP_VT220MSG_MASK;\r\nreturn rc;\r\n}\r\nvoid __sclp_early_printk(const char *str, unsigned int len)\r\n{\r\nint have_linemode, have_vt220;\r\nif (sclp_init_state != sclp_init_state_uninitialized)\r\nreturn;\r\nif (sclp_early_setup(0, &have_linemode, &have_vt220) != 0)\r\nreturn;\r\nif (have_linemode)\r\nsclp_early_print_lm(str, len);\r\nif (have_vt220)\r\nsclp_early_print_vt220(str, len);\r\nsclp_early_setup(1, &have_linemode, &have_vt220);\r\n}\r\nvoid sclp_early_printk(const char *str)\r\n{\r\n__sclp_early_printk(str, strlen(str));\r\n}
