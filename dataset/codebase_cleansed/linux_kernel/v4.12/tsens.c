static int tsens_get_temp(void *data, int *temp)\r\n{\r\nconst struct tsens_sensor *s = data;\r\nstruct tsens_device *tmdev = s->tmdev;\r\nreturn tmdev->ops->get_temp(tmdev, s->id, temp);\r\n}\r\nstatic int tsens_get_trend(void *p, int trip, enum thermal_trend *trend)\r\n{\r\nconst struct tsens_sensor *s = p;\r\nstruct tsens_device *tmdev = s->tmdev;\r\nif (tmdev->ops->get_trend)\r\nreturn tmdev->ops->get_trend(tmdev, s->id, trend);\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int __maybe_unused tsens_suspend(struct device *dev)\r\n{\r\nstruct tsens_device *tmdev = dev_get_drvdata(dev);\r\nif (tmdev->ops && tmdev->ops->suspend)\r\nreturn tmdev->ops->suspend(tmdev);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused tsens_resume(struct device *dev)\r\n{\r\nstruct tsens_device *tmdev = dev_get_drvdata(dev);\r\nif (tmdev->ops && tmdev->ops->resume)\r\nreturn tmdev->ops->resume(tmdev);\r\nreturn 0;\r\n}\r\nstatic int tsens_register(struct tsens_device *tmdev)\r\n{\r\nint i;\r\nstruct thermal_zone_device *tzd;\r\nu32 *hw_id, n = tmdev->num_sensors;\r\nhw_id = devm_kcalloc(tmdev->dev, n, sizeof(u32), GFP_KERNEL);\r\nif (!hw_id)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < tmdev->num_sensors; i++) {\r\ntmdev->sensor[i].tmdev = tmdev;\r\ntmdev->sensor[i].id = i;\r\ntzd = devm_thermal_zone_of_sensor_register(tmdev->dev, i,\r\n&tmdev->sensor[i],\r\n&tsens_of_ops);\r\nif (IS_ERR(tzd))\r\ncontinue;\r\ntmdev->sensor[i].tzd = tzd;\r\nif (tmdev->ops->enable)\r\ntmdev->ops->enable(tmdev, i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int tsens_probe(struct platform_device *pdev)\r\n{\r\nint ret, i;\r\nstruct device *dev;\r\nstruct device_node *np;\r\nstruct tsens_sensor *s;\r\nstruct tsens_device *tmdev;\r\nconst struct tsens_data *data;\r\nconst struct of_device_id *id;\r\nif (pdev->dev.of_node)\r\ndev = &pdev->dev;\r\nelse\r\ndev = pdev->dev.parent;\r\nnp = dev->of_node;\r\nid = of_match_node(tsens_table, np);\r\nif (id)\r\ndata = id->data;\r\nelse\r\ndata = &data_8960;\r\nif (data->num_sensors <= 0) {\r\ndev_err(dev, "invalid number of sensors\n");\r\nreturn -EINVAL;\r\n}\r\ntmdev = devm_kzalloc(dev, sizeof(*tmdev) +\r\ndata->num_sensors * sizeof(*s), GFP_KERNEL);\r\nif (!tmdev)\r\nreturn -ENOMEM;\r\ntmdev->dev = dev;\r\ntmdev->num_sensors = data->num_sensors;\r\ntmdev->ops = data->ops;\r\nfor (i = 0; i < tmdev->num_sensors; i++) {\r\nif (data->hw_ids)\r\ntmdev->sensor[i].hw_id = data->hw_ids[i];\r\nelse\r\ntmdev->sensor[i].hw_id = i;\r\n}\r\nif (!tmdev->ops || !tmdev->ops->init || !tmdev->ops->get_temp)\r\nreturn -EINVAL;\r\nret = tmdev->ops->init(tmdev);\r\nif (ret < 0) {\r\ndev_err(dev, "tsens init failed\n");\r\nreturn ret;\r\n}\r\nif (tmdev->ops->calibrate) {\r\nret = tmdev->ops->calibrate(tmdev);\r\nif (ret < 0) {\r\ndev_err(dev, "tsens calibration failed\n");\r\nreturn ret;\r\n}\r\n}\r\nret = tsens_register(tmdev);\r\nplatform_set_drvdata(pdev, tmdev);\r\nreturn ret;\r\n}\r\nstatic int tsens_remove(struct platform_device *pdev)\r\n{\r\nstruct tsens_device *tmdev = platform_get_drvdata(pdev);\r\nif (tmdev->ops->disable)\r\ntmdev->ops->disable(tmdev);\r\nreturn 0;\r\n}
