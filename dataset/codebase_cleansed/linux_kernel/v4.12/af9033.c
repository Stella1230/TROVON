static int af9033_wr_reg_val_tab(struct af9033_dev *dev,\r\nconst struct reg_val *tab, int tab_len)\r\n{\r\nstruct i2c_client *client = dev->client;\r\n#define MAX_TAB_LEN 212\r\nint ret, i, j;\r\nu8 buf[1 + MAX_TAB_LEN];\r\ndev_dbg(&client->dev, "tab_len=%d\n", tab_len);\r\nif (tab_len > sizeof(buf)) {\r\ndev_warn(&client->dev, "tab len %d is too big\n", tab_len);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0, j = 0; i < tab_len; i++) {\r\nbuf[j] = tab[i].val;\r\nif (i == tab_len - 1 || tab[i].reg != tab[i + 1].reg - 1) {\r\nret = regmap_bulk_write(dev->regmap, tab[i].reg - j,\r\nbuf, j + 1);\r\nif (ret)\r\ngoto err;\r\nj = 0;\r\n} else {\r\nj++;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_init(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i, len;\r\nunsigned int utmp;\r\nconst struct reg_val *init;\r\nu8 buf[4];\r\nstruct reg_val_mask tab[] = {\r\n{ 0x80fb24, 0x00, 0x08 },\r\n{ 0x80004c, 0x00, 0xff },\r\n{ 0x00f641, dev->cfg.tuner, 0xff },\r\n{ 0x80f5ca, 0x01, 0x01 },\r\n{ 0x80f715, 0x01, 0x01 },\r\n{ 0x00f41f, 0x04, 0x04 },\r\n{ 0x00f41a, 0x01, 0x01 },\r\n{ 0x80f731, 0x00, 0x01 },\r\n{ 0x00d91e, 0x00, 0x01 },\r\n{ 0x00d919, 0x00, 0x01 },\r\n{ 0x80f732, 0x00, 0x01 },\r\n{ 0x00d91f, 0x00, 0x01 },\r\n{ 0x00d91a, 0x00, 0x01 },\r\n{ 0x80f730, 0x00, 0x01 },\r\n{ 0x80f778, 0x00, 0xff },\r\n{ 0x80f73c, 0x01, 0x01 },\r\n{ 0x80f776, 0x00, 0x01 },\r\n{ 0x00d8fd, 0x01, 0xff },\r\n{ 0x00d830, 0x01, 0xff },\r\n{ 0x00d831, 0x00, 0xff },\r\n{ 0x00d832, 0x00, 0xff },\r\n{ 0x80f985, dev->ts_mode_serial, 0x01 },\r\n{ 0x80f986, dev->ts_mode_parallel, 0x01 },\r\n{ 0x00d827, 0x00, 0xff },\r\n{ 0x00d829, 0x00, 0xff },\r\n{ 0x800045, dev->cfg.adc_multiplier, 0xff },\r\n};\r\ndev_dbg(&client->dev, "\n");\r\nutmp = div_u64((u64)dev->cfg.clock * 0x80000, 1000000);\r\nbuf[0] = (utmp >> 0) & 0xff;\r\nbuf[1] = (utmp >> 8) & 0xff;\r\nbuf[2] = (utmp >> 16) & 0xff;\r\nbuf[3] = (utmp >> 24) & 0xff;\r\nret = regmap_bulk_write(dev->regmap, 0x800025, buf, 4);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "clk=%u clk_cw=%08x\n", dev->cfg.clock, utmp);\r\nfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\r\nif (clock_adc_lut[i].clock == dev->cfg.clock)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(clock_adc_lut)) {\r\ndev_err(&client->dev, "Couldn't find ADC config for clock %d\n",\r\ndev->cfg.clock);\r\ngoto err;\r\n}\r\nutmp = div_u64((u64)clock_adc_lut[i].adc * 0x80000, 1000000);\r\nbuf[0] = (utmp >> 0) & 0xff;\r\nbuf[1] = (utmp >> 8) & 0xff;\r\nbuf[2] = (utmp >> 16) & 0xff;\r\nret = regmap_bulk_write(dev->regmap, 0x80f1cd, buf, 3);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "adc=%u adc_cw=%06x\n",\r\nclock_adc_lut[i].adc, utmp);\r\nfor (i = 0; i < ARRAY_SIZE(tab); i++) {\r\nret = regmap_update_bits(dev->regmap, tab[i].reg, tab[i].mask,\r\ntab[i].val);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (dev->cfg.dyn0_clk) {\r\nret = regmap_write(dev->regmap, 0x80fba8, 0x00);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (dev->cfg.ts_mode == AF9033_TS_MODE_USB) {\r\nret = regmap_update_bits(dev->regmap, 0x80f9a5, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x80f9b5, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = regmap_update_bits(dev->regmap, 0x80f990, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x80f9b5, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev_dbg(&client->dev, "load ofsm settings\n");\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\nlen = ARRAY_SIZE(ofsm_init_it9135_v1);\r\ninit = ofsm_init_it9135_v1;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nlen = ARRAY_SIZE(ofsm_init_it9135_v2);\r\ninit = ofsm_init_it9135_v2;\r\nbreak;\r\ndefault:\r\nlen = ARRAY_SIZE(ofsm_init);\r\ninit = ofsm_init;\r\nbreak;\r\n}\r\nret = af9033_wr_reg_val_tab(dev, init, len);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "load tuner specific settings\n");\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_TUA9001:\r\nlen = ARRAY_SIZE(tuner_init_tua9001);\r\ninit = tuner_init_tua9001;\r\nbreak;\r\ncase AF9033_TUNER_FC0011:\r\nlen = ARRAY_SIZE(tuner_init_fc0011);\r\ninit = tuner_init_fc0011;\r\nbreak;\r\ncase AF9033_TUNER_MXL5007T:\r\nlen = ARRAY_SIZE(tuner_init_mxl5007t);\r\ninit = tuner_init_mxl5007t;\r\nbreak;\r\ncase AF9033_TUNER_TDA18218:\r\nlen = ARRAY_SIZE(tuner_init_tda18218);\r\ninit = tuner_init_tda18218;\r\nbreak;\r\ncase AF9033_TUNER_FC2580:\r\nlen = ARRAY_SIZE(tuner_init_fc2580);\r\ninit = tuner_init_fc2580;\r\nbreak;\r\ncase AF9033_TUNER_FC0012:\r\nlen = ARRAY_SIZE(tuner_init_fc0012);\r\ninit = tuner_init_fc0012;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_38:\r\nlen = ARRAY_SIZE(tuner_init_it9135_38);\r\ninit = tuner_init_it9135_38;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_51:\r\nlen = ARRAY_SIZE(tuner_init_it9135_51);\r\ninit = tuner_init_it9135_51;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_52:\r\nlen = ARRAY_SIZE(tuner_init_it9135_52);\r\ninit = tuner_init_it9135_52;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_60:\r\nlen = ARRAY_SIZE(tuner_init_it9135_60);\r\ninit = tuner_init_it9135_60;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_61:\r\nlen = ARRAY_SIZE(tuner_init_it9135_61);\r\ninit = tuner_init_it9135_61;\r\nbreak;\r\ncase AF9033_TUNER_IT9135_62:\r\nlen = ARRAY_SIZE(tuner_init_it9135_62);\r\ninit = tuner_init_it9135_62;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "unsupported tuner ID=%d\n",\r\ndev->cfg.tuner);\r\nret = -ENODEV;\r\ngoto err;\r\n}\r\nret = af9033_wr_reg_val_tab(dev, init, len);\r\nif (ret)\r\ngoto err;\r\nif (dev->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\r\nret = regmap_update_bits(dev->regmap, 0x00d91c, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x00d917, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x00d916, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\n}\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nret = regmap_write(dev->regmap, 0x800000, 0x01);\r\nif (ret)\r\ngoto err;\r\n}\r\ndev->bandwidth_hz = 0;\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->cnr.len = 1;\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_count.len = 1;\r\nc->block_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nunsigned int utmp;\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_write(dev->regmap, 0x80004c, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x800000, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_read_poll_timeout(dev->regmap, 0x80004c, utmp, utmp == 0,\r\n5000, 1000000);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x80fb24, 0x08, 0x08);\r\nif (ret)\r\ngoto err;\r\nif (dev->cfg.ts_mode == AF9033_TS_MODE_SERIAL) {\r\nret = regmap_update_bits(dev->regmap, 0x00d917, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x00d916, 0x01, 0x01);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *fesettings)\r\n{\r\nfesettings->min_delay_ms = 2000;\r\nfesettings->step_size = 0;\r\nfesettings->max_drift = 0;\r\nreturn 0;\r\n}\r\nstatic int af9033_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, i;\r\nunsigned int utmp, adc_freq;\r\nu8 tmp, buf[3], bandwidth_reg_val;\r\nu32 if_frequency;\r\ndev_dbg(&client->dev, "frequency=%u bandwidth_hz=%u\n",\r\nc->frequency, c->bandwidth_hz);\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nbandwidth_reg_val = 0x00;\r\nbreak;\r\ncase 7000000:\r\nbandwidth_reg_val = 0x01;\r\nbreak;\r\ncase 8000000:\r\nbandwidth_reg_val = 0x02;\r\nbreak;\r\ndefault:\r\ndev_dbg(&client->dev, "invalid bandwidth_hz\n");\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nif (fe->ops.tuner_ops.set_params)\r\nfe->ops.tuner_ops.set_params(fe);\r\nif (c->bandwidth_hz != dev->bandwidth_hz) {\r\nfor (i = 0; i < ARRAY_SIZE(coeff_lut); i++) {\r\nif (coeff_lut[i].clock == dev->cfg.clock &&\r\ncoeff_lut[i].bandwidth_hz == c->bandwidth_hz) {\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(coeff_lut)) {\r\ndev_err(&client->dev,\r\n"Couldn't find config for clock %u\n",\r\ndev->cfg.clock);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = regmap_bulk_write(dev->regmap, 0x800001, coeff_lut[i].val,\r\nsizeof(coeff_lut[i].val));\r\nif (ret)\r\ngoto err;\r\n}\r\nif (c->bandwidth_hz != dev->bandwidth_hz) {\r\nfor (i = 0; i < ARRAY_SIZE(clock_adc_lut); i++) {\r\nif (clock_adc_lut[i].clock == dev->cfg.clock)\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(clock_adc_lut)) {\r\ndev_err(&client->dev,\r\n"Couldn't find ADC clock for clock %u\n",\r\ndev->cfg.clock);\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nadc_freq = clock_adc_lut[i].adc;\r\nif (dev->cfg.adc_multiplier == AF9033_ADC_MULTIPLIER_2X)\r\nadc_freq = 2 * adc_freq;\r\nif (fe->ops.tuner_ops.get_if_frequency)\r\nfe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nelse\r\nif_frequency = 0;\r\nutmp = DIV_ROUND_CLOSEST_ULL((u64)if_frequency * 0x800000,\r\nadc_freq);\r\nif (!dev->cfg.spec_inv && if_frequency)\r\nutmp = 0x800000 - utmp;\r\nbuf[0] = (utmp >> 0) & 0xff;\r\nbuf[1] = (utmp >> 8) & 0xff;\r\nbuf[2] = (utmp >> 16) & 0xff;\r\nret = regmap_bulk_write(dev->regmap, 0x800029, buf, 3);\r\nif (ret)\r\ngoto err;\r\ndev_dbg(&client->dev, "if_frequency_cw=%06x\n", utmp);\r\ndev->bandwidth_hz = c->bandwidth_hz;\r\n}\r\nret = regmap_update_bits(dev->regmap, 0x80f904, 0x03,\r\nbandwidth_reg_val);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x800040, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x800047, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = regmap_update_bits(dev->regmap, 0x80f999, 0x01, 0x00);\r\nif (ret)\r\ngoto err;\r\nif (c->frequency <= 230000000)\r\ntmp = 0x00;\r\nelse\r\ntmp = 0x01;\r\nret = regmap_write(dev->regmap, 0x80004b, tmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x800000, 0x00);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_get_frontend(struct dvb_frontend *fe,\r\nstruct dtv_frontend_properties *c)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 buf[8];\r\ndev_dbg(&client->dev, "\n");\r\nret = regmap_bulk_read(dev->regmap, 0x80f900, buf, 8);\r\nif (ret)\r\ngoto err;\r\nswitch ((buf[0] >> 0) & 3) {\r\ncase 0:\r\nc->transmission_mode = TRANSMISSION_MODE_2K;\r\nbreak;\r\ncase 1:\r\nc->transmission_mode = TRANSMISSION_MODE_8K;\r\nbreak;\r\n}\r\nswitch ((buf[1] >> 0) & 3) {\r\ncase 0:\r\nc->guard_interval = GUARD_INTERVAL_1_32;\r\nbreak;\r\ncase 1:\r\nc->guard_interval = GUARD_INTERVAL_1_16;\r\nbreak;\r\ncase 2:\r\nc->guard_interval = GUARD_INTERVAL_1_8;\r\nbreak;\r\ncase 3:\r\nc->guard_interval = GUARD_INTERVAL_1_4;\r\nbreak;\r\n}\r\nswitch ((buf[2] >> 0) & 7) {\r\ncase 0:\r\nc->hierarchy = HIERARCHY_NONE;\r\nbreak;\r\ncase 1:\r\nc->hierarchy = HIERARCHY_1;\r\nbreak;\r\ncase 2:\r\nc->hierarchy = HIERARCHY_2;\r\nbreak;\r\ncase 3:\r\nc->hierarchy = HIERARCHY_4;\r\nbreak;\r\n}\r\nswitch ((buf[3] >> 0) & 3) {\r\ncase 0:\r\nc->modulation = QPSK;\r\nbreak;\r\ncase 1:\r\nc->modulation = QAM_16;\r\nbreak;\r\ncase 2:\r\nc->modulation = QAM_64;\r\nbreak;\r\n}\r\nswitch ((buf[4] >> 0) & 3) {\r\ncase 0:\r\nc->bandwidth_hz = 6000000;\r\nbreak;\r\ncase 1:\r\nc->bandwidth_hz = 7000000;\r\nbreak;\r\ncase 2:\r\nc->bandwidth_hz = 8000000;\r\nbreak;\r\n}\r\nswitch ((buf[6] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_HP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_HP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_HP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_HP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_HP = FEC_7_8;\r\nbreak;\r\ncase 5:\r\nc->code_rate_HP = FEC_NONE;\r\nbreak;\r\n}\r\nswitch ((buf[7] >> 0) & 7) {\r\ncase 0:\r\nc->code_rate_LP = FEC_1_2;\r\nbreak;\r\ncase 1:\r\nc->code_rate_LP = FEC_2_3;\r\nbreak;\r\ncase 2:\r\nc->code_rate_LP = FEC_3_4;\r\nbreak;\r\ncase 3:\r\nc->code_rate_LP = FEC_5_6;\r\nbreak;\r\ncase 4:\r\nc->code_rate_LP = FEC_7_8;\r\nbreak;\r\ncase 5:\r\nc->code_rate_LP = FEC_NONE;\r\nbreak;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_status(struct dvb_frontend *fe, enum fe_status *status)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret, tmp = 0;\r\nu8 buf[7];\r\nunsigned int utmp, utmp1;\r\ndev_dbg(&client->dev, "\n");\r\n*status = 0;\r\nret = regmap_read(dev->regmap, 0x800047, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (utmp == 0x01)\r\n*status |= FE_HAS_SIGNAL;\r\nif (utmp != 0x02) {\r\nret = regmap_read(dev->regmap, 0x80f5a9, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp >> 0) & 0x01)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI;\r\nret = regmap_read(dev->regmap, 0x80f999, &utmp);\r\nif (ret)\r\ngoto err;\r\nif ((utmp >> 0) & 0x01)\r\n*status |= FE_HAS_SIGNAL | FE_HAS_CARRIER |\r\nFE_HAS_VITERBI | FE_HAS_SYNC |\r\nFE_HAS_LOCK;\r\n}\r\ndev->fe_status = *status;\r\nif (dev->fe_status & FE_HAS_SIGNAL) {\r\nif (dev->is_af9035) {\r\nret = regmap_read(dev->regmap, 0x80004a, &utmp);\r\nif (ret)\r\ngoto err;\r\ntmp = -utmp * 1000;\r\n} else {\r\nret = regmap_read(dev->regmap, 0x8000f7, &utmp);\r\nif (ret)\r\ngoto err;\r\ntmp = (utmp - 100) * 1000;\r\n}\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->strength.stat[0].svalue = tmp;\r\n} else {\r\nc->strength.len = 1;\r\nc->strength.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_VITERBI) {\r\nret = regmap_bulk_read(dev->regmap, 0x80002c, buf, 3);\r\nif (ret)\r\ngoto err;\r\nutmp1 = buf[2] << 16 | buf[1] << 8 | buf[0] << 0;\r\nret = regmap_read(dev->regmap, 0x80f78b, &utmp);\r\nif (ret)\r\ngoto err;\r\nif (utmp)\r\nutmp1 /= utmp;\r\nret = regmap_read(dev->regmap, 0x80f900, &utmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((utmp >> 0) & 3) {\r\ncase 0:\r\nutmp1 *= 4;\r\nbreak;\r\ncase 1:\r\nutmp1 *= 1;\r\nbreak;\r\ncase 2:\r\nutmp1 *= 2;\r\nbreak;\r\ndefault:\r\nutmp1 *= 0;\r\nbreak;\r\n}\r\nret = regmap_read(dev->regmap, 0x80f903, &utmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((utmp >> 0) & 3) {\r\ncase 0:\r\nutmp1 = clamp(utmp1, 653799U, 1689999U);\r\nutmp1 = ((u64)(intlog10(utmp1)\r\n- intlog10(1690000 - utmp1)\r\n+ 3355443) * 13 * 1000) >> 24;\r\nbreak;\r\ncase 1:\r\nutmp1 = clamp(utmp1, 371105U, 827999U);\r\nutmp1 = ((u64)(intlog10(utmp1 - 370000)\r\n- intlog10(828000 - utmp1)\r\n+ 43900382) * 6 * 1000) >> 24;\r\nbreak;\r\ncase 2:\r\nutmp1 = clamp(utmp1, 193246U, 424999U);\r\nutmp1 = ((u64)(intlog10(utmp1 - 193000)\r\n- intlog10(425000 - utmp1)\r\n+ 49912218) * 8 * 1000) >> 24;\r\nbreak;\r\ndefault:\r\nutmp1 = 0;\r\nbreak;\r\n}\r\ndev_dbg(&client->dev, "cnr=%u\n", utmp1);\r\nc->cnr.stat[0].scale = FE_SCALE_DECIBEL;\r\nc->cnr.stat[0].svalue = utmp1;\r\n} else {\r\nc->cnr.stat[0].scale = FE_SCALE_NOT_AVAILABLE;\r\n}\r\nif (dev->fe_status & FE_HAS_LOCK) {\r\nu16 abort_packet_count, rsd_packet_count;\r\nu32 rsd_bit_err_count;\r\nret = regmap_bulk_read(dev->regmap, 0x800032, buf, 7);\r\nif (ret)\r\ngoto err;\r\nabort_packet_count = (buf[1] << 8) | (buf[0] << 0);\r\nrsd_bit_err_count = (buf[4] << 16) | (buf[3] << 8) | buf[2];\r\nrsd_packet_count = (buf[6] << 8) | (buf[5] << 0);\r\ndev->error_block_count += abort_packet_count;\r\ndev->total_block_count += rsd_packet_count;\r\ndev->post_bit_error += rsd_bit_err_count;\r\ndev->post_bit_count += rsd_packet_count * 204 * 8;\r\nc->block_count.len = 1;\r\nc->block_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_count.stat[0].uvalue = dev->total_block_count;\r\nc->block_error.len = 1;\r\nc->block_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->block_error.stat[0].uvalue = dev->error_block_count;\r\nc->post_bit_count.len = 1;\r\nc->post_bit_count.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_count.stat[0].uvalue = dev->post_bit_count;\r\nc->post_bit_error.len = 1;\r\nc->post_bit_error.stat[0].scale = FE_SCALE_COUNTER;\r\nc->post_bit_error.stat[0].uvalue = dev->post_bit_error;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_snr(struct dvb_frontend *fe, u16 *snr)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nint ret;\r\nunsigned int utmp;\r\ndev_dbg(&client->dev, "\n");\r\nif (c->cnr.stat[0].scale == FE_SCALE_DECIBEL) {\r\nif (dev->is_af9035) {\r\n*snr = div_s64(c->cnr.stat[0].svalue, 100);\r\n} else {\r\n*snr = div_s64(c->cnr.stat[0].svalue, 1000);\r\nret = regmap_read(dev->regmap, 0x80f903, &utmp);\r\nif (ret)\r\ngoto err;\r\nswitch ((utmp >> 0) & 3) {\r\ncase 0:\r\n*snr = *snr * 0xffff / 23;\r\nbreak;\r\ncase 1:\r\n*snr = *snr * 0xffff / 26;\r\nbreak;\r\ncase 2:\r\n*snr = *snr * 0xffff / 32;\r\nbreak;\r\ndefault:\r\ngoto err;\r\n}\r\n}\r\n} else {\r\n*snr = 0;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_signal_strength(struct dvb_frontend *fe, u16 *strength)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nstruct dtv_frontend_properties *c = &dev->fe.dtv_property_cache;\r\nint ret, tmp, power_real;\r\nunsigned int utmp;\r\nu8 gain_offset, buf[7];\r\ndev_dbg(&client->dev, "\n");\r\nif (dev->is_af9035) {\r\nret = regmap_read(dev->regmap, 0x800048, &utmp);\r\nif (ret)\r\ngoto err;\r\n*strength = utmp * 0xffff / 100;\r\n} else {\r\nret = regmap_read(dev->regmap, 0x8000f7, &utmp);\r\nif (ret)\r\ngoto err;\r\nret = regmap_bulk_read(dev->regmap, 0x80f900, buf, 7);\r\nif (ret)\r\ngoto err;\r\nif (c->frequency <= 300000000)\r\ngain_offset = 7;\r\nelse\r\ngain_offset = 4;\r\npower_real = (utmp - 100 - gain_offset) -\r\npower_reference[((buf[3] >> 0) & 3)][((buf[6] >> 0) & 7)];\r\nif (power_real < -15)\r\ntmp = 0;\r\nelse if ((power_real >= -15) && (power_real < 0))\r\ntmp = (2 * (power_real + 15)) / 3;\r\nelse if ((power_real >= 0) && (power_real < 20))\r\ntmp = 4 * power_real + 10;\r\nelse if ((power_real >= 20) && (power_real < 35))\r\ntmp = (2 * (power_real - 20)) / 3 + 90;\r\nelse\r\ntmp = 100;\r\n*strength = tmp * 0xffff / 100;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_read_ber(struct dvb_frontend *fe, u32 *ber)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\n*ber = (dev->post_bit_error - dev->post_bit_error_prev);\r\ndev->post_bit_error_prev = dev->post_bit_error;\r\nreturn 0;\r\n}\r\nstatic int af9033_read_ucblocks(struct dvb_frontend *fe, u32 *ucblocks)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\n*ucblocks = dev->error_block_count;\r\nreturn 0;\r\n}\r\nstatic int af9033_i2c_gate_ctrl(struct dvb_frontend *fe, int enable)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "enable=%d\n", enable);\r\nret = regmap_update_bits(dev->regmap, 0x00fa04, 0x01, enable);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_pid_filter_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\ndev_dbg(&client->dev, "onoff=%d\n", onoff);\r\nret = regmap_update_bits(dev->regmap, 0x80f993, 0x01, onoff);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_pid_filter(struct dvb_frontend *fe, int index, u16 pid,\r\nint onoff)\r\n{\r\nstruct af9033_dev *dev = fe->demodulator_priv;\r\nstruct i2c_client *client = dev->client;\r\nint ret;\r\nu8 wbuf[2] = {(pid >> 0) & 0xff, (pid >> 8) & 0xff};\r\ndev_dbg(&client->dev, "index=%d pid=%04x onoff=%d\n",\r\nindex, pid, onoff);\r\nif (pid > 0x1fff)\r\nreturn 0;\r\nret = regmap_bulk_write(dev->regmap, 0x80f996, wbuf, 2);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x80f994, onoff);\r\nif (ret)\r\ngoto err;\r\nret = regmap_write(dev->regmap, 0x80f995, index);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct af9033_config *cfg = client->dev.platform_data;\r\nstruct af9033_dev *dev;\r\nint ret;\r\nu8 buf[8];\r\nu32 reg;\r\nstatic const struct regmap_config regmap_config = {\r\n.reg_bits = 24,\r\n.val_bits = 8,\r\n};\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->client = client;\r\nmemcpy(&dev->cfg, cfg, sizeof(dev->cfg));\r\nswitch (dev->cfg.ts_mode) {\r\ncase AF9033_TS_MODE_PARALLEL:\r\ndev->ts_mode_parallel = true;\r\nbreak;\r\ncase AF9033_TS_MODE_SERIAL:\r\ndev->ts_mode_serial = true;\r\nbreak;\r\ncase AF9033_TS_MODE_USB:\r\ndefault:\r\nbreak;\r\n}\r\nif (dev->cfg.clock != 12000000) {\r\nret = -ENODEV;\r\ndev_err(&client->dev,\r\n"Unsupported clock %u Hz. Only 12000000 Hz is supported currently\n",\r\ndev->cfg.clock);\r\ngoto err_kfree;\r\n}\r\ndev->regmap = regmap_init_i2c(client, &regmap_config);\r\nif (IS_ERR(dev->regmap)) {\r\nret = PTR_ERR(dev->regmap);\r\ngoto err_kfree;\r\n}\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\ndev->is_it9135 = true;\r\nreg = 0x004bfc;\r\nbreak;\r\ndefault:\r\ndev->is_af9035 = true;\r\nreg = 0x0083e9;\r\nbreak;\r\n}\r\nret = regmap_bulk_read(dev->regmap, reg, &buf[0], 4);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nret = regmap_bulk_read(dev->regmap, 0x804191, &buf[4], 4);\r\nif (ret)\r\ngoto err_regmap_exit;\r\ndev_info(&client->dev,\r\n"firmware version: LINK %d.%d.%d.%d - OFDM %d.%d.%d.%d\n",\r\nbuf[0], buf[1], buf[2], buf[3],\r\nbuf[4], buf[5], buf[6], buf[7]);\r\nswitch (dev->cfg.tuner) {\r\ncase AF9033_TUNER_IT9135_38:\r\ncase AF9033_TUNER_IT9135_51:\r\ncase AF9033_TUNER_IT9135_52:\r\ncase AF9033_TUNER_IT9135_60:\r\ncase AF9033_TUNER_IT9135_61:\r\ncase AF9033_TUNER_IT9135_62:\r\nbreak;\r\ndefault:\r\nret = regmap_write(dev->regmap, 0x80004c, 0x01);\r\nif (ret)\r\ngoto err_regmap_exit;\r\nret = regmap_write(dev->regmap, 0x800000, 0x00);\r\nif (ret)\r\ngoto err_regmap_exit;\r\n}\r\nmemcpy(&dev->fe.ops, &af9033_ops, sizeof(dev->fe.ops));\r\ndev->fe.demodulator_priv = dev;\r\n*cfg->fe = &dev->fe;\r\nif (cfg->ops) {\r\ncfg->ops->pid_filter = af9033_pid_filter;\r\ncfg->ops->pid_filter_ctrl = af9033_pid_filter_ctrl;\r\n}\r\ncfg->regmap = dev->regmap;\r\ni2c_set_clientdata(client, dev);\r\ndev_info(&client->dev, "Afatech AF9033 successfully attached\n");\r\nreturn 0;\r\nerr_regmap_exit:\r\nregmap_exit(dev->regmap);\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&client->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int af9033_remove(struct i2c_client *client)\r\n{\r\nstruct af9033_dev *dev = i2c_get_clientdata(client);\r\ndev_dbg(&client->dev, "\n");\r\nregmap_exit(dev->regmap);\r\nkfree(dev);\r\nreturn 0;\r\n}
