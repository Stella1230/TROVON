static int mlx5e_dcbnl_set_dcbx_mode(struct mlx5e_priv *priv,\r\nenum mlx5_dcbx_oper_mode mode)\r\n{\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nu32 param[MLX5_ST_SZ_DW(dcbx_param)];\r\nint err;\r\nerr = mlx5_query_port_dcbx_param(mdev, param);\r\nif (err)\r\nreturn err;\r\nMLX5_SET(dcbx_param, param, version_admin, mode);\r\nif (mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)\r\nMLX5_SET(dcbx_param, param, willing_admin, 1);\r\nreturn mlx5_set_port_dcbx_param(mdev, param);\r\n}\r\nstatic int mlx5e_dcbnl_switch_to_host_mode(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_dcbx *dcbx = &priv->dcbx;\r\nint err;\r\nif (!MLX5_CAP_GEN(priv->mdev, dcbx))\r\nreturn 0;\r\nif (dcbx->mode == MLX5E_DCBX_PARAM_VER_OPER_HOST)\r\nreturn 0;\r\nerr = mlx5e_dcbnl_set_dcbx_mode(priv, MLX5E_DCBX_PARAM_VER_OPER_HOST);\r\nif (err)\r\nreturn err;\r\ndcbx->mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;\r\nreturn 0;\r\n}\r\nstatic int mlx5e_dcbnl_ieee_getets(struct net_device *netdev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nint err = 0;\r\nint i;\r\nif (!MLX5_CAP_GEN(priv->mdev, ets))\r\nreturn -EOPNOTSUPP;\r\nets->ets_cap = mlx5_max_tc(priv->mdev) + 1;\r\nfor (i = 0; i < ets->ets_cap; i++) {\r\nerr = mlx5_query_port_prio_tc(mdev, i, &ets->prio_tc[i]);\r\nif (err)\r\nreturn err;\r\n}\r\nfor (i = 0; i < ets->ets_cap; i++) {\r\nerr = mlx5_query_port_tc_bw_alloc(mdev, i, &ets->tc_tx_bw[i]);\r\nif (err)\r\nreturn err;\r\nif (ets->tc_tx_bw[i] < MLX5E_MAX_BW_ALLOC)\r\npriv->dcbx.tc_tsa[i] = IEEE_8021QAZ_TSA_ETS;\r\n}\r\nmemcpy(ets->tc_tsa, priv->dcbx.tc_tsa, sizeof(ets->tc_tsa));\r\nreturn err;\r\n}\r\nstatic void mlx5e_build_tc_group(struct ieee_ets *ets, u8 *tc_group, int max_tc)\r\n{\r\nbool any_tc_mapped_to_ets = false;\r\nint strict_group;\r\nint i;\r\nfor (i = 0; i <= max_tc; i++)\r\nif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS)\r\nany_tc_mapped_to_ets = true;\r\nstrict_group = any_tc_mapped_to_ets ? 1 : 0;\r\nfor (i = 0; i <= max_tc; i++) {\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_VENDOR:\r\ntc_group[i] = MLX5E_VENDOR_TC_GROUP_NUM;\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\ntc_group[i] = strict_group++;\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\ntc_group[i] = MLX5E_ETS_TC_GROUP_NUM;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic void mlx5e_build_tc_tx_bw(struct ieee_ets *ets, u8 *tc_tx_bw,\r\nu8 *tc_group, int max_tc)\r\n{\r\nint i;\r\nfor (i = 0; i <= max_tc; i++) {\r\nswitch (ets->tc_tsa[i]) {\r\ncase IEEE_8021QAZ_TSA_VENDOR:\r\ntc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_STRICT:\r\ntc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;\r\nbreak;\r\ncase IEEE_8021QAZ_TSA_ETS:\r\ntc_tx_bw[i] = ets->tc_tx_bw[i];\r\nbreak;\r\n}\r\n}\r\n}\r\nint mlx5e_dcbnl_ieee_setets_core(struct mlx5e_priv *priv, struct ieee_ets *ets)\r\n{\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nu8 tc_tx_bw[IEEE_8021QAZ_MAX_TCS];\r\nu8 tc_group[IEEE_8021QAZ_MAX_TCS];\r\nint max_tc = mlx5_max_tc(mdev);\r\nint err;\r\nmlx5e_build_tc_group(ets, tc_group, max_tc);\r\nmlx5e_build_tc_tx_bw(ets, tc_tx_bw, tc_group, max_tc);\r\nerr = mlx5_set_port_prio_tc(mdev, ets->prio_tc);\r\nif (err)\r\nreturn err;\r\nerr = mlx5_set_port_tc_group(mdev, tc_group);\r\nif (err)\r\nreturn err;\r\nerr = mlx5_set_port_tc_bw_alloc(mdev, tc_tx_bw);\r\nif (err)\r\nreturn err;\r\nmemcpy(priv->dcbx.tc_tsa, ets->tc_tsa, sizeof(ets->tc_tsa));\r\nreturn err;\r\n}\r\nstatic int mlx5e_dbcnl_validate_ets(struct net_device *netdev,\r\nstruct ieee_ets *ets)\r\n{\r\nint bw_sum = 0;\r\nint i;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nif (ets->prio_tc[i] >= MLX5E_MAX_PRIORITY) {\r\nnetdev_err(netdev,\r\n"Failed to validate ETS: priority value greater than max(%d)\n",\r\nMLX5E_MAX_PRIORITY);\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\nif (ets->tc_tsa[i] == IEEE_8021QAZ_TSA_ETS) {\r\nif (!ets->tc_tx_bw[i]) {\r\nnetdev_err(netdev,\r\n"Failed to validate ETS: BW 0 is illegal\n");\r\nreturn -EINVAL;\r\n}\r\nbw_sum += ets->tc_tx_bw[i];\r\n}\r\n}\r\nif (bw_sum != 0 && bw_sum != 100) {\r\nnetdev_err(netdev,\r\n"Failed to validate ETS: BW sum is illegal\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx5e_dcbnl_ieee_setets(struct net_device *netdev,\r\nstruct ieee_ets *ets)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nint err;\r\nif (!MLX5_CAP_GEN(priv->mdev, ets))\r\nreturn -EOPNOTSUPP;\r\nerr = mlx5e_dbcnl_validate_ets(netdev, ets);\r\nif (err)\r\nreturn err;\r\nerr = mlx5e_dcbnl_ieee_setets_core(priv, ets);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int mlx5e_dcbnl_ieee_getpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nstruct mlx5e_pport_stats *pstats = &priv->stats.pport;\r\nint i;\r\npfc->pfc_cap = mlx5_max_tc(mdev) + 1;\r\nfor (i = 0; i < IEEE_8021QAZ_MAX_TCS; i++) {\r\npfc->requests[i] = PPORT_PER_PRIO_GET(pstats, i, tx_pause);\r\npfc->indications[i] = PPORT_PER_PRIO_GET(pstats, i, rx_pause);\r\n}\r\nreturn mlx5_query_port_pfc(mdev, &pfc->pfc_en, NULL);\r\n}\r\nstatic int mlx5e_dcbnl_ieee_setpfc(struct net_device *dev,\r\nstruct ieee_pfc *pfc)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nu8 curr_pfc_en;\r\nint ret;\r\nmlx5_query_port_pfc(mdev, &curr_pfc_en, NULL);\r\nif (pfc->pfc_en == curr_pfc_en)\r\nreturn 0;\r\nret = mlx5_set_port_pfc(mdev, pfc->pfc_en, pfc->pfc_en);\r\nmlx5_toggle_port_link(mdev);\r\nreturn ret;\r\n}\r\nstatic u8 mlx5e_dcbnl_getdcbx(struct net_device *dev)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nstruct mlx5e_dcbx *dcbx = &priv->dcbx;\r\nu8 mode = DCB_CAP_DCBX_VER_IEEE | DCB_CAP_DCBX_VER_CEE;\r\nif (dcbx->mode == MLX5E_DCBX_PARAM_VER_OPER_HOST)\r\nmode |= DCB_CAP_DCBX_HOST;\r\nreturn mode;\r\n}\r\nstatic u8 mlx5e_dcbnl_setdcbx(struct net_device *dev, u8 mode)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(dev);\r\nstruct mlx5e_dcbx *dcbx = &priv->dcbx;\r\nif (mode & DCB_CAP_DCBX_LLD_MANAGED)\r\nreturn 1;\r\nif ((!mode) && MLX5_CAP_GEN(priv->mdev, dcbx)) {\r\nif (dcbx->mode == MLX5E_DCBX_PARAM_VER_OPER_AUTO)\r\nreturn 0;\r\nif (!mlx5e_dcbnl_set_dcbx_mode(priv, MLX5E_DCBX_PARAM_VER_OPER_AUTO)) {\r\ndcbx->mode = MLX5E_DCBX_PARAM_VER_OPER_AUTO;\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nif (!(mode & DCB_CAP_DCBX_HOST))\r\nreturn 1;\r\nif (mlx5e_dcbnl_switch_to_host_mode(netdev_priv(dev)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int mlx5e_dcbnl_ieee_getmaxrate(struct net_device *netdev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nu8 max_bw_value[IEEE_8021QAZ_MAX_TCS];\r\nu8 max_bw_unit[IEEE_8021QAZ_MAX_TCS];\r\nint err;\r\nint i;\r\nerr = mlx5_query_port_ets_rate_limit(mdev, max_bw_value, max_bw_unit);\r\nif (err)\r\nreturn err;\r\nmemset(maxrate->tc_maxrate, 0, sizeof(maxrate->tc_maxrate));\r\nfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\r\nswitch (max_bw_unit[i]) {\r\ncase MLX5_100_MBPS_UNIT:\r\nmaxrate->tc_maxrate[i] = max_bw_value[i] * MLX5E_100MB;\r\nbreak;\r\ncase MLX5_GBPS_UNIT:\r\nmaxrate->tc_maxrate[i] = max_bw_value[i] * MLX5E_1GB;\r\nbreak;\r\ncase MLX5_BW_NO_LIMIT:\r\nbreak;\r\ndefault:\r\nWARN(true, "non-supported BW unit");\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int mlx5e_dcbnl_ieee_setmaxrate(struct net_device *netdev,\r\nstruct ieee_maxrate *maxrate)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nu8 max_bw_value[IEEE_8021QAZ_MAX_TCS];\r\nu8 max_bw_unit[IEEE_8021QAZ_MAX_TCS];\r\n__u64 upper_limit_mbps = roundup(255 * MLX5E_100MB, MLX5E_1GB);\r\nint i;\r\nmemset(max_bw_value, 0, sizeof(max_bw_value));\r\nmemset(max_bw_unit, 0, sizeof(max_bw_unit));\r\nfor (i = 0; i <= mlx5_max_tc(mdev); i++) {\r\nif (!maxrate->tc_maxrate[i]) {\r\nmax_bw_unit[i] = MLX5_BW_NO_LIMIT;\r\ncontinue;\r\n}\r\nif (maxrate->tc_maxrate[i] < upper_limit_mbps) {\r\nmax_bw_value[i] = div_u64(maxrate->tc_maxrate[i],\r\nMLX5E_100MB);\r\nmax_bw_value[i] = max_bw_value[i] ? max_bw_value[i] : 1;\r\nmax_bw_unit[i] = MLX5_100_MBPS_UNIT;\r\n} else {\r\nmax_bw_value[i] = div_u64(maxrate->tc_maxrate[i],\r\nMLX5E_1GB);\r\nmax_bw_unit[i] = MLX5_GBPS_UNIT;\r\n}\r\n}\r\nreturn mlx5_modify_port_ets_rate_limit(mdev, max_bw_value, max_bw_unit);\r\n}\r\nstatic u8 mlx5e_dcbnl_setall(struct net_device *netdev)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nstruct ieee_ets ets;\r\nstruct ieee_pfc pfc;\r\nint err = -EOPNOTSUPP;\r\nint i;\r\nif (!MLX5_CAP_GEN(mdev, ets))\r\ngoto out;\r\nmemset(&ets, 0, sizeof(ets));\r\nmemset(&pfc, 0, sizeof(pfc));\r\nets.ets_cap = IEEE_8021QAZ_MAX_TCS;\r\nfor (i = 0; i < CEE_DCBX_MAX_PGS; i++) {\r\nets.tc_tx_bw[i] = cee_cfg->pg_bw_pct[i];\r\nets.tc_rx_bw[i] = cee_cfg->pg_bw_pct[i];\r\nets.tc_tsa[i] = IEEE_8021QAZ_TSA_ETS;\r\nets.prio_tc[i] = cee_cfg->prio_to_pg_map[i];\r\n}\r\nerr = mlx5e_dbcnl_validate_ets(netdev, &ets);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"%s, Failed to validate ETS: %d\n", __func__, err);\r\ngoto out;\r\n}\r\nerr = mlx5e_dcbnl_ieee_setets_core(priv, &ets);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"%s, Failed to set ETS: %d\n", __func__, err);\r\ngoto out;\r\n}\r\npfc.pfc_cap = mlx5_max_tc(mdev) + 1;\r\nif (!cee_cfg->pfc_enable)\r\npfc.pfc_en = 0;\r\nelse\r\nfor (i = 0; i < CEE_DCBX_MAX_PRIO; i++)\r\npfc.pfc_en |= cee_cfg->pfc_setting[i] << i;\r\nerr = mlx5e_dcbnl_ieee_setpfc(netdev, &pfc);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"%s, Failed to set PFC: %d\n", __func__, err);\r\ngoto out;\r\n}\r\nout:\r\nreturn err ? MLX5_DCB_NO_CHG : MLX5_DCB_CHG_RESET;\r\n}\r\nstatic u8 mlx5e_dcbnl_getstate(struct net_device *netdev)\r\n{\r\nreturn MLX5E_CEE_STATE_UP;\r\n}\r\nstatic void mlx5e_dcbnl_getpermhwaddr(struct net_device *netdev,\r\nu8 *perm_addr)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nif (!perm_addr)\r\nreturn;\r\nmlx5_query_nic_vport_mac_address(priv->mdev, 0, perm_addr);\r\n}\r\nstatic void mlx5e_dcbnl_setpgtccfgtx(struct net_device *netdev,\r\nint priority, u8 prio_type,\r\nu8 pgid, u8 bw_pct, u8 up_map)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\r\nif (priority >= CEE_DCBX_MAX_PRIO) {\r\nnetdev_err(netdev,\r\n"%s, priority is out of range\n", __func__);\r\nreturn;\r\n}\r\nif (pgid >= CEE_DCBX_MAX_PGS) {\r\nnetdev_err(netdev,\r\n"%s, priority group is out of range\n", __func__);\r\nreturn;\r\n}\r\ncee_cfg->prio_to_pg_map[priority] = pgid;\r\n}\r\nstatic void mlx5e_dcbnl_setpgbwgcfgtx(struct net_device *netdev,\r\nint pgid, u8 bw_pct)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\r\nif (pgid >= CEE_DCBX_MAX_PGS) {\r\nnetdev_err(netdev,\r\n"%s, priority group is out of range\n", __func__);\r\nreturn;\r\n}\r\ncee_cfg->pg_bw_pct[pgid] = bw_pct;\r\n}\r\nstatic void mlx5e_dcbnl_getpgtccfgtx(struct net_device *netdev,\r\nint priority, u8 *prio_type,\r\nu8 *pgid, u8 *bw_pct, u8 *up_map)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nif (!MLX5_CAP_GEN(priv->mdev, ets)) {\r\nnetdev_err(netdev, "%s, ets is not supported\n", __func__);\r\nreturn;\r\n}\r\nif (priority >= CEE_DCBX_MAX_PRIO) {\r\nnetdev_err(netdev,\r\n"%s, priority is out of range\n", __func__);\r\nreturn;\r\n}\r\n*prio_type = 0;\r\n*bw_pct = 0;\r\n*up_map = 0;\r\nif (mlx5_query_port_prio_tc(mdev, priority, pgid))\r\n*pgid = 0;\r\n}\r\nstatic void mlx5e_dcbnl_getpgbwgcfgtx(struct net_device *netdev,\r\nint pgid, u8 *bw_pct)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nif (pgid >= CEE_DCBX_MAX_PGS) {\r\nnetdev_err(netdev,\r\n"%s, priority group is out of range\n", __func__);\r\nreturn;\r\n}\r\nif (mlx5_query_port_tc_bw_alloc(mdev, pgid, bw_pct))\r\n*bw_pct = 0;\r\n}\r\nstatic void mlx5e_dcbnl_setpfccfg(struct net_device *netdev,\r\nint priority, u8 setting)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\r\nif (priority >= CEE_DCBX_MAX_PRIO) {\r\nnetdev_err(netdev,\r\n"%s, priority is out of range\n", __func__);\r\nreturn;\r\n}\r\nif (setting > 1)\r\nreturn;\r\ncee_cfg->pfc_setting[priority] = setting;\r\n}\r\nstatic int\r\nmlx5e_dcbnl_get_priority_pfc(struct net_device *netdev,\r\nint priority, u8 *setting)\r\n{\r\nstruct ieee_pfc pfc;\r\nint err;\r\nerr = mlx5e_dcbnl_ieee_getpfc(netdev, &pfc);\r\nif (err)\r\n*setting = 0;\r\nelse\r\n*setting = (pfc.pfc_en >> priority) & 0x01;\r\nreturn err;\r\n}\r\nstatic void mlx5e_dcbnl_getpfccfg(struct net_device *netdev,\r\nint priority, u8 *setting)\r\n{\r\nif (priority >= CEE_DCBX_MAX_PRIO) {\r\nnetdev_err(netdev,\r\n"%s, priority is out of range\n", __func__);\r\nreturn;\r\n}\r\nif (!setting)\r\nreturn;\r\nmlx5e_dcbnl_get_priority_pfc(netdev, priority, setting);\r\n}\r\nstatic u8 mlx5e_dcbnl_getcap(struct net_device *netdev,\r\nint capid, u8 *cap)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nu8 rval = 0;\r\nswitch (capid) {\r\ncase DCB_CAP_ATTR_PG:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC:\r\n*cap = true;\r\nbreak;\r\ncase DCB_CAP_ATTR_UP2TC:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_PG_TCS:\r\n*cap = 1 << mlx5_max_tc(mdev);\r\nbreak;\r\ncase DCB_CAP_ATTR_PFC_TCS:\r\n*cap = 1 << mlx5_max_tc(mdev);\r\nbreak;\r\ncase DCB_CAP_ATTR_GSP:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_BCN:\r\n*cap = false;\r\nbreak;\r\ncase DCB_CAP_ATTR_DCBX:\r\n*cap = (DCB_CAP_DCBX_LLD_MANAGED |\r\nDCB_CAP_DCBX_VER_CEE |\r\nDCB_CAP_DCBX_STATIC);\r\nbreak;\r\ndefault:\r\n*cap = 0;\r\nrval = 1;\r\nbreak;\r\n}\r\nreturn rval;\r\n}\r\nstatic int mlx5e_dcbnl_getnumtcs(struct net_device *netdev,\r\nint tcs_id, u8 *num)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5_core_dev *mdev = priv->mdev;\r\nswitch (tcs_id) {\r\ncase DCB_NUMTCS_ATTR_PG:\r\ncase DCB_NUMTCS_ATTR_PFC:\r\n*num = mlx5_max_tc(mdev) + 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic u8 mlx5e_dcbnl_getpfcstate(struct net_device *netdev)\r\n{\r\nstruct ieee_pfc pfc;\r\nif (mlx5e_dcbnl_ieee_getpfc(netdev, &pfc))\r\nreturn MLX5E_CEE_STATE_DOWN;\r\nreturn pfc.pfc_en ? MLX5E_CEE_STATE_UP : MLX5E_CEE_STATE_DOWN;\r\n}\r\nstatic void mlx5e_dcbnl_setpfcstate(struct net_device *netdev, u8 state)\r\n{\r\nstruct mlx5e_priv *priv = netdev_priv(netdev);\r\nstruct mlx5e_cee_config *cee_cfg = &priv->dcbx.cee_cfg;\r\nif ((state != MLX5E_CEE_STATE_UP) && (state != MLX5E_CEE_STATE_DOWN))\r\nreturn;\r\ncee_cfg->pfc_enable = state;\r\n}\r\nstatic void mlx5e_dcbnl_query_dcbx_mode(struct mlx5e_priv *priv,\r\nenum mlx5_dcbx_oper_mode *mode)\r\n{\r\nu32 out[MLX5_ST_SZ_DW(dcbx_param)];\r\n*mode = MLX5E_DCBX_PARAM_VER_OPER_HOST;\r\nif (!mlx5_query_port_dcbx_param(priv->mdev, out))\r\n*mode = MLX5_GET(dcbx_param, out, version_oper);\r\nif (*mode != MLX5E_DCBX_PARAM_VER_OPER_HOST)\r\n*mode = MLX5E_DCBX_PARAM_VER_OPER_AUTO;\r\n}\r\nstatic void mlx5e_ets_init(struct mlx5e_priv *priv)\r\n{\r\nint i;\r\nstruct ieee_ets ets;\r\nif (!MLX5_CAP_GEN(priv->mdev, ets))\r\nreturn;\r\nmemset(&ets, 0, sizeof(ets));\r\nets.ets_cap = mlx5_max_tc(priv->mdev) + 1;\r\nfor (i = 0; i < ets.ets_cap; i++) {\r\nets.tc_tx_bw[i] = MLX5E_MAX_BW_ALLOC;\r\nets.tc_tsa[i] = IEEE_8021QAZ_TSA_VENDOR;\r\nets.prio_tc[i] = i;\r\n}\r\nmemcpy(priv->dcbx.tc_tsa, ets.tc_tsa, sizeof(ets.tc_tsa));\r\nets.prio_tc[0] = 1;\r\nets.prio_tc[1] = 0;\r\nmlx5e_dcbnl_ieee_setets_core(priv, &ets);\r\n}\r\nvoid mlx5e_dcbnl_initialize(struct mlx5e_priv *priv)\r\n{\r\nstruct mlx5e_dcbx *dcbx = &priv->dcbx;\r\nif (MLX5_CAP_GEN(priv->mdev, dcbx))\r\nmlx5e_dcbnl_query_dcbx_mode(priv, &dcbx->mode);\r\nmlx5e_ets_init(priv);\r\n}
