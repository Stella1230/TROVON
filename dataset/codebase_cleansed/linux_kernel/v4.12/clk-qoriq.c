static void cg_out(struct clockgen *cg, u32 val, u32 __iomem *reg)\r\n{\r\nif (cg->info.flags & CG_LITTLE_ENDIAN)\r\niowrite32(val, reg);\r\nelse\r\niowrite32be(val, reg);\r\n}\r\nstatic u32 cg_in(struct clockgen *cg, u32 __iomem *reg)\r\n{\r\nu32 val;\r\nif (cg->info.flags & CG_LITTLE_ENDIAN)\r\nval = ioread32(reg);\r\nelse\r\nval = ioread32be(reg);\r\nreturn val;\r\n}\r\nstatic void __init p2041_init_periph(struct clockgen *cg)\r\n{\r\nu32 reg;\r\nreg = ioread32be(&cg->guts->rcwsr[7]);\r\nif (reg & RCWSR7_FM1_CLK_SEL)\r\ncg->fman[0] = cg->pll[CGA_PLL2].div[PLL_DIV2].clk;\r\nelse\r\ncg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\r\n}\r\nstatic void __init p4080_init_periph(struct clockgen *cg)\r\n{\r\nu32 reg;\r\nreg = ioread32be(&cg->guts->rcwsr[7]);\r\nif (reg & RCWSR7_FM1_CLK_SEL)\r\ncg->fman[0] = cg->pll[CGA_PLL3].div[PLL_DIV2].clk;\r\nelse\r\ncg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\r\nif (reg & RCWSR7_FM2_CLK_SEL)\r\ncg->fman[1] = cg->pll[CGA_PLL3].div[PLL_DIV2].clk;\r\nelse\r\ncg->fman[1] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\r\n}\r\nstatic void __init p5020_init_periph(struct clockgen *cg)\r\n{\r\nu32 reg;\r\nint div = PLL_DIV2;\r\nreg = ioread32be(&cg->guts->rcwsr[7]);\r\nif (reg & RCWSR7_HWA_ASYNC_DIV)\r\ndiv = PLL_DIV4;\r\nif (reg & RCWSR7_FM1_CLK_SEL)\r\ncg->fman[0] = cg->pll[CGA_PLL2].div[div].clk;\r\nelse\r\ncg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\r\n}\r\nstatic void __init p5040_init_periph(struct clockgen *cg)\r\n{\r\nu32 reg;\r\nint div = PLL_DIV2;\r\nreg = ioread32be(&cg->guts->rcwsr[7]);\r\nif (reg & RCWSR7_HWA_ASYNC_DIV)\r\ndiv = PLL_DIV4;\r\nif (reg & RCWSR7_FM1_CLK_SEL)\r\ncg->fman[0] = cg->pll[CGA_PLL3].div[div].clk;\r\nelse\r\ncg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\r\nif (reg & RCWSR7_FM2_CLK_SEL)\r\ncg->fman[1] = cg->pll[CGA_PLL3].div[div].clk;\r\nelse\r\ncg->fman[1] = cg->pll[PLATFORM_PLL].div[PLL_DIV2].clk;\r\n}\r\nstatic void __init t1023_init_periph(struct clockgen *cg)\r\n{\r\ncg->fman[0] = cg->hwaccel[1];\r\n}\r\nstatic void __init t1040_init_periph(struct clockgen *cg)\r\n{\r\ncg->fman[0] = cg->pll[PLATFORM_PLL].div[PLL_DIV1].clk;\r\n}\r\nstatic void __init t2080_init_periph(struct clockgen *cg)\r\n{\r\ncg->fman[0] = cg->hwaccel[0];\r\n}\r\nstatic void __init t4240_init_periph(struct clockgen *cg)\r\n{\r\ncg->fman[0] = cg->hwaccel[3];\r\ncg->fman[1] = cg->hwaccel[4];\r\n}\r\nstatic int mux_set_parent(struct clk_hw *hw, u8 idx)\r\n{\r\nstruct mux_hwclock *hwc = to_mux_hwclock(hw);\r\nu32 clksel;\r\nif (idx >= hwc->num_parents)\r\nreturn -EINVAL;\r\nclksel = hwc->parent_to_clksel[idx];\r\ncg_out(hwc->cg, (clksel << CLKSEL_SHIFT) & CLKSEL_MASK, hwc->reg);\r\nreturn 0;\r\n}\r\nstatic u8 mux_get_parent(struct clk_hw *hw)\r\n{\r\nstruct mux_hwclock *hwc = to_mux_hwclock(hw);\r\nu32 clksel;\r\ns8 ret;\r\nclksel = (cg_in(hwc->cg, hwc->reg) & CLKSEL_MASK) >> CLKSEL_SHIFT;\r\nret = hwc->clksel_to_parent[clksel];\r\nif (ret < 0) {\r\npr_err("%s: mux at %p has bad clksel\n", __func__, hwc->reg);\r\nreturn 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic const struct clockgen_pll_div *get_pll_div(struct clockgen *cg,\r\nstruct mux_hwclock *hwc,\r\nint idx)\r\n{\r\nint pll, div;\r\nif (!(hwc->info->clksel[idx].flags & CLKSEL_VALID))\r\nreturn NULL;\r\npll = hwc->info->clksel[idx].pll;\r\ndiv = hwc->info->clksel[idx].div;\r\nreturn &cg->pll[pll].div[div];\r\n}\r\nstatic struct clk * __init create_mux_common(struct clockgen *cg,\r\nstruct mux_hwclock *hwc,\r\nconst struct clk_ops *ops,\r\nunsigned long min_rate,\r\nunsigned long max_rate,\r\nunsigned long pct80_rate,\r\nconst char *fmt, int idx)\r\n{\r\nstruct clk_init_data init = {};\r\nstruct clk *clk;\r\nconst struct clockgen_pll_div *div;\r\nconst char *parent_names[NUM_MUX_PARENTS];\r\nchar name[32];\r\nint i, j;\r\nsnprintf(name, sizeof(name), fmt, idx);\r\nfor (i = 0, j = 0; i < NUM_MUX_PARENTS; i++) {\r\nunsigned long rate;\r\nhwc->clksel_to_parent[i] = -1;\r\ndiv = get_pll_div(cg, hwc, i);\r\nif (!div)\r\ncontinue;\r\nrate = clk_get_rate(div->clk);\r\nif (hwc->info->clksel[i].flags & CLKSEL_80PCT &&\r\nrate > pct80_rate)\r\ncontinue;\r\nif (rate < min_rate)\r\ncontinue;\r\nif (rate > max_rate)\r\ncontinue;\r\nparent_names[j] = div->name;\r\nhwc->parent_to_clksel[j] = i;\r\nhwc->clksel_to_parent[i] = j;\r\nj++;\r\n}\r\ninit.name = name;\r\ninit.ops = ops;\r\ninit.parent_names = parent_names;\r\ninit.num_parents = hwc->num_parents = j;\r\ninit.flags = 0;\r\nhwc->hw.init = &init;\r\nhwc->cg = cg;\r\nclk = clk_register(NULL, &hwc->hw);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: Couldn't register %s: %ld\n", __func__, name,\r\nPTR_ERR(clk));\r\nkfree(hwc);\r\nreturn NULL;\r\n}\r\nreturn clk;\r\n}\r\nstatic struct clk * __init create_one_cmux(struct clockgen *cg, int idx)\r\n{\r\nstruct mux_hwclock *hwc;\r\nconst struct clockgen_pll_div *div;\r\nunsigned long plat_rate, min_rate;\r\nu64 max_rate, pct80_rate;\r\nu32 clksel;\r\nhwc = kzalloc(sizeof(*hwc), GFP_KERNEL);\r\nif (!hwc)\r\nreturn NULL;\r\nif (cg->info.flags & CG_VER3)\r\nhwc->reg = cg->regs + 0x70000 + 0x20 * idx;\r\nelse\r\nhwc->reg = cg->regs + 0x20 * idx;\r\nhwc->info = cg->info.cmux_groups[cg->info.cmux_to_group[idx]];\r\nclksel = (cg_in(cg, hwc->reg) & CLKSEL_MASK) >> CLKSEL_SHIFT;\r\ndiv = get_pll_div(cg, hwc, clksel);\r\nif (!div) {\r\nkfree(hwc);\r\nreturn NULL;\r\n}\r\nmax_rate = clk_get_rate(div->clk);\r\npct80_rate = max_rate * 8;\r\ndo_div(pct80_rate, 10);\r\nplat_rate = clk_get_rate(cg->pll[PLATFORM_PLL].div[PLL_DIV1].clk);\r\nif (cg->info.flags & CG_CMUX_GE_PLAT)\r\nmin_rate = plat_rate;\r\nelse\r\nmin_rate = plat_rate / 2;\r\nreturn create_mux_common(cg, hwc, &cmux_ops, min_rate, max_rate,\r\npct80_rate, "cg-cmux%d", idx);\r\n}\r\nstatic struct clk * __init create_one_hwaccel(struct clockgen *cg, int idx)\r\n{\r\nstruct mux_hwclock *hwc;\r\nhwc = kzalloc(sizeof(*hwc), GFP_KERNEL);\r\nif (!hwc)\r\nreturn NULL;\r\nhwc->reg = cg->regs + 0x20 * idx + 0x10;\r\nhwc->info = cg->info.hwaccel[idx];\r\nreturn create_mux_common(cg, hwc, &hwaccel_ops, 0, ULONG_MAX, 0,\r\n"cg-hwaccel%d", idx);\r\n}\r\nstatic void __init create_muxes(struct clockgen *cg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cg->cmux); i++) {\r\nif (cg->info.cmux_to_group[i] < 0)\r\nbreak;\r\nif (cg->info.cmux_to_group[i] >=\r\nARRAY_SIZE(cg->info.cmux_groups)) {\r\nWARN_ON_ONCE(1);\r\ncontinue;\r\n}\r\ncg->cmux[i] = create_one_cmux(cg, i);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(cg->hwaccel); i++) {\r\nif (!cg->info.hwaccel[i])\r\ncontinue;\r\ncg->hwaccel[i] = create_one_hwaccel(cg, i);\r\n}\r\n}\r\nstatic void __init legacy_init_clockgen(struct device_node *np)\r\n{\r\nif (!clockgen.node)\r\nclockgen_init(of_get_parent(np));\r\n}\r\nstatic void __init core_mux_init(struct device_node *np)\r\n{\r\nstruct clk *clk;\r\nstruct resource res;\r\nint idx, rc;\r\nlegacy_init_clockgen(np);\r\nif (of_address_to_resource(np, 0, &res))\r\nreturn;\r\nidx = (res.start & 0xf0) >> 5;\r\nclk = clockgen.cmux[idx];\r\nrc = of_clk_add_provider(np, of_clk_src_simple_get, clk);\r\nif (rc) {\r\npr_err("%s: Couldn't register clk provider for node %s: %d\n",\r\n__func__, np->name, rc);\r\nreturn;\r\n}\r\n}\r\nstatic struct clk __init\r\n*sysclk_from_fixed(struct device_node *node, const char *name)\r\n{\r\nu32 rate;\r\nif (of_property_read_u32(node, "clock-frequency", &rate))\r\nreturn ERR_PTR(-ENODEV);\r\nreturn clk_register_fixed_rate(NULL, name, NULL, 0, rate);\r\n}\r\nstatic struct clk *sysclk_from_parent(const char *name)\r\n{\r\nstruct clk *clk;\r\nconst char *parent_name;\r\nclk = of_clk_get(clockgen.node, 0);\r\nif (IS_ERR(clk))\r\nreturn clk;\r\nparent_name = __clk_get_name(clk);\r\nclk = clk_register_fixed_factor(NULL, name, parent_name,\r\n0, 1, 1);\r\nif (IS_ERR(clk))\r\npr_err("%s: Couldn't register %s: %ld\n", __func__, name,\r\nPTR_ERR(clk));\r\nreturn clk;\r\n}\r\nstatic struct clk * __init create_sysclk(const char *name)\r\n{\r\nstruct device_node *sysclk;\r\nstruct clk *clk;\r\nclk = sysclk_from_fixed(clockgen.node, name);\r\nif (!IS_ERR(clk))\r\nreturn clk;\r\nclk = sysclk_from_parent(name);\r\nif (!IS_ERR(clk))\r\nreturn clk;\r\nsysclk = of_get_child_by_name(clockgen.node, "sysclk");\r\nif (sysclk) {\r\nclk = sysclk_from_fixed(sysclk, name);\r\nif (!IS_ERR(clk))\r\nreturn clk;\r\n}\r\npr_err("%s: No input clock\n", __func__);\r\nreturn NULL;\r\n}\r\nstatic void __init sysclk_init(struct device_node *node)\r\n{\r\nstruct clk *clk;\r\nlegacy_init_clockgen(node);\r\nclk = clockgen.sysclk;\r\nif (clk)\r\nof_clk_add_provider(node, of_clk_src_simple_get, clk);\r\n}\r\nstatic void __init create_one_pll(struct clockgen *cg, int idx)\r\n{\r\nu32 __iomem *reg;\r\nu32 mult;\r\nstruct clockgen_pll *pll = &cg->pll[idx];\r\nint i;\r\nif (!(cg->info.pll_mask & (1 << idx)))\r\nreturn;\r\nif (cg->info.flags & CG_VER3) {\r\nswitch (idx) {\r\ncase PLATFORM_PLL:\r\nreg = cg->regs + 0x60080;\r\nbreak;\r\ncase CGA_PLL1:\r\nreg = cg->regs + 0x80;\r\nbreak;\r\ncase CGA_PLL2:\r\nreg = cg->regs + 0xa0;\r\nbreak;\r\ncase CGB_PLL1:\r\nreg = cg->regs + 0x10080;\r\nbreak;\r\ncase CGB_PLL2:\r\nreg = cg->regs + 0x100a0;\r\nbreak;\r\ndefault:\r\nWARN_ONCE(1, "index %d\n", idx);\r\nreturn;\r\n}\r\n} else {\r\nif (idx == PLATFORM_PLL)\r\nreg = cg->regs + 0xc00;\r\nelse\r\nreg = cg->regs + 0x800 + 0x20 * (idx - 1);\r\n}\r\nmult = cg_in(cg, reg);\r\nif (mult & PLL_KILL) {\r\npr_debug("%s(): pll %p disabled\n", __func__, reg);\r\nreturn;\r\n}\r\nif ((cg->info.flags & CG_VER3) ||\r\n((cg->info.flags & CG_PLL_8BIT) && idx != PLATFORM_PLL))\r\nmult = (mult & GENMASK(8, 1)) >> 1;\r\nelse\r\nmult = (mult & GENMASK(6, 1)) >> 1;\r\nfor (i = 0; i < ARRAY_SIZE(pll->div); i++) {\r\nstruct clk *clk;\r\nsnprintf(pll->div[i].name, sizeof(pll->div[i].name),\r\n"cg-pll%d-div%d", idx, i + 1);\r\nclk = clk_register_fixed_factor(NULL,\r\npll->div[i].name, "cg-sysclk", 0, mult, i + 1);\r\nif (IS_ERR(clk)) {\r\npr_err("%s: %s: register failed %ld\n",\r\n__func__, pll->div[i].name, PTR_ERR(clk));\r\ncontinue;\r\n}\r\npll->div[i].clk = clk;\r\n}\r\n}\r\nstatic void __init create_plls(struct clockgen *cg)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(cg->pll); i++)\r\ncreate_one_pll(cg, i);\r\n}\r\nstatic void __init legacy_pll_init(struct device_node *np, int idx)\r\n{\r\nstruct clockgen_pll *pll;\r\nstruct clk_onecell_data *onecell_data;\r\nstruct clk **subclks;\r\nint count, rc;\r\nlegacy_init_clockgen(np);\r\npll = &clockgen.pll[idx];\r\ncount = of_property_count_strings(np, "clock-output-names");\r\nBUILD_BUG_ON(ARRAY_SIZE(pll->div) < 4);\r\nsubclks = kcalloc(4, sizeof(struct clk *), GFP_KERNEL);\r\nif (!subclks)\r\nreturn;\r\nonecell_data = kmalloc(sizeof(*onecell_data), GFP_KERNEL);\r\nif (!onecell_data)\r\ngoto err_clks;\r\nif (count <= 3) {\r\nsubclks[0] = pll->div[0].clk;\r\nsubclks[1] = pll->div[1].clk;\r\nsubclks[2] = pll->div[3].clk;\r\n} else {\r\nsubclks[0] = pll->div[0].clk;\r\nsubclks[1] = pll->div[1].clk;\r\nsubclks[2] = pll->div[2].clk;\r\nsubclks[3] = pll->div[3].clk;\r\n}\r\nonecell_data->clks = subclks;\r\nonecell_data->clk_num = count;\r\nrc = of_clk_add_provider(np, of_clk_src_onecell_get, onecell_data);\r\nif (rc) {\r\npr_err("%s: Couldn't register clk provider for node %s: %d\n",\r\n__func__, np->name, rc);\r\ngoto err_cell;\r\n}\r\nreturn;\r\nerr_cell:\r\nkfree(onecell_data);\r\nerr_clks:\r\nkfree(subclks);\r\n}\r\nstatic void __init pltfrm_pll_init(struct device_node *np)\r\n{\r\nlegacy_pll_init(np, PLATFORM_PLL);\r\n}\r\nstatic void __init core_pll_init(struct device_node *np)\r\n{\r\nstruct resource res;\r\nint idx;\r\nif (of_address_to_resource(np, 0, &res))\r\nreturn;\r\nif ((res.start & 0xfff) == 0xc00) {\r\npltfrm_pll_init(np);\r\n} else {\r\nidx = (res.start & 0xf0) >> 5;\r\nlegacy_pll_init(np, CGA_PLL1 + idx);\r\n}\r\n}\r\nstatic struct clk *clockgen_clk_get(struct of_phandle_args *clkspec, void *data)\r\n{\r\nstruct clockgen *cg = data;\r\nstruct clk *clk;\r\nstruct clockgen_pll *pll;\r\nu32 type, idx;\r\nif (clkspec->args_count < 2) {\r\npr_err("%s: insufficient phandle args\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\ntype = clkspec->args[0];\r\nidx = clkspec->args[1];\r\nswitch (type) {\r\ncase 0:\r\nif (idx != 0)\r\ngoto bad_args;\r\nclk = cg->sysclk;\r\nbreak;\r\ncase 1:\r\nif (idx >= ARRAY_SIZE(cg->cmux))\r\ngoto bad_args;\r\nclk = cg->cmux[idx];\r\nbreak;\r\ncase 2:\r\nif (idx >= ARRAY_SIZE(cg->hwaccel))\r\ngoto bad_args;\r\nclk = cg->hwaccel[idx];\r\nbreak;\r\ncase 3:\r\nif (idx >= ARRAY_SIZE(cg->fman))\r\ngoto bad_args;\r\nclk = cg->fman[idx];\r\nbreak;\r\ncase 4:\r\npll = &cg->pll[PLATFORM_PLL];\r\nif (idx >= ARRAY_SIZE(pll->div))\r\ngoto bad_args;\r\nclk = pll->div[idx].clk;\r\nbreak;\r\ndefault:\r\ngoto bad_args;\r\n}\r\nif (!clk)\r\nreturn ERR_PTR(-ENOENT);\r\nreturn clk;\r\nbad_args:\r\npr_err("%s: Bad phandle args %u %u\n", __func__, type, idx);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nstatic bool __init has_erratum_a4510(void)\r\n{\r\nu32 svr = mfspr(SPRN_SVR);\r\nint i;\r\nsvr &= ~SVR_SECURITY;\r\nfor (i = 0; i < ARRAY_SIZE(a4510_svrs); i++) {\r\nif (svr == a4510_svrs[i])\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool __init has_erratum_a4510(void)\r\n{\r\nreturn false;\r\n}\r\nstatic void __init clockgen_init(struct device_node *np)\r\n{\r\nint i, ret;\r\nbool is_old_ls1021a = false;\r\nif (clockgen.node)\r\nreturn;\r\nclockgen.node = np;\r\nclockgen.regs = of_iomap(np, 0);\r\nif (!clockgen.regs &&\r\nof_device_is_compatible(of_root, "fsl,ls1021a")) {\r\nclockgen.regs = ioremap(0x1ee1000, 0x1000);\r\nis_old_ls1021a = true;\r\n}\r\nif (!clockgen.regs) {\r\npr_err("%s(): %s: of_iomap() failed\n", __func__, np->name);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(chipinfo); i++) {\r\nif (of_device_is_compatible(np, chipinfo[i].compat))\r\nbreak;\r\nif (is_old_ls1021a &&\r\n!strcmp(chipinfo[i].compat, "fsl,ls1021a-clockgen"))\r\nbreak;\r\n}\r\nif (i == ARRAY_SIZE(chipinfo)) {\r\npr_err("%s: unknown clockgen node %s\n", __func__,\r\nnp->full_name);\r\ngoto err;\r\n}\r\nclockgen.info = chipinfo[i];\r\nif (clockgen.info.guts_compat) {\r\nstruct device_node *guts;\r\nguts = of_find_compatible_node(NULL, NULL,\r\nclockgen.info.guts_compat);\r\nif (guts) {\r\nclockgen.guts = of_iomap(guts, 0);\r\nif (!clockgen.guts) {\r\npr_err("%s: Couldn't map %s regs\n", __func__,\r\nguts->full_name);\r\n}\r\n}\r\n}\r\nif (has_erratum_a4510())\r\nclockgen.info.flags |= CG_CMUX_GE_PLAT;\r\nclockgen.sysclk = create_sysclk("cg-sysclk");\r\ncreate_plls(&clockgen);\r\ncreate_muxes(&clockgen);\r\nif (clockgen.info.init_periph)\r\nclockgen.info.init_periph(&clockgen);\r\nret = of_clk_add_provider(np, clockgen_clk_get, &clockgen);\r\nif (ret) {\r\npr_err("%s: Couldn't register clk provider for node %s: %d\n",\r\n__func__, np->name, ret);\r\n}\r\nreturn;\r\nerr:\r\niounmap(clockgen.regs);\r\nclockgen.regs = NULL;\r\n}
