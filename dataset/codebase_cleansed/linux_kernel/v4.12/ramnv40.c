static int\r\nnv40_ram_calc(struct nvkm_ram *base, u32 freq)\r\n{\r\nstruct nv40_ram *ram = nv40_ram(base);\r\nstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\r\nstruct nvkm_bios *bios = subdev->device->bios;\r\nstruct nvbios_pll pll;\r\nint N1, M1, N2, M2;\r\nint log2P, ret;\r\nret = nvbios_pll_parse(bios, 0x04, &pll);\r\nif (ret) {\r\nnvkm_error(subdev, "mclk pll data not found\n");\r\nreturn ret;\r\n}\r\nret = nv04_pll_calc(subdev, &pll, freq, &N1, &M1, &N2, &M2, &log2P);\r\nif (ret < 0)\r\nreturn ret;\r\nram->ctrl = 0x80000000 | (log2P << 16);\r\nram->ctrl |= min(pll.bias_p + log2P, (int)pll.max_p) << 20;\r\nif (N2 == M2) {\r\nram->ctrl |= 0x00000100;\r\nram->coef = (N1 << 8) | M1;\r\n} else {\r\nram->ctrl |= 0x40000000;\r\nram->coef = (N2 << 24) | (M2 << 16) | (N1 << 8) | M1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nnv40_ram_prog(struct nvkm_ram *base)\r\n{\r\nstruct nv40_ram *ram = nv40_ram(base);\r\nstruct nvkm_subdev *subdev = &ram->base.fb->subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_bios *bios = device->bios;\r\nstruct bit_entry M;\r\nu32 crtc_mask = 0;\r\nu8 sr1[2];\r\nint i;\r\nfor (i = 0; i < 2; i++) {\r\nu32 vbl = nvkm_rd32(device, 0x600808 + (i * 0x2000));\r\nu32 cnt = 0;\r\ndo {\r\nif (vbl != nvkm_rd32(device, 0x600808 + (i * 0x2000))) {\r\nnvkm_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\r\nsr1[i] = nvkm_rd08(device, 0x0c03c5 + (i * 0x2000));\r\nif (!(sr1[i] & 0x20))\r\ncrtc_mask |= (1 << i);\r\nbreak;\r\n}\r\nudelay(1);\r\n} while (cnt++ < 32);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (!(crtc_mask & (1 << i)))\r\ncontinue;\r\nnvkm_msec(device, 2000,\r\nu32 tmp = nvkm_rd32(device, 0x600808 + (i * 0x2000));\r\nif (!(tmp & 0x00010000))\r\nbreak;\r\n);\r\nnvkm_msec(device, 2000,\r\nu32 tmp = nvkm_rd32(device, 0x600808 + (i * 0x2000));\r\nif ( (tmp & 0x00010000))\r\nbreak;\r\n);\r\nnvkm_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\r\nnvkm_wr08(device, 0x0c03c5 + (i * 0x2000), sr1[i] | 0x20);\r\n}\r\nnvkm_wr32(device, 0x1002d4, 0x00000001);\r\nnvkm_wr32(device, 0x1002d0, 0x00000001);\r\nnvkm_wr32(device, 0x1002d0, 0x00000001);\r\nnvkm_mask(device, 0x100210, 0x80000000, 0x00000000);\r\nnvkm_wr32(device, 0x1002dc, 0x00000001);\r\nnvkm_mask(device, 0x00c040, 0x0000c000, 0x00000000);\r\nswitch (device->chipset) {\r\ncase 0x40:\r\ncase 0x45:\r\ncase 0x41:\r\ncase 0x42:\r\ncase 0x47:\r\nnvkm_mask(device, 0x004044, 0xc0771100, ram->ctrl);\r\nnvkm_mask(device, 0x00402c, 0xc0771100, ram->ctrl);\r\nnvkm_wr32(device, 0x004048, ram->coef);\r\nnvkm_wr32(device, 0x004030, ram->coef);\r\ncase 0x43:\r\ncase 0x49:\r\ncase 0x4b:\r\nnvkm_mask(device, 0x004038, 0xc0771100, ram->ctrl);\r\nnvkm_wr32(device, 0x00403c, ram->coef);\r\ndefault:\r\nnvkm_mask(device, 0x004020, 0xc0771100, ram->ctrl);\r\nnvkm_wr32(device, 0x004024, ram->coef);\r\nbreak;\r\n}\r\nudelay(100);\r\nnvkm_mask(device, 0x00c040, 0x0000c000, 0x0000c000);\r\nnvkm_wr32(device, 0x1002dc, 0x00000000);\r\nnvkm_mask(device, 0x100210, 0x80000000, 0x80000000);\r\nudelay(100);\r\nif (!bit_entry(bios, 'M', &M)) {\r\nstruct nvbios_init init = {\r\n.subdev = subdev,\r\n.bios = bios,\r\n.offset = nvbios_rd16(bios, M.offset + 0x00),\r\n.execute = 1,\r\n};\r\nnvbios_exec(&init);\r\n}\r\nfor (i = 0; i < 2; i++) {\r\nif (!(crtc_mask & (1 << i)))\r\ncontinue;\r\nnvkm_msec(device, 2000,\r\nu32 tmp = nvkm_rd32(device, 0x600808 + (i * 0x2000));\r\nif ( (tmp & 0x00010000))\r\nbreak;\r\n);\r\nnvkm_wr08(device, 0x0c03c4 + (i * 0x2000), 0x01);\r\nnvkm_wr08(device, 0x0c03c5 + (i * 0x2000), sr1[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nnv40_ram_tidy(struct nvkm_ram *base)\r\n{\r\n}\r\nint\r\nnv40_ram_new_(struct nvkm_fb *fb, enum nvkm_ram_type type, u64 size,\r\nu32 tags, struct nvkm_ram **pram)\r\n{\r\nstruct nv40_ram *ram;\r\nif (!(ram = kzalloc(sizeof(*ram), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pram = &ram->base;\r\nreturn nvkm_ram_ctor(&nv40_ram_func, fb, type, size, tags, &ram->base);\r\n}\r\nint\r\nnv40_ram_new(struct nvkm_fb *fb, struct nvkm_ram **pram)\r\n{\r\nstruct nvkm_device *device = fb->subdev.device;\r\nu32 pbus1218 = nvkm_rd32(device, 0x001218);\r\nu32 size = nvkm_rd32(device, 0x10020c) & 0xff000000;\r\nu32 tags = nvkm_rd32(device, 0x100320);\r\nenum nvkm_ram_type type = NVKM_RAM_TYPE_UNKNOWN;\r\nint ret;\r\nswitch (pbus1218 & 0x00000300) {\r\ncase 0x00000000: type = NVKM_RAM_TYPE_SDRAM; break;\r\ncase 0x00000100: type = NVKM_RAM_TYPE_DDR1 ; break;\r\ncase 0x00000200: type = NVKM_RAM_TYPE_GDDR3; break;\r\ncase 0x00000300: type = NVKM_RAM_TYPE_DDR2 ; break;\r\n}\r\nret = nv40_ram_new_(fb, type, size, tags, pram);\r\nif (ret)\r\nreturn ret;\r\n(*pram)->parts = (nvkm_rd32(device, 0x100200) & 0x00000003) + 1;\r\nreturn 0;\r\n}
