static void sas_host_smp_discover(struct sas_ha_struct *sas_ha, u8 *resp_data,\r\nu8 phy_id)\r\n{\r\nstruct sas_phy *phy;\r\nstruct sas_rphy *rphy;\r\nif (phy_id >= sas_ha->num_phys) {\r\nresp_data[2] = SMP_RESP_NO_PHY;\r\nreturn;\r\n}\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nphy = sas_ha->sas_phy[phy_id]->phy;\r\nresp_data[9] = phy_id;\r\nresp_data[13] = phy->negotiated_linkrate;\r\nmemcpy(resp_data + 16, sas_ha->sas_addr, SAS_ADDR_SIZE);\r\nmemcpy(resp_data + 24, sas_ha->sas_phy[phy_id]->attached_sas_addr,\r\nSAS_ADDR_SIZE);\r\nresp_data[40] = (phy->minimum_linkrate << 4) |\r\nphy->minimum_linkrate_hw;\r\nresp_data[41] = (phy->maximum_linkrate << 4) |\r\nphy->maximum_linkrate_hw;\r\nif (!sas_ha->sas_phy[phy_id]->port ||\r\n!sas_ha->sas_phy[phy_id]->port->port_dev)\r\nreturn;\r\nrphy = sas_ha->sas_phy[phy_id]->port->port_dev->rphy;\r\nresp_data[12] = rphy->identify.device_type << 4;\r\nresp_data[14] = rphy->identify.initiator_port_protocols;\r\nresp_data[15] = rphy->identify.target_port_protocols;\r\n}\r\nstatic u8 *to_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count, u8 *bit)\r\n{\r\nunsigned int reg;\r\nu8 byte;\r\nif (index == 0)\r\nreturn NULL;\r\nindex--;\r\nif (od < index * 32)\r\nreturn NULL;\r\nod -= index * 32;\r\nreg = od >> 5;\r\nif (reg >= count)\r\nreturn NULL;\r\nod &= (1 << 5) - 1;\r\nbyte = 3 - (od >> 3);\r\n*bit = od & ((1 << 3) - 1);\r\nreturn &data[reg * 4 + byte];\r\n}\r\nint try_test_sas_gpio_gp_bit(unsigned int od, u8 *data, u8 index, u8 count)\r\n{\r\nu8 *byte;\r\nu8 bit;\r\nbyte = to_sas_gpio_gp_bit(od, data, index, count, &bit);\r\nif (!byte)\r\nreturn -1;\r\nreturn (*byte >> bit) & 1;\r\n}\r\nstatic int sas_host_smp_write_gpio(struct sas_ha_struct *sas_ha, u8 *resp_data,\r\nu8 reg_type, u8 reg_index, u8 reg_count,\r\nu8 *req_data)\r\n{\r\nstruct sas_internal *i = to_sas_internal(sas_ha->core.shost->transportt);\r\nint written;\r\nif (i->dft->lldd_write_gpio == NULL) {\r\nresp_data[2] = SMP_RESP_FUNC_UNK;\r\nreturn 0;\r\n}\r\nwritten = i->dft->lldd_write_gpio(sas_ha, reg_type, reg_index,\r\nreg_count, req_data);\r\nif (written < 0) {\r\nresp_data[2] = SMP_RESP_FUNC_FAILED;\r\nwritten = 0;\r\n} else\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nreturn written;\r\n}\r\nstatic void sas_report_phy_sata(struct sas_ha_struct *sas_ha, u8 *resp_data,\r\nu8 phy_id)\r\n{\r\nstruct sas_rphy *rphy;\r\nstruct dev_to_host_fis *fis;\r\nint i;\r\nif (phy_id >= sas_ha->num_phys) {\r\nresp_data[2] = SMP_RESP_NO_PHY;\r\nreturn;\r\n}\r\nresp_data[2] = SMP_RESP_PHY_NO_SATA;\r\nif (!sas_ha->sas_phy[phy_id]->port)\r\nreturn;\r\nrphy = sas_ha->sas_phy[phy_id]->port->port_dev->rphy;\r\nfis = (struct dev_to_host_fis *)\r\nsas_ha->sas_phy[phy_id]->port->port_dev->frame_rcvd;\r\nif (rphy->identify.target_port_protocols != SAS_PROTOCOL_SATA)\r\nreturn;\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nresp_data[9] = phy_id;\r\nmemcpy(resp_data + 16, sas_ha->sas_phy[phy_id]->attached_sas_addr,\r\nSAS_ADDR_SIZE);\r\nif (fis->fis_type != 0x34)\r\nreturn;\r\nfor (i = 0; i < 20; i += 4) {\r\nu8 *dst = resp_data + 24 + i, *src =\r\n&sas_ha->sas_phy[phy_id]->port->port_dev->frame_rcvd[i];\r\ndst[0] = src[3];\r\ndst[1] = src[2];\r\ndst[2] = src[1];\r\ndst[3] = src[0];\r\n}\r\n}\r\nstatic void sas_phy_control(struct sas_ha_struct *sas_ha, u8 phy_id,\r\nu8 phy_op, enum sas_linkrate min,\r\nenum sas_linkrate max, u8 *resp_data)\r\n{\r\nstruct sas_internal *i =\r\nto_sas_internal(sas_ha->core.shost->transportt);\r\nstruct sas_phy_linkrates rates;\r\nstruct asd_sas_phy *asd_phy;\r\nif (phy_id >= sas_ha->num_phys) {\r\nresp_data[2] = SMP_RESP_NO_PHY;\r\nreturn;\r\n}\r\nasd_phy = sas_ha->sas_phy[phy_id];\r\nswitch (phy_op) {\r\ncase PHY_FUNC_NOP:\r\ncase PHY_FUNC_LINK_RESET:\r\ncase PHY_FUNC_HARD_RESET:\r\ncase PHY_FUNC_DISABLE:\r\ncase PHY_FUNC_CLEAR_ERROR_LOG:\r\ncase PHY_FUNC_CLEAR_AFFIL:\r\ncase PHY_FUNC_TX_SATA_PS_SIGNAL:\r\nbreak;\r\ndefault:\r\nresp_data[2] = SMP_RESP_PHY_UNK_OP;\r\nreturn;\r\n}\r\nrates.minimum_linkrate = min;\r\nrates.maximum_linkrate = max;\r\nif (phy_op == PHY_FUNC_LINK_RESET && sas_try_ata_reset(asd_phy) == 0) {\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nreturn;\r\n}\r\nif (i->dft->lldd_control_phy(asd_phy, phy_op, &rates))\r\nresp_data[2] = SMP_RESP_FUNC_FAILED;\r\nelse\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\n}\r\nint sas_smp_host_handler(struct Scsi_Host *shost, struct request *req,\r\nstruct request *rsp)\r\n{\r\nu8 *req_data = NULL, *resp_data = NULL, *buf;\r\nstruct sas_ha_struct *sas_ha = SHOST_TO_SAS_HA(shost);\r\nint error = -EINVAL;\r\nif (blk_rq_bytes(req) < 8 || blk_rq_bytes(rsp) < 8)\r\ngoto out;\r\nif (bio_offset(req->bio) + blk_rq_bytes(req) > PAGE_SIZE ||\r\nbio_offset(rsp->bio) + blk_rq_bytes(rsp) > PAGE_SIZE) {\r\nshost_printk(KERN_ERR, shost,\r\n"SMP request/response frame crosses page boundary");\r\ngoto out;\r\n}\r\nreq_data = kzalloc(blk_rq_bytes(req), GFP_KERNEL);\r\nresp_data = kzalloc(max(blk_rq_bytes(rsp), 128U), GFP_KERNEL);\r\nif (!req_data || !resp_data) {\r\nerror = -ENOMEM;\r\ngoto out;\r\n}\r\nlocal_irq_disable();\r\nbuf = kmap_atomic(bio_page(req->bio));\r\nmemcpy(req_data, buf, blk_rq_bytes(req));\r\nkunmap_atomic(buf - bio_offset(req->bio));\r\nlocal_irq_enable();\r\nif (req_data[0] != SMP_REQUEST)\r\ngoto out;\r\nerror = 0;\r\nresp_data[0] = SMP_RESPONSE;\r\nresp_data[1] = req_data[1];\r\nresp_data[2] = SMP_RESP_FUNC_UNK;\r\nswitch (req_data[1]) {\r\ncase SMP_REPORT_GENERAL:\r\nscsi_req(req)->resid_len -= 8;\r\nscsi_req(rsp)->resid_len -= 32;\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nresp_data[9] = sas_ha->num_phys;\r\nbreak;\r\ncase SMP_REPORT_MANUF_INFO:\r\nscsi_req(req)->resid_len -= 8;\r\nscsi_req(rsp)->resid_len -= 64;\r\nresp_data[2] = SMP_RESP_FUNC_ACC;\r\nmemcpy(resp_data + 12, shost->hostt->name,\r\nSAS_EXPANDER_VENDOR_ID_LEN);\r\nmemcpy(resp_data + 20, "libsas virt phy",\r\nSAS_EXPANDER_PRODUCT_ID_LEN);\r\nbreak;\r\ncase SMP_READ_GPIO_REG:\r\nbreak;\r\ncase SMP_DISCOVER:\r\nscsi_req(req)->resid_len -= 16;\r\nif ((int)scsi_req(req)->resid_len < 0) {\r\nscsi_req(req)->resid_len = 0;\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nscsi_req(rsp)->resid_len -= 56;\r\nsas_host_smp_discover(sas_ha, resp_data, req_data[9]);\r\nbreak;\r\ncase SMP_REPORT_PHY_ERR_LOG:\r\nbreak;\r\ncase SMP_REPORT_PHY_SATA:\r\nscsi_req(req)->resid_len -= 16;\r\nif ((int)scsi_req(req)->resid_len < 0) {\r\nscsi_req(req)->resid_len = 0;\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nscsi_req(rsp)->resid_len -= 60;\r\nsas_report_phy_sata(sas_ha, resp_data, req_data[9]);\r\nbreak;\r\ncase SMP_REPORT_ROUTE_INFO:\r\nbreak;\r\ncase SMP_WRITE_GPIO_REG: {\r\nconst int base_frame_size = 11;\r\nint to_write = req_data[4];\r\nif (blk_rq_bytes(req) < base_frame_size + to_write * 4 ||\r\nscsi_req(req)->resid_len < base_frame_size + to_write * 4) {\r\nresp_data[2] = SMP_RESP_INV_FRM_LEN;\r\nbreak;\r\n}\r\nto_write = sas_host_smp_write_gpio(sas_ha, resp_data, req_data[2],\r\nreq_data[3], to_write, &req_data[8]);\r\nscsi_req(req)->resid_len -= base_frame_size + to_write * 4;\r\nscsi_req(rsp)->resid_len -= 8;\r\nbreak;\r\n}\r\ncase SMP_CONF_ROUTE_INFO:\r\nbreak;\r\ncase SMP_PHY_CONTROL:\r\nscsi_req(req)->resid_len -= 44;\r\nif ((int)scsi_req(req)->resid_len < 0) {\r\nscsi_req(req)->resid_len = 0;\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nscsi_req(rsp)->resid_len -= 8;\r\nsas_phy_control(sas_ha, req_data[9], req_data[10],\r\nreq_data[32] >> 4, req_data[33] >> 4,\r\nresp_data);\r\nbreak;\r\ncase SMP_PHY_TEST_FUNCTION:\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nlocal_irq_disable();\r\nbuf = kmap_atomic(bio_page(rsp->bio));\r\nmemcpy(buf, resp_data, blk_rq_bytes(rsp));\r\nflush_kernel_dcache_page(bio_page(rsp->bio));\r\nkunmap_atomic(buf - bio_offset(rsp->bio));\r\nlocal_irq_enable();\r\nout:\r\nkfree(req_data);\r\nkfree(resp_data);\r\nreturn error;\r\n}
