static inline const struct group_desc *imx_pinctrl_find_group_by_name(\r\nstruct pinctrl_dev *pctldev,\r\nconst char *name)\r\n{\r\nconst struct group_desc *grp = NULL;\r\nint i;\r\nfor (i = 0; i < pctldev->num_groups; i++) {\r\ngrp = pinctrl_generic_get_group(pctldev, i);\r\nif (grp && !strcmp(grp->name, name))\r\nbreak;\r\n}\r\nreturn grp;\r\n}\r\nstatic void imx_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,\r\nunsigned offset)\r\n{\r\nseq_printf(s, "%s", dev_name(pctldev->dev));\r\n}\r\nstatic int imx_dt_node_to_map(struct pinctrl_dev *pctldev,\r\nstruct device_node *np,\r\nstruct pinctrl_map **map, unsigned *num_maps)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct group_desc *grp;\r\nstruct pinctrl_map *new_map;\r\nstruct device_node *parent;\r\nint map_num = 1;\r\nint i, j;\r\ngrp = imx_pinctrl_find_group_by_name(pctldev, np->name);\r\nif (!grp) {\r\ndev_err(info->dev, "unable to find group for node %s\n",\r\nnp->name);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < grp->num_pins; i++) {\r\nstruct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];\r\nif (!(pin->config & IMX_NO_PAD_CTL))\r\nmap_num++;\r\n}\r\nnew_map = kmalloc(sizeof(struct pinctrl_map) * map_num, GFP_KERNEL);\r\nif (!new_map)\r\nreturn -ENOMEM;\r\n*map = new_map;\r\n*num_maps = map_num;\r\nparent = of_get_parent(np);\r\nif (!parent) {\r\nkfree(new_map);\r\nreturn -EINVAL;\r\n}\r\nnew_map[0].type = PIN_MAP_TYPE_MUX_GROUP;\r\nnew_map[0].data.mux.function = parent->name;\r\nnew_map[0].data.mux.group = np->name;\r\nof_node_put(parent);\r\nnew_map++;\r\nfor (i = j = 0; i < grp->num_pins; i++) {\r\nstruct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];\r\nif (!(pin->config & IMX_NO_PAD_CTL)) {\r\nnew_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;\r\nnew_map[j].data.configs.group_or_pin =\r\npin_get_name(pctldev, pin->pin);\r\nnew_map[j].data.configs.configs = &pin->config;\r\nnew_map[j].data.configs.num_configs = 1;\r\nj++;\r\n}\r\n}\r\ndev_dbg(pctldev->dev, "maps: function %s group %s num %d\n",\r\n(*map)->data.mux.function, (*map)->data.mux.group, map_num);\r\nreturn 0;\r\n}\r\nstatic void imx_dt_free_map(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_map *map, unsigned num_maps)\r\n{\r\nkfree(map);\r\n}\r\nstatic int imx_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,\r\nunsigned group)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg;\r\nunsigned int npins, pin_id;\r\nint i;\r\nstruct group_desc *grp = NULL;\r\nstruct function_desc *func = NULL;\r\ngrp = pinctrl_generic_get_group(pctldev, group);\r\nif (!grp)\r\nreturn -EINVAL;\r\nfunc = pinmux_generic_get_function(pctldev, selector);\r\nif (!func)\r\nreturn -EINVAL;\r\nnpins = grp->num_pins;\r\ndev_dbg(ipctl->dev, "enable function %s group %s\n",\r\nfunc->name, grp->name);\r\nfor (i = 0; i < npins; i++) {\r\nstruct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];\r\npin_id = pin->pin;\r\npin_reg = &info->pin_regs[pin_id];\r\nif (pin_reg->mux_reg == -1) {\r\ndev_dbg(ipctl->dev, "Pin(%s) does not support mux function\n",\r\ninfo->pins[pin_id].name);\r\ncontinue;\r\n}\r\nif (info->flags & SHARE_MUX_CONF_REG) {\r\nu32 reg;\r\nreg = readl(ipctl->base + pin_reg->mux_reg);\r\nreg &= ~(0x7 << 20);\r\nreg |= (pin->mux_mode << 20);\r\nwritel(reg, ipctl->base + pin_reg->mux_reg);\r\n} else {\r\nwritel(pin->mux_mode, ipctl->base + pin_reg->mux_reg);\r\n}\r\ndev_dbg(ipctl->dev, "write: offset 0x%x val 0x%x\n",\r\npin_reg->mux_reg, pin->mux_mode);\r\nif (pin->input_val >> 24 == 0xff) {\r\nu32 val = pin->input_val;\r\nu8 select = val & 0xff;\r\nu8 width = (val >> 8) & 0xff;\r\nu8 shift = (val >> 16) & 0xff;\r\nu32 mask = ((1 << width) - 1) << shift;\r\nval = readl(ipctl->base + pin->input_reg);\r\nval &= ~mask;\r\nval |= select << shift;\r\nwritel(val, ipctl->base + pin->input_reg);\r\n} else if (pin->input_reg) {\r\nif (ipctl->input_sel_base)\r\nwritel(pin->input_val, ipctl->input_sel_base +\r\npin->input_reg);\r\nelse\r\nwritel(pin->input_val, ipctl->base +\r\npin->input_reg);\r\ndev_dbg(ipctl->dev,\r\n"==>select_input: offset 0x%x val 0x%x\n",\r\npin->input_reg, pin->input_val);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pmx_gpio_request_enable(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg;\r\nstruct group_desc *grp;\r\nstruct imx_pin *imx_pin;\r\nunsigned int pin, group;\r\nu32 reg;\r\nif (!(info->flags & SHARE_MUX_CONF_REG))\r\nreturn 0;\r\npin_reg = &info->pin_regs[offset];\r\nif (pin_reg->mux_reg == -1)\r\nreturn -EINVAL;\r\nfor (group = 0; group < pctldev->num_groups; group++) {\r\ngrp = pinctrl_generic_get_group(pctldev, group);\r\nif (!grp)\r\ncontinue;\r\nfor (pin = 0; pin < grp->num_pins; pin++) {\r\nimx_pin = &((struct imx_pin *)(grp->data))[pin];\r\nif (imx_pin->pin == offset && !imx_pin->mux_mode)\r\ngoto mux_pin;\r\n}\r\n}\r\nreturn -EINVAL;\r\nmux_pin:\r\nreg = readl(ipctl->base + pin_reg->mux_reg);\r\nreg &= ~(0x7 << 20);\r\nreg |= imx_pin->config;\r\nwritel(reg, ipctl->base + pin_reg->mux_reg);\r\nreturn 0;\r\n}\r\nstatic void imx_pmx_gpio_disable_free(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg;\r\nu32 reg;\r\nif (!(info->flags & SHARE_MUX_CONF_REG))\r\nreturn;\r\npin_reg = &info->pin_regs[offset];\r\nif (pin_reg->mux_reg == -1)\r\nreturn;\r\nreg = readl(ipctl->base + pin_reg->mux_reg);\r\nreg &= ~0x7;\r\nwritel(reg, ipctl->base + pin_reg->mux_reg);\r\n}\r\nstatic int imx_pmx_gpio_set_direction(struct pinctrl_dev *pctldev,\r\nstruct pinctrl_gpio_range *range, unsigned offset, bool input)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg;\r\nu32 reg;\r\nif (!(info->flags & SHARE_MUX_CONF_REG))\r\nreturn 0;\r\npin_reg = &info->pin_regs[offset];\r\nif (pin_reg->mux_reg == -1)\r\nreturn -EINVAL;\r\nreg = readl(ipctl->base + pin_reg->mux_reg);\r\nif (input)\r\nreg &= ~0x2;\r\nelse\r\nreg |= 0x2;\r\nwritel(reg, ipctl->base + pin_reg->mux_reg);\r\nreturn 0;\r\n}\r\nstatic int imx_pinconf_get(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *config)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg = &info->pin_regs[pin_id];\r\nif (pin_reg->conf_reg == -1) {\r\ndev_err(info->dev, "Pin(%s) does not support config function\n",\r\ninfo->pins[pin_id].name);\r\nreturn -EINVAL;\r\n}\r\n*config = readl(ipctl->base + pin_reg->conf_reg);\r\nif (info->flags & SHARE_MUX_CONF_REG)\r\n*config &= 0xffff;\r\nreturn 0;\r\n}\r\nstatic int imx_pinconf_set(struct pinctrl_dev *pctldev,\r\nunsigned pin_id, unsigned long *configs,\r\nunsigned num_configs)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg = &info->pin_regs[pin_id];\r\nint i;\r\nif (pin_reg->conf_reg == -1) {\r\ndev_err(info->dev, "Pin(%s) does not support config function\n",\r\ninfo->pins[pin_id].name);\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(ipctl->dev, "pinconf set pin %s\n",\r\ninfo->pins[pin_id].name);\r\nfor (i = 0; i < num_configs; i++) {\r\nif (info->flags & SHARE_MUX_CONF_REG) {\r\nu32 reg;\r\nreg = readl(ipctl->base + pin_reg->conf_reg);\r\nreg &= ~0xffff;\r\nreg |= configs[i];\r\nwritel(reg, ipctl->base + pin_reg->conf_reg);\r\n} else {\r\nwritel(configs[i], ipctl->base + pin_reg->conf_reg);\r\n}\r\ndev_dbg(ipctl->dev, "write: offset 0x%x val 0x%lx\n",\r\npin_reg->conf_reg, configs[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void imx_pinconf_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned pin_id)\r\n{\r\nstruct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nconst struct imx_pin_reg *pin_reg = &info->pin_regs[pin_id];\r\nunsigned long config;\r\nif (!pin_reg || pin_reg->conf_reg == -1) {\r\nseq_printf(s, "N/A");\r\nreturn;\r\n}\r\nconfig = readl(ipctl->base + pin_reg->conf_reg);\r\nseq_printf(s, "0x%lx", config);\r\n}\r\nstatic void imx_pinconf_group_dbg_show(struct pinctrl_dev *pctldev,\r\nstruct seq_file *s, unsigned group)\r\n{\r\nstruct group_desc *grp;\r\nunsigned long config;\r\nconst char *name;\r\nint i, ret;\r\nif (group > pctldev->num_groups)\r\nreturn;\r\nseq_printf(s, "\n");\r\ngrp = pinctrl_generic_get_group(pctldev, group);\r\nif (!grp)\r\nreturn;\r\nfor (i = 0; i < grp->num_pins; i++) {\r\nstruct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];\r\nname = pin_get_name(pctldev, pin->pin);\r\nret = imx_pinconf_get(pctldev, pin->pin, &config);\r\nif (ret)\r\nreturn;\r\nseq_printf(s, " %s: 0x%lx\n", name, config);\r\n}\r\n}\r\nstatic int imx_pinctrl_parse_groups(struct device_node *np,\r\nstruct group_desc *grp,\r\nstruct imx_pinctrl_soc_info *info,\r\nu32 index)\r\n{\r\nint size, pin_size;\r\nconst __be32 *list;\r\nint i;\r\nu32 config;\r\ndev_dbg(info->dev, "group(%d): %s\n", index, np->name);\r\nif (info->flags & SHARE_MUX_CONF_REG)\r\npin_size = SHARE_FSL_PIN_SIZE;\r\nelse\r\npin_size = FSL_PIN_SIZE;\r\ngrp->name = np->name;\r\nlist = of_get_property(np, "fsl,pins", &size);\r\nif (!list) {\r\ndev_err(info->dev, "no fsl,pins property in node %s\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nif (!size || size % pin_size) {\r\ndev_err(info->dev, "Invalid fsl,pins property in node %s\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\ngrp->num_pins = size / pin_size;\r\ngrp->data = devm_kzalloc(info->dev, grp->num_pins *\r\nsizeof(struct imx_pin), GFP_KERNEL);\r\ngrp->pins = devm_kzalloc(info->dev, grp->num_pins *\r\nsizeof(unsigned int), GFP_KERNEL);\r\nif (!grp->pins || !grp->data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < grp->num_pins; i++) {\r\nu32 mux_reg = be32_to_cpu(*list++);\r\nu32 conf_reg;\r\nunsigned int pin_id;\r\nstruct imx_pin_reg *pin_reg;\r\nstruct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];\r\nif (!(info->flags & ZERO_OFFSET_VALID) && !mux_reg)\r\nmux_reg = -1;\r\nif (info->flags & SHARE_MUX_CONF_REG) {\r\nconf_reg = mux_reg;\r\n} else {\r\nconf_reg = be32_to_cpu(*list++);\r\nif (!conf_reg)\r\nconf_reg = -1;\r\n}\r\npin_id = (mux_reg != -1) ? mux_reg / 4 : conf_reg / 4;\r\npin_reg = &info->pin_regs[pin_id];\r\npin->pin = pin_id;\r\ngrp->pins[i] = pin_id;\r\npin_reg->mux_reg = mux_reg;\r\npin_reg->conf_reg = conf_reg;\r\npin->input_reg = be32_to_cpu(*list++);\r\npin->mux_mode = be32_to_cpu(*list++);\r\npin->input_val = be32_to_cpu(*list++);\r\nconfig = be32_to_cpu(*list++);\r\nif (config & IMX_PAD_SION)\r\npin->mux_mode |= IOMUXC_CONFIG_SION;\r\npin->config = config & ~IMX_PAD_SION;\r\ndev_dbg(info->dev, "%s: 0x%x 0x%08lx", info->pins[pin_id].name,\r\npin->mux_mode, pin->config);\r\n}\r\nreturn 0;\r\n}\r\nstatic int imx_pinctrl_parse_functions(struct device_node *np,\r\nstruct imx_pinctrl *ipctl,\r\nu32 index)\r\n{\r\nstruct pinctrl_dev *pctl = ipctl->pctl;\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nstruct device_node *child;\r\nstruct function_desc *func;\r\nstruct group_desc *grp;\r\nu32 i = 0;\r\ndev_dbg(info->dev, "parse function(%d): %s\n", index, np->name);\r\nfunc = pinmux_generic_get_function(pctl, index);\r\nif (!func)\r\nreturn -EINVAL;\r\nfunc->name = np->name;\r\nfunc->num_group_names = of_get_child_count(np);\r\nif (func->num_group_names == 0) {\r\ndev_err(info->dev, "no groups defined in %s\n", np->full_name);\r\nreturn -EINVAL;\r\n}\r\nfunc->group_names = devm_kzalloc(info->dev,\r\nfunc->num_group_names *\r\nsizeof(char *), GFP_KERNEL);\r\nfor_each_child_of_node(np, child) {\r\nfunc->group_names[i] = child->name;\r\ngrp = devm_kzalloc(info->dev, sizeof(struct group_desc),\r\nGFP_KERNEL);\r\nif (!grp)\r\nreturn -ENOMEM;\r\nmutex_lock(&info->mutex);\r\nradix_tree_insert(&pctl->pin_group_tree,\r\ninfo->group_index++, grp);\r\nmutex_unlock(&info->mutex);\r\nimx_pinctrl_parse_groups(child, grp, info, i++);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool imx_pinctrl_dt_is_flat_functions(struct device_node *np)\r\n{\r\nstruct device_node *function_np;\r\nstruct device_node *pinctrl_np;\r\nfor_each_child_of_node(np, function_np) {\r\nif (of_property_read_bool(function_np, "fsl,pins"))\r\nreturn true;\r\nfor_each_child_of_node(function_np, pinctrl_np) {\r\nif (of_property_read_bool(pinctrl_np, "fsl,pins"))\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int imx_pinctrl_probe_dt(struct platform_device *pdev,\r\nstruct imx_pinctrl *ipctl)\r\n{\r\nstruct device_node *np = pdev->dev.of_node;\r\nstruct device_node *child;\r\nstruct pinctrl_dev *pctl = ipctl->pctl;\r\nstruct imx_pinctrl_soc_info *info = ipctl->info;\r\nu32 nfuncs = 0;\r\nu32 i = 0;\r\nbool flat_funcs;\r\nif (!np)\r\nreturn -ENODEV;\r\nflat_funcs = imx_pinctrl_dt_is_flat_functions(np);\r\nif (flat_funcs) {\r\nnfuncs = 1;\r\n} else {\r\nnfuncs = of_get_child_count(np);\r\nif (nfuncs <= 0) {\r\ndev_err(&pdev->dev, "no functions defined\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nfor (i = 0; i < nfuncs; i++) {\r\nstruct function_desc *function;\r\nfunction = devm_kzalloc(&pdev->dev, sizeof(*function),\r\nGFP_KERNEL);\r\nif (!function)\r\nreturn -ENOMEM;\r\nmutex_lock(&info->mutex);\r\nradix_tree_insert(&pctl->pin_function_tree, i, function);\r\nmutex_unlock(&info->mutex);\r\n}\r\npctl->num_functions = nfuncs;\r\ninfo->group_index = 0;\r\nif (flat_funcs) {\r\npctl->num_groups = of_get_child_count(np);\r\n} else {\r\npctl->num_groups = 0;\r\nfor_each_child_of_node(np, child)\r\npctl->num_groups += of_get_child_count(child);\r\n}\r\nif (flat_funcs) {\r\nimx_pinctrl_parse_functions(np, ipctl, 0);\r\n} else {\r\ni = 0;\r\nfor_each_child_of_node(np, child)\r\nimx_pinctrl_parse_functions(child, ipctl, i++);\r\n}\r\nreturn 0;\r\n}\r\nstatic void imx_free_resources(struct imx_pinctrl *ipctl)\r\n{\r\nif (ipctl->pctl)\r\npinctrl_unregister(ipctl->pctl);\r\n}\r\nint imx_pinctrl_probe(struct platform_device *pdev,\r\nstruct imx_pinctrl_soc_info *info)\r\n{\r\nstruct regmap_config config = { .name = "gpr" };\r\nstruct device_node *dev_np = pdev->dev.of_node;\r\nstruct pinctrl_desc *imx_pinctrl_desc;\r\nstruct device_node *np;\r\nstruct imx_pinctrl *ipctl;\r\nstruct resource *res;\r\nstruct regmap *gpr;\r\nint ret, i;\r\nif (!info || !info->pins || !info->npins) {\r\ndev_err(&pdev->dev, "wrong pinctrl info\n");\r\nreturn -EINVAL;\r\n}\r\ninfo->dev = &pdev->dev;\r\nif (info->gpr_compatible) {\r\ngpr = syscon_regmap_lookup_by_compatible(info->gpr_compatible);\r\nif (!IS_ERR(gpr))\r\nregmap_attach_dev(&pdev->dev, gpr, &config);\r\n}\r\nipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);\r\nif (!ipctl)\r\nreturn -ENOMEM;\r\ninfo->pin_regs = devm_kmalloc(&pdev->dev, sizeof(*info->pin_regs) *\r\ninfo->npins, GFP_KERNEL);\r\nif (!info->pin_regs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < info->npins; i++) {\r\ninfo->pin_regs[i].mux_reg = -1;\r\ninfo->pin_regs[i].conf_reg = -1;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nipctl->base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ipctl->base))\r\nreturn PTR_ERR(ipctl->base);\r\nif (of_property_read_bool(dev_np, "fsl,input-sel")) {\r\nnp = of_parse_phandle(dev_np, "fsl,input-sel", 0);\r\nif (!np) {\r\ndev_err(&pdev->dev, "iomuxc fsl,input-sel property not found\n");\r\nreturn -EINVAL;\r\n}\r\nipctl->input_sel_base = of_iomap(np, 0);\r\nof_node_put(np);\r\nif (!ipctl->input_sel_base) {\r\ndev_err(&pdev->dev,\r\n"iomuxc input select base address not found\n");\r\nreturn -ENOMEM;\r\n}\r\n}\r\nimx_pinctrl_desc = devm_kzalloc(&pdev->dev, sizeof(*imx_pinctrl_desc),\r\nGFP_KERNEL);\r\nif (!imx_pinctrl_desc)\r\nreturn -ENOMEM;\r\nimx_pinctrl_desc->name = dev_name(&pdev->dev);\r\nimx_pinctrl_desc->pins = info->pins;\r\nimx_pinctrl_desc->npins = info->npins;\r\nimx_pinctrl_desc->pctlops = &imx_pctrl_ops;\r\nimx_pinctrl_desc->pmxops = &imx_pmx_ops;\r\nimx_pinctrl_desc->confops = &imx_pinconf_ops;\r\nimx_pinctrl_desc->owner = THIS_MODULE;\r\nmutex_init(&info->mutex);\r\nipctl->info = info;\r\nipctl->dev = info->dev;\r\nplatform_set_drvdata(pdev, ipctl);\r\nret = devm_pinctrl_register_and_init(&pdev->dev,\r\nimx_pinctrl_desc, ipctl,\r\n&ipctl->pctl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "could not register IMX pinctrl driver\n");\r\ngoto free;\r\n}\r\nret = imx_pinctrl_probe_dt(pdev, ipctl);\r\nif (ret) {\r\ndev_err(&pdev->dev, "fail to probe dt properties\n");\r\ngoto free;\r\n}\r\ndev_info(&pdev->dev, "initialized IMX pinctrl driver\n");\r\nreturn pinctrl_enable(ipctl->pctl);\r\nfree:\r\nimx_free_resources(ipctl);\r\nreturn ret;\r\n}
