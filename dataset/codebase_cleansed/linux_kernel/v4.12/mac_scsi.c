static int __init mac_scsi_setup(char *str)\r\n{\r\nint ints[8];\r\n(void)get_options(str, ARRAY_SIZE(ints), ints);\r\nif (ints[0] < 1) {\r\npr_err("Usage: mac5380=<can_queue>[,<cmd_per_lun>[,<sg_tablesize>[,<hostid>[,<use_tags>[,<use_pdma>[,<toshiba_delay>]]]]]]\n");\r\nreturn 0;\r\n}\r\nif (ints[0] >= 1)\r\nsetup_can_queue = ints[1];\r\nif (ints[0] >= 2)\r\nsetup_cmd_per_lun = ints[2];\r\nif (ints[0] >= 3)\r\nsetup_sg_tablesize = ints[3];\r\nif (ints[0] >= 4)\r\nsetup_hostid = ints[4];\r\nif (ints[0] >= 6)\r\nsetup_use_pdma = ints[6];\r\nif (ints[0] >= 7)\r\nsetup_toshiba_delay = ints[7];\r\nreturn 1;\r\n}\r\nstatic inline int macscsi_pread(struct NCR5380_hostdata *hostdata,\r\nunsigned char *dst, int len)\r\n{\r\nu8 __iomem *s = hostdata->pdma_io + (INPUT_DATA_REG << 4);\r\nunsigned char *d = dst;\r\nint n = len;\r\nint transferred;\r\nwhile (!NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\r\nBASR_DRQ | BASR_PHASE_MATCH,\r\nBASR_DRQ | BASR_PHASE_MATCH, HZ / 64)) {\r\nCP_IO_TO_MEM(s, d, n);\r\ntransferred = d - dst - n;\r\nhostdata->pdma_residual = len - transferred;\r\nif (n == 0)\r\nreturn 0;\r\nif (NCR5380_poll_politely2(hostdata, STATUS_REG, SR_REQ, SR_REQ,\r\nBUS_AND_STATUS_REG, BASR_ACK, BASR_ACK, HZ / 64) < 0)\r\nscmd_printk(KERN_ERR, hostdata->connected,\r\n"%s: !REQ and !ACK\n", __func__);\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH))\r\nreturn 0;\r\ndsprintk(NDEBUG_PSEUDO_DMA, hostdata->host,\r\n"%s: bus error (%d/%d)\n", __func__, transferred, len);\r\nNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\r\nd = dst + transferred;\r\nn = len - transferred;\r\n}\r\nscmd_printk(KERN_ERR, hostdata->connected,\r\n"%s: phase mismatch or !DRQ\n", __func__);\r\nNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\r\nreturn -1;\r\n}\r\nstatic inline int macscsi_pwrite(struct NCR5380_hostdata *hostdata,\r\nunsigned char *src, int len)\r\n{\r\nunsigned char *s = src;\r\nu8 __iomem *d = hostdata->pdma_io + (OUTPUT_DATA_REG << 4);\r\nint n = len;\r\nint transferred;\r\nwhile (!NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,\r\nBASR_DRQ | BASR_PHASE_MATCH,\r\nBASR_DRQ | BASR_PHASE_MATCH, HZ / 64)) {\r\nCP_MEM_TO_IO(s, d, n);\r\ntransferred = s - src - n;\r\nhostdata->pdma_residual = len - transferred;\r\nif (NCR5380_poll_politely2(hostdata, STATUS_REG, SR_REQ, SR_REQ,\r\nBUS_AND_STATUS_REG, BASR_ACK, BASR_ACK, HZ / 64) < 0)\r\nscmd_printk(KERN_ERR, hostdata->connected,\r\n"%s: !REQ and !ACK\n", __func__);\r\nif (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_PHASE_MATCH))\r\nreturn 0;\r\nif (n == 0) {\r\nif (NCR5380_poll_politely(hostdata, TARGET_COMMAND_REG,\r\nTCR_LAST_BYTE_SENT,\r\nTCR_LAST_BYTE_SENT, HZ / 64) < 0)\r\nscmd_printk(KERN_ERR, hostdata->connected,\r\n"%s: Last Byte Sent timeout\n", __func__);\r\nreturn 0;\r\n}\r\ndsprintk(NDEBUG_PSEUDO_DMA, hostdata->host,\r\n"%s: bus error (%d/%d)\n", __func__, transferred, len);\r\nNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\r\ns = src + transferred;\r\nn = len - transferred;\r\n}\r\nscmd_printk(KERN_ERR, hostdata->connected,\r\n"%s: phase mismatch or !DRQ\n", __func__);\r\nNCR5380_dprint(NDEBUG_PSEUDO_DMA, hostdata->host);\r\nreturn -1;\r\n}\r\nstatic int macscsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,\r\nstruct scsi_cmnd *cmd)\r\n{\r\nif (hostdata->flags & FLAG_NO_PSEUDO_DMA ||\r\ncmd->SCp.this_residual < 16)\r\nreturn 0;\r\nreturn cmd->SCp.this_residual;\r\n}\r\nstatic int macscsi_dma_residual(struct NCR5380_hostdata *hostdata)\r\n{\r\nreturn hostdata->pdma_residual;\r\n}\r\nstatic int __init mac_scsi_probe(struct platform_device *pdev)\r\n{\r\nstruct Scsi_Host *instance;\r\nstruct NCR5380_hostdata *hostdata;\r\nint error;\r\nint host_flags = 0;\r\nstruct resource *irq, *pio_mem, *pdma_mem = NULL;\r\npio_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!pio_mem)\r\nreturn -ENODEV;\r\npdma_mem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nirq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!hwreg_present((unsigned char *)pio_mem->start +\r\n(STATUS_REG << 4))) {\r\npr_info(PFX "no device detected at %pap\n", &pio_mem->start);\r\nreturn -ENODEV;\r\n}\r\nif (setup_can_queue > 0)\r\nmac_scsi_template.can_queue = setup_can_queue;\r\nif (setup_cmd_per_lun > 0)\r\nmac_scsi_template.cmd_per_lun = setup_cmd_per_lun;\r\nif (setup_sg_tablesize >= 0)\r\nmac_scsi_template.sg_tablesize = setup_sg_tablesize;\r\nif (setup_hostid >= 0)\r\nmac_scsi_template.this_id = setup_hostid & 7;\r\ninstance = scsi_host_alloc(&mac_scsi_template,\r\nsizeof(struct NCR5380_hostdata));\r\nif (!instance)\r\nreturn -ENOMEM;\r\nif (irq)\r\ninstance->irq = irq->start;\r\nelse\r\ninstance->irq = NO_IRQ;\r\nhostdata = shost_priv(instance);\r\nhostdata->base = pio_mem->start;\r\nhostdata->io = (u8 __iomem *)pio_mem->start;\r\nif (pdma_mem && setup_use_pdma)\r\nhostdata->pdma_io = (u8 __iomem *)pdma_mem->start;\r\nelse\r\nhost_flags |= FLAG_NO_PSEUDO_DMA;\r\nhost_flags |= setup_toshiba_delay > 0 ? FLAG_TOSHIBA_DELAY : 0;\r\nerror = NCR5380_init(instance, host_flags | FLAG_LATE_DMA_SETUP);\r\nif (error)\r\ngoto fail_init;\r\nif (instance->irq != NO_IRQ) {\r\nerror = request_irq(instance->irq, macscsi_intr, IRQF_SHARED,\r\n"NCR5380", instance);\r\nif (error)\r\ngoto fail_irq;\r\n}\r\nNCR5380_maybe_reset_bus(instance);\r\nerror = scsi_add_host(instance, NULL);\r\nif (error)\r\ngoto fail_host;\r\nplatform_set_drvdata(pdev, instance);\r\nscsi_scan_host(instance);\r\nreturn 0;\r\nfail_host:\r\nif (instance->irq != NO_IRQ)\r\nfree_irq(instance->irq, instance);\r\nfail_irq:\r\nNCR5380_exit(instance);\r\nfail_init:\r\nscsi_host_put(instance);\r\nreturn error;\r\n}\r\nstatic int __exit mac_scsi_remove(struct platform_device *pdev)\r\n{\r\nstruct Scsi_Host *instance = platform_get_drvdata(pdev);\r\nscsi_remove_host(instance);\r\nif (instance->irq != NO_IRQ)\r\nfree_irq(instance->irq, instance);\r\nNCR5380_exit(instance);\r\nscsi_host_put(instance);\r\nreturn 0;\r\n}
