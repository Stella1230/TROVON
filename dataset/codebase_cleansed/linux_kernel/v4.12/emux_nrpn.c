static int send_converted_effect(const struct nrpn_conv_table *table,\r\nint num_tables,\r\nstruct snd_emux_port *port,\r\nstruct snd_midi_channel *chan,\r\nint type, int val, int mode)\r\n{\r\nint i, cval;\r\nfor (i = 0; i < num_tables; i++) {\r\nif (table[i].control == type) {\r\ncval = table[i].convert(val);\r\nsnd_emux_send_effect(port, chan, table[i].effect,\r\ncval, mode);\r\nreturn 1;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int fx_delay(int val)\r\n{\r\nreturn (unsigned short)snd_sf_calc_parm_delay(val);\r\n}\r\nstatic int fx_attack(int val)\r\n{\r\nreturn (unsigned short)snd_sf_calc_parm_attack(val);\r\n}\r\nstatic int fx_hold(int val)\r\n{\r\nreturn (unsigned short)snd_sf_calc_parm_hold(val);\r\n}\r\nstatic int fx_decay(int val)\r\n{\r\nreturn (unsigned short)snd_sf_calc_parm_decay(val);\r\n}\r\nstatic int fx_the_value(int val)\r\n{\r\nreturn (unsigned short)(val & 0xff);\r\n}\r\nstatic int fx_twice_value(int val)\r\n{\r\nreturn (unsigned short)((val * 2) & 0xff);\r\n}\r\nstatic int fx_conv_pitch(int val)\r\n{\r\nreturn (short)(val * 4096 / 1200);\r\n}\r\nstatic int fx_conv_Q(int val)\r\n{\r\nreturn (unsigned short)((val / 8) & 0xff);\r\n}\r\nstatic int gs_cutoff(int val)\r\n{\r\nreturn (val - 64) * gs_sense[FX_CUTOFF] / 50;\r\n}\r\nstatic int gs_filterQ(int val)\r\n{\r\nreturn (val - 64) * gs_sense[FX_RESONANCE] / 50;\r\n}\r\nstatic int gs_attack(int val)\r\n{\r\nreturn -(val - 64) * gs_sense[FX_ATTACK] / 50;\r\n}\r\nstatic int gs_decay(int val)\r\n{\r\nreturn -(val - 64) * gs_sense[FX_RELEASE] / 50;\r\n}\r\nstatic int gs_release(int val)\r\n{\r\nreturn -(val - 64) * gs_sense[FX_RELEASE] / 50;\r\n}\r\nstatic int gs_vib_rate(int val)\r\n{\r\nreturn (val - 64) * gs_sense[FX_VIBRATE] / 50;\r\n}\r\nstatic int gs_vib_depth(int val)\r\n{\r\nreturn (val - 64) * gs_sense[FX_VIBDEPTH] / 50;\r\n}\r\nstatic int gs_vib_delay(int val)\r\n{\r\nreturn -(val - 64) * gs_sense[FX_VIBDELAY] / 50;\r\n}\r\nvoid\r\nsnd_emux_nrpn(void *p, struct snd_midi_channel *chan,\r\nstruct snd_midi_channel_set *chset)\r\n{\r\nstruct snd_emux_port *port;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chan))\r\nreturn;\r\nif (chan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 127 &&\r\nchan->control[MIDI_CTL_NONREG_PARM_NUM_LSB] <= 26) {\r\nint val;\r\nval = (chan->control[MIDI_CTL_MSB_DATA_ENTRY] << 7) |\r\nchan->control[MIDI_CTL_LSB_DATA_ENTRY];\r\nval -= 8192;\r\nsend_converted_effect\r\n(awe_effects, ARRAY_SIZE(awe_effects),\r\nport, chan, chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB],\r\nval, EMUX_FX_FLAG_SET);\r\nreturn;\r\n}\r\nif (port->chset.midi_mode == SNDRV_MIDI_MODE_GS &&\r\nchan->control[MIDI_CTL_NONREG_PARM_NUM_MSB] == 1) {\r\nint val;\r\nval = chan->control[MIDI_CTL_MSB_DATA_ENTRY];\r\nsend_converted_effect\r\n(gs_effects, ARRAY_SIZE(gs_effects),\r\nport, chan, chan->control[MIDI_CTL_NONREG_PARM_NUM_LSB],\r\nval, EMUX_FX_FLAG_ADD);\r\nreturn;\r\n}\r\n}\r\nstatic int xg_cutoff(int val)\r\n{\r\nreturn (val - 64) * xg_sense[FX_CUTOFF] / 64;\r\n}\r\nstatic int xg_filterQ(int val)\r\n{\r\nreturn (val - 64) * xg_sense[FX_RESONANCE] / 64;\r\n}\r\nstatic int xg_attack(int val)\r\n{\r\nreturn -(val - 64) * xg_sense[FX_ATTACK] / 64;\r\n}\r\nstatic int xg_release(int val)\r\n{\r\nreturn -(val - 64) * xg_sense[FX_RELEASE] / 64;\r\n}\r\nint\r\nsnd_emux_xg_control(struct snd_emux_port *port, struct snd_midi_channel *chan,\r\nint param)\r\n{\r\nreturn send_converted_effect(xg_effects, ARRAY_SIZE(xg_effects),\r\nport, chan, param,\r\nchan->control[param],\r\nEMUX_FX_FLAG_ADD);\r\n}\r\nvoid\r\nsnd_emux_sysex(void *p, unsigned char *buf, int len, int parsed,\r\nstruct snd_midi_channel_set *chset)\r\n{\r\nstruct snd_emux_port *port;\r\nstruct snd_emux *emu;\r\nport = p;\r\nif (snd_BUG_ON(!port || !chset))\r\nreturn;\r\nemu = port->emu;\r\nswitch (parsed) {\r\ncase SNDRV_MIDI_SYSEX_GS_MASTER_VOLUME:\r\nsnd_emux_update_port(port, SNDRV_EMUX_UPDATE_VOLUME);\r\nbreak;\r\ndefault:\r\nif (emu->ops.sysex)\r\nemu->ops.sysex(emu, buf, len, parsed, chset);\r\nbreak;\r\n}\r\n}
