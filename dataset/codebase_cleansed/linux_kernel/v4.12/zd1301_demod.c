static int zd1301_demod_wreg(struct zd1301_demod_dev *dev, u16 reg, u8 val)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct zd1301_demod_platform_data *pdata = pdev->dev.platform_data;\r\nreturn pdata->reg_write(pdata->reg_priv, reg, val);\r\n}\r\nstatic int zd1301_demod_rreg(struct zd1301_demod_dev *dev, u16 reg, u8 *val)\r\n{\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct zd1301_demod_platform_data *pdata = pdev->dev.platform_data;\r\nreturn pdata->reg_read(pdata->reg_priv, reg, val);\r\n}\r\nstatic int zd1301_demod_set_frontend(struct dvb_frontend *fe)\r\n{\r\nstruct zd1301_demod_dev *dev = fe->demodulator_priv;\r\nstruct platform_device *pdev = dev->pdev;\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nint ret;\r\nu32 if_frequency;\r\nu8 r6a50_val;\r\ndev_dbg(&pdev->dev, "frequency=%u bandwidth_hz=%u\n",\r\nc->frequency, c->bandwidth_hz);\r\nif (fe->ops.tuner_ops.set_params &&\r\nfe->ops.tuner_ops.get_if_frequency) {\r\nret = fe->ops.tuner_ops.set_params(fe);\r\nif (ret)\r\ngoto err;\r\nret = fe->ops.tuner_ops.get_if_frequency(fe, &if_frequency);\r\nif (ret)\r\ngoto err;\r\n} else {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\ndev_dbg(&pdev->dev, "if_frequency=%u\n", if_frequency);\r\nif (if_frequency != 36150000) {\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nswitch (c->bandwidth_hz) {\r\ncase 6000000:\r\nr6a50_val = 0x78;\r\nbreak;\r\ncase 7000000:\r\nr6a50_val = 0x68;\r\nbreak;\r\ncase 8000000:\r\nr6a50_val = 0x58;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = zd1301_demod_wreg(dev, 0x6a60, 0x11);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a47, 0x46);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a48, 0x46);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a4a, 0x15);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a4b, 0x63);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a5b, 0x99);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a3b, 0x10);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6806, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a41, 0x08);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a42, 0x46);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a44, 0x14);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a45, 0x67);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a38, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a4c, 0x52);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a49, 0x2a);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6840, 0x2e);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a50, r6a50_val);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a38, 0x07);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&pdev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int zd1301_demod_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct zd1301_demod_dev *dev = fe->demodulator_priv;\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "\n");\r\nret = zd1301_demod_wreg(dev, 0x6a43, 0x70);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x684e, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6849, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x68e2, 0xd7);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x68e0, 0x39);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6840, 0x21);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&pdev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int zd1301_demod_init(struct dvb_frontend *fe)\r\n{\r\nstruct zd1301_demod_dev *dev = fe->demodulator_priv;\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret;\r\ndev_dbg(&pdev->dev, "\n");\r\nret = zd1301_demod_wreg(dev, 0x6840, 0x26);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x68e0, 0xff);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x68e2, 0xd8);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6849, 0x4e);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x684e, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6a43, zd1301_demod_gain);\r\nif (ret)\r\ngoto err;\r\nreturn 0;\r\nerr:\r\ndev_dbg(&pdev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int zd1301_demod_get_tune_settings(struct dvb_frontend *fe,\r\nstruct dvb_frontend_tune_settings *settings)\r\n{\r\nstruct zd1301_demod_dev *dev = fe->demodulator_priv;\r\nstruct platform_device *pdev = dev->pdev;\r\ndev_dbg(&pdev->dev, "\n");\r\nsettings->min_delay_ms = 400;\r\nreturn 0;\r\n}\r\nstatic int zd1301_demod_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct zd1301_demod_dev *dev = fe->demodulator_priv;\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret;\r\nu8 u8tmp;\r\nret = zd1301_demod_rreg(dev, 0x6a24, &u8tmp);\r\nif (ret)\r\ngoto err;\r\nif (u8tmp > 0x00 && u8tmp < 0x20)\r\n*status = FE_HAS_SIGNAL | FE_HAS_CARRIER | FE_HAS_VITERBI |\r\nFE_HAS_SYNC | FE_HAS_LOCK;\r\nelse\r\n*status = 0;\r\ndev_dbg(&pdev->dev, "lock byte=%02x\n", u8tmp);\r\nif (dev->gain != zd1301_demod_gain) {\r\ndev->gain = zd1301_demod_gain;\r\nret = zd1301_demod_wreg(dev, 0x6a43, dev->gain);\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\ndev_dbg(&pdev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstruct dvb_frontend *zd1301_demod_get_dvb_frontend(struct platform_device *pdev)\r\n{\r\nstruct zd1301_demod_dev *dev = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "\n");\r\nreturn &dev->frontend;\r\n}\r\nstatic int zd1301_demod_i2c_master_xfer(struct i2c_adapter *adapter,\r\nstruct i2c_msg msg[], int num)\r\n{\r\nstruct zd1301_demod_dev *dev = i2c_get_adapdata(adapter);\r\nstruct platform_device *pdev = dev->pdev;\r\nint ret, i;\r\nunsigned long timeout;\r\nu8 u8tmp;\r\n#define I2C_XFER_TIMEOUT 5\r\n#define ZD1301_IS_I2C_XFER_WRITE_READ(_msg, _num) \\r\n(_num == 2 && !(_msg[0].flags & I2C_M_RD) && (_msg[1].flags & I2C_M_RD))\r\n#define ZD1301_IS_I2C_XFER_WRITE(_msg, _num) \\r\n(_num == 1 && !(_msg[0].flags & I2C_M_RD))\r\n#define ZD1301_IS_I2C_XFER_READ(_msg, _num) \\r\n(_num == 1 && (_msg[0].flags & I2C_M_RD))\r\nif (ZD1301_IS_I2C_XFER_WRITE_READ(msg, num)) {\r\ndev_dbg(&pdev->dev, "write&read msg[0].len=%u msg[1].len=%u\n",\r\nmsg[0].len, msg[1].len);\r\nif (msg[0].len > 1 || msg[1].len > 8) {\r\nret = -EOPNOTSUPP;\r\ngoto err;\r\n}\r\nret = zd1301_demod_wreg(dev, 0x6811, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6812, 0x05);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6813, msg[1].addr << 1);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6801, msg[0].buf[0]);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6802, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6803, 0x06);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6805, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6804, msg[1].len);\r\nif (ret)\r\ngoto err;\r\ntimeout = jiffies + msecs_to_jiffies(I2C_XFER_TIMEOUT);\r\nfor (u8tmp = 1; !time_after(jiffies, timeout) && u8tmp;) {\r\nusleep_range(500, 800);\r\nret = zd1301_demod_rreg(dev, 0x6804, &u8tmp);\r\nif (ret)\r\ngoto err;\r\n}\r\nfor (i = 0; i < msg[1].len; i++) {\r\nret = zd1301_demod_rreg(dev, 0x0600 + i, &msg[1].buf[i]);\r\nif (ret)\r\ngoto err;\r\n}\r\n} else if (ZD1301_IS_I2C_XFER_WRITE(msg, num)) {\r\ndev_dbg(&pdev->dev, "write msg[0].len=%u\n", msg[0].len);\r\nif (msg[0].len > 1 + 8) {\r\nret = -EOPNOTSUPP;\r\ngoto err;\r\n}\r\nret = zd1301_demod_wreg(dev, 0x6811, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6812, 0x01);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6813, msg[0].addr << 1);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6800, msg[0].buf[0]);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6802, 0x00);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6803, 0x06);\r\nif (ret)\r\ngoto err;\r\nfor (i = 0; i < msg[0].len - 1; i++) {\r\nret = zd1301_demod_wreg(dev, 0x0600 + i, msg[0].buf[1 + i]);\r\nif (ret)\r\ngoto err;\r\n}\r\nret = zd1301_demod_wreg(dev, 0x6805, 0x80);\r\nif (ret)\r\ngoto err;\r\nret = zd1301_demod_wreg(dev, 0x6804, msg[0].len - 1);\r\nif (ret)\r\ngoto err;\r\ntimeout = jiffies + msecs_to_jiffies(I2C_XFER_TIMEOUT);\r\nfor (u8tmp = 1; !time_after(jiffies, timeout) && u8tmp;) {\r\nusleep_range(500, 800);\r\nret = zd1301_demod_rreg(dev, 0x6804, &u8tmp);\r\nif (ret)\r\ngoto err;\r\n}\r\n} else {\r\ndev_dbg(&pdev->dev, "unknown msg[0].len=%u\n", msg[0].len);\r\nret = -EOPNOTSUPP;\r\nif (ret)\r\ngoto err;\r\n}\r\nreturn num;\r\nerr:\r\ndev_dbg(&pdev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic u32 zd1301_demod_i2c_functionality(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstruct i2c_adapter *zd1301_demod_get_i2c_adapter(struct platform_device *pdev)\r\n{\r\nstruct zd1301_demod_dev *dev = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "\n");\r\nreturn &dev->adapter;\r\n}\r\nstatic int zd1301_demod_probe(struct platform_device *pdev)\r\n{\r\nstruct zd1301_demod_dev *dev;\r\nstruct zd1301_demod_platform_data *pdata = pdev->dev.platform_data;\r\nint ret;\r\ndev_dbg(&pdev->dev, "\n");\r\nif (!pdata) {\r\nret = -EINVAL;\r\ndev_err(&pdev->dev, "cannot proceed without platform data\n");\r\ngoto err;\r\n}\r\nif (!pdev->dev.parent->driver) {\r\nret = -EINVAL;\r\ndev_dbg(&pdev->dev, "no parent device\n");\r\ngoto err;\r\n}\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev) {\r\nret = -ENOMEM;\r\ngoto err;\r\n}\r\ndev->pdev = pdev;\r\ndev->gain = zd1301_demod_gain;\r\nret = zd1301_demod_wreg(dev, 0x6840, 0x21);\r\nif (ret)\r\ngoto err_kfree;\r\nret = zd1301_demod_wreg(dev, 0x6a38, 0x07);\r\nif (ret)\r\ngoto err_kfree;\r\nstrlcpy(dev->adapter.name, "ZyDAS ZD1301 demod", sizeof(dev->adapter.name));\r\ndev->adapter.algo = &zd1301_demod_i2c_algorithm;\r\ndev->adapter.algo_data = NULL;\r\ndev->adapter.dev.parent = pdev->dev.parent;\r\ni2c_set_adapdata(&dev->adapter, dev);\r\nret = i2c_add_adapter(&dev->adapter);\r\nif (ret) {\r\ndev_err(&pdev->dev, "I2C adapter add failed %d\n", ret);\r\ngoto err_kfree;\r\n}\r\nmemcpy(&dev->frontend.ops, &zd1301_demod_ops, sizeof(dev->frontend.ops));\r\ndev->frontend.demodulator_priv = dev;\r\nplatform_set_drvdata(pdev, dev);\r\ndev_info(&pdev->dev, "ZyDAS ZD1301 demod attached\n");\r\nreturn 0;\r\nerr_kfree:\r\nkfree(dev);\r\nerr:\r\ndev_dbg(&pdev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int zd1301_demod_remove(struct platform_device *pdev)\r\n{\r\nstruct zd1301_demod_dev *dev = platform_get_drvdata(pdev);\r\ndev_dbg(&pdev->dev, "\n");\r\ni2c_del_adapter(&dev->adapter);\r\nkfree(dev);\r\nreturn 0;\r\n}
