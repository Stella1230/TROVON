static int crypto_pcbc_setkey(struct crypto_skcipher *parent, const u8 *key,\r\nunsigned int keylen)\r\n{\r\nstruct crypto_pcbc_ctx *ctx = crypto_skcipher_ctx(parent);\r\nstruct crypto_cipher *child = ctx->child;\r\nint err;\r\ncrypto_cipher_clear_flags(child, CRYPTO_TFM_REQ_MASK);\r\ncrypto_cipher_set_flags(child, crypto_skcipher_get_flags(parent) &\r\nCRYPTO_TFM_REQ_MASK);\r\nerr = crypto_cipher_setkey(child, key, keylen);\r\ncrypto_skcipher_set_flags(parent, crypto_cipher_get_flags(child) &\r\nCRYPTO_TFM_RES_MASK);\r\nreturn err;\r\n}\r\nstatic int crypto_pcbc_encrypt_segment(struct skcipher_request *req,\r\nstruct skcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nint bsize = crypto_cipher_blocksize(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nu8 *iv = walk->iv;\r\ndo {\r\ncrypto_xor(iv, src, bsize);\r\ncrypto_cipher_encrypt_one(tfm, dst, iv);\r\nmemcpy(iv, dst, bsize);\r\ncrypto_xor(iv, src, bsize);\r\nsrc += bsize;\r\ndst += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_pcbc_encrypt_inplace(struct skcipher_request *req,\r\nstruct skcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nint bsize = crypto_cipher_blocksize(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *iv = walk->iv;\r\nu8 tmpbuf[bsize];\r\ndo {\r\nmemcpy(tmpbuf, src, bsize);\r\ncrypto_xor(iv, src, bsize);\r\ncrypto_cipher_encrypt_one(tfm, src, iv);\r\nmemcpy(iv, tmpbuf, bsize);\r\ncrypto_xor(iv, src, bsize);\r\nsrc += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nmemcpy(walk->iv, iv, bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_pcbc_encrypt(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct crypto_pcbc_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nstruct skcipher_walk walk;\r\nunsigned int nbytes;\r\nint err;\r\nerr = skcipher_walk_virt(&walk, req, false);\r\nwhile ((nbytes = walk.nbytes)) {\r\nif (walk.src.virt.addr == walk.dst.virt.addr)\r\nnbytes = crypto_pcbc_encrypt_inplace(req, &walk,\r\nchild);\r\nelse\r\nnbytes = crypto_pcbc_encrypt_segment(req, &walk,\r\nchild);\r\nerr = skcipher_walk_done(&walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int crypto_pcbc_decrypt_segment(struct skcipher_request *req,\r\nstruct skcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nint bsize = crypto_cipher_blocksize(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *dst = walk->dst.virt.addr;\r\nu8 *iv = walk->iv;\r\ndo {\r\ncrypto_cipher_decrypt_one(tfm, dst, src);\r\ncrypto_xor(dst, iv, bsize);\r\nmemcpy(iv, src, bsize);\r\ncrypto_xor(iv, dst, bsize);\r\nsrc += bsize;\r\ndst += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nmemcpy(walk->iv, iv, bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_pcbc_decrypt_inplace(struct skcipher_request *req,\r\nstruct skcipher_walk *walk,\r\nstruct crypto_cipher *tfm)\r\n{\r\nint bsize = crypto_cipher_blocksize(tfm);\r\nunsigned int nbytes = walk->nbytes;\r\nu8 *src = walk->src.virt.addr;\r\nu8 *iv = walk->iv;\r\nu8 tmpbuf[bsize] __aligned(__alignof__(u32));\r\ndo {\r\nmemcpy(tmpbuf, src, bsize);\r\ncrypto_cipher_decrypt_one(tfm, src, src);\r\ncrypto_xor(src, iv, bsize);\r\nmemcpy(iv, tmpbuf, bsize);\r\ncrypto_xor(iv, src, bsize);\r\nsrc += bsize;\r\n} while ((nbytes -= bsize) >= bsize);\r\nmemcpy(walk->iv, iv, bsize);\r\nreturn nbytes;\r\n}\r\nstatic int crypto_pcbc_decrypt(struct skcipher_request *req)\r\n{\r\nstruct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);\r\nstruct crypto_pcbc_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_cipher *child = ctx->child;\r\nstruct skcipher_walk walk;\r\nunsigned int nbytes;\r\nint err;\r\nerr = skcipher_walk_virt(&walk, req, false);\r\nwhile ((nbytes = walk.nbytes)) {\r\nif (walk.src.virt.addr == walk.dst.virt.addr)\r\nnbytes = crypto_pcbc_decrypt_inplace(req, &walk,\r\nchild);\r\nelse\r\nnbytes = crypto_pcbc_decrypt_segment(req, &walk,\r\nchild);\r\nerr = skcipher_walk_done(&walk, nbytes);\r\n}\r\nreturn err;\r\n}\r\nstatic int crypto_pcbc_init_tfm(struct crypto_skcipher *tfm)\r\n{\r\nstruct skcipher_instance *inst = skcipher_alg_instance(tfm);\r\nstruct crypto_spawn *spawn = skcipher_instance_ctx(inst);\r\nstruct crypto_pcbc_ctx *ctx = crypto_skcipher_ctx(tfm);\r\nstruct crypto_cipher *cipher;\r\ncipher = crypto_spawn_cipher(spawn);\r\nif (IS_ERR(cipher))\r\nreturn PTR_ERR(cipher);\r\nctx->child = cipher;\r\nreturn 0;\r\n}\r\nstatic void crypto_pcbc_exit_tfm(struct crypto_skcipher *tfm)\r\n{\r\nstruct crypto_pcbc_ctx *ctx = crypto_skcipher_ctx(tfm);\r\ncrypto_free_cipher(ctx->child);\r\n}\r\nstatic void crypto_pcbc_free(struct skcipher_instance *inst)\r\n{\r\ncrypto_drop_skcipher(skcipher_instance_ctx(inst));\r\nkfree(inst);\r\n}\r\nstatic int crypto_pcbc_create(struct crypto_template *tmpl, struct rtattr **tb)\r\n{\r\nstruct skcipher_instance *inst;\r\nstruct crypto_attr_type *algt;\r\nstruct crypto_spawn *spawn;\r\nstruct crypto_alg *alg;\r\nint err;\r\nalgt = crypto_get_attr_type(tb);\r\nif (IS_ERR(algt))\r\nreturn PTR_ERR(algt);\r\nif (((algt->type ^ CRYPTO_ALG_TYPE_SKCIPHER) & algt->mask) &\r\n~CRYPTO_ALG_INTERNAL)\r\nreturn -EINVAL;\r\ninst = kzalloc(sizeof(*inst) + sizeof(*spawn), GFP_KERNEL);\r\nif (!inst)\r\nreturn -ENOMEM;\r\nalg = crypto_get_attr_alg(tb, CRYPTO_ALG_TYPE_CIPHER |\r\n(algt->type & CRYPTO_ALG_INTERNAL),\r\nCRYPTO_ALG_TYPE_MASK |\r\n(algt->mask & CRYPTO_ALG_INTERNAL));\r\nerr = PTR_ERR(alg);\r\nif (IS_ERR(alg))\r\ngoto err_free_inst;\r\nspawn = skcipher_instance_ctx(inst);\r\nerr = crypto_init_spawn(spawn, alg, skcipher_crypto_instance(inst),\r\nCRYPTO_ALG_TYPE_MASK);\r\ncrypto_mod_put(alg);\r\nif (err)\r\ngoto err_free_inst;\r\nerr = crypto_inst_setname(skcipher_crypto_instance(inst), "pcbc", alg);\r\nif (err)\r\ngoto err_drop_spawn;\r\ninst->alg.base.cra_flags = alg->cra_flags & CRYPTO_ALG_INTERNAL;\r\ninst->alg.base.cra_priority = alg->cra_priority;\r\ninst->alg.base.cra_blocksize = alg->cra_blocksize;\r\ninst->alg.base.cra_alignmask = alg->cra_alignmask;\r\ninst->alg.ivsize = alg->cra_blocksize;\r\ninst->alg.min_keysize = alg->cra_cipher.cia_min_keysize;\r\ninst->alg.max_keysize = alg->cra_cipher.cia_max_keysize;\r\ninst->alg.base.cra_ctxsize = sizeof(struct crypto_pcbc_ctx);\r\ninst->alg.init = crypto_pcbc_init_tfm;\r\ninst->alg.exit = crypto_pcbc_exit_tfm;\r\ninst->alg.setkey = crypto_pcbc_setkey;\r\ninst->alg.encrypt = crypto_pcbc_encrypt;\r\ninst->alg.decrypt = crypto_pcbc_decrypt;\r\ninst->free = crypto_pcbc_free;\r\nerr = skcipher_register_instance(tmpl, inst);\r\nif (err)\r\ngoto err_drop_spawn;\r\nout:\r\nreturn err;\r\nerr_drop_spawn:\r\ncrypto_drop_spawn(spawn);\r\nerr_free_inst:\r\nkfree(inst);\r\ngoto out;\r\n}\r\nstatic int __init crypto_pcbc_module_init(void)\r\n{\r\nreturn crypto_register_template(&crypto_pcbc_tmpl);\r\n}\r\nstatic void __exit crypto_pcbc_module_exit(void)\r\n{\r\ncrypto_unregister_template(&crypto_pcbc_tmpl);\r\n}
