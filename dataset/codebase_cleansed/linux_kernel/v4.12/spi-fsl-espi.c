static inline u32 fsl_espi_read_reg(struct fsl_espi *espi, int offset)\r\n{\r\nreturn ioread32be(espi->reg_base + offset);\r\n}\r\nstatic inline u16 fsl_espi_read_reg16(struct fsl_espi *espi, int offset)\r\n{\r\nreturn ioread16be(espi->reg_base + offset);\r\n}\r\nstatic inline u8 fsl_espi_read_reg8(struct fsl_espi *espi, int offset)\r\n{\r\nreturn ioread8(espi->reg_base + offset);\r\n}\r\nstatic inline void fsl_espi_write_reg(struct fsl_espi *espi, int offset,\r\nu32 val)\r\n{\r\niowrite32be(val, espi->reg_base + offset);\r\n}\r\nstatic inline void fsl_espi_write_reg16(struct fsl_espi *espi, int offset,\r\nu16 val)\r\n{\r\niowrite16be(val, espi->reg_base + offset);\r\n}\r\nstatic inline void fsl_espi_write_reg8(struct fsl_espi *espi, int offset,\r\nu8 val)\r\n{\r\niowrite8(val, espi->reg_base + offset);\r\n}\r\nstatic int fsl_espi_check_message(struct spi_message *m)\r\n{\r\nstruct fsl_espi *espi = spi_master_get_devdata(m->spi->master);\r\nstruct spi_transfer *t, *first;\r\nif (m->frame_length > SPCOM_TRANLEN_MAX) {\r\ndev_err(espi->dev, "message too long, size is %u bytes\n",\r\nm->frame_length);\r\nreturn -EMSGSIZE;\r\n}\r\nfirst = list_first_entry(&m->transfers, struct spi_transfer,\r\ntransfer_list);\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (first->bits_per_word != t->bits_per_word ||\r\nfirst->speed_hz != t->speed_hz) {\r\ndev_err(espi->dev, "bits_per_word/speed_hz should be the same for all transfers\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (!(m->spi->mode & SPI_LSB_FIRST) && first->bits_per_word != 8 &&\r\nfirst->bits_per_word != 16) {\r\ndev_err(espi->dev,\r\n"MSB-first transfer not supported for wordsize %u\n",\r\nfirst->bits_per_word);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic unsigned int fsl_espi_check_rxskip_mode(struct spi_message *m)\r\n{\r\nstruct spi_transfer *t;\r\nunsigned int i = 0, rxskip = 0;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (i == 0) {\r\nif (!t->tx_buf || t->rx_buf ||\r\nt->len > FSL_ESPI_FIFO_SIZE)\r\nreturn 0;\r\nrxskip = t->len;\r\n} else if (i == 1) {\r\nif (t->tx_buf || !t->rx_buf)\r\nreturn 0;\r\n}\r\ni++;\r\n}\r\nreturn i == 2 ? rxskip : 0;\r\n}\r\nstatic void fsl_espi_fill_tx_fifo(struct fsl_espi *espi, u32 events)\r\n{\r\nu32 tx_fifo_avail;\r\nunsigned int tx_left;\r\nconst void *tx_buf;\r\ntx_fifo_avail = events ? SPIE_TXCNT(events) : FSL_ESPI_FIFO_SIZE;\r\nstart:\r\ntx_left = espi->tx_t->len - espi->tx_pos;\r\ntx_buf = espi->tx_t->tx_buf;\r\nwhile (tx_fifo_avail >= min(4U, tx_left) && tx_left) {\r\nif (tx_left >= 4) {\r\nif (!tx_buf)\r\nfsl_espi_write_reg(espi, ESPI_SPITF, 0);\r\nelse if (espi->swab)\r\nfsl_espi_write_reg(espi, ESPI_SPITF,\r\nswahb32p(tx_buf + espi->tx_pos));\r\nelse\r\nfsl_espi_write_reg(espi, ESPI_SPITF,\r\n*(u32 *)(tx_buf + espi->tx_pos));\r\nespi->tx_pos += 4;\r\ntx_left -= 4;\r\ntx_fifo_avail -= 4;\r\n} else if (tx_left >= 2 && tx_buf && espi->swab) {\r\nfsl_espi_write_reg16(espi, ESPI_SPITF,\r\nswab16p(tx_buf + espi->tx_pos));\r\nespi->tx_pos += 2;\r\ntx_left -= 2;\r\ntx_fifo_avail -= 2;\r\n} else {\r\nif (!tx_buf)\r\nfsl_espi_write_reg8(espi, ESPI_SPITF, 0);\r\nelse\r\nfsl_espi_write_reg8(espi, ESPI_SPITF,\r\n*(u8 *)(tx_buf + espi->tx_pos));\r\nespi->tx_pos += 1;\r\ntx_left -= 1;\r\ntx_fifo_avail -= 1;\r\n}\r\n}\r\nif (!tx_left) {\r\nif (list_is_last(&espi->tx_t->transfer_list,\r\nespi->m_transfers) || espi->rxskip) {\r\nespi->tx_done = true;\r\nreturn;\r\n}\r\nespi->tx_t = list_next_entry(espi->tx_t, transfer_list);\r\nespi->tx_pos = 0;\r\nif (tx_fifo_avail)\r\ngoto start;\r\n}\r\n}\r\nstatic void fsl_espi_read_rx_fifo(struct fsl_espi *espi, u32 events)\r\n{\r\nu32 rx_fifo_avail = SPIE_RXCNT(events);\r\nunsigned int rx_left;\r\nvoid *rx_buf;\r\nstart:\r\nrx_left = espi->rx_t->len - espi->rx_pos;\r\nrx_buf = espi->rx_t->rx_buf;\r\nwhile (rx_fifo_avail >= min(4U, rx_left) && rx_left) {\r\nif (rx_left >= 4) {\r\nu32 val = fsl_espi_read_reg(espi, ESPI_SPIRF);\r\nif (rx_buf && espi->swab)\r\n*(u32 *)(rx_buf + espi->rx_pos) = swahb32(val);\r\nelse if (rx_buf)\r\n*(u32 *)(rx_buf + espi->rx_pos) = val;\r\nespi->rx_pos += 4;\r\nrx_left -= 4;\r\nrx_fifo_avail -= 4;\r\n} else if (rx_left >= 2 && rx_buf && espi->swab) {\r\nu16 val = fsl_espi_read_reg16(espi, ESPI_SPIRF);\r\n*(u16 *)(rx_buf + espi->rx_pos) = swab16(val);\r\nespi->rx_pos += 2;\r\nrx_left -= 2;\r\nrx_fifo_avail -= 2;\r\n} else {\r\nu8 val = fsl_espi_read_reg8(espi, ESPI_SPIRF);\r\nif (rx_buf)\r\n*(u8 *)(rx_buf + espi->rx_pos) = val;\r\nespi->rx_pos += 1;\r\nrx_left -= 1;\r\nrx_fifo_avail -= 1;\r\n}\r\n}\r\nif (!rx_left) {\r\nif (list_is_last(&espi->rx_t->transfer_list,\r\nespi->m_transfers)) {\r\nespi->rx_done = true;\r\nreturn;\r\n}\r\nespi->rx_t = list_next_entry(espi->rx_t, transfer_list);\r\nespi->rx_pos = 0;\r\nif (rx_fifo_avail)\r\ngoto start;\r\n}\r\n}\r\nstatic void fsl_espi_setup_transfer(struct spi_device *spi,\r\nstruct spi_transfer *t)\r\n{\r\nstruct fsl_espi *espi = spi_master_get_devdata(spi->master);\r\nint bits_per_word = t ? t->bits_per_word : spi->bits_per_word;\r\nu32 pm, hz = t ? t->speed_hz : spi->max_speed_hz;\r\nstruct fsl_espi_cs *cs = spi_get_ctldata(spi);\r\nu32 hw_mode_old = cs->hw_mode;\r\ncs->hw_mode &= ~(CSMODE_LEN(0xF) | CSMODE_DIV16 | CSMODE_PM(0xF));\r\ncs->hw_mode |= CSMODE_LEN(bits_per_word - 1);\r\npm = DIV_ROUND_UP(espi->spibrg, hz * 4) - 1;\r\nif (pm > 15) {\r\ncs->hw_mode |= CSMODE_DIV16;\r\npm = DIV_ROUND_UP(espi->spibrg, hz * 16 * 4) - 1;\r\n}\r\ncs->hw_mode |= CSMODE_PM(pm);\r\nif (cs->hw_mode != hw_mode_old)\r\nfsl_espi_write_reg(espi, ESPI_SPMODEx(spi->chip_select),\r\ncs->hw_mode);\r\n}\r\nstatic int fsl_espi_bufs(struct spi_device *spi, struct spi_transfer *t)\r\n{\r\nstruct fsl_espi *espi = spi_master_get_devdata(spi->master);\r\nunsigned int rx_len = t->len;\r\nu32 mask, spcom;\r\nint ret;\r\nreinit_completion(&espi->done);\r\nspcom = SPCOM_CS(spi->chip_select);\r\nspcom |= SPCOM_TRANLEN(t->len - 1);\r\nif (espi->rxskip) {\r\nspcom |= SPCOM_RXSKIP(espi->rxskip);\r\nrx_len = t->len - espi->rxskip;\r\nif (t->rx_nbits == SPI_NBITS_DUAL)\r\nspcom |= SPCOM_DO;\r\n}\r\nfsl_espi_write_reg(espi, ESPI_SPCOM, spcom);\r\nmask = SPIM_DON;\r\nif (rx_len > FSL_ESPI_FIFO_SIZE)\r\nmask |= SPIM_RXT;\r\nfsl_espi_write_reg(espi, ESPI_SPIM, mask);\r\nspin_lock_irq(&espi->lock);\r\nfsl_espi_fill_tx_fifo(espi, 0);\r\nspin_unlock_irq(&espi->lock);\r\nret = wait_for_completion_timeout(&espi->done, 2 * HZ);\r\nif (ret == 0)\r\ndev_err(espi->dev, "Transfer timed out!\n");\r\nfsl_espi_write_reg(espi, ESPI_SPIM, 0);\r\nreturn ret == 0 ? -ETIMEDOUT : 0;\r\n}\r\nstatic int fsl_espi_trans(struct spi_message *m, struct spi_transfer *trans)\r\n{\r\nstruct fsl_espi *espi = spi_master_get_devdata(m->spi->master);\r\nstruct spi_device *spi = m->spi;\r\nint ret;\r\nespi->swab = spi->mode & SPI_LSB_FIRST && trans->bits_per_word > 8;\r\nespi->m_transfers = &m->transfers;\r\nespi->tx_t = list_first_entry(&m->transfers, struct spi_transfer,\r\ntransfer_list);\r\nespi->tx_pos = 0;\r\nespi->tx_done = false;\r\nespi->rx_t = list_first_entry(&m->transfers, struct spi_transfer,\r\ntransfer_list);\r\nespi->rx_pos = 0;\r\nespi->rx_done = false;\r\nespi->rxskip = fsl_espi_check_rxskip_mode(m);\r\nif (trans->rx_nbits == SPI_NBITS_DUAL && !espi->rxskip) {\r\ndev_err(espi->dev, "Dual output mode requires RXSKIP mode!\n");\r\nreturn -EINVAL;\r\n}\r\nif (espi->rxskip)\r\nespi->rx_t = list_next_entry(espi->rx_t, transfer_list);\r\nfsl_espi_setup_transfer(spi, trans);\r\nret = fsl_espi_bufs(spi, trans);\r\nif (trans->delay_usecs)\r\nudelay(trans->delay_usecs);\r\nreturn ret;\r\n}\r\nstatic int fsl_espi_do_one_msg(struct spi_master *master,\r\nstruct spi_message *m)\r\n{\r\nunsigned int delay_usecs = 0, rx_nbits = 0;\r\nstruct spi_transfer *t, trans = {};\r\nint ret;\r\nret = fsl_espi_check_message(m);\r\nif (ret)\r\ngoto out;\r\nlist_for_each_entry(t, &m->transfers, transfer_list) {\r\nif (t->delay_usecs > delay_usecs)\r\ndelay_usecs = t->delay_usecs;\r\nif (t->rx_nbits > rx_nbits)\r\nrx_nbits = t->rx_nbits;\r\n}\r\nt = list_first_entry(&m->transfers, struct spi_transfer,\r\ntransfer_list);\r\ntrans.len = m->frame_length;\r\ntrans.speed_hz = t->speed_hz;\r\ntrans.bits_per_word = t->bits_per_word;\r\ntrans.delay_usecs = delay_usecs;\r\ntrans.rx_nbits = rx_nbits;\r\nif (trans.len)\r\nret = fsl_espi_trans(m, &trans);\r\nm->actual_length = ret ? 0 : trans.len;\r\nout:\r\nif (m->status == -EINPROGRESS)\r\nm->status = ret;\r\nspi_finalize_current_message(master);\r\nreturn ret;\r\n}\r\nstatic int fsl_espi_setup(struct spi_device *spi)\r\n{\r\nstruct fsl_espi *espi;\r\nu32 loop_mode;\r\nstruct fsl_espi_cs *cs = spi_get_ctldata(spi);\r\nif (!cs) {\r\ncs = kzalloc(sizeof(*cs), GFP_KERNEL);\r\nif (!cs)\r\nreturn -ENOMEM;\r\nspi_set_ctldata(spi, cs);\r\n}\r\nespi = spi_master_get_devdata(spi->master);\r\npm_runtime_get_sync(espi->dev);\r\ncs->hw_mode = fsl_espi_read_reg(espi, ESPI_SPMODEx(spi->chip_select));\r\ncs->hw_mode &= ~(CSMODE_CP_BEGIN_EDGECLK | CSMODE_CI_INACTIVEHIGH\r\n| CSMODE_REV);\r\nif (spi->mode & SPI_CPHA)\r\ncs->hw_mode |= CSMODE_CP_BEGIN_EDGECLK;\r\nif (spi->mode & SPI_CPOL)\r\ncs->hw_mode |= CSMODE_CI_INACTIVEHIGH;\r\nif (!(spi->mode & SPI_LSB_FIRST))\r\ncs->hw_mode |= CSMODE_REV;\r\nloop_mode = fsl_espi_read_reg(espi, ESPI_SPMODE);\r\nloop_mode &= ~SPMODE_LOOP;\r\nif (spi->mode & SPI_LOOP)\r\nloop_mode |= SPMODE_LOOP;\r\nfsl_espi_write_reg(espi, ESPI_SPMODE, loop_mode);\r\nfsl_espi_setup_transfer(spi, NULL);\r\npm_runtime_mark_last_busy(espi->dev);\r\npm_runtime_put_autosuspend(espi->dev);\r\nreturn 0;\r\n}\r\nstatic void fsl_espi_cleanup(struct spi_device *spi)\r\n{\r\nstruct fsl_espi_cs *cs = spi_get_ctldata(spi);\r\nkfree(cs);\r\nspi_set_ctldata(spi, NULL);\r\n}\r\nstatic void fsl_espi_cpu_irq(struct fsl_espi *espi, u32 events)\r\n{\r\nif (!espi->rx_done)\r\nfsl_espi_read_rx_fifo(espi, events);\r\nif (!espi->tx_done)\r\nfsl_espi_fill_tx_fifo(espi, events);\r\nif (!espi->tx_done || !espi->rx_done)\r\nreturn;\r\nevents = fsl_espi_read_reg(espi, ESPI_SPIE);\r\nif (!(events & SPIE_DON))\r\ndev_err(espi->dev,\r\n"Transfer done but SPIE_DON isn't set!\n");\r\nif (SPIE_RXCNT(events) || SPIE_TXCNT(events) != FSL_ESPI_FIFO_SIZE)\r\ndev_err(espi->dev, "Transfer done but rx/tx fifo's aren't empty!\n");\r\ncomplete(&espi->done);\r\n}\r\nstatic irqreturn_t fsl_espi_irq(s32 irq, void *context_data)\r\n{\r\nstruct fsl_espi *espi = context_data;\r\nu32 events;\r\nspin_lock(&espi->lock);\r\nevents = fsl_espi_read_reg(espi, ESPI_SPIE);\r\nif (!events) {\r\nspin_unlock(&espi->lock);\r\nreturn IRQ_NONE;\r\n}\r\ndev_vdbg(espi->dev, "%s: events %x\n", __func__, events);\r\nfsl_espi_cpu_irq(espi, events);\r\nfsl_espi_write_reg(espi, ESPI_SPIE, events);\r\nspin_unlock(&espi->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int fsl_espi_runtime_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_espi *espi = spi_master_get_devdata(master);\r\nu32 regval;\r\nregval = fsl_espi_read_reg(espi, ESPI_SPMODE);\r\nregval &= ~SPMODE_ENABLE;\r\nfsl_espi_write_reg(espi, ESPI_SPMODE, regval);\r\nreturn 0;\r\n}\r\nstatic int fsl_espi_runtime_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_espi *espi = spi_master_get_devdata(master);\r\nu32 regval;\r\nregval = fsl_espi_read_reg(espi, ESPI_SPMODE);\r\nregval |= SPMODE_ENABLE;\r\nfsl_espi_write_reg(espi, ESPI_SPMODE, regval);\r\nreturn 0;\r\n}\r\nstatic size_t fsl_espi_max_message_size(struct spi_device *spi)\r\n{\r\nreturn SPCOM_TRANLEN_MAX;\r\n}\r\nstatic void fsl_espi_init_regs(struct device *dev, bool initial)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nstruct fsl_espi *espi = spi_master_get_devdata(master);\r\nstruct device_node *nc;\r\nu32 csmode, cs, prop;\r\nint ret;\r\nfsl_espi_write_reg(espi, ESPI_SPMODE, 0);\r\nfsl_espi_write_reg(espi, ESPI_SPIM, 0);\r\nfsl_espi_write_reg(espi, ESPI_SPCOM, 0);\r\nfsl_espi_write_reg(espi, ESPI_SPIE, 0xffffffff);\r\nfor_each_available_child_of_node(master->dev.of_node, nc) {\r\nret = of_property_read_u32(nc, "reg", &cs);\r\nif (ret || cs >= master->num_chipselect)\r\ncontinue;\r\ncsmode = CSMODE_INIT_VAL;\r\nret = of_property_read_u32(nc, "fsl,csbef", &prop);\r\nif (!ret) {\r\ncsmode &= ~(CSMODE_BEF(0xf));\r\ncsmode |= CSMODE_BEF(prop);\r\n}\r\nret = of_property_read_u32(nc, "fsl,csaft", &prop);\r\nif (!ret) {\r\ncsmode &= ~(CSMODE_AFT(0xf));\r\ncsmode |= CSMODE_AFT(prop);\r\n}\r\nfsl_espi_write_reg(espi, ESPI_SPMODEx(cs), csmode);\r\nif (initial)\r\ndev_info(dev, "cs=%u, init_csmode=0x%x\n", cs, csmode);\r\n}\r\nfsl_espi_write_reg(espi, ESPI_SPMODE, SPMODE_INIT_VAL | SPMODE_ENABLE);\r\n}\r\nstatic int fsl_espi_probe(struct device *dev, struct resource *mem,\r\nunsigned int irq, unsigned int num_cs)\r\n{\r\nstruct spi_master *master;\r\nstruct fsl_espi *espi;\r\nint ret;\r\nmaster = spi_alloc_master(dev, sizeof(struct fsl_espi));\r\nif (!master)\r\nreturn -ENOMEM;\r\ndev_set_drvdata(dev, master);\r\nmaster->mode_bits = SPI_RX_DUAL | SPI_CPOL | SPI_CPHA | SPI_CS_HIGH |\r\nSPI_LSB_FIRST | SPI_LOOP;\r\nmaster->dev.of_node = dev->of_node;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\r\nmaster->setup = fsl_espi_setup;\r\nmaster->cleanup = fsl_espi_cleanup;\r\nmaster->transfer_one_message = fsl_espi_do_one_msg;\r\nmaster->auto_runtime_pm = true;\r\nmaster->max_message_size = fsl_espi_max_message_size;\r\nmaster->num_chipselect = num_cs;\r\nespi = spi_master_get_devdata(master);\r\nspin_lock_init(&espi->lock);\r\nespi->dev = dev;\r\nespi->spibrg = fsl_get_sys_freq();\r\nif (espi->spibrg == -1) {\r\ndev_err(dev, "Can't get sys frequency!\n");\r\nret = -EINVAL;\r\ngoto err_probe;\r\n}\r\nmaster->min_speed_hz = DIV_ROUND_UP(espi->spibrg, 4 * 16 * 16);\r\nmaster->max_speed_hz = DIV_ROUND_UP(espi->spibrg, 4);\r\ninit_completion(&espi->done);\r\nespi->reg_base = devm_ioremap_resource(dev, mem);\r\nif (IS_ERR(espi->reg_base)) {\r\nret = PTR_ERR(espi->reg_base);\r\ngoto err_probe;\r\n}\r\nret = devm_request_irq(dev, irq, fsl_espi_irq, 0, "fsl_espi", espi);\r\nif (ret)\r\ngoto err_probe;\r\nfsl_espi_init_regs(dev, true);\r\npm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_TIMEOUT);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_get_sync(dev);\r\nret = devm_spi_register_master(dev, master);\r\nif (ret < 0)\r\ngoto err_pm;\r\ndev_info(dev, "at 0x%p (irq = %u)\n", espi->reg_base, irq);\r\npm_runtime_mark_last_busy(dev);\r\npm_runtime_put_autosuspend(dev);\r\nreturn 0;\r\nerr_pm:\r\npm_runtime_put_noidle(dev);\r\npm_runtime_disable(dev);\r\npm_runtime_set_suspended(dev);\r\nerr_probe:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int of_fsl_espi_get_chipselects(struct device *dev)\r\n{\r\nstruct device_node *np = dev->of_node;\r\nu32 num_cs;\r\nint ret;\r\nret = of_property_read_u32(np, "fsl,espi-num-chipselects", &num_cs);\r\nif (ret) {\r\ndev_err(dev, "No 'fsl,espi-num-chipselects' property\n");\r\nreturn 0;\r\n}\r\nreturn num_cs;\r\n}\r\nstatic int of_fsl_espi_probe(struct platform_device *ofdev)\r\n{\r\nstruct device *dev = &ofdev->dev;\r\nstruct device_node *np = ofdev->dev.of_node;\r\nstruct resource mem;\r\nunsigned int irq, num_cs;\r\nint ret;\r\nif (of_property_read_bool(np, "mode")) {\r\ndev_err(dev, "mode property is not supported on ESPI!\n");\r\nreturn -EINVAL;\r\n}\r\nnum_cs = of_fsl_espi_get_chipselects(dev);\r\nif (!num_cs)\r\nreturn -EINVAL;\r\nret = of_address_to_resource(np, 0, &mem);\r\nif (ret)\r\nreturn ret;\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq)\r\nreturn -EINVAL;\r\nreturn fsl_espi_probe(dev, &mem, irq, num_cs);\r\n}\r\nstatic int of_fsl_espi_remove(struct platform_device *dev)\r\n{\r\npm_runtime_disable(&dev->dev);\r\nreturn 0;\r\n}\r\nstatic int of_fsl_espi_suspend(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nint ret;\r\nret = spi_master_suspend(master);\r\nif (ret) {\r\ndev_warn(dev, "cannot suspend master\n");\r\nreturn ret;\r\n}\r\nreturn pm_runtime_force_suspend(dev);\r\n}\r\nstatic int of_fsl_espi_resume(struct device *dev)\r\n{\r\nstruct spi_master *master = dev_get_drvdata(dev);\r\nint ret;\r\nfsl_espi_init_regs(dev, false);\r\nret = pm_runtime_force_resume(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn spi_master_resume(master);\r\n}
