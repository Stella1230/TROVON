const char *sti_mixer_to_str(struct sti_mixer *mixer)\r\n{\r\nswitch (mixer->id) {\r\ncase STI_MIXER_MAIN:\r\nreturn "MAIN_MIXER";\r\ncase STI_MIXER_AUX:\r\nreturn "AUX_MIXER";\r\ndefault:\r\nreturn "<UNKNOWN MIXER>";\r\n}\r\n}\r\nstatic inline u32 sti_mixer_reg_read(struct sti_mixer *mixer, u32 reg_id)\r\n{\r\nreturn readl(mixer->regs + reg_id);\r\n}\r\nstatic inline void sti_mixer_reg_write(struct sti_mixer *mixer,\r\nu32 reg_id, u32 val)\r\n{\r\nwritel(val, mixer->regs + reg_id);\r\n}\r\nstatic void mixer_dbg_ctl(struct seq_file *s, int val)\r\n{\r\nunsigned int i;\r\nint count = 0;\r\nchar *const disp_layer[] = {"BKG", "VID0", "VID1", "GDP0",\r\n"GDP1", "GDP2", "GDP3"};\r\nseq_puts(s, "\tEnabled: ");\r\nfor (i = 0; i < 7; i++) {\r\nif (val & 1) {\r\nseq_printf(s, "%s ", disp_layer[i]);\r\ncount++;\r\n}\r\nval = val >> 1;\r\n}\r\nval = val >> 2;\r\nif (val & 1) {\r\nseq_puts(s, "CURS ");\r\ncount++;\r\n}\r\nif (!count)\r\nseq_puts(s, "Nothing");\r\n}\r\nstatic void mixer_dbg_crb(struct seq_file *s, int val)\r\n{\r\nint i;\r\nseq_puts(s, "\tDepth: ");\r\nfor (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {\r\nswitch (val & GAM_DEPTH_MASK_ID) {\r\ncase GAM_DEPTH_VID0_ID:\r\nseq_puts(s, "VID0");\r\nbreak;\r\ncase GAM_DEPTH_VID1_ID:\r\nseq_puts(s, "VID1");\r\nbreak;\r\ncase GAM_DEPTH_GDP0_ID:\r\nseq_puts(s, "GDP0");\r\nbreak;\r\ncase GAM_DEPTH_GDP1_ID:\r\nseq_puts(s, "GDP1");\r\nbreak;\r\ncase GAM_DEPTH_GDP2_ID:\r\nseq_puts(s, "GDP2");\r\nbreak;\r\ncase GAM_DEPTH_GDP3_ID:\r\nseq_puts(s, "GDP3");\r\nbreak;\r\ndefault:\r\nseq_puts(s, "---");\r\n}\r\nif (i < GAM_MIXER_NB_DEPTH_LEVEL - 1)\r\nseq_puts(s, " < ");\r\nval = val >> 3;\r\n}\r\n}\r\nstatic void mixer_dbg_mxn(struct seq_file *s, void *addr)\r\n{\r\nint i;\r\nfor (i = 1; i < 8; i++)\r\nseq_printf(s, "-0x%08X", (int)readl(addr + i * 4));\r\n}\r\nstatic int mixer_dbg_show(struct seq_file *s, void *arg)\r\n{\r\nstruct drm_info_node *node = s->private;\r\nstruct sti_mixer *mixer = (struct sti_mixer *)node->info_ent->data;\r\nseq_printf(s, "%s: (vaddr = 0x%p)",\r\nsti_mixer_to_str(mixer), mixer->regs);\r\nDBGFS_DUMP(GAM_MIXER_CTL);\r\nmixer_dbg_ctl(s, sti_mixer_reg_read(mixer, GAM_MIXER_CTL));\r\nDBGFS_DUMP(GAM_MIXER_BKC);\r\nDBGFS_DUMP(GAM_MIXER_BCO);\r\nDBGFS_DUMP(GAM_MIXER_BCS);\r\nDBGFS_DUMP(GAM_MIXER_AVO);\r\nDBGFS_DUMP(GAM_MIXER_AVS);\r\nDBGFS_DUMP(GAM_MIXER_CRB);\r\nmixer_dbg_crb(s, sti_mixer_reg_read(mixer, GAM_MIXER_CRB));\r\nDBGFS_DUMP(GAM_MIXER_ACT);\r\nDBGFS_DUMP(GAM_MIXER_MBP);\r\nDBGFS_DUMP(GAM_MIXER_MX0);\r\nmixer_dbg_mxn(s, mixer->regs + GAM_MIXER_MX0);\r\nseq_puts(s, "\n");\r\nreturn 0;\r\n}\r\nint sti_mixer_debugfs_init(struct sti_mixer *mixer, struct drm_minor *minor)\r\n{\r\nunsigned int i;\r\nstruct drm_info_list *mixer_debugfs_files;\r\nint nb_files;\r\nswitch (mixer->id) {\r\ncase STI_MIXER_MAIN:\r\nmixer_debugfs_files = mixer0_debugfs_files;\r\nnb_files = ARRAY_SIZE(mixer0_debugfs_files);\r\nbreak;\r\ncase STI_MIXER_AUX:\r\nmixer_debugfs_files = mixer1_debugfs_files;\r\nnb_files = ARRAY_SIZE(mixer1_debugfs_files);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < nb_files; i++)\r\nmixer_debugfs_files[i].data = mixer;\r\nreturn drm_debugfs_create_files(mixer_debugfs_files,\r\nnb_files,\r\nminor->debugfs_root, minor);\r\n}\r\nvoid sti_mixer_set_background_status(struct sti_mixer *mixer, bool enable)\r\n{\r\nu32 val = sti_mixer_reg_read(mixer, GAM_MIXER_CTL);\r\nval &= ~GAM_CTL_BACK_MASK;\r\nval |= enable;\r\nsti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);\r\n}\r\nstatic void sti_mixer_set_background_color(struct sti_mixer *mixer,\r\nunsigned int rgb)\r\n{\r\nsti_mixer_reg_write(mixer, GAM_MIXER_BKC, rgb);\r\n}\r\nstatic void sti_mixer_set_background_area(struct sti_mixer *mixer,\r\nstruct drm_display_mode *mode)\r\n{\r\nu32 ydo, xdo, yds, xds;\r\nydo = sti_vtg_get_line_number(*mode, 0);\r\nyds = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, 0);\r\nxds = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_BCO, ydo << 16 | xdo);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_BCS, yds << 16 | xds);\r\n}\r\nint sti_mixer_set_plane_depth(struct sti_mixer *mixer, struct sti_plane *plane)\r\n{\r\nint plane_id, depth = plane->drm_plane.state->normalized_zpos;\r\nunsigned int i;\r\nu32 mask, val;\r\nswitch (plane->desc) {\r\ncase STI_GDP_0:\r\nplane_id = GAM_DEPTH_GDP0_ID;\r\nbreak;\r\ncase STI_GDP_1:\r\nplane_id = GAM_DEPTH_GDP1_ID;\r\nbreak;\r\ncase STI_GDP_2:\r\nplane_id = GAM_DEPTH_GDP2_ID;\r\nbreak;\r\ncase STI_GDP_3:\r\nplane_id = GAM_DEPTH_GDP3_ID;\r\nbreak;\r\ncase STI_HQVDP_0:\r\nplane_id = GAM_DEPTH_VID0_ID;\r\nbreak;\r\ncase STI_CURSOR:\r\nreturn 0;\r\ndefault:\r\nDRM_ERROR("Unknown plane %d\n", plane->desc);\r\nreturn 1;\r\n}\r\nval = sti_mixer_reg_read(mixer, GAM_MIXER_CRB);\r\nfor (i = 0; i < GAM_MIXER_NB_DEPTH_LEVEL; i++) {\r\nmask = GAM_DEPTH_MASK_ID << (3 * i);\r\nif ((val & mask) == plane_id << (3 * i))\r\nbreak;\r\n}\r\nmask |= GAM_DEPTH_MASK_ID << (3 * depth);\r\nplane_id = plane_id << (3 * depth);\r\nDRM_DEBUG_DRIVER("%s %s depth=%d\n", sti_mixer_to_str(mixer),\r\nsti_plane_to_str(plane), depth);\r\ndev_dbg(mixer->dev, "GAM_MIXER_CRB val 0x%x mask 0x%x\n",\r\nplane_id, mask);\r\nval &= ~mask;\r\nval |= plane_id;\r\nsti_mixer_reg_write(mixer, GAM_MIXER_CRB, val);\r\ndev_dbg(mixer->dev, "Read GAM_MIXER_CRB 0x%x\n",\r\nsti_mixer_reg_read(mixer, GAM_MIXER_CRB));\r\nreturn 0;\r\n}\r\nint sti_mixer_active_video_area(struct sti_mixer *mixer,\r\nstruct drm_display_mode *mode)\r\n{\r\nu32 ydo, xdo, yds, xds;\r\nydo = sti_vtg_get_line_number(*mode, 0);\r\nyds = sti_vtg_get_line_number(*mode, mode->vdisplay - 1);\r\nxdo = sti_vtg_get_pixel_number(*mode, 0);\r\nxds = sti_vtg_get_pixel_number(*mode, mode->hdisplay - 1);\r\nDRM_DEBUG_DRIVER("%s active video area xdo:%d ydo:%d xds:%d yds:%d\n",\r\nsti_mixer_to_str(mixer), xdo, ydo, xds, yds);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_AVO, ydo << 16 | xdo);\r\nsti_mixer_reg_write(mixer, GAM_MIXER_AVS, yds << 16 | xds);\r\nsti_mixer_set_background_color(mixer, bkg_color);\r\nsti_mixer_set_background_area(mixer, mode);\r\nsti_mixer_set_background_status(mixer, true);\r\nreturn 0;\r\n}\r\nstatic u32 sti_mixer_get_plane_mask(struct sti_plane *plane)\r\n{\r\nswitch (plane->desc) {\r\ncase STI_BACK:\r\nreturn GAM_CTL_BACK_MASK;\r\ncase STI_GDP_0:\r\nreturn GAM_CTL_GDP0_MASK;\r\ncase STI_GDP_1:\r\nreturn GAM_CTL_GDP1_MASK;\r\ncase STI_GDP_2:\r\nreturn GAM_CTL_GDP2_MASK;\r\ncase STI_GDP_3:\r\nreturn GAM_CTL_GDP3_MASK;\r\ncase STI_HQVDP_0:\r\nreturn GAM_CTL_VID0_MASK;\r\ncase STI_CURSOR:\r\nreturn GAM_CTL_CURSOR_MASK;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nint sti_mixer_set_plane_status(struct sti_mixer *mixer,\r\nstruct sti_plane *plane, bool status)\r\n{\r\nu32 mask, val;\r\nDRM_DEBUG_DRIVER("%s %s %s\n", status ? "enable" : "disable",\r\nsti_mixer_to_str(mixer), sti_plane_to_str(plane));\r\nmask = sti_mixer_get_plane_mask(plane);\r\nif (!mask) {\r\nDRM_ERROR("Can't find layer mask\n");\r\nreturn -EINVAL;\r\n}\r\nval = sti_mixer_reg_read(mixer, GAM_MIXER_CTL);\r\nval &= ~mask;\r\nval |= status ? mask : 0;\r\nsti_mixer_reg_write(mixer, GAM_MIXER_CTL, val);\r\nreturn 0;\r\n}\r\nstruct sti_mixer *sti_mixer_create(struct device *dev,\r\nstruct drm_device *drm_dev,\r\nint id,\r\nvoid __iomem *baseaddr)\r\n{\r\nstruct sti_mixer *mixer = devm_kzalloc(dev, sizeof(*mixer), GFP_KERNEL);\r\ndev_dbg(dev, "%s\n", __func__);\r\nif (!mixer) {\r\nDRM_ERROR("Failed to allocated memory for mixer\n");\r\nreturn NULL;\r\n}\r\nmixer->regs = baseaddr;\r\nmixer->dev = dev;\r\nmixer->id = id;\r\nDRM_DEBUG_DRIVER("%s created. Regs=%p\n",\r\nsti_mixer_to_str(mixer), mixer->regs);\r\nreturn mixer;\r\n}
