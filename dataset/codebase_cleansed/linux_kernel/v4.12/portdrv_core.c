static int __init pciehp_setup(char *str)\r\n{\r\nif (!strncmp(str, "nomsi", 5))\r\npciehp_msi_disabled = true;\r\nreturn 1;\r\n}\r\nstatic void release_pcie_device(struct device *dev)\r\n{\r\nkfree(to_pcie_device(dev));\r\n}\r\nstatic int pcie_port_enable_msix(struct pci_dev *dev, int *irqs, int mask)\r\n{\r\nint nr_entries, entry, nvec = 0;\r\nnr_entries = pci_alloc_irq_vectors(dev, 1, PCIE_PORT_MAX_MSIX_ENTRIES,\r\nPCI_IRQ_MSIX);\r\nif (nr_entries < 0)\r\nreturn nr_entries;\r\nif (mask & (PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP)) {\r\nu16 reg16;\r\npcie_capability_read_word(dev, PCI_EXP_FLAGS, &reg16);\r\nentry = (reg16 & PCI_EXP_FLAGS_IRQ) >> 9;\r\nif (entry >= nr_entries)\r\ngoto out_free_irqs;\r\nirqs[PCIE_PORT_SERVICE_PME_SHIFT] = pci_irq_vector(dev, entry);\r\nirqs[PCIE_PORT_SERVICE_HP_SHIFT] = pci_irq_vector(dev, entry);\r\nnvec = max(nvec, entry + 1);\r\n}\r\nif (mask & PCIE_PORT_SERVICE_AER) {\r\nu32 reg32, pos;\r\npos = pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR);\r\npci_read_config_dword(dev, pos + PCI_ERR_ROOT_STATUS, &reg32);\r\nentry = reg32 >> 27;\r\nif (entry >= nr_entries)\r\ngoto out_free_irqs;\r\nirqs[PCIE_PORT_SERVICE_AER_SHIFT] = pci_irq_vector(dev, entry);\r\nnvec = max(nvec, entry + 1);\r\n}\r\nif (nvec != nr_entries) {\r\npci_free_irq_vectors(dev);\r\nnr_entries = pci_alloc_irq_vectors(dev, nvec, nvec,\r\nPCI_IRQ_MSIX);\r\nif (nr_entries < 0)\r\nreturn nr_entries;\r\n}\r\nreturn 0;\r\nout_free_irqs:\r\npci_free_irq_vectors(dev);\r\nreturn -EIO;\r\n}\r\nstatic int pcie_init_service_irqs(struct pci_dev *dev, int *irqs, int mask)\r\n{\r\nunsigned flags = PCI_IRQ_LEGACY | PCI_IRQ_MSI;\r\nint ret, i;\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++)\r\nirqs[i] = -1;\r\nif (((mask & PCIE_PORT_SERVICE_PME) && pcie_pme_no_msi()) ||\r\n((mask & PCIE_PORT_SERVICE_HP) && pciehp_no_msi())) {\r\nflags &= ~PCI_IRQ_MSI;\r\n} else {\r\nif (!pcie_port_enable_msix(dev, irqs, mask))\r\nreturn 0;\r\n}\r\nret = pci_alloc_irq_vectors(dev, 1, 1, flags);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {\r\nif (i != PCIE_PORT_SERVICE_VC_SHIFT)\r\nirqs[i] = pci_irq_vector(dev, 0);\r\n}\r\nreturn 0;\r\n}\r\nstatic int get_port_device_capability(struct pci_dev *dev)\r\n{\r\nint services = 0;\r\nint cap_mask = 0;\r\nif (pcie_ports_disabled)\r\nreturn 0;\r\ncap_mask = PCIE_PORT_SERVICE_PME | PCIE_PORT_SERVICE_HP\r\n| PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_DPC;\r\nif (pci_aer_available())\r\ncap_mask |= PCIE_PORT_SERVICE_AER;\r\nif (pcie_ports_auto)\r\npcie_port_platform_notify(dev, &cap_mask);\r\nif ((cap_mask & PCIE_PORT_SERVICE_HP) && dev->is_hotplug_bridge) {\r\nservices |= PCIE_PORT_SERVICE_HP;\r\npcie_capability_clear_word(dev, PCI_EXP_SLTCTL,\r\nPCI_EXP_SLTCTL_CCIE | PCI_EXP_SLTCTL_HPIE);\r\n}\r\nif ((cap_mask & PCIE_PORT_SERVICE_AER)\r\n&& pci_find_ext_capability(dev, PCI_EXT_CAP_ID_ERR)) {\r\nservices |= PCIE_PORT_SERVICE_AER;\r\npci_disable_pcie_error_reporting(dev);\r\n}\r\nif (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_VC))\r\nservices |= PCIE_PORT_SERVICE_VC;\r\nif ((cap_mask & PCIE_PORT_SERVICE_PME)\r\n&& pci_pcie_type(dev) == PCI_EXP_TYPE_ROOT_PORT) {\r\nservices |= PCIE_PORT_SERVICE_PME;\r\npcie_pme_interrupt_enable(dev, false);\r\n}\r\nif (pci_find_ext_capability(dev, PCI_EXT_CAP_ID_DPC))\r\nservices |= PCIE_PORT_SERVICE_DPC;\r\nreturn services;\r\n}\r\nstatic int pcie_device_init(struct pci_dev *pdev, int service, int irq)\r\n{\r\nint retval;\r\nstruct pcie_device *pcie;\r\nstruct device *device;\r\npcie = kzalloc(sizeof(*pcie), GFP_KERNEL);\r\nif (!pcie)\r\nreturn -ENOMEM;\r\npcie->port = pdev;\r\npcie->irq = irq;\r\npcie->service = service;\r\ndevice = &pcie->device;\r\ndevice->bus = &pcie_port_bus_type;\r\ndevice->release = release_pcie_device;\r\ndev_set_name(device, "%s:pcie%03x",\r\npci_name(pdev),\r\nget_descriptor_id(pci_pcie_type(pdev), service));\r\ndevice->parent = &pdev->dev;\r\ndevice_enable_async_suspend(device);\r\nretval = device_register(device);\r\nif (retval) {\r\nput_device(device);\r\nreturn retval;\r\n}\r\npm_runtime_no_callbacks(device);\r\nreturn 0;\r\n}\r\nint pcie_port_device_register(struct pci_dev *dev)\r\n{\r\nint status, capabilities, i, nr_service;\r\nint irqs[PCIE_PORT_DEVICE_MAXSERVICES];\r\nstatus = pci_enable_device(dev);\r\nif (status)\r\nreturn status;\r\ncapabilities = get_port_device_capability(dev);\r\nif (!capabilities)\r\nreturn 0;\r\npci_set_master(dev);\r\nstatus = pcie_init_service_irqs(dev, irqs, capabilities);\r\nif (status) {\r\ncapabilities &= PCIE_PORT_SERVICE_VC | PCIE_PORT_SERVICE_HP;\r\nif (!capabilities)\r\ngoto error_disable;\r\n}\r\nstatus = -ENODEV;\r\nnr_service = 0;\r\nfor (i = 0; i < PCIE_PORT_DEVICE_MAXSERVICES; i++) {\r\nint service = 1 << i;\r\nif (!(capabilities & service))\r\ncontinue;\r\nif (!pcie_device_init(dev, service, irqs[i]))\r\nnr_service++;\r\n}\r\nif (!nr_service)\r\ngoto error_cleanup_irqs;\r\nreturn 0;\r\nerror_cleanup_irqs:\r\npci_free_irq_vectors(dev);\r\nerror_disable:\r\npci_disable_device(dev);\r\nreturn status;\r\n}\r\nstatic int suspend_iter(struct device *dev, void *data)\r\n{\r\nstruct pcie_port_service_driver *service_driver;\r\nif ((dev->bus == &pcie_port_bus_type) && dev->driver) {\r\nservice_driver = to_service_driver(dev->driver);\r\nif (service_driver->suspend)\r\nservice_driver->suspend(to_pcie_device(dev));\r\n}\r\nreturn 0;\r\n}\r\nint pcie_port_device_suspend(struct device *dev)\r\n{\r\nreturn device_for_each_child(dev, NULL, suspend_iter);\r\n}\r\nstatic int resume_iter(struct device *dev, void *data)\r\n{\r\nstruct pcie_port_service_driver *service_driver;\r\nif ((dev->bus == &pcie_port_bus_type) &&\r\n(dev->driver)) {\r\nservice_driver = to_service_driver(dev->driver);\r\nif (service_driver->resume)\r\nservice_driver->resume(to_pcie_device(dev));\r\n}\r\nreturn 0;\r\n}\r\nint pcie_port_device_resume(struct device *dev)\r\n{\r\nreturn device_for_each_child(dev, NULL, resume_iter);\r\n}\r\nstatic int remove_iter(struct device *dev, void *data)\r\n{\r\nif (dev->bus == &pcie_port_bus_type)\r\ndevice_unregister(dev);\r\nreturn 0;\r\n}\r\nvoid pcie_port_device_remove(struct pci_dev *dev)\r\n{\r\ndevice_for_each_child(&dev->dev, NULL, remove_iter);\r\npci_free_irq_vectors(dev);\r\npci_disable_device(dev);\r\n}\r\nstatic int pcie_port_probe_service(struct device *dev)\r\n{\r\nstruct pcie_device *pciedev;\r\nstruct pcie_port_service_driver *driver;\r\nint status;\r\nif (!dev || !dev->driver)\r\nreturn -ENODEV;\r\ndriver = to_service_driver(dev->driver);\r\nif (!driver || !driver->probe)\r\nreturn -ENODEV;\r\npciedev = to_pcie_device(dev);\r\nstatus = driver->probe(pciedev);\r\nif (status)\r\nreturn status;\r\nget_device(dev);\r\nreturn 0;\r\n}\r\nstatic int pcie_port_remove_service(struct device *dev)\r\n{\r\nstruct pcie_device *pciedev;\r\nstruct pcie_port_service_driver *driver;\r\nif (!dev || !dev->driver)\r\nreturn 0;\r\npciedev = to_pcie_device(dev);\r\ndriver = to_service_driver(dev->driver);\r\nif (driver && driver->remove) {\r\ndriver->remove(pciedev);\r\nput_device(dev);\r\n}\r\nreturn 0;\r\n}\r\nstatic void pcie_port_shutdown_service(struct device *dev) {}\r\nint pcie_port_service_register(struct pcie_port_service_driver *new)\r\n{\r\nif (pcie_ports_disabled)\r\nreturn -ENODEV;\r\nnew->driver.name = new->name;\r\nnew->driver.bus = &pcie_port_bus_type;\r\nnew->driver.probe = pcie_port_probe_service;\r\nnew->driver.remove = pcie_port_remove_service;\r\nnew->driver.shutdown = pcie_port_shutdown_service;\r\nreturn driver_register(&new->driver);\r\n}\r\nvoid pcie_port_service_unregister(struct pcie_port_service_driver *drv)\r\n{\r\ndriver_unregister(&drv->driver);\r\n}
