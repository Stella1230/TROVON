struct clcd_panel *versatile_clcd_get_panel(const char *name)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(panels); i++)\r\nif (strcmp(panels[i]->mode.name, name) == 0)\r\nbreak;\r\nif (i < ARRAY_SIZE(panels))\r\nreturn panels[i];\r\npr_err("CLCD: couldn't get parameters for panel %s\n", name);\r\nreturn NULL;\r\n}\r\nint versatile_clcd_setup_dma(struct clcd_fb *fb, unsigned long framesize)\r\n{\r\ndma_addr_t dma;\r\nfb->fb.screen_base = dma_alloc_wc(&fb->dev->dev, framesize, &dma,\r\nGFP_KERNEL);\r\nif (!fb->fb.screen_base) {\r\npr_err("CLCD: unable to map framebuffer\n");\r\nreturn -ENOMEM;\r\n}\r\nfb->fb.fix.smem_start = dma;\r\nfb->fb.fix.smem_len = framesize;\r\nreturn 0;\r\n}\r\nint versatile_clcd_mmap_dma(struct clcd_fb *fb, struct vm_area_struct *vma)\r\n{\r\nreturn dma_mmap_wc(&fb->dev->dev, vma, fb->fb.screen_base,\r\nfb->fb.fix.smem_start, fb->fb.fix.smem_len);\r\n}\r\nvoid versatile_clcd_remove_dma(struct clcd_fb *fb)\r\n{\r\ndma_free_wc(&fb->dev->dev, fb->fb.fix.smem_len, fb->fb.screen_base,\r\nfb->fb.fix.smem_start);\r\n}\r\nstatic void integrator_clcd_enable(struct clcd_fb *fb)\r\n{\r\nstruct fb_var_screeninfo *var = &fb->fb.var;\r\nu32 val;\r\ndev_info(&fb->dev->dev, "enable Integrator CLCD connectors\n");\r\nval = INTEGRATOR_CLCD_LCD_STATIC1 | INTEGRATOR_CLCD_LCD_STATIC2 |\r\nINTEGRATOR_CLCD_LCD0_EN | INTEGRATOR_CLCD_LCD1_EN;\r\nif (var->bits_per_pixel <= 8 ||\r\n(var->bits_per_pixel == 16 && var->green.length == 5))\r\nval |= INTEGRATOR_CLCD_LCDMUX_VGA555;\r\nelse if (fb->fb.var.bits_per_pixel <= 16)\r\nval |= INTEGRATOR_CLCD_LCDMUX_VGA565;\r\nelse\r\nval = 0;\r\nregmap_update_bits(versatile_syscon_map,\r\nINTEGRATOR_HDR_CTRL_OFFSET,\r\nINTEGRATOR_CLCD_MASK,\r\nval);\r\n}\r\nstatic void versatile_clcd_disable(struct clcd_fb *fb)\r\n{\r\ndev_info(&fb->dev->dev, "disable Versatile CLCD connectors\n");\r\nregmap_update_bits(versatile_syscon_map,\r\nSYS_CLCD,\r\nSYS_CLCD_CONNECTOR_MASK,\r\n0);\r\nif (versatile_ib2_map) {\r\ndev_info(&fb->dev->dev, "disable IB2 display\n");\r\nregmap_update_bits(versatile_ib2_map,\r\nIB2_CTRL,\r\nIB2_CTRL_LCD_MASK,\r\nIB2_CTRL_LCD_SD);\r\n}\r\n}\r\nstatic void versatile_clcd_enable(struct clcd_fb *fb)\r\n{\r\nstruct fb_var_screeninfo *var = &fb->fb.var;\r\nu32 val = 0;\r\ndev_info(&fb->dev->dev, "enable Versatile CLCD connectors\n");\r\nswitch (var->green.length) {\r\ncase 5:\r\nval |= SYS_CLCD_MODE_5551;\r\nbreak;\r\ncase 6:\r\nif (var->red.offset == 0)\r\nval |= SYS_CLCD_MODE_565_R_LSB;\r\nelse\r\nval |= SYS_CLCD_MODE_565_B_LSB;\r\nbreak;\r\ncase 8:\r\nval |= SYS_CLCD_MODE_888;\r\nbreak;\r\n}\r\nregmap_update_bits(versatile_syscon_map,\r\nSYS_CLCD,\r\nSYS_CLCD_MODE_MASK,\r\nval);\r\nregmap_update_bits(versatile_syscon_map,\r\nSYS_CLCD,\r\nSYS_CLCD_CONNECTOR_MASK,\r\nSYS_CLCD_NLCDIOON | SYS_CLCD_PWR3V5SWITCH);\r\nif (versatile_ib2_map) {\r\ndev_info(&fb->dev->dev, "enable IB2 display\n");\r\nregmap_update_bits(versatile_ib2_map,\r\nIB2_CTRL,\r\nIB2_CTRL_LCD_MASK,\r\nIB2_CTRL_LCD_BL_ON);\r\n}\r\n}\r\nstatic void versatile_clcd_decode(struct clcd_fb *fb, struct clcd_regs *regs)\r\n{\r\nclcdfb_decode(fb, regs);\r\nif (fb->fb.var.green.length == 6)\r\nregs->cntl &= ~CNTL_BGR;\r\n}\r\nstatic void realview_clcd_disable(struct clcd_fb *fb)\r\n{\r\ndev_info(&fb->dev->dev, "disable RealView CLCD connectors\n");\r\nregmap_update_bits(versatile_syscon_map,\r\nSYS_CLCD,\r\nSYS_CLCD_CONNECTOR_MASK,\r\n0);\r\n}\r\nstatic void realview_clcd_enable(struct clcd_fb *fb)\r\n{\r\ndev_info(&fb->dev->dev, "enable RealView CLCD connectors\n");\r\nregmap_update_bits(versatile_syscon_map,\r\nSYS_CLCD,\r\nSYS_CLCD_CONNECTOR_MASK,\r\nSYS_CLCD_NLCDIOON | SYS_CLCD_PWR3V5SWITCH);\r\n}\r\nstatic void versatile_panel_probe(struct device *dev, struct device_node *panel)\r\n{\r\nstruct versatile_panel const *vpanel = NULL;\r\nu32 val;\r\nint ret;\r\nint i;\r\nret = regmap_read(versatile_syscon_map, SYS_CLCD, &val);\r\nif (ret) {\r\ndev_err(dev, "cannot read CLCD syscon register\n");\r\nreturn;\r\n}\r\nval &= SYS_CLCD_CLCDID_MASK;\r\nfor (i = 0; i < ARRAY_SIZE(versatile_panels); i++) {\r\nvpanel = &versatile_panels[i];\r\nif (val == vpanel->id) {\r\ndev_err(dev, "autodetected panel \"%s\"\n",\r\nvpanel->compatible);\r\nbreak;\r\n}\r\n}\r\nif (i == ARRAY_SIZE(versatile_panels)) {\r\ndev_err(dev, "could not auto-detect panel\n");\r\nreturn;\r\n}\r\nif (!of_device_is_compatible(panel, vpanel->compatible))\r\ndev_err(dev, "panel in DT is not compatible with the "\r\n"auto-detected panel, continuing anyway\n");\r\nif (!vpanel->ib2)\r\nreturn;\r\nversatile_ib2_map = syscon_regmap_lookup_by_compatible(\r\n"arm,versatile-ib2-syscon");\r\nif (IS_ERR(versatile_ib2_map)) {\r\ndev_err(dev, "could not locate IB2 control register\n");\r\nversatile_ib2_map = NULL;\r\nreturn;\r\n}\r\n}\r\nint versatile_clcd_init_panel(struct clcd_fb *fb, struct device_node *panel)\r\n{\r\nconst struct of_device_id *clcd_id;\r\nenum versatile_clcd versatile_clcd_type;\r\nstruct device_node *np;\r\nstruct regmap *map;\r\nstruct device *dev = &fb->dev->dev;\r\nnp = of_find_matching_node_and_match(NULL, versatile_clcd_of_match,\r\n&clcd_id);\r\nif (!np) {\r\nreturn 0;\r\n}\r\nversatile_clcd_type = (enum versatile_clcd)clcd_id->data;\r\nmap = syscon_node_to_regmap(np);\r\nif (IS_ERR(map)) {\r\ndev_err(dev, "no Versatile syscon regmap\n");\r\nreturn PTR_ERR(map);\r\n}\r\nswitch (versatile_clcd_type) {\r\ncase INTEGRATOR_CLCD_CM:\r\nversatile_syscon_map = map;\r\nfb->board->enable = integrator_clcd_enable;\r\nfb->board->caps = CLCD_CAP_5551 | CLCD_CAP_RGB565 |\r\nCLCD_CAP_888;\r\ndev_info(dev, "set up callbacks for Integrator PL110\n");\r\nbreak;\r\ncase VERSATILE_CLCD:\r\nversatile_syscon_map = map;\r\nfb->board->enable = versatile_clcd_enable;\r\nfb->board->disable = versatile_clcd_disable;\r\nfb->board->decode = versatile_clcd_decode;\r\nversatile_panel_probe(dev, panel);\r\ndev_info(dev, "set up callbacks for Versatile\n");\r\nbreak;\r\ncase REALVIEW_CLCD_EB:\r\ncase REALVIEW_CLCD_PB1176:\r\ncase REALVIEW_CLCD_PB11MP:\r\ncase REALVIEW_CLCD_PBA8:\r\ncase REALVIEW_CLCD_PBX:\r\nversatile_syscon_map = map;\r\nfb->board->enable = realview_clcd_enable;\r\nfb->board->disable = realview_clcd_disable;\r\ndev_info(dev, "set up callbacks for RealView PL111\n");\r\nbreak;\r\ndefault:\r\ndev_info(dev, "unknown Versatile system controller\n");\r\nbreak;\r\n}\r\nreturn 0;\r\n}
