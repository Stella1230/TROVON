static int pgctrl_show(struct seq_file *seq, void *v)\r\n{\r\nseq_puts(seq, version);\r\nreturn 0;\r\n}\r\nstatic ssize_t pgctrl_write(struct file *file, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nchar data[128];\r\nstruct pktgen_net *pn = net_generic(current->nsproxy->net_ns, pg_net_id);\r\nif (!capable(CAP_NET_ADMIN))\r\nreturn -EPERM;\r\nif (count == 0)\r\nreturn -EINVAL;\r\nif (count > sizeof(data))\r\ncount = sizeof(data);\r\nif (copy_from_user(data, buf, count))\r\nreturn -EFAULT;\r\ndata[count - 1] = 0;\r\nif (!strcmp(data, "stop"))\r\npktgen_stop_all_threads_ifs(pn);\r\nelse if (!strcmp(data, "start"))\r\npktgen_run_all_threads(pn);\r\nelse if (!strcmp(data, "reset"))\r\npktgen_reset_all_threads(pn);\r\nelse\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic int pgctrl_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pgctrl_show, PDE_DATA(inode));\r\n}\r\nstatic int pktgen_if_show(struct seq_file *seq, void *v)\r\n{\r\nconst struct pktgen_dev *pkt_dev = seq->private;\r\nktime_t stopped;\r\nu64 idle;\r\nseq_printf(seq,\r\n"Params: count %llu min_pkt_size: %u max_pkt_size: %u\n",\r\n(unsigned long long)pkt_dev->count, pkt_dev->min_pkt_size,\r\npkt_dev->max_pkt_size);\r\nseq_printf(seq,\r\n" frags: %d delay: %llu clone_skb: %d ifname: %s\n",\r\npkt_dev->nfrags, (unsigned long long) pkt_dev->delay,\r\npkt_dev->clone_skb, pkt_dev->odevname);\r\nseq_printf(seq, " flows: %u flowlen: %u\n", pkt_dev->cflows,\r\npkt_dev->lflow);\r\nseq_printf(seq,\r\n" queue_map_min: %u queue_map_max: %u\n",\r\npkt_dev->queue_map_min,\r\npkt_dev->queue_map_max);\r\nif (pkt_dev->skb_priority)\r\nseq_printf(seq, " skb_priority: %u\n",\r\npkt_dev->skb_priority);\r\nif (pkt_dev->flags & F_IPV6) {\r\nseq_printf(seq,\r\n" saddr: %pI6c min_saddr: %pI6c max_saddr: %pI6c\n"\r\n" daddr: %pI6c min_daddr: %pI6c max_daddr: %pI6c\n",\r\n&pkt_dev->in6_saddr,\r\n&pkt_dev->min_in6_saddr, &pkt_dev->max_in6_saddr,\r\n&pkt_dev->in6_daddr,\r\n&pkt_dev->min_in6_daddr, &pkt_dev->max_in6_daddr);\r\n} else {\r\nseq_printf(seq,\r\n" dst_min: %s dst_max: %s\n",\r\npkt_dev->dst_min, pkt_dev->dst_max);\r\nseq_printf(seq,\r\n" src_min: %s src_max: %s\n",\r\npkt_dev->src_min, pkt_dev->src_max);\r\n}\r\nseq_puts(seq, " src_mac: ");\r\nseq_printf(seq, "%pM ",\r\nis_zero_ether_addr(pkt_dev->src_mac) ?\r\npkt_dev->odev->dev_addr : pkt_dev->src_mac);\r\nseq_puts(seq, "dst_mac: ");\r\nseq_printf(seq, "%pM\n", pkt_dev->dst_mac);\r\nseq_printf(seq,\r\n" udp_src_min: %d udp_src_max: %d"\r\n" udp_dst_min: %d udp_dst_max: %d\n",\r\npkt_dev->udp_src_min, pkt_dev->udp_src_max,\r\npkt_dev->udp_dst_min, pkt_dev->udp_dst_max);\r\nseq_printf(seq,\r\n" src_mac_count: %d dst_mac_count: %d\n",\r\npkt_dev->src_mac_count, pkt_dev->dst_mac_count);\r\nif (pkt_dev->nr_labels) {\r\nunsigned int i;\r\nseq_puts(seq, " mpls: ");\r\nfor (i = 0; i < pkt_dev->nr_labels; i++)\r\nseq_printf(seq, "%08x%s", ntohl(pkt_dev->labels[i]),\r\ni == pkt_dev->nr_labels-1 ? "\n" : ", ");\r\n}\r\nif (pkt_dev->vlan_id != 0xffff)\r\nseq_printf(seq, " vlan_id: %u vlan_p: %u vlan_cfi: %u\n",\r\npkt_dev->vlan_id, pkt_dev->vlan_p,\r\npkt_dev->vlan_cfi);\r\nif (pkt_dev->svlan_id != 0xffff)\r\nseq_printf(seq, " svlan_id: %u vlan_p: %u vlan_cfi: %u\n",\r\npkt_dev->svlan_id, pkt_dev->svlan_p,\r\npkt_dev->svlan_cfi);\r\nif (pkt_dev->tos)\r\nseq_printf(seq, " tos: 0x%02x\n", pkt_dev->tos);\r\nif (pkt_dev->traffic_class)\r\nseq_printf(seq, " traffic_class: 0x%02x\n", pkt_dev->traffic_class);\r\nif (pkt_dev->burst > 1)\r\nseq_printf(seq, " burst: %d\n", pkt_dev->burst);\r\nif (pkt_dev->node >= 0)\r\nseq_printf(seq, " node: %d\n", pkt_dev->node);\r\nif (pkt_dev->xmit_mode == M_NETIF_RECEIVE)\r\nseq_puts(seq, " xmit_mode: netif_receive\n");\r\nelse if (pkt_dev->xmit_mode == M_QUEUE_XMIT)\r\nseq_puts(seq, " xmit_mode: xmit_queue\n");\r\nseq_puts(seq, " Flags: ");\r\nif (pkt_dev->flags & F_IPV6)\r\nseq_puts(seq, "IPV6 ");\r\nif (pkt_dev->flags & F_IPSRC_RND)\r\nseq_puts(seq, "IPSRC_RND ");\r\nif (pkt_dev->flags & F_IPDST_RND)\r\nseq_puts(seq, "IPDST_RND ");\r\nif (pkt_dev->flags & F_TXSIZE_RND)\r\nseq_puts(seq, "TXSIZE_RND ");\r\nif (pkt_dev->flags & F_UDPSRC_RND)\r\nseq_puts(seq, "UDPSRC_RND ");\r\nif (pkt_dev->flags & F_UDPDST_RND)\r\nseq_puts(seq, "UDPDST_RND ");\r\nif (pkt_dev->flags & F_UDPCSUM)\r\nseq_puts(seq, "UDPCSUM ");\r\nif (pkt_dev->flags & F_NO_TIMESTAMP)\r\nseq_puts(seq, "NO_TIMESTAMP ");\r\nif (pkt_dev->flags & F_MPLS_RND)\r\nseq_puts(seq, "MPLS_RND ");\r\nif (pkt_dev->flags & F_QUEUE_MAP_RND)\r\nseq_puts(seq, "QUEUE_MAP_RND ");\r\nif (pkt_dev->flags & F_QUEUE_MAP_CPU)\r\nseq_puts(seq, "QUEUE_MAP_CPU ");\r\nif (pkt_dev->cflows) {\r\nif (pkt_dev->flags & F_FLOW_SEQ)\r\nseq_puts(seq, "FLOW_SEQ ");\r\nelse\r\nseq_puts(seq, "FLOW_RND ");\r\n}\r\n#ifdef CONFIG_XFRM\r\nif (pkt_dev->flags & F_IPSEC_ON) {\r\nseq_puts(seq, "IPSEC ");\r\nif (pkt_dev->spi)\r\nseq_printf(seq, "spi:%u", pkt_dev->spi);\r\n}\r\n#endif\r\nif (pkt_dev->flags & F_MACSRC_RND)\r\nseq_puts(seq, "MACSRC_RND ");\r\nif (pkt_dev->flags & F_MACDST_RND)\r\nseq_puts(seq, "MACDST_RND ");\r\nif (pkt_dev->flags & F_VID_RND)\r\nseq_puts(seq, "VID_RND ");\r\nif (pkt_dev->flags & F_SVID_RND)\r\nseq_puts(seq, "SVID_RND ");\r\nif (pkt_dev->flags & F_NODE)\r\nseq_puts(seq, "NODE_ALLOC ");\r\nseq_puts(seq, "\n");\r\nstopped = pkt_dev->running ? ktime_get() : pkt_dev->stopped_at;\r\nidle = pkt_dev->idle_acc;\r\ndo_div(idle, NSEC_PER_USEC);\r\nseq_printf(seq,\r\n"Current:\n pkts-sofar: %llu errors: %llu\n",\r\n(unsigned long long)pkt_dev->sofar,\r\n(unsigned long long)pkt_dev->errors);\r\nseq_printf(seq,\r\n" started: %lluus stopped: %lluus idle: %lluus\n",\r\n(unsigned long long) ktime_to_us(pkt_dev->started_at),\r\n(unsigned long long) ktime_to_us(stopped),\r\n(unsigned long long) idle);\r\nseq_printf(seq,\r\n" seq_num: %d cur_dst_mac_offset: %d cur_src_mac_offset: %d\n",\r\npkt_dev->seq_num, pkt_dev->cur_dst_mac_offset,\r\npkt_dev->cur_src_mac_offset);\r\nif (pkt_dev->flags & F_IPV6) {\r\nseq_printf(seq, " cur_saddr: %pI6c cur_daddr: %pI6c\n",\r\n&pkt_dev->cur_in6_saddr,\r\n&pkt_dev->cur_in6_daddr);\r\n} else\r\nseq_printf(seq, " cur_saddr: %pI4 cur_daddr: %pI4\n",\r\n&pkt_dev->cur_saddr, &pkt_dev->cur_daddr);\r\nseq_printf(seq, " cur_udp_dst: %d cur_udp_src: %d\n",\r\npkt_dev->cur_udp_dst, pkt_dev->cur_udp_src);\r\nseq_printf(seq, " cur_queue_map: %u\n", pkt_dev->cur_queue_map);\r\nseq_printf(seq, " flows: %u\n", pkt_dev->nflows);\r\nif (pkt_dev->result[0])\r\nseq_printf(seq, "Result: %s\n", pkt_dev->result);\r\nelse\r\nseq_puts(seq, "Result: Idle\n");\r\nreturn 0;\r\n}\r\nstatic int hex32_arg(const char __user *user_buffer, unsigned long maxlen,\r\n__u32 *num)\r\n{\r\nint i = 0;\r\n*num = 0;\r\nfor (; i < maxlen; i++) {\r\nint value;\r\nchar c;\r\n*num <<= 4;\r\nif (get_user(c, &user_buffer[i]))\r\nreturn -EFAULT;\r\nvalue = hex_to_bin(c);\r\nif (value >= 0)\r\n*num |= value;\r\nelse\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int count_trail_chars(const char __user * user_buffer,\r\nunsigned int maxlen)\r\n{\r\nint i;\r\nfor (i = 0; i < maxlen; i++) {\r\nchar c;\r\nif (get_user(c, &user_buffer[i]))\r\nreturn -EFAULT;\r\nswitch (c) {\r\ncase '\"':\r\ncase '\n':\r\ncase '\r':\r\ncase '\t':\r\ncase ' ':\r\ncase '=':\r\nbreak;\r\ndefault:\r\ngoto done;\r\n}\r\n}\r\ndone:\r\nreturn i;\r\n}\r\nstatic long num_arg(const char __user *user_buffer, unsigned long maxlen,\r\nunsigned long *num)\r\n{\r\nint i;\r\n*num = 0;\r\nfor (i = 0; i < maxlen; i++) {\r\nchar c;\r\nif (get_user(c, &user_buffer[i]))\r\nreturn -EFAULT;\r\nif ((c >= '0') && (c <= '9')) {\r\n*num *= 10;\r\n*num += c - '0';\r\n} else\r\nbreak;\r\n}\r\nreturn i;\r\n}\r\nstatic int strn_len(const char __user * user_buffer, unsigned int maxlen)\r\n{\r\nint i;\r\nfor (i = 0; i < maxlen; i++) {\r\nchar c;\r\nif (get_user(c, &user_buffer[i]))\r\nreturn -EFAULT;\r\nswitch (c) {\r\ncase '\"':\r\ncase '\n':\r\ncase '\r':\r\ncase '\t':\r\ncase ' ':\r\ngoto done_str;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\ndone_str:\r\nreturn i;\r\n}\r\nstatic ssize_t get_labels(const char __user *buffer, struct pktgen_dev *pkt_dev)\r\n{\r\nunsigned int n = 0;\r\nchar c;\r\nssize_t i = 0;\r\nint len;\r\npkt_dev->nr_labels = 0;\r\ndo {\r\n__u32 tmp;\r\nlen = hex32_arg(&buffer[i], 8, &tmp);\r\nif (len <= 0)\r\nreturn len;\r\npkt_dev->labels[n] = htonl(tmp);\r\nif (pkt_dev->labels[n] & MPLS_STACK_BOTTOM)\r\npkt_dev->flags |= F_MPLS_RND;\r\ni += len;\r\nif (get_user(c, &buffer[i]))\r\nreturn -EFAULT;\r\ni++;\r\nn++;\r\nif (n >= MAX_MPLS_LABELS)\r\nreturn -E2BIG;\r\n} while (c == ',');\r\npkt_dev->nr_labels = n;\r\nreturn i;\r\n}\r\nstatic ssize_t pktgen_if_write(struct file *file,\r\nconst char __user * user_buffer, size_t count,\r\nloff_t * offset)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct pktgen_dev *pkt_dev = seq->private;\r\nint i, max, len;\r\nchar name[16], valstr[32];\r\nunsigned long value = 0;\r\nchar *pg_result = NULL;\r\nint tmp = 0;\r\nchar buf[128];\r\npg_result = &(pkt_dev->result[0]);\r\nif (count < 1) {\r\npr_warn("wrong command format\n");\r\nreturn -EINVAL;\r\n}\r\nmax = count;\r\ntmp = count_trail_chars(user_buffer, max);\r\nif (tmp < 0) {\r\npr_warn("illegal format\n");\r\nreturn tmp;\r\n}\r\ni = tmp;\r\nlen = strn_len(&user_buffer[i], sizeof(name) - 1);\r\nif (len < 0)\r\nreturn len;\r\nmemset(name, 0, sizeof(name));\r\nif (copy_from_user(name, &user_buffer[i], len))\r\nreturn -EFAULT;\r\ni += len;\r\nmax = count - i;\r\nlen = count_trail_chars(&user_buffer[i], max);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (debug) {\r\nsize_t copy = min_t(size_t, count, 1023);\r\nchar tb[copy + 1];\r\nif (copy_from_user(tb, user_buffer, copy))\r\nreturn -EFAULT;\r\ntb[copy] = 0;\r\npr_debug("%s,%lu buffer -:%s:-\n",\r\nname, (unsigned long)count, tb);\r\n}\r\nif (!strcmp(name, "min_pkt_size")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value < 14 + 20 + 8)\r\nvalue = 14 + 20 + 8;\r\nif (value != pkt_dev->min_pkt_size) {\r\npkt_dev->min_pkt_size = value;\r\npkt_dev->cur_pkt_size = value;\r\n}\r\nsprintf(pg_result, "OK: min_pkt_size=%u",\r\npkt_dev->min_pkt_size);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "max_pkt_size")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value < 14 + 20 + 8)\r\nvalue = 14 + 20 + 8;\r\nif (value != pkt_dev->max_pkt_size) {\r\npkt_dev->max_pkt_size = value;\r\npkt_dev->cur_pkt_size = value;\r\n}\r\nsprintf(pg_result, "OK: max_pkt_size=%u",\r\npkt_dev->max_pkt_size);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "pkt_size")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value < 14 + 20 + 8)\r\nvalue = 14 + 20 + 8;\r\nif (value != pkt_dev->min_pkt_size) {\r\npkt_dev->min_pkt_size = value;\r\npkt_dev->max_pkt_size = value;\r\npkt_dev->cur_pkt_size = value;\r\n}\r\nsprintf(pg_result, "OK: pkt_size=%u", pkt_dev->min_pkt_size);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "debug")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\ndebug = value;\r\nsprintf(pg_result, "OK: debug=%u", debug);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "frags")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->nfrags = value;\r\nsprintf(pg_result, "OK: frags=%u", pkt_dev->nfrags);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "delay")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value == 0x7FFFFFFF)\r\npkt_dev->delay = ULLONG_MAX;\r\nelse\r\npkt_dev->delay = (u64)value;\r\nsprintf(pg_result, "OK: delay=%llu",\r\n(unsigned long long) pkt_dev->delay);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "rate")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (!value)\r\nreturn len;\r\npkt_dev->delay = pkt_dev->min_pkt_size*8*NSEC_PER_USEC/value;\r\nif (debug)\r\npr_info("Delay set at: %llu ns\n", pkt_dev->delay);\r\nsprintf(pg_result, "OK: rate=%lu", value);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "ratep")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (!value)\r\nreturn len;\r\npkt_dev->delay = NSEC_PER_SEC/value;\r\nif (debug)\r\npr_info("Delay set at: %llu ns\n", pkt_dev->delay);\r\nsprintf(pg_result, "OK: rate=%lu", value);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "udp_src_min")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value != pkt_dev->udp_src_min) {\r\npkt_dev->udp_src_min = value;\r\npkt_dev->cur_udp_src = value;\r\n}\r\nsprintf(pg_result, "OK: udp_src_min=%u", pkt_dev->udp_src_min);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "udp_dst_min")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value != pkt_dev->udp_dst_min) {\r\npkt_dev->udp_dst_min = value;\r\npkt_dev->cur_udp_dst = value;\r\n}\r\nsprintf(pg_result, "OK: udp_dst_min=%u", pkt_dev->udp_dst_min);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "udp_src_max")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value != pkt_dev->udp_src_max) {\r\npkt_dev->udp_src_max = value;\r\npkt_dev->cur_udp_src = value;\r\n}\r\nsprintf(pg_result, "OK: udp_src_max=%u", pkt_dev->udp_src_max);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "udp_dst_max")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value != pkt_dev->udp_dst_max) {\r\npkt_dev->udp_dst_max = value;\r\npkt_dev->cur_udp_dst = value;\r\n}\r\nsprintf(pg_result, "OK: udp_dst_max=%u", pkt_dev->udp_dst_max);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "clone_skb")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\nif ((value > 0) &&\r\n((pkt_dev->xmit_mode == M_NETIF_RECEIVE) ||\r\n!(pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)))\r\nreturn -ENOTSUPP;\r\ni += len;\r\npkt_dev->clone_skb = value;\r\nsprintf(pg_result, "OK: clone_skb=%d", pkt_dev->clone_skb);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "count")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->count = value;\r\nsprintf(pg_result, "OK: count=%llu",\r\n(unsigned long long)pkt_dev->count);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "src_mac_count")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (pkt_dev->src_mac_count != value) {\r\npkt_dev->src_mac_count = value;\r\npkt_dev->cur_src_mac_offset = 0;\r\n}\r\nsprintf(pg_result, "OK: src_mac_count=%d",\r\npkt_dev->src_mac_count);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst_mac_count")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (pkt_dev->dst_mac_count != value) {\r\npkt_dev->dst_mac_count = value;\r\npkt_dev->cur_dst_mac_offset = 0;\r\n}\r\nsprintf(pg_result, "OK: dst_mac_count=%d",\r\npkt_dev->dst_mac_count);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "burst")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif ((value > 1) &&\r\n((pkt_dev->xmit_mode == M_QUEUE_XMIT) ||\r\n((pkt_dev->xmit_mode == M_START_XMIT) &&\r\n(!(pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)))))\r\nreturn -ENOTSUPP;\r\npkt_dev->burst = value < 1 ? 1 : value;\r\nsprintf(pg_result, "OK: burst=%d", pkt_dev->burst);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "node")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (node_possible(value)) {\r\npkt_dev->node = value;\r\nsprintf(pg_result, "OK: node=%d", pkt_dev->node);\r\nif (pkt_dev->page) {\r\nput_page(pkt_dev->page);\r\npkt_dev->page = NULL;\r\n}\r\n}\r\nelse\r\nsprintf(pg_result, "ERROR: node not possible");\r\nreturn count;\r\n}\r\nif (!strcmp(name, "xmit_mode")) {\r\nchar f[32];\r\nmemset(f, 0, 32);\r\nlen = strn_len(&user_buffer[i], sizeof(f) - 1);\r\nif (len < 0)\r\nreturn len;\r\nif (copy_from_user(f, &user_buffer[i], len))\r\nreturn -EFAULT;\r\ni += len;\r\nif (strcmp(f, "start_xmit") == 0) {\r\npkt_dev->xmit_mode = M_START_XMIT;\r\n} else if (strcmp(f, "netif_receive") == 0) {\r\nif (pkt_dev->clone_skb > 0)\r\nreturn -ENOTSUPP;\r\npkt_dev->xmit_mode = M_NETIF_RECEIVE;\r\npkt_dev->last_ok = 1;\r\npkt_dev->clone_skb = 0;\r\n} else if (strcmp(f, "queue_xmit") == 0) {\r\npkt_dev->xmit_mode = M_QUEUE_XMIT;\r\npkt_dev->last_ok = 1;\r\n} else {\r\nsprintf(pg_result,\r\n"xmit_mode -:%s:- unknown\nAvailable modes: %s",\r\nf, "start_xmit, netif_receive\n");\r\nreturn count;\r\n}\r\nsprintf(pg_result, "OK: xmit_mode=%s", f);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "flag")) {\r\nchar f[32];\r\nmemset(f, 0, 32);\r\nlen = strn_len(&user_buffer[i], sizeof(f) - 1);\r\nif (len < 0)\r\nreturn len;\r\nif (copy_from_user(f, &user_buffer[i], len))\r\nreturn -EFAULT;\r\ni += len;\r\nif (strcmp(f, "IPSRC_RND") == 0)\r\npkt_dev->flags |= F_IPSRC_RND;\r\nelse if (strcmp(f, "!IPSRC_RND") == 0)\r\npkt_dev->flags &= ~F_IPSRC_RND;\r\nelse if (strcmp(f, "TXSIZE_RND") == 0)\r\npkt_dev->flags |= F_TXSIZE_RND;\r\nelse if (strcmp(f, "!TXSIZE_RND") == 0)\r\npkt_dev->flags &= ~F_TXSIZE_RND;\r\nelse if (strcmp(f, "IPDST_RND") == 0)\r\npkt_dev->flags |= F_IPDST_RND;\r\nelse if (strcmp(f, "!IPDST_RND") == 0)\r\npkt_dev->flags &= ~F_IPDST_RND;\r\nelse if (strcmp(f, "UDPSRC_RND") == 0)\r\npkt_dev->flags |= F_UDPSRC_RND;\r\nelse if (strcmp(f, "!UDPSRC_RND") == 0)\r\npkt_dev->flags &= ~F_UDPSRC_RND;\r\nelse if (strcmp(f, "UDPDST_RND") == 0)\r\npkt_dev->flags |= F_UDPDST_RND;\r\nelse if (strcmp(f, "!UDPDST_RND") == 0)\r\npkt_dev->flags &= ~F_UDPDST_RND;\r\nelse if (strcmp(f, "MACSRC_RND") == 0)\r\npkt_dev->flags |= F_MACSRC_RND;\r\nelse if (strcmp(f, "!MACSRC_RND") == 0)\r\npkt_dev->flags &= ~F_MACSRC_RND;\r\nelse if (strcmp(f, "MACDST_RND") == 0)\r\npkt_dev->flags |= F_MACDST_RND;\r\nelse if (strcmp(f, "!MACDST_RND") == 0)\r\npkt_dev->flags &= ~F_MACDST_RND;\r\nelse if (strcmp(f, "MPLS_RND") == 0)\r\npkt_dev->flags |= F_MPLS_RND;\r\nelse if (strcmp(f, "!MPLS_RND") == 0)\r\npkt_dev->flags &= ~F_MPLS_RND;\r\nelse if (strcmp(f, "VID_RND") == 0)\r\npkt_dev->flags |= F_VID_RND;\r\nelse if (strcmp(f, "!VID_RND") == 0)\r\npkt_dev->flags &= ~F_VID_RND;\r\nelse if (strcmp(f, "SVID_RND") == 0)\r\npkt_dev->flags |= F_SVID_RND;\r\nelse if (strcmp(f, "!SVID_RND") == 0)\r\npkt_dev->flags &= ~F_SVID_RND;\r\nelse if (strcmp(f, "FLOW_SEQ") == 0)\r\npkt_dev->flags |= F_FLOW_SEQ;\r\nelse if (strcmp(f, "QUEUE_MAP_RND") == 0)\r\npkt_dev->flags |= F_QUEUE_MAP_RND;\r\nelse if (strcmp(f, "!QUEUE_MAP_RND") == 0)\r\npkt_dev->flags &= ~F_QUEUE_MAP_RND;\r\nelse if (strcmp(f, "QUEUE_MAP_CPU") == 0)\r\npkt_dev->flags |= F_QUEUE_MAP_CPU;\r\nelse if (strcmp(f, "!QUEUE_MAP_CPU") == 0)\r\npkt_dev->flags &= ~F_QUEUE_MAP_CPU;\r\n#ifdef CONFIG_XFRM\r\nelse if (strcmp(f, "IPSEC") == 0)\r\npkt_dev->flags |= F_IPSEC_ON;\r\n#endif\r\nelse if (strcmp(f, "!IPV6") == 0)\r\npkt_dev->flags &= ~F_IPV6;\r\nelse if (strcmp(f, "NODE_ALLOC") == 0)\r\npkt_dev->flags |= F_NODE;\r\nelse if (strcmp(f, "!NODE_ALLOC") == 0)\r\npkt_dev->flags &= ~F_NODE;\r\nelse if (strcmp(f, "UDPCSUM") == 0)\r\npkt_dev->flags |= F_UDPCSUM;\r\nelse if (strcmp(f, "!UDPCSUM") == 0)\r\npkt_dev->flags &= ~F_UDPCSUM;\r\nelse if (strcmp(f, "NO_TIMESTAMP") == 0)\r\npkt_dev->flags |= F_NO_TIMESTAMP;\r\nelse if (strcmp(f, "!NO_TIMESTAMP") == 0)\r\npkt_dev->flags &= ~F_NO_TIMESTAMP;\r\nelse {\r\nsprintf(pg_result,\r\n"Flag -:%s:- unknown\nAvailable flags, (prepend ! to un-set flag):\n%s",\r\nf,\r\n"IPSRC_RND, IPDST_RND, UDPSRC_RND, UDPDST_RND, "\r\n"MACSRC_RND, MACDST_RND, TXSIZE_RND, IPV6, "\r\n"MPLS_RND, VID_RND, SVID_RND, FLOW_SEQ, "\r\n"QUEUE_MAP_RND, QUEUE_MAP_CPU, UDPCSUM, "\r\n"NO_TIMESTAMP, "\r\n#ifdef CONFIG_XFRM\r\n"IPSEC, "\r\n#endif\r\n"NODE_ALLOC\n");\r\nreturn count;\r\n}\r\nsprintf(pg_result, "OK: flags=0x%x", pkt_dev->flags);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst_min") || !strcmp(name, "dst")) {\r\nlen = strn_len(&user_buffer[i], sizeof(pkt_dev->dst_min) - 1);\r\nif (len < 0)\r\nreturn len;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nif (strcmp(buf, pkt_dev->dst_min) != 0) {\r\nmemset(pkt_dev->dst_min, 0, sizeof(pkt_dev->dst_min));\r\nstrncpy(pkt_dev->dst_min, buf, len);\r\npkt_dev->daddr_min = in_aton(pkt_dev->dst_min);\r\npkt_dev->cur_daddr = pkt_dev->daddr_min;\r\n}\r\nif (debug)\r\npr_debug("dst_min set to: %s\n", pkt_dev->dst_min);\r\ni += len;\r\nsprintf(pg_result, "OK: dst_min=%s", pkt_dev->dst_min);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst_max")) {\r\nlen = strn_len(&user_buffer[i], sizeof(pkt_dev->dst_max) - 1);\r\nif (len < 0)\r\nreturn len;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nif (strcmp(buf, pkt_dev->dst_max) != 0) {\r\nmemset(pkt_dev->dst_max, 0, sizeof(pkt_dev->dst_max));\r\nstrncpy(pkt_dev->dst_max, buf, len);\r\npkt_dev->daddr_max = in_aton(pkt_dev->dst_max);\r\npkt_dev->cur_daddr = pkt_dev->daddr_max;\r\n}\r\nif (debug)\r\npr_debug("dst_max set to: %s\n", pkt_dev->dst_max);\r\ni += len;\r\nsprintf(pg_result, "OK: dst_max=%s", pkt_dev->dst_max);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst6")) {\r\nlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\r\nif (len < 0)\r\nreturn len;\r\npkt_dev->flags |= F_IPV6;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nin6_pton(buf, -1, pkt_dev->in6_daddr.s6_addr, -1, NULL);\r\nsnprintf(buf, sizeof(buf), "%pI6c", &pkt_dev->in6_daddr);\r\npkt_dev->cur_in6_daddr = pkt_dev->in6_daddr;\r\nif (debug)\r\npr_debug("dst6 set to: %s\n", buf);\r\ni += len;\r\nsprintf(pg_result, "OK: dst6=%s", buf);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst6_min")) {\r\nlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\r\nif (len < 0)\r\nreturn len;\r\npkt_dev->flags |= F_IPV6;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nin6_pton(buf, -1, pkt_dev->min_in6_daddr.s6_addr, -1, NULL);\r\nsnprintf(buf, sizeof(buf), "%pI6c", &pkt_dev->min_in6_daddr);\r\npkt_dev->cur_in6_daddr = pkt_dev->min_in6_daddr;\r\nif (debug)\r\npr_debug("dst6_min set to: %s\n", buf);\r\ni += len;\r\nsprintf(pg_result, "OK: dst6_min=%s", buf);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst6_max")) {\r\nlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\r\nif (len < 0)\r\nreturn len;\r\npkt_dev->flags |= F_IPV6;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nin6_pton(buf, -1, pkt_dev->max_in6_daddr.s6_addr, -1, NULL);\r\nsnprintf(buf, sizeof(buf), "%pI6c", &pkt_dev->max_in6_daddr);\r\nif (debug)\r\npr_debug("dst6_max set to: %s\n", buf);\r\ni += len;\r\nsprintf(pg_result, "OK: dst6_max=%s", buf);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "src6")) {\r\nlen = strn_len(&user_buffer[i], sizeof(buf) - 1);\r\nif (len < 0)\r\nreturn len;\r\npkt_dev->flags |= F_IPV6;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nin6_pton(buf, -1, pkt_dev->in6_saddr.s6_addr, -1, NULL);\r\nsnprintf(buf, sizeof(buf), "%pI6c", &pkt_dev->in6_saddr);\r\npkt_dev->cur_in6_saddr = pkt_dev->in6_saddr;\r\nif (debug)\r\npr_debug("src6 set to: %s\n", buf);\r\ni += len;\r\nsprintf(pg_result, "OK: src6=%s", buf);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "src_min")) {\r\nlen = strn_len(&user_buffer[i], sizeof(pkt_dev->src_min) - 1);\r\nif (len < 0)\r\nreturn len;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nif (strcmp(buf, pkt_dev->src_min) != 0) {\r\nmemset(pkt_dev->src_min, 0, sizeof(pkt_dev->src_min));\r\nstrncpy(pkt_dev->src_min, buf, len);\r\npkt_dev->saddr_min = in_aton(pkt_dev->src_min);\r\npkt_dev->cur_saddr = pkt_dev->saddr_min;\r\n}\r\nif (debug)\r\npr_debug("src_min set to: %s\n", pkt_dev->src_min);\r\ni += len;\r\nsprintf(pg_result, "OK: src_min=%s", pkt_dev->src_min);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "src_max")) {\r\nlen = strn_len(&user_buffer[i], sizeof(pkt_dev->src_max) - 1);\r\nif (len < 0)\r\nreturn len;\r\nif (copy_from_user(buf, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nbuf[len] = 0;\r\nif (strcmp(buf, pkt_dev->src_max) != 0) {\r\nmemset(pkt_dev->src_max, 0, sizeof(pkt_dev->src_max));\r\nstrncpy(pkt_dev->src_max, buf, len);\r\npkt_dev->saddr_max = in_aton(pkt_dev->src_max);\r\npkt_dev->cur_saddr = pkt_dev->saddr_max;\r\n}\r\nif (debug)\r\npr_debug("src_max set to: %s\n", pkt_dev->src_max);\r\ni += len;\r\nsprintf(pg_result, "OK: src_max=%s", pkt_dev->src_max);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "dst_mac")) {\r\nlen = strn_len(&user_buffer[i], sizeof(valstr) - 1);\r\nif (len < 0)\r\nreturn len;\r\nmemset(valstr, 0, sizeof(valstr));\r\nif (copy_from_user(valstr, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nif (!mac_pton(valstr, pkt_dev->dst_mac))\r\nreturn -EINVAL;\r\nether_addr_copy(&pkt_dev->hh[0], pkt_dev->dst_mac);\r\nsprintf(pg_result, "OK: dstmac %pM", pkt_dev->dst_mac);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "src_mac")) {\r\nlen = strn_len(&user_buffer[i], sizeof(valstr) - 1);\r\nif (len < 0)\r\nreturn len;\r\nmemset(valstr, 0, sizeof(valstr));\r\nif (copy_from_user(valstr, &user_buffer[i], len))\r\nreturn -EFAULT;\r\nif (!mac_pton(valstr, pkt_dev->src_mac))\r\nreturn -EINVAL;\r\nether_addr_copy(&pkt_dev->hh[6], pkt_dev->src_mac);\r\nsprintf(pg_result, "OK: srcmac %pM", pkt_dev->src_mac);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "clear_counters")) {\r\npktgen_clear_counters(pkt_dev);\r\nsprintf(pg_result, "OK: Clearing counters.\n");\r\nreturn count;\r\n}\r\nif (!strcmp(name, "flows")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value > MAX_CFLOWS)\r\nvalue = MAX_CFLOWS;\r\npkt_dev->cflows = value;\r\nsprintf(pg_result, "OK: flows=%u", pkt_dev->cflows);\r\nreturn count;\r\n}\r\n#ifdef CONFIG_XFRM\r\nif (!strcmp(name, "spi")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->spi = value;\r\nsprintf(pg_result, "OK: spi=%u", pkt_dev->spi);\r\nreturn count;\r\n}\r\n#endif\r\nif (!strcmp(name, "flowlen")) {\r\nlen = num_arg(&user_buffer[i], 10, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->lflow = value;\r\nsprintf(pg_result, "OK: flowlen=%u", pkt_dev->lflow);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "queue_map_min")) {\r\nlen = num_arg(&user_buffer[i], 5, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->queue_map_min = value;\r\nsprintf(pg_result, "OK: queue_map_min=%u", pkt_dev->queue_map_min);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "queue_map_max")) {\r\nlen = num_arg(&user_buffer[i], 5, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->queue_map_max = value;\r\nsprintf(pg_result, "OK: queue_map_max=%u", pkt_dev->queue_map_max);\r\nreturn count;\r\n}\r\nif (!strcmp(name, "mpls")) {\r\nunsigned int n, cnt;\r\nlen = get_labels(&user_buffer[i], pkt_dev);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\ncnt = sprintf(pg_result, "OK: mpls=");\r\nfor (n = 0; n < pkt_dev->nr_labels; n++)\r\ncnt += sprintf(pg_result + cnt,\r\n"%08x%s", ntohl(pkt_dev->labels[n]),\r\nn == pkt_dev->nr_labels-1 ? "" : ",");\r\nif (pkt_dev->nr_labels && pkt_dev->vlan_id != 0xffff) {\r\npkt_dev->vlan_id = 0xffff;\r\npkt_dev->svlan_id = 0xffff;\r\nif (debug)\r\npr_debug("VLAN/SVLAN auto turned off\n");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "vlan_id")) {\r\nlen = num_arg(&user_buffer[i], 4, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (value <= 4095) {\r\npkt_dev->vlan_id = value;\r\nif (debug)\r\npr_debug("VLAN turned on\n");\r\nif (debug && pkt_dev->nr_labels)\r\npr_debug("MPLS auto turned off\n");\r\npkt_dev->nr_labels = 0;\r\nsprintf(pg_result, "OK: vlan_id=%u", pkt_dev->vlan_id);\r\n} else {\r\npkt_dev->vlan_id = 0xffff;\r\npkt_dev->svlan_id = 0xffff;\r\nif (debug)\r\npr_debug("VLAN/SVLAN turned off\n");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "vlan_p")) {\r\nlen = num_arg(&user_buffer[i], 1, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif ((value <= 7) && (pkt_dev->vlan_id != 0xffff)) {\r\npkt_dev->vlan_p = value;\r\nsprintf(pg_result, "OK: vlan_p=%u", pkt_dev->vlan_p);\r\n} else {\r\nsprintf(pg_result, "ERROR: vlan_p must be 0-7");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "vlan_cfi")) {\r\nlen = num_arg(&user_buffer[i], 1, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif ((value <= 1) && (pkt_dev->vlan_id != 0xffff)) {\r\npkt_dev->vlan_cfi = value;\r\nsprintf(pg_result, "OK: vlan_cfi=%u", pkt_dev->vlan_cfi);\r\n} else {\r\nsprintf(pg_result, "ERROR: vlan_cfi must be 0-1");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "svlan_id")) {\r\nlen = num_arg(&user_buffer[i], 4, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif ((value <= 4095) && ((pkt_dev->vlan_id != 0xffff))) {\r\npkt_dev->svlan_id = value;\r\nif (debug)\r\npr_debug("SVLAN turned on\n");\r\nif (debug && pkt_dev->nr_labels)\r\npr_debug("MPLS auto turned off\n");\r\npkt_dev->nr_labels = 0;\r\nsprintf(pg_result, "OK: svlan_id=%u", pkt_dev->svlan_id);\r\n} else {\r\npkt_dev->vlan_id = 0xffff;\r\npkt_dev->svlan_id = 0xffff;\r\nif (debug)\r\npr_debug("VLAN/SVLAN turned off\n");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "svlan_p")) {\r\nlen = num_arg(&user_buffer[i], 1, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif ((value <= 7) && (pkt_dev->svlan_id != 0xffff)) {\r\npkt_dev->svlan_p = value;\r\nsprintf(pg_result, "OK: svlan_p=%u", pkt_dev->svlan_p);\r\n} else {\r\nsprintf(pg_result, "ERROR: svlan_p must be 0-7");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "svlan_cfi")) {\r\nlen = num_arg(&user_buffer[i], 1, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif ((value <= 1) && (pkt_dev->svlan_id != 0xffff)) {\r\npkt_dev->svlan_cfi = value;\r\nsprintf(pg_result, "OK: svlan_cfi=%u", pkt_dev->svlan_cfi);\r\n} else {\r\nsprintf(pg_result, "ERROR: svlan_cfi must be 0-1");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "tos")) {\r\n__u32 tmp_value = 0;\r\nlen = hex32_arg(&user_buffer[i], 2, &tmp_value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (len == 2) {\r\npkt_dev->tos = tmp_value;\r\nsprintf(pg_result, "OK: tos=0x%02x", pkt_dev->tos);\r\n} else {\r\nsprintf(pg_result, "ERROR: tos must be 00-ff");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "traffic_class")) {\r\n__u32 tmp_value = 0;\r\nlen = hex32_arg(&user_buffer[i], 2, &tmp_value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (len == 2) {\r\npkt_dev->traffic_class = tmp_value;\r\nsprintf(pg_result, "OK: traffic_class=0x%02x", pkt_dev->traffic_class);\r\n} else {\r\nsprintf(pg_result, "ERROR: traffic_class must be 00-ff");\r\n}\r\nreturn count;\r\n}\r\nif (!strcmp(name, "skb_priority")) {\r\nlen = num_arg(&user_buffer[i], 9, &value);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\npkt_dev->skb_priority = value;\r\nsprintf(pg_result, "OK: skb_priority=%i",\r\npkt_dev->skb_priority);\r\nreturn count;\r\n}\r\nsprintf(pkt_dev->result, "No such parameter \"%s\"", name);\r\nreturn -EINVAL;\r\n}\r\nstatic int pktgen_if_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pktgen_if_show, PDE_DATA(inode));\r\n}\r\nstatic int pktgen_thread_show(struct seq_file *seq, void *v)\r\n{\r\nstruct pktgen_thread *t = seq->private;\r\nconst struct pktgen_dev *pkt_dev;\r\nBUG_ON(!t);\r\nseq_puts(seq, "Running: ");\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pkt_dev, &t->if_list, list)\r\nif (pkt_dev->running)\r\nseq_printf(seq, "%s ", pkt_dev->odevname);\r\nseq_puts(seq, "\nStopped: ");\r\nlist_for_each_entry_rcu(pkt_dev, &t->if_list, list)\r\nif (!pkt_dev->running)\r\nseq_printf(seq, "%s ", pkt_dev->odevname);\r\nif (t->result[0])\r\nseq_printf(seq, "\nResult: %s\n", t->result);\r\nelse\r\nseq_puts(seq, "\nResult: NA\n");\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic ssize_t pktgen_thread_write(struct file *file,\r\nconst char __user * user_buffer,\r\nsize_t count, loff_t * offset)\r\n{\r\nstruct seq_file *seq = file->private_data;\r\nstruct pktgen_thread *t = seq->private;\r\nint i, max, len, ret;\r\nchar name[40];\r\nchar *pg_result;\r\nif (count < 1) {\r\nreturn -EINVAL;\r\n}\r\nmax = count;\r\nlen = count_trail_chars(user_buffer, max);\r\nif (len < 0)\r\nreturn len;\r\ni = len;\r\nlen = strn_len(&user_buffer[i], sizeof(name) - 1);\r\nif (len < 0)\r\nreturn len;\r\nmemset(name, 0, sizeof(name));\r\nif (copy_from_user(name, &user_buffer[i], len))\r\nreturn -EFAULT;\r\ni += len;\r\nmax = count - i;\r\nlen = count_trail_chars(&user_buffer[i], max);\r\nif (len < 0)\r\nreturn len;\r\ni += len;\r\nif (debug)\r\npr_debug("t=%s, count=%lu\n", name, (unsigned long)count);\r\nif (!t) {\r\npr_err("ERROR: No thread\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\npg_result = &(t->result[0]);\r\nif (!strcmp(name, "add_device")) {\r\nchar f[32];\r\nmemset(f, 0, 32);\r\nlen = strn_len(&user_buffer[i], sizeof(f) - 1);\r\nif (len < 0) {\r\nret = len;\r\ngoto out;\r\n}\r\nif (copy_from_user(f, &user_buffer[i], len))\r\nreturn -EFAULT;\r\ni += len;\r\nmutex_lock(&pktgen_thread_lock);\r\nret = pktgen_add_device(t, f);\r\nmutex_unlock(&pktgen_thread_lock);\r\nif (!ret) {\r\nret = count;\r\nsprintf(pg_result, "OK: add_device=%s", f);\r\n} else\r\nsprintf(pg_result, "ERROR: can not add device %s", f);\r\ngoto out;\r\n}\r\nif (!strcmp(name, "rem_device_all")) {\r\nmutex_lock(&pktgen_thread_lock);\r\nt->control |= T_REMDEVALL;\r\nmutex_unlock(&pktgen_thread_lock);\r\nschedule_timeout_interruptible(msecs_to_jiffies(125));\r\nret = count;\r\nsprintf(pg_result, "OK: rem_device_all");\r\ngoto out;\r\n}\r\nif (!strcmp(name, "max_before_softirq")) {\r\nsprintf(pg_result, "OK: Note! max_before_softirq is obsoleted -- Do not use");\r\nret = count;\r\ngoto out;\r\n}\r\nret = -EINVAL;\r\nout:\r\nreturn ret;\r\n}\r\nstatic int pktgen_thread_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, pktgen_thread_show, PDE_DATA(inode));\r\n}\r\nstatic struct pktgen_dev *__pktgen_NN_threads(const struct pktgen_net *pn,\r\nconst char *ifname, int remove)\r\n{\r\nstruct pktgen_thread *t;\r\nstruct pktgen_dev *pkt_dev = NULL;\r\nbool exact = (remove == FIND);\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list) {\r\npkt_dev = pktgen_find_dev(t, ifname, exact);\r\nif (pkt_dev) {\r\nif (remove) {\r\npkt_dev->removal_mark = 1;\r\nt->control |= T_REMDEV;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn pkt_dev;\r\n}\r\nstatic void pktgen_mark_device(const struct pktgen_net *pn, const char *ifname)\r\n{\r\nstruct pktgen_dev *pkt_dev = NULL;\r\nconst int max_tries = 10, msec_per_try = 125;\r\nint i = 0;\r\nmutex_lock(&pktgen_thread_lock);\r\npr_debug("%s: marking %s for removal\n", __func__, ifname);\r\nwhile (1) {\r\npkt_dev = __pktgen_NN_threads(pn, ifname, REMOVE);\r\nif (pkt_dev == NULL)\r\nbreak;\r\nmutex_unlock(&pktgen_thread_lock);\r\npr_debug("%s: waiting for %s to disappear....\n",\r\n__func__, ifname);\r\nschedule_timeout_interruptible(msecs_to_jiffies(msec_per_try));\r\nmutex_lock(&pktgen_thread_lock);\r\nif (++i >= max_tries) {\r\npr_err("%s: timed out after waiting %d msec for device %s to be removed\n",\r\n__func__, msec_per_try * i, ifname);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&pktgen_thread_lock);\r\n}\r\nstatic void pktgen_change_name(const struct pktgen_net *pn, struct net_device *dev)\r\n{\r\nstruct pktgen_thread *t;\r\nmutex_lock(&pktgen_thread_lock);\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list) {\r\nstruct pktgen_dev *pkt_dev;\r\nif_lock(t);\r\nlist_for_each_entry(pkt_dev, &t->if_list, list) {\r\nif (pkt_dev->odev != dev)\r\ncontinue;\r\nproc_remove(pkt_dev->entry);\r\npkt_dev->entry = proc_create_data(dev->name, 0600,\r\npn->proc_dir,\r\n&pktgen_if_fops,\r\npkt_dev);\r\nif (!pkt_dev->entry)\r\npr_err("can't move proc entry for '%s'\n",\r\ndev->name);\r\nbreak;\r\n}\r\nif_unlock(t);\r\n}\r\nmutex_unlock(&pktgen_thread_lock);\r\n}\r\nstatic int pktgen_device_event(struct notifier_block *unused,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\r\nstruct pktgen_net *pn = net_generic(dev_net(dev), pg_net_id);\r\nif (pn->pktgen_exiting)\r\nreturn NOTIFY_DONE;\r\nswitch (event) {\r\ncase NETDEV_CHANGENAME:\r\npktgen_change_name(pn, dev);\r\nbreak;\r\ncase NETDEV_UNREGISTER:\r\npktgen_mark_device(pn, dev->name);\r\nbreak;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic struct net_device *pktgen_dev_get_by_name(const struct pktgen_net *pn,\r\nstruct pktgen_dev *pkt_dev,\r\nconst char *ifname)\r\n{\r\nchar b[IFNAMSIZ+5];\r\nint i;\r\nfor (i = 0; ifname[i] != '@'; i++) {\r\nif (i == IFNAMSIZ)\r\nbreak;\r\nb[i] = ifname[i];\r\n}\r\nb[i] = 0;\r\nreturn dev_get_by_name(pn->net, b);\r\n}\r\nstatic int pktgen_setup_dev(const struct pktgen_net *pn,\r\nstruct pktgen_dev *pkt_dev, const char *ifname)\r\n{\r\nstruct net_device *odev;\r\nint err;\r\nif (pkt_dev->odev) {\r\ndev_put(pkt_dev->odev);\r\npkt_dev->odev = NULL;\r\n}\r\nodev = pktgen_dev_get_by_name(pn, pkt_dev, ifname);\r\nif (!odev) {\r\npr_err("no such netdevice: \"%s\"\n", ifname);\r\nreturn -ENODEV;\r\n}\r\nif (odev->type != ARPHRD_ETHER) {\r\npr_err("not an ethernet device: \"%s\"\n", ifname);\r\nerr = -EINVAL;\r\n} else if (!netif_running(odev)) {\r\npr_err("device is down: \"%s\"\n", ifname);\r\nerr = -ENETDOWN;\r\n} else {\r\npkt_dev->odev = odev;\r\nreturn 0;\r\n}\r\ndev_put(odev);\r\nreturn err;\r\n}\r\nstatic void pktgen_setup_inject(struct pktgen_dev *pkt_dev)\r\n{\r\nint ntxq;\r\nif (!pkt_dev->odev) {\r\npr_err("ERROR: pkt_dev->odev == NULL in setup_inject\n");\r\nsprintf(pkt_dev->result,\r\n"ERROR: pkt_dev->odev == NULL in setup_inject.\n");\r\nreturn;\r\n}\r\nntxq = pkt_dev->odev->real_num_tx_queues;\r\nif (ntxq <= pkt_dev->queue_map_min) {\r\npr_warn("WARNING: Requested queue_map_min (zero-based) (%d) exceeds valid range [0 - %d] for (%d) queues on %s, resetting\n",\r\npkt_dev->queue_map_min, (ntxq ?: 1) - 1, ntxq,\r\npkt_dev->odevname);\r\npkt_dev->queue_map_min = (ntxq ?: 1) - 1;\r\n}\r\nif (pkt_dev->queue_map_max >= ntxq) {\r\npr_warn("WARNING: Requested queue_map_max (zero-based) (%d) exceeds valid range [0 - %d] for (%d) queues on %s, resetting\n",\r\npkt_dev->queue_map_max, (ntxq ?: 1) - 1, ntxq,\r\npkt_dev->odevname);\r\npkt_dev->queue_map_max = (ntxq ?: 1) - 1;\r\n}\r\nif (is_zero_ether_addr(pkt_dev->src_mac))\r\nether_addr_copy(&(pkt_dev->hh[6]), pkt_dev->odev->dev_addr);\r\nether_addr_copy(&(pkt_dev->hh[0]), pkt_dev->dst_mac);\r\nif (pkt_dev->flags & F_IPV6) {\r\nint i, set = 0, err = 1;\r\nstruct inet6_dev *idev;\r\nif (pkt_dev->min_pkt_size == 0) {\r\npkt_dev->min_pkt_size = 14 + sizeof(struct ipv6hdr)\r\n+ sizeof(struct udphdr)\r\n+ sizeof(struct pktgen_hdr)\r\n+ pkt_dev->pkt_overhead;\r\n}\r\nfor (i = 0; i < IN6_ADDR_HSIZE; i++)\r\nif (pkt_dev->cur_in6_saddr.s6_addr[i]) {\r\nset = 1;\r\nbreak;\r\n}\r\nif (!set) {\r\nrcu_read_lock();\r\nidev = __in6_dev_get(pkt_dev->odev);\r\nif (idev) {\r\nstruct inet6_ifaddr *ifp;\r\nread_lock_bh(&idev->lock);\r\nlist_for_each_entry(ifp, &idev->addr_list, if_list) {\r\nif ((ifp->scope & IFA_LINK) &&\r\n!(ifp->flags & IFA_F_TENTATIVE)) {\r\npkt_dev->cur_in6_saddr = ifp->addr;\r\nerr = 0;\r\nbreak;\r\n}\r\n}\r\nread_unlock_bh(&idev->lock);\r\n}\r\nrcu_read_unlock();\r\nif (err)\r\npr_err("ERROR: IPv6 link address not available\n");\r\n}\r\n} else {\r\nif (pkt_dev->min_pkt_size == 0) {\r\npkt_dev->min_pkt_size = 14 + sizeof(struct iphdr)\r\n+ sizeof(struct udphdr)\r\n+ sizeof(struct pktgen_hdr)\r\n+ pkt_dev->pkt_overhead;\r\n}\r\npkt_dev->saddr_min = 0;\r\npkt_dev->saddr_max = 0;\r\nif (strlen(pkt_dev->src_min) == 0) {\r\nstruct in_device *in_dev;\r\nrcu_read_lock();\r\nin_dev = __in_dev_get_rcu(pkt_dev->odev);\r\nif (in_dev) {\r\nif (in_dev->ifa_list) {\r\npkt_dev->saddr_min =\r\nin_dev->ifa_list->ifa_address;\r\npkt_dev->saddr_max = pkt_dev->saddr_min;\r\n}\r\n}\r\nrcu_read_unlock();\r\n} else {\r\npkt_dev->saddr_min = in_aton(pkt_dev->src_min);\r\npkt_dev->saddr_max = in_aton(pkt_dev->src_max);\r\n}\r\npkt_dev->daddr_min = in_aton(pkt_dev->dst_min);\r\npkt_dev->daddr_max = in_aton(pkt_dev->dst_max);\r\n}\r\npkt_dev->cur_pkt_size = pkt_dev->min_pkt_size;\r\nif (pkt_dev->min_pkt_size > pkt_dev->max_pkt_size)\r\npkt_dev->max_pkt_size = pkt_dev->min_pkt_size;\r\npkt_dev->cur_dst_mac_offset = 0;\r\npkt_dev->cur_src_mac_offset = 0;\r\npkt_dev->cur_saddr = pkt_dev->saddr_min;\r\npkt_dev->cur_daddr = pkt_dev->daddr_min;\r\npkt_dev->cur_udp_dst = pkt_dev->udp_dst_min;\r\npkt_dev->cur_udp_src = pkt_dev->udp_src_min;\r\npkt_dev->nflows = 0;\r\n}\r\nstatic void spin(struct pktgen_dev *pkt_dev, ktime_t spin_until)\r\n{\r\nktime_t start_time, end_time;\r\ns64 remaining;\r\nstruct hrtimer_sleeper t;\r\nhrtimer_init_on_stack(&t.timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\r\nhrtimer_set_expires(&t.timer, spin_until);\r\nremaining = ktime_to_ns(hrtimer_expires_remaining(&t.timer));\r\nif (remaining <= 0)\r\ngoto out;\r\nstart_time = ktime_get();\r\nif (remaining < 100000) {\r\ndo {\r\nend_time = ktime_get();\r\n} while (ktime_compare(end_time, spin_until) < 0);\r\n} else {\r\nhrtimer_init_sleeper(&t, current);\r\ndo {\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nhrtimer_start_expires(&t.timer, HRTIMER_MODE_ABS);\r\nif (likely(t.task))\r\nschedule();\r\nhrtimer_cancel(&t.timer);\r\n} while (t.task && pkt_dev->running && !signal_pending(current));\r\n__set_current_state(TASK_RUNNING);\r\nend_time = ktime_get();\r\n}\r\npkt_dev->idle_acc += ktime_to_ns(ktime_sub(end_time, start_time));\r\nout:\r\npkt_dev->next_tx = ktime_add_ns(spin_until, pkt_dev->delay);\r\ndestroy_hrtimer_on_stack(&t.timer);\r\n}\r\nstatic inline void set_pkt_overhead(struct pktgen_dev *pkt_dev)\r\n{\r\npkt_dev->pkt_overhead = 0;\r\npkt_dev->pkt_overhead += pkt_dev->nr_labels*sizeof(u32);\r\npkt_dev->pkt_overhead += VLAN_TAG_SIZE(pkt_dev);\r\npkt_dev->pkt_overhead += SVLAN_TAG_SIZE(pkt_dev);\r\n}\r\nstatic inline int f_seen(const struct pktgen_dev *pkt_dev, int flow)\r\n{\r\nreturn !!(pkt_dev->flows[flow].flags & F_INIT);\r\n}\r\nstatic inline int f_pick(struct pktgen_dev *pkt_dev)\r\n{\r\nint flow = pkt_dev->curfl;\r\nif (pkt_dev->flags & F_FLOW_SEQ) {\r\nif (pkt_dev->flows[flow].count >= pkt_dev->lflow) {\r\npkt_dev->flows[flow].count = 0;\r\npkt_dev->flows[flow].flags = 0;\r\npkt_dev->curfl += 1;\r\nif (pkt_dev->curfl >= pkt_dev->cflows)\r\npkt_dev->curfl = 0;\r\n}\r\n} else {\r\nflow = prandom_u32() % pkt_dev->cflows;\r\npkt_dev->curfl = flow;\r\nif (pkt_dev->flows[flow].count > pkt_dev->lflow) {\r\npkt_dev->flows[flow].count = 0;\r\npkt_dev->flows[flow].flags = 0;\r\n}\r\n}\r\nreturn pkt_dev->curfl;\r\n}\r\nstatic void get_ipsec_sa(struct pktgen_dev *pkt_dev, int flow)\r\n{\r\nstruct xfrm_state *x = pkt_dev->flows[flow].x;\r\nstruct pktgen_net *pn = net_generic(dev_net(pkt_dev->odev), pg_net_id);\r\nif (!x) {\r\nif (pkt_dev->spi) {\r\nx = xfrm_state_lookup_byspi(pn->net, htonl(pkt_dev->spi), AF_INET);\r\n} else {\r\nx = xfrm_stateonly_find(pn->net, DUMMY_MARK,\r\n(xfrm_address_t *)&pkt_dev->cur_daddr,\r\n(xfrm_address_t *)&pkt_dev->cur_saddr,\r\nAF_INET,\r\npkt_dev->ipsmode,\r\npkt_dev->ipsproto, 0);\r\n}\r\nif (x) {\r\npkt_dev->flows[flow].x = x;\r\nset_pkt_overhead(pkt_dev);\r\npkt_dev->pkt_overhead += x->props.header_len;\r\n}\r\n}\r\n}\r\nstatic void set_cur_queue_map(struct pktgen_dev *pkt_dev)\r\n{\r\nif (pkt_dev->flags & F_QUEUE_MAP_CPU)\r\npkt_dev->cur_queue_map = smp_processor_id();\r\nelse if (pkt_dev->queue_map_min <= pkt_dev->queue_map_max) {\r\n__u16 t;\r\nif (pkt_dev->flags & F_QUEUE_MAP_RND) {\r\nt = prandom_u32() %\r\n(pkt_dev->queue_map_max -\r\npkt_dev->queue_map_min + 1)\r\n+ pkt_dev->queue_map_min;\r\n} else {\r\nt = pkt_dev->cur_queue_map + 1;\r\nif (t > pkt_dev->queue_map_max)\r\nt = pkt_dev->queue_map_min;\r\n}\r\npkt_dev->cur_queue_map = t;\r\n}\r\npkt_dev->cur_queue_map = pkt_dev->cur_queue_map % pkt_dev->odev->real_num_tx_queues;\r\n}\r\nstatic void mod_cur_headers(struct pktgen_dev *pkt_dev)\r\n{\r\n__u32 imn;\r\n__u32 imx;\r\nint flow = 0;\r\nif (pkt_dev->cflows)\r\nflow = f_pick(pkt_dev);\r\nif (pkt_dev->src_mac_count > 1) {\r\n__u32 mc;\r\n__u32 tmp;\r\nif (pkt_dev->flags & F_MACSRC_RND)\r\nmc = prandom_u32() % pkt_dev->src_mac_count;\r\nelse {\r\nmc = pkt_dev->cur_src_mac_offset++;\r\nif (pkt_dev->cur_src_mac_offset >=\r\npkt_dev->src_mac_count)\r\npkt_dev->cur_src_mac_offset = 0;\r\n}\r\ntmp = pkt_dev->src_mac[5] + (mc & 0xFF);\r\npkt_dev->hh[11] = tmp;\r\ntmp = (pkt_dev->src_mac[4] + ((mc >> 8) & 0xFF) + (tmp >> 8));\r\npkt_dev->hh[10] = tmp;\r\ntmp = (pkt_dev->src_mac[3] + ((mc >> 16) & 0xFF) + (tmp >> 8));\r\npkt_dev->hh[9] = tmp;\r\ntmp = (pkt_dev->src_mac[2] + ((mc >> 24) & 0xFF) + (tmp >> 8));\r\npkt_dev->hh[8] = tmp;\r\ntmp = (pkt_dev->src_mac[1] + (tmp >> 8));\r\npkt_dev->hh[7] = tmp;\r\n}\r\nif (pkt_dev->dst_mac_count > 1) {\r\n__u32 mc;\r\n__u32 tmp;\r\nif (pkt_dev->flags & F_MACDST_RND)\r\nmc = prandom_u32() % pkt_dev->dst_mac_count;\r\nelse {\r\nmc = pkt_dev->cur_dst_mac_offset++;\r\nif (pkt_dev->cur_dst_mac_offset >=\r\npkt_dev->dst_mac_count) {\r\npkt_dev->cur_dst_mac_offset = 0;\r\n}\r\n}\r\ntmp = pkt_dev->dst_mac[5] + (mc & 0xFF);\r\npkt_dev->hh[5] = tmp;\r\ntmp = (pkt_dev->dst_mac[4] + ((mc >> 8) & 0xFF) + (tmp >> 8));\r\npkt_dev->hh[4] = tmp;\r\ntmp = (pkt_dev->dst_mac[3] + ((mc >> 16) & 0xFF) + (tmp >> 8));\r\npkt_dev->hh[3] = tmp;\r\ntmp = (pkt_dev->dst_mac[2] + ((mc >> 24) & 0xFF) + (tmp >> 8));\r\npkt_dev->hh[2] = tmp;\r\ntmp = (pkt_dev->dst_mac[1] + (tmp >> 8));\r\npkt_dev->hh[1] = tmp;\r\n}\r\nif (pkt_dev->flags & F_MPLS_RND) {\r\nunsigned int i;\r\nfor (i = 0; i < pkt_dev->nr_labels; i++)\r\nif (pkt_dev->labels[i] & MPLS_STACK_BOTTOM)\r\npkt_dev->labels[i] = MPLS_STACK_BOTTOM |\r\n((__force __be32)prandom_u32() &\r\nhtonl(0x000fffff));\r\n}\r\nif ((pkt_dev->flags & F_VID_RND) && (pkt_dev->vlan_id != 0xffff)) {\r\npkt_dev->vlan_id = prandom_u32() & (4096 - 1);\r\n}\r\nif ((pkt_dev->flags & F_SVID_RND) && (pkt_dev->svlan_id != 0xffff)) {\r\npkt_dev->svlan_id = prandom_u32() & (4096 - 1);\r\n}\r\nif (pkt_dev->udp_src_min < pkt_dev->udp_src_max) {\r\nif (pkt_dev->flags & F_UDPSRC_RND)\r\npkt_dev->cur_udp_src = prandom_u32() %\r\n(pkt_dev->udp_src_max - pkt_dev->udp_src_min)\r\n+ pkt_dev->udp_src_min;\r\nelse {\r\npkt_dev->cur_udp_src++;\r\nif (pkt_dev->cur_udp_src >= pkt_dev->udp_src_max)\r\npkt_dev->cur_udp_src = pkt_dev->udp_src_min;\r\n}\r\n}\r\nif (pkt_dev->udp_dst_min < pkt_dev->udp_dst_max) {\r\nif (pkt_dev->flags & F_UDPDST_RND) {\r\npkt_dev->cur_udp_dst = prandom_u32() %\r\n(pkt_dev->udp_dst_max - pkt_dev->udp_dst_min)\r\n+ pkt_dev->udp_dst_min;\r\n} else {\r\npkt_dev->cur_udp_dst++;\r\nif (pkt_dev->cur_udp_dst >= pkt_dev->udp_dst_max)\r\npkt_dev->cur_udp_dst = pkt_dev->udp_dst_min;\r\n}\r\n}\r\nif (!(pkt_dev->flags & F_IPV6)) {\r\nimn = ntohl(pkt_dev->saddr_min);\r\nimx = ntohl(pkt_dev->saddr_max);\r\nif (imn < imx) {\r\n__u32 t;\r\nif (pkt_dev->flags & F_IPSRC_RND)\r\nt = prandom_u32() % (imx - imn) + imn;\r\nelse {\r\nt = ntohl(pkt_dev->cur_saddr);\r\nt++;\r\nif (t > imx)\r\nt = imn;\r\n}\r\npkt_dev->cur_saddr = htonl(t);\r\n}\r\nif (pkt_dev->cflows && f_seen(pkt_dev, flow)) {\r\npkt_dev->cur_daddr = pkt_dev->flows[flow].cur_daddr;\r\n} else {\r\nimn = ntohl(pkt_dev->daddr_min);\r\nimx = ntohl(pkt_dev->daddr_max);\r\nif (imn < imx) {\r\n__u32 t;\r\n__be32 s;\r\nif (pkt_dev->flags & F_IPDST_RND) {\r\ndo {\r\nt = prandom_u32() %\r\n(imx - imn) + imn;\r\ns = htonl(t);\r\n} while (ipv4_is_loopback(s) ||\r\nipv4_is_multicast(s) ||\r\nipv4_is_lbcast(s) ||\r\nipv4_is_zeronet(s) ||\r\nipv4_is_local_multicast(s));\r\npkt_dev->cur_daddr = s;\r\n} else {\r\nt = ntohl(pkt_dev->cur_daddr);\r\nt++;\r\nif (t > imx) {\r\nt = imn;\r\n}\r\npkt_dev->cur_daddr = htonl(t);\r\n}\r\n}\r\nif (pkt_dev->cflows) {\r\npkt_dev->flows[flow].flags |= F_INIT;\r\npkt_dev->flows[flow].cur_daddr =\r\npkt_dev->cur_daddr;\r\n#ifdef CONFIG_XFRM\r\nif (pkt_dev->flags & F_IPSEC_ON)\r\nget_ipsec_sa(pkt_dev, flow);\r\n#endif\r\npkt_dev->nflows++;\r\n}\r\n}\r\n} else {\r\nif (!ipv6_addr_any(&pkt_dev->min_in6_daddr)) {\r\nint i;\r\nfor (i = 0; i < 4; i++) {\r\npkt_dev->cur_in6_daddr.s6_addr32[i] =\r\n(((__force __be32)prandom_u32() |\r\npkt_dev->min_in6_daddr.s6_addr32[i]) &\r\npkt_dev->max_in6_daddr.s6_addr32[i]);\r\n}\r\n}\r\n}\r\nif (pkt_dev->min_pkt_size < pkt_dev->max_pkt_size) {\r\n__u32 t;\r\nif (pkt_dev->flags & F_TXSIZE_RND) {\r\nt = prandom_u32() %\r\n(pkt_dev->max_pkt_size - pkt_dev->min_pkt_size)\r\n+ pkt_dev->min_pkt_size;\r\n} else {\r\nt = pkt_dev->cur_pkt_size + 1;\r\nif (t > pkt_dev->max_pkt_size)\r\nt = pkt_dev->min_pkt_size;\r\n}\r\npkt_dev->cur_pkt_size = t;\r\n}\r\nset_cur_queue_map(pkt_dev);\r\npkt_dev->flows[flow].count++;\r\n}\r\nstatic int pktgen_output_ipsec(struct sk_buff *skb, struct pktgen_dev *pkt_dev)\r\n{\r\nstruct xfrm_state *x = pkt_dev->flows[pkt_dev->curfl].x;\r\nint err = 0;\r\nstruct net *net = dev_net(pkt_dev->odev);\r\nif (!x)\r\nreturn 0;\r\nif ((x->props.mode != XFRM_MODE_TRANSPORT) && (pkt_dev->spi == 0))\r\nreturn 0;\r\nif ((x->props.mode == XFRM_MODE_TUNNEL) && (pkt_dev->spi != 0))\r\nskb->_skb_refdst = (unsigned long)&pkt_dev->dst | SKB_DST_NOREF;\r\nrcu_read_lock_bh();\r\nerr = x->outer_mode->output(x, skb);\r\nrcu_read_unlock_bh();\r\nif (err) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEMODEERROR);\r\ngoto error;\r\n}\r\nerr = x->type->output(x, skb);\r\nif (err) {\r\nXFRM_INC_STATS(net, LINUX_MIB_XFRMOUTSTATEPROTOERROR);\r\ngoto error;\r\n}\r\nspin_lock_bh(&x->lock);\r\nx->curlft.bytes += skb->len;\r\nx->curlft.packets++;\r\nspin_unlock_bh(&x->lock);\r\nerror:\r\nreturn err;\r\n}\r\nstatic void free_SAs(struct pktgen_dev *pkt_dev)\r\n{\r\nif (pkt_dev->cflows) {\r\nint i;\r\nfor (i = 0; i < pkt_dev->cflows; i++) {\r\nstruct xfrm_state *x = pkt_dev->flows[i].x;\r\nif (x) {\r\nxfrm_state_put(x);\r\npkt_dev->flows[i].x = NULL;\r\n}\r\n}\r\n}\r\n}\r\nstatic int process_ipsec(struct pktgen_dev *pkt_dev,\r\nstruct sk_buff *skb, __be16 protocol)\r\n{\r\nif (pkt_dev->flags & F_IPSEC_ON) {\r\nstruct xfrm_state *x = pkt_dev->flows[pkt_dev->curfl].x;\r\nint nhead = 0;\r\nif (x) {\r\nstruct ethhdr *eth;\r\nstruct iphdr *iph;\r\nint ret;\r\nnhead = x->props.header_len - skb_headroom(skb);\r\nif (nhead > 0) {\r\nret = pskb_expand_head(skb, nhead, 0, GFP_ATOMIC);\r\nif (ret < 0) {\r\npr_err("Error expanding ipsec packet %d\n",\r\nret);\r\ngoto err;\r\n}\r\n}\r\nskb_pull(skb, ETH_HLEN);\r\nret = pktgen_output_ipsec(skb, pkt_dev);\r\nif (ret) {\r\npr_err("Error creating ipsec packet %d\n", ret);\r\ngoto err;\r\n}\r\neth = (struct ethhdr *)skb_push(skb, ETH_HLEN);\r\nmemcpy(eth, pkt_dev->hh, 2 * ETH_ALEN);\r\neth->h_proto = protocol;\r\niph = ip_hdr(skb);\r\niph->tot_len = htons(skb->len - ETH_HLEN);\r\nip_send_check(iph);\r\n}\r\n}\r\nreturn 1;\r\nerr:\r\nkfree_skb(skb);\r\nreturn 0;\r\n}\r\nstatic void mpls_push(__be32 *mpls, struct pktgen_dev *pkt_dev)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < pkt_dev->nr_labels; i++)\r\n*mpls++ = pkt_dev->labels[i] & ~MPLS_STACK_BOTTOM;\r\nmpls--;\r\n*mpls |= MPLS_STACK_BOTTOM;\r\n}\r\nstatic inline __be16 build_tci(unsigned int id, unsigned int cfi,\r\nunsigned int prio)\r\n{\r\nreturn htons(id | (cfi << 12) | (prio << 13));\r\n}\r\nstatic void pktgen_finalize_skb(struct pktgen_dev *pkt_dev, struct sk_buff *skb,\r\nint datalen)\r\n{\r\nstruct timeval timestamp;\r\nstruct pktgen_hdr *pgh;\r\npgh = (struct pktgen_hdr *)skb_put(skb, sizeof(*pgh));\r\ndatalen -= sizeof(*pgh);\r\nif (pkt_dev->nfrags <= 0) {\r\nmemset(skb_put(skb, datalen), 0, datalen);\r\n} else {\r\nint frags = pkt_dev->nfrags;\r\nint i, len;\r\nint frag_len;\r\nif (frags > MAX_SKB_FRAGS)\r\nfrags = MAX_SKB_FRAGS;\r\nlen = datalen - frags * PAGE_SIZE;\r\nif (len > 0) {\r\nmemset(skb_put(skb, len), 0, len);\r\ndatalen = frags * PAGE_SIZE;\r\n}\r\ni = 0;\r\nfrag_len = (datalen/frags) < PAGE_SIZE ?\r\n(datalen/frags) : PAGE_SIZE;\r\nwhile (datalen > 0) {\r\nif (unlikely(!pkt_dev->page)) {\r\nint node = numa_node_id();\r\nif (pkt_dev->node >= 0 && (pkt_dev->flags & F_NODE))\r\nnode = pkt_dev->node;\r\npkt_dev->page = alloc_pages_node(node, GFP_KERNEL | __GFP_ZERO, 0);\r\nif (!pkt_dev->page)\r\nbreak;\r\n}\r\nget_page(pkt_dev->page);\r\nskb_frag_set_page(skb, i, pkt_dev->page);\r\nskb_shinfo(skb)->frags[i].page_offset = 0;\r\nif (i == (frags - 1))\r\nskb_frag_size_set(&skb_shinfo(skb)->frags[i],\r\n(datalen < PAGE_SIZE ? datalen : PAGE_SIZE));\r\nelse\r\nskb_frag_size_set(&skb_shinfo(skb)->frags[i], frag_len);\r\ndatalen -= skb_frag_size(&skb_shinfo(skb)->frags[i]);\r\nskb->len += skb_frag_size(&skb_shinfo(skb)->frags[i]);\r\nskb->data_len += skb_frag_size(&skb_shinfo(skb)->frags[i]);\r\ni++;\r\nskb_shinfo(skb)->nr_frags = i;\r\n}\r\n}\r\npgh->pgh_magic = htonl(PKTGEN_MAGIC);\r\npgh->seq_num = htonl(pkt_dev->seq_num);\r\nif (pkt_dev->flags & F_NO_TIMESTAMP) {\r\npgh->tv_sec = 0;\r\npgh->tv_usec = 0;\r\n} else {\r\ndo_gettimeofday(&timestamp);\r\npgh->tv_sec = htonl(timestamp.tv_sec);\r\npgh->tv_usec = htonl(timestamp.tv_usec);\r\n}\r\n}\r\nstatic struct sk_buff *pktgen_alloc_skb(struct net_device *dev,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\nunsigned int extralen = LL_RESERVED_SPACE(dev);\r\nstruct sk_buff *skb = NULL;\r\nunsigned int size;\r\nsize = pkt_dev->cur_pkt_size + 64 + extralen + pkt_dev->pkt_overhead;\r\nif (pkt_dev->flags & F_NODE) {\r\nint node = pkt_dev->node >= 0 ? pkt_dev->node : numa_node_id();\r\nskb = __alloc_skb(NET_SKB_PAD + size, GFP_NOWAIT, 0, node);\r\nif (likely(skb)) {\r\nskb_reserve(skb, NET_SKB_PAD);\r\nskb->dev = dev;\r\n}\r\n} else {\r\nskb = __netdev_alloc_skb(dev, size, GFP_NOWAIT);\r\n}\r\nif (likely(skb))\r\nskb_reserve(skb, extralen - 16);\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *fill_packet_ipv4(struct net_device *odev,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\nstruct sk_buff *skb = NULL;\r\n__u8 *eth;\r\nstruct udphdr *udph;\r\nint datalen, iplen;\r\nstruct iphdr *iph;\r\n__be16 protocol = htons(ETH_P_IP);\r\n__be32 *mpls;\r\n__be16 *vlan_tci = NULL;\r\n__be16 *vlan_encapsulated_proto = NULL;\r\n__be16 *svlan_tci = NULL;\r\n__be16 *svlan_encapsulated_proto = NULL;\r\nu16 queue_map;\r\nif (pkt_dev->nr_labels)\r\nprotocol = htons(ETH_P_MPLS_UC);\r\nif (pkt_dev->vlan_id != 0xffff)\r\nprotocol = htons(ETH_P_8021Q);\r\nmod_cur_headers(pkt_dev);\r\nqueue_map = pkt_dev->cur_queue_map;\r\nskb = pktgen_alloc_skb(odev, pkt_dev);\r\nif (!skb) {\r\nsprintf(pkt_dev->result, "No memory");\r\nreturn NULL;\r\n}\r\nprefetchw(skb->data);\r\nskb_reserve(skb, 16);\r\neth = (__u8 *) skb_push(skb, 14);\r\nmpls = (__be32 *)skb_put(skb, pkt_dev->nr_labels*sizeof(__u32));\r\nif (pkt_dev->nr_labels)\r\nmpls_push(mpls, pkt_dev);\r\nif (pkt_dev->vlan_id != 0xffff) {\r\nif (pkt_dev->svlan_id != 0xffff) {\r\nsvlan_tci = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*svlan_tci = build_tci(pkt_dev->svlan_id,\r\npkt_dev->svlan_cfi,\r\npkt_dev->svlan_p);\r\nsvlan_encapsulated_proto = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*svlan_encapsulated_proto = htons(ETH_P_8021Q);\r\n}\r\nvlan_tci = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*vlan_tci = build_tci(pkt_dev->vlan_id,\r\npkt_dev->vlan_cfi,\r\npkt_dev->vlan_p);\r\nvlan_encapsulated_proto = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*vlan_encapsulated_proto = htons(ETH_P_IP);\r\n}\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, skb->len);\r\niph = (struct iphdr *) skb_put(skb, sizeof(struct iphdr));\r\nskb_set_transport_header(skb, skb->len);\r\nudph = (struct udphdr *) skb_put(skb, sizeof(struct udphdr));\r\nskb_set_queue_mapping(skb, queue_map);\r\nskb->priority = pkt_dev->skb_priority;\r\nmemcpy(eth, pkt_dev->hh, 12);\r\n*(__be16 *) & eth[12] = protocol;\r\ndatalen = pkt_dev->cur_pkt_size - 14 - 20 - 8 -\r\npkt_dev->pkt_overhead;\r\nif (datalen < 0 || datalen < sizeof(struct pktgen_hdr))\r\ndatalen = sizeof(struct pktgen_hdr);\r\nudph->source = htons(pkt_dev->cur_udp_src);\r\nudph->dest = htons(pkt_dev->cur_udp_dst);\r\nudph->len = htons(datalen + 8);\r\nudph->check = 0;\r\niph->ihl = 5;\r\niph->version = 4;\r\niph->ttl = 32;\r\niph->tos = pkt_dev->tos;\r\niph->protocol = IPPROTO_UDP;\r\niph->saddr = pkt_dev->cur_saddr;\r\niph->daddr = pkt_dev->cur_daddr;\r\niph->id = htons(pkt_dev->ip_id);\r\npkt_dev->ip_id++;\r\niph->frag_off = 0;\r\niplen = 20 + 8 + datalen;\r\niph->tot_len = htons(iplen);\r\nip_send_check(iph);\r\nskb->protocol = protocol;\r\nskb->dev = odev;\r\nskb->pkt_type = PACKET_HOST;\r\npktgen_finalize_skb(pkt_dev, skb, datalen);\r\nif (!(pkt_dev->flags & F_UDPCSUM)) {\r\nskb->ip_summed = CHECKSUM_NONE;\r\n} else if (odev->features & (NETIF_F_HW_CSUM | NETIF_F_IP_CSUM)) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum = 0;\r\nudp4_hwcsum(skb, iph->saddr, iph->daddr);\r\n} else {\r\n__wsum csum = skb_checksum(skb, skb_transport_offset(skb), datalen + 8, 0);\r\nudph->check = csum_tcpudp_magic(iph->saddr, iph->daddr,\r\ndatalen + 8, IPPROTO_UDP, csum);\r\nif (udph->check == 0)\r\nudph->check = CSUM_MANGLED_0;\r\n}\r\n#ifdef CONFIG_XFRM\r\nif (!process_ipsec(pkt_dev, skb, protocol))\r\nreturn NULL;\r\n#endif\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *fill_packet_ipv6(struct net_device *odev,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\nstruct sk_buff *skb = NULL;\r\n__u8 *eth;\r\nstruct udphdr *udph;\r\nint datalen, udplen;\r\nstruct ipv6hdr *iph;\r\n__be16 protocol = htons(ETH_P_IPV6);\r\n__be32 *mpls;\r\n__be16 *vlan_tci = NULL;\r\n__be16 *vlan_encapsulated_proto = NULL;\r\n__be16 *svlan_tci = NULL;\r\n__be16 *svlan_encapsulated_proto = NULL;\r\nu16 queue_map;\r\nif (pkt_dev->nr_labels)\r\nprotocol = htons(ETH_P_MPLS_UC);\r\nif (pkt_dev->vlan_id != 0xffff)\r\nprotocol = htons(ETH_P_8021Q);\r\nmod_cur_headers(pkt_dev);\r\nqueue_map = pkt_dev->cur_queue_map;\r\nskb = pktgen_alloc_skb(odev, pkt_dev);\r\nif (!skb) {\r\nsprintf(pkt_dev->result, "No memory");\r\nreturn NULL;\r\n}\r\nprefetchw(skb->data);\r\nskb_reserve(skb, 16);\r\neth = (__u8 *) skb_push(skb, 14);\r\nmpls = (__be32 *)skb_put(skb, pkt_dev->nr_labels*sizeof(__u32));\r\nif (pkt_dev->nr_labels)\r\nmpls_push(mpls, pkt_dev);\r\nif (pkt_dev->vlan_id != 0xffff) {\r\nif (pkt_dev->svlan_id != 0xffff) {\r\nsvlan_tci = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*svlan_tci = build_tci(pkt_dev->svlan_id,\r\npkt_dev->svlan_cfi,\r\npkt_dev->svlan_p);\r\nsvlan_encapsulated_proto = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*svlan_encapsulated_proto = htons(ETH_P_8021Q);\r\n}\r\nvlan_tci = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*vlan_tci = build_tci(pkt_dev->vlan_id,\r\npkt_dev->vlan_cfi,\r\npkt_dev->vlan_p);\r\nvlan_encapsulated_proto = (__be16 *)skb_put(skb, sizeof(__be16));\r\n*vlan_encapsulated_proto = htons(ETH_P_IPV6);\r\n}\r\nskb_reset_mac_header(skb);\r\nskb_set_network_header(skb, skb->len);\r\niph = (struct ipv6hdr *) skb_put(skb, sizeof(struct ipv6hdr));\r\nskb_set_transport_header(skb, skb->len);\r\nudph = (struct udphdr *) skb_put(skb, sizeof(struct udphdr));\r\nskb_set_queue_mapping(skb, queue_map);\r\nskb->priority = pkt_dev->skb_priority;\r\nmemcpy(eth, pkt_dev->hh, 12);\r\n*(__be16 *) &eth[12] = protocol;\r\ndatalen = pkt_dev->cur_pkt_size - 14 -\r\nsizeof(struct ipv6hdr) - sizeof(struct udphdr) -\r\npkt_dev->pkt_overhead;\r\nif (datalen < 0 || datalen < sizeof(struct pktgen_hdr)) {\r\ndatalen = sizeof(struct pktgen_hdr);\r\nnet_info_ratelimited("increased datalen to %d\n", datalen);\r\n}\r\nudplen = datalen + sizeof(struct udphdr);\r\nudph->source = htons(pkt_dev->cur_udp_src);\r\nudph->dest = htons(pkt_dev->cur_udp_dst);\r\nudph->len = htons(udplen);\r\nudph->check = 0;\r\n*(__be32 *) iph = htonl(0x60000000);\r\nif (pkt_dev->traffic_class) {\r\n*(__be32 *)iph |= htonl(0x60000000 | (pkt_dev->traffic_class << 20));\r\n}\r\niph->hop_limit = 32;\r\niph->payload_len = htons(udplen);\r\niph->nexthdr = IPPROTO_UDP;\r\niph->daddr = pkt_dev->cur_in6_daddr;\r\niph->saddr = pkt_dev->cur_in6_saddr;\r\nskb->protocol = protocol;\r\nskb->dev = odev;\r\nskb->pkt_type = PACKET_HOST;\r\npktgen_finalize_skb(pkt_dev, skb, datalen);\r\nif (!(pkt_dev->flags & F_UDPCSUM)) {\r\nskb->ip_summed = CHECKSUM_NONE;\r\n} else if (odev->features & (NETIF_F_HW_CSUM | NETIF_F_IPV6_CSUM)) {\r\nskb->ip_summed = CHECKSUM_PARTIAL;\r\nskb->csum_start = skb_transport_header(skb) - skb->head;\r\nskb->csum_offset = offsetof(struct udphdr, check);\r\nudph->check = ~csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, 0);\r\n} else {\r\n__wsum csum = skb_checksum(skb, skb_transport_offset(skb), udplen, 0);\r\nudph->check = csum_ipv6_magic(&iph->saddr, &iph->daddr, udplen, IPPROTO_UDP, csum);\r\nif (udph->check == 0)\r\nudph->check = CSUM_MANGLED_0;\r\n}\r\nreturn skb;\r\n}\r\nstatic struct sk_buff *fill_packet(struct net_device *odev,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\nif (pkt_dev->flags & F_IPV6)\r\nreturn fill_packet_ipv6(odev, pkt_dev);\r\nelse\r\nreturn fill_packet_ipv4(odev, pkt_dev);\r\n}\r\nstatic void pktgen_clear_counters(struct pktgen_dev *pkt_dev)\r\n{\r\npkt_dev->seq_num = 1;\r\npkt_dev->idle_acc = 0;\r\npkt_dev->sofar = 0;\r\npkt_dev->tx_bytes = 0;\r\npkt_dev->errors = 0;\r\n}\r\nstatic void pktgen_run(struct pktgen_thread *t)\r\n{\r\nstruct pktgen_dev *pkt_dev;\r\nint started = 0;\r\nfunc_enter();\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pkt_dev, &t->if_list, list) {\r\npktgen_setup_inject(pkt_dev);\r\nif (pkt_dev->odev) {\r\npktgen_clear_counters(pkt_dev);\r\npkt_dev->skb = NULL;\r\npkt_dev->started_at = pkt_dev->next_tx = ktime_get();\r\nset_pkt_overhead(pkt_dev);\r\nstrcpy(pkt_dev->result, "Starting");\r\npkt_dev->running = 1;\r\nstarted++;\r\n} else\r\nstrcpy(pkt_dev->result, "Error starting");\r\n}\r\nrcu_read_unlock();\r\nif (started)\r\nt->control &= ~(T_STOP);\r\n}\r\nstatic void pktgen_stop_all_threads_ifs(struct pktgen_net *pn)\r\n{\r\nstruct pktgen_thread *t;\r\nfunc_enter();\r\nmutex_lock(&pktgen_thread_lock);\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list)\r\nt->control |= T_STOP;\r\nmutex_unlock(&pktgen_thread_lock);\r\n}\r\nstatic int thread_is_running(const struct pktgen_thread *t)\r\n{\r\nconst struct pktgen_dev *pkt_dev;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pkt_dev, &t->if_list, list)\r\nif (pkt_dev->running) {\r\nrcu_read_unlock();\r\nreturn 1;\r\n}\r\nrcu_read_unlock();\r\nreturn 0;\r\n}\r\nstatic int pktgen_wait_thread_run(struct pktgen_thread *t)\r\n{\r\nwhile (thread_is_running(t)) {\r\nmsleep_interruptible(100);\r\nif (signal_pending(current))\r\ngoto signal;\r\n}\r\nreturn 1;\r\nsignal:\r\nreturn 0;\r\n}\r\nstatic int pktgen_wait_all_threads_run(struct pktgen_net *pn)\r\n{\r\nstruct pktgen_thread *t;\r\nint sig = 1;\r\nmutex_lock(&pktgen_thread_lock);\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list) {\r\nsig = pktgen_wait_thread_run(t);\r\nif (sig == 0)\r\nbreak;\r\n}\r\nif (sig == 0)\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list)\r\nt->control |= (T_STOP);\r\nmutex_unlock(&pktgen_thread_lock);\r\nreturn sig;\r\n}\r\nstatic void pktgen_run_all_threads(struct pktgen_net *pn)\r\n{\r\nstruct pktgen_thread *t;\r\nfunc_enter();\r\nmutex_lock(&pktgen_thread_lock);\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list)\r\nt->control |= (T_RUN);\r\nmutex_unlock(&pktgen_thread_lock);\r\nschedule_timeout_interruptible(msecs_to_jiffies(125));\r\npktgen_wait_all_threads_run(pn);\r\n}\r\nstatic void pktgen_reset_all_threads(struct pktgen_net *pn)\r\n{\r\nstruct pktgen_thread *t;\r\nfunc_enter();\r\nmutex_lock(&pktgen_thread_lock);\r\nlist_for_each_entry(t, &pn->pktgen_threads, th_list)\r\nt->control |= (T_REMDEVALL);\r\nmutex_unlock(&pktgen_thread_lock);\r\nschedule_timeout_interruptible(msecs_to_jiffies(125));\r\npktgen_wait_all_threads_run(pn);\r\n}\r\nstatic void show_results(struct pktgen_dev *pkt_dev, int nr_frags)\r\n{\r\n__u64 bps, mbps, pps;\r\nchar *p = pkt_dev->result;\r\nktime_t elapsed = ktime_sub(pkt_dev->stopped_at,\r\npkt_dev->started_at);\r\nktime_t idle = ns_to_ktime(pkt_dev->idle_acc);\r\np += sprintf(p, "OK: %llu(c%llu+d%llu) usec, %llu (%dbyte,%dfrags)\n",\r\n(unsigned long long)ktime_to_us(elapsed),\r\n(unsigned long long)ktime_to_us(ktime_sub(elapsed, idle)),\r\n(unsigned long long)ktime_to_us(idle),\r\n(unsigned long long)pkt_dev->sofar,\r\npkt_dev->cur_pkt_size, nr_frags);\r\npps = div64_u64(pkt_dev->sofar * NSEC_PER_SEC,\r\nktime_to_ns(elapsed));\r\nbps = pps * 8 * pkt_dev->cur_pkt_size;\r\nmbps = bps;\r\ndo_div(mbps, 1000000);\r\np += sprintf(p, " %llupps %lluMb/sec (%llubps) errors: %llu",\r\n(unsigned long long)pps,\r\n(unsigned long long)mbps,\r\n(unsigned long long)bps,\r\n(unsigned long long)pkt_dev->errors);\r\n}\r\nstatic int pktgen_stop_device(struct pktgen_dev *pkt_dev)\r\n{\r\nint nr_frags = pkt_dev->skb ? skb_shinfo(pkt_dev->skb)->nr_frags : -1;\r\nif (!pkt_dev->running) {\r\npr_warn("interface: %s is already stopped\n",\r\npkt_dev->odevname);\r\nreturn -EINVAL;\r\n}\r\npkt_dev->running = 0;\r\nkfree_skb(pkt_dev->skb);\r\npkt_dev->skb = NULL;\r\npkt_dev->stopped_at = ktime_get();\r\nshow_results(pkt_dev, nr_frags);\r\nreturn 0;\r\n}\r\nstatic struct pktgen_dev *next_to_run(struct pktgen_thread *t)\r\n{\r\nstruct pktgen_dev *pkt_dev, *best = NULL;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pkt_dev, &t->if_list, list) {\r\nif (!pkt_dev->running)\r\ncontinue;\r\nif (best == NULL)\r\nbest = pkt_dev;\r\nelse if (ktime_compare(pkt_dev->next_tx, best->next_tx) < 0)\r\nbest = pkt_dev;\r\n}\r\nrcu_read_unlock();\r\nreturn best;\r\n}\r\nstatic void pktgen_stop(struct pktgen_thread *t)\r\n{\r\nstruct pktgen_dev *pkt_dev;\r\nfunc_enter();\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(pkt_dev, &t->if_list, list) {\r\npktgen_stop_device(pkt_dev);\r\n}\r\nrcu_read_unlock();\r\n}\r\nstatic void pktgen_rem_one_if(struct pktgen_thread *t)\r\n{\r\nstruct list_head *q, *n;\r\nstruct pktgen_dev *cur;\r\nfunc_enter();\r\nlist_for_each_safe(q, n, &t->if_list) {\r\ncur = list_entry(q, struct pktgen_dev, list);\r\nif (!cur->removal_mark)\r\ncontinue;\r\nkfree_skb(cur->skb);\r\ncur->skb = NULL;\r\npktgen_remove_device(t, cur);\r\nbreak;\r\n}\r\n}\r\nstatic void pktgen_rem_all_ifs(struct pktgen_thread *t)\r\n{\r\nstruct list_head *q, *n;\r\nstruct pktgen_dev *cur;\r\nfunc_enter();\r\nlist_for_each_safe(q, n, &t->if_list) {\r\ncur = list_entry(q, struct pktgen_dev, list);\r\nkfree_skb(cur->skb);\r\ncur->skb = NULL;\r\npktgen_remove_device(t, cur);\r\n}\r\n}\r\nstatic void pktgen_rem_thread(struct pktgen_thread *t)\r\n{\r\nremove_proc_entry(t->tsk->comm, t->net->proc_dir);\r\n}\r\nstatic void pktgen_resched(struct pktgen_dev *pkt_dev)\r\n{\r\nktime_t idle_start = ktime_get();\r\nschedule();\r\npkt_dev->idle_acc += ktime_to_ns(ktime_sub(ktime_get(), idle_start));\r\n}\r\nstatic void pktgen_wait_for_skb(struct pktgen_dev *pkt_dev)\r\n{\r\nktime_t idle_start = ktime_get();\r\nwhile (atomic_read(&(pkt_dev->skb->users)) != 1) {\r\nif (signal_pending(current))\r\nbreak;\r\nif (need_resched())\r\npktgen_resched(pkt_dev);\r\nelse\r\ncpu_relax();\r\n}\r\npkt_dev->idle_acc += ktime_to_ns(ktime_sub(ktime_get(), idle_start));\r\n}\r\nstatic void pktgen_xmit(struct pktgen_dev *pkt_dev)\r\n{\r\nunsigned int burst = ACCESS_ONCE(pkt_dev->burst);\r\nstruct net_device *odev = pkt_dev->odev;\r\nstruct netdev_queue *txq;\r\nstruct sk_buff *skb;\r\nint ret;\r\nif (unlikely(!netif_running(odev) || !netif_carrier_ok(odev))) {\r\npktgen_stop_device(pkt_dev);\r\nreturn;\r\n}\r\nif (unlikely(pkt_dev->delay == ULLONG_MAX)) {\r\npkt_dev->next_tx = ktime_add_ns(ktime_get(), ULONG_MAX);\r\nreturn;\r\n}\r\nif (!pkt_dev->skb || (pkt_dev->last_ok &&\r\n++pkt_dev->clone_count >= pkt_dev->clone_skb)) {\r\nkfree_skb(pkt_dev->skb);\r\npkt_dev->skb = fill_packet(odev, pkt_dev);\r\nif (pkt_dev->skb == NULL) {\r\npr_err("ERROR: couldn't allocate skb in fill_packet\n");\r\nschedule();\r\npkt_dev->clone_count--;\r\nreturn;\r\n}\r\npkt_dev->last_pkt_size = pkt_dev->skb->len;\r\npkt_dev->clone_count = 0;\r\n}\r\nif (pkt_dev->delay && pkt_dev->last_ok)\r\nspin(pkt_dev, pkt_dev->next_tx);\r\nif (pkt_dev->xmit_mode == M_NETIF_RECEIVE) {\r\nskb = pkt_dev->skb;\r\nskb->protocol = eth_type_trans(skb, skb->dev);\r\natomic_add(burst, &skb->users);\r\nlocal_bh_disable();\r\ndo {\r\nret = netif_receive_skb(skb);\r\nif (ret == NET_RX_DROP)\r\npkt_dev->errors++;\r\npkt_dev->sofar++;\r\npkt_dev->seq_num++;\r\nif (atomic_read(&skb->users) != burst) {\r\natomic_sub(burst - 1, &skb->users);\r\nbreak;\r\n}\r\nskb_reset_tc(skb);\r\n} while (--burst > 0);\r\ngoto out;\r\n} else if (pkt_dev->xmit_mode == M_QUEUE_XMIT) {\r\nlocal_bh_disable();\r\natomic_inc(&pkt_dev->skb->users);\r\nret = dev_queue_xmit(pkt_dev->skb);\r\nswitch (ret) {\r\ncase NET_XMIT_SUCCESS:\r\npkt_dev->sofar++;\r\npkt_dev->seq_num++;\r\npkt_dev->tx_bytes += pkt_dev->last_pkt_size;\r\nbreak;\r\ncase NET_XMIT_DROP:\r\ncase NET_XMIT_CN:\r\ncase NETDEV_TX_BUSY:\r\ndefault:\r\npkt_dev->errors++;\r\nnet_info_ratelimited("%s xmit error: %d\n",\r\npkt_dev->odevname, ret);\r\nbreak;\r\n}\r\ngoto out;\r\n}\r\ntxq = skb_get_tx_queue(odev, pkt_dev->skb);\r\nlocal_bh_disable();\r\nHARD_TX_LOCK(odev, txq, smp_processor_id());\r\nif (unlikely(netif_xmit_frozen_or_drv_stopped(txq))) {\r\nret = NETDEV_TX_BUSY;\r\npkt_dev->last_ok = 0;\r\ngoto unlock;\r\n}\r\natomic_add(burst, &pkt_dev->skb->users);\r\nxmit_more:\r\nret = netdev_start_xmit(pkt_dev->skb, odev, txq, --burst > 0);\r\nswitch (ret) {\r\ncase NETDEV_TX_OK:\r\npkt_dev->last_ok = 1;\r\npkt_dev->sofar++;\r\npkt_dev->seq_num++;\r\npkt_dev->tx_bytes += pkt_dev->last_pkt_size;\r\nif (burst > 0 && !netif_xmit_frozen_or_drv_stopped(txq))\r\ngoto xmit_more;\r\nbreak;\r\ncase NET_XMIT_DROP:\r\ncase NET_XMIT_CN:\r\npkt_dev->errors++;\r\nbreak;\r\ndefault:\r\nnet_info_ratelimited("%s xmit error: %d\n",\r\npkt_dev->odevname, ret);\r\npkt_dev->errors++;\r\ncase NETDEV_TX_BUSY:\r\natomic_dec(&(pkt_dev->skb->users));\r\npkt_dev->last_ok = 0;\r\n}\r\nif (unlikely(burst))\r\natomic_sub(burst, &pkt_dev->skb->users);\r\nunlock:\r\nHARD_TX_UNLOCK(odev, txq);\r\nout:\r\nlocal_bh_enable();\r\nif ((pkt_dev->count != 0) && (pkt_dev->sofar >= pkt_dev->count)) {\r\npktgen_wait_for_skb(pkt_dev);\r\npktgen_stop_device(pkt_dev);\r\n}\r\n}\r\nstatic int pktgen_thread_worker(void *arg)\r\n{\r\nDEFINE_WAIT(wait);\r\nstruct pktgen_thread *t = arg;\r\nstruct pktgen_dev *pkt_dev = NULL;\r\nint cpu = t->cpu;\r\nBUG_ON(smp_processor_id() != cpu);\r\ninit_waitqueue_head(&t->queue);\r\ncomplete(&t->start_done);\r\npr_debug("starting pktgen/%d: pid=%d\n", cpu, task_pid_nr(current));\r\nset_freezable();\r\nwhile (!kthread_should_stop()) {\r\npkt_dev = next_to_run(t);\r\nif (unlikely(!pkt_dev && t->control == 0)) {\r\nif (t->net->pktgen_exiting)\r\nbreak;\r\nwait_event_interruptible_timeout(t->queue,\r\nt->control != 0,\r\nHZ/10);\r\ntry_to_freeze();\r\ncontinue;\r\n}\r\nif (likely(pkt_dev)) {\r\npktgen_xmit(pkt_dev);\r\nif (need_resched())\r\npktgen_resched(pkt_dev);\r\nelse\r\ncpu_relax();\r\n}\r\nif (t->control & T_STOP) {\r\npktgen_stop(t);\r\nt->control &= ~(T_STOP);\r\n}\r\nif (t->control & T_RUN) {\r\npktgen_run(t);\r\nt->control &= ~(T_RUN);\r\n}\r\nif (t->control & T_REMDEVALL) {\r\npktgen_rem_all_ifs(t);\r\nt->control &= ~(T_REMDEVALL);\r\n}\r\nif (t->control & T_REMDEV) {\r\npktgen_rem_one_if(t);\r\nt->control &= ~(T_REMDEV);\r\n}\r\ntry_to_freeze();\r\n}\r\npr_debug("%s stopping all device\n", t->tsk->comm);\r\npktgen_stop(t);\r\npr_debug("%s removing all device\n", t->tsk->comm);\r\npktgen_rem_all_ifs(t);\r\npr_debug("%s removing thread\n", t->tsk->comm);\r\npktgen_rem_thread(t);\r\nreturn 0;\r\n}\r\nstatic struct pktgen_dev *pktgen_find_dev(struct pktgen_thread *t,\r\nconst char *ifname, bool exact)\r\n{\r\nstruct pktgen_dev *p, *pkt_dev = NULL;\r\nsize_t len = strlen(ifname);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(p, &t->if_list, list)\r\nif (strncmp(p->odevname, ifname, len) == 0) {\r\nif (p->odevname[len]) {\r\nif (exact || p->odevname[len] != '@')\r\ncontinue;\r\n}\r\npkt_dev = p;\r\nbreak;\r\n}\r\nrcu_read_unlock();\r\npr_debug("find_dev(%s) returning %p\n", ifname, pkt_dev);\r\nreturn pkt_dev;\r\n}\r\nstatic int add_dev_to_thread(struct pktgen_thread *t,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\nint rv = 0;\r\nif_lock(t);\r\nif (pkt_dev->pg_thread) {\r\npr_err("ERROR: already assigned to a thread\n");\r\nrv = -EBUSY;\r\ngoto out;\r\n}\r\npkt_dev->running = 0;\r\npkt_dev->pg_thread = t;\r\nlist_add_rcu(&pkt_dev->list, &t->if_list);\r\nout:\r\nif_unlock(t);\r\nreturn rv;\r\n}\r\nstatic int pktgen_add_device(struct pktgen_thread *t, const char *ifname)\r\n{\r\nstruct pktgen_dev *pkt_dev;\r\nint err;\r\nint node = cpu_to_node(t->cpu);\r\npkt_dev = __pktgen_NN_threads(t->net, ifname, FIND);\r\nif (pkt_dev) {\r\npr_err("ERROR: interface already used\n");\r\nreturn -EBUSY;\r\n}\r\npkt_dev = kzalloc_node(sizeof(struct pktgen_dev), GFP_KERNEL, node);\r\nif (!pkt_dev)\r\nreturn -ENOMEM;\r\nstrcpy(pkt_dev->odevname, ifname);\r\npkt_dev->flows = vzalloc_node(MAX_CFLOWS * sizeof(struct flow_state),\r\nnode);\r\nif (pkt_dev->flows == NULL) {\r\nkfree(pkt_dev);\r\nreturn -ENOMEM;\r\n}\r\npkt_dev->removal_mark = 0;\r\npkt_dev->nfrags = 0;\r\npkt_dev->delay = pg_delay_d;\r\npkt_dev->count = pg_count_d;\r\npkt_dev->sofar = 0;\r\npkt_dev->udp_src_min = 9;\r\npkt_dev->udp_src_max = 9;\r\npkt_dev->udp_dst_min = 9;\r\npkt_dev->udp_dst_max = 9;\r\npkt_dev->vlan_p = 0;\r\npkt_dev->vlan_cfi = 0;\r\npkt_dev->vlan_id = 0xffff;\r\npkt_dev->svlan_p = 0;\r\npkt_dev->svlan_cfi = 0;\r\npkt_dev->svlan_id = 0xffff;\r\npkt_dev->burst = 1;\r\npkt_dev->node = -1;\r\nerr = pktgen_setup_dev(t->net, pkt_dev, ifname);\r\nif (err)\r\ngoto out1;\r\nif (pkt_dev->odev->priv_flags & IFF_TX_SKB_SHARING)\r\npkt_dev->clone_skb = pg_clone_skb_d;\r\npkt_dev->entry = proc_create_data(ifname, 0600, t->net->proc_dir,\r\n&pktgen_if_fops, pkt_dev);\r\nif (!pkt_dev->entry) {\r\npr_err("cannot create %s/%s procfs entry\n",\r\nPG_PROC_DIR, ifname);\r\nerr = -EINVAL;\r\ngoto out2;\r\n}\r\n#ifdef CONFIG_XFRM\r\npkt_dev->ipsmode = XFRM_MODE_TRANSPORT;\r\npkt_dev->ipsproto = IPPROTO_ESP;\r\npkt_dev->dstops.family = AF_INET;\r\npkt_dev->dst.dev = pkt_dev->odev;\r\ndst_init_metrics(&pkt_dev->dst, pktgen_dst_metrics, false);\r\npkt_dev->dst.child = &pkt_dev->dst;\r\npkt_dev->dst.ops = &pkt_dev->dstops;\r\n#endif\r\nreturn add_dev_to_thread(t, pkt_dev);\r\nout2:\r\ndev_put(pkt_dev->odev);\r\nout1:\r\n#ifdef CONFIG_XFRM\r\nfree_SAs(pkt_dev);\r\n#endif\r\nvfree(pkt_dev->flows);\r\nkfree(pkt_dev);\r\nreturn err;\r\n}\r\nstatic int __net_init pktgen_create_thread(int cpu, struct pktgen_net *pn)\r\n{\r\nstruct pktgen_thread *t;\r\nstruct proc_dir_entry *pe;\r\nstruct task_struct *p;\r\nt = kzalloc_node(sizeof(struct pktgen_thread), GFP_KERNEL,\r\ncpu_to_node(cpu));\r\nif (!t) {\r\npr_err("ERROR: out of memory, can't create new thread\n");\r\nreturn -ENOMEM;\r\n}\r\nmutex_init(&t->if_lock);\r\nt->cpu = cpu;\r\nINIT_LIST_HEAD(&t->if_list);\r\nlist_add_tail(&t->th_list, &pn->pktgen_threads);\r\ninit_completion(&t->start_done);\r\np = kthread_create_on_node(pktgen_thread_worker,\r\nt,\r\ncpu_to_node(cpu),\r\n"kpktgend_%d", cpu);\r\nif (IS_ERR(p)) {\r\npr_err("kernel_thread() failed for cpu %d\n", t->cpu);\r\nlist_del(&t->th_list);\r\nkfree(t);\r\nreturn PTR_ERR(p);\r\n}\r\nkthread_bind(p, cpu);\r\nt->tsk = p;\r\npe = proc_create_data(t->tsk->comm, 0600, pn->proc_dir,\r\n&pktgen_thread_fops, t);\r\nif (!pe) {\r\npr_err("cannot create %s/%s procfs entry\n",\r\nPG_PROC_DIR, t->tsk->comm);\r\nkthread_stop(p);\r\nlist_del(&t->th_list);\r\nkfree(t);\r\nreturn -EINVAL;\r\n}\r\nt->net = pn;\r\nget_task_struct(p);\r\nwake_up_process(p);\r\nwait_for_completion(&t->start_done);\r\nreturn 0;\r\n}\r\nstatic void _rem_dev_from_if_list(struct pktgen_thread *t,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\nstruct list_head *q, *n;\r\nstruct pktgen_dev *p;\r\nif_lock(t);\r\nlist_for_each_safe(q, n, &t->if_list) {\r\np = list_entry(q, struct pktgen_dev, list);\r\nif (p == pkt_dev)\r\nlist_del_rcu(&p->list);\r\n}\r\nif_unlock(t);\r\n}\r\nstatic int pktgen_remove_device(struct pktgen_thread *t,\r\nstruct pktgen_dev *pkt_dev)\r\n{\r\npr_debug("remove_device pkt_dev=%p\n", pkt_dev);\r\nif (pkt_dev->running) {\r\npr_warn("WARNING: trying to remove a running interface, stopping it now\n");\r\npktgen_stop_device(pkt_dev);\r\n}\r\nif (pkt_dev->odev) {\r\ndev_put(pkt_dev->odev);\r\npkt_dev->odev = NULL;\r\n}\r\nproc_remove(pkt_dev->entry);\r\n_rem_dev_from_if_list(t, pkt_dev);\r\n#ifdef CONFIG_XFRM\r\nfree_SAs(pkt_dev);\r\n#endif\r\nvfree(pkt_dev->flows);\r\nif (pkt_dev->page)\r\nput_page(pkt_dev->page);\r\nkfree_rcu(pkt_dev, rcu);\r\nreturn 0;\r\n}\r\nstatic int __net_init pg_net_init(struct net *net)\r\n{\r\nstruct pktgen_net *pn = net_generic(net, pg_net_id);\r\nstruct proc_dir_entry *pe;\r\nint cpu, ret = 0;\r\npn->net = net;\r\nINIT_LIST_HEAD(&pn->pktgen_threads);\r\npn->pktgen_exiting = false;\r\npn->proc_dir = proc_mkdir(PG_PROC_DIR, pn->net->proc_net);\r\nif (!pn->proc_dir) {\r\npr_warn("cannot create /proc/net/%s\n", PG_PROC_DIR);\r\nreturn -ENODEV;\r\n}\r\npe = proc_create(PGCTRL, 0600, pn->proc_dir, &pktgen_fops);\r\nif (pe == NULL) {\r\npr_err("cannot create %s procfs entry\n", PGCTRL);\r\nret = -EINVAL;\r\ngoto remove;\r\n}\r\nfor_each_online_cpu(cpu) {\r\nint err;\r\nerr = pktgen_create_thread(cpu, pn);\r\nif (err)\r\npr_warn("Cannot create thread for cpu %d (%d)\n",\r\ncpu, err);\r\n}\r\nif (list_empty(&pn->pktgen_threads)) {\r\npr_err("Initialization failed for all threads\n");\r\nret = -ENODEV;\r\ngoto remove_entry;\r\n}\r\nreturn 0;\r\nremove_entry:\r\nremove_proc_entry(PGCTRL, pn->proc_dir);\r\nremove:\r\nremove_proc_entry(PG_PROC_DIR, pn->net->proc_net);\r\nreturn ret;\r\n}\r\nstatic void __net_exit pg_net_exit(struct net *net)\r\n{\r\nstruct pktgen_net *pn = net_generic(net, pg_net_id);\r\nstruct pktgen_thread *t;\r\nstruct list_head *q, *n;\r\nLIST_HEAD(list);\r\npn->pktgen_exiting = true;\r\nmutex_lock(&pktgen_thread_lock);\r\nlist_splice_init(&pn->pktgen_threads, &list);\r\nmutex_unlock(&pktgen_thread_lock);\r\nlist_for_each_safe(q, n, &list) {\r\nt = list_entry(q, struct pktgen_thread, th_list);\r\nlist_del(&t->th_list);\r\nkthread_stop(t->tsk);\r\nput_task_struct(t->tsk);\r\nkfree(t);\r\n}\r\nremove_proc_entry(PGCTRL, pn->proc_dir);\r\nremove_proc_entry(PG_PROC_DIR, pn->net->proc_net);\r\n}\r\nstatic int __init pg_init(void)\r\n{\r\nint ret = 0;\r\npr_info("%s", version);\r\nret = register_pernet_subsys(&pg_net_ops);\r\nif (ret)\r\nreturn ret;\r\nret = register_netdevice_notifier(&pktgen_notifier_block);\r\nif (ret)\r\nunregister_pernet_subsys(&pg_net_ops);\r\nreturn ret;\r\n}\r\nstatic void __exit pg_cleanup(void)\r\n{\r\nunregister_netdevice_notifier(&pktgen_notifier_block);\r\nunregister_pernet_subsys(&pg_net_ops);\r\n}
