static int ncp_file_mmap_fault(struct vm_fault *vmf)\r\n{\r\nstruct inode *inode = file_inode(vmf->vma->vm_file);\r\nchar *pg_addr;\r\nunsigned int already_read;\r\nunsigned int count;\r\nint bufsize;\r\nint pos;\r\nvmf->page = alloc_page(GFP_HIGHUSER);\r\nif (!vmf->page)\r\nreturn VM_FAULT_OOM;\r\npg_addr = kmap(vmf->page);\r\npos = vmf->pgoff << PAGE_SHIFT;\r\ncount = PAGE_SIZE;\r\nbufsize = NCP_SERVER(inode)->buffer_size;\r\nalready_read = 0;\r\nif (ncp_make_open(inode, O_RDONLY) >= 0) {\r\nwhile (already_read < count) {\r\nint read_this_time;\r\nint to_read;\r\nto_read = bufsize - (pos % bufsize);\r\nto_read = min_t(unsigned int, to_read, count - already_read);\r\nif (ncp_read_kernel(NCP_SERVER(inode),\r\nNCP_FINFO(inode)->file_handle,\r\npos, to_read,\r\npg_addr + already_read,\r\n&read_this_time) != 0) {\r\nread_this_time = 0;\r\n}\r\npos += read_this_time;\r\nalready_read += read_this_time;\r\nif (read_this_time < to_read) {\r\nbreak;\r\n}\r\n}\r\nncp_inode_close(inode);\r\n}\r\nif (already_read < PAGE_SIZE)\r\nmemset(pg_addr + already_read, 0, PAGE_SIZE - already_read);\r\nflush_dcache_page(vmf->page);\r\nkunmap(vmf->page);\r\ncount_vm_event(PGMAJFAULT);\r\nmem_cgroup_count_vm_event(vmf->vma->vm_mm, PGMAJFAULT);\r\nreturn VM_FAULT_MAJOR;\r\n}\r\nint ncp_mmap(struct file *file, struct vm_area_struct *vma)\r\n{\r\nstruct inode *inode = file_inode(file);\r\nncp_dbg(1, "called\n");\r\nif (!ncp_conn_valid(NCP_SERVER(inode)))\r\nreturn -EIO;\r\nif (vma->vm_flags & VM_SHARED)\r\nreturn -EINVAL;\r\nif (vma_pages(vma) + vma->vm_pgoff\r\n> (1U << (32 - PAGE_SHIFT)))\r\nreturn -EFBIG;\r\nvma->vm_ops = &ncp_file_mmap;\r\nfile_accessed(file);\r\nreturn 0;\r\n}
