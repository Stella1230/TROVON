static struct i40iw_puda_buf *i40iw_puda_get_listbuf(struct list_head *list)\r\n{\r\nstruct i40iw_puda_buf *buf = NULL;\r\nif (!list_empty(list)) {\r\nbuf = (struct i40iw_puda_buf *)list->next;\r\nlist_del((struct list_head *)&buf->list);\r\n}\r\nreturn buf;\r\n}\r\nstruct i40iw_puda_buf *i40iw_puda_get_bufpool(struct i40iw_puda_rsrc *rsrc)\r\n{\r\nstruct i40iw_puda_buf *buf = NULL;\r\nstruct list_head *list = &rsrc->bufpool;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rsrc->bufpool_lock, flags);\r\nbuf = i40iw_puda_get_listbuf(list);\r\nif (buf)\r\nrsrc->avail_buf_count--;\r\nelse\r\nrsrc->stats_buf_alloc_fail++;\r\nspin_unlock_irqrestore(&rsrc->bufpool_lock, flags);\r\nreturn buf;\r\n}\r\nvoid i40iw_puda_ret_bufpool(struct i40iw_puda_rsrc *rsrc,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&rsrc->bufpool_lock, flags);\r\nlist_add(&buf->list, &rsrc->bufpool);\r\nspin_unlock_irqrestore(&rsrc->bufpool_lock, flags);\r\nrsrc->avail_buf_count++;\r\n}\r\nstatic void i40iw_puda_post_recvbuf(struct i40iw_puda_rsrc *rsrc, u32 wqe_idx,\r\nstruct i40iw_puda_buf *buf, bool initial)\r\n{\r\nu64 *wqe;\r\nstruct i40iw_sc_qp *qp = &rsrc->qp;\r\nu64 offset24 = 0;\r\nqp->qp_uk.rq_wrid_array[wqe_idx] = (uintptr_t)buf;\r\nwqe = qp->qp_uk.rq_base[wqe_idx].elem;\r\ni40iw_debug(rsrc->dev, I40IW_DEBUG_PUDA,\r\n"%s: wqe_idx= %d buf = %p wqe = %p\n", __func__,\r\nwqe_idx, buf, wqe);\r\nif (!initial)\r\nget_64bit_val(wqe, 24, &offset24);\r\noffset24 = (offset24) ? 0 : LS_64(1, I40IWQPSQ_VALID);\r\nset_64bit_val(wqe, 24, offset24);\r\nset_64bit_val(wqe, 0, buf->mem.pa);\r\nset_64bit_val(wqe, 8,\r\nLS_64(buf->mem.size, I40IWQPSQ_FRAG_LEN));\r\nset_64bit_val(wqe, 24, offset24);\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_replenish_rq(struct i40iw_puda_rsrc *rsrc,\r\nbool initial)\r\n{\r\nu32 i;\r\nu32 invalid_cnt = rsrc->rxq_invalid_cnt;\r\nstruct i40iw_puda_buf *buf = NULL;\r\nfor (i = 0; i < invalid_cnt; i++) {\r\nbuf = i40iw_puda_get_bufpool(rsrc);\r\nif (!buf)\r\nreturn I40IW_ERR_list_empty;\r\ni40iw_puda_post_recvbuf(rsrc, rsrc->rx_wqe_idx, buf,\r\ninitial);\r\nrsrc->rx_wqe_idx =\r\n((rsrc->rx_wqe_idx + 1) % rsrc->rq_size);\r\nrsrc->rxq_invalid_cnt--;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct i40iw_puda_buf *i40iw_puda_alloc_buf(struct i40iw_sc_dev *dev,\r\nu32 length)\r\n{\r\nstruct i40iw_puda_buf *buf = NULL;\r\nstruct i40iw_virt_mem buf_mem;\r\nenum i40iw_status_code ret;\r\nret = i40iw_allocate_virt_mem(dev->hw, &buf_mem,\r\nsizeof(struct i40iw_puda_buf));\r\nif (ret) {\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA,\r\n"%s: error mem for buf\n", __func__);\r\nreturn NULL;\r\n}\r\nbuf = (struct i40iw_puda_buf *)buf_mem.va;\r\nret = i40iw_allocate_dma_mem(dev->hw, &buf->mem, length, 1);\r\nif (ret) {\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA,\r\n"%s: error dma mem for buf\n", __func__);\r\ni40iw_free_virt_mem(dev->hw, &buf_mem);\r\nreturn NULL;\r\n}\r\nbuf->buf_mem.va = buf_mem.va;\r\nbuf->buf_mem.size = buf_mem.size;\r\nreturn buf;\r\n}\r\nstatic void i40iw_puda_dele_buf(struct i40iw_sc_dev *dev,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\ni40iw_free_dma_mem(dev->hw, &buf->mem);\r\ni40iw_free_virt_mem(dev->hw, &buf->buf_mem);\r\n}\r\nstatic u64 *i40iw_puda_get_next_send_wqe(struct i40iw_qp_uk *qp, u32 *wqe_idx)\r\n{\r\nu64 *wqe = NULL;\r\nenum i40iw_status_code ret_code = 0;\r\n*wqe_idx = I40IW_RING_GETCURRENT_HEAD(qp->sq_ring);\r\nif (!*wqe_idx)\r\nqp->swqe_polarity = !qp->swqe_polarity;\r\nI40IW_RING_MOVE_HEAD(qp->sq_ring, ret_code);\r\nif (ret_code)\r\nreturn wqe;\r\nwqe = qp->sq_base[*wqe_idx].elem;\r\nreturn wqe;\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_poll_info(struct i40iw_sc_cq *cq,\r\nstruct i40iw_puda_completion_info *info)\r\n{\r\nu64 qword0, qword2, qword3;\r\nu64 *cqe;\r\nu64 comp_ctx;\r\nbool valid_bit;\r\nu32 major_err, minor_err;\r\nbool error;\r\ncqe = (u64 *)I40IW_GET_CURRENT_CQ_ELEMENT(&cq->cq_uk);\r\nget_64bit_val(cqe, 24, &qword3);\r\nvalid_bit = (bool)RS_64(qword3, I40IW_CQ_VALID);\r\nif (valid_bit != cq->cq_uk.polarity)\r\nreturn I40IW_ERR_QUEUE_EMPTY;\r\ni40iw_debug_buf(cq->dev, I40IW_DEBUG_PUDA, "PUDA CQE", cqe, 32);\r\nerror = (bool)RS_64(qword3, I40IW_CQ_ERROR);\r\nif (error) {\r\ni40iw_debug(cq->dev, I40IW_DEBUG_PUDA, "%s receive error\n", __func__);\r\nmajor_err = (u32)(RS_64(qword3, I40IW_CQ_MAJERR));\r\nminor_err = (u32)(RS_64(qword3, I40IW_CQ_MINERR));\r\ninfo->compl_error = major_err << 16 | minor_err;\r\nreturn I40IW_ERR_CQ_COMPL_ERROR;\r\n}\r\nget_64bit_val(cqe, 0, &qword0);\r\nget_64bit_val(cqe, 16, &qword2);\r\ninfo->q_type = (u8)RS_64(qword3, I40IW_CQ_SQ);\r\ninfo->qp_id = (u32)RS_64(qword2, I40IWCQ_QPID);\r\nget_64bit_val(cqe, 8, &comp_ctx);\r\ninfo->qp = (struct i40iw_qp_uk *)(unsigned long)comp_ctx;\r\ninfo->wqe_idx = (u32)RS_64(qword3, I40IW_CQ_WQEIDX);\r\nif (info->q_type == I40IW_CQE_QTYPE_RQ) {\r\ninfo->vlan_valid = (bool)RS_64(qword3, I40IW_VLAN_TAG_VALID);\r\ninfo->l4proto = (u8)RS_64(qword2, I40IW_UDA_L4PROTO);\r\ninfo->l3proto = (u8)RS_64(qword2, I40IW_UDA_L3PROTO);\r\ninfo->payload_len = (u16)RS_64(qword0, I40IW_UDA_PAYLOADLEN);\r\n}\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_puda_poll_completion(struct i40iw_sc_dev *dev,\r\nstruct i40iw_sc_cq *cq, u32 *compl_err)\r\n{\r\nstruct i40iw_qp_uk *qp;\r\nstruct i40iw_cq_uk *cq_uk = &cq->cq_uk;\r\nstruct i40iw_puda_completion_info info;\r\nenum i40iw_status_code ret = 0;\r\nstruct i40iw_puda_buf *buf;\r\nstruct i40iw_puda_rsrc *rsrc;\r\nvoid *sqwrid;\r\nu8 cq_type = cq->cq_type;\r\nunsigned long flags;\r\nif ((cq_type == I40IW_CQ_TYPE_ILQ) || (cq_type == I40IW_CQ_TYPE_IEQ)) {\r\nrsrc = (cq_type == I40IW_CQ_TYPE_ILQ) ? cq->vsi->ilq : cq->vsi->ieq;\r\n} else {\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA, "%s qp_type error\n", __func__);\r\nreturn I40IW_ERR_BAD_PTR;\r\n}\r\nmemset(&info, 0, sizeof(info));\r\nret = i40iw_puda_poll_info(cq, &info);\r\n*compl_err = info.compl_error;\r\nif (ret == I40IW_ERR_QUEUE_EMPTY)\r\nreturn ret;\r\nif (ret)\r\ngoto done;\r\nqp = info.qp;\r\nif (!qp || !rsrc) {\r\nret = I40IW_ERR_BAD_PTR;\r\ngoto done;\r\n}\r\nif (qp->qp_id != rsrc->qp_id) {\r\nret = I40IW_ERR_BAD_PTR;\r\ngoto done;\r\n}\r\nif (info.q_type == I40IW_CQE_QTYPE_RQ) {\r\nbuf = (struct i40iw_puda_buf *)(uintptr_t)qp->rq_wrid_array[info.wqe_idx];\r\nret = i40iw_puda_get_tcpip_info(&info, buf);\r\nif (ret) {\r\nrsrc->stats_rcvd_pkt_err++;\r\nif (cq_type == I40IW_CQ_TYPE_ILQ) {\r\ni40iw_ilq_putback_rcvbuf(&rsrc->qp,\r\ninfo.wqe_idx);\r\n} else {\r\ni40iw_puda_ret_bufpool(rsrc, buf);\r\ni40iw_puda_replenish_rq(rsrc, false);\r\n}\r\ngoto done;\r\n}\r\nrsrc->stats_pkt_rcvd++;\r\nrsrc->compl_rxwqe_idx = info.wqe_idx;\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA, "%s RQ completion\n", __func__);\r\nrsrc->receive(rsrc->vsi, buf);\r\nif (cq_type == I40IW_CQ_TYPE_ILQ)\r\ni40iw_ilq_putback_rcvbuf(&rsrc->qp, info.wqe_idx);\r\nelse\r\ni40iw_puda_replenish_rq(rsrc, false);\r\n} else {\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA, "%s SQ completion\n", __func__);\r\nsqwrid = (void *)(uintptr_t)qp->sq_wrtrk_array[info.wqe_idx].wrid;\r\nI40IW_RING_SET_TAIL(qp->sq_ring, info.wqe_idx);\r\nrsrc->xmit_complete(rsrc->vsi, sqwrid);\r\nspin_lock_irqsave(&rsrc->bufpool_lock, flags);\r\nrsrc->tx_wqe_avail_cnt++;\r\nspin_unlock_irqrestore(&rsrc->bufpool_lock, flags);\r\nif (!list_empty(&rsrc->vsi->ilq->txpend))\r\ni40iw_puda_send_buf(rsrc->vsi->ilq, NULL);\r\n}\r\ndone:\r\nI40IW_RING_MOVE_HEAD(cq_uk->cq_ring, ret);\r\nif (I40IW_RING_GETCURRENT_HEAD(cq_uk->cq_ring) == 0)\r\ncq_uk->polarity = !cq_uk->polarity;\r\nI40IW_RING_MOVE_TAIL(cq_uk->cq_ring);\r\nset_64bit_val(cq_uk->shadow_area, 0,\r\nI40IW_RING_GETCURRENT_HEAD(cq_uk->cq_ring));\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_puda_send(struct i40iw_sc_qp *qp,\r\nstruct i40iw_puda_send_info *info)\r\n{\r\nu64 *wqe;\r\nu32 iplen, l4len;\r\nu64 header[2];\r\nu32 wqe_idx;\r\nu8 iipt;\r\nl4len = info->tcplen >> 2;\r\nif (info->ipv4) {\r\niipt = 3;\r\niplen = 5;\r\n} else {\r\niipt = 1;\r\niplen = 10;\r\n}\r\nwqe = i40iw_puda_get_next_send_wqe(&qp->qp_uk, &wqe_idx);\r\nif (!wqe)\r\nreturn I40IW_ERR_QP_TOOMANY_WRS_POSTED;\r\nqp->qp_uk.sq_wrtrk_array[wqe_idx].wrid = (uintptr_t)info->scratch;\r\nheader[0] = LS_64((info->maclen >> 1), I40IW_UDA_QPSQ_MACLEN) |\r\nLS_64(iplen, I40IW_UDA_QPSQ_IPLEN) | LS_64(1, I40IW_UDA_QPSQ_L4T) |\r\nLS_64(iipt, I40IW_UDA_QPSQ_IIPT) |\r\nLS_64(l4len, I40IW_UDA_QPSQ_L4LEN);\r\nheader[1] = LS_64(I40IW_OP_TYPE_SEND, I40IW_UDA_QPSQ_OPCODE) |\r\nLS_64(1, I40IW_UDA_QPSQ_SIGCOMPL) |\r\nLS_64(info->doloopback, I40IW_UDA_QPSQ_DOLOOPBACK) |\r\nLS_64(qp->qp_uk.swqe_polarity, I40IW_UDA_QPSQ_VALID);\r\nset_64bit_val(wqe, 0, info->paddr);\r\nset_64bit_val(wqe, 8, LS_64(info->len, I40IWQPSQ_FRAG_LEN));\r\nset_64bit_val(wqe, 16, header[0]);\r\nset_64bit_val(wqe, 24, header[1]);\r\ni40iw_debug_buf(qp->dev, I40IW_DEBUG_PUDA, "PUDA SEND WQE", wqe, 32);\r\ni40iw_qp_post_wr(&qp->qp_uk);\r\nreturn 0;\r\n}\r\nvoid i40iw_puda_send_buf(struct i40iw_puda_rsrc *rsrc, struct i40iw_puda_buf *buf)\r\n{\r\nstruct i40iw_puda_send_info info;\r\nenum i40iw_status_code ret = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&rsrc->bufpool_lock, flags);\r\nif (!rsrc->tx_wqe_avail_cnt || (buf && !list_empty(&rsrc->txpend))) {\r\nlist_add_tail(&buf->list, &rsrc->txpend);\r\nspin_unlock_irqrestore(&rsrc->bufpool_lock, flags);\r\nrsrc->stats_sent_pkt_q++;\r\nif (rsrc->type == I40IW_PUDA_RSRC_TYPE_ILQ)\r\ni40iw_debug(rsrc->dev, I40IW_DEBUG_PUDA,\r\n"%s: adding to txpend\n", __func__);\r\nreturn;\r\n}\r\nrsrc->tx_wqe_avail_cnt--;\r\nif (!buf) {\r\nbuf = i40iw_puda_get_listbuf(&rsrc->txpend);\r\nif (!buf)\r\ngoto done;\r\n}\r\ninfo.scratch = (void *)buf;\r\ninfo.paddr = buf->mem.pa;\r\ninfo.len = buf->totallen;\r\ninfo.tcplen = buf->tcphlen;\r\ninfo.maclen = buf->maclen;\r\ninfo.ipv4 = buf->ipv4;\r\ninfo.doloopback = (rsrc->type == I40IW_PUDA_RSRC_TYPE_IEQ);\r\nret = i40iw_puda_send(&rsrc->qp, &info);\r\nif (ret) {\r\nrsrc->tx_wqe_avail_cnt++;\r\nrsrc->stats_sent_pkt_q++;\r\nlist_add(&buf->list, &rsrc->txpend);\r\nif (rsrc->type == I40IW_PUDA_RSRC_TYPE_ILQ)\r\ni40iw_debug(rsrc->dev, I40IW_DEBUG_PUDA,\r\n"%s: adding to puda_send\n", __func__);\r\n} else {\r\nrsrc->stats_pkt_sent++;\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&rsrc->bufpool_lock, flags);\r\n}\r\nstatic void i40iw_puda_qp_setctx(struct i40iw_puda_rsrc *rsrc)\r\n{\r\nstruct i40iw_sc_qp *qp = &rsrc->qp;\r\nu64 *qp_ctx = qp->hw_host_ctx;\r\nset_64bit_val(qp_ctx, 8, qp->sq_pa);\r\nset_64bit_val(qp_ctx, 16, qp->rq_pa);\r\nset_64bit_val(qp_ctx, 24,\r\nLS_64(qp->hw_rq_size, I40IWQPC_RQSIZE) |\r\nLS_64(qp->hw_sq_size, I40IWQPC_SQSIZE));\r\nset_64bit_val(qp_ctx, 48, LS_64(1514, I40IWQPC_SNDMSS));\r\nset_64bit_val(qp_ctx, 56, 0);\r\nset_64bit_val(qp_ctx, 64, 1);\r\nset_64bit_val(qp_ctx, 136,\r\nLS_64(rsrc->cq_id, I40IWQPC_TXCQNUM) |\r\nLS_64(rsrc->cq_id, I40IWQPC_RXCQNUM));\r\nset_64bit_val(qp_ctx, 160, LS_64(1, I40IWQPC_PRIVEN));\r\nset_64bit_val(qp_ctx, 168,\r\nLS_64((uintptr_t)qp, I40IWQPC_QPCOMPCTX));\r\nset_64bit_val(qp_ctx, 176,\r\nLS_64(qp->sq_tph_val, I40IWQPC_SQTPHVAL) |\r\nLS_64(qp->rq_tph_val, I40IWQPC_RQTPHVAL) |\r\nLS_64(qp->qs_handle, I40IWQPC_QSHANDLE));\r\ni40iw_debug_buf(rsrc->dev, I40IW_DEBUG_PUDA, "PUDA QP CONTEXT",\r\nqp_ctx, I40IW_QP_CTX_SIZE);\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_qp_wqe(struct i40iw_sc_dev *dev, struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_sc_cqp *cqp;\r\nu64 *wqe;\r\nu64 header;\r\nstruct i40iw_ccq_cqe_info compl_info;\r\nenum i40iw_status_code status = 0;\r\ncqp = dev->cqp;\r\nwqe = i40iw_sc_cqp_get_next_send_wqe(cqp, 0);\r\nif (!wqe)\r\nreturn I40IW_ERR_RING_FULL;\r\nset_64bit_val(wqe, 16, qp->hw_host_ctx_pa);\r\nset_64bit_val(wqe, 40, qp->shadow_area_pa);\r\nheader = qp->qp_uk.qp_id |\r\nLS_64(I40IW_CQP_OP_CREATE_QP, I40IW_CQPSQ_OPCODE) |\r\nLS_64(I40IW_QP_TYPE_UDA, I40IW_CQPSQ_QP_QPTYPE) |\r\nLS_64(1, I40IW_CQPSQ_QP_CQNUMVALID) |\r\nLS_64(2, I40IW_CQPSQ_QP_NEXTIWSTATE) |\r\nLS_64(cqp->polarity, I40IW_CQPSQ_WQEVALID);\r\nset_64bit_val(wqe, 24, header);\r\ni40iw_debug_buf(cqp->dev, I40IW_DEBUG_PUDA, "PUDA CQE", wqe, 32);\r\ni40iw_sc_cqp_post_sq(cqp);\r\nstatus = dev->cqp_ops->poll_for_cqp_op_done(dev->cqp,\r\nI40IW_CQP_OP_CREATE_QP,\r\n&compl_info);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_qp_create(struct i40iw_puda_rsrc *rsrc)\r\n{\r\nstruct i40iw_sc_qp *qp = &rsrc->qp;\r\nstruct i40iw_qp_uk *ukqp = &qp->qp_uk;\r\nenum i40iw_status_code ret = 0;\r\nu32 sq_size, rq_size, t_size;\r\nstruct i40iw_dma_mem *mem;\r\nsq_size = rsrc->sq_size * I40IW_QP_WQE_MIN_SIZE;\r\nrq_size = rsrc->rq_size * I40IW_QP_WQE_MIN_SIZE;\r\nt_size = (sq_size + rq_size + (I40IW_SHADOW_AREA_SIZE << 3) +\r\nI40IW_QP_CTX_SIZE);\r\nret =\r\ni40iw_allocate_dma_mem(rsrc->dev->hw, &rsrc->qpmem, t_size,\r\nI40IW_HW_PAGE_SIZE);\r\nif (ret) {\r\ni40iw_debug(rsrc->dev, I40IW_DEBUG_PUDA, "%s: error dma mem\n", __func__);\r\nreturn ret;\r\n}\r\nmem = &rsrc->qpmem;\r\nmemset(mem->va, 0, t_size);\r\nqp->hw_sq_size = i40iw_get_encoded_wqe_size(rsrc->sq_size, false);\r\nqp->hw_rq_size = i40iw_get_encoded_wqe_size(rsrc->rq_size, false);\r\nqp->pd = &rsrc->sc_pd;\r\nqp->qp_type = I40IW_QP_TYPE_UDA;\r\nqp->dev = rsrc->dev;\r\nqp->back_qp = (void *)rsrc;\r\nqp->sq_pa = mem->pa;\r\nqp->rq_pa = qp->sq_pa + sq_size;\r\nqp->vsi = rsrc->vsi;\r\nukqp->sq_base = mem->va;\r\nukqp->rq_base = &ukqp->sq_base[rsrc->sq_size];\r\nukqp->shadow_area = ukqp->rq_base[rsrc->rq_size].elem;\r\nqp->shadow_area_pa = qp->rq_pa + rq_size;\r\nqp->hw_host_ctx = ukqp->shadow_area + I40IW_SHADOW_AREA_SIZE;\r\nqp->hw_host_ctx_pa =\r\nqp->shadow_area_pa + (I40IW_SHADOW_AREA_SIZE << 3);\r\nukqp->qp_id = rsrc->qp_id;\r\nukqp->sq_wrtrk_array = rsrc->sq_wrtrk_array;\r\nukqp->rq_wrid_array = rsrc->rq_wrid_array;\r\nukqp->qp_id = rsrc->qp_id;\r\nukqp->sq_size = rsrc->sq_size;\r\nukqp->rq_size = rsrc->rq_size;\r\nI40IW_RING_INIT(ukqp->sq_ring, ukqp->sq_size);\r\nI40IW_RING_INIT(ukqp->initial_ring, ukqp->sq_size);\r\nI40IW_RING_INIT(ukqp->rq_ring, ukqp->rq_size);\r\nif (qp->pd->dev->is_pf)\r\nukqp->wqe_alloc_reg = (u32 __iomem *)(i40iw_get_hw_addr(qp->pd->dev) +\r\nI40E_PFPE_WQEALLOC);\r\nelse\r\nukqp->wqe_alloc_reg = (u32 __iomem *)(i40iw_get_hw_addr(qp->pd->dev) +\r\nI40E_VFPE_WQEALLOC1);\r\nqp->user_pri = 0;\r\ni40iw_qp_add_qos(qp);\r\ni40iw_puda_qp_setctx(rsrc);\r\nif (rsrc->ceq_valid)\r\nret = i40iw_cqp_qp_create_cmd(rsrc->dev, qp);\r\nelse\r\nret = i40iw_puda_qp_wqe(rsrc->dev, qp);\r\nif (ret)\r\ni40iw_free_dma_mem(rsrc->dev->hw, &rsrc->qpmem);\r\nreturn ret;\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_cq_wqe(struct i40iw_sc_dev *dev, struct i40iw_sc_cq *cq)\r\n{\r\nu64 *wqe;\r\nstruct i40iw_sc_cqp *cqp;\r\nu64 header;\r\nstruct i40iw_ccq_cqe_info compl_info;\r\nenum i40iw_status_code status = 0;\r\ncqp = dev->cqp;\r\nwqe = i40iw_sc_cqp_get_next_send_wqe(cqp, 0);\r\nif (!wqe)\r\nreturn I40IW_ERR_RING_FULL;\r\nset_64bit_val(wqe, 0, cq->cq_uk.cq_size);\r\nset_64bit_val(wqe, 8, RS_64_1(cq, 1));\r\nset_64bit_val(wqe, 16,\r\nLS_64(cq->shadow_read_threshold,\r\nI40IW_CQPSQ_CQ_SHADOW_READ_THRESHOLD));\r\nset_64bit_val(wqe, 32, cq->cq_pa);\r\nset_64bit_val(wqe, 40, cq->shadow_area_pa);\r\nheader = cq->cq_uk.cq_id |\r\nLS_64(I40IW_CQP_OP_CREATE_CQ, I40IW_CQPSQ_OPCODE) |\r\nLS_64(1, I40IW_CQPSQ_CQ_CHKOVERFLOW) |\r\nLS_64(1, I40IW_CQPSQ_CQ_ENCEQEMASK) |\r\nLS_64(1, I40IW_CQPSQ_CQ_CEQIDVALID) |\r\nLS_64(cqp->polarity, I40IW_CQPSQ_WQEVALID);\r\nset_64bit_val(wqe, 24, header);\r\ni40iw_debug_buf(dev, I40IW_DEBUG_PUDA, "PUDA CQE",\r\nwqe, I40IW_CQP_WQE_SIZE * 8);\r\ni40iw_sc_cqp_post_sq(dev->cqp);\r\nstatus = dev->cqp_ops->poll_for_cqp_op_done(dev->cqp,\r\nI40IW_CQP_OP_CREATE_CQ,\r\n&compl_info);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_cq_create(struct i40iw_puda_rsrc *rsrc)\r\n{\r\nstruct i40iw_sc_dev *dev = rsrc->dev;\r\nstruct i40iw_sc_cq *cq = &rsrc->cq;\r\nenum i40iw_status_code ret = 0;\r\nu32 tsize, cqsize;\r\nstruct i40iw_dma_mem *mem;\r\nstruct i40iw_cq_init_info info;\r\nstruct i40iw_cq_uk_init_info *init_info = &info.cq_uk_init_info;\r\ncq->vsi = rsrc->vsi;\r\ncqsize = rsrc->cq_size * (sizeof(struct i40iw_cqe));\r\ntsize = cqsize + sizeof(struct i40iw_cq_shadow_area);\r\nret = i40iw_allocate_dma_mem(dev->hw, &rsrc->cqmem, tsize,\r\nI40IW_CQ0_ALIGNMENT_MASK);\r\nif (ret)\r\nreturn ret;\r\nmem = &rsrc->cqmem;\r\nmemset(&info, 0, sizeof(info));\r\ninfo.dev = dev;\r\ninfo.type = (rsrc->type == I40IW_PUDA_RSRC_TYPE_ILQ) ?\r\nI40IW_CQ_TYPE_ILQ : I40IW_CQ_TYPE_IEQ;\r\ninfo.shadow_read_threshold = rsrc->cq_size >> 2;\r\ninfo.ceq_id_valid = true;\r\ninfo.cq_base_pa = mem->pa;\r\ninfo.shadow_area_pa = mem->pa + cqsize;\r\ninit_info->cq_base = mem->va;\r\ninit_info->shadow_area = (u64 *)((u8 *)mem->va + cqsize);\r\ninit_info->cq_size = rsrc->cq_size;\r\ninit_info->cq_id = rsrc->cq_id;\r\ninfo.ceqe_mask = true;\r\ninfo.ceq_id_valid = true;\r\nret = dev->iw_priv_cq_ops->cq_init(cq, &info);\r\nif (ret)\r\ngoto error;\r\nif (rsrc->ceq_valid)\r\nret = i40iw_cqp_cq_create_cmd(dev, cq);\r\nelse\r\nret = i40iw_puda_cq_wqe(dev, cq);\r\nerror:\r\nif (ret)\r\ni40iw_free_dma_mem(dev->hw, &rsrc->cqmem);\r\nreturn ret;\r\n}\r\nstatic void i40iw_puda_free_qp(struct i40iw_puda_rsrc *rsrc)\r\n{\r\nenum i40iw_status_code ret;\r\nstruct i40iw_ccq_cqe_info compl_info;\r\nstruct i40iw_sc_dev *dev = rsrc->dev;\r\nif (rsrc->ceq_valid) {\r\ni40iw_cqp_qp_destroy_cmd(dev, &rsrc->qp);\r\nreturn;\r\n}\r\nret = dev->iw_priv_qp_ops->qp_destroy(&rsrc->qp,\r\n0, false, true, true);\r\nif (ret)\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA,\r\n"%s error puda qp destroy wqe\n",\r\n__func__);\r\nif (!ret) {\r\nret = dev->cqp_ops->poll_for_cqp_op_done(dev->cqp,\r\nI40IW_CQP_OP_DESTROY_QP,\r\n&compl_info);\r\nif (ret)\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA,\r\n"%s error puda qp destroy failed\n",\r\n__func__);\r\n}\r\n}\r\nstatic void i40iw_puda_free_cq(struct i40iw_puda_rsrc *rsrc)\r\n{\r\nenum i40iw_status_code ret;\r\nstruct i40iw_ccq_cqe_info compl_info;\r\nstruct i40iw_sc_dev *dev = rsrc->dev;\r\nif (rsrc->ceq_valid) {\r\ni40iw_cqp_cq_destroy_cmd(dev, &rsrc->cq);\r\nreturn;\r\n}\r\nret = dev->iw_priv_cq_ops->cq_destroy(&rsrc->cq, 0, true);\r\nif (ret)\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA,\r\n"%s error ieq cq destroy\n",\r\n__func__);\r\nif (!ret) {\r\nret = dev->cqp_ops->poll_for_cqp_op_done(dev->cqp,\r\nI40IW_CQP_OP_DESTROY_CQ,\r\n&compl_info);\r\nif (ret)\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA,\r\n"%s error ieq qp destroy done\n",\r\n__func__);\r\n}\r\n}\r\nvoid i40iw_puda_dele_resources(struct i40iw_sc_vsi *vsi,\r\nenum puda_resource_type type,\r\nbool reset)\r\n{\r\nstruct i40iw_sc_dev *dev = vsi->dev;\r\nstruct i40iw_puda_rsrc *rsrc;\r\nstruct i40iw_puda_buf *buf = NULL;\r\nstruct i40iw_puda_buf *nextbuf = NULL;\r\nstruct i40iw_virt_mem *vmem;\r\nswitch (type) {\r\ncase I40IW_PUDA_RSRC_TYPE_ILQ:\r\nrsrc = vsi->ilq;\r\nvmem = &vsi->ilq_mem;\r\nbreak;\r\ncase I40IW_PUDA_RSRC_TYPE_IEQ:\r\nrsrc = vsi->ieq;\r\nvmem = &vsi->ieq_mem;\r\nbreak;\r\ndefault:\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA, "%s: error resource type = 0x%x\n",\r\n__func__, type);\r\nreturn;\r\n}\r\nswitch (rsrc->completion) {\r\ncase PUDA_HASH_CRC_COMPLETE:\r\ni40iw_free_hash_desc(rsrc->hash_desc);\r\ncase PUDA_QP_CREATED:\r\nif (!reset)\r\ni40iw_puda_free_qp(rsrc);\r\ni40iw_free_dma_mem(dev->hw, &rsrc->qpmem);\r\ncase PUDA_CQ_CREATED:\r\nif (!reset)\r\ni40iw_puda_free_cq(rsrc);\r\ni40iw_free_dma_mem(dev->hw, &rsrc->cqmem);\r\nbreak;\r\ndefault:\r\ni40iw_debug(rsrc->dev, I40IW_DEBUG_PUDA, "%s error no resources\n", __func__);\r\nbreak;\r\n}\r\nbuf = rsrc->alloclist;\r\nwhile (buf) {\r\nnextbuf = buf->next;\r\ni40iw_puda_dele_buf(dev, buf);\r\nbuf = nextbuf;\r\nrsrc->alloc_buf_count--;\r\n}\r\ni40iw_free_virt_mem(dev->hw, vmem);\r\n}\r\nstatic enum i40iw_status_code i40iw_puda_allocbufs(struct i40iw_puda_rsrc *rsrc,\r\nu32 count)\r\n{\r\nu32 i;\r\nstruct i40iw_puda_buf *buf;\r\nstruct i40iw_puda_buf *nextbuf;\r\nfor (i = 0; i < count; i++) {\r\nbuf = i40iw_puda_alloc_buf(rsrc->dev, rsrc->buf_size);\r\nif (!buf) {\r\nrsrc->stats_buf_alloc_fail++;\r\nreturn I40IW_ERR_NO_MEMORY;\r\n}\r\ni40iw_puda_ret_bufpool(rsrc, buf);\r\nrsrc->alloc_buf_count++;\r\nif (!rsrc->alloclist) {\r\nrsrc->alloclist = buf;\r\n} else {\r\nnextbuf = rsrc->alloclist;\r\nrsrc->alloclist = buf;\r\nbuf->next = nextbuf;\r\n}\r\n}\r\nrsrc->avail_buf_count = rsrc->alloc_buf_count;\r\nreturn 0;\r\n}\r\nenum i40iw_status_code i40iw_puda_create_rsrc(struct i40iw_sc_vsi *vsi,\r\nstruct i40iw_puda_rsrc_info *info)\r\n{\r\nstruct i40iw_sc_dev *dev = vsi->dev;\r\nenum i40iw_status_code ret = 0;\r\nstruct i40iw_puda_rsrc *rsrc;\r\nu32 pudasize;\r\nu32 sqwridsize, rqwridsize;\r\nstruct i40iw_virt_mem *vmem;\r\ninfo->count = 1;\r\npudasize = sizeof(struct i40iw_puda_rsrc);\r\nsqwridsize = info->sq_size * sizeof(struct i40iw_sq_uk_wr_trk_info);\r\nrqwridsize = info->rq_size * 8;\r\nswitch (info->type) {\r\ncase I40IW_PUDA_RSRC_TYPE_ILQ:\r\nvmem = &vsi->ilq_mem;\r\nbreak;\r\ncase I40IW_PUDA_RSRC_TYPE_IEQ:\r\nvmem = &vsi->ieq_mem;\r\nbreak;\r\ndefault:\r\nreturn I40IW_NOT_SUPPORTED;\r\n}\r\nret =\r\ni40iw_allocate_virt_mem(dev->hw, vmem,\r\npudasize + sqwridsize + rqwridsize);\r\nif (ret)\r\nreturn ret;\r\nrsrc = (struct i40iw_puda_rsrc *)vmem->va;\r\nspin_lock_init(&rsrc->bufpool_lock);\r\nif (info->type == I40IW_PUDA_RSRC_TYPE_ILQ) {\r\nvsi->ilq = (struct i40iw_puda_rsrc *)vmem->va;\r\nvsi->ilq_count = info->count;\r\nrsrc->receive = info->receive;\r\nrsrc->xmit_complete = info->xmit_complete;\r\n} else {\r\nvmem = &vsi->ieq_mem;\r\nvsi->ieq_count = info->count;\r\nvsi->ieq = (struct i40iw_puda_rsrc *)vmem->va;\r\nrsrc->receive = i40iw_ieq_receive;\r\nrsrc->xmit_complete = i40iw_ieq_tx_compl;\r\n}\r\nrsrc->ceq_valid = info->ceq_valid;\r\nrsrc->type = info->type;\r\nrsrc->sq_wrtrk_array = (struct i40iw_sq_uk_wr_trk_info *)((u8 *)vmem->va + pudasize);\r\nrsrc->rq_wrid_array = (u64 *)((u8 *)vmem->va + pudasize + sqwridsize);\r\nINIT_LIST_HEAD(&rsrc->bufpool);\r\nINIT_LIST_HEAD(&rsrc->txpend);\r\nrsrc->tx_wqe_avail_cnt = info->sq_size - 1;\r\ndev->iw_pd_ops->pd_init(dev, &rsrc->sc_pd, info->pd_id, -1);\r\nrsrc->qp_id = info->qp_id;\r\nrsrc->cq_id = info->cq_id;\r\nrsrc->sq_size = info->sq_size;\r\nrsrc->rq_size = info->rq_size;\r\nrsrc->cq_size = info->rq_size + info->sq_size;\r\nrsrc->buf_size = info->buf_size;\r\nrsrc->dev = dev;\r\nrsrc->vsi = vsi;\r\nret = i40iw_puda_cq_create(rsrc);\r\nif (!ret) {\r\nrsrc->completion = PUDA_CQ_CREATED;\r\nret = i40iw_puda_qp_create(rsrc);\r\n}\r\nif (ret) {\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA, "[%s] error qp_create\n", __func__);\r\ngoto error;\r\n}\r\nrsrc->completion = PUDA_QP_CREATED;\r\nret = i40iw_puda_allocbufs(rsrc, info->tx_buf_cnt + info->rq_size);\r\nif (ret) {\r\ni40iw_debug(dev, I40IW_DEBUG_PUDA, "[%s] error allloc_buf\n", __func__);\r\ngoto error;\r\n}\r\nrsrc->rxq_invalid_cnt = info->rq_size;\r\nret = i40iw_puda_replenish_rq(rsrc, true);\r\nif (ret)\r\ngoto error;\r\nif (info->type == I40IW_PUDA_RSRC_TYPE_IEQ) {\r\nif (!i40iw_init_hash_desc(&rsrc->hash_desc)) {\r\nrsrc->check_crc = true;\r\nrsrc->completion = PUDA_HASH_CRC_COMPLETE;\r\nret = 0;\r\n}\r\n}\r\ndev->ccq_ops->ccq_arm(&rsrc->cq);\r\nreturn ret;\r\nerror:\r\ni40iw_puda_dele_resources(vsi, info->type, false);\r\nreturn ret;\r\n}\r\nstatic void i40iw_ilq_putback_rcvbuf(struct i40iw_sc_qp *qp, u32 wqe_idx)\r\n{\r\nu64 *wqe;\r\nu64 offset24;\r\nwqe = qp->qp_uk.rq_base[wqe_idx].elem;\r\nget_64bit_val(wqe, 24, &offset24);\r\noffset24 = (offset24) ? 0 : LS_64(1, I40IWQPSQ_VALID);\r\nset_64bit_val(wqe, 24, offset24);\r\n}\r\nstatic u16 i40iw_ieq_get_fpdu_length(u16 length)\r\n{\r\nu16 fpdu_len;\r\nfpdu_len = length + I40IW_IEQ_MPA_FRAMING;\r\nfpdu_len = (fpdu_len + 3) & 0xfffffffc;\r\nreturn fpdu_len;\r\n}\r\nstatic void i40iw_ieq_copy_to_txbuf(struct i40iw_puda_buf *buf,\r\nstruct i40iw_puda_buf *txbuf,\r\nu16 buf_offset, u32 txbuf_offset,\r\nu32 length)\r\n{\r\nvoid *mem1 = (u8 *)buf->mem.va + buf_offset;\r\nvoid *mem2 = (u8 *)txbuf->mem.va + txbuf_offset;\r\nmemcpy(mem2, mem1, length);\r\n}\r\nstatic void i40iw_ieq_setup_tx_buf(struct i40iw_puda_buf *buf,\r\nstruct i40iw_puda_buf *txbuf)\r\n{\r\ntxbuf->maclen = buf->maclen;\r\ntxbuf->tcphlen = buf->tcphlen;\r\ntxbuf->ipv4 = buf->ipv4;\r\ntxbuf->hdrlen = buf->hdrlen;\r\ni40iw_ieq_copy_to_txbuf(buf, txbuf, 0, 0, buf->hdrlen);\r\n}\r\nstatic void i40iw_ieq_check_first_buf(struct i40iw_puda_buf *buf, u32 fps)\r\n{\r\nu32 offset;\r\nif (buf->seqnum < fps) {\r\noffset = fps - buf->seqnum;\r\nif (offset > buf->datalen)\r\nreturn;\r\nbuf->data += offset;\r\nbuf->datalen -= (u16)offset;\r\nbuf->seqnum = fps;\r\n}\r\n}\r\nstatic void i40iw_ieq_compl_pfpdu(struct i40iw_puda_rsrc *ieq,\r\nstruct list_head *rxlist,\r\nstruct list_head *pbufl,\r\nstruct i40iw_puda_buf *txbuf,\r\nu16 fpdu_len)\r\n{\r\nstruct i40iw_puda_buf *buf;\r\nu32 nextseqnum;\r\nu16 txoffset, bufoffset;\r\nbuf = i40iw_puda_get_listbuf(pbufl);\r\nif (!buf)\r\nreturn;\r\nnextseqnum = buf->seqnum + fpdu_len;\r\ntxbuf->totallen = buf->hdrlen + fpdu_len;\r\ntxbuf->data = (u8 *)txbuf->mem.va + buf->hdrlen;\r\ni40iw_ieq_setup_tx_buf(buf, txbuf);\r\ntxoffset = buf->hdrlen;\r\nbufoffset = (u16)(buf->data - (u8 *)buf->mem.va);\r\ndo {\r\nif (buf->datalen >= fpdu_len) {\r\ni40iw_ieq_copy_to_txbuf(buf, txbuf, bufoffset, txoffset, fpdu_len);\r\nbuf->datalen -= fpdu_len;\r\nbuf->data += fpdu_len;\r\nbuf->seqnum = nextseqnum;\r\nbreak;\r\n}\r\ni40iw_ieq_copy_to_txbuf(buf, txbuf, bufoffset, txoffset, buf->datalen);\r\ntxoffset += buf->datalen;\r\nfpdu_len -= buf->datalen;\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\nbuf = i40iw_puda_get_listbuf(pbufl);\r\nif (!buf)\r\nreturn;\r\nbufoffset = (u16)(buf->data - (u8 *)buf->mem.va);\r\n} while (1);\r\nif (buf->datalen)\r\nlist_add(&buf->list, rxlist);\r\nelse\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\n}\r\nstatic enum i40iw_status_code i40iw_ieq_create_pbufl(\r\nstruct i40iw_pfpdu *pfpdu,\r\nstruct list_head *rxlist,\r\nstruct list_head *pbufl,\r\nstruct i40iw_puda_buf *buf,\r\nu16 fpdu_len)\r\n{\r\nenum i40iw_status_code status = 0;\r\nstruct i40iw_puda_buf *nextbuf;\r\nu32 nextseqnum;\r\nu16 plen = fpdu_len - buf->datalen;\r\nbool done = false;\r\nnextseqnum = buf->seqnum + buf->datalen;\r\ndo {\r\nnextbuf = i40iw_puda_get_listbuf(rxlist);\r\nif (!nextbuf) {\r\nstatus = I40IW_ERR_list_empty;\r\nbreak;\r\n}\r\nlist_add_tail(&nextbuf->list, pbufl);\r\nif (nextbuf->seqnum != nextseqnum) {\r\npfpdu->bad_seq_num++;\r\nstatus = I40IW_ERR_SEQ_NUM;\r\nbreak;\r\n}\r\nif (nextbuf->datalen >= plen) {\r\ndone = true;\r\n} else {\r\nplen -= nextbuf->datalen;\r\nnextseqnum = nextbuf->seqnum + nextbuf->datalen;\r\n}\r\n} while (!done);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_ieq_handle_partial(struct i40iw_puda_rsrc *ieq,\r\nstruct i40iw_pfpdu *pfpdu,\r\nstruct i40iw_puda_buf *buf,\r\nu16 fpdu_len)\r\n{\r\nenum i40iw_status_code status = 0;\r\nu8 *crcptr;\r\nu32 mpacrc;\r\nu32 seqnum = buf->seqnum;\r\nstruct list_head pbufl;\r\nstruct i40iw_puda_buf *txbuf = NULL;\r\nstruct list_head *rxlist = &pfpdu->rxlist;\r\nINIT_LIST_HEAD(&pbufl);\r\nlist_add(&buf->list, &pbufl);\r\nstatus = i40iw_ieq_create_pbufl(pfpdu, rxlist, &pbufl, buf, fpdu_len);\r\nif (status)\r\ngoto error;\r\ntxbuf = i40iw_puda_get_bufpool(ieq);\r\nif (!txbuf) {\r\npfpdu->no_tx_bufs++;\r\nstatus = I40IW_ERR_NO_TXBUFS;\r\ngoto error;\r\n}\r\ni40iw_ieq_compl_pfpdu(ieq, rxlist, &pbufl, txbuf, fpdu_len);\r\ni40iw_ieq_update_tcpip_info(txbuf, fpdu_len, seqnum);\r\ncrcptr = txbuf->data + fpdu_len - 4;\r\nmpacrc = *(u32 *)crcptr;\r\nif (ieq->check_crc) {\r\nstatus = i40iw_ieq_check_mpacrc(ieq->hash_desc, txbuf->data,\r\n(fpdu_len - 4), mpacrc);\r\nif (status) {\r\ni40iw_debug(ieq->dev, I40IW_DEBUG_IEQ,\r\n"%s: error bad crc\n", __func__);\r\ngoto error;\r\n}\r\n}\r\ni40iw_debug_buf(ieq->dev, I40IW_DEBUG_IEQ, "IEQ TX BUFFER",\r\ntxbuf->mem.va, txbuf->totallen);\r\ni40iw_puda_send_buf(ieq, txbuf);\r\npfpdu->rcv_nxt = seqnum + fpdu_len;\r\nreturn status;\r\nerror:\r\nwhile (!list_empty(&pbufl)) {\r\nbuf = (struct i40iw_puda_buf *)(pbufl.prev);\r\nlist_del(&buf->list);\r\nlist_add(&buf->list, rxlist);\r\n}\r\nif (txbuf)\r\ni40iw_puda_ret_bufpool(ieq, txbuf);\r\nreturn status;\r\n}\r\nstatic enum i40iw_status_code i40iw_ieq_process_buf(struct i40iw_puda_rsrc *ieq,\r\nstruct i40iw_pfpdu *pfpdu,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\nu16 fpdu_len = 0;\r\nu16 datalen = buf->datalen;\r\nu8 *datap = buf->data;\r\nu8 *crcptr;\r\nu16 ioffset = 0;\r\nu32 mpacrc;\r\nu32 seqnum = buf->seqnum;\r\nu16 length = 0;\r\nu16 full = 0;\r\nbool partial = false;\r\nstruct i40iw_puda_buf *txbuf;\r\nstruct list_head *rxlist = &pfpdu->rxlist;\r\nenum i40iw_status_code ret = 0;\r\nenum i40iw_status_code status = 0;\r\nioffset = (u16)(buf->data - (u8 *)buf->mem.va);\r\nwhile (datalen) {\r\nfpdu_len = i40iw_ieq_get_fpdu_length(ntohs(*(__be16 *)datap));\r\nif (fpdu_len > pfpdu->max_fpdu_data) {\r\ni40iw_debug(ieq->dev, I40IW_DEBUG_IEQ,\r\n"%s: error bad fpdu_len\n", __func__);\r\nstatus = I40IW_ERR_MPA_CRC;\r\nlist_add(&buf->list, rxlist);\r\nreturn status;\r\n}\r\nif (datalen < fpdu_len) {\r\npartial = true;\r\nbreak;\r\n}\r\ncrcptr = datap + fpdu_len - 4;\r\nmpacrc = *(u32 *)crcptr;\r\nif (ieq->check_crc)\r\nret = i40iw_ieq_check_mpacrc(ieq->hash_desc,\r\ndatap, fpdu_len - 4, mpacrc);\r\nif (ret) {\r\nstatus = I40IW_ERR_MPA_CRC;\r\nlist_add(&buf->list, rxlist);\r\nreturn status;\r\n}\r\nfull++;\r\npfpdu->fpdu_processed++;\r\ndatap += fpdu_len;\r\nlength += fpdu_len;\r\ndatalen -= fpdu_len;\r\n}\r\nif (full) {\r\ntxbuf = i40iw_puda_get_bufpool(ieq);\r\nif (!txbuf) {\r\npfpdu->no_tx_bufs++;\r\nstatus = I40IW_ERR_NO_TXBUFS;\r\nlist_add(&buf->list, rxlist);\r\nreturn status;\r\n}\r\ni40iw_ieq_setup_tx_buf(buf, txbuf);\r\ni40iw_ieq_copy_to_txbuf(buf, txbuf, ioffset, buf->hdrlen,\r\nlength);\r\ntxbuf->totallen = buf->hdrlen + length;\r\ni40iw_ieq_update_tcpip_info(txbuf, length, buf->seqnum);\r\ni40iw_puda_send_buf(ieq, txbuf);\r\nif (!datalen) {\r\npfpdu->rcv_nxt = buf->seqnum + length;\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\nreturn status;\r\n}\r\nbuf->data = datap;\r\nbuf->seqnum = seqnum + length;\r\nbuf->datalen = datalen;\r\npfpdu->rcv_nxt = buf->seqnum;\r\n}\r\nif (partial)\r\nstatus = i40iw_ieq_handle_partial(ieq, pfpdu, buf, fpdu_len);\r\nreturn status;\r\n}\r\nstatic void i40iw_ieq_process_fpdus(struct i40iw_sc_qp *qp,\r\nstruct i40iw_puda_rsrc *ieq)\r\n{\r\nstruct i40iw_pfpdu *pfpdu = &qp->pfpdu;\r\nstruct list_head *rxlist = &pfpdu->rxlist;\r\nstruct i40iw_puda_buf *buf;\r\nenum i40iw_status_code status;\r\ndo {\r\nif (list_empty(rxlist))\r\nbreak;\r\nbuf = i40iw_puda_get_listbuf(rxlist);\r\nif (!buf) {\r\ni40iw_debug(ieq->dev, I40IW_DEBUG_IEQ,\r\n"%s: error no buf\n", __func__);\r\nbreak;\r\n}\r\nif (buf->seqnum != pfpdu->rcv_nxt) {\r\npfpdu->out_of_order++;\r\nlist_add(&buf->list, rxlist);\r\nbreak;\r\n}\r\nstatus = i40iw_ieq_process_buf(ieq, pfpdu, buf);\r\nif (status == I40IW_ERR_MPA_CRC) {\r\npfpdu->mpa_crc_err = true;\r\nwhile (!list_empty(rxlist)) {\r\nbuf = i40iw_puda_get_listbuf(rxlist);\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\npfpdu->crc_err++;\r\n}\r\ni40iw_ieq_mpa_crc_ae(ieq->dev, qp);\r\n}\r\n} while (!status);\r\n}\r\nstatic void i40iw_ieq_handle_exception(struct i40iw_puda_rsrc *ieq,\r\nstruct i40iw_sc_qp *qp,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\nstruct i40iw_puda_buf *tmpbuf = NULL;\r\nstruct i40iw_pfpdu *pfpdu = &qp->pfpdu;\r\nu32 *hw_host_ctx = (u32 *)qp->hw_host_ctx;\r\nu32 rcv_wnd = hw_host_ctx[23];\r\nu32 fps = qp->q2_buf[16];\r\nstruct list_head *rxlist = &pfpdu->rxlist;\r\nstruct list_head *plist;\r\npfpdu->total_ieq_bufs++;\r\nif (pfpdu->mpa_crc_err) {\r\npfpdu->crc_err++;\r\ngoto error;\r\n}\r\nif (pfpdu->mode && (fps != pfpdu->fps)) {\r\ni40iw_ieq_cleanup_qp(ieq, qp);\r\ni40iw_debug(ieq->dev, I40IW_DEBUG_IEQ,\r\n"%s: restarting new partial\n", __func__);\r\npfpdu->mode = false;\r\n}\r\nif (!pfpdu->mode) {\r\ni40iw_debug_buf(ieq->dev, I40IW_DEBUG_IEQ, "Q2 BUFFER", (u64 *)qp->q2_buf, 128);\r\npfpdu->rcv_nxt = fps;\r\npfpdu->fps = fps;\r\npfpdu->mode = true;\r\npfpdu->max_fpdu_data = ieq->vsi->mss;\r\npfpdu->pmode_count++;\r\nINIT_LIST_HEAD(rxlist);\r\ni40iw_ieq_check_first_buf(buf, fps);\r\n}\r\nif (!(rcv_wnd >= (buf->seqnum - pfpdu->rcv_nxt))) {\r\npfpdu->bad_seq_num++;\r\ngoto error;\r\n}\r\nif (!list_empty(rxlist)) {\r\ntmpbuf = (struct i40iw_puda_buf *)rxlist->next;\r\nplist = &tmpbuf->list;\r\nwhile ((struct list_head *)tmpbuf != rxlist) {\r\nif ((int)(buf->seqnum - tmpbuf->seqnum) < 0)\r\nbreak;\r\ntmpbuf = (struct i40iw_puda_buf *)plist->next;\r\n}\r\nlist_add_tail(&buf->list, &tmpbuf->list);\r\n} else {\r\nlist_add_tail(&buf->list, rxlist);\r\n}\r\ni40iw_ieq_process_fpdus(qp, ieq);\r\nreturn;\r\nerror:\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\n}\r\nstatic void i40iw_ieq_receive(struct i40iw_sc_vsi *vsi,\r\nstruct i40iw_puda_buf *buf)\r\n{\r\nstruct i40iw_puda_rsrc *ieq = vsi->ieq;\r\nstruct i40iw_sc_qp *qp = NULL;\r\nu32 wqe_idx = ieq->compl_rxwqe_idx;\r\nqp = i40iw_ieq_get_qp(vsi->dev, buf);\r\nif (!qp) {\r\nieq->stats_bad_qp_id++;\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\n} else {\r\ni40iw_ieq_handle_exception(ieq, qp, buf);\r\n}\r\nif (!ieq->rxq_invalid_cnt)\r\nieq->rx_wqe_idx = wqe_idx;\r\nieq->rxq_invalid_cnt++;\r\n}\r\nstatic void i40iw_ieq_tx_compl(struct i40iw_sc_vsi *vsi, void *sqwrid)\r\n{\r\nstruct i40iw_puda_rsrc *ieq = vsi->ieq;\r\nstruct i40iw_puda_buf *buf = (struct i40iw_puda_buf *)sqwrid;\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\nif (!list_empty(&ieq->txpend)) {\r\nbuf = i40iw_puda_get_listbuf(&ieq->txpend);\r\ni40iw_puda_send_buf(ieq, buf);\r\n}\r\n}\r\nstatic void i40iw_ieq_cleanup_qp(struct i40iw_puda_rsrc *ieq, struct i40iw_sc_qp *qp)\r\n{\r\nstruct i40iw_puda_buf *buf;\r\nstruct i40iw_pfpdu *pfpdu = &qp->pfpdu;\r\nstruct list_head *rxlist = &pfpdu->rxlist;\r\nif (!pfpdu->mode)\r\nreturn;\r\nwhile (!list_empty(rxlist)) {\r\nbuf = i40iw_puda_get_listbuf(rxlist);\r\ni40iw_puda_ret_bufpool(ieq, buf);\r\n}\r\n}
