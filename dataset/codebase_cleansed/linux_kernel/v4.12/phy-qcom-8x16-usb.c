static int phy_8x16_notify_connect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\nstruct phy_8x16 *qphy = container_of(phy, struct phy_8x16, phy);\r\nu32 val;\r\nval = ULPI_MISC_A_VBUSVLDEXTSEL | ULPI_MISC_A_VBUSVLDEXT;\r\nusb_phy_io_write(&qphy->phy, val, ULPI_SET(ULPI_MISC_A));\r\nval = readl(qphy->regs + HSPHY_USBCMD);\r\nval |= HSPHY_SESS_VLD_CTRL;\r\nwritel(val, qphy->regs + HSPHY_USBCMD);\r\nreturn 0;\r\n}\r\nstatic int phy_8x16_notify_disconnect(struct usb_phy *phy,\r\nenum usb_device_speed speed)\r\n{\r\nstruct phy_8x16 *qphy = container_of(phy, struct phy_8x16, phy);\r\nu32 val;\r\nval = ULPI_MISC_A_VBUSVLDEXT | ULPI_MISC_A_VBUSVLDEXTSEL;\r\nusb_phy_io_write(&qphy->phy, val, ULPI_CLR(ULPI_MISC_A));\r\nval = readl(qphy->regs + HSPHY_USBCMD);\r\nval &= ~HSPHY_SESS_VLD_CTRL;\r\nwritel(val, qphy->regs + HSPHY_USBCMD);\r\nreturn 0;\r\n}\r\nstatic int phy_8x16_vbus_on(struct phy_8x16 *qphy)\r\n{\r\nphy_8x16_notify_connect(&qphy->phy, USB_SPEED_UNKNOWN);\r\ngpiod_set_value_cansleep(qphy->switch_gpio, 0);\r\nreturn 0;\r\n}\r\nstatic int phy_8x16_vbus_off(struct phy_8x16 *qphy)\r\n{\r\nphy_8x16_notify_disconnect(&qphy->phy, USB_SPEED_UNKNOWN);\r\ngpiod_set_value_cansleep(qphy->switch_gpio, 1);\r\nreturn 0;\r\n}\r\nstatic int phy_8x16_vbus_notify(struct notifier_block *nb, unsigned long event,\r\nvoid *ptr)\r\n{\r\nstruct phy_8x16 *qphy = container_of(nb, struct phy_8x16, vbus_notify);\r\nif (event)\r\nphy_8x16_vbus_on(qphy);\r\nelse\r\nphy_8x16_vbus_off(qphy);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int phy_8x16_init(struct usb_phy *phy)\r\n{\r\nstruct phy_8x16 *qphy = container_of(phy, struct phy_8x16, phy);\r\nu32 val, init[] = {0x44, 0x6B, 0x24, 0x13};\r\nu32 addr = ULPI_EXT_VENDOR_SPECIFIC;\r\nint idx, state;\r\nfor (idx = 0; idx < ARRAY_SIZE(init); idx++)\r\nusb_phy_io_write(phy, init[idx], addr + idx);\r\nreset_control_reset(qphy->phy_reset);\r\nval = readl(qphy->regs + HSPHY_CTRL);\r\nval |= HSPHY_POR_ASSERT;\r\nwritel(val, qphy->regs + HSPHY_CTRL);\r\nusleep_range(12, 15);\r\nval = readl(qphy->regs + HSPHY_CTRL);\r\nval &= ~HSPHY_POR_ASSERT;\r\nwritel(val, qphy->regs + HSPHY_CTRL);\r\nusleep_range(10, 15);\r\nwritel(0x00, qphy->regs + HSPHY_AHBBURST);\r\nwritel(0x08, qphy->regs + HSPHY_AHBMODE);\r\nval = readl(qphy->regs + HSPHY_GENCONFIG);\r\nval &= ~HSPHY_TXFIFO_IDLE_FORCE_DIS;\r\nwritel(val, qphy->regs + HSPHY_GENCONFIG);\r\nval = readl(qphy->regs + HSPHY_GENCONFIG_2);\r\nval |= HSPHY_SESS_VLD_CTRL_EN;\r\nwritel(val, qphy->regs + HSPHY_GENCONFIG_2);\r\nval = ULPI_PWR_OTG_COMP_DISABLE;\r\nusb_phy_io_write(phy, val, ULPI_SET(ULPI_PWR_CLK_MNG_REG));\r\nstate = extcon_get_state(qphy->vbus_edev, EXTCON_USB);\r\nif (state)\r\nphy_8x16_vbus_on(qphy);\r\nelse\r\nphy_8x16_vbus_off(qphy);\r\nval = usb_phy_io_read(&qphy->phy, ULPI_FUNC_CTRL);\r\nval &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nval |= ULPI_FUNC_CTRL_OPMODE_NORMAL;\r\nusb_phy_io_write(&qphy->phy, val, ULPI_FUNC_CTRL);\r\nreturn 0;\r\n}\r\nstatic void phy_8x16_shutdown(struct usb_phy *phy)\r\n{\r\nu32 val;\r\nval = usb_phy_io_read(phy, ULPI_FUNC_CTRL);\r\nval &= ~ULPI_FUNC_CTRL_OPMODE_MASK;\r\nval |= ULPI_FUNC_CTRL_OPMODE_NONDRIVING;\r\nusb_phy_io_write(phy, val, ULPI_FUNC_CTRL);\r\n}\r\nstatic int phy_8x16_read_devicetree(struct phy_8x16 *qphy)\r\n{\r\nstruct device *dev = qphy->phy.dev;\r\nint ret;\r\nqphy->core_clk = devm_clk_get(dev, "core");\r\nif (IS_ERR(qphy->core_clk))\r\nreturn PTR_ERR(qphy->core_clk);\r\nqphy->iface_clk = devm_clk_get(dev, "iface");\r\nif (IS_ERR(qphy->iface_clk))\r\nreturn PTR_ERR(qphy->iface_clk);\r\nqphy->regulator[0].supply = "v3p3";\r\nqphy->regulator[1].supply = "v1p8";\r\nqphy->regulator[2].supply = "vddcx";\r\nret = devm_regulator_bulk_get(dev, ARRAY_SIZE(qphy->regulator),\r\nqphy->regulator);\r\nif (ret)\r\nreturn ret;\r\nqphy->phy_reset = devm_reset_control_get(dev, "phy");\r\nif (IS_ERR(qphy->phy_reset))\r\nreturn PTR_ERR(qphy->phy_reset);\r\nqphy->switch_gpio = devm_gpiod_get_optional(dev, "switch",\r\nGPIOD_OUT_LOW);\r\nreturn PTR_ERR_OR_ZERO(qphy->switch_gpio);\r\n}\r\nstatic int phy_8x16_reboot_notify(struct notifier_block *this,\r\nunsigned long code, void *unused)\r\n{\r\nstruct phy_8x16 *qphy;\r\nqphy = container_of(this, struct phy_8x16, reboot_notify);\r\ngpiod_set_value_cansleep(qphy->switch_gpio, 0);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int phy_8x16_probe(struct platform_device *pdev)\r\n{\r\nstruct phy_8x16 *qphy;\r\nstruct resource *res;\r\nstruct usb_phy *phy;\r\nint ret;\r\nqphy = devm_kzalloc(&pdev->dev, sizeof(*qphy), GFP_KERNEL);\r\nif (!qphy)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, qphy);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn -EINVAL;\r\nqphy->regs = devm_ioremap(&pdev->dev, res->start, resource_size(res));\r\nif (!qphy->regs)\r\nreturn -ENOMEM;\r\nphy = &qphy->phy;\r\nphy->dev = &pdev->dev;\r\nphy->label = dev_name(&pdev->dev);\r\nphy->init = phy_8x16_init;\r\nphy->shutdown = phy_8x16_shutdown;\r\nphy->notify_connect = phy_8x16_notify_connect;\r\nphy->notify_disconnect = phy_8x16_notify_disconnect;\r\nphy->io_priv = qphy->regs + HSPHY_ULPI_VIEWPORT;\r\nphy->io_ops = &ulpi_viewport_access_ops;\r\nphy->type = USB_PHY_TYPE_USB2;\r\nret = phy_8x16_read_devicetree(qphy);\r\nif (ret < 0)\r\nreturn ret;\r\nqphy->vbus_edev = extcon_get_edev_by_phandle(phy->dev, 0);\r\nif (IS_ERR(qphy->vbus_edev))\r\nreturn PTR_ERR(qphy->vbus_edev);\r\nret = clk_set_rate(qphy->core_clk, INT_MAX);\r\nif (ret < 0)\r\ndev_dbg(phy->dev, "Can't boost core clock\n");\r\nret = clk_prepare_enable(qphy->core_clk);\r\nif (ret < 0)\r\nreturn ret;\r\nret = clk_prepare_enable(qphy->iface_clk);\r\nif (ret < 0)\r\ngoto off_core;\r\nret = regulator_bulk_enable(ARRAY_SIZE(qphy->regulator),\r\nqphy->regulator);\r\nif (WARN_ON(ret))\r\ngoto off_clks;\r\nqphy->vbus_notify.notifier_call = phy_8x16_vbus_notify;\r\nret = devm_extcon_register_notifier(&pdev->dev, qphy->vbus_edev,\r\nEXTCON_USB, &qphy->vbus_notify);\r\nif (ret < 0)\r\ngoto off_power;\r\nret = usb_add_phy_dev(&qphy->phy);\r\nif (ret)\r\ngoto off_power;\r\nqphy->reboot_notify.notifier_call = phy_8x16_reboot_notify;\r\nregister_reboot_notifier(&qphy->reboot_notify);\r\nreturn 0;\r\noff_power:\r\nregulator_bulk_disable(ARRAY_SIZE(qphy->regulator), qphy->regulator);\r\noff_clks:\r\nclk_disable_unprepare(qphy->iface_clk);\r\noff_core:\r\nclk_disable_unprepare(qphy->core_clk);\r\nreturn ret;\r\n}\r\nstatic int phy_8x16_remove(struct platform_device *pdev)\r\n{\r\nstruct phy_8x16 *qphy = platform_get_drvdata(pdev);\r\nunregister_reboot_notifier(&qphy->reboot_notify);\r\ngpiod_set_value_cansleep(qphy->switch_gpio, 0);\r\nusb_remove_phy(&qphy->phy);\r\nclk_disable_unprepare(qphy->iface_clk);\r\nclk_disable_unprepare(qphy->core_clk);\r\nregulator_bulk_disable(ARRAY_SIZE(qphy->regulator), qphy->regulator);\r\nreturn 0;\r\n}
