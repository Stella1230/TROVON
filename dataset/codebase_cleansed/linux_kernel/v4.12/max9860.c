static int max9860_dvddio_event(struct notifier_block *nb,\r\nunsigned long event, void *data)\r\n{\r\nstruct max9860_priv *max9860 = container_of(nb, struct max9860_priv,\r\ndvddio_nb);\r\nif (event & REGULATOR_EVENT_DISABLE) {\r\nregcache_mark_dirty(max9860->regmap);\r\nregcache_cache_only(max9860->regmap, true);\r\n}\r\nreturn 0;\r\n}\r\nstatic bool max9860_readable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX9860_INTRSTATUS ... MAX9860_MICGAIN:\r\ncase MAX9860_MICADC ... MAX9860_PWRMAN:\r\ncase MAX9860_REVISION:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool max9860_writeable(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX9860_INTEN ... MAX9860_MICGAIN:\r\ncase MAX9860_MICADC ... MAX9860_PWRMAN:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool max9860_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX9860_INTRSTATUS:\r\ncase MAX9860_MICREADBACK:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool max9860_precious(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase MAX9860_INTRSTATUS:\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int max9860_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max9860_priv *max9860 = snd_soc_codec_get_drvdata(codec);\r\nu8 master;\r\nu8 ifc1a = 0;\r\nu8 ifc1b = 0;\r\nu8 sysclk = 0;\r\nunsigned long n;\r\nint ret;\r\ndev_dbg(codec->dev, "hw_params %u Hz, %u channels\n",\r\nparams_rate(params),\r\nparams_channels(params));\r\nif (params_channels(params) == 2)\r\nifc1b |= MAX9860_ST;\r\nswitch (max9860->fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmaster = 0;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nmaster = MAX9860_MASTER;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nifc1a |= master;\r\nif (master) {\r\nif (params_width(params) * params_channels(params) > 48)\r\nifc1b |= MAX9860_BSEL_64X;\r\nelse\r\nifc1b |= MAX9860_BSEL_48X;\r\n}\r\nswitch (max9860->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nifc1a |= MAX9860_DDLY;\r\nifc1b |= MAX9860_ADLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nifc1a |= MAX9860_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nif (params_width(params) != 16) {\r\ndev_err(codec->dev,\r\n"DSP_A works for 16 bits per sample only.\n");\r\nreturn -EINVAL;\r\n}\r\nifc1a |= MAX9860_DDLY | MAX9860_WCI | MAX9860_HIZ | MAX9860_TDM;\r\nifc1b |= MAX9860_ADLY;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nif (params_width(params) != 16) {\r\ndev_err(codec->dev,\r\n"DSP_B works for 16 bits per sample only.\n");\r\nreturn -EINVAL;\r\n}\r\nifc1a |= MAX9860_WCI | MAX9860_HIZ | MAX9860_TDM;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (max9860->fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nswitch (max9860->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nreturn -EINVAL;\r\n}\r\nifc1a ^= MAX9860_WCI;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nswitch (max9860->fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_A:\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nreturn -EINVAL;\r\n}\r\nifc1a ^= MAX9860_WCI;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nifc1a ^= MAX9860_DBCI;\r\nifc1b ^= MAX9860_ABCI;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(codec->dev, "IFC1A %02x\n", ifc1a);\r\nret = regmap_write(max9860->regmap, MAX9860_IFC1A, ifc1a);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to set IFC1A: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "IFC1B %02x\n", ifc1b);\r\nret = regmap_write(max9860->regmap, MAX9860_IFC1B, ifc1b);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to set IFC1B: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (params_rate(params) == 8000 || params_rate(params) == 16000) {\r\nif (master) {\r\nswitch (max9860->pclk_rate) {\r\ncase 12000000:\r\nsysclk = MAX9860_FREQ_12MHZ;\r\nbreak;\r\ncase 13000000:\r\nsysclk = MAX9860_FREQ_13MHZ;\r\nbreak;\r\ncase 19200000:\r\nsysclk = MAX9860_FREQ_19_2MHZ;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (sysclk && params_rate(params) == 16000)\r\nsysclk |= MAX9860_16KHZ;\r\n}\r\n}\r\nn = DIV_ROUND_CLOSEST_ULL(65536ULL * 96 * params_rate(params),\r\nmax9860->pclk_rate);\r\nif (!sysclk) {\r\nif (params_rate(params) > 24000)\r\nsysclk |= MAX9860_16KHZ;\r\nif (!master)\r\nn |= 1;\r\n}\r\nsysclk |= max9860->psclk;\r\ndev_dbg(codec->dev, "SYSCLK %02x\n", sysclk);\r\nret = regmap_write(max9860->regmap,\r\nMAX9860_SYSCLK, sysclk);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to set SYSCLK: %d\n", ret);\r\nreturn ret;\r\n}\r\ndev_dbg(codec->dev, "N %lu\n", n);\r\nret = regmap_write(max9860->regmap,\r\nMAX9860_AUDIOCLKHIGH, n >> 8);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to set NHI: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_write(max9860->regmap,\r\nMAX9860_AUDIOCLKLOW, n & 0xff);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to set NLO: %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!master) {\r\ndev_dbg(codec->dev, "Enable PLL\n");\r\nret = regmap_update_bits(max9860->regmap, MAX9860_AUDIOCLKHIGH,\r\nMAX9860_PLL, MAX9860_PLL);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to enable PLL: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int max9860_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct max9860_priv *max9860 = snd_soc_codec_get_drvdata(codec);\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nmax9860->fmt = fmt;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic int max9860_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct max9860_priv *max9860 = dev_get_drvdata(codec->dev);\r\nint ret;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nret = regmap_update_bits(max9860->regmap, MAX9860_PWRMAN,\r\nMAX9860_SHDN, MAX9860_SHDN);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to remove SHDN: %d\n", ret);\r\nreturn ret;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nret = regmap_update_bits(max9860->regmap, MAX9860_PWRMAN,\r\nMAX9860_SHDN, 0);\r\nif (ret) {\r\ndev_err(codec->dev, "Failed to request SHDN: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max9860_suspend(struct device *dev)\r\n{\r\nstruct max9860_priv *max9860 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regmap_update_bits(max9860->regmap, MAX9860_SYSCLK,\r\nMAX9860_PSCLK, MAX9860_PSCLK_OFF);\r\nif (ret) {\r\ndev_err(dev, "Failed to disable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nregulator_disable(max9860->dvddio);\r\nreturn 0;\r\n}\r\nstatic int max9860_resume(struct device *dev)\r\n{\r\nstruct max9860_priv *max9860 = dev_get_drvdata(dev);\r\nint ret;\r\nret = regulator_enable(max9860->dvddio);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable DVDDIO: %d\n", ret);\r\nreturn ret;\r\n}\r\nregcache_cache_only(max9860->regmap, false);\r\nret = regcache_sync(max9860->regmap);\r\nif (ret) {\r\ndev_err(dev, "Failed to sync cache: %d\n", ret);\r\nreturn ret;\r\n}\r\nret = regmap_update_bits(max9860->regmap, MAX9860_SYSCLK,\r\nMAX9860_PSCLK, max9860->psclk);\r\nif (ret) {\r\ndev_err(dev, "Failed to enable clock: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int max9860_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct max9860_priv *max9860;\r\nint ret;\r\nstruct clk *mclk;\r\nunsigned long mclk_rate;\r\nint i;\r\nint intr;\r\nmax9860 = devm_kzalloc(dev, sizeof(struct max9860_priv), GFP_KERNEL);\r\nif (!max9860)\r\nreturn -ENOMEM;\r\nmax9860->dvddio = devm_regulator_get(dev, "DVDDIO");\r\nif (IS_ERR(max9860->dvddio)) {\r\nret = PTR_ERR(max9860->dvddio);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get DVDDIO supply: %d\n", ret);\r\nreturn ret;\r\n}\r\nmax9860->dvddio_nb.notifier_call = max9860_dvddio_event;\r\nret = regulator_register_notifier(max9860->dvddio, &max9860->dvddio_nb);\r\nif (ret)\r\ndev_err(dev, "Failed to register DVDDIO notifier: %d\n", ret);\r\nret = regulator_enable(max9860->dvddio);\r\nif (ret != 0) {\r\ndev_err(dev, "Failed to enable DVDDIO: %d\n", ret);\r\nreturn ret;\r\n}\r\nmax9860->regmap = devm_regmap_init_i2c(i2c, &max9860_regmap);\r\nif (IS_ERR(max9860->regmap)) {\r\nret = PTR_ERR(max9860->regmap);\r\ngoto err_regulator;\r\n}\r\ndev_set_drvdata(dev, max9860);\r\nmclk = clk_get(dev, "mclk");\r\nif (IS_ERR(mclk)) {\r\nret = PTR_ERR(mclk);\r\nif (ret != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get MCLK: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\nmclk_rate = clk_get_rate(mclk);\r\nclk_put(mclk);\r\nif (mclk_rate > 60000000 || mclk_rate < 10000000) {\r\ndev_err(dev, "Bad mclk %luHz (needs 10MHz - 60MHz)\n",\r\nmclk_rate);\r\nret = -EINVAL;\r\ngoto err_regulator;\r\n}\r\nif (mclk_rate >= 40000000)\r\nmax9860->psclk = 3;\r\nelse if (mclk_rate >= 20000000)\r\nmax9860->psclk = 2;\r\nelse\r\nmax9860->psclk = 1;\r\nmax9860->pclk_rate = mclk_rate >> (max9860->psclk - 1);\r\nmax9860->psclk <<= MAX9860_PSCLK_SHIFT;\r\ndev_dbg(dev, "mclk %lu pclk %lu\n", mclk_rate, max9860->pclk_rate);\r\nregcache_cache_bypass(max9860->regmap, true);\r\nfor (i = 0; i < max9860_regmap.num_reg_defaults; ++i) {\r\nret = regmap_write(max9860->regmap,\r\nmax9860_regmap.reg_defaults[i].reg,\r\nmax9860_regmap.reg_defaults[i].def);\r\nif (ret) {\r\ndev_err(dev, "Failed to initialize register %u: %d\n",\r\nmax9860_regmap.reg_defaults[i].reg, ret);\r\ngoto err_regulator;\r\n}\r\n}\r\nregcache_cache_bypass(max9860->regmap, false);\r\nret = regmap_read(max9860->regmap, MAX9860_INTRSTATUS, &intr);\r\nif (ret) {\r\ndev_err(dev, "Failed to clear INTRSTATUS: %d\n", ret);\r\ngoto err_regulator;\r\n}\r\npm_runtime_set_active(dev);\r\npm_runtime_enable(dev);\r\npm_runtime_idle(dev);\r\nret = snd_soc_register_codec(dev, &max9860_codec_driver,\r\n&max9860_dai, 1);\r\nif (ret) {\r\ndev_err(dev, "Failed to register CODEC: %d\n", ret);\r\ngoto err_pm;\r\n}\r\nreturn 0;\r\nerr_pm:\r\npm_runtime_disable(dev);\r\nerr_regulator:\r\nregulator_disable(max9860->dvddio);\r\nreturn ret;\r\n}\r\nstatic int max9860_remove(struct i2c_client *i2c)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct max9860_priv *max9860 = dev_get_drvdata(dev);\r\nsnd_soc_unregister_codec(dev);\r\npm_runtime_disable(dev);\r\nregulator_disable(max9860->dvddio);\r\nreturn 0;\r\n}
