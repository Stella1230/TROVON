static int htp_freq_to_cpu_freq(unsigned int clk_mult)\r\n{\r\nreturn mips_hpt_frequency * clk_mult / 1000;\r\n}\r\nstatic struct cpufreq_frequency_table *\r\nbmips_cpufreq_get_freq_table(const struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_frequency_table *table;\r\nunsigned long cpu_freq;\r\nint i;\r\ncpu_freq = htp_freq_to_cpu_freq(priv->clk_mult);\r\ntable = kmalloc((priv->max_freqs + 1) * sizeof(*table), GFP_KERNEL);\r\nif (!table)\r\nreturn ERR_PTR(-ENOMEM);\r\nfor (i = 0; i < priv->max_freqs; i++) {\r\ntable[i].frequency = cpu_freq / (1 << i);\r\ntable[i].driver_data = i;\r\n}\r\ntable[i].frequency = CPUFREQ_TABLE_END;\r\nreturn table;\r\n}\r\nstatic unsigned int bmips_cpufreq_get(unsigned int cpu)\r\n{\r\nunsigned int div;\r\nuint32_t mode;\r\nswitch (priv->bmips_type) {\r\ncase BMIPS5200:\r\ncase BMIPS5000:\r\nmode = read_c0_brcm_mode();\r\ndiv = ((mode >> BMIPS5_CLK_DIV_SHIFT) & BMIPS5_CLK_DIV_MASK);\r\nbreak;\r\ndefault:\r\ndiv = 0;\r\n}\r\nreturn htp_freq_to_cpu_freq(priv->clk_mult) / (1 << div);\r\n}\r\nstatic int bmips_cpufreq_target_index(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nunsigned int div = policy->freq_table[index].driver_data;\r\nswitch (priv->bmips_type) {\r\ncase BMIPS5200:\r\ncase BMIPS5000:\r\nchange_c0_brcm_mode(BMIPS5_CLK_DIV_MASK << BMIPS5_CLK_DIV_SHIFT,\r\n(1 << BMIPS5_CLK_DIV_SET_SHIFT) |\r\n(div << BMIPS5_CLK_DIV_SHIFT));\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn 0;\r\n}\r\nstatic int bmips_cpufreq_exit(struct cpufreq_policy *policy)\r\n{\r\nkfree(policy->freq_table);\r\nreturn 0;\r\n}\r\nstatic int bmips_cpufreq_init(struct cpufreq_policy *policy)\r\n{\r\nstruct cpufreq_frequency_table *freq_table;\r\nint ret;\r\nfreq_table = bmips_cpufreq_get_freq_table(policy);\r\nif (IS_ERR(freq_table)) {\r\nret = PTR_ERR(freq_table);\r\npr_err("%s: couldn't determine frequency table (%d).\n",\r\nBMIPS_CPUFREQ_NAME, ret);\r\nreturn ret;\r\n}\r\nret = cpufreq_generic_init(policy, freq_table, TRANSITION_LATENCY);\r\nif (ret)\r\nbmips_cpufreq_exit(policy);\r\nelse\r\npr_info("%s: registered\n", BMIPS_CPUFREQ_NAME);\r\nreturn ret;\r\n}\r\nstatic int __init bmips_cpufreq_probe(void)\r\n{\r\nstruct cpufreq_compat *cc;\r\nstruct device_node *np;\r\nfor (cc = bmips_cpufreq_compat; cc->compatible; cc++) {\r\nnp = of_find_compatible_node(NULL, "cpu", cc->compatible);\r\nif (np) {\r\nof_node_put(np);\r\npriv = cc;\r\nbreak;\r\n}\r\n}\r\nif (!cc->compatible)\r\nreturn -ENODEV;\r\nreturn cpufreq_register_driver(&bmips_cpufreq_driver);\r\n}
