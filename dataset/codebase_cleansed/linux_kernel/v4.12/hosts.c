static void scsi_host_cls_release(struct device *dev)\r\n{\r\nput_device(&class_to_shost(dev)->shost_gendev);\r\n}\r\nint scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)\r\n{\r\nenum scsi_host_state oldstate = shost->shost_state;\r\nif (state == oldstate)\r\nreturn 0;\r\nswitch (state) {\r\ncase SHOST_CREATED:\r\ngoto illegal;\r\ncase SHOST_RUNNING:\r\nswitch (oldstate) {\r\ncase SHOST_CREATED:\r\ncase SHOST_RECOVERY:\r\nbreak;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\ncase SHOST_RECOVERY:\r\nswitch (oldstate) {\r\ncase SHOST_RUNNING:\r\nbreak;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\ncase SHOST_CANCEL:\r\nswitch (oldstate) {\r\ncase SHOST_CREATED:\r\ncase SHOST_RUNNING:\r\ncase SHOST_CANCEL_RECOVERY:\r\nbreak;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\ncase SHOST_DEL:\r\nswitch (oldstate) {\r\ncase SHOST_CANCEL:\r\ncase SHOST_DEL_RECOVERY:\r\nbreak;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\ncase SHOST_CANCEL_RECOVERY:\r\nswitch (oldstate) {\r\ncase SHOST_CANCEL:\r\ncase SHOST_RECOVERY:\r\nbreak;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\ncase SHOST_DEL_RECOVERY:\r\nswitch (oldstate) {\r\ncase SHOST_CANCEL_RECOVERY:\r\nbreak;\r\ndefault:\r\ngoto illegal;\r\n}\r\nbreak;\r\n}\r\nshost->shost_state = state;\r\nreturn 0;\r\nillegal:\r\nSCSI_LOG_ERROR_RECOVERY(1,\r\nshost_printk(KERN_ERR, shost,\r\n"Illegal host state transition"\r\n"%s->%s\n",\r\nscsi_host_state_name(oldstate),\r\nscsi_host_state_name(state)));\r\nreturn -EINVAL;\r\n}\r\nvoid scsi_remove_host(struct Scsi_Host *shost)\r\n{\r\nunsigned long flags;\r\nmutex_lock(&shost->scan_mutex);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_CANCEL))\r\nif (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY)) {\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nmutex_unlock(&shost->scan_mutex);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\nscsi_autopm_get_host(shost);\r\nflush_workqueue(shost->tmf_work_q);\r\nscsi_forget_host(shost);\r\nmutex_unlock(&shost->scan_mutex);\r\nscsi_proc_host_rm(shost);\r\nspin_lock_irqsave(shost->host_lock, flags);\r\nif (scsi_host_set_state(shost, SHOST_DEL))\r\nBUG_ON(scsi_host_set_state(shost, SHOST_DEL_RECOVERY));\r\nspin_unlock_irqrestore(shost->host_lock, flags);\r\ntransport_unregister_device(&shost->shost_gendev);\r\ndevice_unregister(&shost->shost_dev);\r\ndevice_del(&shost->shost_gendev);\r\n}\r\nint scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,\r\nstruct device *dma_dev)\r\n{\r\nstruct scsi_host_template *sht = shost->hostt;\r\nint error = -EINVAL;\r\nshost_printk(KERN_INFO, shost, "%s\n",\r\nsht->info ? sht->info(shost) : sht->name);\r\nif (!shost->can_queue) {\r\nshost_printk(KERN_ERR, shost,\r\n"can_queue = 0 no longer supported\n");\r\ngoto fail;\r\n}\r\nerror = scsi_init_sense_cache(shost);\r\nif (error)\r\ngoto fail;\r\nif (shost_use_blk_mq(shost)) {\r\nerror = scsi_mq_setup_tags(shost);\r\nif (error)\r\ngoto fail;\r\n} else {\r\nshost->bqt = blk_init_tags(shost->can_queue,\r\nshost->hostt->tag_alloc_policy);\r\nif (!shost->bqt) {\r\nerror = -ENOMEM;\r\ngoto fail;\r\n}\r\n}\r\nif (!shost->shost_gendev.parent)\r\nshost->shost_gendev.parent = dev ? dev : &platform_bus;\r\nif (!dma_dev)\r\ndma_dev = shost->shost_gendev.parent;\r\nshost->dma_dev = dma_dev;\r\npm_runtime_get_noresume(&shost->shost_gendev);\r\npm_runtime_set_active(&shost->shost_gendev);\r\npm_runtime_enable(&shost->shost_gendev);\r\ndevice_enable_async_suspend(&shost->shost_gendev);\r\nerror = device_add(&shost->shost_gendev);\r\nif (error)\r\ngoto out_disable_runtime_pm;\r\nscsi_host_set_state(shost, SHOST_RUNNING);\r\nget_device(shost->shost_gendev.parent);\r\ndevice_enable_async_suspend(&shost->shost_dev);\r\nerror = device_add(&shost->shost_dev);\r\nif (error)\r\ngoto out_del_gendev;\r\nget_device(&shost->shost_gendev);\r\nif (shost->transportt->host_size) {\r\nshost->shost_data = kzalloc(shost->transportt->host_size,\r\nGFP_KERNEL);\r\nif (shost->shost_data == NULL) {\r\nerror = -ENOMEM;\r\ngoto out_del_dev;\r\n}\r\n}\r\nif (shost->transportt->create_work_queue) {\r\nsnprintf(shost->work_q_name, sizeof(shost->work_q_name),\r\n"scsi_wq_%d", shost->host_no);\r\nshost->work_q = create_singlethread_workqueue(\r\nshost->work_q_name);\r\nif (!shost->work_q) {\r\nerror = -EINVAL;\r\ngoto out_free_shost_data;\r\n}\r\n}\r\nerror = scsi_sysfs_add_host(shost);\r\nif (error)\r\ngoto out_destroy_host;\r\nscsi_proc_host_add(shost);\r\nscsi_autopm_put_host(shost);\r\nreturn error;\r\nout_destroy_host:\r\nif (shost->work_q)\r\ndestroy_workqueue(shost->work_q);\r\nout_free_shost_data:\r\nkfree(shost->shost_data);\r\nout_del_dev:\r\ndevice_del(&shost->shost_dev);\r\nout_del_gendev:\r\ndevice_del(&shost->shost_gendev);\r\nout_disable_runtime_pm:\r\ndevice_disable_async_suspend(&shost->shost_gendev);\r\npm_runtime_disable(&shost->shost_gendev);\r\npm_runtime_set_suspended(&shost->shost_gendev);\r\npm_runtime_put_noidle(&shost->shost_gendev);\r\nif (shost_use_blk_mq(shost))\r\nscsi_mq_destroy_tags(shost);\r\nfail:\r\nreturn error;\r\n}\r\nstatic void scsi_host_dev_release(struct device *dev)\r\n{\r\nstruct Scsi_Host *shost = dev_to_shost(dev);\r\nstruct device *parent = dev->parent;\r\nstruct request_queue *q;\r\nvoid *queuedata;\r\nscsi_proc_hostdir_rm(shost->hostt);\r\nif (shost->tmf_work_q)\r\ndestroy_workqueue(shost->tmf_work_q);\r\nif (shost->ehandler)\r\nkthread_stop(shost->ehandler);\r\nif (shost->work_q)\r\ndestroy_workqueue(shost->work_q);\r\nq = shost->uspace_req_q;\r\nif (q) {\r\nqueuedata = q->queuedata;\r\nblk_cleanup_queue(q);\r\nkfree(queuedata);\r\n}\r\nif (shost->shost_state == SHOST_CREATED) {\r\nkfree(dev_name(&shost->shost_dev));\r\n}\r\nif (shost_use_blk_mq(shost)) {\r\nif (shost->tag_set.tags)\r\nscsi_mq_destroy_tags(shost);\r\n} else {\r\nif (shost->bqt)\r\nblk_free_tags(shost->bqt);\r\n}\r\nkfree(shost->shost_data);\r\nida_simple_remove(&host_index_ida, shost->host_no);\r\nif (parent)\r\nput_device(parent);\r\nkfree(shost);\r\n}\r\nstruct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)\r\n{\r\nstruct Scsi_Host *shost;\r\ngfp_t gfp_mask = GFP_KERNEL;\r\nint index;\r\nif (sht->unchecked_isa_dma && privsize)\r\ngfp_mask |= __GFP_DMA;\r\nshost = kzalloc(sizeof(struct Scsi_Host) + privsize, gfp_mask);\r\nif (!shost)\r\nreturn NULL;\r\nshost->host_lock = &shost->default_lock;\r\nspin_lock_init(shost->host_lock);\r\nshost->shost_state = SHOST_CREATED;\r\nINIT_LIST_HEAD(&shost->__devices);\r\nINIT_LIST_HEAD(&shost->__targets);\r\nINIT_LIST_HEAD(&shost->eh_cmd_q);\r\nINIT_LIST_HEAD(&shost->starved_list);\r\ninit_waitqueue_head(&shost->host_wait);\r\nmutex_init(&shost->scan_mutex);\r\nindex = ida_simple_get(&host_index_ida, 0, 0, GFP_KERNEL);\r\nif (index < 0)\r\ngoto fail_kfree;\r\nshost->host_no = index;\r\nshost->dma_channel = 0xff;\r\nshost->max_channel = 0;\r\nshost->max_id = 8;\r\nshost->max_lun = 8;\r\nshost->transportt = &blank_transport_template;\r\nshost->max_cmd_len = 12;\r\nshost->hostt = sht;\r\nshost->this_id = sht->this_id;\r\nshost->can_queue = sht->can_queue;\r\nshost->sg_tablesize = sht->sg_tablesize;\r\nshost->sg_prot_tablesize = sht->sg_prot_tablesize;\r\nshost->cmd_per_lun = sht->cmd_per_lun;\r\nshost->unchecked_isa_dma = sht->unchecked_isa_dma;\r\nshost->use_clustering = sht->use_clustering;\r\nshost->no_write_same = sht->no_write_same;\r\nif (shost_eh_deadline == -1 || !sht->eh_host_reset_handler)\r\nshost->eh_deadline = -1;\r\nelse if ((ulong) shost_eh_deadline * HZ > INT_MAX) {\r\nshost_printk(KERN_WARNING, shost,\r\n"eh_deadline %u too large, setting to %u\n",\r\nshost_eh_deadline, INT_MAX / HZ);\r\nshost->eh_deadline = INT_MAX;\r\n} else\r\nshost->eh_deadline = shost_eh_deadline * HZ;\r\nif (sht->supported_mode == MODE_UNKNOWN)\r\nshost->active_mode = MODE_INITIATOR;\r\nelse\r\nshost->active_mode = sht->supported_mode;\r\nif (sht->max_host_blocked)\r\nshost->max_host_blocked = sht->max_host_blocked;\r\nelse\r\nshost->max_host_blocked = SCSI_DEFAULT_HOST_BLOCKED;\r\nif (sht->max_sectors)\r\nshost->max_sectors = sht->max_sectors;\r\nelse\r\nshost->max_sectors = SCSI_DEFAULT_MAX_SECTORS;\r\nif (sht->dma_boundary)\r\nshost->dma_boundary = sht->dma_boundary;\r\nelse\r\nshost->dma_boundary = 0xffffffff;\r\nshost->use_blk_mq = scsi_use_blk_mq;\r\ndevice_initialize(&shost->shost_gendev);\r\ndev_set_name(&shost->shost_gendev, "host%d", shost->host_no);\r\nshost->shost_gendev.bus = &scsi_bus_type;\r\nshost->shost_gendev.type = &scsi_host_type;\r\ndevice_initialize(&shost->shost_dev);\r\nshost->shost_dev.parent = &shost->shost_gendev;\r\nshost->shost_dev.class = &shost_class;\r\ndev_set_name(&shost->shost_dev, "host%d", shost->host_no);\r\nshost->shost_dev.groups = scsi_sysfs_shost_attr_groups;\r\nshost->ehandler = kthread_run(scsi_error_handler, shost,\r\n"scsi_eh_%d", shost->host_no);\r\nif (IS_ERR(shost->ehandler)) {\r\nshost_printk(KERN_WARNING, shost,\r\n"error handler thread failed to spawn, error = %ld\n",\r\nPTR_ERR(shost->ehandler));\r\ngoto fail_index_remove;\r\n}\r\nshost->tmf_work_q = alloc_workqueue("scsi_tmf_%d",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM,\r\n1, shost->host_no);\r\nif (!shost->tmf_work_q) {\r\nshost_printk(KERN_WARNING, shost,\r\n"failed to create tmf workq\n");\r\ngoto fail_kthread;\r\n}\r\nscsi_proc_hostdir_add(shost->hostt);\r\nreturn shost;\r\nfail_kthread:\r\nkthread_stop(shost->ehandler);\r\nfail_index_remove:\r\nida_simple_remove(&host_index_ida, shost->host_no);\r\nfail_kfree:\r\nkfree(shost);\r\nreturn NULL;\r\n}\r\nstruct Scsi_Host *scsi_register(struct scsi_host_template *sht, int privsize)\r\n{\r\nstruct Scsi_Host *shost = scsi_host_alloc(sht, privsize);\r\nif (!sht->detect) {\r\nprintk(KERN_WARNING "scsi_register() called on new-style "\r\n"template for driver %s\n", sht->name);\r\ndump_stack();\r\n}\r\nif (shost)\r\nlist_add_tail(&shost->sht_legacy_list, &sht->legacy_hosts);\r\nreturn shost;\r\n}\r\nvoid scsi_unregister(struct Scsi_Host *shost)\r\n{\r\nlist_del(&shost->sht_legacy_list);\r\nscsi_host_put(shost);\r\n}\r\nstatic int __scsi_host_match(struct device *dev, const void *data)\r\n{\r\nstruct Scsi_Host *p;\r\nconst unsigned short *hostnum = data;\r\np = class_to_shost(dev);\r\nreturn p->host_no == *hostnum;\r\n}\r\nstruct Scsi_Host *scsi_host_lookup(unsigned short hostnum)\r\n{\r\nstruct device *cdev;\r\nstruct Scsi_Host *shost = NULL;\r\ncdev = class_find_device(&shost_class, NULL, &hostnum,\r\n__scsi_host_match);\r\nif (cdev) {\r\nshost = scsi_host_get(class_to_shost(cdev));\r\nput_device(cdev);\r\n}\r\nreturn shost;\r\n}\r\nstruct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)\r\n{\r\nif ((shost->shost_state == SHOST_DEL) ||\r\n!get_device(&shost->shost_gendev))\r\nreturn NULL;\r\nreturn shost;\r\n}\r\nvoid scsi_host_put(struct Scsi_Host *shost)\r\n{\r\nput_device(&shost->shost_gendev);\r\n}\r\nint scsi_init_hosts(void)\r\n{\r\nreturn class_register(&shost_class);\r\n}\r\nvoid scsi_exit_hosts(void)\r\n{\r\nclass_unregister(&shost_class);\r\nida_destroy(&host_index_ida);\r\n}\r\nint scsi_is_host_device(const struct device *dev)\r\n{\r\nreturn dev->type == &scsi_host_type;\r\n}\r\nint scsi_queue_work(struct Scsi_Host *shost, struct work_struct *work)\r\n{\r\nif (unlikely(!shost->work_q)) {\r\nshost_printk(KERN_ERR, shost,\r\n"ERROR: Scsi host '%s' attempted to queue scsi-work, "\r\n"when no workqueue created.\n", shost->hostt->name);\r\ndump_stack();\r\nreturn -EINVAL;\r\n}\r\nreturn queue_work(shost->work_q, work);\r\n}\r\nvoid scsi_flush_work(struct Scsi_Host *shost)\r\n{\r\nif (!shost->work_q) {\r\nshost_printk(KERN_ERR, shost,\r\n"ERROR: Scsi host '%s' attempted to flush scsi-work, "\r\n"when no workqueue created.\n", shost->hostt->name);\r\ndump_stack();\r\nreturn;\r\n}\r\nflush_workqueue(shost->work_q);\r\n}
