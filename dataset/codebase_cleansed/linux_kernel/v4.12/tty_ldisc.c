int tty_register_ldisc(int disc, struct tty_ldisc_ops *new_ldisc)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (disc < N_TTY || disc >= NR_LDISCS)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\r\ntty_ldiscs[disc] = new_ldisc;\r\nnew_ldisc->num = disc;\r\nnew_ldisc->refcount = 0;\r\nraw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\r\nreturn ret;\r\n}\r\nint tty_unregister_ldisc(int disc)\r\n{\r\nunsigned long flags;\r\nint ret = 0;\r\nif (disc < N_TTY || disc >= NR_LDISCS)\r\nreturn -EINVAL;\r\nraw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\r\nif (tty_ldiscs[disc]->refcount)\r\nret = -EBUSY;\r\nelse\r\ntty_ldiscs[disc] = NULL;\r\nraw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\r\nreturn ret;\r\n}\r\nstatic struct tty_ldisc_ops *get_ldops(int disc)\r\n{\r\nunsigned long flags;\r\nstruct tty_ldisc_ops *ldops, *ret;\r\nraw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\r\nret = ERR_PTR(-EINVAL);\r\nldops = tty_ldiscs[disc];\r\nif (ldops) {\r\nret = ERR_PTR(-EAGAIN);\r\nif (try_module_get(ldops->owner)) {\r\nldops->refcount++;\r\nret = ldops;\r\n}\r\n}\r\nraw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\r\nreturn ret;\r\n}\r\nstatic void put_ldops(struct tty_ldisc_ops *ldops)\r\n{\r\nunsigned long flags;\r\nraw_spin_lock_irqsave(&tty_ldiscs_lock, flags);\r\nldops->refcount--;\r\nmodule_put(ldops->owner);\r\nraw_spin_unlock_irqrestore(&tty_ldiscs_lock, flags);\r\n}\r\nstatic struct tty_ldisc *tty_ldisc_get(struct tty_struct *tty, int disc)\r\n{\r\nstruct tty_ldisc *ld;\r\nstruct tty_ldisc_ops *ldops;\r\nif (disc < N_TTY || disc >= NR_LDISCS)\r\nreturn ERR_PTR(-EINVAL);\r\nldops = get_ldops(disc);\r\nif (IS_ERR(ldops)) {\r\nrequest_module("tty-ldisc-%d", disc);\r\nldops = get_ldops(disc);\r\nif (IS_ERR(ldops))\r\nreturn ERR_CAST(ldops);\r\n}\r\nld = kmalloc(sizeof(struct tty_ldisc), GFP_KERNEL);\r\nif (ld == NULL) {\r\nput_ldops(ldops);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nld->ops = ldops;\r\nld->tty = tty;\r\nreturn ld;\r\n}\r\nstatic void tty_ldisc_put(struct tty_ldisc *ld)\r\n{\r\nif (WARN_ON_ONCE(!ld))\r\nreturn;\r\nput_ldops(ld->ops);\r\nkfree(ld);\r\n}\r\nstatic void *tty_ldiscs_seq_start(struct seq_file *m, loff_t *pos)\r\n{\r\nreturn (*pos < NR_LDISCS) ? pos : NULL;\r\n}\r\nstatic void *tty_ldiscs_seq_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n(*pos)++;\r\nreturn (*pos < NR_LDISCS) ? pos : NULL;\r\n}\r\nstatic void tty_ldiscs_seq_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int tty_ldiscs_seq_show(struct seq_file *m, void *v)\r\n{\r\nint i = *(loff_t *)v;\r\nstruct tty_ldisc_ops *ldops;\r\nldops = get_ldops(i);\r\nif (IS_ERR(ldops))\r\nreturn 0;\r\nseq_printf(m, "%-10s %2d\n", ldops->name ? ldops->name : "???", i);\r\nput_ldops(ldops);\r\nreturn 0;\r\n}\r\nstatic int proc_tty_ldiscs_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &tty_ldiscs_seq_ops);\r\n}\r\nstruct tty_ldisc *tty_ldisc_ref_wait(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld;\r\nldsem_down_read(&tty->ldisc_sem, MAX_SCHEDULE_TIMEOUT);\r\nld = tty->ldisc;\r\nif (!ld)\r\nldsem_up_read(&tty->ldisc_sem);\r\nreturn ld;\r\n}\r\nstruct tty_ldisc *tty_ldisc_ref(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld = NULL;\r\nif (ldsem_down_read_trylock(&tty->ldisc_sem)) {\r\nld = tty->ldisc;\r\nif (!ld)\r\nldsem_up_read(&tty->ldisc_sem);\r\n}\r\nreturn ld;\r\n}\r\nvoid tty_ldisc_deref(struct tty_ldisc *ld)\r\n{\r\nldsem_up_read(&ld->tty->ldisc_sem);\r\n}\r\nstatic inline int\r\n__tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\r\n{\r\nreturn ldsem_down_write(&tty->ldisc_sem, timeout);\r\n}\r\nstatic inline int\r\n__tty_ldisc_lock_nested(struct tty_struct *tty, unsigned long timeout)\r\n{\r\nreturn ldsem_down_write_nested(&tty->ldisc_sem,\r\nLDISC_SEM_OTHER, timeout);\r\n}\r\nstatic inline void __tty_ldisc_unlock(struct tty_struct *tty)\r\n{\r\nldsem_up_write(&tty->ldisc_sem);\r\n}\r\nstatic int tty_ldisc_lock(struct tty_struct *tty, unsigned long timeout)\r\n{\r\nint ret;\r\nret = __tty_ldisc_lock(tty, timeout);\r\nif (!ret)\r\nreturn -EBUSY;\r\nset_bit(TTY_LDISC_HALTED, &tty->flags);\r\nreturn 0;\r\n}\r\nstatic void tty_ldisc_unlock(struct tty_struct *tty)\r\n{\r\nclear_bit(TTY_LDISC_HALTED, &tty->flags);\r\n__tty_ldisc_unlock(tty);\r\n}\r\nstatic int\r\ntty_ldisc_lock_pair_timeout(struct tty_struct *tty, struct tty_struct *tty2,\r\nunsigned long timeout)\r\n{\r\nint ret;\r\nif (tty < tty2) {\r\nret = __tty_ldisc_lock(tty, timeout);\r\nif (ret) {\r\nret = __tty_ldisc_lock_nested(tty2, timeout);\r\nif (!ret)\r\n__tty_ldisc_unlock(tty);\r\n}\r\n} else {\r\nWARN_ON_ONCE(tty == tty2);\r\nif (tty2 && tty != tty2) {\r\nret = __tty_ldisc_lock(tty2, timeout);\r\nif (ret) {\r\nret = __tty_ldisc_lock_nested(tty, timeout);\r\nif (!ret)\r\n__tty_ldisc_unlock(tty2);\r\n}\r\n} else\r\nret = __tty_ldisc_lock(tty, timeout);\r\n}\r\nif (!ret)\r\nreturn -EBUSY;\r\nset_bit(TTY_LDISC_HALTED, &tty->flags);\r\nif (tty2)\r\nset_bit(TTY_LDISC_HALTED, &tty2->flags);\r\nreturn 0;\r\n}\r\nstatic void tty_ldisc_lock_pair(struct tty_struct *tty, struct tty_struct *tty2)\r\n{\r\ntty_ldisc_lock_pair_timeout(tty, tty2, MAX_SCHEDULE_TIMEOUT);\r\n}\r\nstatic void tty_ldisc_unlock_pair(struct tty_struct *tty,\r\nstruct tty_struct *tty2)\r\n{\r\n__tty_ldisc_unlock(tty);\r\nif (tty2)\r\n__tty_ldisc_unlock(tty2);\r\n}\r\nvoid tty_ldisc_flush(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld = tty_ldisc_ref(tty);\r\ntty_buffer_flush(tty, ld);\r\nif (ld)\r\ntty_ldisc_deref(ld);\r\n}\r\nstatic void tty_set_termios_ldisc(struct tty_struct *tty, int disc)\r\n{\r\ndown_write(&tty->termios_rwsem);\r\ntty->termios.c_line = disc;\r\nup_write(&tty->termios_rwsem);\r\ntty->disc_data = NULL;\r\ntty->receive_room = 0;\r\n}\r\nstatic int tty_ldisc_open(struct tty_struct *tty, struct tty_ldisc *ld)\r\n{\r\nWARN_ON(test_and_set_bit(TTY_LDISC_OPEN, &tty->flags));\r\nif (ld->ops->open) {\r\nint ret;\r\nret = ld->ops->open(tty);\r\nif (ret)\r\nclear_bit(TTY_LDISC_OPEN, &tty->flags);\r\ntty_ldisc_debug(tty, "%p: opened\n", ld);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic void tty_ldisc_close(struct tty_struct *tty, struct tty_ldisc *ld)\r\n{\r\nWARN_ON(!test_bit(TTY_LDISC_OPEN, &tty->flags));\r\nclear_bit(TTY_LDISC_OPEN, &tty->flags);\r\nif (ld->ops->close)\r\nld->ops->close(tty);\r\ntty_ldisc_debug(tty, "%p: closed\n", ld);\r\n}\r\nstatic void tty_ldisc_restore(struct tty_struct *tty, struct tty_ldisc *old)\r\n{\r\nstruct tty_ldisc *new_ldisc;\r\nint r;\r\nold = tty_ldisc_get(tty, old->ops->num);\r\nWARN_ON(IS_ERR(old));\r\ntty->ldisc = old;\r\ntty_set_termios_ldisc(tty, old->ops->num);\r\nif (tty_ldisc_open(tty, old) < 0) {\r\ntty_ldisc_put(old);\r\nnew_ldisc = tty_ldisc_get(tty, N_TTY);\r\nif (IS_ERR(new_ldisc))\r\npanic("n_tty: get");\r\ntty->ldisc = new_ldisc;\r\ntty_set_termios_ldisc(tty, N_TTY);\r\nr = tty_ldisc_open(tty, new_ldisc);\r\nif (r < 0)\r\npanic("Couldn't open N_TTY ldisc for "\r\n"%s --- error %d.",\r\ntty_name(tty), r);\r\n}\r\n}\r\nint tty_set_ldisc(struct tty_struct *tty, int disc)\r\n{\r\nint retval;\r\nstruct tty_ldisc *old_ldisc, *new_ldisc;\r\nnew_ldisc = tty_ldisc_get(tty, disc);\r\nif (IS_ERR(new_ldisc))\r\nreturn PTR_ERR(new_ldisc);\r\ntty_lock(tty);\r\nretval = tty_ldisc_lock(tty, 5 * HZ);\r\nif (retval)\r\ngoto err;\r\nif (!tty->ldisc) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nif (tty->ldisc->ops->num == disc)\r\ngoto out;\r\nif (test_bit(TTY_HUPPED, &tty->flags)) {\r\nretval = -EIO;\r\ngoto out;\r\n}\r\nold_ldisc = tty->ldisc;\r\ntty_ldisc_close(tty, old_ldisc);\r\ntty->ldisc = new_ldisc;\r\ntty_set_termios_ldisc(tty, disc);\r\nretval = tty_ldisc_open(tty, new_ldisc);\r\nif (retval < 0) {\r\ntty_ldisc_put(new_ldisc);\r\ntty_ldisc_restore(tty, old_ldisc);\r\n}\r\nif (tty->ldisc->ops->num != old_ldisc->ops->num && tty->ops->set_ldisc) {\r\ndown_read(&tty->termios_rwsem);\r\ntty->ops->set_ldisc(tty);\r\nup_read(&tty->termios_rwsem);\r\n}\r\nnew_ldisc = old_ldisc;\r\nout:\r\ntty_ldisc_unlock(tty);\r\ntty_buffer_restart_work(tty->port);\r\nerr:\r\ntty_ldisc_put(new_ldisc);\r\ntty_unlock(tty);\r\nreturn retval;\r\n}\r\nstatic void tty_ldisc_kill(struct tty_struct *tty)\r\n{\r\nif (!tty->ldisc)\r\nreturn;\r\ntty_ldisc_close(tty, tty->ldisc);\r\ntty_ldisc_put(tty->ldisc);\r\ntty->ldisc = NULL;\r\n}\r\nstatic void tty_reset_termios(struct tty_struct *tty)\r\n{\r\ndown_write(&tty->termios_rwsem);\r\ntty->termios = tty->driver->init_termios;\r\ntty->termios.c_ispeed = tty_termios_input_baud_rate(&tty->termios);\r\ntty->termios.c_ospeed = tty_termios_baud_rate(&tty->termios);\r\nup_write(&tty->termios_rwsem);\r\n}\r\nint tty_ldisc_reinit(struct tty_struct *tty, int disc)\r\n{\r\nstruct tty_ldisc *ld;\r\nint retval;\r\nld = tty_ldisc_get(tty, disc);\r\nif (IS_ERR(ld)) {\r\nBUG_ON(disc == N_TTY);\r\nreturn PTR_ERR(ld);\r\n}\r\nif (tty->ldisc) {\r\ntty_ldisc_close(tty, tty->ldisc);\r\ntty_ldisc_put(tty->ldisc);\r\n}\r\ntty->ldisc = ld;\r\ntty_set_termios_ldisc(tty, disc);\r\nretval = tty_ldisc_open(tty, tty->ldisc);\r\nif (retval) {\r\nif (!WARN_ON(disc == N_TTY)) {\r\ntty_ldisc_put(tty->ldisc);\r\ntty->ldisc = NULL;\r\n}\r\n}\r\nreturn retval;\r\n}\r\nvoid tty_ldisc_hangup(struct tty_struct *tty, bool reinit)\r\n{\r\nstruct tty_ldisc *ld;\r\ntty_ldisc_debug(tty, "%p: hangup\n", tty->ldisc);\r\nld = tty_ldisc_ref(tty);\r\nif (ld != NULL) {\r\nif (ld->ops->flush_buffer)\r\nld->ops->flush_buffer(tty);\r\ntty_driver_flush_buffer(tty);\r\nif ((test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags)) &&\r\nld->ops->write_wakeup)\r\nld->ops->write_wakeup(tty);\r\nif (ld->ops->hangup)\r\nld->ops->hangup(tty);\r\ntty_ldisc_deref(ld);\r\n}\r\nwake_up_interruptible_poll(&tty->write_wait, POLLOUT);\r\nwake_up_interruptible_poll(&tty->read_wait, POLLIN);\r\ntty_ldisc_lock(tty, MAX_SCHEDULE_TIMEOUT);\r\nif (tty->driver->flags & TTY_DRIVER_RESET_TERMIOS)\r\ntty_reset_termios(tty);\r\nif (tty->ldisc) {\r\nif (reinit) {\r\nif (tty_ldisc_reinit(tty, tty->termios.c_line) < 0)\r\ntty_ldisc_reinit(tty, N_TTY);\r\n} else\r\ntty_ldisc_kill(tty);\r\n}\r\ntty_ldisc_unlock(tty);\r\n}\r\nint tty_ldisc_setup(struct tty_struct *tty, struct tty_struct *o_tty)\r\n{\r\nint retval = tty_ldisc_open(tty, tty->ldisc);\r\nif (retval)\r\nreturn retval;\r\nif (o_tty) {\r\nretval = tty_ldisc_open(o_tty, o_tty->ldisc);\r\nif (retval) {\r\ntty_ldisc_close(tty, tty->ldisc);\r\nreturn retval;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid tty_ldisc_release(struct tty_struct *tty)\r\n{\r\nstruct tty_struct *o_tty = tty->link;\r\ntty_ldisc_lock_pair(tty, o_tty);\r\ntty_ldisc_kill(tty);\r\nif (o_tty)\r\ntty_ldisc_kill(o_tty);\r\ntty_ldisc_unlock_pair(tty, o_tty);\r\ntty_ldisc_debug(tty, "released\n");\r\n}\r\nvoid tty_ldisc_init(struct tty_struct *tty)\r\n{\r\nstruct tty_ldisc *ld = tty_ldisc_get(tty, N_TTY);\r\nif (IS_ERR(ld))\r\npanic("n_tty: init_tty");\r\ntty->ldisc = ld;\r\n}\r\nvoid tty_ldisc_deinit(struct tty_struct *tty)\r\n{\r\nif (tty->ldisc)\r\ntty_ldisc_put(tty->ldisc);\r\ntty->ldisc = NULL;\r\n}
