static void ep93xx_spi_write_u8(const struct ep93xx_spi *espi,\r\nu16 reg, u8 value)\r\n{\r\nwriteb(value, espi->regs_base + reg);\r\n}\r\nstatic u8 ep93xx_spi_read_u8(const struct ep93xx_spi *spi, u16 reg)\r\n{\r\nreturn readb(spi->regs_base + reg);\r\n}\r\nstatic void ep93xx_spi_write_u16(const struct ep93xx_spi *espi,\r\nu16 reg, u16 value)\r\n{\r\nwritew(value, espi->regs_base + reg);\r\n}\r\nstatic u16 ep93xx_spi_read_u16(const struct ep93xx_spi *spi, u16 reg)\r\n{\r\nreturn readw(spi->regs_base + reg);\r\n}\r\nstatic int ep93xx_spi_enable(const struct ep93xx_spi *espi)\r\n{\r\nu8 regval;\r\nint err;\r\nerr = clk_enable(espi->clk);\r\nif (err)\r\nreturn err;\r\nregval = ep93xx_spi_read_u8(espi, SSPCR1);\r\nregval |= SSPCR1_SSE;\r\nep93xx_spi_write_u8(espi, SSPCR1, regval);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_spi_disable(const struct ep93xx_spi *espi)\r\n{\r\nu8 regval;\r\nregval = ep93xx_spi_read_u8(espi, SSPCR1);\r\nregval &= ~SSPCR1_SSE;\r\nep93xx_spi_write_u8(espi, SSPCR1, regval);\r\nclk_disable(espi->clk);\r\n}\r\nstatic void ep93xx_spi_enable_interrupts(const struct ep93xx_spi *espi)\r\n{\r\nu8 regval;\r\nregval = ep93xx_spi_read_u8(espi, SSPCR1);\r\nregval |= (SSPCR1_RORIE | SSPCR1_TIE | SSPCR1_RIE);\r\nep93xx_spi_write_u8(espi, SSPCR1, regval);\r\n}\r\nstatic void ep93xx_spi_disable_interrupts(const struct ep93xx_spi *espi)\r\n{\r\nu8 regval;\r\nregval = ep93xx_spi_read_u8(espi, SSPCR1);\r\nregval &= ~(SSPCR1_RORIE | SSPCR1_TIE | SSPCR1_RIE);\r\nep93xx_spi_write_u8(espi, SSPCR1, regval);\r\n}\r\nstatic int ep93xx_spi_calc_divisors(const struct ep93xx_spi *espi,\r\nu32 rate, u8 *div_cpsr, u8 *div_scr)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(espi->pdev);\r\nunsigned long spi_clk_rate = clk_get_rate(espi->clk);\r\nint cpsr, scr;\r\nrate = clamp(rate, master->min_speed_hz, master->max_speed_hz);\r\nfor (cpsr = 2; cpsr <= 254; cpsr += 2) {\r\nfor (scr = 0; scr <= 255; scr++) {\r\nif ((spi_clk_rate / (cpsr * (scr + 1))) <= rate) {\r\n*div_scr = (u8)scr;\r\n*div_cpsr = (u8)cpsr;\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void ep93xx_spi_cs_control(struct spi_device *spi, bool enable)\r\n{\r\nif (spi->mode & SPI_CS_HIGH)\r\nenable = !enable;\r\nif (gpio_is_valid(spi->cs_gpio))\r\ngpio_set_value(spi->cs_gpio, !enable);\r\n}\r\nstatic int ep93xx_spi_chip_setup(const struct ep93xx_spi *espi,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nu8 dss = bits_per_word_to_dss(xfer->bits_per_word);\r\nu8 div_cpsr = 0;\r\nu8 div_scr = 0;\r\nu16 cr0;\r\nint err;\r\nerr = ep93xx_spi_calc_divisors(espi, xfer->speed_hz,\r\n&div_cpsr, &div_scr);\r\nif (err)\r\nreturn err;\r\ncr0 = div_scr << SSPCR0_SCR_SHIFT;\r\ncr0 |= (spi->mode & (SPI_CPHA | SPI_CPOL)) << SSPCR0_MODE_SHIFT;\r\ncr0 |= dss;\r\ndev_dbg(&espi->pdev->dev, "setup: mode %d, cpsr %d, scr %d, dss %d\n",\r\nspi->mode, div_cpsr, div_scr, dss);\r\ndev_dbg(&espi->pdev->dev, "setup: cr0 %#x\n", cr0);\r\nep93xx_spi_write_u8(espi, SSPCPSR, div_cpsr);\r\nep93xx_spi_write_u16(espi, SSPCR0, cr0);\r\nreturn 0;\r\n}\r\nstatic void ep93xx_do_write(struct ep93xx_spi *espi, struct spi_transfer *t)\r\n{\r\nif (t->bits_per_word > 8) {\r\nu16 tx_val = 0;\r\nif (t->tx_buf)\r\ntx_val = ((u16 *)t->tx_buf)[espi->tx];\r\nep93xx_spi_write_u16(espi, SSPDR, tx_val);\r\nespi->tx += sizeof(tx_val);\r\n} else {\r\nu8 tx_val = 0;\r\nif (t->tx_buf)\r\ntx_val = ((u8 *)t->tx_buf)[espi->tx];\r\nep93xx_spi_write_u8(espi, SSPDR, tx_val);\r\nespi->tx += sizeof(tx_val);\r\n}\r\n}\r\nstatic void ep93xx_do_read(struct ep93xx_spi *espi, struct spi_transfer *t)\r\n{\r\nif (t->bits_per_word > 8) {\r\nu16 rx_val;\r\nrx_val = ep93xx_spi_read_u16(espi, SSPDR);\r\nif (t->rx_buf)\r\n((u16 *)t->rx_buf)[espi->rx] = rx_val;\r\nespi->rx += sizeof(rx_val);\r\n} else {\r\nu8 rx_val;\r\nrx_val = ep93xx_spi_read_u8(espi, SSPDR);\r\nif (t->rx_buf)\r\n((u8 *)t->rx_buf)[espi->rx] = rx_val;\r\nespi->rx += sizeof(rx_val);\r\n}\r\n}\r\nstatic int ep93xx_spi_read_write(struct ep93xx_spi *espi)\r\n{\r\nstruct spi_message *msg = espi->current_msg;\r\nstruct spi_transfer *t = msg->state;\r\nwhile ((ep93xx_spi_read_u8(espi, SSPSR) & SSPSR_RNE)) {\r\nep93xx_do_read(espi, t);\r\nespi->fifo_level--;\r\n}\r\nwhile (espi->fifo_level < SPI_FIFO_SIZE && espi->tx < t->len) {\r\nep93xx_do_write(espi, t);\r\nespi->fifo_level++;\r\n}\r\nif (espi->rx == t->len)\r\nreturn 0;\r\nreturn -EINPROGRESS;\r\n}\r\nstatic void ep93xx_spi_pio_transfer(struct ep93xx_spi *espi)\r\n{\r\nif (ep93xx_spi_read_write(espi)) {\r\nep93xx_spi_enable_interrupts(espi);\r\nwait_for_completion(&espi->wait);\r\n}\r\n}\r\nstatic struct dma_async_tx_descriptor *\r\nep93xx_spi_dma_prepare(struct ep93xx_spi *espi, enum dma_transfer_direction dir)\r\n{\r\nstruct spi_transfer *t = espi->current_msg->state;\r\nstruct dma_async_tx_descriptor *txd;\r\nenum dma_slave_buswidth buswidth;\r\nstruct dma_slave_config conf;\r\nstruct scatterlist *sg;\r\nstruct sg_table *sgt;\r\nstruct dma_chan *chan;\r\nconst void *buf, *pbuf;\r\nsize_t len = t->len;\r\nint i, ret, nents;\r\nif (t->bits_per_word > 8)\r\nbuswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nelse\r\nbuswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nmemset(&conf, 0, sizeof(conf));\r\nconf.direction = dir;\r\nif (dir == DMA_DEV_TO_MEM) {\r\nchan = espi->dma_rx;\r\nbuf = t->rx_buf;\r\nsgt = &espi->rx_sgt;\r\nconf.src_addr = espi->sspdr_phys;\r\nconf.src_addr_width = buswidth;\r\n} else {\r\nchan = espi->dma_tx;\r\nbuf = t->tx_buf;\r\nsgt = &espi->tx_sgt;\r\nconf.dst_addr = espi->sspdr_phys;\r\nconf.dst_addr_width = buswidth;\r\n}\r\nret = dmaengine_slave_config(chan, &conf);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\nnents = DIV_ROUND_UP(len, PAGE_SIZE);\r\nif (nents != sgt->nents) {\r\nsg_free_table(sgt);\r\nret = sg_alloc_table(sgt, nents, GFP_KERNEL);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\n}\r\npbuf = buf;\r\nfor_each_sg(sgt->sgl, sg, sgt->nents, i) {\r\nsize_t bytes = min_t(size_t, len, PAGE_SIZE);\r\nif (buf) {\r\nsg_set_page(sg, virt_to_page(pbuf), bytes,\r\noffset_in_page(pbuf));\r\n} else {\r\nsg_set_page(sg, virt_to_page(espi->zeropage),\r\nbytes, 0);\r\n}\r\npbuf += bytes;\r\nlen -= bytes;\r\n}\r\nif (WARN_ON(len)) {\r\ndev_warn(&espi->pdev->dev, "len = %zu expected 0!\n", len);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nnents = dma_map_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);\r\nif (!nents)\r\nreturn ERR_PTR(-ENOMEM);\r\ntxd = dmaengine_prep_slave_sg(chan, sgt->sgl, nents, dir, DMA_CTRL_ACK);\r\nif (!txd) {\r\ndma_unmap_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\nreturn txd;\r\n}\r\nstatic void ep93xx_spi_dma_finish(struct ep93xx_spi *espi,\r\nenum dma_transfer_direction dir)\r\n{\r\nstruct dma_chan *chan;\r\nstruct sg_table *sgt;\r\nif (dir == DMA_DEV_TO_MEM) {\r\nchan = espi->dma_rx;\r\nsgt = &espi->rx_sgt;\r\n} else {\r\nchan = espi->dma_tx;\r\nsgt = &espi->tx_sgt;\r\n}\r\ndma_unmap_sg(chan->device->dev, sgt->sgl, sgt->nents, dir);\r\n}\r\nstatic void ep93xx_spi_dma_callback(void *callback_param)\r\n{\r\ncomplete(callback_param);\r\n}\r\nstatic void ep93xx_spi_dma_transfer(struct ep93xx_spi *espi)\r\n{\r\nstruct spi_message *msg = espi->current_msg;\r\nstruct dma_async_tx_descriptor *rxd, *txd;\r\nrxd = ep93xx_spi_dma_prepare(espi, DMA_DEV_TO_MEM);\r\nif (IS_ERR(rxd)) {\r\ndev_err(&espi->pdev->dev, "DMA RX failed: %ld\n", PTR_ERR(rxd));\r\nmsg->status = PTR_ERR(rxd);\r\nreturn;\r\n}\r\ntxd = ep93xx_spi_dma_prepare(espi, DMA_MEM_TO_DEV);\r\nif (IS_ERR(txd)) {\r\nep93xx_spi_dma_finish(espi, DMA_DEV_TO_MEM);\r\ndev_err(&espi->pdev->dev, "DMA TX failed: %ld\n", PTR_ERR(txd));\r\nmsg->status = PTR_ERR(txd);\r\nreturn;\r\n}\r\nrxd->callback = ep93xx_spi_dma_callback;\r\nrxd->callback_param = &espi->wait;\r\ndmaengine_submit(rxd);\r\ndmaengine_submit(txd);\r\ndma_async_issue_pending(espi->dma_rx);\r\ndma_async_issue_pending(espi->dma_tx);\r\nwait_for_completion(&espi->wait);\r\nep93xx_spi_dma_finish(espi, DMA_MEM_TO_DEV);\r\nep93xx_spi_dma_finish(espi, DMA_DEV_TO_MEM);\r\n}\r\nstatic void ep93xx_spi_process_transfer(struct ep93xx_spi *espi,\r\nstruct spi_message *msg,\r\nstruct spi_transfer *t)\r\n{\r\nint err;\r\nmsg->state = t;\r\nerr = ep93xx_spi_chip_setup(espi, msg->spi, t);\r\nif (err) {\r\ndev_err(&espi->pdev->dev,\r\n"failed to setup chip for transfer\n");\r\nmsg->status = err;\r\nreturn;\r\n}\r\nespi->rx = 0;\r\nespi->tx = 0;\r\nif (espi->dma_rx && t->len > SPI_FIFO_SIZE)\r\nep93xx_spi_dma_transfer(espi);\r\nelse\r\nep93xx_spi_pio_transfer(espi);\r\nif (msg->status)\r\nreturn;\r\nmsg->actual_length += t->len;\r\nif (t->delay_usecs) {\r\nset_current_state(TASK_UNINTERRUPTIBLE);\r\nschedule_timeout(usecs_to_jiffies(t->delay_usecs));\r\n}\r\nif (t->cs_change) {\r\nif (!list_is_last(&t->transfer_list, &msg->transfers)) {\r\nep93xx_spi_cs_control(msg->spi, false);\r\ncond_resched();\r\nep93xx_spi_cs_control(msg->spi, true);\r\n}\r\n}\r\n}\r\nstatic void ep93xx_spi_process_message(struct ep93xx_spi *espi,\r\nstruct spi_message *msg)\r\n{\r\nunsigned long timeout;\r\nstruct spi_transfer *t;\r\nint err;\r\nerr = ep93xx_spi_enable(espi);\r\nif (err) {\r\ndev_err(&espi->pdev->dev, "failed to enable SPI controller\n");\r\nmsg->status = err;\r\nreturn;\r\n}\r\ntimeout = jiffies + msecs_to_jiffies(SPI_TIMEOUT);\r\nwhile (ep93xx_spi_read_u16(espi, SSPSR) & SSPSR_RNE) {\r\nif (time_after(jiffies, timeout)) {\r\ndev_warn(&espi->pdev->dev,\r\n"timeout while flushing RX FIFO\n");\r\nmsg->status = -ETIMEDOUT;\r\nreturn;\r\n}\r\nep93xx_spi_read_u16(espi, SSPDR);\r\n}\r\nespi->fifo_level = 0;\r\nep93xx_spi_cs_control(msg->spi, true);\r\nlist_for_each_entry(t, &msg->transfers, transfer_list) {\r\nep93xx_spi_process_transfer(espi, msg, t);\r\nif (msg->status)\r\nbreak;\r\n}\r\nep93xx_spi_cs_control(msg->spi, false);\r\nep93xx_spi_disable(espi);\r\n}\r\nstatic int ep93xx_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct ep93xx_spi *espi = spi_master_get_devdata(master);\r\nmsg->state = NULL;\r\nmsg->status = 0;\r\nmsg->actual_length = 0;\r\nespi->current_msg = msg;\r\nep93xx_spi_process_message(espi, msg);\r\nespi->current_msg = NULL;\r\nspi_finalize_current_message(master);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ep93xx_spi_interrupt(int irq, void *dev_id)\r\n{\r\nstruct ep93xx_spi *espi = dev_id;\r\nu8 irq_status = ep93xx_spi_read_u8(espi, SSPIIR);\r\nif (unlikely(irq_status & SSPIIR_RORIS)) {\r\nep93xx_spi_write_u8(espi, SSPICR, 0);\r\ndev_warn(&espi->pdev->dev,\r\n"receive overrun, aborting the message\n");\r\nespi->current_msg->status = -EIO;\r\n} else {\r\nif (ep93xx_spi_read_write(espi)) {\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\nep93xx_spi_disable_interrupts(espi);\r\ncomplete(&espi->wait);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic bool ep93xx_spi_dma_filter(struct dma_chan *chan, void *filter_param)\r\n{\r\nif (ep93xx_dma_chan_is_m2p(chan))\r\nreturn false;\r\nchan->private = filter_param;\r\nreturn true;\r\n}\r\nstatic int ep93xx_spi_setup_dma(struct ep93xx_spi *espi)\r\n{\r\ndma_cap_mask_t mask;\r\nint ret;\r\nespi->zeropage = (void *)get_zeroed_page(GFP_KERNEL);\r\nif (!espi->zeropage)\r\nreturn -ENOMEM;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nespi->dma_rx_data.port = EP93XX_DMA_SSP;\r\nespi->dma_rx_data.direction = DMA_DEV_TO_MEM;\r\nespi->dma_rx_data.name = "ep93xx-spi-rx";\r\nespi->dma_rx = dma_request_channel(mask, ep93xx_spi_dma_filter,\r\n&espi->dma_rx_data);\r\nif (!espi->dma_rx) {\r\nret = -ENODEV;\r\ngoto fail_free_page;\r\n}\r\nespi->dma_tx_data.port = EP93XX_DMA_SSP;\r\nespi->dma_tx_data.direction = DMA_MEM_TO_DEV;\r\nespi->dma_tx_data.name = "ep93xx-spi-tx";\r\nespi->dma_tx = dma_request_channel(mask, ep93xx_spi_dma_filter,\r\n&espi->dma_tx_data);\r\nif (!espi->dma_tx) {\r\nret = -ENODEV;\r\ngoto fail_release_rx;\r\n}\r\nreturn 0;\r\nfail_release_rx:\r\ndma_release_channel(espi->dma_rx);\r\nespi->dma_rx = NULL;\r\nfail_free_page:\r\nfree_page((unsigned long)espi->zeropage);\r\nreturn ret;\r\n}\r\nstatic void ep93xx_spi_release_dma(struct ep93xx_spi *espi)\r\n{\r\nif (espi->dma_rx) {\r\ndma_release_channel(espi->dma_rx);\r\nsg_free_table(&espi->rx_sgt);\r\n}\r\nif (espi->dma_tx) {\r\ndma_release_channel(espi->dma_tx);\r\nsg_free_table(&espi->tx_sgt);\r\n}\r\nif (espi->zeropage)\r\nfree_page((unsigned long)espi->zeropage);\r\n}\r\nstatic int ep93xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct ep93xx_spi_info *info;\r\nstruct ep93xx_spi *espi;\r\nstruct resource *res;\r\nint irq;\r\nint error;\r\nint i;\r\ninfo = dev_get_platdata(&pdev->dev);\r\nif (!info) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -EINVAL;\r\n}\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq resources\n");\r\nreturn -EBUSY;\r\n}\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(&pdev->dev, "unable to get iomem resource\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*espi));\r\nif (!master)\r\nreturn -ENOMEM;\r\nmaster->transfer_one_message = ep93xx_spi_transfer_one_message;\r\nmaster->bus_num = pdev->id;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH;\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\r\nmaster->num_chipselect = info->num_chipselect;\r\nmaster->cs_gpios = devm_kzalloc(&master->dev,\r\nsizeof(int) * master->num_chipselect,\r\nGFP_KERNEL);\r\nif (!master->cs_gpios) {\r\nerror = -ENOMEM;\r\ngoto fail_release_master;\r\n}\r\nfor (i = 0; i < master->num_chipselect; i++) {\r\nmaster->cs_gpios[i] = info->chipselect[i];\r\nif (!gpio_is_valid(master->cs_gpios[i]))\r\ncontinue;\r\nerror = devm_gpio_request_one(&pdev->dev, master->cs_gpios[i],\r\nGPIOF_OUT_INIT_HIGH,\r\n"ep93xx-spi");\r\nif (error) {\r\ndev_err(&pdev->dev, "could not request cs gpio %d\n",\r\nmaster->cs_gpios[i]);\r\ngoto fail_release_master;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, master);\r\nespi = spi_master_get_devdata(master);\r\nespi->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(espi->clk)) {\r\ndev_err(&pdev->dev, "unable to get spi clock\n");\r\nerror = PTR_ERR(espi->clk);\r\ngoto fail_release_master;\r\n}\r\ninit_completion(&espi->wait);\r\nmaster->max_speed_hz = clk_get_rate(espi->clk) / 2;\r\nmaster->min_speed_hz = clk_get_rate(espi->clk) / (254 * 256);\r\nespi->pdev = pdev;\r\nespi->sspdr_phys = res->start + SSPDR;\r\nespi->regs_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(espi->regs_base)) {\r\nerror = PTR_ERR(espi->regs_base);\r\ngoto fail_release_master;\r\n}\r\nerror = devm_request_irq(&pdev->dev, irq, ep93xx_spi_interrupt,\r\n0, "ep93xx-spi", espi);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to request irq\n");\r\ngoto fail_release_master;\r\n}\r\nif (info->use_dma && ep93xx_spi_setup_dma(espi))\r\ndev_warn(&pdev->dev, "DMA setup failed. Falling back to PIO\n");\r\nep93xx_spi_write_u8(espi, SSPCR1, 0);\r\nerror = devm_spi_register_master(&pdev->dev, master);\r\nif (error) {\r\ndev_err(&pdev->dev, "failed to register SPI master\n");\r\ngoto fail_free_dma;\r\n}\r\ndev_info(&pdev->dev, "EP93xx SPI Controller at 0x%08lx irq %d\n",\r\n(unsigned long)res->start, irq);\r\nreturn 0;\r\nfail_free_dma:\r\nep93xx_spi_release_dma(espi);\r\nfail_release_master:\r\nspi_master_put(master);\r\nreturn error;\r\n}\r\nstatic int ep93xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master = platform_get_drvdata(pdev);\r\nstruct ep93xx_spi *espi = spi_master_get_devdata(master);\r\nep93xx_spi_release_dma(espi);\r\nreturn 0;\r\n}
