static int hash_alloc_result(struct sock *sk, struct hash_ctx *ctx)\r\n{\r\nunsigned ds;\r\nif (ctx->result)\r\nreturn 0;\r\nds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\r\nctx->result = sock_kmalloc(sk, ds, GFP_KERNEL);\r\nif (!ctx->result)\r\nreturn -ENOMEM;\r\nmemset(ctx->result, 0, ds);\r\nreturn 0;\r\n}\r\nstatic void hash_free_result(struct sock *sk, struct hash_ctx *ctx)\r\n{\r\nunsigned ds;\r\nif (!ctx->result)\r\nreturn;\r\nds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\r\nsock_kzfree_s(sk, ctx->result, ds);\r\nctx->result = NULL;\r\n}\r\nstatic int hash_sendmsg(struct socket *sock, struct msghdr *msg,\r\nsize_t ignored)\r\n{\r\nint limit = ALG_MAX_PAGES * PAGE_SIZE;\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nlong copied = 0;\r\nint err;\r\nif (limit > sk->sk_sndbuf)\r\nlimit = sk->sk_sndbuf;\r\nlock_sock(sk);\r\nif (!ctx->more) {\r\nif ((msg->msg_flags & MSG_MORE))\r\nhash_free_result(sk, ctx);\r\nerr = af_alg_wait_for_completion(crypto_ahash_init(&ctx->req),\r\n&ctx->completion);\r\nif (err)\r\ngoto unlock;\r\n}\r\nctx->more = 0;\r\nwhile (msg_data_left(msg)) {\r\nint len = msg_data_left(msg);\r\nif (len > limit)\r\nlen = limit;\r\nlen = af_alg_make_sg(&ctx->sgl, &msg->msg_iter, len);\r\nif (len < 0) {\r\nerr = copied ? 0 : len;\r\ngoto unlock;\r\n}\r\nahash_request_set_crypt(&ctx->req, ctx->sgl.sg, NULL, len);\r\nerr = af_alg_wait_for_completion(crypto_ahash_update(&ctx->req),\r\n&ctx->completion);\r\naf_alg_free_sg(&ctx->sgl);\r\nif (err)\r\ngoto unlock;\r\ncopied += len;\r\niov_iter_advance(&msg->msg_iter, len);\r\n}\r\nerr = 0;\r\nctx->more = msg->msg_flags & MSG_MORE;\r\nif (!ctx->more) {\r\nerr = hash_alloc_result(sk, ctx);\r\nif (err)\r\ngoto unlock;\r\nahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\r\nerr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\r\n&ctx->completion);\r\n}\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err ?: copied;\r\n}\r\nstatic ssize_t hash_sendpage(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nint err;\r\nif (flags & MSG_SENDPAGE_NOTLAST)\r\nflags |= MSG_MORE;\r\nlock_sock(sk);\r\nsg_init_table(ctx->sgl.sg, 1);\r\nsg_set_page(ctx->sgl.sg, page, size, offset);\r\nif (!(flags & MSG_MORE)) {\r\nerr = hash_alloc_result(sk, ctx);\r\nif (err)\r\ngoto unlock;\r\n} else if (!ctx->more)\r\nhash_free_result(sk, ctx);\r\nahash_request_set_crypt(&ctx->req, ctx->sgl.sg, ctx->result, size);\r\nif (!(flags & MSG_MORE)) {\r\nif (ctx->more)\r\nerr = crypto_ahash_finup(&ctx->req);\r\nelse\r\nerr = crypto_ahash_digest(&ctx->req);\r\n} else {\r\nif (!ctx->more) {\r\nerr = crypto_ahash_init(&ctx->req);\r\nerr = af_alg_wait_for_completion(err, &ctx->completion);\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = crypto_ahash_update(&ctx->req);\r\n}\r\nerr = af_alg_wait_for_completion(err, &ctx->completion);\r\nif (err)\r\ngoto unlock;\r\nctx->more = flags & MSG_MORE;\r\nunlock:\r\nrelease_sock(sk);\r\nreturn err ?: size;\r\n}\r\nstatic int hash_recvmsg(struct socket *sock, struct msghdr *msg, size_t len,\r\nint flags)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nunsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));\r\nbool result;\r\nint err;\r\nif (len > ds)\r\nlen = ds;\r\nelse if (len < ds)\r\nmsg->msg_flags |= MSG_TRUNC;\r\nlock_sock(sk);\r\nresult = ctx->result;\r\nerr = hash_alloc_result(sk, ctx);\r\nif (err)\r\ngoto unlock;\r\nahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);\r\nif (!result && !ctx->more) {\r\nerr = af_alg_wait_for_completion(\r\ncrypto_ahash_init(&ctx->req),\r\n&ctx->completion);\r\nif (err)\r\ngoto unlock;\r\n}\r\nif (!result || ctx->more) {\r\nctx->more = 0;\r\nerr = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),\r\n&ctx->completion);\r\nif (err)\r\ngoto unlock;\r\n}\r\nerr = memcpy_to_msg(msg, ctx->result, len);\r\nunlock:\r\nhash_free_result(sk, ctx);\r\nrelease_sock(sk);\r\nreturn err ?: len;\r\n}\r\nstatic int hash_accept(struct socket *sock, struct socket *newsock, int flags,\r\nbool kern)\r\n{\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nstruct ahash_request *req = &ctx->req;\r\nchar state[crypto_ahash_statesize(crypto_ahash_reqtfm(req)) ? : 1];\r\nstruct sock *sk2;\r\nstruct alg_sock *ask2;\r\nstruct hash_ctx *ctx2;\r\nbool more;\r\nint err;\r\nlock_sock(sk);\r\nmore = ctx->more;\r\nerr = more ? crypto_ahash_export(req, state) : 0;\r\nrelease_sock(sk);\r\nif (err)\r\nreturn err;\r\nerr = af_alg_accept(ask->parent, newsock, kern);\r\nif (err)\r\nreturn err;\r\nsk2 = newsock->sk;\r\nask2 = alg_sk(sk2);\r\nctx2 = ask2->private;\r\nctx2->more = more;\r\nif (!more)\r\nreturn err;\r\nerr = crypto_ahash_import(&ctx2->req, state);\r\nif (err) {\r\nsock_orphan(sk2);\r\nsock_put(sk2);\r\n}\r\nreturn err;\r\n}\r\nstatic int hash_check_key(struct socket *sock)\r\n{\r\nint err = 0;\r\nstruct sock *psk;\r\nstruct alg_sock *pask;\r\nstruct algif_hash_tfm *tfm;\r\nstruct sock *sk = sock->sk;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nlock_sock(sk);\r\nif (ask->refcnt)\r\ngoto unlock_child;\r\npsk = ask->parent;\r\npask = alg_sk(ask->parent);\r\ntfm = pask->private;\r\nerr = -ENOKEY;\r\nlock_sock_nested(psk, SINGLE_DEPTH_NESTING);\r\nif (!tfm->has_key)\r\ngoto unlock;\r\nif (!pask->refcnt++)\r\nsock_hold(psk);\r\nask->refcnt = 1;\r\nsock_put(psk);\r\nerr = 0;\r\nunlock:\r\nrelease_sock(psk);\r\nunlock_child:\r\nrelease_sock(sk);\r\nreturn err;\r\n}\r\nstatic int hash_sendmsg_nokey(struct socket *sock, struct msghdr *msg,\r\nsize_t size)\r\n{\r\nint err;\r\nerr = hash_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn hash_sendmsg(sock, msg, size);\r\n}\r\nstatic ssize_t hash_sendpage_nokey(struct socket *sock, struct page *page,\r\nint offset, size_t size, int flags)\r\n{\r\nint err;\r\nerr = hash_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn hash_sendpage(sock, page, offset, size, flags);\r\n}\r\nstatic int hash_recvmsg_nokey(struct socket *sock, struct msghdr *msg,\r\nsize_t ignored, int flags)\r\n{\r\nint err;\r\nerr = hash_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn hash_recvmsg(sock, msg, ignored, flags);\r\n}\r\nstatic int hash_accept_nokey(struct socket *sock, struct socket *newsock,\r\nint flags, bool kern)\r\n{\r\nint err;\r\nerr = hash_check_key(sock);\r\nif (err)\r\nreturn err;\r\nreturn hash_accept(sock, newsock, flags, kern);\r\n}\r\nstatic void *hash_bind(const char *name, u32 type, u32 mask)\r\n{\r\nstruct algif_hash_tfm *tfm;\r\nstruct crypto_ahash *hash;\r\ntfm = kzalloc(sizeof(*tfm), GFP_KERNEL);\r\nif (!tfm)\r\nreturn ERR_PTR(-ENOMEM);\r\nhash = crypto_alloc_ahash(name, type, mask);\r\nif (IS_ERR(hash)) {\r\nkfree(tfm);\r\nreturn ERR_CAST(hash);\r\n}\r\ntfm->hash = hash;\r\nreturn tfm;\r\n}\r\nstatic void hash_release(void *private)\r\n{\r\nstruct algif_hash_tfm *tfm = private;\r\ncrypto_free_ahash(tfm->hash);\r\nkfree(tfm);\r\n}\r\nstatic int hash_setkey(void *private, const u8 *key, unsigned int keylen)\r\n{\r\nstruct algif_hash_tfm *tfm = private;\r\nint err;\r\nerr = crypto_ahash_setkey(tfm->hash, key, keylen);\r\ntfm->has_key = !err;\r\nreturn err;\r\n}\r\nstatic void hash_sock_destruct(struct sock *sk)\r\n{\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct hash_ctx *ctx = ask->private;\r\nhash_free_result(sk, ctx);\r\nsock_kfree_s(sk, ctx, ctx->len);\r\naf_alg_release_parent(sk);\r\n}\r\nstatic int hash_accept_parent_nokey(void *private, struct sock *sk)\r\n{\r\nstruct hash_ctx *ctx;\r\nstruct alg_sock *ask = alg_sk(sk);\r\nstruct algif_hash_tfm *tfm = private;\r\nstruct crypto_ahash *hash = tfm->hash;\r\nunsigned len = sizeof(*ctx) + crypto_ahash_reqsize(hash);\r\nctx = sock_kmalloc(sk, len, GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nctx->result = NULL;\r\nctx->len = len;\r\nctx->more = 0;\r\naf_alg_init_completion(&ctx->completion);\r\nask->private = ctx;\r\nahash_request_set_tfm(&ctx->req, hash);\r\nahash_request_set_callback(&ctx->req, CRYPTO_TFM_REQ_MAY_BACKLOG,\r\naf_alg_complete, &ctx->completion);\r\nsk->sk_destruct = hash_sock_destruct;\r\nreturn 0;\r\n}\r\nstatic int hash_accept_parent(void *private, struct sock *sk)\r\n{\r\nstruct algif_hash_tfm *tfm = private;\r\nif (!tfm->has_key && crypto_ahash_has_setkey(tfm->hash))\r\nreturn -ENOKEY;\r\nreturn hash_accept_parent_nokey(private, sk);\r\n}\r\nstatic int __init algif_hash_init(void)\r\n{\r\nreturn af_alg_register_type(&algif_type_hash);\r\n}\r\nstatic void __exit algif_hash_exit(void)\r\n{\r\nint err = af_alg_unregister_type(&algif_type_hash);\r\nBUG_ON(err);\r\n}
