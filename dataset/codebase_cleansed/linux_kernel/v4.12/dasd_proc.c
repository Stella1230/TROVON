static int\r\ndasd_devices_show(struct seq_file *m, void *v)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_block *block;\r\nchar *substr;\r\ndevice = dasd_device_from_devindex((unsigned long) v - 1);\r\nif (IS_ERR(device))\r\nreturn 0;\r\nif (device->block)\r\nblock = device->block;\r\nelse {\r\ndasd_put_device(device);\r\nreturn 0;\r\n}\r\nseq_printf(m, "%s", dev_name(&device->cdev->dev));\r\nif (device->discipline != NULL)\r\nseq_printf(m, "(%s)", device->discipline->name);\r\nelse\r\nseq_printf(m, "(none)");\r\nif (block->gdp)\r\nseq_printf(m, " at (%3d:%6d)",\r\nMAJOR(disk_devt(block->gdp)),\r\nMINOR(disk_devt(block->gdp)));\r\nelse\r\nseq_printf(m, " at (???:??????)");\r\nif (block->gdp)\r\nseq_printf(m, " is %-8s", block->gdp->disk_name);\r\nelse\r\nseq_printf(m, " is ????????");\r\nsubstr = (device->features & DASD_FEATURE_READONLY) ? "(ro)" : " ";\r\nseq_printf(m, "%4s: ", substr);\r\nswitch (device->state) {\r\ncase DASD_STATE_NEW:\r\nseq_printf(m, "new");\r\nbreak;\r\ncase DASD_STATE_KNOWN:\r\nseq_printf(m, "detected");\r\nbreak;\r\ncase DASD_STATE_BASIC:\r\nseq_printf(m, "basic");\r\nbreak;\r\ncase DASD_STATE_UNFMT:\r\nseq_printf(m, "unformatted");\r\nbreak;\r\ncase DASD_STATE_READY:\r\ncase DASD_STATE_ONLINE:\r\nseq_printf(m, "active ");\r\nif (dasd_check_blocksize(block->bp_block))\r\nseq_printf(m, "n/f ");\r\nelse\r\nseq_printf(m,\r\n"at blocksize: %d, %lld blocks, %lld MB",\r\nblock->bp_block, block->blocks,\r\n((block->bp_block >> 9) *\r\nblock->blocks) >> 11);\r\nbreak;\r\ndefault:\r\nseq_printf(m, "no stat");\r\nbreak;\r\n}\r\ndasd_put_device(device);\r\nif (dasd_probeonly)\r\nseq_printf(m, "(probeonly)");\r\nseq_printf(m, "\n");\r\nreturn 0;\r\n}\r\nstatic void *dasd_devices_start(struct seq_file *m, loff_t *pos)\r\n{\r\nif (*pos >= dasd_max_devindex)\r\nreturn NULL;\r\nreturn (void *)((unsigned long) *pos + 1);\r\n}\r\nstatic void *dasd_devices_next(struct seq_file *m, void *v, loff_t *pos)\r\n{\r\n++*pos;\r\nreturn dasd_devices_start(m, pos);\r\n}\r\nstatic void dasd_devices_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int dasd_devices_open(struct inode *inode, struct file *file)\r\n{\r\nreturn seq_open(file, &dasd_devices_seq_ops);\r\n}\r\nstatic int dasd_stats_all_block_on(void)\r\n{\r\nint i, rc;\r\nstruct dasd_device *device;\r\nrc = 0;\r\nfor (i = 0; i < dasd_max_devindex; ++i) {\r\ndevice = dasd_device_from_devindex(i);\r\nif (IS_ERR(device))\r\ncontinue;\r\nif (device->block)\r\nrc = dasd_profile_on(&device->block->profile);\r\ndasd_put_device(device);\r\nif (rc)\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic void dasd_stats_all_block_off(void)\r\n{\r\nint i;\r\nstruct dasd_device *device;\r\nfor (i = 0; i < dasd_max_devindex; ++i) {\r\ndevice = dasd_device_from_devindex(i);\r\nif (IS_ERR(device))\r\ncontinue;\r\nif (device->block)\r\ndasd_profile_off(&device->block->profile);\r\ndasd_put_device(device);\r\n}\r\n}\r\nstatic void dasd_stats_all_block_reset(void)\r\n{\r\nint i;\r\nstruct dasd_device *device;\r\nfor (i = 0; i < dasd_max_devindex; ++i) {\r\ndevice = dasd_device_from_devindex(i);\r\nif (IS_ERR(device))\r\ncontinue;\r\nif (device->block)\r\ndasd_profile_reset(&device->block->profile);\r\ndasd_put_device(device);\r\n}\r\n}\r\nstatic void dasd_statistics_array(struct seq_file *m, unsigned int *array, int factor)\r\n{\r\nint i;\r\nfor (i = 0; i < 32; i++) {\r\nseq_printf(m, "%7d ", array[i] / factor);\r\nif (i == 15)\r\nseq_putc(m, '\n');\r\n}\r\nseq_putc(m, '\n');\r\n}\r\nstatic int dasd_stats_proc_show(struct seq_file *m, void *v)\r\n{\r\n#ifdef CONFIG_DASD_PROFILE\r\nstruct dasd_profile_info *prof;\r\nint factor;\r\nspin_lock_bh(&dasd_global_profile.lock);\r\nprof = dasd_global_profile.data;\r\nif (!prof) {\r\nspin_unlock_bh(&dasd_global_profile.lock);\r\nseq_printf(m, "Statistics are off - they might be "\r\n"switched on using 'echo set on > "\r\n"/proc/dasd/statistics'\n");\r\nreturn 0;\r\n}\r\nfor (factor = 1; (prof->dasd_io_reqs / factor) > 9999999;\r\nfactor *= 10);\r\nseq_printf(m, "%d dasd I/O requests\n", prof->dasd_io_reqs);\r\nseq_printf(m, "with %u sectors(512B each)\n",\r\nprof->dasd_io_sects);\r\nseq_printf(m, "Scale Factor is %d\n", factor);\r\nseq_printf(m,\r\n" __<4 ___8 __16 __32 __64 _128 "\r\n" _256 _512 __1k __2k __4k __8k "\r\n" _16k _32k _64k 128k\n");\r\nseq_printf(m,\r\n" _256 _512 __1M __2M __4M __8M "\r\n" _16M _32M _64M 128M 256M 512M "\r\n" __1G __2G __4G " " _>4G\n");\r\nseq_printf(m, "Histogram of sizes (512B secs)\n");\r\ndasd_statistics_array(m, prof->dasd_io_secs, factor);\r\nseq_printf(m, "Histogram of I/O times (microseconds)\n");\r\ndasd_statistics_array(m, prof->dasd_io_times, factor);\r\nseq_printf(m, "Histogram of I/O times per sector\n");\r\ndasd_statistics_array(m, prof->dasd_io_timps, factor);\r\nseq_printf(m, "Histogram of I/O time till ssch\n");\r\ndasd_statistics_array(m, prof->dasd_io_time1, factor);\r\nseq_printf(m, "Histogram of I/O time between ssch and irq\n");\r\ndasd_statistics_array(m, prof->dasd_io_time2, factor);\r\nseq_printf(m, "Histogram of I/O time between ssch "\r\n"and irq per sector\n");\r\ndasd_statistics_array(m, prof->dasd_io_time2ps, factor);\r\nseq_printf(m, "Histogram of I/O time between irq and end\n");\r\ndasd_statistics_array(m, prof->dasd_io_time3, factor);\r\nseq_printf(m, "# of req in chanq at enqueuing (1..32) \n");\r\ndasd_statistics_array(m, prof->dasd_io_nr_req, factor);\r\nspin_unlock_bh(&dasd_global_profile.lock);\r\n#else\r\nseq_printf(m, "Statistics are not activated in this kernel\n");\r\n#endif\r\nreturn 0;\r\n}\r\nstatic int dasd_stats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, dasd_stats_proc_show, NULL);\r\n}\r\nstatic ssize_t dasd_stats_proc_write(struct file *file,\r\nconst char __user *user_buf, size_t user_len, loff_t *pos)\r\n{\r\n#ifdef CONFIG_DASD_PROFILE\r\nchar *buffer, *str;\r\nint rc;\r\nif (user_len > 65536)\r\nuser_len = 65536;\r\nbuffer = dasd_get_user_string(user_buf, user_len);\r\nif (IS_ERR(buffer))\r\nreturn PTR_ERR(buffer);\r\nstr = skip_spaces(buffer);\r\nif (strncmp(str, "set", 3) == 0 && isspace(str[3])) {\r\nstr = skip_spaces(str + 4);\r\nif (strcmp(str, "on") == 0) {\r\nrc = dasd_stats_all_block_on();\r\nif (rc) {\r\ndasd_stats_all_block_off();\r\ngoto out_error;\r\n}\r\nrc = dasd_profile_on(&dasd_global_profile);\r\nif (rc) {\r\ndasd_stats_all_block_off();\r\ngoto out_error;\r\n}\r\ndasd_profile_reset(&dasd_global_profile);\r\ndasd_global_profile_level = DASD_PROFILE_ON;\r\npr_info("The statistics feature has been switched "\r\n"on\n");\r\n} else if (strcmp(str, "off") == 0) {\r\ndasd_global_profile_level = DASD_PROFILE_OFF;\r\ndasd_profile_off(&dasd_global_profile);\r\ndasd_stats_all_block_off();\r\npr_info("The statistics feature has been switched "\r\n"off\n");\r\n} else\r\ngoto out_parse_error;\r\n} else if (strncmp(str, "reset", 5) == 0) {\r\ndasd_profile_reset(&dasd_global_profile);\r\ndasd_stats_all_block_reset();\r\npr_info("The statistics have been reset\n");\r\n} else\r\ngoto out_parse_error;\r\nvfree(buffer);\r\nreturn user_len;\r\nout_parse_error:\r\nrc = -EINVAL;\r\npr_warn("%s is not a supported value for /proc/dasd/statistics\n", str);\r\nout_error:\r\nvfree(buffer);\r\nreturn rc;\r\n#else\r\npr_warn("/proc/dasd/statistics: is not activated in this kernel\n");\r\nreturn user_len;\r\n#endif\r\n}\r\nint\r\ndasd_proc_init(void)\r\n{\r\ndasd_proc_root_entry = proc_mkdir("dasd", NULL);\r\nif (!dasd_proc_root_entry)\r\ngoto out_nodasd;\r\ndasd_devices_entry = proc_create("devices",\r\nS_IFREG | S_IRUGO | S_IWUSR,\r\ndasd_proc_root_entry,\r\n&dasd_devices_file_ops);\r\nif (!dasd_devices_entry)\r\ngoto out_nodevices;\r\ndasd_statistics_entry = proc_create("statistics",\r\nS_IFREG | S_IRUGO | S_IWUSR,\r\ndasd_proc_root_entry,\r\n&dasd_stats_proc_fops);\r\nif (!dasd_statistics_entry)\r\ngoto out_nostatistics;\r\nreturn 0;\r\nout_nostatistics:\r\nremove_proc_entry("devices", dasd_proc_root_entry);\r\nout_nodevices:\r\nremove_proc_entry("dasd", NULL);\r\nout_nodasd:\r\nreturn -ENOENT;\r\n}\r\nvoid\r\ndasd_proc_exit(void)\r\n{\r\nremove_proc_entry("devices", dasd_proc_root_entry);\r\nremove_proc_entry("statistics", dasd_proc_root_entry);\r\nremove_proc_entry("dasd", NULL);\r\n}
