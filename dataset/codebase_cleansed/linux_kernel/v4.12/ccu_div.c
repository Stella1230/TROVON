static unsigned long ccu_div_round_rate(struct ccu_mux_internal *mux,\r\nunsigned long parent_rate,\r\nunsigned long rate,\r\nvoid *data)\r\n{\r\nstruct ccu_div *cd = data;\r\nunsigned long val;\r\nval = divider_get_val(rate, parent_rate, cd->div.table, cd->div.width,\r\ncd->div.flags);\r\nreturn divider_recalc_rate(&cd->common.hw, parent_rate, val,\r\ncd->div.table, cd->div.flags);\r\n}\r\nstatic void ccu_div_disable(struct clk_hw *hw)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nreturn ccu_gate_helper_disable(&cd->common, cd->enable);\r\n}\r\nstatic int ccu_div_enable(struct clk_hw *hw)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nreturn ccu_gate_helper_enable(&cd->common, cd->enable);\r\n}\r\nstatic int ccu_div_is_enabled(struct clk_hw *hw)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nreturn ccu_gate_helper_is_enabled(&cd->common, cd->enable);\r\n}\r\nstatic unsigned long ccu_div_recalc_rate(struct clk_hw *hw,\r\nunsigned long parent_rate)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nunsigned long val;\r\nu32 reg;\r\nreg = readl(cd->common.base + cd->common.reg);\r\nval = reg >> cd->div.shift;\r\nval &= (1 << cd->div.width) - 1;\r\nccu_mux_helper_adjust_parent_for_prediv(&cd->common, &cd->mux, -1,\r\n&parent_rate);\r\nreturn divider_recalc_rate(hw, parent_rate, val, cd->div.table,\r\ncd->div.flags);\r\n}\r\nstatic int ccu_div_determine_rate(struct clk_hw *hw,\r\nstruct clk_rate_request *req)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nif (clk_hw_get_num_parents(hw) == 1) {\r\nreq->rate = divider_round_rate(hw, req->rate,\r\n&req->best_parent_rate,\r\ncd->div.table,\r\ncd->div.width,\r\ncd->div.flags);\r\nreq->best_parent_hw = clk_hw_get_parent(hw);\r\nreturn 0;\r\n}\r\nreturn ccu_mux_helper_determine_rate(&cd->common, &cd->mux,\r\nreq, ccu_div_round_rate, cd);\r\n}\r\nstatic int ccu_div_set_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nunsigned long flags;\r\nunsigned long val;\r\nu32 reg;\r\nccu_mux_helper_adjust_parent_for_prediv(&cd->common, &cd->mux, -1,\r\n&parent_rate);\r\nval = divider_get_val(rate, parent_rate, cd->div.table, cd->div.width,\r\ncd->div.flags);\r\nspin_lock_irqsave(cd->common.lock, flags);\r\nreg = readl(cd->common.base + cd->common.reg);\r\nreg &= ~GENMASK(cd->div.width + cd->div.shift - 1, cd->div.shift);\r\nwritel(reg | (val << cd->div.shift),\r\ncd->common.base + cd->common.reg);\r\nspin_unlock_irqrestore(cd->common.lock, flags);\r\nreturn 0;\r\n}\r\nstatic u8 ccu_div_get_parent(struct clk_hw *hw)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nreturn ccu_mux_helper_get_parent(&cd->common, &cd->mux);\r\n}\r\nstatic int ccu_div_set_parent(struct clk_hw *hw, u8 index)\r\n{\r\nstruct ccu_div *cd = hw_to_ccu_div(hw);\r\nreturn ccu_mux_helper_set_parent(&cd->common, &cd->mux, index);\r\n}
