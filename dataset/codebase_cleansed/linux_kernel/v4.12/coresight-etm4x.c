static void etm4_os_unlock(struct etmv4_drvdata *drvdata)\r\n{\r\nwritel_relaxed(0x0, drvdata->base + TRCOSLAR);\r\ndrvdata->os_unlock = true;\r\nisb();\r\n}\r\nstatic bool etm4_arch_supported(u8 arch)\r\n{\r\nswitch (arch) {\r\ncase ETM_ARCH_V4:\r\nbreak;\r\ndefault:\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int etm4_cpu_id(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn drvdata->cpu;\r\n}\r\nstatic int etm4_trace_id(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nreturn drvdata->trcid;\r\n}\r\nstatic void etm4_enable_hw(void *info)\r\n{\r\nint i;\r\nstruct etmv4_drvdata *drvdata = info;\r\nstruct etmv4_config *config = &drvdata->config;\r\nCS_UNLOCK(drvdata->base);\r\netm4_os_unlock(drvdata);\r\nwritel_relaxed(0, drvdata->base + TRCPRGCTLR);\r\nif (coresight_timeout(drvdata->base, TRCSTATR, TRCSTATR_IDLE_BIT, 1))\r\ndev_err(drvdata->dev,\r\n"timeout while waiting for Idle Trace Status\n");\r\nwritel_relaxed(config->pe_sel, drvdata->base + TRCPROCSELR);\r\nwritel_relaxed(config->cfg, drvdata->base + TRCCONFIGR);\r\nwritel_relaxed(0x0, drvdata->base + TRCAUXCTLR);\r\nwritel_relaxed(config->eventctrl0, drvdata->base + TRCEVENTCTL0R);\r\nwritel_relaxed(config->eventctrl1, drvdata->base + TRCEVENTCTL1R);\r\nwritel_relaxed(config->stall_ctrl, drvdata->base + TRCSTALLCTLR);\r\nwritel_relaxed(config->ts_ctrl, drvdata->base + TRCTSCTLR);\r\nwritel_relaxed(config->syncfreq, drvdata->base + TRCSYNCPR);\r\nwritel_relaxed(config->ccctlr, drvdata->base + TRCCCCTLR);\r\nwritel_relaxed(config->bb_ctrl, drvdata->base + TRCBBCTLR);\r\nwritel_relaxed(drvdata->trcid, drvdata->base + TRCTRACEIDR);\r\nwritel_relaxed(config->vinst_ctrl, drvdata->base + TRCVICTLR);\r\nwritel_relaxed(config->viiectlr, drvdata->base + TRCVIIECTLR);\r\nwritel_relaxed(config->vissctlr,\r\ndrvdata->base + TRCVISSCTLR);\r\nwritel_relaxed(config->vipcssctlr,\r\ndrvdata->base + TRCVIPCSSCTLR);\r\nfor (i = 0; i < drvdata->nrseqstate - 1; i++)\r\nwritel_relaxed(config->seq_ctrl[i],\r\ndrvdata->base + TRCSEQEVRn(i));\r\nwritel_relaxed(config->seq_rst, drvdata->base + TRCSEQRSTEVR);\r\nwritel_relaxed(config->seq_state, drvdata->base + TRCSEQSTR);\r\nwritel_relaxed(config->ext_inp, drvdata->base + TRCEXTINSELR);\r\nfor (i = 0; i < drvdata->nr_cntr; i++) {\r\nwritel_relaxed(config->cntrldvr[i],\r\ndrvdata->base + TRCCNTRLDVRn(i));\r\nwritel_relaxed(config->cntr_ctrl[i],\r\ndrvdata->base + TRCCNTCTLRn(i));\r\nwritel_relaxed(config->cntr_val[i],\r\ndrvdata->base + TRCCNTVRn(i));\r\n}\r\nfor (i = 0; i < drvdata->nr_resource * 2; i++)\r\nwritel_relaxed(config->res_ctrl[i],\r\ndrvdata->base + TRCRSCTLRn(i));\r\nfor (i = 0; i < drvdata->nr_ss_cmp; i++) {\r\nwritel_relaxed(config->ss_ctrl[i],\r\ndrvdata->base + TRCSSCCRn(i));\r\nwritel_relaxed(config->ss_status[i],\r\ndrvdata->base + TRCSSCSRn(i));\r\nwritel_relaxed(config->ss_pe_cmp[i],\r\ndrvdata->base + TRCSSPCICRn(i));\r\n}\r\nfor (i = 0; i < drvdata->nr_addr_cmp; i++) {\r\nwriteq_relaxed(config->addr_val[i],\r\ndrvdata->base + TRCACVRn(i));\r\nwriteq_relaxed(config->addr_acc[i],\r\ndrvdata->base + TRCACATRn(i));\r\n}\r\nfor (i = 0; i < drvdata->numcidc; i++)\r\nwriteq_relaxed(config->ctxid_pid[i],\r\ndrvdata->base + TRCCIDCVRn(i));\r\nwritel_relaxed(config->ctxid_mask0, drvdata->base + TRCCIDCCTLR0);\r\nwritel_relaxed(config->ctxid_mask1, drvdata->base + TRCCIDCCTLR1);\r\nfor (i = 0; i < drvdata->numvmidc; i++)\r\nwriteq_relaxed(config->vmid_val[i],\r\ndrvdata->base + TRCVMIDCVRn(i));\r\nwritel_relaxed(config->vmid_mask0, drvdata->base + TRCVMIDCCTLR0);\r\nwritel_relaxed(config->vmid_mask1, drvdata->base + TRCVMIDCCTLR1);\r\nwritel_relaxed(readl_relaxed(drvdata->base + TRCPDCR) | TRCPDCR_PU,\r\ndrvdata->base + TRCPDCR);\r\nwritel_relaxed(1, drvdata->base + TRCPRGCTLR);\r\nif (coresight_timeout(drvdata->base, TRCSTATR, TRCSTATR_IDLE_BIT, 0))\r\ndev_err(drvdata->dev,\r\n"timeout while waiting for Idle Trace Status\n");\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d enable smp call done\n", drvdata->cpu);\r\n}\r\nstatic int etm4_parse_event_config(struct etmv4_drvdata *drvdata,\r\nstruct perf_event *event)\r\n{\r\nint ret = 0;\r\nstruct etmv4_config *config = &drvdata->config;\r\nstruct perf_event_attr *attr = &event->attr;\r\nif (!attr) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nmemset(config, 0, sizeof(struct etmv4_config));\r\nif (attr->exclude_kernel)\r\nconfig->mode = ETM_MODE_EXCL_KERN;\r\nif (attr->exclude_user)\r\nconfig->mode = ETM_MODE_EXCL_USER;\r\netm4_set_default_config(config);\r\nret = etm4_set_event_filters(drvdata, event);\r\nif (ret)\r\ngoto out;\r\nif (attr->config & BIT(ETM_OPT_CYCACC)) {\r\nconfig->cfg |= BIT(4);\r\nconfig->ccctlr = ETM_CYC_THRESHOLD_DEFAULT;\r\n}\r\nif (attr->config & BIT(ETM_OPT_TS))\r\nconfig->cfg |= BIT(11);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int etm4_enable_perf(struct coresight_device *csdev,\r\nstruct perf_event *event)\r\n{\r\nint ret = 0;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id())) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = etm4_parse_event_config(drvdata, event);\r\nif (ret)\r\ngoto out;\r\netm4_enable_hw(drvdata);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int etm4_enable_sysfs(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nint ret;\r\nspin_lock(&drvdata->spinlock);\r\nret = smp_call_function_single(drvdata->cpu,\r\netm4_enable_hw, drvdata, 1);\r\nif (ret)\r\ngoto err;\r\ndrvdata->sticky_enable = true;\r\nspin_unlock(&drvdata->spinlock);\r\ndev_info(drvdata->dev, "ETM tracing enabled\n");\r\nreturn 0;\r\nerr:\r\nspin_unlock(&drvdata->spinlock);\r\nreturn ret;\r\n}\r\nstatic int etm4_enable(struct coresight_device *csdev,\r\nstruct perf_event *event, u32 mode)\r\n{\r\nint ret;\r\nu32 val;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nval = local_cmpxchg(&drvdata->mode, CS_MODE_DISABLED, mode);\r\nif (val)\r\nreturn -EBUSY;\r\nswitch (mode) {\r\ncase CS_MODE_SYSFS:\r\nret = etm4_enable_sysfs(csdev);\r\nbreak;\r\ncase CS_MODE_PERF:\r\nret = etm4_enable_perf(csdev, event);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nif (ret)\r\nlocal_set(&drvdata->mode, CS_MODE_DISABLED);\r\nreturn ret;\r\n}\r\nstatic void etm4_disable_hw(void *info)\r\n{\r\nu32 control;\r\nstruct etmv4_drvdata *drvdata = info;\r\nCS_UNLOCK(drvdata->base);\r\ncontrol = readl_relaxed(drvdata->base + TRCPDCR);\r\ncontrol &= ~TRCPDCR_PU;\r\nwritel_relaxed(control, drvdata->base + TRCPDCR);\r\ncontrol = readl_relaxed(drvdata->base + TRCPRGCTLR);\r\ncontrol &= ~0x1;\r\nmb();\r\nisb();\r\nwritel_relaxed(control, drvdata->base + TRCPRGCTLR);\r\nCS_LOCK(drvdata->base);\r\ndev_dbg(drvdata->dev, "cpu: %d disable smp call done\n", drvdata->cpu);\r\n}\r\nstatic int etm4_disable_perf(struct coresight_device *csdev,\r\nstruct perf_event *event)\r\n{\r\nu32 control;\r\nstruct etm_filters *filters = event->hw.addr_filters;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nif (WARN_ON_ONCE(drvdata->cpu != smp_processor_id()))\r\nreturn -EINVAL;\r\netm4_disable_hw(drvdata);\r\ncontrol = readl_relaxed(drvdata->base + TRCVICTLR);\r\nfilters->ssstatus = (control & BIT(9));\r\nreturn 0;\r\n}\r\nstatic void etm4_disable_sysfs(struct coresight_device *csdev)\r\n{\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nget_online_cpus();\r\nspin_lock(&drvdata->spinlock);\r\nsmp_call_function_single(drvdata->cpu, etm4_disable_hw, drvdata, 1);\r\nspin_unlock(&drvdata->spinlock);\r\nput_online_cpus();\r\ndev_info(drvdata->dev, "ETM tracing disabled\n");\r\n}\r\nstatic void etm4_disable(struct coresight_device *csdev,\r\nstruct perf_event *event)\r\n{\r\nu32 mode;\r\nstruct etmv4_drvdata *drvdata = dev_get_drvdata(csdev->dev.parent);\r\nmode = local_read(&drvdata->mode);\r\nswitch (mode) {\r\ncase CS_MODE_DISABLED:\r\nbreak;\r\ncase CS_MODE_SYSFS:\r\netm4_disable_sysfs(csdev);\r\nbreak;\r\ncase CS_MODE_PERF:\r\netm4_disable_perf(csdev, event);\r\nbreak;\r\n}\r\nif (mode)\r\nlocal_set(&drvdata->mode, CS_MODE_DISABLED);\r\n}\r\nstatic void etm4_init_arch_data(void *info)\r\n{\r\nu32 etmidr0;\r\nu32 etmidr1;\r\nu32 etmidr2;\r\nu32 etmidr3;\r\nu32 etmidr4;\r\nu32 etmidr5;\r\nstruct etmv4_drvdata *drvdata = info;\r\netm4_os_unlock(drvdata);\r\nCS_UNLOCK(drvdata->base);\r\netmidr0 = readl_relaxed(drvdata->base + TRCIDR0);\r\nif (BMVAL(etmidr0, 1, 1) && BMVAL(etmidr0, 2, 2))\r\ndrvdata->instrp0 = true;\r\nelse\r\ndrvdata->instrp0 = false;\r\nif (BMVAL(etmidr0, 5, 5))\r\ndrvdata->trcbb = true;\r\nelse\r\ndrvdata->trcbb = false;\r\nif (BMVAL(etmidr0, 6, 6))\r\ndrvdata->trccond = true;\r\nelse\r\ndrvdata->trccond = false;\r\nif (BMVAL(etmidr0, 7, 7))\r\ndrvdata->trccci = true;\r\nelse\r\ndrvdata->trccci = false;\r\nif (BMVAL(etmidr0, 9, 9))\r\ndrvdata->retstack = true;\r\nelse\r\ndrvdata->retstack = false;\r\ndrvdata->nr_event = BMVAL(etmidr0, 10, 11);\r\ndrvdata->q_support = BMVAL(etmidr0, 15, 16);\r\ndrvdata->ts_size = BMVAL(etmidr0, 24, 28);\r\netmidr1 = readl_relaxed(drvdata->base + TRCIDR1);\r\ndrvdata->arch = BMVAL(etmidr1, 4, 11);\r\netmidr2 = readl_relaxed(drvdata->base + TRCIDR2);\r\ndrvdata->ctxid_size = BMVAL(etmidr2, 5, 9);\r\ndrvdata->vmid_size = BMVAL(etmidr2, 10, 14);\r\ndrvdata->ccsize = BMVAL(etmidr2, 25, 28);\r\netmidr3 = readl_relaxed(drvdata->base + TRCIDR3);\r\ndrvdata->ccitmin = BMVAL(etmidr3, 0, 11);\r\ndrvdata->s_ex_level = BMVAL(etmidr3, 16, 19);\r\ndrvdata->ns_ex_level = BMVAL(etmidr3, 20, 23);\r\nif (BMVAL(etmidr3, 24, 24))\r\ndrvdata->trc_error = true;\r\nelse\r\ndrvdata->trc_error = false;\r\nif (BMVAL(etmidr3, 25, 25))\r\ndrvdata->syncpr = true;\r\nelse\r\ndrvdata->syncpr = false;\r\nif (BMVAL(etmidr3, 26, 26))\r\ndrvdata->stallctl = true;\r\nelse\r\ndrvdata->stallctl = false;\r\nif (BMVAL(etmidr3, 27, 27))\r\ndrvdata->sysstall = true;\r\nelse\r\ndrvdata->sysstall = false;\r\ndrvdata->nr_pe = BMVAL(etmidr3, 28, 30);\r\nif (BMVAL(etmidr3, 31, 31))\r\ndrvdata->nooverflow = true;\r\nelse\r\ndrvdata->nooverflow = false;\r\netmidr4 = readl_relaxed(drvdata->base + TRCIDR4);\r\ndrvdata->nr_addr_cmp = BMVAL(etmidr4, 0, 3);\r\ndrvdata->nr_pe_cmp = BMVAL(etmidr4, 12, 15);\r\ndrvdata->nr_resource = BMVAL(etmidr4, 16, 19) + 1;\r\ndrvdata->nr_ss_cmp = BMVAL(etmidr4, 20, 23);\r\ndrvdata->numcidc = BMVAL(etmidr4, 24, 27);\r\ndrvdata->numvmidc = BMVAL(etmidr4, 28, 31);\r\netmidr5 = readl_relaxed(drvdata->base + TRCIDR5);\r\ndrvdata->nr_ext_inp = BMVAL(etmidr5, 0, 8);\r\ndrvdata->trcid_size = BMVAL(etmidr5, 16, 21);\r\nif (BMVAL(etmidr5, 22, 22))\r\ndrvdata->atbtrig = true;\r\nelse\r\ndrvdata->atbtrig = false;\r\nif (BMVAL(etmidr5, 23, 23))\r\ndrvdata->lpoverride = true;\r\nelse\r\ndrvdata->lpoverride = false;\r\ndrvdata->nrseqstate = BMVAL(etmidr5, 25, 27);\r\ndrvdata->nr_cntr = BMVAL(etmidr5, 28, 30);\r\nCS_LOCK(drvdata->base);\r\n}\r\nstatic void etm4_set_default_config(struct etmv4_config *config)\r\n{\r\nconfig->eventctrl0 = 0x0;\r\nconfig->eventctrl1 = 0x0;\r\nconfig->stall_ctrl = 0x0;\r\nconfig->syncfreq = 0xC;\r\nconfig->ts_ctrl = 0x0;\r\nconfig->vinst_ctrl |= BIT(0);\r\n}\r\nstatic u64 etm4_get_access_type(struct etmv4_config *config)\r\n{\r\nu64 access_type = 0;\r\naccess_type = ETM_EXLEVEL_NS_HYP;\r\nif (config->mode & ETM_MODE_EXCL_KERN)\r\naccess_type |= ETM_EXLEVEL_NS_OS;\r\nif (config->mode & ETM_MODE_EXCL_USER)\r\naccess_type |= ETM_EXLEVEL_NS_APP;\r\naccess_type |= (ETM_EXLEVEL_S_APP |\r\nETM_EXLEVEL_S_OS |\r\nETM_EXLEVEL_S_HYP);\r\nreturn access_type;\r\n}\r\nstatic void etm4_set_comparator_filter(struct etmv4_config *config,\r\nu64 start, u64 stop, int comparator)\r\n{\r\nu64 access_type = etm4_get_access_type(config);\r\nconfig->addr_val[comparator] = start;\r\nconfig->addr_acc[comparator] = access_type;\r\nconfig->addr_type[comparator] = ETM_ADDR_TYPE_RANGE;\r\nconfig->addr_val[comparator + 1] = stop;\r\nconfig->addr_acc[comparator + 1] = access_type;\r\nconfig->addr_type[comparator + 1] = ETM_ADDR_TYPE_RANGE;\r\nconfig->viiectlr |= BIT(comparator / 2);\r\n}\r\nstatic void etm4_set_start_stop_filter(struct etmv4_config *config,\r\nu64 address, int comparator,\r\nenum etm_addr_type type)\r\n{\r\nint shift;\r\nu64 access_type = etm4_get_access_type(config);\r\nconfig->addr_val[comparator] = address;\r\nconfig->addr_acc[comparator] = access_type;\r\nconfig->addr_type[comparator] = type;\r\nshift = (type == ETM_ADDR_TYPE_START ? 0 : 16);\r\nconfig->vissctlr |= BIT(shift + comparator);\r\n}\r\nstatic void etm4_set_default_filter(struct etmv4_config *config)\r\n{\r\nu64 start, stop;\r\nstart = 0x0;\r\nstop = ~0x0;\r\netm4_set_comparator_filter(config, start, stop,\r\nETM_DEFAULT_ADDR_COMP);\r\nconfig->vinst_ctrl |= BIT(9);\r\nconfig->vissctlr = 0x0;\r\n}\r\nstatic void etm4_set_default(struct etmv4_config *config)\r\n{\r\nif (WARN_ON_ONCE(!config))\r\nreturn;\r\netm4_set_default_config(config);\r\netm4_set_default_filter(config);\r\n}\r\nstatic int etm4_get_next_comparator(struct etmv4_drvdata *drvdata, u32 type)\r\n{\r\nint nr_comparator, index = 0;\r\nstruct etmv4_config *config = &drvdata->config;\r\nnr_comparator = drvdata->nr_addr_cmp * 2;\r\nwhile (index < nr_comparator) {\r\nswitch (type) {\r\ncase ETM_ADDR_TYPE_RANGE:\r\nif (config->addr_type[index] == ETM_ADDR_TYPE_NONE &&\r\nconfig->addr_type[index + 1] == ETM_ADDR_TYPE_NONE)\r\nreturn index;\r\nindex += 2;\r\nbreak;\r\ncase ETM_ADDR_TYPE_START:\r\ncase ETM_ADDR_TYPE_STOP:\r\nif (config->addr_type[index] == ETM_ADDR_TYPE_NONE)\r\nreturn index;\r\nindex += 1;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic int etm4_set_event_filters(struct etmv4_drvdata *drvdata,\r\nstruct perf_event *event)\r\n{\r\nint i, comparator, ret = 0;\r\nu64 address;\r\nstruct etmv4_config *config = &drvdata->config;\r\nstruct etm_filters *filters = event->hw.addr_filters;\r\nif (!filters)\r\ngoto default_filter;\r\nperf_event_addr_filters_sync(event);\r\nif (!filters->nr_filters)\r\ngoto default_filter;\r\nfor (i = 0; i < filters->nr_filters; i++) {\r\nstruct etm_filter *filter = &filters->etm_filter[i];\r\nenum etm_addr_type type = filter->type;\r\ncomparator = etm4_get_next_comparator(drvdata, type);\r\nif (comparator < 0) {\r\nret = comparator;\r\ngoto out;\r\n}\r\nswitch (type) {\r\ncase ETM_ADDR_TYPE_RANGE:\r\netm4_set_comparator_filter(config,\r\nfilter->start_addr,\r\nfilter->stop_addr,\r\ncomparator);\r\nconfig->vinst_ctrl |= BIT(9);\r\nconfig->vissctlr = 0x0;\r\nbreak;\r\ncase ETM_ADDR_TYPE_START:\r\ncase ETM_ADDR_TYPE_STOP:\r\naddress = (type == ETM_ADDR_TYPE_START ?\r\nfilter->start_addr :\r\nfilter->stop_addr);\r\netm4_set_start_stop_filter(config, address,\r\ncomparator, type);\r\nif (filters->ssstatus)\r\nconfig->vinst_ctrl |= BIT(9);\r\nconfig->viiectlr = 0x0;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\n}\r\ngoto out;\r\ndefault_filter:\r\netm4_set_default_filter(config);\r\nout:\r\nreturn ret;\r\n}\r\nvoid etm4_config_trace_mode(struct etmv4_config *config)\r\n{\r\nu32 addr_acc, mode;\r\nmode = config->mode;\r\nmode &= (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER);\r\nWARN_ON_ONCE(mode == (ETM_MODE_EXCL_KERN | ETM_MODE_EXCL_USER));\r\nif (!(mode & ETM_MODE_EXCL_KERN) && !(mode & ETM_MODE_EXCL_USER))\r\nreturn;\r\naddr_acc = config->addr_acc[ETM_DEFAULT_ADDR_COMP];\r\naddr_acc &= ~(ETM_EXLEVEL_NS_APP | ETM_EXLEVEL_NS_OS);\r\nif (mode & ETM_MODE_EXCL_KERN)\r\naddr_acc |= ETM_EXLEVEL_NS_OS;\r\nelse\r\naddr_acc |= ETM_EXLEVEL_NS_APP;\r\nconfig->addr_acc[ETM_DEFAULT_ADDR_COMP] = addr_acc;\r\nconfig->addr_acc[ETM_DEFAULT_ADDR_COMP + 1] = addr_acc;\r\n}\r\nstatic int etm4_online_cpu(unsigned int cpu)\r\n{\r\nif (!etmdrvdata[cpu])\r\nreturn 0;\r\nif (etmdrvdata[cpu]->boot_enable && !etmdrvdata[cpu]->sticky_enable)\r\ncoresight_enable(etmdrvdata[cpu]->csdev);\r\nreturn 0;\r\n}\r\nstatic int etm4_starting_cpu(unsigned int cpu)\r\n{\r\nif (!etmdrvdata[cpu])\r\nreturn 0;\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (!etmdrvdata[cpu]->os_unlock) {\r\netm4_os_unlock(etmdrvdata[cpu]);\r\netmdrvdata[cpu]->os_unlock = true;\r\n}\r\nif (local_read(&etmdrvdata[cpu]->mode))\r\netm4_enable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nreturn 0;\r\n}\r\nstatic int etm4_dying_cpu(unsigned int cpu)\r\n{\r\nif (!etmdrvdata[cpu])\r\nreturn 0;\r\nspin_lock(&etmdrvdata[cpu]->spinlock);\r\nif (local_read(&etmdrvdata[cpu]->mode))\r\netm4_disable_hw(etmdrvdata[cpu]);\r\nspin_unlock(&etmdrvdata[cpu]->spinlock);\r\nreturn 0;\r\n}\r\nstatic void etm4_init_trace_id(struct etmv4_drvdata *drvdata)\r\n{\r\ndrvdata->trcid = coresight_get_trace_id(drvdata->cpu);\r\n}\r\nstatic int etm4_probe(struct amba_device *adev, const struct amba_id *id)\r\n{\r\nint ret;\r\nvoid __iomem *base;\r\nstruct device *dev = &adev->dev;\r\nstruct coresight_platform_data *pdata = NULL;\r\nstruct etmv4_drvdata *drvdata;\r\nstruct resource *res = &adev->res;\r\nstruct coresight_desc desc = { 0 };\r\nstruct device_node *np = adev->dev.of_node;\r\ndrvdata = devm_kzalloc(dev, sizeof(*drvdata), GFP_KERNEL);\r\nif (!drvdata)\r\nreturn -ENOMEM;\r\nif (np) {\r\npdata = of_get_coresight_platform_data(dev, np);\r\nif (IS_ERR(pdata))\r\nreturn PTR_ERR(pdata);\r\nadev->dev.platform_data = pdata;\r\n}\r\ndrvdata->dev = &adev->dev;\r\ndev_set_drvdata(dev, drvdata);\r\nbase = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\ndrvdata->base = base;\r\nspin_lock_init(&drvdata->spinlock);\r\ndrvdata->cpu = pdata ? pdata->cpu : 0;\r\nget_online_cpus();\r\netmdrvdata[drvdata->cpu] = drvdata;\r\nif (smp_call_function_single(drvdata->cpu,\r\netm4_init_arch_data, drvdata, 1))\r\ndev_err(dev, "ETM arch init failed\n");\r\nif (!etm4_count++) {\r\ncpuhp_setup_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING,\r\n"arm/coresight4:starting",\r\netm4_starting_cpu, etm4_dying_cpu);\r\nret = cpuhp_setup_state_nocalls(CPUHP_AP_ONLINE_DYN,\r\n"arm/coresight4:online",\r\netm4_online_cpu, NULL);\r\nif (ret < 0)\r\ngoto err_arch_supported;\r\nhp_online = ret;\r\n}\r\nput_online_cpus();\r\nif (etm4_arch_supported(drvdata->arch) == false) {\r\nret = -EINVAL;\r\ngoto err_arch_supported;\r\n}\r\netm4_init_trace_id(drvdata);\r\netm4_set_default(&drvdata->config);\r\ndesc.type = CORESIGHT_DEV_TYPE_SOURCE;\r\ndesc.subtype.source_subtype = CORESIGHT_DEV_SUBTYPE_SOURCE_PROC;\r\ndesc.ops = &etm4_cs_ops;\r\ndesc.pdata = pdata;\r\ndesc.dev = dev;\r\ndesc.groups = coresight_etmv4_groups;\r\ndrvdata->csdev = coresight_register(&desc);\r\nif (IS_ERR(drvdata->csdev)) {\r\nret = PTR_ERR(drvdata->csdev);\r\ngoto err_arch_supported;\r\n}\r\nret = etm_perf_symlink(drvdata->csdev, true);\r\nif (ret) {\r\ncoresight_unregister(drvdata->csdev);\r\ngoto err_arch_supported;\r\n}\r\npm_runtime_put(&adev->dev);\r\ndev_info(dev, "%s initialized\n", (char *)id->data);\r\nif (boot_enable) {\r\ncoresight_enable(drvdata->csdev);\r\ndrvdata->boot_enable = true;\r\n}\r\nreturn 0;\r\nerr_arch_supported:\r\nif (--etm4_count == 0) {\r\ncpuhp_remove_state_nocalls(CPUHP_AP_ARM_CORESIGHT_STARTING);\r\nif (hp_online)\r\ncpuhp_remove_state_nocalls(hp_online);\r\n}\r\nreturn ret;\r\n}
