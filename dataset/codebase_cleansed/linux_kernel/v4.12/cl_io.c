static inline int cl_io_type_is_valid(enum cl_io_type type)\r\n{\r\nreturn CIT_READ <= type && type < CIT_OP_NR;\r\n}\r\nstatic inline int cl_io_is_loopable(const struct cl_io *io)\r\n{\r\nreturn cl_io_type_is_valid(io->ci_type) && io->ci_type != CIT_MISC;\r\n}\r\nint cl_io_is_going(const struct lu_env *env)\r\n{\r\nreturn cl_env_info(env)->clt_current_io != NULL;\r\n}\r\nstatic int cl_io_invariant(const struct cl_io *io)\r\n{\r\nstruct cl_io *up;\r\nup = io->ci_parent;\r\nreturn\r\nergo(io->ci_owned_nr > 0, io->ci_state == CIS_IO_GOING ||\r\n(io->ci_state == CIS_LOCKED && up));\r\n}\r\nvoid cl_io_fini(const struct lu_env *env, struct cl_io *io)\r\n{\r\nstruct cl_io_slice *slice;\r\nstruct cl_thread_info *info;\r\nLINVRNT(cl_io_type_is_valid(io->ci_type));\r\nLINVRNT(cl_io_invariant(io));\r\nwhile (!list_empty(&io->ci_layers)) {\r\nslice = container_of(io->ci_layers.prev, struct cl_io_slice,\r\ncis_linkage);\r\nlist_del_init(&slice->cis_linkage);\r\nif (slice->cis_iop->op[io->ci_type].cio_fini)\r\nslice->cis_iop->op[io->ci_type].cio_fini(env, slice);\r\nslice->cis_io = NULL;\r\n}\r\nio->ci_state = CIS_FINI;\r\ninfo = cl_env_info(env);\r\nif (info->clt_current_io == io)\r\ninfo->clt_current_io = NULL;\r\nswitch (io->ci_type) {\r\ncase CIT_READ:\r\ncase CIT_WRITE:\r\ncase CIT_DATA_VERSION:\r\nbreak;\r\ncase CIT_FAULT:\r\nbreak;\r\ncase CIT_FSYNC:\r\nLASSERT(!io->ci_need_restart);\r\nbreak;\r\ncase CIT_SETATTR:\r\ncase CIT_MISC:\r\nLASSERT(ergo(io->ci_ignore_layout || !io->ci_verify_layout,\r\n!io->ci_need_restart));\r\nbreak;\r\ndefault:\r\nLBUG();\r\n}\r\n}\r\nstatic int cl_io_init0(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, struct cl_object *obj)\r\n{\r\nstruct cl_object *scan;\r\nint result;\r\nLINVRNT(io->ci_state == CIS_ZERO || io->ci_state == CIS_FINI);\r\nLINVRNT(cl_io_type_is_valid(iot));\r\nLINVRNT(cl_io_invariant(io));\r\nio->ci_type = iot;\r\nINIT_LIST_HEAD(&io->ci_lockset.cls_todo);\r\nINIT_LIST_HEAD(&io->ci_lockset.cls_done);\r\nINIT_LIST_HEAD(&io->ci_layers);\r\nresult = 0;\r\ncl_object_for_each(scan, obj) {\r\nif (scan->co_ops->coo_io_init) {\r\nresult = scan->co_ops->coo_io_init(env, scan, io);\r\nif (result != 0)\r\nbreak;\r\n}\r\n}\r\nif (result == 0)\r\nio->ci_state = CIS_INIT;\r\nreturn result;\r\n}\r\nint cl_io_sub_init(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, struct cl_object *obj)\r\n{\r\nstruct cl_thread_info *info = cl_env_info(env);\r\nLASSERT(obj != cl_object_top(obj));\r\nif (!info->clt_current_io)\r\ninfo->clt_current_io = io;\r\nreturn cl_io_init0(env, io, iot, obj);\r\n}\r\nint cl_io_init(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, struct cl_object *obj)\r\n{\r\nstruct cl_thread_info *info = cl_env_info(env);\r\nLASSERT(obj == cl_object_top(obj));\r\nLASSERT(!info->clt_current_io);\r\ninfo->clt_current_io = io;\r\nreturn cl_io_init0(env, io, iot, obj);\r\n}\r\nint cl_io_rw_init(const struct lu_env *env, struct cl_io *io,\r\nenum cl_io_type iot, loff_t pos, size_t count)\r\n{\r\nLINVRNT(iot == CIT_READ || iot == CIT_WRITE);\r\nLINVRNT(io->ci_obj);\r\nLU_OBJECT_HEADER(D_VFSTRACE, env, &io->ci_obj->co_lu,\r\n"io range: %u [%llu, %llu) %u %u\n",\r\niot, (__u64)pos, (__u64)pos + count,\r\nio->u.ci_rw.crw_nonblock, io->u.ci_wr.wr_append);\r\nio->u.ci_rw.crw_pos = pos;\r\nio->u.ci_rw.crw_count = count;\r\nreturn cl_io_init(env, io, iot, io->ci_obj);\r\n}\r\nstatic int cl_lock_descr_sort(const struct cl_lock_descr *d0,\r\nconst struct cl_lock_descr *d1)\r\n{\r\nreturn lu_fid_cmp(lu_object_fid(&d0->cld_obj->co_lu),\r\nlu_object_fid(&d1->cld_obj->co_lu));\r\n}\r\nstatic void cl_io_locks_sort(struct cl_io *io)\r\n{\r\nint done = 0;\r\ndo {\r\nstruct cl_io_lock_link *curr;\r\nstruct cl_io_lock_link *prev;\r\nstruct cl_io_lock_link *temp;\r\ndone = 1;\r\nprev = NULL;\r\nlist_for_each_entry_safe(curr, temp,\r\n&io->ci_lockset.cls_todo,\r\ncill_linkage) {\r\nif (prev) {\r\nswitch (cl_lock_descr_sort(&prev->cill_descr,\r\n&curr->cill_descr)) {\r\ncase 0:\r\ndefault:\r\nLBUG();\r\ncase 1:\r\nlist_move_tail(&curr->cill_linkage,\r\n&prev->cill_linkage);\r\ndone = 0;\r\ncontinue;\r\ncase -1:\r\nbreak;\r\n}\r\n}\r\nprev = curr;\r\n}\r\n} while (!done);\r\n}\r\nstatic void cl_lock_descr_merge(struct cl_lock_descr *d0,\r\nconst struct cl_lock_descr *d1)\r\n{\r\nd0->cld_start = min(d0->cld_start, d1->cld_start);\r\nd0->cld_end = max(d0->cld_end, d1->cld_end);\r\nif (d1->cld_mode == CLM_WRITE && d0->cld_mode != CLM_WRITE)\r\nd0->cld_mode = CLM_WRITE;\r\nif (d1->cld_mode == CLM_GROUP && d0->cld_mode != CLM_GROUP)\r\nd0->cld_mode = CLM_GROUP;\r\n}\r\nstatic int cl_lockset_merge(const struct cl_lockset *set,\r\nconst struct cl_lock_descr *need)\r\n{\r\nstruct cl_io_lock_link *scan;\r\nlist_for_each_entry(scan, &set->cls_todo, cill_linkage) {\r\nif (!cl_object_same(scan->cill_descr.cld_obj, need->cld_obj))\r\ncontinue;\r\ncl_lock_descr_merge(&scan->cill_descr, need);\r\nCDEBUG(D_VFSTRACE, "lock: %d: [%lu, %lu]\n",\r\nscan->cill_descr.cld_mode, scan->cill_descr.cld_start,\r\nscan->cill_descr.cld_end);\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cl_lockset_lock(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_lockset *set)\r\n{\r\nstruct cl_io_lock_link *link;\r\nstruct cl_io_lock_link *temp;\r\nint result;\r\nresult = 0;\r\nlist_for_each_entry_safe(link, temp, &set->cls_todo, cill_linkage) {\r\nresult = cl_lock_request(env, io, &link->cill_lock);\r\nif (result < 0)\r\nbreak;\r\nlist_move(&link->cill_linkage, &set->cls_done);\r\n}\r\nreturn result;\r\n}\r\nint cl_io_lock(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_IT_STARTED);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each(scan, io) {\r\nif (!scan->cis_iop->op[io->ci_type].cio_lock)\r\ncontinue;\r\nresult = scan->cis_iop->op[io->ci_type].cio_lock(env, scan);\r\nif (result != 0)\r\nbreak;\r\n}\r\nif (result == 0) {\r\ncl_io_locks_sort(io);\r\nresult = cl_lockset_lock(env, io, &io->ci_lockset);\r\n}\r\nif (result != 0)\r\ncl_io_unlock(env, io);\r\nelse\r\nio->ci_state = CIS_LOCKED;\r\nreturn result;\r\n}\r\nvoid cl_io_unlock(const struct lu_env *env, struct cl_io *io)\r\n{\r\nstruct cl_lockset *set;\r\nstruct cl_io_lock_link *link;\r\nstruct cl_io_lock_link *temp;\r\nconst struct cl_io_slice *scan;\r\nLASSERT(cl_io_is_loopable(io));\r\nLASSERT(CIS_IT_STARTED <= io->ci_state && io->ci_state < CIS_UNLOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\nset = &io->ci_lockset;\r\nlist_for_each_entry_safe(link, temp, &set->cls_todo, cill_linkage) {\r\nlist_del_init(&link->cill_linkage);\r\nif (link->cill_fini)\r\nlink->cill_fini(env, link);\r\n}\r\nlist_for_each_entry_safe(link, temp, &set->cls_done, cill_linkage) {\r\nlist_del_init(&link->cill_linkage);\r\ncl_lock_release(env, &link->cill_lock);\r\nif (link->cill_fini)\r\nlink->cill_fini(env, link);\r\n}\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_unlock)\r\nscan->cis_iop->op[io->ci_type].cio_unlock(env, scan);\r\n}\r\nio->ci_state = CIS_UNLOCKED;\r\n}\r\nint cl_io_iter_init(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_INIT || io->ci_state == CIS_IT_ENDED);\r\nLINVRNT(cl_io_invariant(io));\r\nresult = 0;\r\ncl_io_for_each(scan, io) {\r\nif (!scan->cis_iop->op[io->ci_type].cio_iter_init)\r\ncontinue;\r\nresult = scan->cis_iop->op[io->ci_type].cio_iter_init(env,\r\nscan);\r\nif (result != 0)\r\nbreak;\r\n}\r\nif (result == 0)\r\nio->ci_state = CIS_IT_STARTED;\r\nreturn result;\r\n}\r\nvoid cl_io_iter_fini(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_UNLOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_iter_fini)\r\nscan->cis_iop->op[io->ci_type].cio_iter_fini(env, scan);\r\n}\r\nio->ci_state = CIS_IT_ENDED;\r\n}\r\nstatic void cl_io_rw_advance(const struct lu_env *env, struct cl_io *io,\r\nsize_t nob)\r\n{\r\nconst struct cl_io_slice *scan;\r\nLINVRNT(io->ci_type == CIT_READ || io->ci_type == CIT_WRITE ||\r\nnob == 0);\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(cl_io_invariant(io));\r\nio->u.ci_rw.crw_pos += nob;\r\nio->u.ci_rw.crw_count -= nob;\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_advance)\r\nscan->cis_iop->op[io->ci_type].cio_advance(env, scan,\r\nnob);\r\n}\r\n}\r\nint cl_io_lock_add(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_io_lock_link *link)\r\n{\r\nint result;\r\nif (cl_lockset_merge(&io->ci_lockset, &link->cill_descr)) {\r\nresult = 1;\r\n} else {\r\nlist_add(&link->cill_linkage, &io->ci_lockset.cls_todo);\r\nresult = 0;\r\n}\r\nreturn result;\r\n}\r\nstatic void cl_free_io_lock_link(const struct lu_env *env,\r\nstruct cl_io_lock_link *link)\r\n{\r\nkfree(link);\r\n}\r\nint cl_io_lock_alloc_add(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_lock_descr *descr)\r\n{\r\nstruct cl_io_lock_link *link;\r\nint result;\r\nlink = kzalloc(sizeof(*link), GFP_NOFS);\r\nif (link) {\r\nlink->cill_descr = *descr;\r\nlink->cill_fini = cl_free_io_lock_link;\r\nresult = cl_io_lock_add(env, io, link);\r\nif (result)\r\nlink->cill_fini(env, link);\r\n} else {\r\nresult = -ENOMEM;\r\n}\r\nreturn result;\r\n}\r\nint cl_io_start(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_LOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\nio->ci_state = CIS_IO_GOING;\r\ncl_io_for_each(scan, io) {\r\nif (!scan->cis_iop->op[io->ci_type].cio_start)\r\ncontinue;\r\nresult = scan->cis_iop->op[io->ci_type].cio_start(env, scan);\r\nif (result != 0)\r\nbreak;\r\n}\r\nif (result >= 0)\r\nresult = 0;\r\nreturn result;\r\n}\r\nvoid cl_io_end(const struct lu_env *env, struct cl_io *io)\r\n{\r\nconst struct cl_io_slice *scan;\r\nLINVRNT(cl_io_is_loopable(io));\r\nLINVRNT(io->ci_state == CIS_IO_GOING);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each_reverse(scan, io) {\r\nif (scan->cis_iop->op[io->ci_type].cio_end)\r\nscan->cis_iop->op[io->ci_type].cio_end(env, scan);\r\n}\r\nio->ci_state = CIS_IO_FINISHED;\r\n}\r\nint cl_io_read_ahead(const struct lu_env *env, struct cl_io *io,\r\npgoff_t start, struct cl_read_ahead *ra)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\nLINVRNT(io->ci_type == CIT_READ || io->ci_type == CIT_FAULT);\r\nLINVRNT(io->ci_state == CIS_IO_GOING || io->ci_state == CIS_LOCKED);\r\nLINVRNT(cl_io_invariant(io));\r\ncl_io_for_each(scan, io) {\r\nif (!scan->cis_iop->cio_read_ahead)\r\ncontinue;\r\nresult = scan->cis_iop->cio_read_ahead(env, scan, start, ra);\r\nif (result)\r\nbreak;\r\n}\r\nreturn result > 0 ? 0 : result;\r\n}\r\nint cl_io_commit_async(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page_list *queue, int from, int to,\r\ncl_commit_cbt cb)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\ncl_io_for_each(scan, io) {\r\nif (!scan->cis_iop->cio_commit_async)\r\ncontinue;\r\nresult = scan->cis_iop->cio_commit_async(env, scan, queue,\r\nfrom, to, cb);\r\nif (result != 0)\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nint cl_io_submit_rw(const struct lu_env *env, struct cl_io *io,\r\nenum cl_req_type crt, struct cl_2queue *queue)\r\n{\r\nconst struct cl_io_slice *scan;\r\nint result = 0;\r\ncl_io_for_each(scan, io) {\r\nif (!scan->cis_iop->cio_submit)\r\ncontinue;\r\nresult = scan->cis_iop->cio_submit(env, scan, crt, queue);\r\nif (result != 0)\r\nbreak;\r\n}\r\nLASSERT(ergo(result != 0, list_empty(&queue->c2_qout.pl_pages)));\r\nreturn result;\r\n}\r\nint cl_io_submit_sync(const struct lu_env *env, struct cl_io *io,\r\nenum cl_req_type iot, struct cl_2queue *queue,\r\nlong timeout)\r\n{\r\nstruct cl_sync_io *anchor = &cl_env_info(env)->clt_anchor;\r\nstruct cl_page *pg;\r\nint rc;\r\ncl_page_list_for_each(pg, &queue->c2_qin) {\r\nLASSERT(!pg->cp_sync_io);\r\npg->cp_sync_io = anchor;\r\n}\r\ncl_sync_io_init(anchor, queue->c2_qin.pl_nr, &cl_sync_io_end);\r\nrc = cl_io_submit_rw(env, io, iot, queue);\r\nif (rc == 0) {\r\ncl_page_list_for_each(pg, &queue->c2_qin) {\r\npg->cp_sync_io = NULL;\r\ncl_sync_io_note(env, anchor, 1);\r\n}\r\nrc = cl_sync_io_wait(env, anchor, timeout);\r\ncl_page_list_assume(env, io, &queue->c2_qout);\r\n} else {\r\nLASSERT(list_empty(&queue->c2_qout.pl_pages));\r\ncl_page_list_for_each(pg, &queue->c2_qin)\r\npg->cp_sync_io = NULL;\r\n}\r\nreturn rc;\r\n}\r\nint cl_io_loop(const struct lu_env *env, struct cl_io *io)\r\n{\r\nint result = 0;\r\nLINVRNT(cl_io_is_loopable(io));\r\ndo {\r\nsize_t nob;\r\nio->ci_continue = 0;\r\nresult = cl_io_iter_init(env, io);\r\nif (result == 0) {\r\nnob = io->ci_nob;\r\nresult = cl_io_lock(env, io);\r\nif (result == 0) {\r\nresult = cl_io_start(env, io);\r\ncl_io_end(env, io);\r\ncl_io_unlock(env, io);\r\ncl_io_rw_advance(env, io, io->ci_nob - nob);\r\n}\r\n}\r\ncl_io_iter_fini(env, io);\r\n} while (result == 0 && io->ci_continue);\r\nif (result == 0)\r\nresult = io->ci_result;\r\nreturn result < 0 ? result : 0;\r\n}\r\nvoid cl_io_slice_add(struct cl_io *io, struct cl_io_slice *slice,\r\nstruct cl_object *obj,\r\nconst struct cl_io_operations *ops)\r\n{\r\nstruct list_head *linkage = &slice->cis_linkage;\r\nLASSERT((!linkage->prev && !linkage->next) ||\r\nlist_empty(linkage));\r\nlist_add_tail(linkage, &io->ci_layers);\r\nslice->cis_io = io;\r\nslice->cis_obj = obj;\r\nslice->cis_iop = ops;\r\n}\r\nvoid cl_page_list_init(struct cl_page_list *plist)\r\n{\r\nplist->pl_nr = 0;\r\nINIT_LIST_HEAD(&plist->pl_pages);\r\nplist->pl_owner = current;\r\n}\r\nvoid cl_page_list_add(struct cl_page_list *plist, struct cl_page *page)\r\n{\r\nLASSERT(page->cp_owner);\r\nLINVRNT(plist->pl_owner == current);\r\nLASSERT(list_empty(&page->cp_batch));\r\nlist_add_tail(&page->cp_batch, &plist->pl_pages);\r\n++plist->pl_nr;\r\nlu_ref_add_at(&page->cp_reference, &page->cp_queue_ref, "queue", plist);\r\ncl_page_get(page);\r\n}\r\nvoid cl_page_list_del(const struct lu_env *env, struct cl_page_list *plist,\r\nstruct cl_page *page)\r\n{\r\nLASSERT(plist->pl_nr > 0);\r\nLASSERT(cl_page_is_vmlocked(env, page));\r\nLINVRNT(plist->pl_owner == current);\r\nlist_del_init(&page->cp_batch);\r\n--plist->pl_nr;\r\nlu_ref_del_at(&page->cp_reference, &page->cp_queue_ref, "queue", plist);\r\ncl_page_put(env, page);\r\n}\r\nvoid cl_page_list_move(struct cl_page_list *dst, struct cl_page_list *src,\r\nstruct cl_page *page)\r\n{\r\nLASSERT(src->pl_nr > 0);\r\nLINVRNT(dst->pl_owner == current);\r\nLINVRNT(src->pl_owner == current);\r\nlist_move_tail(&page->cp_batch, &dst->pl_pages);\r\n--src->pl_nr;\r\n++dst->pl_nr;\r\nlu_ref_set_at(&page->cp_reference, &page->cp_queue_ref, "queue",\r\nsrc, dst);\r\n}\r\nvoid cl_page_list_move_head(struct cl_page_list *dst, struct cl_page_list *src,\r\nstruct cl_page *page)\r\n{\r\nLASSERT(src->pl_nr > 0);\r\nLINVRNT(dst->pl_owner == current);\r\nLINVRNT(src->pl_owner == current);\r\nlist_move(&page->cp_batch, &dst->pl_pages);\r\n--src->pl_nr;\r\n++dst->pl_nr;\r\nlu_ref_set_at(&page->cp_reference, &page->cp_queue_ref, "queue",\r\nsrc, dst);\r\n}\r\nvoid cl_page_list_splice(struct cl_page_list *list, struct cl_page_list *head)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *tmp;\r\nLINVRNT(list->pl_owner == current);\r\nLINVRNT(head->pl_owner == current);\r\ncl_page_list_for_each_safe(page, tmp, list)\r\ncl_page_list_move(head, list, page);\r\n}\r\nvoid cl_page_list_disown(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *temp;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each_safe(page, temp, plist) {\r\nLASSERT(plist->pl_nr > 0);\r\nlist_del_init(&page->cp_batch);\r\n--plist->pl_nr;\r\ncl_page_disown0(env, io, page);\r\nlu_ref_del_at(&page->cp_reference, &page->cp_queue_ref, "queue",\r\nplist);\r\ncl_page_put(env, page);\r\n}\r\n}\r\nvoid cl_page_list_fini(const struct lu_env *env, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nstruct cl_page *temp;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each_safe(page, temp, plist)\r\ncl_page_list_del(env, plist, page);\r\nLASSERT(plist->pl_nr == 0);\r\n}\r\nstatic void cl_page_list_assume(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each(page, plist)\r\ncl_page_assume(env, io, page);\r\n}\r\nstatic void cl_page_list_discard(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_page_list *plist)\r\n{\r\nstruct cl_page *page;\r\nLINVRNT(plist->pl_owner == current);\r\ncl_page_list_for_each(page, plist)\r\ncl_page_discard(env, io, page);\r\n}\r\nvoid cl_2queue_init(struct cl_2queue *queue)\r\n{\r\ncl_page_list_init(&queue->c2_qin);\r\ncl_page_list_init(&queue->c2_qout);\r\n}\r\nvoid cl_2queue_disown(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_2queue *queue)\r\n{\r\ncl_page_list_disown(env, io, &queue->c2_qin);\r\ncl_page_list_disown(env, io, &queue->c2_qout);\r\n}\r\nvoid cl_2queue_discard(const struct lu_env *env,\r\nstruct cl_io *io, struct cl_2queue *queue)\r\n{\r\ncl_page_list_discard(env, io, &queue->c2_qin);\r\ncl_page_list_discard(env, io, &queue->c2_qout);\r\n}\r\nvoid cl_2queue_fini(const struct lu_env *env, struct cl_2queue *queue)\r\n{\r\ncl_page_list_fini(env, &queue->c2_qout);\r\ncl_page_list_fini(env, &queue->c2_qin);\r\n}\r\nvoid cl_2queue_init_page(struct cl_2queue *queue, struct cl_page *page)\r\n{\r\ncl_2queue_init(queue);\r\ncl_page_list_add(&queue->c2_qin, page);\r\n}\r\nstruct cl_io *cl_io_top(struct cl_io *io)\r\n{\r\nwhile (io->ci_parent)\r\nio = io->ci_parent;\r\nreturn io;\r\n}\r\nvoid cl_req_attr_set(const struct lu_env *env, struct cl_object *obj,\r\nstruct cl_req_attr *attr)\r\n{\r\nstruct cl_object *scan;\r\ncl_object_for_each(scan, obj) {\r\nif (scan->co_ops->coo_req_attr_set)\r\nscan->co_ops->coo_req_attr_set(env, scan, attr);\r\n}\r\n}\r\nvoid cl_sync_io_end(const struct lu_env *env, struct cl_sync_io *anchor)\r\n{\r\nwake_up_all(&anchor->csi_waitq);\r\natomic_set(&anchor->csi_barrier, 0);\r\n}\r\nvoid cl_sync_io_init(struct cl_sync_io *anchor, int nr,\r\nvoid (*end)(const struct lu_env *, struct cl_sync_io *))\r\n{\r\nmemset(anchor, 0, sizeof(*anchor));\r\ninit_waitqueue_head(&anchor->csi_waitq);\r\natomic_set(&anchor->csi_sync_nr, nr);\r\natomic_set(&anchor->csi_barrier, nr > 0);\r\nanchor->csi_sync_rc = 0;\r\nanchor->csi_end_io = end;\r\nLASSERT(end);\r\n}\r\nint cl_sync_io_wait(const struct lu_env *env, struct cl_sync_io *anchor,\r\nlong timeout)\r\n{\r\nstruct l_wait_info lwi = LWI_TIMEOUT_INTR(cfs_time_seconds(timeout),\r\nNULL, NULL, NULL);\r\nint rc;\r\nLASSERT(timeout >= 0);\r\nrc = l_wait_event(anchor->csi_waitq,\r\natomic_read(&anchor->csi_sync_nr) == 0,\r\n&lwi);\r\nif (rc < 0) {\r\nCERROR("IO failed: %d, still wait for %d remaining entries\n",\r\nrc, atomic_read(&anchor->csi_sync_nr));\r\nlwi = (struct l_wait_info) { 0 };\r\n(void)l_wait_event(anchor->csi_waitq,\r\natomic_read(&anchor->csi_sync_nr) == 0,\r\n&lwi);\r\n} else {\r\nrc = anchor->csi_sync_rc;\r\n}\r\nLASSERT(atomic_read(&anchor->csi_sync_nr) == 0);\r\nwhile (unlikely(atomic_read(&anchor->csi_barrier) != 0))\r\ncpu_relax();\r\nreturn rc;\r\n}\r\nvoid cl_sync_io_note(const struct lu_env *env, struct cl_sync_io *anchor,\r\nint ioret)\r\n{\r\nif (anchor->csi_sync_rc == 0 && ioret < 0)\r\nanchor->csi_sync_rc = ioret;\r\nLASSERT(atomic_read(&anchor->csi_sync_nr) > 0);\r\nif (atomic_dec_and_test(&anchor->csi_sync_nr)) {\r\nLASSERT(anchor->csi_end_io);\r\nanchor->csi_end_io(env, anchor);\r\n}\r\n}
