static void gf_mulx(u8 *pad)\r\n{\r\nu64 a = get_unaligned_be64(pad);\r\nu64 b = get_unaligned_be64(pad + 8);\r\nput_unaligned_be64((a << 1) | (b >> 63), pad);\r\nput_unaligned_be64((b << 1) ^ ((a >> 63) ? 0x87 : 0), pad + 8);\r\n}\r\nstatic int aes_s2v(struct crypto_shash *tfm,\r\nsize_t num_elem, const u8 *addr[], size_t len[], u8 *v)\r\n{\r\nu8 d[AES_BLOCK_SIZE], tmp[AES_BLOCK_SIZE] = {};\r\nSHASH_DESC_ON_STACK(desc, tfm);\r\nsize_t i;\r\ndesc->tfm = tfm;\r\ncrypto_shash_digest(desc, tmp, AES_BLOCK_SIZE, d);\r\nfor (i = 0; i < num_elem - 1; i++) {\r\ngf_mulx(d);\r\ncrypto_shash_digest(desc, addr[i], len[i], tmp);\r\ncrypto_xor(d, tmp, AES_BLOCK_SIZE);\r\n}\r\ncrypto_shash_init(desc);\r\nif (len[i] >= AES_BLOCK_SIZE) {\r\ncrypto_shash_update(desc, addr[i], len[i] - AES_BLOCK_SIZE);\r\ncrypto_xor(d, addr[i] + len[i] - AES_BLOCK_SIZE,\r\nAES_BLOCK_SIZE);\r\n} else {\r\ngf_mulx(d);\r\ncrypto_xor(d, addr[i], len[i]);\r\nd[len[i]] ^= 0x80;\r\n}\r\ncrypto_shash_finup(desc, d, AES_BLOCK_SIZE, v);\r\nreturn 0;\r\n}\r\nstatic int aes_siv_encrypt(const u8 *key, size_t key_len,\r\nconst u8 *plain, size_t plain_len,\r\nsize_t num_elem, const u8 *addr[],\r\nsize_t len[], u8 *out)\r\n{\r\nu8 v[AES_BLOCK_SIZE];\r\nstruct crypto_shash *tfm;\r\nstruct crypto_skcipher *tfm2;\r\nstruct skcipher_request *req;\r\nint res;\r\nstruct scatterlist src[1], dst[1];\r\nu8 *tmp;\r\nkey_len /= 2;\r\naddr[num_elem] = plain;\r\nlen[num_elem] = plain_len;\r\nnum_elem++;\r\ntfm = crypto_alloc_shash("cmac(aes)", 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nres = crypto_shash_setkey(tfm, key, key_len);\r\nif (!res)\r\nres = aes_s2v(tfm, num_elem, addr, len, v);\r\ncrypto_free_shash(tfm);\r\nif (res)\r\nreturn res;\r\ntmp = kmemdup(plain, plain_len, GFP_KERNEL);\r\nif (!tmp)\r\nreturn -ENOMEM;\r\nmemcpy(out, v, AES_BLOCK_SIZE);\r\nv[8] &= 0x7f;\r\nv[12] &= 0x7f;\r\ntfm2 = crypto_alloc_skcipher("ctr(aes)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm2)) {\r\nkfree(tmp);\r\nreturn PTR_ERR(tfm2);\r\n}\r\nres = crypto_skcipher_setkey(tfm2, key + key_len, key_len);\r\nif (res)\r\ngoto fail;\r\nreq = skcipher_request_alloc(tfm2, GFP_KERNEL);\r\nif (!req) {\r\nres = -ENOMEM;\r\ngoto fail;\r\n}\r\nsg_init_one(src, tmp, plain_len);\r\nsg_init_one(dst, out + AES_BLOCK_SIZE, plain_len);\r\nskcipher_request_set_crypt(req, src, dst, plain_len, v);\r\nres = crypto_skcipher_encrypt(req);\r\nskcipher_request_free(req);\r\nfail:\r\nkfree(tmp);\r\ncrypto_free_skcipher(tfm2);\r\nreturn res;\r\n}\r\nstatic int aes_siv_decrypt(const u8 *key, size_t key_len,\r\nconst u8 *iv_crypt, size_t iv_c_len,\r\nsize_t num_elem, const u8 *addr[], size_t len[],\r\nu8 *out)\r\n{\r\nstruct crypto_shash *tfm;\r\nstruct crypto_skcipher *tfm2;\r\nstruct skcipher_request *req;\r\nstruct scatterlist src[1], dst[1];\r\nsize_t crypt_len;\r\nint res;\r\nu8 frame_iv[AES_BLOCK_SIZE], iv[AES_BLOCK_SIZE];\r\nu8 check[AES_BLOCK_SIZE];\r\ncrypt_len = iv_c_len - AES_BLOCK_SIZE;\r\nkey_len /= 2;\r\naddr[num_elem] = out;\r\nlen[num_elem] = crypt_len;\r\nnum_elem++;\r\nmemcpy(iv, iv_crypt, AES_BLOCK_SIZE);\r\nmemcpy(frame_iv, iv_crypt, AES_BLOCK_SIZE);\r\niv[8] &= 0x7f;\r\niv[12] &= 0x7f;\r\ntfm2 = crypto_alloc_skcipher("ctr(aes)", 0, CRYPTO_ALG_ASYNC);\r\nif (IS_ERR(tfm2))\r\nreturn PTR_ERR(tfm2);\r\nres = crypto_skcipher_setkey(tfm2, key + key_len, key_len);\r\nif (res) {\r\ncrypto_free_skcipher(tfm2);\r\nreturn res;\r\n}\r\nreq = skcipher_request_alloc(tfm2, GFP_KERNEL);\r\nif (!req) {\r\ncrypto_free_skcipher(tfm2);\r\nreturn -ENOMEM;\r\n}\r\nsg_init_one(src, iv_crypt + AES_BLOCK_SIZE, crypt_len);\r\nsg_init_one(dst, out, crypt_len);\r\nskcipher_request_set_crypt(req, src, dst, crypt_len, iv);\r\nres = crypto_skcipher_decrypt(req);\r\nskcipher_request_free(req);\r\ncrypto_free_skcipher(tfm2);\r\nif (res)\r\nreturn res;\r\ntfm = crypto_alloc_shash("cmac(aes)", 0, 0);\r\nif (IS_ERR(tfm))\r\nreturn PTR_ERR(tfm);\r\nres = crypto_shash_setkey(tfm, key, key_len);\r\nif (!res)\r\nres = aes_s2v(tfm, num_elem, addr, len, check);\r\ncrypto_free_shash(tfm);\r\nif (res)\r\nreturn res;\r\nif (memcmp(check, frame_iv, AES_BLOCK_SIZE) != 0)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nint fils_encrypt_assoc_req(struct sk_buff *skb,\r\nstruct ieee80211_mgd_assoc_data *assoc_data)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (void *)skb->data;\r\nu8 *capab, *ies, *encr;\r\nconst u8 *addr[5 + 1], *session;\r\nsize_t len[5 + 1];\r\nsize_t crypt_len;\r\nif (ieee80211_is_reassoc_req(mgmt->frame_control)) {\r\ncapab = (u8 *)&mgmt->u.reassoc_req.capab_info;\r\nies = mgmt->u.reassoc_req.variable;\r\n} else {\r\ncapab = (u8 *)&mgmt->u.assoc_req.capab_info;\r\nies = mgmt->u.assoc_req.variable;\r\n}\r\nsession = cfg80211_find_ext_ie(WLAN_EID_EXT_FILS_SESSION,\r\nies, skb->data + skb->len - ies);\r\nif (!session || session[1] != 1 + 8)\r\nreturn -EINVAL;\r\nencr = (u8 *)session + 2 + 1 + 8;\r\naddr[0] = mgmt->sa;\r\nlen[0] = ETH_ALEN;\r\naddr[1] = mgmt->da;\r\nlen[1] = ETH_ALEN;\r\naddr[2] = assoc_data->fils_nonces;\r\nlen[2] = FILS_NONCE_LEN;\r\naddr[3] = &assoc_data->fils_nonces[FILS_NONCE_LEN];\r\nlen[3] = FILS_NONCE_LEN;\r\naddr[4] = capab;\r\nlen[4] = encr - capab;\r\ncrypt_len = skb->data + skb->len - encr;\r\nskb_put(skb, AES_BLOCK_SIZE);\r\nreturn aes_siv_encrypt(assoc_data->fils_kek, assoc_data->fils_kek_len,\r\nencr, crypt_len, 5, addr, len, encr);\r\n}\r\nint fils_decrypt_assoc_resp(struct ieee80211_sub_if_data *sdata,\r\nu8 *frame, size_t *frame_len,\r\nstruct ieee80211_mgd_assoc_data *assoc_data)\r\n{\r\nstruct ieee80211_mgmt *mgmt = (void *)frame;\r\nu8 *capab, *ies, *encr;\r\nconst u8 *addr[5 + 1], *session;\r\nsize_t len[5 + 1];\r\nint res;\r\nsize_t crypt_len;\r\nif (*frame_len < 24 + 6)\r\nreturn -EINVAL;\r\ncapab = (u8 *)&mgmt->u.assoc_resp.capab_info;\r\nies = mgmt->u.assoc_resp.variable;\r\nsession = cfg80211_find_ext_ie(WLAN_EID_EXT_FILS_SESSION,\r\nies, frame + *frame_len - ies);\r\nif (!session || session[1] != 1 + 8) {\r\nmlme_dbg(sdata,\r\n"No (valid) FILS Session element in (Re)Association Response frame from %pM",\r\nmgmt->sa);\r\nreturn -EINVAL;\r\n}\r\nencr = (u8 *)session + 2 + 1 + 8;\r\naddr[0] = mgmt->sa;\r\nlen[0] = ETH_ALEN;\r\naddr[1] = mgmt->da;\r\nlen[1] = ETH_ALEN;\r\naddr[2] = &assoc_data->fils_nonces[FILS_NONCE_LEN];\r\nlen[2] = FILS_NONCE_LEN;\r\naddr[3] = assoc_data->fils_nonces;\r\nlen[3] = FILS_NONCE_LEN;\r\naddr[4] = capab;\r\nlen[4] = encr - capab;\r\ncrypt_len = frame + *frame_len - encr;\r\nif (crypt_len < AES_BLOCK_SIZE) {\r\nmlme_dbg(sdata,\r\n"Not enough room for AES-SIV data after FILS Session element in (Re)Association Response frame from %pM",\r\nmgmt->sa);\r\nreturn -EINVAL;\r\n}\r\nres = aes_siv_decrypt(assoc_data->fils_kek, assoc_data->fils_kek_len,\r\nencr, crypt_len, 5, addr, len, encr);\r\nif (res != 0) {\r\nmlme_dbg(sdata,\r\n"AES-SIV decryption of (Re)Association Response frame from %pM failed",\r\nmgmt->sa);\r\nreturn res;\r\n}\r\n*frame_len -= AES_BLOCK_SIZE;\r\nreturn 0;\r\n}
