struct acpi_namespace_node *acpi_db_convert_to_node(char *in_string)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_size address;\r\nif ((*in_string >= 0x30) && (*in_string <= 0x39)) {\r\naddress = strtoul(in_string, NULL, 16);\r\nnode = ACPI_TO_POINTER(address);\r\nif (!acpi_os_readable(node, sizeof(struct acpi_namespace_node))) {\r\nacpi_os_printf("Address %p is invalid", node);\r\nreturn (NULL);\r\n}\r\nif (ACPI_GET_DESCRIPTOR_TYPE(node) != ACPI_DESC_TYPE_NAMED) {\r\nacpi_os_printf\r\n("Address %p is not a valid namespace node [%s]\n",\r\nnode, acpi_ut_get_descriptor_name(node));\r\nreturn (NULL);\r\n}\r\n} else {\r\nnode = acpi_db_local_ns_lookup(in_string);\r\nif (!node) {\r\nacpi_os_printf\r\n("Could not find [%s] in namespace, defaulting to root node\n",\r\nin_string);\r\nnode = acpi_gbl_root_node;\r\n}\r\n}\r\nreturn (node);\r\n}\r\nacpi_status acpi_db_sleep(char *object_arg)\r\n{\r\nu8 sleep_state;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(acpi_db_sleep);\r\nif (!object_arg) {\r\nacpi_os_printf("Invoking all possible sleep states, 0-%d\n",\r\nACPI_S_STATES_MAX);\r\nfor (i = 0; i <= ACPI_S_STATES_MAX; i++) {\r\nacpi_db_do_one_sleep_state((u8)i);\r\n}\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nsleep_state = (u8)strtoul(object_arg, NULL, 0);\r\nacpi_db_do_one_sleep_state(sleep_state);\r\nreturn_ACPI_STATUS(AE_OK);\r\n}\r\nstatic void acpi_db_do_one_sleep_state(u8 sleep_state)\r\n{\r\nacpi_status status;\r\nu8 sleep_type_a;\r\nu8 sleep_type_b;\r\nif (sleep_state > ACPI_S_STATES_MAX) {\r\nacpi_os_printf("Sleep state %d out of range (%d max)\n",\r\nsleep_state, ACPI_S_STATES_MAX);\r\nreturn;\r\n}\r\nacpi_os_printf("\n---- Invoking sleep state S%d (%s):\n",\r\nsleep_state, acpi_gbl_sleep_state_names[sleep_state]);\r\nstatus =\r\nacpi_get_sleep_type_data(sleep_state, &sleep_type_a, &sleep_type_b);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not evaluate [%s] method, %s\n",\r\nacpi_gbl_sleep_state_names[sleep_state],\r\nacpi_format_exception(status));\r\nreturn;\r\n}\r\nacpi_os_printf\r\n("Register values for sleep state S%d: Sleep-A: %.2X, Sleep-B: %.2X\n",\r\nsleep_state, sleep_type_a, sleep_type_b);\r\nacpi_os_printf("**** Sleep: Prepare to sleep (S%d) ****\n",\r\nsleep_state);\r\nstatus = acpi_enter_sleep_state_prep(sleep_state);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nacpi_os_printf("**** Sleep: Going to sleep (S%d) ****\n", sleep_state);\r\nstatus = acpi_enter_sleep_state(sleep_state);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nacpi_os_printf("**** Wake: Prepare to return from sleep (S%d) ****\n",\r\nsleep_state);\r\nstatus = acpi_leave_sleep_state_prep(sleep_state);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nacpi_os_printf("**** Wake: Return from sleep (S%d) ****\n",\r\nsleep_state);\r\nstatus = acpi_leave_sleep_state(sleep_state);\r\nif (ACPI_FAILURE(status)) {\r\ngoto error_exit;\r\n}\r\nreturn;\r\nerror_exit:\r\nACPI_EXCEPTION((AE_INFO, status, "During invocation of sleep state S%d",\r\nsleep_state));\r\n}\r\nvoid acpi_db_display_locks(void)\r\n{\r\nu32 i;\r\nfor (i = 0; i < ACPI_MAX_MUTEX; i++) {\r\nacpi_os_printf("%26s : %s\n", acpi_ut_get_mutex_name(i),\r\nacpi_gbl_mutex_info[i].thread_id ==\r\nACPI_MUTEX_NOT_ACQUIRED ? "Locked" : "Unlocked");\r\n}\r\n}\r\nvoid acpi_db_display_table_info(char *table_arg)\r\n{\r\nu32 i;\r\nstruct acpi_table_desc *table_desc;\r\nacpi_status status;\r\nacpi_os_printf("Idx ID Status Type "\r\n"TableHeader (Sig, Address, Length, Misc)\n");\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\ntable_desc = &acpi_gbl_root_table_list.tables[i];\r\nacpi_os_printf("%3u %.2u ", i, table_desc->owner_id);\r\nif (!(table_desc->flags & ACPI_TABLE_IS_LOADED)) {\r\nacpi_os_printf("NotLoaded ");\r\n} else {\r\nacpi_os_printf(" Loaded ");\r\n}\r\nswitch (table_desc->flags & ACPI_TABLE_ORIGIN_MASK) {\r\ncase ACPI_TABLE_ORIGIN_EXTERNAL_VIRTUAL:\r\nacpi_os_printf("External/virtual ");\r\nbreak;\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL:\r\nacpi_os_printf("Internal/physical ");\r\nbreak;\r\ncase ACPI_TABLE_ORIGIN_INTERNAL_VIRTUAL:\r\nacpi_os_printf("Internal/virtual ");\r\nbreak;\r\ndefault:\r\nacpi_os_printf("INVALID TYPE ");\r\nbreak;\r\n}\r\nstatus = acpi_tb_validate_table(table_desc);\r\nif (ACPI_FAILURE(status)) {\r\nreturn;\r\n}\r\nif (table_desc->pointer) {\r\nacpi_tb_print_table_header(table_desc->address,\r\ntable_desc->pointer);\r\n} else {\r\nACPI_INFO(("%4.4s - Table has been unloaded",\r\ntable_desc->signature.ascii));\r\n}\r\n}\r\n}\r\nvoid acpi_db_unload_acpi_table(char *object_name)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nnode = acpi_db_convert_to_node(object_name);\r\nif (!node) {\r\nreturn;\r\n}\r\nstatus = acpi_unload_parent_table(ACPI_CAST_PTR(acpi_handle, node));\r\nif (ACPI_SUCCESS(status)) {\r\nacpi_os_printf("Parent of [%s] (%p) unloaded and uninstalled\n",\r\nobject_name, node);\r\n} else {\r\nacpi_os_printf("%s, while unloading parent table of [%s]\n",\r\nacpi_format_exception(status), object_name);\r\n}\r\n}\r\nvoid acpi_db_send_notify(char *name, u32 value)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nnode = acpi_db_convert_to_node(name);\r\nif (!node) {\r\nreturn;\r\n}\r\nif (acpi_ev_is_notify_object(node)) {\r\nstatus = acpi_ev_queue_notify_request(node, value);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not queue notify\n");\r\n}\r\n} else {\r\nacpi_os_printf("Named object [%4.4s] Type %s, "\r\n"must be Device/Thermal/Processor type\n",\r\nacpi_ut_get_node_name(node),\r\nacpi_ut_get_type_name(node->type));\r\n}\r\n}\r\nvoid acpi_db_display_interfaces(char *action_arg, char *interface_name_arg)\r\n{\r\nstruct acpi_interface_info *next_interface;\r\nchar *sub_string;\r\nacpi_status status;\r\nif (!action_arg) {\r\n(void)acpi_os_acquire_mutex(acpi_gbl_osi_mutex,\r\nACPI_WAIT_FOREVER);\r\nnext_interface = acpi_gbl_supported_interfaces;\r\nwhile (next_interface) {\r\nif (!(next_interface->flags & ACPI_OSI_INVALID)) {\r\nacpi_os_printf("%s\n", next_interface->name);\r\n}\r\nnext_interface = next_interface->next;\r\n}\r\nacpi_os_release_mutex(acpi_gbl_osi_mutex);\r\nreturn;\r\n}\r\nif (!interface_name_arg) {\r\nacpi_os_printf("Missing Interface Name argument\n");\r\nreturn;\r\n}\r\nacpi_ut_strupr(action_arg);\r\nsub_string = strstr("INSTALL", action_arg);\r\nif (sub_string) {\r\nstatus = acpi_install_interface(interface_name_arg);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("%s, while installing \"%s\"\n",\r\nacpi_format_exception(status),\r\ninterface_name_arg);\r\n}\r\nreturn;\r\n}\r\nsub_string = strstr("REMOVE", action_arg);\r\nif (sub_string) {\r\nstatus = acpi_remove_interface(interface_name_arg);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("%s, while removing \"%s\"\n",\r\nacpi_format_exception(status),\r\ninterface_name_arg);\r\n}\r\nreturn;\r\n}\r\nacpi_os_printf("Invalid action argument: %s\n", action_arg);\r\nreturn;\r\n}\r\nvoid acpi_db_display_template(char *buffer_arg)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_status status;\r\nstruct acpi_buffer return_buffer;\r\nnode = acpi_db_convert_to_node(buffer_arg);\r\nif (!node || (node == acpi_gbl_root_node)) {\r\nacpi_os_printf("Invalid argument: %s\n", buffer_arg);\r\nreturn;\r\n}\r\nif (node->type != ACPI_TYPE_BUFFER) {\r\nacpi_os_printf\r\n("Not a Buffer object, cannot be a template: %s\n",\r\nbuffer_arg);\r\nreturn;\r\n}\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nstatus = acpi_rs_create_resource_list(node->object, &return_buffer);\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\nacpi_dbg_level |= ACPI_LV_RESOURCES;\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf\r\n("Could not convert Buffer to a resource list: %s, %s\n",\r\nbuffer_arg, acpi_format_exception(status));\r\ngoto dump_buffer;\r\n}\r\nacpi_rs_dump_resource_list(ACPI_CAST_PTR(struct acpi_resource,\r\nreturn_buffer.pointer));\r\ndump_buffer:\r\nacpi_os_printf("\nRaw data buffer:\n");\r\nacpi_ut_debug_dump_buffer((u8 *)node->object->buffer.pointer,\r\nnode->object->buffer.length,\r\nDB_BYTE_DISPLAY, ACPI_UINT32_MAX);\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\nreturn;\r\n}\r\nstatic void\r\nacpi_dm_compare_aml_resources(u8 *aml1_buffer,\r\nacpi_rsdesc_size aml1_buffer_length,\r\nu8 *aml2_buffer,\r\nacpi_rsdesc_size aml2_buffer_length)\r\n{\r\nu8 *aml1;\r\nu8 *aml2;\r\nu8 *aml1_end;\r\nu8 *aml2_end;\r\nacpi_rsdesc_size aml1_length;\r\nacpi_rsdesc_size aml2_length;\r\nacpi_rsdesc_size offset = 0;\r\nu8 resource_type;\r\nu32 count = 0;\r\nu32 i;\r\nif (aml1_buffer_length != aml2_buffer_length) {\r\nacpi_os_printf("**** Buffer length mismatch in converted "\r\n"AML: Original %X, New %X ****\n",\r\naml1_buffer_length, aml2_buffer_length);\r\n}\r\naml1 = aml1_buffer;\r\naml2 = aml2_buffer;\r\naml1_end = aml1_buffer + aml1_buffer_length;\r\naml2_end = aml2_buffer + aml2_buffer_length;\r\nwhile ((aml1 < aml1_end) && (aml2 < aml2_end)) {\r\naml1_length = acpi_ut_get_descriptor_length(aml1);\r\naml2_length = acpi_ut_get_descriptor_length(aml2);\r\nresource_type = acpi_ut_get_resource_type(aml1);\r\nif (aml1_length != aml2_length) {\r\nacpi_os_printf\r\n("**** Length mismatch in descriptor [%.2X] type %2.2X, "\r\n"Offset %8.8X Len1 %X, Len2 %X ****\n", count,\r\nresource_type, offset, aml1_length, aml2_length);\r\n}\r\nelse if (memcmp(aml1, aml2, aml1_length)) {\r\nacpi_os_printf\r\n("**** Data mismatch in descriptor [%.2X] type %2.2X, "\r\n"Offset %8.8X ****\n", count, resource_type,\r\noffset);\r\nfor (i = 0; i < aml1_length; i++) {\r\nif (aml1[i] != aml2[i]) {\r\nacpi_os_printf\r\n("Mismatch at byte offset %.2X: is %2.2X, "\r\n"should be %2.2X\n", i, aml2[i],\r\naml1[i]);\r\n}\r\n}\r\n}\r\nif (resource_type == ACPI_RESOURCE_NAME_END_TAG) {\r\nreturn;\r\n}\r\ncount++;\r\noffset += aml1_length;\r\naml1 += aml1_length;\r\naml2 += aml2_length;\r\n}\r\n}\r\nstatic acpi_status\r\nacpi_dm_test_resource_conversion(struct acpi_namespace_node *node, char *name)\r\n{\r\nacpi_status status;\r\nstruct acpi_buffer return_buffer;\r\nstruct acpi_buffer resource_buffer;\r\nstruct acpi_buffer new_aml;\r\nunion acpi_object *original_aml;\r\nacpi_os_printf("Resource Conversion Comparison:\n");\r\nnew_aml.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nreturn_buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nresource_buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_evaluate_object(node, name, NULL, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not obtain %s: %s\n",\r\nname, acpi_format_exception(status));\r\nreturn (status);\r\n}\r\nstatus = acpi_get_current_resources(node, &resource_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiGetCurrentResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto exit1;\r\n}\r\nstatus = acpi_rs_create_aml_resources(&resource_buffer, &new_aml);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiRsCreateAmlResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto exit2;\r\n}\r\noriginal_aml = return_buffer.pointer;\r\nacpi_dm_compare_aml_resources(original_aml->buffer.pointer,\r\n(acpi_rsdesc_size)original_aml->buffer.\r\nlength, new_aml.pointer,\r\n(acpi_rsdesc_size)new_aml.length);\r\nACPI_FREE(new_aml.pointer);\r\nexit2:\r\nACPI_FREE(resource_buffer.pointer);\r\nexit1:\r\nACPI_FREE(return_buffer.pointer);\r\nreturn (status);\r\n}\r\nstatic acpi_status\r\nacpi_db_resource_callback(struct acpi_resource *resource, void *context)\r\n{\r\nreturn (AE_OK);\r\n}\r\nstatic acpi_status\r\nacpi_db_device_resources(acpi_handle obj_handle,\r\nu32 nesting_level, void *context, void **return_value)\r\n{\r\nstruct acpi_namespace_node *node;\r\nstruct acpi_namespace_node *prt_node = NULL;\r\nstruct acpi_namespace_node *crs_node = NULL;\r\nstruct acpi_namespace_node *prs_node = NULL;\r\nstruct acpi_namespace_node *aei_node = NULL;\r\nchar *parent_path;\r\nstruct acpi_buffer return_buffer;\r\nacpi_status status;\r\nnode = ACPI_CAST_PTR(struct acpi_namespace_node, obj_handle);\r\nparent_path = acpi_ns_get_normalized_pathname(node, TRUE);\r\nif (!parent_path) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\n(void)acpi_get_handle(node, METHOD_NAME__PRT,\r\nACPI_CAST_PTR(acpi_handle, &prt_node));\r\n(void)acpi_get_handle(node, METHOD_NAME__CRS,\r\nACPI_CAST_PTR(acpi_handle, &crs_node));\r\n(void)acpi_get_handle(node, METHOD_NAME__PRS,\r\nACPI_CAST_PTR(acpi_handle, &prs_node));\r\n(void)acpi_get_handle(node, METHOD_NAME__AEI,\r\nACPI_CAST_PTR(acpi_handle, &aei_node));\r\nif (!prt_node && !crs_node && !prs_node && !aei_node) {\r\ngoto cleanup;\r\n}\r\nacpi_os_printf("\nDevice: %s\n", parent_path);\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nif (prt_node) {\r\nacpi_os_printf("Evaluating _PRT\n");\r\nstatus =\r\nacpi_evaluate_object(prt_node, NULL, NULL, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not evaluate _PRT: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_crs;\r\n}\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nstatus = acpi_get_irq_routing_table(node, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("GetIrqRoutingTable failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_crs;\r\n}\r\nacpi_rs_dump_irq_list(ACPI_CAST_PTR(u8, acpi_gbl_db_buffer));\r\n}\r\nget_crs:\r\nif (crs_node) {\r\nacpi_os_printf("Evaluating _CRS\n");\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nstatus =\r\nacpi_evaluate_object(crs_node, NULL, NULL, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not evaluate _CRS: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_prs;\r\n}\r\nstatus = acpi_walk_resources(node, METHOD_NAME__CRS,\r\nacpi_db_resource_callback, NULL);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiWalkResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_prs;\r\n}\r\nreturn_buffer.pointer = NULL;\r\nreturn_buffer.length = ACPI_ALLOCATE_LOCAL_BUFFER;\r\nstatus = acpi_get_current_resources(node, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiGetCurrentResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_prs;\r\n}\r\nstatus = acpi_walk_resource_buffer(&return_buffer,\r\nacpi_db_resource_callback,\r\nNULL);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiWalkResourceBuffer failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto end_crs;\r\n}\r\nacpi_rs_dump_resource_list(ACPI_CAST_PTR(struct acpi_resource,\r\nreturn_buffer.\r\npointer));\r\n(void)acpi_dm_test_resource_conversion(node, METHOD_NAME__CRS);\r\nacpi_os_printf("Evaluating _SRS\n");\r\nstatus = acpi_set_current_resources(node, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiSetCurrentResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto end_crs;\r\n}\r\nend_crs:\r\nACPI_FREE(return_buffer.pointer);\r\n}\r\nget_prs:\r\nif (prs_node) {\r\nacpi_os_printf("Evaluating _PRS\n");\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nstatus =\r\nacpi_evaluate_object(prs_node, NULL, NULL, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not evaluate _PRS: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_aei;\r\n}\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nstatus = acpi_get_possible_resources(node, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiGetPossibleResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto get_aei;\r\n}\r\nacpi_rs_dump_resource_list(ACPI_CAST_PTR\r\n(struct acpi_resource,\r\nacpi_gbl_db_buffer));\r\n}\r\nget_aei:\r\nif (aei_node) {\r\nacpi_os_printf("Evaluating _AEI\n");\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nstatus =\r\nacpi_evaluate_object(aei_node, NULL, NULL, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("Could not evaluate _AEI: %s\n",\r\nacpi_format_exception(status));\r\ngoto cleanup;\r\n}\r\nreturn_buffer.pointer = acpi_gbl_db_buffer;\r\nreturn_buffer.length = ACPI_DEBUG_BUFFER_SIZE;\r\nstatus = acpi_get_event_resources(node, &return_buffer);\r\nif (ACPI_FAILURE(status)) {\r\nacpi_os_printf("AcpiGetEventResources failed: %s\n",\r\nacpi_format_exception(status));\r\ngoto cleanup;\r\n}\r\nacpi_rs_dump_resource_list(ACPI_CAST_PTR\r\n(struct acpi_resource,\r\nacpi_gbl_db_buffer));\r\n}\r\ncleanup:\r\nACPI_FREE(parent_path);\r\nreturn (AE_OK);\r\n}\r\nvoid acpi_db_display_resources(char *object_arg)\r\n{\r\nstruct acpi_namespace_node *node;\r\nacpi_db_set_output_destination(ACPI_DB_REDIRECTABLE_OUTPUT);\r\nacpi_dbg_level |= ACPI_LV_RESOURCES;\r\nif (!object_arg || (!strcmp(object_arg, "*"))) {\r\n(void)acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,\r\nACPI_UINT32_MAX,\r\nacpi_db_device_resources, NULL, NULL,\r\nNULL);\r\n} else {\r\nnode = acpi_db_convert_to_node(object_arg);\r\nif (node) {\r\nif (node->type != ACPI_TYPE_DEVICE) {\r\nacpi_os_printf\r\n("%4.4s: Name is not a device object (%s)\n",\r\nnode->name.ascii,\r\nacpi_ut_get_type_name(node->type));\r\n} else {\r\n(void)acpi_db_device_resources(node, 0, NULL,\r\nNULL);\r\n}\r\n}\r\n}\r\nacpi_db_set_output_destination(ACPI_DB_CONSOLE_OUTPUT);\r\n}\r\nvoid acpi_db_generate_gpe(char *gpe_arg, char *block_arg)\r\n{\r\nu32 block_number = 0;\r\nu32 gpe_number;\r\nstruct acpi_gpe_event_info *gpe_event_info;\r\ngpe_number = strtoul(gpe_arg, NULL, 0);\r\nif (block_arg) {\r\nblock_number = strtoul(block_arg, NULL, 0);\r\nif (block_number == 1) {\r\nblock_number = 0;\r\n}\r\n}\r\ngpe_event_info =\r\nacpi_ev_get_gpe_event_info(ACPI_TO_POINTER(block_number),\r\ngpe_number);\r\nif (!gpe_event_info) {\r\nacpi_os_printf("Invalid GPE\n");\r\nreturn;\r\n}\r\n(void)acpi_ev_gpe_dispatch(NULL, gpe_event_info, gpe_number);\r\n}\r\nvoid acpi_db_generate_sci(void)\r\n{\r\nacpi_ev_sci_dispatch();\r\n}\r\nvoid acpi_db_trace(char *enable_arg, char *method_arg, char *once_arg)\r\n{\r\nu32 debug_level = 0;\r\nu32 debug_layer = 0;\r\nu32 flags = 0;\r\nacpi_ut_strupr(enable_arg);\r\nacpi_ut_strupr(once_arg);\r\nif (method_arg) {\r\nif (acpi_db_trace_method_name) {\r\nACPI_FREE(acpi_db_trace_method_name);\r\nacpi_db_trace_method_name = NULL;\r\n}\r\nacpi_db_trace_method_name =\r\nACPI_ALLOCATE(strlen(method_arg) + 1);\r\nif (!acpi_db_trace_method_name) {\r\nacpi_os_printf("Failed to allocate method name (%s)\n",\r\nmethod_arg);\r\nreturn;\r\n}\r\nstrcpy(acpi_db_trace_method_name, method_arg);\r\n}\r\nif (!strcmp(enable_arg, "ENABLE") ||\r\n!strcmp(enable_arg, "METHOD") || !strcmp(enable_arg, "OPCODE")) {\r\nif (!strcmp(enable_arg, "ENABLE")) {\r\ndebug_level = acpi_gbl_db_console_debug_level;\r\ndebug_layer = acpi_dbg_layer;\r\n} else {\r\ndebug_level = ACPI_LV_TRACE_POINT;\r\ndebug_layer = ACPI_EXECUTER;\r\n}\r\nflags = ACPI_TRACE_ENABLED;\r\nif (!strcmp(enable_arg, "OPCODE")) {\r\nflags |= ACPI_TRACE_OPCODE;\r\n}\r\nif (once_arg && !strcmp(once_arg, "ONCE")) {\r\nflags |= ACPI_TRACE_ONESHOT;\r\n}\r\n}\r\n(void)acpi_debug_trace(acpi_db_trace_method_name,\r\ndebug_level, debug_layer, flags);\r\n}
