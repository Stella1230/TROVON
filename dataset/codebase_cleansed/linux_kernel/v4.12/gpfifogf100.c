int\r\ngf100_fifo_chan_ntfy(struct nvkm_fifo_chan *chan, u32 type,\r\nstruct nvkm_event **pevent)\r\n{\r\nswitch (type) {\r\ncase NV906F_V0_NTFY_NON_STALL_INTERRUPT:\r\n*pevent = &chan->fifo->uevent;\r\nreturn 0;\r\ncase NV906F_V0_NTFY_KILLED:\r\n*pevent = &chan->fifo->kevent;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic u32\r\ngf100_fifo_gpfifo_engine_addr(struct nvkm_engine *engine)\r\n{\r\nswitch (engine->subdev.index) {\r\ncase NVKM_ENGINE_SW : return 0;\r\ncase NVKM_ENGINE_GR : return 0x0210;\r\ncase NVKM_ENGINE_CE0 : return 0x0230;\r\ncase NVKM_ENGINE_CE1 : return 0x0240;\r\ncase NVKM_ENGINE_MSPDEC: return 0x0250;\r\ncase NVKM_ENGINE_MSPPP : return 0x0260;\r\ncase NVKM_ENGINE_MSVLD : return 0x0270;\r\ndefault:\r\nWARN_ON(1);\r\nreturn 0;\r\n}\r\n}\r\nstatic int\r\ngf100_fifo_gpfifo_engine_fini(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine, bool suspend)\r\n{\r\nconst u32 offset = gf100_fifo_gpfifo_engine_addr(engine);\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nstruct nvkm_subdev *subdev = &chan->fifo->base.engine.subdev;\r\nstruct nvkm_device *device = subdev->device;\r\nstruct nvkm_gpuobj *inst = chan->base.inst;\r\nint ret = 0;\r\nmutex_lock(&subdev->mutex);\r\nnvkm_wr32(device, 0x002634, chan->base.chid);\r\nif (nvkm_msec(device, 2000,\r\nif (nvkm_rd32(device, 0x002634) == chan->base.chid)\r\nbreak;\r\n) < 0) {\r\nnvkm_error(subdev, "channel %d [%s] kick timeout\n",\r\nchan->base.chid, chan->base.object.client->name);\r\nret = -ETIMEDOUT;\r\n}\r\nmutex_unlock(&subdev->mutex);\r\nif (ret && suspend)\r\nreturn ret;\r\nif (offset) {\r\nnvkm_kmap(inst);\r\nnvkm_wo32(inst, offset + 0x00, 0x00000000);\r\nnvkm_wo32(inst, offset + 0x04, 0x00000000);\r\nnvkm_done(inst);\r\n}\r\nreturn ret;\r\n}\r\nstatic int\r\ngf100_fifo_gpfifo_engine_init(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nconst u32 offset = gf100_fifo_gpfifo_engine_addr(engine);\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nstruct nvkm_gpuobj *inst = chan->base.inst;\r\nif (offset) {\r\nu64 addr = chan->engn[engine->subdev.index].vma.offset;\r\nnvkm_kmap(inst);\r\nnvkm_wo32(inst, offset + 0x00, lower_32_bits(addr) | 4);\r\nnvkm_wo32(inst, offset + 0x04, upper_32_bits(addr));\r\nnvkm_done(inst);\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\ngf100_fifo_gpfifo_engine_dtor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine)\r\n{\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nnvkm_gpuobj_unmap(&chan->engn[engine->subdev.index].vma);\r\nnvkm_gpuobj_del(&chan->engn[engine->subdev.index].inst);\r\n}\r\nstatic int\r\ngf100_fifo_gpfifo_engine_ctor(struct nvkm_fifo_chan *base,\r\nstruct nvkm_engine *engine,\r\nstruct nvkm_object *object)\r\n{\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nint engn = engine->subdev.index;\r\nint ret;\r\nif (!gf100_fifo_gpfifo_engine_addr(engine))\r\nreturn 0;\r\nret = nvkm_object_bind(object, NULL, 0, &chan->engn[engn].inst);\r\nif (ret)\r\nreturn ret;\r\nreturn nvkm_gpuobj_map(chan->engn[engn].inst, chan->vm,\r\nNV_MEM_ACCESS_RW, &chan->engn[engn].vma);\r\n}\r\nstatic void\r\ngf100_fifo_gpfifo_fini(struct nvkm_fifo_chan *base)\r\n{\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nstruct gf100_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nu32 coff = chan->base.chid * 8;\r\nif (!list_empty(&chan->head) && !chan->killed) {\r\ngf100_fifo_runlist_remove(fifo, chan);\r\nnvkm_mask(device, 0x003004 + coff, 0x00000001, 0x00000000);\r\ngf100_fifo_runlist_commit(fifo);\r\n}\r\ngf100_fifo_intr_engine(fifo);\r\nnvkm_wr32(device, 0x003000 + coff, 0x00000000);\r\n}\r\nstatic void\r\ngf100_fifo_gpfifo_init(struct nvkm_fifo_chan *base)\r\n{\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nstruct gf100_fifo *fifo = chan->fifo;\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nu32 addr = chan->base.inst->addr >> 12;\r\nu32 coff = chan->base.chid * 8;\r\nnvkm_wr32(device, 0x003000 + coff, 0xc0000000 | addr);\r\nif (list_empty(&chan->head) && !chan->killed) {\r\ngf100_fifo_runlist_insert(fifo, chan);\r\nnvkm_wr32(device, 0x003004 + coff, 0x001f0001);\r\ngf100_fifo_runlist_commit(fifo);\r\n}\r\n}\r\nstatic void *\r\ngf100_fifo_gpfifo_dtor(struct nvkm_fifo_chan *base)\r\n{\r\nstruct gf100_fifo_chan *chan = gf100_fifo_chan(base);\r\nnvkm_vm_ref(NULL, &chan->vm, chan->pgd);\r\nnvkm_gpuobj_del(&chan->pgd);\r\nreturn chan;\r\n}\r\nstatic int\r\ngf100_fifo_gpfifo_new(struct nvkm_fifo *base, const struct nvkm_oclass *oclass,\r\nvoid *data, u32 size, struct nvkm_object **pobject)\r\n{\r\nunion {\r\nstruct fermi_channel_gpfifo_v0 v0;\r\n} *args = data;\r\nstruct gf100_fifo *fifo = gf100_fifo(base);\r\nstruct nvkm_device *device = fifo->base.engine.subdev.device;\r\nstruct nvkm_object *parent = oclass->parent;\r\nstruct gf100_fifo_chan *chan;\r\nu64 usermem, ioffset, ilength;\r\nint ret = -ENOSYS, i;\r\nnvif_ioctl(parent, "create channel gpfifo size %d\n", size);\r\nif (!(ret = nvif_unpack(ret, &data, &size, args->v0, 0, 0, false))) {\r\nnvif_ioctl(parent, "create channel gpfifo vers %d vm %llx "\r\n"ioffset %016llx ilength %08x\n",\r\nargs->v0.version, args->v0.vm, args->v0.ioffset,\r\nargs->v0.ilength);\r\n} else\r\nreturn ret;\r\nif (!(chan = kzalloc(sizeof(*chan), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\n*pobject = &chan->base.object;\r\nchan->fifo = fifo;\r\nINIT_LIST_HEAD(&chan->head);\r\nret = nvkm_fifo_chan_ctor(&gf100_fifo_gpfifo_func, &fifo->base,\r\n0x1000, 0x1000, true, args->v0.vm, 0,\r\n(1ULL << NVKM_ENGINE_CE0) |\r\n(1ULL << NVKM_ENGINE_CE1) |\r\n(1ULL << NVKM_ENGINE_GR) |\r\n(1ULL << NVKM_ENGINE_MSPDEC) |\r\n(1ULL << NVKM_ENGINE_MSPPP) |\r\n(1ULL << NVKM_ENGINE_MSVLD) |\r\n(1ULL << NVKM_ENGINE_SW),\r\n1, fifo->user.bar.offset, 0x1000,\r\noclass, &chan->base);\r\nif (ret)\r\nreturn ret;\r\nargs->v0.chid = chan->base.chid;\r\nret = nvkm_gpuobj_new(device, 0x10000, 0x1000, false, NULL, &chan->pgd);\r\nif (ret)\r\nreturn ret;\r\nnvkm_kmap(chan->base.inst);\r\nnvkm_wo32(chan->base.inst, 0x0200, lower_32_bits(chan->pgd->addr));\r\nnvkm_wo32(chan->base.inst, 0x0204, upper_32_bits(chan->pgd->addr));\r\nnvkm_wo32(chan->base.inst, 0x0208, 0xffffffff);\r\nnvkm_wo32(chan->base.inst, 0x020c, 0x000000ff);\r\nnvkm_done(chan->base.inst);\r\nret = nvkm_vm_ref(chan->base.vm, &chan->vm, chan->pgd);\r\nif (ret)\r\nreturn ret;\r\nusermem = chan->base.chid * 0x1000;\r\nioffset = args->v0.ioffset;\r\nilength = order_base_2(args->v0.ilength / 8);\r\nnvkm_kmap(fifo->user.mem);\r\nfor (i = 0; i < 0x1000; i += 4)\r\nnvkm_wo32(fifo->user.mem, usermem + i, 0x00000000);\r\nnvkm_done(fifo->user.mem);\r\nusermem = nvkm_memory_addr(fifo->user.mem) + usermem;\r\nnvkm_kmap(chan->base.inst);\r\nnvkm_wo32(chan->base.inst, 0x08, lower_32_bits(usermem));\r\nnvkm_wo32(chan->base.inst, 0x0c, upper_32_bits(usermem));\r\nnvkm_wo32(chan->base.inst, 0x10, 0x0000face);\r\nnvkm_wo32(chan->base.inst, 0x30, 0xfffff902);\r\nnvkm_wo32(chan->base.inst, 0x48, lower_32_bits(ioffset));\r\nnvkm_wo32(chan->base.inst, 0x4c, upper_32_bits(ioffset) |\r\n(ilength << 16));\r\nnvkm_wo32(chan->base.inst, 0x54, 0x00000002);\r\nnvkm_wo32(chan->base.inst, 0x84, 0x20400000);\r\nnvkm_wo32(chan->base.inst, 0x94, 0x30000001);\r\nnvkm_wo32(chan->base.inst, 0x9c, 0x00000100);\r\nnvkm_wo32(chan->base.inst, 0xa4, 0x1f1f1f1f);\r\nnvkm_wo32(chan->base.inst, 0xa8, 0x1f1f1f1f);\r\nnvkm_wo32(chan->base.inst, 0xac, 0x0000001f);\r\nnvkm_wo32(chan->base.inst, 0xb8, 0xf8000000);\r\nnvkm_wo32(chan->base.inst, 0xf8, 0x10003080);\r\nnvkm_wo32(chan->base.inst, 0xfc, 0x10000010);\r\nnvkm_done(chan->base.inst);\r\nreturn 0;\r\n}
