static void ni903x_start(struct ni903x_wdt *wdt)\r\n{\r\nu8 control = inb(wdt->io_base + NIWD_CONTROL);\r\noutb(control | NIWD_CONTROL_RESET, wdt->io_base + NIWD_CONTROL);\r\noutb(control | NIWD_CONTROL_PET, wdt->io_base + NIWD_CONTROL);\r\n}\r\nstatic int ni903x_wdd_set_timeout(struct watchdog_device *wdd,\r\nunsigned int timeout)\r\n{\r\nstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu32 counter = timeout * (1000000000 / NIWD_PERIOD_NS);\r\noutb(((0x00FF0000 & counter) >> 16), wdt->io_base + NIWD_SEED2);\r\noutb(((0x0000FF00 & counter) >> 8), wdt->io_base + NIWD_SEED1);\r\noutb((0x000000FF & counter), wdt->io_base + NIWD_SEED0);\r\nwdd->timeout = timeout;\r\nreturn 0;\r\n}\r\nstatic unsigned int ni903x_wdd_get_timeleft(struct watchdog_device *wdd)\r\n{\r\nstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu8 control, counter0, counter1, counter2;\r\nu32 counter;\r\ncontrol = inb(wdt->io_base + NIWD_CONTROL);\r\ncontrol |= NIWD_CONTROL_CAPTURECOUNTER;\r\noutb(control, wdt->io_base + NIWD_CONTROL);\r\ncounter2 = inb(wdt->io_base + NIWD_COUNTER2);\r\ncounter1 = inb(wdt->io_base + NIWD_COUNTER1);\r\ncounter0 = inb(wdt->io_base + NIWD_COUNTER0);\r\ncounter = (counter2 << 16) | (counter1 << 8) | counter0;\r\nreturn counter / (1000000000 / NIWD_PERIOD_NS);\r\n}\r\nstatic int ni903x_wdd_ping(struct watchdog_device *wdd)\r\n{\r\nstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\r\nu8 control;\r\ncontrol = inb(wdt->io_base + NIWD_CONTROL);\r\noutb(control | NIWD_CONTROL_PET, wdt->io_base + NIWD_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int ni903x_wdd_start(struct watchdog_device *wdd)\r\n{\r\nstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\r\noutb(NIWD_CONTROL_RESET | NIWD_CONTROL_PROC_RESET,\r\nwdt->io_base + NIWD_CONTROL);\r\nni903x_wdd_set_timeout(wdd, wdd->timeout);\r\nni903x_start(wdt);\r\nreturn 0;\r\n}\r\nstatic int ni903x_wdd_stop(struct watchdog_device *wdd)\r\n{\r\nstruct ni903x_wdt *wdt = watchdog_get_drvdata(wdd);\r\noutb(NIWD_CONTROL_RESET, wdt->io_base + NIWD_CONTROL);\r\nreturn 0;\r\n}\r\nstatic acpi_status ni903x_resources(struct acpi_resource *res, void *data)\r\n{\r\nstruct ni903x_wdt *wdt = data;\r\nu16 io_size;\r\nswitch (res->type) {\r\ncase ACPI_RESOURCE_TYPE_IO:\r\nif (wdt->io_base != 0) {\r\ndev_err(wdt->dev, "too many IO resources\n");\r\nreturn AE_ERROR;\r\n}\r\nwdt->io_base = res->data.io.minimum;\r\nio_size = res->data.io.address_length;\r\nif (io_size < NIWD_IO_SIZE) {\r\ndev_err(wdt->dev, "memory region too small\n");\r\nreturn AE_ERROR;\r\n}\r\nif (!devm_request_region(wdt->dev, wdt->io_base, io_size,\r\nNIWD_NAME)) {\r\ndev_err(wdt->dev, "failed to get memory region\n");\r\nreturn AE_ERROR;\r\n}\r\nreturn AE_OK;\r\ncase ACPI_RESOURCE_TYPE_END_TAG:\r\ndefault:\r\nreturn AE_OK;\r\n}\r\n}\r\nstatic int ni903x_acpi_add(struct acpi_device *device)\r\n{\r\nstruct device *dev = &device->dev;\r\nstruct watchdog_device *wdd;\r\nstruct ni903x_wdt *wdt;\r\nacpi_status status;\r\nint ret;\r\nwdt = devm_kzalloc(dev, sizeof(*wdt), GFP_KERNEL);\r\nif (!wdt)\r\nreturn -ENOMEM;\r\ndevice->driver_data = wdt;\r\nwdt->dev = dev;\r\nstatus = acpi_walk_resources(device->handle, METHOD_NAME__CRS,\r\nni903x_resources, wdt);\r\nif (ACPI_FAILURE(status) || wdt->io_base == 0) {\r\ndev_err(dev, "failed to get resources\n");\r\nreturn -ENODEV;\r\n}\r\nwdd = &wdt->wdd;\r\nwdd->info = &ni903x_wdd_info;\r\nwdd->ops = &ni903x_wdd_ops;\r\nwdd->min_timeout = NIWD_MIN_TIMEOUT;\r\nwdd->max_timeout = NIWD_MAX_TIMEOUT;\r\nwdd->timeout = NIWD_DEFAULT_TIMEOUT;\r\nwdd->parent = dev;\r\nwatchdog_set_drvdata(wdd, wdt);\r\nwatchdog_set_nowayout(wdd, nowayout);\r\nret = watchdog_init_timeout(wdd, timeout, dev);\r\nif (ret)\r\ndev_err(dev, "unable to set timeout value, using default\n");\r\nret = watchdog_register_device(wdd);\r\nif (ret) {\r\ndev_err(dev, "failed to register watchdog\n");\r\nreturn ret;\r\n}\r\noutb(NIWD_CONTROL_RESET | NIWD_CONTROL_MODE,\r\nwdt->io_base + NIWD_CONTROL);\r\ndev_dbg(dev, "io_base=0x%04X, timeout=%d, nowayout=%d\n",\r\nwdt->io_base, timeout, nowayout);\r\nreturn 0;\r\n}\r\nstatic int ni903x_acpi_remove(struct acpi_device *device)\r\n{\r\nstruct ni903x_wdt *wdt = acpi_driver_data(device);\r\nni903x_wdd_stop(&wdt->wdd);\r\nwatchdog_unregister_device(&wdt->wdd);\r\nreturn 0;\r\n}
