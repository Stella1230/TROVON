struct section *find_section_by_name(struct elf *elf, const char *name)\r\n{\r\nstruct section *sec;\r\nlist_for_each_entry(sec, &elf->sections, list)\r\nif (!strcmp(sec->name, name))\r\nreturn sec;\r\nreturn NULL;\r\n}\r\nstatic struct section *find_section_by_index(struct elf *elf,\r\nunsigned int idx)\r\n{\r\nstruct section *sec;\r\nlist_for_each_entry(sec, &elf->sections, list)\r\nif (sec->idx == idx)\r\nreturn sec;\r\nreturn NULL;\r\n}\r\nstatic struct symbol *find_symbol_by_index(struct elf *elf, unsigned int idx)\r\n{\r\nstruct section *sec;\r\nstruct symbol *sym;\r\nlist_for_each_entry(sec, &elf->sections, list)\r\nhash_for_each_possible(sec->symbol_hash, sym, hash, idx)\r\nif (sym->idx == idx)\r\nreturn sym;\r\nreturn NULL;\r\n}\r\nstruct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset)\r\n{\r\nstruct symbol *sym;\r\nlist_for_each_entry(sym, &sec->symbol_list, list)\r\nif (sym->type != STT_SECTION &&\r\nsym->offset == offset)\r\nreturn sym;\r\nreturn NULL;\r\n}\r\nstruct symbol *find_symbol_containing(struct section *sec, unsigned long offset)\r\n{\r\nstruct symbol *sym;\r\nlist_for_each_entry(sym, &sec->symbol_list, list)\r\nif (sym->type != STT_SECTION &&\r\noffset >= sym->offset && offset < sym->offset + sym->len)\r\nreturn sym;\r\nreturn NULL;\r\n}\r\nstruct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,\r\nunsigned int len)\r\n{\r\nstruct rela *rela;\r\nunsigned long o;\r\nif (!sec->rela)\r\nreturn NULL;\r\nfor (o = offset; o < offset + len; o++)\r\nhash_for_each_possible(sec->rela->rela_hash, rela, hash, o)\r\nif (rela->offset == o)\r\nreturn rela;\r\nreturn NULL;\r\n}\r\nstruct rela *find_rela_by_dest(struct section *sec, unsigned long offset)\r\n{\r\nreturn find_rela_by_dest_range(sec, offset, 1);\r\n}\r\nstruct symbol *find_containing_func(struct section *sec, unsigned long offset)\r\n{\r\nstruct symbol *func;\r\nlist_for_each_entry(func, &sec->symbol_list, list)\r\nif (func->type == STT_FUNC && offset >= func->offset &&\r\noffset < func->offset + func->len)\r\nreturn func;\r\nreturn NULL;\r\n}\r\nstatic int read_sections(struct elf *elf)\r\n{\r\nElf_Scn *s = NULL;\r\nstruct section *sec;\r\nsize_t shstrndx, sections_nr;\r\nint i;\r\nif (elf_getshdrnum(elf->elf, &sections_nr)) {\r\nperror("elf_getshdrnum");\r\nreturn -1;\r\n}\r\nif (elf_getshdrstrndx(elf->elf, &shstrndx)) {\r\nperror("elf_getshdrstrndx");\r\nreturn -1;\r\n}\r\nfor (i = 0; i < sections_nr; i++) {\r\nsec = malloc(sizeof(*sec));\r\nif (!sec) {\r\nperror("malloc");\r\nreturn -1;\r\n}\r\nmemset(sec, 0, sizeof(*sec));\r\nINIT_LIST_HEAD(&sec->symbol_list);\r\nINIT_LIST_HEAD(&sec->rela_list);\r\nhash_init(sec->rela_hash);\r\nhash_init(sec->symbol_hash);\r\nlist_add_tail(&sec->list, &elf->sections);\r\ns = elf_getscn(elf->elf, i);\r\nif (!s) {\r\nperror("elf_getscn");\r\nreturn -1;\r\n}\r\nsec->idx = elf_ndxscn(s);\r\nif (!gelf_getshdr(s, &sec->sh)) {\r\nperror("gelf_getshdr");\r\nreturn -1;\r\n}\r\nsec->name = elf_strptr(elf->elf, shstrndx, sec->sh.sh_name);\r\nif (!sec->name) {\r\nperror("elf_strptr");\r\nreturn -1;\r\n}\r\nsec->elf_data = elf_getdata(s, NULL);\r\nif (!sec->elf_data) {\r\nperror("elf_getdata");\r\nreturn -1;\r\n}\r\nif (sec->elf_data->d_off != 0 ||\r\nsec->elf_data->d_size != sec->sh.sh_size) {\r\nWARN("unexpected data attributes for %s", sec->name);\r\nreturn -1;\r\n}\r\nsec->data = (unsigned long)sec->elf_data->d_buf;\r\nsec->len = sec->elf_data->d_size;\r\n}\r\nif (elf_nextscn(elf->elf, s)) {\r\nWARN("section entry mismatch");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int read_symbols(struct elf *elf)\r\n{\r\nstruct section *symtab;\r\nstruct symbol *sym;\r\nstruct list_head *entry, *tmp;\r\nint symbols_nr, i;\r\nsymtab = find_section_by_name(elf, ".symtab");\r\nif (!symtab) {\r\nWARN("missing symbol table");\r\nreturn -1;\r\n}\r\nsymbols_nr = symtab->sh.sh_size / symtab->sh.sh_entsize;\r\nfor (i = 0; i < symbols_nr; i++) {\r\nsym = malloc(sizeof(*sym));\r\nif (!sym) {\r\nperror("malloc");\r\nreturn -1;\r\n}\r\nmemset(sym, 0, sizeof(*sym));\r\nsym->idx = i;\r\nif (!gelf_getsym(symtab->elf_data, i, &sym->sym)) {\r\nperror("gelf_getsym");\r\ngoto err;\r\n}\r\nsym->name = elf_strptr(elf->elf, symtab->sh.sh_link,\r\nsym->sym.st_name);\r\nif (!sym->name) {\r\nperror("elf_strptr");\r\ngoto err;\r\n}\r\nsym->type = GELF_ST_TYPE(sym->sym.st_info);\r\nsym->bind = GELF_ST_BIND(sym->sym.st_info);\r\nif (sym->sym.st_shndx > SHN_UNDEF &&\r\nsym->sym.st_shndx < SHN_LORESERVE) {\r\nsym->sec = find_section_by_index(elf,\r\nsym->sym.st_shndx);\r\nif (!sym->sec) {\r\nWARN("couldn't find section for symbol %s",\r\nsym->name);\r\ngoto err;\r\n}\r\nif (sym->type == STT_SECTION) {\r\nsym->name = sym->sec->name;\r\nsym->sec->sym = sym;\r\n}\r\n} else\r\nsym->sec = find_section_by_index(elf, 0);\r\nsym->offset = sym->sym.st_value;\r\nsym->len = sym->sym.st_size;\r\nentry = &sym->sec->symbol_list;\r\nlist_for_each_prev(tmp, &sym->sec->symbol_list) {\r\nstruct symbol *s;\r\ns = list_entry(tmp, struct symbol, list);\r\nif (sym->offset > s->offset) {\r\nentry = tmp;\r\nbreak;\r\n}\r\nif (sym->offset == s->offset && sym->len >= s->len) {\r\nentry = tmp;\r\nbreak;\r\n}\r\n}\r\nlist_add(&sym->list, entry);\r\nhash_add(sym->sec->symbol_hash, &sym->hash, sym->idx);\r\n}\r\nreturn 0;\r\nerr:\r\nfree(sym);\r\nreturn -1;\r\n}\r\nstatic int read_relas(struct elf *elf)\r\n{\r\nstruct section *sec;\r\nstruct rela *rela;\r\nint i;\r\nunsigned int symndx;\r\nlist_for_each_entry(sec, &elf->sections, list) {\r\nif (sec->sh.sh_type != SHT_RELA)\r\ncontinue;\r\nsec->base = find_section_by_name(elf, sec->name + 5);\r\nif (!sec->base) {\r\nWARN("can't find base section for rela section %s",\r\nsec->name);\r\nreturn -1;\r\n}\r\nsec->base->rela = sec;\r\nfor (i = 0; i < sec->sh.sh_size / sec->sh.sh_entsize; i++) {\r\nrela = malloc(sizeof(*rela));\r\nif (!rela) {\r\nperror("malloc");\r\nreturn -1;\r\n}\r\nmemset(rela, 0, sizeof(*rela));\r\nif (!gelf_getrela(sec->elf_data, i, &rela->rela)) {\r\nperror("gelf_getrela");\r\nreturn -1;\r\n}\r\nrela->type = GELF_R_TYPE(rela->rela.r_info);\r\nrela->addend = rela->rela.r_addend;\r\nrela->offset = rela->rela.r_offset;\r\nsymndx = GELF_R_SYM(rela->rela.r_info);\r\nrela->sym = find_symbol_by_index(elf, symndx);\r\nif (!rela->sym) {\r\nWARN("can't find rela entry symbol %d for %s",\r\nsymndx, sec->name);\r\nreturn -1;\r\n}\r\nlist_add_tail(&rela->list, &sec->rela_list);\r\nhash_add(sec->rela_hash, &rela->hash, rela->offset);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstruct elf *elf_open(const char *name)\r\n{\r\nstruct elf *elf;\r\nelf_version(EV_CURRENT);\r\nelf = malloc(sizeof(*elf));\r\nif (!elf) {\r\nperror("malloc");\r\nreturn NULL;\r\n}\r\nmemset(elf, 0, sizeof(*elf));\r\nINIT_LIST_HEAD(&elf->sections);\r\nelf->name = strdup(name);\r\nif (!elf->name) {\r\nperror("strdup");\r\ngoto err;\r\n}\r\nelf->fd = open(name, O_RDONLY);\r\nif (elf->fd == -1) {\r\nperror("open");\r\ngoto err;\r\n}\r\nelf->elf = elf_begin(elf->fd, ELF_C_READ_MMAP, NULL);\r\nif (!elf->elf) {\r\nperror("elf_begin");\r\ngoto err;\r\n}\r\nif (!gelf_getehdr(elf->elf, &elf->ehdr)) {\r\nperror("gelf_getehdr");\r\ngoto err;\r\n}\r\nif (read_sections(elf))\r\ngoto err;\r\nif (read_symbols(elf))\r\ngoto err;\r\nif (read_relas(elf))\r\ngoto err;\r\nreturn elf;\r\nerr:\r\nelf_close(elf);\r\nreturn NULL;\r\n}\r\nvoid elf_close(struct elf *elf)\r\n{\r\nstruct section *sec, *tmpsec;\r\nstruct symbol *sym, *tmpsym;\r\nstruct rela *rela, *tmprela;\r\nlist_for_each_entry_safe(sec, tmpsec, &elf->sections, list) {\r\nlist_for_each_entry_safe(sym, tmpsym, &sec->symbol_list, list) {\r\nlist_del(&sym->list);\r\nhash_del(&sym->hash);\r\nfree(sym);\r\n}\r\nlist_for_each_entry_safe(rela, tmprela, &sec->rela_list, list) {\r\nlist_del(&rela->list);\r\nhash_del(&rela->hash);\r\nfree(rela);\r\n}\r\nlist_del(&sec->list);\r\nfree(sec);\r\n}\r\nif (elf->name)\r\nfree(elf->name);\r\nif (elf->fd > 0)\r\nclose(elf->fd);\r\nif (elf->elf)\r\nelf_end(elf->elf);\r\nfree(elf);\r\n}
