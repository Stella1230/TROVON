int drm_name_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_minor *minor = node->minor;\r\nstruct drm_device *dev = minor->dev;\r\nstruct drm_master *master;\r\nmutex_lock(&dev->master_mutex);\r\nmaster = dev->master;\r\nseq_printf(m, "%s", dev->driver->name);\r\nif (dev->dev)\r\nseq_printf(m, " dev=%s", dev_name(dev->dev));\r\nif (master && master->unique)\r\nseq_printf(m, " master=%s", master->unique);\r\nif (dev->unique)\r\nseq_printf(m, " unique=%s", dev->unique);\r\nseq_printf(m, "\n");\r\nmutex_unlock(&dev->master_mutex);\r\nreturn 0;\r\n}\r\nint drm_clients_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nstruct drm_file *priv;\r\nkuid_t uid;\r\nseq_printf(m,\r\n"%20s %5s %3s master a %5s %10s\n",\r\n"command",\r\n"pid",\r\n"dev",\r\n"uid",\r\n"magic");\r\nmutex_lock(&dev->filelist_mutex);\r\nlist_for_each_entry_reverse(priv, &dev->filelist, lhead) {\r\nstruct task_struct *task;\r\nrcu_read_lock();\r\ntask = pid_task(priv->pid, PIDTYPE_PID);\r\nuid = task ? __task_cred(task)->euid : GLOBAL_ROOT_UID;\r\nseq_printf(m, "%20s %5d %3d %c %c %5d %10u\n",\r\ntask ? task->comm : "<unknown>",\r\npid_vnr(priv->pid),\r\npriv->minor->index,\r\ndrm_is_current_master(priv) ? 'y' : 'n',\r\npriv->authenticated ? 'y' : 'n',\r\nfrom_kuid_munged(seq_user_ns(m), uid),\r\npriv->magic);\r\nrcu_read_unlock();\r\n}\r\nmutex_unlock(&dev->filelist_mutex);\r\nreturn 0;\r\n}\r\nstatic int drm_gem_one_name_info(int id, void *ptr, void *data)\r\n{\r\nstruct drm_gem_object *obj = ptr;\r\nstruct seq_file *m = data;\r\nseq_printf(m, "%6d %8zd %7d %8d\n",\r\nobj->name, obj->size,\r\nobj->handle_count,\r\nkref_read(&obj->refcount));\r\nreturn 0;\r\n}\r\nint drm_gem_name_info(struct seq_file *m, void *data)\r\n{\r\nstruct drm_info_node *node = (struct drm_info_node *) m->private;\r\nstruct drm_device *dev = node->minor->dev;\r\nseq_printf(m, " name size handles refcount\n");\r\nmutex_lock(&dev->object_name_lock);\r\nidr_for_each(&dev->object_name_idr, drm_gem_one_name_info, m);\r\nmutex_unlock(&dev->object_name_lock);\r\nreturn 0;\r\n}
