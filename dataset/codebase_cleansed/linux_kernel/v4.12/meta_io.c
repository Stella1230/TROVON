static int gfs2_aspace_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nstruct buffer_head *bh, *head;\r\nint nr_underway = 0;\r\nint write_flags = REQ_META | REQ_PRIO | wbc_to_write_flags(wbc);\r\nBUG_ON(!PageLocked(page));\r\nBUG_ON(!page_has_buffers(page));\r\nhead = page_buffers(page);\r\nbh = head;\r\ndo {\r\nif (!buffer_mapped(bh))\r\ncontinue;\r\nif (wbc->sync_mode != WB_SYNC_NONE) {\r\nlock_buffer(bh);\r\n} else if (!trylock_buffer(bh)) {\r\nredirty_page_for_writepage(wbc, page);\r\ncontinue;\r\n}\r\nif (test_clear_buffer_dirty(bh)) {\r\nmark_buffer_async_write(bh);\r\n} else {\r\nunlock_buffer(bh);\r\n}\r\n} while ((bh = bh->b_this_page) != head);\r\nBUG_ON(PageWriteback(page));\r\nset_page_writeback(page);\r\ndo {\r\nstruct buffer_head *next = bh->b_this_page;\r\nif (buffer_async_write(bh)) {\r\nsubmit_bh(REQ_OP_WRITE, write_flags, bh);\r\nnr_underway++;\r\n}\r\nbh = next;\r\n} while (bh != head);\r\nunlock_page(page);\r\nif (nr_underway == 0)\r\nend_page_writeback(page);\r\nreturn 0;\r\n}\r\nstruct buffer_head *gfs2_getbuf(struct gfs2_glock *gl, u64 blkno, int create)\r\n{\r\nstruct address_space *mapping = gfs2_glock2aspace(gl);\r\nstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\r\nstruct page *page;\r\nstruct buffer_head *bh;\r\nunsigned int shift;\r\nunsigned long index;\r\nunsigned int bufnum;\r\nif (mapping == NULL)\r\nmapping = &sdp->sd_aspace;\r\nshift = PAGE_SHIFT - sdp->sd_sb.sb_bsize_shift;\r\nindex = blkno >> shift;\r\nbufnum = blkno - (index << shift);\r\nif (create) {\r\nfor (;;) {\r\npage = grab_cache_page(mapping, index);\r\nif (page)\r\nbreak;\r\nyield();\r\n}\r\n} else {\r\npage = find_get_page_flags(mapping, index,\r\nFGP_LOCK|FGP_ACCESSED);\r\nif (!page)\r\nreturn NULL;\r\n}\r\nif (!page_has_buffers(page))\r\ncreate_empty_buffers(page, sdp->sd_sb.sb_bsize, 0);\r\nfor (bh = page_buffers(page); bufnum--; bh = bh->b_this_page)\r\n;\r\nget_bh(bh);\r\nif (!buffer_mapped(bh))\r\nmap_bh(bh, sdp->sd_vfs, blkno);\r\nunlock_page(page);\r\nput_page(page);\r\nreturn bh;\r\n}\r\nstatic void meta_prep_new(struct buffer_head *bh)\r\n{\r\nstruct gfs2_meta_header *mh = (struct gfs2_meta_header *)bh->b_data;\r\nlock_buffer(bh);\r\nclear_buffer_dirty(bh);\r\nset_buffer_uptodate(bh);\r\nunlock_buffer(bh);\r\nmh->mh_magic = cpu_to_be32(GFS2_MAGIC);\r\n}\r\nstruct buffer_head *gfs2_meta_new(struct gfs2_glock *gl, u64 blkno)\r\n{\r\nstruct buffer_head *bh;\r\nbh = gfs2_getbuf(gl, blkno, CREATE);\r\nmeta_prep_new(bh);\r\nreturn bh;\r\n}\r\nstatic void gfs2_meta_read_endio(struct bio *bio)\r\n{\r\nstruct bio_vec *bvec;\r\nint i;\r\nbio_for_each_segment_all(bvec, bio, i) {\r\nstruct page *page = bvec->bv_page;\r\nstruct buffer_head *bh = page_buffers(page);\r\nunsigned int len = bvec->bv_len;\r\nwhile (bh_offset(bh) < bvec->bv_offset)\r\nbh = bh->b_this_page;\r\ndo {\r\nstruct buffer_head *next = bh->b_this_page;\r\nlen -= bh->b_size;\r\nbh->b_end_io(bh, !bio->bi_error);\r\nbh = next;\r\n} while (bh && len);\r\n}\r\nbio_put(bio);\r\n}\r\nstatic void gfs2_submit_bhs(int op, int op_flags, struct buffer_head *bhs[],\r\nint num)\r\n{\r\nwhile (num > 0) {\r\nstruct buffer_head *bh = *bhs;\r\nstruct bio *bio;\r\nbio = bio_alloc(GFP_NOIO, num);\r\nbio->bi_iter.bi_sector = bh->b_blocknr * (bh->b_size >> 9);\r\nbio->bi_bdev = bh->b_bdev;\r\nwhile (num > 0) {\r\nbh = *bhs;\r\nif (!bio_add_page(bio, bh->b_page, bh->b_size, bh_offset(bh))) {\r\nBUG_ON(bio->bi_iter.bi_size == 0);\r\nbreak;\r\n}\r\nbhs++;\r\nnum--;\r\n}\r\nbio->bi_end_io = gfs2_meta_read_endio;\r\nbio_set_op_attrs(bio, op, op_flags);\r\nsubmit_bio(bio);\r\n}\r\n}\r\nint gfs2_meta_read(struct gfs2_glock *gl, u64 blkno, int flags,\r\nint rahead, struct buffer_head **bhp)\r\n{\r\nstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\r\nstruct buffer_head *bh, *bhs[2];\r\nint num = 0;\r\nif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags))) {\r\n*bhp = NULL;\r\nreturn -EIO;\r\n}\r\n*bhp = bh = gfs2_getbuf(gl, blkno, CREATE);\r\nlock_buffer(bh);\r\nif (buffer_uptodate(bh)) {\r\nunlock_buffer(bh);\r\nflags &= ~DIO_WAIT;\r\n} else {\r\nbh->b_end_io = end_buffer_read_sync;\r\nget_bh(bh);\r\nbhs[num++] = bh;\r\n}\r\nif (rahead) {\r\nbh = gfs2_getbuf(gl, blkno + 1, CREATE);\r\nlock_buffer(bh);\r\nif (buffer_uptodate(bh)) {\r\nunlock_buffer(bh);\r\nbrelse(bh);\r\n} else {\r\nbh->b_end_io = end_buffer_read_sync;\r\nbhs[num++] = bh;\r\n}\r\n}\r\ngfs2_submit_bhs(REQ_OP_READ, REQ_META | REQ_PRIO, bhs, num);\r\nif (!(flags & DIO_WAIT))\r\nreturn 0;\r\nbh = *bhp;\r\nwait_on_buffer(bh);\r\nif (unlikely(!buffer_uptodate(bh))) {\r\nstruct gfs2_trans *tr = current->journal_info;\r\nif (tr && test_bit(TR_TOUCHED, &tr->tr_flags))\r\ngfs2_io_error_bh(sdp, bh);\r\nbrelse(bh);\r\n*bhp = NULL;\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nint gfs2_meta_wait(struct gfs2_sbd *sdp, struct buffer_head *bh)\r\n{\r\nif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\r\nreturn -EIO;\r\nwait_on_buffer(bh);\r\nif (!buffer_uptodate(bh)) {\r\nstruct gfs2_trans *tr = current->journal_info;\r\nif (tr && test_bit(TR_TOUCHED, &tr->tr_flags))\r\ngfs2_io_error_bh(sdp, bh);\r\nreturn -EIO;\r\n}\r\nif (unlikely(test_bit(SDF_SHUTDOWN, &sdp->sd_flags)))\r\nreturn -EIO;\r\nreturn 0;\r\n}\r\nvoid gfs2_remove_from_journal(struct buffer_head *bh, int meta)\r\n{\r\nstruct address_space *mapping = bh->b_page->mapping;\r\nstruct gfs2_sbd *sdp = gfs2_mapping2sbd(mapping);\r\nstruct gfs2_bufdata *bd = bh->b_private;\r\nstruct gfs2_trans *tr = current->journal_info;\r\nint was_pinned = 0;\r\nif (test_clear_buffer_pinned(bh)) {\r\ntrace_gfs2_pin(bd, 0);\r\natomic_dec(&sdp->sd_log_pinned);\r\nlist_del_init(&bd->bd_list);\r\nif (meta == REMOVE_META)\r\ntr->tr_num_buf_rm++;\r\nelse\r\ntr->tr_num_databuf_rm++;\r\nset_bit(TR_TOUCHED, &tr->tr_flags);\r\nwas_pinned = 1;\r\nbrelse(bh);\r\n}\r\nif (bd) {\r\nspin_lock(&sdp->sd_ail_lock);\r\nif (bd->bd_tr) {\r\ngfs2_trans_add_revoke(sdp, bd);\r\n} else if (was_pinned) {\r\nbh->b_private = NULL;\r\nkmem_cache_free(gfs2_bufdata_cachep, bd);\r\n}\r\nspin_unlock(&sdp->sd_ail_lock);\r\n}\r\nclear_buffer_dirty(bh);\r\nclear_buffer_uptodate(bh);\r\n}\r\nvoid gfs2_meta_wipe(struct gfs2_inode *ip, u64 bstart, u32 blen)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\r\nstruct buffer_head *bh;\r\nwhile (blen) {\r\nbh = gfs2_getbuf(ip->i_gl, bstart, NO_CREATE);\r\nif (bh) {\r\nlock_buffer(bh);\r\ngfs2_log_lock(sdp);\r\ngfs2_remove_from_journal(bh, REMOVE_META);\r\ngfs2_log_unlock(sdp);\r\nunlock_buffer(bh);\r\nbrelse(bh);\r\n}\r\nbstart++;\r\nblen--;\r\n}\r\n}\r\nint gfs2_meta_indirect_buffer(struct gfs2_inode *ip, int height, u64 num,\r\nstruct buffer_head **bhp)\r\n{\r\nstruct gfs2_sbd *sdp = GFS2_SB(&ip->i_inode);\r\nstruct gfs2_glock *gl = ip->i_gl;\r\nstruct buffer_head *bh;\r\nint ret = 0;\r\nu32 mtype = height ? GFS2_METATYPE_IN : GFS2_METATYPE_DI;\r\nint rahead = 0;\r\nif (num == ip->i_no_addr)\r\nrahead = ip->i_rahead;\r\nret = gfs2_meta_read(gl, num, DIO_WAIT, rahead, &bh);\r\nif (ret == 0 && gfs2_metatype_check(sdp, bh, mtype)) {\r\nbrelse(bh);\r\nret = -EIO;\r\n}\r\n*bhp = bh;\r\nreturn ret;\r\n}\r\nstruct buffer_head *gfs2_meta_ra(struct gfs2_glock *gl, u64 dblock, u32 extlen)\r\n{\r\nstruct gfs2_sbd *sdp = gl->gl_name.ln_sbd;\r\nstruct buffer_head *first_bh, *bh;\r\nu32 max_ra = gfs2_tune_get(sdp, gt_max_readahead) >>\r\nsdp->sd_sb.sb_bsize_shift;\r\nBUG_ON(!extlen);\r\nif (max_ra < 1)\r\nmax_ra = 1;\r\nif (extlen > max_ra)\r\nextlen = max_ra;\r\nfirst_bh = gfs2_getbuf(gl, dblock, CREATE);\r\nif (buffer_uptodate(first_bh))\r\ngoto out;\r\nif (!buffer_locked(first_bh))\r\nll_rw_block(REQ_OP_READ, REQ_META, 1, &first_bh);\r\ndblock++;\r\nextlen--;\r\nwhile (extlen) {\r\nbh = gfs2_getbuf(gl, dblock, CREATE);\r\nif (!buffer_uptodate(bh) && !buffer_locked(bh))\r\nll_rw_block(REQ_OP_READ, REQ_RAHEAD | REQ_META, 1, &bh);\r\nbrelse(bh);\r\ndblock++;\r\nextlen--;\r\nif (!buffer_locked(first_bh) && buffer_uptodate(first_bh))\r\ngoto out;\r\n}\r\nwait_on_buffer(first_bh);\r\nout:\r\nreturn first_bh;\r\n}
