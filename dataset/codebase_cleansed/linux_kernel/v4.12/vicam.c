static int vicam_control_msg(struct gspca_dev *gspca_dev, u8 request,\r\nu16 value, u16 index, u8 *data, u16 len)\r\n{\r\nint ret;\r\nret = usb_control_msg(gspca_dev->dev,\r\nusb_sndctrlpipe(gspca_dev->dev, 0),\r\nrequest,\r\nUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\r\nvalue, index, data, len, 1000);\r\nif (ret < 0)\r\npr_err("control msg req %02X error %d\n", request, ret);\r\nreturn ret;\r\n}\r\nstatic int vicam_set_camera_power(struct gspca_dev *gspca_dev, int state)\r\n{\r\nint ret;\r\nret = vicam_control_msg(gspca_dev, 0x50, state, 0, NULL, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nif (state)\r\nret = vicam_control_msg(gspca_dev, 0x55, 1, 0, NULL, 0);\r\nreturn ret;\r\n}\r\nstatic int vicam_read_frame(struct gspca_dev *gspca_dev, u8 *data, int size)\r\n{\r\nint ret, unscaled_height, act_len = 0;\r\nu8 *req_data = gspca_dev->usb_buf;\r\ns32 expo = v4l2_ctrl_g_ctrl(gspca_dev->exposure);\r\ns32 gain = v4l2_ctrl_g_ctrl(gspca_dev->gain);\r\nmemset(req_data, 0, 16);\r\nreq_data[0] = gain;\r\nif (gspca_dev->pixfmt.width == 256)\r\nreq_data[1] |= 0x01;\r\nif (gspca_dev->pixfmt.height <= 122) {\r\nreq_data[1] |= 0x10;\r\nunscaled_height = gspca_dev->pixfmt.height * 2;\r\n} else\r\nunscaled_height = gspca_dev->pixfmt.height;\r\nreq_data[2] = 0x90;\r\nif (unscaled_height <= 200)\r\nreq_data[3] = 0x06;\r\nelse if (unscaled_height <= 242)\r\nreq_data[3] = 0x07;\r\nelse\r\nreq_data[3] = 0x08;\r\nif (expo < 256) {\r\nreq_data[4] = 255 - expo;\r\nreq_data[5] = 0x00;\r\nreq_data[6] = 0x00;\r\nreq_data[7] = 0x01;\r\n} else {\r\nreq_data[4] = 0x00;\r\nreq_data[5] = 0x00;\r\nreq_data[6] = expo & 0xFF;\r\nreq_data[7] = expo >> 8;\r\n}\r\nreq_data[8] = ((244 - unscaled_height) / 2) & ~0x01;\r\nmutex_lock(&gspca_dev->usb_lock);\r\nret = vicam_control_msg(gspca_dev, 0x51, 0x80, 0, req_data, 16);\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nif (ret < 0)\r\nreturn ret;\r\nret = usb_bulk_msg(gspca_dev->dev,\r\nusb_rcvbulkpipe(gspca_dev->dev, 0x81),\r\ndata, size, &act_len, 10000);\r\nif (ret < 0 || act_len != size) {\r\npr_err("bulk read fail (%d) len %d/%d\n",\r\nret, act_len, size);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nstatic void vicam_dostream(struct work_struct *work)\r\n{\r\nstruct sd *sd = container_of(work, struct sd, work_struct);\r\nstruct gspca_dev *gspca_dev = &sd->gspca_dev;\r\nint ret, frame_sz;\r\nu8 *buffer;\r\nframe_sz = gspca_dev->cam.cam_mode[gspca_dev->curr_mode].sizeimage +\r\nHEADER_SIZE;\r\nbuffer = kmalloc(frame_sz, GFP_KERNEL | GFP_DMA);\r\nif (!buffer) {\r\npr_err("Couldn't allocate USB buffer\n");\r\ngoto exit;\r\n}\r\nwhile (gspca_dev->present && gspca_dev->streaming) {\r\n#ifdef CONFIG_PM\r\nif (gspca_dev->frozen)\r\nbreak;\r\n#endif\r\nret = vicam_read_frame(gspca_dev, buffer, frame_sz);\r\nif (ret < 0)\r\nbreak;\r\ngspca_frame_add(gspca_dev, FIRST_PACKET,\r\nbuffer + HEADER_SIZE,\r\nframe_sz - HEADER_SIZE);\r\ngspca_frame_add(gspca_dev, LAST_PACKET, NULL, 0);\r\n}\r\nexit:\r\nkfree(buffer);\r\n}\r\nstatic int sd_config(struct gspca_dev *gspca_dev,\r\nconst struct usb_device_id *id)\r\n{\r\nstruct cam *cam = &gspca_dev->cam;\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\ncam->bulk = 1;\r\ncam->bulk_size = 64;\r\ncam->cam_mode = vicam_mode;\r\ncam->nmodes = ARRAY_SIZE(vicam_mode);\r\nINIT_WORK(&sd->work_struct, vicam_dostream);\r\nreturn 0;\r\n}\r\nstatic int sd_init(struct gspca_dev *gspca_dev)\r\n{\r\nint ret;\r\nconst struct ihex_binrec *rec;\r\nconst struct firmware *uninitialized_var(fw);\r\nu8 *firmware_buf;\r\nret = request_ihex_firmware(&fw, VICAM_FIRMWARE,\r\n&gspca_dev->dev->dev);\r\nif (ret) {\r\npr_err("Failed to load \"vicam/firmware.fw\": %d\n", ret);\r\nreturn ret;\r\n}\r\nfirmware_buf = kmalloc(PAGE_SIZE, GFP_KERNEL);\r\nif (!firmware_buf) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nfor (rec = (void *)fw->data; rec; rec = ihex_next_binrec(rec)) {\r\nmemcpy(firmware_buf, rec->data, be16_to_cpu(rec->len));\r\nret = vicam_control_msg(gspca_dev, 0xff, 0, 0, firmware_buf,\r\nbe16_to_cpu(rec->len));\r\nif (ret < 0)\r\nbreak;\r\n}\r\nkfree(firmware_buf);\r\nexit:\r\nrelease_firmware(fw);\r\nreturn ret;\r\n}\r\nstatic int sd_start(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *sd = (struct sd *)gspca_dev;\r\nint ret;\r\nret = vicam_set_camera_power(gspca_dev, 1);\r\nif (ret < 0)\r\nreturn ret;\r\nschedule_work(&sd->work_struct);\r\nreturn 0;\r\n}\r\nstatic void sd_stop0(struct gspca_dev *gspca_dev)\r\n{\r\nstruct sd *dev = (struct sd *)gspca_dev;\r\nmutex_unlock(&gspca_dev->usb_lock);\r\nflush_work(&dev->work_struct);\r\nmutex_lock(&gspca_dev->usb_lock);\r\nif (gspca_dev->present)\r\nvicam_set_camera_power(gspca_dev, 0);\r\n}\r\nstatic int sd_init_controls(struct gspca_dev *gspca_dev)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &gspca_dev->ctrl_handler;\r\ngspca_dev->vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 2);\r\ngspca_dev->exposure = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_EXPOSURE, 0, 2047, 1, 256);\r\ngspca_dev->gain = v4l2_ctrl_new_std(hdl, NULL,\r\nV4L2_CID_GAIN, 0, 255, 1, 200);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nreturn 0;\r\n}\r\nstatic int sd_probe(struct usb_interface *intf,\r\nconst struct usb_device_id *id)\r\n{\r\nreturn gspca_dev_probe(intf, id,\r\n&sd_desc,\r\nsizeof(struct sd),\r\nTHIS_MODULE);\r\n}
