__be32\r\nnfsd4_block_encode_layoutget(struct xdr_stream *xdr,\r\nstruct nfsd4_layoutget *lgp)\r\n{\r\nstruct pnfs_block_extent *b = lgp->lg_content;\r\nint len = sizeof(__be32) + 5 * sizeof(__be64) + sizeof(__be32);\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, sizeof(__be32) + len);\r\nif (!p)\r\nreturn nfserr_toosmall;\r\n*p++ = cpu_to_be32(len);\r\n*p++ = cpu_to_be32(1);\r\np = xdr_encode_opaque_fixed(p, &b->vol_id,\r\nsizeof(struct nfsd4_deviceid));\r\np = xdr_encode_hyper(p, b->foff);\r\np = xdr_encode_hyper(p, b->len);\r\np = xdr_encode_hyper(p, b->soff);\r\n*p++ = cpu_to_be32(b->es);\r\nreturn 0;\r\n}\r\nstatic int\r\nnfsd4_block_encode_volume(struct xdr_stream *xdr, struct pnfs_block_volume *b)\r\n{\r\n__be32 *p;\r\nint len;\r\nswitch (b->type) {\r\ncase PNFS_BLOCK_VOLUME_SIMPLE:\r\nlen = 4 + 4 + 8 + 4 + (XDR_QUADLEN(b->simple.sig_len) << 2);\r\np = xdr_reserve_space(xdr, len);\r\nif (!p)\r\nreturn -ETOOSMALL;\r\n*p++ = cpu_to_be32(b->type);\r\n*p++ = cpu_to_be32(1);\r\np = xdr_encode_hyper(p, b->simple.offset);\r\np = xdr_encode_opaque(p, b->simple.sig, b->simple.sig_len);\r\nbreak;\r\ncase PNFS_BLOCK_VOLUME_SCSI:\r\nlen = 4 + 4 + 4 + 4 + (XDR_QUADLEN(b->scsi.designator_len) << 2) + 8;\r\np = xdr_reserve_space(xdr, len);\r\nif (!p)\r\nreturn -ETOOSMALL;\r\n*p++ = cpu_to_be32(b->type);\r\n*p++ = cpu_to_be32(b->scsi.code_set);\r\n*p++ = cpu_to_be32(b->scsi.designator_type);\r\np = xdr_encode_opaque(p, b->scsi.designator, b->scsi.designator_len);\r\np = xdr_encode_hyper(p, b->scsi.pr_key);\r\nbreak;\r\ndefault:\r\nreturn -ENOTSUPP;\r\n}\r\nreturn len;\r\n}\r\n__be32\r\nnfsd4_block_encode_getdeviceinfo(struct xdr_stream *xdr,\r\nstruct nfsd4_getdeviceinfo *gdp)\r\n{\r\nstruct pnfs_block_deviceaddr *dev = gdp->gd_device;\r\nint len = sizeof(__be32), ret, i;\r\n__be32 *p;\r\np = xdr_reserve_space(xdr, len + sizeof(__be32));\r\nif (!p)\r\nreturn nfserr_resource;\r\nfor (i = 0; i < dev->nr_volumes; i++) {\r\nret = nfsd4_block_encode_volume(xdr, &dev->volumes[i]);\r\nif (ret < 0)\r\nreturn nfserrno(ret);\r\nlen += ret;\r\n}\r\n*p++ = cpu_to_be32(len);\r\n*p++ = cpu_to_be32(dev->nr_volumes);\r\nreturn 0;\r\n}\r\nint\r\nnfsd4_block_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\r\nu32 block_size)\r\n{\r\nstruct iomap *iomaps;\r\nu32 nr_iomaps, i;\r\nif (len < sizeof(u32)) {\r\ndprintk("%s: extent array too small: %u\n", __func__, len);\r\nreturn -EINVAL;\r\n}\r\nlen -= sizeof(u32);\r\nif (len % PNFS_BLOCK_EXTENT_SIZE) {\r\ndprintk("%s: extent array invalid: %u\n", __func__, len);\r\nreturn -EINVAL;\r\n}\r\nnr_iomaps = be32_to_cpup(p++);\r\nif (nr_iomaps != len / PNFS_BLOCK_EXTENT_SIZE) {\r\ndprintk("%s: extent array size mismatch: %u/%u\n",\r\n__func__, len, nr_iomaps);\r\nreturn -EINVAL;\r\n}\r\niomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\r\nif (!iomaps) {\r\ndprintk("%s: failed to allocate extent array\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < nr_iomaps; i++) {\r\nstruct pnfs_block_extent bex;\r\nmemcpy(&bex.vol_id, p, sizeof(struct nfsd4_deviceid));\r\np += XDR_QUADLEN(sizeof(struct nfsd4_deviceid));\r\np = xdr_decode_hyper(p, &bex.foff);\r\nif (bex.foff & (block_size - 1)) {\r\ndprintk("%s: unaligned offset 0x%llx\n",\r\n__func__, bex.foff);\r\ngoto fail;\r\n}\r\np = xdr_decode_hyper(p, &bex.len);\r\nif (bex.len & (block_size - 1)) {\r\ndprintk("%s: unaligned length 0x%llx\n",\r\n__func__, bex.foff);\r\ngoto fail;\r\n}\r\np = xdr_decode_hyper(p, &bex.soff);\r\nif (bex.soff & (block_size - 1)) {\r\ndprintk("%s: unaligned disk offset 0x%llx\n",\r\n__func__, bex.soff);\r\ngoto fail;\r\n}\r\nbex.es = be32_to_cpup(p++);\r\nif (bex.es != PNFS_BLOCK_READWRITE_DATA) {\r\ndprintk("%s: incorrect extent state %d\n",\r\n__func__, bex.es);\r\ngoto fail;\r\n}\r\niomaps[i].offset = bex.foff;\r\niomaps[i].length = bex.len;\r\n}\r\n*iomapp = iomaps;\r\nreturn nr_iomaps;\r\nfail:\r\nkfree(iomaps);\r\nreturn -EINVAL;\r\n}\r\nint\r\nnfsd4_scsi_decode_layoutupdate(__be32 *p, u32 len, struct iomap **iomapp,\r\nu32 block_size)\r\n{\r\nstruct iomap *iomaps;\r\nu32 nr_iomaps, expected, i;\r\nif (len < sizeof(u32)) {\r\ndprintk("%s: extent array too small: %u\n", __func__, len);\r\nreturn -EINVAL;\r\n}\r\nnr_iomaps = be32_to_cpup(p++);\r\nexpected = sizeof(__be32) + nr_iomaps * PNFS_SCSI_RANGE_SIZE;\r\nif (len != expected) {\r\ndprintk("%s: extent array size mismatch: %u/%u\n",\r\n__func__, len, expected);\r\nreturn -EINVAL;\r\n}\r\niomaps = kcalloc(nr_iomaps, sizeof(*iomaps), GFP_KERNEL);\r\nif (!iomaps) {\r\ndprintk("%s: failed to allocate extent array\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < nr_iomaps; i++) {\r\nu64 val;\r\np = xdr_decode_hyper(p, &val);\r\nif (val & (block_size - 1)) {\r\ndprintk("%s: unaligned offset 0x%llx\n", __func__, val);\r\ngoto fail;\r\n}\r\niomaps[i].offset = val;\r\np = xdr_decode_hyper(p, &val);\r\nif (val & (block_size - 1)) {\r\ndprintk("%s: unaligned length 0x%llx\n", __func__, val);\r\ngoto fail;\r\n}\r\niomaps[i].length = val;\r\n}\r\n*iomapp = iomaps;\r\nreturn nr_iomaps;\r\nfail:\r\nkfree(iomaps);\r\nreturn -EINVAL;\r\n}
