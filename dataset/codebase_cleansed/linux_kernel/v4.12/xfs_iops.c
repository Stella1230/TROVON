static int\r\nxfs_initxattrs(\r\nstruct inode *inode,\r\nconst struct xattr *xattr_array,\r\nvoid *fs_info)\r\n{\r\nconst struct xattr *xattr;\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nint error = 0;\r\nfor (xattr = xattr_array; xattr->name != NULL; xattr++) {\r\nerror = xfs_attr_set(ip, xattr->name, xattr->value,\r\nxattr->value_len, ATTR_SECURE);\r\nif (error < 0)\r\nbreak;\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_init_security(\r\nstruct inode *inode,\r\nstruct inode *dir,\r\nconst struct qstr *qstr)\r\n{\r\nreturn security_inode_init_security(inode, dir, qstr,\r\n&xfs_initxattrs, NULL);\r\n}\r\nstatic void\r\nxfs_dentry_to_name(\r\nstruct xfs_name *namep,\r\nstruct dentry *dentry)\r\n{\r\nnamep->name = dentry->d_name.name;\r\nnamep->len = dentry->d_name.len;\r\nnamep->type = XFS_DIR3_FT_UNKNOWN;\r\n}\r\nstatic int\r\nxfs_dentry_mode_to_name(\r\nstruct xfs_name *namep,\r\nstruct dentry *dentry,\r\nint mode)\r\n{\r\nnamep->name = dentry->d_name.name;\r\nnamep->len = dentry->d_name.len;\r\nnamep->type = xfs_mode_to_ftype(mode);\r\nif (unlikely(namep->type == XFS_DIR3_FT_UNKNOWN))\r\nreturn -EFSCORRUPTED;\r\nreturn 0;\r\n}\r\nSTATIC void\r\nxfs_cleanup_inode(\r\nstruct inode *dir,\r\nstruct inode *inode,\r\nstruct dentry *dentry)\r\n{\r\nstruct xfs_name teardown;\r\nxfs_dentry_to_name(&teardown, dentry);\r\nxfs_remove(XFS_I(dir), &teardown, XFS_I(inode));\r\n}\r\nSTATIC int\r\nxfs_generic_create(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode,\r\ndev_t rdev,\r\nbool tmpfile)\r\n{\r\nstruct inode *inode;\r\nstruct xfs_inode *ip = NULL;\r\nstruct posix_acl *default_acl, *acl;\r\nstruct xfs_name name;\r\nint error;\r\nif (S_ISCHR(mode) || S_ISBLK(mode)) {\r\nif (unlikely(!sysv_valid_dev(rdev) || MAJOR(rdev) & ~0x1ff))\r\nreturn -EINVAL;\r\nrdev = sysv_encode_dev(rdev);\r\n} else {\r\nrdev = 0;\r\n}\r\nerror = posix_acl_create(dir, &mode, &default_acl, &acl);\r\nif (error)\r\nreturn error;\r\nerror = xfs_dentry_mode_to_name(&name, dentry, mode);\r\nif (unlikely(error))\r\ngoto out_free_acl;\r\nif (!tmpfile) {\r\nerror = xfs_create(XFS_I(dir), &name, mode, rdev, &ip);\r\n} else {\r\nerror = xfs_create_tmpfile(XFS_I(dir), dentry, mode, &ip);\r\n}\r\nif (unlikely(error))\r\ngoto out_free_acl;\r\ninode = VFS_I(ip);\r\nerror = xfs_init_security(inode, dir, &dentry->d_name);\r\nif (unlikely(error))\r\ngoto out_cleanup_inode;\r\n#ifdef CONFIG_XFS_POSIX_ACL\r\nif (default_acl) {\r\nerror = xfs_set_acl(inode, default_acl, ACL_TYPE_DEFAULT);\r\nif (error)\r\ngoto out_cleanup_inode;\r\n}\r\nif (acl) {\r\nerror = xfs_set_acl(inode, acl, ACL_TYPE_ACCESS);\r\nif (error)\r\ngoto out_cleanup_inode;\r\n}\r\n#endif\r\nxfs_setup_iops(ip);\r\nif (tmpfile)\r\nd_tmpfile(dentry, inode);\r\nelse\r\nd_instantiate(dentry, inode);\r\nxfs_finish_inode_setup(ip);\r\nout_free_acl:\r\nif (default_acl)\r\nposix_acl_release(default_acl);\r\nif (acl)\r\nposix_acl_release(acl);\r\nreturn error;\r\nout_cleanup_inode:\r\nxfs_finish_inode_setup(ip);\r\nif (!tmpfile)\r\nxfs_cleanup_inode(dir, inode, dentry);\r\niput(inode);\r\ngoto out_free_acl;\r\n}\r\nSTATIC int\r\nxfs_vn_mknod(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode,\r\ndev_t rdev)\r\n{\r\nreturn xfs_generic_create(dir, dentry, mode, rdev, false);\r\n}\r\nSTATIC int\r\nxfs_vn_create(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode,\r\nbool flags)\r\n{\r\nreturn xfs_vn_mknod(dir, dentry, mode, 0);\r\n}\r\nSTATIC int\r\nxfs_vn_mkdir(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode)\r\n{\r\nreturn xfs_vn_mknod(dir, dentry, mode|S_IFDIR, 0);\r\n}\r\nSTATIC struct dentry *\r\nxfs_vn_lookup(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct xfs_inode *cip;\r\nstruct xfs_name name;\r\nint error;\r\nif (dentry->d_name.len >= MAXNAMELEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = xfs_lookup(XFS_I(dir), &name, &cip, NULL);\r\nif (unlikely(error)) {\r\nif (unlikely(error != -ENOENT))\r\nreturn ERR_PTR(error);\r\nd_add(dentry, NULL);\r\nreturn NULL;\r\n}\r\nreturn d_splice_alias(VFS_I(cip), dentry);\r\n}\r\nSTATIC struct dentry *\r\nxfs_vn_ci_lookup(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\nunsigned int flags)\r\n{\r\nstruct xfs_inode *ip;\r\nstruct xfs_name xname;\r\nstruct xfs_name ci_name;\r\nstruct qstr dname;\r\nint error;\r\nif (dentry->d_name.len >= MAXNAMELEN)\r\nreturn ERR_PTR(-ENAMETOOLONG);\r\nxfs_dentry_to_name(&xname, dentry);\r\nerror = xfs_lookup(XFS_I(dir), &xname, &ip, &ci_name);\r\nif (unlikely(error)) {\r\nif (unlikely(error != -ENOENT))\r\nreturn ERR_PTR(error);\r\nreturn NULL;\r\n}\r\nif (!ci_name.name)\r\nreturn d_splice_alias(VFS_I(ip), dentry);\r\ndname.name = ci_name.name;\r\ndname.len = ci_name.len;\r\ndentry = d_add_ci(dentry, VFS_I(ip), &dname);\r\nkmem_free(ci_name.name);\r\nreturn dentry;\r\n}\r\nSTATIC int\r\nxfs_vn_link(\r\nstruct dentry *old_dentry,\r\nstruct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nstruct inode *inode = d_inode(old_dentry);\r\nstruct xfs_name name;\r\nint error;\r\nerror = xfs_dentry_mode_to_name(&name, dentry, inode->i_mode);\r\nif (unlikely(error))\r\nreturn error;\r\nerror = xfs_link(XFS_I(dir), XFS_I(inode), &name);\r\nif (unlikely(error))\r\nreturn error;\r\nihold(inode);\r\nd_instantiate(dentry, inode);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_vn_unlink(\r\nstruct inode *dir,\r\nstruct dentry *dentry)\r\n{\r\nstruct xfs_name name;\r\nint error;\r\nxfs_dentry_to_name(&name, dentry);\r\nerror = xfs_remove(XFS_I(dir), &name, XFS_I(d_inode(dentry)));\r\nif (error)\r\nreturn error;\r\nif (xfs_sb_version_hasasciici(&XFS_M(dir->i_sb)->m_sb))\r\nd_invalidate(dentry);\r\nreturn 0;\r\n}\r\nSTATIC int\r\nxfs_vn_symlink(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\nconst char *symname)\r\n{\r\nstruct inode *inode;\r\nstruct xfs_inode *cip = NULL;\r\nstruct xfs_name name;\r\nint error;\r\numode_t mode;\r\nmode = S_IFLNK |\r\n(irix_symlink_mode ? 0777 & ~current_umask() : S_IRWXUGO);\r\nerror = xfs_dentry_mode_to_name(&name, dentry, mode);\r\nif (unlikely(error))\r\ngoto out;\r\nerror = xfs_symlink(XFS_I(dir), &name, symname, mode, &cip);\r\nif (unlikely(error))\r\ngoto out;\r\ninode = VFS_I(cip);\r\nerror = xfs_init_security(inode, dir, &dentry->d_name);\r\nif (unlikely(error))\r\ngoto out_cleanup_inode;\r\nxfs_setup_iops(cip);\r\nd_instantiate(dentry, inode);\r\nxfs_finish_inode_setup(cip);\r\nreturn 0;\r\nout_cleanup_inode:\r\nxfs_finish_inode_setup(cip);\r\nxfs_cleanup_inode(dir, inode, dentry);\r\niput(inode);\r\nout:\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_vn_rename(\r\nstruct inode *odir,\r\nstruct dentry *odentry,\r\nstruct inode *ndir,\r\nstruct dentry *ndentry,\r\nunsigned int flags)\r\n{\r\nstruct inode *new_inode = d_inode(ndentry);\r\nint omode = 0;\r\nint error;\r\nstruct xfs_name oname;\r\nstruct xfs_name nname;\r\nif (flags & ~(RENAME_NOREPLACE | RENAME_EXCHANGE | RENAME_WHITEOUT))\r\nreturn -EINVAL;\r\nif (flags & RENAME_EXCHANGE)\r\nomode = d_inode(ndentry)->i_mode;\r\nerror = xfs_dentry_mode_to_name(&oname, odentry, omode);\r\nif (omode && unlikely(error))\r\nreturn error;\r\nerror = xfs_dentry_mode_to_name(&nname, ndentry,\r\nd_inode(odentry)->i_mode);\r\nif (unlikely(error))\r\nreturn error;\r\nreturn xfs_rename(XFS_I(odir), &oname, XFS_I(d_inode(odentry)),\r\nXFS_I(ndir), &nname,\r\nnew_inode ? XFS_I(new_inode) : NULL, flags);\r\n}\r\nSTATIC const char *\r\nxfs_vn_get_link(\r\nstruct dentry *dentry,\r\nstruct inode *inode,\r\nstruct delayed_call *done)\r\n{\r\nchar *link;\r\nint error = -ENOMEM;\r\nif (!dentry)\r\nreturn ERR_PTR(-ECHILD);\r\nlink = kmalloc(MAXPATHLEN+1, GFP_KERNEL);\r\nif (!link)\r\ngoto out_err;\r\nerror = xfs_readlink(XFS_I(d_inode(dentry)), link);\r\nif (unlikely(error))\r\ngoto out_kfree;\r\nset_delayed_call(done, kfree_link, link);\r\nreturn link;\r\nout_kfree:\r\nkfree(link);\r\nout_err:\r\nreturn ERR_PTR(error);\r\n}\r\nSTATIC const char *\r\nxfs_vn_get_link_inline(\r\nstruct dentry *dentry,\r\nstruct inode *inode,\r\nstruct delayed_call *done)\r\n{\r\nASSERT(XFS_I(inode)->i_df.if_flags & XFS_IFINLINE);\r\nreturn XFS_I(inode)->i_df.if_u1.if_data;\r\n}\r\nSTATIC int\r\nxfs_vn_getattr(\r\nconst struct path *path,\r\nstruct kstat *stat,\r\nu32 request_mask,\r\nunsigned int query_flags)\r\n{\r\nstruct inode *inode = d_inode(path->dentry);\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\ntrace_xfs_getattr(ip);\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nstat->size = XFS_ISIZE(ip);\r\nstat->dev = inode->i_sb->s_dev;\r\nstat->mode = inode->i_mode;\r\nstat->nlink = inode->i_nlink;\r\nstat->uid = inode->i_uid;\r\nstat->gid = inode->i_gid;\r\nstat->ino = ip->i_ino;\r\nstat->atime = inode->i_atime;\r\nstat->mtime = inode->i_mtime;\r\nstat->ctime = inode->i_ctime;\r\nstat->blocks =\r\nXFS_FSB_TO_BB(mp, ip->i_d.di_nblocks + ip->i_delayed_blks);\r\nif (ip->i_d.di_version == 3) {\r\nif (request_mask & STATX_BTIME) {\r\nstat->result_mask |= STATX_BTIME;\r\nstat->btime.tv_sec = ip->i_d.di_crtime.t_sec;\r\nstat->btime.tv_nsec = ip->i_d.di_crtime.t_nsec;\r\n}\r\n}\r\nif (ip->i_d.di_flags & XFS_DIFLAG_IMMUTABLE)\r\nstat->attributes |= STATX_ATTR_IMMUTABLE;\r\nif (ip->i_d.di_flags & XFS_DIFLAG_APPEND)\r\nstat->attributes |= STATX_ATTR_APPEND;\r\nif (ip->i_d.di_flags & XFS_DIFLAG_NODUMP)\r\nstat->attributes |= STATX_ATTR_NODUMP;\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\nstat->blksize = BLKDEV_IOSIZE;\r\nstat->rdev = MKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\r\nsysv_minor(ip->i_df.if_u2.if_rdev));\r\nbreak;\r\ndefault:\r\nif (XFS_IS_REALTIME_INODE(ip)) {\r\nstat->blksize =\r\nxfs_get_extsz_hint(ip) << mp->m_sb.sb_blocklog;\r\n} else\r\nstat->blksize = xfs_preferred_iosize(mp);\r\nstat->rdev = 0;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic void\r\nxfs_setattr_mode(\r\nstruct xfs_inode *ip,\r\nstruct iattr *iattr)\r\n{\r\nstruct inode *inode = VFS_I(ip);\r\numode_t mode = iattr->ia_mode;\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\ninode->i_mode &= S_IFMT;\r\ninode->i_mode |= mode & ~S_IFMT;\r\n}\r\nvoid\r\nxfs_setattr_time(\r\nstruct xfs_inode *ip,\r\nstruct iattr *iattr)\r\n{\r\nstruct inode *inode = VFS_I(ip);\r\nASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL));\r\nif (iattr->ia_valid & ATTR_ATIME)\r\ninode->i_atime = iattr->ia_atime;\r\nif (iattr->ia_valid & ATTR_CTIME)\r\ninode->i_ctime = iattr->ia_ctime;\r\nif (iattr->ia_valid & ATTR_MTIME)\r\ninode->i_mtime = iattr->ia_mtime;\r\n}\r\nstatic int\r\nxfs_vn_change_ok(\r\nstruct dentry *dentry,\r\nstruct iattr *iattr)\r\n{\r\nstruct xfs_mount *mp = XFS_I(d_inode(dentry))->i_mount;\r\nif (mp->m_flags & XFS_MOUNT_RDONLY)\r\nreturn -EROFS;\r\nif (XFS_FORCED_SHUTDOWN(mp))\r\nreturn -EIO;\r\nreturn setattr_prepare(dentry, iattr);\r\n}\r\nint\r\nxfs_setattr_nonsize(\r\nstruct xfs_inode *ip,\r\nstruct iattr *iattr,\r\nint flags)\r\n{\r\nxfs_mount_t *mp = ip->i_mount;\r\nstruct inode *inode = VFS_I(ip);\r\nint mask = iattr->ia_valid;\r\nxfs_trans_t *tp;\r\nint error;\r\nkuid_t uid = GLOBAL_ROOT_UID, iuid = GLOBAL_ROOT_UID;\r\nkgid_t gid = GLOBAL_ROOT_GID, igid = GLOBAL_ROOT_GID;\r\nstruct xfs_dquot *udqp = NULL, *gdqp = NULL;\r\nstruct xfs_dquot *olddquot1 = NULL, *olddquot2 = NULL;\r\nASSERT((mask & ATTR_SIZE) == 0);\r\nif (XFS_IS_QUOTA_ON(mp) && (mask & (ATTR_UID|ATTR_GID))) {\r\nuint qflags = 0;\r\nif ((mask & ATTR_UID) && XFS_IS_UQUOTA_ON(mp)) {\r\nuid = iattr->ia_uid;\r\nqflags |= XFS_QMOPT_UQUOTA;\r\n} else {\r\nuid = inode->i_uid;\r\n}\r\nif ((mask & ATTR_GID) && XFS_IS_GQUOTA_ON(mp)) {\r\ngid = iattr->ia_gid;\r\nqflags |= XFS_QMOPT_GQUOTA;\r\n} else {\r\ngid = inode->i_gid;\r\n}\r\nASSERT(udqp == NULL);\r\nASSERT(gdqp == NULL);\r\nerror = xfs_qm_vop_dqalloc(ip, xfs_kuid_to_uid(uid),\r\nxfs_kgid_to_gid(gid),\r\nxfs_get_projid(ip),\r\nqflags, &udqp, &gdqp, NULL);\r\nif (error)\r\nreturn error;\r\n}\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_ichange, 0, 0, 0, &tp);\r\nif (error)\r\ngoto out_dqrele;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nif (mask & (ATTR_UID|ATTR_GID)) {\r\niuid = inode->i_uid;\r\nigid = inode->i_gid;\r\ngid = (mask & ATTR_GID) ? iattr->ia_gid : igid;\r\nuid = (mask & ATTR_UID) ? iattr->ia_uid : iuid;\r\nif (XFS_IS_QUOTA_RUNNING(mp) &&\r\n((XFS_IS_UQUOTA_ON(mp) && !uid_eq(iuid, uid)) ||\r\n(XFS_IS_GQUOTA_ON(mp) && !gid_eq(igid, gid)))) {\r\nASSERT(tp);\r\nerror = xfs_qm_vop_chown_reserve(tp, ip, udqp, gdqp,\r\nNULL, capable(CAP_FOWNER) ?\r\nXFS_QMOPT_FORCE_RES : 0);\r\nif (error)\r\ngoto out_cancel;\r\n}\r\n}\r\nif (mask & (ATTR_UID|ATTR_GID)) {\r\nif ((inode->i_mode & (S_ISUID|S_ISGID)) &&\r\n!capable(CAP_FSETID))\r\ninode->i_mode &= ~(S_ISUID|S_ISGID);\r\nif (!uid_eq(iuid, uid)) {\r\nif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_UQUOTA_ON(mp)) {\r\nASSERT(mask & ATTR_UID);\r\nASSERT(udqp);\r\nolddquot1 = xfs_qm_vop_chown(tp, ip,\r\n&ip->i_udquot, udqp);\r\n}\r\nip->i_d.di_uid = xfs_kuid_to_uid(uid);\r\ninode->i_uid = uid;\r\n}\r\nif (!gid_eq(igid, gid)) {\r\nif (XFS_IS_QUOTA_RUNNING(mp) && XFS_IS_GQUOTA_ON(mp)) {\r\nASSERT(xfs_sb_version_has_pquotino(&mp->m_sb) ||\r\n!XFS_IS_PQUOTA_ON(mp));\r\nASSERT(mask & ATTR_GID);\r\nASSERT(gdqp);\r\nolddquot2 = xfs_qm_vop_chown(tp, ip,\r\n&ip->i_gdquot, gdqp);\r\n}\r\nip->i_d.di_gid = xfs_kgid_to_gid(gid);\r\ninode->i_gid = gid;\r\n}\r\n}\r\nif (mask & ATTR_MODE)\r\nxfs_setattr_mode(ip, iattr);\r\nif (mask & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\r\nxfs_setattr_time(ip, iattr);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nXFS_STATS_INC(mp, xs_ig_attrchg);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp);\r\nxfs_iunlock(ip, XFS_ILOCK_EXCL);\r\nxfs_qm_dqrele(olddquot1);\r\nxfs_qm_dqrele(olddquot2);\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nif (error)\r\nreturn error;\r\nif ((mask & ATTR_MODE) && !(flags & XFS_ATTR_NOACL)) {\r\nerror = posix_acl_chmod(inode, inode->i_mode);\r\nif (error)\r\nreturn error;\r\n}\r\nreturn 0;\r\nout_cancel:\r\nxfs_trans_cancel(tp);\r\nout_dqrele:\r\nxfs_qm_dqrele(udqp);\r\nxfs_qm_dqrele(gdqp);\r\nreturn error;\r\n}\r\nint\r\nxfs_vn_setattr_nonsize(\r\nstruct dentry *dentry,\r\nstruct iattr *iattr)\r\n{\r\nstruct xfs_inode *ip = XFS_I(d_inode(dentry));\r\nint error;\r\ntrace_xfs_setattr(ip);\r\nerror = xfs_vn_change_ok(dentry, iattr);\r\nif (error)\r\nreturn error;\r\nreturn xfs_setattr_nonsize(ip, iattr, 0);\r\n}\r\nint\r\nxfs_setattr_size(\r\nstruct xfs_inode *ip,\r\nstruct iattr *iattr)\r\n{\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct inode *inode = VFS_I(ip);\r\nxfs_off_t oldsize, newsize;\r\nstruct xfs_trans *tp;\r\nint error;\r\nuint lock_flags = 0;\r\nbool did_zeroing = false;\r\nASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));\r\nASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));\r\nASSERT(S_ISREG(inode->i_mode));\r\nASSERT((iattr->ia_valid & (ATTR_UID|ATTR_GID|ATTR_ATIME|ATTR_ATIME_SET|\r\nATTR_MTIME_SET|ATTR_KILL_PRIV|ATTR_TIMES_SET)) == 0);\r\noldsize = inode->i_size;\r\nnewsize = iattr->ia_size;\r\nif (newsize == 0 && oldsize == 0 && ip->i_d.di_nextents == 0) {\r\nif (!(iattr->ia_valid & (ATTR_CTIME|ATTR_MTIME)))\r\nreturn 0;\r\niattr->ia_valid &= ~ATTR_SIZE;\r\nreturn xfs_setattr_nonsize(ip, iattr, 0);\r\n}\r\nerror = xfs_qm_dqattach(ip, 0);\r\nif (error)\r\nreturn error;\r\ninode_dio_wait(inode);\r\nif (newsize > oldsize) {\r\nerror = xfs_zero_eof(ip, newsize, oldsize, &did_zeroing);\r\n} else {\r\nerror = iomap_truncate_page(inode, newsize, &did_zeroing,\r\n&xfs_iomap_ops);\r\n}\r\nif (error)\r\nreturn error;\r\nif (did_zeroing ||\r\n(newsize > ip->i_d.di_size && oldsize != ip->i_d.di_size)) {\r\nerror = filemap_write_and_wait_range(VFS_I(ip)->i_mapping,\r\nip->i_d.di_size, newsize);\r\nif (error)\r\nreturn error;\r\n}\r\ntruncate_setsize(inode, newsize);\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_itruncate, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nlock_flags |= XFS_ILOCK_EXCL;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nxfs_trans_ijoin(tp, ip, 0);\r\nif (newsize != oldsize &&\r\n!(iattr->ia_valid & (ATTR_CTIME | ATTR_MTIME))) {\r\niattr->ia_ctime = iattr->ia_mtime =\r\ncurrent_time(inode);\r\niattr->ia_valid |= ATTR_CTIME | ATTR_MTIME;\r\n}\r\nip->i_d.di_size = newsize;\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nif (newsize <= oldsize) {\r\nerror = xfs_itruncate_extents(&tp, ip, XFS_DATA_FORK, newsize);\r\nif (error)\r\ngoto out_trans_cancel;\r\nxfs_iflags_set(ip, XFS_ITRUNCATED);\r\nxfs_inode_clear_eofblocks_tag(ip);\r\n}\r\nif (iattr->ia_valid & ATTR_MODE)\r\nxfs_setattr_mode(ip, iattr);\r\nif (iattr->ia_valid & (ATTR_ATIME|ATTR_CTIME|ATTR_MTIME))\r\nxfs_setattr_time(ip, iattr);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\r\nXFS_STATS_INC(mp, xs_ig_attrchg);\r\nif (mp->m_flags & XFS_MOUNT_WSYNC)\r\nxfs_trans_set_sync(tp);\r\nerror = xfs_trans_commit(tp);\r\nout_unlock:\r\nif (lock_flags)\r\nxfs_iunlock(ip, lock_flags);\r\nreturn error;\r\nout_trans_cancel:\r\nxfs_trans_cancel(tp);\r\ngoto out_unlock;\r\n}\r\nint\r\nxfs_vn_setattr_size(\r\nstruct dentry *dentry,\r\nstruct iattr *iattr)\r\n{\r\nstruct xfs_inode *ip = XFS_I(d_inode(dentry));\r\nint error;\r\ntrace_xfs_setattr(ip);\r\nerror = xfs_vn_change_ok(dentry, iattr);\r\nif (error)\r\nreturn error;\r\nreturn xfs_setattr_size(ip, iattr);\r\n}\r\nSTATIC int\r\nxfs_vn_setattr(\r\nstruct dentry *dentry,\r\nstruct iattr *iattr)\r\n{\r\nint error;\r\nif (iattr->ia_valid & ATTR_SIZE) {\r\nstruct xfs_inode *ip = XFS_I(d_inode(dentry));\r\nuint iolock = XFS_IOLOCK_EXCL;\r\nerror = xfs_break_layouts(d_inode(dentry), &iolock);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(ip, XFS_MMAPLOCK_EXCL);\r\nerror = xfs_vn_setattr_size(dentry, iattr);\r\nxfs_iunlock(ip, XFS_MMAPLOCK_EXCL);\r\n} else {\r\nerror = xfs_vn_setattr_nonsize(dentry, iattr);\r\n}\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_vn_update_time(\r\nstruct inode *inode,\r\nstruct timespec *now,\r\nint flags)\r\n{\r\nstruct xfs_inode *ip = XFS_I(inode);\r\nstruct xfs_mount *mp = ip->i_mount;\r\nstruct xfs_trans *tp;\r\nint error;\r\ntrace_xfs_update_time(ip);\r\nerror = xfs_trans_alloc(mp, &M_RES(mp)->tr_fsyncts, 0, 0, 0, &tp);\r\nif (error)\r\nreturn error;\r\nxfs_ilock(ip, XFS_ILOCK_EXCL);\r\nif (flags & S_CTIME)\r\ninode->i_ctime = *now;\r\nif (flags & S_MTIME)\r\ninode->i_mtime = *now;\r\nif (flags & S_ATIME)\r\ninode->i_atime = *now;\r\nxfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\r\nxfs_trans_log_inode(tp, ip, XFS_ILOG_TIMESTAMP);\r\nreturn xfs_trans_commit(tp);\r\n}\r\nSTATIC int\r\nxfs_vn_fiemap(\r\nstruct inode *inode,\r\nstruct fiemap_extent_info *fieinfo,\r\nu64 start,\r\nu64 length)\r\n{\r\nint error;\r\nxfs_ilock(XFS_I(inode), XFS_IOLOCK_SHARED);\r\nif (fieinfo->fi_flags & FIEMAP_FLAG_XATTR) {\r\nfieinfo->fi_flags &= ~FIEMAP_FLAG_XATTR;\r\nerror = iomap_fiemap(inode, fieinfo, start, length,\r\n&xfs_xattr_iomap_ops);\r\n} else {\r\nerror = iomap_fiemap(inode, fieinfo, start, length,\r\n&xfs_iomap_ops);\r\n}\r\nxfs_iunlock(XFS_I(inode), XFS_IOLOCK_SHARED);\r\nreturn error;\r\n}\r\nSTATIC int\r\nxfs_vn_tmpfile(\r\nstruct inode *dir,\r\nstruct dentry *dentry,\r\numode_t mode)\r\n{\r\nreturn xfs_generic_create(dir, dentry, mode, 0, true);\r\n}\r\nSTATIC void\r\nxfs_diflags_to_iflags(\r\nstruct inode *inode,\r\nstruct xfs_inode *ip)\r\n{\r\nuint16_t flags = ip->i_d.di_flags;\r\ninode->i_flags &= ~(S_IMMUTABLE | S_APPEND | S_SYNC |\r\nS_NOATIME | S_DAX);\r\nif (flags & XFS_DIFLAG_IMMUTABLE)\r\ninode->i_flags |= S_IMMUTABLE;\r\nif (flags & XFS_DIFLAG_APPEND)\r\ninode->i_flags |= S_APPEND;\r\nif (flags & XFS_DIFLAG_SYNC)\r\ninode->i_flags |= S_SYNC;\r\nif (flags & XFS_DIFLAG_NOATIME)\r\ninode->i_flags |= S_NOATIME;\r\nif (S_ISREG(inode->i_mode) &&\r\nip->i_mount->m_sb.sb_blocksize == PAGE_SIZE &&\r\n!xfs_is_reflink_inode(ip) &&\r\n(ip->i_mount->m_flags & XFS_MOUNT_DAX ||\r\nip->i_d.di_flags2 & XFS_DIFLAG2_DAX))\r\ninode->i_flags |= S_DAX;\r\n}\r\nvoid\r\nxfs_setup_inode(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct inode *inode = &ip->i_vnode;\r\ngfp_t gfp_mask;\r\ninode->i_ino = ip->i_ino;\r\ninode->i_state = I_NEW;\r\ninode_sb_list_add(inode);\r\nhlist_add_fake(&inode->i_hash);\r\ninode->i_uid = xfs_uid_to_kuid(ip->i_d.di_uid);\r\ninode->i_gid = xfs_gid_to_kgid(ip->i_d.di_gid);\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFBLK:\r\ncase S_IFCHR:\r\ninode->i_rdev =\r\nMKDEV(sysv_major(ip->i_df.if_u2.if_rdev) & 0x1ff,\r\nsysv_minor(ip->i_df.if_u2.if_rdev));\r\nbreak;\r\ndefault:\r\ninode->i_rdev = 0;\r\nbreak;\r\n}\r\ni_size_write(inode, ip->i_d.di_size);\r\nxfs_diflags_to_iflags(inode, ip);\r\nif (S_ISDIR(inode->i_mode)) {\r\nlockdep_set_class(&ip->i_lock.mr_lock, &xfs_dir_ilock_class);\r\nip->d_ops = ip->i_mount->m_dir_inode_ops;\r\n} else {\r\nip->d_ops = ip->i_mount->m_nondir_inode_ops;\r\nlockdep_set_class(&ip->i_lock.mr_lock, &xfs_nondir_ilock_class);\r\n}\r\ngfp_mask = mapping_gfp_mask(inode->i_mapping);\r\nmapping_set_gfp_mask(inode->i_mapping, (gfp_mask & ~(__GFP_FS)));\r\nif (!XFS_IFORK_Q(ip)) {\r\ninode_has_no_xattr(inode);\r\ncache_no_acl(inode);\r\n}\r\n}\r\nvoid\r\nxfs_setup_iops(\r\nstruct xfs_inode *ip)\r\n{\r\nstruct inode *inode = &ip->i_vnode;\r\nswitch (inode->i_mode & S_IFMT) {\r\ncase S_IFREG:\r\ninode->i_op = &xfs_inode_operations;\r\ninode->i_fop = &xfs_file_operations;\r\ninode->i_mapping->a_ops = &xfs_address_space_operations;\r\nbreak;\r\ncase S_IFDIR:\r\nif (xfs_sb_version_hasasciici(&XFS_M(inode->i_sb)->m_sb))\r\ninode->i_op = &xfs_dir_ci_inode_operations;\r\nelse\r\ninode->i_op = &xfs_dir_inode_operations;\r\ninode->i_fop = &xfs_dir_file_operations;\r\nbreak;\r\ncase S_IFLNK:\r\nif (ip->i_df.if_flags & XFS_IFINLINE)\r\ninode->i_op = &xfs_inline_symlink_inode_operations;\r\nelse\r\ninode->i_op = &xfs_symlink_inode_operations;\r\nbreak;\r\ndefault:\r\ninode->i_op = &xfs_inode_operations;\r\ninit_special_inode(inode, inode->i_mode, inode->i_rdev);\r\nbreak;\r\n}\r\n}
