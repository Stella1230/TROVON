bool __rpte_sub_valid(real_pte_t rpte, unsigned long index)\r\n{\r\nunsigned long g_idx;\r\nunsigned long ptev = pte_val(rpte.pte);\r\ng_idx = (ptev & H_PAGE_COMBO_VALID) >> H_PAGE_F_GIX_SHIFT;\r\nindex = index >> 2;\r\nif (g_idx & (0x1 << index))\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic unsigned long mark_subptegroup_valid(unsigned long ptev, unsigned long index)\r\n{\r\nunsigned long g_idx;\r\nif (!(ptev & H_PAGE_COMBO))\r\nreturn ptev;\r\nindex = index >> 2;\r\ng_idx = 0x1 << index;\r\nreturn ptev | (g_idx << H_PAGE_F_GIX_SHIFT);\r\n}\r\nint __hash_page_4K(unsigned long ea, unsigned long access, unsigned long vsid,\r\npte_t *ptep, unsigned long trap, unsigned long flags,\r\nint ssize, int subpg_prot)\r\n{\r\nreal_pte_t rpte;\r\nunsigned long *hidxp;\r\nunsigned long hpte_group;\r\nunsigned int subpg_index;\r\nunsigned long rflags, pa, hidx;\r\nunsigned long old_pte, new_pte, subpg_pte;\r\nunsigned long vpn, hash, slot;\r\nunsigned long shift = mmu_psize_defs[MMU_PAGE_4K].shift;\r\ndo {\r\npte_t pte = READ_ONCE(*ptep);\r\nold_pte = pte_val(pte);\r\nif (unlikely(old_pte & H_PAGE_BUSY))\r\nreturn 0;\r\nif (unlikely(!check_pte_access(access, old_pte)))\r\nreturn 1;\r\nnew_pte = old_pte | H_PAGE_BUSY | _PAGE_ACCESSED | H_PAGE_COMBO;\r\nif (access & _PAGE_WRITE)\r\nnew_pte |= _PAGE_DIRTY;\r\n} while (!pte_xchg(ptep, __pte(old_pte), __pte(new_pte)));\r\nsubpg_pte = new_pte & ~subpg_prot;\r\nrflags = htab_convert_pte_flags(subpg_pte);\r\nif (cpu_has_feature(CPU_FTR_NOEXECUTE) &&\r\n!cpu_has_feature(CPU_FTR_COHERENT_ICACHE)) {\r\nrflags = hash_page_do_lazy_icache(rflags, __pte(old_pte), trap);\r\n}\r\nsubpg_index = (ea & (PAGE_SIZE - 1)) >> shift;\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nrpte = __real_pte(__pte(old_pte), ptep);\r\nif (!(old_pte & H_PAGE_HASHPTE))\r\ngoto htab_insert_hpte;\r\nif (!(old_pte & H_PAGE_COMBO)) {\r\nflush_hash_page(vpn, rpte, MMU_PAGE_64K, ssize, flags);\r\nold_pte &= ~(H_PAGE_HASHPTE | H_PAGE_F_GIX | H_PAGE_F_SECOND);\r\nnew_pte &= ~(H_PAGE_HASHPTE | H_PAGE_F_GIX | H_PAGE_F_SECOND);\r\ngoto htab_insert_hpte;\r\n}\r\nif (__rpte_sub_valid(rpte, subpg_index)) {\r\nint ret;\r\nhash = hpt_hash(vpn, shift, ssize);\r\nhidx = __rpte_to_hidx(rpte, subpg_index);\r\nif (hidx & _PTEIDX_SECONDARY)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += hidx & _PTEIDX_GROUP_IX;\r\nret = mmu_hash_ops.hpte_updatepp(slot, rflags, vpn,\r\nMMU_PAGE_4K, MMU_PAGE_4K,\r\nssize, flags);\r\nif (ret == -1)\r\ngoto htab_insert_hpte;\r\n*ptep = __pte(new_pte & ~H_PAGE_BUSY);\r\nreturn 0;\r\n}\r\nhtab_insert_hpte:\r\nif (old_pte & H_PAGE_4K_PFN) {\r\npa = pte_pfn(__pte(old_pte)) << HW_PAGE_SHIFT;\r\n} else {\r\npa = pte_pfn(__pte(old_pte)) << PAGE_SHIFT;\r\npa += (subpg_index << shift);\r\n}\r\nhash = hpt_hash(vpn, shift, ssize);\r\nrepeat:\r\nhpte_group = ((hash & htab_hash_mask) * HPTES_PER_GROUP) & ~0x7UL;\r\nslot = mmu_hash_ops.hpte_insert(hpte_group, vpn, pa, rflags, 0,\r\nMMU_PAGE_4K, MMU_PAGE_4K, ssize);\r\nif (unlikely(slot == -1)) {\r\nhpte_group = ((~hash & htab_hash_mask) * HPTES_PER_GROUP) & ~0x7UL;\r\nslot = mmu_hash_ops.hpte_insert(hpte_group, vpn, pa,\r\nrflags, HPTE_V_SECONDARY,\r\nMMU_PAGE_4K, MMU_PAGE_4K,\r\nssize);\r\nif (slot == -1) {\r\nif (mftb() & 0x1)\r\nhpte_group = ((hash & htab_hash_mask) *\r\nHPTES_PER_GROUP) & ~0x7UL;\r\nmmu_hash_ops.hpte_remove(hpte_group);\r\ngoto repeat;\r\n}\r\n}\r\nif (unlikely(slot == -2)) {\r\n*ptep = __pte(old_pte);\r\nhash_failure_debug(ea, access, vsid, trap, ssize,\r\nMMU_PAGE_4K, MMU_PAGE_4K, old_pte);\r\nreturn -1;\r\n}\r\nhidxp = (unsigned long *)(ptep + PTRS_PER_PTE);\r\nrpte.hidx &= ~(0xfUL << (subpg_index << 2));\r\n*hidxp = rpte.hidx | (slot << (subpg_index << 2));\r\nnew_pte = mark_subptegroup_valid(new_pte, subpg_index);\r\nnew_pte |= H_PAGE_HASHPTE;\r\nsmp_wmb();\r\n*ptep = __pte(new_pte & ~H_PAGE_BUSY);\r\nreturn 0;\r\n}\r\nint __hash_page_64K(unsigned long ea, unsigned long access,\r\nunsigned long vsid, pte_t *ptep, unsigned long trap,\r\nunsigned long flags, int ssize)\r\n{\r\nunsigned long hpte_group;\r\nunsigned long rflags, pa;\r\nunsigned long old_pte, new_pte;\r\nunsigned long vpn, hash, slot;\r\nunsigned long shift = mmu_psize_defs[MMU_PAGE_64K].shift;\r\ndo {\r\npte_t pte = READ_ONCE(*ptep);\r\nold_pte = pte_val(pte);\r\nif (unlikely(old_pte & H_PAGE_BUSY))\r\nreturn 0;\r\nif (unlikely(!check_pte_access(access, old_pte)))\r\nreturn 1;\r\nif (!mmu_has_feature(MMU_FTR_CI_LARGE_PAGE) &&\r\nunlikely(pte_ci(pte)))\r\nreturn 0;\r\nnew_pte = old_pte | H_PAGE_BUSY | _PAGE_ACCESSED;\r\nif (access & _PAGE_WRITE)\r\nnew_pte |= _PAGE_DIRTY;\r\n} while (!pte_xchg(ptep, __pte(old_pte), __pte(new_pte)));\r\nrflags = htab_convert_pte_flags(new_pte);\r\nif (cpu_has_feature(CPU_FTR_NOEXECUTE) &&\r\n!cpu_has_feature(CPU_FTR_COHERENT_ICACHE))\r\nrflags = hash_page_do_lazy_icache(rflags, __pte(old_pte), trap);\r\nvpn = hpt_vpn(ea, vsid, ssize);\r\nif (unlikely(old_pte & H_PAGE_HASHPTE)) {\r\nhash = hpt_hash(vpn, shift, ssize);\r\nif (old_pte & H_PAGE_F_SECOND)\r\nhash = ~hash;\r\nslot = (hash & htab_hash_mask) * HPTES_PER_GROUP;\r\nslot += (old_pte & H_PAGE_F_GIX) >> H_PAGE_F_GIX_SHIFT;\r\nif (mmu_hash_ops.hpte_updatepp(slot, rflags, vpn, MMU_PAGE_64K,\r\nMMU_PAGE_64K, ssize,\r\nflags) == -1)\r\nold_pte &= ~_PAGE_HPTEFLAGS;\r\n}\r\nif (likely(!(old_pte & H_PAGE_HASHPTE))) {\r\npa = pte_pfn(__pte(old_pte)) << PAGE_SHIFT;\r\nhash = hpt_hash(vpn, shift, ssize);\r\nrepeat:\r\nhpte_group = ((hash & htab_hash_mask) * HPTES_PER_GROUP) & ~0x7UL;\r\nslot = mmu_hash_ops.hpte_insert(hpte_group, vpn, pa, rflags, 0,\r\nMMU_PAGE_64K, MMU_PAGE_64K,\r\nssize);\r\nif (unlikely(slot == -1)) {\r\nhpte_group = ((~hash & htab_hash_mask) * HPTES_PER_GROUP) & ~0x7UL;\r\nslot = mmu_hash_ops.hpte_insert(hpte_group, vpn, pa,\r\nrflags,\r\nHPTE_V_SECONDARY,\r\nMMU_PAGE_64K,\r\nMMU_PAGE_64K, ssize);\r\nif (slot == -1) {\r\nif (mftb() & 0x1)\r\nhpte_group = ((hash & htab_hash_mask) *\r\nHPTES_PER_GROUP) & ~0x7UL;\r\nmmu_hash_ops.hpte_remove(hpte_group);\r\ngoto repeat;\r\n}\r\n}\r\nif (unlikely(slot == -2)) {\r\n*ptep = __pte(old_pte);\r\nhash_failure_debug(ea, access, vsid, trap, ssize,\r\nMMU_PAGE_64K, MMU_PAGE_64K, old_pte);\r\nreturn -1;\r\n}\r\nnew_pte = (new_pte & ~_PAGE_HPTEFLAGS) | H_PAGE_HASHPTE;\r\nnew_pte |= (slot << H_PAGE_F_GIX_SHIFT) &\r\n(H_PAGE_F_SECOND | H_PAGE_F_GIX);\r\n}\r\n*ptep = __pte(new_pte & ~H_PAGE_BUSY);\r\nreturn 0;\r\n}
