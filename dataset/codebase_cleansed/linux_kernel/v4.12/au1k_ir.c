static void au1k_irda_plat_set_phy_mode(struct au1k_private *p, int mode)\r\n{\r\nif (p->platdata && p->platdata->set_phy_mode)\r\np->platdata->set_phy_mode(mode);\r\n}\r\nstatic inline unsigned long irda_read(struct au1k_private *p,\r\nunsigned long ofs)\r\n{\r\n(void)__raw_readl(p->iobase + ofs);\r\nreturn __raw_readl(p->iobase + ofs);\r\n}\r\nstatic inline void irda_write(struct au1k_private *p, unsigned long ofs,\r\nunsigned long val)\r\n{\r\n__raw_writel(val, p->iobase + ofs);\r\nwmb();\r\n}\r\nstatic struct db_dest *GetFreeDB(struct au1k_private *aup)\r\n{\r\nstruct db_dest *db;\r\ndb = aup->pDBfree;\r\nif (db)\r\naup->pDBfree = db->pnext;\r\nreturn db;\r\n}\r\nstatic void *dma_alloc(size_t size, dma_addr_t *dma_handle)\r\n{\r\nvoid *ret;\r\nint gfp = GFP_ATOMIC | GFP_DMA;\r\nret = (void *)__get_free_pages(gfp, get_order(size));\r\nif (ret != NULL) {\r\nmemset(ret, 0, size);\r\n*dma_handle = virt_to_bus(ret);\r\nret = (void *)KSEG0ADDR(ret);\r\n}\r\nreturn ret;\r\n}\r\nstatic void dma_free(void *vaddr, size_t size)\r\n{\r\nvaddr = (void *)KSEG0ADDR(vaddr);\r\nfree_pages((unsigned long) vaddr, get_order(size));\r\n}\r\nstatic void setup_hw_rings(struct au1k_private *aup, u32 rx_base, u32 tx_base)\r\n{\r\nint i;\r\nfor (i = 0; i < NUM_IR_DESC; i++) {\r\naup->rx_ring[i] = (volatile struct ring_dest *)\r\n(rx_base + sizeof(struct ring_dest) * i);\r\n}\r\nfor (i = 0; i < NUM_IR_DESC; i++) {\r\naup->tx_ring[i] = (volatile struct ring_dest *)\r\n(tx_base + sizeof(struct ring_dest) * i);\r\n}\r\n}\r\nstatic int au1k_irda_init_iobuf(iobuff_t *io, int size)\r\n{\r\nio->head = kmalloc(size, GFP_KERNEL);\r\nif (io->head != NULL) {\r\nio->truesize = size;\r\nio->in_frame = FALSE;\r\nio->state = OUTSIDE_FRAME;\r\nio->data = io->head;\r\n}\r\nreturn io->head ? 0 : -ENOMEM;\r\n}\r\nstatic int au1k_irda_set_speed(struct net_device *dev, int speed)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nvolatile struct ring_dest *ptxd;\r\nunsigned long control;\r\nint ret = 0, timeout = 10, i;\r\nif (speed == aup->speed)\r\nreturn ret;\r\nau1k_irda_plat_set_phy_mode(aup, AU1000_IRDA_PHY_MODE_OFF);\r\nirda_write(aup, IR_STATUS, irda_read(aup, IR_STATUS) & ~IR_PHYEN);\r\nirda_write(aup, IR_CONFIG_1,\r\nirda_read(aup, IR_CONFIG_1) & ~(IR_RX_ENABLE | IR_TX_ENABLE));\r\nmsleep(20);\r\nwhile (irda_read(aup, IR_STATUS) & (IR_RX_STATUS | IR_TX_STATUS)) {\r\nmsleep(20);\r\nif (!timeout--) {\r\nprintk(KERN_ERR "%s: rx/tx disable timeout\n",\r\ndev->name);\r\nbreak;\r\n}\r\n}\r\nirda_write(aup, IR_CONFIG_1,\r\nirda_read(aup, IR_CONFIG_1) & ~IR_DMA_ENABLE);\r\nmsleep(20);\r\naup->tx_head = aup->tx_tail = aup->rx_head = 0;\r\nfor (i = 0; i < NUM_IR_DESC; i++) {\r\nptxd = aup->tx_ring[i];\r\nptxd->flags = 0;\r\nptxd->count_0 = 0;\r\nptxd->count_1 = 0;\r\n}\r\nfor (i = 0; i < NUM_IR_DESC; i++) {\r\nptxd = aup->rx_ring[i];\r\nptxd->count_0 = 0;\r\nptxd->count_1 = 0;\r\nptxd->flags = AU_OWN;\r\n}\r\nif (speed == 4000000)\r\nau1k_irda_plat_set_phy_mode(aup, AU1000_IRDA_PHY_MODE_FIR);\r\nelse\r\nau1k_irda_plat_set_phy_mode(aup, AU1000_IRDA_PHY_MODE_SIR);\r\nswitch (speed) {\r\ncase 9600:\r\nirda_write(aup, IR_WRITE_PHY_CONFIG, IR_BR(11) | IR_PW(12));\r\nirda_write(aup, IR_CONFIG_1, IR_SIR_MODE);\r\nbreak;\r\ncase 19200:\r\nirda_write(aup, IR_WRITE_PHY_CONFIG, IR_BR(5) | IR_PW(12));\r\nirda_write(aup, IR_CONFIG_1, IR_SIR_MODE);\r\nbreak;\r\ncase 38400:\r\nirda_write(aup, IR_WRITE_PHY_CONFIG, IR_BR(2) | IR_PW(12));\r\nirda_write(aup, IR_CONFIG_1, IR_SIR_MODE);\r\nbreak;\r\ncase 57600:\r\nirda_write(aup, IR_WRITE_PHY_CONFIG, IR_BR(1) | IR_PW(12));\r\nirda_write(aup, IR_CONFIG_1, IR_SIR_MODE);\r\nbreak;\r\ncase 115200:\r\nirda_write(aup, IR_WRITE_PHY_CONFIG, IR_PW(12));\r\nirda_write(aup, IR_CONFIG_1, IR_SIR_MODE);\r\nbreak;\r\ncase 4000000:\r\nirda_write(aup, IR_WRITE_PHY_CONFIG, IR_P(15));\r\nirda_write(aup, IR_CONFIG_1, IR_FIR | IR_DMA_ENABLE |\r\nIR_RX_ENABLE);\r\nbreak;\r\ndefault:\r\nprintk(KERN_ERR "%s unsupported speed %x\n", dev->name, speed);\r\nret = -EINVAL;\r\nbreak;\r\n}\r\naup->speed = speed;\r\nirda_write(aup, IR_STATUS, irda_read(aup, IR_STATUS) | IR_PHYEN);\r\ncontrol = irda_read(aup, IR_STATUS);\r\nirda_write(aup, IR_RING_PROMPT, 0);\r\nif (control & (1 << 14)) {\r\nprintk(KERN_ERR "%s: configuration error\n", dev->name);\r\n} else {\r\nif (control & (1 << 11))\r\nprintk(KERN_DEBUG "%s Valid SIR config\n", dev->name);\r\nif (control & (1 << 12))\r\nprintk(KERN_DEBUG "%s Valid MIR config\n", dev->name);\r\nif (control & (1 << 13))\r\nprintk(KERN_DEBUG "%s Valid FIR config\n", dev->name);\r\nif (control & (1 << 10))\r\nprintk(KERN_DEBUG "%s TX enabled\n", dev->name);\r\nif (control & (1 << 9))\r\nprintk(KERN_DEBUG "%s RX enabled\n", dev->name);\r\n}\r\nreturn ret;\r\n}\r\nstatic void update_rx_stats(struct net_device *dev, u32 status, u32 count)\r\n{\r\nstruct net_device_stats *ps = &dev->stats;\r\nps->rx_packets++;\r\nif (status & IR_RX_ERROR) {\r\nps->rx_errors++;\r\nif (status & (IR_PHY_ERROR | IR_FIFO_OVER))\r\nps->rx_missed_errors++;\r\nif (status & IR_MAX_LEN)\r\nps->rx_length_errors++;\r\nif (status & IR_CRC_ERROR)\r\nps->rx_crc_errors++;\r\n} else\r\nps->rx_bytes += count;\r\n}\r\nstatic void update_tx_stats(struct net_device *dev, u32 status, u32 pkt_len)\r\n{\r\nstruct net_device_stats *ps = &dev->stats;\r\nps->tx_packets++;\r\nps->tx_bytes += pkt_len;\r\nif (status & IR_TX_ERROR) {\r\nps->tx_errors++;\r\nps->tx_aborted_errors++;\r\n}\r\n}\r\nstatic void au1k_tx_ack(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nvolatile struct ring_dest *ptxd;\r\nptxd = aup->tx_ring[aup->tx_tail];\r\nwhile (!(ptxd->flags & AU_OWN) && (aup->tx_tail != aup->tx_head)) {\r\nupdate_tx_stats(dev, ptxd->flags,\r\n(ptxd->count_1 << 8) | ptxd->count_0);\r\nptxd->count_0 = 0;\r\nptxd->count_1 = 0;\r\nwmb();\r\naup->tx_tail = (aup->tx_tail + 1) & (NUM_IR_DESC - 1);\r\nptxd = aup->tx_ring[aup->tx_tail];\r\nif (aup->tx_full) {\r\naup->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\n}\r\nif (aup->tx_tail == aup->tx_head) {\r\nif (aup->newspeed) {\r\nau1k_irda_set_speed(dev, aup->newspeed);\r\naup->newspeed = 0;\r\n} else {\r\nirda_write(aup, IR_CONFIG_1,\r\nirda_read(aup, IR_CONFIG_1) & ~IR_TX_ENABLE);\r\nirda_write(aup, IR_CONFIG_1,\r\nirda_read(aup, IR_CONFIG_1) | IR_RX_ENABLE);\r\nirda_write(aup, IR_RING_PROMPT, 0);\r\n}\r\n}\r\n}\r\nstatic int au1k_irda_rx(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nvolatile struct ring_dest *prxd;\r\nstruct sk_buff *skb;\r\nstruct db_dest *pDB;\r\nu32 flags, count;\r\nprxd = aup->rx_ring[aup->rx_head];\r\nflags = prxd->flags;\r\nwhile (!(flags & AU_OWN)) {\r\npDB = aup->rx_db_inuse[aup->rx_head];\r\ncount = (prxd->count_1 << 8) | prxd->count_0;\r\nif (!(flags & IR_RX_ERROR)) {\r\nupdate_rx_stats(dev, flags, count);\r\nskb = alloc_skb(count + 1, GFP_ATOMIC);\r\nif (skb == NULL) {\r\ndev->stats.rx_dropped++;\r\ncontinue;\r\n}\r\nskb_reserve(skb, 1);\r\nif (aup->speed == 4000000)\r\nskb_put(skb, count);\r\nelse\r\nskb_put(skb, count - 2);\r\nskb_copy_to_linear_data(skb, (void *)pDB->vaddr,\r\ncount - 2);\r\nskb->dev = dev;\r\nskb_reset_mac_header(skb);\r\nskb->protocol = htons(ETH_P_IRDA);\r\nnetif_rx(skb);\r\nprxd->count_0 = 0;\r\nprxd->count_1 = 0;\r\n}\r\nprxd->flags |= AU_OWN;\r\naup->rx_head = (aup->rx_head + 1) & (NUM_IR_DESC - 1);\r\nirda_write(aup, IR_RING_PROMPT, 0);\r\nprxd = aup->rx_ring[aup->rx_head];\r\nflags = prxd->flags;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t au1k_irda_interrupt(int dummy, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nirda_write(aup, IR_INT_CLEAR, 0);\r\nau1k_irda_rx(dev);\r\nau1k_tx_ack(dev);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int au1k_init(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nu32 enable, ring_address, phyck;\r\nstruct clk *c;\r\nint i;\r\nc = clk_get(NULL, "irda_clk");\r\nif (IS_ERR(c))\r\nreturn PTR_ERR(c);\r\ni = clk_prepare_enable(c);\r\nif (i) {\r\nclk_put(c);\r\nreturn i;\r\n}\r\nswitch (clk_get_rate(c)) {\r\ncase 40000000:\r\nphyck = IR_PHYCLK_40MHZ;\r\nbreak;\r\ncase 48000000:\r\nphyck = IR_PHYCLK_48MHZ;\r\nbreak;\r\ncase 56000000:\r\nphyck = IR_PHYCLK_56MHZ;\r\nbreak;\r\ncase 64000000:\r\nphyck = IR_PHYCLK_64MHZ;\r\nbreak;\r\ndefault:\r\nclk_disable_unprepare(c);\r\nclk_put(c);\r\nreturn -EINVAL;\r\n}\r\naup->irda_clk = c;\r\nenable = IR_HC | IR_CE | IR_C;\r\n#ifndef CONFIG_CPU_LITTLE_ENDIAN\r\nenable |= IR_BE;\r\n#endif\r\naup->tx_head = 0;\r\naup->tx_tail = 0;\r\naup->rx_head = 0;\r\nfor (i = 0; i < NUM_IR_DESC; i++)\r\naup->rx_ring[i]->flags = AU_OWN;\r\nirda_write(aup, IR_ENABLE, enable);\r\nmsleep(20);\r\nau1k_irda_plat_set_phy_mode(aup, AU1000_IRDA_PHY_MODE_OFF);\r\nirda_write(aup, IR_STATUS, irda_read(aup, IR_STATUS) & ~IR_PHYEN);\r\nmsleep(20);\r\nirda_write(aup, IR_MAX_PKT_LEN, MAX_BUF_SIZE);\r\nring_address = (u32)virt_to_phys((void *)aup->rx_ring[0]);\r\nirda_write(aup, IR_RING_BASE_ADDR_H, ring_address >> 26);\r\nirda_write(aup, IR_RING_BASE_ADDR_L, (ring_address >> 10) & 0xffff);\r\nirda_write(aup, IR_RING_SIZE,\r\n(RING_SIZE_64 << 8) | (RING_SIZE_64 << 12));\r\nirda_write(aup, IR_CONFIG_2, phyck | IR_ONE_PIN);\r\nirda_write(aup, IR_RING_ADDR_CMPR, 0);\r\nau1k_irda_set_speed(dev, 9600);\r\nreturn 0;\r\n}\r\nstatic int au1k_irda_start(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nchar hwname[32];\r\nint retval;\r\nretval = au1k_init(dev);\r\nif (retval) {\r\nprintk(KERN_ERR "%s: error in au1k_init\n", dev->name);\r\nreturn retval;\r\n}\r\nretval = request_irq(aup->irq_tx, &au1k_irda_interrupt, 0,\r\ndev->name, dev);\r\nif (retval) {\r\nprintk(KERN_ERR "%s: unable to get IRQ %d\n",\r\ndev->name, dev->irq);\r\nreturn retval;\r\n}\r\nretval = request_irq(aup->irq_rx, &au1k_irda_interrupt, 0,\r\ndev->name, dev);\r\nif (retval) {\r\nfree_irq(aup->irq_tx, dev);\r\nprintk(KERN_ERR "%s: unable to get IRQ %d\n",\r\ndev->name, dev->irq);\r\nreturn retval;\r\n}\r\nsprintf(hwname, "Au1000 SIR/FIR");\r\naup->irlap = irlap_open(dev, &aup->qos, hwname);\r\nnetif_start_queue(dev);\r\nirda_write(aup, IR_CONFIG_2, irda_read(aup, IR_CONFIG_2) | IR_IEN);\r\nau1k_irda_plat_set_phy_mode(aup, AU1000_IRDA_PHY_MODE_SIR);\r\nreturn 0;\r\n}\r\nstatic int au1k_irda_stop(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nau1k_irda_plat_set_phy_mode(aup, AU1000_IRDA_PHY_MODE_OFF);\r\nirda_write(aup, IR_CONFIG_2, irda_read(aup, IR_CONFIG_2) & ~IR_IEN);\r\nirda_write(aup, IR_CONFIG_1, 0);\r\nirda_write(aup, IR_ENABLE, 0);\r\nif (aup->irlap) {\r\nirlap_close(aup->irlap);\r\naup->irlap = NULL;\r\n}\r\nnetif_stop_queue(dev);\r\nfree_irq(aup->irq_tx, dev);\r\nfree_irq(aup->irq_rx, dev);\r\nclk_disable_unprepare(aup->irda_clk);\r\nclk_put(aup->irda_clk);\r\nreturn 0;\r\n}\r\nstatic int au1k_irda_hard_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nint speed = irda_get_next_speed(skb);\r\nvolatile struct ring_dest *ptxd;\r\nstruct db_dest *pDB;\r\nu32 len, flags;\r\nif (speed != aup->speed && speed != -1)\r\naup->newspeed = speed;\r\nif ((skb->len == 0) && (aup->newspeed)) {\r\nif (aup->tx_tail == aup->tx_head) {\r\nau1k_irda_set_speed(dev, speed);\r\naup->newspeed = 0;\r\n}\r\ndev_kfree_skb(skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nptxd = aup->tx_ring[aup->tx_head];\r\nflags = ptxd->flags;\r\nif (flags & AU_OWN) {\r\nprintk(KERN_DEBUG "%s: tx_full\n", dev->name);\r\nnetif_stop_queue(dev);\r\naup->tx_full = 1;\r\nreturn 1;\r\n} else if (((aup->tx_head + 1) & (NUM_IR_DESC - 1)) == aup->tx_tail) {\r\nprintk(KERN_DEBUG "%s: tx_full\n", dev->name);\r\nnetif_stop_queue(dev);\r\naup->tx_full = 1;\r\nreturn 1;\r\n}\r\npDB = aup->tx_db_inuse[aup->tx_head];\r\n#if 0\r\nif (irda_read(aup, IR_RX_BYTE_CNT) != 0) {\r\nprintk(KERN_DEBUG "tx warning: rx byte cnt %x\n",\r\nirda_read(aup, IR_RX_BYTE_CNT));\r\n}\r\n#endif\r\nif (aup->speed == 4000000) {\r\nskb_copy_from_linear_data(skb, (void *)pDB->vaddr, skb->len);\r\nptxd->count_0 = skb->len & 0xff;\r\nptxd->count_1 = (skb->len >> 8) & 0xff;\r\n} else {\r\nlen = async_wrap_skb(skb, (u8 *)pDB->vaddr, MAX_BUF_SIZE);\r\nptxd->count_0 = len & 0xff;\r\nptxd->count_1 = (len >> 8) & 0xff;\r\nptxd->flags |= IR_DIS_CRC;\r\n}\r\nptxd->flags |= AU_OWN;\r\nwmb();\r\nirda_write(aup, IR_CONFIG_1,\r\nirda_read(aup, IR_CONFIG_1) | IR_TX_ENABLE);\r\nirda_write(aup, IR_RING_PROMPT, 0);\r\ndev_kfree_skb(skb);\r\naup->tx_head = (aup->tx_head + 1) & (NUM_IR_DESC - 1);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void au1k_tx_timeout(struct net_device *dev)\r\n{\r\nu32 speed;\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nprintk(KERN_ERR "%s: tx timeout\n", dev->name);\r\nspeed = aup->speed;\r\naup->speed = 0;\r\nau1k_irda_set_speed(dev, speed);\r\naup->tx_full = 0;\r\nnetif_wake_queue(dev);\r\n}\r\nstatic int au1k_irda_ioctl(struct net_device *dev, struct ifreq *ifreq, int cmd)\r\n{\r\nstruct if_irda_req *rq = (struct if_irda_req *)ifreq;\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nint ret = -EOPNOTSUPP;\r\nswitch (cmd) {\r\ncase SIOCSBANDWIDTH:\r\nif (capable(CAP_NET_ADMIN)) {\r\nif (aup->open)\r\nret = au1k_irda_set_speed(dev,\r\nrq->ifr_baudrate);\r\nelse {\r\nprintk(KERN_ERR "%s ioctl: !netif_running\n",\r\ndev->name);\r\nret = 0;\r\n}\r\n}\r\nbreak;\r\ncase SIOCSMEDIABUSY:\r\nret = -EPERM;\r\nif (capable(CAP_NET_ADMIN)) {\r\nirda_device_set_media_busy(dev, TRUE);\r\nret = 0;\r\n}\r\nbreak;\r\ncase SIOCGRECEIVING:\r\nrq->ifr_receiving = 0;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic int au1k_irda_net_init(struct net_device *dev)\r\n{\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nstruct db_dest *pDB, *pDBfree;\r\nint i, err, retval = 0;\r\ndma_addr_t temp;\r\nerr = au1k_irda_init_iobuf(&aup->rx_buff, 14384);\r\nif (err)\r\ngoto out1;\r\ndev->netdev_ops = &au1k_irda_netdev_ops;\r\nirda_init_max_qos_capabilies(&aup->qos);\r\naup->qos.baud_rate.bits = IR_9600 | IR_19200 | IR_38400 |\r\nIR_57600 | IR_115200 | IR_576000 | (IR_4000000 << 8);\r\naup->qos.min_turn_time.bits = qos_mtt_bits;\r\nirda_qos_bits_to_value(&aup->qos);\r\nretval = -ENOMEM;\r\naup->rx_ring[0] = (struct ring_dest *)\r\ndma_alloc(2 * MAX_NUM_IR_DESC * (sizeof(struct ring_dest)),\r\n&temp);\r\nif (!aup->rx_ring[0])\r\ngoto out2;\r\naup->db[0].vaddr =\r\ndma_alloc(MAX_BUF_SIZE * 2 * NUM_IR_DESC, &temp);\r\nif (!aup->db[0].vaddr)\r\ngoto out3;\r\nsetup_hw_rings(aup, (u32)aup->rx_ring[0], (u32)aup->rx_ring[0] + 512);\r\npDBfree = NULL;\r\npDB = aup->db;\r\nfor (i = 0; i < (2 * NUM_IR_DESC); i++) {\r\npDB->pnext = pDBfree;\r\npDBfree = pDB;\r\npDB->vaddr =\r\n(u32 *)((unsigned)aup->db[0].vaddr + (MAX_BUF_SIZE * i));\r\npDB->dma_addr = (dma_addr_t)virt_to_bus(pDB->vaddr);\r\npDB++;\r\n}\r\naup->pDBfree = pDBfree;\r\nfor (i = 0; i < NUM_IR_DESC; i++) {\r\npDB = GetFreeDB(aup);\r\nif (!pDB)\r\ngoto out3;\r\naup->rx_ring[i]->addr_0 = (u8)(pDB->dma_addr & 0xff);\r\naup->rx_ring[i]->addr_1 = (u8)((pDB->dma_addr >> 8) & 0xff);\r\naup->rx_ring[i]->addr_2 = (u8)((pDB->dma_addr >> 16) & 0xff);\r\naup->rx_ring[i]->addr_3 = (u8)((pDB->dma_addr >> 24) & 0xff);\r\naup->rx_db_inuse[i] = pDB;\r\n}\r\nfor (i = 0; i < NUM_IR_DESC; i++) {\r\npDB = GetFreeDB(aup);\r\nif (!pDB)\r\ngoto out3;\r\naup->tx_ring[i]->addr_0 = (u8)(pDB->dma_addr & 0xff);\r\naup->tx_ring[i]->addr_1 = (u8)((pDB->dma_addr >> 8) & 0xff);\r\naup->tx_ring[i]->addr_2 = (u8)((pDB->dma_addr >> 16) & 0xff);\r\naup->tx_ring[i]->addr_3 = (u8)((pDB->dma_addr >> 24) & 0xff);\r\naup->tx_ring[i]->count_0 = 0;\r\naup->tx_ring[i]->count_1 = 0;\r\naup->tx_ring[i]->flags = 0;\r\naup->tx_db_inuse[i] = pDB;\r\n}\r\nreturn 0;\r\nout3:\r\ndma_free((void *)aup->rx_ring[0],\r\n2 * MAX_NUM_IR_DESC * (sizeof(struct ring_dest)));\r\nout2:\r\nkfree(aup->rx_buff.head);\r\nout1:\r\nprintk(KERN_ERR "au1k_irda_net_init() failed. Returns %d\n", retval);\r\nreturn retval;\r\n}\r\nstatic int au1k_irda_probe(struct platform_device *pdev)\r\n{\r\nstruct au1k_private *aup;\r\nstruct net_device *dev;\r\nstruct resource *r;\r\nstruct clk *c;\r\nint err;\r\ndev = alloc_irdadev(sizeof(struct au1k_private));\r\nif (!dev)\r\nreturn -ENOMEM;\r\naup = netdev_priv(dev);\r\naup->platdata = pdev->dev.platform_data;\r\nerr = -EINVAL;\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\r\nif (!r)\r\ngoto out;\r\naup->irq_tx = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_IRQ, 1);\r\nif (!r)\r\ngoto out;\r\naup->irq_rx = r->start;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!r)\r\ngoto out;\r\nerr = -EBUSY;\r\naup->ioarea = request_mem_region(r->start, resource_size(r),\r\npdev->name);\r\nif (!aup->ioarea)\r\ngoto out;\r\nc = clk_get(NULL, "irda_clk");\r\nif (IS_ERR(c)) {\r\nerr = PTR_ERR(c);\r\ngoto out;\r\n}\r\nclk_put(c);\r\naup->iobase = ioremap_nocache(r->start, resource_size(r));\r\nif (!aup->iobase)\r\ngoto out2;\r\ndev->irq = aup->irq_rx;\r\nerr = au1k_irda_net_init(dev);\r\nif (err)\r\ngoto out3;\r\nerr = register_netdev(dev);\r\nif (err)\r\ngoto out4;\r\nplatform_set_drvdata(pdev, dev);\r\nprintk(KERN_INFO "IrDA: Registered device %s\n", dev->name);\r\nreturn 0;\r\nout4:\r\ndma_free((void *)aup->db[0].vaddr,\r\nMAX_BUF_SIZE * 2 * NUM_IR_DESC);\r\ndma_free((void *)aup->rx_ring[0],\r\n2 * MAX_NUM_IR_DESC * (sizeof(struct ring_dest)));\r\nkfree(aup->rx_buff.head);\r\nout3:\r\niounmap(aup->iobase);\r\nout2:\r\nrelease_resource(aup->ioarea);\r\nkfree(aup->ioarea);\r\nout:\r\nfree_netdev(dev);\r\nreturn err;\r\n}\r\nstatic int au1k_irda_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *dev = platform_get_drvdata(pdev);\r\nstruct au1k_private *aup = netdev_priv(dev);\r\nunregister_netdev(dev);\r\ndma_free((void *)aup->db[0].vaddr,\r\nMAX_BUF_SIZE * 2 * NUM_IR_DESC);\r\ndma_free((void *)aup->rx_ring[0],\r\n2 * MAX_NUM_IR_DESC * (sizeof(struct ring_dest)));\r\nkfree(aup->rx_buff.head);\r\niounmap(aup->iobase);\r\nrelease_resource(aup->ioarea);\r\nkfree(aup->ioarea);\r\nfree_netdev(dev);\r\nreturn 0;\r\n}
