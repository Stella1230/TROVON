static int smbb_vbat_weak_fn(unsigned int index)\r\n{\r\nreturn 2100000 + index * 100000;\r\n}\r\nstatic int smbb_vin_fn(unsigned int index)\r\n{\r\nif (index > 42)\r\nreturn 5600000 + (index - 43) * 200000;\r\nreturn 3400000 + index * 50000;\r\n}\r\nstatic int smbb_vmax_fn(unsigned int index)\r\n{\r\nreturn 3240000 + index * 10000;\r\n}\r\nstatic int smbb_vbat_det_fn(unsigned int index)\r\n{\r\nreturn 3240000 + index * 20000;\r\n}\r\nstatic int smbb_imax_fn(unsigned int index)\r\n{\r\nif (index < 2)\r\nreturn 100000 + index * 50000;\r\nreturn index * 100000;\r\n}\r\nstatic int smbb_bat_imax_fn(unsigned int index)\r\n{\r\nreturn index * 50000;\r\n}\r\nstatic unsigned int smbb_hw_lookup(unsigned int val, int (*fn)(unsigned int))\r\n{\r\nunsigned int widx;\r\nunsigned int sel;\r\nfor (widx = sel = 0; (*fn)(widx) <= val; ++widx)\r\nsel = widx;\r\nreturn sel;\r\n}\r\nstatic int smbb_charger_attr_write(struct smbb_charger *chg,\r\nenum smbb_attr which, unsigned int val)\r\n{\r\nconst struct smbb_charger_attr *prop;\r\nunsigned int wval;\r\nunsigned int out;\r\nint rc;\r\nprop = &smbb_charger_attrs[which];\r\nif (val > prop->max || val < prop->min) {\r\ndev_err(chg->dev, "value out of range for %s [%u:%u]\n",\r\nprop->name, prop->min, prop->max);\r\nreturn -EINVAL;\r\n}\r\nif (prop->safe_reg) {\r\nrc = regmap_read(chg->regmap,\r\nchg->addr + prop->safe_reg, &wval);\r\nif (rc) {\r\ndev_err(chg->dev,\r\n"unable to read safe value for '%s'\n",\r\nprop->name);\r\nreturn rc;\r\n}\r\nwval = prop->hw_fn(wval);\r\nif (val > wval) {\r\ndev_warn(chg->dev,\r\n"%s above safe value, clamping at %u\n",\r\nprop->name, wval);\r\nval = wval;\r\n}\r\n}\r\nwval = smbb_hw_lookup(val, prop->hw_fn);\r\nrc = regmap_write(chg->regmap, chg->addr + prop->reg, wval);\r\nif (rc) {\r\ndev_err(chg->dev, "unable to update %s", prop->name);\r\nreturn rc;\r\n}\r\nout = prop->hw_fn(wval);\r\nif (out != val) {\r\ndev_warn(chg->dev,\r\n"%s inaccurate, rounded to %u\n",\r\nprop->name, out);\r\n}\r\ndev_dbg(chg->dev, "%s <= %d\n", prop->name, out);\r\nchg->attr[which] = out;\r\nreturn 0;\r\n}\r\nstatic int smbb_charger_attr_read(struct smbb_charger *chg,\r\nenum smbb_attr which)\r\n{\r\nconst struct smbb_charger_attr *prop;\r\nunsigned int val;\r\nint rc;\r\nprop = &smbb_charger_attrs[which];\r\nrc = regmap_read(chg->regmap, chg->addr + prop->reg, &val);\r\nif (rc) {\r\ndev_err(chg->dev, "failed to read %s\n", prop->name);\r\nreturn rc;\r\n}\r\nval = prop->hw_fn(val);\r\ndev_dbg(chg->dev, "%s => %d\n", prop->name, val);\r\nchg->attr[which] = val;\r\nreturn 0;\r\n}\r\nstatic int smbb_charger_attr_parse(struct smbb_charger *chg,\r\nenum smbb_attr which)\r\n{\r\nconst struct smbb_charger_attr *prop;\r\nunsigned int val;\r\nint rc;\r\nprop = &smbb_charger_attrs[which];\r\nrc = of_property_read_u32(chg->dev->of_node, prop->name, &val);\r\nif (rc == 0) {\r\nrc = smbb_charger_attr_write(chg, which, val);\r\nif (!rc || !prop->fail_ok)\r\nreturn rc;\r\n}\r\nreturn smbb_charger_attr_read(chg, which);\r\n}\r\nstatic void smbb_set_line_flag(struct smbb_charger *chg, int irq, int flag)\r\n{\r\nbool state;\r\nint ret;\r\nret = irq_get_irqchip_state(irq, IRQCHIP_STATE_LINE_LEVEL, &state);\r\nif (ret < 0) {\r\ndev_err(chg->dev, "failed to read irq line\n");\r\nreturn;\r\n}\r\nmutex_lock(&chg->statlock);\r\nif (state)\r\nchg->status |= flag;\r\nelse\r\nchg->status &= ~flag;\r\nmutex_unlock(&chg->statlock);\r\ndev_dbg(chg->dev, "status = %03lx\n", chg->status);\r\n}\r\nstatic irqreturn_t smbb_usb_valid_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_USBIN_VALID);\r\nextcon_set_state_sync(chg->edev, EXTCON_USB,\r\nchg->status & STATUS_USBIN_VALID);\r\npower_supply_changed(chg->usb_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_dc_valid_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_DCIN_VALID);\r\nif (!chg->dc_disabled)\r\npower_supply_changed(chg->dc_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_bat_temp_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nunsigned int val;\r\nint rc;\r\nrc = regmap_read(chg->regmap, chg->addr + SMBB_BAT_TEMP_STATUS, &val);\r\nif (rc)\r\nreturn IRQ_HANDLED;\r\nmutex_lock(&chg->statlock);\r\nif (val & TEMP_STATUS_OK) {\r\nchg->status |= STATUS_BAT_OK;\r\n} else {\r\nchg->status &= ~STATUS_BAT_OK;\r\nif (val & TEMP_STATUS_HOT)\r\nchg->status |= STATUS_BAT_HOT;\r\n}\r\nmutex_unlock(&chg->statlock);\r\npower_supply_changed(chg->bat_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_bat_present_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_BAT_PRESENT);\r\npower_supply_changed(chg->bat_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_chg_done_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_CHG_DONE);\r\npower_supply_changed(chg->bat_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_chg_gone_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_CHG_GONE);\r\npower_supply_changed(chg->bat_psy);\r\npower_supply_changed(chg->usb_psy);\r\nif (!chg->dc_disabled)\r\npower_supply_changed(chg->dc_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_chg_fast_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_CHG_FAST);\r\npower_supply_changed(chg->bat_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t smbb_chg_trkl_handler(int irq, void *_data)\r\n{\r\nstruct smbb_charger *chg = _data;\r\nsmbb_set_line_flag(chg, irq, STATUS_CHG_TRKL);\r\npower_supply_changed(chg->bat_psy);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int smbb_usbin_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct smbb_charger *chg = power_supply_get_drvdata(psy);\r\nint rc = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nmutex_lock(&chg->statlock);\r\nval->intval = !(chg->status & STATUS_CHG_GONE) &&\r\n(chg->status & STATUS_USBIN_VALID);\r\nmutex_unlock(&chg->statlock);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nval->intval = chg->attr[ATTR_USBIN_IMAX];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\r\nval->intval = 2500000;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smbb_usbin_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct smbb_charger *chg = power_supply_get_drvdata(psy);\r\nint rc;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nrc = smbb_charger_attr_write(chg, ATTR_USBIN_IMAX,\r\nval->intval);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smbb_dcin_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct smbb_charger *chg = power_supply_get_drvdata(psy);\r\nint rc = 0;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nmutex_lock(&chg->statlock);\r\nval->intval = !(chg->status & STATUS_CHG_GONE) &&\r\n(chg->status & STATUS_DCIN_VALID);\r\nmutex_unlock(&chg->statlock);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nval->intval = chg->attr[ATTR_DCIN_IMAX];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\r\nval->intval = 2500000;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smbb_dcin_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct smbb_charger *chg = power_supply_get_drvdata(psy);\r\nint rc;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nrc = smbb_charger_attr_write(chg, ATTR_DCIN_IMAX,\r\nval->intval);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smbb_charger_writable_property(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nreturn psp == POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT;\r\n}\r\nstatic int smbb_battery_get_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct smbb_charger *chg = power_supply_get_drvdata(psy);\r\nunsigned long status;\r\nint rc = 0;\r\nmutex_lock(&chg->statlock);\r\nstatus = chg->status;\r\nmutex_unlock(&chg->statlock);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_STATUS:\r\nif (status & STATUS_CHG_GONE)\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (!(status & (STATUS_DCIN_VALID | STATUS_USBIN_VALID)))\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (status & STATUS_CHG_DONE)\r\nval->intval = POWER_SUPPLY_STATUS_FULL;\r\nelse if (!(status & STATUS_BAT_OK))\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nelse if (status & (STATUS_CHG_FAST | STATUS_CHG_TRKL))\r\nval->intval = POWER_SUPPLY_STATUS_CHARGING;\r\nelse\r\nval->intval = POWER_SUPPLY_STATUS_DISCHARGING;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (status & STATUS_BAT_OK)\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nelse if (status & STATUS_BAT_HOT)\r\nval->intval = POWER_SUPPLY_HEALTH_OVERHEAT;\r\nelse\r\nval->intval = POWER_SUPPLY_HEALTH_COLD;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CHARGE_TYPE:\r\nif (status & STATUS_CHG_FAST)\r\nval->intval = POWER_SUPPLY_CHARGE_TYPE_FAST;\r\nelse if (status & STATUS_CHG_TRKL)\r\nval->intval = POWER_SUPPLY_CHARGE_TYPE_TRICKLE;\r\nelse\r\nval->intval = POWER_SUPPLY_CHARGE_TYPE_NONE;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = !!(status & STATUS_BAT_PRESENT);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nval->intval = chg->attr[ATTR_BAT_IMAX];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nval->intval = chg->attr[ATTR_BAT_VMAX];\r\nbreak;\r\ncase POWER_SUPPLY_PROP_TECHNOLOGY:\r\nval->intval = POWER_SUPPLY_TECHNOLOGY_LION;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nval->intval = 3000000;\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smbb_battery_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct smbb_charger *chg = power_supply_get_drvdata(psy);\r\nint rc;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nrc = smbb_charger_attr_write(chg, ATTR_BAT_IMAX, val->intval);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nrc = smbb_charger_attr_write(chg, ATTR_BAT_VMAX, val->intval);\r\nbreak;\r\ndefault:\r\nrc = -EINVAL;\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic int smbb_battery_writable_property(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nreturn 1;\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nstatic int smbb_chg_otg_enable(struct regulator_dev *rdev)\r\n{\r\nstruct smbb_charger *chg = rdev_get_drvdata(rdev);\r\nint rc;\r\nrc = regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,\r\nOTG_CTL_EN, OTG_CTL_EN);\r\nif (rc)\r\ndev_err(chg->dev, "failed to update OTG_CTL\n");\r\nreturn rc;\r\n}\r\nstatic int smbb_chg_otg_disable(struct regulator_dev *rdev)\r\n{\r\nstruct smbb_charger *chg = rdev_get_drvdata(rdev);\r\nint rc;\r\nrc = regmap_update_bits(chg->regmap, chg->addr + SMBB_USB_OTG_CTL,\r\nOTG_CTL_EN, 0);\r\nif (rc)\r\ndev_err(chg->dev, "failed to update OTG_CTL\n");\r\nreturn rc;\r\n}\r\nstatic int smbb_chg_otg_is_enabled(struct regulator_dev *rdev)\r\n{\r\nstruct smbb_charger *chg = rdev_get_drvdata(rdev);\r\nunsigned int value = 0;\r\nint rc;\r\nrc = regmap_read(chg->regmap, chg->addr + SMBB_USB_OTG_CTL, &value);\r\nif (rc)\r\ndev_err(chg->dev, "failed to read OTG_CTL\n");\r\nreturn !!(value & OTG_CTL_EN);\r\n}\r\nstatic int smbb_charger_probe(struct platform_device *pdev)\r\n{\r\nstruct power_supply_config bat_cfg = {};\r\nstruct power_supply_config usb_cfg = {};\r\nstruct power_supply_config dc_cfg = {};\r\nstruct smbb_charger *chg;\r\nstruct regulator_config config = { };\r\nint rc, i;\r\nchg = devm_kzalloc(&pdev->dev, sizeof(*chg), GFP_KERNEL);\r\nif (!chg)\r\nreturn -ENOMEM;\r\nchg->dev = &pdev->dev;\r\nmutex_init(&chg->statlock);\r\nchg->regmap = dev_get_regmap(pdev->dev.parent, NULL);\r\nif (!chg->regmap) {\r\ndev_err(&pdev->dev, "failed to locate regmap\n");\r\nreturn -ENODEV;\r\n}\r\nrc = of_property_read_u32(pdev->dev.of_node, "reg", &chg->addr);\r\nif (rc) {\r\ndev_err(&pdev->dev, "missing or invalid 'reg' property\n");\r\nreturn rc;\r\n}\r\nrc = regmap_read(chg->regmap, chg->addr + SMBB_MISC_REV2, &chg->revision);\r\nif (rc) {\r\ndev_err(&pdev->dev, "unable to read revision\n");\r\nreturn rc;\r\n}\r\nchg->revision += 1;\r\nif (chg->revision != 2 && chg->revision != 3) {\r\ndev_err(&pdev->dev, "v1 hardware not supported\n");\r\nreturn -ENODEV;\r\n}\r\ndev_info(&pdev->dev, "Initializing SMBB rev %u", chg->revision);\r\nchg->dc_disabled = of_property_read_bool(pdev->dev.of_node, "qcom,disable-dc");\r\nfor (i = 0; i < _ATTR_CNT; ++i) {\r\nrc = smbb_charger_attr_parse(chg, i);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to parse/apply settings\n");\r\nreturn rc;\r\n}\r\n}\r\nbat_cfg.drv_data = chg;\r\nbat_cfg.of_node = pdev->dev.of_node;\r\nchg->bat_psy = devm_power_supply_register(&pdev->dev,\r\n&bat_psy_desc,\r\n&bat_cfg);\r\nif (IS_ERR(chg->bat_psy)) {\r\ndev_err(&pdev->dev, "failed to register battery\n");\r\nreturn PTR_ERR(chg->bat_psy);\r\n}\r\nusb_cfg.drv_data = chg;\r\nusb_cfg.supplied_to = smbb_bif;\r\nusb_cfg.num_supplicants = ARRAY_SIZE(smbb_bif);\r\nchg->usb_psy = devm_power_supply_register(&pdev->dev,\r\n&usb_psy_desc,\r\n&usb_cfg);\r\nif (IS_ERR(chg->usb_psy)) {\r\ndev_err(&pdev->dev, "failed to register USB power supply\n");\r\nreturn PTR_ERR(chg->usb_psy);\r\n}\r\nchg->edev = devm_extcon_dev_allocate(&pdev->dev, smbb_usb_extcon_cable);\r\nif (IS_ERR(chg->edev)) {\r\ndev_err(&pdev->dev, "failed to allocate extcon device\n");\r\nreturn -ENOMEM;\r\n}\r\nrc = devm_extcon_dev_register(&pdev->dev, chg->edev);\r\nif (rc < 0) {\r\ndev_err(&pdev->dev, "failed to register extcon device\n");\r\nreturn rc;\r\n}\r\nif (!chg->dc_disabled) {\r\ndc_cfg.drv_data = chg;\r\ndc_cfg.supplied_to = smbb_bif;\r\ndc_cfg.num_supplicants = ARRAY_SIZE(smbb_bif);\r\nchg->dc_psy = devm_power_supply_register(&pdev->dev,\r\n&dc_psy_desc,\r\n&dc_cfg);\r\nif (IS_ERR(chg->dc_psy)) {\r\ndev_err(&pdev->dev, "failed to register DC power supply\n");\r\nreturn PTR_ERR(chg->dc_psy);\r\n}\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(smbb_charger_irqs); ++i) {\r\nint irq;\r\nirq = platform_get_irq_byname(pdev, smbb_charger_irqs[i].name);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "failed to get irq '%s'\n",\r\nsmbb_charger_irqs[i].name);\r\nreturn irq;\r\n}\r\nsmbb_charger_irqs[i].handler(irq, chg);\r\nrc = devm_request_threaded_irq(&pdev->dev, irq, NULL,\r\nsmbb_charger_irqs[i].handler, IRQF_ONESHOT,\r\nsmbb_charger_irqs[i].name, chg);\r\nif (rc) {\r\ndev_err(&pdev->dev, "failed to request irq '%s'\n",\r\nsmbb_charger_irqs[i].name);\r\nreturn rc;\r\n}\r\n}\r\nchg->otg_rdesc.id = -1;\r\nchg->otg_rdesc.name = "otg-vbus";\r\nchg->otg_rdesc.ops = &smbb_chg_otg_ops;\r\nchg->otg_rdesc.owner = THIS_MODULE;\r\nchg->otg_rdesc.type = REGULATOR_VOLTAGE;\r\nchg->otg_rdesc.supply_name = "usb-otg-in";\r\nchg->otg_rdesc.of_match = "otg-vbus";\r\nconfig.dev = &pdev->dev;\r\nconfig.driver_data = chg;\r\nchg->otg_reg = devm_regulator_register(&pdev->dev, &chg->otg_rdesc,\r\n&config);\r\nif (IS_ERR(chg->otg_reg))\r\nreturn PTR_ERR(chg->otg_reg);\r\nchg->jeita_ext_temp = of_property_read_bool(pdev->dev.of_node,\r\n"qcom,jeita-extended-temp-range");\r\nrc = regmap_update_bits(chg->regmap, chg->addr + SMBB_BAT_BTC_CTRL,\r\nBTC_CTRL_COLD_EXT | BTC_CTRL_HOT_EXT_N,\r\nchg->jeita_ext_temp ?\r\nBTC_CTRL_COLD_EXT :\r\nBTC_CTRL_HOT_EXT_N);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"unable to set %s temperature range\n",\r\nchg->jeita_ext_temp ? "JEITA extended" : "normal");\r\nreturn rc;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(smbb_charger_setup); ++i) {\r\nconst struct reg_off_mask_default *r = &smbb_charger_setup[i];\r\nif (r->rev_mask & BIT(chg->revision))\r\ncontinue;\r\nrc = regmap_update_bits(chg->regmap, chg->addr + r->offset,\r\nr->mask, r->value);\r\nif (rc) {\r\ndev_err(&pdev->dev,\r\n"unable to initializing charging, bailing\n");\r\nreturn rc;\r\n}\r\n}\r\nplatform_set_drvdata(pdev, chg);\r\nreturn 0;\r\n}\r\nstatic int smbb_charger_remove(struct platform_device *pdev)\r\n{\r\nstruct smbb_charger *chg;\r\nchg = platform_get_drvdata(pdev);\r\nregmap_update_bits(chg->regmap, chg->addr + SMBB_CHG_CTRL, CTRL_EN, 0);\r\nreturn 0;\r\n}
