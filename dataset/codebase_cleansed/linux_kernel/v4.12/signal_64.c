asmlinkage void sparc64_set_context(struct pt_regs *regs)\r\n{\r\nstruct ucontext __user *ucp = (struct ucontext __user *)\r\nregs->u_regs[UREG_I0];\r\nenum ctx_state prev_state = exception_enter();\r\nmc_gregset_t __user *grp;\r\nunsigned long pc, npc, tstate;\r\nunsigned long fp, i7;\r\nunsigned char fenab;\r\nint err;\r\nsynchronize_user_stack();\r\nif (get_thread_wsaved() ||\r\n(((unsigned long)ucp) & (sizeof(unsigned long)-1)) ||\r\n(!__access_ok(ucp, sizeof(*ucp))))\r\ngoto do_sigsegv;\r\ngrp = &ucp->uc_mcontext.mc_gregs;\r\nerr = __get_user(pc, &((*grp)[MC_PC]));\r\nerr |= __get_user(npc, &((*grp)[MC_NPC]));\r\nif (err || ((pc | npc) & 3))\r\ngoto do_sigsegv;\r\nif (regs->u_regs[UREG_I1]) {\r\nsigset_t set;\r\nif (_NSIG_WORDS == 1) {\r\nif (__get_user(set.sig[0], &ucp->uc_sigmask.sig[0]))\r\ngoto do_sigsegv;\r\n} else {\r\nif (__copy_from_user(&set, &ucp->uc_sigmask, sizeof(sigset_t)))\r\ngoto do_sigsegv;\r\n}\r\nset_current_blocked(&set);\r\n}\r\nif (test_thread_flag(TIF_32BIT)) {\r\npc &= 0xffffffff;\r\nnpc &= 0xffffffff;\r\n}\r\nregs->tpc = pc;\r\nregs->tnpc = npc;\r\nerr |= __get_user(regs->y, &((*grp)[MC_Y]));\r\nerr |= __get_user(tstate, &((*grp)[MC_TSTATE]));\r\nregs->tstate &= ~(TSTATE_ASI | TSTATE_ICC | TSTATE_XCC);\r\nregs->tstate |= (tstate & (TSTATE_ASI | TSTATE_ICC | TSTATE_XCC));\r\nerr |= __get_user(regs->u_regs[UREG_G1], (&(*grp)[MC_G1]));\r\nerr |= __get_user(regs->u_regs[UREG_G2], (&(*grp)[MC_G2]));\r\nerr |= __get_user(regs->u_regs[UREG_G3], (&(*grp)[MC_G3]));\r\nerr |= __get_user(regs->u_regs[UREG_G4], (&(*grp)[MC_G4]));\r\nerr |= __get_user(regs->u_regs[UREG_G5], (&(*grp)[MC_G5]));\r\nerr |= __get_user(regs->u_regs[UREG_G6], (&(*grp)[MC_G6]));\r\nerr |= __get_user(regs->u_regs[UREG_I0], (&(*grp)[MC_O0]));\r\nerr |= __get_user(regs->u_regs[UREG_I1], (&(*grp)[MC_O1]));\r\nerr |= __get_user(regs->u_regs[UREG_I2], (&(*grp)[MC_O2]));\r\nerr |= __get_user(regs->u_regs[UREG_I3], (&(*grp)[MC_O3]));\r\nerr |= __get_user(regs->u_regs[UREG_I4], (&(*grp)[MC_O4]));\r\nerr |= __get_user(regs->u_regs[UREG_I5], (&(*grp)[MC_O5]));\r\nerr |= __get_user(regs->u_regs[UREG_I6], (&(*grp)[MC_O6]));\r\nerr |= __get_user(regs->u_regs[UREG_I7], (&(*grp)[MC_O7]));\r\nerr |= __get_user(fp, &(ucp->uc_mcontext.mc_fp));\r\nerr |= __get_user(i7, &(ucp->uc_mcontext.mc_i7));\r\nerr |= __put_user(fp,\r\n(&(((struct reg_window __user *)(STACK_BIAS+regs->u_regs[UREG_I6]))->ins[6])));\r\nerr |= __put_user(i7,\r\n(&(((struct reg_window __user *)(STACK_BIAS+regs->u_regs[UREG_I6]))->ins[7])));\r\nerr |= __get_user(fenab, &(ucp->uc_mcontext.mc_fpregs.mcfpu_enab));\r\nif (fenab) {\r\nunsigned long *fpregs = current_thread_info()->fpregs;\r\nunsigned long fprs;\r\nfprs_write(0);\r\nerr |= __get_user(fprs, &(ucp->uc_mcontext.mc_fpregs.mcfpu_fprs));\r\nif (fprs & FPRS_DL)\r\nerr |= copy_from_user(fpregs,\r\n&(ucp->uc_mcontext.mc_fpregs.mcfpu_fregs),\r\n(sizeof(unsigned int) * 32));\r\nif (fprs & FPRS_DU)\r\nerr |= copy_from_user(fpregs+16,\r\n((unsigned long __user *)&(ucp->uc_mcontext.mc_fpregs.mcfpu_fregs))+16,\r\n(sizeof(unsigned int) * 32));\r\nerr |= __get_user(current_thread_info()->xfsr[0],\r\n&(ucp->uc_mcontext.mc_fpregs.mcfpu_fsr));\r\nerr |= __get_user(current_thread_info()->gsr[0],\r\n&(ucp->uc_mcontext.mc_fpregs.mcfpu_gsr));\r\nregs->tstate &= ~TSTATE_PEF;\r\n}\r\nif (err)\r\ngoto do_sigsegv;\r\nout:\r\nexception_exit(prev_state);\r\nreturn;\r\ndo_sigsegv:\r\nforce_sig(SIGSEGV, current);\r\ngoto out;\r\n}\r\nasmlinkage void sparc64_get_context(struct pt_regs *regs)\r\n{\r\nstruct ucontext __user *ucp = (struct ucontext __user *)\r\nregs->u_regs[UREG_I0];\r\nenum ctx_state prev_state = exception_enter();\r\nmc_gregset_t __user *grp;\r\nmcontext_t __user *mcp;\r\nunsigned long fp, i7;\r\nunsigned char fenab;\r\nint err;\r\nsynchronize_user_stack();\r\nif (get_thread_wsaved() || clear_user(ucp, sizeof(*ucp)))\r\ngoto do_sigsegv;\r\n#if 1\r\nfenab = 0;\r\n#else\r\nfenab = (current_thread_info()->fpsaved[0] & FPRS_FEF);\r\n#endif\r\nmcp = &ucp->uc_mcontext;\r\ngrp = &mcp->mc_gregs;\r\nif (test_thread_flag(TIF_32BIT)) {\r\nregs->tpc = (regs->tnpc & 0xffffffff);\r\nregs->tnpc = (regs->tnpc + 4) & 0xffffffff;\r\n} else {\r\nregs->tpc = regs->tnpc;\r\nregs->tnpc += 4;\r\n}\r\nerr = 0;\r\nif (_NSIG_WORDS == 1)\r\nerr |= __put_user(current->blocked.sig[0],\r\n(unsigned long __user *)&ucp->uc_sigmask);\r\nelse\r\nerr |= __copy_to_user(&ucp->uc_sigmask, &current->blocked,\r\nsizeof(sigset_t));\r\nerr |= __put_user(regs->tstate, &((*grp)[MC_TSTATE]));\r\nerr |= __put_user(regs->tpc, &((*grp)[MC_PC]));\r\nerr |= __put_user(regs->tnpc, &((*grp)[MC_NPC]));\r\nerr |= __put_user(regs->y, &((*grp)[MC_Y]));\r\nerr |= __put_user(regs->u_regs[UREG_G1], &((*grp)[MC_G1]));\r\nerr |= __put_user(regs->u_regs[UREG_G2], &((*grp)[MC_G2]));\r\nerr |= __put_user(regs->u_regs[UREG_G3], &((*grp)[MC_G3]));\r\nerr |= __put_user(regs->u_regs[UREG_G4], &((*grp)[MC_G4]));\r\nerr |= __put_user(regs->u_regs[UREG_G5], &((*grp)[MC_G5]));\r\nerr |= __put_user(regs->u_regs[UREG_G6], &((*grp)[MC_G6]));\r\nerr |= __put_user(regs->u_regs[UREG_G7], &((*grp)[MC_G7]));\r\nerr |= __put_user(regs->u_regs[UREG_I0], &((*grp)[MC_O0]));\r\nerr |= __put_user(regs->u_regs[UREG_I1], &((*grp)[MC_O1]));\r\nerr |= __put_user(regs->u_regs[UREG_I2], &((*grp)[MC_O2]));\r\nerr |= __put_user(regs->u_regs[UREG_I3], &((*grp)[MC_O3]));\r\nerr |= __put_user(regs->u_regs[UREG_I4], &((*grp)[MC_O4]));\r\nerr |= __put_user(regs->u_regs[UREG_I5], &((*grp)[MC_O5]));\r\nerr |= __put_user(regs->u_regs[UREG_I6], &((*grp)[MC_O6]));\r\nerr |= __put_user(regs->u_regs[UREG_I7], &((*grp)[MC_O7]));\r\nerr |= __get_user(fp,\r\n(&(((struct reg_window __user *)(STACK_BIAS+regs->u_regs[UREG_I6]))->ins[6])));\r\nerr |= __get_user(i7,\r\n(&(((struct reg_window __user *)(STACK_BIAS+regs->u_regs[UREG_I6]))->ins[7])));\r\nerr |= __put_user(fp, &(mcp->mc_fp));\r\nerr |= __put_user(i7, &(mcp->mc_i7));\r\nerr |= __put_user(fenab, &(mcp->mc_fpregs.mcfpu_enab));\r\nif (fenab) {\r\nunsigned long *fpregs = current_thread_info()->fpregs;\r\nunsigned long fprs;\r\nfprs = current_thread_info()->fpsaved[0];\r\nif (fprs & FPRS_DL)\r\nerr |= copy_to_user(&(mcp->mc_fpregs.mcfpu_fregs), fpregs,\r\n(sizeof(unsigned int) * 32));\r\nif (fprs & FPRS_DU)\r\nerr |= copy_to_user(\r\n((unsigned long __user *)&(mcp->mc_fpregs.mcfpu_fregs))+16, fpregs+16,\r\n(sizeof(unsigned int) * 32));\r\nerr |= __put_user(current_thread_info()->xfsr[0], &(mcp->mc_fpregs.mcfpu_fsr));\r\nerr |= __put_user(current_thread_info()->gsr[0], &(mcp->mc_fpregs.mcfpu_gsr));\r\nerr |= __put_user(fprs, &(mcp->mc_fpregs.mcfpu_fprs));\r\n}\r\nif (err)\r\ngoto do_sigsegv;\r\nout:\r\nexception_exit(prev_state);\r\nreturn;\r\ndo_sigsegv:\r\nforce_sig(SIGSEGV, current);\r\ngoto out;\r\n}\r\nstatic bool invalid_frame_pointer(void __user *fp)\r\n{\r\nif (((unsigned long) fp) & 15)\r\nreturn true;\r\nreturn false;\r\n}\r\nvoid do_rt_sigreturn(struct pt_regs *regs)\r\n{\r\nunsigned long tpc, tnpc, tstate, ufp;\r\nstruct rt_signal_frame __user *sf;\r\n__siginfo_fpu_t __user *fpu_save;\r\n__siginfo_rwin_t __user *rwin_save;\r\nsigset_t set;\r\nint err;\r\ncurrent->restart_block.fn = do_no_restart_syscall;\r\nsynchronize_user_stack ();\r\nsf = (struct rt_signal_frame __user *)\r\n(regs->u_regs [UREG_FP] + STACK_BIAS);\r\nif (invalid_frame_pointer(sf))\r\ngoto segv;\r\nif (get_user(ufp, &sf->regs.u_regs[UREG_FP]))\r\ngoto segv;\r\nif ((ufp + STACK_BIAS) & 0x7)\r\ngoto segv;\r\nerr = __get_user(tpc, &sf->regs.tpc);\r\nerr |= __get_user(tnpc, &sf->regs.tnpc);\r\nif (test_thread_flag(TIF_32BIT)) {\r\ntpc &= 0xffffffff;\r\ntnpc &= 0xffffffff;\r\n}\r\nerr |= ((tpc | tnpc) & 3);\r\nerr |= __get_user(regs->y, &sf->regs.y);\r\nerr |= __get_user(tstate, &sf->regs.tstate);\r\nerr |= copy_from_user(regs->u_regs, sf->regs.u_regs, sizeof(regs->u_regs));\r\nregs->tstate &= ~(TSTATE_ASI | TSTATE_ICC | TSTATE_XCC);\r\nregs->tstate |= (tstate & (TSTATE_ASI | TSTATE_ICC | TSTATE_XCC));\r\nerr |= __get_user(fpu_save, &sf->fpu_save);\r\nif (!err && fpu_save)\r\nerr |= restore_fpu_state(regs, fpu_save);\r\nerr |= __copy_from_user(&set, &sf->mask, sizeof(sigset_t));\r\nerr |= restore_altstack(&sf->stack);\r\nif (err)\r\ngoto segv;\r\nerr |= __get_user(rwin_save, &sf->rwin_save);\r\nif (!err && rwin_save) {\r\nif (restore_rwin_state(rwin_save))\r\ngoto segv;\r\n}\r\nregs->tpc = tpc;\r\nregs->tnpc = tnpc;\r\npt_regs_clear_syscall(regs);\r\nset_current_blocked(&set);\r\nreturn;\r\nsegv:\r\nforce_sig(SIGSEGV, current);\r\n}\r\nstatic inline void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)\r\n{\r\nunsigned long sp = regs->u_regs[UREG_FP] + STACK_BIAS;\r\nif (on_sig_stack(sp) && !likely(on_sig_stack(sp - framesize)))\r\nreturn (void __user *) -1L;\r\nsp = sigsp(sp, ksig) - framesize;\r\nsp &= ~15UL;\r\nreturn (void __user *) sp;\r\n}\r\nstatic inline int\r\nsetup_rt_frame(struct ksignal *ksig, struct pt_regs *regs)\r\n{\r\nstruct rt_signal_frame __user *sf;\r\nint wsaved, err, sf_size;\r\nvoid __user *tail;\r\nsynchronize_user_stack();\r\nsave_and_clear_fpu();\r\nwsaved = get_thread_wsaved();\r\nsf_size = sizeof(struct rt_signal_frame);\r\nif (current_thread_info()->fpsaved[0] & FPRS_FEF)\r\nsf_size += sizeof(__siginfo_fpu_t);\r\nif (wsaved)\r\nsf_size += sizeof(__siginfo_rwin_t);\r\nsf = (struct rt_signal_frame __user *)\r\nget_sigframe(ksig, regs, sf_size);\r\nif (invalid_frame_pointer (sf)) {\r\ndo_exit(SIGILL);\r\nreturn -EINVAL;\r\n}\r\ntail = (sf + 1);\r\nerr = copy_to_user(&sf->regs, regs, sizeof (*regs));\r\nif (current_thread_info()->fpsaved[0] & FPRS_FEF) {\r\n__siginfo_fpu_t __user *fpu_save = tail;\r\ntail += sizeof(__siginfo_fpu_t);\r\nerr |= save_fpu_state(regs, fpu_save);\r\nerr |= __put_user((u64)fpu_save, &sf->fpu_save);\r\n} else {\r\nerr |= __put_user(0, &sf->fpu_save);\r\n}\r\nif (wsaved) {\r\n__siginfo_rwin_t __user *rwin_save = tail;\r\ntail += sizeof(__siginfo_rwin_t);\r\nerr |= save_rwin_state(wsaved, rwin_save);\r\nerr |= __put_user((u64)rwin_save, &sf->rwin_save);\r\nset_thread_wsaved(0);\r\n} else {\r\nerr |= __put_user(0, &sf->rwin_save);\r\n}\r\nerr |= __save_altstack(&sf->stack, regs->u_regs[UREG_FP]);\r\nerr |= copy_to_user(&sf->mask, sigmask_to_save(), sizeof(sigset_t));\r\nif (!wsaved) {\r\nerr |= copy_in_user((u64 __user *)sf,\r\n(u64 __user *)(regs->u_regs[UREG_FP] +\r\nSTACK_BIAS),\r\nsizeof(struct reg_window));\r\n} else {\r\nstruct reg_window *rp;\r\nrp = &current_thread_info()->reg_window[wsaved - 1];\r\nerr |= copy_to_user(sf, rp, sizeof(struct reg_window));\r\n}\r\nif (ksig->ka.sa.sa_flags & SA_SIGINFO)\r\nerr |= copy_siginfo_to_user(&sf->info, &ksig->info);\r\nelse {\r\nerr |= __put_user(ksig->sig, &sf->info.si_signo);\r\nerr |= __put_user(SI_NOINFO, &sf->info.si_code);\r\n}\r\nif (err)\r\nreturn err;\r\nregs->u_regs[UREG_FP] = ((unsigned long) sf) - STACK_BIAS;\r\nregs->u_regs[UREG_I0] = ksig->sig;\r\nregs->u_regs[UREG_I1] = (unsigned long) &sf->info;\r\nregs->u_regs[UREG_I2] = (unsigned long) &sf->info;\r\nregs->tpc = (unsigned long) ksig->ka.sa.sa_handler;\r\nregs->tnpc = (regs->tpc + 4);\r\nif (test_thread_flag(TIF_32BIT)) {\r\nregs->tpc &= 0xffffffff;\r\nregs->tnpc &= 0xffffffff;\r\n}\r\nregs->u_regs[UREG_I7] = (unsigned long)ksig->ka.ka_restorer;\r\nreturn 0;\r\n}\r\nstatic inline void syscall_restart(unsigned long orig_i0, struct pt_regs *regs,\r\nstruct sigaction *sa)\r\n{\r\nswitch (regs->u_regs[UREG_I0]) {\r\ncase ERESTART_RESTARTBLOCK:\r\ncase ERESTARTNOHAND:\r\nno_system_call_restart:\r\nregs->u_regs[UREG_I0] = EINTR;\r\nregs->tstate |= (TSTATE_ICARRY|TSTATE_XCARRY);\r\nbreak;\r\ncase ERESTARTSYS:\r\nif (!(sa->sa_flags & SA_RESTART))\r\ngoto no_system_call_restart;\r\ncase ERESTARTNOINTR:\r\nregs->u_regs[UREG_I0] = orig_i0;\r\nregs->tpc -= 4;\r\nregs->tnpc -= 4;\r\n}\r\n}\r\nstatic void do_signal(struct pt_regs *regs, unsigned long orig_i0)\r\n{\r\nstruct ksignal ksig;\r\nint restart_syscall;\r\nbool has_handler;\r\nif (pt_regs_is_syscall(regs) &&\r\n(regs->tstate & (TSTATE_XCARRY | TSTATE_ICARRY)))\r\nregs->u_regs[UREG_G6] = orig_i0;\r\n#ifdef CONFIG_COMPAT\r\nif (test_thread_flag(TIF_32BIT)) {\r\ndo_signal32(regs);\r\nreturn;\r\n}\r\n#endif\r\nhas_handler = get_signal(&ksig);\r\nrestart_syscall = 0;\r\nif (pt_regs_is_syscall(regs) &&\r\n(regs->tstate & (TSTATE_XCARRY | TSTATE_ICARRY))) {\r\nrestart_syscall = 1;\r\norig_i0 = regs->u_regs[UREG_G6];\r\n}\r\nif (has_handler) {\r\nif (restart_syscall)\r\nsyscall_restart(orig_i0, regs, &ksig.ka.sa);\r\nsignal_setup_done(setup_rt_frame(&ksig, regs), &ksig, 0);\r\n} else {\r\nif (restart_syscall) {\r\nswitch (regs->u_regs[UREG_I0]) {\r\ncase ERESTARTNOHAND:\r\ncase ERESTARTSYS:\r\ncase ERESTARTNOINTR:\r\nregs->u_regs[UREG_I0] = orig_i0;\r\nregs->tpc -= 4;\r\nregs->tnpc -= 4;\r\npt_regs_clear_syscall(regs);\r\ncase ERESTART_RESTARTBLOCK:\r\nregs->u_regs[UREG_G1] = __NR_restart_syscall;\r\nregs->tpc -= 4;\r\nregs->tnpc -= 4;\r\npt_regs_clear_syscall(regs);\r\n}\r\n}\r\nrestore_saved_sigmask();\r\n}\r\n}\r\nvoid do_notify_resume(struct pt_regs *regs, unsigned long orig_i0, unsigned long thread_info_flags)\r\n{\r\nuser_exit();\r\nif (thread_info_flags & _TIF_UPROBE)\r\nuprobe_notify_resume(regs);\r\nif (thread_info_flags & _TIF_SIGPENDING)\r\ndo_signal(regs, orig_i0);\r\nif (thread_info_flags & _TIF_NOTIFY_RESUME) {\r\nclear_thread_flag(TIF_NOTIFY_RESUME);\r\ntracehook_notify_resume(regs);\r\n}\r\nuser_enter();\r\n}
