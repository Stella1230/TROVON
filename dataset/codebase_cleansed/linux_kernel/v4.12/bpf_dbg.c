static int matches(const char *cmd, const char *pattern)\r\n{\r\nint len = strlen(cmd);\r\nif (len > strlen(pattern))\r\nreturn -1;\r\nreturn memcmp(pattern, cmd, len);\r\n}\r\nstatic void hex_dump(const uint8_t *buf, size_t len)\r\n{\r\nint i;\r\nrl_printf("%3u: ", 0);\r\nfor (i = 0; i < len; i++) {\r\nif (i && !(i % 16))\r\nrl_printf("\n%3u: ", i);\r\nrl_printf("%02x ", buf[i]);\r\n}\r\nrl_printf("\n");\r\n}\r\nstatic bool bpf_prog_loaded(void)\r\n{\r\nif (bpf_prog_len == 0)\r\nrl_printf("no bpf program loaded!\n");\r\nreturn bpf_prog_len > 0;\r\n}\r\nstatic void bpf_disasm(const struct sock_filter f, unsigned int i)\r\n{\r\nconst char *op, *fmt;\r\nint val = f.k;\r\nchar buf[256];\r\nswitch (f.code) {\r\ncase BPF_RET | BPF_K:\r\nop = op_table[BPF_RET];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_RET | BPF_A:\r\nop = op_table[BPF_RET];\r\nfmt = "a";\r\nbreak;\r\ncase BPF_RET | BPF_X:\r\nop = op_table[BPF_RET];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_MISC_TAX:\r\nop = op_table[BPF_MISC_TAX];\r\nfmt = "";\r\nbreak;\r\ncase BPF_MISC_TXA:\r\nop = op_table[BPF_MISC_TXA];\r\nfmt = "";\r\nbreak;\r\ncase BPF_ST:\r\nop = op_table[BPF_ST];\r\nfmt = "M[%d]";\r\nbreak;\r\ncase BPF_STX:\r\nop = op_table[BPF_STX];\r\nfmt = "M[%d]";\r\nbreak;\r\ncase BPF_LD_W | BPF_ABS:\r\nop = op_table[BPF_LD_W];\r\nfmt = "[%d]";\r\nbreak;\r\ncase BPF_LD_H | BPF_ABS:\r\nop = op_table[BPF_LD_H];\r\nfmt = "[%d]";\r\nbreak;\r\ncase BPF_LD_B | BPF_ABS:\r\nop = op_table[BPF_LD_B];\r\nfmt = "[%d]";\r\nbreak;\r\ncase BPF_LD_W | BPF_LEN:\r\nop = op_table[BPF_LD_W];\r\nfmt = "#len";\r\nbreak;\r\ncase BPF_LD_W | BPF_IND:\r\nop = op_table[BPF_LD_W];\r\nfmt = "[x+%d]";\r\nbreak;\r\ncase BPF_LD_H | BPF_IND:\r\nop = op_table[BPF_LD_H];\r\nfmt = "[x+%d]";\r\nbreak;\r\ncase BPF_LD_B | BPF_IND:\r\nop = op_table[BPF_LD_B];\r\nfmt = "[x+%d]";\r\nbreak;\r\ncase BPF_LD | BPF_IMM:\r\nop = op_table[BPF_LD_W];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_LDX | BPF_IMM:\r\nop = op_table[BPF_LDX];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_LDX_B | BPF_MSH:\r\nop = op_table[BPF_LDX_B];\r\nfmt = "4*([%d]&0xf)";\r\nbreak;\r\ncase BPF_LD | BPF_MEM:\r\nop = op_table[BPF_LD_W];\r\nfmt = "M[%d]";\r\nbreak;\r\ncase BPF_LDX | BPF_MEM:\r\nop = op_table[BPF_LDX];\r\nfmt = "M[%d]";\r\nbreak;\r\ncase BPF_JMP_JA:\r\nop = op_table[BPF_JMP_JA];\r\nfmt = "%d";\r\nval = i + 1 + f.k;\r\nbreak;\r\ncase BPF_JMP_JGT | BPF_X:\r\nop = op_table[BPF_JMP_JGT];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_JMP_JGT | BPF_K:\r\nop = op_table[BPF_JMP_JGT];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_JMP_JGE | BPF_X:\r\nop = op_table[BPF_JMP_JGE];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_JMP_JGE | BPF_K:\r\nop = op_table[BPF_JMP_JGE];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_JMP_JEQ | BPF_X:\r\nop = op_table[BPF_JMP_JEQ];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_JMP_JEQ | BPF_K:\r\nop = op_table[BPF_JMP_JEQ];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_JMP_JSET | BPF_X:\r\nop = op_table[BPF_JMP_JSET];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_JMP_JSET | BPF_K:\r\nop = op_table[BPF_JMP_JSET];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_ALU_NEG:\r\nop = op_table[BPF_ALU_NEG];\r\nfmt = "";\r\nbreak;\r\ncase BPF_ALU_LSH | BPF_X:\r\nop = op_table[BPF_ALU_LSH];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_LSH | BPF_K:\r\nop = op_table[BPF_ALU_LSH];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_RSH | BPF_X:\r\nop = op_table[BPF_ALU_RSH];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_RSH | BPF_K:\r\nop = op_table[BPF_ALU_RSH];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_ADD | BPF_X:\r\nop = op_table[BPF_ALU_ADD];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_ADD | BPF_K:\r\nop = op_table[BPF_ALU_ADD];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_SUB | BPF_X:\r\nop = op_table[BPF_ALU_SUB];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_SUB | BPF_K:\r\nop = op_table[BPF_ALU_SUB];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_MUL | BPF_X:\r\nop = op_table[BPF_ALU_MUL];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_MUL | BPF_K:\r\nop = op_table[BPF_ALU_MUL];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_DIV | BPF_X:\r\nop = op_table[BPF_ALU_DIV];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_DIV | BPF_K:\r\nop = op_table[BPF_ALU_DIV];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_MOD | BPF_X:\r\nop = op_table[BPF_ALU_MOD];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_MOD | BPF_K:\r\nop = op_table[BPF_ALU_MOD];\r\nfmt = "#%d";\r\nbreak;\r\ncase BPF_ALU_AND | BPF_X:\r\nop = op_table[BPF_ALU_AND];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_AND | BPF_K:\r\nop = op_table[BPF_ALU_AND];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_ALU_OR | BPF_X:\r\nop = op_table[BPF_ALU_OR];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_OR | BPF_K:\r\nop = op_table[BPF_ALU_OR];\r\nfmt = "#%#x";\r\nbreak;\r\ncase BPF_ALU_XOR | BPF_X:\r\nop = op_table[BPF_ALU_XOR];\r\nfmt = "x";\r\nbreak;\r\ncase BPF_ALU_XOR | BPF_K:\r\nop = op_table[BPF_ALU_XOR];\r\nfmt = "#%#x";\r\nbreak;\r\ndefault:\r\nop = "nosup";\r\nfmt = "%#x";\r\nval = f.code;\r\nbreak;\r\n}\r\nmemset(buf, 0, sizeof(buf));\r\nsnprintf(buf, sizeof(buf), fmt, val);\r\nbuf[sizeof(buf) - 1] = 0;\r\nif ((BPF_CLASS(f.code) == BPF_JMP && BPF_OP(f.code) != BPF_JA))\r\nrl_printf("l%d:\t%s %s, l%d, l%d\n", i, op, buf,\r\ni + 1 + f.jt, i + 1 + f.jf);\r\nelse\r\nrl_printf("l%d:\t%s %s\n", i, op, buf);\r\n}\r\nstatic void bpf_dump_curr(struct bpf_regs *r, struct sock_filter *f)\r\n{\r\nint i, m = 0;\r\nrl_printf("pc: [%u]\n", r->Pc);\r\nrl_printf("code: [%u] jt[%u] jf[%u] k[%u]\n",\r\nf->code, f->jt, f->jf, f->k);\r\nrl_printf("curr: ");\r\nbpf_disasm(*f, r->Pc);\r\nif (f->jt || f->jf) {\r\nrl_printf("jt: ");\r\nbpf_disasm(*(f + f->jt + 1), r->Pc + f->jt + 1);\r\nrl_printf("jf: ");\r\nbpf_disasm(*(f + f->jf + 1), r->Pc + f->jf + 1);\r\n}\r\nrl_printf("A: [%#08x][%u]\n", r->A, r->A);\r\nrl_printf("X: [%#08x][%u]\n", r->X, r->X);\r\nif (r->Rs)\r\nrl_printf("ret: [%#08x][%u]!\n", r->R, r->R);\r\nfor (i = 0; i < BPF_MEMWORDS; i++) {\r\nif (r->M[i]) {\r\nm++;\r\nrl_printf("M[%d]: [%#08x][%u]\n", i, r->M[i], r->M[i]);\r\n}\r\n}\r\nif (m == 0)\r\nrl_printf("M[0,%d]: [%#08x][%u]\n", BPF_MEMWORDS - 1, 0, 0);\r\n}\r\nstatic void bpf_dump_pkt(uint8_t *pkt, uint32_t pkt_caplen, uint32_t pkt_len)\r\n{\r\nif (pkt_caplen != pkt_len)\r\nrl_printf("cap: %u, len: %u\n", pkt_caplen, pkt_len);\r\nelse\r\nrl_printf("len: %u\n", pkt_len);\r\nhex_dump(pkt, pkt_caplen);\r\n}\r\nstatic void bpf_disasm_all(const struct sock_filter *f, unsigned int len)\r\n{\r\nunsigned int i;\r\nfor (i = 0; i < len; i++)\r\nbpf_disasm(f[i], i);\r\n}\r\nstatic void bpf_dump_all(const struct sock_filter *f, unsigned int len)\r\n{\r\nunsigned int i;\r\nrl_printf("/* { op, jt, jf, k }, */\n");\r\nfor (i = 0; i < len; i++)\r\nrl_printf("{ %#04x, %2u, %2u, %#010x },\n",\r\nf[i].code, f[i].jt, f[i].jf, f[i].k);\r\n}\r\nstatic bool bpf_runnable(struct sock_filter *f, unsigned int len)\r\n{\r\nint sock, ret, i;\r\nstruct sock_fprog bpf = {\r\n.filter = f,\r\n.len = len,\r\n};\r\nsock = socket(AF_INET, SOCK_DGRAM, 0);\r\nif (sock < 0) {\r\nrl_printf("cannot open socket!\n");\r\nreturn false;\r\n}\r\nret = setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &bpf, sizeof(bpf));\r\nclose(sock);\r\nif (ret < 0) {\r\nrl_printf("program not allowed to run by kernel!\n");\r\nreturn false;\r\n}\r\nfor (i = 0; i < len; i++) {\r\nif (BPF_CLASS(f[i].code) == BPF_LD &&\r\nf[i].k > SKF_AD_OFF) {\r\nrl_printf("extensions currently not supported!\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic void bpf_reset_breakpoints(void)\r\n{\r\nint i;\r\nfor (i = 0; i < array_size(bpf_breakpoints); i++)\r\nbpf_breakpoints[i] = -1;\r\n}\r\nstatic void bpf_set_breakpoints(unsigned int where)\r\n{\r\nint i;\r\nbool set = false;\r\nfor (i = 0; i < array_size(bpf_breakpoints); i++) {\r\nif (bpf_breakpoints[i] == (int) where) {\r\nrl_printf("breakpoint already set!\n");\r\nset = true;\r\nbreak;\r\n}\r\nif (bpf_breakpoints[i] == -1 && set == false) {\r\nbpf_breakpoints[i] = where;\r\nset = true;\r\n}\r\n}\r\nif (!set)\r\nrl_printf("too many breakpoints set, reset first!\n");\r\n}\r\nstatic void bpf_dump_breakpoints(void)\r\n{\r\nint i;\r\nrl_printf("breakpoints: ");\r\nfor (i = 0; i < array_size(bpf_breakpoints); i++) {\r\nif (bpf_breakpoints[i] < 0)\r\ncontinue;\r\nrl_printf("%d ", bpf_breakpoints[i]);\r\n}\r\nrl_printf("\n");\r\n}\r\nstatic void bpf_reset(void)\r\n{\r\nbpf_regs_len = 0;\r\nmemset(bpf_regs, 0, sizeof(bpf_regs));\r\nmemset(&bpf_curr, 0, sizeof(bpf_curr));\r\n}\r\nstatic void bpf_safe_regs(void)\r\n{\r\nmemcpy(&bpf_regs[bpf_regs_len++], &bpf_curr, sizeof(bpf_curr));\r\n}\r\nstatic bool bpf_restore_regs(int off)\r\n{\r\nunsigned int index = bpf_regs_len - 1 + off;\r\nif (index == 0) {\r\nbpf_reset();\r\nreturn true;\r\n} else if (index < bpf_regs_len) {\r\nmemcpy(&bpf_curr, &bpf_regs[index], sizeof(bpf_curr));\r\nbpf_regs_len = index;\r\nreturn true;\r\n} else {\r\nrl_printf("reached bottom of register history stack!\n");\r\nreturn false;\r\n}\r\n}\r\nstatic uint32_t extract_u32(uint8_t *pkt, uint32_t off)\r\n{\r\nuint32_t r;\r\nmemcpy(&r, &pkt[off], sizeof(r));\r\nreturn ntohl(r);\r\n}\r\nstatic uint16_t extract_u16(uint8_t *pkt, uint32_t off)\r\n{\r\nuint16_t r;\r\nmemcpy(&r, &pkt[off], sizeof(r));\r\nreturn ntohs(r);\r\n}\r\nstatic uint8_t extract_u8(uint8_t *pkt, uint32_t off)\r\n{\r\nreturn pkt[off];\r\n}\r\nstatic void set_return(struct bpf_regs *r)\r\n{\r\nr->R = 0;\r\nr->Rs = true;\r\n}\r\nstatic void bpf_single_step(struct bpf_regs *r, struct sock_filter *f,\r\nuint8_t *pkt, uint32_t pkt_caplen,\r\nuint32_t pkt_len)\r\n{\r\nuint32_t K = f->k;\r\nint d;\r\nswitch (f->code) {\r\ncase BPF_RET | BPF_K:\r\nr->R = K;\r\nr->Rs = true;\r\nbreak;\r\ncase BPF_RET | BPF_A:\r\nr->R = r->A;\r\nr->Rs = true;\r\nbreak;\r\ncase BPF_RET | BPF_X:\r\nr->R = r->X;\r\nr->Rs = true;\r\nbreak;\r\ncase BPF_MISC_TAX:\r\nr->X = r->A;\r\nbreak;\r\ncase BPF_MISC_TXA:\r\nr->A = r->X;\r\nbreak;\r\ncase BPF_ST:\r\nr->M[K] = r->A;\r\nbreak;\r\ncase BPF_STX:\r\nr->M[K] = r->X;\r\nbreak;\r\ncase BPF_LD_W | BPF_ABS:\r\nd = pkt_caplen - K;\r\nif (d >= sizeof(uint32_t))\r\nr->A = extract_u32(pkt, K);\r\nelse\r\nset_return(r);\r\nbreak;\r\ncase BPF_LD_H | BPF_ABS:\r\nd = pkt_caplen - K;\r\nif (d >= sizeof(uint16_t))\r\nr->A = extract_u16(pkt, K);\r\nelse\r\nset_return(r);\r\nbreak;\r\ncase BPF_LD_B | BPF_ABS:\r\nd = pkt_caplen - K;\r\nif (d >= sizeof(uint8_t))\r\nr->A = extract_u8(pkt, K);\r\nelse\r\nset_return(r);\r\nbreak;\r\ncase BPF_LD_W | BPF_IND:\r\nd = pkt_caplen - (r->X + K);\r\nif (d >= sizeof(uint32_t))\r\nr->A = extract_u32(pkt, r->X + K);\r\nbreak;\r\ncase BPF_LD_H | BPF_IND:\r\nd = pkt_caplen - (r->X + K);\r\nif (d >= sizeof(uint16_t))\r\nr->A = extract_u16(pkt, r->X + K);\r\nelse\r\nset_return(r);\r\nbreak;\r\ncase BPF_LD_B | BPF_IND:\r\nd = pkt_caplen - (r->X + K);\r\nif (d >= sizeof(uint8_t))\r\nr->A = extract_u8(pkt, r->X + K);\r\nelse\r\nset_return(r);\r\nbreak;\r\ncase BPF_LDX_B | BPF_MSH:\r\nd = pkt_caplen - K;\r\nif (d >= sizeof(uint8_t)) {\r\nr->X = extract_u8(pkt, K);\r\nr->X = (r->X & 0xf) << 2;\r\n} else\r\nset_return(r);\r\nbreak;\r\ncase BPF_LD_W | BPF_LEN:\r\nr->A = pkt_len;\r\nbreak;\r\ncase BPF_LDX_W | BPF_LEN:\r\nr->A = pkt_len;\r\nbreak;\r\ncase BPF_LD | BPF_IMM:\r\nr->A = K;\r\nbreak;\r\ncase BPF_LDX | BPF_IMM:\r\nr->X = K;\r\nbreak;\r\ncase BPF_LD | BPF_MEM:\r\nr->A = r->M[K];\r\nbreak;\r\ncase BPF_LDX | BPF_MEM:\r\nr->X = r->M[K];\r\nbreak;\r\ncase BPF_JMP_JA:\r\nr->Pc += K;\r\nbreak;\r\ncase BPF_JMP_JGT | BPF_X:\r\nr->Pc += r->A > r->X ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JGT | BPF_K:\r\nr->Pc += r->A > K ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JGE | BPF_X:\r\nr->Pc += r->A >= r->X ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JGE | BPF_K:\r\nr->Pc += r->A >= K ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JEQ | BPF_X:\r\nr->Pc += r->A == r->X ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JEQ | BPF_K:\r\nr->Pc += r->A == K ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JSET | BPF_X:\r\nr->Pc += r->A & r->X ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_JMP_JSET | BPF_K:\r\nr->Pc += r->A & K ? f->jt : f->jf;\r\nbreak;\r\ncase BPF_ALU_NEG:\r\nr->A = -r->A;\r\nbreak;\r\ncase BPF_ALU_LSH | BPF_X:\r\nr->A <<= r->X;\r\nbreak;\r\ncase BPF_ALU_LSH | BPF_K:\r\nr->A <<= K;\r\nbreak;\r\ncase BPF_ALU_RSH | BPF_X:\r\nr->A >>= r->X;\r\nbreak;\r\ncase BPF_ALU_RSH | BPF_K:\r\nr->A >>= K;\r\nbreak;\r\ncase BPF_ALU_ADD | BPF_X:\r\nr->A += r->X;\r\nbreak;\r\ncase BPF_ALU_ADD | BPF_K:\r\nr->A += K;\r\nbreak;\r\ncase BPF_ALU_SUB | BPF_X:\r\nr->A -= r->X;\r\nbreak;\r\ncase BPF_ALU_SUB | BPF_K:\r\nr->A -= K;\r\nbreak;\r\ncase BPF_ALU_MUL | BPF_X:\r\nr->A *= r->X;\r\nbreak;\r\ncase BPF_ALU_MUL | BPF_K:\r\nr->A *= K;\r\nbreak;\r\ncase BPF_ALU_DIV | BPF_X:\r\ncase BPF_ALU_MOD | BPF_X:\r\nif (r->X == 0) {\r\nset_return(r);\r\nbreak;\r\n}\r\ngoto do_div;\r\ncase BPF_ALU_DIV | BPF_K:\r\ncase BPF_ALU_MOD | BPF_K:\r\nif (K == 0) {\r\nset_return(r);\r\nbreak;\r\n}\r\ndo_div:\r\nswitch (f->code) {\r\ncase BPF_ALU_DIV | BPF_X:\r\nr->A /= r->X;\r\nbreak;\r\ncase BPF_ALU_DIV | BPF_K:\r\nr->A /= K;\r\nbreak;\r\ncase BPF_ALU_MOD | BPF_X:\r\nr->A %= r->X;\r\nbreak;\r\ncase BPF_ALU_MOD | BPF_K:\r\nr->A %= K;\r\nbreak;\r\n}\r\nbreak;\r\ncase BPF_ALU_AND | BPF_X:\r\nr->A &= r->X;\r\nbreak;\r\ncase BPF_ALU_AND | BPF_K:\r\nr->A &= K;\r\nbreak;\r\ncase BPF_ALU_OR | BPF_X:\r\nr->A |= r->X;\r\nbreak;\r\ncase BPF_ALU_OR | BPF_K:\r\nr->A |= K;\r\nbreak;\r\ncase BPF_ALU_XOR | BPF_X:\r\nr->A ^= r->X;\r\nbreak;\r\ncase BPF_ALU_XOR | BPF_K:\r\nr->A ^= K;\r\nbreak;\r\n}\r\n}\r\nstatic bool bpf_pc_has_breakpoint(uint16_t pc)\r\n{\r\nint i;\r\nfor (i = 0; i < array_size(bpf_breakpoints); i++) {\r\nif (bpf_breakpoints[i] < 0)\r\ncontinue;\r\nif (bpf_breakpoints[i] == pc)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic bool bpf_handle_breakpoint(struct bpf_regs *r, struct sock_filter *f,\r\nuint8_t *pkt, uint32_t pkt_caplen,\r\nuint32_t pkt_len)\r\n{\r\nrl_printf("-- register dump --\n");\r\nbpf_dump_curr(r, &f[r->Pc]);\r\nrl_printf("-- packet dump --\n");\r\nbpf_dump_pkt(pkt, pkt_caplen, pkt_len);\r\nrl_printf("(breakpoint)\n");\r\nreturn true;\r\n}\r\nstatic int bpf_run_all(struct sock_filter *f, uint16_t bpf_len, uint8_t *pkt,\r\nuint32_t pkt_caplen, uint32_t pkt_len)\r\n{\r\nbool stop = false;\r\nwhile (bpf_curr.Rs == false && stop == false) {\r\nbpf_safe_regs();\r\nif (bpf_pc_has_breakpoint(bpf_curr.Pc))\r\nstop = bpf_handle_breakpoint(&bpf_curr, f, pkt,\r\npkt_caplen, pkt_len);\r\nbpf_single_step(&bpf_curr, &f[bpf_curr.Pc], pkt, pkt_caplen,\r\npkt_len);\r\nbpf_curr.Pc++;\r\n}\r\nreturn stop ? -1 : bpf_curr.R;\r\n}\r\nstatic int bpf_run_stepping(struct sock_filter *f, uint16_t bpf_len,\r\nuint8_t *pkt, uint32_t pkt_caplen,\r\nuint32_t pkt_len, int next)\r\n{\r\nbool stop = false;\r\nint i = 1;\r\nwhile (bpf_curr.Rs == false && stop == false) {\r\nbpf_safe_regs();\r\nif (i++ == next)\r\nstop = bpf_handle_breakpoint(&bpf_curr, f, pkt,\r\npkt_caplen, pkt_len);\r\nbpf_single_step(&bpf_curr, &f[bpf_curr.Pc], pkt, pkt_caplen,\r\npkt_len);\r\nbpf_curr.Pc++;\r\n}\r\nreturn stop ? -1 : bpf_curr.R;\r\n}\r\nstatic bool pcap_loaded(void)\r\n{\r\nif (pcap_fd < 0)\r\nrl_printf("no pcap file loaded!\n");\r\nreturn pcap_fd >= 0;\r\n}\r\nstatic struct pcap_pkthdr *pcap_curr_pkt(void)\r\n{\r\nreturn (void *) pcap_ptr_va_curr;\r\n}\r\nstatic bool pcap_next_pkt(void)\r\n{\r\nstruct pcap_pkthdr *hdr = pcap_curr_pkt();\r\nif (pcap_ptr_va_curr + sizeof(*hdr) -\r\npcap_ptr_va_start >= pcap_map_size)\r\nreturn false;\r\nif (hdr->caplen == 0 || hdr->len == 0 || hdr->caplen > hdr->len)\r\nreturn false;\r\nif (pcap_ptr_va_curr + sizeof(*hdr) + hdr->caplen -\r\npcap_ptr_va_start >= pcap_map_size)\r\nreturn false;\r\npcap_ptr_va_curr += (sizeof(*hdr) + hdr->caplen);\r\nreturn true;\r\n}\r\nstatic void pcap_reset_pkt(void)\r\n{\r\npcap_ptr_va_curr = pcap_ptr_va_start + sizeof(struct pcap_filehdr);\r\n}\r\nstatic int try_load_pcap(const char *file)\r\n{\r\nstruct pcap_filehdr *hdr;\r\nstruct stat sb;\r\nint ret;\r\npcap_fd = open(file, O_RDONLY);\r\nif (pcap_fd < 0) {\r\nrl_printf("cannot open pcap [%s]!\n", strerror(errno));\r\nreturn CMD_ERR;\r\n}\r\nret = fstat(pcap_fd, &sb);\r\nif (ret < 0) {\r\nrl_printf("cannot fstat pcap file!\n");\r\nreturn CMD_ERR;\r\n}\r\nif (!S_ISREG(sb.st_mode)) {\r\nrl_printf("not a regular pcap file, duh!\n");\r\nreturn CMD_ERR;\r\n}\r\npcap_map_size = sb.st_size;\r\nif (pcap_map_size <= sizeof(struct pcap_filehdr)) {\r\nrl_printf("pcap file too small!\n");\r\nreturn CMD_ERR;\r\n}\r\npcap_ptr_va_start = mmap(NULL, pcap_map_size, PROT_READ,\r\nMAP_SHARED | MAP_LOCKED, pcap_fd, 0);\r\nif (pcap_ptr_va_start == MAP_FAILED) {\r\nrl_printf("mmap of file failed!");\r\nreturn CMD_ERR;\r\n}\r\nhdr = (void *) pcap_ptr_va_start;\r\nif (hdr->magic != TCPDUMP_MAGIC) {\r\nrl_printf("wrong pcap magic!\n");\r\nreturn CMD_ERR;\r\n}\r\npcap_reset_pkt();\r\nreturn CMD_OK;\r\n}\r\nstatic void try_close_pcap(void)\r\n{\r\nif (pcap_fd >= 0) {\r\nmunmap(pcap_ptr_va_start, pcap_map_size);\r\nclose(pcap_fd);\r\npcap_ptr_va_start = pcap_ptr_va_curr = NULL;\r\npcap_map_size = 0;\r\npcap_packet = 0;\r\npcap_fd = -1;\r\n}\r\n}\r\nstatic int cmd_load_bpf(char *bpf_string)\r\n{\r\nchar sp, *token, separator = ',';\r\nunsigned short bpf_len, i = 0;\r\nstruct sock_filter tmp;\r\nbpf_prog_len = 0;\r\nmemset(bpf_image, 0, sizeof(bpf_image));\r\nif (sscanf(bpf_string, "%hu%c", &bpf_len, &sp) != 2 ||\r\nsp != separator || bpf_len > BPF_MAXINSNS || bpf_len == 0) {\r\nrl_printf("syntax error in head length encoding!\n");\r\nreturn CMD_ERR;\r\n}\r\ntoken = bpf_string;\r\nwhile ((token = strchr(token, separator)) && (++token)[0]) {\r\nif (i >= bpf_len) {\r\nrl_printf("program exceeds encoded length!\n");\r\nreturn CMD_ERR;\r\n}\r\nif (sscanf(token, "%hu %hhu %hhu %u,",\r\n&tmp.code, &tmp.jt, &tmp.jf, &tmp.k) != 4) {\r\nrl_printf("syntax error at instruction %d!\n", i);\r\nreturn CMD_ERR;\r\n}\r\nbpf_image[i].code = tmp.code;\r\nbpf_image[i].jt = tmp.jt;\r\nbpf_image[i].jf = tmp.jf;\r\nbpf_image[i].k = tmp.k;\r\ni++;\r\n}\r\nif (i != bpf_len) {\r\nrl_printf("syntax error exceeding encoded length!\n");\r\nreturn CMD_ERR;\r\n} else\r\nbpf_prog_len = bpf_len;\r\nif (!bpf_runnable(bpf_image, bpf_prog_len))\r\nbpf_prog_len = 0;\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_load_pcap(char *file)\r\n{\r\nchar *file_trim, *tmp;\r\nfile_trim = strtok_r(file, " ", &tmp);\r\nif (file_trim == NULL)\r\nreturn CMD_ERR;\r\ntry_close_pcap();\r\nreturn try_load_pcap(file_trim);\r\n}\r\nstatic int cmd_load(char *arg)\r\n{\r\nchar *subcmd, *cont, *tmp = strdup(arg);\r\nint ret = CMD_OK;\r\nsubcmd = strtok_r(tmp, " ", &cont);\r\nif (subcmd == NULL)\r\ngoto out;\r\nif (matches(subcmd, "bpf") == 0) {\r\nbpf_reset();\r\nbpf_reset_breakpoints();\r\nret = cmd_load_bpf(cont);\r\n} else if (matches(subcmd, "pcap") == 0) {\r\nret = cmd_load_pcap(cont);\r\n} else {\r\nout:\r\nrl_printf("bpf <code>: load bpf code\n");\r\nrl_printf("pcap <file>: load pcap file\n");\r\nret = CMD_ERR;\r\n}\r\nfree(tmp);\r\nreturn ret;\r\n}\r\nstatic int cmd_step(char *num)\r\n{\r\nstruct pcap_pkthdr *hdr;\r\nint steps, ret;\r\nif (!bpf_prog_loaded() || !pcap_loaded())\r\nreturn CMD_ERR;\r\nsteps = strtol(num, NULL, 10);\r\nif (steps == 0 || strlen(num) == 0)\r\nsteps = 1;\r\nif (steps < 0) {\r\nif (!bpf_restore_regs(steps))\r\nreturn CMD_ERR;\r\nsteps = 1;\r\n}\r\nhdr = pcap_curr_pkt();\r\nret = bpf_run_stepping(bpf_image, bpf_prog_len,\r\n(uint8_t *) hdr + sizeof(*hdr),\r\nhdr->caplen, hdr->len, steps);\r\nif (ret >= 0 || bpf_curr.Rs) {\r\nbpf_reset();\r\nif (!pcap_next_pkt()) {\r\nrl_printf("(going back to first packet)\n");\r\npcap_reset_pkt();\r\n} else {\r\nrl_printf("(next packet)\n");\r\n}\r\n}\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_select(char *num)\r\n{\r\nunsigned int which, i;\r\nbool have_next = true;\r\nif (!pcap_loaded() || strlen(num) == 0)\r\nreturn CMD_ERR;\r\nwhich = strtoul(num, NULL, 10);\r\nif (which == 0) {\r\nrl_printf("packet count starts with 1, clamping!\n");\r\nwhich = 1;\r\n}\r\npcap_reset_pkt();\r\nbpf_reset();\r\nfor (i = 0; i < which && (have_next = pcap_next_pkt()); i++)\r\n;\r\nif (!have_next || pcap_curr_pkt() == NULL) {\r\nrl_printf("no packet #%u available!\n", which);\r\npcap_reset_pkt();\r\nreturn CMD_ERR;\r\n}\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_breakpoint(char *subcmd)\r\n{\r\nif (!bpf_prog_loaded())\r\nreturn CMD_ERR;\r\nif (strlen(subcmd) == 0)\r\nbpf_dump_breakpoints();\r\nelse if (matches(subcmd, "reset") == 0)\r\nbpf_reset_breakpoints();\r\nelse {\r\nunsigned int where = strtoul(subcmd, NULL, 10);\r\nif (where < bpf_prog_len) {\r\nbpf_set_breakpoints(where);\r\nrl_printf("breakpoint at: ");\r\nbpf_disasm(bpf_image[where], where);\r\n}\r\n}\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_run(char *num)\r\n{\r\nstatic uint32_t pass, fail;\r\nbool has_limit = true;\r\nint pkts = 0, i = 0;\r\nif (!bpf_prog_loaded() || !pcap_loaded())\r\nreturn CMD_ERR;\r\npkts = strtol(num, NULL, 10);\r\nif (pkts == 0 || strlen(num) == 0)\r\nhas_limit = false;\r\ndo {\r\nstruct pcap_pkthdr *hdr = pcap_curr_pkt();\r\nint ret = bpf_run_all(bpf_image, bpf_prog_len,\r\n(uint8_t *) hdr + sizeof(*hdr),\r\nhdr->caplen, hdr->len);\r\nif (ret > 0)\r\npass++;\r\nelse if (ret == 0)\r\nfail++;\r\nelse\r\nreturn CMD_OK;\r\nbpf_reset();\r\n} while (pcap_next_pkt() && (!has_limit || (has_limit && ++i < pkts)));\r\nrl_printf("bpf passes:%u fails:%u\n", pass, fail);\r\npcap_reset_pkt();\r\nbpf_reset();\r\npass = fail = 0;\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_disassemble(char *line_string)\r\n{\r\nbool single_line = false;\r\nunsigned long line;\r\nif (!bpf_prog_loaded())\r\nreturn CMD_ERR;\r\nif (strlen(line_string) > 0 &&\r\n(line = strtoul(line_string, NULL, 10)) < bpf_prog_len)\r\nsingle_line = true;\r\nif (single_line)\r\nbpf_disasm(bpf_image[line], line);\r\nelse\r\nbpf_disasm_all(bpf_image, bpf_prog_len);\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_dump(char *dontcare)\r\n{\r\nif (!bpf_prog_loaded())\r\nreturn CMD_ERR;\r\nbpf_dump_all(bpf_image, bpf_prog_len);\r\nreturn CMD_OK;\r\n}\r\nstatic int cmd_quit(char *dontcare)\r\n{\r\nreturn CMD_EX;\r\n}\r\nstatic int execf(char *arg)\r\n{\r\nchar *cmd, *cont, *tmp = strdup(arg);\r\nint i, ret = 0, len;\r\ncmd = strtok_r(tmp, " ", &cont);\r\nif (cmd == NULL)\r\ngoto out;\r\nlen = strlen(cmd);\r\nfor (i = 0; i < array_size(cmds); i++) {\r\nif (len != strlen(cmds[i].name))\r\ncontinue;\r\nif (strncmp(cmds[i].name, cmd, len) == 0) {\r\nret = cmds[i].func(cont);\r\nbreak;\r\n}\r\n}\r\nout:\r\nfree(tmp);\r\nreturn ret;\r\n}\r\nstatic char *shell_comp_gen(const char *buf, int state)\r\n{\r\nstatic int list_index, len;\r\nif (!state) {\r\nlist_index = 0;\r\nlen = strlen(buf);\r\n}\r\nfor (; list_index < array_size(cmds); ) {\r\nconst char *name = cmds[list_index].name;\r\nlist_index++;\r\nif (strncmp(name, buf, len) == 0)\r\nreturn strdup(name);\r\n}\r\nreturn NULL;\r\n}\r\nstatic char **shell_completion(const char *buf, int start, int end)\r\n{\r\nchar **matches = NULL;\r\nif (start == 0)\r\nmatches = rl_completion_matches(buf, shell_comp_gen);\r\nreturn matches;\r\n}\r\nstatic void intr_shell(int sig)\r\n{\r\nif (rl_end)\r\nrl_kill_line(-1, 0);\r\nrl_crlf();\r\nrl_refresh_line(0, 0);\r\nrl_free_line_state();\r\n}\r\nstatic void init_shell(FILE *fin, FILE *fout)\r\n{\r\nchar file[128];\r\nsnprintf(file, sizeof(file), "%s/.bpf_dbg_history", getenv("HOME"));\r\nread_history(file);\r\nrl_instream = fin;\r\nrl_outstream = fout;\r\nrl_readline_name = "bpf_dbg";\r\nrl_terminal_name = getenv("TERM");\r\nrl_catch_signals = 0;\r\nrl_catch_sigwinch = 1;\r\nrl_attempted_completion_function = shell_completion;\r\nrl_bind_key('\t', rl_complete);\r\nrl_bind_key_in_map('\t', rl_complete, emacs_meta_keymap);\r\nrl_bind_key_in_map('\033', rl_complete, emacs_meta_keymap);\r\nsnprintf(file, sizeof(file), "%s/.bpf_dbg_init", getenv("HOME"));\r\nrl_read_init_file(file);\r\nrl_prep_terminal(0);\r\nrl_set_signals();\r\nsignal(SIGINT, intr_shell);\r\n}\r\nstatic void exit_shell(FILE *fin, FILE *fout)\r\n{\r\nchar file[128];\r\nsnprintf(file, sizeof(file), "%s/.bpf_dbg_history", getenv("HOME"));\r\nwrite_history(file);\r\nclear_history();\r\nrl_deprep_terminal();\r\ntry_close_pcap();\r\nif (fin != stdin)\r\nfclose(fin);\r\nif (fout != stdout)\r\nfclose(fout);\r\n}\r\nstatic int run_shell_loop(FILE *fin, FILE *fout)\r\n{\r\nchar *buf;\r\ninit_shell(fin, fout);\r\nwhile ((buf = readline("> ")) != NULL) {\r\nint ret = execf(buf);\r\nif (ret == CMD_EX)\r\nbreak;\r\nif (ret == CMD_OK && strlen(buf) > 0)\r\nadd_history(buf);\r\nfree(buf);\r\n}\r\nexit_shell(fin, fout);\r\nreturn 0;\r\n}\r\nint main(int argc, char **argv)\r\n{\r\nFILE *fin = NULL, *fout = NULL;\r\nif (argc >= 2)\r\nfin = fopen(argv[1], "r");\r\nif (argc >= 3)\r\nfout = fopen(argv[2], "w");\r\nreturn run_shell_loop(fin ? : stdin, fout ? : stdout);\r\n}
