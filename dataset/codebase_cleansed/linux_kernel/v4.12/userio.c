static int userio_device_write(struct serio *id, unsigned char val)\r\n{\r\nstruct userio_device *userio = id->port_data;\r\nunsigned long flags;\r\nspin_lock_irqsave(&userio->buf_lock, flags);\r\nuserio->buf[userio->head] = val;\r\nuserio->head = (userio->head + 1) % USERIO_BUFSIZE;\r\nif (userio->head == userio->tail)\r\ndev_warn(userio_misc.this_device,\r\n"Buffer overflowed, userio client isn't keeping up");\r\nspin_unlock_irqrestore(&userio->buf_lock, flags);\r\nwake_up_interruptible(&userio->waitq);\r\nreturn 0;\r\n}\r\nstatic int userio_char_open(struct inode *inode, struct file *file)\r\n{\r\nstruct userio_device *userio;\r\nuserio = kzalloc(sizeof(struct userio_device), GFP_KERNEL);\r\nif (!userio)\r\nreturn -ENOMEM;\r\nmutex_init(&userio->mutex);\r\nspin_lock_init(&userio->buf_lock);\r\ninit_waitqueue_head(&userio->waitq);\r\nuserio->serio = kzalloc(sizeof(struct serio), GFP_KERNEL);\r\nif (!userio->serio) {\r\nkfree(userio);\r\nreturn -ENOMEM;\r\n}\r\nuserio->serio->write = userio_device_write;\r\nuserio->serio->port_data = userio;\r\nfile->private_data = userio;\r\nreturn 0;\r\n}\r\nstatic int userio_char_release(struct inode *inode, struct file *file)\r\n{\r\nstruct userio_device *userio = file->private_data;\r\nif (userio->running) {\r\nserio_unregister_port(userio->serio);\r\n} else {\r\nkfree(userio->serio);\r\n}\r\nkfree(userio);\r\nreturn 0;\r\n}\r\nstatic ssize_t userio_char_read(struct file *file, char __user *user_buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct userio_device *userio = file->private_data;\r\nint error;\r\nsize_t nonwrap_len, copylen;\r\nunsigned char buf[USERIO_BUFSIZE];\r\nunsigned long flags;\r\nfor (;;) {\r\nspin_lock_irqsave(&userio->buf_lock, flags);\r\nnonwrap_len = CIRC_CNT_TO_END(userio->head,\r\nuserio->tail,\r\nUSERIO_BUFSIZE);\r\ncopylen = min(nonwrap_len, count);\r\nif (copylen) {\r\nmemcpy(buf, &userio->buf[userio->tail], copylen);\r\nuserio->tail = (userio->tail + copylen) %\r\nUSERIO_BUFSIZE;\r\n}\r\nspin_unlock_irqrestore(&userio->buf_lock, flags);\r\nif (nonwrap_len)\r\nbreak;\r\nif (file->f_flags & O_NONBLOCK)\r\nreturn -EAGAIN;\r\nif (count == 0)\r\nreturn 0;\r\nerror = wait_event_interruptible(userio->waitq,\r\nuserio->head != userio->tail);\r\nif (error)\r\nreturn error;\r\n}\r\nif (copylen)\r\nif (copy_to_user(user_buffer, buf, copylen))\r\nreturn -EFAULT;\r\nreturn copylen;\r\n}\r\nstatic ssize_t userio_char_write(struct file *file, const char __user *buffer,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct userio_device *userio = file->private_data;\r\nstruct userio_cmd cmd;\r\nint error;\r\nif (count != sizeof(cmd)) {\r\ndev_warn(userio_misc.this_device, "Invalid payload size\n");\r\nreturn -EINVAL;\r\n}\r\nif (copy_from_user(&cmd, buffer, sizeof(cmd)))\r\nreturn -EFAULT;\r\nerror = mutex_lock_interruptible(&userio->mutex);\r\nif (error)\r\nreturn error;\r\nswitch (cmd.type) {\r\ncase USERIO_CMD_REGISTER:\r\nif (!userio->serio->id.type) {\r\ndev_warn(userio_misc.this_device,\r\n"No port type given on /dev/userio\n");\r\nerror = -EINVAL;\r\ngoto out;\r\n}\r\nif (userio->running) {\r\ndev_warn(userio_misc.this_device,\r\n"Begin command sent, but we're already running\n");\r\nerror = -EBUSY;\r\ngoto out;\r\n}\r\nuserio->running = true;\r\nserio_register_port(userio->serio);\r\nbreak;\r\ncase USERIO_CMD_SET_PORT_TYPE:\r\nif (userio->running) {\r\ndev_warn(userio_misc.this_device,\r\n"Can't change port type on an already running userio instance\n");\r\nerror = -EBUSY;\r\ngoto out;\r\n}\r\nuserio->serio->id.type = cmd.data;\r\nbreak;\r\ncase USERIO_CMD_SEND_INTERRUPT:\r\nif (!userio->running) {\r\ndev_warn(userio_misc.this_device,\r\n"The device must be registered before sending interrupts\n");\r\nerror = -ENODEV;\r\ngoto out;\r\n}\r\nserio_interrupt(userio->serio, cmd.data, 0);\r\nbreak;\r\ndefault:\r\nerror = -EOPNOTSUPP;\r\ngoto out;\r\n}\r\nout:\r\nmutex_unlock(&userio->mutex);\r\nreturn error ?: count;\r\n}\r\nstatic unsigned int userio_char_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct userio_device *userio = file->private_data;\r\npoll_wait(file, &userio->waitq, wait);\r\nif (userio->head != userio->tail)\r\nreturn POLLIN | POLLRDNORM;\r\nreturn 0;\r\n}
