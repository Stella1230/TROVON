void eeh_set_pe_aux_size(int size)\r\n{\r\nif (size < 0)\r\nreturn;\r\neeh_pe_aux_size = size;\r\n}\r\nstatic struct eeh_pe *eeh_pe_alloc(struct pci_controller *phb, int type)\r\n{\r\nstruct eeh_pe *pe;\r\nsize_t alloc_size;\r\nalloc_size = sizeof(struct eeh_pe);\r\nif (eeh_pe_aux_size) {\r\nalloc_size = ALIGN(alloc_size, cache_line_size());\r\nalloc_size += eeh_pe_aux_size;\r\n}\r\npe = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!pe) return NULL;\r\npe->type = type;\r\npe->phb = phb;\r\nINIT_LIST_HEAD(&pe->child_list);\r\nINIT_LIST_HEAD(&pe->child);\r\nINIT_LIST_HEAD(&pe->edevs);\r\npe->data = (void *)pe + ALIGN(sizeof(struct eeh_pe),\r\ncache_line_size());\r\nreturn pe;\r\n}\r\nint eeh_phb_pe_create(struct pci_controller *phb)\r\n{\r\nstruct eeh_pe *pe;\r\npe = eeh_pe_alloc(phb, EEH_PE_PHB);\r\nif (!pe) {\r\npr_err("%s: out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nlist_add_tail(&pe->child, &eeh_phb_pe);\r\npr_debug("EEH: Add PE for PHB#%x\n", phb->global_number);\r\nreturn 0;\r\n}\r\nstruct eeh_pe *eeh_phb_pe_get(struct pci_controller *phb)\r\n{\r\nstruct eeh_pe *pe;\r\nlist_for_each_entry(pe, &eeh_phb_pe, child) {\r\nif ((pe->type & EEH_PE_PHB) && pe->phb == phb)\r\nreturn pe;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct eeh_pe *eeh_pe_next(struct eeh_pe *pe,\r\nstruct eeh_pe *root)\r\n{\r\nstruct list_head *next = pe->child_list.next;\r\nif (next == &pe->child_list) {\r\nwhile (1) {\r\nif (pe == root)\r\nreturn NULL;\r\nnext = pe->child.next;\r\nif (next != &pe->parent->child_list)\r\nbreak;\r\npe = pe->parent;\r\n}\r\n}\r\nreturn list_entry(next, struct eeh_pe, child);\r\n}\r\nvoid *eeh_pe_traverse(struct eeh_pe *root,\r\neeh_traverse_func fn, void *flag)\r\n{\r\nstruct eeh_pe *pe;\r\nvoid *ret;\r\nfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\r\nret = fn(pe, flag);\r\nif (ret) return ret;\r\n}\r\nreturn NULL;\r\n}\r\nvoid *eeh_pe_dev_traverse(struct eeh_pe *root,\r\neeh_traverse_func fn, void *flag)\r\n{\r\nstruct eeh_pe *pe;\r\nstruct eeh_dev *edev, *tmp;\r\nvoid *ret;\r\nif (!root) {\r\npr_warn("%s: Invalid PE %p\n",\r\n__func__, root);\r\nreturn NULL;\r\n}\r\nfor (pe = root; pe; pe = eeh_pe_next(pe, root)) {\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\nret = fn(edev, flag);\r\nif (ret)\r\nreturn ret;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic void *__eeh_pe_get(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nstruct eeh_dev *edev = (struct eeh_dev *)flag;\r\nif (pe->type & EEH_PE_PHB)\r\nreturn NULL;\r\nif (eeh_has_flag(EEH_VALID_PE_ZERO)) {\r\nif (edev->pe_config_addr == pe->addr)\r\nreturn pe;\r\n} else {\r\nif (edev->pe_config_addr &&\r\n(edev->pe_config_addr == pe->addr))\r\nreturn pe;\r\n}\r\nif (edev->config_addr &&\r\n(edev->config_addr == pe->config_addr))\r\nreturn pe;\r\nreturn NULL;\r\n}\r\nstruct eeh_pe *eeh_pe_get(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *root = eeh_phb_pe_get(edev->phb);\r\nstruct eeh_pe *pe;\r\npe = eeh_pe_traverse(root, __eeh_pe_get, edev);\r\nreturn pe;\r\n}\r\nstatic struct eeh_pe *eeh_pe_get_parent(struct eeh_dev *edev)\r\n{\r\nstruct eeh_dev *parent;\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nif (edev->physfn)\r\npdn = pci_get_pdn(edev->physfn);\r\nelse\r\npdn = pdn ? pdn->parent : NULL;\r\nwhile (pdn) {\r\nparent = pdn_to_eeh_dev(pdn);\r\nif (!parent)\r\nreturn NULL;\r\nif (parent->pe)\r\nreturn parent->pe;\r\npdn = pdn->parent;\r\n}\r\nreturn NULL;\r\n}\r\nint eeh_add_to_parent_pe(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *pe, *parent;\r\nif (!eeh_has_flag(EEH_VALID_PE_ZERO) && !edev->pe_config_addr) {\r\npr_err("%s: Invalid PE#0 for edev 0x%x on PHB#%x\n",\r\n__func__, edev->config_addr, edev->phb->global_number);\r\nreturn -EINVAL;\r\n}\r\npe = eeh_pe_get(edev);\r\nif (pe && !(pe->type & EEH_PE_INVALID)) {\r\npe->type = EEH_PE_BUS;\r\nedev->pe = pe;\r\nlist_add_tail(&edev->list, &pe->edevs);\r\npr_debug("EEH: Add %04x:%02x:%02x.%01x to Bus PE#%x\n",\r\nedev->phb->global_number,\r\nedev->config_addr >> 8,\r\nPCI_SLOT(edev->config_addr & 0xFF),\r\nPCI_FUNC(edev->config_addr & 0xFF),\r\npe->addr);\r\nreturn 0;\r\n} else if (pe && (pe->type & EEH_PE_INVALID)) {\r\nlist_add_tail(&edev->list, &pe->edevs);\r\nedev->pe = pe;\r\nparent = pe;\r\nwhile (parent) {\r\nif (!(parent->type & EEH_PE_INVALID))\r\nbreak;\r\nparent->type &= ~(EEH_PE_INVALID | EEH_PE_KEEP);\r\nparent = parent->parent;\r\n}\r\npr_debug("EEH: Add %04x:%02x:%02x.%01x to Device "\r\n"PE#%x, Parent PE#%x\n",\r\nedev->phb->global_number,\r\nedev->config_addr >> 8,\r\nPCI_SLOT(edev->config_addr & 0xFF),\r\nPCI_FUNC(edev->config_addr & 0xFF),\r\npe->addr, pe->parent->addr);\r\nreturn 0;\r\n}\r\nif (edev->physfn)\r\npe = eeh_pe_alloc(edev->phb, EEH_PE_VF);\r\nelse\r\npe = eeh_pe_alloc(edev->phb, EEH_PE_DEVICE);\r\nif (!pe) {\r\npr_err("%s: out of memory!\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\npe->addr = edev->pe_config_addr;\r\npe->config_addr = edev->config_addr;\r\nparent = eeh_pe_get_parent(edev);\r\nif (!parent) {\r\nparent = eeh_phb_pe_get(edev->phb);\r\nif (!parent) {\r\npr_err("%s: No PHB PE is found (PHB Domain=%d)\n",\r\n__func__, edev->phb->global_number);\r\nedev->pe = NULL;\r\nkfree(pe);\r\nreturn -EEXIST;\r\n}\r\n}\r\npe->parent = parent;\r\nlist_add_tail(&pe->child, &parent->child_list);\r\nlist_add_tail(&edev->list, &pe->edevs);\r\nedev->pe = pe;\r\npr_debug("EEH: Add %04x:%02x:%02x.%01x to "\r\n"Device PE#%x, Parent PE#%x\n",\r\nedev->phb->global_number,\r\nedev->config_addr >> 8,\r\nPCI_SLOT(edev->config_addr & 0xFF),\r\nPCI_FUNC(edev->config_addr & 0xFF),\r\npe->addr, pe->parent->addr);\r\nreturn 0;\r\n}\r\nint eeh_rmv_from_parent_pe(struct eeh_dev *edev)\r\n{\r\nstruct eeh_pe *pe, *parent, *child;\r\nint cnt;\r\nif (!edev->pe) {\r\npr_debug("%s: No PE found for device %04x:%02x:%02x.%01x\n",\r\n__func__, edev->phb->global_number,\r\nedev->config_addr >> 8,\r\nPCI_SLOT(edev->config_addr & 0xFF),\r\nPCI_FUNC(edev->config_addr & 0xFF));\r\nreturn -EEXIST;\r\n}\r\npe = eeh_dev_to_pe(edev);\r\nedev->pe = NULL;\r\nlist_del(&edev->list);\r\nwhile (1) {\r\nparent = pe->parent;\r\nif (pe->type & EEH_PE_PHB)\r\nbreak;\r\nif (!(pe->state & EEH_PE_KEEP)) {\r\nif (list_empty(&pe->edevs) &&\r\nlist_empty(&pe->child_list)) {\r\nlist_del(&pe->child);\r\nkfree(pe);\r\n} else {\r\nbreak;\r\n}\r\n} else {\r\nif (list_empty(&pe->edevs)) {\r\ncnt = 0;\r\nlist_for_each_entry(child, &pe->child_list, child) {\r\nif (!(child->type & EEH_PE_INVALID)) {\r\ncnt++;\r\nbreak;\r\n}\r\n}\r\nif (!cnt)\r\npe->type |= EEH_PE_INVALID;\r\nelse\r\nbreak;\r\n}\r\n}\r\npe = parent;\r\n}\r\nreturn 0;\r\n}\r\nvoid eeh_pe_update_time_stamp(struct eeh_pe *pe)\r\n{\r\nstruct timeval tstamp;\r\nif (!pe) return;\r\nif (pe->freeze_count <= 0) {\r\npe->freeze_count = 0;\r\ndo_gettimeofday(&pe->tstamp);\r\n} else {\r\ndo_gettimeofday(&tstamp);\r\nif (tstamp.tv_sec - pe->tstamp.tv_sec > 3600) {\r\npe->tstamp = tstamp;\r\npe->freeze_count = 0;\r\n}\r\n}\r\n}\r\nstatic void *__eeh_pe_state_mark(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nint state = *((int *)flag);\r\nstruct eeh_dev *edev, *tmp;\r\nstruct pci_dev *pdev;\r\nif (pe->state & EEH_PE_REMOVED)\r\nreturn NULL;\r\npe->state |= state;\r\nif (!(state & EEH_PE_ISOLATED))\r\nreturn NULL;\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (pdev)\r\npdev->error_state = pci_channel_io_frozen;\r\n}\r\nif (pe->state & EEH_PE_CFG_RESTRICTED)\r\npe->state |= EEH_PE_CFG_BLOCKED;\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_state_mark(struct eeh_pe *pe, int state)\r\n{\r\neeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\r\n}\r\nstatic void *__eeh_pe_dev_mode_mark(void *data, void *flag)\r\n{\r\nstruct eeh_dev *edev = data;\r\nint mode = *((int *)flag);\r\nedev->mode |= mode;\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_dev_mode_mark(struct eeh_pe *pe, int mode)\r\n{\r\neeh_pe_dev_traverse(pe, __eeh_pe_dev_mode_mark, &mode);\r\n}\r\nstatic void *__eeh_pe_state_clear(void *data, void *flag)\r\n{\r\nstruct eeh_pe *pe = (struct eeh_pe *)data;\r\nint state = *((int *)flag);\r\nstruct eeh_dev *edev, *tmp;\r\nstruct pci_dev *pdev;\r\nif (pe->state & EEH_PE_REMOVED)\r\nreturn NULL;\r\npe->state &= ~state;\r\nif (!(state & EEH_PE_ISOLATED))\r\nreturn NULL;\r\npe->check_count = 0;\r\neeh_pe_for_each_dev(pe, edev, tmp) {\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (!pdev)\r\ncontinue;\r\npdev->error_state = pci_channel_io_normal;\r\n}\r\nif (pe->state & EEH_PE_CFG_RESTRICTED)\r\npe->state &= ~EEH_PE_CFG_BLOCKED;\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_state_clear(struct eeh_pe *pe, int state)\r\n{\r\neeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\r\n}\r\nvoid eeh_pe_state_mark_with_cfg(struct eeh_pe *pe, int state)\r\n{\r\neeh_pe_traverse(pe, __eeh_pe_state_mark, &state);\r\nif (!(state & EEH_PE_ISOLATED))\r\nreturn;\r\nstate = EEH_PE_CFG_BLOCKED;\r\neeh_pe_traverse(pe, __eeh_pe_state_clear, &state);\r\n}\r\nstatic void eeh_bridge_check_link(struct eeh_dev *edev)\r\n{\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nint cap;\r\nuint32_t val;\r\nint timeout = 0;\r\nif (!(edev->mode & (EEH_DEV_ROOT_PORT | EEH_DEV_DS_PORT)))\r\nreturn;\r\npr_debug("%s: Check PCIe link for %04x:%02x:%02x.%01x ...\n",\r\n__func__, edev->phb->global_number,\r\nedev->config_addr >> 8,\r\nPCI_SLOT(edev->config_addr & 0xFF),\r\nPCI_FUNC(edev->config_addr & 0xFF));\r\ncap = edev->pcie_cap;\r\neeh_ops->read_config(pdn, cap + PCI_EXP_SLTSTA, 2, &val);\r\nif (!(val & PCI_EXP_SLTSTA_PDS)) {\r\npr_debug(" No card in the slot (0x%04x) !\n", val);\r\nreturn;\r\n}\r\neeh_ops->read_config(pdn, cap + PCI_EXP_SLTCAP, 2, &val);\r\nif (val & PCI_EXP_SLTCAP_PCP) {\r\neeh_ops->read_config(pdn, cap + PCI_EXP_SLTCTL, 2, &val);\r\nif (val & PCI_EXP_SLTCTL_PCC) {\r\npr_debug(" In power-off state, power it on ...\n");\r\nval &= ~(PCI_EXP_SLTCTL_PCC | PCI_EXP_SLTCTL_PIC);\r\nval |= (0x0100 & PCI_EXP_SLTCTL_PIC);\r\neeh_ops->write_config(pdn, cap + PCI_EXP_SLTCTL, 2, val);\r\nmsleep(2 * 1000);\r\n}\r\n}\r\neeh_ops->read_config(pdn, cap + PCI_EXP_LNKCTL, 2, &val);\r\nval &= ~PCI_EXP_LNKCTL_LD;\r\neeh_ops->write_config(pdn, cap + PCI_EXP_LNKCTL, 2, val);\r\neeh_ops->read_config(pdn, cap + PCI_EXP_LNKCAP, 4, &val);\r\nif (!(val & PCI_EXP_LNKCAP_DLLLARC)) {\r\npr_debug(" No link reporting capability (0x%08x) \n", val);\r\nmsleep(1000);\r\nreturn;\r\n}\r\ntimeout = 0;\r\nwhile (timeout < 5000) {\r\nmsleep(20);\r\ntimeout += 20;\r\neeh_ops->read_config(pdn, cap + PCI_EXP_LNKSTA, 2, &val);\r\nif (val & PCI_EXP_LNKSTA_DLLLA)\r\nbreak;\r\n}\r\nif (val & PCI_EXP_LNKSTA_DLLLA)\r\npr_debug(" Link up (%s)\n",\r\n(val & PCI_EXP_LNKSTA_CLS_2_5GB) ? "2.5GB" : "5GB");\r\nelse\r\npr_debug(" Link not ready (0x%04x)\n", val);\r\n}\r\nstatic void eeh_restore_bridge_bars(struct eeh_dev *edev)\r\n{\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nint i;\r\nfor (i = 4; i < 13; i++)\r\neeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\r\neeh_ops->write_config(pdn, 14*4, 4, edev->config_space[14]);\r\neeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\r\nSAVED_BYTE(PCI_CACHE_LINE_SIZE));\r\neeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\r\nSAVED_BYTE(PCI_LATENCY_TIMER));\r\neeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\r\neeh_ops->write_config(pdn, PCI_COMMAND, 4, edev->config_space[1]);\r\neeh_bridge_check_link(edev);\r\n}\r\nstatic void eeh_restore_device_bars(struct eeh_dev *edev)\r\n{\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nint i;\r\nu32 cmd;\r\nfor (i = 4; i < 10; i++)\r\neeh_ops->write_config(pdn, i*4, 4, edev->config_space[i]);\r\neeh_ops->write_config(pdn, 12*4, 4, edev->config_space[12]);\r\neeh_ops->write_config(pdn, PCI_CACHE_LINE_SIZE, 1,\r\nSAVED_BYTE(PCI_CACHE_LINE_SIZE));\r\neeh_ops->write_config(pdn, PCI_LATENCY_TIMER, 1,\r\nSAVED_BYTE(PCI_LATENCY_TIMER));\r\neeh_ops->write_config(pdn, 15*4, 4, edev->config_space[15]);\r\neeh_ops->read_config(pdn, PCI_COMMAND, 4, &cmd);\r\nif (edev->config_space[1] & PCI_COMMAND_PARITY)\r\ncmd |= PCI_COMMAND_PARITY;\r\nelse\r\ncmd &= ~PCI_COMMAND_PARITY;\r\nif (edev->config_space[1] & PCI_COMMAND_SERR)\r\ncmd |= PCI_COMMAND_SERR;\r\nelse\r\ncmd &= ~PCI_COMMAND_SERR;\r\neeh_ops->write_config(pdn, PCI_COMMAND, 4, cmd);\r\n}\r\nstatic void *eeh_restore_one_device_bars(void *data, void *flag)\r\n{\r\nstruct eeh_dev *edev = (struct eeh_dev *)data;\r\nstruct pci_dn *pdn = eeh_dev_to_pdn(edev);\r\nif (edev->mode & EEH_DEV_BRIDGE)\r\neeh_restore_bridge_bars(edev);\r\nelse\r\neeh_restore_device_bars(edev);\r\nif (eeh_ops->restore_config && pdn)\r\neeh_ops->restore_config(pdn);\r\nreturn NULL;\r\n}\r\nvoid eeh_pe_restore_bars(struct eeh_pe *pe)\r\n{\r\neeh_pe_dev_traverse(pe, eeh_restore_one_device_bars, NULL);\r\n}\r\nconst char *eeh_pe_loc_get(struct eeh_pe *pe)\r\n{\r\nstruct pci_bus *bus = eeh_pe_bus_get(pe);\r\nstruct device_node *dn;\r\nconst char *loc = NULL;\r\nwhile (bus) {\r\ndn = pci_bus_to_OF_node(bus);\r\nif (!dn) {\r\nbus = bus->parent;\r\ncontinue;\r\n}\r\nif (pci_is_root_bus(bus))\r\nloc = of_get_property(dn, "ibm,io-base-loc-code", NULL);\r\nelse\r\nloc = of_get_property(dn, "ibm,slot-location-code",\r\nNULL);\r\nif (loc)\r\nreturn loc;\r\nbus = bus->parent;\r\n}\r\nreturn "N/A";\r\n}\r\nstruct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)\r\n{\r\nstruct eeh_dev *edev;\r\nstruct pci_dev *pdev;\r\nif (pe->type & EEH_PE_PHB)\r\nreturn pe->phb->bus;\r\nif (pe->state & EEH_PE_PRI_BUS)\r\nreturn pe->bus;\r\nedev = list_first_entry_or_null(&pe->edevs, struct eeh_dev, list);\r\npdev = eeh_dev_to_pci_dev(edev);\r\nif (pdev)\r\nreturn pdev->bus;\r\nreturn NULL;\r\n}
