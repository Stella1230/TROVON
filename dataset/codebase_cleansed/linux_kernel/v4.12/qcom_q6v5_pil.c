static int q6v5_regulator_init(struct device *dev, struct reg_info *regs,\r\nconst struct qcom_mss_reg_res *reg_res)\r\n{\r\nint rc;\r\nint i;\r\nif (!reg_res)\r\nreturn 0;\r\nfor (i = 0; reg_res[i].supply; i++) {\r\nregs[i].reg = devm_regulator_get(dev, reg_res[i].supply);\r\nif (IS_ERR(regs[i].reg)) {\r\nrc = PTR_ERR(regs[i].reg);\r\nif (rc != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get %s\n regulator",\r\nreg_res[i].supply);\r\nreturn rc;\r\n}\r\nregs[i].uV = reg_res[i].uV;\r\nregs[i].uA = reg_res[i].uA;\r\n}\r\nreturn i;\r\n}\r\nstatic int q6v5_regulator_enable(struct q6v5 *qproc,\r\nstruct reg_info *regs, int count)\r\n{\r\nint ret;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (regs[i].uV > 0) {\r\nret = regulator_set_voltage(regs[i].reg,\r\nregs[i].uV, INT_MAX);\r\nif (ret) {\r\ndev_err(qproc->dev,\r\n"Failed to request voltage for %d.\n",\r\ni);\r\ngoto err;\r\n}\r\n}\r\nif (regs[i].uA > 0) {\r\nret = regulator_set_load(regs[i].reg,\r\nregs[i].uA);\r\nif (ret < 0) {\r\ndev_err(qproc->dev,\r\n"Failed to set regulator mode\n");\r\ngoto err;\r\n}\r\n}\r\nret = regulator_enable(regs[i].reg);\r\nif (ret) {\r\ndev_err(qproc->dev, "Regulator enable failed\n");\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (; i >= 0; i--) {\r\nif (regs[i].uV > 0)\r\nregulator_set_voltage(regs[i].reg, 0, INT_MAX);\r\nif (regs[i].uA > 0)\r\nregulator_set_load(regs[i].reg, 0);\r\nregulator_disable(regs[i].reg);\r\n}\r\nreturn ret;\r\n}\r\nstatic void q6v5_regulator_disable(struct q6v5 *qproc,\r\nstruct reg_info *regs, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nif (regs[i].uV > 0)\r\nregulator_set_voltage(regs[i].reg, 0, INT_MAX);\r\nif (regs[i].uA > 0)\r\nregulator_set_load(regs[i].reg, 0);\r\nregulator_disable(regs[i].reg);\r\n}\r\n}\r\nstatic int q6v5_clk_enable(struct device *dev,\r\nstruct clk **clks, int count)\r\n{\r\nint rc;\r\nint i;\r\nfor (i = 0; i < count; i++) {\r\nrc = clk_prepare_enable(clks[i]);\r\nif (rc) {\r\ndev_err(dev, "Clock enable failed\n");\r\ngoto err;\r\n}\r\n}\r\nreturn 0;\r\nerr:\r\nfor (i--; i >= 0; i--)\r\nclk_disable_unprepare(clks[i]);\r\nreturn rc;\r\n}\r\nstatic void q6v5_clk_disable(struct device *dev,\r\nstruct clk **clks, int count)\r\n{\r\nint i;\r\nfor (i = 0; i < count; i++)\r\nclk_disable_unprepare(clks[i]);\r\n}\r\nstatic struct resource_table *q6v5_find_rsc_table(struct rproc *rproc,\r\nconst struct firmware *fw,\r\nint *tablesz)\r\n{\r\nstatic struct resource_table table = { .ver = 1, };\r\n*tablesz = sizeof(table);\r\nreturn &table;\r\n}\r\nstatic int q6v5_load(struct rproc *rproc, const struct firmware *fw)\r\n{\r\nstruct q6v5 *qproc = rproc->priv;\r\nmemcpy(qproc->mba_region, fw->data, fw->size);\r\nreturn 0;\r\n}\r\nstatic int q6v5_rmb_pbl_wait(struct q6v5 *qproc, int ms)\r\n{\r\nunsigned long timeout;\r\ns32 val;\r\ntimeout = jiffies + msecs_to_jiffies(ms);\r\nfor (;;) {\r\nval = readl(qproc->rmb_base + RMB_PBL_STATUS_REG);\r\nif (val)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nmsleep(1);\r\n}\r\nreturn val;\r\n}\r\nstatic int q6v5_rmb_mba_wait(struct q6v5 *qproc, u32 status, int ms)\r\n{\r\nunsigned long timeout;\r\ns32 val;\r\ntimeout = jiffies + msecs_to_jiffies(ms);\r\nfor (;;) {\r\nval = readl(qproc->rmb_base + RMB_MBA_STATUS_REG);\r\nif (val < 0)\r\nbreak;\r\nif (!status && val)\r\nbreak;\r\nelse if (status && val == status)\r\nbreak;\r\nif (time_after(jiffies, timeout))\r\nreturn -ETIMEDOUT;\r\nmsleep(1);\r\n}\r\nreturn val;\r\n}\r\nstatic int q6v5proc_reset(struct q6v5 *qproc)\r\n{\r\nu32 val;\r\nint ret;\r\nval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\r\nval |= (Q6SS_CORE_ARES | Q6SS_BUS_ARES_ENABLE | Q6SS_STOP_CORE);\r\nwritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\r\nval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval |= QDSS_BHS_ON | QDSS_LDO_BYP;\r\nwritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nudelay(1);\r\nval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval |= Q6SS_SLP_RET_N | Q6SS_L2TAG_SLP_NRET_N |\r\nQ6SS_ETB_SLP_NRET_N | Q6SS_L2DATA_STBY_N;\r\nwritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval |= Q6SS_L2DATA_SLP_NRET_N_2;\r\nwritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval |= Q6SS_L2DATA_SLP_NRET_N_1;\r\nwritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval |= Q6SS_L2DATA_SLP_NRET_N_0;\r\nwritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval &= ~Q6SS_CLAMP_IO;\r\nwritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\r\nval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\r\nval &= ~Q6SS_CORE_ARES;\r\nwritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\r\nval = readl(qproc->reg_base + QDSP6SS_GFMUX_CTL_REG);\r\nval |= Q6SS_CLK_ENABLE;\r\nwritel(val, qproc->reg_base + QDSP6SS_GFMUX_CTL_REG);\r\nval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\r\nval &= ~Q6SS_STOP_CORE;\r\nwritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\r\nret = q6v5_rmb_pbl_wait(qproc, 1000);\r\nif (ret == -ETIMEDOUT) {\r\ndev_err(qproc->dev, "PBL boot timed out\n");\r\n} else if (ret != RMB_PBL_SUCCESS) {\r\ndev_err(qproc->dev, "PBL returned unexpected status %d\n", ret);\r\nret = -EINVAL;\r\n} else {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic void q6v5proc_halt_axi_port(struct q6v5 *qproc,\r\nstruct regmap *halt_map,\r\nu32 offset)\r\n{\r\nunsigned long timeout;\r\nunsigned int val;\r\nint ret;\r\nret = regmap_read(halt_map, offset + AXI_IDLE_REG, &val);\r\nif (!ret && val)\r\nreturn;\r\nregmap_write(halt_map, offset + AXI_HALTREQ_REG, 1);\r\ntimeout = jiffies + msecs_to_jiffies(HALT_ACK_TIMEOUT_MS);\r\nfor (;;) {\r\nret = regmap_read(halt_map, offset + AXI_HALTACK_REG, &val);\r\nif (ret || val || time_after(jiffies, timeout))\r\nbreak;\r\nmsleep(1);\r\n}\r\nret = regmap_read(halt_map, offset + AXI_IDLE_REG, &val);\r\nif (ret || !val)\r\ndev_err(qproc->dev, "port failed halt\n");\r\nregmap_write(halt_map, offset + AXI_HALTREQ_REG, 0);\r\n}\r\nstatic int q6v5_mpss_init_image(struct q6v5 *qproc, const struct firmware *fw)\r\n{\r\nunsigned long dma_attrs = DMA_ATTR_FORCE_CONTIGUOUS;\r\ndma_addr_t phys;\r\nvoid *ptr;\r\nint ret;\r\nptr = dma_alloc_attrs(qproc->dev, fw->size, &phys, GFP_KERNEL, dma_attrs);\r\nif (!ptr) {\r\ndev_err(qproc->dev, "failed to allocate mdt buffer\n");\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(ptr, fw->data, fw->size);\r\nwritel(phys, qproc->rmb_base + RMB_PMI_META_DATA_REG);\r\nwritel(RMB_CMD_META_DATA_READY, qproc->rmb_base + RMB_MBA_COMMAND_REG);\r\nret = q6v5_rmb_mba_wait(qproc, RMB_MBA_META_DATA_AUTH_SUCCESS, 1000);\r\nif (ret == -ETIMEDOUT)\r\ndev_err(qproc->dev, "MPSS header authentication timed out\n");\r\nelse if (ret < 0)\r\ndev_err(qproc->dev, "MPSS header authentication failed: %d\n", ret);\r\ndma_free_attrs(qproc->dev, fw->size, ptr, phys, dma_attrs);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic bool q6v5_phdr_valid(const struct elf32_phdr *phdr)\r\n{\r\nif (phdr->p_type != PT_LOAD)\r\nreturn false;\r\nif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\r\nreturn false;\r\nif (!phdr->p_memsz)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int q6v5_mpss_load(struct q6v5 *qproc)\r\n{\r\nconst struct elf32_phdr *phdrs;\r\nconst struct elf32_phdr *phdr;\r\nconst struct firmware *seg_fw;\r\nconst struct firmware *fw;\r\nstruct elf32_hdr *ehdr;\r\nphys_addr_t mpss_reloc;\r\nphys_addr_t boot_addr;\r\nphys_addr_t min_addr = (phys_addr_t)ULLONG_MAX;\r\nphys_addr_t max_addr = 0;\r\nbool relocate = false;\r\nchar seg_name[10];\r\nssize_t offset;\r\nsize_t size;\r\nvoid *ptr;\r\nint ret;\r\nint i;\r\nret = request_firmware(&fw, "modem.mdt", qproc->dev);\r\nif (ret < 0) {\r\ndev_err(qproc->dev, "unable to load modem.mdt\n");\r\nreturn ret;\r\n}\r\nwritel(0, qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\r\nret = q6v5_mpss_init_image(qproc, fw);\r\nif (ret)\r\ngoto release_firmware;\r\nehdr = (struct elf32_hdr *)fw->data;\r\nphdrs = (struct elf32_phdr *)(ehdr + 1);\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (!q6v5_phdr_valid(phdr))\r\ncontinue;\r\nif (phdr->p_flags & QCOM_MDT_RELOCATABLE)\r\nrelocate = true;\r\nif (phdr->p_paddr < min_addr)\r\nmin_addr = phdr->p_paddr;\r\nif (phdr->p_paddr + phdr->p_memsz > max_addr)\r\nmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\r\n}\r\nmpss_reloc = relocate ? min_addr : qproc->mpss_phys;\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nphdr = &phdrs[i];\r\nif (!q6v5_phdr_valid(phdr))\r\ncontinue;\r\noffset = phdr->p_paddr - mpss_reloc;\r\nif (offset < 0 || offset + phdr->p_memsz > qproc->mpss_size) {\r\ndev_err(qproc->dev, "segment outside memory range\n");\r\nret = -EINVAL;\r\ngoto release_firmware;\r\n}\r\nptr = qproc->mpss_region + offset;\r\nif (phdr->p_filesz) {\r\nsnprintf(seg_name, sizeof(seg_name), "modem.b%02d", i);\r\nret = request_firmware(&seg_fw, seg_name, qproc->dev);\r\nif (ret) {\r\ndev_err(qproc->dev, "failed to load %s\n", seg_name);\r\ngoto release_firmware;\r\n}\r\nmemcpy(ptr, seg_fw->data, seg_fw->size);\r\nrelease_firmware(seg_fw);\r\n}\r\nif (phdr->p_memsz > phdr->p_filesz) {\r\nmemset(ptr + phdr->p_filesz, 0,\r\nphdr->p_memsz - phdr->p_filesz);\r\n}\r\nsize = readl(qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\r\nif (!size) {\r\nboot_addr = relocate ? qproc->mpss_phys : min_addr;\r\nwritel(boot_addr, qproc->rmb_base + RMB_PMI_CODE_START_REG);\r\nwritel(RMB_CMD_LOAD_READY, qproc->rmb_base + RMB_MBA_COMMAND_REG);\r\n}\r\nsize += phdr->p_memsz;\r\nwritel(size, qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\r\n}\r\nret = q6v5_rmb_mba_wait(qproc, RMB_MBA_AUTH_COMPLETE, 10000);\r\nif (ret == -ETIMEDOUT)\r\ndev_err(qproc->dev, "MPSS authentication timed out\n");\r\nelse if (ret < 0)\r\ndev_err(qproc->dev, "MPSS authentication failed: %d\n", ret);\r\nrelease_firmware:\r\nrelease_firmware(fw);\r\nreturn ret < 0 ? ret : 0;\r\n}\r\nstatic int q6v5_start(struct rproc *rproc)\r\n{\r\nstruct q6v5 *qproc = (struct q6v5 *)rproc->priv;\r\nint ret;\r\nret = q6v5_regulator_enable(qproc, qproc->proxy_regs,\r\nqproc->proxy_reg_count);\r\nif (ret) {\r\ndev_err(qproc->dev, "failed to enable proxy supplies\n");\r\nreturn ret;\r\n}\r\nret = q6v5_clk_enable(qproc->dev, qproc->proxy_clks,\r\nqproc->proxy_clk_count);\r\nif (ret) {\r\ndev_err(qproc->dev, "failed to enable proxy clocks\n");\r\ngoto disable_proxy_reg;\r\n}\r\nret = q6v5_regulator_enable(qproc, qproc->active_regs,\r\nqproc->active_reg_count);\r\nif (ret) {\r\ndev_err(qproc->dev, "failed to enable supplies\n");\r\ngoto disable_proxy_clk;\r\n}\r\nret = reset_control_deassert(qproc->mss_restart);\r\nif (ret) {\r\ndev_err(qproc->dev, "failed to deassert mss restart\n");\r\ngoto disable_vdd;\r\n}\r\nret = q6v5_clk_enable(qproc->dev, qproc->active_clks,\r\nqproc->active_clk_count);\r\nif (ret) {\r\ndev_err(qproc->dev, "failed to enable clocks\n");\r\ngoto assert_reset;\r\n}\r\nwritel(qproc->mba_phys, qproc->rmb_base + RMB_MBA_IMAGE_REG);\r\nret = q6v5proc_reset(qproc);\r\nif (ret)\r\ngoto halt_axi_ports;\r\nret = q6v5_rmb_mba_wait(qproc, 0, 5000);\r\nif (ret == -ETIMEDOUT) {\r\ndev_err(qproc->dev, "MBA boot timed out\n");\r\ngoto halt_axi_ports;\r\n} else if (ret != RMB_MBA_XPU_UNLOCKED &&\r\nret != RMB_MBA_XPU_UNLOCKED_SCRIBBLED) {\r\ndev_err(qproc->dev, "MBA returned unexpected status %d\n", ret);\r\nret = -EINVAL;\r\ngoto halt_axi_ports;\r\n}\r\ndev_info(qproc->dev, "MBA booted, loading mpss\n");\r\nret = q6v5_mpss_load(qproc);\r\nif (ret)\r\ngoto halt_axi_ports;\r\nret = wait_for_completion_timeout(&qproc->start_done,\r\nmsecs_to_jiffies(5000));\r\nif (ret == 0) {\r\ndev_err(qproc->dev, "start timed out\n");\r\nret = -ETIMEDOUT;\r\ngoto halt_axi_ports;\r\n}\r\nqproc->running = true;\r\nq6v5_clk_disable(qproc->dev, qproc->proxy_clks,\r\nqproc->proxy_clk_count);\r\nq6v5_regulator_disable(qproc, qproc->proxy_regs,\r\nqproc->proxy_reg_count);\r\nreturn 0;\r\nhalt_axi_ports:\r\nq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_q6);\r\nq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_modem);\r\nq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_nc);\r\nq6v5_clk_disable(qproc->dev, qproc->active_clks,\r\nqproc->active_clk_count);\r\nassert_reset:\r\nreset_control_assert(qproc->mss_restart);\r\ndisable_vdd:\r\nq6v5_regulator_disable(qproc, qproc->active_regs,\r\nqproc->active_reg_count);\r\ndisable_proxy_clk:\r\nq6v5_clk_disable(qproc->dev, qproc->proxy_clks,\r\nqproc->proxy_clk_count);\r\ndisable_proxy_reg:\r\nq6v5_regulator_disable(qproc, qproc->proxy_regs,\r\nqproc->proxy_reg_count);\r\nreturn ret;\r\n}\r\nstatic int q6v5_stop(struct rproc *rproc)\r\n{\r\nstruct q6v5 *qproc = (struct q6v5 *)rproc->priv;\r\nint ret;\r\nqproc->running = false;\r\nqcom_smem_state_update_bits(qproc->state,\r\nBIT(qproc->stop_bit), BIT(qproc->stop_bit));\r\nret = wait_for_completion_timeout(&qproc->stop_done,\r\nmsecs_to_jiffies(5000));\r\nif (ret == 0)\r\ndev_err(qproc->dev, "timed out on wait\n");\r\nqcom_smem_state_update_bits(qproc->state, BIT(qproc->stop_bit), 0);\r\nq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_q6);\r\nq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_modem);\r\nq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_nc);\r\nreset_control_assert(qproc->mss_restart);\r\nq6v5_clk_disable(qproc->dev, qproc->active_clks,\r\nqproc->active_clk_count);\r\nq6v5_regulator_disable(qproc, qproc->active_regs,\r\nqproc->active_reg_count);\r\nreturn 0;\r\n}\r\nstatic void *q6v5_da_to_va(struct rproc *rproc, u64 da, int len)\r\n{\r\nstruct q6v5 *qproc = rproc->priv;\r\nint offset;\r\noffset = da - qproc->mpss_reloc;\r\nif (offset < 0 || offset + len > qproc->mpss_size)\r\nreturn NULL;\r\nreturn qproc->mpss_region + offset;\r\n}\r\nstatic irqreturn_t q6v5_wdog_interrupt(int irq, void *dev)\r\n{\r\nstruct q6v5 *qproc = dev;\r\nsize_t len;\r\nchar *msg;\r\nif (!qproc->running) {\r\ncomplete(&qproc->stop_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, MPSS_CRASH_REASON_SMEM, &len);\r\nif (!IS_ERR(msg) && len > 0 && msg[0])\r\ndev_err(qproc->dev, "watchdog received: %s\n", msg);\r\nelse\r\ndev_err(qproc->dev, "watchdog without message\n");\r\nrproc_report_crash(qproc->rproc, RPROC_WATCHDOG);\r\nif (!IS_ERR(msg))\r\nmsg[0] = '\0';\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t q6v5_fatal_interrupt(int irq, void *dev)\r\n{\r\nstruct q6v5 *qproc = dev;\r\nsize_t len;\r\nchar *msg;\r\nmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, MPSS_CRASH_REASON_SMEM, &len);\r\nif (!IS_ERR(msg) && len > 0 && msg[0])\r\ndev_err(qproc->dev, "fatal error received: %s\n", msg);\r\nelse\r\ndev_err(qproc->dev, "fatal error without message\n");\r\nrproc_report_crash(qproc->rproc, RPROC_FATAL_ERROR);\r\nif (!IS_ERR(msg))\r\nmsg[0] = '\0';\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t q6v5_handover_interrupt(int irq, void *dev)\r\n{\r\nstruct q6v5 *qproc = dev;\r\ncomplete(&qproc->start_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t q6v5_stop_ack_interrupt(int irq, void *dev)\r\n{\r\nstruct q6v5 *qproc = dev;\r\ncomplete(&qproc->stop_done);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int q6v5_init_mem(struct q6v5 *qproc, struct platform_device *pdev)\r\n{\r\nstruct of_phandle_args args;\r\nstruct resource *res;\r\nint ret;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "qdsp6");\r\nqproc->reg_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(qproc->reg_base))\r\nreturn PTR_ERR(qproc->reg_base);\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "rmb");\r\nqproc->rmb_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(qproc->rmb_base))\r\nreturn PTR_ERR(qproc->rmb_base);\r\nret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\r\n"qcom,halt-regs", 3, 0, &args);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "failed to parse qcom,halt-regs\n");\r\nreturn -EINVAL;\r\n}\r\nqproc->halt_map = syscon_node_to_regmap(args.np);\r\nof_node_put(args.np);\r\nif (IS_ERR(qproc->halt_map))\r\nreturn PTR_ERR(qproc->halt_map);\r\nqproc->halt_q6 = args.args[0];\r\nqproc->halt_modem = args.args[1];\r\nqproc->halt_nc = args.args[2];\r\nreturn 0;\r\n}\r\nstatic int q6v5_init_clocks(struct device *dev, struct clk **clks,\r\nchar **clk_names)\r\n{\r\nint i;\r\nif (!clk_names)\r\nreturn 0;\r\nfor (i = 0; clk_names[i]; i++) {\r\nclks[i] = devm_clk_get(dev, clk_names[i]);\r\nif (IS_ERR(clks[i])) {\r\nint rc = PTR_ERR(clks[i]);\r\nif (rc != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to get %s clock\n",\r\nclk_names[i]);\r\nreturn rc;\r\n}\r\n}\r\nreturn i;\r\n}\r\nstatic int q6v5_init_reset(struct q6v5 *qproc)\r\n{\r\nqproc->mss_restart = devm_reset_control_get(qproc->dev, NULL);\r\nif (IS_ERR(qproc->mss_restart)) {\r\ndev_err(qproc->dev, "failed to acquire mss restart\n");\r\nreturn PTR_ERR(qproc->mss_restart);\r\n}\r\nreturn 0;\r\n}\r\nstatic int q6v5_request_irq(struct q6v5 *qproc,\r\nstruct platform_device *pdev,\r\nconst char *name,\r\nirq_handler_t thread_fn)\r\n{\r\nint ret;\r\nret = platform_get_irq_byname(pdev, name);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "no %s IRQ defined\n", name);\r\nreturn ret;\r\n}\r\nret = devm_request_threaded_irq(&pdev->dev, ret,\r\nNULL, thread_fn,\r\nIRQF_TRIGGER_RISING | IRQF_ONESHOT,\r\n"q6v5", qproc);\r\nif (ret)\r\ndev_err(&pdev->dev, "request %s IRQ failed\n", name);\r\nreturn ret;\r\n}\r\nstatic int q6v5_alloc_memory_region(struct q6v5 *qproc)\r\n{\r\nstruct device_node *child;\r\nstruct device_node *node;\r\nstruct resource r;\r\nint ret;\r\nchild = of_get_child_by_name(qproc->dev->of_node, "mba");\r\nnode = of_parse_phandle(child, "memory-region", 0);\r\nret = of_address_to_resource(node, 0, &r);\r\nif (ret) {\r\ndev_err(qproc->dev, "unable to resolve mba region\n");\r\nreturn ret;\r\n}\r\nqproc->mba_phys = r.start;\r\nqproc->mba_size = resource_size(&r);\r\nqproc->mba_region = devm_ioremap_wc(qproc->dev, qproc->mba_phys, qproc->mba_size);\r\nif (!qproc->mba_region) {\r\ndev_err(qproc->dev, "unable to map memory region: %pa+%zx\n",\r\n&r.start, qproc->mba_size);\r\nreturn -EBUSY;\r\n}\r\nchild = of_get_child_by_name(qproc->dev->of_node, "mpss");\r\nnode = of_parse_phandle(child, "memory-region", 0);\r\nret = of_address_to_resource(node, 0, &r);\r\nif (ret) {\r\ndev_err(qproc->dev, "unable to resolve mpss region\n");\r\nreturn ret;\r\n}\r\nqproc->mpss_phys = qproc->mpss_reloc = r.start;\r\nqproc->mpss_size = resource_size(&r);\r\nqproc->mpss_region = devm_ioremap_wc(qproc->dev, qproc->mpss_phys, qproc->mpss_size);\r\nif (!qproc->mpss_region) {\r\ndev_err(qproc->dev, "unable to map memory region: %pa+%zx\n",\r\n&r.start, qproc->mpss_size);\r\nreturn -EBUSY;\r\n}\r\nreturn 0;\r\n}\r\nstatic int q6v5_probe(struct platform_device *pdev)\r\n{\r\nconst struct rproc_hexagon_res *desc;\r\nstruct q6v5 *qproc;\r\nstruct rproc *rproc;\r\nint ret;\r\ndesc = of_device_get_match_data(&pdev->dev);\r\nif (!desc)\r\nreturn -EINVAL;\r\nrproc = rproc_alloc(&pdev->dev, pdev->name, &q6v5_ops,\r\ndesc->hexagon_mba_image, sizeof(*qproc));\r\nif (!rproc) {\r\ndev_err(&pdev->dev, "failed to allocate rproc\n");\r\nreturn -ENOMEM;\r\n}\r\nrproc->fw_ops = &q6v5_fw_ops;\r\nqproc = (struct q6v5 *)rproc->priv;\r\nqproc->dev = &pdev->dev;\r\nqproc->rproc = rproc;\r\nplatform_set_drvdata(pdev, qproc);\r\ninit_completion(&qproc->start_done);\r\ninit_completion(&qproc->stop_done);\r\nret = q6v5_init_mem(qproc, pdev);\r\nif (ret)\r\ngoto free_rproc;\r\nret = q6v5_alloc_memory_region(qproc);\r\nif (ret)\r\ngoto free_rproc;\r\nret = q6v5_init_clocks(&pdev->dev, qproc->proxy_clks,\r\ndesc->proxy_clk_names);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get proxy clocks.\n");\r\ngoto free_rproc;\r\n}\r\nqproc->proxy_clk_count = ret;\r\nret = q6v5_init_clocks(&pdev->dev, qproc->active_clks,\r\ndesc->active_clk_names);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get active clocks.\n");\r\ngoto free_rproc;\r\n}\r\nqproc->active_clk_count = ret;\r\nret = q6v5_regulator_init(&pdev->dev, qproc->proxy_regs,\r\ndesc->proxy_supply);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get proxy regulators.\n");\r\ngoto free_rproc;\r\n}\r\nqproc->proxy_reg_count = ret;\r\nret = q6v5_regulator_init(&pdev->dev, qproc->active_regs,\r\ndesc->active_supply);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to get active regulators.\n");\r\ngoto free_rproc;\r\n}\r\nqproc->active_reg_count = ret;\r\nret = q6v5_init_reset(qproc);\r\nif (ret)\r\ngoto free_rproc;\r\nret = q6v5_request_irq(qproc, pdev, "wdog", q6v5_wdog_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nret = q6v5_request_irq(qproc, pdev, "fatal", q6v5_fatal_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nret = q6v5_request_irq(qproc, pdev, "handover", q6v5_handover_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nret = q6v5_request_irq(qproc, pdev, "stop-ack", q6v5_stop_ack_interrupt);\r\nif (ret < 0)\r\ngoto free_rproc;\r\nqproc->state = qcom_smem_state_get(&pdev->dev, "stop", &qproc->stop_bit);\r\nif (IS_ERR(qproc->state)) {\r\nret = PTR_ERR(qproc->state);\r\ngoto free_rproc;\r\n}\r\nqcom_add_smd_subdev(rproc, &qproc->smd_subdev);\r\nret = rproc_add(rproc);\r\nif (ret)\r\ngoto free_rproc;\r\nreturn 0;\r\nfree_rproc:\r\nrproc_free(rproc);\r\nreturn ret;\r\n}\r\nstatic int q6v5_remove(struct platform_device *pdev)\r\n{\r\nstruct q6v5 *qproc = platform_get_drvdata(pdev);\r\nrproc_del(qproc->rproc);\r\nqcom_remove_smd_subdev(qproc->rproc, &qproc->smd_subdev);\r\nrproc_free(qproc->rproc);\r\nreturn 0;\r\n}
