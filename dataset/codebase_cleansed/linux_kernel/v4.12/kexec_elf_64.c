static inline bool elf_is_elf_file(const struct elfhdr *ehdr)\r\n{\r\nreturn memcmp(ehdr->e_ident, ELFMAG, SELFMAG) == 0;\r\n}\r\nstatic uint64_t elf64_to_cpu(const struct elfhdr *ehdr, uint64_t value)\r\n{\r\nif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\r\nvalue = le64_to_cpu(value);\r\nelse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\r\nvalue = be64_to_cpu(value);\r\nreturn value;\r\n}\r\nstatic uint16_t elf16_to_cpu(const struct elfhdr *ehdr, uint16_t value)\r\n{\r\nif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\r\nvalue = le16_to_cpu(value);\r\nelse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\r\nvalue = be16_to_cpu(value);\r\nreturn value;\r\n}\r\nstatic uint32_t elf32_to_cpu(const struct elfhdr *ehdr, uint32_t value)\r\n{\r\nif (ehdr->e_ident[EI_DATA] == ELFDATA2LSB)\r\nvalue = le32_to_cpu(value);\r\nelse if (ehdr->e_ident[EI_DATA] == ELFDATA2MSB)\r\nvalue = be32_to_cpu(value);\r\nreturn value;\r\n}\r\nstatic bool elf_is_ehdr_sane(const struct elfhdr *ehdr, size_t buf_len)\r\n{\r\nif (ehdr->e_phnum > 0 && ehdr->e_phentsize != sizeof(struct elf_phdr)) {\r\npr_debug("Bad program header size.\n");\r\nreturn false;\r\n} else if (ehdr->e_shnum > 0 &&\r\nehdr->e_shentsize != sizeof(struct elf_shdr)) {\r\npr_debug("Bad section header size.\n");\r\nreturn false;\r\n} else if (ehdr->e_ident[EI_VERSION] != EV_CURRENT ||\r\nehdr->e_version != EV_CURRENT) {\r\npr_debug("Unknown ELF version.\n");\r\nreturn false;\r\n}\r\nif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\r\nsize_t phdr_size;\r\nphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\r\nif (ehdr->e_phoff + phdr_size < ehdr->e_phoff) {\r\npr_debug("Program headers at invalid location.\n");\r\nreturn false;\r\n} else if (ehdr->e_phoff + phdr_size > buf_len) {\r\npr_debug("Program headers truncated.\n");\r\nreturn false;\r\n}\r\n}\r\nif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\r\nsize_t shdr_size;\r\nshdr_size = sizeof(struct elf_shdr) * ehdr->e_shnum;\r\nif (ehdr->e_shoff + shdr_size < ehdr->e_shoff) {\r\npr_debug("Section headers at invalid location.\n");\r\nreturn false;\r\n} else if (ehdr->e_shoff + shdr_size > buf_len) {\r\npr_debug("Section headers truncated.\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int elf_read_ehdr(const char *buf, size_t len, struct elfhdr *ehdr)\r\n{\r\nstruct elfhdr *buf_ehdr;\r\nif (len < sizeof(*buf_ehdr)) {\r\npr_debug("Buffer is too small to hold ELF header.\n");\r\nreturn -ENOEXEC;\r\n}\r\nmemset(ehdr, 0, sizeof(*ehdr));\r\nmemcpy(ehdr->e_ident, buf, sizeof(ehdr->e_ident));\r\nif (!elf_is_elf_file(ehdr)) {\r\npr_debug("No ELF header magic.\n");\r\nreturn -ENOEXEC;\r\n}\r\nif (ehdr->e_ident[EI_CLASS] != ELF_CLASS) {\r\npr_debug("Not a supported ELF class.\n");\r\nreturn -ENOEXEC;\r\n} else if (ehdr->e_ident[EI_DATA] != ELFDATA2LSB &&\r\nehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\r\npr_debug("Not a supported ELF data format.\n");\r\nreturn -ENOEXEC;\r\n}\r\nbuf_ehdr = (struct elfhdr *) buf;\r\nif (elf16_to_cpu(ehdr, buf_ehdr->e_ehsize) != sizeof(*buf_ehdr)) {\r\npr_debug("Bad ELF header size.\n");\r\nreturn -ENOEXEC;\r\n}\r\nehdr->e_type = elf16_to_cpu(ehdr, buf_ehdr->e_type);\r\nehdr->e_machine = elf16_to_cpu(ehdr, buf_ehdr->e_machine);\r\nehdr->e_version = elf32_to_cpu(ehdr, buf_ehdr->e_version);\r\nehdr->e_entry = elf_addr_to_cpu(ehdr, buf_ehdr->e_entry);\r\nehdr->e_phoff = elf_addr_to_cpu(ehdr, buf_ehdr->e_phoff);\r\nehdr->e_shoff = elf_addr_to_cpu(ehdr, buf_ehdr->e_shoff);\r\nehdr->e_flags = elf32_to_cpu(ehdr, buf_ehdr->e_flags);\r\nehdr->e_phentsize = elf16_to_cpu(ehdr, buf_ehdr->e_phentsize);\r\nehdr->e_phnum = elf16_to_cpu(ehdr, buf_ehdr->e_phnum);\r\nehdr->e_shentsize = elf16_to_cpu(ehdr, buf_ehdr->e_shentsize);\r\nehdr->e_shnum = elf16_to_cpu(ehdr, buf_ehdr->e_shnum);\r\nehdr->e_shstrndx = elf16_to_cpu(ehdr, buf_ehdr->e_shstrndx);\r\nreturn elf_is_ehdr_sane(ehdr, len) ? 0 : -ENOEXEC;\r\n}\r\nstatic bool elf_is_phdr_sane(const struct elf_phdr *phdr, size_t buf_len)\r\n{\r\nif (phdr->p_offset + phdr->p_filesz < phdr->p_offset) {\r\npr_debug("ELF segment location wraps around.\n");\r\nreturn false;\r\n} else if (phdr->p_offset + phdr->p_filesz > buf_len) {\r\npr_debug("ELF segment not in file.\n");\r\nreturn false;\r\n} else if (phdr->p_paddr + phdr->p_memsz < phdr->p_paddr) {\r\npr_debug("ELF segment address wraps around.\n");\r\nreturn false;\r\n}\r\nreturn true;\r\n}\r\nstatic int elf_read_phdr(const char *buf, size_t len, struct elf_info *elf_info,\r\nint idx)\r\n{\r\nstruct elf_phdr *phdr = (struct elf_phdr *) &elf_info->proghdrs[idx];\r\nconst char *pbuf;\r\nstruct elf_phdr *buf_phdr;\r\npbuf = buf + elf_info->ehdr->e_phoff + (idx * sizeof(*buf_phdr));\r\nbuf_phdr = (struct elf_phdr *) pbuf;\r\nphdr->p_type = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_type);\r\nphdr->p_offset = elf_addr_to_cpu(elf_info->ehdr, buf_phdr->p_offset);\r\nphdr->p_paddr = elf_addr_to_cpu(elf_info->ehdr, buf_phdr->p_paddr);\r\nphdr->p_vaddr = elf_addr_to_cpu(elf_info->ehdr, buf_phdr->p_vaddr);\r\nphdr->p_flags = elf32_to_cpu(elf_info->ehdr, buf_phdr->p_flags);\r\nphdr->p_filesz = elf_addr_to_cpu(elf_info->ehdr, buf_phdr->p_filesz);\r\nphdr->p_memsz = elf_addr_to_cpu(elf_info->ehdr, buf_phdr->p_memsz);\r\nphdr->p_align = elf_addr_to_cpu(elf_info->ehdr, buf_phdr->p_align);\r\nreturn elf_is_phdr_sane(phdr, len) ? 0 : -ENOEXEC;\r\n}\r\nstatic int elf_read_phdrs(const char *buf, size_t len,\r\nstruct elf_info *elf_info)\r\n{\r\nsize_t phdr_size, i;\r\nconst struct elfhdr *ehdr = elf_info->ehdr;\r\nphdr_size = sizeof(struct elf_phdr) * ehdr->e_phnum;\r\nelf_info->proghdrs = kzalloc(phdr_size, GFP_KERNEL);\r\nif (!elf_info->proghdrs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nint ret;\r\nret = elf_read_phdr(buf, len, elf_info, i);\r\nif (ret) {\r\nkfree(elf_info->proghdrs);\r\nelf_info->proghdrs = NULL;\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic bool elf_is_shdr_sane(const struct elf_shdr *shdr, size_t buf_len)\r\n{\r\nbool size_ok;\r\nif (shdr->sh_type == SHT_NULL)\r\nreturn true;\r\nswitch (shdr->sh_type) {\r\ncase SHT_SYMTAB:\r\nsize_ok = shdr->sh_entsize == sizeof(Elf_Sym);\r\nbreak;\r\ncase SHT_RELA:\r\nsize_ok = shdr->sh_entsize == sizeof(Elf_Rela);\r\nbreak;\r\ncase SHT_DYNAMIC:\r\nsize_ok = shdr->sh_entsize == sizeof(Elf_Dyn);\r\nbreak;\r\ncase SHT_REL:\r\nsize_ok = shdr->sh_entsize == sizeof(Elf_Rel);\r\nbreak;\r\ncase SHT_NOTE:\r\ncase SHT_PROGBITS:\r\ncase SHT_HASH:\r\ncase SHT_NOBITS:\r\ndefault:\r\nsize_ok = true;\r\nbreak;\r\n}\r\nif (!size_ok) {\r\npr_debug("ELF section with wrong entry size.\n");\r\nreturn false;\r\n} else if (shdr->sh_addr + shdr->sh_size < shdr->sh_addr) {\r\npr_debug("ELF section address wraps around.\n");\r\nreturn false;\r\n}\r\nif (shdr->sh_type != SHT_NOBITS) {\r\nif (shdr->sh_offset + shdr->sh_size < shdr->sh_offset) {\r\npr_debug("ELF section location wraps around.\n");\r\nreturn false;\r\n} else if (shdr->sh_offset + shdr->sh_size > buf_len) {\r\npr_debug("ELF section not in file.\n");\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstatic int elf_read_shdr(const char *buf, size_t len, struct elf_info *elf_info,\r\nint idx)\r\n{\r\nstruct elf_shdr *shdr = &elf_info->sechdrs[idx];\r\nconst struct elfhdr *ehdr = elf_info->ehdr;\r\nconst char *sbuf;\r\nstruct elf_shdr *buf_shdr;\r\nsbuf = buf + ehdr->e_shoff + idx * sizeof(*buf_shdr);\r\nbuf_shdr = (struct elf_shdr *) sbuf;\r\nshdr->sh_name = elf32_to_cpu(ehdr, buf_shdr->sh_name);\r\nshdr->sh_type = elf32_to_cpu(ehdr, buf_shdr->sh_type);\r\nshdr->sh_addr = elf_addr_to_cpu(ehdr, buf_shdr->sh_addr);\r\nshdr->sh_offset = elf_addr_to_cpu(ehdr, buf_shdr->sh_offset);\r\nshdr->sh_link = elf32_to_cpu(ehdr, buf_shdr->sh_link);\r\nshdr->sh_info = elf32_to_cpu(ehdr, buf_shdr->sh_info);\r\nshdr->sh_flags = elf_addr_to_cpu(ehdr, buf_shdr->sh_flags);\r\nshdr->sh_size = elf_addr_to_cpu(ehdr, buf_shdr->sh_size);\r\nshdr->sh_addralign = elf_addr_to_cpu(ehdr, buf_shdr->sh_addralign);\r\nshdr->sh_entsize = elf_addr_to_cpu(ehdr, buf_shdr->sh_entsize);\r\nreturn elf_is_shdr_sane(shdr, len) ? 0 : -ENOEXEC;\r\n}\r\nstatic int elf_read_shdrs(const char *buf, size_t len,\r\nstruct elf_info *elf_info)\r\n{\r\nsize_t shdr_size, i;\r\nshdr_size = sizeof(struct elf_shdr) * elf_info->ehdr->e_shnum;\r\nelf_info->sechdrs = kzalloc(shdr_size, GFP_KERNEL);\r\nif (!elf_info->sechdrs)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < elf_info->ehdr->e_shnum; i++) {\r\nint ret;\r\nret = elf_read_shdr(buf, len, elf_info, i);\r\nif (ret) {\r\nkfree(elf_info->sechdrs);\r\nelf_info->sechdrs = NULL;\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint elf_read_from_buffer(const char *buf, size_t len, struct elfhdr *ehdr,\r\nstruct elf_info *elf_info)\r\n{\r\nint ret;\r\nret = elf_read_ehdr(buf, len, ehdr);\r\nif (ret)\r\nreturn ret;\r\nelf_info->buffer = buf;\r\nelf_info->ehdr = ehdr;\r\nif (ehdr->e_phoff > 0 && ehdr->e_phnum > 0) {\r\nret = elf_read_phdrs(buf, len, elf_info);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (ehdr->e_shoff > 0 && ehdr->e_shnum > 0) {\r\nret = elf_read_shdrs(buf, len, elf_info);\r\nif (ret) {\r\nkfree(elf_info->proghdrs);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nvoid elf_free_info(struct elf_info *elf_info)\r\n{\r\nkfree(elf_info->proghdrs);\r\nkfree(elf_info->sechdrs);\r\nmemset(elf_info, 0, sizeof(*elf_info));\r\n}\r\nstatic int build_elf_exec_info(const char *buf, size_t len, struct elfhdr *ehdr,\r\nstruct elf_info *elf_info)\r\n{\r\nint i;\r\nint ret;\r\nret = elf_read_from_buffer(buf, len, ehdr, elf_info);\r\nif (ret)\r\nreturn ret;\r\nif (ehdr->e_type != ET_EXEC && ehdr->e_type != ET_DYN) {\r\npr_err("Not an ELF executable.\n");\r\ngoto error;\r\n} else if (!elf_info->proghdrs) {\r\npr_err("No ELF program header.\n");\r\ngoto error;\r\n}\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nif (elf_info->proghdrs[i].p_type == PT_INTERP) {\r\npr_err("Requires an ELF interpreter.\n");\r\ngoto error;\r\n}\r\n}\r\nreturn 0;\r\nerror:\r\nelf_free_info(elf_info);\r\nreturn -ENOEXEC;\r\n}\r\nstatic int elf64_probe(const char *buf, unsigned long len)\r\n{\r\nstruct elfhdr ehdr;\r\nstruct elf_info elf_info;\r\nint ret;\r\nret = build_elf_exec_info(buf, len, &ehdr, &elf_info);\r\nif (ret)\r\nreturn ret;\r\nelf_free_info(&elf_info);\r\nreturn elf_check_arch(&ehdr) ? 0 : -ENOEXEC;\r\n}\r\nstatic int elf_exec_load(struct kimage *image, struct elfhdr *ehdr,\r\nstruct elf_info *elf_info,\r\nunsigned long *lowest_load_addr)\r\n{\r\nunsigned long base = 0, lowest_addr = UINT_MAX;\r\nint ret;\r\nsize_t i;\r\nstruct kexec_buf kbuf = { .image = image, .buf_max = ppc64_rma_size,\r\n.top_down = false };\r\nfor (i = 0; i < ehdr->e_phnum; i++) {\r\nunsigned long load_addr;\r\nsize_t size;\r\nconst struct elf_phdr *phdr;\r\nphdr = &elf_info->proghdrs[i];\r\nif (phdr->p_type != PT_LOAD)\r\ncontinue;\r\nsize = phdr->p_filesz;\r\nif (size > phdr->p_memsz)\r\nsize = phdr->p_memsz;\r\nkbuf.buffer = (void *) elf_info->buffer + phdr->p_offset;\r\nkbuf.bufsz = size;\r\nkbuf.memsz = phdr->p_memsz;\r\nkbuf.buf_align = phdr->p_align;\r\nkbuf.buf_min = phdr->p_paddr + base;\r\nret = kexec_add_buffer(&kbuf);\r\nif (ret)\r\ngoto out;\r\nload_addr = kbuf.mem;\r\nif (load_addr < lowest_addr)\r\nlowest_addr = load_addr;\r\n}\r\nehdr->e_entry += base;\r\n*lowest_load_addr = lowest_addr;\r\nret = 0;\r\nout:\r\nreturn ret;\r\n}\r\nstatic void *elf64_load(struct kimage *image, char *kernel_buf,\r\nunsigned long kernel_len, char *initrd,\r\nunsigned long initrd_len, char *cmdline,\r\nunsigned long cmdline_len)\r\n{\r\nint ret;\r\nunsigned int fdt_size;\r\nunsigned long kernel_load_addr, purgatory_load_addr;\r\nunsigned long initrd_load_addr = 0, fdt_load_addr;\r\nvoid *fdt;\r\nconst void *slave_code;\r\nstruct elfhdr ehdr;\r\nstruct elf_info elf_info;\r\nstruct kexec_buf kbuf = { .image = image, .buf_min = 0,\r\n.buf_max = ppc64_rma_size };\r\nret = build_elf_exec_info(kernel_buf, kernel_len, &ehdr, &elf_info);\r\nif (ret)\r\ngoto out;\r\nret = elf_exec_load(image, &ehdr, &elf_info, &kernel_load_addr);\r\nif (ret)\r\ngoto out;\r\npr_debug("Loaded the kernel at 0x%lx\n", kernel_load_addr);\r\nret = kexec_load_purgatory(image, 0, ppc64_rma_size, true,\r\n&purgatory_load_addr);\r\nif (ret) {\r\npr_err("Loading purgatory failed.\n");\r\ngoto out;\r\n}\r\npr_debug("Loaded purgatory at 0x%lx\n", purgatory_load_addr);\r\nif (initrd != NULL) {\r\nkbuf.buffer = initrd;\r\nkbuf.bufsz = kbuf.memsz = initrd_len;\r\nkbuf.buf_align = PAGE_SIZE;\r\nkbuf.top_down = false;\r\nret = kexec_add_buffer(&kbuf);\r\nif (ret)\r\ngoto out;\r\ninitrd_load_addr = kbuf.mem;\r\npr_debug("Loaded initrd at 0x%lx\n", initrd_load_addr);\r\n}\r\nfdt_size = fdt_totalsize(initial_boot_params) * 2;\r\nfdt = kmalloc(fdt_size, GFP_KERNEL);\r\nif (!fdt) {\r\npr_err("Not enough memory for the device tree.\n");\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nret = fdt_open_into(initial_boot_params, fdt, fdt_size);\r\nif (ret < 0) {\r\npr_err("Error setting up the new device tree.\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = setup_new_fdt(image, fdt, initrd_load_addr, initrd_len, cmdline);\r\nif (ret)\r\ngoto out;\r\nfdt_pack(fdt);\r\nkbuf.buffer = fdt;\r\nkbuf.bufsz = kbuf.memsz = fdt_size;\r\nkbuf.buf_align = PAGE_SIZE;\r\nkbuf.top_down = true;\r\nret = kexec_add_buffer(&kbuf);\r\nif (ret)\r\ngoto out;\r\nfdt_load_addr = kbuf.mem;\r\npr_debug("Loaded device tree at 0x%lx\n", fdt_load_addr);\r\nslave_code = elf_info.buffer + elf_info.proghdrs[0].p_offset;\r\nret = setup_purgatory(image, slave_code, fdt, kernel_load_addr,\r\nfdt_load_addr);\r\nif (ret)\r\npr_err("Error setting up the purgatory.\n");\r\nout:\r\nelf_free_info(&elf_info);\r\nreturn ret ? ERR_PTR(ret) : fdt;\r\n}
