static int netlbl_mgmt_add_common(struct genl_info *info,\r\nstruct netlbl_audit *audit_info)\r\n{\r\nint ret_val = -EINVAL;\r\nstruct netlbl_domaddr_map *addrmap = NULL;\r\nstruct cipso_v4_doi *cipsov4 = NULL;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct calipso_doi *calipso = NULL;\r\n#endif\r\nu32 tmp_val;\r\nstruct netlbl_dom_map *entry = kzalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->def.type = nla_get_u32(info->attrs[NLBL_MGMT_A_PROTOCOL]);\r\nif (info->attrs[NLBL_MGMT_A_DOMAIN]) {\r\nsize_t tmp_size = nla_len(info->attrs[NLBL_MGMT_A_DOMAIN]);\r\nentry->domain = kmalloc(tmp_size, GFP_KERNEL);\r\nif (entry->domain == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_free_entry;\r\n}\r\nnla_strlcpy(entry->domain,\r\ninfo->attrs[NLBL_MGMT_A_DOMAIN], tmp_size);\r\n}\r\nswitch (entry->def.type) {\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nif (info->attrs[NLBL_MGMT_A_FAMILY])\r\nentry->family =\r\nnla_get_u16(info->attrs[NLBL_MGMT_A_FAMILY]);\r\nelse\r\nentry->family = AF_UNSPEC;\r\nbreak;\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nif (!info->attrs[NLBL_MGMT_A_CV4DOI])\r\ngoto add_free_domain;\r\ntmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CV4DOI]);\r\ncipsov4 = cipso_v4_doi_getdef(tmp_val);\r\nif (cipsov4 == NULL)\r\ngoto add_free_domain;\r\nentry->family = AF_INET;\r\nentry->def.cipso = cipsov4;\r\nbreak;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncase NETLBL_NLTYPE_CALIPSO:\r\nif (!info->attrs[NLBL_MGMT_A_CLPDOI])\r\ngoto add_free_domain;\r\ntmp_val = nla_get_u32(info->attrs[NLBL_MGMT_A_CLPDOI]);\r\ncalipso = calipso_doi_getdef(tmp_val);\r\nif (calipso == NULL)\r\ngoto add_free_domain;\r\nentry->family = AF_INET6;\r\nentry->def.calipso = calipso;\r\nbreak;\r\n#endif\r\ndefault:\r\ngoto add_free_domain;\r\n}\r\nif ((entry->family == AF_INET && info->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\r\n(entry->family == AF_INET6 && info->attrs[NLBL_MGMT_A_IPV4ADDR]))\r\ngoto add_doi_put_def;\r\nif (info->attrs[NLBL_MGMT_A_IPV4ADDR]) {\r\nstruct in_addr *addr;\r\nstruct in_addr *mask;\r\nstruct netlbl_domaddr4_map *map;\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_KERNEL);\r\nif (addrmap == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_doi_put_def;\r\n}\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV4ADDR]) !=\r\nsizeof(struct in_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_free_addrmap;\r\n}\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV4MASK]) !=\r\nsizeof(struct in_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_free_addrmap;\r\n}\r\naddr = nla_data(info->attrs[NLBL_MGMT_A_IPV4ADDR]);\r\nmask = nla_data(info->attrs[NLBL_MGMT_A_IPV4MASK]);\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (map == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_free_addrmap;\r\n}\r\nmap->list.addr = addr->s_addr & mask->s_addr;\r\nmap->list.mask = mask->s_addr;\r\nmap->list.valid = 1;\r\nmap->def.type = entry->def.type;\r\nif (cipsov4)\r\nmap->def.cipso = cipsov4;\r\nret_val = netlbl_af4list_add(&map->list, &addrmap->list4);\r\nif (ret_val != 0) {\r\nkfree(map);\r\ngoto add_free_addrmap;\r\n}\r\nentry->family = AF_INET;\r\nentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\r\nentry->def.addrsel = addrmap;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\n} else if (info->attrs[NLBL_MGMT_A_IPV6ADDR]) {\r\nstruct in6_addr *addr;\r\nstruct in6_addr *mask;\r\nstruct netlbl_domaddr6_map *map;\r\naddrmap = kzalloc(sizeof(*addrmap), GFP_KERNEL);\r\nif (addrmap == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_doi_put_def;\r\n}\r\nINIT_LIST_HEAD(&addrmap->list4);\r\nINIT_LIST_HEAD(&addrmap->list6);\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV6ADDR]) !=\r\nsizeof(struct in6_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_free_addrmap;\r\n}\r\nif (nla_len(info->attrs[NLBL_MGMT_A_IPV6MASK]) !=\r\nsizeof(struct in6_addr)) {\r\nret_val = -EINVAL;\r\ngoto add_free_addrmap;\r\n}\r\naddr = nla_data(info->attrs[NLBL_MGMT_A_IPV6ADDR]);\r\nmask = nla_data(info->attrs[NLBL_MGMT_A_IPV6MASK]);\r\nmap = kzalloc(sizeof(*map), GFP_KERNEL);\r\nif (map == NULL) {\r\nret_val = -ENOMEM;\r\ngoto add_free_addrmap;\r\n}\r\nmap->list.addr = *addr;\r\nmap->list.addr.s6_addr32[0] &= mask->s6_addr32[0];\r\nmap->list.addr.s6_addr32[1] &= mask->s6_addr32[1];\r\nmap->list.addr.s6_addr32[2] &= mask->s6_addr32[2];\r\nmap->list.addr.s6_addr32[3] &= mask->s6_addr32[3];\r\nmap->list.mask = *mask;\r\nmap->list.valid = 1;\r\nmap->def.type = entry->def.type;\r\nif (calipso)\r\nmap->def.calipso = calipso;\r\nret_val = netlbl_af6list_add(&map->list, &addrmap->list6);\r\nif (ret_val != 0) {\r\nkfree(map);\r\ngoto add_free_addrmap;\r\n}\r\nentry->family = AF_INET6;\r\nentry->def.type = NETLBL_NLTYPE_ADDRSELECT;\r\nentry->def.addrsel = addrmap;\r\n#endif\r\n}\r\nret_val = netlbl_domhsh_add(entry, audit_info);\r\nif (ret_val != 0)\r\ngoto add_free_addrmap;\r\nreturn 0;\r\nadd_free_addrmap:\r\nkfree(addrmap);\r\nadd_doi_put_def:\r\ncipso_v4_doi_putdef(cipsov4);\r\n#if IS_ENABLED(CONFIG_IPV6)\r\ncalipso_doi_putdef(calipso);\r\n#endif\r\nadd_free_domain:\r\nkfree(entry->domain);\r\nadd_free_entry:\r\nkfree(entry);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_listentry(struct sk_buff *skb,\r\nstruct netlbl_dom_map *entry)\r\n{\r\nint ret_val = 0;\r\nstruct nlattr *nla_a;\r\nstruct nlattr *nla_b;\r\nstruct netlbl_af4list *iter4;\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nstruct netlbl_af6list *iter6;\r\n#endif\r\nif (entry->domain != NULL) {\r\nret_val = nla_put_string(skb,\r\nNLBL_MGMT_A_DOMAIN, entry->domain);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\n}\r\nret_val = nla_put_u16(skb, NLBL_MGMT_A_FAMILY, entry->family);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nswitch (entry->def.type) {\r\ncase NETLBL_NLTYPE_ADDRSELECT:\r\nnla_a = nla_nest_start(skb, NLBL_MGMT_A_SELECTORLIST);\r\nif (nla_a == NULL)\r\nreturn -ENOMEM;\r\nnetlbl_af4list_foreach_rcu(iter4, &entry->def.addrsel->list4) {\r\nstruct netlbl_domaddr4_map *map4;\r\nstruct in_addr addr_struct;\r\nnla_b = nla_nest_start(skb, NLBL_MGMT_A_ADDRSELECTOR);\r\nif (nla_b == NULL)\r\nreturn -ENOMEM;\r\naddr_struct.s_addr = iter4->addr;\r\nret_val = nla_put_in_addr(skb, NLBL_MGMT_A_IPV4ADDR,\r\naddr_struct.s_addr);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\naddr_struct.s_addr = iter4->mask;\r\nret_val = nla_put_in_addr(skb, NLBL_MGMT_A_IPV4MASK,\r\naddr_struct.s_addr);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nmap4 = netlbl_domhsh_addr4_entry(iter4);\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nmap4->def.type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nswitch (map4->def.type) {\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_CV4DOI,\r\nmap4->def.cipso->doi);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nbreak;\r\n}\r\nnla_nest_end(skb, nla_b);\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nnetlbl_af6list_foreach_rcu(iter6, &entry->def.addrsel->list6) {\r\nstruct netlbl_domaddr6_map *map6;\r\nnla_b = nla_nest_start(skb, NLBL_MGMT_A_ADDRSELECTOR);\r\nif (nla_b == NULL)\r\nreturn -ENOMEM;\r\nret_val = nla_put_in6_addr(skb, NLBL_MGMT_A_IPV6ADDR,\r\n&iter6->addr);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = nla_put_in6_addr(skb, NLBL_MGMT_A_IPV6MASK,\r\n&iter6->mask);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nmap6 = netlbl_domhsh_addr6_entry(iter6);\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nmap6->def.type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nswitch (map6->def.type) {\r\ncase NETLBL_NLTYPE_CALIPSO:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_CLPDOI,\r\nmap6->def.calipso->doi);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nbreak;\r\n}\r\nnla_nest_end(skb, nla_b);\r\n}\r\n#endif\r\nnla_nest_end(skb, nla_a);\r\nbreak;\r\ncase NETLBL_NLTYPE_UNLABELED:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nentry->def.type);\r\nbreak;\r\ncase NETLBL_NLTYPE_CIPSOV4:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nentry->def.type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_CV4DOI,\r\nentry->def.cipso->doi);\r\nbreak;\r\ncase NETLBL_NLTYPE_CALIPSO:\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL,\r\nentry->def.type);\r\nif (ret_val != 0)\r\nreturn ret_val;\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_CLPDOI,\r\nentry->def.calipso->doi);\r\nbreak;\r\n}\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_add(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct netlbl_audit audit_info;\r\nif ((!info->attrs[NLBL_MGMT_A_DOMAIN]) ||\r\n(!info->attrs[NLBL_MGMT_A_PROTOCOL]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4ADDR] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6MASK]) ||\r\n((info->attrs[NLBL_MGMT_A_IPV4ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] != NULL)) ||\r\n((info->attrs[NLBL_MGMT_A_IPV6ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV6MASK] != NULL)))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nreturn netlbl_mgmt_add_common(info, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_remove(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nchar *domain;\r\nstruct netlbl_audit audit_info;\r\nif (!info->attrs[NLBL_MGMT_A_DOMAIN])\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\ndomain = nla_data(info->attrs[NLBL_MGMT_A_DOMAIN]);\r\nreturn netlbl_domhsh_remove(domain, AF_UNSPEC, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_listall_cb(struct netlbl_dom_map *entry, void *arg)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct netlbl_domhsh_walk_arg *cb_arg = arg;\r\nvoid *data;\r\ndata = genlmsg_put(cb_arg->skb, NETLINK_CB(cb_arg->nl_cb->skb).portid,\r\ncb_arg->seq, &netlbl_mgmt_gnl_family,\r\nNLM_F_MULTI, NLBL_MGMT_C_LISTALL);\r\nif (data == NULL)\r\ngoto listall_cb_failure;\r\nret_val = netlbl_mgmt_listentry(cb_arg->skb, entry);\r\nif (ret_val != 0)\r\ngoto listall_cb_failure;\r\ncb_arg->seq++;\r\ngenlmsg_end(cb_arg->skb, data);\r\nreturn 0;\r\nlistall_cb_failure:\r\ngenlmsg_cancel(cb_arg->skb, data);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_listall(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nstruct netlbl_domhsh_walk_arg cb_arg;\r\nu32 skip_bkt = cb->args[0];\r\nu32 skip_chain = cb->args[1];\r\ncb_arg.nl_cb = cb;\r\ncb_arg.skb = skb;\r\ncb_arg.seq = cb->nlh->nlmsg_seq;\r\nnetlbl_domhsh_walk(&skip_bkt,\r\n&skip_chain,\r\nnetlbl_mgmt_listall_cb,\r\n&cb_arg);\r\ncb->args[0] = skip_bkt;\r\ncb->args[1] = skip_chain;\r\nreturn skb->len;\r\n}\r\nstatic int netlbl_mgmt_adddef(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct netlbl_audit audit_info;\r\nif ((!info->attrs[NLBL_MGMT_A_PROTOCOL]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4ADDR] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6ADDR]) ||\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] &&\r\ninfo->attrs[NLBL_MGMT_A_IPV6MASK]) ||\r\n((info->attrs[NLBL_MGMT_A_IPV4ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV4MASK] != NULL)) ||\r\n((info->attrs[NLBL_MGMT_A_IPV6ADDR] != NULL) ^\r\n(info->attrs[NLBL_MGMT_A_IPV6MASK] != NULL)))\r\nreturn -EINVAL;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nreturn netlbl_mgmt_add_common(info, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_removedef(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nstruct netlbl_audit audit_info;\r\nnetlbl_netlink_auditinfo(skb, &audit_info);\r\nreturn netlbl_domhsh_remove_default(AF_UNSPEC, &audit_info);\r\n}\r\nstatic int netlbl_mgmt_listdef(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct sk_buff *ans_skb = NULL;\r\nvoid *data;\r\nstruct netlbl_dom_map *entry;\r\nu16 family;\r\nif (info->attrs[NLBL_MGMT_A_FAMILY])\r\nfamily = nla_get_u16(info->attrs[NLBL_MGMT_A_FAMILY]);\r\nelse\r\nfamily = AF_INET;\r\nans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (ans_skb == NULL)\r\nreturn -ENOMEM;\r\ndata = genlmsg_put_reply(ans_skb, info, &netlbl_mgmt_gnl_family,\r\n0, NLBL_MGMT_C_LISTDEF);\r\nif (data == NULL)\r\ngoto listdef_failure;\r\nrcu_read_lock();\r\nentry = netlbl_domhsh_getentry(NULL, family);\r\nif (entry == NULL) {\r\nret_val = -ENOENT;\r\ngoto listdef_failure_lock;\r\n}\r\nret_val = netlbl_mgmt_listentry(ans_skb, entry);\r\nrcu_read_unlock();\r\nif (ret_val != 0)\r\ngoto listdef_failure;\r\ngenlmsg_end(ans_skb, data);\r\nreturn genlmsg_reply(ans_skb, info);\r\nlistdef_failure_lock:\r\nrcu_read_unlock();\r\nlistdef_failure:\r\nkfree_skb(ans_skb);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_protocols_cb(struct sk_buff *skb,\r\nstruct netlink_callback *cb,\r\nu32 protocol)\r\n{\r\nint ret_val = -ENOMEM;\r\nvoid *data;\r\ndata = genlmsg_put(skb, NETLINK_CB(cb->skb).portid, cb->nlh->nlmsg_seq,\r\n&netlbl_mgmt_gnl_family, NLM_F_MULTI,\r\nNLBL_MGMT_C_PROTOCOLS);\r\nif (data == NULL)\r\ngoto protocols_cb_failure;\r\nret_val = nla_put_u32(skb, NLBL_MGMT_A_PROTOCOL, protocol);\r\nif (ret_val != 0)\r\ngoto protocols_cb_failure;\r\ngenlmsg_end(skb, data);\r\nreturn 0;\r\nprotocols_cb_failure:\r\ngenlmsg_cancel(skb, data);\r\nreturn ret_val;\r\n}\r\nstatic int netlbl_mgmt_protocols(struct sk_buff *skb,\r\nstruct netlink_callback *cb)\r\n{\r\nu32 protos_sent = cb->args[0];\r\nif (protos_sent == 0) {\r\nif (netlbl_mgmt_protocols_cb(skb,\r\ncb,\r\nNETLBL_NLTYPE_UNLABELED) < 0)\r\ngoto protocols_return;\r\nprotos_sent++;\r\n}\r\nif (protos_sent == 1) {\r\nif (netlbl_mgmt_protocols_cb(skb,\r\ncb,\r\nNETLBL_NLTYPE_CIPSOV4) < 0)\r\ngoto protocols_return;\r\nprotos_sent++;\r\n}\r\n#if IS_ENABLED(CONFIG_IPV6)\r\nif (protos_sent == 2) {\r\nif (netlbl_mgmt_protocols_cb(skb,\r\ncb,\r\nNETLBL_NLTYPE_CALIPSO) < 0)\r\ngoto protocols_return;\r\nprotos_sent++;\r\n}\r\n#endif\r\nprotocols_return:\r\ncb->args[0] = protos_sent;\r\nreturn skb->len;\r\n}\r\nstatic int netlbl_mgmt_version(struct sk_buff *skb, struct genl_info *info)\r\n{\r\nint ret_val = -ENOMEM;\r\nstruct sk_buff *ans_skb = NULL;\r\nvoid *data;\r\nans_skb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\r\nif (ans_skb == NULL)\r\nreturn -ENOMEM;\r\ndata = genlmsg_put_reply(ans_skb, info, &netlbl_mgmt_gnl_family,\r\n0, NLBL_MGMT_C_VERSION);\r\nif (data == NULL)\r\ngoto version_failure;\r\nret_val = nla_put_u32(ans_skb,\r\nNLBL_MGMT_A_VERSION,\r\nNETLBL_PROTO_VERSION);\r\nif (ret_val != 0)\r\ngoto version_failure;\r\ngenlmsg_end(ans_skb, data);\r\nreturn genlmsg_reply(ans_skb, info);\r\nversion_failure:\r\nkfree_skb(ans_skb);\r\nreturn ret_val;\r\n}\r\nint __init netlbl_mgmt_genl_init(void)\r\n{\r\nreturn genl_register_family(&netlbl_mgmt_gnl_family);\r\n}
