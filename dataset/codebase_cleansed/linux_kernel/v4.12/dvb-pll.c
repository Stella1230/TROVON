static void thomson_dtt759x_bw(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nif (bw == 7000000)\r\nbuf[3] |= 0x10;\r\n}\r\nstatic void thomson_dtt7520x_bw(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nif (bw == 8000000)\r\nbuf[3] ^= 0x10;\r\n}\r\nstatic void tda665x_bw(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nif (bw == 8000000)\r\nbuf[3] |= 0x08;\r\n}\r\nstatic void tua6034_bw(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nif (bw == 7000000)\r\nbuf[3] |= 0x08;\r\n}\r\nstatic void tded4_bw(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nu32 bw = fe->dtv_property_cache.bandwidth_hz;\r\nif (bw == 8000000)\r\nbuf[3] |= 0x04;\r\n}\r\nstatic void opera1_bw(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nu32 b_w = (c->symbol_rate * 27) / 32000;\r\nstruct i2c_msg msg = {\r\n.addr = priv->pll_i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 4\r\n};\r\nint result;\r\nu8 lpf;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nresult = i2c_transfer(priv->i2c, &msg, 1);\r\nif (result != 1)\r\npr_err("%s: i2c_transfer failed:%d",\r\n__func__, result);\r\nif (b_w <= 10000)\r\nlpf = 0xc;\r\nelse if (b_w <= 12000)\r\nlpf = 0x2;\r\nelse if (b_w <= 14000)\r\nlpf = 0xa;\r\nelse if (b_w <= 16000)\r\nlpf = 0x6;\r\nelse if (b_w <= 18000)\r\nlpf = 0xe;\r\nelse if (b_w <= 20000)\r\nlpf = 0x1;\r\nelse if (b_w <= 22000)\r\nlpf = 0x9;\r\nelse if (b_w <= 24000)\r\nlpf = 0x5;\r\nelse if (b_w <= 26000)\r\nlpf = 0xd;\r\nelse if (b_w <= 28000)\r\nlpf = 0x3;\r\nelse\r\nlpf = 0xb;\r\nbuf[2] ^= 0x1c;\r\nbuf[2] |= ((lpf >> 2) & 0x3) << 3;\r\nbuf[3] |= (lpf & 0x3) << 2;\r\nreturn;\r\n}\r\nstatic void samsung_dtos403ih102a_set(struct dvb_frontend *fe, u8 *buf)\r\n{\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nstruct i2c_msg msg = {\r\n.addr = priv->pll_i2c_address,\r\n.flags = 0,\r\n.buf = buf,\r\n.len = 4\r\n};\r\nint result;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nresult = i2c_transfer(priv->i2c, &msg, 1);\r\nif (result != 1)\r\npr_err("%s: i2c_transfer failed:%d",\r\n__func__, result);\r\nbuf[2] = 0x9e;\r\nbuf[3] = 0x90;\r\nreturn;\r\n}\r\nstatic int dvb_pll_configure(struct dvb_frontend *fe, u8 *buf,\r\nconst u32 frequency)\r\n{\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nconst struct dvb_pll_desc *desc = priv->pll_desc;\r\nu32 div;\r\nint i;\r\nif (frequency && (frequency < desc->min || frequency > desc->max))\r\nreturn -EINVAL;\r\nfor (i = 0; i < desc->count; i++) {\r\nif (frequency > desc->entries[i].limit)\r\ncontinue;\r\nbreak;\r\n}\r\nif (debug)\r\ndprintk("pll: %s: freq=%d | i=%d/%d\n", desc->name,\r\nfrequency, i, desc->count);\r\nif (i == desc->count)\r\nreturn -EINVAL;\r\ndiv = (frequency + desc->iffreq +\r\ndesc->entries[i].stepsize/2) / desc->entries[i].stepsize;\r\nbuf[0] = div >> 8;\r\nbuf[1] = div & 0xff;\r\nbuf[2] = desc->entries[i].config;\r\nbuf[3] = desc->entries[i].cb;\r\nif (desc->set)\r\ndesc->set(fe, buf);\r\nif (debug)\r\ndprintk("pll: %s: div=%d | buf=0x%02x,0x%02x,0x%02x,0x%02x\n",\r\ndesc->name, div, buf[0], buf[1], buf[2], buf[3]);\r\nreturn (div * desc->entries[i].stepsize) - desc->iffreq;\r\n}\r\nstatic void dvb_pll_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstatic int dvb_pll_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nif (priv->i2c == NULL)\r\nreturn -EINVAL;\r\nif (priv->pll_desc->sleepdata) {\r\nstruct i2c_msg msg = { .flags = 0,\r\n.addr = priv->pll_i2c_address,\r\n.buf = priv->pll_desc->sleepdata + 1,\r\n.len = priv->pll_desc->sleepdata[0] };\r\nint result;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif ((result = i2c_transfer(priv->i2c, &msg, 1)) != 1) {\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int dvb_pll_set_params(struct dvb_frontend *fe)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nu8 buf[4];\r\nstruct i2c_msg msg =\r\n{ .addr = priv->pll_i2c_address, .flags = 0,\r\n.buf = buf, .len = sizeof(buf) };\r\nint result;\r\nu32 frequency = 0;\r\nif (priv->i2c == NULL)\r\nreturn -EINVAL;\r\nresult = dvb_pll_configure(fe, buf, c->frequency);\r\nif (result < 0)\r\nreturn result;\r\nelse\r\nfrequency = result;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nif ((result = i2c_transfer(priv->i2c, &msg, 1)) != 1) {\r\nreturn result;\r\n}\r\npriv->frequency = frequency;\r\npriv->bandwidth = c->bandwidth_hz;\r\nreturn 0;\r\n}\r\nstatic int dvb_pll_calc_regs(struct dvb_frontend *fe,\r\nu8 *buf, int buf_len)\r\n{\r\nstruct dtv_frontend_properties *c = &fe->dtv_property_cache;\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nint result;\r\nu32 frequency = 0;\r\nif (buf_len < 5)\r\nreturn -EINVAL;\r\nresult = dvb_pll_configure(fe, buf + 1, c->frequency);\r\nif (result < 0)\r\nreturn result;\r\nelse\r\nfrequency = result;\r\nbuf[0] = priv->pll_i2c_address;\r\npriv->frequency = frequency;\r\npriv->bandwidth = c->bandwidth_hz;\r\nreturn 5;\r\n}\r\nstatic int dvb_pll_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\n*frequency = priv->frequency;\r\nreturn 0;\r\n}\r\nstatic int dvb_pll_get_bandwidth(struct dvb_frontend *fe, u32 *bandwidth)\r\n{\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\n*bandwidth = priv->bandwidth;\r\nreturn 0;\r\n}\r\nstatic int dvb_pll_init(struct dvb_frontend *fe)\r\n{\r\nstruct dvb_pll_priv *priv = fe->tuner_priv;\r\nif (priv->i2c == NULL)\r\nreturn -EINVAL;\r\nif (priv->pll_desc->initdata) {\r\nstruct i2c_msg msg = { .flags = 0,\r\n.addr = priv->pll_i2c_address,\r\n.buf = priv->pll_desc->initdata + 1,\r\n.len = priv->pll_desc->initdata[0] };\r\nint result;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nresult = i2c_transfer(priv->i2c, &msg, 1);\r\nif (result != 1)\r\nreturn result;\r\nif (priv->pll_desc->initdata2) {\r\nmsg.buf = priv->pll_desc->initdata2 + 1;\r\nmsg.len = priv->pll_desc->initdata2[0];\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nresult = i2c_transfer(priv->i2c, &msg, 1);\r\nif (result != 1)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstruct dvb_frontend *dvb_pll_attach(struct dvb_frontend *fe, int pll_addr,\r\nstruct i2c_adapter *i2c,\r\nunsigned int pll_desc_id)\r\n{\r\nu8 b1 [] = { 0 };\r\nstruct i2c_msg msg = { .addr = pll_addr, .flags = I2C_M_RD,\r\n.buf = b1, .len = 1 };\r\nstruct dvb_pll_priv *priv = NULL;\r\nint ret;\r\nconst struct dvb_pll_desc *desc;\r\nif ((id[dvb_pll_devcount] > DVB_PLL_UNDEFINED) &&\r\n(id[dvb_pll_devcount] < ARRAY_SIZE(pll_list)))\r\npll_desc_id = id[dvb_pll_devcount];\r\nBUG_ON(pll_desc_id < 1 || pll_desc_id >= ARRAY_SIZE(pll_list));\r\ndesc = pll_list[pll_desc_id];\r\nif (i2c != NULL) {\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 1);\r\nret = i2c_transfer (i2c, &msg, 1);\r\nif (ret != 1)\r\nreturn NULL;\r\nif (fe->ops.i2c_gate_ctrl)\r\nfe->ops.i2c_gate_ctrl(fe, 0);\r\n}\r\npriv = kzalloc(sizeof(struct dvb_pll_priv), GFP_KERNEL);\r\nif (priv == NULL)\r\nreturn NULL;\r\npriv->pll_i2c_address = pll_addr;\r\npriv->i2c = i2c;\r\npriv->pll_desc = desc;\r\npriv->nr = dvb_pll_devcount++;\r\nmemcpy(&fe->ops.tuner_ops, &dvb_pll_tuner_ops,\r\nsizeof(struct dvb_tuner_ops));\r\nstrncpy(fe->ops.tuner_ops.info.name, desc->name,\r\nsizeof(fe->ops.tuner_ops.info.name));\r\nfe->ops.tuner_ops.info.frequency_min = desc->min;\r\nfe->ops.tuner_ops.info.frequency_max = desc->max;\r\nif (!desc->initdata)\r\nfe->ops.tuner_ops.init = NULL;\r\nif (!desc->sleepdata)\r\nfe->ops.tuner_ops.sleep = NULL;\r\nfe->tuner_priv = priv;\r\nif ((debug) || (id[priv->nr] == pll_desc_id)) {\r\ndprintk("dvb-pll[%d]", priv->nr);\r\nif (i2c != NULL)\r\npr_cont(" %d-%04x", i2c_adapter_id(i2c), pll_addr);\r\npr_cont(": id# %d (%s) attached, %s\n", pll_desc_id, desc->name,\r\nid[priv->nr] == pll_desc_id ?\r\n"insmod option" : "autodetected");\r\n}\r\nreturn fe;\r\n}
