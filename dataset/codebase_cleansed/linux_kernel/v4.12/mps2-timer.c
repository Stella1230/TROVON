static u64 notrace mps2_sched_read(void)\r\n{\r\nreturn ~readl_relaxed(sched_clock_base + TIMER_VALUE);\r\n}\r\nstatic inline struct clockevent_mps2 *to_mps2_clkevt(struct clock_event_device *c)\r\n{\r\nreturn container_of(c, struct clockevent_mps2, clkevt);\r\n}\r\nstatic void clockevent_mps2_writel(u32 val, struct clock_event_device *c, u32 offset)\r\n{\r\nwritel_relaxed(val, to_mps2_clkevt(c)->reg + offset);\r\n}\r\nstatic int mps2_timer_shutdown(struct clock_event_device *ce)\r\n{\r\nclockevent_mps2_writel(0, ce, TIMER_RELOAD);\r\nclockevent_mps2_writel(0, ce, TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic int mps2_timer_set_next_event(unsigned long next, struct clock_event_device *ce)\r\n{\r\nclockevent_mps2_writel(next, ce, TIMER_VALUE);\r\nclockevent_mps2_writel(TIMER_CTRL_IE | TIMER_CTRL_ENABLE, ce, TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic int mps2_timer_set_periodic(struct clock_event_device *ce)\r\n{\r\nu32 clock_count_per_tick = to_mps2_clkevt(ce)->clock_count_per_tick;\r\nclockevent_mps2_writel(clock_count_per_tick, ce, TIMER_RELOAD);\r\nclockevent_mps2_writel(clock_count_per_tick, ce, TIMER_VALUE);\r\nclockevent_mps2_writel(TIMER_CTRL_IE | TIMER_CTRL_ENABLE, ce, TIMER_CTRL);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t mps2_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clockevent_mps2 *ce = dev_id;\r\nu32 status = readl_relaxed(ce->reg + TIMER_INT);\r\nif (!status) {\r\npr_warn("spurious interrupt\n");\r\nreturn IRQ_NONE;\r\n}\r\nwritel_relaxed(1, ce->reg + TIMER_INT);\r\nce->clkevt.event_handler(&ce->clkevt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int __init mps2_clockevent_init(struct device_node *np)\r\n{\r\nvoid __iomem *base;\r\nstruct clk *clk = NULL;\r\nstruct clockevent_mps2 *ce;\r\nu32 rate;\r\nint irq, ret;\r\nconst char *name = "mps2-clkevt";\r\nret = of_property_read_u32(np, "clock-frequency", &rate);\r\nif (ret) {\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\npr_err("failed to get clock for clockevent: %d\n", ret);\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("failed to enable clock for clockevent: %d\n", ret);\r\ngoto out_clk_put;\r\n}\r\nrate = clk_get_rate(clk);\r\n}\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\nret = -EADDRNOTAVAIL;\r\npr_err("failed to map register for clockevent: %d\n", ret);\r\ngoto out_clk_disable;\r\n}\r\nirq = irq_of_parse_and_map(np, 0);\r\nif (!irq) {\r\nret = -ENOENT;\r\npr_err("failed to get irq for clockevent: %d\n", ret);\r\ngoto out_iounmap;\r\n}\r\nce = kzalloc(sizeof(*ce), GFP_KERNEL);\r\nif (!ce) {\r\nret = -ENOMEM;\r\ngoto out_iounmap;\r\n}\r\nce->reg = base;\r\nce->clock_count_per_tick = DIV_ROUND_CLOSEST(rate, HZ);\r\nce->clkevt.irq = irq;\r\nce->clkevt.name = name;\r\nce->clkevt.rating = 200;\r\nce->clkevt.features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;\r\nce->clkevt.cpumask = cpu_possible_mask;\r\nce->clkevt.set_state_shutdown = mps2_timer_shutdown,\r\nce->clkevt.set_state_periodic = mps2_timer_set_periodic,\r\nce->clkevt.set_state_oneshot = mps2_timer_shutdown,\r\nce->clkevt.set_next_event = mps2_timer_set_next_event;\r\nwritel_relaxed(0, base + TIMER_CTRL);\r\nret = request_irq(irq, mps2_timer_interrupt, IRQF_TIMER, name, ce);\r\nif (ret) {\r\npr_err("failed to request irq for clockevent: %d\n", ret);\r\ngoto out_kfree;\r\n}\r\nclockevents_config_and_register(&ce->clkevt, rate, 0xf, 0xffffffff);\r\nreturn 0;\r\nout_kfree:\r\nkfree(ce);\r\nout_iounmap:\r\niounmap(base);\r\nout_clk_disable:\r\nclk_disable_unprepare(clk);\r\nout_clk_put:\r\nclk_put(clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init mps2_clocksource_init(struct device_node *np)\r\n{\r\nvoid __iomem *base;\r\nstruct clk *clk = NULL;\r\nu32 rate;\r\nint ret;\r\nconst char *name = "mps2-clksrc";\r\nret = of_property_read_u32(np, "clock-frequency", &rate);\r\nif (ret) {\r\nclk = of_clk_get(np, 0);\r\nif (IS_ERR(clk)) {\r\nret = PTR_ERR(clk);\r\npr_err("failed to get clock for clocksource: %d\n", ret);\r\ngoto out;\r\n}\r\nret = clk_prepare_enable(clk);\r\nif (ret) {\r\npr_err("failed to enable clock for clocksource: %d\n", ret);\r\ngoto out_clk_put;\r\n}\r\nrate = clk_get_rate(clk);\r\n}\r\nbase = of_iomap(np, 0);\r\nif (!base) {\r\nret = -EADDRNOTAVAIL;\r\npr_err("failed to map register for clocksource: %d\n", ret);\r\ngoto out_clk_disable;\r\n}\r\nwritel_relaxed(0, base + TIMER_CTRL);\r\nwritel_relaxed(0xffffffff, base + TIMER_VALUE);\r\nwritel_relaxed(0xffffffff, base + TIMER_RELOAD);\r\nwritel_relaxed(TIMER_CTRL_ENABLE, base + TIMER_CTRL);\r\nret = clocksource_mmio_init(base + TIMER_VALUE, name,\r\nrate, 200, 32,\r\nclocksource_mmio_readl_down);\r\nif (ret) {\r\npr_err("failed to init clocksource: %d\n", ret);\r\ngoto out_iounmap;\r\n}\r\nsched_clock_base = base;\r\nsched_clock_register(mps2_sched_read, 32, rate);\r\nreturn 0;\r\nout_iounmap:\r\niounmap(base);\r\nout_clk_disable:\r\nclk_disable_unprepare(clk);\r\nout_clk_put:\r\nclk_put(clk);\r\nout:\r\nreturn ret;\r\n}\r\nstatic int __init mps2_timer_init(struct device_node *np)\r\n{\r\nstatic int has_clocksource, has_clockevent;\r\nint ret;\r\nif (!has_clocksource) {\r\nret = mps2_clocksource_init(np);\r\nif (!ret) {\r\nhas_clocksource = 1;\r\nreturn 0;\r\n}\r\n}\r\nif (!has_clockevent) {\r\nret = mps2_clockevent_init(np);\r\nif (!ret) {\r\nhas_clockevent = 1;\r\nreturn 0;\r\n}\r\n}\r\nreturn 0;\r\n}
