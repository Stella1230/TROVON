static int cz_smum_get_argument(struct pp_smumgr *smumgr)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nreturn cgs_read_register(smumgr->device,\r\nmmSMU_MP1_SRBM2P_ARG_0);\r\n}\r\nstatic int cz_send_msg_to_smc_async(struct pp_smumgr *smumgr,\r\nuint16_t msg)\r\n{\r\nint result = 0;\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nresult = SMUM_WAIT_FIELD_UNEQUAL(smumgr,\r\nSMU_MP1_SRBM2P_RESP_0, CONTENT, 0);\r\nif (result != 0) {\r\npr_err("cz_send_msg_to_smc_async failed\n");\r\nreturn result;\r\n}\r\ncgs_write_register(smumgr->device, mmSMU_MP1_SRBM2P_RESP_0, 0);\r\ncgs_write_register(smumgr->device, mmSMU_MP1_SRBM2P_MSG_0, msg);\r\nreturn 0;\r\n}\r\nstatic int cz_send_msg_to_smc(struct pp_smumgr *smumgr, uint16_t msg)\r\n{\r\nint result = 0;\r\nresult = cz_send_msg_to_smc_async(smumgr, msg);\r\nif (result != 0)\r\nreturn result;\r\nreturn SMUM_WAIT_FIELD_UNEQUAL(smumgr,\r\nSMU_MP1_SRBM2P_RESP_0, CONTENT, 0);\r\n}\r\nstatic int cz_set_smc_sram_address(struct pp_smumgr *smumgr,\r\nuint32_t smc_address, uint32_t limit)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nif (0 != (3 & smc_address)) {\r\npr_err("SMC address must be 4 byte aligned\n");\r\nreturn -EINVAL;\r\n}\r\nif (limit <= (smc_address + 3)) {\r\npr_err("SMC address beyond the SMC RAM area\n");\r\nreturn -EINVAL;\r\n}\r\ncgs_write_register(smumgr->device, mmMP0PUB_IND_INDEX_0,\r\nSMN_MP1_SRAM_START_ADDR + smc_address);\r\nreturn 0;\r\n}\r\nstatic int cz_write_smc_sram_dword(struct pp_smumgr *smumgr,\r\nuint32_t smc_address, uint32_t value, uint32_t limit)\r\n{\r\nint result;\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\nresult = cz_set_smc_sram_address(smumgr, smc_address, limit);\r\nif (!result)\r\ncgs_write_register(smumgr->device, mmMP0PUB_IND_DATA_0, value);\r\nreturn result;\r\n}\r\nstatic int cz_send_msg_to_smc_with_parameter(struct pp_smumgr *smumgr,\r\nuint16_t msg, uint32_t parameter)\r\n{\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncgs_write_register(smumgr->device, mmSMU_MP1_SRBM2P_ARG_0, parameter);\r\nreturn cz_send_msg_to_smc(smumgr, msg);\r\n}\r\nstatic int cz_check_fw_load_finish(struct pp_smumgr *smumgr,\r\nuint32_t firmware)\r\n{\r\nint i;\r\nuint32_t index = SMN_MP1_SRAM_START_ADDR +\r\nSMU8_FIRMWARE_HEADER_LOCATION +\r\noffsetof(struct SMU8_Firmware_Header, UcodeLoadStatus);\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncgs_write_register(smumgr->device, mmMP0PUB_IND_INDEX, index);\r\nfor (i = 0; i < smumgr->usec_timeout; i++) {\r\nif (firmware ==\r\n(cgs_read_register(smumgr->device, mmMP0PUB_IND_DATA) & firmware))\r\nbreak;\r\nudelay(1);\r\n}\r\nif (i >= smumgr->usec_timeout) {\r\npr_err("SMU check loaded firmware failed.\n");\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cz_load_mec_firmware(struct pp_smumgr *smumgr)\r\n{\r\nuint32_t reg_data;\r\nuint32_t tmp;\r\nint ret = 0;\r\nstruct cgs_firmware_info info = {0};\r\nstruct cz_smumgr *cz_smu;\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncz_smu = (struct cz_smumgr *)smumgr->backend;\r\nret = cgs_get_firmware_info(smumgr->device,\r\nCGS_UCODE_ID_CP_MEC, &info);\r\nif (ret)\r\nreturn -EINVAL;\r\ntmp = cgs_read_register(smumgr->device,\r\nmmCP_MEC_CNTL);\r\ntmp = SMUM_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME1_HALT, 1);\r\ntmp = SMUM_SET_FIELD(tmp, CP_MEC_CNTL, MEC_ME2_HALT, 1);\r\ncgs_write_register(smumgr->device, mmCP_MEC_CNTL, tmp);\r\ntmp = cgs_read_register(smumgr->device,\r\nmmCP_CPC_IC_BASE_CNTL);\r\ntmp = SMUM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, VMID, 0);\r\ntmp = SMUM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, ATC, 0);\r\ntmp = SMUM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, CACHE_POLICY, 0);\r\ntmp = SMUM_SET_FIELD(tmp, CP_CPC_IC_BASE_CNTL, MTYPE, 1);\r\ncgs_write_register(smumgr->device, mmCP_CPC_IC_BASE_CNTL, tmp);\r\nreg_data = smu_lower_32_bits(info.mc_addr) &\r\nSMUM_FIELD_MASK(CP_CPC_IC_BASE_LO, IC_BASE_LO);\r\ncgs_write_register(smumgr->device, mmCP_CPC_IC_BASE_LO, reg_data);\r\nreg_data = smu_upper_32_bits(info.mc_addr) &\r\nSMUM_FIELD_MASK(CP_CPC_IC_BASE_HI, IC_BASE_HI);\r\ncgs_write_register(smumgr->device, mmCP_CPC_IC_BASE_HI, reg_data);\r\nreturn 0;\r\n}\r\nstatic uint8_t cz_translate_firmware_enum_to_arg(struct pp_smumgr *smumgr,\r\nenum cz_scratch_entry firmware_enum)\r\n{\r\nuint8_t ret = 0;\r\nswitch (firmware_enum) {\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_SDMA0:\r\nret = UCODE_ID_SDMA0;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_SDMA1:\r\nif (smumgr->chip_id == CHIP_STONEY)\r\nret = UCODE_ID_SDMA0;\r\nelse\r\nret = UCODE_ID_SDMA1;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_CP_CE:\r\nret = UCODE_ID_CP_CE;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_CP_PFP:\r\nret = UCODE_ID_CP_PFP;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_CP_ME:\r\nret = UCODE_ID_CP_ME;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1:\r\nret = UCODE_ID_CP_MEC_JT1;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2:\r\nif (smumgr->chip_id == CHIP_STONEY)\r\nret = UCODE_ID_CP_MEC_JT1;\r\nelse\r\nret = UCODE_ID_CP_MEC_JT2;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_GMCON_RENG:\r\nret = UCODE_ID_GMCON_RENG;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_RLC_G:\r\nret = UCODE_ID_RLC_G;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH:\r\nret = UCODE_ID_RLC_SCRATCH;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM:\r\nret = UCODE_ID_RLC_SRM_ARAM;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM:\r\nret = UCODE_ID_RLC_SRM_DRAM;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_DMCU_ERAM:\r\nret = UCODE_ID_DMCU_ERAM;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_DMCU_IRAM:\r\nret = UCODE_ID_DMCU_IRAM;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING:\r\nret = TASK_ARG_INIT_MM_PWR_LOG;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_DATA_ID_SDMA_HALT:\r\ncase CZ_SCRATCH_ENTRY_DATA_ID_SYS_CLOCKGATING:\r\ncase CZ_SCRATCH_ENTRY_DATA_ID_SDMA_RING_REGS:\r\ncase CZ_SCRATCH_ENTRY_DATA_ID_NONGFX_REINIT:\r\ncase CZ_SCRATCH_ENTRY_DATA_ID_SDMA_START:\r\ncase CZ_SCRATCH_ENTRY_DATA_ID_IH_REGISTERS:\r\nret = TASK_ARG_REG_MMIO;\r\nbreak;\r\ncase CZ_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE:\r\nret = TASK_ARG_INIT_CLK_TABLE;\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nstatic enum cgs_ucode_id cz_convert_fw_type_to_cgs(uint32_t fw_type)\r\n{\r\nenum cgs_ucode_id result = CGS_UCODE_ID_MAXIMUM;\r\nswitch (fw_type) {\r\ncase UCODE_ID_SDMA0:\r\nresult = CGS_UCODE_ID_SDMA0;\r\nbreak;\r\ncase UCODE_ID_SDMA1:\r\nresult = CGS_UCODE_ID_SDMA1;\r\nbreak;\r\ncase UCODE_ID_CP_CE:\r\nresult = CGS_UCODE_ID_CP_CE;\r\nbreak;\r\ncase UCODE_ID_CP_PFP:\r\nresult = CGS_UCODE_ID_CP_PFP;\r\nbreak;\r\ncase UCODE_ID_CP_ME:\r\nresult = CGS_UCODE_ID_CP_ME;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT1:\r\nresult = CGS_UCODE_ID_CP_MEC_JT1;\r\nbreak;\r\ncase UCODE_ID_CP_MEC_JT2:\r\nresult = CGS_UCODE_ID_CP_MEC_JT2;\r\nbreak;\r\ncase UCODE_ID_RLC_G:\r\nresult = CGS_UCODE_ID_RLC_G;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn result;\r\n}\r\nstatic int cz_smu_populate_single_scratch_task(\r\nstruct pp_smumgr *smumgr,\r\nenum cz_scratch_entry fw_enum,\r\nuint8_t type, bool is_last)\r\n{\r\nuint8_t i;\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nstruct TOC *toc = (struct TOC *)cz_smu->toc_buffer.kaddr;\r\nstruct SMU_Task *task = &toc->tasks[cz_smu->toc_entry_used_count++];\r\ntask->type = type;\r\ntask->arg = cz_translate_firmware_enum_to_arg(smumgr, fw_enum);\r\ntask->next = is_last ? END_OF_TASK_LIST : cz_smu->toc_entry_used_count;\r\nfor (i = 0; i < cz_smu->scratch_buffer_length; i++)\r\nif (cz_smu->scratch_buffer[i].firmware_ID == fw_enum)\r\nbreak;\r\nif (i >= cz_smu->scratch_buffer_length) {\r\npr_err("Invalid Firmware Type\n");\r\nreturn -EINVAL;\r\n}\r\ntask->addr.low = cz_smu->scratch_buffer[i].mc_addr_low;\r\ntask->addr.high = cz_smu->scratch_buffer[i].mc_addr_high;\r\ntask->size_bytes = cz_smu->scratch_buffer[i].data_size;\r\nif (CZ_SCRATCH_ENTRY_DATA_ID_IH_REGISTERS == fw_enum) {\r\nstruct cz_ih_meta_data *pIHReg_restore =\r\n(struct cz_ih_meta_data *)cz_smu->scratch_buffer[i].kaddr;\r\npIHReg_restore->command =\r\nMETADATA_CMD_MODE0 | METADATA_PERFORM_ON_LOAD;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cz_smu_populate_single_ucode_load_task(\r\nstruct pp_smumgr *smumgr,\r\nenum cz_scratch_entry fw_enum,\r\nbool is_last)\r\n{\r\nuint8_t i;\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nstruct TOC *toc = (struct TOC *)cz_smu->toc_buffer.kaddr;\r\nstruct SMU_Task *task = &toc->tasks[cz_smu->toc_entry_used_count++];\r\ntask->type = TASK_TYPE_UCODE_LOAD;\r\ntask->arg = cz_translate_firmware_enum_to_arg(smumgr, fw_enum);\r\ntask->next = is_last ? END_OF_TASK_LIST : cz_smu->toc_entry_used_count;\r\nfor (i = 0; i < cz_smu->driver_buffer_length; i++)\r\nif (cz_smu->driver_buffer[i].firmware_ID == fw_enum)\r\nbreak;\r\nif (i >= cz_smu->driver_buffer_length) {\r\npr_err("Invalid Firmware Type\n");\r\nreturn -EINVAL;\r\n}\r\ntask->addr.low = cz_smu->driver_buffer[i].mc_addr_low;\r\ntask->addr.high = cz_smu->driver_buffer[i].mc_addr_high;\r\ntask->size_bytes = cz_smu->driver_buffer[i].data_size;\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc_for_rlc_aram_save(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\ncz_smu->toc_entry_aram = cz_smu->toc_entry_used_count;\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,\r\nTASK_TYPE_UCODE_SAVE, true);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_initialize_toc_empty_job_list(struct pp_smumgr *smumgr)\r\n{\r\nint i;\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nstruct TOC *toc = (struct TOC *)cz_smu->toc_buffer.kaddr;\r\nfor (i = 0; i < NUM_JOBLIST_ENTRIES; i++)\r\ntoc->JobList[i] = (uint8_t)IGNORE_JOB;\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc_for_vddgfx_enter(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nstruct TOC *toc = (struct TOC *)cz_smu->toc_buffer.kaddr;\r\ntoc->JobList[JOB_GFX_SAVE] = (uint8_t)cz_smu->toc_entry_used_count;\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,\r\nTASK_TYPE_UCODE_SAVE, false);\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,\r\nTASK_TYPE_UCODE_SAVE, true);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc_for_vddgfx_exit(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nstruct TOC *toc = (struct TOC *)cz_smu->toc_buffer.kaddr;\r\ntoc->JobList[JOB_GFX_RESTORE] = (uint8_t)cz_smu->toc_entry_used_count;\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_CE, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_PFP, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_ME, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);\r\nif (smumgr->chip_id == CHIP_STONEY)\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);\r\nelse\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_G, false);\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,\r\nTASK_TYPE_UCODE_LOAD, false);\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,\r\nTASK_TYPE_UCODE_LOAD, false);\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,\r\nTASK_TYPE_UCODE_LOAD, true);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc_for_power_profiling(\r\nstruct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\ncz_smu->toc_entry_power_profiling_index = cz_smu->toc_entry_used_count;\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING,\r\nTASK_TYPE_INITIALIZE, true);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc_for_bootup(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\ncz_smu->toc_entry_initialize_index = cz_smu->toc_entry_used_count;\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_SDMA0, false);\r\nif (smumgr->chip_id != CHIP_STONEY)\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_SDMA1, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_CE, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_PFP, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_ME, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT1, false);\r\nif (smumgr->chip_id != CHIP_STONEY)\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_CP_MEC_JT2, false);\r\ncz_smu_populate_single_ucode_load_task(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_G, true);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc_for_clock_table(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\ncz_smu->toc_entry_clock_table = cz_smu->toc_entry_used_count;\r\ncz_smu_populate_single_scratch_task(smumgr,\r\nCZ_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE,\r\nTASK_TYPE_INITIALIZE, true);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_construct_toc(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\ncz_smu->toc_entry_used_count = 0;\r\ncz_smu_initialize_toc_empty_job_list(smumgr);\r\ncz_smu_construct_toc_for_rlc_aram_save(smumgr);\r\ncz_smu_construct_toc_for_vddgfx_enter(smumgr);\r\ncz_smu_construct_toc_for_vddgfx_exit(smumgr);\r\ncz_smu_construct_toc_for_power_profiling(smumgr);\r\ncz_smu_construct_toc_for_bootup(smumgr);\r\ncz_smu_construct_toc_for_clock_table(smumgr);\r\nreturn 0;\r\n}\r\nstatic int cz_smu_populate_firmware_entries(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nuint32_t firmware_type;\r\nuint32_t i;\r\nint ret;\r\nenum cgs_ucode_id ucode_id;\r\nstruct cgs_firmware_info info = {0};\r\ncz_smu->driver_buffer_length = 0;\r\nfor (i = 0; i < ARRAY_SIZE(firmware_list); i++) {\r\nfirmware_type = cz_translate_firmware_enum_to_arg(smumgr,\r\nfirmware_list[i]);\r\nucode_id = cz_convert_fw_type_to_cgs(firmware_type);\r\nret = cgs_get_firmware_info(smumgr->device,\r\nucode_id, &info);\r\nif (ret == 0) {\r\ncz_smu->driver_buffer[i].mc_addr_high =\r\nsmu_upper_32_bits(info.mc_addr);\r\ncz_smu->driver_buffer[i].mc_addr_low =\r\nsmu_lower_32_bits(info.mc_addr);\r\ncz_smu->driver_buffer[i].data_size = info.image_size;\r\ncz_smu->driver_buffer[i].firmware_ID = firmware_list[i];\r\ncz_smu->driver_buffer_length++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int cz_smu_populate_single_scratch_entry(\r\nstruct pp_smumgr *smumgr,\r\nenum cz_scratch_entry scratch_type,\r\nuint32_t ulsize_byte,\r\nstruct cz_buffer_entry *entry)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nlong long mc_addr =\r\n((long long)(cz_smu->smu_buffer.mc_addr_high) << 32)\r\n| cz_smu->smu_buffer.mc_addr_low;\r\nuint32_t ulsize_aligned = SIZE_ALIGN_32(ulsize_byte);\r\nmc_addr += cz_smu->smu_buffer_used_bytes;\r\nentry->data_size = ulsize_byte;\r\nentry->kaddr = (char *) cz_smu->smu_buffer.kaddr +\r\ncz_smu->smu_buffer_used_bytes;\r\nentry->mc_addr_low = smu_lower_32_bits(mc_addr);\r\nentry->mc_addr_high = smu_upper_32_bits(mc_addr);\r\nentry->firmware_ID = scratch_type;\r\ncz_smu->smu_buffer_used_bytes += ulsize_aligned;\r\nreturn 0;\r\n}\r\nstatic int cz_download_pptable_settings(struct pp_smumgr *smumgr, void **table)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nunsigned long i;\r\nfor (i = 0; i < cz_smu->scratch_buffer_length; i++) {\r\nif (cz_smu->scratch_buffer[i].firmware_ID\r\n== CZ_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE)\r\nbreak;\r\n}\r\n*table = (struct SMU8_Fusion_ClkTable *)cz_smu->scratch_buffer[i].kaddr;\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetClkTableAddrHi,\r\ncz_smu->scratch_buffer[i].mc_addr_high);\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetClkTableAddrLo,\r\ncz_smu->scratch_buffer[i].mc_addr_low);\r\ncz_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_ExecuteJob,\r\ncz_smu->toc_entry_clock_table);\r\ncz_send_msg_to_smc(smumgr, PPSMC_MSG_ClkTableXferToDram);\r\nreturn 0;\r\n}\r\nstatic int cz_upload_pptable_settings(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)smumgr->backend;\r\nunsigned long i;\r\nfor (i = 0; i < cz_smu->scratch_buffer_length; i++) {\r\nif (cz_smu->scratch_buffer[i].firmware_ID\r\n== CZ_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE)\r\nbreak;\r\n}\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetClkTableAddrHi,\r\ncz_smu->scratch_buffer[i].mc_addr_high);\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_SetClkTableAddrLo,\r\ncz_smu->scratch_buffer[i].mc_addr_low);\r\ncz_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_ExecuteJob,\r\ncz_smu->toc_entry_clock_table);\r\ncz_send_msg_to_smc(smumgr, PPSMC_MSG_ClkTableXferToSmu);\r\nreturn 0;\r\n}\r\nstatic int cz_request_smu_load_fw(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu = (struct cz_smumgr *)(smumgr->backend);\r\nuint32_t smc_address;\r\nif (!smumgr->reload_fw) {\r\npr_info("skip reloading...\n");\r\nreturn 0;\r\n}\r\ncz_smu_populate_firmware_entries(smumgr);\r\ncz_smu_construct_toc(smumgr);\r\nsmc_address = SMU8_FIRMWARE_HEADER_LOCATION +\r\noffsetof(struct SMU8_Firmware_Header, UcodeLoadStatus);\r\ncz_write_smc_sram_dword(smumgr, smc_address, 0, smc_address+4);\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_DriverDramAddrHi,\r\ncz_smu->toc_buffer.mc_addr_high);\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_DriverDramAddrLo,\r\ncz_smu->toc_buffer.mc_addr_low);\r\ncz_send_msg_to_smc(smumgr, PPSMC_MSG_InitJobs);\r\ncz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_ExecuteJob,\r\ncz_smu->toc_entry_aram);\r\ncz_send_msg_to_smc_with_parameter(smumgr, PPSMC_MSG_ExecuteJob,\r\ncz_smu->toc_entry_power_profiling_index);\r\nreturn cz_send_msg_to_smc_with_parameter(smumgr,\r\nPPSMC_MSG_ExecuteJob,\r\ncz_smu->toc_entry_initialize_index);\r\n}\r\nstatic int cz_start_smu(struct pp_smumgr *smumgr)\r\n{\r\nint ret = 0;\r\nuint32_t fw_to_check = 0;\r\nfw_to_check = UCODE_ID_RLC_G_MASK |\r\nUCODE_ID_SDMA0_MASK |\r\nUCODE_ID_SDMA1_MASK |\r\nUCODE_ID_CP_CE_MASK |\r\nUCODE_ID_CP_ME_MASK |\r\nUCODE_ID_CP_PFP_MASK |\r\nUCODE_ID_CP_MEC_JT1_MASK |\r\nUCODE_ID_CP_MEC_JT2_MASK;\r\nif (smumgr->chip_id == CHIP_STONEY)\r\nfw_to_check &= ~(UCODE_ID_SDMA1_MASK | UCODE_ID_CP_MEC_JT2_MASK);\r\nret = cz_request_smu_load_fw(smumgr);\r\nif (ret)\r\npr_err("SMU firmware load failed\n");\r\ncz_check_fw_load_finish(smumgr, fw_to_check);\r\nret = cz_load_mec_firmware(smumgr);\r\nif (ret)\r\npr_err("Mec Firmware load failed\n");\r\nreturn ret;\r\n}\r\nstatic int cz_smu_init(struct pp_smumgr *smumgr)\r\n{\r\nuint64_t mc_addr = 0;\r\nint ret = 0;\r\nstruct cz_smumgr *cz_smu;\r\ncz_smu = kzalloc(sizeof(struct cz_smumgr), GFP_KERNEL);\r\nif (cz_smu == NULL)\r\nreturn -ENOMEM;\r\nsmumgr->backend = cz_smu;\r\ncz_smu->toc_buffer.data_size = 4096;\r\ncz_smu->smu_buffer.data_size =\r\nALIGN(UCODE_ID_RLC_SCRATCH_SIZE_BYTE, 32) +\r\nALIGN(UCODE_ID_RLC_SRM_ARAM_SIZE_BYTE, 32) +\r\nALIGN(UCODE_ID_RLC_SRM_DRAM_SIZE_BYTE, 32) +\r\nALIGN(sizeof(struct SMU8_MultimediaPowerLogData), 32) +\r\nALIGN(sizeof(struct SMU8_Fusion_ClkTable), 32);\r\nret = smu_allocate_memory(smumgr->device,\r\ncz_smu->toc_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__GART_CACHEABLE,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&cz_smu->toc_buffer.kaddr,\r\n&cz_smu->toc_buffer.handle);\r\nif (ret != 0)\r\nreturn -1;\r\ncz_smu->toc_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\ncz_smu->toc_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nret = smu_allocate_memory(smumgr->device,\r\ncz_smu->smu_buffer.data_size,\r\nCGS_GPU_MEM_TYPE__GART_CACHEABLE,\r\nPAGE_SIZE,\r\n&mc_addr,\r\n&cz_smu->smu_buffer.kaddr,\r\n&cz_smu->smu_buffer.handle);\r\nif (ret != 0)\r\nreturn -1;\r\ncz_smu->smu_buffer.mc_addr_high = smu_upper_32_bits(mc_addr);\r\ncz_smu->smu_buffer.mc_addr_low = smu_lower_32_bits(mc_addr);\r\nif (0 != cz_smu_populate_single_scratch_entry(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SCRATCH,\r\nUCODE_ID_RLC_SCRATCH_SIZE_BYTE,\r\n&cz_smu->scratch_buffer[cz_smu->scratch_buffer_length++])) {\r\npr_err("Error when Populate Firmware Entry.\n");\r\nreturn -1;\r\n}\r\nif (0 != cz_smu_populate_single_scratch_entry(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_ARAM,\r\nUCODE_ID_RLC_SRM_ARAM_SIZE_BYTE,\r\n&cz_smu->scratch_buffer[cz_smu->scratch_buffer_length++])) {\r\npr_err("Error when Populate Firmware Entry.\n");\r\nreturn -1;\r\n}\r\nif (0 != cz_smu_populate_single_scratch_entry(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_RLC_SRM_DRAM,\r\nUCODE_ID_RLC_SRM_DRAM_SIZE_BYTE,\r\n&cz_smu->scratch_buffer[cz_smu->scratch_buffer_length++])) {\r\npr_err("Error when Populate Firmware Entry.\n");\r\nreturn -1;\r\n}\r\nif (0 != cz_smu_populate_single_scratch_entry(smumgr,\r\nCZ_SCRATCH_ENTRY_UCODE_ID_POWER_PROFILING,\r\nsizeof(struct SMU8_MultimediaPowerLogData),\r\n&cz_smu->scratch_buffer[cz_smu->scratch_buffer_length++])) {\r\npr_err("Error when Populate Firmware Entry.\n");\r\nreturn -1;\r\n}\r\nif (0 != cz_smu_populate_single_scratch_entry(smumgr,\r\nCZ_SCRATCH_ENTRY_SMU8_FUSION_CLKTABLE,\r\nsizeof(struct SMU8_Fusion_ClkTable),\r\n&cz_smu->scratch_buffer[cz_smu->scratch_buffer_length++])) {\r\npr_err("Error when Populate Firmware Entry.\n");\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int cz_smu_fini(struct pp_smumgr *smumgr)\r\n{\r\nstruct cz_smumgr *cz_smu;\r\nif (smumgr == NULL || smumgr->device == NULL)\r\nreturn -EINVAL;\r\ncz_smu = (struct cz_smumgr *)smumgr->backend;\r\nif (cz_smu) {\r\ncgs_free_gpu_mem(smumgr->device,\r\ncz_smu->toc_buffer.handle);\r\ncgs_free_gpu_mem(smumgr->device,\r\ncz_smu->smu_buffer.handle);\r\nkfree(cz_smu);\r\n}\r\nreturn 0;\r\n}
