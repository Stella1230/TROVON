static inline int da732x_get_input_div(struct snd_soc_codec *codec, int sysclk)\r\n{\r\nint val;\r\nint ret;\r\nif (sysclk < DA732X_MCLK_10MHZ) {\r\nval = DA732X_MCLK_RET_0_10MHZ;\r\nret = DA732X_MCLK_VAL_0_10MHZ;\r\n} else if ((sysclk >= DA732X_MCLK_10MHZ) &&\r\n(sysclk < DA732X_MCLK_20MHZ)) {\r\nval = DA732X_MCLK_RET_10_20MHZ;\r\nret = DA732X_MCLK_VAL_10_20MHZ;\r\n} else if ((sysclk >= DA732X_MCLK_20MHZ) &&\r\n(sysclk < DA732X_MCLK_40MHZ)) {\r\nval = DA732X_MCLK_RET_20_40MHZ;\r\nret = DA732X_MCLK_VAL_20_40MHZ;\r\n} else if ((sysclk >= DA732X_MCLK_40MHZ) &&\r\n(sysclk <= DA732X_MCLK_54MHZ)) {\r\nval = DA732X_MCLK_RET_40_54MHZ;\r\nret = DA732X_MCLK_VAL_40_54MHZ;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, DA732X_REG_PLL_CTRL, val);\r\nreturn ret;\r\n}\r\nstatic void da732x_set_charge_pump(struct snd_soc_codec *codec, int state)\r\n{\r\nswitch (state) {\r\ncase DA732X_ENABLE_CP:\r\nsnd_soc_write(codec, DA732X_REG_CLK_EN2, DA732X_CP_CLK_EN);\r\nsnd_soc_write(codec, DA732X_REG_CP_HP2, DA732X_HP_CP_EN |\r\nDA732X_HP_CP_REG | DA732X_HP_CP_PULSESKIP);\r\nsnd_soc_write(codec, DA732X_REG_CP_CTRL1, DA732X_CP_EN |\r\nDA732X_CP_CTRL_CPVDD1);\r\nsnd_soc_write(codec, DA732X_REG_CP_CTRL2,\r\nDA732X_CP_MANAGE_MAGNITUDE | DA732X_CP_BOOST);\r\nsnd_soc_write(codec, DA732X_REG_CP_CTRL3, DA732X_CP_1MHZ);\r\nbreak;\r\ncase DA732X_DISABLE_CP:\r\nsnd_soc_write(codec, DA732X_REG_CLK_EN2, DA732X_CP_CLK_DIS);\r\nsnd_soc_write(codec, DA732X_REG_CP_HP2, DA732X_HP_CP_DIS);\r\nsnd_soc_write(codec, DA732X_REG_CP_CTRL1, DA723X_CP_DIS);\r\nbreak;\r\ndefault:\r\npr_err("Wrong charge pump state\n");\r\nbreak;\r\n}\r\n}\r\nstatic int da732x_hpf_set(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct soc_enum *enum_ctrl = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int reg = enum_ctrl->reg;\r\nunsigned int sel = ucontrol->value.enumerated.item[0];\r\nunsigned int bits;\r\nswitch (sel) {\r\ncase DA732X_HPF_DISABLED:\r\nbits = DA732X_HPF_DIS;\r\nbreak;\r\ncase DA732X_HPF_VOICE:\r\nbits = DA732X_HPF_VOICE_EN;\r\nbreak;\r\ncase DA732X_HPF_MUSIC:\r\nbits = DA732X_HPF_MUSIC_EN;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, reg, DA732X_HPF_MASK, bits);\r\nreturn 0;\r\n}\r\nstatic int da732x_hpf_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct soc_enum *enum_ctrl = (struct soc_enum *)kcontrol->private_value;\r\nunsigned int reg = enum_ctrl->reg;\r\nint val;\r\nval = snd_soc_read(codec, reg) & DA732X_HPF_MASK;\r\nswitch (val) {\r\ncase DA732X_HPF_VOICE_EN:\r\nucontrol->value.enumerated.item[0] = DA732X_HPF_VOICE;\r\nbreak;\r\ncase DA732X_HPF_MUSIC_EN:\r\nucontrol->value.enumerated.item[0] = DA732X_HPF_MUSIC;\r\nbreak;\r\ndefault:\r\nucontrol->value.enumerated.item[0] = DA732X_HPF_DISABLED;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da732x_adc_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nswitch (w->reg) {\r\ncase DA732X_REG_ADC1_PD:\r\nsnd_soc_update_bits(codec, DA732X_REG_CLK_EN3,\r\nDA732X_ADCA_BB_CLK_EN,\r\nDA732X_ADCA_BB_CLK_EN);\r\nbreak;\r\ncase DA732X_REG_ADC2_PD:\r\nsnd_soc_update_bits(codec, DA732X_REG_CLK_EN3,\r\nDA732X_ADCC_BB_CLK_EN,\r\nDA732X_ADCC_BB_CLK_EN);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, w->reg, DA732X_ADC_RST_MASK,\r\nDA732X_ADC_SET_ACT);\r\nsnd_soc_update_bits(codec, w->reg, DA732X_ADC_PD_MASK,\r\nDA732X_ADC_ON);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, w->reg, DA732X_ADC_PD_MASK,\r\nDA732X_ADC_OFF);\r\nsnd_soc_update_bits(codec, w->reg, DA732X_ADC_RST_MASK,\r\nDA732X_ADC_SET_RST);\r\nswitch (w->reg) {\r\ncase DA732X_REG_ADC1_PD:\r\nsnd_soc_update_bits(codec, DA732X_REG_CLK_EN3,\r\nDA732X_ADCA_BB_CLK_EN, 0);\r\nbreak;\r\ncase DA732X_REG_ADC2_PD:\r\nsnd_soc_update_bits(codec, DA732X_REG_CLK_EN3,\r\nDA732X_ADCC_BB_CLK_EN, 0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da732x_out_pga_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << w->shift) | DA732X_OUT_HIZ_EN,\r\n(1 << w->shift) | DA732X_OUT_HIZ_EN);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec, w->reg,\r\n(1 << w->shift) | DA732X_OUT_HIZ_EN,\r\n(1 << w->shift) | DA732X_OUT_HIZ_DIS);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da732x_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu32 aif = 0;\r\nu32 reg_aif;\r\nu32 fs;\r\nreg_aif = dai->driver->base;\r\nswitch (params_width(params)) {\r\ncase 16:\r\naif |= DA732X_AIF_WORD_16;\r\nbreak;\r\ncase 20:\r\naif |= DA732X_AIF_WORD_20;\r\nbreak;\r\ncase 24:\r\naif |= DA732X_AIF_WORD_24;\r\nbreak;\r\ncase 32:\r\naif |= DA732X_AIF_WORD_32;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nfs = DA732X_SR_8KHZ;\r\nbreak;\r\ncase 11025:\r\nfs = DA732X_SR_11_025KHZ;\r\nbreak;\r\ncase 12000:\r\nfs = DA732X_SR_12KHZ;\r\nbreak;\r\ncase 16000:\r\nfs = DA732X_SR_16KHZ;\r\nbreak;\r\ncase 22050:\r\nfs = DA732X_SR_22_05KHZ;\r\nbreak;\r\ncase 24000:\r\nfs = DA732X_SR_24KHZ;\r\nbreak;\r\ncase 32000:\r\nfs = DA732X_SR_32KHZ;\r\nbreak;\r\ncase 44100:\r\nfs = DA732X_SR_44_1KHZ;\r\nbreak;\r\ncase 48000:\r\nfs = DA732X_SR_48KHZ;\r\nbreak;\r\ncase 88100:\r\nfs = DA732X_SR_88_1KHZ;\r\nbreak;\r\ncase 96000:\r\nfs = DA732X_SR_96KHZ;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, reg_aif, DA732X_AIF_WORD_MASK, aif);\r\nsnd_soc_update_bits(codec, DA732X_REG_CLK_CTRL, DA732X_SR1_MASK, fs);\r\nreturn 0;\r\n}\r\nstatic int da732x_set_dai_fmt(struct snd_soc_dai *dai, u32 fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nu32 aif_mclk, pc_count;\r\nu32 reg_aif1, aif1;\r\nu32 reg_aif3, aif3;\r\nswitch (dai->id) {\r\ncase DA732X_DAI_ID1:\r\nreg_aif1 = DA732X_REG_AIFA1;\r\nreg_aif3 = DA732X_REG_AIFA3;\r\npc_count = DA732X_PC_PULSE_AIFA | DA732X_PC_RESYNC_NOT_AUT |\r\nDA732X_PC_SAME;\r\nbreak;\r\ncase DA732X_DAI_ID2:\r\nreg_aif1 = DA732X_REG_AIFB1;\r\nreg_aif3 = DA732X_REG_AIFB3;\r\npc_count = DA732X_PC_PULSE_AIFB | DA732X_PC_RESYNC_NOT_AUT |\r\nDA732X_PC_SAME;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\naif1 = DA732X_AIF_SLAVE;\r\naif_mclk = DA732X_AIFM_FRAME_64 | DA732X_AIFM_SRC_SEL_AIFA;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\naif1 = DA732X_AIF_CLK_FROM_SRC;\r\naif_mclk = DA732X_CLK_GENERATION_AIF_A;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\naif3 = DA732X_AIF_I2S_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\naif3 = DA732X_AIF_RIGHT_J_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\naif3 = DA732X_AIF_LEFT_J_MODE;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\naif3 = DA732X_AIF_DSP_MODE;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif3 |= DA732X_AIF_BCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase SND_SOC_DAIFMT_I2S:\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\naif3 |= DA732X_AIF_BCLK_INV | DA732X_AIF_WCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\naif3 |= DA732X_AIF_BCLK_INV;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\naif3 |= DA732X_AIF_WCLK_INV;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_write(codec, DA732X_REG_AIF_MCLK, aif_mclk);\r\nsnd_soc_update_bits(codec, reg_aif1, DA732X_AIF1_CLK_MASK, aif1);\r\nsnd_soc_update_bits(codec, reg_aif3, DA732X_AIF_BCLK_INV |\r\nDA732X_AIF_WCLK_INV | DA732X_AIF_MODE_MASK, aif3);\r\nsnd_soc_write(codec, DA732X_REG_PC_CTRL, pc_count);\r\nreturn 0;\r\n}\r\nstatic int da732x_set_dai_pll(struct snd_soc_codec *codec, int pll_id,\r\nint source, unsigned int freq_in,\r\nunsigned int freq_out)\r\n{\r\nstruct da732x_priv *da732x = snd_soc_codec_get_drvdata(codec);\r\nint fref, indiv;\r\nu8 div_lo, div_mid, div_hi;\r\nu64 frac_div;\r\nif (freq_out == 0) {\r\nsnd_soc_update_bits(codec, DA732X_REG_PLL_CTRL,\r\nDA732X_PLL_EN, 0);\r\nda732x->pll_en = false;\r\nreturn 0;\r\n}\r\nif (da732x->pll_en)\r\nreturn -EBUSY;\r\nif (source == DA732X_SRCCLK_MCLK) {\r\nswitch (da732x->sysclk) {\r\ncase 11290000:\r\ncase 12288000:\r\ncase 22580000:\r\ncase 24576000:\r\ncase 45160000:\r\ncase 49152000:\r\nsnd_soc_write(codec, DA732X_REG_PLL_CTRL,\r\nDA732X_PLL_BYPASS);\r\nreturn 0;\r\ndefault:\r\ndev_err(codec->dev,\r\n"Cannot use PLL Bypass, invalid SYSCLK rate\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nindiv = da732x_get_input_div(codec, da732x->sysclk);\r\nif (indiv < 0)\r\nreturn indiv;\r\nfref = (da732x->sysclk / indiv);\r\ndiv_hi = freq_out / fref;\r\nfrac_div = (u64)(freq_out % fref) * 8192ULL;\r\ndo_div(frac_div, fref);\r\ndiv_mid = (frac_div >> DA732X_1BYTE_SHIFT) & DA732X_U8_MASK;\r\ndiv_lo = (frac_div) & DA732X_U8_MASK;\r\nsnd_soc_write(codec, DA732X_REG_PLL_DIV_LO, div_lo);\r\nsnd_soc_write(codec, DA732X_REG_PLL_DIV_MID, div_mid);\r\nsnd_soc_write(codec, DA732X_REG_PLL_DIV_HI, div_hi);\r\nsnd_soc_update_bits(codec, DA732X_REG_PLL_CTRL, DA732X_PLL_EN,\r\nDA732X_PLL_EN);\r\nda732x->pll_en = true;\r\nreturn 0;\r\n}\r\nstatic int da732x_set_dai_sysclk(struct snd_soc_dai *dai, int clk_id,\r\nunsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct da732x_priv *da732x = snd_soc_codec_get_drvdata(codec);\r\nda732x->sysclk = freq;\r\nreturn 0;\r\n}\r\nstatic bool da732x_volatile(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase DA732X_REG_HPL_DAC_OFF_CNTL:\r\ncase DA732X_REG_HPR_DAC_OFF_CNTL:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void da732x_dac_offset_adjust(struct snd_soc_codec *codec)\r\n{\r\nu8 offset[DA732X_HP_DACS];\r\nu8 sign[DA732X_HP_DACS];\r\nu8 step = DA732X_DAC_OFFSET_STEP;\r\nsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFFSET,\r\nDA732X_HP_DAC_OFFSET_TRIM_VAL);\r\nsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFFSET,\r\nDA732X_HP_DAC_OFFSET_TRIM_VAL);\r\nsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFF_CNTL,\r\nDA732X_HP_DAC_OFF_CALIBRATION |\r\nDA732X_HP_DAC_OFF_SCALE_STEPS);\r\nsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFF_CNTL,\r\nDA732X_HP_DAC_OFF_CALIBRATION |\r\nDA732X_HP_DAC_OFF_SCALE_STEPS);\r\nmsleep(DA732X_WAIT_FOR_STABILIZATION);\r\nsign[DA732X_HPL_DAC] = (snd_soc_read(codec, DA732X_REG_HPL_DAC_OFF_CNTL) &\r\nDA732X_HP_DAC_OFF_CNTL_COMPO);\r\nsign[DA732X_HPR_DAC] = (snd_soc_read(codec, DA732X_REG_HPR_DAC_OFF_CNTL) &\r\nDA732X_HP_DAC_OFF_CNTL_COMPO);\r\noffset[DA732X_HPL_DAC] = sign[DA732X_HPL_DAC] << DA732X_HP_DAC_COMPO_SHIFT;\r\noffset[DA732X_HPR_DAC] = sign[DA732X_HPR_DAC] << DA732X_HP_DAC_COMPO_SHIFT;\r\ndo {\r\noffset[DA732X_HPL_DAC] |= step;\r\noffset[DA732X_HPR_DAC] |= step;\r\nsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFFSET,\r\n~offset[DA732X_HPL_DAC] & DA732X_HP_DAC_OFF_MASK);\r\nsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFFSET,\r\n~offset[DA732X_HPR_DAC] & DA732X_HP_DAC_OFF_MASK);\r\nmsleep(DA732X_WAIT_FOR_STABILIZATION);\r\nif ((snd_soc_read(codec, DA732X_REG_HPL_DAC_OFF_CNTL) &\r\nDA732X_HP_DAC_OFF_CNTL_COMPO) ^ sign[DA732X_HPL_DAC])\r\noffset[DA732X_HPL_DAC] &= ~step;\r\nif ((snd_soc_read(codec, DA732X_REG_HPR_DAC_OFF_CNTL) &\r\nDA732X_HP_DAC_OFF_CNTL_COMPO) ^ sign[DA732X_HPR_DAC])\r\noffset[DA732X_HPR_DAC] &= ~step;\r\nstep >>= 1;\r\n} while (step);\r\nsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFFSET,\r\n~offset[DA732X_HPL_DAC] & DA732X_HP_DAC_OFF_MASK);\r\nsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFFSET,\r\n~offset[DA732X_HPR_DAC] & DA732X_HP_DAC_OFF_MASK);\r\nsnd_soc_write(codec, DA732X_REG_HPL_DAC_OFF_CNTL,\r\nDA732X_HP_DAC_OFF_SCALE_STEPS);\r\nsnd_soc_write(codec, DA732X_REG_HPR_DAC_OFF_CNTL,\r\nDA732X_HP_DAC_OFF_SCALE_STEPS);\r\n}\r\nstatic void da732x_output_offset_adjust(struct snd_soc_codec *codec)\r\n{\r\nu8 offset[DA732X_HP_AMPS];\r\nu8 sign[DA732X_HP_AMPS];\r\nu8 step = DA732X_OUTPUT_OFFSET_STEP;\r\noffset[DA732X_HPL_AMP] = DA732X_HP_OUT_TRIM_VAL;\r\noffset[DA732X_HPR_AMP] = DA732X_HP_OUT_TRIM_VAL;\r\nsnd_soc_write(codec, DA732X_REG_HPL_OUT_OFFSET, DA732X_HP_OUT_TRIM_VAL);\r\nsnd_soc_write(codec, DA732X_REG_HPR_OUT_OFFSET, DA732X_HP_OUT_TRIM_VAL);\r\nsnd_soc_write(codec, DA732X_REG_HPL,\r\nDA732X_HP_OUT_COMP | DA732X_HP_OUT_EN);\r\nsnd_soc_write(codec, DA732X_REG_HPR,\r\nDA732X_HP_OUT_COMP | DA732X_HP_OUT_EN);\r\nmsleep(DA732X_WAIT_FOR_STABILIZATION);\r\nsign[DA732X_HPL_AMP] = snd_soc_read(codec, DA732X_REG_HPL) &\r\nDA732X_HP_OUT_COMPO;\r\nsign[DA732X_HPR_AMP] = snd_soc_read(codec, DA732X_REG_HPR) &\r\nDA732X_HP_OUT_COMPO;\r\nsnd_soc_write(codec, DA732X_REG_HPL, DA732X_HP_OUT_COMP |\r\n(sign[DA732X_HPL_AMP] >> DA732X_HP_OUT_COMPO_SHIFT) |\r\nDA732X_HP_OUT_EN);\r\nsnd_soc_write(codec, DA732X_REG_HPR, DA732X_HP_OUT_COMP |\r\n(sign[DA732X_HPR_AMP] >> DA732X_HP_OUT_COMPO_SHIFT) |\r\nDA732X_HP_OUT_EN);\r\ndo {\r\noffset[DA732X_HPL_AMP] |= step;\r\noffset[DA732X_HPR_AMP] |= step;\r\nsnd_soc_write(codec, DA732X_REG_HPL_OUT_OFFSET,\r\noffset[DA732X_HPL_AMP]);\r\nsnd_soc_write(codec, DA732X_REG_HPR_OUT_OFFSET,\r\noffset[DA732X_HPR_AMP]);\r\nmsleep(DA732X_WAIT_FOR_STABILIZATION);\r\nif ((snd_soc_read(codec, DA732X_REG_HPL) &\r\nDA732X_HP_OUT_COMPO) ^ sign[DA732X_HPL_AMP])\r\noffset[DA732X_HPL_AMP] &= ~step;\r\nif ((snd_soc_read(codec, DA732X_REG_HPR) &\r\nDA732X_HP_OUT_COMPO) ^ sign[DA732X_HPR_AMP])\r\noffset[DA732X_HPR_AMP] &= ~step;\r\nstep >>= 1;\r\n} while (step);\r\nsnd_soc_write(codec, DA732X_REG_HPL_OUT_OFFSET, offset[DA732X_HPL_AMP]);\r\nsnd_soc_write(codec, DA732X_REG_HPR_OUT_OFFSET, offset[DA732X_HPR_AMP]);\r\n}\r\nstatic void da732x_hp_dc_offset_cancellation(struct snd_soc_codec *codec)\r\n{\r\nsnd_soc_write(codec, DA732X_REG_DAC1_SOFTMUTE, DA732X_SOFTMUTE_EN |\r\nDA732X_GAIN_RAMPED | DA732X_16_SAMPLES);\r\nsnd_soc_write(codec, DA732X_REG_DAC1_SEL, DA732X_DACL_EN |\r\nDA732X_DACR_EN | DA732X_DACL_SDM | DA732X_DACR_SDM |\r\nDA732X_DACL_MUTE | DA732X_DACR_MUTE);\r\nsnd_soc_write(codec, DA732X_REG_HPL, DA732X_HP_OUT_DAC_EN |\r\nDA732X_HP_OUT_MUTE | DA732X_HP_OUT_EN);\r\nsnd_soc_write(codec, DA732X_REG_HPR, DA732X_HP_OUT_EN |\r\nDA732X_HP_OUT_MUTE | DA732X_HP_OUT_DAC_EN);\r\nda732x_dac_offset_adjust(codec);\r\nda732x_output_offset_adjust(codec);\r\nsnd_soc_write(codec, DA732X_REG_DAC1_SEL, DA732X_DACS_DIS);\r\nsnd_soc_write(codec, DA732X_REG_HPL, DA732X_HP_DIS);\r\nsnd_soc_write(codec, DA732X_REG_HPR, DA732X_HP_DIS);\r\n}\r\nstatic int da732x_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct da732x_priv *da732x = snd_soc_codec_get_drvdata(codec);\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\nsnd_soc_update_bits(codec, DA732X_REG_BIAS_EN,\r\nDA732X_BIAS_BOOST_MASK,\r\nDA732X_BIAS_BOOST_100PC);\r\nbreak;\r\ncase SND_SOC_BIAS_PREPARE:\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nsnd_soc_write(codec, DA732X_REG_REF1,\r\nDA732X_VMID_FASTCHG);\r\nsnd_soc_write(codec, DA732X_REG_BIAS_EN,\r\nDA732X_BIAS_EN);\r\nmdelay(DA732X_STARTUP_DELAY);\r\nsnd_soc_write(codec, DA732X_REG_REF1,\r\nDA732X_REFBUFX2_EN);\r\nsnd_soc_write(codec, DA732X_REG_DATA_ROUTE,\r\nDA732X_BYPASS_DSP);\r\nsnd_soc_write(codec, DA732X_REG_DSP_CTRL,\r\nDA732X_DIGITAL_EN);\r\nsnd_soc_write(codec, DA732X_REG_SPARE1_OUT,\r\nDA732X_HP_DRIVER_EN |\r\nDA732X_HP_GATE_LOW |\r\nDA732X_HP_LOOP_GAIN_CTRL);\r\nsnd_soc_write(codec, DA732X_REG_HP_LIN1_GNDSEL,\r\nDA732X_HP_OUT_GNDSEL);\r\nda732x_set_charge_pump(codec, DA732X_ENABLE_CP);\r\nsnd_soc_write(codec, DA732X_REG_CLK_EN1,\r\nDA732X_SYS3_CLK_EN | DA732X_PC_CLK_EN);\r\nsnd_soc_write(codec, DA732X_REG_INP_ZC_EN,\r\nDA732X_MIC1_PRE_ZC_EN |\r\nDA732X_MIC1_ZC_EN |\r\nDA732X_MIC2_PRE_ZC_EN |\r\nDA732X_MIC2_ZC_EN |\r\nDA732X_AUXL_ZC_EN |\r\nDA732X_AUXR_ZC_EN |\r\nDA732X_MIC3_PRE_ZC_EN |\r\nDA732X_MIC3_ZC_EN);\r\nsnd_soc_write(codec, DA732X_REG_OUT_ZC_EN,\r\nDA732X_HPL_ZC_EN | DA732X_HPR_ZC_EN |\r\nDA732X_LIN2_ZC_EN | DA732X_LIN3_ZC_EN |\r\nDA732X_LIN4_ZC_EN);\r\nda732x_hp_dc_offset_cancellation(codec);\r\nregcache_cache_only(da732x->regmap, false);\r\nregcache_sync(da732x->regmap);\r\n} else {\r\nsnd_soc_update_bits(codec, DA732X_REG_BIAS_EN,\r\nDA732X_BIAS_BOOST_MASK,\r\nDA732X_BIAS_BOOST_50PC);\r\nsnd_soc_update_bits(codec, DA732X_REG_PLL_CTRL,\r\nDA732X_PLL_EN, 0);\r\nda732x->pll_en = false;\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregcache_cache_only(da732x->regmap, true);\r\nda732x_set_charge_pump(codec, DA732X_DISABLE_CP);\r\nsnd_soc_update_bits(codec, DA732X_REG_BIAS_EN, DA732X_BIAS_EN,\r\nDA732X_BIAS_DIS);\r\nda732x->pll_en = false;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int da732x_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct da732x_priv *da732x;\r\nunsigned int reg;\r\nint ret;\r\nda732x = devm_kzalloc(&i2c->dev, sizeof(struct da732x_priv),\r\nGFP_KERNEL);\r\nif (!da732x)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(i2c, da732x);\r\nda732x->regmap = devm_regmap_init_i2c(i2c, &da732x_regmap);\r\nif (IS_ERR(da732x->regmap)) {\r\nret = PTR_ERR(da732x->regmap);\r\ndev_err(&i2c->dev, "Failed to initialize regmap\n");\r\ngoto err;\r\n}\r\nret = regmap_read(da732x->regmap, DA732X_REG_ID, &reg);\r\nif (ret < 0) {\r\ndev_err(&i2c->dev, "Failed to read ID register: %d\n", ret);\r\ngoto err;\r\n}\r\ndev_info(&i2c->dev, "Revision: %d.%d\n",\r\n(reg & DA732X_ID_MAJOR_MASK) >> 4,\r\n(reg & DA732X_ID_MINOR_MASK));\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_da732x,\r\nda732x_dai, ARRAY_SIZE(da732x_dai));\r\nif (ret != 0)\r\ndev_err(&i2c->dev, "Failed to register codec.\n");\r\nerr:\r\nreturn ret;\r\n}\r\nstatic int da732x_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
