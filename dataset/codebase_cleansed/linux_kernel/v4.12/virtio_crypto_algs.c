static u64 virtio_crypto_alg_sg_nents_length(struct scatterlist *sg)\r\n{\r\nu64 total = 0;\r\nfor (total = 0; sg; sg = sg_next(sg))\r\ntotal += sg->length;\r\nreturn total;\r\n}\r\nstatic int\r\nvirtio_crypto_alg_validate_key(int key_len, uint32_t *alg)\r\n{\r\nswitch (key_len) {\r\ncase AES_KEYSIZE_128:\r\ncase AES_KEYSIZE_192:\r\ncase AES_KEYSIZE_256:\r\n*alg = VIRTIO_CRYPTO_CIPHER_AES_CBC;\r\nbreak;\r\ndefault:\r\npr_err("virtio_crypto: Unsupported key length: %d\n",\r\nkey_len);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int virtio_crypto_alg_ablkcipher_init_session(\r\nstruct virtio_crypto_ablkcipher_ctx *ctx,\r\nuint32_t alg, const uint8_t *key,\r\nunsigned int keylen,\r\nint encrypt)\r\n{\r\nstruct scatterlist outhdr, key_sg, inhdr, *sgs[3];\r\nunsigned int tmp;\r\nstruct virtio_crypto *vcrypto = ctx->vcrypto;\r\nint op = encrypt ? VIRTIO_CRYPTO_OP_ENCRYPT : VIRTIO_CRYPTO_OP_DECRYPT;\r\nint err;\r\nunsigned int num_out = 0, num_in = 0;\r\nuint8_t *cipher_key = kmalloc(keylen, GFP_ATOMIC);\r\nif (!cipher_key)\r\nreturn -ENOMEM;\r\nmemcpy(cipher_key, key, keylen);\r\nspin_lock(&vcrypto->ctrl_lock);\r\nvcrypto->ctrl.header.opcode =\r\ncpu_to_le32(VIRTIO_CRYPTO_CIPHER_CREATE_SESSION);\r\nvcrypto->ctrl.header.algo = cpu_to_le32(alg);\r\nvcrypto->ctrl.header.queue_id = 0;\r\nvcrypto->input.status = cpu_to_le32(VIRTIO_CRYPTO_ERR);\r\nvcrypto->ctrl.u.sym_create_session.op_type =\r\ncpu_to_le32(VIRTIO_CRYPTO_SYM_OP_CIPHER);\r\nvcrypto->ctrl.u.sym_create_session.u.cipher.para.algo =\r\nvcrypto->ctrl.header.algo;\r\nvcrypto->ctrl.u.sym_create_session.u.cipher.para.keylen =\r\ncpu_to_le32(keylen);\r\nvcrypto->ctrl.u.sym_create_session.u.cipher.para.op =\r\ncpu_to_le32(op);\r\nsg_init_one(&outhdr, &vcrypto->ctrl, sizeof(vcrypto->ctrl));\r\nsgs[num_out++] = &outhdr;\r\nsg_init_one(&key_sg, cipher_key, keylen);\r\nsgs[num_out++] = &key_sg;\r\nsg_init_one(&inhdr, &vcrypto->input, sizeof(vcrypto->input));\r\nsgs[num_out + num_in++] = &inhdr;\r\nerr = virtqueue_add_sgs(vcrypto->ctrl_vq, sgs, num_out,\r\nnum_in, vcrypto, GFP_ATOMIC);\r\nif (err < 0) {\r\nspin_unlock(&vcrypto->ctrl_lock);\r\nkzfree(cipher_key);\r\nreturn err;\r\n}\r\nvirtqueue_kick(vcrypto->ctrl_vq);\r\nwhile (!virtqueue_get_buf(vcrypto->ctrl_vq, &tmp) &&\r\n!virtqueue_is_broken(vcrypto->ctrl_vq))\r\ncpu_relax();\r\nif (le32_to_cpu(vcrypto->input.status) != VIRTIO_CRYPTO_OK) {\r\nspin_unlock(&vcrypto->ctrl_lock);\r\npr_err("virtio_crypto: Create session failed status: %u\n",\r\nle32_to_cpu(vcrypto->input.status));\r\nkzfree(cipher_key);\r\nreturn -EINVAL;\r\n}\r\nif (encrypt)\r\nctx->enc_sess_info.session_id =\r\nle64_to_cpu(vcrypto->input.session_id);\r\nelse\r\nctx->dec_sess_info.session_id =\r\nle64_to_cpu(vcrypto->input.session_id);\r\nspin_unlock(&vcrypto->ctrl_lock);\r\nkzfree(cipher_key);\r\nreturn 0;\r\n}\r\nstatic int virtio_crypto_alg_ablkcipher_close_session(\r\nstruct virtio_crypto_ablkcipher_ctx *ctx,\r\nint encrypt)\r\n{\r\nstruct scatterlist outhdr, status_sg, *sgs[2];\r\nunsigned int tmp;\r\nstruct virtio_crypto_destroy_session_req *destroy_session;\r\nstruct virtio_crypto *vcrypto = ctx->vcrypto;\r\nint err;\r\nunsigned int num_out = 0, num_in = 0;\r\nspin_lock(&vcrypto->ctrl_lock);\r\nvcrypto->ctrl_status.status = VIRTIO_CRYPTO_ERR;\r\nvcrypto->ctrl.header.opcode =\r\ncpu_to_le32(VIRTIO_CRYPTO_CIPHER_DESTROY_SESSION);\r\nvcrypto->ctrl.header.queue_id = 0;\r\ndestroy_session = &vcrypto->ctrl.u.destroy_session;\r\nif (encrypt)\r\ndestroy_session->session_id =\r\ncpu_to_le64(ctx->enc_sess_info.session_id);\r\nelse\r\ndestroy_session->session_id =\r\ncpu_to_le64(ctx->dec_sess_info.session_id);\r\nsg_init_one(&outhdr, &vcrypto->ctrl, sizeof(vcrypto->ctrl));\r\nsgs[num_out++] = &outhdr;\r\nsg_init_one(&status_sg, &vcrypto->ctrl_status.status,\r\nsizeof(vcrypto->ctrl_status.status));\r\nsgs[num_out + num_in++] = &status_sg;\r\nerr = virtqueue_add_sgs(vcrypto->ctrl_vq, sgs, num_out,\r\nnum_in, vcrypto, GFP_ATOMIC);\r\nif (err < 0) {\r\nspin_unlock(&vcrypto->ctrl_lock);\r\nreturn err;\r\n}\r\nvirtqueue_kick(vcrypto->ctrl_vq);\r\nwhile (!virtqueue_get_buf(vcrypto->ctrl_vq, &tmp) &&\r\n!virtqueue_is_broken(vcrypto->ctrl_vq))\r\ncpu_relax();\r\nif (vcrypto->ctrl_status.status != VIRTIO_CRYPTO_OK) {\r\nspin_unlock(&vcrypto->ctrl_lock);\r\npr_err("virtio_crypto: Close session failed status: %u, session_id: 0x%llx\n",\r\nvcrypto->ctrl_status.status,\r\ndestroy_session->session_id);\r\nreturn -EINVAL;\r\n}\r\nspin_unlock(&vcrypto->ctrl_lock);\r\nreturn 0;\r\n}\r\nstatic int virtio_crypto_alg_ablkcipher_init_sessions(\r\nstruct virtio_crypto_ablkcipher_ctx *ctx,\r\nconst uint8_t *key, unsigned int keylen)\r\n{\r\nuint32_t alg;\r\nint ret;\r\nstruct virtio_crypto *vcrypto = ctx->vcrypto;\r\nif (keylen > vcrypto->max_cipher_key_len) {\r\npr_err("virtio_crypto: the key is too long\n");\r\ngoto bad_key;\r\n}\r\nif (virtio_crypto_alg_validate_key(keylen, &alg))\r\ngoto bad_key;\r\nret = virtio_crypto_alg_ablkcipher_init_session(ctx,\r\nalg, key, keylen, 1);\r\nif (ret)\r\nreturn ret;\r\nret = virtio_crypto_alg_ablkcipher_init_session(ctx,\r\nalg, key, keylen, 0);\r\nif (ret) {\r\nvirtio_crypto_alg_ablkcipher_close_session(ctx, 1);\r\nreturn ret;\r\n}\r\nreturn 0;\r\nbad_key:\r\ncrypto_tfm_set_flags(ctx->tfm, CRYPTO_TFM_RES_BAD_KEY_LEN);\r\nreturn -EINVAL;\r\n}\r\nstatic int virtio_crypto_ablkcipher_setkey(struct crypto_ablkcipher *tfm,\r\nconst uint8_t *key,\r\nunsigned int keylen)\r\n{\r\nstruct virtio_crypto_ablkcipher_ctx *ctx = crypto_ablkcipher_ctx(tfm);\r\nint ret;\r\nif (!ctx->vcrypto) {\r\nint node = virtio_crypto_get_current_node();\r\nstruct virtio_crypto *vcrypto =\r\nvirtcrypto_get_dev_node(node);\r\nif (!vcrypto) {\r\npr_err("virtio_crypto: Could not find a virtio device in the system");\r\nreturn -ENODEV;\r\n}\r\nctx->vcrypto = vcrypto;\r\n} else {\r\nvirtio_crypto_alg_ablkcipher_close_session(ctx, 1);\r\nvirtio_crypto_alg_ablkcipher_close_session(ctx, 0);\r\n}\r\nret = virtio_crypto_alg_ablkcipher_init_sessions(ctx, key, keylen);\r\nif (ret) {\r\nvirtcrypto_dev_put(ctx->vcrypto);\r\nctx->vcrypto = NULL;\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\n__virtio_crypto_ablkcipher_do_req(struct virtio_crypto_request *vc_req,\r\nstruct ablkcipher_request *req,\r\nstruct data_queue *data_vq)\r\n{\r\nstruct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(req);\r\nunsigned int ivsize = crypto_ablkcipher_ivsize(tfm);\r\nstruct virtio_crypto_ablkcipher_ctx *ctx = vc_req->ablkcipher_ctx;\r\nstruct virtio_crypto *vcrypto = ctx->vcrypto;\r\nstruct virtio_crypto_op_data_req *req_data;\r\nint src_nents, dst_nents;\r\nint err;\r\nunsigned long flags;\r\nstruct scatterlist outhdr, iv_sg, status_sg, **sgs;\r\nint i;\r\nu64 dst_len;\r\nunsigned int num_out = 0, num_in = 0;\r\nint sg_total;\r\nuint8_t *iv;\r\nsrc_nents = sg_nents_for_len(req->src, req->nbytes);\r\ndst_nents = sg_nents(req->dst);\r\npr_debug("virtio_crypto: Number of sgs (src_nents: %d, dst_nents: %d)\n",\r\nsrc_nents, dst_nents);\r\nsg_total = src_nents + dst_nents + 3;\r\nsgs = kzalloc_node(sg_total * sizeof(*sgs), GFP_ATOMIC,\r\ndev_to_node(&vcrypto->vdev->dev));\r\nif (!sgs)\r\nreturn -ENOMEM;\r\nreq_data = kzalloc_node(sizeof(*req_data), GFP_ATOMIC,\r\ndev_to_node(&vcrypto->vdev->dev));\r\nif (!req_data) {\r\nkfree(sgs);\r\nreturn -ENOMEM;\r\n}\r\nvc_req->req_data = req_data;\r\nvc_req->type = VIRTIO_CRYPTO_SYM_OP_CIPHER;\r\nif (vc_req->encrypt) {\r\nreq_data->header.session_id =\r\ncpu_to_le64(ctx->enc_sess_info.session_id);\r\nreq_data->header.opcode =\r\ncpu_to_le32(VIRTIO_CRYPTO_CIPHER_ENCRYPT);\r\n} else {\r\nreq_data->header.session_id =\r\ncpu_to_le64(ctx->dec_sess_info.session_id);\r\nreq_data->header.opcode =\r\ncpu_to_le32(VIRTIO_CRYPTO_CIPHER_DECRYPT);\r\n}\r\nreq_data->u.sym_req.op_type = cpu_to_le32(VIRTIO_CRYPTO_SYM_OP_CIPHER);\r\nreq_data->u.sym_req.u.cipher.para.iv_len = cpu_to_le32(ivsize);\r\nreq_data->u.sym_req.u.cipher.para.src_data_len =\r\ncpu_to_le32(req->nbytes);\r\ndst_len = virtio_crypto_alg_sg_nents_length(req->dst);\r\nif (unlikely(dst_len > U32_MAX)) {\r\npr_err("virtio_crypto: The dst_len is beyond U32_MAX\n");\r\nerr = -EINVAL;\r\ngoto free;\r\n}\r\npr_debug("virtio_crypto: src_len: %u, dst_len: %llu\n",\r\nreq->nbytes, dst_len);\r\nif (unlikely(req->nbytes + dst_len + ivsize +\r\nsizeof(vc_req->status) > vcrypto->max_size)) {\r\npr_err("virtio_crypto: The length is too big\n");\r\nerr = -EINVAL;\r\ngoto free;\r\n}\r\nreq_data->u.sym_req.u.cipher.para.dst_data_len =\r\ncpu_to_le32((uint32_t)dst_len);\r\nsg_init_one(&outhdr, req_data, sizeof(*req_data));\r\nsgs[num_out++] = &outhdr;\r\niv = kzalloc_node(ivsize, GFP_ATOMIC,\r\ndev_to_node(&vcrypto->vdev->dev));\r\nif (!iv) {\r\nerr = -ENOMEM;\r\ngoto free;\r\n}\r\nmemcpy(iv, req->info, ivsize);\r\nsg_init_one(&iv_sg, iv, ivsize);\r\nsgs[num_out++] = &iv_sg;\r\nvc_req->iv = iv;\r\nfor (i = 0; i < src_nents; i++)\r\nsgs[num_out++] = &req->src[i];\r\nfor (i = 0; i < dst_nents; i++)\r\nsgs[num_out + num_in++] = &req->dst[i];\r\nsg_init_one(&status_sg, &vc_req->status, sizeof(vc_req->status));\r\nsgs[num_out + num_in++] = &status_sg;\r\nvc_req->sgs = sgs;\r\nspin_lock_irqsave(&data_vq->lock, flags);\r\nerr = virtqueue_add_sgs(data_vq->vq, sgs, num_out,\r\nnum_in, vc_req, GFP_ATOMIC);\r\nvirtqueue_kick(data_vq->vq);\r\nspin_unlock_irqrestore(&data_vq->lock, flags);\r\nif (unlikely(err < 0))\r\ngoto free_iv;\r\nreturn 0;\r\nfree_iv:\r\nkzfree(iv);\r\nfree:\r\nkzfree(req_data);\r\nkfree(sgs);\r\nreturn err;\r\n}\r\nstatic int virtio_crypto_ablkcipher_encrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *atfm = crypto_ablkcipher_reqtfm(req);\r\nstruct virtio_crypto_ablkcipher_ctx *ctx = crypto_ablkcipher_ctx(atfm);\r\nstruct virtio_crypto_request *vc_req = ablkcipher_request_ctx(req);\r\nstruct virtio_crypto *vcrypto = ctx->vcrypto;\r\nstruct data_queue *data_vq = &vcrypto->data_vq[0];\r\nvc_req->ablkcipher_ctx = ctx;\r\nvc_req->ablkcipher_req = req;\r\nvc_req->encrypt = true;\r\nvc_req->dataq = data_vq;\r\nreturn crypto_transfer_cipher_request_to_engine(data_vq->engine, req);\r\n}\r\nstatic int virtio_crypto_ablkcipher_decrypt(struct ablkcipher_request *req)\r\n{\r\nstruct crypto_ablkcipher *atfm = crypto_ablkcipher_reqtfm(req);\r\nstruct virtio_crypto_ablkcipher_ctx *ctx = crypto_ablkcipher_ctx(atfm);\r\nstruct virtio_crypto_request *vc_req = ablkcipher_request_ctx(req);\r\nstruct virtio_crypto *vcrypto = ctx->vcrypto;\r\nstruct data_queue *data_vq = &vcrypto->data_vq[0];\r\nvc_req->ablkcipher_ctx = ctx;\r\nvc_req->ablkcipher_req = req;\r\nvc_req->encrypt = false;\r\nvc_req->dataq = data_vq;\r\nreturn crypto_transfer_cipher_request_to_engine(data_vq->engine, req);\r\n}\r\nstatic int virtio_crypto_ablkcipher_init(struct crypto_tfm *tfm)\r\n{\r\nstruct virtio_crypto_ablkcipher_ctx *ctx = crypto_tfm_ctx(tfm);\r\ntfm->crt_ablkcipher.reqsize = sizeof(struct virtio_crypto_request);\r\nctx->tfm = tfm;\r\nreturn 0;\r\n}\r\nstatic void virtio_crypto_ablkcipher_exit(struct crypto_tfm *tfm)\r\n{\r\nstruct virtio_crypto_ablkcipher_ctx *ctx = crypto_tfm_ctx(tfm);\r\nif (!ctx->vcrypto)\r\nreturn;\r\nvirtio_crypto_alg_ablkcipher_close_session(ctx, 1);\r\nvirtio_crypto_alg_ablkcipher_close_session(ctx, 0);\r\nvirtcrypto_dev_put(ctx->vcrypto);\r\nctx->vcrypto = NULL;\r\n}\r\nint virtio_crypto_ablkcipher_crypt_req(\r\nstruct crypto_engine *engine,\r\nstruct ablkcipher_request *req)\r\n{\r\nstruct virtio_crypto_request *vc_req = ablkcipher_request_ctx(req);\r\nstruct data_queue *data_vq = vc_req->dataq;\r\nint ret;\r\nret = __virtio_crypto_ablkcipher_do_req(vc_req, req, data_vq);\r\nif (ret < 0)\r\nreturn ret;\r\nvirtqueue_kick(data_vq->vq);\r\nreturn 0;\r\n}\r\nvoid virtio_crypto_ablkcipher_finalize_req(\r\nstruct virtio_crypto_request *vc_req,\r\nstruct ablkcipher_request *req,\r\nint err)\r\n{\r\ncrypto_finalize_cipher_request(vc_req->dataq->engine, req, err);\r\nvirtcrypto_clear_request(vc_req);\r\n}\r\nint virtio_crypto_algs_register(void)\r\n{\r\nint ret = 0;\r\nmutex_lock(&algs_lock);\r\nif (++virtio_crypto_active_devs != 1)\r\ngoto unlock;\r\nret = crypto_register_algs(virtio_crypto_algs,\r\nARRAY_SIZE(virtio_crypto_algs));\r\nif (ret)\r\nvirtio_crypto_active_devs--;\r\nunlock:\r\nmutex_unlock(&algs_lock);\r\nreturn ret;\r\n}\r\nvoid virtio_crypto_algs_unregister(void)\r\n{\r\nmutex_lock(&algs_lock);\r\nif (--virtio_crypto_active_devs != 0)\r\ngoto unlock;\r\ncrypto_unregister_algs(virtio_crypto_algs,\r\nARRAY_SIZE(virtio_crypto_algs));\r\nunlock:\r\nmutex_unlock(&algs_lock);\r\n}
