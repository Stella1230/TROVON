static int img_spdif_out_suspend(struct device *dev)\r\n{\r\nstruct img_spdif_out *spdif = dev_get_drvdata(dev);\r\nclk_disable_unprepare(spdif->clk_ref);\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_resume(struct device *dev)\r\n{\r\nstruct img_spdif_out *spdif = dev_get_drvdata(dev);\r\nint ret;\r\nret = clk_prepare_enable(spdif->clk_ref);\r\nif (ret) {\r\ndev_err(dev, "clk_enable failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void img_spdif_out_writel(struct img_spdif_out *spdif, u32 val,\r\nu32 reg)\r\n{\r\nwritel(val, spdif->base + reg);\r\n}\r\nstatic inline u32 img_spdif_out_readl(struct img_spdif_out *spdif, u32 reg)\r\n{\r\nreturn readl(spdif->base + reg);\r\n}\r\nstatic void img_spdif_out_reset(struct img_spdif_out *spdif)\r\n{\r\nu32 ctl, status_low, status_high;\r\nctl = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CTL) &\r\n~IMG_SPDIF_OUT_CTL_SRT_MASK;\r\nstatus_low = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSL);\r\nstatus_high = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSH_UV);\r\nreset_control_assert(spdif->rst);\r\nreset_control_deassert(spdif->rst);\r\nimg_spdif_out_writel(spdif, ctl, IMG_SPDIF_OUT_CTL);\r\nimg_spdif_out_writel(spdif, status_low, IMG_SPDIF_OUT_CSL);\r\nimg_spdif_out_writel(spdif, status_high, IMG_SPDIF_OUT_CSH_UV);\r\n}\r\nstatic int img_spdif_out_info(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_info *uinfo)\r\n{\r\nuinfo->type = SNDRV_CTL_ELEM_TYPE_IEC958;\r\nuinfo->count = 1;\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_get_status_mask(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nucontrol->value.iec958.status[0] = 0xff;\r\nucontrol->value.iec958.status[1] = 0xff;\r\nucontrol->value.iec958.status[2] = 0xff;\r\nucontrol->value.iec958.status[3] = 0xff;\r\nucontrol->value.iec958.status[4] = 0xff;\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_get_status(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct img_spdif_out *spdif = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 reg;\r\nunsigned long flags;\r\nspin_lock_irqsave(&spdif->lock, flags);\r\nreg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSL);\r\nucontrol->value.iec958.status[0] = reg & 0xff;\r\nucontrol->value.iec958.status[1] = (reg >> 8) & 0xff;\r\nucontrol->value.iec958.status[2] = (reg >> 16) & 0xff;\r\nucontrol->value.iec958.status[3] = (reg >> 24) & 0xff;\r\nreg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSH_UV);\r\nucontrol->value.iec958.status[4] =\r\n(reg & IMG_SPDIF_OUT_CSH_UV_CSH_MASK) >>\r\nIMG_SPDIF_OUT_CSH_UV_CSH_SHIFT;\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_set_status(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_dai *cpu_dai = snd_kcontrol_chip(kcontrol);\r\nstruct img_spdif_out *spdif = snd_soc_dai_get_drvdata(cpu_dai);\r\nu32 reg;\r\nunsigned long flags;\r\nreg = ((u32)ucontrol->value.iec958.status[3] << 24);\r\nreg |= ((u32)ucontrol->value.iec958.status[2] << 16);\r\nreg |= ((u32)ucontrol->value.iec958.status[1] << 8);\r\nreg |= (u32)ucontrol->value.iec958.status[0];\r\nspin_lock_irqsave(&spdif->lock, flags);\r\nimg_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CSL);\r\nreg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CSH_UV);\r\nreg &= ~IMG_SPDIF_OUT_CSH_UV_CSH_MASK;\r\nreg |= (u32)ucontrol->value.iec958.status[4] <<\r\nIMG_SPDIF_OUT_CSH_UV_CSH_SHIFT;\r\nimg_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CSH_UV);\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_trigger(struct snd_pcm_substream *substream, int cmd,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct img_spdif_out *spdif = snd_soc_dai_get_drvdata(dai);\r\nu32 reg;\r\nunsigned long flags;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nreg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CTL);\r\nreg |= IMG_SPDIF_OUT_CTL_SRT_MASK;\r\nimg_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CTL);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nspin_lock_irqsave(&spdif->lock, flags);\r\nimg_spdif_out_reset(spdif);\r\nspin_unlock_irqrestore(&spdif->lock, flags);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct img_spdif_out *spdif = snd_soc_dai_get_drvdata(dai);\r\nunsigned int channels;\r\nlong pre_div_a, pre_div_b, diff_a, diff_b, rate, clk_rate;\r\nu32 reg;\r\nsnd_pcm_format_t format;\r\nrate = params_rate(params);\r\nformat = params_format(params);\r\nchannels = params_channels(params);\r\ndev_dbg(spdif->dev, "hw_params rate %ld channels %u format %u\n",\r\nrate, channels, format);\r\nif (format != SNDRV_PCM_FORMAT_S32_LE)\r\nreturn -EINVAL;\r\nif (channels != 2)\r\nreturn -EINVAL;\r\npre_div_a = clk_round_rate(spdif->clk_ref, rate * 256);\r\nif (pre_div_a < 0)\r\nreturn pre_div_a;\r\npre_div_b = clk_round_rate(spdif->clk_ref, rate * 384);\r\nif (pre_div_b < 0)\r\nreturn pre_div_b;\r\ndiff_a = abs((pre_div_a / 256) - rate);\r\ndiff_b = abs((pre_div_b / 384) - rate);\r\nif (diff_a > diff_b)\r\nclk_set_rate(spdif->clk_ref, pre_div_b);\r\nelse\r\nclk_set_rate(spdif->clk_ref, pre_div_a);\r\nclk_rate = clk_get_rate(spdif->clk_ref);\r\ndiff_a = abs((clk_rate / 256) - rate);\r\ndiff_b = abs((clk_rate / 384) - rate);\r\nreg = img_spdif_out_readl(spdif, IMG_SPDIF_OUT_CTL);\r\nif (diff_a <= diff_b)\r\nreg &= ~IMG_SPDIF_OUT_CTL_CLK_MASK;\r\nelse\r\nreg |= IMG_SPDIF_OUT_CTL_CLK_MASK;\r\nimg_spdif_out_writel(spdif, reg, IMG_SPDIF_OUT_CTL);\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_dai_probe(struct snd_soc_dai *dai)\r\n{\r\nstruct img_spdif_out *spdif = snd_soc_dai_get_drvdata(dai);\r\nsnd_soc_dai_init_dma_data(dai, &spdif->dma_data, NULL);\r\nsnd_soc_add_dai_controls(dai, img_spdif_out_controls,\r\nARRAY_SIZE(img_spdif_out_controls));\r\nreturn 0;\r\n}\r\nstatic int img_spdif_out_probe(struct platform_device *pdev)\r\n{\r\nstruct img_spdif_out *spdif;\r\nstruct resource *res;\r\nvoid __iomem *base;\r\nint ret;\r\nstruct device *dev = &pdev->dev;\r\nspdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);\r\nif (!spdif)\r\nreturn -ENOMEM;\r\nplatform_set_drvdata(pdev, spdif);\r\nspdif->dev = &pdev->dev;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nbase = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(base))\r\nreturn PTR_ERR(base);\r\nspdif->base = base;\r\nspdif->rst = devm_reset_control_get(&pdev->dev, "rst");\r\nif (IS_ERR(spdif->rst)) {\r\nif (PTR_ERR(spdif->rst) != -EPROBE_DEFER)\r\ndev_err(&pdev->dev, "No top level reset found\n");\r\nreturn PTR_ERR(spdif->rst);\r\n}\r\nspdif->clk_sys = devm_clk_get(&pdev->dev, "sys");\r\nif (IS_ERR(spdif->clk_sys)) {\r\nif (PTR_ERR(spdif->clk_sys) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'sys'\n");\r\nreturn PTR_ERR(spdif->clk_sys);\r\n}\r\nspdif->clk_ref = devm_clk_get(&pdev->dev, "ref");\r\nif (IS_ERR(spdif->clk_ref)) {\r\nif (PTR_ERR(spdif->clk_ref) != -EPROBE_DEFER)\r\ndev_err(dev, "Failed to acquire clock 'ref'\n");\r\nreturn PTR_ERR(spdif->clk_ref);\r\n}\r\nret = clk_prepare_enable(spdif->clk_sys);\r\nif (ret)\r\nreturn ret;\r\nimg_spdif_out_writel(spdif, IMG_SPDIF_OUT_CTL_FS_MASK,\r\nIMG_SPDIF_OUT_CTL);\r\nimg_spdif_out_reset(spdif);\r\npm_runtime_enable(&pdev->dev);\r\nif (!pm_runtime_enabled(&pdev->dev)) {\r\nret = img_spdif_out_resume(&pdev->dev);\r\nif (ret)\r\ngoto err_pm_disable;\r\n}\r\nspin_lock_init(&spdif->lock);\r\nspdif->dma_data.addr = res->start + IMG_SPDIF_OUT_TX_FIFO;\r\nspdif->dma_data.addr_width = 4;\r\nspdif->dma_data.maxburst = 4;\r\nret = devm_snd_soc_register_component(&pdev->dev,\r\n&img_spdif_out_component,\r\n&img_spdif_out_dai, 1);\r\nif (ret)\r\ngoto err_suspend;\r\nret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL, 0);\r\nif (ret)\r\ngoto err_suspend;\r\ndev_dbg(&pdev->dev, "Probe successful\n");\r\nreturn 0;\r\nerr_suspend:\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nimg_spdif_out_suspend(&pdev->dev);\r\nerr_pm_disable:\r\npm_runtime_disable(&pdev->dev);\r\nclk_disable_unprepare(spdif->clk_sys);\r\nreturn ret;\r\n}\r\nstatic int img_spdif_out_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct img_spdif_out *spdif = platform_get_drvdata(pdev);\r\npm_runtime_disable(&pdev->dev);\r\nif (!pm_runtime_status_suspended(&pdev->dev))\r\nimg_spdif_out_suspend(&pdev->dev);\r\nclk_disable_unprepare(spdif->clk_sys);\r\nreturn 0;\r\n}
