static int lmv_intent_remote(struct obd_export *exp, struct lookup_intent *it,\r\nconst struct lu_fid *parent_fid,\r\nstruct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct ptlrpc_request *req = NULL;\r\nstruct lustre_handle plock;\r\nstruct md_op_data *op_data;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct mdt_body *body;\r\nint pmode;\r\nint rc = 0;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (!body)\r\nreturn -EPROTO;\r\nLASSERT((body->mbo_valid & OBD_MD_MDS));\r\nif (it->it_op & IT_LOOKUP)\r\nit->it_op = IT_GETATTR;\r\npmode = it->it_lock_mode;\r\nif (pmode) {\r\nplock.cookie = it->it_lock_handle;\r\nit->it_lock_mode = 0;\r\nit->it_request = NULL;\r\n}\r\nLASSERT(fid_is_sane(&body->mbo_fid1));\r\ntgt = lmv_find_target(lmv, &body->mbo_fid1);\r\nif (IS_ERR(tgt)) {\r\nrc = PTR_ERR(tgt);\r\ngoto out;\r\n}\r\nop_data = kzalloc(sizeof(*op_data), GFP_NOFS);\r\nif (!op_data) {\r\nrc = -ENOMEM;\r\ngoto out;\r\n}\r\nop_data->op_fid1 = body->mbo_fid1;\r\nif (parent_fid) {\r\nLASSERT(it->it_op & IT_OPEN);\r\nop_data->op_fid2 = *parent_fid;\r\n}\r\nop_data->op_bias = MDS_CROSS_REF;\r\nCDEBUG(D_INODE, "REMOTE_INTENT with fid=" DFID " -> mds #%u\n",\r\nPFID(&body->mbo_fid1), tgt->ltd_idx);\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, it, &req, cb_blocking,\r\nextra_lock_flags);\r\nif (rc)\r\ngoto out_free_op_data;\r\nif (it->it_lock_mode != 0) {\r\nit->it_remote_lock_handle =\r\nit->it_lock_handle;\r\nit->it_remote_lock_mode = it->it_lock_mode;\r\n}\r\nif (pmode) {\r\nit->it_lock_handle = plock.cookie;\r\nit->it_lock_mode = pmode;\r\n}\r\nout_free_op_data:\r\nkfree(op_data);\r\nout:\r\nif (rc && pmode)\r\nldlm_lock_decref(&plock, pmode);\r\nptlrpc_req_finished(*reqp);\r\n*reqp = req;\r\nreturn rc;\r\n}\r\nint lmv_revalidate_slaves(struct obd_export *exp,\r\nconst struct lmv_stripe_md *lsm,\r\nldlm_blocking_callback cb_blocking,\r\nint extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct ptlrpc_request *req = NULL;\r\nstruct mdt_body *body;\r\nstruct md_op_data *op_data;\r\nint rc = 0, i;\r\nop_data = kzalloc(sizeof(*op_data), GFP_NOFS);\r\nif (!op_data)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < lsm->lsm_md_stripe_count; i++) {\r\nstruct lookup_intent it = { .it_op = IT_GETATTR };\r\nstruct lustre_handle *lockh = NULL;\r\nstruct lmv_tgt_desc *tgt = NULL;\r\nstruct inode *inode;\r\nstruct lu_fid fid;\r\nfid = lsm->lsm_md_oinfo[i].lmo_fid;\r\ninode = lsm->lsm_md_oinfo[i].lmo_root;\r\nmemset(op_data, 0, sizeof(*op_data));\r\nop_data->op_fid1 = fid;\r\nop_data->op_fid2 = fid;\r\ntgt = lmv_locate_mds(lmv, op_data, &fid);\r\nif (IS_ERR(tgt)) {\r\nrc = PTR_ERR(tgt);\r\ngoto cleanup;\r\n}\r\nCDEBUG(D_INODE, "Revalidate slave " DFID " -> mds #%u\n",\r\nPFID(&fid), tgt->ltd_idx);\r\nif (req) {\r\nptlrpc_req_finished(req);\r\nreq = NULL;\r\n}\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, &it, &req,\r\ncb_blocking, extra_lock_flags);\r\nif (rc < 0)\r\ngoto cleanup;\r\nlockh = (struct lustre_handle *)&it.it_lock_handle;\r\nif (rc > 0 && !req) {\r\nCDEBUG(D_INODE, "slave "DFID" is still valid.\n",\r\nPFID(&fid));\r\nrc = 0;\r\n} else {\r\nbody = req_capsule_server_get(&req->rq_pill,\r\n&RMF_MDT_BODY);\r\nif (!body) {\r\nif (it.it_lock_mode && lockh) {\r\nldlm_lock_decref(lockh, it.it_lock_mode);\r\nit.it_lock_mode = 0;\r\n}\r\nrc = -ENOENT;\r\ngoto cleanup;\r\n}\r\ni_size_write(inode, body->mbo_size);\r\ninode->i_blocks = body->mbo_blocks;\r\nset_nlink(inode, body->mbo_nlink);\r\nLTIME_S(inode->i_atime) = body->mbo_atime;\r\nLTIME_S(inode->i_ctime) = body->mbo_ctime;\r\nLTIME_S(inode->i_mtime) = body->mbo_mtime;\r\n}\r\nmd_set_lock_data(tgt->ltd_exp, lockh, inode, NULL);\r\nif (it.it_lock_mode && lockh) {\r\nldlm_lock_decref(lockh, it.it_lock_mode);\r\nit.it_lock_mode = 0;\r\n}\r\n}\r\ncleanup:\r\nif (req)\r\nptlrpc_req_finished(req);\r\nkfree(op_data);\r\nreturn rc;\r\n}\r\nstatic int lmv_intent_open(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct lookup_intent *it,\r\nstruct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt;\r\nstruct mdt_body *body;\r\nint rc;\r\nif (it->it_flags & MDS_OPEN_BY_FID) {\r\nLASSERT(fid_is_sane(&op_data->op_fid2));\r\nif (op_data->op_mea1)\r\nop_data->op_fid1 = op_data->op_fid2;\r\ntgt = lmv_find_target(lmv, &op_data->op_fid2);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nop_data->op_mds = tgt->ltd_idx;\r\n} else {\r\nLASSERT(fid_is_sane(&op_data->op_fid1));\r\nLASSERT(fid_is_zero(&op_data->op_fid2));\r\nLASSERT(op_data->op_name);\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\n}\r\nif ((it->it_op & IT_CREAT) && !(it->it_flags & MDS_OPEN_BY_FID)) {\r\nrc = lmv_fid_alloc(NULL, exp, &op_data->op_fid2, op_data);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nCDEBUG(D_INODE, "OPEN_INTENT with fid1=" DFID ", fid2=" DFID ", name='%s' -> mds #%u\n",\r\nPFID(&op_data->op_fid1),\r\nPFID(&op_data->op_fid2), op_data->op_name, tgt->ltd_idx);\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, it, reqp, cb_blocking,\r\nextra_lock_flags);\r\nif (rc != 0)\r\nreturn rc;\r\nif ((it->it_disposition & DISP_LOOKUP_NEG) &&\r\n!(it->it_disposition & DISP_OPEN_CREATE) &&\r\n!(it->it_disposition & DISP_OPEN_OPEN))\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (!body)\r\nreturn -EPROTO;\r\nif (unlikely((body->mbo_valid & OBD_MD_MDS))) {\r\nrc = lmv_intent_remote(exp, it, &op_data->op_fid1, reqp,\r\ncb_blocking, extra_lock_flags);\r\nif (rc != 0)\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (!body)\r\nreturn -EPROTO;\r\n}\r\nreturn rc;\r\n}\r\nstatic int lmv_intent_lookup(struct obd_export *exp,\r\nstruct md_op_data *op_data,\r\nstruct lookup_intent *it,\r\nstruct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct lmv_stripe_md *lsm = op_data->op_mea1;\r\nstruct obd_device *obd = exp->exp_obd;\r\nstruct lmv_obd *lmv = &obd->u.lmv;\r\nstruct lmv_tgt_desc *tgt = NULL;\r\nstruct mdt_body *body;\r\nint rc = 0;\r\ntgt = lmv_locate_mds(lmv, op_data, &op_data->op_fid1);\r\nif (IS_ERR(tgt) && (PTR_ERR(tgt) != -EBADFD))\r\nreturn PTR_ERR(tgt);\r\nif (lsm && !lmv_is_known_hash_type(lsm->lsm_md_hash_type)) {\r\nstruct lmv_oinfo *oinfo = &lsm->lsm_md_oinfo[0];\r\nop_data->op_fid1 = oinfo->lmo_fid;\r\nop_data->op_mds = oinfo->lmo_mds;\r\ntgt = lmv_get_target(lmv, oinfo->lmo_mds, NULL);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\n}\r\nif (!fid_is_sane(&op_data->op_fid2))\r\nfid_zero(&op_data->op_fid2);\r\nCDEBUG(D_INODE, "LOOKUP_INTENT with fid1=" DFID ", fid2=" DFID ", name='%s' -> mds #%u lsm=%p lsm_magic=%x\n",\r\nPFID(&op_data->op_fid1), PFID(&op_data->op_fid2),\r\nop_data->op_name ? op_data->op_name : "<NULL>",\r\ntgt->ltd_idx, lsm, !lsm ? -1 : lsm->lsm_md_magic);\r\nop_data->op_bias &= ~MDS_CROSS_REF;\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, it, reqp, cb_blocking,\r\nextra_lock_flags);\r\nif (rc < 0)\r\nreturn rc;\r\nif (!*reqp) {\r\nif (op_data->op_mea2) {\r\nrc = lmv_revalidate_slaves(exp, op_data->op_mea2,\r\ncb_blocking,\r\nextra_lock_flags);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nreturn rc;\r\n} else if (it_disposition(it, DISP_LOOKUP_NEG) && lsm &&\r\nlmv_need_try_all_stripes(lsm)) {\r\nint stripe_index;\r\nfor (stripe_index = 1;\r\nstripe_index < lsm->lsm_md_stripe_count &&\r\nit_disposition(it, DISP_LOOKUP_NEG); stripe_index++) {\r\nstruct lmv_oinfo *oinfo;\r\nptlrpc_req_finished(*reqp);\r\nit->it_request = NULL;\r\n*reqp = NULL;\r\noinfo = &lsm->lsm_md_oinfo[stripe_index];\r\ntgt = lmv_find_target(lmv, &oinfo->lmo_fid);\r\nif (IS_ERR(tgt))\r\nreturn PTR_ERR(tgt);\r\nCDEBUG(D_INODE, "Try other stripes " DFID"\n",\r\nPFID(&oinfo->lmo_fid));\r\nop_data->op_fid1 = oinfo->lmo_fid;\r\nit->it_disposition &= ~DISP_ENQ_COMPLETE;\r\nrc = md_intent_lock(tgt->ltd_exp, op_data, it, reqp,\r\ncb_blocking, extra_lock_flags);\r\nif (rc)\r\nreturn rc;\r\n}\r\n}\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (!body)\r\nreturn -EPROTO;\r\nif (unlikely((body->mbo_valid & OBD_MD_MDS))) {\r\nrc = lmv_intent_remote(exp, it, NULL, reqp, cb_blocking,\r\nextra_lock_flags);\r\nif (rc != 0)\r\nreturn rc;\r\nbody = req_capsule_server_get(&(*reqp)->rq_pill, &RMF_MDT_BODY);\r\nif (!body)\r\nreturn -EPROTO;\r\n}\r\nreturn rc;\r\n}\r\nint lmv_intent_lock(struct obd_export *exp, struct md_op_data *op_data,\r\nstruct lookup_intent *it, struct ptlrpc_request **reqp,\r\nldlm_blocking_callback cb_blocking,\r\n__u64 extra_lock_flags)\r\n{\r\nstruct obd_device *obd = exp->exp_obd;\r\nint rc;\r\nLASSERT(fid_is_sane(&op_data->op_fid1));\r\nCDEBUG(D_INODE, "INTENT LOCK '%s' for "DFID" '%*s' on "DFID"\n",\r\nLL_IT2STR(it), PFID(&op_data->op_fid2),\r\n(int)op_data->op_namelen, op_data->op_name,\r\nPFID(&op_data->op_fid1));\r\nrc = lmv_check_connect(obd);\r\nif (rc)\r\nreturn rc;\r\nif (it->it_op & (IT_LOOKUP | IT_GETATTR | IT_LAYOUT))\r\nrc = lmv_intent_lookup(exp, op_data, it, reqp, cb_blocking,\r\nextra_lock_flags);\r\nelse if (it->it_op & IT_OPEN)\r\nrc = lmv_intent_open(exp, op_data, it, reqp, cb_blocking,\r\nextra_lock_flags);\r\nelse\r\nLBUG();\r\nif (rc < 0) {\r\nstruct lustre_handle lock_handle;\r\nif (it->it_lock_mode) {\r\nlock_handle.cookie = it->it_lock_handle;\r\nldlm_lock_decref(&lock_handle, it->it_lock_mode);\r\n}\r\nit->it_lock_handle = 0;\r\nit->it_lock_mode = 0;\r\nif (it->it_remote_lock_mode) {\r\nlock_handle.cookie = it->it_remote_lock_handle;\r\nldlm_lock_decref(&lock_handle,\r\nit->it_remote_lock_mode);\r\n}\r\nit->it_remote_lock_handle = 0;\r\nit->it_remote_lock_mode = 0;\r\n}\r\nreturn rc;\r\n}
