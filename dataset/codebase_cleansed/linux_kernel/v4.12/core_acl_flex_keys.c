static bool mlxsw_afk_blocks_check(struct mlxsw_afk *mlxsw_afk)\r\n{\r\nint i;\r\nint j;\r\nfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\r\nconst struct mlxsw_afk_block *block = &mlxsw_afk->blocks[i];\r\nfor (j = 0; j < block->instances_count; j++) {\r\nstruct mlxsw_afk_element_inst *elinst;\r\nelinst = &block->instances[j];\r\nif (elinst->type != elinst->info->type ||\r\nelinst->item.size.bits !=\r\nelinst->info->item.size.bits)\r\nreturn false;\r\n}\r\n}\r\nreturn true;\r\n}\r\nstruct mlxsw_afk *mlxsw_afk_create(unsigned int max_blocks,\r\nconst struct mlxsw_afk_block *blocks,\r\nunsigned int blocks_count)\r\n{\r\nstruct mlxsw_afk *mlxsw_afk;\r\nmlxsw_afk = kzalloc(sizeof(*mlxsw_afk), GFP_KERNEL);\r\nif (!mlxsw_afk)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&mlxsw_afk->key_info_list);\r\nmlxsw_afk->max_blocks = max_blocks;\r\nmlxsw_afk->blocks = blocks;\r\nmlxsw_afk->blocks_count = blocks_count;\r\nWARN_ON(!mlxsw_afk_blocks_check(mlxsw_afk));\r\nreturn mlxsw_afk;\r\n}\r\nvoid mlxsw_afk_destroy(struct mlxsw_afk *mlxsw_afk)\r\n{\r\nWARN_ON(!list_empty(&mlxsw_afk->key_info_list));\r\nkfree(mlxsw_afk);\r\n}\r\nstatic bool\r\nmlxsw_afk_key_info_elements_eq(struct mlxsw_afk_key_info *key_info,\r\nstruct mlxsw_afk_element_usage *elusage)\r\n{\r\nreturn memcmp(&key_info->elusage, elusage, sizeof(*elusage)) == 0;\r\n}\r\nstatic struct mlxsw_afk_key_info *\r\nmlxsw_afk_key_info_find(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_element_usage *elusage)\r\n{\r\nstruct mlxsw_afk_key_info *key_info;\r\nlist_for_each_entry(key_info, &mlxsw_afk->key_info_list, list) {\r\nif (mlxsw_afk_key_info_elements_eq(key_info, elusage))\r\nreturn key_info;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mlxsw_afk_picker_count_hits(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_picker *picker,\r\nenum mlxsw_afk_element element)\r\n{\r\nint i;\r\nint j;\r\nfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\r\nconst struct mlxsw_afk_block *block = &mlxsw_afk->blocks[i];\r\nfor (j = 0; j < block->instances_count; j++) {\r\nstruct mlxsw_afk_element_inst *elinst;\r\nelinst = &block->instances[j];\r\nif (elinst->info->element == element) {\r\n__set_bit(element, picker->hits[i].element);\r\npicker->hits[i].total++;\r\n}\r\n}\r\n}\r\n}\r\nstatic void mlxsw_afk_picker_subtract_hits(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_picker *picker,\r\nint block_index)\r\n{\r\nDECLARE_BITMAP(hits_element, MLXSW_AFK_ELEMENT_MAX);\r\nint i;\r\nint j;\r\nmemcpy(&hits_element, &picker->hits[block_index].element,\r\nsizeof(hits_element));\r\nfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\r\nfor_each_set_bit(j, hits_element, MLXSW_AFK_ELEMENT_MAX) {\r\nif (__test_and_clear_bit(j, picker->hits[i].element))\r\npicker->hits[i].total--;\r\n}\r\n}\r\n}\r\nstatic int mlxsw_afk_picker_most_hits_get(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_picker *picker)\r\n{\r\nint most_index = -EINVAL;\r\nint most_hits = 0;\r\nint i;\r\nfor (i = 0; i < mlxsw_afk->blocks_count; i++) {\r\nif (picker->hits[i].total > most_hits) {\r\nmost_hits = picker->hits[i].total;\r\nmost_index = i;\r\n}\r\n}\r\nreturn most_index;\r\n}\r\nstatic int mlxsw_afk_picker_key_info_add(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_picker *picker,\r\nint block_index,\r\nstruct mlxsw_afk_key_info *key_info)\r\n{\r\nenum mlxsw_afk_element element;\r\nif (key_info->blocks_count == mlxsw_afk->max_blocks)\r\nreturn -EINVAL;\r\nfor_each_set_bit(element, picker->hits[block_index].element,\r\nMLXSW_AFK_ELEMENT_MAX) {\r\nkey_info->element_to_block[element] = key_info->blocks_count;\r\nmlxsw_afk_element_usage_add(&key_info->elusage, element);\r\n}\r\nkey_info->blocks[key_info->blocks_count] =\r\n&mlxsw_afk->blocks[block_index];\r\nkey_info->blocks_count++;\r\nreturn 0;\r\n}\r\nstatic int mlxsw_afk_picker(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_key_info *key_info,\r\nstruct mlxsw_afk_element_usage *elusage)\r\n{\r\nstruct mlxsw_afk_picker *picker;\r\nenum mlxsw_afk_element element;\r\nsize_t alloc_size;\r\nint err;\r\nalloc_size = sizeof(picker->hits[0]) * mlxsw_afk->blocks_count;\r\npicker = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!picker)\r\nreturn -ENOMEM;\r\nmlxsw_afk_element_usage_for_each(element, elusage)\r\nmlxsw_afk_picker_count_hits(mlxsw_afk, picker, element);\r\ndo {\r\nint block_index;\r\nblock_index = mlxsw_afk_picker_most_hits_get(mlxsw_afk, picker);\r\nif (block_index < 0) {\r\nerr = block_index;\r\ngoto out;\r\n}\r\nerr = mlxsw_afk_picker_key_info_add(mlxsw_afk, picker,\r\nblock_index, key_info);\r\nif (err)\r\ngoto out;\r\nmlxsw_afk_picker_subtract_hits(mlxsw_afk, picker, block_index);\r\n} while (!mlxsw_afk_key_info_elements_eq(key_info, elusage));\r\nerr = 0;\r\nout:\r\nkfree(picker);\r\nreturn err;\r\n}\r\nstatic struct mlxsw_afk_key_info *\r\nmlxsw_afk_key_info_create(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_element_usage *elusage)\r\n{\r\nstruct mlxsw_afk_key_info *key_info;\r\nsize_t alloc_size;\r\nint err;\r\nalloc_size = sizeof(*key_info) +\r\nsizeof(key_info->blocks[0]) * mlxsw_afk->max_blocks;\r\nkey_info = kzalloc(alloc_size, GFP_KERNEL);\r\nif (!key_info)\r\nreturn ERR_PTR(-ENOMEM);\r\nerr = mlxsw_afk_picker(mlxsw_afk, key_info, elusage);\r\nif (err)\r\ngoto err_picker;\r\nlist_add(&key_info->list, &mlxsw_afk->key_info_list);\r\nkey_info->ref_count = 1;\r\nreturn key_info;\r\nerr_picker:\r\nkfree(key_info);\r\nreturn ERR_PTR(err);\r\n}\r\nstatic void mlxsw_afk_key_info_destroy(struct mlxsw_afk_key_info *key_info)\r\n{\r\nlist_del(&key_info->list);\r\nkfree(key_info);\r\n}\r\nstruct mlxsw_afk_key_info *\r\nmlxsw_afk_key_info_get(struct mlxsw_afk *mlxsw_afk,\r\nstruct mlxsw_afk_element_usage *elusage)\r\n{\r\nstruct mlxsw_afk_key_info *key_info;\r\nkey_info = mlxsw_afk_key_info_find(mlxsw_afk, elusage);\r\nif (key_info) {\r\nkey_info->ref_count++;\r\nreturn key_info;\r\n}\r\nreturn mlxsw_afk_key_info_create(mlxsw_afk, elusage);\r\n}\r\nvoid mlxsw_afk_key_info_put(struct mlxsw_afk_key_info *key_info)\r\n{\r\nif (--key_info->ref_count)\r\nreturn;\r\nmlxsw_afk_key_info_destroy(key_info);\r\n}\r\nbool mlxsw_afk_key_info_subset(struct mlxsw_afk_key_info *key_info,\r\nstruct mlxsw_afk_element_usage *elusage)\r\n{\r\nreturn mlxsw_afk_element_usage_subset(elusage, &key_info->elusage);\r\n}\r\nstatic const struct mlxsw_afk_element_inst *\r\nmlxsw_afk_block_elinst_get(const struct mlxsw_afk_block *block,\r\nenum mlxsw_afk_element element)\r\n{\r\nint i;\r\nfor (i = 0; i < block->instances_count; i++) {\r\nstruct mlxsw_afk_element_inst *elinst;\r\nelinst = &block->instances[i];\r\nif (elinst->info->element == element)\r\nreturn elinst;\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct mlxsw_afk_element_inst *\r\nmlxsw_afk_key_info_elinst_get(struct mlxsw_afk_key_info *key_info,\r\nenum mlxsw_afk_element element,\r\nint *p_block_index)\r\n{\r\nconst struct mlxsw_afk_element_inst *elinst;\r\nconst struct mlxsw_afk_block *block;\r\nint block_index;\r\nif (WARN_ON(!test_bit(element, key_info->elusage.usage)))\r\nreturn NULL;\r\nblock_index = key_info->element_to_block[element];\r\nblock = key_info->blocks[block_index];\r\nelinst = mlxsw_afk_block_elinst_get(block, element);\r\nif (WARN_ON(!elinst))\r\nreturn NULL;\r\n*p_block_index = block_index;\r\nreturn elinst;\r\n}\r\nu16\r\nmlxsw_afk_key_info_block_encoding_get(const struct mlxsw_afk_key_info *key_info,\r\nint block_index)\r\n{\r\nreturn key_info->blocks[block_index]->encoding;\r\n}\r\nunsigned int\r\nmlxsw_afk_key_info_blocks_count_get(const struct mlxsw_afk_key_info *key_info)\r\n{\r\nreturn key_info->blocks_count;\r\n}\r\nvoid mlxsw_afk_values_add_u32(struct mlxsw_afk_element_values *values,\r\nenum mlxsw_afk_element element,\r\nu32 key_value, u32 mask_value)\r\n{\r\nconst struct mlxsw_afk_element_info *elinfo =\r\n&mlxsw_afk_element_infos[element];\r\nconst struct mlxsw_item *storage_item = &elinfo->item;\r\nif (!mask_value)\r\nreturn;\r\nif (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_U32))\r\nreturn;\r\n__mlxsw_item_set32(values->storage.key, storage_item, 0, key_value);\r\n__mlxsw_item_set32(values->storage.mask, storage_item, 0, mask_value);\r\nmlxsw_afk_element_usage_add(&values->elusage, element);\r\n}\r\nvoid mlxsw_afk_values_add_buf(struct mlxsw_afk_element_values *values,\r\nenum mlxsw_afk_element element,\r\nconst char *key_value, const char *mask_value,\r\nunsigned int len)\r\n{\r\nconst struct mlxsw_afk_element_info *elinfo =\r\n&mlxsw_afk_element_infos[element];\r\nconst struct mlxsw_item *storage_item = &elinfo->item;\r\nif (!memchr_inv(mask_value, 0, len))\r\nreturn;\r\nif (WARN_ON(elinfo->type != MLXSW_AFK_ELEMENT_TYPE_BUF) ||\r\nWARN_ON(elinfo->item.size.bytes != len))\r\nreturn;\r\n__mlxsw_item_memcpy_to(values->storage.key, key_value,\r\nstorage_item, 0);\r\n__mlxsw_item_memcpy_to(values->storage.mask, mask_value,\r\nstorage_item, 0);\r\nmlxsw_afk_element_usage_add(&values->elusage, element);\r\n}\r\nstatic void mlxsw_afk_encode_u32(const struct mlxsw_item *storage_item,\r\nconst struct mlxsw_item *output_item,\r\nchar *storage, char *output_indexed)\r\n{\r\nu32 value;\r\nvalue = __mlxsw_item_get32(storage, storage_item, 0);\r\n__mlxsw_item_set32(output_indexed, output_item, 0, value);\r\n}\r\nstatic void mlxsw_afk_encode_buf(const struct mlxsw_item *storage_item,\r\nconst struct mlxsw_item *output_item,\r\nchar *storage, char *output_indexed)\r\n{\r\nchar *storage_data = __mlxsw_item_data(storage, storage_item, 0);\r\nchar *output_data = __mlxsw_item_data(output_indexed, output_item, 0);\r\nsize_t len = output_item->size.bytes;\r\nmemcpy(output_data, storage_data, len);\r\n}\r\nstatic void mlxsw_afk_encode_one(const struct mlxsw_afk_element_inst *elinst,\r\nint block_index, char *storage, char *output)\r\n{\r\nchar *output_indexed = output + block_index * MLXSW_AFK_KEY_BLOCK_SIZE;\r\nconst struct mlxsw_item *storage_item = &elinst->info->item;\r\nconst struct mlxsw_item *output_item = &elinst->item;\r\nif (elinst->type == MLXSW_AFK_ELEMENT_TYPE_U32)\r\nmlxsw_afk_encode_u32(storage_item, output_item,\r\nstorage, output_indexed);\r\nelse if (elinst->type == MLXSW_AFK_ELEMENT_TYPE_BUF)\r\nmlxsw_afk_encode_buf(storage_item, output_item,\r\nstorage, output_indexed);\r\n}\r\nvoid mlxsw_afk_encode(struct mlxsw_afk_key_info *key_info,\r\nstruct mlxsw_afk_element_values *values,\r\nchar *key, char *mask)\r\n{\r\nconst struct mlxsw_afk_element_inst *elinst;\r\nenum mlxsw_afk_element element;\r\nint block_index;\r\nmlxsw_afk_element_usage_for_each(element, &values->elusage) {\r\nelinst = mlxsw_afk_key_info_elinst_get(key_info, element,\r\n&block_index);\r\nif (!elinst)\r\ncontinue;\r\nmlxsw_afk_encode_one(elinst, block_index,\r\nvalues->storage.key, key);\r\nmlxsw_afk_encode_one(elinst, block_index,\r\nvalues->storage.mask, mask);\r\n}\r\n}
