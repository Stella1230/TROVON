static void scr24x_delete(struct kref *kref)\r\n{\r\nstruct scr24x_dev *dev = container_of(kref, struct scr24x_dev,\r\nrefcnt);\r\nkfree(dev);\r\n}\r\nstatic int scr24x_wait_ready(struct scr24x_dev *dev)\r\n{\r\nu_char status;\r\nint timeout = 100;\r\ndo {\r\nstatus = ioread8(dev->regs + SCR24X_CMD_STATUS);\r\nif (!(status & STATUS_BUSY))\r\nreturn 0;\r\nmsleep(20);\r\n} while (--timeout);\r\nreturn -EIO;\r\n}\r\nstatic int scr24x_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct scr24x_dev *dev = container_of(inode->i_cdev,\r\nstruct scr24x_dev, c_dev);\r\nkref_get(&dev->refcnt);\r\nfilp->private_data = dev;\r\nreturn nonseekable_open(inode, filp);\r\n}\r\nstatic int scr24x_release(struct inode *inode, struct file *filp)\r\n{\r\nstruct scr24x_dev *dev = filp->private_data;\r\nkref_put(&dev->refcnt, scr24x_delete);\r\nreturn 0;\r\n}\r\nstatic int read_chunk(struct scr24x_dev *dev, size_t offset, size_t limit)\r\n{\r\nsize_t i, y;\r\nint ret;\r\nfor (i = offset; i < limit; i += 5) {\r\niowrite8(CMD_READ_BYTE, dev->regs + SCR24X_CMD_STATUS);\r\nret = scr24x_wait_ready(dev);\r\nif (ret < 0)\r\nreturn ret;\r\nfor (y = 0; y < 5 && i + y < limit; y++)\r\ndev->buf[i + y] = ioread8(dev->regs + SCR24X_DATA(y));\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t scr24x_read(struct file *filp, char __user *buf, size_t count,\r\nloff_t *ppos)\r\n{\r\nstruct scr24x_dev *dev = filp->private_data;\r\nint ret;\r\nint len;\r\nif (count < CCID_HEADER_SIZE)\r\nreturn -EINVAL;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (!dev->dev) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nret = scr24x_wait_ready(dev);\r\nif (ret < 0)\r\ngoto out;\r\nlen = CCID_HEADER_SIZE;\r\nret = read_chunk(dev, 0, len);\r\nif (ret < 0)\r\ngoto out;\r\nlen += le32_to_cpu(*(__le32 *)(&dev->buf[CCID_LENGTH_OFFSET]));\r\nif (len > sizeof(dev->buf)) {\r\nret = -EIO;\r\ngoto out;\r\n}\r\nret = read_chunk(dev, CCID_HEADER_SIZE, len);\r\nif (ret < 0)\r\ngoto out;\r\nif (len < count)\r\ncount = len;\r\nif (copy_to_user(buf, dev->buf, count)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = count;\r\nout:\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t scr24x_write(struct file *filp, const char __user *buf,\r\nsize_t count, loff_t *ppos)\r\n{\r\nstruct scr24x_dev *dev = filp->private_data;\r\nsize_t i, y;\r\nint ret;\r\nif (mutex_lock_interruptible(&dev->lock))\r\nreturn -ERESTARTSYS;\r\nif (!dev->dev) {\r\nret = -ENODEV;\r\ngoto out;\r\n}\r\nif (count > sizeof(dev->buf)) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (copy_from_user(dev->buf, buf, count)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = scr24x_wait_ready(dev);\r\nif (ret < 0)\r\ngoto out;\r\niowrite8(CMD_START, dev->regs + SCR24X_CMD_STATUS);\r\nret = scr24x_wait_ready(dev);\r\nif (ret < 0)\r\ngoto out;\r\nfor (i = 0; i < count; i += 5) {\r\nfor (y = 0; y < 5 && i + y < count; y++)\r\niowrite8(dev->buf[i + y], dev->regs + SCR24X_DATA(y));\r\niowrite8(CMD_WRITE_BYTE, dev->regs + SCR24X_CMD_STATUS);\r\nret = scr24x_wait_ready(dev);\r\nif (ret < 0)\r\ngoto out;\r\n}\r\nret = count;\r\nout:\r\nmutex_unlock(&dev->lock);\r\nreturn ret;\r\n}\r\nstatic int scr24x_config_check(struct pcmcia_device *link, void *priv_data)\r\n{\r\nif (resource_size(link->resource[PCMCIA_IOPORT_0]) != 0x11)\r\nreturn -ENODEV;\r\nreturn pcmcia_request_io(link);\r\n}\r\nstatic int scr24x_probe(struct pcmcia_device *link)\r\n{\r\nstruct scr24x_dev *dev;\r\nint ret;\r\ndev = kzalloc(sizeof(*dev), GFP_KERNEL);\r\nif (!dev)\r\nreturn -ENOMEM;\r\ndev->devno = find_first_zero_bit(scr24x_minors, SCR24X_DEVS);\r\nif (dev->devno >= SCR24X_DEVS) {\r\nret = -EBUSY;\r\ngoto err;\r\n}\r\nmutex_init(&dev->lock);\r\nkref_init(&dev->refcnt);\r\nlink->priv = dev;\r\nlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\r\nret = pcmcia_loop_config(link, scr24x_config_check, NULL);\r\nif (ret < 0)\r\ngoto err;\r\ndev->dev = &link->dev;\r\ndev->regs = devm_ioport_map(&link->dev,\r\nlink->resource[PCMCIA_IOPORT_0]->start,\r\nresource_size(link->resource[PCMCIA_IOPORT_0]));\r\nif (!dev->regs) {\r\nret = -EIO;\r\ngoto err;\r\n}\r\ncdev_init(&dev->c_dev, &scr24x_fops);\r\ndev->c_dev.owner = THIS_MODULE;\r\ndev->c_dev.ops = &scr24x_fops;\r\nret = cdev_add(&dev->c_dev, MKDEV(MAJOR(scr24x_devt), dev->devno), 1);\r\nif (ret < 0)\r\ngoto err;\r\nret = pcmcia_enable_device(link);\r\nif (ret < 0) {\r\npcmcia_disable_device(link);\r\ngoto err;\r\n}\r\ndevice_create(scr24x_class, NULL, MKDEV(MAJOR(scr24x_devt), dev->devno),\r\nNULL, "scr24x%d", dev->devno);\r\ndev_info(&link->dev, "SCR24x Chip Card Interface\n");\r\nreturn 0;\r\nerr:\r\nif (dev->devno < SCR24X_DEVS)\r\nclear_bit(dev->devno, scr24x_minors);\r\nkfree (dev);\r\nreturn ret;\r\n}\r\nstatic void scr24x_remove(struct pcmcia_device *link)\r\n{\r\nstruct scr24x_dev *dev = (struct scr24x_dev *)link->priv;\r\ndevice_destroy(scr24x_class, MKDEV(MAJOR(scr24x_devt), dev->devno));\r\nmutex_lock(&dev->lock);\r\npcmcia_disable_device(link);\r\ncdev_del(&dev->c_dev);\r\nclear_bit(dev->devno, scr24x_minors);\r\ndev->dev = NULL;\r\nmutex_unlock(&dev->lock);\r\nkref_put(&dev->refcnt, scr24x_delete);\r\n}\r\nstatic int __init scr24x_init(void)\r\n{\r\nint ret;\r\nscr24x_class = class_create(THIS_MODULE, "scr24x");\r\nif (IS_ERR(scr24x_class))\r\nreturn PTR_ERR(scr24x_class);\r\nret = alloc_chrdev_region(&scr24x_devt, 0, SCR24X_DEVS, "scr24x");\r\nif (ret < 0) {\r\nclass_destroy(scr24x_class);\r\nreturn ret;\r\n}\r\nret = pcmcia_register_driver(&scr24x_driver);\r\nif (ret < 0) {\r\nunregister_chrdev_region(scr24x_devt, SCR24X_DEVS);\r\nclass_destroy(scr24x_class);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit scr24x_exit(void)\r\n{\r\npcmcia_unregister_driver(&scr24x_driver);\r\nunregister_chrdev_region(scr24x_devt, SCR24X_DEVS);\r\nclass_destroy(scr24x_class);\r\n}
