static unsigned long\r\n__dump_trace(dump_trace_func_t func, void *data, unsigned long sp,\r\nunsigned long low, unsigned long high)\r\n{\r\nstruct stack_frame *sf;\r\nstruct pt_regs *regs;\r\nwhile (1) {\r\nif (sp < low || sp > high - sizeof(*sf))\r\nreturn sp;\r\nsf = (struct stack_frame *) sp;\r\nif (func(data, sf->gprs[8], 0))\r\nreturn sp;\r\nwhile (1) {\r\nlow = sp;\r\nsp = sf->back_chain;\r\nif (!sp)\r\nbreak;\r\nif (sp <= low || sp > high - sizeof(*sf))\r\nreturn sp;\r\nsf = (struct stack_frame *) sp;\r\nif (func(data, sf->gprs[8], 1))\r\nreturn sp;\r\n}\r\nsp = (unsigned long) (sf + 1);\r\nif (sp <= low || sp > high - sizeof(*regs))\r\nreturn sp;\r\nregs = (struct pt_regs *) sp;\r\nif (!user_mode(regs)) {\r\nif (func(data, regs->psw.addr, 1))\r\nreturn sp;\r\n}\r\nlow = sp;\r\nsp = regs->gprs[15];\r\n}\r\n}\r\nvoid dump_trace(dump_trace_func_t func, void *data, struct task_struct *task,\r\nunsigned long sp)\r\n{\r\nunsigned long frame_size;\r\nframe_size = STACK_FRAME_OVERHEAD + sizeof(struct pt_regs);\r\n#ifdef CONFIG_CHECK_STACK\r\nsp = __dump_trace(func, data, sp,\r\nS390_lowcore.panic_stack + frame_size - 4096,\r\nS390_lowcore.panic_stack + frame_size);\r\n#endif\r\nsp = __dump_trace(func, data, sp,\r\nS390_lowcore.async_stack + frame_size - ASYNC_SIZE,\r\nS390_lowcore.async_stack + frame_size);\r\ntask = task ?: current;\r\n__dump_trace(func, data, sp,\r\n(unsigned long)task_stack_page(task),\r\n(unsigned long)task_stack_page(task) + THREAD_SIZE);\r\n}\r\nstatic int show_address(void *data, unsigned long address, int reliable)\r\n{\r\nif (reliable)\r\nprintk(" [<%016lx>] %pSR \n", address, (void *)address);\r\nelse\r\nprintk("([<%016lx>] %pSR)\n", address, (void *)address);\r\nreturn 0;\r\n}\r\nstatic void show_trace(struct task_struct *task, unsigned long sp)\r\n{\r\nif (!sp)\r\nsp = task ? task->thread.ksp : current_stack_pointer();\r\nprintk("Call Trace:\n");\r\ndump_trace(show_address, NULL, task, sp);\r\nif (!task)\r\ntask = current;\r\ndebug_show_held_locks(task);\r\n}\r\nvoid show_stack(struct task_struct *task, unsigned long *sp)\r\n{\r\nunsigned long *stack;\r\nint i;\r\nstack = sp;\r\nif (!stack) {\r\nif (!task)\r\nstack = (unsigned long *)current_stack_pointer();\r\nelse\r\nstack = (unsigned long *)task->thread.ksp;\r\n}\r\nprintk(KERN_DEFAULT "Stack:\n");\r\nfor (i = 0; i < 20; i++) {\r\nif (((addr_t) stack & (THREAD_SIZE-1)) == 0)\r\nbreak;\r\nif (i % 4 == 0)\r\nprintk(KERN_DEFAULT " ");\r\npr_cont("%016lx%c", *stack++, i % 4 == 3 ? '\n' : ' ');\r\n}\r\nshow_trace(task, (unsigned long)sp);\r\n}\r\nstatic void show_last_breaking_event(struct pt_regs *regs)\r\n{\r\nprintk("Last Breaking-Event-Address:\n");\r\nprintk(" [<%016lx>] %pSR\n", regs->args[0], (void *)regs->args[0]);\r\n}\r\nvoid show_registers(struct pt_regs *regs)\r\n{\r\nstruct psw_bits *psw = &psw_bits(regs->psw);\r\nchar *mode;\r\nmode = user_mode(regs) ? "User" : "Krnl";\r\nprintk("%s PSW : %p %p", mode, (void *)regs->psw.mask, (void *)regs->psw.addr);\r\nif (!user_mode(regs))\r\npr_cont(" (%pSR)", (void *)regs->psw.addr);\r\npr_cont("\n");\r\nprintk(" R:%x T:%x IO:%x EX:%x Key:%x M:%x W:%x "\r\n"P:%x AS:%x CC:%x PM:%x", psw->r, psw->t, psw->i, psw->e,\r\npsw->key, psw->m, psw->w, psw->p, psw->as, psw->cc, psw->pm);\r\npr_cont(" RI:%x EA:%x\n", psw->ri, psw->eaba);\r\nprintk("%s GPRS: %016lx %016lx %016lx %016lx\n", mode,\r\nregs->gprs[0], regs->gprs[1], regs->gprs[2], regs->gprs[3]);\r\nprintk(" %016lx %016lx %016lx %016lx\n",\r\nregs->gprs[4], regs->gprs[5], regs->gprs[6], regs->gprs[7]);\r\nprintk(" %016lx %016lx %016lx %016lx\n",\r\nregs->gprs[8], regs->gprs[9], regs->gprs[10], regs->gprs[11]);\r\nprintk(" %016lx %016lx %016lx %016lx\n",\r\nregs->gprs[12], regs->gprs[13], regs->gprs[14], regs->gprs[15]);\r\nshow_code(regs);\r\n}\r\nvoid show_regs(struct pt_regs *regs)\r\n{\r\nshow_regs_print_info(KERN_DEFAULT);\r\nshow_registers(regs);\r\nif (!user_mode(regs))\r\nshow_trace(NULL, regs->gprs[15]);\r\nshow_last_breaking_event(regs);\r\n}\r\nvoid die(struct pt_regs *regs, const char *str)\r\n{\r\nstatic int die_counter;\r\noops_enter();\r\nlgr_info_log();\r\ndebug_stop_all();\r\nconsole_verbose();\r\nspin_lock_irq(&die_lock);\r\nbust_spinlocks(1);\r\nprintk("%s: %04x ilc:%d [#%d] ", str, regs->int_code & 0xffff,\r\nregs->int_code >> 17, ++die_counter);\r\n#ifdef CONFIG_PREEMPT\r\npr_cont("PREEMPT ");\r\n#endif\r\n#ifdef CONFIG_SMP\r\npr_cont("SMP ");\r\n#endif\r\nif (debug_pagealloc_enabled())\r\npr_cont("DEBUG_PAGEALLOC");\r\npr_cont("\n");\r\nnotify_die(DIE_OOPS, str, regs, 0, regs->int_code & 0xffff, SIGSEGV);\r\nprint_modules();\r\nshow_regs(regs);\r\nbust_spinlocks(0);\r\nadd_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);\r\nspin_unlock_irq(&die_lock);\r\nif (in_interrupt())\r\npanic("Fatal exception in interrupt");\r\nif (panic_on_oops)\r\npanic("Fatal exception: panic_on_oops");\r\noops_exit();\r\ndo_exit(SIGSEGV);\r\n}
