int s5k83a_probe(struct sd *sd)\r\n{\r\nu8 prod_id = 0, ver_id = 0;\r\nint i, err = 0;\r\nstruct gspca_dev *gspca_dev = (struct gspca_dev *)sd;\r\nif (force_sensor) {\r\nif (force_sensor == S5K83A_SENSOR) {\r\npr_info("Forcing a %s sensor\n", s5k83a.name);\r\ngoto sensor_found;\r\n}\r\nreturn -ENODEV;\r\n}\r\nPDEBUG(D_PROBE, "Probing for a s5k83a sensor");\r\nfor (i = 0; i < ARRAY_SIZE(preinit_s5k83a) && !err; i++) {\r\nu8 data[2] = {preinit_s5k83a[i][2], preinit_s5k83a[i][3]};\r\nif (preinit_s5k83a[i][0] == SENSOR)\r\nerr = m5602_write_sensor(sd, preinit_s5k83a[i][1],\r\ndata, 2);\r\nelse\r\nerr = m5602_write_bridge(sd, preinit_s5k83a[i][1],\r\ndata[0]);\r\n}\r\nif (m5602_read_sensor(sd, 0x00, &prod_id, 1))\r\nreturn -ENODEV;\r\nif (m5602_read_sensor(sd, 0x01, &ver_id, 1))\r\nreturn -ENODEV;\r\nif ((prod_id == 0xff) || (ver_id == 0xff))\r\nreturn -ENODEV;\r\nelse\r\npr_info("Detected a s5k83a sensor\n");\r\nsensor_found:\r\nsd->gspca_dev.cam.cam_mode = s5k83a_modes;\r\nsd->gspca_dev.cam.nmodes = ARRAY_SIZE(s5k83a_modes);\r\nsd->rotation_thread = NULL;\r\nreturn 0;\r\n}\r\nint s5k83a_init(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nfor (i = 0; i < ARRAY_SIZE(init_s5k83a) && !err; i++) {\r\nu8 data[2] = {0x00, 0x00};\r\nswitch (init_s5k83a[i][0]) {\r\ncase BRIDGE:\r\nerr = m5602_write_bridge(sd,\r\ninit_s5k83a[i][1],\r\ninit_s5k83a[i][2]);\r\nbreak;\r\ncase SENSOR:\r\ndata[0] = init_s5k83a[i][2];\r\nerr = m5602_write_sensor(sd,\r\ninit_s5k83a[i][1], data, 1);\r\nbreak;\r\ncase SENSOR_LONG:\r\ndata[0] = init_s5k83a[i][2];\r\ndata[1] = init_s5k83a[i][3];\r\nerr = m5602_write_sensor(sd,\r\ninit_s5k83a[i][1], data, 2);\r\nbreak;\r\ndefault:\r\npr_info("Invalid stream command, exiting init\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (dump_sensor)\r\ns5k83a_dump_registers(sd);\r\nreturn err;\r\n}\r\nint s5k83a_init_controls(struct sd *sd)\r\n{\r\nstruct v4l2_ctrl_handler *hdl = &sd->gspca_dev.ctrl_handler;\r\nsd->gspca_dev.vdev.ctrl_handler = hdl;\r\nv4l2_ctrl_handler_init(hdl, 6);\r\nv4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_BRIGHTNESS,\r\n0, 255, 1, S5K83A_DEFAULT_BRIGHTNESS);\r\nv4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_EXPOSURE,\r\n0, S5K83A_MAXIMUM_EXPOSURE, 1,\r\nS5K83A_DEFAULT_EXPOSURE);\r\nv4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_GAIN,\r\n0, 255, 1, S5K83A_DEFAULT_GAIN);\r\nsd->hflip = v4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_HFLIP,\r\n0, 1, 1, 0);\r\nsd->vflip = v4l2_ctrl_new_std(hdl, &s5k83a_ctrl_ops, V4L2_CID_VFLIP,\r\n0, 1, 1, 0);\r\nif (hdl->error) {\r\npr_err("Could not initialize controls\n");\r\nreturn hdl->error;\r\n}\r\nv4l2_ctrl_cluster(2, &sd->hflip);\r\nreturn 0;\r\n}\r\nstatic int rotation_thread_function(void *data)\r\n{\r\nstruct sd *sd = (struct sd *) data;\r\nu8 reg, previous_rotation = 0;\r\n__s32 vflip, hflip;\r\nset_current_state(TASK_INTERRUPTIBLE);\r\nwhile (!schedule_timeout(msecs_to_jiffies(100))) {\r\nif (mutex_lock_interruptible(&sd->gspca_dev.usb_lock))\r\nbreak;\r\ns5k83a_get_rotation(sd, &reg);\r\nif (previous_rotation != reg) {\r\nprevious_rotation = reg;\r\npr_info("Camera was flipped\n");\r\nhflip = sd->hflip->val;\r\nvflip = sd->vflip->val;\r\nif (reg) {\r\nvflip = !vflip;\r\nhflip = !hflip;\r\n}\r\ns5k83a_set_flip_real((struct gspca_dev *) sd,\r\nvflip, hflip);\r\n}\r\nmutex_unlock(&sd->gspca_dev.usb_lock);\r\nset_current_state(TASK_INTERRUPTIBLE);\r\n}\r\nif (previous_rotation) {\r\nhflip = sd->hflip->val;\r\nvflip = sd->vflip->val;\r\ns5k83a_set_flip_real((struct gspca_dev *) sd, vflip, hflip);\r\n}\r\nsd->rotation_thread = NULL;\r\nreturn 0;\r\n}\r\nint s5k83a_start(struct sd *sd)\r\n{\r\nint i, err = 0;\r\nsd->rotation_thread = kthread_create(rotation_thread_function,\r\nsd, "rotation thread");\r\nwake_up_process(sd->rotation_thread);\r\nfor (i = 0; i < ARRAY_SIZE(start_s5k83a) && !err; i++) {\r\nu8 data[2] = {start_s5k83a[i][2], start_s5k83a[i][3]};\r\nif (start_s5k83a[i][0] == SENSOR)\r\nerr = m5602_write_sensor(sd, start_s5k83a[i][1],\r\ndata, 2);\r\nelse\r\nerr = m5602_write_bridge(sd, start_s5k83a[i][1],\r\ndata[0]);\r\n}\r\nif (err < 0)\r\nreturn err;\r\nreturn s5k83a_set_led_indication(sd, 1);\r\n}\r\nint s5k83a_stop(struct sd *sd)\r\n{\r\nif (sd->rotation_thread)\r\nkthread_stop(sd->rotation_thread);\r\nreturn s5k83a_set_led_indication(sd, 0);\r\n}\r\nvoid s5k83a_disconnect(struct sd *sd)\r\n{\r\ns5k83a_stop(sd);\r\nsd->sensor = NULL;\r\n}\r\nstatic int s5k83a_set_gain(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ndata[0] = 0x00;\r\ndata[1] = 0x20;\r\nerr = m5602_write_sensor(sd, 0x14, data, 2);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = 0x01;\r\ndata[1] = 0x00;\r\nerr = m5602_write_sensor(sd, 0x0d, data, 2);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = val >> 3;\r\ndata[1] = val >> 1;\r\nerr = m5602_write_sensor(sd, S5K83A_GAIN, data, 2);\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_brightness(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[1];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ndata[0] = val;\r\nerr = m5602_write_sensor(sd, S5K83A_BRIGHTNESS, data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_exposure(struct gspca_dev *gspca_dev, __s32 val)\r\n{\r\nint err;\r\nu8 data[2];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ndata[0] = 0;\r\ndata[1] = val;\r\nerr = m5602_write_sensor(sd, S5K83A_EXPOSURE, data, 2);\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_flip_real(struct gspca_dev *gspca_dev,\r\n__s32 vflip, __s32 hflip)\r\n{\r\nint err;\r\nu8 data[1];\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\ndata[0] = 0x05;\r\nerr = m5602_write_sensor(sd, S5K83A_PAGE_MAP, data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = S5K83A_FLIP_MASK;\r\ndata[0] = (vflip) ? data[0] | 0x40 : data[0];\r\ndata[0] = (hflip) ? data[0] | 0x80 : data[0];\r\nerr = m5602_write_sensor(sd, S5K83A_FLIP, data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = (vflip) ? 0x0b : 0x0a;\r\nerr = m5602_write_sensor(sd, S5K83A_VFLIP_TUNE, data, 1);\r\nif (err < 0)\r\nreturn err;\r\ndata[0] = (hflip) ? 0x0a : 0x0b;\r\nerr = m5602_write_sensor(sd, S5K83A_HFLIP_TUNE, data, 1);\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_hvflip(struct gspca_dev *gspca_dev)\r\n{\r\nint err;\r\nu8 reg;\r\nstruct sd *sd = (struct sd *) gspca_dev;\r\nint hflip = sd->hflip->val;\r\nint vflip = sd->vflip->val;\r\nerr = s5k83a_get_rotation(sd, &reg);\r\nif (err < 0)\r\nreturn err;\r\nif (reg) {\r\nhflip = !hflip;\r\nvflip = !vflip;\r\n}\r\nerr = s5k83a_set_flip_real(gspca_dev, vflip, hflip);\r\nreturn err;\r\n}\r\nstatic int s5k83a_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct gspca_dev *gspca_dev =\r\ncontainer_of(ctrl->handler, struct gspca_dev, ctrl_handler);\r\nint err;\r\nif (!gspca_dev->streaming)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_BRIGHTNESS:\r\nerr = s5k83a_set_brightness(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_EXPOSURE:\r\nerr = s5k83a_set_exposure(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_GAIN:\r\nerr = s5k83a_set_gain(gspca_dev, ctrl->val);\r\nbreak;\r\ncase V4L2_CID_HFLIP:\r\nerr = s5k83a_set_hvflip(gspca_dev);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn err;\r\n}\r\nstatic int s5k83a_set_led_indication(struct sd *sd, u8 val)\r\n{\r\nint err = 0;\r\nu8 data[1];\r\nerr = m5602_read_bridge(sd, M5602_XB_GPIO_DAT, data);\r\nif (err < 0)\r\nreturn err;\r\nif (val)\r\ndata[0] = data[0] | S5K83A_GPIO_LED_MASK;\r\nelse\r\ndata[0] = data[0] & ~S5K83A_GPIO_LED_MASK;\r\nerr = m5602_write_bridge(sd, M5602_XB_GPIO_DAT, data[0]);\r\nreturn err;\r\n}\r\nstatic int s5k83a_get_rotation(struct sd *sd, u8 *reg_data)\r\n{\r\nint err = m5602_read_bridge(sd, M5602_XB_GPIO_DAT, reg_data);\r\n*reg_data = (*reg_data & S5K83A_GPIO_ROTATION_MASK) ? 0 : 1;\r\nreturn err;\r\n}\r\nstatic void s5k83a_dump_registers(struct sd *sd)\r\n{\r\nint address;\r\nu8 page, old_page;\r\nm5602_read_sensor(sd, S5K83A_PAGE_MAP, &old_page, 1);\r\nfor (page = 0; page < 16; page++) {\r\nm5602_write_sensor(sd, S5K83A_PAGE_MAP, &page, 1);\r\npr_info("Dumping the s5k83a register state for page 0x%x\n",\r\npage);\r\nfor (address = 0; address <= 0xff; address++) {\r\nu8 val = 0;\r\nm5602_read_sensor(sd, address, &val, 1);\r\npr_info("register 0x%x contains 0x%x\n", address, val);\r\n}\r\n}\r\npr_info("s5k83a register state dump complete\n");\r\nfor (page = 0; page < 16; page++) {\r\nm5602_write_sensor(sd, S5K83A_PAGE_MAP, &page, 1);\r\npr_info("Probing for which registers that are read/write for page 0x%x\n",\r\npage);\r\nfor (address = 0; address <= 0xff; address++) {\r\nu8 old_val, ctrl_val, test_val = 0xff;\r\nm5602_read_sensor(sd, address, &old_val, 1);\r\nm5602_write_sensor(sd, address, &test_val, 1);\r\nm5602_read_sensor(sd, address, &ctrl_val, 1);\r\nif (ctrl_val == test_val)\r\npr_info("register 0x%x is writeable\n",\r\naddress);\r\nelse\r\npr_info("register 0x%x is read only\n",\r\naddress);\r\nm5602_write_sensor(sd, address, &old_val, 1);\r\n}\r\n}\r\npr_info("Read/write register probing complete\n");\r\nm5602_write_sensor(sd, S5K83A_PAGE_MAP, &old_page, 1);\r\n}
