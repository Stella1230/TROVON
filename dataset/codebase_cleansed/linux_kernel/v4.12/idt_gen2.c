static int\r\nidtg2_route_add_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\r\nu16 table, u16 route_destid, u8 route_port)\r\n{\r\nif (table == RIO_GLOBAL_TABLE)\r\ntable = 0;\r\nelse\r\ntable++;\r\nif (route_port == RIO_INVALID_ROUTE)\r\nroute_port = IDT_DEFAULT_ROUTE;\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nLOCAL_RTE_CONF_DESTID_SEL, table);\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nRIO_STD_RTE_CONF_DESTID_SEL_CSR,\r\n(u32)route_destid);\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nRIO_STD_RTE_CONF_PORT_SEL_CSR,\r\n(u32)route_port);\r\nudelay(10);\r\nreturn 0;\r\n}\r\nstatic int\r\nidtg2_route_get_entry(struct rio_mport *mport, u16 destid, u8 hopcount,\r\nu16 table, u16 route_destid, u8 *route_port)\r\n{\r\nu32 result;\r\nif (table == RIO_GLOBAL_TABLE)\r\ntable = 0;\r\nelse\r\ntable++;\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nLOCAL_RTE_CONF_DESTID_SEL, table);\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nRIO_STD_RTE_CONF_DESTID_SEL_CSR,\r\nroute_destid);\r\nrio_mport_read_config_32(mport, destid, hopcount,\r\nRIO_STD_RTE_CONF_PORT_SEL_CSR, &result);\r\nif (IDT_DEFAULT_ROUTE == (u8)result || IDT_NO_ROUTE == (u8)result)\r\n*route_port = RIO_INVALID_ROUTE;\r\nelse\r\n*route_port = (u8)result;\r\nreturn 0;\r\n}\r\nstatic int\r\nidtg2_route_clr_table(struct rio_mport *mport, u16 destid, u8 hopcount,\r\nu16 table)\r\n{\r\nu32 i;\r\nif (table == RIO_GLOBAL_TABLE)\r\ntable = 0;\r\nelse\r\ntable++;\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nLOCAL_RTE_CONF_DESTID_SEL, table);\r\nfor (i = RIO_STD_RTE_CONF_EXTCFGEN;\r\ni <= (RIO_STD_RTE_CONF_EXTCFGEN | 0xff);) {\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nRIO_STD_RTE_CONF_DESTID_SEL_CSR, i);\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nRIO_STD_RTE_CONF_PORT_SEL_CSR,\r\n(IDT_DEFAULT_ROUTE << 24) | (IDT_DEFAULT_ROUTE << 16) |\r\n(IDT_DEFAULT_ROUTE << 8) | IDT_DEFAULT_ROUTE);\r\ni += 4;\r\n}\r\nreturn 0;\r\n}\r\nstatic int\r\nidtg2_set_domain(struct rio_mport *mport, u16 destid, u8 hopcount,\r\nu8 sw_domain)\r\n{\r\nrio_mport_write_config_32(mport, destid, hopcount,\r\nIDT_RIO_DOMAIN, (u32)sw_domain);\r\nreturn 0;\r\n}\r\nstatic int\r\nidtg2_get_domain(struct rio_mport *mport, u16 destid, u8 hopcount,\r\nu8 *sw_domain)\r\n{\r\nu32 regval;\r\nrio_mport_read_config_32(mport, destid, hopcount,\r\nIDT_RIO_DOMAIN, &regval);\r\n*sw_domain = (u8)(regval & 0xff);\r\nreturn 0;\r\n}\r\nstatic int\r\nidtg2_em_init(struct rio_dev *rdev)\r\n{\r\nu32 regval;\r\nint i, tmp;\r\npr_debug("RIO: %s [%d:%d]\n", __func__, rdev->destid, rdev->hopcount);\r\nrio_write_config_32(rdev, IDT_PW_INFO_CSR, 0x0000e000);\r\nrio_write_config_32(rdev, IDT_LT_ERR_REPORT_EN,\r\nREM_LTL_ERR_ILLTRAN | REM_LTL_ERR_UNSOLR |\r\nREM_LTL_ERR_UNSUPTR);\r\nrio_read_config_32(rdev, IDT_DEV_CTRL_1, &regval);\r\nrio_write_config_32(rdev, IDT_DEV_CTRL_1,\r\nregval | IDT_DEV_CTRL_1_GENPW | IDT_DEV_CTRL_1_PRSTBEH);\r\nrio_write_config_32(rdev, IDT_PORT_ERR_REPORT_EN_BC, 0x807e8037);\r\nrio_write_config_32(rdev, IDT_PORT_ISERR_REPORT_EN_BC,\r\nIDT_PORT_INIT_TX_ACQUIRED);\r\ntmp = RIO_GET_TOTAL_PORTS(rdev->swpinfo);\r\nfor (i = 0; i < tmp; i++) {\r\nrio_read_config_32(rdev, IDT_PORT_OPS(i), &regval);\r\nrio_write_config_32(rdev,\r\nIDT_PORT_OPS(i), regval | IDT_PORT_OPS_GENPW |\r\nIDT_PORT_OPS_PL_ELOG |\r\nIDT_PORT_OPS_LL_ELOG |\r\nIDT_PORT_OPS_LT_ELOG);\r\n}\r\nrio_write_config_32(rdev, IDT_ERR_CAP, IDT_ERR_CAP_LOG_OVERWR);\r\nrio_write_config_32(rdev, IDT_LANE_ERR_REPORT_EN_BC, 0);\r\ntmp = (rdev->did == RIO_DID_IDTCPS1848) ? 48 : 16;\r\nfor (i = 0; i < tmp; i++) {\r\nrio_read_config_32(rdev, IDT_LANE_CTRL(i), &regval);\r\nrio_write_config_32(rdev, IDT_LANE_CTRL(i),\r\nregval | IDT_LANE_CTRL_GENPW);\r\n}\r\nrio_write_config_32(rdev, IDT_AUX_PORT_ERR_CAP_EN, 0);\r\nrio_write_config_32(rdev, IDT_AUX_ERR_REPORT_EN, 0);\r\nrio_write_config_32(rdev, IDT_JTAG_CTRL, 0);\r\nrio_read_config_32(rdev, IDT_I2C_MCTRL, &regval);\r\nrio_write_config_32(rdev, IDT_I2C_MCTRL, regval & ~IDT_I2C_MCTRL_GENPW);\r\nrio_write_config_32(rdev, IDT_CFGBLK_ERR_CAPTURE_EN, 0);\r\nrio_read_config_32(rdev, IDT_CFGBLK_ERR_REPORT, &regval);\r\nrio_write_config_32(rdev, IDT_CFGBLK_ERR_REPORT,\r\nregval & ~IDT_CFGBLK_ERR_REPORT_GENPW);\r\nrio_write_config_32(rdev,\r\nrdev->phys_efptr + RIO_PORT_LINKTO_CTL_CSR, 0x8e << 8);\r\nreturn 0;\r\n}\r\nstatic int\r\nidtg2_em_handler(struct rio_dev *rdev, u8 portnum)\r\n{\r\nu32 regval, em_perrdet, em_ltlerrdet;\r\nrio_read_config_32(rdev,\r\nrdev->em_efptr + RIO_EM_LTL_ERR_DETECT, &em_ltlerrdet);\r\nif (em_ltlerrdet) {\r\nif (em_ltlerrdet & REM_LTL_ERR_IMPSPEC) {\r\nrio_read_config_32(rdev,\r\nIDT_ISLTL_ADDRESS_CAP, &regval);\r\npr_debug("RIO: %s Implementation Specific LTL errors" \\r\n" 0x%x @(0x%x)\n",\r\nrio_name(rdev), em_ltlerrdet, regval);\r\nrio_write_config_32(rdev, IDT_ISLTL_ADDRESS_CAP, 0);\r\n}\r\n}\r\nrio_read_config_32(rdev,\r\nrdev->em_efptr + RIO_EM_PN_ERR_DETECT(portnum), &em_perrdet);\r\nif (em_perrdet) {\r\nif (em_perrdet & REM_PED_IMPL_SPEC) {\r\nrio_read_config_32(rdev,\r\nIDT_PORT_ISERR_DET(portnum), &regval);\r\npr_debug("RIO: %s Implementation Specific Port" \\r\n" errors 0x%x\n", rio_name(rdev), regval);\r\nrio_write_config_32(rdev,\r\nIDT_PORT_ISERR_DET(portnum), 0);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t\r\nidtg2_show_errlog(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct rio_dev *rdev = to_rio_dev(dev);\r\nssize_t len = 0;\r\nu32 regval;\r\nwhile (!rio_read_config_32(rdev, IDT_ERR_RD, &regval)) {\r\nif (!regval)\r\nbreak;\r\nlen += snprintf(buf + len, PAGE_SIZE - len,\r\n"%08x\n", regval);\r\nif (len >= (PAGE_SIZE - 10))\r\nbreak;\r\n}\r\nreturn len;\r\n}\r\nstatic int idtg2_sysfs(struct rio_dev *rdev, bool create)\r\n{\r\nstruct device *dev = &rdev->dev;\r\nint err = 0;\r\nif (create) {\r\nerr = device_create_file(dev, &dev_attr_errlog);\r\nif (err)\r\ndev_err(dev, "Unable create sysfs errlog file\n");\r\n} else\r\ndevice_remove_file(dev, &dev_attr_errlog);\r\nreturn err;\r\n}\r\nstatic int idtg2_probe(struct rio_dev *rdev, const struct rio_device_id *id)\r\n{\r\npr_debug("RIO: %s for %s\n", __func__, rio_name(rdev));\r\nspin_lock(&rdev->rswitch->lock);\r\nif (rdev->rswitch->ops) {\r\nspin_unlock(&rdev->rswitch->lock);\r\nreturn -EINVAL;\r\n}\r\nrdev->rswitch->ops = &idtg2_switch_ops;\r\nif (rdev->do_enum) {\r\nrio_write_config_32(rdev,\r\nRIO_STD_RTE_DEFAULT_PORT, IDT_NO_ROUTE);\r\n}\r\nspin_unlock(&rdev->rswitch->lock);\r\nidtg2_sysfs(rdev, true);\r\nreturn 0;\r\n}\r\nstatic void idtg2_remove(struct rio_dev *rdev)\r\n{\r\npr_debug("RIO: %s for %s\n", __func__, rio_name(rdev));\r\nspin_lock(&rdev->rswitch->lock);\r\nif (rdev->rswitch->ops != &idtg2_switch_ops) {\r\nspin_unlock(&rdev->rswitch->lock);\r\nreturn;\r\n}\r\nrdev->rswitch->ops = NULL;\r\nspin_unlock(&rdev->rswitch->lock);\r\nidtg2_sysfs(rdev, false);\r\n}\r\nstatic int __init idtg2_init(void)\r\n{\r\nreturn rio_register_driver(&idtg2_driver);\r\n}\r\nstatic void __exit idtg2_exit(void)\r\n{\r\npr_debug("RIO: %s\n", __func__);\r\nrio_unregister_driver(&idtg2_driver);\r\npr_debug("RIO: %s done\n", __func__);\r\n}
