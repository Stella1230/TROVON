acpi_status acpi_allocate_root_table(u32 initial_table_count)\r\n{\r\nacpi_gbl_root_table_list.max_table_count = initial_table_count;\r\nacpi_gbl_root_table_list.flags = ACPI_ROOT_ALLOW_RESIZE;\r\nreturn (acpi_tb_resize_root_table_list());\r\n}\r\nacpi_status ACPI_INIT_FUNCTION\r\nacpi_initialize_tables(struct acpi_table_desc *initial_table_array,\r\nu32 initial_table_count, u8 allow_resize)\r\n{\r\nacpi_physical_address rsdp_address;\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_initialize_tables);\r\nif (!initial_table_array) {\r\nstatus = acpi_allocate_root_table(initial_table_count);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\n} else {\r\nmemset(initial_table_array, 0,\r\n(acpi_size)initial_table_count *\r\nsizeof(struct acpi_table_desc));\r\nacpi_gbl_root_table_list.tables = initial_table_array;\r\nacpi_gbl_root_table_list.max_table_count = initial_table_count;\r\nacpi_gbl_root_table_list.flags = ACPI_ROOT_ORIGIN_UNKNOWN;\r\nif (allow_resize) {\r\nacpi_gbl_root_table_list.flags |=\r\nACPI_ROOT_ALLOW_RESIZE;\r\n}\r\n}\r\nrsdp_address = acpi_os_get_root_pointer();\r\nif (!rsdp_address) {\r\nreturn_ACPI_STATUS(AE_NOT_FOUND);\r\n}\r\nstatus = acpi_tb_parse_root_table(rsdp_address);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status ACPI_INIT_FUNCTION acpi_reallocate_root_table(void)\r\n{\r\nacpi_status status;\r\nu32 i;\r\nACPI_FUNCTION_TRACE(acpi_reallocate_root_table);\r\nif (acpi_gbl_root_table_list.flags & ACPI_ROOT_ORIGIN_ALLOCATED) {\r\nreturn_ACPI_STATUS(AE_SUPPORT);\r\n}\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; ++i) {\r\nif (acpi_gbl_root_table_list.tables[i].pointer) {\r\nACPI_ERROR((AE_INFO,\r\n"Table [%4.4s] is not invalidated during early boot stage",\r\nacpi_gbl_root_table_list.tables[i].\r\nsignature.ascii));\r\n}\r\n}\r\nacpi_gbl_root_table_list.flags |= ACPI_ROOT_ALLOW_RESIZE;\r\nstatus = acpi_tb_resize_root_table_list();\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_get_table_header(char *signature,\r\nu32 instance, struct acpi_table_header *out_table_header)\r\n{\r\nu32 i;\r\nu32 j;\r\nstruct acpi_table_header *header;\r\nif (!signature || !out_table_header) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\nfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\r\ni++) {\r\nif (!ACPI_COMPARE_NAME\r\n(&(acpi_gbl_root_table_list.tables[i].signature),\r\nsignature)) {\r\ncontinue;\r\n}\r\nif (++j < instance) {\r\ncontinue;\r\n}\r\nif (!acpi_gbl_root_table_list.tables[i].pointer) {\r\nif ((acpi_gbl_root_table_list.tables[i].flags &\r\nACPI_TABLE_ORIGIN_MASK) ==\r\nACPI_TABLE_ORIGIN_INTERNAL_PHYSICAL) {\r\nheader =\r\nacpi_os_map_memory(acpi_gbl_root_table_list.\r\ntables[i].address,\r\nsizeof(struct\r\nacpi_table_header));\r\nif (!header) {\r\nreturn (AE_NO_MEMORY);\r\n}\r\nmemcpy(out_table_header, header,\r\nsizeof(struct acpi_table_header));\r\nacpi_os_unmap_memory(header,\r\nsizeof(struct\r\nacpi_table_header));\r\n} else {\r\nreturn (AE_NOT_FOUND);\r\n}\r\n} else {\r\nmemcpy(out_table_header,\r\nacpi_gbl_root_table_list.tables[i].pointer,\r\nsizeof(struct acpi_table_header));\r\n}\r\nreturn (AE_OK);\r\n}\r\nreturn (AE_NOT_FOUND);\r\n}\r\nacpi_status\r\nacpi_get_table(char *signature,\r\nu32 instance, struct acpi_table_header ** out_table)\r\n{\r\nu32 i;\r\nu32 j;\r\nacpi_status status = AE_NOT_FOUND;\r\nstruct acpi_table_desc *table_desc;\r\nif (!signature || !out_table) {\r\nreturn (AE_BAD_PARAMETER);\r\n}\r\n*out_table = NULL;\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0, j = 0; i < acpi_gbl_root_table_list.current_table_count;\r\ni++) {\r\ntable_desc = &acpi_gbl_root_table_list.tables[i];\r\nif (!ACPI_COMPARE_NAME(&table_desc->signature, signature)) {\r\ncontinue;\r\n}\r\nif (++j < instance) {\r\ncontinue;\r\n}\r\nstatus = acpi_tb_get_table(table_desc, out_table);\r\nbreak;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn (status);\r\n}\r\nvoid acpi_put_table(struct acpi_table_header *table)\r\n{\r\nu32 i;\r\nstruct acpi_table_desc *table_desc;\r\nACPI_FUNCTION_TRACE(acpi_put_table);\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nfor (i = 0; i < acpi_gbl_root_table_list.current_table_count; i++) {\r\ntable_desc = &acpi_gbl_root_table_list.tables[i];\r\nif (table_desc->pointer != table) {\r\ncontinue;\r\n}\r\nacpi_tb_put_table(table_desc);\r\nbreak;\r\n}\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_VOID;\r\n}\r\nacpi_status\r\nacpi_get_table_by_index(u32 table_index, struct acpi_table_header **out_table)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_get_table_by_index);\r\nif (!out_table) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\n*out_table = NULL;\r\n(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);\r\nif (table_index >= acpi_gbl_root_table_list.current_table_count) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto unlock_and_exit;\r\n}\r\nstatus =\r\nacpi_tb_get_table(&acpi_gbl_root_table_list.tables[table_index],\r\nout_table);\r\nunlock_and_exit:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_TABLES);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status\r\nacpi_install_table_handler(acpi_table_handler handler, void *context)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_install_table_handler);\r\nif (!handler) {\r\nreturn_ACPI_STATUS(AE_BAD_PARAMETER);\r\n}\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (acpi_gbl_table_handler) {\r\nstatus = AE_ALREADY_EXISTS;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_table_handler = handler;\r\nacpi_gbl_table_handler_context = context;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}\r\nacpi_status acpi_remove_table_handler(acpi_table_handler handler)\r\n{\r\nacpi_status status;\r\nACPI_FUNCTION_TRACE(acpi_remove_table_handler);\r\nstatus = acpi_ut_acquire_mutex(ACPI_MTX_EVENTS);\r\nif (ACPI_FAILURE(status)) {\r\nreturn_ACPI_STATUS(status);\r\n}\r\nif (!handler || handler != acpi_gbl_table_handler) {\r\nstatus = AE_BAD_PARAMETER;\r\ngoto cleanup;\r\n}\r\nacpi_gbl_table_handler = NULL;\r\ncleanup:\r\n(void)acpi_ut_release_mutex(ACPI_MTX_EVENTS);\r\nreturn_ACPI_STATUS(status);\r\n}
