static const struct mtk_mdp_fmt *mtk_mdp_find_fmt(u32 pixelformat, u32 type)\r\n{\r\nu32 i, flag;\r\nflag = V4L2_TYPE_IS_OUTPUT(type) ? MTK_MDP_FMT_FLAG_OUTPUT :\r\nMTK_MDP_FMT_FLAG_CAPTURE;\r\nfor (i = 0; i < ARRAY_SIZE(mtk_mdp_formats); ++i) {\r\nif (!(mtk_mdp_formats[i].flags & flag))\r\ncontinue;\r\nif (mtk_mdp_formats[i].pixelformat == pixelformat)\r\nreturn &mtk_mdp_formats[i];\r\n}\r\nreturn NULL;\r\n}\r\nstatic const struct mtk_mdp_fmt *mtk_mdp_find_fmt_by_index(u32 index, u32 type)\r\n{\r\nu32 i, flag, num = 0;\r\nflag = V4L2_TYPE_IS_OUTPUT(type) ? MTK_MDP_FMT_FLAG_OUTPUT :\r\nMTK_MDP_FMT_FLAG_CAPTURE;\r\nfor (i = 0; i < ARRAY_SIZE(mtk_mdp_formats); ++i) {\r\nif (!(mtk_mdp_formats[i].flags & flag))\r\ncontinue;\r\nif (index == num)\r\nreturn &mtk_mdp_formats[i];\r\nnum++;\r\n}\r\nreturn NULL;\r\n}\r\nstatic void mtk_mdp_bound_align_image(u32 *w, unsigned int wmin,\r\nunsigned int wmax, unsigned int align_w,\r\nu32 *h, unsigned int hmin,\r\nunsigned int hmax, unsigned int align_h)\r\n{\r\nint org_w, org_h, step_w, step_h;\r\nint walign, halign;\r\norg_w = *w;\r\norg_h = *h;\r\nwalign = ffs(align_w) - 1;\r\nhalign = ffs(align_h) - 1;\r\nv4l_bound_align_image(w, wmin, wmax, walign, h, hmin, hmax, halign, 0);\r\nstep_w = 1 << walign;\r\nstep_h = 1 << halign;\r\nif (*w < org_w && (*w + step_w) <= wmax)\r\n*w += step_w;\r\nif (*h < org_h && (*h + step_h) <= hmax)\r\n*h += step_h;\r\n}\r\nstatic const struct mtk_mdp_fmt *mtk_mdp_try_fmt_mplane(struct mtk_mdp_ctx *ctx,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nstruct mtk_mdp_variant *variant = mdp->variant;\r\nstruct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;\r\nconst struct mtk_mdp_fmt *fmt;\r\nu32 max_w, max_h, align_w, align_h;\r\nu32 min_w, min_h, org_w, org_h;\r\nint i;\r\nfmt = mtk_mdp_find_fmt(pix_mp->pixelformat, f->type);\r\nif (!fmt)\r\nfmt = mtk_mdp_find_fmt_by_index(0, f->type);\r\nif (!fmt) {\r\ndev_dbg(&ctx->mdp_dev->pdev->dev,\r\n"pixelformat format 0x%X invalid\n",\r\npix_mp->pixelformat);\r\nreturn NULL;\r\n}\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->pixelformat = fmt->pixelformat;\r\nif (!V4L2_TYPE_IS_OUTPUT(f->type)) {\r\npix_mp->colorspace = ctx->colorspace;\r\npix_mp->xfer_func = ctx->xfer_func;\r\npix_mp->ycbcr_enc = ctx->ycbcr_enc;\r\npix_mp->quantization = ctx->quant;\r\n}\r\nmemset(pix_mp->reserved, 0, sizeof(pix_mp->reserved));\r\nmax_w = variant->pix_max->target_rot_dis_w;\r\nmax_h = variant->pix_max->target_rot_dis_h;\r\nif (fmt->align == NULL) {\r\nalign_w = variant->pix_align->org_w;\r\nalign_h = variant->pix_align->org_h;\r\n} else {\r\nalign_w = fmt->align->org_w;\r\nalign_h = fmt->align->org_h;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(f->type)) {\r\nmin_w = variant->pix_min->org_w;\r\nmin_h = variant->pix_min->org_h;\r\n} else {\r\nmin_w = variant->pix_min->target_rot_dis_w;\r\nmin_h = variant->pix_min->target_rot_dis_h;\r\n}\r\nmtk_mdp_dbg(2, "[%d] type:%d, wxh:%ux%u, align:%ux%u, max:%ux%u",\r\nctx->id, f->type, pix_mp->width, pix_mp->height,\r\nalign_w, align_h, max_w, max_h);\r\norg_w = pix_mp->width;\r\norg_h = pix_mp->height;\r\nmtk_mdp_bound_align_image(&pix_mp->width, min_w, max_w, align_w,\r\n&pix_mp->height, min_h, max_h, align_h);\r\nif (org_w != pix_mp->width || org_h != pix_mp->height)\r\nmtk_mdp_dbg(1, "[%d] size change:%ux%u to %ux%u", ctx->id,\r\norg_w, org_h, pix_mp->width, pix_mp->height);\r\npix_mp->num_planes = fmt->num_planes;\r\nfor (i = 0; i < pix_mp->num_planes; ++i) {\r\nint bpl = (pix_mp->width * fmt->row_depth[i]) / 8;\r\nint sizeimage = (pix_mp->width * pix_mp->height *\r\nfmt->depth[i]) / 8;\r\npix_mp->plane_fmt[i].bytesperline = bpl;\r\nif (pix_mp->plane_fmt[i].sizeimage < sizeimage)\r\npix_mp->plane_fmt[i].sizeimage = sizeimage;\r\nmemset(pix_mp->plane_fmt[i].reserved, 0,\r\nsizeof(pix_mp->plane_fmt[i].reserved));\r\nmtk_mdp_dbg(2, "[%d] p%d, bpl:%d, sizeimage:%u (%u)", ctx->id,\r\ni, bpl, pix_mp->plane_fmt[i].sizeimage, sizeimage);\r\n}\r\nreturn fmt;\r\n}\r\nstatic struct mtk_mdp_frame *mtk_mdp_ctx_get_frame(struct mtk_mdp_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn &ctx->s_frame;\r\nreturn &ctx->d_frame;\r\n}\r\nstatic void mtk_mdp_check_crop_change(u32 new_w, u32 new_h, u32 *w, u32 *h)\r\n{\r\nif (new_w != *w || new_h != *h) {\r\nmtk_mdp_dbg(1, "size change:%dx%d to %dx%d",\r\n*w, *h, new_w, new_h);\r\n*w = new_w;\r\n*h = new_h;\r\n}\r\n}\r\nstatic int mtk_mdp_try_crop(struct mtk_mdp_ctx *ctx, u32 type,\r\nstruct v4l2_rect *r)\r\n{\r\nstruct mtk_mdp_frame *frame;\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nstruct mtk_mdp_variant *variant = mdp->variant;\r\nu32 align_w, align_h, new_w, new_h;\r\nu32 min_w, min_h, max_w, max_h;\r\nif (r->top < 0 || r->left < 0) {\r\ndev_err(&ctx->mdp_dev->pdev->dev,\r\n"doesn't support negative values for top & left\n");\r\nreturn -EINVAL;\r\n}\r\nmtk_mdp_dbg(2, "[%d] type:%d, set wxh:%dx%d", ctx->id, type,\r\nr->width, r->height);\r\nframe = mtk_mdp_ctx_get_frame(ctx, type);\r\nmax_w = frame->width;\r\nmax_h = frame->height;\r\nnew_w = r->width;\r\nnew_h = r->height;\r\nif (V4L2_TYPE_IS_OUTPUT(type)) {\r\nalign_w = 1;\r\nalign_h = 1;\r\nmin_w = 64;\r\nmin_h = 32;\r\n} else {\r\nalign_w = variant->pix_align->target_w;\r\nalign_h = variant->pix_align->target_h;\r\nif (ctx->ctrls.rotate->val == 90 ||\r\nctx->ctrls.rotate->val == 270) {\r\nmax_w = frame->height;\r\nmax_h = frame->width;\r\nmin_w = variant->pix_min->target_rot_en_w;\r\nmin_h = variant->pix_min->target_rot_en_h;\r\nnew_w = r->height;\r\nnew_h = r->width;\r\n} else {\r\nmin_w = variant->pix_min->target_rot_dis_w;\r\nmin_h = variant->pix_min->target_rot_dis_h;\r\n}\r\n}\r\nmtk_mdp_dbg(2, "[%d] align:%dx%d, min:%dx%d, new:%dx%d", ctx->id,\r\nalign_w, align_h, min_w, min_h, new_w, new_h);\r\nmtk_mdp_bound_align_image(&new_w, min_w, max_w, align_w,\r\n&new_h, min_h, max_h, align_h);\r\nif (!V4L2_TYPE_IS_OUTPUT(type) &&\r\n(ctx->ctrls.rotate->val == 90 ||\r\nctx->ctrls.rotate->val == 270))\r\nmtk_mdp_check_crop_change(new_h, new_w,\r\n&r->width, &r->height);\r\nelse\r\nmtk_mdp_check_crop_change(new_w, new_h,\r\n&r->width, &r->height);\r\nif (r->left + new_w > max_w)\r\nr->left = max_w - new_w;\r\nif (r->top + new_h > max_h)\r\nr->top = max_h - new_h;\r\nif (r->left & 1)\r\nr->left -= 1;\r\nmtk_mdp_dbg(2, "[%d] crop l,t,w,h:%d,%d,%d,%d, max:%dx%d", ctx->id,\r\nr->left, r->top, r->width,\r\nr->height, max_w, max_h);\r\nreturn 0;\r\n}\r\nstatic inline struct mtk_mdp_ctx *fh_to_ctx(struct v4l2_fh *fh)\r\n{\r\nreturn container_of(fh, struct mtk_mdp_ctx, fh);\r\n}\r\nstatic inline struct mtk_mdp_ctx *ctrl_to_ctx(struct v4l2_ctrl *ctrl)\r\n{\r\nreturn container_of(ctrl->handler, struct mtk_mdp_ctx, ctrl_handler);\r\n}\r\nvoid mtk_mdp_ctx_state_lock_set(struct mtk_mdp_ctx *ctx, u32 state)\r\n{\r\nmutex_lock(&ctx->slock);\r\nctx->state |= state;\r\nmutex_unlock(&ctx->slock);\r\n}\r\nstatic void mtk_mdp_ctx_state_lock_clear(struct mtk_mdp_ctx *ctx, u32 state)\r\n{\r\nmutex_lock(&ctx->slock);\r\nctx->state &= ~state;\r\nmutex_unlock(&ctx->slock);\r\n}\r\nstatic bool mtk_mdp_ctx_state_is_set(struct mtk_mdp_ctx *ctx, u32 mask)\r\n{\r\nbool ret;\r\nmutex_lock(&ctx->slock);\r\nret = (ctx->state & mask) == mask;\r\nmutex_unlock(&ctx->slock);\r\nreturn ret;\r\n}\r\nstatic void mtk_mdp_ctx_lock(struct vb2_queue *vq)\r\n{\r\nstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vq);\r\nmutex_lock(&ctx->mdp_dev->lock);\r\n}\r\nstatic void mtk_mdp_ctx_unlock(struct vb2_queue *vq)\r\n{\r\nstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vq);\r\nmutex_unlock(&ctx->mdp_dev->lock);\r\n}\r\nstatic void mtk_mdp_set_frame_size(struct mtk_mdp_frame *frame, int width,\r\nint height)\r\n{\r\nframe->width = width;\r\nframe->height = height;\r\nframe->crop.width = width;\r\nframe->crop.height = height;\r\nframe->crop.left = 0;\r\nframe->crop.top = 0;\r\n}\r\nstatic int mtk_mdp_m2m_start_streaming(struct vb2_queue *q, unsigned int count)\r\n{\r\nstruct mtk_mdp_ctx *ctx = q->drv_priv;\r\nint ret;\r\nret = pm_runtime_get_sync(&ctx->mdp_dev->pdev->dev);\r\nif (ret < 0)\r\nmtk_mdp_dbg(1, "[%d] pm_runtime_get_sync failed:%d",\r\nctx->id, ret);\r\nreturn 0;\r\n}\r\nstatic void *mtk_mdp_m2m_buf_remove(struct mtk_mdp_ctx *ctx,\r\nenum v4l2_buf_type type)\r\n{\r\nif (V4L2_TYPE_IS_OUTPUT(type))\r\nreturn v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nelse\r\nreturn v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\n}\r\nstatic void mtk_mdp_m2m_stop_streaming(struct vb2_queue *q)\r\n{\r\nstruct mtk_mdp_ctx *ctx = q->drv_priv;\r\nstruct vb2_buffer *vb;\r\nvb = mtk_mdp_m2m_buf_remove(ctx, q->type);\r\nwhile (vb != NULL) {\r\nv4l2_m2m_buf_done(to_vb2_v4l2_buffer(vb), VB2_BUF_STATE_ERROR);\r\nvb = mtk_mdp_m2m_buf_remove(ctx, q->type);\r\n}\r\npm_runtime_put(&ctx->mdp_dev->pdev->dev);\r\n}\r\nstatic void mtk_mdp_m2m_job_abort(void *priv)\r\n{\r\n}\r\nstatic void mtk_mdp_prepare_addr(struct mtk_mdp_ctx *ctx,\r\nstruct vb2_buffer *vb,\r\nstruct mtk_mdp_frame *frame,\r\nstruct mtk_mdp_addr *addr)\r\n{\r\nu32 pix_size, planes, i;\r\npix_size = frame->width * frame->height;\r\nplanes = min_t(u32, frame->fmt->num_planes, ARRAY_SIZE(addr->addr));\r\nfor (i = 0; i < planes; i++)\r\naddr->addr[i] = vb2_dma_contig_plane_dma_addr(vb, i);\r\nif (planes == 1) {\r\nif (frame->fmt->pixelformat == V4L2_PIX_FMT_YVU420) {\r\naddr->addr[1] = (dma_addr_t)(addr->addr[0] + pix_size);\r\naddr->addr[2] = (dma_addr_t)(addr->addr[1] +\r\n(pix_size >> 2));\r\n} else {\r\ndev_err(&ctx->mdp_dev->pdev->dev,\r\n"Invalid pixelformat:0x%x\n",\r\nframe->fmt->pixelformat);\r\n}\r\n}\r\nmtk_mdp_dbg(3, "[%d] planes:%d, size:%d, addr:%p,%p,%p",\r\nctx->id, planes, pix_size, (void *)addr->addr[0],\r\n(void *)addr->addr[1], (void *)addr->addr[2]);\r\n}\r\nstatic void mtk_mdp_m2m_get_bufs(struct mtk_mdp_ctx *ctx)\r\n{\r\nstruct mtk_mdp_frame *s_frame, *d_frame;\r\nstruct vb2_buffer *src_vb, *dst_vb;\r\nstruct vb2_v4l2_buffer *src_vbuf, *dst_vbuf;\r\ns_frame = &ctx->s_frame;\r\nd_frame = &ctx->d_frame;\r\nsrc_vb = v4l2_m2m_next_src_buf(ctx->m2m_ctx);\r\nmtk_mdp_prepare_addr(ctx, src_vb, s_frame, &s_frame->addr);\r\ndst_vb = v4l2_m2m_next_dst_buf(ctx->m2m_ctx);\r\nmtk_mdp_prepare_addr(ctx, dst_vb, d_frame, &d_frame->addr);\r\nsrc_vbuf = to_vb2_v4l2_buffer(src_vb);\r\ndst_vbuf = to_vb2_v4l2_buffer(dst_vb);\r\ndst_vbuf->vb2_buf.timestamp = src_vbuf->vb2_buf.timestamp;\r\n}\r\nstatic void mtk_mdp_process_done(void *priv, int vb_state)\r\n{\r\nstruct mtk_mdp_dev *mdp = priv;\r\nstruct mtk_mdp_ctx *ctx;\r\nstruct vb2_buffer *src_vb, *dst_vb;\r\nstruct vb2_v4l2_buffer *src_vbuf = NULL, *dst_vbuf = NULL;\r\nctx = v4l2_m2m_get_curr_priv(mdp->m2m_dev);\r\nif (!ctx)\r\nreturn;\r\nsrc_vb = v4l2_m2m_src_buf_remove(ctx->m2m_ctx);\r\nsrc_vbuf = to_vb2_v4l2_buffer(src_vb);\r\ndst_vb = v4l2_m2m_dst_buf_remove(ctx->m2m_ctx);\r\ndst_vbuf = to_vb2_v4l2_buffer(dst_vb);\r\ndst_vbuf->vb2_buf.timestamp = src_vbuf->vb2_buf.timestamp;\r\ndst_vbuf->timecode = src_vbuf->timecode;\r\ndst_vbuf->flags &= ~V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\ndst_vbuf->flags |= src_vbuf->flags & V4L2_BUF_FLAG_TSTAMP_SRC_MASK;\r\nv4l2_m2m_buf_done(src_vbuf, vb_state);\r\nv4l2_m2m_buf_done(dst_vbuf, vb_state);\r\nv4l2_m2m_job_finish(ctx->mdp_dev->m2m_dev, ctx->m2m_ctx);\r\n}\r\nstatic void mtk_mdp_m2m_worker(struct work_struct *work)\r\n{\r\nstruct mtk_mdp_ctx *ctx =\r\ncontainer_of(work, struct mtk_mdp_ctx, work);\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nenum vb2_buffer_state buf_state = VB2_BUF_STATE_ERROR;\r\nint ret;\r\nif (mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_CTX_ERROR)) {\r\ndev_err(&mdp->pdev->dev, "ctx is in error state");\r\ngoto worker_end;\r\n}\r\nmtk_mdp_m2m_get_bufs(ctx);\r\nmtk_mdp_hw_set_input_addr(ctx, &ctx->s_frame.addr);\r\nmtk_mdp_hw_set_output_addr(ctx, &ctx->d_frame.addr);\r\nmtk_mdp_hw_set_in_size(ctx);\r\nmtk_mdp_hw_set_in_image_format(ctx);\r\nmtk_mdp_hw_set_out_size(ctx);\r\nmtk_mdp_hw_set_out_image_format(ctx);\r\nmtk_mdp_hw_set_rotation(ctx);\r\nmtk_mdp_hw_set_global_alpha(ctx);\r\nret = mtk_mdp_vpu_process(&ctx->vpu);\r\nif (ret) {\r\ndev_err(&mdp->pdev->dev, "processing failed: %d", ret);\r\ngoto worker_end;\r\n}\r\nbuf_state = VB2_BUF_STATE_DONE;\r\nworker_end:\r\nmtk_mdp_process_done(mdp, buf_state);\r\n}\r\nstatic void mtk_mdp_m2m_device_run(void *priv)\r\n{\r\nstruct mtk_mdp_ctx *ctx = priv;\r\nqueue_work(ctx->mdp_dev->job_wq, &ctx->work);\r\n}\r\nstatic int mtk_mdp_m2m_queue_setup(struct vb2_queue *vq,\r\nunsigned int *num_buffers, unsigned int *num_planes,\r\nunsigned int sizes[], struct device *alloc_devs[])\r\n{\r\nstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vq);\r\nstruct mtk_mdp_frame *frame;\r\nint i;\r\nframe = mtk_mdp_ctx_get_frame(ctx, vq->type);\r\n*num_planes = frame->fmt->num_planes;\r\nfor (i = 0; i < frame->fmt->num_planes; i++)\r\nsizes[i] = frame->payload[i];\r\nmtk_mdp_dbg(2, "[%d] type:%d, planes:%d, buffers:%d, size:%u,%u",\r\nctx->id, vq->type, *num_planes, *num_buffers,\r\nsizes[0], sizes[1]);\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_buf_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nstruct mtk_mdp_frame *frame;\r\nint i;\r\nframe = mtk_mdp_ctx_get_frame(ctx, vb->vb2_queue->type);\r\nif (!V4L2_TYPE_IS_OUTPUT(vb->vb2_queue->type)) {\r\nfor (i = 0; i < frame->fmt->num_planes; i++)\r\nvb2_set_plane_payload(vb, i, frame->payload[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_mdp_m2m_buf_queue(struct vb2_buffer *vb)\r\n{\r\nstruct mtk_mdp_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);\r\nv4l2_m2m_buf_queue(ctx->m2m_ctx, to_vb2_v4l2_buffer(vb));\r\n}\r\nstatic int mtk_mdp_m2m_querycap(struct file *file, void *fh,\r\nstruct v4l2_capability *cap)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nstrlcpy(cap->driver, MTK_MDP_MODULE_NAME, sizeof(cap->driver));\r\nstrlcpy(cap->card, mdp->pdev->name, sizeof(cap->card));\r\nstrlcpy(cap->bus_info, "platform:mt8173", sizeof(cap->bus_info));\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_enum_fmt_mplane(struct v4l2_fmtdesc *f, u32 type)\r\n{\r\nconst struct mtk_mdp_fmt *fmt;\r\nfmt = mtk_mdp_find_fmt_by_index(f->index, type);\r\nif (!fmt)\r\nreturn -EINVAL;\r\nf->pixelformat = fmt->pixelformat;\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_enum_fmt_mplane_vid_cap(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn mtk_mdp_enum_fmt_mplane(f, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\r\n}\r\nstatic int mtk_mdp_m2m_enum_fmt_mplane_vid_out(struct file *file, void *priv,\r\nstruct v4l2_fmtdesc *f)\r\n{\r\nreturn mtk_mdp_enum_fmt_mplane(f, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\n}\r\nstatic int mtk_mdp_m2m_g_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nstruct mtk_mdp_frame *frame;\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nint i;\r\nmtk_mdp_dbg(2, "[%d] type:%d", ctx->id, f->type);\r\nframe = mtk_mdp_ctx_get_frame(ctx, f->type);\r\npix_mp = &f->fmt.pix_mp;\r\npix_mp->width = frame->width;\r\npix_mp->height = frame->height;\r\npix_mp->field = V4L2_FIELD_NONE;\r\npix_mp->pixelformat = frame->fmt->pixelformat;\r\npix_mp->num_planes = frame->fmt->num_planes;\r\npix_mp->colorspace = ctx->colorspace;\r\npix_mp->xfer_func = ctx->xfer_func;\r\npix_mp->ycbcr_enc = ctx->ycbcr_enc;\r\npix_mp->quantization = ctx->quant;\r\nmtk_mdp_dbg(2, "[%d] wxh:%dx%d", ctx->id,\r\npix_mp->width, pix_mp->height);\r\nfor (i = 0; i < pix_mp->num_planes; ++i) {\r\npix_mp->plane_fmt[i].bytesperline = (frame->width *\r\nframe->fmt->row_depth[i]) / 8;\r\npix_mp->plane_fmt[i].sizeimage = (frame->width *\r\nframe->height * frame->fmt->depth[i]) / 8;\r\nmtk_mdp_dbg(2, "[%d] p%d, bpl:%d, sizeimage:%d", ctx->id, i,\r\npix_mp->plane_fmt[i].bytesperline,\r\npix_mp->plane_fmt[i].sizeimage);\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_try_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nif (!mtk_mdp_try_fmt_mplane(ctx, f))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_s_fmt_mplane(struct file *file, void *fh,\r\nstruct v4l2_format *f)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nstruct vb2_queue *vq;\r\nstruct mtk_mdp_frame *frame;\r\nstruct v4l2_pix_format_mplane *pix_mp;\r\nconst struct mtk_mdp_fmt *fmt;\r\nint i;\r\nmtk_mdp_dbg(2, "[%d] type:%d", ctx->id, f->type);\r\nframe = mtk_mdp_ctx_get_frame(ctx, f->type);\r\nfmt = mtk_mdp_try_fmt_mplane(ctx, f);\r\nif (!fmt) {\r\nmtk_mdp_err("[%d] try_fmt failed, type:%d", ctx->id, f->type);\r\nreturn -EINVAL;\r\n}\r\nframe->fmt = fmt;\r\nvq = v4l2_m2m_get_vq(ctx->m2m_ctx, f->type);\r\nif (vb2_is_streaming(vq)) {\r\ndev_info(&ctx->mdp_dev->pdev->dev, "queue %d busy", f->type);\r\nreturn -EBUSY;\r\n}\r\npix_mp = &f->fmt.pix_mp;\r\nfor (i = 0; i < frame->fmt->num_planes; i++) {\r\nframe->payload[i] = pix_mp->plane_fmt[i].sizeimage;\r\nframe->pitch[i] = pix_mp->plane_fmt[i].bytesperline;\r\n}\r\nmtk_mdp_set_frame_size(frame, pix_mp->width, pix_mp->height);\r\nif (V4L2_TYPE_IS_OUTPUT(f->type)) {\r\nctx->colorspace = pix_mp->colorspace;\r\nctx->xfer_func = pix_mp->xfer_func;\r\nctx->ycbcr_enc = pix_mp->ycbcr_enc;\r\nctx->quant = pix_mp->quantization;\r\n}\r\nif (V4L2_TYPE_IS_OUTPUT(f->type))\r\nmtk_mdp_ctx_state_lock_set(ctx, MTK_MDP_SRC_FMT);\r\nelse\r\nmtk_mdp_ctx_state_lock_set(ctx, MTK_MDP_DST_FMT);\r\nmtk_mdp_dbg(2, "[%d] type:%d, frame:%dx%d", ctx->id, f->type,\r\nframe->width, frame->height);\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_reqbufs(struct file *file, void *fh,\r\nstruct v4l2_requestbuffers *reqbufs)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nif (reqbufs->count == 0) {\r\nif (reqbufs->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)\r\nmtk_mdp_ctx_state_lock_clear(ctx, MTK_MDP_SRC_FMT);\r\nelse\r\nmtk_mdp_ctx_state_lock_clear(ctx, MTK_MDP_DST_FMT);\r\n}\r\nreturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, reqbufs);\r\n}\r\nstatic int mtk_mdp_m2m_streamon(struct file *file, void *fh,\r\nenum v4l2_buf_type type)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nint ret;\r\nif (V4L2_TYPE_IS_OUTPUT(type)) {\r\nif (!mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_SRC_FMT))\r\nreturn -EINVAL;\r\n} else if (!mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_DST_FMT)) {\r\nreturn -EINVAL;\r\n}\r\nif (!mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_VPU_INIT)) {\r\nret = mtk_mdp_vpu_init(&ctx->vpu);\r\nif (ret < 0) {\r\ndev_err(&ctx->mdp_dev->pdev->dev,\r\n"vpu init failed %d\n",\r\nret);\r\nreturn -EINVAL;\r\n}\r\nmtk_mdp_ctx_state_lock_set(ctx, MTK_MDP_VPU_INIT);\r\n}\r\nreturn v4l2_m2m_streamon(file, ctx->m2m_ctx, type);\r\n}\r\nstatic inline bool mtk_mdp_is_target_compose(u32 target)\r\n{\r\nif (target == V4L2_SEL_TGT_COMPOSE_DEFAULT\r\n|| target == V4L2_SEL_TGT_COMPOSE_BOUNDS\r\n|| target == V4L2_SEL_TGT_COMPOSE)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic inline bool mtk_mdp_is_target_crop(u32 target)\r\n{\r\nif (target == V4L2_SEL_TGT_CROP_DEFAULT\r\n|| target == V4L2_SEL_TGT_CROP_BOUNDS\r\n|| target == V4L2_SEL_TGT_CROP)\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int mtk_mdp_m2m_g_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mtk_mdp_frame *frame;\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nbool valid = false;\r\nif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (mtk_mdp_is_target_compose(s->target))\r\nvalid = true;\r\n} else if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (mtk_mdp_is_target_crop(s->target))\r\nvalid = true;\r\n}\r\nif (!valid) {\r\nmtk_mdp_dbg(1, "[%d] invalid type:%d,%u", ctx->id, s->type,\r\ns->target);\r\nreturn -EINVAL;\r\n}\r\nframe = mtk_mdp_ctx_get_frame(ctx, s->type);\r\nswitch (s->target) {\r\ncase V4L2_SEL_TGT_COMPOSE_DEFAULT:\r\ncase V4L2_SEL_TGT_COMPOSE_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_BOUNDS:\r\ncase V4L2_SEL_TGT_CROP_DEFAULT:\r\ns->r.left = 0;\r\ns->r.top = 0;\r\ns->r.width = frame->width;\r\ns->r.height = frame->height;\r\nreturn 0;\r\ncase V4L2_SEL_TGT_COMPOSE:\r\ncase V4L2_SEL_TGT_CROP:\r\ns->r.left = frame->crop.left;\r\ns->r.top = frame->crop.top;\r\ns->r.width = frame->crop.width;\r\ns->r.height = frame->crop.height;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int mtk_mdp_check_scaler_ratio(struct mtk_mdp_variant *var, int src_w,\r\nint src_h, int dst_w, int dst_h, int rot)\r\n{\r\nint tmp_w, tmp_h;\r\nif (rot == 90 || rot == 270) {\r\ntmp_w = dst_h;\r\ntmp_h = dst_w;\r\n} else {\r\ntmp_w = dst_w;\r\ntmp_h = dst_h;\r\n}\r\nif ((src_w / tmp_w) > var->h_scale_down_max ||\r\n(src_h / tmp_h) > var->v_scale_down_max ||\r\n(tmp_w / src_w) > var->h_scale_up_max ||\r\n(tmp_h / src_h) > var->v_scale_up_max)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_s_selection(struct file *file, void *fh,\r\nstruct v4l2_selection *s)\r\n{\r\nstruct mtk_mdp_frame *frame;\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(fh);\r\nstruct v4l2_rect new_r;\r\nstruct mtk_mdp_variant *variant = ctx->mdp_dev->variant;\r\nint ret;\r\nbool valid = false;\r\nif (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {\r\nif (s->target == V4L2_SEL_TGT_COMPOSE)\r\nvalid = true;\r\n} else if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT) {\r\nif (s->target == V4L2_SEL_TGT_CROP)\r\nvalid = true;\r\n}\r\nif (!valid) {\r\nmtk_mdp_dbg(1, "[%d] invalid type:%d,%u", ctx->id, s->type,\r\ns->target);\r\nreturn -EINVAL;\r\n}\r\nnew_r = s->r;\r\nret = mtk_mdp_try_crop(ctx, s->type, &new_r);\r\nif (ret)\r\nreturn ret;\r\nif (mtk_mdp_is_target_crop(s->target))\r\nframe = &ctx->s_frame;\r\nelse\r\nframe = &ctx->d_frame;\r\nif (mtk_mdp_ctx_state_is_set(ctx, MTK_MDP_DST_FMT | MTK_MDP_SRC_FMT)) {\r\nif (V4L2_TYPE_IS_OUTPUT(s->type)) {\r\nret = mtk_mdp_check_scaler_ratio(variant, new_r.width,\r\nnew_r.height, ctx->d_frame.crop.width,\r\nctx->d_frame.crop.height,\r\nctx->ctrls.rotate->val);\r\n} else {\r\nret = mtk_mdp_check_scaler_ratio(variant,\r\nctx->s_frame.crop.width,\r\nctx->s_frame.crop.height, new_r.width,\r\nnew_r.height, ctx->ctrls.rotate->val);\r\n}\r\nif (ret) {\r\ndev_info(&ctx->mdp_dev->pdev->dev,\r\n"Out of scaler range");\r\nreturn -EINVAL;\r\n}\r\n}\r\ns->r = new_r;\r\nframe->crop = new_r;\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_m2m_queue_init(void *priv, struct vb2_queue *src_vq,\r\nstruct vb2_queue *dst_vq)\r\n{\r\nstruct mtk_mdp_ctx *ctx = priv;\r\nint ret;\r\nmemset(src_vq, 0, sizeof(*src_vq));\r\nsrc_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;\r\nsrc_vq->io_modes = VB2_MMAP | VB2_DMABUF;\r\nsrc_vq->drv_priv = ctx;\r\nsrc_vq->ops = &mtk_mdp_m2m_qops;\r\nsrc_vq->mem_ops = &vb2_dma_contig_memops;\r\nsrc_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\nsrc_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\nsrc_vq->dev = &ctx->mdp_dev->pdev->dev;\r\nret = vb2_queue_init(src_vq);\r\nif (ret)\r\nreturn ret;\r\nmemset(dst_vq, 0, sizeof(*dst_vq));\r\ndst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;\r\ndst_vq->io_modes = VB2_MMAP | VB2_DMABUF;\r\ndst_vq->drv_priv = ctx;\r\ndst_vq->ops = &mtk_mdp_m2m_qops;\r\ndst_vq->mem_ops = &vb2_dma_contig_memops;\r\ndst_vq->buf_struct_size = sizeof(struct v4l2_m2m_buffer);\r\ndst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;\r\ndst_vq->dev = &ctx->mdp_dev->pdev->dev;\r\nreturn vb2_queue_init(dst_vq);\r\n}\r\nstatic int mtk_mdp_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct mtk_mdp_ctx *ctx = ctrl_to_ctx(ctrl);\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nstruct mtk_mdp_variant *variant = mdp->variant;\r\nu32 state = MTK_MDP_DST_FMT | MTK_MDP_SRC_FMT;\r\nint ret = 0;\r\nif (ctrl->flags & V4L2_CTRL_FLAG_INACTIVE)\r\nreturn 0;\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_HFLIP:\r\nctx->hflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_VFLIP:\r\nctx->vflip = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_ROTATE:\r\nif (mtk_mdp_ctx_state_is_set(ctx, state)) {\r\nret = mtk_mdp_check_scaler_ratio(variant,\r\nctx->s_frame.crop.width,\r\nctx->s_frame.crop.height,\r\nctx->d_frame.crop.width,\r\nctx->d_frame.crop.height,\r\nctx->ctrls.rotate->val);\r\nif (ret)\r\nreturn -EINVAL;\r\n}\r\nctx->rotation = ctrl->val;\r\nbreak;\r\ncase V4L2_CID_ALPHA_COMPONENT:\r\nctx->d_frame.alpha = ctrl->val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mtk_mdp_ctrls_create(struct mtk_mdp_ctx *ctx)\r\n{\r\nv4l2_ctrl_handler_init(&ctx->ctrl_handler, MTK_MDP_MAX_CTRL_NUM);\r\nctx->ctrls.rotate = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&mtk_mdp_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);\r\nctx->ctrls.hflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&mtk_mdp_ctrl_ops,\r\nV4L2_CID_HFLIP,\r\n0, 1, 1, 0);\r\nctx->ctrls.vflip = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&mtk_mdp_ctrl_ops,\r\nV4L2_CID_VFLIP,\r\n0, 1, 1, 0);\r\nctx->ctrls.global_alpha = v4l2_ctrl_new_std(&ctx->ctrl_handler,\r\n&mtk_mdp_ctrl_ops,\r\nV4L2_CID_ALPHA_COMPONENT,\r\n0, 255, 1, 0);\r\nctx->ctrls_rdy = ctx->ctrl_handler.error == 0;\r\nif (ctx->ctrl_handler.error) {\r\nint err = ctx->ctrl_handler.error;\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\ndev_err(&ctx->mdp_dev->pdev->dev,\r\n"Failed to create control handlers\n");\r\nreturn err;\r\n}\r\nreturn 0;\r\n}\r\nstatic void mtk_mdp_set_default_params(struct mtk_mdp_ctx *ctx)\r\n{\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nstruct mtk_mdp_frame *frame;\r\nframe = mtk_mdp_ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\nframe->fmt = mtk_mdp_find_fmt_by_index(0,\r\nV4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE);\r\nframe->width = mdp->variant->pix_min->org_w;\r\nframe->height = mdp->variant->pix_min->org_h;\r\nframe->payload[0] = frame->width * frame->height;\r\nframe->payload[1] = frame->payload[0] / 2;\r\nframe = mtk_mdp_ctx_get_frame(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\r\nframe->fmt = mtk_mdp_find_fmt_by_index(0,\r\nV4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE);\r\nframe->width = mdp->variant->pix_min->target_rot_dis_w;\r\nframe->height = mdp->variant->pix_min->target_rot_dis_h;\r\nframe->payload[0] = frame->width * frame->height;\r\nframe->payload[1] = frame->payload[0] / 2;\r\n}\r\nstatic int mtk_mdp_m2m_open(struct file *file)\r\n{\r\nstruct mtk_mdp_dev *mdp = video_drvdata(file);\r\nstruct video_device *vfd = video_devdata(file);\r\nstruct mtk_mdp_ctx *ctx = NULL;\r\nint ret;\r\nctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\r\nif (!ctx)\r\nreturn -ENOMEM;\r\nif (mutex_lock_interruptible(&mdp->lock)) {\r\nret = -ERESTARTSYS;\r\ngoto err_lock;\r\n}\r\nmutex_init(&ctx->slock);\r\nctx->id = mdp->id_counter++;\r\nv4l2_fh_init(&ctx->fh, vfd);\r\nfile->private_data = &ctx->fh;\r\nret = mtk_mdp_ctrls_create(ctx);\r\nif (ret)\r\ngoto error_ctrls;\r\nctx->fh.ctrl_handler = &ctx->ctrl_handler;\r\nv4l2_fh_add(&ctx->fh);\r\nINIT_LIST_HEAD(&ctx->list);\r\nctx->mdp_dev = mdp;\r\nmtk_mdp_set_default_params(ctx);\r\nINIT_WORK(&ctx->work, mtk_mdp_m2m_worker);\r\nctx->m2m_ctx = v4l2_m2m_ctx_init(mdp->m2m_dev, ctx,\r\nmtk_mdp_m2m_queue_init);\r\nif (IS_ERR(ctx->m2m_ctx)) {\r\ndev_err(&mdp->pdev->dev, "Failed to initialize m2m context");\r\nret = PTR_ERR(ctx->m2m_ctx);\r\ngoto error_m2m_ctx;\r\n}\r\nctx->fh.m2m_ctx = ctx->m2m_ctx;\r\nif (mdp->ctx_num++ == 0) {\r\nret = vpu_load_firmware(mdp->vpu_dev);\r\nif (ret < 0) {\r\ndev_err(&mdp->pdev->dev,\r\n"vpu_load_firmware failed %d\n", ret);\r\ngoto err_load_vpu;\r\n}\r\nret = mtk_mdp_vpu_register(mdp->pdev);\r\nif (ret < 0) {\r\ndev_err(&mdp->pdev->dev,\r\n"mdp_vpu register failed %d\n", ret);\r\ngoto err_load_vpu;\r\n}\r\n}\r\nlist_add(&ctx->list, &mdp->ctx_list);\r\nmutex_unlock(&mdp->lock);\r\nmtk_mdp_dbg(0, "%s [%d]", dev_name(&mdp->pdev->dev), ctx->id);\r\nreturn 0;\r\nerr_load_vpu:\r\nmdp->ctx_num--;\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nerror_m2m_ctx:\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nerror_ctrls:\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nmutex_unlock(&mdp->lock);\r\nerr_lock:\r\nkfree(ctx);\r\nreturn ret;\r\n}\r\nstatic int mtk_mdp_m2m_release(struct file *file)\r\n{\r\nstruct mtk_mdp_ctx *ctx = fh_to_ctx(file->private_data);\r\nstruct mtk_mdp_dev *mdp = ctx->mdp_dev;\r\nflush_workqueue(mdp->job_wq);\r\nmutex_lock(&mdp->lock);\r\nv4l2_m2m_ctx_release(ctx->m2m_ctx);\r\nv4l2_ctrl_handler_free(&ctx->ctrl_handler);\r\nv4l2_fh_del(&ctx->fh);\r\nv4l2_fh_exit(&ctx->fh);\r\nmtk_mdp_vpu_deinit(&ctx->vpu);\r\nmdp->ctx_num--;\r\nlist_del_init(&ctx->list);\r\nmtk_mdp_dbg(0, "%s [%d]", dev_name(&mdp->pdev->dev), ctx->id);\r\nmutex_unlock(&mdp->lock);\r\nkfree(ctx);\r\nreturn 0;\r\n}\r\nint mtk_mdp_register_m2m_device(struct mtk_mdp_dev *mdp)\r\n{\r\nstruct device *dev = &mdp->pdev->dev;\r\nint ret;\r\nmdp->variant = &mtk_mdp_default_variant;\r\nmdp->vdev = video_device_alloc();\r\nif (!mdp->vdev) {\r\ndev_err(dev, "failed to allocate video device\n");\r\nret = -ENOMEM;\r\ngoto err_video_alloc;\r\n}\r\nmdp->vdev->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;\r\nmdp->vdev->fops = &mtk_mdp_m2m_fops;\r\nmdp->vdev->ioctl_ops = &mtk_mdp_m2m_ioctl_ops;\r\nmdp->vdev->release = video_device_release;\r\nmdp->vdev->lock = &mdp->lock;\r\nmdp->vdev->vfl_dir = VFL_DIR_M2M;\r\nmdp->vdev->v4l2_dev = &mdp->v4l2_dev;\r\nsnprintf(mdp->vdev->name, sizeof(mdp->vdev->name), "%s:m2m",\r\nMTK_MDP_MODULE_NAME);\r\nvideo_set_drvdata(mdp->vdev, mdp);\r\nmdp->m2m_dev = v4l2_m2m_init(&mtk_mdp_m2m_ops);\r\nif (IS_ERR(mdp->m2m_dev)) {\r\ndev_err(dev, "failed to initialize v4l2-m2m device\n");\r\nret = PTR_ERR(mdp->m2m_dev);\r\ngoto err_m2m_init;\r\n}\r\nret = video_register_device(mdp->vdev, VFL_TYPE_GRABBER, 2);\r\nif (ret) {\r\ndev_err(dev, "failed to register video device\n");\r\ngoto err_vdev_register;\r\n}\r\nv4l2_info(&mdp->v4l2_dev, "driver registered as /dev/video%d",\r\nmdp->vdev->num);\r\nreturn 0;\r\nerr_vdev_register:\r\nv4l2_m2m_release(mdp->m2m_dev);\r\nerr_m2m_init:\r\nvideo_device_release(mdp->vdev);\r\nerr_video_alloc:\r\nreturn ret;\r\n}\r\nvoid mtk_mdp_unregister_m2m_device(struct mtk_mdp_dev *mdp)\r\n{\r\nvideo_unregister_device(mdp->vdev);\r\nv4l2_m2m_release(mdp->m2m_dev);\r\n}
