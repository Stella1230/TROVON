static void lov_init_set(struct lov_request_set *set)\r\n{\r\nset->set_count = 0;\r\natomic_set(&set->set_completes, 0);\r\natomic_set(&set->set_success, 0);\r\natomic_set(&set->set_finish_checked, 0);\r\nINIT_LIST_HEAD(&set->set_list);\r\natomic_set(&set->set_refcount, 1);\r\ninit_waitqueue_head(&set->set_waitq);\r\n}\r\nvoid lov_finish_set(struct lov_request_set *set)\r\n{\r\nstruct list_head *pos, *n;\r\nLASSERT(set);\r\nlist_for_each_safe(pos, n, &set->set_list) {\r\nstruct lov_request *req = list_entry(pos,\r\nstruct lov_request,\r\nrq_link);\r\nlist_del_init(&req->rq_link);\r\nkfree(req->rq_oi.oi_osfs);\r\nkfree(req);\r\n}\r\nkfree(set);\r\n}\r\nstatic int lov_set_finished(struct lov_request_set *set, int idempotent)\r\n{\r\nint completes = atomic_read(&set->set_completes);\r\nCDEBUG(D_INFO, "check set %d/%d\n", completes, set->set_count);\r\nif (completes == set->set_count) {\r\nif (idempotent)\r\nreturn 1;\r\nif (atomic_inc_return(&set->set_finish_checked) == 1)\r\nreturn 1;\r\n}\r\nreturn 0;\r\n}\r\nstatic void lov_update_set(struct lov_request_set *set,\r\nstruct lov_request *req, int rc)\r\n{\r\nreq->rq_complete = 1;\r\nreq->rq_rc = rc;\r\natomic_inc(&set->set_completes);\r\nif (rc == 0)\r\natomic_inc(&set->set_success);\r\nwake_up(&set->set_waitq);\r\n}\r\nstatic void lov_set_add_req(struct lov_request *req,\r\nstruct lov_request_set *set)\r\n{\r\nlist_add_tail(&req->rq_link, &set->set_list);\r\nset->set_count++;\r\nreq->rq_rqset = set;\r\n}\r\nstatic int lov_check_set(struct lov_obd *lov, int idx)\r\n{\r\nint rc;\r\nstruct lov_tgt_desc *tgt;\r\nmutex_lock(&lov->lov_lock);\r\ntgt = lov->lov_tgts[idx];\r\nrc = !tgt || tgt->ltd_active ||\r\n(tgt->ltd_exp &&\r\nclass_exp2cliimp(tgt->ltd_exp)->imp_connect_tried);\r\nmutex_unlock(&lov->lov_lock);\r\nreturn rc;\r\n}\r\nstatic int lov_check_and_wait_active(struct lov_obd *lov, int ost_idx)\r\n{\r\nwait_queue_head_t waitq;\r\nstruct l_wait_info lwi;\r\nstruct lov_tgt_desc *tgt;\r\nint rc = 0;\r\nmutex_lock(&lov->lov_lock);\r\ntgt = lov->lov_tgts[ost_idx];\r\nif (unlikely(!tgt)) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nif (likely(tgt->ltd_active)) {\r\nrc = 1;\r\ngoto out;\r\n}\r\nif (tgt->ltd_exp && class_exp2cliimp(tgt->ltd_exp)->imp_connect_tried) {\r\nrc = 0;\r\ngoto out;\r\n}\r\nmutex_unlock(&lov->lov_lock);\r\ninit_waitqueue_head(&waitq);\r\nlwi = LWI_TIMEOUT_INTERVAL(cfs_time_seconds(obd_timeout),\r\ncfs_time_seconds(1), NULL, NULL);\r\nrc = l_wait_event(waitq, lov_check_set(lov, ost_idx), &lwi);\r\nif (tgt->ltd_active)\r\nreturn 1;\r\nreturn 0;\r\nout:\r\nmutex_unlock(&lov->lov_lock);\r\nreturn rc;\r\n}\r\nint lov_fini_statfs(struct obd_device *obd, struct obd_statfs *osfs,\r\nint success)\r\n{\r\nif (success) {\r\n__u32 expected_stripes = lov_get_stripecnt(&obd->u.lov,\r\nLOV_MAGIC, 0);\r\nif (osfs->os_files != LOV_U64_MAX)\r\nlov_do_div64(osfs->os_files, expected_stripes);\r\nif (osfs->os_ffree != LOV_U64_MAX)\r\nlov_do_div64(osfs->os_ffree, expected_stripes);\r\nspin_lock(&obd->obd_osfs_lock);\r\nmemcpy(&obd->obd_osfs, osfs, sizeof(*osfs));\r\nobd->obd_osfs_age = cfs_time_current_64();\r\nspin_unlock(&obd->obd_osfs_lock);\r\nreturn 0;\r\n}\r\nreturn -EIO;\r\n}\r\nint lov_fini_statfs_set(struct lov_request_set *set)\r\n{\r\nint rc = 0;\r\nif (!set)\r\nreturn 0;\r\nif (atomic_read(&set->set_completes)) {\r\nrc = lov_fini_statfs(set->set_obd, set->set_oi->oi_osfs,\r\natomic_read(&set->set_success));\r\n}\r\nlov_put_reqset(set);\r\nreturn rc;\r\n}\r\nstatic void lov_update_statfs(struct obd_statfs *osfs,\r\nstruct obd_statfs *lov_sfs,\r\nint success)\r\n{\r\nint shift = 0, quit = 0;\r\n__u64 tmp;\r\nif (success == 0) {\r\nmemcpy(osfs, lov_sfs, sizeof(*lov_sfs));\r\n} else {\r\nif (osfs->os_bsize != lov_sfs->os_bsize) {\r\ntmp = osfs->os_bsize | lov_sfs->os_bsize;\r\nfor (shift = 0; shift <= 64; ++shift) {\r\nif (tmp & 1) {\r\nif (quit)\r\nbreak;\r\nquit = 1;\r\nshift = 0;\r\n}\r\ntmp >>= 1;\r\n}\r\n}\r\nif (osfs->os_bsize < lov_sfs->os_bsize) {\r\nosfs->os_bsize = lov_sfs->os_bsize;\r\nosfs->os_bfree >>= shift;\r\nosfs->os_bavail >>= shift;\r\nosfs->os_blocks >>= shift;\r\n} else if (shift != 0) {\r\nlov_sfs->os_bfree >>= shift;\r\nlov_sfs->os_bavail >>= shift;\r\nlov_sfs->os_blocks >>= shift;\r\n}\r\nosfs->os_bfree += lov_sfs->os_bfree;\r\nosfs->os_bavail += lov_sfs->os_bavail;\r\nosfs->os_blocks += lov_sfs->os_blocks;\r\nLOV_SUM_MAX(osfs->os_files, lov_sfs->os_files);\r\nLOV_SUM_MAX(osfs->os_ffree, lov_sfs->os_ffree);\r\n}\r\n}\r\nstatic int cb_statfs_update(void *cookie, int rc)\r\n{\r\nstruct obd_info *oinfo = cookie;\r\nstruct lov_request *lovreq;\r\nstruct lov_request_set *set;\r\nstruct obd_statfs *osfs, *lov_sfs;\r\nstruct lov_obd *lov;\r\nstruct lov_tgt_desc *tgt;\r\nstruct obd_device *lovobd, *tgtobd;\r\nint success;\r\nlovreq = container_of(oinfo, struct lov_request, rq_oi);\r\nset = lovreq->rq_rqset;\r\nlovobd = set->set_obd;\r\nlov = &lovobd->u.lov;\r\nosfs = set->set_oi->oi_osfs;\r\nlov_sfs = oinfo->oi_osfs;\r\nsuccess = atomic_read(&set->set_success);\r\nlov_update_set(set, lovreq, rc);\r\nif (rc)\r\ngoto out;\r\nobd_getref(lovobd);\r\ntgt = lov->lov_tgts[lovreq->rq_idx];\r\nif (!tgt || !tgt->ltd_active)\r\ngoto out_update;\r\ntgtobd = class_exp2obd(tgt->ltd_exp);\r\nspin_lock(&tgtobd->obd_osfs_lock);\r\nmemcpy(&tgtobd->obd_osfs, lov_sfs, sizeof(*lov_sfs));\r\nif ((oinfo->oi_flags & OBD_STATFS_FROM_CACHE) == 0)\r\ntgtobd->obd_osfs_age = cfs_time_current_64();\r\nspin_unlock(&tgtobd->obd_osfs_lock);\r\nout_update:\r\nlov_update_statfs(osfs, lov_sfs, success);\r\nobd_putref(lovobd);\r\nout:\r\nif (set->set_oi->oi_flags & OBD_STATFS_PTLRPCD &&\r\nlov_set_finished(set, 0)) {\r\nlov_statfs_interpret(NULL, set, set->set_count !=\r\natomic_read(&set->set_success));\r\n}\r\nreturn 0;\r\n}\r\nint lov_prep_statfs_set(struct obd_device *obd, struct obd_info *oinfo,\r\nstruct lov_request_set **reqset)\r\n{\r\nstruct lov_request_set *set;\r\nstruct lov_obd *lov = &obd->u.lov;\r\nint rc = 0, i;\r\nset = kzalloc(sizeof(*set), GFP_NOFS);\r\nif (!set)\r\nreturn -ENOMEM;\r\nlov_init_set(set);\r\nset->set_obd = obd;\r\nset->set_oi = oinfo;\r\nfor (i = 0; i < lov->desc.ld_tgt_count; i++) {\r\nstruct lov_request *req;\r\nif (!lov->lov_tgts[i] ||\r\n(oinfo->oi_flags & OBD_STATFS_NODELAY &&\r\n!lov->lov_tgts[i]->ltd_active)) {\r\nCDEBUG(D_HA, "lov idx %d inactive\n", i);\r\ncontinue;\r\n}\r\nif (!lov->lov_tgts[i]->ltd_exp) {\r\nCDEBUG(D_HA, "lov idx %d administratively disabled\n", i);\r\ncontinue;\r\n}\r\nif (!lov->lov_tgts[i]->ltd_active)\r\nlov_check_and_wait_active(lov, i);\r\nreq = kzalloc(sizeof(*req), GFP_NOFS);\r\nif (!req) {\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nreq->rq_oi.oi_osfs = kzalloc(sizeof(*req->rq_oi.oi_osfs),\r\nGFP_NOFS);\r\nif (!req->rq_oi.oi_osfs) {\r\nkfree(req);\r\nrc = -ENOMEM;\r\ngoto out_set;\r\n}\r\nreq->rq_idx = i;\r\nreq->rq_oi.oi_cb_up = cb_statfs_update;\r\nreq->rq_oi.oi_flags = oinfo->oi_flags;\r\nlov_set_add_req(req, set);\r\n}\r\nif (!set->set_count) {\r\nrc = -EIO;\r\ngoto out_set;\r\n}\r\n*reqset = set;\r\nreturn rc;\r\nout_set:\r\nlov_fini_statfs_set(set);\r\nreturn rc;\r\n}
