static int scif_fdopen(struct inode *inode, struct file *f)\r\n{\r\nstruct scif_endpt *priv = scif_open();\r\nif (!priv)\r\nreturn -ENOMEM;\r\nf->private_data = priv;\r\nreturn 0;\r\n}\r\nstatic int scif_fdclose(struct inode *inode, struct file *f)\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nreturn scif_close(priv);\r\n}\r\nstatic int scif_fdmmap(struct file *f, struct vm_area_struct *vma)\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nreturn scif_mmap(vma, priv);\r\n}\r\nstatic unsigned int scif_fdpoll(struct file *f, poll_table *wait)\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nreturn __scif_pollfd(f, wait, priv);\r\n}\r\nstatic int scif_fdflush(struct file *f, fl_owner_t id)\r\n{\r\nstruct scif_endpt *ep = f->private_data;\r\nspin_lock(&ep->lock);\r\nif (ep->files == id)\r\n__scif_flush(ep);\r\nspin_unlock(&ep->lock);\r\nreturn 0;\r\n}\r\nstatic __always_inline void scif_err_debug(int err, const char *str)\r\n{\r\nif (err < 0 && err != -ENOTCONN)\r\ndev_dbg(scif_info.mdev.this_device, "%s err %d\n", str, err);\r\n}\r\nstatic long scif_fdioctl(struct file *f, unsigned int cmd, unsigned long arg)\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nvoid __user *argp = (void __user *)arg;\r\nint err = 0;\r\nstruct scifioctl_msg request;\r\nbool non_block = false;\r\nnon_block = !!(f->f_flags & O_NONBLOCK);\r\nswitch (cmd) {\r\ncase SCIF_BIND:\r\n{\r\nint pn;\r\nif (copy_from_user(&pn, argp, sizeof(pn)))\r\nreturn -EFAULT;\r\npn = scif_bind(priv, pn);\r\nif (pn < 0)\r\nreturn pn;\r\nif (copy_to_user(argp, &pn, sizeof(pn)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SCIF_LISTEN:\r\nreturn scif_listen(priv, arg);\r\ncase SCIF_CONNECT:\r\n{\r\nstruct scifioctl_connect req;\r\nstruct scif_endpt *ep = (struct scif_endpt *)priv;\r\nif (copy_from_user(&req, argp, sizeof(req)))\r\nreturn -EFAULT;\r\nerr = __scif_connect(priv, &req.peer, non_block);\r\nif (err < 0)\r\nreturn err;\r\nreq.self.node = ep->port.node;\r\nreq.self.port = ep->port.port;\r\nif (copy_to_user(argp, &req, sizeof(req)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\ncase SCIF_ACCEPTREQ:\r\n{\r\nstruct scifioctl_accept request;\r\nscif_epd_t *ep = (scif_epd_t *)&request.endpt;\r\nif (copy_from_user(&request, argp, sizeof(request)))\r\nreturn -EFAULT;\r\nerr = scif_accept(priv, &request.peer, ep, request.flags);\r\nif (err < 0)\r\nreturn err;\r\nif (copy_to_user(argp, &request, sizeof(request))) {\r\nscif_close(*ep);\r\nreturn -EFAULT;\r\n}\r\nmutex_lock(&scif_info.eplock);\r\nlist_add_tail(&((*ep)->miacceptlist), &scif_info.uaccept);\r\nlist_add_tail(&((*ep)->liacceptlist), &priv->li_accept);\r\n(*ep)->listenep = priv;\r\npriv->acceptcnt++;\r\nmutex_unlock(&scif_info.eplock);\r\nreturn 0;\r\n}\r\ncase SCIF_ACCEPTREG:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scif_endpt *newep;\r\nstruct scif_endpt *lisep;\r\nstruct scif_endpt *fep = NULL;\r\nstruct scif_endpt *tmpep;\r\nstruct list_head *pos, *tmpq;\r\nif (copy_from_user(&newep, argp, sizeof(void *)))\r\nreturn -EFAULT;\r\nmutex_lock(&scif_info.eplock);\r\nlist_for_each_safe(pos, tmpq, &scif_info.uaccept) {\r\ntmpep = list_entry(pos,\r\nstruct scif_endpt, miacceptlist);\r\nif (tmpep == newep) {\r\nlist_del(pos);\r\nfep = tmpep;\r\nbreak;\r\n}\r\n}\r\nif (!fep) {\r\nmutex_unlock(&scif_info.eplock);\r\nreturn -ENOENT;\r\n}\r\nlisep = newep->listenep;\r\nlist_for_each_safe(pos, tmpq, &lisep->li_accept) {\r\ntmpep = list_entry(pos,\r\nstruct scif_endpt, liacceptlist);\r\nif (tmpep == newep) {\r\nlist_del(pos);\r\nlisep->acceptcnt--;\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&scif_info.eplock);\r\nscif_anon_inode_fput(priv);\r\nscif_teardown_ep(priv);\r\nscif_add_epd_to_zombie_list(priv, !SCIF_EPLOCK_HELD);\r\nf->private_data = newep;\r\nreturn 0;\r\n}\r\ncase SCIF_SEND:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nif (copy_from_user(&request, argp,\r\nsizeof(struct scifioctl_msg))) {\r\nerr = -EFAULT;\r\ngoto send_err;\r\n}\r\nerr = scif_user_send(priv, (void __user *)request.msg,\r\nrequest.len, request.flags);\r\nif (err < 0)\r\ngoto send_err;\r\nif (copy_to_user(&\r\n((struct scifioctl_msg __user *)argp)->out_len,\r\n&err, sizeof(err))) {\r\nerr = -EFAULT;\r\ngoto send_err;\r\n}\r\nerr = 0;\r\nsend_err:\r\nscif_err_debug(err, "scif_send");\r\nreturn err;\r\n}\r\ncase SCIF_RECV:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nif (copy_from_user(&request, argp,\r\nsizeof(struct scifioctl_msg))) {\r\nerr = -EFAULT;\r\ngoto recv_err;\r\n}\r\nerr = scif_user_recv(priv, (void __user *)request.msg,\r\nrequest.len, request.flags);\r\nif (err < 0)\r\ngoto recv_err;\r\nif (copy_to_user(&\r\n((struct scifioctl_msg __user *)argp)->out_len,\r\n&err, sizeof(err))) {\r\nerr = -EFAULT;\r\ngoto recv_err;\r\n}\r\nerr = 0;\r\nrecv_err:\r\nscif_err_debug(err, "scif_recv");\r\nreturn err;\r\n}\r\ncase SCIF_GET_NODEIDS:\r\n{\r\nstruct scifioctl_node_ids node_ids;\r\nint entries;\r\nu16 *nodes;\r\nvoid __user *unodes, *uself;\r\nu16 self;\r\nif (copy_from_user(&node_ids, argp, sizeof(node_ids))) {\r\nerr = -EFAULT;\r\ngoto getnodes_err2;\r\n}\r\nentries = min_t(int, scif_info.maxid, node_ids.len);\r\nnodes = kmalloc_array(entries, sizeof(u16), GFP_KERNEL);\r\nif (entries && !nodes) {\r\nerr = -ENOMEM;\r\ngoto getnodes_err2;\r\n}\r\nnode_ids.len = scif_get_node_ids(nodes, entries, &self);\r\nunodes = (void __user *)node_ids.nodes;\r\nif (copy_to_user(unodes, nodes, sizeof(u16) * entries)) {\r\nerr = -EFAULT;\r\ngoto getnodes_err1;\r\n}\r\nuself = (void __user *)node_ids.self;\r\nif (copy_to_user(uself, &self, sizeof(u16))) {\r\nerr = -EFAULT;\r\ngoto getnodes_err1;\r\n}\r\nif (copy_to_user(argp, &node_ids, sizeof(node_ids))) {\r\nerr = -EFAULT;\r\ngoto getnodes_err1;\r\n}\r\ngetnodes_err1:\r\nkfree(nodes);\r\ngetnodes_err2:\r\nreturn err;\r\n}\r\ncase SCIF_REG:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_reg reg;\r\noff_t ret;\r\nif (copy_from_user(&reg, argp, sizeof(reg))) {\r\nerr = -EFAULT;\r\ngoto reg_err;\r\n}\r\nif (reg.flags & SCIF_MAP_KERNEL) {\r\nerr = -EINVAL;\r\ngoto reg_err;\r\n}\r\nret = scif_register(priv, (void *)reg.addr, reg.len,\r\nreg.offset, reg.prot, reg.flags);\r\nif (ret < 0) {\r\nerr = (int)ret;\r\ngoto reg_err;\r\n}\r\nif (copy_to_user(&((struct scifioctl_reg __user *)argp)\r\n->out_offset, &ret, sizeof(reg.out_offset))) {\r\nerr = -EFAULT;\r\ngoto reg_err;\r\n}\r\nerr = 0;\r\nreg_err:\r\nscif_err_debug(err, "scif_register");\r\nreturn err;\r\n}\r\ncase SCIF_UNREG:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_unreg unreg;\r\nif (copy_from_user(&unreg, argp, sizeof(unreg))) {\r\nerr = -EFAULT;\r\ngoto unreg_err;\r\n}\r\nerr = scif_unregister(priv, unreg.offset, unreg.len);\r\nunreg_err:\r\nscif_err_debug(err, "scif_unregister");\r\nreturn err;\r\n}\r\ncase SCIF_READFROM:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_copy copy;\r\nif (copy_from_user(&copy, argp, sizeof(copy))) {\r\nerr = -EFAULT;\r\ngoto readfrom_err;\r\n}\r\nerr = scif_readfrom(priv, copy.loffset, copy.len, copy.roffset,\r\ncopy.flags);\r\nreadfrom_err:\r\nscif_err_debug(err, "scif_readfrom");\r\nreturn err;\r\n}\r\ncase SCIF_WRITETO:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_copy copy;\r\nif (copy_from_user(&copy, argp, sizeof(copy))) {\r\nerr = -EFAULT;\r\ngoto writeto_err;\r\n}\r\nerr = scif_writeto(priv, copy.loffset, copy.len, copy.roffset,\r\ncopy.flags);\r\nwriteto_err:\r\nscif_err_debug(err, "scif_writeto");\r\nreturn err;\r\n}\r\ncase SCIF_VREADFROM:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_copy copy;\r\nif (copy_from_user(&copy, argp, sizeof(copy))) {\r\nerr = -EFAULT;\r\ngoto vreadfrom_err;\r\n}\r\nerr = scif_vreadfrom(priv, (void __force *)copy.addr, copy.len,\r\ncopy.roffset, copy.flags);\r\nvreadfrom_err:\r\nscif_err_debug(err, "scif_vreadfrom");\r\nreturn err;\r\n}\r\ncase SCIF_VWRITETO:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_copy copy;\r\nif (copy_from_user(&copy, argp, sizeof(copy))) {\r\nerr = -EFAULT;\r\ngoto vwriteto_err;\r\n}\r\nerr = scif_vwriteto(priv, (void __force *)copy.addr, copy.len,\r\ncopy.roffset, copy.flags);\r\nvwriteto_err:\r\nscif_err_debug(err, "scif_vwriteto");\r\nreturn err;\r\n}\r\ncase SCIF_FENCE_MARK:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_fence_mark mark;\r\nint tmp_mark = 0;\r\nif (copy_from_user(&mark, argp, sizeof(mark))) {\r\nerr = -EFAULT;\r\ngoto fence_mark_err;\r\n}\r\nerr = scif_fence_mark(priv, mark.flags, &tmp_mark);\r\nif (err)\r\ngoto fence_mark_err;\r\nif (copy_to_user((void __user *)mark.mark, &tmp_mark,\r\nsizeof(tmp_mark))) {\r\nerr = -EFAULT;\r\ngoto fence_mark_err;\r\n}\r\nfence_mark_err:\r\nscif_err_debug(err, "scif_fence_mark");\r\nreturn err;\r\n}\r\ncase SCIF_FENCE_WAIT:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nerr = scif_fence_wait(priv, arg);\r\nscif_err_debug(err, "scif_fence_wait");\r\nreturn err;\r\n}\r\ncase SCIF_FENCE_SIGNAL:\r\n{\r\nstruct scif_endpt *priv = f->private_data;\r\nstruct scifioctl_fence_signal signal;\r\nif (copy_from_user(&signal, argp, sizeof(signal))) {\r\nerr = -EFAULT;\r\ngoto fence_signal_err;\r\n}\r\nerr = scif_fence_signal(priv, signal.loff, signal.lval,\r\nsignal.roff, signal.rval, signal.flags);\r\nfence_signal_err:\r\nscif_err_debug(err, "scif_fence_signal");\r\nreturn err;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}
