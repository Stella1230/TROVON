static int qlcnic_sriov_pf_set_vport_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *npar_info,\r\nu16 vport_id)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO))\r\nreturn -ENOMEM;\r\ncmd.req.arg[1] = (vport_id << 16) | 0x1;\r\ncmd.req.arg[2] = npar_info->bit_offsets;\r\ncmd.req.arg[2] |= npar_info->min_tx_bw << 16;\r\ncmd.req.arg[3] = npar_info->max_tx_bw | (npar_info->max_tx_ques << 16);\r\ncmd.req.arg[4] = npar_info->max_tx_mac_filters;\r\ncmd.req.arg[4] |= npar_info->max_rx_mcast_mac_filters << 16;\r\ncmd.req.arg[5] = npar_info->max_rx_ucast_mac_filters |\r\n(npar_info->max_rx_ip_addr << 16);\r\ncmd.req.arg[6] = npar_info->max_rx_lro_flow |\r\n(npar_info->max_rx_status_rings << 16);\r\ncmd.req.arg[7] = npar_info->max_rx_buf_rings |\r\n(npar_info->max_rx_ques << 16);\r\ncmd.req.arg[8] = npar_info->max_tx_vlan_keys;\r\ncmd.req.arg[8] |= npar_info->max_local_ipv6_addrs << 16;\r\ncmd.req.arg[9] = npar_info->max_remote_ipv6_addrs;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to set vport info, err=%d\n", err);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cal_res_limit(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *info, u16 func)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_resources *res = &sriov->ff_max;\r\nu16 num_macs = sriov->num_allowed_vlans + 1;\r\nint ret = -EIO, vpid, id;\r\nstruct qlcnic_vport *vp;\r\nu32 num_vfs, max, temp;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter, func);\r\nif (vpid < 0)\r\nreturn -EINVAL;\r\nnum_vfs = sriov->num_vfs;\r\nmax = num_vfs + 1;\r\ninfo->bit_offsets = 0xffff;\r\ninfo->max_tx_ques = res->num_tx_queues / max;\r\nif (qlcnic_83xx_pf_check(adapter))\r\nnum_macs = QLCNIC_83XX_SRIOV_VF_MAX_MAC;\r\ninfo->max_rx_mcast_mac_filters = res->num_rx_mcast_mac_filters;\r\nif (adapter->ahw->pci_func == func) {\r\ninfo->min_tx_bw = 0;\r\ninfo->max_tx_bw = MAX_BW;\r\ntemp = res->num_rx_ucast_mac_filters - num_macs * num_vfs;\r\ninfo->max_rx_ucast_mac_filters = temp;\r\ntemp = res->num_tx_mac_filters - num_macs * num_vfs;\r\ninfo->max_tx_mac_filters = temp;\r\ntemp = num_macs * num_vfs * QLCNIC_SRIOV_VF_MAX_MAC;\r\ntemp = res->num_rx_mcast_mac_filters - temp;\r\ninfo->max_rx_mcast_mac_filters = temp;\r\ninfo->max_tx_ques = res->num_tx_queues - sriov->num_vfs;\r\n} else {\r\nid = qlcnic_sriov_func_to_index(adapter, func);\r\nif (id < 0)\r\nreturn id;\r\nvp = sriov->vf_info[id].vp;\r\ninfo->min_tx_bw = vp->min_tx_bw;\r\ninfo->max_tx_bw = vp->max_tx_bw;\r\ninfo->max_rx_ucast_mac_filters = num_macs;\r\ninfo->max_tx_mac_filters = num_macs;\r\ntemp = num_macs * QLCNIC_SRIOV_VF_MAX_MAC;\r\ninfo->max_rx_mcast_mac_filters = temp;\r\ninfo->max_tx_ques = QLCNIC_SINGLE_RING;\r\n}\r\ninfo->max_rx_ip_addr = res->num_destip / max;\r\ninfo->max_rx_status_rings = res->num_rx_status_rings / max;\r\ninfo->max_rx_buf_rings = res->num_rx_buf_rings / max;\r\ninfo->max_rx_ques = res->num_rx_queues / max;\r\ninfo->max_rx_lro_flow = res->num_lro_flows_supported / max;\r\ninfo->max_tx_vlan_keys = res->num_txvlan_keys;\r\ninfo->max_local_ipv6_addrs = res->max_local_ipv6_addrs;\r\ninfo->max_remote_ipv6_addrs = res->max_remote_ipv6_addrs;\r\nret = qlcnic_sriov_pf_set_vport_info(adapter, info, vpid);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}\r\nstatic void qlcnic_sriov_pf_set_ff_max_res(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *info)\r\n{\r\nstruct qlcnic_resources *ff_max = &adapter->ahw->sriov->ff_max;\r\nff_max->num_tx_mac_filters = info->max_tx_mac_filters;\r\nff_max->num_rx_ucast_mac_filters = info->max_rx_ucast_mac_filters;\r\nff_max->num_rx_mcast_mac_filters = info->max_rx_mcast_mac_filters;\r\nff_max->num_txvlan_keys = info->max_tx_vlan_keys;\r\nff_max->num_rx_queues = info->max_rx_ques;\r\nff_max->num_tx_queues = info->max_tx_ques;\r\nff_max->num_lro_flows_supported = info->max_rx_lro_flow;\r\nff_max->num_destip = info->max_rx_ip_addr;\r\nff_max->num_rx_buf_rings = info->max_rx_buf_rings;\r\nff_max->num_rx_status_rings = info->max_rx_status_rings;\r\nff_max->max_remote_ipv6_addrs = info->max_remote_ipv6_addrs;\r\nff_max->max_local_ipv6_addrs = info->max_local_ipv6_addrs;\r\n}\r\nstatic void qlcnic_sriov_set_vf_max_vlan(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *npar_info)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nint temp, total_fn;\r\ntemp = npar_info->max_rx_mcast_mac_filters;\r\ntotal_fn = sriov->num_vfs + 1;\r\ntemp = temp / (QLCNIC_SRIOV_VF_MAX_MAC * total_fn);\r\nsriov->num_allowed_vlans = temp - 1;\r\nif (qlcnic_83xx_pf_check(adapter))\r\nsriov->num_allowed_vlans = 1;\r\nnetdev_info(adapter->netdev, "Max Guest VLANs supported per VF = %d\n",\r\nsriov->num_allowed_vlans);\r\n}\r\nstatic int qlcnic_sriov_get_pf_info(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_info *npar_info)\r\n{\r\nint err;\r\nstruct qlcnic_cmd_args cmd;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_GET_NIC_INFO))\r\nreturn -ENOMEM;\r\ncmd.req.arg[1] = 0x2;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to get PF info, err=%d\n", err);\r\ngoto out;\r\n}\r\nnpar_info->total_pf = cmd.rsp.arg[2] & 0xff;\r\nnpar_info->total_rss_engines = (cmd.rsp.arg[2] >> 8) & 0xff;\r\nnpar_info->max_vports = MSW(cmd.rsp.arg[2]);\r\nnpar_info->max_tx_ques = LSW(cmd.rsp.arg[3]);\r\nnpar_info->max_tx_mac_filters = MSW(cmd.rsp.arg[3]);\r\nnpar_info->max_rx_mcast_mac_filters = LSW(cmd.rsp.arg[4]);\r\nnpar_info->max_rx_ucast_mac_filters = MSW(cmd.rsp.arg[4]);\r\nnpar_info->max_rx_ip_addr = LSW(cmd.rsp.arg[5]);\r\nnpar_info->max_rx_lro_flow = MSW(cmd.rsp.arg[5]);\r\nnpar_info->max_rx_status_rings = LSW(cmd.rsp.arg[6]);\r\nnpar_info->max_rx_buf_rings = MSW(cmd.rsp.arg[6]);\r\nnpar_info->max_rx_ques = LSW(cmd.rsp.arg[7]);\r\nnpar_info->max_tx_vlan_keys = MSW(cmd.rsp.arg[7]);\r\nnpar_info->max_local_ipv6_addrs = LSW(cmd.rsp.arg[8]);\r\nnpar_info->max_remote_ipv6_addrs = MSW(cmd.rsp.arg[8]);\r\nqlcnic_sriov_set_vf_max_vlan(adapter, npar_info);\r\nqlcnic_sriov_pf_set_ff_max_res(adapter, npar_info);\r\ndev_info(&adapter->pdev->dev,\r\n"\n\ttotal_pf: %d,\n"\r\n"\n\ttotal_rss_engines: %d max_vports: %d max_tx_ques %d,\n"\r\n"\tmax_tx_mac_filters: %d max_rx_mcast_mac_filters: %d,\n"\r\n"\tmax_rx_ucast_mac_filters: 0x%x, max_rx_ip_addr: %d,\n"\r\n"\tmax_rx_lro_flow: %d max_rx_status_rings: %d,\n"\r\n"\tmax_rx_buf_rings: %d, max_rx_ques: %d, max_tx_vlan_keys %d\n"\r\n"\tmax_local_ipv6_addrs: %d, max_remote_ipv6_addrs: %d\n",\r\nnpar_info->total_pf, npar_info->total_rss_engines,\r\nnpar_info->max_vports, npar_info->max_tx_ques,\r\nnpar_info->max_tx_mac_filters,\r\nnpar_info->max_rx_mcast_mac_filters,\r\nnpar_info->max_rx_ucast_mac_filters, npar_info->max_rx_ip_addr,\r\nnpar_info->max_rx_lro_flow, npar_info->max_rx_status_rings,\r\nnpar_info->max_rx_buf_rings, npar_info->max_rx_ques,\r\nnpar_info->max_tx_vlan_keys, npar_info->max_local_ipv6_addrs,\r\nnpar_info->max_remote_ipv6_addrs);\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic void qlcnic_sriov_pf_reset_vport_handle(struct qlcnic_adapter *adapter,\r\nu8 func)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vport *vp;\r\nint index;\r\nif (adapter->ahw->pci_func == func) {\r\nsriov->vp_handle = 0;\r\n} else {\r\nindex = qlcnic_sriov_func_to_index(adapter, func);\r\nif (index < 0)\r\nreturn;\r\nvp = sriov->vf_info[index].vp;\r\nvp->handle = 0;\r\n}\r\n}\r\nstatic void qlcnic_sriov_pf_set_vport_handle(struct qlcnic_adapter *adapter,\r\nu16 vport_handle, u8 func)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vport *vp;\r\nint index;\r\nif (adapter->ahw->pci_func == func) {\r\nsriov->vp_handle = vport_handle;\r\n} else {\r\nindex = qlcnic_sriov_func_to_index(adapter, func);\r\nif (index < 0)\r\nreturn;\r\nvp = sriov->vf_info[index].vp;\r\nvp->handle = vport_handle;\r\n}\r\n}\r\nstatic int qlcnic_sriov_pf_get_vport_handle(struct qlcnic_adapter *adapter,\r\nu8 func)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vf_info *vf_info;\r\nint index;\r\nif (adapter->ahw->pci_func == func) {\r\nreturn sriov->vp_handle;\r\n} else {\r\nindex = qlcnic_sriov_func_to_index(adapter, func);\r\nif (index >= 0) {\r\nvf_info = &sriov->vf_info[index];\r\nreturn vf_info->vp->handle;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int qlcnic_sriov_pf_config_vport(struct qlcnic_adapter *adapter,\r\nu8 flag, u16 func)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint ret;\r\nint vpid;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_CONFIG_VPORT))\r\nreturn -ENOMEM;\r\nif (flag) {\r\ncmd.req.arg[3] = func << 8;\r\n} else {\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter, func);\r\nif (vpid < 0) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\ncmd.req.arg[3] = ((vpid & 0xffff) << 8) | 1;\r\n}\r\nret = qlcnic_issue_cmd(adapter, &cmd);\r\nif (ret) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed %s vport, err %d for func 0x%x\n",\r\n(flag ? "enable" : "disable"), ret, func);\r\ngoto out;\r\n}\r\nif (flag) {\r\nvpid = cmd.rsp.arg[2] & 0xffff;\r\nqlcnic_sriov_pf_set_vport_handle(adapter, vpid, func);\r\n} else {\r\nqlcnic_sriov_pf_reset_vport_handle(adapter, func);\r\n}\r\nout:\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn ret;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_vlan_filtering(struct qlcnic_adapter *adapter,\r\nu8 enable)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = 0x4;\r\nif (enable) {\r\nadapter->flags |= QLCNIC_VLAN_FILTERING;\r\ncmd.req.arg[1] |= BIT_16;\r\nif (qlcnic_84xx_check(adapter))\r\ncmd.req.arg[1] |= QLC_SRIOV_ALLOW_VLAN0;\r\n} else {\r\nadapter->flags &= ~QLCNIC_VLAN_FILTERING;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to configure VLAN filtering, err=%d\n", err);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_flood(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = QLC_FLOOD_MODE | QLC_VF_FLOOD_BIT;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to configure VF Flood bit on PF, err=%d\n",\r\nerr);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_eswitch(struct qlcnic_adapter *adapter,\r\nu8 func, u8 enable)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint err = -EIO;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_TOGGLE_ESWITCH))\r\nreturn -ENOMEM;\r\ncmd.req.arg[0] |= (3 << 29);\r\ncmd.req.arg[1] = ((func & 0xf) << 2) | BIT_6 | BIT_1;\r\nif (enable)\r\ncmd.req.arg[1] |= BIT_0;\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err != QLCNIC_RCODE_SUCCESS) {\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to enable sriov eswitch%d\n", err);\r\nerr = -EIO;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic void qlcnic_sriov_pf_del_flr_queue(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_back_channel *bc = &sriov->bc;\r\nint i;\r\nfor (i = 0; i < sriov->num_vfs; i++)\r\ncancel_work_sync(&sriov->vf_info[i].flr_work);\r\ndestroy_workqueue(bc->bc_flr_wq);\r\n}\r\nstatic int qlcnic_sriov_pf_create_flr_queue(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_back_channel *bc = &adapter->ahw->sriov->bc;\r\nstruct workqueue_struct *wq;\r\nwq = create_singlethread_workqueue("qlcnic-flr");\r\nif (wq == NULL) {\r\ndev_err(&adapter->pdev->dev, "Cannot create FLR workqueue\n");\r\nreturn -ENOMEM;\r\n}\r\nbc->bc_flr_wq = wq;\r\nreturn 0;\r\n}\r\nvoid qlcnic_sriov_pf_cleanup(struct qlcnic_adapter *adapter)\r\n{\r\nu8 func = adapter->ahw->pci_func;\r\nif (!qlcnic_sriov_enable_check(adapter))\r\nreturn;\r\nqlcnic_sriov_pf_del_flr_queue(adapter);\r\nqlcnic_sriov_cfg_bc_intr(adapter, 0);\r\nqlcnic_sriov_pf_config_vport(adapter, 0, func);\r\nqlcnic_sriov_pf_cfg_eswitch(adapter, func, 0);\r\nqlcnic_sriov_pf_cfg_vlan_filtering(adapter, 0);\r\n__qlcnic_sriov_cleanup(adapter);\r\nadapter->ahw->op_mode = QLCNIC_MGMT_FUNC;\r\nclear_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\r\n}\r\nvoid qlcnic_sriov_pf_disable(struct qlcnic_adapter *adapter)\r\n{\r\nif (!qlcnic_sriov_pf_check(adapter))\r\nreturn;\r\nif (!qlcnic_sriov_enable_check(adapter))\r\nreturn;\r\npci_disable_sriov(adapter->pdev);\r\nnetdev_info(adapter->netdev,\r\n"SR-IOV is disabled successfully on port %d\n",\r\nadapter->portnum);\r\n}\r\nstatic int qlcnic_pci_sriov_disable(struct qlcnic_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nif (pci_vfs_assigned(adapter->pdev)) {\r\nnetdev_err(adapter->netdev,\r\n"SR-IOV VFs belonging to port %d are assigned to VMs. SR-IOV can not be disabled on this port\n",\r\nadapter->portnum);\r\nnetdev_info(adapter->netdev,\r\n"Please detach SR-IOV VFs belonging to port %d from VMs, and then try to disable SR-IOV on this port\n",\r\nadapter->portnum);\r\nreturn -EPERM;\r\n}\r\nqlcnic_sriov_pf_disable(adapter);\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nqlcnic_sriov_free_vlans(adapter);\r\nqlcnic_sriov_pf_cleanup(adapter);\r\nif (qlcnic_83xx_configure_opmode(adapter)) {\r\nrtnl_unlock();\r\nreturn -EIO;\r\n}\r\nif (netif_running(netdev))\r\n__qlcnic_up(adapter, netdev);\r\nrtnl_unlock();\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_init(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_info nic_info, pf_info, vp_info;\r\nint err;\r\nu8 func = ahw->pci_func;\r\nif (!qlcnic_sriov_enable_check(adapter))\r\nreturn 0;\r\nerr = qlcnic_sriov_pf_cfg_vlan_filtering(adapter, 1);\r\nif (err)\r\nreturn err;\r\nif (qlcnic_84xx_check(adapter)) {\r\nerr = qlcnic_sriov_pf_cfg_flood(adapter);\r\nif (err)\r\ngoto disable_vlan_filtering;\r\n}\r\nerr = qlcnic_sriov_pf_cfg_eswitch(adapter, func, 1);\r\nif (err)\r\ngoto disable_vlan_filtering;\r\nerr = qlcnic_sriov_pf_config_vport(adapter, 1, func);\r\nif (err)\r\ngoto disable_eswitch;\r\nerr = qlcnic_sriov_get_pf_info(adapter, &pf_info);\r\nif (err)\r\ngoto delete_vport;\r\nerr = qlcnic_get_nic_info(adapter, &nic_info, func);\r\nif (err)\r\ngoto delete_vport;\r\nerr = qlcnic_sriov_pf_cal_res_limit(adapter, &vp_info, func);\r\nif (err)\r\ngoto delete_vport;\r\nerr = qlcnic_sriov_cfg_bc_intr(adapter, 1);\r\nif (err)\r\ngoto delete_vport;\r\nahw->physical_port = (u8) nic_info.phys_port;\r\nahw->switch_mode = nic_info.switch_mode;\r\nahw->max_mtu = nic_info.max_mtu;\r\nahw->capabilities = nic_info.capabilities;\r\nahw->nic_mode = QLC_83XX_SRIOV_MODE;\r\nreturn err;\r\ndelete_vport:\r\nqlcnic_sriov_pf_config_vport(adapter, 0, func);\r\ndisable_eswitch:\r\nqlcnic_sriov_pf_cfg_eswitch(adapter, func, 0);\r\ndisable_vlan_filtering:\r\nqlcnic_sriov_pf_cfg_vlan_filtering(adapter, 0);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_enable(struct qlcnic_adapter *adapter, int num_vfs)\r\n{\r\nint err;\r\nif (!qlcnic_sriov_enable_check(adapter))\r\nreturn 0;\r\nerr = pci_enable_sriov(adapter->pdev, num_vfs);\r\nif (err)\r\nqlcnic_sriov_pf_cleanup(adapter);\r\nreturn err;\r\n}\r\nstatic int __qlcnic_pci_sriov_enable(struct qlcnic_adapter *adapter,\r\nint num_vfs)\r\n{\r\nint err = 0;\r\nset_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\r\nadapter->ahw->op_mode = QLCNIC_SRIOV_PF_FUNC;\r\nerr = qlcnic_sriov_init(adapter, num_vfs);\r\nif (err)\r\ngoto clear_op_mode;\r\nerr = qlcnic_sriov_pf_create_flr_queue(adapter);\r\nif (err)\r\ngoto sriov_cleanup;\r\nerr = qlcnic_sriov_pf_init(adapter);\r\nif (err)\r\ngoto del_flr_queue;\r\nqlcnic_sriov_alloc_vlans(adapter);\r\nreturn err;\r\ndel_flr_queue:\r\nqlcnic_sriov_pf_del_flr_queue(adapter);\r\nsriov_cleanup:\r\n__qlcnic_sriov_cleanup(adapter);\r\nclear_op_mode:\r\nclear_bit(__QLCNIC_SRIOV_ENABLE, &adapter->state);\r\nadapter->ahw->op_mode = QLCNIC_MGMT_FUNC;\r\nreturn err;\r\n}\r\nstatic int qlcnic_pci_sriov_enable(struct qlcnic_adapter *adapter, int num_vfs)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err;\r\nif (!(adapter->flags & QLCNIC_MSIX_ENABLED)) {\r\nnetdev_err(netdev,\r\n"SR-IOV cannot be enabled, when legacy interrupts are enabled\n");\r\nreturn -EIO;\r\n}\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nerr = __qlcnic_pci_sriov_enable(adapter, num_vfs);\r\nif (err)\r\ngoto error;\r\nif (netif_running(netdev))\r\n__qlcnic_up(adapter, netdev);\r\nrtnl_unlock();\r\nerr = qlcnic_sriov_pf_enable(adapter, num_vfs);\r\nif (!err) {\r\nnetdev_info(netdev,\r\n"SR-IOV is enabled successfully on port %d\n",\r\nadapter->portnum);\r\nreturn num_vfs;\r\n}\r\nrtnl_lock();\r\nif (netif_running(netdev))\r\n__qlcnic_down(adapter, netdev);\r\nerror:\r\nif (!qlcnic_83xx_configure_opmode(adapter)) {\r\nif (netif_running(netdev))\r\n__qlcnic_up(adapter, netdev);\r\n}\r\nrtnl_unlock();\r\nnetdev_info(netdev, "Failed to enable SR-IOV on port %d\n",\r\nadapter->portnum);\r\nreturn err;\r\n}\r\nint qlcnic_pci_sriov_configure(struct pci_dev *dev, int num_vfs)\r\n{\r\nstruct qlcnic_adapter *adapter = pci_get_drvdata(dev);\r\nint err;\r\nif (test_and_set_bit(__QLCNIC_RESETTING, &adapter->state))\r\nreturn -EBUSY;\r\nif (num_vfs == 0)\r\nerr = qlcnic_pci_sriov_disable(adapter);\r\nelse\r\nerr = qlcnic_pci_sriov_enable(adapter, num_vfs);\r\nclear_bit(__QLCNIC_RESETTING, &adapter->state);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_set_vf_acl(struct qlcnic_adapter *adapter, u8 func)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nstruct qlcnic_vport *vp;\r\nint err, id;\r\nu8 *mac;\r\nid = qlcnic_sriov_func_to_index(adapter, func);\r\nif (id < 0)\r\nreturn id;\r\nvp = adapter->ahw->sriov->vf_info[id].vp;\r\nerr = qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_SET_NIC_INFO);\r\nif (err)\r\nreturn err;\r\ncmd.req.arg[1] = 0x3 | func << 16;\r\nif (vp->spoofchk == true) {\r\nmac = vp->mac;\r\ncmd.req.arg[2] |= BIT_1 | BIT_3 | BIT_8;\r\ncmd.req.arg[4] = mac[5] | mac[4] << 8 | mac[3] << 16 |\r\nmac[2] << 24;\r\ncmd.req.arg[5] = mac[1] | mac[0] << 8;\r\n}\r\nif (vp->vlan_mode == QLC_PVID_MODE) {\r\ncmd.req.arg[2] |= BIT_6;\r\ncmd.req.arg[3] |= vp->pvid << 8;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, &cmd);\r\nif (err)\r\ndev_err(&adapter->pdev->dev, "Failed to set ACL, err=%d\n",\r\nerr);\r\nqlcnic_free_mbx_args(&cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_set_vf_vport_info(struct qlcnic_adapter *adapter,\r\nu16 func)\r\n{\r\nstruct qlcnic_info defvp_info;\r\nint err;\r\nerr = qlcnic_sriov_pf_cal_res_limit(adapter, &defvp_info, func);\r\nif (err)\r\nreturn -EIO;\r\nerr = qlcnic_sriov_set_vf_acl(adapter, func);\r\nif (err)\r\nreturn err;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_channel_cfg_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_vport *vp = vf->vp;\r\nstruct qlcnic_adapter *adapter;\r\nstruct qlcnic_sriov *sriov;\r\nu16 func = vf->pci_func;\r\nsize_t size;\r\nint err;\r\nadapter = vf->adapter;\r\nsriov = adapter->ahw->sriov;\r\nif (trans->req_hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT) {\r\nerr = qlcnic_sriov_pf_config_vport(adapter, 1, func);\r\nif (!err) {\r\nerr = qlcnic_sriov_set_vf_vport_info(adapter, func);\r\nif (err)\r\nqlcnic_sriov_pf_config_vport(adapter, 0, func);\r\n}\r\n} else {\r\nif (vp->vlan_mode == QLC_GUEST_VLAN_MODE) {\r\nsize = sizeof(*vf->sriov_vlans);\r\nsize = size * sriov->num_allowed_vlans;\r\nmemset(vf->sriov_vlans, 0, size);\r\n}\r\nerr = qlcnic_sriov_pf_config_vport(adapter, 0, func);\r\n}\r\nif (err)\r\ngoto err_out;\r\ncmd->rsp.arg[0] |= (1 << 25);\r\nif (trans->req_hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT)\r\nset_bit(QLC_BC_VF_STATE, &vf->state);\r\nelse\r\nclear_bit(QLC_BC_VF_STATE, &vf->state);\r\nreturn err;\r\nerr_out:\r\ncmd->rsp.arg[0] |= (2 << 25);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_cfg_vf_def_mac(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nu16 vlan, u8 op)\r\n{\r\nstruct qlcnic_cmd_args *cmd;\r\nstruct qlcnic_macvlan_mbx mv;\r\nstruct qlcnic_vport *vp;\r\nu8 *addr;\r\nint err;\r\nu32 *buf;\r\nint vpid;\r\nvp = vf->vp;\r\ncmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);\r\nif (!cmd)\r\nreturn -ENOMEM;\r\nerr = qlcnic_alloc_mbx_args(cmd, adapter, QLCNIC_CMD_CONFIG_MAC_VLAN);\r\nif (err)\r\ngoto free_cmd;\r\ncmd->type = QLC_83XX_MBX_CMD_NO_WAIT;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter, vf->pci_func);\r\nif (vpid < 0) {\r\nerr = -EINVAL;\r\ngoto free_args;\r\n}\r\nif (vlan)\r\nop = ((op == QLCNIC_MAC_ADD || op == QLCNIC_MAC_VLAN_ADD) ?\r\nQLCNIC_MAC_VLAN_ADD : QLCNIC_MAC_VLAN_DEL);\r\ncmd->req.arg[1] = op | (1 << 8) | (3 << 6);\r\ncmd->req.arg[1] |= ((vpid & 0xffff) << 16) | BIT_31;\r\naddr = vp->mac;\r\nmv.vlan = vlan;\r\nmv.mac_addr0 = addr[0];\r\nmv.mac_addr1 = addr[1];\r\nmv.mac_addr2 = addr[2];\r\nmv.mac_addr3 = addr[3];\r\nmv.mac_addr4 = addr[4];\r\nmv.mac_addr5 = addr[5];\r\nbuf = &cmd->req.arg[2];\r\nmemcpy(buf, &mv, sizeof(struct qlcnic_macvlan_mbx));\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err)\r\nreturn err;\r\nfree_args:\r\nqlcnic_free_mbx_args(cmd);\r\nfree_cmd:\r\nkfree(cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_create_rx_ctx(struct qlcnic_cmd_args *cmd)\r\n{\r\nif ((cmd->req.arg[0] >> 29) != 0x3)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic void qlcnic_83xx_cfg_default_mac_vlan(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nint opcode)\r\n{\r\nstruct qlcnic_sriov *sriov;\r\nu16 vlan;\r\nint i;\r\nsriov = adapter->ahw->sriov;\r\nspin_lock_bh(&vf->vlan_list_lock);\r\nif (vf->num_vlan) {\r\nfor (i = 0; i < sriov->num_allowed_vlans; i++) {\r\nvlan = vf->sriov_vlans[i];\r\nif (vlan)\r\nqlcnic_sriov_cfg_vf_def_mac(adapter, vf, vlan,\r\nopcode);\r\n}\r\n}\r\nspin_unlock_bh(&vf->vlan_list_lock);\r\nif (vf->vp->vlan_mode != QLC_PVID_MODE) {\r\nif (qlcnic_83xx_pf_check(adapter) &&\r\nqlcnic_sriov_check_any_vlan(vf))\r\nreturn;\r\nqlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0, opcode);\r\n}\r\n}\r\nstatic int qlcnic_sriov_pf_create_rx_ctx_cmd(struct qlcnic_bc_trans *tran,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = tran->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nstruct qlcnic_rcv_mbx_out *mbx_out;\r\nint err;\r\nerr = qlcnic_sriov_validate_create_rx_ctx(cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\ncmd->req.arg[6] = vf->vp->handle;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err) {\r\nmbx_out = (struct qlcnic_rcv_mbx_out *)&cmd->rsp.arg[1];\r\nvf->rx_ctx_id = mbx_out->ctx_id;\r\nqlcnic_83xx_cfg_default_mac_vlan(adapter, vf, QLCNIC_MAC_ADD);\r\n} else {\r\nvf->rx_ctx_id = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_mac_address_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nu8 type, *mac;\r\ntype = cmd->req.arg[1];\r\nswitch (type) {\r\ncase QLCNIC_SET_STATION_MAC:\r\ncase QLCNIC_SET_FAC_DEF_MAC:\r\ncmd->rsp.arg[0] = (2 << 25);\r\nbreak;\r\ncase QLCNIC_GET_CURRENT_MAC:\r\ncmd->rsp.arg[0] = (1 << 25);\r\nmac = vf->vp->mac;\r\ncmd->rsp.arg[2] = mac[1] | ((mac[0] << 8) & 0xff00);\r\ncmd->rsp.arg[1] = mac[5] | ((mac[4] << 8) & 0xff00) |\r\n((mac[3]) << 16 & 0xff0000) |\r\n((mac[2]) << 24 & 0xff000000);\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_validate_create_tx_ctx(struct qlcnic_cmd_args *cmd)\r\n{\r\nif ((cmd->req.arg[0] >> 29) != 0x3)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_create_tx_ctx_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nstruct qlcnic_tx_mbx_out *mbx_out;\r\nint err;\r\nerr = qlcnic_sriov_validate_create_tx_ctx(cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\ncmd->req.arg[5] |= vf->vp->handle << 16;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err) {\r\nmbx_out = (struct qlcnic_tx_mbx_out *)&cmd->rsp.arg[2];\r\nvf->tx_ctx_id = mbx_out->ctx_id;\r\n} else {\r\nvf->tx_ctx_id = 0;\r\n}\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_del_rx_ctx(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif ((cmd->req.arg[0] >> 29) != 0x3)\r\nreturn -EINVAL;\r\nif ((cmd->req.arg[1] & 0xffff) != vf->rx_ctx_id)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_del_rx_ctx_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_del_rx_ctx(vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\nqlcnic_83xx_cfg_default_mac_vlan(adapter, vf, QLCNIC_MAC_DEL);\r\ncmd->req.arg[1] |= vf->vp->handle << 16;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err)\r\nvf->rx_ctx_id = 0;\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_del_tx_ctx(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif ((cmd->req.arg[0] >> 29) != 0x3)\r\nreturn -EINVAL;\r\nif ((cmd->req.arg[1] & 0xffff) != vf->tx_ctx_id)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_del_tx_ctx_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_del_tx_ctx(vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\ncmd->req.arg[1] |= vf->vp->handle << 16;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nif (!err)\r\nvf->tx_ctx_id = 0;\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_cfg_lro(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif ((cmd->req.arg[1] >> 16) != vf->rx_ctx_id)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_lro_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_cfg_lro(vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_ip_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err = -EIO;\r\nu8 op;\r\nop = cmd->req.arg[1] & 0xff;\r\ncmd->req.arg[1] |= vf->vp->handle << 16;\r\ncmd->req.arg[1] |= BIT_31;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_cfg_intrpt(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif (((cmd->req.arg[1] >> 8) & 0xff) != vf->pci_func)\r\nreturn -EINVAL;\r\nif (!(cmd->req.arg[1] & BIT_16))\r\nreturn -EINVAL;\r\nif ((cmd->req.arg[1] & 0xff) != 0x1)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_intrpt_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_cfg_intrpt(vf, cmd);\r\nif (err)\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nelse\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_mtu(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif (cmd->req.arg[1] != vf->rx_ctx_id)\r\nreturn -EINVAL;\r\nif (cmd->req.arg[2] > adapter->ahw->max_mtu)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_set_mtu_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_mtu(adapter, vf, cmd);\r\nif (err)\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nelse\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_get_nic_info(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif (cmd->req.arg[1] & BIT_31) {\r\nif (((cmd->req.arg[1] >> 16) & 0x7fff) != vf->pci_func)\r\nreturn -EINVAL;\r\n} else {\r\ncmd->req.arg[1] |= vf->vp->handle << 16;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_get_nic_info_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_get_nic_info(vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_cfg_rss(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif (cmd->req.arg[1] != vf->rx_ctx_id)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_rss_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_cfg_rss(vf, cmd);\r\nif (err)\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nelse\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_cfg_intrcoal(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_nic_intr_coalesce *coal = &adapter->ahw->coal;\r\nu16 ctx_id, pkts, time;\r\nint err = -EINVAL;\r\nu8 type;\r\ntype = cmd->req.arg[1] & QLC_INTR_COAL_TYPE_MASK;\r\nctx_id = cmd->req.arg[1] >> 16;\r\npkts = cmd->req.arg[2] & 0xffff;\r\ntime = cmd->req.arg[2] >> 16;\r\nswitch (type) {\r\ncase QLCNIC_INTR_COAL_TYPE_RX:\r\nif (ctx_id != vf->rx_ctx_id || pkts > coal->rx_packets ||\r\ntime < coal->rx_time_us)\r\ngoto err_label;\r\nbreak;\r\ncase QLCNIC_INTR_COAL_TYPE_TX:\r\nif (ctx_id != vf->tx_ctx_id || pkts > coal->tx_packets ||\r\ntime < coal->tx_time_us)\r\ngoto err_label;\r\nbreak;\r\ndefault:\r\nnetdev_err(adapter->netdev, "Invalid coalescing type 0x%x received\n",\r\ntype);\r\nreturn err;\r\n}\r\nreturn 0;\r\nerr_label:\r\nnetdev_err(adapter->netdev, "Expected: rx_ctx_id 0x%x rx_packets 0x%x rx_time_us 0x%x tx_ctx_id 0x%x tx_packets 0x%x tx_time_us 0x%x\n",\r\nvf->rx_ctx_id, coal->rx_packets, coal->rx_time_us,\r\nvf->tx_ctx_id, coal->tx_packets, coal->tx_time_us);\r\nnetdev_err(adapter->netdev, "Received: ctx_id 0x%x packets 0x%x time_us 0x%x type 0x%x\n",\r\nctx_id, pkts, time, type);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_intrcoal_cmd(struct qlcnic_bc_trans *tran,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = tran->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_cfg_intrcoal(adapter, vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_cfg_macvlan(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vport *vp = vf->vp;\r\nu8 op, new_op;\r\nif (!(cmd->req.arg[1] & BIT_8))\r\nreturn -EINVAL;\r\ncmd->req.arg[1] |= (vf->vp->handle << 16);\r\ncmd->req.arg[1] |= BIT_31;\r\nif (vp->vlan_mode == QLC_PVID_MODE) {\r\nop = cmd->req.arg[1] & 0x7;\r\ncmd->req.arg[1] &= ~0x7;\r\nnew_op = (op == QLCNIC_MAC_ADD || op == QLCNIC_MAC_VLAN_ADD) ?\r\nQLCNIC_MAC_VLAN_ADD : QLCNIC_MAC_VLAN_DEL;\r\ncmd->req.arg[3] |= vp->pvid << 16;\r\ncmd->req.arg[1] |= new_op;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_macvlan_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_cfg_macvlan(adapter, vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_validate_linkevent(struct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nif ((cmd->req.arg[1] >> 16) != vf->rx_ctx_id)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_linkevent_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\nerr = qlcnic_sriov_validate_linkevent(vf, cmd);\r\nif (err) {\r\ncmd->rsp.arg[0] |= (0x6 << 25);\r\nreturn err;\r\n}\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_promisc_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nint err;\r\ncmd->req.arg[1] |= vf->vp->handle << 16;\r\ncmd->req.arg[1] |= BIT_31;\r\nerr = qlcnic_issue_cmd(adapter, cmd);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_get_acl_cmd(struct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = trans->vf;\r\nstruct qlcnic_vport *vp = vf->vp;\r\nu8 cmd_op, mode = vp->vlan_mode;\r\nstruct qlcnic_adapter *adapter;\r\nstruct qlcnic_sriov *sriov;\r\nadapter = vf->adapter;\r\nsriov = adapter->ahw->sriov;\r\ncmd_op = trans->req_hdr->cmd_op;\r\ncmd->rsp.arg[0] |= 1 << 25;\r\nif (qlcnic_84xx_check(adapter) && mode == QLC_PVID_MODE)\r\nreturn 0;\r\nswitch (mode) {\r\ncase QLC_GUEST_VLAN_MODE:\r\ncmd->rsp.arg[1] = mode | 1 << 8;\r\ncmd->rsp.arg[2] = sriov->num_allowed_vlans << 16;\r\nbreak;\r\ncase QLC_PVID_MODE:\r\ncmd->rsp.arg[1] = mode | 1 << 8 | vp->pvid << 16;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_del_guest_vlan(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nu16 vlan;\r\nif (!qlcnic_sriov_check_any_vlan(vf))\r\nreturn -EINVAL;\r\nvlan = cmd->req.arg[1] >> 16;\r\nif (!vf->rx_ctx_id) {\r\nqlcnic_sriov_del_vlan_id(sriov, vf, vlan);\r\nreturn 0;\r\n}\r\nqlcnic_sriov_cfg_vf_def_mac(adapter, vf, vlan, QLCNIC_MAC_DEL);\r\nqlcnic_sriov_del_vlan_id(sriov, vf, vlan);\r\nif (qlcnic_83xx_pf_check(adapter))\r\nqlcnic_sriov_cfg_vf_def_mac(adapter, vf,\r\n0, QLCNIC_MAC_ADD);\r\nreturn 0;\r\n}\r\nstatic int qlcnic_sriov_pf_add_guest_vlan(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nint err = -EIO;\r\nu16 vlan;\r\nif (qlcnic_83xx_pf_check(adapter) && qlcnic_sriov_check_any_vlan(vf))\r\nreturn err;\r\nvlan = cmd->req.arg[1] >> 16;\r\nif (!vf->rx_ctx_id) {\r\nqlcnic_sriov_add_vlan_id(sriov, vf, vlan);\r\nreturn 0;\r\n}\r\nif (qlcnic_83xx_pf_check(adapter)) {\r\nerr = qlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0,\r\nQLCNIC_MAC_DEL);\r\nif (err)\r\nreturn err;\r\n}\r\nerr = qlcnic_sriov_cfg_vf_def_mac(adapter, vf, vlan, QLCNIC_MAC_ADD);\r\nif (err) {\r\nif (qlcnic_83xx_pf_check(adapter))\r\nqlcnic_sriov_cfg_vf_def_mac(adapter, vf, 0,\r\nQLCNIC_MAC_ADD);\r\nreturn err;\r\n}\r\nqlcnic_sriov_add_vlan_id(sriov, vf, vlan);\r\nreturn err;\r\n}\r\nstatic int qlcnic_sriov_pf_cfg_guest_vlan_cmd(struct qlcnic_bc_trans *tran,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nstruct qlcnic_vf_info *vf = tran->vf;\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nstruct qlcnic_vport *vp = vf->vp;\r\nint err = -EIO;\r\nu8 op;\r\nif (vp->vlan_mode != QLC_GUEST_VLAN_MODE) {\r\ncmd->rsp.arg[0] |= 2 << 25;\r\nreturn err;\r\n}\r\nop = cmd->req.arg[1] & 0xf;\r\nif (op)\r\nerr = qlcnic_sriov_pf_add_guest_vlan(adapter, vf, cmd);\r\nelse\r\nerr = qlcnic_sriov_pf_del_guest_vlan(adapter, vf, cmd);\r\ncmd->rsp.arg[0] |= err ? 2 << 25 : 1 << 25;\r\nreturn err;\r\n}\r\nvoid qlcnic_sriov_pf_process_bc_cmd(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_bc_trans *trans,\r\nstruct qlcnic_cmd_args *cmd)\r\n{\r\nu8 size, cmd_op;\r\ncmd_op = trans->req_hdr->cmd_op;\r\nif (trans->req_hdr->op_type == QLC_BC_CMD) {\r\nsize = ARRAY_SIZE(qlcnic_pf_bc_cmd_hdlr);\r\nif (cmd_op < size) {\r\nqlcnic_pf_bc_cmd_hdlr[cmd_op].fn(trans, cmd);\r\nreturn;\r\n}\r\n} else {\r\nint i;\r\nsize = ARRAY_SIZE(qlcnic_pf_fw_cmd_hdlr);\r\nfor (i = 0; i < size; i++) {\r\nif (cmd_op == qlcnic_pf_fw_cmd_hdlr[i].cmd) {\r\nqlcnic_pf_fw_cmd_hdlr[i].fn(trans, cmd);\r\nreturn;\r\n}\r\n}\r\nsize = ARRAY_SIZE(qlcnic_pf_passthru_supp_cmds);\r\nfor (i = 0; i < size; i++) {\r\nif (cmd_op == qlcnic_pf_passthru_supp_cmds[i]) {\r\nqlcnic_issue_cmd(adapter, cmd);\r\nreturn;\r\n}\r\n}\r\n}\r\ncmd->rsp.arg[0] |= (0x9 << 25);\r\n}\r\nvoid qlcnic_pf_set_interface_id_create_rx_ctx(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nu16 vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= vpid;\r\n}\r\nvoid qlcnic_pf_set_interface_id_del_rx_ctx(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nu16 vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= vpid << 16;\r\n}\r\nvoid qlcnic_pf_set_interface_id_create_tx_ctx(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nint vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= vpid << 16;\r\n}\r\nvoid qlcnic_pf_set_interface_id_del_tx_ctx(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nu16 vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= vpid << 16;\r\n}\r\nvoid qlcnic_pf_set_interface_id_promisc(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nu16 vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= (vpid << 16) | BIT_31;\r\n}\r\nvoid qlcnic_pf_set_interface_id_ipaddr(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nu16 vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= (vpid << 16) | BIT_31;\r\n}\r\nvoid qlcnic_pf_set_interface_id_macaddr(struct qlcnic_adapter *adapter,\r\nu32 *int_id)\r\n{\r\nu16 vpid;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter,\r\nadapter->ahw->pci_func);\r\n*int_id |= (vpid << 16) | BIT_31;\r\n}\r\nstatic void qlcnic_sriov_del_rx_ctx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint vpid;\r\nif (!vf->rx_ctx_id)\r\nreturn;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_RX_CTX))\r\nreturn;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter, vf->pci_func);\r\nif (vpid >= 0) {\r\ncmd.req.arg[1] = vf->rx_ctx_id | (vpid & 0xffff) << 16;\r\nif (qlcnic_issue_cmd(adapter, &cmd))\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to delete Tx ctx in firmware for func 0x%x\n",\r\nvf->pci_func);\r\nelse\r\nvf->rx_ctx_id = 0;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nstatic void qlcnic_sriov_del_tx_ctx(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vf_info *vf)\r\n{\r\nstruct qlcnic_cmd_args cmd;\r\nint vpid;\r\nif (!vf->tx_ctx_id)\r\nreturn;\r\nif (qlcnic_alloc_mbx_args(&cmd, adapter, QLCNIC_CMD_DESTROY_TX_CTX))\r\nreturn;\r\nvpid = qlcnic_sriov_pf_get_vport_handle(adapter, vf->pci_func);\r\nif (vpid >= 0) {\r\ncmd.req.arg[1] |= vf->tx_ctx_id | (vpid & 0xffff) << 16;\r\nif (qlcnic_issue_cmd(adapter, &cmd))\r\ndev_err(&adapter->pdev->dev,\r\n"Failed to delete Tx ctx in firmware for func 0x%x\n",\r\nvf->pci_func);\r\nelse\r\nvf->tx_ctx_id = 0;\r\n}\r\nqlcnic_free_mbx_args(&cmd);\r\n}\r\nstatic int qlcnic_sriov_add_act_list_irqsave(struct qlcnic_sriov *sriov,\r\nstruct qlcnic_vf_info *vf,\r\nstruct qlcnic_bc_trans *trans)\r\n{\r\nstruct qlcnic_trans_list *t_list = &vf->rcv_act;\r\nunsigned long flag;\r\nspin_lock_irqsave(&t_list->lock, flag);\r\n__qlcnic_sriov_add_act_list(sriov, vf, trans);\r\nspin_unlock_irqrestore(&t_list->lock, flag);\r\nreturn 0;\r\n}\r\nstatic void __qlcnic_sriov_process_flr(struct qlcnic_vf_info *vf)\r\n{\r\nstruct qlcnic_adapter *adapter = vf->adapter;\r\nqlcnic_sriov_cleanup_list(&vf->rcv_pend);\r\ncancel_work_sync(&vf->trans_work);\r\nqlcnic_sriov_cleanup_list(&vf->rcv_act);\r\nif (test_bit(QLC_BC_VF_SOFT_FLR, &vf->state)) {\r\nqlcnic_sriov_del_tx_ctx(adapter, vf);\r\nqlcnic_sriov_del_rx_ctx(adapter, vf);\r\n}\r\nqlcnic_sriov_pf_config_vport(adapter, 0, vf->pci_func);\r\nclear_bit(QLC_BC_VF_FLR, &vf->state);\r\nif (test_bit(QLC_BC_VF_SOFT_FLR, &vf->state)) {\r\nqlcnic_sriov_add_act_list_irqsave(adapter->ahw->sriov, vf,\r\nvf->flr_trans);\r\nclear_bit(QLC_BC_VF_SOFT_FLR, &vf->state);\r\nvf->flr_trans = NULL;\r\n}\r\n}\r\nstatic void qlcnic_sriov_pf_process_flr(struct work_struct *work)\r\n{\r\nstruct qlcnic_vf_info *vf;\r\nvf = container_of(work, struct qlcnic_vf_info, flr_work);\r\n__qlcnic_sriov_process_flr(vf);\r\nreturn;\r\n}\r\nstatic void qlcnic_sriov_schedule_flr(struct qlcnic_sriov *sriov,\r\nstruct qlcnic_vf_info *vf,\r\nwork_func_t func)\r\n{\r\nif (test_bit(__QLCNIC_RESETTING, &vf->adapter->state))\r\nreturn;\r\nINIT_WORK(&vf->flr_work, func);\r\nqueue_work(sriov->bc.bc_flr_wq, &vf->flr_work);\r\n}\r\nstatic void qlcnic_sriov_handle_soft_flr(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_bc_trans *trans,\r\nstruct qlcnic_vf_info *vf)\r\n{\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nset_bit(QLC_BC_VF_FLR, &vf->state);\r\nclear_bit(QLC_BC_VF_STATE, &vf->state);\r\nset_bit(QLC_BC_VF_SOFT_FLR, &vf->state);\r\nvf->flr_trans = trans;\r\nqlcnic_sriov_schedule_flr(sriov, vf, qlcnic_sriov_pf_process_flr);\r\nnetdev_info(adapter->netdev, "Software FLR for PCI func %d\n",\r\nvf->pci_func);\r\n}\r\nbool qlcnic_sriov_soft_flr_check(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_bc_trans *trans,\r\nstruct qlcnic_vf_info *vf)\r\n{\r\nstruct qlcnic_bc_hdr *hdr = trans->req_hdr;\r\nif ((hdr->cmd_op == QLCNIC_BC_CMD_CHANNEL_INIT) &&\r\n(hdr->op_type == QLC_BC_CMD) &&\r\ntest_bit(QLC_BC_VF_STATE, &vf->state)) {\r\nqlcnic_sriov_handle_soft_flr(adapter, trans, vf);\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nvoid qlcnic_sriov_pf_handle_flr(struct qlcnic_sriov *sriov,\r\nstruct qlcnic_vf_info *vf)\r\n{\r\nstruct net_device *dev = vf->adapter->netdev;\r\nstruct qlcnic_vport *vp = vf->vp;\r\nif (!test_and_clear_bit(QLC_BC_VF_STATE, &vf->state)) {\r\nclear_bit(QLC_BC_VF_FLR, &vf->state);\r\nreturn;\r\n}\r\nif (test_and_set_bit(QLC_BC_VF_FLR, &vf->state)) {\r\nnetdev_info(dev, "FLR for PCI func %d in progress\n",\r\nvf->pci_func);\r\nreturn;\r\n}\r\nif (vp->vlan_mode == QLC_GUEST_VLAN_MODE)\r\nmemset(vf->sriov_vlans, 0,\r\nsizeof(*vf->sriov_vlans) * sriov->num_allowed_vlans);\r\nqlcnic_sriov_schedule_flr(sriov, vf, qlcnic_sriov_pf_process_flr);\r\nnetdev_info(dev, "FLR received for PCI func %d\n", vf->pci_func);\r\n}\r\nvoid qlcnic_sriov_pf_reset(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nstruct qlcnic_sriov *sriov = ahw->sriov;\r\nstruct qlcnic_vf_info *vf;\r\nu16 num_vfs = sriov->num_vfs;\r\nint i;\r\nfor (i = 0; i < num_vfs; i++) {\r\nvf = &sriov->vf_info[i];\r\nvf->rx_ctx_id = 0;\r\nvf->tx_ctx_id = 0;\r\ncancel_work_sync(&vf->flr_work);\r\n__qlcnic_sriov_process_flr(vf);\r\nclear_bit(QLC_BC_VF_STATE, &vf->state);\r\n}\r\nqlcnic_sriov_pf_reset_vport_handle(adapter, ahw->pci_func);\r\nQLCWRX(ahw, QLCNIC_MBX_INTR_ENBL, (ahw->num_msix - 1) << 8);\r\n}\r\nint qlcnic_sriov_pf_reinit(struct qlcnic_adapter *adapter)\r\n{\r\nstruct qlcnic_hardware_context *ahw = adapter->ahw;\r\nint err;\r\nif (!qlcnic_sriov_enable_check(adapter))\r\nreturn 0;\r\nahw->op_mode = QLCNIC_SRIOV_PF_FUNC;\r\nerr = qlcnic_sriov_pf_init(adapter);\r\nif (err)\r\nreturn err;\r\ndev_info(&adapter->pdev->dev, "%s: op_mode %d\n",\r\n__func__, ahw->op_mode);\r\nreturn err;\r\n}\r\nint qlcnic_sriov_set_vf_mac(struct net_device *netdev, int vf, u8 *mac)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nint i, num_vfs;\r\nstruct qlcnic_vf_info *vf_info;\r\nu8 *curr_mac;\r\nif (!qlcnic_sriov_pf_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nnum_vfs = sriov->num_vfs;\r\nif (!is_valid_ether_addr(mac) || vf >= num_vfs)\r\nreturn -EINVAL;\r\nif (ether_addr_equal(adapter->mac_addr, mac)) {\r\nnetdev_err(netdev, "MAC address is already in use by the PF\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < num_vfs; i++) {\r\nvf_info = &sriov->vf_info[i];\r\nif (ether_addr_equal(vf_info->vp->mac, mac)) {\r\nnetdev_err(netdev,\r\n"MAC address is already in use by VF %d\n",\r\ni);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvf_info = &sriov->vf_info[vf];\r\ncurr_mac = vf_info->vp->mac;\r\nif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\r\nnetdev_err(netdev,\r\n"MAC address change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\n",\r\nvf);\r\nreturn -EOPNOTSUPP;\r\n}\r\nmemcpy(curr_mac, mac, netdev->addr_len);\r\nnetdev_info(netdev, "MAC Address %pM is configured for VF %d\n",\r\nmac, vf);\r\nreturn 0;\r\n}\r\nint qlcnic_sriov_set_vf_tx_rate(struct net_device *netdev, int vf,\r\nint min_tx_rate, int max_tx_rate)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vf_info *vf_info;\r\nstruct qlcnic_info nic_info;\r\nstruct qlcnic_vport *vp;\r\nu16 vpid;\r\nif (!qlcnic_sriov_pf_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (vf >= sriov->num_vfs)\r\nreturn -EINVAL;\r\nvf_info = &sriov->vf_info[vf];\r\nvp = vf_info->vp;\r\nvpid = vp->handle;\r\nif (!min_tx_rate)\r\nmin_tx_rate = QLC_VF_MIN_TX_RATE;\r\nif (max_tx_rate &&\r\n(max_tx_rate >= 10000 || max_tx_rate < min_tx_rate)) {\r\nnetdev_err(netdev,\r\n"Invalid max Tx rate, allowed range is [%d - %d]",\r\nmin_tx_rate, QLC_VF_MAX_TX_RATE);\r\nreturn -EINVAL;\r\n}\r\nif (!max_tx_rate)\r\nmax_tx_rate = 10000;\r\nif (min_tx_rate &&\r\n(min_tx_rate > max_tx_rate || min_tx_rate < QLC_VF_MIN_TX_RATE)) {\r\nnetdev_err(netdev,\r\n"Invalid min Tx rate, allowed range is [%d - %d]",\r\nQLC_VF_MIN_TX_RATE, max_tx_rate);\r\nreturn -EINVAL;\r\n}\r\nif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\r\nif (qlcnic_sriov_get_vf_vport_info(adapter, &nic_info, vpid))\r\nreturn -EIO;\r\nnic_info.max_tx_bw = max_tx_rate / 100;\r\nnic_info.min_tx_bw = min_tx_rate / 100;\r\nnic_info.bit_offsets = BIT_0;\r\nif (qlcnic_sriov_pf_set_vport_info(adapter, &nic_info, vpid))\r\nreturn -EIO;\r\n}\r\nvp->max_tx_bw = max_tx_rate / 100;\r\nnetdev_info(netdev,\r\n"Setting Max Tx rate %d (Mbps), %d %% of PF bandwidth, for VF %d\n",\r\nmax_tx_rate, vp->max_tx_bw, vf);\r\nvp->min_tx_bw = min_tx_rate / 100;\r\nnetdev_info(netdev,\r\n"Setting Min Tx rate %d (Mbps), %d %% of PF bandwidth, for VF %d\n",\r\nmin_tx_rate, vp->min_tx_bw, vf);\r\nreturn 0;\r\n}\r\nint qlcnic_sriov_set_vf_vlan(struct net_device *netdev, int vf,\r\nu16 vlan, u8 qos, __be16 vlan_proto)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vf_info *vf_info;\r\nstruct qlcnic_vport *vp;\r\nif (!qlcnic_sriov_pf_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (vf >= sriov->num_vfs || qos > 7)\r\nreturn -EINVAL;\r\nif (vlan_proto != htons(ETH_P_8021Q))\r\nreturn -EPROTONOSUPPORT;\r\nif (vlan > MAX_VLAN_ID) {\r\nnetdev_err(netdev,\r\n"Invalid VLAN ID, allowed range is [0 - %d]\n",\r\nMAX_VLAN_ID);\r\nreturn -EINVAL;\r\n}\r\nvf_info = &sriov->vf_info[vf];\r\nvp = vf_info->vp;\r\nif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\r\nnetdev_err(netdev,\r\n"VLAN change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\n",\r\nvf);\r\nreturn -EOPNOTSUPP;\r\n}\r\nmemset(vf_info->sriov_vlans, 0,\r\nsizeof(*vf_info->sriov_vlans) * sriov->num_allowed_vlans);\r\nswitch (vlan) {\r\ncase 4095:\r\nvp->vlan_mode = QLC_GUEST_VLAN_MODE;\r\nbreak;\r\ncase 0:\r\nvp->vlan_mode = QLC_NO_VLAN_MODE;\r\nvp->qos = 0;\r\nbreak;\r\ndefault:\r\nvp->vlan_mode = QLC_PVID_MODE;\r\nqlcnic_sriov_add_vlan_id(sriov, vf_info, vlan);\r\nvp->qos = qos;\r\nvp->pvid = vlan;\r\n}\r\nnetdev_info(netdev, "Setting VLAN %d, QoS %d, for VF %d\n",\r\nvlan, qos, vf);\r\nreturn 0;\r\n}\r\nstatic __u32 qlcnic_sriov_get_vf_vlan(struct qlcnic_adapter *adapter,\r\nstruct qlcnic_vport *vp, int vf)\r\n{\r\n__u32 vlan = 0;\r\nswitch (vp->vlan_mode) {\r\ncase QLC_PVID_MODE:\r\nvlan = vp->pvid;\r\nbreak;\r\ncase QLC_GUEST_VLAN_MODE:\r\nvlan = MAX_VLAN_ID;\r\nbreak;\r\ncase QLC_NO_VLAN_MODE:\r\nvlan = 0;\r\nbreak;\r\ndefault:\r\nnetdev_info(adapter->netdev, "Invalid VLAN mode = %d for VF %d\n",\r\nvp->vlan_mode, vf);\r\n}\r\nreturn vlan;\r\n}\r\nint qlcnic_sriov_get_vf_config(struct net_device *netdev,\r\nint vf, struct ifla_vf_info *ivi)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vport *vp;\r\nif (!qlcnic_sriov_pf_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (vf >= sriov->num_vfs)\r\nreturn -EINVAL;\r\nvp = sriov->vf_info[vf].vp;\r\nmemcpy(&ivi->mac, vp->mac, ETH_ALEN);\r\nivi->vlan = qlcnic_sriov_get_vf_vlan(adapter, vp, vf);\r\nivi->qos = vp->qos;\r\nivi->spoofchk = vp->spoofchk;\r\nif (vp->max_tx_bw == MAX_BW)\r\nivi->max_tx_rate = 0;\r\nelse\r\nivi->max_tx_rate = vp->max_tx_bw * 100;\r\nif (vp->min_tx_bw == MIN_BW)\r\nivi->min_tx_rate = 0;\r\nelse\r\nivi->min_tx_rate = vp->min_tx_bw * 100;\r\nivi->vf = vf;\r\nreturn 0;\r\n}\r\nint qlcnic_sriov_set_vf_spoofchk(struct net_device *netdev, int vf, bool chk)\r\n{\r\nstruct qlcnic_adapter *adapter = netdev_priv(netdev);\r\nstruct qlcnic_sriov *sriov = adapter->ahw->sriov;\r\nstruct qlcnic_vf_info *vf_info;\r\nstruct qlcnic_vport *vp;\r\nif (!qlcnic_sriov_pf_check(adapter))\r\nreturn -EOPNOTSUPP;\r\nif (vf >= sriov->num_vfs)\r\nreturn -EINVAL;\r\nvf_info = &sriov->vf_info[vf];\r\nvp = vf_info->vp;\r\nif (test_bit(QLC_BC_VF_STATE, &vf_info->state)) {\r\nnetdev_err(netdev,\r\n"Spoof check change failed for VF %d, as VF driver is loaded. Please unload VF driver and retry the operation\n",\r\nvf);\r\nreturn -EOPNOTSUPP;\r\n}\r\nvp->spoofchk = chk;\r\nreturn 0;\r\n}
