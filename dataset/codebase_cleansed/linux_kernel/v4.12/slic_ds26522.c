static void slic_write(struct spi_device *spi, u16 addr,\r\nu8 data)\r\n{\r\nu8 temp[3];\r\naddr = bitrev16(addr) >> 1;\r\ndata = bitrev8(data);\r\ntemp[0] = (u8)((addr >> 8) & 0x7f);\r\ntemp[1] = (u8)(addr & 0xfe);\r\ntemp[2] = data;\r\nspi_write(spi, &temp[0], SLIC_THREE_LEN);\r\n}\r\nstatic u8 slic_read(struct spi_device *spi, u16 addr)\r\n{\r\nu8 temp[2];\r\nu8 data;\r\naddr = bitrev16(addr) >> 1;\r\ntemp[0] = (u8)(((addr >> 8) & 0x7f) | 0x80);\r\ntemp[1] = (u8)(addr & 0xfe);\r\nspi_write_then_read(spi, &temp[0], SLIC_TWO_LEN, &data,\r\nSLIC_TRANS_LEN);\r\ndata = bitrev8(data);\r\nreturn data;\r\n}\r\nstatic bool get_slic_product_code(struct spi_device *spi)\r\n{\r\nu8 device_id;\r\ndevice_id = slic_read(spi, DS26522_IDR_ADDR);\r\nif ((device_id & 0xf8) == 0x68)\r\nreturn true;\r\nelse\r\nreturn false;\r\n}\r\nstatic void ds26522_e1_spec_config(struct spi_device *spi)\r\n{\r\nslic_write(spi, DS26522_RMMR_ADDR, DS26522_RMMR_E1);\r\nslic_write(spi, DS26522_TMMR_ADDR, DS26522_TMMR_E1);\r\nslic_write(spi, DS26522_RMMR_ADDR,\r\nslic_read(spi, DS26522_RMMR_ADDR) | DS26522_RMMR_FRM_EN);\r\nslic_write(spi, DS26522_TMMR_ADDR,\r\nslic_read(spi, DS26522_TMMR_ADDR) | DS26522_TMMR_FRM_EN);\r\nslic_write(spi, DS26522_RCR1_ADDR,\r\nDS26522_RCR1_E1_HDB3 | DS26522_RCR1_E1_CCS);\r\nslic_write(spi, DS26522_RIOCR_ADDR,\r\nDS26522_RIOCR_2048KHZ | DS26522_RIOCR_RSIO_OUT);\r\nslic_write(spi, DS26522_TCR1_ADDR, DS26522_TCR1_TB8ZS);\r\nslic_write(spi, DS26522_TIOCR_ADDR,\r\nDS26522_TIOCR_2048KHZ | DS26522_TIOCR_TSIO_OUT);\r\nslic_write(spi, DS26522_E1TAF_ADDR, DS26522_E1TAF_DEFAULT);\r\nslic_write(spi, DS26522_E1TNAF_ADDR, DS26522_E1TNAF_DEFAULT);\r\nslic_write(spi, DS26522_RMMR_ADDR, slic_read(spi, DS26522_RMMR_ADDR) |\r\nDS26522_RMMR_INIT_DONE);\r\nslic_write(spi, DS26522_TMMR_ADDR, slic_read(spi, DS26522_TMMR_ADDR) |\r\nDS26522_TMMR_INIT_DONE);\r\nslic_write(spi, DS26522_LTRCR_ADDR, DS26522_LTRCR_E1);\r\nslic_write(spi, DS26522_LTITSR_ADDR,\r\nDS26522_LTITSR_TLIS_75OHM | DS26522_LTITSR_LBOS_75OHM);\r\nslic_write(spi, DS26522_LRISMR_ADDR,\r\nDS26522_LRISMR_75OHM | DS26522_LRISMR_MAX);\r\nslic_write(spi, DS26522_LMCR_ADDR, DS26522_LMCR_TE);\r\n}\r\nstatic int slic_ds26522_init_configure(struct spi_device *spi)\r\n{\r\nu16 addr;\r\nslic_write(spi, DS26522_GTCCR_ADDR, DS26522_GTCCR_BPREFSEL_REFCLKIN |\r\nDS26522_GTCCR_BFREQSEL_2048KHZ |\r\nDS26522_GTCCR_FREQSEL_2048KHZ);\r\nslic_write(spi, DS26522_GTCR2_ADDR, DS26522_GTCR2_TSSYNCOUT);\r\nslic_write(spi, DS26522_GFCR_ADDR, DS26522_GFCR_BPCLK_2048KHZ);\r\nslic_write(spi, DS26522_GTCR1_ADDR, DS26522_GTCR1);\r\nslic_write(spi, DS26522_GLSRR_ADDR, DS26522_GLSRR_RESET);\r\nslic_write(spi, DS26522_GFSRR_ADDR, DS26522_GFSRR_RESET);\r\nusleep_range(100, 120);\r\nslic_write(spi, DS26522_GLSRR_ADDR, DS26522_GLSRR_NORMAL);\r\nslic_write(spi, DS26522_GFSRR_ADDR, DS26522_GFSRR_NORMAL);\r\nslic_write(spi, DS26522_RMMR_ADDR, DS26522_RMMR_SFTRST);\r\nslic_write(spi, DS26522_TMMR_ADDR, DS26522_TMMR_SFTRST);\r\nusleep_range(100, 120);\r\nfor (addr = DS26522_RF_ADDR_START; addr <= DS26522_RF_ADDR_END;\r\naddr++)\r\nslic_write(spi, addr, 0);\r\nfor (addr = DS26522_TF_ADDR_START; addr <= DS26522_TF_ADDR_END;\r\naddr++)\r\nslic_write(spi, addr, 0);\r\nfor (addr = DS26522_LIU_ADDR_START; addr <= DS26522_LIU_ADDR_END;\r\naddr++)\r\nslic_write(spi, addr, 0);\r\nfor (addr = DS26522_BERT_ADDR_START; addr <= DS26522_BERT_ADDR_END;\r\naddr++)\r\nslic_write(spi, addr, 0);\r\nds26522_e1_spec_config(spi);\r\nslic_write(spi, DS26522_GTCR1_ADDR, 0x00);\r\nreturn 0;\r\n}\r\nstatic int slic_ds26522_remove(struct spi_device *spi)\r\n{\r\npr_info("DS26522 module uninstalled\n");\r\nreturn 0;\r\n}\r\nstatic int slic_ds26522_probe(struct spi_device *spi)\r\n{\r\nint ret = 0;\r\ng_spi = spi;\r\nspi->bits_per_word = 8;\r\nif (!get_slic_product_code(spi))\r\nreturn ret;\r\nret = slic_ds26522_init_configure(spi);\r\nif (ret == 0)\r\npr_info("DS26522 cs%d configured\n", spi->chip_select);\r\nreturn ret;\r\n}
