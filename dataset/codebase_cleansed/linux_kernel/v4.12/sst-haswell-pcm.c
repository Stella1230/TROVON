static inline u32 hsw_mixer_to_ipc(unsigned int value)\r\n{\r\nif (value >= ARRAY_SIZE(volume_map))\r\nreturn volume_map[0];\r\nelse\r\nreturn volume_map[value];\r\n}\r\nstatic inline unsigned int hsw_ipc_to_mixer(u32 value)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(volume_map); i++) {\r\nif (volume_map[i] >= value)\r\nreturn i;\r\n}\r\nreturn i - 1;\r\n}\r\nstatic int hsw_stream_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nu32 volume;\r\nint dai, stream;\r\ndai = mod_map[mc->reg].dai_id;\r\nstream = mod_map[mc->reg].stream;\r\npcm_data = &pdata->pcm[dai][stream];\r\nmutex_lock(&pcm_data->mutex);\r\npm_runtime_get_sync(pdata->dev);\r\nif (!pcm_data->stream) {\r\npcm_data->volume[0] =\r\nhsw_mixer_to_ipc(ucontrol->value.integer.value[0]);\r\npcm_data->volume[1] =\r\nhsw_mixer_to_ipc(ucontrol->value.integer.value[1]);\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn 0;\r\n}\r\nif (ucontrol->value.integer.value[0] ==\r\nucontrol->value.integer.value[1]) {\r\nvolume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);\r\nsst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, SST_HSW_CHANNELS_ALL, volume);\r\n} else {\r\nvolume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);\r\nsst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 0, volume);\r\nvolume = hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);\r\nsst_hsw_stream_set_volume(hsw, pcm_data->stream, 0, 1, volume);\r\n}\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn 0;\r\n}\r\nstatic int hsw_stream_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct soc_mixer_control *mc =\r\n(struct soc_mixer_control *)kcontrol->private_value;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nu32 volume;\r\nint dai, stream;\r\ndai = mod_map[mc->reg].dai_id;\r\nstream = mod_map[mc->reg].stream;\r\npcm_data = &pdata->pcm[dai][stream];\r\nmutex_lock(&pcm_data->mutex);\r\npm_runtime_get_sync(pdata->dev);\r\nif (!pcm_data->stream) {\r\nucontrol->value.integer.value[0] =\r\nhsw_ipc_to_mixer(pcm_data->volume[0]);\r\nucontrol->value.integer.value[1] =\r\nhsw_ipc_to_mixer(pcm_data->volume[1]);\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn 0;\r\n}\r\nsst_hsw_stream_get_volume(hsw, pcm_data->stream, 0, 0, &volume);\r\nucontrol->value.integer.value[0] = hsw_ipc_to_mixer(volume);\r\nsst_hsw_stream_get_volume(hsw, pcm_data->stream, 0, 1, &volume);\r\nucontrol->value.integer.value[1] = hsw_ipc_to_mixer(volume);\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn 0;\r\n}\r\nstatic int hsw_volume_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nu32 volume;\r\npm_runtime_get_sync(pdata->dev);\r\nif (ucontrol->value.integer.value[0] ==\r\nucontrol->value.integer.value[1]) {\r\nvolume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);\r\nsst_hsw_mixer_set_volume(hsw, 0, SST_HSW_CHANNELS_ALL, volume);\r\n} else {\r\nvolume = hsw_mixer_to_ipc(ucontrol->value.integer.value[0]);\r\nsst_hsw_mixer_set_volume(hsw, 0, 0, volume);\r\nvolume = hsw_mixer_to_ipc(ucontrol->value.integer.value[1]);\r\nsst_hsw_mixer_set_volume(hsw, 0, 1, volume);\r\n}\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nreturn 0;\r\n}\r\nstatic int hsw_volume_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nunsigned int volume = 0;\r\npm_runtime_get_sync(pdata->dev);\r\nsst_hsw_mixer_get_volume(hsw, 0, 0, &volume);\r\nucontrol->value.integer.value[0] = hsw_ipc_to_mixer(volume);\r\nsst_hsw_mixer_get_volume(hsw, 0, 1, &volume);\r\nucontrol->value.integer.value[1] = hsw_ipc_to_mixer(volume);\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nreturn 0;\r\n}\r\nstatic int hsw_waves_switch_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nenum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;\r\nucontrol->value.integer.value[0] =\r\n(sst_hsw_is_module_active(hsw, id) ||\r\nsst_hsw_is_module_enabled_rtd3(hsw, id));\r\nreturn 0;\r\n}\r\nstatic int hsw_waves_switch_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nint ret = 0;\r\nenum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;\r\nbool switch_on = (bool)ucontrol->value.integer.value[0];\r\nif (sst_hsw_is_module_loaded(hsw, id)) {\r\nif (switch_on == sst_hsw_is_module_active(hsw, id))\r\nreturn 0;\r\nif (switch_on)\r\nret = sst_hsw_module_enable(hsw, id, 0);\r\nelse\r\nret = sst_hsw_module_disable(hsw, id, 0);\r\n} else {\r\nif (switch_on == sst_hsw_is_module_enabled_rtd3(hsw, id))\r\nreturn 0;\r\nif (switch_on)\r\nsst_hsw_set_module_enabled_rtd3(hsw, id);\r\nelse\r\nsst_hsw_set_module_disabled_rtd3(hsw, id);\r\n}\r\nreturn ret;\r\n}\r\nstatic int hsw_waves_param_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nreturn sst_hsw_load_param_line(hsw, ucontrol->value.bytes.data);\r\n}\r\nstatic int hsw_waves_param_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_platform *platform = snd_soc_kcontrol_platform(kcontrol);\r\nstruct hsw_priv_data *pdata = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nint ret;\r\nenum sst_hsw_module_id id = SST_HSW_MODULE_WAVES;\r\nint param_id = ucontrol->value.bytes.data[0];\r\nint param_size = WAVES_PARAM_COUNT;\r\nif (param_id == 0xFF) {\r\nsst_hsw_reset_param_buf(hsw);\r\nreturn 0;\r\n}\r\nret = sst_hsw_store_param_line(hsw, ucontrol->value.bytes.data);\r\nif (ret < 0)\r\nreturn ret;\r\nif (sst_hsw_is_module_active(hsw, id))\r\nret = sst_hsw_module_set_param(hsw, id, 0, param_id,\r\nparam_size, ucontrol->value.bytes.data);\r\nreturn ret;\r\n}\r\nstatic int create_adsp_page_table(struct snd_pcm_substream *substream,\r\nstruct hsw_priv_data *pdata, struct snd_soc_pcm_runtime *rtd,\r\nunsigned char *dma_area, size_t size, int pcm)\r\n{\r\nstruct snd_dma_buffer *dmab = snd_pcm_get_dma_buf(substream);\r\nint i, pages, stream = substream->stream;\r\npages = snd_sgbuf_aligned_pages(size);\r\ndev_dbg(rtd->dev, "generating page table for %p size 0x%zx pages %d\n",\r\ndma_area, size, pages);\r\nfor (i = 0; i < pages; i++) {\r\nu32 idx = (((i << 2) + i)) >> 1;\r\nu32 pfn = snd_sgbuf_get_addr(dmab, i * PAGE_SIZE) >> PAGE_SHIFT;\r\nu32 *pg_table;\r\ndev_dbg(rtd->dev, "pfn i %i idx %d pfn %x\n", i, idx, pfn);\r\npg_table = (u32 *)(pdata->dmab[pcm][stream].area + idx);\r\nif (i & 1)\r\n*pg_table |= (pfn << 4);\r\nelse\r\n*pg_table |= pfn;\r\n}\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nstruct sst_module *module_data;\r\nstruct sst_dsp *dsp;\r\nstruct snd_dma_buffer *dmab;\r\nenum sst_hsw_stream_type stream_type;\r\nenum sst_hsw_stream_path_id path_id;\r\nu32 rate, bits, map, pages, module_id;\r\nu8 channels;\r\nint ret, dai;\r\ndai = mod_map[rtd->cpu_dai->id].dai_id;\r\npcm_data = &pdata->pcm[dai][substream->stream];\r\nif (pcm_data->allocated) {\r\nret = sst_hsw_stream_reset(hsw, pcm_data->stream);\r\nif (ret < 0)\r\ndev_dbg(rtd->dev, "error: reset stream failed %d\n",\r\nret);\r\nret = sst_hsw_stream_free(hsw, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_dbg(rtd->dev, "error: free stream failed %d\n",\r\nret);\r\nreturn ret;\r\n}\r\npcm_data->allocated = false;\r\npcm_data->stream = sst_hsw_stream_new(hsw, rtd->cpu_dai->id,\r\nhsw_notify_pointer, pcm_data);\r\nif (pcm_data->stream == NULL) {\r\ndev_err(rtd->dev, "error: failed to create stream\n");\r\nreturn -EINVAL;\r\n}\r\n}\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)\r\npath_id = SST_HSW_STREAM_PATH_SSP0_OUT;\r\nelse\r\npath_id = SST_HSW_STREAM_PATH_SSP0_IN;\r\nswitch (rtd->cpu_dai->id) {\r\ncase 0:\r\nif (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {\r\nstream_type = SST_HSW_STREAM_TYPE_SYSTEM;\r\nmodule_id = SST_HSW_MODULE_PCM_SYSTEM;\r\n}\r\nelse {\r\nstream_type = SST_HSW_STREAM_TYPE_CAPTURE;\r\nmodule_id = SST_HSW_MODULE_PCM_CAPTURE;\r\n}\r\nbreak;\r\ncase 1:\r\ncase 2:\r\nstream_type = SST_HSW_STREAM_TYPE_RENDER;\r\nmodule_id = SST_HSW_MODULE_PCM;\r\nbreak;\r\ncase 3:\r\nstream_type = SST_HSW_STREAM_TYPE_LOOPBACK;\r\npath_id = SST_HSW_STREAM_PATH_SSP0_OUT;\r\nmodule_id = SST_HSW_MODULE_PCM_REFERENCE;\r\nbreak;\r\ndefault:\r\ndev_err(rtd->dev, "error: invalid DAI ID %d\n",\r\nrtd->cpu_dai->id);\r\nreturn -EINVAL;\r\n};\r\nret = sst_hsw_stream_format(hsw, pcm_data->stream,\r\npath_id, stream_type, SST_HSW_STREAM_FORMAT_PCM_FORMAT);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: failed to set format %d\n", ret);\r\nreturn ret;\r\n}\r\nrate = params_rate(params);\r\nret = sst_hsw_stream_set_rate(hsw, pcm_data->stream, rate);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: could not set rate %d\n", rate);\r\nreturn ret;\r\n}\r\nswitch (params_format(params)) {\r\ncase SNDRV_PCM_FORMAT_S16_LE:\r\nbits = SST_HSW_DEPTH_16BIT;\r\nsst_hsw_stream_set_valid(hsw, pcm_data->stream, 16);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S24_LE:\r\nbits = SST_HSW_DEPTH_32BIT;\r\nsst_hsw_stream_set_valid(hsw, pcm_data->stream, 24);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S8:\r\nbits = SST_HSW_DEPTH_8BIT;\r\nsst_hsw_stream_set_valid(hsw, pcm_data->stream, 8);\r\nbreak;\r\ncase SNDRV_PCM_FORMAT_S32_LE:\r\nbits = SST_HSW_DEPTH_32BIT;\r\nsst_hsw_stream_set_valid(hsw, pcm_data->stream, 32);\r\nbreak;\r\ndefault:\r\ndev_err(rtd->dev, "error: invalid format %d\n",\r\nparams_format(params));\r\nreturn -EINVAL;\r\n}\r\nret = sst_hsw_stream_set_bits(hsw, pcm_data->stream, bits);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: could not set bits %d\n", bits);\r\nreturn ret;\r\n}\r\nchannels = params_channels(params);\r\nmap = create_channel_map(SST_HSW_CHANNEL_CONFIG_STEREO);\r\nsst_hsw_stream_set_map_config(hsw, pcm_data->stream,\r\nmap, SST_HSW_CHANNEL_CONFIG_STEREO);\r\nret = sst_hsw_stream_set_channels(hsw, pcm_data->stream, channels);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: could not set channels %d\n",\r\nchannels);\r\nreturn ret;\r\n}\r\nret = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: could not allocate %d bytes for PCM %d\n",\r\nparams_buffer_bytes(params), ret);\r\nreturn ret;\r\n}\r\ndmab = snd_pcm_get_dma_buf(substream);\r\nret = create_adsp_page_table(substream, pdata, rtd, runtime->dma_area,\r\nruntime->dma_bytes, rtd->cpu_dai->id);\r\nif (ret < 0)\r\nreturn ret;\r\nsst_hsw_stream_set_style(hsw, pcm_data->stream,\r\nSST_HSW_INTERLEAVING_PER_CHANNEL);\r\nif (runtime->dma_bytes % PAGE_SIZE)\r\npages = (runtime->dma_bytes / PAGE_SIZE) + 1;\r\nelse\r\npages = runtime->dma_bytes / PAGE_SIZE;\r\nret = sst_hsw_stream_buffer(hsw, pcm_data->stream,\r\npdata->dmab[rtd->cpu_dai->id][substream->stream].addr,\r\npages, runtime->dma_bytes, 0,\r\nsnd_sgbuf_get_addr(dmab, 0) >> PAGE_SHIFT);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: failed to set DMA buffer %d\n", ret);\r\nreturn ret;\r\n}\r\ndsp = sst_hsw_get_dsp(hsw);\r\nmodule_data = sst_module_get_from_id(dsp, module_id);\r\nif (module_data == NULL) {\r\ndev_err(rtd->dev, "error: failed to get module config\n");\r\nreturn -EINVAL;\r\n}\r\nsst_hsw_stream_set_module_info(hsw, pcm_data->stream,\r\npcm_data->runtime);\r\nret = sst_hsw_stream_commit(hsw, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_err(rtd->dev, "error: failed to commit stream %d\n", ret);\r\nreturn ret;\r\n}\r\nif (!pcm_data->allocated) {\r\nsst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,\r\n0, pcm_data->volume[0]);\r\nsst_hsw_stream_set_volume(hsw, pcm_data->stream, 0,\r\n1, pcm_data->volume[1]);\r\npcm_data->allocated = true;\r\n}\r\nret = sst_hsw_stream_pause(hsw, pcm_data->stream, 1);\r\nif (ret < 0)\r\ndev_err(rtd->dev, "error: failed to pause %d\n", ret);\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_hw_free(struct snd_pcm_substream *substream)\r\n{\r\nsnd_pcm_lib_free_pages(substream);\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_trigger(struct snd_pcm_substream *substream, int cmd)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw_stream *sst_stream;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nsnd_pcm_uframes_t pos;\r\nint dai;\r\ndai = mod_map[rtd->cpu_dai->id].dai_id;\r\npcm_data = &pdata->pcm[dai][substream->stream];\r\nsst_stream = pcm_data->stream;\r\nswitch (cmd) {\r\ncase SNDRV_PCM_TRIGGER_START:\r\ncase SNDRV_PCM_TRIGGER_RESUME:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_RELEASE:\r\nsst_hsw_stream_set_silence_start(hsw, sst_stream, false);\r\nsst_hsw_stream_resume(hsw, pcm_data->stream, 0);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_STOP:\r\ncase SNDRV_PCM_TRIGGER_SUSPEND:\r\ncase SNDRV_PCM_TRIGGER_PAUSE_PUSH:\r\nsst_hsw_stream_set_silence_start(hsw, sst_stream, false);\r\nsst_hsw_stream_pause(hsw, pcm_data->stream, 0);\r\nbreak;\r\ncase SNDRV_PCM_TRIGGER_DRAIN:\r\npos = runtime->control->appl_ptr % runtime->buffer_size;\r\nsst_hsw_stream_set_old_position(hsw, pcm_data->stream, pos);\r\nsst_hsw_stream_set_silence_start(hsw, sst_stream, true);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic u32 hsw_notify_pointer(struct sst_hsw_stream *stream, void *data)\r\n{\r\nstruct hsw_pcm_data *pcm_data = data;\r\nstruct snd_pcm_substream *substream = pcm_data->substream;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nu32 pos;\r\nsnd_pcm_uframes_t position = bytes_to_frames(runtime,\r\nsst_hsw_get_dsp_position(hsw, pcm_data->stream));\r\nunsigned char *dma_area = runtime->dma_area;\r\nsnd_pcm_uframes_t dma_frames =\r\nbytes_to_frames(runtime, runtime->dma_bytes);\r\nsnd_pcm_uframes_t old_position;\r\nssize_t samples;\r\npos = frames_to_bytes(runtime,\r\n(runtime->control->appl_ptr % runtime->buffer_size));\r\ndev_vdbg(rtd->dev, "PCM: App pointer %d bytes\n", pos);\r\nif (dma_area == NULL || dma_frames <= 0\r\n|| (substream->stream == SNDRV_PCM_STREAM_CAPTURE)\r\n|| !sst_hsw_stream_get_silence_start(hsw, stream)) {\r\nsnd_pcm_period_elapsed(substream);\r\nreturn pos;\r\n}\r\nold_position = sst_hsw_stream_get_old_position(hsw, stream);\r\nif (position > old_position) {\r\nif (position < dma_frames) {\r\nsamples = SST_SAMPLES(runtime, position - old_position);\r\nsnd_pcm_format_set_silence(runtime->format,\r\nSST_OLD_POSITION(dma_area,\r\nruntime, old_position),\r\nsamples);\r\n} else\r\ndev_err(rtd->dev, "PCM: position is wrong\n");\r\n} else {\r\nif (old_position < dma_frames) {\r\nsamples = SST_SAMPLES(runtime,\r\ndma_frames - old_position);\r\nsnd_pcm_format_set_silence(runtime->format,\r\nSST_OLD_POSITION(dma_area,\r\nruntime, old_position),\r\nsamples);\r\n} else\r\ndev_err(rtd->dev, "PCM: dma_bytes is wrong\n");\r\nif (position < dma_frames) {\r\nsamples = SST_SAMPLES(runtime, position);\r\nsnd_pcm_format_set_silence(runtime->format,\r\ndma_area, samples);\r\n} else\r\ndev_err(rtd->dev, "PCM: position is wrong\n");\r\n}\r\nsst_hsw_stream_set_old_position(hsw, stream, position);\r\nsnd_pcm_period_elapsed(substream);\r\nreturn pos;\r\n}\r\nstatic snd_pcm_uframes_t hsw_pcm_pointer(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct snd_pcm_runtime *runtime = substream->runtime;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nsnd_pcm_uframes_t offset;\r\nuint64_t ppos;\r\nu32 position;\r\nint dai;\r\ndai = mod_map[rtd->cpu_dai->id].dai_id;\r\npcm_data = &pdata->pcm[dai][substream->stream];\r\nposition = sst_hsw_get_dsp_position(hsw, pcm_data->stream);\r\noffset = bytes_to_frames(runtime, position);\r\nppos = sst_hsw_get_dsp_presentation_position(hsw, pcm_data->stream);\r\ndev_vdbg(rtd->dev, "PCM: DMA pointer %du bytes, pos %llu\n",\r\nposition, ppos);\r\nreturn offset;\r\n}\r\nstatic int hsw_pcm_open(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nint dai;\r\ndai = mod_map[rtd->cpu_dai->id].dai_id;\r\npcm_data = &pdata->pcm[dai][substream->stream];\r\nmutex_lock(&pcm_data->mutex);\r\npm_runtime_get_sync(pdata->dev);\r\npcm_data->substream = substream;\r\nsnd_soc_set_runtime_hwparams(substream, &hsw_pcm_hardware);\r\npcm_data->stream = sst_hsw_stream_new(hsw, rtd->cpu_dai->id,\r\nhsw_notify_pointer, pcm_data);\r\nif (pcm_data->stream == NULL) {\r\ndev_err(rtd->dev, "error: failed to create stream\n");\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_close(struct snd_pcm_substream *substream)\r\n{\r\nstruct snd_soc_pcm_runtime *rtd = substream->private_data;\r\nstruct hsw_priv_data *pdata =\r\nsnd_soc_platform_get_drvdata(rtd->platform);\r\nstruct hsw_pcm_data *pcm_data;\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nint ret, dai;\r\ndai = mod_map[rtd->cpu_dai->id].dai_id;\r\npcm_data = &pdata->pcm[dai][substream->stream];\r\nmutex_lock(&pcm_data->mutex);\r\nret = sst_hsw_stream_reset(hsw, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_dbg(rtd->dev, "error: reset stream failed %d\n", ret);\r\ngoto out;\r\n}\r\nret = sst_hsw_stream_free(hsw, pcm_data->stream);\r\nif (ret < 0) {\r\ndev_dbg(rtd->dev, "error: free stream failed %d\n", ret);\r\ngoto out;\r\n}\r\npcm_data->allocated = 0;\r\npcm_data->stream = NULL;\r\nout:\r\npm_runtime_mark_last_busy(pdata->dev);\r\npm_runtime_put_autosuspend(pdata->dev);\r\nmutex_unlock(&pcm_data->mutex);\r\nreturn ret;\r\n}\r\nstatic int hsw_pcm_create_modules(struct hsw_priv_data *pdata)\r\n{\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nstruct hsw_pcm_data *pcm_data;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mod_map); i++) {\r\npcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];\r\npcm_data->runtime = sst_hsw_runtime_module_create(hsw,\r\nmod_map[i].mod_id, pcm_data->persistent_offset);\r\nif (pcm_data->runtime == NULL)\r\ngoto err;\r\npcm_data->persistent_offset =\r\npcm_data->runtime->persistent_offset;\r\n}\r\nif (sst_hsw_is_module_loaded(hsw, SST_HSW_MODULE_WAVES)) {\r\npdata->runtime_waves = sst_hsw_runtime_module_create(hsw,\r\nSST_HSW_MODULE_WAVES, 0);\r\nif (pdata->runtime_waves == NULL)\r\ngoto err;\r\n}\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; i--) {\r\npcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];\r\nsst_hsw_runtime_module_free(pcm_data->runtime);\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic void hsw_pcm_free_modules(struct hsw_priv_data *pdata)\r\n{\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nstruct hsw_pcm_data *pcm_data;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(mod_map); i++) {\r\npcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];\r\nif (pcm_data->runtime){\r\nsst_hsw_runtime_module_free(pcm_data->runtime);\r\npcm_data->runtime = NULL;\r\n}\r\n}\r\nif (sst_hsw_is_module_loaded(hsw, SST_HSW_MODULE_WAVES) &&\r\npdata->runtime_waves) {\r\nsst_hsw_runtime_module_free(pdata->runtime_waves);\r\npdata->runtime_waves = NULL;\r\n}\r\n}\r\nstatic int hsw_pcm_new(struct snd_soc_pcm_runtime *rtd)\r\n{\r\nstruct snd_pcm *pcm = rtd->pcm;\r\nstruct snd_soc_platform *platform = rtd->platform;\r\nstruct sst_pdata *pdata = dev_get_platdata(platform->dev);\r\nstruct hsw_priv_data *priv_data = dev_get_drvdata(platform->dev);\r\nstruct device *dev = pdata->dma_dev;\r\nint ret = 0;\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream ||\r\npcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream) {\r\nret = snd_pcm_lib_preallocate_pages_for_all(pcm,\r\nSNDRV_DMA_TYPE_DEV_SG,\r\ndev,\r\nhsw_pcm_hardware.buffer_bytes_max,\r\nhsw_pcm_hardware.buffer_bytes_max);\r\nif (ret) {\r\ndev_err(rtd->dev, "dma buffer allocation failed %d\n",\r\nret);\r\nreturn ret;\r\n}\r\n}\r\nif (pcm->streams[SNDRV_PCM_STREAM_PLAYBACK].substream)\r\npriv_data->pcm[rtd->cpu_dai->id][SNDRV_PCM_STREAM_PLAYBACK].hsw_pcm = pcm;\r\nif (pcm->streams[SNDRV_PCM_STREAM_CAPTURE].substream)\r\npriv_data->pcm[rtd->cpu_dai->id][SNDRV_PCM_STREAM_CAPTURE].hsw_pcm = pcm;\r\nreturn ret;\r\n}\r\nstatic int hsw_pcm_probe(struct snd_soc_platform *platform)\r\n{\r\nstruct hsw_priv_data *priv_data = snd_soc_platform_get_drvdata(platform);\r\nstruct sst_pdata *pdata = dev_get_platdata(platform->dev);\r\nstruct device *dma_dev, *dev;\r\nint i, ret = 0;\r\nif (!pdata)\r\nreturn -ENODEV;\r\ndev = platform->dev;\r\ndma_dev = pdata->dma_dev;\r\npriv_data->hsw = pdata->dsp;\r\npriv_data->dev = platform->dev;\r\npriv_data->pm_state = HSW_PM_STATE_D0;\r\npriv_data->soc_card = platform->component.card;\r\nfor (i = 0; i < ARRAY_SIZE(hsw_dais); i++) {\r\nif (hsw_dais[i].playback.channels_min) {\r\nmutex_init(&priv_data->pcm[i][SNDRV_PCM_STREAM_PLAYBACK].mutex);\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dma_dev,\r\nPAGE_SIZE, &priv_data->dmab[i][0]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\nif (hsw_dais[i].capture.channels_min) {\r\nmutex_init(&priv_data->pcm[i][SNDRV_PCM_STREAM_CAPTURE].mutex);\r\nret = snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, dma_dev,\r\nPAGE_SIZE, &priv_data->dmab[i][1]);\r\nif (ret < 0)\r\ngoto err;\r\n}\r\n}\r\nret = hsw_pcm_create_modules(priv_data);\r\nif (ret < 0)\r\ngoto err;\r\npm_runtime_set_autosuspend_delay(platform->dev,\r\nSST_RUNTIME_SUSPEND_DELAY);\r\npm_runtime_use_autosuspend(platform->dev);\r\npm_runtime_enable(platform->dev);\r\npm_runtime_idle(platform->dev);\r\nreturn 0;\r\nerr:\r\nfor (--i; i >= 0; i--) {\r\nif (hsw_dais[i].playback.channels_min)\r\nsnd_dma_free_pages(&priv_data->dmab[i][0]);\r\nif (hsw_dais[i].capture.channels_min)\r\nsnd_dma_free_pages(&priv_data->dmab[i][1]);\r\n}\r\nreturn ret;\r\n}\r\nstatic int hsw_pcm_remove(struct snd_soc_platform *platform)\r\n{\r\nstruct hsw_priv_data *priv_data =\r\nsnd_soc_platform_get_drvdata(platform);\r\nint i;\r\npm_runtime_disable(platform->dev);\r\nhsw_pcm_free_modules(priv_data);\r\nfor (i = 0; i < ARRAY_SIZE(hsw_dais); i++) {\r\nif (hsw_dais[i].playback.channels_min)\r\nsnd_dma_free_pages(&priv_data->dmab[i][0]);\r\nif (hsw_dais[i].capture.channels_min)\r\nsnd_dma_free_pages(&priv_data->dmab[i][1]);\r\n}\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_dev_probe(struct platform_device *pdev)\r\n{\r\nstruct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);\r\nstruct hsw_priv_data *priv_data;\r\nint ret;\r\nif (!sst_pdata)\r\nreturn -EINVAL;\r\npriv_data = devm_kzalloc(&pdev->dev, sizeof(*priv_data), GFP_KERNEL);\r\nif (!priv_data)\r\nreturn -ENOMEM;\r\nret = sst_hsw_dsp_init(&pdev->dev, sst_pdata);\r\nif (ret < 0)\r\nreturn -ENODEV;\r\npriv_data->hsw = sst_pdata->dsp;\r\nplatform_set_drvdata(pdev, priv_data);\r\nret = snd_soc_register_platform(&pdev->dev, &hsw_soc_platform);\r\nif (ret < 0)\r\ngoto err_plat;\r\nret = snd_soc_register_component(&pdev->dev, &hsw_dai_component,\r\nhsw_dais, ARRAY_SIZE(hsw_dais));\r\nif (ret < 0)\r\ngoto err_comp;\r\nreturn 0;\r\nerr_comp:\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nerr_plat:\r\nsst_hsw_dsp_free(&pdev->dev, sst_pdata);\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_dev_remove(struct platform_device *pdev)\r\n{\r\nstruct sst_pdata *sst_pdata = dev_get_platdata(&pdev->dev);\r\nsnd_soc_unregister_platform(&pdev->dev);\r\nsnd_soc_unregister_component(&pdev->dev);\r\nsst_hsw_dsp_free(&pdev->dev, sst_pdata);\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_runtime_idle(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_suspend(struct device *dev)\r\n{\r\nstruct hsw_priv_data *pdata = dev_get_drvdata(dev);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nsst_hsw_dsp_runtime_suspend(hsw);\r\nhsw_pcm_free_modules(pdata);\r\nsst_hsw_dsp_runtime_sleep(hsw);\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_runtime_suspend(struct device *dev)\r\n{\r\nstruct hsw_priv_data *pdata = dev_get_drvdata(dev);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nint ret;\r\nif (pdata->pm_state >= HSW_PM_STATE_RTD3)\r\nreturn 0;\r\nif (sst_hsw_is_module_active(hsw, SST_HSW_MODULE_WAVES)) {\r\nret = sst_hsw_module_disable(hsw, SST_HSW_MODULE_WAVES, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nsst_hsw_set_module_enabled_rtd3(hsw, SST_HSW_MODULE_WAVES);\r\n}\r\nhsw_pcm_suspend(dev);\r\npdata->pm_state = HSW_PM_STATE_RTD3;\r\nreturn 0;\r\n}\r\nstatic int hsw_pcm_runtime_resume(struct device *dev)\r\n{\r\nstruct hsw_priv_data *pdata = dev_get_drvdata(dev);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nint ret;\r\nif (pdata->pm_state != HSW_PM_STATE_RTD3)\r\nreturn 0;\r\nret = sst_hsw_dsp_load(hsw);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to reload %d\n", ret);\r\nreturn ret;\r\n}\r\nret = hsw_pcm_create_modules(pdata);\r\nif (ret < 0) {\r\ndev_err(dev, "failed to create modules %d\n", ret);\r\nreturn ret;\r\n}\r\nret = sst_hsw_dsp_runtime_resume(hsw);\r\nif (ret < 0)\r\nreturn ret;\r\nelse if (ret == 1)\r\nreturn 0;\r\nif (sst_hsw_is_module_enabled_rtd3(hsw, SST_HSW_MODULE_WAVES)) {\r\nret = sst_hsw_module_enable(hsw, SST_HSW_MODULE_WAVES, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = sst_hsw_launch_param_buf(hsw);\r\nif (ret < 0)\r\nreturn ret;\r\nsst_hsw_set_module_disabled_rtd3(hsw, SST_HSW_MODULE_WAVES);\r\n}\r\npdata->pm_state = HSW_PM_STATE_D0;\r\nreturn ret;\r\n}\r\nstatic void hsw_pcm_complete(struct device *dev)\r\n{\r\nstruct hsw_priv_data *pdata = dev_get_drvdata(dev);\r\nstruct sst_hsw *hsw = pdata->hsw;\r\nstruct hsw_pcm_data *pcm_data;\r\nint i, err;\r\nif (pdata->pm_state != HSW_PM_STATE_D3)\r\nreturn;\r\nerr = sst_hsw_dsp_load(hsw);\r\nif (err < 0) {\r\ndev_err(dev, "failed to reload %d\n", err);\r\nreturn;\r\n}\r\nerr = hsw_pcm_create_modules(pdata);\r\nif (err < 0) {\r\ndev_err(dev, "failed to create modules %d\n", err);\r\nreturn;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mod_map); i++) {\r\npcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];\r\nif (!pcm_data->substream)\r\ncontinue;\r\nerr = sst_module_runtime_restore(pcm_data->runtime,\r\n&pcm_data->context);\r\nif (err < 0)\r\ndev_err(dev, "failed to restore context for PCM %d\n", i);\r\n}\r\nsnd_soc_resume(pdata->soc_card->dev);\r\nerr = sst_hsw_dsp_runtime_resume(hsw);\r\nif (err < 0)\r\nreturn;\r\nelse if (err == 1)\r\nreturn;\r\npdata->pm_state = HSW_PM_STATE_D0;\r\nreturn;\r\n}\r\nstatic int hsw_pcm_prepare(struct device *dev)\r\n{\r\nstruct hsw_priv_data *pdata = dev_get_drvdata(dev);\r\nstruct hsw_pcm_data *pcm_data;\r\nint i, err;\r\nif (pdata->pm_state == HSW_PM_STATE_D3)\r\nreturn 0;\r\nelse if (pdata->pm_state == HSW_PM_STATE_D0) {\r\nfor (i = 0; i < ARRAY_SIZE(mod_map); i++) {\r\npcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];\r\nif (!pcm_data->substream)\r\ncontinue;\r\ndev_dbg(dev, "suspending pcm %d\n", i);\r\nsnd_pcm_suspend_all(pcm_data->hsw_pcm);\r\nmsleep(2);\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(mod_map); i++) {\r\npcm_data = &pdata->pcm[mod_map[i].dai_id][mod_map[i].stream];\r\nif (!pcm_data->substream)\r\ncontinue;\r\ndev_dbg(dev, "saving context pcm %d\n", i);\r\nerr = sst_module_runtime_save(pcm_data->runtime,\r\n&pcm_data->context);\r\nif (err < 0)\r\ndev_err(dev, "failed to save context for PCM %d\n", i);\r\n}\r\nhsw_pcm_suspend(dev);\r\n}\r\nsnd_soc_suspend(pdata->soc_card->dev);\r\nsnd_soc_poweroff(pdata->soc_card->dev);\r\npdata->pm_state = HSW_PM_STATE_D3;\r\nreturn 0;\r\n}
