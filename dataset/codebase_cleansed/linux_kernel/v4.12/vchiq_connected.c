static void connected_init(void)\r\n{\r\nif (!g_once_init) {\r\nmutex_init(&g_connected_mutex);\r\ng_once_init = 1;\r\n}\r\n}\r\nvoid vchiq_add_connected_callback(VCHIQ_CONNECTED_CALLBACK_T callback)\r\n{\r\nconnected_init();\r\nif (mutex_lock_killable(&g_connected_mutex) != 0)\r\nreturn;\r\nif (g_connected)\r\ncallback();\r\nelse {\r\nif (g_num_deferred_callbacks >= MAX_CALLBACKS)\r\nvchiq_log_error(vchiq_core_log_level,\r\n"There already %d callback registered - "\r\n"please increase MAX_CALLBACKS",\r\ng_num_deferred_callbacks);\r\nelse {\r\ng_deferred_callback[g_num_deferred_callbacks] =\r\ncallback;\r\ng_num_deferred_callbacks++;\r\n}\r\n}\r\nmutex_unlock(&g_connected_mutex);\r\n}\r\nvoid vchiq_call_connected_callbacks(void)\r\n{\r\nint i;\r\nconnected_init();\r\nif (mutex_lock_killable(&g_connected_mutex) != 0)\r\nreturn;\r\nfor (i = 0; i < g_num_deferred_callbacks; i++)\r\ng_deferred_callback[i]();\r\ng_num_deferred_callbacks = 0;\r\ng_connected = 1;\r\nmutex_unlock(&g_connected_mutex);\r\n}
