static inline struct dwc2_hsotg_req *our_req(struct usb_request *req)\r\n{\r\nreturn container_of(req, struct dwc2_hsotg_req, req);\r\n}\r\nstatic inline struct dwc2_hsotg_ep *our_ep(struct usb_ep *ep)\r\n{\r\nreturn container_of(ep, struct dwc2_hsotg_ep, ep);\r\n}\r\nstatic inline struct dwc2_hsotg *to_hsotg(struct usb_gadget *gadget)\r\n{\r\nreturn container_of(gadget, struct dwc2_hsotg, gadget);\r\n}\r\nstatic inline void __orr32(void __iomem *ptr, u32 val)\r\n{\r\ndwc2_writel(dwc2_readl(ptr) | val, ptr);\r\n}\r\nstatic inline void __bic32(void __iomem *ptr, u32 val)\r\n{\r\ndwc2_writel(dwc2_readl(ptr) & ~val, ptr);\r\n}\r\nstatic inline struct dwc2_hsotg_ep *index_to_ep(struct dwc2_hsotg *hsotg,\r\nu32 ep_index, u32 dir_in)\r\n{\r\nif (dir_in)\r\nreturn hsotg->eps_in[ep_index];\r\nelse\r\nreturn hsotg->eps_out[ep_index];\r\n}\r\nstatic inline bool using_dma(struct dwc2_hsotg *hsotg)\r\n{\r\nreturn hsotg->params.g_dma;\r\n}\r\nstatic inline bool using_desc_dma(struct dwc2_hsotg *hsotg)\r\n{\r\nreturn hsotg->params.g_dma_desc;\r\n}\r\nstatic inline void dwc2_gadget_incr_frame_num(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nhs_ep->target_frame += hs_ep->interval;\r\nif (hs_ep->target_frame > DSTS_SOFFN_LIMIT) {\r\nhs_ep->frame_overrun = 1;\r\nhs_ep->target_frame &= DSTS_SOFFN_LIMIT;\r\n} else {\r\nhs_ep->frame_overrun = 0;\r\n}\r\n}\r\nstatic void dwc2_hsotg_en_gsint(struct dwc2_hsotg *hsotg, u32 ints)\r\n{\r\nu32 gsintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\nu32 new_gsintmsk;\r\nnew_gsintmsk = gsintmsk | ints;\r\nif (new_gsintmsk != gsintmsk) {\r\ndev_dbg(hsotg->dev, "gsintmsk now 0x%08x\n", new_gsintmsk);\r\ndwc2_writel(new_gsintmsk, hsotg->regs + GINTMSK);\r\n}\r\n}\r\nstatic void dwc2_hsotg_disable_gsint(struct dwc2_hsotg *hsotg, u32 ints)\r\n{\r\nu32 gsintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\nu32 new_gsintmsk;\r\nnew_gsintmsk = gsintmsk & ~ints;\r\nif (new_gsintmsk != gsintmsk)\r\ndwc2_writel(new_gsintmsk, hsotg->regs + GINTMSK);\r\n}\r\nstatic void dwc2_hsotg_ctrl_epint(struct dwc2_hsotg *hsotg,\r\nunsigned int ep, unsigned int dir_in,\r\nunsigned int en)\r\n{\r\nunsigned long flags;\r\nu32 bit = 1 << ep;\r\nu32 daint;\r\nif (!dir_in)\r\nbit <<= 16;\r\nlocal_irq_save(flags);\r\ndaint = dwc2_readl(hsotg->regs + DAINTMSK);\r\nif (en)\r\ndaint |= bit;\r\nelse\r\ndaint &= ~bit;\r\ndwc2_writel(daint, hsotg->regs + DAINTMSK);\r\nlocal_irq_restore(flags);\r\n}\r\nint dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg)\r\n{\r\nif (hsotg->hw_params.en_multiple_tx_fifo)\r\nreturn (dwc2_readl(hsotg->regs + GHWCFG4) &\r\nGHWCFG4_NUM_IN_EPS_MASK) >> GHWCFG4_NUM_IN_EPS_SHIFT;\r\nelse\r\nreturn hsotg->hw_params.num_dev_perio_in_ep;\r\n}\r\nstatic int dwc2_hsotg_ep_info_size(struct dwc2_hsotg *hsotg)\r\n{\r\nint val = 0;\r\nint i;\r\nu32 ep_dirs;\r\nif (!using_dma(hsotg)) {\r\ndev_dbg(hsotg->dev, "Buffer DMA ep info size 0\n");\r\nreturn 0;\r\n}\r\nep_dirs = hsotg->hw_params.dev_ep_dirs;\r\nfor (i = 0; i <= hsotg->hw_params.num_dev_ep; i++) {\r\nval += ep_dirs & 3 ? 1 : 2;\r\nep_dirs >>= 2;\r\n}\r\nif (using_desc_dma(hsotg))\r\nval = val * 4;\r\nreturn val;\r\n}\r\nint dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg)\r\n{\r\nint ep_info_size;\r\nint addr;\r\nint tx_addr_max;\r\nu32 np_tx_fifo_size;\r\nnp_tx_fifo_size = min_t(u32, hsotg->hw_params.dev_nperio_tx_fifo_size,\r\nhsotg->params.g_np_tx_fifo_size);\r\nep_info_size = dwc2_hsotg_ep_info_size(hsotg);\r\ntx_addr_max = hsotg->hw_params.total_fifo_size - ep_info_size;\r\naddr = hsotg->params.g_rx_fifo_size + np_tx_fifo_size;\r\nif (tx_addr_max <= addr)\r\nreturn 0;\r\nreturn tx_addr_max - addr;\r\n}\r\nint dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg)\r\n{\r\nint tx_fifo_count;\r\nint tx_fifo_depth;\r\ntx_fifo_depth = dwc2_hsotg_tx_fifo_total_depth(hsotg);\r\ntx_fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);\r\nif (!tx_fifo_count)\r\nreturn tx_fifo_depth;\r\nelse\r\nreturn tx_fifo_depth / tx_fifo_count;\r\n}\r\nstatic void dwc2_hsotg_init_fifo(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned int ep;\r\nunsigned int addr;\r\nint timeout;\r\nu32 val;\r\nu32 *txfsz = hsotg->params.g_tx_fifo_size;\r\nWARN_ON(hsotg->fifo_map);\r\nhsotg->fifo_map = 0;\r\ndwc2_writel(hsotg->params.g_rx_fifo_size, hsotg->regs + GRXFSIZ);\r\ndwc2_writel((hsotg->params.g_rx_fifo_size << FIFOSIZE_STARTADDR_SHIFT) |\r\n(hsotg->params.g_np_tx_fifo_size << FIFOSIZE_DEPTH_SHIFT),\r\nhsotg->regs + GNPTXFSIZ);\r\naddr = hsotg->params.g_rx_fifo_size + hsotg->params.g_np_tx_fifo_size;\r\nfor (ep = 1; ep < MAX_EPS_CHANNELS; ep++) {\r\nif (!txfsz[ep])\r\ncontinue;\r\nval = addr;\r\nval |= txfsz[ep] << FIFOSIZE_DEPTH_SHIFT;\r\nWARN_ONCE(addr + txfsz[ep] > hsotg->fifo_mem,\r\n"insufficient fifo memory");\r\naddr += txfsz[ep];\r\ndwc2_writel(val, hsotg->regs + DPTXFSIZN(ep));\r\nval = dwc2_readl(hsotg->regs + DPTXFSIZN(ep));\r\n}\r\ndwc2_writel(hsotg->hw_params.total_fifo_size |\r\naddr << GDFIFOCFG_EPINFOBASE_SHIFT,\r\nhsotg->regs + GDFIFOCFG);\r\ndwc2_writel(GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |\r\nGRSTCTL_RXFFLSH, hsotg->regs + GRSTCTL);\r\ntimeout = 100;\r\nwhile (1) {\r\nval = dwc2_readl(hsotg->regs + GRSTCTL);\r\nif ((val & (GRSTCTL_TXFFLSH | GRSTCTL_RXFFLSH)) == 0)\r\nbreak;\r\nif (--timeout == 0) {\r\ndev_err(hsotg->dev,\r\n"%s: timeout flushing fifos (GRSTCTL=%08x)\n",\r\n__func__, val);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\ndev_dbg(hsotg->dev, "FIFOs reset, timeout at %d\n", timeout);\r\n}\r\nstatic struct usb_request *dwc2_hsotg_ep_alloc_request(struct usb_ep *ep,\r\ngfp_t flags)\r\n{\r\nstruct dwc2_hsotg_req *req;\r\nreq = kzalloc(sizeof(*req), flags);\r\nif (!req)\r\nreturn NULL;\r\nINIT_LIST_HEAD(&req->queue);\r\nreturn &req->req;\r\n}\r\nstatic inline int is_ep_periodic(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nreturn hs_ep->periodic;\r\n}\r\nstatic void dwc2_hsotg_unmap_dma(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct dwc2_hsotg_req *hs_req)\r\n{\r\nstruct usb_request *req = &hs_req->req;\r\nusb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->dir_in);\r\n}\r\nstatic int dwc2_gadget_alloc_ctrl_desc_chains(struct dwc2_hsotg *hsotg)\r\n{\r\nhsotg->setup_desc[0] =\r\ndmam_alloc_coherent(hsotg->dev,\r\nsizeof(struct dwc2_dma_desc),\r\n&hsotg->setup_desc_dma[0],\r\nGFP_KERNEL);\r\nif (!hsotg->setup_desc[0])\r\ngoto fail;\r\nhsotg->setup_desc[1] =\r\ndmam_alloc_coherent(hsotg->dev,\r\nsizeof(struct dwc2_dma_desc),\r\n&hsotg->setup_desc_dma[1],\r\nGFP_KERNEL);\r\nif (!hsotg->setup_desc[1])\r\ngoto fail;\r\nhsotg->ctrl_in_desc =\r\ndmam_alloc_coherent(hsotg->dev,\r\nsizeof(struct dwc2_dma_desc),\r\n&hsotg->ctrl_in_desc_dma,\r\nGFP_KERNEL);\r\nif (!hsotg->ctrl_in_desc)\r\ngoto fail;\r\nhsotg->ctrl_out_desc =\r\ndmam_alloc_coherent(hsotg->dev,\r\nsizeof(struct dwc2_dma_desc),\r\n&hsotg->ctrl_out_desc_dma,\r\nGFP_KERNEL);\r\nif (!hsotg->ctrl_out_desc)\r\ngoto fail;\r\nreturn 0;\r\nfail:\r\nreturn -ENOMEM;\r\n}\r\nstatic int dwc2_hsotg_write_fifo(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct dwc2_hsotg_req *hs_req)\r\n{\r\nbool periodic = is_ep_periodic(hs_ep);\r\nu32 gnptxsts = dwc2_readl(hsotg->regs + GNPTXSTS);\r\nint buf_pos = hs_req->req.actual;\r\nint to_write = hs_ep->size_loaded;\r\nvoid *data;\r\nint can_write;\r\nint pkt_round;\r\nint max_transfer;\r\nto_write -= (buf_pos - hs_ep->last_load);\r\nif (to_write == 0)\r\nreturn 0;\r\nif (periodic && !hsotg->dedicated_fifos) {\r\nu32 epsize = dwc2_readl(hsotg->regs + DIEPTSIZ(hs_ep->index));\r\nint size_left;\r\nint size_done;\r\nsize_left = DXEPTSIZ_XFERSIZE_GET(epsize);\r\nif (hs_ep->fifo_load != 0) {\r\ndwc2_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);\r\nreturn -ENOSPC;\r\n}\r\ndev_dbg(hsotg->dev, "%s: left=%d, load=%d, fifo=%d, size %d\n",\r\n__func__, size_left,\r\nhs_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);\r\nsize_done = hs_ep->size_loaded - size_left;\r\ncan_write = hs_ep->fifo_load - size_done;\r\ndev_dbg(hsotg->dev, "%s: => can_write1=%d\n",\r\n__func__, can_write);\r\ncan_write = hs_ep->fifo_size - can_write;\r\ndev_dbg(hsotg->dev, "%s: => can_write2=%d\n",\r\n__func__, can_write);\r\nif (can_write <= 0) {\r\ndwc2_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);\r\nreturn -ENOSPC;\r\n}\r\n} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {\r\ncan_write = dwc2_readl(hsotg->regs +\r\nDTXFSTS(hs_ep->fifo_index));\r\ncan_write &= 0xffff;\r\ncan_write *= 4;\r\n} else {\r\nif (GNPTXSTS_NP_TXQ_SPC_AVAIL_GET(gnptxsts) == 0) {\r\ndev_dbg(hsotg->dev,\r\n"%s: no queue slots available (0x%08x)\n",\r\n__func__, gnptxsts);\r\ndwc2_hsotg_en_gsint(hsotg, GINTSTS_NPTXFEMP);\r\nreturn -ENOSPC;\r\n}\r\ncan_write = GNPTXSTS_NP_TXF_SPC_AVAIL_GET(gnptxsts);\r\ncan_write *= 4;\r\n}\r\nmax_transfer = hs_ep->ep.maxpacket * hs_ep->mc;\r\ndev_dbg(hsotg->dev, "%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\n",\r\n__func__, gnptxsts, can_write, to_write, max_transfer);\r\nif (can_write > 512 && !periodic)\r\ncan_write = 512;\r\nif (to_write > max_transfer) {\r\nto_write = max_transfer;\r\nif (!hsotg->dedicated_fifos)\r\ndwc2_hsotg_en_gsint(hsotg,\r\nperiodic ? GINTSTS_PTXFEMP :\r\nGINTSTS_NPTXFEMP);\r\n}\r\nif (to_write > can_write) {\r\nto_write = can_write;\r\npkt_round = to_write % max_transfer;\r\nif (pkt_round)\r\nto_write -= pkt_round;\r\nif (!hsotg->dedicated_fifos)\r\ndwc2_hsotg_en_gsint(hsotg,\r\nperiodic ? GINTSTS_PTXFEMP :\r\nGINTSTS_NPTXFEMP);\r\n}\r\ndev_dbg(hsotg->dev, "write %d/%d, can_write %d, done %d\n",\r\nto_write, hs_req->req.length, can_write, buf_pos);\r\nif (to_write <= 0)\r\nreturn -ENOSPC;\r\nhs_req->req.actual = buf_pos + to_write;\r\nhs_ep->total_data += to_write;\r\nif (periodic)\r\nhs_ep->fifo_load += to_write;\r\nto_write = DIV_ROUND_UP(to_write, 4);\r\ndata = hs_req->req.buf + buf_pos;\r\niowrite32_rep(hsotg->regs + EPFIFO(hs_ep->index), data, to_write);\r\nreturn (to_write >= can_write) ? -ENOSPC : 0;\r\n}\r\nstatic unsigned int get_ep_limit(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nint index = hs_ep->index;\r\nunsigned int maxsize;\r\nunsigned int maxpkt;\r\nif (index != 0) {\r\nmaxsize = DXEPTSIZ_XFERSIZE_LIMIT + 1;\r\nmaxpkt = DXEPTSIZ_PKTCNT_LIMIT + 1;\r\n} else {\r\nmaxsize = 64 + 64;\r\nif (hs_ep->dir_in)\r\nmaxpkt = DIEPTSIZ0_PKTCNT_LIMIT + 1;\r\nelse\r\nmaxpkt = 2;\r\n}\r\nmaxpkt--;\r\nmaxsize--;\r\nif ((maxpkt * hs_ep->ep.maxpacket) < maxsize)\r\nmaxsize = maxpkt * hs_ep->ep.maxpacket;\r\nreturn maxsize;\r\n}\r\nstatic u32 dwc2_hsotg_read_frameno(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 dsts;\r\ndsts = dwc2_readl(hsotg->regs + DSTS);\r\ndsts &= DSTS_SOFFN_MASK;\r\ndsts >>= DSTS_SOFFN_SHIFT;\r\nreturn dsts;\r\n}\r\nstatic unsigned int dwc2_gadget_get_chain_limit(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nint is_isoc = hs_ep->isochronous;\r\nunsigned int maxsize;\r\nif (is_isoc)\r\nmaxsize = hs_ep->dir_in ? DEV_DMA_ISOC_TX_NBYTES_LIMIT :\r\nDEV_DMA_ISOC_RX_NBYTES_LIMIT;\r\nelse\r\nmaxsize = DEV_DMA_NBYTES_LIMIT;\r\nmaxsize *= MAX_DMA_DESC_NUM_GENERIC;\r\nreturn maxsize;\r\n}\r\nstatic u32 dwc2_gadget_get_desc_params(struct dwc2_hsotg_ep *hs_ep, u32 *mask)\r\n{\r\nu32 mps = hs_ep->ep.maxpacket;\r\nint dir_in = hs_ep->dir_in;\r\nu32 desc_size = 0;\r\nif (!hs_ep->index && !dir_in) {\r\ndesc_size = mps;\r\n*mask = DEV_DMA_NBYTES_MASK;\r\n} else if (hs_ep->isochronous) {\r\nif (dir_in) {\r\ndesc_size = DEV_DMA_ISOC_TX_NBYTES_LIMIT;\r\n*mask = DEV_DMA_ISOC_TX_NBYTES_MASK;\r\n} else {\r\ndesc_size = DEV_DMA_ISOC_RX_NBYTES_LIMIT;\r\n*mask = DEV_DMA_ISOC_RX_NBYTES_MASK;\r\n}\r\n} else {\r\ndesc_size = DEV_DMA_NBYTES_LIMIT;\r\n*mask = DEV_DMA_NBYTES_MASK;\r\ndesc_size -= desc_size % mps;\r\n}\r\nreturn desc_size;\r\n}\r\nstatic void dwc2_gadget_config_nonisoc_xfer_ddma(struct dwc2_hsotg_ep *hs_ep,\r\ndma_addr_t dma_buff,\r\nunsigned int len)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nint dir_in = hs_ep->dir_in;\r\nstruct dwc2_dma_desc *desc = hs_ep->desc_list;\r\nu32 mps = hs_ep->ep.maxpacket;\r\nu32 maxsize = 0;\r\nu32 offset = 0;\r\nu32 mask = 0;\r\nint i;\r\nmaxsize = dwc2_gadget_get_desc_params(hs_ep, &mask);\r\nhs_ep->desc_count = (len / maxsize) +\r\n((len % maxsize) ? 1 : 0);\r\nif (len == 0)\r\nhs_ep->desc_count = 1;\r\nfor (i = 0; i < hs_ep->desc_count; ++i) {\r\ndesc->status = 0;\r\ndesc->status |= (DEV_DMA_BUFF_STS_HBUSY\r\n<< DEV_DMA_BUFF_STS_SHIFT);\r\nif (len > maxsize) {\r\nif (!hs_ep->index && !dir_in)\r\ndesc->status |= (DEV_DMA_L | DEV_DMA_IOC);\r\ndesc->status |= (maxsize <<\r\nDEV_DMA_NBYTES_SHIFT & mask);\r\ndesc->buf = dma_buff + offset;\r\nlen -= maxsize;\r\noffset += maxsize;\r\n} else {\r\ndesc->status |= (DEV_DMA_L | DEV_DMA_IOC);\r\nif (dir_in)\r\ndesc->status |= (len % mps) ? DEV_DMA_SHORT :\r\n((hs_ep->send_zlp) ? DEV_DMA_SHORT : 0);\r\nif (len > maxsize)\r\ndev_err(hsotg->dev, "wrong len %d\n", len);\r\ndesc->status |=\r\nlen << DEV_DMA_NBYTES_SHIFT & mask;\r\ndesc->buf = dma_buff + offset;\r\n}\r\ndesc->status &= ~DEV_DMA_BUFF_STS_MASK;\r\ndesc->status |= (DEV_DMA_BUFF_STS_HREADY\r\n<< DEV_DMA_BUFF_STS_SHIFT);\r\ndesc++;\r\n}\r\n}\r\nstatic int dwc2_gadget_fill_isoc_desc(struct dwc2_hsotg_ep *hs_ep,\r\ndma_addr_t dma_buff, unsigned int len)\r\n{\r\nstruct dwc2_dma_desc *desc;\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nu32 index;\r\nu32 maxsize = 0;\r\nu32 mask = 0;\r\nmaxsize = dwc2_gadget_get_desc_params(hs_ep, &mask);\r\nif (len > maxsize) {\r\ndev_err(hsotg->dev, "wrong len %d\n", len);\r\nreturn -EINVAL;\r\n}\r\nif (hs_ep->next_desc == MAX_DMA_DESC_NUM_GENERIC / 2)\r\nreturn -EBUSY;\r\nif (hs_ep->dir_in)\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\nindex = (MAX_DMA_DESC_NUM_GENERIC / 2) * hs_ep->isoc_chain_num +\r\nhs_ep->next_desc;\r\nif ((hs_ep->isoc_chain_num && index > MAX_DMA_DESC_NUM_GENERIC) ||\r\n(!hs_ep->isoc_chain_num && index > MAX_DMA_DESC_NUM_GENERIC / 2)) {\r\ndev_err(hsotg->dev, "wrong index %d for iso chain\n", index);\r\nreturn -EINVAL;\r\n}\r\ndesc = &hs_ep->desc_list[index];\r\nif (hs_ep->next_desc)\r\nhs_ep->desc_list[index - 1].status &= ~DEV_DMA_L;\r\ndev_dbg(hsotg->dev, "%s: Filling ep %d, dir %s isoc desc # %d\n",\r\n__func__, hs_ep->index, hs_ep->dir_in ? "in" : "out", index);\r\ndesc->status = 0;\r\ndesc->status |= (DEV_DMA_BUFF_STS_HBUSY << DEV_DMA_BUFF_STS_SHIFT);\r\ndesc->buf = dma_buff;\r\ndesc->status |= (DEV_DMA_L | DEV_DMA_IOC |\r\n((len << DEV_DMA_NBYTES_SHIFT) & mask));\r\nif (hs_ep->dir_in) {\r\ndesc->status |= ((hs_ep->mc << DEV_DMA_ISOC_PID_SHIFT) &\r\nDEV_DMA_ISOC_PID_MASK) |\r\n((len % hs_ep->ep.maxpacket) ?\r\nDEV_DMA_SHORT : 0) |\r\n((hs_ep->target_frame <<\r\nDEV_DMA_ISOC_FRNUM_SHIFT) &\r\nDEV_DMA_ISOC_FRNUM_MASK);\r\n}\r\ndesc->status &= ~DEV_DMA_BUFF_STS_MASK;\r\ndesc->status |= (DEV_DMA_BUFF_STS_HREADY << DEV_DMA_BUFF_STS_SHIFT);\r\nhs_ep->next_desc++;\r\nreturn 0;\r\n}\r\nstatic void dwc2_gadget_start_isoc_ddma(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nstruct dwc2_hsotg_req *hs_req, *treq;\r\nint index = hs_ep->index;\r\nint ret;\r\nu32 dma_reg;\r\nu32 depctl;\r\nu32 ctrl;\r\nif (list_empty(&hs_ep->queue)) {\r\ndev_dbg(hsotg->dev, "%s: No requests in queue\n", __func__);\r\nreturn;\r\n}\r\nlist_for_each_entry_safe(hs_req, treq, &hs_ep->queue, queue) {\r\nret = dwc2_gadget_fill_isoc_desc(hs_ep, hs_req->req.dma,\r\nhs_req->req.length);\r\nif (ret) {\r\ndev_dbg(hsotg->dev, "%s: desc chain full\n", __func__);\r\nbreak;\r\n}\r\n}\r\ndepctl = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\ndma_reg = hs_ep->dir_in ? DIEPDMA(index) : DOEPDMA(index);\r\ndwc2_writel(hs_ep->desc_list_dma, hsotg->regs + dma_reg);\r\nctrl = dwc2_readl(hsotg->regs + depctl);\r\nctrl |= DXEPCTL_EPENA | DXEPCTL_CNAK;\r\ndwc2_writel(ctrl, hsotg->regs + depctl);\r\nhs_ep->isoc_chain_num = (hs_ep->isoc_chain_num ^ 1) & 0x1;\r\nhs_ep->next_desc = 0;\r\n}\r\nstatic void dwc2_hsotg_start_req(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct dwc2_hsotg_req *hs_req,\r\nbool continuing)\r\n{\r\nstruct usb_request *ureq = &hs_req->req;\r\nint index = hs_ep->index;\r\nint dir_in = hs_ep->dir_in;\r\nu32 epctrl_reg;\r\nu32 epsize_reg;\r\nu32 epsize;\r\nu32 ctrl;\r\nunsigned int length;\r\nunsigned int packets;\r\nunsigned int maxreq;\r\nunsigned int dma_reg;\r\nif (index != 0) {\r\nif (hs_ep->req && !continuing) {\r\ndev_err(hsotg->dev, "%s: active request\n", __func__);\r\nWARN_ON(1);\r\nreturn;\r\n} else if (hs_ep->req != hs_req && continuing) {\r\ndev_err(hsotg->dev,\r\n"%s: continue different req\n", __func__);\r\nWARN_ON(1);\r\nreturn;\r\n}\r\n}\r\ndma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nepsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x, ep %d, dir %s\n",\r\n__func__, dwc2_readl(hsotg->regs + epctrl_reg), index,\r\nhs_ep->dir_in ? "in" : "out");\r\nctrl = dwc2_readl(hsotg->regs + epctrl_reg);\r\nif (index && ctrl & DXEPCTL_STALL) {\r\ndev_warn(hsotg->dev, "%s: ep%d is stalled\n", __func__, index);\r\nreturn;\r\n}\r\nlength = ureq->length - ureq->actual;\r\ndev_dbg(hsotg->dev, "ureq->length:%d ureq->actual:%d\n",\r\nureq->length, ureq->actual);\r\nif (!using_desc_dma(hsotg))\r\nmaxreq = get_ep_limit(hs_ep);\r\nelse\r\nmaxreq = dwc2_gadget_get_chain_limit(hs_ep);\r\nif (length > maxreq) {\r\nint round = maxreq % hs_ep->ep.maxpacket;\r\ndev_dbg(hsotg->dev, "%s: length %d, max-req %d, r %d\n",\r\n__func__, length, maxreq, round);\r\nif (round)\r\nmaxreq -= round;\r\nlength = maxreq;\r\n}\r\nif (length)\r\npackets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);\r\nelse\r\npackets = 1;\r\nif (hs_ep->isochronous && length > (hs_ep->mc * hs_ep->ep.maxpacket)) {\r\ndev_err(hsotg->dev, "req length > maxpacket*mc\n");\r\nreturn;\r\n}\r\nif (dir_in && index != 0)\r\nif (hs_ep->isochronous)\r\nepsize = DXEPTSIZ_MC(packets);\r\nelse\r\nepsize = DXEPTSIZ_MC(1);\r\nelse\r\nepsize = 0;\r\nif (dir_in && ureq->zero && !continuing) {\r\nif ((ureq->length >= hs_ep->ep.maxpacket) &&\r\n!(ureq->length % hs_ep->ep.maxpacket))\r\nhs_ep->send_zlp = 1;\r\n}\r\nepsize |= DXEPTSIZ_PKTCNT(packets);\r\nepsize |= DXEPTSIZ_XFERSIZE(length);\r\ndev_dbg(hsotg->dev, "%s: %d@%d/%d, 0x%08x => 0x%08x\n",\r\n__func__, packets, length, ureq->length, epsize, epsize_reg);\r\nhs_ep->req = hs_req;\r\nif (using_desc_dma(hsotg)) {\r\nu32 offset = 0;\r\nu32 mps = hs_ep->ep.maxpacket;\r\nif (!dir_in) {\r\nif (!index)\r\nlength = mps;\r\nelse if (length % mps)\r\nlength += (mps - (length % mps));\r\n}\r\nif (!index && hsotg->ep0_state == DWC2_EP0_DATA_OUT &&\r\ncontinuing)\r\noffset = ureq->actual;\r\ndwc2_gadget_config_nonisoc_xfer_ddma(hs_ep, ureq->dma + offset,\r\nlength);\r\ndwc2_writel(hs_ep->desc_list_dma, hsotg->regs + dma_reg);\r\ndev_dbg(hsotg->dev, "%s: %08x pad => 0x%08x\n",\r\n__func__, (u32)hs_ep->desc_list_dma, dma_reg);\r\n} else {\r\ndwc2_writel(epsize, hsotg->regs + epsize_reg);\r\nif (using_dma(hsotg) && !continuing && (length != 0)) {\r\ndwc2_writel(ureq->dma, hsotg->regs + dma_reg);\r\ndev_dbg(hsotg->dev, "%s: %pad => 0x%08x\n",\r\n__func__, &ureq->dma, dma_reg);\r\n}\r\n}\r\nif (hs_ep->isochronous && hs_ep->interval == 1) {\r\nhs_ep->target_frame = dwc2_hsotg_read_frameno(hsotg);\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\nif (hs_ep->target_frame & 0x1)\r\nctrl |= DXEPCTL_SETODDFR;\r\nelse\r\nctrl |= DXEPCTL_SETEVENFR;\r\n}\r\nctrl |= DXEPCTL_EPENA;\r\ndev_dbg(hsotg->dev, "ep0 state:%d\n", hsotg->ep0_state);\r\nif (!(index == 0 && hsotg->ep0_state == DWC2_EP0_SETUP))\r\nctrl |= DXEPCTL_CNAK;\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);\r\ndwc2_writel(ctrl, hsotg->regs + epctrl_reg);\r\nhs_ep->size_loaded = length;\r\nhs_ep->last_load = ureq->actual;\r\nif (dir_in && !using_dma(hsotg)) {\r\nhs_ep->fifo_load = 0;\r\ndwc2_hsotg_write_fifo(hsotg, hs_ep, hs_req);\r\n}\r\nif (!(dwc2_readl(hsotg->regs + epctrl_reg) & DXEPCTL_EPENA))\r\ndev_dbg(hsotg->dev,\r\n"ep%d: failed to become enabled (DXEPCTL=0x%08x)?\n",\r\nindex, dwc2_readl(hsotg->regs + epctrl_reg));\r\ndev_dbg(hsotg->dev, "%s: DXEPCTL=0x%08x\n",\r\n__func__, dwc2_readl(hsotg->regs + epctrl_reg));\r\ndwc2_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);\r\n}\r\nstatic int dwc2_hsotg_map_dma(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct usb_request *req)\r\n{\r\nint ret;\r\nret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);\r\nif (ret)\r\ngoto dma_error;\r\nreturn 0;\r\ndma_error:\r\ndev_err(hsotg->dev, "%s: failed to map buffer %p, %d bytes\n",\r\n__func__, req->buf, req->length);\r\nreturn -EIO;\r\n}\r\nstatic int dwc2_hsotg_handle_unaligned_buf_start(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct dwc2_hsotg_req *hs_req)\r\n{\r\nvoid *req_buf = hs_req->req.buf;\r\nif (!using_dma(hsotg) || !((long)req_buf & 3))\r\nreturn 0;\r\nWARN_ON(hs_req->saved_req_buf);\r\ndev_dbg(hsotg->dev, "%s: %s: buf=%p length=%d\n", __func__,\r\nhs_ep->ep.name, req_buf, hs_req->req.length);\r\nhs_req->req.buf = kmalloc(hs_req->req.length, GFP_ATOMIC);\r\nif (!hs_req->req.buf) {\r\nhs_req->req.buf = req_buf;\r\ndev_err(hsotg->dev,\r\n"%s: unable to allocate memory for bounce buffer\n",\r\n__func__);\r\nreturn -ENOMEM;\r\n}\r\nhs_req->saved_req_buf = req_buf;\r\nif (hs_ep->dir_in)\r\nmemcpy(hs_req->req.buf, req_buf, hs_req->req.length);\r\nreturn 0;\r\n}\r\nstatic void\r\ndwc2_hsotg_handle_unaligned_buf_complete(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct dwc2_hsotg_req *hs_req)\r\n{\r\nif (!using_dma(hsotg) || !hs_req->saved_req_buf)\r\nreturn;\r\ndev_dbg(hsotg->dev, "%s: %s: status=%d actual-length=%d\n", __func__,\r\nhs_ep->ep.name, hs_req->req.status, hs_req->req.actual);\r\nif (!hs_ep->dir_in && !hs_req->req.status)\r\nmemcpy(hs_req->saved_req_buf, hs_req->req.buf,\r\nhs_req->req.actual);\r\nkfree(hs_req->req.buf);\r\nhs_req->req.buf = hs_req->saved_req_buf;\r\nhs_req->saved_req_buf = NULL;\r\n}\r\nstatic bool dwc2_gadget_target_frame_elapsed(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nu32 target_frame = hs_ep->target_frame;\r\nu32 current_frame = dwc2_hsotg_read_frameno(hsotg);\r\nbool frame_overrun = hs_ep->frame_overrun;\r\nif (!frame_overrun && current_frame >= target_frame)\r\nreturn true;\r\nif (frame_overrun && current_frame >= target_frame &&\r\n((current_frame - target_frame) < DSTS_SOFFN_LIMIT / 2))\r\nreturn true;\r\nreturn false;\r\n}\r\nstatic int dwc2_gadget_set_ep0_desc_chain(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep)\r\n{\r\nswitch (hsotg->ep0_state) {\r\ncase DWC2_EP0_SETUP:\r\ncase DWC2_EP0_STATUS_OUT:\r\nhs_ep->desc_list = hsotg->setup_desc[0];\r\nhs_ep->desc_list_dma = hsotg->setup_desc_dma[0];\r\nbreak;\r\ncase DWC2_EP0_DATA_IN:\r\ncase DWC2_EP0_STATUS_IN:\r\nhs_ep->desc_list = hsotg->ctrl_in_desc;\r\nhs_ep->desc_list_dma = hsotg->ctrl_in_desc_dma;\r\nbreak;\r\ncase DWC2_EP0_DATA_OUT:\r\nhs_ep->desc_list = hsotg->ctrl_out_desc;\r\nhs_ep->desc_list_dma = hsotg->ctrl_out_desc_dma;\r\nbreak;\r\ndefault:\r\ndev_err(hsotg->dev, "invalid EP 0 state in queue %d\n",\r\nhsotg->ep0_state);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct dwc2_hsotg_req *hs_req = our_req(req);\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nbool first;\r\nint ret;\r\ndev_dbg(hs->dev, "%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\n",\r\nep->name, req, req->length, req->buf, req->no_interrupt,\r\nreq->zero, req->short_not_ok);\r\nif (hs->lx_state == DWC2_L2) {\r\ndev_dbg(hs->dev, "%s: don't submit request while suspended\n",\r\n__func__);\r\nreturn -EAGAIN;\r\n}\r\nINIT_LIST_HEAD(&hs_req->queue);\r\nreq->actual = 0;\r\nreq->status = -EINPROGRESS;\r\nret = dwc2_hsotg_handle_unaligned_buf_start(hs, hs_ep, hs_req);\r\nif (ret)\r\nreturn ret;\r\nif (using_dma(hs)) {\r\nret = dwc2_hsotg_map_dma(hs, hs_ep, req);\r\nif (ret)\r\nreturn ret;\r\n}\r\nif (using_desc_dma(hs) && !hs_ep->index) {\r\nret = dwc2_gadget_set_ep0_desc_chain(hs, hs_ep);\r\nif (ret)\r\nreturn ret;\r\n}\r\nfirst = list_empty(&hs_ep->queue);\r\nlist_add_tail(&hs_req->queue, &hs_ep->queue);\r\nif (using_desc_dma(hs) && hs_ep->isochronous &&\r\nhs_ep->target_frame != TARGET_FRAME_INITIAL) {\r\nret = dwc2_gadget_fill_isoc_desc(hs_ep, hs_req->req.dma,\r\nhs_req->req.length);\r\nif (ret)\r\ndev_dbg(hs->dev, "%s: ISO desc chain full\n", __func__);\r\nreturn 0;\r\n}\r\nif (first) {\r\nif (!hs_ep->isochronous) {\r\ndwc2_hsotg_start_req(hs, hs_ep, hs_req, false);\r\nreturn 0;\r\n}\r\nwhile (dwc2_gadget_target_frame_elapsed(hs_ep))\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\nif (hs_ep->target_frame != TARGET_FRAME_INITIAL)\r\ndwc2_hsotg_start_req(hs, hs_ep, hs_req, false);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,\r\ngfp_t gfp_flags)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&hs->lock, flags);\r\nret = dwc2_hsotg_ep_queue(ep, req, gfp_flags);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void dwc2_hsotg_ep_free_request(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct dwc2_hsotg_req *hs_req = our_req(req);\r\nkfree(hs_req);\r\n}\r\nstatic void dwc2_hsotg_complete_oursetup(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\ndev_dbg(hsotg->dev, "%s: ep %p, req %p\n", __func__, ep, req);\r\ndwc2_hsotg_ep_free_request(ep, req);\r\n}\r\nstatic struct dwc2_hsotg_ep *ep_from_windex(struct dwc2_hsotg *hsotg,\r\nu32 windex)\r\n{\r\nstruct dwc2_hsotg_ep *ep;\r\nint dir = (windex & USB_DIR_IN) ? 1 : 0;\r\nint idx = windex & 0x7F;\r\nif (windex >= 0x100)\r\nreturn NULL;\r\nif (idx > hsotg->num_of_eps)\r\nreturn NULL;\r\nep = index_to_ep(hsotg, idx, dir);\r\nif (idx && ep->dir_in != dir)\r\nreturn NULL;\r\nreturn ep;\r\n}\r\nint dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg, int testmode)\r\n{\r\nint dctl = dwc2_readl(hsotg->regs + DCTL);\r\ndctl &= ~DCTL_TSTCTL_MASK;\r\nswitch (testmode) {\r\ncase TEST_J:\r\ncase TEST_K:\r\ncase TEST_SE0_NAK:\r\ncase TEST_PACKET:\r\ncase TEST_FORCE_EN:\r\ndctl |= testmode << DCTL_TSTCTL_SHIFT;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndwc2_writel(dctl, hsotg->regs + DCTL);\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_send_reply(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *ep,\r\nvoid *buff,\r\nint length)\r\n{\r\nstruct usb_request *req;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: buff %p, len %d\n", __func__, buff, length);\r\nreq = dwc2_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);\r\nhsotg->ep0_reply = req;\r\nif (!req) {\r\ndev_warn(hsotg->dev, "%s: cannot alloc req\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nreq->buf = hsotg->ep0_buff;\r\nreq->length = length;\r\nreq->zero = 0;\r\nreq->complete = dwc2_hsotg_complete_oursetup;\r\nif (length)\r\nmemcpy(req->buf, buff, length);\r\nret = dwc2_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);\r\nif (ret) {\r\ndev_warn(hsotg->dev, "%s: cannot queue req\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_process_req_status(struct dwc2_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nstruct dwc2_hsotg_ep *ep;\r\n__le16 reply;\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: USB_REQ_GET_STATUS\n", __func__);\r\nif (!ep0->dir_in) {\r\ndev_warn(hsotg->dev, "%s: direction out?\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nswitch (ctrl->bRequestType & USB_RECIP_MASK) {\r\ncase USB_RECIP_DEVICE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_INTERFACE:\r\nreply = cpu_to_le16(0);\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));\r\nif (!ep)\r\nreturn -ENOENT;\r\nreply = cpu_to_le16(ep->halted ? 1 : 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (le16_to_cpu(ctrl->wLength) != 2)\r\nreturn -EINVAL;\r\nret = dwc2_hsotg_send_reply(hsotg, ep0, &reply, 2);\r\nif (ret) {\r\ndev_err(hsotg->dev, "%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nreturn 1;\r\n}\r\nstatic struct dwc2_hsotg_req *get_ep_head(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nreturn list_first_entry_or_null(&hs_ep->queue, struct dwc2_hsotg_req,\r\nqueue);\r\n}\r\nstatic void dwc2_gadget_start_next_request(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nu32 mask;\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nint dir_in = hs_ep->dir_in;\r\nstruct dwc2_hsotg_req *hs_req;\r\nu32 epmsk_reg = dir_in ? DIEPMSK : DOEPMSK;\r\nif (!list_empty(&hs_ep->queue)) {\r\nhs_req = get_ep_head(hs_ep);\r\ndwc2_hsotg_start_req(hsotg, hs_ep, hs_req, false);\r\nreturn;\r\n}\r\nif (!hs_ep->isochronous)\r\nreturn;\r\nif (dir_in) {\r\ndev_dbg(hsotg->dev, "%s: No more ISOC-IN requests\n",\r\n__func__);\r\n} else {\r\ndev_dbg(hsotg->dev, "%s: No more ISOC-OUT requests\n",\r\n__func__);\r\nmask = dwc2_readl(hsotg->regs + epmsk_reg);\r\nmask |= DOEPMSK_OUTTKNEPDISMSK;\r\ndwc2_writel(mask, hsotg->regs + epmsk_reg);\r\n}\r\n}\r\nstatic int dwc2_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nstruct dwc2_hsotg_req *hs_req;\r\nbool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);\r\nstruct dwc2_hsotg_ep *ep;\r\nint ret;\r\nbool halted;\r\nu32 recip;\r\nu32 wValue;\r\nu32 wIndex;\r\ndev_dbg(hsotg->dev, "%s: %s_FEATURE\n",\r\n__func__, set ? "SET" : "CLEAR");\r\nwValue = le16_to_cpu(ctrl->wValue);\r\nwIndex = le16_to_cpu(ctrl->wIndex);\r\nrecip = ctrl->bRequestType & USB_RECIP_MASK;\r\nswitch (recip) {\r\ncase USB_RECIP_DEVICE:\r\nswitch (wValue) {\r\ncase USB_DEVICE_TEST_MODE:\r\nif ((wIndex & 0xff) != 0)\r\nreturn -EINVAL;\r\nif (!set)\r\nreturn -EINVAL;\r\nhsotg->test_mode = wIndex >> 8;\r\nret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nif (ret) {\r\ndev_err(hsotg->dev,\r\n"%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nbreak;\r\ncase USB_RECIP_ENDPOINT:\r\nep = ep_from_windex(hsotg, wIndex);\r\nif (!ep) {\r\ndev_dbg(hsotg->dev, "%s: no endpoint for 0x%04x\n",\r\n__func__, wIndex);\r\nreturn -ENOENT;\r\n}\r\nswitch (wValue) {\r\ncase USB_ENDPOINT_HALT:\r\nhalted = ep->halted;\r\ndwc2_hsotg_ep_sethalt(&ep->ep, set, true);\r\nret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nif (ret) {\r\ndev_err(hsotg->dev,\r\n"%s: failed to send reply\n", __func__);\r\nreturn ret;\r\n}\r\nif (!set && halted) {\r\nif (ep->req) {\r\nhs_req = ep->req;\r\nep->req = NULL;\r\nlist_del_init(&hs_req->queue);\r\nif (hs_req->req.complete) {\r\nspin_unlock(&hsotg->lock);\r\nusb_gadget_giveback_request(\r\n&ep->ep, &hs_req->req);\r\nspin_lock(&hsotg->lock);\r\n}\r\n}\r\nif (!ep->req)\r\ndwc2_gadget_start_next_request(ep);\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENOENT;\r\n}\r\nreturn 1;\r\n}\r\nstatic void dwc2_hsotg_stall_ep0(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nu32 reg;\r\nu32 ctrl;\r\ndev_dbg(hsotg->dev, "ep0 stall (dir=%d)\n", ep0->dir_in);\r\nreg = (ep0->dir_in) ? DIEPCTL0 : DOEPCTL0;\r\nctrl = dwc2_readl(hsotg->regs + reg);\r\nctrl |= DXEPCTL_STALL;\r\nctrl |= DXEPCTL_CNAK;\r\ndwc2_writel(ctrl, hsotg->regs + reg);\r\ndev_dbg(hsotg->dev,\r\n"written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\n",\r\nctrl, reg, dwc2_readl(hsotg->regs + reg));\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\n}\r\nstatic void dwc2_hsotg_process_control(struct dwc2_hsotg *hsotg,\r\nstruct usb_ctrlrequest *ctrl)\r\n{\r\nstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\r\nint ret = 0;\r\nu32 dcfg;\r\ndev_dbg(hsotg->dev,\r\n"ctrl Type=%02x, Req=%02x, V=%04x, I=%04x, L=%04x\n",\r\nctrl->bRequestType, ctrl->bRequest, ctrl->wValue,\r\nctrl->wIndex, ctrl->wLength);\r\nif (ctrl->wLength == 0) {\r\nep0->dir_in = 1;\r\nhsotg->ep0_state = DWC2_EP0_STATUS_IN;\r\n} else if (ctrl->bRequestType & USB_DIR_IN) {\r\nep0->dir_in = 1;\r\nhsotg->ep0_state = DWC2_EP0_DATA_IN;\r\n} else {\r\nep0->dir_in = 0;\r\nhsotg->ep0_state = DWC2_EP0_DATA_OUT;\r\n}\r\nif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\r\nswitch (ctrl->bRequest) {\r\ncase USB_REQ_SET_ADDRESS:\r\nhsotg->connected = 1;\r\ndcfg = dwc2_readl(hsotg->regs + DCFG);\r\ndcfg &= ~DCFG_DEVADDR_MASK;\r\ndcfg |= (le16_to_cpu(ctrl->wValue) <<\r\nDCFG_DEVADDR_SHIFT) & DCFG_DEVADDR_MASK;\r\ndwc2_writel(dcfg, hsotg->regs + DCFG);\r\ndev_info(hsotg->dev, "new address %d\n", ctrl->wValue);\r\nret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);\r\nreturn;\r\ncase USB_REQ_GET_STATUS:\r\nret = dwc2_hsotg_process_req_status(hsotg, ctrl);\r\nbreak;\r\ncase USB_REQ_CLEAR_FEATURE:\r\ncase USB_REQ_SET_FEATURE:\r\nret = dwc2_hsotg_process_req_feature(hsotg, ctrl);\r\nbreak;\r\n}\r\n}\r\nif (ret == 0 && hsotg->driver) {\r\nspin_unlock(&hsotg->lock);\r\nret = hsotg->driver->setup(&hsotg->gadget, ctrl);\r\nspin_lock(&hsotg->lock);\r\nif (ret < 0)\r\ndev_dbg(hsotg->dev, "driver->setup() ret %d\n", ret);\r\n}\r\nif (ret < 0)\r\ndwc2_hsotg_stall_ep0(hsotg);\r\n}\r\nstatic void dwc2_hsotg_complete_setup(struct usb_ep *ep,\r\nstruct usb_request *req)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nif (req->status < 0) {\r\ndev_dbg(hsotg->dev, "%s: failed %d\n", __func__, req->status);\r\nreturn;\r\n}\r\nspin_lock(&hsotg->lock);\r\nif (req->actual == 0)\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\nelse\r\ndwc2_hsotg_process_control(hsotg, req->buf);\r\nspin_unlock(&hsotg->lock);\r\n}\r\nstatic void dwc2_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct usb_request *req = hsotg->ctrl_req;\r\nstruct dwc2_hsotg_req *hs_req = our_req(req);\r\nint ret;\r\ndev_dbg(hsotg->dev, "%s: queueing setup request\n", __func__);\r\nreq->zero = 0;\r\nreq->length = 8;\r\nreq->buf = hsotg->ctrl_buff;\r\nreq->complete = dwc2_hsotg_complete_setup;\r\nif (!list_empty(&hs_req->queue)) {\r\ndev_dbg(hsotg->dev, "%s already queued???\n", __func__);\r\nreturn;\r\n}\r\nhsotg->eps_out[0]->dir_in = 0;\r\nhsotg->eps_out[0]->send_zlp = 0;\r\nhsotg->ep0_state = DWC2_EP0_SETUP;\r\nret = dwc2_hsotg_ep_queue(&hsotg->eps_out[0]->ep, req, GFP_ATOMIC);\r\nif (ret < 0) {\r\ndev_err(hsotg->dev, "%s: failed queue (%d)\n", __func__, ret);\r\n}\r\n}\r\nstatic void dwc2_hsotg_program_zlp(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep)\r\n{\r\nu32 ctrl;\r\nu8 index = hs_ep->index;\r\nu32 epctl_reg = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nu32 epsiz_reg = hs_ep->dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\r\nif (hs_ep->dir_in)\r\ndev_dbg(hsotg->dev, "Sending zero-length packet on ep%d\n",\r\nindex);\r\nelse\r\ndev_dbg(hsotg->dev, "Receiving zero-length packet on ep%d\n",\r\nindex);\r\nif (using_desc_dma(hsotg)) {\r\ndma_addr_t dma = hs_ep->desc_list_dma;\r\ndwc2_gadget_set_ep0_desc_chain(hsotg, hs_ep);\r\ndwc2_gadget_config_nonisoc_xfer_ddma(hs_ep, dma, 0);\r\n} else {\r\ndwc2_writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |\r\nDXEPTSIZ_XFERSIZE(0), hsotg->regs +\r\nepsiz_reg);\r\n}\r\nctrl = dwc2_readl(hsotg->regs + epctl_reg);\r\nctrl |= DXEPCTL_CNAK;\r\nctrl |= DXEPCTL_EPENA;\r\nctrl |= DXEPCTL_USBACTEP;\r\ndwc2_writel(ctrl, hsotg->regs + epctl_reg);\r\n}\r\nstatic void dwc2_hsotg_complete_request(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nstruct dwc2_hsotg_req *hs_req,\r\nint result)\r\n{\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "%s: nothing to complete?\n", __func__);\r\nreturn;\r\n}\r\ndev_dbg(hsotg->dev, "complete: ep %p %s, req %p, %d => %p\n",\r\nhs_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);\r\nif (hs_req->req.status == -EINPROGRESS)\r\nhs_req->req.status = result;\r\nif (using_dma(hsotg))\r\ndwc2_hsotg_unmap_dma(hsotg, hs_ep, hs_req);\r\ndwc2_hsotg_handle_unaligned_buf_complete(hsotg, hs_ep, hs_req);\r\nhs_ep->req = NULL;\r\nlist_del_init(&hs_req->queue);\r\nif (hs_req->req.complete) {\r\nspin_unlock(&hsotg->lock);\r\nusb_gadget_giveback_request(&hs_ep->ep, &hs_req->req);\r\nspin_lock(&hsotg->lock);\r\n}\r\nif (using_desc_dma(hsotg) && hs_ep->isochronous)\r\nreturn;\r\nif (!hs_ep->req && result >= 0)\r\ndwc2_gadget_start_next_request(hs_ep);\r\n}\r\nstatic void dwc2_gadget_complete_isoc_request_ddma(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nstruct dwc2_hsotg_req *hs_req;\r\nstruct usb_request *ureq;\r\nint index;\r\ndma_addr_t dma_addr;\r\nu32 dma_reg;\r\nu32 depdma;\r\nu32 desc_sts;\r\nu32 mask;\r\nhs_req = get_ep_head(hs_ep);\r\nif (!hs_req) {\r\ndev_warn(hsotg->dev, "%s: ISOC EP queue empty\n", __func__);\r\nreturn;\r\n}\r\nureq = &hs_req->req;\r\ndma_addr = hs_ep->desc_list_dma;\r\nif (!hs_ep->isoc_chain_num)\r\ndma_addr += sizeof(struct dwc2_dma_desc) *\r\n(MAX_DMA_DESC_NUM_GENERIC / 2);\r\ndma_reg = hs_ep->dir_in ? DIEPDMA(hs_ep->index) : DOEPDMA(hs_ep->index);\r\ndepdma = dwc2_readl(hsotg->regs + dma_reg);\r\nindex = (depdma - dma_addr) / sizeof(struct dwc2_dma_desc) - 1;\r\ndesc_sts = hs_ep->desc_list[index].status;\r\nmask = hs_ep->dir_in ? DEV_DMA_ISOC_TX_NBYTES_MASK :\r\nDEV_DMA_ISOC_RX_NBYTES_MASK;\r\nureq->actual = ureq->length -\r\n((desc_sts & mask) >> DEV_DMA_ISOC_NBYTES_SHIFT);\r\nif (!hs_ep->dir_in && ureq->length & 0x3)\r\nureq->actual += 4 - (ureq->length & 0x3);\r\ndwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\n}\r\nstatic void dwc2_gadget_start_next_isoc_ddma(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nu32 depctl;\r\nu32 dma_reg;\r\nu32 ctrl;\r\nu32 dma_addr = hs_ep->desc_list_dma;\r\nunsigned char index = hs_ep->index;\r\ndma_reg = hs_ep->dir_in ? DIEPDMA(index) : DOEPDMA(index);\r\ndepctl = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nctrl = dwc2_readl(hsotg->regs + depctl);\r\nif (!(ctrl & DXEPCTL_EPENA)) {\r\nif (!hs_ep->next_desc) {\r\ndev_dbg(hsotg->dev, "%s: No more ISOC requests\n",\r\n__func__);\r\nreturn;\r\n}\r\ndma_addr += sizeof(struct dwc2_dma_desc) *\r\n(MAX_DMA_DESC_NUM_GENERIC / 2) *\r\nhs_ep->isoc_chain_num;\r\ndwc2_writel(dma_addr, hsotg->regs + dma_reg);\r\nctrl |= DXEPCTL_EPENA | DXEPCTL_CNAK;\r\ndwc2_writel(ctrl, hsotg->regs + depctl);\r\nhs_ep->isoc_chain_num = (hs_ep->isoc_chain_num ^ 1) & 0x1;\r\nhs_ep->next_desc = 0;\r\ndev_dbg(hsotg->dev, "%s: Restarted isochronous endpoint\n",\r\n__func__);\r\n}\r\n}\r\nstatic void dwc2_hsotg_rx_data(struct dwc2_hsotg *hsotg, int ep_idx, int size)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = hsotg->eps_out[ep_idx];\r\nstruct dwc2_hsotg_req *hs_req = hs_ep->req;\r\nvoid __iomem *fifo = hsotg->regs + EPFIFO(ep_idx);\r\nint to_read;\r\nint max_req;\r\nint read_ptr;\r\nif (!hs_req) {\r\nu32 epctl = dwc2_readl(hsotg->regs + DOEPCTL(ep_idx));\r\nint ptr;\r\ndev_dbg(hsotg->dev,\r\n"%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\n",\r\n__func__, size, ep_idx, epctl);\r\nfor (ptr = 0; ptr < size; ptr += 4)\r\n(void)dwc2_readl(fifo);\r\nreturn;\r\n}\r\nto_read = size;\r\nread_ptr = hs_req->req.actual;\r\nmax_req = hs_req->req.length - read_ptr;\r\ndev_dbg(hsotg->dev, "%s: read %d/%d, done %d/%d\n",\r\n__func__, to_read, max_req, read_ptr, hs_req->req.length);\r\nif (to_read > max_req) {\r\nWARN_ON_ONCE(1);\r\n}\r\nhs_ep->total_data += to_read;\r\nhs_req->req.actual += to_read;\r\nto_read = DIV_ROUND_UP(to_read, 4);\r\nioread32_rep(fifo, hs_req->req.buf + read_ptr, to_read);\r\n}\r\nstatic void dwc2_hsotg_ep0_zlp(struct dwc2_hsotg *hsotg, bool dir_in)\r\n{\r\nhsotg->eps_out[0]->dir_in = dir_in;\r\nhsotg->ep0_state = dir_in ? DWC2_EP0_STATUS_IN : DWC2_EP0_STATUS_OUT;\r\ndwc2_hsotg_program_zlp(hsotg, hsotg->eps_out[0]);\r\n}\r\nstatic void dwc2_hsotg_change_ep_iso_parity(struct dwc2_hsotg *hsotg,\r\nu32 epctl_reg)\r\n{\r\nu32 ctrl;\r\nctrl = dwc2_readl(hsotg->regs + epctl_reg);\r\nif (ctrl & DXEPCTL_EOFRNUM)\r\nctrl |= DXEPCTL_SETEVENFR;\r\nelse\r\nctrl |= DXEPCTL_SETODDFR;\r\ndwc2_writel(ctrl, hsotg->regs + epctl_reg);\r\n}\r\nstatic unsigned int dwc2_gadget_get_xfersize_ddma(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nunsigned int bytes_rem = 0;\r\nstruct dwc2_dma_desc *desc = hs_ep->desc_list;\r\nint i;\r\nu32 status;\r\nif (!desc)\r\nreturn -EINVAL;\r\nfor (i = 0; i < hs_ep->desc_count; ++i) {\r\nstatus = desc->status;\r\nbytes_rem += status & DEV_DMA_NBYTES_MASK;\r\nif (status & DEV_DMA_STS_MASK)\r\ndev_err(hsotg->dev, "descriptor %d closed with %x\n",\r\ni, status & DEV_DMA_STS_MASK);\r\n}\r\nreturn bytes_rem;\r\n}\r\nstatic void dwc2_hsotg_handle_outdone(struct dwc2_hsotg *hsotg, int epnum)\r\n{\r\nu32 epsize = dwc2_readl(hsotg->regs + DOEPTSIZ(epnum));\r\nstruct dwc2_hsotg_ep *hs_ep = hsotg->eps_out[epnum];\r\nstruct dwc2_hsotg_req *hs_req = hs_ep->req;\r\nstruct usb_request *req = &hs_req->req;\r\nunsigned int size_left = DXEPTSIZ_XFERSIZE_GET(epsize);\r\nint result = 0;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "%s: no request active\n", __func__);\r\nreturn;\r\n}\r\nif (epnum == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_OUT) {\r\ndev_dbg(hsotg->dev, "zlp packet received\n");\r\ndwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\nreturn;\r\n}\r\nif (using_desc_dma(hsotg))\r\nsize_left = dwc2_gadget_get_xfersize_ddma(hs_ep);\r\nif (using_dma(hsotg)) {\r\nunsigned int size_done;\r\nsize_done = hs_ep->size_loaded - size_left;\r\nsize_done += hs_ep->last_load;\r\nreq->actual = size_done;\r\n}\r\nif (req->actual < req->length && size_left == 0) {\r\ndwc2_hsotg_start_req(hsotg, hs_ep, hs_req, true);\r\nreturn;\r\n}\r\nif (req->actual < req->length && req->short_not_ok) {\r\ndev_dbg(hsotg->dev, "%s: got %d/%d (short not ok) => error\n",\r\n__func__, req->actual, req->length);\r\n}\r\nif (!using_desc_dma(hsotg) && epnum == 0 &&\r\nhsotg->ep0_state == DWC2_EP0_DATA_OUT) {\r\ndwc2_hsotg_ep0_zlp(hsotg, true);\r\nreturn;\r\n}\r\nif (!using_dma(hsotg)) {\r\nif (hs_ep->isochronous && hs_ep->interval == 1)\r\ndwc2_hsotg_change_ep_iso_parity(hsotg, DOEPCTL(epnum));\r\nelse if (hs_ep->isochronous && hs_ep->interval > 1)\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\n}\r\ndwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, result);\r\n}\r\nstatic void dwc2_hsotg_handle_rx(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 grxstsr = dwc2_readl(hsotg->regs + GRXSTSP);\r\nu32 epnum, status, size;\r\nWARN_ON(using_dma(hsotg));\r\nepnum = grxstsr & GRXSTS_EPNUM_MASK;\r\nstatus = grxstsr & GRXSTS_PKTSTS_MASK;\r\nsize = grxstsr & GRXSTS_BYTECNT_MASK;\r\nsize >>= GRXSTS_BYTECNT_SHIFT;\r\ndev_dbg(hsotg->dev, "%s: GRXSTSP=0x%08x (%d@%d)\n",\r\n__func__, grxstsr, size, epnum);\r\nswitch ((status & GRXSTS_PKTSTS_MASK) >> GRXSTS_PKTSTS_SHIFT) {\r\ncase GRXSTS_PKTSTS_GLOBALOUTNAK:\r\ndev_dbg(hsotg->dev, "GLOBALOUTNAK\n");\r\nbreak;\r\ncase GRXSTS_PKTSTS_OUTDONE:\r\ndev_dbg(hsotg->dev, "OutDone (Frame=0x%08x)\n",\r\ndwc2_hsotg_read_frameno(hsotg));\r\nif (!using_dma(hsotg))\r\ndwc2_hsotg_handle_outdone(hsotg, epnum);\r\nbreak;\r\ncase GRXSTS_PKTSTS_SETUPDONE:\r\ndev_dbg(hsotg->dev,\r\n"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\n",\r\ndwc2_hsotg_read_frameno(hsotg),\r\ndwc2_readl(hsotg->regs + DOEPCTL(0)));\r\nif (hsotg->ep0_state == DWC2_EP0_SETUP)\r\ndwc2_hsotg_handle_outdone(hsotg, epnum);\r\nbreak;\r\ncase GRXSTS_PKTSTS_OUTRX:\r\ndwc2_hsotg_rx_data(hsotg, epnum, size);\r\nbreak;\r\ncase GRXSTS_PKTSTS_SETUPRX:\r\ndev_dbg(hsotg->dev,\r\n"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\n",\r\ndwc2_hsotg_read_frameno(hsotg),\r\ndwc2_readl(hsotg->regs + DOEPCTL(0)));\r\nWARN_ON(hsotg->ep0_state != DWC2_EP0_SETUP);\r\ndwc2_hsotg_rx_data(hsotg, epnum, size);\r\nbreak;\r\ndefault:\r\ndev_warn(hsotg->dev, "%s: unknown status %08x\n",\r\n__func__, grxstsr);\r\ndwc2_hsotg_dump(hsotg);\r\nbreak;\r\n}\r\n}\r\nstatic u32 dwc2_hsotg_ep0_mps(unsigned int mps)\r\n{\r\nswitch (mps) {\r\ncase 64:\r\nreturn D0EPCTL_MPS_64;\r\ncase 32:\r\nreturn D0EPCTL_MPS_32;\r\ncase 16:\r\nreturn D0EPCTL_MPS_16;\r\ncase 8:\r\nreturn D0EPCTL_MPS_8;\r\n}\r\nWARN_ON(1);\r\nreturn (u32)-1;\r\n}\r\nstatic void dwc2_hsotg_set_ep_maxpacket(struct dwc2_hsotg *hsotg,\r\nunsigned int ep, unsigned int mps,\r\nunsigned int mc, unsigned int dir_in)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 reg;\r\nhs_ep = index_to_ep(hsotg, ep, dir_in);\r\nif (!hs_ep)\r\nreturn;\r\nif (ep == 0) {\r\nu32 mps_bytes = mps;\r\nmps = dwc2_hsotg_ep0_mps(mps_bytes);\r\nif (mps > 3)\r\ngoto bad_mps;\r\nhs_ep->ep.maxpacket = mps_bytes;\r\nhs_ep->mc = 1;\r\n} else {\r\nif (mps > 1024)\r\ngoto bad_mps;\r\nhs_ep->mc = mc;\r\nif (mc > 3)\r\ngoto bad_mps;\r\nhs_ep->ep.maxpacket = mps;\r\n}\r\nif (dir_in) {\r\nreg = dwc2_readl(regs + DIEPCTL(ep));\r\nreg &= ~DXEPCTL_MPS_MASK;\r\nreg |= mps;\r\ndwc2_writel(reg, regs + DIEPCTL(ep));\r\n} else {\r\nreg = dwc2_readl(regs + DOEPCTL(ep));\r\nreg &= ~DXEPCTL_MPS_MASK;\r\nreg |= mps;\r\ndwc2_writel(reg, regs + DOEPCTL(ep));\r\n}\r\nreturn;\r\nbad_mps:\r\ndev_err(hsotg->dev, "ep%d: bad mps of %d\n", ep, mps);\r\n}\r\nstatic void dwc2_hsotg_txfifo_flush(struct dwc2_hsotg *hsotg, unsigned int idx)\r\n{\r\nint timeout;\r\nint val;\r\ndwc2_writel(GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,\r\nhsotg->regs + GRSTCTL);\r\ntimeout = 100;\r\nwhile (1) {\r\nval = dwc2_readl(hsotg->regs + GRSTCTL);\r\nif ((val & (GRSTCTL_TXFFLSH)) == 0)\r\nbreak;\r\nif (--timeout == 0) {\r\ndev_err(hsotg->dev,\r\n"%s: timeout flushing fifo (GRSTCTL=%08x)\n",\r\n__func__, val);\r\nbreak;\r\n}\r\nudelay(1);\r\n}\r\n}\r\nstatic int dwc2_hsotg_trytx(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg_req *hs_req = hs_ep->req;\r\nif (!hs_ep->dir_in || !hs_req) {\r\nif (hs_ep->index != 0)\r\ndwc2_hsotg_ctrl_epint(hsotg, hs_ep->index,\r\nhs_ep->dir_in, 0);\r\nreturn 0;\r\n}\r\nif (hs_req->req.actual < hs_req->req.length) {\r\ndev_dbg(hsotg->dev, "trying to write more for ep%d\n",\r\nhs_ep->index);\r\nreturn dwc2_hsotg_write_fifo(hsotg, hs_ep, hs_req);\r\n}\r\nreturn 0;\r\n}\r\nstatic void dwc2_hsotg_complete_in(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg_req *hs_req = hs_ep->req;\r\nu32 epsize = dwc2_readl(hsotg->regs + DIEPTSIZ(hs_ep->index));\r\nint size_left, size_done;\r\nif (!hs_req) {\r\ndev_dbg(hsotg->dev, "XferCompl but no req\n");\r\nreturn;\r\n}\r\nif (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_IN) {\r\ndev_dbg(hsotg->dev, "zlp packet sent\n");\r\nhs_ep->dir_in = 0;\r\ndwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\nif (hsotg->test_mode) {\r\nint ret;\r\nret = dwc2_hsotg_set_test_mode(hsotg, hsotg->test_mode);\r\nif (ret < 0) {\r\ndev_dbg(hsotg->dev, "Invalid Test #%d\n",\r\nhsotg->test_mode);\r\ndwc2_hsotg_stall_ep0(hsotg);\r\nreturn;\r\n}\r\n}\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\nreturn;\r\n}\r\nif (using_desc_dma(hsotg)) {\r\nsize_left = dwc2_gadget_get_xfersize_ddma(hs_ep);\r\nif (size_left < 0)\r\ndev_err(hsotg->dev, "error parsing DDMA results %d\n",\r\nsize_left);\r\n} else {\r\nsize_left = DXEPTSIZ_XFERSIZE_GET(epsize);\r\n}\r\nsize_done = hs_ep->size_loaded - size_left;\r\nsize_done += hs_ep->last_load;\r\nif (hs_req->req.actual != size_done)\r\ndev_dbg(hsotg->dev, "%s: adjusting size done %d => %d\n",\r\n__func__, hs_req->req.actual, size_done);\r\nhs_req->req.actual = size_done;\r\ndev_dbg(hsotg->dev, "req->length:%d req->actual:%d req->zero:%d\n",\r\nhs_req->req.length, hs_req->req.actual, hs_req->req.zero);\r\nif (!size_left && hs_req->req.actual < hs_req->req.length) {\r\ndev_dbg(hsotg->dev, "%s trying more for req...\n", __func__);\r\ndwc2_hsotg_start_req(hsotg, hs_ep, hs_req, true);\r\nreturn;\r\n}\r\nif (hs_ep->send_zlp) {\r\ndwc2_hsotg_program_zlp(hsotg, hs_ep);\r\nhs_ep->send_zlp = 0;\r\nreturn;\r\n}\r\nif (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_DATA_IN) {\r\ndwc2_hsotg_ep0_zlp(hsotg, false);\r\nreturn;\r\n}\r\ndwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\r\n}\r\nstatic u32 dwc2_gadget_read_ep_interrupts(struct dwc2_hsotg *hsotg,\r\nunsigned int idx, int dir_in)\r\n{\r\nu32 epmsk_reg = dir_in ? DIEPMSK : DOEPMSK;\r\nu32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);\r\nu32 ints;\r\nu32 mask;\r\nu32 diepempmsk;\r\nmask = dwc2_readl(hsotg->regs + epmsk_reg);\r\ndiepempmsk = dwc2_readl(hsotg->regs + DIEPEMPMSK);\r\nmask |= ((diepempmsk >> idx) & 0x1) ? DIEPMSK_TXFIFOEMPTY : 0;\r\nmask |= DXEPINT_SETUP_RCVD;\r\nints = dwc2_readl(hsotg->regs + epint_reg);\r\nints &= mask;\r\nreturn ints;\r\n}\r\nstatic void dwc2_gadget_handle_ep_disabled(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nstruct dwc2_hsotg_req *hs_req;\r\nunsigned char idx = hs_ep->index;\r\nint dir_in = hs_ep->dir_in;\r\nu32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);\r\nint dctl = dwc2_readl(hsotg->regs + DCTL);\r\ndev_dbg(hsotg->dev, "%s: EPDisbld\n", __func__);\r\nif (dir_in) {\r\nint epctl = dwc2_readl(hsotg->regs + epctl_reg);\r\ndwc2_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);\r\nif (hs_ep->isochronous) {\r\ndwc2_hsotg_complete_in(hsotg, hs_ep);\r\nreturn;\r\n}\r\nif ((epctl & DXEPCTL_STALL) && (epctl & DXEPCTL_EPTYPE_BULK)) {\r\nint dctl = dwc2_readl(hsotg->regs + DCTL);\r\ndctl |= DCTL_CGNPINNAK;\r\ndwc2_writel(dctl, hsotg->regs + DCTL);\r\n}\r\nreturn;\r\n}\r\nif (dctl & DCTL_GOUTNAKSTS) {\r\ndctl |= DCTL_CGOUTNAK;\r\ndwc2_writel(dctl, hsotg->regs + DCTL);\r\n}\r\nif (!hs_ep->isochronous)\r\nreturn;\r\nif (list_empty(&hs_ep->queue)) {\r\ndev_dbg(hsotg->dev, "%s: complete_ep 0x%p, ep->queue empty!\n",\r\n__func__, hs_ep);\r\nreturn;\r\n}\r\ndo {\r\nhs_req = get_ep_head(hs_ep);\r\nif (hs_req)\r\ndwc2_hsotg_complete_request(hsotg, hs_ep, hs_req,\r\n-ENODATA);\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\n} while (dwc2_gadget_target_frame_elapsed(hs_ep));\r\ndwc2_gadget_start_next_request(hs_ep);\r\n}\r\nstatic void dwc2_gadget_handle_out_token_ep_disabled(struct dwc2_hsotg_ep *ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = ep->parent;\r\nint dir_in = ep->dir_in;\r\nu32 doepmsk;\r\nu32 tmp;\r\nif (dir_in || !ep->isochronous)\r\nreturn;\r\ntmp = dwc2_hsotg_read_frameno(hsotg);\r\ndwc2_hsotg_complete_request(hsotg, ep, get_ep_head(ep), -ENODATA);\r\nif (using_desc_dma(hsotg)) {\r\nif (ep->target_frame == TARGET_FRAME_INITIAL) {\r\nep->target_frame = tmp;\r\ndwc2_gadget_start_isoc_ddma(ep);\r\n}\r\nreturn;\r\n}\r\nif (ep->interval > 1 &&\r\nep->target_frame == TARGET_FRAME_INITIAL) {\r\nu32 dsts;\r\nu32 ctrl;\r\ndsts = dwc2_readl(hsotg->regs + DSTS);\r\nep->target_frame = dwc2_hsotg_read_frameno(hsotg);\r\ndwc2_gadget_incr_frame_num(ep);\r\nctrl = dwc2_readl(hsotg->regs + DOEPCTL(ep->index));\r\nif (ep->target_frame & 0x1)\r\nctrl |= DXEPCTL_SETODDFR;\r\nelse\r\nctrl |= DXEPCTL_SETEVENFR;\r\ndwc2_writel(ctrl, hsotg->regs + DOEPCTL(ep->index));\r\n}\r\ndwc2_gadget_start_next_request(ep);\r\ndoepmsk = dwc2_readl(hsotg->regs + DOEPMSK);\r\ndoepmsk &= ~DOEPMSK_OUTTKNEPDISMSK;\r\ndwc2_writel(doepmsk, hsotg->regs + DOEPMSK);\r\n}\r\nstatic void dwc2_gadget_handle_nak(struct dwc2_hsotg_ep *hs_ep)\r\n{\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nint dir_in = hs_ep->dir_in;\r\nif (!dir_in || !hs_ep->isochronous)\r\nreturn;\r\nif (hs_ep->target_frame == TARGET_FRAME_INITIAL) {\r\nhs_ep->target_frame = dwc2_hsotg_read_frameno(hsotg);\r\nif (using_desc_dma(hsotg)) {\r\ndwc2_gadget_start_isoc_ddma(hs_ep);\r\nreturn;\r\n}\r\nif (hs_ep->interval > 1) {\r\nu32 ctrl = dwc2_readl(hsotg->regs +\r\nDIEPCTL(hs_ep->index));\r\nif (hs_ep->target_frame & 0x1)\r\nctrl |= DXEPCTL_SETODDFR;\r\nelse\r\nctrl |= DXEPCTL_SETEVENFR;\r\ndwc2_writel(ctrl, hsotg->regs + DIEPCTL(hs_ep->index));\r\n}\r\ndwc2_hsotg_complete_request(hsotg, hs_ep,\r\nget_ep_head(hs_ep), 0);\r\n}\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\n}\r\nstatic void dwc2_hsotg_epint(struct dwc2_hsotg *hsotg, unsigned int idx,\r\nint dir_in)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = index_to_ep(hsotg, idx, dir_in);\r\nu32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);\r\nu32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);\r\nu32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);\r\nu32 ints;\r\nu32 ctrl;\r\nints = dwc2_gadget_read_ep_interrupts(hsotg, idx, dir_in);\r\nctrl = dwc2_readl(hsotg->regs + epctl_reg);\r\ndwc2_writel(ints, hsotg->regs + epint_reg);\r\nif (!hs_ep) {\r\ndev_err(hsotg->dev, "%s:Interrupt for unconfigured ep%d(%s)\n",\r\n__func__, idx, dir_in ? "in" : "out");\r\nreturn;\r\n}\r\ndev_dbg(hsotg->dev, "%s: ep%d(%s) DxEPINT=0x%08x\n",\r\n__func__, idx, dir_in ? "in" : "out", ints);\r\nif (idx == 0 && (ints & (DXEPINT_SETUP | DXEPINT_SETUP_RCVD)))\r\nints &= ~DXEPINT_XFERCOMPL;\r\nif (using_desc_dma(hsotg) && idx == 0 && !hs_ep->dir_in &&\r\nhsotg->ep0_state == DWC2_EP0_SETUP && !(ints & DXEPINT_SETUP))\r\nints &= ~DXEPINT_XFERCOMPL;\r\nif (ints & DXEPINT_XFERCOMPL) {\r\ndev_dbg(hsotg->dev,\r\n"%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\n",\r\n__func__, dwc2_readl(hsotg->regs + epctl_reg),\r\ndwc2_readl(hsotg->regs + epsiz_reg));\r\nif (using_desc_dma(hsotg) && hs_ep->isochronous) {\r\ndwc2_gadget_complete_isoc_request_ddma(hs_ep);\r\ndwc2_gadget_start_next_isoc_ddma(hs_ep);\r\n} else if (dir_in) {\r\nif (hs_ep->isochronous && hs_ep->interval > 1)\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\ndwc2_hsotg_complete_in(hsotg, hs_ep);\r\nif (ints & DXEPINT_NAKINTRPT)\r\nints &= ~DXEPINT_NAKINTRPT;\r\nif (idx == 0 && !hs_ep->req)\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\n} else if (using_dma(hsotg)) {\r\nif (hs_ep->isochronous && hs_ep->interval > 1)\r\ndwc2_gadget_incr_frame_num(hs_ep);\r\ndwc2_hsotg_handle_outdone(hsotg, idx);\r\n}\r\n}\r\nif (ints & DXEPINT_EPDISBLD)\r\ndwc2_gadget_handle_ep_disabled(hs_ep);\r\nif (ints & DXEPINT_OUTTKNEPDIS)\r\ndwc2_gadget_handle_out_token_ep_disabled(hs_ep);\r\nif (ints & DXEPINT_NAKINTRPT)\r\ndwc2_gadget_handle_nak(hs_ep);\r\nif (ints & DXEPINT_AHBERR)\r\ndev_dbg(hsotg->dev, "%s: AHBErr\n", __func__);\r\nif (ints & DXEPINT_SETUP) {\r\ndev_dbg(hsotg->dev, "%s: Setup/Timeout\n", __func__);\r\nif (using_dma(hsotg) && idx == 0) {\r\nif (dir_in)\r\nWARN_ON_ONCE(1);\r\nelse\r\ndwc2_hsotg_handle_outdone(hsotg, 0);\r\n}\r\n}\r\nif (ints & DXEPINT_STSPHSERCVD) {\r\ndev_dbg(hsotg->dev, "%s: StsPhseRcvd\n", __func__);\r\nif (using_desc_dma(hsotg))\r\ndwc2_hsotg_ep0_zlp(hsotg, true);\r\n}\r\nif (ints & DXEPINT_BACK2BACKSETUP)\r\ndev_dbg(hsotg->dev, "%s: B2BSetup/INEPNakEff\n", __func__);\r\nif (ints & DXEPINT_BNAINTR) {\r\ndev_dbg(hsotg->dev, "%s: BNA interrupt\n", __func__);\r\nif (hs_ep->isochronous)\r\ndwc2_gadget_start_next_isoc_ddma(hs_ep);\r\n}\r\nif (dir_in && !hs_ep->isochronous) {\r\nif (ints & DXEPINT_INTKNTXFEMP) {\r\ndev_dbg(hsotg->dev, "%s: ep%d: INTknTXFEmpMsk\n",\r\n__func__, idx);\r\n}\r\nif (ints & DXEPINT_INTKNEPMIS) {\r\ndev_warn(hsotg->dev, "%s: ep%d: INTknEP\n",\r\n__func__, idx);\r\n}\r\nif (hsotg->dedicated_fifos &&\r\nints & DXEPINT_TXFEMP) {\r\ndev_dbg(hsotg->dev, "%s: ep%d: TxFIFOEmpty\n",\r\n__func__, idx);\r\nif (!using_dma(hsotg))\r\ndwc2_hsotg_trytx(hsotg, hs_ep);\r\n}\r\n}\r\n}\r\nstatic void dwc2_hsotg_irq_enumdone(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 dsts = dwc2_readl(hsotg->regs + DSTS);\r\nint ep0_mps = 0, ep_mps = 8;\r\ndev_dbg(hsotg->dev, "EnumDone (DSTS=0x%08x)\n", dsts);\r\nswitch ((dsts & DSTS_ENUMSPD_MASK) >> DSTS_ENUMSPD_SHIFT) {\r\ncase DSTS_ENUMSPD_FS:\r\ncase DSTS_ENUMSPD_FS48:\r\nhsotg->gadget.speed = USB_SPEED_FULL;\r\nep0_mps = EP0_MPS_LIMIT;\r\nep_mps = 1023;\r\nbreak;\r\ncase DSTS_ENUMSPD_HS:\r\nhsotg->gadget.speed = USB_SPEED_HIGH;\r\nep0_mps = EP0_MPS_LIMIT;\r\nep_mps = 1024;\r\nbreak;\r\ncase DSTS_ENUMSPD_LS:\r\nhsotg->gadget.speed = USB_SPEED_LOW;\r\nep0_mps = 8;\r\nep_mps = 8;\r\nbreak;\r\n}\r\ndev_info(hsotg->dev, "new device is %s\n",\r\nusb_speed_string(hsotg->gadget.speed));\r\nif (ep0_mps) {\r\nint i;\r\ndwc2_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 0, 1);\r\ndwc2_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 0, 0);\r\nfor (i = 1; i < hsotg->num_of_eps; i++) {\r\nif (hsotg->eps_in[i])\r\ndwc2_hsotg_set_ep_maxpacket(hsotg, i, ep_mps,\r\n0, 1);\r\nif (hsotg->eps_out[i])\r\ndwc2_hsotg_set_ep_maxpacket(hsotg, i, ep_mps,\r\n0, 0);\r\n}\r\n}\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\ndwc2_readl(hsotg->regs + DIEPCTL0),\r\ndwc2_readl(hsotg->regs + DOEPCTL0));\r\n}\r\nstatic void kill_all_requests(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *ep,\r\nint result)\r\n{\r\nstruct dwc2_hsotg_req *req, *treq;\r\nunsigned int size;\r\nep->req = NULL;\r\nlist_for_each_entry_safe(req, treq, &ep->queue, queue)\r\ndwc2_hsotg_complete_request(hsotg, ep, req,\r\nresult);\r\nif (!hsotg->dedicated_fifos)\r\nreturn;\r\nsize = (dwc2_readl(hsotg->regs + DTXFSTS(ep->fifo_index)) & 0xffff) * 4;\r\nif (size < ep->fifo_size)\r\ndwc2_hsotg_txfifo_flush(hsotg, ep->fifo_index);\r\n}\r\nvoid dwc2_hsotg_disconnect(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned int ep;\r\nif (!hsotg->connected)\r\nreturn;\r\nhsotg->connected = 0;\r\nhsotg->test_mode = 0;\r\nfor (ep = 0; ep < hsotg->num_of_eps; ep++) {\r\nif (hsotg->eps_in[ep])\r\nkill_all_requests(hsotg, hsotg->eps_in[ep],\r\n-ESHUTDOWN);\r\nif (hsotg->eps_out[ep])\r\nkill_all_requests(hsotg, hsotg->eps_out[ep],\r\n-ESHUTDOWN);\r\n}\r\ncall_gadget(hsotg, disconnect);\r\nhsotg->lx_state = DWC2_L3;\r\n}\r\nstatic void dwc2_hsotg_irq_fifoempty(struct dwc2_hsotg *hsotg, bool periodic)\r\n{\r\nstruct dwc2_hsotg_ep *ep;\r\nint epno, ret;\r\nfor (epno = 0; epno < hsotg->num_of_eps; epno++) {\r\nep = index_to_ep(hsotg, epno, 1);\r\nif (!ep)\r\ncontinue;\r\nif (!ep->dir_in)\r\ncontinue;\r\nif ((periodic && !ep->periodic) ||\r\n(!periodic && ep->periodic))\r\ncontinue;\r\nret = dwc2_hsotg_trytx(hsotg, ep);\r\nif (ret < 0)\r\nbreak;\r\n}\r\n}\r\nvoid dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg,\r\nbool is_usb_reset)\r\n{\r\nu32 intmsk;\r\nu32 val;\r\nu32 usbcfg;\r\nu32 dcfg = 0;\r\nkill_all_requests(hsotg, hsotg->eps_out[0], -ECONNRESET);\r\nif (!is_usb_reset)\r\nif (dwc2_core_reset(hsotg, true))\r\nreturn;\r\nusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);\r\nusbcfg &= ~(GUSBCFG_TOUTCAL_MASK | GUSBCFG_PHYIF16 | GUSBCFG_SRPCAP |\r\nGUSBCFG_HNPCAP | GUSBCFG_USBTRDTIM_MASK);\r\nif (hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS &&\r\n(hsotg->params.speed == DWC2_SPEED_PARAM_FULL ||\r\nhsotg->params.speed == DWC2_SPEED_PARAM_LOW)) {\r\nusbcfg |= GUSBCFG_PHYSEL;\r\n} else {\r\nval = (hsotg->phyif == GUSBCFG_PHYIF8) ? 9 : 5;\r\nusbcfg |= hsotg->phyif | GUSBCFG_TOUTCAL(7) |\r\n(val << GUSBCFG_USBTRDTIM_SHIFT);\r\n}\r\ndwc2_writel(usbcfg, hsotg->regs + GUSBCFG);\r\ndwc2_hsotg_init_fifo(hsotg);\r\nif (!is_usb_reset)\r\n__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\ndcfg |= DCFG_EPMISCNT(1);\r\nswitch (hsotg->params.speed) {\r\ncase DWC2_SPEED_PARAM_LOW:\r\ndcfg |= DCFG_DEVSPD_LS;\r\nbreak;\r\ncase DWC2_SPEED_PARAM_FULL:\r\nif (hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS)\r\ndcfg |= DCFG_DEVSPD_FS48;\r\nelse\r\ndcfg |= DCFG_DEVSPD_FS;\r\nbreak;\r\ndefault:\r\ndcfg |= DCFG_DEVSPD_HS;\r\n}\r\ndwc2_writel(dcfg, hsotg->regs + DCFG);\r\ndwc2_writel(0xffffffff, hsotg->regs + GOTGINT);\r\ndwc2_writel(0xffffffff, hsotg->regs + GINTSTS);\r\nintmsk = GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |\r\nGINTSTS_GOUTNAKEFF | GINTSTS_GINNAKEFF |\r\nGINTSTS_USBRST | GINTSTS_RESETDET |\r\nGINTSTS_ENUMDONE | GINTSTS_OTGINT |\r\nGINTSTS_USBSUSP | GINTSTS_WKUPINT;\r\nif (!using_desc_dma(hsotg))\r\nintmsk |= GINTSTS_INCOMPL_SOIN | GINTSTS_INCOMPL_SOOUT;\r\nif (!hsotg->params.external_id_pin_ctl)\r\nintmsk |= GINTSTS_CONIDSTSCHNG;\r\ndwc2_writel(intmsk, hsotg->regs + GINTMSK);\r\nif (using_dma(hsotg)) {\r\ndwc2_writel(GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |\r\n(GAHBCFG_HBSTLEN_INCR4 << GAHBCFG_HBSTLEN_SHIFT),\r\nhsotg->regs + GAHBCFG);\r\nif (using_desc_dma(hsotg))\r\n__orr32(hsotg->regs + DCFG, DCFG_DESCDMA_EN);\r\n} else {\r\ndwc2_writel(((hsotg->dedicated_fifos) ?\r\n(GAHBCFG_NP_TXF_EMP_LVL |\r\nGAHBCFG_P_TXF_EMP_LVL) : 0) |\r\nGAHBCFG_GLBL_INTR_EN, hsotg->regs + GAHBCFG);\r\n}\r\ndwc2_writel(((hsotg->dedicated_fifos && !using_dma(hsotg)) ?\r\nDIEPMSK_TXFIFOEMPTY | DIEPMSK_INTKNTXFEMPMSK : 0) |\r\nDIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK |\r\nDIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK,\r\nhsotg->regs + DIEPMSK);\r\ndwc2_writel((using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |\r\nDOEPMSK_STSPHSERCVDMSK) : 0) |\r\nDOEPMSK_EPDISBLDMSK | DOEPMSK_AHBERRMSK |\r\nDOEPMSK_SETUPMSK,\r\nhsotg->regs + DOEPMSK);\r\nif (using_desc_dma(hsotg))\r\n__orr32(hsotg->regs + DOEPMSK, DOEPMSK_BNAMSK);\r\ndwc2_writel(0, hsotg->regs + DAINTMSK);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\ndwc2_readl(hsotg->regs + DIEPCTL0),\r\ndwc2_readl(hsotg->regs + DOEPCTL0));\r\ndwc2_hsotg_en_gsint(hsotg, GINTSTS_OEPINT | GINTSTS_IEPINT);\r\nif (!using_dma(hsotg))\r\ndwc2_hsotg_en_gsint(hsotg, GINTSTS_RXFLVL);\r\ndwc2_hsotg_ctrl_epint(hsotg, 0, 0, 1);\r\ndwc2_hsotg_ctrl_epint(hsotg, 0, 1, 1);\r\nif (!is_usb_reset) {\r\n__orr32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);\r\nudelay(10);\r\n__bic32(hsotg->regs + DCTL, DCTL_PWRONPRGDONE);\r\n}\r\ndev_dbg(hsotg->dev, "DCTL=0x%08x\n", dwc2_readl(hsotg->regs + DCTL));\r\ndwc2_writel(DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |\r\nDXEPTSIZ_XFERSIZE(8), hsotg->regs + DOEPTSIZ0);\r\ndwc2_writel(dwc2_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |\r\nDXEPCTL_CNAK | DXEPCTL_EPENA |\r\nDXEPCTL_USBACTEP,\r\nhsotg->regs + DOEPCTL0);\r\ndwc2_writel(dwc2_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |\r\nDXEPCTL_USBACTEP, hsotg->regs + DIEPCTL0);\r\ndwc2_hsotg_enqueue_setup(hsotg);\r\ndev_dbg(hsotg->dev, "EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\n",\r\ndwc2_readl(hsotg->regs + DIEPCTL0),\r\ndwc2_readl(hsotg->regs + DOEPCTL0));\r\nval = DCTL_CGOUTNAK | DCTL_CGNPINNAK;\r\nif (!is_usb_reset)\r\nval |= DCTL_SFTDISCON;\r\n__orr32(hsotg->regs + DCTL, val);\r\nmdelay(3);\r\nhsotg->lx_state = DWC2_L0;\r\n}\r\nstatic void dwc2_hsotg_core_disconnect(struct dwc2_hsotg *hsotg)\r\n{\r\n__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\n}\r\nvoid dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg)\r\n{\r\n__bic32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\n}\r\nstatic void dwc2_gadget_handle_incomplete_isoc_in(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep;\r\nu32 epctrl;\r\nu32 idx;\r\ndev_dbg(hsotg->dev, "Incomplete isoc in interrupt received:\n");\r\nfor (idx = 1; idx <= hsotg->num_of_eps; idx++) {\r\nhs_ep = hsotg->eps_in[idx];\r\nepctrl = dwc2_readl(hsotg->regs + DIEPCTL(idx));\r\nif ((epctrl & DXEPCTL_EPENA) && hs_ep->isochronous &&\r\ndwc2_gadget_target_frame_elapsed(hs_ep)) {\r\nepctrl |= DXEPCTL_SNAK;\r\nepctrl |= DXEPCTL_EPDIS;\r\ndwc2_writel(epctrl, hsotg->regs + DIEPCTL(idx));\r\n}\r\n}\r\ndwc2_writel(GINTSTS_INCOMPL_SOIN, hsotg->regs + GINTSTS);\r\n}\r\nstatic void dwc2_gadget_handle_incomplete_isoc_out(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 gintsts;\r\nu32 gintmsk;\r\nu32 epctrl;\r\nstruct dwc2_hsotg_ep *hs_ep;\r\nint idx;\r\ndev_dbg(hsotg->dev, "%s: GINTSTS_INCOMPL_SOOUT\n", __func__);\r\nfor (idx = 1; idx <= hsotg->num_of_eps; idx++) {\r\nhs_ep = hsotg->eps_out[idx];\r\nepctrl = dwc2_readl(hsotg->regs + DOEPCTL(idx));\r\nif ((epctrl & DXEPCTL_EPENA) && hs_ep->isochronous &&\r\ndwc2_gadget_target_frame_elapsed(hs_ep)) {\r\ngintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\ngintmsk |= GINTSTS_GOUTNAKEFF;\r\ndwc2_writel(gintmsk, hsotg->regs + GINTMSK);\r\ngintsts = dwc2_readl(hsotg->regs + GINTSTS);\r\nif (!(gintsts & GINTSTS_GOUTNAKEFF))\r\n__orr32(hsotg->regs + DCTL, DCTL_SGOUTNAK);\r\n}\r\n}\r\ndwc2_writel(GINTSTS_INCOMPL_SOOUT, hsotg->regs + GINTSTS);\r\n}\r\nstatic irqreturn_t dwc2_hsotg_irq(int irq, void *pw)\r\n{\r\nstruct dwc2_hsotg *hsotg = pw;\r\nint retry_count = 8;\r\nu32 gintsts;\r\nu32 gintmsk;\r\nif (!dwc2_is_device_mode(hsotg))\r\nreturn IRQ_NONE;\r\nspin_lock(&hsotg->lock);\r\nirq_retry:\r\ngintsts = dwc2_readl(hsotg->regs + GINTSTS);\r\ngintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\ndev_dbg(hsotg->dev, "%s: %08x %08x (%08x) retry %d\n",\r\n__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);\r\ngintsts &= gintmsk;\r\nif (gintsts & GINTSTS_RESETDET) {\r\ndev_dbg(hsotg->dev, "%s: USBRstDet\n", __func__);\r\ndwc2_writel(GINTSTS_RESETDET, hsotg->regs + GINTSTS);\r\nif (hsotg->lx_state == DWC2_L2) {\r\ndwc2_exit_hibernation(hsotg, true);\r\nhsotg->lx_state = DWC2_L0;\r\n}\r\n}\r\nif (gintsts & (GINTSTS_USBRST | GINTSTS_RESETDET)) {\r\nu32 usb_status = dwc2_readl(hsotg->regs + GOTGCTL);\r\nu32 connected = hsotg->connected;\r\ndev_dbg(hsotg->dev, "%s: USBRst\n", __func__);\r\ndev_dbg(hsotg->dev, "GNPTXSTS=%08x\n",\r\ndwc2_readl(hsotg->regs + GNPTXSTS));\r\ndwc2_writel(GINTSTS_USBRST, hsotg->regs + GINTSTS);\r\ndwc2_hsotg_disconnect(hsotg);\r\nif (usb_status & GOTGCTL_BSESVLD && connected)\r\ndwc2_hsotg_core_init_disconnected(hsotg, true);\r\n}\r\nif (gintsts & GINTSTS_ENUMDONE) {\r\ndwc2_writel(GINTSTS_ENUMDONE, hsotg->regs + GINTSTS);\r\ndwc2_hsotg_irq_enumdone(hsotg);\r\n}\r\nif (gintsts & (GINTSTS_OEPINT | GINTSTS_IEPINT)) {\r\nu32 daint = dwc2_readl(hsotg->regs + DAINT);\r\nu32 daintmsk = dwc2_readl(hsotg->regs + DAINTMSK);\r\nu32 daint_out, daint_in;\r\nint ep;\r\ndaint &= daintmsk;\r\ndaint_out = daint >> DAINT_OUTEP_SHIFT;\r\ndaint_in = daint & ~(daint_out << DAINT_OUTEP_SHIFT);\r\ndev_dbg(hsotg->dev, "%s: daint=%08x\n", __func__, daint);\r\nfor (ep = 0; ep < hsotg->num_of_eps && daint_out;\r\nep++, daint_out >>= 1) {\r\nif (daint_out & 1)\r\ndwc2_hsotg_epint(hsotg, ep, 0);\r\n}\r\nfor (ep = 0; ep < hsotg->num_of_eps && daint_in;\r\nep++, daint_in >>= 1) {\r\nif (daint_in & 1)\r\ndwc2_hsotg_epint(hsotg, ep, 1);\r\n}\r\n}\r\nif (gintsts & GINTSTS_NPTXFEMP) {\r\ndev_dbg(hsotg->dev, "NPTxFEmp\n");\r\ndwc2_hsotg_disable_gsint(hsotg, GINTSTS_NPTXFEMP);\r\ndwc2_hsotg_irq_fifoempty(hsotg, false);\r\n}\r\nif (gintsts & GINTSTS_PTXFEMP) {\r\ndev_dbg(hsotg->dev, "PTxFEmp\n");\r\ndwc2_hsotg_disable_gsint(hsotg, GINTSTS_PTXFEMP);\r\ndwc2_hsotg_irq_fifoempty(hsotg, true);\r\n}\r\nif (gintsts & GINTSTS_RXFLVL) {\r\ndwc2_hsotg_handle_rx(hsotg);\r\n}\r\nif (gintsts & GINTSTS_ERLYSUSP) {\r\ndev_dbg(hsotg->dev, "GINTSTS_ErlySusp\n");\r\ndwc2_writel(GINTSTS_ERLYSUSP, hsotg->regs + GINTSTS);\r\n}\r\nif (gintsts & GINTSTS_GOUTNAKEFF) {\r\nu8 idx;\r\nu32 epctrl;\r\nu32 gintmsk;\r\nstruct dwc2_hsotg_ep *hs_ep;\r\ngintmsk = dwc2_readl(hsotg->regs + GINTMSK);\r\ngintmsk &= ~GINTSTS_GOUTNAKEFF;\r\ndwc2_writel(gintmsk, hsotg->regs + GINTMSK);\r\ndev_dbg(hsotg->dev, "GOUTNakEff triggered\n");\r\nfor (idx = 1; idx <= hsotg->num_of_eps; idx++) {\r\nhs_ep = hsotg->eps_out[idx];\r\nepctrl = dwc2_readl(hsotg->regs + DOEPCTL(idx));\r\nif ((epctrl & DXEPCTL_EPENA) && hs_ep->isochronous) {\r\nepctrl |= DXEPCTL_SNAK;\r\nepctrl |= DXEPCTL_EPDIS;\r\ndwc2_writel(epctrl, hsotg->regs + DOEPCTL(idx));\r\n}\r\n}\r\n}\r\nif (gintsts & GINTSTS_GINNAKEFF) {\r\ndev_info(hsotg->dev, "GINNakEff triggered\n");\r\n__orr32(hsotg->regs + DCTL, DCTL_CGNPINNAK);\r\ndwc2_hsotg_dump(hsotg);\r\n}\r\nif (gintsts & GINTSTS_INCOMPL_SOIN)\r\ndwc2_gadget_handle_incomplete_isoc_in(hsotg);\r\nif (gintsts & GINTSTS_INCOMPL_SOOUT)\r\ndwc2_gadget_handle_incomplete_isoc_out(hsotg);\r\nif (gintsts & IRQ_RETRY_MASK && --retry_count > 0)\r\ngoto irq_retry;\r\nspin_unlock(&hsotg->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int dwc2_hsotg_wait_bit_set(struct dwc2_hsotg *hs_otg, u32 reg,\r\nu32 bit, u32 timeout)\r\n{\r\nu32 i;\r\nfor (i = 0; i < timeout; i++) {\r\nif (dwc2_readl(hs_otg->regs + reg) & bit)\r\nreturn 0;\r\nudelay(1);\r\n}\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void dwc2_hsotg_ep_stop_xfr(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep)\r\n{\r\nu32 epctrl_reg;\r\nu32 epint_reg;\r\nepctrl_reg = hs_ep->dir_in ? DIEPCTL(hs_ep->index) :\r\nDOEPCTL(hs_ep->index);\r\nepint_reg = hs_ep->dir_in ? DIEPINT(hs_ep->index) :\r\nDOEPINT(hs_ep->index);\r\ndev_dbg(hsotg->dev, "%s: stopping transfer on %s\n", __func__,\r\nhs_ep->name);\r\nif (hs_ep->dir_in) {\r\nif (hsotg->dedicated_fifos || hs_ep->periodic) {\r\n__orr32(hsotg->regs + epctrl_reg, DXEPCTL_SNAK);\r\nif (dwc2_hsotg_wait_bit_set(hsotg, epint_reg,\r\nDXEPINT_INEPNAKEFF, 100))\r\ndev_warn(hsotg->dev,\r\n"%s: timeout DIEPINT.NAKEFF\n",\r\n__func__);\r\n} else {\r\n__orr32(hsotg->regs + DCTL, DCTL_SGNPINNAK);\r\nif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS,\r\nGINTSTS_GINNAKEFF, 100))\r\ndev_warn(hsotg->dev,\r\n"%s: timeout GINTSTS.GINNAKEFF\n",\r\n__func__);\r\n}\r\n} else {\r\nif (!(dwc2_readl(hsotg->regs + GINTSTS) & GINTSTS_GOUTNAKEFF))\r\n__orr32(hsotg->regs + DCTL, DCTL_SGOUTNAK);\r\nif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS,\r\nGINTSTS_GOUTNAKEFF, 100))\r\ndev_warn(hsotg->dev, "%s: timeout GINTSTS.GOUTNAKEFF\n",\r\n__func__);\r\n}\r\n__orr32(hsotg->regs + epctrl_reg, DXEPCTL_EPDIS | DXEPCTL_SNAK);\r\nif (dwc2_hsotg_wait_bit_set(hsotg, epint_reg, DXEPINT_EPDISBLD, 100))\r\ndev_warn(hsotg->dev,\r\n"%s: timeout DOEPCTL.EPDisable\n", __func__);\r\n__orr32(hsotg->regs + epint_reg, DXEPINT_EPDISBLD);\r\nif (hs_ep->dir_in) {\r\nunsigned short fifo_index;\r\nif (hsotg->dedicated_fifos || hs_ep->periodic)\r\nfifo_index = hs_ep->fifo_index;\r\nelse\r\nfifo_index = 0;\r\ndwc2_flush_tx_fifo(hsotg, fifo_index);\r\nif (!hsotg->dedicated_fifos && !hs_ep->periodic)\r\n__orr32(hsotg->regs + DCTL, DCTL_CGNPINNAK);\r\n} else {\r\n__orr32(hsotg->regs + DCTL, DCTL_CGOUTNAK);\r\n}\r\n}\r\nstatic int dwc2_hsotg_ep_enable(struct usb_ep *ep,\r\nconst struct usb_endpoint_descriptor *desc)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nunsigned long flags;\r\nunsigned int index = hs_ep->index;\r\nu32 epctrl_reg;\r\nu32 epctrl;\r\nu32 mps;\r\nu32 mc;\r\nu32 mask;\r\nunsigned int dir_in;\r\nunsigned int i, val, size;\r\nint ret = 0;\r\ndev_dbg(hsotg->dev,\r\n"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\n",\r\n__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,\r\ndesc->wMaxPacketSize, desc->bInterval);\r\nif (index == 0) {\r\ndev_err(hsotg->dev, "%s: called for EP 0\n", __func__);\r\nreturn -EINVAL;\r\n}\r\ndir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;\r\nif (dir_in != hs_ep->dir_in) {\r\ndev_err(hsotg->dev, "%s: direction mismatch!\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmps = usb_endpoint_maxp(desc);\r\nmc = usb_endpoint_maxp_mult(desc);\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nepctrl = dwc2_readl(hsotg->regs + epctrl_reg);\r\ndev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x from 0x%08x\n",\r\n__func__, epctrl, epctrl_reg);\r\nif (using_desc_dma(hsotg) && !hs_ep->desc_list) {\r\nhs_ep->desc_list = dmam_alloc_coherent(hsotg->dev,\r\nMAX_DMA_DESC_NUM_GENERIC *\r\nsizeof(struct dwc2_dma_desc),\r\n&hs_ep->desc_list_dma, GFP_ATOMIC);\r\nif (!hs_ep->desc_list) {\r\nret = -ENOMEM;\r\ngoto error2;\r\n}\r\n}\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nepctrl &= ~(DXEPCTL_EPTYPE_MASK | DXEPCTL_MPS_MASK);\r\nepctrl |= DXEPCTL_MPS(mps);\r\nepctrl |= DXEPCTL_USBACTEP;\r\ndwc2_hsotg_set_ep_maxpacket(hsotg, hs_ep->index, mps, mc, dir_in);\r\nhs_ep->isochronous = 0;\r\nhs_ep->periodic = 0;\r\nhs_ep->halted = 0;\r\nhs_ep->interval = desc->bInterval;\r\nswitch (desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) {\r\ncase USB_ENDPOINT_XFER_ISOC:\r\nepctrl |= DXEPCTL_EPTYPE_ISO;\r\nepctrl |= DXEPCTL_SETEVENFR;\r\nhs_ep->isochronous = 1;\r\nhs_ep->interval = 1 << (desc->bInterval - 1);\r\nhs_ep->target_frame = TARGET_FRAME_INITIAL;\r\nhs_ep->isoc_chain_num = 0;\r\nhs_ep->next_desc = 0;\r\nif (dir_in) {\r\nhs_ep->periodic = 1;\r\nmask = dwc2_readl(hsotg->regs + DIEPMSK);\r\nmask |= DIEPMSK_NAKMSK;\r\ndwc2_writel(mask, hsotg->regs + DIEPMSK);\r\n} else {\r\nmask = dwc2_readl(hsotg->regs + DOEPMSK);\r\nmask |= DOEPMSK_OUTTKNEPDISMSK;\r\ndwc2_writel(mask, hsotg->regs + DOEPMSK);\r\n}\r\nbreak;\r\ncase USB_ENDPOINT_XFER_BULK:\r\nepctrl |= DXEPCTL_EPTYPE_BULK;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_INT:\r\nif (dir_in)\r\nhs_ep->periodic = 1;\r\nif (hsotg->gadget.speed == USB_SPEED_HIGH)\r\nhs_ep->interval = 1 << (desc->bInterval - 1);\r\nepctrl |= DXEPCTL_EPTYPE_INTERRUPT;\r\nbreak;\r\ncase USB_ENDPOINT_XFER_CONTROL:\r\nepctrl |= DXEPCTL_EPTYPE_CONTROL;\r\nbreak;\r\n}\r\nif (dir_in && hsotg->dedicated_fifos) {\r\nu32 fifo_index = 0;\r\nu32 fifo_size = UINT_MAX;\r\nsize = hs_ep->ep.maxpacket * hs_ep->mc;\r\nfor (i = 1; i < hsotg->num_of_eps; ++i) {\r\nif (hsotg->fifo_map & (1 << i))\r\ncontinue;\r\nval = dwc2_readl(hsotg->regs + DPTXFSIZN(i));\r\nval = (val >> FIFOSIZE_DEPTH_SHIFT) * 4;\r\nif (val < size)\r\ncontinue;\r\nif (val < fifo_size) {\r\nfifo_size = val;\r\nfifo_index = i;\r\n}\r\n}\r\nif (!fifo_index) {\r\ndev_err(hsotg->dev,\r\n"%s: No suitable fifo found\n", __func__);\r\nret = -ENOMEM;\r\ngoto error1;\r\n}\r\nhsotg->fifo_map |= 1 << fifo_index;\r\nepctrl |= DXEPCTL_TXFNUM(fifo_index);\r\nhs_ep->fifo_index = fifo_index;\r\nhs_ep->fifo_size = fifo_size;\r\n}\r\nif (index && !hs_ep->isochronous)\r\nepctrl |= DXEPCTL_SETD0PID;\r\ndev_dbg(hsotg->dev, "%s: write DxEPCTL=0x%08x\n",\r\n__func__, epctrl);\r\ndwc2_writel(epctrl, hsotg->regs + epctrl_reg);\r\ndev_dbg(hsotg->dev, "%s: read DxEPCTL=0x%08x\n",\r\n__func__, dwc2_readl(hsotg->regs + epctrl_reg));\r\ndwc2_hsotg_ctrl_epint(hsotg, index, dir_in, 1);\r\nerror1:\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nerror2:\r\nif (ret && using_desc_dma(hsotg) && hs_ep->desc_list) {\r\ndmam_free_coherent(hsotg->dev, MAX_DMA_DESC_NUM_GENERIC *\r\nsizeof(struct dwc2_dma_desc),\r\nhs_ep->desc_list, hs_ep->desc_list_dma);\r\nhs_ep->desc_list = NULL;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dwc2_hsotg_ep_disable(struct usb_ep *ep)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hsotg = hs_ep->parent;\r\nint dir_in = hs_ep->dir_in;\r\nint index = hs_ep->index;\r\nunsigned long flags;\r\nu32 epctrl_reg;\r\nu32 ctrl;\r\ndev_dbg(hsotg->dev, "%s(ep %p)\n", __func__, ep);\r\nif (ep == &hsotg->eps_out[0]->ep) {\r\ndev_err(hsotg->dev, "%s: called for ep0\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nctrl = dwc2_readl(hsotg->regs + epctrl_reg);\r\nif (ctrl & DXEPCTL_EPENA)\r\ndwc2_hsotg_ep_stop_xfr(hsotg, hs_ep);\r\nctrl &= ~DXEPCTL_EPENA;\r\nctrl &= ~DXEPCTL_USBACTEP;\r\nctrl |= DXEPCTL_SNAK;\r\ndev_dbg(hsotg->dev, "%s: DxEPCTL=0x%08x\n", __func__, ctrl);\r\ndwc2_writel(ctrl, hsotg->regs + epctrl_reg);\r\ndwc2_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);\r\nkill_all_requests(hsotg, hs_ep, -ESHUTDOWN);\r\nhsotg->fifo_map &= ~(1 << hs_ep->fifo_index);\r\nhs_ep->fifo_index = 0;\r\nhs_ep->fifo_size = 0;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic bool on_list(struct dwc2_hsotg_ep *ep, struct dwc2_hsotg_req *test)\r\n{\r\nstruct dwc2_hsotg_req *req, *treq;\r\nlist_for_each_entry_safe(req, treq, &ep->queue, queue) {\r\nif (req == test)\r\nreturn true;\r\n}\r\nreturn false;\r\n}\r\nstatic int dwc2_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\r\n{\r\nstruct dwc2_hsotg_req *hs_req = our_req(req);\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nunsigned long flags;\r\ndev_dbg(hs->dev, "ep_dequeue(%p,%p)\n", ep, req);\r\nspin_lock_irqsave(&hs->lock, flags);\r\nif (!on_list(hs_ep, hs_req)) {\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn -EINVAL;\r\n}\r\nif (req == &hs_ep->req->req)\r\ndwc2_hsotg_ep_stop_xfr(hs, hs_ep);\r\ndwc2_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_ep_sethalt(struct usb_ep *ep, int value, bool now)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nint index = hs_ep->index;\r\nu32 epreg;\r\nu32 epctl;\r\nu32 xfertype;\r\ndev_info(hs->dev, "%s(ep %p %s, %d)\n", __func__, ep, ep->name, value);\r\nif (index == 0) {\r\nif (value)\r\ndwc2_hsotg_stall_ep0(hs);\r\nelse\r\ndev_warn(hs->dev,\r\n"%s: can't clear halt on ep0\n", __func__);\r\nreturn 0;\r\n}\r\nif (hs_ep->isochronous) {\r\ndev_err(hs->dev, "%s is Isochronous Endpoint\n", ep->name);\r\nreturn -EINVAL;\r\n}\r\nif (!now && value && !list_empty(&hs_ep->queue)) {\r\ndev_dbg(hs->dev, "%s request is pending, cannot halt\n",\r\nep->name);\r\nreturn -EAGAIN;\r\n}\r\nif (hs_ep->dir_in) {\r\nepreg = DIEPCTL(index);\r\nepctl = dwc2_readl(hs->regs + epreg);\r\nif (value) {\r\nepctl |= DXEPCTL_STALL | DXEPCTL_SNAK;\r\nif (epctl & DXEPCTL_EPENA)\r\nepctl |= DXEPCTL_EPDIS;\r\n} else {\r\nepctl &= ~DXEPCTL_STALL;\r\nxfertype = epctl & DXEPCTL_EPTYPE_MASK;\r\nif (xfertype == DXEPCTL_EPTYPE_BULK ||\r\nxfertype == DXEPCTL_EPTYPE_INTERRUPT)\r\nepctl |= DXEPCTL_SETD0PID;\r\n}\r\ndwc2_writel(epctl, hs->regs + epreg);\r\n} else {\r\nepreg = DOEPCTL(index);\r\nepctl = dwc2_readl(hs->regs + epreg);\r\nif (value) {\r\nepctl |= DXEPCTL_STALL;\r\n} else {\r\nepctl &= ~DXEPCTL_STALL;\r\nxfertype = epctl & DXEPCTL_EPTYPE_MASK;\r\nif (xfertype == DXEPCTL_EPTYPE_BULK ||\r\nxfertype == DXEPCTL_EPTYPE_INTERRUPT)\r\nepctl |= DXEPCTL_SETD0PID;\r\n}\r\ndwc2_writel(epctl, hs->regs + epreg);\r\n}\r\nhs_ep->halted = value;\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)\r\n{\r\nstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\r\nstruct dwc2_hsotg *hs = hs_ep->parent;\r\nunsigned long flags = 0;\r\nint ret = 0;\r\nspin_lock_irqsave(&hs->lock, flags);\r\nret = dwc2_hsotg_ep_sethalt(ep, value, false);\r\nspin_unlock_irqrestore(&hs->lock, flags);\r\nreturn ret;\r\n}\r\nstatic void dwc2_hsotg_init(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 trdtim;\r\nu32 usbcfg;\r\ndwc2_writel(DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |\r\nDIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,\r\nhsotg->regs + DIEPMSK);\r\ndwc2_writel(DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |\r\nDOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,\r\nhsotg->regs + DOEPMSK);\r\ndwc2_writel(0, hsotg->regs + DAINTMSK);\r\n__orr32(hsotg->regs + DCTL, DCTL_SFTDISCON);\r\ndev_dbg(hsotg->dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",\r\ndwc2_readl(hsotg->regs + GRXFSIZ),\r\ndwc2_readl(hsotg->regs + GNPTXFSIZ));\r\ndwc2_hsotg_init_fifo(hsotg);\r\nusbcfg = dwc2_readl(hsotg->regs + GUSBCFG);\r\nusbcfg &= ~(GUSBCFG_TOUTCAL_MASK | GUSBCFG_PHYIF16 | GUSBCFG_SRPCAP |\r\nGUSBCFG_HNPCAP | GUSBCFG_USBTRDTIM_MASK);\r\ntrdtim = (hsotg->phyif == GUSBCFG_PHYIF8) ? 9 : 5;\r\nusbcfg |= hsotg->phyif | GUSBCFG_TOUTCAL(7) |\r\n(trdtim << GUSBCFG_USBTRDTIM_SHIFT);\r\ndwc2_writel(usbcfg, hsotg->regs + GUSBCFG);\r\nif (using_dma(hsotg))\r\n__orr32(hsotg->regs + GAHBCFG, GAHBCFG_DMA_EN);\r\n}\r\nstatic int dwc2_hsotg_udc_start(struct usb_gadget *gadget,\r\nstruct usb_gadget_driver *driver)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags;\r\nint ret;\r\nif (!hsotg) {\r\npr_err("%s: called with no device\n", __func__);\r\nreturn -ENODEV;\r\n}\r\nif (!driver) {\r\ndev_err(hsotg->dev, "%s: no driver\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (driver->max_speed < USB_SPEED_FULL)\r\ndev_err(hsotg->dev, "%s: bad speed\n", __func__);\r\nif (!driver->setup) {\r\ndev_err(hsotg->dev, "%s: missing entry points\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nWARN_ON(hsotg->driver);\r\ndriver->driver.bus = NULL;\r\nhsotg->driver = driver;\r\nhsotg->gadget.dev.of_node = hsotg->dev->of_node;\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) {\r\nret = dwc2_lowlevel_hw_enable(hsotg);\r\nif (ret)\r\ngoto err;\r\n}\r\nif (!IS_ERR_OR_NULL(hsotg->uphy))\r\notg_set_peripheral(hsotg->uphy->otg, &hsotg->gadget);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (dwc2_hw_is_device(hsotg)) {\r\ndwc2_hsotg_init(hsotg);\r\ndwc2_hsotg_core_init_disconnected(hsotg, false);\r\n}\r\nhsotg->enabled = 0;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\ndev_info(hsotg->dev, "bound driver %s\n", driver->driver.name);\r\nreturn 0;\r\nerr:\r\nhsotg->driver = NULL;\r\nreturn ret;\r\n}\r\nstatic int dwc2_hsotg_udc_stop(struct usb_gadget *gadget)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags = 0;\r\nint ep;\r\nif (!hsotg)\r\nreturn -ENODEV;\r\nfor (ep = 1; ep < hsotg->num_of_eps; ep++) {\r\nif (hsotg->eps_in[ep])\r\ndwc2_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);\r\nif (hsotg->eps_out[ep])\r\ndwc2_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);\r\n}\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nhsotg->driver = NULL;\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nhsotg->enabled = 0;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nif (!IS_ERR_OR_NULL(hsotg->uphy))\r\notg_set_peripheral(hsotg->uphy->otg, NULL);\r\nif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\r\ndwc2_lowlevel_hw_disable(hsotg);\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_gadget_getframe(struct usb_gadget *gadget)\r\n{\r\nreturn dwc2_hsotg_read_frameno(to_hsotg(gadget));\r\n}\r\nstatic int dwc2_hsotg_pullup(struct usb_gadget *gadget, int is_on)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags = 0;\r\ndev_dbg(hsotg->dev, "%s: is_on: %d op_state: %d\n", __func__, is_on,\r\nhsotg->op_state);\r\nif (hsotg->op_state != OTG_STATE_B_PERIPHERAL) {\r\nhsotg->enabled = is_on;\r\nreturn 0;\r\n}\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (is_on) {\r\nhsotg->enabled = 1;\r\ndwc2_hsotg_core_init_disconnected(hsotg, false);\r\ndwc2_hsotg_core_connect(hsotg);\r\n} else {\r\ndwc2_hsotg_core_disconnect(hsotg);\r\ndwc2_hsotg_disconnect(hsotg);\r\nhsotg->enabled = 0;\r\n}\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_vbus_session(struct usb_gadget *gadget, int is_active)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nunsigned long flags;\r\ndev_dbg(hsotg->dev, "%s: is_active: %d\n", __func__, is_active);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (hsotg->lx_state == DWC2_L2)\r\ndwc2_exit_hibernation(hsotg, false);\r\nif (is_active) {\r\nhsotg->op_state = OTG_STATE_B_PERIPHERAL;\r\ndwc2_hsotg_core_init_disconnected(hsotg, false);\r\nif (hsotg->enabled)\r\ndwc2_hsotg_core_connect(hsotg);\r\n} else {\r\ndwc2_hsotg_core_disconnect(hsotg);\r\ndwc2_hsotg_disconnect(hsotg);\r\n}\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int dwc2_hsotg_vbus_draw(struct usb_gadget *gadget, unsigned int mA)\r\n{\r\nstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\r\nif (IS_ERR_OR_NULL(hsotg->uphy))\r\nreturn -ENOTSUPP;\r\nreturn usb_phy_set_power(hsotg->uphy, mA);\r\n}\r\nstatic void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,\r\nstruct dwc2_hsotg_ep *hs_ep,\r\nint epnum,\r\nbool dir_in)\r\n{\r\nchar *dir;\r\nif (epnum == 0)\r\ndir = "";\r\nelse if (dir_in)\r\ndir = "in";\r\nelse\r\ndir = "out";\r\nhs_ep->dir_in = dir_in;\r\nhs_ep->index = epnum;\r\nsnprintf(hs_ep->name, sizeof(hs_ep->name), "ep%d%s", epnum, dir);\r\nINIT_LIST_HEAD(&hs_ep->queue);\r\nINIT_LIST_HEAD(&hs_ep->ep.ep_list);\r\nif (epnum)\r\nlist_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);\r\nhs_ep->parent = hsotg;\r\nhs_ep->ep.name = hs_ep->name;\r\nif (hsotg->params.speed == DWC2_SPEED_PARAM_LOW)\r\nusb_ep_set_maxpacket_limit(&hs_ep->ep, 8);\r\nelse\r\nusb_ep_set_maxpacket_limit(&hs_ep->ep,\r\nepnum ? 1024 : EP0_MPS_LIMIT);\r\nhs_ep->ep.ops = &dwc2_hsotg_ep_ops;\r\nif (epnum == 0) {\r\nhs_ep->ep.caps.type_control = true;\r\n} else {\r\nif (hsotg->params.speed != DWC2_SPEED_PARAM_LOW) {\r\nhs_ep->ep.caps.type_iso = true;\r\nhs_ep->ep.caps.type_bulk = true;\r\n}\r\nhs_ep->ep.caps.type_int = true;\r\n}\r\nif (dir_in)\r\nhs_ep->ep.caps.dir_in = true;\r\nelse\r\nhs_ep->ep.caps.dir_out = true;\r\nif (using_dma(hsotg)) {\r\nu32 next = DXEPCTL_NEXTEP((epnum + 1) % 15);\r\nif (dir_in)\r\ndwc2_writel(next, hsotg->regs + DIEPCTL(epnum));\r\nelse\r\ndwc2_writel(next, hsotg->regs + DOEPCTL(epnum));\r\n}\r\n}\r\nstatic int dwc2_hsotg_hw_cfg(struct dwc2_hsotg *hsotg)\r\n{\r\nu32 cfg;\r\nu32 ep_type;\r\nu32 i;\r\nhsotg->num_of_eps = hsotg->hw_params.num_dev_ep;\r\nhsotg->num_of_eps++;\r\nhsotg->eps_in[0] = devm_kzalloc(hsotg->dev,\r\nsizeof(struct dwc2_hsotg_ep),\r\nGFP_KERNEL);\r\nif (!hsotg->eps_in[0])\r\nreturn -ENOMEM;\r\nhsotg->eps_out[0] = hsotg->eps_in[0];\r\ncfg = hsotg->hw_params.dev_ep_dirs;\r\nfor (i = 1, cfg >>= 2; i < hsotg->num_of_eps; i++, cfg >>= 2) {\r\nep_type = cfg & 3;\r\nif (!(ep_type & 2)) {\r\nhsotg->eps_in[i] = devm_kzalloc(hsotg->dev,\r\nsizeof(struct dwc2_hsotg_ep), GFP_KERNEL);\r\nif (!hsotg->eps_in[i])\r\nreturn -ENOMEM;\r\n}\r\nif (!(ep_type & 1)) {\r\nhsotg->eps_out[i] = devm_kzalloc(hsotg->dev,\r\nsizeof(struct dwc2_hsotg_ep), GFP_KERNEL);\r\nif (!hsotg->eps_out[i])\r\nreturn -ENOMEM;\r\n}\r\n}\r\nhsotg->fifo_mem = hsotg->hw_params.total_fifo_size;\r\nhsotg->dedicated_fifos = hsotg->hw_params.en_multiple_tx_fifo;\r\ndev_info(hsotg->dev, "EPs: %d, %s fifos, %d entries in SPRAM\n",\r\nhsotg->num_of_eps,\r\nhsotg->dedicated_fifos ? "dedicated" : "shared",\r\nhsotg->fifo_mem);\r\nreturn 0;\r\n}\r\nstatic void dwc2_hsotg_dump(struct dwc2_hsotg *hsotg)\r\n{\r\n#ifdef DEBUG\r\nstruct device *dev = hsotg->dev;\r\nvoid __iomem *regs = hsotg->regs;\r\nu32 val;\r\nint idx;\r\ndev_info(dev, "DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\n",\r\ndwc2_readl(regs + DCFG), dwc2_readl(regs + DCTL),\r\ndwc2_readl(regs + DIEPMSK));\r\ndev_info(dev, "GAHBCFG=0x%08x, GHWCFG1=0x%08x\n",\r\ndwc2_readl(regs + GAHBCFG), dwc2_readl(regs + GHWCFG1));\r\ndev_info(dev, "GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\n",\r\ndwc2_readl(regs + GRXFSIZ), dwc2_readl(regs + GNPTXFSIZ));\r\nfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\r\nval = dwc2_readl(regs + DPTXFSIZN(idx));\r\ndev_info(dev, "DPTx[%d] FSize=%d, StAddr=0x%08x\n", idx,\r\nval >> FIFOSIZE_DEPTH_SHIFT,\r\nval & FIFOSIZE_STARTADDR_MASK);\r\n}\r\nfor (idx = 0; idx < hsotg->num_of_eps; idx++) {\r\ndev_info(dev,\r\n"ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n", idx,\r\ndwc2_readl(regs + DIEPCTL(idx)),\r\ndwc2_readl(regs + DIEPTSIZ(idx)),\r\ndwc2_readl(regs + DIEPDMA(idx)));\r\nval = dwc2_readl(regs + DOEPCTL(idx));\r\ndev_info(dev,\r\n"ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\n",\r\nidx, dwc2_readl(regs + DOEPCTL(idx)),\r\ndwc2_readl(regs + DOEPTSIZ(idx)),\r\ndwc2_readl(regs + DOEPDMA(idx)));\r\n}\r\ndev_info(dev, "DVBUSDIS=0x%08x, DVBUSPULSE=%08x\n",\r\ndwc2_readl(regs + DVBUSDIS), dwc2_readl(regs + DVBUSPULSE));\r\n#endif\r\n}\r\nint dwc2_gadget_init(struct dwc2_hsotg *hsotg, int irq)\r\n{\r\nstruct device *dev = hsotg->dev;\r\nint epnum;\r\nint ret;\r\ndev_dbg(dev, "NonPeriodic TXFIFO size: %d\n",\r\nhsotg->params.g_np_tx_fifo_size);\r\ndev_dbg(dev, "RXFIFO size: %d\n", hsotg->params.g_rx_fifo_size);\r\nhsotg->gadget.max_speed = USB_SPEED_HIGH;\r\nhsotg->gadget.ops = &dwc2_hsotg_gadget_ops;\r\nhsotg->gadget.name = dev_name(dev);\r\nif (hsotg->dr_mode == USB_DR_MODE_OTG)\r\nhsotg->gadget.is_otg = 1;\r\nelse if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\r\nhsotg->op_state = OTG_STATE_B_PERIPHERAL;\r\nret = dwc2_hsotg_hw_cfg(hsotg);\r\nif (ret) {\r\ndev_err(hsotg->dev, "Hardware configuration failed: %d\n", ret);\r\nreturn ret;\r\n}\r\nhsotg->ctrl_buff = devm_kzalloc(hsotg->dev,\r\nDWC2_CTRL_BUFF_SIZE, GFP_KERNEL);\r\nif (!hsotg->ctrl_buff)\r\nreturn -ENOMEM;\r\nhsotg->ep0_buff = devm_kzalloc(hsotg->dev,\r\nDWC2_CTRL_BUFF_SIZE, GFP_KERNEL);\r\nif (!hsotg->ep0_buff)\r\nreturn -ENOMEM;\r\nif (using_desc_dma(hsotg)) {\r\nret = dwc2_gadget_alloc_ctrl_desc_chains(hsotg);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nret = devm_request_irq(hsotg->dev, irq, dwc2_hsotg_irq, IRQF_SHARED,\r\ndev_name(hsotg->dev), hsotg);\r\nif (ret < 0) {\r\ndev_err(dev, "cannot claim IRQ for gadget\n");\r\nreturn ret;\r\n}\r\nif (hsotg->num_of_eps == 0) {\r\ndev_err(dev, "wrong number of EPs (zero)\n");\r\nreturn -EINVAL;\r\n}\r\nINIT_LIST_HEAD(&hsotg->gadget.ep_list);\r\nhsotg->gadget.ep0 = &hsotg->eps_out[0]->ep;\r\nhsotg->ctrl_req = dwc2_hsotg_ep_alloc_request(&hsotg->eps_out[0]->ep,\r\nGFP_KERNEL);\r\nif (!hsotg->ctrl_req) {\r\ndev_err(dev, "failed to allocate ctrl req\n");\r\nreturn -ENOMEM;\r\n}\r\nfor (epnum = 0; epnum < hsotg->num_of_eps; epnum++) {\r\nif (hsotg->eps_in[epnum])\r\ndwc2_hsotg_initep(hsotg, hsotg->eps_in[epnum],\r\nepnum, 1);\r\nif (hsotg->eps_out[epnum])\r\ndwc2_hsotg_initep(hsotg, hsotg->eps_out[epnum],\r\nepnum, 0);\r\n}\r\nret = usb_add_gadget_udc(dev, &hsotg->gadget);\r\nif (ret)\r\nreturn ret;\r\ndwc2_hsotg_dump(hsotg);\r\nreturn 0;\r\n}\r\nint dwc2_hsotg_remove(struct dwc2_hsotg *hsotg)\r\n{\r\nusb_del_gadget_udc(&hsotg->gadget);\r\nreturn 0;\r\n}\r\nint dwc2_hsotg_suspend(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned long flags;\r\nif (hsotg->lx_state != DWC2_L0)\r\nreturn 0;\r\nif (hsotg->driver) {\r\nint ep;\r\ndev_info(hsotg->dev, "suspending usb gadget %s\n",\r\nhsotg->driver->driver.name);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\nif (hsotg->enabled)\r\ndwc2_hsotg_core_disconnect(hsotg);\r\ndwc2_hsotg_disconnect(hsotg);\r\nhsotg->gadget.speed = USB_SPEED_UNKNOWN;\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\nfor (ep = 0; ep < hsotg->num_of_eps; ep++) {\r\nif (hsotg->eps_in[ep])\r\ndwc2_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);\r\nif (hsotg->eps_out[ep])\r\ndwc2_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint dwc2_hsotg_resume(struct dwc2_hsotg *hsotg)\r\n{\r\nunsigned long flags;\r\nif (hsotg->lx_state == DWC2_L2)\r\nreturn 0;\r\nif (hsotg->driver) {\r\ndev_info(hsotg->dev, "resuming usb gadget %s\n",\r\nhsotg->driver->driver.name);\r\nspin_lock_irqsave(&hsotg->lock, flags);\r\ndwc2_hsotg_core_init_disconnected(hsotg, false);\r\nif (hsotg->enabled)\r\ndwc2_hsotg_core_connect(hsotg);\r\nspin_unlock_irqrestore(&hsotg->lock, flags);\r\n}\r\nreturn 0;\r\n}\r\nint dwc2_backup_device_registers(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct dwc2_dregs_backup *dr;\r\nint i;\r\ndev_dbg(hsotg->dev, "%s\n", __func__);\r\ndr = &hsotg->dr_backup;\r\ndr->dcfg = dwc2_readl(hsotg->regs + DCFG);\r\ndr->dctl = dwc2_readl(hsotg->regs + DCTL);\r\ndr->daintmsk = dwc2_readl(hsotg->regs + DAINTMSK);\r\ndr->diepmsk = dwc2_readl(hsotg->regs + DIEPMSK);\r\ndr->doepmsk = dwc2_readl(hsotg->regs + DOEPMSK);\r\nfor (i = 0; i < hsotg->num_of_eps; i++) {\r\ndr->diepctl[i] = dwc2_readl(hsotg->regs + DIEPCTL(i));\r\nif (dr->diepctl[i] & DXEPCTL_DPID)\r\ndr->diepctl[i] |= DXEPCTL_SETD1PID;\r\nelse\r\ndr->diepctl[i] |= DXEPCTL_SETD0PID;\r\ndr->dieptsiz[i] = dwc2_readl(hsotg->regs + DIEPTSIZ(i));\r\ndr->diepdma[i] = dwc2_readl(hsotg->regs + DIEPDMA(i));\r\ndr->doepctl[i] = dwc2_readl(hsotg->regs + DOEPCTL(i));\r\nif (dr->doepctl[i] & DXEPCTL_DPID)\r\ndr->doepctl[i] |= DXEPCTL_SETD1PID;\r\nelse\r\ndr->doepctl[i] |= DXEPCTL_SETD0PID;\r\ndr->doeptsiz[i] = dwc2_readl(hsotg->regs + DOEPTSIZ(i));\r\ndr->doepdma[i] = dwc2_readl(hsotg->regs + DOEPDMA(i));\r\n}\r\ndr->valid = true;\r\nreturn 0;\r\n}\r\nint dwc2_restore_device_registers(struct dwc2_hsotg *hsotg)\r\n{\r\nstruct dwc2_dregs_backup *dr;\r\nu32 dctl;\r\nint i;\r\ndev_dbg(hsotg->dev, "%s\n", __func__);\r\ndr = &hsotg->dr_backup;\r\nif (!dr->valid) {\r\ndev_err(hsotg->dev, "%s: no device registers to restore\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\ndr->valid = false;\r\ndwc2_writel(dr->dcfg, hsotg->regs + DCFG);\r\ndwc2_writel(dr->dctl, hsotg->regs + DCTL);\r\ndwc2_writel(dr->daintmsk, hsotg->regs + DAINTMSK);\r\ndwc2_writel(dr->diepmsk, hsotg->regs + DIEPMSK);\r\ndwc2_writel(dr->doepmsk, hsotg->regs + DOEPMSK);\r\nfor (i = 0; i < hsotg->num_of_eps; i++) {\r\ndwc2_writel(dr->diepctl[i], hsotg->regs + DIEPCTL(i));\r\ndwc2_writel(dr->dieptsiz[i], hsotg->regs + DIEPTSIZ(i));\r\ndwc2_writel(dr->diepdma[i], hsotg->regs + DIEPDMA(i));\r\ndwc2_writel(dr->doepctl[i], hsotg->regs + DOEPCTL(i));\r\ndwc2_writel(dr->doeptsiz[i], hsotg->regs + DOEPTSIZ(i));\r\ndwc2_writel(dr->doepdma[i], hsotg->regs + DOEPDMA(i));\r\n}\r\ndctl = dwc2_readl(hsotg->regs + DCTL);\r\ndctl |= DCTL_PWRONPRGDONE;\r\ndwc2_writel(dctl, hsotg->regs + DCTL);\r\nreturn 0;\r\n}
