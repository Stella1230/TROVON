static void fmi_set_pins(void *handle, u8 pins)\r\n{\r\nstruct fmi *fmi = handle;\r\nu8 bits = FMI_BIT_TUN_STRQ;\r\nif (!fmi->mute)\r\nbits |= FMI_BIT_VOL_SW;\r\nif (pins & LM7000_DATA)\r\nbits |= FMI_BIT_TUN_DATA;\r\nif (pins & LM7000_CLK)\r\nbits |= FMI_BIT_TUN_CLK;\r\nif (pins & LM7000_CE)\r\nbits |= FMI_BIT_TUN_CE;\r\nmutex_lock(&fmi->lock);\r\noutb_p(bits, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\n}\r\nstatic inline void fmi_mute(struct fmi *fmi)\r\n{\r\nmutex_lock(&fmi->lock);\r\noutb(0x00, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\n}\r\nstatic inline void fmi_unmute(struct fmi *fmi)\r\n{\r\nmutex_lock(&fmi->lock);\r\noutb(0x08, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\n}\r\nstatic inline int fmi_getsigstr(struct fmi *fmi)\r\n{\r\nint val;\r\nint res;\r\nmutex_lock(&fmi->lock);\r\nval = fmi->mute ? 0x00 : 0x08;\r\noutb(val, fmi->io);\r\noutb(val | 0x10, fmi->io);\r\nmsleep(143);\r\nres = (int)inb(fmi->io + 1);\r\noutb(val, fmi->io);\r\nmutex_unlock(&fmi->lock);\r\nreturn (res & 2) ? 0 : 0xFFFF;\r\n}\r\nstatic void fmi_set_freq(struct fmi *fmi)\r\n{\r\nfmi->curfreq = clamp(fmi->curfreq, RSF16_MINFREQ, RSF16_MAXFREQ);\r\nlm7000_set_freq((fmi->curfreq / 800) * 800, fmi, fmi_set_pins);\r\n}\r\nstatic int vidioc_querycap(struct file *file, void *priv,\r\nstruct v4l2_capability *v)\r\n{\r\nstrlcpy(v->driver, "radio-sf16fmi", sizeof(v->driver));\r\nstrlcpy(v->card, "SF16-FMI/FMP/FMD radio", sizeof(v->card));\r\nstrlcpy(v->bus_info, "ISA:radio-sf16fmi", sizeof(v->bus_info));\r\nv->device_caps = V4L2_CAP_TUNER | V4L2_CAP_RADIO;\r\nv->capabilities = v->device_caps | V4L2_CAP_DEVICE_CAPS;\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_tuner(struct file *file, void *priv,\r\nstruct v4l2_tuner *v)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nif (v->index > 0)\r\nreturn -EINVAL;\r\nstrlcpy(v->name, "FM", sizeof(v->name));\r\nv->type = V4L2_TUNER_RADIO;\r\nv->rangelow = RSF16_MINFREQ;\r\nv->rangehigh = RSF16_MAXFREQ;\r\nv->rxsubchans = V4L2_TUNER_SUB_MONO | V4L2_TUNER_SUB_STEREO;\r\nv->capability = V4L2_TUNER_CAP_STEREO | V4L2_TUNER_CAP_LOW;\r\nv->audmode = V4L2_TUNER_MODE_STEREO;\r\nv->signal = fmi_getsigstr(fmi);\r\nreturn 0;\r\n}\r\nstatic int vidioc_s_tuner(struct file *file, void *priv,\r\nconst struct v4l2_tuner *v)\r\n{\r\nreturn v->index ? -EINVAL : 0;\r\n}\r\nstatic int vidioc_s_frequency(struct file *file, void *priv,\r\nconst struct v4l2_frequency *f)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nif (f->tuner != 0 || f->type != V4L2_TUNER_RADIO)\r\nreturn -EINVAL;\r\nfmi->curfreq = f->frequency;\r\nfmi_set_freq(fmi);\r\nreturn 0;\r\n}\r\nstatic int vidioc_g_frequency(struct file *file, void *priv,\r\nstruct v4l2_frequency *f)\r\n{\r\nstruct fmi *fmi = video_drvdata(file);\r\nif (f->tuner != 0)\r\nreturn -EINVAL;\r\nf->type = V4L2_TUNER_RADIO;\r\nf->frequency = fmi->curfreq;\r\nreturn 0;\r\n}\r\nstatic int fmi_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct fmi *fmi = container_of(ctrl->handler, struct fmi, hdl);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_AUDIO_MUTE:\r\nif (ctrl->val)\r\nfmi_mute(fmi);\r\nelse\r\nfmi_unmute(fmi);\r\nfmi->mute = ctrl->val;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init isapnp_fmi_probe(void)\r\n{\r\nint i = 0;\r\nwhile (id_table[i].card_vendor != 0 && dev == NULL) {\r\ndev = pnp_find_dev(NULL, id_table[i].vendor,\r\nid_table[i].function, NULL);\r\ni++;\r\n}\r\nif (!dev)\r\nreturn -ENODEV;\r\nif (pnp_device_attach(dev) < 0)\r\nreturn -EAGAIN;\r\nif (pnp_activate_dev(dev) < 0) {\r\nprintk(KERN_ERR "radio-sf16fmi: PnP configure failed (out of resources?)\n");\r\npnp_device_detach(dev);\r\nreturn -ENOMEM;\r\n}\r\nif (!pnp_port_valid(dev, 0)) {\r\npnp_device_detach(dev);\r\nreturn -ENODEV;\r\n}\r\ni = pnp_port_start(dev, 0);\r\nprintk(KERN_INFO "radio-sf16fmi: PnP reports card at %#x\n", i);\r\nreturn i;\r\n}\r\nstatic int __init fmi_init(void)\r\n{\r\nstruct fmi *fmi = &fmi_card;\r\nstruct v4l2_device *v4l2_dev = &fmi->v4l2_dev;\r\nstruct v4l2_ctrl_handler *hdl = &fmi->hdl;\r\nint res, i;\r\nint probe_ports[] = { 0, 0x284, 0x384 };\r\nif (io < 0) {\r\nfor (i = 0; i < ARRAY_SIZE(probe_ports); i++) {\r\nio = probe_ports[i];\r\nif (io == 0) {\r\nio = isapnp_fmi_probe();\r\nif (io < 0)\r\ncontinue;\r\npnp_attached = true;\r\n}\r\nif (!request_region(io, 2, "radio-sf16fmi")) {\r\nif (pnp_attached)\r\npnp_device_detach(dev);\r\nio = -1;\r\ncontinue;\r\n}\r\nif (pnp_attached ||\r\n((inb(io) & 0xf9) == 0xf9 && (inb(io) & 0x4) == 0))\r\nbreak;\r\nrelease_region(io, 2);\r\nio = -1;\r\n}\r\n} else {\r\nif (!request_region(io, 2, "radio-sf16fmi")) {\r\nprintk(KERN_ERR "radio-sf16fmi: port %#x already in use\n", io);\r\nreturn -EBUSY;\r\n}\r\nif (inb(io) == 0xff) {\r\nprintk(KERN_ERR "radio-sf16fmi: card not present at %#x\n", io);\r\nrelease_region(io, 2);\r\nreturn -ENODEV;\r\n}\r\n}\r\nif (io < 0) {\r\nprintk(KERN_ERR "radio-sf16fmi: no cards found\n");\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(v4l2_dev->name, "sf16fmi", sizeof(v4l2_dev->name));\r\nfmi->io = io;\r\nres = v4l2_device_register(NULL, v4l2_dev);\r\nif (res < 0) {\r\nrelease_region(fmi->io, 2);\r\nif (pnp_attached)\r\npnp_device_detach(dev);\r\nv4l2_err(v4l2_dev, "Could not register v4l2_device\n");\r\nreturn res;\r\n}\r\nv4l2_ctrl_handler_init(hdl, 1);\r\nv4l2_ctrl_new_std(hdl, &fmi_ctrl_ops,\r\nV4L2_CID_AUDIO_MUTE, 0, 1, 1, 1);\r\nv4l2_dev->ctrl_handler = hdl;\r\nif (hdl->error) {\r\nres = hdl->error;\r\nv4l2_err(v4l2_dev, "Could not register controls\n");\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(v4l2_dev);\r\nreturn res;\r\n}\r\nstrlcpy(fmi->vdev.name, v4l2_dev->name, sizeof(fmi->vdev.name));\r\nfmi->vdev.v4l2_dev = v4l2_dev;\r\nfmi->vdev.fops = &fmi_fops;\r\nfmi->vdev.ioctl_ops = &fmi_ioctl_ops;\r\nfmi->vdev.release = video_device_release_empty;\r\nvideo_set_drvdata(&fmi->vdev, fmi);\r\nmutex_init(&fmi->lock);\r\nfmi->mute = true;\r\nfmi->curfreq = RSF16_MINFREQ;\r\nfmi_set_freq(fmi);\r\nif (video_register_device(&fmi->vdev, VFL_TYPE_RADIO, radio_nr) < 0) {\r\nv4l2_ctrl_handler_free(hdl);\r\nv4l2_device_unregister(v4l2_dev);\r\nrelease_region(fmi->io, 2);\r\nif (pnp_attached)\r\npnp_device_detach(dev);\r\nreturn -EINVAL;\r\n}\r\nv4l2_info(v4l2_dev, "card driver at 0x%x\n", fmi->io);\r\nreturn 0;\r\n}\r\nstatic void __exit fmi_exit(void)\r\n{\r\nstruct fmi *fmi = &fmi_card;\r\nv4l2_ctrl_handler_free(&fmi->hdl);\r\nvideo_unregister_device(&fmi->vdev);\r\nv4l2_device_unregister(&fmi->v4l2_dev);\r\nrelease_region(fmi->io, 2);\r\nif (dev && pnp_attached)\r\npnp_device_detach(dev);\r\n}
