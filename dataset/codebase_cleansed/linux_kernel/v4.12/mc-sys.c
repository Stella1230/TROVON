static enum mc_cmd_status mc_cmd_hdr_read_status(struct mc_command *cmd)\r\n{\r\nstruct mc_cmd_header *hdr = (struct mc_cmd_header *)&cmd->header;\r\nreturn (enum mc_cmd_status)hdr->status;\r\n}\r\nstatic u16 mc_cmd_hdr_read_cmdid(struct mc_command *cmd)\r\n{\r\nstruct mc_cmd_header *hdr = (struct mc_cmd_header *)&cmd->header;\r\nu16 cmd_id = le16_to_cpu(hdr->cmd_id);\r\nreturn cmd_id;\r\n}\r\nstatic int mc_status_to_error(enum mc_cmd_status status)\r\n{\r\nstatic const int mc_status_to_error_map[] = {\r\n[MC_CMD_STATUS_OK] = 0,\r\n[MC_CMD_STATUS_AUTH_ERR] = -EACCES,\r\n[MC_CMD_STATUS_NO_PRIVILEGE] = -EPERM,\r\n[MC_CMD_STATUS_DMA_ERR] = -EIO,\r\n[MC_CMD_STATUS_CONFIG_ERR] = -ENXIO,\r\n[MC_CMD_STATUS_TIMEOUT] = -ETIMEDOUT,\r\n[MC_CMD_STATUS_NO_RESOURCE] = -ENAVAIL,\r\n[MC_CMD_STATUS_NO_MEMORY] = -ENOMEM,\r\n[MC_CMD_STATUS_BUSY] = -EBUSY,\r\n[MC_CMD_STATUS_UNSUPPORTED_OP] = -ENOTSUPP,\r\n[MC_CMD_STATUS_INVALID_STATE] = -ENODEV,\r\n};\r\nif (WARN_ON((u32)status >= ARRAY_SIZE(mc_status_to_error_map)))\r\nreturn -EINVAL;\r\nreturn mc_status_to_error_map[status];\r\n}\r\nstatic const char *mc_status_to_string(enum mc_cmd_status status)\r\n{\r\nstatic const char *const status_strings[] = {\r\n[MC_CMD_STATUS_OK] = "Command completed successfully",\r\n[MC_CMD_STATUS_READY] = "Command ready to be processed",\r\n[MC_CMD_STATUS_AUTH_ERR] = "Authentication error",\r\n[MC_CMD_STATUS_NO_PRIVILEGE] = "No privilege",\r\n[MC_CMD_STATUS_DMA_ERR] = "DMA or I/O error",\r\n[MC_CMD_STATUS_CONFIG_ERR] = "Configuration error",\r\n[MC_CMD_STATUS_TIMEOUT] = "Operation timed out",\r\n[MC_CMD_STATUS_NO_RESOURCE] = "No resources",\r\n[MC_CMD_STATUS_NO_MEMORY] = "No memory available",\r\n[MC_CMD_STATUS_BUSY] = "Device is busy",\r\n[MC_CMD_STATUS_UNSUPPORTED_OP] = "Unsupported operation",\r\n[MC_CMD_STATUS_INVALID_STATE] = "Invalid state"\r\n};\r\nif ((unsigned int)status >= ARRAY_SIZE(status_strings))\r\nreturn "Unknown MC error";\r\nreturn status_strings[status];\r\n}\r\nstatic inline void mc_write_command(struct mc_command __iomem *portal,\r\nstruct mc_command *cmd)\r\n{\r\nint i;\r\nfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\r\n__raw_writeq(cmd->params[i], &portal->params[i]);\r\n__iowmb();\r\n__raw_writeq(cmd->header, &portal->header);\r\n}\r\nstatic inline enum mc_cmd_status mc_read_response(struct mc_command __iomem *\r\nportal,\r\nstruct mc_command *resp)\r\n{\r\nint i;\r\nenum mc_cmd_status status;\r\n__iormb();\r\nresp->header = __raw_readq(&portal->header);\r\n__iormb();\r\nstatus = mc_cmd_hdr_read_status(resp);\r\nif (status != MC_CMD_STATUS_OK)\r\nreturn status;\r\nfor (i = 0; i < MC_CMD_NUM_OF_PARAMS; i++)\r\nresp->params[i] = __raw_readq(&portal->params[i]);\r\n__iormb();\r\nreturn status;\r\n}\r\nstatic int mc_polling_wait_preemptible(struct fsl_mc_io *mc_io,\r\nstruct mc_command *cmd,\r\nenum mc_cmd_status *mc_status)\r\n{\r\nenum mc_cmd_status status;\r\nunsigned long jiffies_until_timeout =\r\njiffies + msecs_to_jiffies(MC_CMD_COMPLETION_TIMEOUT_MS);\r\nfor (;;) {\r\nstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\r\nif (status != MC_CMD_STATUS_READY)\r\nbreak;\r\nusleep_range(MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS,\r\nMC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\r\nif (time_after_eq(jiffies, jiffies_until_timeout)) {\r\ndev_dbg(mc_io->dev,\r\n"MC command timed out (portal: %#llx, dprc handle: %#x, command: %#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)mc_cmd_hdr_read_token(cmd),\r\n(unsigned int)mc_cmd_hdr_read_cmdid(cmd));\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\n*mc_status = status;\r\nreturn 0;\r\n}\r\nstatic int mc_polling_wait_atomic(struct fsl_mc_io *mc_io,\r\nstruct mc_command *cmd,\r\nenum mc_cmd_status *mc_status)\r\n{\r\nenum mc_cmd_status status;\r\nunsigned long timeout_usecs = MC_CMD_COMPLETION_TIMEOUT_MS * 1000;\r\nBUILD_BUG_ON((MC_CMD_COMPLETION_TIMEOUT_MS * 1000) %\r\nMC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS != 0);\r\nfor (;;) {\r\nstatus = mc_read_response(mc_io->portal_virt_addr, cmd);\r\nif (status != MC_CMD_STATUS_READY)\r\nbreak;\r\nudelay(MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);\r\ntimeout_usecs -= MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS;\r\nif (timeout_usecs == 0) {\r\ndev_dbg(mc_io->dev,\r\n"MC command timed out (portal: %#llx, dprc handle: %#x, command: %#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)mc_cmd_hdr_read_token(cmd),\r\n(unsigned int)mc_cmd_hdr_read_cmdid(cmd));\r\nreturn -ETIMEDOUT;\r\n}\r\n}\r\n*mc_status = status;\r\nreturn 0;\r\n}\r\nint mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)\r\n{\r\nint error;\r\nenum mc_cmd_status status;\r\nunsigned long irq_flags = 0;\r\nif (WARN_ON(in_irq() &&\r\n!(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)))\r\nreturn -EINVAL;\r\nif (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\r\nspin_lock_irqsave(&mc_io->spinlock, irq_flags);\r\nelse\r\nmutex_lock(&mc_io->mutex);\r\nmc_write_command(mc_io->portal_virt_addr, cmd);\r\nif (!(mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL))\r\nerror = mc_polling_wait_preemptible(mc_io, cmd, &status);\r\nelse\r\nerror = mc_polling_wait_atomic(mc_io, cmd, &status);\r\nif (error < 0)\r\ngoto common_exit;\r\nif (status != MC_CMD_STATUS_OK) {\r\ndev_dbg(mc_io->dev,\r\n"MC command failed: portal: %#llx, dprc handle: %#x, command: %#x, status: %s (%#x)\n",\r\nmc_io->portal_phys_addr,\r\n(unsigned int)mc_cmd_hdr_read_token(cmd),\r\n(unsigned int)mc_cmd_hdr_read_cmdid(cmd),\r\nmc_status_to_string(status),\r\n(unsigned int)status);\r\nerror = mc_status_to_error(status);\r\ngoto common_exit;\r\n}\r\nerror = 0;\r\ncommon_exit:\r\nif (mc_io->flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)\r\nspin_unlock_irqrestore(&mc_io->spinlock, irq_flags);\r\nelse\r\nmutex_unlock(&mc_io->mutex);\r\nreturn error;\r\n}
