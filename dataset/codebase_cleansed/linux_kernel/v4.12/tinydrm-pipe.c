static inline struct tinydrm_connector *\r\nto_tinydrm_connector(struct drm_connector *connector)\r\n{\r\nreturn container_of(connector, struct tinydrm_connector, base);\r\n}\r\nstatic int tinydrm_connector_get_modes(struct drm_connector *connector)\r\n{\r\nstruct tinydrm_connector *tconn = to_tinydrm_connector(connector);\r\nstruct drm_display_mode *mode;\r\nmode = drm_mode_duplicate(connector->dev, tconn->mode);\r\nif (!mode) {\r\nDRM_ERROR("Failed to duplicate mode\n");\r\nreturn 0;\r\n}\r\nif (mode->name[0] == '\0')\r\ndrm_mode_set_name(mode);\r\nmode->type |= DRM_MODE_TYPE_PREFERRED;\r\ndrm_mode_probed_add(connector, mode);\r\nif (mode->width_mm) {\r\nconnector->display_info.width_mm = mode->width_mm;\r\nconnector->display_info.height_mm = mode->height_mm;\r\n}\r\nreturn 1;\r\n}\r\nstatic enum drm_connector_status\r\ntinydrm_connector_detect(struct drm_connector *connector, bool force)\r\n{\r\nif (drm_device_is_unplugged(connector->dev))\r\nreturn connector_status_disconnected;\r\nreturn connector->status;\r\n}\r\nstatic void tinydrm_connector_destroy(struct drm_connector *connector)\r\n{\r\nstruct tinydrm_connector *tconn = to_tinydrm_connector(connector);\r\ndrm_connector_cleanup(connector);\r\nkfree(tconn);\r\n}\r\nstruct drm_connector *\r\ntinydrm_connector_create(struct drm_device *drm,\r\nconst struct drm_display_mode *mode,\r\nint connector_type)\r\n{\r\nstruct tinydrm_connector *tconn;\r\nstruct drm_connector *connector;\r\nint ret;\r\ntconn = kzalloc(sizeof(*tconn), GFP_KERNEL);\r\nif (!tconn)\r\nreturn ERR_PTR(-ENOMEM);\r\ntconn->mode = mode;\r\nconnector = &tconn->base;\r\ndrm_connector_helper_add(connector, &tinydrm_connector_hfuncs);\r\nret = drm_connector_init(drm, connector, &tinydrm_connector_funcs,\r\nconnector_type);\r\nif (ret) {\r\nkfree(tconn);\r\nreturn ERR_PTR(ret);\r\n}\r\nconnector->status = connector_status_connected;\r\nreturn connector;\r\n}\r\nvoid tinydrm_display_pipe_update(struct drm_simple_display_pipe *pipe,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct tinydrm_device *tdev = pipe_to_tinydrm(pipe);\r\nstruct drm_framebuffer *fb = pipe->plane.state->fb;\r\nstruct drm_crtc *crtc = &tdev->pipe.crtc;\r\nif (fb && (fb != old_state->fb)) {\r\npipe->plane.fb = fb;\r\nif (fb->funcs->dirty)\r\nfb->funcs->dirty(fb, NULL, 0, 0, NULL, 0);\r\n}\r\nif (crtc->state->event) {\r\nspin_lock_irq(&crtc->dev->event_lock);\r\ndrm_crtc_send_vblank_event(crtc, crtc->state->event);\r\nspin_unlock_irq(&crtc->dev->event_lock);\r\ncrtc->state->event = NULL;\r\n}\r\n}\r\nint tinydrm_display_pipe_prepare_fb(struct drm_simple_display_pipe *pipe,\r\nstruct drm_plane_state *plane_state)\r\n{\r\nreturn drm_fb_cma_prepare_fb(&pipe->plane, plane_state);\r\n}\r\nstatic int tinydrm_rotate_mode(struct drm_display_mode *mode,\r\nunsigned int rotation)\r\n{\r\nif (rotation == 0 || rotation == 180) {\r\nreturn 0;\r\n} else if (rotation == 90 || rotation == 270) {\r\nswap(mode->hdisplay, mode->vdisplay);\r\nswap(mode->hsync_start, mode->vsync_start);\r\nswap(mode->hsync_end, mode->vsync_end);\r\nswap(mode->htotal, mode->vtotal);\r\nswap(mode->width_mm, mode->height_mm);\r\nreturn 0;\r\n} else {\r\nreturn -EINVAL;\r\n}\r\n}\r\nint\r\ntinydrm_display_pipe_init(struct tinydrm_device *tdev,\r\nconst struct drm_simple_display_pipe_funcs *funcs,\r\nint connector_type,\r\nconst uint32_t *formats,\r\nunsigned int format_count,\r\nconst struct drm_display_mode *mode,\r\nunsigned int rotation)\r\n{\r\nstruct drm_device *drm = tdev->drm;\r\nstruct drm_display_mode *mode_copy;\r\nstruct drm_connector *connector;\r\nint ret;\r\nmode_copy = devm_kmalloc(drm->dev, sizeof(*mode_copy), GFP_KERNEL);\r\nif (!mode_copy)\r\nreturn -ENOMEM;\r\n*mode_copy = *mode;\r\nret = tinydrm_rotate_mode(mode_copy, rotation);\r\nif (ret) {\r\nDRM_ERROR("Illegal rotation value %u\n", rotation);\r\nreturn -EINVAL;\r\n}\r\ndrm->mode_config.min_width = mode_copy->hdisplay;\r\ndrm->mode_config.max_width = mode_copy->hdisplay;\r\ndrm->mode_config.min_height = mode_copy->vdisplay;\r\ndrm->mode_config.max_height = mode_copy->vdisplay;\r\nconnector = tinydrm_connector_create(drm, mode_copy, connector_type);\r\nif (IS_ERR(connector))\r\nreturn PTR_ERR(connector);\r\nret = drm_simple_display_pipe_init(drm, &tdev->pipe, funcs, formats,\r\nformat_count, connector);\r\nif (ret)\r\nreturn ret;\r\nreturn 0;\r\n}
