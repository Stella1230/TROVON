struct platform_device *usb_phy_generic_register(void)\r\n{\r\nreturn platform_device_register_simple("usb_phy_generic",\r\nPLATFORM_DEVID_AUTO, NULL, 0);\r\n}\r\nvoid usb_phy_generic_unregister(struct platform_device *pdev)\r\n{\r\nplatform_device_unregister(pdev);\r\n}\r\nstatic int nop_set_suspend(struct usb_phy *x, int suspend)\r\n{\r\nstruct usb_phy_generic *nop = dev_get_drvdata(x->dev);\r\nif (!IS_ERR(nop->clk)) {\r\nif (suspend)\r\nclk_disable_unprepare(nop->clk);\r\nelse\r\nclk_prepare_enable(nop->clk);\r\n}\r\nreturn 0;\r\n}\r\nstatic void nop_reset(struct usb_phy_generic *nop)\r\n{\r\nif (!nop->gpiod_reset)\r\nreturn;\r\ngpiod_set_value(nop->gpiod_reset, 1);\r\nusleep_range(10000, 20000);\r\ngpiod_set_value(nop->gpiod_reset, 0);\r\n}\r\nstatic void nop_set_vbus_draw(struct usb_phy_generic *nop, unsigned mA)\r\n{\r\nstruct regulator *vbus_draw = nop->vbus_draw;\r\nint enabled;\r\nint ret;\r\nif (!vbus_draw)\r\nreturn;\r\nenabled = nop->vbus_draw_enabled;\r\nif (mA) {\r\nregulator_set_current_limit(vbus_draw, 0, 1000 * mA);\r\nif (!enabled) {\r\nret = regulator_enable(vbus_draw);\r\nif (ret < 0)\r\nreturn;\r\nnop->vbus_draw_enabled = 1;\r\n}\r\n} else {\r\nif (enabled) {\r\nret = regulator_disable(vbus_draw);\r\nif (ret < 0)\r\nreturn;\r\nnop->vbus_draw_enabled = 0;\r\n}\r\n}\r\nnop->mA = mA;\r\n}\r\nstatic irqreturn_t nop_gpio_vbus_thread(int irq, void *data)\r\n{\r\nstruct usb_phy_generic *nop = data;\r\nstruct usb_otg *otg = nop->phy.otg;\r\nint vbus, status;\r\nvbus = gpiod_get_value(nop->gpiod_vbus);\r\nif ((vbus ^ nop->vbus) == 0)\r\nreturn IRQ_HANDLED;\r\nnop->vbus = vbus;\r\nif (vbus) {\r\nstatus = USB_EVENT_VBUS;\r\notg->state = OTG_STATE_B_PERIPHERAL;\r\nnop->phy.last_event = status;\r\nnop_set_vbus_draw(nop, 100);\r\natomic_notifier_call_chain(&nop->phy.notifier, status,\r\notg->gadget);\r\n} else {\r\nnop_set_vbus_draw(nop, 0);\r\nstatus = USB_EVENT_NONE;\r\notg->state = OTG_STATE_B_IDLE;\r\nnop->phy.last_event = status;\r\natomic_notifier_call_chain(&nop->phy.notifier, status,\r\notg->gadget);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nint usb_gen_phy_init(struct usb_phy *phy)\r\n{\r\nstruct usb_phy_generic *nop = dev_get_drvdata(phy->dev);\r\nint ret;\r\nif (!IS_ERR(nop->vcc)) {\r\nif (regulator_enable(nop->vcc))\r\ndev_err(phy->dev, "Failed to enable power\n");\r\n}\r\nif (!IS_ERR(nop->clk)) {\r\nret = clk_prepare_enable(nop->clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\nnop_reset(nop);\r\nreturn 0;\r\n}\r\nvoid usb_gen_phy_shutdown(struct usb_phy *phy)\r\n{\r\nstruct usb_phy_generic *nop = dev_get_drvdata(phy->dev);\r\ngpiod_set_value(nop->gpiod_reset, 1);\r\nif (!IS_ERR(nop->clk))\r\nclk_disable_unprepare(nop->clk);\r\nif (!IS_ERR(nop->vcc)) {\r\nif (regulator_disable(nop->vcc))\r\ndev_err(phy->dev, "Failed to disable power\n");\r\n}\r\n}\r\nstatic int nop_set_peripheral(struct usb_otg *otg, struct usb_gadget *gadget)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\nif (!gadget) {\r\notg->gadget = NULL;\r\nreturn -ENODEV;\r\n}\r\notg->gadget = gadget;\r\nif (otg->state == OTG_STATE_B_PERIPHERAL)\r\natomic_notifier_call_chain(&otg->usb_phy->notifier,\r\nUSB_EVENT_VBUS, otg->gadget);\r\nelse\r\notg->state = OTG_STATE_B_IDLE;\r\nreturn 0;\r\n}\r\nstatic int nop_set_host(struct usb_otg *otg, struct usb_bus *host)\r\n{\r\nif (!otg)\r\nreturn -ENODEV;\r\nif (!host) {\r\notg->host = NULL;\r\nreturn -ENODEV;\r\n}\r\notg->host = host;\r\nreturn 0;\r\n}\r\nint usb_phy_gen_create_phy(struct device *dev, struct usb_phy_generic *nop,\r\nstruct usb_phy_generic_platform_data *pdata)\r\n{\r\nenum usb_phy_type type = USB_PHY_TYPE_USB2;\r\nint err = 0;\r\nu32 clk_rate = 0;\r\nbool needs_vcc = false;\r\nif (dev->of_node) {\r\nstruct device_node *node = dev->of_node;\r\nif (of_property_read_u32(node, "clock-frequency", &clk_rate))\r\nclk_rate = 0;\r\nneeds_vcc = of_property_read_bool(node, "vcc-supply");\r\nnop->gpiod_reset = devm_gpiod_get_optional(dev, "reset",\r\nGPIOD_ASIS);\r\nerr = PTR_ERR_OR_ZERO(nop->gpiod_reset);\r\nif (!err) {\r\nnop->gpiod_vbus = devm_gpiod_get_optional(dev,\r\n"vbus-detect",\r\nGPIOD_ASIS);\r\nerr = PTR_ERR_OR_ZERO(nop->gpiod_vbus);\r\n}\r\n} else if (pdata) {\r\ntype = pdata->type;\r\nclk_rate = pdata->clk_rate;\r\nneeds_vcc = pdata->needs_vcc;\r\nif (gpio_is_valid(pdata->gpio_reset)) {\r\nerr = devm_gpio_request_one(dev, pdata->gpio_reset,\r\nGPIOF_ACTIVE_LOW,\r\ndev_name(dev));\r\nif (!err)\r\nnop->gpiod_reset =\r\ngpio_to_desc(pdata->gpio_reset);\r\n}\r\nnop->gpiod_vbus = pdata->gpiod_vbus;\r\n}\r\nif (err == -EPROBE_DEFER)\r\nreturn -EPROBE_DEFER;\r\nif (err) {\r\ndev_err(dev, "Error requesting RESET or VBUS GPIO\n");\r\nreturn err;\r\n}\r\nif (nop->gpiod_reset)\r\ngpiod_direction_output(nop->gpiod_reset, 1);\r\nnop->phy.otg = devm_kzalloc(dev, sizeof(*nop->phy.otg),\r\nGFP_KERNEL);\r\nif (!nop->phy.otg)\r\nreturn -ENOMEM;\r\nnop->clk = devm_clk_get(dev, "main_clk");\r\nif (IS_ERR(nop->clk)) {\r\ndev_dbg(dev, "Can't get phy clock: %ld\n",\r\nPTR_ERR(nop->clk));\r\n}\r\nif (!IS_ERR(nop->clk) && clk_rate) {\r\nerr = clk_set_rate(nop->clk, clk_rate);\r\nif (err) {\r\ndev_err(dev, "Error setting clock rate\n");\r\nreturn err;\r\n}\r\n}\r\nnop->vcc = devm_regulator_get(dev, "vcc");\r\nif (IS_ERR(nop->vcc)) {\r\ndev_dbg(dev, "Error getting vcc regulator: %ld\n",\r\nPTR_ERR(nop->vcc));\r\nif (needs_vcc)\r\nreturn -EPROBE_DEFER;\r\n}\r\nnop->dev = dev;\r\nnop->phy.dev = nop->dev;\r\nnop->phy.label = "nop-xceiv";\r\nnop->phy.set_suspend = nop_set_suspend;\r\nnop->phy.type = type;\r\nnop->phy.otg->state = OTG_STATE_UNDEFINED;\r\nnop->phy.otg->usb_phy = &nop->phy;\r\nnop->phy.otg->set_host = nop_set_host;\r\nnop->phy.otg->set_peripheral = nop_set_peripheral;\r\nreturn 0;\r\n}\r\nstatic int usb_phy_generic_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct usb_phy_generic *nop;\r\nint err;\r\nnop = devm_kzalloc(dev, sizeof(*nop), GFP_KERNEL);\r\nif (!nop)\r\nreturn -ENOMEM;\r\nerr = usb_phy_gen_create_phy(dev, nop, dev_get_platdata(&pdev->dev));\r\nif (err)\r\nreturn err;\r\nif (nop->gpiod_vbus) {\r\nerr = devm_request_threaded_irq(&pdev->dev,\r\ngpiod_to_irq(nop->gpiod_vbus),\r\nNULL, nop_gpio_vbus_thread,\r\nVBUS_IRQ_FLAGS, "vbus_detect",\r\nnop);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't request irq %i, err: %d\n",\r\ngpiod_to_irq(nop->gpiod_vbus), err);\r\nreturn err;\r\n}\r\nnop->phy.otg->state = gpiod_get_value(nop->gpiod_vbus) ?\r\nOTG_STATE_B_PERIPHERAL : OTG_STATE_B_IDLE;\r\n}\r\nnop->phy.init = usb_gen_phy_init;\r\nnop->phy.shutdown = usb_gen_phy_shutdown;\r\nerr = usb_add_phy_dev(&nop->phy);\r\nif (err) {\r\ndev_err(&pdev->dev, "can't register transceiver, err: %d\n",\r\nerr);\r\nreturn err;\r\n}\r\nplatform_set_drvdata(pdev, nop);\r\nreturn 0;\r\n}\r\nstatic int usb_phy_generic_remove(struct platform_device *pdev)\r\n{\r\nstruct usb_phy_generic *nop = platform_get_drvdata(pdev);\r\nusb_remove_phy(&nop->phy);\r\nreturn 0;\r\n}\r\nstatic int __init usb_phy_generic_init(void)\r\n{\r\nreturn platform_driver_register(&usb_phy_generic_driver);\r\n}\r\nstatic void __exit usb_phy_generic_exit(void)\r\n{\r\nplatform_driver_unregister(&usb_phy_generic_driver);\r\n}
