static inline void vsp1_clu_write(struct vsp1_clu *clu, struct vsp1_dl_list *dl,\r\nu32 reg, u32 data)\r\n{\r\nvsp1_dl_list_write(dl, reg, data);\r\n}\r\nstatic int clu_set_table(struct vsp1_clu *clu, struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vsp1_dl_body *dlb;\r\nunsigned int i;\r\ndlb = vsp1_dl_fragment_alloc(clu->entity.vsp1, 1 + 17 * 17 * 17);\r\nif (!dlb)\r\nreturn -ENOMEM;\r\nvsp1_dl_fragment_write(dlb, VI6_CLU_ADDR, 0);\r\nfor (i = 0; i < 17 * 17 * 17; ++i)\r\nvsp1_dl_fragment_write(dlb, VI6_CLU_DATA, ctrl->p_new.p_u32[i]);\r\nspin_lock_irq(&clu->lock);\r\nswap(clu->clu, dlb);\r\nspin_unlock_irq(&clu->lock);\r\nvsp1_dl_fragment_free(dlb);\r\nreturn 0;\r\n}\r\nstatic int clu_s_ctrl(struct v4l2_ctrl *ctrl)\r\n{\r\nstruct vsp1_clu *clu =\r\ncontainer_of(ctrl->handler, struct vsp1_clu, ctrls);\r\nswitch (ctrl->id) {\r\ncase V4L2_CID_VSP1_CLU_TABLE:\r\nclu_set_table(clu, ctrl);\r\nbreak;\r\ncase V4L2_CID_VSP1_CLU_MODE:\r\nclu->mode = ctrl->val;\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int clu_enum_mbus_code(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_mbus_code_enum *code)\r\n{\r\nstatic const unsigned int codes[] = {\r\nMEDIA_BUS_FMT_ARGB8888_1X32,\r\nMEDIA_BUS_FMT_AHSV8888_1X32,\r\nMEDIA_BUS_FMT_AYUV8_1X32,\r\n};\r\nreturn vsp1_subdev_enum_mbus_code(subdev, cfg, code, codes,\r\nARRAY_SIZE(codes));\r\n}\r\nstatic int clu_enum_frame_size(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_frame_size_enum *fse)\r\n{\r\nreturn vsp1_subdev_enum_frame_size(subdev, cfg, fse, CLU_MIN_SIZE,\r\nCLU_MIN_SIZE, CLU_MAX_SIZE,\r\nCLU_MAX_SIZE);\r\n}\r\nstatic int clu_set_format(struct v4l2_subdev *subdev,\r\nstruct v4l2_subdev_pad_config *cfg,\r\nstruct v4l2_subdev_format *fmt)\r\n{\r\nstruct vsp1_clu *clu = to_clu(subdev);\r\nstruct v4l2_subdev_pad_config *config;\r\nstruct v4l2_mbus_framefmt *format;\r\nint ret = 0;\r\nmutex_lock(&clu->entity.lock);\r\nconfig = vsp1_entity_get_pad_config(&clu->entity, cfg, fmt->which);\r\nif (!config) {\r\nret = -EINVAL;\r\ngoto done;\r\n}\r\nif (fmt->format.code != MEDIA_BUS_FMT_ARGB8888_1X32 &&\r\nfmt->format.code != MEDIA_BUS_FMT_AHSV8888_1X32 &&\r\nfmt->format.code != MEDIA_BUS_FMT_AYUV8_1X32)\r\nfmt->format.code = MEDIA_BUS_FMT_AYUV8_1X32;\r\nformat = vsp1_entity_get_pad_format(&clu->entity, config, fmt->pad);\r\nif (fmt->pad == CLU_PAD_SOURCE) {\r\nfmt->format = *format;\r\ngoto done;\r\n}\r\nformat->code = fmt->format.code;\r\nformat->width = clamp_t(unsigned int, fmt->format.width,\r\nCLU_MIN_SIZE, CLU_MAX_SIZE);\r\nformat->height = clamp_t(unsigned int, fmt->format.height,\r\nCLU_MIN_SIZE, CLU_MAX_SIZE);\r\nformat->field = V4L2_FIELD_NONE;\r\nformat->colorspace = V4L2_COLORSPACE_SRGB;\r\nfmt->format = *format;\r\nformat = vsp1_entity_get_pad_format(&clu->entity, config,\r\nCLU_PAD_SOURCE);\r\n*format = fmt->format;\r\ndone:\r\nmutex_unlock(&clu->entity.lock);\r\nreturn ret;\r\n}\r\nstatic void clu_configure(struct vsp1_entity *entity,\r\nstruct vsp1_pipeline *pipe,\r\nstruct vsp1_dl_list *dl,\r\nenum vsp1_entity_params params)\r\n{\r\nstruct vsp1_clu *clu = to_clu(&entity->subdev);\r\nstruct vsp1_dl_body *dlb;\r\nunsigned long flags;\r\nu32 ctrl = VI6_CLU_CTRL_AAI | VI6_CLU_CTRL_MVS | VI6_CLU_CTRL_EN;\r\nswitch (params) {\r\ncase VSP1_ENTITY_PARAMS_INIT: {\r\nstruct v4l2_mbus_framefmt *format;\r\nformat = vsp1_entity_get_pad_format(&clu->entity,\r\nclu->entity.config,\r\nCLU_PAD_SINK);\r\nclu->yuv_mode = format->code == MEDIA_BUS_FMT_AYUV8_1X32;\r\nbreak;\r\n}\r\ncase VSP1_ENTITY_PARAMS_PARTITION:\r\nbreak;\r\ncase VSP1_ENTITY_PARAMS_RUNTIME:\r\nif (clu->mode == V4L2_CID_VSP1_CLU_MODE_2D && clu->yuv_mode)\r\nctrl |= VI6_CLU_CTRL_AX1I_2D | VI6_CLU_CTRL_AX2I_2D\r\n| VI6_CLU_CTRL_OS0_2D | VI6_CLU_CTRL_OS1_2D\r\n| VI6_CLU_CTRL_OS2_2D | VI6_CLU_CTRL_M2D;\r\nvsp1_clu_write(clu, dl, VI6_CLU_CTRL, ctrl);\r\nspin_lock_irqsave(&clu->lock, flags);\r\ndlb = clu->clu;\r\nclu->clu = NULL;\r\nspin_unlock_irqrestore(&clu->lock, flags);\r\nif (dlb)\r\nvsp1_dl_list_add_fragment(dl, dlb);\r\nbreak;\r\n}\r\n}\r\nstruct vsp1_clu *vsp1_clu_create(struct vsp1_device *vsp1)\r\n{\r\nstruct vsp1_clu *clu;\r\nint ret;\r\nclu = devm_kzalloc(vsp1->dev, sizeof(*clu), GFP_KERNEL);\r\nif (clu == NULL)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock_init(&clu->lock);\r\nclu->entity.ops = &clu_entity_ops;\r\nclu->entity.type = VSP1_ENTITY_CLU;\r\nret = vsp1_entity_init(vsp1, &clu->entity, "clu", 2, &clu_ops,\r\nMEDIA_ENT_F_PROC_VIDEO_LUT);\r\nif (ret < 0)\r\nreturn ERR_PTR(ret);\r\nv4l2_ctrl_handler_init(&clu->ctrls, 2);\r\nv4l2_ctrl_new_custom(&clu->ctrls, &clu_table_control, NULL);\r\nv4l2_ctrl_new_custom(&clu->ctrls, &clu_mode_control, NULL);\r\nclu->entity.subdev.ctrl_handler = &clu->ctrls;\r\nif (clu->ctrls.error) {\r\ndev_err(vsp1->dev, "clu: failed to initialize controls\n");\r\nret = clu->ctrls.error;\r\nvsp1_entity_destroy(&clu->entity);\r\nreturn ERR_PTR(ret);\r\n}\r\nv4l2_ctrl_handler_setup(&clu->ctrls);\r\nreturn clu;\r\n}
