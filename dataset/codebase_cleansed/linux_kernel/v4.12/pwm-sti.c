static inline struct sti_pwm_chip *to_sti_pwmchip(struct pwm_chip *chip)\r\n{\r\nreturn container_of(chip, struct sti_pwm_chip, chip);\r\n}\r\nstatic int sti_pwm_get_prescale(struct sti_pwm_chip *pc, unsigned long period,\r\nunsigned int *prescale)\r\n{\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nunsigned long clk_rate;\r\nunsigned long value;\r\nunsigned int ps;\r\nclk_rate = clk_get_rate(pc->pwm_clk);\r\nif (!clk_rate) {\r\ndev_err(pc->dev, "failed to get clock rate\n");\r\nreturn -EINVAL;\r\n}\r\nvalue = NSEC_PER_SEC / clk_rate;\r\nvalue *= cdata->max_pwm_cnt + 1;\r\nif (period % value)\r\nreturn -EINVAL;\r\nps = period / value - 1;\r\nif (ps > cdata->max_prescale)\r\nreturn -EINVAL;\r\n*prescale = ps;\r\nreturn 0;\r\n}\r\nstatic int sti_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nunsigned int ncfg, value, prescale = 0;\r\nstruct pwm_device *cur = pc->cur;\r\nstruct device *dev = pc->dev;\r\nbool period_same = false;\r\nint ret;\r\nncfg = hweight_long(pc->configured);\r\nif (ncfg)\r\nperiod_same = (period_ns == pwm_get_period(cur));\r\nif (!ncfg ||\r\n((ncfg == 1) && (pwm->hwpwm == cur->hwpwm)) ||\r\n((ncfg == 1) && (pwm->hwpwm != cur->hwpwm) && period_same) ||\r\n((ncfg > 1) && period_same)) {\r\nret = clk_enable(pc->pwm_clk);\r\nif (ret)\r\nreturn ret;\r\nret = clk_enable(pc->cpt_clk);\r\nif (ret)\r\nreturn ret;\r\nif (!period_same) {\r\nret = sti_pwm_get_prescale(pc, period_ns, &prescale);\r\nif (ret)\r\ngoto clk_dis;\r\nvalue = prescale & PWM_PRESCALE_LOW_MASK;\r\nret = regmap_field_write(pc->prescale_low, value);\r\nif (ret)\r\ngoto clk_dis;\r\nvalue = (prescale & PWM_PRESCALE_HIGH_MASK) >> 4;\r\nret = regmap_field_write(pc->prescale_high, value);\r\nif (ret)\r\ngoto clk_dis;\r\n}\r\nvalue = cdata->max_pwm_cnt * duty_ns / period_ns;\r\nret = regmap_write(pc->regmap, PWM_OUT_VAL(pwm->hwpwm), value);\r\nif (ret)\r\ngoto clk_dis;\r\nret = regmap_field_write(pc->pwm_cpt_int_en, 0);\r\nset_bit(pwm->hwpwm, &pc->configured);\r\npc->cur = pwm;\r\ndev_dbg(dev, "prescale:%u, period:%i, duty:%i, value:%u\n",\r\nprescale, period_ns, duty_ns, value);\r\n} else {\r\nreturn -EINVAL;\r\n}\r\nclk_dis:\r\nclk_disable(pc->pwm_clk);\r\nclk_disable(pc->cpt_clk);\r\nreturn ret;\r\n}\r\nstatic int sti_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nstruct device *dev = pc->dev;\r\nint ret = 0;\r\nmutex_lock(&pc->sti_pwm_lock);\r\nif (!pc->en_count) {\r\nret = clk_enable(pc->pwm_clk);\r\nif (ret)\r\ngoto out;\r\nret = clk_enable(pc->cpt_clk);\r\nif (ret)\r\ngoto out;\r\nret = regmap_field_write(pc->pwm_out_en, 1);\r\nif (ret) {\r\ndev_err(dev, "failed to enable PWM device %u: %d\n",\r\npwm->hwpwm, ret);\r\ngoto out;\r\n}\r\n}\r\npc->en_count++;\r\nout:\r\nmutex_unlock(&pc->sti_pwm_lock);\r\nreturn ret;\r\n}\r\nstatic void sti_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nmutex_lock(&pc->sti_pwm_lock);\r\nif (--pc->en_count) {\r\nmutex_unlock(&pc->sti_pwm_lock);\r\nreturn;\r\n}\r\nregmap_field_write(pc->pwm_out_en, 0);\r\nclk_disable(pc->pwm_clk);\r\nclk_disable(pc->cpt_clk);\r\nmutex_unlock(&pc->sti_pwm_lock);\r\n}\r\nstatic void sti_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nclear_bit(pwm->hwpwm, &pc->configured);\r\n}\r\nstatic int sti_pwm_capture(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_capture *result, unsigned long timeout)\r\n{\r\nstruct sti_pwm_chip *pc = to_sti_pwmchip(chip);\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nstruct sti_cpt_ddata *ddata = pwm_get_chip_data(pwm);\r\nstruct device *dev = pc->dev;\r\nunsigned int effective_ticks;\r\nunsigned long long high, low;\r\nint ret;\r\nif (pwm->hwpwm >= cdata->cpt_num_devs) {\r\ndev_err(dev, "device %u is not valid\n", pwm->hwpwm);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&ddata->lock);\r\nddata->index = 0;\r\nregmap_write(pc->regmap, PWM_CPT_EDGE(pwm->hwpwm), CPT_EDGE_RISING);\r\nregmap_field_write(pc->pwm_cpt_int_en, BIT(pwm->hwpwm));\r\nret = regmap_field_write(pc->pwm_cpt_en, 1);\r\nif (ret) {\r\ndev_err(dev, "failed to enable PWM capture %u: %d\n",\r\npwm->hwpwm, ret);\r\ngoto out;\r\n}\r\nret = wait_event_interruptible_timeout(ddata->wait, ddata->index > 1,\r\nmsecs_to_jiffies(timeout));\r\nregmap_write(pc->regmap, PWM_CPT_EDGE(pwm->hwpwm), CPT_EDGE_DISABLED);\r\nif (ret == -ERESTARTSYS)\r\ngoto out;\r\nswitch (ddata->index) {\r\ncase 0:\r\ncase 1:\r\nresult->period = 0;\r\nresult->duty_cycle = 0;\r\nbreak;\r\ncase 2:\r\nhigh = ddata->snapshot[1] - ddata->snapshot[0];\r\nlow = ddata->snapshot[2] - ddata->snapshot[1];\r\neffective_ticks = clk_get_rate(pc->cpt_clk);\r\nresult->period = (high + low) * NSEC_PER_SEC;\r\nresult->period /= effective_ticks;\r\nresult->duty_cycle = high * NSEC_PER_SEC;\r\nresult->duty_cycle /= effective_ticks;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "internal error\n");\r\nbreak;\r\n}\r\nout:\r\nregmap_field_write(pc->pwm_cpt_en, 0);\r\nmutex_unlock(&ddata->lock);\r\nreturn ret;\r\n}\r\nstatic irqreturn_t sti_pwm_interrupt(int irq, void *data)\r\n{\r\nstruct sti_pwm_chip *pc = data;\r\nstruct device *dev = pc->dev;\r\nstruct sti_cpt_ddata *ddata;\r\nint devicenum;\r\nunsigned int cpt_int_stat;\r\nunsigned int reg;\r\nint ret = IRQ_NONE;\r\nret = regmap_field_read(pc->pwm_cpt_int_stat, &cpt_int_stat);\r\nif (ret)\r\nreturn ret;\r\nwhile (cpt_int_stat) {\r\ndevicenum = ffs(cpt_int_stat) - 1;\r\nddata = pwm_get_chip_data(&pc->chip.pwms[devicenum]);\r\nregmap_read(pc->regmap,\r\nPWM_CPT_VAL(devicenum),\r\n&ddata->snapshot[ddata->index]);\r\nswitch (ddata->index) {\r\ncase 0:\r\ncase 1:\r\nregmap_read(pc->regmap, PWM_CPT_EDGE(devicenum), &reg);\r\nreg ^= PWM_CPT_EDGE_MASK;\r\nregmap_write(pc->regmap, PWM_CPT_EDGE(devicenum), reg);\r\nddata->index++;\r\nbreak;\r\ncase 2:\r\nregmap_write(pc->regmap,\r\nPWM_CPT_EDGE(devicenum),\r\nCPT_EDGE_DISABLED);\r\nwake_up(&ddata->wait);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "Internal error\n");\r\n}\r\ncpt_int_stat &= ~BIT_MASK(devicenum);\r\nret = IRQ_HANDLED;\r\n}\r\nregmap_write(pc->regmap, PWM_INT_ACK, PWM_INT_ACK_MASK);\r\nreturn ret;\r\n}\r\nstatic int sti_pwm_probe_dt(struct sti_pwm_chip *pc)\r\n{\r\nstruct device *dev = pc->dev;\r\nconst struct reg_field *reg_fields;\r\nstruct device_node *np = dev->of_node;\r\nstruct sti_pwm_compat_data *cdata = pc->cdata;\r\nu32 num_devs;\r\nint ret;\r\nret = of_property_read_u32(np, "st,pwm-num-chan", &num_devs);\r\nif (!ret)\r\ncdata->pwm_num_devs = num_devs;\r\nret = of_property_read_u32(np, "st,capture-num-chan", &num_devs);\r\nif (!ret)\r\ncdata->cpt_num_devs = num_devs;\r\nif (!cdata->pwm_num_devs && !cdata->cpt_num_devs) {\r\ndev_err(dev, "No channels configured\n");\r\nreturn -EINVAL;\r\n}\r\nreg_fields = cdata->reg_fields;\r\npc->prescale_low = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWMCLK_PRESCALE_LOW]);\r\nif (IS_ERR(pc->prescale_low))\r\nreturn PTR_ERR(pc->prescale_low);\r\npc->prescale_high = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWMCLK_PRESCALE_HIGH]);\r\nif (IS_ERR(pc->prescale_high))\r\nreturn PTR_ERR(pc->prescale_high);\r\npc->pwm_out_en = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWM_OUT_EN]);\r\nif (IS_ERR(pc->pwm_out_en))\r\nreturn PTR_ERR(pc->pwm_out_en);\r\npc->pwm_cpt_en = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWM_CPT_EN]);\r\nif (IS_ERR(pc->pwm_cpt_en))\r\nreturn PTR_ERR(pc->pwm_cpt_en);\r\npc->pwm_cpt_int_en = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWM_CPT_INT_EN]);\r\nif (IS_ERR(pc->pwm_cpt_int_en))\r\nreturn PTR_ERR(pc->pwm_cpt_int_en);\r\npc->pwm_cpt_int_stat = devm_regmap_field_alloc(dev, pc->regmap,\r\nreg_fields[PWM_CPT_INT_STAT]);\r\nif (PTR_ERR_OR_ZERO(pc->pwm_cpt_int_stat))\r\nreturn PTR_ERR(pc->pwm_cpt_int_stat);\r\nreturn 0;\r\n}\r\nstatic int sti_pwm_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct sti_pwm_compat_data *cdata;\r\nstruct sti_pwm_chip *pc;\r\nstruct resource *res;\r\nunsigned int i;\r\nint irq, ret;\r\npc = devm_kzalloc(dev, sizeof(*pc), GFP_KERNEL);\r\nif (!pc)\r\nreturn -ENOMEM;\r\ncdata = devm_kzalloc(dev, sizeof(*cdata), GFP_KERNEL);\r\nif (!cdata)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npc->mmio = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(pc->mmio))\r\nreturn PTR_ERR(pc->mmio);\r\npc->regmap = devm_regmap_init_mmio(dev, pc->mmio,\r\n&sti_pwm_regmap_config);\r\nif (IS_ERR(pc->regmap))\r\nreturn PTR_ERR(pc->regmap);\r\nirq = platform_get_irq(pdev, 0);\r\nif (irq < 0) {\r\ndev_err(&pdev->dev, "Failed to obtain IRQ\n");\r\nreturn irq;\r\n}\r\nret = devm_request_irq(&pdev->dev, irq, sti_pwm_interrupt, 0,\r\npdev->name, pc);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "Failed to request IRQ\n");\r\nreturn ret;\r\n}\r\ncdata->reg_fields = sti_pwm_regfields;\r\ncdata->max_prescale = 0xff;\r\ncdata->max_pwm_cnt = 255;\r\ncdata->pwm_num_devs = 0;\r\ncdata->cpt_num_devs = 0;\r\npc->cdata = cdata;\r\npc->dev = dev;\r\npc->en_count = 0;\r\nmutex_init(&pc->sti_pwm_lock);\r\nret = sti_pwm_probe_dt(pc);\r\nif (ret)\r\nreturn ret;\r\nif (!cdata->pwm_num_devs)\r\ngoto skip_pwm;\r\npc->pwm_clk = of_clk_get_by_name(dev->of_node, "pwm");\r\nif (IS_ERR(pc->pwm_clk)) {\r\ndev_err(dev, "failed to get PWM clock\n");\r\nreturn PTR_ERR(pc->pwm_clk);\r\n}\r\nret = clk_prepare(pc->pwm_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to prepare clock\n");\r\nreturn ret;\r\n}\r\nskip_pwm:\r\nif (!cdata->cpt_num_devs)\r\ngoto skip_cpt;\r\npc->cpt_clk = of_clk_get_by_name(dev->of_node, "capture");\r\nif (IS_ERR(pc->cpt_clk)) {\r\ndev_err(dev, "failed to get PWM capture clock\n");\r\nreturn PTR_ERR(pc->cpt_clk);\r\n}\r\nret = clk_prepare(pc->cpt_clk);\r\nif (ret) {\r\ndev_err(dev, "failed to prepare clock\n");\r\nreturn ret;\r\n}\r\nskip_cpt:\r\npc->chip.dev = dev;\r\npc->chip.ops = &sti_pwm_ops;\r\npc->chip.base = -1;\r\npc->chip.npwm = pc->cdata->pwm_num_devs;\r\nret = pwmchip_add(&pc->chip);\r\nif (ret < 0) {\r\nclk_unprepare(pc->pwm_clk);\r\nclk_unprepare(pc->cpt_clk);\r\nreturn ret;\r\n}\r\nfor (i = 0; i < cdata->cpt_num_devs; i++) {\r\nstruct sti_cpt_ddata *ddata;\r\nddata = devm_kzalloc(dev, sizeof(*ddata), GFP_KERNEL);\r\nif (!ddata)\r\nreturn -ENOMEM;\r\ninit_waitqueue_head(&ddata->wait);\r\nmutex_init(&ddata->lock);\r\npwm_set_chip_data(&pc->chip.pwms[i], ddata);\r\n}\r\nplatform_set_drvdata(pdev, pc);\r\nreturn 0;\r\n}\r\nstatic int sti_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct sti_pwm_chip *pc = platform_get_drvdata(pdev);\r\nunsigned int i;\r\nfor (i = 0; i < pc->cdata->pwm_num_devs; i++)\r\npwm_disable(&pc->chip.pwms[i]);\r\nclk_unprepare(pc->pwm_clk);\r\nclk_unprepare(pc->cpt_clk);\r\nreturn pwmchip_remove(&pc->chip);\r\n}
