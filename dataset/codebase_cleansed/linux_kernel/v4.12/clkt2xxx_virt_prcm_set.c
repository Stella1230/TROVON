unsigned long omap2_table_mpu_recalc(struct clk_hw *clk,\r\nunsigned long parent_rate)\r\n{\r\nreturn curr_prcm_set->mpu_speed;\r\n}\r\nlong omap2_round_to_table_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long *parent_rate)\r\n{\r\nconst struct prcm_config *ptr;\r\nlong highest_rate;\r\nhighest_rate = -EINVAL;\r\nfor (ptr = rate_table; ptr->mpu_speed; ptr++) {\r\nif (!(ptr->flags & cpu_mask))\r\ncontinue;\r\nif (ptr->xtal_speed != sys_ck_rate)\r\ncontinue;\r\nhighest_rate = ptr->mpu_speed;\r\nif (ptr->mpu_speed <= rate)\r\nbreak;\r\n}\r\nreturn highest_rate;\r\n}\r\nint omap2_select_table_rate(struct clk_hw *hw, unsigned long rate,\r\nunsigned long parent_rate)\r\n{\r\nu32 cur_rate, done_rate, bypass = 0;\r\nconst struct prcm_config *prcm;\r\nunsigned long found_speed = 0;\r\nunsigned long flags;\r\nfor (prcm = rate_table; prcm->mpu_speed; prcm++) {\r\nif (!(prcm->flags & cpu_mask))\r\ncontinue;\r\nif (prcm->xtal_speed != sys_ck_rate)\r\ncontinue;\r\nif (prcm->mpu_speed <= rate) {\r\nfound_speed = prcm->mpu_speed;\r\nbreak;\r\n}\r\n}\r\nif (!found_speed) {\r\nprintk(KERN_INFO "Could not set MPU rate to %luMHz\n",\r\nrate / 1000000);\r\nreturn -EINVAL;\r\n}\r\ncurr_prcm_set = prcm;\r\ncur_rate = omap2xxx_clk_get_core_rate();\r\nif (prcm->dpll_speed == cur_rate / 2) {\r\nomap2xxx_sdrc_reprogram(CORE_CLK_SRC_DPLL, 1);\r\n} else if (prcm->dpll_speed == cur_rate * 2) {\r\nomap2xxx_sdrc_reprogram(CORE_CLK_SRC_DPLL_X2, 1);\r\n} else if (prcm->dpll_speed != cur_rate) {\r\nlocal_irq_save(flags);\r\nif (prcm->dpll_speed == prcm->xtal_speed)\r\nbypass = 1;\r\nif ((prcm->cm_clksel2_pll & OMAP24XX_CORE_CLK_SRC_MASK) ==\r\nCORE_CLK_SRC_DPLL_X2)\r\ndone_rate = CORE_CLK_SRC_DPLL_X2;\r\nelse\r\ndone_rate = CORE_CLK_SRC_DPLL;\r\nomap2xxx_cm_set_mod_dividers(prcm->cm_clksel_mpu,\r\nprcm->cm_clksel_dsp,\r\nprcm->cm_clksel_gfx,\r\nprcm->cm_clksel1_core,\r\nprcm->cm_clksel_mdm);\r\nomap2xxx_sdrc_reprogram(CORE_CLK_SRC_DPLL_X2, 1);\r\nomap2_set_prcm(prcm->cm_clksel1_pll, prcm->base_sdrc_rfr,\r\nbypass);\r\nomap2xxx_sdrc_init_params(omap2xxx_sdrc_dll_is_unlocked());\r\nomap2xxx_sdrc_reprogram(done_rate, 0);\r\nlocal_irq_restore(flags);\r\n}\r\nreturn 0;\r\n}\r\nvoid omap2xxx_clkt_vps_check_bootloader_rates(void)\r\n{\r\nconst struct prcm_config *prcm = NULL;\r\nunsigned long rate;\r\nrate = omap2xxx_clk_get_core_rate();\r\nfor (prcm = rate_table; prcm->mpu_speed; prcm++) {\r\nif (!(prcm->flags & cpu_mask))\r\ncontinue;\r\nif (prcm->xtal_speed != sys_ck_rate)\r\ncontinue;\r\nif (prcm->dpll_speed <= rate)\r\nbreak;\r\n}\r\ncurr_prcm_set = prcm;\r\n}\r\nvoid omap2xxx_clkt_vps_late_init(void)\r\n{\r\nstruct clk *c;\r\nc = clk_get(NULL, "sys_ck");\r\nif (IS_ERR(c)) {\r\nWARN(1, "could not locate sys_ck\n");\r\n} else {\r\nsys_ck_rate = clk_get_rate(c);\r\nclk_put(c);\r\n}\r\n}\r\nvoid omap2xxx_clkt_vps_init(void)\r\n{\r\nstruct clk_init_data init = { NULL };\r\nstruct clk_hw_omap *hw = NULL;\r\nstruct clk *clk;\r\nconst char *parent_name = "mpu_ck";\r\nomap2xxx_clkt_vps_late_init();\r\nomap2xxx_clkt_vps_check_bootloader_rates();\r\nhw = kzalloc(sizeof(*hw), GFP_KERNEL);\r\nif (!hw)\r\ngoto cleanup;\r\ninit.name = "virt_prcm_set";\r\ninit.ops = &virt_prcm_set_ops;\r\ninit.parent_names = &parent_name;\r\ninit.num_parents = 1;\r\nhw->hw.init = &init;\r\nclk = clk_register(NULL, &hw->hw);\r\nclkdev_create(clk, "cpufreq_ck", NULL);\r\nreturn;\r\ncleanup:\r\nkfree(hw);\r\n}
