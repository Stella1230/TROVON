unsigned int get_rsa_modex_fc(struct ica_rsa_modexpo *mex, int *fcode)\r\n{\r\nif (!mex->inputdatalength)\r\nreturn -EINVAL;\r\nif (mex->inputdatalength <= 128)\r\n*fcode = MEX_1K;\r\nelse if (mex->inputdatalength <= 256)\r\n*fcode = MEX_2K;\r\nelse\r\n*fcode = MEX_4K;\r\nreturn 0;\r\n}\r\nunsigned int get_rsa_crt_fc(struct ica_rsa_modexpo_crt *crt, int *fcode)\r\n{\r\nif (!crt->inputdatalength)\r\nreturn -EINVAL;\r\nif (crt->inputdatalength <= 128)\r\n*fcode = CRT_1K;\r\nelse if (crt->inputdatalength <= 256)\r\n*fcode = CRT_2K;\r\nelse\r\n*fcode = CRT_4K;\r\nreturn 0;\r\n}\r\nstatic int ICAMEX_msg_to_type50MEX_msg(struct zcrypt_queue *zq,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nunsigned char *mod, *exp, *inp;\r\nint mod_len;\r\nmod_len = mex->inputdatalength;\r\nif (mod_len <= 128) {\r\nstruct type50_meb1_msg *meb1 = ap_msg->message;\r\nmemset(meb1, 0, sizeof(*meb1));\r\nap_msg->length = sizeof(*meb1);\r\nmeb1->header.msg_type_code = TYPE50_TYPE_CODE;\r\nmeb1->header.msg_len = sizeof(*meb1);\r\nmeb1->keyblock_type = TYPE50_MEB1_FMT;\r\nmod = meb1->modulus + sizeof(meb1->modulus) - mod_len;\r\nexp = meb1->exponent + sizeof(meb1->exponent) - mod_len;\r\ninp = meb1->message + sizeof(meb1->message) - mod_len;\r\n} else if (mod_len <= 256) {\r\nstruct type50_meb2_msg *meb2 = ap_msg->message;\r\nmemset(meb2, 0, sizeof(*meb2));\r\nap_msg->length = sizeof(*meb2);\r\nmeb2->header.msg_type_code = TYPE50_TYPE_CODE;\r\nmeb2->header.msg_len = sizeof(*meb2);\r\nmeb2->keyblock_type = TYPE50_MEB2_FMT;\r\nmod = meb2->modulus + sizeof(meb2->modulus) - mod_len;\r\nexp = meb2->exponent + sizeof(meb2->exponent) - mod_len;\r\ninp = meb2->message + sizeof(meb2->message) - mod_len;\r\n} else {\r\nstruct type50_meb3_msg *meb3 = ap_msg->message;\r\nmemset(meb3, 0, sizeof(*meb3));\r\nap_msg->length = sizeof(*meb3);\r\nmeb3->header.msg_type_code = TYPE50_TYPE_CODE;\r\nmeb3->header.msg_len = sizeof(*meb3);\r\nmeb3->keyblock_type = TYPE50_MEB3_FMT;\r\nmod = meb3->modulus + sizeof(meb3->modulus) - mod_len;\r\nexp = meb3->exponent + sizeof(meb3->exponent) - mod_len;\r\ninp = meb3->message + sizeof(meb3->message) - mod_len;\r\n}\r\nif (copy_from_user(mod, mex->n_modulus, mod_len) ||\r\ncopy_from_user(exp, mex->b_key, mod_len) ||\r\ncopy_from_user(inp, mex->inputdata, mod_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int ICACRT_msg_to_type50CRT_msg(struct zcrypt_queue *zq,\r\nstruct ap_message *ap_msg,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nint mod_len, short_len;\r\nunsigned char *p, *q, *dp, *dq, *u, *inp;\r\nmod_len = crt->inputdatalength;\r\nshort_len = (mod_len + 1) / 2;\r\nif (mod_len <= 128) {\r\nstruct type50_crb1_msg *crb1 = ap_msg->message;\r\nmemset(crb1, 0, sizeof(*crb1));\r\nap_msg->length = sizeof(*crb1);\r\ncrb1->header.msg_type_code = TYPE50_TYPE_CODE;\r\ncrb1->header.msg_len = sizeof(*crb1);\r\ncrb1->keyblock_type = TYPE50_CRB1_FMT;\r\np = crb1->p + sizeof(crb1->p) - short_len;\r\nq = crb1->q + sizeof(crb1->q) - short_len;\r\ndp = crb1->dp + sizeof(crb1->dp) - short_len;\r\ndq = crb1->dq + sizeof(crb1->dq) - short_len;\r\nu = crb1->u + sizeof(crb1->u) - short_len;\r\ninp = crb1->message + sizeof(crb1->message) - mod_len;\r\n} else if (mod_len <= 256) {\r\nstruct type50_crb2_msg *crb2 = ap_msg->message;\r\nmemset(crb2, 0, sizeof(*crb2));\r\nap_msg->length = sizeof(*crb2);\r\ncrb2->header.msg_type_code = TYPE50_TYPE_CODE;\r\ncrb2->header.msg_len = sizeof(*crb2);\r\ncrb2->keyblock_type = TYPE50_CRB2_FMT;\r\np = crb2->p + sizeof(crb2->p) - short_len;\r\nq = crb2->q + sizeof(crb2->q) - short_len;\r\ndp = crb2->dp + sizeof(crb2->dp) - short_len;\r\ndq = crb2->dq + sizeof(crb2->dq) - short_len;\r\nu = crb2->u + sizeof(crb2->u) - short_len;\r\ninp = crb2->message + sizeof(crb2->message) - mod_len;\r\n} else if ((mod_len <= 512) &&\r\n(zq->zcard->max_mod_size == CEX3A_MAX_MOD_SIZE)) {\r\nstruct type50_crb3_msg *crb3 = ap_msg->message;\r\nmemset(crb3, 0, sizeof(*crb3));\r\nap_msg->length = sizeof(*crb3);\r\ncrb3->header.msg_type_code = TYPE50_TYPE_CODE;\r\ncrb3->header.msg_len = sizeof(*crb3);\r\ncrb3->keyblock_type = TYPE50_CRB3_FMT;\r\np = crb3->p + sizeof(crb3->p) - short_len;\r\nq = crb3->q + sizeof(crb3->q) - short_len;\r\ndp = crb3->dp + sizeof(crb3->dp) - short_len;\r\ndq = crb3->dq + sizeof(crb3->dq) - short_len;\r\nu = crb3->u + sizeof(crb3->u) - short_len;\r\ninp = crb3->message + sizeof(crb3->message) - mod_len;\r\n} else\r\nreturn -EINVAL;\r\nif (copy_from_user(p, crt->np_prime + MSGTYPE_ADJUSTMENT, short_len) ||\r\ncopy_from_user(q, crt->nq_prime, short_len) ||\r\ncopy_from_user(dp, crt->bp_key + MSGTYPE_ADJUSTMENT, short_len) ||\r\ncopy_from_user(dq, crt->bq_key, short_len) ||\r\ncopy_from_user(u, crt->u_mult_inv + MSGTYPE_ADJUSTMENT, short_len) ||\r\ncopy_from_user(inp, crt->inputdata, mod_len))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_type80(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nstruct type80_hdr *t80h = reply->message;\r\nunsigned char *data;\r\nif (t80h->len < sizeof(*t80h) + outputdatalength) {\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x code=0x%02x => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\nt80h->code);\r\nreturn -EAGAIN;\r\n}\r\nif (zq->zcard->user_space_type == ZCRYPT_CEX2A)\r\nBUG_ON(t80h->len > CEX2A_MAX_RESPONSE_SIZE);\r\nelse\r\nBUG_ON(t80h->len > CEX3A_MAX_RESPONSE_SIZE);\r\ndata = reply->message + t80h->len - outputdatalength;\r\nif (copy_to_user(outputdata, data, outputdatalength))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic int convert_response(struct zcrypt_queue *zq,\r\nstruct ap_message *reply,\r\nchar __user *outputdata,\r\nunsigned int outputdatalength)\r\n{\r\nunsigned char rtype = ((unsigned char *) reply->message)[1];\r\nswitch (rtype) {\r\ncase TYPE82_RSP_CODE:\r\ncase TYPE88_RSP_CODE:\r\nreturn convert_error(zq, reply);\r\ncase TYPE80_RSP_CODE:\r\nreturn convert_type80(zq, reply,\r\noutputdata, outputdatalength);\r\ndefault:\r\nzq->online = 0;\r\npr_err("Cryptographic device %02x.%04x failed and was set offline\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid));\r\nZCRYPT_DBF(DBF_ERR,\r\n"device=%02x.%04x rtype=0x%02x => online=0 rc=EAGAIN\n",\r\nAP_QID_CARD(zq->queue->qid),\r\nAP_QID_QUEUE(zq->queue->qid),\r\n(unsigned int) rtype);\r\nreturn -EAGAIN;\r\n}\r\n}\r\nstatic void zcrypt_cex2a_receive(struct ap_queue *aq,\r\nstruct ap_message *msg,\r\nstruct ap_message *reply)\r\n{\r\nstatic struct error_hdr error_reply = {\r\n.type = TYPE82_RSP_CODE,\r\n.reply_code = REP82_ERROR_MACHINE_FAILURE,\r\n};\r\nstruct type80_hdr *t80h;\r\nint length;\r\nif (!reply)\r\ngoto out;\r\nt80h = reply->message;\r\nif (t80h->type == TYPE80_RSP_CODE) {\r\nif (aq->ap_dev.device_type == AP_DEVICE_TYPE_CEX2A)\r\nlength = min_t(int,\r\nCEX2A_MAX_RESPONSE_SIZE, t80h->len);\r\nelse\r\nlength = min_t(int,\r\nCEX3A_MAX_RESPONSE_SIZE, t80h->len);\r\nmemcpy(msg->message, reply->message, length);\r\n} else\r\nmemcpy(msg->message, reply->message, sizeof(error_reply));\r\nout:\r\ncomplete((struct completion *) msg->private);\r\n}\r\nstatic long zcrypt_cex2a_modexpo(struct zcrypt_queue *zq,\r\nstruct ica_rsa_modexpo *mex)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nif (zq->zcard->user_space_type == ZCRYPT_CEX2A)\r\nap_msg.message = kmalloc(MSGTYPE50_CRB2_MAX_MSG_SIZE,\r\nGFP_KERNEL);\r\nelse\r\nap_msg.message = kmalloc(MSGTYPE50_CRB3_MAX_MSG_SIZE,\r\nGFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_cex2a_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICAMEX_msg_to_type50MEX_msg(zq, &ap_msg, mex);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zq->queue, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0) {\r\nrc = ap_msg.rc;\r\nif (rc == 0)\r\nrc = convert_response(zq, &ap_msg, mex->outputdata,\r\nmex->outputdatalength);\r\n} else\r\nap_cancel_message(zq->queue, &ap_msg);\r\nout_free:\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nstatic long zcrypt_cex2a_modexpo_crt(struct zcrypt_queue *zq,\r\nstruct ica_rsa_modexpo_crt *crt)\r\n{\r\nstruct ap_message ap_msg;\r\nstruct completion work;\r\nint rc;\r\nap_init_message(&ap_msg);\r\nif (zq->zcard->user_space_type == ZCRYPT_CEX2A)\r\nap_msg.message = kmalloc(MSGTYPE50_CRB2_MAX_MSG_SIZE,\r\nGFP_KERNEL);\r\nelse\r\nap_msg.message = kmalloc(MSGTYPE50_CRB3_MAX_MSG_SIZE,\r\nGFP_KERNEL);\r\nif (!ap_msg.message)\r\nreturn -ENOMEM;\r\nap_msg.receive = zcrypt_cex2a_receive;\r\nap_msg.psmid = (((unsigned long long) current->pid) << 32) +\r\natomic_inc_return(&zcrypt_step);\r\nap_msg.private = &work;\r\nrc = ICACRT_msg_to_type50CRT_msg(zq, &ap_msg, crt);\r\nif (rc)\r\ngoto out_free;\r\ninit_completion(&work);\r\nap_queue_message(zq->queue, &ap_msg);\r\nrc = wait_for_completion_interruptible(&work);\r\nif (rc == 0) {\r\nrc = ap_msg.rc;\r\nif (rc == 0)\r\nrc = convert_response(zq, &ap_msg, crt->outputdata,\r\ncrt->outputdatalength);\r\n} else\r\nap_cancel_message(zq->queue, &ap_msg);\r\nout_free:\r\nkfree(ap_msg.message);\r\nreturn rc;\r\n}\r\nvoid __init zcrypt_msgtype50_init(void)\r\n{\r\nzcrypt_msgtype_register(&zcrypt_msgtype50_ops);\r\n}\r\nvoid __exit zcrypt_msgtype50_exit(void)\r\n{\r\nzcrypt_msgtype_unregister(&zcrypt_msgtype50_ops);\r\n}
