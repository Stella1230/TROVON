static int isl29018_set_integration_time(struct isl29018_chip *chip,\r\nunsigned int utime)\r\n{\r\nunsigned int i;\r\nint ret;\r\nunsigned int int_time, new_int_time;\r\nfor (i = 0; i < ARRAY_SIZE(isl29018_int_utimes[chip->type]); ++i) {\r\nif (utime == isl29018_int_utimes[chip->type][i]) {\r\nnew_int_time = i;\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(isl29018_int_utimes[chip->type]))\r\nreturn -EINVAL;\r\nret = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMAND2,\r\nISL29018_CMD2_RESOLUTION_MASK,\r\ni << ISL29018_CMD2_RESOLUTION_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nint_time = chip->int_time;\r\nfor (i = 0; i < ARRAY_SIZE(isl29018_scales[int_time]); ++i) {\r\nif (chip->scale.scale == isl29018_scales[int_time][i].scale &&\r\nchip->scale.uscale == isl29018_scales[int_time][i].uscale) {\r\nchip->scale = isl29018_scales[new_int_time][i];\r\nbreak;\r\n}\r\n}\r\nchip->int_time = new_int_time;\r\nreturn 0;\r\n}\r\nstatic int isl29018_set_scale(struct isl29018_chip *chip, int scale, int uscale)\r\n{\r\nunsigned int i;\r\nint ret;\r\nstruct isl29018_scale new_scale;\r\nfor (i = 0; i < ARRAY_SIZE(isl29018_scales[chip->int_time]); ++i) {\r\nif (scale == isl29018_scales[chip->int_time][i].scale &&\r\nuscale == isl29018_scales[chip->int_time][i].uscale) {\r\nnew_scale = isl29018_scales[chip->int_time][i];\r\nbreak;\r\n}\r\n}\r\nif (i >= ARRAY_SIZE(isl29018_scales[chip->int_time]))\r\nreturn -EINVAL;\r\nret = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMAND2,\r\nISL29018_CMD2_RANGE_MASK,\r\ni << ISL29018_CMD2_RANGE_SHIFT);\r\nif (ret < 0)\r\nreturn ret;\r\nchip->scale = new_scale;\r\nreturn 0;\r\n}\r\nstatic int isl29018_read_sensor_input(struct isl29018_chip *chip, int mode)\r\n{\r\nint status;\r\nunsigned int lsb;\r\nunsigned int msb;\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nstatus = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1,\r\nmode << ISL29018_CMD1_OPMODE_SHIFT);\r\nif (status) {\r\ndev_err(dev,\r\n"Error in setting operating mode err %d\n", status);\r\nreturn status;\r\n}\r\nmsleep(ISL29018_CONV_TIME_MS);\r\nstatus = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_LSB, &lsb);\r\nif (status < 0) {\r\ndev_err(dev,\r\n"Error in reading LSB DATA with err %d\n", status);\r\nreturn status;\r\n}\r\nstatus = regmap_read(chip->regmap, ISL29018_REG_ADD_DATA_MSB, &msb);\r\nif (status < 0) {\r\ndev_err(dev,\r\n"Error in reading MSB DATA with error %d\n", status);\r\nreturn status;\r\n}\r\ndev_vdbg(dev, "MSB 0x%x and LSB 0x%x\n", msb, lsb);\r\nreturn (msb << 8) | lsb;\r\n}\r\nstatic int isl29018_read_lux(struct isl29018_chip *chip, int *lux)\r\n{\r\nint lux_data;\r\nunsigned int data_x_range;\r\nlux_data = isl29018_read_sensor_input(chip,\r\nISL29018_CMD1_OPMODE_ALS_ONCE);\r\nif (lux_data < 0)\r\nreturn lux_data;\r\ndata_x_range = lux_data * chip->scale.scale +\r\nlux_data * chip->scale.uscale / 1000000;\r\n*lux = data_x_range * chip->calibscale +\r\ndata_x_range * chip->ucalibscale / 1000000;\r\nreturn 0;\r\n}\r\nstatic int isl29018_read_ir(struct isl29018_chip *chip, int *ir)\r\n{\r\nint ir_data;\r\nir_data = isl29018_read_sensor_input(chip,\r\nISL29018_CMD1_OPMODE_IR_ONCE);\r\nif (ir_data < 0)\r\nreturn ir_data;\r\n*ir = ir_data;\r\nreturn 0;\r\n}\r\nstatic int isl29018_read_proximity_ir(struct isl29018_chip *chip, int scheme,\r\nint *near_ir)\r\n{\r\nint status;\r\nint prox_data = -1;\r\nint ir_data = -1;\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nstatus = regmap_update_bits(chip->regmap, ISL29018_REG_ADD_COMMAND2,\r\nISL29018_CMD2_SCHEME_MASK,\r\nscheme << ISL29018_CMD2_SCHEME_SHIFT);\r\nif (status) {\r\ndev_err(dev, "Error in setting operating mode\n");\r\nreturn status;\r\n}\r\nprox_data = isl29018_read_sensor_input(chip,\r\nISL29018_CMD1_OPMODE_PROX_ONCE);\r\nif (prox_data < 0)\r\nreturn prox_data;\r\nif (scheme == 1) {\r\n*near_ir = prox_data;\r\nreturn 0;\r\n}\r\nir_data = isl29018_read_sensor_input(chip,\r\nISL29018_CMD1_OPMODE_IR_ONCE);\r\nif (ir_data < 0)\r\nreturn ir_data;\r\nif (prox_data >= ir_data)\r\n*near_ir = prox_data - ir_data;\r\nelse\r\n*near_ir = 0;\r\nreturn 0;\r\n}\r\nstatic ssize_t in_illuminance_scale_available_show\r\n(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nunsigned int i;\r\nint len = 0;\r\nmutex_lock(&chip->lock);\r\nfor (i = 0; i < ARRAY_SIZE(isl29018_scales[chip->int_time]); ++i)\r\nlen += sprintf(buf + len, "%d.%06d ",\r\nisl29018_scales[chip->int_time][i].scale,\r\nisl29018_scales[chip->int_time][i].uscale);\r\nmutex_unlock(&chip->lock);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t in_illuminance_integration_time_available_show\r\n(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nunsigned int i;\r\nint len = 0;\r\nfor (i = 0; i < ARRAY_SIZE(isl29018_int_utimes[chip->type]); ++i)\r\nlen += sprintf(buf + len, "0.%06d ",\r\nisl29018_int_utimes[chip->type][i]);\r\nbuf[len - 1] = '\n';\r\nreturn len;\r\n}\r\nstatic ssize_t proximity_on_chip_ambient_infrared_suppression_show\r\n(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nreturn sprintf(buf, "%d\n", chip->prox_scheme);\r\n}\r\nstatic ssize_t proximity_on_chip_ambient_infrared_suppression_store\r\n(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct iio_dev *indio_dev = dev_to_iio_dev(dev);\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nint val;\r\nif (kstrtoint(buf, 10, &val))\r\nreturn -EINVAL;\r\nif (!(val == 0 || val == 1))\r\nreturn -EINVAL;\r\nmutex_lock(&chip->lock);\r\nchip->prox_scheme = val;\r\nmutex_unlock(&chip->lock);\r\nreturn count;\r\n}\r\nstatic int isl29018_write_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint val,\r\nint val2,\r\nlong mask)\r\n{\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nint ret = -EINVAL;\r\nmutex_lock(&chip->lock);\r\nif (chip->suspended) {\r\nret = -EBUSY;\r\ngoto write_done;\r\n}\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_LIGHT) {\r\nchip->calibscale = val;\r\nchip->ucalibscale = val2;\r\nret = 0;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (chan->type == IIO_LIGHT && !val)\r\nret = isl29018_set_integration_time(chip, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_LIGHT)\r\nret = isl29018_set_scale(chip, val, val2);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nwrite_done:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int isl29018_read_raw(struct iio_dev *indio_dev,\r\nstruct iio_chan_spec const *chan,\r\nint *val,\r\nint *val2,\r\nlong mask)\r\n{\r\nint ret = -EINVAL;\r\nstruct isl29018_chip *chip = iio_priv(indio_dev);\r\nmutex_lock(&chip->lock);\r\nif (chip->suspended) {\r\nret = -EBUSY;\r\ngoto read_done;\r\n}\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_RAW:\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nswitch (chan->type) {\r\ncase IIO_LIGHT:\r\nret = isl29018_read_lux(chip, val);\r\nbreak;\r\ncase IIO_INTENSITY:\r\nret = isl29018_read_ir(chip, val);\r\nbreak;\r\ncase IIO_PROXIMITY:\r\nret = isl29018_read_proximity_ir(chip,\r\nchip->prox_scheme,\r\nval);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nif (!ret)\r\nret = IIO_VAL_INT;\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = 0;\r\n*val2 = isl29018_int_utimes[chip->type][chip->int_time];\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_SCALE:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = chip->scale.scale;\r\n*val2 = chip->scale.uscale;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nbreak;\r\ncase IIO_CHAN_INFO_CALIBSCALE:\r\nif (chan->type == IIO_LIGHT) {\r\n*val = chip->calibscale;\r\n*val2 = chip->ucalibscale;\r\nret = IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nread_done:\r\nmutex_unlock(&chip->lock);\r\nreturn ret;\r\n}\r\nstatic int isl29018_chip_init(struct isl29018_chip *chip)\r\n{\r\nint status;\r\nstruct device *dev = regmap_get_device(chip->regmap);\r\nif (chip->type == isl29035) {\r\nunsigned int id;\r\nstatus = regmap_read(chip->regmap, ISL29035_REG_DEVICE_ID, &id);\r\nif (status < 0) {\r\ndev_err(dev,\r\n"Error reading ID register with error %d\n",\r\nstatus);\r\nreturn status;\r\n}\r\nid = (id & ISL29035_DEVICE_ID_MASK) >> ISL29035_DEVICE_ID_SHIFT;\r\nif (id != ISL29035_DEVICE_ID)\r\nreturn -ENODEV;\r\nstatus = regmap_update_bits(chip->regmap,\r\nISL29035_REG_DEVICE_ID,\r\nISL29035_BOUT_MASK, 0);\r\nif (status < 0)\r\nreturn status;\r\n}\r\nstatus = regmap_write(chip->regmap, ISL29018_REG_TEST, 0x0);\r\nif (status < 0) {\r\ndev_err(dev, "Failed to clear isl29018 TEST reg.(%d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\nstatus = regmap_write(chip->regmap, ISL29018_REG_ADD_COMMAND1, 0);\r\nif (status < 0) {\r\ndev_err(dev, "Failed to clear isl29018 CMD1 reg.(%d)\n",\r\nstatus);\r\nreturn status;\r\n}\r\nusleep_range(1000, 2000);\r\nstatus = isl29018_set_scale(chip, chip->scale.scale,\r\nchip->scale.uscale);\r\nif (status < 0) {\r\ndev_err(dev, "Init of isl29018 fails\n");\r\nreturn status;\r\n}\r\nstatus = isl29018_set_integration_time(chip,\r\nisl29018_int_utimes[chip->type][chip->int_time]);\r\nif (status < 0)\r\ndev_err(dev, "Init of isl29018 fails\n");\r\nreturn status;\r\n}\r\nstatic bool isl29018_is_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase ISL29018_REG_ADD_DATA_LSB:\r\ncase ISL29018_REG_ADD_DATA_MSB:\r\ncase ISL29018_REG_ADD_COMMAND1:\r\ncase ISL29018_REG_TEST:\r\ncase ISL29035_REG_DEVICE_ID:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic const char *isl29018_match_acpi_device(struct device *dev, int *data)\r\n{\r\nconst struct acpi_device_id *id;\r\nid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (!id)\r\nreturn NULL;\r\n*data = (int)id->driver_data;\r\nreturn dev_name(dev);\r\n}\r\nstatic int isl29018_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct isl29018_chip *chip;\r\nstruct iio_dev *indio_dev;\r\nint err;\r\nconst char *name = NULL;\r\nint dev_id = 0;\r\nindio_dev = devm_iio_device_alloc(&client->dev, sizeof(*chip));\r\nif (!indio_dev)\r\nreturn -ENOMEM;\r\nchip = iio_priv(indio_dev);\r\ni2c_set_clientdata(client, indio_dev);\r\nif (id) {\r\nname = id->name;\r\ndev_id = id->driver_data;\r\n}\r\nif (ACPI_HANDLE(&client->dev))\r\nname = isl29018_match_acpi_device(&client->dev, &dev_id);\r\nmutex_init(&chip->lock);\r\nchip->type = dev_id;\r\nchip->calibscale = 1;\r\nchip->ucalibscale = 0;\r\nchip->int_time = ISL29018_INT_TIME_16;\r\nchip->scale = isl29018_scales[chip->int_time][0];\r\nchip->suspended = false;\r\nchip->regmap = devm_regmap_init_i2c(client,\r\nisl29018_chip_info_tbl[dev_id].regmap_cfg);\r\nif (IS_ERR(chip->regmap)) {\r\nerr = PTR_ERR(chip->regmap);\r\ndev_err(&client->dev, "regmap initialization fails: %d\n", err);\r\nreturn err;\r\n}\r\nerr = isl29018_chip_init(chip);\r\nif (err)\r\nreturn err;\r\nindio_dev->info = isl29018_chip_info_tbl[dev_id].indio_info;\r\nindio_dev->channels = isl29018_chip_info_tbl[dev_id].channels;\r\nindio_dev->num_channels = isl29018_chip_info_tbl[dev_id].num_channels;\r\nindio_dev->name = name;\r\nindio_dev->dev.parent = &client->dev;\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nreturn devm_iio_device_register(&client->dev, indio_dev);\r\n}\r\nstatic int isl29018_suspend(struct device *dev)\r\n{\r\nstruct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));\r\nmutex_lock(&chip->lock);\r\nchip->suspended = true;\r\nmutex_unlock(&chip->lock);\r\nreturn 0;\r\n}\r\nstatic int isl29018_resume(struct device *dev)\r\n{\r\nstruct isl29018_chip *chip = iio_priv(dev_get_drvdata(dev));\r\nint err;\r\nmutex_lock(&chip->lock);\r\nerr = isl29018_chip_init(chip);\r\nif (!err)\r\nchip->suspended = false;\r\nmutex_unlock(&chip->lock);\r\nreturn err;\r\n}
