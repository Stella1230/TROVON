static inline void\r\nsuperio_outb(int reg, int val)\r\n{\r\noutb(reg, REG);\r\noutb(val, VAL);\r\n}\r\nstatic inline int\r\nsuperio_inb(int reg)\r\n{\r\noutb(reg, REG);\r\nreturn inb(VAL);\r\n}\r\nstatic inline void\r\nsuperio_enter(void)\r\n{\r\noutb(0x55, REG);\r\n}\r\nstatic inline void\r\nsuperio_exit(void)\r\n{\r\noutb(0xAA, REG);\r\n}\r\nstatic inline int smsc47m1_read_value(struct smsc47m1_data *data, u8 reg)\r\n{\r\nreturn inb_p(data->addr + reg);\r\n}\r\nstatic inline void smsc47m1_write_value(struct smsc47m1_data *data, u8 reg,\r\nu8 value)\r\n{\r\noutb_p(value, data->addr + reg);\r\n}\r\nstatic struct smsc47m1_data *smsc47m1_update_device(struct device *dev,\r\nint init)\r\n{\r\nstruct smsc47m1_data *data = dev_get_drvdata(dev);\r\nmutex_lock(&data->update_lock);\r\nif (time_after(jiffies, data->last_updated + HZ + HZ / 2) || init) {\r\nint i, fan_nr;\r\nfan_nr = data->type == smsc47m2 ? 3 : 2;\r\nfor (i = 0; i < fan_nr; i++) {\r\ndata->fan[i] = smsc47m1_read_value(data,\r\nSMSC47M1_REG_FAN[i]);\r\ndata->fan_preload[i] = smsc47m1_read_value(data,\r\nSMSC47M1_REG_FAN_PRELOAD[i]);\r\ndata->pwm[i] = smsc47m1_read_value(data,\r\nSMSC47M1_REG_PWM[i]);\r\n}\r\ni = smsc47m1_read_value(data, SMSC47M1_REG_FANDIV);\r\ndata->fan_div[0] = (i >> 4) & 0x03;\r\ndata->fan_div[1] = i >> 6;\r\ndata->alarms = smsc47m1_read_value(data,\r\nSMSC47M1_REG_ALARM) >> 6;\r\nif (data->alarms)\r\nsmsc47m1_write_value(data, SMSC47M1_REG_ALARM, 0xC0);\r\nif (fan_nr >= 3) {\r\ndata->fan_div[2] = (smsc47m1_read_value(data,\r\nSMSC47M2_REG_FANDIV3) >> 4) & 0x03;\r\ndata->alarms |= (smsc47m1_read_value(data,\r\nSMSC47M2_REG_ALARM6) & 0x40) >> 4;\r\nif (data->alarms & 0x04)\r\nsmsc47m1_write_value(data,\r\nSMSC47M2_REG_ALARM6,\r\n0x40);\r\n}\r\ndata->last_updated = jiffies;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn data;\r\n}\r\nstatic ssize_t get_fan(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nint nr = attr->index;\r\nint rpm = (data->pwm[nr] & 0x7F) == 0x00 ? 0 :\r\nFAN_FROM_REG(data->fan[nr],\r\nDIV_FROM_REG(data->fan_div[nr]),\r\ndata->fan_preload[nr]);\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t get_fan_min(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nint nr = attr->index;\r\nint rpm = MIN_FROM_REG(data->fan_preload[nr],\r\nDIV_FROM_REG(data->fan_div[nr]));\r\nreturn sprintf(buf, "%d\n", rpm);\r\n}\r\nstatic ssize_t get_fan_div(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nreturn sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[attr->index]));\r\n}\r\nstatic ssize_t get_fan_alarm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nint bitnr = to_sensor_dev_attr(devattr)->index;\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nreturn sprintf(buf, "%u\n", (data->alarms >> bitnr) & 1);\r\n}\r\nstatic ssize_t get_pwm(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nreturn sprintf(buf, "%d\n", PWM_FROM_REG(data->pwm[attr->index]));\r\n}\r\nstatic ssize_t get_pwm_en(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nreturn sprintf(buf, "%d\n", PWM_EN_FROM_REG(data->pwm[attr->index]));\r\n}\r\nstatic ssize_t alarms_show(struct device *dev,\r\nstruct device_attribute *devattr, char *buf)\r\n{\r\nstruct smsc47m1_data *data = smsc47m1_update_device(dev, 0);\r\nreturn sprintf(buf, "%d\n", data->alarms);\r\n}\r\nstatic ssize_t set_fan_min(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nlong rpmdiv;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nmutex_lock(&data->update_lock);\r\nrpmdiv = val * DIV_FROM_REG(data->fan_div[nr]);\r\nif (983040 > 192 * rpmdiv || 2 * rpmdiv > 983040) {\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\ndata->fan_preload[nr] = 192 - ((983040 + rpmdiv / 2) / rpmdiv);\r\nsmsc47m1_write_value(data, SMSC47M1_REG_FAN_PRELOAD[nr],\r\ndata->fan_preload[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_fan_div(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nlong new_div;\r\nint err;\r\nlong tmp;\r\nu8 old_div = DIV_FROM_REG(data->fan_div[nr]);\r\nerr = kstrtol(buf, 10, &new_div);\r\nif (err)\r\nreturn err;\r\nif (new_div == old_div)\r\nreturn count;\r\nmutex_lock(&data->update_lock);\r\nswitch (new_div) {\r\ncase 1:\r\ndata->fan_div[nr] = 0;\r\nbreak;\r\ncase 2:\r\ndata->fan_div[nr] = 1;\r\nbreak;\r\ncase 4:\r\ndata->fan_div[nr] = 2;\r\nbreak;\r\ncase 8:\r\ndata->fan_div[nr] = 3;\r\nbreak;\r\ndefault:\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\nswitch (nr) {\r\ncase 0:\r\ncase 1:\r\ntmp = smsc47m1_read_value(data, SMSC47M1_REG_FANDIV)\r\n& ~(0x03 << (4 + 2 * nr));\r\ntmp |= data->fan_div[nr] << (4 + 2 * nr);\r\nsmsc47m1_write_value(data, SMSC47M1_REG_FANDIV, tmp);\r\nbreak;\r\ncase 2:\r\ntmp = smsc47m1_read_value(data, SMSC47M2_REG_FANDIV3) & 0xCF;\r\ntmp |= data->fan_div[2] << 4;\r\nsmsc47m1_write_value(data, SMSC47M2_REG_FANDIV3, tmp);\r\nbreak;\r\n}\r\ntmp = 192 - (old_div * (192 - data->fan_preload[nr])\r\n+ new_div / 2) / new_div;\r\ndata->fan_preload[nr] = clamp_val(tmp, 0, 191);\r\nsmsc47m1_write_value(data, SMSC47M1_REG_FAN_PRELOAD[nr],\r\ndata->fan_preload[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nlong val;\r\nint err;\r\nerr = kstrtol(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val < 0 || val > 255)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] &= 0x81;\r\ndata->pwm[nr] |= PWM_TO_REG(val);\r\nsmsc47m1_write_value(data, SMSC47M1_REG_PWM[nr],\r\ndata->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t set_pwm_en(struct device *dev, struct device_attribute\r\n*devattr, const char *buf, size_t count)\r\n{\r\nstruct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);\r\nstruct smsc47m1_data *data = dev_get_drvdata(dev);\r\nint nr = attr->index;\r\nunsigned long val;\r\nint err;\r\nerr = kstrtoul(buf, 10, &val);\r\nif (err)\r\nreturn err;\r\nif (val > 1)\r\nreturn -EINVAL;\r\nmutex_lock(&data->update_lock);\r\ndata->pwm[nr] &= 0xFE;\r\ndata->pwm[nr] |= !val;\r\nsmsc47m1_write_value(data, SMSC47M1_REG_PWM[nr],\r\ndata->pwm[nr]);\r\nmutex_unlock(&data->update_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t name_show(struct device *dev, struct device_attribute\r\n*devattr, char *buf)\r\n{\r\nstruct smsc47m1_data *data = dev_get_drvdata(dev);\r\nreturn sprintf(buf, "%s\n", data->name);\r\n}\r\nstatic int __init smsc47m1_find(struct smsc47m1_sio_data *sio_data)\r\n{\r\nu8 val;\r\nunsigned short addr;\r\nsuperio_enter();\r\nval = force_id ? force_id : superio_inb(SUPERIO_REG_DEVID);\r\nswitch (val) {\r\ncase 0x51:\r\npr_info("Found SMSC LPC47B27x\n");\r\nsio_data->type = smsc47m1;\r\nbreak;\r\ncase 0x59:\r\npr_info("Found SMSC LPC47M10x/LPC47M112/LPC47M13x\n");\r\nsio_data->type = smsc47m1;\r\nbreak;\r\ncase 0x5F:\r\npr_info("Found SMSC LPC47M14x\n");\r\nsio_data->type = smsc47m1;\r\nbreak;\r\ncase 0x60:\r\npr_info("Found SMSC LPC47M15x/LPC47M192/LPC47M997\n");\r\nsio_data->type = smsc47m1;\r\nbreak;\r\ncase 0x6B:\r\nif (superio_inb(SUPERIO_REG_DEVREV) & 0x80) {\r\npr_debug("Found SMSC LPC47M233, unsupported\n");\r\nsuperio_exit();\r\nreturn -ENODEV;\r\n}\r\npr_info("Found SMSC LPC47M292\n");\r\nsio_data->type = smsc47m2;\r\nbreak;\r\ndefault:\r\nsuperio_exit();\r\nreturn -ENODEV;\r\n}\r\nsuperio_select();\r\naddr = (superio_inb(SUPERIO_REG_BASE) << 8)\r\n| superio_inb(SUPERIO_REG_BASE + 1);\r\nif (addr == 0) {\r\npr_info("Device address not set, will not use\n");\r\nsuperio_exit();\r\nreturn -ENODEV;\r\n}\r\nsio_data->activate = superio_inb(SUPERIO_REG_ACT);\r\nif ((sio_data->activate & 0x01) == 0) {\r\npr_info("Enabling device\n");\r\nsuperio_outb(SUPERIO_REG_ACT, sio_data->activate | 0x01);\r\n}\r\nsuperio_exit();\r\nreturn addr;\r\n}\r\nstatic void smsc47m1_restore(const struct smsc47m1_sio_data *sio_data)\r\n{\r\nif ((sio_data->activate & 0x01) == 0) {\r\nsuperio_enter();\r\nsuperio_select();\r\npr_info("Disabling device\n");\r\nsuperio_outb(SUPERIO_REG_ACT, sio_data->activate);\r\nsuperio_exit();\r\n}\r\n}\r\nstatic int __init smsc47m1_handle_resources(unsigned short address,\r\nenum chips type, int action,\r\nstruct device *dev)\r\n{\r\nstatic const u8 ports_m1[] = {\r\n0x04, 1,\r\n0x33, 4,\r\n0x56, 7,\r\n};\r\nstatic const u8 ports_m2[] = {\r\n0x04, 1,\r\n0x09, 1,\r\n0x2c, 2,\r\n0x35, 4,\r\n0x56, 7,\r\n0x69, 4,\r\n};\r\nint i, ports_size, err;\r\nconst u8 *ports;\r\nswitch (type) {\r\ncase smsc47m1:\r\ndefault:\r\nports = ports_m1;\r\nports_size = ARRAY_SIZE(ports_m1);\r\nbreak;\r\ncase smsc47m2:\r\nports = ports_m2;\r\nports_size = ARRAY_SIZE(ports_m2);\r\nbreak;\r\n}\r\nfor (i = 0; i + 1 < ports_size; i += 2) {\r\nunsigned short start = address + ports[i];\r\nunsigned short len = ports[i + 1];\r\nswitch (action) {\r\ncase CHECK:\r\nerr = acpi_check_region(start, len, DRVNAME);\r\nif (err)\r\nreturn err;\r\nbreak;\r\ncase REQUEST:\r\nif (!devm_request_region(dev, start, len, DRVNAME)) {\r\ndev_err(dev,\r\n"Region 0x%hx-0x%hx already in use!\n",\r\nstart, start + len);\r\nreturn -EBUSY;\r\n}\r\nbreak;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void smsc47m1_remove_files(struct device *dev)\r\n{\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group);\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group_fan1);\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group_fan2);\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group_fan3);\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group_pwm1);\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group_pwm2);\r\nsysfs_remove_group(&dev->kobj, &smsc47m1_group_pwm3);\r\n}\r\nstatic int __init smsc47m1_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct smsc47m1_sio_data *sio_data = dev_get_platdata(dev);\r\nstruct smsc47m1_data *data;\r\nstruct resource *res;\r\nint err;\r\nint fan1, fan2, fan3, pwm1, pwm2, pwm3;\r\nstatic const char * const names[] = {\r\n"smsc47m1",\r\n"smsc47m2",\r\n};\r\nres = platform_get_resource(pdev, IORESOURCE_IO, 0);\r\nerr = smsc47m1_handle_resources(res->start, sio_data->type,\r\nREQUEST, dev);\r\nif (err < 0)\r\nreturn err;\r\ndata = devm_kzalloc(dev, sizeof(struct smsc47m1_data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ndata->addr = res->start;\r\ndata->type = sio_data->type;\r\ndata->name = names[sio_data->type];\r\nmutex_init(&data->update_lock);\r\nplatform_set_drvdata(pdev, data);\r\npwm1 = (smsc47m1_read_value(data, SMSC47M1_REG_PPIN(0)) & 0x05)\r\n== 0x04;\r\npwm2 = (smsc47m1_read_value(data, SMSC47M1_REG_PPIN(1)) & 0x05)\r\n== 0x04;\r\nif (data->type == smsc47m2) {\r\nfan1 = (smsc47m1_read_value(data, SMSC47M2_REG_TPIN1)\r\n& 0x0d) == 0x09;\r\nfan2 = (smsc47m1_read_value(data, SMSC47M2_REG_TPIN2)\r\n& 0x0d) == 0x09;\r\nfan3 = (smsc47m1_read_value(data, SMSC47M2_REG_TPIN3)\r\n& 0x0d) == 0x0d;\r\npwm3 = (smsc47m1_read_value(data, SMSC47M2_REG_PPIN3)\r\n& 0x0d) == 0x08;\r\n} else {\r\nfan1 = (smsc47m1_read_value(data, SMSC47M1_REG_TPIN(0))\r\n& 0x05) == 0x05;\r\nfan2 = (smsc47m1_read_value(data, SMSC47M1_REG_TPIN(1))\r\n& 0x05) == 0x05;\r\nfan3 = 0;\r\npwm3 = 0;\r\n}\r\nif (!(fan1 || fan2 || fan3 || pwm1 || pwm2 || pwm3)) {\r\ndev_warn(dev, "Device not configured, will not use\n");\r\nreturn -ENODEV;\r\n}\r\nsmsc47m1_update_device(dev, 1);\r\nif (fan1) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&smsc47m1_group_fan1);\r\nif (err)\r\ngoto error_remove_files;\r\n} else\r\ndev_dbg(dev, "Fan 1 not enabled by hardware, skipping\n");\r\nif (fan2) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&smsc47m1_group_fan2);\r\nif (err)\r\ngoto error_remove_files;\r\n} else\r\ndev_dbg(dev, "Fan 2 not enabled by hardware, skipping\n");\r\nif (fan3) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&smsc47m1_group_fan3);\r\nif (err)\r\ngoto error_remove_files;\r\n} else if (data->type == smsc47m2)\r\ndev_dbg(dev, "Fan 3 not enabled by hardware, skipping\n");\r\nif (pwm1) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&smsc47m1_group_pwm1);\r\nif (err)\r\ngoto error_remove_files;\r\n} else\r\ndev_dbg(dev, "PWM 1 not enabled by hardware, skipping\n");\r\nif (pwm2) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&smsc47m1_group_pwm2);\r\nif (err)\r\ngoto error_remove_files;\r\n} else\r\ndev_dbg(dev, "PWM 2 not enabled by hardware, skipping\n");\r\nif (pwm3) {\r\nerr = sysfs_create_group(&dev->kobj,\r\n&smsc47m1_group_pwm3);\r\nif (err)\r\ngoto error_remove_files;\r\n} else if (data->type == smsc47m2)\r\ndev_dbg(dev, "PWM 3 not enabled by hardware, skipping\n");\r\nerr = sysfs_create_group(&dev->kobj, &smsc47m1_group);\r\nif (err)\r\ngoto error_remove_files;\r\ndata->hwmon_dev = hwmon_device_register(dev);\r\nif (IS_ERR(data->hwmon_dev)) {\r\nerr = PTR_ERR(data->hwmon_dev);\r\ngoto error_remove_files;\r\n}\r\nreturn 0;\r\nerror_remove_files:\r\nsmsc47m1_remove_files(dev);\r\nreturn err;\r\n}\r\nstatic int __exit smsc47m1_remove(struct platform_device *pdev)\r\n{\r\nstruct smsc47m1_data *data = platform_get_drvdata(pdev);\r\nhwmon_device_unregister(data->hwmon_dev);\r\nsmsc47m1_remove_files(&pdev->dev);\r\nreturn 0;\r\n}\r\nstatic int __init smsc47m1_device_add(unsigned short address,\r\nconst struct smsc47m1_sio_data *sio_data)\r\n{\r\nstruct resource res = {\r\n.start = address,\r\n.end = address + SMSC_EXTENT - 1,\r\n.name = DRVNAME,\r\n.flags = IORESOURCE_IO,\r\n};\r\nint err;\r\nerr = smsc47m1_handle_resources(address, sio_data->type, CHECK, NULL);\r\nif (err)\r\ngoto exit;\r\npdev = platform_device_alloc(DRVNAME, address);\r\nif (!pdev) {\r\nerr = -ENOMEM;\r\npr_err("Device allocation failed\n");\r\ngoto exit;\r\n}\r\nerr = platform_device_add_resources(pdev, &res, 1);\r\nif (err) {\r\npr_err("Device resource addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add_data(pdev, sio_data,\r\nsizeof(struct smsc47m1_sio_data));\r\nif (err) {\r\npr_err("Platform data allocation failed\n");\r\ngoto exit_device_put;\r\n}\r\nerr = platform_device_add(pdev);\r\nif (err) {\r\npr_err("Device addition failed (%d)\n", err);\r\ngoto exit_device_put;\r\n}\r\nreturn 0;\r\nexit_device_put:\r\nplatform_device_put(pdev);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int __init sm_smsc47m1_init(void)\r\n{\r\nint err;\r\nunsigned short address;\r\nstruct smsc47m1_sio_data sio_data;\r\nerr = smsc47m1_find(&sio_data);\r\nif (err < 0)\r\nreturn err;\r\naddress = err;\r\nerr = smsc47m1_device_add(address, &sio_data);\r\nif (err)\r\nreturn err;\r\nerr = platform_driver_probe(&smsc47m1_driver, smsc47m1_probe);\r\nif (err)\r\ngoto exit_device;\r\nreturn 0;\r\nexit_device:\r\nplatform_device_unregister(pdev);\r\nsmsc47m1_restore(&sio_data);\r\nreturn err;\r\n}\r\nstatic void __exit sm_smsc47m1_exit(void)\r\n{\r\nplatform_driver_unregister(&smsc47m1_driver);\r\nsmsc47m1_restore(dev_get_platdata(&pdev->dev));\r\nplatform_device_unregister(pdev);\r\n}
