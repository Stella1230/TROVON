static inline void pmic_arb_base_write(struct spmi_pmic_arb_dev *dev,\r\nu32 offset, u32 val)\r\n{\r\nwritel_relaxed(val, dev->wr_base + offset);\r\n}\r\nstatic inline void pmic_arb_set_rd_cmd(struct spmi_pmic_arb_dev *dev,\r\nu32 offset, u32 val)\r\n{\r\nwritel_relaxed(val, dev->rd_base + offset);\r\n}\r\nstatic void pa_read_data(struct spmi_pmic_arb_dev *dev, u8 *buf, u32 reg, u8 bc)\r\n{\r\nu32 data = __raw_readl(dev->rd_base + reg);\r\nmemcpy(buf, &data, (bc & 3) + 1);\r\n}\r\nstatic void\r\npa_write_data(struct spmi_pmic_arb_dev *dev, const u8 *buf, u32 reg, u8 bc)\r\n{\r\nu32 data = 0;\r\nmemcpy(&data, buf, (bc & 3) + 1);\r\n__raw_writel(data, dev->wr_base + reg);\r\n}\r\nstatic int pmic_arb_wait_for_done(struct spmi_controller *ctrl,\r\nvoid __iomem *base, u8 sid, u16 addr)\r\n{\r\nstruct spmi_pmic_arb_dev *dev = spmi_controller_get_drvdata(ctrl);\r\nu32 status = 0;\r\nu32 timeout = PMIC_ARB_TIMEOUT_US;\r\nu32 offset;\r\nint rc;\r\nrc = dev->ver_ops->offset(dev, sid, addr, &offset);\r\nif (rc)\r\nreturn rc;\r\noffset += PMIC_ARB_STATUS;\r\nwhile (timeout--) {\r\nstatus = readl_relaxed(base + offset);\r\nif (status & PMIC_ARB_STATUS_DONE) {\r\nif (status & PMIC_ARB_STATUS_DENIED) {\r\ndev_err(&ctrl->dev,\r\n"%s: transaction denied (0x%x)\n",\r\n__func__, status);\r\nreturn -EPERM;\r\n}\r\nif (status & PMIC_ARB_STATUS_FAILURE) {\r\ndev_err(&ctrl->dev,\r\n"%s: transaction failed (0x%x)\n",\r\n__func__, status);\r\nreturn -EIO;\r\n}\r\nif (status & PMIC_ARB_STATUS_DROPPED) {\r\ndev_err(&ctrl->dev,\r\n"%s: transaction dropped (0x%x)\n",\r\n__func__, status);\r\nreturn -EIO;\r\n}\r\nreturn 0;\r\n}\r\nudelay(1);\r\n}\r\ndev_err(&ctrl->dev,\r\n"%s: timeout, status 0x%x\n",\r\n__func__, status);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int\r\npmic_arb_non_data_cmd_v1(struct spmi_controller *ctrl, u8 opc, u8 sid)\r\n{\r\nstruct spmi_pmic_arb_dev *pmic_arb = spmi_controller_get_drvdata(ctrl);\r\nunsigned long flags;\r\nu32 cmd;\r\nint rc;\r\nu32 offset;\r\nrc = pmic_arb->ver_ops->offset(pmic_arb, sid, 0, &offset);\r\nif (rc)\r\nreturn rc;\r\ncmd = ((opc | 0x40) << 27) | ((sid & 0xf) << 20);\r\nraw_spin_lock_irqsave(&pmic_arb->lock, flags);\r\npmic_arb_base_write(pmic_arb, offset + PMIC_ARB_CMD, cmd);\r\nrc = pmic_arb_wait_for_done(ctrl, pmic_arb->wr_base, sid, 0);\r\nraw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int\r\npmic_arb_non_data_cmd_v2(struct spmi_controller *ctrl, u8 opc, u8 sid)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic int pmic_arb_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid)\r\n{\r\nstruct spmi_pmic_arb_dev *pmic_arb = spmi_controller_get_drvdata(ctrl);\r\ndev_dbg(&ctrl->dev, "cmd op:0x%x sid:%d\n", opc, sid);\r\nif (opc < SPMI_CMD_RESET || opc > SPMI_CMD_WAKEUP)\r\nreturn -EINVAL;\r\nreturn pmic_arb->ver_ops->non_data_cmd(ctrl, opc, sid);\r\n}\r\nstatic int pmic_arb_read_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,\r\nu16 addr, u8 *buf, size_t len)\r\n{\r\nstruct spmi_pmic_arb_dev *pmic_arb = spmi_controller_get_drvdata(ctrl);\r\nunsigned long flags;\r\nu8 bc = len - 1;\r\nu32 cmd;\r\nint rc;\r\nu32 offset;\r\nrc = pmic_arb->ver_ops->offset(pmic_arb, sid, addr, &offset);\r\nif (rc)\r\nreturn rc;\r\nif (bc >= PMIC_ARB_MAX_TRANS_BYTES) {\r\ndev_err(&ctrl->dev,\r\n"pmic-arb supports 1..%d bytes per trans, but:%zu requested",\r\nPMIC_ARB_MAX_TRANS_BYTES, len);\r\nreturn -EINVAL;\r\n}\r\nif (opc >= 0x60 && opc <= 0x7F)\r\nopc = PMIC_ARB_OP_READ;\r\nelse if (opc >= 0x20 && opc <= 0x2F)\r\nopc = PMIC_ARB_OP_EXT_READ;\r\nelse if (opc >= 0x38 && opc <= 0x3F)\r\nopc = PMIC_ARB_OP_EXT_READL;\r\nelse\r\nreturn -EINVAL;\r\ncmd = pmic_arb->ver_ops->fmt_cmd(opc, sid, addr, bc);\r\nraw_spin_lock_irqsave(&pmic_arb->lock, flags);\r\npmic_arb_set_rd_cmd(pmic_arb, offset + PMIC_ARB_CMD, cmd);\r\nrc = pmic_arb_wait_for_done(ctrl, pmic_arb->rd_base, sid, addr);\r\nif (rc)\r\ngoto done;\r\npa_read_data(pmic_arb, buf, offset + PMIC_ARB_RDATA0,\r\nmin_t(u8, bc, 3));\r\nif (bc > 3)\r\npa_read_data(pmic_arb, buf + 4,\r\noffset + PMIC_ARB_RDATA1, bc - 4);\r\ndone:\r\nraw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\r\nreturn rc;\r\n}\r\nstatic int pmic_arb_write_cmd(struct spmi_controller *ctrl, u8 opc, u8 sid,\r\nu16 addr, const u8 *buf, size_t len)\r\n{\r\nstruct spmi_pmic_arb_dev *pmic_arb = spmi_controller_get_drvdata(ctrl);\r\nunsigned long flags;\r\nu8 bc = len - 1;\r\nu32 cmd;\r\nint rc;\r\nu32 offset;\r\nrc = pmic_arb->ver_ops->offset(pmic_arb, sid, addr, &offset);\r\nif (rc)\r\nreturn rc;\r\nif (bc >= PMIC_ARB_MAX_TRANS_BYTES) {\r\ndev_err(&ctrl->dev,\r\n"pmic-arb supports 1..%d bytes per trans, but:%zu requested",\r\nPMIC_ARB_MAX_TRANS_BYTES, len);\r\nreturn -EINVAL;\r\n}\r\nif (opc >= 0x40 && opc <= 0x5F)\r\nopc = PMIC_ARB_OP_WRITE;\r\nelse if (opc >= 0x00 && opc <= 0x0F)\r\nopc = PMIC_ARB_OP_EXT_WRITE;\r\nelse if (opc >= 0x30 && opc <= 0x37)\r\nopc = PMIC_ARB_OP_EXT_WRITEL;\r\nelse if (opc >= 0x80)\r\nopc = PMIC_ARB_OP_ZERO_WRITE;\r\nelse\r\nreturn -EINVAL;\r\ncmd = pmic_arb->ver_ops->fmt_cmd(opc, sid, addr, bc);\r\nraw_spin_lock_irqsave(&pmic_arb->lock, flags);\r\npa_write_data(pmic_arb, buf, offset + PMIC_ARB_WDATA0,\r\nmin_t(u8, bc, 3));\r\nif (bc > 3)\r\npa_write_data(pmic_arb, buf + 4,\r\noffset + PMIC_ARB_WDATA1, bc - 4);\r\npmic_arb_base_write(pmic_arb, offset + PMIC_ARB_CMD, cmd);\r\nrc = pmic_arb_wait_for_done(ctrl, pmic_arb->wr_base, sid, addr);\r\nraw_spin_unlock_irqrestore(&pmic_arb->lock, flags);\r\nreturn rc;\r\n}\r\nstatic void qpnpint_spmi_write(struct irq_data *d, u8 reg, void *buf,\r\nsize_t len)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = irq_data_get_irq_chip_data(d);\r\nu8 sid = d->hwirq >> 24;\r\nu8 per = d->hwirq >> 16;\r\nif (pmic_arb_write_cmd(pa->spmic, SPMI_CMD_EXT_WRITEL, sid,\r\n(per << 8) + reg, buf, len))\r\ndev_err_ratelimited(&pa->spmic->dev,\r\n"failed irqchip transaction on %x\n",\r\nd->irq);\r\n}\r\nstatic void qpnpint_spmi_read(struct irq_data *d, u8 reg, void *buf, size_t len)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = irq_data_get_irq_chip_data(d);\r\nu8 sid = d->hwirq >> 24;\r\nu8 per = d->hwirq >> 16;\r\nif (pmic_arb_read_cmd(pa->spmic, SPMI_CMD_EXT_READL, sid,\r\n(per << 8) + reg, buf, len))\r\ndev_err_ratelimited(&pa->spmic->dev,\r\n"failed irqchip transaction on %x\n",\r\nd->irq);\r\n}\r\nstatic void periph_interrupt(struct spmi_pmic_arb_dev *pa, u8 apid)\r\n{\r\nunsigned int irq;\r\nu32 status;\r\nint id;\r\nstatus = readl_relaxed(pa->intr + pa->ver_ops->irq_status(apid));\r\nwhile (status) {\r\nid = ffs(status) - 1;\r\nstatus &= ~(1 << id);\r\nirq = irq_find_mapping(pa->domain,\r\npa->apid_to_ppid[apid] << 16\r\n| id << 8\r\n| apid);\r\ngeneric_handle_irq(irq);\r\n}\r\n}\r\nstatic void pmic_arb_chained_irq(struct irq_desc *desc)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nvoid __iomem *intr = pa->intr;\r\nint first = pa->min_apid >> 5;\r\nint last = pa->max_apid >> 5;\r\nu32 status;\r\nint i, id;\r\nchained_irq_enter(chip, desc);\r\nfor (i = first; i <= last; ++i) {\r\nstatus = readl_relaxed(intr +\r\npa->ver_ops->owner_acc_status(pa->ee, i));\r\nwhile (status) {\r\nid = ffs(status) - 1;\r\nstatus &= ~(1 << id);\r\nperiph_interrupt(pa, id + i * 32);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void qpnpint_irq_ack(struct irq_data *d)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = irq_data_get_irq_chip_data(d);\r\nu8 irq = d->hwirq >> 8;\r\nu8 apid = d->hwirq;\r\nunsigned long flags;\r\nu8 data;\r\nraw_spin_lock_irqsave(&pa->lock, flags);\r\nwritel_relaxed(1 << irq, pa->intr + pa->ver_ops->irq_clear(apid));\r\nraw_spin_unlock_irqrestore(&pa->lock, flags);\r\ndata = 1 << irq;\r\nqpnpint_spmi_write(d, QPNPINT_REG_LATCHED_CLR, &data, 1);\r\n}\r\nstatic void qpnpint_irq_mask(struct irq_data *d)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = irq_data_get_irq_chip_data(d);\r\nu8 irq = d->hwirq >> 8;\r\nu8 apid = d->hwirq;\r\nunsigned long flags;\r\nu32 status;\r\nu8 data;\r\nraw_spin_lock_irqsave(&pa->lock, flags);\r\nstatus = readl_relaxed(pa->intr + pa->ver_ops->acc_enable(apid));\r\nif (status & SPMI_PIC_ACC_ENABLE_BIT) {\r\nstatus = status & ~SPMI_PIC_ACC_ENABLE_BIT;\r\nwritel_relaxed(status, pa->intr +\r\npa->ver_ops->acc_enable(apid));\r\n}\r\nraw_spin_unlock_irqrestore(&pa->lock, flags);\r\ndata = 1 << irq;\r\nqpnpint_spmi_write(d, QPNPINT_REG_EN_CLR, &data, 1);\r\n}\r\nstatic void qpnpint_irq_unmask(struct irq_data *d)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = irq_data_get_irq_chip_data(d);\r\nu8 irq = d->hwirq >> 8;\r\nu8 apid = d->hwirq;\r\nunsigned long flags;\r\nu32 status;\r\nu8 data;\r\nraw_spin_lock_irqsave(&pa->lock, flags);\r\nstatus = readl_relaxed(pa->intr + pa->ver_ops->acc_enable(apid));\r\nif (!(status & SPMI_PIC_ACC_ENABLE_BIT)) {\r\nwritel_relaxed(status | SPMI_PIC_ACC_ENABLE_BIT,\r\npa->intr + pa->ver_ops->acc_enable(apid));\r\n}\r\nraw_spin_unlock_irqrestore(&pa->lock, flags);\r\ndata = 1 << irq;\r\nqpnpint_spmi_write(d, QPNPINT_REG_EN_SET, &data, 1);\r\n}\r\nstatic void qpnpint_irq_enable(struct irq_data *d)\r\n{\r\nu8 irq = d->hwirq >> 8;\r\nu8 data;\r\nqpnpint_irq_unmask(d);\r\ndata = 1 << irq;\r\nqpnpint_spmi_write(d, QPNPINT_REG_LATCHED_CLR, &data, 1);\r\n}\r\nstatic int qpnpint_irq_set_type(struct irq_data *d, unsigned int flow_type)\r\n{\r\nstruct spmi_pmic_arb_qpnpint_type type;\r\nu8 irq = d->hwirq >> 8;\r\nqpnpint_spmi_read(d, QPNPINT_REG_SET_TYPE, &type, sizeof(type));\r\nif (flow_type & (IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING)) {\r\ntype.type |= 1 << irq;\r\nif (flow_type & IRQF_TRIGGER_RISING)\r\ntype.polarity_high |= 1 << irq;\r\nif (flow_type & IRQF_TRIGGER_FALLING)\r\ntype.polarity_low |= 1 << irq;\r\n} else {\r\nif ((flow_type & (IRQF_TRIGGER_HIGH)) &&\r\n(flow_type & (IRQF_TRIGGER_LOW)))\r\nreturn -EINVAL;\r\ntype.type &= ~(1 << irq);\r\nif (flow_type & IRQF_TRIGGER_HIGH)\r\ntype.polarity_high |= 1 << irq;\r\nelse\r\ntype.polarity_low |= 1 << irq;\r\n}\r\nqpnpint_spmi_write(d, QPNPINT_REG_SET_TYPE, &type, sizeof(type));\r\nreturn 0;\r\n}\r\nstatic int qpnpint_get_irqchip_state(struct irq_data *d,\r\nenum irqchip_irq_state which,\r\nbool *state)\r\n{\r\nu8 irq = d->hwirq >> 8;\r\nu8 status = 0;\r\nif (which != IRQCHIP_STATE_LINE_LEVEL)\r\nreturn -EINVAL;\r\nqpnpint_spmi_read(d, QPNPINT_REG_RT_STS, &status, 1);\r\n*state = !!(status & BIT(irq));\r\nreturn 0;\r\n}\r\nstatic int search_mapping_table(struct spmi_pmic_arb_dev *pa,\r\nstruct spmi_pmic_arb_irq_spec *spec,\r\nu8 *apid)\r\n{\r\nu16 ppid = spec->slave << 8 | spec->per;\r\nu32 *mapping_table = pa->mapping_table;\r\nint index = 0, i;\r\nu32 data;\r\nfor (i = 0; i < SPMI_MAPPING_TABLE_TREE_DEPTH; ++i) {\r\nif (!test_and_set_bit(index, pa->mapping_table_valid))\r\nmapping_table[index] = readl_relaxed(pa->cnfg +\r\nSPMI_MAPPING_TABLE_REG(index));\r\ndata = mapping_table[index];\r\nif (ppid & (1 << SPMI_MAPPING_BIT_INDEX(data))) {\r\nif (SPMI_MAPPING_BIT_IS_1_FLAG(data)) {\r\nindex = SPMI_MAPPING_BIT_IS_1_RESULT(data);\r\n} else {\r\n*apid = SPMI_MAPPING_BIT_IS_1_RESULT(data);\r\nreturn 0;\r\n}\r\n} else {\r\nif (SPMI_MAPPING_BIT_IS_0_FLAG(data)) {\r\nindex = SPMI_MAPPING_BIT_IS_0_RESULT(data);\r\n} else {\r\n*apid = SPMI_MAPPING_BIT_IS_0_RESULT(data);\r\nreturn 0;\r\n}\r\n}\r\n}\r\nreturn -ENODEV;\r\n}\r\nstatic int qpnpint_irq_domain_dt_translate(struct irq_domain *d,\r\nstruct device_node *controller,\r\nconst u32 *intspec,\r\nunsigned int intsize,\r\nunsigned long *out_hwirq,\r\nunsigned int *out_type)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = d->host_data;\r\nstruct spmi_pmic_arb_irq_spec spec;\r\nint err;\r\nu8 apid;\r\ndev_dbg(&pa->spmic->dev,\r\n"intspec[0] 0x%1x intspec[1] 0x%02x intspec[2] 0x%02x\n",\r\nintspec[0], intspec[1], intspec[2]);\r\nif (irq_domain_get_of_node(d) != controller)\r\nreturn -EINVAL;\r\nif (intsize != 4)\r\nreturn -EINVAL;\r\nif (intspec[0] > 0xF || intspec[1] > 0xFF || intspec[2] > 0x7)\r\nreturn -EINVAL;\r\nspec.slave = intspec[0];\r\nspec.per = intspec[1];\r\nspec.irq = intspec[2];\r\nerr = search_mapping_table(pa, &spec, &apid);\r\nif (err)\r\nreturn err;\r\npa->apid_to_ppid[apid] = spec.slave << 8 | spec.per;\r\nif (apid > pa->max_apid)\r\npa->max_apid = apid;\r\nif (apid < pa->min_apid)\r\npa->min_apid = apid;\r\n*out_hwirq = spec.slave << 24\r\n| spec.per << 16\r\n| spec.irq << 8\r\n| apid;\r\n*out_type = intspec[3] & IRQ_TYPE_SENSE_MASK;\r\ndev_dbg(&pa->spmic->dev, "out_hwirq = %lu\n", *out_hwirq);\r\nreturn 0;\r\n}\r\nstatic int qpnpint_irq_domain_map(struct irq_domain *d,\r\nunsigned int virq,\r\nirq_hw_number_t hwirq)\r\n{\r\nstruct spmi_pmic_arb_dev *pa = d->host_data;\r\ndev_dbg(&pa->spmic->dev, "virq = %u, hwirq = %lu\n", virq, hwirq);\r\nirq_set_chip_and_handler(virq, &pmic_arb_irqchip, handle_level_irq);\r\nirq_set_chip_data(virq, d->host_data);\r\nirq_set_noprobe(virq);\r\nreturn 0;\r\n}\r\nstatic int\r\npmic_arb_offset_v1(struct spmi_pmic_arb_dev *pa, u8 sid, u16 addr, u32 *offset)\r\n{\r\n*offset = 0x800 + 0x80 * pa->channel;\r\nreturn 0;\r\n}\r\nstatic u16 pmic_arb_find_chan(struct spmi_pmic_arb_dev *pa, u16 ppid)\r\n{\r\nu32 regval, offset;\r\nu16 chan;\r\nu16 id;\r\nfor (chan = pa->last_channel; ; chan++) {\r\noffset = PMIC_ARB_REG_CHNL(chan);\r\nif (offset >= pa->core_size)\r\nbreak;\r\nregval = readl_relaxed(pa->core + offset);\r\nif (!regval)\r\ncontinue;\r\nid = (regval >> 8) & PMIC_ARB_PPID_MASK;\r\npa->ppid_to_chan[id] = chan | PMIC_ARB_CHAN_VALID;\r\nif (id == ppid) {\r\nchan |= PMIC_ARB_CHAN_VALID;\r\nbreak;\r\n}\r\n}\r\npa->last_channel = chan & ~PMIC_ARB_CHAN_VALID;\r\nreturn chan;\r\n}\r\nstatic int\r\npmic_arb_offset_v2(struct spmi_pmic_arb_dev *pa, u8 sid, u16 addr, u32 *offset)\r\n{\r\nu16 ppid = (sid << 8) | (addr >> 8);\r\nu16 chan;\r\nchan = pa->ppid_to_chan[ppid];\r\nif (!(chan & PMIC_ARB_CHAN_VALID))\r\nchan = pmic_arb_find_chan(pa, ppid);\r\nif (!(chan & PMIC_ARB_CHAN_VALID))\r\nreturn -ENODEV;\r\nchan &= ~PMIC_ARB_CHAN_VALID;\r\n*offset = 0x1000 * pa->ee + 0x8000 * chan;\r\nreturn 0;\r\n}\r\nstatic u32 pmic_arb_fmt_cmd_v1(u8 opc, u8 sid, u16 addr, u8 bc)\r\n{\r\nreturn (opc << 27) | ((sid & 0xf) << 20) | (addr << 4) | (bc & 0x7);\r\n}\r\nstatic u32 pmic_arb_fmt_cmd_v2(u8 opc, u8 sid, u16 addr, u8 bc)\r\n{\r\nreturn (opc << 27) | ((addr & 0xff) << 4) | (bc & 0x7);\r\n}\r\nstatic u32 pmic_arb_owner_acc_status_v1(u8 m, u8 n)\r\n{\r\nreturn 0x20 * m + 0x4 * n;\r\n}\r\nstatic u32 pmic_arb_owner_acc_status_v2(u8 m, u8 n)\r\n{\r\nreturn 0x100000 + 0x1000 * m + 0x4 * n;\r\n}\r\nstatic u32 pmic_arb_acc_enable_v1(u8 n)\r\n{\r\nreturn 0x200 + 0x4 * n;\r\n}\r\nstatic u32 pmic_arb_acc_enable_v2(u8 n)\r\n{\r\nreturn 0x1000 * n;\r\n}\r\nstatic u32 pmic_arb_irq_status_v1(u8 n)\r\n{\r\nreturn 0x600 + 0x4 * n;\r\n}\r\nstatic u32 pmic_arb_irq_status_v2(u8 n)\r\n{\r\nreturn 0x4 + 0x1000 * n;\r\n}\r\nstatic u32 pmic_arb_irq_clear_v1(u8 n)\r\n{\r\nreturn 0xA00 + 0x4 * n;\r\n}\r\nstatic u32 pmic_arb_irq_clear_v2(u8 n)\r\n{\r\nreturn 0x8 + 0x1000 * n;\r\n}\r\nstatic int spmi_pmic_arb_probe(struct platform_device *pdev)\r\n{\r\nstruct spmi_pmic_arb_dev *pa;\r\nstruct spmi_controller *ctrl;\r\nstruct resource *res;\r\nvoid __iomem *core;\r\nu32 channel, ee, hw_ver;\r\nint err;\r\nbool is_v1;\r\nctrl = spmi_controller_alloc(&pdev->dev, sizeof(*pa));\r\nif (!ctrl)\r\nreturn -ENOMEM;\r\npa = spmi_controller_get_drvdata(ctrl);\r\npa->spmic = ctrl;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "core");\r\npa->core_size = resource_size(res);\r\ncore = devm_ioremap_resource(&ctrl->dev, res);\r\nif (IS_ERR(core)) {\r\nerr = PTR_ERR(core);\r\ngoto err_put_ctrl;\r\n}\r\nhw_ver = readl_relaxed(core + PMIC_ARB_VERSION);\r\nis_v1 = (hw_ver < PMIC_ARB_VERSION_V2_MIN);\r\ndev_info(&ctrl->dev, "PMIC Arb Version-%d (0x%x)\n", (is_v1 ? 1 : 2),\r\nhw_ver);\r\nif (is_v1) {\r\npa->ver_ops = &pmic_arb_v1;\r\npa->wr_base = core;\r\npa->rd_base = core;\r\n} else {\r\npa->core = core;\r\npa->ver_ops = &pmic_arb_v2;\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"obsrvr");\r\npa->rd_base = devm_ioremap_resource(&ctrl->dev, res);\r\nif (IS_ERR(pa->rd_base)) {\r\nerr = PTR_ERR(pa->rd_base);\r\ngoto err_put_ctrl;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\r\n"chnls");\r\npa->wr_base = devm_ioremap_resource(&ctrl->dev, res);\r\nif (IS_ERR(pa->wr_base)) {\r\nerr = PTR_ERR(pa->wr_base);\r\ngoto err_put_ctrl;\r\n}\r\npa->ppid_to_chan = devm_kcalloc(&ctrl->dev,\r\nPMIC_ARB_MAX_PPID,\r\nsizeof(*pa->ppid_to_chan),\r\nGFP_KERNEL);\r\nif (!pa->ppid_to_chan) {\r\nerr = -ENOMEM;\r\ngoto err_put_ctrl;\r\n}\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "intr");\r\npa->intr = devm_ioremap_resource(&ctrl->dev, res);\r\nif (IS_ERR(pa->intr)) {\r\nerr = PTR_ERR(pa->intr);\r\ngoto err_put_ctrl;\r\n}\r\nres = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cnfg");\r\npa->cnfg = devm_ioremap_resource(&ctrl->dev, res);\r\nif (IS_ERR(pa->cnfg)) {\r\nerr = PTR_ERR(pa->cnfg);\r\ngoto err_put_ctrl;\r\n}\r\npa->irq = platform_get_irq_byname(pdev, "periph_irq");\r\nif (pa->irq < 0) {\r\nerr = pa->irq;\r\ngoto err_put_ctrl;\r\n}\r\nerr = of_property_read_u32(pdev->dev.of_node, "qcom,channel", &channel);\r\nif (err) {\r\ndev_err(&pdev->dev, "channel unspecified.\n");\r\ngoto err_put_ctrl;\r\n}\r\nif (channel > 5) {\r\ndev_err(&pdev->dev, "invalid channel (%u) specified.\n",\r\nchannel);\r\nerr = -EINVAL;\r\ngoto err_put_ctrl;\r\n}\r\npa->channel = channel;\r\nerr = of_property_read_u32(pdev->dev.of_node, "qcom,ee", &ee);\r\nif (err) {\r\ndev_err(&pdev->dev, "EE unspecified.\n");\r\ngoto err_put_ctrl;\r\n}\r\nif (ee > 5) {\r\ndev_err(&pdev->dev, "invalid EE (%u) specified\n", ee);\r\nerr = -EINVAL;\r\ngoto err_put_ctrl;\r\n}\r\npa->ee = ee;\r\npa->apid_to_ppid = devm_kcalloc(&ctrl->dev, PMIC_ARB_MAX_PERIPHS,\r\nsizeof(*pa->apid_to_ppid),\r\nGFP_KERNEL);\r\nif (!pa->apid_to_ppid) {\r\nerr = -ENOMEM;\r\ngoto err_put_ctrl;\r\n}\r\npa->mapping_table = devm_kcalloc(&ctrl->dev, PMIC_ARB_MAX_PERIPHS - 1,\r\nsizeof(*pa->mapping_table), GFP_KERNEL);\r\nif (!pa->mapping_table) {\r\nerr = -ENOMEM;\r\ngoto err_put_ctrl;\r\n}\r\npa->max_apid = 0;\r\npa->min_apid = PMIC_ARB_MAX_PERIPHS - 1;\r\nplatform_set_drvdata(pdev, ctrl);\r\nraw_spin_lock_init(&pa->lock);\r\nctrl->cmd = pmic_arb_cmd;\r\nctrl->read_cmd = pmic_arb_read_cmd;\r\nctrl->write_cmd = pmic_arb_write_cmd;\r\ndev_dbg(&pdev->dev, "adding irq domain\n");\r\npa->domain = irq_domain_add_tree(pdev->dev.of_node,\r\n&pmic_arb_irq_domain_ops, pa);\r\nif (!pa->domain) {\r\ndev_err(&pdev->dev, "unable to create irq_domain\n");\r\nerr = -ENOMEM;\r\ngoto err_put_ctrl;\r\n}\r\nirq_set_chained_handler_and_data(pa->irq, pmic_arb_chained_irq, pa);\r\nerr = spmi_controller_add(ctrl);\r\nif (err)\r\ngoto err_domain_remove;\r\nreturn 0;\r\nerr_domain_remove:\r\nirq_set_chained_handler_and_data(pa->irq, NULL, NULL);\r\nirq_domain_remove(pa->domain);\r\nerr_put_ctrl:\r\nspmi_controller_put(ctrl);\r\nreturn err;\r\n}\r\nstatic int spmi_pmic_arb_remove(struct platform_device *pdev)\r\n{\r\nstruct spmi_controller *ctrl = platform_get_drvdata(pdev);\r\nstruct spmi_pmic_arb_dev *pa = spmi_controller_get_drvdata(ctrl);\r\nspmi_controller_remove(ctrl);\r\nirq_set_chained_handler_and_data(pa->irq, NULL, NULL);\r\nirq_domain_remove(pa->domain);\r\nspmi_controller_put(ctrl);\r\nreturn 0;\r\n}
