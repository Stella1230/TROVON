int ip_vs_bind_scheduler(struct ip_vs_service *svc,\r\nstruct ip_vs_scheduler *scheduler)\r\n{\r\nint ret;\r\nif (scheduler->init_service) {\r\nret = scheduler->init_service(svc);\r\nif (ret) {\r\npr_err("%s(): init error\n", __func__);\r\nreturn ret;\r\n}\r\n}\r\nrcu_assign_pointer(svc->scheduler, scheduler);\r\nreturn 0;\r\n}\r\nvoid ip_vs_unbind_scheduler(struct ip_vs_service *svc,\r\nstruct ip_vs_scheduler *sched)\r\n{\r\nstruct ip_vs_scheduler *cur_sched;\r\ncur_sched = rcu_dereference_protected(svc->scheduler, 1);\r\nif (!cur_sched)\r\nreturn;\r\nif (sched->done_service)\r\nsched->done_service(svc);\r\n}\r\nstatic struct ip_vs_scheduler *ip_vs_sched_getbyname(const char *sched_name)\r\n{\r\nstruct ip_vs_scheduler *sched;\r\nIP_VS_DBG(2, "%s(): sched_name \"%s\"\n", __func__, sched_name);\r\nmutex_lock(&ip_vs_sched_mutex);\r\nlist_for_each_entry(sched, &ip_vs_schedulers, n_list) {\r\nif (sched->module && !try_module_get(sched->module)) {\r\ncontinue;\r\n}\r\nif (strcmp(sched_name, sched->name)==0) {\r\nmutex_unlock(&ip_vs_sched_mutex);\r\nreturn sched;\r\n}\r\nmodule_put(sched->module);\r\n}\r\nmutex_unlock(&ip_vs_sched_mutex);\r\nreturn NULL;\r\n}\r\nstruct ip_vs_scheduler *ip_vs_scheduler_get(const char *sched_name)\r\n{\r\nstruct ip_vs_scheduler *sched;\r\nsched = ip_vs_sched_getbyname(sched_name);\r\nif (sched == NULL) {\r\nrequest_module("ip_vs_%s", sched_name);\r\nsched = ip_vs_sched_getbyname(sched_name);\r\n}\r\nreturn sched;\r\n}\r\nvoid ip_vs_scheduler_put(struct ip_vs_scheduler *scheduler)\r\n{\r\nif (scheduler)\r\nmodule_put(scheduler->module);\r\n}\r\nvoid ip_vs_scheduler_err(struct ip_vs_service *svc, const char *msg)\r\n{\r\nstruct ip_vs_scheduler *sched = rcu_dereference(svc->scheduler);\r\nchar *sched_name = sched ? sched->name : "none";\r\nif (svc->fwmark) {\r\nIP_VS_ERR_RL("%s: FWM %u 0x%08X - %s\n",\r\nsched_name, svc->fwmark, svc->fwmark, msg);\r\n#ifdef CONFIG_IP_VS_IPV6\r\n} else if (svc->af == AF_INET6) {\r\nIP_VS_ERR_RL("%s: %s [%pI6c]:%d - %s\n",\r\nsched_name, ip_vs_proto_name(svc->protocol),\r\n&svc->addr.in6, ntohs(svc->port), msg);\r\n#endif\r\n} else {\r\nIP_VS_ERR_RL("%s: %s %pI4:%d - %s\n",\r\nsched_name, ip_vs_proto_name(svc->protocol),\r\n&svc->addr.ip, ntohs(svc->port), msg);\r\n}\r\n}\r\nint register_ip_vs_scheduler(struct ip_vs_scheduler *scheduler)\r\n{\r\nstruct ip_vs_scheduler *sched;\r\nif (!scheduler) {\r\npr_err("%s(): NULL arg\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nif (!scheduler->name) {\r\npr_err("%s(): NULL scheduler_name\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nip_vs_use_count_inc();\r\nmutex_lock(&ip_vs_sched_mutex);\r\nif (!list_empty(&scheduler->n_list)) {\r\nmutex_unlock(&ip_vs_sched_mutex);\r\nip_vs_use_count_dec();\r\npr_err("%s(): [%s] scheduler already linked\n",\r\n__func__, scheduler->name);\r\nreturn -EINVAL;\r\n}\r\nlist_for_each_entry(sched, &ip_vs_schedulers, n_list) {\r\nif (strcmp(scheduler->name, sched->name) == 0) {\r\nmutex_unlock(&ip_vs_sched_mutex);\r\nip_vs_use_count_dec();\r\npr_err("%s(): [%s] scheduler already existed "\r\n"in the system\n", __func__, scheduler->name);\r\nreturn -EINVAL;\r\n}\r\n}\r\nlist_add(&scheduler->n_list, &ip_vs_schedulers);\r\nmutex_unlock(&ip_vs_sched_mutex);\r\npr_info("[%s] scheduler registered.\n", scheduler->name);\r\nreturn 0;\r\n}\r\nint unregister_ip_vs_scheduler(struct ip_vs_scheduler *scheduler)\r\n{\r\nif (!scheduler) {\r\npr_err("%s(): NULL arg\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&ip_vs_sched_mutex);\r\nif (list_empty(&scheduler->n_list)) {\r\nmutex_unlock(&ip_vs_sched_mutex);\r\npr_err("%s(): [%s] scheduler is not in the list. failed\n",\r\n__func__, scheduler->name);\r\nreturn -EINVAL;\r\n}\r\nlist_del(&scheduler->n_list);\r\nmutex_unlock(&ip_vs_sched_mutex);\r\nip_vs_use_count_dec();\r\npr_info("[%s] scheduler unregistered.\n", scheduler->name);\r\nreturn 0;\r\n}
