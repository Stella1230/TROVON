static inline int\r\ndasd_hash_busid(const char *bus_id)\r\n{\r\nint hash, i;\r\nhash = 0;\r\nfor (i = 0; (i < DASD_BUS_ID_SIZE) && *bus_id; i++, bus_id++)\r\nhash += *bus_id;\r\nreturn hash & 0xff;\r\n}\r\nstatic int __init dasd_call_setup(char *opt)\r\n{\r\nstatic int i __initdata;\r\nchar *tmp;\r\nwhile (i < DASD_MAX_PARAMS) {\r\ntmp = strsep(&opt, ",");\r\nif (!tmp)\r\nbreak;\r\ndasd[i++] = tmp;\r\n}\r\nreturn 1;\r\n}\r\nstatic int __init dasd_busid(char *str, int *id0, int *id1, int *devno)\r\n{\r\nunsigned int val;\r\nchar *tok;\r\nif (strncmp(DASD_IPLDEV, str, strlen(DASD_IPLDEV)) == 0) {\r\nif (ipl_info.type != IPL_TYPE_CCW) {\r\npr_err("The IPL device is not a CCW device\n");\r\nreturn -EINVAL;\r\n}\r\n*id0 = 0;\r\n*id1 = ipl_info.data.ccw.dev_id.ssid;\r\n*devno = ipl_info.data.ccw.dev_id.devno;\r\nreturn 0;\r\n}\r\nif (!kstrtouint(str, 16, &val)) {\r\n*id0 = *id1 = 0;\r\nif (val < 0 || val > 0xffff)\r\nreturn -EINVAL;\r\n*devno = val;\r\nreturn 0;\r\n}\r\ntok = strsep(&str, ".");\r\nif (kstrtouint(tok, 16, &val) || val > 0xff)\r\nreturn -EINVAL;\r\n*id0 = val;\r\ntok = strsep(&str, ".");\r\nif (kstrtouint(tok, 16, &val) || val > 0xff)\r\nreturn -EINVAL;\r\n*id1 = val;\r\ntok = strsep(&str, ".");\r\nif (kstrtouint(tok, 16, &val) || val > 0xffff)\r\nreturn -EINVAL;\r\n*devno = val;\r\nreturn 0;\r\n}\r\nstatic int __init dasd_feature_list(char *str)\r\n{\r\nint features, len, rc;\r\nfeatures = 0;\r\nrc = 0;\r\nif (!str)\r\nreturn DASD_FEATURE_DEFAULT;\r\nwhile (1) {\r\nfor (len = 0;\r\nstr[len] && str[len] != ':' && str[len] != ')'; len++);\r\nif (len == 2 && !strncmp(str, "ro", 2))\r\nfeatures |= DASD_FEATURE_READONLY;\r\nelse if (len == 4 && !strncmp(str, "diag", 4))\r\nfeatures |= DASD_FEATURE_USEDIAG;\r\nelse if (len == 3 && !strncmp(str, "raw", 3))\r\nfeatures |= DASD_FEATURE_USERAW;\r\nelse if (len == 6 && !strncmp(str, "erplog", 6))\r\nfeatures |= DASD_FEATURE_ERPLOG;\r\nelse if (len == 8 && !strncmp(str, "failfast", 8))\r\nfeatures |= DASD_FEATURE_FAILFAST;\r\nelse {\r\npr_warn("%*s is not a supported device option\n",\r\nlen, str);\r\nrc = -EINVAL;\r\n}\r\nstr += len;\r\nif (*str != ':')\r\nbreak;\r\nstr++;\r\n}\r\nreturn rc ? : features;\r\n}\r\nstatic int __init dasd_parse_keyword(char *keyword)\r\n{\r\nint length = strlen(keyword);\r\nif (strncmp("autodetect", keyword, length) == 0) {\r\ndasd_autodetect = 1;\r\npr_info("The autodetection mode has been activated\n");\r\nreturn 0;\r\n}\r\nif (strncmp("probeonly", keyword, length) == 0) {\r\ndasd_probeonly = 1;\r\npr_info("The probeonly mode has been activated\n");\r\nreturn 0;\r\n}\r\nif (strncmp("nopav", keyword, length) == 0) {\r\nif (MACHINE_IS_VM)\r\npr_info("'nopav' is not supported on z/VM\n");\r\nelse {\r\ndasd_nopav = 1;\r\npr_info("PAV support has be deactivated\n");\r\n}\r\nreturn 0;\r\n}\r\nif (strncmp("nofcx", keyword, length) == 0) {\r\ndasd_nofcx = 1;\r\npr_info("High Performance FICON support has been "\r\n"deactivated\n");\r\nreturn 0;\r\n}\r\nif (strncmp("fixedbuffers", keyword, length) == 0) {\r\nif (dasd_page_cache)\r\nreturn 0;\r\ndasd_page_cache =\r\nkmem_cache_create("dasd_page_cache", PAGE_SIZE,\r\nPAGE_SIZE, SLAB_CACHE_DMA,\r\nNULL);\r\nif (!dasd_page_cache)\r\nDBF_EVENT(DBF_WARNING, "%s", "Failed to create slab, "\r\n"fixed buffer mode disabled.");\r\nelse\r\nDBF_EVENT(DBF_INFO, "%s",\r\n"turning on fixed buffer mode");\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int __init dasd_evaluate_range_param(char *range, char **from_str,\r\nchar **to_str, char **features_str)\r\n{\r\nint rc = 0;\r\nif (strchr(range, '-')) {\r\n*from_str = strsep(&range, "-");\r\n*to_str = strsep(&range, "(");\r\n*features_str = strsep(&range, ")");\r\n} else {\r\n*from_str = strsep(&range, "(");\r\n*features_str = strsep(&range, ")");\r\n}\r\nif (*features_str && !range) {\r\npr_warn("A closing parenthesis ')' is missing in the dasd= parameter\n");\r\nrc = -EINVAL;\r\n}\r\nreturn rc;\r\n}\r\nstatic int __init dasd_parse_range(const char *range)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint from, from_id0, from_id1;\r\nint to, to_id0, to_id1;\r\nint features;\r\nchar bus_id[DASD_BUS_ID_SIZE + 1];\r\nchar *features_str = NULL;\r\nchar *from_str = NULL;\r\nchar *to_str = NULL;\r\nsize_t len = strlen(range) + 1;\r\nchar tmp[len];\r\nstrlcpy(tmp, range, len);\r\nif (dasd_evaluate_range_param(tmp, &from_str, &to_str, &features_str))\r\ngoto out_err;\r\nif (dasd_busid(from_str, &from_id0, &from_id1, &from))\r\ngoto out_err;\r\nto = from;\r\nto_id0 = from_id0;\r\nto_id1 = from_id1;\r\nif (to_str) {\r\nif (dasd_busid(to_str, &to_id0, &to_id1, &to))\r\ngoto out_err;\r\nif (from_id0 != to_id0 || from_id1 != to_id1 || from > to) {\r\npr_err("%s is not a valid device range\n", range);\r\ngoto out_err;\r\n}\r\n}\r\nfeatures = dasd_feature_list(features_str);\r\nif (features < 0)\r\ngoto out_err;\r\nfeatures |= DASD_FEATURE_INITIAL_ONLINE;\r\nwhile (from <= to) {\r\nsprintf(bus_id, "%01x.%01x.%04x", from_id0, from_id1, from++);\r\ndevmap = dasd_add_busid(bus_id, features);\r\nif (IS_ERR(devmap))\r\nreturn PTR_ERR(devmap);\r\n}\r\nreturn 0;\r\nout_err:\r\nreturn -EINVAL;\r\n}\r\nint __init dasd_parse(void)\r\n{\r\nint rc, i;\r\nchar *cur;\r\nrc = 0;\r\nfor (i = 0; i < DASD_MAX_PARAMS; i++) {\r\ncur = dasd[i];\r\nif (!cur)\r\nbreak;\r\nif (*cur == '\0')\r\ncontinue;\r\nrc = dasd_parse_keyword(cur);\r\nif (rc)\r\nrc = dasd_parse_range(cur);\r\nif (rc)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nstatic struct dasd_devmap *\r\ndasd_add_busid(const char *bus_id, int features)\r\n{\r\nstruct dasd_devmap *devmap, *new, *tmp;\r\nint hash;\r\nnew = kzalloc(sizeof(struct dasd_devmap), GFP_KERNEL);\r\nif (!new)\r\nreturn ERR_PTR(-ENOMEM);\r\nspin_lock(&dasd_devmap_lock);\r\ndevmap = NULL;\r\nhash = dasd_hash_busid(bus_id);\r\nlist_for_each_entry(tmp, &dasd_hashlists[hash], list)\r\nif (strncmp(tmp->bus_id, bus_id, DASD_BUS_ID_SIZE) == 0) {\r\ndevmap = tmp;\r\nbreak;\r\n}\r\nif (!devmap) {\r\nnew->devindex = dasd_max_devindex++;\r\nstrncpy(new->bus_id, bus_id, DASD_BUS_ID_SIZE);\r\nnew->features = features;\r\nnew->device = NULL;\r\nlist_add(&new->list, &dasd_hashlists[hash]);\r\ndevmap = new;\r\nnew = NULL;\r\n}\r\nspin_unlock(&dasd_devmap_lock);\r\nkfree(new);\r\nreturn devmap;\r\n}\r\nstatic struct dasd_devmap *\r\ndasd_find_busid(const char *bus_id)\r\n{\r\nstruct dasd_devmap *devmap, *tmp;\r\nint hash;\r\nspin_lock(&dasd_devmap_lock);\r\ndevmap = ERR_PTR(-ENODEV);\r\nhash = dasd_hash_busid(bus_id);\r\nlist_for_each_entry(tmp, &dasd_hashlists[hash], list) {\r\nif (strncmp(tmp->bus_id, bus_id, DASD_BUS_ID_SIZE) == 0) {\r\ndevmap = tmp;\r\nbreak;\r\n}\r\n}\r\nspin_unlock(&dasd_devmap_lock);\r\nreturn devmap;\r\n}\r\nint\r\ndasd_busid_known(const char *bus_id)\r\n{\r\nreturn IS_ERR(dasd_find_busid(bus_id)) ? -ENOENT : 0;\r\n}\r\nstatic void\r\ndasd_forget_ranges(void)\r\n{\r\nstruct dasd_devmap *devmap, *n;\r\nint i;\r\nspin_lock(&dasd_devmap_lock);\r\nfor (i = 0; i < 256; i++) {\r\nlist_for_each_entry_safe(devmap, n, &dasd_hashlists[i], list) {\r\nBUG_ON(devmap->device != NULL);\r\nlist_del(&devmap->list);\r\nkfree(devmap);\r\n}\r\n}\r\nspin_unlock(&dasd_devmap_lock);\r\n}\r\nstruct dasd_device *\r\ndasd_device_from_devindex(int devindex)\r\n{\r\nstruct dasd_devmap *devmap, *tmp;\r\nstruct dasd_device *device;\r\nint i;\r\nspin_lock(&dasd_devmap_lock);\r\ndevmap = NULL;\r\nfor (i = 0; (i < 256) && !devmap; i++)\r\nlist_for_each_entry(tmp, &dasd_hashlists[i], list)\r\nif (tmp->devindex == devindex) {\r\ndevmap = tmp;\r\nbreak;\r\n}\r\nif (devmap && devmap->device) {\r\ndevice = devmap->device;\r\ndasd_get_device(device);\r\n} else\r\ndevice = ERR_PTR(-ENODEV);\r\nspin_unlock(&dasd_devmap_lock);\r\nreturn device;\r\n}\r\nstatic struct dasd_devmap *\r\ndasd_devmap_from_cdev(struct ccw_device *cdev)\r\n{\r\nstruct dasd_devmap *devmap;\r\ndevmap = dasd_find_busid(dev_name(&cdev->dev));\r\nif (IS_ERR(devmap))\r\ndevmap = dasd_add_busid(dev_name(&cdev->dev),\r\nDASD_FEATURE_DEFAULT);\r\nreturn devmap;\r\n}\r\nstruct dasd_device *\r\ndasd_create_device(struct ccw_device *cdev)\r\n{\r\nstruct dasd_devmap *devmap;\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\nint rc;\r\ndevmap = dasd_devmap_from_cdev(cdev);\r\nif (IS_ERR(devmap))\r\nreturn (void *) devmap;\r\ndevice = dasd_alloc_device();\r\nif (IS_ERR(device))\r\nreturn device;\r\natomic_set(&device->ref_count, 3);\r\nspin_lock(&dasd_devmap_lock);\r\nif (!devmap->device) {\r\ndevmap->device = device;\r\ndevice->devindex = devmap->devindex;\r\ndevice->features = devmap->features;\r\nget_device(&cdev->dev);\r\ndevice->cdev = cdev;\r\nrc = 0;\r\n} else\r\nrc = -EBUSY;\r\nspin_unlock(&dasd_devmap_lock);\r\nif (rc) {\r\ndasd_free_device(device);\r\nreturn ERR_PTR(rc);\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\ndev_set_drvdata(&cdev->dev, device);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nreturn device;\r\n}\r\nvoid\r\ndasd_delete_device(struct dasd_device *device)\r\n{\r\nstruct ccw_device *cdev;\r\nstruct dasd_devmap *devmap;\r\nunsigned long flags;\r\ndevmap = dasd_find_busid(dev_name(&device->cdev->dev));\r\nBUG_ON(IS_ERR(devmap));\r\nspin_lock(&dasd_devmap_lock);\r\nif (devmap->device != device) {\r\nspin_unlock(&dasd_devmap_lock);\r\ndasd_put_device(device);\r\nreturn;\r\n}\r\ndevmap->device = NULL;\r\nspin_unlock(&dasd_devmap_lock);\r\nspin_lock_irqsave(get_ccwdev_lock(device->cdev), flags);\r\ndev_set_drvdata(&device->cdev->dev, NULL);\r\nspin_unlock_irqrestore(get_ccwdev_lock(device->cdev), flags);\r\natomic_sub(3, &device->ref_count);\r\nwait_event(dasd_delete_wq, atomic_read(&device->ref_count) == 0);\r\ndasd_generic_free_discipline(device);\r\ncdev = device->cdev;\r\ndevice->cdev = NULL;\r\nput_device(&cdev->dev);\r\ndasd_free_device(device);\r\n}\r\nvoid\r\ndasd_put_device_wake(struct dasd_device *device)\r\n{\r\nwake_up(&dasd_delete_wq);\r\n}\r\nstruct dasd_device *\r\ndasd_device_from_cdev_locked(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device = dev_get_drvdata(&cdev->dev);\r\nif (!device)\r\nreturn ERR_PTR(-ENODEV);\r\ndasd_get_device(device);\r\nreturn device;\r\n}\r\nstruct dasd_device *\r\ndasd_device_from_cdev(struct ccw_device *cdev)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\ndevice = dasd_device_from_cdev_locked(cdev);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nreturn device;\r\n}\r\nvoid dasd_add_link_to_gendisk(struct gendisk *gdp, struct dasd_device *device)\r\n{\r\nstruct dasd_devmap *devmap;\r\ndevmap = dasd_find_busid(dev_name(&device->cdev->dev));\r\nif (IS_ERR(devmap))\r\nreturn;\r\nspin_lock(&dasd_devmap_lock);\r\ngdp->private_data = devmap;\r\nspin_unlock(&dasd_devmap_lock);\r\n}\r\nstruct dasd_device *dasd_device_from_gendisk(struct gendisk *gdp)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_devmap *devmap;\r\nif (!gdp->private_data)\r\nreturn NULL;\r\ndevice = NULL;\r\nspin_lock(&dasd_devmap_lock);\r\ndevmap = gdp->private_data;\r\nif (devmap && devmap->device) {\r\ndevice = devmap->device;\r\ndasd_get_device(device);\r\n}\r\nspin_unlock(&dasd_devmap_lock);\r\nreturn device;\r\n}\r\nstatic ssize_t dasd_ff_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint ff_flag;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (!IS_ERR(devmap))\r\nff_flag = (devmap->features & DASD_FEATURE_FAILFAST) != 0;\r\nelse\r\nff_flag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_FAILFAST) != 0;\r\nreturn snprintf(buf, PAGE_SIZE, ff_flag ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t dasd_ff_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int val;\r\nint rc;\r\nif (kstrtouint(buf, 0, &val) || val > 1)\r\nreturn -EINVAL;\r\nrc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_FAILFAST, val);\r\nreturn rc ? : count;\r\n}\r\nstatic ssize_t\r\ndasd_ro_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint ro_flag;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (!IS_ERR(devmap))\r\nro_flag = (devmap->features & DASD_FEATURE_READONLY) != 0;\r\nelse\r\nro_flag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_READONLY) != 0;\r\nreturn snprintf(buf, PAGE_SIZE, ro_flag ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndasd_ro_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\nunsigned int val;\r\nint rc;\r\nif (kstrtouint(buf, 0, &val) || val > 1)\r\nreturn -EINVAL;\r\nrc = dasd_set_feature(cdev, DASD_FEATURE_READONLY, val);\r\nif (rc)\r\nreturn rc;\r\ndevice = dasd_device_from_cdev(cdev);\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\nspin_lock_irqsave(get_ccwdev_lock(cdev), flags);\r\nval = val || test_bit(DASD_FLAG_DEVICE_RO, &device->flags);\r\nif (!device->block || !device->block->gdp ||\r\ntest_bit(DASD_FLAG_OFFLINE, &device->flags)) {\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\ngoto out;\r\n}\r\natomic_inc(&device->block->open_count);\r\nspin_unlock_irqrestore(get_ccwdev_lock(cdev), flags);\r\nset_disk_ro(device->block->gdp, val);\r\natomic_dec(&device->block->open_count);\r\nout:\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ndasd_erplog_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint erplog;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (!IS_ERR(devmap))\r\nerplog = (devmap->features & DASD_FEATURE_ERPLOG) != 0;\r\nelse\r\nerplog = (DASD_FEATURE_DEFAULT & DASD_FEATURE_ERPLOG) != 0;\r\nreturn snprintf(buf, PAGE_SIZE, erplog ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndasd_erplog_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nunsigned int val;\r\nint rc;\r\nif (kstrtouint(buf, 0, &val) || val > 1)\r\nreturn -EINVAL;\r\nrc = dasd_set_feature(to_ccwdev(dev), DASD_FEATURE_ERPLOG, val);\r\nreturn rc ? : count;\r\n}\r\nstatic ssize_t\r\ndasd_use_diag_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint use_diag;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (!IS_ERR(devmap))\r\nuse_diag = (devmap->features & DASD_FEATURE_USEDIAG) != 0;\r\nelse\r\nuse_diag = (DASD_FEATURE_DEFAULT & DASD_FEATURE_USEDIAG) != 0;\r\nreturn sprintf(buf, use_diag ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndasd_use_diag_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_devmap *devmap;\r\nunsigned int val;\r\nssize_t rc;\r\ndevmap = dasd_devmap_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(devmap))\r\nreturn PTR_ERR(devmap);\r\nif (kstrtouint(buf, 0, &val) || val > 1)\r\nreturn -EINVAL;\r\nspin_lock(&dasd_devmap_lock);\r\nrc = count;\r\nif (!devmap->device && !(devmap->features & DASD_FEATURE_USERAW)) {\r\nif (val)\r\ndevmap->features |= DASD_FEATURE_USEDIAG;\r\nelse\r\ndevmap->features &= ~DASD_FEATURE_USEDIAG;\r\n} else\r\nrc = -EPERM;\r\nspin_unlock(&dasd_devmap_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ndasd_use_raw_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint use_raw;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (!IS_ERR(devmap))\r\nuse_raw = (devmap->features & DASD_FEATURE_USERAW) != 0;\r\nelse\r\nuse_raw = (DASD_FEATURE_DEFAULT & DASD_FEATURE_USERAW) != 0;\r\nreturn sprintf(buf, use_raw ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndasd_use_raw_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_devmap *devmap;\r\nssize_t rc;\r\nunsigned long val;\r\ndevmap = dasd_devmap_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(devmap))\r\nreturn PTR_ERR(devmap);\r\nif ((kstrtoul(buf, 10, &val) != 0) || val > 1)\r\nreturn -EINVAL;\r\nspin_lock(&dasd_devmap_lock);\r\nrc = count;\r\nif (!devmap->device && !(devmap->features & DASD_FEATURE_USEDIAG)) {\r\nif (val)\r\ndevmap->features |= DASD_FEATURE_USERAW;\r\nelse\r\ndevmap->features &= ~DASD_FEATURE_USERAW;\r\n} else\r\nrc = -EPERM;\r\nspin_unlock(&dasd_devmap_lock);\r\nreturn rc;\r\n}\r\nstatic ssize_t\r\ndasd_safe_offline_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct dasd_device *device;\r\nint rc;\r\ndevice = dasd_device_from_cdev(cdev);\r\nif (IS_ERR(device)) {\r\nrc = PTR_ERR(device);\r\ngoto out;\r\n}\r\nif (test_bit(DASD_FLAG_OFFLINE, &device->flags) ||\r\ntest_bit(DASD_FLAG_SAFE_OFFLINE_RUNNING, &device->flags)) {\r\ndasd_put_device(device);\r\nrc = -EBUSY;\r\ngoto out;\r\n}\r\nset_bit(DASD_FLAG_SAFE_OFFLINE, &device->flags);\r\ndasd_put_device(device);\r\nrc = ccw_device_set_offline(cdev);\r\nout:\r\nreturn rc ? rc : count;\r\n}\r\nstatic ssize_t\r\ndasd_access_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nstruct dasd_device *device;\r\nint count;\r\ndevice = dasd_device_from_cdev(cdev);\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\nif (!device->discipline)\r\ncount = -ENODEV;\r\nelse if (!device->discipline->host_access_count)\r\ncount = -EOPNOTSUPP;\r\nelse\r\ncount = device->discipline->host_access_count(device);\r\ndasd_put_device(device);\r\nif (count < 0)\r\nreturn count;\r\nreturn sprintf(buf, "%d\n", count);\r\n}\r\nstatic ssize_t\r\ndasd_discipline_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_device *device;\r\nssize_t len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\ngoto out;\r\nelse if (!device->discipline) {\r\ndasd_put_device(device);\r\ngoto out;\r\n} else {\r\nlen = snprintf(buf, PAGE_SIZE, "%s\n",\r\ndevice->discipline->name);\r\ndasd_put_device(device);\r\nreturn len;\r\n}\r\nout:\r\nlen = snprintf(buf, PAGE_SIZE, "none\n");\r\nreturn len;\r\n}\r\nstatic ssize_t\r\ndasd_device_status_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_device *device;\r\nssize_t len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (!IS_ERR(device)) {\r\nswitch (device->state) {\r\ncase DASD_STATE_NEW:\r\nlen = snprintf(buf, PAGE_SIZE, "new\n");\r\nbreak;\r\ncase DASD_STATE_KNOWN:\r\nlen = snprintf(buf, PAGE_SIZE, "detected\n");\r\nbreak;\r\ncase DASD_STATE_BASIC:\r\nlen = snprintf(buf, PAGE_SIZE, "basic\n");\r\nbreak;\r\ncase DASD_STATE_UNFMT:\r\nlen = snprintf(buf, PAGE_SIZE, "unformatted\n");\r\nbreak;\r\ncase DASD_STATE_READY:\r\nlen = snprintf(buf, PAGE_SIZE, "ready\n");\r\nbreak;\r\ncase DASD_STATE_ONLINE:\r\nlen = snprintf(buf, PAGE_SIZE, "online\n");\r\nbreak;\r\ndefault:\r\nlen = snprintf(buf, PAGE_SIZE, "no stat\n");\r\nbreak;\r\n}\r\ndasd_put_device(device);\r\n} else\r\nlen = snprintf(buf, PAGE_SIZE, "unknown\n");\r\nreturn len;\r\n}\r\nstatic ssize_t dasd_alias_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_uid uid;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn sprintf(buf, "0\n");\r\nif (device->discipline && device->discipline->get_uid &&\r\n!device->discipline->get_uid(device, &uid)) {\r\nif (uid.type == UA_BASE_PAV_ALIAS ||\r\nuid.type == UA_HYPER_PAV_ALIAS) {\r\ndasd_put_device(device);\r\nreturn sprintf(buf, "1\n");\r\n}\r\n}\r\ndasd_put_device(device);\r\nreturn sprintf(buf, "0\n");\r\n}\r\nstatic ssize_t dasd_vendor_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_uid uid;\r\nchar *vendor;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nvendor = "";\r\nif (IS_ERR(device))\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", vendor);\r\nif (device->discipline && device->discipline->get_uid &&\r\n!device->discipline->get_uid(device, &uid))\r\nvendor = uid.vendor;\r\ndasd_put_device(device);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", vendor);\r\n}\r\nstatic ssize_t\r\ndasd_uid_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nstruct dasd_uid uid;\r\nchar uid_string[UID_STRLEN];\r\nchar ua_string[3];\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nuid_string[0] = 0;\r\nif (IS_ERR(device))\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", uid_string);\r\nif (device->discipline && device->discipline->get_uid &&\r\n!device->discipline->get_uid(device, &uid)) {\r\nswitch (uid.type) {\r\ncase UA_BASE_DEVICE:\r\nsnprintf(ua_string, sizeof(ua_string), "%02x",\r\nuid.real_unit_addr);\r\nbreak;\r\ncase UA_BASE_PAV_ALIAS:\r\nsnprintf(ua_string, sizeof(ua_string), "%02x",\r\nuid.base_unit_addr);\r\nbreak;\r\ncase UA_HYPER_PAV_ALIAS:\r\nsnprintf(ua_string, sizeof(ua_string), "xx");\r\nbreak;\r\ndefault:\r\nsnprintf(ua_string, sizeof(ua_string), "%02x",\r\nuid.real_unit_addr);\r\nbreak;\r\n}\r\nif (strlen(uid.vduit) > 0)\r\nsnprintf(uid_string, sizeof(uid_string),\r\n"%s.%s.%04x.%s.%s",\r\nuid.vendor, uid.serial, uid.ssid, ua_string,\r\nuid.vduit);\r\nelse\r\nsnprintf(uid_string, sizeof(uid_string),\r\n"%s.%s.%04x.%s",\r\nuid.vendor, uid.serial, uid.ssid, ua_string);\r\n}\r\ndasd_put_device(device);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", uid_string);\r\n}\r\nstatic ssize_t\r\ndasd_eer_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint eer_flag;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (!IS_ERR(devmap) && devmap->device)\r\neer_flag = dasd_eer_enabled(devmap->device);\r\nelse\r\neer_flag = 0;\r\nreturn snprintf(buf, PAGE_SIZE, eer_flag ? "1\n" : "0\n");\r\n}\r\nstatic ssize_t\r\ndasd_eer_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nunsigned int val;\r\nint rc = 0;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn PTR_ERR(device);\r\nif (kstrtouint(buf, 0, &val) || val > 1)\r\nreturn -EINVAL;\r\nif (val)\r\nrc = dasd_eer_enable(device);\r\nelse\r\ndasd_eer_disable(device);\r\ndasd_put_device(device);\r\nreturn rc ? : count;\r\n}\r\nstatic ssize_t\r\ndasd_expires_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nint len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nlen = snprintf(buf, PAGE_SIZE, "%lu\n", device->default_expires);\r\ndasd_put_device(device);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\ndasd_expires_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long val;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif ((kstrtoul(buf, 10, &val) != 0) ||\r\n(val > DASD_EXPIRES_MAX) || val == 0) {\r\ndasd_put_device(device);\r\nreturn -EINVAL;\r\n}\r\nif (val)\r\ndevice->default_expires = val;\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ndasd_retries_show(struct device *dev, struct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nint len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nlen = snprintf(buf, PAGE_SIZE, "%lu\n", device->default_retries);\r\ndasd_put_device(device);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\ndasd_retries_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long val;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif ((kstrtoul(buf, 10, &val) != 0) ||\r\n(val > DASD_RETRIES_MAX)) {\r\ndasd_put_device(device);\r\nreturn -EINVAL;\r\n}\r\nif (val)\r\ndevice->default_retries = val;\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ndasd_timeout_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_device *device;\r\nint len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nlen = snprintf(buf, PAGE_SIZE, "%lu\n", device->blk_timeout);\r\ndasd_put_device(device);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\ndasd_timeout_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nstruct request_queue *q;\r\nunsigned long val, flags;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device) || !device->block)\r\nreturn -ENODEV;\r\nif ((kstrtoul(buf, 10, &val) != 0) ||\r\nval > UINT_MAX / HZ) {\r\ndasd_put_device(device);\r\nreturn -EINVAL;\r\n}\r\nq = device->block->request_queue;\r\nif (!q) {\r\ndasd_put_device(device);\r\nreturn -ENODEV;\r\n}\r\nspin_lock_irqsave(&device->block->request_queue_lock, flags);\r\nif (!val)\r\nblk_queue_rq_timed_out(q, NULL);\r\nelse\r\nblk_queue_rq_timed_out(q, dasd_times_out);\r\ndevice->blk_timeout = val;\r\nblk_queue_rq_timeout(q, device->blk_timeout * HZ);\r\nspin_unlock_irqrestore(&device->block->request_queue_lock, flags);\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ndasd_path_reset_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nunsigned int val;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif ((kstrtouint(buf, 16, &val) != 0) || val > 0xff)\r\nval = 0;\r\nif (device->discipline && device->discipline->reset_path)\r\ndevice->discipline->reset_path(device, (__u8) val);\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nstatic ssize_t dasd_hpf_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_device *device;\r\nint hpf;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif (!device->discipline || !device->discipline->hpf_enabled) {\r\ndasd_put_device(device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", dasd_nofcx);\r\n}\r\nhpf = device->discipline->hpf_enabled(device);\r\ndasd_put_device(device);\r\nreturn snprintf(buf, PAGE_SIZE, "%d\n", hpf);\r\n}\r\nstatic ssize_t dasd_reservation_policy_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_devmap *devmap;\r\nint rc = 0;\r\ndevmap = dasd_find_busid(dev_name(dev));\r\nif (IS_ERR(devmap)) {\r\nrc = snprintf(buf, PAGE_SIZE, "ignore\n");\r\n} else {\r\nspin_lock(&dasd_devmap_lock);\r\nif (devmap->features & DASD_FEATURE_FAILONSLCK)\r\nrc = snprintf(buf, PAGE_SIZE, "fail\n");\r\nelse\r\nrc = snprintf(buf, PAGE_SIZE, "ignore\n");\r\nspin_unlock(&dasd_devmap_lock);\r\n}\r\nreturn rc;\r\n}\r\nstatic ssize_t dasd_reservation_policy_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ccw_device *cdev = to_ccwdev(dev);\r\nint rc;\r\nif (sysfs_streq("ignore", buf))\r\nrc = dasd_set_feature(cdev, DASD_FEATURE_FAILONSLCK, 0);\r\nelse if (sysfs_streq("fail", buf))\r\nrc = dasd_set_feature(cdev, DASD_FEATURE_FAILONSLCK, 1);\r\nelse\r\nrc = -EINVAL;\r\nreturn rc ? : count;\r\n}\r\nstatic ssize_t dasd_reservation_state_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct dasd_device *device;\r\nint rc = 0;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn snprintf(buf, PAGE_SIZE, "none\n");\r\nif (test_bit(DASD_FLAG_IS_RESERVED, &device->flags))\r\nrc = snprintf(buf, PAGE_SIZE, "reserved\n");\r\nelse if (test_bit(DASD_FLAG_LOCK_STOLEN, &device->flags))\r\nrc = snprintf(buf, PAGE_SIZE, "lost\n");\r\nelse\r\nrc = snprintf(buf, PAGE_SIZE, "none\n");\r\ndasd_put_device(device);\r\nreturn rc;\r\n}\r\nstatic ssize_t dasd_reservation_state_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nint rc = 0;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif (sysfs_streq("reset", buf))\r\nclear_bit(DASD_FLAG_LOCK_STOLEN, &device->flags);\r\nelse\r\nrc = -EINVAL;\r\ndasd_put_device(device);\r\nif (rc)\r\nreturn rc;\r\nelse\r\nreturn count;\r\n}\r\nstatic ssize_t dasd_pm_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nu8 opm, nppm, cablepm, cuirpm, hpfpm, ifccpm;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn sprintf(buf, "0\n");\r\nopm = dasd_path_get_opm(device);\r\nnppm = dasd_path_get_nppm(device);\r\ncablepm = dasd_path_get_cablepm(device);\r\ncuirpm = dasd_path_get_cuirpm(device);\r\nhpfpm = dasd_path_get_hpfpm(device);\r\nifccpm = dasd_path_get_ifccpm(device);\r\ndasd_put_device(device);\r\nreturn sprintf(buf, "%02x %02x %02x %02x %02x %02x\n", opm, nppm,\r\ncablepm, cuirpm, hpfpm, ifccpm);\r\n}\r\nstatic ssize_t\r\ndasd_path_threshold_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nint len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nlen = snprintf(buf, PAGE_SIZE, "%lu\n", device->path_thrhld);\r\ndasd_put_device(device);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\ndasd_path_threshold_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\nunsigned long val;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif (kstrtoul(buf, 10, &val) != 0 || val > DASD_THRHLD_MAX) {\r\ndasd_put_device(device);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(to_ccwdev(dev)), flags);\r\ndevice->path_thrhld = val;\r\nspin_unlock_irqrestore(get_ccwdev_lock(to_ccwdev(dev)), flags);\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nstatic ssize_t\r\ndasd_path_interval_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct dasd_device *device;\r\nint len;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nlen = snprintf(buf, PAGE_SIZE, "%lu\n", device->path_interval);\r\ndasd_put_device(device);\r\nreturn len;\r\n}\r\nstatic ssize_t\r\ndasd_path_interval_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct dasd_device *device;\r\nunsigned long flags;\r\nunsigned long val;\r\ndevice = dasd_device_from_cdev(to_ccwdev(dev));\r\nif (IS_ERR(device))\r\nreturn -ENODEV;\r\nif ((kstrtoul(buf, 10, &val) != 0) ||\r\n(val > DASD_INTERVAL_MAX) || val == 0) {\r\ndasd_put_device(device);\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(get_ccwdev_lock(to_ccwdev(dev)), flags);\r\nif (val)\r\ndevice->path_interval = val;\r\nspin_unlock_irqrestore(get_ccwdev_lock(to_ccwdev(dev)), flags);\r\ndasd_put_device(device);\r\nreturn count;\r\n}\r\nint\r\ndasd_get_feature(struct ccw_device *cdev, int feature)\r\n{\r\nstruct dasd_devmap *devmap;\r\ndevmap = dasd_find_busid(dev_name(&cdev->dev));\r\nif (IS_ERR(devmap))\r\nreturn PTR_ERR(devmap);\r\nreturn ((devmap->features & feature) != 0);\r\n}\r\nint\r\ndasd_set_feature(struct ccw_device *cdev, int feature, int flag)\r\n{\r\nstruct dasd_devmap *devmap;\r\ndevmap = dasd_devmap_from_cdev(cdev);\r\nif (IS_ERR(devmap))\r\nreturn PTR_ERR(devmap);\r\nspin_lock(&dasd_devmap_lock);\r\nif (flag)\r\ndevmap->features |= feature;\r\nelse\r\ndevmap->features &= ~feature;\r\nif (devmap->device)\r\ndevmap->device->features = devmap->features;\r\nspin_unlock(&dasd_devmap_lock);\r\nreturn 0;\r\n}\r\nint\r\ndasd_add_sysfs_files(struct ccw_device *cdev)\r\n{\r\nreturn sysfs_create_group(&cdev->dev.kobj, &dasd_attr_group);\r\n}\r\nvoid\r\ndasd_remove_sysfs_files(struct ccw_device *cdev)\r\n{\r\nsysfs_remove_group(&cdev->dev.kobj, &dasd_attr_group);\r\n}\r\nint\r\ndasd_devmap_init(void)\r\n{\r\nint i;\r\ndasd_max_devindex = 0;\r\nfor (i = 0; i < 256; i++)\r\nINIT_LIST_HEAD(&dasd_hashlists[i]);\r\nreturn 0;\r\n}\r\nvoid\r\ndasd_devmap_exit(void)\r\n{\r\ndasd_forget_ranges();\r\n}
