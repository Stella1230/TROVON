static irqreturn_t axp20x_usb_power_irq(int irq, void *devid)\r\n{\r\nstruct axp20x_usb_power *power = devid;\r\npower_supply_changed(power->supply);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int axp20x_usb_power_get_property(struct power_supply *psy,\r\nenum power_supply_property psp, union power_supply_propval *val)\r\n{\r\nstruct axp20x_usb_power *power = power_supply_get_drvdata(psy);\r\nunsigned int input, v;\r\nint ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN:\r\nret = regmap_read(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, &v);\r\nif (ret)\r\nreturn ret;\r\nval->intval = AXP20X_VBUS_VHOLD_uV(v);\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nif (IS_ENABLED(CONFIG_AXP20X_ADC)) {\r\nret = iio_read_channel_processed(power->vbus_v,\r\n&val->intval);\r\nif (ret)\r\nreturn ret;\r\nval->intval *= 1000;\r\nreturn 0;\r\n}\r\nret = axp20x_read_variable_width(power->regmap,\r\nAXP20X_VBUS_V_ADC_H, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 1700;\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nret = regmap_read(power->regmap, AXP20X_VBUS_IPSOUT_MGMT, &v);\r\nif (ret)\r\nreturn ret;\r\nswitch (v & AXP20X_VBUS_CLIMIT_MASK) {\r\ncase AXP20X_VBUC_CLIMIT_100mA:\r\nif (power->axp20x_id == AXP221_ID)\r\nval->intval = -1;\r\nelse\r\nval->intval = 100000;\r\nbreak;\r\ncase AXP20X_VBUC_CLIMIT_500mA:\r\nval->intval = 500000;\r\nbreak;\r\ncase AXP20X_VBUC_CLIMIT_900mA:\r\nval->intval = 900000;\r\nbreak;\r\ncase AXP20X_VBUC_CLIMIT_NONE:\r\nval->intval = -1;\r\nbreak;\r\n}\r\nreturn 0;\r\ncase POWER_SUPPLY_PROP_CURRENT_NOW:\r\nif (IS_ENABLED(CONFIG_AXP20X_ADC)) {\r\nret = iio_read_channel_processed(power->vbus_i,\r\n&val->intval);\r\nif (ret)\r\nreturn ret;\r\nval->intval *= 1000;\r\nreturn 0;\r\n}\r\nret = axp20x_read_variable_width(power->regmap,\r\nAXP20X_VBUS_I_ADC_H, 12);\r\nif (ret < 0)\r\nreturn ret;\r\nval->intval = ret * 375;\r\nreturn 0;\r\ndefault:\r\nbreak;\r\n}\r\nret = regmap_read(power->regmap, AXP20X_PWR_INPUT_STATUS, &input);\r\nif (ret)\r\nreturn ret;\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_HEALTH:\r\nif (!(input & AXP20X_PWR_STATUS_VBUS_PRESENT)) {\r\nval->intval = POWER_SUPPLY_HEALTH_UNKNOWN;\r\nbreak;\r\n}\r\nval->intval = POWER_SUPPLY_HEALTH_GOOD;\r\nif (power->axp20x_id == AXP202_ID) {\r\nret = regmap_read(power->regmap,\r\nAXP20X_USB_OTG_STATUS, &v);\r\nif (ret)\r\nreturn ret;\r\nif (!(v & AXP20X_USB_STATUS_VBUS_VALID))\r\nval->intval =\r\nPOWER_SUPPLY_HEALTH_UNSPEC_FAILURE;\r\n}\r\nbreak;\r\ncase POWER_SUPPLY_PROP_PRESENT:\r\nval->intval = !!(input & AXP20X_PWR_STATUS_VBUS_PRESENT);\r\nbreak;\r\ncase POWER_SUPPLY_PROP_ONLINE:\r\nval->intval = !!(input & AXP20X_PWR_STATUS_VBUS_USED);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nstatic int axp20x_usb_power_set_voltage_min(struct axp20x_usb_power *power,\r\nint intval)\r\n{\r\nint val;\r\nswitch (intval) {\r\ncase 4000000:\r\ncase 4100000:\r\ncase 4200000:\r\ncase 4300000:\r\ncase 4400000:\r\ncase 4500000:\r\ncase 4600000:\r\ncase 4700000:\r\nval = (intval - 4000000) / 100000;\r\nreturn regmap_update_bits(power->regmap,\r\nAXP20X_VBUS_IPSOUT_MGMT,\r\nAXP20X_VBUS_VHOLD_MASK,\r\nval << AXP20X_VBUS_VHOLD_OFFSET);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int axp20x_usb_power_set_current_max(struct axp20x_usb_power *power,\r\nint intval)\r\n{\r\nint val;\r\nswitch (intval) {\r\ncase 100000:\r\nif (power->axp20x_id == AXP221_ID)\r\nreturn -EINVAL;\r\ncase 500000:\r\ncase 900000:\r\nval = (900000 - intval) / 400000;\r\nreturn regmap_update_bits(power->regmap,\r\nAXP20X_VBUS_IPSOUT_MGMT,\r\nAXP20X_VBUS_CLIMIT_MASK, val);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int axp20x_usb_power_set_property(struct power_supply *psy,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct axp20x_usb_power *power = power_supply_get_drvdata(psy);\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_VOLTAGE_MIN:\r\nreturn axp20x_usb_power_set_voltage_min(power, val->intval);\r\ncase POWER_SUPPLY_PROP_CURRENT_MAX:\r\nreturn axp20x_usb_power_set_current_max(power, val->intval);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int axp20x_usb_power_prop_writeable(struct power_supply *psy,\r\nenum power_supply_property psp)\r\n{\r\nreturn psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||\r\npsp == POWER_SUPPLY_PROP_CURRENT_MAX;\r\n}\r\nstatic int configure_iio_channels(struct platform_device *pdev,\r\nstruct axp20x_usb_power *power)\r\n{\r\npower->vbus_v = devm_iio_channel_get(&pdev->dev, "vbus_v");\r\nif (IS_ERR(power->vbus_v)) {\r\nif (PTR_ERR(power->vbus_v) == -ENODEV)\r\nreturn -EPROBE_DEFER;\r\nreturn PTR_ERR(power->vbus_v);\r\n}\r\npower->vbus_i = devm_iio_channel_get(&pdev->dev, "vbus_i");\r\nif (IS_ERR(power->vbus_i)) {\r\nif (PTR_ERR(power->vbus_i) == -ENODEV)\r\nreturn -EPROBE_DEFER;\r\nreturn PTR_ERR(power->vbus_i);\r\n}\r\nreturn 0;\r\n}\r\nstatic int configure_adc_registers(struct axp20x_usb_power *power)\r\n{\r\nreturn regmap_update_bits(power->regmap, AXP20X_ADC_EN1,\r\nAXP20X_ADC_EN1_VBUS_CURR |\r\nAXP20X_ADC_EN1_VBUS_VOLT,\r\nAXP20X_ADC_EN1_VBUS_CURR |\r\nAXP20X_ADC_EN1_VBUS_VOLT);\r\n}\r\nstatic int axp20x_usb_power_probe(struct platform_device *pdev)\r\n{\r\nstruct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);\r\nstruct power_supply_config psy_cfg = {};\r\nstruct axp20x_usb_power *power;\r\nstatic const char * const axp20x_irq_names[] = { "VBUS_PLUGIN",\r\n"VBUS_REMOVAL", "VBUS_VALID", "VBUS_NOT_VALID", NULL };\r\nstatic const char * const axp22x_irq_names[] = {\r\n"VBUS_PLUGIN", "VBUS_REMOVAL", NULL };\r\nstatic const char * const *irq_names;\r\nconst struct power_supply_desc *usb_power_desc;\r\nint i, irq, ret;\r\nif (!of_device_is_available(pdev->dev.of_node))\r\nreturn -ENODEV;\r\nif (!axp20x) {\r\ndev_err(&pdev->dev, "Parent drvdata not set\n");\r\nreturn -EINVAL;\r\n}\r\npower = devm_kzalloc(&pdev->dev, sizeof(*power), GFP_KERNEL);\r\nif (!power)\r\nreturn -ENOMEM;\r\npower->axp20x_id = (enum axp20x_variants)of_device_get_match_data(\r\n&pdev->dev);\r\npower->np = pdev->dev.of_node;\r\npower->regmap = axp20x->regmap;\r\nif (power->axp20x_id == AXP202_ID) {\r\nret = regmap_update_bits(power->regmap, AXP20X_VBUS_MON,\r\nAXP20X_VBUS_MON_VBUS_VALID,\r\nAXP20X_VBUS_MON_VBUS_VALID);\r\nif (ret)\r\nreturn ret;\r\nif (IS_ENABLED(CONFIG_AXP20X_ADC))\r\nret = configure_iio_channels(pdev, power);\r\nelse\r\nret = configure_adc_registers(power);\r\nif (ret)\r\nreturn ret;\r\nusb_power_desc = &axp20x_usb_power_desc;\r\nirq_names = axp20x_irq_names;\r\n} else if (power->axp20x_id == AXP221_ID ||\r\npower->axp20x_id == AXP223_ID) {\r\nusb_power_desc = &axp22x_usb_power_desc;\r\nirq_names = axp22x_irq_names;\r\n} else {\r\ndev_err(&pdev->dev, "Unsupported AXP variant: %ld\n",\r\naxp20x->variant);\r\nreturn -EINVAL;\r\n}\r\npsy_cfg.of_node = pdev->dev.of_node;\r\npsy_cfg.drv_data = power;\r\npower->supply = devm_power_supply_register(&pdev->dev, usb_power_desc,\r\n&psy_cfg);\r\nif (IS_ERR(power->supply))\r\nreturn PTR_ERR(power->supply);\r\nfor (i = 0; irq_names[i]; i++) {\r\nirq = platform_get_irq_byname(pdev, irq_names[i]);\r\nif (irq < 0) {\r\ndev_warn(&pdev->dev, "No IRQ for %s: %d\n",\r\nirq_names[i], irq);\r\ncontinue;\r\n}\r\nirq = regmap_irq_get_virq(axp20x->regmap_irqc, irq);\r\nret = devm_request_any_context_irq(&pdev->dev, irq,\r\naxp20x_usb_power_irq, 0, DRVNAME, power);\r\nif (ret < 0)\r\ndev_warn(&pdev->dev, "Error requesting %s IRQ: %d\n",\r\nirq_names[i], ret);\r\n}\r\nreturn 0;\r\n}
