static int dvbsky_usb_generic_rw(struct dvb_usb_device *d,\r\nu8 *wbuf, u16 wlen, u8 *rbuf, u16 rlen)\r\n{\r\nint ret;\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nmutex_lock(&d->usb_mutex);\r\nif (wlen != 0)\r\nmemcpy(state->obuf, wbuf, wlen);\r\nret = dvb_usbv2_generic_rw_locked(d, state->obuf, wlen,\r\nstate->ibuf, rlen);\r\nif (!ret && (rlen != 0))\r\nmemcpy(rbuf, state->ibuf, rlen);\r\nmutex_unlock(&d->usb_mutex);\r\nreturn ret;\r\n}\r\nstatic int dvbsky_stream_ctrl(struct dvb_usb_device *d, u8 onoff)\r\n{\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nint ret;\r\nu8 obuf_pre[3] = { 0x37, 0, 0 };\r\nu8 obuf_post[3] = { 0x36, 3, 0 };\r\nmutex_lock(&state->stream_mutex);\r\nret = dvbsky_usb_generic_rw(d, obuf_pre, 3, NULL, 0);\r\nif (!ret && onoff) {\r\nmsleep(20);\r\nret = dvbsky_usb_generic_rw(d, obuf_post, 3, NULL, 0);\r\n}\r\nmutex_unlock(&state->stream_mutex);\r\nreturn ret;\r\n}\r\nstatic int dvbsky_streaming_ctrl(struct dvb_frontend *fe, int onoff)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nreturn dvbsky_stream_ctrl(d, (onoff == 0) ? 0 : 1);\r\n}\r\nstatic int dvbsky_gpio_ctrl(struct dvb_usb_device *d, u8 gport, u8 value)\r\n{\r\nint ret;\r\nu8 obuf[3], ibuf[2];\r\nobuf[0] = 0x0e;\r\nobuf[1] = gport;\r\nobuf[2] = value;\r\nret = dvbsky_usb_generic_rw(d, obuf, 3, ibuf, 1);\r\nif (ret)\r\ndev_err(&d->udev->dev, "failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int dvbsky_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg msg[],\r\nint num)\r\n{\r\nstruct dvb_usb_device *d = i2c_get_adapdata(adap);\r\nint ret = 0;\r\nu8 ibuf[64], obuf[64];\r\nif (mutex_lock_interruptible(&d->i2c_mutex) < 0)\r\nreturn -EAGAIN;\r\nif (num > 2) {\r\ndev_err(&d->udev->dev,\r\n"too many i2c messages[%d], max 2.", num);\r\nret = -EOPNOTSUPP;\r\ngoto i2c_error;\r\n}\r\nif (num == 1) {\r\nif (msg[0].len > 60) {\r\ndev_err(&d->udev->dev,\r\n"too many i2c bytes[%d], max 60.",\r\nmsg[0].len);\r\nret = -EOPNOTSUPP;\r\ngoto i2c_error;\r\n}\r\nif (msg[0].flags & I2C_M_RD) {\r\nobuf[0] = 0x09;\r\nobuf[1] = 0;\r\nobuf[2] = msg[0].len;\r\nobuf[3] = msg[0].addr;\r\nret = dvbsky_usb_generic_rw(d, obuf, 4,\r\nibuf, msg[0].len + 1);\r\nif (ret)\r\ndev_err(&d->udev->dev, "failed=%d\n", ret);\r\nif (!ret)\r\nmemcpy(msg[0].buf, &ibuf[1], msg[0].len);\r\n} else {\r\nobuf[0] = 0x08;\r\nobuf[1] = msg[0].addr;\r\nobuf[2] = msg[0].len;\r\nmemcpy(&obuf[3], msg[0].buf, msg[0].len);\r\nret = dvbsky_usb_generic_rw(d, obuf,\r\nmsg[0].len + 3, ibuf, 1);\r\nif (ret)\r\ndev_err(&d->udev->dev, "failed=%d\n", ret);\r\n}\r\n} else {\r\nif ((msg[0].len > 60) || (msg[1].len > 60)) {\r\ndev_err(&d->udev->dev,\r\n"too many i2c bytes[w-%d][r-%d], max 60.",\r\nmsg[0].len, msg[1].len);\r\nret = -EOPNOTSUPP;\r\ngoto i2c_error;\r\n}\r\nobuf[0] = 0x09;\r\nobuf[1] = msg[0].len;\r\nobuf[2] = msg[1].len;\r\nobuf[3] = msg[0].addr;\r\nmemcpy(&obuf[4], msg[0].buf, msg[0].len);\r\nret = dvbsky_usb_generic_rw(d, obuf,\r\nmsg[0].len + 4, ibuf, msg[1].len + 1);\r\nif (ret)\r\ndev_err(&d->udev->dev, "failed=%d\n", ret);\r\nif (!ret)\r\nmemcpy(msg[1].buf, &ibuf[1], msg[1].len);\r\n}\r\ni2c_error:\r\nmutex_unlock(&d->i2c_mutex);\r\nreturn (ret) ? ret : num;\r\n}\r\nstatic u32 dvbsky_i2c_func(struct i2c_adapter *adapter)\r\n{\r\nreturn I2C_FUNC_I2C;\r\n}\r\nstatic int dvbsky_rc_query(struct dvb_usb_device *d)\r\n{\r\nu32 code = 0xffff, scancode;\r\nu8 rc5_command, rc5_system;\r\nu8 obuf[2], ibuf[2], toggle;\r\nint ret;\r\nobuf[0] = 0x10;\r\nret = dvbsky_usb_generic_rw(d, obuf, 1, ibuf, 2);\r\nif (ret)\r\ndev_err(&d->udev->dev, "failed=%d\n", ret);\r\nif (ret == 0)\r\ncode = (ibuf[0] << 8) | ibuf[1];\r\nif (code != 0xffff) {\r\ndev_dbg(&d->udev->dev, "rc code: %x\n", code);\r\nrc5_command = code & 0x3F;\r\nrc5_system = (code & 0x7C0) >> 6;\r\ntoggle = (code & 0x800) ? 1 : 0;\r\nscancode = rc5_system << 8 | rc5_command;\r\nrc_keydown(d->rc_dev, RC_TYPE_RC5, scancode, toggle);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dvbsky_get_rc_config(struct dvb_usb_device *d, struct dvb_usb_rc *rc)\r\n{\r\nif (dvb_usb_dvbsky_disable_rc) {\r\nrc->map_name = NULL;\r\nreturn 0;\r\n}\r\nrc->allowed_protos = RC_BIT_RC5;\r\nrc->query = dvbsky_rc_query;\r\nrc->interval = 300;\r\nreturn 0;\r\n}\r\nstatic int dvbsky_usb_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nu8 value;\r\nif (voltage == SEC_VOLTAGE_OFF)\r\nvalue = 0;\r\nelse\r\nvalue = 1;\r\ndvbsky_gpio_ctrl(d, 0x80, value);\r\nreturn state->fe_set_voltage(fe, voltage);\r\n}\r\nstatic int dvbsky_read_mac_addr(struct dvb_usb_adapter *adap, u8 mac[6])\r\n{\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nu8 obuf[] = { 0x1e, 0x00 };\r\nu8 ibuf[6] = { 0 };\r\nstruct i2c_msg msg[] = {\r\n{\r\n.addr = 0x51,\r\n.flags = 0,\r\n.buf = obuf,\r\n.len = 2,\r\n}, {\r\n.addr = 0x51,\r\n.flags = I2C_M_RD,\r\n.buf = ibuf,\r\n.len = 6,\r\n}\r\n};\r\nif (i2c_transfer(&d->i2c_adap, msg, 2) == 2)\r\nmemcpy(mac, ibuf, 6);\r\nreturn 0;\r\n}\r\nstatic int dvbsky_usb_read_status(struct dvb_frontend *fe,\r\nenum fe_status *status)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nint ret;\r\nret = state->fe_read_status(fe, status);\r\nif ((*status & FE_HAS_LOCK) && (!state->last_lock))\r\ndvbsky_stream_ctrl(d, 1);\r\nstate->last_lock = (*status & FE_HAS_LOCK) ? 1 : 0;\r\nreturn ret;\r\n}\r\nstatic int dvbsky_s960_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvbsky_state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\nstruct i2c_adapter *i2c_adapter;\r\nstruct i2c_client *client;\r\nstruct i2c_board_info info;\r\nstruct ts2020_config ts2020_config = {};\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nadap->fe[0] = dvb_attach(m88ds3103_attach,\r\n&dvbsky_s960_m88ds3103_config,\r\n&d->i2c_adap,\r\n&i2c_adapter);\r\nif (!adap->fe[0]) {\r\ndev_err(&d->udev->dev, "dvbsky_s960_attach fail.\n");\r\nret = -ENODEV;\r\ngoto fail_attach;\r\n}\r\nts2020_config.fe = adap->fe[0];\r\nts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\r\nstrlcpy(info.type, "ts2020", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &ts2020_config;\r\nrequest_module("ts2020");\r\nclient = i2c_new_device(i2c_adapter, &info);\r\nif (client == NULL || client->dev.driver == NULL) {\r\ndvb_frontend_detach(adap->fe[0]);\r\nret = -ENODEV;\r\ngoto fail_attach;\r\n}\r\nif (!try_module_get(client->dev.driver->owner)) {\r\ni2c_unregister_device(client);\r\ndvb_frontend_detach(adap->fe[0]);\r\nret = -ENODEV;\r\ngoto fail_attach;\r\n}\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nstate->fe_read_status = adap->fe[0]->ops.read_status;\r\nadap->fe[0]->ops.read_status = dvbsky_usb_read_status;\r\nstate->fe_set_voltage = adap->fe[0]->ops.set_voltage;\r\nadap->fe[0]->ops.set_voltage = dvbsky_usb_set_voltage;\r\nstate->i2c_client_tuner = client;\r\nfail_attach:\r\nreturn ret;\r\n}\r\nstatic int dvbsky_usb_ci_set_voltage(struct dvb_frontend *fe,\r\nenum fe_sec_voltage voltage)\r\n{\r\nstruct dvb_usb_device *d = fe_to_d(fe);\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nu8 value;\r\nif (voltage == SEC_VOLTAGE_OFF)\r\nvalue = 0;\r\nelse\r\nvalue = 1;\r\ndvbsky_gpio_ctrl(d, 0x00, value);\r\nreturn state->fe_set_voltage(fe, voltage);\r\n}\r\nstatic int dvbsky_ci_ctrl(void *priv, u8 read, int addr,\r\nu8 data, int *mem)\r\n{\r\nstruct dvb_usb_device *d = priv;\r\nint ret = 0;\r\nu8 command[4], respond[2], command_size, respond_size;\r\ncommand[1] = (u8)((addr >> 8) & 0xff);\r\ncommand[2] = (u8)(addr & 0xff);\r\nif (read) {\r\ncommand[0] = 0x71;\r\ncommand_size = 3;\r\nrespond_size = 2;\r\n} else {\r\ncommand[0] = 0x70;\r\ncommand[3] = data;\r\ncommand_size = 4;\r\nrespond_size = 1;\r\n}\r\nret = dvbsky_usb_generic_rw(d, command, command_size,\r\nrespond, respond_size);\r\nif (ret)\r\ngoto err;\r\nif (read)\r\n*mem = respond[1];\r\nreturn ret;\r\nerr:\r\ndev_err(&d->udev->dev, "ci control failed=%d\n", ret);\r\nreturn ret;\r\n}\r\nstatic int dvbsky_s960c_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvbsky_state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\nstruct i2c_adapter *i2c_adapter;\r\nstruct i2c_client *client_tuner, *client_ci;\r\nstruct i2c_board_info info;\r\nstruct sp2_config sp2_config;\r\nstruct ts2020_config ts2020_config = {};\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nadap->fe[0] = dvb_attach(m88ds3103_attach,\r\n&dvbsky_s960c_m88ds3103_config,\r\n&d->i2c_adap,\r\n&i2c_adapter);\r\nif (!adap->fe[0]) {\r\ndev_err(&d->udev->dev, "dvbsky_s960ci_attach fail.\n");\r\nret = -ENODEV;\r\ngoto fail_attach;\r\n}\r\nts2020_config.fe = adap->fe[0];\r\nts2020_config.get_agc_pwm = m88ds3103_get_agc_pwm;\r\nstrlcpy(info.type, "ts2020", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &ts2020_config;\r\nrequest_module("ts2020");\r\nclient_tuner = i2c_new_device(i2c_adapter, &info);\r\nif (client_tuner == NULL || client_tuner->dev.driver == NULL) {\r\nret = -ENODEV;\r\ngoto fail_tuner_device;\r\n}\r\nif (!try_module_get(client_tuner->dev.driver->owner)) {\r\nret = -ENODEV;\r\ngoto fail_tuner_module;\r\n}\r\nmemset(&sp2_config, 0, sizeof(sp2_config));\r\nsp2_config.dvb_adap = &adap->dvb_adap;\r\nsp2_config.priv = d;\r\nsp2_config.ci_control = dvbsky_ci_ctrl;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "sp2", I2C_NAME_SIZE);\r\ninfo.addr = 0x40;\r\ninfo.platform_data = &sp2_config;\r\nrequest_module("sp2");\r\nclient_ci = i2c_new_device(&d->i2c_adap, &info);\r\nif (client_ci == NULL || client_ci->dev.driver == NULL) {\r\nret = -ENODEV;\r\ngoto fail_ci_device;\r\n}\r\nif (!try_module_get(client_ci->dev.driver->owner)) {\r\nret = -ENODEV;\r\ngoto fail_ci_module;\r\n}\r\nadap->fe[0]->ops.read_signal_strength =\r\nadap->fe[0]->ops.tuner_ops.get_rf_strength;\r\nstate->fe_read_status = adap->fe[0]->ops.read_status;\r\nadap->fe[0]->ops.read_status = dvbsky_usb_read_status;\r\nstate->fe_set_voltage = adap->fe[0]->ops.set_voltage;\r\nadap->fe[0]->ops.set_voltage = dvbsky_usb_ci_set_voltage;\r\nstate->i2c_client_tuner = client_tuner;\r\nstate->i2c_client_ci = client_ci;\r\nreturn ret;\r\nfail_ci_module:\r\ni2c_unregister_device(client_ci);\r\nfail_ci_device:\r\nmodule_put(client_tuner->dev.driver->owner);\r\nfail_tuner_module:\r\ni2c_unregister_device(client_tuner);\r\nfail_tuner_device:\r\ndvb_frontend_detach(adap->fe[0]);\r\nfail_attach:\r\nreturn ret;\r\n}\r\nstatic int dvbsky_t680c_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvbsky_state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\nstruct i2c_adapter *i2c_adapter;\r\nstruct i2c_client *client_demod, *client_tuner, *client_ci;\r\nstruct i2c_board_info info;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\nstruct sp2_config sp2_config;\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &i2c_adapter;\r\nsi2168_config.fe = &adap->fe[0];\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient_demod = i2c_new_device(&d->i2c_adap, &info);\r\nif (client_demod == NULL ||\r\nclient_demod->dev.driver == NULL)\r\ngoto fail_demod_device;\r\nif (!try_module_get(client_demod->dev.driver->owner))\r\ngoto fail_demod_module;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = adap->fe[0];\r\nsi2157_config.if_port = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(i2c_adapter, &info);\r\nif (client_tuner == NULL ||\r\nclient_tuner->dev.driver == NULL)\r\ngoto fail_tuner_device;\r\nif (!try_module_get(client_tuner->dev.driver->owner))\r\ngoto fail_tuner_module;\r\nmemset(&sp2_config, 0, sizeof(sp2_config));\r\nsp2_config.dvb_adap = &adap->dvb_adap;\r\nsp2_config.priv = d;\r\nsp2_config.ci_control = dvbsky_ci_ctrl;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "sp2", I2C_NAME_SIZE);\r\ninfo.addr = 0x40;\r\ninfo.platform_data = &sp2_config;\r\nrequest_module(info.type);\r\nclient_ci = i2c_new_device(&d->i2c_adap, &info);\r\nif (client_ci == NULL || client_ci->dev.driver == NULL)\r\ngoto fail_ci_device;\r\nif (!try_module_get(client_ci->dev.driver->owner))\r\ngoto fail_ci_module;\r\nstate->i2c_client_demod = client_demod;\r\nstate->i2c_client_tuner = client_tuner;\r\nstate->i2c_client_ci = client_ci;\r\nreturn ret;\r\nfail_ci_module:\r\ni2c_unregister_device(client_ci);\r\nfail_ci_device:\r\nmodule_put(client_tuner->dev.driver->owner);\r\nfail_tuner_module:\r\ni2c_unregister_device(client_tuner);\r\nfail_tuner_device:\r\nmodule_put(client_demod->dev.driver->owner);\r\nfail_demod_module:\r\ni2c_unregister_device(client_demod);\r\nfail_demod_device:\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nstatic int dvbsky_t330_attach(struct dvb_usb_adapter *adap)\r\n{\r\nstruct dvbsky_state *state = adap_to_priv(adap);\r\nstruct dvb_usb_device *d = adap_to_d(adap);\r\nint ret = 0;\r\nstruct i2c_adapter *i2c_adapter;\r\nstruct i2c_client *client_demod, *client_tuner;\r\nstruct i2c_board_info info;\r\nstruct si2168_config si2168_config;\r\nstruct si2157_config si2157_config;\r\nmemset(&si2168_config, 0, sizeof(si2168_config));\r\nsi2168_config.i2c_adapter = &i2c_adapter;\r\nsi2168_config.fe = &adap->fe[0];\r\nsi2168_config.ts_mode = SI2168_TS_PARALLEL;\r\nsi2168_config.ts_clock_gapped = true;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2168", I2C_NAME_SIZE);\r\ninfo.addr = 0x64;\r\ninfo.platform_data = &si2168_config;\r\nrequest_module(info.type);\r\nclient_demod = i2c_new_device(&d->i2c_adap, &info);\r\nif (client_demod == NULL ||\r\nclient_demod->dev.driver == NULL)\r\ngoto fail_demod_device;\r\nif (!try_module_get(client_demod->dev.driver->owner))\r\ngoto fail_demod_module;\r\nmemset(&si2157_config, 0, sizeof(si2157_config));\r\nsi2157_config.fe = adap->fe[0];\r\nsi2157_config.if_port = 1;\r\nmemset(&info, 0, sizeof(struct i2c_board_info));\r\nstrlcpy(info.type, "si2157", I2C_NAME_SIZE);\r\ninfo.addr = 0x60;\r\ninfo.platform_data = &si2157_config;\r\nrequest_module(info.type);\r\nclient_tuner = i2c_new_device(i2c_adapter, &info);\r\nif (client_tuner == NULL ||\r\nclient_tuner->dev.driver == NULL)\r\ngoto fail_tuner_device;\r\nif (!try_module_get(client_tuner->dev.driver->owner))\r\ngoto fail_tuner_module;\r\nstate->i2c_client_demod = client_demod;\r\nstate->i2c_client_tuner = client_tuner;\r\nreturn ret;\r\nfail_tuner_module:\r\ni2c_unregister_device(client_tuner);\r\nfail_tuner_device:\r\nmodule_put(client_demod->dev.driver->owner);\r\nfail_demod_module:\r\ni2c_unregister_device(client_demod);\r\nfail_demod_device:\r\nret = -ENODEV;\r\nreturn ret;\r\n}\r\nstatic int dvbsky_identify_state(struct dvb_usb_device *d, const char **name)\r\n{\r\ndvbsky_gpio_ctrl(d, 0x04, 1);\r\nmsleep(20);\r\ndvbsky_gpio_ctrl(d, 0x83, 0);\r\ndvbsky_gpio_ctrl(d, 0xc0, 1);\r\nmsleep(100);\r\ndvbsky_gpio_ctrl(d, 0x83, 1);\r\ndvbsky_gpio_ctrl(d, 0xc0, 0);\r\nmsleep(50);\r\nreturn WARM;\r\n}\r\nstatic int dvbsky_init(struct dvb_usb_device *d)\r\n{\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nmutex_init(&state->stream_mutex);\r\nstate->last_lock = 0;\r\nreturn 0;\r\n}\r\nstatic void dvbsky_exit(struct dvb_usb_device *d)\r\n{\r\nstruct dvbsky_state *state = d_to_priv(d);\r\nstruct i2c_client *client;\r\nclient = state->i2c_client_tuner;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = state->i2c_client_demod;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\nclient = state->i2c_client_ci;\r\nif (client) {\r\nmodule_put(client->dev.driver->owner);\r\ni2c_unregister_device(client);\r\n}\r\n}
