int amdgpu_gfx_scratch_get(struct amdgpu_device *adev, uint32_t *reg)\r\n{\r\nint i;\r\ni = ffs(adev->gfx.scratch.free_mask);\r\nif (i != 0 && i <= adev->gfx.scratch.num_reg) {\r\ni--;\r\nadev->gfx.scratch.free_mask &= ~(1u << i);\r\n*reg = adev->gfx.scratch.reg_base + i;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nvoid amdgpu_gfx_scratch_free(struct amdgpu_device *adev, uint32_t reg)\r\n{\r\nadev->gfx.scratch.free_mask |= 1u << (reg - adev->gfx.scratch.reg_base);\r\n}\r\nvoid amdgpu_gfx_parse_disable_cu(unsigned *mask, unsigned max_se, unsigned max_sh)\r\n{\r\nunsigned se, sh, cu;\r\nconst char *p;\r\nmemset(mask, 0, sizeof(*mask) * max_se * max_sh);\r\nif (!amdgpu_disable_cu || !*amdgpu_disable_cu)\r\nreturn;\r\np = amdgpu_disable_cu;\r\nfor (;;) {\r\nchar *next;\r\nint ret = sscanf(p, "%u.%u.%u", &se, &sh, &cu);\r\nif (ret < 3) {\r\nDRM_ERROR("amdgpu: could not parse disable_cu\n");\r\nreturn;\r\n}\r\nif (se < max_se && sh < max_sh && cu < 16) {\r\nDRM_INFO("amdgpu: disabling CU %u.%u.%u\n", se, sh, cu);\r\nmask[se * max_sh + sh] |= 1u << cu;\r\n} else {\r\nDRM_ERROR("amdgpu: disable_cu %u.%u.%u is out of range\n",\r\nse, sh, cu);\r\n}\r\nnext = strchr(p, ',');\r\nif (!next)\r\nbreak;\r\np = next + 1;\r\n}\r\n}
