static u64 notrace ep93xx_read_sched_clock(void)\r\n{\r\nu64 ret;\r\nret = readl(EP93XX_TIMER4_VALUE_LOW);\r\nret |= ((u64) (readl(EP93XX_TIMER4_VALUE_HIGH) & 0xff) << 32);\r\nreturn ret;\r\n}\r\nu64 ep93xx_clocksource_read(struct clocksource *c)\r\n{\r\nu64 ret;\r\nret = readl(EP93XX_TIMER4_VALUE_LOW);\r\nret |= ((u64) (readl(EP93XX_TIMER4_VALUE_HIGH) & 0xff) << 32);\r\nreturn (u64) ret;\r\n}\r\nstatic int ep93xx_clkevt_set_next_event(unsigned long next,\r\nstruct clock_event_device *evt)\r\n{\r\nu32 tmode = EP93XX_TIMER123_CONTROL_MODE |\r\nEP93XX_TIMER123_CONTROL_CLKSEL;\r\nwritel(tmode, EP93XX_TIMER3_CONTROL);\r\nwritel(next, EP93XX_TIMER3_LOAD);\r\nwritel(tmode | EP93XX_TIMER123_CONTROL_ENABLE,\r\nEP93XX_TIMER3_CONTROL);\r\nreturn 0;\r\n}\r\nstatic int ep93xx_clkevt_shutdown(struct clock_event_device *evt)\r\n{\r\nwritel(0, EP93XX_TIMER3_CONTROL);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t ep93xx_timer_interrupt(int irq, void *dev_id)\r\n{\r\nstruct clock_event_device *evt = dev_id;\r\nwritel(1, EP93XX_TIMER3_CLEAR);\r\nevt->event_handler(evt);\r\nreturn IRQ_HANDLED;\r\n}\r\nvoid __init ep93xx_timer_init(void)\r\n{\r\nwritel(EP93XX_TIMER4_VALUE_HIGH_ENABLE,\r\nEP93XX_TIMER4_VALUE_HIGH);\r\nclocksource_mmio_init(NULL, "timer4",\r\nEP93XX_TIMER4_RATE, 200, 40,\r\nep93xx_clocksource_read);\r\nsched_clock_register(ep93xx_read_sched_clock, 40,\r\nEP93XX_TIMER4_RATE);\r\nsetup_irq(IRQ_EP93XX_TIMER3, &ep93xx_timer_irq);\r\nclockevents_config_and_register(&ep93xx_clockevent,\r\nEP93XX_TIMER123_RATE,\r\n1,\r\n0xffffffffU);\r\n}
