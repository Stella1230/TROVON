void cfm_init(struct s_smc *smc)\r\n{\r\nsmc->mib.fddiSMTCF_State = ACTIONS(SC0_ISOLATED) ;\r\nsmc->r.rm_join = 0 ;\r\nsmc->r.rm_loop = 0 ;\r\nsmc->y[PA].scrub = 0 ;\r\nsmc->y[PB].scrub = 0 ;\r\nsmc->y[PA].cem_pst = CEM_PST_DOWN ;\r\nsmc->y[PB].cem_pst = CEM_PST_DOWN ;\r\n}\r\nstatic void selection_criteria (struct s_smc *smc, struct s_phy *phy)\r\n{\r\nswitch (phy->mib->fddiPORTMy_Type) {\r\ncase TA:\r\nif ( !THRU_ENABLED(smc) && smc->y[PB].cf_join ) {\r\nphy->wc_flag = TRUE ;\r\n} else {\r\nphy->wc_flag = FALSE ;\r\n}\r\nbreak;\r\ncase TB:\r\nphy->wc_flag = FALSE ;\r\nbreak;\r\ncase TS:\r\nphy->wc_flag = FALSE ;\r\nbreak;\r\ncase TM:\r\nphy->wc_flag = FALSE ;\r\nbreak;\r\n}\r\n}\r\nvoid all_selection_criteria(struct s_smc *smc)\r\n{\r\nstruct s_phy *phy ;\r\nint p ;\r\nfor ( p = 0,phy = smc->y ; p < NUMPHYS; p++, phy++ ) {\r\nselection_criteria (smc,phy);\r\n}\r\n}\r\nstatic void cem_priv_state(struct s_smc *smc, int event)\r\n{\r\nint np;\r\nint i;\r\nif (smc->s.sas != SMT_DAS )\r\nreturn ;\r\nnp = event - CF_JOIN;\r\nif (np != PA && np != PB) {\r\nreturn ;\r\n}\r\nif (smc->y[np].cf_join) {\r\nsmc->y[np].cem_pst = CEM_PST_UP ;\r\n} else if (!smc->y[np].wc_flag) {\r\nsmc->y[np].cem_pst = CEM_PST_DOWN ;\r\n}\r\nfor (i = 0 ; i < 2 ; i ++ ) {\r\nif ( smc->y[i].cem_pst == CEM_PST_HOLD && !smc->y[i].wc_flag ) {\r\nsmc->y[i].cem_pst = CEM_PST_DOWN;\r\nqueue_event(smc,(int)(EVENT_PCM+i),PC_START) ;\r\n}\r\nif ( smc->y[i].cem_pst == CEM_PST_UP && smc->y[i].wc_flag ) {\r\nsmc->y[i].cem_pst = CEM_PST_HOLD;\r\nqueue_event(smc,(int)(EVENT_PCM+i),PC_START) ;\r\n}\r\nif ( smc->y[i].cem_pst == CEM_PST_DOWN && smc->y[i].wc_flag ) {\r\nsmc->y[i].cem_pst = CEM_PST_HOLD;\r\n}\r\n}\r\nreturn ;\r\n}\r\nvoid cfm(struct s_smc *smc, int event)\r\n{\r\nint state ;\r\nint cond ;\r\nint oldstate ;\r\nall_selection_criteria (smc);\r\ncem_priv_state (smc, event);\r\noldstate = smc->mib.fddiSMTCF_State ;\r\ndo {\r\nDB_CFM("CFM : state %s%s event %s",\r\nsmc->mib.fddiSMTCF_State & AFLAG ? "ACTIONS " : "",\r\ncfm_states[smc->mib.fddiSMTCF_State & ~AFLAG],\r\ncfm_events[event]);\r\nstate = smc->mib.fddiSMTCF_State ;\r\ncfm_fsm(smc,event) ;\r\nevent = 0 ;\r\n} while (state != smc->mib.fddiSMTCF_State) ;\r\n#ifndef SLIM_SMT\r\ncond = FALSE ;\r\nif ( (smc->mib.fddiSMTCF_State == SC9_C_WRAP_A &&\r\nsmc->y[PA].pc_mode == PM_PEER) ||\r\n(smc->mib.fddiSMTCF_State == SC10_C_WRAP_B &&\r\nsmc->y[PB].pc_mode == PM_PEER) ||\r\n(smc->mib.fddiSMTCF_State == SC11_C_WRAP_S &&\r\nsmc->y[PS].pc_mode == PM_PEER &&\r\nsmc->y[PS].mib->fddiPORTNeighborType != TS ) ) {\r\ncond = TRUE ;\r\n}\r\nif (cond != smc->mib.fddiSMTPeerWrapFlag)\r\nsmt_srf_event(smc,SMT_COND_SMT_PEER_WRAP,0,cond) ;\r\n#if 0\r\nif (smc->mib.fddiSMTCF_State != oldstate) {\r\nsmt_srf_event(smc,SMT_EVENT_MAC_PATH_CHANGE,INDEX_MAC,0) ;\r\n}\r\n#endif\r\n#endif\r\nsmc->mib.m[MAC0].fddiMACDownstreamPORTType =\r\ncf_to_ptype[smc->mib.fddiSMTCF_State] ;\r\ncfm_state_change(smc,(int)smc->mib.fddiSMTCF_State) ;\r\n}\r\nstatic void cfm_fsm(struct s_smc *smc, int cmd)\r\n{\r\nswitch(smc->mib.fddiSMTCF_State) {\r\ncase ACTIONS(SC0_ISOLATED) :\r\nsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\r\nsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\r\nsmc->mib.p[PA].fddiPORTMACPlacement = 0 ;\r\nsmc->mib.p[PB].fddiPORTMACPlacement = 0 ;\r\nsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_SEPA ;\r\nconfig_mux(smc,MUX_ISOLATE) ;\r\nsmc->r.rm_loop = FALSE ;\r\nsmc->r.rm_join = FALSE ;\r\nqueue_event(smc,EVENT_RMT,RM_JOIN) ;\r\nACTIONS_DONE() ;\r\nDB_CFMN(1, "CFM : %s", cfm_states[smc->mib.fddiSMTCF_State]);\r\nbreak;\r\ncase SC0_ISOLATED :\r\nif (smc->s.sas && (smc->y[PA].cf_join || smc->y[PA].cf_loop ||\r\nsmc->y[PB].cf_join || smc->y[PB].cf_loop)) {\r\nGO_STATE(SC11_C_WRAP_S) ;\r\nbreak ;\r\n}\r\nif ((smc->y[PA].cem_pst == CEM_PST_UP && smc->y[PA].cf_join &&\r\n!smc->y[PA].wc_flag) || smc->y[PA].cf_loop) {\r\nGO_STATE(SC9_C_WRAP_A) ;\r\nbreak ;\r\n}\r\nif ((smc->y[PB].cem_pst == CEM_PST_UP && smc->y[PB].cf_join &&\r\n!smc->y[PB].wc_flag) || smc->y[PB].cf_loop) {\r\nGO_STATE(SC10_C_WRAP_B) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(SC9_C_WRAP_A) :\r\nsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_CONCATENATED ;\r\nsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\r\nsmc->mib.p[PA].fddiPORTMACPlacement = INDEX_MAC ;\r\nsmc->mib.p[PB].fddiPORTMACPlacement = 0 ;\r\nsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_CON ;\r\nconfig_mux(smc,MUX_WRAPA) ;\r\nif (smc->y[PA].cf_loop) {\r\nsmc->r.rm_join = FALSE ;\r\nsmc->r.rm_loop = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_LOOP) ;\r\n}\r\nif (smc->y[PA].cf_join) {\r\nsmc->r.rm_loop = FALSE ;\r\nsmc->r.rm_join = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_JOIN) ;\r\n}\r\nACTIONS_DONE() ;\r\nDB_CFMN(1, "CFM : %s", cfm_states[smc->mib.fddiSMTCF_State]);\r\nbreak ;\r\ncase SC9_C_WRAP_A :\r\nif ( (smc->y[PA].wc_flag || !smc->y[PA].cf_join) &&\r\n!smc->y[PA].cf_loop ) {\r\nGO_STATE(SC0_ISOLATED) ;\r\nbreak ;\r\n}\r\nelse if ( (smc->y[PB].cf_loop && smc->y[PA].cf_join &&\r\nsmc->y[PA].cem_pst == CEM_PST_UP) ||\r\n((smc->y[PB].cf_loop ||\r\n(smc->y[PB].cf_join &&\r\nsmc->y[PB].cem_pst == CEM_PST_UP)) &&\r\n(smc->y[PA].pc_mode == PM_TREE ||\r\nsmc->y[PB].pc_mode == PM_TREE))) {\r\nsmc->y[PA].scrub = TRUE ;\r\nGO_STATE(SC10_C_WRAP_B) ;\r\nbreak ;\r\n}\r\nelse if (!smc->s.attach_s &&\r\nsmc->y[PA].cf_join &&\r\nsmc->y[PA].cem_pst == CEM_PST_UP &&\r\nsmc->y[PA].pc_mode == PM_PEER && smc->y[PB].cf_join &&\r\nsmc->y[PB].cem_pst == CEM_PST_UP &&\r\nsmc->y[PB].pc_mode == PM_PEER) {\r\nsmc->y[PA].scrub = TRUE ;\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC4_THRU_A) ;\r\nbreak ;\r\n}\r\nelse if ( smc->s.attach_s &&\r\nsmc->y[PA].cf_join &&\r\nsmc->y[PA].cem_pst == CEM_PST_UP &&\r\nsmc->y[PA].pc_mode == PM_PEER &&\r\nsmc->y[PB].cf_join &&\r\nsmc->y[PB].cem_pst == CEM_PST_UP &&\r\nsmc->y[PB].pc_mode == PM_PEER) {\r\nsmc->y[PA].scrub = TRUE ;\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC5_THRU_B) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(SC10_C_WRAP_B) :\r\nsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_ISOLATED ;\r\nsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_CONCATENATED ;\r\nsmc->mib.p[PA].fddiPORTMACPlacement = 0 ;\r\nsmc->mib.p[PB].fddiPORTMACPlacement = INDEX_MAC ;\r\nsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_CON ;\r\nconfig_mux(smc,MUX_WRAPB) ;\r\nif (smc->y[PB].cf_loop) {\r\nsmc->r.rm_join = FALSE ;\r\nsmc->r.rm_loop = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_LOOP) ;\r\n}\r\nif (smc->y[PB].cf_join) {\r\nsmc->r.rm_loop = FALSE ;\r\nsmc->r.rm_join = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_JOIN) ;\r\n}\r\nACTIONS_DONE() ;\r\nDB_CFMN(1, "CFM : %s", cfm_states[smc->mib.fddiSMTCF_State]);\r\nbreak ;\r\ncase SC10_C_WRAP_B :\r\nif ( !smc->y[PB].cf_join && !smc->y[PB].cf_loop ) {\r\nGO_STATE(SC0_ISOLATED) ;\r\nbreak ;\r\n}\r\nelse if ( smc->y[PA].cf_loop && smc->y[PA].pc_mode == PM_PEER &&\r\nsmc->y[PB].cf_join && smc->y[PB].pc_mode == PM_PEER) {\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC9_C_WRAP_A) ;\r\nbreak ;\r\n}\r\nelse if (!smc->s.attach_s &&\r\nsmc->y[PA].cf_join && smc->y[PA].pc_mode == PM_PEER &&\r\nsmc->y[PB].cf_join && smc->y[PB].pc_mode == PM_PEER) {\r\nsmc->y[PA].scrub = TRUE ;\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC4_THRU_A) ;\r\nbreak ;\r\n}\r\nelse if ( smc->s.attach_s &&\r\nsmc->y[PA].cf_join && smc->y[PA].pc_mode == PM_PEER &&\r\nsmc->y[PB].cf_join && smc->y[PB].pc_mode == PM_PEER) {\r\nsmc->y[PA].scrub = TRUE ;\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC5_THRU_B) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(SC4_THRU_A) :\r\nsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_THRU ;\r\nsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_THRU ;\r\nsmc->mib.p[PA].fddiPORTMACPlacement = 0 ;\r\nsmc->mib.p[PB].fddiPORTMACPlacement = INDEX_MAC ;\r\nsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_THRU ;\r\nconfig_mux(smc,MUX_THRUA) ;\r\nsmc->r.rm_loop = FALSE ;\r\nsmc->r.rm_join = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_JOIN) ;\r\nACTIONS_DONE() ;\r\nDB_CFMN(1, "CFM : %s", cfm_states[smc->mib.fddiSMTCF_State]);\r\nbreak ;\r\ncase SC4_THRU_A :\r\nif (smc->y[PB].wc_flag || !smc->y[PB].cf_join) {\r\nsmc->y[PA].scrub = TRUE ;\r\nGO_STATE(SC9_C_WRAP_A) ;\r\nbreak ;\r\n}\r\nelse if (!smc->y[PA].cf_join || smc->y[PA].wc_flag) {\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC10_C_WRAP_B) ;\r\nbreak ;\r\n}\r\nelse if (smc->s.attach_s) {\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC5_THRU_B) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(SC5_THRU_B) :\r\nsmc->mib.p[PA].fddiPORTCurrentPath = MIB_PATH_THRU ;\r\nsmc->mib.p[PB].fddiPORTCurrentPath = MIB_PATH_THRU ;\r\nsmc->mib.p[PA].fddiPORTMACPlacement = INDEX_MAC ;\r\nsmc->mib.p[PB].fddiPORTMACPlacement = 0 ;\r\nsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_THRU ;\r\nconfig_mux(smc,MUX_THRUB) ;\r\nsmc->r.rm_loop = FALSE ;\r\nsmc->r.rm_join = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_JOIN) ;\r\nACTIONS_DONE() ;\r\nDB_CFMN(1, "CFM : %s", cfm_states[smc->mib.fddiSMTCF_State]);\r\nbreak ;\r\ncase SC5_THRU_B :\r\nif (!smc->y[PB].cf_join || smc->y[PB].wc_flag) {\r\nsmc->y[PA].scrub = TRUE ;\r\nGO_STATE(SC9_C_WRAP_A) ;\r\nbreak ;\r\n}\r\nelse if (!smc->y[PA].cf_join || smc->y[PA].wc_flag) {\r\nsmc->y[PB].scrub = TRUE ;\r\nGO_STATE(SC10_C_WRAP_B) ;\r\nbreak ;\r\n}\r\nelse if (!smc->s.attach_s) {\r\nsmc->y[PA].scrub = TRUE ;\r\nGO_STATE(SC4_THRU_A) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ncase ACTIONS(SC11_C_WRAP_S) :\r\nsmc->mib.p[PS].fddiPORTCurrentPath = MIB_PATH_CONCATENATED ;\r\nsmc->mib.p[PS].fddiPORTMACPlacement = INDEX_MAC ;\r\nsmc->mib.fddiSMTStationStatus = MIB_SMT_STASTA_CON ;\r\nconfig_mux(smc,MUX_WRAPS) ;\r\nif (smc->y[PA].cf_loop || smc->y[PB].cf_loop) {\r\nsmc->r.rm_join = FALSE ;\r\nsmc->r.rm_loop = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_LOOP) ;\r\n}\r\nif (smc->y[PA].cf_join || smc->y[PB].cf_join) {\r\nsmc->r.rm_loop = FALSE ;\r\nsmc->r.rm_join = TRUE ;\r\nqueue_event(smc,EVENT_RMT,RM_JOIN) ;\r\n}\r\nACTIONS_DONE() ;\r\nDB_CFMN(1, "CFM : %s", cfm_states[smc->mib.fddiSMTCF_State]);\r\nbreak ;\r\ncase SC11_C_WRAP_S :\r\nif ( !smc->y[PA].cf_join && !smc->y[PA].cf_loop &&\r\n!smc->y[PB].cf_join && !smc->y[PB].cf_loop) {\r\nGO_STATE(SC0_ISOLATED) ;\r\nbreak ;\r\n}\r\nbreak ;\r\ndefault:\r\nSMT_PANIC(smc,SMT_E0106, SMT_E0106_MSG) ;\r\nbreak;\r\n}\r\n}\r\nint cfm_get_mac_input(struct s_smc *smc)\r\n{\r\nreturn (smc->mib.fddiSMTCF_State == SC10_C_WRAP_B ||\r\nsmc->mib.fddiSMTCF_State == SC5_THRU_B) ? PB : PA;\r\n}\r\nint cfm_get_mac_output(struct s_smc *smc)\r\n{\r\nreturn (smc->mib.fddiSMTCF_State == SC10_C_WRAP_B ||\r\nsmc->mib.fddiSMTCF_State == SC4_THRU_A) ? PB : PA;\r\n}\r\nint cem_build_path(struct s_smc *smc, char *to, int path_index)\r\n{\r\nchar *path ;\r\nint len ;\r\nswitch (smc->mib.fddiSMTCF_State) {\r\ndefault :\r\ncase SC0_ISOLATED :\r\npath = smc->s.sas ? path_iso_s : path_iso ;\r\nlen = smc->s.sas ? sizeof(path_iso_s) : sizeof(path_iso) ;\r\nbreak ;\r\ncase SC9_C_WRAP_A :\r\npath = path_wrap_a ;\r\nlen = sizeof(path_wrap_a) ;\r\nbreak ;\r\ncase SC10_C_WRAP_B :\r\npath = path_wrap_b ;\r\nlen = sizeof(path_wrap_b) ;\r\nbreak ;\r\ncase SC4_THRU_A :\r\npath = path_thru ;\r\nlen = sizeof(path_thru) ;\r\nbreak ;\r\ncase SC11_C_WRAP_S :\r\npath = path_wrap_s ;\r\nlen = sizeof(path_wrap_s) ;\r\nbreak ;\r\n}\r\nmemcpy(to,path,len) ;\r\nLINT_USE(path_index);\r\nreturn len;\r\n}
