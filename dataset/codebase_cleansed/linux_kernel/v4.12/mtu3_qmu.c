static struct qmu_gpd *gpd_dma_to_virt(struct mtu3_gpd_ring *ring,\r\ndma_addr_t dma_addr)\r\n{\r\ndma_addr_t dma_base = ring->dma;\r\nstruct qmu_gpd *gpd_head = ring->start;\r\nu32 offset = (dma_addr - dma_base) / sizeof(*gpd_head);\r\nif (offset >= MAX_GPD_NUM)\r\nreturn NULL;\r\nreturn gpd_head + offset;\r\n}\r\nstatic dma_addr_t gpd_virt_to_dma(struct mtu3_gpd_ring *ring,\r\nstruct qmu_gpd *gpd)\r\n{\r\ndma_addr_t dma_base = ring->dma;\r\nstruct qmu_gpd *gpd_head = ring->start;\r\nu32 offset;\r\noffset = gpd - gpd_head;\r\nif (offset >= MAX_GPD_NUM)\r\nreturn 0;\r\nreturn dma_base + (offset * sizeof(*gpd));\r\n}\r\nstatic void gpd_ring_init(struct mtu3_gpd_ring *ring, struct qmu_gpd *gpd)\r\n{\r\nring->start = gpd;\r\nring->enqueue = gpd;\r\nring->dequeue = gpd;\r\nring->end = gpd + MAX_GPD_NUM - 1;\r\n}\r\nstatic void reset_gpd_list(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nstruct qmu_gpd *gpd = ring->start;\r\nif (gpd) {\r\ngpd->flag &= ~GPD_FLAGS_HWO;\r\ngpd_ring_init(ring, gpd);\r\n}\r\n}\r\nint mtu3_gpd_ring_alloc(struct mtu3_ep *mep)\r\n{\r\nstruct qmu_gpd *gpd;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\ngpd = dma_pool_zalloc(mep->mtu->qmu_gpd_pool, GFP_ATOMIC, &ring->dma);\r\nif (gpd == NULL)\r\nreturn -ENOMEM;\r\ngpd_ring_init(ring, gpd);\r\nreturn 0;\r\n}\r\nvoid mtu3_gpd_ring_free(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\ndma_pool_free(mep->mtu->qmu_gpd_pool,\r\nring->start, ring->dma);\r\nmemset(ring, 0, sizeof(*ring));\r\n}\r\nstatic noinline u8 qmu_calc_checksum(u8 *data)\r\n{\r\nu8 chksum = 0;\r\nint i;\r\ndata[1] = 0x0;\r\nmb();\r\nfor (i = 0; i < QMU_CHECKSUM_LEN; i++)\r\nchksum += data[i];\r\nchksum += 1;\r\nreturn 0xFF - chksum;\r\n}\r\nvoid mtu3_qmu_resume(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3 *mtu = mep->mtu;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint epnum = mep->epnum;\r\nu32 offset;\r\noffset = mep->is_in ? USB_QMU_TQCSR(epnum) : USB_QMU_RQCSR(epnum);\r\nmtu3_writel(mbase, offset, QMU_Q_RESUME);\r\nif (!(mtu3_readl(mbase, offset) & QMU_Q_ACTIVE))\r\nmtu3_writel(mbase, offset, QMU_Q_RESUME);\r\n}\r\nstatic struct qmu_gpd *advance_enq_gpd(struct mtu3_gpd_ring *ring)\r\n{\r\nif (ring->enqueue < ring->end)\r\nring->enqueue++;\r\nelse\r\nring->enqueue = ring->start;\r\nreturn ring->enqueue;\r\n}\r\nstatic struct qmu_gpd *advance_deq_gpd(struct mtu3_gpd_ring *ring)\r\n{\r\nif (ring->dequeue < ring->end)\r\nring->dequeue++;\r\nelse\r\nring->dequeue = ring->start;\r\nreturn ring->dequeue;\r\n}\r\nstatic int gpd_ring_empty(struct mtu3_gpd_ring *ring)\r\n{\r\nstruct qmu_gpd *enq = ring->enqueue;\r\nstruct qmu_gpd *next;\r\nif (ring->enqueue < ring->end)\r\nnext = enq + 1;\r\nelse\r\nnext = ring->start;\r\nreturn next == ring->dequeue;\r\n}\r\nint mtu3_prepare_transfer(struct mtu3_ep *mep)\r\n{\r\nreturn gpd_ring_empty(&mep->gpd_ring);\r\n}\r\nstatic int mtu3_prepare_tx_gpd(struct mtu3_ep *mep, struct mtu3_request *mreq)\r\n{\r\nstruct qmu_gpd *enq;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nstruct qmu_gpd *gpd = ring->enqueue;\r\nstruct usb_request *req = &mreq->request;\r\nmemset(gpd, 0, sizeof(*gpd));\r\ngpd->buffer = cpu_to_le32((u32)req->dma);\r\ngpd->buf_len = cpu_to_le16(req->length);\r\ngpd->flag |= GPD_FLAGS_IOC;\r\nenq = advance_enq_gpd(ring);\r\ndev_dbg(mep->mtu->dev, "TX-EP%d queue gpd=%p, enq=%p\n",\r\nmep->epnum, gpd, enq);\r\nenq->flag &= ~GPD_FLAGS_HWO;\r\ngpd->next_gpd = cpu_to_le32((u32)gpd_virt_to_dma(ring, enq));\r\nif (req->zero)\r\ngpd->ext_flag |= GPD_EXT_FLAG_ZLP;\r\ngpd->chksum = qmu_calc_checksum((u8 *)gpd);\r\ngpd->flag |= GPD_FLAGS_HWO;\r\nmreq->gpd = gpd;\r\nreturn 0;\r\n}\r\nstatic int mtu3_prepare_rx_gpd(struct mtu3_ep *mep, struct mtu3_request *mreq)\r\n{\r\nstruct qmu_gpd *enq;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nstruct qmu_gpd *gpd = ring->enqueue;\r\nstruct usb_request *req = &mreq->request;\r\nmemset(gpd, 0, sizeof(*gpd));\r\ngpd->buffer = cpu_to_le32((u32)req->dma);\r\ngpd->data_buf_len = cpu_to_le16(req->length);\r\ngpd->flag |= GPD_FLAGS_IOC;\r\nenq = advance_enq_gpd(ring);\r\ndev_dbg(mep->mtu->dev, "RX-EP%d queue gpd=%p, enq=%p\n",\r\nmep->epnum, gpd, enq);\r\nenq->flag &= ~GPD_FLAGS_HWO;\r\ngpd->next_gpd = cpu_to_le32((u32)gpd_virt_to_dma(ring, enq));\r\ngpd->chksum = qmu_calc_checksum((u8 *)gpd);\r\ngpd->flag |= GPD_FLAGS_HWO;\r\nmreq->gpd = gpd;\r\nreturn 0;\r\n}\r\nvoid mtu3_insert_gpd(struct mtu3_ep *mep, struct mtu3_request *mreq)\r\n{\r\nif (mep->is_in)\r\nmtu3_prepare_tx_gpd(mep, mreq);\r\nelse\r\nmtu3_prepare_rx_gpd(mep, mreq);\r\n}\r\nint mtu3_qmu_start(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3 *mtu = mep->mtu;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nu8 epnum = mep->epnum;\r\nif (mep->is_in) {\r\nmtu3_writel(mbase, USB_QMU_TQSAR(mep->epnum), ring->dma);\r\nmtu3_setbits(mbase, MU3D_EP_TXCR0(mep->epnum), TX_DMAREQEN);\r\nmtu3_setbits(mbase, U3D_QCR0, QMU_TX_CS_EN(epnum));\r\nmtu3_setbits(mbase, U3D_QCR1, QMU_TX_ZLP(epnum));\r\nmtu3_writel(mbase, U3D_TQERRIESR0,\r\nQMU_TX_LEN_ERR(epnum) | QMU_TX_CS_ERR(epnum));\r\nif (mtu3_readl(mbase, USB_QMU_TQCSR(epnum)) & QMU_Q_ACTIVE) {\r\ndev_warn(mtu->dev, "Tx %d Active Now!\n", epnum);\r\nreturn 0;\r\n}\r\nmtu3_writel(mbase, USB_QMU_TQCSR(epnum), QMU_Q_START);\r\n} else {\r\nmtu3_writel(mbase, USB_QMU_RQSAR(mep->epnum), ring->dma);\r\nmtu3_setbits(mbase, MU3D_EP_RXCR0(mep->epnum), RX_DMAREQEN);\r\nmtu3_setbits(mbase, U3D_QCR0, QMU_RX_CS_EN(epnum));\r\nmtu3_clrbits(mbase, U3D_QCR3, QMU_RX_ZLP(epnum));\r\nmtu3_setbits(mbase, U3D_QCR3, QMU_RX_COZ(epnum));\r\nmtu3_writel(mbase, U3D_RQERRIESR0,\r\nQMU_RX_LEN_ERR(epnum) | QMU_RX_CS_ERR(epnum));\r\nmtu3_writel(mbase, U3D_RQERRIESR1, QMU_RX_ZLP_ERR(epnum));\r\nif (mtu3_readl(mbase, USB_QMU_RQCSR(epnum)) & QMU_Q_ACTIVE) {\r\ndev_warn(mtu->dev, "Rx %d Active Now!\n", epnum);\r\nreturn 0;\r\n}\r\nmtu3_writel(mbase, USB_QMU_RQCSR(epnum), QMU_Q_START);\r\n}\r\nreturn 0;\r\n}\r\nvoid mtu3_qmu_stop(struct mtu3_ep *mep)\r\n{\r\nstruct mtu3 *mtu = mep->mtu;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nint epnum = mep->epnum;\r\nu32 value = 0;\r\nu32 qcsr;\r\nint ret;\r\nqcsr = mep->is_in ? USB_QMU_TQCSR(epnum) : USB_QMU_RQCSR(epnum);\r\nif (!(mtu3_readl(mbase, qcsr) & QMU_Q_ACTIVE)) {\r\ndev_dbg(mtu->dev, "%s's qmu is inactive now!\n", mep->name);\r\nreturn;\r\n}\r\nmtu3_writel(mbase, qcsr, QMU_Q_STOP);\r\nret = readl_poll_timeout_atomic(mbase + qcsr, value,\r\n!(value & QMU_Q_ACTIVE), 1, 1000);\r\nif (ret) {\r\ndev_err(mtu->dev, "stop %s's qmu failed\n", mep->name);\r\nreturn;\r\n}\r\ndev_dbg(mtu->dev, "%s's qmu stop now!\n", mep->name);\r\n}\r\nvoid mtu3_qmu_flush(struct mtu3_ep *mep)\r\n{\r\ndev_dbg(mep->mtu->dev, "%s flush QMU %s\n", __func__,\r\n((mep->is_in) ? "TX" : "RX"));\r\nmtu3_qmu_stop(mep);\r\nreset_gpd_list(mep);\r\n}\r\nstatic void qmu_tx_zlp_error_handler(struct mtu3 *mtu, u8 epnum)\r\n{\r\nstruct mtu3_ep *mep = mtu->in_eps + epnum;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nstruct qmu_gpd *gpd_current = NULL;\r\ndma_addr_t gpd_dma = mtu3_readl(mbase, USB_QMU_TQCPR(epnum));\r\nstruct usb_request *req = NULL;\r\nstruct mtu3_request *mreq;\r\nu32 txcsr = 0;\r\nint ret;\r\nmreq = next_request(mep);\r\nif (mreq && mreq->request.length == 0)\r\nreq = &mreq->request;\r\nelse\r\nreturn;\r\ngpd_current = gpd_dma_to_virt(ring, gpd_dma);\r\nif (le16_to_cpu(gpd_current->buf_len) != 0) {\r\ndev_err(mtu->dev, "TX EP%d buffer length error(!=0)\n", epnum);\r\nreturn;\r\n}\r\ndev_dbg(mtu->dev, "%s send ZLP for req=%p\n", __func__, mreq);\r\nmtu3_clrbits(mbase, MU3D_EP_TXCR0(mep->epnum), TX_DMAREQEN);\r\nret = readl_poll_timeout_atomic(mbase + MU3D_EP_TXCR0(mep->epnum),\r\ntxcsr, !(txcsr & TX_FIFOFULL), 1, 1000);\r\nif (ret) {\r\ndev_err(mtu->dev, "%s wait for fifo empty fail\n", __func__);\r\nreturn;\r\n}\r\nmtu3_setbits(mbase, MU3D_EP_TXCR0(mep->epnum), TX_TXPKTRDY);\r\ngpd_current->flag |= GPD_FLAGS_BPS;\r\ngpd_current->chksum = qmu_calc_checksum((u8 *)gpd_current);\r\ngpd_current->flag |= GPD_FLAGS_HWO;\r\nmtu3_setbits(mbase, MU3D_EP_TXCR0(mep->epnum), TX_DMAREQEN);\r\nmtu3_qmu_resume(mep);\r\n}\r\nstatic void qmu_done_tx(struct mtu3 *mtu, u8 epnum)\r\n{\r\nstruct mtu3_ep *mep = mtu->in_eps + epnum;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nstruct qmu_gpd *gpd = ring->dequeue;\r\nstruct qmu_gpd *gpd_current = NULL;\r\ndma_addr_t gpd_dma = mtu3_readl(mbase, USB_QMU_TQCPR(epnum));\r\nstruct usb_request *request = NULL;\r\nstruct mtu3_request *mreq;\r\ngpd_current = gpd_dma_to_virt(ring, gpd_dma);\r\ndev_dbg(mtu->dev, "%s EP%d, last=%p, current=%p, enq=%p\n",\r\n__func__, epnum, gpd, gpd_current, ring->enqueue);\r\nwhile (gpd != gpd_current && !(gpd->flag & GPD_FLAGS_HWO)) {\r\nmreq = next_request(mep);\r\nif (mreq == NULL || mreq->gpd != gpd) {\r\ndev_err(mtu->dev, "no correct TX req is found\n");\r\nbreak;\r\n}\r\nrequest = &mreq->request;\r\nrequest->actual = le16_to_cpu(gpd->buf_len);\r\nmtu3_req_complete(mep, request, 0);\r\ngpd = advance_deq_gpd(ring);\r\n}\r\ndev_dbg(mtu->dev, "%s EP%d, deq=%p, enq=%p, complete\n",\r\n__func__, epnum, ring->dequeue, ring->enqueue);\r\n}\r\nstatic void qmu_done_rx(struct mtu3 *mtu, u8 epnum)\r\n{\r\nstruct mtu3_ep *mep = mtu->out_eps + epnum;\r\nstruct mtu3_gpd_ring *ring = &mep->gpd_ring;\r\nvoid __iomem *mbase = mtu->mac_base;\r\nstruct qmu_gpd *gpd = ring->dequeue;\r\nstruct qmu_gpd *gpd_current = NULL;\r\ndma_addr_t gpd_dma = mtu3_readl(mbase, USB_QMU_RQCPR(epnum));\r\nstruct usb_request *req = NULL;\r\nstruct mtu3_request *mreq;\r\ngpd_current = gpd_dma_to_virt(ring, gpd_dma);\r\ndev_dbg(mtu->dev, "%s EP%d, last=%p, current=%p, enq=%p\n",\r\n__func__, epnum, gpd, gpd_current, ring->enqueue);\r\nwhile (gpd != gpd_current && !(gpd->flag & GPD_FLAGS_HWO)) {\r\nmreq = next_request(mep);\r\nif (mreq == NULL || mreq->gpd != gpd) {\r\ndev_err(mtu->dev, "no correct RX req is found\n");\r\nbreak;\r\n}\r\nreq = &mreq->request;\r\nreq->actual = le16_to_cpu(gpd->buf_len);\r\nmtu3_req_complete(mep, req, 0);\r\ngpd = advance_deq_gpd(ring);\r\n}\r\ndev_dbg(mtu->dev, "%s EP%d, deq=%p, enq=%p, complete\n",\r\n__func__, epnum, ring->dequeue, ring->enqueue);\r\n}\r\nstatic void qmu_done_isr(struct mtu3 *mtu, u32 done_status)\r\n{\r\nint i;\r\nfor (i = 1; i < mtu->num_eps; i++) {\r\nif (done_status & QMU_RX_DONE_INT(i))\r\nqmu_done_rx(mtu, i);\r\nif (done_status & QMU_TX_DONE_INT(i))\r\nqmu_done_tx(mtu, i);\r\n}\r\n}\r\nstatic void qmu_exception_isr(struct mtu3 *mtu, u32 qmu_status)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 errval;\r\nint i;\r\nif ((qmu_status & RXQ_CSERR_INT) || (qmu_status & RXQ_LENERR_INT)) {\r\nerrval = mtu3_readl(mbase, U3D_RQERRIR0);\r\nfor (i = 1; i < mtu->num_eps; i++) {\r\nif (errval & QMU_RX_CS_ERR(i))\r\ndev_err(mtu->dev, "Rx %d CS error!\n", i);\r\nif (errval & QMU_RX_LEN_ERR(i))\r\ndev_err(mtu->dev, "RX %d Length error\n", i);\r\n}\r\nmtu3_writel(mbase, U3D_RQERRIR0, errval);\r\n}\r\nif (qmu_status & RXQ_ZLPERR_INT) {\r\nerrval = mtu3_readl(mbase, U3D_RQERRIR1);\r\nfor (i = 1; i < mtu->num_eps; i++) {\r\nif (errval & QMU_RX_ZLP_ERR(i))\r\ndev_dbg(mtu->dev, "RX EP%d Recv ZLP\n", i);\r\n}\r\nmtu3_writel(mbase, U3D_RQERRIR1, errval);\r\n}\r\nif ((qmu_status & TXQ_CSERR_INT) || (qmu_status & TXQ_LENERR_INT)) {\r\nerrval = mtu3_readl(mbase, U3D_TQERRIR0);\r\nfor (i = 1; i < mtu->num_eps; i++) {\r\nif (errval & QMU_TX_CS_ERR(i))\r\ndev_err(mtu->dev, "Tx %d checksum error!\n", i);\r\nif (errval & QMU_TX_LEN_ERR(i))\r\nqmu_tx_zlp_error_handler(mtu, i);\r\n}\r\nmtu3_writel(mbase, U3D_TQERRIR0, errval);\r\n}\r\n}\r\nirqreturn_t mtu3_qmu_isr(struct mtu3 *mtu)\r\n{\r\nvoid __iomem *mbase = mtu->mac_base;\r\nu32 qmu_status;\r\nu32 qmu_done_status;\r\nqmu_status = mtu3_readl(mbase, U3D_QISAR1);\r\nqmu_status &= mtu3_readl(mbase, U3D_QIER1);\r\nqmu_done_status = mtu3_readl(mbase, U3D_QISAR0);\r\nqmu_done_status &= mtu3_readl(mbase, U3D_QIER0);\r\nmtu3_writel(mbase, U3D_QISAR0, qmu_done_status);\r\ndev_dbg(mtu->dev, "=== QMUdone[tx=%x, rx=%x] QMUexp[%x] ===\n",\r\n(qmu_done_status & 0xFFFF), qmu_done_status >> 16,\r\nqmu_status);\r\nif (qmu_done_status)\r\nqmu_done_isr(mtu, qmu_done_status);\r\nif (qmu_status)\r\nqmu_exception_isr(mtu, qmu_status);\r\nreturn IRQ_HANDLED;\r\n}\r\nint mtu3_qmu_init(struct mtu3 *mtu)\r\n{\r\ncompiletime_assert(QMU_GPD_SIZE == 16, "QMU_GPD size SHOULD be 16B");\r\nmtu->qmu_gpd_pool = dma_pool_create("QMU_GPD", mtu->dev,\r\nQMU_GPD_RING_SIZE, QMU_GPD_SIZE, 0);\r\nif (!mtu->qmu_gpd_pool)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nvoid mtu3_qmu_exit(struct mtu3 *mtu)\r\n{\r\ndma_pool_destroy(mtu->qmu_gpd_pool);\r\n}
