static int mcp23sxx_spi_write(void *context, const void *data, size_t count)\r\n{\r\nstruct mcp23s08 *mcp = context;\r\nstruct spi_device *spi = to_spi_device(mcp->dev);\r\nstruct spi_message m;\r\nstruct spi_transfer t[2] = { { .tx_buf = &mcp->addr, .len = 1, },\r\n{ .tx_buf = data, .len = count, }, };\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t[0], &m);\r\nspi_message_add_tail(&t[1], &m);\r\nreturn spi_sync(spi, &m);\r\n}\r\nstatic int mcp23sxx_spi_gather_write(void *context,\r\nconst void *reg, size_t reg_size,\r\nconst void *val, size_t val_size)\r\n{\r\nstruct mcp23s08 *mcp = context;\r\nstruct spi_device *spi = to_spi_device(mcp->dev);\r\nstruct spi_message m;\r\nstruct spi_transfer t[3] = { { .tx_buf = &mcp->addr, .len = 1, },\r\n{ .tx_buf = reg, .len = reg_size, },\r\n{ .tx_buf = val, .len = val_size, }, };\r\nspi_message_init(&m);\r\nspi_message_add_tail(&t[0], &m);\r\nspi_message_add_tail(&t[1], &m);\r\nspi_message_add_tail(&t[2], &m);\r\nreturn spi_sync(spi, &m);\r\n}\r\nstatic int mcp23sxx_spi_read(void *context, const void *reg, size_t reg_size,\r\nvoid *val, size_t val_size)\r\n{\r\nstruct mcp23s08 *mcp = context;\r\nstruct spi_device *spi = to_spi_device(mcp->dev);\r\nu8 tx[2];\r\nif (reg_size != 1)\r\nreturn -EINVAL;\r\ntx[0] = mcp->addr | 0x01;\r\ntx[1] = *((u8 *) reg);\r\nreturn spi_write_then_read(spi, tx, sizeof(tx), val, val_size);\r\n}\r\nstatic int mcp_read(struct mcp23s08 *mcp, unsigned int reg, unsigned int *val)\r\n{\r\nreturn regmap_read(mcp->regmap, reg << mcp->reg_shift, val);\r\n}\r\nstatic int mcp_write(struct mcp23s08 *mcp, unsigned int reg, unsigned int val)\r\n{\r\nreturn regmap_write(mcp->regmap, reg << mcp->reg_shift, val);\r\n}\r\nstatic int mcp_update_cache(struct mcp23s08 *mcp)\r\n{\r\nint ret, reg, i;\r\nfor (i = 0; i < ARRAY_SIZE(mcp->cache); i++) {\r\nret = mcp_read(mcp, i, &reg);\r\nif (ret < 0)\r\nreturn ret;\r\nmcp->cache[i] = reg;\r\n}\r\nreturn 0;\r\n}\r\nstatic int mcp23s08_direction_input(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = gpiochip_get_data(chip);\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nmcp->cache[MCP_IODIR] |= (1 << offset);\r\nstatus = mcp_write(mcp, MCP_IODIR, mcp->cache[MCP_IODIR]);\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic int mcp23s08_get(struct gpio_chip *chip, unsigned offset)\r\n{\r\nstruct mcp23s08 *mcp = gpiochip_get_data(chip);\r\nint status, ret;\r\nmutex_lock(&mcp->lock);\r\nret = mcp_read(mcp, MCP_GPIO, &status);\r\nif (ret < 0)\r\nstatus = 0;\r\nelse {\r\nmcp->cache[MCP_GPIO] = status;\r\nstatus = !!(status & (1 << offset));\r\n}\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic int __mcp23s08_set(struct mcp23s08 *mcp, unsigned mask, int value)\r\n{\r\nunsigned olat = mcp->cache[MCP_OLAT];\r\nif (value)\r\nolat |= mask;\r\nelse\r\nolat &= ~mask;\r\nmcp->cache[MCP_OLAT] = olat;\r\nreturn mcp_write(mcp, MCP_OLAT, olat);\r\n}\r\nstatic void mcp23s08_set(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mcp23s08 *mcp = gpiochip_get_data(chip);\r\nunsigned mask = 1 << offset;\r\nmutex_lock(&mcp->lock);\r\n__mcp23s08_set(mcp, mask, value);\r\nmutex_unlock(&mcp->lock);\r\n}\r\nstatic int\r\nmcp23s08_direction_output(struct gpio_chip *chip, unsigned offset, int value)\r\n{\r\nstruct mcp23s08 *mcp = gpiochip_get_data(chip);\r\nunsigned mask = 1 << offset;\r\nint status;\r\nmutex_lock(&mcp->lock);\r\nstatus = __mcp23s08_set(mcp, mask, value);\r\nif (status == 0) {\r\nmcp->cache[MCP_IODIR] &= ~mask;\r\nstatus = mcp_write(mcp, MCP_IODIR, mcp->cache[MCP_IODIR]);\r\n}\r\nmutex_unlock(&mcp->lock);\r\nreturn status;\r\n}\r\nstatic irqreturn_t mcp23s08_irq(int irq, void *data)\r\n{\r\nstruct mcp23s08 *mcp = data;\r\nint intcap, intf, i, gpio, gpio_orig, intcap_mask;\r\nunsigned int child_irq;\r\nbool intf_set, intcap_changed, gpio_bit_changed,\r\ndefval_changed, gpio_set;\r\nmutex_lock(&mcp->lock);\r\nif (mcp_read(mcp, MCP_INTF, &intf) < 0) {\r\nmutex_unlock(&mcp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nmcp->cache[MCP_INTF] = intf;\r\nif (mcp_read(mcp, MCP_INTCAP, &intcap) < 0) {\r\nmutex_unlock(&mcp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nmcp->cache[MCP_INTCAP] = intcap;\r\nif (mcp_read(mcp, MCP_GPIO, &gpio) < 0) {\r\nmutex_unlock(&mcp->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\ngpio_orig = mcp->cache[MCP_GPIO];\r\nmcp->cache[MCP_GPIO] = gpio;\r\nmutex_unlock(&mcp->lock);\r\nif (mcp->cache[MCP_INTF] == 0) {\r\nreturn IRQ_HANDLED;\r\n}\r\ndev_dbg(mcp->chip.parent,\r\n"intcap 0x%04X intf 0x%04X gpio_orig 0x%04X gpio 0x%04X\n",\r\nintcap, intf, gpio_orig, gpio);\r\nfor (i = 0; i < mcp->chip.ngpio; i++) {\r\nintf_set = BIT(i) & mcp->cache[MCP_INTF];\r\nif (i < 8 && intf_set)\r\nintcap_mask = 0x00FF;\r\nelse if (i >= 8 && intf_set)\r\nintcap_mask = 0xFF00;\r\nelse\r\nintcap_mask = 0x00;\r\nintcap_changed = (intcap_mask &\r\n(BIT(i) & mcp->cache[MCP_INTCAP])) !=\r\n(intcap_mask & (BIT(i) & gpio_orig));\r\ngpio_set = BIT(i) & mcp->cache[MCP_GPIO];\r\ngpio_bit_changed = (BIT(i) & gpio_orig) !=\r\n(BIT(i) & mcp->cache[MCP_GPIO]);\r\ndefval_changed = (BIT(i) & mcp->cache[MCP_INTCON]) &&\r\n((BIT(i) & mcp->cache[MCP_GPIO]) !=\r\n(BIT(i) & mcp->cache[MCP_DEFVAL]));\r\nif (((gpio_bit_changed || intcap_changed) &&\r\n(BIT(i) & mcp->irq_rise) && gpio_set) ||\r\n((gpio_bit_changed || intcap_changed) &&\r\n(BIT(i) & mcp->irq_fall) && !gpio_set) ||\r\ndefval_changed) {\r\nchild_irq = irq_find_mapping(mcp->chip.irqdomain, i);\r\nhandle_nested_irq(child_irq);\r\n}\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void mcp23s08_irq_mask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\r\nstruct mcp23s08 *mcp = gpiochip_get_data(gc);\r\nunsigned int pos = data->hwirq;\r\nmcp->cache[MCP_GPINTEN] &= ~BIT(pos);\r\n}\r\nstatic void mcp23s08_irq_unmask(struct irq_data *data)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\r\nstruct mcp23s08 *mcp = gpiochip_get_data(gc);\r\nunsigned int pos = data->hwirq;\r\nmcp->cache[MCP_GPINTEN] |= BIT(pos);\r\n}\r\nstatic int mcp23s08_irq_set_type(struct irq_data *data, unsigned int type)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\r\nstruct mcp23s08 *mcp = gpiochip_get_data(gc);\r\nunsigned int pos = data->hwirq;\r\nint status = 0;\r\nif ((type & IRQ_TYPE_EDGE_BOTH) == IRQ_TYPE_EDGE_BOTH) {\r\nmcp->cache[MCP_INTCON] &= ~BIT(pos);\r\nmcp->irq_rise |= BIT(pos);\r\nmcp->irq_fall |= BIT(pos);\r\n} else if (type & IRQ_TYPE_EDGE_RISING) {\r\nmcp->cache[MCP_INTCON] &= ~BIT(pos);\r\nmcp->irq_rise |= BIT(pos);\r\nmcp->irq_fall &= ~BIT(pos);\r\n} else if (type & IRQ_TYPE_EDGE_FALLING) {\r\nmcp->cache[MCP_INTCON] &= ~BIT(pos);\r\nmcp->irq_rise &= ~BIT(pos);\r\nmcp->irq_fall |= BIT(pos);\r\n} else if (type & IRQ_TYPE_LEVEL_HIGH) {\r\nmcp->cache[MCP_INTCON] |= BIT(pos);\r\nmcp->cache[MCP_DEFVAL] &= ~BIT(pos);\r\n} else if (type & IRQ_TYPE_LEVEL_LOW) {\r\nmcp->cache[MCP_INTCON] |= BIT(pos);\r\nmcp->cache[MCP_DEFVAL] |= BIT(pos);\r\n} else\r\nreturn -EINVAL;\r\nreturn status;\r\n}\r\nstatic void mcp23s08_irq_bus_lock(struct irq_data *data)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\r\nstruct mcp23s08 *mcp = gpiochip_get_data(gc);\r\nmutex_lock(&mcp->irq_lock);\r\n}\r\nstatic void mcp23s08_irq_bus_unlock(struct irq_data *data)\r\n{\r\nstruct gpio_chip *gc = irq_data_get_irq_chip_data(data);\r\nstruct mcp23s08 *mcp = gpiochip_get_data(gc);\r\nmutex_lock(&mcp->lock);\r\nmcp_write(mcp, MCP_GPINTEN, mcp->cache[MCP_GPINTEN]);\r\nmcp_write(mcp, MCP_DEFVAL, mcp->cache[MCP_DEFVAL]);\r\nmcp_write(mcp, MCP_INTCON, mcp->cache[MCP_INTCON]);\r\nmutex_unlock(&mcp->lock);\r\nmutex_unlock(&mcp->irq_lock);\r\n}\r\nstatic int mcp23s08_irq_setup(struct mcp23s08 *mcp)\r\n{\r\nstruct gpio_chip *chip = &mcp->chip;\r\nint err;\r\nunsigned long irqflags = IRQF_ONESHOT | IRQF_SHARED;\r\nmutex_init(&mcp->irq_lock);\r\nif (mcp->irq_active_high)\r\nirqflags |= IRQF_TRIGGER_HIGH;\r\nelse\r\nirqflags |= IRQF_TRIGGER_LOW;\r\nerr = devm_request_threaded_irq(chip->parent, mcp->irq, NULL,\r\nmcp23s08_irq,\r\nirqflags, dev_name(chip->parent), mcp);\r\nif (err != 0) {\r\ndev_err(chip->parent, "unable to request IRQ#%d: %d\n",\r\nmcp->irq, err);\r\nreturn err;\r\n}\r\nerr = gpiochip_irqchip_add_nested(chip,\r\n&mcp23s08_irq_chip,\r\n0,\r\nhandle_simple_irq,\r\nIRQ_TYPE_NONE);\r\nif (err) {\r\ndev_err(chip->parent,\r\n"could not connect irqchip to gpiochip: %d\n", err);\r\nreturn err;\r\n}\r\ngpiochip_set_nested_irqchip(chip,\r\n&mcp23s08_irq_chip,\r\nmcp->irq);\r\nreturn 0;\r\n}\r\nstatic void mcp23s08_dbg_show(struct seq_file *s, struct gpio_chip *chip)\r\n{\r\nstruct mcp23s08 *mcp;\r\nchar bank;\r\nint t;\r\nunsigned mask;\r\nmcp = gpiochip_get_data(chip);\r\nbank = '0' + ((mcp->addr >> 1) & 0x7);\r\nmutex_lock(&mcp->lock);\r\nt = mcp_update_cache(mcp);\r\nif (t < 0) {\r\nseq_printf(s, " I/O ERROR %d\n", t);\r\ngoto done;\r\n}\r\nfor (t = 0, mask = 1; t < chip->ngpio; t++, mask <<= 1) {\r\nconst char *label;\r\nlabel = gpiochip_is_requested(chip, t);\r\nif (!label)\r\ncontinue;\r\nseq_printf(s, " gpio-%-3d P%c.%d (%-12s) %s %s %s",\r\nchip->base + t, bank, t, label,\r\n(mcp->cache[MCP_IODIR] & mask) ? "in " : "out",\r\n(mcp->cache[MCP_GPIO] & mask) ? "hi" : "lo",\r\n(mcp->cache[MCP_GPPU] & mask) ? "up" : " ");\r\nseq_puts(s, "\n");\r\n}\r\ndone:\r\nmutex_unlock(&mcp->lock);\r\n}\r\nstatic int mcp23s08_probe_one(struct mcp23s08 *mcp, struct device *dev,\r\nvoid *data, unsigned addr, unsigned type,\r\nstruct mcp23s08_platform_data *pdata, int cs)\r\n{\r\nint status, ret;\r\nbool mirror = false;\r\nmutex_init(&mcp->lock);\r\nmcp->dev = dev;\r\nmcp->addr = addr;\r\nmcp->irq_active_high = false;\r\nmcp->chip.direction_input = mcp23s08_direction_input;\r\nmcp->chip.get = mcp23s08_get;\r\nmcp->chip.direction_output = mcp23s08_direction_output;\r\nmcp->chip.set = mcp23s08_set;\r\nmcp->chip.dbg_show = mcp23s08_dbg_show;\r\n#ifdef CONFIG_OF_GPIO\r\nmcp->chip.of_gpio_n_cells = 2;\r\nmcp->chip.of_node = dev->of_node;\r\n#endif\r\nswitch (type) {\r\n#ifdef CONFIG_SPI_MASTER\r\ncase MCP_TYPE_S08:\r\nmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp,\r\n&mcp23x08_regmap);\r\nmcp->reg_shift = 0;\r\nmcp->chip.ngpio = 8;\r\nmcp->chip.label = "mcp23s08";\r\nbreak;\r\ncase MCP_TYPE_S17:\r\nmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp,\r\n&mcp23x17_regmap);\r\nmcp->reg_shift = 1;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23s17";\r\nbreak;\r\ncase MCP_TYPE_S18:\r\nmcp->regmap = devm_regmap_init(dev, &mcp23sxx_spi_regmap, mcp,\r\n&mcp23x17_regmap);\r\nmcp->reg_shift = 1;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23s18";\r\nbreak;\r\n#endif\r\n#if IS_ENABLED(CONFIG_I2C)\r\ncase MCP_TYPE_008:\r\nmcp->regmap = devm_regmap_init_i2c(data, &mcp23x08_regmap);\r\nmcp->reg_shift = 0;\r\nmcp->chip.ngpio = 8;\r\nmcp->chip.label = "mcp23008";\r\nbreak;\r\ncase MCP_TYPE_017:\r\nmcp->regmap = devm_regmap_init_i2c(data, &mcp23x17_regmap);\r\nmcp->reg_shift = 1;\r\nmcp->chip.ngpio = 16;\r\nmcp->chip.label = "mcp23017";\r\nbreak;\r\n#endif\r\ndefault:\r\ndev_err(dev, "invalid device type (%d)\n", type);\r\nreturn -EINVAL;\r\n}\r\nif (IS_ERR(mcp->regmap))\r\nreturn PTR_ERR(mcp->regmap);\r\nmcp->chip.base = pdata->base;\r\nmcp->chip.can_sleep = true;\r\nmcp->chip.parent = dev;\r\nmcp->chip.owner = THIS_MODULE;\r\nret = mcp_read(mcp, MCP_IOCON, &status);\r\nif (ret < 0)\r\ngoto fail;\r\nmcp->irq_controller = pdata->irq_controller;\r\nif (mcp->irq && mcp->irq_controller) {\r\nmcp->irq_active_high =\r\nof_property_read_bool(mcp->chip.parent->of_node,\r\n"microchip,irq-active-high");\r\nmirror = pdata->mirror;\r\n}\r\nif ((status & IOCON_SEQOP) || !(status & IOCON_HAEN) || mirror ||\r\nmcp->irq_active_high) {\r\nstatus &= ~(IOCON_SEQOP | (IOCON_SEQOP << 8));\r\nstatus |= IOCON_HAEN | (IOCON_HAEN << 8);\r\nif (mcp->irq_active_high)\r\nstatus |= IOCON_INTPOL | (IOCON_INTPOL << 8);\r\nelse\r\nstatus &= ~(IOCON_INTPOL | (IOCON_INTPOL << 8));\r\nif (mirror)\r\nstatus |= IOCON_MIRROR | (IOCON_MIRROR << 8);\r\nif (type == MCP_TYPE_S18)\r\nstatus |= IOCON_INTCC | (IOCON_INTCC << 8);\r\nret = mcp_write(mcp, MCP_IOCON, status);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nret = mcp_write(mcp, MCP_GPPU, pdata->chip[cs].pullups);\r\nif (ret < 0)\r\ngoto fail;\r\nret = mcp_update_cache(mcp);\r\nif (ret < 0)\r\ngoto fail;\r\nif (mcp->cache[MCP_IPOL] != 0) {\r\nmcp->cache[MCP_IPOL] = 0;\r\nret = mcp_write(mcp, MCP_IPOL, 0);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nif (mcp->cache[MCP_GPINTEN] != 0) {\r\nmcp->cache[MCP_GPINTEN] = 0;\r\nret = mcp_write(mcp, MCP_GPINTEN, 0);\r\nif (ret < 0)\r\ngoto fail;\r\n}\r\nret = gpiochip_add_data(&mcp->chip, mcp);\r\nif (ret < 0)\r\ngoto fail;\r\nif (mcp->irq && mcp->irq_controller) {\r\nret = mcp23s08_irq_setup(mcp);\r\nif (ret)\r\ngoto fail;\r\n}\r\nfail:\r\nif (ret < 0)\r\ndev_dbg(dev, "can't setup chip %d, --> %d\n", addr, ret);\r\nreturn ret;\r\n}\r\nstatic int mcp230xx_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct mcp23s08_platform_data *pdata, local_pdata;\r\nstruct mcp23s08 *mcp;\r\nint status;\r\nconst struct of_device_id *match;\r\nmatch = of_match_device(of_match_ptr(mcp23s08_i2c_of_match),\r\n&client->dev);\r\nif (match) {\r\npdata = &local_pdata;\r\npdata->base = -1;\r\npdata->chip[0].pullups = 0;\r\npdata->irq_controller = of_property_read_bool(\r\nclient->dev.of_node,\r\n"interrupt-controller");\r\npdata->mirror = of_property_read_bool(client->dev.of_node,\r\n"microchip,irq-mirror");\r\nclient->irq = irq_of_parse_and_map(client->dev.of_node, 0);\r\n} else {\r\npdata = dev_get_platdata(&client->dev);\r\nif (!pdata) {\r\npdata = devm_kzalloc(&client->dev,\r\nsizeof(struct mcp23s08_platform_data),\r\nGFP_KERNEL);\r\nif (!pdata)\r\nreturn -ENOMEM;\r\npdata->base = -1;\r\n}\r\n}\r\nmcp = kzalloc(sizeof(*mcp), GFP_KERNEL);\r\nif (!mcp)\r\nreturn -ENOMEM;\r\nmcp->irq = client->irq;\r\nstatus = mcp23s08_probe_one(mcp, &client->dev, client, client->addr,\r\nid->driver_data, pdata, 0);\r\nif (status)\r\ngoto fail;\r\ni2c_set_clientdata(client, mcp);\r\nreturn 0;\r\nfail:\r\nkfree(mcp);\r\nreturn status;\r\n}\r\nstatic int mcp230xx_remove(struct i2c_client *client)\r\n{\r\nstruct mcp23s08 *mcp = i2c_get_clientdata(client);\r\ngpiochip_remove(&mcp->chip);\r\nkfree(mcp);\r\nreturn 0;\r\n}\r\nstatic int __init mcp23s08_i2c_init(void)\r\n{\r\nreturn i2c_add_driver(&mcp230xx_driver);\r\n}\r\nstatic void mcp23s08_i2c_exit(void)\r\n{\r\ni2c_del_driver(&mcp230xx_driver);\r\n}\r\nstatic int __init mcp23s08_i2c_init(void) { return 0; }\r\nstatic void mcp23s08_i2c_exit(void) { }\r\nstatic int mcp23s08_probe(struct spi_device *spi)\r\n{\r\nstruct mcp23s08_platform_data *pdata, local_pdata;\r\nunsigned addr;\r\nint chips = 0;\r\nstruct mcp23s08_driver_data *data;\r\nint status, type;\r\nunsigned ngpio = 0;\r\nconst struct of_device_id *match;\r\nu32 spi_present_mask = 0;\r\nmatch = of_match_device(of_match_ptr(mcp23s08_spi_of_match), &spi->dev);\r\nif (match) {\r\ntype = (int)(uintptr_t)match->data;\r\nstatus = of_property_read_u32(spi->dev.of_node,\r\n"microchip,spi-present-mask", &spi_present_mask);\r\nif (status) {\r\nstatus = of_property_read_u32(spi->dev.of_node,\r\n"mcp,spi-present-mask", &spi_present_mask);\r\nif (status) {\r\ndev_err(&spi->dev,\r\n"DT has no spi-present-mask\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nif ((spi_present_mask <= 0) || (spi_present_mask >= 256)) {\r\ndev_err(&spi->dev, "invalid spi-present-mask\n");\r\nreturn -ENODEV;\r\n}\r\npdata = &local_pdata;\r\npdata->base = -1;\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\npdata->chip[addr].pullups = 0;\r\nif (spi_present_mask & (1 << addr))\r\nchips++;\r\n}\r\npdata->irq_controller = of_property_read_bool(\r\nspi->dev.of_node,\r\n"interrupt-controller");\r\npdata->mirror = of_property_read_bool(spi->dev.of_node,\r\n"microchip,irq-mirror");\r\n} else {\r\ntype = spi_get_device_id(spi)->driver_data;\r\npdata = dev_get_platdata(&spi->dev);\r\nif (!pdata) {\r\npdata = devm_kzalloc(&spi->dev,\r\nsizeof(struct mcp23s08_platform_data),\r\nGFP_KERNEL);\r\npdata->base = -1;\r\n}\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\nif (!pdata->chip[addr].is_present)\r\ncontinue;\r\nchips++;\r\nif ((type == MCP_TYPE_S08) && (addr > 3)) {\r\ndev_err(&spi->dev,\r\n"mcp23s08 only supports address 0..3\n");\r\nreturn -EINVAL;\r\n}\r\nspi_present_mask |= 1 << addr;\r\n}\r\n}\r\nif (!chips)\r\nreturn -ENODEV;\r\ndata = devm_kzalloc(&spi->dev,\r\nsizeof(*data) + chips * sizeof(struct mcp23s08),\r\nGFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\nspi_set_drvdata(spi, data);\r\nspi->irq = irq_of_parse_and_map(spi->dev.of_node, 0);\r\nfor (addr = 0; addr < ARRAY_SIZE(pdata->chip); addr++) {\r\nif (!(spi_present_mask & (1 << addr)))\r\ncontinue;\r\nchips--;\r\ndata->mcp[addr] = &data->chip[chips];\r\ndata->mcp[addr]->irq = spi->irq;\r\nstatus = mcp23s08_probe_one(data->mcp[addr], &spi->dev, spi,\r\n0x40 | (addr << 1), type, pdata,\r\naddr);\r\nif (status < 0)\r\ngoto fail;\r\nif (pdata->base != -1)\r\npdata->base += data->mcp[addr]->chip.ngpio;\r\nngpio += data->mcp[addr]->chip.ngpio;\r\n}\r\ndata->ngpio = ngpio;\r\nreturn 0;\r\nfail:\r\nfor (addr = 0; addr < ARRAY_SIZE(data->mcp); addr++) {\r\nif (!data->mcp[addr])\r\ncontinue;\r\ngpiochip_remove(&data->mcp[addr]->chip);\r\n}\r\nreturn status;\r\n}\r\nstatic int mcp23s08_remove(struct spi_device *spi)\r\n{\r\nstruct mcp23s08_driver_data *data = spi_get_drvdata(spi);\r\nunsigned addr;\r\nfor (addr = 0; addr < ARRAY_SIZE(data->mcp); addr++) {\r\nif (!data->mcp[addr])\r\ncontinue;\r\ngpiochip_remove(&data->mcp[addr]->chip);\r\n}\r\nreturn 0;\r\n}\r\nstatic int __init mcp23s08_spi_init(void)\r\n{\r\nreturn spi_register_driver(&mcp23s08_driver);\r\n}\r\nstatic void mcp23s08_spi_exit(void)\r\n{\r\nspi_unregister_driver(&mcp23s08_driver);\r\n}\r\nstatic int __init mcp23s08_spi_init(void) { return 0; }\r\nstatic void mcp23s08_spi_exit(void) { }\r\nstatic int __init mcp23s08_init(void)\r\n{\r\nint ret;\r\nret = mcp23s08_spi_init();\r\nif (ret)\r\ngoto spi_fail;\r\nret = mcp23s08_i2c_init();\r\nif (ret)\r\ngoto i2c_fail;\r\nreturn 0;\r\ni2c_fail:\r\nmcp23s08_spi_exit();\r\nspi_fail:\r\nreturn ret;\r\n}\r\nstatic void __exit mcp23s08_exit(void)\r\n{\r\nmcp23s08_spi_exit();\r\nmcp23s08_i2c_exit();\r\n}
