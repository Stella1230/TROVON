static inline struct rockchip_pwm_chip *to_rockchip_pwm_chip(struct pwm_chip *c)\r\n{\r\nreturn container_of(c, struct rockchip_pwm_chip, chip);\r\n}\r\nstatic void rockchip_pwm_set_enable_v1(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, bool enable,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nu32 enable_conf = PWM_CTRL_OUTPUT_EN | PWM_CTRL_TIMER_EN;\r\nu32 val;\r\nval = readl_relaxed(pc->base + pc->data->regs.ctrl);\r\nif (enable)\r\nval |= enable_conf;\r\nelse\r\nval &= ~enable_conf;\r\nwritel_relaxed(val, pc->base + pc->data->regs.ctrl);\r\n}\r\nstatic void rockchip_pwm_get_state_v1(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nu32 enable_conf = PWM_CTRL_OUTPUT_EN | PWM_CTRL_TIMER_EN;\r\nu32 val;\r\nval = readl_relaxed(pc->base + pc->data->regs.ctrl);\r\nif ((val & enable_conf) == enable_conf)\r\nstate->enabled = true;\r\n}\r\nstatic void rockchip_pwm_set_enable_v2(struct pwm_chip *chip,\r\nstruct pwm_device *pwm, bool enable,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nu32 enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | PWM_ENABLE |\r\nPWM_CONTINUOUS;\r\nu32 val;\r\nif (polarity == PWM_POLARITY_INVERSED)\r\nenable_conf |= PWM_DUTY_NEGATIVE | PWM_INACTIVE_POSITIVE;\r\nelse\r\nenable_conf |= PWM_DUTY_POSITIVE | PWM_INACTIVE_NEGATIVE;\r\nval = readl_relaxed(pc->base + pc->data->regs.ctrl);\r\nif (enable)\r\nval |= enable_conf;\r\nelse\r\nval &= ~enable_conf;\r\nwritel_relaxed(val, pc->base + pc->data->regs.ctrl);\r\n}\r\nstatic void rockchip_pwm_get_state_v2(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nu32 enable_conf = PWM_OUTPUT_LEFT | PWM_LP_DISABLE | PWM_ENABLE |\r\nPWM_CONTINUOUS;\r\nu32 val;\r\nval = readl_relaxed(pc->base + pc->data->regs.ctrl);\r\nif ((val & enable_conf) != enable_conf)\r\nreturn;\r\nstate->enabled = true;\r\nif (!(val & PWM_DUTY_POSITIVE))\r\nstate->polarity = PWM_POLARITY_INVERSED;\r\n}\r\nstatic void rockchip_pwm_get_state(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nunsigned long clk_rate;\r\nu64 tmp;\r\nint ret;\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\nreturn;\r\nclk_rate = clk_get_rate(pc->clk);\r\ntmp = readl_relaxed(pc->base + pc->data->regs.period);\r\ntmp *= pc->data->prescaler * NSEC_PER_SEC;\r\nstate->period = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\r\ntmp = readl_relaxed(pc->base + pc->data->regs.duty);\r\ntmp *= pc->data->prescaler * NSEC_PER_SEC;\r\nstate->duty_cycle = DIV_ROUND_CLOSEST_ULL(tmp, clk_rate);\r\npc->data->get_state(chip, pwm, state);\r\nclk_disable(pc->clk);\r\n}\r\nstatic int rockchip_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm,\r\nint duty_ns, int period_ns)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nunsigned long period, duty;\r\nu64 clk_rate, div;\r\nclk_rate = clk_get_rate(pc->clk);\r\ndiv = clk_rate * period_ns;\r\nperiod = DIV_ROUND_CLOSEST_ULL(div,\r\npc->data->prescaler * NSEC_PER_SEC);\r\ndiv = clk_rate * duty_ns;\r\nduty = DIV_ROUND_CLOSEST_ULL(div, pc->data->prescaler * NSEC_PER_SEC);\r\nwritel(period, pc->base + pc->data->regs.period);\r\nwritel(duty, pc->base + pc->data->regs.duty);\r\nreturn 0;\r\n}\r\nstatic int rockchip_pwm_enable(struct pwm_chip *chip,\r\nstruct pwm_device *pwm,\r\nbool enable,\r\nenum pwm_polarity polarity)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nint ret;\r\nif (enable) {\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\nreturn ret;\r\n}\r\npc->data->set_enable(chip, pwm, enable, polarity);\r\nif (!enable)\r\nclk_disable(pc->clk);\r\nreturn 0;\r\n}\r\nstatic int rockchip_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,\r\nstruct pwm_state *state)\r\n{\r\nstruct rockchip_pwm_chip *pc = to_rockchip_pwm_chip(chip);\r\nstruct pwm_state curstate;\r\nbool enabled;\r\nint ret;\r\npwm_get_state(pwm, &curstate);\r\nenabled = curstate.enabled;\r\nret = clk_enable(pc->clk);\r\nif (ret)\r\nreturn ret;\r\nif (state->polarity != curstate.polarity && enabled) {\r\nret = rockchip_pwm_enable(chip, pwm, false, state->polarity);\r\nif (ret)\r\ngoto out;\r\nenabled = false;\r\n}\r\nret = rockchip_pwm_config(chip, pwm, state->duty_cycle, state->period);\r\nif (ret) {\r\nif (enabled != curstate.enabled)\r\nrockchip_pwm_enable(chip, pwm, !enabled,\r\nstate->polarity);\r\ngoto out;\r\n}\r\nif (state->enabled != enabled) {\r\nret = rockchip_pwm_enable(chip, pwm, state->enabled,\r\nstate->polarity);\r\nif (ret)\r\ngoto out;\r\n}\r\nrockchip_pwm_get_state(chip, pwm, state);\r\nout:\r\nclk_disable(pc->clk);\r\nreturn ret;\r\n}\r\nstatic int rockchip_pwm_probe(struct platform_device *pdev)\r\n{\r\nconst struct of_device_id *id;\r\nstruct rockchip_pwm_chip *pc;\r\nstruct resource *r;\r\nint ret;\r\nid = of_match_device(rockchip_pwm_dt_ids, &pdev->dev);\r\nif (!id)\r\nreturn -EINVAL;\r\npc = devm_kzalloc(&pdev->dev, sizeof(*pc), GFP_KERNEL);\r\nif (!pc)\r\nreturn -ENOMEM;\r\nr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npc->base = devm_ioremap_resource(&pdev->dev, r);\r\nif (IS_ERR(pc->base))\r\nreturn PTR_ERR(pc->base);\r\npc->clk = devm_clk_get(&pdev->dev, NULL);\r\nif (IS_ERR(pc->clk))\r\nreturn PTR_ERR(pc->clk);\r\nret = clk_prepare_enable(pc->clk);\r\nif (ret)\r\nreturn ret;\r\nplatform_set_drvdata(pdev, pc);\r\npc->data = id->data;\r\npc->chip.dev = &pdev->dev;\r\npc->chip.ops = pc->data->ops;\r\npc->chip.base = -1;\r\npc->chip.npwm = 1;\r\nif (pc->data->supports_polarity) {\r\npc->chip.of_xlate = of_pwm_xlate_with_flags;\r\npc->chip.of_pwm_n_cells = 3;\r\n}\r\nret = pwmchip_add(&pc->chip);\r\nif (ret < 0) {\r\nclk_unprepare(pc->clk);\r\ndev_err(&pdev->dev, "pwmchip_add() failed: %d\n", ret);\r\n}\r\nif (!pwm_is_enabled(pc->chip.pwms))\r\nclk_disable(pc->clk);\r\nreturn ret;\r\n}\r\nstatic int rockchip_pwm_remove(struct platform_device *pdev)\r\n{\r\nstruct rockchip_pwm_chip *pc = platform_get_drvdata(pdev);\r\nif (pwm_is_enabled(pc->chip.pwms))\r\nclk_disable(pc->clk);\r\nclk_unprepare(pc->clk);\r\nreturn pwmchip_remove(&pc->chip);\r\n}
