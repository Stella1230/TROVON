static inline void __user *media_get_uptr(__u64 arg)\r\n{\r\nreturn (void __user *)(uintptr_t)arg;\r\n}\r\nstatic int media_device_open(struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int media_device_close(struct file *filp)\r\n{\r\nreturn 0;\r\n}\r\nstatic int media_device_get_info(struct media_device *dev,\r\nstruct media_device_info *info)\r\n{\r\nmemset(info, 0, sizeof(*info));\r\nif (dev->driver_name[0])\r\nstrlcpy(info->driver, dev->driver_name, sizeof(info->driver));\r\nelse\r\nstrlcpy(info->driver, dev->dev->driver->name,\r\nsizeof(info->driver));\r\nstrlcpy(info->model, dev->model, sizeof(info->model));\r\nstrlcpy(info->serial, dev->serial, sizeof(info->serial));\r\nstrlcpy(info->bus_info, dev->bus_info, sizeof(info->bus_info));\r\ninfo->media_version = MEDIA_API_VERSION;\r\ninfo->hw_revision = dev->hw_revision;\r\ninfo->driver_version = dev->driver_version;\r\nreturn 0;\r\n}\r\nstatic struct media_entity *find_entity(struct media_device *mdev, u32 id)\r\n{\r\nstruct media_entity *entity;\r\nint next = id & MEDIA_ENT_ID_FLAG_NEXT;\r\nid &= ~MEDIA_ENT_ID_FLAG_NEXT;\r\nmedia_device_for_each_entity(entity, mdev) {\r\nif (((media_entity_id(entity) == id) && !next) ||\r\n((media_entity_id(entity) > id) && next)) {\r\nreturn entity;\r\n}\r\n}\r\nreturn NULL;\r\n}\r\nstatic long media_device_enum_entities(struct media_device *mdev,\r\nstruct media_entity_desc *entd)\r\n{\r\nstruct media_entity *ent;\r\nent = find_entity(mdev, entd->id);\r\nif (ent == NULL)\r\nreturn -EINVAL;\r\nmemset(entd, 0, sizeof(*entd));\r\nentd->id = media_entity_id(ent);\r\nif (ent->name)\r\nstrlcpy(entd->name, ent->name, sizeof(entd->name));\r\nentd->type = ent->function;\r\nentd->revision = 0;\r\nentd->flags = ent->flags;\r\nentd->group_id = 0;\r\nentd->pads = ent->num_pads;\r\nentd->links = ent->num_links - ent->num_backlinks;\r\nif (ent->function < MEDIA_ENT_F_OLD_BASE ||\r\nent->function > MEDIA_ENT_F_TUNER) {\r\nif (is_media_entity_v4l2_subdev(ent))\r\nentd->type = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;\r\nelse if (ent->function != MEDIA_ENT_F_IO_V4L)\r\nentd->type = MEDIA_ENT_T_DEVNODE_UNKNOWN;\r\n}\r\nmemcpy(&entd->raw, &ent->info, sizeof(ent->info));\r\nreturn 0;\r\n}\r\nstatic void media_device_kpad_to_upad(const struct media_pad *kpad,\r\nstruct media_pad_desc *upad)\r\n{\r\nupad->entity = media_entity_id(kpad->entity);\r\nupad->index = kpad->index;\r\nupad->flags = kpad->flags;\r\n}\r\nstatic long media_device_enum_links(struct media_device *mdev,\r\nstruct media_links_enum *links)\r\n{\r\nstruct media_entity *entity;\r\nentity = find_entity(mdev, links->entity);\r\nif (entity == NULL)\r\nreturn -EINVAL;\r\nif (links->pads) {\r\nunsigned int p;\r\nfor (p = 0; p < entity->num_pads; p++) {\r\nstruct media_pad_desc pad;\r\nmemset(&pad, 0, sizeof(pad));\r\nmedia_device_kpad_to_upad(&entity->pads[p], &pad);\r\nif (copy_to_user(&links->pads[p], &pad, sizeof(pad)))\r\nreturn -EFAULT;\r\n}\r\n}\r\nif (links->links) {\r\nstruct media_link *link;\r\nstruct media_link_desc __user *ulink_desc = links->links;\r\nlist_for_each_entry(link, &entity->links, list) {\r\nstruct media_link_desc klink_desc;\r\nif (link->source->entity != entity)\r\ncontinue;\r\nmemset(&klink_desc, 0, sizeof(klink_desc));\r\nmedia_device_kpad_to_upad(link->source,\r\n&klink_desc.source);\r\nmedia_device_kpad_to_upad(link->sink,\r\n&klink_desc.sink);\r\nklink_desc.flags = link->flags;\r\nif (copy_to_user(ulink_desc, &klink_desc,\r\nsizeof(*ulink_desc)))\r\nreturn -EFAULT;\r\nulink_desc++;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic long media_device_setup_link(struct media_device *mdev,\r\nstruct media_link_desc *linkd)\r\n{\r\nstruct media_link *link = NULL;\r\nstruct media_entity *source;\r\nstruct media_entity *sink;\r\nsource = find_entity(mdev, linkd->source.entity);\r\nsink = find_entity(mdev, linkd->sink.entity);\r\nif (source == NULL || sink == NULL)\r\nreturn -EINVAL;\r\nif (linkd->source.index >= source->num_pads ||\r\nlinkd->sink.index >= sink->num_pads)\r\nreturn -EINVAL;\r\nlink = media_entity_find_link(&source->pads[linkd->source.index],\r\n&sink->pads[linkd->sink.index]);\r\nif (link == NULL)\r\nreturn -EINVAL;\r\nreturn __media_entity_setup_link(link, linkd->flags);\r\n}\r\nstatic long media_device_get_topology(struct media_device *mdev,\r\nstruct media_v2_topology *topo)\r\n{\r\nstruct media_entity *entity;\r\nstruct media_interface *intf;\r\nstruct media_pad *pad;\r\nstruct media_link *link;\r\nstruct media_v2_entity kentity, __user *uentity;\r\nstruct media_v2_interface kintf, __user *uintf;\r\nstruct media_v2_pad kpad, __user *upad;\r\nstruct media_v2_link klink, __user *ulink;\r\nunsigned int i;\r\nint ret = 0;\r\ntopo->topology_version = mdev->topology_version;\r\ni = 0;\r\nuentity = media_get_uptr(topo->ptr_entities);\r\nmedia_device_for_each_entity(entity, mdev) {\r\ni++;\r\nif (ret || !uentity)\r\ncontinue;\r\nif (i > topo->num_entities) {\r\nret = -ENOSPC;\r\ncontinue;\r\n}\r\nmemset(&kentity, 0, sizeof(kentity));\r\nkentity.id = entity->graph_obj.id;\r\nkentity.function = entity->function;\r\nstrncpy(kentity.name, entity->name,\r\nsizeof(kentity.name));\r\nif (copy_to_user(uentity, &kentity, sizeof(kentity)))\r\nret = -EFAULT;\r\nuentity++;\r\n}\r\ntopo->num_entities = i;\r\ni = 0;\r\nuintf = media_get_uptr(topo->ptr_interfaces);\r\nmedia_device_for_each_intf(intf, mdev) {\r\ni++;\r\nif (ret || !uintf)\r\ncontinue;\r\nif (i > topo->num_interfaces) {\r\nret = -ENOSPC;\r\ncontinue;\r\n}\r\nmemset(&kintf, 0, sizeof(kintf));\r\nkintf.id = intf->graph_obj.id;\r\nkintf.intf_type = intf->type;\r\nkintf.flags = intf->flags;\r\nif (media_type(&intf->graph_obj) == MEDIA_GRAPH_INTF_DEVNODE) {\r\nstruct media_intf_devnode *devnode;\r\ndevnode = intf_to_devnode(intf);\r\nkintf.devnode.major = devnode->major;\r\nkintf.devnode.minor = devnode->minor;\r\n}\r\nif (copy_to_user(uintf, &kintf, sizeof(kintf)))\r\nret = -EFAULT;\r\nuintf++;\r\n}\r\ntopo->num_interfaces = i;\r\ni = 0;\r\nupad = media_get_uptr(topo->ptr_pads);\r\nmedia_device_for_each_pad(pad, mdev) {\r\ni++;\r\nif (ret || !upad)\r\ncontinue;\r\nif (i > topo->num_pads) {\r\nret = -ENOSPC;\r\ncontinue;\r\n}\r\nmemset(&kpad, 0, sizeof(kpad));\r\nkpad.id = pad->graph_obj.id;\r\nkpad.entity_id = pad->entity->graph_obj.id;\r\nkpad.flags = pad->flags;\r\nif (copy_to_user(upad, &kpad, sizeof(kpad)))\r\nret = -EFAULT;\r\nupad++;\r\n}\r\ntopo->num_pads = i;\r\ni = 0;\r\nulink = media_get_uptr(topo->ptr_links);\r\nmedia_device_for_each_link(link, mdev) {\r\nif (link->is_backlink)\r\ncontinue;\r\ni++;\r\nif (ret || !ulink)\r\ncontinue;\r\nif (i > topo->num_links) {\r\nret = -ENOSPC;\r\ncontinue;\r\n}\r\nmemset(&klink, 0, sizeof(klink));\r\nklink.id = link->graph_obj.id;\r\nklink.source_id = link->gobj0->id;\r\nklink.sink_id = link->gobj1->id;\r\nklink.flags = link->flags;\r\nif (copy_to_user(ulink, &klink, sizeof(klink)))\r\nret = -EFAULT;\r\nulink++;\r\n}\r\ntopo->num_links = i;\r\nreturn ret;\r\n}\r\nstatic long copy_arg_from_user(void *karg, void __user *uarg, unsigned int cmd)\r\n{\r\nif (copy_from_user(karg, uarg, _IOC_SIZE(cmd)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long copy_arg_to_user(void __user *uarg, void *karg, unsigned int cmd)\r\n{\r\nif (copy_to_user(uarg, karg, _IOC_SIZE(cmd)))\r\nreturn -EFAULT;\r\nreturn 0;\r\n}\r\nstatic long media_device_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long __arg)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nstruct media_device *dev = devnode->media_dev;\r\nconst struct media_ioctl_info *info;\r\nvoid __user *arg = (void __user *)__arg;\r\nchar __karg[256], *karg = __karg;\r\nlong ret;\r\nif (_IOC_NR(cmd) >= ARRAY_SIZE(ioctl_info)\r\n|| ioctl_info[_IOC_NR(cmd)].cmd != cmd)\r\nreturn -ENOIOCTLCMD;\r\ninfo = &ioctl_info[_IOC_NR(cmd)];\r\nif (_IOC_SIZE(info->cmd) > sizeof(__karg)) {\r\nkarg = kmalloc(_IOC_SIZE(info->cmd), GFP_KERNEL);\r\nif (!karg)\r\nreturn -ENOMEM;\r\n}\r\nif (info->arg_from_user) {\r\nret = info->arg_from_user(karg, arg, cmd);\r\nif (ret)\r\ngoto out_free;\r\n}\r\nif (info->flags & MEDIA_IOC_FL_GRAPH_MUTEX)\r\nmutex_lock(&dev->graph_mutex);\r\nret = info->fn(dev, karg);\r\nif (info->flags & MEDIA_IOC_FL_GRAPH_MUTEX)\r\nmutex_unlock(&dev->graph_mutex);\r\nif (!ret && info->arg_to_user)\r\nret = info->arg_to_user(arg, karg, cmd);\r\nout_free:\r\nif (karg != __karg)\r\nkfree(karg);\r\nreturn ret;\r\n}\r\nstatic long media_device_enum_links32(struct media_device *mdev,\r\nstruct media_links_enum32 __user *ulinks)\r\n{\r\nstruct media_links_enum links;\r\ncompat_uptr_t pads_ptr, links_ptr;\r\nmemset(&links, 0, sizeof(links));\r\nif (get_user(links.entity, &ulinks->entity)\r\n|| get_user(pads_ptr, &ulinks->pads)\r\n|| get_user(links_ptr, &ulinks->links))\r\nreturn -EFAULT;\r\nlinks.pads = compat_ptr(pads_ptr);\r\nlinks.links = compat_ptr(links_ptr);\r\nreturn media_device_enum_links(mdev, &links);\r\n}\r\nstatic long media_device_compat_ioctl(struct file *filp, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct media_devnode *devnode = media_devnode_data(filp);\r\nstruct media_device *dev = devnode->media_dev;\r\nlong ret;\r\nswitch (cmd) {\r\ncase MEDIA_IOC_ENUM_LINKS32:\r\nmutex_lock(&dev->graph_mutex);\r\nret = media_device_enum_links32(dev,\r\n(struct media_links_enum32 __user *)arg);\r\nmutex_unlock(&dev->graph_mutex);\r\nbreak;\r\ndefault:\r\nreturn media_device_ioctl(filp, cmd, arg);\r\n}\r\nreturn ret;\r\n}\r\nstatic ssize_t show_model(struct device *cd,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct media_devnode *devnode = to_media_devnode(cd);\r\nstruct media_device *mdev = devnode->media_dev;\r\nreturn sprintf(buf, "%.*s\n", (int)sizeof(mdev->model), mdev->model);\r\n}\r\nstatic void media_device_release(struct media_devnode *mdev)\r\n{\r\ndev_dbg(mdev->parent, "Media device released\n");\r\n}\r\nint __must_check media_device_register_entity(struct media_device *mdev,\r\nstruct media_entity *entity)\r\n{\r\nstruct media_entity_notify *notify, *next;\r\nunsigned int i;\r\nint ret;\r\nif (entity->function == MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN ||\r\nentity->function == MEDIA_ENT_F_UNKNOWN)\r\ndev_warn(mdev->dev,\r\n"Entity type for entity %s was not initialized!\n",\r\nentity->name);\r\nWARN_ON(entity->graph_obj.mdev != NULL);\r\nentity->graph_obj.mdev = mdev;\r\nINIT_LIST_HEAD(&entity->links);\r\nentity->num_links = 0;\r\nentity->num_backlinks = 0;\r\nif (!ida_pre_get(&mdev->entity_internal_idx, GFP_KERNEL))\r\nreturn -ENOMEM;\r\nmutex_lock(&mdev->graph_mutex);\r\nret = ida_get_new_above(&mdev->entity_internal_idx, 1,\r\n&entity->internal_idx);\r\nif (ret < 0) {\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nmdev->entity_internal_idx_max =\r\nmax(mdev->entity_internal_idx_max, entity->internal_idx);\r\nmedia_gobj_create(mdev, MEDIA_GRAPH_ENTITY, &entity->graph_obj);\r\nfor (i = 0; i < entity->num_pads; i++)\r\nmedia_gobj_create(mdev, MEDIA_GRAPH_PAD,\r\n&entity->pads[i].graph_obj);\r\nlist_for_each_entry_safe(notify, next, &mdev->entity_notify, list) {\r\n(notify)->notify(entity, notify->notify_data);\r\n}\r\nif (mdev->entity_internal_idx_max\r\n>= mdev->pm_count_walk.ent_enum.idx_max) {\r\nstruct media_graph new = { .top = 0 };\r\nret = media_graph_walk_init(&new, mdev);\r\nif (ret) {\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn ret;\r\n}\r\nmedia_graph_walk_cleanup(&mdev->pm_count_walk);\r\nmdev->pm_count_walk = new;\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn 0;\r\n}\r\nstatic void __media_device_unregister_entity(struct media_entity *entity)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nstruct media_link *link, *tmp;\r\nstruct media_interface *intf;\r\nunsigned int i;\r\nida_simple_remove(&mdev->entity_internal_idx, entity->internal_idx);\r\nlist_for_each_entry(intf, &mdev->interfaces, graph_obj.list) {\r\nlist_for_each_entry_safe(link, tmp, &intf->links, list) {\r\nif (link->entity == entity)\r\n__media_remove_intf_link(link);\r\n}\r\n}\r\n__media_entity_remove_links(entity);\r\nfor (i = 0; i < entity->num_pads; i++)\r\nmedia_gobj_destroy(&entity->pads[i].graph_obj);\r\nmedia_gobj_destroy(&entity->graph_obj);\r\nentity->graph_obj.mdev = NULL;\r\n}\r\nvoid media_device_unregister_entity(struct media_entity *entity)\r\n{\r\nstruct media_device *mdev = entity->graph_obj.mdev;\r\nif (mdev == NULL)\r\nreturn;\r\nmutex_lock(&mdev->graph_mutex);\r\n__media_device_unregister_entity(entity);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nvoid media_device_init(struct media_device *mdev)\r\n{\r\nINIT_LIST_HEAD(&mdev->entities);\r\nINIT_LIST_HEAD(&mdev->interfaces);\r\nINIT_LIST_HEAD(&mdev->pads);\r\nINIT_LIST_HEAD(&mdev->links);\r\nINIT_LIST_HEAD(&mdev->entity_notify);\r\nmutex_init(&mdev->graph_mutex);\r\nida_init(&mdev->entity_internal_idx);\r\ndev_dbg(mdev->dev, "Media device initialized\n");\r\n}\r\nvoid media_device_cleanup(struct media_device *mdev)\r\n{\r\nida_destroy(&mdev->entity_internal_idx);\r\nmdev->entity_internal_idx_max = 0;\r\nmedia_graph_walk_cleanup(&mdev->pm_count_walk);\r\nmutex_destroy(&mdev->graph_mutex);\r\n}\r\nint __must_check __media_device_register(struct media_device *mdev,\r\nstruct module *owner)\r\n{\r\nstruct media_devnode *devnode;\r\nint ret;\r\ndevnode = kzalloc(sizeof(*devnode), GFP_KERNEL);\r\nif (!devnode)\r\nreturn -ENOMEM;\r\nmdev->devnode = devnode;\r\ndevnode->fops = &media_device_fops;\r\ndevnode->parent = mdev->dev;\r\ndevnode->release = media_device_release;\r\nmdev->topology_version = 0;\r\nret = media_devnode_register(mdev, devnode, owner);\r\nif (ret < 0) {\r\nmdev->devnode = NULL;\r\nreturn ret;\r\n}\r\nret = device_create_file(&devnode->dev, &dev_attr_model);\r\nif (ret < 0) {\r\nmdev->devnode = NULL;\r\nmedia_devnode_unregister_prepare(devnode);\r\nmedia_devnode_unregister(devnode);\r\nreturn ret;\r\n}\r\ndev_dbg(mdev->dev, "Media device registered\n");\r\nreturn 0;\r\n}\r\nint __must_check media_device_register_entity_notify(struct media_device *mdev,\r\nstruct media_entity_notify *nptr)\r\n{\r\nmutex_lock(&mdev->graph_mutex);\r\nlist_add_tail(&nptr->list, &mdev->entity_notify);\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn 0;\r\n}\r\nstatic void __media_device_unregister_entity_notify(struct media_device *mdev,\r\nstruct media_entity_notify *nptr)\r\n{\r\nlist_del(&nptr->list);\r\n}\r\nvoid media_device_unregister_entity_notify(struct media_device *mdev,\r\nstruct media_entity_notify *nptr)\r\n{\r\nmutex_lock(&mdev->graph_mutex);\r\n__media_device_unregister_entity_notify(mdev, nptr);\r\nmutex_unlock(&mdev->graph_mutex);\r\n}\r\nvoid media_device_unregister(struct media_device *mdev)\r\n{\r\nstruct media_entity *entity;\r\nstruct media_entity *next;\r\nstruct media_interface *intf, *tmp_intf;\r\nstruct media_entity_notify *notify, *nextp;\r\nif (mdev == NULL)\r\nreturn;\r\nmutex_lock(&mdev->graph_mutex);\r\nif (!media_devnode_is_registered(mdev->devnode)) {\r\nmutex_unlock(&mdev->graph_mutex);\r\nreturn;\r\n}\r\nmedia_devnode_unregister_prepare(mdev->devnode);\r\nlist_for_each_entry_safe(entity, next, &mdev->entities, graph_obj.list)\r\n__media_device_unregister_entity(entity);\r\nlist_for_each_entry_safe(notify, nextp, &mdev->entity_notify, list)\r\n__media_device_unregister_entity_notify(mdev, notify);\r\nlist_for_each_entry_safe(intf, tmp_intf, &mdev->interfaces,\r\ngraph_obj.list) {\r\n__media_remove_intf_links(intf);\r\nmedia_gobj_destroy(&intf->graph_obj);\r\n}\r\nmutex_unlock(&mdev->graph_mutex);\r\ndev_dbg(mdev->dev, "Media device unregistered\n");\r\ndevice_remove_file(&mdev->devnode->dev, &dev_attr_model);\r\nmedia_devnode_unregister(mdev->devnode);\r\nmdev->devnode = NULL;\r\n}\r\nvoid media_device_pci_init(struct media_device *mdev,\r\nstruct pci_dev *pci_dev,\r\nconst char *name)\r\n{\r\nmdev->dev = &pci_dev->dev;\r\nif (name)\r\nstrlcpy(mdev->model, name, sizeof(mdev->model));\r\nelse\r\nstrlcpy(mdev->model, pci_name(pci_dev), sizeof(mdev->model));\r\nsprintf(mdev->bus_info, "PCI:%s", pci_name(pci_dev));\r\nmdev->hw_revision = (pci_dev->subsystem_vendor << 16)\r\n| pci_dev->subsystem_device;\r\nmdev->driver_version = LINUX_VERSION_CODE;\r\nmedia_device_init(mdev);\r\n}\r\nvoid __media_device_usb_init(struct media_device *mdev,\r\nstruct usb_device *udev,\r\nconst char *board_name,\r\nconst char *driver_name)\r\n{\r\nmdev->dev = &udev->dev;\r\nif (driver_name)\r\nstrlcpy(mdev->driver_name, driver_name,\r\nsizeof(mdev->driver_name));\r\nif (board_name)\r\nstrlcpy(mdev->model, board_name, sizeof(mdev->model));\r\nelse if (udev->product)\r\nstrlcpy(mdev->model, udev->product, sizeof(mdev->model));\r\nelse\r\nstrlcpy(mdev->model, "unknown model", sizeof(mdev->model));\r\nif (udev->serial)\r\nstrlcpy(mdev->serial, udev->serial, sizeof(mdev->serial));\r\nusb_make_path(udev, mdev->bus_info, sizeof(mdev->bus_info));\r\nmdev->hw_revision = le16_to_cpu(udev->descriptor.bcdDevice);\r\nmdev->driver_version = LINUX_VERSION_CODE;\r\nmedia_device_init(mdev);\r\n}
