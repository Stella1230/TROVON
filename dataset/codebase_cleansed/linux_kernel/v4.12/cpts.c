static int event_expired(struct cpts_event *event)\r\n{\r\nreturn time_after(jiffies, event->tmo);\r\n}\r\nstatic int event_type(struct cpts_event *event)\r\n{\r\nreturn (event->high >> EVENT_TYPE_SHIFT) & EVENT_TYPE_MASK;\r\n}\r\nstatic int cpts_fifo_pop(struct cpts *cpts, u32 *high, u32 *low)\r\n{\r\nu32 r = cpts_read32(cpts, intstat_raw);\r\nif (r & TS_PEND_RAW) {\r\n*high = cpts_read32(cpts, event_high);\r\n*low = cpts_read32(cpts, event_low);\r\ncpts_write32(cpts, EVENT_POP, event_pop);\r\nreturn 0;\r\n}\r\nreturn -1;\r\n}\r\nstatic int cpts_purge_events(struct cpts *cpts)\r\n{\r\nstruct list_head *this, *next;\r\nstruct cpts_event *event;\r\nint removed = 0;\r\nlist_for_each_safe(this, next, &cpts->events) {\r\nevent = list_entry(this, struct cpts_event, list);\r\nif (event_expired(event)) {\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\n++removed;\r\n}\r\n}\r\nif (removed)\r\npr_debug("cpts: event pool cleaned up %d\n", removed);\r\nreturn removed ? 0 : -1;\r\n}\r\nstatic int cpts_fifo_read(struct cpts *cpts, int match)\r\n{\r\nint i, type = -1;\r\nu32 hi, lo;\r\nstruct cpts_event *event;\r\nfor (i = 0; i < CPTS_FIFO_DEPTH; i++) {\r\nif (cpts_fifo_pop(cpts, &hi, &lo))\r\nbreak;\r\nif (list_empty(&cpts->pool) && cpts_purge_events(cpts)) {\r\npr_err("cpts: event pool empty\n");\r\nreturn -1;\r\n}\r\nevent = list_first_entry(&cpts->pool, struct cpts_event, list);\r\nevent->tmo = jiffies + 2;\r\nevent->high = hi;\r\nevent->low = lo;\r\ntype = event_type(event);\r\nswitch (type) {\r\ncase CPTS_EV_PUSH:\r\ncase CPTS_EV_RX:\r\ncase CPTS_EV_TX:\r\nlist_del_init(&event->list);\r\nlist_add_tail(&event->list, &cpts->events);\r\nbreak;\r\ncase CPTS_EV_ROLL:\r\ncase CPTS_EV_HALF:\r\ncase CPTS_EV_HW:\r\nbreak;\r\ndefault:\r\npr_err("cpts: unknown event type\n");\r\nbreak;\r\n}\r\nif (type == match)\r\nbreak;\r\n}\r\nreturn type == match ? 0 : -1;\r\n}\r\nstatic u64 cpts_systim_read(const struct cyclecounter *cc)\r\n{\r\nu64 val = 0;\r\nstruct cpts_event *event;\r\nstruct list_head *this, *next;\r\nstruct cpts *cpts = container_of(cc, struct cpts, cc);\r\ncpts_write32(cpts, TS_PUSH, ts_push);\r\nif (cpts_fifo_read(cpts, CPTS_EV_PUSH))\r\npr_err("cpts: unable to obtain a time stamp\n");\r\nlist_for_each_safe(this, next, &cpts->events) {\r\nevent = list_entry(this, struct cpts_event, list);\r\nif (event_type(event) == CPTS_EV_PUSH) {\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\nval = event->low;\r\nbreak;\r\n}\r\n}\r\nreturn val;\r\n}\r\nstatic int cpts_ptp_adjfreq(struct ptp_clock_info *ptp, s32 ppb)\r\n{\r\nu64 adj;\r\nu32 diff, mult;\r\nint neg_adj = 0;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nif (ppb < 0) {\r\nneg_adj = 1;\r\nppb = -ppb;\r\n}\r\nmult = cpts->cc_mult;\r\nadj = mult;\r\nadj *= ppb;\r\ndiff = div_u64(adj, 1000000000ULL);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ntimecounter_read(&cpts->tc);\r\ncpts->cc.mult = neg_adj ? mult - diff : mult + diff;\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ntimecounter_adjtime(&cpts->tc, delta);\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\nns = timecounter_read(&cpts->tc);\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\n*ts = ns_to_timespec64(ns);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *ts)\r\n{\r\nu64 ns;\r\nunsigned long flags;\r\nstruct cpts *cpts = container_of(ptp, struct cpts, info);\r\nns = timespec64_to_ns(ts);\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ntimecounter_init(&cpts->tc, &cpts->cc, ns);\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int cpts_ptp_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *rq, int on)\r\n{\r\nreturn -EOPNOTSUPP;\r\n}\r\nstatic void cpts_overflow_check(struct work_struct *work)\r\n{\r\nstruct timespec64 ts;\r\nstruct cpts *cpts = container_of(work, struct cpts, overflow_work.work);\r\ncpts_ptp_gettime(&cpts->info, &ts);\r\npr_debug("cpts overflow check at %lld.%09lu\n", ts.tv_sec, ts.tv_nsec);\r\nschedule_delayed_work(&cpts->overflow_work, cpts->ov_check_period);\r\n}\r\nstatic int cpts_match(struct sk_buff *skb, unsigned int ptp_class,\r\nu16 ts_seqid, u8 ts_msgtype)\r\n{\r\nu16 *seqid;\r\nunsigned int offset = 0;\r\nu8 *msgtype, *data = skb->data;\r\nif (ptp_class & PTP_CLASS_VLAN)\r\noffset += VLAN_HLEN;\r\nswitch (ptp_class & PTP_CLASS_PMASK) {\r\ncase PTP_CLASS_IPV4:\r\noffset += ETH_HLEN + IPV4_HLEN(data + offset) + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_IPV6:\r\noffset += ETH_HLEN + IP6_HLEN + UDP_HLEN;\r\nbreak;\r\ncase PTP_CLASS_L2:\r\noffset += ETH_HLEN;\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nif (skb->len + ETH_HLEN < offset + OFF_PTP_SEQUENCE_ID + sizeof(*seqid))\r\nreturn 0;\r\nif (unlikely(ptp_class & PTP_CLASS_V1))\r\nmsgtype = data + offset + OFF_PTP_CONTROL;\r\nelse\r\nmsgtype = data + offset;\r\nseqid = (u16 *)(data + offset + OFF_PTP_SEQUENCE_ID);\r\nreturn (ts_msgtype == (*msgtype & 0xf) && ts_seqid == ntohs(*seqid));\r\n}\r\nstatic u64 cpts_find_ts(struct cpts *cpts, struct sk_buff *skb, int ev_type)\r\n{\r\nu64 ns = 0;\r\nstruct cpts_event *event;\r\nstruct list_head *this, *next;\r\nunsigned int class = ptp_classify_raw(skb);\r\nunsigned long flags;\r\nu16 seqid;\r\nu8 mtype;\r\nif (class == PTP_CLASS_NONE)\r\nreturn 0;\r\nspin_lock_irqsave(&cpts->lock, flags);\r\ncpts_fifo_read(cpts, CPTS_EV_PUSH);\r\nlist_for_each_safe(this, next, &cpts->events) {\r\nevent = list_entry(this, struct cpts_event, list);\r\nif (event_expired(event)) {\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\ncontinue;\r\n}\r\nmtype = (event->high >> MESSAGE_TYPE_SHIFT) & MESSAGE_TYPE_MASK;\r\nseqid = (event->high >> SEQUENCE_ID_SHIFT) & SEQUENCE_ID_MASK;\r\nif (ev_type == event_type(event) &&\r\ncpts_match(skb, class, seqid, mtype)) {\r\nns = timecounter_cyc2time(&cpts->tc, event->low);\r\nlist_del_init(&event->list);\r\nlist_add(&event->list, &cpts->pool);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&cpts->lock, flags);\r\nreturn ns;\r\n}\r\nvoid cpts_rx_timestamp(struct cpts *cpts, struct sk_buff *skb)\r\n{\r\nu64 ns;\r\nstruct skb_shared_hwtstamps *ssh;\r\nif (!cpts->rx_enable)\r\nreturn;\r\nns = cpts_find_ts(cpts, skb, CPTS_EV_RX);\r\nif (!ns)\r\nreturn;\r\nssh = skb_hwtstamps(skb);\r\nmemset(ssh, 0, sizeof(*ssh));\r\nssh->hwtstamp = ns_to_ktime(ns);\r\n}\r\nvoid cpts_tx_timestamp(struct cpts *cpts, struct sk_buff *skb)\r\n{\r\nu64 ns;\r\nstruct skb_shared_hwtstamps ssh;\r\nif (!(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS))\r\nreturn;\r\nns = cpts_find_ts(cpts, skb, CPTS_EV_TX);\r\nif (!ns)\r\nreturn;\r\nmemset(&ssh, 0, sizeof(ssh));\r\nssh.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(skb, &ssh);\r\n}\r\nint cpts_register(struct cpts *cpts)\r\n{\r\nint err, i;\r\nINIT_LIST_HEAD(&cpts->events);\r\nINIT_LIST_HEAD(&cpts->pool);\r\nfor (i = 0; i < CPTS_MAX_EVENTS; i++)\r\nlist_add(&cpts->pool_data[i].list, &cpts->pool);\r\nclk_enable(cpts->refclk);\r\ncpts_write32(cpts, CPTS_EN, control);\r\ncpts_write32(cpts, TS_PEND_EN, int_enable);\r\ntimecounter_init(&cpts->tc, &cpts->cc, ktime_to_ns(ktime_get_real()));\r\ncpts->clock = ptp_clock_register(&cpts->info, cpts->dev);\r\nif (IS_ERR(cpts->clock)) {\r\nerr = PTR_ERR(cpts->clock);\r\ncpts->clock = NULL;\r\ngoto err_ptp;\r\n}\r\ncpts->phc_index = ptp_clock_index(cpts->clock);\r\nschedule_delayed_work(&cpts->overflow_work, cpts->ov_check_period);\r\nreturn 0;\r\nerr_ptp:\r\nclk_disable(cpts->refclk);\r\nreturn err;\r\n}\r\nvoid cpts_unregister(struct cpts *cpts)\r\n{\r\nif (WARN_ON(!cpts->clock))\r\nreturn;\r\ncancel_delayed_work_sync(&cpts->overflow_work);\r\nptp_clock_unregister(cpts->clock);\r\ncpts->clock = NULL;\r\ncpts_write32(cpts, 0, int_enable);\r\ncpts_write32(cpts, 0, control);\r\nclk_disable(cpts->refclk);\r\n}\r\nstatic void cpts_calc_mult_shift(struct cpts *cpts)\r\n{\r\nu64 frac, maxsec, ns;\r\nu32 freq;\r\nfreq = clk_get_rate(cpts->refclk);\r\nmaxsec = cpts->cc.mask;\r\ndo_div(maxsec, freq);\r\nif (maxsec > 10)\r\nmaxsec = 10;\r\ncpts->ov_check_period = (HZ * maxsec) / 2;\r\ndev_info(cpts->dev, "cpts: overflow check period %lu (jiffies)\n",\r\ncpts->ov_check_period);\r\nif (cpts->cc.mult || cpts->cc.shift)\r\nreturn;\r\nclocks_calc_mult_shift(&cpts->cc.mult, &cpts->cc.shift,\r\nfreq, NSEC_PER_SEC, maxsec);\r\nfrac = 0;\r\nns = cyclecounter_cyc2ns(&cpts->cc, freq, cpts->cc.mask, &frac);\r\ndev_info(cpts->dev,\r\n"CPTS: ref_clk_freq:%u calc_mult:%u calc_shift:%u error:%lld nsec/sec\n",\r\nfreq, cpts->cc.mult, cpts->cc.shift, (ns - NSEC_PER_SEC));\r\n}\r\nstatic int cpts_of_parse(struct cpts *cpts, struct device_node *node)\r\n{\r\nint ret = -EINVAL;\r\nu32 prop;\r\nif (!of_property_read_u32(node, "cpts_clock_mult", &prop))\r\ncpts->cc.mult = prop;\r\nif (!of_property_read_u32(node, "cpts_clock_shift", &prop))\r\ncpts->cc.shift = prop;\r\nif ((cpts->cc.mult && !cpts->cc.shift) ||\r\n(!cpts->cc.mult && cpts->cc.shift))\r\ngoto of_error;\r\nreturn 0;\r\nof_error:\r\ndev_err(cpts->dev, "CPTS: Missing property in the DT.\n");\r\nreturn ret;\r\n}\r\nstruct cpts *cpts_create(struct device *dev, void __iomem *regs,\r\nstruct device_node *node)\r\n{\r\nstruct cpts *cpts;\r\nint ret;\r\ncpts = devm_kzalloc(dev, sizeof(*cpts), GFP_KERNEL);\r\nif (!cpts)\r\nreturn ERR_PTR(-ENOMEM);\r\ncpts->dev = dev;\r\ncpts->reg = (struct cpsw_cpts __iomem *)regs;\r\nspin_lock_init(&cpts->lock);\r\nINIT_DELAYED_WORK(&cpts->overflow_work, cpts_overflow_check);\r\nret = cpts_of_parse(cpts, node);\r\nif (ret)\r\nreturn ERR_PTR(ret);\r\ncpts->refclk = devm_clk_get(dev, "cpts");\r\nif (IS_ERR(cpts->refclk)) {\r\ndev_err(dev, "Failed to get cpts refclk\n");\r\nreturn ERR_PTR(PTR_ERR(cpts->refclk));\r\n}\r\nclk_prepare(cpts->refclk);\r\ncpts->cc.read = cpts_systim_read;\r\ncpts->cc.mask = CLOCKSOURCE_MASK(32);\r\ncpts->info = cpts_info;\r\ncpts_calc_mult_shift(cpts);\r\ncpts->cc_mult = cpts->cc.mult;\r\nreturn cpts;\r\n}\r\nvoid cpts_release(struct cpts *cpts)\r\n{\r\nif (!cpts)\r\nreturn;\r\nif (WARN_ON(!cpts->refclk))\r\nreturn;\r\nclk_unprepare(cpts->refclk);\r\n}
