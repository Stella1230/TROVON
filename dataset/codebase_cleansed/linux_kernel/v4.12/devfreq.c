static struct devfreq *find_device_devfreq(struct device *dev)\r\n{\r\nstruct devfreq *tmp_devfreq;\r\nif (IS_ERR_OR_NULL(dev)) {\r\npr_err("DEVFREQ: %s: Invalid parameters\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nWARN(!mutex_is_locked(&devfreq_list_lock),\r\n"devfreq_list_lock must be locked.");\r\nlist_for_each_entry(tmp_devfreq, &devfreq_list, node) {\r\nif (tmp_devfreq->dev.parent == dev)\r\nreturn tmp_devfreq;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int devfreq_get_freq_level(struct devfreq *devfreq, unsigned long freq)\r\n{\r\nint lev;\r\nfor (lev = 0; lev < devfreq->profile->max_state; lev++)\r\nif (freq == devfreq->profile->freq_table[lev])\r\nreturn lev;\r\nreturn -EINVAL;\r\n}\r\nstatic void devfreq_set_freq_table(struct devfreq *devfreq)\r\n{\r\nstruct devfreq_dev_profile *profile = devfreq->profile;\r\nstruct dev_pm_opp *opp;\r\nunsigned long freq;\r\nint i, count;\r\ncount = dev_pm_opp_get_opp_count(devfreq->dev.parent);\r\nif (count <= 0)\r\nreturn;\r\nprofile->max_state = count;\r\nprofile->freq_table = devm_kcalloc(devfreq->dev.parent,\r\nprofile->max_state,\r\nsizeof(*profile->freq_table),\r\nGFP_KERNEL);\r\nif (!profile->freq_table) {\r\nprofile->max_state = 0;\r\nreturn;\r\n}\r\nfor (i = 0, freq = 0; i < profile->max_state; i++, freq++) {\r\nopp = dev_pm_opp_find_freq_ceil(devfreq->dev.parent, &freq);\r\nif (IS_ERR(opp)) {\r\ndevm_kfree(devfreq->dev.parent, profile->freq_table);\r\nprofile->max_state = 0;\r\nreturn;\r\n}\r\ndev_pm_opp_put(opp);\r\nprofile->freq_table[i] = freq;\r\n}\r\n}\r\nint devfreq_update_status(struct devfreq *devfreq, unsigned long freq)\r\n{\r\nint lev, prev_lev, ret = 0;\r\nunsigned long cur_time;\r\ncur_time = jiffies;\r\nif (!devfreq->previous_freq)\r\ngoto out;\r\nprev_lev = devfreq_get_freq_level(devfreq, devfreq->previous_freq);\r\nif (prev_lev < 0) {\r\nret = prev_lev;\r\ngoto out;\r\n}\r\ndevfreq->time_in_state[prev_lev] +=\r\ncur_time - devfreq->last_stat_updated;\r\nlev = devfreq_get_freq_level(devfreq, freq);\r\nif (lev < 0) {\r\nret = lev;\r\ngoto out;\r\n}\r\nif (lev != prev_lev) {\r\ndevfreq->trans_table[(prev_lev *\r\ndevfreq->profile->max_state) + lev]++;\r\ndevfreq->total_trans++;\r\n}\r\nout:\r\ndevfreq->last_stat_updated = cur_time;\r\nreturn ret;\r\n}\r\nstatic struct devfreq_governor *find_devfreq_governor(const char *name)\r\n{\r\nstruct devfreq_governor *tmp_governor;\r\nif (IS_ERR_OR_NULL(name)) {\r\npr_err("DEVFREQ: %s: Invalid parameters\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nWARN(!mutex_is_locked(&devfreq_list_lock),\r\n"devfreq_list_lock must be locked.");\r\nlist_for_each_entry(tmp_governor, &devfreq_governor_list, node) {\r\nif (!strncmp(tmp_governor->name, name, DEVFREQ_NAME_LEN))\r\nreturn tmp_governor;\r\n}\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nstatic int devfreq_notify_transition(struct devfreq *devfreq,\r\nstruct devfreq_freqs *freqs, unsigned int state)\r\n{\r\nif (!devfreq)\r\nreturn -EINVAL;\r\nswitch (state) {\r\ncase DEVFREQ_PRECHANGE:\r\nsrcu_notifier_call_chain(&devfreq->transition_notifier_list,\r\nDEVFREQ_PRECHANGE, freqs);\r\nbreak;\r\ncase DEVFREQ_POSTCHANGE:\r\nsrcu_notifier_call_chain(&devfreq->transition_notifier_list,\r\nDEVFREQ_POSTCHANGE, freqs);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint update_devfreq(struct devfreq *devfreq)\r\n{\r\nstruct devfreq_freqs freqs;\r\nunsigned long freq, cur_freq;\r\nint err = 0;\r\nu32 flags = 0;\r\nif (!mutex_is_locked(&devfreq->lock)) {\r\nWARN(true, "devfreq->lock must be locked by the caller.\n");\r\nreturn -EINVAL;\r\n}\r\nif (!devfreq->governor)\r\nreturn -EINVAL;\r\nerr = devfreq->governor->get_target_freq(devfreq, &freq);\r\nif (err)\r\nreturn err;\r\nif (devfreq->min_freq && freq < devfreq->min_freq) {\r\nfreq = devfreq->min_freq;\r\nflags &= ~DEVFREQ_FLAG_LEAST_UPPER_BOUND;\r\n}\r\nif (devfreq->max_freq && freq > devfreq->max_freq) {\r\nfreq = devfreq->max_freq;\r\nflags |= DEVFREQ_FLAG_LEAST_UPPER_BOUND;\r\n}\r\nif (devfreq->profile->get_cur_freq)\r\ndevfreq->profile->get_cur_freq(devfreq->dev.parent, &cur_freq);\r\nelse\r\ncur_freq = devfreq->previous_freq;\r\nfreqs.old = cur_freq;\r\nfreqs.new = freq;\r\ndevfreq_notify_transition(devfreq, &freqs, DEVFREQ_PRECHANGE);\r\nerr = devfreq->profile->target(devfreq->dev.parent, &freq, flags);\r\nif (err) {\r\nfreqs.new = cur_freq;\r\ndevfreq_notify_transition(devfreq, &freqs, DEVFREQ_POSTCHANGE);\r\nreturn err;\r\n}\r\nfreqs.new = freq;\r\ndevfreq_notify_transition(devfreq, &freqs, DEVFREQ_POSTCHANGE);\r\nif (devfreq->profile->freq_table)\r\nif (devfreq_update_status(devfreq, freq))\r\ndev_err(&devfreq->dev,\r\n"Couldn't update frequency transition information.\n");\r\ndevfreq->previous_freq = freq;\r\nreturn err;\r\n}\r\nstatic void devfreq_monitor(struct work_struct *work)\r\n{\r\nint err;\r\nstruct devfreq *devfreq = container_of(work,\r\nstruct devfreq, work.work);\r\nmutex_lock(&devfreq->lock);\r\nerr = update_devfreq(devfreq);\r\nif (err)\r\ndev_err(&devfreq->dev, "dvfs failed with (%d) error\n", err);\r\nqueue_delayed_work(devfreq_wq, &devfreq->work,\r\nmsecs_to_jiffies(devfreq->profile->polling_ms));\r\nmutex_unlock(&devfreq->lock);\r\n}\r\nvoid devfreq_monitor_start(struct devfreq *devfreq)\r\n{\r\nINIT_DEFERRABLE_WORK(&devfreq->work, devfreq_monitor);\r\nif (devfreq->profile->polling_ms)\r\nqueue_delayed_work(devfreq_wq, &devfreq->work,\r\nmsecs_to_jiffies(devfreq->profile->polling_ms));\r\n}\r\nvoid devfreq_monitor_stop(struct devfreq *devfreq)\r\n{\r\ncancel_delayed_work_sync(&devfreq->work);\r\n}\r\nvoid devfreq_monitor_suspend(struct devfreq *devfreq)\r\n{\r\nmutex_lock(&devfreq->lock);\r\nif (devfreq->stop_polling) {\r\nmutex_unlock(&devfreq->lock);\r\nreturn;\r\n}\r\ndevfreq_update_status(devfreq, devfreq->previous_freq);\r\ndevfreq->stop_polling = true;\r\nmutex_unlock(&devfreq->lock);\r\ncancel_delayed_work_sync(&devfreq->work);\r\n}\r\nvoid devfreq_monitor_resume(struct devfreq *devfreq)\r\n{\r\nunsigned long freq;\r\nmutex_lock(&devfreq->lock);\r\nif (!devfreq->stop_polling)\r\ngoto out;\r\nif (!delayed_work_pending(&devfreq->work) &&\r\ndevfreq->profile->polling_ms)\r\nqueue_delayed_work(devfreq_wq, &devfreq->work,\r\nmsecs_to_jiffies(devfreq->profile->polling_ms));\r\ndevfreq->last_stat_updated = jiffies;\r\ndevfreq->stop_polling = false;\r\nif (devfreq->profile->get_cur_freq &&\r\n!devfreq->profile->get_cur_freq(devfreq->dev.parent, &freq))\r\ndevfreq->previous_freq = freq;\r\nout:\r\nmutex_unlock(&devfreq->lock);\r\n}\r\nvoid devfreq_interval_update(struct devfreq *devfreq, unsigned int *delay)\r\n{\r\nunsigned int cur_delay = devfreq->profile->polling_ms;\r\nunsigned int new_delay = *delay;\r\nmutex_lock(&devfreq->lock);\r\ndevfreq->profile->polling_ms = new_delay;\r\nif (devfreq->stop_polling)\r\ngoto out;\r\nif (!new_delay) {\r\nmutex_unlock(&devfreq->lock);\r\ncancel_delayed_work_sync(&devfreq->work);\r\nreturn;\r\n}\r\nif (!cur_delay) {\r\nqueue_delayed_work(devfreq_wq, &devfreq->work,\r\nmsecs_to_jiffies(devfreq->profile->polling_ms));\r\ngoto out;\r\n}\r\nif (cur_delay > new_delay) {\r\nmutex_unlock(&devfreq->lock);\r\ncancel_delayed_work_sync(&devfreq->work);\r\nmutex_lock(&devfreq->lock);\r\nif (!devfreq->stop_polling)\r\nqueue_delayed_work(devfreq_wq, &devfreq->work,\r\nmsecs_to_jiffies(devfreq->profile->polling_ms));\r\n}\r\nout:\r\nmutex_unlock(&devfreq->lock);\r\n}\r\nstatic int devfreq_notifier_call(struct notifier_block *nb, unsigned long type,\r\nvoid *devp)\r\n{\r\nstruct devfreq *devfreq = container_of(nb, struct devfreq, nb);\r\nint ret;\r\nmutex_lock(&devfreq->lock);\r\nret = update_devfreq(devfreq);\r\nmutex_unlock(&devfreq->lock);\r\nreturn ret;\r\n}\r\nstatic void devfreq_dev_release(struct device *dev)\r\n{\r\nstruct devfreq *devfreq = to_devfreq(dev);\r\nmutex_lock(&devfreq_list_lock);\r\nif (IS_ERR(find_device_devfreq(devfreq->dev.parent))) {\r\nmutex_unlock(&devfreq_list_lock);\r\ndev_warn(&devfreq->dev, "releasing devfreq which doesn't exist\n");\r\nreturn;\r\n}\r\nlist_del(&devfreq->node);\r\nmutex_unlock(&devfreq_list_lock);\r\nif (devfreq->governor)\r\ndevfreq->governor->event_handler(devfreq,\r\nDEVFREQ_GOV_STOP, NULL);\r\nif (devfreq->profile->exit)\r\ndevfreq->profile->exit(devfreq->dev.parent);\r\nmutex_destroy(&devfreq->lock);\r\nkfree(devfreq);\r\n}\r\nstruct devfreq *devfreq_add_device(struct device *dev,\r\nstruct devfreq_dev_profile *profile,\r\nconst char *governor_name,\r\nvoid *data)\r\n{\r\nstruct devfreq *devfreq;\r\nstruct devfreq_governor *governor;\r\nstatic atomic_t devfreq_no = ATOMIC_INIT(-1);\r\nint err = 0;\r\nif (!dev || !profile || !governor_name) {\r\ndev_err(dev, "%s: Invalid parameters.\n", __func__);\r\nreturn ERR_PTR(-EINVAL);\r\n}\r\nmutex_lock(&devfreq_list_lock);\r\ndevfreq = find_device_devfreq(dev);\r\nmutex_unlock(&devfreq_list_lock);\r\nif (!IS_ERR(devfreq)) {\r\ndev_err(dev, "%s: Unable to create devfreq for the device.\n",\r\n__func__);\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\ndevfreq = kzalloc(sizeof(struct devfreq), GFP_KERNEL);\r\nif (!devfreq) {\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nmutex_init(&devfreq->lock);\r\nmutex_lock(&devfreq->lock);\r\ndevfreq->dev.parent = dev;\r\ndevfreq->dev.class = devfreq_class;\r\ndevfreq->dev.release = devfreq_dev_release;\r\ndevfreq->profile = profile;\r\nstrncpy(devfreq->governor_name, governor_name, DEVFREQ_NAME_LEN);\r\ndevfreq->previous_freq = profile->initial_freq;\r\ndevfreq->last_status.current_frequency = profile->initial_freq;\r\ndevfreq->data = data;\r\ndevfreq->nb.notifier_call = devfreq_notifier_call;\r\nif (!devfreq->profile->max_state && !devfreq->profile->freq_table) {\r\nmutex_unlock(&devfreq->lock);\r\ndevfreq_set_freq_table(devfreq);\r\nmutex_lock(&devfreq->lock);\r\n}\r\ndev_set_name(&devfreq->dev, "devfreq%d",\r\natomic_inc_return(&devfreq_no));\r\nerr = device_register(&devfreq->dev);\r\nif (err) {\r\nmutex_unlock(&devfreq->lock);\r\ngoto err_out;\r\n}\r\ndevfreq->trans_table = devm_kzalloc(&devfreq->dev,\r\nsizeof(unsigned int) *\r\ndevfreq->profile->max_state *\r\ndevfreq->profile->max_state,\r\nGFP_KERNEL);\r\ndevfreq->time_in_state = devm_kzalloc(&devfreq->dev,\r\nsizeof(unsigned long) *\r\ndevfreq->profile->max_state,\r\nGFP_KERNEL);\r\ndevfreq->last_stat_updated = jiffies;\r\nsrcu_init_notifier_head(&devfreq->transition_notifier_list);\r\nmutex_unlock(&devfreq->lock);\r\nmutex_lock(&devfreq_list_lock);\r\nlist_add(&devfreq->node, &devfreq_list);\r\ngovernor = find_devfreq_governor(devfreq->governor_name);\r\nif (IS_ERR(governor)) {\r\ndev_err(dev, "%s: Unable to find governor for the device\n",\r\n__func__);\r\nerr = PTR_ERR(governor);\r\ngoto err_init;\r\n}\r\ndevfreq->governor = governor;\r\nerr = devfreq->governor->event_handler(devfreq, DEVFREQ_GOV_START,\r\nNULL);\r\nif (err) {\r\ndev_err(dev, "%s: Unable to start governor for the device\n",\r\n__func__);\r\ngoto err_init;\r\n}\r\nmutex_unlock(&devfreq_list_lock);\r\nreturn devfreq;\r\nerr_init:\r\nlist_del(&devfreq->node);\r\nmutex_unlock(&devfreq_list_lock);\r\ndevice_unregister(&devfreq->dev);\r\nerr_out:\r\nreturn ERR_PTR(err);\r\n}\r\nint devfreq_remove_device(struct devfreq *devfreq)\r\n{\r\nif (!devfreq)\r\nreturn -EINVAL;\r\ndevice_unregister(&devfreq->dev);\r\nreturn 0;\r\n}\r\nstatic int devm_devfreq_dev_match(struct device *dev, void *res, void *data)\r\n{\r\nstruct devfreq **r = res;\r\nif (WARN_ON(!r || !*r))\r\nreturn 0;\r\nreturn *r == data;\r\n}\r\nstatic void devm_devfreq_dev_release(struct device *dev, void *res)\r\n{\r\ndevfreq_remove_device(*(struct devfreq **)res);\r\n}\r\nstruct devfreq *devm_devfreq_add_device(struct device *dev,\r\nstruct devfreq_dev_profile *profile,\r\nconst char *governor_name,\r\nvoid *data)\r\n{\r\nstruct devfreq **ptr, *devfreq;\r\nptr = devres_alloc(devm_devfreq_dev_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn ERR_PTR(-ENOMEM);\r\ndevfreq = devfreq_add_device(dev, profile, governor_name, data);\r\nif (IS_ERR(devfreq)) {\r\ndevres_free(ptr);\r\nreturn ERR_PTR(-ENOMEM);\r\n}\r\n*ptr = devfreq;\r\ndevres_add(dev, ptr);\r\nreturn devfreq;\r\n}\r\nstruct devfreq *devfreq_get_devfreq_by_phandle(struct device *dev, int index)\r\n{\r\nstruct device_node *node;\r\nstruct devfreq *devfreq;\r\nif (!dev)\r\nreturn ERR_PTR(-EINVAL);\r\nif (!dev->of_node)\r\nreturn ERR_PTR(-EINVAL);\r\nnode = of_parse_phandle(dev->of_node, "devfreq", index);\r\nif (!node)\r\nreturn ERR_PTR(-ENODEV);\r\nmutex_lock(&devfreq_list_lock);\r\nlist_for_each_entry(devfreq, &devfreq_list, node) {\r\nif (devfreq->dev.parent\r\n&& devfreq->dev.parent->of_node == node) {\r\nmutex_unlock(&devfreq_list_lock);\r\nof_node_put(node);\r\nreturn devfreq;\r\n}\r\n}\r\nmutex_unlock(&devfreq_list_lock);\r\nof_node_put(node);\r\nreturn ERR_PTR(-EPROBE_DEFER);\r\n}\r\nstruct devfreq *devfreq_get_devfreq_by_phandle(struct device *dev, int index)\r\n{\r\nreturn ERR_PTR(-ENODEV);\r\n}\r\nvoid devm_devfreq_remove_device(struct device *dev, struct devfreq *devfreq)\r\n{\r\nWARN_ON(devres_release(dev, devm_devfreq_dev_release,\r\ndevm_devfreq_dev_match, devfreq));\r\n}\r\nint devfreq_suspend_device(struct devfreq *devfreq)\r\n{\r\nif (!devfreq)\r\nreturn -EINVAL;\r\nif (!devfreq->governor)\r\nreturn 0;\r\nreturn devfreq->governor->event_handler(devfreq,\r\nDEVFREQ_GOV_SUSPEND, NULL);\r\n}\r\nint devfreq_resume_device(struct devfreq *devfreq)\r\n{\r\nif (!devfreq)\r\nreturn -EINVAL;\r\nif (!devfreq->governor)\r\nreturn 0;\r\nreturn devfreq->governor->event_handler(devfreq,\r\nDEVFREQ_GOV_RESUME, NULL);\r\n}\r\nint devfreq_add_governor(struct devfreq_governor *governor)\r\n{\r\nstruct devfreq_governor *g;\r\nstruct devfreq *devfreq;\r\nint err = 0;\r\nif (!governor) {\r\npr_err("%s: Invalid parameters.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&devfreq_list_lock);\r\ng = find_devfreq_governor(governor->name);\r\nif (!IS_ERR(g)) {\r\npr_err("%s: governor %s already registered\n", __func__,\r\ng->name);\r\nerr = -EINVAL;\r\ngoto err_out;\r\n}\r\nlist_add(&governor->node, &devfreq_governor_list);\r\nlist_for_each_entry(devfreq, &devfreq_list, node) {\r\nint ret = 0;\r\nstruct device *dev = devfreq->dev.parent;\r\nif (!strncmp(devfreq->governor_name, governor->name,\r\nDEVFREQ_NAME_LEN)) {\r\nif (devfreq->governor) {\r\ndev_warn(dev,\r\n"%s: Governor %s already present\n",\r\n__func__, devfreq->governor->name);\r\nret = devfreq->governor->event_handler(devfreq,\r\nDEVFREQ_GOV_STOP, NULL);\r\nif (ret) {\r\ndev_warn(dev,\r\n"%s: Governor %s stop = %d\n",\r\n__func__,\r\ndevfreq->governor->name, ret);\r\n}\r\n}\r\ndevfreq->governor = governor;\r\nret = devfreq->governor->event_handler(devfreq,\r\nDEVFREQ_GOV_START, NULL);\r\nif (ret) {\r\ndev_warn(dev, "%s: Governor %s start=%d\n",\r\n__func__, devfreq->governor->name,\r\nret);\r\n}\r\n}\r\n}\r\nerr_out:\r\nmutex_unlock(&devfreq_list_lock);\r\nreturn err;\r\n}\r\nint devfreq_remove_governor(struct devfreq_governor *governor)\r\n{\r\nstruct devfreq_governor *g;\r\nstruct devfreq *devfreq;\r\nint err = 0;\r\nif (!governor) {\r\npr_err("%s: Invalid parameters.\n", __func__);\r\nreturn -EINVAL;\r\n}\r\nmutex_lock(&devfreq_list_lock);\r\ng = find_devfreq_governor(governor->name);\r\nif (IS_ERR(g)) {\r\npr_err("%s: governor %s not registered\n", __func__,\r\ngovernor->name);\r\nerr = PTR_ERR(g);\r\ngoto err_out;\r\n}\r\nlist_for_each_entry(devfreq, &devfreq_list, node) {\r\nint ret;\r\nstruct device *dev = devfreq->dev.parent;\r\nif (!strncmp(devfreq->governor_name, governor->name,\r\nDEVFREQ_NAME_LEN)) {\r\nif (!devfreq->governor) {\r\ndev_warn(dev, "%s: Governor %s NOT present\n",\r\n__func__, governor->name);\r\ncontinue;\r\n}\r\nret = devfreq->governor->event_handler(devfreq,\r\nDEVFREQ_GOV_STOP, NULL);\r\nif (ret) {\r\ndev_warn(dev, "%s: Governor %s stop=%d\n",\r\n__func__, devfreq->governor->name,\r\nret);\r\n}\r\ndevfreq->governor = NULL;\r\n}\r\n}\r\nlist_del(&governor->node);\r\nerr_out:\r\nmutex_unlock(&devfreq_list_lock);\r\nreturn err;\r\n}\r\nstatic ssize_t governor_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nif (!to_devfreq(dev)->governor)\r\nreturn -EINVAL;\r\nreturn sprintf(buf, "%s\n", to_devfreq(dev)->governor->name);\r\n}\r\nstatic ssize_t governor_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nint ret;\r\nchar str_governor[DEVFREQ_NAME_LEN + 1];\r\nstruct devfreq_governor *governor;\r\nret = sscanf(buf, "%" __stringify(DEVFREQ_NAME_LEN) "s", str_governor);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&devfreq_list_lock);\r\ngovernor = find_devfreq_governor(str_governor);\r\nif (IS_ERR(governor)) {\r\nret = PTR_ERR(governor);\r\ngoto out;\r\n}\r\nif (df->governor == governor) {\r\nret = 0;\r\ngoto out;\r\n} else if (df->governor->immutable || governor->immutable) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nif (df->governor) {\r\nret = df->governor->event_handler(df, DEVFREQ_GOV_STOP, NULL);\r\nif (ret) {\r\ndev_warn(dev, "%s: Governor %s not stopped(%d)\n",\r\n__func__, df->governor->name, ret);\r\ngoto out;\r\n}\r\n}\r\ndf->governor = governor;\r\nstrncpy(df->governor_name, governor->name, DEVFREQ_NAME_LEN);\r\nret = df->governor->event_handler(df, DEVFREQ_GOV_START, NULL);\r\nif (ret)\r\ndev_warn(dev, "%s: Governor %s not started(%d)\n",\r\n__func__, df->governor->name, ret);\r\nout:\r\nmutex_unlock(&devfreq_list_lock);\r\nif (!ret)\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic ssize_t available_governors_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct devfreq *df = to_devfreq(d);\r\nssize_t count = 0;\r\nmutex_lock(&devfreq_list_lock);\r\nif (df->governor->immutable) {\r\ncount = scnprintf(&buf[count], DEVFREQ_NAME_LEN,\r\n"%s ", df->governor_name);\r\n} else {\r\nstruct devfreq_governor *governor;\r\nlist_for_each_entry(governor, &devfreq_governor_list, node) {\r\nif (governor->immutable)\r\ncontinue;\r\ncount += scnprintf(&buf[count], (PAGE_SIZE - count - 2),\r\n"%s ", governor->name);\r\n}\r\n}\r\nmutex_unlock(&devfreq_list_lock);\r\nif (count)\r\ncount--;\r\ncount += sprintf(&buf[count], "\n");\r\nreturn count;\r\n}\r\nstatic ssize_t cur_freq_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nunsigned long freq;\r\nstruct devfreq *devfreq = to_devfreq(dev);\r\nif (devfreq->profile->get_cur_freq &&\r\n!devfreq->profile->get_cur_freq(devfreq->dev.parent, &freq))\r\nreturn sprintf(buf, "%lu\n", freq);\r\nreturn sprintf(buf, "%lu\n", devfreq->previous_freq);\r\n}\r\nstatic ssize_t target_freq_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%lu\n", to_devfreq(dev)->previous_freq);\r\n}\r\nstatic ssize_t polling_interval_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nreturn sprintf(buf, "%d\n", to_devfreq(dev)->profile->polling_ms);\r\n}\r\nstatic ssize_t polling_interval_store(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nunsigned int value;\r\nint ret;\r\nif (!df->governor)\r\nreturn -EINVAL;\r\nret = sscanf(buf, "%u", &value);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\ndf->governor->event_handler(df, DEVFREQ_GOV_INTERVAL, &value);\r\nret = count;\r\nreturn ret;\r\n}\r\nstatic ssize_t min_freq_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nunsigned long value;\r\nint ret;\r\nunsigned long max;\r\nret = sscanf(buf, "%lu", &value);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&df->lock);\r\nmax = df->max_freq;\r\nif (value && max && value > max) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ndf->min_freq = value;\r\nupdate_devfreq(df);\r\nret = count;\r\nunlock:\r\nmutex_unlock(&df->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t max_freq_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct devfreq *df = to_devfreq(dev);\r\nunsigned long value;\r\nint ret;\r\nunsigned long min;\r\nret = sscanf(buf, "%lu", &value);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\nmutex_lock(&df->lock);\r\nmin = df->min_freq;\r\nif (value && min && value < min) {\r\nret = -EINVAL;\r\ngoto unlock;\r\n}\r\ndf->max_freq = value;\r\nupdate_devfreq(df);\r\nret = count;\r\nunlock:\r\nmutex_unlock(&df->lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t available_frequencies_show(struct device *d,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct devfreq *df = to_devfreq(d);\r\nstruct device *dev = df->dev.parent;\r\nstruct dev_pm_opp *opp;\r\nssize_t count = 0;\r\nunsigned long freq = 0;\r\ndo {\r\nopp = dev_pm_opp_find_freq_ceil(dev, &freq);\r\nif (IS_ERR(opp))\r\nbreak;\r\ndev_pm_opp_put(opp);\r\ncount += scnprintf(&buf[count], (PAGE_SIZE - count - 2),\r\n"%lu ", freq);\r\nfreq++;\r\n} while (1);\r\nif (count)\r\ncount--;\r\ncount += sprintf(&buf[count], "\n");\r\nreturn count;\r\n}\r\nstatic ssize_t trans_stat_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct devfreq *devfreq = to_devfreq(dev);\r\nssize_t len;\r\nint i, j;\r\nunsigned int max_state = devfreq->profile->max_state;\r\nif (!devfreq->stop_polling &&\r\ndevfreq_update_status(devfreq, devfreq->previous_freq))\r\nreturn 0;\r\nif (max_state == 0)\r\nreturn sprintf(buf, "Not Supported.\n");\r\nlen = sprintf(buf, " From : To\n");\r\nlen += sprintf(buf + len, " :");\r\nfor (i = 0; i < max_state; i++)\r\nlen += sprintf(buf + len, "%10lu",\r\ndevfreq->profile->freq_table[i]);\r\nlen += sprintf(buf + len, " time(ms)\n");\r\nfor (i = 0; i < max_state; i++) {\r\nif (devfreq->profile->freq_table[i]\r\n== devfreq->previous_freq) {\r\nlen += sprintf(buf + len, "*");\r\n} else {\r\nlen += sprintf(buf + len, " ");\r\n}\r\nlen += sprintf(buf + len, "%10lu:",\r\ndevfreq->profile->freq_table[i]);\r\nfor (j = 0; j < max_state; j++)\r\nlen += sprintf(buf + len, "%10u",\r\ndevfreq->trans_table[(i * max_state) + j]);\r\nlen += sprintf(buf + len, "%10u\n",\r\njiffies_to_msecs(devfreq->time_in_state[i]));\r\n}\r\nlen += sprintf(buf + len, "Total transition : %u\n",\r\ndevfreq->total_trans);\r\nreturn len;\r\n}\r\nstatic int __init devfreq_init(void)\r\n{\r\ndevfreq_class = class_create(THIS_MODULE, "devfreq");\r\nif (IS_ERR(devfreq_class)) {\r\npr_err("%s: couldn't create class\n", __FILE__);\r\nreturn PTR_ERR(devfreq_class);\r\n}\r\ndevfreq_wq = create_freezable_workqueue("devfreq_wq");\r\nif (!devfreq_wq) {\r\nclass_destroy(devfreq_class);\r\npr_err("%s: couldn't create workqueue\n", __FILE__);\r\nreturn -ENOMEM;\r\n}\r\ndevfreq_class->dev_groups = devfreq_groups;\r\nreturn 0;\r\n}\r\nstruct dev_pm_opp *devfreq_recommended_opp(struct device *dev,\r\nunsigned long *freq,\r\nu32 flags)\r\n{\r\nstruct dev_pm_opp *opp;\r\nif (flags & DEVFREQ_FLAG_LEAST_UPPER_BOUND) {\r\nopp = dev_pm_opp_find_freq_floor(dev, freq);\r\nif (opp == ERR_PTR(-ERANGE))\r\nopp = dev_pm_opp_find_freq_ceil(dev, freq);\r\n} else {\r\nopp = dev_pm_opp_find_freq_ceil(dev, freq);\r\nif (opp == ERR_PTR(-ERANGE))\r\nopp = dev_pm_opp_find_freq_floor(dev, freq);\r\n}\r\nreturn opp;\r\n}\r\nint devfreq_register_opp_notifier(struct device *dev, struct devfreq *devfreq)\r\n{\r\nreturn dev_pm_opp_register_notifier(dev, &devfreq->nb);\r\n}\r\nint devfreq_unregister_opp_notifier(struct device *dev, struct devfreq *devfreq)\r\n{\r\nreturn dev_pm_opp_unregister_notifier(dev, &devfreq->nb);\r\n}\r\nstatic void devm_devfreq_opp_release(struct device *dev, void *res)\r\n{\r\ndevfreq_unregister_opp_notifier(dev, *(struct devfreq **)res);\r\n}\r\nint devm_devfreq_register_opp_notifier(struct device *dev,\r\nstruct devfreq *devfreq)\r\n{\r\nstruct devfreq **ptr;\r\nint ret;\r\nptr = devres_alloc(devm_devfreq_opp_release, sizeof(*ptr), GFP_KERNEL);\r\nif (!ptr)\r\nreturn -ENOMEM;\r\nret = devfreq_register_opp_notifier(dev, devfreq);\r\nif (ret) {\r\ndevres_free(ptr);\r\nreturn ret;\r\n}\r\n*ptr = devfreq;\r\ndevres_add(dev, ptr);\r\nreturn 0;\r\n}\r\nvoid devm_devfreq_unregister_opp_notifier(struct device *dev,\r\nstruct devfreq *devfreq)\r\n{\r\nWARN_ON(devres_release(dev, devm_devfreq_opp_release,\r\ndevm_devfreq_dev_match, devfreq));\r\n}\r\nint devfreq_register_notifier(struct devfreq *devfreq,\r\nstruct notifier_block *nb,\r\nunsigned int list)\r\n{\r\nint ret = 0;\r\nif (!devfreq)\r\nreturn -EINVAL;\r\nswitch (list) {\r\ncase DEVFREQ_TRANSITION_NOTIFIER:\r\nret = srcu_notifier_chain_register(\r\n&devfreq->transition_notifier_list, nb);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nint devfreq_unregister_notifier(struct devfreq *devfreq,\r\nstruct notifier_block *nb,\r\nunsigned int list)\r\n{\r\nint ret = 0;\r\nif (!devfreq)\r\nreturn -EINVAL;\r\nswitch (list) {\r\ncase DEVFREQ_TRANSITION_NOTIFIER:\r\nret = srcu_notifier_chain_unregister(\r\n&devfreq->transition_notifier_list, nb);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nreturn ret;\r\n}\r\nstatic void devm_devfreq_notifier_release(struct device *dev, void *res)\r\n{\r\nstruct devfreq_notifier_devres *this = res;\r\ndevfreq_unregister_notifier(this->devfreq, this->nb, this->list);\r\n}\r\nint devm_devfreq_register_notifier(struct device *dev,\r\nstruct devfreq *devfreq,\r\nstruct notifier_block *nb,\r\nunsigned int list)\r\n{\r\nstruct devfreq_notifier_devres *ptr;\r\nint ret;\r\nptr = devres_alloc(devm_devfreq_notifier_release, sizeof(*ptr),\r\nGFP_KERNEL);\r\nif (!ptr)\r\nreturn -ENOMEM;\r\nret = devfreq_register_notifier(devfreq, nb, list);\r\nif (ret) {\r\ndevres_free(ptr);\r\nreturn ret;\r\n}\r\nptr->devfreq = devfreq;\r\nptr->nb = nb;\r\nptr->list = list;\r\ndevres_add(dev, ptr);\r\nreturn 0;\r\n}\r\nvoid devm_devfreq_unregister_notifier(struct device *dev,\r\nstruct devfreq *devfreq,\r\nstruct notifier_block *nb,\r\nunsigned int list)\r\n{\r\nWARN_ON(devres_release(dev, devm_devfreq_notifier_release,\r\ndevm_devfreq_dev_match, devfreq));\r\n}
