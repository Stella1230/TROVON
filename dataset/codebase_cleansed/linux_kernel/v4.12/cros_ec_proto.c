static int prepare_packet(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nstruct ec_host_request *request;\r\nu8 *out;\r\nint i;\r\nu8 csum = 0;\r\nBUG_ON(ec_dev->proto_version != EC_HOST_REQUEST_VERSION);\r\nBUG_ON(msg->outsize + sizeof(*request) > ec_dev->dout_size);\r\nout = ec_dev->dout;\r\nrequest = (struct ec_host_request *)out;\r\nrequest->struct_version = EC_HOST_REQUEST_VERSION;\r\nrequest->checksum = 0;\r\nrequest->command = msg->command;\r\nrequest->command_version = msg->version;\r\nrequest->reserved = 0;\r\nrequest->data_len = msg->outsize;\r\nfor (i = 0; i < sizeof(*request); i++)\r\ncsum += out[i];\r\nmemcpy(out + sizeof(*request), msg->data, msg->outsize);\r\nfor (i = 0; i < msg->outsize; i++)\r\ncsum += msg->data[i];\r\nrequest->checksum = -csum;\r\nreturn sizeof(*request) + msg->outsize;\r\n}\r\nstatic int send_command(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nint ret;\r\nif (ec_dev->proto_version > 2)\r\nret = ec_dev->pkt_xfer(ec_dev, msg);\r\nelse\r\nret = ec_dev->cmd_xfer(ec_dev, msg);\r\nif (msg->result == EC_RES_IN_PROGRESS) {\r\nint i;\r\nstruct cros_ec_command *status_msg;\r\nstruct ec_response_get_comms_status *status;\r\nstatus_msg = kmalloc(sizeof(*status_msg) + sizeof(*status),\r\nGFP_KERNEL);\r\nif (!status_msg)\r\nreturn -ENOMEM;\r\nstatus_msg->version = 0;\r\nstatus_msg->command = EC_CMD_GET_COMMS_STATUS;\r\nstatus_msg->insize = sizeof(*status);\r\nstatus_msg->outsize = 0;\r\nfor (i = 0; i < EC_COMMAND_RETRIES; i++) {\r\nusleep_range(10000, 11000);\r\nret = ec_dev->cmd_xfer(ec_dev, status_msg);\r\nif (ret < 0)\r\nbreak;\r\nmsg->result = status_msg->result;\r\nif (status_msg->result != EC_RES_SUCCESS)\r\nbreak;\r\nstatus = (struct ec_response_get_comms_status *)\r\nstatus_msg->data;\r\nif (!(status->flags & EC_COMMS_STATUS_PROCESSING))\r\nbreak;\r\n}\r\nkfree(status_msg);\r\n}\r\nreturn ret;\r\n}\r\nint cros_ec_prepare_tx(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nu8 *out;\r\nu8 csum;\r\nint i;\r\nif (ec_dev->proto_version > 2)\r\nreturn prepare_packet(ec_dev, msg);\r\nBUG_ON(msg->outsize > EC_PROTO2_MAX_PARAM_SIZE);\r\nout = ec_dev->dout;\r\nout[0] = EC_CMD_VERSION0 + msg->version;\r\nout[1] = msg->command;\r\nout[2] = msg->outsize;\r\ncsum = out[0] + out[1] + out[2];\r\nfor (i = 0; i < msg->outsize; i++)\r\ncsum += out[EC_MSG_TX_HEADER_BYTES + i] = msg->data[i];\r\nout[EC_MSG_TX_HEADER_BYTES + msg->outsize] = csum;\r\nreturn EC_MSG_TX_PROTO_BYTES + msg->outsize;\r\n}\r\nint cros_ec_check_result(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nswitch (msg->result) {\r\ncase EC_RES_SUCCESS:\r\nreturn 0;\r\ncase EC_RES_IN_PROGRESS:\r\ndev_dbg(ec_dev->dev, "command 0x%02x in progress\n",\r\nmsg->command);\r\nreturn -EAGAIN;\r\ndefault:\r\ndev_dbg(ec_dev->dev, "command 0x%02x returned %d\n",\r\nmsg->command, msg->result);\r\nreturn 0;\r\n}\r\n}\r\nstatic int cros_ec_host_command_proto_query(struct cros_ec_device *ec_dev,\r\nint devidx,\r\nstruct cros_ec_command *msg)\r\n{\r\nint ret;\r\nif (!ec_dev->pkt_xfer)\r\nreturn -EPROTONOSUPPORT;\r\nmemset(msg, 0, sizeof(*msg));\r\nmsg->command = EC_CMD_PASSTHRU_OFFSET(devidx) | EC_CMD_GET_PROTOCOL_INFO;\r\nmsg->insize = sizeof(struct ec_response_get_protocol_info);\r\nret = send_command(ec_dev, msg);\r\nif (ret < 0) {\r\ndev_dbg(ec_dev->dev,\r\n"failed to check for EC[%d] protocol version: %d\n",\r\ndevidx, ret);\r\nreturn ret;\r\n}\r\nif (devidx > 0 && msg->result == EC_RES_INVALID_COMMAND)\r\nreturn -ENODEV;\r\nelse if (msg->result != EC_RES_SUCCESS)\r\nreturn msg->result;\r\nreturn 0;\r\n}\r\nstatic int cros_ec_host_command_proto_query_v2(struct cros_ec_device *ec_dev)\r\n{\r\nstruct cros_ec_command *msg;\r\nstruct ec_params_hello *hello_params;\r\nstruct ec_response_hello *hello_response;\r\nint ret;\r\nint len = max(sizeof(*hello_params), sizeof(*hello_response));\r\nmsg = kmalloc(sizeof(*msg) + len, GFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_HELLO;\r\nhello_params = (struct ec_params_hello *)msg->data;\r\nmsg->outsize = sizeof(*hello_params);\r\nhello_response = (struct ec_response_hello *)msg->data;\r\nmsg->insize = sizeof(*hello_response);\r\nhello_params->in_data = 0xa0b0c0d0;\r\nret = send_command(ec_dev, msg);\r\nif (ret < 0) {\r\ndev_dbg(ec_dev->dev,\r\n"EC failed to respond to v2 hello: %d\n",\r\nret);\r\ngoto exit;\r\n} else if (msg->result != EC_RES_SUCCESS) {\r\ndev_err(ec_dev->dev,\r\n"EC responded to v2 hello with error: %d\n",\r\nmsg->result);\r\nret = msg->result;\r\ngoto exit;\r\n} else if (hello_response->out_data != 0xa1b2c3d4) {\r\ndev_err(ec_dev->dev,\r\n"EC responded to v2 hello with bad result: %u\n",\r\nhello_response->out_data);\r\nret = -EBADMSG;\r\ngoto exit;\r\n}\r\nret = 0;\r\nexit:\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_get_host_command_version_mask(struct cros_ec_device *ec_dev,\r\nu16 cmd, u32 *mask)\r\n{\r\nstruct ec_params_get_cmd_versions *pver;\r\nstruct ec_response_get_cmd_versions *rver;\r\nstruct cros_ec_command *msg;\r\nint ret;\r\nmsg = kmalloc(sizeof(*msg) + max(sizeof(*rver), sizeof(*pver)),\r\nGFP_KERNEL);\r\nif (!msg)\r\nreturn -ENOMEM;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_GET_CMD_VERSIONS;\r\nmsg->insize = sizeof(*rver);\r\nmsg->outsize = sizeof(*pver);\r\npver = (struct ec_params_get_cmd_versions *)msg->data;\r\npver->cmd = cmd;\r\nret = cros_ec_cmd_xfer(ec_dev, msg);\r\nif (ret > 0) {\r\nrver = (struct ec_response_get_cmd_versions *)msg->data;\r\n*mask = rver->version_mask;\r\n}\r\nkfree(msg);\r\nreturn ret;\r\n}\r\nint cros_ec_query_all(struct cros_ec_device *ec_dev)\r\n{\r\nstruct device *dev = ec_dev->dev;\r\nstruct cros_ec_command *proto_msg;\r\nstruct ec_response_get_protocol_info *proto_info;\r\nu32 ver_mask = 0;\r\nint ret;\r\nproto_msg = kzalloc(sizeof(*proto_msg) + sizeof(*proto_info),\r\nGFP_KERNEL);\r\nif (!proto_msg)\r\nreturn -ENOMEM;\r\nec_dev->proto_version = 3;\r\nret = cros_ec_host_command_proto_query(ec_dev, 0, proto_msg);\r\nif (ret == 0) {\r\nproto_info = (struct ec_response_get_protocol_info *)\r\nproto_msg->data;\r\nec_dev->max_request = proto_info->max_request_packet_size -\r\nsizeof(struct ec_host_request);\r\nec_dev->max_response = proto_info->max_response_packet_size -\r\nsizeof(struct ec_host_response);\r\nec_dev->proto_version =\r\nmin(EC_HOST_REQUEST_VERSION,\r\nfls(proto_info->protocol_versions) - 1);\r\ndev_dbg(ec_dev->dev,\r\n"using proto v%u\n",\r\nec_dev->proto_version);\r\nec_dev->din_size = ec_dev->max_response +\r\nsizeof(struct ec_host_response) +\r\nEC_MAX_RESPONSE_OVERHEAD;\r\nec_dev->dout_size = ec_dev->max_request +\r\nsizeof(struct ec_host_request) +\r\nEC_MAX_REQUEST_OVERHEAD;\r\nret = cros_ec_host_command_proto_query(ec_dev, 1, proto_msg);\r\nif (ret) {\r\ndev_dbg(ec_dev->dev, "no PD chip found: %d\n", ret);\r\nec_dev->max_passthru = 0;\r\n} else {\r\ndev_dbg(ec_dev->dev, "found PD chip\n");\r\nec_dev->max_passthru =\r\nproto_info->max_request_packet_size -\r\nsizeof(struct ec_host_request);\r\n}\r\n} else {\r\nec_dev->proto_version = 2;\r\nret = cros_ec_host_command_proto_query_v2(ec_dev);\r\nif (ret == 0) {\r\ndev_dbg(ec_dev->dev, "falling back to proto v2\n");\r\nec_dev->max_request = EC_PROTO2_MAX_PARAM_SIZE;\r\nec_dev->max_response = EC_PROTO2_MAX_PARAM_SIZE;\r\nec_dev->max_passthru = 0;\r\nec_dev->pkt_xfer = NULL;\r\nec_dev->din_size = EC_PROTO2_MSG_BYTES;\r\nec_dev->dout_size = EC_PROTO2_MSG_BYTES;\r\n} else {\r\nec_dev->proto_version = EC_PROTO_VERSION_UNKNOWN;\r\ndev_dbg(ec_dev->dev, "EC query failed: %d\n", ret);\r\ngoto exit;\r\n}\r\n}\r\ndevm_kfree(dev, ec_dev->din);\r\ndevm_kfree(dev, ec_dev->dout);\r\nec_dev->din = devm_kzalloc(dev, ec_dev->din_size, GFP_KERNEL);\r\nif (!ec_dev->din) {\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nec_dev->dout = devm_kzalloc(dev, ec_dev->dout_size, GFP_KERNEL);\r\nif (!ec_dev->dout) {\r\ndevm_kfree(dev, ec_dev->din);\r\nret = -ENOMEM;\r\ngoto exit;\r\n}\r\nret = cros_ec_get_host_command_version_mask(ec_dev,\r\nEC_CMD_GET_NEXT_EVENT,\r\n&ver_mask);\r\nif (ret < 0 || ver_mask == 0)\r\nec_dev->mkbp_event_supported = 0;\r\nelse\r\nec_dev->mkbp_event_supported = 1;\r\nexit:\r\nkfree(proto_msg);\r\nreturn ret;\r\n}\r\nint cros_ec_cmd_xfer(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nint ret;\r\nmutex_lock(&ec_dev->lock);\r\nif (ec_dev->proto_version == EC_PROTO_VERSION_UNKNOWN) {\r\nret = cros_ec_query_all(ec_dev);\r\nif (ret) {\r\ndev_err(ec_dev->dev,\r\n"EC version unknown and query failed; aborting command\n");\r\nmutex_unlock(&ec_dev->lock);\r\nreturn ret;\r\n}\r\n}\r\nif (msg->insize > ec_dev->max_response) {\r\ndev_dbg(ec_dev->dev, "clamping message receive buffer\n");\r\nmsg->insize = ec_dev->max_response;\r\n}\r\nif (msg->command < EC_CMD_PASSTHRU_OFFSET(1)) {\r\nif (msg->outsize > ec_dev->max_request) {\r\ndev_err(ec_dev->dev,\r\n"request of size %u is too big (max: %u)\n",\r\nmsg->outsize,\r\nec_dev->max_request);\r\nmutex_unlock(&ec_dev->lock);\r\nreturn -EMSGSIZE;\r\n}\r\n} else {\r\nif (msg->outsize > ec_dev->max_passthru) {\r\ndev_err(ec_dev->dev,\r\n"passthru rq of size %u is too big (max: %u)\n",\r\nmsg->outsize,\r\nec_dev->max_passthru);\r\nmutex_unlock(&ec_dev->lock);\r\nreturn -EMSGSIZE;\r\n}\r\n}\r\nret = send_command(ec_dev, msg);\r\nmutex_unlock(&ec_dev->lock);\r\nreturn ret;\r\n}\r\nint cros_ec_cmd_xfer_status(struct cros_ec_device *ec_dev,\r\nstruct cros_ec_command *msg)\r\n{\r\nint ret;\r\nret = cros_ec_cmd_xfer(ec_dev, msg);\r\nif (ret < 0) {\r\ndev_err(ec_dev->dev, "Command xfer error (err:%d)\n", ret);\r\n} else if (msg->result != EC_RES_SUCCESS) {\r\ndev_dbg(ec_dev->dev, "Command result (err: %d)\n", msg->result);\r\nreturn -EPROTO;\r\n}\r\nreturn ret;\r\n}\r\nstatic int get_next_event(struct cros_ec_device *ec_dev)\r\n{\r\nu8 buffer[sizeof(struct cros_ec_command) + sizeof(ec_dev->event_data)];\r\nstruct cros_ec_command *msg = (struct cros_ec_command *)&buffer;\r\nint ret;\r\nif (ec_dev->suspended) {\r\ndev_dbg(ec_dev->dev, "Device suspended.\n");\r\nreturn -EHOSTDOWN;\r\n}\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_GET_NEXT_EVENT;\r\nmsg->insize = sizeof(ec_dev->event_data);\r\nmsg->outsize = 0;\r\nret = cros_ec_cmd_xfer(ec_dev, msg);\r\nif (ret > 0) {\r\nec_dev->event_size = ret - 1;\r\nmemcpy(&ec_dev->event_data, msg->data,\r\nsizeof(ec_dev->event_data));\r\n}\r\nreturn ret;\r\n}\r\nstatic int get_keyboard_state_event(struct cros_ec_device *ec_dev)\r\n{\r\nu8 buffer[sizeof(struct cros_ec_command) +\r\nsizeof(ec_dev->event_data.data)];\r\nstruct cros_ec_command *msg = (struct cros_ec_command *)&buffer;\r\nmsg->version = 0;\r\nmsg->command = EC_CMD_MKBP_STATE;\r\nmsg->insize = sizeof(ec_dev->event_data.data);\r\nmsg->outsize = 0;\r\nec_dev->event_size = cros_ec_cmd_xfer(ec_dev, msg);\r\nec_dev->event_data.event_type = EC_MKBP_EVENT_KEY_MATRIX;\r\nmemcpy(&ec_dev->event_data.data, msg->data,\r\nsizeof(ec_dev->event_data.data));\r\nreturn ec_dev->event_size;\r\n}\r\nint cros_ec_get_next_event(struct cros_ec_device *ec_dev)\r\n{\r\nif (ec_dev->mkbp_event_supported)\r\nreturn get_next_event(ec_dev);\r\nelse\r\nreturn get_keyboard_state_event(ec_dev);\r\n}
