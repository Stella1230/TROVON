static u32 icoll_intr_bitshift(struct irq_data *d, u32 bit)\r\n{\r\nreturn bit << ((d->hwirq & 3) << 3);\r\n}\r\nstatic void __iomem *icoll_intr_reg(struct irq_data *d)\r\n{\r\nreturn icoll_priv.intr + ((d->hwirq >> 2) * 0x10);\r\n}\r\nstatic void icoll_ack_irq(struct irq_data *d)\r\n{\r\n__raw_writel(BV_ICOLL_LEVELACK_IRQLEVELACK__LEVEL0,\r\nicoll_priv.levelack);\r\n}\r\nstatic void icoll_mask_irq(struct irq_data *d)\r\n{\r\n__raw_writel(BM_ICOLL_INTR_ENABLE,\r\nicoll_priv.intr + CLR_REG + HW_ICOLL_INTERRUPTn(d->hwirq));\r\n}\r\nstatic void icoll_unmask_irq(struct irq_data *d)\r\n{\r\n__raw_writel(BM_ICOLL_INTR_ENABLE,\r\nicoll_priv.intr + SET_REG + HW_ICOLL_INTERRUPTn(d->hwirq));\r\n}\r\nstatic void asm9260_mask_irq(struct irq_data *d)\r\n{\r\n__raw_writel(icoll_intr_bitshift(d, BM_ICOLL_INTR_ENABLE),\r\nicoll_intr_reg(d) + CLR_REG);\r\n}\r\nstatic void asm9260_unmask_irq(struct irq_data *d)\r\n{\r\n__raw_writel(ASM9260_BM_CLEAR_BIT(d->hwirq),\r\nicoll_priv.clear +\r\nASM9260_HW_ICOLL_CLEARn(d->hwirq));\r\n__raw_writel(icoll_intr_bitshift(d, BM_ICOLL_INTR_ENABLE),\r\nicoll_intr_reg(d) + SET_REG);\r\n}\r\nasmlinkage void __exception_irq_entry icoll_handle_irq(struct pt_regs *regs)\r\n{\r\nu32 irqnr;\r\nirqnr = __raw_readl(icoll_priv.stat);\r\n__raw_writel(irqnr, icoll_priv.vector);\r\nhandle_domain_irq(icoll_domain, irqnr, regs);\r\n}\r\nstatic int icoll_irq_domain_map(struct irq_domain *d, unsigned int virq,\r\nirq_hw_number_t hw)\r\n{\r\nstruct irq_chip *chip;\r\nif (icoll_priv.type == ICOLL)\r\nchip = &mxs_icoll_chip;\r\nelse\r\nchip = &asm9260_icoll_chip;\r\nirq_set_chip_and_handler(virq, chip, handle_level_irq);\r\nreturn 0;\r\n}\r\nstatic void __init icoll_add_domain(struct device_node *np,\r\nint num)\r\n{\r\nicoll_domain = irq_domain_add_linear(np, num,\r\n&icoll_irq_domain_ops, NULL);\r\nif (!icoll_domain)\r\npanic("%s: unable to create irq domain", np->full_name);\r\n}\r\nstatic void __iomem * __init icoll_init_iobase(struct device_node *np)\r\n{\r\nvoid __iomem *icoll_base;\r\nicoll_base = of_io_request_and_map(np, 0, np->name);\r\nif (IS_ERR(icoll_base))\r\npanic("%s: unable to map resource", np->full_name);\r\nreturn icoll_base;\r\n}\r\nstatic int __init icoll_of_init(struct device_node *np,\r\nstruct device_node *interrupt_parent)\r\n{\r\nvoid __iomem *icoll_base;\r\nicoll_priv.type = ICOLL;\r\nicoll_base = icoll_init_iobase(np);\r\nicoll_priv.vector = icoll_base + HW_ICOLL_VECTOR;\r\nicoll_priv.levelack = icoll_base + HW_ICOLL_LEVELACK;\r\nicoll_priv.ctrl = icoll_base + HW_ICOLL_CTRL;\r\nicoll_priv.stat = icoll_base + HW_ICOLL_STAT_OFFSET;\r\nicoll_priv.intr = icoll_base + HW_ICOLL_INTERRUPT0;\r\nicoll_priv.clear = NULL;\r\nstmp_reset_block(icoll_priv.ctrl);\r\nicoll_add_domain(np, ICOLL_NUM_IRQS);\r\nreturn 0;\r\n}\r\nstatic int __init asm9260_of_init(struct device_node *np,\r\nstruct device_node *interrupt_parent)\r\n{\r\nvoid __iomem *icoll_base;\r\nint i;\r\nicoll_priv.type = ASM9260_ICOLL;\r\nicoll_base = icoll_init_iobase(np);\r\nicoll_priv.vector = icoll_base + ASM9260_HW_ICOLL_VECTOR;\r\nicoll_priv.levelack = icoll_base + ASM9260_HW_ICOLL_LEVELACK;\r\nicoll_priv.ctrl = icoll_base + ASM9260_HW_ICOLL_CTRL;\r\nicoll_priv.stat = icoll_base + ASM9260_HW_ICOLL_STAT_OFFSET;\r\nicoll_priv.intr = icoll_base + ASM9260_HW_ICOLL_INTERRUPT0;\r\nicoll_priv.clear = icoll_base + ASM9260_HW_ICOLL_CLEAR0;\r\nwritel_relaxed(ASM9260_BM_CTRL_IRQ_ENABLE,\r\nicoll_priv.ctrl);\r\nfor (i = 0; i < 16 * 0x10; i += 0x10)\r\nwritel(0, icoll_priv.intr + i);\r\nicoll_add_domain(np, ASM9260_NUM_IRQS);\r\nset_handle_irq(icoll_handle_irq);\r\nreturn 0;\r\n}
