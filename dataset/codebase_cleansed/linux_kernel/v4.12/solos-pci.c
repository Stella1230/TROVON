static inline void solos_pop(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nif (vcc->pop)\r\nvcc->pop(vcc, skb);\r\nelse\r\ndev_kfree_skb_any(skb);\r\n}\r\nstatic ssize_t solos_param_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\r\nstruct solos_card *card = atmdev->dev_data;\r\nstruct solos_param prm;\r\nstruct sk_buff *skb;\r\nstruct pkt_hdr *header;\r\nint buflen;\r\nbuflen = strlen(attr->attr.name) + 10;\r\nskb = alloc_skb(sizeof(*header) + buflen, GFP_KERNEL);\r\nif (!skb) {\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_show()\n");\r\nreturn -ENOMEM;\r\n}\r\nheader = (void *)skb_put(skb, sizeof(*header));\r\nbuflen = snprintf((void *)&header[1], buflen - 1,\r\n"L%05d\n%s\n", current->pid, attr->attr.name);\r\nskb_put(skb, buflen);\r\nheader->size = cpu_to_le16(buflen);\r\nheader->vpi = cpu_to_le16(0);\r\nheader->vci = cpu_to_le16(0);\r\nheader->type = cpu_to_le16(PKT_COMMAND);\r\nprm.pid = current->pid;\r\nprm.response = NULL;\r\nprm.port = SOLOS_CHAN(atmdev);\r\nspin_lock_irq(&card->param_queue_lock);\r\nlist_add(&prm.list, &card->param_queue);\r\nspin_unlock_irq(&card->param_queue_lock);\r\nfpga_queue(card, prm.port, skb, NULL);\r\nwait_event_timeout(card->param_wq, prm.response, 5 * HZ);\r\nspin_lock_irq(&card->param_queue_lock);\r\nlist_del(&prm.list);\r\nspin_unlock_irq(&card->param_queue_lock);\r\nif (!prm.response)\r\nreturn -EIO;\r\nbuflen = prm.response->len;\r\nmemcpy(buf, prm.response->data, buflen);\r\nkfree_skb(prm.response);\r\nreturn buflen;\r\n}\r\nstatic ssize_t solos_param_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\r\nstruct solos_card *card = atmdev->dev_data;\r\nstruct solos_param prm;\r\nstruct sk_buff *skb;\r\nstruct pkt_hdr *header;\r\nint buflen;\r\nssize_t ret;\r\nbuflen = strlen(attr->attr.name) + 11 + count;\r\nskb = alloc_skb(sizeof(*header) + buflen, GFP_KERNEL);\r\nif (!skb) {\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff in solos_param_store()\n");\r\nreturn -ENOMEM;\r\n}\r\nheader = (void *)skb_put(skb, sizeof(*header));\r\nbuflen = snprintf((void *)&header[1], buflen - 1,\r\n"L%05d\n%s\n%s\n", current->pid, attr->attr.name, buf);\r\nskb_put(skb, buflen);\r\nheader->size = cpu_to_le16(buflen);\r\nheader->vpi = cpu_to_le16(0);\r\nheader->vci = cpu_to_le16(0);\r\nheader->type = cpu_to_le16(PKT_COMMAND);\r\nprm.pid = current->pid;\r\nprm.response = NULL;\r\nprm.port = SOLOS_CHAN(atmdev);\r\nspin_lock_irq(&card->param_queue_lock);\r\nlist_add(&prm.list, &card->param_queue);\r\nspin_unlock_irq(&card->param_queue_lock);\r\nfpga_queue(card, prm.port, skb, NULL);\r\nwait_event_timeout(card->param_wq, prm.response, 5 * HZ);\r\nspin_lock_irq(&card->param_queue_lock);\r\nlist_del(&prm.list);\r\nspin_unlock_irq(&card->param_queue_lock);\r\nskb = prm.response;\r\nif (!skb)\r\nreturn -EIO;\r\nbuflen = skb->len;\r\nif (skb->data[buflen - 1] == '\n')\r\nbuflen--;\r\nif (buflen == 2 && !strncmp(skb->data, "OK", 2))\r\nret = count;\r\nelse if (buflen == 5 && !strncmp(skb->data, "ERROR", 5))\r\nret = -EIO;\r\nelse {\r\nskb->data[buflen] = 0;\r\ndev_warn(&card->dev->dev, "Unexpected parameter response: '%s'\n",\r\nskb->data);\r\nret = -EIO;\r\n}\r\nkfree_skb(skb);\r\nreturn ret;\r\n}\r\nstatic char *next_string(struct sk_buff *skb)\r\n{\r\nint i = 0;\r\nchar *this = skb->data;\r\nfor (i = 0; i < skb->len; i++) {\r\nif (this[i] == '\n') {\r\nthis[i] = 0;\r\nskb_pull(skb, i + 1);\r\nreturn this;\r\n}\r\nif (!isprint(this[i]))\r\nreturn NULL;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int process_status(struct solos_card *card, int port, struct sk_buff *skb)\r\n{\r\nchar *str, *state_str, *snr, *attn;\r\nint ver, rate_up, rate_down, err;\r\nif (!card->atmdev[port])\r\nreturn -ENODEV;\r\nstr = next_string(skb);\r\nif (!str)\r\nreturn -EIO;\r\nerr = kstrtoint(str, 10, &ver);\r\nif (err) {\r\ndev_warn(&card->dev->dev, "Unexpected status interrupt version\n");\r\nreturn err;\r\n}\r\nif (ver < 1) {\r\ndev_warn(&card->dev->dev, "Unexpected status interrupt version %d\n",\r\nver);\r\nreturn -EIO;\r\n}\r\nstr = next_string(skb);\r\nif (!str)\r\nreturn -EIO;\r\nif (!strcmp(str, "ERROR")) {\r\ndev_dbg(&card->dev->dev, "Status packet indicated Solos error on port %d (starting up?)\n",\r\nport);\r\nreturn 0;\r\n}\r\nerr = kstrtoint(str, 10, &rate_down);\r\nif (err)\r\nreturn err;\r\nstr = next_string(skb);\r\nif (!str)\r\nreturn -EIO;\r\nerr = kstrtoint(str, 10, &rate_up);\r\nif (err)\r\nreturn err;\r\nstate_str = next_string(skb);\r\nif (!state_str)\r\nreturn -EIO;\r\nif (strcmp(state_str, "Showtime")) {\r\natm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_LOST);\r\ndev_info(&card->dev->dev, "Port %d: %s\n", port, state_str);\r\nreturn 0;\r\n}\r\nsnr = next_string(skb);\r\nif (!snr)\r\nreturn -EIO;\r\nattn = next_string(skb);\r\nif (!attn)\r\nreturn -EIO;\r\ndev_info(&card->dev->dev, "Port %d: %s @%d/%d kb/s%s%s%s%s\n",\r\nport, state_str, rate_down/1000, rate_up/1000,\r\nsnr[0]?", SNR ":"", snr, attn[0]?", Attn ":"", attn);\r\ncard->atmdev[port]->link_rate = rate_down / 424;\r\natm_dev_signal_change(card->atmdev[port], ATM_PHY_SIG_FOUND);\r\nreturn 0;\r\n}\r\nstatic int process_command(struct solos_card *card, int port, struct sk_buff *skb)\r\n{\r\nstruct solos_param *prm;\r\nunsigned long flags;\r\nint cmdpid;\r\nint found = 0, err;\r\nif (skb->len < 7)\r\nreturn 0;\r\nif (skb->data[0] != 'L' || !isdigit(skb->data[1]) ||\r\n!isdigit(skb->data[2]) || !isdigit(skb->data[3]) ||\r\n!isdigit(skb->data[4]) || !isdigit(skb->data[5]) ||\r\nskb->data[6] != '\n')\r\nreturn 0;\r\nerr = kstrtoint(&skb->data[1], 10, &cmdpid);\r\nif (err)\r\nreturn err;\r\nspin_lock_irqsave(&card->param_queue_lock, flags);\r\nlist_for_each_entry(prm, &card->param_queue, list) {\r\nif (prm->port == port && prm->pid == cmdpid) {\r\nprm->response = skb;\r\nskb_pull(skb, 7);\r\nwake_up(&card->param_wq);\r\nfound = 1;\r\nbreak;\r\n}\r\n}\r\nspin_unlock_irqrestore(&card->param_queue_lock, flags);\r\nreturn found;\r\n}\r\nstatic ssize_t console_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\r\nstruct solos_card *card = atmdev->dev_data;\r\nstruct sk_buff *skb;\r\nunsigned int len;\r\nspin_lock(&card->cli_queue_lock);\r\nskb = skb_dequeue(&card->cli_queue[SOLOS_CHAN(atmdev)]);\r\nspin_unlock(&card->cli_queue_lock);\r\nif(skb == NULL)\r\nreturn sprintf(buf, "No data.\n");\r\nlen = skb->len;\r\nmemcpy(buf, skb->data, len);\r\nkfree_skb(skb);\r\nreturn len;\r\n}\r\nstatic int send_command(struct solos_card *card, int dev, const char *buf, size_t size)\r\n{\r\nstruct sk_buff *skb;\r\nstruct pkt_hdr *header;\r\nif (size > (BUF_SIZE - sizeof(*header))) {\r\ndev_dbg(&card->dev->dev, "Command is too big. Dropping request\n");\r\nreturn 0;\r\n}\r\nskb = alloc_skb(size + sizeof(*header), GFP_ATOMIC);\r\nif (!skb) {\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff in send_command()\n");\r\nreturn 0;\r\n}\r\nheader = (void *)skb_put(skb, sizeof(*header));\r\nheader->size = cpu_to_le16(size);\r\nheader->vpi = cpu_to_le16(0);\r\nheader->vci = cpu_to_le16(0);\r\nheader->type = cpu_to_le16(PKT_COMMAND);\r\nmemcpy(skb_put(skb, size), buf, size);\r\nfpga_queue(card, dev, skb, NULL);\r\nreturn 0;\r\n}\r\nstatic ssize_t console_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct atm_dev *atmdev = container_of(dev, struct atm_dev, class_dev);\r\nstruct solos_card *card = atmdev->dev_data;\r\nint err;\r\nerr = send_command(card, SOLOS_CHAN(atmdev), buf, count);\r\nreturn err?:count;\r\n}\r\nstatic ssize_t geos_gpio_store(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);\r\nstruct solos_card *card = pci_get_drvdata(pdev);\r\nuint32_t data32;\r\nif (count != 1 && (count != 2 || buf[1] != '\n'))\r\nreturn -EINVAL;\r\nspin_lock_irq(&card->param_queue_lock);\r\ndata32 = ioread32(card->config_regs + GPIO_STATUS);\r\nif (buf[0] == '1') {\r\ndata32 |= 1 << gattr->offset;\r\niowrite32(data32, card->config_regs + GPIO_STATUS);\r\n} else if (buf[0] == '0') {\r\ndata32 &= ~(1 << gattr->offset);\r\niowrite32(data32, card->config_regs + GPIO_STATUS);\r\n} else {\r\ncount = -EINVAL;\r\n}\r\nspin_unlock_irq(&card->param_queue_lock);\r\nreturn count;\r\n}\r\nstatic ssize_t geos_gpio_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);\r\nstruct solos_card *card = pci_get_drvdata(pdev);\r\nuint32_t data32;\r\ndata32 = ioread32(card->config_regs + GPIO_STATUS);\r\ndata32 = (data32 >> gattr->offset) & 1;\r\nreturn sprintf(buf, "%d\n", data32);\r\n}\r\nstatic ssize_t hardware_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(dev);\r\nstruct geos_gpio_attr *gattr = container_of(attr, struct geos_gpio_attr, attr);\r\nstruct solos_card *card = pci_get_drvdata(pdev);\r\nuint32_t data32;\r\ndata32 = ioread32(card->config_regs + GPIO_STATUS);\r\nswitch (gattr->offset) {\r\ncase 0:\r\ndata32 = data32 & 0x1F;\r\nbreak;\r\ncase 1:\r\ndata32 = (data32 >> 5) & 0x0F;\r\nbreak;\r\n}\r\nreturn sprintf(buf, "%d\n", data32);\r\n}\r\nstatic int flash_upgrade(struct solos_card *card, int chip)\r\n{\r\nconst struct firmware *fw;\r\nconst char *fw_name;\r\nint blocksize = 0;\r\nint numblocks = 0;\r\nint offset;\r\nswitch (chip) {\r\ncase 0:\r\nfw_name = "solos-FPGA.bin";\r\nif (card->atmel_flash)\r\nblocksize = ATMEL_FPGA_BLOCK;\r\nelse\r\nblocksize = SPI_FLASH_BLOCK;\r\nbreak;\r\ncase 1:\r\nfw_name = "solos-Firmware.bin";\r\nif (card->atmel_flash)\r\nblocksize = ATMEL_SOLOS_BLOCK;\r\nelse\r\nblocksize = SPI_FLASH_BLOCK;\r\nbreak;\r\ncase 2:\r\nif (card->fpga_version > LEGACY_BUFFERS){\r\nfw_name = "solos-db-FPGA.bin";\r\nif (card->atmel_flash)\r\nblocksize = ATMEL_FPGA_BLOCK;\r\nelse\r\nblocksize = SPI_FLASH_BLOCK;\r\n} else {\r\ndev_info(&card->dev->dev, "FPGA version doesn't support"\r\n" daughter board upgrades\n");\r\nreturn -EPERM;\r\n}\r\nbreak;\r\ncase 3:\r\nif (card->fpga_version > LEGACY_BUFFERS){\r\nfw_name = "solos-Firmware.bin";\r\nif (card->atmel_flash)\r\nblocksize = ATMEL_SOLOS_BLOCK;\r\nelse\r\nblocksize = SPI_FLASH_BLOCK;\r\n} else {\r\ndev_info(&card->dev->dev, "FPGA version doesn't support"\r\n" daughter board upgrades\n");\r\nreturn -EPERM;\r\n}\r\nbreak;\r\ndefault:\r\nreturn -ENODEV;\r\n}\r\nif (request_firmware(&fw, fw_name, &card->dev->dev))\r\nreturn -ENOENT;\r\ndev_info(&card->dev->dev, "Flash upgrade starting\n");\r\niowrite32(DRIVER_VERSION, card->config_regs + DRIVER_VER);\r\nnumblocks = fw->size / blocksize;\r\ndev_info(&card->dev->dev, "Firmware size: %zd\n", fw->size);\r\ndev_info(&card->dev->dev, "Number of blocks: %d\n", numblocks);\r\ndev_info(&card->dev->dev, "Changing FPGA to Update mode\n");\r\niowrite32(1, card->config_regs + FPGA_MODE);\r\n(void) ioread32(card->config_regs + FPGA_MODE);\r\nif(chip == 0 || chip == 2)\r\ndev_info(&card->dev->dev, "Set FPGA Flash mode to FPGA Chip Erase\n");\r\nif(chip == 1 || chip == 3)\r\ndev_info(&card->dev->dev, "Set FPGA Flash mode to Solos Chip Erase\n");\r\niowrite32((chip * 2), card->config_regs + FLASH_MODE);\r\niowrite32(1, card->config_regs + WRITE_FLASH);\r\nwait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));\r\nfor (offset = 0; offset < fw->size; offset += blocksize) {\r\nint i;\r\niowrite32(0, card->config_regs + WRITE_FLASH);\r\niowrite32(((chip * 2) + 1), card->config_regs + FLASH_MODE);\r\nfor(i = 0; i < blocksize; i += 4) {\r\nuint32_t word;\r\nif (card->atmel_flash)\r\nword = swahb32p((uint32_t *)(fw->data + offset + i));\r\nelse\r\nword = *(uint32_t *)(fw->data + offset + i);\r\nif(card->fpga_version > LEGACY_BUFFERS)\r\niowrite32(word, FLASH_BUF + i);\r\nelse\r\niowrite32(word, RX_BUF(card, 3) + i);\r\n}\r\niowrite32(offset / blocksize, card->config_regs + FLASH_BLOCK);\r\niowrite32(1, card->config_regs + WRITE_FLASH);\r\nwait_event(card->fw_wq, !ioread32(card->config_regs + FLASH_BUSY));\r\n}\r\nrelease_firmware(fw);\r\niowrite32(0, card->config_regs + WRITE_FLASH);\r\niowrite32(0, card->config_regs + FPGA_MODE);\r\niowrite32(0, card->config_regs + FLASH_MODE);\r\ndev_info(&card->dev->dev, "Returning FPGA to Data mode\n");\r\nreturn 0;\r\n}\r\nstatic irqreturn_t solos_irq(int irq, void *dev_id)\r\n{\r\nstruct solos_card *card = dev_id;\r\nint handled = 1;\r\niowrite32(0, card->config_regs + IRQ_CLEAR);\r\nif (card->atmdev[0])\r\ntasklet_schedule(&card->tlet);\r\nelse\r\nwake_up(&card->fw_wq);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void solos_bh(unsigned long card_arg)\r\n{\r\nstruct solos_card *card = (void *)card_arg;\r\nuint32_t card_flags;\r\nuint32_t rx_done = 0;\r\nint port;\r\ncard_flags = fpga_tx(card);\r\nfor (port = 0; port < card->nr_ports; port++) {\r\nif (card_flags & (0x10 << port)) {\r\nstruct pkt_hdr _hdr, *header;\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc;\r\nint size;\r\nif (card->using_dma) {\r\nskb = card->rx_skb[port];\r\ncard->rx_skb[port] = NULL;\r\ndma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,\r\nRX_DMA_SIZE, DMA_FROM_DEVICE);\r\nheader = (void *)skb->data;\r\nsize = le16_to_cpu(header->size);\r\nskb_put(skb, size + sizeof(*header));\r\nskb_pull(skb, sizeof(*header));\r\n} else {\r\nheader = &_hdr;\r\nrx_done |= 0x10 << port;\r\nmemcpy_fromio(header, RX_BUF(card, port), sizeof(*header));\r\nsize = le16_to_cpu(header->size);\r\nif (size > (card->buffer_size - sizeof(*header))){\r\ndev_warn(&card->dev->dev, "Invalid buffer size\n");\r\ncontinue;\r\n}\r\nskb = netdev_alloc_skb_ip_align(NULL, size + 1);\r\nif (!skb) {\r\nif (net_ratelimit())\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff for RX\n");\r\ncontinue;\r\n}\r\nmemcpy_fromio(skb_put(skb, size),\r\nRX_BUF(card, port) + sizeof(*header),\r\nsize);\r\n}\r\nif (atmdebug) {\r\ndev_info(&card->dev->dev, "Received: port %d\n", port);\r\ndev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",\r\nsize, le16_to_cpu(header->vpi),\r\nle16_to_cpu(header->vci));\r\nprint_buffer(skb);\r\n}\r\nswitch (le16_to_cpu(header->type)) {\r\ncase PKT_DATA:\r\nvcc = find_vcc(card->atmdev[port], le16_to_cpu(header->vpi),\r\nle16_to_cpu(header->vci));\r\nif (!vcc) {\r\nif (net_ratelimit())\r\ndev_warn(&card->dev->dev, "Received packet for unknown VPI.VCI %d.%d on port %d\n",\r\nle16_to_cpu(header->vpi), le16_to_cpu(header->vci),\r\nport);\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\n}\r\natm_charge(vcc, skb->truesize);\r\nvcc->push(vcc, skb);\r\natomic_inc(&vcc->stats->rx);\r\nbreak;\r\ncase PKT_STATUS:\r\nif (process_status(card, port, skb) &&\r\nnet_ratelimit()) {\r\ndev_warn(&card->dev->dev, "Bad status packet of %d bytes on port %d:\n", skb->len, port);\r\nprint_buffer(skb);\r\n}\r\ndev_kfree_skb_any(skb);\r\nbreak;\r\ncase PKT_COMMAND:\r\ndefault:\r\nif (process_command(card, port, skb))\r\nbreak;\r\nspin_lock(&card->cli_queue_lock);\r\nif (skb_queue_len(&card->cli_queue[port]) > 10) {\r\nif (net_ratelimit())\r\ndev_warn(&card->dev->dev, "Dropping console response on port %d\n",\r\nport);\r\ndev_kfree_skb_any(skb);\r\n} else\r\nskb_queue_tail(&card->cli_queue[port], skb);\r\nspin_unlock(&card->cli_queue_lock);\r\nbreak;\r\n}\r\n}\r\nif (card->using_dma && card->atmdev[port] &&\r\n!card->rx_skb[port]) {\r\nstruct sk_buff *skb = dev_alloc_skb(RX_DMA_SIZE);\r\nif (skb) {\r\nSKB_CB(skb)->dma_addr =\r\ndma_map_single(&card->dev->dev, skb->data,\r\nRX_DMA_SIZE, DMA_FROM_DEVICE);\r\niowrite32(SKB_CB(skb)->dma_addr,\r\ncard->config_regs + RX_DMA_ADDR(port));\r\ncard->rx_skb[port] = skb;\r\n} else {\r\nif (net_ratelimit())\r\ndev_warn(&card->dev->dev, "Failed to allocate RX skb");\r\ntasklet_schedule(&card->tlet);\r\n}\r\n}\r\n}\r\nif (rx_done)\r\niowrite32(rx_done, card->config_regs + FLAGS_ADDR);\r\nreturn;\r\n}\r\nstatic struct atm_vcc *find_vcc(struct atm_dev *dev, short vpi, int vci)\r\n{\r\nstruct hlist_head *head;\r\nstruct atm_vcc *vcc = NULL;\r\nstruct sock *s;\r\nread_lock(&vcc_sklist_lock);\r\nhead = &vcc_hash[vci & (VCC_HTABLE_SIZE -1)];\r\nsk_for_each(s, head) {\r\nvcc = atm_sk(s);\r\nif (vcc->dev == dev && vcc->vci == vci &&\r\nvcc->vpi == vpi && vcc->qos.rxtp.traffic_class != ATM_NONE &&\r\ntest_bit(ATM_VF_READY, &vcc->flags))\r\ngoto out;\r\n}\r\nvcc = NULL;\r\nout:\r\nread_unlock(&vcc_sklist_lock);\r\nreturn vcc;\r\n}\r\nstatic int popen(struct atm_vcc *vcc)\r\n{\r\nstruct solos_card *card = vcc->dev->dev_data;\r\nstruct sk_buff *skb;\r\nstruct pkt_hdr *header;\r\nif (vcc->qos.aal != ATM_AAL5) {\r\ndev_warn(&card->dev->dev, "Unsupported ATM type %d\n",\r\nvcc->qos.aal);\r\nreturn -EINVAL;\r\n}\r\nskb = alloc_skb(sizeof(*header), GFP_KERNEL);\r\nif (!skb) {\r\nif (net_ratelimit())\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff in popen()\n");\r\nreturn -ENOMEM;\r\n}\r\nheader = (void *)skb_put(skb, sizeof(*header));\r\nheader->size = cpu_to_le16(0);\r\nheader->vpi = cpu_to_le16(vcc->vpi);\r\nheader->vci = cpu_to_le16(vcc->vci);\r\nheader->type = cpu_to_le16(PKT_POPEN);\r\nfpga_queue(card, SOLOS_CHAN(vcc->dev), skb, NULL);\r\nset_bit(ATM_VF_ADDR, &vcc->flags);\r\nset_bit(ATM_VF_READY, &vcc->flags);\r\nreturn 0;\r\n}\r\nstatic void pclose(struct atm_vcc *vcc)\r\n{\r\nstruct solos_card *card = vcc->dev->dev_data;\r\nunsigned char port = SOLOS_CHAN(vcc->dev);\r\nstruct sk_buff *skb, *tmpskb;\r\nstruct pkt_hdr *header;\r\nspin_lock(&card->tx_queue_lock);\r\nskb_queue_walk_safe(&card->tx_queue[port], skb, tmpskb) {\r\nif (SKB_CB(skb)->vcc == vcc) {\r\nskb_unlink(skb, &card->tx_queue[port]);\r\nsolos_pop(vcc, skb);\r\n}\r\n}\r\nspin_unlock(&card->tx_queue_lock);\r\nskb = alloc_skb(sizeof(*header), GFP_KERNEL);\r\nif (!skb) {\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff in pclose()\n");\r\nreturn;\r\n}\r\nheader = (void *)skb_put(skb, sizeof(*header));\r\nheader->size = cpu_to_le16(0);\r\nheader->vpi = cpu_to_le16(vcc->vpi);\r\nheader->vci = cpu_to_le16(vcc->vci);\r\nheader->type = cpu_to_le16(PKT_PCLOSE);\r\nskb_get(skb);\r\nfpga_queue(card, port, skb, NULL);\r\nif (!wait_event_timeout(card->param_wq, !skb_shared(skb), 5 * HZ))\r\ndev_warn(&card->dev->dev,\r\n"Timeout waiting for VCC close on port %d\n", port);\r\ndev_kfree_skb(skb);\r\ntasklet_unlock_wait(&card->tlet);\r\nclear_bit(ATM_VF_ADDR, &vcc->flags);\r\nreturn;\r\n}\r\nstatic int print_buffer(struct sk_buff *buf)\r\n{\r\nint len,i;\r\nchar msg[500];\r\nchar item[10];\r\nlen = buf->len;\r\nfor (i = 0; i < len; i++){\r\nif(i % 8 == 0)\r\nsprintf(msg, "%02X: ", i);\r\nsprintf(item,"%02X ",*(buf->data + i));\r\nstrcat(msg, item);\r\nif(i % 8 == 7) {\r\nsprintf(item, "\n");\r\nstrcat(msg, item);\r\nprintk(KERN_DEBUG "%s", msg);\r\n}\r\n}\r\nif (i % 8 != 0) {\r\nsprintf(item, "\n");\r\nstrcat(msg, item);\r\nprintk(KERN_DEBUG "%s", msg);\r\n}\r\nprintk(KERN_DEBUG "\n");\r\nreturn 0;\r\n}\r\nstatic void fpga_queue(struct solos_card *card, int port, struct sk_buff *skb,\r\nstruct atm_vcc *vcc)\r\n{\r\nint old_len;\r\nunsigned long flags;\r\nSKB_CB(skb)->vcc = vcc;\r\nspin_lock_irqsave(&card->tx_queue_lock, flags);\r\nold_len = skb_queue_len(&card->tx_queue[port]);\r\nskb_queue_tail(&card->tx_queue[port], skb);\r\nif (!old_len)\r\ncard->tx_mask |= (1 << port);\r\nspin_unlock_irqrestore(&card->tx_queue_lock, flags);\r\nif (!old_len)\r\nfpga_tx(card);\r\n}\r\nstatic uint32_t fpga_tx(struct solos_card *card)\r\n{\r\nuint32_t tx_pending, card_flags;\r\nuint32_t tx_started = 0;\r\nstruct sk_buff *skb;\r\nstruct atm_vcc *vcc;\r\nunsigned char port;\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->tx_lock, flags);\r\ncard_flags = ioread32(card->config_regs + FLAGS_ADDR);\r\ntx_pending = card->tx_mask & ~card_flags;\r\nfor (port = 0; tx_pending; tx_pending >>= 1, port++) {\r\nif (tx_pending & 1) {\r\nstruct sk_buff *oldskb = card->tx_skb[port];\r\nif (oldskb) {\r\ndma_unmap_single(&card->dev->dev, SKB_CB(oldskb)->dma_addr,\r\noldskb->len, DMA_TO_DEVICE);\r\ncard->tx_skb[port] = NULL;\r\n}\r\nspin_lock(&card->tx_queue_lock);\r\nskb = skb_dequeue(&card->tx_queue[port]);\r\nif (!skb)\r\ncard->tx_mask &= ~(1 << port);\r\nspin_unlock(&card->tx_queue_lock);\r\nif (skb && !card->using_dma) {\r\nmemcpy_toio(TX_BUF(card, port), skb->data, skb->len);\r\ntx_started |= 1 << port;\r\noldskb = skb;\r\n} else if (skb && card->using_dma) {\r\nunsigned char *data = skb->data;\r\nif ((unsigned long)data & card->dma_alignment) {\r\ndata = card->dma_bounce + (BUF_SIZE * port);\r\nmemcpy(data, skb->data, skb->len);\r\n}\r\nSKB_CB(skb)->dma_addr = dma_map_single(&card->dev->dev, data,\r\nskb->len, DMA_TO_DEVICE);\r\ncard->tx_skb[port] = skb;\r\niowrite32(SKB_CB(skb)->dma_addr,\r\ncard->config_regs + TX_DMA_ADDR(port));\r\n}\r\nif (!oldskb)\r\ncontinue;\r\nif (atmdebug) {\r\nstruct pkt_hdr *header = (void *)oldskb->data;\r\nint size = le16_to_cpu(header->size);\r\nskb_pull(oldskb, sizeof(*header));\r\ndev_info(&card->dev->dev, "Transmitted: port %d\n",\r\nport);\r\ndev_info(&card->dev->dev, "size: %d VPI: %d VCI: %d\n",\r\nsize, le16_to_cpu(header->vpi),\r\nle16_to_cpu(header->vci));\r\nprint_buffer(oldskb);\r\n}\r\nvcc = SKB_CB(oldskb)->vcc;\r\nif (vcc) {\r\natomic_inc(&vcc->stats->tx);\r\nsolos_pop(vcc, oldskb);\r\n} else {\r\ndev_kfree_skb_irq(oldskb);\r\nwake_up(&card->param_wq);\r\n}\r\n}\r\n}\r\nif (tx_started)\r\niowrite32(tx_started, card->config_regs + FLAGS_ADDR);\r\nspin_unlock_irqrestore(&card->tx_lock, flags);\r\nreturn card_flags;\r\n}\r\nstatic int psend(struct atm_vcc *vcc, struct sk_buff *skb)\r\n{\r\nstruct solos_card *card = vcc->dev->dev_data;\r\nstruct pkt_hdr *header;\r\nint pktlen;\r\npktlen = skb->len;\r\nif (pktlen > (BUF_SIZE - sizeof(*header))) {\r\ndev_warn(&card->dev->dev, "Length of PDU is too large. Dropping PDU.\n");\r\nsolos_pop(vcc, skb);\r\nreturn 0;\r\n}\r\nif (!skb_clone_writable(skb, sizeof(*header))) {\r\nint expand_by = 0;\r\nint ret;\r\nif (skb_headroom(skb) < sizeof(*header))\r\nexpand_by = sizeof(*header) - skb_headroom(skb);\r\nret = pskb_expand_head(skb, expand_by, 0, GFP_ATOMIC);\r\nif (ret) {\r\ndev_warn(&card->dev->dev, "pskb_expand_head failed.\n");\r\nsolos_pop(vcc, skb);\r\nreturn ret;\r\n}\r\n}\r\nheader = (void *)skb_push(skb, sizeof(*header));\r\nheader->size = cpu_to_le16(pktlen);\r\nheader->vpi = cpu_to_le16(vcc->vpi);\r\nheader->vci = cpu_to_le16(vcc->vci);\r\nheader->type = cpu_to_le16(PKT_DATA);\r\nfpga_queue(card, SOLOS_CHAN(vcc->dev), skb, vcc);\r\nreturn 0;\r\n}\r\nstatic int fpga_probe(struct pci_dev *dev, const struct pci_device_id *id)\r\n{\r\nint err;\r\nuint16_t fpga_ver;\r\nuint8_t major_ver, minor_ver;\r\nuint32_t data32;\r\nstruct solos_card *card;\r\ncard = kzalloc(sizeof(*card), GFP_KERNEL);\r\nif (!card)\r\nreturn -ENOMEM;\r\ncard->dev = dev;\r\ninit_waitqueue_head(&card->fw_wq);\r\ninit_waitqueue_head(&card->param_wq);\r\nerr = pci_enable_device(dev);\r\nif (err) {\r\ndev_warn(&dev->dev, "Failed to enable PCI device\n");\r\ngoto out;\r\n}\r\nerr = dma_set_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\r\nif (err) {\r\ndev_warn(&dev->dev, "Failed to set 32-bit DMA mask\n");\r\ngoto out;\r\n}\r\nerr = pci_request_regions(dev, "solos");\r\nif (err) {\r\ndev_warn(&dev->dev, "Failed to request regions\n");\r\ngoto out;\r\n}\r\ncard->config_regs = pci_iomap(dev, 0, CONFIG_RAM_SIZE);\r\nif (!card->config_regs) {\r\ndev_warn(&dev->dev, "Failed to ioremap config registers\n");\r\nerr = -ENOMEM;\r\ngoto out_release_regions;\r\n}\r\ncard->buffers = pci_iomap(dev, 1, DATA_RAM_SIZE);\r\nif (!card->buffers) {\r\ndev_warn(&dev->dev, "Failed to ioremap data buffers\n");\r\nerr = -ENOMEM;\r\ngoto out_unmap_config;\r\n}\r\nif (reset) {\r\niowrite32(1, card->config_regs + FPGA_MODE);\r\ndata32 = ioread32(card->config_regs + FPGA_MODE);\r\niowrite32(0, card->config_regs + FPGA_MODE);\r\ndata32 = ioread32(card->config_regs + FPGA_MODE);\r\n}\r\ndata32 = ioread32(card->config_regs + FPGA_VER);\r\nfpga_ver = (data32 & 0x0000FFFF);\r\nmajor_ver = ((data32 & 0xFF000000) >> 24);\r\nminor_ver = ((data32 & 0x00FF0000) >> 16);\r\ncard->fpga_version = FPGA_VERSION(major_ver,minor_ver);\r\nif (card->fpga_version > LEGACY_BUFFERS)\r\ncard->buffer_size = BUF_SIZE;\r\nelse\r\ncard->buffer_size = OLD_BUF_SIZE;\r\ndev_info(&dev->dev, "Solos FPGA Version %d.%02d svn-%d\n",\r\nmajor_ver, minor_ver, fpga_ver);\r\nif (fpga_ver < 37 && (fpga_upgrade || firmware_upgrade ||\r\ndb_fpga_upgrade || db_firmware_upgrade)) {\r\ndev_warn(&dev->dev,\r\n"FPGA too old; cannot upgrade flash. Use JTAG.\n");\r\nfpga_upgrade = firmware_upgrade = 0;\r\ndb_fpga_upgrade = db_firmware_upgrade = 0;\r\n}\r\nif (fpga_ver < 39)\r\ncard->atmel_flash = 1;\r\nelse\r\ncard->atmel_flash = 0;\r\ndata32 = ioread32(card->config_regs + PORTS);\r\ncard->nr_ports = (data32 & 0x000000FF);\r\nif (card->fpga_version >= DMA_SUPPORTED) {\r\npci_set_master(dev);\r\ncard->using_dma = 1;\r\nif (1) {\r\ncard->dma_alignment = 3;\r\ncard->dma_bounce = kmalloc(card->nr_ports * BUF_SIZE, GFP_KERNEL);\r\nif (!card->dma_bounce) {\r\ndev_warn(&card->dev->dev, "Failed to allocate DMA bounce buffers\n");\r\nerr = -ENOMEM;\r\ngoto out_unmap_both;\r\n}\r\n}\r\n} else {\r\ncard->using_dma = 0;\r\niowrite32(0xF0, card->config_regs + FLAGS_ADDR);\r\n}\r\npci_set_drvdata(dev, card);\r\ntasklet_init(&card->tlet, solos_bh, (unsigned long)card);\r\nspin_lock_init(&card->tx_lock);\r\nspin_lock_init(&card->tx_queue_lock);\r\nspin_lock_init(&card->cli_queue_lock);\r\nspin_lock_init(&card->param_queue_lock);\r\nINIT_LIST_HEAD(&card->param_queue);\r\nerr = request_irq(dev->irq, solos_irq, IRQF_SHARED,\r\n"solos-pci", card);\r\nif (err) {\r\ndev_dbg(&card->dev->dev, "Failed to request interrupt IRQ: %d\n", dev->irq);\r\ngoto out_unmap_both;\r\n}\r\niowrite32(1, card->config_regs + IRQ_EN_ADDR);\r\nif (fpga_upgrade)\r\nflash_upgrade(card, 0);\r\nif (firmware_upgrade)\r\nflash_upgrade(card, 1);\r\nif (db_fpga_upgrade)\r\nflash_upgrade(card, 2);\r\nif (db_firmware_upgrade)\r\nflash_upgrade(card, 3);\r\nerr = atm_init(card, &dev->dev);\r\nif (err)\r\ngoto out_free_irq;\r\nif (card->fpga_version >= DMA_SUPPORTED &&\r\nsysfs_create_group(&card->dev->dev.kobj, &gpio_attr_group))\r\ndev_err(&card->dev->dev, "Could not register parameter group for GPIOs\n");\r\nreturn 0;\r\nout_free_irq:\r\niowrite32(0, card->config_regs + IRQ_EN_ADDR);\r\nfree_irq(dev->irq, card);\r\ntasklet_kill(&card->tlet);\r\nout_unmap_both:\r\nkfree(card->dma_bounce);\r\npci_iounmap(dev, card->buffers);\r\nout_unmap_config:\r\npci_iounmap(dev, card->config_regs);\r\nout_release_regions:\r\npci_release_regions(dev);\r\nout:\r\nkfree(card);\r\nreturn err;\r\n}\r\nstatic int atm_init(struct solos_card *card, struct device *parent)\r\n{\r\nint i;\r\nfor (i = 0; i < card->nr_ports; i++) {\r\nstruct sk_buff *skb;\r\nstruct pkt_hdr *header;\r\nskb_queue_head_init(&card->tx_queue[i]);\r\nskb_queue_head_init(&card->cli_queue[i]);\r\ncard->atmdev[i] = atm_dev_register("solos-pci", parent, &fpga_ops, -1, NULL);\r\nif (!card->atmdev[i]) {\r\ndev_err(&card->dev->dev, "Could not register ATM device %d\n", i);\r\natm_remove(card);\r\nreturn -ENODEV;\r\n}\r\nif (device_create_file(&card->atmdev[i]->class_dev, &dev_attr_console))\r\ndev_err(&card->dev->dev, "Could not register console for ATM device %d\n", i);\r\nif (sysfs_create_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group))\r\ndev_err(&card->dev->dev, "Could not register parameter group for ATM device %d\n", i);\r\ndev_info(&card->dev->dev, "Registered ATM device %d\n", card->atmdev[i]->number);\r\ncard->atmdev[i]->ci_range.vpi_bits = 8;\r\ncard->atmdev[i]->ci_range.vci_bits = 16;\r\ncard->atmdev[i]->dev_data = card;\r\ncard->atmdev[i]->phy_data = (void *)(unsigned long)i;\r\natm_dev_signal_change(card->atmdev[i], ATM_PHY_SIG_FOUND);\r\nskb = alloc_skb(sizeof(*header), GFP_KERNEL);\r\nif (!skb) {\r\ndev_warn(&card->dev->dev, "Failed to allocate sk_buff in atm_init()\n");\r\ncontinue;\r\n}\r\nheader = (void *)skb_put(skb, sizeof(*header));\r\nheader->size = cpu_to_le16(0);\r\nheader->vpi = cpu_to_le16(0);\r\nheader->vci = cpu_to_le16(0);\r\nheader->type = cpu_to_le16(PKT_STATUS);\r\nfpga_queue(card, i, skb, NULL);\r\n}\r\nreturn 0;\r\n}\r\nstatic void atm_remove(struct solos_card *card)\r\n{\r\nint i;\r\nfor (i = 0; i < card->nr_ports; i++) {\r\nif (card->atmdev[i]) {\r\nstruct sk_buff *skb;\r\ndev_info(&card->dev->dev, "Unregistering ATM device %d\n", card->atmdev[i]->number);\r\nsysfs_remove_group(&card->atmdev[i]->class_dev.kobj, &solos_attr_group);\r\natm_dev_deregister(card->atmdev[i]);\r\nskb = card->rx_skb[i];\r\nif (skb) {\r\ndma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,\r\nRX_DMA_SIZE, DMA_FROM_DEVICE);\r\ndev_kfree_skb(skb);\r\n}\r\nskb = card->tx_skb[i];\r\nif (skb) {\r\ndma_unmap_single(&card->dev->dev, SKB_CB(skb)->dma_addr,\r\nskb->len, DMA_TO_DEVICE);\r\ndev_kfree_skb(skb);\r\n}\r\nwhile ((skb = skb_dequeue(&card->tx_queue[i])))\r\ndev_kfree_skb(skb);\r\n}\r\n}\r\n}\r\nstatic void fpga_remove(struct pci_dev *dev)\r\n{\r\nstruct solos_card *card = pci_get_drvdata(dev);\r\niowrite32(0, card->config_regs + IRQ_EN_ADDR);\r\niowrite32(1, card->config_regs + FPGA_MODE);\r\n(void)ioread32(card->config_regs + FPGA_MODE);\r\nif (card->fpga_version >= DMA_SUPPORTED)\r\nsysfs_remove_group(&card->dev->dev.kobj, &gpio_attr_group);\r\natm_remove(card);\r\nfree_irq(dev->irq, card);\r\ntasklet_kill(&card->tlet);\r\nkfree(card->dma_bounce);\r\niowrite32(0, card->config_regs + FPGA_MODE);\r\n(void)ioread32(card->config_regs + FPGA_MODE);\r\npci_iounmap(dev, card->buffers);\r\npci_iounmap(dev, card->config_regs);\r\npci_release_regions(dev);\r\npci_disable_device(dev);\r\nkfree(card);\r\n}\r\nstatic int __init solos_pci_init(void)\r\n{\r\nBUILD_BUG_ON(sizeof(struct solos_skb_cb) > sizeof(((struct sk_buff *)0)->cb));\r\nprintk(KERN_INFO "Solos PCI Driver Version %s\n", VERSION);\r\nreturn pci_register_driver(&fpga_driver);\r\n}\r\nstatic void __exit solos_pci_exit(void)\r\n{\r\npci_unregister_driver(&fpga_driver);\r\nprintk(KERN_INFO "Solos PCI Driver %s Unloaded\n", VERSION);\r\n}
