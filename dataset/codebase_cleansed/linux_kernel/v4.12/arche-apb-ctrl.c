static inline void deassert_reset(unsigned int gpio)\r\n{\r\ngpio_set_value(gpio, 1);\r\n}\r\nstatic inline void assert_reset(unsigned int gpio)\r\n{\r\ngpio_set_value(gpio, 0);\r\n}\r\nstatic int coldboot_seq(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\r\nint ret;\r\nif (apb->init_disabled ||\r\napb->state == ARCHE_PLATFORM_STATE_ACTIVE)\r\nreturn 0;\r\nassert_reset(apb->resetn_gpio);\r\nif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&\r\ngpio_is_valid(apb->spi_en_gpio))\r\ndevm_gpio_free(dev, apb->spi_en_gpio);\r\nif (!IS_ERR(apb->vcore)) {\r\nret = regulator_enable(apb->vcore);\r\nif (ret) {\r\ndev_err(dev, "failed to enable core regulator\n");\r\nreturn ret;\r\n}\r\n}\r\nif (!IS_ERR(apb->vio)) {\r\nret = regulator_enable(apb->vio);\r\nif (ret) {\r\ndev_err(dev, "failed to enable IO regulator\n");\r\nreturn ret;\r\n}\r\n}\r\napb_bootret_deassert(dev);\r\nif (gpio_is_valid(apb->clk_en_gpio))\r\ngpio_set_value(apb->clk_en_gpio, 1);\r\nusleep_range(100, 200);\r\ndeassert_reset(apb->resetn_gpio);\r\napb->state = ARCHE_PLATFORM_STATE_ACTIVE;\r\nreturn 0;\r\n}\r\nstatic int fw_flashing_seq(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\r\nint ret;\r\nif (apb->init_disabled ||\r\napb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\r\nreturn 0;\r\nret = regulator_enable(apb->vcore);\r\nif (ret) {\r\ndev_err(dev, "failed to enable core regulator\n");\r\nreturn ret;\r\n}\r\nret = regulator_enable(apb->vio);\r\nif (ret) {\r\ndev_err(dev, "failed to enable IO regulator\n");\r\nreturn ret;\r\n}\r\nif (gpio_is_valid(apb->spi_en_gpio)) {\r\nunsigned long flags;\r\nif (apb->spi_en_polarity_high)\r\nflags = GPIOF_OUT_INIT_HIGH;\r\nelse\r\nflags = GPIOF_OUT_INIT_LOW;\r\nret = devm_gpio_request_one(dev, apb->spi_en_gpio,\r\nflags, "apb_spi_en");\r\nif (ret) {\r\ndev_err(dev, "Failed requesting SPI bus en gpio %d\n",\r\napb->spi_en_gpio);\r\nreturn ret;\r\n}\r\n}\r\nassert_reset(apb->resetn_gpio);\r\napb->state = ARCHE_PLATFORM_STATE_FW_FLASHING;\r\nreturn 0;\r\n}\r\nstatic int standby_boot_seq(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\r\nif (apb->init_disabled)\r\nreturn 0;\r\nif (apb->state == ARCHE_PLATFORM_STATE_STANDBY ||\r\napb->state == ARCHE_PLATFORM_STATE_OFF)\r\nreturn 0;\r\nif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&\r\ngpio_is_valid(apb->spi_en_gpio))\r\ndevm_gpio_free(dev, apb->spi_en_gpio);\r\napb->state = ARCHE_PLATFORM_STATE_STANDBY;\r\nreturn 0;\r\n}\r\nstatic void poweroff_seq(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\r\nif (apb->init_disabled || apb->state == ARCHE_PLATFORM_STATE_OFF)\r\nreturn;\r\nif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING &&\r\ngpio_is_valid(apb->spi_en_gpio))\r\ndevm_gpio_free(dev, apb->spi_en_gpio);\r\nif (gpio_is_valid(apb->clk_en_gpio))\r\ngpio_set_value(apb->clk_en_gpio, 0);\r\nif (!IS_ERR(apb->vcore) && regulator_is_enabled(apb->vcore) > 0)\r\nregulator_disable(apb->vcore);\r\nif (!IS_ERR(apb->vio) && regulator_is_enabled(apb->vio) > 0)\r\nregulator_disable(apb->vio);\r\nassert_reset(apb->resetn_gpio);\r\napb->state = ARCHE_PLATFORM_STATE_OFF;\r\n}\r\nvoid apb_bootret_assert(struct device *dev)\r\n{\r\nstruct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);\r\ngpio_set_value(apb->boot_ret_gpio, 1);\r\n}\r\nvoid apb_bootret_deassert(struct device *dev)\r\n{\r\nstruct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);\r\ngpio_set_value(apb->boot_ret_gpio, 0);\r\n}\r\nint apb_ctrl_coldboot(struct device *dev)\r\n{\r\nreturn coldboot_seq(to_platform_device(dev));\r\n}\r\nint apb_ctrl_fw_flashing(struct device *dev)\r\n{\r\nreturn fw_flashing_seq(to_platform_device(dev));\r\n}\r\nint apb_ctrl_standby_boot(struct device *dev)\r\n{\r\nreturn standby_boot_seq(to_platform_device(dev));\r\n}\r\nvoid apb_ctrl_poweroff(struct device *dev)\r\n{\r\npoweroff_seq(to_platform_device(dev));\r\n}\r\nstatic ssize_t state_store(struct device *dev,\r\nstruct device_attribute *attr, const char *buf, size_t count)\r\n{\r\nstruct platform_device *pdev = to_platform_device(dev);\r\nstruct arche_apb_ctrl_drvdata *apb = platform_get_drvdata(pdev);\r\nint ret = 0;\r\nbool is_disabled;\r\nif (sysfs_streq(buf, "off")) {\r\nif (apb->state == ARCHE_PLATFORM_STATE_OFF)\r\nreturn count;\r\npoweroff_seq(pdev);\r\n} else if (sysfs_streq(buf, "active")) {\r\nif (apb->state == ARCHE_PLATFORM_STATE_ACTIVE)\r\nreturn count;\r\npoweroff_seq(pdev);\r\nis_disabled = apb->init_disabled;\r\napb->init_disabled = false;\r\nret = coldboot_seq(pdev);\r\nif (ret)\r\napb->init_disabled = is_disabled;\r\n} else if (sysfs_streq(buf, "standby")) {\r\nif (apb->state == ARCHE_PLATFORM_STATE_STANDBY)\r\nreturn count;\r\nret = standby_boot_seq(pdev);\r\n} else if (sysfs_streq(buf, "fw_flashing")) {\r\nif (apb->state == ARCHE_PLATFORM_STATE_FW_FLASHING)\r\nreturn count;\r\npoweroff_seq(pdev);\r\nret = fw_flashing_seq(pdev);\r\n} else {\r\ndev_err(dev, "unknown state\n");\r\nret = -EINVAL;\r\n}\r\nreturn ret ? ret : count;\r\n}\r\nstatic ssize_t state_show(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct arche_apb_ctrl_drvdata *apb = dev_get_drvdata(dev);\r\nswitch (apb->state) {\r\ncase ARCHE_PLATFORM_STATE_OFF:\r\nreturn sprintf(buf, "off%s\n",\r\napb->init_disabled ? ",disabled" : "");\r\ncase ARCHE_PLATFORM_STATE_ACTIVE:\r\nreturn sprintf(buf, "active\n");\r\ncase ARCHE_PLATFORM_STATE_STANDBY:\r\nreturn sprintf(buf, "standby\n");\r\ncase ARCHE_PLATFORM_STATE_FW_FLASHING:\r\nreturn sprintf(buf, "fw_flashing\n");\r\ndefault:\r\nreturn sprintf(buf, "unknown state\n");\r\n}\r\n}\r\nstatic int apb_ctrl_get_devtree_data(struct platform_device *pdev,\r\nstruct arche_apb_ctrl_drvdata *apb)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nint ret;\r\napb->resetn_gpio = of_get_named_gpio(np, "reset-gpios", 0);\r\nif (apb->resetn_gpio < 0) {\r\ndev_err(dev, "failed to get reset gpio\n");\r\nreturn apb->resetn_gpio;\r\n}\r\nret = devm_gpio_request_one(dev, apb->resetn_gpio,\r\nGPIOF_OUT_INIT_LOW, "apb-reset");\r\nif (ret) {\r\ndev_err(dev, "Failed requesting reset gpio %d\n",\r\napb->resetn_gpio);\r\nreturn ret;\r\n}\r\napb->boot_ret_gpio = of_get_named_gpio(np, "boot-ret-gpios", 0);\r\nif (apb->boot_ret_gpio < 0) {\r\ndev_err(dev, "failed to get boot retention gpio\n");\r\nreturn apb->boot_ret_gpio;\r\n}\r\nret = devm_gpio_request_one(dev, apb->boot_ret_gpio,\r\nGPIOF_OUT_INIT_LOW, "boot retention");\r\nif (ret) {\r\ndev_err(dev, "Failed requesting bootret gpio %d\n",\r\napb->boot_ret_gpio);\r\nreturn ret;\r\n}\r\napb->pwroff_gpio = of_get_named_gpio(np, "pwr-off-gpios", 0);\r\nif (apb->pwroff_gpio < 0) {\r\ndev_err(dev, "failed to get power off gpio\n");\r\nreturn apb->pwroff_gpio;\r\n}\r\nret = devm_gpio_request_one(dev, apb->pwroff_gpio,\r\nGPIOF_IN, "pwroff_n");\r\nif (ret) {\r\ndev_err(dev, "Failed requesting pwroff_n gpio %d\n",\r\napb->pwroff_gpio);\r\nreturn ret;\r\n}\r\napb->clk_en_gpio = of_get_named_gpio(np, "clock-en-gpio", 0);\r\nif (apb->clk_en_gpio < 0) {\r\ndev_warn(dev, "failed to get clock en gpio\n");\r\n} else if (gpio_is_valid(apb->clk_en_gpio)) {\r\nret = devm_gpio_request_one(dev, apb->clk_en_gpio,\r\nGPIOF_OUT_INIT_LOW, "apb_clk_en");\r\nif (ret) {\r\ndev_warn(dev, "Failed requesting APB clock en gpio %d\n",\r\napb->clk_en_gpio);\r\nreturn ret;\r\n}\r\n}\r\napb->pwrdn_gpio = of_get_named_gpio(np, "pwr-down-gpios", 0);\r\nif (apb->pwrdn_gpio < 0)\r\ndev_warn(dev, "failed to get power down gpio\n");\r\napb->vcore = devm_regulator_get(dev, "vcore");\r\nif (IS_ERR(apb->vcore))\r\ndev_warn(dev, "no core regulator found\n");\r\napb->vio = devm_regulator_get(dev, "vio");\r\nif (IS_ERR(apb->vio))\r\ndev_warn(dev, "no IO regulator found\n");\r\napb->pinctrl = devm_pinctrl_get(&pdev->dev);\r\nif (IS_ERR(apb->pinctrl)) {\r\ndev_err(&pdev->dev, "could not get pinctrl handle\n");\r\nreturn PTR_ERR(apb->pinctrl);\r\n}\r\napb->pin_default = pinctrl_lookup_state(apb->pinctrl, "default");\r\nif (IS_ERR(apb->pin_default)) {\r\ndev_err(&pdev->dev, "could not get default pin state\n");\r\nreturn PTR_ERR(apb->pin_default);\r\n}\r\napb->spi_en_gpio = of_get_named_gpio(np, "spi-en-gpio", 0);\r\nif (apb->spi_en_gpio >= 0) {\r\nif (of_property_read_bool(pdev->dev.of_node,\r\n"spi-en-active-high"))\r\napb->spi_en_polarity_high = true;\r\n}\r\nreturn 0;\r\n}\r\nstatic int arche_apb_ctrl_probe(struct platform_device *pdev)\r\n{\r\nint ret;\r\nstruct arche_apb_ctrl_drvdata *apb;\r\nstruct device *dev = &pdev->dev;\r\napb = devm_kzalloc(&pdev->dev, sizeof(*apb), GFP_KERNEL);\r\nif (!apb)\r\nreturn -ENOMEM;\r\nret = apb_ctrl_get_devtree_data(pdev, apb);\r\nif (ret) {\r\ndev_err(dev, "failed to get apb devicetree data %d\n", ret);\r\nreturn ret;\r\n}\r\napb->state = ARCHE_PLATFORM_STATE_OFF;\r\nif (of_property_read_bool(pdev->dev.of_node, "arche,init-disable"))\r\napb->init_disabled = true;\r\nplatform_set_drvdata(pdev, apb);\r\nret = device_create_file(dev, &dev_attr_state);\r\nif (ret) {\r\ndev_err(dev, "failed to create state file in sysfs\n");\r\nreturn ret;\r\n}\r\ndev_info(&pdev->dev, "Device registered successfully\n");\r\nreturn 0;\r\n}\r\nstatic int arche_apb_ctrl_remove(struct platform_device *pdev)\r\n{\r\ndevice_remove_file(&pdev->dev, &dev_attr_state);\r\npoweroff_seq(pdev);\r\nplatform_set_drvdata(pdev, NULL);\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused arche_apb_ctrl_suspend(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic int __maybe_unused arche_apb_ctrl_resume(struct device *dev)\r\n{\r\nreturn 0;\r\n}\r\nstatic void arche_apb_ctrl_shutdown(struct platform_device *pdev)\r\n{\r\napb_ctrl_poweroff(&pdev->dev);\r\n}\r\nint __init arche_apb_init(void)\r\n{\r\nreturn platform_driver_register(&arche_apb_ctrl_device_driver);\r\n}\r\nvoid __exit arche_apb_exit(void)\r\n{\r\nplatform_driver_unregister(&arche_apb_ctrl_device_driver);\r\n}
