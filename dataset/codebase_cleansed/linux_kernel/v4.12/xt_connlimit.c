static inline unsigned int connlimit_iphash(__be32 addr)\r\n{\r\nreturn jhash_1word((__force __u32)addr,\r\nconnlimit_rnd) % CONNLIMIT_SLOTS;\r\n}\r\nstatic inline unsigned int\r\nconnlimit_iphash6(const union nf_inet_addr *addr,\r\nconst union nf_inet_addr *mask)\r\n{\r\nunion nf_inet_addr res;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(addr->ip6); ++i)\r\nres.ip6[i] = addr->ip6[i] & mask->ip6[i];\r\nreturn jhash2((u32 *)res.ip6, ARRAY_SIZE(res.ip6),\r\nconnlimit_rnd) % CONNLIMIT_SLOTS;\r\n}\r\nstatic inline bool already_closed(const struct nf_conn *conn)\r\n{\r\nif (nf_ct_protonum(conn) == IPPROTO_TCP)\r\nreturn conn->proto.tcp.state == TCP_CONNTRACK_TIME_WAIT ||\r\nconn->proto.tcp.state == TCP_CONNTRACK_CLOSE;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int\r\nsame_source_net(const union nf_inet_addr *addr,\r\nconst union nf_inet_addr *mask,\r\nconst union nf_inet_addr *u3, u_int8_t family)\r\n{\r\nif (family == NFPROTO_IPV4) {\r\nreturn ntohl(addr->ip & mask->ip) -\r\nntohl(u3->ip & mask->ip);\r\n} else {\r\nunion nf_inet_addr lh, rh;\r\nunsigned int i;\r\nfor (i = 0; i < ARRAY_SIZE(addr->ip6); ++i) {\r\nlh.ip6[i] = addr->ip6[i] & mask->ip6[i];\r\nrh.ip6[i] = u3->ip6[i] & mask->ip6[i];\r\n}\r\nreturn memcmp(&lh.ip6, &rh.ip6, sizeof(lh.ip6));\r\n}\r\n}\r\nstatic bool add_hlist(struct hlist_head *head,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst union nf_inet_addr *addr)\r\n{\r\nstruct xt_connlimit_conn *conn;\r\nconn = kmem_cache_alloc(connlimit_conn_cachep, GFP_ATOMIC);\r\nif (conn == NULL)\r\nreturn false;\r\nconn->tuple = *tuple;\r\nconn->addr = *addr;\r\nhlist_add_head(&conn->node, head);\r\nreturn true;\r\n}\r\nstatic unsigned int check_hlist(struct net *net,\r\nstruct hlist_head *head,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst struct nf_conntrack_zone *zone,\r\nbool *addit)\r\n{\r\nconst struct nf_conntrack_tuple_hash *found;\r\nstruct xt_connlimit_conn *conn;\r\nstruct hlist_node *n;\r\nstruct nf_conn *found_ct;\r\nunsigned int length = 0;\r\n*addit = true;\r\nrcu_read_lock();\r\nhlist_for_each_entry_safe(conn, n, head, node) {\r\nfound = nf_conntrack_find_get(net, zone, &conn->tuple);\r\nif (found == NULL) {\r\nhlist_del(&conn->node);\r\nkmem_cache_free(connlimit_conn_cachep, conn);\r\ncontinue;\r\n}\r\nfound_ct = nf_ct_tuplehash_to_ctrack(found);\r\nif (nf_ct_tuple_equal(&conn->tuple, tuple)) {\r\n*addit = false;\r\n} else if (already_closed(found_ct)) {\r\nnf_ct_put(found_ct);\r\nhlist_del(&conn->node);\r\nkmem_cache_free(connlimit_conn_cachep, conn);\r\ncontinue;\r\n}\r\nnf_ct_put(found_ct);\r\nlength++;\r\n}\r\nrcu_read_unlock();\r\nreturn length;\r\n}\r\nstatic void tree_nodes_free(struct rb_root *root,\r\nstruct xt_connlimit_rb *gc_nodes[],\r\nunsigned int gc_count)\r\n{\r\nstruct xt_connlimit_rb *rbconn;\r\nwhile (gc_count) {\r\nrbconn = gc_nodes[--gc_count];\r\nrb_erase(&rbconn->node, root);\r\nkmem_cache_free(connlimit_rb_cachep, rbconn);\r\n}\r\n}\r\nstatic unsigned int\r\ncount_tree(struct net *net, struct rb_root *root,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst union nf_inet_addr *addr, const union nf_inet_addr *mask,\r\nu8 family, const struct nf_conntrack_zone *zone)\r\n{\r\nstruct xt_connlimit_rb *gc_nodes[CONNLIMIT_GC_MAX_NODES];\r\nstruct rb_node **rbnode, *parent;\r\nstruct xt_connlimit_rb *rbconn;\r\nstruct xt_connlimit_conn *conn;\r\nunsigned int gc_count;\r\nbool no_gc = false;\r\nrestart:\r\ngc_count = 0;\r\nparent = NULL;\r\nrbnode = &(root->rb_node);\r\nwhile (*rbnode) {\r\nint diff;\r\nbool addit;\r\nrbconn = rb_entry(*rbnode, struct xt_connlimit_rb, node);\r\nparent = *rbnode;\r\ndiff = same_source_net(addr, mask, &rbconn->addr, family);\r\nif (diff < 0) {\r\nrbnode = &((*rbnode)->rb_left);\r\n} else if (diff > 0) {\r\nrbnode = &((*rbnode)->rb_right);\r\n} else {\r\nunsigned int count;\r\ncount = check_hlist(net, &rbconn->hhead, tuple, zone, &addit);\r\ntree_nodes_free(root, gc_nodes, gc_count);\r\nif (!addit)\r\nreturn count;\r\nif (!add_hlist(&rbconn->hhead, tuple, addr))\r\nreturn 0;\r\nreturn count + 1;\r\n}\r\nif (no_gc || gc_count >= ARRAY_SIZE(gc_nodes))\r\ncontinue;\r\ncheck_hlist(net, &rbconn->hhead, tuple, zone, &addit);\r\nif (hlist_empty(&rbconn->hhead))\r\ngc_nodes[gc_count++] = rbconn;\r\n}\r\nif (gc_count) {\r\nno_gc = true;\r\ntree_nodes_free(root, gc_nodes, gc_count);\r\ngoto restart;\r\n}\r\nrbconn = kmem_cache_alloc(connlimit_rb_cachep, GFP_ATOMIC);\r\nif (rbconn == NULL)\r\nreturn 0;\r\nconn = kmem_cache_alloc(connlimit_conn_cachep, GFP_ATOMIC);\r\nif (conn == NULL) {\r\nkmem_cache_free(connlimit_rb_cachep, rbconn);\r\nreturn 0;\r\n}\r\nconn->tuple = *tuple;\r\nconn->addr = *addr;\r\nrbconn->addr = *addr;\r\nINIT_HLIST_HEAD(&rbconn->hhead);\r\nhlist_add_head(&conn->node, &rbconn->hhead);\r\nrb_link_node(&rbconn->node, parent, rbnode);\r\nrb_insert_color(&rbconn->node, root);\r\nreturn 1;\r\n}\r\nstatic int count_them(struct net *net,\r\nstruct xt_connlimit_data *data,\r\nconst struct nf_conntrack_tuple *tuple,\r\nconst union nf_inet_addr *addr,\r\nconst union nf_inet_addr *mask,\r\nu_int8_t family,\r\nconst struct nf_conntrack_zone *zone)\r\n{\r\nstruct rb_root *root;\r\nint count;\r\nu32 hash;\r\nif (family == NFPROTO_IPV6) {\r\nhash = connlimit_iphash6(addr, mask);\r\nroot = &data->climit_root6[hash];\r\n} else {\r\nhash = connlimit_iphash(addr->ip & mask->ip);\r\nroot = &data->climit_root4[hash];\r\n}\r\nspin_lock_bh(&xt_connlimit_locks[hash % CONNLIMIT_LOCK_SLOTS]);\r\ncount = count_tree(net, root, tuple, addr, mask, family, zone);\r\nspin_unlock_bh(&xt_connlimit_locks[hash % CONNLIMIT_LOCK_SLOTS]);\r\nreturn count;\r\n}\r\nstatic bool\r\nconnlimit_mt(const struct sk_buff *skb, struct xt_action_param *par)\r\n{\r\nstruct net *net = xt_net(par);\r\nconst struct xt_connlimit_info *info = par->matchinfo;\r\nunion nf_inet_addr addr;\r\nstruct nf_conntrack_tuple tuple;\r\nconst struct nf_conntrack_tuple *tuple_ptr = &tuple;\r\nconst struct nf_conntrack_zone *zone = &nf_ct_zone_dflt;\r\nenum ip_conntrack_info ctinfo;\r\nconst struct nf_conn *ct;\r\nunsigned int connections;\r\nct = nf_ct_get(skb, &ctinfo);\r\nif (ct != NULL) {\r\ntuple_ptr = &ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple;\r\nzone = nf_ct_zone(ct);\r\n} else if (!nf_ct_get_tuplepr(skb, skb_network_offset(skb),\r\nxt_family(par), net, &tuple)) {\r\ngoto hotdrop;\r\n}\r\nif (xt_family(par) == NFPROTO_IPV6) {\r\nconst struct ipv6hdr *iph = ipv6_hdr(skb);\r\nmemcpy(&addr.ip6, (info->flags & XT_CONNLIMIT_DADDR) ?\r\n&iph->daddr : &iph->saddr, sizeof(addr.ip6));\r\n} else {\r\nconst struct iphdr *iph = ip_hdr(skb);\r\naddr.ip = (info->flags & XT_CONNLIMIT_DADDR) ?\r\niph->daddr : iph->saddr;\r\n}\r\nconnections = count_them(net, info->data, tuple_ptr, &addr,\r\n&info->mask, xt_family(par), zone);\r\nif (connections == 0)\r\ngoto hotdrop;\r\nreturn (connections > info->limit) ^\r\n!!(info->flags & XT_CONNLIMIT_INVERT);\r\nhotdrop:\r\npar->hotdrop = true;\r\nreturn false;\r\n}\r\nstatic int connlimit_mt_check(const struct xt_mtchk_param *par)\r\n{\r\nstruct xt_connlimit_info *info = par->matchinfo;\r\nunsigned int i;\r\nint ret;\r\nnet_get_random_once(&connlimit_rnd, sizeof(connlimit_rnd));\r\nret = nf_ct_netns_get(par->net, par->family);\r\nif (ret < 0) {\r\npr_info("cannot load conntrack support for "\r\n"address family %u\n", par->family);\r\nreturn ret;\r\n}\r\ninfo->data = kmalloc(sizeof(struct xt_connlimit_data), GFP_KERNEL);\r\nif (info->data == NULL) {\r\nnf_ct_netns_put(par->net, par->family);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < ARRAY_SIZE(info->data->climit_root4); ++i)\r\ninfo->data->climit_root4[i] = RB_ROOT;\r\nfor (i = 0; i < ARRAY_SIZE(info->data->climit_root6); ++i)\r\ninfo->data->climit_root6[i] = RB_ROOT;\r\nreturn 0;\r\n}\r\nstatic void destroy_tree(struct rb_root *r)\r\n{\r\nstruct xt_connlimit_conn *conn;\r\nstruct xt_connlimit_rb *rbconn;\r\nstruct hlist_node *n;\r\nstruct rb_node *node;\r\nwhile ((node = rb_first(r)) != NULL) {\r\nrbconn = rb_entry(node, struct xt_connlimit_rb, node);\r\nrb_erase(node, r);\r\nhlist_for_each_entry_safe(conn, n, &rbconn->hhead, node)\r\nkmem_cache_free(connlimit_conn_cachep, conn);\r\nkmem_cache_free(connlimit_rb_cachep, rbconn);\r\n}\r\n}\r\nstatic void connlimit_mt_destroy(const struct xt_mtdtor_param *par)\r\n{\r\nconst struct xt_connlimit_info *info = par->matchinfo;\r\nunsigned int i;\r\nnf_ct_netns_put(par->net, par->family);\r\nfor (i = 0; i < ARRAY_SIZE(info->data->climit_root4); ++i)\r\ndestroy_tree(&info->data->climit_root4[i]);\r\nfor (i = 0; i < ARRAY_SIZE(info->data->climit_root6); ++i)\r\ndestroy_tree(&info->data->climit_root6[i]);\r\nkfree(info->data);\r\n}\r\nstatic int __init connlimit_mt_init(void)\r\n{\r\nint ret, i;\r\nBUILD_BUG_ON(CONNLIMIT_LOCK_SLOTS > CONNLIMIT_SLOTS);\r\nBUILD_BUG_ON((CONNLIMIT_SLOTS % CONNLIMIT_LOCK_SLOTS) != 0);\r\nfor (i = 0; i < CONNLIMIT_LOCK_SLOTS; ++i)\r\nspin_lock_init(&xt_connlimit_locks[i]);\r\nconnlimit_conn_cachep = kmem_cache_create("xt_connlimit_conn",\r\nsizeof(struct xt_connlimit_conn),\r\n0, 0, NULL);\r\nif (!connlimit_conn_cachep)\r\nreturn -ENOMEM;\r\nconnlimit_rb_cachep = kmem_cache_create("xt_connlimit_rb",\r\nsizeof(struct xt_connlimit_rb),\r\n0, 0, NULL);\r\nif (!connlimit_rb_cachep) {\r\nkmem_cache_destroy(connlimit_conn_cachep);\r\nreturn -ENOMEM;\r\n}\r\nret = xt_register_match(&connlimit_mt_reg);\r\nif (ret != 0) {\r\nkmem_cache_destroy(connlimit_conn_cachep);\r\nkmem_cache_destroy(connlimit_rb_cachep);\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit connlimit_mt_exit(void)\r\n{\r\nxt_unregister_match(&connlimit_mt_reg);\r\nkmem_cache_destroy(connlimit_conn_cachep);\r\nkmem_cache_destroy(connlimit_rb_cachep);\r\n}
