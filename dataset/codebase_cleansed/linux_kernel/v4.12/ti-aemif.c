static int aemif_calc_rate(struct platform_device *pdev, int wanted,\r\nunsigned long clk, int max)\r\n{\r\nint result;\r\nresult = DIV_ROUND_UP((wanted * clk), NSEC_PER_MSEC) - 1;\r\ndev_dbg(&pdev->dev, "%s: result %d from %ld, %d\n", __func__, result,\r\nclk, wanted);\r\nif (result < 0)\r\nresult = 0;\r\nelse if (result > max)\r\nresult = -EINVAL;\r\nreturn result;\r\n}\r\nstatic int aemif_config_abus(struct platform_device *pdev, int csnum)\r\n{\r\nstruct aemif_device *aemif = platform_get_drvdata(pdev);\r\nstruct aemif_cs_data *data = &aemif->cs_data[csnum];\r\nint ta, rhold, rstrobe, rsetup, whold, wstrobe, wsetup;\r\nunsigned long clk_rate = aemif->clk_rate;\r\nunsigned offset;\r\nu32 set, val;\r\noffset = A1CR_OFFSET + (data->cs - aemif->cs_offset) * 4;\r\nta = aemif_calc_rate(pdev, data->ta, clk_rate, TA_MAX);\r\nrhold = aemif_calc_rate(pdev, data->rhold, clk_rate, RHOLD_MAX);\r\nrstrobe = aemif_calc_rate(pdev, data->rstrobe, clk_rate, RSTROBE_MAX);\r\nrsetup = aemif_calc_rate(pdev, data->rsetup, clk_rate, RSETUP_MAX);\r\nwhold = aemif_calc_rate(pdev, data->whold, clk_rate, WHOLD_MAX);\r\nwstrobe = aemif_calc_rate(pdev, data->wstrobe, clk_rate, WSTROBE_MAX);\r\nwsetup = aemif_calc_rate(pdev, data->wsetup, clk_rate, WSETUP_MAX);\r\nif (ta < 0 || rhold < 0 || rstrobe < 0 || rsetup < 0 ||\r\nwhold < 0 || wstrobe < 0 || wsetup < 0) {\r\ndev_err(&pdev->dev, "%s: cannot get suitable timings\n",\r\n__func__);\r\nreturn -EINVAL;\r\n}\r\nset = TA(ta) | RHOLD(rhold) | RSTROBE(rstrobe) | RSETUP(rsetup) |\r\nWHOLD(whold) | WSTROBE(wstrobe) | WSETUP(wsetup);\r\nset |= (data->asize & ACR_ASIZE_MASK);\r\nif (data->enable_ew)\r\nset |= ACR_EW_MASK;\r\nif (data->enable_ss)\r\nset |= ACR_SS_MASK;\r\nval = readl(aemif->base + offset);\r\nval &= ~CONFIG_MASK;\r\nval |= set;\r\nwritel(val, aemif->base + offset);\r\nreturn 0;\r\n}\r\nstatic inline int aemif_cycles_to_nsec(int val, unsigned long clk_rate)\r\n{\r\nreturn ((val + 1) * NSEC_PER_MSEC) / clk_rate;\r\n}\r\nstatic void aemif_get_hw_params(struct platform_device *pdev, int csnum)\r\n{\r\nstruct aemif_device *aemif = platform_get_drvdata(pdev);\r\nstruct aemif_cs_data *data = &aemif->cs_data[csnum];\r\nunsigned long clk_rate = aemif->clk_rate;\r\nu32 val, offset;\r\noffset = A1CR_OFFSET + (data->cs - aemif->cs_offset) * 4;\r\nval = readl(aemif->base + offset);\r\ndata->ta = aemif_cycles_to_nsec(TA_VAL(val), clk_rate);\r\ndata->rhold = aemif_cycles_to_nsec(RHOLD_VAL(val), clk_rate);\r\ndata->rstrobe = aemif_cycles_to_nsec(RSTROBE_VAL(val), clk_rate);\r\ndata->rsetup = aemif_cycles_to_nsec(RSETUP_VAL(val), clk_rate);\r\ndata->whold = aemif_cycles_to_nsec(WHOLD_VAL(val), clk_rate);\r\ndata->wstrobe = aemif_cycles_to_nsec(WSTROBE_VAL(val), clk_rate);\r\ndata->wsetup = aemif_cycles_to_nsec(WSETUP_VAL(val), clk_rate);\r\ndata->enable_ew = EW_VAL(val);\r\ndata->enable_ss = SS_VAL(val);\r\ndata->asize = val & ASIZE_MAX;\r\n}\r\nstatic int of_aemif_parse_abus_config(struct platform_device *pdev,\r\nstruct device_node *np)\r\n{\r\nstruct aemif_device *aemif = platform_get_drvdata(pdev);\r\nstruct aemif_cs_data *data;\r\nu32 cs;\r\nu32 val;\r\nif (of_property_read_u32(np, "ti,cs-chipselect", &cs)) {\r\ndev_dbg(&pdev->dev, "cs property is required");\r\nreturn -EINVAL;\r\n}\r\nif (cs - aemif->cs_offset >= NUM_CS || cs < aemif->cs_offset) {\r\ndev_dbg(&pdev->dev, "cs number is incorrect %d", cs);\r\nreturn -EINVAL;\r\n}\r\nif (aemif->num_cs >= NUM_CS) {\r\ndev_dbg(&pdev->dev, "cs count is more than %d", NUM_CS);\r\nreturn -EINVAL;\r\n}\r\ndata = &aemif->cs_data[aemif->num_cs];\r\ndata->cs = cs;\r\naemif_get_hw_params(pdev, aemif->num_cs++);\r\nif (!of_property_read_u32(np, "ti,cs-min-turnaround-ns", &val))\r\ndata->ta = val;\r\nif (!of_property_read_u32(np, "ti,cs-read-hold-ns", &val))\r\ndata->rhold = val;\r\nif (!of_property_read_u32(np, "ti,cs-read-strobe-ns", &val))\r\ndata->rstrobe = val;\r\nif (!of_property_read_u32(np, "ti,cs-read-setup-ns", &val))\r\ndata->rsetup = val;\r\nif (!of_property_read_u32(np, "ti,cs-write-hold-ns", &val))\r\ndata->whold = val;\r\nif (!of_property_read_u32(np, "ti,cs-write-strobe-ns", &val))\r\ndata->wstrobe = val;\r\nif (!of_property_read_u32(np, "ti,cs-write-setup-ns", &val))\r\ndata->wsetup = val;\r\nif (!of_property_read_u32(np, "ti,cs-bus-width", &val))\r\nif (val == 16)\r\ndata->asize = 1;\r\ndata->enable_ew = of_property_read_bool(np, "ti,cs-extended-wait-mode");\r\ndata->enable_ss = of_property_read_bool(np, "ti,cs-select-strobe-mode");\r\nreturn 0;\r\n}\r\nstatic int aemif_probe(struct platform_device *pdev)\r\n{\r\nint i;\r\nint ret = -ENODEV;\r\nstruct resource *res;\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *np = dev->of_node;\r\nstruct device_node *child_np;\r\nstruct aemif_device *aemif;\r\nstruct aemif_platform_data *pdata;\r\nstruct of_dev_auxdata *dev_lookup;\r\nif (np == NULL)\r\nreturn 0;\r\naemif = devm_kzalloc(dev, sizeof(*aemif), GFP_KERNEL);\r\nif (!aemif)\r\nreturn -ENOMEM;\r\npdata = dev_get_platdata(&pdev->dev);\r\ndev_lookup = pdata ? pdata->dev_lookup : NULL;\r\nplatform_set_drvdata(pdev, aemif);\r\naemif->clk = devm_clk_get(dev, NULL);\r\nif (IS_ERR(aemif->clk)) {\r\ndev_err(dev, "cannot get clock 'aemif'\n");\r\nreturn PTR_ERR(aemif->clk);\r\n}\r\nclk_prepare_enable(aemif->clk);\r\naemif->clk_rate = clk_get_rate(aemif->clk) / MSEC_PER_SEC;\r\nif (of_device_is_compatible(np, "ti,da850-aemif"))\r\naemif->cs_offset = 2;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\naemif->base = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(aemif->base)) {\r\nret = PTR_ERR(aemif->base);\r\ngoto error;\r\n}\r\nfor_each_available_child_of_node(np, child_np) {\r\nret = of_aemif_parse_abus_config(pdev, child_np);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nfor (i = 0; i < aemif->num_cs; i++) {\r\nret = aemif_config_abus(pdev, i);\r\nif (ret < 0) {\r\ndev_err(dev, "Error configuring chip select %d\n",\r\naemif->cs_data[i].cs);\r\ngoto error;\r\n}\r\n}\r\nfor_each_available_child_of_node(np, child_np) {\r\nret = of_platform_populate(child_np, NULL, dev_lookup, dev);\r\nif (ret < 0)\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nclk_disable_unprepare(aemif->clk);\r\nreturn ret;\r\n}\r\nstatic int aemif_remove(struct platform_device *pdev)\r\n{\r\nstruct aemif_device *aemif = platform_get_drvdata(pdev);\r\nclk_disable_unprepare(aemif->clk);\r\nreturn 0;\r\n}
