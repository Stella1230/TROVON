static u32 socfpga_fpga_readl(struct socfpga_fpga_priv *priv, u32 reg_offset)\r\n{\r\nreturn readl(priv->fpga_base_addr + reg_offset);\r\n}\r\nstatic void socfpga_fpga_writel(struct socfpga_fpga_priv *priv, u32 reg_offset,\r\nu32 value)\r\n{\r\nwritel(value, priv->fpga_base_addr + reg_offset);\r\n}\r\nstatic u32 socfpga_fpga_raw_readl(struct socfpga_fpga_priv *priv,\r\nu32 reg_offset)\r\n{\r\nreturn __raw_readl(priv->fpga_base_addr + reg_offset);\r\n}\r\nstatic void socfpga_fpga_raw_writel(struct socfpga_fpga_priv *priv,\r\nu32 reg_offset, u32 value)\r\n{\r\n__raw_writel(value, priv->fpga_base_addr + reg_offset);\r\n}\r\nstatic void socfpga_fpga_data_writel(struct socfpga_fpga_priv *priv, u32 value)\r\n{\r\nwritel(value, priv->fpga_data_addr);\r\n}\r\nstatic inline void socfpga_fpga_set_bitsl(struct socfpga_fpga_priv *priv,\r\nu32 offset, u32 bits)\r\n{\r\nu32 val;\r\nval = socfpga_fpga_readl(priv, offset);\r\nval |= bits;\r\nsocfpga_fpga_writel(priv, offset, val);\r\n}\r\nstatic inline void socfpga_fpga_clr_bitsl(struct socfpga_fpga_priv *priv,\r\nu32 offset, u32 bits)\r\n{\r\nu32 val;\r\nval = socfpga_fpga_readl(priv, offset);\r\nval &= ~bits;\r\nsocfpga_fpga_writel(priv, offset, val);\r\n}\r\nstatic u32 socfpga_fpga_mon_status_get(struct socfpga_fpga_priv *priv)\r\n{\r\nreturn socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_GPIO_EXT_PORTA_OFST) &\r\nSOCFPGA_FPGMGR_MON_STATUS_MASK;\r\n}\r\nstatic u32 socfpga_fpga_state_get(struct socfpga_fpga_priv *priv)\r\n{\r\nu32 status = socfpga_fpga_mon_status_get(priv);\r\nif ((status & SOCFPGA_FPGMGR_MON_FPGA_POWER_ON) == 0)\r\nreturn SOCFPGA_FPGMGR_STAT_POWER_OFF;\r\nreturn socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_STAT_OFST) &\r\nSOCFPGA_FPGMGR_STAT_STATE_MASK;\r\n}\r\nstatic void socfpga_fpga_clear_done_status(struct socfpga_fpga_priv *priv)\r\n{\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_DCLKSTAT_OFST,\r\nSOCFPGA_FPGMGR_DCLKSTAT_DCNTDONE_E_DONE);\r\n}\r\nstatic int socfpga_fpga_dclk_set_and_wait_clear(struct socfpga_fpga_priv *priv,\r\nu32 count)\r\n{\r\nint timeout = 2;\r\nu32 done;\r\nif (socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_DCLKSTAT_OFST))\r\nsocfpga_fpga_clear_done_status(priv);\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_DCLKCNT_OFST, count);\r\ndo {\r\ndone = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_DCLKSTAT_OFST);\r\nif (done == SOCFPGA_FPGMGR_DCLKSTAT_DCNTDONE_E_DONE) {\r\nsocfpga_fpga_clear_done_status(priv);\r\nreturn 0;\r\n}\r\nudelay(1);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic int socfpga_fpga_wait_for_state(struct socfpga_fpga_priv *priv,\r\nu32 state)\r\n{\r\nint timeout = 2;\r\ndo {\r\nif ((socfpga_fpga_state_get(priv) & state) != 0)\r\nreturn 0;\r\nmsleep(20);\r\n} while (timeout--);\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void socfpga_fpga_enable_irqs(struct socfpga_fpga_priv *priv, u32 irqs)\r\n{\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTTYPE_LEVEL_OFST, 0);\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INT_POL_OFST, irqs);\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST, irqs);\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTMSK_OFST, 0);\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTEN_OFST, irqs);\r\n}\r\nstatic void socfpga_fpga_disable_irqs(struct socfpga_fpga_priv *priv)\r\n{\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_INTEN_OFST, 0);\r\n}\r\nstatic irqreturn_t socfpga_fpga_isr(int irq, void *dev_id)\r\n{\r\nstruct socfpga_fpga_priv *priv = dev_id;\r\nu32 irqs, st;\r\nbool conf_done, nstatus;\r\nirqs = socfpga_fpga_raw_readl(priv, SOCFPGA_FPGMGR_GPIO_INTSTAT_OFST);\r\nsocfpga_fpga_raw_writel(priv, SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST, irqs);\r\nst = socfpga_fpga_raw_readl(priv, SOCFPGA_FPGMGR_GPIO_EXT_PORTA_OFST);\r\nconf_done = (st & SOCFPGA_FPGMGR_MON_CONF_DONE) != 0;\r\nnstatus = (st & SOCFPGA_FPGMGR_MON_NSTATUS) != 0;\r\nif (conf_done && nstatus) {\r\nsocfpga_fpga_raw_writel(priv,\r\nSOCFPGA_FPGMGR_GPIO_INTEN_OFST, 0);\r\ncomplete(&priv->status_complete);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int socfpga_fpga_wait_for_config_done(struct socfpga_fpga_priv *priv)\r\n{\r\nint timeout, ret = 0;\r\nsocfpga_fpga_disable_irqs(priv);\r\ninit_completion(&priv->status_complete);\r\nsocfpga_fpga_enable_irqs(priv, SOCFPGA_FPGMGR_MON_CONF_DONE);\r\ntimeout = wait_for_completion_interruptible_timeout(\r\n&priv->status_complete,\r\nmsecs_to_jiffies(10));\r\nif (timeout == 0)\r\nret = -ETIMEDOUT;\r\nsocfpga_fpga_disable_irqs(priv);\r\nreturn ret;\r\n}\r\nstatic int socfpga_fpga_cfg_mode_get(struct socfpga_fpga_priv *priv)\r\n{\r\nu32 msel;\r\nmsel = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_STAT_OFST);\r\nmsel &= SOCFPGA_FPGMGR_STAT_MSEL_MASK;\r\nmsel >>= SOCFPGA_FPGMGR_STAT_MSEL_SHIFT;\r\nif ((msel >= ARRAY_SIZE(cfgmgr_modes)) || !cfgmgr_modes[msel].valid)\r\nreturn -EINVAL;\r\nreturn msel;\r\n}\r\nstatic int socfpga_fpga_cfg_mode_set(struct socfpga_fpga_priv *priv)\r\n{\r\nu32 ctrl_reg;\r\nint mode;\r\nmode = socfpga_fpga_cfg_mode_get(priv);\r\nif (mode < 0)\r\nreturn mode;\r\nctrl_reg = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_CTL_OFST);\r\nctrl_reg &= ~SOCFPGA_FPGMGR_CTL_CDRATIO_MASK;\r\nctrl_reg &= ~SOCFPGA_FPGMGR_CTL_CFGWDTH_MASK;\r\nctrl_reg |= cfgmgr_modes[mode].ctrl;\r\nctrl_reg &= ~SOCFPGA_FPGMGR_CTL_NCE;\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_CTL_OFST, ctrl_reg);\r\nreturn 0;\r\n}\r\nstatic int socfpga_fpga_reset(struct fpga_manager *mgr)\r\n{\r\nstruct socfpga_fpga_priv *priv = mgr->priv;\r\nu32 ctrl_reg, status;\r\nint ret;\r\nret = socfpga_fpga_cfg_mode_set(priv);\r\nif (ret)\r\nreturn ret;\r\nsocfpga_fpga_set_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\r\nSOCFPGA_FPGMGR_CTL_EN);\r\nctrl_reg = socfpga_fpga_readl(priv, SOCFPGA_FPGMGR_CTL_OFST);\r\nctrl_reg |= SOCFPGA_FPGMGR_CTL_NCFGPULL;\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_CTL_OFST, ctrl_reg);\r\nstatus = socfpga_fpga_wait_for_state(priv, SOCFPGA_FPGMGR_STAT_RESET);\r\nctrl_reg &= ~SOCFPGA_FPGMGR_CTL_NCFGPULL;\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_CTL_OFST, ctrl_reg);\r\nif (status)\r\nreturn -ETIMEDOUT;\r\nreturn 0;\r\n}\r\nstatic int socfpga_fpga_ops_configure_init(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info,\r\nconst char *buf, size_t count)\r\n{\r\nstruct socfpga_fpga_priv *priv = mgr->priv;\r\nint ret;\r\nif (info->flags & FPGA_MGR_PARTIAL_RECONFIG) {\r\ndev_err(&mgr->dev, "Partial reconfiguration not supported.\n");\r\nreturn -EINVAL;\r\n}\r\nret = socfpga_fpga_reset(mgr);\r\nif (ret)\r\nreturn ret;\r\nif (socfpga_fpga_wait_for_state(priv, SOCFPGA_FPGMGR_STAT_CFG))\r\nreturn -ETIMEDOUT;\r\nsocfpga_fpga_writel(priv, SOCFPGA_FPGMGR_GPIO_PORTA_EOI_OFST,\r\nSOCFPGA_FPGMGR_MON_NSTATUS);\r\nsocfpga_fpga_set_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\r\nSOCFPGA_FPGMGR_CTL_AXICFGEN);\r\nreturn 0;\r\n}\r\nstatic int socfpga_fpga_ops_configure_write(struct fpga_manager *mgr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct socfpga_fpga_priv *priv = mgr->priv;\r\nu32 *buffer_32 = (u32 *)buf;\r\nsize_t i = 0;\r\nif (count <= 0)\r\nreturn -EINVAL;\r\nwhile (count >= sizeof(u32)) {\r\nsocfpga_fpga_data_writel(priv, buffer_32[i++]);\r\ncount -= sizeof(u32);\r\n}\r\nswitch (count) {\r\ncase 3:\r\nsocfpga_fpga_data_writel(priv, buffer_32[i++] & 0x00ffffff);\r\nbreak;\r\ncase 2:\r\nsocfpga_fpga_data_writel(priv, buffer_32[i++] & 0x0000ffff);\r\nbreak;\r\ncase 1:\r\nsocfpga_fpga_data_writel(priv, buffer_32[i++] & 0x000000ff);\r\nbreak;\r\ncase 0:\r\nbreak;\r\ndefault:\r\nreturn -EFAULT;\r\n}\r\nreturn 0;\r\n}\r\nstatic int socfpga_fpga_ops_configure_complete(struct fpga_manager *mgr,\r\nstruct fpga_image_info *info)\r\n{\r\nstruct socfpga_fpga_priv *priv = mgr->priv;\r\nu32 status;\r\nstatus = socfpga_fpga_wait_for_config_done(priv);\r\nif (status)\r\nreturn status;\r\nsocfpga_fpga_clr_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\r\nSOCFPGA_FPGMGR_CTL_AXICFGEN);\r\nif (socfpga_fpga_dclk_set_and_wait_clear(priv, 4))\r\nreturn -ETIMEDOUT;\r\nif (socfpga_fpga_wait_for_state(priv, SOCFPGA_FPGMGR_STAT_USER_MODE))\r\nreturn -ETIMEDOUT;\r\nsocfpga_fpga_clr_bitsl(priv, SOCFPGA_FPGMGR_CTL_OFST,\r\nSOCFPGA_FPGMGR_CTL_EN);\r\nreturn 0;\r\n}\r\nstatic enum fpga_mgr_states socfpga_fpga_ops_state(struct fpga_manager *mgr)\r\n{\r\nstruct socfpga_fpga_priv *priv = mgr->priv;\r\nenum fpga_mgr_states ret;\r\nu32 state;\r\nstate = socfpga_fpga_state_get(priv);\r\nif (state < ARRAY_SIZE(socfpga_state_to_framework_state))\r\nret = socfpga_state_to_framework_state[state];\r\nelse\r\nret = FPGA_MGR_STATE_UNKNOWN;\r\nreturn ret;\r\n}\r\nstatic int socfpga_fpga_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct socfpga_fpga_priv *priv;\r\nstruct resource *res;\r\nint ret;\r\npriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\r\nif (!priv)\r\nreturn -ENOMEM;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npriv->fpga_base_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->fpga_base_addr))\r\nreturn PTR_ERR(priv->fpga_base_addr);\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\npriv->fpga_data_addr = devm_ioremap_resource(dev, res);\r\nif (IS_ERR(priv->fpga_data_addr))\r\nreturn PTR_ERR(priv->fpga_data_addr);\r\npriv->irq = platform_get_irq(pdev, 0);\r\nif (priv->irq < 0)\r\nreturn priv->irq;\r\nret = devm_request_irq(dev, priv->irq, socfpga_fpga_isr, 0,\r\ndev_name(dev), priv);\r\nif (ret)\r\nreturn ret;\r\nreturn fpga_mgr_register(dev, "Altera SOCFPGA FPGA Manager",\r\n&socfpga_fpga_ops, priv);\r\n}\r\nstatic int socfpga_fpga_remove(struct platform_device *pdev)\r\n{\r\nfpga_mgr_unregister(&pdev->dev);\r\nreturn 0;\r\n}
