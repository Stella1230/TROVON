static inline void pic32_spi_enable(struct pic32_spi *pic32s)\r\n{\r\nwritel(CTRL_ON | CTRL_SIDL, &pic32s->regs->ctrl_set);\r\n}\r\nstatic inline void pic32_spi_disable(struct pic32_spi *pic32s)\r\n{\r\nwritel(CTRL_ON | CTRL_SIDL, &pic32s->regs->ctrl_clr);\r\nndelay(20);\r\n}\r\nstatic void pic32_spi_set_clk_rate(struct pic32_spi *pic32s, u32 spi_ck)\r\n{\r\nu32 div;\r\ndiv = DIV_ROUND_CLOSEST(clk_get_rate(pic32s->clk), 2 * spi_ck) - 1;\r\nwritel(div & BAUD_MASK, &pic32s->regs->baud);\r\n}\r\nstatic inline u32 pic32_rx_fifo_level(struct pic32_spi *pic32s)\r\n{\r\nu32 sr = readl(&pic32s->regs->status);\r\nreturn (sr >> STAT_RF_LVL_SHIFT) & STAT_RF_LVL_MASK;\r\n}\r\nstatic inline u32 pic32_tx_fifo_level(struct pic32_spi *pic32s)\r\n{\r\nu32 sr = readl(&pic32s->regs->status);\r\nreturn (sr >> STAT_TF_LVL_SHIFT) & STAT_TF_LVL_MASK;\r\n}\r\nstatic u32 pic32_tx_max(struct pic32_spi *pic32s, int n_bytes)\r\n{\r\nu32 tx_left, tx_room, rxtx_gap;\r\ntx_left = (pic32s->tx_end - pic32s->tx) / n_bytes;\r\ntx_room = pic32s->fifo_n_elm - pic32_tx_fifo_level(pic32s);\r\nrxtx_gap = ((pic32s->rx_end - pic32s->rx) -\r\n(pic32s->tx_end - pic32s->tx)) / n_bytes;\r\nreturn min3(tx_left, tx_room, (u32)(pic32s->fifo_n_elm - rxtx_gap));\r\n}\r\nstatic u32 pic32_rx_max(struct pic32_spi *pic32s, int n_bytes)\r\n{\r\nu32 rx_left = (pic32s->rx_end - pic32s->rx) / n_bytes;\r\nreturn min_t(u32, rx_left, pic32_rx_fifo_level(pic32s));\r\n}\r\nstatic void pic32_err_stop(struct pic32_spi *pic32s, const char *msg)\r\n{\r\ndisable_irq_nosync(pic32s->fault_irq);\r\ndisable_irq_nosync(pic32s->rx_irq);\r\ndisable_irq_nosync(pic32s->tx_irq);\r\ndev_err(&pic32s->master->dev, "%s\n", msg);\r\nif (pic32s->master->cur_msg)\r\npic32s->master->cur_msg->status = -EIO;\r\ncomplete(&pic32s->xfer_done);\r\n}\r\nstatic irqreturn_t pic32_spi_fault_irq(int irq, void *dev_id)\r\n{\r\nstruct pic32_spi *pic32s = dev_id;\r\nu32 status;\r\nstatus = readl(&pic32s->regs->status);\r\nif (status & (STAT_RX_OV | STAT_TX_UR)) {\r\nwritel(STAT_RX_OV, &pic32s->regs->status_clr);\r\nwritel(STAT_TX_UR, &pic32s->regs->status_clr);\r\npic32_err_stop(pic32s, "err_irq: fifo ov/ur-run\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (status & STAT_FRM_ERR) {\r\npic32_err_stop(pic32s, "err_irq: frame error");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (!pic32s->master->cur_msg) {\r\npic32_err_stop(pic32s, "err_irq: no mesg");\r\nreturn IRQ_NONE;\r\n}\r\nreturn IRQ_NONE;\r\n}\r\nstatic irqreturn_t pic32_spi_rx_irq(int irq, void *dev_id)\r\n{\r\nstruct pic32_spi *pic32s = dev_id;\r\npic32s->rx_fifo(pic32s);\r\nif (pic32s->rx_end == pic32s->rx) {\r\ndisable_irq_nosync(pic32s->fault_irq);\r\ndisable_irq_nosync(pic32s->rx_irq);\r\ncomplete(&pic32s->xfer_done);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t pic32_spi_tx_irq(int irq, void *dev_id)\r\n{\r\nstruct pic32_spi *pic32s = dev_id;\r\npic32s->tx_fifo(pic32s);\r\nif (pic32s->tx_end == pic32s->tx)\r\ndisable_irq_nosync(pic32s->tx_irq);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void pic32_spi_dma_rx_notify(void *data)\r\n{\r\nstruct pic32_spi *pic32s = data;\r\ncomplete(&pic32s->xfer_done);\r\n}\r\nstatic int pic32_spi_dma_transfer(struct pic32_spi *pic32s,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct spi_master *master = pic32s->master;\r\nstruct dma_async_tx_descriptor *desc_rx;\r\nstruct dma_async_tx_descriptor *desc_tx;\r\ndma_cookie_t cookie;\r\nint ret;\r\nif (!master->dma_rx || !master->dma_tx)\r\nreturn -ENODEV;\r\ndesc_rx = dmaengine_prep_slave_sg(master->dma_rx,\r\nxfer->rx_sg.sgl,\r\nxfer->rx_sg.nents,\r\nDMA_FROM_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_rx) {\r\nret = -EINVAL;\r\ngoto err_dma;\r\n}\r\ndesc_tx = dmaengine_prep_slave_sg(master->dma_tx,\r\nxfer->tx_sg.sgl,\r\nxfer->tx_sg.nents,\r\nDMA_TO_DEVICE,\r\nDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\r\nif (!desc_tx) {\r\nret = -EINVAL;\r\ngoto err_dma;\r\n}\r\ndesc_rx->callback = pic32_spi_dma_rx_notify;\r\ndesc_rx->callback_param = pic32s;\r\ncookie = dmaengine_submit(desc_rx);\r\nret = dma_submit_error(cookie);\r\nif (ret)\r\ngoto err_dma;\r\ncookie = dmaengine_submit(desc_tx);\r\nret = dma_submit_error(cookie);\r\nif (ret)\r\ngoto err_dma_tx;\r\ndma_async_issue_pending(master->dma_rx);\r\ndma_async_issue_pending(master->dma_tx);\r\nreturn 0;\r\nerr_dma_tx:\r\ndmaengine_terminate_all(master->dma_rx);\r\nerr_dma:\r\nreturn ret;\r\n}\r\nstatic int pic32_spi_dma_config(struct pic32_spi *pic32s, u32 dma_width)\r\n{\r\nint buf_offset = offsetof(struct pic32_spi_regs, buf);\r\nstruct spi_master *master = pic32s->master;\r\nstruct dma_slave_config cfg;\r\nint ret;\r\ncfg.device_fc = true;\r\ncfg.src_addr = pic32s->dma_base + buf_offset;\r\ncfg.dst_addr = pic32s->dma_base + buf_offset;\r\ncfg.src_maxburst = pic32s->fifo_n_elm / 2;\r\ncfg.dst_maxburst = pic32s->fifo_n_elm / 2;\r\ncfg.src_addr_width = dma_width;\r\ncfg.dst_addr_width = dma_width;\r\ncfg.slave_id = pic32s->tx_irq;\r\ncfg.direction = DMA_MEM_TO_DEV;\r\nret = dmaengine_slave_config(master->dma_tx, &cfg);\r\nif (ret) {\r\ndev_err(&master->dev, "tx channel setup failed\n");\r\nreturn ret;\r\n}\r\ncfg.slave_id = pic32s->rx_irq;\r\ncfg.direction = DMA_DEV_TO_MEM;\r\nret = dmaengine_slave_config(master->dma_rx, &cfg);\r\nif (ret)\r\ndev_err(&master->dev, "rx channel setup failed\n");\r\nreturn ret;\r\n}\r\nstatic int pic32_spi_set_word_size(struct pic32_spi *pic32s, u8 bits_per_word)\r\n{\r\nenum dma_slave_buswidth dmawidth;\r\nu32 buswidth, v;\r\nswitch (bits_per_word) {\r\ncase 8:\r\npic32s->rx_fifo = pic32_spi_rx_byte;\r\npic32s->tx_fifo = pic32_spi_tx_byte;\r\nbuswidth = PIC32_BPW_8;\r\ndmawidth = DMA_SLAVE_BUSWIDTH_1_BYTE;\r\nbreak;\r\ncase 16:\r\npic32s->rx_fifo = pic32_spi_rx_word;\r\npic32s->tx_fifo = pic32_spi_tx_word;\r\nbuswidth = PIC32_BPW_16;\r\ndmawidth = DMA_SLAVE_BUSWIDTH_2_BYTES;\r\nbreak;\r\ncase 32:\r\npic32s->rx_fifo = pic32_spi_rx_dword;\r\npic32s->tx_fifo = pic32_spi_tx_dword;\r\nbuswidth = PIC32_BPW_32;\r\ndmawidth = DMA_SLAVE_BUSWIDTH_4_BYTES;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\npic32s->fifo_n_elm = DIV_ROUND_UP(pic32s->fifo_n_byte,\r\nbits_per_word / 8);\r\nv = readl(&pic32s->regs->ctrl);\r\nv &= ~(CTRL_BPW_MASK << CTRL_BPW_SHIFT);\r\nv |= buswidth << CTRL_BPW_SHIFT;\r\nwritel(v, &pic32s->regs->ctrl);\r\nif (test_bit(PIC32F_DMA_PREP, &pic32s->flags))\r\npic32_spi_dma_config(pic32s, dmawidth);\r\nreturn 0;\r\n}\r\nstatic int pic32_spi_prepare_hardware(struct spi_master *master)\r\n{\r\nstruct pic32_spi *pic32s = spi_master_get_devdata(master);\r\npic32_spi_enable(pic32s);\r\nreturn 0;\r\n}\r\nstatic int pic32_spi_prepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct pic32_spi *pic32s = spi_master_get_devdata(master);\r\nstruct spi_device *spi = msg->spi;\r\nu32 val;\r\nif (pic32s->bits_per_word != spi->bits_per_word) {\r\npic32_spi_set_word_size(pic32s, spi->bits_per_word);\r\npic32s->bits_per_word = spi->bits_per_word;\r\n}\r\nif (pic32s->speed_hz != spi->max_speed_hz) {\r\npic32_spi_set_clk_rate(pic32s, spi->max_speed_hz);\r\npic32s->speed_hz = spi->max_speed_hz;\r\n}\r\nif (pic32s->mode != spi->mode) {\r\nval = readl(&pic32s->regs->ctrl);\r\nif (spi->mode & SPI_CPOL)\r\nval |= CTRL_CKP;\r\nelse\r\nval &= ~CTRL_CKP;\r\nif (spi->mode & SPI_CPHA)\r\nval &= ~CTRL_CKE;\r\nelse\r\nval |= CTRL_CKE;\r\nval |= CTRL_SMP;\r\nwritel(val, &pic32s->regs->ctrl);\r\npic32s->mode = spi->mode;\r\n}\r\nreturn 0;\r\n}\r\nstatic bool pic32_spi_can_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct pic32_spi *pic32s = spi_master_get_devdata(master);\r\nreturn (xfer->len >= PIC32_DMA_LEN_MIN) &&\r\ntest_bit(PIC32F_DMA_PREP, &pic32s->flags);\r\n}\r\nstatic int pic32_spi_one_transfer(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *transfer)\r\n{\r\nstruct pic32_spi *pic32s;\r\nbool dma_issued = false;\r\nunsigned long timeout;\r\nint ret;\r\npic32s = spi_master_get_devdata(master);\r\nif (transfer->bits_per_word &&\r\n(transfer->bits_per_word != pic32s->bits_per_word)) {\r\nret = pic32_spi_set_word_size(pic32s, transfer->bits_per_word);\r\nif (ret)\r\nreturn ret;\r\npic32s->bits_per_word = transfer->bits_per_word;\r\n}\r\nif (transfer->speed_hz && (transfer->speed_hz != pic32s->speed_hz)) {\r\npic32_spi_set_clk_rate(pic32s, transfer->speed_hz);\r\npic32s->speed_hz = transfer->speed_hz;\r\n}\r\nreinit_completion(&pic32s->xfer_done);\r\nif (transfer->rx_sg.nents && transfer->tx_sg.nents) {\r\nret = pic32_spi_dma_transfer(pic32s, transfer);\r\nif (ret) {\r\ndev_err(&spi->dev, "dma submit error\n");\r\nreturn ret;\r\n}\r\ndma_issued = true;\r\n} else {\r\npic32s->tx = (const void *)transfer->tx_buf;\r\npic32s->rx = (const void *)transfer->rx_buf;\r\npic32s->tx_end = pic32s->tx + transfer->len;\r\npic32s->rx_end = pic32s->rx + transfer->len;\r\npic32s->len = transfer->len;\r\nenable_irq(pic32s->fault_irq);\r\nenable_irq(pic32s->rx_irq);\r\nenable_irq(pic32s->tx_irq);\r\n}\r\ntimeout = wait_for_completion_timeout(&pic32s->xfer_done, 2 * HZ);\r\nif (timeout == 0) {\r\ndev_err(&spi->dev, "wait error/timedout\n");\r\nif (dma_issued) {\r\ndmaengine_terminate_all(master->dma_rx);\r\ndmaengine_terminate_all(master->dma_rx);\r\n}\r\nret = -ETIMEDOUT;\r\n} else {\r\nret = 0;\r\n}\r\nreturn ret;\r\n}\r\nstatic int pic32_spi_unprepare_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nreturn 0;\r\n}\r\nstatic int pic32_spi_unprepare_hardware(struct spi_master *master)\r\n{\r\nstruct pic32_spi *pic32s = spi_master_get_devdata(master);\r\npic32_spi_disable(pic32s);\r\nreturn 0;\r\n}\r\nstatic int pic32_spi_setup(struct spi_device *spi)\r\n{\r\nif (!spi->max_speed_hz) {\r\ndev_err(&spi->dev, "No max speed HZ parameter\n");\r\nreturn -EINVAL;\r\n}\r\nif (!gpio_is_valid(spi->cs_gpio))\r\nreturn -EINVAL;\r\ngpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));\r\nreturn 0;\r\n}\r\nstatic void pic32_spi_cleanup(struct spi_device *spi)\r\n{\r\ngpio_direction_output(spi->cs_gpio, !(spi->mode & SPI_CS_HIGH));\r\n}\r\nstatic void pic32_spi_dma_prep(struct pic32_spi *pic32s, struct device *dev)\r\n{\r\nstruct spi_master *master = pic32s->master;\r\ndma_cap_mask_t mask;\r\ndma_cap_zero(mask);\r\ndma_cap_set(DMA_SLAVE, mask);\r\nmaster->dma_rx = dma_request_slave_channel_compat(mask, NULL, NULL,\r\ndev, "spi-rx");\r\nif (!master->dma_rx) {\r\ndev_warn(dev, "RX channel not found.\n");\r\ngoto out_err;\r\n}\r\nmaster->dma_tx = dma_request_slave_channel_compat(mask, NULL, NULL,\r\ndev, "spi-tx");\r\nif (!master->dma_tx) {\r\ndev_warn(dev, "TX channel not found.\n");\r\ngoto out_err;\r\n}\r\nif (pic32_spi_dma_config(pic32s, DMA_SLAVE_BUSWIDTH_1_BYTE))\r\ngoto out_err;\r\nset_bit(PIC32F_DMA_PREP, &pic32s->flags);\r\nreturn;\r\nout_err:\r\nif (master->dma_rx)\r\ndma_release_channel(master->dma_rx);\r\nif (master->dma_tx)\r\ndma_release_channel(master->dma_tx);\r\n}\r\nstatic void pic32_spi_dma_unprep(struct pic32_spi *pic32s)\r\n{\r\nif (!test_bit(PIC32F_DMA_PREP, &pic32s->flags))\r\nreturn;\r\nclear_bit(PIC32F_DMA_PREP, &pic32s->flags);\r\nif (pic32s->master->dma_rx)\r\ndma_release_channel(pic32s->master->dma_rx);\r\nif (pic32s->master->dma_tx)\r\ndma_release_channel(pic32s->master->dma_tx);\r\n}\r\nstatic void pic32_spi_hw_init(struct pic32_spi *pic32s)\r\n{\r\nu32 ctrl;\r\npic32_spi_disable(pic32s);\r\nctrl = readl(&pic32s->regs->ctrl);\r\nctrl |= CTRL_ENHBUF;\r\npic32s->fifo_n_byte = 16;\r\nctrl &= ~CTRL_FRMEN;\r\nctrl |= CTRL_MSTEN;\r\nctrl &= ~(0x3 << CTRL_TX_INT_SHIFT);\r\nctrl |= (TX_FIFO_HALF_EMPTY << CTRL_TX_INT_SHIFT);\r\nctrl &= ~(0x3 << CTRL_RX_INT_SHIFT);\r\nctrl |= (RX_FIFO_NOT_EMPTY << CTRL_RX_INT_SHIFT);\r\nctrl &= ~CTRL_MCLKSEL;\r\nctrl &= ~CTRL_MSSEN;\r\nwritel(ctrl, &pic32s->regs->ctrl);\r\nctrl = CTRL2_TX_UR_EN | CTRL2_RX_OV_EN | CTRL2_FRM_ERR_EN;\r\nwritel(ctrl, &pic32s->regs->ctrl2_set);\r\n}\r\nstatic int pic32_spi_hw_probe(struct platform_device *pdev,\r\nstruct pic32_spi *pic32s)\r\n{\r\nstruct resource *mem;\r\nint ret;\r\nmem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\npic32s->regs = devm_ioremap_resource(&pdev->dev, mem);\r\nif (IS_ERR(pic32s->regs))\r\nreturn PTR_ERR(pic32s->regs);\r\npic32s->dma_base = mem->start;\r\npic32s->fault_irq = platform_get_irq_byname(pdev, "fault");\r\nif (pic32s->fault_irq < 0) {\r\ndev_err(&pdev->dev, "fault-irq not found\n");\r\nreturn pic32s->fault_irq;\r\n}\r\npic32s->rx_irq = platform_get_irq_byname(pdev, "rx");\r\nif (pic32s->rx_irq < 0) {\r\ndev_err(&pdev->dev, "rx-irq not found\n");\r\nreturn pic32s->rx_irq;\r\n}\r\npic32s->tx_irq = platform_get_irq_byname(pdev, "tx");\r\nif (pic32s->tx_irq < 0) {\r\ndev_err(&pdev->dev, "tx-irq not found\n");\r\nreturn pic32s->tx_irq;\r\n}\r\npic32s->clk = devm_clk_get(&pdev->dev, "mck0");\r\nif (IS_ERR(pic32s->clk)) {\r\ndev_err(&pdev->dev, "clk not found\n");\r\nret = PTR_ERR(pic32s->clk);\r\ngoto err_unmap_mem;\r\n}\r\nret = clk_prepare_enable(pic32s->clk);\r\nif (ret)\r\ngoto err_unmap_mem;\r\npic32_spi_hw_init(pic32s);\r\nreturn 0;\r\nerr_unmap_mem:\r\ndev_err(&pdev->dev, "%s failed, err %d\n", __func__, ret);\r\nreturn ret;\r\n}\r\nstatic int pic32_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct spi_master *master;\r\nstruct pic32_spi *pic32s;\r\nint ret;\r\nmaster = spi_alloc_master(&pdev->dev, sizeof(*pic32s));\r\nif (!master)\r\nreturn -ENOMEM;\r\npic32s = spi_master_get_devdata(master);\r\npic32s->master = master;\r\nret = pic32_spi_hw_probe(pdev, pic32s);\r\nif (ret)\r\ngoto err_master;\r\nmaster->dev.of_node = of_node_get(pdev->dev.of_node);\r\nmaster->mode_bits = SPI_MODE_3 | SPI_MODE_0 | SPI_CS_HIGH;\r\nmaster->num_chipselect = 1;\r\nmaster->max_speed_hz = clk_get_rate(pic32s->clk);\r\nmaster->setup = pic32_spi_setup;\r\nmaster->cleanup = pic32_spi_cleanup;\r\nmaster->flags = SPI_MASTER_MUST_TX | SPI_MASTER_MUST_RX;\r\nmaster->bits_per_word_mask = SPI_BPW_MASK(8) | SPI_BPW_MASK(16) |\r\nSPI_BPW_MASK(32);\r\nmaster->transfer_one = pic32_spi_one_transfer;\r\nmaster->prepare_message = pic32_spi_prepare_message;\r\nmaster->unprepare_message = pic32_spi_unprepare_message;\r\nmaster->prepare_transfer_hardware = pic32_spi_prepare_hardware;\r\nmaster->unprepare_transfer_hardware = pic32_spi_unprepare_hardware;\r\npic32_spi_dma_prep(pic32s, &pdev->dev);\r\nif (test_bit(PIC32F_DMA_PREP, &pic32s->flags))\r\nmaster->can_dma = pic32_spi_can_dma;\r\ninit_completion(&pic32s->xfer_done);\r\npic32s->mode = -1;\r\nirq_set_status_flags(pic32s->fault_irq, IRQ_NOAUTOEN);\r\nret = devm_request_irq(&pdev->dev, pic32s->fault_irq,\r\npic32_spi_fault_irq, IRQF_NO_THREAD,\r\ndev_name(&pdev->dev), pic32s);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request fault-irq %d\n", pic32s->rx_irq);\r\ngoto err_bailout;\r\n}\r\nirq_set_status_flags(pic32s->rx_irq, IRQ_NOAUTOEN);\r\nret = devm_request_irq(&pdev->dev, pic32s->rx_irq,\r\npic32_spi_rx_irq, IRQF_NO_THREAD,\r\ndev_name(&pdev->dev), pic32s);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request rx-irq %d\n", pic32s->rx_irq);\r\ngoto err_bailout;\r\n}\r\nirq_set_status_flags(pic32s->tx_irq, IRQ_NOAUTOEN);\r\nret = devm_request_irq(&pdev->dev, pic32s->tx_irq,\r\npic32_spi_tx_irq, IRQF_NO_THREAD,\r\ndev_name(&pdev->dev), pic32s);\r\nif (ret < 0) {\r\ndev_err(&pdev->dev, "request tx-irq %d\n", pic32s->tx_irq);\r\ngoto err_bailout;\r\n}\r\nret = devm_spi_register_master(&pdev->dev, master);\r\nif (ret) {\r\ndev_err(&master->dev, "failed registering spi master\n");\r\ngoto err_bailout;\r\n}\r\nplatform_set_drvdata(pdev, pic32s);\r\nreturn 0;\r\nerr_bailout:\r\nclk_disable_unprepare(pic32s->clk);\r\nerr_master:\r\nspi_master_put(master);\r\nreturn ret;\r\n}\r\nstatic int pic32_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct pic32_spi *pic32s;\r\npic32s = platform_get_drvdata(pdev);\r\npic32_spi_disable(pic32s);\r\nclk_disable_unprepare(pic32s->clk);\r\npic32_spi_dma_unprep(pic32s);\r\nreturn 0;\r\n}
