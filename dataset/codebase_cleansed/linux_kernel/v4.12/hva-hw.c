static irqreturn_t hva_hw_its_interrupt(int irq, void *data)\r\n{\r\nstruct hva_dev *hva = data;\r\nhva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);\r\nhva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);\r\nwritel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t hva_hw_its_irq_thread(int irq, void *arg)\r\n{\r\nstruct hva_dev *hva = arg;\r\nstruct device *dev = hva_to_dev(hva);\r\nu32 status = hva->sts_reg & 0xFF;\r\nu8 ctx_id = 0;\r\nstruct hva_ctx *ctx = NULL;\r\ndev_dbg(dev, "%s %s: status: 0x%02x fifo level: 0x%02x\n",\r\nHVA_PREFIX, __func__, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);\r\nctx_id = (hva->sts_reg & 0xFF00) >> 8;\r\nif (ctx_id >= HVA_MAX_INSTANCES) {\r\ndev_err(dev, "%s %s: bad context identifier: %d\n",\r\nctx->name, __func__, ctx_id);\r\nctx->hw_err = true;\r\ngoto out;\r\n}\r\nctx = hva->instances[ctx_id];\r\nif (!ctx)\r\ngoto out;\r\nswitch (status) {\r\ncase NO_ERROR:\r\ndev_dbg(dev, "%s %s: no error\n",\r\nctx->name, __func__);\r\nctx->hw_err = false;\r\nbreak;\r\ncase H264_SLICE_READY:\r\ndev_dbg(dev, "%s %s: h264 slice ready\n",\r\nctx->name, __func__);\r\nctx->hw_err = false;\r\nbreak;\r\ncase H264_FRAME_SKIPPED:\r\ndev_dbg(dev, "%s %s: h264 frame skipped\n",\r\nctx->name, __func__);\r\nctx->hw_err = false;\r\nbreak;\r\ncase H264_BITSTREAM_OVERSIZE:\r\ndev_err(dev, "%s %s:h264 bitstream oversize\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\ncase H264_SLICE_LIMIT_SIZE:\r\ndev_err(dev, "%s %s: h264 slice limit size is reached\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\ncase H264_MAX_SLICE_NUMBER:\r\ndev_err(dev, "%s %s: h264 max slice number is reached\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\ncase TASK_LIST_FULL:\r\ndev_err(dev, "%s %s:task list full\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\ncase UNKNOWN_COMMAND:\r\ndev_err(dev, "%s %s: command not known\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\ncase WRONG_CODEC_OR_RESOLUTION:\r\ndev_err(dev, "%s %s: wrong codec or resolution\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s %s: status not recognized\n",\r\nctx->name, __func__);\r\nctx->hw_err = true;\r\nbreak;\r\n}\r\nout:\r\ncomplete(&hva->interrupt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t hva_hw_err_interrupt(int irq, void *data)\r\n{\r\nstruct hva_dev *hva = data;\r\nhva->sts_reg = readl_relaxed(hva->regs + HVA_HIF_FIFO_STS);\r\nhva->sfl_reg = readl_relaxed(hva->regs + HVA_HIF_REG_SFL);\r\nhva->lmi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_LMI_ERR);\r\nhva->emi_err_reg = readl_relaxed(hva->regs + HVA_HIF_REG_EMI_ERR);\r\nhva->hec_mif_err_reg = readl_relaxed(hva->regs +\r\nHVA_HIF_REG_HEC_MIF_ERR);\r\nwritel_relaxed(0x1, hva->regs + HVA_HIF_REG_IT_ACK);\r\nreturn IRQ_WAKE_THREAD;\r\n}\r\nstatic irqreturn_t hva_hw_err_irq_thread(int irq, void *arg)\r\n{\r\nstruct hva_dev *hva = arg;\r\nstruct device *dev = hva_to_dev(hva);\r\nu8 ctx_id = 0;\r\nstruct hva_ctx *ctx;\r\ndev_dbg(dev, "%s status: 0x%02x fifo level: 0x%02x\n",\r\nHVA_PREFIX, hva->sts_reg & 0xFF, hva->sfl_reg & 0xF);\r\nctx_id = (hva->sts_reg & 0xFF00) >> 8;\r\nif (ctx_id >= HVA_MAX_INSTANCES) {\r\ndev_err(dev, "%s bad context identifier: %d\n", HVA_PREFIX,\r\nctx_id);\r\ngoto out;\r\n}\r\nctx = hva->instances[ctx_id];\r\nif (!ctx)\r\ngoto out;\r\nif (hva->lmi_err_reg) {\r\ndev_err(dev, "%s local memory interface error: 0x%08x\n",\r\nctx->name, hva->lmi_err_reg);\r\nctx->hw_err = true;\r\n}\r\nif (hva->emi_err_reg) {\r\ndev_err(dev, "%s external memory interface error: 0x%08x\n",\r\nctx->name, hva->emi_err_reg);\r\nctx->hw_err = true;\r\n}\r\nif (hva->hec_mif_err_reg) {\r\ndev_err(dev, "%s hec memory interface error: 0x%08x\n",\r\nctx->name, hva->hec_mif_err_reg);\r\nctx->hw_err = true;\r\n}\r\nout:\r\ncomplete(&hva->interrupt);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic unsigned long int hva_hw_get_ip_version(struct hva_dev *hva)\r\n{\r\nstruct device *dev = hva_to_dev(hva);\r\nunsigned long int version;\r\nif (pm_runtime_get_sync(dev) < 0) {\r\ndev_err(dev, "%s failed to get pm_runtime\n", HVA_PREFIX);\r\nmutex_unlock(&hva->protect_mutex);\r\nreturn -EFAULT;\r\n}\r\nversion = readl_relaxed(hva->regs + HVA_HIF_REG_VERSION) &\r\nVERSION_ID_MASK;\r\npm_runtime_put_autosuspend(dev);\r\nswitch (version) {\r\ncase HVA_VERSION_V400:\r\ndev_dbg(dev, "%s IP hardware version 0x%lx\n",\r\nHVA_PREFIX, version);\r\nbreak;\r\ndefault:\r\ndev_err(dev, "%s unknown IP hardware version 0x%lx\n",\r\nHVA_PREFIX, version);\r\nversion = HVA_VERSION_UNKNOWN;\r\nbreak;\r\n}\r\nreturn version;\r\n}\r\nint hva_hw_probe(struct platform_device *pdev, struct hva_dev *hva)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct resource *regs;\r\nstruct resource *esram;\r\nint ret;\r\nWARN_ON(!hva);\r\nregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nhva->regs = devm_ioremap_resource(dev, regs);\r\nif (IS_ERR(hva->regs)) {\r\ndev_err(dev, "%s failed to get regs\n", HVA_PREFIX);\r\nreturn PTR_ERR(hva->regs);\r\n}\r\nesram = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!esram) {\r\ndev_err(dev, "%s failed to get esram\n", HVA_PREFIX);\r\nreturn -ENODEV;\r\n}\r\nhva->esram_addr = esram->start;\r\nhva->esram_size = resource_size(esram);\r\ndev_info(dev, "%s esram reserved for address: 0x%x size:%d\n",\r\nHVA_PREFIX, hva->esram_addr, hva->esram_size);\r\nhva->clk = devm_clk_get(dev, "clk_hva");\r\nif (IS_ERR(hva->clk)) {\r\ndev_err(dev, "%s failed to get clock\n", HVA_PREFIX);\r\nreturn PTR_ERR(hva->clk);\r\n}\r\nret = clk_prepare(hva->clk);\r\nif (ret < 0) {\r\ndev_err(dev, "%s failed to prepare clock\n", HVA_PREFIX);\r\nhva->clk = ERR_PTR(-EINVAL);\r\nreturn ret;\r\n}\r\nret = platform_get_irq(pdev, 0);\r\nif (ret < 0) {\r\ndev_err(dev, "%s failed to get status IRQ\n", HVA_PREFIX);\r\ngoto err_clk;\r\n}\r\nhva->irq_its = ret;\r\nret = devm_request_threaded_irq(dev, hva->irq_its, hva_hw_its_interrupt,\r\nhva_hw_its_irq_thread,\r\nIRQF_ONESHOT,\r\n"hva_its_irq", hva);\r\nif (ret) {\r\ndev_err(dev, "%s failed to install status IRQ 0x%x\n",\r\nHVA_PREFIX, hva->irq_its);\r\ngoto err_clk;\r\n}\r\ndisable_irq(hva->irq_its);\r\nret = platform_get_irq(pdev, 1);\r\nif (ret < 0) {\r\ndev_err(dev, "%s failed to get error IRQ\n", HVA_PREFIX);\r\ngoto err_clk;\r\n}\r\nhva->irq_err = ret;\r\nret = devm_request_threaded_irq(dev, hva->irq_err, hva_hw_err_interrupt,\r\nhva_hw_err_irq_thread,\r\nIRQF_ONESHOT,\r\n"hva_err_irq", hva);\r\nif (ret) {\r\ndev_err(dev, "%s failed to install error IRQ 0x%x\n",\r\nHVA_PREFIX, hva->irq_err);\r\ngoto err_clk;\r\n}\r\ndisable_irq(hva->irq_err);\r\nmutex_init(&hva->protect_mutex);\r\ninit_completion(&hva->interrupt);\r\npm_runtime_set_autosuspend_delay(dev, AUTOSUSPEND_DELAY_MS);\r\npm_runtime_use_autosuspend(dev);\r\npm_runtime_set_suspended(dev);\r\npm_runtime_enable(dev);\r\nret = pm_runtime_get_sync(dev);\r\nif (ret < 0) {\r\ndev_err(dev, "%s failed to set PM\n", HVA_PREFIX);\r\ngoto err_clk;\r\n}\r\nhva->ip_version = hva_hw_get_ip_version(hva);\r\nif (hva->ip_version == HVA_VERSION_UNKNOWN) {\r\nret = -EINVAL;\r\ngoto err_pm;\r\n}\r\ndev_info(dev, "%s found hva device (version 0x%lx)\n", HVA_PREFIX,\r\nhva->ip_version);\r\nreturn 0;\r\nerr_pm:\r\npm_runtime_put(dev);\r\nerr_clk:\r\nif (hva->clk)\r\nclk_unprepare(hva->clk);\r\nreturn ret;\r\n}\r\nvoid hva_hw_remove(struct hva_dev *hva)\r\n{\r\nstruct device *dev = hva_to_dev(hva);\r\ndisable_irq(hva->irq_its);\r\ndisable_irq(hva->irq_err);\r\npm_runtime_put_autosuspend(dev);\r\npm_runtime_disable(dev);\r\n}\r\nint hva_hw_runtime_suspend(struct device *dev)\r\n{\r\nstruct hva_dev *hva = dev_get_drvdata(dev);\r\nclk_disable_unprepare(hva->clk);\r\nreturn 0;\r\n}\r\nint hva_hw_runtime_resume(struct device *dev)\r\n{\r\nstruct hva_dev *hva = dev_get_drvdata(dev);\r\nif (clk_prepare_enable(hva->clk)) {\r\ndev_err(hva->dev, "%s failed to prepare hva clk\n",\r\nHVA_PREFIX);\r\nreturn -EINVAL;\r\n}\r\nif (clk_set_rate(hva->clk, CLK_RATE)) {\r\ndev_err(dev, "%s failed to set clock frequency\n",\r\nHVA_PREFIX);\r\nreturn -EINVAL;\r\n}\r\nreturn 0;\r\n}\r\nint hva_hw_execute_task(struct hva_ctx *ctx, enum hva_hw_cmd_type cmd,\r\nstruct hva_buffer *task)\r\n{\r\nstruct hva_dev *hva = ctx_to_hdev(ctx);\r\nstruct device *dev = hva_to_dev(hva);\r\nu8 client_id = ctx->id;\r\nint ret;\r\nu32 reg = 0;\r\nmutex_lock(&hva->protect_mutex);\r\nenable_irq(hva->irq_its);\r\nenable_irq(hva->irq_err);\r\nif (pm_runtime_get_sync(dev) < 0) {\r\ndev_err(dev, "%s failed to get pm_runtime\n", ctx->name);\r\nctx->sys_errors++;\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nreg = readl_relaxed(hva->regs + HVA_HIF_REG_CLK_GATING);\r\nswitch (cmd) {\r\ncase H264_ENC:\r\nreg |= CLK_GATING_HVC;\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s unknown command 0x%x\n", ctx->name, cmd);\r\nctx->encode_errors++;\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nwritel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);\r\ndev_dbg(dev, "%s %s: write configuration registers\n", ctx->name,\r\n__func__);\r\nwritel_relaxed(BSM_CFG_VAL1, hva->regs + HVA_HIF_REG_BSM);\r\nwritel_relaxed(MIF_CFG_VAL3, hva->regs + HVA_HIF_REG_MIF_CFG);\r\nwritel_relaxed(HEC_MIF_CFG_VAL, hva->regs + HVA_HIF_REG_HEC_MIF_CFG);\r\ndev_dbg(dev, "%s %s: send task (cmd: %d, task_desc: %pad)\n",\r\nctx->name, __func__, cmd + (client_id << 8), &task->paddr);\r\nwritel_relaxed(cmd + (client_id << 8), hva->regs + HVA_HIF_FIFO_CMD);\r\nwritel_relaxed(task->paddr, hva->regs + HVA_HIF_FIFO_CMD);\r\nif (!wait_for_completion_timeout(&hva->interrupt,\r\nmsecs_to_jiffies(2000))) {\r\ndev_err(dev, "%s %s: time out on completion\n", ctx->name,\r\n__func__);\r\nctx->encode_errors++;\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nret = ctx->hw_err ? -EFAULT : 0;\r\nctx->encode_errors += ctx->hw_err ? 1 : 0;\r\nout:\r\ndisable_irq(hva->irq_its);\r\ndisable_irq(hva->irq_err);\r\nswitch (cmd) {\r\ncase H264_ENC:\r\nreg &= ~CLK_GATING_HVC;\r\nwritel_relaxed(reg, hva->regs + HVA_HIF_REG_CLK_GATING);\r\nbreak;\r\ndefault:\r\ndev_dbg(dev, "%s unknown command 0x%x\n", ctx->name, cmd);\r\n}\r\npm_runtime_put_autosuspend(dev);\r\nmutex_unlock(&hva->protect_mutex);\r\nreturn ret;\r\n}\r\nvoid hva_hw_dump_regs(struct hva_dev *hva, struct seq_file *s)\r\n{\r\nstruct device *dev = hva_to_dev(hva);\r\nmutex_lock(&hva->protect_mutex);\r\nif (pm_runtime_get_sync(dev) < 0) {\r\nseq_puts(s, "Cannot wake up IP\n");\r\nmutex_unlock(&hva->protect_mutex);\r\nreturn;\r\n}\r\nseq_printf(s, "Registers:\nReg @ = 0x%p\n", hva->regs);\r\nDUMP(HVA_HIF_REG_RST);\r\nDUMP(HVA_HIF_REG_RST_ACK);\r\nDUMP(HVA_HIF_REG_MIF_CFG);\r\nDUMP(HVA_HIF_REG_HEC_MIF_CFG);\r\nDUMP(HVA_HIF_REG_CFL);\r\nDUMP(HVA_HIF_REG_SFL);\r\nDUMP(HVA_HIF_REG_LMI_ERR);\r\nDUMP(HVA_HIF_REG_EMI_ERR);\r\nDUMP(HVA_HIF_REG_HEC_MIF_ERR);\r\nDUMP(HVA_HIF_REG_HEC_STS);\r\nDUMP(HVA_HIF_REG_HVC_STS);\r\nDUMP(HVA_HIF_REG_HJE_STS);\r\nDUMP(HVA_HIF_REG_CNT);\r\nDUMP(HVA_HIF_REG_HEC_CHKSYN_DIS);\r\nDUMP(HVA_HIF_REG_CLK_GATING);\r\nDUMP(HVA_HIF_REG_VERSION);\r\npm_runtime_put_autosuspend(dev);\r\nmutex_unlock(&hva->protect_mutex);\r\n}
