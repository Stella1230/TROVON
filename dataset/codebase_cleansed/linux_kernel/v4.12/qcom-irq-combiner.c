static inline int irq_nr(u32 reg, u32 bit)\r\n{\r\nreturn reg * REG_SIZE + bit;\r\n}\r\nstatic void combiner_handle_irq(struct irq_desc *desc)\r\n{\r\nstruct combiner *combiner = irq_desc_get_handler_data(desc);\r\nstruct irq_chip *chip = irq_desc_get_chip(desc);\r\nu32 reg;\r\nchained_irq_enter(chip, desc);\r\nfor (reg = 0; reg < combiner->nregs; reg++) {\r\nint virq;\r\nint hwirq;\r\nu32 bit;\r\nu32 status;\r\nbit = readl_relaxed(combiner->regs[reg].addr);\r\nstatus = bit & combiner->regs[reg].enabled;\r\nif (!status)\r\npr_warn_ratelimited("Unexpected IRQ on CPU%d: (%08x %08lx %p)\n",\r\nsmp_processor_id(), bit,\r\ncombiner->regs[reg].enabled,\r\ncombiner->regs[reg].addr);\r\nwhile (status) {\r\nbit = __ffs(status);\r\nstatus &= ~(1 << bit);\r\nhwirq = irq_nr(reg, bit);\r\nvirq = irq_find_mapping(combiner->domain, hwirq);\r\nif (virq > 0)\r\ngeneric_handle_irq(virq);\r\n}\r\n}\r\nchained_irq_exit(chip, desc);\r\n}\r\nstatic void combiner_irq_chip_mask_irq(struct irq_data *data)\r\n{\r\nstruct combiner *combiner = irq_data_get_irq_chip_data(data);\r\nstruct combiner_reg *reg = combiner->regs + data->hwirq / REG_SIZE;\r\nclear_bit(data->hwirq % REG_SIZE, &reg->enabled);\r\n}\r\nstatic void combiner_irq_chip_unmask_irq(struct irq_data *data)\r\n{\r\nstruct combiner *combiner = irq_data_get_irq_chip_data(data);\r\nstruct combiner_reg *reg = combiner->regs + data->hwirq / REG_SIZE;\r\nset_bit(data->hwirq % REG_SIZE, &reg->enabled);\r\n}\r\nstatic int combiner_irq_map(struct irq_domain *domain, unsigned int irq,\r\nirq_hw_number_t hwirq)\r\n{\r\nirq_set_chip_and_handler(irq, &irq_chip, handle_level_irq);\r\nirq_set_chip_data(irq, domain->host_data);\r\nirq_set_noprobe(irq);\r\nreturn 0;\r\n}\r\nstatic void combiner_irq_unmap(struct irq_domain *domain, unsigned int irq)\r\n{\r\nirq_domain_reset_irq_data(irq_get_irq_data(irq));\r\n}\r\nstatic int combiner_irq_translate(struct irq_domain *d, struct irq_fwspec *fws,\r\nunsigned long *hwirq, unsigned int *type)\r\n{\r\nstruct combiner *combiner = d->host_data;\r\nif (is_acpi_node(fws->fwnode)) {\r\nif (WARN_ON((fws->param_count != 2) ||\r\n(fws->param[0] >= combiner->nirqs) ||\r\n(fws->param[1] & IORESOURCE_IRQ_LOWEDGE) ||\r\n(fws->param[1] & IORESOURCE_IRQ_HIGHEDGE)))\r\nreturn -EINVAL;\r\n*hwirq = fws->param[0];\r\n*type = fws->param[1];\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic acpi_status count_registers_cb(struct acpi_resource *ares, void *context)\r\n{\r\nint *count = context;\r\nif (ares->type == ACPI_RESOURCE_TYPE_GENERIC_REGISTER)\r\n++(*count);\r\nreturn AE_OK;\r\n}\r\nstatic int count_registers(struct platform_device *pdev)\r\n{\r\nacpi_handle ahandle = ACPI_HANDLE(&pdev->dev);\r\nacpi_status status;\r\nint count = 0;\r\nif (!acpi_has_method(ahandle, METHOD_NAME__CRS))\r\nreturn -EINVAL;\r\nstatus = acpi_walk_resources(ahandle, METHOD_NAME__CRS,\r\ncount_registers_cb, &count);\r\nif (ACPI_FAILURE(status))\r\nreturn -EINVAL;\r\nreturn count;\r\n}\r\nstatic acpi_status get_registers_cb(struct acpi_resource *ares, void *context)\r\n{\r\nstruct get_registers_context *ctx = context;\r\nstruct acpi_resource_generic_register *reg;\r\nphys_addr_t paddr;\r\nvoid __iomem *vaddr;\r\nif (ares->type != ACPI_RESOURCE_TYPE_GENERIC_REGISTER)\r\nreturn AE_OK;\r\nreg = &ares->data.generic_reg;\r\npaddr = reg->address;\r\nif ((reg->space_id != ACPI_SPACE_MEM) ||\r\n(reg->bit_offset != 0) ||\r\n(reg->bit_width > REG_SIZE)) {\r\ndev_err(ctx->dev, "Bad register resource @%pa\n", &paddr);\r\nctx->err = -EINVAL;\r\nreturn AE_ERROR;\r\n}\r\nvaddr = devm_ioremap(ctx->dev, reg->address, REG_SIZE);\r\nif (!vaddr) {\r\ndev_err(ctx->dev, "Can't map register @%pa\n", &paddr);\r\nctx->err = -ENOMEM;\r\nreturn AE_ERROR;\r\n}\r\nctx->combiner->regs[ctx->combiner->nregs].addr = vaddr;\r\nctx->combiner->nirqs += reg->bit_width;\r\nctx->combiner->nregs++;\r\nreturn AE_OK;\r\n}\r\nstatic int get_registers(struct platform_device *pdev, struct combiner *comb)\r\n{\r\nacpi_handle ahandle = ACPI_HANDLE(&pdev->dev);\r\nacpi_status status;\r\nstruct get_registers_context ctx;\r\nif (!acpi_has_method(ahandle, METHOD_NAME__CRS))\r\nreturn -EINVAL;\r\nctx.dev = &pdev->dev;\r\nctx.combiner = comb;\r\nctx.err = 0;\r\nstatus = acpi_walk_resources(ahandle, METHOD_NAME__CRS,\r\nget_registers_cb, &ctx);\r\nif (ACPI_FAILURE(status))\r\nreturn ctx.err;\r\nreturn 0;\r\n}\r\nstatic int __init combiner_probe(struct platform_device *pdev)\r\n{\r\nstruct combiner *combiner;\r\nsize_t alloc_sz;\r\nu32 nregs;\r\nint err;\r\nnregs = count_registers(pdev);\r\nif (nregs <= 0) {\r\ndev_err(&pdev->dev, "Error reading register resources\n");\r\nreturn -EINVAL;\r\n}\r\nalloc_sz = sizeof(*combiner) + sizeof(struct combiner_reg) * nregs;\r\ncombiner = devm_kzalloc(&pdev->dev, alloc_sz, GFP_KERNEL);\r\nif (!combiner)\r\nreturn -ENOMEM;\r\nerr = get_registers(pdev, combiner);\r\nif (err < 0)\r\nreturn err;\r\ncombiner->parent_irq = platform_get_irq(pdev, 0);\r\nif (combiner->parent_irq <= 0) {\r\ndev_err(&pdev->dev, "Error getting IRQ resource\n");\r\nreturn -EPROBE_DEFER;\r\n}\r\ncombiner->domain = irq_domain_create_linear(pdev->dev.fwnode, combiner->nirqs,\r\n&domain_ops, combiner);\r\nif (!combiner->domain)\r\nreturn -ENODEV;\r\nirq_set_chained_handler_and_data(combiner->parent_irq,\r\ncombiner_handle_irq, combiner);\r\ndev_info(&pdev->dev, "Initialized with [p=%d,n=%d,r=%p]\n",\r\ncombiner->parent_irq, combiner->nirqs, combiner->regs[0].addr);\r\nreturn 0;\r\n}\r\nstatic int __init register_qcom_irq_combiner(void)\r\n{\r\nreturn platform_driver_register(&qcom_irq_combiner_probe);\r\n}
