static inline void b44_sync_dma_desc_for_device(struct ssb_device *sdev,\r\ndma_addr_t dma_base,\r\nunsigned long offset,\r\nenum dma_data_direction dir)\r\n{\r\ndma_sync_single_for_device(sdev->dma_dev, dma_base + offset,\r\ndma_desc_sync_size, dir);\r\n}\r\nstatic inline void b44_sync_dma_desc_for_cpu(struct ssb_device *sdev,\r\ndma_addr_t dma_base,\r\nunsigned long offset,\r\nenum dma_data_direction dir)\r\n{\r\ndma_sync_single_for_cpu(sdev->dma_dev, dma_base + offset,\r\ndma_desc_sync_size, dir);\r\n}\r\nstatic inline unsigned long br32(const struct b44 *bp, unsigned long reg)\r\n{\r\nreturn ssb_read32(bp->sdev, reg);\r\n}\r\nstatic inline void bw32(const struct b44 *bp,\r\nunsigned long reg, unsigned long val)\r\n{\r\nssb_write32(bp->sdev, reg, val);\r\n}\r\nstatic int b44_wait_bit(struct b44 *bp, unsigned long reg,\r\nu32 bit, unsigned long timeout, const int clear)\r\n{\r\nunsigned long i;\r\nfor (i = 0; i < timeout; i++) {\r\nu32 val = br32(bp, reg);\r\nif (clear && !(val & bit))\r\nbreak;\r\nif (!clear && (val & bit))\r\nbreak;\r\nudelay(10);\r\n}\r\nif (i == timeout) {\r\nif (net_ratelimit())\r\nnetdev_err(bp->dev, "BUG! Timeout waiting for bit %08x of register %lx to %s\n",\r\nbit, reg, clear ? "clear" : "set");\r\nreturn -ENODEV;\r\n}\r\nreturn 0;\r\n}\r\nstatic inline void __b44_cam_read(struct b44 *bp, unsigned char *data, int index)\r\n{\r\nu32 val;\r\nbw32(bp, B44_CAM_CTRL, (CAM_CTRL_READ |\r\n(index << CAM_CTRL_INDEX_SHIFT)));\r\nb44_wait_bit(bp, B44_CAM_CTRL, CAM_CTRL_BUSY, 100, 1);\r\nval = br32(bp, B44_CAM_DATA_LO);\r\ndata[2] = (val >> 24) & 0xFF;\r\ndata[3] = (val >> 16) & 0xFF;\r\ndata[4] = (val >> 8) & 0xFF;\r\ndata[5] = (val >> 0) & 0xFF;\r\nval = br32(bp, B44_CAM_DATA_HI);\r\ndata[0] = (val >> 8) & 0xFF;\r\ndata[1] = (val >> 0) & 0xFF;\r\n}\r\nstatic inline void __b44_cam_write(struct b44 *bp, unsigned char *data, int index)\r\n{\r\nu32 val;\r\nval = ((u32) data[2]) << 24;\r\nval |= ((u32) data[3]) << 16;\r\nval |= ((u32) data[4]) << 8;\r\nval |= ((u32) data[5]) << 0;\r\nbw32(bp, B44_CAM_DATA_LO, val);\r\nval = (CAM_DATA_HI_VALID |\r\n(((u32) data[0]) << 8) |\r\n(((u32) data[1]) << 0));\r\nbw32(bp, B44_CAM_DATA_HI, val);\r\nbw32(bp, B44_CAM_CTRL, (CAM_CTRL_WRITE |\r\n(index << CAM_CTRL_INDEX_SHIFT)));\r\nb44_wait_bit(bp, B44_CAM_CTRL, CAM_CTRL_BUSY, 100, 1);\r\n}\r\nstatic inline void __b44_disable_ints(struct b44 *bp)\r\n{\r\nbw32(bp, B44_IMASK, 0);\r\n}\r\nstatic void b44_disable_ints(struct b44 *bp)\r\n{\r\n__b44_disable_ints(bp);\r\nbr32(bp, B44_IMASK);\r\n}\r\nstatic void b44_enable_ints(struct b44 *bp)\r\n{\r\nbw32(bp, B44_IMASK, bp->imask);\r\n}\r\nstatic int __b44_readphy(struct b44 *bp, int phy_addr, int reg, u32 *val)\r\n{\r\nint err;\r\nbw32(bp, B44_EMAC_ISTAT, EMAC_INT_MII);\r\nbw32(bp, B44_MDIO_DATA, (MDIO_DATA_SB_START |\r\n(MDIO_OP_READ << MDIO_DATA_OP_SHIFT) |\r\n(phy_addr << MDIO_DATA_PMD_SHIFT) |\r\n(reg << MDIO_DATA_RA_SHIFT) |\r\n(MDIO_TA_VALID << MDIO_DATA_TA_SHIFT)));\r\nerr = b44_wait_bit(bp, B44_EMAC_ISTAT, EMAC_INT_MII, 100, 0);\r\n*val = br32(bp, B44_MDIO_DATA) & MDIO_DATA_DATA;\r\nreturn err;\r\n}\r\nstatic int __b44_writephy(struct b44 *bp, int phy_addr, int reg, u32 val)\r\n{\r\nbw32(bp, B44_EMAC_ISTAT, EMAC_INT_MII);\r\nbw32(bp, B44_MDIO_DATA, (MDIO_DATA_SB_START |\r\n(MDIO_OP_WRITE << MDIO_DATA_OP_SHIFT) |\r\n(phy_addr << MDIO_DATA_PMD_SHIFT) |\r\n(reg << MDIO_DATA_RA_SHIFT) |\r\n(MDIO_TA_VALID << MDIO_DATA_TA_SHIFT) |\r\n(val & MDIO_DATA_DATA)));\r\nreturn b44_wait_bit(bp, B44_EMAC_ISTAT, EMAC_INT_MII, 100, 0);\r\n}\r\nstatic inline int b44_readphy(struct b44 *bp, int reg, u32 *val)\r\n{\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nreturn 0;\r\nreturn __b44_readphy(bp, bp->phy_addr, reg, val);\r\n}\r\nstatic inline int b44_writephy(struct b44 *bp, int reg, u32 val)\r\n{\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nreturn 0;\r\nreturn __b44_writephy(bp, bp->phy_addr, reg, val);\r\n}\r\nstatic int b44_mdio_read_mii(struct net_device *dev, int phy_id, int location)\r\n{\r\nu32 val;\r\nstruct b44 *bp = netdev_priv(dev);\r\nint rc = __b44_readphy(bp, phy_id, location, &val);\r\nif (rc)\r\nreturn 0xffffffff;\r\nreturn val;\r\n}\r\nstatic void b44_mdio_write_mii(struct net_device *dev, int phy_id, int location,\r\nint val)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\n__b44_writephy(bp, phy_id, location, val);\r\n}\r\nstatic int b44_mdio_read_phylib(struct mii_bus *bus, int phy_id, int location)\r\n{\r\nu32 val;\r\nstruct b44 *bp = bus->priv;\r\nint rc = __b44_readphy(bp, phy_id, location, &val);\r\nif (rc)\r\nreturn 0xffffffff;\r\nreturn val;\r\n}\r\nstatic int b44_mdio_write_phylib(struct mii_bus *bus, int phy_id, int location,\r\nu16 val)\r\n{\r\nstruct b44 *bp = bus->priv;\r\nreturn __b44_writephy(bp, phy_id, location, val);\r\n}\r\nstatic int b44_phy_reset(struct b44 *bp)\r\n{\r\nu32 val;\r\nint err;\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nreturn 0;\r\nerr = b44_writephy(bp, MII_BMCR, BMCR_RESET);\r\nif (err)\r\nreturn err;\r\nudelay(100);\r\nerr = b44_readphy(bp, MII_BMCR, &val);\r\nif (!err) {\r\nif (val & BMCR_RESET) {\r\nnetdev_err(bp->dev, "PHY Reset would not complete\n");\r\nerr = -ENODEV;\r\n}\r\n}\r\nreturn err;\r\n}\r\nstatic void __b44_set_flow_ctrl(struct b44 *bp, u32 pause_flags)\r\n{\r\nu32 val;\r\nbp->flags &= ~(B44_FLAG_TX_PAUSE | B44_FLAG_RX_PAUSE);\r\nbp->flags |= pause_flags;\r\nval = br32(bp, B44_RXCONFIG);\r\nif (pause_flags & B44_FLAG_RX_PAUSE)\r\nval |= RXCONFIG_FLOW;\r\nelse\r\nval &= ~RXCONFIG_FLOW;\r\nbw32(bp, B44_RXCONFIG, val);\r\nval = br32(bp, B44_MAC_FLOW);\r\nif (pause_flags & B44_FLAG_TX_PAUSE)\r\nval |= (MAC_FLOW_PAUSE_ENAB |\r\n(0xc0 & MAC_FLOW_RX_HI_WATER));\r\nelse\r\nval &= ~MAC_FLOW_PAUSE_ENAB;\r\nbw32(bp, B44_MAC_FLOW, val);\r\n}\r\nstatic void b44_set_flow_ctrl(struct b44 *bp, u32 local, u32 remote)\r\n{\r\nu32 pause_enab = 0;\r\nif ((local & ADVERTISE_PAUSE_CAP) &&\r\n(local & ADVERTISE_PAUSE_ASYM)){\r\nif ((remote & LPA_PAUSE_ASYM) &&\r\n!(remote & LPA_PAUSE_CAP))\r\npause_enab |= B44_FLAG_RX_PAUSE;\r\n}\r\n__b44_set_flow_ctrl(bp, pause_enab);\r\n}\r\nstatic void b44_wap54g10_workaround(struct b44 *bp)\r\n{\r\nchar buf[20];\r\nu32 val;\r\nint err;\r\nif (bcm47xx_nvram_getenv("boardnum", buf, sizeof(buf)) < 0)\r\nreturn;\r\nif (simple_strtoul(buf, NULL, 0) == 2) {\r\nerr = __b44_readphy(bp, 0, MII_BMCR, &val);\r\nif (err)\r\ngoto error;\r\nif (!(val & BMCR_ISOLATE))\r\nreturn;\r\nval &= ~BMCR_ISOLATE;\r\nerr = __b44_writephy(bp, 0, MII_BMCR, val);\r\nif (err)\r\ngoto error;\r\n}\r\nreturn;\r\nerror:\r\npr_warn("PHY: cannot reset MII transceiver isolate bit\n");\r\n}\r\nstatic inline void b44_wap54g10_workaround(struct b44 *bp)\r\n{\r\n}\r\nstatic int b44_setup_phy(struct b44 *bp)\r\n{\r\nu32 val;\r\nint err;\r\nb44_wap54g10_workaround(bp);\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nreturn 0;\r\nif ((err = b44_readphy(bp, B44_MII_ALEDCTRL, &val)) != 0)\r\ngoto out;\r\nif ((err = b44_writephy(bp, B44_MII_ALEDCTRL,\r\nval & MII_ALEDCTRL_ALLMSK)) != 0)\r\ngoto out;\r\nif ((err = b44_readphy(bp, B44_MII_TLEDCTRL, &val)) != 0)\r\ngoto out;\r\nif ((err = b44_writephy(bp, B44_MII_TLEDCTRL,\r\nval | MII_TLEDCTRL_ENABLE)) != 0)\r\ngoto out;\r\nif (!(bp->flags & B44_FLAG_FORCE_LINK)) {\r\nu32 adv = ADVERTISE_CSMA;\r\nif (bp->flags & B44_FLAG_ADV_10HALF)\r\nadv |= ADVERTISE_10HALF;\r\nif (bp->flags & B44_FLAG_ADV_10FULL)\r\nadv |= ADVERTISE_10FULL;\r\nif (bp->flags & B44_FLAG_ADV_100HALF)\r\nadv |= ADVERTISE_100HALF;\r\nif (bp->flags & B44_FLAG_ADV_100FULL)\r\nadv |= ADVERTISE_100FULL;\r\nif (bp->flags & B44_FLAG_PAUSE_AUTO)\r\nadv |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;\r\nif ((err = b44_writephy(bp, MII_ADVERTISE, adv)) != 0)\r\ngoto out;\r\nif ((err = b44_writephy(bp, MII_BMCR, (BMCR_ANENABLE |\r\nBMCR_ANRESTART))) != 0)\r\ngoto out;\r\n} else {\r\nu32 bmcr;\r\nif ((err = b44_readphy(bp, MII_BMCR, &bmcr)) != 0)\r\ngoto out;\r\nbmcr &= ~(BMCR_FULLDPLX | BMCR_ANENABLE | BMCR_SPEED100);\r\nif (bp->flags & B44_FLAG_100_BASE_T)\r\nbmcr |= BMCR_SPEED100;\r\nif (bp->flags & B44_FLAG_FULL_DUPLEX)\r\nbmcr |= BMCR_FULLDPLX;\r\nif ((err = b44_writephy(bp, MII_BMCR, bmcr)) != 0)\r\ngoto out;\r\nb44_set_flow_ctrl(bp, 0, 0);\r\n}\r\nout:\r\nreturn err;\r\n}\r\nstatic void b44_stats_update(struct b44 *bp)\r\n{\r\nunsigned long reg;\r\nu64 *val;\r\nval = &bp->hw_stats.tx_good_octets;\r\nu64_stats_update_begin(&bp->hw_stats.syncp);\r\nfor (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL) {\r\n*val++ += br32(bp, reg);\r\n}\r\nreg += 8*4UL;\r\nfor (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL) {\r\n*val++ += br32(bp, reg);\r\n}\r\nu64_stats_update_end(&bp->hw_stats.syncp);\r\n}\r\nstatic void b44_link_report(struct b44 *bp)\r\n{\r\nif (!netif_carrier_ok(bp->dev)) {\r\nnetdev_info(bp->dev, "Link is down\n");\r\n} else {\r\nnetdev_info(bp->dev, "Link is up at %d Mbps, %s duplex\n",\r\n(bp->flags & B44_FLAG_100_BASE_T) ? 100 : 10,\r\n(bp->flags & B44_FLAG_FULL_DUPLEX) ? "full" : "half");\r\nnetdev_info(bp->dev, "Flow control is %s for TX and %s for RX\n",\r\n(bp->flags & B44_FLAG_TX_PAUSE) ? "on" : "off",\r\n(bp->flags & B44_FLAG_RX_PAUSE) ? "on" : "off");\r\n}\r\n}\r\nstatic void b44_check_phy(struct b44 *bp)\r\n{\r\nu32 bmsr, aux;\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\r\nbp->flags |= B44_FLAG_100_BASE_T;\r\nif (!netif_carrier_ok(bp->dev)) {\r\nu32 val = br32(bp, B44_TX_CTRL);\r\nif (bp->flags & B44_FLAG_FULL_DUPLEX)\r\nval |= TX_CTRL_DUPLEX;\r\nelse\r\nval &= ~TX_CTRL_DUPLEX;\r\nbw32(bp, B44_TX_CTRL, val);\r\nnetif_carrier_on(bp->dev);\r\nb44_link_report(bp);\r\n}\r\nreturn;\r\n}\r\nif (!b44_readphy(bp, MII_BMSR, &bmsr) &&\r\n!b44_readphy(bp, B44_MII_AUXCTRL, &aux) &&\r\n(bmsr != 0xffff)) {\r\nif (aux & MII_AUXCTRL_SPEED)\r\nbp->flags |= B44_FLAG_100_BASE_T;\r\nelse\r\nbp->flags &= ~B44_FLAG_100_BASE_T;\r\nif (aux & MII_AUXCTRL_DUPLEX)\r\nbp->flags |= B44_FLAG_FULL_DUPLEX;\r\nelse\r\nbp->flags &= ~B44_FLAG_FULL_DUPLEX;\r\nif (!netif_carrier_ok(bp->dev) &&\r\n(bmsr & BMSR_LSTATUS)) {\r\nu32 val = br32(bp, B44_TX_CTRL);\r\nu32 local_adv, remote_adv;\r\nif (bp->flags & B44_FLAG_FULL_DUPLEX)\r\nval |= TX_CTRL_DUPLEX;\r\nelse\r\nval &= ~TX_CTRL_DUPLEX;\r\nbw32(bp, B44_TX_CTRL, val);\r\nif (!(bp->flags & B44_FLAG_FORCE_LINK) &&\r\n!b44_readphy(bp, MII_ADVERTISE, &local_adv) &&\r\n!b44_readphy(bp, MII_LPA, &remote_adv))\r\nb44_set_flow_ctrl(bp, local_adv, remote_adv);\r\nnetif_carrier_on(bp->dev);\r\nb44_link_report(bp);\r\n} else if (netif_carrier_ok(bp->dev) && !(bmsr & BMSR_LSTATUS)) {\r\nnetif_carrier_off(bp->dev);\r\nb44_link_report(bp);\r\n}\r\nif (bmsr & BMSR_RFAULT)\r\nnetdev_warn(bp->dev, "Remote fault detected in PHY\n");\r\nif (bmsr & BMSR_JCD)\r\nnetdev_warn(bp->dev, "Jabber detected in PHY\n");\r\n}\r\n}\r\nstatic void b44_timer(unsigned long __opaque)\r\n{\r\nstruct b44 *bp = (struct b44 *) __opaque;\r\nspin_lock_irq(&bp->lock);\r\nb44_check_phy(bp);\r\nb44_stats_update(bp);\r\nspin_unlock_irq(&bp->lock);\r\nmod_timer(&bp->timer, round_jiffies(jiffies + HZ));\r\n}\r\nstatic void b44_tx(struct b44 *bp)\r\n{\r\nu32 cur, cons;\r\nunsigned bytes_compl = 0, pkts_compl = 0;\r\ncur = br32(bp, B44_DMATX_STAT) & DMATX_STAT_CDMASK;\r\ncur /= sizeof(struct dma_desc);\r\nfor (cons = bp->tx_cons; cons != cur; cons = NEXT_TX(cons)) {\r\nstruct ring_info *rp = &bp->tx_buffers[cons];\r\nstruct sk_buff *skb = rp->skb;\r\nBUG_ON(skb == NULL);\r\ndma_unmap_single(bp->sdev->dma_dev,\r\nrp->mapping,\r\nskb->len,\r\nDMA_TO_DEVICE);\r\nrp->skb = NULL;\r\nbytes_compl += skb->len;\r\npkts_compl++;\r\ndev_kfree_skb_irq(skb);\r\n}\r\nnetdev_completed_queue(bp->dev, pkts_compl, bytes_compl);\r\nbp->tx_cons = cons;\r\nif (netif_queue_stopped(bp->dev) &&\r\nTX_BUFFS_AVAIL(bp) > B44_TX_WAKEUP_THRESH)\r\nnetif_wake_queue(bp->dev);\r\nbw32(bp, B44_GPTIMER, 0);\r\n}\r\nstatic int b44_alloc_rx_skb(struct b44 *bp, int src_idx, u32 dest_idx_unmasked)\r\n{\r\nstruct dma_desc *dp;\r\nstruct ring_info *src_map, *map;\r\nstruct rx_header *rh;\r\nstruct sk_buff *skb;\r\ndma_addr_t mapping;\r\nint dest_idx;\r\nu32 ctrl;\r\nsrc_map = NULL;\r\nif (src_idx >= 0)\r\nsrc_map = &bp->rx_buffers[src_idx];\r\ndest_idx = dest_idx_unmasked & (B44_RX_RING_SIZE - 1);\r\nmap = &bp->rx_buffers[dest_idx];\r\nskb = netdev_alloc_skb(bp->dev, RX_PKT_BUF_SZ);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nmapping = dma_map_single(bp->sdev->dma_dev, skb->data,\r\nRX_PKT_BUF_SZ,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(bp->sdev->dma_dev, mapping) ||\r\nmapping + RX_PKT_BUF_SZ > DMA_BIT_MASK(30)) {\r\nif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\r\ndma_unmap_single(bp->sdev->dma_dev, mapping,\r\nRX_PKT_BUF_SZ, DMA_FROM_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nskb = alloc_skb(RX_PKT_BUF_SZ, GFP_ATOMIC | GFP_DMA);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nmapping = dma_map_single(bp->sdev->dma_dev, skb->data,\r\nRX_PKT_BUF_SZ,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(bp->sdev->dma_dev, mapping) ||\r\nmapping + RX_PKT_BUF_SZ > DMA_BIT_MASK(30)) {\r\nif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\r\ndma_unmap_single(bp->sdev->dma_dev, mapping, RX_PKT_BUF_SZ,DMA_FROM_DEVICE);\r\ndev_kfree_skb_any(skb);\r\nreturn -ENOMEM;\r\n}\r\nbp->force_copybreak = 1;\r\n}\r\nrh = (struct rx_header *) skb->data;\r\nrh->len = 0;\r\nrh->flags = 0;\r\nmap->skb = skb;\r\nmap->mapping = mapping;\r\nif (src_map != NULL)\r\nsrc_map->skb = NULL;\r\nctrl = (DESC_CTRL_LEN & RX_PKT_BUF_SZ);\r\nif (dest_idx == (B44_RX_RING_SIZE - 1))\r\nctrl |= DESC_CTRL_EOT;\r\ndp = &bp->rx_ring[dest_idx];\r\ndp->ctrl = cpu_to_le32(ctrl);\r\ndp->addr = cpu_to_le32((u32) mapping + bp->dma_offset);\r\nif (bp->flags & B44_FLAG_RX_RING_HACK)\r\nb44_sync_dma_desc_for_device(bp->sdev, bp->rx_ring_dma,\r\ndest_idx * sizeof(*dp),\r\nDMA_BIDIRECTIONAL);\r\nreturn RX_PKT_BUF_SZ;\r\n}\r\nstatic void b44_recycle_rx(struct b44 *bp, int src_idx, u32 dest_idx_unmasked)\r\n{\r\nstruct dma_desc *src_desc, *dest_desc;\r\nstruct ring_info *src_map, *dest_map;\r\nstruct rx_header *rh;\r\nint dest_idx;\r\n__le32 ctrl;\r\ndest_idx = dest_idx_unmasked & (B44_RX_RING_SIZE - 1);\r\ndest_desc = &bp->rx_ring[dest_idx];\r\ndest_map = &bp->rx_buffers[dest_idx];\r\nsrc_desc = &bp->rx_ring[src_idx];\r\nsrc_map = &bp->rx_buffers[src_idx];\r\ndest_map->skb = src_map->skb;\r\nrh = (struct rx_header *) src_map->skb->data;\r\nrh->len = 0;\r\nrh->flags = 0;\r\ndest_map->mapping = src_map->mapping;\r\nif (bp->flags & B44_FLAG_RX_RING_HACK)\r\nb44_sync_dma_desc_for_cpu(bp->sdev, bp->rx_ring_dma,\r\nsrc_idx * sizeof(*src_desc),\r\nDMA_BIDIRECTIONAL);\r\nctrl = src_desc->ctrl;\r\nif (dest_idx == (B44_RX_RING_SIZE - 1))\r\nctrl |= cpu_to_le32(DESC_CTRL_EOT);\r\nelse\r\nctrl &= cpu_to_le32(~DESC_CTRL_EOT);\r\ndest_desc->ctrl = ctrl;\r\ndest_desc->addr = src_desc->addr;\r\nsrc_map->skb = NULL;\r\nif (bp->flags & B44_FLAG_RX_RING_HACK)\r\nb44_sync_dma_desc_for_device(bp->sdev, bp->rx_ring_dma,\r\ndest_idx * sizeof(*dest_desc),\r\nDMA_BIDIRECTIONAL);\r\ndma_sync_single_for_device(bp->sdev->dma_dev, dest_map->mapping,\r\nRX_PKT_BUF_SZ,\r\nDMA_FROM_DEVICE);\r\n}\r\nstatic int b44_rx(struct b44 *bp, int budget)\r\n{\r\nint received;\r\nu32 cons, prod;\r\nreceived = 0;\r\nprod = br32(bp, B44_DMARX_STAT) & DMARX_STAT_CDMASK;\r\nprod /= sizeof(struct dma_desc);\r\ncons = bp->rx_cons;\r\nwhile (cons != prod && budget > 0) {\r\nstruct ring_info *rp = &bp->rx_buffers[cons];\r\nstruct sk_buff *skb = rp->skb;\r\ndma_addr_t map = rp->mapping;\r\nstruct rx_header *rh;\r\nu16 len;\r\ndma_sync_single_for_cpu(bp->sdev->dma_dev, map,\r\nRX_PKT_BUF_SZ,\r\nDMA_FROM_DEVICE);\r\nrh = (struct rx_header *) skb->data;\r\nlen = le16_to_cpu(rh->len);\r\nif ((len > (RX_PKT_BUF_SZ - RX_PKT_OFFSET)) ||\r\n(rh->flags & cpu_to_le16(RX_FLAG_ERRORS))) {\r\ndrop_it:\r\nb44_recycle_rx(bp, cons, bp->rx_prod);\r\ndrop_it_no_recycle:\r\nbp->dev->stats.rx_dropped++;\r\ngoto next_pkt;\r\n}\r\nif (len == 0) {\r\nint i = 0;\r\ndo {\r\nudelay(2);\r\nbarrier();\r\nlen = le16_to_cpu(rh->len);\r\n} while (len == 0 && i++ < 5);\r\nif (len == 0)\r\ngoto drop_it;\r\n}\r\nlen -= 4;\r\nif (!bp->force_copybreak && len > RX_COPY_THRESHOLD) {\r\nint skb_size;\r\nskb_size = b44_alloc_rx_skb(bp, cons, bp->rx_prod);\r\nif (skb_size < 0)\r\ngoto drop_it;\r\ndma_unmap_single(bp->sdev->dma_dev, map,\r\nskb_size, DMA_FROM_DEVICE);\r\nskb_put(skb, len + RX_PKT_OFFSET);\r\nskb_pull(skb, RX_PKT_OFFSET);\r\n} else {\r\nstruct sk_buff *copy_skb;\r\nb44_recycle_rx(bp, cons, bp->rx_prod);\r\ncopy_skb = napi_alloc_skb(&bp->napi, len);\r\nif (copy_skb == NULL)\r\ngoto drop_it_no_recycle;\r\nskb_put(copy_skb, len);\r\nskb_copy_from_linear_data_offset(skb, RX_PKT_OFFSET,\r\ncopy_skb->data, len);\r\nskb = copy_skb;\r\n}\r\nskb_checksum_none_assert(skb);\r\nskb->protocol = eth_type_trans(skb, bp->dev);\r\nnetif_receive_skb(skb);\r\nreceived++;\r\nbudget--;\r\nnext_pkt:\r\nbp->rx_prod = (bp->rx_prod + 1) &\r\n(B44_RX_RING_SIZE - 1);\r\ncons = (cons + 1) & (B44_RX_RING_SIZE - 1);\r\n}\r\nbp->rx_cons = cons;\r\nbw32(bp, B44_DMARX_PTR, cons * sizeof(struct dma_desc));\r\nreturn received;\r\n}\r\nstatic int b44_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct b44 *bp = container_of(napi, struct b44, napi);\r\nint work_done;\r\nunsigned long flags;\r\nspin_lock_irqsave(&bp->lock, flags);\r\nif (bp->istat & (ISTAT_TX | ISTAT_TO)) {\r\nb44_tx(bp);\r\n}\r\nif (bp->istat & ISTAT_RFO) {\r\nbp->istat &= ~ISTAT_RFO;\r\nb44_disable_ints(bp);\r\nssb_device_enable(bp->sdev, 0);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET_SKIP_PHY);\r\nnetif_wake_queue(bp->dev);\r\n}\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nwork_done = 0;\r\nif (bp->istat & ISTAT_RX)\r\nwork_done += b44_rx(bp, budget);\r\nif (bp->istat & ISTAT_ERRORS) {\r\nspin_lock_irqsave(&bp->lock, flags);\r\nb44_halt(bp);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET_SKIP_PHY);\r\nnetif_wake_queue(bp->dev);\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nwork_done = 0;\r\n}\r\nif (work_done < budget) {\r\nnapi_complete_done(napi, work_done);\r\nb44_enable_ints(bp);\r\n}\r\nreturn work_done;\r\n}\r\nstatic irqreturn_t b44_interrupt(int irq, void *dev_id)\r\n{\r\nstruct net_device *dev = dev_id;\r\nstruct b44 *bp = netdev_priv(dev);\r\nu32 istat, imask;\r\nint handled = 0;\r\nspin_lock(&bp->lock);\r\nistat = br32(bp, B44_ISTAT);\r\nimask = br32(bp, B44_IMASK);\r\nistat &= imask;\r\nif (istat) {\r\nhandled = 1;\r\nif (unlikely(!netif_running(dev))) {\r\nnetdev_info(dev, "late interrupt\n");\r\ngoto irq_ack;\r\n}\r\nif (napi_schedule_prep(&bp->napi)) {\r\nbp->istat = istat;\r\n__b44_disable_ints(bp);\r\n__napi_schedule(&bp->napi);\r\n}\r\nirq_ack:\r\nbw32(bp, B44_ISTAT, istat);\r\nbr32(bp, B44_ISTAT);\r\n}\r\nspin_unlock(&bp->lock);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void b44_tx_timeout(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nnetdev_err(dev, "transmit timed out, resetting\n");\r\nspin_lock_irq(&bp->lock);\r\nb44_halt(bp);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET);\r\nspin_unlock_irq(&bp->lock);\r\nb44_enable_ints(bp);\r\nnetif_wake_queue(dev);\r\n}\r\nstatic netdev_tx_t b44_start_xmit(struct sk_buff *skb, struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nint rc = NETDEV_TX_OK;\r\ndma_addr_t mapping;\r\nu32 len, entry, ctrl;\r\nunsigned long flags;\r\nlen = skb->len;\r\nspin_lock_irqsave(&bp->lock, flags);\r\nif (unlikely(TX_BUFFS_AVAIL(bp) < 1)) {\r\nnetif_stop_queue(dev);\r\nnetdev_err(dev, "BUG! Tx Ring full when queue awake!\n");\r\ngoto err_out;\r\n}\r\nmapping = dma_map_single(bp->sdev->dma_dev, skb->data, len, DMA_TO_DEVICE);\r\nif (dma_mapping_error(bp->sdev->dma_dev, mapping) || mapping + len > DMA_BIT_MASK(30)) {\r\nstruct sk_buff *bounce_skb;\r\nif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\r\ndma_unmap_single(bp->sdev->dma_dev, mapping, len,\r\nDMA_TO_DEVICE);\r\nbounce_skb = alloc_skb(len, GFP_ATOMIC | GFP_DMA);\r\nif (!bounce_skb)\r\ngoto err_out;\r\nmapping = dma_map_single(bp->sdev->dma_dev, bounce_skb->data,\r\nlen, DMA_TO_DEVICE);\r\nif (dma_mapping_error(bp->sdev->dma_dev, mapping) || mapping + len > DMA_BIT_MASK(30)) {\r\nif (!dma_mapping_error(bp->sdev->dma_dev, mapping))\r\ndma_unmap_single(bp->sdev->dma_dev, mapping,\r\nlen, DMA_TO_DEVICE);\r\ndev_kfree_skb_any(bounce_skb);\r\ngoto err_out;\r\n}\r\nskb_copy_from_linear_data(skb, skb_put(bounce_skb, len), len);\r\ndev_kfree_skb_any(skb);\r\nskb = bounce_skb;\r\n}\r\nentry = bp->tx_prod;\r\nbp->tx_buffers[entry].skb = skb;\r\nbp->tx_buffers[entry].mapping = mapping;\r\nctrl = (len & DESC_CTRL_LEN);\r\nctrl |= DESC_CTRL_IOC | DESC_CTRL_SOF | DESC_CTRL_EOF;\r\nif (entry == (B44_TX_RING_SIZE - 1))\r\nctrl |= DESC_CTRL_EOT;\r\nbp->tx_ring[entry].ctrl = cpu_to_le32(ctrl);\r\nbp->tx_ring[entry].addr = cpu_to_le32((u32) mapping+bp->dma_offset);\r\nif (bp->flags & B44_FLAG_TX_RING_HACK)\r\nb44_sync_dma_desc_for_device(bp->sdev, bp->tx_ring_dma,\r\nentry * sizeof(bp->tx_ring[0]),\r\nDMA_TO_DEVICE);\r\nentry = NEXT_TX(entry);\r\nbp->tx_prod = entry;\r\nwmb();\r\nbw32(bp, B44_DMATX_PTR, entry * sizeof(struct dma_desc));\r\nif (bp->flags & B44_FLAG_BUGGY_TXPTR)\r\nbw32(bp, B44_DMATX_PTR, entry * sizeof(struct dma_desc));\r\nif (bp->flags & B44_FLAG_REORDER_BUG)\r\nbr32(bp, B44_DMATX_PTR);\r\nnetdev_sent_queue(dev, skb->len);\r\nif (TX_BUFFS_AVAIL(bp) < 1)\r\nnetif_stop_queue(dev);\r\nout_unlock:\r\nspin_unlock_irqrestore(&bp->lock, flags);\r\nreturn rc;\r\nerr_out:\r\nrc = NETDEV_TX_BUSY;\r\ngoto out_unlock;\r\n}\r\nstatic int b44_change_mtu(struct net_device *dev, int new_mtu)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nif (!netif_running(dev)) {\r\ndev->mtu = new_mtu;\r\nreturn 0;\r\n}\r\nspin_lock_irq(&bp->lock);\r\nb44_halt(bp);\r\ndev->mtu = new_mtu;\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET);\r\nspin_unlock_irq(&bp->lock);\r\nb44_enable_ints(bp);\r\nreturn 0;\r\n}\r\nstatic void b44_free_rings(struct b44 *bp)\r\n{\r\nstruct ring_info *rp;\r\nint i;\r\nfor (i = 0; i < B44_RX_RING_SIZE; i++) {\r\nrp = &bp->rx_buffers[i];\r\nif (rp->skb == NULL)\r\ncontinue;\r\ndma_unmap_single(bp->sdev->dma_dev, rp->mapping, RX_PKT_BUF_SZ,\r\nDMA_FROM_DEVICE);\r\ndev_kfree_skb_any(rp->skb);\r\nrp->skb = NULL;\r\n}\r\nfor (i = 0; i < B44_TX_RING_SIZE; i++) {\r\nrp = &bp->tx_buffers[i];\r\nif (rp->skb == NULL)\r\ncontinue;\r\ndma_unmap_single(bp->sdev->dma_dev, rp->mapping, rp->skb->len,\r\nDMA_TO_DEVICE);\r\ndev_kfree_skb_any(rp->skb);\r\nrp->skb = NULL;\r\n}\r\n}\r\nstatic void b44_init_rings(struct b44 *bp)\r\n{\r\nint i;\r\nb44_free_rings(bp);\r\nmemset(bp->rx_ring, 0, B44_RX_RING_BYTES);\r\nmemset(bp->tx_ring, 0, B44_TX_RING_BYTES);\r\nif (bp->flags & B44_FLAG_RX_RING_HACK)\r\ndma_sync_single_for_device(bp->sdev->dma_dev, bp->rx_ring_dma,\r\nDMA_TABLE_BYTES, DMA_BIDIRECTIONAL);\r\nif (bp->flags & B44_FLAG_TX_RING_HACK)\r\ndma_sync_single_for_device(bp->sdev->dma_dev, bp->tx_ring_dma,\r\nDMA_TABLE_BYTES, DMA_TO_DEVICE);\r\nfor (i = 0; i < bp->rx_pending; i++) {\r\nif (b44_alloc_rx_skb(bp, -1, i) < 0)\r\nbreak;\r\n}\r\n}\r\nstatic void b44_free_consistent(struct b44 *bp)\r\n{\r\nkfree(bp->rx_buffers);\r\nbp->rx_buffers = NULL;\r\nkfree(bp->tx_buffers);\r\nbp->tx_buffers = NULL;\r\nif (bp->rx_ring) {\r\nif (bp->flags & B44_FLAG_RX_RING_HACK) {\r\ndma_unmap_single(bp->sdev->dma_dev, bp->rx_ring_dma,\r\nDMA_TABLE_BYTES, DMA_BIDIRECTIONAL);\r\nkfree(bp->rx_ring);\r\n} else\r\ndma_free_coherent(bp->sdev->dma_dev, DMA_TABLE_BYTES,\r\nbp->rx_ring, bp->rx_ring_dma);\r\nbp->rx_ring = NULL;\r\nbp->flags &= ~B44_FLAG_RX_RING_HACK;\r\n}\r\nif (bp->tx_ring) {\r\nif (bp->flags & B44_FLAG_TX_RING_HACK) {\r\ndma_unmap_single(bp->sdev->dma_dev, bp->tx_ring_dma,\r\nDMA_TABLE_BYTES, DMA_TO_DEVICE);\r\nkfree(bp->tx_ring);\r\n} else\r\ndma_free_coherent(bp->sdev->dma_dev, DMA_TABLE_BYTES,\r\nbp->tx_ring, bp->tx_ring_dma);\r\nbp->tx_ring = NULL;\r\nbp->flags &= ~B44_FLAG_TX_RING_HACK;\r\n}\r\n}\r\nstatic int b44_alloc_consistent(struct b44 *bp, gfp_t gfp)\r\n{\r\nint size;\r\nsize = B44_RX_RING_SIZE * sizeof(struct ring_info);\r\nbp->rx_buffers = kzalloc(size, gfp);\r\nif (!bp->rx_buffers)\r\ngoto out_err;\r\nsize = B44_TX_RING_SIZE * sizeof(struct ring_info);\r\nbp->tx_buffers = kzalloc(size, gfp);\r\nif (!bp->tx_buffers)\r\ngoto out_err;\r\nsize = DMA_TABLE_BYTES;\r\nbp->rx_ring = dma_alloc_coherent(bp->sdev->dma_dev, size,\r\n&bp->rx_ring_dma, gfp);\r\nif (!bp->rx_ring) {\r\nstruct dma_desc *rx_ring;\r\ndma_addr_t rx_ring_dma;\r\nrx_ring = kzalloc(size, gfp);\r\nif (!rx_ring)\r\ngoto out_err;\r\nrx_ring_dma = dma_map_single(bp->sdev->dma_dev, rx_ring,\r\nDMA_TABLE_BYTES,\r\nDMA_BIDIRECTIONAL);\r\nif (dma_mapping_error(bp->sdev->dma_dev, rx_ring_dma) ||\r\nrx_ring_dma + size > DMA_BIT_MASK(30)) {\r\nkfree(rx_ring);\r\ngoto out_err;\r\n}\r\nbp->rx_ring = rx_ring;\r\nbp->rx_ring_dma = rx_ring_dma;\r\nbp->flags |= B44_FLAG_RX_RING_HACK;\r\n}\r\nbp->tx_ring = dma_alloc_coherent(bp->sdev->dma_dev, size,\r\n&bp->tx_ring_dma, gfp);\r\nif (!bp->tx_ring) {\r\nstruct dma_desc *tx_ring;\r\ndma_addr_t tx_ring_dma;\r\ntx_ring = kzalloc(size, gfp);\r\nif (!tx_ring)\r\ngoto out_err;\r\ntx_ring_dma = dma_map_single(bp->sdev->dma_dev, tx_ring,\r\nDMA_TABLE_BYTES,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(bp->sdev->dma_dev, tx_ring_dma) ||\r\ntx_ring_dma + size > DMA_BIT_MASK(30)) {\r\nkfree(tx_ring);\r\ngoto out_err;\r\n}\r\nbp->tx_ring = tx_ring;\r\nbp->tx_ring_dma = tx_ring_dma;\r\nbp->flags |= B44_FLAG_TX_RING_HACK;\r\n}\r\nreturn 0;\r\nout_err:\r\nb44_free_consistent(bp);\r\nreturn -ENOMEM;\r\n}\r\nstatic void b44_clear_stats(struct b44 *bp)\r\n{\r\nunsigned long reg;\r\nbw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);\r\nfor (reg = B44_TX_GOOD_O; reg <= B44_TX_PAUSE; reg += 4UL)\r\nbr32(bp, reg);\r\nfor (reg = B44_RX_GOOD_O; reg <= B44_RX_NPAUSE; reg += 4UL)\r\nbr32(bp, reg);\r\n}\r\nstatic void b44_chip_reset(struct b44 *bp, int reset_kind)\r\n{\r\nstruct ssb_device *sdev = bp->sdev;\r\nbool was_enabled;\r\nwas_enabled = ssb_device_is_enabled(bp->sdev);\r\nssb_device_enable(bp->sdev, 0);\r\nssb_pcicore_dev_irqvecs_enable(&sdev->bus->pcicore, sdev);\r\nif (was_enabled) {\r\nbw32(bp, B44_RCV_LAZY, 0);\r\nbw32(bp, B44_ENET_CTRL, ENET_CTRL_DISABLE);\r\nb44_wait_bit(bp, B44_ENET_CTRL, ENET_CTRL_DISABLE, 200, 1);\r\nbw32(bp, B44_DMATX_CTRL, 0);\r\nbp->tx_prod = bp->tx_cons = 0;\r\nif (br32(bp, B44_DMARX_STAT) & DMARX_STAT_EMASK) {\r\nb44_wait_bit(bp, B44_DMARX_STAT, DMARX_STAT_SIDLE,\r\n100, 0);\r\n}\r\nbw32(bp, B44_DMARX_CTRL, 0);\r\nbp->rx_prod = bp->rx_cons = 0;\r\n}\r\nb44_clear_stats(bp);\r\nif (reset_kind == B44_CHIP_RESET_PARTIAL)\r\nreturn;\r\nswitch (sdev->bus->bustype) {\r\ncase SSB_BUSTYPE_SSB:\r\nbw32(bp, B44_MDIO_CTRL, (MDIO_CTRL_PREAMBLE |\r\n(DIV_ROUND_CLOSEST(ssb_clockspeed(sdev->bus),\r\nB44_MDC_RATIO)\r\n& MDIO_CTRL_MAXF_MASK)));\r\nbreak;\r\ncase SSB_BUSTYPE_PCI:\r\nbw32(bp, B44_MDIO_CTRL, (MDIO_CTRL_PREAMBLE |\r\n(0x0d & MDIO_CTRL_MAXF_MASK)));\r\nbreak;\r\ncase SSB_BUSTYPE_PCMCIA:\r\ncase SSB_BUSTYPE_SDIO:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\nbr32(bp, B44_MDIO_CTRL);\r\nif (!(br32(bp, B44_DEVCTRL) & DEVCTRL_IPP)) {\r\nbw32(bp, B44_ENET_CTRL, ENET_CTRL_EPSEL);\r\nbr32(bp, B44_ENET_CTRL);\r\nbp->flags |= B44_FLAG_EXTERNAL_PHY;\r\n} else {\r\nu32 val = br32(bp, B44_DEVCTRL);\r\nif (val & DEVCTRL_EPR) {\r\nbw32(bp, B44_DEVCTRL, (val & ~DEVCTRL_EPR));\r\nbr32(bp, B44_DEVCTRL);\r\nudelay(100);\r\n}\r\nbp->flags &= ~B44_FLAG_EXTERNAL_PHY;\r\n}\r\n}\r\nstatic void b44_halt(struct b44 *bp)\r\n{\r\nb44_disable_ints(bp);\r\nb44_phy_reset(bp);\r\nnetdev_info(bp->dev, "powering down PHY\n");\r\nbw32(bp, B44_MAC_CTRL, MAC_CTRL_PHY_PDOWN);\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nb44_chip_reset(bp, B44_CHIP_RESET_FULL);\r\nelse\r\nb44_chip_reset(bp, B44_CHIP_RESET_PARTIAL);\r\n}\r\nstatic void __b44_set_mac_addr(struct b44 *bp)\r\n{\r\nbw32(bp, B44_CAM_CTRL, 0);\r\nif (!(bp->dev->flags & IFF_PROMISC)) {\r\nu32 val;\r\n__b44_cam_write(bp, bp->dev->dev_addr, 0);\r\nval = br32(bp, B44_CAM_CTRL);\r\nbw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);\r\n}\r\n}\r\nstatic int b44_set_mac_addr(struct net_device *dev, void *p)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nstruct sockaddr *addr = p;\r\nu32 val;\r\nif (netif_running(dev))\r\nreturn -EBUSY;\r\nif (!is_valid_ether_addr(addr->sa_data))\r\nreturn -EINVAL;\r\nmemcpy(dev->dev_addr, addr->sa_data, dev->addr_len);\r\nspin_lock_irq(&bp->lock);\r\nval = br32(bp, B44_RXCONFIG);\r\nif (!(val & RXCONFIG_CAM_ABSENT))\r\n__b44_set_mac_addr(bp);\r\nspin_unlock_irq(&bp->lock);\r\nreturn 0;\r\n}\r\nstatic void b44_init_hw(struct b44 *bp, int reset_kind)\r\n{\r\nu32 val;\r\nb44_chip_reset(bp, B44_CHIP_RESET_FULL);\r\nif (reset_kind == B44_FULL_RESET) {\r\nb44_phy_reset(bp);\r\nb44_setup_phy(bp);\r\n}\r\nbw32(bp, B44_MAC_CTRL, MAC_CTRL_CRC32_ENAB | MAC_CTRL_PHY_LEDCTRL);\r\nbw32(bp, B44_RCV_LAZY, (1 << RCV_LAZY_FC_SHIFT));\r\n__b44_set_rx_mode(bp->dev);\r\nbw32(bp, B44_RXMAXLEN, bp->dev->mtu + ETH_HLEN + 8 + RX_HEADER_LEN);\r\nbw32(bp, B44_TXMAXLEN, bp->dev->mtu + ETH_HLEN + 8 + RX_HEADER_LEN);\r\nbw32(bp, B44_TX_WMARK, 56);\r\nif (reset_kind == B44_PARTIAL_RESET) {\r\nbw32(bp, B44_DMARX_CTRL, (DMARX_CTRL_ENABLE |\r\n(RX_PKT_OFFSET << DMARX_CTRL_ROSHIFT)));\r\n} else {\r\nbw32(bp, B44_DMATX_CTRL, DMATX_CTRL_ENABLE);\r\nbw32(bp, B44_DMATX_ADDR, bp->tx_ring_dma + bp->dma_offset);\r\nbw32(bp, B44_DMARX_CTRL, (DMARX_CTRL_ENABLE |\r\n(RX_PKT_OFFSET << DMARX_CTRL_ROSHIFT)));\r\nbw32(bp, B44_DMARX_ADDR, bp->rx_ring_dma + bp->dma_offset);\r\nbw32(bp, B44_DMARX_PTR, bp->rx_pending);\r\nbp->rx_prod = bp->rx_pending;\r\nbw32(bp, B44_MIB_CTRL, MIB_CTRL_CLR_ON_READ);\r\n}\r\nval = br32(bp, B44_ENET_CTRL);\r\nbw32(bp, B44_ENET_CTRL, (val | ENET_CTRL_ENABLE));\r\nnetdev_reset_queue(bp->dev);\r\n}\r\nstatic int b44_open(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nint err;\r\nerr = b44_alloc_consistent(bp, GFP_KERNEL);\r\nif (err)\r\ngoto out;\r\nnapi_enable(&bp->napi);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET);\r\nb44_check_phy(bp);\r\nerr = request_irq(dev->irq, b44_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (unlikely(err < 0)) {\r\nnapi_disable(&bp->napi);\r\nb44_chip_reset(bp, B44_CHIP_RESET_PARTIAL);\r\nb44_free_rings(bp);\r\nb44_free_consistent(bp);\r\ngoto out;\r\n}\r\ninit_timer(&bp->timer);\r\nbp->timer.expires = jiffies + HZ;\r\nbp->timer.data = (unsigned long) bp;\r\nbp->timer.function = b44_timer;\r\nadd_timer(&bp->timer);\r\nb44_enable_ints(bp);\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nphy_start(dev->phydev);\r\nnetif_start_queue(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic void b44_poll_controller(struct net_device *dev)\r\n{\r\ndisable_irq(dev->irq);\r\nb44_interrupt(dev->irq, dev);\r\nenable_irq(dev->irq);\r\n}\r\nstatic void bwfilter_table(struct b44 *bp, u8 *pp, u32 bytes, u32 table_offset)\r\n{\r\nu32 i;\r\nu32 *pattern = (u32 *) pp;\r\nfor (i = 0; i < bytes; i += sizeof(u32)) {\r\nbw32(bp, B44_FILT_ADDR, table_offset + i);\r\nbw32(bp, B44_FILT_DATA, pattern[i / sizeof(u32)]);\r\n}\r\n}\r\nstatic int b44_magic_pattern(u8 *macaddr, u8 *ppattern, u8 *pmask, int offset)\r\n{\r\nint magicsync = 6;\r\nint k, j, len = offset;\r\nint ethaddr_bytes = ETH_ALEN;\r\nmemset(ppattern + offset, 0xff, magicsync);\r\nfor (j = 0; j < magicsync; j++)\r\nset_bit(len++, (unsigned long *) pmask);\r\nfor (j = 0; j < B44_MAX_PATTERNS; j++) {\r\nif ((B44_PATTERN_SIZE - len) >= ETH_ALEN)\r\nethaddr_bytes = ETH_ALEN;\r\nelse\r\nethaddr_bytes = B44_PATTERN_SIZE - len;\r\nif (ethaddr_bytes <=0)\r\nbreak;\r\nfor (k = 0; k< ethaddr_bytes; k++) {\r\nppattern[offset + magicsync +\r\n(j * ETH_ALEN) + k] = macaddr[k];\r\nset_bit(len++, (unsigned long *) pmask);\r\n}\r\n}\r\nreturn len - 1;\r\n}\r\nstatic void b44_setup_pseudo_magicp(struct b44 *bp)\r\n{\r\nu32 val;\r\nint plen0, plen1, plen2;\r\nu8 *pwol_pattern;\r\nu8 pwol_mask[B44_PMASK_SIZE];\r\npwol_pattern = kzalloc(B44_PATTERN_SIZE, GFP_KERNEL);\r\nif (!pwol_pattern)\r\nreturn;\r\nmemset(pwol_mask, 0, B44_PMASK_SIZE);\r\nplen0 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,\r\nB44_ETHIPV4UDP_HLEN);\r\nbwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE, B44_PATTERN_BASE);\r\nbwfilter_table(bp, pwol_mask, B44_PMASK_SIZE, B44_PMASK_BASE);\r\nmemset(pwol_pattern, 0, B44_PATTERN_SIZE);\r\nmemset(pwol_mask, 0, B44_PMASK_SIZE);\r\nplen1 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,\r\nETH_HLEN);\r\nbwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE,\r\nB44_PATTERN_BASE + B44_PATTERN_SIZE);\r\nbwfilter_table(bp, pwol_mask, B44_PMASK_SIZE,\r\nB44_PMASK_BASE + B44_PMASK_SIZE);\r\nmemset(pwol_pattern, 0, B44_PATTERN_SIZE);\r\nmemset(pwol_mask, 0, B44_PMASK_SIZE);\r\nplen2 = b44_magic_pattern(bp->dev->dev_addr, pwol_pattern, pwol_mask,\r\nB44_ETHIPV6UDP_HLEN);\r\nbwfilter_table(bp, pwol_pattern, B44_PATTERN_SIZE,\r\nB44_PATTERN_BASE + B44_PATTERN_SIZE + B44_PATTERN_SIZE);\r\nbwfilter_table(bp, pwol_mask, B44_PMASK_SIZE,\r\nB44_PMASK_BASE + B44_PMASK_SIZE + B44_PMASK_SIZE);\r\nkfree(pwol_pattern);\r\nval = plen0 | (plen1 << 8) | (plen2 << 16) | WKUP_LEN_ENABLE_THREE;\r\nbw32(bp, B44_WKUP_LEN, val);\r\nval = br32(bp, B44_DEVCTRL);\r\nbw32(bp, B44_DEVCTRL, val | DEVCTRL_PFE);\r\n}\r\nstatic void b44_setup_wol_pci(struct b44 *bp)\r\n{\r\nu16 val;\r\nif (bp->sdev->bus->bustype != SSB_BUSTYPE_SSB) {\r\nbw32(bp, SSB_TMSLOW, br32(bp, SSB_TMSLOW) | SSB_TMSLOW_PE);\r\npci_read_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, &val);\r\npci_write_config_word(bp->sdev->bus->host_pci, SSB_PMCSR, val | SSB_PE);\r\n}\r\n}\r\nstatic inline void b44_setup_wol_pci(struct b44 *bp) { }\r\nstatic void b44_setup_wol(struct b44 *bp)\r\n{\r\nu32 val;\r\nbw32(bp, B44_RXCONFIG, RXCONFIG_ALLMULTI);\r\nif (bp->flags & B44_FLAG_B0_ANDLATER) {\r\nbw32(bp, B44_WKUP_LEN, WKUP_LEN_DISABLE);\r\nval = bp->dev->dev_addr[2] << 24 |\r\nbp->dev->dev_addr[3] << 16 |\r\nbp->dev->dev_addr[4] << 8 |\r\nbp->dev->dev_addr[5];\r\nbw32(bp, B44_ADDR_LO, val);\r\nval = bp->dev->dev_addr[0] << 8 |\r\nbp->dev->dev_addr[1];\r\nbw32(bp, B44_ADDR_HI, val);\r\nval = br32(bp, B44_DEVCTRL);\r\nbw32(bp, B44_DEVCTRL, val | DEVCTRL_MPM | DEVCTRL_PFE);\r\n} else {\r\nb44_setup_pseudo_magicp(bp);\r\n}\r\nb44_setup_wol_pci(bp);\r\n}\r\nstatic int b44_close(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nnetif_stop_queue(dev);\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nphy_stop(dev->phydev);\r\nnapi_disable(&bp->napi);\r\ndel_timer_sync(&bp->timer);\r\nspin_lock_irq(&bp->lock);\r\nb44_halt(bp);\r\nb44_free_rings(bp);\r\nnetif_carrier_off(dev);\r\nspin_unlock_irq(&bp->lock);\r\nfree_irq(dev->irq, dev);\r\nif (bp->flags & B44_FLAG_WOL_ENABLE) {\r\nb44_init_hw(bp, B44_PARTIAL_RESET);\r\nb44_setup_wol(bp);\r\n}\r\nb44_free_consistent(bp);\r\nreturn 0;\r\n}\r\nstatic void b44_get_stats64(struct net_device *dev,\r\nstruct rtnl_link_stats64 *nstat)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nstruct b44_hw_stats *hwstat = &bp->hw_stats;\r\nunsigned int start;\r\ndo {\r\nstart = u64_stats_fetch_begin_irq(&hwstat->syncp);\r\nnstat->rx_packets = hwstat->rx_pkts;\r\nnstat->tx_packets = hwstat->tx_pkts;\r\nnstat->rx_bytes = hwstat->rx_octets;\r\nnstat->tx_bytes = hwstat->tx_octets;\r\nnstat->tx_errors = (hwstat->tx_jabber_pkts +\r\nhwstat->tx_oversize_pkts +\r\nhwstat->tx_underruns +\r\nhwstat->tx_excessive_cols +\r\nhwstat->tx_late_cols);\r\nnstat->multicast = hwstat->rx_multicast_pkts;\r\nnstat->collisions = hwstat->tx_total_cols;\r\nnstat->rx_length_errors = (hwstat->rx_oversize_pkts +\r\nhwstat->rx_undersize);\r\nnstat->rx_over_errors = hwstat->rx_missed_pkts;\r\nnstat->rx_frame_errors = hwstat->rx_align_errs;\r\nnstat->rx_crc_errors = hwstat->rx_crc_errs;\r\nnstat->rx_errors = (hwstat->rx_jabber_pkts +\r\nhwstat->rx_oversize_pkts +\r\nhwstat->rx_missed_pkts +\r\nhwstat->rx_crc_align_errs +\r\nhwstat->rx_undersize +\r\nhwstat->rx_crc_errs +\r\nhwstat->rx_align_errs +\r\nhwstat->rx_symbol_errs);\r\nnstat->tx_aborted_errors = hwstat->tx_underruns;\r\n#if 0\r\nnstat->tx_carrier_errors = hwstat->tx_carrier_lost;\r\n#endif\r\n} while (u64_stats_fetch_retry_irq(&hwstat->syncp, start));\r\n}\r\nstatic int __b44_load_mcast(struct b44 *bp, struct net_device *dev)\r\n{\r\nstruct netdev_hw_addr *ha;\r\nint i, num_ents;\r\nnum_ents = min_t(int, netdev_mc_count(dev), B44_MCAST_TABLE_SIZE);\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, dev) {\r\nif (i == num_ents)\r\nbreak;\r\n__b44_cam_write(bp, ha->addr, i++ + 1);\r\n}\r\nreturn i+1;\r\n}\r\nstatic void __b44_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nu32 val;\r\nval = br32(bp, B44_RXCONFIG);\r\nval &= ~(RXCONFIG_PROMISC | RXCONFIG_ALLMULTI);\r\nif ((dev->flags & IFF_PROMISC) || (val & RXCONFIG_CAM_ABSENT)) {\r\nval |= RXCONFIG_PROMISC;\r\nbw32(bp, B44_RXCONFIG, val);\r\n} else {\r\nunsigned char zero[6] = {0, 0, 0, 0, 0, 0};\r\nint i = 1;\r\n__b44_set_mac_addr(bp);\r\nif ((dev->flags & IFF_ALLMULTI) ||\r\n(netdev_mc_count(dev) > B44_MCAST_TABLE_SIZE))\r\nval |= RXCONFIG_ALLMULTI;\r\nelse\r\ni = __b44_load_mcast(bp, dev);\r\nfor (; i < 64; i++)\r\n__b44_cam_write(bp, zero, i);\r\nbw32(bp, B44_RXCONFIG, val);\r\nval = br32(bp, B44_CAM_CTRL);\r\nbw32(bp, B44_CAM_CTRL, val | CAM_CTRL_ENABLE);\r\n}\r\n}\r\nstatic void b44_set_rx_mode(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nspin_lock_irq(&bp->lock);\r\n__b44_set_rx_mode(dev);\r\nspin_unlock_irq(&bp->lock);\r\n}\r\nstatic u32 b44_get_msglevel(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nreturn bp->msg_enable;\r\n}\r\nstatic void b44_set_msglevel(struct net_device *dev, u32 value)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nbp->msg_enable = value;\r\n}\r\nstatic void b44_get_drvinfo (struct net_device *dev, struct ethtool_drvinfo *info)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nstruct ssb_bus *bus = bp->sdev->bus;\r\nstrlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));\r\nstrlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));\r\nswitch (bus->bustype) {\r\ncase SSB_BUSTYPE_PCI:\r\nstrlcpy(info->bus_info, pci_name(bus->host_pci), sizeof(info->bus_info));\r\nbreak;\r\ncase SSB_BUSTYPE_SSB:\r\nstrlcpy(info->bus_info, "SSB", sizeof(info->bus_info));\r\nbreak;\r\ncase SSB_BUSTYPE_PCMCIA:\r\ncase SSB_BUSTYPE_SDIO:\r\nWARN_ON(1);\r\nbreak;\r\n}\r\n}\r\nstatic int b44_nway_reset(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nu32 bmcr;\r\nint r;\r\nspin_lock_irq(&bp->lock);\r\nb44_readphy(bp, MII_BMCR, &bmcr);\r\nb44_readphy(bp, MII_BMCR, &bmcr);\r\nr = -EINVAL;\r\nif (bmcr & BMCR_ANENABLE) {\r\nb44_writephy(bp, MII_BMCR,\r\nbmcr | BMCR_ANRESTART);\r\nr = 0;\r\n}\r\nspin_unlock_irq(&bp->lock);\r\nreturn r;\r\n}\r\nstatic int b44_get_link_ksettings(struct net_device *dev,\r\nstruct ethtool_link_ksettings *cmd)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nu32 supported, advertising;\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\r\nBUG_ON(!dev->phydev);\r\nreturn phy_ethtool_ksettings_get(dev->phydev, cmd);\r\n}\r\nsupported = (SUPPORTED_Autoneg);\r\nsupported |= (SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_10baseT_Half |\r\nSUPPORTED_10baseT_Full |\r\nSUPPORTED_MII);\r\nadvertising = 0;\r\nif (bp->flags & B44_FLAG_ADV_10HALF)\r\nadvertising |= ADVERTISED_10baseT_Half;\r\nif (bp->flags & B44_FLAG_ADV_10FULL)\r\nadvertising |= ADVERTISED_10baseT_Full;\r\nif (bp->flags & B44_FLAG_ADV_100HALF)\r\nadvertising |= ADVERTISED_100baseT_Half;\r\nif (bp->flags & B44_FLAG_ADV_100FULL)\r\nadvertising |= ADVERTISED_100baseT_Full;\r\nadvertising |= ADVERTISED_Pause | ADVERTISED_Asym_Pause;\r\ncmd->base.speed = (bp->flags & B44_FLAG_100_BASE_T) ?\r\nSPEED_100 : SPEED_10;\r\ncmd->base.duplex = (bp->flags & B44_FLAG_FULL_DUPLEX) ?\r\nDUPLEX_FULL : DUPLEX_HALF;\r\ncmd->base.port = 0;\r\ncmd->base.phy_address = bp->phy_addr;\r\ncmd->base.autoneg = (bp->flags & B44_FLAG_FORCE_LINK) ?\r\nAUTONEG_DISABLE : AUTONEG_ENABLE;\r\nif (cmd->base.autoneg == AUTONEG_ENABLE)\r\nadvertising |= ADVERTISED_Autoneg;\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.supported,\r\nsupported);\r\nethtool_convert_legacy_u32_to_link_mode(cmd->link_modes.advertising,\r\nadvertising);\r\nif (!netif_running(dev)){\r\ncmd->base.speed = 0;\r\ncmd->base.duplex = 0xff;\r\n}\r\nreturn 0;\r\n}\r\nstatic int b44_set_link_ksettings(struct net_device *dev,\r\nconst struct ethtool_link_ksettings *cmd)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nu32 speed;\r\nint ret;\r\nu32 advertising;\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\r\nBUG_ON(!dev->phydev);\r\nspin_lock_irq(&bp->lock);\r\nif (netif_running(dev))\r\nb44_setup_phy(bp);\r\nret = phy_ethtool_ksettings_set(dev->phydev, cmd);\r\nspin_unlock_irq(&bp->lock);\r\nreturn ret;\r\n}\r\nspeed = cmd->base.speed;\r\nethtool_convert_link_mode_to_legacy_u32(&advertising,\r\ncmd->link_modes.advertising);\r\nif (cmd->base.autoneg == AUTONEG_ENABLE) {\r\nif (advertising &\r\n(ADVERTISED_1000baseT_Half |\r\nADVERTISED_1000baseT_Full))\r\nreturn -EINVAL;\r\n} else if ((speed != SPEED_100 &&\r\nspeed != SPEED_10) ||\r\n(cmd->base.duplex != DUPLEX_HALF &&\r\ncmd->base.duplex != DUPLEX_FULL)) {\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irq(&bp->lock);\r\nif (cmd->base.autoneg == AUTONEG_ENABLE) {\r\nbp->flags &= ~(B44_FLAG_FORCE_LINK |\r\nB44_FLAG_100_BASE_T |\r\nB44_FLAG_FULL_DUPLEX |\r\nB44_FLAG_ADV_10HALF |\r\nB44_FLAG_ADV_10FULL |\r\nB44_FLAG_ADV_100HALF |\r\nB44_FLAG_ADV_100FULL);\r\nif (advertising == 0) {\r\nbp->flags |= (B44_FLAG_ADV_10HALF |\r\nB44_FLAG_ADV_10FULL |\r\nB44_FLAG_ADV_100HALF |\r\nB44_FLAG_ADV_100FULL);\r\n} else {\r\nif (advertising & ADVERTISED_10baseT_Half)\r\nbp->flags |= B44_FLAG_ADV_10HALF;\r\nif (advertising & ADVERTISED_10baseT_Full)\r\nbp->flags |= B44_FLAG_ADV_10FULL;\r\nif (advertising & ADVERTISED_100baseT_Half)\r\nbp->flags |= B44_FLAG_ADV_100HALF;\r\nif (advertising & ADVERTISED_100baseT_Full)\r\nbp->flags |= B44_FLAG_ADV_100FULL;\r\n}\r\n} else {\r\nbp->flags |= B44_FLAG_FORCE_LINK;\r\nbp->flags &= ~(B44_FLAG_100_BASE_T | B44_FLAG_FULL_DUPLEX);\r\nif (speed == SPEED_100)\r\nbp->flags |= B44_FLAG_100_BASE_T;\r\nif (cmd->base.duplex == DUPLEX_FULL)\r\nbp->flags |= B44_FLAG_FULL_DUPLEX;\r\n}\r\nif (netif_running(dev))\r\nb44_setup_phy(bp);\r\nspin_unlock_irq(&bp->lock);\r\nreturn 0;\r\n}\r\nstatic void b44_get_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nering->rx_max_pending = B44_RX_RING_SIZE - 1;\r\nering->rx_pending = bp->rx_pending;\r\n}\r\nstatic int b44_set_ringparam(struct net_device *dev,\r\nstruct ethtool_ringparam *ering)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nif ((ering->rx_pending > B44_RX_RING_SIZE - 1) ||\r\n(ering->rx_mini_pending != 0) ||\r\n(ering->rx_jumbo_pending != 0) ||\r\n(ering->tx_pending > B44_TX_RING_SIZE - 1))\r\nreturn -EINVAL;\r\nspin_lock_irq(&bp->lock);\r\nbp->rx_pending = ering->rx_pending;\r\nbp->tx_pending = ering->tx_pending;\r\nb44_halt(bp);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET);\r\nnetif_wake_queue(bp->dev);\r\nspin_unlock_irq(&bp->lock);\r\nb44_enable_ints(bp);\r\nreturn 0;\r\n}\r\nstatic void b44_get_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nepause->autoneg =\r\n(bp->flags & B44_FLAG_PAUSE_AUTO) != 0;\r\nepause->rx_pause =\r\n(bp->flags & B44_FLAG_RX_PAUSE) != 0;\r\nepause->tx_pause =\r\n(bp->flags & B44_FLAG_TX_PAUSE) != 0;\r\n}\r\nstatic int b44_set_pauseparam(struct net_device *dev,\r\nstruct ethtool_pauseparam *epause)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nspin_lock_irq(&bp->lock);\r\nif (epause->autoneg)\r\nbp->flags |= B44_FLAG_PAUSE_AUTO;\r\nelse\r\nbp->flags &= ~B44_FLAG_PAUSE_AUTO;\r\nif (epause->rx_pause)\r\nbp->flags |= B44_FLAG_RX_PAUSE;\r\nelse\r\nbp->flags &= ~B44_FLAG_RX_PAUSE;\r\nif (epause->tx_pause)\r\nbp->flags |= B44_FLAG_TX_PAUSE;\r\nelse\r\nbp->flags &= ~B44_FLAG_TX_PAUSE;\r\nif (bp->flags & B44_FLAG_PAUSE_AUTO) {\r\nb44_halt(bp);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET);\r\n} else {\r\n__b44_set_flow_ctrl(bp, bp->flags);\r\n}\r\nspin_unlock_irq(&bp->lock);\r\nb44_enable_ints(bp);\r\nreturn 0;\r\n}\r\nstatic void b44_get_strings(struct net_device *dev, u32 stringset, u8 *data)\r\n{\r\nswitch(stringset) {\r\ncase ETH_SS_STATS:\r\nmemcpy(data, *b44_gstrings, sizeof(b44_gstrings));\r\nbreak;\r\n}\r\n}\r\nstatic int b44_get_sset_count(struct net_device *dev, int sset)\r\n{\r\nswitch (sset) {\r\ncase ETH_SS_STATS:\r\nreturn ARRAY_SIZE(b44_gstrings);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic void b44_get_ethtool_stats(struct net_device *dev,\r\nstruct ethtool_stats *stats, u64 *data)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nstruct b44_hw_stats *hwstat = &bp->hw_stats;\r\nu64 *data_src, *data_dst;\r\nunsigned int start;\r\nu32 i;\r\nspin_lock_irq(&bp->lock);\r\nb44_stats_update(bp);\r\nspin_unlock_irq(&bp->lock);\r\ndo {\r\ndata_src = &hwstat->tx_good_octets;\r\ndata_dst = data;\r\nstart = u64_stats_fetch_begin_irq(&hwstat->syncp);\r\nfor (i = 0; i < ARRAY_SIZE(b44_gstrings); i++)\r\n*data_dst++ = *data_src++;\r\n} while (u64_stats_fetch_retry_irq(&hwstat->syncp, start));\r\n}\r\nstatic void b44_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nwol->supported = WAKE_MAGIC;\r\nif (bp->flags & B44_FLAG_WOL_ENABLE)\r\nwol->wolopts = WAKE_MAGIC;\r\nelse\r\nwol->wolopts = 0;\r\nmemset(&wol->sopass, 0, sizeof(wol->sopass));\r\n}\r\nstatic int b44_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nspin_lock_irq(&bp->lock);\r\nif (wol->wolopts & WAKE_MAGIC)\r\nbp->flags |= B44_FLAG_WOL_ENABLE;\r\nelse\r\nbp->flags &= ~B44_FLAG_WOL_ENABLE;\r\nspin_unlock_irq(&bp->lock);\r\ndevice_set_wakeup_enable(bp->sdev->dev, wol->wolopts & WAKE_MAGIC);\r\nreturn 0;\r\n}\r\nstatic int b44_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nint err = -EINVAL;\r\nif (!netif_running(dev))\r\ngoto out;\r\nspin_lock_irq(&bp->lock);\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\r\nBUG_ON(!dev->phydev);\r\nerr = phy_mii_ioctl(dev->phydev, ifr, cmd);\r\n} else {\r\nerr = generic_mii_ioctl(&bp->mii_if, if_mii(ifr), cmd, NULL);\r\n}\r\nspin_unlock_irq(&bp->lock);\r\nout:\r\nreturn err;\r\n}\r\nstatic int b44_get_invariants(struct b44 *bp)\r\n{\r\nstruct ssb_device *sdev = bp->sdev;\r\nint err = 0;\r\nu8 *addr;\r\nbp->dma_offset = ssb_dma_translation(sdev);\r\nif (sdev->bus->bustype == SSB_BUSTYPE_SSB &&\r\ninstance > 1) {\r\naddr = sdev->bus->sprom.et1mac;\r\nbp->phy_addr = sdev->bus->sprom.et1phyaddr;\r\n} else {\r\naddr = sdev->bus->sprom.et0mac;\r\nbp->phy_addr = sdev->bus->sprom.et0phyaddr;\r\n}\r\nbp->phy_addr &= 0x1F;\r\nmemcpy(bp->dev->dev_addr, addr, ETH_ALEN);\r\nif (!is_valid_ether_addr(&bp->dev->dev_addr[0])){\r\npr_err("Invalid MAC address found in EEPROM\n");\r\nreturn -EINVAL;\r\n}\r\nbp->imask = IMASK_DEF;\r\nif (bp->sdev->id.revision >= 7)\r\nbp->flags |= B44_FLAG_B0_ANDLATER;\r\nreturn err;\r\n}\r\nstatic void b44_adjust_link(struct net_device *dev)\r\n{\r\nstruct b44 *bp = netdev_priv(dev);\r\nstruct phy_device *phydev = dev->phydev;\r\nbool status_changed = 0;\r\nBUG_ON(!phydev);\r\nif (bp->old_link != phydev->link) {\r\nstatus_changed = 1;\r\nbp->old_link = phydev->link;\r\n}\r\nif (phydev->link) {\r\nif ((phydev->duplex == DUPLEX_HALF) &&\r\n(bp->flags & B44_FLAG_FULL_DUPLEX)) {\r\nstatus_changed = 1;\r\nbp->flags &= ~B44_FLAG_FULL_DUPLEX;\r\n} else if ((phydev->duplex == DUPLEX_FULL) &&\r\n!(bp->flags & B44_FLAG_FULL_DUPLEX)) {\r\nstatus_changed = 1;\r\nbp->flags |= B44_FLAG_FULL_DUPLEX;\r\n}\r\n}\r\nif (status_changed) {\r\nu32 val = br32(bp, B44_TX_CTRL);\r\nif (bp->flags & B44_FLAG_FULL_DUPLEX)\r\nval |= TX_CTRL_DUPLEX;\r\nelse\r\nval &= ~TX_CTRL_DUPLEX;\r\nbw32(bp, B44_TX_CTRL, val);\r\nphy_print_status(phydev);\r\n}\r\n}\r\nstatic int b44_register_phy_one(struct b44 *bp)\r\n{\r\nstruct mii_bus *mii_bus;\r\nstruct ssb_device *sdev = bp->sdev;\r\nstruct phy_device *phydev;\r\nchar bus_id[MII_BUS_ID_SIZE + 3];\r\nstruct ssb_sprom *sprom = &sdev->bus->sprom;\r\nint err;\r\nmii_bus = mdiobus_alloc();\r\nif (!mii_bus) {\r\ndev_err(sdev->dev, "mdiobus_alloc() failed\n");\r\nerr = -ENOMEM;\r\ngoto err_out;\r\n}\r\nmii_bus->priv = bp;\r\nmii_bus->read = b44_mdio_read_phylib;\r\nmii_bus->write = b44_mdio_write_phylib;\r\nmii_bus->name = "b44_eth_mii";\r\nmii_bus->parent = sdev->dev;\r\nmii_bus->phy_mask = ~(1 << bp->phy_addr);\r\nsnprintf(mii_bus->id, MII_BUS_ID_SIZE, "%x", instance);\r\nbp->mii_bus = mii_bus;\r\nerr = mdiobus_register(mii_bus);\r\nif (err) {\r\ndev_err(sdev->dev, "failed to register MII bus\n");\r\ngoto err_out_mdiobus;\r\n}\r\nif (!mdiobus_is_registered_device(bp->mii_bus, bp->phy_addr) &&\r\n(sprom->boardflags_lo & (B44_BOARDFLAG_ROBO | B44_BOARDFLAG_ADM))) {\r\ndev_info(sdev->dev,\r\n"could not find PHY at %i, use fixed one\n",\r\nbp->phy_addr);\r\nbp->phy_addr = 0;\r\nsnprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, "fixed-0",\r\nbp->phy_addr);\r\n} else {\r\nsnprintf(bus_id, sizeof(bus_id), PHY_ID_FMT, mii_bus->id,\r\nbp->phy_addr);\r\n}\r\nphydev = phy_connect(bp->dev, bus_id, &b44_adjust_link,\r\nPHY_INTERFACE_MODE_MII);\r\nif (IS_ERR(phydev)) {\r\ndev_err(sdev->dev, "could not attach PHY at %i\n",\r\nbp->phy_addr);\r\nerr = PTR_ERR(phydev);\r\ngoto err_out_mdiobus_unregister;\r\n}\r\nphydev->supported &= (SUPPORTED_100baseT_Half |\r\nSUPPORTED_100baseT_Full |\r\nSUPPORTED_Autoneg |\r\nSUPPORTED_MII);\r\nphydev->advertising = phydev->supported;\r\nbp->old_link = 0;\r\nbp->phy_addr = phydev->mdio.addr;\r\nphy_attached_info(phydev);\r\nreturn 0;\r\nerr_out_mdiobus_unregister:\r\nmdiobus_unregister(mii_bus);\r\nerr_out_mdiobus:\r\nmdiobus_free(mii_bus);\r\nerr_out:\r\nreturn err;\r\n}\r\nstatic void b44_unregister_phy_one(struct b44 *bp)\r\n{\r\nstruct net_device *dev = bp->dev;\r\nstruct mii_bus *mii_bus = bp->mii_bus;\r\nphy_disconnect(dev->phydev);\r\nmdiobus_unregister(mii_bus);\r\nmdiobus_free(mii_bus);\r\n}\r\nstatic int b44_init_one(struct ssb_device *sdev,\r\nconst struct ssb_device_id *ent)\r\n{\r\nstruct net_device *dev;\r\nstruct b44 *bp;\r\nint err;\r\ninstance++;\r\npr_info_once("%s version %s\n", DRV_DESCRIPTION, DRV_MODULE_VERSION);\r\ndev = alloc_etherdev(sizeof(*bp));\r\nif (!dev) {\r\nerr = -ENOMEM;\r\ngoto out;\r\n}\r\nSET_NETDEV_DEV(dev, sdev->dev);\r\ndev->features |= 0;\r\nbp = netdev_priv(dev);\r\nbp->sdev = sdev;\r\nbp->dev = dev;\r\nbp->force_copybreak = 0;\r\nbp->msg_enable = netif_msg_init(b44_debug, B44_DEF_MSG_ENABLE);\r\nspin_lock_init(&bp->lock);\r\nbp->rx_pending = B44_DEF_RX_RING_PENDING;\r\nbp->tx_pending = B44_DEF_TX_RING_PENDING;\r\ndev->netdev_ops = &b44_netdev_ops;\r\nnetif_napi_add(dev, &bp->napi, b44_poll, 64);\r\ndev->watchdog_timeo = B44_TX_TIMEOUT;\r\ndev->min_mtu = B44_MIN_MTU;\r\ndev->max_mtu = B44_MAX_MTU;\r\ndev->irq = sdev->irq;\r\ndev->ethtool_ops = &b44_ethtool_ops;\r\nerr = ssb_bus_powerup(sdev->bus, 0);\r\nif (err) {\r\ndev_err(sdev->dev,\r\n"Failed to powerup the bus\n");\r\ngoto err_out_free_dev;\r\n}\r\nif (dma_set_mask_and_coherent(sdev->dma_dev, DMA_BIT_MASK(30))) {\r\ndev_err(sdev->dev,\r\n"Required 30BIT DMA mask unsupported by the system\n");\r\ngoto err_out_powerdown;\r\n}\r\nerr = b44_get_invariants(bp);\r\nif (err) {\r\ndev_err(sdev->dev,\r\n"Problem fetching invariants of chip, aborting\n");\r\ngoto err_out_powerdown;\r\n}\r\nif (bp->phy_addr == B44_PHY_ADDR_NO_PHY) {\r\ndev_err(sdev->dev, "No PHY present on this MAC, aborting\n");\r\nerr = -ENODEV;\r\ngoto err_out_powerdown;\r\n}\r\nbp->mii_if.dev = dev;\r\nbp->mii_if.mdio_read = b44_mdio_read_mii;\r\nbp->mii_if.mdio_write = b44_mdio_write_mii;\r\nbp->mii_if.phy_id = bp->phy_addr;\r\nbp->mii_if.phy_id_mask = 0x1f;\r\nbp->mii_if.reg_num_mask = 0x1f;\r\nbp->flags |= (B44_FLAG_ADV_10HALF | B44_FLAG_ADV_10FULL |\r\nB44_FLAG_ADV_100HALF | B44_FLAG_ADV_100FULL);\r\nbp->flags |= B44_FLAG_PAUSE_AUTO;\r\nerr = register_netdev(dev);\r\nif (err) {\r\ndev_err(sdev->dev, "Cannot register net device, aborting\n");\r\ngoto err_out_powerdown;\r\n}\r\nnetif_carrier_off(dev);\r\nssb_set_drvdata(sdev, dev);\r\nb44_chip_reset(bp, B44_CHIP_RESET_FULL);\r\nerr = b44_phy_reset(bp);\r\nif (err < 0) {\r\ndev_err(sdev->dev, "phy reset failed\n");\r\ngoto err_out_unregister_netdev;\r\n}\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY) {\r\nerr = b44_register_phy_one(bp);\r\nif (err) {\r\ndev_err(sdev->dev, "Cannot register PHY, aborting\n");\r\ngoto err_out_unregister_netdev;\r\n}\r\n}\r\ndevice_set_wakeup_capable(sdev->dev, true);\r\nnetdev_info(dev, "%s %pM\n", DRV_DESCRIPTION, dev->dev_addr);\r\nreturn 0;\r\nerr_out_unregister_netdev:\r\nunregister_netdev(dev);\r\nerr_out_powerdown:\r\nssb_bus_may_powerdown(sdev->bus);\r\nerr_out_free_dev:\r\nnetif_napi_del(&bp->napi);\r\nfree_netdev(dev);\r\nout:\r\nreturn err;\r\n}\r\nstatic void b44_remove_one(struct ssb_device *sdev)\r\n{\r\nstruct net_device *dev = ssb_get_drvdata(sdev);\r\nstruct b44 *bp = netdev_priv(dev);\r\nunregister_netdev(dev);\r\nif (bp->flags & B44_FLAG_EXTERNAL_PHY)\r\nb44_unregister_phy_one(bp);\r\nssb_device_disable(sdev, 0);\r\nssb_bus_may_powerdown(sdev->bus);\r\nnetif_napi_del(&bp->napi);\r\nfree_netdev(dev);\r\nssb_pcihost_set_power_state(sdev, PCI_D3hot);\r\nssb_set_drvdata(sdev, NULL);\r\n}\r\nstatic int b44_suspend(struct ssb_device *sdev, pm_message_t state)\r\n{\r\nstruct net_device *dev = ssb_get_drvdata(sdev);\r\nstruct b44 *bp = netdev_priv(dev);\r\nif (!netif_running(dev))\r\nreturn 0;\r\ndel_timer_sync(&bp->timer);\r\nspin_lock_irq(&bp->lock);\r\nb44_halt(bp);\r\nnetif_carrier_off(bp->dev);\r\nnetif_device_detach(bp->dev);\r\nb44_free_rings(bp);\r\nspin_unlock_irq(&bp->lock);\r\nfree_irq(dev->irq, dev);\r\nif (bp->flags & B44_FLAG_WOL_ENABLE) {\r\nb44_init_hw(bp, B44_PARTIAL_RESET);\r\nb44_setup_wol(bp);\r\n}\r\nssb_pcihost_set_power_state(sdev, PCI_D3hot);\r\nreturn 0;\r\n}\r\nstatic int b44_resume(struct ssb_device *sdev)\r\n{\r\nstruct net_device *dev = ssb_get_drvdata(sdev);\r\nstruct b44 *bp = netdev_priv(dev);\r\nint rc = 0;\r\nrc = ssb_bus_powerup(sdev->bus, 0);\r\nif (rc) {\r\ndev_err(sdev->dev,\r\n"Failed to powerup the bus\n");\r\nreturn rc;\r\n}\r\nif (!netif_running(dev))\r\nreturn 0;\r\nspin_lock_irq(&bp->lock);\r\nb44_init_rings(bp);\r\nb44_init_hw(bp, B44_FULL_RESET);\r\nspin_unlock_irq(&bp->lock);\r\nrc = request_irq(dev->irq, b44_interrupt, IRQF_SHARED, dev->name, dev);\r\nif (rc) {\r\nnetdev_err(dev, "request_irq failed\n");\r\nspin_lock_irq(&bp->lock);\r\nb44_halt(bp);\r\nb44_free_rings(bp);\r\nspin_unlock_irq(&bp->lock);\r\nreturn rc;\r\n}\r\nnetif_device_attach(bp->dev);\r\nb44_enable_ints(bp);\r\nnetif_wake_queue(dev);\r\nmod_timer(&bp->timer, jiffies + 1);\r\nreturn 0;\r\n}\r\nstatic inline int __init b44_pci_init(void)\r\n{\r\nint err = 0;\r\n#ifdef CONFIG_B44_PCI\r\nerr = ssb_pcihost_register(&b44_pci_driver);\r\n#endif\r\nreturn err;\r\n}\r\nstatic inline void b44_pci_exit(void)\r\n{\r\n#ifdef CONFIG_B44_PCI\r\nssb_pcihost_unregister(&b44_pci_driver);\r\n#endif\r\n}\r\nstatic int __init b44_init(void)\r\n{\r\nunsigned int dma_desc_align_size = dma_get_cache_alignment();\r\nint err;\r\ndma_desc_sync_size = max_t(unsigned int, dma_desc_align_size, sizeof(struct dma_desc));\r\nerr = b44_pci_init();\r\nif (err)\r\nreturn err;\r\nerr = ssb_driver_register(&b44_ssb_driver);\r\nif (err)\r\nb44_pci_exit();\r\nreturn err;\r\n}\r\nstatic void __exit b44_cleanup(void)\r\n{\r\nssb_driver_unregister(&b44_ssb_driver);\r\nb44_pci_exit();\r\n}
