static int pch_ptp_match(struct sk_buff *skb, u16 uid_hi, u32 uid_lo, u16 seqid)\r\n{\r\nu8 *data = skb->data;\r\nunsigned int offset;\r\nu16 *hi, *id;\r\nu32 lo;\r\nif (ptp_classify_raw(skb) == PTP_CLASS_NONE)\r\nreturn 0;\r\noffset = ETH_HLEN + IPV4_HLEN(data) + UDP_HLEN;\r\nif (skb->len < offset + OFF_PTP_SEQUENCE_ID + sizeof(seqid))\r\nreturn 0;\r\nhi = (u16 *)(data + offset + OFF_PTP_SOURCE_UUID);\r\nid = (u16 *)(data + offset + OFF_PTP_SEQUENCE_ID);\r\nmemcpy(&lo, &hi[1], sizeof(lo));\r\nreturn (uid_hi == *hi &&\r\nuid_lo == lo &&\r\nseqid == *id);\r\n}\r\nstatic void\r\npch_rx_timestamp(struct pch_gbe_adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct skb_shared_hwtstamps *shhwtstamps;\r\nstruct pci_dev *pdev;\r\nu64 ns;\r\nu32 hi, lo, val;\r\nu16 uid, seq;\r\nif (!adapter->hwts_rx_en)\r\nreturn;\r\npdev = adapter->ptp_pdev;\r\nval = pch_ch_event_read(pdev);\r\nif (!(val & RX_SNAPSHOT_LOCKED))\r\nreturn;\r\nlo = pch_src_uuid_lo_read(pdev);\r\nhi = pch_src_uuid_hi_read(pdev);\r\nuid = hi & 0xffff;\r\nseq = (hi >> 16) & 0xffff;\r\nif (!pch_ptp_match(skb, htons(uid), htonl(lo), htons(seq)))\r\ngoto out;\r\nns = pch_rx_snap_read(pdev);\r\nshhwtstamps = skb_hwtstamps(skb);\r\nmemset(shhwtstamps, 0, sizeof(*shhwtstamps));\r\nshhwtstamps->hwtstamp = ns_to_ktime(ns);\r\nout:\r\npch_ch_event_write(pdev, RX_SNAPSHOT_LOCKED);\r\n}\r\nstatic void\r\npch_tx_timestamp(struct pch_gbe_adapter *adapter, struct sk_buff *skb)\r\n{\r\nstruct skb_shared_hwtstamps shhwtstamps;\r\nstruct pci_dev *pdev;\r\nstruct skb_shared_info *shtx;\r\nu64 ns;\r\nu32 cnt, val;\r\nshtx = skb_shinfo(skb);\r\nif (likely(!(shtx->tx_flags & SKBTX_HW_TSTAMP && adapter->hwts_tx_en)))\r\nreturn;\r\nshtx->tx_flags |= SKBTX_IN_PROGRESS;\r\npdev = adapter->ptp_pdev;\r\nfor (cnt = 0; cnt < 100; cnt++) {\r\nval = pch_ch_event_read(pdev);\r\nif (val & TX_SNAPSHOT_LOCKED)\r\nbreak;\r\nudelay(1);\r\n}\r\nif (!(val & TX_SNAPSHOT_LOCKED)) {\r\nshtx->tx_flags &= ~SKBTX_IN_PROGRESS;\r\nreturn;\r\n}\r\nns = pch_tx_snap_read(pdev);\r\nmemset(&shhwtstamps, 0, sizeof(shhwtstamps));\r\nshhwtstamps.hwtstamp = ns_to_ktime(ns);\r\nskb_tstamp_tx(skb, &shhwtstamps);\r\npch_ch_event_write(pdev, TX_SNAPSHOT_LOCKED);\r\n}\r\nstatic int hwtstamp_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct hwtstamp_config cfg;\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pci_dev *pdev;\r\nu8 station[20];\r\nif (copy_from_user(&cfg, ifr->ifr_data, sizeof(cfg)))\r\nreturn -EFAULT;\r\nif (cfg.flags)\r\nreturn -EINVAL;\r\npdev = adapter->ptp_pdev;\r\nif (cfg.tx_type != HWTSTAMP_TX_OFF && cfg.tx_type != HWTSTAMP_TX_ON)\r\nreturn -ERANGE;\r\nswitch (cfg.rx_filter) {\r\ncase HWTSTAMP_FILTER_NONE:\r\nadapter->hwts_rx_en = 0;\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_SYNC:\r\nadapter->hwts_rx_en = 0;\r\npch_ch_control_write(pdev, SLAVE_MODE | CAP_MODE0);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ:\r\nadapter->hwts_rx_en = 1;\r\npch_ch_control_write(pdev, MASTER_MODE | CAP_MODE0);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L4_EVENT:\r\nadapter->hwts_rx_en = 1;\r\npch_ch_control_write(pdev, V2_MODE | CAP_MODE2);\r\nstrcpy(station, PTP_L4_MULTICAST_SA);\r\npch_set_station_address(station, pdev);\r\nbreak;\r\ncase HWTSTAMP_FILTER_PTP_V2_L2_EVENT:\r\nadapter->hwts_rx_en = 1;\r\npch_ch_control_write(pdev, V2_MODE | CAP_MODE2);\r\nstrcpy(station, PTP_L2_MULTICAST_SA);\r\npch_set_station_address(station, pdev);\r\nbreak;\r\ndefault:\r\nreturn -ERANGE;\r\n}\r\nadapter->hwts_tx_en = cfg.tx_type == HWTSTAMP_TX_ON;\r\npch_ch_event_write(pdev, TX_SNAPSHOT_LOCKED | RX_SNAPSHOT_LOCKED);\r\nreturn copy_to_user(ifr->ifr_data, &cfg, sizeof(cfg)) ? -EFAULT : 0;\r\n}\r\nstatic inline void pch_gbe_mac_load_mac_addr(struct pch_gbe_hw *hw)\r\n{\r\niowrite32(0x01, &hw->reg->MAC_ADDR_LOAD);\r\n}\r\ns32 pch_gbe_mac_read_mac_addr(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nu32 adr1a, adr1b;\r\nadr1a = ioread32(&hw->reg->mac_adr[0].high);\r\nadr1b = ioread32(&hw->reg->mac_adr[0].low);\r\nhw->mac.addr[0] = (u8)(adr1a & 0xFF);\r\nhw->mac.addr[1] = (u8)((adr1a >> 8) & 0xFF);\r\nhw->mac.addr[2] = (u8)((adr1a >> 16) & 0xFF);\r\nhw->mac.addr[3] = (u8)((adr1a >> 24) & 0xFF);\r\nhw->mac.addr[4] = (u8)(adr1b & 0xFF);\r\nhw->mac.addr[5] = (u8)((adr1b >> 8) & 0xFF);\r\nnetdev_dbg(adapter->netdev, "hw->mac.addr : %pM\n", hw->mac.addr);\r\nreturn 0;\r\n}\r\nstatic void pch_gbe_wait_clr_bit(void *reg, u32 bit)\r\n{\r\nu32 tmp;\r\ntmp = 1000;\r\nwhile ((ioread32(reg) & bit) && --tmp)\r\ncpu_relax();\r\nif (!tmp)\r\npr_err("Error: busy bit is not cleared\n");\r\n}\r\nstatic void pch_gbe_mac_mar_set(struct pch_gbe_hw *hw, u8 * addr, u32 index)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nu32 mar_low, mar_high, adrmask;\r\nnetdev_dbg(adapter->netdev, "index : 0x%x\n", index);\r\nmar_high = ((u32) addr[0] | ((u32) addr[1] << 8) |\r\n((u32) addr[2] << 16) | ((u32) addr[3] << 24));\r\nmar_low = ((u32) addr[4] | ((u32) addr[5] << 8));\r\nadrmask = ioread32(&hw->reg->ADDR_MASK);\r\niowrite32((adrmask | (0x0001 << index)), &hw->reg->ADDR_MASK);\r\npch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\r\niowrite32(mar_high, &hw->reg->mac_adr[index].high);\r\niowrite32(mar_low, &hw->reg->mac_adr[index].low);\r\niowrite32((adrmask & ~(0x0001 << index)), &hw->reg->ADDR_MASK);\r\npch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\r\n}\r\nstatic void pch_gbe_mac_reset_hw(struct pch_gbe_hw *hw)\r\n{\r\npch_gbe_mac_read_mac_addr(hw);\r\niowrite32(PCH_GBE_ALL_RST, &hw->reg->RESET);\r\n#ifdef PCH_GBE_MAC_IFOP_RGMII\r\niowrite32(PCH_GBE_MODE_GMII_ETHER, &hw->reg->MODE);\r\n#endif\r\npch_gbe_wait_clr_bit(&hw->reg->RESET, PCH_GBE_ALL_RST);\r\npch_gbe_mac_mar_set(hw, hw->mac.addr, 0);\r\nreturn;\r\n}\r\nstatic void pch_gbe_disable_mac_rx(struct pch_gbe_hw *hw)\r\n{\r\nu32 rctl;\r\nrctl = ioread32(&hw->reg->MAC_RX_EN);\r\niowrite32((rctl & ~PCH_GBE_MRE_MAC_RX_EN), &hw->reg->MAC_RX_EN);\r\n}\r\nstatic void pch_gbe_enable_mac_rx(struct pch_gbe_hw *hw)\r\n{\r\nu32 rctl;\r\nrctl = ioread32(&hw->reg->MAC_RX_EN);\r\niowrite32((rctl | PCH_GBE_MRE_MAC_RX_EN), &hw->reg->MAC_RX_EN);\r\n}\r\nstatic void pch_gbe_mac_init_rx_addrs(struct pch_gbe_hw *hw, u16 mar_count)\r\n{\r\nu32 i;\r\npch_gbe_mac_mar_set(hw, hw->mac.addr, 0);\r\nfor (i = 1; i < mar_count; i++) {\r\niowrite32(0, &hw->reg->mac_adr[i].high);\r\niowrite32(0, &hw->reg->mac_adr[i].low);\r\n}\r\niowrite32(0xFFFE, &hw->reg->ADDR_MASK);\r\npch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\r\n}\r\nstatic void pch_gbe_mac_mc_addr_list_update(struct pch_gbe_hw *hw,\r\nu8 *mc_addr_list, u32 mc_addr_count,\r\nu32 mar_used_count, u32 mar_total_num)\r\n{\r\nu32 i, adrmask;\r\nfor (i = mar_used_count; i < mar_total_num; i++) {\r\nif (mc_addr_count) {\r\npch_gbe_mac_mar_set(hw, mc_addr_list, i);\r\nmc_addr_count--;\r\nmc_addr_list += ETH_ALEN;\r\n} else {\r\nadrmask = ioread32(&hw->reg->ADDR_MASK);\r\niowrite32((adrmask | (0x0001 << i)),\r\n&hw->reg->ADDR_MASK);\r\npch_gbe_wait_clr_bit(&hw->reg->ADDR_MASK, PCH_GBE_BUSY);\r\niowrite32(0, &hw->reg->mac_adr[i].high);\r\niowrite32(0, &hw->reg->mac_adr[i].low);\r\n}\r\n}\r\n}\r\ns32 pch_gbe_mac_force_mac_fc(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nstruct pch_gbe_mac_info *mac = &hw->mac;\r\nu32 rx_fctrl;\r\nnetdev_dbg(adapter->netdev, "mac->fc = %u\n", mac->fc);\r\nrx_fctrl = ioread32(&hw->reg->RX_FCTRL);\r\nswitch (mac->fc) {\r\ncase PCH_GBE_FC_NONE:\r\nrx_fctrl &= ~PCH_GBE_FL_CTRL_EN;\r\nmac->tx_fc_enable = false;\r\nbreak;\r\ncase PCH_GBE_FC_RX_PAUSE:\r\nrx_fctrl |= PCH_GBE_FL_CTRL_EN;\r\nmac->tx_fc_enable = false;\r\nbreak;\r\ncase PCH_GBE_FC_TX_PAUSE:\r\nrx_fctrl &= ~PCH_GBE_FL_CTRL_EN;\r\nmac->tx_fc_enable = true;\r\nbreak;\r\ncase PCH_GBE_FC_FULL:\r\nrx_fctrl |= PCH_GBE_FL_CTRL_EN;\r\nmac->tx_fc_enable = true;\r\nbreak;\r\ndefault:\r\nnetdev_err(adapter->netdev,\r\n"Flow control param set incorrectly\n");\r\nreturn -EINVAL;\r\n}\r\nif (mac->link_duplex == DUPLEX_HALF)\r\nrx_fctrl &= ~PCH_GBE_FL_CTRL_EN;\r\niowrite32(rx_fctrl, &hw->reg->RX_FCTRL);\r\nnetdev_dbg(adapter->netdev,\r\n"RX_FCTRL reg : 0x%08x mac->tx_fc_enable : %d\n",\r\nioread32(&hw->reg->RX_FCTRL), mac->tx_fc_enable);\r\nreturn 0;\r\n}\r\nstatic void pch_gbe_mac_set_wol_event(struct pch_gbe_hw *hw, u32 wu_evt)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nu32 addr_mask;\r\nnetdev_dbg(adapter->netdev, "wu_evt : 0x%08x ADDR_MASK reg : 0x%08x\n",\r\nwu_evt, ioread32(&hw->reg->ADDR_MASK));\r\nif (wu_evt) {\r\naddr_mask = ioread32(&hw->reg->ADDR_MASK);\r\niowrite32(addr_mask, &hw->reg->WOL_ADDR_MASK);\r\npch_gbe_wait_clr_bit(&hw->reg->WOL_ADDR_MASK, PCH_GBE_WLA_BUSY);\r\niowrite32(0, &hw->reg->WOL_ST);\r\niowrite32((wu_evt | PCH_GBE_WLC_WOL_MODE), &hw->reg->WOL_CTRL);\r\niowrite32(0x02, &hw->reg->TCPIP_ACC);\r\niowrite32(PCH_GBE_INT_ENABLE_MASK, &hw->reg->INT_EN);\r\n} else {\r\niowrite32(0, &hw->reg->WOL_CTRL);\r\niowrite32(0, &hw->reg->WOL_ST);\r\n}\r\nreturn;\r\n}\r\nu16 pch_gbe_mac_ctrl_miim(struct pch_gbe_hw *hw, u32 addr, u32 dir, u32 reg,\r\nu16 data)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nu32 data_out = 0;\r\nunsigned int i;\r\nunsigned long flags;\r\nspin_lock_irqsave(&hw->miim_lock, flags);\r\nfor (i = 100; i; --i) {\r\nif ((ioread32(&hw->reg->MIIM) & PCH_GBE_MIIM_OPER_READY))\r\nbreak;\r\nudelay(20);\r\n}\r\nif (i == 0) {\r\nnetdev_err(adapter->netdev, "pch-gbe.miim won't go Ready\n");\r\nspin_unlock_irqrestore(&hw->miim_lock, flags);\r\nreturn 0;\r\n}\r\niowrite32(((reg << PCH_GBE_MIIM_REG_ADDR_SHIFT) |\r\n(addr << PCH_GBE_MIIM_PHY_ADDR_SHIFT) |\r\ndir | data), &hw->reg->MIIM);\r\nfor (i = 0; i < 100; i++) {\r\nudelay(20);\r\ndata_out = ioread32(&hw->reg->MIIM);\r\nif ((data_out & PCH_GBE_MIIM_OPER_READY))\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&hw->miim_lock, flags);\r\nnetdev_dbg(adapter->netdev, "PHY %s: reg=%d, data=0x%04X\n",\r\ndir == PCH_GBE_MIIM_OPER_READ ? "READ" : "WRITE", reg,\r\ndir == PCH_GBE_MIIM_OPER_READ ? data_out : data);\r\nreturn (u16) data_out;\r\n}\r\nstatic void pch_gbe_mac_set_pause_packet(struct pch_gbe_hw *hw)\r\n{\r\nstruct pch_gbe_adapter *adapter = pch_gbe_hw_to_adapter(hw);\r\nunsigned long tmp2, tmp3;\r\ntmp2 = hw->mac.addr[1];\r\ntmp2 = (tmp2 << 8) | hw->mac.addr[0];\r\ntmp2 = PCH_GBE_PAUSE_PKT2_VALUE | (tmp2 << 16);\r\ntmp3 = hw->mac.addr[5];\r\ntmp3 = (tmp3 << 8) | hw->mac.addr[4];\r\ntmp3 = (tmp3 << 8) | hw->mac.addr[3];\r\ntmp3 = (tmp3 << 8) | hw->mac.addr[2];\r\niowrite32(PCH_GBE_PAUSE_PKT1_VALUE, &hw->reg->PAUSE_PKT1);\r\niowrite32(tmp2, &hw->reg->PAUSE_PKT2);\r\niowrite32(tmp3, &hw->reg->PAUSE_PKT3);\r\niowrite32(PCH_GBE_PAUSE_PKT4_VALUE, &hw->reg->PAUSE_PKT4);\r\niowrite32(PCH_GBE_PAUSE_PKT5_VALUE, &hw->reg->PAUSE_PKT5);\r\niowrite32(PCH_GBE_PS_PKT_RQ, &hw->reg->PAUSE_REQ);\r\nnetdev_dbg(adapter->netdev,\r\n"PAUSE_PKT1-5 reg : 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",\r\nioread32(&hw->reg->PAUSE_PKT1),\r\nioread32(&hw->reg->PAUSE_PKT2),\r\nioread32(&hw->reg->PAUSE_PKT3),\r\nioread32(&hw->reg->PAUSE_PKT4),\r\nioread32(&hw->reg->PAUSE_PKT5));\r\nreturn;\r\n}\r\nstatic int pch_gbe_alloc_queues(struct pch_gbe_adapter *adapter)\r\n{\r\nadapter->tx_ring = devm_kzalloc(&adapter->pdev->dev,\r\nsizeof(*adapter->tx_ring), GFP_KERNEL);\r\nif (!adapter->tx_ring)\r\nreturn -ENOMEM;\r\nadapter->rx_ring = devm_kzalloc(&adapter->pdev->dev,\r\nsizeof(*adapter->rx_ring), GFP_KERNEL);\r\nif (!adapter->rx_ring)\r\nreturn -ENOMEM;\r\nreturn 0;\r\n}\r\nstatic void pch_gbe_init_stats(struct pch_gbe_adapter *adapter)\r\n{\r\nmemset(&adapter->stats, 0, sizeof(adapter->stats));\r\nreturn;\r\n}\r\nstatic int pch_gbe_init_phy(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nu32 addr;\r\nu16 bmcr, stat;\r\nfor (addr = 0; addr < PCH_GBE_PHY_REGS_LEN; addr++) {\r\nadapter->mii.phy_id = (addr == 0) ? 1 : (addr == 1) ? 0 : addr;\r\nbmcr = pch_gbe_mdio_read(netdev, adapter->mii.phy_id, MII_BMCR);\r\nstat = pch_gbe_mdio_read(netdev, adapter->mii.phy_id, MII_BMSR);\r\nstat = pch_gbe_mdio_read(netdev, adapter->mii.phy_id, MII_BMSR);\r\nif (!((bmcr == 0xFFFF) || ((stat == 0) && (bmcr == 0))))\r\nbreak;\r\n}\r\nadapter->hw.phy.addr = adapter->mii.phy_id;\r\nnetdev_dbg(netdev, "phy_addr = %d\n", adapter->mii.phy_id);\r\nif (addr == PCH_GBE_PHY_REGS_LEN)\r\nreturn -EAGAIN;\r\nfor (addr = 0; addr < PCH_GBE_PHY_REGS_LEN; addr++) {\r\nif (addr != adapter->mii.phy_id) {\r\npch_gbe_mdio_write(netdev, addr, MII_BMCR,\r\nBMCR_ISOLATE);\r\n} else {\r\nbmcr = pch_gbe_mdio_read(netdev, addr, MII_BMCR);\r\npch_gbe_mdio_write(netdev, addr, MII_BMCR,\r\nbmcr & ~BMCR_ISOLATE);\r\n}\r\n}\r\nadapter->mii.phy_id_mask = 0x1F;\r\nadapter->mii.reg_num_mask = 0x1F;\r\nadapter->mii.dev = adapter->netdev;\r\nadapter->mii.mdio_read = pch_gbe_mdio_read;\r\nadapter->mii.mdio_write = pch_gbe_mdio_write;\r\nadapter->mii.supports_gmii = mii_check_gmii_support(&adapter->mii);\r\nreturn 0;\r\n}\r\nstatic int pch_gbe_mdio_read(struct net_device *netdev, int addr, int reg)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nreturn pch_gbe_mac_ctrl_miim(hw, addr, PCH_GBE_HAL_MIIM_READ, reg,\r\n(u16) 0);\r\n}\r\nstatic void pch_gbe_mdio_write(struct net_device *netdev,\r\nint addr, int reg, int data)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\npch_gbe_mac_ctrl_miim(hw, addr, PCH_GBE_HAL_MIIM_WRITE, reg, data);\r\n}\r\nstatic void pch_gbe_reset_task(struct work_struct *work)\r\n{\r\nstruct pch_gbe_adapter *adapter;\r\nadapter = container_of(work, struct pch_gbe_adapter, reset_task);\r\nrtnl_lock();\r\npch_gbe_reinit_locked(adapter);\r\nrtnl_unlock();\r\n}\r\nvoid pch_gbe_reinit_locked(struct pch_gbe_adapter *adapter)\r\n{\r\npch_gbe_down(adapter);\r\npch_gbe_up(adapter);\r\n}\r\nvoid pch_gbe_reset(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\npch_gbe_mac_reset_hw(&adapter->hw);\r\npch_gbe_set_multi(netdev);\r\npch_gbe_mac_init_rx_addrs(&adapter->hw, PCH_GBE_MAR_ENTRIES);\r\nif (pch_gbe_hal_init_hw(&adapter->hw))\r\nnetdev_err(netdev, "Hardware Error\n");\r\n}\r\nstatic void pch_gbe_free_irq(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nfree_irq(adapter->pdev->irq, netdev);\r\nif (adapter->have_msi) {\r\npci_disable_msi(adapter->pdev);\r\nnetdev_dbg(netdev, "call pci_disable_msi\n");\r\n}\r\n}\r\nstatic void pch_gbe_irq_disable(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\natomic_inc(&adapter->irq_sem);\r\niowrite32(0, &hw->reg->INT_EN);\r\nioread32(&hw->reg->INT_ST);\r\nsynchronize_irq(adapter->pdev->irq);\r\nnetdev_dbg(adapter->netdev, "INT_EN reg : 0x%08x\n",\r\nioread32(&hw->reg->INT_EN));\r\n}\r\nstatic void pch_gbe_irq_enable(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nif (likely(atomic_dec_and_test(&adapter->irq_sem)))\r\niowrite32(PCH_GBE_INT_ENABLE_MASK, &hw->reg->INT_EN);\r\nioread32(&hw->reg->INT_ST);\r\nnetdev_dbg(adapter->netdev, "INT_EN reg : 0x%08x\n",\r\nioread32(&hw->reg->INT_EN));\r\n}\r\nstatic void pch_gbe_setup_tctl(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 tx_mode, tcpip;\r\ntx_mode = PCH_GBE_TM_LONG_PKT |\r\nPCH_GBE_TM_ST_AND_FD |\r\nPCH_GBE_TM_SHORT_PKT |\r\nPCH_GBE_TM_TH_TX_STRT_8 |\r\nPCH_GBE_TM_TH_ALM_EMP_4 | PCH_GBE_TM_TH_ALM_FULL_8;\r\niowrite32(tx_mode, &hw->reg->TX_MODE);\r\ntcpip = ioread32(&hw->reg->TCPIP_ACC);\r\ntcpip |= PCH_GBE_TX_TCPIPACC_EN;\r\niowrite32(tcpip, &hw->reg->TCPIP_ACC);\r\nreturn;\r\n}\r\nstatic void pch_gbe_configure_tx(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 tdba, tdlen, dctrl;\r\nnetdev_dbg(adapter->netdev, "dma addr = 0x%08llx size = 0x%08x\n",\r\n(unsigned long long)adapter->tx_ring->dma,\r\nadapter->tx_ring->size);\r\ntdba = adapter->tx_ring->dma;\r\ntdlen = adapter->tx_ring->size - 0x10;\r\niowrite32(tdba, &hw->reg->TX_DSC_BASE);\r\niowrite32(tdlen, &hw->reg->TX_DSC_SIZE);\r\niowrite32(tdba, &hw->reg->TX_DSC_SW_P);\r\ndctrl = ioread32(&hw->reg->DMA_CTRL);\r\ndctrl |= PCH_GBE_TX_DMA_EN;\r\niowrite32(dctrl, &hw->reg->DMA_CTRL);\r\n}\r\nstatic void pch_gbe_setup_rctl(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 rx_mode, tcpip;\r\nrx_mode = PCH_GBE_ADD_FIL_EN | PCH_GBE_MLT_FIL_EN |\r\nPCH_GBE_RH_ALM_EMP_4 | PCH_GBE_RH_ALM_FULL_4 | PCH_GBE_RH_RD_TRG_8;\r\niowrite32(rx_mode, &hw->reg->RX_MODE);\r\ntcpip = ioread32(&hw->reg->TCPIP_ACC);\r\ntcpip |= PCH_GBE_RX_TCPIPACC_OFF;\r\ntcpip &= ~PCH_GBE_RX_TCPIPACC_EN;\r\niowrite32(tcpip, &hw->reg->TCPIP_ACC);\r\nreturn;\r\n}\r\nstatic void pch_gbe_configure_rx(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 rdba, rdlen, rxdma;\r\nnetdev_dbg(adapter->netdev, "dma adr = 0x%08llx size = 0x%08x\n",\r\n(unsigned long long)adapter->rx_ring->dma,\r\nadapter->rx_ring->size);\r\npch_gbe_mac_force_mac_fc(hw);\r\npch_gbe_disable_mac_rx(hw);\r\nrxdma = ioread32(&hw->reg->DMA_CTRL);\r\nrxdma &= ~PCH_GBE_RX_DMA_EN;\r\niowrite32(rxdma, &hw->reg->DMA_CTRL);\r\nnetdev_dbg(adapter->netdev,\r\n"MAC_RX_EN reg = 0x%08x DMA_CTRL reg = 0x%08x\n",\r\nioread32(&hw->reg->MAC_RX_EN),\r\nioread32(&hw->reg->DMA_CTRL));\r\nrdba = adapter->rx_ring->dma;\r\nrdlen = adapter->rx_ring->size - 0x10;\r\niowrite32(rdba, &hw->reg->RX_DSC_BASE);\r\niowrite32(rdlen, &hw->reg->RX_DSC_SIZE);\r\niowrite32((rdba + rdlen), &hw->reg->RX_DSC_SW_P);\r\n}\r\nstatic void pch_gbe_unmap_and_free_tx_resource(\r\nstruct pch_gbe_adapter *adapter, struct pch_gbe_buffer *buffer_info)\r\n{\r\nif (buffer_info->mapped) {\r\ndma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\r\nbuffer_info->length, DMA_TO_DEVICE);\r\nbuffer_info->mapped = false;\r\n}\r\nif (buffer_info->skb) {\r\ndev_kfree_skb_any(buffer_info->skb);\r\nbuffer_info->skb = NULL;\r\n}\r\n}\r\nstatic void pch_gbe_unmap_and_free_rx_resource(\r\nstruct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_buffer *buffer_info)\r\n{\r\nif (buffer_info->mapped) {\r\ndma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\r\nbuffer_info->length, DMA_FROM_DEVICE);\r\nbuffer_info->mapped = false;\r\n}\r\nif (buffer_info->skb) {\r\ndev_kfree_skb_any(buffer_info->skb);\r\nbuffer_info->skb = NULL;\r\n}\r\n}\r\nstatic void pch_gbe_clean_tx_ring(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_tx_ring *tx_ring)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct pch_gbe_buffer *buffer_info;\r\nunsigned long size;\r\nunsigned int i;\r\nfor (i = 0; i < tx_ring->count; i++) {\r\nbuffer_info = &tx_ring->buffer_info[i];\r\npch_gbe_unmap_and_free_tx_resource(adapter, buffer_info);\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"call pch_gbe_unmap_and_free_tx_resource() %d count\n", i);\r\nsize = (unsigned long)sizeof(struct pch_gbe_buffer) * tx_ring->count;\r\nmemset(tx_ring->buffer_info, 0, size);\r\nmemset(tx_ring->desc, 0, tx_ring->size);\r\ntx_ring->next_to_use = 0;\r\ntx_ring->next_to_clean = 0;\r\niowrite32(tx_ring->dma, &hw->reg->TX_DSC_HW_P);\r\niowrite32((tx_ring->size - 0x10), &hw->reg->TX_DSC_SIZE);\r\n}\r\nstatic void\r\npch_gbe_clean_rx_ring(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_rx_ring *rx_ring)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct pch_gbe_buffer *buffer_info;\r\nunsigned long size;\r\nunsigned int i;\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nbuffer_info = &rx_ring->buffer_info[i];\r\npch_gbe_unmap_and_free_rx_resource(adapter, buffer_info);\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"call pch_gbe_unmap_and_free_rx_resource() %d count\n", i);\r\nsize = (unsigned long)sizeof(struct pch_gbe_buffer) * rx_ring->count;\r\nmemset(rx_ring->buffer_info, 0, size);\r\nmemset(rx_ring->desc, 0, rx_ring->size);\r\nrx_ring->next_to_clean = 0;\r\nrx_ring->next_to_use = 0;\r\niowrite32(rx_ring->dma, &hw->reg->RX_DSC_HW_P);\r\niowrite32((rx_ring->size - 0x10), &hw->reg->RX_DSC_SIZE);\r\n}\r\nstatic void pch_gbe_set_rgmii_ctrl(struct pch_gbe_adapter *adapter, u16 speed,\r\nu16 duplex)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nunsigned long rgmii = 0;\r\n#ifdef PCH_GBE_MAC_IFOP_RGMII\r\nswitch (speed) {\r\ncase SPEED_10:\r\nrgmii = (PCH_GBE_RGMII_RATE_2_5M |\r\nPCH_GBE_MAC_RGMII_CTRL_SETTING);\r\nbreak;\r\ncase SPEED_100:\r\nrgmii = (PCH_GBE_RGMII_RATE_25M |\r\nPCH_GBE_MAC_RGMII_CTRL_SETTING);\r\nbreak;\r\ncase SPEED_1000:\r\nrgmii = (PCH_GBE_RGMII_RATE_125M |\r\nPCH_GBE_MAC_RGMII_CTRL_SETTING);\r\nbreak;\r\n}\r\niowrite32(rgmii, &hw->reg->RGMII_CTRL);\r\n#else\r\nrgmii = 0;\r\niowrite32(rgmii, &hw->reg->RGMII_CTRL);\r\n#endif\r\n}\r\nstatic void pch_gbe_set_mode(struct pch_gbe_adapter *adapter, u16 speed,\r\nu16 duplex)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nunsigned long mode = 0;\r\nswitch (speed) {\r\ncase SPEED_10:\r\nmode = PCH_GBE_MODE_MII_ETHER;\r\nnetdev->tx_queue_len = 10;\r\nbreak;\r\ncase SPEED_100:\r\nmode = PCH_GBE_MODE_MII_ETHER;\r\nnetdev->tx_queue_len = 100;\r\nbreak;\r\ncase SPEED_1000:\r\nmode = PCH_GBE_MODE_GMII_ETHER;\r\nbreak;\r\n}\r\nif (duplex == DUPLEX_FULL)\r\nmode |= PCH_GBE_MODE_FULL_DUPLEX;\r\nelse\r\nmode |= PCH_GBE_MODE_HALF_DUPLEX;\r\niowrite32(mode, &hw->reg->MODE);\r\n}\r\nstatic void pch_gbe_watchdog(unsigned long data)\r\n{\r\nstruct pch_gbe_adapter *adapter = (struct pch_gbe_adapter *)data;\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nnetdev_dbg(netdev, "right now = %ld\n", jiffies);\r\npch_gbe_update_stats(adapter);\r\nif ((mii_link_ok(&adapter->mii)) && (!netif_carrier_ok(netdev))) {\r\nstruct ethtool_cmd cmd = { .cmd = ETHTOOL_GSET };\r\nnetdev->tx_queue_len = adapter->tx_queue_len;\r\nif (mii_ethtool_gset(&adapter->mii, &cmd)) {\r\nnetdev_err(netdev, "ethtool get setting Error\n");\r\nmod_timer(&adapter->watchdog_timer,\r\nround_jiffies(jiffies +\r\nPCH_GBE_WATCHDOG_PERIOD));\r\nreturn;\r\n}\r\nhw->mac.link_speed = ethtool_cmd_speed(&cmd);\r\nhw->mac.link_duplex = cmd.duplex;\r\npch_gbe_set_rgmii_ctrl(adapter, hw->mac.link_speed,\r\nhw->mac.link_duplex);\r\npch_gbe_set_mode(adapter, hw->mac.link_speed,\r\nhw->mac.link_duplex);\r\nnetdev_dbg(netdev,\r\n"Link is Up %d Mbps %s-Duplex\n",\r\nhw->mac.link_speed,\r\ncmd.duplex == DUPLEX_FULL ? "Full" : "Half");\r\nnetif_carrier_on(netdev);\r\nnetif_wake_queue(netdev);\r\n} else if ((!mii_link_ok(&adapter->mii)) &&\r\n(netif_carrier_ok(netdev))) {\r\nnetdev_dbg(netdev, "NIC Link is Down\n");\r\nhw->mac.link_speed = SPEED_10;\r\nhw->mac.link_duplex = DUPLEX_HALF;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\n}\r\nmod_timer(&adapter->watchdog_timer,\r\nround_jiffies(jiffies + PCH_GBE_WATCHDOG_PERIOD));\r\n}\r\nstatic void pch_gbe_tx_queue(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_tx_ring *tx_ring,\r\nstruct sk_buff *skb)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct pch_gbe_tx_desc *tx_desc;\r\nstruct pch_gbe_buffer *buffer_info;\r\nstruct sk_buff *tmp_skb;\r\nunsigned int frame_ctrl;\r\nunsigned int ring_num;\r\nframe_ctrl = 0;\r\nif (unlikely(skb->len < PCH_GBE_SHORT_PKT))\r\nframe_ctrl |= PCH_GBE_TXD_CTRL_APAD;\r\nif (skb->ip_summed == CHECKSUM_NONE)\r\nframe_ctrl |= PCH_GBE_TXD_CTRL_TCPIP_ACC_OFF;\r\nif (skb->len < PCH_GBE_SHORT_PKT && skb->ip_summed != CHECKSUM_NONE) {\r\nframe_ctrl |= PCH_GBE_TXD_CTRL_APAD |\r\nPCH_GBE_TXD_CTRL_TCPIP_ACC_OFF;\r\nif (skb->protocol == htons(ETH_P_IP)) {\r\nstruct iphdr *iph = ip_hdr(skb);\r\nunsigned int offset;\r\noffset = skb_transport_offset(skb);\r\nif (iph->protocol == IPPROTO_TCP) {\r\nskb->csum = 0;\r\ntcp_hdr(skb)->check = 0;\r\nskb->csum = skb_checksum(skb, offset,\r\nskb->len - offset, 0);\r\ntcp_hdr(skb)->check =\r\ncsum_tcpudp_magic(iph->saddr,\r\niph->daddr,\r\nskb->len - offset,\r\nIPPROTO_TCP,\r\nskb->csum);\r\n} else if (iph->protocol == IPPROTO_UDP) {\r\nskb->csum = 0;\r\nudp_hdr(skb)->check = 0;\r\nskb->csum =\r\nskb_checksum(skb, offset,\r\nskb->len - offset, 0);\r\nudp_hdr(skb)->check =\r\ncsum_tcpudp_magic(iph->saddr,\r\niph->daddr,\r\nskb->len - offset,\r\nIPPROTO_UDP,\r\nskb->csum);\r\n}\r\n}\r\n}\r\nring_num = tx_ring->next_to_use;\r\nif (unlikely((ring_num + 1) == tx_ring->count))\r\ntx_ring->next_to_use = 0;\r\nelse\r\ntx_ring->next_to_use = ring_num + 1;\r\nbuffer_info = &tx_ring->buffer_info[ring_num];\r\ntmp_skb = buffer_info->skb;\r\nmemcpy(tmp_skb->data, skb->data, ETH_HLEN);\r\ntmp_skb->data[ETH_HLEN] = 0x00;\r\ntmp_skb->data[ETH_HLEN + 1] = 0x00;\r\ntmp_skb->len = skb->len;\r\nmemcpy(&tmp_skb->data[ETH_HLEN + 2], &skb->data[ETH_HLEN],\r\n(skb->len - ETH_HLEN));\r\nbuffer_info->length = tmp_skb->len;\r\nbuffer_info->dma = dma_map_single(&adapter->pdev->dev, tmp_skb->data,\r\nbuffer_info->length,\r\nDMA_TO_DEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {\r\nnetdev_err(adapter->netdev, "TX DMA map failed\n");\r\nbuffer_info->dma = 0;\r\nbuffer_info->time_stamp = 0;\r\ntx_ring->next_to_use = ring_num;\r\nreturn;\r\n}\r\nbuffer_info->mapped = true;\r\nbuffer_info->time_stamp = jiffies;\r\ntx_desc = PCH_GBE_TX_DESC(*tx_ring, ring_num);\r\ntx_desc->buffer_addr = (buffer_info->dma);\r\ntx_desc->length = (tmp_skb->len);\r\ntx_desc->tx_words_eob = ((tmp_skb->len + 3));\r\ntx_desc->tx_frame_ctrl = (frame_ctrl);\r\ntx_desc->gbec_status = (DSC_INIT16);\r\nif (unlikely(++ring_num == tx_ring->count))\r\nring_num = 0;\r\niowrite32(tx_ring->dma +\r\n(int)sizeof(struct pch_gbe_tx_desc) * ring_num,\r\n&hw->reg->TX_DSC_SW_P);\r\npch_tx_timestamp(adapter, skb);\r\ndev_kfree_skb_any(skb);\r\n}\r\nvoid pch_gbe_update_stats(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_hw_stats *stats = &adapter->stats;\r\nunsigned long flags;\r\nif ((pdev->error_state) && (pdev->error_state != pci_channel_io_normal))\r\nreturn;\r\nspin_lock_irqsave(&adapter->stats_lock, flags);\r\nstats->rx_errors = stats->rx_crc_errors + stats->rx_frame_errors;\r\nstats->tx_errors = stats->tx_length_errors +\r\nstats->tx_aborted_errors +\r\nstats->tx_carrier_errors + stats->tx_timeout_count;\r\nnetdev->stats.rx_packets = stats->rx_packets;\r\nnetdev->stats.rx_bytes = stats->rx_bytes;\r\nnetdev->stats.rx_dropped = stats->rx_dropped;\r\nnetdev->stats.tx_packets = stats->tx_packets;\r\nnetdev->stats.tx_bytes = stats->tx_bytes;\r\nnetdev->stats.tx_dropped = stats->tx_dropped;\r\nnetdev->stats.multicast = stats->multicast;\r\nnetdev->stats.collisions = stats->collisions;\r\nnetdev->stats.rx_errors = stats->rx_errors;\r\nnetdev->stats.rx_crc_errors = stats->rx_crc_errors;\r\nnetdev->stats.rx_frame_errors = stats->rx_frame_errors;\r\nnetdev->stats.tx_errors = stats->tx_errors;\r\nnetdev->stats.tx_aborted_errors = stats->tx_aborted_errors;\r\nnetdev->stats.tx_carrier_errors = stats->tx_carrier_errors;\r\nspin_unlock_irqrestore(&adapter->stats_lock, flags);\r\n}\r\nstatic void pch_gbe_disable_dma_rx(struct pch_gbe_hw *hw)\r\n{\r\nu32 rxdma;\r\nrxdma = ioread32(&hw->reg->DMA_CTRL);\r\nrxdma &= ~PCH_GBE_RX_DMA_EN;\r\niowrite32(rxdma, &hw->reg->DMA_CTRL);\r\n}\r\nstatic void pch_gbe_enable_dma_rx(struct pch_gbe_hw *hw)\r\n{\r\nu32 rxdma;\r\nrxdma = ioread32(&hw->reg->DMA_CTRL);\r\nrxdma |= PCH_GBE_RX_DMA_EN;\r\niowrite32(rxdma, &hw->reg->DMA_CTRL);\r\n}\r\nstatic irqreturn_t pch_gbe_intr(int irq, void *data)\r\n{\r\nstruct net_device *netdev = data;\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 int_st;\r\nu32 int_en;\r\nint_st = ioread32(&hw->reg->INT_ST);\r\nint_st = int_st & ioread32(&hw->reg->INT_EN);\r\nif (unlikely(!int_st))\r\nreturn IRQ_NONE;\r\nnetdev_dbg(netdev, "%s occur int_st = 0x%08x\n", __func__, int_st);\r\nif (int_st & PCH_GBE_INT_RX_FRAME_ERR)\r\nadapter->stats.intr_rx_frame_err_count++;\r\nif (int_st & PCH_GBE_INT_RX_FIFO_ERR)\r\nif (!adapter->rx_stop_flag) {\r\nadapter->stats.intr_rx_fifo_err_count++;\r\nnetdev_dbg(netdev, "Rx fifo over run\n");\r\nadapter->rx_stop_flag = true;\r\nint_en = ioread32(&hw->reg->INT_EN);\r\niowrite32((int_en & ~PCH_GBE_INT_RX_FIFO_ERR),\r\n&hw->reg->INT_EN);\r\npch_gbe_disable_dma_rx(&adapter->hw);\r\nint_st |= ioread32(&hw->reg->INT_ST);\r\nint_st = int_st & ioread32(&hw->reg->INT_EN);\r\n}\r\nif (int_st & PCH_GBE_INT_RX_DMA_ERR)\r\nadapter->stats.intr_rx_dma_err_count++;\r\nif (int_st & PCH_GBE_INT_TX_FIFO_ERR)\r\nadapter->stats.intr_tx_fifo_err_count++;\r\nif (int_st & PCH_GBE_INT_TX_DMA_ERR)\r\nadapter->stats.intr_tx_dma_err_count++;\r\nif (int_st & PCH_GBE_INT_TCPIP_ERR)\r\nadapter->stats.intr_tcpip_err_count++;\r\nif ((int_st & PCH_GBE_INT_RX_DSC_EMP)) {\r\nadapter->stats.intr_rx_dsc_empty_count++;\r\nnetdev_dbg(netdev, "Rx descriptor is empty\n");\r\nint_en = ioread32(&hw->reg->INT_EN);\r\niowrite32((int_en & ~PCH_GBE_INT_RX_DSC_EMP), &hw->reg->INT_EN);\r\nif (hw->mac.tx_fc_enable) {\r\npch_gbe_mac_set_pause_packet(hw);\r\n}\r\n}\r\nif ((int_st & (PCH_GBE_INT_RX_DMA_CMPLT | PCH_GBE_INT_TX_CMPLT)) ||\r\n(adapter->rx_stop_flag)) {\r\nif (likely(napi_schedule_prep(&adapter->napi))) {\r\natomic_inc(&adapter->irq_sem);\r\nint_en = ioread32(&hw->reg->INT_EN);\r\nint_en &=\r\n~(PCH_GBE_INT_RX_DMA_CMPLT | PCH_GBE_INT_TX_CMPLT);\r\niowrite32(int_en, &hw->reg->INT_EN);\r\n__napi_schedule(&adapter->napi);\r\n}\r\n}\r\nnetdev_dbg(netdev, "return = 0x%08x INT_EN reg = 0x%08x\n",\r\nIRQ_HANDLED, ioread32(&hw->reg->INT_EN));\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void\r\npch_gbe_alloc_rx_buffers(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_rx_ring *rx_ring, int cleaned_count)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct pch_gbe_rx_desc *rx_desc;\r\nstruct pch_gbe_buffer *buffer_info;\r\nstruct sk_buff *skb;\r\nunsigned int i;\r\nunsigned int bufsz;\r\nbufsz = adapter->rx_buffer_len + NET_IP_ALIGN;\r\ni = rx_ring->next_to_use;\r\nwhile ((cleaned_count--)) {\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nskb = netdev_alloc_skb(netdev, bufsz);\r\nif (unlikely(!skb)) {\r\nadapter->stats.rx_alloc_buff_failed++;\r\nbreak;\r\n}\r\nskb_reserve(skb, NET_IP_ALIGN);\r\nbuffer_info->skb = skb;\r\nbuffer_info->dma = dma_map_single(&pdev->dev,\r\nbuffer_info->rx_buffer,\r\nbuffer_info->length,\r\nDMA_FROM_DEVICE);\r\nif (dma_mapping_error(&adapter->pdev->dev, buffer_info->dma)) {\r\ndev_kfree_skb(skb);\r\nbuffer_info->skb = NULL;\r\nbuffer_info->dma = 0;\r\nadapter->stats.rx_alloc_buff_failed++;\r\nbreak;\r\n}\r\nbuffer_info->mapped = true;\r\nrx_desc = PCH_GBE_RX_DESC(*rx_ring, i);\r\nrx_desc->buffer_addr = (buffer_info->dma);\r\nrx_desc->gbec_status = DSC_INIT16;\r\nnetdev_dbg(netdev,\r\n"i = %d buffer_info->dma = 0x08%llx buffer_info->length = 0x%x\n",\r\ni, (unsigned long long)buffer_info->dma,\r\nbuffer_info->length);\r\nif (unlikely(++i == rx_ring->count))\r\ni = 0;\r\n}\r\nif (likely(rx_ring->next_to_use != i)) {\r\nrx_ring->next_to_use = i;\r\nif (unlikely(i-- == 0))\r\ni = (rx_ring->count - 1);\r\niowrite32(rx_ring->dma +\r\n(int)sizeof(struct pch_gbe_rx_desc) * i,\r\n&hw->reg->RX_DSC_SW_P);\r\n}\r\nreturn;\r\n}\r\nstatic int\r\npch_gbe_alloc_rx_buffers_pool(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_rx_ring *rx_ring, int cleaned_count)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_buffer *buffer_info;\r\nunsigned int i;\r\nunsigned int bufsz;\r\nunsigned int size;\r\nbufsz = adapter->rx_buffer_len;\r\nsize = rx_ring->count * bufsz + PCH_GBE_RESERVE_MEMORY;\r\nrx_ring->rx_buff_pool =\r\ndma_zalloc_coherent(&pdev->dev, size,\r\n&rx_ring->rx_buff_pool_logic, GFP_KERNEL);\r\nif (!rx_ring->rx_buff_pool)\r\nreturn -ENOMEM;\r\nrx_ring->rx_buff_pool_size = size;\r\nfor (i = 0; i < rx_ring->count; i++) {\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nbuffer_info->rx_buffer = rx_ring->rx_buff_pool + bufsz * i;\r\nbuffer_info->length = bufsz;\r\n}\r\nreturn 0;\r\n}\r\nstatic void pch_gbe_alloc_tx_buffers(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_tx_ring *tx_ring)\r\n{\r\nstruct pch_gbe_buffer *buffer_info;\r\nstruct sk_buff *skb;\r\nunsigned int i;\r\nunsigned int bufsz;\r\nstruct pch_gbe_tx_desc *tx_desc;\r\nbufsz =\r\nadapter->hw.mac.max_frame_size + PCH_GBE_DMA_ALIGN + NET_IP_ALIGN;\r\nfor (i = 0; i < tx_ring->count; i++) {\r\nbuffer_info = &tx_ring->buffer_info[i];\r\nskb = netdev_alloc_skb(adapter->netdev, bufsz);\r\nskb_reserve(skb, PCH_GBE_DMA_ALIGN);\r\nbuffer_info->skb = skb;\r\ntx_desc = PCH_GBE_TX_DESC(*tx_ring, i);\r\ntx_desc->gbec_status = (DSC_INIT16);\r\n}\r\nreturn;\r\n}\r\nstatic bool\r\npch_gbe_clean_tx(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_tx_ring *tx_ring)\r\n{\r\nstruct pch_gbe_tx_desc *tx_desc;\r\nstruct pch_gbe_buffer *buffer_info;\r\nstruct sk_buff *skb;\r\nunsigned int i;\r\nunsigned int cleaned_count = 0;\r\nbool cleaned = false;\r\nint unused, thresh;\r\nnetdev_dbg(adapter->netdev, "next_to_clean : %d\n",\r\ntx_ring->next_to_clean);\r\ni = tx_ring->next_to_clean;\r\ntx_desc = PCH_GBE_TX_DESC(*tx_ring, i);\r\nnetdev_dbg(adapter->netdev, "gbec_status:0x%04x dma_status:0x%04x\n",\r\ntx_desc->gbec_status, tx_desc->dma_status);\r\nunused = PCH_GBE_DESC_UNUSED(tx_ring);\r\nthresh = tx_ring->count - PCH_GBE_TX_WEIGHT;\r\nif ((tx_desc->gbec_status == DSC_INIT16) && (unused < thresh))\r\n{\r\nint j, k;\r\nif (unused < 8) {\r\nnetdev_dbg(adapter->netdev,\r\n"clean_tx: transmit queue warning (%x,%x) unused=%d\n",\r\ntx_ring->next_to_clean, tx_ring->next_to_use,\r\nunused);\r\n}\r\nk = i;\r\nfor (j = 0; j < PCH_GBE_TX_WEIGHT; j++)\r\n{\r\ntx_desc = PCH_GBE_TX_DESC(*tx_ring, k);\r\nif (tx_desc->gbec_status != DSC_INIT16) break;\r\nif (++k >= tx_ring->count) k = 0;\r\n}\r\nif (j < PCH_GBE_TX_WEIGHT) {\r\nnetdev_dbg(adapter->netdev,\r\n"clean_tx: unused=%d loops=%d found tx_desc[%x,%x:%x].gbec_status=%04x\n",\r\nunused, j, i, k, tx_ring->next_to_use,\r\ntx_desc->gbec_status);\r\ni = k;\r\n}\r\n}\r\nwhile ((tx_desc->gbec_status & DSC_INIT16) == 0x0000) {\r\nnetdev_dbg(adapter->netdev, "gbec_status:0x%04x\n",\r\ntx_desc->gbec_status);\r\nbuffer_info = &tx_ring->buffer_info[i];\r\nskb = buffer_info->skb;\r\ncleaned = true;\r\nif ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_ABT)) {\r\nadapter->stats.tx_aborted_errors++;\r\nnetdev_err(adapter->netdev, "Transfer Abort Error\n");\r\n} else if ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_CRSER)\r\n) {\r\nadapter->stats.tx_carrier_errors++;\r\nnetdev_err(adapter->netdev,\r\n"Transfer Carrier Sense Error\n");\r\n} else if ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_EXCOL)\r\n) {\r\nadapter->stats.tx_aborted_errors++;\r\nnetdev_err(adapter->netdev,\r\n"Transfer Collision Abort Error\n");\r\n} else if ((tx_desc->gbec_status &\r\n(PCH_GBE_TXD_GMAC_STAT_SNGCOL |\r\nPCH_GBE_TXD_GMAC_STAT_MLTCOL))) {\r\nadapter->stats.collisions++;\r\nadapter->stats.tx_packets++;\r\nadapter->stats.tx_bytes += skb->len;\r\nnetdev_dbg(adapter->netdev, "Transfer Collision\n");\r\n} else if ((tx_desc->gbec_status & PCH_GBE_TXD_GMAC_STAT_CMPLT)\r\n) {\r\nadapter->stats.tx_packets++;\r\nadapter->stats.tx_bytes += skb->len;\r\n}\r\nif (buffer_info->mapped) {\r\nnetdev_dbg(adapter->netdev,\r\n"unmap buffer_info->dma : %d\n", i);\r\ndma_unmap_single(&adapter->pdev->dev, buffer_info->dma,\r\nbuffer_info->length, DMA_TO_DEVICE);\r\nbuffer_info->mapped = false;\r\n}\r\nif (buffer_info->skb) {\r\nnetdev_dbg(adapter->netdev,\r\n"trim buffer_info->skb : %d\n", i);\r\nskb_trim(buffer_info->skb, 0);\r\n}\r\ntx_desc->gbec_status = DSC_INIT16;\r\nif (unlikely(++i == tx_ring->count))\r\ni = 0;\r\ntx_desc = PCH_GBE_TX_DESC(*tx_ring, i);\r\nif (cleaned_count++ == PCH_GBE_TX_WEIGHT) {\r\ncleaned = false;\r\nbreak;\r\n}\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"called pch_gbe_unmap_and_free_tx_resource() %d count\n",\r\ncleaned_count);\r\nif (cleaned_count > 0) {\r\nnetif_tx_lock(adapter->netdev);\r\nif (unlikely(cleaned && (netif_queue_stopped(adapter->netdev))))\r\n{\r\nnetif_wake_queue(adapter->netdev);\r\nadapter->stats.tx_restart_count++;\r\nnetdev_dbg(adapter->netdev, "Tx wake queue\n");\r\n}\r\ntx_ring->next_to_clean = i;\r\nnetdev_dbg(adapter->netdev, "next_to_clean : %d\n",\r\ntx_ring->next_to_clean);\r\nnetif_tx_unlock(adapter->netdev);\r\n}\r\nreturn cleaned;\r\n}\r\nstatic bool\r\npch_gbe_clean_rx(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_rx_ring *rx_ring,\r\nint *work_done, int work_to_do)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_buffer *buffer_info;\r\nstruct pch_gbe_rx_desc *rx_desc;\r\nu32 length;\r\nunsigned int i;\r\nunsigned int cleaned_count = 0;\r\nbool cleaned = false;\r\nstruct sk_buff *skb;\r\nu8 dma_status;\r\nu16 gbec_status;\r\nu32 tcp_ip_status;\r\ni = rx_ring->next_to_clean;\r\nwhile (*work_done < work_to_do) {\r\nrx_desc = PCH_GBE_RX_DESC(*rx_ring, i);\r\nif (rx_desc->gbec_status == DSC_INIT16)\r\nbreak;\r\ncleaned = true;\r\ncleaned_count++;\r\ndma_status = rx_desc->dma_status;\r\ngbec_status = rx_desc->gbec_status;\r\ntcp_ip_status = rx_desc->tcp_ip_status;\r\nrx_desc->gbec_status = DSC_INIT16;\r\nbuffer_info = &rx_ring->buffer_info[i];\r\nskb = buffer_info->skb;\r\nbuffer_info->skb = NULL;\r\ndma_unmap_single(&pdev->dev, buffer_info->dma,\r\nbuffer_info->length, DMA_FROM_DEVICE);\r\nbuffer_info->mapped = false;\r\nnetdev_dbg(netdev,\r\n"RxDecNo = 0x%04x Status[DMA:0x%02x GBE:0x%04x TCP:0x%08x] BufInf = 0x%p\n",\r\ni, dma_status, gbec_status, tcp_ip_status,\r\nbuffer_info);\r\nif (unlikely(gbec_status & PCH_GBE_RXD_GMAC_STAT_NOTOCTAL)) {\r\nadapter->stats.rx_frame_errors++;\r\nnetdev_err(netdev, "Receive Not Octal Error\n");\r\n} else if (unlikely(gbec_status &\r\nPCH_GBE_RXD_GMAC_STAT_NBLERR)) {\r\nadapter->stats.rx_frame_errors++;\r\nnetdev_err(netdev, "Receive Nibble Error\n");\r\n} else if (unlikely(gbec_status &\r\nPCH_GBE_RXD_GMAC_STAT_CRCERR)) {\r\nadapter->stats.rx_crc_errors++;\r\nnetdev_err(netdev, "Receive CRC Error\n");\r\n} else {\r\nlength = (rx_desc->rx_words_eob) - 3 - ETH_FCS_LEN;\r\nif (rx_desc->rx_words_eob & 0x02)\r\nlength = length - 4;\r\nmemcpy(skb->data, buffer_info->rx_buffer, length);\r\nadapter->stats.rx_bytes += length;\r\nadapter->stats.rx_packets++;\r\nif ((gbec_status & PCH_GBE_RXD_GMAC_STAT_MARMLT))\r\nadapter->stats.multicast++;\r\nskb_put(skb, length);\r\npch_rx_timestamp(adapter, skb);\r\nskb->protocol = eth_type_trans(skb, netdev);\r\nif (tcp_ip_status & PCH_GBE_RXD_ACC_STAT_TCPIPOK)\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nelse\r\nskb->ip_summed = CHECKSUM_NONE;\r\nnapi_gro_receive(&adapter->napi, skb);\r\n(*work_done)++;\r\nnetdev_dbg(netdev,\r\n"Receive skb->ip_summed: %d length: %d\n",\r\nskb->ip_summed, length);\r\n}\r\nif (unlikely(cleaned_count >= PCH_GBE_RX_BUFFER_WRITE)) {\r\npch_gbe_alloc_rx_buffers(adapter, rx_ring,\r\ncleaned_count);\r\ncleaned_count = 0;\r\n}\r\nif (++i == rx_ring->count)\r\ni = 0;\r\n}\r\nrx_ring->next_to_clean = i;\r\nif (cleaned_count)\r\npch_gbe_alloc_rx_buffers(adapter, rx_ring, cleaned_count);\r\nreturn cleaned;\r\n}\r\nint pch_gbe_setup_tx_resources(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_tx_ring *tx_ring)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_tx_desc *tx_desc;\r\nint size;\r\nint desNo;\r\nsize = (int)sizeof(struct pch_gbe_buffer) * tx_ring->count;\r\ntx_ring->buffer_info = vzalloc(size);\r\nif (!tx_ring->buffer_info)\r\nreturn -ENOMEM;\r\ntx_ring->size = tx_ring->count * (int)sizeof(struct pch_gbe_tx_desc);\r\ntx_ring->desc = dma_zalloc_coherent(&pdev->dev, tx_ring->size,\r\n&tx_ring->dma, GFP_KERNEL);\r\nif (!tx_ring->desc) {\r\nvfree(tx_ring->buffer_info);\r\nreturn -ENOMEM;\r\n}\r\ntx_ring->next_to_use = 0;\r\ntx_ring->next_to_clean = 0;\r\nfor (desNo = 0; desNo < tx_ring->count; desNo++) {\r\ntx_desc = PCH_GBE_TX_DESC(*tx_ring, desNo);\r\ntx_desc->gbec_status = DSC_INIT16;\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"tx_ring->desc = 0x%p tx_ring->dma = 0x%08llx next_to_clean = 0x%08x next_to_use = 0x%08x\n",\r\ntx_ring->desc, (unsigned long long)tx_ring->dma,\r\ntx_ring->next_to_clean, tx_ring->next_to_use);\r\nreturn 0;\r\n}\r\nint pch_gbe_setup_rx_resources(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_rx_ring *rx_ring)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_rx_desc *rx_desc;\r\nint size;\r\nint desNo;\r\nsize = (int)sizeof(struct pch_gbe_buffer) * rx_ring->count;\r\nrx_ring->buffer_info = vzalloc(size);\r\nif (!rx_ring->buffer_info)\r\nreturn -ENOMEM;\r\nrx_ring->size = rx_ring->count * (int)sizeof(struct pch_gbe_rx_desc);\r\nrx_ring->desc = dma_zalloc_coherent(&pdev->dev, rx_ring->size,\r\n&rx_ring->dma, GFP_KERNEL);\r\nif (!rx_ring->desc) {\r\nvfree(rx_ring->buffer_info);\r\nreturn -ENOMEM;\r\n}\r\nrx_ring->next_to_clean = 0;\r\nrx_ring->next_to_use = 0;\r\nfor (desNo = 0; desNo < rx_ring->count; desNo++) {\r\nrx_desc = PCH_GBE_RX_DESC(*rx_ring, desNo);\r\nrx_desc->gbec_status = DSC_INIT16;\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"rx_ring->desc = 0x%p rx_ring->dma = 0x%08llx next_to_clean = 0x%08x next_to_use = 0x%08x\n",\r\nrx_ring->desc, (unsigned long long)rx_ring->dma,\r\nrx_ring->next_to_clean, rx_ring->next_to_use);\r\nreturn 0;\r\n}\r\nvoid pch_gbe_free_tx_resources(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_tx_ring *tx_ring)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\npch_gbe_clean_tx_ring(adapter, tx_ring);\r\nvfree(tx_ring->buffer_info);\r\ntx_ring->buffer_info = NULL;\r\npci_free_consistent(pdev, tx_ring->size, tx_ring->desc, tx_ring->dma);\r\ntx_ring->desc = NULL;\r\n}\r\nvoid pch_gbe_free_rx_resources(struct pch_gbe_adapter *adapter,\r\nstruct pch_gbe_rx_ring *rx_ring)\r\n{\r\nstruct pci_dev *pdev = adapter->pdev;\r\npch_gbe_clean_rx_ring(adapter, rx_ring);\r\nvfree(rx_ring->buffer_info);\r\nrx_ring->buffer_info = NULL;\r\npci_free_consistent(pdev, rx_ring->size, rx_ring->desc, rx_ring->dma);\r\nrx_ring->desc = NULL;\r\n}\r\nstatic int pch_gbe_request_irq(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nint err;\r\nint flags;\r\nflags = IRQF_SHARED;\r\nadapter->have_msi = false;\r\nerr = pci_enable_msi(adapter->pdev);\r\nnetdev_dbg(netdev, "call pci_enable_msi\n");\r\nif (err) {\r\nnetdev_dbg(netdev, "call pci_enable_msi - Error: %d\n", err);\r\n} else {\r\nflags = 0;\r\nadapter->have_msi = true;\r\n}\r\nerr = request_irq(adapter->pdev->irq, &pch_gbe_intr,\r\nflags, netdev->name, netdev);\r\nif (err)\r\nnetdev_err(netdev, "Unable to allocate interrupt Error: %d\n",\r\nerr);\r\nnetdev_dbg(netdev,\r\n"adapter->have_msi : %d flags : 0x%04x return : 0x%04x\n",\r\nadapter->have_msi, flags, err);\r\nreturn err;\r\n}\r\nint pch_gbe_up(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pch_gbe_tx_ring *tx_ring = adapter->tx_ring;\r\nstruct pch_gbe_rx_ring *rx_ring = adapter->rx_ring;\r\nint err = -EINVAL;\r\nif (!is_valid_ether_addr(adapter->hw.mac.addr)) {\r\nnetdev_err(netdev, "Error: Invalid MAC address\n");\r\ngoto out;\r\n}\r\npch_gbe_set_multi(netdev);\r\npch_gbe_setup_tctl(adapter);\r\npch_gbe_configure_tx(adapter);\r\npch_gbe_setup_rctl(adapter);\r\npch_gbe_configure_rx(adapter);\r\nerr = pch_gbe_request_irq(adapter);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"Error: can't bring device up - irq request failed\n");\r\ngoto out;\r\n}\r\nerr = pch_gbe_alloc_rx_buffers_pool(adapter, rx_ring, rx_ring->count);\r\nif (err) {\r\nnetdev_err(netdev,\r\n"Error: can't bring device up - alloc rx buffers pool failed\n");\r\ngoto freeirq;\r\n}\r\npch_gbe_alloc_tx_buffers(adapter, tx_ring);\r\npch_gbe_alloc_rx_buffers(adapter, rx_ring, rx_ring->count);\r\nadapter->tx_queue_len = netdev->tx_queue_len;\r\npch_gbe_enable_dma_rx(&adapter->hw);\r\npch_gbe_enable_mac_rx(&adapter->hw);\r\nmod_timer(&adapter->watchdog_timer, jiffies);\r\nnapi_enable(&adapter->napi);\r\npch_gbe_irq_enable(adapter);\r\nnetif_start_queue(adapter->netdev);\r\nreturn 0;\r\nfreeirq:\r\npch_gbe_free_irq(adapter);\r\nout:\r\nreturn err;\r\n}\r\nvoid pch_gbe_down(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct net_device *netdev = adapter->netdev;\r\nstruct pci_dev *pdev = adapter->pdev;\r\nstruct pch_gbe_rx_ring *rx_ring = adapter->rx_ring;\r\nnapi_disable(&adapter->napi);\r\natomic_set(&adapter->irq_sem, 0);\r\npch_gbe_irq_disable(adapter);\r\npch_gbe_free_irq(adapter);\r\ndel_timer_sync(&adapter->watchdog_timer);\r\nnetdev->tx_queue_len = adapter->tx_queue_len;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\nif ((pdev->error_state) && (pdev->error_state != pci_channel_io_normal))\r\npch_gbe_reset(adapter);\r\npch_gbe_clean_tx_ring(adapter, adapter->tx_ring);\r\npch_gbe_clean_rx_ring(adapter, adapter->rx_ring);\r\npci_free_consistent(adapter->pdev, rx_ring->rx_buff_pool_size,\r\nrx_ring->rx_buff_pool, rx_ring->rx_buff_pool_logic);\r\nrx_ring->rx_buff_pool_logic = 0;\r\nrx_ring->rx_buff_pool_size = 0;\r\nrx_ring->rx_buff_pool = NULL;\r\n}\r\nstatic int pch_gbe_sw_init(struct pch_gbe_adapter *adapter)\r\n{\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct net_device *netdev = adapter->netdev;\r\nadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_2048;\r\nhw->mac.max_frame_size = netdev->mtu + ETH_HLEN + ETH_FCS_LEN;\r\nhw->mac.min_frame_size = ETH_ZLEN + ETH_FCS_LEN;\r\nif (pch_gbe_hal_setup_init_funcs(hw)) {\r\nnetdev_err(netdev, "Hardware Initialization Failure\n");\r\nreturn -EIO;\r\n}\r\nif (pch_gbe_alloc_queues(adapter)) {\r\nnetdev_err(netdev, "Unable to allocate memory for queues\n");\r\nreturn -ENOMEM;\r\n}\r\nspin_lock_init(&adapter->hw.miim_lock);\r\nspin_lock_init(&adapter->stats_lock);\r\nspin_lock_init(&adapter->ethtool_lock);\r\natomic_set(&adapter->irq_sem, 0);\r\npch_gbe_irq_disable(adapter);\r\npch_gbe_init_stats(adapter);\r\nnetdev_dbg(netdev,\r\n"rx_buffer_len : %d mac.min_frame_size : %d mac.max_frame_size : %d\n",\r\n(u32) adapter->rx_buffer_len,\r\nhw->mac.min_frame_size, hw->mac.max_frame_size);\r\nreturn 0;\r\n}\r\nstatic int pch_gbe_open(struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nint err;\r\nerr = pch_gbe_setup_tx_resources(adapter, adapter->tx_ring);\r\nif (err)\r\ngoto err_setup_tx;\r\nerr = pch_gbe_setup_rx_resources(adapter, adapter->rx_ring);\r\nif (err)\r\ngoto err_setup_rx;\r\npch_gbe_hal_power_up_phy(hw);\r\nerr = pch_gbe_up(adapter);\r\nif (err)\r\ngoto err_up;\r\nnetdev_dbg(netdev, "Success End\n");\r\nreturn 0;\r\nerr_up:\r\nif (!adapter->wake_up_evt)\r\npch_gbe_hal_power_down_phy(hw);\r\npch_gbe_free_rx_resources(adapter, adapter->rx_ring);\r\nerr_setup_rx:\r\npch_gbe_free_tx_resources(adapter, adapter->tx_ring);\r\nerr_setup_tx:\r\npch_gbe_reset(adapter);\r\nnetdev_err(netdev, "Error End\n");\r\nreturn err;\r\n}\r\nstatic int pch_gbe_stop(struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\npch_gbe_down(adapter);\r\nif (!adapter->wake_up_evt)\r\npch_gbe_hal_power_down_phy(hw);\r\npch_gbe_free_tx_resources(adapter, adapter->tx_ring);\r\npch_gbe_free_rx_resources(adapter, adapter->rx_ring);\r\nreturn 0;\r\n}\r\nstatic int pch_gbe_xmit_frame(struct sk_buff *skb, struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_tx_ring *tx_ring = adapter->tx_ring;\r\nif (unlikely(!PCH_GBE_DESC_UNUSED(tx_ring))) {\r\nnetif_stop_queue(netdev);\r\nnetdev_dbg(netdev,\r\n"Return : BUSY next_to use : 0x%08x next_to clean : 0x%08x\n",\r\ntx_ring->next_to_use, tx_ring->next_to_clean);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\npch_gbe_tx_queue(adapter, tx_ring, skb);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic void pch_gbe_set_multi(struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nstruct netdev_hw_addr *ha;\r\nu8 *mta_list;\r\nu32 rctl;\r\nint i;\r\nint mc_count;\r\nnetdev_dbg(netdev, "netdev->flags : 0x%08x\n", netdev->flags);\r\nrctl = ioread32(&hw->reg->RX_MODE);\r\nmc_count = netdev_mc_count(netdev);\r\nif ((netdev->flags & IFF_PROMISC)) {\r\nrctl &= ~PCH_GBE_ADD_FIL_EN;\r\nrctl &= ~PCH_GBE_MLT_FIL_EN;\r\n} else if ((netdev->flags & IFF_ALLMULTI)) {\r\nrctl |= PCH_GBE_ADD_FIL_EN;\r\nrctl &= ~PCH_GBE_MLT_FIL_EN;\r\n} else {\r\nif (mc_count >= PCH_GBE_MAR_ENTRIES) {\r\nrctl |= PCH_GBE_ADD_FIL_EN;\r\nrctl &= ~PCH_GBE_MLT_FIL_EN;\r\n} else {\r\nrctl |= (PCH_GBE_ADD_FIL_EN | PCH_GBE_MLT_FIL_EN);\r\n}\r\n}\r\niowrite32(rctl, &hw->reg->RX_MODE);\r\nif (mc_count >= PCH_GBE_MAR_ENTRIES)\r\nreturn;\r\nmta_list = kmalloc(mc_count * ETH_ALEN, GFP_ATOMIC);\r\nif (!mta_list)\r\nreturn;\r\ni = 0;\r\nnetdev_for_each_mc_addr(ha, netdev) {\r\nif (i == mc_count)\r\nbreak;\r\nmemcpy(mta_list + (i++ * ETH_ALEN), &ha->addr, ETH_ALEN);\r\n}\r\npch_gbe_mac_mc_addr_list_update(hw, mta_list, i, 1,\r\nPCH_GBE_MAR_ENTRIES);\r\nkfree(mta_list);\r\nnetdev_dbg(netdev,\r\n"RX_MODE reg(check bit31,30 ADD,MLT) : 0x%08x netdev->mc_count : 0x%08x\n",\r\nioread32(&hw->reg->RX_MODE), mc_count);\r\n}\r\nstatic int pch_gbe_set_mac(struct net_device *netdev, void *addr)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct sockaddr *skaddr = addr;\r\nint ret_val;\r\nif (!is_valid_ether_addr(skaddr->sa_data)) {\r\nret_val = -EADDRNOTAVAIL;\r\n} else {\r\nmemcpy(netdev->dev_addr, skaddr->sa_data, netdev->addr_len);\r\nmemcpy(adapter->hw.mac.addr, skaddr->sa_data, netdev->addr_len);\r\npch_gbe_mac_mar_set(&adapter->hw, adapter->hw.mac.addr, 0);\r\nret_val = 0;\r\n}\r\nnetdev_dbg(netdev, "ret_val : 0x%08x\n", ret_val);\r\nnetdev_dbg(netdev, "dev_addr : %pM\n", netdev->dev_addr);\r\nnetdev_dbg(netdev, "mac_addr : %pM\n", adapter->hw.mac.addr);\r\nnetdev_dbg(netdev, "MAC_ADR1AB reg : 0x%08x 0x%08x\n",\r\nioread32(&adapter->hw.reg->mac_adr[0].high),\r\nioread32(&adapter->hw.reg->mac_adr[0].low));\r\nreturn ret_val;\r\n}\r\nstatic int pch_gbe_change_mtu(struct net_device *netdev, int new_mtu)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nint max_frame = new_mtu + ETH_HLEN + ETH_FCS_LEN;\r\nunsigned long old_rx_buffer_len = adapter->rx_buffer_len;\r\nint err;\r\nif (max_frame <= PCH_GBE_FRAME_SIZE_2048)\r\nadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_2048;\r\nelse if (max_frame <= PCH_GBE_FRAME_SIZE_4096)\r\nadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_4096;\r\nelse if (max_frame <= PCH_GBE_FRAME_SIZE_8192)\r\nadapter->rx_buffer_len = PCH_GBE_FRAME_SIZE_8192;\r\nelse\r\nadapter->rx_buffer_len = PCH_GBE_MAX_RX_BUFFER_SIZE;\r\nif (netif_running(netdev)) {\r\npch_gbe_down(adapter);\r\nerr = pch_gbe_up(adapter);\r\nif (err) {\r\nadapter->rx_buffer_len = old_rx_buffer_len;\r\npch_gbe_up(adapter);\r\nreturn err;\r\n} else {\r\nnetdev->mtu = new_mtu;\r\nadapter->hw.mac.max_frame_size = max_frame;\r\n}\r\n} else {\r\npch_gbe_reset(adapter);\r\nnetdev->mtu = new_mtu;\r\nadapter->hw.mac.max_frame_size = max_frame;\r\n}\r\nnetdev_dbg(netdev,\r\n"max_frame : %d rx_buffer_len : %d mtu : %d max_frame_size : %d\n",\r\nmax_frame, (u32) adapter->rx_buffer_len, netdev->mtu,\r\nadapter->hw.mac.max_frame_size);\r\nreturn 0;\r\n}\r\nstatic int pch_gbe_set_features(struct net_device *netdev,\r\nnetdev_features_t features)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nnetdev_features_t changed = features ^ netdev->features;\r\nif (!(changed & NETIF_F_RXCSUM))\r\nreturn 0;\r\nif (netif_running(netdev))\r\npch_gbe_reinit_locked(adapter);\r\nelse\r\npch_gbe_reset(adapter);\r\nreturn 0;\r\n}\r\nstatic int pch_gbe_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nnetdev_dbg(netdev, "cmd : 0x%04x\n", cmd);\r\nif (cmd == SIOCSHWTSTAMP)\r\nreturn hwtstamp_ioctl(netdev, ifr, cmd);\r\nreturn generic_mii_ioctl(&adapter->mii, if_mii(ifr), cmd, NULL);\r\n}\r\nstatic void pch_gbe_tx_timeout(struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nadapter->stats.tx_timeout_count++;\r\nschedule_work(&adapter->reset_task);\r\n}\r\nstatic int pch_gbe_napi_poll(struct napi_struct *napi, int budget)\r\n{\r\nstruct pch_gbe_adapter *adapter =\r\ncontainer_of(napi, struct pch_gbe_adapter, napi);\r\nint work_done = 0;\r\nbool poll_end_flag = false;\r\nbool cleaned = false;\r\nnetdev_dbg(adapter->netdev, "budget : %d\n", budget);\r\npch_gbe_clean_rx(adapter, adapter->rx_ring, &work_done, budget);\r\ncleaned = pch_gbe_clean_tx(adapter, adapter->tx_ring);\r\nif (cleaned)\r\nwork_done = budget;\r\nif (work_done < budget)\r\npoll_end_flag = true;\r\nif (poll_end_flag) {\r\nnapi_complete_done(napi, work_done);\r\npch_gbe_irq_enable(adapter);\r\n}\r\nif (adapter->rx_stop_flag) {\r\nadapter->rx_stop_flag = false;\r\npch_gbe_enable_dma_rx(&adapter->hw);\r\n}\r\nnetdev_dbg(adapter->netdev,\r\n"poll_end_flag : %d work_done : %d budget : %d\n",\r\npoll_end_flag, work_done, budget);\r\nreturn work_done;\r\n}\r\nstatic void pch_gbe_netpoll(struct net_device *netdev)\r\n{\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\ndisable_irq(adapter->pdev->irq);\r\npch_gbe_intr(adapter->pdev->irq, netdev);\r\nenable_irq(adapter->pdev->irq);\r\n}\r\nstatic pci_ers_result_t pch_gbe_io_error_detected(struct pci_dev *pdev,\r\npci_channel_state_t state)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev))\r\npch_gbe_down(adapter);\r\npci_disable_device(pdev);\r\nreturn PCI_ERS_RESULT_NEED_RESET;\r\n}\r\nstatic pci_ers_result_t pch_gbe_io_slot_reset(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nif (pci_enable_device(pdev)) {\r\nnetdev_err(netdev, "Cannot re-enable PCI device after reset\n");\r\nreturn PCI_ERS_RESULT_DISCONNECT;\r\n}\r\npci_set_master(pdev);\r\npci_enable_wake(pdev, PCI_D0, 0);\r\npch_gbe_hal_power_up_phy(hw);\r\npch_gbe_reset(adapter);\r\npch_gbe_mac_set_wol_event(hw, 0);\r\nreturn PCI_ERS_RESULT_RECOVERED;\r\n}\r\nstatic void pch_gbe_io_resume(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nif (netif_running(netdev)) {\r\nif (pch_gbe_up(adapter)) {\r\nnetdev_dbg(netdev,\r\n"can't bring device back up after reset\n");\r\nreturn;\r\n}\r\n}\r\nnetif_device_attach(netdev);\r\n}\r\nstatic int __pch_gbe_suspend(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 wufc = adapter->wake_up_evt;\r\nint retval = 0;\r\nnetif_device_detach(netdev);\r\nif (netif_running(netdev))\r\npch_gbe_down(adapter);\r\nif (wufc) {\r\npch_gbe_set_multi(netdev);\r\npch_gbe_setup_rctl(adapter);\r\npch_gbe_configure_rx(adapter);\r\npch_gbe_set_rgmii_ctrl(adapter, hw->mac.link_speed,\r\nhw->mac.link_duplex);\r\npch_gbe_set_mode(adapter, hw->mac.link_speed,\r\nhw->mac.link_duplex);\r\npch_gbe_mac_set_wol_event(hw, wufc);\r\npci_disable_device(pdev);\r\n} else {\r\npch_gbe_hal_power_down_phy(hw);\r\npch_gbe_mac_set_wol_event(hw, wufc);\r\npci_disable_device(pdev);\r\n}\r\nreturn retval;\r\n}\r\nstatic int pch_gbe_suspend(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nreturn __pch_gbe_suspend(pdev);\r\n}\r\nstatic int pch_gbe_resume(struct device *device)\r\n{\r\nstruct pci_dev *pdev = to_pci_dev(device);\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\nstruct pch_gbe_hw *hw = &adapter->hw;\r\nu32 err;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nnetdev_err(netdev, "Cannot enable PCI device from suspend\n");\r\nreturn err;\r\n}\r\npci_set_master(pdev);\r\npch_gbe_hal_power_up_phy(hw);\r\npch_gbe_reset(adapter);\r\npch_gbe_mac_set_wol_event(hw, 0);\r\nif (netif_running(netdev))\r\npch_gbe_up(adapter);\r\nnetif_device_attach(netdev);\r\nreturn 0;\r\n}\r\nstatic void pch_gbe_shutdown(struct pci_dev *pdev)\r\n{\r\n__pch_gbe_suspend(pdev);\r\nif (system_state == SYSTEM_POWER_OFF) {\r\npci_wake_from_d3(pdev, true);\r\npci_set_power_state(pdev, PCI_D3hot);\r\n}\r\n}\r\nstatic void pch_gbe_remove(struct pci_dev *pdev)\r\n{\r\nstruct net_device *netdev = pci_get_drvdata(pdev);\r\nstruct pch_gbe_adapter *adapter = netdev_priv(netdev);\r\ncancel_work_sync(&adapter->reset_task);\r\nunregister_netdev(netdev);\r\npch_gbe_hal_phy_hw_reset(&adapter->hw);\r\nfree_netdev(netdev);\r\n}\r\nstatic int pch_gbe_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *pci_id)\r\n{\r\nstruct net_device *netdev;\r\nstruct pch_gbe_adapter *adapter;\r\nint ret;\r\nret = pcim_enable_device(pdev);\r\nif (ret)\r\nreturn ret;\r\nif (pci_set_dma_mask(pdev, DMA_BIT_MASK(64))\r\n|| pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64))) {\r\nret = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));\r\nif (ret) {\r\nret = pci_set_consistent_dma_mask(pdev,\r\nDMA_BIT_MASK(32));\r\nif (ret) {\r\ndev_err(&pdev->dev, "ERR: No usable DMA "\r\n"configuration, aborting\n");\r\nreturn ret;\r\n}\r\n}\r\n}\r\nret = pcim_iomap_regions(pdev, 1 << PCH_GBE_PCI_BAR, pci_name(pdev));\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"ERR: Can't reserve PCI I/O and memory resources\n");\r\nreturn ret;\r\n}\r\npci_set_master(pdev);\r\nnetdev = alloc_etherdev((int)sizeof(struct pch_gbe_adapter));\r\nif (!netdev)\r\nreturn -ENOMEM;\r\nSET_NETDEV_DEV(netdev, &pdev->dev);\r\npci_set_drvdata(pdev, netdev);\r\nadapter = netdev_priv(netdev);\r\nadapter->netdev = netdev;\r\nadapter->pdev = pdev;\r\nadapter->hw.back = adapter;\r\nadapter->hw.reg = pcim_iomap_table(pdev)[PCH_GBE_PCI_BAR];\r\nadapter->pdata = (struct pch_gbe_privdata *)pci_id->driver_data;\r\nif (adapter->pdata && adapter->pdata->platform_init)\r\nadapter->pdata->platform_init(pdev);\r\nadapter->ptp_pdev = pci_get_bus_and_slot(adapter->pdev->bus->number,\r\nPCI_DEVFN(12, 4));\r\nnetdev->netdev_ops = &pch_gbe_netdev_ops;\r\nnetdev->watchdog_timeo = PCH_GBE_WATCHDOG_PERIOD;\r\nnetif_napi_add(netdev, &adapter->napi,\r\npch_gbe_napi_poll, PCH_GBE_RX_WEIGHT);\r\nnetdev->hw_features = NETIF_F_RXCSUM |\r\nNETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;\r\nnetdev->features = netdev->hw_features;\r\npch_gbe_set_ethtool_ops(netdev);\r\nnetdev->min_mtu = ETH_ZLEN - ETH_HLEN;\r\nnetdev->max_mtu = PCH_GBE_MAX_JUMBO_FRAME_SIZE -\r\n(ETH_HLEN + ETH_FCS_LEN);\r\npch_gbe_mac_load_mac_addr(&adapter->hw);\r\npch_gbe_mac_reset_hw(&adapter->hw);\r\nret = pch_gbe_sw_init(adapter);\r\nif (ret)\r\ngoto err_free_netdev;\r\nret = pch_gbe_init_phy(adapter);\r\nif (ret) {\r\ndev_err(&pdev->dev, "PHY initialize error\n");\r\ngoto err_free_adapter;\r\n}\r\npch_gbe_hal_get_bus_info(&adapter->hw);\r\nret = pch_gbe_hal_read_mac_addr(&adapter->hw);\r\nif (ret) {\r\ndev_err(&pdev->dev, "MAC address Read Error\n");\r\ngoto err_free_adapter;\r\n}\r\nmemcpy(netdev->dev_addr, adapter->hw.mac.addr, netdev->addr_len);\r\nif (!is_valid_ether_addr(netdev->dev_addr)) {\r\ndev_err(&pdev->dev, "Invalid MAC address, "\r\n"interface disabled.\n");\r\n}\r\nsetup_timer(&adapter->watchdog_timer, pch_gbe_watchdog,\r\n(unsigned long)adapter);\r\nINIT_WORK(&adapter->reset_task, pch_gbe_reset_task);\r\npch_gbe_check_options(adapter);\r\nadapter->wake_up_evt = PCH_GBE_WL_INIT_SETTING;\r\ndev_info(&pdev->dev, "MAC address : %pM\n", netdev->dev_addr);\r\npch_gbe_reset(adapter);\r\nret = register_netdev(netdev);\r\nif (ret)\r\ngoto err_free_adapter;\r\nnetif_carrier_off(netdev);\r\nnetif_stop_queue(netdev);\r\ndev_dbg(&pdev->dev, "PCH Network Connection\n");\r\nif (adapter->pdata && adapter->pdata->phy_disable_hibernate)\r\npch_gbe_phy_disable_hibernate(&adapter->hw);\r\ndevice_set_wakeup_enable(&pdev->dev, 1);\r\nreturn 0;\r\nerr_free_adapter:\r\npch_gbe_hal_phy_hw_reset(&adapter->hw);\r\nerr_free_netdev:\r\nfree_netdev(netdev);\r\nreturn ret;\r\n}\r\nstatic int pch_gbe_minnow_platform_init(struct pci_dev *pdev)\r\n{\r\nunsigned long flags = GPIOF_DIR_OUT | GPIOF_INIT_HIGH | GPIOF_EXPORT;\r\nunsigned gpio = MINNOW_PHY_RESET_GPIO;\r\nint ret;\r\nret = devm_gpio_request_one(&pdev->dev, gpio, flags,\r\n"minnow_phy_reset");\r\nif (ret) {\r\ndev_err(&pdev->dev,\r\n"ERR: Can't request PHY reset GPIO line '%d'\n", gpio);\r\nreturn ret;\r\n}\r\ngpio_set_value(gpio, 0);\r\nusleep_range(1250, 1500);\r\ngpio_set_value(gpio, 1);\r\nusleep_range(1250, 1500);\r\nreturn ret;\r\n}\r\nstatic int __init pch_gbe_init_module(void)\r\n{\r\nint ret;\r\npr_info("EG20T PCH Gigabit Ethernet Driver - version %s\n",DRV_VERSION);\r\nret = pci_register_driver(&pch_gbe_driver);\r\nif (copybreak != PCH_GBE_COPYBREAK_DEFAULT) {\r\nif (copybreak == 0) {\r\npr_info("copybreak disabled\n");\r\n} else {\r\npr_info("copybreak enabled for packets <= %u bytes\n",\r\ncopybreak);\r\n}\r\n}\r\nreturn ret;\r\n}\r\nstatic void __exit pch_gbe_exit_module(void)\r\n{\r\npci_unregister_driver(&pch_gbe_driver);\r\n}
