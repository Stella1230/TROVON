static int get_psp_from_gb_prop(int gb_prop, enum power_supply_property *psp)\r\n{\r\nint prop;\r\nswitch (gb_prop) {\r\ncase GB_POWER_SUPPLY_PROP_STATUS:\r\nprop = POWER_SUPPLY_PROP_STATUS;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_TYPE:\r\nprop = POWER_SUPPLY_PROP_CHARGE_TYPE;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_HEALTH:\r\nprop = POWER_SUPPLY_PROP_HEALTH;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_PRESENT:\r\nprop = POWER_SUPPLY_PROP_PRESENT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ONLINE:\r\nprop = POWER_SUPPLY_PROP_ONLINE;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_AUTHENTIC:\r\nprop = POWER_SUPPLY_PROP_AUTHENTIC;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TECHNOLOGY:\r\nprop = POWER_SUPPLY_PROP_TECHNOLOGY;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CYCLE_COUNT:\r\nprop = POWER_SUPPLY_PROP_CYCLE_COUNT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_MAX:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_MIN:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_MIN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_NOW:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_AVG:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_OCV:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_OCV;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_VOLTAGE_BOOT:\r\nprop = POWER_SUPPLY_PROP_VOLTAGE_BOOT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CURRENT_MAX:\r\nprop = POWER_SUPPLY_PROP_CURRENT_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CURRENT_NOW:\r\nprop = POWER_SUPPLY_PROP_CURRENT_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CURRENT_AVG:\r\nprop = POWER_SUPPLY_PROP_CURRENT_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CURRENT_BOOT:\r\nprop = POWER_SUPPLY_PROP_CURRENT_BOOT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_POWER_NOW:\r\nprop = POWER_SUPPLY_PROP_POWER_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_POWER_AVG:\r\nprop = POWER_SUPPLY_PROP_POWER_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:\r\nprop = POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN:\r\nprop = POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_FULL:\r\nprop = POWER_SUPPLY_PROP_CHARGE_FULL;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_EMPTY:\r\nprop = POWER_SUPPLY_PROP_CHARGE_EMPTY;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_NOW:\r\nprop = POWER_SUPPLY_PROP_CHARGE_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_AVG:\r\nprop = POWER_SUPPLY_PROP_CHARGE_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_COUNTER:\r\nprop = POWER_SUPPLY_PROP_CHARGE_COUNTER;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:\r\nprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX:\r\nprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE:\r\nprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX:\r\nprop = POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT:\r\nprop = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX:\r\nprop = POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:\r\nprop = POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN:\r\nprop = POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN:\r\nprop = POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ENERGY_FULL:\r\nprop = POWER_SUPPLY_PROP_ENERGY_FULL;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ENERGY_EMPTY:\r\nprop = POWER_SUPPLY_PROP_ENERGY_EMPTY;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ENERGY_NOW:\r\nprop = POWER_SUPPLY_PROP_ENERGY_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_ENERGY_AVG:\r\nprop = POWER_SUPPLY_PROP_ENERGY_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CAPACITY:\r\nprop = POWER_SUPPLY_PROP_CAPACITY;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN:\r\nprop = POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX:\r\nprop = POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CAPACITY_LEVEL:\r\nprop = POWER_SUPPLY_PROP_CAPACITY_LEVEL;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP:\r\nprop = POWER_SUPPLY_PROP_TEMP;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_MAX:\r\nprop = POWER_SUPPLY_PROP_TEMP_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_MIN:\r\nprop = POWER_SUPPLY_PROP_TEMP_MIN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_ALERT_MIN:\r\nprop = POWER_SUPPLY_PROP_TEMP_ALERT_MIN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_ALERT_MAX:\r\nprop = POWER_SUPPLY_PROP_TEMP_ALERT_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_AMBIENT:\r\nprop = POWER_SUPPLY_PROP_TEMP_AMBIENT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN:\r\nprop = POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX:\r\nprop = POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:\r\nprop = POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG:\r\nprop = POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TIME_TO_FULL_NOW:\r\nprop = POWER_SUPPLY_PROP_TIME_TO_FULL_NOW;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TIME_TO_FULL_AVG:\r\nprop = POWER_SUPPLY_PROP_TIME_TO_FULL_AVG;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_TYPE:\r\nprop = POWER_SUPPLY_PROP_TYPE;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_SCOPE:\r\nprop = POWER_SUPPLY_PROP_SCOPE;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT:\r\nprop = POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT;\r\nbreak;\r\ncase GB_POWER_SUPPLY_PROP_CALIBRATE:\r\nprop = POWER_SUPPLY_PROP_CALIBRATE;\r\nbreak;\r\ndefault:\r\nprop = -1;\r\nbreak;\r\n}\r\nif (prop < 0)\r\nreturn prop;\r\n*psp = (enum power_supply_property)prop;\r\nreturn 0;\r\n}\r\nstatic struct gb_connection *get_conn_from_psy(struct gb_power_supply *gbpsy)\r\n{\r\nreturn gbpsy->supplies->connection;\r\n}\r\nstatic struct gb_power_supply_prop *get_psy_prop(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp)\r\n{\r\nint i;\r\nfor (i = 0; i < gbpsy->properties_count; i++)\r\nif (gbpsy->props[i].prop == psp)\r\nreturn &gbpsy->props[i];\r\nreturn NULL;\r\n}\r\nstatic int is_psy_prop_writeable(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp)\r\n{\r\nstruct gb_power_supply_prop *prop;\r\nprop = get_psy_prop(gbpsy, psp);\r\nif (!prop)\r\nreturn -ENOENT;\r\nreturn prop->is_writeable ? 1 : 0;\r\n}\r\nstatic int is_prop_valint(enum power_supply_property psp)\r\n{\r\nreturn ((psp < POWER_SUPPLY_PROP_MODEL_NAME) ? 1 : 0);\r\n}\r\nstatic void next_interval(struct gb_power_supply *gbpsy)\r\n{\r\nif (gbpsy->update_interval == update_interval_max)\r\nreturn;\r\ngbpsy->update_interval *= 2;\r\nif (gbpsy->update_interval > update_interval_max)\r\ngbpsy->update_interval = update_interval_max;\r\n}\r\nstatic void __gb_power_supply_changed(struct gb_power_supply *gbpsy)\r\n{\r\npower_supply_changed(gbpsy->psy);\r\n}\r\nstatic void gb_power_supply_state_change(struct gb_power_supply *gbpsy,\r\nstruct gb_power_supply_prop *prop)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nint ret;\r\nmutex_lock(&gbpsy->supply_lock);\r\nif ((prop->val == GB_POWER_SUPPLY_STATUS_CHARGING) &&\r\n!gbpsy->pm_acquired) {\r\nret = gb_pm_runtime_get_sync(connection->bundle);\r\nif (ret)\r\ndev_err(&connection->bundle->dev,\r\n"Fail to set wake lock for charging state\n");\r\nelse\r\ngbpsy->pm_acquired = true;\r\n} else {\r\nif (gbpsy->pm_acquired) {\r\nret = gb_pm_runtime_put_autosuspend(connection->bundle);\r\nif (ret)\r\ndev_err(&connection->bundle->dev,\r\n"Fail to set wake unlock for none charging\n");\r\nelse\r\ngbpsy->pm_acquired = false;\r\n}\r\n}\r\nmutex_unlock(&gbpsy->supply_lock);\r\n}\r\nstatic void check_changed(struct gb_power_supply *gbpsy,\r\nstruct gb_power_supply_prop *prop)\r\n{\r\nconst struct gb_power_supply_changes *psyc;\r\nint val = prop->val;\r\nint prev_val = prop->previous_val;\r\nbool changed = false;\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(psy_props_changes); i++) {\r\npsyc = &psy_props_changes[i];\r\nif (prop->prop == psyc->prop) {\r\nif (!psyc->tolerance_change)\r\nchanged = true;\r\nelse if (val < prev_val &&\r\nprev_val - val > psyc->tolerance_change)\r\nchanged = true;\r\nelse if (val > prev_val &&\r\nval - prev_val > psyc->tolerance_change)\r\nchanged = true;\r\nif (changed && psyc->prop_changed)\r\npsyc->prop_changed(gbpsy, prop);\r\nif (changed)\r\ngbpsy->changed = true;\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic int total_props(struct gb_power_supply *gbpsy)\r\n{\r\nreturn (gbpsy->properties_count + gbpsy->properties_count_str);\r\n}\r\nstatic void prop_append(struct gb_power_supply *gbpsy,\r\nenum power_supply_property prop)\r\n{\r\nenum power_supply_property *new_props_raw;\r\ngbpsy->properties_count_str++;\r\nnew_props_raw = krealloc(gbpsy->props_raw, total_props(gbpsy) *\r\nsizeof(enum power_supply_property),\r\nGFP_KERNEL);\r\nif (!new_props_raw)\r\nreturn;\r\ngbpsy->props_raw = new_props_raw;\r\ngbpsy->props_raw[total_props(gbpsy) - 1] = prop;\r\n}\r\nstatic int __gb_power_supply_set_name(char *init_name, char *name, size_t len)\r\n{\r\nunsigned int i = 0;\r\nint ret = 0;\r\nstruct power_supply *psy;\r\nif (!strlen(init_name))\r\ninit_name = "gb_power_supply";\r\nstrlcpy(name, init_name, len);\r\nwhile ((ret < len) && (psy = power_supply_get_by_name(name))) {\r\npower_supply_put(psy);\r\nret = snprintf(name, len, "%s_%u", init_name, ++i);\r\n}\r\nif (ret >= len)\r\nreturn -ENOMEM;\r\nreturn i;\r\n}\r\nstatic void _gb_power_supply_append_props(struct gb_power_supply *gbpsy)\r\n{\r\nif (strlen(gbpsy->manufacturer))\r\nprop_append(gbpsy, POWER_SUPPLY_PROP_MANUFACTURER);\r\nif (strlen(gbpsy->model_name))\r\nprop_append(gbpsy, POWER_SUPPLY_PROP_MODEL_NAME);\r\nif (strlen(gbpsy->serial_number))\r\nprop_append(gbpsy, POWER_SUPPLY_PROP_SERIAL_NUMBER);\r\n}\r\nstatic int gb_power_supply_description_get(struct gb_power_supply *gbpsy)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nstruct gb_power_supply_get_description_request req;\r\nstruct gb_power_supply_get_description_response resp;\r\nint ret;\r\nreq.psy_id = gbpsy->id;\r\nret = gb_operation_sync(connection,\r\nGB_POWER_SUPPLY_TYPE_GET_DESCRIPTION,\r\n&req, sizeof(req), &resp, sizeof(resp));\r\nif (ret < 0)\r\nreturn ret;\r\ngbpsy->manufacturer = kstrndup(resp.manufacturer, PROP_MAX, GFP_KERNEL);\r\nif (!gbpsy->manufacturer)\r\nreturn -ENOMEM;\r\ngbpsy->model_name = kstrndup(resp.model, PROP_MAX, GFP_KERNEL);\r\nif (!gbpsy->model_name)\r\nreturn -ENOMEM;\r\ngbpsy->serial_number = kstrndup(resp.serial_number, PROP_MAX,\r\nGFP_KERNEL);\r\nif (!gbpsy->serial_number)\r\nreturn -ENOMEM;\r\ngbpsy->type = le16_to_cpu(resp.type);\r\ngbpsy->properties_count = resp.properties_count;\r\nreturn 0;\r\n}\r\nstatic int gb_power_supply_prop_descriptors_get(struct gb_power_supply *gbpsy)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nstruct gb_power_supply_get_property_descriptors_request *req;\r\nstruct gb_power_supply_get_property_descriptors_response *resp;\r\nstruct gb_operation *op;\r\nu8 props_count = gbpsy->properties_count;\r\nenum power_supply_property psp;\r\nint ret;\r\nint i, r = 0;\r\nif (props_count == 0)\r\nreturn 0;\r\nop = gb_operation_create(connection,\r\nGB_POWER_SUPPLY_TYPE_GET_PROP_DESCRIPTORS,\r\nsizeof(req), sizeof(*resp) + props_count *\r\nsizeof(struct gb_power_supply_props_desc),\r\nGFP_KERNEL);\r\nif (!op)\r\nreturn -ENOMEM;\r\nreq = op->request->payload;\r\nreq->psy_id = gbpsy->id;\r\nret = gb_operation_request_send_sync(op);\r\nif (ret < 0)\r\ngoto out_put_operation;\r\nresp = op->response->payload;\r\nfor (i = 0; i < props_count; i++) {\r\nret = get_psp_from_gb_prop(resp->props[i].property, &psp);\r\nif (ret < 0) {\r\ndev_warn(&connection->bundle->dev,\r\n"greybus property %u it is not supported by this kernel, dropped\n",\r\nresp->props[i].property);\r\ngbpsy->properties_count--;\r\n}\r\n}\r\ngbpsy->props = kcalloc(gbpsy->properties_count, sizeof(*gbpsy->props),\r\nGFP_KERNEL);\r\nif (!gbpsy->props) {\r\nret = -ENOMEM;\r\ngoto out_put_operation;\r\n}\r\ngbpsy->props_raw = kcalloc(gbpsy->properties_count,\r\nsizeof(*gbpsy->props_raw), GFP_KERNEL);\r\nif (!gbpsy->props_raw) {\r\nret = -ENOMEM;\r\ngoto out_put_operation;\r\n}\r\nfor (i = 0; i < props_count; i++) {\r\nret = get_psp_from_gb_prop(resp->props[i].property, &psp);\r\nif (ret < 0) {\r\nr++;\r\ncontinue;\r\n}\r\ngbpsy->props[i - r].prop = psp;\r\ngbpsy->props[i - r].gb_prop = resp->props[i].property;\r\ngbpsy->props_raw[i - r] = psp;\r\nif (resp->props[i].is_writeable)\r\ngbpsy->props[i - r].is_writeable = true;\r\n}\r\n_gb_power_supply_append_props(gbpsy);\r\nret = 0;\r\nout_put_operation:\r\ngb_operation_put(op);\r\nreturn ret;\r\n}\r\nstatic int __gb_power_supply_property_update(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nstruct gb_power_supply_prop *prop;\r\nstruct gb_power_supply_get_property_request req;\r\nstruct gb_power_supply_get_property_response resp;\r\nint val;\r\nint ret;\r\nprop = get_psy_prop(gbpsy, psp);\r\nif (!prop)\r\nreturn -EINVAL;\r\nreq.psy_id = gbpsy->id;\r\nreq.property = prop->gb_prop;\r\nret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_GET_PROPERTY,\r\n&req, sizeof(req), &resp, sizeof(resp));\r\nif (ret < 0)\r\nreturn ret;\r\nval = le32_to_cpu(resp.prop_val);\r\nif (val == prop->val)\r\nreturn 0;\r\nprop->previous_val = prop->val;\r\nprop->val = val;\r\ncheck_changed(gbpsy, prop);\r\nreturn 0;\r\n}\r\nstatic int __gb_power_supply_property_get(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct gb_power_supply_prop *prop;\r\nprop = get_psy_prop(gbpsy, psp);\r\nif (!prop)\r\nreturn -EINVAL;\r\nval->intval = prop->val;\r\nreturn 0;\r\n}\r\nstatic int __gb_power_supply_property_strval_get(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nswitch (psp) {\r\ncase POWER_SUPPLY_PROP_MODEL_NAME:\r\nval->strval = gbpsy->model_name;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_MANUFACTURER:\r\nval->strval = gbpsy->manufacturer;\r\nbreak;\r\ncase POWER_SUPPLY_PROP_SERIAL_NUMBER:\r\nval->strval = gbpsy->serial_number;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int _gb_power_supply_property_get(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nint ret;\r\nif (is_prop_valint(psp))\r\nret = __gb_power_supply_property_get(gbpsy, psp, val);\r\nelse\r\nret = __gb_power_supply_property_strval_get(gbpsy, psp, val);\r\nif (ret < 0)\r\ndev_err(&connection->bundle->dev, "get property %u\n", psp);\r\nreturn 0;\r\n}\r\nstatic int is_cache_valid(struct gb_power_supply *gbpsy)\r\n{\r\nif (gbpsy->cache_invalid) {\r\ngbpsy->cache_invalid = 0;\r\nreturn 0;\r\n}\r\nif (gbpsy->last_update &&\r\ntime_is_after_jiffies(gbpsy->last_update +\r\nmsecs_to_jiffies(cache_time)))\r\nreturn 1;\r\nreturn 0;\r\n}\r\nstatic int gb_power_supply_status_get(struct gb_power_supply *gbpsy)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nint ret = 0;\r\nint i;\r\nif (is_cache_valid(gbpsy))\r\nreturn 0;\r\nret = gb_pm_runtime_get_sync(connection->bundle);\r\nif (ret)\r\nreturn ret;\r\nfor (i = 0; i < gbpsy->properties_count; i++) {\r\nret = __gb_power_supply_property_update(gbpsy,\r\ngbpsy->props[i].prop);\r\nif (ret < 0)\r\nbreak;\r\n}\r\nif (ret == 0)\r\ngbpsy->last_update = jiffies;\r\ngb_pm_runtime_put_autosuspend(connection->bundle);\r\nreturn ret;\r\n}\r\nstatic void gb_power_supply_status_update(struct gb_power_supply *gbpsy)\r\n{\r\ngb_power_supply_status_get(gbpsy);\r\nif (!gbpsy->changed)\r\nreturn;\r\ngbpsy->update_interval = update_interval_init;\r\n__gb_power_supply_changed(gbpsy);\r\ngbpsy->changed = false;\r\n}\r\nstatic void gb_power_supply_work(struct work_struct *work)\r\n{\r\nstruct gb_power_supply *gbpsy = container_of(work,\r\nstruct gb_power_supply,\r\nwork.work);\r\nif (!gbpsy->update_interval)\r\nreturn;\r\ngb_power_supply_status_update(gbpsy);\r\nnext_interval(gbpsy);\r\nschedule_delayed_work(&gbpsy->work, gbpsy->update_interval);\r\n}\r\nstatic int get_property(struct power_supply *b,\r\nenum power_supply_property psp,\r\nunion power_supply_propval *val)\r\n{\r\nstruct gb_power_supply *gbpsy = to_gb_power_supply(b);\r\ngb_power_supply_status_get(gbpsy);\r\nreturn _gb_power_supply_property_get(gbpsy, psp, val);\r\n}\r\nstatic int gb_power_supply_property_set(struct gb_power_supply *gbpsy,\r\nenum power_supply_property psp,\r\nint val)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nstruct gb_power_supply_prop *prop;\r\nstruct gb_power_supply_set_property_request req;\r\nint ret;\r\nret = gb_pm_runtime_get_sync(connection->bundle);\r\nif (ret)\r\nreturn ret;\r\nprop = get_psy_prop(gbpsy, psp);\r\nif (!prop) {\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nreq.psy_id = gbpsy->id;\r\nreq.property = prop->gb_prop;\r\nreq.prop_val = cpu_to_le32((s32)val);\r\nret = gb_operation_sync(connection, GB_POWER_SUPPLY_TYPE_SET_PROPERTY,\r\n&req, sizeof(req), NULL, 0);\r\nif (ret < 0)\r\ngoto out;\r\nprop->val = val;\r\nout:\r\ngb_pm_runtime_put_autosuspend(connection->bundle);\r\nreturn ret;\r\n}\r\nstatic int set_property(struct power_supply *b,\r\nenum power_supply_property psp,\r\nconst union power_supply_propval *val)\r\n{\r\nstruct gb_power_supply *gbpsy = to_gb_power_supply(b);\r\nreturn gb_power_supply_property_set(gbpsy, psp, val->intval);\r\n}\r\nstatic int property_is_writeable(struct power_supply *b,\r\nenum power_supply_property psp)\r\n{\r\nstruct gb_power_supply *gbpsy = to_gb_power_supply(b);\r\nreturn is_psy_prop_writeable(gbpsy, psp);\r\n}\r\nstatic int gb_power_supply_register(struct gb_power_supply *gbpsy)\r\n{\r\nstruct gb_connection *connection = get_conn_from_psy(gbpsy);\r\nstruct power_supply_config cfg = {};\r\ncfg.drv_data = gbpsy;\r\ngbpsy->desc.name = gbpsy->name;\r\ngbpsy->desc.type = gbpsy->type;\r\ngbpsy->desc.properties = gbpsy->props_raw;\r\ngbpsy->desc.num_properties = total_props(gbpsy);\r\ngbpsy->desc.get_property = get_property;\r\ngbpsy->desc.set_property = set_property;\r\ngbpsy->desc.property_is_writeable = property_is_writeable;\r\ngbpsy->psy = power_supply_register(&connection->bundle->dev,\r\n&gbpsy->desc, &cfg);\r\nreturn PTR_ERR_OR_ZERO(gbpsy->psy);\r\n}\r\nstatic void _gb_power_supply_free(struct gb_power_supply *gbpsy)\r\n{\r\nkfree(gbpsy->serial_number);\r\nkfree(gbpsy->model_name);\r\nkfree(gbpsy->manufacturer);\r\nkfree(gbpsy->props_raw);\r\nkfree(gbpsy->props);\r\n}\r\nstatic void _gb_power_supply_release(struct gb_power_supply *gbpsy)\r\n{\r\ngbpsy->update_interval = 0;\r\ncancel_delayed_work_sync(&gbpsy->work);\r\nif (gbpsy->registered)\r\npower_supply_unregister(gbpsy->psy);\r\n_gb_power_supply_free(gbpsy);\r\n}\r\nstatic void _gb_power_supplies_release(struct gb_power_supplies *supplies)\r\n{\r\nint i;\r\nif (!supplies->supply)\r\nreturn;\r\nmutex_lock(&supplies->supplies_lock);\r\nfor (i = 0; i < supplies->supplies_count; i++)\r\n_gb_power_supply_release(&supplies->supply[i]);\r\nkfree(supplies->supply);\r\nmutex_unlock(&supplies->supplies_lock);\r\nkfree(supplies);\r\n}\r\nstatic int gb_power_supplies_get_count(struct gb_power_supplies *supplies)\r\n{\r\nstruct gb_power_supply_get_supplies_response resp;\r\nint ret;\r\nret = gb_operation_sync(supplies->connection,\r\nGB_POWER_SUPPLY_TYPE_GET_SUPPLIES,\r\nNULL, 0, &resp, sizeof(resp));\r\nif (ret < 0)\r\nreturn ret;\r\nif (!resp.supplies_count)\r\nreturn -EINVAL;\r\nsupplies->supplies_count = resp.supplies_count;\r\nreturn ret;\r\n}\r\nstatic int gb_power_supply_config(struct gb_power_supplies *supplies, int id)\r\n{\r\nstruct gb_power_supply *gbpsy = &supplies->supply[id];\r\nint ret;\r\ngbpsy->supplies = supplies;\r\ngbpsy->id = id;\r\nret = gb_power_supply_description_get(gbpsy);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn gb_power_supply_prop_descriptors_get(gbpsy);\r\n}\r\nstatic int gb_power_supply_enable(struct gb_power_supply *gbpsy)\r\n{\r\nint ret;\r\nret = __gb_power_supply_set_name(gbpsy->model_name, gbpsy->name,\r\nsizeof(gbpsy->name));\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&gbpsy->supply_lock);\r\nret = gb_power_supply_register(gbpsy);\r\nif (ret < 0)\r\nreturn ret;\r\ngbpsy->update_interval = update_interval_init;\r\nINIT_DELAYED_WORK(&gbpsy->work, gb_power_supply_work);\r\nschedule_delayed_work(&gbpsy->work, 0);\r\ngbpsy->registered = true;\r\nreturn 0;\r\n}\r\nstatic int gb_power_supplies_setup(struct gb_power_supplies *supplies)\r\n{\r\nstruct gb_connection *connection = supplies->connection;\r\nint ret;\r\nint i;\r\nmutex_lock(&supplies->supplies_lock);\r\nret = gb_power_supplies_get_count(supplies);\r\nif (ret < 0)\r\ngoto out;\r\nsupplies->supply = kzalloc(supplies->supplies_count *\r\nsizeof(struct gb_power_supply),\r\nGFP_KERNEL);\r\nif (!supplies->supply) {\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nfor (i = 0; i < supplies->supplies_count; i++) {\r\nret = gb_power_supply_config(supplies, i);\r\nif (ret < 0) {\r\ndev_err(&connection->bundle->dev,\r\n"Fail to configure supplies devices\n");\r\ngoto out;\r\n}\r\n}\r\nout:\r\nmutex_unlock(&supplies->supplies_lock);\r\nreturn ret;\r\n}\r\nstatic int gb_power_supplies_register(struct gb_power_supplies *supplies)\r\n{\r\nstruct gb_connection *connection = supplies->connection;\r\nint ret = 0;\r\nint i;\r\nmutex_lock(&supplies->supplies_lock);\r\nfor (i = 0; i < supplies->supplies_count; i++) {\r\nret = gb_power_supply_enable(&supplies->supply[i]);\r\nif (ret < 0) {\r\ndev_err(&connection->bundle->dev,\r\n"Fail to enable supplies devices\n");\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&supplies->supplies_lock);\r\nreturn ret;\r\n}\r\nstatic int gb_supplies_request_handler(struct gb_operation *op)\r\n{\r\nstruct gb_connection *connection = op->connection;\r\nstruct gb_power_supplies *supplies = gb_connection_get_data(connection);\r\nstruct gb_power_supply *gbpsy;\r\nstruct gb_message *request;\r\nstruct gb_power_supply_event_request *payload;\r\nu8 psy_id;\r\nu8 event;\r\nint ret = 0;\r\nif (op->type != GB_POWER_SUPPLY_TYPE_EVENT) {\r\ndev_err(&connection->bundle->dev,\r\n"Unsupported unsolicited event: %u\n", op->type);\r\nreturn -EINVAL;\r\n}\r\nrequest = op->request;\r\nif (request->payload_size < sizeof(*payload)) {\r\ndev_err(&connection->bundle->dev,\r\n"Wrong event size received (%zu < %zu)\n",\r\nrequest->payload_size, sizeof(*payload));\r\nreturn -EINVAL;\r\n}\r\npayload = request->payload;\r\npsy_id = payload->psy_id;\r\nmutex_lock(&supplies->supplies_lock);\r\nif (psy_id >= supplies->supplies_count ||\r\n!supplies->supply[psy_id].registered) {\r\ndev_err(&connection->bundle->dev,\r\n"Event received for unconfigured power_supply id: %d\n",\r\npsy_id);\r\nret = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nevent = payload->event;\r\ngbpsy = &supplies->supply[psy_id];\r\nif (!gbpsy->update_interval) {\r\nret = -ESHUTDOWN;\r\ngoto out_unlock;\r\n}\r\nif (event & GB_POWER_SUPPLY_UPDATE) {\r\ngbpsy->cache_invalid = 1;\r\ngb_power_supply_status_update(gbpsy);\r\n}\r\nout_unlock:\r\nmutex_unlock(&supplies->supplies_lock);\r\nreturn ret;\r\n}\r\nstatic int gb_power_supply_probe(struct gb_bundle *bundle,\r\nconst struct greybus_bundle_id *id)\r\n{\r\nstruct greybus_descriptor_cport *cport_desc;\r\nstruct gb_connection *connection;\r\nstruct gb_power_supplies *supplies;\r\nint ret;\r\nif (bundle->num_cports != 1)\r\nreturn -ENODEV;\r\ncport_desc = &bundle->cport_desc[0];\r\nif (cport_desc->protocol_id != GREYBUS_PROTOCOL_POWER_SUPPLY)\r\nreturn -ENODEV;\r\nsupplies = kzalloc(sizeof(*supplies), GFP_KERNEL);\r\nif (!supplies)\r\nreturn -ENOMEM;\r\nconnection = gb_connection_create(bundle, le16_to_cpu(cport_desc->id),\r\ngb_supplies_request_handler);\r\nif (IS_ERR(connection)) {\r\nret = PTR_ERR(connection);\r\ngoto out;\r\n}\r\nsupplies->connection = connection;\r\ngb_connection_set_data(connection, supplies);\r\nmutex_init(&supplies->supplies_lock);\r\ngreybus_set_drvdata(bundle, supplies);\r\nret = gb_connection_enable_tx(connection);\r\nif (ret)\r\ngoto error_connection_destroy;\r\nret = gb_power_supplies_setup(supplies);\r\nif (ret < 0)\r\ngoto error_connection_disable;\r\nret = gb_connection_enable(connection);\r\nif (ret)\r\ngoto error_connection_disable;\r\nret = gb_power_supplies_register(supplies);\r\nif (ret < 0)\r\ngoto error_connection_disable;\r\ngb_pm_runtime_put_autosuspend(bundle);\r\nreturn 0;\r\nerror_connection_disable:\r\ngb_connection_disable(connection);\r\nerror_connection_destroy:\r\ngb_connection_destroy(connection);\r\nout:\r\n_gb_power_supplies_release(supplies);\r\nreturn ret;\r\n}\r\nstatic void gb_power_supply_disconnect(struct gb_bundle *bundle)\r\n{\r\nstruct gb_power_supplies *supplies = greybus_get_drvdata(bundle);\r\ngb_connection_disable(supplies->connection);\r\ngb_connection_destroy(supplies->connection);\r\n_gb_power_supplies_release(supplies);\r\n}
