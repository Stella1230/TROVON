int cros_ec_sensors_core_init(struct platform_device *pdev,\r\nstruct iio_dev *indio_dev,\r\nbool physical_device)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct cros_ec_sensors_core_state *state = iio_priv(indio_dev);\r\nstruct cros_ec_dev *ec = dev_get_drvdata(pdev->dev.parent);\r\nstruct cros_ec_sensor_platform *sensor_platform = dev_get_platdata(dev);\r\nplatform_set_drvdata(pdev, indio_dev);\r\nstate->ec = ec->ec_dev;\r\nstate->msg = devm_kzalloc(&pdev->dev,\r\nmax((u16)sizeof(struct ec_params_motion_sense),\r\nstate->ec->max_response), GFP_KERNEL);\r\nif (!state->msg)\r\nreturn -ENOMEM;\r\nstate->resp = (struct ec_response_motion_sense *)state->msg->data;\r\nmutex_init(&state->cmd_lock);\r\nstate->msg->version = 2;\r\nstate->msg->command = EC_CMD_MOTION_SENSE_CMD + ec->cmd_offset;\r\nstate->msg->outsize = sizeof(struct ec_params_motion_sense);\r\nindio_dev->dev.parent = &pdev->dev;\r\nindio_dev->name = pdev->name;\r\nif (physical_device) {\r\nindio_dev->modes = INDIO_DIRECT_MODE;\r\nstate->param.cmd = MOTIONSENSE_CMD_INFO;\r\nstate->param.info.sensor_num = sensor_platform->sensor_num;\r\nif (cros_ec_motion_send_host_cmd(state, 0)) {\r\ndev_warn(dev, "Can not access sensor info\n");\r\nreturn -EIO;\r\n}\r\nstate->type = state->resp->info.type;\r\nstate->loc = state->resp->info.location;\r\n}\r\nreturn 0;\r\n}\r\nint cros_ec_motion_send_host_cmd(struct cros_ec_sensors_core_state *state,\r\nu16 opt_length)\r\n{\r\nint ret;\r\nif (opt_length)\r\nstate->msg->insize = min(opt_length, state->ec->max_response);\r\nelse\r\nstate->msg->insize = state->ec->max_response;\r\nmemcpy(state->msg->data, &state->param, sizeof(state->param));\r\nret = cros_ec_cmd_xfer_status(state->ec, state->msg);\r\nif (ret < 0)\r\nreturn -EIO;\r\nif (ret &&\r\nstate->resp != (struct ec_response_motion_sense *)state->msg->data)\r\nmemcpy(state->resp, state->msg->data, ret);\r\nreturn 0;\r\n}\r\nstatic ssize_t cros_ec_sensors_calibrate(struct iio_dev *indio_dev,\r\nuintptr_t private, const struct iio_chan_spec *chan,\r\nconst char *buf, size_t len)\r\n{\r\nstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\r\nint ret, i;\r\nbool calibrate;\r\nret = strtobool(buf, &calibrate);\r\nif (ret < 0)\r\nreturn ret;\r\nif (!calibrate)\r\nreturn -EINVAL;\r\nmutex_lock(&st->cmd_lock);\r\nst->param.cmd = MOTIONSENSE_CMD_PERFORM_CALIB;\r\nret = cros_ec_motion_send_host_cmd(st, 0);\r\nif (ret != 0) {\r\ndev_warn(&indio_dev->dev, "Unable to calibrate sensor\n");\r\n} else {\r\nfor (i = CROS_EC_SENSOR_X; i < CROS_EC_SENSOR_MAX_AXIS; i++)\r\nst->calib[i] = st->resp->perform_calib.offset[i];\r\n}\r\nmutex_unlock(&st->cmd_lock);\r\nreturn ret ? ret : len;\r\n}\r\nstatic ssize_t cros_ec_sensors_loc(struct iio_dev *indio_dev,\r\nuintptr_t private, const struct iio_chan_spec *chan,\r\nchar *buf)\r\n{\r\nstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\r\nreturn snprintf(buf, PAGE_SIZE, "%s\n", cros_ec_loc[st->loc]);\r\n}\r\nstatic unsigned int cros_ec_sensors_idx_to_reg(\r\nstruct cros_ec_sensors_core_state *st,\r\nunsigned int idx)\r\n{\r\nif (st->type == MOTIONSENSE_TYPE_ACCEL)\r\nreturn EC_MEMMAP_ACC_DATA + sizeof(u16) *\r\n(1 + idx + st->param.info.sensor_num *\r\nCROS_EC_SENSOR_MAX_AXIS);\r\nreturn EC_MEMMAP_GYRO_DATA + sizeof(u16) * idx;\r\n}\r\nstatic int cros_ec_sensors_cmd_read_u8(struct cros_ec_device *ec,\r\nunsigned int offset, u8 *dest)\r\n{\r\nreturn ec->cmd_readmem(ec, offset, 1, dest);\r\n}\r\nstatic int cros_ec_sensors_cmd_read_u16(struct cros_ec_device *ec,\r\nunsigned int offset, u16 *dest)\r\n{\r\n__le16 tmp;\r\nint ret = ec->cmd_readmem(ec, offset, 2, &tmp);\r\nif (ret >= 0)\r\n*dest = le16_to_cpu(tmp);\r\nreturn ret;\r\n}\r\nstatic int cros_ec_sensors_read_until_not_busy(\r\nstruct cros_ec_sensors_core_state *st)\r\n{\r\nstruct cros_ec_device *ec = st->ec;\r\nu8 status;\r\nint ret, attempts = 0;\r\nret = cros_ec_sensors_cmd_read_u8(ec, EC_MEMMAP_ACC_STATUS, &status);\r\nif (ret < 0)\r\nreturn ret;\r\nwhile (status & EC_MEMMAP_ACC_STATUS_BUSY_BIT) {\r\nif (attempts++ >= 50)\r\nreturn -EIO;\r\nif (attempts % 5 == 0)\r\nmsleep(25);\r\nret = cros_ec_sensors_cmd_read_u8(ec, EC_MEMMAP_ACC_STATUS,\r\n&status);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn status;\r\n}\r\nstatic int cros_ec_sensors_read_data_unsafe(struct iio_dev *indio_dev,\r\nunsigned long scan_mask, s16 *data)\r\n{\r\nstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\r\nstruct cros_ec_device *ec = st->ec;\r\nunsigned int i;\r\nint ret;\r\nfor_each_set_bit(i, &scan_mask, indio_dev->masklength) {\r\nret = cros_ec_sensors_cmd_read_u16(ec,\r\ncros_ec_sensors_idx_to_reg(st, i),\r\ndata);\r\nif (ret < 0)\r\nreturn ret;\r\ndata++;\r\n}\r\nreturn 0;\r\n}\r\nint cros_ec_sensors_read_lpc(struct iio_dev *indio_dev,\r\nunsigned long scan_mask, s16 *data)\r\n{\r\nstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\r\nstruct cros_ec_device *ec = st->ec;\r\nu8 samp_id = 0xff, status = 0;\r\nint ret, attempts = 0;\r\nwhile ((status & (EC_MEMMAP_ACC_STATUS_BUSY_BIT |\r\nEC_MEMMAP_ACC_STATUS_SAMPLE_ID_MASK)) != samp_id) {\r\nif (attempts++ >= 5)\r\nreturn -EIO;\r\nret = cros_ec_sensors_read_until_not_busy(st);\r\nif (ret < 0)\r\nreturn ret;\r\nsamp_id = ret & EC_MEMMAP_ACC_STATUS_SAMPLE_ID_MASK;\r\nret = cros_ec_sensors_read_data_unsafe(indio_dev, scan_mask,\r\ndata);\r\nif (ret < 0)\r\nreturn ret;\r\nret = cros_ec_sensors_cmd_read_u8(ec, EC_MEMMAP_ACC_STATUS,\r\n&status);\r\nif (ret < 0)\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nint cros_ec_sensors_read_cmd(struct iio_dev *indio_dev,\r\nunsigned long scan_mask, s16 *data)\r\n{\r\nstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\r\nint ret;\r\nunsigned int i;\r\nst->param.cmd = MOTIONSENSE_CMD_DATA;\r\nret = cros_ec_motion_send_host_cmd(st, sizeof(st->resp->data));\r\nif (ret != 0) {\r\ndev_warn(&indio_dev->dev, "Unable to read sensor data\n");\r\nreturn ret;\r\n}\r\nfor_each_set_bit(i, &scan_mask, indio_dev->masklength) {\r\n*data = st->resp->data.data[i];\r\ndata++;\r\n}\r\nreturn 0;\r\n}\r\nirqreturn_t cros_ec_sensors_capture(int irq, void *p)\r\n{\r\nstruct iio_poll_func *pf = p;\r\nstruct iio_dev *indio_dev = pf->indio_dev;\r\nstruct cros_ec_sensors_core_state *st = iio_priv(indio_dev);\r\nint ret;\r\nmutex_lock(&st->cmd_lock);\r\nmemset(st->samples, 0, indio_dev->scan_bytes);\r\nret = st->read_ec_sensors_data(indio_dev,\r\n*(indio_dev->active_scan_mask),\r\n(s16 *)st->samples);\r\nif (ret < 0)\r\ngoto done;\r\niio_push_to_buffers_with_timestamp(indio_dev, st->samples,\r\niio_get_time_ns(indio_dev));\r\ndone:\r\niio_trigger_notify_done(indio_dev->trig);\r\nmutex_unlock(&st->cmd_lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nint cros_ec_sensors_core_read(struct cros_ec_sensors_core_state *st,\r\nstruct iio_chan_spec const *chan,\r\nint *val, int *val2, long mask)\r\n{\r\nint ret = IIO_VAL_INT;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nst->param.cmd = MOTIONSENSE_CMD_EC_RATE;\r\nst->param.ec_rate.data =\r\nEC_MOTION_SENSE_NO_VALUE;\r\nif (cros_ec_motion_send_host_cmd(st, 0))\r\nret = -EIO;\r\nelse\r\n*val = st->resp->ec_rate.ret;\r\nbreak;\r\ncase IIO_CHAN_INFO_FREQUENCY:\r\nst->param.cmd = MOTIONSENSE_CMD_SENSOR_ODR;\r\nst->param.sensor_odr.data =\r\nEC_MOTION_SENSE_NO_VALUE;\r\nif (cros_ec_motion_send_host_cmd(st, 0))\r\nret = -EIO;\r\nelse\r\n*val = st->resp->sensor_odr.ret;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn ret;\r\n}\r\nint cros_ec_sensors_core_write(struct cros_ec_sensors_core_state *st,\r\nstruct iio_chan_spec const *chan,\r\nint val, int val2, long mask)\r\n{\r\nint ret = 0;\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_FREQUENCY:\r\nst->param.cmd = MOTIONSENSE_CMD_SENSOR_ODR;\r\nst->param.sensor_odr.data = val;\r\nst->param.sensor_odr.roundup = 1;\r\nif (cros_ec_motion_send_host_cmd(st, 0))\r\nret = -EIO;\r\nbreak;\r\ncase IIO_CHAN_INFO_SAMP_FREQ:\r\nst->param.cmd = MOTIONSENSE_CMD_EC_RATE;\r\nst->param.ec_rate.data = val;\r\nif (cros_ec_motion_send_host_cmd(st, 0))\r\nret = -EIO;\r\nelse\r\nst->curr_sampl_freq = val;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\nbreak;\r\n}\r\nreturn ret;\r\n}
