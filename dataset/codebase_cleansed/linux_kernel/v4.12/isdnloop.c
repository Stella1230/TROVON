static void\r\nisdnloop_free_queue(isdnloop_card *card, int channel)\r\n{\r\nstruct sk_buff_head *queue = &card->bqueue[channel];\r\nskb_queue_purge(queue);\r\ncard->sndcount[channel] = 0;\r\n}\r\nstatic void\r\nisdnloop_bchan_send(isdnloop_card *card, int ch)\r\n{\r\nisdnloop_card *rcard = card->rcard[ch];\r\nint rch = card->rch[ch], len, ack;\r\nstruct sk_buff *skb;\r\nisdn_ctrl cmd;\r\nwhile (card->sndcount[ch]) {\r\nskb = skb_dequeue(&card->bqueue[ch]);\r\nif (skb) {\r\nlen = skb->len;\r\ncard->sndcount[ch] -= len;\r\nack = *(skb->head);\r\ncmd.driver = card->myid;\r\ncmd.arg = ch;\r\nif (rcard) {\r\nrcard->interface.rcvcallb_skb(rcard->myid, rch, skb);\r\n} else {\r\nprintk(KERN_WARNING "isdnloop: no rcard, skb dropped\n");\r\ndev_kfree_skb(skb);\r\n};\r\ncmd.command = ISDN_STAT_BSENT;\r\ncmd.parm.length = len;\r\ncard->interface.statcallb(&cmd);\r\n} else\r\ncard->sndcount[ch] = 0;\r\n}\r\n}\r\nstatic void\r\nisdnloop_pollbchan(unsigned long data)\r\n{\r\nisdnloop_card *card = (isdnloop_card *) data;\r\nunsigned long flags;\r\nif (card->flags & ISDNLOOP_FLAGS_B1ACTIVE)\r\nisdnloop_bchan_send(card, 0);\r\nif (card->flags & ISDNLOOP_FLAGS_B2ACTIVE)\r\nisdnloop_bchan_send(card, 1);\r\nif (card->flags & (ISDNLOOP_FLAGS_B1ACTIVE | ISDNLOOP_FLAGS_B2ACTIVE)) {\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\ncard->rb_timer.expires = jiffies + ISDNLOOP_TIMER_BCREAD;\r\nadd_timer(&card->rb_timer);\r\ncard->flags |= ISDNLOOP_FLAGS_RBTIMER;\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n} else\r\ncard->flags &= ~ISDNLOOP_FLAGS_RBTIMER;\r\n}\r\nstatic void\r\nisdnloop_parse_setup(char *setup, isdn_ctrl *cmd)\r\n{\r\nchar *t = setup;\r\nchar *s = strchr(t, ',');\r\n*s++ = '\0';\r\nstrlcpy(cmd->parm.setup.phone, t, sizeof(cmd->parm.setup.phone));\r\ns = strchr(t = s, ',');\r\n*s++ = '\0';\r\nif (!strlen(t))\r\ncmd->parm.setup.si1 = 0;\r\nelse\r\ncmd->parm.setup.si1 = simple_strtoul(t, NULL, 10);\r\ns = strchr(t = s, ',');\r\n*s++ = '\0';\r\nif (!strlen(t))\r\ncmd->parm.setup.si2 = 0;\r\nelse\r\ncmd->parm.setup.si2 =\r\nsimple_strtoul(t, NULL, 10);\r\nstrlcpy(cmd->parm.setup.eazmsn, s, sizeof(cmd->parm.setup.eazmsn));\r\ncmd->parm.setup.plan = 0;\r\ncmd->parm.setup.screen = 0;\r\n}\r\nstatic void\r\nisdnloop_parse_status(u_char *status, int channel, isdnloop_card *card)\r\n{\r\nisdnloop_stat *s = isdnloop_stat_table;\r\nint action = -1;\r\nisdn_ctrl cmd;\r\nwhile (s->statstr) {\r\nif (!strncmp(status, s->statstr, strlen(s->statstr))) {\r\ncmd.command = s->command;\r\naction = s->action;\r\nbreak;\r\n}\r\ns++;\r\n}\r\nif (action == -1)\r\nreturn;\r\ncmd.driver = card->myid;\r\ncmd.arg = channel;\r\nswitch (action) {\r\ncase 1:\r\ncard->flags |= (channel) ?\r\nISDNLOOP_FLAGS_B2ACTIVE : ISDNLOOP_FLAGS_B1ACTIVE;\r\nbreak;\r\ncase 2:\r\ncard->flags &= ~((channel) ?\r\nISDNLOOP_FLAGS_B2ACTIVE : ISDNLOOP_FLAGS_B1ACTIVE);\r\nisdnloop_free_queue(card, channel);\r\nbreak;\r\ncase 3:\r\nisdnloop_parse_setup(status + 6, &cmd);\r\nbreak;\r\ncase 4:\r\nsprintf(cmd.parm.setup.phone, "LEASED%d", card->myid);\r\nsprintf(cmd.parm.setup.eazmsn, "%d", channel + 1);\r\ncmd.parm.setup.si1 = 7;\r\ncmd.parm.setup.si2 = 0;\r\ncmd.parm.setup.plan = 0;\r\ncmd.parm.setup.screen = 0;\r\nbreak;\r\ncase 5:\r\nstrlcpy(cmd.parm.num, status + 3, sizeof(cmd.parm.num));\r\nbreak;\r\ncase 6:\r\nsnprintf(cmd.parm.num, sizeof(cmd.parm.num), "%d",\r\n(int) simple_strtoul(status + 7, NULL, 16));\r\nbreak;\r\ncase 7:\r\nstatus += 3;\r\nif (strlen(status) == 4)\r\nsnprintf(cmd.parm.num, sizeof(cmd.parm.num), "%s%c%c",\r\nstatus + 2, *status, *(status + 1));\r\nelse\r\nstrlcpy(cmd.parm.num, status + 1, sizeof(cmd.parm.num));\r\nbreak;\r\ncase 8:\r\ncard->flags &= ~ISDNLOOP_FLAGS_B1ACTIVE;\r\nisdnloop_free_queue(card, 0);\r\ncmd.arg = 0;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncmd.command = ISDN_STAT_DHUP;\r\ncmd.arg = 0;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncmd.command = ISDN_STAT_BHUP;\r\ncard->flags &= ~ISDNLOOP_FLAGS_B2ACTIVE;\r\nisdnloop_free_queue(card, 1);\r\ncmd.arg = 1;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\ncmd.command = ISDN_STAT_DHUP;\r\ncmd.arg = 1;\r\ncmd.driver = card->myid;\r\nbreak;\r\n}\r\ncard->interface.statcallb(&cmd);\r\n}\r\nstatic void\r\nisdnloop_putmsg(isdnloop_card *card, unsigned char c)\r\n{\r\nulong flags;\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\n*card->msg_buf_write++ = (c == 0xff) ? '\n' : c;\r\nif (card->msg_buf_write == card->msg_buf_read) {\r\nif (++card->msg_buf_read > card->msg_buf_end)\r\ncard->msg_buf_read = card->msg_buf;\r\n}\r\nif (card->msg_buf_write > card->msg_buf_end)\r\ncard->msg_buf_write = card->msg_buf;\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nstatic void\r\nisdnloop_polldchan(unsigned long data)\r\n{\r\nisdnloop_card *card = (isdnloop_card *) data;\r\nstruct sk_buff *skb;\r\nint avail;\r\nint left;\r\nu_char c;\r\nint ch;\r\nunsigned long flags;\r\nu_char *p;\r\nisdn_ctrl cmd;\r\nskb = skb_dequeue(&card->dqueue);\r\nif (skb)\r\navail = skb->len;\r\nelse\r\navail = 0;\r\nfor (left = avail; left > 0; left--) {\r\nc = *skb->data;\r\nskb_pull(skb, 1);\r\nisdnloop_putmsg(card, c);\r\ncard->imsg[card->iptr] = c;\r\nif (card->iptr < 59)\r\ncard->iptr++;\r\nif (!skb->len) {\r\navail++;\r\nisdnloop_putmsg(card, '\n');\r\ncard->imsg[card->iptr] = 0;\r\ncard->iptr = 0;\r\nif (card->imsg[0] == '0' && card->imsg[1] >= '0' &&\r\ncard->imsg[1] <= '2' && card->imsg[2] == ';') {\r\nch = (card->imsg[1] - '0') - 1;\r\np = &card->imsg[3];\r\nisdnloop_parse_status(p, ch, card);\r\n} else {\r\np = card->imsg;\r\nif (!strncmp(p, "DRV1.", 5)) {\r\nprintk(KERN_INFO "isdnloop: (%s) %s\n", CID, p);\r\nif (!strncmp(p + 7, "TC", 2)) {\r\ncard->ptype = ISDN_PTYPE_1TR6;\r\ncard->interface.features |= ISDN_FEATURE_P_1TR6;\r\nprintk(KERN_INFO\r\n"isdnloop: (%s) 1TR6-Protocol loaded and running\n", CID);\r\n}\r\nif (!strncmp(p + 7, "EC", 2)) {\r\ncard->ptype = ISDN_PTYPE_EURO;\r\ncard->interface.features |= ISDN_FEATURE_P_EURO;\r\nprintk(KERN_INFO\r\n"isdnloop: (%s) Euro-Protocol loaded and running\n", CID);\r\n}\r\ncontinue;\r\n}\r\n}\r\n}\r\n}\r\nif (avail) {\r\ncmd.command = ISDN_STAT_STAVAIL;\r\ncmd.driver = card->myid;\r\ncmd.arg = avail;\r\ncard->interface.statcallb(&cmd);\r\n}\r\nif (card->flags & (ISDNLOOP_FLAGS_B1ACTIVE | ISDNLOOP_FLAGS_B2ACTIVE))\r\nif (!(card->flags & ISDNLOOP_FLAGS_RBTIMER)) {\r\ncard->flags |= ISDNLOOP_FLAGS_RBTIMER;\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\ndel_timer(&card->rb_timer);\r\ncard->rb_timer.function = isdnloop_pollbchan;\r\ncard->rb_timer.data = (unsigned long) card;\r\ncard->rb_timer.expires = jiffies + ISDNLOOP_TIMER_BCREAD;\r\nadd_timer(&card->rb_timer);\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\ncard->st_timer.expires = jiffies + ISDNLOOP_TIMER_DCREAD;\r\nadd_timer(&card->st_timer);\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nstatic int\r\nisdnloop_sendbuf(int channel, struct sk_buff *skb, isdnloop_card *card)\r\n{\r\nint len = skb->len;\r\nunsigned long flags;\r\nstruct sk_buff *nskb;\r\nif (len > 4000) {\r\nprintk(KERN_WARNING\r\n"isdnloop: Send packet too large\n");\r\nreturn -EINVAL;\r\n}\r\nif (len) {\r\nif (!(card->flags & (channel) ? ISDNLOOP_FLAGS_B2ACTIVE : ISDNLOOP_FLAGS_B1ACTIVE))\r\nreturn 0;\r\nif (card->sndcount[channel] > ISDNLOOP_MAX_SQUEUE)\r\nreturn 0;\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\nnskb = dev_alloc_skb(skb->len);\r\nif (nskb) {\r\nskb_copy_from_linear_data(skb,\r\nskb_put(nskb, len), len);\r\nskb_queue_tail(&card->bqueue[channel], nskb);\r\ndev_kfree_skb(skb);\r\n} else\r\nlen = 0;\r\ncard->sndcount[channel] += len;\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nreturn len;\r\n}\r\nstatic int\r\nisdnloop_readstatus(u_char __user *buf, int len, isdnloop_card *card)\r\n{\r\nint count;\r\nu_char __user *p;\r\nfor (p = buf, count = 0; count < len; p++, count++) {\r\nif (card->msg_buf_read == card->msg_buf_write)\r\nreturn count;\r\nif (put_user(*card->msg_buf_read++, p))\r\nreturn -EFAULT;\r\nif (card->msg_buf_read > card->msg_buf_end)\r\ncard->msg_buf_read = card->msg_buf;\r\n}\r\nreturn count;\r\n}\r\nstatic int\r\nisdnloop_fake(isdnloop_card *card, char *s, int ch)\r\n{\r\nstruct sk_buff *skb;\r\nint len = strlen(s) + ((ch >= 0) ? 3 : 0);\r\nskb = dev_alloc_skb(len);\r\nif (!skb) {\r\nprintk(KERN_WARNING "isdnloop: Out of memory in isdnloop_fake\n");\r\nreturn 1;\r\n}\r\nif (ch >= 0)\r\nsprintf(skb_put(skb, 3), "%02d;", ch);\r\nmemcpy(skb_put(skb, strlen(s)), s, strlen(s));\r\nskb_queue_tail(&card->dqueue, skb);\r\nreturn 0;\r\n}\r\nstatic void\r\nisdnloop_fake_err(isdnloop_card *card)\r\n{\r\nchar buf[64];\r\nsnprintf(buf, sizeof(buf), "E%s", card->omsg);\r\nisdnloop_fake(card, buf, -1);\r\nisdnloop_fake(card, "NAK", -1);\r\n}\r\nstatic char *\r\nisdnloop_unicause(isdnloop_card *card, int loc, int cau)\r\n{\r\nstatic char buf[6];\r\nswitch (card->ptype) {\r\ncase ISDN_PTYPE_EURO:\r\nsprintf(buf, "E%02X%02X", (loc) ? 4 : 2, ctable_eu[cau]);\r\nbreak;\r\ncase ISDN_PTYPE_1TR6:\r\nsprintf(buf, "%02X44", ctable_1t[cau]);\r\nbreak;\r\ndefault:\r\nreturn "0000";\r\n}\r\nreturn buf;\r\n}\r\nstatic void\r\nisdnloop_atimeout(isdnloop_card *card, int ch)\r\n{\r\nunsigned long flags;\r\nchar buf[60];\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\nif (card->rcard) {\r\nisdnloop_fake(card->rcard[ch], "DDIS_I", card->rch[ch] + 1);\r\ncard->rcard[ch]->rcard[card->rch[ch]] = NULL;\r\ncard->rcard[ch] = NULL;\r\n}\r\nisdnloop_fake(card, "DDIS_I", ch + 1);\r\nsprintf(buf, "CAU%s", isdnloop_unicause(card, 1, 3));\r\nisdnloop_fake(card, buf, ch + 1);\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nstatic void\r\nisdnloop_atimeout0(unsigned long data)\r\n{\r\nisdnloop_card *card = (isdnloop_card *) data;\r\nisdnloop_atimeout(card, 0);\r\n}\r\nstatic void\r\nisdnloop_atimeout1(unsigned long data)\r\n{\r\nisdnloop_card *card = (isdnloop_card *) data;\r\nisdnloop_atimeout(card, 1);\r\n}\r\nstatic void\r\nisdnloop_start_ctimer(isdnloop_card *card, int ch)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\ninit_timer(&card->c_timer[ch]);\r\ncard->c_timer[ch].expires = jiffies + ISDNLOOP_TIMER_ALERTWAIT;\r\nif (ch)\r\ncard->c_timer[ch].function = isdnloop_atimeout1;\r\nelse\r\ncard->c_timer[ch].function = isdnloop_atimeout0;\r\ncard->c_timer[ch].data = (unsigned long) card;\r\nadd_timer(&card->c_timer[ch]);\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nstatic void\r\nisdnloop_kill_ctimer(isdnloop_card *card, int ch)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\ndel_timer(&card->c_timer[ch]);\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nstatic int\r\nisdnloop_try_call(isdnloop_card *card, char *p, int lch, isdn_ctrl *cmd)\r\n{\r\nisdnloop_card *cc = cards;\r\nunsigned long flags;\r\nint ch;\r\nint num_match;\r\nint i;\r\nchar *e;\r\nchar nbuf[32];\r\nisdnloop_parse_setup(p, cmd);\r\nwhile (cc) {\r\nfor (ch = 0; ch < 2; ch++) {\r\nif ((cc == card) && (ch == lch))\r\ncontinue;\r\nnum_match = 0;\r\nswitch (cc->ptype) {\r\ncase ISDN_PTYPE_EURO:\r\nfor (i = 0; i < 3; i++)\r\nif (!(strcmp(cc->s0num[i], cmd->parm.setup.phone)))\r\nnum_match = 1;\r\nbreak;\r\ncase ISDN_PTYPE_1TR6:\r\ne = cc->eazlist[ch];\r\nwhile (*e) {\r\nsprintf(nbuf, "%s%c", cc->s0num[0], *e);\r\nif (!(strcmp(nbuf, cmd->parm.setup.phone)))\r\nnum_match = 1;\r\ne++;\r\n}\r\n}\r\nif (num_match) {\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\nif (!(cc->rcard[ch])) {\r\nif (!(si2bit[cmd->parm.setup.si1] & cc->sil[ch])) {\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn 3;\r\n}\r\ncc->rcard[ch] = card;\r\ncc->rch[ch] = lch;\r\ncard->rcard[lch] = cc;\r\ncard->rch[lch] = ch;\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn 0;\r\n} else {\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nif (ch == 1)\r\nreturn 1;\r\n}\r\n}\r\n}\r\ncc = cc->next;\r\n}\r\nreturn 2;\r\n}\r\nstatic char *\r\nisdnloop_vstphone(isdnloop_card *card, char *phone, int caller)\r\n{\r\nint i;\r\nstatic char nphone[30];\r\nif (!card) {\r\nprintk("BUG!!!\n");\r\nreturn "";\r\n}\r\nswitch (card->ptype) {\r\ncase ISDN_PTYPE_EURO:\r\nif (caller) {\r\nfor (i = 0; i < 2; i++)\r\nif (!(strcmp(card->s0num[i], phone)))\r\nreturn phone;\r\nreturn card->s0num[0];\r\n}\r\nreturn phone;\r\nbreak;\r\ncase ISDN_PTYPE_1TR6:\r\nif (caller) {\r\nsprintf(nphone, "%s%c", card->s0num[0], phone[0]);\r\nreturn nphone;\r\n} else\r\nreturn &phone[strlen(phone) - 1];\r\nbreak;\r\n}\r\nreturn "";\r\n}\r\nstatic void\r\nisdnloop_parse_cmd(isdnloop_card *card)\r\n{\r\nchar *p = card->omsg;\r\nisdn_ctrl cmd;\r\nchar buf[60];\r\nisdnloop_stat *s = isdnloop_cmd_table;\r\nint action = -1;\r\nint i;\r\nint ch;\r\nif ((card->omsg[0] != '0') && (card->omsg[2] != ';')) {\r\nisdnloop_fake_err(card);\r\nreturn;\r\n}\r\nch = card->omsg[1] - '0';\r\nif ((ch < 0) || (ch > 2)) {\r\nisdnloop_fake_err(card);\r\nreturn;\r\n}\r\np += 3;\r\nwhile (s->statstr) {\r\nif (!strncmp(p, s->statstr, strlen(s->statstr))) {\r\naction = s->action;\r\nif (s->command && (ch != 0)) {\r\nisdnloop_fake_err(card);\r\nreturn;\r\n}\r\nbreak;\r\n}\r\ns++;\r\n}\r\nif (action == -1)\r\nreturn;\r\nswitch (action) {\r\ncase 1:\r\nif (card->rcard[ch - 1]) {\r\nisdnloop_fake(card->rcard[ch - 1], "BCON_I",\r\ncard->rch[ch - 1] + 1);\r\nisdnloop_fake(card, "BCON_C", ch);\r\n}\r\nbreak;\r\ncase 17:\r\nif (card->rcard[ch - 1]) {\r\nisdnloop_fake(card->rcard[ch - 1], "BCON_C",\r\ncard->rch[ch - 1] + 1);\r\n}\r\nbreak;\r\ncase 2:\r\nisdnloop_fake(card, "BDIS_C", ch);\r\nif (card->rcard[ch - 1]) {\r\nisdnloop_fake(card->rcard[ch - 1], "BDIS_I",\r\ncard->rch[ch - 1] + 1);\r\n}\r\nbreak;\r\ncase 16:\r\nisdnloop_kill_ctimer(card, ch - 1);\r\nif (card->rcard[ch - 1]) {\r\nisdnloop_kill_ctimer(card->rcard[ch - 1], card->rch[ch - 1]);\r\nisdnloop_fake(card->rcard[ch - 1], "DCON_C",\r\ncard->rch[ch - 1] + 1);\r\nisdnloop_fake(card, "DCON_C", ch);\r\n}\r\nbreak;\r\ncase 3:\r\nisdnloop_kill_ctimer(card, ch - 1);\r\nif (card->rcard[ch - 1]) {\r\nisdnloop_kill_ctimer(card->rcard[ch - 1], card->rch[ch - 1]);\r\nisdnloop_fake(card->rcard[ch - 1], "DDIS_I",\r\ncard->rch[ch - 1] + 1);\r\ncard->rcard[ch - 1] = NULL;\r\n}\r\nisdnloop_fake(card, "DDIS_C", ch);\r\nbreak;\r\ncase 4:\r\nif (card->ptype != ISDN_PTYPE_1TR6) {\r\nisdnloop_fake_err(card);\r\nreturn;\r\n}\r\ncase 5:\r\np += 6;\r\nswitch (isdnloop_try_call(card, p, ch - 1, &cmd)) {\r\ncase 0:\r\nsprintf(buf, "D%s_I%s,%02d,%02d,%s",\r\n(action == 4) ? "SCA" : "CAL",\r\nisdnloop_vstphone(card, cmd.parm.setup.eazmsn, 1),\r\ncmd.parm.setup.si1,\r\ncmd.parm.setup.si2,\r\nisdnloop_vstphone(card->rcard[ch - 1],\r\ncmd.parm.setup.phone, 0));\r\nisdnloop_fake(card->rcard[ch - 1], buf, card->rch[ch - 1] + 1);\r\ncase 3:\r\nisdnloop_start_ctimer(card, ch - 1);\r\nbreak;\r\ncase 1:\r\nisdnloop_fake(card, "DDIS_I", ch);\r\nsprintf(buf, "CAU%s", isdnloop_unicause(card, 1, 1));\r\nisdnloop_fake(card, buf, ch);\r\nbreak;\r\ncase 2:\r\nisdnloop_fake(card, "DDIS_I", ch);\r\nsprintf(buf, "CAU%s", isdnloop_unicause(card, 1, 2));\r\nisdnloop_fake(card, buf, ch);\r\nbreak;\r\n}\r\nbreak;\r\ncase 6:\r\ncard->eazlist[ch - 1][0] = '\0';\r\nbreak;\r\ncase 7:\r\np += 3;\r\nif (strlen(p) >= sizeof(card->eazlist[0]))\r\nbreak;\r\nstrcpy(card->eazlist[ch - 1], p);\r\nbreak;\r\ncase 8:\r\nsprintf(buf, "EAZ-LIST: %s", card->eazlist[ch - 1]);\r\nisdnloop_fake(card, buf, ch + 1);\r\nbreak;\r\ncase 9:\r\nbreak;\r\ncase 10:\r\nbreak;\r\ncase 11:\r\np += 6;\r\ni = 0;\r\nwhile (strchr("0157", *p)) {\r\nif (i)\r\ncard->sil[ch - 1] |= si2bit[*p - '0'];\r\ni = (*p++ == '0');\r\n}\r\nif (*p)\r\nisdnloop_fake_err(card);\r\nbreak;\r\ncase 12:\r\nsprintf(buf, "SIN-LIST: ");\r\np = buf + 10;\r\nfor (i = 0; i < 3; i++)\r\nif (card->sil[ch - 1] & (1 << i))\r\np += sprintf(p, "%02d", bit2si[i]);\r\nisdnloop_fake(card, buf, ch + 1);\r\nbreak;\r\ncase 13:\r\ncard->sil[ch - 1] = 0;\r\nbreak;\r\ncase 14:\r\nbreak;\r\ncase 15:\r\nbreak;\r\n}\r\n}\r\nstatic int\r\nisdnloop_writecmd(const u_char *buf, int len, int user, isdnloop_card *card)\r\n{\r\nint xcount = 0;\r\nint ocount = 1;\r\nisdn_ctrl cmd;\r\nwhile (len) {\r\nint count = len;\r\nu_char *p;\r\nu_char msg[0x100];\r\nif (count > 255)\r\ncount = 255;\r\nif (user) {\r\nif (copy_from_user(msg, buf, count))\r\nreturn -EFAULT;\r\n} else\r\nmemcpy(msg, buf, count);\r\nisdnloop_putmsg(card, '>');\r\nfor (p = msg; count > 0; count--, p++) {\r\nlen--;\r\nxcount++;\r\nisdnloop_putmsg(card, *p);\r\ncard->omsg[card->optr] = *p;\r\nif (*p == '\n') {\r\ncard->omsg[card->optr] = '\0';\r\ncard->optr = 0;\r\nisdnloop_parse_cmd(card);\r\nif (len) {\r\nisdnloop_putmsg(card, '>');\r\nocount++;\r\n}\r\n} else {\r\nif (card->optr < 59)\r\ncard->optr++;\r\n}\r\nocount++;\r\n}\r\n}\r\ncmd.command = ISDN_STAT_STAVAIL;\r\ncmd.driver = card->myid;\r\ncmd.arg = ocount;\r\ncard->interface.statcallb(&cmd);\r\nreturn xcount;\r\n}\r\nstatic void\r\nisdnloop_stopcard(isdnloop_card *card)\r\n{\r\nunsigned long flags;\r\nisdn_ctrl cmd;\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\nif (card->flags & ISDNLOOP_FLAGS_RUNNING) {\r\ncard->flags &= ~ISDNLOOP_FLAGS_RUNNING;\r\ndel_timer(&card->st_timer);\r\ndel_timer(&card->rb_timer);\r\ndel_timer(&card->c_timer[0]);\r\ndel_timer(&card->c_timer[1]);\r\ncmd.command = ISDN_STAT_STOP;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\n}\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\n}\r\nstatic void\r\nisdnloop_stopallcards(void)\r\n{\r\nisdnloop_card *p = cards;\r\nwhile (p) {\r\nisdnloop_stopcard(p);\r\np = p->next;\r\n}\r\n}\r\nstatic int\r\nisdnloop_start(isdnloop_card *card, isdnloop_sdef *sdefp)\r\n{\r\nunsigned long flags;\r\nisdnloop_sdef sdef;\r\nint i;\r\nif (card->flags & ISDNLOOP_FLAGS_RUNNING)\r\nreturn -EBUSY;\r\nif (copy_from_user((char *) &sdef, (char *) sdefp, sizeof(sdef)))\r\nreturn -EFAULT;\r\nfor (i = 0; i < 3; i++) {\r\nif (!memchr(sdef.num[i], 0, sizeof(sdef.num[i])))\r\nreturn -EINVAL;\r\n}\r\nspin_lock_irqsave(&card->isdnloop_lock, flags);\r\nswitch (sdef.ptype) {\r\ncase ISDN_PTYPE_EURO:\r\nif (isdnloop_fake(card, "DRV1.23EC-Q.931-CAPI-CNS-BASIS-20.02.96",\r\n-1)) {\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\ncard->sil[0] = card->sil[1] = 4;\r\nif (isdnloop_fake(card, "TEI OK", 0)) {\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nstrlcpy(card->s0num[i], sdef.num[i],\r\nsizeof(card->s0num[0]));\r\n}\r\nbreak;\r\ncase ISDN_PTYPE_1TR6:\r\nif (isdnloop_fake(card, "DRV1.04TC-1TR6-CAPI-CNS-BASIS-29.11.95",\r\n-1)) {\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\ncard->sil[0] = card->sil[1] = 4;\r\nif (isdnloop_fake(card, "TEI OK", 0)) {\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn -ENOMEM;\r\n}\r\nstrlcpy(card->s0num[0], sdef.num[0], sizeof(card->s0num[0]));\r\ncard->s0num[1][0] = '\0';\r\ncard->s0num[2][0] = '\0';\r\nbreak;\r\ndefault:\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nprintk(KERN_WARNING "isdnloop: Illegal D-channel protocol %d\n",\r\nsdef.ptype);\r\nreturn -EINVAL;\r\n}\r\ninit_timer(&card->st_timer);\r\ncard->st_timer.expires = jiffies + ISDNLOOP_TIMER_DCREAD;\r\ncard->st_timer.function = isdnloop_polldchan;\r\ncard->st_timer.data = (unsigned long) card;\r\nadd_timer(&card->st_timer);\r\ncard->flags |= ISDNLOOP_FLAGS_RUNNING;\r\nspin_unlock_irqrestore(&card->isdnloop_lock, flags);\r\nreturn 0;\r\n}\r\nstatic int\r\nisdnloop_command(isdn_ctrl *c, isdnloop_card *card)\r\n{\r\nulong a;\r\nint i;\r\nchar cbuf[80];\r\nisdn_ctrl cmd;\r\nisdnloop_cdef cdef;\r\nswitch (c->command) {\r\ncase ISDN_CMD_IOCTL:\r\nmemcpy(&a, c->parm.num, sizeof(ulong));\r\nswitch (c->arg) {\r\ncase ISDNLOOP_IOCTL_DEBUGVAR:\r\nreturn (ulong) card;\r\ncase ISDNLOOP_IOCTL_STARTUP:\r\nif (!access_ok(VERIFY_READ, (void *) a, sizeof(isdnloop_sdef)))\r\nreturn -EFAULT;\r\nreturn isdnloop_start(card, (isdnloop_sdef *) a);\r\nbreak;\r\ncase ISDNLOOP_IOCTL_ADDCARD:\r\nif (copy_from_user((char *)&cdef,\r\n(char *)a,\r\nsizeof(cdef)))\r\nreturn -EFAULT;\r\nreturn isdnloop_addcard(cdef.id1);\r\nbreak;\r\ncase ISDNLOOP_IOCTL_LEASEDCFG:\r\nif (a) {\r\nif (!card->leased) {\r\ncard->leased = 1;\r\nwhile (card->ptype == ISDN_PTYPE_UNKNOWN)\r\nschedule_timeout_interruptible(10);\r\nschedule_timeout_interruptible(10);\r\nsprintf(cbuf, "00;FV2ON\n01;EAZ1\n02;EAZ2\n");\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\nprintk(KERN_INFO\r\n"isdnloop: (%s) Leased-line mode enabled\n",\r\nCID);\r\ncmd.command = ISDN_STAT_RUN;\r\ncmd.driver = card->myid;\r\ncmd.arg = 0;\r\ncard->interface.statcallb(&cmd);\r\n}\r\n} else {\r\nif (card->leased) {\r\ncard->leased = 0;\r\nsprintf(cbuf, "00;FV2OFF\n");\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\nprintk(KERN_INFO\r\n"isdnloop: (%s) Leased-line mode disabled\n",\r\nCID);\r\ncmd.command = ISDN_STAT_RUN;\r\ncmd.driver = card->myid;\r\ncmd.arg = 0;\r\ncard->interface.statcallb(&cmd);\r\n}\r\n}\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase ISDN_CMD_DIAL:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (card->leased)\r\nbreak;\r\nif ((c->arg & 255) < ISDNLOOP_BCH) {\r\nchar *p;\r\nchar dcode[4];\r\na = c->arg;\r\np = c->parm.setup.phone;\r\nif (*p == 's' || *p == 'S') {\r\np++;\r\nstrcpy(dcode, "SCA");\r\n} else\r\nstrcpy(dcode, "CAL");\r\nsnprintf(cbuf, sizeof(cbuf),\r\n"%02d;D%s_R%s,%02d,%02d,%s\n", (int) (a + 1),\r\ndcode, p, c->parm.setup.si1,\r\nc->parm.setup.si2, c->parm.setup.eazmsn);\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_ACCEPTD:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (c->arg < ISDNLOOP_BCH) {\r\na = c->arg + 1;\r\ncbuf[0] = 0;\r\nswitch (card->l2_proto[a - 1]) {\r\ncase ISDN_PROTO_L2_X75I:\r\nsprintf(cbuf, "%02d;BX75\n", (int) a);\r\nbreak;\r\n#ifdef CONFIG_ISDN_X25\r\ncase ISDN_PROTO_L2_X25DTE:\r\nsprintf(cbuf, "%02d;BX2T\n", (int) a);\r\nbreak;\r\ncase ISDN_PROTO_L2_X25DCE:\r\nsprintf(cbuf, "%02d;BX2C\n", (int) a);\r\nbreak;\r\n#endif\r\ncase ISDN_PROTO_L2_HDLC:\r\nsprintf(cbuf, "%02d;BTRA\n", (int) a);\r\nbreak;\r\n}\r\nif (strlen(cbuf))\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\nsprintf(cbuf, "%02d;DCON_R\n", (int) a);\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_ACCEPTB:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (c->arg < ISDNLOOP_BCH) {\r\na = c->arg + 1;\r\nswitch (card->l2_proto[a - 1]) {\r\ncase ISDN_PROTO_L2_X75I:\r\nsprintf(cbuf, "%02d;BCON_R,BX75\n", (int) a);\r\nbreak;\r\n#ifdef CONFIG_ISDN_X25\r\ncase ISDN_PROTO_L2_X25DTE:\r\nsprintf(cbuf, "%02d;BCON_R,BX2T\n", (int) a);\r\nbreak;\r\ncase ISDN_PROTO_L2_X25DCE:\r\nsprintf(cbuf, "%02d;BCON_R,BX2C\n", (int) a);\r\nbreak;\r\n#endif\r\ncase ISDN_PROTO_L2_HDLC:\r\nsprintf(cbuf, "%02d;BCON_R,BTRA\n", (int) a);\r\nbreak;\r\ndefault:\r\nsprintf(cbuf, "%02d;BCON_R\n", (int) a);\r\n}\r\nprintk(KERN_DEBUG "isdnloop writecmd '%s'\n", cbuf);\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\nbreak;\r\ncase ISDN_CMD_HANGUP:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (c->arg < ISDNLOOP_BCH) {\r\na = c->arg + 1;\r\nsprintf(cbuf, "%02d;BDIS_R\n%02d;DDIS_R\n", (int) a, (int) a);\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETEAZ:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (card->leased)\r\nbreak;\r\nif (c->arg < ISDNLOOP_BCH) {\r\na = c->arg + 1;\r\nif (card->ptype == ISDN_PTYPE_EURO) {\r\nsprintf(cbuf, "%02d;MS%s%s\n", (int) a,\r\nc->parm.num[0] ? "N" : "ALL", c->parm.num);\r\n} else\r\nsprintf(cbuf, "%02d;EAZ%s\n", (int) a,\r\nc->parm.num[0] ? c->parm.num : (u_char *) "0123456789");\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_CLREAZ:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif (card->leased)\r\nbreak;\r\nif (c->arg < ISDNLOOP_BCH) {\r\na = c->arg + 1;\r\nif (card->ptype == ISDN_PTYPE_EURO)\r\nsprintf(cbuf, "%02d;MSNC\n", (int) a);\r\nelse\r\nsprintf(cbuf, "%02d;EAZC\n", (int) a);\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETL2:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nif ((c->arg & 255) < ISDNLOOP_BCH) {\r\na = c->arg;\r\nswitch (a >> 8) {\r\ncase ISDN_PROTO_L2_X75I:\r\nsprintf(cbuf, "%02d;BX75\n", (int) (a & 255) + 1);\r\nbreak;\r\n#ifdef CONFIG_ISDN_X25\r\ncase ISDN_PROTO_L2_X25DTE:\r\nsprintf(cbuf, "%02d;BX2T\n", (int) (a & 255) + 1);\r\nbreak;\r\ncase ISDN_PROTO_L2_X25DCE:\r\nsprintf(cbuf, "%02d;BX2C\n", (int) (a & 255) + 1);\r\nbreak;\r\n#endif\r\ncase ISDN_PROTO_L2_HDLC:\r\nsprintf(cbuf, "%02d;BTRA\n", (int) (a & 255) + 1);\r\nbreak;\r\ncase ISDN_PROTO_L2_TRANS:\r\nsprintf(cbuf, "%02d;BTRA\n", (int) (a & 255) + 1);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ni = isdnloop_writecmd(cbuf, strlen(cbuf), 0, card);\r\ncard->l2_proto[a & 255] = (a >> 8);\r\n}\r\nbreak;\r\ncase ISDN_CMD_SETL3:\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn 0;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic inline isdnloop_card *\r\nisdnloop_findcard(int driverid)\r\n{\r\nisdnloop_card *p = cards;\r\nwhile (p) {\r\nif (p->myid == driverid)\r\nreturn p;\r\np = p->next;\r\n}\r\nreturn (isdnloop_card *) 0;\r\n}\r\nstatic int\r\nif_command(isdn_ctrl *c)\r\n{\r\nisdnloop_card *card = isdnloop_findcard(c->driver);\r\nif (card)\r\nreturn isdnloop_command(c, card);\r\nprintk(KERN_ERR\r\n"isdnloop: if_command called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nif_writecmd(const u_char __user *buf, int len, int id, int channel)\r\n{\r\nisdnloop_card *card = isdnloop_findcard(id);\r\nif (card) {\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn isdnloop_writecmd(buf, len, 1, card);\r\n}\r\nprintk(KERN_ERR\r\n"isdnloop: if_writecmd called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nif_readstatus(u_char __user *buf, int len, int id, int channel)\r\n{\r\nisdnloop_card *card = isdnloop_findcard(id);\r\nif (card) {\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\nreturn isdnloop_readstatus(buf, len, card);\r\n}\r\nprintk(KERN_ERR\r\n"isdnloop: if_readstatus called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic int\r\nif_sendbuf(int id, int channel, int ack, struct sk_buff *skb)\r\n{\r\nisdnloop_card *card = isdnloop_findcard(id);\r\nif (card) {\r\nif (!(card->flags & ISDNLOOP_FLAGS_RUNNING))\r\nreturn -ENODEV;\r\n*(skb->head) = ack;\r\nreturn isdnloop_sendbuf(channel, skb, card);\r\n}\r\nprintk(KERN_ERR\r\n"isdnloop: if_sendbuf called with invalid driverId!\n");\r\nreturn -ENODEV;\r\n}\r\nstatic isdnloop_card *\r\nisdnloop_initcard(char *id)\r\n{\r\nisdnloop_card *card;\r\nint i;\r\ncard = kzalloc(sizeof(isdnloop_card), GFP_KERNEL);\r\nif (!card) {\r\nprintk(KERN_WARNING\r\n"isdnloop: (%s) Could not allocate card-struct.\n", id);\r\nreturn (isdnloop_card *) 0;\r\n}\r\ncard->interface.owner = THIS_MODULE;\r\ncard->interface.channels = ISDNLOOP_BCH;\r\ncard->interface.hl_hdrlen = 1;\r\ncard->interface.maxbufsize = 4000;\r\ncard->interface.command = if_command;\r\ncard->interface.writebuf_skb = if_sendbuf;\r\ncard->interface.writecmd = if_writecmd;\r\ncard->interface.readstat = if_readstatus;\r\ncard->interface.features = ISDN_FEATURE_L2_X75I |\r\n#ifdef CONFIG_ISDN_X25\r\nISDN_FEATURE_L2_X25DTE |\r\nISDN_FEATURE_L2_X25DCE |\r\n#endif\r\nISDN_FEATURE_L2_HDLC |\r\nISDN_FEATURE_L3_TRANS |\r\nISDN_FEATURE_P_UNKNOWN;\r\ncard->ptype = ISDN_PTYPE_UNKNOWN;\r\nstrlcpy(card->interface.id, id, sizeof(card->interface.id));\r\ncard->msg_buf_write = card->msg_buf;\r\ncard->msg_buf_read = card->msg_buf;\r\ncard->msg_buf_end = &card->msg_buf[sizeof(card->msg_buf) - 1];\r\nfor (i = 0; i < ISDNLOOP_BCH; i++) {\r\ncard->l2_proto[i] = ISDN_PROTO_L2_X75I;\r\nskb_queue_head_init(&card->bqueue[i]);\r\n}\r\nskb_queue_head_init(&card->dqueue);\r\nspin_lock_init(&card->isdnloop_lock);\r\ncard->next = cards;\r\ncards = card;\r\nif (!register_isdn(&card->interface)) {\r\ncards = cards->next;\r\nprintk(KERN_WARNING\r\n"isdnloop: Unable to register %s\n", id);\r\nkfree(card);\r\nreturn (isdnloop_card *) 0;\r\n}\r\ncard->myid = card->interface.channels;\r\nreturn card;\r\n}\r\nstatic int\r\nisdnloop_addcard(char *id1)\r\n{\r\nisdnloop_card *card;\r\ncard = isdnloop_initcard(id1);\r\nif (!card) {\r\nreturn -EIO;\r\n}\r\nprintk(KERN_INFO\r\n"isdnloop: (%s) virtual card added\n",\r\ncard->interface.id);\r\nreturn 0;\r\n}\r\nstatic int __init\r\nisdnloop_init(void)\r\n{\r\nif (isdnloop_id)\r\nreturn isdnloop_addcard(isdnloop_id);\r\nreturn 0;\r\n}\r\nstatic void __exit\r\nisdnloop_exit(void)\r\n{\r\nisdn_ctrl cmd;\r\nisdnloop_card *card = cards;\r\nisdnloop_card *last;\r\nint i;\r\nisdnloop_stopallcards();\r\nwhile (card) {\r\ncmd.command = ISDN_STAT_UNLOAD;\r\ncmd.driver = card->myid;\r\ncard->interface.statcallb(&cmd);\r\nfor (i = 0; i < ISDNLOOP_BCH; i++)\r\nisdnloop_free_queue(card, i);\r\ncard = card->next;\r\n}\r\ncard = cards;\r\nwhile (card) {\r\nlast = card;\r\nskb_queue_purge(&card->dqueue);\r\ncard = card->next;\r\nkfree(last);\r\n}\r\nprintk(KERN_NOTICE "isdnloop-ISDN-driver unloaded\n");\r\n}
