static bool rt298_volatile_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0 ... 0xff:\r\ncase RT298_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\r\ncase RT298_GET_HP_SENSE:\r\ncase RT298_GET_MIC1_SENSE:\r\ncase RT298_PROC_COEF:\r\ncase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_MIC1, 0):\r\ncase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_SPK_OUT, 0):\r\ncase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_HP_OUT, 0):\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool rt298_readable_register(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase 0 ... 0xff:\r\ncase RT298_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID):\r\ncase RT298_GET_HP_SENSE:\r\ncase RT298_GET_MIC1_SENSE:\r\ncase RT298_SET_AUDIO_POWER:\r\ncase RT298_SET_HPO_POWER:\r\ncase RT298_SET_SPK_POWER:\r\ncase RT298_SET_DMIC1_POWER:\r\ncase RT298_SPK_MUX:\r\ncase RT298_HPO_MUX:\r\ncase RT298_ADC0_MUX:\r\ncase RT298_ADC1_MUX:\r\ncase RT298_SET_MIC1:\r\ncase RT298_SET_PIN_HPO:\r\ncase RT298_SET_PIN_SPK:\r\ncase RT298_SET_PIN_DMIC1:\r\ncase RT298_SPK_EAPD:\r\ncase RT298_SET_AMP_GAIN_HPO:\r\ncase RT298_SET_DMIC2_DEFAULT:\r\ncase RT298_DACL_GAIN:\r\ncase RT298_DACR_GAIN:\r\ncase RT298_ADCL_GAIN:\r\ncase RT298_ADCR_GAIN:\r\ncase RT298_MIC_GAIN:\r\ncase RT298_SPOL_GAIN:\r\ncase RT298_SPOR_GAIN:\r\ncase RT298_HPOL_GAIN:\r\ncase RT298_HPOR_GAIN:\r\ncase RT298_F_DAC_SWITCH:\r\ncase RT298_F_RECMIX_SWITCH:\r\ncase RT298_REC_MIC_SWITCH:\r\ncase RT298_REC_I2S_SWITCH:\r\ncase RT298_REC_LINE_SWITCH:\r\ncase RT298_REC_BEEP_SWITCH:\r\ncase RT298_DAC_FORMAT:\r\ncase RT298_ADC_FORMAT:\r\ncase RT298_COEF_INDEX:\r\ncase RT298_PROC_COEF:\r\ncase RT298_SET_AMP_GAIN_ADC_IN1:\r\ncase RT298_SET_AMP_GAIN_ADC_IN2:\r\ncase RT298_SET_POWER(RT298_DAC_OUT1):\r\ncase RT298_SET_POWER(RT298_DAC_OUT2):\r\ncase RT298_SET_POWER(RT298_ADC_IN1):\r\ncase RT298_SET_POWER(RT298_ADC_IN2):\r\ncase RT298_SET_POWER(RT298_DMIC2):\r\ncase RT298_SET_POWER(RT298_MIC1):\r\ncase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_MIC1, 0):\r\ncase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_SPK_OUT, 0):\r\ncase VERB_CMD(AC_VERB_GET_EAPD_BTLENABLE, RT298_HP_OUT, 0):\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic void rt298_index_sync(struct snd_soc_codec *codec)\r\n{\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nint i;\r\nfor (i = 0; i < INDEX_CACHE_SIZE; i++) {\r\nsnd_soc_write(codec, rt298->index_cache[i].reg,\r\nrt298->index_cache[i].def);\r\n}\r\n}\r\nstatic int rt298_jack_detect(struct rt298_priv *rt298, bool *hp, bool *mic)\r\n{\r\nstruct snd_soc_dapm_context *dapm;\r\nunsigned int val, buf;\r\n*hp = false;\r\n*mic = false;\r\nif (!rt298->codec)\r\nreturn -EINVAL;\r\ndapm = snd_soc_codec_get_dapm(rt298->codec);\r\nif (rt298->pdata.cbj_en) {\r\nregmap_read(rt298->regmap, RT298_GET_HP_SENSE, &buf);\r\n*hp = buf & 0x80000000;\r\nif (*hp == rt298->is_hp_in)\r\nreturn -1;\r\nrt298->is_hp_in = *hp;\r\nif (*hp) {\r\nregmap_update_bits(rt298->regmap,\r\nRT298_DC_GAIN, 0x200, 0x200);\r\nsnd_soc_dapm_force_enable_pin(dapm, "HV");\r\nsnd_soc_dapm_force_enable_pin(dapm, "VREF");\r\nsnd_soc_dapm_force_enable_pin(dapm, "LDO1");\r\nsnd_soc_dapm_sync(dapm);\r\nregmap_update_bits(rt298->regmap,\r\nRT298_POWER_CTRL1, 0x1001, 0);\r\nregmap_update_bits(rt298->regmap,\r\nRT298_POWER_CTRL2, 0x4, 0x4);\r\nregmap_write(rt298->regmap, RT298_SET_MIC1, 0x24);\r\nmsleep(50);\r\nregmap_update_bits(rt298->regmap,\r\nRT298_CBJ_CTRL1, 0xfcc0, 0xd400);\r\nmsleep(300);\r\nregmap_read(rt298->regmap, RT298_CBJ_CTRL2, &val);\r\nif (0x0070 == (val & 0x0070)) {\r\n*mic = true;\r\n} else {\r\nregmap_update_bits(rt298->regmap,\r\nRT298_CBJ_CTRL1, 0xfcc0, 0xe400);\r\nmsleep(300);\r\nregmap_read(rt298->regmap,\r\nRT298_CBJ_CTRL2, &val);\r\nif (0x0070 == (val & 0x0070))\r\n*mic = true;\r\nelse\r\n*mic = false;\r\n}\r\nregmap_update_bits(rt298->regmap,\r\nRT298_DC_GAIN, 0x200, 0x0);\r\n} else {\r\n*mic = false;\r\nregmap_write(rt298->regmap, RT298_SET_MIC1, 0x20);\r\nregmap_update_bits(rt298->regmap,\r\nRT298_CBJ_CTRL1, 0x0400, 0x0000);\r\n}\r\n} else {\r\nregmap_read(rt298->regmap, RT298_GET_HP_SENSE, &buf);\r\n*hp = buf & 0x80000000;\r\nregmap_read(rt298->regmap, RT298_GET_MIC1_SENSE, &buf);\r\n*mic = buf & 0x80000000;\r\n}\r\nsnd_soc_dapm_disable_pin(dapm, "HV");\r\nsnd_soc_dapm_disable_pin(dapm, "VREF");\r\nif (!*hp)\r\nsnd_soc_dapm_disable_pin(dapm, "LDO1");\r\nsnd_soc_dapm_sync(dapm);\r\npr_debug("*hp = %d *mic = %d\n", *hp, *mic);\r\nreturn 0;\r\n}\r\nstatic void rt298_jack_detect_work(struct work_struct *work)\r\n{\r\nstruct rt298_priv *rt298 =\r\ncontainer_of(work, struct rt298_priv, jack_detect_work.work);\r\nint status = 0;\r\nbool hp = false;\r\nbool mic = false;\r\nif (rt298_jack_detect(rt298, &hp, &mic) < 0)\r\nreturn;\r\nif (hp == true)\r\nstatus |= SND_JACK_HEADPHONE;\r\nif (mic == true)\r\nstatus |= SND_JACK_MICROPHONE;\r\nsnd_soc_jack_report(rt298->jack, status,\r\nSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\r\n}\r\nint rt298_mic_detect(struct snd_soc_codec *codec, struct snd_soc_jack *jack)\r\n{\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nstruct snd_soc_dapm_context *dapm;\r\nbool hp = false;\r\nbool mic = false;\r\nint status = 0;\r\nif (!jack) {\r\nregmap_update_bits(rt298->regmap, RT298_IRQ_CTRL, 0x2, 0x0);\r\ndapm = snd_soc_codec_get_dapm(codec);\r\nsnd_soc_dapm_disable_pin(dapm, "LDO1");\r\nsnd_soc_dapm_sync(dapm);\r\nreturn 0;\r\n}\r\nrt298->jack = jack;\r\nregmap_update_bits(rt298->regmap, RT298_IRQ_CTRL, 0x2, 0x2);\r\nrt298_jack_detect(rt298, &hp, &mic);\r\nif (hp == true)\r\nstatus |= SND_JACK_HEADPHONE;\r\nif (mic == true)\r\nstatus |= SND_JACK_MICROPHONE;\r\nsnd_soc_jack_report(rt298->jack, status,\r\nSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\r\nreturn 0;\r\n}\r\nstatic int is_mclk_mode(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nif (rt298->clk_id == RT298_SCLK_S_MCLK)\r\nreturn 1;\r\nelse\r\nreturn 0;\r\n}\r\nstatic int rt298_spk_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_write(codec,\r\nRT298_SPK_EAPD, RT298_SET_EAPD_HIGH);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_write(codec,\r\nRT298_SPK_EAPD, RT298_SET_EAPD_LOW);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt298_set_dmic1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_write(codec, RT298_SET_PIN_DMIC1, 0x20);\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_write(codec, RT298_SET_PIN_DMIC1, 0);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt298_adc_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nunsigned int nid;\r\nnid = (w->reg >> 20) & 0xff;\r\nswitch (event) {\r\ncase SND_SOC_DAPM_POST_PMU:\r\nsnd_soc_update_bits(codec,\r\nVERB_CMD(AC_VERB_SET_AMP_GAIN_MUTE, nid, 0),\r\n0x7080, 0x7000);\r\nif (!(snd_soc_read(codec, RT298_VAD_CTRL) & 0x200)) {\r\npr_info("NO MCLK\n");\r\nswitch (nid) {\r\ncase RT298_ADC_IN1:\r\nsnd_soc_update_bits(codec,\r\nRT298_D_FILTER_CTRL, 0x2, 0x2);\r\nmdelay(10);\r\nsnd_soc_update_bits(codec,\r\nRT298_D_FILTER_CTRL, 0x2, 0x0);\r\nbreak;\r\ncase RT298_ADC_IN2:\r\nsnd_soc_update_bits(codec,\r\nRT298_D_FILTER_CTRL, 0x4, 0x4);\r\nmdelay(10);\r\nsnd_soc_update_bits(codec,\r\nRT298_D_FILTER_CTRL, 0x4, 0x0);\r\nbreak;\r\n}\r\n}\r\nbreak;\r\ncase SND_SOC_DAPM_PRE_PMD:\r\nsnd_soc_update_bits(codec,\r\nVERB_CMD(AC_VERB_SET_AMP_GAIN_MUTE, nid, 0),\r\n0x7080, 0x7080);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt298_mic1_event(struct snd_soc_dapm_widget *w,\r\nstruct snd_kcontrol *kcontrol, int event)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(w->dapm);\r\nswitch (event) {\r\ncase SND_SOC_DAPM_PRE_PMU:\r\nsnd_soc_update_bits(codec,\r\nRT298_A_BIAS_CTRL3, 0xc000, 0x8000);\r\nsnd_soc_update_bits(codec,\r\nRT298_A_BIAS_CTRL2, 0xc000, 0x8000);\r\nbreak;\r\ncase SND_SOC_DAPM_POST_PMD:\r\nsnd_soc_update_bits(codec,\r\nRT298_A_BIAS_CTRL3, 0xc000, 0x0000);\r\nsnd_soc_update_bits(codec,\r\nRT298_A_BIAS_CTRL2, 0xc000, 0x0000);\r\nbreak;\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt298_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params,\r\nstruct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int val = 0;\r\nint d_len_code;\r\nswitch (params_rate(params)) {\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported sample rate %d\n",\r\nparams_rate(params));\r\nreturn -EINVAL;\r\n}\r\nswitch (rt298->sys_clk) {\r\ncase 12288000:\r\ncase 24576000:\r\nif (params_rate(params) != 48000) {\r\ndev_err(codec->dev, "Sys_clk is not matched (%d %d)\n",\r\nparams_rate(params), rt298->sys_clk);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\ncase 11289600:\r\ncase 22579200:\r\nif (params_rate(params) != 44100) {\r\ndev_err(codec->dev, "Sys_clk is not matched (%d %d)\n",\r\nparams_rate(params), rt298->sys_clk);\r\nreturn -EINVAL;\r\n}\r\nbreak;\r\n}\r\nif (params_channels(params) <= 16) {\r\nval |= (params_channels(params) - 1);\r\n} else {\r\ndev_err(codec->dev, "Unsupported channels %d\n",\r\nparams_channels(params));\r\nreturn -EINVAL;\r\n}\r\nd_len_code = 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nd_len_code = 0;\r\nval |= (0x1 << 4);\r\nbreak;\r\ncase 32:\r\nd_len_code = 2;\r\nval |= (0x4 << 4);\r\nbreak;\r\ncase 20:\r\nd_len_code = 1;\r\nval |= (0x2 << 4);\r\nbreak;\r\ncase 24:\r\nd_len_code = 2;\r\nval |= (0x3 << 4);\r\nbreak;\r\ncase 8:\r\nd_len_code = 3;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x0018, d_len_code << 3);\r\ndev_dbg(codec->dev, "format val = 0x%x\n", val);\r\nsnd_soc_update_bits(codec, RT298_DAC_FORMAT, 0x407f, val);\r\nsnd_soc_update_bits(codec, RT298_ADC_FORMAT, 0x407f, val);\r\nreturn 0;\r\n}\r\nstatic int rt298_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x800, 0x800);\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x800, 0x0);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x300, 0x0);\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x300, 0x1 << 8);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x300, 0x2 << 8);\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_B:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x300, 0x3 << 8);\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec, RT298_DAC_FORMAT, 0x8000, 0);\r\nsnd_soc_update_bits(codec, RT298_ADC_FORMAT, 0x8000, 0);\r\nreturn 0;\r\n}\r\nstatic int rt298_set_dai_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\ndev_dbg(codec->dev, "%s freq=%d\n", __func__, freq);\r\nif (RT298_SCLK_S_MCLK == clk_id) {\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL2, 0x0100, 0x0);\r\nsnd_soc_update_bits(codec,\r\nRT298_PLL_CTRL1, 0x20, 0x20);\r\n} else {\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL2, 0x0100, 0x0100);\r\nsnd_soc_update_bits(codec,\r\nRT298_PLL_CTRL1, 0x20, 0x0);\r\n}\r\nswitch (freq) {\r\ncase 19200000:\r\nif (RT298_SCLK_S_MCLK == clk_id) {\r\ndev_err(codec->dev, "Should not use MCLK\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL2, 0x40, 0x40);\r\nbreak;\r\ncase 24000000:\r\nif (RT298_SCLK_S_MCLK == clk_id) {\r\ndev_err(codec->dev, "Should not use MCLK\n");\r\nreturn -EINVAL;\r\n}\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL2, 0x40, 0x0);\r\nbreak;\r\ncase 12288000:\r\ncase 11289600:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL2, 0x8, 0x0);\r\nsnd_soc_update_bits(codec,\r\nRT298_CLK_DIV, 0xfc1e, 0x0004);\r\nbreak;\r\ncase 24576000:\r\ncase 22579200:\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL2, 0x8, 0x8);\r\nsnd_soc_update_bits(codec,\r\nRT298_CLK_DIV, 0xfc1e, 0x5406);\r\nbreak;\r\ndefault:\r\ndev_err(codec->dev, "Unsupported system clock\n");\r\nreturn -EINVAL;\r\n}\r\nrt298->sys_clk = freq;\r\nrt298->clk_id = clk_id;\r\nreturn 0;\r\n}\r\nstatic int rt298_set_bclk_ratio(struct snd_soc_dai *dai, unsigned int ratio)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\ndev_dbg(codec->dev, "%s ratio=%d\n", __func__, ratio);\r\nif (50 == ratio)\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x1000, 0x1000);\r\nelse\r\nsnd_soc_update_bits(codec,\r\nRT298_I2S_CTRL1, 0x1000, 0x0);\r\nreturn 0;\r\n}\r\nstatic int rt298_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nswitch (level) {\r\ncase SND_SOC_BIAS_PREPARE:\r\nif (SND_SOC_BIAS_STANDBY ==\r\nsnd_soc_codec_get_bias_level(codec)) {\r\nsnd_soc_write(codec,\r\nRT298_SET_AUDIO_POWER, AC_PWRST_D0);\r\nsnd_soc_update_bits(codec, 0x0d, 0x200, 0x200);\r\nsnd_soc_update_bits(codec, 0x52, 0x80, 0x0);\r\nmdelay(20);\r\nsnd_soc_update_bits(codec, 0x0d, 0x200, 0x0);\r\nsnd_soc_update_bits(codec, 0x52, 0x80, 0x80);\r\n}\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nsnd_soc_write(codec,\r\nRT298_SET_AUDIO_POWER, AC_PWRST_D3);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic irqreturn_t rt298_irq(int irq, void *data)\r\n{\r\nstruct rt298_priv *rt298 = data;\r\nbool hp = false;\r\nbool mic = false;\r\nint ret, status = 0;\r\nret = rt298_jack_detect(rt298, &hp, &mic);\r\nregmap_update_bits(rt298->regmap, RT298_IRQ_CTRL, 0x1, 0x1);\r\nif (ret == 0) {\r\nif (hp == true)\r\nstatus |= SND_JACK_HEADPHONE;\r\nif (mic == true)\r\nstatus |= SND_JACK_MICROPHONE;\r\nsnd_soc_jack_report(rt298->jack, status,\r\nSND_JACK_MICROPHONE | SND_JACK_HEADPHONE);\r\npm_wakeup_event(&rt298->i2c->dev, 300);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int rt298_probe(struct snd_soc_codec *codec)\r\n{\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nrt298->codec = codec;\r\nif (rt298->i2c->irq) {\r\nregmap_update_bits(rt298->regmap,\r\nRT298_IRQ_CTRL, 0x2, 0x2);\r\nINIT_DELAYED_WORK(&rt298->jack_detect_work,\r\nrt298_jack_detect_work);\r\nschedule_delayed_work(&rt298->jack_detect_work,\r\nmsecs_to_jiffies(1250));\r\n}\r\nreturn 0;\r\n}\r\nstatic int rt298_remove(struct snd_soc_codec *codec)\r\n{\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\ncancel_delayed_work_sync(&rt298->jack_detect_work);\r\nreturn 0;\r\n}\r\nstatic int rt298_suspend(struct snd_soc_codec *codec)\r\n{\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nrt298->is_hp_in = -1;\r\nregcache_cache_only(rt298->regmap, true);\r\nregcache_mark_dirty(rt298->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt298_resume(struct snd_soc_codec *codec)\r\n{\r\nstruct rt298_priv *rt298 = snd_soc_codec_get_drvdata(codec);\r\nregcache_cache_only(rt298->regmap, false);\r\nrt298_index_sync(codec);\r\nregcache_sync(rt298->regmap);\r\nreturn 0;\r\n}\r\nstatic int rt298_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct rt298_platform_data *pdata = dev_get_platdata(&i2c->dev);\r\nstruct rt298_priv *rt298;\r\nstruct device *dev = &i2c->dev;\r\nconst struct acpi_device_id *acpiid;\r\nint i, ret;\r\nrt298 = devm_kzalloc(&i2c->dev, sizeof(*rt298),\r\nGFP_KERNEL);\r\nif (NULL == rt298)\r\nreturn -ENOMEM;\r\nrt298->regmap = devm_regmap_init(&i2c->dev, NULL, i2c, &rt298_regmap);\r\nif (IS_ERR(rt298->regmap)) {\r\nret = PTR_ERR(rt298->regmap);\r\ndev_err(&i2c->dev, "Failed to allocate register map: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\nregmap_read(rt298->regmap,\r\nRT298_GET_PARAM(AC_NODE_ROOT, AC_PAR_VENDOR_ID), &ret);\r\nif (ret != RT298_VENDOR_ID) {\r\ndev_err(&i2c->dev,\r\n"Device with ID register %#x is not rt298\n", ret);\r\nreturn -ENODEV;\r\n}\r\nrt298->index_cache = devm_kmemdup(&i2c->dev, rt298_index_def,\r\nsizeof(rt298_index_def), GFP_KERNEL);\r\nif (!rt298->index_cache)\r\nreturn -ENOMEM;\r\nrt298->index_cache_size = INDEX_CACHE_SIZE;\r\nrt298->i2c = i2c;\r\ni2c_set_clientdata(i2c, rt298);\r\nfor (i = 0; i < INDEX_CACHE_SIZE; i++)\r\nregmap_write(rt298->regmap, rt298->index_cache[i].reg,\r\nrt298->index_cache[i].def);\r\nfor (i = 0; i < ARRAY_SIZE(rt298_reg); i++)\r\nregmap_write(rt298->regmap, rt298_reg[i].reg,\r\nrt298_reg[i].def);\r\nif (pdata)\r\nrt298->pdata = *pdata;\r\nacpiid = acpi_match_device(dev->driver->acpi_match_table, dev);\r\nif (acpiid && acpiid->driver_data) {\r\nrt298->pdata = *(struct rt298_platform_data *)\r\nacpiid->driver_data;\r\n}\r\nif (dmi_check_system(force_combo_jack_table)) {\r\nrt298->pdata.cbj_en = true;\r\nrt298->pdata.gpio2_en = false;\r\n}\r\nregmap_update_bits(rt298->regmap, 0x04, 0x80, 0x80);\r\nregmap_update_bits(rt298->regmap, 0x1b, 0x860, 0x860);\r\nregmap_update_bits(rt298->regmap, 0x08, 0x20, 0x20);\r\nregmap_write(rt298->regmap, RT298_SET_AUDIO_POWER, AC_PWRST_D3);\r\nfor (i = 0; i < RT298_POWER_REG_LEN; i++)\r\nregmap_write(rt298->regmap,\r\nRT298_SET_POWER(rt298_support_power_controls[i]),\r\nAC_PWRST_D1);\r\nif (!rt298->pdata.cbj_en) {\r\nregmap_write(rt298->regmap, RT298_CBJ_CTRL2, 0x0000);\r\nregmap_write(rt298->regmap, RT298_MIC1_DET_CTRL, 0x0816);\r\nregmap_update_bits(rt298->regmap,\r\nRT298_CBJ_CTRL1, 0xf000, 0xb000);\r\n} else {\r\nregmap_update_bits(rt298->regmap,\r\nRT298_CBJ_CTRL1, 0xf000, 0x5000);\r\n}\r\nmdelay(10);\r\nif (!rt298->pdata.gpio2_en)\r\nregmap_write(rt298->regmap, RT298_SET_DMIC2_DEFAULT, 0x40);\r\nelse\r\nregmap_write(rt298->regmap, RT298_SET_DMIC2_DEFAULT, 0);\r\nmdelay(10);\r\nregmap_write(rt298->regmap, RT298_MISC_CTRL1, 0x0000);\r\nregmap_update_bits(rt298->regmap,\r\nRT298_WIND_FILTER_CTRL, 0x0082, 0x0082);\r\nregmap_write(rt298->regmap, RT298_UNSOLICITED_INLINE_CMD, 0x81);\r\nregmap_write(rt298->regmap, RT298_UNSOLICITED_HP_OUT, 0x82);\r\nregmap_write(rt298->regmap, RT298_UNSOLICITED_MIC1, 0x84);\r\nregmap_update_bits(rt298->regmap, RT298_IRQ_FLAG_CTRL, 0x2, 0x2);\r\nrt298->is_hp_in = -1;\r\nif (rt298->i2c->irq) {\r\nret = request_threaded_irq(rt298->i2c->irq, NULL, rt298_irq,\r\nIRQF_TRIGGER_HIGH | IRQF_ONESHOT, "rt298", rt298);\r\nif (ret != 0) {\r\ndev_err(&i2c->dev,\r\n"Failed to reguest IRQ: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\nret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_rt298,\r\nrt298_dai, ARRAY_SIZE(rt298_dai));\r\nreturn ret;\r\n}\r\nstatic int rt298_i2c_remove(struct i2c_client *i2c)\r\n{\r\nstruct rt298_priv *rt298 = i2c_get_clientdata(i2c);\r\nif (i2c->irq)\r\nfree_irq(i2c->irq, rt298);\r\nsnd_soc_unregister_codec(&i2c->dev);\r\nreturn 0;\r\n}
