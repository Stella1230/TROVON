static bool nau8810_readable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase NAU8810_REG_RESET ... NAU8810_REG_SMPLR:\r\ncase NAU8810_REG_DAC ... NAU8810_REG_DACGAIN:\r\ncase NAU8810_REG_ADC ... NAU8810_REG_ADCGAIN:\r\ncase NAU8810_REG_EQ1 ... NAU8810_REG_EQ5:\r\ncase NAU8810_REG_DACLIM1 ... NAU8810_REG_DACLIM2:\r\ncase NAU8810_REG_NOTCH1 ... NAU8810_REG_NOTCH4:\r\ncase NAU8810_REG_ALC1 ... NAU8810_REG_ATTEN:\r\ncase NAU8810_REG_INPUT_SIGNAL ... NAU8810_REG_PGAGAIN:\r\ncase NAU8810_REG_ADCBOOST:\r\ncase NAU8810_REG_OUTPUT ... NAU8810_REG_SPKMIX:\r\ncase NAU8810_REG_SPKGAIN:\r\ncase NAU8810_REG_MONOMIX:\r\ncase NAU8810_REG_POWER4 ... NAU8810_REG_TSLOTCTL2:\r\ncase NAU8810_REG_DEVICE_REVID ... NAU8810_REG_RESERVE:\r\ncase NAU8810_REG_OUTCTL ... NAU8810_REG_ALC1ENHAN2:\r\ncase NAU8810_REG_MISCCTL:\r\ncase NAU8810_REG_OUTTIEOFF ... NAU8810_REG_OUTTIEOFFMAN:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool nau8810_writeable_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase NAU8810_REG_RESET ... NAU8810_REG_SMPLR:\r\ncase NAU8810_REG_DAC ... NAU8810_REG_DACGAIN:\r\ncase NAU8810_REG_ADC ... NAU8810_REG_ADCGAIN:\r\ncase NAU8810_REG_EQ1 ... NAU8810_REG_EQ5:\r\ncase NAU8810_REG_DACLIM1 ... NAU8810_REG_DACLIM2:\r\ncase NAU8810_REG_NOTCH1 ... NAU8810_REG_NOTCH4:\r\ncase NAU8810_REG_ALC1 ... NAU8810_REG_ATTEN:\r\ncase NAU8810_REG_INPUT_SIGNAL ... NAU8810_REG_PGAGAIN:\r\ncase NAU8810_REG_ADCBOOST:\r\ncase NAU8810_REG_OUTPUT ... NAU8810_REG_SPKMIX:\r\ncase NAU8810_REG_SPKGAIN:\r\ncase NAU8810_REG_MONOMIX:\r\ncase NAU8810_REG_POWER4 ... NAU8810_REG_TSLOTCTL2:\r\ncase NAU8810_REG_OUTCTL ... NAU8810_REG_ALC1ENHAN2:\r\ncase NAU8810_REG_MISCCTL:\r\ncase NAU8810_REG_OUTTIEOFF ... NAU8810_REG_OUTTIEOFFMAN:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool nau8810_volatile_reg(struct device *dev, unsigned int reg)\r\n{\r\nswitch (reg) {\r\ncase NAU8810_REG_RESET:\r\ncase NAU8810_REG_DEVICE_REVID ... NAU8810_REG_RESERVE:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic int nau8810_eq_get(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\r\nint i, reg, reg_val;\r\nu16 *val;\r\nval = (u16 *)ucontrol->value.bytes.data;\r\nreg = NAU8810_REG_EQ1;\r\nfor (i = 0; i < params->max / sizeof(u16); i++) {\r\nregmap_read(nau8810->regmap, reg + i, &reg_val);\r\nreg_val = cpu_to_be16(reg_val);\r\nmemcpy(val + i, &reg_val, sizeof(reg_val));\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8810_eq_put(struct snd_kcontrol *kcontrol,\r\nstruct snd_ctl_elem_value *ucontrol)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_kcontrol_codec(kcontrol);\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nstruct soc_bytes_ext *params = (void *)kcontrol->private_value;\r\nvoid *data;\r\nu16 *val, value;\r\nint i, reg, ret;\r\ndata = kmemdup(ucontrol->value.bytes.data,\r\nparams->max, GFP_KERNEL | GFP_DMA);\r\nif (!data)\r\nreturn -ENOMEM;\r\nval = (u16 *)data;\r\nreg = NAU8810_REG_EQ1;\r\nfor (i = 0; i < params->max / sizeof(u16); i++) {\r\nvalue = be16_to_cpu(*(val + i));\r\nret = regmap_write(nau8810->regmap, reg + i, value);\r\nif (ret) {\r\ndev_err(codec->dev, "EQ configuration fail, register: %x ret: %d\n",\r\nreg + i, ret);\r\nkfree(data);\r\nreturn ret;\r\n}\r\n}\r\nkfree(data);\r\nreturn 0;\r\n}\r\nstatic int check_mclk_select_pll(struct snd_soc_dapm_widget *source,\r\nstruct snd_soc_dapm_widget *sink)\r\n{\r\nstruct snd_soc_codec *codec = snd_soc_dapm_to_codec(source->dapm);\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nunsigned int value;\r\nregmap_read(nau8810->regmap, NAU8810_REG_CLOCK, &value);\r\nreturn (value & NAU8810_CLKM_MASK);\r\n}\r\nstatic int nau8810_set_sysclk(struct snd_soc_dai *dai,\r\nint clk_id, unsigned int freq, int dir)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nnau8810->clk_id = clk_id;\r\nnau8810->sysclk = freq;\r\ndev_dbg(nau8810->dev, "master sysclk %dHz, source %s\n",\r\nfreq, clk_id == NAU8810_SCLK_PLL ? "PLL" : "MCLK");\r\nreturn 0;\r\n}\r\nstatic int nau88l0_calc_pll(unsigned int pll_in,\r\nunsigned int fs, struct nau8810_pll *pll_param)\r\n{\r\nu64 f2, f2_max, pll_ratio;\r\nint i, scal_sel;\r\nif (pll_in > NAU_PLL_REF_MAX || pll_in < NAU_PLL_REF_MIN)\r\nreturn -EINVAL;\r\nf2_max = 0;\r\nscal_sel = ARRAY_SIZE(nau8810_mclk_scaler);\r\nfor (i = 0; i < ARRAY_SIZE(nau8810_mclk_scaler); i++) {\r\nf2 = 256 * fs * 4 * nau8810_mclk_scaler[i] / 10;\r\nif (f2 > NAU_PLL_FREQ_MIN && f2 < NAU_PLL_FREQ_MAX &&\r\nf2_max < f2) {\r\nf2_max = f2;\r\nscal_sel = i;\r\n}\r\n}\r\nif (ARRAY_SIZE(nau8810_mclk_scaler) == scal_sel)\r\nreturn -EINVAL;\r\npll_param->mclk_scaler = scal_sel;\r\nf2 = f2_max;\r\npll_ratio = div_u64(f2 << 28, pll_in);\r\npll_param->pre_factor = 0;\r\nif (((pll_ratio >> 28) & 0xF) < NAU_PLL_OPTOP_MIN) {\r\npll_ratio <<= 1;\r\npll_param->pre_factor = 1;\r\n}\r\npll_param->pll_int = (pll_ratio >> 28) & 0xF;\r\npll_param->pll_frac = ((pll_ratio & 0xFFFFFFF) >> 4);\r\nreturn 0;\r\n}\r\nstatic int nau8810_set_pll(struct snd_soc_dai *codec_dai, int pll_id,\r\nint source, unsigned int freq_in, unsigned int freq_out)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nstruct regmap *map = nau8810->regmap;\r\nstruct nau8810_pll *pll_param = &nau8810->pll;\r\nint ret, fs;\r\nfs = freq_out / 256;\r\nret = nau88l0_calc_pll(freq_in, fs, pll_param);\r\nif (ret < 0) {\r\ndev_err(nau8810->dev, "Unsupported input clock %d\n", freq_in);\r\nreturn ret;\r\n}\r\ndev_info(nau8810->dev, "pll_int=%x pll_frac=%x mclk_scaler=%x pre_factor=%x\n",\r\npll_param->pll_int, pll_param->pll_frac, pll_param->mclk_scaler,\r\npll_param->pre_factor);\r\nregmap_update_bits(map, NAU8810_REG_PLLN,\r\nNAU8810_PLLMCLK_DIV2 | NAU8810_PLLN_MASK,\r\n(pll_param->pre_factor ? NAU8810_PLLMCLK_DIV2 : 0) |\r\npll_param->pll_int);\r\nregmap_write(map, NAU8810_REG_PLLK1,\r\n(pll_param->pll_frac >> NAU8810_PLLK1_SFT) &\r\nNAU8810_PLLK1_MASK);\r\nregmap_write(map, NAU8810_REG_PLLK2,\r\n(pll_param->pll_frac >> NAU8810_PLLK2_SFT) &\r\nNAU8810_PLLK2_MASK);\r\nregmap_write(map, NAU8810_REG_PLLK3,\r\npll_param->pll_frac & NAU8810_PLLK3_MASK);\r\nregmap_update_bits(map, NAU8810_REG_CLOCK, NAU8810_MCLKSEL_MASK,\r\npll_param->mclk_scaler << NAU8810_MCLKSEL_SFT);\r\nregmap_update_bits(map, NAU8810_REG_CLOCK,\r\nNAU8810_CLKM_MASK, NAU8810_CLKM_PLL);\r\nreturn 0;\r\n}\r\nstatic int nau8810_set_dai_fmt(struct snd_soc_dai *codec_dai,\r\nunsigned int fmt)\r\n{\r\nstruct snd_soc_codec *codec = codec_dai->codec;\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nu16 ctrl1_val = 0, ctrl2_val = 0;\r\nswitch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {\r\ncase SND_SOC_DAIFMT_CBM_CFM:\r\nctrl2_val |= NAU8810_CLKIO_MASTER;\r\nbreak;\r\ncase SND_SOC_DAIFMT_CBS_CFS:\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {\r\ncase SND_SOC_DAIFMT_I2S:\r\nctrl1_val |= NAU8810_AIFMT_I2S;\r\nbreak;\r\ncase SND_SOC_DAIFMT_RIGHT_J:\r\nbreak;\r\ncase SND_SOC_DAIFMT_LEFT_J:\r\nctrl1_val |= NAU8810_AIFMT_LEFT;\r\nbreak;\r\ncase SND_SOC_DAIFMT_DSP_A:\r\nctrl1_val |= NAU8810_AIFMT_PCM_A;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nswitch (fmt & SND_SOC_DAIFMT_INV_MASK) {\r\ncase SND_SOC_DAIFMT_NB_NF:\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_IF:\r\nctrl1_val |= NAU8810_BCLKP_IB | NAU8810_FSP_IF;\r\nbreak;\r\ncase SND_SOC_DAIFMT_IB_NF:\r\nctrl1_val |= NAU8810_BCLKP_IB;\r\nbreak;\r\ncase SND_SOC_DAIFMT_NB_IF:\r\nctrl1_val |= NAU8810_FSP_IF;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nregmap_update_bits(nau8810->regmap, NAU8810_REG_IFACE,\r\nNAU8810_AIFMT_MASK | NAU8810_FSP_IF |\r\nNAU8810_BCLKP_IB, ctrl1_val);\r\nregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\r\nNAU8810_CLKIO_MASK, ctrl2_val);\r\nreturn 0;\r\n}\r\nstatic int nau8810_mclk_clkdiv(struct nau8810 *nau8810, int rate)\r\n{\r\nint i, sclk, imclk = rate * 256, div = 0;\r\nif (!nau8810->sysclk) {\r\ndev_err(nau8810->dev, "Make mclk div configuration fail because of invalid system clock\n");\r\nreturn -EINVAL;\r\n}\r\nfor (i = 1; i < ARRAY_SIZE(nau8810_mclk_scaler); i++) {\r\nsclk = (nau8810->sysclk * 10) /\r\nnau8810_mclk_scaler[i];\r\nif (sclk < imclk)\r\nbreak;\r\ndiv = i;\r\n}\r\ndev_dbg(nau8810->dev,\r\n"master clock prescaler %x for fs %d\n", div, rate);\r\nregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\r\nNAU8810_MCLKSEL_MASK, (div << NAU8810_MCLKSEL_SFT));\r\nregmap_update_bits(nau8810->regmap, NAU8810_REG_CLOCK,\r\nNAU8810_CLKM_MASK, NAU8810_CLKM_MCLK);\r\nreturn 0;\r\n}\r\nstatic int nau8810_pcm_hw_params(struct snd_pcm_substream *substream,\r\nstruct snd_pcm_hw_params *params, struct snd_soc_dai *dai)\r\n{\r\nstruct snd_soc_codec *codec = dai->codec;\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nint val_len = 0, val_rate = 0, ret = 0;\r\nswitch (params_width(params)) {\r\ncase 16:\r\nbreak;\r\ncase 20:\r\nval_len |= NAU8810_WLEN_20;\r\nbreak;\r\ncase 24:\r\nval_len |= NAU8810_WLEN_24;\r\nbreak;\r\ncase 32:\r\nval_len |= NAU8810_WLEN_32;\r\nbreak;\r\n}\r\nswitch (params_rate(params)) {\r\ncase 8000:\r\nval_rate |= NAU8810_SMPLR_8K;\r\nbreak;\r\ncase 11025:\r\nval_rate |= NAU8810_SMPLR_12K;\r\nbreak;\r\ncase 16000:\r\nval_rate |= NAU8810_SMPLR_16K;\r\nbreak;\r\ncase 22050:\r\nval_rate |= NAU8810_SMPLR_24K;\r\nbreak;\r\ncase 32000:\r\nval_rate |= NAU8810_SMPLR_32K;\r\nbreak;\r\ncase 44100:\r\ncase 48000:\r\nbreak;\r\n}\r\nregmap_update_bits(nau8810->regmap, NAU8810_REG_IFACE,\r\nNAU8810_WLEN_MASK, val_len);\r\nregmap_update_bits(nau8810->regmap, NAU8810_REG_SMPLR,\r\nNAU8810_SMPLR_MASK, val_rate);\r\nif (nau8810->clk_id == NAU8810_SCLK_MCLK) {\r\nret = nau8810_mclk_clkdiv(nau8810, params_rate(params));\r\nif (ret < 0)\r\ndev_err(nau8810->dev, "MCLK div configuration fail\n");\r\n}\r\nreturn ret;\r\n}\r\nstatic int nau8810_set_bias_level(struct snd_soc_codec *codec,\r\nenum snd_soc_bias_level level)\r\n{\r\nstruct nau8810 *nau8810 = snd_soc_codec_get_drvdata(codec);\r\nstruct regmap *map = nau8810->regmap;\r\nswitch (level) {\r\ncase SND_SOC_BIAS_ON:\r\ncase SND_SOC_BIAS_PREPARE:\r\nregmap_update_bits(map, NAU8810_REG_POWER1,\r\nNAU8810_REFIMP_MASK, NAU8810_REFIMP_80K);\r\nbreak;\r\ncase SND_SOC_BIAS_STANDBY:\r\nregmap_update_bits(map, NAU8810_REG_POWER1,\r\nNAU8810_IOBUF_EN | NAU8810_ABIAS_EN,\r\nNAU8810_IOBUF_EN | NAU8810_ABIAS_EN);\r\nif (snd_soc_codec_get_bias_level(codec) == SND_SOC_BIAS_OFF) {\r\nregcache_sync(map);\r\nregmap_update_bits(map, NAU8810_REG_POWER1,\r\nNAU8810_REFIMP_MASK, NAU8810_REFIMP_3K);\r\nmdelay(100);\r\n}\r\nregmap_update_bits(map, NAU8810_REG_POWER1,\r\nNAU8810_REFIMP_MASK, NAU8810_REFIMP_300K);\r\nbreak;\r\ncase SND_SOC_BIAS_OFF:\r\nregmap_write(map, NAU8810_REG_POWER1, 0);\r\nregmap_write(map, NAU8810_REG_POWER2, 0);\r\nregmap_write(map, NAU8810_REG_POWER3, 0);\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int nau8810_i2c_probe(struct i2c_client *i2c,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &i2c->dev;\r\nstruct nau8810 *nau8810 = dev_get_platdata(dev);\r\nif (!nau8810) {\r\nnau8810 = devm_kzalloc(dev, sizeof(*nau8810), GFP_KERNEL);\r\nif (!nau8810)\r\nreturn -ENOMEM;\r\n}\r\ni2c_set_clientdata(i2c, nau8810);\r\nnau8810->regmap = devm_regmap_init_i2c(i2c, &nau8810_regmap_config);\r\nif (IS_ERR(nau8810->regmap))\r\nreturn PTR_ERR(nau8810->regmap);\r\nnau8810->dev = dev;\r\nregmap_write(nau8810->regmap, NAU8810_REG_RESET, 0x00);\r\nreturn snd_soc_register_codec(dev,\r\n&nau8810_codec_driver, &nau8810_dai, 1);\r\n}\r\nstatic int nau8810_i2c_remove(struct i2c_client *client)\r\n{\r\nsnd_soc_unregister_codec(&client->dev);\r\nreturn 0;\r\n}
