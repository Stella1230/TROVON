static inline void ican3_set_page(struct ican3_dev *mod, unsigned int page)\r\n{\r\nBUG_ON(page >= DPM_NUM_PAGES);\r\niowrite8(page, &mod->dpmctrl->window_address);\r\n}\r\nstatic int ican3_old_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nunsigned int mbox, mbox_page;\r\nu8 locl, peer, xord;\r\nican3_set_page(mod, QUEUE_OLD_CONTROL);\r\npeer = ioread8(mod->dpm + MSYNC_PEER);\r\nlocl = ioread8(mod->dpm + MSYNC_LOCL);\r\nxord = locl ^ peer;\r\nif ((xord & MSYNC_RB_MASK) == 0x00) {\r\nnetdev_dbg(mod->ndev, "no mbox for reading\n");\r\nreturn -ENOMEM;\r\n}\r\nif ((xord & MSYNC_RB_MASK) == MSYNC_RB_MASK)\r\nmbox = (xord & MSYNC_RBLW) ? MSYNC_RB0 : MSYNC_RB1;\r\nelse\r\nmbox = (xord & MSYNC_RB0) ? MSYNC_RB0 : MSYNC_RB1;\r\nmbox_page = (mbox == MSYNC_RB0) ? QUEUE_OLD_RB0 : QUEUE_OLD_RB1;\r\nican3_set_page(mod, mbox_page);\r\nmemcpy_fromio(msg, mod->dpm, sizeof(*msg));\r\nlocl ^= mbox;\r\nican3_set_page(mod, QUEUE_OLD_CONTROL);\r\niowrite8(locl, mod->dpm + MSYNC_LOCL);\r\nreturn 0;\r\n}\r\nstatic int ican3_old_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nunsigned int mbox, mbox_page;\r\nu8 locl, peer, xord;\r\nican3_set_page(mod, QUEUE_OLD_CONTROL);\r\npeer = ioread8(mod->dpm + MSYNC_PEER);\r\nlocl = ioread8(mod->dpm + MSYNC_LOCL);\r\nxord = locl ^ peer;\r\nif ((xord & MSYNC_WB_MASK) == MSYNC_WB_MASK) {\r\nnetdev_err(mod->ndev, "no mbox for writing\n");\r\nreturn -ENOMEM;\r\n}\r\nmbox = (xord & MSYNC_WB0) ? MSYNC_WB1 : MSYNC_WB0;\r\nmbox_page = (mbox == MSYNC_WB0) ? QUEUE_OLD_WB0 : QUEUE_OLD_WB1;\r\nican3_set_page(mod, mbox_page);\r\nmemcpy_toio(mod->dpm, msg, sizeof(*msg));\r\nlocl ^= mbox;\r\nif (mbox == MSYNC_WB1)\r\nlocl |= MSYNC_WBLW;\r\nican3_set_page(mod, QUEUE_OLD_CONTROL);\r\niowrite8(locl, mod->dpm + MSYNC_LOCL);\r\nreturn 0;\r\n}\r\nstatic void ican3_init_new_host_interface(struct ican3_dev *mod)\r\n{\r\nstruct ican3_new_desc desc;\r\nunsigned long flags;\r\nvoid __iomem *dst;\r\nint i;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nmod->rx_num = 0;\r\nmod->rx_int = 0;\r\nican3_set_page(mod, QUEUE_TOHOST);\r\ndst = mod->dpm;\r\nfor (i = 0; i < ICAN3_NEW_BUFFERS; i++) {\r\ndesc.control = DESC_INTERRUPT | DESC_LEN(1);\r\ndesc.pointer = mod->free_page;\r\nif (i == ICAN3_NEW_BUFFERS - 1)\r\ndesc.control |= DESC_WRAP;\r\nmemcpy_toio(dst, &desc, sizeof(desc));\r\ndst += sizeof(desc);\r\nmod->free_page++;\r\n}\r\nican3_set_page(mod, QUEUE_FROMHOST_MID);\r\ndst = mod->dpm;\r\nmod->tx_num = 0;\r\nfor (i = 0; i < ICAN3_NEW_BUFFERS; i++) {\r\ndesc.control = DESC_VALID | DESC_LEN(1);\r\ndesc.pointer = mod->free_page;\r\nif (i == ICAN3_NEW_BUFFERS - 1)\r\ndesc.control |= DESC_WRAP;\r\nmemcpy_toio(dst, &desc, sizeof(desc));\r\ndst += sizeof(desc);\r\nmod->free_page++;\r\n}\r\nican3_set_page(mod, QUEUE_FROMHOST_HIGH);\r\ndst = mod->dpm;\r\ndesc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1);\r\ndesc.pointer = mod->free_page;\r\nmemcpy_toio(dst, &desc, sizeof(desc));\r\nmod->free_page++;\r\nican3_set_page(mod, QUEUE_FROMHOST_LOW);\r\ndst = mod->dpm;\r\ndesc.control = DESC_VALID | DESC_WRAP | DESC_LEN(1);\r\ndesc.pointer = mod->free_page;\r\nmemcpy_toio(dst, &desc, sizeof(desc));\r\nmod->free_page++;\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\n}\r\nstatic void ican3_init_fast_host_interface(struct ican3_dev *mod)\r\n{\r\nstruct ican3_fast_desc desc;\r\nunsigned long flags;\r\nunsigned int addr;\r\nvoid __iomem *dst;\r\nint i;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nmod->fastrx_start = mod->free_page;\r\nmod->fastrx_num = 0;\r\nmemset(&desc, 0, sizeof(desc));\r\ndesc.control = 0x00;\r\ndesc.command = 1;\r\naddr = 0;\r\nfor (i = 0; i < ICAN3_RX_BUFFERS; i++) {\r\nif (i == ICAN3_RX_BUFFERS - 1)\r\ndesc.control |= DESC_WRAP;\r\nican3_set_page(mod, mod->free_page);\r\ndst = mod->dpm + addr;\r\nmemcpy_toio(dst, &desc, sizeof(desc));\r\naddr += sizeof(desc);\r\nif (addr >= DPM_PAGE_SIZE) {\r\naddr = 0;\r\nmod->free_page++;\r\n}\r\n}\r\nif (addr != 0)\r\nmod->free_page++;\r\nmod->fasttx_start = mod->free_page;\r\nmod->fasttx_num = 0;\r\nmemset(&desc, 0, sizeof(desc));\r\ndesc.control = DESC_VALID;\r\ndesc.command = 1;\r\naddr = 0;\r\nfor (i = 0; i < ICAN3_TX_BUFFERS; i++) {\r\nif (i == ICAN3_TX_BUFFERS - 1)\r\ndesc.control |= DESC_WRAP;\r\nican3_set_page(mod, mod->free_page);\r\ndst = mod->dpm + addr;\r\nmemcpy_toio(dst, &desc, sizeof(desc));\r\naddr += sizeof(desc);\r\nif (addr >= DPM_PAGE_SIZE) {\r\naddr = 0;\r\nmod->free_page++;\r\n}\r\n}\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\n}\r\nstatic int ican3_new_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nstruct ican3_new_desc desc;\r\nvoid __iomem *desc_addr = mod->dpm + (mod->tx_num * sizeof(desc));\r\nican3_set_page(mod, QUEUE_FROMHOST_MID);\r\nmemcpy_fromio(&desc, desc_addr, sizeof(desc));\r\nif (!(desc.control & DESC_VALID)) {\r\nnetdev_dbg(mod->ndev, "%s: no free buffers\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nican3_set_page(mod, desc.pointer);\r\nmemcpy_toio(mod->dpm, msg, sizeof(*msg));\r\nican3_set_page(mod, QUEUE_FROMHOST_MID);\r\ndesc.control ^= DESC_VALID;\r\nmemcpy_toio(desc_addr, &desc, sizeof(desc));\r\nmod->tx_num = (desc.control & DESC_WRAP) ? 0 : (mod->tx_num + 1);\r\nreturn 0;\r\n}\r\nstatic int ican3_new_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nstruct ican3_new_desc desc;\r\nvoid __iomem *desc_addr = mod->dpm + (mod->rx_num * sizeof(desc));\r\nican3_set_page(mod, QUEUE_TOHOST);\r\nmemcpy_fromio(&desc, desc_addr, sizeof(desc));\r\nif (!(desc.control & DESC_VALID)) {\r\nnetdev_dbg(mod->ndev, "%s: no buffers to recv\n", __func__);\r\nreturn -ENOMEM;\r\n}\r\nican3_set_page(mod, desc.pointer);\r\nmemcpy_fromio(msg, mod->dpm, sizeof(*msg));\r\nican3_set_page(mod, QUEUE_TOHOST);\r\ndesc.control ^= DESC_VALID;\r\nmemcpy_toio(desc_addr, &desc, sizeof(desc));\r\nmod->rx_num = (desc.control & DESC_WRAP) ? 0 : (mod->rx_num + 1);\r\nreturn 0;\r\n}\r\nstatic int ican3_send_msg(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nif (mod->iftype == 0)\r\nret = ican3_old_send_msg(mod, msg);\r\nelse\r\nret = ican3_new_send_msg(mod, msg);\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ican3_recv_msg(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nunsigned long flags;\r\nint ret;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nif (mod->iftype == 0)\r\nret = ican3_old_recv_msg(mod, msg);\r\nelse\r\nret = ican3_new_recv_msg(mod, msg);\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\nreturn ret;\r\n}\r\nstatic int ican3_msg_connect(struct ican3_dev *mod)\r\n{\r\nstruct ican3_msg msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_CONNECTI;\r\nmsg.len = cpu_to_le16(0);\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic int ican3_msg_disconnect(struct ican3_dev *mod)\r\n{\r\nstruct ican3_msg msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_DISCONNECT;\r\nmsg.len = cpu_to_le16(0);\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic int ican3_msg_newhostif(struct ican3_dev *mod)\r\n{\r\nstruct ican3_msg msg;\r\nint ret;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_NEWHOSTIF;\r\nmsg.len = cpu_to_le16(0);\r\nWARN_ON(mod->iftype != 0);\r\nret = ican3_send_msg(mod, &msg);\r\nif (ret)\r\nreturn ret;\r\nmod->iftype = 1;\r\nreturn 0;\r\n}\r\nstatic int ican3_msg_fasthostif(struct ican3_dev *mod)\r\n{\r\nstruct ican3_msg msg;\r\nunsigned int addr;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_INITFDPMQUEUE;\r\nmsg.len = cpu_to_le16(8);\r\naddr = DPM_PAGE_ADDR(mod->fastrx_start);\r\nmsg.data[0] = addr & 0xff;\r\nmsg.data[1] = (addr >> 8) & 0xff;\r\nmsg.data[2] = (addr >> 16) & 0xff;\r\nmsg.data[3] = (addr >> 24) & 0xff;\r\naddr = DPM_PAGE_ADDR(mod->fasttx_start);\r\nmsg.data[4] = addr & 0xff;\r\nmsg.data[5] = (addr >> 8) & 0xff;\r\nmsg.data[6] = (addr >> 16) & 0xff;\r\nmsg.data[7] = (addr >> 24) & 0xff;\r\nWARN_ON(mod->iftype != 1);\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic int ican3_set_id_filter(struct ican3_dev *mod, bool accept)\r\n{\r\nstruct ican3_msg msg;\r\nint ret;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_SETAFILMASK;\r\nmsg.len = cpu_to_le16(5);\r\nmsg.data[0] = 0x00;\r\nmsg.data[1] = 0x00;\r\nmsg.data[2] = 0xff;\r\nmsg.data[3] = 0x07;\r\nmsg.data[4] = accept ? SETAFILMASK_FASTIF : SETAFILMASK_REJECT;\r\nret = ican3_send_msg(mod, &msg);\r\nif (ret)\r\nreturn ret;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_SETAFILMASK;\r\nmsg.len = cpu_to_le16(13);\r\nmsg.data[0] = 0;\r\nmsg.data[1] = 0x00;\r\nmsg.data[2] = 0x00;\r\nmsg.data[3] = 0x00;\r\nmsg.data[4] = 0x20;\r\nmsg.data[5] = 0xff;\r\nmsg.data[6] = 0xff;\r\nmsg.data[7] = 0xff;\r\nmsg.data[8] = 0x3f;\r\nmsg.data[9] = accept ? SETAFILMASK_FASTIF : SETAFILMASK_REJECT;\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic int ican3_set_bus_state(struct ican3_dev *mod, bool on)\r\n{\r\nstruct can_bittiming *bt = &mod->can.bittiming;\r\nstruct ican3_msg msg;\r\nu8 btr0, btr1;\r\nint res;\r\nbtr0 = ((bt->brp - 1) & 0x3f) | (((bt->sjw - 1) & 0x3) << 6);\r\nbtr1 = ((bt->prop_seg + bt->phase_seg1 - 1) & 0xf) |\r\n(((bt->phase_seg2 - 1) & 0x7) << 4);\r\nif (mod->can.ctrlmode & CAN_CTRLMODE_3_SAMPLES)\r\nbtr1 |= 0x80;\r\nif (mod->fwtype == ICAN3_FWTYPE_ICANOS) {\r\nif (on) {\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_CBTRREQ;\r\nmsg.len = cpu_to_le16(4);\r\nmsg.data[0] = 0x00;\r\nmsg.data[1] = 0x00;\r\nmsg.data[2] = btr0;\r\nmsg.data[3] = btr1;\r\nres = ican3_send_msg(mod, &msg);\r\nif (res)\r\nreturn res;\r\n}\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = on ? MSG_CONREQ : MSG_COFFREQ;\r\nmsg.len = cpu_to_le16(0);\r\nreturn ican3_send_msg(mod, &msg);\r\n} else if (mod->fwtype == ICAN3_FWTYPE_CAL_CANOPEN) {\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_LMTS;\r\nif (on) {\r\nmsg.len = cpu_to_le16(4);\r\nmsg.data[0] = LMTS_BUSON_REQ;\r\nmsg.data[1] = 0;\r\nmsg.data[2] = btr0;\r\nmsg.data[3] = btr1;\r\n} else {\r\nmsg.len = cpu_to_le16(2);\r\nmsg.data[0] = LMTS_BUSOFF_REQ;\r\nmsg.data[1] = 0;\r\n}\r\nres = ican3_send_msg(mod, &msg);\r\nif (res)\r\nreturn res;\r\nif (on) {\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_NMTS;\r\nmsg.len = cpu_to_le16(11);\r\nmsg.data[0] = NMTS_CREATE_NODE_REQ;\r\nmsg.data[1] = 0;\r\nmsg.data[2] = 2;\r\nmsg.data[3] = 1;\r\nstrcpy(msg.data + 4, "locnod1");\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nreturn 0;\r\n}\r\nreturn -ENOTSUPP;\r\n}\r\nstatic int ican3_set_termination(struct ican3_dev *mod, bool on)\r\n{\r\nstruct ican3_msg msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_HWCONF;\r\nmsg.len = cpu_to_le16(2);\r\nmsg.data[0] = 0x00;\r\nmsg.data[1] = on ? HWCONF_TERMINATE_ON : HWCONF_TERMINATE_OFF;\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic int ican3_send_inquiry(struct ican3_dev *mod, u8 subspec)\r\n{\r\nstruct ican3_msg msg;\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_INQUIRY;\r\nmsg.len = cpu_to_le16(2);\r\nmsg.data[0] = subspec;\r\nmsg.data[1] = 0x00;\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic int ican3_set_buserror(struct ican3_dev *mod, u8 quota)\r\n{\r\nstruct ican3_msg msg;\r\nif (mod->fwtype == ICAN3_FWTYPE_ICANOS) {\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_CCONFREQ;\r\nmsg.len = cpu_to_le16(2);\r\nmsg.data[0] = 0x00;\r\nmsg.data[1] = quota;\r\n} else if (mod->fwtype == ICAN3_FWTYPE_CAL_CANOPEN) {\r\nmemset(&msg, 0, sizeof(msg));\r\nmsg.spec = MSG_LMTS;\r\nmsg.len = cpu_to_le16(4);\r\nmsg.data[0] = LMTS_CAN_CONF_REQ;\r\nmsg.data[1] = 0x00;\r\nmsg.data[2] = 0x00;\r\nmsg.data[3] = quota;\r\n} else {\r\nreturn -ENOTSUPP;\r\n}\r\nreturn ican3_send_msg(mod, &msg);\r\n}\r\nstatic void ican3_to_can_frame(struct ican3_dev *mod,\r\nstruct ican3_fast_desc *desc,\r\nstruct can_frame *cf)\r\n{\r\nif ((desc->command & ICAN3_CAN_TYPE_MASK) == ICAN3_CAN_TYPE_SFF) {\r\nif (desc->data[1] & ICAN3_SFF_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\ncf->can_id |= desc->data[0] << 3;\r\ncf->can_id |= (desc->data[1] & 0xe0) >> 5;\r\ncf->can_dlc = get_can_dlc(desc->data[1] & ICAN3_CAN_DLC_MASK);\r\nmemcpy(cf->data, &desc->data[2], cf->can_dlc);\r\n} else {\r\ncf->can_dlc = get_can_dlc(desc->data[0] & ICAN3_CAN_DLC_MASK);\r\nif (desc->data[0] & ICAN3_EFF_RTR)\r\ncf->can_id |= CAN_RTR_FLAG;\r\nif (desc->data[0] & ICAN3_EFF) {\r\ncf->can_id |= CAN_EFF_FLAG;\r\ncf->can_id |= desc->data[2] << 21;\r\ncf->can_id |= desc->data[3] << 13;\r\ncf->can_id |= desc->data[4] << 5;\r\ncf->can_id |= (desc->data[5] & 0xf8) >> 3;\r\n} else {\r\ncf->can_id |= desc->data[2] << 3;\r\ncf->can_id |= desc->data[3] >> 5;\r\n}\r\nmemcpy(cf->data, &desc->data[6], cf->can_dlc);\r\n}\r\n}\r\nstatic void can_frame_to_ican3(struct ican3_dev *mod,\r\nstruct can_frame *cf,\r\nstruct ican3_fast_desc *desc)\r\n{\r\nmemset(desc->data, 0, sizeof(desc->data));\r\ndesc->command = ICAN3_CAN_TYPE_EFF;\r\ndesc->data[0] |= cf->can_dlc;\r\ndesc->data[1] |= ICAN3_ECHO;\r\nif (mod->can.ctrlmode & CAN_CTRLMODE_ONE_SHOT)\r\ndesc->data[1] |= ICAN3_SNGL;\r\nif (cf->can_id & CAN_RTR_FLAG)\r\ndesc->data[0] |= ICAN3_EFF_RTR;\r\nif (cf->can_id & CAN_EFF_FLAG) {\r\ndesc->data[0] |= ICAN3_EFF;\r\ndesc->data[2] = (cf->can_id & 0x1fe00000) >> 21;\r\ndesc->data[3] = (cf->can_id & 0x001fe000) >> 13;\r\ndesc->data[4] = (cf->can_id & 0x00001fe0) >> 5;\r\ndesc->data[5] = (cf->can_id & 0x0000001f) << 3;\r\n} else {\r\ndesc->data[2] = (cf->can_id & 0x7F8) >> 3;\r\ndesc->data[3] = (cf->can_id & 0x007) << 5;\r\n}\r\nmemcpy(&desc->data[6], cf->data, cf->can_dlc);\r\n}\r\nstatic void ican3_handle_idvers(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nnetdev_dbg(mod->ndev, "IDVERS response: %s\n", msg->data);\r\n}\r\nstatic void ican3_handle_msglost(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nstruct net_device *dev = mod->ndev;\r\nstruct net_device_stats *stats = &dev->stats;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (msg->spec == MSG_MSGLOST) {\r\nnetdev_err(mod->ndev, "lost %d control messages\n", msg->data[0]);\r\nreturn;\r\n}\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (skb) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\nnetif_rx(skb);\r\n}\r\n}\r\nstatic int ican3_handle_cevtind(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nstruct net_device *dev = mod->ndev;\r\nstruct net_device_stats *stats = &dev->stats;\r\nenum can_state state = mod->can.state;\r\nu8 isrc, ecc, status, rxerr, txerr;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nif (msg->data[1] != CEVTIND_CHIP_SJA1000) {\r\nnetdev_err(mod->ndev, "unable to handle errors on non-SJA1000\n");\r\nreturn -ENODEV;\r\n}\r\nif (le16_to_cpu(msg->len) < 6) {\r\nnetdev_err(mod->ndev, "error message too short\n");\r\nreturn -EINVAL;\r\n}\r\nisrc = msg->data[0];\r\necc = msg->data[2];\r\nstatus = msg->data[3];\r\nrxerr = msg->data[4];\r\ntxerr = msg->data[5];\r\nif (isrc == CEVTIND_BEI) {\r\nint ret;\r\nnetdev_dbg(mod->ndev, "bus error interrupt\n");\r\nif (!(ecc & ECC_DIR)) {\r\nkfree_skb(skb_dequeue(&mod->echoq));\r\nstats->tx_errors++;\r\n} else {\r\nstats->rx_errors++;\r\n}\r\nret = ican3_set_buserror(mod, 1);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to re-enable bus-error\n");\r\nreturn ret;\r\n}\r\nif (!(mod->can.ctrlmode & CAN_CTRLMODE_BERR_REPORTING))\r\nreturn 0;\r\n}\r\nskb = alloc_can_err_skb(dev, &cf);\r\nif (skb == NULL)\r\nreturn -ENOMEM;\r\nif (isrc == CEVTIND_DOI || isrc == CEVTIND_LOST) {\r\nnetdev_dbg(mod->ndev, "data overrun interrupt\n");\r\ncf->can_id |= CAN_ERR_CRTL;\r\ncf->data[1] = CAN_ERR_CRTL_RX_OVERFLOW;\r\nstats->rx_over_errors++;\r\nstats->rx_errors++;\r\n}\r\nif (isrc == CEVTIND_EI) {\r\nnetdev_dbg(mod->ndev, "error warning + passive interrupt\n");\r\nif (status & SR_BS) {\r\nstate = CAN_STATE_BUS_OFF;\r\ncf->can_id |= CAN_ERR_BUSOFF;\r\nmod->can.can_stats.bus_off++;\r\ncan_bus_off(dev);\r\n} else if (status & SR_ES) {\r\nif (rxerr >= 128 || txerr >= 128)\r\nstate = CAN_STATE_ERROR_PASSIVE;\r\nelse\r\nstate = CAN_STATE_ERROR_WARNING;\r\n} else {\r\nstate = CAN_STATE_ERROR_ACTIVE;\r\n}\r\n}\r\nif (isrc == CEVTIND_BEI) {\r\nmod->can.can_stats.bus_error++;\r\ncf->can_id |= CAN_ERR_PROT | CAN_ERR_BUSERROR;\r\nswitch (ecc & ECC_MASK) {\r\ncase ECC_BIT:\r\ncf->data[2] |= CAN_ERR_PROT_BIT;\r\nbreak;\r\ncase ECC_FORM:\r\ncf->data[2] |= CAN_ERR_PROT_FORM;\r\nbreak;\r\ncase ECC_STUFF:\r\ncf->data[2] |= CAN_ERR_PROT_STUFF;\r\nbreak;\r\ndefault:\r\ncf->data[3] = ecc & ECC_SEG;\r\nbreak;\r\n}\r\nif (!(ecc & ECC_DIR))\r\ncf->data[2] |= CAN_ERR_PROT_TX;\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\nif (state != mod->can.state && (state == CAN_STATE_ERROR_WARNING ||\r\nstate == CAN_STATE_ERROR_PASSIVE)) {\r\ncf->can_id |= CAN_ERR_CRTL;\r\nif (state == CAN_STATE_ERROR_WARNING) {\r\nmod->can.can_stats.error_warning++;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_WARNING :\r\nCAN_ERR_CRTL_RX_WARNING;\r\n} else {\r\nmod->can.can_stats.error_passive++;\r\ncf->data[1] = (txerr > rxerr) ?\r\nCAN_ERR_CRTL_TX_PASSIVE :\r\nCAN_ERR_CRTL_RX_PASSIVE;\r\n}\r\ncf->data[6] = txerr;\r\ncf->data[7] = rxerr;\r\n}\r\nmod->can.state = state;\r\nnetif_rx(skb);\r\nreturn 0;\r\n}\r\nstatic void ican3_handle_inquiry(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nswitch (msg->data[0]) {\r\ncase INQUIRY_STATUS:\r\ncase INQUIRY_EXTENDED:\r\nmod->bec.rxerr = msg->data[5];\r\nmod->bec.txerr = msg->data[6];\r\ncomplete(&mod->buserror_comp);\r\nbreak;\r\ncase INQUIRY_TERMINATION:\r\nmod->termination_enabled = msg->data[6] & HWCONF_TERMINATE_ON;\r\ncomplete(&mod->termination_comp);\r\nbreak;\r\ndefault:\r\nnetdev_err(mod->ndev, "received an unknown inquiry response\n");\r\nbreak;\r\n}\r\n}\r\nstatic void ican3_handle_nmtsind(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nu16 subspec;\r\nsubspec = msg->data[0] + msg->data[1] * 0x100;\r\nif (subspec == NMTS_SLAVE_EVENT_IND) {\r\nswitch (msg->data[2]) {\r\ncase NE_LOCAL_OCCURRED:\r\ncase NE_LOCAL_RESOLVED:\r\nle16_add_cpu(&msg->len, -3);\r\nmemmove(msg->data, msg->data + 3, le16_to_cpu(msg->len));\r\nican3_handle_cevtind(mod, msg);\r\nbreak;\r\ncase NE_REMOTE_OCCURRED:\r\ncase NE_REMOTE_RESOLVED:\r\nbreak;\r\ndefault:\r\nnetdev_warn(mod->ndev, "unknown NMTS event indication %x\n",\r\nmsg->data[2]);\r\nbreak;\r\n}\r\n} else if (subspec == NMTS_SLAVE_STATE_IND) {\r\n} else {\r\nnetdev_warn(mod->ndev, "unhandled NMTS indication %x\n",\r\nsubspec);\r\nreturn;\r\n}\r\n}\r\nstatic void ican3_handle_unknown_message(struct ican3_dev *mod,\r\nstruct ican3_msg *msg)\r\n{\r\nnetdev_warn(mod->ndev, "received unknown message: spec 0x%.2x length %d\n",\r\nmsg->spec, le16_to_cpu(msg->len));\r\n}\r\nstatic void ican3_handle_message(struct ican3_dev *mod, struct ican3_msg *msg)\r\n{\r\nnetdev_dbg(mod->ndev, "%s: modno %d spec 0x%.2x len %d bytes\n", __func__,\r\nmod->num, msg->spec, le16_to_cpu(msg->len));\r\nswitch (msg->spec) {\r\ncase MSG_IDVERS:\r\nican3_handle_idvers(mod, msg);\r\nbreak;\r\ncase MSG_MSGLOST:\r\ncase MSG_FMSGLOST:\r\nican3_handle_msglost(mod, msg);\r\nbreak;\r\ncase MSG_CEVTIND:\r\nican3_handle_cevtind(mod, msg);\r\nbreak;\r\ncase MSG_INQUIRY:\r\nican3_handle_inquiry(mod, msg);\r\nbreak;\r\ncase MSG_NMTS:\r\nican3_handle_nmtsind(mod, msg);\r\nbreak;\r\ndefault:\r\nican3_handle_unknown_message(mod, msg);\r\nbreak;\r\n}\r\n}\r\nstatic void ican3_put_echo_skb(struct ican3_dev *mod, struct sk_buff *skb)\r\n{\r\nskb = can_create_echo_skb(skb);\r\nif (!skb)\r\nreturn;\r\nskb_queue_tail(&mod->echoq, skb);\r\n}\r\nstatic unsigned int ican3_get_echo_skb(struct ican3_dev *mod)\r\n{\r\nstruct sk_buff *skb = skb_dequeue(&mod->echoq);\r\nstruct can_frame *cf;\r\nu8 dlc;\r\nif (!skb) {\r\nnetdev_err(mod->ndev, "BUG: echo skb not occupied\n");\r\nreturn 0;\r\n}\r\ncf = (struct can_frame *)skb->data;\r\ndlc = cf->can_dlc;\r\nif (skb->pkt_type != PACKET_LOOPBACK) {\r\nkfree_skb(skb);\r\nreturn dlc;\r\n}\r\nskb->protocol = htons(ETH_P_CAN);\r\nskb->pkt_type = PACKET_BROADCAST;\r\nskb->ip_summed = CHECKSUM_UNNECESSARY;\r\nskb->dev = mod->ndev;\r\nnetif_receive_skb(skb);\r\nreturn dlc;\r\n}\r\nstatic bool ican3_echo_skb_matches(struct ican3_dev *mod, struct sk_buff *skb)\r\n{\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct sk_buff *echo_skb = skb_peek(&mod->echoq);\r\nstruct can_frame *echo_cf;\r\nif (!echo_skb)\r\nreturn false;\r\necho_cf = (struct can_frame *)echo_skb->data;\r\nif (cf->can_id != echo_cf->can_id)\r\nreturn false;\r\nif (cf->can_dlc != echo_cf->can_dlc)\r\nreturn false;\r\nreturn memcmp(cf->data, echo_cf->data, cf->can_dlc) == 0;\r\n}\r\nstatic bool ican3_txok(struct ican3_dev *mod)\r\n{\r\nstruct ican3_fast_desc __iomem *desc;\r\nu8 control;\r\nif (skb_queue_len(&mod->echoq) >= ICAN3_TX_BUFFERS)\r\nreturn false;\r\nican3_set_page(mod, mod->fasttx_start + (mod->fasttx_num / 16));\r\ndesc = mod->dpm + ((mod->fasttx_num % 16) * sizeof(*desc));\r\ncontrol = ioread8(&desc->control);\r\nif (!(control & DESC_VALID))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic int ican3_recv_skb(struct ican3_dev *mod)\r\n{\r\nstruct net_device *ndev = mod->ndev;\r\nstruct net_device_stats *stats = &ndev->stats;\r\nstruct ican3_fast_desc desc;\r\nvoid __iomem *desc_addr;\r\nstruct can_frame *cf;\r\nstruct sk_buff *skb;\r\nunsigned long flags;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nican3_set_page(mod, mod->fastrx_start + (mod->fastrx_num / 16));\r\ndesc_addr = mod->dpm + ((mod->fastrx_num % 16) * sizeof(desc));\r\nmemcpy_fromio(&desc, desc_addr, sizeof(desc));\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\nif (!(desc.control & DESC_VALID))\r\nreturn -ENOBUFS;\r\nskb = alloc_can_skb(ndev, &cf);\r\nif (unlikely(skb == NULL)) {\r\nstats->rx_dropped++;\r\ngoto err_noalloc;\r\n}\r\nican3_to_can_frame(mod, &desc, cf);\r\nif (ican3_echo_skb_matches(mod, skb)) {\r\nstats->tx_packets++;\r\nstats->tx_bytes += ican3_get_echo_skb(mod);\r\nkfree_skb(skb);\r\ngoto err_noalloc;\r\n}\r\nstats->rx_packets++;\r\nstats->rx_bytes += cf->can_dlc;\r\nnetif_receive_skb(skb);\r\nerr_noalloc:\r\ndesc.control ^= DESC_VALID;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nican3_set_page(mod, mod->fastrx_start + (mod->fastrx_num / 16));\r\nmemcpy_toio(desc_addr, &desc, 1);\r\nmod->fastrx_num = (desc.control & DESC_WRAP) ? 0\r\n: (mod->fastrx_num + 1);\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\nreturn 0;\r\n}\r\nstatic int ican3_napi(struct napi_struct *napi, int budget)\r\n{\r\nstruct ican3_dev *mod = container_of(napi, struct ican3_dev, napi);\r\nunsigned long flags;\r\nint received = 0;\r\nint ret;\r\nwhile (true) {\r\nstruct ican3_msg uninitialized_var(msg);\r\nret = ican3_recv_msg(mod, &msg);\r\nif (ret)\r\nbreak;\r\nican3_handle_message(mod, &msg);\r\n}\r\nwhile (received < budget) {\r\nret = ican3_recv_skb(mod);\r\nif (ret)\r\nbreak;\r\nreceived++;\r\n}\r\nif (received < budget)\r\nnapi_complete_done(napi, received);\r\nspin_lock_irqsave(&mod->lock, flags);\r\nif (netif_queue_stopped(mod->ndev) && ican3_txok(mod))\r\nnetif_wake_queue(mod->ndev);\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\niowrite8(1 << mod->num, &mod->ctrl->int_enable);\r\nreturn received;\r\n}\r\nstatic irqreturn_t ican3_irq(int irq, void *dev_id)\r\n{\r\nstruct ican3_dev *mod = dev_id;\r\nu8 stat;\r\nstat = ioread8(&mod->ctrl->int_disable) & (1 << mod->num);\r\nif (stat == (1 << mod->num))\r\nreturn IRQ_NONE;\r\nioread8(&mod->dpmctrl->interrupt);\r\niowrite8(1 << mod->num, &mod->ctrl->int_disable);\r\nnapi_schedule(&mod->napi);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int ican3_reset_module(struct ican3_dev *mod)\r\n{\r\nunsigned long start;\r\nu8 runold, runnew;\r\niowrite8(1 << mod->num, &mod->ctrl->int_disable);\r\nmod->free_page = DPM_FREE_START;\r\nican3_set_page(mod, QUEUE_OLD_CONTROL);\r\nrunold = ioread8(mod->dpm + TARGET_RUNNING);\r\niowrite8(0x00, &mod->dpmctrl->hwreset);\r\nstart = jiffies;\r\ndo {\r\nican3_set_page(mod, QUEUE_OLD_CONTROL);\r\nrunnew = ioread8(mod->dpm + TARGET_RUNNING);\r\nif (runnew == (runold ^ 0xff))\r\nreturn 0;\r\nmsleep(10);\r\n} while (time_before(jiffies, start + HZ / 2));\r\nnetdev_err(mod->ndev, "failed to reset CAN module\n");\r\nreturn -ETIMEDOUT;\r\n}\r\nstatic void ican3_shutdown_module(struct ican3_dev *mod)\r\n{\r\nican3_msg_disconnect(mod);\r\nican3_reset_module(mod);\r\n}\r\nstatic int ican3_startup_module(struct ican3_dev *mod)\r\n{\r\nint ret;\r\nret = ican3_reset_module(mod);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to reset module\n");\r\nreturn ret;\r\n}\r\nmemcpy_fromio(mod->fwinfo, mod->dpm + FIRMWARE_STAMP, sizeof(mod->fwinfo) - 1);\r\nif (strncmp(mod->fwinfo, "JANZ-ICAN3", 10)) {\r\nnetdev_err(mod->ndev, "ICAN3 not detected (found %s)\n", mod->fwinfo);\r\nreturn -ENODEV;\r\n}\r\nif (strstr(mod->fwinfo, "CAL/CANopen"))\r\nmod->fwtype = ICAN3_FWTYPE_CAL_CANOPEN;\r\nelse\r\nmod->fwtype = ICAN3_FWTYPE_ICANOS;\r\niowrite8(1 << mod->num, &mod->ctrl->int_enable);\r\nret = ican3_msg_connect(mod);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to connect to module\n");\r\nreturn ret;\r\n}\r\nican3_init_new_host_interface(mod);\r\nret = ican3_msg_newhostif(mod);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to switch to new-style interface\n");\r\nreturn ret;\r\n}\r\nret = ican3_set_termination(mod, true);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to enable termination\n");\r\nreturn ret;\r\n}\r\nret = ican3_set_buserror(mod, 1);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to set bus-error\n");\r\nreturn ret;\r\n}\r\nican3_init_fast_host_interface(mod);\r\nret = ican3_msg_fasthostif(mod);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to switch to fast host interface\n");\r\nreturn ret;\r\n}\r\nret = ican3_set_id_filter(mod, true);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to set acceptance filter\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic int ican3_open(struct net_device *ndev)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(ndev);\r\nint ret;\r\nret = open_candev(ndev);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to start CAN layer\n");\r\nreturn ret;\r\n}\r\nret = ican3_set_bus_state(mod, true);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to set bus-on\n");\r\nclose_candev(ndev);\r\nreturn ret;\r\n}\r\nmod->can.state = CAN_STATE_ERROR_ACTIVE;\r\nnetif_start_queue(ndev);\r\nreturn 0;\r\n}\r\nstatic int ican3_stop(struct net_device *ndev)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(ndev);\r\nint ret;\r\nnetif_stop_queue(ndev);\r\nmod->can.state = CAN_STATE_STOPPED;\r\nret = ican3_set_bus_state(mod, false);\r\nif (ret) {\r\nnetdev_err(mod->ndev, "unable to set bus-off\n");\r\nreturn ret;\r\n}\r\nskb_queue_purge(&mod->echoq);\r\nclose_candev(ndev);\r\nreturn 0;\r\n}\r\nstatic int ican3_xmit(struct sk_buff *skb, struct net_device *ndev)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(ndev);\r\nstruct can_frame *cf = (struct can_frame *)skb->data;\r\nstruct ican3_fast_desc desc;\r\nvoid __iomem *desc_addr;\r\nunsigned long flags;\r\nif (can_dropped_invalid_skb(ndev, skb))\r\nreturn NETDEV_TX_OK;\r\nspin_lock_irqsave(&mod->lock, flags);\r\nif (!ican3_txok(mod)) {\r\nnetdev_err(mod->ndev, "BUG: no free descriptors\n");\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\nreturn NETDEV_TX_BUSY;\r\n}\r\nican3_set_page(mod, mod->fasttx_start + (mod->fasttx_num / 16));\r\ndesc_addr = mod->dpm + ((mod->fasttx_num % 16) * sizeof(desc));\r\nmemset(&desc, 0, sizeof(desc));\r\nmemcpy_fromio(&desc, desc_addr, 1);\r\ncan_frame_to_ican3(mod, cf, &desc);\r\nican3_put_echo_skb(mod, skb);\r\ndesc.control |= DESC_IVALID;\r\nmemcpy_toio(desc_addr, &desc, sizeof(desc));\r\niowrite8(0x01, &mod->dpmctrl->interrupt);\r\ndesc.control ^= DESC_VALID;\r\nmemcpy_toio(desc_addr, &desc, sizeof(desc));\r\nmod->fasttx_num = (desc.control & DESC_WRAP) ? 0\r\n: (mod->fasttx_num + 1);\r\nif (!ican3_txok(mod))\r\nnetif_stop_queue(ndev);\r\nspin_unlock_irqrestore(&mod->lock, flags);\r\nreturn NETDEV_TX_OK;\r\n}\r\nstatic int ican3_set_mode(struct net_device *ndev, enum can_mode mode)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(ndev);\r\nint ret;\r\nif (mode != CAN_MODE_START)\r\nreturn -ENOTSUPP;\r\nret = ican3_set_bus_state(mod, true);\r\nif (ret) {\r\nnetdev_err(ndev, "unable to set bus-on\n");\r\nreturn ret;\r\n}\r\nmod->can.state = CAN_STATE_ERROR_ACTIVE;\r\nif (netif_queue_stopped(ndev))\r\nnetif_wake_queue(ndev);\r\nreturn 0;\r\n}\r\nstatic int ican3_get_berr_counter(const struct net_device *ndev,\r\nstruct can_berr_counter *bec)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(ndev);\r\nint ret;\r\nret = ican3_send_inquiry(mod, INQUIRY_STATUS);\r\nif (ret)\r\nreturn ret;\r\nif (!wait_for_completion_timeout(&mod->buserror_comp, HZ)) {\r\nnetdev_info(mod->ndev, "%s timed out\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nbec->rxerr = mod->bec.rxerr;\r\nbec->txerr = mod->bec.txerr;\r\nreturn 0;\r\n}\r\nstatic ssize_t ican3_sysfs_show_term(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(to_net_dev(dev));\r\nint ret;\r\nret = ican3_send_inquiry(mod, INQUIRY_TERMINATION);\r\nif (ret)\r\nreturn ret;\r\nif (!wait_for_completion_timeout(&mod->termination_comp, HZ)) {\r\nnetdev_info(mod->ndev, "%s timed out\n", __func__);\r\nreturn -ETIMEDOUT;\r\n}\r\nreturn snprintf(buf, PAGE_SIZE, "%u\n", mod->termination_enabled);\r\n}\r\nstatic ssize_t ican3_sysfs_set_term(struct device *dev,\r\nstruct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(to_net_dev(dev));\r\nunsigned long enable;\r\nint ret;\r\nif (kstrtoul(buf, 0, &enable))\r\nreturn -EINVAL;\r\nret = ican3_set_termination(mod, enable);\r\nif (ret)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t ican3_sysfs_show_fwinfo(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct ican3_dev *mod = netdev_priv(to_net_dev(dev));\r\nreturn scnprintf(buf, PAGE_SIZE, "%s\n", mod->fwinfo);\r\n}\r\nstatic int ican3_probe(struct platform_device *pdev)\r\n{\r\nstruct janz_platform_data *pdata;\r\nstruct net_device *ndev;\r\nstruct ican3_dev *mod;\r\nstruct resource *res;\r\nstruct device *dev;\r\nint ret;\r\npdata = dev_get_platdata(&pdev->dev);\r\nif (!pdata)\r\nreturn -ENXIO;\r\ndev_dbg(&pdev->dev, "probe: module number %d\n", pdata->modno);\r\ndev = &pdev->dev;\r\nndev = alloc_candev(sizeof(*mod), 0);\r\nif (!ndev) {\r\ndev_err(dev, "unable to allocate CANdev\n");\r\nret = -ENOMEM;\r\ngoto out_return;\r\n}\r\nplatform_set_drvdata(pdev, ndev);\r\nmod = netdev_priv(ndev);\r\nmod->ndev = ndev;\r\nmod->num = pdata->modno;\r\nnetif_napi_add(ndev, &mod->napi, ican3_napi, ICAN3_RX_BUFFERS);\r\nskb_queue_head_init(&mod->echoq);\r\nspin_lock_init(&mod->lock);\r\ninit_completion(&mod->termination_comp);\r\ninit_completion(&mod->buserror_comp);\r\nndev->sysfs_groups[0] = &ican3_sysfs_attr_group;\r\nmod->free_page = DPM_FREE_START;\r\nndev->netdev_ops = &ican3_netdev_ops;\r\nndev->flags |= IFF_ECHO;\r\nSET_NETDEV_DEV(ndev, &pdev->dev);\r\nmod->can.clock.freq = ICAN3_CAN_CLOCK;\r\nmod->can.bittiming_const = &ican3_bittiming_const;\r\nmod->can.do_set_mode = ican3_set_mode;\r\nmod->can.do_get_berr_counter = ican3_get_berr_counter;\r\nmod->can.ctrlmode_supported = CAN_CTRLMODE_3_SAMPLES\r\n| CAN_CTRLMODE_BERR_REPORTING\r\n| CAN_CTRLMODE_ONE_SHOT;\r\nmod->irq = platform_get_irq(pdev, 0);\r\nif (mod->irq < 0) {\r\ndev_err(dev, "IRQ line not found\n");\r\nret = -ENODEV;\r\ngoto out_free_ndev;\r\n}\r\nndev->irq = mod->irq;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res) {\r\ndev_err(dev, "MODULbus registers not found\n");\r\nret = -ENODEV;\r\ngoto out_free_ndev;\r\n}\r\nmod->dpm = ioremap(res->start, resource_size(res));\r\nif (!mod->dpm) {\r\ndev_err(dev, "MODULbus registers not ioremap\n");\r\nret = -ENOMEM;\r\ngoto out_free_ndev;\r\n}\r\nmod->dpmctrl = mod->dpm + DPM_PAGE_SIZE;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\r\nif (!res) {\r\ndev_err(dev, "CONTROL registers not found\n");\r\nret = -ENODEV;\r\ngoto out_iounmap_dpm;\r\n}\r\nmod->ctrl = ioremap(res->start, resource_size(res));\r\nif (!mod->ctrl) {\r\ndev_err(dev, "CONTROL registers not ioremap\n");\r\nret = -ENOMEM;\r\ngoto out_iounmap_dpm;\r\n}\r\niowrite8(1 << mod->num, &mod->ctrl->int_disable);\r\nret = request_irq(mod->irq, ican3_irq, IRQF_SHARED, DRV_NAME, mod);\r\nif (ret) {\r\ndev_err(dev, "unable to request IRQ\n");\r\ngoto out_iounmap_ctrl;\r\n}\r\nnapi_enable(&mod->napi);\r\nret = ican3_startup_module(mod);\r\nif (ret) {\r\ndev_err(dev, "%s: unable to start CANdev\n", __func__);\r\ngoto out_free_irq;\r\n}\r\nret = register_candev(ndev);\r\nif (ret) {\r\ndev_err(dev, "%s: unable to register CANdev\n", __func__);\r\ngoto out_free_irq;\r\n}\r\nnetdev_info(mod->ndev, "module %d: registered CAN device\n", pdata->modno);\r\nreturn 0;\r\nout_free_irq:\r\nnapi_disable(&mod->napi);\r\niowrite8(1 << mod->num, &mod->ctrl->int_disable);\r\nfree_irq(mod->irq, mod);\r\nout_iounmap_ctrl:\r\niounmap(mod->ctrl);\r\nout_iounmap_dpm:\r\niounmap(mod->dpm);\r\nout_free_ndev:\r\nfree_candev(ndev);\r\nout_return:\r\nreturn ret;\r\n}\r\nstatic int ican3_remove(struct platform_device *pdev)\r\n{\r\nstruct net_device *ndev = platform_get_drvdata(pdev);\r\nstruct ican3_dev *mod = netdev_priv(ndev);\r\nunregister_netdev(ndev);\r\nnapi_disable(&mod->napi);\r\niowrite8(1 << mod->num, &mod->ctrl->int_disable);\r\nfree_irq(mod->irq, mod);\r\nican3_shutdown_module(mod);\r\niounmap(mod->ctrl);\r\niounmap(mod->dpm);\r\nfree_candev(ndev);\r\nreturn 0;\r\n}
