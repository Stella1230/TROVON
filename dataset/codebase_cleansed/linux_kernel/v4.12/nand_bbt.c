static inline uint8_t bbt_get_entry(struct nand_chip *chip, int block)\r\n{\r\nuint8_t entry = chip->bbt[block >> BBT_ENTRY_SHIFT];\r\nentry >>= (block & BBT_ENTRY_MASK) * 2;\r\nreturn entry & BBT_ENTRY_MASK;\r\n}\r\nstatic inline void bbt_mark_entry(struct nand_chip *chip, int block,\r\nuint8_t mark)\r\n{\r\nuint8_t msk = (mark & BBT_ENTRY_MASK) << ((block & BBT_ENTRY_MASK) * 2);\r\nchip->bbt[block >> BBT_ENTRY_SHIFT] |= msk;\r\n}\r\nstatic int check_pattern_no_oob(uint8_t *buf, struct nand_bbt_descr *td)\r\n{\r\nif (memcmp(buf, td->pattern, td->len))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int check_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)\r\n{\r\nif (td->options & NAND_BBT_NO_OOB)\r\nreturn check_pattern_no_oob(buf, td);\r\nif (memcmp(buf + paglen + td->offs, td->pattern, td->len))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic int check_short_pattern(uint8_t *buf, struct nand_bbt_descr *td)\r\n{\r\nif (memcmp(buf + td->offs, td->pattern, td->len))\r\nreturn -1;\r\nreturn 0;\r\n}\r\nstatic u32 add_marker_len(struct nand_bbt_descr *td)\r\n{\r\nu32 len;\r\nif (!(td->options & NAND_BBT_NO_OOB))\r\nreturn 0;\r\nlen = td->len;\r\nif (td->options & NAND_BBT_VERSION)\r\nlen++;\r\nreturn len;\r\n}\r\nstatic int read_bbt(struct mtd_info *mtd, uint8_t *buf, int page, int num,\r\nstruct nand_bbt_descr *td, int offs)\r\n{\r\nint res, ret = 0, i, j, act = 0;\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nsize_t retlen, len, totlen;\r\nloff_t from;\r\nint bits = td->options & NAND_BBT_NRBITS_MSK;\r\nuint8_t msk = (uint8_t)((1 << bits) - 1);\r\nu32 marker_len;\r\nint reserved_block_code = td->reserved_block_code;\r\ntotlen = (num * bits) >> 3;\r\nmarker_len = add_marker_len(td);\r\nfrom = ((loff_t)page) << this->page_shift;\r\nwhile (totlen) {\r\nlen = min(totlen, (size_t)(1 << this->bbt_erase_shift));\r\nif (marker_len) {\r\nlen -= marker_len;\r\nfrom += marker_len;\r\nmarker_len = 0;\r\n}\r\nres = mtd_read(mtd, from, len, &retlen, buf);\r\nif (res < 0) {\r\nif (mtd_is_eccerr(res)) {\r\npr_info("nand_bbt: ECC error in BBT at 0x%012llx\n",\r\nfrom & ~mtd->writesize);\r\nreturn res;\r\n} else if (mtd_is_bitflip(res)) {\r\npr_info("nand_bbt: corrected error in BBT at 0x%012llx\n",\r\nfrom & ~mtd->writesize);\r\nret = res;\r\n} else {\r\npr_info("nand_bbt: error reading BBT\n");\r\nreturn res;\r\n}\r\n}\r\nfor (i = 0; i < len; i++) {\r\nuint8_t dat = buf[i];\r\nfor (j = 0; j < 8; j += bits, act++) {\r\nuint8_t tmp = (dat >> j) & msk;\r\nif (tmp == msk)\r\ncontinue;\r\nif (reserved_block_code && (tmp == reserved_block_code)) {\r\npr_info("nand_read_bbt: reserved block at 0x%012llx\n",\r\n(loff_t)(offs + act) <<\r\nthis->bbt_erase_shift);\r\nbbt_mark_entry(this, offs + act,\r\nBBT_BLOCK_RESERVED);\r\nmtd->ecc_stats.bbtblocks++;\r\ncontinue;\r\n}\r\npr_info("nand_read_bbt: bad block at 0x%012llx\n",\r\n(loff_t)(offs + act) <<\r\nthis->bbt_erase_shift);\r\nif (tmp == 0)\r\nbbt_mark_entry(this, offs + act,\r\nBBT_BLOCK_FACTORY_BAD);\r\nelse\r\nbbt_mark_entry(this, offs + act,\r\nBBT_BLOCK_WORN);\r\nmtd->ecc_stats.badblocks++;\r\n}\r\n}\r\ntotlen -= len;\r\nfrom += len;\r\n}\r\nreturn ret;\r\n}\r\nstatic int read_abs_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td, int chip)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint res = 0, i;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nint offs = 0;\r\nfor (i = 0; i < this->numchips; i++) {\r\nif (chip == -1 || chip == i)\r\nres = read_bbt(mtd, buf, td->pages[i],\r\nthis->chipsize >> this->bbt_erase_shift,\r\ntd, offs);\r\nif (res)\r\nreturn res;\r\noffs += this->chipsize >> this->bbt_erase_shift;\r\n}\r\n} else {\r\nres = read_bbt(mtd, buf, td->pages[0],\r\nmtd->size >> this->bbt_erase_shift, td, 0);\r\nif (res)\r\nreturn res;\r\n}\r\nreturn 0;\r\n}\r\nstatic int scan_read_data(struct mtd_info *mtd, uint8_t *buf, loff_t offs,\r\nstruct nand_bbt_descr *td)\r\n{\r\nsize_t retlen;\r\nsize_t len;\r\nlen = td->len;\r\nif (td->options & NAND_BBT_VERSION)\r\nlen++;\r\nreturn mtd_read(mtd, offs, len, &retlen, buf);\r\n}\r\nstatic int scan_read_oob(struct mtd_info *mtd, uint8_t *buf, loff_t offs,\r\nsize_t len)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint res, ret = 0;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooboffs = 0;\r\nops.ooblen = mtd->oobsize;\r\nwhile (len > 0) {\r\nops.datbuf = buf;\r\nops.len = min(len, (size_t)mtd->writesize);\r\nops.oobbuf = buf + ops.len;\r\nres = mtd_read_oob(mtd, offs, &ops);\r\nif (res) {\r\nif (!mtd_is_bitflip_or_eccerr(res))\r\nreturn res;\r\nelse if (mtd_is_eccerr(res) || !ret)\r\nret = res;\r\n}\r\nbuf += mtd->oobsize + mtd->writesize;\r\nlen -= mtd->writesize;\r\noffs += mtd->writesize;\r\n}\r\nreturn ret;\r\n}\r\nstatic int scan_read(struct mtd_info *mtd, uint8_t *buf, loff_t offs,\r\nsize_t len, struct nand_bbt_descr *td)\r\n{\r\nif (td->options & NAND_BBT_NO_OOB)\r\nreturn scan_read_data(mtd, buf, offs, td);\r\nelse\r\nreturn scan_read_oob(mtd, buf, offs, len);\r\n}\r\nstatic int scan_write_bbt(struct mtd_info *mtd, loff_t offs, size_t len,\r\nuint8_t *buf, uint8_t *oob)\r\n{\r\nstruct mtd_oob_ops ops;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooboffs = 0;\r\nops.ooblen = mtd->oobsize;\r\nops.datbuf = buf;\r\nops.oobbuf = oob;\r\nops.len = len;\r\nreturn mtd_write_oob(mtd, offs, &ops);\r\n}\r\nstatic u32 bbt_get_ver_offs(struct mtd_info *mtd, struct nand_bbt_descr *td)\r\n{\r\nu32 ver_offs = td->veroffs;\r\nif (!(td->options & NAND_BBT_NO_OOB))\r\nver_offs += mtd->writesize;\r\nreturn ver_offs;\r\n}\r\nstatic void read_abs_bbts(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *td, struct nand_bbt_descr *md)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nif (td->options & NAND_BBT_VERSION) {\r\nscan_read(mtd, buf, (loff_t)td->pages[0] << this->page_shift,\r\nmtd->writesize, td);\r\ntd->version[0] = buf[bbt_get_ver_offs(mtd, td)];\r\npr_info("Bad block table at page %d, version 0x%02X\n",\r\ntd->pages[0], td->version[0]);\r\n}\r\nif (md && (md->options & NAND_BBT_VERSION)) {\r\nscan_read(mtd, buf, (loff_t)md->pages[0] << this->page_shift,\r\nmtd->writesize, md);\r\nmd->version[0] = buf[bbt_get_ver_offs(mtd, md)];\r\npr_info("Bad block table at page %d, version 0x%02X\n",\r\nmd->pages[0], md->version[0]);\r\n}\r\n}\r\nstatic int scan_block_fast(struct mtd_info *mtd, struct nand_bbt_descr *bd,\r\nloff_t offs, uint8_t *buf, int numpages)\r\n{\r\nstruct mtd_oob_ops ops;\r\nint j, ret;\r\nops.ooblen = mtd->oobsize;\r\nops.oobbuf = buf;\r\nops.ooboffs = 0;\r\nops.datbuf = NULL;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nfor (j = 0; j < numpages; j++) {\r\nret = mtd_read_oob(mtd, offs, &ops);\r\nif (ret && !mtd_is_bitflip_or_eccerr(ret))\r\nreturn ret;\r\nif (check_short_pattern(buf, bd))\r\nreturn 1;\r\noffs += mtd->writesize;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_bbt(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *bd, int chip)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint i, numblocks, numpages;\r\nint startblock;\r\nloff_t from;\r\npr_info("Scanning device for bad blocks\n");\r\nif (bd->options & NAND_BBT_SCAN2NDPAGE)\r\nnumpages = 2;\r\nelse\r\nnumpages = 1;\r\nif (chip == -1) {\r\nnumblocks = mtd->size >> this->bbt_erase_shift;\r\nstartblock = 0;\r\nfrom = 0;\r\n} else {\r\nif (chip >= this->numchips) {\r\npr_warn("create_bbt(): chipnr (%d) > available chips (%d)\n",\r\nchip + 1, this->numchips);\r\nreturn -EINVAL;\r\n}\r\nnumblocks = this->chipsize >> this->bbt_erase_shift;\r\nstartblock = chip * numblocks;\r\nnumblocks += startblock;\r\nfrom = (loff_t)startblock << this->bbt_erase_shift;\r\n}\r\nif (this->bbt_options & NAND_BBT_SCANLASTPAGE)\r\nfrom += mtd->erasesize - (mtd->writesize * numpages);\r\nfor (i = startblock; i < numblocks; i++) {\r\nint ret;\r\nBUG_ON(bd->options & NAND_BBT_NO_OOB);\r\nret = scan_block_fast(mtd, bd, from, buf, numpages);\r\nif (ret < 0)\r\nreturn ret;\r\nif (ret) {\r\nbbt_mark_entry(this, i, BBT_BLOCK_FACTORY_BAD);\r\npr_warn("Bad eraseblock %d at 0x%012llx\n",\r\ni, (unsigned long long)from);\r\nmtd->ecc_stats.badblocks++;\r\n}\r\nfrom += (1 << this->bbt_erase_shift);\r\n}\r\nreturn 0;\r\n}\r\nstatic int search_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *td)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint i, chips;\r\nint startblock, block, dir;\r\nint scanlen = mtd->writesize + mtd->oobsize;\r\nint bbtblocks;\r\nint blocktopage = this->bbt_erase_shift - this->page_shift;\r\nif (td->options & NAND_BBT_LASTBLOCK) {\r\nstartblock = (mtd->size >> this->bbt_erase_shift) - 1;\r\ndir = -1;\r\n} else {\r\nstartblock = 0;\r\ndir = 1;\r\n}\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nchips = this->numchips;\r\nbbtblocks = this->chipsize >> this->bbt_erase_shift;\r\nstartblock &= bbtblocks - 1;\r\n} else {\r\nchips = 1;\r\nbbtblocks = mtd->size >> this->bbt_erase_shift;\r\n}\r\nfor (i = 0; i < chips; i++) {\r\ntd->version[i] = 0;\r\ntd->pages[i] = -1;\r\nfor (block = 0; block < td->maxblocks; block++) {\r\nint actblock = startblock + dir * block;\r\nloff_t offs = (loff_t)actblock << this->bbt_erase_shift;\r\nscan_read(mtd, buf, offs, mtd->writesize, td);\r\nif (!check_pattern(buf, scanlen, mtd->writesize, td)) {\r\ntd->pages[i] = actblock << blocktopage;\r\nif (td->options & NAND_BBT_VERSION) {\r\noffs = bbt_get_ver_offs(mtd, td);\r\ntd->version[i] = buf[offs];\r\n}\r\nbreak;\r\n}\r\n}\r\nstartblock += this->chipsize >> this->bbt_erase_shift;\r\n}\r\nfor (i = 0; i < chips; i++) {\r\nif (td->pages[i] == -1)\r\npr_warn("Bad block table not found for chip %d\n", i);\r\nelse\r\npr_info("Bad block table found at page %d, version 0x%02X\n",\r\ntd->pages[i], td->version[i]);\r\n}\r\nreturn 0;\r\n}\r\nstatic void search_read_bbts(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *td,\r\nstruct nand_bbt_descr *md)\r\n{\r\nsearch_bbt(mtd, buf, td);\r\nif (md)\r\nsearch_bbt(mtd, buf, md);\r\n}\r\nstatic int get_bbt_block(struct nand_chip *this, struct nand_bbt_descr *td,\r\nstruct nand_bbt_descr *md, int chip)\r\n{\r\nint startblock, dir, page, numblocks, i;\r\nif (td->pages[chip] != -1)\r\nreturn td->pages[chip] >>\r\n(this->bbt_erase_shift - this->page_shift);\r\nnumblocks = (int)(this->chipsize >> this->bbt_erase_shift);\r\nif (!(td->options & NAND_BBT_PERCHIP))\r\nnumblocks *= this->numchips;\r\nif (td->options & NAND_BBT_LASTBLOCK) {\r\nstartblock = numblocks * (chip + 1) - 1;\r\ndir = -1;\r\n} else {\r\nstartblock = chip * numblocks;\r\ndir = 1;\r\n}\r\nfor (i = 0; i < td->maxblocks; i++) {\r\nint block = startblock + dir * i;\r\nswitch (bbt_get_entry(this, block)) {\r\ncase BBT_BLOCK_WORN:\r\ncase BBT_BLOCK_FACTORY_BAD:\r\ncontinue;\r\n}\r\npage = block << (this->bbt_erase_shift - this->page_shift);\r\nif (!md || md->pages[chip] != page)\r\nreturn block;\r\n}\r\nreturn -ENOSPC;\r\n}\r\nstatic void mark_bbt_block_bad(struct nand_chip *this,\r\nstruct nand_bbt_descr *td,\r\nint chip, int block)\r\n{\r\nstruct mtd_info *mtd = nand_to_mtd(this);\r\nloff_t to;\r\nint res;\r\nbbt_mark_entry(this, block, BBT_BLOCK_WORN);\r\nto = (loff_t)block << this->bbt_erase_shift;\r\nres = this->block_markbad(mtd, to);\r\nif (res)\r\npr_warn("nand_bbt: error %d while marking block %d bad\n",\r\nres, block);\r\ntd->pages[chip] = -1;\r\n}\r\nstatic int write_bbt(struct mtd_info *mtd, uint8_t *buf,\r\nstruct nand_bbt_descr *td, struct nand_bbt_descr *md,\r\nint chipsel)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nstruct erase_info einfo;\r\nint i, res, chip = 0;\r\nint bits, page, offs, numblocks, sft, sftmsk;\r\nint nrchips, pageoffs, ooboffs;\r\nuint8_t msk[4];\r\nuint8_t rcode = td->reserved_block_code;\r\nsize_t retlen, len = 0;\r\nloff_t to;\r\nstruct mtd_oob_ops ops;\r\nops.ooblen = mtd->oobsize;\r\nops.ooboffs = 0;\r\nops.datbuf = NULL;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nif (!rcode)\r\nrcode = 0xff;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nnumblocks = (int)(this->chipsize >> this->bbt_erase_shift);\r\nif (chipsel == -1) {\r\nnrchips = this->numchips;\r\n} else {\r\nnrchips = chipsel + 1;\r\nchip = chipsel;\r\n}\r\n} else {\r\nnumblocks = (int)(mtd->size >> this->bbt_erase_shift);\r\nnrchips = 1;\r\n}\r\nwhile (chip < nrchips) {\r\nint block;\r\nblock = get_bbt_block(this, td, md, chip);\r\nif (block < 0) {\r\npr_err("No space left to write bad block table\n");\r\nres = block;\r\ngoto outerr;\r\n}\r\npage = block << (this->bbt_erase_shift - this->page_shift);\r\nbits = td->options & NAND_BBT_NRBITS_MSK;\r\nmsk[2] = ~rcode;\r\nswitch (bits) {\r\ncase 1: sft = 3; sftmsk = 0x07; msk[0] = 0x00; msk[1] = 0x01;\r\nmsk[3] = 0x01;\r\nbreak;\r\ncase 2: sft = 2; sftmsk = 0x06; msk[0] = 0x00; msk[1] = 0x01;\r\nmsk[3] = 0x03;\r\nbreak;\r\ncase 4: sft = 1; sftmsk = 0x04; msk[0] = 0x00; msk[1] = 0x0C;\r\nmsk[3] = 0x0f;\r\nbreak;\r\ncase 8: sft = 0; sftmsk = 0x00; msk[0] = 0x00; msk[1] = 0x0F;\r\nmsk[3] = 0xff;\r\nbreak;\r\ndefault: return -EINVAL;\r\n}\r\nto = ((loff_t)page) << this->page_shift;\r\nif (td->options & NAND_BBT_SAVECONTENT) {\r\nto &= ~(((loff_t)1 << this->bbt_erase_shift) - 1);\r\nlen = 1 << this->bbt_erase_shift;\r\nres = mtd_read(mtd, to, len, &retlen, buf);\r\nif (res < 0) {\r\nif (retlen != len) {\r\npr_info("nand_bbt: error reading block for writing the bad block table\n");\r\nreturn res;\r\n}\r\npr_warn("nand_bbt: ECC error while reading block for writing bad block table\n");\r\n}\r\nops.ooblen = (len >> this->page_shift) * mtd->oobsize;\r\nops.oobbuf = &buf[len];\r\nres = mtd_read_oob(mtd, to + mtd->writesize, &ops);\r\nif (res < 0 || ops.oobretlen != ops.ooblen)\r\ngoto outerr;\r\npageoffs = page - (int)(to >> this->page_shift);\r\noffs = pageoffs << this->page_shift;\r\nmemset(&buf[offs], 0xff, (size_t)(numblocks >> sft));\r\nooboffs = len + (pageoffs * mtd->oobsize);\r\n} else if (td->options & NAND_BBT_NO_OOB) {\r\nooboffs = 0;\r\noffs = td->len;\r\nif (td->options & NAND_BBT_VERSION)\r\noffs++;\r\nlen = (size_t)(numblocks >> sft);\r\nlen += offs;\r\nlen = ALIGN(len, mtd->writesize);\r\nmemset(buf, 0xff, len);\r\nmemcpy(buf, td->pattern, td->len);\r\n} else {\r\nlen = (size_t)(numblocks >> sft);\r\nlen = ALIGN(len, mtd->writesize);\r\nmemset(buf, 0xff, len +\r\n(len >> this->page_shift)* mtd->oobsize);\r\noffs = 0;\r\nooboffs = len;\r\nmemcpy(&buf[ooboffs + td->offs], td->pattern, td->len);\r\n}\r\nif (td->options & NAND_BBT_VERSION)\r\nbuf[ooboffs + td->veroffs] = td->version[chip];\r\nfor (i = 0; i < numblocks; i++) {\r\nuint8_t dat;\r\nint sftcnt = (i << (3 - sft)) & sftmsk;\r\ndat = bbt_get_entry(this, chip * numblocks + i);\r\nbuf[offs + (i >> sft)] &= ~(msk[dat] << sftcnt);\r\n}\r\nmemset(&einfo, 0, sizeof(einfo));\r\neinfo.mtd = mtd;\r\neinfo.addr = to;\r\neinfo.len = 1 << this->bbt_erase_shift;\r\nres = nand_erase_nand(mtd, &einfo, 1);\r\nif (res < 0) {\r\npr_warn("nand_bbt: error while erasing BBT block %d\n",\r\nres);\r\nmark_bbt_block_bad(this, td, chip, block);\r\ncontinue;\r\n}\r\nres = scan_write_bbt(mtd, to, len, buf,\r\ntd->options & NAND_BBT_NO_OOB ? NULL :\r\n&buf[len]);\r\nif (res < 0) {\r\npr_warn("nand_bbt: error while writing BBT block %d\n",\r\nres);\r\nmark_bbt_block_bad(this, td, chip, block);\r\ncontinue;\r\n}\r\npr_info("Bad block table written to 0x%012llx, version 0x%02X\n",\r\n(unsigned long long)to, td->version[chip]);\r\ntd->pages[chip++] = page;\r\n}\r\nreturn 0;\r\nouterr:\r\npr_warn("nand_bbt: error while writing bad block table %d\n", res);\r\nreturn res;\r\n}\r\nstatic inline int nand_memory_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nreturn create_bbt(mtd, this->buffers->databuf, bd, -1);\r\n}\r\nstatic int check_create(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd)\r\n{\r\nint i, chips, writeops, create, chipsel, res, res2;\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nstruct nand_bbt_descr *td = this->bbt_td;\r\nstruct nand_bbt_descr *md = this->bbt_md;\r\nstruct nand_bbt_descr *rd, *rd2;\r\nif (td->options & NAND_BBT_PERCHIP)\r\nchips = this->numchips;\r\nelse\r\nchips = 1;\r\nfor (i = 0; i < chips; i++) {\r\nwriteops = 0;\r\ncreate = 0;\r\nrd = NULL;\r\nrd2 = NULL;\r\nres = res2 = 0;\r\nchipsel = (td->options & NAND_BBT_PERCHIP) ? i : -1;\r\nif (md) {\r\nif (td->pages[i] == -1 && md->pages[i] == -1) {\r\ncreate = 1;\r\nwriteops = 0x03;\r\n} else if (td->pages[i] == -1) {\r\nrd = md;\r\nwriteops = 0x01;\r\n} else if (md->pages[i] == -1) {\r\nrd = td;\r\nwriteops = 0x02;\r\n} else if (td->version[i] == md->version[i]) {\r\nrd = td;\r\nif (!(td->options & NAND_BBT_VERSION))\r\nrd2 = md;\r\n} else if (((int8_t)(td->version[i] - md->version[i])) > 0) {\r\nrd = td;\r\nwriteops = 0x02;\r\n} else {\r\nrd = md;\r\nwriteops = 0x01;\r\n}\r\n} else {\r\nif (td->pages[i] == -1) {\r\ncreate = 1;\r\nwriteops = 0x01;\r\n} else {\r\nrd = td;\r\n}\r\n}\r\nif (create) {\r\nif (!(td->options & NAND_BBT_CREATE))\r\ncontinue;\r\nif (!(this->bbt_options & NAND_BBT_CREATE_EMPTY))\r\ncreate_bbt(mtd, buf, bd, chipsel);\r\ntd->version[i] = 1;\r\nif (md)\r\nmd->version[i] = 1;\r\n}\r\nif (rd) {\r\nres = read_abs_bbt(mtd, buf, rd, chipsel);\r\nif (mtd_is_eccerr(res)) {\r\nrd->pages[i] = -1;\r\nrd->version[i] = 0;\r\ni--;\r\ncontinue;\r\n}\r\n}\r\nif (rd2) {\r\nres2 = read_abs_bbt(mtd, buf, rd2, chipsel);\r\nif (mtd_is_eccerr(res2)) {\r\nrd2->pages[i] = -1;\r\nrd2->version[i] = 0;\r\ni--;\r\ncontinue;\r\n}\r\n}\r\nif (mtd_is_bitflip(res) || mtd_is_bitflip(res2))\r\nwriteops = 0x03;\r\nif (md) {\r\ntd->version[i] = max(td->version[i], md->version[i]);\r\nmd->version[i] = td->version[i];\r\n}\r\nif ((writeops & 0x01) && (td->options & NAND_BBT_WRITE)) {\r\nres = write_bbt(mtd, buf, td, md, chipsel);\r\nif (res < 0)\r\nreturn res;\r\n}\r\nif ((writeops & 0x02) && md && (md->options & NAND_BBT_WRITE)) {\r\nres = write_bbt(mtd, buf, md, td, chipsel);\r\nif (res < 0)\r\nreturn res;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic void mark_bbt_region(struct mtd_info *mtd, struct nand_bbt_descr *td)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint i, j, chips, block, nrblocks, update;\r\nuint8_t oldval;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nchips = this->numchips;\r\nnrblocks = (int)(this->chipsize >> this->bbt_erase_shift);\r\n} else {\r\nchips = 1;\r\nnrblocks = (int)(mtd->size >> this->bbt_erase_shift);\r\n}\r\nfor (i = 0; i < chips; i++) {\r\nif ((td->options & NAND_BBT_ABSPAGE) ||\r\n!(td->options & NAND_BBT_WRITE)) {\r\nif (td->pages[i] == -1)\r\ncontinue;\r\nblock = td->pages[i] >> (this->bbt_erase_shift - this->page_shift);\r\noldval = bbt_get_entry(this, block);\r\nbbt_mark_entry(this, block, BBT_BLOCK_RESERVED);\r\nif ((oldval != BBT_BLOCK_RESERVED) &&\r\ntd->reserved_block_code)\r\nnand_update_bbt(mtd, (loff_t)block <<\r\nthis->bbt_erase_shift);\r\ncontinue;\r\n}\r\nupdate = 0;\r\nif (td->options & NAND_BBT_LASTBLOCK)\r\nblock = ((i + 1) * nrblocks) - td->maxblocks;\r\nelse\r\nblock = i * nrblocks;\r\nfor (j = 0; j < td->maxblocks; j++) {\r\noldval = bbt_get_entry(this, block);\r\nbbt_mark_entry(this, block, BBT_BLOCK_RESERVED);\r\nif (oldval != BBT_BLOCK_RESERVED)\r\nupdate = 1;\r\nblock++;\r\n}\r\nif (update && td->reserved_block_code)\r\nnand_update_bbt(mtd, (loff_t)(block - 1) <<\r\nthis->bbt_erase_shift);\r\n}\r\n}\r\nstatic void verify_bbt_descr(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nu32 pattern_len;\r\nu32 bits;\r\nu32 table_size;\r\nif (!bd)\r\nreturn;\r\npattern_len = bd->len;\r\nbits = bd->options & NAND_BBT_NRBITS_MSK;\r\nBUG_ON((this->bbt_options & NAND_BBT_NO_OOB) &&\r\n!(this->bbt_options & NAND_BBT_USE_FLASH));\r\nBUG_ON(!bits);\r\nif (bd->options & NAND_BBT_VERSION)\r\npattern_len++;\r\nif (bd->options & NAND_BBT_NO_OOB) {\r\nBUG_ON(!(this->bbt_options & NAND_BBT_USE_FLASH));\r\nBUG_ON(!(this->bbt_options & NAND_BBT_NO_OOB));\r\nBUG_ON(bd->offs);\r\nif (bd->options & NAND_BBT_VERSION)\r\nBUG_ON(bd->veroffs != bd->len);\r\nBUG_ON(bd->options & NAND_BBT_SAVECONTENT);\r\n}\r\nif (bd->options & NAND_BBT_PERCHIP)\r\ntable_size = this->chipsize >> this->bbt_erase_shift;\r\nelse\r\ntable_size = mtd->size >> this->bbt_erase_shift;\r\ntable_size >>= 3;\r\ntable_size *= bits;\r\nif (bd->options & NAND_BBT_NO_OOB)\r\ntable_size += pattern_len;\r\nBUG_ON(table_size > (1 << this->bbt_erase_shift));\r\n}\r\nstatic int nand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint len, res;\r\nuint8_t *buf;\r\nstruct nand_bbt_descr *td = this->bbt_td;\r\nstruct nand_bbt_descr *md = this->bbt_md;\r\nlen = (mtd->size >> (this->bbt_erase_shift + 2)) ? : 1;\r\nthis->bbt = kzalloc(len, GFP_KERNEL);\r\nif (!this->bbt)\r\nreturn -ENOMEM;\r\nif (!td) {\r\nif ((res = nand_memory_bbt(mtd, bd))) {\r\npr_err("nand_bbt: can't scan flash and build the RAM-based BBT\n");\r\ngoto err;\r\n}\r\nreturn 0;\r\n}\r\nverify_bbt_descr(mtd, td);\r\nverify_bbt_descr(mtd, md);\r\nlen = (1 << this->bbt_erase_shift);\r\nlen += (len >> this->page_shift) * mtd->oobsize;\r\nbuf = vmalloc(len);\r\nif (!buf) {\r\nres = -ENOMEM;\r\ngoto err;\r\n}\r\nif (td->options & NAND_BBT_ABSPAGE) {\r\nread_abs_bbts(mtd, buf, td, md);\r\n} else {\r\nsearch_read_bbts(mtd, buf, td, md);\r\n}\r\nres = check_create(mtd, buf, bd);\r\nif (res)\r\ngoto err;\r\nmark_bbt_region(mtd, td);\r\nif (md)\r\nmark_bbt_region(mtd, md);\r\nvfree(buf);\r\nreturn 0;\r\nerr:\r\nkfree(this->bbt);\r\nthis->bbt = NULL;\r\nreturn res;\r\n}\r\nstatic int nand_update_bbt(struct mtd_info *mtd, loff_t offs)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint len, res = 0;\r\nint chip, chipsel;\r\nuint8_t *buf;\r\nstruct nand_bbt_descr *td = this->bbt_td;\r\nstruct nand_bbt_descr *md = this->bbt_md;\r\nif (!this->bbt || !td)\r\nreturn -EINVAL;\r\nlen = (1 << this->bbt_erase_shift);\r\nlen += (len >> this->page_shift) * mtd->oobsize;\r\nbuf = kmalloc(len, GFP_KERNEL);\r\nif (!buf)\r\nreturn -ENOMEM;\r\nif (td->options & NAND_BBT_PERCHIP) {\r\nchip = (int)(offs >> this->chip_shift);\r\nchipsel = chip;\r\n} else {\r\nchip = 0;\r\nchipsel = -1;\r\n}\r\ntd->version[chip]++;\r\nif (md)\r\nmd->version[chip]++;\r\nif (td->options & NAND_BBT_WRITE) {\r\nres = write_bbt(mtd, buf, td, md, chipsel);\r\nif (res < 0)\r\ngoto out;\r\n}\r\nif (md && (md->options & NAND_BBT_WRITE)) {\r\nres = write_bbt(mtd, buf, md, td, chipsel);\r\n}\r\nout:\r\nkfree(buf);\r\nreturn res;\r\n}\r\nstatic int nand_create_badblock_pattern(struct nand_chip *this)\r\n{\r\nstruct nand_bbt_descr *bd;\r\nif (this->badblock_pattern) {\r\npr_warn("Bad block pattern already allocated; not replacing\n");\r\nreturn -EINVAL;\r\n}\r\nbd = kzalloc(sizeof(*bd), GFP_KERNEL);\r\nif (!bd)\r\nreturn -ENOMEM;\r\nbd->options = this->bbt_options & BADBLOCK_SCAN_MASK;\r\nbd->offs = this->badblockpos;\r\nbd->len = (this->options & NAND_BUSWIDTH_16) ? 2 : 1;\r\nbd->pattern = scan_ff_pattern;\r\nbd->options |= NAND_BBT_DYNAMICSTRUCT;\r\nthis->badblock_pattern = bd;\r\nreturn 0;\r\n}\r\nint nand_default_bbt(struct mtd_info *mtd)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint ret;\r\nif (this->bbt_options & NAND_BBT_USE_FLASH) {\r\nif (!this->bbt_td) {\r\nif (this->bbt_options & NAND_BBT_NO_OOB) {\r\nthis->bbt_td = &bbt_main_no_oob_descr;\r\nthis->bbt_md = &bbt_mirror_no_oob_descr;\r\n} else {\r\nthis->bbt_td = &bbt_main_descr;\r\nthis->bbt_md = &bbt_mirror_descr;\r\n}\r\n}\r\n} else {\r\nthis->bbt_td = NULL;\r\nthis->bbt_md = NULL;\r\n}\r\nif (!this->badblock_pattern) {\r\nret = nand_create_badblock_pattern(this);\r\nif (ret)\r\nreturn ret;\r\n}\r\nreturn nand_scan_bbt(mtd, this->badblock_pattern);\r\n}\r\nint nand_isreserved_bbt(struct mtd_info *mtd, loff_t offs)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint block;\r\nblock = (int)(offs >> this->bbt_erase_shift);\r\nreturn bbt_get_entry(this, block) == BBT_BLOCK_RESERVED;\r\n}\r\nint nand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint block, res;\r\nblock = (int)(offs >> this->bbt_erase_shift);\r\nres = bbt_get_entry(this, block);\r\npr_debug("nand_isbad_bbt(): bbt info for offs 0x%08x: (block %d) 0x%02x\n",\r\n(unsigned int)offs, block, res);\r\nswitch (res) {\r\ncase BBT_BLOCK_GOOD:\r\nreturn 0;\r\ncase BBT_BLOCK_WORN:\r\nreturn 1;\r\ncase BBT_BLOCK_RESERVED:\r\nreturn allowbbt ? 0 : 1;\r\n}\r\nreturn 1;\r\n}\r\nint nand_markbad_bbt(struct mtd_info *mtd, loff_t offs)\r\n{\r\nstruct nand_chip *this = mtd_to_nand(mtd);\r\nint block, ret = 0;\r\nblock = (int)(offs >> this->bbt_erase_shift);\r\nbbt_mark_entry(this, block, BBT_BLOCK_WORN);\r\nif (this->bbt_options & NAND_BBT_USE_FLASH)\r\nret = nand_update_bbt(mtd, offs);\r\nreturn ret;\r\n}
