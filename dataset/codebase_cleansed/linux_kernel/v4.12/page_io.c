static struct bio *get_swap_bio(gfp_t gfp_flags,\r\nstruct page *page, bio_end_io_t end_io)\r\n{\r\nstruct bio *bio;\r\nbio = bio_alloc(gfp_flags, 1);\r\nif (bio) {\r\nbio->bi_iter.bi_sector = map_swap_page(page, &bio->bi_bdev);\r\nbio->bi_iter.bi_sector <<= PAGE_SHIFT - 9;\r\nbio->bi_end_io = end_io;\r\nbio_add_page(bio, page, PAGE_SIZE, 0);\r\nBUG_ON(bio->bi_iter.bi_size != PAGE_SIZE);\r\n}\r\nreturn bio;\r\n}\r\nvoid end_swap_bio_write(struct bio *bio)\r\n{\r\nstruct page *page = bio->bi_io_vec[0].bv_page;\r\nif (bio->bi_error) {\r\nSetPageError(page);\r\nset_page_dirty(page);\r\npr_alert("Write-error on swap-device (%u:%u:%llu)\n",\r\nimajor(bio->bi_bdev->bd_inode),\r\niminor(bio->bi_bdev->bd_inode),\r\n(unsigned long long)bio->bi_iter.bi_sector);\r\nClearPageReclaim(page);\r\n}\r\nend_page_writeback(page);\r\nbio_put(bio);\r\n}\r\nstatic void swap_slot_free_notify(struct page *page)\r\n{\r\nstruct swap_info_struct *sis;\r\nstruct gendisk *disk;\r\nif (unlikely(!PageSwapCache(page)))\r\nreturn;\r\nsis = page_swap_info(page);\r\nif (!(sis->flags & SWP_BLKDEV))\r\nreturn;\r\ndisk = sis->bdev->bd_disk;\r\nif (disk->fops->swap_slot_free_notify) {\r\nswp_entry_t entry;\r\nunsigned long offset;\r\nentry.val = page_private(page);\r\noffset = swp_offset(entry);\r\nSetPageDirty(page);\r\ndisk->fops->swap_slot_free_notify(sis->bdev,\r\noffset);\r\n}\r\n}\r\nstatic void end_swap_bio_read(struct bio *bio)\r\n{\r\nstruct page *page = bio->bi_io_vec[0].bv_page;\r\nif (bio->bi_error) {\r\nSetPageError(page);\r\nClearPageUptodate(page);\r\npr_alert("Read-error on swap-device (%u:%u:%llu)\n",\r\nimajor(bio->bi_bdev->bd_inode),\r\niminor(bio->bi_bdev->bd_inode),\r\n(unsigned long long)bio->bi_iter.bi_sector);\r\ngoto out;\r\n}\r\nSetPageUptodate(page);\r\nswap_slot_free_notify(page);\r\nout:\r\nunlock_page(page);\r\nbio_put(bio);\r\n}\r\nint generic_swapfile_activate(struct swap_info_struct *sis,\r\nstruct file *swap_file,\r\nsector_t *span)\r\n{\r\nstruct address_space *mapping = swap_file->f_mapping;\r\nstruct inode *inode = mapping->host;\r\nunsigned blocks_per_page;\r\nunsigned long page_no;\r\nunsigned blkbits;\r\nsector_t probe_block;\r\nsector_t last_block;\r\nsector_t lowest_block = -1;\r\nsector_t highest_block = 0;\r\nint nr_extents = 0;\r\nint ret;\r\nblkbits = inode->i_blkbits;\r\nblocks_per_page = PAGE_SIZE >> blkbits;\r\nprobe_block = 0;\r\npage_no = 0;\r\nlast_block = i_size_read(inode) >> blkbits;\r\nwhile ((probe_block + blocks_per_page) <= last_block &&\r\npage_no < sis->max) {\r\nunsigned block_in_page;\r\nsector_t first_block;\r\ncond_resched();\r\nfirst_block = bmap(inode, probe_block);\r\nif (first_block == 0)\r\ngoto bad_bmap;\r\nif (first_block & (blocks_per_page - 1)) {\r\nprobe_block++;\r\ngoto reprobe;\r\n}\r\nfor (block_in_page = 1; block_in_page < blocks_per_page;\r\nblock_in_page++) {\r\nsector_t block;\r\nblock = bmap(inode, probe_block + block_in_page);\r\nif (block == 0)\r\ngoto bad_bmap;\r\nif (block != first_block + block_in_page) {\r\nprobe_block++;\r\ngoto reprobe;\r\n}\r\n}\r\nfirst_block >>= (PAGE_SHIFT - blkbits);\r\nif (page_no) {\r\nif (first_block < lowest_block)\r\nlowest_block = first_block;\r\nif (first_block > highest_block)\r\nhighest_block = first_block;\r\n}\r\nret = add_swap_extent(sis, page_no, 1, first_block);\r\nif (ret < 0)\r\ngoto out;\r\nnr_extents += ret;\r\npage_no++;\r\nprobe_block += blocks_per_page;\r\nreprobe:\r\ncontinue;\r\n}\r\nret = nr_extents;\r\n*span = 1 + highest_block - lowest_block;\r\nif (page_no == 0)\r\npage_no = 1;\r\nsis->max = page_no;\r\nsis->pages = page_no - 1;\r\nsis->highest_bit = page_no - 1;\r\nout:\r\nreturn ret;\r\nbad_bmap:\r\npr_err("swapon: swapfile has holes\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nint swap_writepage(struct page *page, struct writeback_control *wbc)\r\n{\r\nint ret = 0;\r\nif (try_to_free_swap(page)) {\r\nunlock_page(page);\r\ngoto out;\r\n}\r\nif (frontswap_store(page) == 0) {\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nend_page_writeback(page);\r\ngoto out;\r\n}\r\nret = __swap_writepage(page, wbc, end_swap_bio_write);\r\nout:\r\nreturn ret;\r\n}\r\nstatic sector_t swap_page_sector(struct page *page)\r\n{\r\nreturn (sector_t)__page_file_index(page) << (PAGE_SHIFT - 9);\r\n}\r\nint __swap_writepage(struct page *page, struct writeback_control *wbc,\r\nbio_end_io_t end_write_func)\r\n{\r\nstruct bio *bio;\r\nint ret;\r\nstruct swap_info_struct *sis = page_swap_info(page);\r\nVM_BUG_ON_PAGE(!PageSwapCache(page), page);\r\nif (sis->flags & SWP_FILE) {\r\nstruct kiocb kiocb;\r\nstruct file *swap_file = sis->swap_file;\r\nstruct address_space *mapping = swap_file->f_mapping;\r\nstruct bio_vec bv = {\r\n.bv_page = page,\r\n.bv_len = PAGE_SIZE,\r\n.bv_offset = 0\r\n};\r\nstruct iov_iter from;\r\niov_iter_bvec(&from, ITER_BVEC | WRITE, &bv, 1, PAGE_SIZE);\r\ninit_sync_kiocb(&kiocb, swap_file);\r\nkiocb.ki_pos = page_file_offset(page);\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nret = mapping->a_ops->direct_IO(&kiocb, &from);\r\nif (ret == PAGE_SIZE) {\r\ncount_vm_event(PSWPOUT);\r\nret = 0;\r\n} else {\r\nset_page_dirty(page);\r\nClearPageReclaim(page);\r\npr_err_ratelimited("Write error on dio swapfile (%llu)\n",\r\npage_file_offset(page));\r\n}\r\nend_page_writeback(page);\r\nreturn ret;\r\n}\r\nret = bdev_write_page(sis->bdev, swap_page_sector(page), page, wbc);\r\nif (!ret) {\r\ncount_vm_event(PSWPOUT);\r\nreturn 0;\r\n}\r\nret = 0;\r\nbio = get_swap_bio(GFP_NOIO, page, end_write_func);\r\nif (bio == NULL) {\r\nset_page_dirty(page);\r\nunlock_page(page);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbio->bi_opf = REQ_OP_WRITE | wbc_to_write_flags(wbc);\r\ncount_vm_event(PSWPOUT);\r\nset_page_writeback(page);\r\nunlock_page(page);\r\nsubmit_bio(bio);\r\nout:\r\nreturn ret;\r\n}\r\nint swap_readpage(struct page *page)\r\n{\r\nstruct bio *bio;\r\nint ret = 0;\r\nstruct swap_info_struct *sis = page_swap_info(page);\r\nVM_BUG_ON_PAGE(!PageSwapCache(page), page);\r\nVM_BUG_ON_PAGE(!PageLocked(page), page);\r\nVM_BUG_ON_PAGE(PageUptodate(page), page);\r\nif (frontswap_load(page) == 0) {\r\nSetPageUptodate(page);\r\nunlock_page(page);\r\ngoto out;\r\n}\r\nif (sis->flags & SWP_FILE) {\r\nstruct file *swap_file = sis->swap_file;\r\nstruct address_space *mapping = swap_file->f_mapping;\r\nret = mapping->a_ops->readpage(swap_file, page);\r\nif (!ret)\r\ncount_vm_event(PSWPIN);\r\nreturn ret;\r\n}\r\nret = bdev_read_page(sis->bdev, swap_page_sector(page), page);\r\nif (!ret) {\r\nif (trylock_page(page)) {\r\nswap_slot_free_notify(page);\r\nunlock_page(page);\r\n}\r\ncount_vm_event(PSWPIN);\r\nreturn 0;\r\n}\r\nret = 0;\r\nbio = get_swap_bio(GFP_KERNEL, page, end_swap_bio_read);\r\nif (bio == NULL) {\r\nunlock_page(page);\r\nret = -ENOMEM;\r\ngoto out;\r\n}\r\nbio_set_op_attrs(bio, REQ_OP_READ, 0);\r\ncount_vm_event(PSWPIN);\r\nsubmit_bio(bio);\r\nout:\r\nreturn ret;\r\n}\r\nint swap_set_page_dirty(struct page *page)\r\n{\r\nstruct swap_info_struct *sis = page_swap_info(page);\r\nif (sis->flags & SWP_FILE) {\r\nstruct address_space *mapping = sis->swap_file->f_mapping;\r\nVM_BUG_ON_PAGE(!PageSwapCache(page), page);\r\nreturn mapping->a_ops->set_page_dirty(page);\r\n} else {\r\nreturn __set_page_dirty_no_writeback(page);\r\n}\r\n}
