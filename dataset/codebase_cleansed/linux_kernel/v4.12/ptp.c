size_t efx_ptp_describe_stats(struct efx_nic *efx, u8 *strings)\r\n{\r\nif (!efx->ptp_data)\r\nreturn 0;\r\nreturn efx_nic_describe_stats(efx_ptp_stat_desc, PTP_STAT_COUNT,\r\nefx_ptp_stat_mask, strings);\r\n}\r\nsize_t efx_ptp_update_stats(struct efx_nic *efx, u64 *stats)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_STATUS_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_STATUS_LEN);\r\nsize_t i;\r\nint rc;\r\nif (!efx->ptp_data)\r\nreturn 0;\r\nfor (i = 0; i < PTP_STAT_COUNT; i++) {\r\nif (efx_ptp_stat_desc[i].dma_width)\r\ncontinue;\r\nstats[i] = *(unsigned int *)((char *)efx->ptp_data +\r\nefx_ptp_stat_desc[i].offset);\r\n}\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_STATUS);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc)\r\nmemset(outbuf, 0, sizeof(outbuf));\r\nefx_nic_update_stats(efx_ptp_stat_desc, PTP_STAT_COUNT,\r\nefx_ptp_stat_mask,\r\nstats, _MCDI_PTR(outbuf, 0), false);\r\nreturn PTP_STAT_COUNT;\r\n}\r\nstatic void efx_ptp_ns_to_s_ns(s64 ns, u32 *nic_major, u32 *nic_minor)\r\n{\r\nstruct timespec64 ts = ns_to_timespec64(ns);\r\n*nic_major = (u32)ts.tv_sec;\r\n*nic_minor = ts.tv_nsec;\r\n}\r\nstatic ktime_t efx_ptp_s_ns_to_ktime_correction(u32 nic_major, u32 nic_minor,\r\ns32 correction)\r\n{\r\nktime_t kt = ktime_set(nic_major, nic_minor);\r\nif (correction >= 0)\r\nkt = ktime_add_ns(kt, (u64)correction);\r\nelse\r\nkt = ktime_sub_ns(kt, (u64)-correction);\r\nreturn kt;\r\n}\r\nstatic void efx_ptp_ns_to_s27(s64 ns, u32 *nic_major, u32 *nic_minor)\r\n{\r\nstruct timespec64 ts = ns_to_timespec64(ns);\r\nu32 maj = (u32)ts.tv_sec;\r\nu32 min = (u32)(((u64)ts.tv_nsec * NS_TO_S27_MULT +\r\n(1ULL << (NS_TO_S27_SHIFT - 1))) >> NS_TO_S27_SHIFT);\r\nif (min >= S27_MINOR_MAX) {\r\nmin -= S27_MINOR_MAX;\r\nmaj++;\r\n}\r\n*nic_major = maj;\r\n*nic_minor = min;\r\n}\r\nstatic inline ktime_t efx_ptp_s27_to_ktime(u32 nic_major, u32 nic_minor)\r\n{\r\nu32 ns = (u32)(((u64)nic_minor * NSEC_PER_SEC +\r\n(1ULL << (S27_TO_NS_SHIFT - 1))) >> S27_TO_NS_SHIFT);\r\nreturn ktime_set(nic_major, ns);\r\n}\r\nstatic ktime_t efx_ptp_s27_to_ktime_correction(u32 nic_major, u32 nic_minor,\r\ns32 correction)\r\n{\r\nnic_minor += correction;\r\nif ((s32)nic_minor < 0) {\r\nnic_minor += S27_MINOR_MAX;\r\nnic_major--;\r\n} else if (nic_minor >= S27_MINOR_MAX) {\r\nnic_minor -= S27_MINOR_MAX;\r\nnic_major++;\r\n}\r\nreturn efx_ptp_s27_to_ktime(nic_major, nic_minor);\r\n}\r\nstatic int efx_ptp_get_attributes(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_GET_ATTRIBUTES_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_GET_ATTRIBUTES_LEN);\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nint rc;\r\nu32 fmt;\r\nsize_t out_len;\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_GET_ATTRIBUTES);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), &out_len);\r\nif (rc == 0) {\r\nfmt = MCDI_DWORD(outbuf, PTP_OUT_GET_ATTRIBUTES_TIME_FORMAT);\r\n} else if (rc == -EINVAL) {\r\nfmt = MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_NANOSECONDS;\r\n} else if (rc == -EPERM) {\r\nnetif_info(efx, probe, efx->net_dev, "no PTP support\n");\r\nreturn rc;\r\n} else {\r\nefx_mcdi_display_error(efx, MC_CMD_PTP, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), rc);\r\nreturn rc;\r\n}\r\nif (fmt == MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_27FRACTION) {\r\nptp->ns_to_nic_time = efx_ptp_ns_to_s27;\r\nptp->nic_to_kernel_time = efx_ptp_s27_to_ktime_correction;\r\n} else if (fmt == MC_CMD_PTP_OUT_GET_ATTRIBUTES_SECONDS_NANOSECONDS) {\r\nptp->ns_to_nic_time = efx_ptp_ns_to_s_ns;\r\nptp->nic_to_kernel_time = efx_ptp_s_ns_to_ktime_correction;\r\n} else {\r\nreturn -ERANGE;\r\n}\r\nptp->time_format = fmt;\r\nif (rc == 0 && out_len >= MC_CMD_PTP_OUT_GET_ATTRIBUTES_LEN)\r\nptp->min_synchronisation_ns =\r\nMCDI_DWORD(outbuf,\r\nPTP_OUT_GET_ATTRIBUTES_SYNC_WINDOW_MIN);\r\nelse\r\nptp->min_synchronisation_ns = DEFAULT_MIN_SYNCHRONISATION_NS;\r\nreturn 0;\r\n}\r\nstatic int efx_ptp_get_timestamp_corrections(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_GET_TIMESTAMP_CORRECTIONS_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_GET_TIMESTAMP_CORRECTIONS_LEN);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP,\r\nMC_CMD_PTP_OP_GET_TIMESTAMP_CORRECTIONS);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc == 0) {\r\nefx->ptp_data->ts_corrections.tx = MCDI_DWORD(outbuf,\r\nPTP_OUT_GET_TIMESTAMP_CORRECTIONS_TRANSMIT);\r\nefx->ptp_data->ts_corrections.rx = MCDI_DWORD(outbuf,\r\nPTP_OUT_GET_TIMESTAMP_CORRECTIONS_RECEIVE);\r\nefx->ptp_data->ts_corrections.pps_out = MCDI_DWORD(outbuf,\r\nPTP_OUT_GET_TIMESTAMP_CORRECTIONS_PPS_OUT);\r\nefx->ptp_data->ts_corrections.pps_in = MCDI_DWORD(outbuf,\r\nPTP_OUT_GET_TIMESTAMP_CORRECTIONS_PPS_IN);\r\n} else if (rc == -EINVAL) {\r\nefx->ptp_data->ts_corrections.tx = 0;\r\nefx->ptp_data->ts_corrections.rx = 0;\r\nefx->ptp_data->ts_corrections.pps_out = 0;\r\nefx->ptp_data->ts_corrections.pps_in = 0;\r\n} else {\r\nefx_mcdi_display_error(efx, MC_CMD_PTP, sizeof(inbuf), outbuf,\r\nsizeof(outbuf), rc);\r\nreturn rc;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_ptp_enable(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_ENABLE_LEN);\r\nMCDI_DECLARE_BUF_ERR(outbuf);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ENABLE);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_QUEUE,\r\nefx->ptp_data->channel ?\r\nefx->ptp_data->channel->channel : 0);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ENABLE_MODE, efx->ptp_data->mode);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nrc = (rc == -EALREADY) ? 0 : rc;\r\nif (rc)\r\nefx_mcdi_display_error(efx, MC_CMD_PTP,\r\nMC_CMD_PTP_IN_ENABLE_LEN,\r\noutbuf, sizeof(outbuf), rc);\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_disable(struct efx_nic *efx)\r\n{\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_DISABLE_LEN);\r\nMCDI_DECLARE_BUF_ERR(outbuf);\r\nint rc;\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_DISABLE);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nrc = efx_mcdi_rpc_quiet(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nrc = (rc == -EALREADY) ? 0 : rc;\r\nif (rc == -ENOSYS || rc == -EPERM)\r\nnetif_info(efx, probe, efx->net_dev, "no PTP support\n");\r\nelse if (rc)\r\nefx_mcdi_display_error(efx, MC_CMD_PTP,\r\nMC_CMD_PTP_IN_DISABLE_LEN,\r\noutbuf, sizeof(outbuf), rc);\r\nreturn rc;\r\n}\r\nstatic void efx_ptp_deliver_rx_queue(struct sk_buff_head *q)\r\n{\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(q))) {\r\nlocal_bh_disable();\r\nnetif_receive_skb(skb);\r\nlocal_bh_enable();\r\n}\r\n}\r\nstatic void efx_ptp_handle_no_channel(struct efx_nic *efx)\r\n{\r\nnetif_err(efx, drv, efx->net_dev,\r\n"ERROR: PTP requires MSI-X and 1 additional interrupt"\r\n"vector. PTP disabled\n");\r\n}\r\nstatic void efx_ptp_send_times(struct efx_nic *efx,\r\nstruct pps_event_time *last_time)\r\n{\r\nstruct pps_event_time now;\r\nstruct timespec64 limit;\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct timespec64 start;\r\nint *mc_running = ptp->start.addr;\r\npps_get_ts(&now);\r\nstart = now.ts_real;\r\nlimit = now.ts_real;\r\ntimespec64_add_ns(&limit, SYNCHRONISE_PERIOD_NS);\r\nwhile ((timespec64_compare(&now.ts_real, &limit) < 0) &&\r\nACCESS_ONCE(*mc_running)) {\r\nstruct timespec64 update_time;\r\nunsigned int host_time;\r\nupdate_time = now.ts_real;\r\ntimespec64_add_ns(&update_time, SYNCHRONISATION_GRANULARITY_NS);\r\ndo {\r\npps_get_ts(&now);\r\n} while ((timespec64_compare(&now.ts_real, &update_time) < 0) &&\r\nACCESS_ONCE(*mc_running));\r\nhost_time = (now.ts_real.tv_sec << MC_NANOSECOND_BITS |\r\nnow.ts_real.tv_nsec);\r\nefx->type->ptp_write_host_time(efx, host_time);\r\n}\r\n*last_time = now;\r\n}\r\nstatic int efx_ptp_synchronize(struct efx_nic *efx, unsigned int num_readings)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nMCDI_DECLARE_BUF(synch_buf, MC_CMD_PTP_OUT_SYNCHRONIZE_LENMAX);\r\nsize_t response_length;\r\nint rc;\r\nunsigned long timeout;\r\nstruct pps_event_time last_time = {};\r\nunsigned int loops = 0;\r\nint *start = ptp->start.addr;\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_OP, MC_CMD_PTP_OP_SYNCHRONIZE);\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_PERIPH_ID, 0);\r\nMCDI_SET_DWORD(synch_buf, PTP_IN_SYNCHRONIZE_NUMTIMESETS,\r\nnum_readings);\r\nMCDI_SET_QWORD(synch_buf, PTP_IN_SYNCHRONIZE_START_ADDR,\r\nptp->start.dma_addr);\r\nACCESS_ONCE(*start) = 0;\r\nrc = efx_mcdi_rpc_start(efx, MC_CMD_PTP, synch_buf,\r\nMC_CMD_PTP_IN_SYNCHRONIZE_LEN);\r\nEFX_WARN_ON_ONCE_PARANOID(rc);\r\ntimeout = jiffies + msecs_to_jiffies(MAX_SYNCHRONISE_WAIT_MS);\r\nwhile (!ACCESS_ONCE(*start) && (time_before(jiffies, timeout))) {\r\nudelay(20);\r\nloops++;\r\n}\r\nif (loops <= 1)\r\n++ptp->fast_syncs;\r\nif (!time_before(jiffies, timeout))\r\n++ptp->sync_timeouts;\r\nif (ACCESS_ONCE(*start))\r\nefx_ptp_send_times(efx, &last_time);\r\nrc = efx_mcdi_rpc_finish(efx, MC_CMD_PTP,\r\nMC_CMD_PTP_IN_SYNCHRONIZE_LEN,\r\nsynch_buf, sizeof(synch_buf),\r\n&response_length);\r\nif (rc == 0) {\r\nrc = efx_ptp_process_times(efx, synch_buf, response_length,\r\n&last_time);\r\nif (rc == 0)\r\n++ptp->good_syncs;\r\nelse\r\n++ptp->no_time_syncs;\r\n}\r\nif (rc != 0)\r\n++ptp->bad_syncs;\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_xmit_skb(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nstruct efx_ptp_data *ptp_data = efx->ptp_data;\r\nstruct skb_shared_hwtstamps timestamps;\r\nint rc = -EIO;\r\nMCDI_DECLARE_BUF(txtime, MC_CMD_PTP_OUT_TRANSMIT_LEN);\r\nsize_t len;\r\nMCDI_SET_DWORD(ptp_data->txbuf, PTP_IN_OP, MC_CMD_PTP_OP_TRANSMIT);\r\nMCDI_SET_DWORD(ptp_data->txbuf, PTP_IN_PERIPH_ID, 0);\r\nMCDI_SET_DWORD(ptp_data->txbuf, PTP_IN_TRANSMIT_LENGTH, skb->len);\r\nif (skb_shinfo(skb)->nr_frags != 0) {\r\nrc = skb_linearize(skb);\r\nif (rc != 0)\r\ngoto fail;\r\n}\r\nif (skb->ip_summed == CHECKSUM_PARTIAL) {\r\nrc = skb_checksum_help(skb);\r\nif (rc != 0)\r\ngoto fail;\r\n}\r\nskb_copy_from_linear_data(skb,\r\nMCDI_PTR(ptp_data->txbuf,\r\nPTP_IN_TRANSMIT_PACKET),\r\nskb->len);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP,\r\nptp_data->txbuf, MC_CMD_PTP_IN_TRANSMIT_LEN(skb->len),\r\ntxtime, sizeof(txtime), &len);\r\nif (rc != 0)\r\ngoto fail;\r\nmemset(&timestamps, 0, sizeof(timestamps));\r\ntimestamps.hwtstamp = ptp_data->nic_to_kernel_time(\r\nMCDI_DWORD(txtime, PTP_OUT_TRANSMIT_MAJOR),\r\nMCDI_DWORD(txtime, PTP_OUT_TRANSMIT_MINOR),\r\nptp_data->ts_corrections.tx);\r\nskb_tstamp_tx(skb, &timestamps);\r\nrc = 0;\r\nfail:\r\ndev_kfree_skb(skb);\r\nreturn rc;\r\n}\r\nstatic void efx_ptp_drop_time_expired_events(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct list_head *cursor;\r\nstruct list_head *next;\r\nif (ptp->rx_ts_inline)\r\nreturn;\r\nspin_lock_bh(&ptp->evt_lock);\r\nif (!list_empty(&ptp->evt_list)) {\r\nlist_for_each_safe(cursor, next, &ptp->evt_list) {\r\nstruct efx_ptp_event_rx *evt;\r\nevt = list_entry(cursor, struct efx_ptp_event_rx,\r\nlink);\r\nif (time_after(jiffies, evt->expiry)) {\r\nlist_move(&evt->link, &ptp->evt_free_list);\r\nnetif_warn(efx, hw, efx->net_dev,\r\n"PTP rx event dropped\n");\r\n}\r\n}\r\n}\r\nspin_unlock_bh(&ptp->evt_lock);\r\n}\r\nstatic enum ptp_packet_state efx_ptp_match_rx(struct efx_nic *efx,\r\nstruct sk_buff *skb)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nbool evts_waiting;\r\nstruct list_head *cursor;\r\nstruct list_head *next;\r\nstruct efx_ptp_match *match;\r\nenum ptp_packet_state rc = PTP_PACKET_STATE_UNMATCHED;\r\nWARN_ON_ONCE(ptp->rx_ts_inline);\r\nspin_lock_bh(&ptp->evt_lock);\r\nevts_waiting = !list_empty(&ptp->evt_list);\r\nspin_unlock_bh(&ptp->evt_lock);\r\nif (!evts_waiting)\r\nreturn PTP_PACKET_STATE_UNMATCHED;\r\nmatch = (struct efx_ptp_match *)skb->cb;\r\nspin_lock_bh(&ptp->evt_lock);\r\nlist_for_each_safe(cursor, next, &ptp->evt_list) {\r\nstruct efx_ptp_event_rx *evt;\r\nevt = list_entry(cursor, struct efx_ptp_event_rx, link);\r\nif ((evt->seq0 == match->words[0]) &&\r\n(evt->seq1 == match->words[1])) {\r\nstruct skb_shared_hwtstamps *timestamps;\r\ntimestamps = skb_hwtstamps(skb);\r\ntimestamps->hwtstamp = evt->hwtimestamp;\r\nmatch->state = PTP_PACKET_STATE_MATCHED;\r\nrc = PTP_PACKET_STATE_MATCHED;\r\nlist_move(&evt->link, &ptp->evt_free_list);\r\nbreak;\r\n}\r\n}\r\nspin_unlock_bh(&ptp->evt_lock);\r\nreturn rc;\r\n}\r\nstatic void efx_ptp_process_events(struct efx_nic *efx, struct sk_buff_head *q)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct sk_buff *skb;\r\nwhile ((skb = skb_dequeue(&ptp->rxq))) {\r\nstruct efx_ptp_match *match;\r\nmatch = (struct efx_ptp_match *)skb->cb;\r\nif (match->state == PTP_PACKET_STATE_MATCH_UNWANTED) {\r\n__skb_queue_tail(q, skb);\r\n} else if (efx_ptp_match_rx(efx, skb) ==\r\nPTP_PACKET_STATE_MATCHED) {\r\n__skb_queue_tail(q, skb);\r\n} else if (time_after(jiffies, match->expiry)) {\r\nmatch->state = PTP_PACKET_STATE_TIMED_OUT;\r\n++ptp->rx_no_timestamp;\r\n__skb_queue_tail(q, skb);\r\n} else {\r\nskb_queue_head(&ptp->rxq, skb);\r\nbreak;\r\n}\r\n}\r\n}\r\nstatic inline void efx_ptp_process_rx(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nlocal_bh_disable();\r\nnetif_receive_skb(skb);\r\nlocal_bh_enable();\r\n}\r\nstatic void efx_ptp_remove_multicast_filters(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nif (ptp->rxfilter_installed) {\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_general);\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_event);\r\nptp->rxfilter_installed = false;\r\n}\r\n}\r\nstatic int efx_ptp_insert_multicast_filters(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct efx_filter_spec rxfilter;\r\nint rc;\r\nif (!ptp->channel || ptp->rxfilter_installed)\r\nreturn 0;\r\nefx_filter_init_rx(&rxfilter, EFX_FILTER_PRI_REQUIRED, 0,\r\nefx_rx_queue_index(\r\nefx_channel_get_rx_queue(ptp->channel)));\r\nrc = efx_filter_set_ipv4_local(&rxfilter, IPPROTO_UDP,\r\nhtonl(PTP_ADDRESS),\r\nhtons(PTP_EVENT_PORT));\r\nif (rc != 0)\r\nreturn rc;\r\nrc = efx_filter_insert_filter(efx, &rxfilter, true);\r\nif (rc < 0)\r\nreturn rc;\r\nptp->rxfilter_event = rc;\r\nefx_filter_init_rx(&rxfilter, EFX_FILTER_PRI_REQUIRED, 0,\r\nefx_rx_queue_index(\r\nefx_channel_get_rx_queue(ptp->channel)));\r\nrc = efx_filter_set_ipv4_local(&rxfilter, IPPROTO_UDP,\r\nhtonl(PTP_ADDRESS),\r\nhtons(PTP_GENERAL_PORT));\r\nif (rc != 0)\r\ngoto fail;\r\nrc = efx_filter_insert_filter(efx, &rxfilter, true);\r\nif (rc < 0)\r\ngoto fail;\r\nptp->rxfilter_general = rc;\r\nptp->rxfilter_installed = true;\r\nreturn 0;\r\nfail:\r\nefx_filter_remove_id_safe(efx, EFX_FILTER_PRI_REQUIRED,\r\nptp->rxfilter_event);\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_start(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nint rc;\r\nptp->reset_required = false;\r\nrc = efx_ptp_insert_multicast_filters(efx);\r\nif (rc)\r\nreturn rc;\r\nrc = efx_ptp_enable(efx);\r\nif (rc != 0)\r\ngoto fail;\r\nptp->evt_frag_idx = 0;\r\nptp->current_adjfreq = 0;\r\nreturn 0;\r\nfail:\r\nefx_ptp_remove_multicast_filters(efx);\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_stop(struct efx_nic *efx)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct list_head *cursor;\r\nstruct list_head *next;\r\nint rc;\r\nif (ptp == NULL)\r\nreturn 0;\r\nrc = efx_ptp_disable(efx);\r\nefx_ptp_remove_multicast_filters(efx);\r\nefx_ptp_deliver_rx_queue(&efx->ptp_data->rxq);\r\nskb_queue_purge(&efx->ptp_data->txq);\r\nspin_lock_bh(&efx->ptp_data->evt_lock);\r\nlist_for_each_safe(cursor, next, &efx->ptp_data->evt_list) {\r\nlist_move(cursor, &efx->ptp_data->evt_free_list);\r\n}\r\nspin_unlock_bh(&efx->ptp_data->evt_lock);\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_restart(struct efx_nic *efx)\r\n{\r\nif (efx->ptp_data && efx->ptp_data->enabled)\r\nreturn efx_ptp_start(efx);\r\nreturn 0;\r\n}\r\nstatic void efx_ptp_pps_worker(struct work_struct *work)\r\n{\r\nstruct efx_ptp_data *ptp =\r\ncontainer_of(work, struct efx_ptp_data, pps_work);\r\nstruct efx_nic *efx = ptp->efx;\r\nstruct ptp_clock_event ptp_evt;\r\nif (efx_ptp_synchronize(efx, PTP_SYNC_ATTEMPTS))\r\nreturn;\r\nptp_evt.type = PTP_CLOCK_PPSUSR;\r\nptp_evt.pps_times = ptp->host_time_pps;\r\nptp_clock_event(ptp->phc_clock, &ptp_evt);\r\n}\r\nstatic void efx_ptp_worker(struct work_struct *work)\r\n{\r\nstruct efx_ptp_data *ptp_data =\r\ncontainer_of(work, struct efx_ptp_data, work);\r\nstruct efx_nic *efx = ptp_data->efx;\r\nstruct sk_buff *skb;\r\nstruct sk_buff_head tempq;\r\nif (ptp_data->reset_required) {\r\nefx_ptp_stop(efx);\r\nefx_ptp_start(efx);\r\nreturn;\r\n}\r\nefx_ptp_drop_time_expired_events(efx);\r\n__skb_queue_head_init(&tempq);\r\nefx_ptp_process_events(efx, &tempq);\r\nwhile ((skb = skb_dequeue(&ptp_data->txq)))\r\nefx_ptp_xmit_skb(efx, skb);\r\nwhile ((skb = __skb_dequeue(&tempq)))\r\nefx_ptp_process_rx(efx, skb);\r\n}\r\nint efx_ptp_probe(struct efx_nic *efx, struct efx_channel *channel)\r\n{\r\nstruct efx_ptp_data *ptp;\r\nint rc = 0;\r\nunsigned int pos;\r\nptp = kzalloc(sizeof(struct efx_ptp_data), GFP_KERNEL);\r\nefx->ptp_data = ptp;\r\nif (!efx->ptp_data)\r\nreturn -ENOMEM;\r\nptp->efx = efx;\r\nptp->channel = channel;\r\nptp->rx_ts_inline = efx_nic_rev(efx) >= EFX_REV_HUNT_A0;\r\nrc = efx_nic_alloc_buffer(efx, &ptp->start, sizeof(int), GFP_KERNEL);\r\nif (rc != 0)\r\ngoto fail1;\r\nskb_queue_head_init(&ptp->rxq);\r\nskb_queue_head_init(&ptp->txq);\r\nptp->workwq = create_singlethread_workqueue("sfc_ptp");\r\nif (!ptp->workwq) {\r\nrc = -ENOMEM;\r\ngoto fail2;\r\n}\r\nINIT_WORK(&ptp->work, efx_ptp_worker);\r\nptp->config.flags = 0;\r\nptp->config.tx_type = HWTSTAMP_TX_OFF;\r\nptp->config.rx_filter = HWTSTAMP_FILTER_NONE;\r\nINIT_LIST_HEAD(&ptp->evt_list);\r\nINIT_LIST_HEAD(&ptp->evt_free_list);\r\nspin_lock_init(&ptp->evt_lock);\r\nfor (pos = 0; pos < MAX_RECEIVE_EVENTS; pos++)\r\nlist_add(&ptp->rx_evts[pos].link, &ptp->evt_free_list);\r\nrc = efx_ptp_get_attributes(efx);\r\nif (rc < 0)\r\ngoto fail3;\r\nrc = efx_ptp_get_timestamp_corrections(efx);\r\nif (rc < 0)\r\ngoto fail3;\r\nif (efx->mcdi->fn_flags &\r\n(1 << MC_CMD_DRV_ATTACH_EXT_OUT_FLAG_PRIMARY)) {\r\nptp->phc_clock_info = efx_phc_clock_info;\r\nptp->phc_clock = ptp_clock_register(&ptp->phc_clock_info,\r\n&efx->pci_dev->dev);\r\nif (IS_ERR(ptp->phc_clock)) {\r\nrc = PTR_ERR(ptp->phc_clock);\r\ngoto fail3;\r\n} else if (ptp->phc_clock) {\r\nINIT_WORK(&ptp->pps_work, efx_ptp_pps_worker);\r\nptp->pps_workwq = create_singlethread_workqueue("sfc_pps");\r\nif (!ptp->pps_workwq) {\r\nrc = -ENOMEM;\r\ngoto fail4;\r\n}\r\n}\r\n}\r\nptp->nic_ts_enabled = false;\r\nreturn 0;\r\nfail4:\r\nptp_clock_unregister(efx->ptp_data->phc_clock);\r\nfail3:\r\ndestroy_workqueue(efx->ptp_data->workwq);\r\nfail2:\r\nefx_nic_free_buffer(efx, &ptp->start);\r\nfail1:\r\nkfree(efx->ptp_data);\r\nefx->ptp_data = NULL;\r\nreturn rc;\r\n}\r\nstatic int efx_ptp_probe_channel(struct efx_channel *channel)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nchannel->irq_moderation_us = 0;\r\nchannel->rx_queue.core_index = 0;\r\nreturn efx_ptp_probe(efx, channel);\r\n}\r\nvoid efx_ptp_remove(struct efx_nic *efx)\r\n{\r\nif (!efx->ptp_data)\r\nreturn;\r\n(void)efx_ptp_disable(efx);\r\ncancel_work_sync(&efx->ptp_data->work);\r\ncancel_work_sync(&efx->ptp_data->pps_work);\r\nskb_queue_purge(&efx->ptp_data->rxq);\r\nskb_queue_purge(&efx->ptp_data->txq);\r\nif (efx->ptp_data->phc_clock) {\r\ndestroy_workqueue(efx->ptp_data->pps_workwq);\r\nptp_clock_unregister(efx->ptp_data->phc_clock);\r\n}\r\ndestroy_workqueue(efx->ptp_data->workwq);\r\nefx_nic_free_buffer(efx, &efx->ptp_data->start);\r\nkfree(efx->ptp_data);\r\n}\r\nstatic void efx_ptp_remove_channel(struct efx_channel *channel)\r\n{\r\nefx_ptp_remove(channel->efx);\r\n}\r\nstatic void efx_ptp_get_channel_name(struct efx_channel *channel,\r\nchar *buf, size_t len)\r\n{\r\nsnprintf(buf, len, "%s-ptp", channel->efx->name);\r\n}\r\nbool efx_ptp_is_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nreturn efx->ptp_data &&\r\nefx->ptp_data->enabled &&\r\nskb->len >= PTP_MIN_LENGTH &&\r\nskb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM &&\r\nlikely(skb->protocol == htons(ETH_P_IP)) &&\r\nskb_transport_header_was_set(skb) &&\r\nskb_network_header_len(skb) >= sizeof(struct iphdr) &&\r\nip_hdr(skb)->protocol == IPPROTO_UDP &&\r\nskb_headlen(skb) >=\r\nskb_transport_offset(skb) + sizeof(struct udphdr) &&\r\nudp_hdr(skb)->dest == htons(PTP_EVENT_PORT);\r\n}\r\nstatic bool efx_ptp_rx(struct efx_channel *channel, struct sk_buff *skb)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct efx_ptp_match *match = (struct efx_ptp_match *)skb->cb;\r\nu8 *match_data_012, *match_data_345;\r\nunsigned int version;\r\nu8 *data;\r\nmatch->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);\r\nif (ptp->mode == MC_CMD_PTP_MODE_V1) {\r\nif (!pskb_may_pull(skb, PTP_V1_MIN_LENGTH)) {\r\nreturn false;\r\n}\r\ndata = skb->data;\r\nversion = ntohs(*(__be16 *)&data[PTP_V1_VERSION_OFFSET]);\r\nif (version != PTP_VERSION_V1) {\r\nreturn false;\r\n}\r\nmatch_data_012 = data + PTP_V1_UUID_OFFSET;\r\nmatch_data_345 = data + PTP_V1_UUID_OFFSET + 3;\r\n} else {\r\nif (!pskb_may_pull(skb, PTP_V2_MIN_LENGTH)) {\r\nreturn false;\r\n}\r\ndata = skb->data;\r\nversion = data[PTP_V2_VERSION_OFFSET];\r\nif ((version & PTP_VERSION_V2_MASK) != PTP_VERSION_V2) {\r\nreturn false;\r\n}\r\nmatch_data_345 = data + PTP_V2_UUID_OFFSET + 5;\r\nif (ptp->mode == MC_CMD_PTP_MODE_V2) {\r\nmatch_data_012 = data + PTP_V2_UUID_OFFSET + 2;\r\n} else {\r\nmatch_data_012 = data + PTP_V2_UUID_OFFSET + 0;\r\nBUG_ON(ptp->mode != MC_CMD_PTP_MODE_V2_ENHANCED);\r\n}\r\n}\r\nif (ntohs(*(__be16 *)&data[PTP_DPORT_OFFSET]) == PTP_EVENT_PORT) {\r\nmatch->state = PTP_PACKET_STATE_UNMATCHED;\r\nBUILD_BUG_ON(PTP_V1_SEQUENCE_OFFSET != PTP_V2_SEQUENCE_OFFSET);\r\nBUILD_BUG_ON(PTP_V1_SEQUENCE_LENGTH != PTP_V2_SEQUENCE_LENGTH);\r\nmatch->words[0] = (match_data_012[0] |\r\n(match_data_012[1] << 8) |\r\n(match_data_012[2] << 16) |\r\n(match_data_345[0] << 24));\r\nmatch->words[1] = (match_data_345[1] |\r\n(match_data_345[2] << 8) |\r\n(data[PTP_V1_SEQUENCE_OFFSET +\r\nPTP_V1_SEQUENCE_LENGTH - 1] <<\r\n16));\r\n} else {\r\nmatch->state = PTP_PACKET_STATE_MATCH_UNWANTED;\r\n}\r\nskb_queue_tail(&ptp->rxq, skb);\r\nqueue_work(ptp->workwq, &ptp->work);\r\nreturn true;\r\n}\r\nint efx_ptp_tx(struct efx_nic *efx, struct sk_buff *skb)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nskb_queue_tail(&ptp->txq, skb);\r\nif ((udp_hdr(skb)->dest == htons(PTP_EVENT_PORT)) &&\r\n(skb->len <= MC_CMD_PTP_IN_TRANSMIT_PACKET_MAXNUM))\r\nefx_xmit_hwtstamp_pending(skb);\r\nqueue_work(ptp->workwq, &ptp->work);\r\nreturn NETDEV_TX_OK;\r\n}\r\nint efx_ptp_get_mode(struct efx_nic *efx)\r\n{\r\nreturn efx->ptp_data->mode;\r\n}\r\nint efx_ptp_change_mode(struct efx_nic *efx, bool enable_wanted,\r\nunsigned int new_mode)\r\n{\r\nif ((enable_wanted != efx->ptp_data->enabled) ||\r\n(enable_wanted && (efx->ptp_data->mode != new_mode))) {\r\nint rc = 0;\r\nif (enable_wanted) {\r\nif (efx->ptp_data->enabled &&\r\n(efx->ptp_data->mode != new_mode)) {\r\nefx->ptp_data->enabled = false;\r\nrc = efx_ptp_stop(efx);\r\nif (rc != 0)\r\nreturn rc;\r\n}\r\nefx->ptp_data->mode = new_mode;\r\nif (netif_running(efx->net_dev))\r\nrc = efx_ptp_start(efx);\r\nif (rc == 0) {\r\nrc = efx_ptp_synchronize(efx,\r\nPTP_SYNC_ATTEMPTS * 2);\r\nif (rc != 0)\r\nefx_ptp_stop(efx);\r\n}\r\n} else {\r\nrc = efx_ptp_stop(efx);\r\n}\r\nif (rc != 0)\r\nreturn rc;\r\nefx->ptp_data->enabled = enable_wanted;\r\n}\r\nreturn 0;\r\n}\r\nstatic int efx_ptp_ts_init(struct efx_nic *efx, struct hwtstamp_config *init)\r\n{\r\nint rc;\r\nif (init->flags)\r\nreturn -EINVAL;\r\nif ((init->tx_type != HWTSTAMP_TX_OFF) &&\r\n(init->tx_type != HWTSTAMP_TX_ON))\r\nreturn -ERANGE;\r\nrc = efx->type->ptp_set_ts_config(efx, init);\r\nif (rc)\r\nreturn rc;\r\nefx->ptp_data->config = *init;\r\nreturn 0;\r\n}\r\nvoid efx_ptp_get_ts_info(struct efx_nic *efx, struct ethtool_ts_info *ts_info)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nstruct efx_nic *primary = efx->primary;\r\nASSERT_RTNL();\r\nif (!ptp)\r\nreturn;\r\nts_info->so_timestamping |= (SOF_TIMESTAMPING_TX_HARDWARE |\r\nSOF_TIMESTAMPING_RX_HARDWARE |\r\nSOF_TIMESTAMPING_RAW_HARDWARE);\r\nif (primary && primary->ptp_data && primary->ptp_data->phc_clock)\r\nts_info->phc_index =\r\nptp_clock_index(primary->ptp_data->phc_clock);\r\nts_info->tx_types = 1 << HWTSTAMP_TX_OFF | 1 << HWTSTAMP_TX_ON;\r\nts_info->rx_filters = ptp->efx->type->hwtstamp_filters;\r\n}\r\nint efx_ptp_set_ts_config(struct efx_nic *efx, struct ifreq *ifr)\r\n{\r\nstruct hwtstamp_config config;\r\nint rc;\r\nif (!efx->ptp_data)\r\nreturn -EOPNOTSUPP;\r\nif (copy_from_user(&config, ifr->ifr_data, sizeof(config)))\r\nreturn -EFAULT;\r\nrc = efx_ptp_ts_init(efx, &config);\r\nif (rc != 0)\r\nreturn rc;\r\nreturn copy_to_user(ifr->ifr_data, &config, sizeof(config))\r\n? -EFAULT : 0;\r\n}\r\nint efx_ptp_get_ts_config(struct efx_nic *efx, struct ifreq *ifr)\r\n{\r\nif (!efx->ptp_data)\r\nreturn -EOPNOTSUPP;\r\nreturn copy_to_user(ifr->ifr_data, &efx->ptp_data->config,\r\nsizeof(efx->ptp_data->config)) ? -EFAULT : 0;\r\n}\r\nstatic void ptp_event_failure(struct efx_nic *efx, int expected_frag_len)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP unexpected event length: got %d expected %d\n",\r\nptp->evt_frag_idx, expected_frag_len);\r\nptp->reset_required = true;\r\nqueue_work(ptp->workwq, &ptp->work);\r\n}\r\nstatic void ptp_event_rx(struct efx_nic *efx, struct efx_ptp_data *ptp)\r\n{\r\nstruct efx_ptp_event_rx *evt = NULL;\r\nif (WARN_ON_ONCE(ptp->rx_ts_inline))\r\nreturn;\r\nif (ptp->evt_frag_idx != 3) {\r\nptp_event_failure(efx, 3);\r\nreturn;\r\n}\r\nspin_lock_bh(&ptp->evt_lock);\r\nif (!list_empty(&ptp->evt_free_list)) {\r\nevt = list_first_entry(&ptp->evt_free_list,\r\nstruct efx_ptp_event_rx, link);\r\nlist_del(&evt->link);\r\nevt->seq0 = EFX_QWORD_FIELD(ptp->evt_frags[2], MCDI_EVENT_DATA);\r\nevt->seq1 = (EFX_QWORD_FIELD(ptp->evt_frags[2],\r\nMCDI_EVENT_SRC) |\r\n(EFX_QWORD_FIELD(ptp->evt_frags[1],\r\nMCDI_EVENT_SRC) << 8) |\r\n(EFX_QWORD_FIELD(ptp->evt_frags[0],\r\nMCDI_EVENT_SRC) << 16));\r\nevt->hwtimestamp = efx->ptp_data->nic_to_kernel_time(\r\nEFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA),\r\nEFX_QWORD_FIELD(ptp->evt_frags[1], MCDI_EVENT_DATA),\r\nptp->ts_corrections.rx);\r\nevt->expiry = jiffies + msecs_to_jiffies(PKT_EVENT_LIFETIME_MS);\r\nlist_add_tail(&evt->link, &ptp->evt_list);\r\nqueue_work(ptp->workwq, &ptp->work);\r\n} else if (net_ratelimit()) {\r\nnetif_err(efx, rx_err, efx->net_dev, "PTP event queue overflow\n");\r\n}\r\nspin_unlock_bh(&ptp->evt_lock);\r\n}\r\nstatic void ptp_event_fault(struct efx_nic *efx, struct efx_ptp_data *ptp)\r\n{\r\nint code = EFX_QWORD_FIELD(ptp->evt_frags[0], MCDI_EVENT_DATA);\r\nif (ptp->evt_frag_idx != 1) {\r\nptp_event_failure(efx, 1);\r\nreturn;\r\n}\r\nnetif_err(efx, hw, efx->net_dev, "PTP error %d\n", code);\r\n}\r\nstatic void ptp_event_pps(struct efx_nic *efx, struct efx_ptp_data *ptp)\r\n{\r\nif (ptp->nic_ts_enabled)\r\nqueue_work(ptp->pps_workwq, &ptp->pps_work);\r\n}\r\nvoid efx_ptp_event(struct efx_nic *efx, efx_qword_t *ev)\r\n{\r\nstruct efx_ptp_data *ptp = efx->ptp_data;\r\nint code = EFX_QWORD_FIELD(*ev, MCDI_EVENT_CODE);\r\nif (!ptp) {\r\nif (net_ratelimit())\r\nnetif_warn(efx, drv, efx->net_dev,\r\n"Received PTP event but PTP not set up\n");\r\nreturn;\r\n}\r\nif (!ptp->enabled)\r\nreturn;\r\nif (ptp->evt_frag_idx == 0) {\r\nptp->evt_code = code;\r\n} else if (ptp->evt_code != code) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP out of sequence event %d\n", code);\r\nptp->evt_frag_idx = 0;\r\n}\r\nptp->evt_frags[ptp->evt_frag_idx++] = *ev;\r\nif (!MCDI_EVENT_FIELD(*ev, CONT)) {\r\nswitch (code) {\r\ncase MCDI_EVENT_CODE_PTP_RX:\r\nptp_event_rx(efx, ptp);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PTP_FAULT:\r\nptp_event_fault(efx, ptp);\r\nbreak;\r\ncase MCDI_EVENT_CODE_PTP_PPS:\r\nptp_event_pps(efx, ptp);\r\nbreak;\r\ndefault:\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP unknown event %d\n", code);\r\nbreak;\r\n}\r\nptp->evt_frag_idx = 0;\r\n} else if (MAX_EVENT_FRAGS == ptp->evt_frag_idx) {\r\nnetif_err(efx, hw, efx->net_dev,\r\n"PTP too many event fragments\n");\r\nptp->evt_frag_idx = 0;\r\n}\r\n}\r\nvoid efx_time_sync_event(struct efx_channel *channel, efx_qword_t *ev)\r\n{\r\nchannel->sync_timestamp_major = MCDI_EVENT_FIELD(*ev, PTP_TIME_MAJOR);\r\nchannel->sync_timestamp_minor =\r\nMCDI_EVENT_FIELD(*ev, PTP_TIME_MINOR_26_19) << 19;\r\n(void) cmpxchg(&channel->sync_events_state, SYNC_EVENTS_REQUESTED,\r\nSYNC_EVENTS_VALID);\r\n}\r\nstatic inline u32 efx_rx_buf_timestamp_minor(struct efx_nic *efx, const u8 *eh)\r\n{\r\n#if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)\r\nreturn __le32_to_cpup((const __le32 *)(eh + efx->rx_packet_ts_offset));\r\n#else\r\nconst u8 *data = eh + efx->rx_packet_ts_offset;\r\nreturn (u32)data[0] |\r\n(u32)data[1] << 8 |\r\n(u32)data[2] << 16 |\r\n(u32)data[3] << 24;\r\n#endif\r\n}\r\nvoid __efx_rx_skb_attach_timestamp(struct efx_channel *channel,\r\nstruct sk_buff *skb)\r\n{\r\nstruct efx_nic *efx = channel->efx;\r\nu32 pkt_timestamp_major, pkt_timestamp_minor;\r\nu32 diff, carry;\r\nstruct skb_shared_hwtstamps *timestamps;\r\npkt_timestamp_minor = (efx_rx_buf_timestamp_minor(efx,\r\nskb_mac_header(skb)) +\r\n(u32) efx->ptp_data->ts_corrections.rx) &\r\n(MINOR_TICKS_PER_SECOND - 1);\r\ndiff = (pkt_timestamp_minor - channel->sync_timestamp_minor) &\r\n(MINOR_TICKS_PER_SECOND - 1);\r\ncarry = channel->sync_timestamp_minor + diff > MINOR_TICKS_PER_SECOND ?\r\n1 : 0;\r\nif (diff <= MINOR_TICKS_PER_SECOND / EXPECTED_SYNC_EVENTS_PER_SECOND +\r\nFUZZ) {\r\npkt_timestamp_major = channel->sync_timestamp_major + carry;\r\n} else if (diff >= MINOR_TICKS_PER_SECOND - FUZZ) {\r\npkt_timestamp_major = channel->sync_timestamp_major - 1 + carry;\r\n} else {\r\nnetif_vdbg(efx, drv, efx->net_dev,\r\n"packet timestamp %x too far from sync event %x:%x\n",\r\npkt_timestamp_minor, channel->sync_timestamp_major,\r\nchannel->sync_timestamp_minor);\r\nreturn;\r\n}\r\ntimestamps = skb_hwtstamps(skb);\r\ntimestamps->hwtstamp =\r\nefx_ptp_s27_to_ktime(pkt_timestamp_major, pkt_timestamp_minor);\r\n}\r\nstatic int efx_phc_adjfreq(struct ptp_clock_info *ptp, s32 delta)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nstruct efx_nic *efx = ptp_data->efx;\r\nMCDI_DECLARE_BUF(inadj, MC_CMD_PTP_IN_ADJUST_LEN);\r\ns64 adjustment_ns;\r\nint rc;\r\nif (delta > MAX_PPB)\r\ndelta = MAX_PPB;\r\nelse if (delta < -MAX_PPB)\r\ndelta = -MAX_PPB;\r\nadjustment_ns = (((s64)delta * PPB_SCALE_WORD) >>\r\n(PPB_EXTRA_BITS + MAX_PPB_BITS));\r\nMCDI_SET_DWORD(inadj, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);\r\nMCDI_SET_DWORD(inadj, PTP_IN_PERIPH_ID, 0);\r\nMCDI_SET_QWORD(inadj, PTP_IN_ADJUST_FREQ, adjustment_ns);\r\nMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_SECONDS, 0);\r\nMCDI_SET_DWORD(inadj, PTP_IN_ADJUST_NANOSECONDS, 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP, inadj, sizeof(inadj),\r\nNULL, 0, NULL);\r\nif (rc != 0)\r\nreturn rc;\r\nptp_data->current_adjfreq = adjustment_ns;\r\nreturn 0;\r\n}\r\nstatic int efx_phc_adjtime(struct ptp_clock_info *ptp, s64 delta)\r\n{\r\nu32 nic_major, nic_minor;\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nstruct efx_nic *efx = ptp_data->efx;\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_ADJUST_LEN);\r\nefx->ptp_data->ns_to_nic_time(delta, &nic_major, &nic_minor);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_ADJUST);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nMCDI_SET_QWORD(inbuf, PTP_IN_ADJUST_FREQ, ptp_data->current_adjfreq);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_MAJOR, nic_major);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_ADJUST_MINOR, nic_minor);\r\nreturn efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\nNULL, 0, NULL);\r\n}\r\nstatic int efx_phc_gettime(struct ptp_clock_info *ptp, struct timespec64 *ts)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nstruct efx_nic *efx = ptp_data->efx;\r\nMCDI_DECLARE_BUF(inbuf, MC_CMD_PTP_IN_READ_NIC_TIME_LEN);\r\nMCDI_DECLARE_BUF(outbuf, MC_CMD_PTP_OUT_READ_NIC_TIME_LEN);\r\nint rc;\r\nktime_t kt;\r\nMCDI_SET_DWORD(inbuf, PTP_IN_OP, MC_CMD_PTP_OP_READ_NIC_TIME);\r\nMCDI_SET_DWORD(inbuf, PTP_IN_PERIPH_ID, 0);\r\nrc = efx_mcdi_rpc(efx, MC_CMD_PTP, inbuf, sizeof(inbuf),\r\noutbuf, sizeof(outbuf), NULL);\r\nif (rc != 0)\r\nreturn rc;\r\nkt = ptp_data->nic_to_kernel_time(\r\nMCDI_DWORD(outbuf, PTP_OUT_READ_NIC_TIME_MAJOR),\r\nMCDI_DWORD(outbuf, PTP_OUT_READ_NIC_TIME_MINOR), 0);\r\n*ts = ktime_to_timespec64(kt);\r\nreturn 0;\r\n}\r\nstatic int efx_phc_settime(struct ptp_clock_info *ptp,\r\nconst struct timespec64 *e_ts)\r\n{\r\nint rc;\r\nstruct timespec64 time_now;\r\nstruct timespec64 delta;\r\nrc = efx_phc_gettime(ptp, &time_now);\r\nif (rc != 0)\r\nreturn rc;\r\ndelta = timespec64_sub(*e_ts, time_now);\r\nrc = efx_phc_adjtime(ptp, timespec64_to_ns(&delta));\r\nif (rc != 0)\r\nreturn rc;\r\nreturn 0;\r\n}\r\nstatic int efx_phc_enable(struct ptp_clock_info *ptp,\r\nstruct ptp_clock_request *request,\r\nint enable)\r\n{\r\nstruct efx_ptp_data *ptp_data = container_of(ptp,\r\nstruct efx_ptp_data,\r\nphc_clock_info);\r\nif (request->type != PTP_CLK_REQ_PPS)\r\nreturn -EOPNOTSUPP;\r\nptp_data->nic_ts_enabled = !!enable;\r\nreturn 0;\r\n}\r\nvoid efx_ptp_defer_probe_with_channel(struct efx_nic *efx)\r\n{\r\nif (efx_ptp_disable(efx) == 0)\r\nefx->extra_channel_type[EFX_EXTRA_CHANNEL_PTP] =\r\n&efx_ptp_channel_type;\r\n}\r\nvoid efx_ptp_start_datapath(struct efx_nic *efx)\r\n{\r\nif (efx_ptp_restart(efx))\r\nnetif_err(efx, drv, efx->net_dev, "Failed to restart PTP.\n");\r\nif (efx->type->ptp_set_ts_sync_events)\r\nefx->type->ptp_set_ts_sync_events(efx, true, true);\r\n}\r\nvoid efx_ptp_stop_datapath(struct efx_nic *efx)\r\n{\r\nif (efx->type->ptp_set_ts_sync_events)\r\nefx->type->ptp_set_ts_sync_events(efx, false, true);\r\nefx_ptp_stop(efx);\r\n}
