static int adt7411_read_10_bit(struct i2c_client *client, u8 lsb_reg,\r\nu8 msb_reg, u8 lsb_shift)\r\n{\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nint val, tmp;\r\nmutex_lock(&data->device_lock);\r\nval = i2c_smbus_read_byte_data(client, lsb_reg);\r\nif (val < 0)\r\ngoto exit_unlock;\r\ntmp = (val >> lsb_shift) & 3;\r\nval = i2c_smbus_read_byte_data(client, msb_reg);\r\nif (val >= 0)\r\nval = (val << 2) | tmp;\r\nexit_unlock:\r\nmutex_unlock(&data->device_lock);\r\nreturn val;\r\n}\r\nstatic int adt7411_modify_bit(struct i2c_client *client, u8 reg, u8 bit,\r\nbool flag)\r\n{\r\nstruct adt7411_data *data = i2c_get_clientdata(client);\r\nint ret, val;\r\nmutex_lock(&data->device_lock);\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ngoto exit_unlock;\r\nif (flag)\r\nval = ret | bit;\r\nelse\r\nval = ret & ~bit;\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nexit_unlock:\r\nmutex_unlock(&data->device_lock);\r\nreturn ret;\r\n}\r\nstatic ssize_t adt7411_show_bit(struct device *dev,\r\nstruct device_attribute *attr, char *buf)\r\n{\r\nstruct sensor_device_attribute_2 *attr2 = to_sensor_dev_attr_2(attr);\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret = i2c_smbus_read_byte_data(client, attr2->index);\r\nreturn ret < 0 ? ret : sprintf(buf, "%u\n", !!(ret & attr2->nr));\r\n}\r\nstatic ssize_t adt7411_set_bit(struct device *dev,\r\nstruct device_attribute *attr, const char *buf,\r\nsize_t count)\r\n{\r\nstruct sensor_device_attribute_2 *s_attr2 = to_sensor_dev_attr_2(attr);\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nunsigned long flag;\r\nret = kstrtoul(buf, 0, &flag);\r\nif (ret || flag > 1)\r\nreturn -EINVAL;\r\nret = adt7411_modify_bit(client, s_attr2->index, s_attr2->nr, flag);\r\nmutex_lock(&data->update_lock);\r\ndata->next_update = jiffies;\r\nmutex_unlock(&data->update_lock);\r\nreturn ret < 0 ? ret : count;\r\n}\r\nstatic int adt7411_read_in_alarm(struct device *dev, int channel, long *val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nret = i2c_smbus_read_byte_data(client, adt7411_in_alarm_reg[channel]);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = !!(ret & adt7411_in_alarm_bits[channel]);\r\nreturn 0;\r\n}\r\nstatic int adt7411_read_in_vdd(struct device *dev, u32 attr, long *val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nswitch (attr) {\r\ncase hwmon_in_input:\r\nret = adt7411_read_10_bit(client, ADT7411_REG_INT_TEMP_VDD_LSB,\r\nADT7411_REG_VDD_MSB, 2);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret * 7000 / 1024;\r\nreturn 0;\r\ncase hwmon_in_min:\r\nret = i2c_smbus_read_byte_data(client, ADT7411_REG_VDD_LOW);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret * 7000 / 256;\r\nreturn 0;\r\ncase hwmon_in_max:\r\nret = i2c_smbus_read_byte_data(client, ADT7411_REG_VDD_HIGH);\r\nif (ret < 0)\r\nreturn ret;\r\n*val = ret * 7000 / 256;\r\nreturn 0;\r\ncase hwmon_in_alarm:\r\nreturn adt7411_read_in_alarm(dev, 0, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int adt7411_update_vref(struct device *dev)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint val;\r\nif (time_after_eq(jiffies, data->next_update)) {\r\nval = i2c_smbus_read_byte_data(client, ADT7411_REG_CFG3);\r\nif (val < 0)\r\nreturn val;\r\nif (val & ADT7411_CFG3_REF_VDD) {\r\nval = adt7411_read_in_vdd(dev, hwmon_in_input,\r\n&data->vref_cached);\r\nif (val < 0)\r\nreturn val;\r\n} else {\r\ndata->vref_cached = 2250;\r\n}\r\ndata->next_update = jiffies + HZ;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adt7411_read_in_chan(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret;\r\nint reg, lsb_reg, lsb_shift;\r\nint nr = channel - 1;\r\nmutex_lock(&data->update_lock);\r\nret = adt7411_update_vref(dev);\r\nif (ret < 0)\r\ngoto exit_unlock;\r\nswitch (attr) {\r\ncase hwmon_in_input:\r\nlsb_reg = ADT7411_REG_EXT_TEMP_AIN14_LSB + (nr >> 2);\r\nlsb_shift = 2 * (nr & 0x03);\r\nret = adt7411_read_10_bit(client, lsb_reg,\r\nADT7411_REG_EXT_TEMP_AIN1_MSB + nr,\r\nlsb_shift);\r\nif (ret < 0)\r\ngoto exit_unlock;\r\n*val = ret * data->vref_cached / 1024;\r\nret = 0;\r\nbreak;\r\ncase hwmon_in_min:\r\ncase hwmon_in_max:\r\nreg = (attr == hwmon_in_min)\r\n? ADT7411_REG_IN_LOW(channel)\r\n: ADT7411_REG_IN_HIGH(channel);\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\ngoto exit_unlock;\r\n*val = ret * data->vref_cached / 256;\r\nret = 0;\r\nbreak;\r\ncase hwmon_in_alarm:\r\nret = adt7411_read_in_alarm(dev, channel, val);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\nbreak;\r\n}\r\nexit_unlock:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int adt7411_read_in(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nif (channel == 0)\r\nreturn adt7411_read_in_vdd(dev, attr, val);\r\nelse\r\nreturn adt7411_read_in_chan(dev, attr, channel, val);\r\n}\r\nstatic int adt7411_read_temp_alarm(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret, bit;\r\nret = i2c_smbus_read_byte_data(client, ADT7411_REG_STAT_1);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (attr) {\r\ncase hwmon_temp_min_alarm:\r\nbit = channel ? ADT7411_STAT_1_EXT_TEMP_LOW\r\n: ADT7411_STAT_1_INT_TEMP_LOW;\r\nbreak;\r\ncase hwmon_temp_max_alarm:\r\nbit = channel ? ADT7411_STAT_1_EXT_TEMP_HIGH_AIN1\r\n: ADT7411_STAT_1_INT_TEMP_HIGH;\r\nbreak;\r\ncase hwmon_temp_fault:\r\nbit = ADT7411_STAT_1_EXT_TEMP_FAULT;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n*val = !!(ret & bit);\r\nreturn 0;\r\n}\r\nstatic int adt7411_read_temp(struct device *dev, u32 attr, int channel,\r\nlong *val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret, reg, regl, regh;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\nregl = channel ? ADT7411_REG_EXT_TEMP_AIN14_LSB :\r\nADT7411_REG_INT_TEMP_VDD_LSB;\r\nregh = channel ? ADT7411_REG_EXT_TEMP_AIN1_MSB :\r\nADT7411_REG_INT_TEMP_MSB;\r\nret = adt7411_read_10_bit(client, regl, regh, 0);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret & 0x200 ? ret - 0x400 : ret;\r\n*val = ret * 250;\r\nreturn 0;\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\nreg = (attr == hwmon_temp_min)\r\n? ADT7411_REG_TEMP_LOW(channel)\r\n: ADT7411_REG_TEMP_HIGH(channel);\r\nret = i2c_smbus_read_byte_data(client, reg);\r\nif (ret < 0)\r\nreturn ret;\r\nret = ret & 0x80 ? ret - 0x100 : ret;\r\n*val = ret * 1000;\r\nreturn 0;\r\ncase hwmon_temp_min_alarm:\r\ncase hwmon_temp_max_alarm:\r\ncase hwmon_temp_fault:\r\nreturn adt7411_read_temp_alarm(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int adt7411_read(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long *val)\r\n{\r\nswitch (type) {\r\ncase hwmon_in:\r\nreturn adt7411_read_in(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn adt7411_read_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic int adt7411_write_in_vdd(struct device *dev, u32 attr, long val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint reg;\r\nval = clamp_val(val, 0, 255 * 7000 / 256);\r\nval = DIV_ROUND_CLOSEST(val * 256, 7000);\r\nswitch (attr) {\r\ncase hwmon_in_min:\r\nreg = ADT7411_REG_VDD_LOW;\r\nbreak;\r\ncase hwmon_in_max:\r\nreg = ADT7411_REG_VDD_HIGH;\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn i2c_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic int adt7411_write_in_chan(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint ret, reg;\r\nmutex_lock(&data->update_lock);\r\nret = adt7411_update_vref(dev);\r\nif (ret < 0)\r\ngoto exit_unlock;\r\nval = clamp_val(val, 0, 255 * data->vref_cached / 256);\r\nval = DIV_ROUND_CLOSEST(val * 256, data->vref_cached);\r\nswitch (attr) {\r\ncase hwmon_in_min:\r\nreg = ADT7411_REG_IN_LOW(channel);\r\nbreak;\r\ncase hwmon_in_max:\r\nreg = ADT7411_REG_IN_HIGH(channel);\r\nbreak;\r\ndefault:\r\nret = -EOPNOTSUPP;\r\ngoto exit_unlock;\r\n}\r\nret = i2c_smbus_write_byte_data(client, reg, val);\r\nexit_unlock:\r\nmutex_unlock(&data->update_lock);\r\nreturn ret;\r\n}\r\nstatic int adt7411_write_in(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nif (channel == 0)\r\nreturn adt7411_write_in_vdd(dev, attr, val);\r\nelse\r\nreturn adt7411_write_in_chan(dev, attr, channel, val);\r\n}\r\nstatic int adt7411_write_temp(struct device *dev, u32 attr, int channel,\r\nlong val)\r\n{\r\nstruct adt7411_data *data = dev_get_drvdata(dev);\r\nstruct i2c_client *client = data->client;\r\nint reg;\r\nval = clamp_val(val, -128000, 127000);\r\nval = DIV_ROUND_CLOSEST(val, 1000);\r\nswitch (attr) {\r\ncase hwmon_temp_min:\r\nreg = ADT7411_REG_TEMP_LOW(channel);\r\nbreak;\r\ncase hwmon_temp_max:\r\nreg = ADT7411_REG_TEMP_HIGH(channel);\r\nbreak;\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\nreturn i2c_smbus_write_byte_data(client, reg, val);\r\n}\r\nstatic int adt7411_write(struct device *dev, enum hwmon_sensor_types type,\r\nu32 attr, int channel, long val)\r\n{\r\nswitch (type) {\r\ncase hwmon_in:\r\nreturn adt7411_write_in(dev, attr, channel, val);\r\ncase hwmon_temp:\r\nreturn adt7411_write_temp(dev, attr, channel, val);\r\ndefault:\r\nreturn -EOPNOTSUPP;\r\n}\r\n}\r\nstatic umode_t adt7411_is_visible(const void *_data,\r\nenum hwmon_sensor_types type,\r\nu32 attr, int channel)\r\n{\r\nconst struct adt7411_data *data = _data;\r\nbool visible;\r\nswitch (type) {\r\ncase hwmon_in:\r\nvisible = channel == 0 || channel >= 3 || !data->use_ext_temp;\r\nswitch (attr) {\r\ncase hwmon_in_input:\r\ncase hwmon_in_alarm:\r\nreturn visible ? S_IRUGO : 0;\r\ncase hwmon_in_min:\r\ncase hwmon_in_max:\r\nreturn visible ? S_IRUGO | S_IWUSR : 0;\r\n}\r\nbreak;\r\ncase hwmon_temp:\r\nvisible = channel == 0 || data->use_ext_temp;\r\nswitch (attr) {\r\ncase hwmon_temp_input:\r\ncase hwmon_temp_min_alarm:\r\ncase hwmon_temp_max_alarm:\r\ncase hwmon_temp_fault:\r\nreturn visible ? S_IRUGO : 0;\r\ncase hwmon_temp_min:\r\ncase hwmon_temp_max:\r\nreturn visible ? S_IRUGO | S_IWUSR : 0;\r\n}\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\nreturn 0;\r\n}\r\nstatic int adt7411_detect(struct i2c_client *client,\r\nstruct i2c_board_info *info)\r\n{\r\nint val;\r\nif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE_DATA))\r\nreturn -ENODEV;\r\nval = i2c_smbus_read_byte_data(client, ADT7411_REG_MANUFACTURER_ID);\r\nif (val < 0 || val != ADT7411_MANUFACTURER_ID) {\r\ndev_dbg(&client->dev,\r\n"Wrong manufacturer ID. Got %d, expected %d\n",\r\nval, ADT7411_MANUFACTURER_ID);\r\nreturn -ENODEV;\r\n}\r\nval = i2c_smbus_read_byte_data(client, ADT7411_REG_DEVICE_ID);\r\nif (val < 0 || val != ADT7411_DEVICE_ID) {\r\ndev_dbg(&client->dev,\r\n"Wrong device ID. Got %d, expected %d\n",\r\nval, ADT7411_DEVICE_ID);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, "adt7411", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int adt7411_init_device(struct adt7411_data *data)\r\n{\r\nint ret;\r\nu8 val;\r\nret = i2c_smbus_read_byte_data(data->client, ADT7411_REG_CFG3);\r\nif (ret < 0)\r\nreturn ret;\r\nval = ret;\r\nval &= ~(ADT7411_CFG3_RESERVED_BIT1 | ADT7411_CFG3_RESERVED_BIT2);\r\nval |= ADT7411_CFG3_RESERVED_BIT3;\r\nret = i2c_smbus_write_byte_data(data->client, ADT7411_REG_CFG3, val);\r\nif (ret < 0)\r\nreturn ret;\r\nret = i2c_smbus_read_byte_data(data->client, ADT7411_REG_CFG1);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->use_ext_temp = ret & ADT7411_CFG1_EXT_TDM;\r\nval = ret;\r\nval &= ~ADT7411_CFG1_RESERVED_BIT1;\r\nval |= ADT7411_CFG1_RESERVED_BIT3;\r\nval |= ADT7411_CFG1_START_MONITOR;\r\nreturn i2c_smbus_write_byte_data(data->client, ADT7411_REG_CFG1, val);\r\n}\r\nstatic int adt7411_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct adt7411_data *data;\r\nstruct device *hwmon_dev;\r\nint ret;\r\ndata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\r\nif (!data)\r\nreturn -ENOMEM;\r\ni2c_set_clientdata(client, data);\r\ndata->client = client;\r\nmutex_init(&data->device_lock);\r\nmutex_init(&data->update_lock);\r\nret = adt7411_init_device(data);\r\nif (ret < 0)\r\nreturn ret;\r\ndata->next_update = jiffies;\r\nhwmon_dev = devm_hwmon_device_register_with_info(dev, client->name,\r\ndata,\r\n&adt7411_chip_info,\r\nadt7411_groups);\r\nreturn PTR_ERR_OR_ZERO(hwmon_dev);\r\n}
