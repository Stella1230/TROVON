static struct sync_file *sync_file_alloc(void)\r\n{\r\nstruct sync_file *sync_file;\r\nsync_file = kzalloc(sizeof(*sync_file), GFP_KERNEL);\r\nif (!sync_file)\r\nreturn NULL;\r\nsync_file->file = anon_inode_getfile("sync_file", &sync_file_fops,\r\nsync_file, 0);\r\nif (IS_ERR(sync_file->file))\r\ngoto err;\r\nkref_init(&sync_file->kref);\r\ninit_waitqueue_head(&sync_file->wq);\r\nINIT_LIST_HEAD(&sync_file->cb.node);\r\nreturn sync_file;\r\nerr:\r\nkfree(sync_file);\r\nreturn NULL;\r\n}\r\nstatic void fence_check_cb_func(struct dma_fence *f, struct dma_fence_cb *cb)\r\n{\r\nstruct sync_file *sync_file;\r\nsync_file = container_of(cb, struct sync_file, cb);\r\nwake_up_all(&sync_file->wq);\r\n}\r\nstruct sync_file *sync_file_create(struct dma_fence *fence)\r\n{\r\nstruct sync_file *sync_file;\r\nsync_file = sync_file_alloc();\r\nif (!sync_file)\r\nreturn NULL;\r\nsync_file->fence = dma_fence_get(fence);\r\nsnprintf(sync_file->name, sizeof(sync_file->name), "%s-%s%llu-%d",\r\nfence->ops->get_driver_name(fence),\r\nfence->ops->get_timeline_name(fence), fence->context,\r\nfence->seqno);\r\nreturn sync_file;\r\n}\r\nstatic struct sync_file *sync_file_fdget(int fd)\r\n{\r\nstruct file *file = fget(fd);\r\nif (!file)\r\nreturn NULL;\r\nif (file->f_op != &sync_file_fops)\r\ngoto err;\r\nreturn file->private_data;\r\nerr:\r\nfput(file);\r\nreturn NULL;\r\n}\r\nstruct dma_fence *sync_file_get_fence(int fd)\r\n{\r\nstruct sync_file *sync_file;\r\nstruct dma_fence *fence;\r\nsync_file = sync_file_fdget(fd);\r\nif (!sync_file)\r\nreturn NULL;\r\nfence = dma_fence_get(sync_file->fence);\r\nfput(sync_file->file);\r\nreturn fence;\r\n}\r\nstatic int sync_file_set_fence(struct sync_file *sync_file,\r\nstruct dma_fence **fences, int num_fences)\r\n{\r\nstruct dma_fence_array *array;\r\nif (num_fences == 1) {\r\nsync_file->fence = fences[0];\r\nkfree(fences);\r\n} else {\r\narray = dma_fence_array_create(num_fences, fences,\r\ndma_fence_context_alloc(1),\r\n1, false);\r\nif (!array)\r\nreturn -ENOMEM;\r\nsync_file->fence = &array->base;\r\n}\r\nreturn 0;\r\n}\r\nstatic struct dma_fence **get_fences(struct sync_file *sync_file,\r\nint *num_fences)\r\n{\r\nif (dma_fence_is_array(sync_file->fence)) {\r\nstruct dma_fence_array *array = to_dma_fence_array(sync_file->fence);\r\n*num_fences = array->num_fences;\r\nreturn array->fences;\r\n}\r\n*num_fences = 1;\r\nreturn &sync_file->fence;\r\n}\r\nstatic void add_fence(struct dma_fence **fences,\r\nint *i, struct dma_fence *fence)\r\n{\r\nfences[*i] = fence;\r\nif (!dma_fence_is_signaled(fence)) {\r\ndma_fence_get(fence);\r\n(*i)++;\r\n}\r\n}\r\nstatic struct sync_file *sync_file_merge(const char *name, struct sync_file *a,\r\nstruct sync_file *b)\r\n{\r\nstruct sync_file *sync_file;\r\nstruct dma_fence **fences, **nfences, **a_fences, **b_fences;\r\nint i, i_a, i_b, num_fences, a_num_fences, b_num_fences;\r\nsync_file = sync_file_alloc();\r\nif (!sync_file)\r\nreturn NULL;\r\na_fences = get_fences(a, &a_num_fences);\r\nb_fences = get_fences(b, &b_num_fences);\r\nif (a_num_fences > INT_MAX - b_num_fences)\r\nreturn NULL;\r\nnum_fences = a_num_fences + b_num_fences;\r\nfences = kcalloc(num_fences, sizeof(*fences), GFP_KERNEL);\r\nif (!fences)\r\ngoto err;\r\nfor (i = i_a = i_b = 0; i_a < a_num_fences && i_b < b_num_fences; ) {\r\nstruct dma_fence *pt_a = a_fences[i_a];\r\nstruct dma_fence *pt_b = b_fences[i_b];\r\nif (pt_a->context < pt_b->context) {\r\nadd_fence(fences, &i, pt_a);\r\ni_a++;\r\n} else if (pt_a->context > pt_b->context) {\r\nadd_fence(fences, &i, pt_b);\r\ni_b++;\r\n} else {\r\nif (pt_a->seqno - pt_b->seqno <= INT_MAX)\r\nadd_fence(fences, &i, pt_a);\r\nelse\r\nadd_fence(fences, &i, pt_b);\r\ni_a++;\r\ni_b++;\r\n}\r\n}\r\nfor (; i_a < a_num_fences; i_a++)\r\nadd_fence(fences, &i, a_fences[i_a]);\r\nfor (; i_b < b_num_fences; i_b++)\r\nadd_fence(fences, &i, b_fences[i_b]);\r\nif (i == 0)\r\nfences[i++] = dma_fence_get(a_fences[0]);\r\nif (num_fences > i) {\r\nnfences = krealloc(fences, i * sizeof(*fences),\r\nGFP_KERNEL);\r\nif (!nfences)\r\ngoto err;\r\nfences = nfences;\r\n}\r\nif (sync_file_set_fence(sync_file, fences, i) < 0) {\r\nkfree(fences);\r\ngoto err;\r\n}\r\nstrlcpy(sync_file->name, name, sizeof(sync_file->name));\r\nreturn sync_file;\r\nerr:\r\nfput(sync_file->file);\r\nreturn NULL;\r\n}\r\nstatic void sync_file_free(struct kref *kref)\r\n{\r\nstruct sync_file *sync_file = container_of(kref, struct sync_file,\r\nkref);\r\nif (test_bit(POLL_ENABLED, &sync_file->fence->flags))\r\ndma_fence_remove_callback(sync_file->fence, &sync_file->cb);\r\ndma_fence_put(sync_file->fence);\r\nkfree(sync_file);\r\n}\r\nstatic int sync_file_release(struct inode *inode, struct file *file)\r\n{\r\nstruct sync_file *sync_file = file->private_data;\r\nkref_put(&sync_file->kref, sync_file_free);\r\nreturn 0;\r\n}\r\nstatic unsigned int sync_file_poll(struct file *file, poll_table *wait)\r\n{\r\nstruct sync_file *sync_file = file->private_data;\r\npoll_wait(file, &sync_file->wq, wait);\r\nif (!test_and_set_bit(POLL_ENABLED, &sync_file->fence->flags)) {\r\nif (dma_fence_add_callback(sync_file->fence, &sync_file->cb,\r\nfence_check_cb_func) < 0)\r\nwake_up_all(&sync_file->wq);\r\n}\r\nreturn dma_fence_is_signaled(sync_file->fence) ? POLLIN : 0;\r\n}\r\nstatic long sync_file_ioctl_merge(struct sync_file *sync_file,\r\nunsigned long arg)\r\n{\r\nint fd = get_unused_fd_flags(O_CLOEXEC);\r\nint err;\r\nstruct sync_file *fence2, *fence3;\r\nstruct sync_merge_data data;\r\nif (fd < 0)\r\nreturn fd;\r\nif (copy_from_user(&data, (void __user *)arg, sizeof(data))) {\r\nerr = -EFAULT;\r\ngoto err_put_fd;\r\n}\r\nif (data.flags || data.pad) {\r\nerr = -EINVAL;\r\ngoto err_put_fd;\r\n}\r\nfence2 = sync_file_fdget(data.fd2);\r\nif (!fence2) {\r\nerr = -ENOENT;\r\ngoto err_put_fd;\r\n}\r\ndata.name[sizeof(data.name) - 1] = '\0';\r\nfence3 = sync_file_merge(data.name, sync_file, fence2);\r\nif (!fence3) {\r\nerr = -ENOMEM;\r\ngoto err_put_fence2;\r\n}\r\ndata.fence = fd;\r\nif (copy_to_user((void __user *)arg, &data, sizeof(data))) {\r\nerr = -EFAULT;\r\ngoto err_put_fence3;\r\n}\r\nfd_install(fd, fence3->file);\r\nfput(fence2->file);\r\nreturn 0;\r\nerr_put_fence3:\r\nfput(fence3->file);\r\nerr_put_fence2:\r\nfput(fence2->file);\r\nerr_put_fd:\r\nput_unused_fd(fd);\r\nreturn err;\r\n}\r\nstatic void sync_fill_fence_info(struct dma_fence *fence,\r\nstruct sync_fence_info *info)\r\n{\r\nstrlcpy(info->obj_name, fence->ops->get_timeline_name(fence),\r\nsizeof(info->obj_name));\r\nstrlcpy(info->driver_name, fence->ops->get_driver_name(fence),\r\nsizeof(info->driver_name));\r\ninfo->status = dma_fence_get_status(fence);\r\ninfo->timestamp_ns = ktime_to_ns(fence->timestamp);\r\n}\r\nstatic long sync_file_ioctl_fence_info(struct sync_file *sync_file,\r\nunsigned long arg)\r\n{\r\nstruct sync_file_info info;\r\nstruct sync_fence_info *fence_info = NULL;\r\nstruct dma_fence **fences;\r\n__u32 size;\r\nint num_fences, ret, i;\r\nif (copy_from_user(&info, (void __user *)arg, sizeof(info)))\r\nreturn -EFAULT;\r\nif (info.flags || info.pad)\r\nreturn -EINVAL;\r\nfences = get_fences(sync_file, &num_fences);\r\nif (!info.num_fences)\r\ngoto no_fences;\r\nif (info.num_fences < num_fences)\r\nreturn -EINVAL;\r\nsize = num_fences * sizeof(*fence_info);\r\nfence_info = kzalloc(size, GFP_KERNEL);\r\nif (!fence_info)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < num_fences; i++)\r\nsync_fill_fence_info(fences[i], &fence_info[i]);\r\nif (copy_to_user(u64_to_user_ptr(info.sync_fence_info), fence_info,\r\nsize)) {\r\nret = -EFAULT;\r\ngoto out;\r\n}\r\nno_fences:\r\nstrlcpy(info.name, sync_file->name, sizeof(info.name));\r\ninfo.status = dma_fence_is_signaled(sync_file->fence);\r\ninfo.num_fences = num_fences;\r\nif (copy_to_user((void __user *)arg, &info, sizeof(info)))\r\nret = -EFAULT;\r\nelse\r\nret = 0;\r\nout:\r\nkfree(fence_info);\r\nreturn ret;\r\n}\r\nstatic long sync_file_ioctl(struct file *file, unsigned int cmd,\r\nunsigned long arg)\r\n{\r\nstruct sync_file *sync_file = file->private_data;\r\nswitch (cmd) {\r\ncase SYNC_IOC_MERGE:\r\nreturn sync_file_ioctl_merge(sync_file, arg);\r\ncase SYNC_IOC_FILE_INFO:\r\nreturn sync_file_ioctl_fence_info(sync_file, arg);\r\ndefault:\r\nreturn -ENOTTY;\r\n}\r\n}
