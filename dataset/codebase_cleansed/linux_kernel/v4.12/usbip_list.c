void usbip_list_usage(void)\r\n{\r\nprintf("usage: %s", usbip_list_usage_string);\r\n}\r\nstatic int get_exported_devices(char *host, int sockfd)\r\n{\r\nchar product_name[100];\r\nchar class_name[100];\r\nstruct op_devlist_reply reply;\r\nuint16_t code = OP_REP_DEVLIST;\r\nstruct usbip_usb_device udev;\r\nstruct usbip_usb_interface uintf;\r\nunsigned int i;\r\nint rc, j;\r\nrc = usbip_net_send_op_common(sockfd, OP_REQ_DEVLIST, 0);\r\nif (rc < 0) {\r\ndbg("usbip_net_send_op_common failed");\r\nreturn -1;\r\n}\r\nrc = usbip_net_recv_op_common(sockfd, &code);\r\nif (rc < 0) {\r\ndbg("usbip_net_recv_op_common failed");\r\nreturn -1;\r\n}\r\nmemset(&reply, 0, sizeof(reply));\r\nrc = usbip_net_recv(sockfd, &reply, sizeof(reply));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv_op_devlist failed");\r\nreturn -1;\r\n}\r\nPACK_OP_DEVLIST_REPLY(0, &reply);\r\ndbg("exportable devices: %d\n", reply.ndev);\r\nif (reply.ndev == 0) {\r\ninfo("no exportable devices found on %s", host);\r\nreturn 0;\r\n}\r\nprintf("Exportable USB devices\n");\r\nprintf("======================\n");\r\nprintf(" - %s\n", host);\r\nfor (i = 0; i < reply.ndev; i++) {\r\nmemset(&udev, 0, sizeof(udev));\r\nrc = usbip_net_recv(sockfd, &udev, sizeof(udev));\r\nif (rc < 0) {\r\ndbg("usbip_net_recv failed: usbip_usb_device[%d]", i);\r\nreturn -1;\r\n}\r\nusbip_net_pack_usb_device(0, &udev);\r\nusbip_names_get_product(product_name, sizeof(product_name),\r\nudev.idVendor, udev.idProduct);\r\nusbip_names_get_class(class_name, sizeof(class_name),\r\nudev.bDeviceClass, udev.bDeviceSubClass,\r\nudev.bDeviceProtocol);\r\nprintf("%11s: %s\n", udev.busid, product_name);\r\nprintf("%11s: %s\n", "", udev.path);\r\nprintf("%11s: %s\n", "", class_name);\r\nfor (j = 0; j < udev.bNumInterfaces; j++) {\r\nrc = usbip_net_recv(sockfd, &uintf, sizeof(uintf));\r\nif (rc < 0) {\r\nerr("usbip_net_recv failed: usbip_usb_intf[%d]",\r\nj);\r\nreturn -1;\r\n}\r\nusbip_net_pack_usb_interface(0, &uintf);\r\nusbip_names_get_class(class_name, sizeof(class_name),\r\nuintf.bInterfaceClass,\r\nuintf.bInterfaceSubClass,\r\nuintf.bInterfaceProtocol);\r\nprintf("%11s: %2d - %s\n", "", j, class_name);\r\n}\r\nprintf("\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int list_exported_devices(char *host)\r\n{\r\nint rc;\r\nint sockfd;\r\nsockfd = usbip_net_tcp_connect(host, usbip_port_string);\r\nif (sockfd < 0) {\r\nerr("could not connect to %s:%s: %s", host,\r\nusbip_port_string, gai_strerror(sockfd));\r\nreturn -1;\r\n}\r\ndbg("connected to %s:%s", host, usbip_port_string);\r\nrc = get_exported_devices(host, sockfd);\r\nif (rc < 0) {\r\nerr("failed to get device list from %s", host);\r\nreturn -1;\r\n}\r\nclose(sockfd);\r\nreturn 0;\r\n}\r\nstatic void print_device(const char *busid, const char *vendor,\r\nconst char *product, bool parsable)\r\n{\r\nif (parsable)\r\nprintf("busid=%s#usbid=%.4s:%.4s#", busid, vendor, product);\r\nelse\r\nprintf(" - busid %s (%.4s:%.4s)\n", busid, vendor, product);\r\n}\r\nstatic void print_product_name(char *product_name, bool parsable)\r\n{\r\nif (!parsable)\r\nprintf(" %s\n", product_name);\r\n}\r\nstatic int list_devices(bool parsable)\r\n{\r\nstruct udev *udev;\r\nstruct udev_enumerate *enumerate;\r\nstruct udev_list_entry *devices, *dev_list_entry;\r\nstruct udev_device *dev;\r\nconst char *path;\r\nconst char *idVendor;\r\nconst char *idProduct;\r\nconst char *bConfValue;\r\nconst char *bNumIntfs;\r\nconst char *busid;\r\nchar product_name[128];\r\nint ret = -1;\r\nudev = udev_new();\r\nenumerate = udev_enumerate_new(udev);\r\nudev_enumerate_add_match_subsystem(enumerate, "usb");\r\nudev_enumerate_add_nomatch_sysattr(enumerate, "bDeviceClass", "09");\r\nudev_enumerate_add_nomatch_sysattr(enumerate, "bInterfaceNumber", NULL);\r\nudev_enumerate_scan_devices(enumerate);\r\ndevices = udev_enumerate_get_list_entry(enumerate);\r\nudev_list_entry_foreach(dev_list_entry, devices) {\r\npath = udev_list_entry_get_name(dev_list_entry);\r\ndev = udev_device_new_from_syspath(udev, path);\r\nidVendor = udev_device_get_sysattr_value(dev, "idVendor");\r\nidProduct = udev_device_get_sysattr_value(dev, "idProduct");\r\nbConfValue = udev_device_get_sysattr_value(dev,\r\n"bConfigurationValue");\r\nbNumIntfs = udev_device_get_sysattr_value(dev,\r\n"bNumInterfaces");\r\nbusid = udev_device_get_sysname(dev);\r\nif (!idVendor || !idProduct || !bConfValue || !bNumIntfs) {\r\nerr("problem getting device attributes: %s",\r\nstrerror(errno));\r\ngoto err_out;\r\n}\r\nusbip_names_get_product(product_name, sizeof(product_name),\r\nstrtol(idVendor, NULL, 16),\r\nstrtol(idProduct, NULL, 16));\r\nprint_device(busid, idVendor, idProduct, parsable);\r\nprint_product_name(product_name, parsable);\r\nprintf("\n");\r\nudev_device_unref(dev);\r\n}\r\nret = 0;\r\nerr_out:\r\nudev_enumerate_unref(enumerate);\r\nudev_unref(udev);\r\nreturn ret;\r\n}\r\nstatic int list_gadget_devices(bool parsable)\r\n{\r\nint ret = -1;\r\nstruct udev *udev;\r\nstruct udev_enumerate *enumerate;\r\nstruct udev_list_entry *devices, *dev_list_entry;\r\nstruct udev_device *dev;\r\nconst char *path;\r\nconst char *driver;\r\nconst struct usb_device_descriptor *d_desc;\r\nconst char *descriptors;\r\nchar product_name[128];\r\nuint16_t idVendor;\r\nchar idVendor_buf[8];\r\nuint16_t idProduct;\r\nchar idProduct_buf[8];\r\nconst char *busid;\r\nudev = udev_new();\r\nenumerate = udev_enumerate_new(udev);\r\nudev_enumerate_add_match_subsystem(enumerate, "platform");\r\nudev_enumerate_scan_devices(enumerate);\r\ndevices = udev_enumerate_get_list_entry(enumerate);\r\nudev_list_entry_foreach(dev_list_entry, devices) {\r\npath = udev_list_entry_get_name(dev_list_entry);\r\ndev = udev_device_new_from_syspath(udev, path);\r\ndriver = udev_device_get_driver(dev);\r\nif (driver == NULL || strcmp(driver, USBIP_DEVICE_DRV_NAME))\r\ncontinue;\r\ndescriptors = udev_device_get_sysattr_value(dev,\r\nVUDC_DEVICE_DESCR_FILE);\r\nif (!descriptors) {\r\nerr("problem getting device attributes: %s",\r\nstrerror(errno));\r\ngoto err_out;\r\n}\r\nd_desc = (const struct usb_device_descriptor *) descriptors;\r\nidVendor = le16toh(d_desc->idVendor);\r\nsprintf(idVendor_buf, "0x%4x", idVendor);\r\nidProduct = le16toh(d_desc->idProduct);\r\nsprintf(idProduct_buf, "0x%4x", idVendor);\r\nbusid = udev_device_get_sysname(dev);\r\nusbip_names_get_product(product_name, sizeof(product_name),\r\nle16toh(idVendor),\r\nle16toh(idProduct));\r\nprint_device(busid, idVendor_buf, idProduct_buf, parsable);\r\nprint_product_name(product_name, parsable);\r\nprintf("\n");\r\nudev_device_unref(dev);\r\n}\r\nret = 0;\r\nerr_out:\r\nudev_enumerate_unref(enumerate);\r\nudev_unref(udev);\r\nreturn ret;\r\n}\r\nint usbip_list(int argc, char *argv[])\r\n{\r\nstatic const struct option opts[] = {\r\n{ "parsable", no_argument, NULL, 'p' },\r\n{ "remote", required_argument, NULL, 'r' },\r\n{ "local", no_argument, NULL, 'l' },\r\n{ "device", no_argument, NULL, 'd' },\r\n{ NULL, 0, NULL, 0 }\r\n};\r\nbool parsable = false;\r\nint opt;\r\nint ret = -1;\r\nif (usbip_names_init(USBIDS_FILE))\r\nerr("failed to open %s", USBIDS_FILE);\r\nfor (;;) {\r\nopt = getopt_long(argc, argv, "pr:ld", opts, NULL);\r\nif (opt == -1)\r\nbreak;\r\nswitch (opt) {\r\ncase 'p':\r\nparsable = true;\r\nbreak;\r\ncase 'r':\r\nret = list_exported_devices(optarg);\r\ngoto out;\r\ncase 'l':\r\nret = list_devices(parsable);\r\ngoto out;\r\ncase 'd':\r\nret = list_gadget_devices(parsable);\r\ngoto out;\r\ndefault:\r\ngoto err_out;\r\n}\r\n}\r\nerr_out:\r\nusbip_list_usage();\r\nout:\r\nusbip_names_free();\r\nreturn ret;\r\n}
