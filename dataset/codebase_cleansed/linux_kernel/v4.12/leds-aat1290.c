static struct aat1290_led *fled_cdev_to_led(\r\nstruct led_classdev_flash *fled_cdev)\r\n{\r\nreturn container_of(fled_cdev, struct aat1290_led, fled_cdev);\r\n}\r\nstatic struct led_classdev_flash *led_cdev_to_fled_cdev(\r\nstruct led_classdev *led_cdev)\r\n{\r\nreturn container_of(led_cdev, struct led_classdev_flash, led_cdev);\r\n}\r\nstatic void aat1290_as2cwire_write(struct aat1290_led *led, int addr, int value)\r\n{\r\nint i;\r\ngpiod_direction_output(led->gpio_fl_en, 0);\r\ngpiod_direction_output(led->gpio_en_set, 0);\r\nudelay(AAT1290_FLEN_OFF_DELAY_TIME_US);\r\nfor (i = 0; i < addr; ++i) {\r\nudelay(AAT1290_EN_SET_TICK_TIME_US);\r\ngpiod_direction_output(led->gpio_en_set, 0);\r\nudelay(AAT1290_EN_SET_TICK_TIME_US);\r\ngpiod_direction_output(led->gpio_en_set, 1);\r\n}\r\nusleep_range(AAT1290_LATCH_TIME_MIN_US, AAT1290_LATCH_TIME_MAX_US);\r\nfor (i = 0; i < value; ++i) {\r\nudelay(AAT1290_EN_SET_TICK_TIME_US);\r\ngpiod_direction_output(led->gpio_en_set, 0);\r\nudelay(AAT1290_EN_SET_TICK_TIME_US);\r\ngpiod_direction_output(led->gpio_en_set, 1);\r\n}\r\nusleep_range(AAT1290_LATCH_TIME_MIN_US, AAT1290_LATCH_TIME_MAX_US);\r\n}\r\nstatic void aat1290_set_flash_safety_timer(struct aat1290_led *led,\r\nunsigned int micro_sec)\r\n{\r\nstruct led_classdev_flash *fled_cdev = &led->fled_cdev;\r\nstruct led_flash_setting *flash_tm = &fled_cdev->timeout;\r\nint flash_tm_reg = AAT1290_FLASH_TM_NUM_LEVELS -\r\n(micro_sec / flash_tm->step) + 1;\r\naat1290_as2cwire_write(led, AAT1290_FLASH_SAFETY_TIMER_ADDR,\r\nflash_tm_reg);\r\n}\r\nstatic int aat1290_led_brightness_set(struct led_classdev *led_cdev,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_classdev_flash *fled_cdev = led_cdev_to_fled_cdev(led_cdev);\r\nstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\r\nmutex_lock(&led->lock);\r\nif (brightness == 0) {\r\ngpiod_direction_output(led->gpio_fl_en, 0);\r\ngpiod_direction_output(led->gpio_en_set, 0);\r\nled->movie_mode = false;\r\n} else {\r\nif (!led->movie_mode) {\r\naat1290_as2cwire_write(led,\r\nAAT1290_MM_CURRENT_RATIO_ADDR,\r\nAAT1290_MM_TO_FL_1_92);\r\nled->movie_mode = true;\r\n}\r\naat1290_as2cwire_write(led, AAT1290_MOVIE_MODE_CURRENT_ADDR,\r\nAAT1290_MAX_MM_CURR_PERCENT_0 - brightness);\r\naat1290_as2cwire_write(led, AAT1290_MOVIE_MODE_CONFIG_ADDR,\r\nAAT1290_MOVIE_MODE_ON);\r\n}\r\nmutex_unlock(&led->lock);\r\nreturn 0;\r\n}\r\nstatic int aat1290_led_flash_strobe_set(struct led_classdev_flash *fled_cdev,\r\nbool state)\r\n{\r\nstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\r\nstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\r\nstruct led_flash_setting *timeout = &fled_cdev->timeout;\r\nmutex_lock(&led->lock);\r\nif (state) {\r\naat1290_set_flash_safety_timer(led, timeout->val);\r\ngpiod_direction_output(led->gpio_fl_en, 1);\r\n} else {\r\ngpiod_direction_output(led->gpio_fl_en, 0);\r\ngpiod_direction_output(led->gpio_en_set, 0);\r\n}\r\nled_cdev->brightness = 0;\r\nled->movie_mode = false;\r\nmutex_unlock(&led->lock);\r\nreturn 0;\r\n}\r\nstatic int aat1290_led_flash_timeout_set(struct led_classdev_flash *fled_cdev,\r\nu32 timeout)\r\n{\r\nreturn 0;\r\n}\r\nstatic int aat1290_led_parse_dt(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *cfg,\r\nstruct device_node **sub_node)\r\n{\r\nstruct led_classdev *led_cdev = &led->fled_cdev.led_cdev;\r\nstruct device *dev = &led->pdev->dev;\r\nstruct device_node *child_node;\r\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\r\nstruct pinctrl *pinctrl;\r\n#endif\r\nint ret = 0;\r\nled->gpio_fl_en = devm_gpiod_get(dev, "flen", GPIOD_ASIS);\r\nif (IS_ERR(led->gpio_fl_en)) {\r\nret = PTR_ERR(led->gpio_fl_en);\r\ndev_err(dev, "Unable to claim gpio \"flen\".\n");\r\nreturn ret;\r\n}\r\nled->gpio_en_set = devm_gpiod_get(dev, "enset", GPIOD_ASIS);\r\nif (IS_ERR(led->gpio_en_set)) {\r\nret = PTR_ERR(led->gpio_en_set);\r\ndev_err(dev, "Unable to claim gpio \"enset\".\n");\r\nreturn ret;\r\n}\r\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\r\npinctrl = devm_pinctrl_get_select_default(&led->pdev->dev);\r\nif (IS_ERR(pinctrl)) {\r\ncfg->has_external_strobe = false;\r\ndev_info(dev,\r\n"No support for external strobe detected.\n");\r\n} else {\r\ncfg->has_external_strobe = true;\r\n}\r\n#endif\r\nchild_node = of_get_next_available_child(dev->of_node, NULL);\r\nif (!child_node) {\r\ndev_err(dev, "No DT child node found for connected LED.\n");\r\nreturn -EINVAL;\r\n}\r\nled_cdev->name = of_get_property(child_node, "label", NULL) ? :\r\nchild_node->name;\r\nret = of_property_read_u32(child_node, "led-max-microamp",\r\n&cfg->max_mm_current);\r\nif (ret < 0)\r\ndev_warn(dev,\r\n"led-max-microamp DT property missing\n");\r\nret = of_property_read_u32(child_node, "flash-max-microamp",\r\n&cfg->max_flash_current);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"flash-max-microamp DT property missing\n");\r\ngoto err_parse_dt;\r\n}\r\nret = of_property_read_u32(child_node, "flash-max-timeout-us",\r\n&cfg->max_flash_tm);\r\nif (ret < 0) {\r\ndev_err(dev,\r\n"flash-max-timeout-us DT property missing\n");\r\ngoto err_parse_dt;\r\n}\r\n*sub_node = child_node;\r\nerr_parse_dt:\r\nof_node_put(child_node);\r\nreturn ret;\r\n}\r\nstatic void aat1290_led_validate_mm_current(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *cfg)\r\n{\r\nint i, b = 0, e = AAT1290_MM_CURRENT_SCALE_SIZE;\r\nwhile (e - b > 1) {\r\ni = b + (e - b) / 2;\r\nif (cfg->max_mm_current < led->mm_current_scale[i])\r\ne = i;\r\nelse\r\nb = i;\r\n}\r\ncfg->max_mm_current = led->mm_current_scale[b];\r\ncfg->max_brightness = b + 1;\r\n}\r\nstatic int init_mm_current_scale(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *cfg)\r\n{\r\nint max_mm_current_percent[] = { 20, 22, 25, 28, 32, 36, 40, 45, 50, 56,\r\n63, 71, 79, 89, 100 };\r\nint i, max_mm_current =\r\nAAT1290_MAX_MM_CURRENT(cfg->max_flash_current);\r\nled->mm_current_scale = devm_kzalloc(&led->pdev->dev,\r\nsizeof(max_mm_current_percent),\r\nGFP_KERNEL);\r\nif (!led->mm_current_scale)\r\nreturn -ENOMEM;\r\nfor (i = 0; i < AAT1290_MM_CURRENT_SCALE_SIZE; ++i)\r\nled->mm_current_scale[i] = max_mm_current *\r\nmax_mm_current_percent[i] / 100;\r\nreturn 0;\r\n}\r\nstatic int aat1290_led_get_configuration(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *cfg,\r\nstruct device_node **sub_node)\r\n{\r\nint ret;\r\nret = aat1290_led_parse_dt(led, cfg, sub_node);\r\nif (ret < 0)\r\nreturn ret;\r\nret = init_mm_current_scale(led, cfg);\r\nif (ret < 0)\r\nreturn ret;\r\naat1290_led_validate_mm_current(led, cfg);\r\n#if IS_ENABLED(CONFIG_V4L2_FLASH_LED_CLASS)\r\n#else\r\ndevm_kfree(&led->pdev->dev, led->mm_current_scale);\r\n#endif\r\nreturn 0;\r\n}\r\nstatic void aat1290_init_flash_timeout(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *cfg)\r\n{\r\nstruct led_classdev_flash *fled_cdev = &led->fled_cdev;\r\nstruct led_flash_setting *setting;\r\nsetting = &fled_cdev->timeout;\r\nsetting->min = cfg->max_flash_tm / AAT1290_FLASH_TM_NUM_LEVELS;\r\nsetting->max = cfg->max_flash_tm;\r\nsetting->step = setting->min;\r\nsetting->val = setting->max;\r\n}\r\nstatic enum led_brightness aat1290_intensity_to_brightness(\r\nstruct v4l2_flash *v4l2_flash,\r\ns32 intensity)\r\n{\r\nstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\r\nstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\r\nint i;\r\nfor (i = AAT1290_MM_CURRENT_SCALE_SIZE - 1; i >= 0; --i)\r\nif (intensity >= led->mm_current_scale[i])\r\nreturn i + 1;\r\nreturn 1;\r\n}\r\nstatic s32 aat1290_brightness_to_intensity(struct v4l2_flash *v4l2_flash,\r\nenum led_brightness brightness)\r\n{\r\nstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\r\nstruct aat1290_led *led = fled_cdev_to_led(fled_cdev);\r\nreturn led->mm_current_scale[brightness - 1];\r\n}\r\nstatic int aat1290_led_external_strobe_set(struct v4l2_flash *v4l2_flash,\r\nbool enable)\r\n{\r\nstruct aat1290_led *led = fled_cdev_to_led(v4l2_flash->fled_cdev);\r\nstruct led_classdev_flash *fled_cdev = v4l2_flash->fled_cdev;\r\nstruct led_classdev *led_cdev = &fled_cdev->led_cdev;\r\nstruct pinctrl *pinctrl;\r\ngpiod_direction_output(led->gpio_fl_en, 0);\r\ngpiod_direction_output(led->gpio_en_set, 0);\r\nled->movie_mode = false;\r\nled_cdev->brightness = 0;\r\npinctrl = devm_pinctrl_get_select(&led->pdev->dev,\r\nenable ? "isp" : "host");\r\nif (IS_ERR(pinctrl)) {\r\ndev_warn(&led->pdev->dev, "Unable to switch strobe source.\n");\r\nreturn PTR_ERR(pinctrl);\r\n}\r\nreturn 0;\r\n}\r\nstatic void aat1290_init_v4l2_flash_config(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *led_cfg,\r\nstruct v4l2_flash_config *v4l2_sd_cfg)\r\n{\r\nstruct led_classdev *led_cdev = &led->fled_cdev.led_cdev;\r\nstruct led_flash_setting *s;\r\nstrlcpy(v4l2_sd_cfg->dev_name, led_cdev->name,\r\nsizeof(v4l2_sd_cfg->dev_name));\r\ns = &v4l2_sd_cfg->torch_intensity;\r\ns->min = led->mm_current_scale[0];\r\ns->max = led_cfg->max_mm_current;\r\ns->step = 1;\r\ns->val = s->max;\r\nv4l2_sd_cfg->has_external_strobe = led_cfg->has_external_strobe;\r\n}\r\nstatic inline void aat1290_init_v4l2_flash_config(struct aat1290_led *led,\r\nstruct aat1290_led_config_data *led_cfg,\r\nstruct v4l2_flash_config *v4l2_sd_cfg)\r\n{\r\n}\r\nstatic int aat1290_led_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct device_node *sub_node = NULL;\r\nstruct aat1290_led *led;\r\nstruct led_classdev *led_cdev;\r\nstruct led_classdev_flash *fled_cdev;\r\nstruct aat1290_led_config_data led_cfg = {};\r\nstruct v4l2_flash_config v4l2_sd_cfg = {};\r\nint ret;\r\nled = devm_kzalloc(dev, sizeof(*led), GFP_KERNEL);\r\nif (!led)\r\nreturn -ENOMEM;\r\nled->pdev = pdev;\r\nplatform_set_drvdata(pdev, led);\r\nfled_cdev = &led->fled_cdev;\r\nfled_cdev->ops = &flash_ops;\r\nled_cdev = &fled_cdev->led_cdev;\r\nret = aat1290_led_get_configuration(led, &led_cfg, &sub_node);\r\nif (ret < 0)\r\nreturn ret;\r\nmutex_init(&led->lock);\r\nled_cdev->brightness_set_blocking = aat1290_led_brightness_set;\r\nled_cdev->max_brightness = led_cfg.max_brightness;\r\nled_cdev->flags |= LED_DEV_CAP_FLASH;\r\naat1290_init_flash_timeout(led, &led_cfg);\r\nret = led_classdev_flash_register(&pdev->dev, fled_cdev);\r\nif (ret < 0)\r\ngoto err_flash_register;\r\naat1290_init_v4l2_flash_config(led, &led_cfg, &v4l2_sd_cfg);\r\nled->v4l2_flash = v4l2_flash_init(dev, sub_node, fled_cdev, NULL,\r\n&v4l2_flash_ops, &v4l2_sd_cfg);\r\nif (IS_ERR(led->v4l2_flash)) {\r\nret = PTR_ERR(led->v4l2_flash);\r\ngoto error_v4l2_flash_init;\r\n}\r\nreturn 0;\r\nerror_v4l2_flash_init:\r\nled_classdev_flash_unregister(fled_cdev);\r\nerr_flash_register:\r\nmutex_destroy(&led->lock);\r\nreturn ret;\r\n}\r\nstatic int aat1290_led_remove(struct platform_device *pdev)\r\n{\r\nstruct aat1290_led *led = platform_get_drvdata(pdev);\r\nv4l2_flash_release(led->v4l2_flash);\r\nled_classdev_flash_unregister(&led->fled_cdev);\r\nmutex_destroy(&led->lock);\r\nreturn 0;\r\n}
