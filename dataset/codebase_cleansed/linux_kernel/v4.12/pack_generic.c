static inline u32 lustre_msg_hdr_size_v2(u32 count)\r\n{\r\nreturn cfs_size_round(offsetof(struct lustre_msg_v2,\r\nlm_buflens[count]));\r\n}\r\nu32 lustre_msg_hdr_size(__u32 magic, u32 count)\r\n{\r\nswitch (magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_msg_hdr_size_v2(count);\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", magic);\r\nreturn 0;\r\n}\r\n}\r\nvoid ptlrpc_buf_set_swabbed(struct ptlrpc_request *req, const int inout,\r\nu32 index)\r\n{\r\nif (inout)\r\nlustre_set_req_swabbed(req, index);\r\nelse\r\nlustre_set_rep_swabbed(req, index);\r\n}\r\nint ptlrpc_buf_need_swab(struct ptlrpc_request *req, const int inout,\r\nu32 index)\r\n{\r\nif (inout)\r\nreturn (ptlrpc_req_need_swab(req) &&\r\n!lustre_req_swabbed(req, index));\r\nelse\r\nreturn (ptlrpc_rep_need_swab(req) &&\r\n!lustre_rep_swabbed(req, index));\r\n}\r\nu32 lustre_msg_early_size(void)\r\n{\r\nstatic u32 size;\r\nif (!size) {\r\n__u32 pblen = sizeof(struct ptlrpc_body_v2);\r\nsize = lustre_msg_size(LUSTRE_MSG_MAGIC_V2, 1, &pblen);\r\n}\r\nreturn size;\r\n}\r\nu32 lustre_msg_size_v2(int count, __u32 *lengths)\r\n{\r\nu32 size;\r\nint i;\r\nsize = lustre_msg_hdr_size_v2(count);\r\nfor (i = 0; i < count; i++)\r\nsize += cfs_size_round(lengths[i]);\r\nreturn size;\r\n}\r\nu32 lustre_msg_size(__u32 magic, int count, __u32 *lens)\r\n{\r\n__u32 size[] = { sizeof(struct ptlrpc_body) };\r\nif (!lens) {\r\nLASSERT(count == 1);\r\nlens = size;\r\n}\r\nLASSERT(count > 0);\r\nLASSERT(lens[MSG_PTLRPC_BODY_OFF] >= sizeof(struct ptlrpc_body_v2));\r\nswitch (magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_msg_size_v2(count, lens);\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", magic);\r\nreturn 0;\r\n}\r\n}\r\nu32 lustre_packed_msg_size(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\nvoid lustre_init_msg_v2(struct lustre_msg_v2 *msg, int count, __u32 *lens,\r\nchar **bufs)\r\n{\r\nchar *ptr;\r\nint i;\r\nmsg->lm_bufcount = count;\r\nmsg->lm_magic = LUSTRE_MSG_MAGIC_V2;\r\nfor (i = 0; i < count; i++)\r\nmsg->lm_buflens[i] = lens[i];\r\nif (!bufs)\r\nreturn;\r\nptr = (char *)msg + lustre_msg_hdr_size_v2(count);\r\nfor (i = 0; i < count; i++) {\r\nchar *tmp = bufs[i];\r\nLOGL(tmp, lens[i], ptr);\r\n}\r\n}\r\nstatic int lustre_pack_request_v2(struct ptlrpc_request *req,\r\nint count, __u32 *lens, char **bufs)\r\n{\r\nint reqlen, rc;\r\nreqlen = lustre_msg_size_v2(count, lens);\r\nrc = sptlrpc_cli_alloc_reqbuf(req, reqlen);\r\nif (rc)\r\nreturn rc;\r\nreq->rq_reqlen = reqlen;\r\nlustre_init_msg_v2(req->rq_reqmsg, count, lens, bufs);\r\nlustre_msg_add_version(req->rq_reqmsg, PTLRPC_MSG_VERSION);\r\nreturn 0;\r\n}\r\nint lustre_pack_request(struct ptlrpc_request *req, __u32 magic, int count,\r\n__u32 *lens, char **bufs)\r\n{\r\n__u32 size[] = { sizeof(struct ptlrpc_body) };\r\nif (!lens) {\r\nLASSERT(count == 1);\r\nlens = size;\r\n}\r\nLASSERT(count > 0);\r\nLASSERT(lens[MSG_PTLRPC_BODY_OFF] == sizeof(struct ptlrpc_body));\r\nreturn lustre_pack_request_v2(req, count, lens, bufs);\r\n}\r\nstruct ptlrpc_reply_state *\r\nlustre_get_emerg_rs(struct ptlrpc_service_part *svcpt)\r\n{\r\nstruct ptlrpc_reply_state *rs = NULL;\r\nspin_lock(&svcpt->scp_rep_lock);\r\nwhile (list_empty(&svcpt->scp_rep_idle)) {\r\nstruct l_wait_info lwi;\r\nint rc;\r\nspin_unlock(&svcpt->scp_rep_lock);\r\nlwi = LWI_TIMEOUT(cfs_time_seconds(10), NULL, NULL);\r\nrc = l_wait_event(svcpt->scp_rep_waitq,\r\n!list_empty(&svcpt->scp_rep_idle), &lwi);\r\nif (rc != 0)\r\ngoto out;\r\nspin_lock(&svcpt->scp_rep_lock);\r\n}\r\nrs = list_entry(svcpt->scp_rep_idle.next,\r\nstruct ptlrpc_reply_state, rs_list);\r\nlist_del(&rs->rs_list);\r\nspin_unlock(&svcpt->scp_rep_lock);\r\nmemset(rs, 0, svcpt->scp_service->srv_max_reply_size);\r\nrs->rs_size = svcpt->scp_service->srv_max_reply_size;\r\nrs->rs_svcpt = svcpt;\r\nrs->rs_prealloc = 1;\r\nout:\r\nreturn rs;\r\n}\r\nvoid lustre_put_emerg_rs(struct ptlrpc_reply_state *rs)\r\n{\r\nstruct ptlrpc_service_part *svcpt = rs->rs_svcpt;\r\nspin_lock(&svcpt->scp_rep_lock);\r\nlist_add(&rs->rs_list, &svcpt->scp_rep_idle);\r\nspin_unlock(&svcpt->scp_rep_lock);\r\nwake_up(&svcpt->scp_rep_waitq);\r\n}\r\nint lustre_pack_reply_v2(struct ptlrpc_request *req, int count,\r\n__u32 *lens, char **bufs, int flags)\r\n{\r\nstruct ptlrpc_reply_state *rs;\r\nint msg_len, rc;\r\nLASSERT(!req->rq_reply_state);\r\nif ((flags & LPRFL_EARLY_REPLY) == 0) {\r\nspin_lock(&req->rq_lock);\r\nreq->rq_packed_final = 1;\r\nspin_unlock(&req->rq_lock);\r\n}\r\nmsg_len = lustre_msg_size_v2(count, lens);\r\nrc = sptlrpc_svc_alloc_rs(req, msg_len);\r\nif (rc)\r\nreturn rc;\r\nrs = req->rq_reply_state;\r\natomic_set(&rs->rs_refcount, 1);\r\nrs->rs_cb_id.cbid_fn = reply_out_callback;\r\nrs->rs_cb_id.cbid_arg = rs;\r\nrs->rs_svcpt = req->rq_rqbd->rqbd_svcpt;\r\nINIT_LIST_HEAD(&rs->rs_exp_list);\r\nINIT_LIST_HEAD(&rs->rs_obd_list);\r\nINIT_LIST_HEAD(&rs->rs_list);\r\nspin_lock_init(&rs->rs_lock);\r\nreq->rq_replen = msg_len;\r\nreq->rq_reply_state = rs;\r\nreq->rq_repmsg = rs->rs_msg;\r\nlustre_init_msg_v2(rs->rs_msg, count, lens, bufs);\r\nlustre_msg_add_version(rs->rs_msg, PTLRPC_MSG_VERSION);\r\nPTLRPC_RS_DEBUG_LRU_ADD(rs);\r\nreturn 0;\r\n}\r\nint lustre_pack_reply_flags(struct ptlrpc_request *req, int count, __u32 *lens,\r\nchar **bufs, int flags)\r\n{\r\nint rc = 0;\r\n__u32 size[] = { sizeof(struct ptlrpc_body) };\r\nif (!lens) {\r\nLASSERT(count == 1);\r\nlens = size;\r\n}\r\nLASSERT(count > 0);\r\nLASSERT(lens[MSG_PTLRPC_BODY_OFF] == sizeof(struct ptlrpc_body));\r\nswitch (req->rq_reqmsg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nrc = lustre_pack_reply_v2(req, count, lens, bufs, flags);\r\nbreak;\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n",\r\nreq->rq_reqmsg->lm_magic);\r\nrc = -EINVAL;\r\n}\r\nif (rc != 0)\r\nCERROR("lustre_pack_reply failed: rc=%d size=%d\n", rc,\r\nlustre_msg_size(req->rq_reqmsg->lm_magic, count, lens));\r\nreturn rc;\r\n}\r\nint lustre_pack_reply(struct ptlrpc_request *req, int count, __u32 *lens,\r\nchar **bufs)\r\n{\r\nreturn lustre_pack_reply_flags(req, count, lens, bufs, 0);\r\n}\r\nvoid *lustre_msg_buf_v2(struct lustre_msg_v2 *m, u32 n, u32 min_size)\r\n{\r\nu32 i, offset, buflen, bufcount;\r\nbufcount = m->lm_bufcount;\r\nif (unlikely(n >= bufcount)) {\r\nCDEBUG(D_INFO, "msg %p buffer[%d] not present (count %d)\n",\r\nm, n, bufcount);\r\nreturn NULL;\r\n}\r\nbuflen = m->lm_buflens[n];\r\nif (unlikely(buflen < min_size)) {\r\nCERROR("msg %p buffer[%d] size %d too small (required %d, opc=%d)\n",\r\nm, n, buflen, min_size,\r\nn == MSG_PTLRPC_BODY_OFF ? -1 : lustre_msg_get_opc(m));\r\nreturn NULL;\r\n}\r\noffset = lustre_msg_hdr_size_v2(bufcount);\r\nfor (i = 0; i < n; i++)\r\noffset += cfs_size_round(m->lm_buflens[i]);\r\nreturn (char *)m + offset;\r\n}\r\nvoid *lustre_msg_buf(struct lustre_msg *m, u32 n, u32 min_size)\r\n{\r\nswitch (m->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_msg_buf_v2(m, n, min_size);\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x (msg:%p)\n",\r\nm->lm_magic, m);\r\nreturn NULL;\r\n}\r\n}\r\nstatic int lustre_shrink_msg_v2(struct lustre_msg_v2 *msg, u32 segment,\r\nunsigned int newlen, int move_data)\r\n{\r\nchar *tail = NULL, *newpos;\r\nint tail_len = 0, n;\r\nLASSERT(msg);\r\nLASSERT(msg->lm_bufcount > segment);\r\nLASSERT(msg->lm_buflens[segment] >= newlen);\r\nif (msg->lm_buflens[segment] == newlen)\r\ngoto out;\r\nif (move_data && msg->lm_bufcount > segment + 1) {\r\ntail = lustre_msg_buf_v2(msg, segment + 1, 0);\r\nfor (n = segment + 1; n < msg->lm_bufcount; n++)\r\ntail_len += cfs_size_round(msg->lm_buflens[n]);\r\n}\r\nmsg->lm_buflens[segment] = newlen;\r\nif (tail && tail_len) {\r\nnewpos = lustre_msg_buf_v2(msg, segment + 1, 0);\r\nLASSERT(newpos <= tail);\r\nif (newpos != tail)\r\nmemmove(newpos, tail, tail_len);\r\n}\r\nout:\r\nreturn lustre_msg_size_v2(msg->lm_bufcount, msg->lm_buflens);\r\n}\r\nint lustre_shrink_msg(struct lustre_msg *msg, int segment,\r\nunsigned int newlen, int move_data)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_shrink_msg_v2(msg, segment, newlen, move_data);\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\nreturn 0;\r\n}\r\nvoid lustre_free_reply_state(struct ptlrpc_reply_state *rs)\r\n{\r\nPTLRPC_RS_DEBUG_LRU_DEL(rs);\r\nLASSERT(atomic_read(&rs->rs_refcount) == 0);\r\nLASSERT(!rs->rs_difficult || rs->rs_handled);\r\nLASSERT(!rs->rs_on_net);\r\nLASSERT(!rs->rs_scheduled);\r\nLASSERT(!rs->rs_export);\r\nLASSERT(rs->rs_nlocks == 0);\r\nLASSERT(list_empty(&rs->rs_exp_list));\r\nLASSERT(list_empty(&rs->rs_obd_list));\r\nsptlrpc_svc_free_rs(rs);\r\n}\r\nstatic int lustre_unpack_msg_v2(struct lustre_msg_v2 *m, int len)\r\n{\r\nint swabbed, required_len, i;\r\nrequired_len = lustre_msg_hdr_size_v2(0);\r\nif (len < required_len) {\r\nCERROR("message length %d too small for lustre_msg\n", len);\r\nreturn -EINVAL;\r\n}\r\nswabbed = (m->lm_magic == LUSTRE_MSG_MAGIC_V2_SWABBED);\r\nif (swabbed) {\r\n__swab32s(&m->lm_magic);\r\n__swab32s(&m->lm_bufcount);\r\n__swab32s(&m->lm_secflvr);\r\n__swab32s(&m->lm_repsize);\r\n__swab32s(&m->lm_cksum);\r\n__swab32s(&m->lm_flags);\r\nBUILD_BUG_ON(offsetof(typeof(*m), lm_padding_2) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*m), lm_padding_3) == 0);\r\n}\r\nrequired_len = lustre_msg_hdr_size_v2(m->lm_bufcount);\r\nif (len < required_len) {\r\nCERROR("message length %d too small for %d buflens\n",\r\nlen, m->lm_bufcount);\r\nreturn -EINVAL;\r\n}\r\nfor (i = 0; i < m->lm_bufcount; i++) {\r\nif (swabbed)\r\n__swab32s(&m->lm_buflens[i]);\r\nrequired_len += cfs_size_round(m->lm_buflens[i]);\r\n}\r\nif (len < required_len) {\r\nCERROR("len: %d, required_len %d\n", len, required_len);\r\nCERROR("bufcount: %d\n", m->lm_bufcount);\r\nfor (i = 0; i < m->lm_bufcount; i++)\r\nCERROR("buffer %d length %d\n", i, m->lm_buflens[i]);\r\nreturn -EINVAL;\r\n}\r\nreturn swabbed;\r\n}\r\nint __lustre_unpack_msg(struct lustre_msg *m, int len)\r\n{\r\nint required_len, rc;\r\nrequired_len = offsetof(struct lustre_msg, lm_magic) +\r\nsizeof(m->lm_magic);\r\nif (len < required_len) {\r\nCERROR("message length %d too small for magic/version check\n",\r\nlen);\r\nreturn -EINVAL;\r\n}\r\nrc = lustre_unpack_msg_v2(m, len);\r\nreturn rc;\r\n}\r\nint ptlrpc_unpack_req_msg(struct ptlrpc_request *req, int len)\r\n{\r\nint rc;\r\nrc = __lustre_unpack_msg(req->rq_reqmsg, len);\r\nif (rc == 1) {\r\nlustre_set_req_swabbed(req, MSG_PTLRPC_HEADER_OFF);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nint ptlrpc_unpack_rep_msg(struct ptlrpc_request *req, int len)\r\n{\r\nint rc;\r\nrc = __lustre_unpack_msg(req->rq_repmsg, len);\r\nif (rc == 1) {\r\nlustre_set_rep_swabbed(req, MSG_PTLRPC_HEADER_OFF);\r\nrc = 0;\r\n}\r\nreturn rc;\r\n}\r\nstatic inline int lustre_unpack_ptlrpc_body_v2(struct ptlrpc_request *req,\r\nconst int inout, int offset)\r\n{\r\nstruct ptlrpc_body *pb;\r\nstruct lustre_msg_v2 *m = inout ? req->rq_reqmsg : req->rq_repmsg;\r\npb = lustre_msg_buf_v2(m, offset, sizeof(struct ptlrpc_body_v2));\r\nif (!pb) {\r\nCERROR("error unpacking ptlrpc body\n");\r\nreturn -EFAULT;\r\n}\r\nif (ptlrpc_buf_need_swab(req, inout, offset)) {\r\nlustre_swab_ptlrpc_body(pb);\r\nptlrpc_buf_set_swabbed(req, inout, offset);\r\n}\r\nif ((pb->pb_version & ~LUSTRE_VERSION_MASK) != PTLRPC_MSG_VERSION) {\r\nCERROR("wrong lustre_msg version %08x\n", pb->pb_version);\r\nreturn -EINVAL;\r\n}\r\nif (!inout)\r\npb->pb_status = ptlrpc_status_ntoh(pb->pb_status);\r\nreturn 0;\r\n}\r\nint lustre_unpack_req_ptlrpc_body(struct ptlrpc_request *req, int offset)\r\n{\r\nswitch (req->rq_reqmsg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_unpack_ptlrpc_body_v2(req, 1, offset);\r\ndefault:\r\nCERROR("bad lustre msg magic: %08x\n",\r\nreq->rq_reqmsg->lm_magic);\r\nreturn -EINVAL;\r\n}\r\n}\r\nint lustre_unpack_rep_ptlrpc_body(struct ptlrpc_request *req, int offset)\r\n{\r\nswitch (req->rq_repmsg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_unpack_ptlrpc_body_v2(req, 0, offset);\r\ndefault:\r\nCERROR("bad lustre msg magic: %08x\n",\r\nreq->rq_repmsg->lm_magic);\r\nreturn -EINVAL;\r\n}\r\n}\r\nstatic inline u32 lustre_msg_buflen_v2(struct lustre_msg_v2 *m, u32 n)\r\n{\r\nif (n >= m->lm_bufcount)\r\nreturn 0;\r\nreturn m->lm_buflens[n];\r\n}\r\nu32 lustre_msg_buflen(struct lustre_msg *m, u32 n)\r\n{\r\nswitch (m->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_msg_buflen_v2(m, n);\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", m->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\nu32 lustre_msg_bufcount(struct lustre_msg *m)\r\n{\r\nswitch (m->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn m->lm_bufcount;\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", m->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\nchar *lustre_msg_string(struct lustre_msg *m, u32 index, u32 max_len)\r\n{\r\nchar *str;\r\nu32 slen, blen;\r\nswitch (m->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nstr = lustre_msg_buf_v2(m, index, 0);\r\nblen = lustre_msg_buflen_v2(m, index);\r\nbreak;\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", m->lm_magic);\r\n}\r\nif (!str) {\r\nCERROR("can't unpack string in msg %p buffer[%d]\n", m, index);\r\nreturn NULL;\r\n}\r\nslen = strnlen(str, blen);\r\nif (slen == blen) {\r\nCERROR("can't unpack non-NULL terminated string in msg %p buffer[%d] len %d\n",\r\nm, index, blen);\r\nreturn NULL;\r\n}\r\nif (max_len == 0) {\r\nif (slen != blen - 1) {\r\nCERROR("can't unpack short string in msg %p buffer[%d] len %d: strlen %d\n",\r\nm, index, blen, slen);\r\nreturn NULL;\r\n}\r\n} else if (slen > max_len) {\r\nCERROR("can't unpack oversized string in msg %p buffer[%d] len %d strlen %d: max %d expected\n",\r\nm, index, blen, slen, max_len);\r\nreturn NULL;\r\n}\r\nreturn str;\r\n}\r\nstatic inline void *__lustre_swab_buf(struct lustre_msg *msg, u32 index,\r\nu32 min_size, void *swabber)\r\n{\r\nvoid *ptr = NULL;\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nptr = lustre_msg_buf_v2(msg, index, min_size);\r\nbreak;\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\nif (ptr && swabber)\r\n((void (*)(void *))swabber)(ptr);\r\nreturn ptr;\r\n}\r\nstatic inline struct ptlrpc_body *lustre_msg_ptlrpc_body(struct lustre_msg *msg)\r\n{\r\nreturn lustre_msg_buf_v2(msg, MSG_PTLRPC_BODY_OFF,\r\nsizeof(struct ptlrpc_body_v2));\r\n}\r\n__u32 lustre_msghdr_get_flags(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn msg->lm_flags;\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\nvoid lustre_msghdr_set_flags(struct lustre_msg *msg, __u32 flags)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nmsg->lm_flags = flags;\r\nreturn;\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\n__u32 lustre_msg_get_flags(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (pb)\r\nreturn pb->pb_flags;\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid lustre_msg_add_flags(struct lustre_msg *msg, u32 flags)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_flags |= flags;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_flags(struct lustre_msg *msg, u32 flags)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_flags = flags;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_clear_flags(struct lustre_msg *msg, u32 flags)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_flags &= ~(flags & MSG_GEN_FLAG_MASK);\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\n__u32 lustre_msg_get_op_flags(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (pb)\r\nreturn pb->pb_op_flags;\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid lustre_msg_add_op_flags(struct lustre_msg *msg, u32 flags)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_op_flags |= flags;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nstruct lustre_handle *lustre_msg_get_handle(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn NULL;\r\n}\r\nreturn &pb->pb_handle;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn NULL;\r\n}\r\n}\r\n__u32 lustre_msg_get_type(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn PTL_RPC_MSG_ERR;\r\n}\r\nreturn pb->pb_type;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn PTL_RPC_MSG_ERR;\r\n}\r\n}\r\nvoid lustre_msg_add_version(struct lustre_msg *msg, u32 version)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_version |= version;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\n__u32 lustre_msg_get_opc(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_opc;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x (msg:%p)\n",\r\nmsg->lm_magic, msg);\r\nreturn 0;\r\n}\r\n}\r\n__u16 lustre_msg_get_tag(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_tag;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\n__u64 lustre_msg_get_last_committed(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_last_committed;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\n__u64 *lustre_msg_get_versions(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn NULL;\r\n}\r\nreturn pb->pb_pre_versions;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn NULL;\r\n}\r\n}\r\n__u64 lustre_msg_get_transno(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_transno;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\nint lustre_msg_get_status(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (pb)\r\nreturn pb->pb_status;\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\n}\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\n}\r\n__u64 lustre_msg_get_slv(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn -EINVAL;\r\n}\r\nreturn pb->pb_slv;\r\n}\r\ndefault:\r\nCERROR("invalid msg magic %08x\n", msg->lm_magic);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid lustre_msg_set_slv(struct lustre_msg *msg, __u64 slv)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn;\r\n}\r\npb->pb_slv = slv;\r\nreturn;\r\n}\r\ndefault:\r\nCERROR("invalid msg magic %x\n", msg->lm_magic);\r\nreturn;\r\n}\r\n}\r\n__u32 lustre_msg_get_limit(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn -EINVAL;\r\n}\r\nreturn pb->pb_limit;\r\n}\r\ndefault:\r\nCERROR("invalid msg magic %x\n", msg->lm_magic);\r\nreturn -EINVAL;\r\n}\r\n}\r\nvoid lustre_msg_set_limit(struct lustre_msg *msg, __u64 limit)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn;\r\n}\r\npb->pb_limit = limit;\r\nreturn;\r\n}\r\ndefault:\r\nCERROR("invalid msg magic %08x\n", msg->lm_magic);\r\nreturn;\r\n}\r\n}\r\n__u32 lustre_msg_get_conn_cnt(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_conn_cnt;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\n__u32 lustre_msg_get_magic(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn msg->lm_magic;\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\n__u32 lustre_msg_get_timeout(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_timeout;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn -EPROTO;\r\n}\r\n}\r\n__u32 lustre_msg_get_service_time(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nif (!pb) {\r\nCERROR("invalid msg %p: no ptlrpc body!\n", msg);\r\nreturn 0;\r\n}\r\nreturn pb->pb_service_time;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\n__u32 lustre_msg_get_cksum(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn msg->lm_cksum;\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\n__u32 lustre_msg_calc_cksum(struct lustre_msg *msg)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\n__u32 crc;\r\nunsigned int hsize = 4;\r\ncfs_crypto_hash_digest(CFS_HASH_ALG_CRC32, (unsigned char *)pb,\r\nlustre_msg_buflen(msg,\r\nMSG_PTLRPC_BODY_OFF),\r\nNULL, 0, (unsigned char *)&crc, &hsize);\r\nreturn crc;\r\n}\r\ndefault:\r\nCERROR("incorrect message magic: %08x\n", msg->lm_magic);\r\nreturn 0;\r\n}\r\n}\r\nvoid lustre_msg_set_handle(struct lustre_msg *msg, struct lustre_handle *handle)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_handle = *handle;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_type(struct lustre_msg *msg, __u32 type)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_type = type;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_opc(struct lustre_msg *msg, __u32 opc)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_opc = opc;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_last_xid(struct lustre_msg *msg, u64 last_xid)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_last_xid = last_xid;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_tag(struct lustre_msg *msg, __u16 tag)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_tag = tag;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_versions(struct lustre_msg *msg, __u64 *versions)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_pre_versions[0] = versions[0];\r\npb->pb_pre_versions[1] = versions[1];\r\npb->pb_pre_versions[2] = versions[2];\r\npb->pb_pre_versions[3] = versions[3];\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_transno(struct lustre_msg *msg, __u64 transno)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_transno = transno;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_status(struct lustre_msg *msg, __u32 status)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_status = status;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_conn_cnt(struct lustre_msg *msg, __u32 conn_cnt)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_conn_cnt = conn_cnt;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_timeout(struct lustre_msg *msg, __u32 timeout)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_timeout = timeout;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_service_time(struct lustre_msg *msg, __u32 service_time)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_service_time = service_time;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_jobid(struct lustre_msg *msg, char *jobid)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\n__u32 opc = lustre_msg_get_opc(msg);\r\nstruct ptlrpc_body *pb;\r\nif (!opc || opc == LDLM_BL_CALLBACK ||\r\nopc == LDLM_CP_CALLBACK || opc == LDLM_GL_CALLBACK)\r\nreturn;\r\npb = lustre_msg_buf_v2(msg, MSG_PTLRPC_BODY_OFF,\r\nsizeof(struct ptlrpc_body));\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\nif (jobid)\r\nmemcpy(pb->pb_jobid, jobid, LUSTRE_JOBID_SIZE);\r\nelse if (pb->pb_jobid[0] == '\0')\r\nlustre_get_jobid(pb->pb_jobid);\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_cksum(struct lustre_msg *msg, __u32 cksum)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nmsg->lm_cksum = cksum;\r\nreturn;\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid lustre_msg_set_mbits(struct lustre_msg *msg, __u64 mbits)\r\n{\r\nswitch (msg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2: {\r\nstruct ptlrpc_body *pb = lustre_msg_ptlrpc_body(msg);\r\nLASSERTF(pb, "invalid msg %p: no ptlrpc body!\n", msg);\r\npb->pb_mbits = mbits;\r\nreturn;\r\n}\r\ndefault:\r\nLASSERTF(0, "incorrect message magic: %08x\n", msg->lm_magic);\r\n}\r\n}\r\nvoid ptlrpc_request_set_replen(struct ptlrpc_request *req)\r\n{\r\nint count = req_capsule_filled_sizes(&req->rq_pill, RCL_SERVER);\r\nreq->rq_replen = lustre_msg_size(req->rq_reqmsg->lm_magic, count,\r\nreq->rq_pill.rc_area[RCL_SERVER]);\r\nif (req->rq_reqmsg->lm_magic == LUSTRE_MSG_MAGIC_V2)\r\nreq->rq_reqmsg->lm_repsize = req->rq_replen;\r\n}\r\nint do_set_info_async(struct obd_import *imp,\r\nint opcode, int version,\r\nu32 keylen, void *key,\r\nu32 vallen, void *val,\r\nstruct ptlrpc_request_set *set)\r\n{\r\nstruct ptlrpc_request *req;\r\nchar *tmp;\r\nint rc;\r\nreq = ptlrpc_request_alloc(imp, &RQF_OBD_SET_INFO);\r\nif (!req)\r\nreturn -ENOMEM;\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SETINFO_KEY,\r\nRCL_CLIENT, keylen);\r\nreq_capsule_set_size(&req->rq_pill, &RMF_SETINFO_VAL,\r\nRCL_CLIENT, vallen);\r\nrc = ptlrpc_request_pack(req, version, opcode);\r\nif (rc) {\r\nptlrpc_request_free(req);\r\nreturn rc;\r\n}\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_SETINFO_KEY);\r\nmemcpy(tmp, key, keylen);\r\ntmp = req_capsule_client_get(&req->rq_pill, &RMF_SETINFO_VAL);\r\nmemcpy(tmp, val, vallen);\r\nptlrpc_request_set_replen(req);\r\nif (set) {\r\nptlrpc_set_add_req(set, req);\r\nptlrpc_check_set(NULL, set);\r\n} else {\r\nrc = ptlrpc_queue_wait(req);\r\nptlrpc_req_finished(req);\r\n}\r\nreturn rc;\r\n}\r\nvoid lustre_swab_ptlrpc_body(struct ptlrpc_body *b)\r\n{\r\n__swab32s(&b->pb_type);\r\n__swab32s(&b->pb_version);\r\n__swab32s(&b->pb_opc);\r\n__swab32s(&b->pb_status);\r\n__swab64s(&b->pb_last_xid);\r\n__swab16s(&b->pb_tag);\r\n__swab64s(&b->pb_last_committed);\r\n__swab64s(&b->pb_transno);\r\n__swab32s(&b->pb_flags);\r\n__swab32s(&b->pb_op_flags);\r\n__swab32s(&b->pb_conn_cnt);\r\n__swab32s(&b->pb_timeout);\r\n__swab32s(&b->pb_service_time);\r\n__swab32s(&b->pb_limit);\r\n__swab64s(&b->pb_slv);\r\n__swab64s(&b->pb_pre_versions[0]);\r\n__swab64s(&b->pb_pre_versions[1]);\r\n__swab64s(&b->pb_pre_versions[2]);\r\n__swab64s(&b->pb_pre_versions[3]);\r\n__swab64s(&b->pb_mbits);\r\nBUILD_BUG_ON(offsetof(typeof(*b), pb_padding0) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*b), pb_padding1) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*b), pb_padding64_0) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*b), pb_padding64_1) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*b), pb_padding64_2) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*b), pb_jobid) == 0);\r\n}\r\nvoid lustre_swab_connect(struct obd_connect_data *ocd)\r\n{\r\n__swab64s(&ocd->ocd_connect_flags);\r\n__swab32s(&ocd->ocd_version);\r\n__swab32s(&ocd->ocd_grant);\r\n__swab64s(&ocd->ocd_ibits_known);\r\n__swab32s(&ocd->ocd_index);\r\n__swab32s(&ocd->ocd_brw_size);\r\n__swab16s(&ocd->ocd_grant_extent);\r\n__swab32s(&ocd->ocd_unused);\r\n__swab64s(&ocd->ocd_transno);\r\n__swab32s(&ocd->ocd_group);\r\n__swab32s(&ocd->ocd_cksum_types);\r\n__swab32s(&ocd->ocd_instance);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_MAX_EASIZE)\r\n__swab32s(&ocd->ocd_max_easize);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_MAXBYTES)\r\n__swab64s(&ocd->ocd_maxbytes);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_MULTIMODRPCS)\r\n__swab16s(&ocd->ocd_maxmodrpcs);\r\nBUILD_BUG_ON(!offsetof(typeof(*ocd), padding0));\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding1) == 0);\r\nif (ocd->ocd_connect_flags & OBD_CONNECT_FLAGS2)\r\n__swab64s(&ocd->ocd_connect_flags2);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding3) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding4) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding5) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding6) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding7) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding8) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), padding9) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), paddingA) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), paddingB) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), paddingC) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), paddingD) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), paddingE) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*ocd), paddingF) == 0);\r\n}\r\nstatic void lustre_swab_obdo(struct obdo *o)\r\n{\r\n__swab64s(&o->o_valid);\r\nlustre_swab_ost_id(&o->o_oi);\r\n__swab64s(&o->o_parent_seq);\r\n__swab64s(&o->o_size);\r\n__swab64s(&o->o_mtime);\r\n__swab64s(&o->o_atime);\r\n__swab64s(&o->o_ctime);\r\n__swab64s(&o->o_blocks);\r\n__swab64s(&o->o_grant);\r\n__swab32s(&o->o_blksize);\r\n__swab32s(&o->o_mode);\r\n__swab32s(&o->o_uid);\r\n__swab32s(&o->o_gid);\r\n__swab32s(&o->o_flags);\r\n__swab32s(&o->o_nlink);\r\n__swab32s(&o->o_parent_oid);\r\n__swab32s(&o->o_misc);\r\n__swab64s(&o->o_ioepoch);\r\n__swab32s(&o->o_stripe_idx);\r\n__swab32s(&o->o_parent_ver);\r\n__swab32s(&o->o_uid_h);\r\n__swab32s(&o->o_gid_h);\r\n__swab64s(&o->o_data_version);\r\nBUILD_BUG_ON(offsetof(typeof(*o), o_padding_4) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*o), o_padding_5) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*o), o_padding_6) == 0);\r\n}\r\nvoid lustre_swab_obd_statfs(struct obd_statfs *os)\r\n{\r\n__swab64s(&os->os_type);\r\n__swab64s(&os->os_blocks);\r\n__swab64s(&os->os_bfree);\r\n__swab64s(&os->os_bavail);\r\n__swab64s(&os->os_files);\r\n__swab64s(&os->os_ffree);\r\n__swab32s(&os->os_bsize);\r\n__swab32s(&os->os_namelen);\r\n__swab64s(&os->os_maxbytes);\r\n__swab32s(&os->os_state);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_fprecreated) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare2) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare3) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare4) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare5) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare6) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare7) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare8) == 0);\r\nBUILD_BUG_ON(offsetof(typeof(*os), os_spare9) == 0);\r\n}\r\nvoid lustre_swab_obd_ioobj(struct obd_ioobj *ioo)\r\n{\r\nlustre_swab_ost_id(&ioo->ioo_oid);\r\n__swab32s(&ioo->ioo_max_brw);\r\n__swab32s(&ioo->ioo_bufcnt);\r\n}\r\nvoid lustre_swab_niobuf_remote(struct niobuf_remote *nbr)\r\n{\r\n__swab64s(&nbr->rnb_offset);\r\n__swab32s(&nbr->rnb_len);\r\n__swab32s(&nbr->rnb_flags);\r\n}\r\nvoid lustre_swab_ost_body(struct ost_body *b)\r\n{\r\nlustre_swab_obdo(&b->oa);\r\n}\r\nvoid lustre_swab_ost_last_id(u64 *id)\r\n{\r\n__swab64s(id);\r\n}\r\nvoid lustre_swab_generic_32s(__u32 *val)\r\n{\r\n__swab32s(val);\r\n}\r\nvoid lustre_swab_gl_desc(union ldlm_gl_desc *desc)\r\n{\r\nlustre_swab_lu_fid(&desc->lquota_desc.gl_id.qid_fid);\r\n__swab64s(&desc->lquota_desc.gl_flags);\r\n__swab64s(&desc->lquota_desc.gl_ver);\r\n__swab64s(&desc->lquota_desc.gl_hardlimit);\r\n__swab64s(&desc->lquota_desc.gl_softlimit);\r\n__swab64s(&desc->lquota_desc.gl_time);\r\nBUILD_BUG_ON(offsetof(typeof(desc->lquota_desc), gl_pad2) == 0);\r\n}\r\nvoid lustre_swab_ost_lvb_v1(struct ost_lvb_v1 *lvb)\r\n{\r\n__swab64s(&lvb->lvb_size);\r\n__swab64s(&lvb->lvb_mtime);\r\n__swab64s(&lvb->lvb_atime);\r\n__swab64s(&lvb->lvb_ctime);\r\n__swab64s(&lvb->lvb_blocks);\r\n}\r\nvoid lustre_swab_ost_lvb(struct ost_lvb *lvb)\r\n{\r\n__swab64s(&lvb->lvb_size);\r\n__swab64s(&lvb->lvb_mtime);\r\n__swab64s(&lvb->lvb_atime);\r\n__swab64s(&lvb->lvb_ctime);\r\n__swab64s(&lvb->lvb_blocks);\r\n__swab32s(&lvb->lvb_mtime_ns);\r\n__swab32s(&lvb->lvb_atime_ns);\r\n__swab32s(&lvb->lvb_ctime_ns);\r\n__swab32s(&lvb->lvb_padding);\r\n}\r\nvoid lustre_swab_lquota_lvb(struct lquota_lvb *lvb)\r\n{\r\n__swab64s(&lvb->lvb_flags);\r\n__swab64s(&lvb->lvb_id_may_rel);\r\n__swab64s(&lvb->lvb_id_rel);\r\n__swab64s(&lvb->lvb_id_qunit);\r\n__swab64s(&lvb->lvb_pad1);\r\n}\r\nvoid lustre_swab_mdt_body(struct mdt_body *b)\r\n{\r\nlustre_swab_lu_fid(&b->mbo_fid1);\r\nlustre_swab_lu_fid(&b->mbo_fid2);\r\n__swab64s(&b->mbo_valid);\r\n__swab64s(&b->mbo_size);\r\n__swab64s(&b->mbo_mtime);\r\n__swab64s(&b->mbo_atime);\r\n__swab64s(&b->mbo_ctime);\r\n__swab64s(&b->mbo_blocks);\r\n__swab64s(&b->mbo_ioepoch);\r\n__swab64s(&b->mbo_t_state);\r\n__swab32s(&b->mbo_fsuid);\r\n__swab32s(&b->mbo_fsgid);\r\n__swab32s(&b->mbo_capability);\r\n__swab32s(&b->mbo_mode);\r\n__swab32s(&b->mbo_uid);\r\n__swab32s(&b->mbo_gid);\r\n__swab32s(&b->mbo_flags);\r\n__swab32s(&b->mbo_rdev);\r\n__swab32s(&b->mbo_nlink);\r\nBUILD_BUG_ON(offsetof(typeof(*b), mbo_unused2) == 0);\r\n__swab32s(&b->mbo_suppgid);\r\n__swab32s(&b->mbo_eadatasize);\r\n__swab32s(&b->mbo_aclsize);\r\n__swab32s(&b->mbo_max_mdsize);\r\nBUILD_BUG_ON(!offsetof(typeof(*b), mbo_unused3));\r\n__swab32s(&b->mbo_uid_h);\r\n__swab32s(&b->mbo_gid_h);\r\nBUILD_BUG_ON(offsetof(typeof(*b), mbo_padding_5) == 0);\r\n}\r\nvoid lustre_swab_mdt_ioepoch(struct mdt_ioepoch *b)\r\n{\r\nBUILD_BUG_ON(!offsetof(typeof(*b), mio_unused1));\r\nBUILD_BUG_ON(!offsetof(typeof(*b), mio_unused2));\r\nBUILD_BUG_ON(!offsetof(typeof(*b), mio_padding));\r\n}\r\nvoid lustre_swab_mgs_target_info(struct mgs_target_info *mti)\r\n{\r\nint i;\r\n__swab32s(&mti->mti_lustre_ver);\r\n__swab32s(&mti->mti_stripe_index);\r\n__swab32s(&mti->mti_config_ver);\r\n__swab32s(&mti->mti_flags);\r\n__swab32s(&mti->mti_instance);\r\n__swab32s(&mti->mti_nid_count);\r\nBUILD_BUG_ON(sizeof(lnet_nid_t) != sizeof(__u64));\r\nfor (i = 0; i < MTI_NIDS_MAX; i++)\r\n__swab64s(&mti->mti_nids[i]);\r\n}\r\nvoid lustre_swab_mgs_nidtbl_entry(struct mgs_nidtbl_entry *entry)\r\n{\r\n__u8 i;\r\n__swab64s(&entry->mne_version);\r\n__swab32s(&entry->mne_instance);\r\n__swab32s(&entry->mne_index);\r\n__swab32s(&entry->mne_length);\r\nBUILD_BUG_ON(sizeof(entry->mne_nid_count) != sizeof(__u8));\r\nBUILD_BUG_ON(sizeof(entry->mne_nid_type) != sizeof(__u8));\r\nLASSERT(entry->mne_nid_type == 0);\r\nfor (i = 0; i < entry->mne_nid_count; i++) {\r\nBUILD_BUG_ON(sizeof(lnet_nid_t) != sizeof(__u64));\r\n__swab64s(&entry->u.nids[i]);\r\n}\r\n}\r\nvoid lustre_swab_mgs_config_body(struct mgs_config_body *body)\r\n{\r\n__swab64s(&body->mcb_offset);\r\n__swab32s(&body->mcb_units);\r\n__swab16s(&body->mcb_type);\r\n}\r\nvoid lustre_swab_mgs_config_res(struct mgs_config_res *body)\r\n{\r\n__swab64s(&body->mcr_offset);\r\n__swab64s(&body->mcr_size);\r\n}\r\nstatic void lustre_swab_obd_dqinfo(struct obd_dqinfo *i)\r\n{\r\n__swab64s(&i->dqi_bgrace);\r\n__swab64s(&i->dqi_igrace);\r\n__swab32s(&i->dqi_flags);\r\n__swab32s(&i->dqi_valid);\r\n}\r\nstatic void lustre_swab_obd_dqblk(struct obd_dqblk *b)\r\n{\r\n__swab64s(&b->dqb_ihardlimit);\r\n__swab64s(&b->dqb_isoftlimit);\r\n__swab64s(&b->dqb_curinodes);\r\n__swab64s(&b->dqb_bhardlimit);\r\n__swab64s(&b->dqb_bsoftlimit);\r\n__swab64s(&b->dqb_curspace);\r\n__swab64s(&b->dqb_btime);\r\n__swab64s(&b->dqb_itime);\r\n__swab32s(&b->dqb_valid);\r\nBUILD_BUG_ON(offsetof(typeof(*b), dqb_padding) == 0);\r\n}\r\nvoid lustre_swab_obd_quotactl(struct obd_quotactl *q)\r\n{\r\n__swab32s(&q->qc_cmd);\r\n__swab32s(&q->qc_type);\r\n__swab32s(&q->qc_id);\r\n__swab32s(&q->qc_stat);\r\nlustre_swab_obd_dqinfo(&q->qc_dqinfo);\r\nlustre_swab_obd_dqblk(&q->qc_dqblk);\r\n}\r\nvoid lustre_swab_fid2path(struct getinfo_fid2path *gf)\r\n{\r\nlustre_swab_lu_fid(&gf->gf_fid);\r\n__swab64s(&gf->gf_recno);\r\n__swab32s(&gf->gf_linkno);\r\n__swab32s(&gf->gf_pathlen);\r\n}\r\nstatic void lustre_swab_fiemap_extent(struct fiemap_extent *fm_extent)\r\n{\r\n__swab64s(&fm_extent->fe_logical);\r\n__swab64s(&fm_extent->fe_physical);\r\n__swab64s(&fm_extent->fe_length);\r\n__swab32s(&fm_extent->fe_flags);\r\n__swab32s(&fm_extent->fe_device);\r\n}\r\nvoid lustre_swab_fiemap(struct fiemap *fiemap)\r\n{\r\n__u32 i;\r\n__swab64s(&fiemap->fm_start);\r\n__swab64s(&fiemap->fm_length);\r\n__swab32s(&fiemap->fm_flags);\r\n__swab32s(&fiemap->fm_mapped_extents);\r\n__swab32s(&fiemap->fm_extent_count);\r\n__swab32s(&fiemap->fm_reserved);\r\nfor (i = 0; i < fiemap->fm_mapped_extents; i++)\r\nlustre_swab_fiemap_extent(&fiemap->fm_extents[i]);\r\n}\r\nvoid lustre_swab_mdt_rec_reint (struct mdt_rec_reint *rr)\r\n{\r\n__swab32s(&rr->rr_opcode);\r\n__swab32s(&rr->rr_cap);\r\n__swab32s(&rr->rr_fsuid);\r\n__swab32s(&rr->rr_fsgid);\r\n__swab32s(&rr->rr_suppgid1);\r\n__swab32s(&rr->rr_suppgid2);\r\nlustre_swab_lu_fid(&rr->rr_fid1);\r\nlustre_swab_lu_fid(&rr->rr_fid2);\r\n__swab64s(&rr->rr_mtime);\r\n__swab64s(&rr->rr_atime);\r\n__swab64s(&rr->rr_ctime);\r\n__swab64s(&rr->rr_size);\r\n__swab64s(&rr->rr_blocks);\r\n__swab32s(&rr->rr_bias);\r\n__swab32s(&rr->rr_mode);\r\n__swab32s(&rr->rr_flags);\r\n__swab32s(&rr->rr_flags_h);\r\n__swab32s(&rr->rr_umask);\r\nBUILD_BUG_ON(offsetof(typeof(*rr), rr_padding_4) == 0);\r\n}\r\nvoid lustre_swab_lov_desc(struct lov_desc *ld)\r\n{\r\n__swab32s(&ld->ld_tgt_count);\r\n__swab32s(&ld->ld_active_tgt_count);\r\n__swab32s(&ld->ld_default_stripe_count);\r\n__swab32s(&ld->ld_pattern);\r\n__swab64s(&ld->ld_default_stripe_size);\r\n__swab64s(&ld->ld_default_stripe_offset);\r\n__swab32s(&ld->ld_qos_maxage);\r\n}\r\nstatic void lustre_swab_lmv_mds_md_v1(struct lmv_mds_md_v1 *lmm1)\r\n{\r\nint i;\r\n__swab32s(&lmm1->lmv_magic);\r\n__swab32s(&lmm1->lmv_stripe_count);\r\n__swab32s(&lmm1->lmv_master_mdt_index);\r\n__swab32s(&lmm1->lmv_hash_type);\r\n__swab32s(&lmm1->lmv_layout_version);\r\nfor (i = 0; i < lmm1->lmv_stripe_count; i++)\r\nlustre_swab_lu_fid(&lmm1->lmv_stripe_fids[i]);\r\n}\r\nvoid lustre_swab_lmv_mds_md(union lmv_mds_md *lmm)\r\n{\r\nswitch (lmm->lmv_magic) {\r\ncase LMV_MAGIC_V1:\r\nlustre_swab_lmv_mds_md_v1(&lmm->lmv_md_v1);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nvoid lustre_swab_lmv_user_md(struct lmv_user_md *lum)\r\n{\r\n__swab32s(&lum->lum_magic);\r\n__swab32s(&lum->lum_stripe_count);\r\n__swab32s(&lum->lum_stripe_offset);\r\n__swab32s(&lum->lum_hash_type);\r\n__swab32s(&lum->lum_type);\r\nBUILD_BUG_ON(!offsetof(typeof(*lum), lum_padding1));\r\n}\r\nstatic void lustre_swab_lmm_oi(struct ost_id *oi)\r\n{\r\n__swab64s(&oi->oi.oi_id);\r\n__swab64s(&oi->oi.oi_seq);\r\n}\r\nstatic void lustre_swab_lov_user_md_common(struct lov_user_md_v1 *lum)\r\n{\r\n__swab32s(&lum->lmm_magic);\r\n__swab32s(&lum->lmm_pattern);\r\nlustre_swab_lmm_oi(&lum->lmm_oi);\r\n__swab32s(&lum->lmm_stripe_size);\r\n__swab16s(&lum->lmm_stripe_count);\r\n__swab16s(&lum->lmm_stripe_offset);\r\n}\r\nvoid lustre_swab_lov_user_md_v1(struct lov_user_md_v1 *lum)\r\n{\r\nCDEBUG(D_IOCTL, "swabbing lov_user_md v1\n");\r\nlustre_swab_lov_user_md_common(lum);\r\n}\r\nvoid lustre_swab_lov_user_md_v3(struct lov_user_md_v3 *lum)\r\n{\r\nCDEBUG(D_IOCTL, "swabbing lov_user_md v3\n");\r\nlustre_swab_lov_user_md_common((struct lov_user_md_v1 *)lum);\r\n}\r\nvoid lustre_swab_lov_mds_md(struct lov_mds_md *lmm)\r\n{\r\nCDEBUG(D_IOCTL, "swabbing lov_mds_md\n");\r\n__swab32s(&lmm->lmm_magic);\r\n__swab32s(&lmm->lmm_pattern);\r\nlustre_swab_lmm_oi(&lmm->lmm_oi);\r\n__swab32s(&lmm->lmm_stripe_size);\r\n__swab16s(&lmm->lmm_stripe_count);\r\n__swab16s(&lmm->lmm_layout_gen);\r\n}\r\nvoid lustre_swab_lov_user_md_objects(struct lov_user_ost_data *lod,\r\nint stripe_count)\r\n{\r\nint i;\r\nfor (i = 0; i < stripe_count; i++) {\r\nlustre_swab_ost_id(&lod[i].l_ost_oi);\r\n__swab32s(&lod[i].l_ost_gen);\r\n__swab32s(&lod[i].l_ost_idx);\r\n}\r\n}\r\nstatic void lustre_swab_ldlm_res_id(struct ldlm_res_id *id)\r\n{\r\nint i;\r\nfor (i = 0; i < RES_NAME_SIZE; i++)\r\n__swab64s(&id->name[i]);\r\n}\r\nstatic void lustre_swab_ldlm_policy_data(union ldlm_wire_policy_data *d)\r\n{\r\n__swab64s(&d->l_extent.start);\r\n__swab64s(&d->l_extent.end);\r\n__swab64s(&d->l_extent.gid);\r\n__swab64s(&d->l_flock.lfw_owner);\r\n__swab32s(&d->l_flock.lfw_pid);\r\n}\r\nvoid lustre_swab_ldlm_intent(struct ldlm_intent *i)\r\n{\r\n__swab64s(&i->opc);\r\n}\r\nstatic void lustre_swab_ldlm_resource_desc(struct ldlm_resource_desc *r)\r\n{\r\n__swab32s(&r->lr_type);\r\nBUILD_BUG_ON(offsetof(typeof(*r), lr_padding) == 0);\r\nlustre_swab_ldlm_res_id(&r->lr_name);\r\n}\r\nstatic void lustre_swab_ldlm_lock_desc(struct ldlm_lock_desc *l)\r\n{\r\nlustre_swab_ldlm_resource_desc(&l->l_resource);\r\n__swab32s(&l->l_req_mode);\r\n__swab32s(&l->l_granted_mode);\r\nlustre_swab_ldlm_policy_data(&l->l_policy_data);\r\n}\r\nvoid lustre_swab_ldlm_request(struct ldlm_request *rq)\r\n{\r\n__swab32s(&rq->lock_flags);\r\nlustre_swab_ldlm_lock_desc(&rq->lock_desc);\r\n__swab32s(&rq->lock_count);\r\n}\r\nvoid lustre_swab_ldlm_reply(struct ldlm_reply *r)\r\n{\r\n__swab32s(&r->lock_flags);\r\nBUILD_BUG_ON(offsetof(typeof(*r), lock_padding) == 0);\r\nlustre_swab_ldlm_lock_desc(&r->lock_desc);\r\n__swab64s(&r->lock_policy_res1);\r\n__swab64s(&r->lock_policy_res2);\r\n}\r\nvoid dump_ioo(struct obd_ioobj *ioo)\r\n{\r\nCDEBUG(D_RPCTRACE,\r\n"obd_ioobj: ioo_oid=" DOSTID ", ioo_max_brw=%#x, ioo_bufct=%d\n",\r\nPOSTID(&ioo->ioo_oid), ioo->ioo_max_brw,\r\nioo->ioo_bufcnt);\r\n}\r\nvoid dump_rniobuf(struct niobuf_remote *nb)\r\n{\r\nCDEBUG(D_RPCTRACE, "niobuf_remote: offset=%llu, len=%d, flags=%x\n",\r\nnb->rnb_offset, nb->rnb_len, nb->rnb_flags);\r\n}\r\nstatic void dump_obdo(struct obdo *oa)\r\n{\r\n__u32 valid = oa->o_valid;\r\nCDEBUG(D_RPCTRACE, "obdo: o_valid = %08x\n", valid);\r\nif (valid & OBD_MD_FLID)\r\nCDEBUG(D_RPCTRACE, "obdo: id = "DOSTID"\n", POSTID(&oa->o_oi));\r\nif (valid & OBD_MD_FLFID)\r\nCDEBUG(D_RPCTRACE, "obdo: o_parent_seq = %#llx\n",\r\noa->o_parent_seq);\r\nif (valid & OBD_MD_FLSIZE)\r\nCDEBUG(D_RPCTRACE, "obdo: o_size = %lld\n", oa->o_size);\r\nif (valid & OBD_MD_FLMTIME)\r\nCDEBUG(D_RPCTRACE, "obdo: o_mtime = %lld\n", oa->o_mtime);\r\nif (valid & OBD_MD_FLATIME)\r\nCDEBUG(D_RPCTRACE, "obdo: o_atime = %lld\n", oa->o_atime);\r\nif (valid & OBD_MD_FLCTIME)\r\nCDEBUG(D_RPCTRACE, "obdo: o_ctime = %lld\n", oa->o_ctime);\r\nif (valid & OBD_MD_FLBLOCKS)\r\nCDEBUG(D_RPCTRACE, "obdo: o_blocks = %lld\n", oa->o_blocks);\r\nif (valid & OBD_MD_FLGRANT)\r\nCDEBUG(D_RPCTRACE, "obdo: o_grant = %lld\n", oa->o_grant);\r\nif (valid & OBD_MD_FLBLKSZ)\r\nCDEBUG(D_RPCTRACE, "obdo: o_blksize = %d\n", oa->o_blksize);\r\nif (valid & (OBD_MD_FLTYPE | OBD_MD_FLMODE))\r\nCDEBUG(D_RPCTRACE, "obdo: o_mode = %o\n",\r\noa->o_mode & ((valid & OBD_MD_FLTYPE ? S_IFMT : 0) |\r\n(valid & OBD_MD_FLMODE ? ~S_IFMT : 0)));\r\nif (valid & OBD_MD_FLUID)\r\nCDEBUG(D_RPCTRACE, "obdo: o_uid = %u\n", oa->o_uid);\r\nif (valid & OBD_MD_FLUID)\r\nCDEBUG(D_RPCTRACE, "obdo: o_uid_h = %u\n", oa->o_uid_h);\r\nif (valid & OBD_MD_FLGID)\r\nCDEBUG(D_RPCTRACE, "obdo: o_gid = %u\n", oa->o_gid);\r\nif (valid & OBD_MD_FLGID)\r\nCDEBUG(D_RPCTRACE, "obdo: o_gid_h = %u\n", oa->o_gid_h);\r\nif (valid & OBD_MD_FLFLAGS)\r\nCDEBUG(D_RPCTRACE, "obdo: o_flags = %x\n", oa->o_flags);\r\nif (valid & OBD_MD_FLNLINK)\r\nCDEBUG(D_RPCTRACE, "obdo: o_nlink = %u\n", oa->o_nlink);\r\nelse if (valid & OBD_MD_FLCKSUM)\r\nCDEBUG(D_RPCTRACE, "obdo: o_checksum (o_nlink) = %u\n",\r\noa->o_nlink);\r\nif (valid & OBD_MD_FLGENER)\r\nCDEBUG(D_RPCTRACE, "obdo: o_parent_oid = %x\n",\r\noa->o_parent_oid);\r\nif (valid & OBD_MD_FLEPOCH)\r\nCDEBUG(D_RPCTRACE, "obdo: o_ioepoch = %lld\n",\r\noa->o_ioepoch);\r\nif (valid & OBD_MD_FLFID) {\r\nCDEBUG(D_RPCTRACE, "obdo: o_stripe_idx = %u\n",\r\noa->o_stripe_idx);\r\nCDEBUG(D_RPCTRACE, "obdo: o_parent_ver = %x\n",\r\noa->o_parent_ver);\r\n}\r\nif (valid & OBD_MD_FLHANDLE)\r\nCDEBUG(D_RPCTRACE, "obdo: o_handle = %lld\n",\r\noa->o_handle.cookie);\r\n}\r\nvoid dump_ost_body(struct ost_body *ob)\r\n{\r\ndump_obdo(&ob->oa);\r\n}\r\nvoid dump_rcs(__u32 *rc)\r\n{\r\nCDEBUG(D_RPCTRACE, "rmf_rcs: %d\n", *rc);\r\n}\r\nstatic inline int req_ptlrpc_body_swabbed(struct ptlrpc_request *req)\r\n{\r\nLASSERT(req->rq_reqmsg);\r\nswitch (req->rq_reqmsg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_req_swabbed(req, MSG_PTLRPC_BODY_OFF);\r\ndefault:\r\nCERROR("bad lustre msg magic: %#08X\n",\r\nreq->rq_reqmsg->lm_magic);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int rep_ptlrpc_body_swabbed(struct ptlrpc_request *req)\r\n{\r\nLASSERT(req->rq_repmsg);\r\nswitch (req->rq_repmsg->lm_magic) {\r\ncase LUSTRE_MSG_MAGIC_V2:\r\nreturn lustre_rep_swabbed(req, MSG_PTLRPC_BODY_OFF);\r\ndefault:\r\nreturn 0;\r\n}\r\n}\r\nvoid _debug_req(struct ptlrpc_request *req,\r\nstruct libcfs_debug_msg_data *msgdata,\r\nconst char *fmt, ...)\r\n{\r\nint req_ok = req->rq_reqmsg != NULL;\r\nint rep_ok = req->rq_repmsg != NULL;\r\nlnet_nid_t nid = LNET_NID_ANY;\r\nva_list args;\r\nif (ptlrpc_req_need_swab(req)) {\r\nreq_ok = req_ok && req_ptlrpc_body_swabbed(req);\r\nrep_ok = rep_ok && rep_ptlrpc_body_swabbed(req);\r\n}\r\nif (req->rq_import && req->rq_import->imp_connection)\r\nnid = req->rq_import->imp_connection->c_peer.nid;\r\nelse if (req->rq_export && req->rq_export->exp_connection)\r\nnid = req->rq_export->exp_connection->c_peer.nid;\r\nva_start(args, fmt);\r\nlibcfs_debug_vmsg2(msgdata, fmt, args,\r\n" req@%p x%llu/t%lld(%lld) o%d->%s@%s:%d/%d lens %d/%d e %d to %lld dl %lld ref %d fl " REQ_FLAGS_FMT "/%x/%x rc %d/%d\n",\r\nreq, req->rq_xid, req->rq_transno,\r\nreq_ok ? lustre_msg_get_transno(req->rq_reqmsg) : 0,\r\nreq_ok ? lustre_msg_get_opc(req->rq_reqmsg) : -1,\r\nreq->rq_import ?\r\nreq->rq_import->imp_obd->obd_name :\r\nreq->rq_export ?\r\nreq->rq_export->exp_client_uuid.uuid :\r\n"<?>",\r\nlibcfs_nid2str(nid),\r\nreq->rq_request_portal, req->rq_reply_portal,\r\nreq->rq_reqlen, req->rq_replen,\r\nreq->rq_early_count, (s64)req->rq_timedout,\r\n(s64)req->rq_deadline,\r\natomic_read(&req->rq_refcount),\r\nDEBUG_REQ_FLAGS(req),\r\nreq_ok ? lustre_msg_get_flags(req->rq_reqmsg) : -1,\r\nrep_ok ? lustre_msg_get_flags(req->rq_repmsg) : -1,\r\nreq->rq_status,\r\nrep_ok ? lustre_msg_get_status(req->rq_repmsg) : -1);\r\nva_end(args);\r\n}\r\nvoid lustre_swab_lustre_capa(struct lustre_capa *c)\r\n{\r\nlustre_swab_lu_fid(&c->lc_fid);\r\n__swab64s(&c->lc_opc);\r\n__swab64s(&c->lc_uid);\r\n__swab64s(&c->lc_gid);\r\n__swab32s(&c->lc_flags);\r\n__swab32s(&c->lc_keyid);\r\n__swab32s(&c->lc_timeout);\r\n__swab32s(&c->lc_expiry);\r\n}\r\nvoid lustre_swab_hsm_user_state(struct hsm_user_state *state)\r\n{\r\n__swab32s(&state->hus_states);\r\n__swab32s(&state->hus_archive_id);\r\n}\r\nvoid lustre_swab_hsm_state_set(struct hsm_state_set *hss)\r\n{\r\n__swab32s(&hss->hss_valid);\r\n__swab64s(&hss->hss_setmask);\r\n__swab64s(&hss->hss_clearmask);\r\n__swab32s(&hss->hss_archive_id);\r\n}\r\nstatic void lustre_swab_hsm_extent(struct hsm_extent *extent)\r\n{\r\n__swab64s(&extent->offset);\r\n__swab64s(&extent->length);\r\n}\r\nvoid lustre_swab_hsm_current_action(struct hsm_current_action *action)\r\n{\r\n__swab32s(&action->hca_state);\r\n__swab32s(&action->hca_action);\r\nlustre_swab_hsm_extent(&action->hca_location);\r\n}\r\nvoid lustre_swab_hsm_user_item(struct hsm_user_item *hui)\r\n{\r\nlustre_swab_lu_fid(&hui->hui_fid);\r\nlustre_swab_hsm_extent(&hui->hui_extent);\r\n}\r\nvoid lustre_swab_layout_intent(struct layout_intent *li)\r\n{\r\n__swab32s(&li->li_opc);\r\n__swab32s(&li->li_flags);\r\n__swab64s(&li->li_start);\r\n__swab64s(&li->li_end);\r\n}\r\nvoid lustre_swab_hsm_progress_kernel(struct hsm_progress_kernel *hpk)\r\n{\r\nlustre_swab_lu_fid(&hpk->hpk_fid);\r\n__swab64s(&hpk->hpk_cookie);\r\n__swab64s(&hpk->hpk_extent.offset);\r\n__swab64s(&hpk->hpk_extent.length);\r\n__swab16s(&hpk->hpk_flags);\r\n__swab16s(&hpk->hpk_errval);\r\n}\r\nvoid lustre_swab_hsm_request(struct hsm_request *hr)\r\n{\r\n__swab32s(&hr->hr_action);\r\n__swab32s(&hr->hr_archive_id);\r\n__swab64s(&hr->hr_flags);\r\n__swab32s(&hr->hr_itemcount);\r\n__swab32s(&hr->hr_data_len);\r\n}\r\nvoid lustre_swab_swap_layouts(struct mdc_swap_layouts *msl)\r\n{\r\n__swab64s(&msl->msl_flags);\r\n}\r\nvoid lustre_swab_close_data(struct close_data *cd)\r\n{\r\nlustre_swab_lu_fid(&cd->cd_fid);\r\n__swab64s(&cd->cd_data_version);\r\n}
