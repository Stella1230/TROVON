static int __init dma_init(void)\r\n{\r\ndma_debug_init(PREALLOC_DMA_DEBUG_ENTRIES);\r\nreturn 0;\r\n}\r\nvoid *dma_generic_alloc_coherent(struct device *dev, size_t size,\r\ndma_addr_t *dma_handle, gfp_t gfp,\r\nunsigned long attrs)\r\n{\r\nvoid *ret, *ret_nocache;\r\nint order = get_order(size);\r\ngfp |= __GFP_ZERO;\r\nret = (void *)__get_free_pages(gfp, order);\r\nif (!ret)\r\nreturn NULL;\r\ndma_cache_sync(dev, ret, size, DMA_BIDIRECTIONAL);\r\nret_nocache = (void __force *)ioremap_nocache(virt_to_phys(ret), size);\r\nif (!ret_nocache) {\r\nfree_pages((unsigned long)ret, order);\r\nreturn NULL;\r\n}\r\nsplit_page(pfn_to_page(virt_to_phys(ret) >> PAGE_SHIFT), order);\r\n*dma_handle = virt_to_phys(ret);\r\nreturn ret_nocache;\r\n}\r\nvoid dma_generic_free_coherent(struct device *dev, size_t size,\r\nvoid *vaddr, dma_addr_t dma_handle,\r\nunsigned long attrs)\r\n{\r\nint order = get_order(size);\r\nunsigned long pfn = dma_handle >> PAGE_SHIFT;\r\nint k;\r\nfor (k = 0; k < (1 << order); k++)\r\n__free_pages(pfn_to_page(pfn + k), 0);\r\niounmap(vaddr);\r\n}\r\nvoid dma_cache_sync(struct device *dev, void *vaddr, size_t size,\r\nenum dma_data_direction direction)\r\n{\r\nvoid *addr;\r\naddr = __in_29bit_mode() ?\r\n(void *)CAC_ADDR((unsigned long)vaddr) : vaddr;\r\nswitch (direction) {\r\ncase DMA_FROM_DEVICE:\r\n__flush_invalidate_region(addr, size);\r\nbreak;\r\ncase DMA_TO_DEVICE:\r\n__flush_wback_region(addr, size);\r\nbreak;\r\ncase DMA_BIDIRECTIONAL:\r\n__flush_purge_region(addr, size);\r\nbreak;\r\ndefault:\r\nBUG();\r\n}\r\n}\r\nstatic int __init memchunk_setup(char *str)\r\n{\r\nreturn 1;\r\n}\r\nstatic void __init memchunk_cmdline_override(char *name, unsigned long *sizep)\r\n{\r\nchar *p = boot_command_line;\r\nint k = strlen(name);\r\nwhile ((p = strstr(p, "memchunk."))) {\r\np += 9;\r\nif (!strncmp(name, p, k) && p[k] == '=') {\r\np += k + 1;\r\n*sizep = memparse(p, NULL);\r\npr_info("%s: forcing memory chunk size to 0x%08lx\n",\r\nname, *sizep);\r\nbreak;\r\n}\r\n}\r\n}\r\nint __init platform_resource_setup_memory(struct platform_device *pdev,\r\nchar *name, unsigned long memsize)\r\n{\r\nstruct resource *r;\r\ndma_addr_t dma_handle;\r\nvoid *buf;\r\nr = pdev->resource + pdev->num_resources - 1;\r\nif (r->flags) {\r\npr_warning("%s: unable to find empty space for resource\n",\r\nname);\r\nreturn -EINVAL;\r\n}\r\nmemchunk_cmdline_override(name, &memsize);\r\nif (!memsize)\r\nreturn 0;\r\nbuf = dma_alloc_coherent(NULL, memsize, &dma_handle, GFP_KERNEL);\r\nif (!buf) {\r\npr_warning("%s: unable to allocate memory\n", name);\r\nreturn -ENOMEM;\r\n}\r\nmemset(buf, 0, memsize);\r\nr->flags = IORESOURCE_MEM;\r\nr->start = dma_handle;\r\nr->end = r->start + memsize - 1;\r\nr->name = name;\r\nreturn 0;\r\n}
