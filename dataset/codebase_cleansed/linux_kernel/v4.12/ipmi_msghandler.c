const char *ipmi_addr_src_to_str(enum ipmi_addr_src src)\r\n{\r\nif (src >= SI_LAST)\r\nsrc = 0;\r\nreturn addr_src_to_str[src];\r\n}\r\nstatic int is_lan_addr(struct ipmi_addr *addr)\r\n{\r\nreturn addr->addr_type == IPMI_LAN_ADDR_TYPE;\r\n}\r\nstatic int is_ipmb_addr(struct ipmi_addr *addr)\r\n{\r\nreturn addr->addr_type == IPMI_IPMB_ADDR_TYPE;\r\n}\r\nstatic int is_ipmb_bcast_addr(struct ipmi_addr *addr)\r\n{\r\nreturn addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE;\r\n}\r\nstatic void free_recv_msg_list(struct list_head *q)\r\n{\r\nstruct ipmi_recv_msg *msg, *msg2;\r\nlist_for_each_entry_safe(msg, msg2, q, link) {\r\nlist_del(&msg->link);\r\nipmi_free_recv_msg(msg);\r\n}\r\n}\r\nstatic void free_smi_msg_list(struct list_head *q)\r\n{\r\nstruct ipmi_smi_msg *msg, *msg2;\r\nlist_for_each_entry_safe(msg, msg2, q, link) {\r\nlist_del(&msg->link);\r\nipmi_free_smi_msg(msg);\r\n}\r\n}\r\nstatic void clean_up_interface_data(ipmi_smi_t intf)\r\n{\r\nint i;\r\nstruct cmd_rcvr *rcvr, *rcvr2;\r\nstruct list_head list;\r\ntasklet_kill(&intf->recv_tasklet);\r\nfree_smi_msg_list(&intf->waiting_rcv_msgs);\r\nfree_recv_msg_list(&intf->waiting_events);\r\nmutex_lock(&intf->cmd_rcvrs_mutex);\r\nINIT_LIST_HEAD(&list);\r\nlist_splice_init_rcu(&intf->cmd_rcvrs, &list, synchronize_rcu);\r\nmutex_unlock(&intf->cmd_rcvrs_mutex);\r\nlist_for_each_entry_safe(rcvr, rcvr2, &list, link)\r\nkfree(rcvr);\r\nfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\r\nif ((intf->seq_table[i].inuse)\r\n&& (intf->seq_table[i].recv_msg))\r\nipmi_free_recv_msg(intf->seq_table[i].recv_msg);\r\n}\r\n}\r\nstatic void intf_free(struct kref *ref)\r\n{\r\nipmi_smi_t intf = container_of(ref, struct ipmi_smi, refcount);\r\nclean_up_interface_data(intf);\r\nkfree(intf);\r\n}\r\nint ipmi_smi_watcher_register(struct ipmi_smi_watcher *watcher)\r\n{\r\nipmi_smi_t intf;\r\nLIST_HEAD(to_deliver);\r\nstruct watcher_entry *e, *e2;\r\nmutex_lock(&smi_watchers_mutex);\r\nmutex_lock(&ipmi_interfaces_mutex);\r\nlist_for_each_entry(intf, &ipmi_interfaces, link) {\r\nif (intf->intf_num == -1)\r\ncontinue;\r\ne = kmalloc(sizeof(*e), GFP_KERNEL);\r\nif (!e)\r\ngoto out_err;\r\nkref_get(&intf->refcount);\r\ne->intf = intf;\r\ne->intf_num = intf->intf_num;\r\nlist_add_tail(&e->link, &to_deliver);\r\n}\r\nlist_add(&watcher->link, &smi_watchers);\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nlist_for_each_entry_safe(e, e2, &to_deliver, link) {\r\nlist_del(&e->link);\r\nwatcher->new_smi(e->intf_num, e->intf->si_dev);\r\nkref_put(&e->intf->refcount, intf_free);\r\nkfree(e);\r\n}\r\nmutex_unlock(&smi_watchers_mutex);\r\nreturn 0;\r\nout_err:\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nmutex_unlock(&smi_watchers_mutex);\r\nlist_for_each_entry_safe(e, e2, &to_deliver, link) {\r\nlist_del(&e->link);\r\nkref_put(&e->intf->refcount, intf_free);\r\nkfree(e);\r\n}\r\nreturn -ENOMEM;\r\n}\r\nint ipmi_smi_watcher_unregister(struct ipmi_smi_watcher *watcher)\r\n{\r\nmutex_lock(&smi_watchers_mutex);\r\nlist_del(&(watcher->link));\r\nmutex_unlock(&smi_watchers_mutex);\r\nreturn 0;\r\n}\r\nstatic void\r\ncall_smi_watchers(int i, struct device *dev)\r\n{\r\nstruct ipmi_smi_watcher *w;\r\nlist_for_each_entry(w, &smi_watchers, link) {\r\nif (try_module_get(w->owner)) {\r\nw->new_smi(i, dev);\r\nmodule_put(w->owner);\r\n}\r\n}\r\n}\r\nstatic int\r\nipmi_addr_equal(struct ipmi_addr *addr1, struct ipmi_addr *addr2)\r\n{\r\nif (addr1->addr_type != addr2->addr_type)\r\nreturn 0;\r\nif (addr1->channel != addr2->channel)\r\nreturn 0;\r\nif (addr1->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\r\nstruct ipmi_system_interface_addr *smi_addr1\r\n= (struct ipmi_system_interface_addr *) addr1;\r\nstruct ipmi_system_interface_addr *smi_addr2\r\n= (struct ipmi_system_interface_addr *) addr2;\r\nreturn (smi_addr1->lun == smi_addr2->lun);\r\n}\r\nif (is_ipmb_addr(addr1) || is_ipmb_bcast_addr(addr1)) {\r\nstruct ipmi_ipmb_addr *ipmb_addr1\r\n= (struct ipmi_ipmb_addr *) addr1;\r\nstruct ipmi_ipmb_addr *ipmb_addr2\r\n= (struct ipmi_ipmb_addr *) addr2;\r\nreturn ((ipmb_addr1->slave_addr == ipmb_addr2->slave_addr)\r\n&& (ipmb_addr1->lun == ipmb_addr2->lun));\r\n}\r\nif (is_lan_addr(addr1)) {\r\nstruct ipmi_lan_addr *lan_addr1\r\n= (struct ipmi_lan_addr *) addr1;\r\nstruct ipmi_lan_addr *lan_addr2\r\n= (struct ipmi_lan_addr *) addr2;\r\nreturn ((lan_addr1->remote_SWID == lan_addr2->remote_SWID)\r\n&& (lan_addr1->local_SWID == lan_addr2->local_SWID)\r\n&& (lan_addr1->session_handle\r\n== lan_addr2->session_handle)\r\n&& (lan_addr1->lun == lan_addr2->lun));\r\n}\r\nreturn 1;\r\n}\r\nint ipmi_validate_addr(struct ipmi_addr *addr, int len)\r\n{\r\nif (len < sizeof(struct ipmi_system_interface_addr))\r\nreturn -EINVAL;\r\nif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\r\nif (addr->channel != IPMI_BMC_CHANNEL)\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif ((addr->channel == IPMI_BMC_CHANNEL)\r\n|| (addr->channel >= IPMI_MAX_CHANNELS)\r\n|| (addr->channel < 0))\r\nreturn -EINVAL;\r\nif (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\r\nif (len < sizeof(struct ipmi_ipmb_addr))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nif (is_lan_addr(addr)) {\r\nif (len < sizeof(struct ipmi_lan_addr))\r\nreturn -EINVAL;\r\nreturn 0;\r\n}\r\nreturn -EINVAL;\r\n}\r\nunsigned int ipmi_addr_length(int addr_type)\r\n{\r\nif (addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\r\nreturn sizeof(struct ipmi_system_interface_addr);\r\nif ((addr_type == IPMI_IPMB_ADDR_TYPE)\r\n|| (addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE))\r\nreturn sizeof(struct ipmi_ipmb_addr);\r\nif (addr_type == IPMI_LAN_ADDR_TYPE)\r\nreturn sizeof(struct ipmi_lan_addr);\r\nreturn 0;\r\n}\r\nstatic void deliver_response(struct ipmi_recv_msg *msg)\r\n{\r\nif (!msg->user) {\r\nipmi_smi_t intf = msg->user_msg_data;\r\nif (intf->null_user_handler) {\r\nintf->null_user_handler(intf, msg);\r\nipmi_inc_stat(intf, handled_local_responses);\r\n} else {\r\nipmi_inc_stat(intf, unhandled_local_responses);\r\n}\r\nipmi_free_recv_msg(msg);\r\n} else if (!oops_in_progress) {\r\nipmi_user_t user = msg->user;\r\nuser->handler->ipmi_recv_hndl(msg, user->handler_data);\r\n}\r\n}\r\nstatic void\r\ndeliver_err_response(struct ipmi_recv_msg *msg, int err)\r\n{\r\nmsg->recv_type = IPMI_RESPONSE_RECV_TYPE;\r\nmsg->msg_data[0] = err;\r\nmsg->msg.netfn |= 1;\r\nmsg->msg.data_len = 1;\r\nmsg->msg.data = msg->msg_data;\r\ndeliver_response(msg);\r\n}\r\nstatic int intf_next_seq(ipmi_smi_t intf,\r\nstruct ipmi_recv_msg *recv_msg,\r\nunsigned long timeout,\r\nint retries,\r\nint broadcast,\r\nunsigned char *seq,\r\nlong *seqid)\r\n{\r\nint rv = 0;\r\nunsigned int i;\r\nfor (i = intf->curr_seq; (i+1)%IPMI_IPMB_NUM_SEQ != intf->curr_seq;\r\ni = (i+1)%IPMI_IPMB_NUM_SEQ) {\r\nif (!intf->seq_table[i].inuse)\r\nbreak;\r\n}\r\nif (!intf->seq_table[i].inuse) {\r\nintf->seq_table[i].recv_msg = recv_msg;\r\nintf->seq_table[i].timeout = MAX_MSG_TIMEOUT;\r\nintf->seq_table[i].orig_timeout = timeout;\r\nintf->seq_table[i].retries_left = retries;\r\nintf->seq_table[i].broadcast = broadcast;\r\nintf->seq_table[i].inuse = 1;\r\nintf->seq_table[i].seqid = NEXT_SEQID(intf->seq_table[i].seqid);\r\n*seq = i;\r\n*seqid = intf->seq_table[i].seqid;\r\nintf->curr_seq = (i+1)%IPMI_IPMB_NUM_SEQ;\r\nneed_waiter(intf);\r\n} else {\r\nrv = -EAGAIN;\r\n}\r\nreturn rv;\r\n}\r\nstatic int intf_find_seq(ipmi_smi_t intf,\r\nunsigned char seq,\r\nshort channel,\r\nunsigned char cmd,\r\nunsigned char netfn,\r\nstruct ipmi_addr *addr,\r\nstruct ipmi_recv_msg **recv_msg)\r\n{\r\nint rv = -ENODEV;\r\nunsigned long flags;\r\nif (seq >= IPMI_IPMB_NUM_SEQ)\r\nreturn -EINVAL;\r\nspin_lock_irqsave(&(intf->seq_lock), flags);\r\nif (intf->seq_table[seq].inuse) {\r\nstruct ipmi_recv_msg *msg = intf->seq_table[seq].recv_msg;\r\nif ((msg->addr.channel == channel) && (msg->msg.cmd == cmd)\r\n&& (msg->msg.netfn == netfn)\r\n&& (ipmi_addr_equal(addr, &(msg->addr)))) {\r\n*recv_msg = msg;\r\nintf->seq_table[seq].inuse = 0;\r\nrv = 0;\r\n}\r\n}\r\nspin_unlock_irqrestore(&(intf->seq_lock), flags);\r\nreturn rv;\r\n}\r\nstatic int intf_start_seq_timer(ipmi_smi_t intf,\r\nlong msgid)\r\n{\r\nint rv = -ENODEV;\r\nunsigned long flags;\r\nunsigned char seq;\r\nunsigned long seqid;\r\nGET_SEQ_FROM_MSGID(msgid, seq, seqid);\r\nspin_lock_irqsave(&(intf->seq_lock), flags);\r\nif ((intf->seq_table[seq].inuse)\r\n&& (intf->seq_table[seq].seqid == seqid)) {\r\nstruct seq_table *ent = &(intf->seq_table[seq]);\r\nent->timeout = ent->orig_timeout;\r\nrv = 0;\r\n}\r\nspin_unlock_irqrestore(&(intf->seq_lock), flags);\r\nreturn rv;\r\n}\r\nstatic int intf_err_seq(ipmi_smi_t intf,\r\nlong msgid,\r\nunsigned int err)\r\n{\r\nint rv = -ENODEV;\r\nunsigned long flags;\r\nunsigned char seq;\r\nunsigned long seqid;\r\nstruct ipmi_recv_msg *msg = NULL;\r\nGET_SEQ_FROM_MSGID(msgid, seq, seqid);\r\nspin_lock_irqsave(&(intf->seq_lock), flags);\r\nif ((intf->seq_table[seq].inuse)\r\n&& (intf->seq_table[seq].seqid == seqid)) {\r\nstruct seq_table *ent = &(intf->seq_table[seq]);\r\nent->inuse = 0;\r\nmsg = ent->recv_msg;\r\nrv = 0;\r\n}\r\nspin_unlock_irqrestore(&(intf->seq_lock), flags);\r\nif (msg)\r\ndeliver_err_response(msg, err);\r\nreturn rv;\r\n}\r\nint ipmi_create_user(unsigned int if_num,\r\nconst struct ipmi_user_hndl *handler,\r\nvoid *handler_data,\r\nipmi_user_t *user)\r\n{\r\nunsigned long flags;\r\nipmi_user_t new_user;\r\nint rv = 0;\r\nipmi_smi_t intf;\r\nif (handler == NULL)\r\nreturn -EINVAL;\r\nif (!initialized) {\r\nrv = ipmi_init_msghandler();\r\nif (rv)\r\nreturn rv;\r\nif (!initialized)\r\nreturn -ENODEV;\r\n}\r\nnew_user = kmalloc(sizeof(*new_user), GFP_KERNEL);\r\nif (!new_user)\r\nreturn -ENOMEM;\r\nmutex_lock(&ipmi_interfaces_mutex);\r\nlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\r\nif (intf->intf_num == if_num)\r\ngoto found;\r\n}\r\nrv = -EINVAL;\r\ngoto out_kfree;\r\nfound:\r\nkref_get(&intf->refcount);\r\nkref_init(&new_user->refcount);\r\nnew_user->handler = handler;\r\nnew_user->handler_data = handler_data;\r\nnew_user->intf = intf;\r\nnew_user->gets_events = false;\r\nif (!try_module_get(intf->handlers->owner)) {\r\nrv = -ENODEV;\r\ngoto out_kref;\r\n}\r\nif (intf->handlers->inc_usecount) {\r\nrv = intf->handlers->inc_usecount(intf->send_info);\r\nif (rv) {\r\nmodule_put(intf->handlers->owner);\r\ngoto out_kref;\r\n}\r\n}\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nnew_user->valid = true;\r\nspin_lock_irqsave(&intf->seq_lock, flags);\r\nlist_add_rcu(&new_user->link, &intf->users);\r\nspin_unlock_irqrestore(&intf->seq_lock, flags);\r\nif (handler->ipmi_watchdog_pretimeout) {\r\nif (atomic_inc_return(&intf->event_waiters) == 1)\r\nneed_waiter(intf);\r\n}\r\n*user = new_user;\r\nreturn 0;\r\nout_kref:\r\nkref_put(&intf->refcount, intf_free);\r\nout_kfree:\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nkfree(new_user);\r\nreturn rv;\r\n}\r\nint ipmi_get_smi_info(int if_num, struct ipmi_smi_info *data)\r\n{\r\nint rv = 0;\r\nipmi_smi_t intf;\r\nconst struct ipmi_smi_handlers *handlers;\r\nmutex_lock(&ipmi_interfaces_mutex);\r\nlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\r\nif (intf->intf_num == if_num)\r\ngoto found;\r\n}\r\nrv = -EINVAL;\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nreturn rv;\r\nfound:\r\nhandlers = intf->handlers;\r\nrv = -ENOSYS;\r\nif (handlers->get_smi_info)\r\nrv = handlers->get_smi_info(intf->send_info, data);\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nreturn rv;\r\n}\r\nstatic void free_user(struct kref *ref)\r\n{\r\nipmi_user_t user = container_of(ref, struct ipmi_user, refcount);\r\nkfree(user);\r\n}\r\nint ipmi_destroy_user(ipmi_user_t user)\r\n{\r\nipmi_smi_t intf = user->intf;\r\nint i;\r\nunsigned long flags;\r\nstruct cmd_rcvr *rcvr;\r\nstruct cmd_rcvr *rcvrs = NULL;\r\nuser->valid = false;\r\nif (user->handler->ipmi_watchdog_pretimeout)\r\natomic_dec(&intf->event_waiters);\r\nif (user->gets_events)\r\natomic_dec(&intf->event_waiters);\r\nspin_lock_irqsave(&intf->seq_lock, flags);\r\nlist_del_rcu(&user->link);\r\nfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\r\nif (intf->seq_table[i].inuse\r\n&& (intf->seq_table[i].recv_msg->user == user)) {\r\nintf->seq_table[i].inuse = 0;\r\nipmi_free_recv_msg(intf->seq_table[i].recv_msg);\r\n}\r\n}\r\nspin_unlock_irqrestore(&intf->seq_lock, flags);\r\nmutex_lock(&intf->cmd_rcvrs_mutex);\r\nlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\r\nif (rcvr->user == user) {\r\nlist_del_rcu(&rcvr->link);\r\nrcvr->next = rcvrs;\r\nrcvrs = rcvr;\r\n}\r\n}\r\nmutex_unlock(&intf->cmd_rcvrs_mutex);\r\nsynchronize_rcu();\r\nwhile (rcvrs) {\r\nrcvr = rcvrs;\r\nrcvrs = rcvr->next;\r\nkfree(rcvr);\r\n}\r\nmutex_lock(&ipmi_interfaces_mutex);\r\nif (intf->handlers) {\r\nmodule_put(intf->handlers->owner);\r\nif (intf->handlers->dec_usecount)\r\nintf->handlers->dec_usecount(intf->send_info);\r\n}\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nkref_put(&intf->refcount, intf_free);\r\nkref_put(&user->refcount, free_user);\r\nreturn 0;\r\n}\r\nvoid ipmi_get_version(ipmi_user_t user,\r\nunsigned char *major,\r\nunsigned char *minor)\r\n{\r\n*major = user->intf->ipmi_version_major;\r\n*minor = user->intf->ipmi_version_minor;\r\n}\r\nint ipmi_set_my_address(ipmi_user_t user,\r\nunsigned int channel,\r\nunsigned char address)\r\n{\r\nif (channel >= IPMI_MAX_CHANNELS)\r\nreturn -EINVAL;\r\nuser->intf->channels[channel].address = address;\r\nreturn 0;\r\n}\r\nint ipmi_get_my_address(ipmi_user_t user,\r\nunsigned int channel,\r\nunsigned char *address)\r\n{\r\nif (channel >= IPMI_MAX_CHANNELS)\r\nreturn -EINVAL;\r\n*address = user->intf->channels[channel].address;\r\nreturn 0;\r\n}\r\nint ipmi_set_my_LUN(ipmi_user_t user,\r\nunsigned int channel,\r\nunsigned char LUN)\r\n{\r\nif (channel >= IPMI_MAX_CHANNELS)\r\nreturn -EINVAL;\r\nuser->intf->channels[channel].lun = LUN & 0x3;\r\nreturn 0;\r\n}\r\nint ipmi_get_my_LUN(ipmi_user_t user,\r\nunsigned int channel,\r\nunsigned char *address)\r\n{\r\nif (channel >= IPMI_MAX_CHANNELS)\r\nreturn -EINVAL;\r\n*address = user->intf->channels[channel].lun;\r\nreturn 0;\r\n}\r\nint ipmi_get_maintenance_mode(ipmi_user_t user)\r\n{\r\nint mode;\r\nunsigned long flags;\r\nspin_lock_irqsave(&user->intf->maintenance_mode_lock, flags);\r\nmode = user->intf->maintenance_mode;\r\nspin_unlock_irqrestore(&user->intf->maintenance_mode_lock, flags);\r\nreturn mode;\r\n}\r\nstatic void maintenance_mode_update(ipmi_smi_t intf)\r\n{\r\nif (intf->handlers->set_maintenance_mode)\r\nintf->handlers->set_maintenance_mode(\r\nintf->send_info, intf->maintenance_mode_enable);\r\n}\r\nint ipmi_set_maintenance_mode(ipmi_user_t user, int mode)\r\n{\r\nint rv = 0;\r\nunsigned long flags;\r\nipmi_smi_t intf = user->intf;\r\nspin_lock_irqsave(&intf->maintenance_mode_lock, flags);\r\nif (intf->maintenance_mode != mode) {\r\nswitch (mode) {\r\ncase IPMI_MAINTENANCE_MODE_AUTO:\r\nintf->maintenance_mode_enable\r\n= (intf->auto_maintenance_timeout > 0);\r\nbreak;\r\ncase IPMI_MAINTENANCE_MODE_OFF:\r\nintf->maintenance_mode_enable = false;\r\nbreak;\r\ncase IPMI_MAINTENANCE_MODE_ON:\r\nintf->maintenance_mode_enable = true;\r\nbreak;\r\ndefault:\r\nrv = -EINVAL;\r\ngoto out_unlock;\r\n}\r\nintf->maintenance_mode = mode;\r\nmaintenance_mode_update(intf);\r\n}\r\nout_unlock:\r\nspin_unlock_irqrestore(&intf->maintenance_mode_lock, flags);\r\nreturn rv;\r\n}\r\nint ipmi_set_gets_events(ipmi_user_t user, bool val)\r\n{\r\nunsigned long flags;\r\nipmi_smi_t intf = user->intf;\r\nstruct ipmi_recv_msg *msg, *msg2;\r\nstruct list_head msgs;\r\nINIT_LIST_HEAD(&msgs);\r\nspin_lock_irqsave(&intf->events_lock, flags);\r\nif (user->gets_events == val)\r\ngoto out;\r\nuser->gets_events = val;\r\nif (val) {\r\nif (atomic_inc_return(&intf->event_waiters) == 1)\r\nneed_waiter(intf);\r\n} else {\r\natomic_dec(&intf->event_waiters);\r\n}\r\nif (intf->delivering_events)\r\ngoto out;\r\nwhile (user->gets_events && !list_empty(&intf->waiting_events)) {\r\nlist_for_each_entry_safe(msg, msg2, &intf->waiting_events, link)\r\nlist_move_tail(&msg->link, &msgs);\r\nintf->waiting_events_count = 0;\r\nif (intf->event_msg_printed) {\r\nprintk(KERN_WARNING PFX "Event queue no longer"\r\n" full\n");\r\nintf->event_msg_printed = 0;\r\n}\r\nintf->delivering_events = 1;\r\nspin_unlock_irqrestore(&intf->events_lock, flags);\r\nlist_for_each_entry_safe(msg, msg2, &msgs, link) {\r\nmsg->user = user;\r\nkref_get(&user->refcount);\r\ndeliver_response(msg);\r\n}\r\nspin_lock_irqsave(&intf->events_lock, flags);\r\nintf->delivering_events = 0;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&intf->events_lock, flags);\r\nreturn 0;\r\n}\r\nstatic struct cmd_rcvr *find_cmd_rcvr(ipmi_smi_t intf,\r\nunsigned char netfn,\r\nunsigned char cmd,\r\nunsigned char chan)\r\n{\r\nstruct cmd_rcvr *rcvr;\r\nlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\r\nif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\r\n&& (rcvr->chans & (1 << chan)))\r\nreturn rcvr;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int is_cmd_rcvr_exclusive(ipmi_smi_t intf,\r\nunsigned char netfn,\r\nunsigned char cmd,\r\nunsigned int chans)\r\n{\r\nstruct cmd_rcvr *rcvr;\r\nlist_for_each_entry_rcu(rcvr, &intf->cmd_rcvrs, link) {\r\nif ((rcvr->netfn == netfn) && (rcvr->cmd == cmd)\r\n&& (rcvr->chans & chans))\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nint ipmi_register_for_cmd(ipmi_user_t user,\r\nunsigned char netfn,\r\nunsigned char cmd,\r\nunsigned int chans)\r\n{\r\nipmi_smi_t intf = user->intf;\r\nstruct cmd_rcvr *rcvr;\r\nint rv = 0;\r\nrcvr = kmalloc(sizeof(*rcvr), GFP_KERNEL);\r\nif (!rcvr)\r\nreturn -ENOMEM;\r\nrcvr->cmd = cmd;\r\nrcvr->netfn = netfn;\r\nrcvr->chans = chans;\r\nrcvr->user = user;\r\nmutex_lock(&intf->cmd_rcvrs_mutex);\r\nif (!is_cmd_rcvr_exclusive(intf, netfn, cmd, chans)) {\r\nrv = -EBUSY;\r\ngoto out_unlock;\r\n}\r\nif (atomic_inc_return(&intf->event_waiters) == 1)\r\nneed_waiter(intf);\r\nlist_add_rcu(&rcvr->link, &intf->cmd_rcvrs);\r\nout_unlock:\r\nmutex_unlock(&intf->cmd_rcvrs_mutex);\r\nif (rv)\r\nkfree(rcvr);\r\nreturn rv;\r\n}\r\nint ipmi_unregister_for_cmd(ipmi_user_t user,\r\nunsigned char netfn,\r\nunsigned char cmd,\r\nunsigned int chans)\r\n{\r\nipmi_smi_t intf = user->intf;\r\nstruct cmd_rcvr *rcvr;\r\nstruct cmd_rcvr *rcvrs = NULL;\r\nint i, rv = -ENOENT;\r\nmutex_lock(&intf->cmd_rcvrs_mutex);\r\nfor (i = 0; i < IPMI_NUM_CHANNELS; i++) {\r\nif (((1 << i) & chans) == 0)\r\ncontinue;\r\nrcvr = find_cmd_rcvr(intf, netfn, cmd, i);\r\nif (rcvr == NULL)\r\ncontinue;\r\nif (rcvr->user == user) {\r\nrv = 0;\r\nrcvr->chans &= ~chans;\r\nif (rcvr->chans == 0) {\r\nlist_del_rcu(&rcvr->link);\r\nrcvr->next = rcvrs;\r\nrcvrs = rcvr;\r\n}\r\n}\r\n}\r\nmutex_unlock(&intf->cmd_rcvrs_mutex);\r\nsynchronize_rcu();\r\nwhile (rcvrs) {\r\natomic_dec(&intf->event_waiters);\r\nrcvr = rcvrs;\r\nrcvrs = rcvr->next;\r\nkfree(rcvr);\r\n}\r\nreturn rv;\r\n}\r\nstatic unsigned char\r\nipmb_checksum(unsigned char *data, int size)\r\n{\r\nunsigned char csum = 0;\r\nfor (; size > 0; size--, data++)\r\ncsum += *data;\r\nreturn -csum;\r\n}\r\nstatic inline void format_ipmb_msg(struct ipmi_smi_msg *smi_msg,\r\nstruct kernel_ipmi_msg *msg,\r\nstruct ipmi_ipmb_addr *ipmb_addr,\r\nlong msgid,\r\nunsigned char ipmb_seq,\r\nint broadcast,\r\nunsigned char source_address,\r\nunsigned char source_lun)\r\n{\r\nint i = broadcast;\r\nsmi_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nsmi_msg->data[1] = IPMI_SEND_MSG_CMD;\r\nsmi_msg->data[2] = ipmb_addr->channel;\r\nif (broadcast)\r\nsmi_msg->data[3] = 0;\r\nsmi_msg->data[i+3] = ipmb_addr->slave_addr;\r\nsmi_msg->data[i+4] = (msg->netfn << 2) | (ipmb_addr->lun & 0x3);\r\nsmi_msg->data[i+5] = ipmb_checksum(&(smi_msg->data[i+3]), 2);\r\nsmi_msg->data[i+6] = source_address;\r\nsmi_msg->data[i+7] = (ipmb_seq << 2) | source_lun;\r\nsmi_msg->data[i+8] = msg->cmd;\r\nif (msg->data_len > 0)\r\nmemcpy(&(smi_msg->data[i+9]), msg->data,\r\nmsg->data_len);\r\nsmi_msg->data_size = msg->data_len + 9;\r\nsmi_msg->data[i+smi_msg->data_size]\r\n= ipmb_checksum(&(smi_msg->data[i+6]),\r\nsmi_msg->data_size-6);\r\nsmi_msg->data_size += 1 + i;\r\nsmi_msg->msgid = msgid;\r\n}\r\nstatic inline void format_lan_msg(struct ipmi_smi_msg *smi_msg,\r\nstruct kernel_ipmi_msg *msg,\r\nstruct ipmi_lan_addr *lan_addr,\r\nlong msgid,\r\nunsigned char ipmb_seq,\r\nunsigned char source_lun)\r\n{\r\nsmi_msg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nsmi_msg->data[1] = IPMI_SEND_MSG_CMD;\r\nsmi_msg->data[2] = lan_addr->channel;\r\nsmi_msg->data[3] = lan_addr->session_handle;\r\nsmi_msg->data[4] = lan_addr->remote_SWID;\r\nsmi_msg->data[5] = (msg->netfn << 2) | (lan_addr->lun & 0x3);\r\nsmi_msg->data[6] = ipmb_checksum(&(smi_msg->data[4]), 2);\r\nsmi_msg->data[7] = lan_addr->local_SWID;\r\nsmi_msg->data[8] = (ipmb_seq << 2) | source_lun;\r\nsmi_msg->data[9] = msg->cmd;\r\nif (msg->data_len > 0)\r\nmemcpy(&(smi_msg->data[10]), msg->data,\r\nmsg->data_len);\r\nsmi_msg->data_size = msg->data_len + 10;\r\nsmi_msg->data[smi_msg->data_size]\r\n= ipmb_checksum(&(smi_msg->data[7]),\r\nsmi_msg->data_size-7);\r\nsmi_msg->data_size += 1;\r\nsmi_msg->msgid = msgid;\r\n}\r\nstatic struct ipmi_smi_msg *smi_add_send_msg(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *smi_msg,\r\nint priority)\r\n{\r\nif (intf->curr_msg) {\r\nif (priority > 0)\r\nlist_add_tail(&smi_msg->link, &intf->hp_xmit_msgs);\r\nelse\r\nlist_add_tail(&smi_msg->link, &intf->xmit_msgs);\r\nsmi_msg = NULL;\r\n} else {\r\nintf->curr_msg = smi_msg;\r\n}\r\nreturn smi_msg;\r\n}\r\nstatic void smi_send(ipmi_smi_t intf, const struct ipmi_smi_handlers *handlers,\r\nstruct ipmi_smi_msg *smi_msg, int priority)\r\n{\r\nint run_to_completion = intf->run_to_completion;\r\nif (run_to_completion) {\r\nsmi_msg = smi_add_send_msg(intf, smi_msg, priority);\r\n} else {\r\nunsigned long flags;\r\nspin_lock_irqsave(&intf->xmit_msgs_lock, flags);\r\nsmi_msg = smi_add_send_msg(intf, smi_msg, priority);\r\nspin_unlock_irqrestore(&intf->xmit_msgs_lock, flags);\r\n}\r\nif (smi_msg)\r\nhandlers->sender(intf->send_info, smi_msg);\r\n}\r\nstatic int i_ipmi_request(ipmi_user_t user,\r\nipmi_smi_t intf,\r\nstruct ipmi_addr *addr,\r\nlong msgid,\r\nstruct kernel_ipmi_msg *msg,\r\nvoid *user_msg_data,\r\nvoid *supplied_smi,\r\nstruct ipmi_recv_msg *supplied_recv,\r\nint priority,\r\nunsigned char source_address,\r\nunsigned char source_lun,\r\nint retries,\r\nunsigned int retry_time_ms)\r\n{\r\nint rv = 0;\r\nstruct ipmi_smi_msg *smi_msg;\r\nstruct ipmi_recv_msg *recv_msg;\r\nunsigned long flags;\r\nif (supplied_recv)\r\nrecv_msg = supplied_recv;\r\nelse {\r\nrecv_msg = ipmi_alloc_recv_msg();\r\nif (recv_msg == NULL)\r\nreturn -ENOMEM;\r\n}\r\nrecv_msg->user_msg_data = user_msg_data;\r\nif (supplied_smi)\r\nsmi_msg = (struct ipmi_smi_msg *) supplied_smi;\r\nelse {\r\nsmi_msg = ipmi_alloc_smi_msg();\r\nif (smi_msg == NULL) {\r\nipmi_free_recv_msg(recv_msg);\r\nreturn -ENOMEM;\r\n}\r\n}\r\nrcu_read_lock();\r\nif (intf->in_shutdown) {\r\nrv = -ENODEV;\r\ngoto out_err;\r\n}\r\nrecv_msg->user = user;\r\nif (user)\r\nkref_get(&user->refcount);\r\nrecv_msg->msgid = msgid;\r\nrecv_msg->msg = *msg;\r\nif (addr->addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE) {\r\nstruct ipmi_system_interface_addr *smi_addr;\r\nif (msg->netfn & 1) {\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nsmi_addr = (struct ipmi_system_interface_addr *) addr;\r\nif (smi_addr->lun > 3) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nmemcpy(&recv_msg->addr, smi_addr, sizeof(*smi_addr));\r\nif ((msg->netfn == IPMI_NETFN_APP_REQUEST)\r\n&& ((msg->cmd == IPMI_SEND_MSG_CMD)\r\n|| (msg->cmd == IPMI_GET_MSG_CMD)\r\n|| (msg->cmd == IPMI_READ_EVENT_MSG_BUFFER_CMD))) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nif (((msg->netfn == IPMI_NETFN_APP_REQUEST)\r\n&& ((msg->cmd == IPMI_COLD_RESET_CMD)\r\n|| (msg->cmd == IPMI_WARM_RESET_CMD)))\r\n|| (msg->netfn == IPMI_NETFN_FIRMWARE_REQUEST)) {\r\nspin_lock_irqsave(&intf->maintenance_mode_lock, flags);\r\nintf->auto_maintenance_timeout\r\n= IPMI_MAINTENANCE_MODE_TIMEOUT;\r\nif (!intf->maintenance_mode\r\n&& !intf->maintenance_mode_enable) {\r\nintf->maintenance_mode_enable = true;\r\nmaintenance_mode_update(intf);\r\n}\r\nspin_unlock_irqrestore(&intf->maintenance_mode_lock,\r\nflags);\r\n}\r\nif ((msg->data_len + 2) > IPMI_MAX_MSG_LENGTH) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EMSGSIZE;\r\ngoto out_err;\r\n}\r\nsmi_msg->data[0] = (msg->netfn << 2) | (smi_addr->lun & 0x3);\r\nsmi_msg->data[1] = msg->cmd;\r\nsmi_msg->msgid = msgid;\r\nsmi_msg->user_data = recv_msg;\r\nif (msg->data_len > 0)\r\nmemcpy(&(smi_msg->data[2]), msg->data, msg->data_len);\r\nsmi_msg->data_size = msg->data_len + 2;\r\nipmi_inc_stat(intf, sent_local_commands);\r\n} else if (is_ipmb_addr(addr) || is_ipmb_bcast_addr(addr)) {\r\nstruct ipmi_ipmb_addr *ipmb_addr;\r\nunsigned char ipmb_seq;\r\nlong seqid;\r\nint broadcast = 0;\r\nif (addr->channel >= IPMI_MAX_CHANNELS) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nif (intf->channels[addr->channel].medium\r\n!= IPMI_CHANNEL_MEDIUM_IPMB) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nif (retries < 0) {\r\nif (addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE)\r\nretries = 0;\r\nelse\r\nretries = 4;\r\n}\r\nif (addr->addr_type == IPMI_IPMB_BROADCAST_ADDR_TYPE) {\r\naddr->addr_type = IPMI_IPMB_ADDR_TYPE;\r\nbroadcast = 1;\r\n}\r\nif (retry_time_ms == 0)\r\nretry_time_ms = 1000;\r\nif ((msg->data_len + 10 + broadcast) > IPMI_MAX_MSG_LENGTH) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EMSGSIZE;\r\ngoto out_err;\r\n}\r\nipmb_addr = (struct ipmi_ipmb_addr *) addr;\r\nif (ipmb_addr->lun > 3) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nmemcpy(&recv_msg->addr, ipmb_addr, sizeof(*ipmb_addr));\r\nif (recv_msg->msg.netfn & 0x1) {\r\nipmi_inc_stat(intf, sent_ipmb_responses);\r\nformat_ipmb_msg(smi_msg, msg, ipmb_addr, msgid,\r\nmsgid, broadcast,\r\nsource_address, source_lun);\r\nsmi_msg->user_data = recv_msg;\r\n} else {\r\nspin_lock_irqsave(&(intf->seq_lock), flags);\r\nrv = intf_next_seq(intf,\r\nrecv_msg,\r\nretry_time_ms,\r\nretries,\r\nbroadcast,\r\n&ipmb_seq,\r\n&seqid);\r\nif (rv) {\r\nspin_unlock_irqrestore(&(intf->seq_lock),\r\nflags);\r\ngoto out_err;\r\n}\r\nipmi_inc_stat(intf, sent_ipmb_commands);\r\nformat_ipmb_msg(smi_msg, msg, ipmb_addr,\r\nSTORE_SEQ_IN_MSGID(ipmb_seq, seqid),\r\nipmb_seq, broadcast,\r\nsource_address, source_lun);\r\nmemcpy(recv_msg->msg_data, smi_msg->data,\r\nsmi_msg->data_size);\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = smi_msg->data_size;\r\nspin_unlock_irqrestore(&(intf->seq_lock), flags);\r\n}\r\n} else if (is_lan_addr(addr)) {\r\nstruct ipmi_lan_addr *lan_addr;\r\nunsigned char ipmb_seq;\r\nlong seqid;\r\nif (addr->channel >= IPMI_MAX_CHANNELS) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nif ((intf->channels[addr->channel].medium\r\n!= IPMI_CHANNEL_MEDIUM_8023LAN)\r\n&& (intf->channels[addr->channel].medium\r\n!= IPMI_CHANNEL_MEDIUM_ASYNC)) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nretries = 4;\r\nif (retry_time_ms == 0)\r\nretry_time_ms = 1000;\r\nif ((msg->data_len + 12) > IPMI_MAX_MSG_LENGTH) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EMSGSIZE;\r\ngoto out_err;\r\n}\r\nlan_addr = (struct ipmi_lan_addr *) addr;\r\nif (lan_addr->lun > 3) {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\nmemcpy(&recv_msg->addr, lan_addr, sizeof(*lan_addr));\r\nif (recv_msg->msg.netfn & 0x1) {\r\nipmi_inc_stat(intf, sent_lan_responses);\r\nformat_lan_msg(smi_msg, msg, lan_addr, msgid,\r\nmsgid, source_lun);\r\nsmi_msg->user_data = recv_msg;\r\n} else {\r\nspin_lock_irqsave(&(intf->seq_lock), flags);\r\nrv = intf_next_seq(intf,\r\nrecv_msg,\r\nretry_time_ms,\r\nretries,\r\n0,\r\n&ipmb_seq,\r\n&seqid);\r\nif (rv) {\r\nspin_unlock_irqrestore(&(intf->seq_lock),\r\nflags);\r\ngoto out_err;\r\n}\r\nipmi_inc_stat(intf, sent_lan_commands);\r\nformat_lan_msg(smi_msg, msg, lan_addr,\r\nSTORE_SEQ_IN_MSGID(ipmb_seq, seqid),\r\nipmb_seq, source_lun);\r\nmemcpy(recv_msg->msg_data, smi_msg->data,\r\nsmi_msg->data_size);\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = smi_msg->data_size;\r\nspin_unlock_irqrestore(&(intf->seq_lock), flags);\r\n}\r\n} else {\r\nipmi_inc_stat(intf, sent_invalid_commands);\r\nrv = -EINVAL;\r\ngoto out_err;\r\n}\r\n#ifdef DEBUG_MSGING\r\n{\r\nint m;\r\nfor (m = 0; m < smi_msg->data_size; m++)\r\nprintk(" %2.2x", smi_msg->data[m]);\r\nprintk("\n");\r\n}\r\n#endif\r\nsmi_send(intf, intf->handlers, smi_msg, priority);\r\nrcu_read_unlock();\r\nreturn 0;\r\nout_err:\r\nrcu_read_unlock();\r\nipmi_free_smi_msg(smi_msg);\r\nipmi_free_recv_msg(recv_msg);\r\nreturn rv;\r\n}\r\nstatic int check_addr(ipmi_smi_t intf,\r\nstruct ipmi_addr *addr,\r\nunsigned char *saddr,\r\nunsigned char *lun)\r\n{\r\nif (addr->channel >= IPMI_MAX_CHANNELS)\r\nreturn -EINVAL;\r\n*lun = intf->channels[addr->channel].lun;\r\n*saddr = intf->channels[addr->channel].address;\r\nreturn 0;\r\n}\r\nint ipmi_request_settime(ipmi_user_t user,\r\nstruct ipmi_addr *addr,\r\nlong msgid,\r\nstruct kernel_ipmi_msg *msg,\r\nvoid *user_msg_data,\r\nint priority,\r\nint retries,\r\nunsigned int retry_time_ms)\r\n{\r\nunsigned char saddr = 0, lun = 0;\r\nint rv;\r\nif (!user)\r\nreturn -EINVAL;\r\nrv = check_addr(user->intf, addr, &saddr, &lun);\r\nif (rv)\r\nreturn rv;\r\nreturn i_ipmi_request(user,\r\nuser->intf,\r\naddr,\r\nmsgid,\r\nmsg,\r\nuser_msg_data,\r\nNULL, NULL,\r\npriority,\r\nsaddr,\r\nlun,\r\nretries,\r\nretry_time_ms);\r\n}\r\nint ipmi_request_supply_msgs(ipmi_user_t user,\r\nstruct ipmi_addr *addr,\r\nlong msgid,\r\nstruct kernel_ipmi_msg *msg,\r\nvoid *user_msg_data,\r\nvoid *supplied_smi,\r\nstruct ipmi_recv_msg *supplied_recv,\r\nint priority)\r\n{\r\nunsigned char saddr = 0, lun = 0;\r\nint rv;\r\nif (!user)\r\nreturn -EINVAL;\r\nrv = check_addr(user->intf, addr, &saddr, &lun);\r\nif (rv)\r\nreturn rv;\r\nreturn i_ipmi_request(user,\r\nuser->intf,\r\naddr,\r\nmsgid,\r\nmsg,\r\nuser_msg_data,\r\nsupplied_smi,\r\nsupplied_recv,\r\npriority,\r\nsaddr,\r\nlun,\r\n-1, 0);\r\n}\r\nstatic int smi_ipmb_proc_show(struct seq_file *m, void *v)\r\n{\r\nipmi_smi_t intf = m->private;\r\nint i;\r\nseq_printf(m, "%x", intf->channels[0].address);\r\nfor (i = 1; i < IPMI_MAX_CHANNELS; i++)\r\nseq_printf(m, " %x", intf->channels[i].address);\r\nseq_putc(m, '\n');\r\nreturn 0;\r\n}\r\nstatic int smi_ipmb_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_ipmb_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int smi_version_proc_show(struct seq_file *m, void *v)\r\n{\r\nipmi_smi_t intf = m->private;\r\nseq_printf(m, "%u.%u\n",\r\nipmi_version_major(&intf->bmc->id),\r\nipmi_version_minor(&intf->bmc->id));\r\nreturn 0;\r\n}\r\nstatic int smi_version_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_version_proc_show, PDE_DATA(inode));\r\n}\r\nstatic int smi_stats_proc_show(struct seq_file *m, void *v)\r\n{\r\nipmi_smi_t intf = m->private;\r\nseq_printf(m, "sent_invalid_commands: %u\n",\r\nipmi_get_stat(intf, sent_invalid_commands));\r\nseq_printf(m, "sent_local_commands: %u\n",\r\nipmi_get_stat(intf, sent_local_commands));\r\nseq_printf(m, "handled_local_responses: %u\n",\r\nipmi_get_stat(intf, handled_local_responses));\r\nseq_printf(m, "unhandled_local_responses: %u\n",\r\nipmi_get_stat(intf, unhandled_local_responses));\r\nseq_printf(m, "sent_ipmb_commands: %u\n",\r\nipmi_get_stat(intf, sent_ipmb_commands));\r\nseq_printf(m, "sent_ipmb_command_errs: %u\n",\r\nipmi_get_stat(intf, sent_ipmb_command_errs));\r\nseq_printf(m, "retransmitted_ipmb_commands: %u\n",\r\nipmi_get_stat(intf, retransmitted_ipmb_commands));\r\nseq_printf(m, "timed_out_ipmb_commands: %u\n",\r\nipmi_get_stat(intf, timed_out_ipmb_commands));\r\nseq_printf(m, "timed_out_ipmb_broadcasts: %u\n",\r\nipmi_get_stat(intf, timed_out_ipmb_broadcasts));\r\nseq_printf(m, "sent_ipmb_responses: %u\n",\r\nipmi_get_stat(intf, sent_ipmb_responses));\r\nseq_printf(m, "handled_ipmb_responses: %u\n",\r\nipmi_get_stat(intf, handled_ipmb_responses));\r\nseq_printf(m, "invalid_ipmb_responses: %u\n",\r\nipmi_get_stat(intf, invalid_ipmb_responses));\r\nseq_printf(m, "unhandled_ipmb_responses: %u\n",\r\nipmi_get_stat(intf, unhandled_ipmb_responses));\r\nseq_printf(m, "sent_lan_commands: %u\n",\r\nipmi_get_stat(intf, sent_lan_commands));\r\nseq_printf(m, "sent_lan_command_errs: %u\n",\r\nipmi_get_stat(intf, sent_lan_command_errs));\r\nseq_printf(m, "retransmitted_lan_commands: %u\n",\r\nipmi_get_stat(intf, retransmitted_lan_commands));\r\nseq_printf(m, "timed_out_lan_commands: %u\n",\r\nipmi_get_stat(intf, timed_out_lan_commands));\r\nseq_printf(m, "sent_lan_responses: %u\n",\r\nipmi_get_stat(intf, sent_lan_responses));\r\nseq_printf(m, "handled_lan_responses: %u\n",\r\nipmi_get_stat(intf, handled_lan_responses));\r\nseq_printf(m, "invalid_lan_responses: %u\n",\r\nipmi_get_stat(intf, invalid_lan_responses));\r\nseq_printf(m, "unhandled_lan_responses: %u\n",\r\nipmi_get_stat(intf, unhandled_lan_responses));\r\nseq_printf(m, "handled_commands: %u\n",\r\nipmi_get_stat(intf, handled_commands));\r\nseq_printf(m, "invalid_commands: %u\n",\r\nipmi_get_stat(intf, invalid_commands));\r\nseq_printf(m, "unhandled_commands: %u\n",\r\nipmi_get_stat(intf, unhandled_commands));\r\nseq_printf(m, "invalid_events: %u\n",\r\nipmi_get_stat(intf, invalid_events));\r\nseq_printf(m, "events: %u\n",\r\nipmi_get_stat(intf, events));\r\nseq_printf(m, "failed rexmit LAN msgs: %u\n",\r\nipmi_get_stat(intf, dropped_rexmit_lan_commands));\r\nseq_printf(m, "failed rexmit IPMB msgs: %u\n",\r\nipmi_get_stat(intf, dropped_rexmit_ipmb_commands));\r\nreturn 0;\r\n}\r\nstatic int smi_stats_proc_open(struct inode *inode, struct file *file)\r\n{\r\nreturn single_open(file, smi_stats_proc_show, PDE_DATA(inode));\r\n}\r\nint ipmi_smi_add_proc_entry(ipmi_smi_t smi, char *name,\r\nconst struct file_operations *proc_ops,\r\nvoid *data)\r\n{\r\nint rv = 0;\r\n#ifdef CONFIG_PROC_FS\r\nstruct proc_dir_entry *file;\r\nstruct ipmi_proc_entry *entry;\r\nentry = kmalloc(sizeof(*entry), GFP_KERNEL);\r\nif (!entry)\r\nreturn -ENOMEM;\r\nentry->name = kstrdup(name, GFP_KERNEL);\r\nif (!entry->name) {\r\nkfree(entry);\r\nreturn -ENOMEM;\r\n}\r\nfile = proc_create_data(name, 0, smi->proc_dir, proc_ops, data);\r\nif (!file) {\r\nkfree(entry->name);\r\nkfree(entry);\r\nrv = -ENOMEM;\r\n} else {\r\nmutex_lock(&smi->proc_entry_lock);\r\nentry->next = smi->proc_entries;\r\nsmi->proc_entries = entry;\r\nmutex_unlock(&smi->proc_entry_lock);\r\n}\r\n#endif\r\nreturn rv;\r\n}\r\nstatic int add_proc_entries(ipmi_smi_t smi, int num)\r\n{\r\nint rv = 0;\r\n#ifdef CONFIG_PROC_FS\r\nsprintf(smi->proc_dir_name, "%d", num);\r\nsmi->proc_dir = proc_mkdir(smi->proc_dir_name, proc_ipmi_root);\r\nif (!smi->proc_dir)\r\nrv = -ENOMEM;\r\nif (rv == 0)\r\nrv = ipmi_smi_add_proc_entry(smi, "stats",\r\n&smi_stats_proc_ops,\r\nsmi);\r\nif (rv == 0)\r\nrv = ipmi_smi_add_proc_entry(smi, "ipmb",\r\n&smi_ipmb_proc_ops,\r\nsmi);\r\nif (rv == 0)\r\nrv = ipmi_smi_add_proc_entry(smi, "version",\r\n&smi_version_proc_ops,\r\nsmi);\r\n#endif\r\nreturn rv;\r\n}\r\nstatic void remove_proc_entries(ipmi_smi_t smi)\r\n{\r\n#ifdef CONFIG_PROC_FS\r\nstruct ipmi_proc_entry *entry;\r\nmutex_lock(&smi->proc_entry_lock);\r\nwhile (smi->proc_entries) {\r\nentry = smi->proc_entries;\r\nsmi->proc_entries = entry->next;\r\nremove_proc_entry(entry->name, smi->proc_dir);\r\nkfree(entry->name);\r\nkfree(entry);\r\n}\r\nmutex_unlock(&smi->proc_entry_lock);\r\nremove_proc_entry(smi->proc_dir_name, proc_ipmi_root);\r\n#endif\r\n}\r\nstatic int __find_bmc_guid(struct device *dev, void *data)\r\n{\r\nunsigned char *id = data;\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn memcmp(bmc->guid, id, 16) == 0;\r\n}\r\nstatic struct bmc_device *ipmi_find_bmc_guid(struct device_driver *drv,\r\nunsigned char *guid)\r\n{\r\nstruct device *dev;\r\ndev = driver_find_device(drv, NULL, guid, __find_bmc_guid);\r\nif (dev)\r\nreturn to_bmc_device(dev);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic int __find_bmc_prod_dev_id(struct device *dev, void *data)\r\n{\r\nstruct prod_dev_id *id = data;\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn (bmc->id.product_id == id->product_id\r\n&& bmc->id.device_id == id->device_id);\r\n}\r\nstatic struct bmc_device *ipmi_find_bmc_prod_dev_id(\r\nstruct device_driver *drv,\r\nunsigned int product_id, unsigned char device_id)\r\n{\r\nstruct prod_dev_id id = {\r\n.product_id = product_id,\r\n.device_id = device_id,\r\n};\r\nstruct device *dev;\r\ndev = driver_find_device(drv, NULL, &id, __find_bmc_prod_dev_id);\r\nif (dev)\r\nreturn to_bmc_device(dev);\r\nelse\r\nreturn NULL;\r\n}\r\nstatic ssize_t device_id_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 10, "%u\n", bmc->id.device_id);\r\n}\r\nstatic ssize_t provides_device_sdrs_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 10, "%u\n",\r\n(bmc->id.device_revision & 0x80) >> 7);\r\n}\r\nstatic ssize_t revision_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 20, "%u\n",\r\nbmc->id.device_revision & 0x0F);\r\n}\r\nstatic ssize_t firmware_revision_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 20, "%u.%x\n", bmc->id.firmware_revision_1,\r\nbmc->id.firmware_revision_2);\r\n}\r\nstatic ssize_t ipmi_version_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 20, "%u.%u\n",\r\nipmi_version_major(&bmc->id),\r\nipmi_version_minor(&bmc->id));\r\n}\r\nstatic ssize_t add_dev_support_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 10, "0x%02x\n",\r\nbmc->id.additional_device_support);\r\n}\r\nstatic ssize_t manufacturer_id_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 20, "0x%6.6x\n", bmc->id.manufacturer_id);\r\n}\r\nstatic ssize_t product_id_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 10, "0x%4.4x\n", bmc->id.product_id);\r\n}\r\nstatic ssize_t aux_firmware_rev_show(struct device *dev,\r\nstruct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 21, "0x%02x 0x%02x 0x%02x 0x%02x\n",\r\nbmc->id.aux_firmware_revision[3],\r\nbmc->id.aux_firmware_revision[2],\r\nbmc->id.aux_firmware_revision[1],\r\nbmc->id.aux_firmware_revision[0]);\r\n}\r\nstatic ssize_t guid_show(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\nreturn snprintf(buf, 100, "%Lx%Lx\n",\r\n(long long) bmc->guid[0],\r\n(long long) bmc->guid[8]);\r\n}\r\nstatic umode_t bmc_dev_attr_is_visible(struct kobject *kobj,\r\nstruct attribute *attr, int idx)\r\n{\r\nstruct device *dev = kobj_to_dev(kobj);\r\nstruct bmc_device *bmc = to_bmc_device(dev);\r\numode_t mode = attr->mode;\r\nif (attr == &dev_attr_aux_firmware_revision.attr)\r\nreturn bmc->id.aux_firmware_revision_set ? mode : 0;\r\nif (attr == &dev_attr_guid.attr)\r\nreturn bmc->guid_set ? mode : 0;\r\nreturn mode;\r\n}\r\nstatic void\r\nrelease_bmc_device(struct device *dev)\r\n{\r\nkfree(to_bmc_device(dev));\r\n}\r\nstatic void\r\ncleanup_bmc_device(struct kref *ref)\r\n{\r\nstruct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);\r\nplatform_device_unregister(&bmc->pdev);\r\n}\r\nstatic void ipmi_bmc_unregister(ipmi_smi_t intf)\r\n{\r\nstruct bmc_device *bmc = intf->bmc;\r\nsysfs_remove_link(&intf->si_dev->kobj, "bmc");\r\nif (intf->my_dev_name) {\r\nsysfs_remove_link(&bmc->pdev.dev.kobj, intf->my_dev_name);\r\nkfree(intf->my_dev_name);\r\nintf->my_dev_name = NULL;\r\n}\r\nmutex_lock(&ipmidriver_mutex);\r\nkref_put(&bmc->usecount, cleanup_bmc_device);\r\nintf->bmc = NULL;\r\nmutex_unlock(&ipmidriver_mutex);\r\n}\r\nstatic int ipmi_bmc_register(ipmi_smi_t intf, int ifnum)\r\n{\r\nint rv;\r\nstruct bmc_device *bmc = intf->bmc;\r\nstruct bmc_device *old_bmc;\r\nmutex_lock(&ipmidriver_mutex);\r\nif (bmc->guid_set)\r\nold_bmc = ipmi_find_bmc_guid(&ipmidriver.driver, bmc->guid);\r\nelse\r\nold_bmc = ipmi_find_bmc_prod_dev_id(&ipmidriver.driver,\r\nbmc->id.product_id,\r\nbmc->id.device_id);\r\nif (old_bmc) {\r\nkfree(bmc);\r\nintf->bmc = old_bmc;\r\nbmc = old_bmc;\r\nkref_get(&bmc->usecount);\r\nmutex_unlock(&ipmidriver_mutex);\r\nprintk(KERN_INFO\r\n"ipmi: interfacing existing BMC (man_id: 0x%6.6x,"\r\n" prod_id: 0x%4.4x, dev_id: 0x%2.2x)\n",\r\nbmc->id.manufacturer_id,\r\nbmc->id.product_id,\r\nbmc->id.device_id);\r\n} else {\r\nunsigned char orig_dev_id = bmc->id.device_id;\r\nint warn_printed = 0;\r\nsnprintf(bmc->name, sizeof(bmc->name),\r\n"ipmi_bmc.%4.4x", bmc->id.product_id);\r\nbmc->pdev.name = bmc->name;\r\nwhile (ipmi_find_bmc_prod_dev_id(&ipmidriver.driver,\r\nbmc->id.product_id,\r\nbmc->id.device_id)) {\r\nif (!warn_printed) {\r\nprintk(KERN_WARNING PFX\r\n"This machine has two different BMCs"\r\n" with the same product id and device"\r\n" id. This is an error in the"\r\n" firmware, but incrementing the"\r\n" device id to work around the problem."\r\n" Prod ID = 0x%x, Dev ID = 0x%x\n",\r\nbmc->id.product_id, bmc->id.device_id);\r\nwarn_printed = 1;\r\n}\r\nbmc->id.device_id++;\r\nif (bmc->id.device_id == orig_dev_id) {\r\nprintk(KERN_ERR PFX\r\n"Out of device ids!\n");\r\nbreak;\r\n}\r\n}\r\nbmc->pdev.dev.driver = &ipmidriver.driver;\r\nbmc->pdev.id = bmc->id.device_id;\r\nbmc->pdev.dev.release = release_bmc_device;\r\nbmc->pdev.dev.type = &bmc_device_type;\r\nkref_init(&bmc->usecount);\r\nrv = platform_device_register(&bmc->pdev);\r\nmutex_unlock(&ipmidriver_mutex);\r\nif (rv) {\r\nput_device(&bmc->pdev.dev);\r\nprintk(KERN_ERR\r\n"ipmi_msghandler:"\r\n" Unable to register bmc device: %d\n",\r\nrv);\r\nreturn rv;\r\n}\r\ndev_info(intf->si_dev, "Found new BMC (man_id: 0x%6.6x, "\r\n"prod_id: 0x%4.4x, dev_id: 0x%2.2x)\n",\r\nbmc->id.manufacturer_id,\r\nbmc->id.product_id,\r\nbmc->id.device_id);\r\n}\r\nrv = sysfs_create_link(&intf->si_dev->kobj, &bmc->pdev.dev.kobj, "bmc");\r\nif (rv) {\r\nprintk(KERN_ERR\r\n"ipmi_msghandler: Unable to create bmc symlink: %d\n",\r\nrv);\r\ngoto out_err;\r\n}\r\nintf->my_dev_name = kasprintf(GFP_KERNEL, "ipmi%d", ifnum);\r\nif (!intf->my_dev_name) {\r\nrv = -ENOMEM;\r\nprintk(KERN_ERR\r\n"ipmi_msghandler: allocate link from BMC: %d\n",\r\nrv);\r\ngoto out_err;\r\n}\r\nrv = sysfs_create_link(&bmc->pdev.dev.kobj, &intf->si_dev->kobj,\r\nintf->my_dev_name);\r\nif (rv) {\r\nkfree(intf->my_dev_name);\r\nintf->my_dev_name = NULL;\r\nprintk(KERN_ERR\r\n"ipmi_msghandler:"\r\n" Unable to create symlink to bmc: %d\n",\r\nrv);\r\ngoto out_err;\r\n}\r\nreturn 0;\r\nout_err:\r\nipmi_bmc_unregister(intf);\r\nreturn rv;\r\n}\r\nstatic int\r\nsend_guid_cmd(ipmi_smi_t intf, int chan)\r\n{\r\nstruct kernel_ipmi_msg msg;\r\nstruct ipmi_system_interface_addr si;\r\nsi.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsi.channel = IPMI_BMC_CHANNEL;\r\nsi.lun = 0;\r\nmsg.netfn = IPMI_NETFN_APP_REQUEST;\r\nmsg.cmd = IPMI_GET_DEVICE_GUID_CMD;\r\nmsg.data = NULL;\r\nmsg.data_len = 0;\r\nreturn i_ipmi_request(NULL,\r\nintf,\r\n(struct ipmi_addr *) &si,\r\n0,\r\n&msg,\r\nintf,\r\nNULL,\r\nNULL,\r\n0,\r\nintf->channels[0].address,\r\nintf->channels[0].lun,\r\n-1, 0);\r\n}\r\nstatic void\r\nguid_handler(ipmi_smi_t intf, struct ipmi_recv_msg *msg)\r\n{\r\nif ((msg->addr.addr_type != IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\r\n|| (msg->msg.netfn != IPMI_NETFN_APP_RESPONSE)\r\n|| (msg->msg.cmd != IPMI_GET_DEVICE_GUID_CMD))\r\nreturn;\r\nif (msg->msg.data[0] != 0) {\r\nintf->bmc->guid_set = 0;\r\ngoto out;\r\n}\r\nif (msg->msg.data_len < 17) {\r\nintf->bmc->guid_set = 0;\r\nprintk(KERN_WARNING PFX\r\n"guid_handler: The GUID response from the BMC was too"\r\n" short, it was %d but should have been 17. Assuming"\r\n" GUID is not available.\n",\r\nmsg->msg.data_len);\r\ngoto out;\r\n}\r\nmemcpy(intf->bmc->guid, msg->msg.data, 16);\r\nintf->bmc->guid_set = 1;\r\nout:\r\nwake_up(&intf->waitq);\r\n}\r\nstatic void\r\nget_guid(ipmi_smi_t intf)\r\n{\r\nint rv;\r\nintf->bmc->guid_set = 0x2;\r\nintf->null_user_handler = guid_handler;\r\nrv = send_guid_cmd(intf, 0);\r\nif (rv)\r\nintf->bmc->guid_set = 0;\r\nwait_event(intf->waitq, intf->bmc->guid_set != 2);\r\nintf->null_user_handler = NULL;\r\n}\r\nstatic int\r\nsend_channel_info_cmd(ipmi_smi_t intf, int chan)\r\n{\r\nstruct kernel_ipmi_msg msg;\r\nunsigned char data[1];\r\nstruct ipmi_system_interface_addr si;\r\nsi.addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsi.channel = IPMI_BMC_CHANNEL;\r\nsi.lun = 0;\r\nmsg.netfn = IPMI_NETFN_APP_REQUEST;\r\nmsg.cmd = IPMI_GET_CHANNEL_INFO_CMD;\r\nmsg.data = data;\r\nmsg.data_len = 1;\r\ndata[0] = chan;\r\nreturn i_ipmi_request(NULL,\r\nintf,\r\n(struct ipmi_addr *) &si,\r\n0,\r\n&msg,\r\nintf,\r\nNULL,\r\nNULL,\r\n0,\r\nintf->channels[0].address,\r\nintf->channels[0].lun,\r\n-1, 0);\r\n}\r\nstatic void\r\nchannel_handler(ipmi_smi_t intf, struct ipmi_recv_msg *msg)\r\n{\r\nint rv = 0;\r\nint chan;\r\nif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\r\n&& (msg->msg.netfn == IPMI_NETFN_APP_RESPONSE)\r\n&& (msg->msg.cmd == IPMI_GET_CHANNEL_INFO_CMD)) {\r\nif (msg->msg.data[0] != 0) {\r\nif (msg->msg.data[0] == IPMI_INVALID_COMMAND_ERR) {\r\nintf->channels[0].medium\r\n= IPMI_CHANNEL_MEDIUM_IPMB;\r\nintf->channels[0].protocol\r\n= IPMI_CHANNEL_PROTOCOL_IPMB;\r\nintf->curr_channel = IPMI_MAX_CHANNELS;\r\nwake_up(&intf->waitq);\r\ngoto out;\r\n}\r\ngoto next_channel;\r\n}\r\nif (msg->msg.data_len < 4) {\r\ngoto next_channel;\r\n}\r\nchan = intf->curr_channel;\r\nintf->channels[chan].medium = msg->msg.data[2] & 0x7f;\r\nintf->channels[chan].protocol = msg->msg.data[3] & 0x1f;\r\nnext_channel:\r\nintf->curr_channel++;\r\nif (intf->curr_channel >= IPMI_MAX_CHANNELS)\r\nwake_up(&intf->waitq);\r\nelse\r\nrv = send_channel_info_cmd(intf, intf->curr_channel);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX\r\n"Error sending channel information for channel"\r\n" %d: %d\n", intf->curr_channel, rv);\r\nintf->curr_channel = IPMI_MAX_CHANNELS;\r\nwake_up(&intf->waitq);\r\n}\r\n}\r\nout:\r\nreturn;\r\n}\r\nstatic void ipmi_poll(ipmi_smi_t intf)\r\n{\r\nif (intf->handlers->poll)\r\nintf->handlers->poll(intf->send_info);\r\nhandle_new_recv_msgs(intf);\r\n}\r\nvoid ipmi_poll_interface(ipmi_user_t user)\r\n{\r\nipmi_poll(user->intf);\r\n}\r\nint ipmi_register_smi(const struct ipmi_smi_handlers *handlers,\r\nvoid *send_info,\r\nstruct ipmi_device_id *device_id,\r\nstruct device *si_dev,\r\nunsigned char slave_addr)\r\n{\r\nint i, j;\r\nint rv;\r\nipmi_smi_t intf;\r\nipmi_smi_t tintf;\r\nstruct list_head *link;\r\nif (!initialized) {\r\nrv = ipmi_init_msghandler();\r\nif (rv)\r\nreturn rv;\r\nif (!initialized)\r\nreturn -ENODEV;\r\n}\r\nintf = kzalloc(sizeof(*intf), GFP_KERNEL);\r\nif (!intf)\r\nreturn -ENOMEM;\r\nintf->ipmi_version_major = ipmi_version_major(device_id);\r\nintf->ipmi_version_minor = ipmi_version_minor(device_id);\r\nintf->bmc = kzalloc(sizeof(*intf->bmc), GFP_KERNEL);\r\nif (!intf->bmc) {\r\nkfree(intf);\r\nreturn -ENOMEM;\r\n}\r\nintf->intf_num = -1;\r\nkref_init(&intf->refcount);\r\nintf->bmc->id = *device_id;\r\nintf->si_dev = si_dev;\r\nfor (j = 0; j < IPMI_MAX_CHANNELS; j++) {\r\nintf->channels[j].address = IPMI_BMC_SLAVE_ADDR;\r\nintf->channels[j].lun = 2;\r\n}\r\nif (slave_addr != 0)\r\nintf->channels[0].address = slave_addr;\r\nINIT_LIST_HEAD(&intf->users);\r\nintf->handlers = handlers;\r\nintf->send_info = send_info;\r\nspin_lock_init(&intf->seq_lock);\r\nfor (j = 0; j < IPMI_IPMB_NUM_SEQ; j++) {\r\nintf->seq_table[j].inuse = 0;\r\nintf->seq_table[j].seqid = 0;\r\n}\r\nintf->curr_seq = 0;\r\n#ifdef CONFIG_PROC_FS\r\nmutex_init(&intf->proc_entry_lock);\r\n#endif\r\nspin_lock_init(&intf->waiting_rcv_msgs_lock);\r\nINIT_LIST_HEAD(&intf->waiting_rcv_msgs);\r\ntasklet_init(&intf->recv_tasklet,\r\nsmi_recv_tasklet,\r\n(unsigned long) intf);\r\natomic_set(&intf->watchdog_pretimeouts_to_deliver, 0);\r\nspin_lock_init(&intf->xmit_msgs_lock);\r\nINIT_LIST_HEAD(&intf->xmit_msgs);\r\nINIT_LIST_HEAD(&intf->hp_xmit_msgs);\r\nspin_lock_init(&intf->events_lock);\r\natomic_set(&intf->event_waiters, 0);\r\nintf->ticks_to_req_ev = IPMI_REQUEST_EV_TIME;\r\nINIT_LIST_HEAD(&intf->waiting_events);\r\nintf->waiting_events_count = 0;\r\nmutex_init(&intf->cmd_rcvrs_mutex);\r\nspin_lock_init(&intf->maintenance_mode_lock);\r\nINIT_LIST_HEAD(&intf->cmd_rcvrs);\r\ninit_waitqueue_head(&intf->waitq);\r\nfor (i = 0; i < IPMI_NUM_STATS; i++)\r\natomic_set(&intf->stats[i], 0);\r\nintf->proc_dir = NULL;\r\nmutex_lock(&smi_watchers_mutex);\r\nmutex_lock(&ipmi_interfaces_mutex);\r\ni = 0;\r\nlink = &ipmi_interfaces;\r\nlist_for_each_entry_rcu(tintf, &ipmi_interfaces, link) {\r\nif (tintf->intf_num != i) {\r\nlink = &tintf->link;\r\nbreak;\r\n}\r\ni++;\r\n}\r\nif (i == 0)\r\nlist_add_rcu(&intf->link, &ipmi_interfaces);\r\nelse\r\nlist_add_tail_rcu(&intf->link, link);\r\nrv = handlers->start_processing(send_info, intf);\r\nif (rv)\r\ngoto out;\r\nget_guid(intf);\r\nif ((intf->ipmi_version_major > 1)\r\n|| ((intf->ipmi_version_major == 1)\r\n&& (intf->ipmi_version_minor >= 5))) {\r\nintf->null_user_handler = channel_handler;\r\nintf->curr_channel = 0;\r\nrv = send_channel_info_cmd(intf, 0);\r\nif (rv) {\r\nprintk(KERN_WARNING PFX\r\n"Error sending channel information for channel"\r\n" 0, %d\n", rv);\r\ngoto out;\r\n}\r\nwait_event(intf->waitq,\r\nintf->curr_channel >= IPMI_MAX_CHANNELS);\r\nintf->null_user_handler = NULL;\r\n} else {\r\nintf->channels[0].medium = IPMI_CHANNEL_MEDIUM_IPMB;\r\nintf->channels[0].protocol = IPMI_CHANNEL_PROTOCOL_IPMB;\r\nintf->curr_channel = IPMI_MAX_CHANNELS;\r\n}\r\nrv = ipmi_bmc_register(intf, i);\r\nif (rv == 0)\r\nrv = add_proc_entries(intf, i);\r\nout:\r\nif (rv) {\r\nif (intf->proc_dir)\r\nremove_proc_entries(intf);\r\nintf->handlers = NULL;\r\nlist_del_rcu(&intf->link);\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nmutex_unlock(&smi_watchers_mutex);\r\nsynchronize_rcu();\r\nkref_put(&intf->refcount, intf_free);\r\n} else {\r\nsmp_wmb();\r\nintf->intf_num = i;\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\ncall_smi_watchers(i, intf->si_dev);\r\nmutex_unlock(&smi_watchers_mutex);\r\n}\r\nreturn rv;\r\n}\r\nstatic void deliver_smi_err_response(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg,\r\nunsigned char err)\r\n{\r\nmsg->rsp[0] = msg->data[0] | 4;\r\nmsg->rsp[1] = msg->data[1];\r\nmsg->rsp[2] = err;\r\nmsg->rsp_size = 3;\r\nhandle_one_recv_msg(intf, msg);\r\n}\r\nstatic void cleanup_smi_msgs(ipmi_smi_t intf)\r\n{\r\nint i;\r\nstruct seq_table *ent;\r\nstruct ipmi_smi_msg *msg;\r\nstruct list_head *entry;\r\nstruct list_head tmplist;\r\nINIT_LIST_HEAD(&tmplist);\r\nlist_splice_tail(&intf->hp_xmit_msgs, &tmplist);\r\nlist_splice_tail(&intf->xmit_msgs, &tmplist);\r\nwhile (intf->curr_msg && !list_empty(&intf->waiting_rcv_msgs)) {\r\nschedule_timeout(1);\r\n}\r\nwhile (!list_empty(&tmplist)) {\r\nentry = tmplist.next;\r\nlist_del(entry);\r\nmsg = list_entry(entry, struct ipmi_smi_msg, link);\r\ndeliver_smi_err_response(intf, msg, IPMI_ERR_UNSPECIFIED);\r\n}\r\nfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++) {\r\nent = &(intf->seq_table[i]);\r\nif (!ent->inuse)\r\ncontinue;\r\ndeliver_err_response(ent->recv_msg, IPMI_ERR_UNSPECIFIED);\r\n}\r\n}\r\nint ipmi_unregister_smi(ipmi_smi_t intf)\r\n{\r\nstruct ipmi_smi_watcher *w;\r\nint intf_num = intf->intf_num;\r\nipmi_user_t user;\r\nmutex_lock(&smi_watchers_mutex);\r\nmutex_lock(&ipmi_interfaces_mutex);\r\nintf->intf_num = -1;\r\nintf->in_shutdown = true;\r\nlist_del_rcu(&intf->link);\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nsynchronize_rcu();\r\ncleanup_smi_msgs(intf);\r\nmutex_lock(&ipmi_interfaces_mutex);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(user, &intf->users, link) {\r\nmodule_put(intf->handlers->owner);\r\nif (intf->handlers->dec_usecount)\r\nintf->handlers->dec_usecount(intf->send_info);\r\n}\r\nrcu_read_unlock();\r\nintf->handlers = NULL;\r\nmutex_unlock(&ipmi_interfaces_mutex);\r\nremove_proc_entries(intf);\r\nipmi_bmc_unregister(intf);\r\nlist_for_each_entry(w, &smi_watchers, link)\r\nw->smi_gone(intf_num);\r\nmutex_unlock(&smi_watchers_mutex);\r\nkref_put(&intf->refcount, intf_free);\r\nreturn 0;\r\n}\r\nstatic int handle_ipmb_get_msg_rsp(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct ipmi_ipmb_addr ipmb_addr;\r\nstruct ipmi_recv_msg *recv_msg;\r\nif (msg->rsp_size < 11) {\r\nipmi_inc_stat(intf, invalid_ipmb_responses);\r\nreturn 0;\r\n}\r\nif (msg->rsp[2] != 0) {\r\nreturn 0;\r\n}\r\nipmb_addr.addr_type = IPMI_IPMB_ADDR_TYPE;\r\nipmb_addr.slave_addr = msg->rsp[6];\r\nipmb_addr.channel = msg->rsp[3] & 0x0f;\r\nipmb_addr.lun = msg->rsp[7] & 3;\r\nif (intf_find_seq(intf,\r\nmsg->rsp[7] >> 2,\r\nmsg->rsp[3] & 0x0f,\r\nmsg->rsp[8],\r\n(msg->rsp[4] >> 2) & (~1),\r\n(struct ipmi_addr *) &(ipmb_addr),\r\n&recv_msg)) {\r\nipmi_inc_stat(intf, unhandled_ipmb_responses);\r\nreturn 0;\r\n}\r\nmemcpy(recv_msg->msg_data,\r\n&(msg->rsp[9]),\r\nmsg->rsp_size - 9);\r\nrecv_msg->msg.netfn = msg->rsp[4] >> 2;\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 10;\r\nrecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\r\nipmi_inc_stat(intf, handled_ipmb_responses);\r\ndeliver_response(recv_msg);\r\nreturn 0;\r\n}\r\nstatic int handle_ipmb_get_msg_cmd(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct cmd_rcvr *rcvr;\r\nint rv = 0;\r\nunsigned char netfn;\r\nunsigned char cmd;\r\nunsigned char chan;\r\nipmi_user_t user = NULL;\r\nstruct ipmi_ipmb_addr *ipmb_addr;\r\nstruct ipmi_recv_msg *recv_msg;\r\nif (msg->rsp_size < 10) {\r\nipmi_inc_stat(intf, invalid_commands);\r\nreturn 0;\r\n}\r\nif (msg->rsp[2] != 0) {\r\nreturn 0;\r\n}\r\nnetfn = msg->rsp[4] >> 2;\r\ncmd = msg->rsp[8];\r\nchan = msg->rsp[3] & 0xf;\r\nrcu_read_lock();\r\nrcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\r\nif (rcvr) {\r\nuser = rcvr->user;\r\nkref_get(&user->refcount);\r\n} else\r\nuser = NULL;\r\nrcu_read_unlock();\r\nif (user == NULL) {\r\nipmi_inc_stat(intf, unhandled_commands);\r\nmsg->data[0] = (IPMI_NETFN_APP_REQUEST << 2);\r\nmsg->data[1] = IPMI_SEND_MSG_CMD;\r\nmsg->data[2] = msg->rsp[3];\r\nmsg->data[3] = msg->rsp[6];\r\nmsg->data[4] = ((netfn + 1) << 2) | (msg->rsp[7] & 0x3);\r\nmsg->data[5] = ipmb_checksum(&(msg->data[3]), 2);\r\nmsg->data[6] = intf->channels[msg->rsp[3] & 0xf].address;\r\nmsg->data[7] = (msg->rsp[7] & 0xfc) | (msg->rsp[4] & 0x3);\r\nmsg->data[8] = msg->rsp[8];\r\nmsg->data[9] = IPMI_INVALID_CMD_COMPLETION_CODE;\r\nmsg->data[10] = ipmb_checksum(&(msg->data[6]), 4);\r\nmsg->data_size = 11;\r\n#ifdef DEBUG_MSGING\r\n{\r\nint m;\r\nprintk("Invalid command:");\r\nfor (m = 0; m < msg->data_size; m++)\r\nprintk(" %2.2x", msg->data[m]);\r\nprintk("\n");\r\n}\r\n#endif\r\nrcu_read_lock();\r\nif (!intf->in_shutdown) {\r\nsmi_send(intf, intf->handlers, msg, 0);\r\nrv = -1;\r\n}\r\nrcu_read_unlock();\r\n} else {\r\nipmi_inc_stat(intf, handled_commands);\r\nrecv_msg = ipmi_alloc_recv_msg();\r\nif (!recv_msg) {\r\nrv = 1;\r\nkref_put(&user->refcount, free_user);\r\n} else {\r\nipmb_addr = (struct ipmi_ipmb_addr *) &recv_msg->addr;\r\nipmb_addr->addr_type = IPMI_IPMB_ADDR_TYPE;\r\nipmb_addr->slave_addr = msg->rsp[6];\r\nipmb_addr->lun = msg->rsp[7] & 3;\r\nipmb_addr->channel = msg->rsp[3] & 0xf;\r\nrecv_msg->user = user;\r\nrecv_msg->recv_type = IPMI_CMD_RECV_TYPE;\r\nrecv_msg->msgid = msg->rsp[7] >> 2;\r\nrecv_msg->msg.netfn = msg->rsp[4] >> 2;\r\nrecv_msg->msg.cmd = msg->rsp[8];\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 10;\r\nmemcpy(recv_msg->msg_data,\r\n&(msg->rsp[9]),\r\nmsg->rsp_size - 10);\r\ndeliver_response(recv_msg);\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int handle_lan_get_msg_rsp(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct ipmi_lan_addr lan_addr;\r\nstruct ipmi_recv_msg *recv_msg;\r\nif (msg->rsp_size < 13) {\r\nipmi_inc_stat(intf, invalid_lan_responses);\r\nreturn 0;\r\n}\r\nif (msg->rsp[2] != 0) {\r\nreturn 0;\r\n}\r\nlan_addr.addr_type = IPMI_LAN_ADDR_TYPE;\r\nlan_addr.session_handle = msg->rsp[4];\r\nlan_addr.remote_SWID = msg->rsp[8];\r\nlan_addr.local_SWID = msg->rsp[5];\r\nlan_addr.channel = msg->rsp[3] & 0x0f;\r\nlan_addr.privilege = msg->rsp[3] >> 4;\r\nlan_addr.lun = msg->rsp[9] & 3;\r\nif (intf_find_seq(intf,\r\nmsg->rsp[9] >> 2,\r\nmsg->rsp[3] & 0x0f,\r\nmsg->rsp[10],\r\n(msg->rsp[6] >> 2) & (~1),\r\n(struct ipmi_addr *) &(lan_addr),\r\n&recv_msg)) {\r\nipmi_inc_stat(intf, unhandled_lan_responses);\r\nreturn 0;\r\n}\r\nmemcpy(recv_msg->msg_data,\r\n&(msg->rsp[11]),\r\nmsg->rsp_size - 11);\r\nrecv_msg->msg.netfn = msg->rsp[6] >> 2;\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 12;\r\nrecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\r\nipmi_inc_stat(intf, handled_lan_responses);\r\ndeliver_response(recv_msg);\r\nreturn 0;\r\n}\r\nstatic int handle_lan_get_msg_cmd(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct cmd_rcvr *rcvr;\r\nint rv = 0;\r\nunsigned char netfn;\r\nunsigned char cmd;\r\nunsigned char chan;\r\nipmi_user_t user = NULL;\r\nstruct ipmi_lan_addr *lan_addr;\r\nstruct ipmi_recv_msg *recv_msg;\r\nif (msg->rsp_size < 12) {\r\nipmi_inc_stat(intf, invalid_commands);\r\nreturn 0;\r\n}\r\nif (msg->rsp[2] != 0) {\r\nreturn 0;\r\n}\r\nnetfn = msg->rsp[6] >> 2;\r\ncmd = msg->rsp[10];\r\nchan = msg->rsp[3] & 0xf;\r\nrcu_read_lock();\r\nrcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\r\nif (rcvr) {\r\nuser = rcvr->user;\r\nkref_get(&user->refcount);\r\n} else\r\nuser = NULL;\r\nrcu_read_unlock();\r\nif (user == NULL) {\r\nipmi_inc_stat(intf, unhandled_commands);\r\nrv = 0;\r\n} else {\r\nipmi_inc_stat(intf, handled_commands);\r\nrecv_msg = ipmi_alloc_recv_msg();\r\nif (!recv_msg) {\r\nrv = 1;\r\nkref_put(&user->refcount, free_user);\r\n} else {\r\nlan_addr = (struct ipmi_lan_addr *) &recv_msg->addr;\r\nlan_addr->addr_type = IPMI_LAN_ADDR_TYPE;\r\nlan_addr->session_handle = msg->rsp[4];\r\nlan_addr->remote_SWID = msg->rsp[8];\r\nlan_addr->local_SWID = msg->rsp[5];\r\nlan_addr->lun = msg->rsp[9] & 3;\r\nlan_addr->channel = msg->rsp[3] & 0xf;\r\nlan_addr->privilege = msg->rsp[3] >> 4;\r\nrecv_msg->user = user;\r\nrecv_msg->recv_type = IPMI_CMD_RECV_TYPE;\r\nrecv_msg->msgid = msg->rsp[9] >> 2;\r\nrecv_msg->msg.netfn = msg->rsp[6] >> 2;\r\nrecv_msg->msg.cmd = msg->rsp[10];\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 12;\r\nmemcpy(recv_msg->msg_data,\r\n&(msg->rsp[11]),\r\nmsg->rsp_size - 12);\r\ndeliver_response(recv_msg);\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic int handle_oem_get_msg_cmd(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct cmd_rcvr *rcvr;\r\nint rv = 0;\r\nunsigned char netfn;\r\nunsigned char cmd;\r\nunsigned char chan;\r\nipmi_user_t user = NULL;\r\nstruct ipmi_system_interface_addr *smi_addr;\r\nstruct ipmi_recv_msg *recv_msg;\r\nif (msg->rsp_size < 4) {\r\nipmi_inc_stat(intf, invalid_commands);\r\nreturn 0;\r\n}\r\nif (msg->rsp[2] != 0) {\r\nreturn 0;\r\n}\r\nnetfn = msg->rsp[0] >> 2;\r\ncmd = msg->rsp[1];\r\nchan = msg->rsp[3] & 0xf;\r\nrcu_read_lock();\r\nrcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\r\nif (rcvr) {\r\nuser = rcvr->user;\r\nkref_get(&user->refcount);\r\n} else\r\nuser = NULL;\r\nrcu_read_unlock();\r\nif (user == NULL) {\r\nipmi_inc_stat(intf, unhandled_commands);\r\nrv = 0;\r\n} else {\r\nipmi_inc_stat(intf, handled_commands);\r\nrecv_msg = ipmi_alloc_recv_msg();\r\nif (!recv_msg) {\r\nrv = 1;\r\nkref_put(&user->refcount, free_user);\r\n} else {\r\nsmi_addr = ((struct ipmi_system_interface_addr *)\r\n&(recv_msg->addr));\r\nsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr->channel = IPMI_BMC_CHANNEL;\r\nsmi_addr->lun = msg->rsp[0] & 3;\r\nrecv_msg->user = user;\r\nrecv_msg->user_msg_data = NULL;\r\nrecv_msg->recv_type = IPMI_OEM_RECV_TYPE;\r\nrecv_msg->msg.netfn = msg->rsp[0] >> 2;\r\nrecv_msg->msg.cmd = msg->rsp[1];\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 4;\r\nmemcpy(recv_msg->msg_data,\r\n&(msg->rsp[4]),\r\nmsg->rsp_size - 4);\r\ndeliver_response(recv_msg);\r\n}\r\n}\r\nreturn rv;\r\n}\r\nstatic void copy_event_into_recv_msg(struct ipmi_recv_msg *recv_msg,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct ipmi_system_interface_addr *smi_addr;\r\nrecv_msg->msgid = 0;\r\nsmi_addr = (struct ipmi_system_interface_addr *) &(recv_msg->addr);\r\nsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr->channel = IPMI_BMC_CHANNEL;\r\nsmi_addr->lun = msg->rsp[0] & 3;\r\nrecv_msg->recv_type = IPMI_ASYNC_EVENT_RECV_TYPE;\r\nrecv_msg->msg.netfn = msg->rsp[0] >> 2;\r\nrecv_msg->msg.cmd = msg->rsp[1];\r\nmemcpy(recv_msg->msg_data, &(msg->rsp[3]), msg->rsp_size - 3);\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 3;\r\n}\r\nstatic int handle_read_event_rsp(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct ipmi_recv_msg *recv_msg, *recv_msg2;\r\nstruct list_head msgs;\r\nipmi_user_t user;\r\nint rv = 0;\r\nint deliver_count = 0;\r\nunsigned long flags;\r\nif (msg->rsp_size < 19) {\r\nipmi_inc_stat(intf, invalid_events);\r\nreturn 0;\r\n}\r\nif (msg->rsp[2] != 0) {\r\nreturn 0;\r\n}\r\nINIT_LIST_HEAD(&msgs);\r\nspin_lock_irqsave(&intf->events_lock, flags);\r\nipmi_inc_stat(intf, events);\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(user, &intf->users, link) {\r\nif (!user->gets_events)\r\ncontinue;\r\nrecv_msg = ipmi_alloc_recv_msg();\r\nif (!recv_msg) {\r\nrcu_read_unlock();\r\nlist_for_each_entry_safe(recv_msg, recv_msg2, &msgs,\r\nlink) {\r\nlist_del(&recv_msg->link);\r\nipmi_free_recv_msg(recv_msg);\r\n}\r\nrv = 1;\r\ngoto out;\r\n}\r\ndeliver_count++;\r\ncopy_event_into_recv_msg(recv_msg, msg);\r\nrecv_msg->user = user;\r\nkref_get(&user->refcount);\r\nlist_add_tail(&(recv_msg->link), &msgs);\r\n}\r\nrcu_read_unlock();\r\nif (deliver_count) {\r\nlist_for_each_entry_safe(recv_msg, recv_msg2, &msgs, link) {\r\nlist_del(&recv_msg->link);\r\ndeliver_response(recv_msg);\r\n}\r\n} else if (intf->waiting_events_count < MAX_EVENTS_IN_QUEUE) {\r\nrecv_msg = ipmi_alloc_recv_msg();\r\nif (!recv_msg) {\r\nrv = 1;\r\ngoto out;\r\n}\r\ncopy_event_into_recv_msg(recv_msg, msg);\r\nlist_add_tail(&(recv_msg->link), &(intf->waiting_events));\r\nintf->waiting_events_count++;\r\n} else if (!intf->event_msg_printed) {\r\nprintk(KERN_WARNING PFX "Event queue full, discarding"\r\n" incoming events\n");\r\nintf->event_msg_printed = 1;\r\n}\r\nout:\r\nspin_unlock_irqrestore(&(intf->events_lock), flags);\r\nreturn rv;\r\n}\r\nstatic int handle_bmc_rsp(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nstruct ipmi_recv_msg *recv_msg;\r\nstruct ipmi_user *user;\r\nrecv_msg = (struct ipmi_recv_msg *) msg->user_data;\r\nif (recv_msg == NULL) {\r\nprintk(KERN_WARNING\r\n"IPMI message received with no owner. This\n"\r\n"could be because of a malformed message, or\n"\r\n"because of a hardware error. Contact your\n"\r\n"hardware vender for assistance\n");\r\nreturn 0;\r\n}\r\nuser = recv_msg->user;\r\nif (user && !user->valid) {\r\nipmi_inc_stat(intf, unhandled_local_responses);\r\nipmi_free_recv_msg(recv_msg);\r\n} else {\r\nstruct ipmi_system_interface_addr *smi_addr;\r\nipmi_inc_stat(intf, handled_local_responses);\r\nrecv_msg->recv_type = IPMI_RESPONSE_RECV_TYPE;\r\nrecv_msg->msgid = msg->msgid;\r\nsmi_addr = ((struct ipmi_system_interface_addr *)\r\n&(recv_msg->addr));\r\nsmi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsmi_addr->channel = IPMI_BMC_CHANNEL;\r\nsmi_addr->lun = msg->rsp[0] & 3;\r\nrecv_msg->msg.netfn = msg->rsp[0] >> 2;\r\nrecv_msg->msg.cmd = msg->rsp[1];\r\nmemcpy(recv_msg->msg_data,\r\n&(msg->rsp[2]),\r\nmsg->rsp_size - 2);\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = msg->rsp_size - 2;\r\ndeliver_response(recv_msg);\r\n}\r\nreturn 0;\r\n}\r\nstatic int handle_one_recv_msg(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nint requeue;\r\nint chan;\r\n#ifdef DEBUG_MSGING\r\nint m;\r\nprintk("Recv:");\r\nfor (m = 0; m < msg->rsp_size; m++)\r\nprintk(" %2.2x", msg->rsp[m]);\r\nprintk("\n");\r\n#endif\r\nif (msg->rsp_size < 2) {\r\nprintk(KERN_WARNING PFX "BMC returned to small a message"\r\n" for netfn %x cmd %x, got %d bytes\n",\r\n(msg->data[0] >> 2) | 1, msg->data[1], msg->rsp_size);\r\nmsg->rsp[0] = msg->data[0] | (1 << 2);\r\nmsg->rsp[1] = msg->data[1];\r\nmsg->rsp[2] = IPMI_ERR_UNSPECIFIED;\r\nmsg->rsp_size = 3;\r\n} else if (((msg->rsp[0] >> 2) != ((msg->data[0] >> 2) | 1))\r\n|| (msg->rsp[1] != msg->data[1])) {\r\nprintk(KERN_WARNING PFX "BMC returned incorrect response,"\r\n" expected netfn %x cmd %x, got netfn %x cmd %x\n",\r\n(msg->data[0] >> 2) | 1, msg->data[1],\r\nmsg->rsp[0] >> 2, msg->rsp[1]);\r\nmsg->rsp[0] = msg->data[0] | (1 << 2);\r\nmsg->rsp[1] = msg->data[1];\r\nmsg->rsp[2] = IPMI_ERR_UNSPECIFIED;\r\nmsg->rsp_size = 3;\r\n}\r\nif ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))\r\n&& (msg->rsp[1] == IPMI_SEND_MSG_CMD)\r\n&& (msg->user_data != NULL)) {\r\nstruct ipmi_recv_msg *recv_msg = msg->user_data;\r\nrequeue = 0;\r\nif (msg->rsp_size < 2)\r\ngoto out;\r\nchan = msg->data[2] & 0x0f;\r\nif (chan >= IPMI_MAX_CHANNELS)\r\ngoto out;\r\nif (!recv_msg)\r\ngoto out;\r\nif (!recv_msg->user || !recv_msg->user->valid)\r\ngoto out;\r\nrecv_msg->recv_type = IPMI_RESPONSE_RESPONSE_TYPE;\r\nrecv_msg->msg.data = recv_msg->msg_data;\r\nrecv_msg->msg.data_len = 1;\r\nrecv_msg->msg_data[0] = msg->rsp[2];\r\ndeliver_response(recv_msg);\r\n} else if ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))\r\n&& (msg->rsp[1] == IPMI_GET_MSG_CMD)) {\r\nchan = msg->rsp[3] & 0xf;\r\nif (chan >= IPMI_MAX_CHANNELS) {\r\nrequeue = 0;\r\ngoto out;\r\n}\r\nif (intf->curr_channel < IPMI_MAX_CHANNELS) {\r\nrequeue = 0;\r\ngoto out;\r\n}\r\nswitch (intf->channels[chan].medium) {\r\ncase IPMI_CHANNEL_MEDIUM_IPMB:\r\nif (msg->rsp[4] & 0x04) {\r\nrequeue = handle_ipmb_get_msg_rsp(intf, msg);\r\n} else {\r\nrequeue = handle_ipmb_get_msg_cmd(intf, msg);\r\n}\r\nbreak;\r\ncase IPMI_CHANNEL_MEDIUM_8023LAN:\r\ncase IPMI_CHANNEL_MEDIUM_ASYNC:\r\nif (msg->rsp[6] & 0x04) {\r\nrequeue = handle_lan_get_msg_rsp(intf, msg);\r\n} else {\r\nrequeue = handle_lan_get_msg_cmd(intf, msg);\r\n}\r\nbreak;\r\ndefault:\r\nif ((intf->channels[chan].medium\r\n>= IPMI_CHANNEL_MEDIUM_OEM_MIN)\r\n&& (intf->channels[chan].medium\r\n<= IPMI_CHANNEL_MEDIUM_OEM_MAX)) {\r\nrequeue = handle_oem_get_msg_cmd(intf, msg);\r\n} else {\r\nrequeue = 0;\r\n}\r\n}\r\n} else if ((msg->rsp[0] == ((IPMI_NETFN_APP_REQUEST|1) << 2))\r\n&& (msg->rsp[1] == IPMI_READ_EVENT_MSG_BUFFER_CMD)) {\r\nrequeue = handle_read_event_rsp(intf, msg);\r\n} else {\r\nrequeue = handle_bmc_rsp(intf, msg);\r\n}\r\nout:\r\nreturn requeue;\r\n}\r\nstatic void handle_new_recv_msgs(ipmi_smi_t intf)\r\n{\r\nstruct ipmi_smi_msg *smi_msg;\r\nunsigned long flags = 0;\r\nint rv;\r\nint run_to_completion = intf->run_to_completion;\r\nif (!run_to_completion)\r\nspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\r\nwhile (!list_empty(&intf->waiting_rcv_msgs)) {\r\nsmi_msg = list_entry(intf->waiting_rcv_msgs.next,\r\nstruct ipmi_smi_msg, link);\r\nlist_del(&smi_msg->link);\r\nif (!run_to_completion)\r\nspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock,\r\nflags);\r\nrv = handle_one_recv_msg(intf, smi_msg);\r\nif (!run_to_completion)\r\nspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\r\nif (rv > 0) {\r\nlist_add(&smi_msg->link, &intf->waiting_rcv_msgs);\r\nbreak;\r\n} else {\r\nif (rv == 0)\r\nipmi_free_smi_msg(smi_msg);\r\n}\r\n}\r\nif (!run_to_completion)\r\nspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock, flags);\r\nif (atomic_add_unless(&intf->watchdog_pretimeouts_to_deliver, -1, 0)) {\r\nipmi_user_t user;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(user, &intf->users, link) {\r\nif (user->handler->ipmi_watchdog_pretimeout)\r\nuser->handler->ipmi_watchdog_pretimeout(\r\nuser->handler_data);\r\n}\r\nrcu_read_unlock();\r\n}\r\n}\r\nstatic void smi_recv_tasklet(unsigned long val)\r\n{\r\nunsigned long flags = 0;\r\nipmi_smi_t intf = (ipmi_smi_t) val;\r\nint run_to_completion = intf->run_to_completion;\r\nstruct ipmi_smi_msg *newmsg = NULL;\r\nif (!run_to_completion)\r\nspin_lock_irqsave(&intf->xmit_msgs_lock, flags);\r\nif (intf->curr_msg == NULL && !intf->in_shutdown) {\r\nstruct list_head *entry = NULL;\r\nif (!list_empty(&intf->hp_xmit_msgs))\r\nentry = intf->hp_xmit_msgs.next;\r\nelse if (!list_empty(&intf->xmit_msgs))\r\nentry = intf->xmit_msgs.next;\r\nif (entry) {\r\nlist_del(entry);\r\nnewmsg = list_entry(entry, struct ipmi_smi_msg, link);\r\nintf->curr_msg = newmsg;\r\n}\r\n}\r\nif (!run_to_completion)\r\nspin_unlock_irqrestore(&intf->xmit_msgs_lock, flags);\r\nif (newmsg)\r\nintf->handlers->sender(intf->send_info, newmsg);\r\nhandle_new_recv_msgs(intf);\r\n}\r\nvoid ipmi_smi_msg_received(ipmi_smi_t intf,\r\nstruct ipmi_smi_msg *msg)\r\n{\r\nunsigned long flags = 0;\r\nint run_to_completion = intf->run_to_completion;\r\nif ((msg->data_size >= 2)\r\n&& (msg->data[0] == (IPMI_NETFN_APP_REQUEST << 2))\r\n&& (msg->data[1] == IPMI_SEND_MSG_CMD)\r\n&& (msg->user_data == NULL)) {\r\nif (intf->in_shutdown)\r\ngoto free_msg;\r\nif ((msg->rsp_size >= 3) && (msg->rsp[2] != 0)\r\n&& (msg->rsp[2] != IPMI_NODE_BUSY_ERR)\r\n&& (msg->rsp[2] != IPMI_LOST_ARBITRATION_ERR)\r\n&& (msg->rsp[2] != IPMI_BUS_ERR)\r\n&& (msg->rsp[2] != IPMI_NAK_ON_WRITE_ERR)) {\r\nint chan = msg->rsp[3] & 0xf;\r\nif (chan >= IPMI_MAX_CHANNELS)\r\n;\r\nelse if ((intf->channels[chan].medium\r\n== IPMI_CHANNEL_MEDIUM_8023LAN)\r\n|| (intf->channels[chan].medium\r\n== IPMI_CHANNEL_MEDIUM_ASYNC))\r\nipmi_inc_stat(intf, sent_lan_command_errs);\r\nelse\r\nipmi_inc_stat(intf, sent_ipmb_command_errs);\r\nintf_err_seq(intf, msg->msgid, msg->rsp[2]);\r\n} else\r\nintf_start_seq_timer(intf, msg->msgid);\r\nfree_msg:\r\nipmi_free_smi_msg(msg);\r\n} else {\r\nif (!run_to_completion)\r\nspin_lock_irqsave(&intf->waiting_rcv_msgs_lock, flags);\r\nlist_add_tail(&msg->link, &intf->waiting_rcv_msgs);\r\nif (!run_to_completion)\r\nspin_unlock_irqrestore(&intf->waiting_rcv_msgs_lock,\r\nflags);\r\n}\r\nif (!run_to_completion)\r\nspin_lock_irqsave(&intf->xmit_msgs_lock, flags);\r\nif (msg == intf->curr_msg)\r\nintf->curr_msg = NULL;\r\nif (!run_to_completion)\r\nspin_unlock_irqrestore(&intf->xmit_msgs_lock, flags);\r\nif (run_to_completion)\r\nsmi_recv_tasklet((unsigned long) intf);\r\nelse\r\ntasklet_schedule(&intf->recv_tasklet);\r\n}\r\nvoid ipmi_smi_watchdog_pretimeout(ipmi_smi_t intf)\r\n{\r\nif (intf->in_shutdown)\r\nreturn;\r\natomic_set(&intf->watchdog_pretimeouts_to_deliver, 1);\r\ntasklet_schedule(&intf->recv_tasklet);\r\n}\r\nstatic struct ipmi_smi_msg *\r\nsmi_from_recv_msg(ipmi_smi_t intf, struct ipmi_recv_msg *recv_msg,\r\nunsigned char seq, long seqid)\r\n{\r\nstruct ipmi_smi_msg *smi_msg = ipmi_alloc_smi_msg();\r\nif (!smi_msg)\r\nreturn NULL;\r\nmemcpy(smi_msg->data, recv_msg->msg.data, recv_msg->msg.data_len);\r\nsmi_msg->data_size = recv_msg->msg.data_len;\r\nsmi_msg->msgid = STORE_SEQ_IN_MSGID(seq, seqid);\r\n#ifdef DEBUG_MSGING\r\n{\r\nint m;\r\nprintk("Resend: ");\r\nfor (m = 0; m < smi_msg->data_size; m++)\r\nprintk(" %2.2x", smi_msg->data[m]);\r\nprintk("\n");\r\n}\r\n#endif\r\nreturn smi_msg;\r\n}\r\nstatic void check_msg_timeout(ipmi_smi_t intf, struct seq_table *ent,\r\nstruct list_head *timeouts, long timeout_period,\r\nint slot, unsigned long *flags,\r\nunsigned int *waiting_msgs)\r\n{\r\nstruct ipmi_recv_msg *msg;\r\nconst struct ipmi_smi_handlers *handlers;\r\nif (intf->in_shutdown)\r\nreturn;\r\nif (!ent->inuse)\r\nreturn;\r\nent->timeout -= timeout_period;\r\nif (ent->timeout > 0) {\r\n(*waiting_msgs)++;\r\nreturn;\r\n}\r\nif (ent->retries_left == 0) {\r\nent->inuse = 0;\r\nmsg = ent->recv_msg;\r\nlist_add_tail(&msg->link, timeouts);\r\nif (ent->broadcast)\r\nipmi_inc_stat(intf, timed_out_ipmb_broadcasts);\r\nelse if (is_lan_addr(&ent->recv_msg->addr))\r\nipmi_inc_stat(intf, timed_out_lan_commands);\r\nelse\r\nipmi_inc_stat(intf, timed_out_ipmb_commands);\r\n} else {\r\nstruct ipmi_smi_msg *smi_msg;\r\n(*waiting_msgs)++;\r\nent->timeout = MAX_MSG_TIMEOUT;\r\nent->retries_left--;\r\nsmi_msg = smi_from_recv_msg(intf, ent->recv_msg, slot,\r\nent->seqid);\r\nif (!smi_msg) {\r\nif (is_lan_addr(&ent->recv_msg->addr))\r\nipmi_inc_stat(intf,\r\ndropped_rexmit_lan_commands);\r\nelse\r\nipmi_inc_stat(intf,\r\ndropped_rexmit_ipmb_commands);\r\nreturn;\r\n}\r\nspin_unlock_irqrestore(&intf->seq_lock, *flags);\r\nhandlers = intf->handlers;\r\nif (handlers) {\r\nif (is_lan_addr(&ent->recv_msg->addr))\r\nipmi_inc_stat(intf,\r\nretransmitted_lan_commands);\r\nelse\r\nipmi_inc_stat(intf,\r\nretransmitted_ipmb_commands);\r\nsmi_send(intf, handlers, smi_msg, 0);\r\n} else\r\nipmi_free_smi_msg(smi_msg);\r\nspin_lock_irqsave(&intf->seq_lock, *flags);\r\n}\r\n}\r\nstatic unsigned int ipmi_timeout_handler(ipmi_smi_t intf, long timeout_period)\r\n{\r\nstruct list_head timeouts;\r\nstruct ipmi_recv_msg *msg, *msg2;\r\nunsigned long flags;\r\nint i;\r\nunsigned int waiting_msgs = 0;\r\nINIT_LIST_HEAD(&timeouts);\r\nspin_lock_irqsave(&intf->seq_lock, flags);\r\nfor (i = 0; i < IPMI_IPMB_NUM_SEQ; i++)\r\ncheck_msg_timeout(intf, &(intf->seq_table[i]),\r\n&timeouts, timeout_period, i,\r\n&flags, &waiting_msgs);\r\nspin_unlock_irqrestore(&intf->seq_lock, flags);\r\nlist_for_each_entry_safe(msg, msg2, &timeouts, link)\r\ndeliver_err_response(msg, IPMI_TIMEOUT_COMPLETION_CODE);\r\nif (intf->auto_maintenance_timeout > 0) {\r\nspin_lock_irqsave(&intf->maintenance_mode_lock, flags);\r\nif (intf->auto_maintenance_timeout > 0) {\r\nintf->auto_maintenance_timeout\r\n-= timeout_period;\r\nif (!intf->maintenance_mode\r\n&& (intf->auto_maintenance_timeout <= 0)) {\r\nintf->maintenance_mode_enable = false;\r\nmaintenance_mode_update(intf);\r\n}\r\n}\r\nspin_unlock_irqrestore(&intf->maintenance_mode_lock,\r\nflags);\r\n}\r\ntasklet_schedule(&intf->recv_tasklet);\r\nreturn waiting_msgs;\r\n}\r\nstatic void ipmi_request_event(ipmi_smi_t intf)\r\n{\r\nif (intf->maintenance_mode_enable)\r\nreturn;\r\nif (!intf->in_shutdown)\r\nintf->handlers->request_events(intf->send_info);\r\n}\r\nstatic void ipmi_timeout(unsigned long data)\r\n{\r\nipmi_smi_t intf;\r\nint nt = 0;\r\nif (atomic_read(&stop_operation))\r\nreturn;\r\nrcu_read_lock();\r\nlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\r\nint lnt = 0;\r\nif (atomic_read(&intf->event_waiters)) {\r\nintf->ticks_to_req_ev--;\r\nif (intf->ticks_to_req_ev == 0) {\r\nipmi_request_event(intf);\r\nintf->ticks_to_req_ev = IPMI_REQUEST_EV_TIME;\r\n}\r\nlnt++;\r\n}\r\nlnt += ipmi_timeout_handler(intf, IPMI_TIMEOUT_TIME);\r\nlnt = !!lnt;\r\nif (lnt != intf->last_needs_timer &&\r\nintf->handlers->set_need_watch)\r\nintf->handlers->set_need_watch(intf->send_info, lnt);\r\nintf->last_needs_timer = lnt;\r\nnt += lnt;\r\n}\r\nrcu_read_unlock();\r\nif (nt)\r\nmod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);\r\n}\r\nstatic void need_waiter(ipmi_smi_t intf)\r\n{\r\nif (!timer_pending(&ipmi_timer))\r\nmod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);\r\n}\r\nstatic void free_smi_msg(struct ipmi_smi_msg *msg)\r\n{\r\natomic_dec(&smi_msg_inuse_count);\r\nkfree(msg);\r\n}\r\nstruct ipmi_smi_msg *ipmi_alloc_smi_msg(void)\r\n{\r\nstruct ipmi_smi_msg *rv;\r\nrv = kmalloc(sizeof(struct ipmi_smi_msg), GFP_ATOMIC);\r\nif (rv) {\r\nrv->done = free_smi_msg;\r\nrv->user_data = NULL;\r\natomic_inc(&smi_msg_inuse_count);\r\n}\r\nreturn rv;\r\n}\r\nstatic void free_recv_msg(struct ipmi_recv_msg *msg)\r\n{\r\natomic_dec(&recv_msg_inuse_count);\r\nkfree(msg);\r\n}\r\nstatic struct ipmi_recv_msg *ipmi_alloc_recv_msg(void)\r\n{\r\nstruct ipmi_recv_msg *rv;\r\nrv = kmalloc(sizeof(struct ipmi_recv_msg), GFP_ATOMIC);\r\nif (rv) {\r\nrv->user = NULL;\r\nrv->done = free_recv_msg;\r\natomic_inc(&recv_msg_inuse_count);\r\n}\r\nreturn rv;\r\n}\r\nvoid ipmi_free_recv_msg(struct ipmi_recv_msg *msg)\r\n{\r\nif (msg->user)\r\nkref_put(&msg->user->refcount, free_user);\r\nmsg->done(msg);\r\n}\r\nstatic void dummy_smi_done_handler(struct ipmi_smi_msg *msg)\r\n{\r\natomic_dec(&panic_done_count);\r\n}\r\nstatic void dummy_recv_done_handler(struct ipmi_recv_msg *msg)\r\n{\r\natomic_dec(&panic_done_count);\r\n}\r\nstatic void ipmi_panic_request_and_wait(ipmi_smi_t intf,\r\nstruct ipmi_addr *addr,\r\nstruct kernel_ipmi_msg *msg)\r\n{\r\nstruct ipmi_smi_msg smi_msg;\r\nstruct ipmi_recv_msg recv_msg;\r\nint rv;\r\nsmi_msg.done = dummy_smi_done_handler;\r\nrecv_msg.done = dummy_recv_done_handler;\r\natomic_add(2, &panic_done_count);\r\nrv = i_ipmi_request(NULL,\r\nintf,\r\naddr,\r\n0,\r\nmsg,\r\nintf,\r\n&smi_msg,\r\n&recv_msg,\r\n0,\r\nintf->channels[0].address,\r\nintf->channels[0].lun,\r\n0, 1);\r\nif (rv)\r\natomic_sub(2, &panic_done_count);\r\nelse if (intf->handlers->flush_messages)\r\nintf->handlers->flush_messages(intf->send_info);\r\nwhile (atomic_read(&panic_done_count) != 0)\r\nipmi_poll(intf);\r\n}\r\nstatic void event_receiver_fetcher(ipmi_smi_t intf, struct ipmi_recv_msg *msg)\r\n{\r\nif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\r\n&& (msg->msg.netfn == IPMI_NETFN_SENSOR_EVENT_RESPONSE)\r\n&& (msg->msg.cmd == IPMI_GET_EVENT_RECEIVER_CMD)\r\n&& (msg->msg.data[0] == IPMI_CC_NO_ERROR)) {\r\nintf->event_receiver = msg->msg.data[1];\r\nintf->event_receiver_lun = msg->msg.data[2] & 0x3;\r\n}\r\n}\r\nstatic void device_id_fetcher(ipmi_smi_t intf, struct ipmi_recv_msg *msg)\r\n{\r\nif ((msg->addr.addr_type == IPMI_SYSTEM_INTERFACE_ADDR_TYPE)\r\n&& (msg->msg.netfn == IPMI_NETFN_APP_RESPONSE)\r\n&& (msg->msg.cmd == IPMI_GET_DEVICE_ID_CMD)\r\n&& (msg->msg.data[0] == IPMI_CC_NO_ERROR)) {\r\nintf->local_sel_device = (msg->msg.data[6] >> 2) & 1;\r\nintf->local_event_generator = (msg->msg.data[6] >> 5) & 1;\r\n}\r\n}\r\nstatic void send_panic_events(char *str)\r\n{\r\nstruct kernel_ipmi_msg msg;\r\nipmi_smi_t intf;\r\nunsigned char data[16];\r\nstruct ipmi_system_interface_addr *si;\r\nstruct ipmi_addr addr;\r\nsi = (struct ipmi_system_interface_addr *) &addr;\r\nsi->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsi->channel = IPMI_BMC_CHANNEL;\r\nsi->lun = 0;\r\nmsg.netfn = 0x04;\r\nmsg.cmd = 2;\r\nmsg.data = data;\r\nmsg.data_len = 8;\r\ndata[0] = 0x41;\r\ndata[1] = 0x03;\r\ndata[2] = 0x20;\r\ndata[4] = 0x6f;\r\ndata[5] = 0xa1;\r\nif (str) {\r\ndata[3] = str[0];\r\ndata[6] = str[1];\r\ndata[7] = str[2];\r\n}\r\nlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\r\nif (!intf->handlers)\r\ncontinue;\r\nipmi_panic_request_and_wait(intf, &addr, &msg);\r\n}\r\n#ifdef CONFIG_IPMI_PANIC_STRING\r\nif (!str)\r\nreturn;\r\nlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\r\nchar *p = str;\r\nstruct ipmi_ipmb_addr *ipmb;\r\nint j;\r\nif (intf->intf_num == -1)\r\ncontinue;\r\nsmp_rmb();\r\nintf->local_sel_device = 0;\r\nintf->local_event_generator = 0;\r\nintf->event_receiver = 0;\r\nmsg.netfn = IPMI_NETFN_APP_REQUEST;\r\nmsg.cmd = IPMI_GET_DEVICE_ID_CMD;\r\nmsg.data = NULL;\r\nmsg.data_len = 0;\r\nintf->null_user_handler = device_id_fetcher;\r\nipmi_panic_request_and_wait(intf, &addr, &msg);\r\nif (intf->local_event_generator) {\r\nmsg.netfn = IPMI_NETFN_SENSOR_EVENT_REQUEST;\r\nmsg.cmd = IPMI_GET_EVENT_RECEIVER_CMD;\r\nmsg.data = NULL;\r\nmsg.data_len = 0;\r\nintf->null_user_handler = event_receiver_fetcher;\r\nipmi_panic_request_and_wait(intf, &addr, &msg);\r\n}\r\nintf->null_user_handler = NULL;\r\nif (((intf->event_receiver & 1) == 0)\r\n&& (intf->event_receiver != 0)\r\n&& (intf->event_receiver != intf->channels[0].address)) {\r\nipmb = (struct ipmi_ipmb_addr *) &addr;\r\nipmb->addr_type = IPMI_IPMB_ADDR_TYPE;\r\nipmb->channel = 0;\r\nipmb->lun = intf->event_receiver_lun;\r\nipmb->slave_addr = intf->event_receiver;\r\n} else if (intf->local_sel_device) {\r\nsi = (struct ipmi_system_interface_addr *) &addr;\r\nsi->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\r\nsi->channel = IPMI_BMC_CHANNEL;\r\nsi->lun = 0;\r\n} else\r\ncontinue;\r\nmsg.netfn = IPMI_NETFN_STORAGE_REQUEST;\r\nmsg.cmd = IPMI_ADD_SEL_ENTRY_CMD;\r\nmsg.data = data;\r\nmsg.data_len = 16;\r\nj = 0;\r\nwhile (*p) {\r\nint size = strlen(p);\r\nif (size > 11)\r\nsize = 11;\r\ndata[0] = 0;\r\ndata[1] = 0;\r\ndata[2] = 0xf0;\r\ndata[3] = intf->channels[0].address;\r\ndata[4] = j++;\r\nstrncpy(data+5, p, 11);\r\np += size;\r\nipmi_panic_request_and_wait(intf, &addr, &msg);\r\n}\r\n}\r\n#endif\r\n}\r\nstatic int panic_event(struct notifier_block *this,\r\nunsigned long event,\r\nvoid *ptr)\r\n{\r\nipmi_smi_t intf;\r\nif (has_panicked)\r\nreturn NOTIFY_DONE;\r\nhas_panicked = 1;\r\nlist_for_each_entry_rcu(intf, &ipmi_interfaces, link) {\r\nif (!intf->handlers)\r\ncontinue;\r\nif (!spin_trylock(&intf->xmit_msgs_lock)) {\r\nINIT_LIST_HEAD(&intf->xmit_msgs);\r\nINIT_LIST_HEAD(&intf->hp_xmit_msgs);\r\n} else\r\nspin_unlock(&intf->xmit_msgs_lock);\r\nif (!spin_trylock(&intf->waiting_rcv_msgs_lock))\r\nINIT_LIST_HEAD(&intf->waiting_rcv_msgs);\r\nelse\r\nspin_unlock(&intf->waiting_rcv_msgs_lock);\r\nintf->run_to_completion = 1;\r\nintf->handlers->set_run_to_completion(intf->send_info, 1);\r\n}\r\n#ifdef CONFIG_IPMI_PANIC_EVENT\r\nsend_panic_events(ptr);\r\n#endif\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int ipmi_init_msghandler(void)\r\n{\r\nint rv;\r\nif (initialized)\r\nreturn 0;\r\nrv = driver_register(&ipmidriver.driver);\r\nif (rv) {\r\nprintk(KERN_ERR PFX "Could not register IPMI driver\n");\r\nreturn rv;\r\n}\r\nprintk(KERN_INFO "ipmi message handler version "\r\nIPMI_DRIVER_VERSION "\n");\r\n#ifdef CONFIG_PROC_FS\r\nproc_ipmi_root = proc_mkdir("ipmi", NULL);\r\nif (!proc_ipmi_root) {\r\nprintk(KERN_ERR PFX "Unable to create IPMI proc dir");\r\ndriver_unregister(&ipmidriver.driver);\r\nreturn -ENOMEM;\r\n}\r\n#endif\r\nsetup_timer(&ipmi_timer, ipmi_timeout, 0);\r\nmod_timer(&ipmi_timer, jiffies + IPMI_TIMEOUT_JIFFIES);\r\natomic_notifier_chain_register(&panic_notifier_list, &panic_block);\r\ninitialized = 1;\r\nreturn 0;\r\n}\r\nstatic int __init ipmi_init_msghandler_mod(void)\r\n{\r\nipmi_init_msghandler();\r\nreturn 0;\r\n}\r\nstatic void __exit cleanup_ipmi(void)\r\n{\r\nint count;\r\nif (!initialized)\r\nreturn;\r\natomic_notifier_chain_unregister(&panic_notifier_list, &panic_block);\r\natomic_inc(&stop_operation);\r\ndel_timer_sync(&ipmi_timer);\r\n#ifdef CONFIG_PROC_FS\r\nproc_remove(proc_ipmi_root);\r\n#endif\r\ndriver_unregister(&ipmidriver.driver);\r\ninitialized = 0;\r\ncount = atomic_read(&smi_msg_inuse_count);\r\nif (count != 0)\r\nprintk(KERN_WARNING PFX "SMI message count %d at exit\n",\r\ncount);\r\ncount = atomic_read(&recv_msg_inuse_count);\r\nif (count != 0)\r\nprintk(KERN_WARNING PFX "recv message count %d at exit\n",\r\ncount);\r\n}
