static u16 dib0070_read_reg(struct dib0070_state *state, u8 reg)\r\n{\r\nu16 ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn 0;\r\n}\r\nstate->i2c_write_buffer[0] = reg;\r\nmemset(state->msg, 0, 2 * sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->cfg->i2c_address;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 1;\r\nstate->msg[1].addr = state->cfg->i2c_address;\r\nstate->msg[1].flags = I2C_M_RD;\r\nstate->msg[1].buf = state->i2c_read_buffer;\r\nstate->msg[1].len = 2;\r\nif (i2c_transfer(state->i2c, state->msg, 2) != 2) {\r\npr_warn("DiB0070 I2C read failed\n");\r\nret = 0;\r\n} else\r\nret = (state->i2c_read_buffer[0] << 8)\r\n| state->i2c_read_buffer[1];\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib0070_write_reg(struct dib0070_state *state, u8 reg, u16 val)\r\n{\r\nint ret;\r\nif (mutex_lock_interruptible(&state->i2c_buffer_lock) < 0) {\r\ndprintk("could not acquire lock\n");\r\nreturn -EINVAL;\r\n}\r\nstate->i2c_write_buffer[0] = reg;\r\nstate->i2c_write_buffer[1] = val >> 8;\r\nstate->i2c_write_buffer[2] = val & 0xff;\r\nmemset(state->msg, 0, sizeof(struct i2c_msg));\r\nstate->msg[0].addr = state->cfg->i2c_address;\r\nstate->msg[0].flags = 0;\r\nstate->msg[0].buf = state->i2c_write_buffer;\r\nstate->msg[0].len = 3;\r\nif (i2c_transfer(state->i2c, state->msg, 1) != 1) {\r\npr_warn("DiB0070 I2C write failed\n");\r\nret = -EREMOTEIO;\r\n} else\r\nret = 0;\r\nmutex_unlock(&state->i2c_buffer_lock);\r\nreturn ret;\r\n}\r\nstatic int dib0070_set_bandwidth(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nu16 tmp = dib0070_read_reg(state, 0x02) & 0x3fff;\r\nif (state->fe->dtv_property_cache.bandwidth_hz/1000 > 7000)\r\ntmp |= (0 << 14);\r\nelse if (state->fe->dtv_property_cache.bandwidth_hz/1000 > 6000)\r\ntmp |= (1 << 14);\r\nelse if (state->fe->dtv_property_cache.bandwidth_hz/1000 > 5000)\r\ntmp |= (2 << 14);\r\nelse\r\ntmp |= (3 << 14);\r\ndib0070_write_reg(state, 0x02, tmp);\r\nif (state->fe->dtv_property_cache.delivery_system == SYS_ISDBT) {\r\nu16 value = dib0070_read_reg(state, 0x17);\r\ndib0070_write_reg(state, 0x17, value & 0xfffc);\r\ntmp = dib0070_read_reg(state, 0x01) & 0x01ff;\r\ndib0070_write_reg(state, 0x01, tmp | (60 << 9));\r\ndib0070_write_reg(state, 0x17, value);\r\n}\r\nreturn 0;\r\n}\r\nstatic int dib0070_captrim(struct dib0070_state *state, enum frontend_tune_state *tune_state)\r\n{\r\nint8_t step_sign;\r\nu16 adc;\r\nint ret = 0;\r\nif (*tune_state == CT_TUNER_STEP_0) {\r\ndib0070_write_reg(state, 0x0f, 0xed10);\r\ndib0070_write_reg(state, 0x17, 0x0034);\r\ndib0070_write_reg(state, 0x18, 0x0032);\r\nstate->step = state->captrim = state->fcaptrim = 64;\r\nstate->adc_diff = 3000;\r\nret = 20;\r\n*tune_state = CT_TUNER_STEP_1;\r\n} else if (*tune_state == CT_TUNER_STEP_1) {\r\nstate->step /= 2;\r\ndib0070_write_reg(state, 0x14, state->lo4 | state->captrim);\r\nret = 15;\r\n*tune_state = CT_TUNER_STEP_2;\r\n} else if (*tune_state == CT_TUNER_STEP_2) {\r\nadc = dib0070_read_reg(state, 0x19);\r\ndprintk("CAPTRIM=%hd; ADC = %hd (ADC) & %dmV\n", state->captrim, adc, (u32) adc*(u32)1800/(u32)1024);\r\nif (adc >= 400) {\r\nadc -= 400;\r\nstep_sign = -1;\r\n} else {\r\nadc = 400 - adc;\r\nstep_sign = 1;\r\n}\r\nif (adc < state->adc_diff) {\r\ndprintk("CAPTRIM=%hd is closer to target (%hd/%hd)\n", state->captrim, adc, state->adc_diff);\r\nstate->adc_diff = adc;\r\nstate->fcaptrim = state->captrim;\r\n}\r\nstate->captrim += (step_sign * state->step);\r\nif (state->step >= 1)\r\n*tune_state = CT_TUNER_STEP_1;\r\nelse\r\n*tune_state = CT_TUNER_STEP_3;\r\n} else if (*tune_state == CT_TUNER_STEP_3) {\r\ndib0070_write_reg(state, 0x14, state->lo4 | state->fcaptrim);\r\ndib0070_write_reg(state, 0x18, 0x07ff);\r\n*tune_state = CT_TUNER_STEP_4;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0070_set_ctrl_lo5(struct dvb_frontend *fe, u8 vco_bias_trim, u8 hf_div_trim, u8 cp_current, u8 third_order_filt)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nu16 lo5 = (third_order_filt << 14) | (0 << 13) | (1 << 12) | (3 << 9) | (cp_current << 6) | (hf_div_trim << 3) | (vco_bias_trim << 0);\r\ndprintk("CTRL_LO5: 0x%x\n", lo5);\r\nreturn dib0070_write_reg(state, 0x15, lo5);\r\n}\r\nvoid dib0070_ctrl_agc_filter(struct dvb_frontend *fe, u8 open)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nif (open) {\r\ndib0070_write_reg(state, 0x1b, 0xff00);\r\ndib0070_write_reg(state, 0x1a, 0x0000);\r\n} else {\r\ndib0070_write_reg(state, 0x1b, 0x4112);\r\nif (state->cfg->vga_filter != 0) {\r\ndib0070_write_reg(state, 0x1a, state->cfg->vga_filter);\r\ndprintk("vga filter register is set to %x\n", state->cfg->vga_filter);\r\n} else\r\ndib0070_write_reg(state, 0x1a, 0x0009);\r\n}\r\n}\r\nstatic int dib0070_tune_digital(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nconst struct dib0070_tuning *tune;\r\nconst struct dib0070_lna_match *lna_match;\r\nenum frontend_tune_state *tune_state = &state->tune_state;\r\nint ret = 10;\r\nu8 band = (u8)BAND_OF_FREQUENCY(fe->dtv_property_cache.frequency/1000);\r\nu32 freq = fe->dtv_property_cache.frequency/1000 + (band == BAND_VHF ? state->cfg->freq_offset_khz_vhf : state->cfg->freq_offset_khz_uhf);\r\n#ifdef CONFIG_SYS_ISDBT\r\nif (state->fe->dtv_property_cache.delivery_system == SYS_ISDBT && state->fe->dtv_property_cache.isdbt_sb_mode == 1)\r\nif (((state->fe->dtv_property_cache.isdbt_sb_segment_count % 2)\r\n&& (state->fe->dtv_property_cache.isdbt_sb_segment_idx == ((state->fe->dtv_property_cache.isdbt_sb_segment_count / 2) + 1)))\r\n|| (((state->fe->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\n&& (state->fe->dtv_property_cache.isdbt_sb_segment_idx == (state->fe->dtv_property_cache.isdbt_sb_segment_count / 2)))\r\n|| (((state->fe->dtv_property_cache.isdbt_sb_segment_count % 2) == 0)\r\n&& (state->fe->dtv_property_cache.isdbt_sb_segment_idx == ((state->fe->dtv_property_cache.isdbt_sb_segment_count / 2) + 1))))\r\nfreq += 850;\r\n#endif\r\nif (state->current_rf != freq) {\r\nswitch (state->revision) {\r\ncase DIB0070S_P1A:\r\ntune = dib0070s_tuning_table;\r\nlna_match = dib0070_lna;\r\nbreak;\r\ndefault:\r\ntune = dib0070_tuning_table;\r\nif (state->cfg->flip_chip)\r\nlna_match = dib0070_lna_flip_chip;\r\nelse\r\nlna_match = dib0070_lna;\r\nbreak;\r\n}\r\nwhile (freq > tune->max_freq)\r\ntune++;\r\nwhile (freq > lna_match->max_freq)\r\nlna_match++;\r\nstate->current_tune_table_index = tune;\r\nstate->lna_match = lna_match;\r\n}\r\nif (*tune_state == CT_TUNER_START) {\r\ndprintk("Tuning for Band: %hd (%d kHz)\n", band, freq);\r\nif (state->current_rf != freq) {\r\nu8 REFDIV;\r\nu32 FBDiv, Rest, FREF, VCOF_kHz;\r\nu8 Den;\r\nstate->current_rf = freq;\r\nstate->lo4 = (state->current_tune_table_index->vco_band << 11) | (state->current_tune_table_index->hfdiv << 7);\r\ndib0070_write_reg(state, 0x17, 0x30);\r\nVCOF_kHz = state->current_tune_table_index->vco_multi * freq * 2;\r\nswitch (band) {\r\ncase BAND_VHF:\r\nREFDIV = (u8) ((state->cfg->clock_khz + 9999) / 10000);\r\nbreak;\r\ncase BAND_FM:\r\nREFDIV = (u8) ((state->cfg->clock_khz) / 1000);\r\nbreak;\r\ndefault:\r\nREFDIV = (u8) (state->cfg->clock_khz / 10000);\r\nbreak;\r\n}\r\nFREF = state->cfg->clock_khz / REFDIV;\r\nswitch (state->revision) {\r\ncase DIB0070S_P1A:\r\nFBDiv = (VCOF_kHz / state->current_tune_table_index->presc / FREF);\r\nRest = (VCOF_kHz / state->current_tune_table_index->presc) - FBDiv * FREF;\r\nbreak;\r\ncase DIB0070_P1G:\r\ncase DIB0070_P1F:\r\ndefault:\r\nFBDiv = (freq / (FREF / 2));\r\nRest = 2 * freq - FBDiv * FREF;\r\nbreak;\r\n}\r\nif (Rest < LPF)\r\nRest = 0;\r\nelse if (Rest < 2 * LPF)\r\nRest = 2 * LPF;\r\nelse if (Rest > (FREF - LPF)) {\r\nRest = 0;\r\nFBDiv += 1;\r\n} else if (Rest > (FREF - 2 * LPF))\r\nRest = FREF - 2 * LPF;\r\nRest = (Rest * 6528) / (FREF / 10);\r\nDen = 1;\r\nif (Rest > 0) {\r\nstate->lo4 |= (1 << 14) | (1 << 12);\r\nDen = 255;\r\n}\r\ndib0070_write_reg(state, 0x11, (u16)FBDiv);\r\ndib0070_write_reg(state, 0x12, (Den << 8) | REFDIV);\r\ndib0070_write_reg(state, 0x13, (u16) Rest);\r\nif (state->revision == DIB0070S_P1A) {\r\nif (band == BAND_SBAND) {\r\ndib0070_set_ctrl_lo5(fe, 2, 4, 3, 0);\r\ndib0070_write_reg(state, 0x1d, 0xFFFF);\r\n} else\r\ndib0070_set_ctrl_lo5(fe, 5, 4, 3, 1);\r\n}\r\ndib0070_write_reg(state, 0x20,\r\n0x0040 | 0x0020 | 0x0010 | 0x0008 | 0x0002 | 0x0001 | state->current_tune_table_index->tuner_enable);\r\ndprintk("REFDIV: %hd, FREF: %d\n", REFDIV, FREF);\r\ndprintk("FBDIV: %d, Rest: %d\n", FBDiv, Rest);\r\ndprintk("Num: %hd, Den: %hd, SD: %hd\n", (u16) Rest, Den, (state->lo4 >> 12) & 0x1);\r\ndprintk("HFDIV code: %hd\n", state->current_tune_table_index->hfdiv);\r\ndprintk("VCO = %hd\n", state->current_tune_table_index->vco_band);\r\ndprintk("VCOF: ((%hd*%d) << 1))\n", state->current_tune_table_index->vco_multi, freq);\r\n*tune_state = CT_TUNER_STEP_0;\r\n} else {\r\nret = 50;\r\n*tune_state = CT_TUNER_STEP_5;\r\n}\r\n} else if ((*tune_state > CT_TUNER_START) && (*tune_state < CT_TUNER_STEP_4)) {\r\nret = dib0070_captrim(state, tune_state);\r\n} else if (*tune_state == CT_TUNER_STEP_4) {\r\nconst struct dib0070_wbd_gain_cfg *tmp = state->cfg->wbd_gain;\r\nif (tmp != NULL) {\r\nwhile (freq/1000 > tmp->freq)\r\ntmp++;\r\ndib0070_write_reg(state, 0x0f,\r\n(0 << 15) | (1 << 14) | (3 << 12)\r\n| (tmp->wbd_gain_val << 9) | (0 << 8) | (1 << 7)\r\n| (state->current_tune_table_index->wbdmux << 0));\r\nstate->wbd_gain_current = tmp->wbd_gain_val;\r\n} else {\r\ndib0070_write_reg(state, 0x0f,\r\n(0 << 15) | (1 << 14) | (3 << 12)\r\n| (6 << 9) | (0 << 8) | (1 << 7)\r\n| (state->current_tune_table_index->wbdmux << 0));\r\nstate->wbd_gain_current = 6;\r\n}\r\ndib0070_write_reg(state, 0x06, 0x3fff);\r\ndib0070_write_reg(state, 0x07,\r\n(state->current_tune_table_index->switch_trim << 11) | (7 << 8) | (state->lna_match->lna_band << 3) | (3 << 0));\r\ndib0070_write_reg(state, 0x08, (state->lna_match->lna_band << 10) | (3 << 7) | (127));\r\ndib0070_write_reg(state, 0x0d, 0x0d80);\r\ndib0070_write_reg(state, 0x18, 0x07ff);\r\ndib0070_write_reg(state, 0x17, 0x0033);\r\n*tune_state = CT_TUNER_STEP_5;\r\n} else if (*tune_state == CT_TUNER_STEP_5) {\r\ndib0070_set_bandwidth(fe);\r\n*tune_state = CT_TUNER_STOP;\r\n} else {\r\nret = FE_CALLBACK_TIME_NEVER;\r\n}\r\nreturn ret;\r\n}\r\nstatic int dib0070_tune(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nuint32_t ret;\r\nstate->tune_state = CT_TUNER_START;\r\ndo {\r\nret = dib0070_tune_digital(fe);\r\nif (ret != FE_CALLBACK_TIME_NEVER)\r\nmsleep(ret/10);\r\nelse\r\nbreak;\r\n} while (state->tune_state != CT_TUNER_STOP);\r\nreturn 0;\r\n}\r\nstatic int dib0070_wakeup(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nif (state->cfg->sleep)\r\nstate->cfg->sleep(fe, 0);\r\nreturn 0;\r\n}\r\nstatic int dib0070_sleep(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nif (state->cfg->sleep)\r\nstate->cfg->sleep(fe, 1);\r\nreturn 0;\r\n}\r\nu8 dib0070_get_rf_output(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nreturn (dib0070_read_reg(state, 0x07) >> 11) & 0x3;\r\n}\r\nint dib0070_set_rf_output(struct dvb_frontend *fe, u8 no)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nu16 rxrf2 = dib0070_read_reg(state, 0x07) & 0xfe7ff;\r\nif (no > 3)\r\nno = 3;\r\nif (no < 1)\r\nno = 1;\r\nreturn dib0070_write_reg(state, 0x07, rxrf2 | (no << 11));\r\n}\r\nstatic u16 dib0070_read_wbd_offset(struct dib0070_state *state, u8 gain)\r\n{\r\nu16 tuner_en = dib0070_read_reg(state, 0x20);\r\nu16 offset;\r\ndib0070_write_reg(state, 0x18, 0x07ff);\r\ndib0070_write_reg(state, 0x20, 0x0800 | 0x4000 | 0x0040 | 0x0020 | 0x0010 | 0x0008 | 0x0002 | 0x0001);\r\ndib0070_write_reg(state, 0x0f, (1 << 14) | (2 << 12) | (gain << 9) | (1 << 8) | (1 << 7) | (0 << 0));\r\nmsleep(9);\r\noffset = dib0070_read_reg(state, 0x19);\r\ndib0070_write_reg(state, 0x20, tuner_en);\r\nreturn offset;\r\n}\r\nstatic void dib0070_wbd_offset_calibration(struct dib0070_state *state)\r\n{\r\nu8 gain;\r\nfor (gain = 6; gain < 8; gain++) {\r\nstate->wbd_offset_3_3[gain - 6] = ((dib0070_read_wbd_offset(state, gain) * 8 * 18 / 33 + 1) / 2);\r\ndprintk("Gain: %d, WBDOffset (3.3V) = %hd\n", gain, state->wbd_offset_3_3[gain-6]);\r\n}\r\n}\r\nu16 dib0070_wbd_offset(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nconst struct dib0070_wbd_gain_cfg *tmp = state->cfg->wbd_gain;\r\nu32 freq = fe->dtv_property_cache.frequency/1000;\r\nif (tmp != NULL) {\r\nwhile (freq/1000 > tmp->freq)\r\ntmp++;\r\nstate->wbd_gain_current = tmp->wbd_gain_val;\r\n} else\r\nstate->wbd_gain_current = 6;\r\nreturn state->wbd_offset_3_3[state->wbd_gain_current - 6];\r\n}\r\nstatic int dib0070_reset(struct dvb_frontend *fe)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\nu16 l, r, *n;\r\nHARD_RESET(state);\r\n#ifndef FORCE_SBAND_TUNER\r\nif ((dib0070_read_reg(state, 0x22) >> 9) & 0x1)\r\nstate->revision = (dib0070_read_reg(state, 0x1f) >> 8) & 0xff;\r\nelse\r\n#else\r\n#warning forcing SBAND\r\n#endif\r\nstate->revision = DIB0070S_P1A;\r\ndprintk("Revision: %x\n", state->revision);\r\nif (state->revision == DIB0070_P1D) {\r\ndprintk("Error: this driver is not to be used meant for P1D or earlier\n");\r\nreturn -EINVAL;\r\n}\r\nn = (u16 *) dib0070_p1f_defaults;\r\nl = pgm_read_word(n++);\r\nwhile (l) {\r\nr = pgm_read_word(n++);\r\ndo {\r\ndib0070_write_reg(state, (u8)r, pgm_read_word(n++));\r\nr++;\r\n} while (--l);\r\nl = pgm_read_word(n++);\r\n}\r\nif (state->cfg->force_crystal_mode != 0)\r\nr = state->cfg->force_crystal_mode;\r\nelse if (state->cfg->clock_khz >= 24000)\r\nr = 1;\r\nelse\r\nr = 2;\r\nr |= state->cfg->osc_buffer_state << 3;\r\ndib0070_write_reg(state, 0x10, r);\r\ndib0070_write_reg(state, 0x1f, (1 << 8) | ((state->cfg->clock_pad_drive & 0xf) << 5));\r\nif (state->cfg->invert_iq) {\r\nr = dib0070_read_reg(state, 0x02) & 0xffdf;\r\ndib0070_write_reg(state, 0x02, r | (1 << 5));\r\n}\r\nif (state->revision == DIB0070S_P1A)\r\ndib0070_set_ctrl_lo5(fe, 2, 4, 3, 0);\r\nelse\r\ndib0070_set_ctrl_lo5(fe, 5, 4, state->cfg->charge_pump,\r\nstate->cfg->enable_third_order_filter);\r\ndib0070_write_reg(state, 0x01, (54 << 9) | 0xc8);\r\ndib0070_wbd_offset_calibration(state);\r\nreturn 0;\r\n}\r\nstatic int dib0070_get_frequency(struct dvb_frontend *fe, u32 *frequency)\r\n{\r\nstruct dib0070_state *state = fe->tuner_priv;\r\n*frequency = 1000 * state->current_rf;\r\nreturn 0;\r\n}\r\nstatic void dib0070_release(struct dvb_frontend *fe)\r\n{\r\nkfree(fe->tuner_priv);\r\nfe->tuner_priv = NULL;\r\n}\r\nstruct dvb_frontend *dib0070_attach(struct dvb_frontend *fe, struct i2c_adapter *i2c, struct dib0070_config *cfg)\r\n{\r\nstruct dib0070_state *state = kzalloc(sizeof(struct dib0070_state), GFP_KERNEL);\r\nif (state == NULL)\r\nreturn NULL;\r\nstate->cfg = cfg;\r\nstate->i2c = i2c;\r\nstate->fe = fe;\r\nmutex_init(&state->i2c_buffer_lock);\r\nfe->tuner_priv = state;\r\nif (dib0070_reset(fe) != 0)\r\ngoto free_mem;\r\npr_info("DiB0070: successfully identified\n");\r\nmemcpy(&fe->ops.tuner_ops, &dib0070_ops, sizeof(struct dvb_tuner_ops));\r\nfe->tuner_priv = state;\r\nreturn fe;\r\nfree_mem:\r\nkfree(state);\r\nfe->tuner_priv = NULL;\r\nreturn NULL;\r\n}
