static void rvin_write(struct rvin_dev *vin, u32 value, u32 offset)\r\n{\r\niowrite32(value, vin->base + offset);\r\n}\r\nstatic u32 rvin_read(struct rvin_dev *vin, u32 offset)\r\n{\r\nreturn ioread32(vin->base + offset);\r\n}\r\nstatic int rvin_setup(struct rvin_dev *vin)\r\n{\r\nu32 vnmc, dmr, dmr2, interrupts;\r\nv4l2_std_id std;\r\nbool progressive = false, output_is_yuv = false, input_is_yuv = false;\r\nswitch (vin->format.field) {\r\ncase V4L2_FIELD_TOP:\r\nvnmc = VNMC_IM_ODD;\r\nbreak;\r\ncase V4L2_FIELD_BOTTOM:\r\nvnmc = VNMC_IM_EVEN;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED:\r\nvnmc = VNMC_IM_FULL;\r\nif (!v4l2_subdev_call(vin_to_source(vin), video, g_std, &std)) {\r\nif (std & V4L2_STD_525_60)\r\nvnmc = VNMC_IM_FULL | VNMC_FOC;\r\n}\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_TB:\r\nvnmc = VNMC_IM_FULL;\r\nbreak;\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nvnmc = VNMC_IM_FULL | VNMC_FOC;\r\nbreak;\r\ncase V4L2_FIELD_ALTERNATE:\r\ncase V4L2_FIELD_NONE:\r\nif (vin->continuous) {\r\nvnmc = VNMC_IM_ODD_EVEN;\r\nprogressive = true;\r\n} else {\r\nvnmc = VNMC_IM_ODD;\r\n}\r\nbreak;\r\ndefault:\r\nvnmc = VNMC_IM_ODD;\r\nbreak;\r\n}\r\nswitch (vin->digital.code) {\r\ncase MEDIA_BUS_FMT_YUYV8_1X16:\r\nvnmc |= VNMC_INF_YUV16;\r\ninput_is_yuv = true;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY8_2X8:\r\nvnmc |= vin->digital.mbus_cfg.type == V4L2_MBUS_BT656 ?\r\nVNMC_INF_YUV8_BT656 : VNMC_INF_YUV8_BT601;\r\ninput_is_yuv = true;\r\nbreak;\r\ncase MEDIA_BUS_FMT_RGB888_1X24:\r\nvnmc |= VNMC_INF_RGB888;\r\nbreak;\r\ncase MEDIA_BUS_FMT_UYVY10_2X10:\r\nvnmc |= vin->digital.mbus_cfg.type == V4L2_MBUS_BT656 ?\r\nVNMC_INF_YUV10_BT656 : VNMC_INF_YUV10_BT601;\r\ninput_is_yuv = true;\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndmr2 = VNDMR2_FTEV | VNDMR2_VLV(1);\r\nif (!(vin->digital.mbus_cfg.flags & V4L2_MBUS_HSYNC_ACTIVE_LOW))\r\ndmr2 |= VNDMR2_HPS;\r\nif (!(vin->digital.mbus_cfg.flags & V4L2_MBUS_VSYNC_ACTIVE_LOW))\r\ndmr2 |= VNDMR2_VPS;\r\nswitch (vin->format.pixelformat) {\r\ncase V4L2_PIX_FMT_NV16:\r\nrvin_write(vin,\r\nALIGN(vin->format.width * vin->format.height, 0x80),\r\nVNUVAOF_REG);\r\ndmr = VNDMR_DTMD_YCSEP;\r\noutput_is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_YUYV:\r\ndmr = VNDMR_BPSM;\r\noutput_is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_UYVY:\r\ndmr = 0;\r\noutput_is_yuv = true;\r\nbreak;\r\ncase V4L2_PIX_FMT_XRGB555:\r\ndmr = VNDMR_DTMD_ARGB1555;\r\nbreak;\r\ncase V4L2_PIX_FMT_RGB565:\r\ndmr = 0;\r\nbreak;\r\ncase V4L2_PIX_FMT_XBGR32:\r\ndmr = VNDMR_EXRGB;\r\nbreak;\r\ndefault:\r\nvin_err(vin, "Invalid pixelformat (0x%x)\n",\r\nvin->format.pixelformat);\r\nreturn -EINVAL;\r\n}\r\nvnmc |= VNMC_VUP;\r\nif (input_is_yuv == output_is_yuv)\r\nvnmc |= VNMC_BPS;\r\ninterrupts = progressive ? VNIE_FIE : VNIE_EFE;\r\nrvin_write(vin, interrupts, VNINTS_REG);\r\nrvin_write(vin, interrupts, VNIE_REG);\r\nrvin_write(vin, dmr, VNDMR_REG);\r\nrvin_write(vin, dmr2, VNDMR2_REG);\r\nrvin_write(vin, vnmc | VNMC_ME, VNMC_REG);\r\nreturn 0;\r\n}\r\nstatic void rvin_capture_on(struct rvin_dev *vin)\r\n{\r\nvin_dbg(vin, "Capture on in %s mode\n",\r\nvin->continuous ? "continuous" : "single");\r\nif (vin->continuous)\r\nrvin_write(vin, VNFC_C_FRAME, VNFC_REG);\r\nelse\r\nrvin_write(vin, VNFC_S_FRAME, VNFC_REG);\r\n}\r\nstatic void rvin_capture_off(struct rvin_dev *vin)\r\n{\r\nrvin_write(vin, 0, VNFC_REG);\r\n}\r\nstatic int rvin_capture_start(struct rvin_dev *vin)\r\n{\r\nint ret;\r\nrvin_crop_scale_comp(vin);\r\nret = rvin_setup(vin);\r\nif (ret)\r\nreturn ret;\r\nrvin_capture_on(vin);\r\nreturn 0;\r\n}\r\nstatic void rvin_capture_stop(struct rvin_dev *vin)\r\n{\r\nrvin_capture_off(vin);\r\nrvin_write(vin, rvin_read(vin, VNMC_REG) & ~VNMC_ME, VNMC_REG);\r\n}\r\nstatic void rvin_disable_interrupts(struct rvin_dev *vin)\r\n{\r\nrvin_write(vin, 0, VNIE_REG);\r\n}\r\nstatic u32 rvin_get_interrupt_status(struct rvin_dev *vin)\r\n{\r\nreturn rvin_read(vin, VNINTS_REG);\r\n}\r\nstatic void rvin_ack_interrupt(struct rvin_dev *vin)\r\n{\r\nrvin_write(vin, rvin_read(vin, VNINTS_REG), VNINTS_REG);\r\n}\r\nstatic bool rvin_capture_active(struct rvin_dev *vin)\r\n{\r\nreturn rvin_read(vin, VNMS_REG) & VNMS_CA;\r\n}\r\nstatic int rvin_get_active_slot(struct rvin_dev *vin, u32 vnms)\r\n{\r\nif (vin->continuous)\r\nreturn (vnms & VNMS_FBS_MASK) >> VNMS_FBS_SHIFT;\r\nreturn 0;\r\n}\r\nstatic enum v4l2_field rvin_get_active_field(struct rvin_dev *vin, u32 vnms)\r\n{\r\nif (vin->format.field == V4L2_FIELD_ALTERNATE) {\r\nif (vnms & VNMS_FS)\r\nreturn V4L2_FIELD_BOTTOM;\r\nreturn V4L2_FIELD_TOP;\r\n}\r\nreturn vin->format.field;\r\n}\r\nstatic void rvin_set_slot_addr(struct rvin_dev *vin, int slot, dma_addr_t addr)\r\n{\r\nconst struct rvin_video_format *fmt;\r\nint offsetx, offsety;\r\ndma_addr_t offset;\r\nfmt = rvin_format_from_pixel(vin->format.pixelformat);\r\noffsetx = vin->compose.left * fmt->bpp;\r\noffsety = vin->compose.top * vin->format.bytesperline;\r\noffset = addr + offsetx + offsety;\r\nif (WARN_ON((offsetx | offsety | offset) & HW_BUFFER_MASK))\r\nreturn;\r\nrvin_write(vin, offset, VNMB_REG(slot));\r\n}\r\nstatic void rvin_set_coeff(struct rvin_dev *vin, unsigned short xs)\r\n{\r\nint i;\r\nconst struct vin_coeff *p_prev_set = NULL;\r\nconst struct vin_coeff *p_set = NULL;\r\nfor (i = 0; i < ARRAY_SIZE(vin_coeff_set); i++) {\r\np_prev_set = p_set;\r\np_set = &vin_coeff_set[i];\r\nif (xs < p_set->xs_value)\r\nbreak;\r\n}\r\nif (p_prev_set && p_set &&\r\nxs - p_prev_set->xs_value < p_set->xs_value - xs)\r\np_set = p_prev_set;\r\nrvin_write(vin, p_set->coeff_set[0], VNC1A_REG);\r\nrvin_write(vin, p_set->coeff_set[1], VNC1B_REG);\r\nrvin_write(vin, p_set->coeff_set[2], VNC1C_REG);\r\nrvin_write(vin, p_set->coeff_set[3], VNC2A_REG);\r\nrvin_write(vin, p_set->coeff_set[4], VNC2B_REG);\r\nrvin_write(vin, p_set->coeff_set[5], VNC2C_REG);\r\nrvin_write(vin, p_set->coeff_set[6], VNC3A_REG);\r\nrvin_write(vin, p_set->coeff_set[7], VNC3B_REG);\r\nrvin_write(vin, p_set->coeff_set[8], VNC3C_REG);\r\nrvin_write(vin, p_set->coeff_set[9], VNC4A_REG);\r\nrvin_write(vin, p_set->coeff_set[10], VNC4B_REG);\r\nrvin_write(vin, p_set->coeff_set[11], VNC4C_REG);\r\nrvin_write(vin, p_set->coeff_set[12], VNC5A_REG);\r\nrvin_write(vin, p_set->coeff_set[13], VNC5B_REG);\r\nrvin_write(vin, p_set->coeff_set[14], VNC5C_REG);\r\nrvin_write(vin, p_set->coeff_set[15], VNC6A_REG);\r\nrvin_write(vin, p_set->coeff_set[16], VNC6B_REG);\r\nrvin_write(vin, p_set->coeff_set[17], VNC6C_REG);\r\nrvin_write(vin, p_set->coeff_set[18], VNC7A_REG);\r\nrvin_write(vin, p_set->coeff_set[19], VNC7B_REG);\r\nrvin_write(vin, p_set->coeff_set[20], VNC7C_REG);\r\nrvin_write(vin, p_set->coeff_set[21], VNC8A_REG);\r\nrvin_write(vin, p_set->coeff_set[22], VNC8B_REG);\r\nrvin_write(vin, p_set->coeff_set[23], VNC8C_REG);\r\n}\r\nvoid rvin_crop_scale_comp(struct rvin_dev *vin)\r\n{\r\nu32 xs, ys;\r\nrvin_write(vin, vin->crop.left, VNSPPRC_REG);\r\nrvin_write(vin, vin->crop.left + vin->crop.width - 1, VNEPPRC_REG);\r\nswitch (vin->format.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nrvin_write(vin, vin->crop.top / 2, VNSLPRC_REG);\r\nrvin_write(vin, (vin->crop.top + vin->crop.height) / 2 - 1,\r\nVNELPRC_REG);\r\nbreak;\r\ndefault:\r\nrvin_write(vin, vin->crop.top, VNSLPRC_REG);\r\nrvin_write(vin, vin->crop.top + vin->crop.height - 1,\r\nVNELPRC_REG);\r\nbreak;\r\n}\r\nys = 0;\r\nif (vin->crop.height != vin->compose.height)\r\nys = (4096 * vin->crop.height) / vin->compose.height;\r\nrvin_write(vin, ys, VNYS_REG);\r\nxs = 0;\r\nif (vin->crop.width != vin->compose.width)\r\nxs = (4096 * vin->crop.width) / vin->compose.width;\r\nif (xs > 0 && xs < 2048)\r\nxs = 2048;\r\nrvin_write(vin, xs, VNXS_REG);\r\nif (xs < 4096)\r\nxs *= 2;\r\nrvin_set_coeff(vin, xs);\r\nrvin_write(vin, 0, VNSPPOC_REG);\r\nrvin_write(vin, 0, VNSLPOC_REG);\r\nrvin_write(vin, vin->format.width - 1, VNEPPOC_REG);\r\nswitch (vin->format.field) {\r\ncase V4L2_FIELD_INTERLACED:\r\ncase V4L2_FIELD_INTERLACED_TB:\r\ncase V4L2_FIELD_INTERLACED_BT:\r\nrvin_write(vin, vin->format.height / 2 - 1, VNELPOC_REG);\r\nbreak;\r\ndefault:\r\nrvin_write(vin, vin->format.height - 1, VNELPOC_REG);\r\nbreak;\r\n}\r\nif (vin->format.pixelformat == V4L2_PIX_FMT_NV16)\r\nrvin_write(vin, ALIGN(vin->format.width, 0x20), VNIS_REG);\r\nelse\r\nrvin_write(vin, ALIGN(vin->format.width, 0x10), VNIS_REG);\r\nvin_dbg(vin,\r\n"Pre-Clip: %ux%u@%u:%u YS: %d XS: %d Post-Clip: %ux%u@%u:%u\n",\r\nvin->crop.width, vin->crop.height, vin->crop.left,\r\nvin->crop.top, ys, xs, vin->format.width, vin->format.height,\r\n0, 0);\r\n}\r\nvoid rvin_scale_try(struct rvin_dev *vin, struct v4l2_pix_format *pix,\r\nu32 width, u32 height)\r\n{\r\npix->width = width;\r\npix->height = height;\r\n}\r\nstatic bool rvin_fill_hw_slot(struct rvin_dev *vin, int slot)\r\n{\r\nstruct rvin_buffer *buf;\r\nstruct vb2_v4l2_buffer *vbuf;\r\ndma_addr_t phys_addr_top;\r\nif (vin->queue_buf[slot] != NULL)\r\nreturn true;\r\nif (list_empty(&vin->buf_list))\r\nreturn false;\r\nvin_dbg(vin, "Filling HW slot: %d\n", slot);\r\nbuf = list_entry(vin->buf_list.next, struct rvin_buffer, list);\r\nvbuf = &buf->vb;\r\nlist_del_init(to_buf_list(vbuf));\r\nvin->queue_buf[slot] = vbuf;\r\nphys_addr_top = vb2_dma_contig_plane_dma_addr(&vbuf->vb2_buf, 0);\r\nrvin_set_slot_addr(vin, slot, phys_addr_top);\r\nreturn true;\r\n}\r\nstatic bool rvin_fill_hw(struct rvin_dev *vin)\r\n{\r\nint slot, limit;\r\nlimit = vin->continuous ? HW_BUFFER_NUM : 1;\r\nfor (slot = 0; slot < limit; slot++)\r\nif (!rvin_fill_hw_slot(vin, slot))\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic irqreturn_t rvin_irq(int irq, void *data)\r\n{\r\nstruct rvin_dev *vin = data;\r\nu32 int_status, vnms;\r\nint slot;\r\nunsigned int sequence, handled = 0;\r\nunsigned long flags;\r\nspin_lock_irqsave(&vin->qlock, flags);\r\nint_status = rvin_get_interrupt_status(vin);\r\nif (!int_status)\r\ngoto done;\r\nrvin_ack_interrupt(vin);\r\nhandled = 1;\r\nif (vin->state == STOPPED) {\r\nvin_dbg(vin, "IRQ while state stopped\n");\r\ngoto done;\r\n}\r\nif (vin->state == STOPPING) {\r\nvin_dbg(vin, "IRQ while state stopping\n");\r\ngoto done;\r\n}\r\nvnms = rvin_read(vin, VNMS_REG);\r\nslot = rvin_get_active_slot(vin, vnms);\r\nsequence = vin->sequence++;\r\nvin_dbg(vin, "IRQ %02d: %d\tbuf0: %c buf1: %c buf2: %c\tmore: %d\n",\r\nsequence, slot,\r\nslot == 0 ? 'x' : vin->queue_buf[0] != NULL ? '1' : '0',\r\nslot == 1 ? 'x' : vin->queue_buf[1] != NULL ? '1' : '0',\r\nslot == 2 ? 'x' : vin->queue_buf[2] != NULL ? '1' : '0',\r\n!list_empty(&vin->buf_list));\r\nif (WARN_ON((vin->queue_buf[slot] == NULL)))\r\ngoto done;\r\nvin->queue_buf[slot]->field = rvin_get_active_field(vin, vnms);\r\nvin->queue_buf[slot]->sequence = sequence;\r\nvin->queue_buf[slot]->vb2_buf.timestamp = ktime_get_ns();\r\nvb2_buffer_done(&vin->queue_buf[slot]->vb2_buf, VB2_BUF_STATE_DONE);\r\nvin->queue_buf[slot] = NULL;\r\nif (!rvin_fill_hw(vin)) {\r\nvin->state = STALLED;\r\nif (vin->continuous) {\r\nrvin_capture_off(vin);\r\nvin_dbg(vin, "IRQ %02d: hw not ready stop\n", sequence);\r\n}\r\n} else {\r\nif (!vin->continuous)\r\nrvin_capture_on(vin);\r\n}\r\ndone:\r\nspin_unlock_irqrestore(&vin->qlock, flags);\r\nreturn IRQ_RETVAL(handled);\r\n}\r\nstatic void return_all_buffers(struct rvin_dev *vin,\r\nenum vb2_buffer_state state)\r\n{\r\nstruct rvin_buffer *buf, *node;\r\nint i;\r\nfor (i = 0; i < HW_BUFFER_NUM; i++) {\r\nif (vin->queue_buf[i]) {\r\nvb2_buffer_done(&vin->queue_buf[i]->vb2_buf,\r\nstate);\r\nvin->queue_buf[i] = NULL;\r\n}\r\n}\r\nlist_for_each_entry_safe(buf, node, &vin->buf_list, list) {\r\nvb2_buffer_done(&buf->vb.vb2_buf, state);\r\nlist_del(&buf->list);\r\n}\r\n}\r\nstatic int rvin_queue_setup(struct vb2_queue *vq, unsigned int *nbuffers,\r\nunsigned int *nplanes, unsigned int sizes[],\r\nstruct device *alloc_devs[])\r\n{\r\nstruct rvin_dev *vin = vb2_get_drv_priv(vq);\r\nif (*nplanes)\r\nreturn sizes[0] < vin->format.sizeimage ? -EINVAL : 0;\r\n*nplanes = 1;\r\nsizes[0] = vin->format.sizeimage;\r\nreturn 0;\r\n}\r\nstatic int rvin_buffer_prepare(struct vb2_buffer *vb)\r\n{\r\nstruct rvin_dev *vin = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long size = vin->format.sizeimage;\r\nif (vb2_plane_size(vb, 0) < size) {\r\nvin_err(vin, "buffer too small (%lu < %lu)\n",\r\nvb2_plane_size(vb, 0), size);\r\nreturn -EINVAL;\r\n}\r\nvb2_set_plane_payload(vb, 0, size);\r\nreturn 0;\r\n}\r\nstatic void rvin_buffer_queue(struct vb2_buffer *vb)\r\n{\r\nstruct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);\r\nstruct rvin_dev *vin = vb2_get_drv_priv(vb->vb2_queue);\r\nunsigned long flags;\r\nspin_lock_irqsave(&vin->qlock, flags);\r\nlist_add_tail(to_buf_list(vbuf), &vin->buf_list);\r\nif (vin->state == STALLED)\r\nif (rvin_fill_hw(vin))\r\nrvin_capture_on(vin);\r\nspin_unlock_irqrestore(&vin->qlock, flags);\r\n}\r\nstatic int rvin_start_streaming(struct vb2_queue *vq, unsigned int count)\r\n{\r\nstruct rvin_dev *vin = vb2_get_drv_priv(vq);\r\nstruct v4l2_subdev *sd;\r\nunsigned long flags;\r\nint ret;\r\nsd = vin_to_source(vin);\r\nv4l2_subdev_call(sd, video, s_stream, 1);\r\nspin_lock_irqsave(&vin->qlock, flags);\r\nvin->state = RUNNING;\r\nvin->sequence = 0;\r\nvin->continuous = count > HW_BUFFER_NUM;\r\nif (!rvin_fill_hw(vin)) {\r\nvin_err(vin, "HW not ready to start, not enough buffers available\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nret = rvin_capture_start(vin);\r\nout:\r\nif (ret) {\r\nreturn_all_buffers(vin, VB2_BUF_STATE_QUEUED);\r\nv4l2_subdev_call(sd, video, s_stream, 0);\r\n}\r\nspin_unlock_irqrestore(&vin->qlock, flags);\r\nreturn ret;\r\n}\r\nstatic void rvin_stop_streaming(struct vb2_queue *vq)\r\n{\r\nstruct rvin_dev *vin = vb2_get_drv_priv(vq);\r\nstruct v4l2_subdev *sd;\r\nunsigned long flags;\r\nint retries = 0;\r\nspin_lock_irqsave(&vin->qlock, flags);\r\nvin->state = STOPPING;\r\nwhile (retries++ < RVIN_RETRIES) {\r\nrvin_capture_stop(vin);\r\nif (!rvin_capture_active(vin)) {\r\nvin->state = STOPPED;\r\nbreak;\r\n}\r\nspin_unlock_irqrestore(&vin->qlock, flags);\r\nmsleep(RVIN_TIMEOUT_MS);\r\nspin_lock_irqsave(&vin->qlock, flags);\r\n}\r\nif (vin->state != STOPPED) {\r\nvin_err(vin, "Failed stop HW, something is seriously broken\n");\r\nvin->state = STOPPED;\r\n}\r\nreturn_all_buffers(vin, VB2_BUF_STATE_ERROR);\r\nspin_unlock_irqrestore(&vin->qlock, flags);\r\nsd = vin_to_source(vin);\r\nv4l2_subdev_call(sd, video, s_stream, 0);\r\nrvin_disable_interrupts(vin);\r\n}\r\nvoid rvin_dma_remove(struct rvin_dev *vin)\r\n{\r\nmutex_destroy(&vin->lock);\r\nv4l2_device_unregister(&vin->v4l2_dev);\r\n}\r\nint rvin_dma_probe(struct rvin_dev *vin, int irq)\r\n{\r\nstruct vb2_queue *q = &vin->queue;\r\nint i, ret;\r\nret = v4l2_device_register(vin->dev, &vin->v4l2_dev);\r\nif (ret)\r\nreturn ret;\r\nmutex_init(&vin->lock);\r\nINIT_LIST_HEAD(&vin->buf_list);\r\nspin_lock_init(&vin->qlock);\r\nvin->state = STOPPED;\r\nfor (i = 0; i < HW_BUFFER_NUM; i++)\r\nvin->queue_buf[i] = NULL;\r\nq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\r\nq->io_modes = VB2_MMAP | VB2_READ | VB2_DMABUF;\r\nq->lock = &vin->lock;\r\nq->drv_priv = vin;\r\nq->buf_struct_size = sizeof(struct rvin_buffer);\r\nq->ops = &rvin_qops;\r\nq->mem_ops = &vb2_dma_contig_memops;\r\nq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\r\nq->min_buffers_needed = 2;\r\nq->dev = vin->dev;\r\nret = vb2_queue_init(q);\r\nif (ret < 0) {\r\nvin_err(vin, "failed to initialize VB2 queue\n");\r\ngoto error;\r\n}\r\nret = devm_request_irq(vin->dev, irq, rvin_irq, IRQF_SHARED,\r\nKBUILD_MODNAME, vin);\r\nif (ret) {\r\nvin_err(vin, "failed to request irq\n");\r\ngoto error;\r\n}\r\nreturn 0;\r\nerror:\r\nrvin_dma_remove(vin);\r\nreturn ret;\r\n}
