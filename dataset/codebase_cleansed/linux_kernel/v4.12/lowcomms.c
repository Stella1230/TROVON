static void cbuf_add(struct cbuf *cb, int n)\r\n{\r\ncb->len += n;\r\n}\r\nstatic int cbuf_data(struct cbuf *cb)\r\n{\r\nreturn ((cb->base + cb->len) & cb->mask);\r\n}\r\nstatic void cbuf_init(struct cbuf *cb, int size)\r\n{\r\ncb->base = cb->len = 0;\r\ncb->mask = size-1;\r\n}\r\nstatic void cbuf_eat(struct cbuf *cb, int n)\r\n{\r\ncb->len -= n;\r\ncb->base += n;\r\ncb->base &= cb->mask;\r\n}\r\nstatic bool cbuf_empty(struct cbuf *cb)\r\n{\r\nreturn cb->len == 0;\r\n}\r\nstatic inline int nodeid_hash(int nodeid)\r\n{\r\nreturn nodeid & (CONN_HASH_SIZE-1);\r\n}\r\nstatic struct connection *__find_con(int nodeid)\r\n{\r\nint r;\r\nstruct connection *con;\r\nr = nodeid_hash(nodeid);\r\nhlist_for_each_entry(con, &connection_hash[r], list) {\r\nif (con->nodeid == nodeid)\r\nreturn con;\r\n}\r\nreturn NULL;\r\n}\r\nstatic struct connection *__nodeid2con(int nodeid, gfp_t alloc)\r\n{\r\nstruct connection *con = NULL;\r\nint r;\r\ncon = __find_con(nodeid);\r\nif (con || !alloc)\r\nreturn con;\r\ncon = kmem_cache_zalloc(con_cache, alloc);\r\nif (!con)\r\nreturn NULL;\r\nr = nodeid_hash(nodeid);\r\nhlist_add_head(&con->list, &connection_hash[r]);\r\ncon->nodeid = nodeid;\r\nmutex_init(&con->sock_mutex);\r\nINIT_LIST_HEAD(&con->writequeue);\r\nspin_lock_init(&con->writequeue_lock);\r\nINIT_WORK(&con->swork, process_send_sockets);\r\nINIT_WORK(&con->rwork, process_recv_sockets);\r\nif (con->nodeid) {\r\nstruct connection *zerocon = __find_con(0);\r\ncon->connect_action = zerocon->connect_action;\r\nif (!con->rx_action)\r\ncon->rx_action = zerocon->rx_action;\r\n}\r\nreturn con;\r\n}\r\nstatic void foreach_conn(void (*conn_func)(struct connection *c))\r\n{\r\nint i;\r\nstruct hlist_node *n;\r\nstruct connection *con;\r\nfor (i = 0; i < CONN_HASH_SIZE; i++) {\r\nhlist_for_each_entry_safe(con, n, &connection_hash[i], list)\r\nconn_func(con);\r\n}\r\n}\r\nstatic struct connection *nodeid2con(int nodeid, gfp_t allocation)\r\n{\r\nstruct connection *con;\r\nmutex_lock(&connections_lock);\r\ncon = __nodeid2con(nodeid, allocation);\r\nmutex_unlock(&connections_lock);\r\nreturn con;\r\n}\r\nstatic struct dlm_node_addr *find_node_addr(int nodeid)\r\n{\r\nstruct dlm_node_addr *na;\r\nlist_for_each_entry(na, &dlm_node_addrs, list) {\r\nif (na->nodeid == nodeid)\r\nreturn na;\r\n}\r\nreturn NULL;\r\n}\r\nstatic int addr_compare(struct sockaddr_storage *x, struct sockaddr_storage *y)\r\n{\r\nswitch (x->ss_family) {\r\ncase AF_INET: {\r\nstruct sockaddr_in *sinx = (struct sockaddr_in *)x;\r\nstruct sockaddr_in *siny = (struct sockaddr_in *)y;\r\nif (sinx->sin_addr.s_addr != siny->sin_addr.s_addr)\r\nreturn 0;\r\nif (sinx->sin_port != siny->sin_port)\r\nreturn 0;\r\nbreak;\r\n}\r\ncase AF_INET6: {\r\nstruct sockaddr_in6 *sinx = (struct sockaddr_in6 *)x;\r\nstruct sockaddr_in6 *siny = (struct sockaddr_in6 *)y;\r\nif (!ipv6_addr_equal(&sinx->sin6_addr, &siny->sin6_addr))\r\nreturn 0;\r\nif (sinx->sin6_port != siny->sin6_port)\r\nreturn 0;\r\nbreak;\r\n}\r\ndefault:\r\nreturn 0;\r\n}\r\nreturn 1;\r\n}\r\nstatic int nodeid_to_addr(int nodeid, struct sockaddr_storage *sas_out,\r\nstruct sockaddr *sa_out, bool try_new_addr)\r\n{\r\nstruct sockaddr_storage sas;\r\nstruct dlm_node_addr *na;\r\nif (!dlm_local_count)\r\nreturn -1;\r\nspin_lock(&dlm_node_addrs_spin);\r\nna = find_node_addr(nodeid);\r\nif (na && na->addr_count) {\r\nmemcpy(&sas, na->addr[na->curr_addr_index],\r\nsizeof(struct sockaddr_storage));\r\nif (try_new_addr) {\r\nna->curr_addr_index++;\r\nif (na->curr_addr_index == na->addr_count)\r\nna->curr_addr_index = 0;\r\n}\r\n}\r\nspin_unlock(&dlm_node_addrs_spin);\r\nif (!na)\r\nreturn -EEXIST;\r\nif (!na->addr_count)\r\nreturn -ENOENT;\r\nif (sas_out)\r\nmemcpy(sas_out, &sas, sizeof(struct sockaddr_storage));\r\nif (!sa_out)\r\nreturn 0;\r\nif (dlm_local_addr[0]->ss_family == AF_INET) {\r\nstruct sockaddr_in *in4 = (struct sockaddr_in *) &sas;\r\nstruct sockaddr_in *ret4 = (struct sockaddr_in *) sa_out;\r\nret4->sin_addr.s_addr = in4->sin_addr.s_addr;\r\n} else {\r\nstruct sockaddr_in6 *in6 = (struct sockaddr_in6 *) &sas;\r\nstruct sockaddr_in6 *ret6 = (struct sockaddr_in6 *) sa_out;\r\nret6->sin6_addr = in6->sin6_addr;\r\n}\r\nreturn 0;\r\n}\r\nstatic int addr_to_nodeid(struct sockaddr_storage *addr, int *nodeid)\r\n{\r\nstruct dlm_node_addr *na;\r\nint rv = -EEXIST;\r\nint addr_i;\r\nspin_lock(&dlm_node_addrs_spin);\r\nlist_for_each_entry(na, &dlm_node_addrs, list) {\r\nif (!na->addr_count)\r\ncontinue;\r\nfor (addr_i = 0; addr_i < na->addr_count; addr_i++) {\r\nif (addr_compare(na->addr[addr_i], addr)) {\r\n*nodeid = na->nodeid;\r\nrv = 0;\r\ngoto unlock;\r\n}\r\n}\r\n}\r\nunlock:\r\nspin_unlock(&dlm_node_addrs_spin);\r\nreturn rv;\r\n}\r\nint dlm_lowcomms_addr(int nodeid, struct sockaddr_storage *addr, int len)\r\n{\r\nstruct sockaddr_storage *new_addr;\r\nstruct dlm_node_addr *new_node, *na;\r\nnew_node = kzalloc(sizeof(struct dlm_node_addr), GFP_NOFS);\r\nif (!new_node)\r\nreturn -ENOMEM;\r\nnew_addr = kzalloc(sizeof(struct sockaddr_storage), GFP_NOFS);\r\nif (!new_addr) {\r\nkfree(new_node);\r\nreturn -ENOMEM;\r\n}\r\nmemcpy(new_addr, addr, len);\r\nspin_lock(&dlm_node_addrs_spin);\r\nna = find_node_addr(nodeid);\r\nif (!na) {\r\nnew_node->nodeid = nodeid;\r\nnew_node->addr[0] = new_addr;\r\nnew_node->addr_count = 1;\r\nlist_add(&new_node->list, &dlm_node_addrs);\r\nspin_unlock(&dlm_node_addrs_spin);\r\nreturn 0;\r\n}\r\nif (na->addr_count >= DLM_MAX_ADDR_COUNT) {\r\nspin_unlock(&dlm_node_addrs_spin);\r\nkfree(new_addr);\r\nkfree(new_node);\r\nreturn -ENOSPC;\r\n}\r\nna->addr[na->addr_count++] = new_addr;\r\nspin_unlock(&dlm_node_addrs_spin);\r\nkfree(new_node);\r\nreturn 0;\r\n}\r\nstatic void lowcomms_data_ready(struct sock *sk)\r\n{\r\nstruct connection *con = sock2con(sk);\r\nif (con && !test_and_set_bit(CF_READ_PENDING, &con->flags))\r\nqueue_work(recv_workqueue, &con->rwork);\r\n}\r\nstatic void lowcomms_write_space(struct sock *sk)\r\n{\r\nstruct connection *con = sock2con(sk);\r\nif (!con)\r\nreturn;\r\nclear_bit(SOCK_NOSPACE, &con->sock->flags);\r\nif (test_and_clear_bit(CF_APP_LIMITED, &con->flags)) {\r\ncon->sock->sk->sk_write_pending--;\r\nclear_bit(SOCKWQ_ASYNC_NOSPACE, &con->sock->flags);\r\n}\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags))\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\nstatic inline void lowcomms_connect_sock(struct connection *con)\r\n{\r\nif (test_bit(CF_CLOSE, &con->flags))\r\nreturn;\r\nif (!test_and_set_bit(CF_CONNECT_PENDING, &con->flags))\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\nstatic void lowcomms_state_change(struct sock *sk)\r\n{\r\nif (sk->sk_shutdown) {\r\nif (sk->sk_shutdown == RCV_SHUTDOWN)\r\nlowcomms_data_ready(sk);\r\n} else if (sk->sk_state == TCP_ESTABLISHED) {\r\nlowcomms_write_space(sk);\r\n}\r\n}\r\nint dlm_lowcomms_connect_node(int nodeid)\r\n{\r\nstruct connection *con;\r\nif (nodeid == dlm_our_nodeid())\r\nreturn 0;\r\ncon = nodeid2con(nodeid, GFP_NOFS);\r\nif (!con)\r\nreturn -ENOMEM;\r\nlowcomms_connect_sock(con);\r\nreturn 0;\r\n}\r\nstatic void lowcomms_error_report(struct sock *sk)\r\n{\r\nstruct connection *con;\r\nstruct sockaddr_storage saddr;\r\nint buflen;\r\nvoid (*orig_report)(struct sock *) = NULL;\r\nread_lock_bh(&sk->sk_callback_lock);\r\ncon = sock2con(sk);\r\nif (con == NULL)\r\ngoto out;\r\norig_report = con->orig_error_report;\r\nif (con->sock == NULL ||\r\nkernel_getpeername(con->sock, (struct sockaddr *)&saddr, &buflen)) {\r\nprintk_ratelimited(KERN_ERR "dlm: node %d: socket error "\r\n"sending to node %d, port %d, "\r\n"sk_err=%d/%d\n", dlm_our_nodeid(),\r\ncon->nodeid, dlm_config.ci_tcp_port,\r\nsk->sk_err, sk->sk_err_soft);\r\n} else if (saddr.ss_family == AF_INET) {\r\nstruct sockaddr_in *sin4 = (struct sockaddr_in *)&saddr;\r\nprintk_ratelimited(KERN_ERR "dlm: node %d: socket error "\r\n"sending to node %d at %pI4, port %d, "\r\n"sk_err=%d/%d\n", dlm_our_nodeid(),\r\ncon->nodeid, &sin4->sin_addr.s_addr,\r\ndlm_config.ci_tcp_port, sk->sk_err,\r\nsk->sk_err_soft);\r\n} else {\r\nstruct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&saddr;\r\nprintk_ratelimited(KERN_ERR "dlm: node %d: socket error "\r\n"sending to node %d at %u.%u.%u.%u, "\r\n"port %d, sk_err=%d/%d\n", dlm_our_nodeid(),\r\ncon->nodeid, sin6->sin6_addr.s6_addr32[0],\r\nsin6->sin6_addr.s6_addr32[1],\r\nsin6->sin6_addr.s6_addr32[2],\r\nsin6->sin6_addr.s6_addr32[3],\r\ndlm_config.ci_tcp_port, sk->sk_err,\r\nsk->sk_err_soft);\r\n}\r\nout:\r\nread_unlock_bh(&sk->sk_callback_lock);\r\nif (orig_report)\r\norig_report(sk);\r\n}\r\nstatic void save_callbacks(struct connection *con, struct sock *sk)\r\n{\r\ncon->orig_data_ready = sk->sk_data_ready;\r\ncon->orig_state_change = sk->sk_state_change;\r\ncon->orig_write_space = sk->sk_write_space;\r\ncon->orig_error_report = sk->sk_error_report;\r\n}\r\nstatic void restore_callbacks(struct connection *con, struct sock *sk)\r\n{\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\nsk->sk_user_data = NULL;\r\nsk->sk_data_ready = con->orig_data_ready;\r\nsk->sk_state_change = con->orig_state_change;\r\nsk->sk_write_space = con->orig_write_space;\r\nsk->sk_error_report = con->orig_error_report;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void add_sock(struct socket *sock, struct connection *con, bool save_cb)\r\n{\r\nstruct sock *sk = sock->sk;\r\nwrite_lock_bh(&sk->sk_callback_lock);\r\ncon->sock = sock;\r\nsk->sk_user_data = con;\r\nif (save_cb)\r\nsave_callbacks(con, sk);\r\nsk->sk_data_ready = lowcomms_data_ready;\r\nsk->sk_write_space = lowcomms_write_space;\r\nsk->sk_state_change = lowcomms_state_change;\r\nsk->sk_allocation = GFP_NOFS;\r\nsk->sk_error_report = lowcomms_error_report;\r\nwrite_unlock_bh(&sk->sk_callback_lock);\r\n}\r\nstatic void make_sockaddr(struct sockaddr_storage *saddr, uint16_t port,\r\nint *addr_len)\r\n{\r\nsaddr->ss_family = dlm_local_addr[0]->ss_family;\r\nif (saddr->ss_family == AF_INET) {\r\nstruct sockaddr_in *in4_addr = (struct sockaddr_in *)saddr;\r\nin4_addr->sin_port = cpu_to_be16(port);\r\n*addr_len = sizeof(struct sockaddr_in);\r\nmemset(&in4_addr->sin_zero, 0, sizeof(in4_addr->sin_zero));\r\n} else {\r\nstruct sockaddr_in6 *in6_addr = (struct sockaddr_in6 *)saddr;\r\nin6_addr->sin6_port = cpu_to_be16(port);\r\n*addr_len = sizeof(struct sockaddr_in6);\r\n}\r\nmemset((char *)saddr + *addr_len, 0, sizeof(struct sockaddr_storage) - *addr_len);\r\n}\r\nstatic void close_connection(struct connection *con, bool and_other,\r\nbool tx, bool rx)\r\n{\r\nclear_bit(CF_CONNECT_PENDING, &con->flags);\r\nclear_bit(CF_WRITE_PENDING, &con->flags);\r\nif (tx && cancel_work_sync(&con->swork))\r\nlog_print("canceled swork for node %d", con->nodeid);\r\nif (rx && cancel_work_sync(&con->rwork))\r\nlog_print("canceled rwork for node %d", con->nodeid);\r\nmutex_lock(&con->sock_mutex);\r\nif (con->sock) {\r\nif (!test_bit(CF_IS_OTHERCON, &con->flags))\r\nrestore_callbacks(con, con->sock->sk);\r\nsock_release(con->sock);\r\ncon->sock = NULL;\r\n}\r\nif (con->othercon && and_other) {\r\nclose_connection(con->othercon, false, true, true);\r\n}\r\nif (con->rx_page) {\r\n__free_page(con->rx_page);\r\ncon->rx_page = NULL;\r\n}\r\ncon->retries = 0;\r\nmutex_unlock(&con->sock_mutex);\r\n}\r\nstatic int receive_from_sock(struct connection *con)\r\n{\r\nint ret = 0;\r\nstruct msghdr msg = {};\r\nstruct kvec iov[2];\r\nunsigned len;\r\nint r;\r\nint call_again_soon = 0;\r\nint nvec;\r\nmutex_lock(&con->sock_mutex);\r\nif (con->sock == NULL) {\r\nret = -EAGAIN;\r\ngoto out_close;\r\n}\r\nif (con->nodeid == 0) {\r\nret = -EINVAL;\r\ngoto out_close;\r\n}\r\nif (con->rx_page == NULL) {\r\ncon->rx_page = alloc_page(GFP_ATOMIC);\r\nif (con->rx_page == NULL)\r\ngoto out_resched;\r\ncbuf_init(&con->cb, PAGE_SIZE);\r\n}\r\niov[0].iov_len = con->cb.base - cbuf_data(&con->cb);\r\niov[0].iov_base = page_address(con->rx_page) + cbuf_data(&con->cb);\r\niov[1].iov_len = 0;\r\nnvec = 1;\r\nif (cbuf_data(&con->cb) >= con->cb.base) {\r\niov[0].iov_len = PAGE_SIZE - cbuf_data(&con->cb);\r\niov[1].iov_len = con->cb.base;\r\niov[1].iov_base = page_address(con->rx_page);\r\nnvec = 2;\r\n}\r\nlen = iov[0].iov_len + iov[1].iov_len;\r\nr = ret = kernel_recvmsg(con->sock, &msg, iov, nvec, len,\r\nMSG_DONTWAIT | MSG_NOSIGNAL);\r\nif (ret <= 0)\r\ngoto out_close;\r\nelse if (ret == len)\r\ncall_again_soon = 1;\r\ncbuf_add(&con->cb, ret);\r\nret = dlm_process_incoming_buffer(con->nodeid,\r\npage_address(con->rx_page),\r\ncon->cb.base, con->cb.len,\r\nPAGE_SIZE);\r\nif (ret == -EBADMSG) {\r\nlog_print("lowcomms: addr=%p, base=%u, len=%u, read=%d",\r\npage_address(con->rx_page), con->cb.base,\r\ncon->cb.len, r);\r\n}\r\nif (ret < 0)\r\ngoto out_close;\r\ncbuf_eat(&con->cb, ret);\r\nif (cbuf_empty(&con->cb) && !call_again_soon) {\r\n__free_page(con->rx_page);\r\ncon->rx_page = NULL;\r\n}\r\nif (call_again_soon)\r\ngoto out_resched;\r\nmutex_unlock(&con->sock_mutex);\r\nreturn 0;\r\nout_resched:\r\nif (!test_and_set_bit(CF_READ_PENDING, &con->flags))\r\nqueue_work(recv_workqueue, &con->rwork);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn -EAGAIN;\r\nout_close:\r\nmutex_unlock(&con->sock_mutex);\r\nif (ret != -EAGAIN) {\r\nclose_connection(con, false, true, false);\r\n}\r\nif (ret == 0)\r\nret = -EAGAIN;\r\nreturn ret;\r\n}\r\nstatic int tcp_accept_from_sock(struct connection *con)\r\n{\r\nint result;\r\nstruct sockaddr_storage peeraddr;\r\nstruct socket *newsock;\r\nint len;\r\nint nodeid;\r\nstruct connection *newcon;\r\nstruct connection *addcon;\r\nmutex_lock(&connections_lock);\r\nif (!dlm_allow_conn) {\r\nmutex_unlock(&connections_lock);\r\nreturn -1;\r\n}\r\nmutex_unlock(&connections_lock);\r\nmemset(&peeraddr, 0, sizeof(peeraddr));\r\nresult = sock_create_kern(&init_net, dlm_local_addr[0]->ss_family,\r\nSOCK_STREAM, IPPROTO_TCP, &newsock);\r\nif (result < 0)\r\nreturn -ENOMEM;\r\nmutex_lock_nested(&con->sock_mutex, 0);\r\nresult = -ENOTCONN;\r\nif (con->sock == NULL)\r\ngoto accept_err;\r\nnewsock->type = con->sock->type;\r\nnewsock->ops = con->sock->ops;\r\nresult = con->sock->ops->accept(con->sock, newsock, O_NONBLOCK, true);\r\nif (result < 0)\r\ngoto accept_err;\r\nmemset(&peeraddr, 0, sizeof(peeraddr));\r\nif (newsock->ops->getname(newsock, (struct sockaddr *)&peeraddr,\r\n&len, 2)) {\r\nresult = -ECONNABORTED;\r\ngoto accept_err;\r\n}\r\nmake_sockaddr(&peeraddr, 0, &len);\r\nif (addr_to_nodeid(&peeraddr, &nodeid)) {\r\nunsigned char *b=(unsigned char *)&peeraddr;\r\nlog_print("connect from non cluster node");\r\nprint_hex_dump_bytes("ss: ", DUMP_PREFIX_NONE,\r\nb, sizeof(struct sockaddr_storage));\r\nsock_release(newsock);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn -1;\r\n}\r\nlog_print("got connection from %d", nodeid);\r\nnewcon = nodeid2con(nodeid, GFP_NOFS);\r\nif (!newcon) {\r\nresult = -ENOMEM;\r\ngoto accept_err;\r\n}\r\nmutex_lock_nested(&newcon->sock_mutex, 1);\r\nif (newcon->sock) {\r\nstruct connection *othercon = newcon->othercon;\r\nif (!othercon) {\r\nothercon = kmem_cache_zalloc(con_cache, GFP_NOFS);\r\nif (!othercon) {\r\nlog_print("failed to allocate incoming socket");\r\nmutex_unlock(&newcon->sock_mutex);\r\nresult = -ENOMEM;\r\ngoto accept_err;\r\n}\r\nothercon->nodeid = nodeid;\r\nothercon->rx_action = receive_from_sock;\r\nmutex_init(&othercon->sock_mutex);\r\nINIT_WORK(&othercon->swork, process_send_sockets);\r\nINIT_WORK(&othercon->rwork, process_recv_sockets);\r\nset_bit(CF_IS_OTHERCON, &othercon->flags);\r\n}\r\nif (!othercon->sock) {\r\nnewcon->othercon = othercon;\r\nothercon->sock = newsock;\r\nnewsock->sk->sk_user_data = othercon;\r\nadd_sock(newsock, othercon, false);\r\naddcon = othercon;\r\n}\r\nelse {\r\nprintk("Extra connection from node %d attempted\n", nodeid);\r\nresult = -EAGAIN;\r\nmutex_unlock(&newcon->sock_mutex);\r\ngoto accept_err;\r\n}\r\n}\r\nelse {\r\nnewsock->sk->sk_user_data = newcon;\r\nnewcon->rx_action = receive_from_sock;\r\nadd_sock(newsock, newcon, false);\r\naddcon = newcon;\r\n}\r\nmutex_unlock(&newcon->sock_mutex);\r\nif (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))\r\nqueue_work(recv_workqueue, &addcon->rwork);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn 0;\r\naccept_err:\r\nmutex_unlock(&con->sock_mutex);\r\nsock_release(newsock);\r\nif (result != -EAGAIN)\r\nlog_print("error accepting connection from node: %d", result);\r\nreturn result;\r\n}\r\nstatic int sctp_accept_from_sock(struct connection *con)\r\n{\r\nstruct sctp_prim prim;\r\nint nodeid;\r\nint prim_len, ret;\r\nint addr_len;\r\nstruct connection *newcon;\r\nstruct connection *addcon;\r\nstruct socket *newsock;\r\nmutex_lock(&connections_lock);\r\nif (!dlm_allow_conn) {\r\nmutex_unlock(&connections_lock);\r\nreturn -1;\r\n}\r\nmutex_unlock(&connections_lock);\r\nmutex_lock_nested(&con->sock_mutex, 0);\r\nret = kernel_accept(con->sock, &newsock, O_NONBLOCK);\r\nif (ret < 0)\r\ngoto accept_err;\r\nmemset(&prim, 0, sizeof(struct sctp_prim));\r\nprim_len = sizeof(struct sctp_prim);\r\nret = kernel_getsockopt(newsock, IPPROTO_SCTP, SCTP_PRIMARY_ADDR,\r\n(char *)&prim, &prim_len);\r\nif (ret < 0) {\r\nlog_print("getsockopt/sctp_primary_addr failed: %d", ret);\r\ngoto accept_err;\r\n}\r\nmake_sockaddr(&prim.ssp_addr, 0, &addr_len);\r\nret = addr_to_nodeid(&prim.ssp_addr, &nodeid);\r\nif (ret) {\r\nunsigned char *b = (unsigned char *)&prim.ssp_addr;\r\nlog_print("reject connect from unknown addr");\r\nprint_hex_dump_bytes("ss: ", DUMP_PREFIX_NONE,\r\nb, sizeof(struct sockaddr_storage));\r\ngoto accept_err;\r\n}\r\nnewcon = nodeid2con(nodeid, GFP_NOFS);\r\nif (!newcon) {\r\nret = -ENOMEM;\r\ngoto accept_err;\r\n}\r\nmutex_lock_nested(&newcon->sock_mutex, 1);\r\nif (newcon->sock) {\r\nstruct connection *othercon = newcon->othercon;\r\nif (!othercon) {\r\nothercon = kmem_cache_zalloc(con_cache, GFP_NOFS);\r\nif (!othercon) {\r\nlog_print("failed to allocate incoming socket");\r\nmutex_unlock(&newcon->sock_mutex);\r\nret = -ENOMEM;\r\ngoto accept_err;\r\n}\r\nothercon->nodeid = nodeid;\r\nothercon->rx_action = receive_from_sock;\r\nmutex_init(&othercon->sock_mutex);\r\nINIT_WORK(&othercon->swork, process_send_sockets);\r\nINIT_WORK(&othercon->rwork, process_recv_sockets);\r\nset_bit(CF_IS_OTHERCON, &othercon->flags);\r\n}\r\nif (!othercon->sock) {\r\nnewcon->othercon = othercon;\r\nothercon->sock = newsock;\r\nnewsock->sk->sk_user_data = othercon;\r\nadd_sock(newsock, othercon, false);\r\naddcon = othercon;\r\n} else {\r\nprintk("Extra connection from node %d attempted\n", nodeid);\r\nret = -EAGAIN;\r\nmutex_unlock(&newcon->sock_mutex);\r\ngoto accept_err;\r\n}\r\n} else {\r\nnewsock->sk->sk_user_data = newcon;\r\nnewcon->rx_action = receive_from_sock;\r\nadd_sock(newsock, newcon, false);\r\naddcon = newcon;\r\n}\r\nlog_print("connected to %d", nodeid);\r\nmutex_unlock(&newcon->sock_mutex);\r\nif (!test_and_set_bit(CF_READ_PENDING, &addcon->flags))\r\nqueue_work(recv_workqueue, &addcon->rwork);\r\nmutex_unlock(&con->sock_mutex);\r\nreturn 0;\r\naccept_err:\r\nmutex_unlock(&con->sock_mutex);\r\nif (newsock)\r\nsock_release(newsock);\r\nif (ret != -EAGAIN)\r\nlog_print("error accepting connection from node: %d", ret);\r\nreturn ret;\r\n}\r\nstatic void free_entry(struct writequeue_entry *e)\r\n{\r\n__free_page(e->page);\r\nkfree(e);\r\n}\r\nstatic void writequeue_entry_complete(struct writequeue_entry *e, int completed)\r\n{\r\ne->offset += completed;\r\ne->len -= completed;\r\nif (e->len == 0 && e->users == 0) {\r\nlist_del(&e->list);\r\nfree_entry(e);\r\n}\r\n}\r\nstatic int sctp_bind_addrs(struct connection *con, uint16_t port)\r\n{\r\nstruct sockaddr_storage localaddr;\r\nint i, addr_len, result = 0;\r\nfor (i = 0; i < dlm_local_count; i++) {\r\nmemcpy(&localaddr, dlm_local_addr[i], sizeof(localaddr));\r\nmake_sockaddr(&localaddr, port, &addr_len);\r\nif (!i)\r\nresult = kernel_bind(con->sock,\r\n(struct sockaddr *)&localaddr,\r\naddr_len);\r\nelse\r\nresult = kernel_setsockopt(con->sock, SOL_SCTP,\r\nSCTP_SOCKOPT_BINDX_ADD,\r\n(char *)&localaddr, addr_len);\r\nif (result < 0) {\r\nlog_print("Can't bind to %d addr number %d, %d.\n",\r\nport, i + 1, result);\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nstatic void sctp_connect_to_sock(struct connection *con)\r\n{\r\nstruct sockaddr_storage daddr;\r\nint one = 1;\r\nint result;\r\nint addr_len;\r\nstruct socket *sock;\r\nif (con->nodeid == 0) {\r\nlog_print("attempt to connect sock 0 foiled");\r\nreturn;\r\n}\r\nmutex_lock(&con->sock_mutex);\r\nif (con->retries++ > MAX_CONNECT_RETRIES)\r\ngoto out;\r\nif (con->sock) {\r\nlog_print("node %d already connected.", con->nodeid);\r\ngoto out;\r\n}\r\nmemset(&daddr, 0, sizeof(daddr));\r\nresult = nodeid_to_addr(con->nodeid, &daddr, NULL, true);\r\nif (result < 0) {\r\nlog_print("no address for nodeid %d", con->nodeid);\r\ngoto out;\r\n}\r\nresult = sock_create_kern(&init_net, dlm_local_addr[0]->ss_family,\r\nSOCK_STREAM, IPPROTO_SCTP, &sock);\r\nif (result < 0)\r\ngoto socket_err;\r\nsock->sk->sk_user_data = con;\r\ncon->rx_action = receive_from_sock;\r\ncon->connect_action = sctp_connect_to_sock;\r\nadd_sock(sock, con, true);\r\nif (sctp_bind_addrs(con, 0))\r\ngoto bind_err;\r\nmake_sockaddr(&daddr, dlm_config.ci_tcp_port, &addr_len);\r\nlog_print("connecting to %d", con->nodeid);\r\nkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nresult = sock->ops->connect(sock, (struct sockaddr *)&daddr, addr_len,\r\nO_NONBLOCK);\r\nif (result == -EINPROGRESS)\r\nresult = 0;\r\nif (result == 0)\r\ngoto out;\r\nbind_err:\r\ncon->sock = NULL;\r\nsock_release(sock);\r\nsocket_err:\r\nif (result != -EHOSTUNREACH &&\r\nresult != -ENETUNREACH &&\r\nresult != -ENETDOWN &&\r\nresult != -EINVAL &&\r\nresult != -EPROTONOSUPPORT) {\r\nlog_print("connect %d try %d error %d", con->nodeid,\r\ncon->retries, result);\r\nmutex_unlock(&con->sock_mutex);\r\nmsleep(1000);\r\nclear_bit(CF_CONNECT_PENDING, &con->flags);\r\nlowcomms_connect_sock(con);\r\nreturn;\r\n}\r\nout:\r\nmutex_unlock(&con->sock_mutex);\r\nset_bit(CF_WRITE_PENDING, &con->flags);\r\n}\r\nstatic void tcp_connect_to_sock(struct connection *con)\r\n{\r\nstruct sockaddr_storage saddr, src_addr;\r\nint addr_len;\r\nstruct socket *sock = NULL;\r\nint one = 1;\r\nint result;\r\nif (con->nodeid == 0) {\r\nlog_print("attempt to connect sock 0 foiled");\r\nreturn;\r\n}\r\nmutex_lock(&con->sock_mutex);\r\nif (con->retries++ > MAX_CONNECT_RETRIES)\r\ngoto out;\r\nif (con->sock)\r\ngoto out;\r\nresult = sock_create_kern(&init_net, dlm_local_addr[0]->ss_family,\r\nSOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (result < 0)\r\ngoto out_err;\r\nmemset(&saddr, 0, sizeof(saddr));\r\nresult = nodeid_to_addr(con->nodeid, &saddr, NULL, false);\r\nif (result < 0) {\r\nlog_print("no address for nodeid %d", con->nodeid);\r\ngoto out_err;\r\n}\r\nsock->sk->sk_user_data = con;\r\ncon->rx_action = receive_from_sock;\r\ncon->connect_action = tcp_connect_to_sock;\r\nadd_sock(sock, con, true);\r\nmemcpy(&src_addr, dlm_local_addr[0], sizeof(src_addr));\r\nmake_sockaddr(&src_addr, 0, &addr_len);\r\nresult = sock->ops->bind(sock, (struct sockaddr *) &src_addr,\r\naddr_len);\r\nif (result < 0) {\r\nlog_print("could not bind for connect: %d", result);\r\n}\r\nmake_sockaddr(&saddr, dlm_config.ci_tcp_port, &addr_len);\r\nlog_print("connecting to %d", con->nodeid);\r\nkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nresult = sock->ops->connect(sock, (struct sockaddr *)&saddr, addr_len,\r\nO_NONBLOCK);\r\nif (result == -EINPROGRESS)\r\nresult = 0;\r\nif (result == 0)\r\ngoto out;\r\nout_err:\r\nif (con->sock) {\r\nsock_release(con->sock);\r\ncon->sock = NULL;\r\n} else if (sock) {\r\nsock_release(sock);\r\n}\r\nif (result != -EHOSTUNREACH &&\r\nresult != -ENETUNREACH &&\r\nresult != -ENETDOWN &&\r\nresult != -EINVAL &&\r\nresult != -EPROTONOSUPPORT) {\r\nlog_print("connect %d try %d error %d", con->nodeid,\r\ncon->retries, result);\r\nmutex_unlock(&con->sock_mutex);\r\nmsleep(1000);\r\nclear_bit(CF_CONNECT_PENDING, &con->flags);\r\nlowcomms_connect_sock(con);\r\nreturn;\r\n}\r\nout:\r\nmutex_unlock(&con->sock_mutex);\r\nset_bit(CF_WRITE_PENDING, &con->flags);\r\nreturn;\r\n}\r\nstatic struct socket *tcp_create_listen_sock(struct connection *con,\r\nstruct sockaddr_storage *saddr)\r\n{\r\nstruct socket *sock = NULL;\r\nint result = 0;\r\nint one = 1;\r\nint addr_len;\r\nif (dlm_local_addr[0]->ss_family == AF_INET)\r\naddr_len = sizeof(struct sockaddr_in);\r\nelse\r\naddr_len = sizeof(struct sockaddr_in6);\r\nresult = sock_create_kern(&init_net, dlm_local_addr[0]->ss_family,\r\nSOCK_STREAM, IPPROTO_TCP, &sock);\r\nif (result < 0) {\r\nlog_print("Can't create listening comms socket");\r\ngoto create_out;\r\n}\r\nkernel_setsockopt(sock, SOL_TCP, TCP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nresult = kernel_setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\r\n(char *)&one, sizeof(one));\r\nif (result < 0) {\r\nlog_print("Failed to set SO_REUSEADDR on socket: %d", result);\r\n}\r\nsock->sk->sk_user_data = con;\r\ncon->rx_action = tcp_accept_from_sock;\r\ncon->connect_action = tcp_connect_to_sock;\r\nmake_sockaddr(saddr, dlm_config.ci_tcp_port, &addr_len);\r\nresult = sock->ops->bind(sock, (struct sockaddr *) saddr, addr_len);\r\nif (result < 0) {\r\nlog_print("Can't bind to port %d", dlm_config.ci_tcp_port);\r\nsock_release(sock);\r\nsock = NULL;\r\ncon->sock = NULL;\r\ngoto create_out;\r\n}\r\nresult = kernel_setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE,\r\n(char *)&one, sizeof(one));\r\nif (result < 0) {\r\nlog_print("Set keepalive failed: %d", result);\r\n}\r\nresult = sock->ops->listen(sock, 5);\r\nif (result < 0) {\r\nlog_print("Can't listen on port %d", dlm_config.ci_tcp_port);\r\nsock_release(sock);\r\nsock = NULL;\r\ngoto create_out;\r\n}\r\ncreate_out:\r\nreturn sock;\r\n}\r\nstatic void init_local(void)\r\n{\r\nstruct sockaddr_storage sas, *addr;\r\nint i;\r\ndlm_local_count = 0;\r\nfor (i = 0; i < DLM_MAX_ADDR_COUNT; i++) {\r\nif (dlm_our_addr(&sas, i))\r\nbreak;\r\naddr = kmemdup(&sas, sizeof(*addr), GFP_NOFS);\r\nif (!addr)\r\nbreak;\r\ndlm_local_addr[dlm_local_count++] = addr;\r\n}\r\n}\r\nstatic int sctp_listen_for_all(void)\r\n{\r\nstruct socket *sock = NULL;\r\nint result = -EINVAL;\r\nstruct connection *con = nodeid2con(0, GFP_NOFS);\r\nint bufsize = NEEDED_RMEM;\r\nint one = 1;\r\nif (!con)\r\nreturn -ENOMEM;\r\nlog_print("Using SCTP for communications");\r\nresult = sock_create_kern(&init_net, dlm_local_addr[0]->ss_family,\r\nSOCK_STREAM, IPPROTO_SCTP, &sock);\r\nif (result < 0) {\r\nlog_print("Can't create comms socket, check SCTP is loaded");\r\ngoto out;\r\n}\r\nresult = kernel_setsockopt(sock, SOL_SOCKET, SO_RCVBUFFORCE,\r\n(char *)&bufsize, sizeof(bufsize));\r\nif (result)\r\nlog_print("Error increasing buffer space on socket %d", result);\r\nresult = kernel_setsockopt(sock, SOL_SCTP, SCTP_NODELAY, (char *)&one,\r\nsizeof(one));\r\nif (result < 0)\r\nlog_print("Could not set SCTP NODELAY error %d\n", result);\r\nwrite_lock_bh(&sock->sk->sk_callback_lock);\r\nsock->sk->sk_user_data = con;\r\ncon->sock = sock;\r\ncon->sock->sk->sk_data_ready = lowcomms_data_ready;\r\ncon->rx_action = sctp_accept_from_sock;\r\ncon->connect_action = sctp_connect_to_sock;\r\nwrite_unlock_bh(&sock->sk->sk_callback_lock);\r\nif (sctp_bind_addrs(con, dlm_config.ci_tcp_port))\r\ngoto create_delsock;\r\nresult = sock->ops->listen(sock, 5);\r\nif (result < 0) {\r\nlog_print("Can't set socket listening");\r\ngoto create_delsock;\r\n}\r\nreturn 0;\r\ncreate_delsock:\r\nsock_release(sock);\r\ncon->sock = NULL;\r\nout:\r\nreturn result;\r\n}\r\nstatic int tcp_listen_for_all(void)\r\n{\r\nstruct socket *sock = NULL;\r\nstruct connection *con = nodeid2con(0, GFP_NOFS);\r\nint result = -EINVAL;\r\nif (!con)\r\nreturn -ENOMEM;\r\nif (dlm_local_addr[1] != NULL) {\r\nlog_print("TCP protocol can't handle multi-homed hosts, "\r\n"try SCTP");\r\nreturn -EINVAL;\r\n}\r\nlog_print("Using TCP for communications");\r\nsock = tcp_create_listen_sock(con, dlm_local_addr[0]);\r\nif (sock) {\r\nadd_sock(sock, con, true);\r\nresult = 0;\r\n}\r\nelse {\r\nresult = -EADDRINUSE;\r\n}\r\nreturn result;\r\n}\r\nstatic struct writequeue_entry *new_writequeue_entry(struct connection *con,\r\ngfp_t allocation)\r\n{\r\nstruct writequeue_entry *entry;\r\nentry = kmalloc(sizeof(struct writequeue_entry), allocation);\r\nif (!entry)\r\nreturn NULL;\r\nentry->page = alloc_page(allocation);\r\nif (!entry->page) {\r\nkfree(entry);\r\nreturn NULL;\r\n}\r\nentry->offset = 0;\r\nentry->len = 0;\r\nentry->end = 0;\r\nentry->users = 0;\r\nentry->con = con;\r\nreturn entry;\r\n}\r\nvoid *dlm_lowcomms_get_buffer(int nodeid, int len, gfp_t allocation, char **ppc)\r\n{\r\nstruct connection *con;\r\nstruct writequeue_entry *e;\r\nint offset = 0;\r\ncon = nodeid2con(nodeid, allocation);\r\nif (!con)\r\nreturn NULL;\r\nspin_lock(&con->writequeue_lock);\r\ne = list_entry(con->writequeue.prev, struct writequeue_entry, list);\r\nif ((&e->list == &con->writequeue) ||\r\n(PAGE_SIZE - e->end < len)) {\r\ne = NULL;\r\n} else {\r\noffset = e->end;\r\ne->end += len;\r\ne->users++;\r\n}\r\nspin_unlock(&con->writequeue_lock);\r\nif (e) {\r\ngot_one:\r\n*ppc = page_address(e->page) + offset;\r\nreturn e;\r\n}\r\ne = new_writequeue_entry(con, allocation);\r\nif (e) {\r\nspin_lock(&con->writequeue_lock);\r\noffset = e->end;\r\ne->end += len;\r\ne->users++;\r\nlist_add_tail(&e->list, &con->writequeue);\r\nspin_unlock(&con->writequeue_lock);\r\ngoto got_one;\r\n}\r\nreturn NULL;\r\n}\r\nvoid dlm_lowcomms_commit_buffer(void *mh)\r\n{\r\nstruct writequeue_entry *e = (struct writequeue_entry *)mh;\r\nstruct connection *con = e->con;\r\nint users;\r\nspin_lock(&con->writequeue_lock);\r\nusers = --e->users;\r\nif (users)\r\ngoto out;\r\ne->len = e->end - e->offset;\r\nspin_unlock(&con->writequeue_lock);\r\nif (!test_and_set_bit(CF_WRITE_PENDING, &con->flags)) {\r\nqueue_work(send_workqueue, &con->swork);\r\n}\r\nreturn;\r\nout:\r\nspin_unlock(&con->writequeue_lock);\r\nreturn;\r\n}\r\nstatic void send_to_sock(struct connection *con)\r\n{\r\nint ret = 0;\r\nconst int msg_flags = MSG_DONTWAIT | MSG_NOSIGNAL;\r\nstruct writequeue_entry *e;\r\nint len, offset;\r\nint count = 0;\r\nmutex_lock(&con->sock_mutex);\r\nif (con->sock == NULL)\r\ngoto out_connect;\r\nspin_lock(&con->writequeue_lock);\r\nfor (;;) {\r\ne = list_entry(con->writequeue.next, struct writequeue_entry,\r\nlist);\r\nif ((struct list_head *) e == &con->writequeue)\r\nbreak;\r\nlen = e->len;\r\noffset = e->offset;\r\nBUG_ON(len == 0 && e->users == 0);\r\nspin_unlock(&con->writequeue_lock);\r\nret = 0;\r\nif (len) {\r\nret = kernel_sendpage(con->sock, e->page, offset, len,\r\nmsg_flags);\r\nif (ret == -EAGAIN || ret == 0) {\r\nif (ret == -EAGAIN &&\r\ntest_bit(SOCKWQ_ASYNC_NOSPACE, &con->sock->flags) &&\r\n!test_and_set_bit(CF_APP_LIMITED, &con->flags)) {\r\nset_bit(SOCK_NOSPACE, &con->sock->flags);\r\ncon->sock->sk->sk_write_pending++;\r\n}\r\ncond_resched();\r\ngoto out;\r\n} else if (ret < 0)\r\ngoto send_error;\r\n}\r\nif (++count >= MAX_SEND_MSG_COUNT) {\r\ncond_resched();\r\ncount = 0;\r\n}\r\nspin_lock(&con->writequeue_lock);\r\nwritequeue_entry_complete(e, ret);\r\n}\r\nspin_unlock(&con->writequeue_lock);\r\nout:\r\nmutex_unlock(&con->sock_mutex);\r\nreturn;\r\nsend_error:\r\nmutex_unlock(&con->sock_mutex);\r\nclose_connection(con, false, false, true);\r\nlowcomms_connect_sock(con);\r\nreturn;\r\nout_connect:\r\nmutex_unlock(&con->sock_mutex);\r\nlowcomms_connect_sock(con);\r\n}\r\nstatic void clean_one_writequeue(struct connection *con)\r\n{\r\nstruct writequeue_entry *e, *safe;\r\nspin_lock(&con->writequeue_lock);\r\nlist_for_each_entry_safe(e, safe, &con->writequeue, list) {\r\nlist_del(&e->list);\r\nfree_entry(e);\r\n}\r\nspin_unlock(&con->writequeue_lock);\r\n}\r\nint dlm_lowcomms_close(int nodeid)\r\n{\r\nstruct connection *con;\r\nstruct dlm_node_addr *na;\r\nlog_print("closing connection to node %d", nodeid);\r\ncon = nodeid2con(nodeid, 0);\r\nif (con) {\r\nset_bit(CF_CLOSE, &con->flags);\r\nclose_connection(con, true, true, true);\r\nclean_one_writequeue(con);\r\n}\r\nspin_lock(&dlm_node_addrs_spin);\r\nna = find_node_addr(nodeid);\r\nif (na) {\r\nlist_del(&na->list);\r\nwhile (na->addr_count--)\r\nkfree(na->addr[na->addr_count]);\r\nkfree(na);\r\n}\r\nspin_unlock(&dlm_node_addrs_spin);\r\nreturn 0;\r\n}\r\nstatic void process_recv_sockets(struct work_struct *work)\r\n{\r\nstruct connection *con = container_of(work, struct connection, rwork);\r\nint err;\r\nclear_bit(CF_READ_PENDING, &con->flags);\r\ndo {\r\nerr = con->rx_action(con);\r\n} while (!err);\r\n}\r\nstatic void process_send_sockets(struct work_struct *work)\r\n{\r\nstruct connection *con = container_of(work, struct connection, swork);\r\nif (test_and_clear_bit(CF_CONNECT_PENDING, &con->flags))\r\ncon->connect_action(con);\r\nif (test_and_clear_bit(CF_WRITE_PENDING, &con->flags))\r\nsend_to_sock(con);\r\n}\r\nstatic void clean_writequeues(void)\r\n{\r\nforeach_conn(clean_one_writequeue);\r\n}\r\nstatic void work_stop(void)\r\n{\r\ndestroy_workqueue(recv_workqueue);\r\ndestroy_workqueue(send_workqueue);\r\n}\r\nstatic int work_start(void)\r\n{\r\nrecv_workqueue = alloc_workqueue("dlm_recv",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM, 1);\r\nif (!recv_workqueue) {\r\nlog_print("can't start dlm_recv");\r\nreturn -ENOMEM;\r\n}\r\nsend_workqueue = alloc_workqueue("dlm_send",\r\nWQ_UNBOUND | WQ_MEM_RECLAIM, 1);\r\nif (!send_workqueue) {\r\nlog_print("can't start dlm_send");\r\ndestroy_workqueue(recv_workqueue);\r\nreturn -ENOMEM;\r\n}\r\nreturn 0;\r\n}\r\nstatic void stop_conn(struct connection *con)\r\n{\r\ncon->flags |= 0x0F;\r\nif (con->sock && con->sock->sk)\r\ncon->sock->sk->sk_user_data = NULL;\r\n}\r\nstatic void free_conn(struct connection *con)\r\n{\r\nclose_connection(con, true, true, true);\r\nif (con->othercon)\r\nkmem_cache_free(con_cache, con->othercon);\r\nhlist_del(&con->list);\r\nkmem_cache_free(con_cache, con);\r\n}\r\nvoid dlm_lowcomms_stop(void)\r\n{\r\nmutex_lock(&connections_lock);\r\ndlm_allow_conn = 0;\r\nforeach_conn(stop_conn);\r\nclean_writequeues();\r\nforeach_conn(free_conn);\r\nmutex_unlock(&connections_lock);\r\nwork_stop();\r\nkmem_cache_destroy(con_cache);\r\n}\r\nint dlm_lowcomms_start(void)\r\n{\r\nint error = -EINVAL;\r\nstruct connection *con;\r\nint i;\r\nfor (i = 0; i < CONN_HASH_SIZE; i++)\r\nINIT_HLIST_HEAD(&connection_hash[i]);\r\ninit_local();\r\nif (!dlm_local_count) {\r\nerror = -ENOTCONN;\r\nlog_print("no local IP address has been set");\r\ngoto fail;\r\n}\r\nerror = -ENOMEM;\r\ncon_cache = kmem_cache_create("dlm_conn", sizeof(struct connection),\r\n__alignof__(struct connection), 0,\r\nNULL);\r\nif (!con_cache)\r\ngoto fail;\r\nerror = work_start();\r\nif (error)\r\ngoto fail_destroy;\r\ndlm_allow_conn = 1;\r\nif (dlm_config.ci_protocol == 0)\r\nerror = tcp_listen_for_all();\r\nelse\r\nerror = sctp_listen_for_all();\r\nif (error)\r\ngoto fail_unlisten;\r\nreturn 0;\r\nfail_unlisten:\r\ndlm_allow_conn = 0;\r\ncon = nodeid2con(0,0);\r\nif (con) {\r\nclose_connection(con, false, true, true);\r\nkmem_cache_free(con_cache, con);\r\n}\r\nfail_destroy:\r\nkmem_cache_destroy(con_cache);\r\nfail:\r\nreturn error;\r\n}\r\nvoid dlm_lowcomms_exit(void)\r\n{\r\nstruct dlm_node_addr *na, *safe;\r\nspin_lock(&dlm_node_addrs_spin);\r\nlist_for_each_entry_safe(na, safe, &dlm_node_addrs, list) {\r\nlist_del(&na->list);\r\nwhile (na->addr_count--)\r\nkfree(na->addr[na->addr_count]);\r\nkfree(na);\r\n}\r\nspin_unlock(&dlm_node_addrs_spin);\r\n}
