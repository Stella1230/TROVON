static void mtk_plane_reset(struct drm_plane *plane)\r\n{\r\nstruct mtk_plane_state *state;\r\nif (plane->state) {\r\n__drm_atomic_helper_plane_destroy_state(plane->state);\r\nstate = to_mtk_plane_state(plane->state);\r\nmemset(state, 0, sizeof(*state));\r\n} else {\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn;\r\nplane->state = &state->base;\r\n}\r\nstate->base.plane = plane;\r\nstate->pending.format = DRM_FORMAT_RGB565;\r\n}\r\nstatic struct drm_plane_state *mtk_plane_duplicate_state(struct drm_plane *plane)\r\n{\r\nstruct mtk_plane_state *old_state = to_mtk_plane_state(plane->state);\r\nstruct mtk_plane_state *state;\r\nstate = kzalloc(sizeof(*state), GFP_KERNEL);\r\nif (!state)\r\nreturn NULL;\r\n__drm_atomic_helper_plane_duplicate_state(plane, &state->base);\r\nWARN_ON(state->base.plane != plane);\r\nstate->pending = old_state->pending;\r\nreturn &state->base;\r\n}\r\nstatic void mtk_drm_plane_destroy_state(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\n__drm_atomic_helper_plane_destroy_state(state);\r\nkfree(to_mtk_plane_state(state));\r\n}\r\nstatic int mtk_plane_atomic_check(struct drm_plane *plane,\r\nstruct drm_plane_state *state)\r\n{\r\nstruct drm_framebuffer *fb = state->fb;\r\nstruct drm_crtc_state *crtc_state;\r\nstruct drm_rect clip = { 0, };\r\nif (!fb)\r\nreturn 0;\r\nif (!mtk_fb_get_gem_obj(fb)) {\r\nDRM_DEBUG_KMS("buffer is null\n");\r\nreturn -EFAULT;\r\n}\r\nif (!state->crtc)\r\nreturn 0;\r\ncrtc_state = drm_atomic_get_crtc_state(state->state, state->crtc);\r\nif (IS_ERR(crtc_state))\r\nreturn PTR_ERR(crtc_state);\r\nclip.x2 = crtc_state->mode.hdisplay;\r\nclip.y2 = crtc_state->mode.vdisplay;\r\nreturn drm_plane_helper_check_state(state, &clip,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\nDRM_PLANE_HELPER_NO_SCALING,\r\ntrue, true);\r\n}\r\nstatic void mtk_plane_atomic_update(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct mtk_plane_state *state = to_mtk_plane_state(plane->state);\r\nstruct drm_crtc *crtc = plane->state->crtc;\r\nstruct drm_framebuffer *fb = plane->state->fb;\r\nstruct drm_gem_object *gem;\r\nstruct mtk_drm_gem_obj *mtk_gem;\r\nunsigned int pitch, format;\r\ndma_addr_t addr;\r\nif (!crtc || WARN_ON(!fb))\r\nreturn;\r\ngem = mtk_fb_get_gem_obj(fb);\r\nmtk_gem = to_mtk_gem_obj(gem);\r\naddr = mtk_gem->dma_addr;\r\npitch = fb->pitches[0];\r\nformat = fb->format->format;\r\naddr += (plane->state->src.x1 >> 16) * fb->format->cpp[0];\r\naddr += (plane->state->src.y1 >> 16) * pitch;\r\nstate->pending.enable = true;\r\nstate->pending.pitch = pitch;\r\nstate->pending.format = format;\r\nstate->pending.addr = addr;\r\nstate->pending.x = plane->state->dst.x1;\r\nstate->pending.y = plane->state->dst.y1;\r\nstate->pending.width = drm_rect_width(&plane->state->dst);\r\nstate->pending.height = drm_rect_height(&plane->state->dst);\r\nwmb();\r\nstate->pending.dirty = true;\r\n}\r\nstatic void mtk_plane_atomic_disable(struct drm_plane *plane,\r\nstruct drm_plane_state *old_state)\r\n{\r\nstruct mtk_plane_state *state = to_mtk_plane_state(plane->state);\r\nstate->pending.enable = false;\r\nwmb();\r\nstate->pending.dirty = true;\r\n}\r\nint mtk_plane_init(struct drm_device *dev, struct drm_plane *plane,\r\nunsigned long possible_crtcs, enum drm_plane_type type)\r\n{\r\nint err;\r\nerr = drm_universal_plane_init(dev, plane, possible_crtcs,\r\n&mtk_plane_funcs, formats,\r\nARRAY_SIZE(formats), type, NULL);\r\nif (err) {\r\nDRM_ERROR("failed to initialize plane\n");\r\nreturn err;\r\n}\r\ndrm_plane_helper_add(plane, &mtk_plane_helper_funcs);\r\nreturn 0;\r\n}
