static int usnic_ib_dump_vf_hdr(void *obj, char *buf, int buf_sz)\r\n{\r\nstruct usnic_ib_vf *vf = obj;\r\nreturn scnprintf(buf, buf_sz, "PF: %s ", vf->pf->ib_dev.name);\r\n}\r\nstatic void usnic_ib_dump_vf(struct usnic_ib_vf *vf, char *buf, int buf_sz)\r\n{\r\nusnic_vnic_dump(vf->vnic, buf, buf_sz, vf,\r\nusnic_ib_dump_vf_hdr,\r\nusnic_ib_qp_grp_dump_hdr, usnic_ib_qp_grp_dump_rows);\r\n}\r\nvoid usnic_ib_log_vf(struct usnic_ib_vf *vf)\r\n{\r\nchar buf[1000];\r\nusnic_ib_dump_vf(vf, buf, sizeof(buf));\r\nusnic_dbg("%s\n", buf);\r\n}\r\nstatic inline const char *usnic_ib_netdev_event_to_string(unsigned long event)\r\n{\r\nconst char *event2str[] = {"NETDEV_NONE", "NETDEV_UP", "NETDEV_DOWN",\r\n"NETDEV_REBOOT", "NETDEV_CHANGE",\r\n"NETDEV_REGISTER", "NETDEV_UNREGISTER", "NETDEV_CHANGEMTU",\r\n"NETDEV_CHANGEADDR", "NETDEV_GOING_DOWN", "NETDEV_FEAT_CHANGE",\r\n"NETDEV_BONDING_FAILOVER", "NETDEV_PRE_UP",\r\n"NETDEV_PRE_TYPE_CHANGE", "NETDEV_POST_TYPE_CHANGE",\r\n"NETDEV_POST_INT", "NETDEV_UNREGISTER_FINAL", "NETDEV_RELEASE",\r\n"NETDEV_NOTIFY_PEERS", "NETDEV_JOIN"\r\n};\r\nif (event >= ARRAY_SIZE(event2str))\r\nreturn "UNKNOWN_NETDEV_EVENT";\r\nelse\r\nreturn event2str[event];\r\n}\r\nstatic void usnic_ib_qp_grp_modify_active_to_err(struct usnic_ib_dev *us_ibdev)\r\n{\r\nstruct usnic_ib_ucontext *ctx;\r\nstruct usnic_ib_qp_grp *qp_grp;\r\nenum ib_qp_state cur_state;\r\nint status;\r\nBUG_ON(!mutex_is_locked(&us_ibdev->usdev_lock));\r\nlist_for_each_entry(ctx, &us_ibdev->ctx_list, link) {\r\nlist_for_each_entry(qp_grp, &ctx->qp_grp_list, link) {\r\ncur_state = qp_grp->state;\r\nif (cur_state == IB_QPS_INIT ||\r\ncur_state == IB_QPS_RTR ||\r\ncur_state == IB_QPS_RTS) {\r\nstatus = usnic_ib_qp_grp_modify(qp_grp,\r\nIB_QPS_ERR,\r\nNULL);\r\nif (status) {\r\nusnic_err("Failed to transistion qp grp %u from %s to %s\n",\r\nqp_grp->grp_id,\r\nusnic_ib_qp_grp_state_to_string\r\n(cur_state),\r\nusnic_ib_qp_grp_state_to_string\r\n(IB_QPS_ERR));\r\n}\r\n}\r\n}\r\n}\r\n}\r\nstatic void usnic_ib_handle_usdev_event(struct usnic_ib_dev *us_ibdev,\r\nunsigned long event)\r\n{\r\nstruct net_device *netdev;\r\nstruct ib_event ib_event;\r\nmemset(&ib_event, 0, sizeof(ib_event));\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nnetdev = us_ibdev->netdev;\r\nswitch (event) {\r\ncase NETDEV_REBOOT:\r\nusnic_info("PF Reset on %s\n", us_ibdev->ib_dev.name);\r\nusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\r\nib_event.event = IB_EVENT_PORT_ERR;\r\nib_event.device = &us_ibdev->ib_dev;\r\nib_event.element.port_num = 1;\r\nib_dispatch_event(&ib_event);\r\nbreak;\r\ncase NETDEV_UP:\r\ncase NETDEV_DOWN:\r\ncase NETDEV_CHANGE:\r\nif (!us_ibdev->ufdev->link_up &&\r\nnetif_carrier_ok(netdev)) {\r\nusnic_fwd_carrier_up(us_ibdev->ufdev);\r\nusnic_info("Link UP on %s\n", us_ibdev->ib_dev.name);\r\nib_event.event = IB_EVENT_PORT_ACTIVE;\r\nib_event.device = &us_ibdev->ib_dev;\r\nib_event.element.port_num = 1;\r\nib_dispatch_event(&ib_event);\r\n} else if (us_ibdev->ufdev->link_up &&\r\n!netif_carrier_ok(netdev)) {\r\nusnic_fwd_carrier_down(us_ibdev->ufdev);\r\nusnic_info("Link DOWN on %s\n", us_ibdev->ib_dev.name);\r\nusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\r\nib_event.event = IB_EVENT_PORT_ERR;\r\nib_event.device = &us_ibdev->ib_dev;\r\nib_event.element.port_num = 1;\r\nib_dispatch_event(&ib_event);\r\n} else {\r\nusnic_dbg("Ignoring %s on %s\n",\r\nusnic_ib_netdev_event_to_string(event),\r\nus_ibdev->ib_dev.name);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEADDR:\r\nif (!memcmp(us_ibdev->ufdev->mac, netdev->dev_addr,\r\nsizeof(us_ibdev->ufdev->mac))) {\r\nusnic_dbg("Ignoring addr change on %s\n",\r\nus_ibdev->ib_dev.name);\r\n} else {\r\nusnic_info(" %s old mac: %pM new mac: %pM\n",\r\nus_ibdev->ib_dev.name,\r\nus_ibdev->ufdev->mac,\r\nnetdev->dev_addr);\r\nusnic_fwd_set_mac(us_ibdev->ufdev, netdev->dev_addr);\r\nusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\r\nib_event.event = IB_EVENT_GID_CHANGE;\r\nib_event.device = &us_ibdev->ib_dev;\r\nib_event.element.port_num = 1;\r\nib_dispatch_event(&ib_event);\r\n}\r\nbreak;\r\ncase NETDEV_CHANGEMTU:\r\nif (us_ibdev->ufdev->mtu != netdev->mtu) {\r\nusnic_info("MTU Change on %s old: %u new: %u\n",\r\nus_ibdev->ib_dev.name,\r\nus_ibdev->ufdev->mtu, netdev->mtu);\r\nusnic_fwd_set_mtu(us_ibdev->ufdev, netdev->mtu);\r\nusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\r\n} else {\r\nusnic_dbg("Ignoring MTU change on %s\n",\r\nus_ibdev->ib_dev.name);\r\n}\r\nbreak;\r\ndefault:\r\nusnic_dbg("Ignoring event %s on %s",\r\nusnic_ib_netdev_event_to_string(event),\r\nus_ibdev->ib_dev.name);\r\n}\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\n}\r\nstatic int usnic_ib_netdevice_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct usnic_ib_dev *us_ibdev;\r\nstruct net_device *netdev = netdev_notifier_info_to_dev(ptr);\r\nmutex_lock(&usnic_ib_ibdev_list_lock);\r\nlist_for_each_entry(us_ibdev, &usnic_ib_ibdev_list, ib_dev_link) {\r\nif (us_ibdev->netdev == netdev) {\r\nusnic_ib_handle_usdev_event(us_ibdev, event);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&usnic_ib_ibdev_list_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int usnic_ib_handle_inet_event(struct usnic_ib_dev *us_ibdev,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct in_ifaddr *ifa = ptr;\r\nstruct ib_event ib_event;\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nswitch (event) {\r\ncase NETDEV_DOWN:\r\nusnic_info("%s via ip notifiers",\r\nusnic_ib_netdev_event_to_string(event));\r\nusnic_fwd_del_ipaddr(us_ibdev->ufdev);\r\nusnic_ib_qp_grp_modify_active_to_err(us_ibdev);\r\nib_event.event = IB_EVENT_GID_CHANGE;\r\nib_event.device = &us_ibdev->ib_dev;\r\nib_event.element.port_num = 1;\r\nib_dispatch_event(&ib_event);\r\nbreak;\r\ncase NETDEV_UP:\r\nusnic_fwd_add_ipaddr(us_ibdev->ufdev, ifa->ifa_address);\r\nusnic_info("%s via ip notifiers: ip %pI4",\r\nusnic_ib_netdev_event_to_string(event),\r\n&us_ibdev->ufdev->inaddr);\r\nib_event.event = IB_EVENT_GID_CHANGE;\r\nib_event.device = &us_ibdev->ib_dev;\r\nib_event.element.port_num = 1;\r\nib_dispatch_event(&ib_event);\r\nbreak;\r\ndefault:\r\nusnic_info("Ignoring event %s on %s",\r\nusnic_ib_netdev_event_to_string(event),\r\nus_ibdev->ib_dev.name);\r\n}\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int usnic_ib_inetaddr_event(struct notifier_block *notifier,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct usnic_ib_dev *us_ibdev;\r\nstruct in_ifaddr *ifa = ptr;\r\nstruct net_device *netdev = ifa->ifa_dev->dev;\r\nmutex_lock(&usnic_ib_ibdev_list_lock);\r\nlist_for_each_entry(us_ibdev, &usnic_ib_ibdev_list, ib_dev_link) {\r\nif (us_ibdev->netdev == netdev) {\r\nusnic_ib_handle_inet_event(us_ibdev, event, ptr);\r\nbreak;\r\n}\r\n}\r\nmutex_unlock(&usnic_ib_ibdev_list_lock);\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int usnic_port_immutable(struct ib_device *ibdev, u8 port_num,\r\nstruct ib_port_immutable *immutable)\r\n{\r\nstruct ib_port_attr attr;\r\nint err;\r\nimmutable->core_cap_flags = RDMA_CORE_PORT_USNIC;\r\nerr = ib_query_port(ibdev, port_num, &attr);\r\nif (err)\r\nreturn err;\r\nimmutable->pkey_tbl_len = attr.pkey_tbl_len;\r\nimmutable->gid_tbl_len = attr.gid_tbl_len;\r\nreturn 0;\r\n}\r\nstatic void usnic_get_dev_fw_str(struct ib_device *device,\r\nchar *str,\r\nsize_t str_len)\r\n{\r\nstruct usnic_ib_dev *us_ibdev =\r\ncontainer_of(device, struct usnic_ib_dev, ib_dev);\r\nstruct ethtool_drvinfo info;\r\nmutex_lock(&us_ibdev->usdev_lock);\r\nus_ibdev->netdev->ethtool_ops->get_drvinfo(us_ibdev->netdev, &info);\r\nmutex_unlock(&us_ibdev->usdev_lock);\r\nsnprintf(str, str_len, "%s", info.fw_version);\r\n}\r\nstatic void *usnic_ib_device_add(struct pci_dev *dev)\r\n{\r\nstruct usnic_ib_dev *us_ibdev;\r\nunion ib_gid gid;\r\nstruct in_ifaddr *in;\r\nstruct net_device *netdev;\r\nusnic_dbg("\n");\r\nnetdev = pci_get_drvdata(dev);\r\nus_ibdev = (struct usnic_ib_dev *)ib_alloc_device(sizeof(*us_ibdev));\r\nif (!us_ibdev) {\r\nusnic_err("Device %s context alloc failed\n",\r\nnetdev_name(pci_get_drvdata(dev)));\r\nreturn ERR_PTR(-EFAULT);\r\n}\r\nus_ibdev->ufdev = usnic_fwd_dev_alloc(dev);\r\nif (!us_ibdev->ufdev) {\r\nusnic_err("Failed to alloc ufdev for %s\n", pci_name(dev));\r\ngoto err_dealloc;\r\n}\r\nmutex_init(&us_ibdev->usdev_lock);\r\nINIT_LIST_HEAD(&us_ibdev->vf_dev_list);\r\nINIT_LIST_HEAD(&us_ibdev->ctx_list);\r\nus_ibdev->pdev = dev;\r\nus_ibdev->netdev = pci_get_drvdata(dev);\r\nus_ibdev->ib_dev.owner = THIS_MODULE;\r\nus_ibdev->ib_dev.node_type = RDMA_NODE_USNIC_UDP;\r\nus_ibdev->ib_dev.phys_port_cnt = USNIC_IB_PORT_CNT;\r\nus_ibdev->ib_dev.num_comp_vectors = USNIC_IB_NUM_COMP_VECTORS;\r\nus_ibdev->ib_dev.dev.parent = &dev->dev;\r\nus_ibdev->ib_dev.uverbs_abi_ver = USNIC_UVERBS_ABI_VERSION;\r\nstrlcpy(us_ibdev->ib_dev.name, "usnic_%d", IB_DEVICE_NAME_MAX);\r\nus_ibdev->ib_dev.uverbs_cmd_mask =\r\n(1ull << IB_USER_VERBS_CMD_GET_CONTEXT) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_DEVICE) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_PORT) |\r\n(1ull << IB_USER_VERBS_CMD_ALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_DEALLOC_PD) |\r\n(1ull << IB_USER_VERBS_CMD_REG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_DEREG_MR) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_CQ) |\r\n(1ull << IB_USER_VERBS_CMD_CREATE_QP) |\r\n(1ull << IB_USER_VERBS_CMD_MODIFY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_QUERY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_DESTROY_QP) |\r\n(1ull << IB_USER_VERBS_CMD_ATTACH_MCAST) |\r\n(1ull << IB_USER_VERBS_CMD_DETACH_MCAST) |\r\n(1ull << IB_USER_VERBS_CMD_OPEN_QP);\r\nus_ibdev->ib_dev.query_device = usnic_ib_query_device;\r\nus_ibdev->ib_dev.query_port = usnic_ib_query_port;\r\nus_ibdev->ib_dev.query_pkey = usnic_ib_query_pkey;\r\nus_ibdev->ib_dev.query_gid = usnic_ib_query_gid;\r\nus_ibdev->ib_dev.get_link_layer = usnic_ib_port_link_layer;\r\nus_ibdev->ib_dev.alloc_pd = usnic_ib_alloc_pd;\r\nus_ibdev->ib_dev.dealloc_pd = usnic_ib_dealloc_pd;\r\nus_ibdev->ib_dev.create_qp = usnic_ib_create_qp;\r\nus_ibdev->ib_dev.modify_qp = usnic_ib_modify_qp;\r\nus_ibdev->ib_dev.query_qp = usnic_ib_query_qp;\r\nus_ibdev->ib_dev.destroy_qp = usnic_ib_destroy_qp;\r\nus_ibdev->ib_dev.create_cq = usnic_ib_create_cq;\r\nus_ibdev->ib_dev.destroy_cq = usnic_ib_destroy_cq;\r\nus_ibdev->ib_dev.reg_user_mr = usnic_ib_reg_mr;\r\nus_ibdev->ib_dev.dereg_mr = usnic_ib_dereg_mr;\r\nus_ibdev->ib_dev.alloc_ucontext = usnic_ib_alloc_ucontext;\r\nus_ibdev->ib_dev.dealloc_ucontext = usnic_ib_dealloc_ucontext;\r\nus_ibdev->ib_dev.mmap = usnic_ib_mmap;\r\nus_ibdev->ib_dev.create_ah = usnic_ib_create_ah;\r\nus_ibdev->ib_dev.destroy_ah = usnic_ib_destroy_ah;\r\nus_ibdev->ib_dev.post_send = usnic_ib_post_send;\r\nus_ibdev->ib_dev.post_recv = usnic_ib_post_recv;\r\nus_ibdev->ib_dev.poll_cq = usnic_ib_poll_cq;\r\nus_ibdev->ib_dev.req_notify_cq = usnic_ib_req_notify_cq;\r\nus_ibdev->ib_dev.get_dma_mr = usnic_ib_get_dma_mr;\r\nus_ibdev->ib_dev.get_port_immutable = usnic_port_immutable;\r\nus_ibdev->ib_dev.get_dev_fw_str = usnic_get_dev_fw_str;\r\nif (ib_register_device(&us_ibdev->ib_dev, NULL))\r\ngoto err_fwd_dealloc;\r\nusnic_fwd_set_mtu(us_ibdev->ufdev, us_ibdev->netdev->mtu);\r\nusnic_fwd_set_mac(us_ibdev->ufdev, us_ibdev->netdev->dev_addr);\r\nif (netif_carrier_ok(us_ibdev->netdev))\r\nusnic_fwd_carrier_up(us_ibdev->ufdev);\r\nin = ((struct in_device *)(netdev->ip_ptr))->ifa_list;\r\nif (in != NULL)\r\nusnic_fwd_add_ipaddr(us_ibdev->ufdev, in->ifa_address);\r\nusnic_mac_ip_to_gid(us_ibdev->netdev->perm_addr,\r\nus_ibdev->ufdev->inaddr, &gid.raw[0]);\r\nmemcpy(&us_ibdev->ib_dev.node_guid, &gid.global.interface_id,\r\nsizeof(gid.global.interface_id));\r\nkref_init(&us_ibdev->vf_cnt);\r\nusnic_info("Added ibdev: %s netdev: %s with mac %pM Link: %u MTU: %u\n",\r\nus_ibdev->ib_dev.name, netdev_name(us_ibdev->netdev),\r\nus_ibdev->ufdev->mac, us_ibdev->ufdev->link_up,\r\nus_ibdev->ufdev->mtu);\r\nreturn us_ibdev;\r\nerr_fwd_dealloc:\r\nusnic_fwd_dev_free(us_ibdev->ufdev);\r\nerr_dealloc:\r\nusnic_err("failed -- deallocing device\n");\r\nib_dealloc_device(&us_ibdev->ib_dev);\r\nreturn NULL;\r\n}\r\nstatic void usnic_ib_device_remove(struct usnic_ib_dev *us_ibdev)\r\n{\r\nusnic_info("Unregistering %s\n", us_ibdev->ib_dev.name);\r\nusnic_ib_sysfs_unregister_usdev(us_ibdev);\r\nusnic_fwd_dev_free(us_ibdev->ufdev);\r\nib_unregister_device(&us_ibdev->ib_dev);\r\nib_dealloc_device(&us_ibdev->ib_dev);\r\n}\r\nstatic void usnic_ib_undiscover_pf(struct kref *kref)\r\n{\r\nstruct usnic_ib_dev *us_ibdev, *tmp;\r\nstruct pci_dev *dev;\r\nbool found = false;\r\ndev = container_of(kref, struct usnic_ib_dev, vf_cnt)->pdev;\r\nmutex_lock(&usnic_ib_ibdev_list_lock);\r\nlist_for_each_entry_safe(us_ibdev, tmp,\r\n&usnic_ib_ibdev_list, ib_dev_link) {\r\nif (us_ibdev->pdev == dev) {\r\nlist_del(&us_ibdev->ib_dev_link);\r\nusnic_ib_device_remove(us_ibdev);\r\nfound = true;\r\nbreak;\r\n}\r\n}\r\nWARN(!found, "Failed to remove PF %s\n", pci_name(dev));\r\nmutex_unlock(&usnic_ib_ibdev_list_lock);\r\n}\r\nstatic struct usnic_ib_dev *usnic_ib_discover_pf(struct usnic_vnic *vnic)\r\n{\r\nstruct usnic_ib_dev *us_ibdev;\r\nstruct pci_dev *parent_pci, *vf_pci;\r\nint err;\r\nvf_pci = usnic_vnic_get_pdev(vnic);\r\nparent_pci = pci_physfn(vf_pci);\r\nBUG_ON(!parent_pci);\r\nmutex_lock(&usnic_ib_ibdev_list_lock);\r\nlist_for_each_entry(us_ibdev, &usnic_ib_ibdev_list, ib_dev_link) {\r\nif (us_ibdev->pdev == parent_pci) {\r\nkref_get(&us_ibdev->vf_cnt);\r\ngoto out;\r\n}\r\n}\r\nus_ibdev = usnic_ib_device_add(parent_pci);\r\nif (IS_ERR_OR_NULL(us_ibdev)) {\r\nus_ibdev = us_ibdev ? us_ibdev : ERR_PTR(-EFAULT);\r\ngoto out;\r\n}\r\nerr = usnic_ib_sysfs_register_usdev(us_ibdev);\r\nif (err) {\r\nusnic_ib_device_remove(us_ibdev);\r\nus_ibdev = ERR_PTR(err);\r\ngoto out;\r\n}\r\nlist_add(&us_ibdev->ib_dev_link, &usnic_ib_ibdev_list);\r\nout:\r\nmutex_unlock(&usnic_ib_ibdev_list_lock);\r\nreturn us_ibdev;\r\n}\r\nstatic int usnic_ib_pci_probe(struct pci_dev *pdev,\r\nconst struct pci_device_id *id)\r\n{\r\nint err;\r\nstruct usnic_ib_dev *pf;\r\nstruct usnic_ib_vf *vf;\r\nenum usnic_vnic_res_type res_type;\r\nvf = kzalloc(sizeof(*vf), GFP_KERNEL);\r\nif (!vf)\r\nreturn -ENOMEM;\r\nerr = pci_enable_device(pdev);\r\nif (err) {\r\nusnic_err("Failed to enable %s with err %d\n",\r\npci_name(pdev), err);\r\ngoto out_clean_vf;\r\n}\r\nerr = pci_request_regions(pdev, DRV_NAME);\r\nif (err) {\r\nusnic_err("Failed to request region for %s with err %d\n",\r\npci_name(pdev), err);\r\ngoto out_disable_device;\r\n}\r\npci_set_master(pdev);\r\npci_set_drvdata(pdev, vf);\r\nvf->vnic = usnic_vnic_alloc(pdev);\r\nif (IS_ERR_OR_NULL(vf->vnic)) {\r\nerr = vf->vnic ? PTR_ERR(vf->vnic) : -ENOMEM;\r\nusnic_err("Failed to alloc vnic for %s with err %d\n",\r\npci_name(pdev), err);\r\ngoto out_release_regions;\r\n}\r\npf = usnic_ib_discover_pf(vf->vnic);\r\nif (IS_ERR_OR_NULL(pf)) {\r\nusnic_err("Failed to discover pf of vnic %s with err%ld\n",\r\npci_name(pdev), PTR_ERR(pf));\r\nerr = pf ? PTR_ERR(pf) : -EFAULT;\r\ngoto out_clean_vnic;\r\n}\r\nvf->pf = pf;\r\nspin_lock_init(&vf->lock);\r\nmutex_lock(&pf->usdev_lock);\r\nlist_add_tail(&vf->link, &pf->vf_dev_list);\r\nfor (res_type = USNIC_VNIC_RES_TYPE_EOL+1;\r\nres_type < USNIC_VNIC_RES_TYPE_MAX;\r\nres_type++) {\r\npf->vf_res_cnt[res_type] = usnic_vnic_res_cnt(vf->vnic,\r\nres_type);\r\n}\r\nmutex_unlock(&pf->usdev_lock);\r\nusnic_info("Registering usnic VF %s into PF %s\n", pci_name(pdev),\r\npf->ib_dev.name);\r\nusnic_ib_log_vf(vf);\r\nreturn 0;\r\nout_clean_vnic:\r\nusnic_vnic_free(vf->vnic);\r\nout_release_regions:\r\npci_set_drvdata(pdev, NULL);\r\npci_clear_master(pdev);\r\npci_release_regions(pdev);\r\nout_disable_device:\r\npci_disable_device(pdev);\r\nout_clean_vf:\r\nkfree(vf);\r\nreturn err;\r\n}\r\nstatic void usnic_ib_pci_remove(struct pci_dev *pdev)\r\n{\r\nstruct usnic_ib_vf *vf = pci_get_drvdata(pdev);\r\nstruct usnic_ib_dev *pf = vf->pf;\r\nmutex_lock(&pf->usdev_lock);\r\nlist_del(&vf->link);\r\nmutex_unlock(&pf->usdev_lock);\r\nkref_put(&pf->vf_cnt, usnic_ib_undiscover_pf);\r\nusnic_vnic_free(vf->vnic);\r\npci_set_drvdata(pdev, NULL);\r\npci_clear_master(pdev);\r\npci_release_regions(pdev);\r\npci_disable_device(pdev);\r\nkfree(vf);\r\nusnic_info("Removed VF %s\n", pci_name(pdev));\r\n}\r\nstatic int __init usnic_ib_init(void)\r\n{\r\nint err;\r\nprintk_once(KERN_INFO "%s", usnic_version);\r\nerr = usnic_uiom_init(DRV_NAME);\r\nif (err) {\r\nusnic_err("Unable to initalize umem with err %d\n", err);\r\nreturn err;\r\n}\r\nerr = pci_register_driver(&usnic_ib_pci_driver);\r\nif (err) {\r\nusnic_err("Unable to register with PCI\n");\r\ngoto out_umem_fini;\r\n}\r\nerr = register_netdevice_notifier(&usnic_ib_netdevice_notifier);\r\nif (err) {\r\nusnic_err("Failed to register netdev notifier\n");\r\ngoto out_pci_unreg;\r\n}\r\nerr = register_inetaddr_notifier(&usnic_ib_inetaddr_notifier);\r\nif (err) {\r\nusnic_err("Failed to register inet addr notifier\n");\r\ngoto out_unreg_netdev_notifier;\r\n}\r\nerr = usnic_transport_init();\r\nif (err) {\r\nusnic_err("Failed to initialize transport\n");\r\ngoto out_unreg_inetaddr_notifier;\r\n}\r\nusnic_debugfs_init();\r\nreturn 0;\r\nout_unreg_inetaddr_notifier:\r\nunregister_inetaddr_notifier(&usnic_ib_inetaddr_notifier);\r\nout_unreg_netdev_notifier:\r\nunregister_netdevice_notifier(&usnic_ib_netdevice_notifier);\r\nout_pci_unreg:\r\npci_unregister_driver(&usnic_ib_pci_driver);\r\nout_umem_fini:\r\nusnic_uiom_fini();\r\nreturn err;\r\n}\r\nstatic void __exit usnic_ib_destroy(void)\r\n{\r\nusnic_dbg("\n");\r\nusnic_debugfs_exit();\r\nusnic_transport_fini();\r\nunregister_inetaddr_notifier(&usnic_ib_inetaddr_notifier);\r\nunregister_netdevice_notifier(&usnic_ib_netdevice_notifier);\r\npci_unregister_driver(&usnic_ib_pci_driver);\r\nusnic_uiom_fini();\r\n}
