static void cpt_send_msg_to_vf(struct cpt_device *cpt, int vf,\r\nstruct cpt_mbox *mbx)\r\n{\r\ncpt_write_csr64(cpt->reg_base, CPTX_PF_VFX_MBOXX(0, vf, 1),\r\nmbx->data);\r\ncpt_write_csr64(cpt->reg_base, CPTX_PF_VFX_MBOXX(0, vf, 0), mbx->msg);\r\n}\r\nstatic void cpt_mbox_send_ack(struct cpt_device *cpt, int vf,\r\nstruct cpt_mbox *mbx)\r\n{\r\nmbx->data = 0ull;\r\nmbx->msg = CPT_MBOX_MSG_TYPE_ACK;\r\ncpt_send_msg_to_vf(cpt, vf, mbx);\r\n}\r\nstatic void cpt_clear_mbox_intr(struct cpt_device *cpt, u32 vf)\r\n{\r\ncpt_write_csr64(cpt->reg_base, CPTX_PF_MBOX_INTX(0, 0), (1 << vf));\r\n}\r\nstatic void cpt_cfg_qlen_for_vf(struct cpt_device *cpt, int vf, u32 size)\r\n{\r\nunion cptx_pf_qx_ctl pf_qx_ctl;\r\npf_qx_ctl.u = cpt_read_csr64(cpt->reg_base, CPTX_PF_QX_CTL(0, vf));\r\npf_qx_ctl.s.size = size;\r\npf_qx_ctl.s.cont_err = true;\r\ncpt_write_csr64(cpt->reg_base, CPTX_PF_QX_CTL(0, vf), pf_qx_ctl.u);\r\n}\r\nstatic void cpt_cfg_vq_priority(struct cpt_device *cpt, int vf, u32 pri)\r\n{\r\nunion cptx_pf_qx_ctl pf_qx_ctl;\r\npf_qx_ctl.u = cpt_read_csr64(cpt->reg_base, CPTX_PF_QX_CTL(0, vf));\r\npf_qx_ctl.s.pri = pri;\r\ncpt_write_csr64(cpt->reg_base, CPTX_PF_QX_CTL(0, vf), pf_qx_ctl.u);\r\n}\r\nstatic int cpt_bind_vq_to_grp(struct cpt_device *cpt, u8 q, u8 grp)\r\n{\r\nstruct microcode *mcode = cpt->mcode;\r\nunion cptx_pf_qx_ctl pf_qx_ctl;\r\nstruct device *dev = &cpt->pdev->dev;\r\nif (q >= CPT_MAX_VF_NUM) {\r\ndev_err(dev, "Queues are more than cores in the group");\r\nreturn -EINVAL;\r\n}\r\nif (grp >= CPT_MAX_CORE_GROUPS) {\r\ndev_err(dev, "Request group is more than possible groups");\r\nreturn -EINVAL;\r\n}\r\nif (grp >= cpt->next_mc_idx) {\r\ndev_err(dev, "Request group is higher than available functional groups");\r\nreturn -EINVAL;\r\n}\r\npf_qx_ctl.u = cpt_read_csr64(cpt->reg_base, CPTX_PF_QX_CTL(0, q));\r\npf_qx_ctl.s.grp = mcode[grp].group;\r\ncpt_write_csr64(cpt->reg_base, CPTX_PF_QX_CTL(0, q), pf_qx_ctl.u);\r\ndev_dbg(dev, "VF %d TYPE %s", q, (mcode[grp].is_ae ? "AE" : "SE"));\r\nreturn mcode[grp].is_ae ? AE_TYPES : SE_TYPES;\r\n}\r\nstatic void cpt_handle_mbox_intr(struct cpt_device *cpt, int vf)\r\n{\r\nstruct cpt_vf_info *vfx = &cpt->vfinfo[vf];\r\nstruct cpt_mbox mbx = {};\r\nint vftype;\r\nstruct device *dev = &cpt->pdev->dev;\r\nmbx.msg = cpt_read_csr64(cpt->reg_base, CPTX_PF_VFX_MBOXX(0, vf, 0));\r\nmbx.data = cpt_read_csr64(cpt->reg_base, CPTX_PF_VFX_MBOXX(0, vf, 1));\r\ndev_dbg(dev, "%s: Mailbox msg 0x%llx from VF%d", __func__, mbx.msg, vf);\r\nswitch (mbx.msg) {\r\ncase CPT_MSG_VF_UP:\r\nvfx->state = VF_STATE_UP;\r\ntry_module_get(THIS_MODULE);\r\ncpt_mbox_send_ack(cpt, vf, &mbx);\r\nbreak;\r\ncase CPT_MSG_READY:\r\nmbx.msg = CPT_MSG_READY;\r\nmbx.data = vf;\r\ncpt_send_msg_to_vf(cpt, vf, &mbx);\r\nbreak;\r\ncase CPT_MSG_VF_DOWN:\r\nvfx->state = VF_STATE_DOWN;\r\nmodule_put(THIS_MODULE);\r\ncpt_mbox_send_ack(cpt, vf, &mbx);\r\nbreak;\r\ncase CPT_MSG_QLEN:\r\nvfx->qlen = mbx.data;\r\ncpt_cfg_qlen_for_vf(cpt, vf, vfx->qlen);\r\ncpt_mbox_send_ack(cpt, vf, &mbx);\r\nbreak;\r\ncase CPT_MSG_QBIND_GRP:\r\nvftype = cpt_bind_vq_to_grp(cpt, vf, (u8)mbx.data);\r\nif ((vftype != AE_TYPES) && (vftype != SE_TYPES))\r\ndev_err(dev, "Queue %d binding to group %llu failed",\r\nvf, mbx.data);\r\nelse {\r\ndev_dbg(dev, "Queue %d binding to group %llu successful",\r\nvf, mbx.data);\r\nmbx.msg = CPT_MSG_QBIND_GRP;\r\nmbx.data = vftype;\r\ncpt_send_msg_to_vf(cpt, vf, &mbx);\r\n}\r\nbreak;\r\ncase CPT_MSG_VQ_PRIORITY:\r\nvfx->priority = mbx.data;\r\ncpt_cfg_vq_priority(cpt, vf, vfx->priority);\r\ncpt_mbox_send_ack(cpt, vf, &mbx);\r\nbreak;\r\ndefault:\r\ndev_err(&cpt->pdev->dev, "Invalid msg from VF%d, msg 0x%llx\n",\r\nvf, mbx.msg);\r\nbreak;\r\n}\r\n}\r\nvoid cpt_mbox_intr_handler (struct cpt_device *cpt, int mbx)\r\n{\r\nu64 intr;\r\nu8 vf;\r\nintr = cpt_read_csr64(cpt->reg_base, CPTX_PF_MBOX_INTX(0, 0));\r\ndev_dbg(&cpt->pdev->dev, "PF interrupt Mbox%d 0x%llx\n", mbx, intr);\r\nfor (vf = 0; vf < CPT_MAX_VF_NUM; vf++) {\r\nif (intr & (1ULL << vf)) {\r\ndev_dbg(&cpt->pdev->dev, "Intr from VF %d\n", vf);\r\ncpt_handle_mbox_intr(cpt, vf);\r\ncpt_clear_mbox_intr(cpt, vf);\r\n}\r\n}\r\n}
