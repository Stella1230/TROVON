static int check_short_pattern(uint8_t *buf, int len, int paglen, struct nand_bbt_descr *td)\r\n{\r\nint i;\r\nuint8_t *p = buf;\r\nfor (i = 0; i < td->len; i++) {\r\nif (p[i] != td->pattern[i])\r\nreturn -1;\r\n}\r\nreturn 0;\r\n}\r\nstatic int create_bbt(struct mtd_info *mtd, uint8_t *buf, struct nand_bbt_descr *bd, int chip)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct bbm_info *bbm = this->bbm;\r\nint i, j, numblocks, len, scanlen;\r\nint startblock;\r\nloff_t from;\r\nsize_t readlen, ooblen;\r\nstruct mtd_oob_ops ops;\r\nint rgn;\r\nprintk(KERN_INFO "Scanning device for bad blocks\n");\r\nlen = 2;\r\nscanlen = ooblen = 0;\r\nreadlen = bd->len;\r\nnumblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);\r\nstartblock = 0;\r\nfrom = 0;\r\nops.mode = MTD_OPS_PLACE_OOB;\r\nops.ooblen = readlen;\r\nops.oobbuf = buf;\r\nops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;\r\nfor (i = startblock; i < numblocks; ) {\r\nint ret;\r\nfor (j = 0; j < len; j++) {\r\nret = onenand_bbt_read_oob(mtd,\r\nfrom + j * this->writesize + bd->offs, &ops);\r\nif (ret == ONENAND_BBT_READ_FATAL_ERROR)\r\nreturn -EIO;\r\nif (ret || check_short_pattern(&buf[j * scanlen],\r\nscanlen, this->writesize, bd)) {\r\nbbm->bbt[i >> 3] |= 0x03 << (i & 0x6);\r\nprintk(KERN_INFO "OneNAND eraseblock %d is an "\r\n"initial bad block\n", i >> 1);\r\nmtd->ecc_stats.badblocks++;\r\nbreak;\r\n}\r\n}\r\ni += 2;\r\nif (FLEXONENAND(this)) {\r\nrgn = flexonenand_region(mtd, from);\r\nfrom += mtd->eraseregions[rgn].erasesize;\r\n} else\r\nfrom += (1 << bbm->bbt_erase_shift);\r\n}\r\nreturn 0;\r\n}\r\nstatic inline int onenand_memory_bbt (struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nreturn create_bbt(mtd, this->page_buf, bd, -1);\r\n}\r\nstatic int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct bbm_info *bbm = this->bbm;\r\nint block;\r\nuint8_t res;\r\nblock = (int) (onenand_block(this, offs) << 1);\r\nres = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;\r\npr_debug("onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",\r\n(unsigned int) offs, block >> 1, res);\r\nswitch ((int) res) {\r\ncase 0x00: return 0;\r\ncase 0x01: return 1;\r\ncase 0x02: return allowbbt ? 0 : 1;\r\n}\r\nreturn 1;\r\n}\r\nstatic int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct bbm_info *bbm = this->bbm;\r\nint len, ret = 0;\r\nlen = this->chipsize >> (this->erase_shift + 2);\r\nbbm->bbt = kzalloc(len, GFP_KERNEL);\r\nif (!bbm->bbt)\r\nreturn -ENOMEM;\r\nbbm->badblockpos = ONENAND_BADBLOCK_POS;\r\nbbm->bbt_erase_shift = this->erase_shift;\r\nif (!bbm->isbad_bbt)\r\nbbm->isbad_bbt = onenand_isbad_bbt;\r\nif ((ret = onenand_memory_bbt(mtd, bd))) {\r\nprintk(KERN_ERR "onenand_scan_bbt: Can't scan flash and build the RAM-based BBT\n");\r\nkfree(bbm->bbt);\r\nbbm->bbt = NULL;\r\n}\r\nreturn ret;\r\n}\r\nint onenand_default_bbt(struct mtd_info *mtd)\r\n{\r\nstruct onenand_chip *this = mtd->priv;\r\nstruct bbm_info *bbm;\r\nthis->bbm = kzalloc(sizeof(struct bbm_info), GFP_KERNEL);\r\nif (!this->bbm)\r\nreturn -ENOMEM;\r\nbbm = this->bbm;\r\nif (!bbm->badblock_pattern)\r\nbbm->badblock_pattern = &largepage_memorybased;\r\nreturn onenand_scan_bbt(mtd, bbm->badblock_pattern);\r\n}
