static void smc_llc_tx_handler(struct smc_wr_tx_pend_priv *pend,\r\nstruct smc_link *link,\r\nenum ib_wc_status wc_status)\r\n{\r\n}\r\nstatic int smc_llc_add_pending_send(struct smc_link *link,\r\nstruct smc_wr_buf **wr_buf,\r\nstruct smc_wr_tx_pend_priv **pend)\r\n{\r\nint rc;\r\nrc = smc_wr_tx_get_free_slot(link, smc_llc_tx_handler, wr_buf, pend);\r\nif (rc < 0)\r\nreturn rc;\r\nBUILD_BUG_ON_MSG(\r\nsizeof(union smc_llc_msg) > SMC_WR_BUF_SIZE,\r\n"must increase SMC_WR_BUF_SIZE to at least sizeof(struct smc_llc_msg)");\r\nBUILD_BUG_ON_MSG(\r\nsizeof(union smc_llc_msg) != SMC_WR_TX_SIZE,\r\n"must adapt SMC_WR_TX_SIZE to sizeof(struct smc_llc_msg); if not all smc_wr upper layer protocols use the same message size any more, must start to set link->wr_tx_sges[i].length on each individual smc_wr_tx_send()");\r\nBUILD_BUG_ON_MSG(\r\nsizeof(struct smc_llc_tx_pend) > SMC_WR_TX_PEND_PRIV_SIZE,\r\n"must increase SMC_WR_TX_PEND_PRIV_SIZE to at least sizeof(struct smc_llc_tx_pend)");\r\nreturn 0;\r\n}\r\nint smc_llc_send_confirm_link(struct smc_link *link, u8 mac[],\r\nunion ib_gid *gid,\r\nenum smc_llc_reqresp reqresp)\r\n{\r\nstruct smc_link_group *lgr = container_of(link, struct smc_link_group,\r\nlnk[SMC_SINGLE_LINK]);\r\nstruct smc_llc_msg_confirm_link *confllc;\r\nstruct smc_wr_tx_pend_priv *pend;\r\nstruct smc_wr_buf *wr_buf;\r\nint rc;\r\nrc = smc_llc_add_pending_send(link, &wr_buf, &pend);\r\nif (rc)\r\nreturn rc;\r\nconfllc = (struct smc_llc_msg_confirm_link *)wr_buf;\r\nmemset(confllc, 0, sizeof(*confllc));\r\nconfllc->hd.common.type = SMC_LLC_CONFIRM_LINK;\r\nconfllc->hd.length = sizeof(struct smc_llc_msg_confirm_link);\r\nif (reqresp == SMC_LLC_RESP)\r\nconfllc->hd.flags |= SMC_LLC_FLAG_RESP;\r\nmemcpy(confllc->sender_mac, mac, ETH_ALEN);\r\nmemcpy(confllc->sender_gid, gid, SMC_GID_SIZE);\r\nhton24(confllc->sender_qp_num, link->roce_qp->qp_num);\r\nmemcpy(confllc->link_uid, lgr->id, SMC_LGR_ID_SIZE);\r\nconfllc->max_links = SMC_LINKS_PER_LGR_MAX;\r\nrc = smc_wr_tx_send(link, pend);\r\nreturn rc;\r\n}\r\nstatic void smc_llc_rx_confirm_link(struct smc_link *link,\r\nstruct smc_llc_msg_confirm_link *llc)\r\n{\r\nstruct smc_link_group *lgr;\r\nlgr = container_of(link, struct smc_link_group, lnk[SMC_SINGLE_LINK]);\r\nif (llc->hd.flags & SMC_LLC_FLAG_RESP) {\r\nif (lgr->role == SMC_SERV)\r\ncomplete(&link->llc_confirm_resp);\r\n} else {\r\nif (lgr->role == SMC_CLNT) {\r\nlink->link_id = llc->link_num;\r\ncomplete(&link->llc_confirm);\r\n}\r\n}\r\n}\r\nstatic void smc_llc_rx_handler(struct ib_wc *wc, void *buf)\r\n{\r\nstruct smc_link *link = (struct smc_link *)wc->qp->qp_context;\r\nunion smc_llc_msg *llc = buf;\r\nif (wc->byte_len < sizeof(*llc))\r\nreturn;\r\nif (llc->raw.hdr.length != sizeof(*llc))\r\nreturn;\r\nif (llc->raw.hdr.common.type == SMC_LLC_CONFIRM_LINK)\r\nsmc_llc_rx_confirm_link(link, &llc->confirm_link);\r\n}\r\nint __init smc_llc_init(void)\r\n{\r\nstruct smc_wr_rx_handler *handler;\r\nint rc = 0;\r\nfor (handler = smc_llc_rx_handlers; handler->handler; handler++) {\r\nINIT_HLIST_NODE(&handler->list);\r\nrc = smc_wr_rx_register_handler(handler);\r\nif (rc)\r\nbreak;\r\n}\r\nreturn rc;\r\n}
