static int opt3001_find_scale(const struct opt3001 *opt, int val,\r\nint val2, u8 *exponent)\r\n{\r\nint i;\r\nfor (i = 0; i < ARRAY_SIZE(opt3001_scales); i++) {\r\nconst struct opt3001_scale *scale = &opt3001_scales[i];\r\nif ((val * 1000 + val2 / 1000) <=\r\n(scale->val * 1000 + scale->val2 / 1000)) {\r\n*exponent = i;\r\nreturn 0;\r\n}\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic void opt3001_to_iio_ret(struct opt3001 *opt, u8 exponent,\r\nu16 mantissa, int *val, int *val2)\r\n{\r\nint lux;\r\nlux = 10 * (mantissa << exponent);\r\n*val = lux / 1000;\r\n*val2 = (lux - (*val * 1000)) * 1000;\r\n}\r\nstatic void opt3001_set_mode(struct opt3001 *opt, u16 *reg, u16 mode)\r\n{\r\n*reg &= ~OPT3001_CONFIGURATION_M_MASK;\r\n*reg |= mode;\r\nopt->mode = mode;\r\n}\r\nstatic int opt3001_get_lux(struct opt3001 *opt, int *val, int *val2)\r\n{\r\nint ret;\r\nu16 mantissa;\r\nu16 reg;\r\nu8 exponent;\r\nu16 value;\r\nlong timeout;\r\nif (opt->use_irq) {\r\nret = i2c_smbus_write_word_swapped(opt->client,\r\nOPT3001_LOW_LIMIT,\r\nOPT3001_LOW_LIMIT_EOC_ENABLE);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n",\r\nOPT3001_LOW_LIMIT);\r\nreturn ret;\r\n}\r\nopt->ok_to_ignore_lock = true;\r\n}\r\nopt->result_ready = false;\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\ngoto err;\r\n}\r\nreg = ret;\r\nopt3001_set_mode(opt, &reg, OPT3001_CONFIGURATION_M_SINGLE);\r\nret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\r\nreg);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n",\r\nOPT3001_CONFIGURATION);\r\ngoto err;\r\n}\r\nif (opt->use_irq) {\r\nret = wait_event_timeout(opt->result_ready_queue,\r\nopt->result_ready,\r\nmsecs_to_jiffies(OPT3001_RESULT_READY_LONG));\r\n} else {\r\ntimeout = (opt->int_time == OPT3001_INT_TIME_SHORT) ?\r\nOPT3001_RESULT_READY_SHORT : OPT3001_RESULT_READY_LONG;\r\nmsleep(timeout);\r\nret = i2c_smbus_read_word_swapped(opt->client,\r\nOPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\ngoto err;\r\n}\r\nif (!(ret & OPT3001_CONFIGURATION_CRF)) {\r\nret = -ETIMEDOUT;\r\ngoto err;\r\n}\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_RESULT);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_RESULT);\r\ngoto err;\r\n}\r\nopt->result = ret;\r\nopt->result_ready = true;\r\n}\r\nerr:\r\nif (opt->use_irq)\r\nopt->ok_to_ignore_lock = false;\r\nif (ret == 0)\r\nreturn -ETIMEDOUT;\r\nelse if (ret < 0)\r\nreturn ret;\r\nif (opt->use_irq) {\r\nvalue = (opt->low_thresh_exp << 12) | opt->low_thresh_mantissa;\r\nret = i2c_smbus_write_word_swapped(opt->client,\r\nOPT3001_LOW_LIMIT,\r\nvalue);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n",\r\nOPT3001_LOW_LIMIT);\r\nreturn ret;\r\n}\r\n}\r\nexponent = OPT3001_REG_EXPONENT(opt->result);\r\nmantissa = OPT3001_REG_MANTISSA(opt->result);\r\nopt3001_to_iio_ret(opt, exponent, mantissa, val, val2);\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int opt3001_get_int_time(struct opt3001 *opt, int *val, int *val2)\r\n{\r\n*val = 0;\r\n*val2 = opt->int_time;\r\nreturn IIO_VAL_INT_PLUS_MICRO;\r\n}\r\nstatic int opt3001_set_int_time(struct opt3001 *opt, int time)\r\n{\r\nint ret;\r\nu16 reg;\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\nreturn ret;\r\n}\r\nreg = ret;\r\nswitch (time) {\r\ncase OPT3001_INT_TIME_SHORT:\r\nreg &= ~OPT3001_CONFIGURATION_CT;\r\nopt->int_time = OPT3001_INT_TIME_SHORT;\r\nbreak;\r\ncase OPT3001_INT_TIME_LONG:\r\nreg |= OPT3001_CONFIGURATION_CT;\r\nopt->int_time = OPT3001_INT_TIME_LONG;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\r\nreg);\r\n}\r\nstatic int opt3001_read_raw(struct iio_dev *iio,\r\nstruct iio_chan_spec const *chan, int *val, int *val2,\r\nlong mask)\r\n{\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret;\r\nif (opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS)\r\nreturn -EBUSY;\r\nif (chan->type != IIO_LIGHT)\r\nreturn -EINVAL;\r\nmutex_lock(&opt->lock);\r\nswitch (mask) {\r\ncase IIO_CHAN_INFO_PROCESSED:\r\nret = opt3001_get_lux(opt, val, val2);\r\nbreak;\r\ncase IIO_CHAN_INFO_INT_TIME:\r\nret = opt3001_get_int_time(opt, val, val2);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&opt->lock);\r\nreturn ret;\r\n}\r\nstatic int opt3001_write_raw(struct iio_dev *iio,\r\nstruct iio_chan_spec const *chan, int val, int val2,\r\nlong mask)\r\n{\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret;\r\nif (opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS)\r\nreturn -EBUSY;\r\nif (chan->type != IIO_LIGHT)\r\nreturn -EINVAL;\r\nif (mask != IIO_CHAN_INFO_INT_TIME)\r\nreturn -EINVAL;\r\nif (val != 0)\r\nreturn -EINVAL;\r\nmutex_lock(&opt->lock);\r\nret = opt3001_set_int_time(opt, val2);\r\nmutex_unlock(&opt->lock);\r\nreturn ret;\r\n}\r\nstatic int opt3001_read_event_value(struct iio_dev *iio,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info,\r\nint *val, int *val2)\r\n{\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret = IIO_VAL_INT_PLUS_MICRO;\r\nmutex_lock(&opt->lock);\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nopt3001_to_iio_ret(opt, opt->high_thresh_exp,\r\nopt->high_thresh_mantissa, val, val2);\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nopt3001_to_iio_ret(opt, opt->low_thresh_exp,\r\nopt->low_thresh_mantissa, val, val2);\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\n}\r\nmutex_unlock(&opt->lock);\r\nreturn ret;\r\n}\r\nstatic int opt3001_write_event_value(struct iio_dev *iio,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, enum iio_event_info info,\r\nint val, int val2)\r\n{\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret;\r\nu16 mantissa;\r\nu16 value;\r\nu16 reg;\r\nu8 exponent;\r\nif (val < 0)\r\nreturn -EINVAL;\r\nmutex_lock(&opt->lock);\r\nret = opt3001_find_scale(opt, val, val2, &exponent);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "can't find scale for %d.%06u\n", val, val2);\r\ngoto err;\r\n}\r\nmantissa = (((val * 1000) + (val2 / 1000)) / 10) >> exponent;\r\nvalue = (exponent << 12) | mantissa;\r\nswitch (dir) {\r\ncase IIO_EV_DIR_RISING:\r\nreg = OPT3001_HIGH_LIMIT;\r\nopt->high_thresh_mantissa = mantissa;\r\nopt->high_thresh_exp = exponent;\r\nbreak;\r\ncase IIO_EV_DIR_FALLING:\r\nreg = OPT3001_LOW_LIMIT;\r\nopt->low_thresh_mantissa = mantissa;\r\nopt->low_thresh_exp = exponent;\r\nbreak;\r\ndefault:\r\nret = -EINVAL;\r\ngoto err;\r\n}\r\nret = i2c_smbus_write_word_swapped(opt->client, reg, value);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n", reg);\r\ngoto err;\r\n}\r\nerr:\r\nmutex_unlock(&opt->lock);\r\nreturn ret;\r\n}\r\nstatic int opt3001_read_event_config(struct iio_dev *iio,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir)\r\n{\r\nstruct opt3001 *opt = iio_priv(iio);\r\nreturn opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS;\r\n}\r\nstatic int opt3001_write_event_config(struct iio_dev *iio,\r\nconst struct iio_chan_spec *chan, enum iio_event_type type,\r\nenum iio_event_direction dir, int state)\r\n{\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret;\r\nu16 mode;\r\nu16 reg;\r\nif (state && opt->mode == OPT3001_CONFIGURATION_M_CONTINUOUS)\r\nreturn 0;\r\nif (!state && opt->mode == OPT3001_CONFIGURATION_M_SHUTDOWN)\r\nreturn 0;\r\nmutex_lock(&opt->lock);\r\nmode = state ? OPT3001_CONFIGURATION_M_CONTINUOUS\r\n: OPT3001_CONFIGURATION_M_SHUTDOWN;\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\ngoto err;\r\n}\r\nreg = ret;\r\nopt3001_set_mode(opt, &reg, mode);\r\nret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\r\nreg);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n",\r\nOPT3001_CONFIGURATION);\r\ngoto err;\r\n}\r\nerr:\r\nmutex_unlock(&opt->lock);\r\nreturn ret;\r\n}\r\nstatic int opt3001_read_id(struct opt3001 *opt)\r\n{\r\nchar manufacturer[2];\r\nu16 device_id;\r\nint ret;\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_MANUFACTURER_ID);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_MANUFACTURER_ID);\r\nreturn ret;\r\n}\r\nmanufacturer[0] = ret >> 8;\r\nmanufacturer[1] = ret & 0xff;\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_DEVICE_ID);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_DEVICE_ID);\r\nreturn ret;\r\n}\r\ndevice_id = ret;\r\ndev_info(opt->dev, "Found %c%c OPT%04x\n", manufacturer[0],\r\nmanufacturer[1], device_id);\r\nreturn 0;\r\n}\r\nstatic int opt3001_configure(struct opt3001 *opt)\r\n{\r\nint ret;\r\nu16 reg;\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\nreturn ret;\r\n}\r\nreg = ret;\r\nreg &= ~OPT3001_CONFIGURATION_RN_MASK;\r\nreg |= OPT3001_CONFIGURATION_RN_AUTO;\r\nif (reg & OPT3001_CONFIGURATION_CT)\r\nopt->int_time = OPT3001_INT_TIME_LONG;\r\nelse\r\nopt->int_time = OPT3001_INT_TIME_SHORT;\r\nopt3001_set_mode(opt, &reg, OPT3001_CONFIGURATION_M_SHUTDOWN);\r\nreg |= OPT3001_CONFIGURATION_L;\r\nreg &= ~OPT3001_CONFIGURATION_POL;\r\nreg &= ~OPT3001_CONFIGURATION_ME;\r\nreg &= ~OPT3001_CONFIGURATION_FC_MASK;\r\nret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\r\nreg);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n",\r\nOPT3001_CONFIGURATION);\r\nreturn ret;\r\n}\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_LOW_LIMIT);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_LOW_LIMIT);\r\nreturn ret;\r\n}\r\nopt->low_thresh_mantissa = OPT3001_REG_MANTISSA(ret);\r\nopt->low_thresh_exp = OPT3001_REG_EXPONENT(ret);\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_HIGH_LIMIT);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_HIGH_LIMIT);\r\nreturn ret;\r\n}\r\nopt->high_thresh_mantissa = OPT3001_REG_MANTISSA(ret);\r\nopt->high_thresh_exp = OPT3001_REG_EXPONENT(ret);\r\nreturn 0;\r\n}\r\nstatic irqreturn_t opt3001_irq(int irq, void *_iio)\r\n{\r\nstruct iio_dev *iio = _iio;\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret;\r\nif (!opt->ok_to_ignore_lock)\r\nmutex_lock(&opt->lock);\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\ngoto out;\r\n}\r\nif ((ret & OPT3001_CONFIGURATION_M_MASK) ==\r\nOPT3001_CONFIGURATION_M_CONTINUOUS) {\r\nif (ret & OPT3001_CONFIGURATION_FH)\r\niio_push_event(iio,\r\nIIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_RISING),\r\niio_get_time_ns(iio));\r\nif (ret & OPT3001_CONFIGURATION_FL)\r\niio_push_event(iio,\r\nIIO_UNMOD_EVENT_CODE(IIO_LIGHT, 0,\r\nIIO_EV_TYPE_THRESH,\r\nIIO_EV_DIR_FALLING),\r\niio_get_time_ns(iio));\r\n} else if (ret & OPT3001_CONFIGURATION_CRF) {\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_RESULT);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_RESULT);\r\ngoto out;\r\n}\r\nopt->result = ret;\r\nopt->result_ready = true;\r\nwake_up(&opt->result_ready_queue);\r\n}\r\nout:\r\nif (!opt->ok_to_ignore_lock)\r\nmutex_unlock(&opt->lock);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic int opt3001_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct device *dev = &client->dev;\r\nstruct iio_dev *iio;\r\nstruct opt3001 *opt;\r\nint irq = client->irq;\r\nint ret;\r\niio = devm_iio_device_alloc(dev, sizeof(*opt));\r\nif (!iio)\r\nreturn -ENOMEM;\r\nopt = iio_priv(iio);\r\nopt->client = client;\r\nopt->dev = dev;\r\nmutex_init(&opt->lock);\r\ninit_waitqueue_head(&opt->result_ready_queue);\r\ni2c_set_clientdata(client, iio);\r\nret = opt3001_read_id(opt);\r\nif (ret)\r\nreturn ret;\r\nret = opt3001_configure(opt);\r\nif (ret)\r\nreturn ret;\r\niio->name = client->name;\r\niio->channels = opt3001_channels;\r\niio->num_channels = ARRAY_SIZE(opt3001_channels);\r\niio->dev.parent = dev;\r\niio->modes = INDIO_DIRECT_MODE;\r\niio->info = &opt3001_info;\r\nret = devm_iio_device_register(dev, iio);\r\nif (ret) {\r\ndev_err(dev, "failed to register IIO device\n");\r\nreturn ret;\r\n}\r\nif (irq > 0) {\r\nret = request_threaded_irq(irq, NULL, opt3001_irq,\r\nIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\r\n"opt3001", iio);\r\nif (ret) {\r\ndev_err(dev, "failed to request IRQ #%d\n", irq);\r\nreturn ret;\r\n}\r\nopt->use_irq = true;\r\n} else {\r\ndev_dbg(opt->dev, "enabling interrupt-less operation\n");\r\n}\r\nreturn 0;\r\n}\r\nstatic int opt3001_remove(struct i2c_client *client)\r\n{\r\nstruct iio_dev *iio = i2c_get_clientdata(client);\r\nstruct opt3001 *opt = iio_priv(iio);\r\nint ret;\r\nu16 reg;\r\nif (opt->use_irq)\r\nfree_irq(client->irq, iio);\r\nret = i2c_smbus_read_word_swapped(opt->client, OPT3001_CONFIGURATION);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to read register %02x\n",\r\nOPT3001_CONFIGURATION);\r\nreturn ret;\r\n}\r\nreg = ret;\r\nopt3001_set_mode(opt, &reg, OPT3001_CONFIGURATION_M_SHUTDOWN);\r\nret = i2c_smbus_write_word_swapped(opt->client, OPT3001_CONFIGURATION,\r\nreg);\r\nif (ret < 0) {\r\ndev_err(opt->dev, "failed to write register %02x\n",\r\nOPT3001_CONFIGURATION);\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}
