static void gpio_tilt_polled_poll(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_tilt_polled_dev *tdev = dev->private;\r\nconst struct gpio_tilt_platform_data *pdata = tdev->pdata;\r\nstruct input_dev *input = dev->input;\r\nstruct gpio_tilt_state *tilt_state = NULL;\r\nint state, i;\r\nif (tdev->count < tdev->threshold) {\r\ntdev->count++;\r\n} else {\r\nstate = 0;\r\nfor (i = 0; i < pdata->nr_gpios; i++)\r\nstate |= (!!gpio_get_value(pdata->gpios[i].gpio) << i);\r\nif (state != tdev->last_state) {\r\nfor (i = 0; i < pdata->nr_states; i++)\r\nif (pdata->states[i].gpios == state)\r\ntilt_state = &pdata->states[i];\r\nif (tilt_state) {\r\nfor (i = 0; i < pdata->nr_axes; i++)\r\ninput_report_abs(input,\r\npdata->axes[i].axis,\r\ntilt_state->axes[i]);\r\ninput_sync(input);\r\n}\r\ntdev->count = 0;\r\ntdev->last_state = state;\r\n}\r\n}\r\n}\r\nstatic void gpio_tilt_polled_open(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_tilt_polled_dev *tdev = dev->private;\r\nconst struct gpio_tilt_platform_data *pdata = tdev->pdata;\r\nif (pdata->enable)\r\npdata->enable(tdev->dev);\r\ntdev->last_state = -1;\r\ntdev->count = tdev->threshold;\r\ngpio_tilt_polled_poll(tdev->poll_dev);\r\n}\r\nstatic void gpio_tilt_polled_close(struct input_polled_dev *dev)\r\n{\r\nstruct gpio_tilt_polled_dev *tdev = dev->private;\r\nconst struct gpio_tilt_platform_data *pdata = tdev->pdata;\r\nif (pdata->disable)\r\npdata->disable(tdev->dev);\r\n}\r\nstatic int gpio_tilt_polled_probe(struct platform_device *pdev)\r\n{\r\nconst struct gpio_tilt_platform_data *pdata =\r\ndev_get_platdata(&pdev->dev);\r\nstruct device *dev = &pdev->dev;\r\nstruct gpio_tilt_polled_dev *tdev;\r\nstruct input_polled_dev *poll_dev;\r\nstruct input_dev *input;\r\nint error, i;\r\nif (!pdata || !pdata->poll_interval)\r\nreturn -EINVAL;\r\ntdev = kzalloc(sizeof(struct gpio_tilt_polled_dev), GFP_KERNEL);\r\nif (!tdev) {\r\ndev_err(dev, "no memory for private data\n");\r\nreturn -ENOMEM;\r\n}\r\nerror = gpio_request_array(pdata->gpios, pdata->nr_gpios);\r\nif (error) {\r\ndev_err(dev,\r\n"Could not request tilt GPIOs: %d\n", error);\r\ngoto err_free_tdev;\r\n}\r\npoll_dev = input_allocate_polled_device();\r\nif (!poll_dev) {\r\ndev_err(dev, "no memory for polled device\n");\r\nerror = -ENOMEM;\r\ngoto err_free_gpios;\r\n}\r\npoll_dev->private = tdev;\r\npoll_dev->poll = gpio_tilt_polled_poll;\r\npoll_dev->poll_interval = pdata->poll_interval;\r\npoll_dev->open = gpio_tilt_polled_open;\r\npoll_dev->close = gpio_tilt_polled_close;\r\ninput = poll_dev->input;\r\ninput->name = pdev->name;\r\ninput->phys = DRV_NAME"/input0";\r\ninput->dev.parent = dev;\r\ninput->id.bustype = BUS_HOST;\r\ninput->id.vendor = 0x0001;\r\ninput->id.product = 0x0001;\r\ninput->id.version = 0x0100;\r\n__set_bit(EV_ABS, input->evbit);\r\nfor (i = 0; i < pdata->nr_axes; i++)\r\ninput_set_abs_params(input, pdata->axes[i].axis,\r\npdata->axes[i].min, pdata->axes[i].max,\r\npdata->axes[i].fuzz, pdata->axes[i].flat);\r\ntdev->threshold = DIV_ROUND_UP(pdata->debounce_interval,\r\npdata->poll_interval);\r\ntdev->poll_dev = poll_dev;\r\ntdev->dev = dev;\r\ntdev->pdata = pdata;\r\nerror = input_register_polled_device(poll_dev);\r\nif (error) {\r\ndev_err(dev, "unable to register polled device, err=%d\n",\r\nerror);\r\ngoto err_free_polldev;\r\n}\r\nplatform_set_drvdata(pdev, tdev);\r\nreturn 0;\r\nerr_free_polldev:\r\ninput_free_polled_device(poll_dev);\r\nerr_free_gpios:\r\ngpio_free_array(pdata->gpios, pdata->nr_gpios);\r\nerr_free_tdev:\r\nkfree(tdev);\r\nreturn error;\r\n}\r\nstatic int gpio_tilt_polled_remove(struct platform_device *pdev)\r\n{\r\nstruct gpio_tilt_polled_dev *tdev = platform_get_drvdata(pdev);\r\nconst struct gpio_tilt_platform_data *pdata = tdev->pdata;\r\ninput_unregister_polled_device(tdev->poll_dev);\r\ninput_free_polled_device(tdev->poll_dev);\r\ngpio_free_array(pdata->gpios, pdata->nr_gpios);\r\nkfree(tdev);\r\nreturn 0;\r\n}
