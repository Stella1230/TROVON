bool\r\nnvkm_engine_chsw_load(struct nvkm_engine *engine)\r\n{\r\nif (engine->func->chsw_load)\r\nreturn engine->func->chsw_load(engine);\r\nreturn false;\r\n}\r\nvoid\r\nnvkm_engine_unref(struct nvkm_engine **pengine)\r\n{\r\nstruct nvkm_engine *engine = *pengine;\r\nif (engine) {\r\nmutex_lock(&engine->subdev.mutex);\r\nif (--engine->usecount == 0)\r\nnvkm_subdev_fini(&engine->subdev, false);\r\nmutex_unlock(&engine->subdev.mutex);\r\n*pengine = NULL;\r\n}\r\n}\r\nstruct nvkm_engine *\r\nnvkm_engine_ref(struct nvkm_engine *engine)\r\n{\r\nif (engine) {\r\nmutex_lock(&engine->subdev.mutex);\r\nif (++engine->usecount == 1) {\r\nint ret = nvkm_subdev_init(&engine->subdev);\r\nif (ret) {\r\nengine->usecount--;\r\nmutex_unlock(&engine->subdev.mutex);\r\nreturn ERR_PTR(ret);\r\n}\r\n}\r\nmutex_unlock(&engine->subdev.mutex);\r\n}\r\nreturn engine;\r\n}\r\nvoid\r\nnvkm_engine_tile(struct nvkm_engine *engine, int region)\r\n{\r\nstruct nvkm_fb *fb = engine->subdev.device->fb;\r\nif (engine->func->tile)\r\nengine->func->tile(engine, region, &fb->tile.region[region]);\r\n}\r\nstatic void\r\nnvkm_engine_intr(struct nvkm_subdev *subdev)\r\n{\r\nstruct nvkm_engine *engine = nvkm_engine(subdev);\r\nif (engine->func->intr)\r\nengine->func->intr(engine);\r\n}\r\nstatic int\r\nnvkm_engine_fini(struct nvkm_subdev *subdev, bool suspend)\r\n{\r\nstruct nvkm_engine *engine = nvkm_engine(subdev);\r\nif (engine->func->fini)\r\nreturn engine->func->fini(engine, suspend);\r\nreturn 0;\r\n}\r\nstatic int\r\nnvkm_engine_init(struct nvkm_subdev *subdev)\r\n{\r\nstruct nvkm_engine *engine = nvkm_engine(subdev);\r\nstruct nvkm_fb *fb = subdev->device->fb;\r\nint ret = 0, i;\r\ns64 time;\r\nif (!engine->usecount) {\r\nnvkm_trace(subdev, "init skipped, engine has no users\n");\r\nreturn ret;\r\n}\r\nif (engine->func->oneinit && !engine->subdev.oneinit) {\r\nnvkm_trace(subdev, "one-time init running...\n");\r\ntime = ktime_to_us(ktime_get());\r\nret = engine->func->oneinit(engine);\r\nif (ret) {\r\nnvkm_trace(subdev, "one-time init failed, %d\n", ret);\r\nreturn ret;\r\n}\r\nengine->subdev.oneinit = true;\r\ntime = ktime_to_us(ktime_get()) - time;\r\nnvkm_trace(subdev, "one-time init completed in %lldus\n", time);\r\n}\r\nif (engine->func->init)\r\nret = engine->func->init(engine);\r\nfor (i = 0; fb && i < fb->tile.regions; i++)\r\nnvkm_engine_tile(engine, i);\r\nreturn ret;\r\n}\r\nstatic void *\r\nnvkm_engine_dtor(struct nvkm_subdev *subdev)\r\n{\r\nstruct nvkm_engine *engine = nvkm_engine(subdev);\r\nif (engine->func->dtor)\r\nreturn engine->func->dtor(engine);\r\nreturn engine;\r\n}\r\nint\r\nnvkm_engine_ctor(const struct nvkm_engine_func *func,\r\nstruct nvkm_device *device, int index, bool enable,\r\nstruct nvkm_engine *engine)\r\n{\r\nnvkm_subdev_ctor(&nvkm_engine_func, device, index, &engine->subdev);\r\nengine->func = func;\r\nif (!nvkm_boolopt(device->cfgopt, nvkm_subdev_name[index], enable)) {\r\nnvkm_debug(&engine->subdev, "disabled\n");\r\nreturn -ENODEV;\r\n}\r\nspin_lock_init(&engine->lock);\r\nreturn 0;\r\n}\r\nint\r\nnvkm_engine_new_(const struct nvkm_engine_func *func,\r\nstruct nvkm_device *device, int index, bool enable,\r\nstruct nvkm_engine **pengine)\r\n{\r\nif (!(*pengine = kzalloc(sizeof(**pengine), GFP_KERNEL)))\r\nreturn -ENOMEM;\r\nreturn nvkm_engine_ctor(func, device, index, enable, *pengine);\r\n}
