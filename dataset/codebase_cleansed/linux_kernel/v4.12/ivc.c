static inline void tegra_ivc_invalidate(struct tegra_ivc *ivc, dma_addr_t phys)\r\n{\r\nif (!ivc->peer)\r\nreturn;\r\ndma_sync_single_for_cpu(ivc->peer, phys, TEGRA_IVC_ALIGN,\r\nDMA_FROM_DEVICE);\r\n}\r\nstatic inline void tegra_ivc_flush(struct tegra_ivc *ivc, dma_addr_t phys)\r\n{\r\nif (!ivc->peer)\r\nreturn;\r\ndma_sync_single_for_device(ivc->peer, phys, TEGRA_IVC_ALIGN,\r\nDMA_TO_DEVICE);\r\n}\r\nstatic inline bool tegra_ivc_empty(struct tegra_ivc *ivc,\r\nstruct tegra_ivc_header *header)\r\n{\r\nu32 tx = ACCESS_ONCE(header->tx.count);\r\nu32 rx = ACCESS_ONCE(header->rx.count);\r\nif (tx - rx > ivc->num_frames)\r\nreturn true;\r\nreturn tx == rx;\r\n}\r\nstatic inline bool tegra_ivc_full(struct tegra_ivc *ivc,\r\nstruct tegra_ivc_header *header)\r\n{\r\nu32 tx = ACCESS_ONCE(header->tx.count);\r\nu32 rx = ACCESS_ONCE(header->rx.count);\r\nreturn tx - rx >= ivc->num_frames;\r\n}\r\nstatic inline u32 tegra_ivc_available(struct tegra_ivc *ivc,\r\nstruct tegra_ivc_header *header)\r\n{\r\nu32 tx = ACCESS_ONCE(header->tx.count);\r\nu32 rx = ACCESS_ONCE(header->rx.count);\r\nreturn tx - rx;\r\n}\r\nstatic inline void tegra_ivc_advance_tx(struct tegra_ivc *ivc)\r\n{\r\nACCESS_ONCE(ivc->tx.channel->tx.count) =\r\nACCESS_ONCE(ivc->tx.channel->tx.count) + 1;\r\nif (ivc->tx.position == ivc->num_frames - 1)\r\nivc->tx.position = 0;\r\nelse\r\nivc->tx.position++;\r\n}\r\nstatic inline void tegra_ivc_advance_rx(struct tegra_ivc *ivc)\r\n{\r\nACCESS_ONCE(ivc->rx.channel->rx.count) =\r\nACCESS_ONCE(ivc->rx.channel->rx.count) + 1;\r\nif (ivc->rx.position == ivc->num_frames - 1)\r\nivc->rx.position = 0;\r\nelse\r\nivc->rx.position++;\r\n}\r\nstatic inline int tegra_ivc_check_read(struct tegra_ivc *ivc)\r\n{\r\nunsigned int offset = offsetof(struct tegra_ivc_header, tx.count);\r\nif (ivc->tx.channel->tx.state != TEGRA_IVC_STATE_ESTABLISHED)\r\nreturn -ECONNRESET;\r\nif (!tegra_ivc_empty(ivc, ivc->rx.channel))\r\nreturn 0;\r\ntegra_ivc_invalidate(ivc, ivc->rx.phys + offset);\r\nif (tegra_ivc_empty(ivc, ivc->rx.channel))\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nstatic inline int tegra_ivc_check_write(struct tegra_ivc *ivc)\r\n{\r\nunsigned int offset = offsetof(struct tegra_ivc_header, rx.count);\r\nif (ivc->tx.channel->tx.state != TEGRA_IVC_STATE_ESTABLISHED)\r\nreturn -ECONNRESET;\r\nif (!tegra_ivc_full(ivc, ivc->tx.channel))\r\nreturn 0;\r\ntegra_ivc_invalidate(ivc, ivc->tx.phys + offset);\r\nif (tegra_ivc_full(ivc, ivc->tx.channel))\r\nreturn -ENOSPC;\r\nreturn 0;\r\n}\r\nstatic void *tegra_ivc_frame_virt(struct tegra_ivc *ivc,\r\nstruct tegra_ivc_header *header,\r\nunsigned int frame)\r\n{\r\nif (WARN_ON(frame >= ivc->num_frames))\r\nreturn ERR_PTR(-EINVAL);\r\nreturn (void *)(header + 1) + ivc->frame_size * frame;\r\n}\r\nstatic inline dma_addr_t tegra_ivc_frame_phys(struct tegra_ivc *ivc,\r\ndma_addr_t phys,\r\nunsigned int frame)\r\n{\r\nunsigned long offset;\r\noffset = sizeof(struct tegra_ivc_header) + ivc->frame_size * frame;\r\nreturn phys + offset;\r\n}\r\nstatic inline void tegra_ivc_invalidate_frame(struct tegra_ivc *ivc,\r\ndma_addr_t phys,\r\nunsigned int frame,\r\nunsigned int offset,\r\nsize_t size)\r\n{\r\nif (!ivc->peer || WARN_ON(frame >= ivc->num_frames))\r\nreturn;\r\nphys = tegra_ivc_frame_phys(ivc, phys, frame) + offset;\r\ndma_sync_single_for_cpu(ivc->peer, phys, size, DMA_FROM_DEVICE);\r\n}\r\nstatic inline void tegra_ivc_flush_frame(struct tegra_ivc *ivc,\r\ndma_addr_t phys,\r\nunsigned int frame,\r\nunsigned int offset,\r\nsize_t size)\r\n{\r\nif (!ivc->peer || WARN_ON(frame >= ivc->num_frames))\r\nreturn;\r\nphys = tegra_ivc_frame_phys(ivc, phys, frame) + offset;\r\ndma_sync_single_for_device(ivc->peer, phys, size, DMA_TO_DEVICE);\r\n}\r\nvoid *tegra_ivc_read_get_next_frame(struct tegra_ivc *ivc)\r\n{\r\nint err;\r\nif (WARN_ON(ivc == NULL))\r\nreturn ERR_PTR(-EINVAL);\r\nerr = tegra_ivc_check_read(ivc);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nsmp_rmb();\r\ntegra_ivc_invalidate_frame(ivc, ivc->rx.phys, ivc->rx.position, 0,\r\nivc->frame_size);\r\nreturn tegra_ivc_frame_virt(ivc, ivc->rx.channel, ivc->rx.position);\r\n}\r\nint tegra_ivc_read_advance(struct tegra_ivc *ivc)\r\n{\r\nunsigned int rx = offsetof(struct tegra_ivc_header, rx.count);\r\nunsigned int tx = offsetof(struct tegra_ivc_header, tx.count);\r\nint err;\r\nerr = tegra_ivc_check_read(ivc);\r\nif (err < 0)\r\nreturn err;\r\ntegra_ivc_advance_rx(ivc);\r\ntegra_ivc_flush(ivc, ivc->rx.phys + rx);\r\nsmp_mb();\r\ntegra_ivc_invalidate(ivc, ivc->rx.phys + tx);\r\nif (tegra_ivc_available(ivc, ivc->rx.channel) == ivc->num_frames - 1)\r\nivc->notify(ivc, ivc->notify_data);\r\nreturn 0;\r\n}\r\nvoid *tegra_ivc_write_get_next_frame(struct tegra_ivc *ivc)\r\n{\r\nint err;\r\nerr = tegra_ivc_check_write(ivc);\r\nif (err < 0)\r\nreturn ERR_PTR(err);\r\nreturn tegra_ivc_frame_virt(ivc, ivc->tx.channel, ivc->tx.position);\r\n}\r\nint tegra_ivc_write_advance(struct tegra_ivc *ivc)\r\n{\r\nunsigned int tx = offsetof(struct tegra_ivc_header, tx.count);\r\nunsigned int rx = offsetof(struct tegra_ivc_header, rx.count);\r\nint err;\r\nerr = tegra_ivc_check_write(ivc);\r\nif (err < 0)\r\nreturn err;\r\ntegra_ivc_flush_frame(ivc, ivc->tx.phys, ivc->tx.position, 0,\r\nivc->frame_size);\r\nsmp_wmb();\r\ntegra_ivc_advance_tx(ivc);\r\ntegra_ivc_flush(ivc, ivc->tx.phys + tx);\r\nsmp_mb();\r\ntegra_ivc_invalidate(ivc, ivc->tx.phys + rx);\r\nif (tegra_ivc_available(ivc, ivc->tx.channel) == 1)\r\nivc->notify(ivc, ivc->notify_data);\r\nreturn 0;\r\n}\r\nvoid tegra_ivc_reset(struct tegra_ivc *ivc)\r\n{\r\nunsigned int offset = offsetof(struct tegra_ivc_header, tx.count);\r\nivc->tx.channel->tx.state = TEGRA_IVC_STATE_SYNC;\r\ntegra_ivc_flush(ivc, ivc->tx.phys + offset);\r\nivc->notify(ivc, ivc->notify_data);\r\n}\r\nint tegra_ivc_notified(struct tegra_ivc *ivc)\r\n{\r\nunsigned int offset = offsetof(struct tegra_ivc_header, tx.count);\r\nenum tegra_ivc_state state;\r\ntegra_ivc_invalidate(ivc, ivc->rx.phys + offset);\r\nstate = ACCESS_ONCE(ivc->rx.channel->tx.state);\r\nif (state == TEGRA_IVC_STATE_SYNC) {\r\noffset = offsetof(struct tegra_ivc_header, tx.count);\r\nsmp_rmb();\r\nivc->tx.channel->tx.count = 0;\r\nivc->rx.channel->rx.count = 0;\r\nivc->tx.position = 0;\r\nivc->rx.position = 0;\r\nsmp_wmb();\r\nivc->tx.channel->tx.state = TEGRA_IVC_STATE_ACK;\r\ntegra_ivc_flush(ivc, ivc->tx.phys + offset);\r\nivc->notify(ivc, ivc->notify_data);\r\n} else if (ivc->tx.channel->tx.state == TEGRA_IVC_STATE_SYNC &&\r\nstate == TEGRA_IVC_STATE_ACK) {\r\noffset = offsetof(struct tegra_ivc_header, tx.count);\r\nsmp_rmb();\r\nivc->tx.channel->tx.count = 0;\r\nivc->rx.channel->rx.count = 0;\r\nivc->tx.position = 0;\r\nivc->rx.position = 0;\r\nsmp_wmb();\r\nivc->tx.channel->tx.state = TEGRA_IVC_STATE_ESTABLISHED;\r\ntegra_ivc_flush(ivc, ivc->tx.phys + offset);\r\nivc->notify(ivc, ivc->notify_data);\r\n} else if (ivc->tx.channel->tx.state == TEGRA_IVC_STATE_ACK) {\r\noffset = offsetof(struct tegra_ivc_header, tx.count);\r\nsmp_rmb();\r\nivc->tx.channel->tx.state = TEGRA_IVC_STATE_ESTABLISHED;\r\ntegra_ivc_flush(ivc, ivc->tx.phys + offset);\r\nivc->notify(ivc, ivc->notify_data);\r\n} else {\r\n}\r\nif (ivc->tx.channel->tx.state != TEGRA_IVC_STATE_ESTABLISHED)\r\nreturn -EAGAIN;\r\nreturn 0;\r\n}\r\nsize_t tegra_ivc_align(size_t size)\r\n{\r\nreturn ALIGN(size, TEGRA_IVC_ALIGN);\r\n}\r\nunsigned tegra_ivc_total_queue_size(unsigned queue_size)\r\n{\r\nif (!IS_ALIGNED(queue_size, TEGRA_IVC_ALIGN)) {\r\npr_err("%s: queue_size (%u) must be %u-byte aligned\n",\r\n__func__, queue_size, TEGRA_IVC_ALIGN);\r\nreturn 0;\r\n}\r\nreturn queue_size + sizeof(struct tegra_ivc_header);\r\n}\r\nstatic int tegra_ivc_check_params(unsigned long rx, unsigned long tx,\r\nunsigned int num_frames, size_t frame_size)\r\n{\r\nBUILD_BUG_ON(!IS_ALIGNED(offsetof(struct tegra_ivc_header, tx.count),\r\nTEGRA_IVC_ALIGN));\r\nBUILD_BUG_ON(!IS_ALIGNED(offsetof(struct tegra_ivc_header, rx.count),\r\nTEGRA_IVC_ALIGN));\r\nBUILD_BUG_ON(!IS_ALIGNED(sizeof(struct tegra_ivc_header),\r\nTEGRA_IVC_ALIGN));\r\nif ((uint64_t)num_frames * (uint64_t)frame_size >= 0x100000000UL) {\r\npr_err("num_frames * frame_size overflows\n");\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(frame_size, TEGRA_IVC_ALIGN)) {\r\npr_err("frame size not adequately aligned: %zu\n", frame_size);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(rx, TEGRA_IVC_ALIGN)) {\r\npr_err("IVC channel start not aligned: %#lx\n", rx);\r\nreturn -EINVAL;\r\n}\r\nif (!IS_ALIGNED(tx, TEGRA_IVC_ALIGN)) {\r\npr_err("IVC channel start not aligned: %#lx\n", tx);\r\nreturn -EINVAL;\r\n}\r\nif (rx < tx) {\r\nif (rx + frame_size * num_frames > tx) {\r\npr_err("queue regions overlap: %#lx + %zx > %#lx\n",\r\nrx, frame_size * num_frames, tx);\r\nreturn -EINVAL;\r\n}\r\n} else {\r\nif (tx + frame_size * num_frames > rx) {\r\npr_err("queue regions overlap: %#lx + %zx > %#lx\n",\r\ntx, frame_size * num_frames, rx);\r\nreturn -EINVAL;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nint tegra_ivc_init(struct tegra_ivc *ivc, struct device *peer, void *rx,\r\ndma_addr_t rx_phys, void *tx, dma_addr_t tx_phys,\r\nunsigned int num_frames, size_t frame_size,\r\nvoid (*notify)(struct tegra_ivc *ivc, void *data),\r\nvoid *data)\r\n{\r\nsize_t queue_size;\r\nint err;\r\nif (WARN_ON(!ivc || !notify))\r\nreturn -EINVAL;\r\nif (frame_size > INT_MAX)\r\nreturn -E2BIG;\r\nerr = tegra_ivc_check_params((unsigned long)rx, (unsigned long)tx,\r\nnum_frames, frame_size);\r\nif (err < 0)\r\nreturn err;\r\nqueue_size = tegra_ivc_total_queue_size(num_frames * frame_size);\r\nif (peer) {\r\nivc->rx.phys = dma_map_single(peer, rx, queue_size,\r\nDMA_BIDIRECTIONAL);\r\nif (ivc->rx.phys == DMA_ERROR_CODE)\r\nreturn -ENOMEM;\r\nivc->tx.phys = dma_map_single(peer, tx, queue_size,\r\nDMA_BIDIRECTIONAL);\r\nif (ivc->tx.phys == DMA_ERROR_CODE) {\r\ndma_unmap_single(peer, ivc->rx.phys, queue_size,\r\nDMA_BIDIRECTIONAL);\r\nreturn -ENOMEM;\r\n}\r\n} else {\r\nivc->rx.phys = rx_phys;\r\nivc->tx.phys = tx_phys;\r\n}\r\nivc->rx.channel = rx;\r\nivc->tx.channel = tx;\r\nivc->peer = peer;\r\nivc->notify = notify;\r\nivc->notify_data = data;\r\nivc->frame_size = frame_size;\r\nivc->num_frames = num_frames;\r\nivc->tx.position = 0;\r\nivc->rx.position = 0;\r\nreturn 0;\r\n}\r\nvoid tegra_ivc_cleanup(struct tegra_ivc *ivc)\r\n{\r\nif (ivc->peer) {\r\nsize_t size = tegra_ivc_total_queue_size(ivc->num_frames *\r\nivc->frame_size);\r\ndma_unmap_single(ivc->peer, ivc->rx.phys, size,\r\nDMA_BIDIRECTIONAL);\r\ndma_unmap_single(ivc->peer, ivc->tx.phys, size,\r\nDMA_BIDIRECTIONAL);\r\n}\r\n}
