static int\r\nnfs4_file_open(struct inode *inode, struct file *filp)\r\n{\r\nstruct nfs_open_context *ctx;\r\nstruct dentry *dentry = file_dentry(filp);\r\nstruct dentry *parent = NULL;\r\nstruct inode *dir;\r\nunsigned openflags = filp->f_flags;\r\nstruct iattr attr;\r\nint err;\r\ndprintk("NFS: open file(%pd2)\n", dentry);\r\nerr = nfs_check_flags(openflags);\r\nif (err)\r\nreturn err;\r\nif ((openflags & O_ACCMODE) == 3)\r\nopenflags--;\r\nopenflags &= ~(O_CREAT|O_EXCL);\r\nparent = dget_parent(dentry);\r\ndir = d_inode(parent);\r\nctx = alloc_nfs_open_context(file_dentry(filp), filp->f_mode, filp);\r\nerr = PTR_ERR(ctx);\r\nif (IS_ERR(ctx))\r\ngoto out;\r\nattr.ia_valid = ATTR_OPEN;\r\nif (openflags & O_TRUNC) {\r\nattr.ia_valid |= ATTR_SIZE;\r\nattr.ia_size = 0;\r\nfilemap_write_and_wait(inode->i_mapping);\r\n}\r\ninode = NFS_PROTO(dir)->open_context(dir, ctx, openflags, &attr, NULL);\r\nif (IS_ERR(inode)) {\r\nerr = PTR_ERR(inode);\r\nswitch (err) {\r\ncase -EPERM:\r\ncase -EACCES:\r\ncase -EDQUOT:\r\ncase -ENOSPC:\r\ncase -EROFS:\r\ngoto out_put_ctx;\r\ndefault:\r\ngoto out_drop;\r\n}\r\n}\r\nif (inode != d_inode(dentry))\r\ngoto out_drop;\r\nnfs_set_verifier(dentry, nfs_save_change_attribute(dir));\r\nnfs_file_set_open_context(filp, ctx);\r\nnfs_fscache_open_file(inode, filp);\r\nerr = 0;\r\nout_put_ctx:\r\nput_nfs_open_context(ctx);\r\nout:\r\ndput(parent);\r\nreturn err;\r\nout_drop:\r\nd_drop(dentry);\r\nerr = -EOPENSTALE;\r\ngoto out_put_ctx;\r\n}\r\nstatic int\r\nnfs4_file_flush(struct file *file, fl_owner_t id)\r\n{\r\nstruct inode *inode = file_inode(file);\r\ndprintk("NFS: flush(%pD2)\n", file);\r\nnfs_inc_stats(inode, NFSIOS_VFSFLUSH);\r\nif ((file->f_mode & FMODE_WRITE) == 0)\r\nreturn 0;\r\nif (!nfs4_delegation_flush_on_close(inode))\r\nreturn filemap_fdatawrite(file->f_mapping);\r\nreturn vfs_fsync(file, 0);\r\n}\r\nstatic ssize_t nfs4_copy_file_range(struct file *file_in, loff_t pos_in,\r\nstruct file *file_out, loff_t pos_out,\r\nsize_t count, unsigned int flags)\r\n{\r\nif (file_inode(file_in) == file_inode(file_out))\r\nreturn -EINVAL;\r\nreturn nfs42_proc_copy(file_in, pos_in, file_out, pos_out, count);\r\n}\r\nstatic loff_t nfs4_file_llseek(struct file *filep, loff_t offset, int whence)\r\n{\r\nloff_t ret;\r\nswitch (whence) {\r\ncase SEEK_HOLE:\r\ncase SEEK_DATA:\r\nret = nfs42_proc_llseek(filep, offset, whence);\r\nif (ret != -ENOTSUPP)\r\nreturn ret;\r\ndefault:\r\nreturn nfs_file_llseek(filep, offset, whence);\r\n}\r\n}\r\nstatic long nfs42_fallocate(struct file *filep, int mode, loff_t offset, loff_t len)\r\n{\r\nstruct inode *inode = file_inode(filep);\r\nlong ret;\r\nif (!S_ISREG(inode->i_mode))\r\nreturn -EOPNOTSUPP;\r\nif ((mode != 0) && (mode != (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE)))\r\nreturn -EOPNOTSUPP;\r\nret = inode_newsize_ok(inode, offset + len);\r\nif (ret < 0)\r\nreturn ret;\r\nif (mode & FALLOC_FL_PUNCH_HOLE)\r\nreturn nfs42_proc_deallocate(filep, offset, len);\r\nreturn nfs42_proc_allocate(filep, offset, len);\r\n}\r\nstatic int nfs42_clone_file_range(struct file *src_file, loff_t src_off,\r\nstruct file *dst_file, loff_t dst_off, u64 count)\r\n{\r\nstruct inode *dst_inode = file_inode(dst_file);\r\nstruct nfs_server *server = NFS_SERVER(dst_inode);\r\nstruct inode *src_inode = file_inode(src_file);\r\nunsigned int bs = server->clone_blksize;\r\nbool same_inode = false;\r\nint ret;\r\nret = -EINVAL;\r\nif (bs) {\r\nif (!IS_ALIGNED(src_off, bs) || !IS_ALIGNED(dst_off, bs))\r\ngoto out;\r\nif (!IS_ALIGNED(count, bs) && i_size_read(src_inode) != (src_off + count))\r\ngoto out;\r\n}\r\nif (src_inode == dst_inode)\r\nsame_inode = true;\r\nif (same_inode) {\r\ninode_lock(src_inode);\r\n} else if (dst_inode < src_inode) {\r\ninode_lock_nested(dst_inode, I_MUTEX_PARENT);\r\ninode_lock_nested(src_inode, I_MUTEX_CHILD);\r\n} else {\r\ninode_lock_nested(src_inode, I_MUTEX_PARENT);\r\ninode_lock_nested(dst_inode, I_MUTEX_CHILD);\r\n}\r\nret = nfs_sync_inode(src_inode);\r\nif (ret)\r\ngoto out_unlock;\r\nret = nfs_sync_inode(dst_inode);\r\nif (ret)\r\ngoto out_unlock;\r\nret = nfs42_proc_clone(src_file, dst_file, src_off, dst_off, count);\r\nif (!ret)\r\ntruncate_inode_pages_range(&dst_inode->i_data, dst_off, dst_off + count - 1);\r\nout_unlock:\r\nif (same_inode) {\r\ninode_unlock(src_inode);\r\n} else if (dst_inode < src_inode) {\r\ninode_unlock(src_inode);\r\ninode_unlock(dst_inode);\r\n} else {\r\ninode_unlock(dst_inode);\r\ninode_unlock(src_inode);\r\n}\r\nout:\r\nreturn ret;\r\n}
