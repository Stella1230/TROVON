static inline const struct lpss_config\r\n*lpss_get_config(const struct driver_data *drv_data)\r\n{\r\nreturn &lpss_platforms[drv_data->ssp_type - LPSS_LPT_SSP];\r\n}\r\nstatic bool is_lpss_ssp(const struct driver_data *drv_data)\r\n{\r\nswitch (drv_data->ssp_type) {\r\ncase LPSS_LPT_SSP:\r\ncase LPSS_BYT_SSP:\r\ncase LPSS_BSW_SSP:\r\ncase LPSS_SPT_SSP:\r\ncase LPSS_BXT_SSP:\r\nreturn true;\r\ndefault:\r\nreturn false;\r\n}\r\n}\r\nstatic bool is_quark_x1000_ssp(const struct driver_data *drv_data)\r\n{\r\nreturn drv_data->ssp_type == QUARK_X1000_SSP;\r\n}\r\nstatic u32 pxa2xx_spi_get_ssrc1_change_mask(const struct driver_data *drv_data)\r\n{\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nreturn QUARK_X1000_SSCR1_CHANGE_MASK;\r\ncase CE4100_SSP:\r\nreturn CE4100_SSCR1_CHANGE_MASK;\r\ndefault:\r\nreturn SSCR1_CHANGE_MASK;\r\n}\r\n}\r\nstatic u32\r\npxa2xx_spi_get_rx_default_thre(const struct driver_data *drv_data)\r\n{\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nreturn RX_THRESH_QUARK_X1000_DFLT;\r\ncase CE4100_SSP:\r\nreturn RX_THRESH_CE4100_DFLT;\r\ndefault:\r\nreturn RX_THRESH_DFLT;\r\n}\r\n}\r\nstatic bool pxa2xx_spi_txfifo_full(const struct driver_data *drv_data)\r\n{\r\nu32 mask;\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nmask = QUARK_X1000_SSSR_TFL_MASK;\r\nbreak;\r\ncase CE4100_SSP:\r\nmask = CE4100_SSSR_TFL_MASK;\r\nbreak;\r\ndefault:\r\nmask = SSSR_TFL_MASK;\r\nbreak;\r\n}\r\nreturn (pxa2xx_spi_read(drv_data, SSSR) & mask) == mask;\r\n}\r\nstatic void pxa2xx_spi_clear_rx_thre(const struct driver_data *drv_data,\r\nu32 *sccr1_reg)\r\n{\r\nu32 mask;\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nmask = QUARK_X1000_SSCR1_RFT;\r\nbreak;\r\ncase CE4100_SSP:\r\nmask = CE4100_SSCR1_RFT;\r\nbreak;\r\ndefault:\r\nmask = SSCR1_RFT;\r\nbreak;\r\n}\r\n*sccr1_reg &= ~mask;\r\n}\r\nstatic void pxa2xx_spi_set_rx_thre(const struct driver_data *drv_data,\r\nu32 *sccr1_reg, u32 threshold)\r\n{\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\n*sccr1_reg |= QUARK_X1000_SSCR1_RxTresh(threshold);\r\nbreak;\r\ncase CE4100_SSP:\r\n*sccr1_reg |= CE4100_SSCR1_RxTresh(threshold);\r\nbreak;\r\ndefault:\r\n*sccr1_reg |= SSCR1_RxTresh(threshold);\r\nbreak;\r\n}\r\n}\r\nstatic u32 pxa2xx_configure_sscr0(const struct driver_data *drv_data,\r\nu32 clk_div, u8 bits)\r\n{\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nreturn clk_div\r\n| QUARK_X1000_SSCR0_Motorola\r\n| QUARK_X1000_SSCR0_DataSize(bits > 32 ? 8 : bits)\r\n| SSCR0_SSE;\r\ndefault:\r\nreturn clk_div\r\n| SSCR0_Motorola\r\n| SSCR0_DataSize(bits > 16 ? bits - 16 : bits)\r\n| SSCR0_SSE\r\n| (bits > 16 ? SSCR0_EDSS : 0);\r\n}\r\n}\r\nstatic u32 __lpss_ssp_read_priv(struct driver_data *drv_data, unsigned offset)\r\n{\r\nWARN_ON(!drv_data->lpss_base);\r\nreturn readl(drv_data->lpss_base + offset);\r\n}\r\nstatic void __lpss_ssp_write_priv(struct driver_data *drv_data,\r\nunsigned offset, u32 value)\r\n{\r\nWARN_ON(!drv_data->lpss_base);\r\nwritel(value, drv_data->lpss_base + offset);\r\n}\r\nstatic void lpss_ssp_setup(struct driver_data *drv_data)\r\n{\r\nconst struct lpss_config *config;\r\nu32 value;\r\nconfig = lpss_get_config(drv_data);\r\ndrv_data->lpss_base = drv_data->ioaddr + config->offset;\r\nvalue = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);\r\nvalue &= ~(LPSS_CS_CONTROL_SW_MODE | LPSS_CS_CONTROL_CS_HIGH);\r\nvalue |= LPSS_CS_CONTROL_SW_MODE | LPSS_CS_CONTROL_CS_HIGH;\r\n__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);\r\nif (drv_data->master_info->enable_dma) {\r\n__lpss_ssp_write_priv(drv_data, config->reg_ssp, 1);\r\nif (config->reg_general >= 0) {\r\nvalue = __lpss_ssp_read_priv(drv_data,\r\nconfig->reg_general);\r\nvalue |= LPSS_GENERAL_REG_RXTO_HOLDOFF_DISABLE;\r\n__lpss_ssp_write_priv(drv_data,\r\nconfig->reg_general, value);\r\n}\r\n}\r\n}\r\nstatic void lpss_ssp_select_cs(struct driver_data *drv_data,\r\nconst struct lpss_config *config)\r\n{\r\nu32 value, cs;\r\nif (!config->cs_sel_mask)\r\nreturn;\r\nvalue = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);\r\ncs = drv_data->master->cur_msg->spi->chip_select;\r\ncs <<= config->cs_sel_shift;\r\nif (cs != (value & config->cs_sel_mask)) {\r\nvalue &= ~config->cs_sel_mask;\r\nvalue |= cs;\r\n__lpss_ssp_write_priv(drv_data,\r\nconfig->reg_cs_ctrl, value);\r\nndelay(1000000000 /\r\n(drv_data->master->max_speed_hz / 2));\r\n}\r\n}\r\nstatic void lpss_ssp_cs_control(struct driver_data *drv_data, bool enable)\r\n{\r\nconst struct lpss_config *config;\r\nu32 value;\r\nconfig = lpss_get_config(drv_data);\r\nif (enable)\r\nlpss_ssp_select_cs(drv_data, config);\r\nvalue = __lpss_ssp_read_priv(drv_data, config->reg_cs_ctrl);\r\nif (enable)\r\nvalue &= ~LPSS_CS_CONTROL_CS_HIGH;\r\nelse\r\nvalue |= LPSS_CS_CONTROL_CS_HIGH;\r\n__lpss_ssp_write_priv(drv_data, config->reg_cs_ctrl, value);\r\n}\r\nstatic void cs_assert(struct driver_data *drv_data)\r\n{\r\nstruct chip_data *chip =\r\nspi_get_ctldata(drv_data->master->cur_msg->spi);\r\nif (drv_data->ssp_type == CE4100_SSP) {\r\npxa2xx_spi_write(drv_data, SSSR, chip->frm);\r\nreturn;\r\n}\r\nif (chip->cs_control) {\r\nchip->cs_control(PXA2XX_CS_ASSERT);\r\nreturn;\r\n}\r\nif (gpio_is_valid(chip->gpio_cs)) {\r\ngpio_set_value(chip->gpio_cs, chip->gpio_cs_inverted);\r\nreturn;\r\n}\r\nif (is_lpss_ssp(drv_data))\r\nlpss_ssp_cs_control(drv_data, true);\r\n}\r\nstatic void cs_deassert(struct driver_data *drv_data)\r\n{\r\nstruct chip_data *chip =\r\nspi_get_ctldata(drv_data->master->cur_msg->spi);\r\nif (drv_data->ssp_type == CE4100_SSP)\r\nreturn;\r\nif (chip->cs_control) {\r\nchip->cs_control(PXA2XX_CS_DEASSERT);\r\nreturn;\r\n}\r\nif (gpio_is_valid(chip->gpio_cs)) {\r\ngpio_set_value(chip->gpio_cs, !chip->gpio_cs_inverted);\r\nreturn;\r\n}\r\nif (is_lpss_ssp(drv_data))\r\nlpss_ssp_cs_control(drv_data, false);\r\n}\r\nint pxa2xx_spi_flush(struct driver_data *drv_data)\r\n{\r\nunsigned long limit = loops_per_jiffy << 1;\r\ndo {\r\nwhile (pxa2xx_spi_read(drv_data, SSSR) & SSSR_RNE)\r\npxa2xx_spi_read(drv_data, SSDR);\r\n} while ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_BSY) && --limit);\r\nwrite_SSSR_CS(drv_data, SSSR_ROR);\r\nreturn limit;\r\n}\r\nstatic int null_writer(struct driver_data *drv_data)\r\n{\r\nu8 n_bytes = drv_data->n_bytes;\r\nif (pxa2xx_spi_txfifo_full(drv_data)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\npxa2xx_spi_write(drv_data, SSDR, 0);\r\ndrv_data->tx += n_bytes;\r\nreturn 1;\r\n}\r\nstatic int null_reader(struct driver_data *drv_data)\r\n{\r\nu8 n_bytes = drv_data->n_bytes;\r\nwhile ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\npxa2xx_spi_read(drv_data, SSDR);\r\ndrv_data->rx += n_bytes;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic int u8_writer(struct driver_data *drv_data)\r\n{\r\nif (pxa2xx_spi_txfifo_full(drv_data)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\npxa2xx_spi_write(drv_data, SSDR, *(u8 *)(drv_data->tx));\r\n++drv_data->tx;\r\nreturn 1;\r\n}\r\nstatic int u8_reader(struct driver_data *drv_data)\r\n{\r\nwhile ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\n*(u8 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);\r\n++drv_data->rx;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic int u16_writer(struct driver_data *drv_data)\r\n{\r\nif (pxa2xx_spi_txfifo_full(drv_data)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\npxa2xx_spi_write(drv_data, SSDR, *(u16 *)(drv_data->tx));\r\ndrv_data->tx += 2;\r\nreturn 1;\r\n}\r\nstatic int u16_reader(struct driver_data *drv_data)\r\n{\r\nwhile ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\n*(u16 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);\r\ndrv_data->rx += 2;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nstatic int u32_writer(struct driver_data *drv_data)\r\n{\r\nif (pxa2xx_spi_txfifo_full(drv_data)\r\n|| (drv_data->tx == drv_data->tx_end))\r\nreturn 0;\r\npxa2xx_spi_write(drv_data, SSDR, *(u32 *)(drv_data->tx));\r\ndrv_data->tx += 4;\r\nreturn 1;\r\n}\r\nstatic int u32_reader(struct driver_data *drv_data)\r\n{\r\nwhile ((pxa2xx_spi_read(drv_data, SSSR) & SSSR_RNE)\r\n&& (drv_data->rx < drv_data->rx_end)) {\r\n*(u32 *)(drv_data->rx) = pxa2xx_spi_read(drv_data, SSDR);\r\ndrv_data->rx += 4;\r\n}\r\nreturn drv_data->rx == drv_data->rx_end;\r\n}\r\nvoid *pxa2xx_spi_next_transfer(struct driver_data *drv_data)\r\n{\r\nstruct spi_message *msg = drv_data->master->cur_msg;\r\nstruct spi_transfer *trans = drv_data->cur_transfer;\r\nif (trans->transfer_list.next != &msg->transfers) {\r\ndrv_data->cur_transfer =\r\nlist_entry(trans->transfer_list.next,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nreturn RUNNING_STATE;\r\n} else\r\nreturn DONE_STATE;\r\n}\r\nstatic void giveback(struct driver_data *drv_data)\r\n{\r\nstruct spi_transfer* last_transfer;\r\nstruct spi_message *msg;\r\nunsigned long timeout;\r\nmsg = drv_data->master->cur_msg;\r\ndrv_data->cur_transfer = NULL;\r\nlast_transfer = list_last_entry(&msg->transfers, struct spi_transfer,\r\ntransfer_list);\r\nif (last_transfer->delay_usecs)\r\nudelay(last_transfer->delay_usecs);\r\ntimeout = jiffies + msecs_to_jiffies(10);\r\nwhile (pxa2xx_spi_read(drv_data, SSSR) & SSSR_BSY &&\r\n!time_after(jiffies, timeout))\r\ncpu_relax();\r\nif (!last_transfer->cs_change)\r\ncs_deassert(drv_data);\r\nelse {\r\nstruct spi_message *next_msg;\r\nnext_msg = spi_get_next_queued_message(drv_data->master);\r\nif ((next_msg && next_msg->spi != msg->spi) ||\r\nmsg->state == ERROR_STATE)\r\ncs_deassert(drv_data);\r\n}\r\nspi_finalize_current_message(drv_data->master);\r\n}\r\nstatic void reset_sccr1(struct driver_data *drv_data)\r\n{\r\nstruct chip_data *chip =\r\nspi_get_ctldata(drv_data->master->cur_msg->spi);\r\nu32 sccr1_reg;\r\nsccr1_reg = pxa2xx_spi_read(drv_data, SSCR1) & ~drv_data->int_cr1;\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nsccr1_reg &= ~QUARK_X1000_SSCR1_RFT;\r\nbreak;\r\ncase CE4100_SSP:\r\nsccr1_reg &= ~CE4100_SSCR1_RFT;\r\nbreak;\r\ndefault:\r\nsccr1_reg &= ~SSCR1_RFT;\r\nbreak;\r\n}\r\nsccr1_reg |= chip->threshold;\r\npxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);\r\n}\r\nstatic void int_error_stop(struct driver_data *drv_data, const char* msg)\r\n{\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nreset_sccr1(drv_data);\r\nif (!pxa25x_ssp_comp(drv_data))\r\npxa2xx_spi_write(drv_data, SSTO, 0);\r\npxa2xx_spi_flush(drv_data);\r\npxa2xx_spi_write(drv_data, SSCR0,\r\npxa2xx_spi_read(drv_data, SSCR0) & ~SSCR0_SSE);\r\ndev_err(&drv_data->pdev->dev, "%s\n", msg);\r\ndrv_data->master->cur_msg->state = ERROR_STATE;\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic void int_transfer_complete(struct driver_data *drv_data)\r\n{\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\nreset_sccr1(drv_data);\r\nif (!pxa25x_ssp_comp(drv_data))\r\npxa2xx_spi_write(drv_data, SSTO, 0);\r\ndrv_data->master->cur_msg->actual_length += drv_data->len -\r\n(drv_data->rx_end - drv_data->rx);\r\ndrv_data->master->cur_msg->state = pxa2xx_spi_next_transfer(drv_data);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\n}\r\nstatic irqreturn_t interrupt_transfer(struct driver_data *drv_data)\r\n{\r\nu32 irq_mask = (pxa2xx_spi_read(drv_data, SSCR1) & SSCR1_TIE) ?\r\ndrv_data->mask_sr : drv_data->mask_sr & ~SSSR_TFS;\r\nu32 irq_status = pxa2xx_spi_read(drv_data, SSSR) & irq_mask;\r\nif (irq_status & SSSR_ROR) {\r\nint_error_stop(drv_data, "interrupt_transfer: fifo overrun");\r\nreturn IRQ_HANDLED;\r\n}\r\nif (irq_status & SSSR_TINT) {\r\npxa2xx_spi_write(drv_data, SSSR, SSSR_TINT);\r\nif (drv_data->read(drv_data)) {\r\nint_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\n}\r\ndo {\r\nif (drv_data->read(drv_data)) {\r\nint_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\n} while (drv_data->write(drv_data));\r\nif (drv_data->read(drv_data)) {\r\nint_transfer_complete(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nif (drv_data->tx == drv_data->tx_end) {\r\nu32 bytes_left;\r\nu32 sccr1_reg;\r\nsccr1_reg = pxa2xx_spi_read(drv_data, SSCR1);\r\nsccr1_reg &= ~SSCR1_TIE;\r\nif (pxa25x_ssp_comp(drv_data)) {\r\nu32 rx_thre;\r\npxa2xx_spi_clear_rx_thre(drv_data, &sccr1_reg);\r\nbytes_left = drv_data->rx_end - drv_data->rx;\r\nswitch (drv_data->n_bytes) {\r\ncase 4:\r\nbytes_left >>= 1;\r\ncase 2:\r\nbytes_left >>= 1;\r\n}\r\nrx_thre = pxa2xx_spi_get_rx_default_thre(drv_data);\r\nif (rx_thre > bytes_left)\r\nrx_thre = bytes_left;\r\npxa2xx_spi_set_rx_thre(drv_data, &sccr1_reg, rx_thre);\r\n}\r\npxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);\r\n}\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void handle_bad_msg(struct driver_data *drv_data)\r\n{\r\npxa2xx_spi_write(drv_data, SSCR0,\r\npxa2xx_spi_read(drv_data, SSCR0) & ~SSCR0_SSE);\r\npxa2xx_spi_write(drv_data, SSCR1,\r\npxa2xx_spi_read(drv_data, SSCR1) & ~drv_data->int_cr1);\r\nif (!pxa25x_ssp_comp(drv_data))\r\npxa2xx_spi_write(drv_data, SSTO, 0);\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\ndev_err(&drv_data->pdev->dev,\r\n"bad message state in interrupt handler\n");\r\n}\r\nstatic irqreturn_t ssp_int(int irq, void *dev_id)\r\n{\r\nstruct driver_data *drv_data = dev_id;\r\nu32 sccr1_reg;\r\nu32 mask = drv_data->mask_sr;\r\nu32 status;\r\nif (pm_runtime_suspended(&drv_data->pdev->dev))\r\nreturn IRQ_NONE;\r\nstatus = pxa2xx_spi_read(drv_data, SSSR);\r\nif (status == ~0)\r\nreturn IRQ_NONE;\r\nsccr1_reg = pxa2xx_spi_read(drv_data, SSCR1);\r\nif (!(sccr1_reg & SSCR1_TIE))\r\nmask &= ~SSSR_TFS;\r\nif (!(sccr1_reg & SSCR1_TINTE))\r\nmask &= ~SSSR_TINT;\r\nif (!(status & mask))\r\nreturn IRQ_NONE;\r\npxa2xx_spi_write(drv_data, SSCR1, sccr1_reg & ~drv_data->int_cr1);\r\npxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);\r\nif (!drv_data->master->cur_msg) {\r\nhandle_bad_msg(drv_data);\r\nreturn IRQ_HANDLED;\r\n}\r\nreturn drv_data->transfer_handler(drv_data);\r\n}\r\nstatic unsigned int quark_x1000_get_clk_div(int rate, u32 *dds)\r\n{\r\nunsigned long xtal = 200000000;\r\nunsigned long fref = xtal / 2;\r\nunsigned long fref1 = fref / 2;\r\nunsigned long fref2 = fref * 2 / 5;\r\nunsigned long scale;\r\nunsigned long q, q1, q2;\r\nlong r, r1, r2;\r\nu32 mul;\r\nmul = (1 << 24) >> 1;\r\nq1 = DIV_ROUND_UP(fref1, rate);\r\nif (q1 > 256) {\r\nscale = fls_long(q1 - 1);\r\nif (scale > 9) {\r\nq1 >>= scale - 9;\r\nmul >>= scale - 9;\r\n}\r\nq1 += q1 & 1;\r\n}\r\nscale = __ffs(q1);\r\nq1 >>= scale;\r\nmul >>= scale;\r\nr1 = abs(fref1 / (1 << (24 - fls_long(mul))) / q1 - rate);\r\nq2 = DIV_ROUND_UP(fref2, rate);\r\nr2 = abs(fref2 / q2 - rate);\r\nif (r2 >= r1 || q2 > 256) {\r\nr = r1;\r\nq = q1;\r\n} else {\r\nr = r2;\r\nq = q2;\r\nmul = (1 << 24) * 2 / 5;\r\n}\r\nif (fref / rate >= 80) {\r\nu64 fssp;\r\nu32 m;\r\nq1 = DIV_ROUND_UP(fref, rate);\r\nm = (1 << 24) / q1;\r\nfssp = (u64)fref * m;\r\ndo_div(fssp, 1 << 24);\r\nr1 = abs(fssp - rate);\r\nif (r1 < r) {\r\nq = 1;\r\nmul = m;\r\n}\r\n}\r\n*dds = mul;\r\nreturn q - 1;\r\n}\r\nstatic unsigned int ssp_get_clk_div(struct driver_data *drv_data, int rate)\r\n{\r\nunsigned long ssp_clk = drv_data->master->max_speed_hz;\r\nconst struct ssp_device *ssp = drv_data->ssp;\r\nrate = min_t(int, ssp_clk, rate);\r\nif (ssp->type == PXA25x_SSP || ssp->type == CE4100_SSP)\r\nreturn (ssp_clk / (2 * rate) - 1) & 0xff;\r\nelse\r\nreturn (ssp_clk / rate - 1) & 0xfff;\r\n}\r\nstatic unsigned int pxa2xx_ssp_get_clk_div(struct driver_data *drv_data,\r\nint rate)\r\n{\r\nstruct chip_data *chip =\r\nspi_get_ctldata(drv_data->master->cur_msg->spi);\r\nunsigned int clk_div;\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nclk_div = quark_x1000_get_clk_div(rate, &chip->dds_rate);\r\nbreak;\r\ndefault:\r\nclk_div = ssp_get_clk_div(drv_data, rate);\r\nbreak;\r\n}\r\nreturn clk_div << 8;\r\n}\r\nstatic bool pxa2xx_spi_can_dma(struct spi_master *master,\r\nstruct spi_device *spi,\r\nstruct spi_transfer *xfer)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nreturn chip->enable_dma &&\r\nxfer->len <= MAX_DMA_LEN &&\r\nxfer->len >= chip->dma_burst_size;\r\n}\r\nstatic void pump_transfers(unsigned long data)\r\n{\r\nstruct driver_data *drv_data = (struct driver_data *)data;\r\nstruct spi_master *master = drv_data->master;\r\nstruct spi_message *message = master->cur_msg;\r\nstruct chip_data *chip = spi_get_ctldata(message->spi);\r\nu32 dma_thresh = chip->dma_threshold;\r\nu32 dma_burst = chip->dma_burst_size;\r\nu32 change_mask = pxa2xx_spi_get_ssrc1_change_mask(drv_data);\r\nstruct spi_transfer *transfer;\r\nstruct spi_transfer *previous;\r\nu32 clk_div;\r\nu8 bits;\r\nu32 speed;\r\nu32 cr0;\r\nu32 cr1;\r\nint err;\r\nint dma_mapped;\r\ntransfer = drv_data->cur_transfer;\r\nif (message->state == ERROR_STATE) {\r\nmessage->status = -EIO;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\nif (message->state == DONE_STATE) {\r\nmessage->status = 0;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\nif (message->state == RUNNING_STATE) {\r\nprevious = list_entry(transfer->transfer_list.prev,\r\nstruct spi_transfer,\r\ntransfer_list);\r\nif (previous->delay_usecs)\r\nudelay(previous->delay_usecs);\r\nif (previous->cs_change)\r\ncs_deassert(drv_data);\r\n}\r\nif (transfer->len > MAX_DMA_LEN && chip->enable_dma) {\r\nif (message->is_dma_mapped\r\n|| transfer->rx_dma || transfer->tx_dma) {\r\ndev_err(&drv_data->pdev->dev,\r\n"pump_transfers: mapped transfer length of "\r\n"%u is greater than %d\n",\r\ntransfer->len, MAX_DMA_LEN);\r\nmessage->status = -EINVAL;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\ndev_warn_ratelimited(&message->spi->dev,\r\n"pump_transfers: DMA disabled for transfer length %ld "\r\n"greater than %d\n",\r\n(long)drv_data->len, MAX_DMA_LEN);\r\n}\r\nif (pxa2xx_spi_flush(drv_data) == 0) {\r\ndev_err(&drv_data->pdev->dev, "pump_transfers: flush failed\n");\r\nmessage->status = -EIO;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\ndrv_data->n_bytes = chip->n_bytes;\r\ndrv_data->tx = (void *)transfer->tx_buf;\r\ndrv_data->tx_end = drv_data->tx + transfer->len;\r\ndrv_data->rx = transfer->rx_buf;\r\ndrv_data->rx_end = drv_data->rx + transfer->len;\r\ndrv_data->len = transfer->len;\r\ndrv_data->write = drv_data->tx ? chip->write : null_writer;\r\ndrv_data->read = drv_data->rx ? chip->read : null_reader;\r\nbits = transfer->bits_per_word;\r\nspeed = transfer->speed_hz;\r\nclk_div = pxa2xx_ssp_get_clk_div(drv_data, speed);\r\nif (bits <= 8) {\r\ndrv_data->n_bytes = 1;\r\ndrv_data->read = drv_data->read != null_reader ?\r\nu8_reader : null_reader;\r\ndrv_data->write = drv_data->write != null_writer ?\r\nu8_writer : null_writer;\r\n} else if (bits <= 16) {\r\ndrv_data->n_bytes = 2;\r\ndrv_data->read = drv_data->read != null_reader ?\r\nu16_reader : null_reader;\r\ndrv_data->write = drv_data->write != null_writer ?\r\nu16_writer : null_writer;\r\n} else if (bits <= 32) {\r\ndrv_data->n_bytes = 4;\r\ndrv_data->read = drv_data->read != null_reader ?\r\nu32_reader : null_reader;\r\ndrv_data->write = drv_data->write != null_writer ?\r\nu32_writer : null_writer;\r\n}\r\nif (chip->enable_dma) {\r\nif (pxa2xx_spi_set_dma_burst_and_threshold(chip,\r\nmessage->spi,\r\nbits, &dma_burst,\r\n&dma_thresh))\r\ndev_warn_ratelimited(&message->spi->dev,\r\n"pump_transfers: DMA burst size reduced to match bits_per_word\n");\r\n}\r\nmessage->state = RUNNING_STATE;\r\ndma_mapped = master->can_dma &&\r\nmaster->can_dma(master, message->spi, transfer) &&\r\nmaster->cur_msg_mapped;\r\nif (dma_mapped) {\r\ndrv_data->transfer_handler = pxa2xx_spi_dma_transfer;\r\nerr = pxa2xx_spi_dma_prepare(drv_data, dma_burst);\r\nif (err) {\r\nmessage->status = err;\r\ngiveback(drv_data);\r\nreturn;\r\n}\r\ncr1 = chip->cr1 | dma_thresh | drv_data->dma_cr1;\r\npxa2xx_spi_write(drv_data, SSSR, drv_data->clear_sr);\r\npxa2xx_spi_dma_start(drv_data);\r\n} else {\r\ndrv_data->transfer_handler = interrupt_transfer;\r\ncr1 = chip->cr1 | chip->threshold | drv_data->int_cr1;\r\nwrite_SSSR_CS(drv_data, drv_data->clear_sr);\r\n}\r\ncr0 = pxa2xx_configure_sscr0(drv_data, clk_div, bits);\r\nif (!pxa25x_ssp_comp(drv_data))\r\ndev_dbg(&message->spi->dev, "%u Hz actual, %s\n",\r\nmaster->max_speed_hz\r\n/ (1 + ((cr0 & SSCR0_SCR(0xfff)) >> 8)),\r\ndma_mapped ? "DMA" : "PIO");\r\nelse\r\ndev_dbg(&message->spi->dev, "%u Hz actual, %s\n",\r\nmaster->max_speed_hz / 2\r\n/ (1 + ((cr0 & SSCR0_SCR(0x0ff)) >> 8)),\r\ndma_mapped ? "DMA" : "PIO");\r\nif (is_lpss_ssp(drv_data)) {\r\nif ((pxa2xx_spi_read(drv_data, SSIRF) & 0xff)\r\n!= chip->lpss_rx_threshold)\r\npxa2xx_spi_write(drv_data, SSIRF,\r\nchip->lpss_rx_threshold);\r\nif ((pxa2xx_spi_read(drv_data, SSITF) & 0xffff)\r\n!= chip->lpss_tx_threshold)\r\npxa2xx_spi_write(drv_data, SSITF,\r\nchip->lpss_tx_threshold);\r\n}\r\nif (is_quark_x1000_ssp(drv_data) &&\r\n(pxa2xx_spi_read(drv_data, DDS_RATE) != chip->dds_rate))\r\npxa2xx_spi_write(drv_data, DDS_RATE, chip->dds_rate);\r\nif ((pxa2xx_spi_read(drv_data, SSCR0) != cr0)\r\n|| (pxa2xx_spi_read(drv_data, SSCR1) & change_mask)\r\n!= (cr1 & change_mask)) {\r\npxa2xx_spi_write(drv_data, SSCR0, cr0 & ~SSCR0_SSE);\r\nif (!pxa25x_ssp_comp(drv_data))\r\npxa2xx_spi_write(drv_data, SSTO, chip->timeout);\r\npxa2xx_spi_write(drv_data, SSCR1, cr1 & change_mask);\r\npxa2xx_spi_write(drv_data, SSCR0, cr0);\r\n} else {\r\nif (!pxa25x_ssp_comp(drv_data))\r\npxa2xx_spi_write(drv_data, SSTO, chip->timeout);\r\n}\r\ncs_assert(drv_data);\r\npxa2xx_spi_write(drv_data, SSCR1, cr1);\r\n}\r\nstatic int pxa2xx_spi_transfer_one_message(struct spi_master *master,\r\nstruct spi_message *msg)\r\n{\r\nstruct driver_data *drv_data = spi_master_get_devdata(master);\r\nmsg->state = START_STATE;\r\ndrv_data->cur_transfer = list_entry(msg->transfers.next,\r\nstruct spi_transfer,\r\ntransfer_list);\r\ntasklet_schedule(&drv_data->pump_transfers);\r\nreturn 0;\r\n}\r\nstatic int pxa2xx_spi_unprepare_transfer(struct spi_master *master)\r\n{\r\nstruct driver_data *drv_data = spi_master_get_devdata(master);\r\npxa2xx_spi_write(drv_data, SSCR0,\r\npxa2xx_spi_read(drv_data, SSCR0) & ~SSCR0_SSE);\r\nreturn 0;\r\n}\r\nstatic int setup_cs(struct spi_device *spi, struct chip_data *chip,\r\nstruct pxa2xx_spi_chip *chip_info)\r\n{\r\nstruct driver_data *drv_data = spi_master_get_devdata(spi->master);\r\nint err = 0;\r\nif (chip == NULL)\r\nreturn 0;\r\nif (drv_data->cs_gpiods) {\r\nstruct gpio_desc *gpiod;\r\ngpiod = drv_data->cs_gpiods[spi->chip_select];\r\nif (gpiod) {\r\nchip->gpio_cs = desc_to_gpio(gpiod);\r\nchip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;\r\ngpiod_set_value(gpiod, chip->gpio_cs_inverted);\r\n}\r\nreturn 0;\r\n}\r\nif (chip_info == NULL)\r\nreturn 0;\r\nif (gpio_is_valid(chip->gpio_cs))\r\ngpio_free(chip->gpio_cs);\r\nif (chip_info->cs_control) {\r\nchip->cs_control = chip_info->cs_control;\r\nreturn 0;\r\n}\r\nif (gpio_is_valid(chip_info->gpio_cs)) {\r\nerr = gpio_request(chip_info->gpio_cs, "SPI_CS");\r\nif (err) {\r\ndev_err(&spi->dev, "failed to request chip select GPIO%d\n",\r\nchip_info->gpio_cs);\r\nreturn err;\r\n}\r\nchip->gpio_cs = chip_info->gpio_cs;\r\nchip->gpio_cs_inverted = spi->mode & SPI_CS_HIGH;\r\nerr = gpio_direction_output(chip->gpio_cs,\r\n!chip->gpio_cs_inverted);\r\n}\r\nreturn err;\r\n}\r\nstatic int setup(struct spi_device *spi)\r\n{\r\nstruct pxa2xx_spi_chip *chip_info;\r\nstruct chip_data *chip;\r\nconst struct lpss_config *config;\r\nstruct driver_data *drv_data = spi_master_get_devdata(spi->master);\r\nuint tx_thres, tx_hi_thres, rx_thres;\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\ntx_thres = TX_THRESH_QUARK_X1000_DFLT;\r\ntx_hi_thres = 0;\r\nrx_thres = RX_THRESH_QUARK_X1000_DFLT;\r\nbreak;\r\ncase CE4100_SSP:\r\ntx_thres = TX_THRESH_CE4100_DFLT;\r\ntx_hi_thres = 0;\r\nrx_thres = RX_THRESH_CE4100_DFLT;\r\nbreak;\r\ncase LPSS_LPT_SSP:\r\ncase LPSS_BYT_SSP:\r\ncase LPSS_BSW_SSP:\r\ncase LPSS_SPT_SSP:\r\ncase LPSS_BXT_SSP:\r\nconfig = lpss_get_config(drv_data);\r\ntx_thres = config->tx_threshold_lo;\r\ntx_hi_thres = config->tx_threshold_hi;\r\nrx_thres = config->rx_threshold;\r\nbreak;\r\ndefault:\r\ntx_thres = TX_THRESH_DFLT;\r\ntx_hi_thres = 0;\r\nrx_thres = RX_THRESH_DFLT;\r\nbreak;\r\n}\r\nchip = spi_get_ctldata(spi);\r\nif (!chip) {\r\nchip = kzalloc(sizeof(struct chip_data), GFP_KERNEL);\r\nif (!chip)\r\nreturn -ENOMEM;\r\nif (drv_data->ssp_type == CE4100_SSP) {\r\nif (spi->chip_select > 4) {\r\ndev_err(&spi->dev,\r\n"failed setup: cs number must not be > 4.\n");\r\nkfree(chip);\r\nreturn -EINVAL;\r\n}\r\nchip->frm = spi->chip_select;\r\n} else\r\nchip->gpio_cs = -1;\r\nchip->enable_dma = drv_data->master_info->enable_dma;\r\nchip->timeout = TIMOUT_DFLT;\r\n}\r\nchip_info = spi->controller_data;\r\nchip->cr1 = 0;\r\nif (chip_info) {\r\nif (chip_info->timeout)\r\nchip->timeout = chip_info->timeout;\r\nif (chip_info->tx_threshold)\r\ntx_thres = chip_info->tx_threshold;\r\nif (chip_info->tx_hi_threshold)\r\ntx_hi_thres = chip_info->tx_hi_threshold;\r\nif (chip_info->rx_threshold)\r\nrx_thres = chip_info->rx_threshold;\r\nchip->dma_threshold = 0;\r\nif (chip_info->enable_loopback)\r\nchip->cr1 = SSCR1_LBM;\r\n}\r\nchip->lpss_rx_threshold = SSIRF_RxThresh(rx_thres);\r\nchip->lpss_tx_threshold = SSITF_TxLoThresh(tx_thres)\r\n| SSITF_TxHiThresh(tx_hi_thres);\r\nif (chip->enable_dma) {\r\nif (pxa2xx_spi_set_dma_burst_and_threshold(chip, spi,\r\nspi->bits_per_word,\r\n&chip->dma_burst_size,\r\n&chip->dma_threshold)) {\r\ndev_warn(&spi->dev,\r\n"in setup: DMA burst size reduced to match bits_per_word\n");\r\n}\r\n}\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nchip->threshold = (QUARK_X1000_SSCR1_RxTresh(rx_thres)\r\n& QUARK_X1000_SSCR1_RFT)\r\n| (QUARK_X1000_SSCR1_TxTresh(tx_thres)\r\n& QUARK_X1000_SSCR1_TFT);\r\nbreak;\r\ncase CE4100_SSP:\r\nchip->threshold = (CE4100_SSCR1_RxTresh(rx_thres) & CE4100_SSCR1_RFT) |\r\n(CE4100_SSCR1_TxTresh(tx_thres) & CE4100_SSCR1_TFT);\r\nbreak;\r\ndefault:\r\nchip->threshold = (SSCR1_RxTresh(rx_thres) & SSCR1_RFT) |\r\n(SSCR1_TxTresh(tx_thres) & SSCR1_TFT);\r\nbreak;\r\n}\r\nchip->cr1 &= ~(SSCR1_SPO | SSCR1_SPH);\r\nchip->cr1 |= (((spi->mode & SPI_CPHA) != 0) ? SSCR1_SPH : 0)\r\n| (((spi->mode & SPI_CPOL) != 0) ? SSCR1_SPO : 0);\r\nif (spi->mode & SPI_LOOP)\r\nchip->cr1 |= SSCR1_LBM;\r\nif (spi->bits_per_word <= 8) {\r\nchip->n_bytes = 1;\r\nchip->read = u8_reader;\r\nchip->write = u8_writer;\r\n} else if (spi->bits_per_word <= 16) {\r\nchip->n_bytes = 2;\r\nchip->read = u16_reader;\r\nchip->write = u16_writer;\r\n} else if (spi->bits_per_word <= 32) {\r\nchip->n_bytes = 4;\r\nchip->read = u32_reader;\r\nchip->write = u32_writer;\r\n}\r\nspi_set_ctldata(spi, chip);\r\nif (drv_data->ssp_type == CE4100_SSP)\r\nreturn 0;\r\nreturn setup_cs(spi, chip, chip_info);\r\n}\r\nstatic void cleanup(struct spi_device *spi)\r\n{\r\nstruct chip_data *chip = spi_get_ctldata(spi);\r\nstruct driver_data *drv_data = spi_master_get_devdata(spi->master);\r\nif (!chip)\r\nreturn;\r\nif (drv_data->ssp_type != CE4100_SSP && !drv_data->cs_gpiods &&\r\ngpio_is_valid(chip->gpio_cs))\r\ngpio_free(chip->gpio_cs);\r\nkfree(chip);\r\n}\r\nstatic int pxa2xx_spi_get_port_id(struct acpi_device *adev)\r\n{\r\nunsigned int devid;\r\nint port_id = -1;\r\nif (adev && adev->pnp.unique_id &&\r\n!kstrtouint(adev->pnp.unique_id, 0, &devid))\r\nport_id = devid;\r\nreturn port_id;\r\n}\r\nstatic int pxa2xx_spi_get_port_id(struct acpi_device *adev)\r\n{\r\nreturn -1;\r\n}\r\nstatic bool pxa2xx_spi_idma_filter(struct dma_chan *chan, void *param)\r\n{\r\nstruct device *dev = param;\r\nif (dev != chan->device->dev->parent)\r\nreturn false;\r\nreturn true;\r\n}\r\nstatic struct pxa2xx_spi_master *\r\npxa2xx_spi_init_pdata(struct platform_device *pdev)\r\n{\r\nstruct pxa2xx_spi_master *pdata;\r\nstruct acpi_device *adev;\r\nstruct ssp_device *ssp;\r\nstruct resource *res;\r\nconst struct acpi_device_id *adev_id = NULL;\r\nconst struct pci_device_id *pcidev_id = NULL;\r\nint type;\r\nadev = ACPI_COMPANION(&pdev->dev);\r\nif (dev_is_pci(pdev->dev.parent))\r\npcidev_id = pci_match_id(pxa2xx_spi_pci_compound_match,\r\nto_pci_dev(pdev->dev.parent));\r\nelse if (adev)\r\nadev_id = acpi_match_device(pdev->dev.driver->acpi_match_table,\r\n&pdev->dev);\r\nelse\r\nreturn NULL;\r\nif (adev_id)\r\ntype = (int)adev_id->driver_data;\r\nelse if (pcidev_id)\r\ntype = (int)pcidev_id->driver_data;\r\nelse\r\nreturn NULL;\r\npdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\r\nif (!pdata)\r\nreturn NULL;\r\nres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\r\nif (!res)\r\nreturn NULL;\r\nssp = &pdata->ssp;\r\nssp->phys_base = res->start;\r\nssp->mmio_base = devm_ioremap_resource(&pdev->dev, res);\r\nif (IS_ERR(ssp->mmio_base))\r\nreturn NULL;\r\nif (pcidev_id) {\r\npdata->tx_param = pdev->dev.parent;\r\npdata->rx_param = pdev->dev.parent;\r\npdata->dma_filter = pxa2xx_spi_idma_filter;\r\n}\r\nssp->clk = devm_clk_get(&pdev->dev, NULL);\r\nssp->irq = platform_get_irq(pdev, 0);\r\nssp->type = type;\r\nssp->pdev = pdev;\r\nssp->port_id = pxa2xx_spi_get_port_id(adev);\r\npdata->num_chipselect = 1;\r\npdata->enable_dma = true;\r\nreturn pdata;\r\n}\r\nstatic inline struct pxa2xx_spi_master *\r\npxa2xx_spi_init_pdata(struct platform_device *pdev)\r\n{\r\nreturn NULL;\r\n}\r\nstatic int pxa2xx_spi_fw_translate_cs(struct spi_master *master, unsigned cs)\r\n{\r\nstruct driver_data *drv_data = spi_master_get_devdata(master);\r\nif (has_acpi_companion(&drv_data->pdev->dev)) {\r\nswitch (drv_data->ssp_type) {\r\ncase LPSS_BYT_SSP:\r\ncase LPSS_BSW_SSP:\r\nreturn cs - 1;\r\ndefault:\r\nbreak;\r\n}\r\n}\r\nreturn cs;\r\n}\r\nstatic int pxa2xx_spi_probe(struct platform_device *pdev)\r\n{\r\nstruct device *dev = &pdev->dev;\r\nstruct pxa2xx_spi_master *platform_info;\r\nstruct spi_master *master;\r\nstruct driver_data *drv_data;\r\nstruct ssp_device *ssp;\r\nconst struct lpss_config *config;\r\nint status, count;\r\nu32 tmp;\r\nplatform_info = dev_get_platdata(dev);\r\nif (!platform_info) {\r\nplatform_info = pxa2xx_spi_init_pdata(pdev);\r\nif (!platform_info) {\r\ndev_err(&pdev->dev, "missing platform data\n");\r\nreturn -ENODEV;\r\n}\r\n}\r\nssp = pxa_ssp_request(pdev->id, pdev->name);\r\nif (!ssp)\r\nssp = &platform_info->ssp;\r\nif (!ssp->mmio_base) {\r\ndev_err(&pdev->dev, "failed to get ssp\n");\r\nreturn -ENODEV;\r\n}\r\nmaster = spi_alloc_master(dev, sizeof(struct driver_data));\r\nif (!master) {\r\ndev_err(&pdev->dev, "cannot alloc spi_master\n");\r\npxa_ssp_free(ssp);\r\nreturn -ENOMEM;\r\n}\r\ndrv_data = spi_master_get_devdata(master);\r\ndrv_data->master = master;\r\ndrv_data->master_info = platform_info;\r\ndrv_data->pdev = pdev;\r\ndrv_data->ssp = ssp;\r\nmaster->dev.of_node = pdev->dev.of_node;\r\nmaster->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_LOOP;\r\nmaster->bus_num = ssp->port_id;\r\nmaster->dma_alignment = DMA_ALIGNMENT;\r\nmaster->cleanup = cleanup;\r\nmaster->setup = setup;\r\nmaster->transfer_one_message = pxa2xx_spi_transfer_one_message;\r\nmaster->unprepare_transfer_hardware = pxa2xx_spi_unprepare_transfer;\r\nmaster->fw_translate_cs = pxa2xx_spi_fw_translate_cs;\r\nmaster->auto_runtime_pm = true;\r\nmaster->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;\r\ndrv_data->ssp_type = ssp->type;\r\ndrv_data->ioaddr = ssp->mmio_base;\r\ndrv_data->ssdr_physical = ssp->phys_base + SSDR;\r\nif (pxa25x_ssp_comp(drv_data)) {\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\r\nbreak;\r\ndefault:\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 16);\r\nbreak;\r\n}\r\ndrv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE;\r\ndrv_data->dma_cr1 = 0;\r\ndrv_data->clear_sr = SSSR_ROR;\r\ndrv_data->mask_sr = SSSR_RFS | SSSR_TFS | SSSR_ROR;\r\n} else {\r\nmaster->bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);\r\ndrv_data->int_cr1 = SSCR1_TIE | SSCR1_RIE | SSCR1_TINTE;\r\ndrv_data->dma_cr1 = DEFAULT_DMA_CR1;\r\ndrv_data->clear_sr = SSSR_ROR | SSSR_TINT;\r\ndrv_data->mask_sr = SSSR_TINT | SSSR_RFS | SSSR_TFS | SSSR_ROR;\r\n}\r\nstatus = request_irq(ssp->irq, ssp_int, IRQF_SHARED, dev_name(dev),\r\ndrv_data);\r\nif (status < 0) {\r\ndev_err(&pdev->dev, "cannot get IRQ %d\n", ssp->irq);\r\ngoto out_error_master_alloc;\r\n}\r\nif (platform_info->enable_dma) {\r\nstatus = pxa2xx_spi_dma_setup(drv_data);\r\nif (status) {\r\ndev_dbg(dev, "no DMA channels available, using PIO\n");\r\nplatform_info->enable_dma = false;\r\n} else {\r\nmaster->can_dma = pxa2xx_spi_can_dma;\r\n}\r\n}\r\nclk_prepare_enable(ssp->clk);\r\nmaster->max_speed_hz = clk_get_rate(ssp->clk);\r\npxa2xx_spi_write(drv_data, SSCR0, 0);\r\nswitch (drv_data->ssp_type) {\r\ncase QUARK_X1000_SSP:\r\ntmp = QUARK_X1000_SSCR1_RxTresh(RX_THRESH_QUARK_X1000_DFLT) |\r\nQUARK_X1000_SSCR1_TxTresh(TX_THRESH_QUARK_X1000_DFLT);\r\npxa2xx_spi_write(drv_data, SSCR1, tmp);\r\ntmp = QUARK_X1000_SSCR0_Motorola | QUARK_X1000_SSCR0_DataSize(8);\r\npxa2xx_spi_write(drv_data, SSCR0, tmp);\r\nbreak;\r\ncase CE4100_SSP:\r\ntmp = CE4100_SSCR1_RxTresh(RX_THRESH_CE4100_DFLT) |\r\nCE4100_SSCR1_TxTresh(TX_THRESH_CE4100_DFLT);\r\npxa2xx_spi_write(drv_data, SSCR1, tmp);\r\ntmp = SSCR0_SCR(2) | SSCR0_Motorola | SSCR0_DataSize(8);\r\npxa2xx_spi_write(drv_data, SSCR0, tmp);\r\nbreak;\r\ndefault:\r\ntmp = SSCR1_RxTresh(RX_THRESH_DFLT) |\r\nSSCR1_TxTresh(TX_THRESH_DFLT);\r\npxa2xx_spi_write(drv_data, SSCR1, tmp);\r\ntmp = SSCR0_SCR(2) | SSCR0_Motorola | SSCR0_DataSize(8);\r\npxa2xx_spi_write(drv_data, SSCR0, tmp);\r\nbreak;\r\n}\r\nif (!pxa25x_ssp_comp(drv_data))\r\npxa2xx_spi_write(drv_data, SSTO, 0);\r\nif (!is_quark_x1000_ssp(drv_data))\r\npxa2xx_spi_write(drv_data, SSPSP, 0);\r\nif (is_lpss_ssp(drv_data)) {\r\nlpss_ssp_setup(drv_data);\r\nconfig = lpss_get_config(drv_data);\r\nif (config->reg_capabilities >= 0) {\r\ntmp = __lpss_ssp_read_priv(drv_data,\r\nconfig->reg_capabilities);\r\ntmp &= LPSS_CAPS_CS_EN_MASK;\r\ntmp >>= LPSS_CAPS_CS_EN_SHIFT;\r\nplatform_info->num_chipselect = ffz(tmp);\r\n} else if (config->cs_num) {\r\nplatform_info->num_chipselect = config->cs_num;\r\n}\r\n}\r\nmaster->num_chipselect = platform_info->num_chipselect;\r\ncount = gpiod_count(&pdev->dev, "cs");\r\nif (count > 0) {\r\nint i;\r\nmaster->num_chipselect = max_t(int, count,\r\nmaster->num_chipselect);\r\ndrv_data->cs_gpiods = devm_kcalloc(&pdev->dev,\r\nmaster->num_chipselect, sizeof(struct gpio_desc *),\r\nGFP_KERNEL);\r\nif (!drv_data->cs_gpiods) {\r\nstatus = -ENOMEM;\r\ngoto out_error_clock_enabled;\r\n}\r\nfor (i = 0; i < master->num_chipselect; i++) {\r\nstruct gpio_desc *gpiod;\r\ngpiod = devm_gpiod_get_index(dev, "cs", i,\r\nGPIOD_OUT_HIGH);\r\nif (IS_ERR(gpiod)) {\r\nif (PTR_ERR(gpiod) == -ENOENT)\r\ncontinue;\r\nstatus = (int)PTR_ERR(gpiod);\r\ngoto out_error_clock_enabled;\r\n} else {\r\ndrv_data->cs_gpiods[i] = gpiod;\r\n}\r\n}\r\n}\r\ntasklet_init(&drv_data->pump_transfers, pump_transfers,\r\n(unsigned long)drv_data);\r\npm_runtime_set_autosuspend_delay(&pdev->dev, 50);\r\npm_runtime_use_autosuspend(&pdev->dev);\r\npm_runtime_set_active(&pdev->dev);\r\npm_runtime_enable(&pdev->dev);\r\nplatform_set_drvdata(pdev, drv_data);\r\nstatus = devm_spi_register_master(&pdev->dev, master);\r\nif (status != 0) {\r\ndev_err(&pdev->dev, "problem registering spi master\n");\r\ngoto out_error_clock_enabled;\r\n}\r\nreturn status;\r\nout_error_clock_enabled:\r\nclk_disable_unprepare(ssp->clk);\r\npxa2xx_spi_dma_release(drv_data);\r\nfree_irq(ssp->irq, drv_data);\r\nout_error_master_alloc:\r\nspi_master_put(master);\r\npxa_ssp_free(ssp);\r\nreturn status;\r\n}\r\nstatic int pxa2xx_spi_remove(struct platform_device *pdev)\r\n{\r\nstruct driver_data *drv_data = platform_get_drvdata(pdev);\r\nstruct ssp_device *ssp;\r\nif (!drv_data)\r\nreturn 0;\r\nssp = drv_data->ssp;\r\npm_runtime_get_sync(&pdev->dev);\r\npxa2xx_spi_write(drv_data, SSCR0, 0);\r\nclk_disable_unprepare(ssp->clk);\r\nif (drv_data->master_info->enable_dma)\r\npxa2xx_spi_dma_release(drv_data);\r\npm_runtime_put_noidle(&pdev->dev);\r\npm_runtime_disable(&pdev->dev);\r\nfree_irq(ssp->irq, drv_data);\r\npxa_ssp_free(ssp);\r\nreturn 0;\r\n}\r\nstatic void pxa2xx_spi_shutdown(struct platform_device *pdev)\r\n{\r\nint status = 0;\r\nif ((status = pxa2xx_spi_remove(pdev)) != 0)\r\ndev_err(&pdev->dev, "shutdown failed with %d\n", status);\r\n}\r\nstatic int pxa2xx_spi_suspend(struct device *dev)\r\n{\r\nstruct driver_data *drv_data = dev_get_drvdata(dev);\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nint status;\r\nstatus = spi_master_suspend(drv_data->master);\r\nif (status != 0)\r\nreturn status;\r\npxa2xx_spi_write(drv_data, SSCR0, 0);\r\nif (!pm_runtime_suspended(dev))\r\nclk_disable_unprepare(ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa2xx_spi_resume(struct device *dev)\r\n{\r\nstruct driver_data *drv_data = dev_get_drvdata(dev);\r\nstruct ssp_device *ssp = drv_data->ssp;\r\nint status;\r\nif (!pm_runtime_suspended(dev))\r\nclk_prepare_enable(ssp->clk);\r\nif (is_lpss_ssp(drv_data))\r\nlpss_ssp_setup(drv_data);\r\nstatus = spi_master_resume(drv_data->master);\r\nif (status != 0) {\r\ndev_err(dev, "problem starting queue (%d)\n", status);\r\nreturn status;\r\n}\r\nreturn 0;\r\n}\r\nstatic int pxa2xx_spi_runtime_suspend(struct device *dev)\r\n{\r\nstruct driver_data *drv_data = dev_get_drvdata(dev);\r\nclk_disable_unprepare(drv_data->ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int pxa2xx_spi_runtime_resume(struct device *dev)\r\n{\r\nstruct driver_data *drv_data = dev_get_drvdata(dev);\r\nclk_prepare_enable(drv_data->ssp->clk);\r\nreturn 0;\r\n}\r\nstatic int __init pxa2xx_spi_init(void)\r\n{\r\nreturn platform_driver_register(&driver);\r\n}\r\nstatic void __exit pxa2xx_spi_exit(void)\r\n{\r\nplatform_driver_unregister(&driver);\r\n}
