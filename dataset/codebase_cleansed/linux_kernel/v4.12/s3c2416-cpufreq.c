static unsigned int s3c2416_cpufreq_get_speed(unsigned int cpu)\r\n{\r\nstruct s3c2416_data *s3c_freq = &s3c2416_cpufreq;\r\nif (cpu != 0)\r\nreturn 0;\r\nif (s3c_freq->is_dvs)\r\nreturn FREQ_DVS;\r\nreturn clk_get_rate(s3c_freq->armclk) / 1000;\r\n}\r\nstatic int s3c2416_cpufreq_set_armdiv(struct s3c2416_data *s3c_freq,\r\nunsigned int freq)\r\n{\r\nint ret;\r\nif (clk_get_rate(s3c_freq->armdiv) / 1000 != freq) {\r\nret = clk_set_rate(s3c_freq->armdiv, freq * 1000);\r\nif (ret < 0) {\r\npr_err("cpufreq: Failed to set armdiv rate %dkHz: %d\n",\r\nfreq, ret);\r\nreturn ret;\r\n}\r\n}\r\nreturn 0;\r\n}\r\nstatic int s3c2416_cpufreq_enter_dvs(struct s3c2416_data *s3c_freq, int idx)\r\n{\r\n#ifdef CONFIG_ARM_S3C2416_CPUFREQ_VCORESCALE\r\nstruct s3c2416_dvfs *dvfs;\r\n#endif\r\nint ret;\r\nif (s3c_freq->is_dvs) {\r\npr_debug("cpufreq: already in dvs mode, nothing to do\n");\r\nreturn 0;\r\n}\r\npr_debug("cpufreq: switching armclk to hclk (%lukHz)\n",\r\nclk_get_rate(s3c_freq->hclk) / 1000);\r\nret = clk_set_parent(s3c_freq->armclk, s3c_freq->hclk);\r\nif (ret < 0) {\r\npr_err("cpufreq: Failed to switch armclk to hclk: %d\n", ret);\r\nreturn ret;\r\n}\r\n#ifdef CONFIG_ARM_S3C2416_CPUFREQ_VCORESCALE\r\nif (s3c_freq->vddarm) {\r\ndvfs = &s3c2416_dvfs_table[idx];\r\npr_debug("cpufreq: setting regulator to %d-%d\n",\r\ndvfs->vddarm_min, dvfs->vddarm_max);\r\nret = regulator_set_voltage(s3c_freq->vddarm,\r\ndvfs->vddarm_min,\r\ndvfs->vddarm_max);\r\nif (ret != 0)\r\npr_err("cpufreq: Failed to set VDDARM: %d\n", ret);\r\n}\r\n#endif\r\ns3c_freq->is_dvs = 1;\r\nreturn 0;\r\n}\r\nstatic int s3c2416_cpufreq_leave_dvs(struct s3c2416_data *s3c_freq, int idx)\r\n{\r\n#ifdef CONFIG_ARM_S3C2416_CPUFREQ_VCORESCALE\r\nstruct s3c2416_dvfs *dvfs;\r\n#endif\r\nint ret;\r\nif (!s3c_freq->is_dvs) {\r\npr_debug("cpufreq: not in dvs mode, so can't leave\n");\r\nreturn 0;\r\n}\r\n#ifdef CONFIG_ARM_S3C2416_CPUFREQ_VCORESCALE\r\nif (s3c_freq->vddarm) {\r\ndvfs = &s3c2416_dvfs_table[idx];\r\npr_debug("cpufreq: setting regulator to %d-%d\n",\r\ndvfs->vddarm_min, dvfs->vddarm_max);\r\nret = regulator_set_voltage(s3c_freq->vddarm,\r\ndvfs->vddarm_min,\r\ndvfs->vddarm_max);\r\nif (ret != 0) {\r\npr_err("cpufreq: Failed to set VDDARM: %d\n", ret);\r\nreturn ret;\r\n}\r\n}\r\n#endif\r\nif (clk_get_rate(s3c_freq->armdiv) > clk_get_rate(s3c_freq->hclk)) {\r\npr_debug("cpufreq: force armdiv to hclk frequency (%lukHz)\n",\r\nclk_get_rate(s3c_freq->hclk) / 1000);\r\nret = s3c2416_cpufreq_set_armdiv(s3c_freq,\r\nclk_get_rate(s3c_freq->hclk) / 1000);\r\nif (ret < 0) {\r\npr_err("cpufreq: Failed to set the armdiv to %lukHz: %d\n",\r\nclk_get_rate(s3c_freq->hclk) / 1000, ret);\r\nreturn ret;\r\n}\r\n}\r\npr_debug("cpufreq: switching armclk parent to armdiv (%lukHz)\n",\r\nclk_get_rate(s3c_freq->armdiv) / 1000);\r\nret = clk_set_parent(s3c_freq->armclk, s3c_freq->armdiv);\r\nif (ret < 0) {\r\npr_err("cpufreq: Failed to switch armclk clock parent to armdiv: %d\n",\r\nret);\r\nreturn ret;\r\n}\r\ns3c_freq->is_dvs = 0;\r\nreturn 0;\r\n}\r\nstatic int s3c2416_cpufreq_set_target(struct cpufreq_policy *policy,\r\nunsigned int index)\r\n{\r\nstruct s3c2416_data *s3c_freq = &s3c2416_cpufreq;\r\nunsigned int new_freq;\r\nint idx, ret, to_dvs = 0;\r\nmutex_lock(&cpufreq_lock);\r\nidx = s3c_freq->freq_table[index].driver_data;\r\nif (idx == SOURCE_HCLK)\r\nto_dvs = 1;\r\nif (to_dvs && s3c_freq->disable_dvs) {\r\npr_debug("cpufreq: entering dvs mode not allowed\n");\r\nret = -EINVAL;\r\ngoto out;\r\n}\r\nnew_freq = (s3c_freq->is_dvs && !to_dvs)\r\n? clk_get_rate(s3c_freq->hclk) / 1000\r\n: s3c_freq->freq_table[index].frequency;\r\nif (to_dvs) {\r\npr_debug("cpufreq: enter dvs\n");\r\nret = s3c2416_cpufreq_enter_dvs(s3c_freq, idx);\r\n} else if (s3c_freq->is_dvs) {\r\npr_debug("cpufreq: leave dvs\n");\r\nret = s3c2416_cpufreq_leave_dvs(s3c_freq, idx);\r\n} else {\r\npr_debug("cpufreq: change armdiv to %dkHz\n", new_freq);\r\nret = s3c2416_cpufreq_set_armdiv(s3c_freq, new_freq);\r\n}\r\nout:\r\nmutex_unlock(&cpufreq_lock);\r\nreturn ret;\r\n}\r\nstatic void s3c2416_cpufreq_cfg_regulator(struct s3c2416_data *s3c_freq)\r\n{\r\nint count, v, i, found;\r\nstruct cpufreq_frequency_table *pos;\r\nstruct s3c2416_dvfs *dvfs;\r\ncount = regulator_count_voltages(s3c_freq->vddarm);\r\nif (count < 0) {\r\npr_err("cpufreq: Unable to check supported voltages\n");\r\nreturn;\r\n}\r\nif (!count)\r\ngoto out;\r\ncpufreq_for_each_valid_entry(pos, s3c_freq->freq_table) {\r\ndvfs = &s3c2416_dvfs_table[pos->driver_data];\r\nfound = 0;\r\nfor (i = 0; i < count; i++) {\r\nv = regulator_list_voltage(s3c_freq->vddarm, i);\r\nif (v >= dvfs->vddarm_min)\r\nfound = 1;\r\n}\r\nif (!found) {\r\npr_debug("cpufreq: %dkHz unsupported by regulator\n",\r\npos->frequency);\r\npos->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\n}\r\nout:\r\ns3c_freq->regulator_latency = 1 * 1000 * 1000;\r\n}\r\nstatic int s3c2416_cpufreq_reboot_notifier_evt(struct notifier_block *this,\r\nunsigned long event, void *ptr)\r\n{\r\nstruct s3c2416_data *s3c_freq = &s3c2416_cpufreq;\r\nint ret;\r\nmutex_lock(&cpufreq_lock);\r\ns3c_freq->disable_dvs = 1;\r\nmutex_unlock(&cpufreq_lock);\r\nif (s3c_freq->is_dvs) {\r\npr_debug("cpufreq: leave dvs on reboot\n");\r\nret = cpufreq_driver_target(cpufreq_cpu_get(0), FREQ_SLEEP, 0);\r\nif (ret < 0)\r\nreturn NOTIFY_BAD;\r\n}\r\nreturn NOTIFY_DONE;\r\n}\r\nstatic int s3c2416_cpufreq_driver_init(struct cpufreq_policy *policy)\r\n{\r\nstruct s3c2416_data *s3c_freq = &s3c2416_cpufreq;\r\nstruct cpufreq_frequency_table *pos;\r\nstruct clk *msysclk;\r\nunsigned long rate;\r\nint ret;\r\nif (policy->cpu != 0)\r\nreturn -EINVAL;\r\nmsysclk = clk_get(NULL, "msysclk");\r\nif (IS_ERR(msysclk)) {\r\nret = PTR_ERR(msysclk);\r\npr_err("cpufreq: Unable to obtain msysclk: %d\n", ret);\r\nreturn ret;\r\n}\r\nrate = clk_get_rate(msysclk);\r\nif (rate == 800 * 1000 * 1000) {\r\npr_info("cpufreq: msysclk running at %lukHz, using S3C2416 frequency table\n",\r\nrate / 1000);\r\ns3c_freq->freq_table = s3c2416_freq_table;\r\npolicy->cpuinfo.max_freq = 400000;\r\n} else if (rate / 1000 == 534000) {\r\npr_info("cpufreq: msysclk running at %lukHz, using S3C2450 frequency table\n",\r\nrate / 1000);\r\ns3c_freq->freq_table = s3c2450_freq_table;\r\npolicy->cpuinfo.max_freq = 534000;\r\n}\r\nclk_put(msysclk);\r\nif (s3c_freq->freq_table == NULL) {\r\npr_err("cpufreq: No frequency information for this CPU, msysclk at %lukHz\n",\r\nrate / 1000);\r\nreturn -ENODEV;\r\n}\r\ns3c_freq->is_dvs = 0;\r\ns3c_freq->armdiv = clk_get(NULL, "armdiv");\r\nif (IS_ERR(s3c_freq->armdiv)) {\r\nret = PTR_ERR(s3c_freq->armdiv);\r\npr_err("cpufreq: Unable to obtain ARMDIV: %d\n", ret);\r\nreturn ret;\r\n}\r\ns3c_freq->hclk = clk_get(NULL, "hclk");\r\nif (IS_ERR(s3c_freq->hclk)) {\r\nret = PTR_ERR(s3c_freq->hclk);\r\npr_err("cpufreq: Unable to obtain HCLK: %d\n", ret);\r\ngoto err_hclk;\r\n}\r\nrate = clk_get_rate(s3c_freq->hclk);\r\nif (rate < 133 * 1000 * 1000) {\r\npr_err("cpufreq: HCLK not at 133MHz\n");\r\nret = -EINVAL;\r\ngoto err_armclk;\r\n}\r\ns3c_freq->armclk = clk_get(NULL, "armclk");\r\nif (IS_ERR(s3c_freq->armclk)) {\r\nret = PTR_ERR(s3c_freq->armclk);\r\npr_err("cpufreq: Unable to obtain ARMCLK: %d\n", ret);\r\ngoto err_armclk;\r\n}\r\n#ifdef CONFIG_ARM_S3C2416_CPUFREQ_VCORESCALE\r\ns3c_freq->vddarm = regulator_get(NULL, "vddarm");\r\nif (IS_ERR(s3c_freq->vddarm)) {\r\nret = PTR_ERR(s3c_freq->vddarm);\r\npr_err("cpufreq: Failed to obtain VDDARM: %d\n", ret);\r\ngoto err_vddarm;\r\n}\r\ns3c2416_cpufreq_cfg_regulator(s3c_freq);\r\n#else\r\ns3c_freq->regulator_latency = 0;\r\n#endif\r\ncpufreq_for_each_entry(pos, s3c_freq->freq_table) {\r\nif (pos->driver_data == 0) {\r\nif (!s3c_freq->hclk) {\r\npr_debug("cpufreq: %dkHz unsupported as it would need unavailable dvs mode\n",\r\npos->frequency);\r\npos->frequency = CPUFREQ_ENTRY_INVALID;\r\n} else {\r\ncontinue;\r\n}\r\n}\r\nrate = clk_round_rate(s3c_freq->armdiv,\r\npos->frequency * 1000);\r\nrate /= 1000;\r\nif (rate != pos->frequency) {\r\npr_debug("cpufreq: %dkHz unsupported by clock (clk_round_rate return %lu)\n",\r\npos->frequency, rate);\r\npos->frequency = CPUFREQ_ENTRY_INVALID;\r\n}\r\n}\r\nret = cpufreq_generic_init(policy, s3c_freq->freq_table,\r\n(500 * 1000) + s3c_freq->regulator_latency);\r\nif (ret)\r\ngoto err_freq_table;\r\nregister_reboot_notifier(&s3c2416_cpufreq_reboot_notifier);\r\nreturn 0;\r\nerr_freq_table:\r\n#ifdef CONFIG_ARM_S3C2416_CPUFREQ_VCORESCALE\r\nregulator_put(s3c_freq->vddarm);\r\nerr_vddarm:\r\n#endif\r\nclk_put(s3c_freq->armclk);\r\nerr_armclk:\r\nclk_put(s3c_freq->hclk);\r\nerr_hclk:\r\nclk_put(s3c_freq->armdiv);\r\nreturn ret;\r\n}\r\nstatic int __init s3c2416_cpufreq_init(void)\r\n{\r\nreturn cpufreq_register_driver(&s3c2416_cpufreq_driver);\r\n}
