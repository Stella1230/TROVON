static ssize_t show_color_common(struct device *dev, char *buf, int color)\r\n{\r\nstruct i2c_client *client;\r\nstruct blinkm_data *data;\r\nint ret;\r\nclient = to_i2c_client(dev);\r\ndata = i2c_get_clientdata(client);\r\nret = blinkm_transfer_hw(client, BLM_GET_CUR_RGB);\r\nif (ret < 0)\r\nreturn ret;\r\nswitch (color) {\r\ncase RED:\r\nreturn scnprintf(buf, PAGE_SIZE, "%02X\n", data->red);\r\ncase GREEN:\r\nreturn scnprintf(buf, PAGE_SIZE, "%02X\n", data->green);\r\ncase BLUE:\r\nreturn scnprintf(buf, PAGE_SIZE, "%02X\n", data->blue);\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\nreturn -EINVAL;\r\n}\r\nstatic int store_color_common(struct device *dev, const char *buf, int color)\r\n{\r\nstruct i2c_client *client;\r\nstruct blinkm_data *data;\r\nint ret;\r\nu8 value;\r\nclient = to_i2c_client(dev);\r\ndata = i2c_get_clientdata(client);\r\nret = kstrtou8(buf, 10, &value);\r\nif (ret < 0) {\r\ndev_err(dev, "BlinkM: value too large!\n");\r\nreturn ret;\r\n}\r\nswitch (color) {\r\ncase RED:\r\ndata->next_red = value;\r\nbreak;\r\ncase GREEN:\r\ndata->next_green = value;\r\nbreak;\r\ncase BLUE:\r\ndata->next_blue = value;\r\nbreak;\r\ndefault:\r\nreturn -EINVAL;\r\n}\r\ndev_dbg(dev, "next_red = %d, next_green = %d, next_blue = %d\n",\r\ndata->next_red, data->next_green, data->next_blue);\r\nret = blinkm_transfer_hw(client, BLM_GO_RGB);\r\nif (ret < 0) {\r\ndev_err(dev, "BlinkM: can't set RGB\n");\r\nreturn ret;\r\n}\r\nreturn 0;\r\n}\r\nstatic ssize_t show_red(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_color_common(dev, buf, RED);\r\n}\r\nstatic ssize_t store_red(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nret = store_color_common(dev, buf, RED);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t show_green(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_color_common(dev, buf, GREEN);\r\n}\r\nstatic ssize_t store_green(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nret = store_color_common(dev, buf, GREEN);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t show_blue(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn show_color_common(dev, buf, BLUE);\r\n}\r\nstatic ssize_t store_blue(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nint ret;\r\nret = store_color_common(dev, buf, BLUE);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic ssize_t show_test(struct device *dev, struct device_attribute *attr,\r\nchar *buf)\r\n{\r\nreturn scnprintf(buf, PAGE_SIZE,\r\n"#Write into test to start test sequence!#\n");\r\n}\r\nstatic ssize_t store_test(struct device *dev, struct device_attribute *attr,\r\nconst char *buf, size_t count)\r\n{\r\nstruct i2c_client *client;\r\nint ret;\r\nclient = to_i2c_client(dev);\r\nret = blinkm_test_run(client);\r\nif (ret < 0)\r\nreturn ret;\r\nreturn count;\r\n}\r\nstatic int blinkm_write(struct i2c_client *client, int cmd, u8 *arg)\r\n{\r\nint result;\r\nint i;\r\nint arglen = blinkm_cmds[cmd].nr_args;\r\nresult = i2c_smbus_write_byte(client, blinkm_cmds[cmd].cmdbyte);\r\nif (result < 0)\r\nreturn result;\r\nif (arglen == 0)\r\nreturn 0;\r\nfor (i = 0; i < arglen; i++) {\r\nresult = i2c_smbus_write_byte(client, arg[i]);\r\nif (result < 0)\r\nreturn result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int blinkm_read(struct i2c_client *client, int cmd, u8 *arg)\r\n{\r\nint result;\r\nint i;\r\nint retlen = blinkm_cmds[cmd].nr_ret;\r\nfor (i = 0; i < retlen; i++) {\r\nresult = i2c_smbus_read_byte(client);\r\nif (result < 0)\r\nreturn result;\r\narg[i] = result;\r\n}\r\nreturn 0;\r\n}\r\nstatic int blinkm_transfer_hw(struct i2c_client *client, int cmd)\r\n{\r\nstruct blinkm_data *data = i2c_get_clientdata(client);\r\nif (mutex_lock_interruptible(&data->update_lock) < 0)\r\nreturn -EAGAIN;\r\nswitch (cmd) {\r\ncase BLM_FADE_RAND_RGB:\r\ncase BLM_GO_RGB:\r\ncase BLM_FADE_RGB:\r\ndata->args[0] = data->next_red;\r\ndata->args[1] = data->next_green;\r\ndata->args[2] = data->next_blue;\r\nblinkm_write(client, cmd, data->args);\r\ndata->red = data->args[0];\r\ndata->green = data->args[1];\r\ndata->blue = data->args[2];\r\nbreak;\r\ncase BLM_FADE_HSB:\r\ncase BLM_FADE_RAND_HSB:\r\ndata->args[0] = data->next_hue;\r\ndata->args[1] = data->next_saturation;\r\ndata->args[2] = data->next_brightness;\r\nblinkm_write(client, cmd, data->args);\r\ndata->hue = data->next_hue;\r\ndata->saturation = data->next_saturation;\r\ndata->brightness = data->next_brightness;\r\nbreak;\r\ncase BLM_PLAY_SCRIPT:\r\ndata->args[0] = data->script_id;\r\ndata->args[1] = data->script_repeats;\r\ndata->args[2] = data->script_startline;\r\nblinkm_write(client, cmd, data->args);\r\nbreak;\r\ncase BLM_STOP_SCRIPT:\r\nblinkm_write(client, cmd, NULL);\r\nbreak;\r\ncase BLM_GET_CUR_RGB:\r\ndata->args[0] = data->red;\r\ndata->args[1] = data->green;\r\ndata->args[2] = data->blue;\r\nblinkm_write(client, cmd, NULL);\r\nblinkm_read(client, cmd, data->args);\r\ndata->red = data->args[0];\r\ndata->green = data->args[1];\r\ndata->blue = data->args[2];\r\nbreak;\r\ncase BLM_GET_ADDR:\r\ndata->args[0] = data->i2c_addr;\r\nblinkm_write(client, cmd, NULL);\r\nblinkm_read(client, cmd, data->args);\r\ndata->i2c_addr = data->args[0];\r\nbreak;\r\ncase BLM_SET_TIME_ADJ:\r\ncase BLM_SET_FADE_SPEED:\r\ncase BLM_READ_SCRIPT_LINE:\r\ncase BLM_WRITE_SCRIPT_LINE:\r\ncase BLM_SET_SCRIPT_LR:\r\ncase BLM_SET_ADDR:\r\ncase BLM_GET_FW_VER:\r\ncase BLM_SET_STARTUP_PARAM:\r\ndev_err(&client->dev,\r\n"BlinkM: cmd %d not implemented yet.\n", cmd);\r\nbreak;\r\ndefault:\r\ndev_err(&client->dev, "BlinkM: unknown command %d\n", cmd);\r\nmutex_unlock(&data->update_lock);\r\nreturn -EINVAL;\r\n}\r\nmutex_unlock(&data->update_lock);\r\nreturn 0;\r\n}\r\nstatic int blinkm_led_common_set(struct led_classdev *led_cdev,\r\nenum led_brightness value, int color)\r\n{\r\nstruct blinkm_led *led = cdev_to_blmled(led_cdev);\r\nstruct blinkm_data *data = i2c_get_clientdata(led->i2c_client);\r\nswitch (color) {\r\ncase RED:\r\nif (data->next_red == (u8) value)\r\nreturn 0;\r\ndata->next_red = (u8) value;\r\nbreak;\r\ncase GREEN:\r\nif (data->next_green == (u8) value)\r\nreturn 0;\r\ndata->next_green = (u8) value;\r\nbreak;\r\ncase BLUE:\r\nif (data->next_blue == (u8) value)\r\nreturn 0;\r\ndata->next_blue = (u8) value;\r\nbreak;\r\ndefault:\r\ndev_err(&led->i2c_client->dev, "BlinkM: unknown color.\n");\r\nreturn -EINVAL;\r\n}\r\nblinkm_transfer_hw(led->i2c_client, BLM_GO_RGB);\r\ndev_dbg(&led->i2c_client->dev,\r\n"# DONE # next_red = %d, next_green = %d,"\r\n" next_blue = %d\n",\r\ndata->next_red, data->next_green,\r\ndata->next_blue);\r\nreturn 0;\r\n}\r\nstatic int blinkm_led_red_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nreturn blinkm_led_common_set(led_cdev, value, RED);\r\n}\r\nstatic int blinkm_led_green_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nreturn blinkm_led_common_set(led_cdev, value, GREEN);\r\n}\r\nstatic int blinkm_led_blue_set(struct led_classdev *led_cdev,\r\nenum led_brightness value)\r\n{\r\nreturn blinkm_led_common_set(led_cdev, value, BLUE);\r\n}\r\nstatic void blinkm_init_hw(struct i2c_client *client)\r\n{\r\nint ret;\r\nret = blinkm_transfer_hw(client, BLM_STOP_SCRIPT);\r\nret = blinkm_transfer_hw(client, BLM_GO_RGB);\r\n}\r\nstatic int blinkm_test_run(struct i2c_client *client)\r\n{\r\nint ret;\r\nstruct blinkm_data *data = i2c_get_clientdata(client);\r\ndata->next_red = 0x01;\r\ndata->next_green = 0x05;\r\ndata->next_blue = 0x10;\r\nret = blinkm_transfer_hw(client, BLM_GO_RGB);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(2000);\r\ndata->next_red = 0x25;\r\ndata->next_green = 0x10;\r\ndata->next_blue = 0x31;\r\nret = blinkm_transfer_hw(client, BLM_FADE_RGB);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(2000);\r\ndata->next_hue = 0x50;\r\ndata->next_saturation = 0x10;\r\ndata->next_brightness = 0x20;\r\nret = blinkm_transfer_hw(client, BLM_FADE_HSB);\r\nif (ret < 0)\r\nreturn ret;\r\nmsleep(2000);\r\nreturn 0;\r\n}\r\nstatic int blinkm_detect(struct i2c_client *client, struct i2c_board_info *info)\r\n{\r\nstruct i2c_adapter *adapter = client->adapter;\r\nint ret;\r\nint count = 99;\r\nu8 tmpargs[7];\r\nif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_BYTE_DATA\r\n| I2C_FUNC_SMBUS_WORD_DATA\r\n| I2C_FUNC_SMBUS_WRITE_BYTE))\r\nreturn -ENODEV;\r\nwhile (count > 0) {\r\nret = blinkm_write(client, BLM_GET_ADDR, NULL);\r\nusleep_range(5000, 10000);\r\nret = blinkm_read(client, BLM_GET_ADDR, tmpargs);\r\nusleep_range(5000, 10000);\r\nif (tmpargs[0] == 0x09)\r\ncount = 0;\r\ncount--;\r\n}\r\nret = blinkm_write(client, BLM_GET_ADDR, NULL);\r\nif (ret < 0)\r\nreturn ret;\r\nusleep_range(20000, 30000);\r\nret = blinkm_read(client, BLM_GET_ADDR, tmpargs);\r\nif (ret < 0)\r\nreturn ret;\r\nif (tmpargs[0] != 0x09) {\r\ndev_err(&client->dev, "enodev DEV ADDR = 0x%02X\n", tmpargs[0]);\r\nreturn -ENODEV;\r\n}\r\nstrlcpy(info->type, "blinkm", I2C_NAME_SIZE);\r\nreturn 0;\r\n}\r\nstatic int blinkm_probe(struct i2c_client *client,\r\nconst struct i2c_device_id *id)\r\n{\r\nstruct blinkm_data *data;\r\nstruct blinkm_led *led[3];\r\nint err, i;\r\nchar blinkm_led_name[28];\r\ndata = devm_kzalloc(&client->dev,\r\nsizeof(struct blinkm_data), GFP_KERNEL);\r\nif (!data) {\r\nerr = -ENOMEM;\r\ngoto exit;\r\n}\r\ndata->i2c_addr = 0x09;\r\ndata->i2c_addr = 0x08;\r\ndata->fw_ver = 0xfe;\r\ndata->script_id = 0x01;\r\ndata->i2c_client = client;\r\ni2c_set_clientdata(client, data);\r\nmutex_init(&data->update_lock);\r\nerr = sysfs_create_group(&client->dev.kobj, &blinkm_group);\r\nif (err < 0) {\r\ndev_err(&client->dev, "couldn't register sysfs group\n");\r\ngoto exit;\r\n}\r\nfor (i = 0; i < 3; i++) {\r\nled[i] = &data->blinkm_leds[i];\r\nled[i]->i2c_client = client;\r\nled[i]->id = i;\r\nled[i]->led_cdev.max_brightness = 255;\r\nled[i]->led_cdev.flags = LED_CORE_SUSPENDRESUME;\r\nswitch (i) {\r\ncase RED:\r\nsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\r\n"blinkm-%d-%d-red",\r\nclient->adapter->nr,\r\nclient->addr);\r\nled[i]->led_cdev.name = blinkm_led_name;\r\nled[i]->led_cdev.brightness_set_blocking =\r\nblinkm_led_red_set;\r\nerr = led_classdev_register(&client->dev,\r\n&led[i]->led_cdev);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"couldn't register LED %s\n",\r\nled[i]->led_cdev.name);\r\ngoto failred;\r\n}\r\nbreak;\r\ncase GREEN:\r\nsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\r\n"blinkm-%d-%d-green",\r\nclient->adapter->nr,\r\nclient->addr);\r\nled[i]->led_cdev.name = blinkm_led_name;\r\nled[i]->led_cdev.brightness_set_blocking =\r\nblinkm_led_green_set;\r\nerr = led_classdev_register(&client->dev,\r\n&led[i]->led_cdev);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"couldn't register LED %s\n",\r\nled[i]->led_cdev.name);\r\ngoto failgreen;\r\n}\r\nbreak;\r\ncase BLUE:\r\nsnprintf(blinkm_led_name, sizeof(blinkm_led_name),\r\n"blinkm-%d-%d-blue",\r\nclient->adapter->nr,\r\nclient->addr);\r\nled[i]->led_cdev.name = blinkm_led_name;\r\nled[i]->led_cdev.brightness_set_blocking =\r\nblinkm_led_blue_set;\r\nerr = led_classdev_register(&client->dev,\r\n&led[i]->led_cdev);\r\nif (err < 0) {\r\ndev_err(&client->dev,\r\n"couldn't register LED %s\n",\r\nled[i]->led_cdev.name);\r\ngoto failblue;\r\n}\r\nbreak;\r\n}\r\n}\r\nblinkm_init_hw(client);\r\nreturn 0;\r\nfailblue:\r\nled_classdev_unregister(&led[GREEN]->led_cdev);\r\nfailgreen:\r\nled_classdev_unregister(&led[RED]->led_cdev);\r\nfailred:\r\nsysfs_remove_group(&client->dev.kobj, &blinkm_group);\r\nexit:\r\nreturn err;\r\n}\r\nstatic int blinkm_remove(struct i2c_client *client)\r\n{\r\nstruct blinkm_data *data = i2c_get_clientdata(client);\r\nint ret = 0;\r\nint i;\r\nfor (i = 0; i < 3; i++)\r\nled_classdev_unregister(&data->blinkm_leds[i].led_cdev);\r\ndata->next_red = 0x00;\r\ndata->next_green = 0x00;\r\ndata->next_blue = 0x00;\r\nret = blinkm_transfer_hw(client, BLM_FADE_RGB);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failure in blinkm_remove ignored. Continuing.\n");\r\ndata->next_hue = 0x00;\r\ndata->next_saturation = 0x00;\r\ndata->next_brightness = 0x00;\r\nret = blinkm_transfer_hw(client, BLM_FADE_HSB);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failure in blinkm_remove ignored. Continuing.\n");\r\ndata->next_red = 0xff;\r\nret = blinkm_transfer_hw(client, BLM_GO_RGB);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failure in blinkm_remove ignored. Continuing.\n");\r\ndata->next_red = 0x00;\r\nret = blinkm_transfer_hw(client, BLM_FADE_RGB);\r\nif (ret < 0)\r\ndev_err(&client->dev, "Failure in blinkm_remove ignored. Continuing.\n");\r\nsysfs_remove_group(&client->dev.kobj, &blinkm_group);\r\nreturn 0;\r\n}
