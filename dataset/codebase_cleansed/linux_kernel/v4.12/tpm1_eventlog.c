static void *tpm_bios_measurements_start(struct seq_file *m, loff_t *pos)\r\n{\r\nloff_t i;\r\nstruct tpm_chip *chip = m->private;\r\nstruct tpm_bios_log *log = &chip->log;\r\nvoid *addr = log->bios_event_log;\r\nvoid *limit = log->bios_event_log_end;\r\nstruct tcpa_event *event;\r\nu32 converted_event_size;\r\nu32 converted_event_type;\r\nfor (i = 0; i < *pos; i++) {\r\nevent = addr;\r\nconverted_event_size =\r\ndo_endian_conversion(event->event_size);\r\nconverted_event_type =\r\ndo_endian_conversion(event->event_type);\r\nif ((addr + sizeof(struct tcpa_event)) < limit) {\r\nif ((converted_event_type == 0) &&\r\n(converted_event_size == 0))\r\nreturn NULL;\r\naddr += (sizeof(struct tcpa_event) +\r\nconverted_event_size);\r\n}\r\n}\r\nif ((addr + sizeof(struct tcpa_event)) >= limit)\r\nreturn NULL;\r\nevent = addr;\r\nconverted_event_size = do_endian_conversion(event->event_size);\r\nconverted_event_type = do_endian_conversion(event->event_type);\r\nif (((converted_event_type == 0) && (converted_event_size == 0))\r\n|| ((addr + sizeof(struct tcpa_event) + converted_event_size)\r\n>= limit))\r\nreturn NULL;\r\nreturn addr;\r\n}\r\nstatic void *tpm_bios_measurements_next(struct seq_file *m, void *v,\r\nloff_t *pos)\r\n{\r\nstruct tcpa_event *event = v;\r\nstruct tpm_chip *chip = m->private;\r\nstruct tpm_bios_log *log = &chip->log;\r\nvoid *limit = log->bios_event_log_end;\r\nu32 converted_event_size;\r\nu32 converted_event_type;\r\nconverted_event_size = do_endian_conversion(event->event_size);\r\nv += sizeof(struct tcpa_event) + converted_event_size;\r\nif ((v + sizeof(struct tcpa_event)) >= limit)\r\nreturn NULL;\r\nevent = v;\r\nconverted_event_size = do_endian_conversion(event->event_size);\r\nconverted_event_type = do_endian_conversion(event->event_type);\r\nif (((converted_event_type == 0) && (converted_event_size == 0)) ||\r\n((v + sizeof(struct tcpa_event) + converted_event_size) >= limit))\r\nreturn NULL;\r\n(*pos)++;\r\nreturn v;\r\n}\r\nstatic void tpm_bios_measurements_stop(struct seq_file *m, void *v)\r\n{\r\n}\r\nstatic int get_event_name(char *dest, struct tcpa_event *event,\r\nunsigned char * event_entry)\r\n{\r\nconst char *name = "";\r\nchar data[41] = "";\r\nint i, n_len = 0, d_len = 0;\r\nstruct tcpa_pc_event *pc_event;\r\nswitch (do_endian_conversion(event->event_type)) {\r\ncase PREBOOT:\r\ncase POST_CODE:\r\ncase UNUSED:\r\ncase NO_ACTION:\r\ncase SCRTM_CONTENTS:\r\ncase SCRTM_VERSION:\r\ncase CPU_MICROCODE:\r\ncase PLATFORM_CONFIG_FLAGS:\r\ncase TABLE_OF_DEVICES:\r\ncase COMPACT_HASH:\r\ncase IPL:\r\ncase IPL_PARTITION_DATA:\r\ncase NONHOST_CODE:\r\ncase NONHOST_CONFIG:\r\ncase NONHOST_INFO:\r\nname = tcpa_event_type_strings[do_endian_conversion\r\n(event->event_type)];\r\nn_len = strlen(name);\r\nbreak;\r\ncase SEPARATOR:\r\ncase ACTION:\r\nif (MAX_TEXT_EVENT >\r\ndo_endian_conversion(event->event_size)) {\r\nname = event_entry;\r\nn_len = do_endian_conversion(event->event_size);\r\n}\r\nbreak;\r\ncase EVENT_TAG:\r\npc_event = (struct tcpa_pc_event *)event_entry;\r\nswitch (do_endian_conversion(pc_event->event_id)) {\r\ncase SMBIOS:\r\ncase BIS_CERT:\r\ncase CMOS:\r\ncase NVRAM:\r\ncase OPTION_ROM_EXEC:\r\ncase OPTION_ROM_CONFIG:\r\ncase S_CRTM_VERSION:\r\nname = tcpa_pc_event_id_strings[do_endian_conversion\r\n(pc_event->event_id)];\r\nn_len = strlen(name);\r\nbreak;\r\ncase POST_BIOS_ROM:\r\ncase ESCD:\r\ncase OPTION_ROM_MICROCODE:\r\ncase S_CRTM_CONTENTS:\r\ncase POST_CONTENTS:\r\nname = tcpa_pc_event_id_strings[do_endian_conversion\r\n(pc_event->event_id)];\r\nn_len = strlen(name);\r\nfor (i = 0; i < 20; i++)\r\nd_len += sprintf(&data[2*i], "%02x",\r\npc_event->event_data[i]);\r\nbreak;\r\ndefault:\r\nbreak;\r\n}\r\ndefault:\r\nbreak;\r\n}\r\nreturn snprintf(dest, MAX_TEXT_EVENT, "[%.*s%.*s]",\r\nn_len, name, d_len, data);\r\n}\r\nstatic int tpm_binary_bios_measurements_show(struct seq_file *m, void *v)\r\n{\r\nstruct tcpa_event *event = v;\r\nstruct tcpa_event temp_event;\r\nchar *temp_ptr;\r\nint i;\r\nmemcpy(&temp_event, event, sizeof(struct tcpa_event));\r\ntemp_event.pcr_index = do_endian_conversion(event->pcr_index);\r\ntemp_event.event_type = do_endian_conversion(event->event_type);\r\ntemp_event.event_size = do_endian_conversion(event->event_size);\r\ntemp_ptr = (char *) &temp_event;\r\nfor (i = 0; i < (sizeof(struct tcpa_event) - 1) ; i++)\r\nseq_putc(m, temp_ptr[i]);\r\ntemp_ptr = (char *) v;\r\nfor (i = (sizeof(struct tcpa_event) - 1);\r\ni < (sizeof(struct tcpa_event) + temp_event.event_size); i++)\r\nseq_putc(m, temp_ptr[i]);\r\nreturn 0;\r\n}\r\nstatic int tpm_bios_measurements_release(struct inode *inode,\r\nstruct file *file)\r\n{\r\nstruct seq_file *seq = (struct seq_file *)file->private_data;\r\nstruct tpm_chip *chip = (struct tpm_chip *)seq->private;\r\nput_device(&chip->dev);\r\nreturn seq_release(inode, file);\r\n}\r\nstatic int tpm_ascii_bios_measurements_show(struct seq_file *m, void *v)\r\n{\r\nint len = 0;\r\nchar *eventname;\r\nstruct tcpa_event *event = v;\r\nunsigned char *event_entry =\r\n(unsigned char *)(v + sizeof(struct tcpa_event));\r\neventname = kmalloc(MAX_TEXT_EVENT, GFP_KERNEL);\r\nif (!eventname) {\r\nprintk(KERN_ERR "%s: ERROR - No Memory for event name\n ",\r\n__func__);\r\nreturn -EFAULT;\r\n}\r\nseq_printf(m, "%2d ", do_endian_conversion(event->pcr_index));\r\nseq_printf(m, "%20phN", event->pcr_value);\r\nseq_printf(m, " %02x", do_endian_conversion(event->event_type));\r\nlen += get_event_name(eventname, event, event_entry);\r\nseq_printf(m, " %s\n", eventname);\r\nkfree(eventname);\r\nreturn 0;\r\n}\r\nstatic int tpm_bios_measurements_open(struct inode *inode,\r\nstruct file *file)\r\n{\r\nint err;\r\nstruct seq_file *seq;\r\nstruct tpm_chip_seqops *chip_seqops;\r\nconst struct seq_operations *seqops;\r\nstruct tpm_chip *chip;\r\ninode_lock(inode);\r\nif (!inode->i_private) {\r\ninode_unlock(inode);\r\nreturn -ENODEV;\r\n}\r\nchip_seqops = (struct tpm_chip_seqops *)inode->i_private;\r\nseqops = chip_seqops->seqops;\r\nchip = chip_seqops->chip;\r\nget_device(&chip->dev);\r\ninode_unlock(inode);\r\nerr = seq_open(file, seqops);\r\nif (!err) {\r\nseq = file->private_data;\r\nseq->private = chip;\r\n}\r\nreturn err;\r\n}\r\nstatic int tpm_read_log(struct tpm_chip *chip)\r\n{\r\nint rc;\r\nif (chip->log.bios_event_log != NULL) {\r\ndev_dbg(&chip->dev,\r\n"%s: ERROR - event log already initialized\n",\r\n__func__);\r\nreturn -EFAULT;\r\n}\r\nrc = tpm_read_log_acpi(chip);\r\nif (rc != -ENODEV)\r\nreturn rc;\r\nreturn tpm_read_log_of(chip);\r\n}\r\nint tpm_bios_log_setup(struct tpm_chip *chip)\r\n{\r\nconst char *name = dev_name(&chip->dev);\r\nunsigned int cnt;\r\nint rc = 0;\r\nrc = tpm_read_log(chip);\r\nif (rc)\r\nreturn rc;\r\ncnt = 0;\r\nchip->bios_dir[cnt] = securityfs_create_dir(name, NULL);\r\nif (IS_ERR(chip->bios_dir[cnt]))\r\ngoto err;\r\ncnt++;\r\nchip->bin_log_seqops.chip = chip;\r\nif (chip->flags & TPM_CHIP_FLAG_TPM2)\r\nchip->bin_log_seqops.seqops =\r\n&tpm2_binary_b_measurements_seqops;\r\nelse\r\nchip->bin_log_seqops.seqops =\r\n&tpm_binary_b_measurements_seqops;\r\nchip->bios_dir[cnt] =\r\nsecurityfs_create_file("binary_bios_measurements",\r\n0440, chip->bios_dir[0],\r\n(void *)&chip->bin_log_seqops,\r\n&tpm_bios_measurements_ops);\r\nif (IS_ERR(chip->bios_dir[cnt]))\r\ngoto err;\r\ncnt++;\r\nif (!(chip->flags & TPM_CHIP_FLAG_TPM2)) {\r\nchip->ascii_log_seqops.chip = chip;\r\nchip->ascii_log_seqops.seqops =\r\n&tpm_ascii_b_measurements_seqops;\r\nchip->bios_dir[cnt] =\r\nsecurityfs_create_file("ascii_bios_measurements",\r\n0440, chip->bios_dir[0],\r\n(void *)&chip->ascii_log_seqops,\r\n&tpm_bios_measurements_ops);\r\nif (IS_ERR(chip->bios_dir[cnt]))\r\ngoto err;\r\ncnt++;\r\n}\r\nreturn 0;\r\nerr:\r\nrc = PTR_ERR(chip->bios_dir[cnt]);\r\nchip->bios_dir[cnt] = NULL;\r\ntpm_bios_log_teardown(chip);\r\nreturn rc;\r\n}\r\nvoid tpm_bios_log_teardown(struct tpm_chip *chip)\r\n{\r\nint i;\r\nstruct inode *inode;\r\nfor (i = (TPM_NUM_EVENT_LOG_FILES - 1); i >= 0; i--) {\r\nif (chip->bios_dir[i]) {\r\ninode = d_inode(chip->bios_dir[i]);\r\ninode_lock(inode);\r\ninode->i_private = NULL;\r\ninode_unlock(inode);\r\nsecurityfs_remove(chip->bios_dir[i]);\r\n}\r\n}\r\n}
