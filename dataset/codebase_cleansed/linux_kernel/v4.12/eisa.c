static inline unsigned long eisa_permute(unsigned short port)\r\n{\r\nif (port & 0x300) {\r\nreturn 0xfc000000 | ((port & 0xfc00) >> 6)\r\n| ((port & 0x3f8) << 9) | (port & 7);\r\n} else {\r\nreturn 0xfc000000 | port;\r\n}\r\n}\r\nunsigned char eisa_in8(unsigned short port)\r\n{\r\nif (EISA_bus)\r\nreturn gsc_readb(eisa_permute(port));\r\nreturn 0xff;\r\n}\r\nunsigned short eisa_in16(unsigned short port)\r\n{\r\nif (EISA_bus)\r\nreturn le16_to_cpu(gsc_readw(eisa_permute(port)));\r\nreturn 0xffff;\r\n}\r\nunsigned int eisa_in32(unsigned short port)\r\n{\r\nif (EISA_bus)\r\nreturn le32_to_cpu(gsc_readl(eisa_permute(port)));\r\nreturn 0xffffffff;\r\n}\r\nvoid eisa_out8(unsigned char data, unsigned short port)\r\n{\r\nif (EISA_bus)\r\ngsc_writeb(data, eisa_permute(port));\r\n}\r\nvoid eisa_out16(unsigned short data, unsigned short port)\r\n{\r\nif (EISA_bus)\r\ngsc_writew(cpu_to_le16(data), eisa_permute(port));\r\n}\r\nvoid eisa_out32(unsigned int data, unsigned short port)\r\n{\r\nif (EISA_bus)\r\ngsc_writel(cpu_to_le32(data), eisa_permute(port));\r\n}\r\nstatic void eisa_mask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nunsigned long flags;\r\nEISA_DBG("disable irq %d\n", irq);\r\nspin_lock_irqsave(&eisa_irq_lock, flags);\r\nif (irq & 8) {\r\nslave_mask |= (1 << (irq&7));\r\neisa_out8(slave_mask, 0xa1);\r\n} else {\r\nmaster_mask |= (1 << (irq&7));\r\neisa_out8(master_mask, 0x21);\r\n}\r\nspin_unlock_irqrestore(&eisa_irq_lock, flags);\r\nEISA_DBG("pic0 mask %02x\n", eisa_in8(0x21));\r\nEISA_DBG("pic1 mask %02x\n", eisa_in8(0xa1));\r\n}\r\nstatic void eisa_unmask_irq(struct irq_data *d)\r\n{\r\nunsigned int irq = d->irq;\r\nunsigned long flags;\r\nEISA_DBG("enable irq %d\n", irq);\r\nspin_lock_irqsave(&eisa_irq_lock, flags);\r\nif (irq & 8) {\r\nslave_mask &= ~(1 << (irq&7));\r\neisa_out8(slave_mask, 0xa1);\r\n} else {\r\nmaster_mask &= ~(1 << (irq&7));\r\neisa_out8(master_mask, 0x21);\r\n}\r\nspin_unlock_irqrestore(&eisa_irq_lock, flags);\r\nEISA_DBG("pic0 mask %02x\n", eisa_in8(0x21));\r\nEISA_DBG("pic1 mask %02x\n", eisa_in8(0xa1));\r\n}\r\nstatic irqreturn_t eisa_irq(int wax_irq, void *intr_dev)\r\n{\r\nint irq = gsc_readb(0xfc01f000);\r\nunsigned long flags;\r\nspin_lock_irqsave(&eisa_irq_lock, flags);\r\neisa_out8(0x0a, 0x20);\r\neisa_out8(0x0a, 0xa0);\r\nEISA_DBG("irq IAR %02x 8259-1 irr %02x 8259-2 irr %02x\n",\r\nirq, eisa_in8(0x20), eisa_in8(0xa0));\r\neisa_out8(0x0a, 0x20);\r\neisa_out8(0x0a, 0xa0);\r\nEISA_DBG("irq 8259-1 isr %02x imr %02x 8259-2 isr %02x imr %02x\n",\r\neisa_in8(0x20), eisa_in8(0x21), eisa_in8(0xa0), eisa_in8(0xa1));\r\nirq &= 0xf;\r\nif (irq & 8) {\r\nslave_mask |= (1 << (irq&7));\r\neisa_out8(slave_mask, 0xa1);\r\neisa_out8(0x60 | (irq&7),0xa0);\r\neisa_out8(0x62, 0x20);\r\n} else {\r\nmaster_mask |= (1 << (irq&7));\r\neisa_out8(master_mask, 0x21);\r\neisa_out8(0x60|irq, 0x20);\r\n}\r\nspin_unlock_irqrestore(&eisa_irq_lock, flags);\r\ngeneric_handle_irq(irq);\r\nspin_lock_irqsave(&eisa_irq_lock, flags);\r\nif (irq & 8) {\r\nslave_mask &= ~(1 << (irq&7));\r\neisa_out8(slave_mask, 0xa1);\r\n} else {\r\nmaster_mask &= ~(1 << (irq&7));\r\neisa_out8(master_mask, 0x21);\r\n}\r\nspin_unlock_irqrestore(&eisa_irq_lock, flags);\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic irqreturn_t dummy_irq2_handler(int _, void *dev)\r\n{\r\nprintk(KERN_ALERT "eisa: uhh, irq2?\n");\r\nreturn IRQ_HANDLED;\r\n}\r\nstatic void init_eisa_pic(void)\r\n{\r\nunsigned long flags;\r\nspin_lock_irqsave(&eisa_irq_lock, flags);\r\neisa_out8(0xff, 0x21);\r\neisa_out8(0xff, 0xa1);\r\neisa_out8(0x11, 0x20);\r\neisa_out8(0x00, 0x21);\r\neisa_out8(0x04, 0x21);\r\neisa_out8(0x01, 0x21);\r\neisa_out8(0x40, 0x20);\r\neisa_out8(0x11, 0xa0);\r\neisa_out8(0x08, 0xa1);\r\neisa_out8(0x02, 0xa1);\r\neisa_out8(0x01, 0xa1);\r\neisa_out8(0x40, 0xa0);\r\nudelay(100);\r\nslave_mask = 0xff;\r\nmaster_mask = 0xfb;\r\neisa_out8(slave_mask, 0xa1);\r\neisa_out8(master_mask, 0x21);\r\nEISA_DBG("EISA edge/level %04x\n", eisa_irq_level);\r\neisa_out8(eisa_irq_level&0xff, 0x4d0);\r\neisa_out8((eisa_irq_level >> 8) & 0xff, 0x4d1);\r\nEISA_DBG("pic0 mask %02x\n", eisa_in8(0x21));\r\nEISA_DBG("pic1 mask %02x\n", eisa_in8(0xa1));\r\nEISA_DBG("pic0 edge/level %02x\n", eisa_in8(0x4d0));\r\nEISA_DBG("pic1 edge/level %02x\n", eisa_in8(0x4d1));\r\nspin_unlock_irqrestore(&eisa_irq_lock, flags);\r\n}\r\nstatic int __init eisa_probe(struct parisc_device *dev)\r\n{\r\nint i, result;\r\nchar *name = is_mongoose(dev) ? "Mongoose" : "Wax";\r\nprintk(KERN_INFO "%s EISA Adapter found at 0x%08lx\n",\r\nname, (unsigned long)dev->hpa.start);\r\neisa_dev.hba.dev = dev;\r\neisa_dev.hba.iommu = ccio_get_iommu(dev);\r\neisa_dev.hba.lmmio_space.name = "EISA";\r\neisa_dev.hba.lmmio_space.start = F_EXTEND(0xfc000000);\r\neisa_dev.hba.lmmio_space.end = F_EXTEND(0xffbfffff);\r\neisa_dev.hba.lmmio_space.flags = IORESOURCE_MEM;\r\nresult = ccio_request_resource(dev, &eisa_dev.hba.lmmio_space);\r\nif (result < 0) {\r\nprintk(KERN_ERR "EISA: failed to claim EISA Bus address space!\n");\r\nreturn result;\r\n}\r\neisa_dev.hba.io_space.name = "EISA";\r\neisa_dev.hba.io_space.start = 0;\r\neisa_dev.hba.io_space.end = 0xffff;\r\neisa_dev.hba.lmmio_space.flags = IORESOURCE_IO;\r\nresult = request_resource(&ioport_resource, &eisa_dev.hba.io_space);\r\nif (result < 0) {\r\nprintk(KERN_ERR "EISA: failed to claim EISA Bus port space!\n");\r\nreturn result;\r\n}\r\npcibios_register_hba(&eisa_dev.hba);\r\nresult = request_irq(dev->irq, eisa_irq, IRQF_SHARED, "EISA", &eisa_dev);\r\nif (result) {\r\nprintk(KERN_ERR "EISA: request_irq failed!\n");\r\ngoto error_release;\r\n}\r\nsetup_irq(2, &irq2_action);\r\nfor (i = 0; i < 16; i++) {\r\nirq_set_chip_and_handler(i, &eisa_interrupt_type,\r\nhandle_simple_irq);\r\n}\r\nEISA_bus = 1;\r\nif (dev->num_addrs) {\r\neisa_dev.eeprom_addr = dev->addr[0];\r\n} else {\r\nif (is_mongoose(dev)) {\r\neisa_dev.eeprom_addr = SNAKES_EEPROM_BASE_ADDR;\r\n} else {\r\neisa_dev.eeprom_addr = MIRAGE_EEPROM_BASE_ADDR;\r\n}\r\n}\r\neisa_eeprom_addr = ioremap_nocache(eisa_dev.eeprom_addr, HPEE_MAX_LENGTH);\r\nif (!eisa_eeprom_addr) {\r\nresult = -ENOMEM;\r\nprintk(KERN_ERR "EISA: ioremap_nocache failed!\n");\r\ngoto error_free_irq;\r\n}\r\nresult = eisa_enumerator(eisa_dev.eeprom_addr, &eisa_dev.hba.io_space,\r\n&eisa_dev.hba.lmmio_space);\r\ninit_eisa_pic();\r\nif (result >= 0) {\r\neisa_dev.root.dev = &dev->dev;\r\ndev_set_drvdata(&dev->dev, &eisa_dev.root);\r\neisa_dev.root.bus_base_addr = 0;\r\neisa_dev.root.res = &eisa_dev.hba.io_space;\r\neisa_dev.root.slots = result;\r\neisa_dev.root.dma_mask = 0xffffffff;\r\nif (eisa_root_register (&eisa_dev.root)) {\r\nprintk(KERN_ERR "EISA: Failed to register EISA root\n");\r\nresult = -ENOMEM;\r\ngoto error_iounmap;\r\n}\r\n}\r\nreturn 0;\r\nerror_iounmap:\r\niounmap(eisa_eeprom_addr);\r\nerror_free_irq:\r\nfree_irq(dev->irq, &eisa_dev);\r\nerror_release:\r\nrelease_resource(&eisa_dev.hba.io_space);\r\nreturn result;\r\n}\r\nvoid __init eisa_init(void)\r\n{\r\nregister_parisc_driver(&eisa_driver);\r\n}\r\nvoid eisa_make_irq_level(int num)\r\n{\r\nif (eisa_irq_configured& (1<<num)) {\r\nprintk(KERN_WARNING\r\n"IRQ %d polarity configured twice (last to level)\n",\r\nnum);\r\n}\r\neisa_irq_level |= (1<<num);\r\neisa_irq_configured |= (1<<num);\r\n}\r\nvoid eisa_make_irq_edge(int num)\r\n{\r\nif (eisa_irq_configured& (1<<num)) {\r\nprintk(KERN_WARNING\r\n"IRQ %d polarity configured twice (last to edge)\n",\r\nnum);\r\n}\r\neisa_irq_level &= ~(1<<num);\r\neisa_irq_configured |= (1<<num);\r\n}\r\nstatic int __init eisa_irq_setup(char *str)\r\n{\r\nchar *cur = str;\r\nint val;\r\nEISA_DBG("IRQ setup\n");\r\nwhile (cur != NULL) {\r\nchar *pe;\r\nval = (int) simple_strtoul(cur, &pe, 0);\r\nif (val > 15 || val < 0) {\r\nprintk(KERN_ERR "eisa: EISA irq value are 0-15\n");\r\ncontinue;\r\n}\r\nif (val == 2) {\r\nval = 9;\r\n}\r\neisa_make_irq_edge(val);\r\nEISA_DBG("setting IRQ %d to edge-triggered mode\n", val);\r\nif ((cur = strchr(cur, ','))) {\r\ncur++;\r\n} else {\r\nbreak;\r\n}\r\n}\r\nreturn 1;\r\n}
