static inline struct geneve_port *geneve_vport(const struct vport *vport)\r\n{\r\nreturn vport_priv(vport);\r\n}\r\nstatic int geneve_get_options(const struct vport *vport,\r\nstruct sk_buff *skb)\r\n{\r\nstruct geneve_port *geneve_port = geneve_vport(vport);\r\nif (nla_put_u16(skb, OVS_TUNNEL_ATTR_DST_PORT, geneve_port->dst_port))\r\nreturn -EMSGSIZE;\r\nreturn 0;\r\n}\r\nstatic struct vport *geneve_tnl_create(const struct vport_parms *parms)\r\n{\r\nstruct net *net = ovs_dp_get_net(parms->dp);\r\nstruct nlattr *options = parms->options;\r\nstruct geneve_port *geneve_port;\r\nstruct net_device *dev;\r\nstruct vport *vport;\r\nstruct nlattr *a;\r\nu16 dst_port;\r\nint err;\r\nif (!options) {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\na = nla_find_nested(options, OVS_TUNNEL_ATTR_DST_PORT);\r\nif (a && nla_len(a) == sizeof(u16)) {\r\ndst_port = nla_get_u16(a);\r\n} else {\r\nerr = -EINVAL;\r\ngoto error;\r\n}\r\nvport = ovs_vport_alloc(sizeof(struct geneve_port),\r\n&ovs_geneve_vport_ops, parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\ngeneve_port = geneve_vport(vport);\r\ngeneve_port->dst_port = dst_port;\r\nrtnl_lock();\r\ndev = geneve_dev_create_fb(net, parms->name, NET_NAME_USER, dst_port);\r\nif (IS_ERR(dev)) {\r\nrtnl_unlock();\r\novs_vport_free(vport);\r\nreturn ERR_CAST(dev);\r\n}\r\nerr = dev_change_flags(dev, dev->flags | IFF_UP);\r\nif (err < 0) {\r\nrtnl_delete_link(dev);\r\nrtnl_unlock();\r\novs_vport_free(vport);\r\ngoto error;\r\n}\r\nrtnl_unlock();\r\nreturn vport;\r\nerror:\r\nreturn ERR_PTR(err);\r\n}\r\nstatic struct vport *geneve_create(const struct vport_parms *parms)\r\n{\r\nstruct vport *vport;\r\nvport = geneve_tnl_create(parms);\r\nif (IS_ERR(vport))\r\nreturn vport;\r\nreturn ovs_netdev_link(vport, parms->name);\r\n}\r\nstatic int __init ovs_geneve_tnl_init(void)\r\n{\r\nreturn ovs_vport_ops_register(&ovs_geneve_vport_ops);\r\n}\r\nstatic void __exit ovs_geneve_tnl_exit(void)\r\n{\r\novs_vport_ops_unregister(&ovs_geneve_vport_ops);\r\n}
