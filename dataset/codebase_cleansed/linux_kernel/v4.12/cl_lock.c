static void cl_lock_trace0(int level, const struct lu_env *env,\r\nconst char *prefix, const struct cl_lock *lock,\r\nconst char *func, const int line)\r\n{\r\nstruct cl_object_header *h = cl_object_header(lock->cll_descr.cld_obj);\r\nCDEBUG(level, "%s: %p (%p/%d) at %s():%d\n",\r\nprefix, lock, env, h->coh_nesting, func, line);\r\n}\r\nvoid cl_lock_slice_add(struct cl_lock *lock, struct cl_lock_slice *slice,\r\nstruct cl_object *obj,\r\nconst struct cl_lock_operations *ops)\r\n{\r\nslice->cls_lock = lock;\r\nlist_add_tail(&slice->cls_linkage, &lock->cll_layers);\r\nslice->cls_obj = obj;\r\nslice->cls_ops = ops;\r\n}\r\nvoid cl_lock_fini(const struct lu_env *env, struct cl_lock *lock)\r\n{\r\ncl_lock_trace(D_DLMTRACE, env, "destroy lock", lock);\r\nwhile (!list_empty(&lock->cll_layers)) {\r\nstruct cl_lock_slice *slice;\r\nslice = list_entry(lock->cll_layers.next,\r\nstruct cl_lock_slice, cls_linkage);\r\nlist_del_init(lock->cll_layers.next);\r\nslice->cls_ops->clo_fini(env, slice);\r\n}\r\nPOISON(lock, 0x5a, sizeof(*lock));\r\n}\r\nint cl_lock_init(const struct lu_env *env, struct cl_lock *lock,\r\nconst struct cl_io *io)\r\n{\r\nstruct cl_object *obj = lock->cll_descr.cld_obj;\r\nstruct cl_object *scan;\r\nint result = 0;\r\nLASSERT(obj);\r\nINIT_LIST_HEAD(&lock->cll_layers);\r\nlist_for_each_entry(scan, &obj->co_lu.lo_header->loh_layers,\r\nco_lu.lo_linkage) {\r\nresult = scan->co_ops->coo_lock_init(env, scan, lock, io);\r\nif (result != 0) {\r\ncl_lock_fini(env, lock);\r\nbreak;\r\n}\r\n}\r\nreturn result;\r\n}\r\nconst struct cl_lock_slice *cl_lock_at(const struct cl_lock *lock,\r\nconst struct lu_device_type *dtype)\r\n{\r\nconst struct cl_lock_slice *slice;\r\nlist_for_each_entry(slice, &lock->cll_layers, cls_linkage) {\r\nif (slice->cls_obj->co_lu.lo_dev->ld_type == dtype)\r\nreturn slice;\r\n}\r\nreturn NULL;\r\n}\r\nvoid cl_lock_cancel(const struct lu_env *env, struct cl_lock *lock)\r\n{\r\nconst struct cl_lock_slice *slice;\r\ncl_lock_trace(D_DLMTRACE, env, "cancel lock", lock);\r\nlist_for_each_entry_reverse(slice, &lock->cll_layers, cls_linkage) {\r\nif (slice->cls_ops->clo_cancel)\r\nslice->cls_ops->clo_cancel(env, slice);\r\n}\r\n}\r\nint cl_lock_enqueue(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_lock *lock, struct cl_sync_io *anchor)\r\n{\r\nconst struct cl_lock_slice *slice;\r\nint rc = -ENOSYS;\r\nlist_for_each_entry(slice, &lock->cll_layers, cls_linkage) {\r\nif (!slice->cls_ops->clo_enqueue)\r\ncontinue;\r\nrc = slice->cls_ops->clo_enqueue(env, slice, io, anchor);\r\nif (rc != 0)\r\nbreak;\r\n}\r\nreturn rc;\r\n}\r\nint cl_lock_request(const struct lu_env *env, struct cl_io *io,\r\nstruct cl_lock *lock)\r\n{\r\nstruct cl_sync_io *anchor = NULL;\r\n__u32 enq_flags = lock->cll_descr.cld_enq_flags;\r\nint rc;\r\nrc = cl_lock_init(env, lock, io);\r\nif (rc < 0)\r\nreturn rc;\r\nif ((enq_flags & CEF_ASYNC) && !(enq_flags & CEF_AGL)) {\r\nanchor = &cl_env_info(env)->clt_anchor;\r\ncl_sync_io_init(anchor, 1, cl_sync_io_end);\r\n}\r\nrc = cl_lock_enqueue(env, io, lock, anchor);\r\nif (anchor) {\r\nint rc2;\r\ncl_sync_io_note(env, anchor, 0);\r\nrc2 = cl_sync_io_wait(env, anchor, 0);\r\nif (rc2 < 0 && rc == 0)\r\nrc = rc2;\r\n}\r\nif (rc < 0)\r\ncl_lock_release(env, lock);\r\nreturn rc;\r\n}\r\nvoid cl_lock_release(const struct lu_env *env, struct cl_lock *lock)\r\n{\r\ncl_lock_trace(D_DLMTRACE, env, "release lock", lock);\r\ncl_lock_cancel(env, lock);\r\ncl_lock_fini(env, lock);\r\n}\r\nconst char *cl_lock_mode_name(const enum cl_lock_mode mode)\r\n{\r\nstatic const char *names[] = {\r\n[CLM_READ] = "R",\r\n[CLM_WRITE] = "W",\r\n[CLM_GROUP] = "G"\r\n};\r\nif (0 <= mode && mode < ARRAY_SIZE(names))\r\nreturn names[mode];\r\nelse\r\nreturn "U";\r\n}\r\nvoid cl_lock_descr_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t printer,\r\nconst struct cl_lock_descr *descr)\r\n{\r\nconst struct lu_fid *fid;\r\nfid = lu_object_fid(&descr->cld_obj->co_lu);\r\n(*printer)(env, cookie, DDESCR"@"DFID, PDESCR(descr), PFID(fid));\r\n}\r\nvoid cl_lock_print(const struct lu_env *env, void *cookie,\r\nlu_printer_t printer, const struct cl_lock *lock)\r\n{\r\nconst struct cl_lock_slice *slice;\r\n(*printer)(env, cookie, "lock@%p", lock);\r\ncl_lock_descr_print(env, cookie, printer, &lock->cll_descr);\r\n(*printer)(env, cookie, " {\n");\r\nlist_for_each_entry(slice, &lock->cll_layers, cls_linkage) {\r\n(*printer)(env, cookie, " %s@%p: ",\r\nslice->cls_obj->co_lu.lo_dev->ld_type->ldt_name,\r\nslice);\r\nif (slice->cls_ops->clo_print)\r\nslice->cls_ops->clo_print(env, cookie, printer, slice);\r\n(*printer)(env, cookie, "\n");\r\n}\r\n(*printer)(env, cookie, "} lock@%p\n", lock);\r\n}
