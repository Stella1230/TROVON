ssize_t store_sampling_rate(struct gov_attr_set *attr_set, const char *buf,\r\nsize_t count)\r\n{\r\nstruct dbs_data *dbs_data = to_dbs_data(attr_set);\r\nstruct policy_dbs_info *policy_dbs;\r\nunsigned int rate;\r\nint ret;\r\nret = sscanf(buf, "%u", &rate);\r\nif (ret != 1)\r\nreturn -EINVAL;\r\ndbs_data->sampling_rate = max(rate, dbs_data->min_sampling_rate);\r\nlist_for_each_entry(policy_dbs, &attr_set->policy_list, list) {\r\nmutex_lock(&policy_dbs->update_mutex);\r\ngov_update_sample_delay(policy_dbs, 0);\r\nmutex_unlock(&policy_dbs->update_mutex);\r\n}\r\nreturn count;\r\n}\r\nvoid gov_update_cpu_data(struct dbs_data *dbs_data)\r\n{\r\nstruct policy_dbs_info *policy_dbs;\r\nlist_for_each_entry(policy_dbs, &dbs_data->attr_set.policy_list, list) {\r\nunsigned int j;\r\nfor_each_cpu(j, policy_dbs->policy->cpus) {\r\nstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\r\nj_cdbs->prev_cpu_idle = get_cpu_idle_time(j, &j_cdbs->prev_update_time,\r\ndbs_data->io_is_busy);\r\nif (dbs_data->ignore_nice_load)\r\nj_cdbs->prev_cpu_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE];\r\n}\r\n}\r\n}\r\nunsigned int dbs_update(struct cpufreq_policy *policy)\r\n{\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nunsigned int ignore_nice = dbs_data->ignore_nice_load;\r\nunsigned int max_load = 0, idle_periods = UINT_MAX;\r\nunsigned int sampling_rate, io_busy, j;\r\nsampling_rate = dbs_data->sampling_rate * policy_dbs->rate_mult;\r\nio_busy = dbs_data->io_is_busy;\r\nfor_each_cpu(j, policy->cpus) {\r\nstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\r\nu64 update_time, cur_idle_time;\r\nunsigned int idle_time, time_elapsed;\r\nunsigned int load;\r\ncur_idle_time = get_cpu_idle_time(j, &update_time, io_busy);\r\ntime_elapsed = update_time - j_cdbs->prev_update_time;\r\nj_cdbs->prev_update_time = update_time;\r\nidle_time = cur_idle_time - j_cdbs->prev_cpu_idle;\r\nj_cdbs->prev_cpu_idle = cur_idle_time;\r\nif (ignore_nice) {\r\nu64 cur_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE];\r\nidle_time += div_u64(cur_nice - j_cdbs->prev_cpu_nice, NSEC_PER_USEC);\r\nj_cdbs->prev_cpu_nice = cur_nice;\r\n}\r\nif (unlikely(!time_elapsed)) {\r\nload = j_cdbs->prev_load;\r\n} else if (unlikely(time_elapsed > 2 * sampling_rate &&\r\nj_cdbs->prev_load)) {\r\nload = j_cdbs->prev_load;\r\nj_cdbs->prev_load = 0;\r\n} else {\r\nif (time_elapsed >= idle_time) {\r\nload = 100 * (time_elapsed - idle_time) / time_elapsed;\r\n} else {\r\nload = (int)idle_time < 0 ? 100 : 0;\r\n}\r\nj_cdbs->prev_load = load;\r\n}\r\nif (time_elapsed > 2 * sampling_rate) {\r\nunsigned int periods = time_elapsed / sampling_rate;\r\nif (periods < idle_periods)\r\nidle_periods = periods;\r\n}\r\nif (load > max_load)\r\nmax_load = load;\r\n}\r\npolicy_dbs->idle_periods = idle_periods;\r\nreturn max_load;\r\n}\r\nstatic void dbs_work_handler(struct work_struct *work)\r\n{\r\nstruct policy_dbs_info *policy_dbs;\r\nstruct cpufreq_policy *policy;\r\nstruct dbs_governor *gov;\r\npolicy_dbs = container_of(work, struct policy_dbs_info, work);\r\npolicy = policy_dbs->policy;\r\ngov = dbs_governor_of(policy);\r\nmutex_lock(&policy_dbs->update_mutex);\r\ngov_update_sample_delay(policy_dbs, gov->gov_dbs_update(policy));\r\nmutex_unlock(&policy_dbs->update_mutex);\r\natomic_set(&policy_dbs->work_count, 0);\r\nsmp_wmb();\r\npolicy_dbs->work_in_progress = false;\r\n}\r\nstatic void dbs_irq_work(struct irq_work *irq_work)\r\n{\r\nstruct policy_dbs_info *policy_dbs;\r\npolicy_dbs = container_of(irq_work, struct policy_dbs_info, irq_work);\r\nschedule_work_on(smp_processor_id(), &policy_dbs->work);\r\n}\r\nstatic void dbs_update_util_handler(struct update_util_data *data, u64 time,\r\nunsigned int flags)\r\n{\r\nstruct cpu_dbs_info *cdbs = container_of(data, struct cpu_dbs_info, update_util);\r\nstruct policy_dbs_info *policy_dbs = cdbs->policy_dbs;\r\nu64 delta_ns, lst;\r\nif (policy_dbs->work_in_progress)\r\nreturn;\r\nsmp_rmb();\r\nlst = READ_ONCE(policy_dbs->last_sample_time);\r\ndelta_ns = time - lst;\r\nif ((s64)delta_ns < policy_dbs->sample_delay_ns)\r\nreturn;\r\nif (policy_dbs->is_shared) {\r\nif (!atomic_add_unless(&policy_dbs->work_count, 1, 1))\r\nreturn;\r\nif (unlikely(lst != READ_ONCE(policy_dbs->last_sample_time))) {\r\natomic_set(&policy_dbs->work_count, 0);\r\nreturn;\r\n}\r\n}\r\npolicy_dbs->last_sample_time = time;\r\npolicy_dbs->work_in_progress = true;\r\nirq_work_queue(&policy_dbs->irq_work);\r\n}\r\nstatic void gov_set_update_util(struct policy_dbs_info *policy_dbs,\r\nunsigned int delay_us)\r\n{\r\nstruct cpufreq_policy *policy = policy_dbs->policy;\r\nint cpu;\r\ngov_update_sample_delay(policy_dbs, delay_us);\r\npolicy_dbs->last_sample_time = 0;\r\nfor_each_cpu(cpu, policy->cpus) {\r\nstruct cpu_dbs_info *cdbs = &per_cpu(cpu_dbs, cpu);\r\ncpufreq_add_update_util_hook(cpu, &cdbs->update_util,\r\ndbs_update_util_handler);\r\n}\r\n}\r\nstatic inline void gov_clear_update_util(struct cpufreq_policy *policy)\r\n{\r\nint i;\r\nfor_each_cpu(i, policy->cpus)\r\ncpufreq_remove_update_util_hook(i);\r\nsynchronize_sched();\r\n}\r\nstatic struct policy_dbs_info *alloc_policy_dbs_info(struct cpufreq_policy *policy,\r\nstruct dbs_governor *gov)\r\n{\r\nstruct policy_dbs_info *policy_dbs;\r\nint j;\r\npolicy_dbs = gov->alloc();\r\nif (!policy_dbs)\r\nreturn NULL;\r\npolicy_dbs->policy = policy;\r\nmutex_init(&policy_dbs->update_mutex);\r\natomic_set(&policy_dbs->work_count, 0);\r\ninit_irq_work(&policy_dbs->irq_work, dbs_irq_work);\r\nINIT_WORK(&policy_dbs->work, dbs_work_handler);\r\nfor_each_cpu(j, policy->related_cpus) {\r\nstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\r\nj_cdbs->policy_dbs = policy_dbs;\r\n}\r\nreturn policy_dbs;\r\n}\r\nstatic void free_policy_dbs_info(struct policy_dbs_info *policy_dbs,\r\nstruct dbs_governor *gov)\r\n{\r\nint j;\r\nmutex_destroy(&policy_dbs->update_mutex);\r\nfor_each_cpu(j, policy_dbs->policy->related_cpus) {\r\nstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\r\nj_cdbs->policy_dbs = NULL;\r\nj_cdbs->update_util.func = NULL;\r\n}\r\ngov->free(policy_dbs);\r\n}\r\nint cpufreq_dbs_governor_init(struct cpufreq_policy *policy)\r\n{\r\nstruct dbs_governor *gov = dbs_governor_of(policy);\r\nstruct dbs_data *dbs_data;\r\nstruct policy_dbs_info *policy_dbs;\r\nunsigned int latency;\r\nint ret = 0;\r\nif (policy->governor_data)\r\nreturn -EBUSY;\r\npolicy_dbs = alloc_policy_dbs_info(policy, gov);\r\nif (!policy_dbs)\r\nreturn -ENOMEM;\r\nmutex_lock(&gov_dbs_data_mutex);\r\ndbs_data = gov->gdbs_data;\r\nif (dbs_data) {\r\nif (WARN_ON(have_governor_per_policy())) {\r\nret = -EINVAL;\r\ngoto free_policy_dbs_info;\r\n}\r\npolicy_dbs->dbs_data = dbs_data;\r\npolicy->governor_data = policy_dbs;\r\ngov_attr_set_get(&dbs_data->attr_set, &policy_dbs->list);\r\ngoto out;\r\n}\r\ndbs_data = kzalloc(sizeof(*dbs_data), GFP_KERNEL);\r\nif (!dbs_data) {\r\nret = -ENOMEM;\r\ngoto free_policy_dbs_info;\r\n}\r\ngov_attr_set_init(&dbs_data->attr_set, &policy_dbs->list);\r\nret = gov->init(dbs_data);\r\nif (ret)\r\ngoto free_policy_dbs_info;\r\nlatency = policy->cpuinfo.transition_latency / 1000;\r\nif (latency == 0)\r\nlatency = 1;\r\ndbs_data->min_sampling_rate = max(dbs_data->min_sampling_rate,\r\nMIN_LATENCY_MULTIPLIER * latency);\r\ndbs_data->sampling_rate = max(dbs_data->min_sampling_rate,\r\nLATENCY_MULTIPLIER * latency);\r\nif (!have_governor_per_policy())\r\ngov->gdbs_data = dbs_data;\r\npolicy_dbs->dbs_data = dbs_data;\r\npolicy->governor_data = policy_dbs;\r\ngov->kobj_type.sysfs_ops = &governor_sysfs_ops;\r\nret = kobject_init_and_add(&dbs_data->attr_set.kobj, &gov->kobj_type,\r\nget_governor_parent_kobj(policy),\r\n"%s", gov->gov.name);\r\nif (!ret)\r\ngoto out;\r\npr_err("initialization failed (dbs_data kobject init error %d)\n", ret);\r\npolicy->governor_data = NULL;\r\nif (!have_governor_per_policy())\r\ngov->gdbs_data = NULL;\r\ngov->exit(dbs_data);\r\nkfree(dbs_data);\r\nfree_policy_dbs_info:\r\nfree_policy_dbs_info(policy_dbs, gov);\r\nout:\r\nmutex_unlock(&gov_dbs_data_mutex);\r\nreturn ret;\r\n}\r\nvoid cpufreq_dbs_governor_exit(struct cpufreq_policy *policy)\r\n{\r\nstruct dbs_governor *gov = dbs_governor_of(policy);\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nunsigned int count;\r\nmutex_lock(&gov_dbs_data_mutex);\r\ncount = gov_attr_set_put(&dbs_data->attr_set, &policy_dbs->list);\r\npolicy->governor_data = NULL;\r\nif (!count) {\r\nif (!have_governor_per_policy())\r\ngov->gdbs_data = NULL;\r\ngov->exit(dbs_data);\r\nkfree(dbs_data);\r\n}\r\nfree_policy_dbs_info(policy_dbs, gov);\r\nmutex_unlock(&gov_dbs_data_mutex);\r\n}\r\nint cpufreq_dbs_governor_start(struct cpufreq_policy *policy)\r\n{\r\nstruct dbs_governor *gov = dbs_governor_of(policy);\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nstruct dbs_data *dbs_data = policy_dbs->dbs_data;\r\nunsigned int sampling_rate, ignore_nice, j;\r\nunsigned int io_busy;\r\nif (!policy->cur)\r\nreturn -EINVAL;\r\npolicy_dbs->is_shared = policy_is_shared(policy);\r\npolicy_dbs->rate_mult = 1;\r\nsampling_rate = dbs_data->sampling_rate;\r\nignore_nice = dbs_data->ignore_nice_load;\r\nio_busy = dbs_data->io_is_busy;\r\nfor_each_cpu(j, policy->cpus) {\r\nstruct cpu_dbs_info *j_cdbs = &per_cpu(cpu_dbs, j);\r\nj_cdbs->prev_cpu_idle = get_cpu_idle_time(j, &j_cdbs->prev_update_time, io_busy);\r\nj_cdbs->prev_load = 0;\r\nif (ignore_nice)\r\nj_cdbs->prev_cpu_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE];\r\n}\r\ngov->start(policy);\r\ngov_set_update_util(policy_dbs, sampling_rate);\r\nreturn 0;\r\n}\r\nvoid cpufreq_dbs_governor_stop(struct cpufreq_policy *policy)\r\n{\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\ngov_clear_update_util(policy_dbs->policy);\r\nirq_work_sync(&policy_dbs->irq_work);\r\ncancel_work_sync(&policy_dbs->work);\r\natomic_set(&policy_dbs->work_count, 0);\r\npolicy_dbs->work_in_progress = false;\r\n}\r\nvoid cpufreq_dbs_governor_limits(struct cpufreq_policy *policy)\r\n{\r\nstruct policy_dbs_info *policy_dbs = policy->governor_data;\r\nmutex_lock(&policy_dbs->update_mutex);\r\ncpufreq_policy_apply_limits(policy);\r\ngov_update_sample_delay(policy_dbs, 0);\r\nmutex_unlock(&policy_dbs->update_mutex);\r\n}
